head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.14;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.06;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.17;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2008 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "util/u_format.h"
#include "util/u_memory.h"
#include "util/u_simple_list.h"

#include "tr_dump.h"
#include "tr_dump_defines.h"
#include "tr_dump_state.h"
#include "tr_texture.h"
#include "tr_context.h"
#include "tr_screen.h"
#include "tr_public.h"


static boolean trace = FALSE;

static const char *
trace_screen_get_name(struct pipe_screen *_screen)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   const char *result;

   trace_dump_call_begin("pipe_screen", "get_name");

   trace_dump_arg(ptr, screen);

   result = screen->get_name(screen);

   trace_dump_ret(string, result);

   trace_dump_call_end();

   return result;
}


static const char *
trace_screen_get_vendor(struct pipe_screen *_screen)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   const char *result;

   trace_dump_call_begin("pipe_screen", "get_vendor");

   trace_dump_arg(ptr, screen);

   result = screen->get_vendor(screen);

   trace_dump_ret(string, result);

   trace_dump_call_end();

   return result;
}


static int
trace_screen_get_param(struct pipe_screen *_screen,
                       enum pipe_cap param)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   int result;

   trace_dump_call_begin("pipe_screen", "get_param");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(int, param);

   result = screen->get_param(screen, param);

   trace_dump_ret(int, result);

   trace_dump_call_end();

   return result;
}


static int
trace_screen_get_shader_param(struct pipe_screen *_screen, unsigned shader,
                       enum pipe_shader_cap param)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   int result;

   trace_dump_call_begin("pipe_screen", "get_shader_param");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(uint, shader);
   trace_dump_arg(int, param);

   result = screen->get_shader_param(screen, shader, param);

   trace_dump_ret(int, result);

   trace_dump_call_end();

   return result;
}


static float
trace_screen_get_paramf(struct pipe_screen *_screen,
                        enum pipe_capf param)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   float result;

   trace_dump_call_begin("pipe_screen", "get_paramf");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(int, param);

   result = screen->get_paramf(screen, param);

   trace_dump_ret(float, result);

   trace_dump_call_end();

   return result;
}


static boolean
trace_screen_is_format_supported(struct pipe_screen *_screen,
                                 enum pipe_format format,
                                 enum pipe_texture_target target,
                                 unsigned sample_count,
                                 unsigned tex_usage)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   boolean result;

   trace_dump_call_begin("pipe_screen", "is_format_supported");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(format, format);
   trace_dump_arg(int, target);
   trace_dump_arg(uint, sample_count);
   trace_dump_arg(uint, tex_usage);

   result = screen->is_format_supported(screen, format, target, sample_count,
                                        tex_usage);

   trace_dump_ret(bool, result);

   trace_dump_call_end();

   return result;
}


static struct pipe_context *
trace_screen_context_create(struct pipe_screen *_screen, void *priv)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_context *result;

   trace_dump_call_begin("pipe_screen", "context_create");

   trace_dump_arg(ptr, screen);

   result = screen->context_create(screen, priv);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   result = trace_context_create(tr_scr, result);

   return result;
}


static void
trace_screen_flush_frontbuffer(struct pipe_screen *_screen,
                               struct pipe_resource *_resource,
                               unsigned level, unsigned layer,
                               void *context_private,
                               struct pipe_box *sub_box)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct trace_resource *tr_res = trace_resource(_resource);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_resource *resource = tr_res->resource;

   trace_dump_call_begin("pipe_screen", "flush_frontbuffer");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(ptr, resource);
   trace_dump_arg(uint, level);
   trace_dump_arg(uint, layer);
   /* XXX: hide, as there is nothing we can do with this
   trace_dump_arg(ptr, context_private);
   */

   screen->flush_frontbuffer(screen, resource, level, layer, context_private, sub_box);

   trace_dump_call_end();
}


/********************************************************************
 * texture
 */


static struct pipe_resource *
trace_screen_resource_create(struct pipe_screen *_screen,
                            const struct pipe_resource *templat)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_resource *result;

   trace_dump_call_begin("pipe_screen", "resource_create");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(resource_template, templat);

   result = screen->resource_create(screen, templat);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   result = trace_resource_create(tr_scr, result);

   return result;
}

static struct pipe_resource *
trace_screen_resource_from_handle(struct pipe_screen *_screen,
                                 const struct pipe_resource *templ,
                                 struct winsys_handle *handle)
{
   struct trace_screen *tr_screen = trace_screen(_screen);
   struct pipe_screen *screen = tr_screen->screen;
   struct pipe_resource *result;

   /* TODO trace call */

   result = screen->resource_from_handle(screen, templ, handle);

   result = trace_resource_create(trace_screen(_screen), result);

   return result;
}

static boolean
trace_screen_resource_get_handle(struct pipe_screen *_screen,
                                struct pipe_resource *_resource,
                                struct winsys_handle *handle)
{
   struct trace_screen *tr_screen = trace_screen(_screen);
   struct trace_resource *tr_resource = trace_resource(_resource);
   struct pipe_screen *screen = tr_screen->screen;
   struct pipe_resource *resource = tr_resource->resource;

   /* TODO trace call */

   return screen->resource_get_handle(screen, resource, handle);
}



static void
trace_screen_resource_destroy(struct pipe_screen *_screen,
			      struct pipe_resource *_resource)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct trace_resource *tr_res = trace_resource(_resource);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_resource *resource = tr_res->resource;

   assert(resource->screen == screen);

   trace_dump_call_begin("pipe_screen", "resource_destroy");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(ptr, resource);

   trace_dump_call_end();

   trace_resource_destroy(tr_scr, tr_res);
}


/********************************************************************
 * fence
 */


static void
trace_screen_fence_reference(struct pipe_screen *_screen,
                             struct pipe_fence_handle **pdst,
                             struct pipe_fence_handle *src)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_fence_handle *dst;

   assert(pdst);
   dst = *pdst;
   
   trace_dump_call_begin("pipe_screen", "fence_reference");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(ptr, dst);
   trace_dump_arg(ptr, src);

   screen->fence_reference(screen, pdst, src);

   trace_dump_call_end();
}


static boolean
trace_screen_fence_signalled(struct pipe_screen *_screen,
                             struct pipe_fence_handle *fence)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   int result;

   trace_dump_call_begin("pipe_screen", "fence_signalled");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(ptr, fence);

   result = screen->fence_signalled(screen, fence);

   trace_dump_ret(bool, result);

   trace_dump_call_end();

   return result;
}


static boolean
trace_screen_fence_finish(struct pipe_screen *_screen,
                          struct pipe_fence_handle *fence,
                          uint64_t timeout)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   int result;

   trace_dump_call_begin("pipe_screen", "fence_finish");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(ptr, fence);
   trace_dump_arg(uint, timeout);

   result = screen->fence_finish(screen, fence, timeout);

   trace_dump_ret(bool, result);

   trace_dump_call_end();

   return result;
}


/********************************************************************
 * screen
 */

static uint64_t
trace_screen_get_timestamp(struct pipe_screen *_screen)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   uint64_t result;

   trace_dump_call_begin("pipe_screen", "get_timestamp");
   trace_dump_arg(ptr, screen);

   result = screen->get_timestamp(screen);

   trace_dump_ret(uint, result);
   trace_dump_call_end();

   return result;
}

static void
trace_screen_destroy(struct pipe_screen *_screen)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;

   trace_dump_call_begin("pipe_screen", "destroy");
   trace_dump_arg(ptr, screen);
   trace_dump_call_end();

   screen->destroy(screen);

   FREE(tr_scr);
}

boolean
trace_enabled(void)
{
   static boolean firstrun = TRUE;

   if (!firstrun)
      return trace;
   firstrun = FALSE;

   if(trace_dump_trace_begin()) {
      trace_dumping_start();
      trace = TRUE;
   }

   return trace;
}

struct pipe_screen *
trace_screen_create(struct pipe_screen *screen)
{
   struct trace_screen *tr_scr;

   if(!screen)
      goto error1;

   if (!trace_enabled())
      goto error1;

   trace_dump_call_begin("", "pipe_screen_create");

   tr_scr = CALLOC_STRUCT(trace_screen);
   if(!tr_scr)
      goto error2;

   tr_scr->base.destroy = trace_screen_destroy;
   tr_scr->base.get_name = trace_screen_get_name;
   tr_scr->base.get_vendor = trace_screen_get_vendor;
   tr_scr->base.get_param = trace_screen_get_param;
   tr_scr->base.get_shader_param = trace_screen_get_shader_param;
   tr_scr->base.get_paramf = trace_screen_get_paramf;
   tr_scr->base.is_format_supported = trace_screen_is_format_supported;
   assert(screen->context_create);
   tr_scr->base.context_create = trace_screen_context_create;
   tr_scr->base.resource_create = trace_screen_resource_create;
   tr_scr->base.resource_from_handle = trace_screen_resource_from_handle;
   tr_scr->base.resource_get_handle = trace_screen_resource_get_handle;
   tr_scr->base.resource_destroy = trace_screen_resource_destroy;
   tr_scr->base.fence_reference = trace_screen_fence_reference;
   tr_scr->base.fence_signalled = trace_screen_fence_signalled;
   tr_scr->base.fence_finish = trace_screen_fence_finish;
   tr_scr->base.flush_frontbuffer = trace_screen_flush_frontbuffer;
   tr_scr->base.get_timestamp = trace_screen_get_timestamp;

   tr_scr->screen = screen;

   trace_dump_ret(ptr, screen);
   trace_dump_call_end();

   return &tr_scr->base;

error2:
   trace_dump_ret(ptr, screen);
   trace_dump_call_end();
error1:
   return screen;
}


struct trace_screen *
trace_screen(struct pipe_screen *screen)
{
   assert(screen);
   assert(screen->destroy == trace_screen_destroy);
   return (struct trace_screen *)screen;
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d33 1
a39 2
#include "pipe/p_format.h"

d212 2
a213 1
                               void *context_private)
d230 1
a230 1
   screen->flush_frontbuffer(screen, resource, level, layer, context_private);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d135 1
a135 1
                        enum pipe_cap param)
a321 43

/********************************************************************
 * buffer
 */



static struct pipe_resource *
trace_screen_user_buffer_create(struct pipe_screen *_screen,
                                void *data,
                                unsigned size,
				unsigned usage)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_resource *result;

   trace_dump_call_begin("pipe_screen", "user_buffer_create");

   trace_dump_arg(ptr, screen);
   trace_dump_arg_begin("data");
   trace_dump_bytes(data, size);
   trace_dump_arg_end();
   trace_dump_arg(uint, size);
   trace_dump_arg(uint, usage);

   result = screen->user_buffer_create(screen, data, size, usage);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   if(result) {
      assert(!(result->flags & TRACE_FLAG_USER_BUFFER));
      result->flags |= TRACE_FLAG_USER_BUFFER;
   }

   return trace_resource_create(tr_scr, result);
}




d403 18
a429 1
   trace_dump_trace_end();
a456 1
   struct pipe_winsys *winsys;
a469 8
#if 0
   winsys = trace_winsys_create(screen->winsys);
   if(!winsys)
      goto error3;
#else
   winsys = screen->winsys;
#endif
   tr_scr->base.winsys = winsys;
a482 1
   tr_scr->base.user_buffer_create = trace_screen_user_buffer_create;
d487 1
a498 1
   trace_dump_trace_end();
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d120 1
a120 1
   trace_dump_arg(int, shader);
d161 1
a161 2
                                 unsigned tex_usage,
                                 unsigned geom_flags)
a173 1
   trace_dump_arg(uint, geom_flags);
d176 1
a176 1
                                        tex_usage, geom_flags);
d285 1
a285 1
                                struct pipe_resource *_texture,
d289 1
a289 1
   struct trace_resource *tr_texture = trace_resource(_texture);
d291 1
a291 1
   struct pipe_resource *texture = tr_texture->resource;
d295 1
a295 1
   return screen->resource_get_handle(screen, texture, handle);
d302 1
a302 1
			      struct pipe_resource *_texture)
d305 1
a305 1
   struct trace_resource *tr_tex = trace_resource(_texture);
d307 1
a307 1
   struct pipe_resource *texture = tr_tex->resource;
d309 1
a309 1
   assert(texture->screen == screen);
d311 1
a311 1
   trace_dump_call_begin("pipe_screen", "texture_destroy");
d314 1
a314 1
   trace_dump_arg(ptr, texture);
d318 1
a318 1
   trace_resource_destroy(tr_scr, tr_tex);
d394 1
a394 1
static int
d396 1
a396 2
                             struct pipe_fence_handle *fence,
                             unsigned flags)
a405 1
   trace_dump_arg(uint, flags);
d407 1
a407 1
   result = screen->fence_signalled(screen, fence, flags);
d409 1
a409 1
   trace_dump_ret(int, result);
d417 1
a417 1
static int
d420 1
a420 1
                          unsigned flags)
d430 1
a430 1
   trace_dump_arg(uint, flags);
d432 1
a432 1
   result = screen->fence_finish(screen, fence, flags);
d434 1
a434 1
   trace_dump_ret(int, result);
a469 2

   trace_dump_init();
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a31 1
#include "tr_buffer.h"
d37 1
a38 1
#include "util/u_inlines.h"
a42 1
static boolean rbug = FALSE;
d88 1
a88 1
                       int param)
d109 24
d135 1
a135 1
                        int param)
d160 1
d173 1
d177 2
a178 1
   result = screen->is_format_supported(screen, format, target, tex_usage, geom_flags);
d213 2
a214 1
                               struct pipe_surface *_surface,
d218 1
a218 1
   struct trace_surface *tr_surf = trace_surface(_surface);
d220 1
a220 1
   struct pipe_surface *surface = tr_surf->surface;
d225 3
a227 1
   trace_dump_arg(ptr, surface);
d232 1
a232 1
   screen->flush_frontbuffer(screen, surface, context_private);
d243 3
a245 3
static struct pipe_texture *
trace_screen_texture_create(struct pipe_screen *_screen,
                            const struct pipe_texture *templat)
d249 1
a249 1
   struct pipe_texture *result;
d251 1
a251 1
   trace_dump_call_begin("pipe_screen", "texture_create");
d254 1
a254 1
   trace_dump_arg(template, templat);
d256 1
a256 1
   result = screen->texture_create(screen, templat);
d262 1
a262 1
   result = trace_texture_create(tr_scr, result);
d267 4
a270 6

static struct pipe_texture *
trace_screen_texture_blanket(struct pipe_screen *_screen,
                             const struct pipe_texture *templat,
                             const unsigned *ppitch,
                             struct pipe_buffer *_buffer)
d272 3
a274 8
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct trace_buffer *tr_buf = trace_buffer(_buffer);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_buffer *buffer = tr_buf->buffer;
   unsigned pitch = *ppitch;
   struct pipe_texture *result;

   trace_dump_call_begin("pipe_screen", "texture_blanket");
d276 1
a276 8
   trace_dump_arg(ptr, screen);
   trace_dump_arg(template, templat);
   trace_dump_arg(uint, pitch);
   trace_dump_arg(ptr, buffer);

   result = screen->texture_blanket(screen, templat, ppitch, buffer);

   trace_dump_ret(ptr, result);
d278 1
a278 1
   trace_dump_call_end();
d280 1
a280 1
   result = trace_texture_create(tr_scr, result);
d285 4
a288 3

static void
trace_screen_texture_destroy(struct pipe_texture *_texture)
d290 4
a293 11
   struct trace_screen *tr_scr = trace_screen(_texture->screen);
   struct trace_texture *tr_tex = trace_texture(_texture);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_texture *texture = tr_tex->texture;

   assert(texture->screen == screen);

   trace_dump_call_begin("pipe_screen", "texture_destroy");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(ptr, texture);
d295 1
a295 1
   trace_dump_call_end();
d297 1
a297 1
   trace_texture_destroy(tr_tex);
a300 40
/********************************************************************
 * surface
 */


static struct pipe_surface *
trace_screen_get_tex_surface(struct pipe_screen *_screen,
                             struct pipe_texture *_texture,
                             unsigned face, unsigned level,
                             unsigned zslice,
                             unsigned usage)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct trace_texture *tr_tex = trace_texture(_texture);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_texture *texture = tr_tex->texture;
   struct pipe_surface *result = NULL;

   assert(texture->screen == screen);

   trace_dump_call_begin("pipe_screen", "get_tex_surface");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(ptr, texture);
   trace_dump_arg(uint, face);
   trace_dump_arg(uint, level);
   trace_dump_arg(uint, zslice);
   trace_dump_arg(uint, usage);

   result = screen->get_tex_surface(screen, texture, face, level, zslice, usage);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   result = trace_surface_create(tr_tex, result);

   return result;
}

d303 2
a304 30
trace_screen_tex_surface_destroy(struct pipe_surface *_surface)
{
   struct trace_screen *tr_scr = trace_screen(_surface->texture->screen);
   struct trace_surface *tr_surf = trace_surface(_surface);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_surface *surface = tr_surf->surface;

   trace_dump_call_begin("pipe_screen", "tex_surface_destroy");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(ptr, surface);

   trace_dump_call_end();

   trace_surface_destroy(tr_surf);
}


/********************************************************************
 * transfer
 */


static struct pipe_transfer *
trace_screen_get_tex_transfer(struct pipe_screen *_screen,
                              struct pipe_texture *_texture,
                              unsigned face, unsigned level,
                              unsigned zslice,
                              enum pipe_transfer_usage usage,
                              unsigned x, unsigned y, unsigned w, unsigned h)
d307 1
a307 1
   struct trace_texture *tr_tex = trace_texture(_texture);
d309 1
a309 2
   struct pipe_texture *texture = tr_tex->texture;
   struct pipe_transfer *result = NULL;
d313 1
a313 1
   trace_dump_call_begin("pipe_screen", "get_tex_transfer");
a316 14
   trace_dump_arg(uint, face);
   trace_dump_arg(uint, level);
   trace_dump_arg(uint, zslice);
   trace_dump_arg(uint, usage);

   trace_dump_arg(uint, x);
   trace_dump_arg(uint, y);
   trace_dump_arg(uint, w);
   trace_dump_arg(uint, h);

   result = screen->get_tex_transfer(screen, texture, face, level, zslice, usage,
                                     x, y, w, h);

   trace_dump_ret(ptr, result);
d320 1
a320 4
   if (result)
      result = trace_transfer_create(tr_tex, result);

   return result;
a323 79
static void
trace_screen_tex_transfer_destroy(struct pipe_transfer *_transfer)
{
   struct trace_screen *tr_scr = trace_screen(_transfer->texture->screen);
   struct trace_transfer *tr_trans = trace_transfer(_transfer);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_transfer *transfer = tr_trans->transfer;

   trace_dump_call_begin("pipe_screen", "tex_transfer_destroy");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(ptr, transfer);

   trace_dump_call_end();

   trace_transfer_destroy(tr_trans);
}


static void *
trace_screen_transfer_map(struct pipe_screen *_screen,
                          struct pipe_transfer *_transfer)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct trace_transfer *tr_trans = trace_transfer(_transfer);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_transfer *transfer = tr_trans->transfer;
   void *map;

   map = screen->transfer_map(screen, transfer);
   if(map) {
      if(transfer->usage & PIPE_TRANSFER_WRITE) {
         assert(!tr_trans->map);
         tr_trans->map = map;
      }
   }

   return map;
}


static void
trace_screen_transfer_unmap(struct pipe_screen *_screen,
                           struct pipe_transfer *_transfer)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct trace_transfer *tr_trans = trace_transfer(_transfer);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_transfer *transfer = tr_trans->transfer;

   if(tr_trans->map) {
      size_t size = util_format_get_nblocksy(transfer->texture->format, transfer->height) * transfer->stride;

      trace_dump_call_begin("pipe_screen", "transfer_write");

      trace_dump_arg(ptr, screen);

      trace_dump_arg(ptr, transfer);

      trace_dump_arg_begin("stride");
      trace_dump_uint(transfer->stride);
      trace_dump_arg_end();

      trace_dump_arg_begin("data");
      trace_dump_bytes(tr_trans->map, size);
      trace_dump_arg_end();

      trace_dump_arg_begin("size");
      trace_dump_uint(size);
      trace_dump_arg_end();

      trace_dump_call_end();

      tr_trans->map = NULL;
   }

   screen->transfer_unmap(screen, transfer);
}

a329 59
static struct pipe_buffer *
trace_screen_surface_buffer_create(struct pipe_screen *_screen,
                                   unsigned width, unsigned height,
                                   enum pipe_format format,
                                   unsigned usage,
                                   unsigned tex_usage,
                                   unsigned *pstride)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   unsigned stride;
   struct pipe_buffer *result;

   trace_dump_call_begin("pipe_screen", "surface_buffer_create");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(uint, width);
   trace_dump_arg(uint, height);
   trace_dump_arg(format, format);
   trace_dump_arg(uint, usage);
   trace_dump_arg(uint, tex_usage);

   result = screen->surface_buffer_create(screen,
                                          width, height,
                                          format,
                                          usage,
                                          tex_usage,
                                          pstride);

   stride = *pstride;

   trace_dump_arg(uint, stride);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   return trace_buffer_create(tr_scr, result);
}


static struct pipe_buffer *
trace_screen_buffer_create(struct pipe_screen *_screen,
                           unsigned alignment,
                           unsigned usage,
                           unsigned size)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_buffer *result;

   trace_dump_call_begin("pipe_screen", "buffer_create");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(uint, alignment);
   trace_dump_arg(uint, usage);
   trace_dump_arg(uint, size);

   result = screen->buffer_create(screen, alignment, usage, size);
d331 1
a331 19
   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   /* Zero the buffer to avoid dumping uninitialized memory */
   if(result->usage & PIPE_BUFFER_USAGE_CPU_WRITE) {
      void *map;
      map = pipe_buffer_map(screen, result, PIPE_BUFFER_USAGE_CPU_WRITE);
      if(map) {
         memset(map, 0, result->size);
         screen->buffer_unmap(screen, result);
      }
   }

   return trace_buffer_create(tr_scr, result);
}


static struct pipe_buffer *
d334 2
a335 1
                                unsigned size)
d339 1
a339 1
   struct pipe_buffer *result;
d348 1
d350 1
a350 1
   result = screen->user_buffer_create(screen, data, size);
d357 2
a358 64
      assert(!(result->usage & TRACE_BUFFER_USAGE_USER));
      result->usage |= TRACE_BUFFER_USAGE_USER;
   }

   return trace_buffer_create(tr_scr, result);
}


/**
 * This function is used to track if data has been changed on a user buffer
 * without map/unmap being called.
 */
void
trace_screen_user_buffer_update(struct pipe_screen *_screen,
                                struct pipe_buffer *_buffer)
{
#if 0
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   const void *map;

   if(buffer && buffer->usage & TRACE_BUFFER_USAGE_USER) {
      map = screen->buffer_map(screen, buffer, PIPE_BUFFER_USAGE_CPU_READ);
      if(map) {
         trace_dump_call_begin("pipe_winsys", "buffer_write");

         trace_dump_arg(ptr, screen);

         trace_dump_arg(ptr, buffer);

         trace_dump_arg_begin("data");
         trace_dump_bytes(map, buffer->size);
         trace_dump_arg_end();

         trace_dump_arg_begin("size");
         trace_dump_uint(buffer->size);
         trace_dump_arg_end();

         trace_dump_call_end();

         screen->buffer_unmap(screen, buffer);
      }
   }
#endif
}


static void *
trace_screen_buffer_map(struct pipe_screen *_screen,
                        struct pipe_buffer *_buffer,
                        unsigned usage)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct trace_buffer *tr_buf = trace_buffer(_buffer);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_buffer *buffer = tr_buf->buffer;
   void *map;

   assert(screen->buffer_map);
   map = screen->buffer_map(screen, buffer, usage);
   if(map) {
      if(usage & PIPE_BUFFER_USAGE_CPU_WRITE) {
         tr_buf->map = map;
      }
d361 1
a361 1
   return map;
a364 105
static void *
trace_screen_buffer_map_range(struct pipe_screen *_screen,
                              struct pipe_buffer *_buffer,
                              unsigned offset,
                              unsigned length,
                              unsigned usage)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct trace_buffer *tr_buf = trace_buffer(_buffer);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_buffer *buffer = tr_buf->buffer;
   void *map;

   assert(screen->buffer_map_range);
   map = screen->buffer_map_range(screen, buffer, offset, length, usage);
   if(map) {
      if(usage & PIPE_BUFFER_USAGE_CPU_WRITE) {
         tr_buf->map = map;
      }
   }

   return map;
}


static void
buffer_write(struct pipe_screen *screen,
             struct pipe_buffer *buffer,
             unsigned offset,
             const char *map,
             unsigned size)
{
   assert(map);

   trace_dump_call_begin("pipe_screen", "buffer_write");

   trace_dump_arg(ptr, screen);

   trace_dump_arg(ptr, buffer);

   trace_dump_arg(uint, offset);

   trace_dump_arg_begin("data");
   trace_dump_bytes(map + offset, size);
   trace_dump_arg_end();

   trace_dump_arg(uint, size);

   trace_dump_call_end();

}


static void
trace_screen_buffer_flush_mapped_range(struct pipe_screen *_screen,
                                       struct pipe_buffer *_buffer,
                                       unsigned offset,
                                       unsigned length)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct trace_buffer *tr_buf = trace_buffer(_buffer);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_buffer *buffer = tr_buf->buffer;

   assert(tr_buf->map);
   buffer_write(screen, buffer, offset, tr_buf->map, length);
   tr_buf->range_flushed = TRUE;
   screen->buffer_flush_mapped_range(screen, buffer, offset, length);
}


static void
trace_screen_buffer_unmap(struct pipe_screen *_screen,
                          struct pipe_buffer *_buffer)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct trace_buffer *tr_buf = trace_buffer(_buffer);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_buffer *buffer = tr_buf->buffer;

   if (tr_buf->map && !tr_buf->range_flushed)
      buffer_write(screen, buffer, 0, tr_buf->map, buffer->size);
   tr_buf->map = NULL;
   tr_buf->range_flushed = FALSE;
   screen->buffer_unmap(screen, buffer);
}


static void
trace_screen_buffer_destroy(struct pipe_buffer *_buffer)
{
   struct trace_screen *tr_scr = trace_screen(_buffer->screen);
   struct trace_buffer *tr_buf = trace_buffer(_buffer);
   struct pipe_screen *screen = tr_scr->screen;
   struct pipe_buffer *buffer = tr_buf->buffer;

   trace_dump_call_begin("pipe_screen", "buffer_destroy");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(ptr, buffer);

   trace_dump_call_end();

   trace_buffer_destroy(tr_scr, _buffer);
}
a460 3
   if (tr_scr->rbug)
      trace_rbug_stop(tr_scr->rbug);

a481 5
   if (debug_get_bool_option("GALLIUM_RBUG", FALSE)) {
      trace = TRUE;
      rbug = TRUE;
   }

a509 7
   pipe_mutex_init(tr_scr->list_mutex);
   make_empty_list(&tr_scr->buffers);
   make_empty_list(&tr_scr->contexts);
   make_empty_list(&tr_scr->textures);
   make_empty_list(&tr_scr->surfaces);
   make_empty_list(&tr_scr->transfers);

d515 1
d520 4
a523 10
   tr_scr->base.texture_create = trace_screen_texture_create;
   tr_scr->base.texture_blanket = trace_screen_texture_blanket;
   tr_scr->base.texture_destroy = trace_screen_texture_destroy;
   tr_scr->base.get_tex_surface = trace_screen_get_tex_surface;
   tr_scr->base.tex_surface_destroy = trace_screen_tex_surface_destroy;
   tr_scr->base.get_tex_transfer = trace_screen_get_tex_transfer;
   tr_scr->base.tex_transfer_destroy = trace_screen_tex_transfer_destroy;
   tr_scr->base.transfer_map = trace_screen_transfer_map;
   tr_scr->base.transfer_unmap = trace_screen_transfer_unmap;
   tr_scr->base.buffer_create = trace_screen_buffer_create;
a524 10
   tr_scr->base.surface_buffer_create = trace_screen_surface_buffer_create;
   if (screen->buffer_map)
      tr_scr->base.buffer_map = trace_screen_buffer_map;
   if (screen->buffer_map_range)
      tr_scr->base.buffer_map_range = trace_screen_buffer_map_range;
   if (screen->buffer_flush_mapped_range)
      tr_scr->base.buffer_flush_mapped_range = trace_screen_buffer_flush_mapped_range;
   if (screen->buffer_unmap)
      tr_scr->base.buffer_unmap = trace_screen_buffer_unmap;
   tr_scr->base.buffer_destroy = trace_screen_buffer_destroy;
d529 1
a534 3
   if (rbug)
      tr_scr->rbug = trace_rbug_start(tr_scr);

a536 4
#if 0
error3:
   FREE(tr_scr);
#endif
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d32 1
a37 1
#include "tr_public.h"
d39 1
d44 1
d90 1
a90 1
                       enum pipe_cap param)
a110 24
static int
trace_screen_get_shader_param(struct pipe_screen *_screen, unsigned shader,
                       enum pipe_shader_cap param)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   int result;

   trace_dump_call_begin("pipe_screen", "get_shader_param");

   trace_dump_arg(ptr, screen);
   trace_dump_arg(int, shader);
   trace_dump_arg(int, param);

   result = screen->get_shader_param(screen, shader, param);

   trace_dump_ret(int, result);

   trace_dump_call_end();

   return result;
}


d113 1
a113 1
                        enum pipe_cap param)
a137 1
                                 unsigned sample_count,
a149 1
   trace_dump_arg(uint, sample_count);
d153 1
a153 2
   result = screen->is_format_supported(screen, format, target, sample_count,
                                        tex_usage, geom_flags);
d188 1
a188 2
                               struct pipe_resource *_resource,
                               unsigned level, unsigned layer,
d192 1
a192 1
   struct trace_resource *tr_res = trace_resource(_resource);
d194 1
a194 1
   struct pipe_resource *resource = tr_res->resource;
d199 1
a199 3
   trace_dump_arg(ptr, resource);
   trace_dump_arg(uint, level);
   trace_dump_arg(uint, layer);
d204 1
a204 1
   screen->flush_frontbuffer(screen, resource, level, layer, context_private);
d215 3
a217 3
static struct pipe_resource *
trace_screen_resource_create(struct pipe_screen *_screen,
                            const struct pipe_resource *templat)
d221 1
a221 1
   struct pipe_resource *result;
d223 1
a223 1
   trace_dump_call_begin("pipe_screen", "resource_create");
d226 1
a226 1
   trace_dump_arg(resource_template, templat);
d228 1
a228 1
   result = screen->resource_create(screen, templat);
d234 1
a234 1
   result = trace_resource_create(tr_scr, result);
d239 6
a244 4
static struct pipe_resource *
trace_screen_resource_from_handle(struct pipe_screen *_screen,
                                 const struct pipe_resource *templ,
                                 struct winsys_handle *handle)
d246 8
a253 3
   struct trace_screen *tr_screen = trace_screen(_screen);
   struct pipe_screen *screen = tr_screen->screen;
   struct pipe_resource *result;
d255 8
a262 1
   /* TODO trace call */
d264 1
a264 1
   result = screen->resource_from_handle(screen, templ, handle);
d266 1
a266 1
   result = trace_resource_create(trace_screen(_screen), result);
d271 3
a273 4
static boolean
trace_screen_resource_get_handle(struct pipe_screen *_screen,
                                struct pipe_resource *_texture,
                                struct winsys_handle *handle)
d275 11
a285 4
   struct trace_screen *tr_screen = trace_screen(_screen);
   struct trace_resource *tr_texture = trace_resource(_texture);
   struct pipe_screen *screen = tr_screen->screen;
   struct pipe_resource *texture = tr_texture->resource;
d287 1
a287 1
   /* TODO trace call */
d289 1
a289 1
   return screen->resource_get_handle(screen, texture, handle);
d293 40
d335 30
a364 2
trace_screen_resource_destroy(struct pipe_screen *_screen,
			      struct pipe_resource *_texture)
d367 1
a367 1
   struct trace_resource *tr_tex = trace_resource(_texture);
d369 2
a370 1
   struct pipe_resource *texture = tr_tex->resource;
d374 1
a374 1
   trace_dump_call_begin("pipe_screen", "texture_destroy");
d378 14
d395 4
a398 1
   trace_resource_destroy(tr_scr, tr_tex);
d402 79
d487 59
d547 19
a565 1
static struct pipe_resource *
d568 1
a568 2
                                unsigned size,
				unsigned usage)
d572 1
a572 1
   struct pipe_resource *result;
a580 1
   trace_dump_arg(uint, usage);
d582 1
a582 1
   result = screen->user_buffer_create(screen, data, size, usage);
d589 64
a652 2
      assert(!(result->flags & TRACE_FLAG_USER_BUFFER));
      result->flags |= TRACE_FLAG_USER_BUFFER;
d655 1
a655 1
   return trace_resource_create(tr_scr, result);
d659 105
d860 3
d884 5
d917 7
a928 1
   tr_scr->base.get_shader_param = trace_screen_get_shader_param;
d933 10
a942 4
   tr_scr->base.resource_create = trace_screen_resource_create;
   tr_scr->base.resource_from_handle = trace_screen_resource_from_handle;
   tr_scr->base.resource_get_handle = trace_screen_resource_get_handle;
   tr_scr->base.resource_destroy = trace_screen_resource_destroy;
d944 10
a957 1

d963 3
d968 4
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d120 1
a120 1
   trace_dump_arg(uint, shader);
d135 1
a135 1
                        enum pipe_capf param)
d161 2
a162 1
                                 unsigned tex_usage)
d175 1
d178 1
a178 1
                                        tex_usage);
d287 1
a287 1
                                struct pipe_resource *_resource,
d291 1
a291 1
   struct trace_resource *tr_resource = trace_resource(_resource);
d293 1
a293 1
   struct pipe_resource *resource = tr_resource->resource;
d297 1
a297 1
   return screen->resource_get_handle(screen, resource, handle);
d304 1
a304 1
			      struct pipe_resource *_resource)
d307 1
a307 1
   struct trace_resource *tr_res = trace_resource(_resource);
d309 21
a329 1
   struct pipe_resource *resource = tr_res->resource;
d331 9
a339 1
   assert(resource->screen == screen);
d341 1
a341 1
   trace_dump_call_begin("pipe_screen", "resource_destroy");
d344 9
a352 1
   trace_dump_arg(ptr, resource);
d356 6
a361 1
   trace_resource_destroy(tr_scr, tr_res);
d365 2
d396 1
a396 1
static boolean
d398 2
a399 1
                             struct pipe_fence_handle *fence)
d409 1
d411 1
a411 1
   result = screen->fence_signalled(screen, fence);
d413 1
a413 1
   trace_dump_ret(bool, result);
d421 1
a421 1
static boolean
d424 1
a424 1
                          uint64_t timeout)
d434 1
a434 1
   trace_dump_arg(uint, timeout);
d436 1
a436 1
   result = screen->fence_finish(screen, fence, timeout);
d438 1
a438 1
   trace_dump_ret(bool, result);
a449 18
static uint64_t
trace_screen_get_timestamp(struct pipe_screen *_screen)
{
   struct trace_screen *tr_scr = trace_screen(_screen);
   struct pipe_screen *screen = tr_scr->screen;
   uint64_t result;

   trace_dump_call_begin("pipe_screen", "get_timestamp");
   trace_dump_arg(ptr, screen);

   result = screen->get_timestamp(screen);

   trace_dump_ret(uint, result);
   trace_dump_call_end();

   return result;
}

d459 1
d475 2
d489 1
d503 8
d524 1
a528 1
   tr_scr->base.get_timestamp = trace_screen_get_timestamp;
d540 1
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2008 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a32 1
#include "tr_dump_defines.h"
d39 2
d213 1
a213 2
                               void *context_private,
                               struct pipe_box *sub_box)
d230 1
a230 1
   screen->flush_frontbuffer(screen, resource, level, layer, context_private, sub_box);
@


