head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.35;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.53;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.16;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.55;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.01.13;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.06;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.13.06;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.17;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.09.00;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.46.16;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2008 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "util/u_inlines.h"
#include "util/u_memory.h"
#include "util/u_simple_list.h"

#include "pipe/p_format.h"
#include "pipe/p_screen.h"

#include "tr_dump.h"
#include "tr_dump_defines.h"
#include "tr_dump_state.h"
#include "tr_public.h"
#include "tr_screen.h"
#include "tr_texture.h"
#include "tr_context.h"


struct trace_query
{
   unsigned type;

   struct pipe_query *query;
};


static INLINE struct trace_query *
trace_query(struct pipe_query *query) {
   return (struct trace_query *)query;
}


static INLINE struct pipe_query *
trace_query_unwrap(struct pipe_query *query)
{
   if (query) {
      return trace_query(query)->query;
   } else {
      return NULL;
   }
}


static INLINE struct pipe_resource *
trace_resource_unwrap(struct trace_context *tr_ctx,
                     struct pipe_resource *resource)
{
   struct trace_resource *tr_res;

   if(!resource)
      return NULL;

   tr_res = trace_resource(resource);

   assert(tr_res->resource);
   return tr_res->resource;
}


static INLINE struct pipe_surface *
trace_surface_unwrap(struct trace_context *tr_ctx,
                     struct pipe_surface *surface)
{
   struct trace_screen *tr_scr = trace_screen(tr_ctx->base.screen);
   struct trace_surface *tr_surf;

   if(!surface)
      return NULL;

   assert(surface->texture);
   if(!surface->texture)
      return surface;

   tr_surf = trace_surface(surface);

   assert(tr_surf->surface);
   assert(tr_surf->surface->texture->screen == tr_scr->screen);
   (void) tr_scr;
   return tr_surf->surface;
}


static INLINE void
trace_context_draw_vbo(struct pipe_context *_pipe,
                       const struct pipe_draw_info *info)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "draw_vbo");

   trace_dump_arg(ptr,  pipe);
   trace_dump_arg(draw_info, info);

   trace_dump_trace_flush();

   pipe->draw_vbo(pipe, info);

   trace_dump_call_end();
}


static INLINE struct pipe_query *
trace_context_create_query(struct pipe_context *_pipe,
                           unsigned query_type)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_query *query;

   trace_dump_call_begin("pipe_context", "create_query");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(query_type, query_type);

   query = pipe->create_query(pipe, query_type);

   trace_dump_ret(ptr, query);

   trace_dump_call_end();

   /* Wrap query object. */
   if (query) {
      struct trace_query *tr_query = CALLOC_STRUCT(trace_query);
      if (tr_query) {
         tr_query->type = query_type;
         tr_query->query = query;
         query = (struct pipe_query *)tr_query;
      } else {
         pipe->destroy_query(pipe, query);
         query = NULL;
      }
   }

   return query;
}


static INLINE void
trace_context_destroy_query(struct pipe_context *_pipe,
                            struct pipe_query *_query)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct trace_query *tr_query = trace_query(_query);
   struct pipe_query *query = tr_query->query;

   FREE(tr_query);

   trace_dump_call_begin("pipe_context", "destroy_query");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, query);

   pipe->destroy_query(pipe, query);

   trace_dump_call_end();
}


static INLINE void
trace_context_begin_query(struct pipe_context *_pipe,
                          struct pipe_query *query)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   query = trace_query_unwrap(query);

   trace_dump_call_begin("pipe_context", "begin_query");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, query);

   pipe->begin_query(pipe, query);

   trace_dump_call_end();
}


static INLINE void
trace_context_end_query(struct pipe_context *_pipe,
                        struct pipe_query *query)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   query = trace_query_unwrap(query);

   trace_dump_call_begin("pipe_context", "end_query");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, query);

   pipe->end_query(pipe, query);

   trace_dump_call_end();
}


static INLINE boolean
trace_context_get_query_result(struct pipe_context *_pipe,
                               struct pipe_query *_query,
                               boolean wait,
                               union pipe_query_result *result)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct trace_query *tr_query = trace_query(_query);
   struct pipe_query *query = tr_query->query;
   boolean ret;

   trace_dump_call_begin("pipe_context", "get_query_result");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, query);

   ret = pipe->get_query_result(pipe, query, wait, result);

   trace_dump_arg_begin("result");
   if (ret) {
      trace_dump_query_result(tr_query->type, result);
   } else {
      trace_dump_null();
   }
   trace_dump_arg_end();

   trace_dump_ret(bool, ret);

   trace_dump_call_end();

   return ret;
}


static INLINE void *
trace_context_create_blend_state(struct pipe_context *_pipe,
                                 const struct pipe_blend_state *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   void * result;

   trace_dump_call_begin("pipe_context", "create_blend_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(blend_state, state);

   result = pipe->create_blend_state(pipe, state);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   return result;
}


static INLINE void
trace_context_bind_blend_state(struct pipe_context *_pipe,
                               void *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "bind_blend_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, state);

   pipe->bind_blend_state(pipe, state);

   trace_dump_call_end();
}


static INLINE void
trace_context_delete_blend_state(struct pipe_context *_pipe,
                                 void *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "delete_blend_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, state);

   pipe->delete_blend_state(pipe, state);

   trace_dump_call_end();
}


static INLINE void *
trace_context_create_sampler_state(struct pipe_context *_pipe,
                                   const struct pipe_sampler_state *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   void * result;

   trace_dump_call_begin("pipe_context", "create_sampler_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(sampler_state, state);

   result = pipe->create_sampler_state(pipe, state);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   return result;
}


static INLINE void
trace_context_bind_sampler_states(struct pipe_context *_pipe,
                                  unsigned shader,
                                  unsigned start,
                                  unsigned num_states,
                                  void **states)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   /* remove this when we have pipe->bind_sampler_states(..., start, ...) */
   assert(start == 0);

   trace_dump_call_begin("pipe_context", "bind_sampler_states");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, shader);
   trace_dump_arg(uint, start);
   trace_dump_arg(uint, num_states);
   trace_dump_arg_array(ptr, states, num_states);

   pipe->bind_sampler_states(pipe, shader, start, num_states, states);

   trace_dump_call_end();
}


static INLINE void
trace_context_delete_sampler_state(struct pipe_context *_pipe,
                                   void *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "delete_sampler_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, state);

   pipe->delete_sampler_state(pipe, state);

   trace_dump_call_end();
}


static INLINE void *
trace_context_create_rasterizer_state(struct pipe_context *_pipe,
                                      const struct pipe_rasterizer_state *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   void * result;

   trace_dump_call_begin("pipe_context", "create_rasterizer_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(rasterizer_state, state);

   result = pipe->create_rasterizer_state(pipe, state);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   return result;
}


static INLINE void
trace_context_bind_rasterizer_state(struct pipe_context *_pipe,
                                    void *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "bind_rasterizer_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, state);

   pipe->bind_rasterizer_state(pipe, state);

   trace_dump_call_end();
}


static INLINE void
trace_context_delete_rasterizer_state(struct pipe_context *_pipe,
                                      void *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "delete_rasterizer_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, state);

   pipe->delete_rasterizer_state(pipe, state);

   trace_dump_call_end();
}


static INLINE void *
trace_context_create_depth_stencil_alpha_state(struct pipe_context *_pipe,
                                               const struct pipe_depth_stencil_alpha_state *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   void * result;

   trace_dump_call_begin("pipe_context", "create_depth_stencil_alpha_state");

   result = pipe->create_depth_stencil_alpha_state(pipe, state);

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(depth_stencil_alpha_state, state);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   return result;
}


static INLINE void
trace_context_bind_depth_stencil_alpha_state(struct pipe_context *_pipe,
                                             void *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "bind_depth_stencil_alpha_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, state);

   pipe->bind_depth_stencil_alpha_state(pipe, state);

   trace_dump_call_end();
}


static INLINE void
trace_context_delete_depth_stencil_alpha_state(struct pipe_context *_pipe,
                                               void *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "delete_depth_stencil_alpha_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, state);

   pipe->delete_depth_stencil_alpha_state(pipe, state);

   trace_dump_call_end();
}


#define TRACE_SHADER_STATE(shader_type) \
   static INLINE void * \
   trace_context_create_##shader_type##_state(struct pipe_context *_pipe, \
                                 const struct pipe_shader_state *state) \
   { \
      struct trace_context *tr_ctx = trace_context(_pipe); \
      struct pipe_context *pipe = tr_ctx->pipe; \
      void * result; \
      trace_dump_call_begin("pipe_context", "create_" #shader_type "_state"); \
      trace_dump_arg(ptr, pipe); \
      trace_dump_arg(shader_state, state); \
      result = pipe->create_##shader_type##_state(pipe, state); \
      trace_dump_ret(ptr, result); \
      trace_dump_call_end(); \
      return result; \
   } \
    \
   static INLINE void \
   trace_context_bind_##shader_type##_state(struct pipe_context *_pipe, \
                               void *state) \
   { \
      struct trace_context *tr_ctx = trace_context(_pipe); \
      struct pipe_context *pipe = tr_ctx->pipe; \
      trace_dump_call_begin("pipe_context", "bind_" #shader_type "_state"); \
      trace_dump_arg(ptr, pipe); \
      trace_dump_arg(ptr, state); \
      pipe->bind_##shader_type##_state(pipe, state); \
      trace_dump_call_end(); \
   } \
    \
   static INLINE void \
   trace_context_delete_##shader_type##_state(struct pipe_context *_pipe, \
                                 void *state) \
   { \
      struct trace_context *tr_ctx = trace_context(_pipe); \
      struct pipe_context *pipe = tr_ctx->pipe; \
      trace_dump_call_begin("pipe_context", "delete_" #shader_type "_state"); \
      trace_dump_arg(ptr, pipe); \
      trace_dump_arg(ptr, state); \
      pipe->delete_##shader_type##_state(pipe, state); \
      trace_dump_call_end(); \
   }

TRACE_SHADER_STATE(fs)
TRACE_SHADER_STATE(vs)
TRACE_SHADER_STATE(gs)

#undef TRACE_SHADER_STATE


static INLINE void *
trace_context_create_vertex_elements_state(struct pipe_context *_pipe,
                                           unsigned num_elements,
                                           const struct  pipe_vertex_element *elements)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   void * result;

   trace_dump_call_begin("pipe_context", "create_vertex_elements_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, num_elements);

   trace_dump_arg_begin("elements");
   trace_dump_struct_array(vertex_element, elements, num_elements);
   trace_dump_arg_end();

   result = pipe->create_vertex_elements_state(pipe, num_elements, elements);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   return result;
}


static INLINE void
trace_context_bind_vertex_elements_state(struct pipe_context *_pipe,
                                         void *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "bind_vertex_elements_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, state);

   pipe->bind_vertex_elements_state(pipe, state);

   trace_dump_call_end();
}


static INLINE void
trace_context_delete_vertex_elements_state(struct pipe_context *_pipe,
                                           void *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "delete_vertex_elements_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, state);

   pipe->delete_vertex_elements_state(pipe, state);

   trace_dump_call_end();
}


static INLINE void
trace_context_set_blend_color(struct pipe_context *_pipe,
                              const struct pipe_blend_color *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "set_blend_color");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(blend_color, state);

   pipe->set_blend_color(pipe, state);

   trace_dump_call_end();
}


static INLINE void
trace_context_set_stencil_ref(struct pipe_context *_pipe,
                              const struct pipe_stencil_ref *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "set_stencil_ref");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(stencil_ref, state);

   pipe->set_stencil_ref(pipe, state);

   trace_dump_call_end();
}


static INLINE void
trace_context_set_clip_state(struct pipe_context *_pipe,
                             const struct pipe_clip_state *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "set_clip_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(clip_state, state);

   pipe->set_clip_state(pipe, state);

   trace_dump_call_end();
}

static INLINE void
trace_context_set_sample_mask(struct pipe_context *_pipe,
                              unsigned sample_mask)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "set_sample_mask");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, sample_mask);

   pipe->set_sample_mask(pipe, sample_mask);

   trace_dump_call_end();
}

static INLINE void
trace_context_set_constant_buffer(struct pipe_context *_pipe,
                                  uint shader, uint index,
                                  struct pipe_constant_buffer *constant_buffer)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_constant_buffer cb;

   if (constant_buffer) {
      cb = *constant_buffer;
      cb.buffer = trace_resource_unwrap(tr_ctx, constant_buffer->buffer);
      constant_buffer = &cb;
   }

   trace_dump_call_begin("pipe_context", "set_constant_buffer");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, shader);
   trace_dump_arg(uint, index);
   trace_dump_arg(constant_buffer, constant_buffer);

   pipe->set_constant_buffer(pipe, shader, index, constant_buffer);

   trace_dump_call_end();
}


static INLINE void
trace_context_set_framebuffer_state(struct pipe_context *_pipe,
                                    const struct pipe_framebuffer_state *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_framebuffer_state unwrapped_state;
   unsigned i;


   /* Unwrap the input state */
   memcpy(&unwrapped_state, state, sizeof(unwrapped_state));
   for(i = 0; i < state->nr_cbufs; ++i)
      unwrapped_state.cbufs[i] = trace_surface_unwrap(tr_ctx, state->cbufs[i]);
   for(i = state->nr_cbufs; i < PIPE_MAX_COLOR_BUFS; ++i)
      unwrapped_state.cbufs[i] = NULL;
   unwrapped_state.zsbuf = trace_surface_unwrap(tr_ctx, state->zsbuf);
   state = &unwrapped_state;

   trace_dump_call_begin("pipe_context", "set_framebuffer_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(framebuffer_state, state);

   pipe->set_framebuffer_state(pipe, state);

   trace_dump_call_end();
}


static INLINE void
trace_context_set_polygon_stipple(struct pipe_context *_pipe,
                                  const struct pipe_poly_stipple *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "set_polygon_stipple");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(poly_stipple, state);

   pipe->set_polygon_stipple(pipe, state);

   trace_dump_call_end();
}


static INLINE void
trace_context_set_scissor_states(struct pipe_context *_pipe,
                                 unsigned start_slot,
                                 unsigned num_scissors,
                                 const struct pipe_scissor_state *states)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "set_scissor_states");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, start_slot);
   trace_dump_arg(uint, num_scissors);
   trace_dump_arg(scissor_state, states);

   pipe->set_scissor_states(pipe, start_slot, num_scissors, states);

   trace_dump_call_end();
}


static INLINE void
trace_context_set_viewport_states(struct pipe_context *_pipe,
                                  unsigned start_slot,
                                  unsigned num_viewports,
                                  const struct pipe_viewport_state *states)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "set_viewport_states");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, start_slot);
   trace_dump_arg(uint, num_viewports);
   trace_dump_arg(viewport_state, states);

   pipe->set_viewport_states(pipe, start_slot, num_viewports, states);

   trace_dump_call_end();
}


static struct pipe_sampler_view *
trace_context_create_sampler_view(struct pipe_context *_pipe,
                          struct pipe_resource *_resource,
                          const struct pipe_sampler_view *templ)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct trace_resource *tr_res = trace_resource(_resource);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_resource *resource = tr_res->resource;
   struct pipe_sampler_view *result;
   struct trace_sampler_view *tr_view;

   trace_dump_call_begin("pipe_context", "create_sampler_view");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, resource);

   trace_dump_arg_begin("templ");
   trace_dump_sampler_view_template(templ, resource->target);
   trace_dump_arg_end();

   result = pipe->create_sampler_view(pipe, resource, templ);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   /*
    * Wrap pipe_sampler_view
    */
   tr_view = CALLOC_STRUCT(trace_sampler_view);
   tr_view->base = *templ;
   tr_view->base.reference.count = 1;
   tr_view->base.texture = NULL;
   pipe_resource_reference(&tr_view->base.texture, _resource);
   tr_view->base.context = _pipe;
   tr_view->sampler_view = result;
   result = &tr_view->base;

   return result;
}


static void
trace_context_sampler_view_destroy(struct pipe_context *_pipe,
                           struct pipe_sampler_view *_view)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct trace_sampler_view *tr_view = trace_sampler_view(_view);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_sampler_view *view = tr_view->sampler_view;

   assert(_view->context == _pipe);

   trace_dump_call_begin("pipe_context", "sampler_view_destroy");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, view);

   pipe_sampler_view_reference(&tr_view->sampler_view, NULL);

   trace_dump_call_end();

   pipe_resource_reference(&_view->texture, NULL);
   FREE(_view);
}

/********************************************************************
 * surface
 */


static struct pipe_surface *
trace_context_create_surface(struct pipe_context *_pipe,
                             struct pipe_resource *_resource,
                             const struct pipe_surface *surf_tmpl)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct trace_resource *tr_res = trace_resource(_resource);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_resource *resource = tr_res->resource;
   struct pipe_surface *result = NULL;

   trace_dump_call_begin("pipe_context", "create_surface");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, resource);
   
   trace_dump_arg_begin("surf_tmpl");
   trace_dump_surface_template(surf_tmpl, resource->target);
   trace_dump_arg_end();


   result = pipe->create_surface(pipe, resource, surf_tmpl);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   result = trace_surf_create(tr_ctx, tr_res, result);

   return result;
}


static void
trace_context_surface_destroy(struct pipe_context *_pipe,
                              struct pipe_surface *_surface)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct trace_surface *tr_surf = trace_surface(_surface);
   struct pipe_surface *surface = tr_surf->surface;

   trace_dump_call_begin("pipe_context", "surface_destroy");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, surface);

   trace_dump_call_end();

   trace_surf_destroy(tr_surf);
}


static INLINE void
trace_context_set_sampler_views(struct pipe_context *_pipe,
                                unsigned shader,
                                unsigned start,
                                unsigned num,
                                struct pipe_sampler_view **views)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct trace_sampler_view *tr_view;
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_SHADER_SAMPLER_VIEWS];
   unsigned i;

   /* remove this when we have pipe->set_sampler_views(..., start, ...) */
   assert(start == 0);

   for(i = 0; i < num; ++i) {
      tr_view = trace_sampler_view(views[i]);
      unwrapped_views[i] = tr_view ? tr_view->sampler_view : NULL;
   }
   views = unwrapped_views;

   trace_dump_call_begin("pipe_context", "set_sampler_views");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, shader);
   trace_dump_arg(uint, start);
   trace_dump_arg(uint, num);
   trace_dump_arg_array(ptr, views, num);

   pipe->set_sampler_views(pipe, shader, start, num, views);

   trace_dump_call_end();
}


static INLINE void
trace_context_set_vertex_buffers(struct pipe_context *_pipe,
                                 unsigned start_slot, unsigned num_buffers,
                                 const struct pipe_vertex_buffer *buffers)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   unsigned i;

   trace_dump_call_begin("pipe_context", "set_vertex_buffers");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, start_slot);
   trace_dump_arg(uint, num_buffers);

   trace_dump_arg_begin("buffers");
   trace_dump_struct_array(vertex_buffer, buffers, num_buffers);
   trace_dump_arg_end();

   if (buffers) {
      struct pipe_vertex_buffer *_buffers = MALLOC(num_buffers * sizeof(*_buffers));
      memcpy(_buffers, buffers, num_buffers * sizeof(*_buffers));
      for (i = 0; i < num_buffers; i++)
         _buffers[i].buffer = trace_resource_unwrap(tr_ctx, buffers[i].buffer);
      pipe->set_vertex_buffers(pipe, start_slot, num_buffers, _buffers);
      FREE(_buffers);
   } else {
      pipe->set_vertex_buffers(pipe, start_slot, num_buffers, NULL);
   }

   trace_dump_call_end();
}


static INLINE void
trace_context_set_index_buffer(struct pipe_context *_pipe,
                               const struct pipe_index_buffer *ib)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "set_index_buffer");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(index_buffer, ib);

   if (ib) {
      struct pipe_index_buffer _ib;
      _ib = *ib;
      _ib.buffer = trace_resource_unwrap(tr_ctx, ib->buffer);
      pipe->set_index_buffer(pipe, &_ib);
   } else {
      pipe->set_index_buffer(pipe, NULL);
   }

   trace_dump_call_end();
}


static INLINE struct pipe_stream_output_target *
trace_context_create_stream_output_target(struct pipe_context *_pipe,
                                          struct pipe_resource *res,
                                          unsigned buffer_offset,
                                          unsigned buffer_size)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_stream_output_target *result;

   res = trace_resource_unwrap(tr_ctx, res);

   trace_dump_call_begin("pipe_context", "create_stream_output_target");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, res);
   trace_dump_arg(uint, buffer_offset);
   trace_dump_arg(uint, buffer_size);

   result = pipe->create_stream_output_target(pipe,
                                              res, buffer_offset, buffer_size);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   return result;
}


static INLINE void
trace_context_stream_output_target_destroy(
   struct pipe_context *_pipe,
   struct pipe_stream_output_target *target)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "stream_output_target_destroy");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, target);

   pipe->stream_output_target_destroy(pipe, target);

   trace_dump_call_end();
}


static INLINE void
trace_context_set_stream_output_targets(struct pipe_context *_pipe,
                                        unsigned num_targets,
                                        struct pipe_stream_output_target **tgs,
                                        const unsigned *offsets)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "set_stream_output_targets");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, num_targets);
   trace_dump_arg_array(ptr, tgs, num_targets);
   trace_dump_arg_array(uint, offsets, num_targets);

   pipe->set_stream_output_targets(pipe, num_targets, tgs, offsets);

   trace_dump_call_end();
}


static INLINE void
trace_context_resource_copy_region(struct pipe_context *_pipe,
                                   struct pipe_resource *dst,
                                   unsigned dst_level,
                                   unsigned dstx, unsigned dsty, unsigned dstz,
                                   struct pipe_resource *src,
                                   unsigned src_level,
                                   const struct pipe_box *src_box)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   dst = trace_resource_unwrap(tr_ctx, dst);
   src = trace_resource_unwrap(tr_ctx, src);

   trace_dump_call_begin("pipe_context", "resource_copy_region");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, dst);
   trace_dump_arg(uint, dst_level);
   trace_dump_arg(uint, dstx);
   trace_dump_arg(uint, dsty);
   trace_dump_arg(uint, dstz);
   trace_dump_arg(ptr, src);
   trace_dump_arg(uint, src_level);
   trace_dump_arg(box, src_box);

   pipe->resource_copy_region(pipe,
                              dst, dst_level, dstx, dsty, dstz,
                              src, src_level, src_box);

   trace_dump_call_end();
}


static INLINE void
trace_context_blit(struct pipe_context *_pipe,
                   const struct pipe_blit_info *_info)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_blit_info info = *_info;

   info.dst.resource = trace_resource_unwrap(tr_ctx, info.dst.resource);
   info.src.resource = trace_resource_unwrap(tr_ctx, info.src.resource);

   trace_dump_call_begin("pipe_context", "blit");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(blit_info, _info);

   pipe->blit(pipe, &info);

   trace_dump_call_end();
}


static void
trace_context_flush_resource(struct pipe_context *_pipe,
                             struct pipe_resource *resource)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   resource = trace_resource_unwrap(tr_ctx, resource);

   trace_dump_call_begin("pipe_context", "flush_resource");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, resource);

   pipe->flush_resource(pipe, resource);

   trace_dump_call_end();
}


static INLINE void
trace_context_clear(struct pipe_context *_pipe,
                    unsigned buffers,
                    const union pipe_color_union *color,
                    double depth,
                    unsigned stencil)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "clear");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, buffers);
   trace_dump_arg_begin("color");
   if (color)
      trace_dump_array(float, color->f, 4);
   else
      trace_dump_null();
   trace_dump_arg_end();
   trace_dump_arg(float, depth);
   trace_dump_arg(uint, stencil);

   pipe->clear(pipe, buffers, color, depth, stencil);

   trace_dump_call_end();
}


static INLINE void
trace_context_clear_render_target(struct pipe_context *_pipe,
                                  struct pipe_surface *dst,
                                  const union pipe_color_union *color,
                                  unsigned dstx, unsigned dsty,
                                  unsigned width, unsigned height)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   dst = trace_surface_unwrap(tr_ctx, dst);

   trace_dump_call_begin("pipe_context", "clear_render_target");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, dst);
   trace_dump_arg_array(float, color->f, 4);
   trace_dump_arg(uint, dstx);
   trace_dump_arg(uint, dsty);
   trace_dump_arg(uint, width);
   trace_dump_arg(uint, height);

   pipe->clear_render_target(pipe, dst, color, dstx, dsty, width, height);

   trace_dump_call_end();
}

static INLINE void
trace_context_clear_depth_stencil(struct pipe_context *_pipe,
                                  struct pipe_surface *dst,
                                  unsigned clear_flags,
                                  double depth,
                                  unsigned stencil,
                                  unsigned dstx, unsigned dsty,
                                  unsigned width, unsigned height)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   dst = trace_surface_unwrap(tr_ctx, dst);

   trace_dump_call_begin("pipe_context", "clear_depth_stencil");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, dst);
   trace_dump_arg(uint, clear_flags);
   trace_dump_arg(float, depth);
   trace_dump_arg(uint, stencil);
   trace_dump_arg(uint, dstx);
   trace_dump_arg(uint, dsty);
   trace_dump_arg(uint, width);
   trace_dump_arg(uint, height);

   pipe->clear_depth_stencil(pipe, dst, clear_flags, depth, stencil,
                             dstx, dsty, width, height);

   trace_dump_call_end();
}

static INLINE void
trace_context_flush(struct pipe_context *_pipe,
                    struct pipe_fence_handle **fence,
                    unsigned flags)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "flush");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, flags);

   pipe->flush(pipe, fence, flags);

   if(fence)
      trace_dump_ret(ptr, *fence);

   trace_dump_call_end();
}


static INLINE void
trace_context_destroy(struct pipe_context *_pipe)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "destroy");
   trace_dump_arg(ptr, pipe);
   trace_dump_call_end();

   pipe->destroy(pipe);

   FREE(tr_ctx);
}


/********************************************************************
 * transfer
 */


static void *
trace_context_transfer_map(struct pipe_context *_context,
                           struct pipe_resource *_resource,
                           unsigned level,
                           unsigned usage,
                           const struct pipe_box *box,
                           struct pipe_transfer **transfer)
{
   struct trace_context *tr_context = trace_context(_context);
   struct trace_resource *tr_res = trace_resource(_resource);
   struct pipe_context *context = tr_context->pipe;
   struct pipe_resource *texture = tr_res->resource;
   struct pipe_transfer *result = NULL;
   void *map;

   assert(texture->screen == context->screen);

   /*
    * Map and transfers can't be serialized so we convert all write transfers
    * to transfer_inline_write and ignore read transfers.
    */

   map = context->transfer_map(context, texture, level, usage, box, &result);
   if (!map)
      return NULL;

   *transfer = trace_transfer_create(tr_context, tr_res, result);

   if (map) {
      if(usage & PIPE_TRANSFER_WRITE) {
         trace_transfer(*transfer)->map = map;
      }
   }

   return *transfer ? map : NULL;
}

static void
trace_context_transfer_flush_region( struct pipe_context *_context,
				     struct pipe_transfer *_transfer,
				     const struct pipe_box *box)
{
   struct trace_context *tr_context = trace_context(_context);
   struct trace_transfer *tr_transfer = trace_transfer(_transfer);
   struct pipe_context *context = tr_context->pipe;
   struct pipe_transfer *transfer = tr_transfer->transfer;

   context->transfer_flush_region(context,
				  transfer,
				  box);
}

static void
trace_context_transfer_unmap(struct pipe_context *_context,
                             struct pipe_transfer *_transfer)
{
   struct trace_context *tr_ctx = trace_context(_context);
   struct trace_transfer *tr_trans = trace_transfer(_transfer);
   struct pipe_context *context = tr_ctx->pipe;
   struct pipe_transfer *transfer = tr_trans->transfer;

   if(tr_trans->map) {
      /*
       * Fake a transfer_inline_write
       */

      struct pipe_resource *resource = transfer->resource;
      unsigned level = transfer->level;
      unsigned usage = transfer->usage;
      const struct pipe_box *box = &transfer->box;
      unsigned stride = transfer->stride;
      unsigned layer_stride = transfer->layer_stride;

      trace_dump_call_begin("pipe_context", "transfer_inline_write");

      trace_dump_arg(ptr, context);
      trace_dump_arg(ptr, resource);
      trace_dump_arg(uint, level);
      trace_dump_arg(uint, usage);
      trace_dump_arg(box, box);

      trace_dump_arg_begin("data");
      trace_dump_box_bytes(tr_trans->map,
                           resource,
                           box,
                           stride,
                           layer_stride);
      trace_dump_arg_end();

      trace_dump_arg(uint, stride);
      trace_dump_arg(uint, layer_stride);

      trace_dump_call_end();

      tr_trans->map = NULL;
   }

   context->transfer_unmap(context, transfer);
   trace_transfer_destroy(tr_ctx, tr_trans);
}


static void
trace_context_transfer_inline_write(struct pipe_context *_context,
                                    struct pipe_resource *_resource,
                                    unsigned level,
                                    unsigned usage,
                                    const struct pipe_box *box,
                                    const void *data,
                                    unsigned stride,
                                    unsigned layer_stride)
{
   struct trace_context *tr_context = trace_context(_context);
   struct trace_resource *tr_res = trace_resource(_resource);
   struct pipe_context *context = tr_context->pipe;
   struct pipe_resource *resource = tr_res->resource;

   assert(resource->screen == context->screen);

   trace_dump_call_begin("pipe_context", "transfer_inline_write");

   trace_dump_arg(ptr, context);
   trace_dump_arg(ptr, resource);
   trace_dump_arg(uint, level);
   trace_dump_arg(uint, usage);
   trace_dump_arg(box, box);

   trace_dump_arg_begin("data");
   trace_dump_box_bytes(data,
                        resource,
                        box,
                        stride,
                        layer_stride);
   trace_dump_arg_end();

   trace_dump_arg(uint, stride);
   trace_dump_arg(uint, layer_stride);

   trace_dump_call_end();

   context->transfer_inline_write(context, resource,
                                  level, usage, box, data, stride, layer_stride);
}


static void trace_context_render_condition(struct pipe_context *_context,
                                           struct pipe_query *query,
                                           boolean condition,
                                           uint mode)
{
   struct trace_context *tr_context = trace_context(_context);
   struct pipe_context *context = tr_context->pipe;

   query = trace_query_unwrap(query);

   trace_dump_call_begin("pipe_context", "render_condition");

   trace_dump_arg(ptr, context);
   trace_dump_arg(ptr, query);
   trace_dump_arg(bool, condition);
   trace_dump_arg(uint, mode);

   trace_dump_call_end();

   context->render_condition(context, query, condition, mode);
}


static void trace_context_texture_barrier(struct pipe_context *_context)
{
   struct trace_context *tr_context = trace_context(_context);
   struct pipe_context *context = tr_context->pipe;

   trace_dump_call_begin("pipe_context", "texture_barrier");

   trace_dump_arg(ptr, context);

   trace_dump_call_end();

   context->texture_barrier(context);
}


static void trace_context_memory_barrier(struct pipe_context *_context,
                                         unsigned flags)
{
   struct trace_context *tr_context = trace_context(_context);
   struct pipe_context *context = tr_context->pipe;

   trace_dump_call_begin("pipe_context", "memory_barrier");
   trace_dump_arg(ptr, context);
   trace_dump_arg(uint, flags);
   trace_dump_call_end();

   context->memory_barrier(context, flags);
}


static const struct debug_named_value rbug_blocker_flags[] = {
   {"before", 1, NULL},
   {"after", 2, NULL},
   DEBUG_NAMED_VALUE_END
};

struct pipe_context *
trace_context_create(struct trace_screen *tr_scr,
                     struct pipe_context *pipe)
{
   struct trace_context *tr_ctx;

   if(!pipe)
      goto error1;

   if(!trace_enabled())
      goto error1;

   tr_ctx = CALLOC_STRUCT(trace_context);
   if(!tr_ctx)
      goto error1;

   tr_ctx->base.priv = pipe->priv; /* expose wrapped priv data */
   tr_ctx->base.screen = &tr_scr->base;

   tr_ctx->base.destroy = trace_context_destroy;

#define TR_CTX_INIT(_member) \
   tr_ctx->base . _member = pipe -> _member ? trace_context_ ## _member : NULL

   TR_CTX_INIT(draw_vbo);
   TR_CTX_INIT(render_condition);
   TR_CTX_INIT(create_query);
   TR_CTX_INIT(destroy_query);
   TR_CTX_INIT(begin_query);
   TR_CTX_INIT(end_query);
   TR_CTX_INIT(get_query_result);
   TR_CTX_INIT(create_blend_state);
   TR_CTX_INIT(bind_blend_state);
   TR_CTX_INIT(delete_blend_state);
   TR_CTX_INIT(create_sampler_state);
   TR_CTX_INIT(bind_sampler_states);
   TR_CTX_INIT(delete_sampler_state);
   TR_CTX_INIT(create_rasterizer_state);
   TR_CTX_INIT(bind_rasterizer_state);
   TR_CTX_INIT(delete_rasterizer_state);
   TR_CTX_INIT(create_depth_stencil_alpha_state);
   TR_CTX_INIT(bind_depth_stencil_alpha_state);
   TR_CTX_INIT(delete_depth_stencil_alpha_state);
   TR_CTX_INIT(create_fs_state);
   TR_CTX_INIT(bind_fs_state);
   TR_CTX_INIT(delete_fs_state);
   TR_CTX_INIT(create_vs_state);
   TR_CTX_INIT(bind_vs_state);
   TR_CTX_INIT(delete_vs_state);
   TR_CTX_INIT(create_gs_state);
   TR_CTX_INIT(bind_gs_state);
   TR_CTX_INIT(delete_gs_state);
   TR_CTX_INIT(create_vertex_elements_state);
   TR_CTX_INIT(bind_vertex_elements_state);
   TR_CTX_INIT(delete_vertex_elements_state);
   TR_CTX_INIT(set_blend_color);
   TR_CTX_INIT(set_stencil_ref);
   TR_CTX_INIT(set_clip_state);
   TR_CTX_INIT(set_sample_mask);
   TR_CTX_INIT(set_constant_buffer);
   TR_CTX_INIT(set_framebuffer_state);
   TR_CTX_INIT(set_polygon_stipple);
   TR_CTX_INIT(set_scissor_states);
   TR_CTX_INIT(set_viewport_states);
   TR_CTX_INIT(set_sampler_views);
   TR_CTX_INIT(create_sampler_view);
   TR_CTX_INIT(sampler_view_destroy);
   TR_CTX_INIT(create_surface);
   TR_CTX_INIT(surface_destroy);
   TR_CTX_INIT(set_vertex_buffers);
   TR_CTX_INIT(set_index_buffer);
   TR_CTX_INIT(create_stream_output_target);
   TR_CTX_INIT(stream_output_target_destroy);
   TR_CTX_INIT(set_stream_output_targets);
   TR_CTX_INIT(resource_copy_region);
   TR_CTX_INIT(blit);
   TR_CTX_INIT(flush_resource);
   TR_CTX_INIT(clear);
   TR_CTX_INIT(clear_render_target);
   TR_CTX_INIT(clear_depth_stencil);
   TR_CTX_INIT(flush);
   TR_CTX_INIT(texture_barrier);
   TR_CTX_INIT(memory_barrier);

   TR_CTX_INIT(transfer_map);
   TR_CTX_INIT(transfer_unmap);
   TR_CTX_INIT(transfer_flush_region);
   TR_CTX_INIT(transfer_inline_write);

#undef TR_CTX_INIT

   tr_ctx->pipe = pipe;

   return &tr_ctx->base;

error1:
   return pipe;
}


/**
 * Sanity checker: check that the given context really is a 
 * trace context (and not the wrapped driver's context).
 */
void
trace_context_check(const struct pipe_context *pipe)
{
   struct trace_context *tr_ctx = (struct trace_context *) pipe;
   assert(tr_ctx->base.destroy == trace_context_destroy);
}

@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d130 1
a130 2
                           unsigned query_type,
                           unsigned index)
a139 1
   trace_dump_arg(int, index);
d141 1
a141 1
   query = pipe->create_query(pipe, query_type, index);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d130 2
a131 1
                           unsigned query_type)
d141 1
d143 1
a143 1
   query = pipe->create_query(pipe, query_type);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d36 1
d44 12
d58 10
d134 1
a134 1
   struct pipe_query *result;
d139 1
a139 1
   trace_dump_arg(uint, query_type);
d141 1
a141 1
   result = pipe->create_query(pipe, query_type);
d143 1
a143 1
   trace_dump_ret(ptr, result);
d147 14
a160 1
   return result;
d166 1
a166 1
                            struct pipe_query *query)
d170 4
d193 2
d213 2
d228 1
a228 1
                               struct pipe_query *query,
d230 1
a230 1
                               union pipe_query_result *presult)
d234 3
a236 2
   uint64_t result;
   boolean _result;
d241 1
d243 1
a243 3
   _result = pipe->get_query_result(pipe, query, wait, presult);
   /* XXX this depends on the query type */
   result = *((uint64_t*)presult);
d245 9
a253 2
   trace_dump_arg(uint, result);
   trace_dump_ret(bool, _result);
d257 1
a257 1
   return _result;
d356 1
a356 13
   switch (shader) {
   case PIPE_SHADER_VERTEX:
      trace_dump_call_begin("pipe_context", "bind_vertex_sampler_states");
      break;
   case PIPE_SHADER_GEOMETRY:
      trace_dump_call_begin("pipe_context", "bind_geometry_sampler_states");
      break;
   case PIPE_SHADER_FRAGMENT:
      trace_dump_call_begin("pipe_context", "bind_fragment_sampler_states");
      break;
   default:
      debug_error("Unexpected shader in trace_context_bind_sampler_states()");
   }
d359 2
d364 1
a364 13
   switch (shader) {
   case PIPE_SHADER_VERTEX:
      pipe->bind_vertex_sampler_states(pipe, num_states, states);
      break;
   case PIPE_SHADER_GEOMETRY:
      pipe->bind_geometry_sampler_states(pipe, num_states, states);
      break;
   case PIPE_SHADER_FRAGMENT:
      pipe->bind_fragment_sampler_states(pipe, num_states, states);
      break;
   default:
      debug_error("Unexpected shader in trace_context_bind_sampler_states()");
   }
a370 30
trace_context_bind_fragment_sampler_states(struct pipe_context *_pipe,
                                           unsigned num,
                                           void **states)
{
   trace_context_bind_sampler_states(_pipe, PIPE_SHADER_FRAGMENT,
                                     0, num, states);
}


static INLINE void
trace_context_bind_vertex_sampler_states(struct pipe_context *_pipe,
                                         unsigned num,
                                         void **states)
{
   trace_context_bind_sampler_states(_pipe, PIPE_SHADER_VERTEX,
                                     0, num, states);
}


static INLINE void
trace_context_bind_geometry_sampler_states(struct pipe_context *_pipe,
                                         unsigned num,
                                         void **states)
{
   trace_context_bind_sampler_states(_pipe, PIPE_SHADER_GEOMETRY,
                                     0, num, states);
}


static INLINE void
d945 1
a945 1
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_SAMPLERS];
d957 1
a957 13
   switch (shader) {
   case PIPE_SHADER_VERTEX:
      trace_dump_call_begin("pipe_context", "set_vertex_sampler_views");
      break;
   case PIPE_SHADER_GEOMETRY:
      trace_dump_call_begin("pipe_context", "set_geometry_sampler_views");
      break;
   case PIPE_SHADER_FRAGMENT:
      trace_dump_call_begin("pipe_context", "set_fragment_sampler_views");
      break;
   default:
      debug_error("Unexpected shader in trace_context_set_sampler_views()");
   }
d960 2
a961 1
   /*trace_dump_arg(uint, shader);*/
d965 1
a965 13
   switch (shader) {
   case PIPE_SHADER_VERTEX:
      pipe->set_vertex_sampler_views(pipe, num, views);
      break;
   case PIPE_SHADER_GEOMETRY:
      pipe->set_geometry_sampler_views(pipe, num, views);
      break;
   case PIPE_SHADER_FRAGMENT:
      pipe->set_fragment_sampler_views(pipe, num, views);
      break;
   default:
      debug_error("Unexpected shader in trace_context_set_sampler_views()");
   }
a971 27
trace_context_set_fragment_sampler_views(struct pipe_context *_pipe,
                                         unsigned num,
                                         struct pipe_sampler_view **views)
{
   trace_context_set_sampler_views(_pipe, PIPE_SHADER_FRAGMENT, 0, num, views);
}


static INLINE void
trace_context_set_vertex_sampler_views(struct pipe_context *_pipe,
                                       unsigned num,
                                       struct pipe_sampler_view **views)
{
   trace_context_set_sampler_views(_pipe, PIPE_SHADER_VERTEX, 0, num, views);
}


static INLINE void
trace_context_set_geometry_sampler_views(struct pipe_context *_pipe,
                                       unsigned num,
                                       struct pipe_sampler_view **views)
{
   trace_context_set_sampler_views(_pipe, PIPE_SHADER_GEOMETRY, 0, num, views);
}


static INLINE void
d1083 1
a1083 1
                                        unsigned append_bitmask)
d1093 1
a1093 1
   trace_dump_arg(uint, append_bitmask);
d1095 1
a1095 1
   pipe->set_stream_output_targets(pipe, num_targets, tgs, append_bitmask);
d1158 20
d1462 2
d1492 15
d1548 1
a1548 3
   TR_CTX_INIT(bind_fragment_sampler_states);
   TR_CTX_INIT(bind_vertex_sampler_states);
   TR_CTX_INIT(bind_geometry_sampler_states);
d1577 1
a1577 3
   TR_CTX_INIT(set_fragment_sampler_views);
   TR_CTX_INIT(set_vertex_sampler_views);
   TR_CTX_INIT(set_geometry_sampler_views);
d1589 1
d1595 1
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d97 2
d186 1
a186 1
                               void *presult)
d198 1
d293 5
a297 3
trace_context_bind_fragment_sampler_states(struct pipe_context *_pipe,
                                           unsigned num_states,
                                           void **states)
d302 16
a317 1
   trace_dump_call_begin("pipe_context", "bind_fragment_sampler_states");
d323 13
a335 1
   pipe->bind_fragment_sampler_states(pipe, num_states, states);
d342 10
d353 1
a353 1
                                         unsigned num_states,
d356 3
a358 2
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
a359 2
   if (!pipe->bind_vertex_sampler_states)
      return;
d361 7
a367 9
   trace_dump_call_begin("pipe_context", "bind_vertex_sampler_states");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, num_states);
   trace_dump_arg_array(ptr, states, num_states);

   pipe->bind_vertex_sampler_states(pipe, num_states, states);

   trace_dump_call_end();
d507 42
a548 7
static INLINE void *
trace_context_create_fs_state(struct pipe_context *_pipe,
                              const struct pipe_shader_state *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   void * result;
d550 3
a552 1
   trace_dump_call_begin("pipe_context", "create_fs_state");
d554 1
a554 106
   trace_dump_arg(ptr, pipe);
   trace_dump_arg(shader_state, state);

   result = pipe->create_fs_state(pipe, state);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   return result;
}


static INLINE void
trace_context_bind_fs_state(struct pipe_context *_pipe,
                            void *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "bind_fs_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, state);

   pipe->bind_fs_state(pipe, state);

   trace_dump_call_end();
}


static INLINE void
trace_context_delete_fs_state(struct pipe_context *_pipe,
                              void *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "delete_fs_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, state);

   pipe->delete_fs_state(pipe, state);

   trace_dump_call_end();
}


static INLINE void *
trace_context_create_vs_state(struct pipe_context *_pipe,
                              const struct pipe_shader_state *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   void * result;

   trace_dump_call_begin("pipe_context", "create_vs_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(shader_state, state);

   result = pipe->create_vs_state(pipe, state);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   return result;
}


static INLINE void
trace_context_bind_vs_state(struct pipe_context *_pipe,
                            void *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "bind_vs_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, state);

   pipe->bind_vs_state(pipe, state);

   trace_dump_call_end();
}


static INLINE void
trace_context_delete_vs_state(struct pipe_context *_pipe,
                              void *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "delete_vs_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, state);

   pipe->delete_vs_state(pipe, state);

   trace_dump_call_end();
}
d694 1
a694 1
                                  struct pipe_resource *buffer)
d698 1
d700 4
a703 2
   if (buffer) {
      buffer = trace_resource_unwrap(tr_ctx, buffer);
d711 1
a711 1
   trace_dump_arg(ptr, buffer);
d713 1
a713 1
   pipe->set_constant_buffer(pipe, shader, index, buffer);
d768 4
a771 2
trace_context_set_scissor_state(struct pipe_context *_pipe,
                                const struct pipe_scissor_state *state)
d776 1
a776 1
   trace_dump_call_begin("pipe_context", "set_scissor_state");
d779 3
a781 1
   trace_dump_arg(scissor_state, state);
d783 1
a783 1
   pipe->set_scissor_state(pipe, state);
d790 4
a793 2
trace_context_set_viewport_state(struct pipe_context *_pipe,
                                 const struct pipe_viewport_state *state)
d798 1
a798 1
   trace_dump_call_begin("pipe_context", "set_viewport_state");
d801 3
a803 1
   trace_dump_arg(viewport_state, state);
d805 1
a805 1
   pipe->set_viewport_state(pipe, state);
d812 1
a812 1
trace_create_sampler_view(struct pipe_context *_pipe,
d855 1
a855 1
trace_sampler_view_destroy(struct pipe_context *_pipe,
d863 2
d884 3
a886 3
trace_create_surface(struct pipe_context *_pipe,
                     struct pipe_resource *_resource,
                     const struct pipe_surface *surf_tmpl)
d910 1
a910 1
   result = trace_surf_create(tr_res, result);
d917 2
a918 2
trace_surface_destroy(struct pipe_context *_pipe,
                      struct pipe_surface *_surface)
d937 5
a941 3
trace_context_set_fragment_sampler_views(struct pipe_context *_pipe,
                                         unsigned num,
                                         struct pipe_sampler_view **views)
d949 3
d958 13
a970 1
   trace_dump_call_begin("pipe_context", "set_fragment_sampler_views");
d973 1
d977 13
a989 1
   pipe->set_fragment_sampler_views(pipe, num, views);
d996 9
d1009 2
a1010 5
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct trace_sampler_view *tr_view;
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_VERTEX_SAMPLERS];
   unsigned i;
a1011 2
   if (!pipe->set_vertex_sampler_views)
      return;
d1013 6
a1018 15
   for(i = 0; i < num; ++i) {
      tr_view = trace_sampler_view(views[i]);
      unwrapped_views[i] = tr_view ? tr_view->sampler_view : NULL;
   }
   views = unwrapped_views;

   trace_dump_call_begin("pipe_context", "set_vertex_sampler_views");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, num);
   trace_dump_arg_array(ptr, views, num);

   pipe->set_vertex_sampler_views(pipe, num, views);

   trace_dump_call_end();
d1024 1
a1024 1
                                 unsigned num_buffers,
d1034 1
d1041 1
a1041 1
   if (num_buffers) {
d1046 1
a1046 1
      pipe->set_vertex_buffers(pipe, num_buffers, _buffers);
d1049 1
a1049 1
      pipe->set_vertex_buffers(pipe, num_buffers, NULL);
d1080 72
d1188 22
d1212 1
a1212 1
                    const float *rgba,
d1223 3
a1225 2
   if (rgba)
      trace_dump_arg_array(float, rgba, 4);
d1228 1
d1232 1
a1232 1
   pipe->clear(pipe, buffers, rgba, depth, stencil);
d1241 1
a1241 1
                                  const float *rgba,
d1254 1
a1254 1
   trace_dump_arg_array(float, rgba, 4);
d1260 1
a1260 1
   pipe->clear_render_target(pipe, dst, rgba, dstx, dsty, width, height);
d1299 2
a1300 1
                    struct pipe_fence_handle **fence)
d1308 1
d1310 1
a1310 1
   pipe->flush(pipe, fence);
d1340 2
a1341 2
static struct pipe_transfer *
trace_context_get_transfer(struct pipe_context *_context,
d1345 2
a1346 1
                           const struct pipe_box *box)
d1353 1
d1362 9
a1370 35
   result = context->get_transfer(context, texture, level, usage, box);

   if (result)
      result = trace_transfer_create(tr_context, tr_res, result);

   return result;
}


static void
trace_context_transfer_destroy(struct pipe_context *_context,
                               struct pipe_transfer *_transfer)
{
   struct trace_context *tr_context = trace_context(_context);
   struct trace_transfer *tr_trans = trace_transfer(_transfer);

   trace_transfer_destroy(tr_context, tr_trans);
}


static void *
trace_context_transfer_map(struct pipe_context *_context,
                          struct pipe_transfer *_transfer)
{
   struct trace_context *tr_context = trace_context(_context);
   struct trace_transfer *tr_trans = trace_transfer(_transfer);
   struct pipe_context *context = tr_context->pipe;
   struct pipe_transfer *transfer = tr_trans->transfer;
   void *map;

   map = context->transfer_map(context, transfer);
   if(map) {
      if(transfer->usage & PIPE_TRANSFER_WRITE) {
         assert(!tr_trans->map);
         tr_trans->map = map;
d1374 1
a1374 1
   return map;
a1376 1

d1423 1
a1423 1
                           resource->format,
d1438 1
d1469 1
a1469 1
                        resource->format,
d1485 4
a1488 27
static void trace_redefine_user_buffer(struct pipe_context *_context,
                                       struct pipe_resource *_resource,
                                       unsigned offset, unsigned size)
{
   struct trace_context *tr_context = trace_context(_context);
   struct trace_resource *tr_res = trace_resource(_resource);
   struct pipe_context *context = tr_context->pipe;
   struct pipe_resource *resource = tr_res->resource;

   assert(resource->screen == context->screen);

   trace_dump_call_begin("pipe_context", "redefine_user_buffer");

   trace_dump_arg(ptr, context);
   trace_dump_arg(ptr, resource);
   trace_dump_arg(uint, offset);
   trace_dump_arg(uint, size);

   trace_dump_call_end();

   context->redefine_user_buffer(context, resource, offset, size);
}


static void trace_render_condition(struct pipe_context *_context,
                                   struct pipe_query *query,
                                   uint mode)
d1497 1
d1502 1
a1502 1
   context->render_condition(context, query, mode);
d1506 1
a1506 1
static void trace_texture_barrier(struct pipe_context *_context)
a1542 1
   tr_ctx->base.winsys = NULL;
d1547 72
a1618 60
   tr_ctx->base.draw_vbo = trace_context_draw_vbo;
   tr_ctx->base.create_query = trace_context_create_query;
   tr_ctx->base.destroy_query = trace_context_destroy_query;
   tr_ctx->base.begin_query = trace_context_begin_query;
   tr_ctx->base.end_query = trace_context_end_query;
   tr_ctx->base.get_query_result = trace_context_get_query_result;
   tr_ctx->base.create_blend_state = trace_context_create_blend_state;
   tr_ctx->base.bind_blend_state = trace_context_bind_blend_state;
   tr_ctx->base.delete_blend_state = trace_context_delete_blend_state;
   tr_ctx->base.create_sampler_state = trace_context_create_sampler_state;
   tr_ctx->base.bind_fragment_sampler_states = trace_context_bind_fragment_sampler_states;
   tr_ctx->base.bind_vertex_sampler_states = trace_context_bind_vertex_sampler_states;
   tr_ctx->base.delete_sampler_state = trace_context_delete_sampler_state;
   tr_ctx->base.create_rasterizer_state = trace_context_create_rasterizer_state;
   tr_ctx->base.bind_rasterizer_state = trace_context_bind_rasterizer_state;
   tr_ctx->base.delete_rasterizer_state = trace_context_delete_rasterizer_state;
   tr_ctx->base.create_depth_stencil_alpha_state = trace_context_create_depth_stencil_alpha_state;
   tr_ctx->base.bind_depth_stencil_alpha_state = trace_context_bind_depth_stencil_alpha_state;
   tr_ctx->base.delete_depth_stencil_alpha_state = trace_context_delete_depth_stencil_alpha_state;
   tr_ctx->base.create_fs_state = trace_context_create_fs_state;
   tr_ctx->base.bind_fs_state = trace_context_bind_fs_state;
   tr_ctx->base.delete_fs_state = trace_context_delete_fs_state;
   tr_ctx->base.create_vs_state = trace_context_create_vs_state;
   tr_ctx->base.bind_vs_state = trace_context_bind_vs_state;
   tr_ctx->base.delete_vs_state = trace_context_delete_vs_state;
   tr_ctx->base.create_vertex_elements_state = trace_context_create_vertex_elements_state;
   tr_ctx->base.bind_vertex_elements_state = trace_context_bind_vertex_elements_state;
   tr_ctx->base.delete_vertex_elements_state = trace_context_delete_vertex_elements_state;
   tr_ctx->base.set_blend_color = trace_context_set_blend_color;
   tr_ctx->base.set_stencil_ref = trace_context_set_stencil_ref;
   tr_ctx->base.set_clip_state = trace_context_set_clip_state;
   tr_ctx->base.set_sample_mask = trace_context_set_sample_mask;
   tr_ctx->base.set_constant_buffer = trace_context_set_constant_buffer;
   tr_ctx->base.set_framebuffer_state = trace_context_set_framebuffer_state;
   tr_ctx->base.set_polygon_stipple = trace_context_set_polygon_stipple;
   tr_ctx->base.set_scissor_state = trace_context_set_scissor_state;
   tr_ctx->base.set_viewport_state = trace_context_set_viewport_state;
   tr_ctx->base.set_fragment_sampler_views = trace_context_set_fragment_sampler_views;
   tr_ctx->base.set_vertex_sampler_views = trace_context_set_vertex_sampler_views;
   tr_ctx->base.create_sampler_view = trace_create_sampler_view;
   tr_ctx->base.sampler_view_destroy = trace_sampler_view_destroy;
   tr_ctx->base.create_surface = trace_create_surface;
   tr_ctx->base.surface_destroy = trace_surface_destroy;
   tr_ctx->base.set_vertex_buffers = trace_context_set_vertex_buffers;
   tr_ctx->base.set_index_buffer = trace_context_set_index_buffer;
   tr_ctx->base.resource_copy_region = trace_context_resource_copy_region;
   tr_ctx->base.clear = trace_context_clear;
   tr_ctx->base.clear_render_target = trace_context_clear_render_target;
   tr_ctx->base.clear_depth_stencil = trace_context_clear_depth_stencil;
   tr_ctx->base.flush = trace_context_flush;
   tr_ctx->base.render_condition = pipe->render_condition ? trace_render_condition : NULL;
   tr_ctx->base.texture_barrier = pipe->texture_barrier ? trace_texture_barrier : NULL;

   tr_ctx->base.get_transfer = trace_context_get_transfer;
   tr_ctx->base.transfer_destroy = trace_context_transfer_destroy;
   tr_ctx->base.transfer_map = trace_context_transfer_map;
   tr_ctx->base.transfer_unmap = trace_context_transfer_unmap;
   tr_ctx->base.transfer_flush_region = trace_context_transfer_flush_region;
   tr_ctx->base.transfer_inline_write = trace_context_transfer_inline_write;
   tr_ctx->base.redefine_user_buffer = trace_redefine_user_buffer;
d1627 13
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d50 1
a50 1
   struct trace_resource *tr_tex;
d55 1
a55 1
   tr_tex = trace_resource(resource);
d57 2
a58 2
   assert(tr_tex->resource);
   return tr_tex->resource;
d835 1
a835 1
   struct trace_resource *tr_tex = trace_resource(_resource);
d837 1
a837 1
   struct pipe_resource *texture = tr_tex->resource;
d844 5
a848 2
   trace_dump_arg(ptr, texture);
   trace_dump_arg(sampler_view_template, templ);
d850 1
a850 1
   result = pipe->create_sampler_view(pipe, texture, templ);
d901 1
a901 1
                     struct pipe_resource *_texture,
d905 1
a905 1
   struct trace_resource *tr_tex = trace_resource(_texture);
d907 1
a907 1
   struct pipe_resource *texture = tr_tex->resource;
d913 6
a918 3
   trace_dump_arg(ptr, texture);
   /* hmm some values unitialized there */
   trace_dump_arg(surface, surf_tmpl);
d920 1
a920 1
   result = pipe->create_surface(pipe, texture, surf_tmpl);
d926 1
a926 1
   result = trace_surf_create(tr_tex, result);
a1192 1
                    unsigned flags,
a1200 1
   trace_dump_arg(uint, flags);
d1202 1
a1202 1
   pipe->flush(pipe, flags, fence);
a1225 25
static unsigned int
trace_is_resource_referenced( struct pipe_context *_pipe,
                              struct pipe_resource *_resource,
                              unsigned level, int layer)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct trace_resource *tr_tex = trace_resource(_resource);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_resource *texture = tr_tex->resource;
   unsigned int referenced;

   trace_dump_call_begin("pipe_context", "is_resource_referenced");
   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, texture);
   trace_dump_arg(uint, level);
   trace_dump_arg(int, layer);

   referenced = pipe->is_resource_referenced(pipe, texture, level, layer);

   trace_dump_ret(uint, referenced);
   trace_dump_call_end();

   return referenced;
}

d1240 1
a1240 1
   struct trace_resource *tr_tex = trace_resource(_resource);
d1242 1
a1242 1
   struct pipe_resource *texture = tr_tex->resource;
d1255 1
a1255 1
      result = trace_transfer_create(tr_context, tr_tex, result);
d1369 1
a1369 1
   struct trace_resource *tr_tex = trace_resource(_resource);
d1371 1
a1371 1
   struct pipe_resource *resource = tr_tex->resource;
d1401 56
d1536 2
a1537 1
   tr_ctx->base.is_resource_referenced = trace_is_resource_referenced;
d1545 1
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d28 1
d32 1
d37 1
a37 2
#include "tr_state.h"
#include "tr_buffer.h"
d40 1
a42 11
static INLINE struct pipe_buffer *
trace_buffer_unwrap(struct trace_context *tr_ctx,
                     struct pipe_buffer *buffer)
{
   struct trace_screen *tr_scr = trace_screen(tr_ctx->base.screen);
   struct trace_buffer *tr_buf;

   if(!buffer)
      return NULL;

   tr_buf = trace_buffer(buffer);
a43 5
   assert(tr_buf->buffer);
   assert(tr_buf->buffer->screen == tr_scr->screen);
   (void) tr_scr;
   return tr_buf->buffer;
}
d46 3
a48 3
static INLINE struct pipe_texture *
trace_texture_unwrap(struct trace_context *tr_ctx,
                     struct pipe_texture *texture)
d50 1
a50 1
   struct trace_texture *tr_tex;
d52 1
a52 1
   if(!texture)
d55 1
a55 1
   tr_tex = trace_texture(texture);
d57 2
a58 2
   assert(tr_tex->texture);
   return tr_tex->texture;
d86 2
a87 135
trace_context_draw_block(struct trace_context *tr_ctx, int flag)
{
   int k;

   pipe_mutex_lock(tr_ctx->draw_mutex);

   if (tr_ctx->draw_blocker & flag) {
      tr_ctx->draw_blocked |= flag;
   } else if ((tr_ctx->draw_rule.blocker & flag) &&
              (tr_ctx->draw_blocker & 4)) {
      boolean block = FALSE;
      debug_printf("%s (%p %p) (%p %p) (%p %u) (%p %u)\n", __FUNCTION__,
                   (void *) tr_ctx->draw_rule.fs, (void *) tr_ctx->curr.fs,
                   (void *) tr_ctx->draw_rule.vs, (void *) tr_ctx->curr.vs,
                   (void *) tr_ctx->draw_rule.surf, 0,
                   (void *) tr_ctx->draw_rule.tex, 0);
      if (tr_ctx->draw_rule.fs &&
          tr_ctx->draw_rule.fs == tr_ctx->curr.fs)
         block = TRUE;
      if (tr_ctx->draw_rule.vs &&
          tr_ctx->draw_rule.vs == tr_ctx->curr.vs)
         block = TRUE;
      if (tr_ctx->draw_rule.surf &&
          tr_ctx->draw_rule.surf == tr_ctx->curr.zsbuf)
            block = TRUE;
      if (tr_ctx->draw_rule.surf)
         for (k = 0; k < tr_ctx->curr.nr_cbufs; k++)
            if (tr_ctx->draw_rule.surf == tr_ctx->curr.cbufs[k])
               block = TRUE;
      if (tr_ctx->draw_rule.tex) {
         for (k = 0; k < tr_ctx->curr.num_texs; k++)
            if (tr_ctx->draw_rule.tex == tr_ctx->curr.tex[k])
               block = TRUE;
         for (k = 0; k < tr_ctx->curr.num_vert_texs; k++) {
            if (tr_ctx->draw_rule.tex == tr_ctx->curr.vert_tex[k]) {
               block = TRUE;
            }
         }
      }

      if (block)
         tr_ctx->draw_blocked |= (flag | 4);
   }

   if (tr_ctx->draw_blocked)
      trace_rbug_notify_draw_blocked(tr_ctx);

   /* wait for rbug to clear the blocked flag */
   while (tr_ctx->draw_blocked & flag) {
      tr_ctx->draw_blocked |= flag;
#ifdef PIPE_THREAD_HAVE_CONDVAR
      pipe_condvar_wait(tr_ctx->draw_cond, tr_ctx->draw_mutex);
#else
      pipe_mutex_unlock(tr_ctx->draw_mutex);
#ifdef PIPE_SUBSYSTEM_WINDOWS_USER
      Sleep(1);
#endif
      pipe_mutex_lock(tr_ctx->draw_mutex);
#endif
   }

   pipe_mutex_unlock(tr_ctx->draw_mutex);
}

static INLINE void
trace_context_draw_arrays(struct pipe_context *_pipe,
                          unsigned mode, unsigned start, unsigned count)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   if (tr_ctx->curr.fs->disabled || tr_ctx->curr.vs->disabled)
      return;

   trace_context_draw_block(tr_ctx, 1);

   trace_dump_call_begin("pipe_context", "draw_arrays");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, mode);
   trace_dump_arg(uint, start);
   trace_dump_arg(uint, count);

   pipe->draw_arrays(pipe, mode, start, count);

   trace_dump_call_end();

   trace_context_draw_block(tr_ctx, 2);
}


static INLINE void
trace_context_draw_elements(struct pipe_context *_pipe,
                          struct pipe_buffer *_indexBuffer,
                          unsigned indexSize,
                          unsigned mode, unsigned start, unsigned count)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct trace_buffer *tr_buf = trace_buffer(_indexBuffer);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_buffer *indexBuffer = tr_buf->buffer;

   if (tr_ctx->curr.fs->disabled || tr_ctx->curr.vs->disabled)
      return;

   trace_context_draw_block(tr_ctx, 1);

   trace_screen_user_buffer_update(_pipe->screen, indexBuffer);

   trace_dump_call_begin("pipe_context", "draw_elements");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, indexBuffer);
   trace_dump_arg(uint, indexSize);
   trace_dump_arg(uint, mode);
   trace_dump_arg(uint, start);
   trace_dump_arg(uint, count);

   pipe->draw_elements(pipe, indexBuffer, indexSize, mode, start, count);

   trace_dump_call_end();

   trace_context_draw_block(tr_ctx, 2);
}


static INLINE void
trace_context_draw_range_elements(struct pipe_context *_pipe,
                                  struct pipe_buffer *_indexBuffer,
                                  unsigned indexSize,
                                  unsigned minIndex,
                                  unsigned maxIndex,
                                  unsigned mode,
                                  unsigned start,
                                  unsigned count)
a89 1
   struct trace_buffer *tr_buf = trace_buffer(_indexBuffer);
a90 4
   struct pipe_buffer *indexBuffer = tr_buf->buffer;

   if (tr_ctx->curr.fs->disabled || tr_ctx->curr.vs->disabled)
      return;
d92 1
a92 1
   trace_context_draw_block(tr_ctx, 1);
d94 2
a95 1
   trace_screen_user_buffer_update(_pipe->screen, indexBuffer);
d97 1
a97 15
   trace_dump_call_begin("pipe_context", "draw_range_elements");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, indexBuffer);
   trace_dump_arg(uint, indexSize);
   trace_dump_arg(uint, minIndex);
   trace_dump_arg(uint, maxIndex);
   trace_dump_arg(uint, mode);
   trace_dump_arg(uint, start);
   trace_dump_arg(uint, count);

   pipe->draw_range_elements(pipe,
                             indexBuffer,
                             indexSize, minIndex, maxIndex,
                             mode, start, count);
a99 2

   trace_context_draw_block(tr_ctx, 2);
d184 1
a184 1
                               uint64_t *presult)
d196 1
a196 1
   result = *presult;
d317 3
a486 2
   result = trace_shader_create(tr_ctx, state, result, TRACE_SHADER_FRAGMENT);

d493 1
a493 1
                            void *_state)
a495 1
   struct trace_shader *tr_shdr = trace_shader(_state);
a496 1
   void *state = tr_shdr ? tr_shdr->state : NULL;
a502 5
   tr_ctx->curr.fs = tr_shdr;

   if (tr_shdr && tr_shdr->replaced)
      state = tr_shdr->replaced;

d511 1
a511 1
                              void *_state)
a513 1
   struct trace_shader *tr_shdr = trace_shader(_state);
a514 1
   void *state = tr_shdr->state;
a523 2

   trace_shader_destroy(tr_ctx, tr_shdr);
a545 2
   result = trace_shader_create(tr_ctx, state, result, TRACE_SHADER_VERTEX);

d552 1
a552 1
                            void *_state)
a554 1
   struct trace_shader *tr_shdr = trace_shader(_state);
a555 1
   void *state = tr_shdr ? tr_shdr->state : NULL;
a561 5
   tr_ctx->curr.vs = tr_shdr;

   if (tr_shdr && tr_shdr->replaced)
      state = tr_shdr->replaced;

d570 1
a570 1
                              void *_state)
a572 1
   struct trace_shader *tr_shdr = trace_shader(_state);
a573 1
   void *state = tr_shdr->state;
d583 11
d595 52
a646 1
   trace_shader_destroy(tr_ctx, tr_shdr);
d703 16
d723 1
a723 1
                                  struct pipe_buffer *buffer)
d729 1
a729 2
      trace_screen_user_buffer_update(_pipe->screen, buffer);
      buffer = trace_buffer_unwrap(tr_ctx, buffer);
a753 12
   {
      tr_ctx->curr.nr_cbufs = state->nr_cbufs;
      for (i = 0; i < state->nr_cbufs; i++)
         if (state->cbufs[i])
            tr_ctx->curr.cbufs[i] = trace_texture(state->cbufs[i]->texture);
         else
            tr_ctx->curr.cbufs[i] = NULL;
      if (state->zsbuf)
         tr_ctx->curr.zsbuf = trace_texture(state->zsbuf->texture);
      else
         tr_ctx->curr.zsbuf = NULL;
   }
d829 117
d947 3
a949 3
trace_context_set_fragment_sampler_textures(struct pipe_context *_pipe,
                                            unsigned num_textures,
                                            struct pipe_texture **textures)
d952 1
a952 1
   struct trace_texture *tr_tex;
d954 1
a954 1
   struct pipe_texture *unwrapped_textures[PIPE_MAX_SAMPLERS];
d957 3
a959 5
   tr_ctx->curr.num_texs = num_textures;
   for(i = 0; i < num_textures; ++i) {
      tr_tex = trace_texture(textures[i]);
      tr_ctx->curr.tex[i] = tr_tex;
      unwrapped_textures[i] = tr_tex ? tr_tex->texture : NULL;
d961 1
a961 1
   textures = unwrapped_textures;
d963 1
a963 1
   trace_dump_call_begin("pipe_context", "set_fragment_sampler_textures");
d966 2
a967 2
   trace_dump_arg(uint, num_textures);
   trace_dump_arg_array(ptr, textures, num_textures);
d969 1
a969 1
   pipe->set_fragment_sampler_textures(pipe, num_textures, textures);
d976 3
a978 3
trace_context_set_vertex_sampler_textures(struct pipe_context *_pipe,
                                          unsigned num_textures,
                                          struct pipe_texture **textures)
d981 1
a981 1
   struct trace_texture *tr_tex;
d983 1
a983 1
   struct pipe_texture *unwrapped_textures[PIPE_MAX_VERTEX_SAMPLERS];
d986 6
a991 5
   tr_ctx->curr.num_vert_texs = num_textures;
   for(i = 0; i < num_textures; ++i) {
      tr_tex = trace_texture(textures[i]);
      tr_ctx->curr.vert_tex[i] = tr_tex;
      unwrapped_textures[i] = tr_tex ? tr_tex->texture : NULL;
d993 1
a993 1
   textures = unwrapped_textures;
d995 1
a995 1
   trace_dump_call_begin("pipe_context", "set_vertex_sampler_textures");
d998 2
a999 2
   trace_dump_arg(uint, num_textures);
   trace_dump_arg_array(ptr, textures, num_textures);
d1001 1
a1001 1
   pipe->set_vertex_sampler_textures(pipe, num_textures, textures);
a1015 3
   for(i = 0; i < num_buffers; ++i)
      trace_screen_user_buffer_update(_pipe->screen, buffers[i].buffer);

d1026 1
a1026 1
      struct pipe_vertex_buffer *_buffers = malloc(num_buffers * sizeof(*_buffers));
d1029 1
a1029 1
         _buffers[i].buffer = trace_buffer_unwrap(tr_ctx, buffers[i].buffer);
d1031 1
a1031 1
      free(_buffers);
d1041 2
a1042 3
trace_context_set_vertex_elements(struct pipe_context *_pipe,
                                  unsigned num_elements,
                                  const struct pipe_vertex_element *elements)
d1047 1
a1047 1
   trace_dump_call_begin("pipe_context", "set_vertex_elements");
d1050 30
a1079 1
   trace_dump_arg(uint, num_elements);
d1081 9
a1089 3
   trace_dump_arg_begin("elements");
   trace_dump_struct_array(vertex_element, elements, num_elements);
   trace_dump_arg_end();
d1091 3
a1093 1
   pipe->set_vertex_elements(pipe, num_elements, elements);
d1100 5
a1104 6
trace_context_surface_copy(struct pipe_context *_pipe,
                           struct pipe_surface *dest,
                           unsigned destx, unsigned desty,
                           struct pipe_surface *src,
                           unsigned srcx, unsigned srcy,
                           unsigned width, unsigned height)
d1109 1
a1109 4
   dest = trace_surface_unwrap(tr_ctx, dest);
   src = trace_surface_unwrap(tr_ctx, src);

   trace_dump_call_begin("pipe_context", "surface_copy");
d1112 7
a1118 8
   trace_dump_arg(ptr, dest);
   trace_dump_arg(uint, destx);
   trace_dump_arg(uint, desty);
   trace_dump_arg(ptr, src);
   trace_dump_arg(uint, srcx);
   trace_dump_arg(uint, srcy);
   trace_dump_arg(uint, width);
   trace_dump_arg(uint, height);
d1120 1
a1120 3
   pipe->surface_copy(pipe,
                      dest, destx, desty,
                      src, srcx, srcy, width, height);
d1127 5
a1131 5
trace_context_surface_fill(struct pipe_context *_pipe,
                           struct pipe_surface *dst,
                           unsigned dstx, unsigned dsty,
                           unsigned width, unsigned height,
                           unsigned value)
d1138 1
a1138 1
   trace_dump_call_begin("pipe_context", "surface_fill");
d1142 1
d1148 1
a1148 1
   pipe->surface_fill(pipe, dst, dstx, dsty, width, height, value);
a1152 1

d1154 7
a1160 5
trace_context_clear(struct pipe_context *_pipe,
                    unsigned buffers,
                    const float *rgba,
                    double depth,
                    unsigned stencil)
d1165 3
a1167 1
   trace_dump_call_begin("pipe_context", "clear");
d1170 2
a1171 2
   trace_dump_arg(uint, buffers);
   trace_dump_arg_array(float, rgba, 4);
d1174 4
d1179 2
a1180 1
   pipe->clear(pipe, buffers, rgba, depth, stencil);
a1184 1

a1209 1
   struct trace_screen *tr_scr = trace_screen(_pipe->screen);
a1216 2
   trace_screen_remove_from_list(tr_scr, contexts, tr_ctx);

d1223 3
a1225 3
trace_is_texture_referenced( struct pipe_context *_pipe,
			    struct pipe_texture *_texture,
			    unsigned face, unsigned level)
d1228 1
a1228 1
   struct trace_texture *tr_tex = trace_texture(_texture);
d1230 1
a1230 1
   struct pipe_texture *texture = tr_tex->texture;
d1233 1
a1233 1
   trace_dump_call_begin("pipe_context", "is_texture_referenced");
a1235 1
   trace_dump_arg(uint, face);
d1237 1
d1239 1
a1239 1
   referenced = pipe->is_texture_referenced(pipe, texture, face, level);
d1247 141
a1387 3
static unsigned int
trace_is_buffer_referenced( struct pipe_context *_pipe,
			    struct pipe_buffer *_buf)
d1389 14
a1402 5
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct trace_buffer *tr_buf = trace_buffer(_buf);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_buffer *buf = tr_buf->buffer;
   unsigned int referenced;
d1404 7
a1410 3
   trace_dump_call_begin("pipe_context", "is_buffer_referenced");
   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, buf);
d1412 2
a1413 1
   referenced = pipe->is_buffer_referenced(pipe, buf);
a1414 1
   trace_dump_ret(uint, referenced);
d1417 2
a1418 1
   return referenced;
d1421 3
d1425 3
a1427 3
   {"before", 1},
   {"after", 2},
   {NULL, 0},
a1448 7
   tr_ctx->draw_blocker = debug_get_flags_option("RBUG_BLOCK",
                                                 rbug_blocker_flags,
                                                 0);
   pipe_mutex_init(tr_ctx->draw_mutex);
   pipe_condvar_init(tr_ctx->draw_cond);
   pipe_mutex_init(tr_ctx->list_mutex);
   make_empty_list(&tr_ctx->shaders);
d1451 1
a1451 3
   tr_ctx->base.draw_arrays = trace_context_draw_arrays;
   tr_ctx->base.draw_elements = trace_context_draw_elements;
   tr_ctx->base.draw_range_elements = trace_context_draw_range_elements;
d1476 3
d1482 1
d1488 6
a1493 2
   tr_ctx->base.set_fragment_sampler_textures = trace_context_set_fragment_sampler_textures;
   tr_ctx->base.set_vertex_sampler_textures = trace_context_set_vertex_sampler_textures;
d1495 2
a1496 5
   tr_ctx->base.set_vertex_elements = trace_context_set_vertex_elements;
   if (pipe->surface_copy)
      tr_ctx->base.surface_copy = trace_context_surface_copy;
   if (pipe->surface_fill)
      tr_ctx->base.surface_fill = trace_context_surface_fill;
d1498 2
d1501 8
a1508 2
   tr_ctx->base.is_texture_referenced = trace_is_texture_referenced;
   tr_ctx->base.is_buffer_referenced = trace_is_buffer_referenced;
a1510 2

   trace_screen_add_to_list(tr_scr, contexts, tr_ctx);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a27 1
#include "util/u_inlines.h"
a30 1
#include "pipe/p_format.h"
d35 2
a36 1
#include "tr_public.h"
a38 1
#include "tr_context.h"
d41 11
d53 5
d60 3
a62 3
static INLINE struct pipe_resource *
trace_resource_unwrap(struct trace_context *tr_ctx,
                     struct pipe_resource *resource)
d64 1
a64 1
   struct trace_resource *tr_tex;
d66 1
a66 1
   if(!resource)
d69 1
a69 1
   tr_tex = trace_resource(resource);
d71 2
a72 2
   assert(tr_tex->resource);
   return tr_tex->resource;
d100 135
a234 2
trace_context_draw_vbo(struct pipe_context *_pipe,
                       const struct pipe_draw_info *info)
d237 1
d239 4
d244 1
a244 1
   trace_dump_call_begin("pipe_context", "draw_vbo");
d246 1
a246 2
   trace_dump_arg(ptr,  pipe);
   trace_dump_arg(draw_info, info);
d248 15
a262 1
   pipe->draw_vbo(pipe, info);
d265 2
d351 1
a351 1
                               void *presult)
d363 1
a363 1
   result = *((uint64_t*)presult);
a483 3
   if (!pipe->bind_vertex_sampler_states)
      return;

d651 2
d659 1
a659 1
                            void *state)
d662 1
d664 1
d671 5
d684 1
a684 1
                              void *state)
d687 1
d689 1
d699 2
d723 2
d731 1
a731 1
                            void *state)
d734 1
d736 1
d743 5
d756 1
a756 1
                              void *state)
d759 1
d761 1
a770 11
}


static INLINE void *
trace_context_create_vertex_elements_state(struct pipe_context *_pipe,
                                           unsigned num_elements,
                                           const struct  pipe_vertex_element *elements)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   void * result;
d772 1
a772 52
   trace_dump_call_begin("pipe_context", "create_vertex_elements_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, num_elements);

   trace_dump_arg_begin("elements");
   trace_dump_struct_array(vertex_element, elements, num_elements);
   trace_dump_arg_end();

   result = pipe->create_vertex_elements_state(pipe, num_elements, elements);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   return result;
}


static INLINE void
trace_context_bind_vertex_elements_state(struct pipe_context *_pipe,
                                         void *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "bind_vertex_elements_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, state);

   pipe->bind_vertex_elements_state(pipe, state);

   trace_dump_call_end();
}


static INLINE void
trace_context_delete_vertex_elements_state(struct pipe_context *_pipe,
                                           void *state)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "delete_vertex_elements_state");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, state);

   pipe->delete_vertex_elements_state(pipe, state);

   trace_dump_call_end();
a828 16
static INLINE void
trace_context_set_sample_mask(struct pipe_context *_pipe,
                              unsigned sample_mask)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "set_sample_mask");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, sample_mask);

   pipe->set_sample_mask(pipe, sample_mask);

   trace_dump_call_end();
}
d833 1
a833 1
                                  struct pipe_resource *buffer)
d839 2
a840 1
      buffer = trace_resource_unwrap(tr_ctx, buffer);
d865 12
a951 117
static struct pipe_sampler_view *
trace_create_sampler_view(struct pipe_context *_pipe,
                          struct pipe_resource *_resource,
                          const struct pipe_sampler_view *templ)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct trace_resource *tr_tex = trace_resource(_resource);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_resource *texture = tr_tex->resource;
   struct pipe_sampler_view *result;
   struct trace_sampler_view *tr_view;

   trace_dump_call_begin("pipe_context", "create_sampler_view");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, texture);
   trace_dump_arg(sampler_view_template, templ);

   result = pipe->create_sampler_view(pipe, texture, templ);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   /*
    * Wrap pipe_sampler_view
    */
   tr_view = CALLOC_STRUCT(trace_sampler_view);
   tr_view->base = *templ;
   tr_view->base.reference.count = 1;
   tr_view->base.texture = NULL;
   pipe_resource_reference(&tr_view->base.texture, _resource);
   tr_view->base.context = _pipe;
   tr_view->sampler_view = result;
   result = &tr_view->base;

   return result;
}


static void
trace_sampler_view_destroy(struct pipe_context *_pipe,
                           struct pipe_sampler_view *_view)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct trace_sampler_view *tr_view = trace_sampler_view(_view);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_sampler_view *view = tr_view->sampler_view;

   trace_dump_call_begin("pipe_context", "sampler_view_destroy");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, view);

   pipe_sampler_view_reference(&tr_view->sampler_view, NULL);

   trace_dump_call_end();

   pipe_resource_reference(&_view->texture, NULL);
   FREE(_view);
}

/********************************************************************
 * surface
 */


static struct pipe_surface *
trace_create_surface(struct pipe_context *_pipe,
                     struct pipe_resource *_texture,
                     const struct pipe_surface *surf_tmpl)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct trace_resource *tr_tex = trace_resource(_texture);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_resource *texture = tr_tex->resource;
   struct pipe_surface *result = NULL;

   trace_dump_call_begin("pipe_context", "create_surface");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, texture);
   /* hmm some values unitialized there */
   trace_dump_arg(surface, surf_tmpl);

   result = pipe->create_surface(pipe, texture, surf_tmpl);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   result = trace_surf_create(tr_tex, result);

   return result;
}


static void
trace_surface_destroy(struct pipe_context *_pipe,
                      struct pipe_surface *_surface)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct trace_surface *tr_surf = trace_surface(_surface);
   struct pipe_surface *surface = tr_surf->surface;

   trace_dump_call_begin("pipe_context", "surface_destroy");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, surface);

   trace_dump_call_end();

   trace_surf_destroy(tr_surf);
}


d953 3
a955 3
trace_context_set_fragment_sampler_views(struct pipe_context *_pipe,
                                         unsigned num,
                                         struct pipe_sampler_view **views)
d958 1
a958 1
   struct trace_sampler_view *tr_view;
d960 1
a960 1
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_SAMPLERS];
d963 5
a967 3
   for(i = 0; i < num; ++i) {
      tr_view = trace_sampler_view(views[i]);
      unwrapped_views[i] = tr_view ? tr_view->sampler_view : NULL;
d969 1
a969 1
   views = unwrapped_views;
d971 1
a971 1
   trace_dump_call_begin("pipe_context", "set_fragment_sampler_views");
d974 2
a975 2
   trace_dump_arg(uint, num);
   trace_dump_arg_array(ptr, views, num);
d977 1
a977 1
   pipe->set_fragment_sampler_views(pipe, num, views);
d984 3
a986 3
trace_context_set_vertex_sampler_views(struct pipe_context *_pipe,
                                       unsigned num,
                                       struct pipe_sampler_view **views)
d989 1
a989 1
   struct trace_sampler_view *tr_view;
d991 1
a991 1
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_VERTEX_SAMPLERS];
d994 5
a998 6
   if (!pipe->set_vertex_sampler_views)
      return;

   for(i = 0; i < num; ++i) {
      tr_view = trace_sampler_view(views[i]);
      unwrapped_views[i] = tr_view ? tr_view->sampler_view : NULL;
d1000 1
a1000 1
   views = unwrapped_views;
d1002 1
a1002 1
   trace_dump_call_begin("pipe_context", "set_vertex_sampler_views");
d1005 2
a1006 2
   trace_dump_arg(uint, num);
   trace_dump_arg_array(ptr, views, num);
d1008 1
a1008 1
   pipe->set_vertex_sampler_views(pipe, num, views);
d1023 3
d1036 1
a1036 1
      struct pipe_vertex_buffer *_buffers = MALLOC(num_buffers * sizeof(*_buffers));
d1039 1
a1039 1
         _buffers[i].buffer = trace_resource_unwrap(tr_ctx, buffers[i].buffer);
d1041 1
a1041 1
      FREE(_buffers);
d1051 3
a1053 2
trace_context_set_index_buffer(struct pipe_context *_pipe,
                               const struct pipe_index_buffer *ib)
d1058 1
a1058 1
   trace_dump_call_begin("pipe_context", "set_index_buffer");
d1061 5
a1065 1
   trace_dump_arg(index_buffer, ib);
d1067 1
a1067 8
   if (ib) {
      struct pipe_index_buffer _ib;
      _ib = *ib;
      _ib.buffer = trace_resource_unwrap(tr_ctx, ib->buffer);
      pipe->set_index_buffer(pipe, &_ib);
   } else {
      pipe->set_index_buffer(pipe, NULL);
   }
d1072 1
d1074 6
a1079 7
trace_context_resource_copy_region(struct pipe_context *_pipe,
                                   struct pipe_resource *dst,
                                   unsigned dst_level,
                                   unsigned dstx, unsigned dsty, unsigned dstz,
                                   struct pipe_resource *src,
                                   unsigned src_level,
                                   const struct pipe_box *src_box)
d1084 2
a1085 2
   dst = trace_resource_unwrap(tr_ctx, dst);
   src = trace_resource_unwrap(tr_ctx, src);
d1087 1
a1087 1
   trace_dump_call_begin("pipe_context", "resource_copy_region");
d1090 3
a1092 5
   trace_dump_arg(ptr, dst);
   trace_dump_arg(uint, dst_level);
   trace_dump_arg(uint, dstx);
   trace_dump_arg(uint, dsty);
   trace_dump_arg(uint, dstz);
d1094 4
a1097 31
   trace_dump_arg(uint, src_level);
   trace_dump_arg(box, src_box);

   pipe->resource_copy_region(pipe,
                              dst, dst_level, dstx, dsty, dstz,
                              src, src_level, src_box);

   trace_dump_call_end();
}


static INLINE void
trace_context_clear(struct pipe_context *_pipe,
                    unsigned buffers,
                    const float *rgba,
                    double depth,
                    unsigned stencil)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "clear");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, buffers);
   if (rgba)
      trace_dump_arg_array(float, rgba, 4);
   else
      trace_dump_null();
   trace_dump_arg(float, depth);
   trace_dump_arg(uint, stencil);
d1099 3
a1101 1
   pipe->clear(pipe, buffers, rgba, depth, stencil);
d1108 5
a1112 5
trace_context_clear_render_target(struct pipe_context *_pipe,
                                  struct pipe_surface *dst,
                                  const float *rgba,
                                  unsigned dstx, unsigned dsty,
                                  unsigned width, unsigned height)
d1119 1
a1119 1
   trace_dump_call_begin("pipe_context", "clear_render_target");
a1122 1
   trace_dump_arg_array(float, rgba, 4);
d1128 1
a1128 1
   pipe->clear_render_target(pipe, dst, rgba, dstx, dsty, width, height);
d1133 1
d1135 5
a1139 7
trace_context_clear_depth_stencil(struct pipe_context *_pipe,
                                  struct pipe_surface *dst,
                                  unsigned clear_flags,
                                  double depth,
                                  unsigned stencil,
                                  unsigned dstx, unsigned dsty,
                                  unsigned width, unsigned height)
d1144 1
a1144 3
   dst = trace_surface_unwrap(tr_ctx, dst);

   trace_dump_call_begin("pipe_context", "clear_depth_stencil");
d1147 2
a1148 2
   trace_dump_arg(ptr, dst);
   trace_dump_arg(uint, clear_flags);
a1150 4
   trace_dump_arg(uint, dstx);
   trace_dump_arg(uint, dsty);
   trace_dump_arg(uint, width);
   trace_dump_arg(uint, height);
d1152 1
a1152 2
   pipe->clear_depth_stencil(pipe, dst, clear_flags, depth, stencil,
                             dstx, dsty, width, height);
d1157 1
d1183 1
d1191 2
d1199 3
a1201 3
trace_is_resource_referenced( struct pipe_context *_pipe,
                              struct pipe_resource *_resource,
                              unsigned level, int layer)
d1204 1
a1204 1
   struct trace_resource *tr_tex = trace_resource(_resource);
d1206 1
a1206 1
   struct pipe_resource *texture = tr_tex->resource;
d1209 1
a1209 1
   trace_dump_call_begin("pipe_context", "is_resource_referenced");
d1212 1
a1213 1
   trace_dump_arg(int, layer);
d1215 1
a1215 1
   referenced = pipe->is_resource_referenced(pipe, texture, level, layer);
d1223 3
a1225 38

/********************************************************************
 * transfer
 */


static struct pipe_transfer *
trace_context_get_transfer(struct pipe_context *_context,
                           struct pipe_resource *_resource,
                           unsigned level,
                           unsigned usage,
                           const struct pipe_box *box)
{
   struct trace_context *tr_context = trace_context(_context);
   struct trace_resource *tr_tex = trace_resource(_resource);
   struct pipe_context *context = tr_context->pipe;
   struct pipe_resource *texture = tr_tex->resource;
   struct pipe_transfer *result = NULL;

   assert(texture->screen == context->screen);

   /*
    * Map and transfers can't be serialized so we convert all write transfers
    * to transfer_inline_write and ignore read transfers.
    */

   result = context->get_transfer(context, texture, level, usage, box);

   if (result)
      result = trace_transfer_create(tr_context, tr_tex, result);

   return result;
}


static void
trace_context_transfer_destroy(struct pipe_context *_context,
                               struct pipe_transfer *_transfer)
d1227 5
a1231 2
   struct trace_context *tr_context = trace_context(_context);
   struct trace_transfer *tr_trans = trace_transfer(_transfer);
d1233 3
a1235 2
   trace_transfer_destroy(tr_context, tr_trans);
}
d1237 1
d1239 1
a1239 122
static void *
trace_context_transfer_map(struct pipe_context *_context,
                          struct pipe_transfer *_transfer)
{
   struct trace_context *tr_context = trace_context(_context);
   struct trace_transfer *tr_trans = trace_transfer(_transfer);
   struct pipe_context *context = tr_context->pipe;
   struct pipe_transfer *transfer = tr_trans->transfer;
   void *map;

   map = context->transfer_map(context, transfer);
   if(map) {
      if(transfer->usage & PIPE_TRANSFER_WRITE) {
         assert(!tr_trans->map);
         tr_trans->map = map;
      }
   }

   return map;
}


static void
trace_context_transfer_flush_region( struct pipe_context *_context,
				     struct pipe_transfer *_transfer,
				     const struct pipe_box *box)
{
   struct trace_context *tr_context = trace_context(_context);
   struct trace_transfer *tr_transfer = trace_transfer(_transfer);
   struct pipe_context *context = tr_context->pipe;
   struct pipe_transfer *transfer = tr_transfer->transfer;

   context->transfer_flush_region(context,
				  transfer,
				  box);
}

static void
trace_context_transfer_unmap(struct pipe_context *_context,
                             struct pipe_transfer *_transfer)
{
   struct trace_context *tr_ctx = trace_context(_context);
   struct trace_transfer *tr_trans = trace_transfer(_transfer);
   struct pipe_context *context = tr_ctx->pipe;
   struct pipe_transfer *transfer = tr_trans->transfer;

   if(tr_trans->map) {
      /*
       * Fake a transfer_inline_write
       */

      struct pipe_resource *resource = transfer->resource;
      unsigned level = transfer->level;
      unsigned usage = transfer->usage;
      const struct pipe_box *box = &transfer->box;
      unsigned stride = transfer->stride;
      unsigned layer_stride = transfer->layer_stride;

      trace_dump_call_begin("pipe_context", "transfer_inline_write");

      trace_dump_arg(ptr, context);
      trace_dump_arg(ptr, resource);
      trace_dump_arg(uint, level);
      trace_dump_arg(uint, usage);
      trace_dump_arg(box, box);

      trace_dump_arg_begin("data");
      trace_dump_box_bytes(tr_trans->map,
                           resource->format,
                           box,
                           stride,
                           layer_stride);
      trace_dump_arg_end();

      trace_dump_arg(uint, stride);
      trace_dump_arg(uint, layer_stride);

      trace_dump_call_end();

      tr_trans->map = NULL;
   }

   context->transfer_unmap(context, transfer);
}


static void
trace_context_transfer_inline_write(struct pipe_context *_context,
                                    struct pipe_resource *_resource,
                                    unsigned level,
                                    unsigned usage,
                                    const struct pipe_box *box,
                                    const void *data,
                                    unsigned stride,
                                    unsigned layer_stride)
{
   struct trace_context *tr_context = trace_context(_context);
   struct trace_resource *tr_tex = trace_resource(_resource);
   struct pipe_context *context = tr_context->pipe;
   struct pipe_resource *resource = tr_tex->resource;

   assert(resource->screen == context->screen);

   trace_dump_call_begin("pipe_context", "transfer_inline_write");

   trace_dump_arg(ptr, context);
   trace_dump_arg(ptr, resource);
   trace_dump_arg(uint, level);
   trace_dump_arg(uint, usage);
   trace_dump_arg(box, box);

   trace_dump_arg_begin("data");
   trace_dump_box_bytes(data,
                        resource->format,
                        box,
                        stride,
                        layer_stride);
   trace_dump_arg_end();

   trace_dump_arg(uint, stride);
   trace_dump_arg(uint, layer_stride);

d1242 1
a1242 2
   context->transfer_inline_write(context, resource,
                                  level, usage, box, data, stride, layer_stride);
a1244 3



d1246 3
a1248 3
   {"before", 1, NULL},
   {"after", 2, NULL},
   DEBUG_NAMED_VALUE_END
d1270 7
d1279 3
a1281 1
   tr_ctx->base.draw_vbo = trace_context_draw_vbo;
a1305 3
   tr_ctx->base.create_vertex_elements_state = trace_context_create_vertex_elements_state;
   tr_ctx->base.bind_vertex_elements_state = trace_context_bind_vertex_elements_state;
   tr_ctx->base.delete_vertex_elements_state = trace_context_delete_vertex_elements_state;
a1308 1
   tr_ctx->base.set_sample_mask = trace_context_set_sample_mask;
d1314 2
a1315 6
   tr_ctx->base.set_fragment_sampler_views = trace_context_set_fragment_sampler_views;
   tr_ctx->base.set_vertex_sampler_views = trace_context_set_vertex_sampler_views;
   tr_ctx->base.create_sampler_view = trace_create_sampler_view;
   tr_ctx->base.sampler_view_destroy = trace_sampler_view_destroy;
   tr_ctx->base.create_surface = trace_create_surface;
   tr_ctx->base.surface_destroy = trace_surface_destroy;
d1317 5
a1321 2
   tr_ctx->base.set_index_buffer = trace_context_set_index_buffer;
   tr_ctx->base.resource_copy_region = trace_context_resource_copy_region;
a1322 2
   tr_ctx->base.clear_render_target = trace_context_clear_render_target;
   tr_ctx->base.clear_depth_stencil = trace_context_clear_depth_stencil;
d1324 2
a1325 1
   tr_ctx->base.is_resource_referenced = trace_is_resource_referenced;
d1327 1
a1327 6
   tr_ctx->base.get_transfer = trace_context_get_transfer;
   tr_ctx->base.transfer_destroy = trace_context_transfer_destroy;
   tr_ctx->base.transfer_map = trace_context_transfer_map;
   tr_ctx->base.transfer_unmap = trace_context_transfer_unmap;
   tr_ctx->base.transfer_flush_region = trace_context_transfer_flush_region;
   tr_ctx->base.transfer_inline_write = trace_context_transfer_inline_write;
d1329 1
a1329 1
   tr_ctx->pipe = pipe;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d50 1
a50 1
   struct trace_resource *tr_res;
d55 1
a55 1
   tr_res = trace_resource(resource);
d57 2
a58 2
   assert(tr_res->resource);
   return tr_res->resource;
a96 2
   trace_dump_trace_flush();

d184 1
a184 1
                               union pipe_query_result *presult)
a195 1
   /* XXX this depends on the query type */
d290 3
a292 5
trace_context_bind_sampler_states(struct pipe_context *_pipe,
                                  unsigned shader,
                                  unsigned start,
                                  unsigned num_states,
                                  void **states)
d297 1
a297 16
   /* remove this when we have pipe->bind_sampler_states(..., start, ...) */
   assert(start == 0);

   switch (shader) {
   case PIPE_SHADER_VERTEX:
      trace_dump_call_begin("pipe_context", "bind_vertex_sampler_states");
      break;
   case PIPE_SHADER_GEOMETRY:
      trace_dump_call_begin("pipe_context", "bind_geometry_sampler_states");
      break;
   case PIPE_SHADER_FRAGMENT:
      trace_dump_call_begin("pipe_context", "bind_fragment_sampler_states");
      break;
   default:
      debug_error("Unexpected shader in trace_context_bind_sampler_states()");
   }
d303 1
a303 13
   switch (shader) {
   case PIPE_SHADER_VERTEX:
      pipe->bind_vertex_sampler_states(pipe, num_states, states);
      break;
   case PIPE_SHADER_GEOMETRY:
      pipe->bind_geometry_sampler_states(pipe, num_states, states);
      break;
   case PIPE_SHADER_FRAGMENT:
      pipe->bind_fragment_sampler_states(pipe, num_states, states);
      break;
   default:
      debug_error("Unexpected shader in trace_context_bind_sampler_states()");
   }
d310 3
a312 3
trace_context_bind_fragment_sampler_states(struct pipe_context *_pipe,
                                           unsigned num,
                                           void **states)
d314 5
a318 3
   trace_context_bind_sampler_states(_pipe, PIPE_SHADER_FRAGMENT,
                                     0, num, states);
}
d320 1
d322 3
a324 8
static INLINE void
trace_context_bind_vertex_sampler_states(struct pipe_context *_pipe,
                                         unsigned num,
                                         void **states)
{
   trace_context_bind_sampler_states(_pipe, PIPE_SHADER_VERTEX,
                                     0, num, states);
}
d326 1
d328 1
a328 7
static INLINE void
trace_context_bind_geometry_sampler_states(struct pipe_context *_pipe,
                                         unsigned num,
                                         void **states)
{
   trace_context_bind_sampler_states(_pipe, PIPE_SHADER_GEOMETRY,
                                     0, num, states);
d468 111
a578 42
#define TRACE_SHADER_STATE(shader_type) \
   static INLINE void * \
   trace_context_create_##shader_type##_state(struct pipe_context *_pipe, \
                                 const struct pipe_shader_state *state) \
   { \
      struct trace_context *tr_ctx = trace_context(_pipe); \
      struct pipe_context *pipe = tr_ctx->pipe; \
      void * result; \
      trace_dump_call_begin("pipe_context", "create_" #shader_type "_state"); \
      trace_dump_arg(ptr, pipe); \
      trace_dump_arg(shader_state, state); \
      result = pipe->create_##shader_type##_state(pipe, state); \
      trace_dump_ret(ptr, result); \
      trace_dump_call_end(); \
      return result; \
   } \
    \
   static INLINE void \
   trace_context_bind_##shader_type##_state(struct pipe_context *_pipe, \
                               void *state) \
   { \
      struct trace_context *tr_ctx = trace_context(_pipe); \
      struct pipe_context *pipe = tr_ctx->pipe; \
      trace_dump_call_begin("pipe_context", "bind_" #shader_type "_state"); \
      trace_dump_arg(ptr, pipe); \
      trace_dump_arg(ptr, state); \
      pipe->bind_##shader_type##_state(pipe, state); \
      trace_dump_call_end(); \
   } \
    \
   static INLINE void \
   trace_context_delete_##shader_type##_state(struct pipe_context *_pipe, \
                                 void *state) \
   { \
      struct trace_context *tr_ctx = trace_context(_pipe); \
      struct pipe_context *pipe = tr_ctx->pipe; \
      trace_dump_call_begin("pipe_context", "delete_" #shader_type "_state"); \
      trace_dump_arg(ptr, pipe); \
      trace_dump_arg(ptr, state); \
      pipe->delete_##shader_type##_state(pipe, state); \
      trace_dump_call_end(); \
   }
d580 1
a580 3
TRACE_SHADER_STATE(fs)
TRACE_SHADER_STATE(vs)
TRACE_SHADER_STATE(gs)
d582 2
a583 1
#undef TRACE_SHADER_STATE
d723 1
a723 1
                                  struct pipe_constant_buffer *constant_buffer)
a726 1
   struct pipe_constant_buffer cb;
d728 2
a729 4
   if (constant_buffer) {
      cb = *constant_buffer;
      cb.buffer = trace_resource_unwrap(tr_ctx, constant_buffer->buffer);
      constant_buffer = &cb;
d737 1
a737 1
   trace_dump_arg(constant_buffer, constant_buffer);
d739 1
a739 1
   pipe->set_constant_buffer(pipe, shader, index, constant_buffer);
d794 2
a795 4
trace_context_set_scissor_states(struct pipe_context *_pipe,
                                 unsigned start_slot,
                                 unsigned num_scissors,
                                 const struct pipe_scissor_state *states)
d800 1
a800 1
   trace_dump_call_begin("pipe_context", "set_scissor_states");
d803 1
a803 3
   trace_dump_arg(uint, start_slot);
   trace_dump_arg(uint, num_scissors);
   trace_dump_arg(scissor_state, states);
d805 1
a805 1
   pipe->set_scissor_states(pipe, start_slot, num_scissors, states);
d812 2
a813 4
trace_context_set_viewport_states(struct pipe_context *_pipe,
                                  unsigned start_slot,
                                  unsigned num_viewports,
                                  const struct pipe_viewport_state *states)
d818 1
a818 1
   trace_dump_call_begin("pipe_context", "set_viewport_states");
d821 1
a821 3
   trace_dump_arg(uint, start_slot);
   trace_dump_arg(uint, num_viewports);
   trace_dump_arg(viewport_state, states);
d823 1
a823 1
   pipe->set_viewport_states(pipe, start_slot, num_viewports, states);
d830 1
a830 1
trace_context_create_sampler_view(struct pipe_context *_pipe,
d835 1
a835 1
   struct trace_resource *tr_res = trace_resource(_resource);
d837 1
a837 1
   struct pipe_resource *resource = tr_res->resource;
d844 2
a845 1
   trace_dump_arg(ptr, resource);
d847 1
a847 5
   trace_dump_arg_begin("templ");
   trace_dump_sampler_view_template(templ, resource->target);
   trace_dump_arg_end();

   result = pipe->create_sampler_view(pipe, resource, templ);
d870 1
a870 1
trace_context_sampler_view_destroy(struct pipe_context *_pipe,
a877 2
   assert(_view->context == _pipe);

d897 3
a899 3
trace_context_create_surface(struct pipe_context *_pipe,
                             struct pipe_resource *_resource,
                             const struct pipe_surface *surf_tmpl)
d902 1
a902 1
   struct trace_resource *tr_res = trace_resource(_resource);
d904 1
a904 1
   struct pipe_resource *resource = tr_res->resource;
d910 3
a912 5
   trace_dump_arg(ptr, resource);
   
   trace_dump_arg_begin("surf_tmpl");
   trace_dump_surface_template(surf_tmpl, resource->target);
   trace_dump_arg_end();
d914 1
a914 2

   result = pipe->create_surface(pipe, resource, surf_tmpl);
d920 1
a920 1
   result = trace_surf_create(tr_ctx, tr_res, result);
d927 2
a928 2
trace_context_surface_destroy(struct pipe_context *_pipe,
                              struct pipe_surface *_surface)
d947 3
a949 5
trace_context_set_sampler_views(struct pipe_context *_pipe,
                                unsigned shader,
                                unsigned start,
                                unsigned num,
                                struct pipe_sampler_view **views)
a956 3
   /* remove this when we have pipe->set_sampler_views(..., start, ...) */
   assert(start == 0);

d963 1
a963 13
   switch (shader) {
   case PIPE_SHADER_VERTEX:
      trace_dump_call_begin("pipe_context", "set_vertex_sampler_views");
      break;
   case PIPE_SHADER_GEOMETRY:
      trace_dump_call_begin("pipe_context", "set_geometry_sampler_views");
      break;
   case PIPE_SHADER_FRAGMENT:
      trace_dump_call_begin("pipe_context", "set_fragment_sampler_views");
      break;
   default:
      debug_error("Unexpected shader in trace_context_set_sampler_views()");
   }
a965 1
   /*trace_dump_arg(uint, shader);*/
d969 1
a969 13
   switch (shader) {
   case PIPE_SHADER_VERTEX:
      pipe->set_vertex_sampler_views(pipe, num, views);
      break;
   case PIPE_SHADER_GEOMETRY:
      pipe->set_geometry_sampler_views(pipe, num, views);
      break;
   case PIPE_SHADER_FRAGMENT:
      pipe->set_fragment_sampler_views(pipe, num, views);
      break;
   default:
      debug_error("Unexpected shader in trace_context_set_sampler_views()");
   }
a975 9
trace_context_set_fragment_sampler_views(struct pipe_context *_pipe,
                                         unsigned num,
                                         struct pipe_sampler_view **views)
{
   trace_context_set_sampler_views(_pipe, PIPE_SHADER_FRAGMENT, 0, num, views);
}


static INLINE void
d980 20
a999 2
   trace_context_set_sampler_views(_pipe, PIPE_SHADER_VERTEX, 0, num, views);
}
d1001 1
d1003 1
a1003 6
static INLINE void
trace_context_set_geometry_sampler_views(struct pipe_context *_pipe,
                                       unsigned num,
                                       struct pipe_sampler_view **views)
{
   trace_context_set_sampler_views(_pipe, PIPE_SHADER_GEOMETRY, 0, num, views);
d1009 1
a1009 1
                                 unsigned start_slot, unsigned num_buffers,
a1018 1
   trace_dump_arg(uint, start_slot);
d1025 1
a1025 1
   if (buffers) {
d1030 1
a1030 1
      pipe->set_vertex_buffers(pipe, start_slot, num_buffers, _buffers);
d1033 1
a1033 1
      pipe->set_vertex_buffers(pipe, start_slot, num_buffers, NULL);
a1063 72

static INLINE struct pipe_stream_output_target *
trace_context_create_stream_output_target(struct pipe_context *_pipe,
                                          struct pipe_resource *res,
                                          unsigned buffer_offset,
                                          unsigned buffer_size)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_stream_output_target *result;

   res = trace_resource_unwrap(tr_ctx, res);

   trace_dump_call_begin("pipe_context", "create_stream_output_target");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, res);
   trace_dump_arg(uint, buffer_offset);
   trace_dump_arg(uint, buffer_size);

   result = pipe->create_stream_output_target(pipe,
                                              res, buffer_offset, buffer_size);

   trace_dump_ret(ptr, result);

   trace_dump_call_end();

   return result;
}


static INLINE void
trace_context_stream_output_target_destroy(
   struct pipe_context *_pipe,
   struct pipe_stream_output_target *target)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "stream_output_target_destroy");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, target);

   pipe->stream_output_target_destroy(pipe, target);

   trace_dump_call_end();
}


static INLINE void
trace_context_set_stream_output_targets(struct pipe_context *_pipe,
                                        unsigned num_targets,
                                        struct pipe_stream_output_target **tgs,
                                        unsigned append_bitmask)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   trace_dump_call_begin("pipe_context", "set_stream_output_targets");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(uint, num_targets);
   trace_dump_arg_array(ptr, tgs, num_targets);
   trace_dump_arg(uint, append_bitmask);

   pipe->set_stream_output_targets(pipe, num_targets, tgs, append_bitmask);

   trace_dump_call_end();
}


a1099 22
trace_context_blit(struct pipe_context *_pipe,
                   const struct pipe_blit_info *_info)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;
   struct pipe_blit_info info = *_info;

   info.dst.resource = trace_resource_unwrap(tr_ctx, info.dst.resource);
   info.src.resource = trace_resource_unwrap(tr_ctx, info.src.resource);

   trace_dump_call_begin("pipe_context", "blit");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(blit_info, _info);

   pipe->blit(pipe, &info);

   trace_dump_call_end();
}


static INLINE void
d1102 1
a1102 1
                    const union pipe_color_union *color,
d1113 2
a1114 3
   trace_dump_arg_begin("color");
   if (color)
      trace_dump_array(float, color->f, 4);
a1116 1
   trace_dump_arg_end();
d1120 1
a1120 1
   pipe->clear(pipe, buffers, color, depth, stencil);
d1129 1
a1129 1
                                  const union pipe_color_union *color,
d1142 1
a1142 1
   trace_dump_arg_array(float, color->f, 4);
d1148 1
a1148 1
   pipe->clear_render_target(pipe, dst, color, dstx, dsty, width, height);
d1187 2
a1188 2
                    struct pipe_fence_handle **fence,
                    unsigned flags)
d1198 1
a1198 1
   pipe->flush(pipe, fence, flags);
d1222 25
d1253 2
a1254 2
static void *
trace_context_transfer_map(struct pipe_context *_context,
d1258 1
a1258 2
                           const struct pipe_box *box,
                           struct pipe_transfer **transfer)
d1261 1
a1261 1
   struct trace_resource *tr_res = trace_resource(_resource);
d1263 1
a1263 1
   struct pipe_resource *texture = tr_res->resource;
a1264 1
   void *map;
d1273 19
a1291 3
   map = context->transfer_map(context, texture, level, usage, box, &result);
   if (!map)
      return NULL;
d1293 9
a1301 1
   *transfer = trace_transfer_create(tr_context, tr_res, result);
d1303 5
a1307 3
   if (map) {
      if(usage & PIPE_TRANSFER_WRITE) {
         trace_transfer(*transfer)->map = map;
d1311 1
a1311 1
   return *transfer ? map : NULL;
d1314 1
d1361 1
a1361 1
                           resource,
a1375 1
   trace_transfer_destroy(tr_ctx, tr_trans);
d1390 1
a1390 1
   struct trace_resource *tr_res = trace_resource(_resource);
d1392 1
a1392 1
   struct pipe_resource *resource = tr_res->resource;
d1406 1
a1406 1
                        resource,
a1421 34
static void trace_context_render_condition(struct pipe_context *_context,
                                           struct pipe_query *query,
                                           boolean condition,
                                           uint mode)
{
   struct trace_context *tr_context = trace_context(_context);
   struct pipe_context *context = tr_context->pipe;

   trace_dump_call_begin("pipe_context", "render_condition");

   trace_dump_arg(ptr, context);
   trace_dump_arg(ptr, query);
   trace_dump_arg(bool, condition);
   trace_dump_arg(uint, mode);

   trace_dump_call_end();

   context->render_condition(context, query, condition, mode);
}


static void trace_context_texture_barrier(struct pipe_context *_context)
{
   struct trace_context *tr_context = trace_context(_context);
   struct pipe_context *context = tr_context->pipe;

   trace_dump_call_begin("pipe_context", "texture_barrier");

   trace_dump_arg(ptr, context);

   trace_dump_call_end();

   context->texture_barrier(context);
}
d1446 1
d1451 58
a1508 72

#define TR_CTX_INIT(_member) \
   tr_ctx->base . _member = pipe -> _member ? trace_context_ ## _member : NULL

   TR_CTX_INIT(draw_vbo);
   TR_CTX_INIT(render_condition);
   TR_CTX_INIT(create_query);
   TR_CTX_INIT(destroy_query);
   TR_CTX_INIT(begin_query);
   TR_CTX_INIT(end_query);
   TR_CTX_INIT(get_query_result);
   TR_CTX_INIT(create_blend_state);
   TR_CTX_INIT(bind_blend_state);
   TR_CTX_INIT(delete_blend_state);
   TR_CTX_INIT(create_sampler_state);
   TR_CTX_INIT(bind_fragment_sampler_states);
   TR_CTX_INIT(bind_vertex_sampler_states);
   TR_CTX_INIT(bind_geometry_sampler_states);
   TR_CTX_INIT(delete_sampler_state);
   TR_CTX_INIT(create_rasterizer_state);
   TR_CTX_INIT(bind_rasterizer_state);
   TR_CTX_INIT(delete_rasterizer_state);
   TR_CTX_INIT(create_depth_stencil_alpha_state);
   TR_CTX_INIT(bind_depth_stencil_alpha_state);
   TR_CTX_INIT(delete_depth_stencil_alpha_state);
   TR_CTX_INIT(create_fs_state);
   TR_CTX_INIT(bind_fs_state);
   TR_CTX_INIT(delete_fs_state);
   TR_CTX_INIT(create_vs_state);
   TR_CTX_INIT(bind_vs_state);
   TR_CTX_INIT(delete_vs_state);
   TR_CTX_INIT(create_gs_state);
   TR_CTX_INIT(bind_gs_state);
   TR_CTX_INIT(delete_gs_state);
   TR_CTX_INIT(create_vertex_elements_state);
   TR_CTX_INIT(bind_vertex_elements_state);
   TR_CTX_INIT(delete_vertex_elements_state);
   TR_CTX_INIT(set_blend_color);
   TR_CTX_INIT(set_stencil_ref);
   TR_CTX_INIT(set_clip_state);
   TR_CTX_INIT(set_sample_mask);
   TR_CTX_INIT(set_constant_buffer);
   TR_CTX_INIT(set_framebuffer_state);
   TR_CTX_INIT(set_polygon_stipple);
   TR_CTX_INIT(set_scissor_states);
   TR_CTX_INIT(set_viewport_states);
   TR_CTX_INIT(set_fragment_sampler_views);
   TR_CTX_INIT(set_vertex_sampler_views);
   TR_CTX_INIT(set_geometry_sampler_views);
   TR_CTX_INIT(create_sampler_view);
   TR_CTX_INIT(sampler_view_destroy);
   TR_CTX_INIT(create_surface);
   TR_CTX_INIT(surface_destroy);
   TR_CTX_INIT(set_vertex_buffers);
   TR_CTX_INIT(set_index_buffer);
   TR_CTX_INIT(create_stream_output_target);
   TR_CTX_INIT(stream_output_target_destroy);
   TR_CTX_INIT(set_stream_output_targets);
   TR_CTX_INIT(resource_copy_region);
   TR_CTX_INIT(blit);
   TR_CTX_INIT(clear);
   TR_CTX_INIT(clear_render_target);
   TR_CTX_INIT(clear_depth_stencil);
   TR_CTX_INIT(flush);
   TR_CTX_INIT(texture_barrier);

   TR_CTX_INIT(transfer_map);
   TR_CTX_INIT(transfer_unmap);
   TR_CTX_INIT(transfer_flush_region);
   TR_CTX_INIT(transfer_inline_write);

#undef TR_CTX_INIT
a1516 13


/**
 * Sanity checker: check that the given context really is a 
 * trace context (and not the wrapped driver's context).
 */
void
trace_context_check(const struct pipe_context *pipe)
{
   struct trace_context *tr_ctx = (struct trace_context *) pipe;
   assert(tr_ctx->base.destroy == trace_context_destroy);
}

@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2008 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a35 1
#include "tr_dump_defines.h"
a42 12
struct trace_query
{
   unsigned type;

   struct pipe_query *query;
};


static INLINE struct trace_query *
trace_query(struct pipe_query *query) {
   return (struct trace_query *)query;
}
a44 10
static INLINE struct pipe_query *
trace_query_unwrap(struct pipe_query *query)
{
   if (query) {
      return trace_query(query)->query;
   } else {
      return NULL;
   }
}

d111 1
a111 1
   struct pipe_query *query;
d116 1
a116 1
   trace_dump_arg(query_type, query_type);
d118 1
a118 1
   query = pipe->create_query(pipe, query_type);
d120 1
a120 1
   trace_dump_ret(ptr, query);
d124 1
a124 14
   /* Wrap query object. */
   if (query) {
      struct trace_query *tr_query = CALLOC_STRUCT(trace_query);
      if (tr_query) {
         tr_query->type = query_type;
         tr_query->query = query;
         query = (struct pipe_query *)tr_query;
      } else {
         pipe->destroy_query(pipe, query);
         query = NULL;
      }
   }

   return query;
d130 1
a130 1
                            struct pipe_query *_query)
a133 4
   struct trace_query *tr_query = trace_query(_query);
   struct pipe_query *query = tr_query->query;

   FREE(tr_query);
a152 2
   query = trace_query_unwrap(query);

a170 2
   query = trace_query_unwrap(query);

d184 1
a184 1
                               struct pipe_query *_query,
d186 1
a186 1
                               union pipe_query_result *result)
d190 2
a191 3
   struct trace_query *tr_query = trace_query(_query);
   struct pipe_query *query = tr_query->query;
   boolean ret;
a195 1
   trace_dump_arg(ptr, query);
d197 3
a199 1
   ret = pipe->get_query_result(pipe, query, wait, result);
d201 2
a202 9
   trace_dump_arg_begin("result");
   if (ret) {
      trace_dump_query_result(tr_query->type, result);
   } else {
      trace_dump_null();
   }
   trace_dump_arg_end();

   trace_dump_ret(bool, ret);
d206 1
a206 1
   return ret;
d305 13
a317 1
   trace_dump_call_begin("pipe_context", "bind_sampler_states");
a319 2
   trace_dump_arg(uint, shader);
   trace_dump_arg(uint, start);
d323 13
a335 1
   pipe->bind_sampler_states(pipe, shader, start, num_states, states);
d342 30
d946 1
a946 1
   struct pipe_sampler_view *unwrapped_views[PIPE_MAX_SHADER_SAMPLER_VIEWS];
d958 13
a970 1
   trace_dump_call_begin("pipe_context", "set_sampler_views");
d973 1
a973 2
   trace_dump_arg(uint, shader);
   trace_dump_arg(uint, start);
d977 13
a989 1
   pipe->set_sampler_views(pipe, shader, start, num, views);
d996 27
d1134 1
a1134 1
                                        const unsigned *offsets)
d1144 1
a1144 1
   trace_dump_arg_array(uint, offsets, num_targets);
d1146 1
a1146 1
   pipe->set_stream_output_targets(pipe, num_targets, tgs, offsets);
a1208 20
static void
trace_context_flush_resource(struct pipe_context *_pipe,
                             struct pipe_resource *resource)
{
   struct trace_context *tr_ctx = trace_context(_pipe);
   struct pipe_context *pipe = tr_ctx->pipe;

   resource = trace_resource_unwrap(tr_ctx, resource);

   trace_dump_call_begin("pipe_context", "flush_resource");

   trace_dump_arg(ptr, pipe);
   trace_dump_arg(ptr, resource);

   pipe->flush_resource(pipe, resource);

   trace_dump_call_end();
}


a1492 2
   query = trace_query_unwrap(query);

a1520 15
static void trace_context_memory_barrier(struct pipe_context *_context,
                                         unsigned flags)
{
   struct trace_context *tr_context = trace_context(_context);
   struct pipe_context *context = tr_context->pipe;

   trace_dump_call_begin("pipe_context", "memory_barrier");
   trace_dump_arg(ptr, context);
   trace_dump_arg(uint, flags);
   trace_dump_call_end();

   context->memory_barrier(context, flags);
}


d1562 3
a1564 1
   TR_CTX_INIT(bind_sampler_states);
d1593 3
a1595 1
   TR_CTX_INIT(set_sampler_views);
a1606 1
   TR_CTX_INIT(flush_resource);
a1611 1
   TR_CTX_INIT(memory_barrier);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d130 1
a130 2
                           unsigned query_type,
                           unsigned index)
a139 1
   trace_dump_arg(int, index);
d141 1
a141 1
   query = pipe->create_query(pipe, query_type, index);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d130 2
a131 1
                           unsigned query_type)
d141 1
d143 1
a143 1
   query = pipe->create_query(pipe, query_type);
@


