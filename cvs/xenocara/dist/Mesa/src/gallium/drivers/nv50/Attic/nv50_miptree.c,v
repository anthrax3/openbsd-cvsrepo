head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.07.09.21.08.54;	author jsg;	state dead;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.42;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.40;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@/*
 * Copyright 2008 Ben Skeggs
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include "pipe/p_state.h"
#include "pipe/p_defines.h"
#include "util/u_inlines.h"
#include "util/u_format.h"

#include "nv50_context.h"
#include "nv50_resource.h"

uint32_t
nv50_tex_choose_tile_dims_helper(unsigned nx, unsigned ny, unsigned nz)
{
   uint32_t tile_mode = 0x000;

   if (ny > 64) tile_mode = 0x040; /* height 128 tiles */
   else
   if (ny > 32) tile_mode = 0x030; /* height 64 tiles */
   else
   if (ny > 16) tile_mode = 0x020; /* height 32 tiles */
   else
   if (ny >  8) tile_mode = 0x010; /* height 16 tiles */

   if (nz == 1)
      return tile_mode;
   else
      if (tile_mode > 0x020)
         tile_mode = 0x020;

   if (nz > 16 && tile_mode < 0x020)
      return tile_mode | 0x500; /* depth 32 tiles */
   if (nz > 8) return tile_mode | 0x400; /* depth 16 tiles */
   if (nz > 4) return tile_mode | 0x300; /* depth 8 tiles */
   if (nz > 2) return tile_mode | 0x200; /* depth 4 tiles */

   return tile_mode | 0x100;
}

static uint32_t
nv50_tex_choose_tile_dims(unsigned nx, unsigned ny, unsigned nz)
{
   return nv50_tex_choose_tile_dims_helper(nx, ny * 2, nz);
}

static uint32_t
nv50_mt_choose_storage_type(struct nv50_miptree *mt, boolean compressed)
{
   const unsigned ms = mt->ms_x + mt->ms_y;

   uint32_t tile_flags;

   if (unlikely(mt->base.base.flags & NOUVEAU_RESOURCE_FLAG_LINEAR))
      return 0;
   if (unlikely(mt->base.base.bind & PIPE_BIND_CURSOR))
      return 0;

   switch (mt->base.base.format) {
   case PIPE_FORMAT_Z16_UNORM:
      tile_flags = 0x6c + ms;
      break;
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
      tile_flags = 0x18 + ms;
      break;
   case PIPE_FORMAT_Z24X8_UNORM:
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
      tile_flags = 0x128 + ms;
      break;
   case PIPE_FORMAT_Z32_FLOAT:
      tile_flags = 0x40 + ms;
      break;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      tile_flags = 0x60 + ms;
      break;
   default:
      switch (util_format_get_blocksizebits(mt->base.base.format)) {
      case 128:
         assert(ms < 3);
         tile_flags = 0x74;
         break;
      case 64:
         switch (ms) {
         case 2: tile_flags = 0xfc; break;
         case 3: tile_flags = 0xfd; break;
         default:
            tile_flags = 0x70;
            break;
         }
         break;
      case 32:
         if (mt->base.base.bind & PIPE_BIND_SCANOUT) {
            assert(ms == 0);
            tile_flags = 0x7a;
         } else {
            switch (ms) {
            case 2: tile_flags = 0xf8; break;
            case 3: tile_flags = 0xf9; break;
            default:
               tile_flags = 0x70;
               break;
            }
         }
         break;
      case 16:
      case 8:
         tile_flags = 0x70;
         break;
      default:
         return 0;
      }
      if (mt->base.base.bind & PIPE_BIND_CURSOR)
         tile_flags = 0;
   }

   if (!compressed)
      tile_flags &= ~0x180;

   return tile_flags;
}

void
nv50_miptree_destroy(struct pipe_screen *pscreen, struct pipe_resource *pt)
{
   struct nv50_miptree *mt = nv50_miptree(pt);

   nouveau_bo_ref(NULL, &mt->base.bo);

   nouveau_fence_ref(NULL, &mt->base.fence);
   nouveau_fence_ref(NULL, &mt->base.fence_wr);

   NOUVEAU_DRV_STAT(nouveau_screen(pscreen), tex_obj_current_count, -1);
   NOUVEAU_DRV_STAT(nouveau_screen(pscreen), tex_obj_current_bytes,
                    -(uint64_t)mt->total_size);

   FREE(mt);
}

boolean
nv50_miptree_get_handle(struct pipe_screen *pscreen,
                        struct pipe_resource *pt,
                        struct winsys_handle *whandle)
{
   struct nv50_miptree *mt = nv50_miptree(pt);
   unsigned stride;

   if (!mt || !mt->base.bo)
      return FALSE;

   stride = mt->level[0].pitch;

   return nouveau_screen_bo_get_handle(pscreen,
                                       mt->base.bo,
                                       stride,
                                       whandle);
}

const struct u_resource_vtbl nv50_miptree_vtbl =
{
   nv50_miptree_get_handle,         /* get_handle */
   nv50_miptree_destroy,            /* resource_destroy */
   nv50_miptree_transfer_map,       /* transfer_map */
   u_default_transfer_flush_region, /* transfer_flush_region */
   nv50_miptree_transfer_unmap,     /* transfer_unmap */
   u_default_transfer_inline_write  /* transfer_inline_write */
};

static INLINE boolean
nv50_miptree_init_ms_mode(struct nv50_miptree *mt)
{
   switch (mt->base.base.nr_samples) {
   case 8:
      mt->ms_mode = NV50_3D_MULTISAMPLE_MODE_MS8;
      mt->ms_x = 2;
      mt->ms_y = 1;
      break;
   case 4:
      mt->ms_mode = NV50_3D_MULTISAMPLE_MODE_MS4;
      mt->ms_x = 1;
      mt->ms_y = 1;
      break;
   case 2:
      mt->ms_mode = NV50_3D_MULTISAMPLE_MODE_MS2;
      mt->ms_x = 1;
      break;
   case 1:
   case 0:
      mt->ms_mode = NV50_3D_MULTISAMPLE_MODE_MS1;
      break;
   default:
      NOUVEAU_ERR("invalid nr_samples: %u\n", mt->base.base.nr_samples);
      return FALSE;
   }
   return TRUE;
}

boolean
nv50_miptree_init_layout_linear(struct nv50_miptree *mt, unsigned pitch_align)
{
   struct pipe_resource *pt = &mt->base.base;
   const unsigned blocksize = util_format_get_blocksize(pt->format);
   unsigned h = pt->height0;

   if (util_format_is_depth_or_stencil(pt->format))
      return FALSE;

   if ((pt->last_level > 0) || (pt->depth0 > 1) || (pt->array_size > 1))
      return FALSE;
   if (mt->ms_x | mt->ms_y)
      return FALSE;

   mt->level[0].pitch = align(pt->width0 * blocksize, pitch_align);

   /* Account for very generous prefetch (allocate size as if tiled). */
   h = MAX2(h, 8);
   h = util_next_power_of_two(h);

   mt->total_size = mt->level[0].pitch * h;

   return TRUE;
}

static void
nv50_miptree_init_layout_video(struct nv50_miptree *mt)
{
   const struct pipe_resource *pt = &mt->base.base;
   const unsigned blocksize = util_format_get_blocksize(pt->format);

   assert(pt->last_level == 0);
   assert(mt->ms_x == 0 && mt->ms_y == 0);
   assert(!util_format_is_compressed(pt->format));

   mt->layout_3d = pt->target == PIPE_TEXTURE_3D;

   mt->level[0].tile_mode = 0x20;
   mt->level[0].pitch = align(pt->width0 * blocksize, 64);
   mt->total_size = align(pt->height0, 16) * mt->level[0].pitch * (mt->layout_3d ? pt->depth0 : 1);

   if (pt->array_size > 1) {
      mt->layer_stride = align(mt->total_size, NV50_TILE_SIZE(0x20));
      mt->total_size = mt->layer_stride * pt->array_size;
   }
}

static void
nv50_miptree_init_layout_tiled(struct nv50_miptree *mt)
{
   struct pipe_resource *pt = &mt->base.base;
   unsigned w, h, d, l;
   const unsigned blocksize = util_format_get_blocksize(pt->format);

   mt->layout_3d = pt->target == PIPE_TEXTURE_3D;

   w = pt->width0 << mt->ms_x;
   h = pt->height0 << mt->ms_y;

   /* For 3D textures, a mipmap is spanned by all the layers, for array
    * textures and cube maps, each layer contains its own mipmaps.
    */
   d = mt->layout_3d ? pt->depth0 : 1;

   for (l = 0; l <= pt->last_level; ++l) {
      struct nv50_miptree_level *lvl = &mt->level[l];
      unsigned tsx, tsy, tsz;
      unsigned nbx = util_format_get_nblocksx(pt->format, w);
      unsigned nby = util_format_get_nblocksy(pt->format, h);

      lvl->offset = mt->total_size;

      lvl->tile_mode = nv50_tex_choose_tile_dims(nbx, nby, d);

      tsx = NV50_TILE_SIZE_X(lvl->tile_mode); /* x is tile row pitch in bytes */
      tsy = NV50_TILE_SIZE_Y(lvl->tile_mode);
      tsz = NV50_TILE_SIZE_Z(lvl->tile_mode);

      lvl->pitch = align(nbx * blocksize, tsx);

      mt->total_size += lvl->pitch * align(nby, tsy) * align(d, tsz);

      w = u_minify(w, 1);
      h = u_minify(h, 1);
      d = u_minify(d, 1);
   }

   if (pt->array_size > 1) {
      mt->layer_stride = align(mt->total_size,
                               NV50_TILE_SIZE(mt->level[0].tile_mode));
      mt->total_size = mt->layer_stride * pt->array_size;
   }
}

struct pipe_resource *
nv50_miptree_create(struct pipe_screen *pscreen,
                    const struct pipe_resource *templ)
{
   struct nouveau_device *dev = nouveau_screen(pscreen)->device;
   struct nv50_miptree *mt = CALLOC_STRUCT(nv50_miptree);
   struct pipe_resource *pt = &mt->base.base;
   int ret;
   union nouveau_bo_config bo_config;
   uint32_t bo_flags;

   if (!mt)
      return NULL;

   mt->base.vtbl = &nv50_miptree_vtbl;
   *pt = *templ;
   pipe_reference_init(&pt->reference, 1);
   pt->screen = pscreen;

   bo_config.nv50.memtype = nv50_mt_choose_storage_type(mt, TRUE);

   if (!nv50_miptree_init_ms_mode(mt)) {
      FREE(mt);
      return NULL;
   }

   if (unlikely(pt->flags & NV50_RESOURCE_FLAG_VIDEO)) {
      nv50_miptree_init_layout_video(mt);
      /* BO allocation done by client */
      return pt;
   } else
   if (bo_config.nv50.memtype != 0) {
      nv50_miptree_init_layout_tiled(mt);
   } else
   if (!nv50_miptree_init_layout_linear(mt, 64)) {
      FREE(mt);
      return NULL;
   }
   bo_config.nv50.tile_mode = mt->level[0].tile_mode;

   bo_flags = NOUVEAU_BO_VRAM | NOUVEAU_BO_NOSNOOP;
   if (mt->base.base.bind & (PIPE_BIND_CURSOR | PIPE_BIND_DISPLAY_TARGET))
      bo_flags |= NOUVEAU_BO_CONTIG;

   ret = nouveau_bo_new(dev, bo_flags, 4096, mt->total_size, &bo_config,
                        &mt->base.bo);
   if (ret) {
      FREE(mt);
      return NULL;
   }
   mt->base.domain = NOUVEAU_BO_VRAM;
   mt->base.address = mt->base.bo->offset;

   return pt;
}

struct pipe_resource *
nv50_miptree_from_handle(struct pipe_screen *pscreen,
                         const struct pipe_resource *templ,
                         struct winsys_handle *whandle)
{
   struct nv50_miptree *mt;
   unsigned stride;

   /* only supports 2D, non-mipmapped textures for the moment */
   if ((templ->target != PIPE_TEXTURE_2D &&
        templ->target != PIPE_TEXTURE_RECT) ||
       templ->last_level != 0 ||
       templ->depth0 != 1 ||
       templ->array_size > 1)
      return NULL;

   mt = CALLOC_STRUCT(nv50_miptree);
   if (!mt)
      return NULL;

   mt->base.bo = nouveau_screen_bo_from_handle(pscreen, whandle, &stride);
   if (mt->base.bo == NULL) {
      FREE(mt);
      return NULL;
   }
   mt->base.domain = NOUVEAU_BO_VRAM;
   mt->base.address = mt->base.bo->offset;

   mt->base.base = *templ;
   mt->base.vtbl = &nv50_miptree_vtbl;
   pipe_reference_init(&mt->base.base.reference, 1);
   mt->base.base.screen = pscreen;
   mt->level[0].pitch = stride;
   mt->level[0].offset = 0;
   mt->level[0].tile_mode = mt->base.bo->config.nv50.tile_mode;

   /* no need to adjust bo reference count */
   return &mt->base.base;
}


/* Offset of zslice @@z from start of level @@l. */
INLINE unsigned
nv50_mt_zslice_offset(const struct nv50_miptree *mt, unsigned l, unsigned z)
{
   const struct pipe_resource *pt = &mt->base.base;

   unsigned tds = NV50_TILE_SHIFT_Z(mt->level[l].tile_mode);
   unsigned ths = NV50_TILE_SHIFT_Y(mt->level[l].tile_mode);

   unsigned nby = util_format_get_nblocksy(pt->format,
                                           u_minify(pt->height0, l));

   /* to next 2D tile slice within a 3D tile */
   unsigned stride_2d = NV50_TILE_SIZE_2D(mt->level[l].tile_mode);

   /* to slice in the next (in z direction) 3D tile */
   unsigned stride_3d = (align(nby, (1 << ths)) * mt->level[l].pitch) << tds;

   return (z & ((1 << tds) - 1)) * stride_2d + (z >> tds) * stride_3d;
}

/* Surface functions.
 */

struct nv50_surface *
nv50_surface_from_miptree(struct nv50_miptree *mt,
                          const struct pipe_surface *templ)
{
   struct pipe_surface *ps;
   struct nv50_surface *ns = CALLOC_STRUCT(nv50_surface);
   if (!ns)
      return NULL;
   ps = &ns->base;

   pipe_reference_init(&ps->reference, 1);
   pipe_resource_reference(&ps->texture, &mt->base.base);

   ps->format = templ->format;
   ps->writable = templ->writable;
   ps->u.tex.level = templ->u.tex.level;
   ps->u.tex.first_layer = templ->u.tex.first_layer;
   ps->u.tex.last_layer = templ->u.tex.last_layer;

   ns->width = u_minify(mt->base.base.width0, ps->u.tex.level);
   ns->height = u_minify(mt->base.base.height0, ps->u.tex.level);
   ns->depth = ps->u.tex.last_layer - ps->u.tex.first_layer + 1;
   ns->offset = mt->level[templ->u.tex.level].offset;

   /* comment says there are going to be removed, but they're used by the st */
   ps->width = ns->width;
   ps->height = ns->height;

   ns->width <<= mt->ms_x;
   ns->height <<= mt->ms_y;

   return ns;
}

struct pipe_surface *
nv50_miptree_surface_new(struct pipe_context *pipe,
                         struct pipe_resource *pt,
                         const struct pipe_surface *templ)
{
   struct nv50_miptree *mt = nv50_miptree(pt);
   struct nv50_surface *ns = nv50_surface_from_miptree(mt, templ);
   if (!ns)
      return NULL;
   ns->base.context = pipe;

   if (ns->base.u.tex.first_layer) {
      const unsigned l = ns->base.u.tex.level;
      const unsigned z = ns->base.u.tex.first_layer;

      if (mt->layout_3d) {
         ns->offset += nv50_mt_zslice_offset(mt, l, z);

         /* TODO: switch to depth 1 tiles; but actually this shouldn't happen */
         if (ns->depth > 1 &&
             (z & (NV50_TILE_SIZE_Z(mt->level[l].tile_mode) - 1)))
            NOUVEAU_ERR("Creating unsupported 3D surface !\n");
      } else {
         ns->offset += mt->layer_stride * z;
      }
   }

   return &ns->base;
}
@


1.4
log
@Merge Mesa 9.2.0
@
text
@@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d17 4
a20 4
 * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
a29 1
#include "nv50_transfer.h"
d31 2
a32 2
static INLINE uint32_t
get_tile_dims(unsigned nx, unsigned ny, unsigned nz)
d34 1
a34 1
   uint32_t tile_mode = 0x00;
d36 1
a36 1
   if (ny > 32) tile_mode = 0x04; /* height 128 tiles */
d38 1
a38 1
   if (ny > 16) tile_mode = 0x03; /* height 64 tiles */
d40 1
a40 1
   if (ny >  8) tile_mode = 0x02; /* height 32 tiles */
d42 1
a42 1
   if (ny >  4) tile_mode = 0x01; /* height 16 tiles */
d47 2
a48 2
   if (tile_mode > 0x02)
      tile_mode = 0x02;
d50 5
a54 5
   if (nz > 16 && tile_mode < 0x02)
      return tile_mode | 0x50; /* depth 32 tiles */
   if (nz > 8) return tile_mode | 0x40; /* depth 16 tiles */
   if (nz > 4) return tile_mode | 0x30; /* depth 8 tiles */
   if (nz > 2) return tile_mode | 0x20; /* depth 4 tiles */
d56 1
a56 1
   return tile_mode | 0x10;
d59 2
a60 2
static INLINE unsigned
calc_zslice_offset(uint32_t tile_mode, unsigned z, unsigned pitch, unsigned nbh)
d62 71
a132 3
   unsigned tile_h = NV50_TILE_HEIGHT(tile_mode);
   unsigned tile_d_shift = NV50_TILE_DIM_SHIFT(tile_mode, 1);
   unsigned tile_d = 1 << tile_d_shift;
d134 2
a135 4
   /* stride_2d == to next slice within this volume tile */
   /* stride_3d == size (in bytes) of a volume tile */
   unsigned stride_2d = tile_h * NV50_TILE_PITCH(tile_mode);
   unsigned stride_3d = tile_d * align(nbh, tile_h) * pitch;
d137 1
a137 1
   return (z & (tile_d - 1)) * stride_2d + (z >> tile_d_shift) * stride_3d;
d140 1
a140 1
static void
d145 8
a152 1
   nouveau_screen_bo_release(pscreen, mt->base.bo);
d157 1
a157 1
static boolean
d168 1
a168 2
   stride = util_format_get_stride(mt->base.base.format,
                                   mt->base.base.width0);
d180 1
a180 3
   nv50_miptree_transfer_new,       /* get_transfer */
   nv50_miptree_transfer_del,       /* transfer_destroy */
   nv50_miptree_transfer_map,	      /* transfer_map */
d186 31
a216 3
struct pipe_resource *
nv50_miptree_create(struct pipe_screen *pscreen,
                    const struct pipe_resource *templ)
a217 2
   struct nouveau_device *dev = nouveau_screen(pscreen)->device;
   struct nv50_miptree *mt = CALLOC_STRUCT(nv50_miptree);
d219 21
a239 3
   int ret;
   unsigned w, h, d, l, alloc_size;
   uint32_t tile_flags;
d241 5
a245 2
   if (!mt)
      return NULL;
d247 3
a249 4
   mt->base.vtbl = &nv50_miptree_vtbl;
   *pt = *templ;
   pipe_reference_init(&pt->reference, 1);
   pt->screen = pscreen;
d253 3
a255 3
   w = pt->width0;
   h = pt->height0;
   d = mt->layout_3d ? pt->depth0 : 1;
d257 3
a259 31
   switch (pt->format) {
   case PIPE_FORMAT_Z16_UNORM:
      tile_flags = 0x6c00;
      break;
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
      tile_flags = 0x1800;
      break;
   case PIPE_FORMAT_Z24X8_UNORM:
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
      tile_flags = 0x2800;
      break;
   case PIPE_FORMAT_R32G32B32A32_FLOAT:
   case PIPE_FORMAT_R32G32B32_FLOAT:
      tile_flags = 0x7400;
      break;
   case PIPE_FORMAT_Z32_FLOAT:
      tile_flags = 0x4000;
      break;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_USCALED:
      tile_flags = 0x6000;
      break;
   default:
      if (pt->bind & PIPE_BIND_CURSOR)
         tile_flags = 0;
      else
      if ((pt->bind & PIPE_BIND_SCANOUT) &&
          util_format_get_blocksizebits(pt->format) == 32)
         tile_flags = 0x7a00;
      else
         tile_flags = 0x7000;
      break;
d261 13
a273 2
   if (pt->bind & (PIPE_BIND_SCANOUT | PIPE_BIND_CURSOR))
      tile_flags |= NOUVEAU_BO_TILE_SCANOUT;
d278 2
d282 1
a284 1
      unsigned blocksize = util_format_get_blocksize(pt->format);
d288 5
a292 2
      if (tile_flags & NOUVEAU_BO_TILE_LAYOUT_MASK)
         lvl->tile_mode = get_tile_dims(nbx, nby, d);
d294 1
a294 1
      lvl->pitch = align(nbx * blocksize, NV50_TILE_PITCH(lvl->tile_mode));
d296 1
a296 3
      mt->total_size += lvl->pitch *
         align(nby, NV50_TILE_HEIGHT(lvl->tile_mode)) *
         align(d, NV50_TILE_DEPTH(lvl->tile_mode));
d308 27
d336 13
a348 1
   alloc_size = mt->total_size;
d350 6
a355 3
   ret = nouveau_bo_new_tile(dev, NOUVEAU_BO_VRAM, 256, alloc_size,
                             mt->level[0].tile_mode, tile_flags,
                             &mt->base.bo);
d361 1
d391 2
d400 1
a400 1
   mt->level[0].tile_mode = mt->base.bo->tile_mode;
d407 21
d431 3
a433 4
struct pipe_surface *
nv50_miptree_surface_new(struct pipe_context *pipe,
                         struct pipe_resource *pt,
                         const struct pipe_surface *templ)
a434 2
   struct nv50_miptree *mt = nv50_miptree(pt); /* guaranteed */
   struct nv50_surface *ns;
d436 1
a436 3
   struct nv50_miptree_level *lvl = &mt->level[templ->u.tex.level];

   ns = CALLOC_STRUCT(nv50_surface);
d442 2
a443 2
   pipe_resource_reference(&ps->texture, pt);
   ps->context = pipe;
d445 1
a445 1
   ps->usage = templ->usage;
d450 2
a451 2
   ns->width = u_minify(pt->width0, ps->u.tex.level);
   ns->height = u_minify(pt->height0, ps->u.tex.level);
d453 1
a453 1
   ns->offset = lvl->offset;
d459 2
a460 14
   if (mt->layout_3d) {
      unsigned zslice = ps->u.tex.first_layer;

      /* TODO: re-layout the texture to use only depth 1 tiles in this case: */
      if (ns->depth > 1 && (zslice & (NV50_TILE_DEPTH(lvl->tile_mode) - 1)))
         NOUVEAU_ERR("Creating unsupported 3D surface of slices [%u:%u].\n",
                     zslice, ps->u.tex.last_layer);

      ns->offset += calc_zslice_offset(lvl->tile_mode, zslice, lvl->pitch,
                                       util_format_get_nblocksy(pt->format,
                                                                ns->height));
   } else {
      ns->offset += mt->layer_stride * ps->u.tex.first_layer;
   }
d462 1
a462 1
   return ps;
d465 4
a468 2
void
nv50_miptree_surface_del(struct pipe_context *pipe, struct pipe_surface *ps)
d470 5
a474 1
   struct nv50_surface *s = nv50_surface(ps);
d476 15
a490 1
   pipe_resource_reference(&ps->texture, NULL);
d492 1
a492 1
   FREE(s);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a31 1
/* The restrictions in tile mode selection probably aren't necessary. */
d33 1
a33 1
get_tile_mode(unsigned ny, unsigned d)
d35 1
a35 1
	uint32_t tile_mode = 0x00;
d37 19
a55 19
	if (ny > 32) tile_mode = 0x04; /* height 64 tiles */
	else
	if (ny > 16) tile_mode = 0x03; /* height 32 tiles */
	else
	if (ny >  8) tile_mode = 0x02; /* height 16 tiles */
	else
	if (ny >  4) tile_mode = 0x01; /* height 8 tiles */

	if (d == 1)
		return tile_mode;
	else
	if (tile_mode > 0x02)
		tile_mode = 0x02;

	if (d > 16 && tile_mode < 0x02)
		return tile_mode | 0x50; /* depth 32 tiles */
	if (d >  8) return tile_mode | 0x40; /* depth 16 tiles */
	if (d >  4) return tile_mode | 0x30; /* depth 8 tiles */
	if (d >  2) return tile_mode | 0x20; /* depth 4 tiles */
d57 1
a57 1
	return tile_mode | 0x10;
d61 1
a61 1
get_zslice_offset(unsigned tile_mode, unsigned z, unsigned pitch, unsigned nb_h)
d63 8
a70 2
	unsigned tile_h = get_tile_height(tile_mode);
	unsigned tile_d = get_tile_depth(tile_mode);
d72 1
a72 6
	/* pitch_2d == to next slice within this volume-tile */
	/* pitch_3d == size (in bytes) of a volume-tile */
	unsigned pitch_2d = tile_h * 64;
	unsigned pitch_3d = tile_d * align(nb_h, tile_h) * pitch;

	return (z % tile_d) * pitch_2d + (z / tile_d) * pitch_3d;
a74 3



d76 1
a76 2
nv50_miptree_destroy(struct pipe_screen *pscreen,
		     struct pipe_resource *pt)
d78 1
a78 2
	struct nv50_miptree *mt = nv50_miptree(pt);
	unsigned l;
d80 1
a80 2
	for (l = 0; l <= pt->last_level; ++l)
		FREE(mt->level[l].image_offset);
d82 1
a82 2
	nouveau_screen_bo_release(pscreen, mt->base.bo);
	FREE(mt);
d87 2
a88 2
			struct pipe_resource *pt,
			struct winsys_handle *whandle)
d90 2
a91 3
	struct nv50_miptree *mt = nv50_miptree(pt);
	unsigned stride;

d93 2
a94 2
	if (!mt || !mt->base.bo)
		return FALSE;
d96 2
a97 2
	stride = util_format_get_stride(mt->base.base.format,
					mt->base.base.width0);
d99 4
a102 4
	return nouveau_screen_bo_get_handle(pscreen,
					    mt->base.bo,
					    stride,
					    whandle);
a104 1

d107 4
a110 5
   nv50_miptree_get_handle,	      /* get_handle */
   nv50_miptree_destroy,	      /* resource_destroy */
   NULL,			      /* is_resource_referenced */
   nv50_miptree_transfer_new,	      /* get_transfer */
   nv50_miptree_transfer_del,     /* transfer_destroy */
d112 3
a114 3
   u_default_transfer_flush_region,   /* transfer_flush_region */
   nv50_miptree_transfer_unmap,	      /* transfer_unmap */
   u_default_transfer_inline_write    /* transfer_inline_write */
a116 2


d118 2
a119 1
nv50_miptree_create(struct pipe_screen *pscreen, const struct pipe_resource *tmp)
d121 97
a217 95
	struct nouveau_device *dev = nouveau_screen(pscreen)->device;
	struct nv50_miptree *mt = CALLOC_STRUCT(nv50_miptree);
	struct pipe_resource *pt = &mt->base.base;
	unsigned width = tmp->width0, height = tmp->height0;
	unsigned depth = tmp->depth0, image_alignment;
	uint32_t tile_flags;
	int ret, i, l;

	if (!mt)
		return NULL;

	*pt = *tmp;
	mt->base.vtbl = &nv50_miptree_vtbl;
	pipe_reference_init(&pt->reference, 1);
	pt->screen = pscreen;

	switch (pt->format) {
	case PIPE_FORMAT_Z32_FLOAT:
		tile_flags = 0x4800;
		break;
	case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
		tile_flags = 0x1800;
		break;
	case PIPE_FORMAT_Z16_UNORM:
		tile_flags = 0x6c00;
		break;
	case PIPE_FORMAT_Z24X8_UNORM:
	case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
		tile_flags = 0x2800;
		break;
	case PIPE_FORMAT_Z32_FLOAT_S8X24_USCALED:
		tile_flags = 0xe000;
		break;
	case PIPE_FORMAT_R32G32B32A32_FLOAT:
	case PIPE_FORMAT_R32G32B32_FLOAT:
		tile_flags = 0x7400;
		break;
	default:
		if ((pt->bind & PIPE_BIND_SCANOUT) &&
		    util_format_get_blocksizebits(pt->format) == 32)
			tile_flags = 0x7a00;
		else
			tile_flags = 0x7000;
		break;
	}

	/* XXX: texture arrays */
	mt->image_nr = (pt->target == PIPE_TEXTURE_CUBE) ? 6 : 1;

	for (l = 0; l <= pt->last_level; l++) {
		struct nv50_miptree_level *lvl = &mt->level[l];
		unsigned nblocksy = util_format_get_nblocksy(pt->format, height);

		lvl->image_offset = CALLOC(mt->image_nr, sizeof(int));
		lvl->pitch = align(util_format_get_stride(pt->format, width), 64);
		lvl->tile_mode = get_tile_mode(nblocksy, depth);

		width = u_minify(width, 1);
		height = u_minify(height, 1);
		depth = u_minify(depth, 1);
	}

	image_alignment  = get_tile_height(mt->level[0].tile_mode) * 64;
	image_alignment *= get_tile_depth(mt->level[0].tile_mode);

	/* NOTE the distinction between arrays of mip-mapped 2D textures and
	 * mip-mapped 3D textures. We can't use image_nr == depth for 3D mip.
	 */
	for (i = 0; i < mt->image_nr; i++) {
		for (l = 0; l <= pt->last_level; l++) {
			struct nv50_miptree_level *lvl = &mt->level[l];
			int size;
			unsigned tile_h = get_tile_height(lvl->tile_mode);
			unsigned tile_d = get_tile_depth(lvl->tile_mode);

			size  = lvl->pitch;
			size *= align(util_format_get_nblocksy(pt->format, u_minify(pt->height0, l)), tile_h);
			size *= align(u_minify(pt->depth0, l), tile_d);

			lvl->image_offset[i] = mt->total_size;

			mt->total_size += size;
		}
		mt->total_size = align(mt->total_size, image_alignment);
	}

	ret = nouveau_bo_new_tile(dev, NOUVEAU_BO_VRAM, 256, mt->total_size,
				  mt->level[0].tile_mode, tile_flags,
				  &mt->base.bo);
	if (ret) {
		for (l = 0; l <= pt->last_level; ++l)
			FREE(mt->level[l].image_offset);
		FREE(mt);
		return NULL;
	}
d219 1
a219 1
	return pt;
a221 1

d224 2
a225 2
			 const struct pipe_resource *template,
			 struct winsys_handle *whandle)
d227 2
a228 2
	struct nv50_miptree *mt;
	unsigned stride;
d230 28
a257 31
	/* Only supports 2D, non-mipmapped textures for the moment */
	if ((template->target != PIPE_TEXTURE_2D &&
	      template->target != PIPE_TEXTURE_RECT) ||
	    template->last_level != 0 ||
	    template->depth0 != 1)
		return NULL;

	mt = CALLOC_STRUCT(nv50_miptree);
	if (!mt)
		return NULL;

	mt->base.bo = nouveau_screen_bo_from_handle(pscreen, whandle, &stride);
	if (mt->base.bo == NULL) {
		FREE(mt);
		return NULL;
	}


	mt->base.base = *template;
	mt->base.vtbl = &nv50_miptree_vtbl;
	pipe_reference_init(&mt->base.base.reference, 1);
	mt->base.base.screen = pscreen;
	mt->image_nr = 1;
	mt->level[0].pitch = stride;
	mt->level[0].image_offset = CALLOC(1, sizeof(unsigned));
	mt->level[0].tile_mode = mt->base.bo->tile_mode;

	/* XXX: Need to adjust bo refcount??
	 */
	/* nouveau_bo_ref(bo, &mt->base.bo); */
	return &mt->base.base;
d261 1
a261 2

/* Surface functions
d265 3
a267 2
nv50_miptree_surface_new(struct pipe_context *pipe, struct pipe_resource *pt,
			 const struct pipe_surface *surf_tmpl)
d269 42
a310 34
	unsigned level = surf_tmpl->u.tex.level;
	struct nv50_miptree *mt = nv50_miptree(pt);
	struct nv50_miptree_level *lvl = &mt->level[level];
	struct nv50_surface *ns;
	unsigned img = 0, zslice = 0;

	assert(surf_tmpl->u.tex.first_layer == surf_tmpl->u.tex.last_layer);

	/* XXX can't unify these here? */
	if (pt->target == PIPE_TEXTURE_CUBE)
		img = surf_tmpl->u.tex.first_layer;
	else if (pt->target == PIPE_TEXTURE_3D)
		zslice = surf_tmpl->u.tex.first_layer;

	ns = CALLOC_STRUCT(nv50_surface);
	if (!ns)
		return NULL;
	pipe_resource_reference(&ns->base.texture, pt);
	ns->base.context = pipe;
	ns->base.format = pt->format;
	ns->base.width = u_minify(pt->width0, level);
	ns->base.height = u_minify(pt->height0, level);
	ns->base.usage = surf_tmpl->usage;
	pipe_reference_init(&ns->base.reference, 1);
	ns->base.u.tex.level = level;
	ns->base.u.tex.first_layer = surf_tmpl->u.tex.first_layer;
	ns->base.u.tex.last_layer = surf_tmpl->u.tex.last_layer;
	ns->offset = lvl->image_offset[img];

	if (pt->target == PIPE_TEXTURE_3D) {
		unsigned nb_h = util_format_get_nblocksy(pt->format, ns->base.height);
		ns->offset += get_zslice_offset(lvl->tile_mode, zslice,
						lvl->pitch, nb_h);
	}
d312 1
a312 1
	return &ns->base;
d316 1
a316 2
nv50_miptree_surface_del(struct pipe_context *pipe,
			 struct pipe_surface *ps)
d318 3
a320 1
	struct nv50_surface *s = nv50_surface(ps);
d322 1
a322 2
	pipe_resource_reference(&s->base.texture, NULL);
	FREE(s);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d29 2
d75 56
a130 2
static struct pipe_texture *
nv50_miptree_create(struct pipe_screen *pscreen, const struct pipe_texture *tmp)
d134 1
a134 1
	struct pipe_texture *pt = &mt->base.base;
d140 3
d144 1
d152 1
a152 1
	case PIPE_FORMAT_S8Z24_UNORM:
d159 1
a159 1
	case PIPE_FORMAT_Z24S8_UNORM:
d162 3
d170 1
a170 1
		if ((pt->tex_usage & PIPE_TEXTURE_USAGE_PRIMARY) &&
d231 5
a235 3
static struct pipe_texture *
nv50_miptree_blanket(struct pipe_screen *pscreen, const struct pipe_texture *pt,
		     const unsigned *stride, struct pipe_buffer *pb)
a236 1
	struct nouveau_bo *bo = nouveau_bo(pb);
d238 1
d241 4
a244 2
	if (pt->target != PIPE_TEXTURE_2D || pt->last_level != 0 ||
	    pt->depth0 != 1)
d251 9
a259 1
	mt->base.base = *pt;
d263 1
a263 1
	mt->level[0].pitch = *stride;
d265 1
a265 1
	mt->level[0].tile_mode = bo->tile_mode;
d267 3
a269 1
	nouveau_bo_ref(bo, &mt->base.bo);
a272 5
static void
nv50_miptree_destroy(struct pipe_texture *pt)
{
	struct nv50_miptree *mt = nv50_miptree(pt);
	unsigned l;
a273 2
	for (l = 0; l <= pt->last_level; ++l)
		FREE(mt->level[l].image_offset);
d275 2
a276 3
	nouveau_bo_ref(NULL, &mt->base.bo);
	FREE(mt);
}
d278 3
a280 4
static struct pipe_surface *
nv50_miptree_surface_new(struct pipe_screen *pscreen, struct pipe_texture *pt,
			 unsigned face, unsigned level, unsigned zslice,
			 unsigned flags)
d282 1
d285 4
a288 2
	struct pipe_surface *ps;
	unsigned img = 0;
d290 1
d292 3
a294 1
		img = face;
d296 2
a297 2
	ps = CALLOC_STRUCT(pipe_surface);
	if (!ps)
d299 11
a309 10
	pipe_texture_reference(&ps->texture, pt);
	ps->format = pt->format;
	ps->width = u_minify(pt->width0, level);
	ps->height = u_minify(pt->height0, level);
	ps->usage = flags;
	pipe_reference_init(&ps->reference, 1);
	ps->face = face;
	ps->level = level;
	ps->zslice = zslice;
	ps->offset = lvl->image_offset[img];
d312 2
a313 2
		unsigned nb_h = util_format_get_nblocksy(pt->format, ps->height);
		ps->offset += get_zslice_offset(lvl->tile_mode, zslice,
d317 1
a317 1
	return ps;
d320 3
a322 2
static void
nv50_miptree_surface_del(struct pipe_surface *ps)
d326 1
a326 1
	pipe_texture_reference(&ps->texture, NULL);
a328 11

void
nv50_screen_init_miptree_functions(struct pipe_screen *pscreen)
{
	pscreen->texture_create = nv50_miptree_create;
	pscreen->texture_blanket = nv50_miptree_blanket;
	pscreen->texture_destroy = nv50_miptree_destroy;
	pscreen->get_tex_surface = nv50_miptree_surface_new;
	pscreen->tex_surface_destroy = nv50_miptree_surface_del;
}

@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a28 2
#include "nv50_resource.h"
#include "nv50_transfer.h"
d73 2
a74 56



static void
nv50_miptree_destroy(struct pipe_screen *pscreen,
		     struct pipe_resource *pt)
{
	struct nv50_miptree *mt = nv50_miptree(pt);
	unsigned l;

	for (l = 0; l <= pt->last_level; ++l)
		FREE(mt->level[l].image_offset);

	nouveau_screen_bo_release(pscreen, mt->base.bo);
	FREE(mt);
}

static boolean
nv50_miptree_get_handle(struct pipe_screen *pscreen,
			struct pipe_resource *pt,
			struct winsys_handle *whandle)
{
	struct nv50_miptree *mt = nv50_miptree(pt);
	unsigned stride;


	if (!mt || !mt->base.bo)
		return FALSE;

	stride = util_format_get_stride(mt->base.base.format,
					mt->base.base.width0);

	return nouveau_screen_bo_get_handle(pscreen,
					    mt->base.bo,
					    stride,
					    whandle);
}


const struct u_resource_vtbl nv50_miptree_vtbl =
{
   nv50_miptree_get_handle,	      /* get_handle */
   nv50_miptree_destroy,	      /* resource_destroy */
   NULL,			      /* is_resource_referenced */
   nv50_miptree_transfer_new,	      /* get_transfer */
   nv50_miptree_transfer_del,     /* transfer_destroy */
   nv50_miptree_transfer_map,	      /* transfer_map */
   u_default_transfer_flush_region,   /* transfer_flush_region */
   nv50_miptree_transfer_unmap,	      /* transfer_unmap */
   u_default_transfer_inline_write    /* transfer_inline_write */
};



struct pipe_resource *
nv50_miptree_create(struct pipe_screen *pscreen, const struct pipe_resource *tmp)
d78 1
a78 1
	struct pipe_resource *pt = &mt->base.base;
a83 3
	if (!mt)
		return NULL;

a84 1
	mt->base.vtbl = &nv50_miptree_vtbl;
d92 1
a92 1
	case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d99 1
a99 1
	case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
a101 3
	case PIPE_FORMAT_Z32_FLOAT_S8X24_USCALED:
		tile_flags = 0xe000;
		break;
d107 1
a107 1
		if ((pt->bind & PIPE_BIND_SCANOUT) &&
d168 3
a170 5

struct pipe_resource *
nv50_miptree_from_handle(struct pipe_screen *pscreen,
			 const struct pipe_resource *template,
			 struct winsys_handle *whandle)
d172 1
a173 1
	unsigned stride;
d176 2
a177 4
	if ((template->target != PIPE_TEXTURE_2D &&
	      template->target != PIPE_TEXTURE_RECT) ||
	    template->last_level != 0 ||
	    template->depth0 != 1)
d184 1
a184 9
	mt->base.bo = nouveau_screen_bo_from_handle(pscreen, whandle, &stride);
	if (mt->base.bo == NULL) {
		FREE(mt);
		return NULL;
	}


	mt->base.base = *template;
	mt->base.vtbl = &nv50_miptree_vtbl;
d188 1
a188 1
	mt->level[0].pitch = stride;
d190 1
a190 1
	mt->level[0].tile_mode = mt->base.bo->tile_mode;
d192 1
a192 3
	/* XXX: Need to adjust bo refcount??
	 */
	/* nouveau_bo_ref(bo, &mt->base.bo); */
d196 5
d202 2
d205 3
a207 2
/* Surface functions
 */
d209 4
a212 3
struct pipe_surface *
nv50_miptree_surface_new(struct pipe_context *pipe, struct pipe_resource *pt,
			 const struct pipe_surface *surf_tmpl)
a213 1
	unsigned level = surf_tmpl->u.tex.level;
d216 2
a217 4
	struct nv50_surface *ns;
	unsigned img = 0, zslice = 0;

	assert(surf_tmpl->u.tex.first_layer == surf_tmpl->u.tex.last_layer);
a218 1
	/* XXX can't unify these here? */
d220 1
a220 3
		img = surf_tmpl->u.tex.first_layer;
	else if (pt->target == PIPE_TEXTURE_3D)
		zslice = surf_tmpl->u.tex.first_layer;
d222 2
a223 2
	ns = CALLOC_STRUCT(nv50_surface);
	if (!ns)
d225 10
a234 11
	pipe_resource_reference(&ns->base.texture, pt);
	ns->base.context = pipe;
	ns->base.format = pt->format;
	ns->base.width = u_minify(pt->width0, level);
	ns->base.height = u_minify(pt->height0, level);
	ns->base.usage = surf_tmpl->usage;
	pipe_reference_init(&ns->base.reference, 1);
	ns->base.u.tex.level = level;
	ns->base.u.tex.first_layer = surf_tmpl->u.tex.first_layer;
	ns->base.u.tex.last_layer = surf_tmpl->u.tex.last_layer;
	ns->offset = lvl->image_offset[img];
d237 2
a238 2
		unsigned nb_h = util_format_get_nblocksy(pt->format, ns->base.height);
		ns->offset += get_zslice_offset(lvl->tile_mode, zslice,
d242 1
a242 1
	return &ns->base;
d245 2
a246 3
void
nv50_miptree_surface_del(struct pipe_context *pipe,
			 struct pipe_surface *ps)
d250 1
a250 1
	pipe_resource_reference(&s->base.texture, NULL);
d253 11
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d17 4
a20 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d30 1
d32 3
a34 2
uint32_t
nv50_tex_choose_tile_dims_helper(unsigned nx, unsigned ny, unsigned nz)
d36 1
a36 1
   uint32_t tile_mode = 0x000;
d38 7
a44 19
   if (ny > 64) tile_mode = 0x040; /* height 128 tiles */
   else
   if (ny > 32) tile_mode = 0x030; /* height 64 tiles */
   else
   if (ny > 16) tile_mode = 0x020; /* height 32 tiles */
   else
   if (ny >  8) tile_mode = 0x010; /* height 16 tiles */

   if (nz == 1)
      return tile_mode;
   else
      if (tile_mode > 0x020)
         tile_mode = 0x020;

   if (nz > 16 && tile_mode < 0x020)
      return tile_mode | 0x500; /* depth 32 tiles */
   if (nz > 8) return tile_mode | 0x400; /* depth 16 tiles */
   if (nz > 4) return tile_mode | 0x300; /* depth 8 tiles */
   if (nz > 2) return tile_mode | 0x200; /* depth 4 tiles */
d46 11
a56 2
   return tile_mode | 0x100;
}
d58 1
a58 4
static uint32_t
nv50_tex_choose_tile_dims(unsigned nx, unsigned ny, unsigned nz)
{
   return nv50_tex_choose_tile_dims_helper(nx, ny * 2, nz);
d61 2
a62 2
static uint32_t
nv50_mt_choose_storage_type(struct nv50_miptree *mt, boolean compressed)
d64 2
a65 3
   const unsigned ms = mt->ms_x + mt->ms_y;

   uint32_t tile_flags;
d67 4
a70 61
   if (unlikely(mt->base.base.flags & NOUVEAU_RESOURCE_FLAG_LINEAR))
      return 0;
   if (unlikely(mt->base.base.bind & PIPE_BIND_CURSOR))
      return 0;

   switch (mt->base.base.format) {
   case PIPE_FORMAT_Z16_UNORM:
      tile_flags = 0x6c + ms;
      break;
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
      tile_flags = 0x18 + ms;
      break;
   case PIPE_FORMAT_Z24X8_UNORM:
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
      tile_flags = 0x128 + ms;
      break;
   case PIPE_FORMAT_Z32_FLOAT:
      tile_flags = 0x40 + ms;
      break;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      tile_flags = 0x60 + ms;
      break;
   default:
      switch (util_format_get_blocksizebits(mt->base.base.format)) {
      case 128:
         assert(ms < 3);
         tile_flags = 0x74;
         break;
      case 64:
         switch (ms) {
         case 2: tile_flags = 0xfc; break;
         case 3: tile_flags = 0xfd; break;
         default:
            tile_flags = 0x70;
            break;
         }
         break;
      case 32:
         if (mt->base.base.bind & PIPE_BIND_SCANOUT) {
            assert(ms == 0);
            tile_flags = 0x7a;
         } else {
            switch (ms) {
            case 2: tile_flags = 0xf8; break;
            case 3: tile_flags = 0xf9; break;
            default:
               tile_flags = 0x70;
               break;
            }
         }
         break;
      case 16:
      case 8:
         tile_flags = 0x70;
         break;
      default:
         return 0;
      }
      if (mt->base.base.bind & PIPE_BIND_CURSOR)
         tile_flags = 0;
   }
d72 1
a72 4
   if (!compressed)
      tile_flags &= ~0x180;

   return tile_flags;
a74 4
void
nv50_miptree_destroy(struct pipe_screen *pscreen, struct pipe_resource *pt)
{
   struct nv50_miptree *mt = nv50_miptree(pt);
a75 1
   nouveau_bo_ref(NULL, &mt->base.bo);
a76 2
   nouveau_fence_ref(NULL, &mt->base.fence);
   nouveau_fence_ref(NULL, &mt->base.fence_wr);
d78 3
a80 11
   NOUVEAU_DRV_STAT(nouveau_screen(pscreen), tex_obj_current_count, -1);
   NOUVEAU_DRV_STAT(nouveau_screen(pscreen), tex_obj_current_bytes,
                    -(uint64_t)mt->total_size);

   FREE(mt);
}

boolean
nv50_miptree_get_handle(struct pipe_screen *pscreen,
                        struct pipe_resource *pt,
                        struct winsys_handle *whandle)
d82 2
a83 5
   struct nv50_miptree *mt = nv50_miptree(pt);
   unsigned stride;

   if (!mt || !mt->base.bo)
      return FALSE;
d85 2
a86 1
   stride = mt->level[0].pitch;
d88 2
a89 4
   return nouveau_screen_bo_get_handle(pscreen,
                                       mt->base.bo,
                                       stride,
                                       whandle);
d92 4
a95 41
const struct u_resource_vtbl nv50_miptree_vtbl =
{
   nv50_miptree_get_handle,         /* get_handle */
   nv50_miptree_destroy,            /* resource_destroy */
   nv50_miptree_transfer_map,       /* transfer_map */
   u_default_transfer_flush_region, /* transfer_flush_region */
   nv50_miptree_transfer_unmap,     /* transfer_unmap */
   u_default_transfer_inline_write  /* transfer_inline_write */
};

static INLINE boolean
nv50_miptree_init_ms_mode(struct nv50_miptree *mt)
{
   switch (mt->base.base.nr_samples) {
   case 8:
      mt->ms_mode = NV50_3D_MULTISAMPLE_MODE_MS8;
      mt->ms_x = 2;
      mt->ms_y = 1;
      break;
   case 4:
      mt->ms_mode = NV50_3D_MULTISAMPLE_MODE_MS4;
      mt->ms_x = 1;
      mt->ms_y = 1;
      break;
   case 2:
      mt->ms_mode = NV50_3D_MULTISAMPLE_MODE_MS2;
      mt->ms_x = 1;
      break;
   case 1:
   case 0:
      mt->ms_mode = NV50_3D_MULTISAMPLE_MODE_MS1;
      break;
   default:
      NOUVEAU_ERR("invalid nr_samples: %u\n", mt->base.base.nr_samples);
      return FALSE;
   }
   return TRUE;
}

boolean
nv50_miptree_init_layout_linear(struct nv50_miptree *mt, unsigned pitch_align)
d97 2
a98 6
   struct pipe_resource *pt = &mt->base.base;
   const unsigned blocksize = util_format_get_blocksize(pt->format);
   unsigned h = pt->height0;

   if (util_format_is_depth_or_stencil(pt->format))
      return FALSE;
a99 4
   if ((pt->last_level > 0) || (pt->depth0 > 1) || (pt->array_size > 1))
      return FALSE;
   if (mt->ms_x | mt->ms_y)
      return FALSE;
d101 2
a102 1
   mt->level[0].pitch = align(pt->width0 * blocksize, pitch_align);
d104 2
a105 3
   /* Account for very generous prefetch (allocate size as if tiled). */
   h = MAX2(h, 8);
   h = util_next_power_of_two(h);
d107 4
a110 3
   mt->total_size = mt->level[0].pitch * h;

   return TRUE;
a112 21
static void
nv50_miptree_init_layout_video(struct nv50_miptree *mt)
{
   const struct pipe_resource *pt = &mt->base.base;
   const unsigned blocksize = util_format_get_blocksize(pt->format);

   assert(pt->last_level == 0);
   assert(mt->ms_x == 0 && mt->ms_y == 0);
   assert(!util_format_is_compressed(pt->format));

   mt->layout_3d = pt->target == PIPE_TEXTURE_3D;

   mt->level[0].tile_mode = 0x20;
   mt->level[0].pitch = align(pt->width0 * blocksize, 64);
   mt->total_size = align(pt->height0, 16) * mt->level[0].pitch * (mt->layout_3d ? pt->depth0 : 1);

   if (pt->array_size > 1) {
      mt->layer_stride = align(mt->total_size, NV50_TILE_SIZE(0x20));
      mt->total_size = mt->layer_stride * pt->array_size;
   }
}
d114 1
a114 2
static void
nv50_miptree_init_layout_tiled(struct nv50_miptree *mt)
d116 10
a125 29
   struct pipe_resource *pt = &mt->base.base;
   unsigned w, h, d, l;
   const unsigned blocksize = util_format_get_blocksize(pt->format);

   mt->layout_3d = pt->target == PIPE_TEXTURE_3D;

   w = pt->width0 << mt->ms_x;
   h = pt->height0 << mt->ms_y;

   /* For 3D textures, a mipmap is spanned by all the layers, for array
    * textures and cube maps, each layer contains its own mipmaps.
    */
   d = mt->layout_3d ? pt->depth0 : 1;

   for (l = 0; l <= pt->last_level; ++l) {
      struct nv50_miptree_level *lvl = &mt->level[l];
      unsigned tsx, tsy, tsz;
      unsigned nbx = util_format_get_nblocksx(pt->format, w);
      unsigned nby = util_format_get_nblocksy(pt->format, h);

      lvl->offset = mt->total_size;

      lvl->tile_mode = nv50_tex_choose_tile_dims(nbx, nby, d);

      tsx = NV50_TILE_SIZE_X(lvl->tile_mode); /* x is tile row pitch in bytes */
      tsy = NV50_TILE_SIZE_Y(lvl->tile_mode);
      tsz = NV50_TILE_SIZE_Z(lvl->tile_mode);

      lvl->pitch = align(nbx * blocksize, tsx);
a126 1
      mt->total_size += lvl->pitch * align(nby, tsy) * align(d, tsz);
a127 11
      w = u_minify(w, 1);
      h = u_minify(h, 1);
      d = u_minify(d, 1);
   }

   if (pt->array_size > 1) {
      mt->layer_stride = align(mt->total_size,
                               NV50_TILE_SIZE(mt->level[0].tile_mode));
      mt->total_size = mt->layer_stride * pt->array_size;
   }
}
d130 1
a130 2
nv50_miptree_create(struct pipe_screen *pscreen,
                    const struct pipe_resource *templ)
d132 95
a226 48
   struct nouveau_device *dev = nouveau_screen(pscreen)->device;
   struct nv50_miptree *mt = CALLOC_STRUCT(nv50_miptree);
   struct pipe_resource *pt = &mt->base.base;
   int ret;
   union nouveau_bo_config bo_config;
   uint32_t bo_flags;

   if (!mt)
      return NULL;

   mt->base.vtbl = &nv50_miptree_vtbl;
   *pt = *templ;
   pipe_reference_init(&pt->reference, 1);
   pt->screen = pscreen;

   bo_config.nv50.memtype = nv50_mt_choose_storage_type(mt, TRUE);

   if (!nv50_miptree_init_ms_mode(mt)) {
      FREE(mt);
      return NULL;
   }

   if (unlikely(pt->flags & NV50_RESOURCE_FLAG_VIDEO)) {
      nv50_miptree_init_layout_video(mt);
      /* BO allocation done by client */
      return pt;
   } else
   if (bo_config.nv50.memtype != 0) {
      nv50_miptree_init_layout_tiled(mt);
   } else
   if (!nv50_miptree_init_layout_linear(mt, 64)) {
      FREE(mt);
      return NULL;
   }
   bo_config.nv50.tile_mode = mt->level[0].tile_mode;

   bo_flags = NOUVEAU_BO_VRAM | NOUVEAU_BO_NOSNOOP;
   if (mt->base.base.bind & (PIPE_BIND_CURSOR | PIPE_BIND_DISPLAY_TARGET))
      bo_flags |= NOUVEAU_BO_CONTIG;

   ret = nouveau_bo_new(dev, bo_flags, 4096, mt->total_size, &bo_config,
                        &mt->base.bo);
   if (ret) {
      FREE(mt);
      return NULL;
   }
   mt->base.domain = NOUVEAU_BO_VRAM;
   mt->base.address = mt->base.bo->offset;
d228 1
a228 1
   return pt;
d231 1
d234 2
a235 2
                         const struct pipe_resource *templ,
                         struct winsys_handle *whandle)
d237 2
a238 2
   struct nv50_miptree *mt;
   unsigned stride;
d240 6
a245 27
   /* only supports 2D, non-mipmapped textures for the moment */
   if ((templ->target != PIPE_TEXTURE_2D &&
        templ->target != PIPE_TEXTURE_RECT) ||
       templ->last_level != 0 ||
       templ->depth0 != 1 ||
       templ->array_size > 1)
      return NULL;

   mt = CALLOC_STRUCT(nv50_miptree);
   if (!mt)
      return NULL;

   mt->base.bo = nouveau_screen_bo_from_handle(pscreen, whandle, &stride);
   if (mt->base.bo == NULL) {
      FREE(mt);
      return NULL;
   }
   mt->base.domain = NOUVEAU_BO_VRAM;
   mt->base.address = mt->base.bo->offset;

   mt->base.base = *templ;
   mt->base.vtbl = &nv50_miptree_vtbl;
   pipe_reference_init(&mt->base.base.reference, 1);
   mt->base.base.screen = pscreen;
   mt->level[0].pitch = stride;
   mt->level[0].offset = 0;
   mt->level[0].tile_mode = mt->base.bo->config.nv50.tile_mode;
d247 3
a249 3
   /* no need to adjust bo reference count */
   return &mt->base.base;
}
d251 5
a256 5
/* Offset of zslice @@z from start of level @@l. */
INLINE unsigned
nv50_mt_zslice_offset(const struct nv50_miptree *mt, unsigned l, unsigned z)
{
   const struct pipe_resource *pt = &mt->base.base;
d258 8
a265 2
   unsigned tds = NV50_TILE_SHIFT_Z(mt->level[l].tile_mode);
   unsigned ths = NV50_TILE_SHIFT_Y(mt->level[l].tile_mode);
d267 5
a271 2
   unsigned nby = util_format_get_nblocksy(pt->format,
                                           u_minify(pt->height0, l));
a272 2
   /* to next 2D tile slice within a 3D tile */
   unsigned stride_2d = NV50_TILE_SIZE_2D(mt->level[l].tile_mode);
a273 2
   /* to slice in the next (in z direction) 3D tile */
   unsigned stride_3d = (align(nby, (1 << ths)) * mt->level[l].pitch) << tds;
d275 1
a275 4
   return (z & ((1 << tds) - 1)) * stride_2d + (z >> tds) * stride_3d;
}

/* Surface functions.
d278 3
a280 3
struct nv50_surface *
nv50_surface_from_miptree(struct nv50_miptree *mt,
                          const struct pipe_surface *templ)
d282 34
a315 23
   struct pipe_surface *ps;
   struct nv50_surface *ns = CALLOC_STRUCT(nv50_surface);
   if (!ns)
      return NULL;
   ps = &ns->base;

   pipe_reference_init(&ps->reference, 1);
   pipe_resource_reference(&ps->texture, &mt->base.base);

   ps->format = templ->format;
   ps->writable = templ->writable;
   ps->u.tex.level = templ->u.tex.level;
   ps->u.tex.first_layer = templ->u.tex.first_layer;
   ps->u.tex.last_layer = templ->u.tex.last_layer;

   ns->width = u_minify(mt->base.base.width0, ps->u.tex.level);
   ns->height = u_minify(mt->base.base.height0, ps->u.tex.level);
   ns->depth = ps->u.tex.last_layer - ps->u.tex.first_layer + 1;
   ns->offset = mt->level[templ->u.tex.level].offset;

   /* comment says there are going to be removed, but they're used by the st */
   ps->width = ns->width;
   ps->height = ns->height;
d317 1
a317 4
   ns->width <<= mt->ms_x;
   ns->height <<= mt->ms_y;

   return ns;
d320 3
a322 4
struct pipe_surface *
nv50_miptree_surface_new(struct pipe_context *pipe,
                         struct pipe_resource *pt,
                         const struct pipe_surface *templ)
d324 1
a324 21
   struct nv50_miptree *mt = nv50_miptree(pt);
   struct nv50_surface *ns = nv50_surface_from_miptree(mt, templ);
   if (!ns)
      return NULL;
   ns->base.context = pipe;

   if (ns->base.u.tex.first_layer) {
      const unsigned l = ns->base.u.tex.level;
      const unsigned z = ns->base.u.tex.first_layer;

      if (mt->layout_3d) {
         ns->offset += nv50_mt_zslice_offset(mt, l, z);

         /* TODO: switch to depth 1 tiles; but actually this shouldn't happen */
         if (ns->depth > 1 &&
             (z & (NV50_TILE_SIZE_Z(mt->level[l].tile_mode) - 1)))
            NOUVEAU_ERR("Creating unsupported 3D surface !\n");
      } else {
         ns->offset += mt->layer_stride * z;
      }
   }
d326 2
a327 1
   return &ns->base;
@


