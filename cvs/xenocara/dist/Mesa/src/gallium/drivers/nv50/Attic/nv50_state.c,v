head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.07.09.21.08.54;	author jsg;	state dead;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.44;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.41;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@/*
 * Copyright 2010 Christoph Bumiller
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include "pipe/p_defines.h"
#include "util/u_helpers.h"
#include "util/u_inlines.h"
#include "util/u_transfer.h"
#include "util/u_format_srgb.h"

#include "tgsi/tgsi_parse.h"

#include "nv50_stateobj.h"
#include "nv50_context.h"

#include "nv50_3d.xml.h"
#include "nv50_texture.xml.h"

#include "nouveau/nouveau_gldefs.h"

/* Caveats:
 *  ! pipe_sampler_state.normalized_coords is ignored - rectangle textures will
 *     use non-normalized coordinates, everything else won't
 *    (The relevant bit is in the TIC entry and not the TSC entry.)
 *
 *  ! pipe_sampler_state.seamless_cube_map is ignored - seamless filtering is
 *     always activated on NVA0 +
 *    (Give me the global bit, otherwise it's not worth the CPU work.)
 *
 *  ! pipe_sampler_state.border_color is not swizzled according to the texture
 *     swizzle in pipe_sampler_view
 *    (This will be ugly with indirect independent texture/sampler access,
 *     we'd have to emulate the logic in the shader. GL doesn't have that,
 *     D3D doesn't have swizzle, if we knew what we were implementing we'd be
 *     good.)
 *
 *  ! pipe_rasterizer_state.line_last_pixel is ignored - it is never drawn
 *
 *  ! pipe_rasterizer_state.flatshade_first also applies to QUADS
 *    (There's a GL query for that, forcing an exception is just ridiculous.)
 *
 *  ! pipe_rasterizer_state.half_pixel_center is ignored - pixel centers
 *     are always at half integer coordinates and the top-left rule applies
 *    (There does not seem to be a hardware switch for this.)
 *
 *  ! pipe_rasterizer_state.sprite_coord_enable is masked with 0xff on NVC0
 *    (The hardware only has 8 slots meant for TexCoord and we have to assign
 *     in advance to maintain elegant separate shader objects.)
 */

static INLINE uint32_t
nv50_colormask(unsigned mask)
{
   uint32_t ret = 0;

   if (mask & PIPE_MASK_R)
      ret |= 0x0001;
   if (mask & PIPE_MASK_G)
      ret |= 0x0010;
   if (mask & PIPE_MASK_B)
      ret |= 0x0100;
   if (mask & PIPE_MASK_A)
      ret |= 0x1000;

   return ret;
}

#define NV50_BLEND_FACTOR_CASE(a, b) \
   case PIPE_BLENDFACTOR_##a: return NV50_3D_BLEND_FACTOR_##b

static INLINE uint32_t
nv50_blend_fac(unsigned factor)
{
   switch (factor) {
   NV50_BLEND_FACTOR_CASE(ONE, ONE);
   NV50_BLEND_FACTOR_CASE(SRC_COLOR, SRC_COLOR);
   NV50_BLEND_FACTOR_CASE(SRC_ALPHA, SRC_ALPHA);
   NV50_BLEND_FACTOR_CASE(DST_ALPHA, DST_ALPHA);
   NV50_BLEND_FACTOR_CASE(DST_COLOR, DST_COLOR);
   NV50_BLEND_FACTOR_CASE(SRC_ALPHA_SATURATE, SRC_ALPHA_SATURATE);
   NV50_BLEND_FACTOR_CASE(CONST_COLOR, CONSTANT_COLOR);
   NV50_BLEND_FACTOR_CASE(CONST_ALPHA, CONSTANT_ALPHA);
   NV50_BLEND_FACTOR_CASE(SRC1_COLOR, SRC1_COLOR);
   NV50_BLEND_FACTOR_CASE(SRC1_ALPHA, SRC1_ALPHA);
   NV50_BLEND_FACTOR_CASE(ZERO, ZERO);
   NV50_BLEND_FACTOR_CASE(INV_SRC_COLOR, ONE_MINUS_SRC_COLOR);
   NV50_BLEND_FACTOR_CASE(INV_SRC_ALPHA, ONE_MINUS_SRC_ALPHA);
   NV50_BLEND_FACTOR_CASE(INV_DST_ALPHA, ONE_MINUS_DST_ALPHA);
   NV50_BLEND_FACTOR_CASE(INV_DST_COLOR, ONE_MINUS_DST_COLOR);
   NV50_BLEND_FACTOR_CASE(INV_CONST_COLOR, ONE_MINUS_CONSTANT_COLOR);
   NV50_BLEND_FACTOR_CASE(INV_CONST_ALPHA, ONE_MINUS_CONSTANT_ALPHA);
   NV50_BLEND_FACTOR_CASE(INV_SRC1_COLOR, ONE_MINUS_SRC1_COLOR);
   NV50_BLEND_FACTOR_CASE(INV_SRC1_ALPHA, ONE_MINUS_SRC1_ALPHA);
   default:
      return NV50_3D_BLEND_FACTOR_ZERO;
   }
}

static void *
nv50_blend_state_create(struct pipe_context *pipe,
                        const struct pipe_blend_state *cso)
{
   struct nv50_blend_stateobj *so = CALLOC_STRUCT(nv50_blend_stateobj);
   int i;
   boolean emit_common_func = cso->rt[0].blend_enable;
   uint32_t ms;

   if (nv50_context(pipe)->screen->tesla->oclass >= NVA3_3D_CLASS) {
      SB_BEGIN_3D(so, BLEND_INDEPENDENT, 1);
      SB_DATA    (so, cso->independent_blend_enable);
   }

   so->pipe = *cso;

   SB_BEGIN_3D(so, COLOR_MASK_COMMON, 1);
   SB_DATA    (so, !cso->independent_blend_enable);

   SB_BEGIN_3D(so, BLEND_ENABLE_COMMON, 1);
   SB_DATA    (so, !cso->independent_blend_enable);

   if (cso->independent_blend_enable) {
      SB_BEGIN_3D(so, BLEND_ENABLE(0), 8);
      for (i = 0; i < 8; ++i) {
         SB_DATA(so, cso->rt[i].blend_enable);
         if (cso->rt[i].blend_enable)
            emit_common_func = TRUE;
      }

      if (nv50_context(pipe)->screen->tesla->oclass >= NVA3_3D_CLASS) {
         emit_common_func = FALSE;

         for (i = 0; i < 8; ++i) {
            if (!cso->rt[i].blend_enable)
               continue;
            SB_BEGIN_3D_(so, NVA3_3D_IBLEND_EQUATION_RGB(i), 6);
            SB_DATA     (so, nvgl_blend_eqn(cso->rt[i].rgb_func));
            SB_DATA     (so, nv50_blend_fac(cso->rt[i].rgb_src_factor));
            SB_DATA     (so, nv50_blend_fac(cso->rt[i].rgb_dst_factor));
            SB_DATA     (so, nvgl_blend_eqn(cso->rt[i].alpha_func));
            SB_DATA     (so, nv50_blend_fac(cso->rt[i].alpha_src_factor));
            SB_DATA     (so, nv50_blend_fac(cso->rt[i].alpha_dst_factor));
         }
      }
   } else {
      SB_BEGIN_3D(so, BLEND_ENABLE(0), 1);
      SB_DATA    (so, cso->rt[0].blend_enable);
   }

   if (emit_common_func) {
      SB_BEGIN_3D(so, BLEND_EQUATION_RGB, 5);
      SB_DATA    (so, nvgl_blend_eqn(cso->rt[0].rgb_func));
      SB_DATA    (so, nv50_blend_fac(cso->rt[0].rgb_src_factor));
      SB_DATA    (so, nv50_blend_fac(cso->rt[0].rgb_dst_factor));
      SB_DATA    (so, nvgl_blend_eqn(cso->rt[0].alpha_func));
      SB_DATA    (so, nv50_blend_fac(cso->rt[0].alpha_src_factor));
      SB_BEGIN_3D(so, BLEND_FUNC_DST_ALPHA, 1);
      SB_DATA    (so, nv50_blend_fac(cso->rt[0].alpha_dst_factor));
   }

   if (cso->logicop_enable) {
      SB_BEGIN_3D(so, LOGIC_OP_ENABLE, 2);
      SB_DATA    (so, 1);
      SB_DATA    (so, nvgl_logicop_func(cso->logicop_func));
   } else {
      SB_BEGIN_3D(so, LOGIC_OP_ENABLE, 1);
      SB_DATA    (so, 0);
   }

   if (cso->independent_blend_enable) {
      SB_BEGIN_3D(so, COLOR_MASK(0), 8);
      for (i = 0; i < 8; ++i)
         SB_DATA(so, nv50_colormask(cso->rt[i].colormask));
   } else {
      SB_BEGIN_3D(so, COLOR_MASK(0), 1);
      SB_DATA    (so, nv50_colormask(cso->rt[0].colormask));
   }

   ms = 0;
   if (cso->alpha_to_coverage)
      ms |= NV50_3D_MULTISAMPLE_CTRL_ALPHA_TO_COVERAGE;
   if (cso->alpha_to_one)
      ms |= NV50_3D_MULTISAMPLE_CTRL_ALPHA_TO_ONE;

   SB_BEGIN_3D(so, MULTISAMPLE_CTRL, 1);
   SB_DATA    (so, ms);

   assert(so->size <= (sizeof(so->state) / sizeof(so->state[0])));
   return so;
}

static void
nv50_blend_state_bind(struct pipe_context *pipe, void *hwcso)
{
   struct nv50_context *nv50 = nv50_context(pipe);

   nv50->blend = hwcso;
   nv50->dirty |= NV50_NEW_BLEND;
}

static void
nv50_blend_state_delete(struct pipe_context *pipe, void *hwcso)
{
   FREE(hwcso);
}

/* NOTE: ignoring line_last_pixel, using FALSE (set on screen init) */
static void *
nv50_rasterizer_state_create(struct pipe_context *pipe,
                             const struct pipe_rasterizer_state *cso)
{
   struct nv50_rasterizer_stateobj *so;
   uint32_t reg;

   so = CALLOC_STRUCT(nv50_rasterizer_stateobj);
   if (!so)
      return NULL;
   so->pipe = *cso;

#ifndef NV50_SCISSORS_CLIPPING
   SB_BEGIN_3D(so, SCISSOR_ENABLE(0), 1);
   SB_DATA    (so, cso->scissor);
#endif
    
   SB_BEGIN_3D(so, SHADE_MODEL, 1);
   SB_DATA    (so, cso->flatshade ? NV50_3D_SHADE_MODEL_FLAT :
                                    NV50_3D_SHADE_MODEL_SMOOTH);
   SB_BEGIN_3D(so, PROVOKING_VERTEX_LAST, 1);
   SB_DATA    (so, !cso->flatshade_first);
   SB_BEGIN_3D(so, VERTEX_TWO_SIDE_ENABLE, 1);
   SB_DATA    (so, cso->light_twoside);

   SB_BEGIN_3D(so, FRAG_COLOR_CLAMP_EN, 1);
   SB_DATA    (so, cso->clamp_fragment_color ? 0x11111111 : 0x00000000);

   SB_BEGIN_3D(so, MULTISAMPLE_ENABLE, 1);
   SB_DATA    (so, cso->multisample);

   SB_BEGIN_3D(so, LINE_WIDTH, 1);
   SB_DATA    (so, fui(cso->line_width));
   SB_BEGIN_3D(so, LINE_SMOOTH_ENABLE, 1);
   SB_DATA    (so, cso->line_smooth);

   SB_BEGIN_3D(so, LINE_STIPPLE_ENABLE, 1);
   if (cso->line_stipple_enable) {
      SB_DATA    (so, 1);
      SB_BEGIN_3D(so, LINE_STIPPLE, 1);
      SB_DATA    (so, (cso->line_stipple_pattern << 8) |
                  cso->line_stipple_factor);
   } else {
      SB_DATA    (so, 0);
   }

   if (!cso->point_size_per_vertex) {
      SB_BEGIN_3D(so, POINT_SIZE, 1);
      SB_DATA    (so, fui(cso->point_size));
   }
   SB_BEGIN_3D(so, POINT_SPRITE_ENABLE, 1);
   SB_DATA    (so, cso->point_quad_rasterization);
   SB_BEGIN_3D(so, POINT_SMOOTH_ENABLE, 1);
   SB_DATA    (so, cso->point_smooth);

   SB_BEGIN_3D(so, POLYGON_MODE_FRONT, 3);
   SB_DATA    (so, nvgl_polygon_mode(cso->fill_front));
   SB_DATA    (so, nvgl_polygon_mode(cso->fill_back));
   SB_DATA    (so, cso->poly_smooth);

   SB_BEGIN_3D(so, CULL_FACE_ENABLE, 3);
   SB_DATA    (so, cso->cull_face != PIPE_FACE_NONE);
   SB_DATA    (so, cso->front_ccw ? NV50_3D_FRONT_FACE_CCW :
                                    NV50_3D_FRONT_FACE_CW);
   switch (cso->cull_face) {
   case PIPE_FACE_FRONT_AND_BACK:
      SB_DATA(so, NV50_3D_CULL_FACE_FRONT_AND_BACK);
      break;
   case PIPE_FACE_FRONT:
      SB_DATA(so, NV50_3D_CULL_FACE_FRONT);
      break;
   case PIPE_FACE_BACK:
   default:
     SB_DATA(so, NV50_3D_CULL_FACE_BACK);
     break;
   }

   SB_BEGIN_3D(so, POLYGON_STIPPLE_ENABLE, 1);
   SB_DATA    (so, cso->poly_stipple_enable);
   SB_BEGIN_3D(so, POLYGON_OFFSET_POINT_ENABLE, 3);
   SB_DATA    (so, cso->offset_point);
   SB_DATA    (so, cso->offset_line);
   SB_DATA    (so, cso->offset_tri);

   if (cso->offset_point || cso->offset_line || cso->offset_tri) {
      SB_BEGIN_3D(so, POLYGON_OFFSET_FACTOR, 1);
      SB_DATA    (so, fui(cso->offset_scale));
      SB_BEGIN_3D(so, POLYGON_OFFSET_UNITS, 1);
      SB_DATA    (so, fui(cso->offset_units * 2.0f));
      SB_BEGIN_3D(so, POLYGON_OFFSET_CLAMP, 1);
      SB_DATA    (so, fui(cso->offset_clamp));
   }

   if (cso->depth_clip) {
      reg = 0;
   } else {
      reg =
         NV50_3D_VIEW_VOLUME_CLIP_CTRL_DEPTH_CLAMP_NEAR |
         NV50_3D_VIEW_VOLUME_CLIP_CTRL_DEPTH_CLAMP_FAR |
         NV50_3D_VIEW_VOLUME_CLIP_CTRL_UNK12_UNK1;
   }
#ifndef NV50_SCISSORS_CLIPPING
   reg |=
      NV50_3D_VIEW_VOLUME_CLIP_CTRL_UNK7 |
      NV50_3D_VIEW_VOLUME_CLIP_CTRL_UNK12_UNK1;
#endif
   SB_BEGIN_3D(so, VIEW_VOLUME_CLIP_CTRL, 1);
   SB_DATA    (so, reg);

   assert(so->size <= (sizeof(so->state) / sizeof(so->state[0])));
   return (void *)so;
}

static void
nv50_rasterizer_state_bind(struct pipe_context *pipe, void *hwcso)
{
   struct nv50_context *nv50 = nv50_context(pipe);

   nv50->rast = hwcso;
   nv50->dirty |= NV50_NEW_RASTERIZER;
}

static void
nv50_rasterizer_state_delete(struct pipe_context *pipe, void *hwcso)
{
   FREE(hwcso);
}

static void *
nv50_zsa_state_create(struct pipe_context *pipe,
                      const struct pipe_depth_stencil_alpha_state *cso)
{
   struct nv50_zsa_stateobj *so = CALLOC_STRUCT(nv50_zsa_stateobj);

   so->pipe = *cso;

   SB_BEGIN_3D(so, DEPTH_WRITE_ENABLE, 1);
   SB_DATA    (so, cso->depth.writemask);
   SB_BEGIN_3D(so, DEPTH_TEST_ENABLE, 1);
   if (cso->depth.enabled) {
      SB_DATA    (so, 1);
      SB_BEGIN_3D(so, DEPTH_TEST_FUNC, 1);
      SB_DATA    (so, nvgl_comparison_op(cso->depth.func));
   } else {
      SB_DATA    (so, 0);
   }

   if (cso->stencil[0].enabled) {
      SB_BEGIN_3D(so, STENCIL_ENABLE, 5);
      SB_DATA    (so, 1);
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[0].fail_op));
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[0].zfail_op));
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[0].zpass_op));
      SB_DATA    (so, nvgl_comparison_op(cso->stencil[0].func));
      SB_BEGIN_3D(so, STENCIL_FRONT_MASK, 2);
      SB_DATA    (so, cso->stencil[0].writemask);
      SB_DATA    (so, cso->stencil[0].valuemask);
   } else {
      SB_BEGIN_3D(so, STENCIL_ENABLE, 1);
      SB_DATA    (so, 0);
   }

   if (cso->stencil[1].enabled) {
      assert(cso->stencil[0].enabled);
      SB_BEGIN_3D(so, STENCIL_TWO_SIDE_ENABLE, 5);
      SB_DATA    (so, 1);
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[1].fail_op));
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[1].zfail_op));
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[1].zpass_op));
      SB_DATA    (so, nvgl_comparison_op(cso->stencil[1].func));
      SB_BEGIN_3D(so, STENCIL_BACK_MASK, 2);
      SB_DATA    (so, cso->stencil[1].writemask);
      SB_DATA    (so, cso->stencil[1].valuemask);
   } else {
      SB_BEGIN_3D(so, STENCIL_TWO_SIDE_ENABLE, 1);
      SB_DATA    (so, 0);
   }
    
   SB_BEGIN_3D(so, ALPHA_TEST_ENABLE, 1);
   if (cso->alpha.enabled) {
      SB_DATA    (so, 1);
      SB_BEGIN_3D(so, ALPHA_TEST_REF, 2);
      SB_DATA    (so, fui(cso->alpha.ref_value));
      SB_DATA    (so, nvgl_comparison_op(cso->alpha.func));
   } else {
      SB_DATA    (so, 0);
   }

   assert(so->size <= (sizeof(so->state) / sizeof(so->state[0])));
   return (void *)so;
}

static void
nv50_zsa_state_bind(struct pipe_context *pipe, void *hwcso)
{
   struct nv50_context *nv50 = nv50_context(pipe);

   nv50->zsa = hwcso;
   nv50->dirty |= NV50_NEW_ZSA;
}

static void
nv50_zsa_state_delete(struct pipe_context *pipe, void *hwcso)
{
   FREE(hwcso);
}

/* ====================== SAMPLERS AND TEXTURES ================================
 */

#define NV50_TSC_WRAP_CASE(n) \
    case PIPE_TEX_WRAP_##n: return NV50_TSC_WRAP_##n

static INLINE unsigned
nv50_tsc_wrap_mode(unsigned wrap)
{
   switch (wrap) {
   NV50_TSC_WRAP_CASE(REPEAT);
   NV50_TSC_WRAP_CASE(MIRROR_REPEAT);
   NV50_TSC_WRAP_CASE(CLAMP_TO_EDGE);
   NV50_TSC_WRAP_CASE(CLAMP_TO_BORDER);
   NV50_TSC_WRAP_CASE(CLAMP);
   NV50_TSC_WRAP_CASE(MIRROR_CLAMP_TO_EDGE);
   NV50_TSC_WRAP_CASE(MIRROR_CLAMP_TO_BORDER);
   NV50_TSC_WRAP_CASE(MIRROR_CLAMP);
   default:
       NOUVEAU_ERR("unknown wrap mode: %d\n", wrap);
       return NV50_TSC_WRAP_REPEAT;
   }
}

void *
nv50_sampler_state_create(struct pipe_context *pipe,
                          const struct pipe_sampler_state *cso)
{
   struct nv50_tsc_entry *so = MALLOC_STRUCT(nv50_tsc_entry);
   float f[2];

   so->id = -1;

   so->tsc[0] = (0x00026000 |
                 (nv50_tsc_wrap_mode(cso->wrap_s) << 0) |
                 (nv50_tsc_wrap_mode(cso->wrap_t) << 3) |
                 (nv50_tsc_wrap_mode(cso->wrap_r) << 6));

   switch (cso->mag_img_filter) {
   case PIPE_TEX_FILTER_LINEAR:
      so->tsc[1] = NV50_TSC_1_MAGF_LINEAR;
      break;
   case PIPE_TEX_FILTER_NEAREST:
   default:
      so->tsc[1] = NV50_TSC_1_MAGF_NEAREST;
      break;
   }

   switch (cso->min_img_filter) {
   case PIPE_TEX_FILTER_LINEAR:
      so->tsc[1] |= NV50_TSC_1_MINF_LINEAR;
      break;
   case PIPE_TEX_FILTER_NEAREST:
   default:
      so->tsc[1] |= NV50_TSC_1_MINF_NEAREST;
      break;
   }

   switch (cso->min_mip_filter) {
   case PIPE_TEX_MIPFILTER_LINEAR:
      so->tsc[1] |= NV50_TSC_1_MIPF_LINEAR;
      break;
   case PIPE_TEX_MIPFILTER_NEAREST:
      so->tsc[1] |= NV50_TSC_1_MIPF_NEAREST;
      break;
   case PIPE_TEX_MIPFILTER_NONE:
   default:
      so->tsc[1] |= NV50_TSC_1_MIPF_NONE;
      break;
   }

   if (nouveau_screen(pipe->screen)->class_3d >= NVE4_3D_CLASS) {
      if (cso->seamless_cube_map)
         so->tsc[1] |= NVE4_TSC_1_CUBE_SEAMLESS;
      if (!cso->normalized_coords)
         so->tsc[1] |= NVE4_TSC_1_FORCE_NONNORMALIZED_COORDS;
   }

   if (cso->max_anisotropy >= 16)
      so->tsc[0] |= (7 << 20);
   else
   if (cso->max_anisotropy >= 12)
      so->tsc[0] |= (6 << 20);
   else {
      so->tsc[0] |= (cso->max_anisotropy >> 1) << 20;

      if (cso->max_anisotropy >= 4)
         so->tsc[1] |= NV50_TSC_1_UNKN_ANISO_35;
      else
      if (cso->max_anisotropy >= 2)
         so->tsc[1] |= NV50_TSC_1_UNKN_ANISO_15;
   }

   if (cso->compare_mode == PIPE_TEX_COMPARE_R_TO_TEXTURE) {
      /* NOTE: must be deactivated for non-shadow textures */
      so->tsc[0] |= (1 << 9);
      so->tsc[0] |= (nvgl_comparison_op(cso->compare_func) & 0x7) << 10;
   }

   f[0] = CLAMP(cso->lod_bias, -16.0f, 15.0f);
   so->tsc[1] |= ((int)(f[0] * 256.0f) & 0x1fff) << 12;

   f[0] = CLAMP(cso->min_lod, 0.0f, 15.0f);
   f[1] = CLAMP(cso->max_lod, 0.0f, 15.0f);
   so->tsc[2] =
      (((int)(f[1] * 256.0f) & 0xfff) << 12) | ((int)(f[0] * 256.0f) & 0xfff);

   so->tsc[2] |=
      util_format_linear_float_to_srgb_8unorm(cso->border_color.f[0]) << 24;
   so->tsc[3] =
      util_format_linear_float_to_srgb_8unorm(cso->border_color.f[1]) << 12;
   so->tsc[3] |=
      util_format_linear_float_to_srgb_8unorm(cso->border_color.f[2]) << 20;

   so->tsc[4] = fui(cso->border_color.f[0]);
   so->tsc[5] = fui(cso->border_color.f[1]);
   so->tsc[6] = fui(cso->border_color.f[2]);
   so->tsc[7] = fui(cso->border_color.f[3]);

   return (void *)so;
}

static void
nv50_sampler_state_delete(struct pipe_context *pipe, void *hwcso)
{
   unsigned s, i;

   for (s = 0; s < 3; ++s)
      for (i = 0; i < nv50_context(pipe)->num_samplers[s]; ++i)
         if (nv50_context(pipe)->samplers[s][i] == hwcso)
            nv50_context(pipe)->samplers[s][i] = NULL;

   nv50_screen_tsc_free(nv50_context(pipe)->screen, nv50_tsc_entry(hwcso));

   FREE(hwcso);
}

static INLINE void
nv50_stage_sampler_states_bind(struct nv50_context *nv50, int s,
                               unsigned nr, void **hwcso)
{
   unsigned i;

   for (i = 0; i < nr; ++i) {
      struct nv50_tsc_entry *old = nv50->samplers[s][i];

      nv50->samplers[s][i] = nv50_tsc_entry(hwcso[i]);
      if (old)
         nv50_screen_tsc_unlock(nv50->screen, old);
   }
   for (; i < nv50->num_samplers[s]; ++i)
      if (nv50->samplers[s][i])
         nv50_screen_tsc_unlock(nv50->screen, nv50->samplers[s][i]);

   nv50->num_samplers[s] = nr;

   nv50->dirty |= NV50_NEW_SAMPLERS;
}

static void
nv50_vp_sampler_states_bind(struct pipe_context *pipe, unsigned nr, void **s)
{
   nv50_stage_sampler_states_bind(nv50_context(pipe), 0, nr, s);
}

static void
nv50_fp_sampler_states_bind(struct pipe_context *pipe, unsigned nr, void **s)
{
   nv50_stage_sampler_states_bind(nv50_context(pipe), 2, nr, s);
}

static void
nv50_gp_sampler_states_bind(struct pipe_context *pipe, unsigned nr, void **s)
{
   nv50_stage_sampler_states_bind(nv50_context(pipe), 1, nr, s);
}

/* NOTE: only called when not referenced anywhere, won't be bound */
static void
nv50_sampler_view_destroy(struct pipe_context *pipe,
                          struct pipe_sampler_view *view)
{
   pipe_resource_reference(&view->texture, NULL);

   nv50_screen_tic_free(nv50_context(pipe)->screen, nv50_tic_entry(view));

   FREE(nv50_tic_entry(view));
}

static INLINE void
nv50_stage_set_sampler_views(struct nv50_context *nv50, int s,
                             unsigned nr,
                             struct pipe_sampler_view **views)
{
   unsigned i;

   for (i = 0; i < nr; ++i) {
      struct nv50_tic_entry *old = nv50_tic_entry(nv50->textures[s][i]);
      if (old)
         nv50_screen_tic_unlock(nv50->screen, old);

      pipe_sampler_view_reference(&nv50->textures[s][i], views[i]);
   }

   for (i = nr; i < nv50->num_textures[s]; ++i) {
      struct nv50_tic_entry *old = nv50_tic_entry(nv50->textures[s][i]);
      if (!old)
         continue;
      nv50_screen_tic_unlock(nv50->screen, old);

      pipe_sampler_view_reference(&nv50->textures[s][i], NULL);
   }

   nv50->num_textures[s] = nr;

   nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_TEXTURES);

   nv50->dirty |= NV50_NEW_TEXTURES;
}

static void
nv50_vp_set_sampler_views(struct pipe_context *pipe,
                          unsigned nr,
                          struct pipe_sampler_view **views)
{
   nv50_stage_set_sampler_views(nv50_context(pipe), 0, nr, views);
}

static void
nv50_fp_set_sampler_views(struct pipe_context *pipe,
                          unsigned nr,
                          struct pipe_sampler_view **views)
{
   nv50_stage_set_sampler_views(nv50_context(pipe), 2, nr, views);
}

static void
nv50_gp_set_sampler_views(struct pipe_context *pipe,
                          unsigned nr,
                          struct pipe_sampler_view **views)
{
   nv50_stage_set_sampler_views(nv50_context(pipe), 1, nr, views);
}

/* ============================= SHADERS =======================================
 */

static void *
nv50_sp_state_create(struct pipe_context *pipe,
                     const struct pipe_shader_state *cso, unsigned type)
{
   struct nv50_program *prog;

   prog = CALLOC_STRUCT(nv50_program);
   if (!prog)
      return NULL;

   prog->type = type;
   prog->pipe.tokens = tgsi_dup_tokens(cso->tokens);

   if (cso->stream_output.num_outputs)
      prog->pipe.stream_output = cso->stream_output;

   return (void *)prog;
}

static void
nv50_sp_state_delete(struct pipe_context *pipe, void *hwcso)
{
   struct nv50_program *prog = (struct nv50_program *)hwcso;

   nv50_program_destroy(nv50_context(pipe), prog);

   FREE((void *)prog->pipe.tokens);
   FREE(prog);
}

static void *
nv50_vp_state_create(struct pipe_context *pipe,
                     const struct pipe_shader_state *cso)
{
   return nv50_sp_state_create(pipe, cso, PIPE_SHADER_VERTEX);
}

static void
nv50_vp_state_bind(struct pipe_context *pipe, void *hwcso)
{
    struct nv50_context *nv50 = nv50_context(pipe);

    nv50->vertprog = hwcso;
    nv50->dirty |= NV50_NEW_VERTPROG;
}

static void *
nv50_fp_state_create(struct pipe_context *pipe,
                     const struct pipe_shader_state *cso)
{
   return nv50_sp_state_create(pipe, cso, PIPE_SHADER_FRAGMENT);
}

static void
nv50_fp_state_bind(struct pipe_context *pipe, void *hwcso)
{
    struct nv50_context *nv50 = nv50_context(pipe);

    nv50->fragprog = hwcso;
    nv50->dirty |= NV50_NEW_FRAGPROG;
}

static void *
nv50_gp_state_create(struct pipe_context *pipe,
                     const struct pipe_shader_state *cso)
{
   return nv50_sp_state_create(pipe, cso, PIPE_SHADER_GEOMETRY);
}

static void
nv50_gp_state_bind(struct pipe_context *pipe, void *hwcso)
{
    struct nv50_context *nv50 = nv50_context(pipe);

    nv50->gmtyprog = hwcso;
    nv50->dirty |= NV50_NEW_GMTYPROG;
}

static void
nv50_set_constant_buffer(struct pipe_context *pipe, uint shader, uint index,
                         struct pipe_constant_buffer *cb)
{
   struct nv50_context *nv50 = nv50_context(pipe);
   struct pipe_resource *res = cb ? cb->buffer : NULL;
   const unsigned s = nv50_context_shader_stage(shader);
   const unsigned i = index;

   if (shader == PIPE_SHADER_COMPUTE)
      return;

   if (nv50->constbuf[s][i].user)
      nv50->constbuf[s][i].u.buf = NULL;
   else
   if (nv50->constbuf[s][i].u.buf)
      nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_CB(s, i));

   pipe_resource_reference(&nv50->constbuf[s][i].u.buf, res);

   nv50->constbuf[s][i].user = (cb && cb->user_buffer) ? TRUE : FALSE;
   if (nv50->constbuf[s][i].user) {
      nv50->constbuf[s][i].u.data = cb->user_buffer;
      nv50->constbuf[s][i].size = cb->buffer_size;
      nv50->constbuf_valid[s] |= 1 << i;
   } else
   if (res) {
      nv50->constbuf[s][i].offset = cb->buffer_offset;
      nv50->constbuf[s][i].size = align(cb->buffer_size, 0x100);
      nv50->constbuf_valid[s] |= 1 << i;
   } else {
      nv50->constbuf_valid[s] &= ~(1 << i);
   }
   nv50->constbuf_dirty[s] |= 1 << i;

   nv50->dirty |= NV50_NEW_CONSTBUF;
}

/* =============================================================================
 */

static void
nv50_set_blend_color(struct pipe_context *pipe,
                     const struct pipe_blend_color *bcol)
{
   struct nv50_context *nv50 = nv50_context(pipe);

   nv50->blend_colour = *bcol;
   nv50->dirty |= NV50_NEW_BLEND_COLOUR;
}

static void
nv50_set_stencil_ref(struct pipe_context *pipe,
                     const struct pipe_stencil_ref *sr)
{
   struct nv50_context *nv50 = nv50_context(pipe);

   nv50->stencil_ref = *sr;
   nv50->dirty |= NV50_NEW_STENCIL_REF;
}

static void
nv50_set_clip_state(struct pipe_context *pipe,
                    const struct pipe_clip_state *clip)
{
   struct nv50_context *nv50 = nv50_context(pipe);

   memcpy(nv50->clip.ucp, clip->ucp, sizeof(clip->ucp));

   nv50->dirty |= NV50_NEW_CLIP;
}

static void
nv50_set_sample_mask(struct pipe_context *pipe, unsigned sample_mask)
{
   struct nv50_context *nv50 = nv50_context(pipe);

   nv50->sample_mask = sample_mask;
   nv50->dirty |= NV50_NEW_SAMPLE_MASK;
}


static void
nv50_set_framebuffer_state(struct pipe_context *pipe,
                           const struct pipe_framebuffer_state *fb)
{
   struct nv50_context *nv50 = nv50_context(pipe);
   unsigned i;

   nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_FB);

   for (i = 0; i < fb->nr_cbufs; ++i)
      pipe_surface_reference(&nv50->framebuffer.cbufs[i], fb->cbufs[i]);
   for (; i < nv50->framebuffer.nr_cbufs; ++i)
      pipe_surface_reference(&nv50->framebuffer.cbufs[i], NULL);

   nv50->framebuffer.nr_cbufs = fb->nr_cbufs;

   nv50->framebuffer.width = fb->width;
   nv50->framebuffer.height = fb->height;

   pipe_surface_reference(&nv50->framebuffer.zsbuf, fb->zsbuf);

   nv50->dirty |= NV50_NEW_FRAMEBUFFER;
}

static void
nv50_set_polygon_stipple(struct pipe_context *pipe,
                         const struct pipe_poly_stipple *stipple)
{
   struct nv50_context *nv50 = nv50_context(pipe);

   nv50->stipple = *stipple;
   nv50->dirty |= NV50_NEW_STIPPLE;
}

static void
nv50_set_scissor_states(struct pipe_context *pipe,
                        unsigned start_slot,
                        unsigned num_scissors,
                        const struct pipe_scissor_state *scissor)
{
   struct nv50_context *nv50 = nv50_context(pipe);

   nv50->scissor = *scissor;
   nv50->dirty |= NV50_NEW_SCISSOR;
}

static void
nv50_set_viewport_states(struct pipe_context *pipe,
                         unsigned start_slot,
                         unsigned num_viewports,
                         const struct pipe_viewport_state *vpt)
{
   struct nv50_context *nv50 = nv50_context(pipe);

   nv50->viewport = *vpt;
   nv50->dirty |= NV50_NEW_VIEWPORT;
}

static void
nv50_set_vertex_buffers(struct pipe_context *pipe,
                        unsigned start_slot, unsigned count,
                        const struct pipe_vertex_buffer *vb)
{
   struct nv50_context *nv50 = nv50_context(pipe);
   unsigned i;

   util_set_vertex_buffers_count(nv50->vtxbuf, &nv50->num_vtxbufs, vb,
                                 start_slot, count);

   if (!vb) {
      nv50->vbo_user &= ~(((1ull << count) - 1) << start_slot);
      nv50->vbo_constant &= ~(((1ull << count) - 1) << start_slot);
      return;
   }

   for (i = 0; i < count; ++i) {
      unsigned dst_index = start_slot + i;

      if (!vb[i].buffer && vb[i].user_buffer) {
         nv50->vbo_user |= 1 << dst_index;
         if (!vb[i].stride)
            nv50->vbo_constant |= 1 << dst_index;
         else
            nv50->vbo_constant &= ~(1 << dst_index);
      } else {
         nv50->vbo_user &= ~(1 << dst_index);
         nv50->vbo_constant &= ~(1 << dst_index);
      }
   }

   nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_VERTEX);

   nv50->dirty |= NV50_NEW_ARRAYS;
}

static void
nv50_set_index_buffer(struct pipe_context *pipe,
                      const struct pipe_index_buffer *ib)
{
   struct nv50_context *nv50 = nv50_context(pipe);

   if (nv50->idxbuf.buffer)
      nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_INDEX);

   if (ib) {
      pipe_resource_reference(&nv50->idxbuf.buffer, ib->buffer);
      nv50->idxbuf.index_size = ib->index_size;
      if (ib->buffer) {
         nv50->idxbuf.offset = ib->offset;
         BCTX_REFN(nv50->bufctx_3d, INDEX, nv04_resource(ib->buffer), RD);
      } else {
         nv50->idxbuf.user_buffer = ib->user_buffer;
      }
   } else {
      pipe_resource_reference(&nv50->idxbuf.buffer, NULL);
   }
}

static void
nv50_vertex_state_bind(struct pipe_context *pipe, void *hwcso)
{
   struct nv50_context *nv50 = nv50_context(pipe);

   nv50->vertex = hwcso;
   nv50->dirty |= NV50_NEW_VERTEX;
}

static struct pipe_stream_output_target *
nv50_so_target_create(struct pipe_context *pipe,
                      struct pipe_resource *res,
                      unsigned offset, unsigned size)
{
   struct nv50_so_target *targ = MALLOC_STRUCT(nv50_so_target);
   if (!targ)
      return NULL;

   if (nouveau_context(pipe)->screen->class_3d >= NVA0_3D_CLASS) {
      targ->pq = pipe->create_query(pipe,
                                    NVA0_QUERY_STREAM_OUTPUT_BUFFER_OFFSET);
      if (!targ->pq) {
         FREE(targ);
         return NULL;
      }
   } else {
      targ->pq = NULL;
   }
   targ->clean = TRUE;

   targ->pipe.buffer_size = size;
   targ->pipe.buffer_offset = offset;
   targ->pipe.context = pipe;
   targ->pipe.buffer = NULL;
   pipe_resource_reference(&targ->pipe.buffer, res);
   pipe_reference_init(&targ->pipe.reference, 1);

   return &targ->pipe;
}

static void
nv50_so_target_destroy(struct pipe_context *pipe,
                       struct pipe_stream_output_target *ptarg)
{
   struct nv50_so_target *targ = nv50_so_target(ptarg);
   if (targ->pq)
      pipe->destroy_query(pipe, targ->pq);
   pipe_resource_reference(&targ->pipe.buffer, NULL);
   FREE(targ);
}

static void
nv50_set_stream_output_targets(struct pipe_context *pipe,
                               unsigned num_targets,
                               struct pipe_stream_output_target **targets,
                               unsigned append_mask)
{
   struct nv50_context *nv50 = nv50_context(pipe);
   unsigned i;
   boolean serialize = TRUE;
   const boolean can_resume = nv50->screen->base.class_3d >= NVA0_3D_CLASS;

   assert(num_targets <= 4);

   for (i = 0; i < num_targets; ++i) {
      const boolean changed = nv50->so_target[i] != targets[i];
      if (!changed && (append_mask & (1 << i)))
         continue;
      nv50->so_targets_dirty |= 1 << i;

      if (can_resume && changed && nv50->so_target[i]) {
         nva0_so_target_save_offset(pipe, nv50->so_target[i], i, serialize);
         serialize = FALSE;
      }

      if (targets[i] && !(append_mask & (1 << i)))
         nv50_so_target(targets[i])->clean = TRUE;

      pipe_so_target_reference(&nv50->so_target[i], targets[i]);
   }
   for (; i < nv50->num_so_targets; ++i) {
      if (can_resume && nv50->so_target[i]) {
         nva0_so_target_save_offset(pipe, nv50->so_target[i], i, serialize);
         serialize = FALSE;
      }
      pipe_so_target_reference(&nv50->so_target[i], NULL);
      nv50->so_targets_dirty |= 1 << i;
   }
   nv50->num_so_targets = num_targets;

   if (nv50->so_targets_dirty)
      nv50->dirty |= NV50_NEW_STRMOUT;
}

void
nv50_init_state_functions(struct nv50_context *nv50)
{
   struct pipe_context *pipe = &nv50->base.pipe;

   pipe->create_blend_state = nv50_blend_state_create;
   pipe->bind_blend_state = nv50_blend_state_bind;
   pipe->delete_blend_state = nv50_blend_state_delete;

   pipe->create_rasterizer_state = nv50_rasterizer_state_create;
   pipe->bind_rasterizer_state = nv50_rasterizer_state_bind;
   pipe->delete_rasterizer_state = nv50_rasterizer_state_delete;

   pipe->create_depth_stencil_alpha_state = nv50_zsa_state_create;
   pipe->bind_depth_stencil_alpha_state = nv50_zsa_state_bind;
   pipe->delete_depth_stencil_alpha_state = nv50_zsa_state_delete;

   pipe->create_sampler_state = nv50_sampler_state_create;
   pipe->delete_sampler_state = nv50_sampler_state_delete;
   pipe->bind_vertex_sampler_states   = nv50_vp_sampler_states_bind;
   pipe->bind_fragment_sampler_states = nv50_fp_sampler_states_bind;
   pipe->bind_geometry_sampler_states = nv50_gp_sampler_states_bind;

   pipe->create_sampler_view = nv50_create_sampler_view;
   pipe->sampler_view_destroy = nv50_sampler_view_destroy;
   pipe->set_vertex_sampler_views   = nv50_vp_set_sampler_views;
   pipe->set_fragment_sampler_views = nv50_fp_set_sampler_views;
   pipe->set_geometry_sampler_views = nv50_gp_set_sampler_views;
 
   pipe->create_vs_state = nv50_vp_state_create;
   pipe->create_fs_state = nv50_fp_state_create;
   pipe->create_gs_state = nv50_gp_state_create;
   pipe->bind_vs_state = nv50_vp_state_bind;
   pipe->bind_fs_state = nv50_fp_state_bind;
   pipe->bind_gs_state = nv50_gp_state_bind;
   pipe->delete_vs_state = nv50_sp_state_delete;
   pipe->delete_fs_state = nv50_sp_state_delete;
   pipe->delete_gs_state = nv50_sp_state_delete;

   pipe->set_blend_color = nv50_set_blend_color;
   pipe->set_stencil_ref = nv50_set_stencil_ref;
   pipe->set_clip_state = nv50_set_clip_state;
   pipe->set_sample_mask = nv50_set_sample_mask;
   pipe->set_constant_buffer = nv50_set_constant_buffer;
   pipe->set_framebuffer_state = nv50_set_framebuffer_state;
   pipe->set_polygon_stipple = nv50_set_polygon_stipple;
   pipe->set_scissor_states = nv50_set_scissor_states;
   pipe->set_viewport_states = nv50_set_viewport_states;

   pipe->create_vertex_elements_state = nv50_vertex_state_create;
   pipe->delete_vertex_elements_state = nv50_vertex_state_delete;
   pipe->bind_vertex_elements_state = nv50_vertex_state_bind;

   pipe->set_vertex_buffers = nv50_set_vertex_buffers;
   pipe->set_index_buffer = nv50_set_index_buffer;

   pipe->create_stream_output_target = nv50_so_target_create;
   pipe->stream_output_target_destroy = nv50_so_target_destroy;
   pipe->set_stream_output_targets = nv50_set_stream_output_targets;
}
@


1.4
log
@Merge Mesa 9.2.0
@
text
@@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d17 4
a20 4
 * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
d24 1
d27 1
d60 1
a60 1
 *  ! pipe_rasterizer_state.gl_rasterization_rules is ignored - pixel centers
d124 1
d126 1
a126 1
   if (nv50_context(pipe)->screen->tesla->grclass >= NVA3_3D) {
d147 1
a147 1
      if (nv50_context(pipe)->screen->tesla->grclass >= NVA3_3D) {
d196 9
d230 1
d253 3
d314 11
d326 7
d460 1
a460 1
   struct nv50_tsc_entry *so = CALLOC_STRUCT(nv50_tsc_entry);
d472 1
a472 1
      so->tsc[1] |= NV50_TSC_1_MAGF_LINEAR;
d476 1
a476 1
      so->tsc[1] |= NV50_TSC_1_MAGF_NEAREST;
d503 7
d536 1
a536 1
   so->tsc[2] |=
d539 11
a549 4
   so->tsc[4] = fui(cso->border_color[0]);
   so->tsc[5] = fui(cso->border_color[1]);
   so->tsc[6] = fui(cso->border_color[2]);
   so->tsc[7] = fui(cso->border_color[3]);
d647 1
a647 1
   nv50_bufctx_reset(nv50, NV50_BUFCTX_TEXTURES);
d692 3
d759 1
a759 1
                         struct pipe_resource *res)
d762 3
d766 2
a767 3
   if (nv50->constbuf[shader][index])
      nv50_bufctx_del_resident(nv50, NV50_BUFCTX_CONSTANT,
			       nv04_resource(nv50->constbuf[shader][index]));
d769 5
a773 1
   pipe_resource_reference(&nv50->constbuf[shader][index], res);
d775 16
a790 1
   nv50->constbuf_dirty[shader] |= 1 << index;
a822 4
   const unsigned size = clip->nr * sizeof(clip->ucp[0]);

   memcpy(&nv50->clip.ucp[0][0], &clip->ucp[0][0], size);
   nv50->clip.nr = clip->nr;
d824 1
a824 1
   nv50->clip.depth_clamp = clip->depth_clamp;
d844 15
a859 1
   nv50->framebuffer = *fb;
d874 4
a877 2
nv50_set_scissor_state(struct pipe_context *pipe,
                       const struct pipe_scissor_state *scissor)
d886 4
a889 2
nv50_set_viewport_state(struct pipe_context *pipe,
                        const struct pipe_viewport_state *vpt)
d899 1
a899 1
                        unsigned count,
d905 2
a906 4
   for (i = 0; i < count; ++i)
      pipe_resource_reference(&nv50->vtxbuf[i].buffer, vb[i].buffer);
   for (; i < nv50->num_vtxbufs; ++i)
      pipe_resource_reference(&nv50->vtxbuf[i].buffer, NULL);
d908 20
a927 2
   memcpy(nv50->vtxbuf, vb, sizeof(*vb) * count);
   nv50->num_vtxbufs = count;
d929 1
a929 1
   nv50_bufctx_reset(nv50, NV50_BUFCTX_VERTEX);
d940 3
d945 7
a951 2

      memcpy(&nv50->idxbuf, ib, sizeof(nv50->idxbuf));
d966 85
d1097 2
a1098 2
   pipe->set_scissor_state = nv50_set_scissor_state;
   pipe->set_viewport_state = nv50_set_viewport_state;
d1107 3
a1109 1
   pipe->redefine_user_buffer = u_default_redefine_user_buffer;
a1110 1

@


1.2
log
@Merge Mesa 7.10.3
@
text
@d2 1
a2 1
 * Copyright 2008 Ben Skeggs
a22 1
#include "pipe/p_state.h"
d25 1
d29 1
a30 1
#include "nv50_texture.h"
d32 34
a65 1
#include "nouveau/nouveau_stateobj.h"
d70 1
a70 1
	uint32_t cmask = 0;
d72 8
a79 8
	if (mask & PIPE_MASK_R)
		cmask |= 0x0001;
	if (mask & PIPE_MASK_G)
		cmask |= 0x0010;
	if (mask & PIPE_MASK_B)
		cmask |= 0x0100;
	if (mask & PIPE_MASK_A)
		cmask |= 0x1000;
d81 1
a81 1
	return cmask;
d84 3
d88 1
a88 1
nv50_blend_func(unsigned factor)
d90 23
a112 42
	switch (factor) {
	case PIPE_BLENDFACTOR_ZERO:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ZERO;
	case PIPE_BLENDFACTOR_ONE:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE;
	case PIPE_BLENDFACTOR_SRC_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_SRC_COLOR;
	case PIPE_BLENDFACTOR_INV_SRC_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_SRC_COLOR;
	case PIPE_BLENDFACTOR_SRC_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_SRC_ALPHA;
	case PIPE_BLENDFACTOR_INV_SRC_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_SRC_ALPHA;
	case PIPE_BLENDFACTOR_DST_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_DST_ALPHA;
	case PIPE_BLENDFACTOR_INV_DST_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_DST_ALPHA;
	case PIPE_BLENDFACTOR_DST_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_DST_COLOR;
	case PIPE_BLENDFACTOR_INV_DST_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_DST_COLOR;
	case PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE:
		return NV50TCL_BLEND_FUNC_SRC_RGB_SRC_ALPHA_SATURATE;
	case PIPE_BLENDFACTOR_CONST_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_CONSTANT_COLOR;
	case PIPE_BLENDFACTOR_INV_CONST_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_CONSTANT_COLOR;
	case PIPE_BLENDFACTOR_CONST_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_CONSTANT_ALPHA;
	case PIPE_BLENDFACTOR_INV_CONST_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_CONSTANT_ALPHA;
	case PIPE_BLENDFACTOR_SRC1_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_SRC1_COLOR;
	case PIPE_BLENDFACTOR_INV_SRC1_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_SRC1_COLOR;
	case PIPE_BLENDFACTOR_SRC1_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_SRC1_ALPHA;
	case PIPE_BLENDFACTOR_INV_SRC1_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_SRC1_ALPHA;
	default:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ZERO;
	}
d117 1
a117 1
			const struct pipe_blend_state *cso)
d119 76
a194 59
	struct nouveau_stateobj *so = so_new(5, 24, 0);
	struct nouveau_grobj *tesla = nv50_context(pipe)->screen->tesla;
	struct nv50_blend_stateobj *bso = CALLOC_STRUCT(nv50_blend_stateobj);
	unsigned i, blend_enabled = 0;

	/*XXX ignored:
	 * 	- dither
	 */

	so_method(so, tesla, NV50TCL_BLEND_ENABLE(0), 8);
	if (cso->independent_blend_enable) {
		for (i = 0; i < 8; ++i) {
			so_data(so, cso->rt[i].blend_enable);
			if (cso->rt[i].blend_enable)
				blend_enabled = 1;
		}
	} else
	if (cso->rt[0].blend_enable) {
		blend_enabled = 1;
		for (i = 0; i < 8; i++)
			so_data(so, 1);
	} else {
		for (i = 0; i < 8; i++)
			so_data(so, 0);
	}
	if (blend_enabled) {
		so_method(so, tesla, NV50TCL_BLEND_EQUATION_RGB, 5);
		so_data  (so, nvgl_blend_eqn(cso->rt[0].rgb_func));
		so_data  (so, nv50_blend_func(cso->rt[0].rgb_src_factor));
		so_data  (so, nv50_blend_func(cso->rt[0].rgb_dst_factor));
		so_data  (so, nvgl_blend_eqn(cso->rt[0].alpha_func));
		so_data  (so, nv50_blend_func(cso->rt[0].alpha_src_factor));
		so_method(so, tesla, NV50TCL_BLEND_FUNC_DST_ALPHA, 1);
		so_data  (so, nv50_blend_func(cso->rt[0].alpha_dst_factor));
	}

	if (cso->logicop_enable == 0 ) {
		so_method(so, tesla, NV50TCL_LOGIC_OP_ENABLE, 1);
		so_data  (so, 0);
	} else {
		so_method(so, tesla, NV50TCL_LOGIC_OP_ENABLE, 2);
		so_data  (so, 1);
		so_data  (so, nvgl_logicop_func(cso->logicop_func));
	}

	so_method(so, tesla, NV50TCL_COLOR_MASK(0), 8);
	if (cso->independent_blend_enable)
		for (i = 0; i < 8; ++i)
			so_data(so, nv50_colormask(cso->rt[i].colormask));
	else {
		uint32_t cmask = nv50_colormask(cso->rt[0].colormask);
		for (i = 0; i < 8; i++)
			so_data(so, cmask);
	}

	bso->pipe = *cso;
	so_ref(so, &bso->so);
	so_ref(NULL, &so);
	return (void *)bso;
d200 1
a200 1
	struct nv50_context *nv50 = nv50_context(pipe);
d202 2
a203 2
	nv50->blend = hwcso;
	nv50->dirty |= NV50_NEW_BLEND;
d209 2
a210 1
	struct nv50_blend_stateobj *bso = hwcso;
d212 99
a310 2
	so_ref(NULL, &bso->so);
	FREE(bso);
d313 2
a314 2
static INLINE unsigned
wrap_mode(unsigned wrap)
d316 1
a316 21
	switch (wrap) {
	case PIPE_TEX_WRAP_REPEAT:
		return NV50TSC_1_0_WRAPS_REPEAT;
	case PIPE_TEX_WRAP_MIRROR_REPEAT:
		return NV50TSC_1_0_WRAPS_MIRROR_REPEAT;
	case PIPE_TEX_WRAP_CLAMP_TO_EDGE:
		return NV50TSC_1_0_WRAPS_CLAMP_TO_EDGE;
	case PIPE_TEX_WRAP_CLAMP_TO_BORDER:
		return NV50TSC_1_0_WRAPS_CLAMP_TO_BORDER;
	case PIPE_TEX_WRAP_CLAMP:
		return NV50TSC_1_0_WRAPS_CLAMP;
	case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE:
		return NV50TSC_1_0_WRAPS_MIRROR_CLAMP_TO_EDGE;
	case PIPE_TEX_WRAP_MIRROR_CLAMP_TO_BORDER:
		return NV50TSC_1_0_WRAPS_MIRROR_CLAMP_TO_BORDER;
	case PIPE_TEX_WRAP_MIRROR_CLAMP:
		return NV50TSC_1_0_WRAPS_MIRROR_CLAMP;
	default:
		NOUVEAU_ERR("unknown wrap mode: %d\n", wrap);
		return NV50TSC_1_0_WRAPS_REPEAT;
	}
d318 1
d320 2
a321 2
nv50_sampler_state_create(struct pipe_context *pipe,
			  const struct pipe_sampler_state *cso)
d323 3
a325 73
	struct nv50_sampler_stateobj *sso = CALLOC(1, sizeof(*sso));
	unsigned *tsc = sso->tsc;
	float limit;

	tsc[0] = (0x00026000 |
		  (wrap_mode(cso->wrap_s) << 0) |
		  (wrap_mode(cso->wrap_t) << 3) |
		  (wrap_mode(cso->wrap_r) << 6));

	switch (cso->mag_img_filter) {
	case PIPE_TEX_FILTER_LINEAR:
		tsc[1] |= NV50TSC_1_1_MAGF_LINEAR;
		break;
	case PIPE_TEX_FILTER_NEAREST:
	default:
		tsc[1] |= NV50TSC_1_1_MAGF_NEAREST;
		break;
	}

	switch (cso->min_img_filter) {
	case PIPE_TEX_FILTER_LINEAR:
		tsc[1] |= NV50TSC_1_1_MINF_LINEAR;
		break;
	case PIPE_TEX_FILTER_NEAREST:
	default:
		tsc[1] |= NV50TSC_1_1_MINF_NEAREST;
		break;
	}

	switch (cso->min_mip_filter) {
	case PIPE_TEX_MIPFILTER_LINEAR:
		tsc[1] |= NV50TSC_1_1_MIPF_LINEAR;
		break;
	case PIPE_TEX_MIPFILTER_NEAREST:
		tsc[1] |= NV50TSC_1_1_MIPF_NEAREST;
		break;
	case PIPE_TEX_MIPFILTER_NONE:
	default:
		tsc[1] |= NV50TSC_1_1_MIPF_NONE;
		break;
	}

	if (cso->max_anisotropy >= 16)
		tsc[0] |= (7 << 20);
	else
	if (cso->max_anisotropy >= 12)
		tsc[0] |= (6 << 20);
	else {
		tsc[0] |= (cso->max_anisotropy >> 1) << 20;

		if (cso->max_anisotropy >= 4)
			tsc[1] |= NV50TSC_1_1_UNKN_ANISO_35;
		else
		if (cso->max_anisotropy >= 2)
			tsc[1] |= NV50TSC_1_1_UNKN_ANISO_15;
	}

	if (cso->compare_mode == PIPE_TEX_COMPARE_R_TO_TEXTURE) {
		/* XXX: must be deactivated for non-shadow textures */
		tsc[0] |= (1 << 9);
		tsc[0] |= (nvgl_comparison_op(cso->compare_func) & 0x7) << 10;
	}

	limit = CLAMP(cso->lod_bias, -16.0, 15.0);
	tsc[1] |= ((int)(limit * 256.0) & 0x1fff) << 12;

	tsc[2] |= ((int)CLAMP(cso->max_lod, 0.0, 15.0) << 20) |
		  ((int)CLAMP(cso->min_lod, 0.0, 15.0) << 8);

	tsc[4] = fui(cso->border_color[0]);
	tsc[5] = fui(cso->border_color[1]);
	tsc[6] = fui(cso->border_color[2]);
	tsc[7] = fui(cso->border_color[3]);
d327 63
a389 2
	sso->normalized = cso->normalized_coords;
	return (void *)sso;
d392 2
a393 6
/* type == 0 for VPs, 1 for GPs, 2 for FPs, which is how the
 * relevant tesla methods are indexed (NV50TCL_BIND_TSC etc.)
 */
static INLINE void
nv50_sampler_state_bind(struct pipe_context *pipe, unsigned type,
			unsigned nr, void **sampler)
d395 2
a396 1
	struct nv50_context *nv50 = nv50_context(pipe);
d398 2
a399 1
	memcpy(nv50->sampler[type], sampler, nr * sizeof(void *));
d401 2
a402 3
	nv50->sampler_nr[type] = nr;
	nv50->dirty |= NV50_NEW_SAMPLER;
}
d404 2
a405 2
static void
nv50_vp_sampler_state_bind(struct pipe_context *pipe, unsigned nr, void **s)
d407 13
a419 1
	nv50_sampler_state_bind(pipe, 0, nr, s);
d422 3
a424 2
static void
nv50_fp_sampler_state_bind(struct pipe_context *pipe, unsigned nr, void **s)
d426 78
a503 1
	nv50_sampler_state_bind(pipe, 2, nr, s);
d509 10
a518 1
	FREE(hwcso);
d522 2
a523 3
nv50_set_sampler_views(struct pipe_context *pipe, unsigned p,
		       unsigned nr,
		       struct pipe_sampler_view **views)
d525 4
a528 2
	struct nv50_context *nv50 = nv50_context(pipe);
	unsigned i;
d530 7
a536 3
	for (i = 0; i < nr; i++)
		pipe_sampler_view_reference(&nv50->sampler_views[p][i],
					    views[i]);
d538 1
a538 2
	for (i = nr; i < nv50->sampler_view_nr[p]; i++)
		pipe_sampler_view_reference(&nv50->sampler_views[p][i], NULL);
d540 1
a540 2
	nv50->sampler_view_nr[p] = nr;
	nv50->dirty |= NV50_NEW_TEXTURE;
d544 1
a544 3
nv50_set_vp_sampler_views(struct pipe_context *pipe,
			  unsigned nr,
			  struct pipe_sampler_view **views)
d546 1
a546 1
	nv50_set_sampler_views(pipe, 0, nr, views);
d550 1
a550 3
nv50_set_fp_sampler_views(struct pipe_context *pipe,
			  unsigned nr,
			  struct pipe_sampler_view **views)
d552 1
a552 1
	nv50_set_sampler_views(pipe, 2, nr, views);
d556 7
d564 1
a564 1
			  struct pipe_sampler_view *view)
d566 5
a570 2
	pipe_resource_reference(&view->texture, NULL);
	FREE(nv50_sampler_view(view));
d573 29
a601 18
static struct pipe_sampler_view *
nv50_create_sampler_view(struct pipe_context *pipe,
			 struct pipe_resource *texture,
			 const struct pipe_sampler_view *templ)
{
	struct nv50_sampler_view *view = CALLOC_STRUCT(nv50_sampler_view);

	view->pipe = *templ;
	view->pipe.reference.count = 1;
	view->pipe.texture = NULL;
	pipe_resource_reference(&view->pipe.texture, texture);
	view->pipe.context = pipe;

	if (!nv50_tex_construct(view)) {
		nv50_sampler_view_destroy(pipe, &view->pipe);
		return NULL;
	}
	return &view->pipe;
d604 4
a607 4

static void *
nv50_rasterizer_state_create(struct pipe_context *pipe,
			     const struct pipe_rasterizer_state *cso)
d609 1
a609 94
	struct nouveau_stateobj *so = so_new(16, 22, 0);
	struct nouveau_grobj *tesla = nv50_context(pipe)->screen->tesla;
	struct nv50_rasterizer_stateobj *rso =
		CALLOC_STRUCT(nv50_rasterizer_stateobj);

	/*XXX: ignored
	 * 	- light_twoside
	 * 	- point_smooth
	 * 	- multisample
	 * 	- point_sprite / sprite_coord_mode
	 */

	so_method(so, tesla, NV50TCL_SCISSOR_ENABLE(0), 1);
	so_data  (so, cso->scissor);

	so_method(so, tesla, NV50TCL_SHADE_MODEL, 1);
	so_data  (so, cso->flatshade ? NV50TCL_SHADE_MODEL_FLAT :
				       NV50TCL_SHADE_MODEL_SMOOTH);
	so_method(so, tesla, NV50TCL_PROVOKING_VERTEX_LAST, 1);
	so_data  (so, cso->flatshade_first ? 0 : 1);

	so_method(so, tesla, NV50TCL_VERTEX_TWO_SIDE_ENABLE, 1);
	so_data  (so, cso->light_twoside);

	so_method(so, tesla, NV50TCL_LINE_WIDTH, 1);
	so_data  (so, fui(cso->line_width));
	so_method(so, tesla, NV50TCL_LINE_SMOOTH_ENABLE, 1);
	so_data  (so, cso->line_smooth ? 1 : 0);
	if (cso->line_stipple_enable) {
		so_method(so, tesla, NV50TCL_LINE_STIPPLE_ENABLE, 1);
		so_data  (so, 1);
		so_method(so, tesla, NV50TCL_LINE_STIPPLE_PATTERN, 1);
		so_data  (so, (cso->line_stipple_pattern << 8) |
			       cso->line_stipple_factor);
	} else {
		so_method(so, tesla, NV50TCL_LINE_STIPPLE_ENABLE, 1);
		so_data  (so, 0);
	}

	so_method(so, tesla, NV50TCL_POINT_SIZE, 1);
	so_data  (so, fui(cso->point_size));

	so_method(so, tesla, NV50TCL_POINT_SPRITE_ENABLE, 1);
	so_data  (so, cso->point_quad_rasterization ? 1 : 0);

	so_method(so, tesla, NV50TCL_POLYGON_MODE_FRONT, 3);
        so_data(so, nvgl_polygon_mode(cso->fill_front));
        so_data(so, nvgl_polygon_mode(cso->fill_back));
	so_data(so, cso->poly_smooth ? 1 : 0);

	so_method(so, tesla, NV50TCL_CULL_FACE_ENABLE, 3);
	so_data  (so, cso->cull_face != PIPE_FACE_NONE);
	if (cso->front_ccw) {
		so_data(so, NV50TCL_FRONT_FACE_CCW);
        }
        else {
		so_data(so, NV50TCL_FRONT_FACE_CW);
        }
	switch (cso->cull_face) {
	case PIPE_FACE_FRONT:
		so_data(so, NV50TCL_CULL_FACE_FRONT);
		break;
	case PIPE_FACE_BACK:
		so_data(so, NV50TCL_CULL_FACE_BACK);
		break;
	case PIPE_FACE_FRONT_AND_BACK:
		so_data(so, NV50TCL_CULL_FACE_FRONT_AND_BACK);
		break;
	default:
		so_data(so, NV50TCL_CULL_FACE_BACK);
		break;
	}

	so_method(so, tesla, NV50TCL_POLYGON_STIPPLE_ENABLE, 1);
	so_data  (so, cso->poly_stipple_enable ? 1 : 0);

	so_method(so, tesla, NV50TCL_POLYGON_OFFSET_POINT_ENABLE, 3);
        so_data(so, cso->offset_point);
        so_data(so, cso->offset_line);
        so_data(so, cso->offset_tri);

	if (cso->offset_point ||
            cso->offset_line ||
            cso->offset_tri) {
		so_method(so, tesla, NV50TCL_POLYGON_OFFSET_FACTOR, 1);
		so_data  (so, fui(cso->offset_scale));
		so_method(so, tesla, NV50TCL_POLYGON_OFFSET_UNITS, 1);
		so_data  (so, fui(cso->offset_units * 2.0f));
	}

	rso->pipe = *cso;
	so_ref(so, &rso->so);
	so_ref(NULL, &so);
	return (void *)rso;
d613 3
a615 1
nv50_rasterizer_state_bind(struct pipe_context *pipe, void *hwcso)
d617 1
a617 4
	struct nv50_context *nv50 = nv50_context(pipe);

	nv50->rasterizer = hwcso;
	nv50->dirty |= NV50_NEW_RASTERIZER;
d621 3
a623 1
nv50_rasterizer_state_delete(struct pipe_context *pipe, void *hwcso)
d625 2
a626 1
	struct nv50_rasterizer_stateobj *rso = hwcso;
d628 2
a629 3
	so_ref(NULL, &rso->so);
	FREE(rso);
}
d632 2
a633 2
nv50_depth_stencil_alpha_state_create(struct pipe_context *pipe,
			const struct pipe_depth_stencil_alpha_state *cso)
d635 10
a644 70
	struct nouveau_grobj *tesla = nv50_context(pipe)->screen->tesla;
	struct nv50_zsa_stateobj *zsa = CALLOC_STRUCT(nv50_zsa_stateobj);
	struct nouveau_stateobj *so = so_new(9, 21, 0);

	so_method(so, tesla, NV50TCL_DEPTH_WRITE_ENABLE, 1);
	so_data  (so, cso->depth.writemask ? 1 : 0);
	if (cso->depth.enabled) {
		so_method(so, tesla, NV50TCL_DEPTH_TEST_ENABLE, 1);
		so_data  (so, 1);
		so_method(so, tesla, NV50TCL_DEPTH_TEST_FUNC, 1);
		so_data  (so, nvgl_comparison_op(cso->depth.func));
	} else {
		so_method(so, tesla, NV50TCL_DEPTH_TEST_ENABLE, 1);
		so_data  (so, 0);
	}

	if (cso->stencil[0].enabled) {
		so_method(so, tesla, NV50TCL_STENCIL_FRONT_ENABLE, 5);
		so_data  (so, 1);
		so_data  (so, nvgl_stencil_op(cso->stencil[0].fail_op));
		so_data  (so, nvgl_stencil_op(cso->stencil[0].zfail_op));
		so_data  (so, nvgl_stencil_op(cso->stencil[0].zpass_op));
		so_data  (so, nvgl_comparison_op(cso->stencil[0].func));
		so_method(so, tesla, NV50TCL_STENCIL_FRONT_MASK, 2);
		so_data  (so, cso->stencil[0].writemask);
		so_data  (so, cso->stencil[0].valuemask);
	} else {
		so_method(so, tesla, NV50TCL_STENCIL_FRONT_ENABLE, 1);
		so_data  (so, 0);
	}

	if (cso->stencil[1].enabled) {
		so_method(so, tesla, NV50TCL_STENCIL_BACK_ENABLE, 5);
		so_data  (so, 1);
		so_data  (so, nvgl_stencil_op(cso->stencil[1].fail_op));
		so_data  (so, nvgl_stencil_op(cso->stencil[1].zfail_op));
		so_data  (so, nvgl_stencil_op(cso->stencil[1].zpass_op));
		so_data  (so, nvgl_comparison_op(cso->stencil[1].func));
		so_method(so, tesla, NV50TCL_STENCIL_BACK_MASK, 2);
		so_data  (so, cso->stencil[1].writemask);
		so_data  (so, cso->stencil[1].valuemask);
	} else {
		so_method(so, tesla, NV50TCL_STENCIL_BACK_ENABLE, 1);
		so_data  (so, 0);
	}

	if (cso->alpha.enabled) {
		so_method(so, tesla, NV50TCL_ALPHA_TEST_ENABLE, 1);
		so_data  (so, 1);
		so_method(so, tesla, NV50TCL_ALPHA_TEST_REF, 2);
		so_data  (so, fui(cso->alpha.ref_value));
		so_data  (so, nvgl_comparison_op(cso->alpha.func));
	} else {
		so_method(so, tesla, NV50TCL_ALPHA_TEST_ENABLE, 1);
		so_data  (so, 0);
	}

	zsa->pipe = *cso;
	so_ref(so, &zsa->so);
	so_ref(NULL, &so);
	return (void *)zsa;
}

static void
nv50_depth_stencil_alpha_state_bind(struct pipe_context *pipe, void *hwcso)
{
	struct nv50_context *nv50 = nv50_context(pipe);

	nv50->zsa = hwcso;
	nv50->dirty |= NV50_NEW_ZSA;
d648 1
a648 1
nv50_depth_stencil_alpha_state_delete(struct pipe_context *pipe, void *hwcso)
d650 3
a652 1
	struct nv50_zsa_stateobj *zsa = hwcso;
d654 2
a655 2
	so_ref(NULL, &zsa->so);
	FREE(zsa);
d660 1
a660 1
		     const struct pipe_shader_state *cso)
d662 1
a662 5
	struct nv50_program *p = CALLOC_STRUCT(nv50_program);

	p->pipe.tokens = tgsi_dup_tokens(cso->tokens);
	p->type = PIPE_SHADER_VERTEX;
	return (void *)p;
d668 1
a668 11
	struct nv50_context *nv50 = nv50_context(pipe);

	nv50->vertprog = hwcso;
	nv50->dirty |= NV50_NEW_VERTPROG;
}

static void
nv50_vp_state_delete(struct pipe_context *pipe, void *hwcso)
{
	struct nv50_context *nv50 = nv50_context(pipe);
	struct nv50_program *p = hwcso;
d670 2
a671 3
	nv50_program_destroy(nv50, p);
	FREE((void *)p->pipe.tokens);
	FREE(p);
d676 1
a676 1
		     const struct pipe_shader_state *cso)
d678 1
a678 5
	struct nv50_program *p = CALLOC_STRUCT(nv50_program);

	p->pipe.tokens = tgsi_dup_tokens(cso->tokens);
	p->type = PIPE_SHADER_FRAGMENT;
	return (void *)p;
d684 1
a684 11
	struct nv50_context *nv50 = nv50_context(pipe);

	nv50->fragprog = hwcso;
	nv50->dirty |= NV50_NEW_FRAGPROG;
}

static void
nv50_fp_state_delete(struct pipe_context *pipe, void *hwcso)
{
	struct nv50_context *nv50 = nv50_context(pipe);
	struct nv50_program *p = hwcso;
d686 2
a687 3
	nv50_program_destroy(nv50, p);
	FREE((void *)p->pipe.tokens);
	FREE(p);
d692 1
a692 1
		     const struct pipe_shader_state *cso)
d694 1
a694 5
	struct nv50_program *p = CALLOC_STRUCT(nv50_program);

	p->pipe.tokens = tgsi_dup_tokens(cso->tokens);
	p->type = PIPE_SHADER_GEOMETRY;
	return (void *)p;
d700 1
a700 1
	struct nv50_context *nv50 = nv50_context(pipe);
d702 2
a703 2
	nv50->geomprog = hwcso;
	nv50->dirty |= NV50_NEW_GEOMPROG;
d707 2
a708 1
nv50_gp_state_delete(struct pipe_context *pipe, void *hwcso)
d710 7
a716 2
	struct nv50_context *nv50 = nv50_context(pipe);
	struct nv50_program *p = hwcso;
d718 3
a720 3
	nv50_program_destroy(nv50, p);
	FREE((void *)p->pipe.tokens);
	FREE(p);
d723 3
d728 1
a728 1
		     const struct pipe_blend_color *bcol)
d730 1
a730 1
	struct nv50_context *nv50 = nv50_context(pipe);
d732 2
a733 2
	nv50->blend_colour = *bcol;
	nv50->dirty |= NV50_NEW_BLEND_COLOUR;
d736 1
a736 1
 static void
d738 1
a738 1
		     const struct pipe_stencil_ref *sr)
d740 1
a740 1
	struct nv50_context *nv50 = nv50_context(pipe);
d742 2
a743 2
	nv50->stencil_ref = *sr;
	nv50->dirty |= NV50_NEW_STENCIL_REF;
d748 1
a748 1
		    const struct pipe_clip_state *clip)
d750 2
a751 1
	struct nv50_context *nv50 = nv50_context(pipe);
d753 4
a756 3
	nv50->clip.depth_clamp = clip->depth_clamp;
	nv50->dirty |= NV50_NEW_CLIP;
}
d758 1
a758 4
static void
nv50_set_sample_mask(struct pipe_context *pipe,
		     unsigned sample_mask)
{
d762 1
a762 2
nv50_set_constant_buffer(struct pipe_context *pipe, uint shader, uint index,
			 struct pipe_resource *buf )
d764 1
a764 1
	struct nv50_context *nv50 = nv50_context(pipe);
d766 2
a767 12
	if (shader == PIPE_SHADER_VERTEX) {
		nv50->constbuf[PIPE_SHADER_VERTEX] = buf;
		nv50->dirty |= NV50_NEW_VERTPROG_CB;
	} else
	if (shader == PIPE_SHADER_FRAGMENT) {
		nv50->constbuf[PIPE_SHADER_FRAGMENT] = buf;
		nv50->dirty |= NV50_NEW_FRAGPROG_CB;
	} else
	if (shader == PIPE_SHADER_GEOMETRY) {
		nv50->constbuf[PIPE_SHADER_GEOMETRY] = buf;
		nv50->dirty |= NV50_NEW_GEOMPROG_CB;
	}
d770 1
d773 1
a773 1
			   const struct pipe_framebuffer_state *fb)
d775 1
a775 1
	struct nv50_context *nv50 = nv50_context(pipe);
d777 2
a778 2
	nv50->framebuffer = *fb;
	nv50->dirty |= NV50_NEW_FRAMEBUFFER;
d783 1
a783 1
			 const struct pipe_poly_stipple *stipple)
d785 1
a785 1
	struct nv50_context *nv50 = nv50_context(pipe);
d787 2
a788 2
	nv50->stipple = *stipple;
	nv50->dirty |= NV50_NEW_STIPPLE;
d793 1
a793 1
		       const struct pipe_scissor_state *s)
d795 1
a795 1
	struct nv50_context *nv50 = nv50_context(pipe);
d797 2
a798 2
	nv50->scissor = *s;
	nv50->dirty |= NV50_NEW_SCISSOR;
d803 1
a803 1
			const struct pipe_viewport_state *vpt)
d805 1
a805 1
	struct nv50_context *nv50 = nv50_context(pipe);
d807 2
a808 2
	nv50->viewport = *vpt;
	nv50->dirty |= NV50_NEW_VIEWPORT;
d812 3
a814 2
nv50_set_vertex_buffers(struct pipe_context *pipe, unsigned count,
			const struct pipe_vertex_buffer *vb)
d816 7
a822 1
	struct nv50_context *nv50 = nv50_context(pipe);
d824 2
a825 2
	memcpy(nv50->vtxbuf, vb, sizeof(*vb) * count);
	nv50->vtxbuf_nr = count;
d827 3
a829 1
	nv50->dirty |= NV50_NEW_ARRAYS;
d834 1
a834 16
		      const struct pipe_index_buffer *ib)
{
	struct nv50_context *nv50 = nv50_context(pipe);

	if (ib)
		memcpy(&nv50->idxbuf, ib, sizeof(nv50->idxbuf));
	else
		memset(&nv50->idxbuf, 0, sizeof(nv50->idxbuf));

	/* TODO make this more like a state */
}

static void *
nv50_vtxelts_state_create(struct pipe_context *pipe,
			  unsigned num_elements,
			  const struct pipe_vertex_element *elements)
d836 1
a836 1
	struct nv50_vtxelt_stateobj *cso = CALLOC_STRUCT(nv50_vtxelt_stateobj);
d838 2
a839 3
	assert(num_elements < 16); /* not doing fallbacks yet */
	cso->num_elements = num_elements;
	memcpy(cso->pipe, elements, num_elements * sizeof(*elements));
d841 4
a844 3
	nv50_vtxelt_construct(cso);

	return (void *)cso;
d848 1
a848 1
nv50_vtxelts_state_delete(struct pipe_context *pipe, void *hwcso)
d850 1
a850 2
	FREE(hwcso);
}
d852 2
a853 7
static void
nv50_vtxelts_state_bind(struct pipe_context *pipe, void *hwcso)
{
	struct nv50_context *nv50 = nv50_context(pipe);

	nv50->vtxelt = hwcso;
	nv50->dirty |= NV50_NEW_ARRAYS;
d859 52
a910 49
	nv50->pipe.create_blend_state = nv50_blend_state_create;
	nv50->pipe.bind_blend_state = nv50_blend_state_bind;
	nv50->pipe.delete_blend_state = nv50_blend_state_delete;

	nv50->pipe.create_sampler_state = nv50_sampler_state_create;
	nv50->pipe.delete_sampler_state = nv50_sampler_state_delete;
	nv50->pipe.bind_fragment_sampler_states = nv50_fp_sampler_state_bind;
	nv50->pipe.bind_vertex_sampler_states   = nv50_vp_sampler_state_bind;
	nv50->pipe.set_fragment_sampler_views = nv50_set_fp_sampler_views;
	nv50->pipe.set_vertex_sampler_views   = nv50_set_vp_sampler_views;
	nv50->pipe.create_sampler_view = nv50_create_sampler_view;
	nv50->pipe.sampler_view_destroy = nv50_sampler_view_destroy;

	nv50->pipe.create_rasterizer_state = nv50_rasterizer_state_create;
	nv50->pipe.bind_rasterizer_state = nv50_rasterizer_state_bind;
	nv50->pipe.delete_rasterizer_state = nv50_rasterizer_state_delete;

	nv50->pipe.create_depth_stencil_alpha_state =
		nv50_depth_stencil_alpha_state_create;
	nv50->pipe.bind_depth_stencil_alpha_state =
		nv50_depth_stencil_alpha_state_bind;
	nv50->pipe.delete_depth_stencil_alpha_state =
		nv50_depth_stencil_alpha_state_delete;

	nv50->pipe.create_vs_state = nv50_vp_state_create;
	nv50->pipe.bind_vs_state = nv50_vp_state_bind;
	nv50->pipe.delete_vs_state = nv50_vp_state_delete;

	nv50->pipe.create_fs_state = nv50_fp_state_create;
	nv50->pipe.bind_fs_state = nv50_fp_state_bind;
	nv50->pipe.delete_fs_state = nv50_fp_state_delete;

	nv50->pipe.create_gs_state = nv50_gp_state_create;
	nv50->pipe.bind_gs_state = nv50_gp_state_bind;
	nv50->pipe.delete_gs_state = nv50_gp_state_delete;

	nv50->pipe.set_blend_color = nv50_set_blend_color;
        nv50->pipe.set_stencil_ref = nv50_set_stencil_ref;
	nv50->pipe.set_clip_state = nv50_set_clip_state;
	nv50->pipe.set_sample_mask = nv50_set_sample_mask;
	nv50->pipe.set_constant_buffer = nv50_set_constant_buffer;
	nv50->pipe.set_framebuffer_state = nv50_set_framebuffer_state;
	nv50->pipe.set_polygon_stipple = nv50_set_polygon_stipple;
	nv50->pipe.set_scissor_state = nv50_set_scissor_state;
	nv50->pipe.set_viewport_state = nv50_set_viewport_state;

	nv50->pipe.create_vertex_elements_state = nv50_vtxelts_state_create;
	nv50->pipe.delete_vertex_elements_state = nv50_vtxelts_state_delete;
	nv50->pipe.bind_vertex_elements_state = nv50_vtxelts_state_bind;
d912 1
a912 2
	nv50->pipe.set_vertex_buffers = nv50_set_vertex_buffers;
	nv50->pipe.set_index_buffer = nv50_set_index_buffer;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d51 47
d130 2
a131 2
		so_data  (so, 0x4000 | nvgl_blend_func(cso->rt[0].rgb_src_factor));
		so_data  (so, 0x4000 | nvgl_blend_func(cso->rt[0].rgb_dst_factor));
d133 1
a133 1
		so_data  (so, 0x4000 | nvgl_blend_func(cso->rt[0].alpha_src_factor));
d135 1
a135 1
		so_data  (so, 0x4000 | nvgl_blend_func(cso->rt[0].alpha_dst_factor));
d288 3
d306 1
a306 1
	nv50_sampler_state_bind(pipe, PIPE_SHADER_VERTEX, nr, s);
d312 1
a312 1
	nv50_sampler_state_bind(pipe, PIPE_SHADER_FRAGMENT, nr, s);
d322 3
a324 2
nv50_set_sampler_texture(struct pipe_context *pipe, unsigned type,
			 unsigned nr, struct pipe_texture **pt)
d330 5
a334 3
		pipe_texture_reference((void *)&nv50->miptree[type][i], pt[i]);
	for (i = nr; i < nv50->miptree_nr[type]; i++)
		pipe_texture_reference((void *)&nv50->miptree[type][i], NULL);
d336 1
a336 1
	nv50->miptree_nr[type] = nr;
d341 3
a343 2
nv50_set_vp_sampler_textures(struct pipe_context *pipe,
			     unsigned nr, struct pipe_texture **pt)
d345 1
a345 1
	nv50_set_sampler_texture(pipe, PIPE_SHADER_VERTEX, nr, pt);
d349 3
a351 2
nv50_set_fp_sampler_textures(struct pipe_context *pipe,
			     unsigned nr, struct pipe_texture **pt)
d353 29
a381 1
	nv50_set_sampler_texture(pipe, PIPE_SHADER_FRAGMENT, nr, pt);
d384 1
d389 1
a389 1
	struct nouveau_stateobj *so = so_new(15, 21, 0);
d395 1
a395 1
	 * 	- light_twosize
d401 3
d435 2
a436 7
	if (cso->front_winding == PIPE_WINDING_CCW) {
		so_data(so, nvgl_polygon_mode(cso->fill_ccw));
		so_data(so, nvgl_polygon_mode(cso->fill_cw));
	} else {
		so_data(so, nvgl_polygon_mode(cso->fill_cw));
		so_data(so, nvgl_polygon_mode(cso->fill_ccw));
	}
d440 2
a441 2
	so_data  (so, cso->cull_mode != PIPE_WINDING_NONE);
	if (cso->front_winding == PIPE_WINDING_CCW) {
d443 2
a444 15
		switch (cso->cull_mode) {
		case PIPE_WINDING_CCW:
			so_data(so, NV50TCL_CULL_FACE_FRONT);
			break;
		case PIPE_WINDING_CW:
			so_data(so, NV50TCL_CULL_FACE_BACK);
			break;
		case PIPE_WINDING_BOTH:
			so_data(so, NV50TCL_CULL_FACE_FRONT_AND_BACK);
			break;
		default:
			so_data(so, NV50TCL_CULL_FACE_BACK);
			break;
		}
	} else {
d446 14
a459 14
		switch (cso->cull_mode) {
		case PIPE_WINDING_CCW:
			so_data(so, NV50TCL_CULL_FACE_BACK);
			break;
		case PIPE_WINDING_CW:
			so_data(so, NV50TCL_CULL_FACE_FRONT);
			break;
		case PIPE_WINDING_BOTH:
			so_data(so, NV50TCL_CULL_FACE_FRONT_AND_BACK);
			break;
		default:
			so_data(so, NV50TCL_CULL_FACE_BACK);
			break;
		}
d466 7
a472 17
	if ((cso->offset_cw && cso->fill_cw == PIPE_POLYGON_MODE_POINT) ||
	    (cso->offset_ccw && cso->fill_ccw == PIPE_POLYGON_MODE_POINT))
		so_data(so, 1);
	else
		so_data(so, 0);
	if ((cso->offset_cw && cso->fill_cw == PIPE_POLYGON_MODE_LINE) ||
	    (cso->offset_ccw && cso->fill_ccw == PIPE_POLYGON_MODE_LINE))
		so_data(so, 1);
	else
		so_data(so, 0);
	if ((cso->offset_cw && cso->fill_cw == PIPE_POLYGON_MODE_FILL) ||
	    (cso->offset_ccw && cso->fill_ccw == PIPE_POLYGON_MODE_FILL))
		so_data(so, 1);
	else
		so_data(so, 0);

	if (cso->offset_cw || cso->offset_ccw) {
a595 1
	tgsi_scan_shader(p->pipe.tokens, &p->info);
a626 1
	tgsi_scan_shader(p->pipe.tokens, &p->info);
a657 1
	tgsi_scan_shader(p->pipe.tokens, &p->info);
d666 1
a666 1
	nv50->fragprog = hwcso;
d705 10
d719 1
a719 1
			 struct pipe_buffer *buf )
d790 2
a791 2
nv50_set_vertex_elements(struct pipe_context *pipe, unsigned count,
			 const struct pipe_vertex_element *ve)
d795 14
a808 2
	memcpy(nv50->vtxelt, ve, sizeof(*ve) * count);
	nv50->vtxelt_nr = count;
d810 21
d845 4
a848 2
	nv50->pipe.set_fragment_sampler_textures = nv50_set_fp_sampler_textures;
	nv50->pipe.set_vertex_sampler_textures   = nv50_set_vp_sampler_textures;
d876 1
d883 4
d888 1
a888 1
	nv50->pipe.set_vertex_elements = nv50_set_vertex_elements;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a50 47
static INLINE uint32_t
nv50_blend_func(unsigned factor)
{
	switch (factor) {
	case PIPE_BLENDFACTOR_ZERO:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ZERO;
	case PIPE_BLENDFACTOR_ONE:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE;
	case PIPE_BLENDFACTOR_SRC_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_SRC_COLOR;
	case PIPE_BLENDFACTOR_INV_SRC_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_SRC_COLOR;
	case PIPE_BLENDFACTOR_SRC_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_SRC_ALPHA;
	case PIPE_BLENDFACTOR_INV_SRC_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_SRC_ALPHA;
	case PIPE_BLENDFACTOR_DST_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_DST_ALPHA;
	case PIPE_BLENDFACTOR_INV_DST_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_DST_ALPHA;
	case PIPE_BLENDFACTOR_DST_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_DST_COLOR;
	case PIPE_BLENDFACTOR_INV_DST_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_DST_COLOR;
	case PIPE_BLENDFACTOR_SRC_ALPHA_SATURATE:
		return NV50TCL_BLEND_FUNC_SRC_RGB_SRC_ALPHA_SATURATE;
	case PIPE_BLENDFACTOR_CONST_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_CONSTANT_COLOR;
	case PIPE_BLENDFACTOR_INV_CONST_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_CONSTANT_COLOR;
	case PIPE_BLENDFACTOR_CONST_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_CONSTANT_ALPHA;
	case PIPE_BLENDFACTOR_INV_CONST_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_CONSTANT_ALPHA;
	case PIPE_BLENDFACTOR_SRC1_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_SRC1_COLOR;
	case PIPE_BLENDFACTOR_INV_SRC1_COLOR:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_SRC1_COLOR;
	case PIPE_BLENDFACTOR_SRC1_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_SRC1_ALPHA;
	case PIPE_BLENDFACTOR_INV_SRC1_ALPHA:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ONE_MINUS_SRC1_ALPHA;
	default:
		return NV50TCL_BLEND_FUNC_SRC_RGB_ZERO;
	}
}

d83 2
a84 2
		so_data  (so, nv50_blend_func(cso->rt[0].rgb_src_factor));
		so_data  (so, nv50_blend_func(cso->rt[0].rgb_dst_factor));
d86 1
a86 1
		so_data  (so, nv50_blend_func(cso->rt[0].alpha_src_factor));
d88 1
a88 1
		so_data  (so, nv50_blend_func(cso->rt[0].alpha_dst_factor));
a240 3
/* type == 0 for VPs, 1 for GPs, 2 for FPs, which is how the
 * relevant tesla methods are indexed (NV50TCL_BIND_TSC etc.)
 */
d256 1
a256 1
	nv50_sampler_state_bind(pipe, 0, nr, s);
d262 1
a262 1
	nv50_sampler_state_bind(pipe, 2, nr, s);
d272 2
a273 3
nv50_set_sampler_views(struct pipe_context *pipe, unsigned p,
		       unsigned nr,
		       struct pipe_sampler_view **views)
d279 3
a281 5
		pipe_sampler_view_reference(&nv50->sampler_views[p][i],
					    views[i]);

	for (i = nr; i < nv50->sampler_view_nr[p]; i++)
		pipe_sampler_view_reference(&nv50->sampler_views[p][i], NULL);
d283 1
a283 1
	nv50->sampler_view_nr[p] = nr;
d288 2
a289 3
nv50_set_vp_sampler_views(struct pipe_context *pipe,
			  unsigned nr,
			  struct pipe_sampler_view **views)
d291 1
a291 1
	nv50_set_sampler_views(pipe, 0, nr, views);
d295 2
a296 3
nv50_set_fp_sampler_views(struct pipe_context *pipe,
			  unsigned nr,
			  struct pipe_sampler_view **views)
d298 1
a298 29
	nv50_set_sampler_views(pipe, 2, nr, views);
}

static void
nv50_sampler_view_destroy(struct pipe_context *pipe,
			  struct pipe_sampler_view *view)
{
	pipe_resource_reference(&view->texture, NULL);
	FREE(nv50_sampler_view(view));
}

static struct pipe_sampler_view *
nv50_create_sampler_view(struct pipe_context *pipe,
			 struct pipe_resource *texture,
			 const struct pipe_sampler_view *templ)
{
	struct nv50_sampler_view *view = CALLOC_STRUCT(nv50_sampler_view);

	view->pipe = *templ;
	view->pipe.reference.count = 1;
	view->pipe.texture = NULL;
	pipe_resource_reference(&view->pipe.texture, texture);
	view->pipe.context = pipe;

	if (!nv50_tex_construct(view)) {
		nv50_sampler_view_destroy(pipe, &view->pipe);
		return NULL;
	}
	return &view->pipe;
a300 1

d305 1
a305 1
	struct nouveau_stateobj *so = so_new(16, 22, 0);
d311 1
a311 1
	 * 	- light_twoside
a316 3
	so_method(so, tesla, NV50TCL_SCISSOR_ENABLE(0), 1);
	so_data  (so, cso->scissor);

d348 7
a354 2
        so_data(so, nvgl_polygon_mode(cso->fill_front));
        so_data(so, nvgl_polygon_mode(cso->fill_back));
d358 2
a359 2
	so_data  (so, cso->cull_face != PIPE_FACE_NONE);
	if (cso->front_ccw) {
d361 15
a375 2
        }
        else {
d377 14
a390 14
        }
	switch (cso->cull_face) {
	case PIPE_FACE_FRONT:
		so_data(so, NV50TCL_CULL_FACE_FRONT);
		break;
	case PIPE_FACE_BACK:
		so_data(so, NV50TCL_CULL_FACE_BACK);
		break;
	case PIPE_FACE_FRONT_AND_BACK:
		so_data(so, NV50TCL_CULL_FACE_FRONT_AND_BACK);
		break;
	default:
		so_data(so, NV50TCL_CULL_FACE_BACK);
		break;
d397 17
a413 7
        so_data(so, cso->offset_point);
        so_data(so, cso->offset_line);
        so_data(so, cso->offset_tri);

	if (cso->offset_point ||
            cso->offset_line ||
            cso->offset_tri) {
d537 1
d569 1
d601 1
d610 1
a610 1
	nv50->geomprog = hwcso;
a648 10
	struct nv50_context *nv50 = nv50_context(pipe);

	nv50->clip.depth_clamp = clip->depth_clamp;
	nv50->dirty |= NV50_NEW_CLIP;
}

static void
nv50_set_sample_mask(struct pipe_context *pipe,
		     unsigned sample_mask)
{
d653 1
a653 1
			 struct pipe_resource *buf )
d724 2
a725 2
nv50_set_index_buffer(struct pipe_context *pipe,
		      const struct pipe_index_buffer *ib)
d729 2
a730 14
	if (ib)
		memcpy(&nv50->idxbuf, ib, sizeof(nv50->idxbuf));
	else
		memset(&nv50->idxbuf, 0, sizeof(nv50->idxbuf));

	/* TODO make this more like a state */
}

static void *
nv50_vtxelts_state_create(struct pipe_context *pipe,
			  unsigned num_elements,
			  const struct pipe_vertex_element *elements)
{
	struct nv50_vtxelt_stateobj *cso = CALLOC_STRUCT(nv50_vtxelt_stateobj);
a731 21
	assert(num_elements < 16); /* not doing fallbacks yet */
	cso->num_elements = num_elements;
	memcpy(cso->pipe, elements, num_elements * sizeof(*elements));

	nv50_vtxelt_construct(cso);

	return (void *)cso;
}

static void
nv50_vtxelts_state_delete(struct pipe_context *pipe, void *hwcso)
{
	FREE(hwcso);
}

static void
nv50_vtxelts_state_bind(struct pipe_context *pipe, void *hwcso)
{
	struct nv50_context *nv50 = nv50_context(pipe);

	nv50->vtxelt = hwcso;
d746 2
a747 4
	nv50->pipe.set_fragment_sampler_views = nv50_set_fp_sampler_views;
	nv50->pipe.set_vertex_sampler_views   = nv50_set_vp_sampler_views;
	nv50->pipe.create_sampler_view = nv50_create_sampler_view;
	nv50->pipe.sampler_view_destroy = nv50_sampler_view_destroy;
a774 1
	nv50->pipe.set_sample_mask = nv50_set_sample_mask;
a780 4
	nv50->pipe.create_vertex_elements_state = nv50_vtxelts_state_create;
	nv50->pipe.delete_vertex_elements_state = nv50_vtxelts_state_delete;
	nv50->pipe.bind_vertex_elements_state = nv50_vtxelts_state_bind;

d782 1
a782 1
	nv50->pipe.set_index_buffer = nv50_set_index_buffer;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d2 1
a2 1
 * Copyright 2010 Christoph Bumiller
d17 4
a20 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d23 1
a24 1
#include "util/u_helpers.h"
a25 2
#include "util/u_transfer.h"
#include "util/u_format_srgb.h"
a28 1
#include "nv50_stateobj.h"
d30 1
d32 1
a32 34
#include "nv50_3d.xml.h"
#include "nv50_texture.xml.h"

#include "nouveau/nouveau_gldefs.h"

/* Caveats:
 *  ! pipe_sampler_state.normalized_coords is ignored - rectangle textures will
 *     use non-normalized coordinates, everything else won't
 *    (The relevant bit is in the TIC entry and not the TSC entry.)
 *
 *  ! pipe_sampler_state.seamless_cube_map is ignored - seamless filtering is
 *     always activated on NVA0 +
 *    (Give me the global bit, otherwise it's not worth the CPU work.)
 *
 *  ! pipe_sampler_state.border_color is not swizzled according to the texture
 *     swizzle in pipe_sampler_view
 *    (This will be ugly with indirect independent texture/sampler access,
 *     we'd have to emulate the logic in the shader. GL doesn't have that,
 *     D3D doesn't have swizzle, if we knew what we were implementing we'd be
 *     good.)
 *
 *  ! pipe_rasterizer_state.line_last_pixel is ignored - it is never drawn
 *
 *  ! pipe_rasterizer_state.flatshade_first also applies to QUADS
 *    (There's a GL query for that, forcing an exception is just ridiculous.)
 *
 *  ! pipe_rasterizer_state.half_pixel_center is ignored - pixel centers
 *     are always at half integer coordinates and the top-left rule applies
 *    (There does not seem to be a hardware switch for this.)
 *
 *  ! pipe_rasterizer_state.sprite_coord_enable is masked with 0xff on NVC0
 *    (The hardware only has 8 slots meant for TexCoord and we have to assign
 *     in advance to maintain elegant separate shader objects.)
 */
d37 1
a37 1
   uint32_t ret = 0;
d39 8
a46 8
   if (mask & PIPE_MASK_R)
      ret |= 0x0001;
   if (mask & PIPE_MASK_G)
      ret |= 0x0010;
   if (mask & PIPE_MASK_B)
      ret |= 0x0100;
   if (mask & PIPE_MASK_A)
      ret |= 0x1000;
d48 1
a48 1
   return ret;
a50 3
#define NV50_BLEND_FACTOR_CASE(a, b) \
   case PIPE_BLENDFACTOR_##a: return NV50_3D_BLEND_FACTOR_##b

d52 1
a52 1
nv50_blend_fac(unsigned factor)
d54 42
a95 23
   switch (factor) {
   NV50_BLEND_FACTOR_CASE(ONE, ONE);
   NV50_BLEND_FACTOR_CASE(SRC_COLOR, SRC_COLOR);
   NV50_BLEND_FACTOR_CASE(SRC_ALPHA, SRC_ALPHA);
   NV50_BLEND_FACTOR_CASE(DST_ALPHA, DST_ALPHA);
   NV50_BLEND_FACTOR_CASE(DST_COLOR, DST_COLOR);
   NV50_BLEND_FACTOR_CASE(SRC_ALPHA_SATURATE, SRC_ALPHA_SATURATE);
   NV50_BLEND_FACTOR_CASE(CONST_COLOR, CONSTANT_COLOR);
   NV50_BLEND_FACTOR_CASE(CONST_ALPHA, CONSTANT_ALPHA);
   NV50_BLEND_FACTOR_CASE(SRC1_COLOR, SRC1_COLOR);
   NV50_BLEND_FACTOR_CASE(SRC1_ALPHA, SRC1_ALPHA);
   NV50_BLEND_FACTOR_CASE(ZERO, ZERO);
   NV50_BLEND_FACTOR_CASE(INV_SRC_COLOR, ONE_MINUS_SRC_COLOR);
   NV50_BLEND_FACTOR_CASE(INV_SRC_ALPHA, ONE_MINUS_SRC_ALPHA);
   NV50_BLEND_FACTOR_CASE(INV_DST_ALPHA, ONE_MINUS_DST_ALPHA);
   NV50_BLEND_FACTOR_CASE(INV_DST_COLOR, ONE_MINUS_DST_COLOR);
   NV50_BLEND_FACTOR_CASE(INV_CONST_COLOR, ONE_MINUS_CONSTANT_COLOR);
   NV50_BLEND_FACTOR_CASE(INV_CONST_ALPHA, ONE_MINUS_CONSTANT_ALPHA);
   NV50_BLEND_FACTOR_CASE(INV_SRC1_COLOR, ONE_MINUS_SRC1_COLOR);
   NV50_BLEND_FACTOR_CASE(INV_SRC1_ALPHA, ONE_MINUS_SRC1_ALPHA);
   default:
      return NV50_3D_BLEND_FACTOR_ZERO;
   }
d100 1
a100 1
                        const struct pipe_blend_state *cso)
d102 59
a160 86
   struct nv50_blend_stateobj *so = CALLOC_STRUCT(nv50_blend_stateobj);
   int i;
   boolean emit_common_func = cso->rt[0].blend_enable;
   uint32_t ms;

   if (nv50_context(pipe)->screen->tesla->oclass >= NVA3_3D_CLASS) {
      SB_BEGIN_3D(so, BLEND_INDEPENDENT, 1);
      SB_DATA    (so, cso->independent_blend_enable);
   }

   so->pipe = *cso;

   SB_BEGIN_3D(so, COLOR_MASK_COMMON, 1);
   SB_DATA    (so, !cso->independent_blend_enable);

   SB_BEGIN_3D(so, BLEND_ENABLE_COMMON, 1);
   SB_DATA    (so, !cso->independent_blend_enable);

   if (cso->independent_blend_enable) {
      SB_BEGIN_3D(so, BLEND_ENABLE(0), 8);
      for (i = 0; i < 8; ++i) {
         SB_DATA(so, cso->rt[i].blend_enable);
         if (cso->rt[i].blend_enable)
            emit_common_func = TRUE;
      }

      if (nv50_context(pipe)->screen->tesla->oclass >= NVA3_3D_CLASS) {
         emit_common_func = FALSE;

         for (i = 0; i < 8; ++i) {
            if (!cso->rt[i].blend_enable)
               continue;
            SB_BEGIN_3D_(so, NVA3_3D_IBLEND_EQUATION_RGB(i), 6);
            SB_DATA     (so, nvgl_blend_eqn(cso->rt[i].rgb_func));
            SB_DATA     (so, nv50_blend_fac(cso->rt[i].rgb_src_factor));
            SB_DATA     (so, nv50_blend_fac(cso->rt[i].rgb_dst_factor));
            SB_DATA     (so, nvgl_blend_eqn(cso->rt[i].alpha_func));
            SB_DATA     (so, nv50_blend_fac(cso->rt[i].alpha_src_factor));
            SB_DATA     (so, nv50_blend_fac(cso->rt[i].alpha_dst_factor));
         }
      }
   } else {
      SB_BEGIN_3D(so, BLEND_ENABLE(0), 1);
      SB_DATA    (so, cso->rt[0].blend_enable);
   }

   if (emit_common_func) {
      SB_BEGIN_3D(so, BLEND_EQUATION_RGB, 5);
      SB_DATA    (so, nvgl_blend_eqn(cso->rt[0].rgb_func));
      SB_DATA    (so, nv50_blend_fac(cso->rt[0].rgb_src_factor));
      SB_DATA    (so, nv50_blend_fac(cso->rt[0].rgb_dst_factor));
      SB_DATA    (so, nvgl_blend_eqn(cso->rt[0].alpha_func));
      SB_DATA    (so, nv50_blend_fac(cso->rt[0].alpha_src_factor));
      SB_BEGIN_3D(so, BLEND_FUNC_DST_ALPHA, 1);
      SB_DATA    (so, nv50_blend_fac(cso->rt[0].alpha_dst_factor));
   }

   if (cso->logicop_enable) {
      SB_BEGIN_3D(so, LOGIC_OP_ENABLE, 2);
      SB_DATA    (so, 1);
      SB_DATA    (so, nvgl_logicop_func(cso->logicop_func));
   } else {
      SB_BEGIN_3D(so, LOGIC_OP_ENABLE, 1);
      SB_DATA    (so, 0);
   }

   if (cso->independent_blend_enable) {
      SB_BEGIN_3D(so, COLOR_MASK(0), 8);
      for (i = 0; i < 8; ++i)
         SB_DATA(so, nv50_colormask(cso->rt[i].colormask));
   } else {
      SB_BEGIN_3D(so, COLOR_MASK(0), 1);
      SB_DATA    (so, nv50_colormask(cso->rt[0].colormask));
   }

   ms = 0;
   if (cso->alpha_to_coverage)
      ms |= NV50_3D_MULTISAMPLE_CTRL_ALPHA_TO_COVERAGE;
   if (cso->alpha_to_one)
      ms |= NV50_3D_MULTISAMPLE_CTRL_ALPHA_TO_ONE;

   SB_BEGIN_3D(so, MULTISAMPLE_CTRL, 1);
   SB_DATA    (so, ms);

   assert(so->size <= (sizeof(so->state) / sizeof(so->state[0])));
   return so;
d166 1
a166 1
   struct nv50_context *nv50 = nv50_context(pipe);
d168 2
a169 2
   nv50->blend = hwcso;
   nv50->dirty |= NV50_NEW_BLEND;
d175 4
a178 1
   FREE(hwcso);
d181 2
a182 4
/* NOTE: ignoring line_last_pixel, using FALSE (set on screen init) */
static void *
nv50_rasterizer_state_create(struct pipe_context *pipe,
                             const struct pipe_rasterizer_state *cso)
d184 21
a204 107
   struct nv50_rasterizer_stateobj *so;
   uint32_t reg;

   so = CALLOC_STRUCT(nv50_rasterizer_stateobj);
   if (!so)
      return NULL;
   so->pipe = *cso;

#ifndef NV50_SCISSORS_CLIPPING
   SB_BEGIN_3D(so, SCISSOR_ENABLE(0), 1);
   SB_DATA    (so, cso->scissor);
#endif
    
   SB_BEGIN_3D(so, SHADE_MODEL, 1);
   SB_DATA    (so, cso->flatshade ? NV50_3D_SHADE_MODEL_FLAT :
                                    NV50_3D_SHADE_MODEL_SMOOTH);
   SB_BEGIN_3D(so, PROVOKING_VERTEX_LAST, 1);
   SB_DATA    (so, !cso->flatshade_first);
   SB_BEGIN_3D(so, VERTEX_TWO_SIDE_ENABLE, 1);
   SB_DATA    (so, cso->light_twoside);

   SB_BEGIN_3D(so, FRAG_COLOR_CLAMP_EN, 1);
   SB_DATA    (so, cso->clamp_fragment_color ? 0x11111111 : 0x00000000);

   SB_BEGIN_3D(so, MULTISAMPLE_ENABLE, 1);
   SB_DATA    (so, cso->multisample);

   SB_BEGIN_3D(so, LINE_WIDTH, 1);
   SB_DATA    (so, fui(cso->line_width));
   SB_BEGIN_3D(so, LINE_SMOOTH_ENABLE, 1);
   SB_DATA    (so, cso->line_smooth);

   SB_BEGIN_3D(so, LINE_STIPPLE_ENABLE, 1);
   if (cso->line_stipple_enable) {
      SB_DATA    (so, 1);
      SB_BEGIN_3D(so, LINE_STIPPLE, 1);
      SB_DATA    (so, (cso->line_stipple_pattern << 8) |
                  cso->line_stipple_factor);
   } else {
      SB_DATA    (so, 0);
   }

   if (!cso->point_size_per_vertex) {
      SB_BEGIN_3D(so, POINT_SIZE, 1);
      SB_DATA    (so, fui(cso->point_size));
   }
   SB_BEGIN_3D(so, POINT_SPRITE_ENABLE, 1);
   SB_DATA    (so, cso->point_quad_rasterization);
   SB_BEGIN_3D(so, POINT_SMOOTH_ENABLE, 1);
   SB_DATA    (so, cso->point_smooth);

   SB_BEGIN_3D(so, POLYGON_MODE_FRONT, 3);
   SB_DATA    (so, nvgl_polygon_mode(cso->fill_front));
   SB_DATA    (so, nvgl_polygon_mode(cso->fill_back));
   SB_DATA    (so, cso->poly_smooth);

   SB_BEGIN_3D(so, CULL_FACE_ENABLE, 3);
   SB_DATA    (so, cso->cull_face != PIPE_FACE_NONE);
   SB_DATA    (so, cso->front_ccw ? NV50_3D_FRONT_FACE_CCW :
                                    NV50_3D_FRONT_FACE_CW);
   switch (cso->cull_face) {
   case PIPE_FACE_FRONT_AND_BACK:
      SB_DATA(so, NV50_3D_CULL_FACE_FRONT_AND_BACK);
      break;
   case PIPE_FACE_FRONT:
      SB_DATA(so, NV50_3D_CULL_FACE_FRONT);
      break;
   case PIPE_FACE_BACK:
   default:
     SB_DATA(so, NV50_3D_CULL_FACE_BACK);
     break;
   }

   SB_BEGIN_3D(so, POLYGON_STIPPLE_ENABLE, 1);
   SB_DATA    (so, cso->poly_stipple_enable);
   SB_BEGIN_3D(so, POLYGON_OFFSET_POINT_ENABLE, 3);
   SB_DATA    (so, cso->offset_point);
   SB_DATA    (so, cso->offset_line);
   SB_DATA    (so, cso->offset_tri);

   if (cso->offset_point || cso->offset_line || cso->offset_tri) {
      SB_BEGIN_3D(so, POLYGON_OFFSET_FACTOR, 1);
      SB_DATA    (so, fui(cso->offset_scale));
      SB_BEGIN_3D(so, POLYGON_OFFSET_UNITS, 1);
      SB_DATA    (so, fui(cso->offset_units * 2.0f));
      SB_BEGIN_3D(so, POLYGON_OFFSET_CLAMP, 1);
      SB_DATA    (so, fui(cso->offset_clamp));
   }

   if (cso->depth_clip) {
      reg = 0;
   } else {
      reg =
         NV50_3D_VIEW_VOLUME_CLIP_CTRL_DEPTH_CLAMP_NEAR |
         NV50_3D_VIEW_VOLUME_CLIP_CTRL_DEPTH_CLAMP_FAR |
         NV50_3D_VIEW_VOLUME_CLIP_CTRL_UNK12_UNK1;
   }
#ifndef NV50_SCISSORS_CLIPPING
   reg |=
      NV50_3D_VIEW_VOLUME_CLIP_CTRL_UNK7 |
      NV50_3D_VIEW_VOLUME_CLIP_CTRL_UNK12_UNK1;
#endif
   SB_BEGIN_3D(so, VIEW_VOLUME_CLIP_CTRL, 1);
   SB_DATA    (so, reg);

   assert(so->size <= (sizeof(so->state) / sizeof(so->state[0])));
   return (void *)so;
d206 3
a208 3

static void
nv50_rasterizer_state_bind(struct pipe_context *pipe, void *hwcso)
d210 73
a282 1
   struct nv50_context *nv50 = nv50_context(pipe);
d284 2
a285 2
   nv50->rast = hwcso;
   nv50->dirty |= NV50_NEW_RASTERIZER;
d288 6
a293 2
static void
nv50_rasterizer_state_delete(struct pipe_context *pipe, void *hwcso)
d295 1
a295 2
   FREE(hwcso);
}
d297 1
a297 5
static void *
nv50_zsa_state_create(struct pipe_context *pipe,
                      const struct pipe_depth_stencil_alpha_state *cso)
{
   struct nv50_zsa_stateobj *so = CALLOC_STRUCT(nv50_zsa_stateobj);
d299 2
a300 65
   so->pipe = *cso;

   SB_BEGIN_3D(so, DEPTH_WRITE_ENABLE, 1);
   SB_DATA    (so, cso->depth.writemask);
   SB_BEGIN_3D(so, DEPTH_TEST_ENABLE, 1);
   if (cso->depth.enabled) {
      SB_DATA    (so, 1);
      SB_BEGIN_3D(so, DEPTH_TEST_FUNC, 1);
      SB_DATA    (so, nvgl_comparison_op(cso->depth.func));
   } else {
      SB_DATA    (so, 0);
   }

   if (cso->stencil[0].enabled) {
      SB_BEGIN_3D(so, STENCIL_ENABLE, 5);
      SB_DATA    (so, 1);
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[0].fail_op));
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[0].zfail_op));
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[0].zpass_op));
      SB_DATA    (so, nvgl_comparison_op(cso->stencil[0].func));
      SB_BEGIN_3D(so, STENCIL_FRONT_MASK, 2);
      SB_DATA    (so, cso->stencil[0].writemask);
      SB_DATA    (so, cso->stencil[0].valuemask);
   } else {
      SB_BEGIN_3D(so, STENCIL_ENABLE, 1);
      SB_DATA    (so, 0);
   }

   if (cso->stencil[1].enabled) {
      assert(cso->stencil[0].enabled);
      SB_BEGIN_3D(so, STENCIL_TWO_SIDE_ENABLE, 5);
      SB_DATA    (so, 1);
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[1].fail_op));
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[1].zfail_op));
      SB_DATA    (so, nvgl_stencil_op(cso->stencil[1].zpass_op));
      SB_DATA    (so, nvgl_comparison_op(cso->stencil[1].func));
      SB_BEGIN_3D(so, STENCIL_BACK_MASK, 2);
      SB_DATA    (so, cso->stencil[1].writemask);
      SB_DATA    (so, cso->stencil[1].valuemask);
   } else {
      SB_BEGIN_3D(so, STENCIL_TWO_SIDE_ENABLE, 1);
      SB_DATA    (so, 0);
   }
    
   SB_BEGIN_3D(so, ALPHA_TEST_ENABLE, 1);
   if (cso->alpha.enabled) {
      SB_DATA    (so, 1);
      SB_BEGIN_3D(so, ALPHA_TEST_REF, 2);
      SB_DATA    (so, fui(cso->alpha.ref_value));
      SB_DATA    (so, nvgl_comparison_op(cso->alpha.func));
   } else {
      SB_DATA    (so, 0);
   }

   assert(so->size <= (sizeof(so->state) / sizeof(so->state[0])));
   return (void *)so;
}

static void
nv50_zsa_state_bind(struct pipe_context *pipe, void *hwcso)
{
   struct nv50_context *nv50 = nv50_context(pipe);

   nv50->zsa = hwcso;
   nv50->dirty |= NV50_NEW_ZSA;
d304 1
a304 1
nv50_zsa_state_delete(struct pipe_context *pipe, void *hwcso)
d306 1
a306 1
   FREE(hwcso);
d309 2
a310 8
/* ====================== SAMPLERS AND TEXTURES ================================
 */

#define NV50_TSC_WRAP_CASE(n) \
    case PIPE_TEX_WRAP_##n: return NV50_TSC_WRAP_##n

static INLINE unsigned
nv50_tsc_wrap_mode(unsigned wrap)
d312 1
a312 111
   switch (wrap) {
   NV50_TSC_WRAP_CASE(REPEAT);
   NV50_TSC_WRAP_CASE(MIRROR_REPEAT);
   NV50_TSC_WRAP_CASE(CLAMP_TO_EDGE);
   NV50_TSC_WRAP_CASE(CLAMP_TO_BORDER);
   NV50_TSC_WRAP_CASE(CLAMP);
   NV50_TSC_WRAP_CASE(MIRROR_CLAMP_TO_EDGE);
   NV50_TSC_WRAP_CASE(MIRROR_CLAMP_TO_BORDER);
   NV50_TSC_WRAP_CASE(MIRROR_CLAMP);
   default:
       NOUVEAU_ERR("unknown wrap mode: %d\n", wrap);
       return NV50_TSC_WRAP_REPEAT;
   }
}

void *
nv50_sampler_state_create(struct pipe_context *pipe,
                          const struct pipe_sampler_state *cso)
{
   struct nv50_tsc_entry *so = MALLOC_STRUCT(nv50_tsc_entry);
   float f[2];

   so->id = -1;

   so->tsc[0] = (0x00026000 |
                 (nv50_tsc_wrap_mode(cso->wrap_s) << 0) |
                 (nv50_tsc_wrap_mode(cso->wrap_t) << 3) |
                 (nv50_tsc_wrap_mode(cso->wrap_r) << 6));

   switch (cso->mag_img_filter) {
   case PIPE_TEX_FILTER_LINEAR:
      so->tsc[1] = NV50_TSC_1_MAGF_LINEAR;
      break;
   case PIPE_TEX_FILTER_NEAREST:
   default:
      so->tsc[1] = NV50_TSC_1_MAGF_NEAREST;
      break;
   }

   switch (cso->min_img_filter) {
   case PIPE_TEX_FILTER_LINEAR:
      so->tsc[1] |= NV50_TSC_1_MINF_LINEAR;
      break;
   case PIPE_TEX_FILTER_NEAREST:
   default:
      so->tsc[1] |= NV50_TSC_1_MINF_NEAREST;
      break;
   }

   switch (cso->min_mip_filter) {
   case PIPE_TEX_MIPFILTER_LINEAR:
      so->tsc[1] |= NV50_TSC_1_MIPF_LINEAR;
      break;
   case PIPE_TEX_MIPFILTER_NEAREST:
      so->tsc[1] |= NV50_TSC_1_MIPF_NEAREST;
      break;
   case PIPE_TEX_MIPFILTER_NONE:
   default:
      so->tsc[1] |= NV50_TSC_1_MIPF_NONE;
      break;
   }

   if (nouveau_screen(pipe->screen)->class_3d >= NVE4_3D_CLASS) {
      if (cso->seamless_cube_map)
         so->tsc[1] |= NVE4_TSC_1_CUBE_SEAMLESS;
      if (!cso->normalized_coords)
         so->tsc[1] |= NVE4_TSC_1_FORCE_NONNORMALIZED_COORDS;
   }

   if (cso->max_anisotropy >= 16)
      so->tsc[0] |= (7 << 20);
   else
   if (cso->max_anisotropy >= 12)
      so->tsc[0] |= (6 << 20);
   else {
      so->tsc[0] |= (cso->max_anisotropy >> 1) << 20;

      if (cso->max_anisotropy >= 4)
         so->tsc[1] |= NV50_TSC_1_UNKN_ANISO_35;
      else
      if (cso->max_anisotropy >= 2)
         so->tsc[1] |= NV50_TSC_1_UNKN_ANISO_15;
   }

   if (cso->compare_mode == PIPE_TEX_COMPARE_R_TO_TEXTURE) {
      /* NOTE: must be deactivated for non-shadow textures */
      so->tsc[0] |= (1 << 9);
      so->tsc[0] |= (nvgl_comparison_op(cso->compare_func) & 0x7) << 10;
   }

   f[0] = CLAMP(cso->lod_bias, -16.0f, 15.0f);
   so->tsc[1] |= ((int)(f[0] * 256.0f) & 0x1fff) << 12;

   f[0] = CLAMP(cso->min_lod, 0.0f, 15.0f);
   f[1] = CLAMP(cso->max_lod, 0.0f, 15.0f);
   so->tsc[2] =
      (((int)(f[1] * 256.0f) & 0xfff) << 12) | ((int)(f[0] * 256.0f) & 0xfff);

   so->tsc[2] |=
      util_format_linear_float_to_srgb_8unorm(cso->border_color.f[0]) << 24;
   so->tsc[3] =
      util_format_linear_float_to_srgb_8unorm(cso->border_color.f[1]) << 12;
   so->tsc[3] |=
      util_format_linear_float_to_srgb_8unorm(cso->border_color.f[2]) << 20;

   so->tsc[4] = fui(cso->border_color.f[0]);
   so->tsc[5] = fui(cso->border_color.f[1]);
   so->tsc[6] = fui(cso->border_color.f[2]);
   so->tsc[7] = fui(cso->border_color.f[3]);

   return (void *)so;
d318 1
a318 10
   unsigned s, i;

   for (s = 0; s < 3; ++s)
      for (i = 0; i < nv50_context(pipe)->num_samplers[s]; ++i)
         if (nv50_context(pipe)->samplers[s][i] == hwcso)
            nv50_context(pipe)->samplers[s][i] = NULL;

   nv50_screen_tsc_free(nv50_context(pipe)->screen, nv50_tsc_entry(hwcso));

   FREE(hwcso);
d322 3
a324 2
nv50_stage_sampler_states_bind(struct nv50_context *nv50, int s,
                               unsigned nr, void **hwcso)
d326 2
a327 4
   unsigned i;

   for (i = 0; i < nr; ++i) {
      struct nv50_tsc_entry *old = nv50->samplers[s][i];
d329 3
a331 7
      nv50->samplers[s][i] = nv50_tsc_entry(hwcso[i]);
      if (old)
         nv50_screen_tsc_unlock(nv50->screen, old);
   }
   for (; i < nv50->num_samplers[s]; ++i)
      if (nv50->samplers[s][i])
         nv50_screen_tsc_unlock(nv50->screen, nv50->samplers[s][i]);
d333 2
a334 1
   nv50->num_samplers[s] = nr;
d336 2
a337 1
   nv50->dirty |= NV50_NEW_SAMPLERS;
d341 3
a343 1
nv50_vp_sampler_states_bind(struct pipe_context *pipe, unsigned nr, void **s)
d345 1
a345 1
   nv50_stage_sampler_states_bind(nv50_context(pipe), 0, nr, s);
d349 3
a351 1
nv50_fp_sampler_states_bind(struct pipe_context *pipe, unsigned nr, void **s)
d353 1
a353 1
   nv50_stage_sampler_states_bind(nv50_context(pipe), 2, nr, s);
d357 2
a358 1
nv50_gp_sampler_states_bind(struct pipe_context *pipe, unsigned nr, void **s)
d360 2
a361 1
   nv50_stage_sampler_states_bind(nv50_context(pipe), 1, nr, s);
d364 19
a382 6
/* NOTE: only called when not referenced anywhere, won't be bound */
static void
nv50_sampler_view_destroy(struct pipe_context *pipe,
                          struct pipe_sampler_view *view)
{
   pipe_resource_reference(&view->texture, NULL);
a383 1
   nv50_screen_tic_free(nv50_context(pipe)->screen, nv50_tic_entry(view));
d385 98
a482 1
   FREE(nv50_tic_entry(view));
d485 2
a486 4
static INLINE void
nv50_stage_set_sampler_views(struct nv50_context *nv50, int s,
                             unsigned nr,
                             struct pipe_sampler_view **views)
d488 1
a488 6
   unsigned i;

   for (i = 0; i < nr; ++i) {
      struct nv50_tic_entry *old = nv50_tic_entry(nv50->textures[s][i]);
      if (old)
         nv50_screen_tic_unlock(nv50->screen, old);
d490 2
a491 17
      pipe_sampler_view_reference(&nv50->textures[s][i], views[i]);
   }

   for (i = nr; i < nv50->num_textures[s]; ++i) {
      struct nv50_tic_entry *old = nv50_tic_entry(nv50->textures[s][i]);
      if (!old)
         continue;
      nv50_screen_tic_unlock(nv50->screen, old);

      pipe_sampler_view_reference(&nv50->textures[s][i], NULL);
   }

   nv50->num_textures[s] = nr;

   nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_TEXTURES);

   nv50->dirty |= NV50_NEW_TEXTURES;
d495 1
a495 3
nv50_vp_set_sampler_views(struct pipe_context *pipe,
                          unsigned nr,
                          struct pipe_sampler_view **views)
d497 4
a500 1
   nv50_stage_set_sampler_views(nv50_context(pipe), 0, nr, views);
d503 3
a505 4
static void
nv50_fp_set_sampler_views(struct pipe_context *pipe,
                          unsigned nr,
                          struct pipe_sampler_view **views)
d507 70
a576 1
   nv50_stage_set_sampler_views(nv50_context(pipe), 2, nr, views);
d580 1
a580 3
nv50_gp_set_sampler_views(struct pipe_context *pipe,
                          unsigned nr,
                          struct pipe_sampler_view **views)
d582 4
a585 1
   nv50_stage_set_sampler_views(nv50_context(pipe), 1, nr, views);
a587 3
/* ============================= SHADERS =======================================
 */

d589 2
a590 2
nv50_sp_state_create(struct pipe_context *pipe,
                     const struct pipe_shader_state *cso, unsigned type)
d592 1
a592 1
   struct nv50_program *prog;
d594 4
a597 3
   prog = CALLOC_STRUCT(nv50_program);
   if (!prog)
      return NULL;
d599 4
a602 2
   prog->type = type;
   prog->pipe.tokens = tgsi_dup_tokens(cso->tokens);
d604 2
a605 4
   if (cso->stream_output.num_outputs)
      prog->pipe.stream_output = cso->stream_output;

   return (void *)prog;
d609 1
a609 1
nv50_sp_state_delete(struct pipe_context *pipe, void *hwcso)
d611 2
a612 3
   struct nv50_program *prog = (struct nv50_program *)hwcso;

   nv50_program_destroy(nv50_context(pipe), prog);
d614 3
a616 2
   FREE((void *)prog->pipe.tokens);
   FREE(prog);
d620 2
a621 2
nv50_vp_state_create(struct pipe_context *pipe,
                     const struct pipe_shader_state *cso)
d623 5
a627 1
   return nv50_sp_state_create(pipe, cso, PIPE_SHADER_VERTEX);
d631 1
a631 1
nv50_vp_state_bind(struct pipe_context *pipe, void *hwcso)
d633 1
a633 1
    struct nv50_context *nv50 = nv50_context(pipe);
d635 2
a636 9
    nv50->vertprog = hwcso;
    nv50->dirty |= NV50_NEW_VERTPROG;
}

static void *
nv50_fp_state_create(struct pipe_context *pipe,
                     const struct pipe_shader_state *cso)
{
   return nv50_sp_state_create(pipe, cso, PIPE_SHADER_FRAGMENT);
d640 1
a640 1
nv50_fp_state_bind(struct pipe_context *pipe, void *hwcso)
d642 2
a643 1
    struct nv50_context *nv50 = nv50_context(pipe);
d645 3
a647 2
    nv50->fragprog = hwcso;
    nv50->dirty |= NV50_NEW_FRAGPROG;
d652 1
a652 1
                     const struct pipe_shader_state *cso)
d654 5
a658 1
   return nv50_sp_state_create(pipe, cso, PIPE_SHADER_GEOMETRY);
d664 1
a664 1
    struct nv50_context *nv50 = nv50_context(pipe);
d666 2
a667 2
    nv50->gmtyprog = hwcso;
    nv50->dirty |= NV50_NEW_GMTYPROG;
d671 1
a671 2
nv50_set_constant_buffer(struct pipe_context *pipe, uint shader, uint index,
                         struct pipe_constant_buffer *cb)
d673 2
a674 30
   struct nv50_context *nv50 = nv50_context(pipe);
   struct pipe_resource *res = cb ? cb->buffer : NULL;
   const unsigned s = nv50_context_shader_stage(shader);
   const unsigned i = index;

   if (shader == PIPE_SHADER_COMPUTE)
      return;

   if (nv50->constbuf[s][i].user)
      nv50->constbuf[s][i].u.buf = NULL;
   else
   if (nv50->constbuf[s][i].u.buf)
      nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_CB(s, i));

   pipe_resource_reference(&nv50->constbuf[s][i].u.buf, res);

   nv50->constbuf[s][i].user = (cb && cb->user_buffer) ? TRUE : FALSE;
   if (nv50->constbuf[s][i].user) {
      nv50->constbuf[s][i].u.data = cb->user_buffer;
      nv50->constbuf[s][i].size = cb->buffer_size;
      nv50->constbuf_valid[s] |= 1 << i;
   } else
   if (res) {
      nv50->constbuf[s][i].offset = cb->buffer_offset;
      nv50->constbuf[s][i].size = align(cb->buffer_size, 0x100);
      nv50->constbuf_valid[s] |= 1 << i;
   } else {
      nv50->constbuf_valid[s] &= ~(1 << i);
   }
   nv50->constbuf_dirty[s] |= 1 << i;
d676 3
a678 1
   nv50->dirty |= NV50_NEW_CONSTBUF;
a680 3
/* =============================================================================
 */

d683 1
a683 1
                     const struct pipe_blend_color *bcol)
d685 1
a685 1
   struct nv50_context *nv50 = nv50_context(pipe);
d687 2
a688 2
   nv50->blend_colour = *bcol;
   nv50->dirty |= NV50_NEW_BLEND_COLOUR;
d691 1
a691 1
static void
d693 1
a693 1
                     const struct pipe_stencil_ref *sr)
d695 1
a695 1
   struct nv50_context *nv50 = nv50_context(pipe);
d697 2
a698 2
   nv50->stencil_ref = *sr;
   nv50->dirty |= NV50_NEW_STENCIL_REF;
d703 1
a703 1
                    const struct pipe_clip_state *clip)
d705 1
a705 1
   struct nv50_context *nv50 = nv50_context(pipe);
d707 3
a709 1
   memcpy(nv50->clip.ucp, clip->ucp, sizeof(clip->ucp));
d711 4
a714 1
   nv50->dirty |= NV50_NEW_CLIP;
d718 2
a719 1
nv50_set_sample_mask(struct pipe_context *pipe, unsigned sample_mask)
d721 1
a721 1
   struct nv50_context *nv50 = nv50_context(pipe);
d723 12
a734 2
   nv50->sample_mask = sample_mask;
   nv50->dirty |= NV50_NEW_SAMPLE_MASK;
a736 1

d739 1
a739 1
                           const struct pipe_framebuffer_state *fb)
d741 1
a741 2
   struct nv50_context *nv50 = nv50_context(pipe);
   unsigned i;
d743 3
a745 1
   nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_FB);
d747 5
a751 6
   for (i = 0; i < fb->nr_cbufs; ++i)
      pipe_surface_reference(&nv50->framebuffer.cbufs[i], fb->cbufs[i]);
   for (; i < nv50->framebuffer.nr_cbufs; ++i)
      pipe_surface_reference(&nv50->framebuffer.cbufs[i], NULL);

   nv50->framebuffer.nr_cbufs = fb->nr_cbufs;
d753 2
a754 6
   nv50->framebuffer.width = fb->width;
   nv50->framebuffer.height = fb->height;

   pipe_surface_reference(&nv50->framebuffer.zsbuf, fb->zsbuf);

   nv50->dirty |= NV50_NEW_FRAMEBUFFER;
d758 2
a759 2
nv50_set_polygon_stipple(struct pipe_context *pipe,
                         const struct pipe_poly_stipple *stipple)
d761 1
a761 1
   struct nv50_context *nv50 = nv50_context(pipe);
d763 2
a764 2
   nv50->stipple = *stipple;
   nv50->dirty |= NV50_NEW_STIPPLE;
d768 2
a769 4
nv50_set_scissor_states(struct pipe_context *pipe,
                        unsigned start_slot,
                        unsigned num_scissors,
                        const struct pipe_scissor_state *scissor)
d771 1
a771 1
   struct nv50_context *nv50 = nv50_context(pipe);
d773 2
a774 2
   nv50->scissor = *scissor;
   nv50->dirty |= NV50_NEW_SCISSOR;
d778 2
a779 4
nv50_set_viewport_states(struct pipe_context *pipe,
                         unsigned start_slot,
                         unsigned num_viewports,
                         const struct pipe_viewport_state *vpt)
d781 4
a784 1
   struct nv50_context *nv50 = nv50_context(pipe);
d786 1
a786 2
   nv50->viewport = *vpt;
   nv50->dirty |= NV50_NEW_VIEWPORT;
d790 2
a791 3
nv50_set_vertex_buffers(struct pipe_context *pipe,
                        unsigned start_slot, unsigned count,
                        const struct pipe_vertex_buffer *vb)
d793 1
a793 2
   struct nv50_context *nv50 = nv50_context(pipe);
   unsigned i;
d795 4
a798 2
   util_set_vertex_buffers_count(nv50->vtxbuf, &nv50->num_vtxbufs, vb,
                                 start_slot, count);
d800 2
a801 5
   if (!vb) {
      nv50->vbo_user &= ~(((1ull << count) - 1) << start_slot);
      nv50->vbo_constant &= ~(((1ull << count) - 1) << start_slot);
      return;
   }
d803 6
a808 2
   for (i = 0; i < count; ++i) {
      unsigned dst_index = start_slot + i;
d810 3
a812 11
      if (!vb[i].buffer && vb[i].user_buffer) {
         nv50->vbo_user |= 1 << dst_index;
         if (!vb[i].stride)
            nv50->vbo_constant |= 1 << dst_index;
         else
            nv50->vbo_constant &= ~(1 << dst_index);
      } else {
         nv50->vbo_user &= ~(1 << dst_index);
         nv50->vbo_constant &= ~(1 << dst_index);
      }
   }
d814 1
a814 1
   nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_VERTEX);
d816 1
a816 1
   nv50->dirty |= NV50_NEW_ARRAYS;
d820 1
a820 2
nv50_set_index_buffer(struct pipe_context *pipe,
                      const struct pipe_index_buffer *ib)
d822 2
a823 1
   struct nv50_context *nv50 = nv50_context(pipe);
d825 4
a828 106
   if (nv50->idxbuf.buffer)
      nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_INDEX);

   if (ib) {
      pipe_resource_reference(&nv50->idxbuf.buffer, ib->buffer);
      nv50->idxbuf.index_size = ib->index_size;
      if (ib->buffer) {
         nv50->idxbuf.offset = ib->offset;
         BCTX_REFN(nv50->bufctx_3d, INDEX, nv04_resource(ib->buffer), RD);
      } else {
         nv50->idxbuf.user_buffer = ib->user_buffer;
      }
   } else {
      pipe_resource_reference(&nv50->idxbuf.buffer, NULL);
   }
}

static void
nv50_vertex_state_bind(struct pipe_context *pipe, void *hwcso)
{
   struct nv50_context *nv50 = nv50_context(pipe);

   nv50->vertex = hwcso;
   nv50->dirty |= NV50_NEW_VERTEX;
}

static struct pipe_stream_output_target *
nv50_so_target_create(struct pipe_context *pipe,
                      struct pipe_resource *res,
                      unsigned offset, unsigned size)
{
   struct nv50_so_target *targ = MALLOC_STRUCT(nv50_so_target);
   if (!targ)
      return NULL;

   if (nouveau_context(pipe)->screen->class_3d >= NVA0_3D_CLASS) {
      targ->pq = pipe->create_query(pipe,
                                    NVA0_QUERY_STREAM_OUTPUT_BUFFER_OFFSET);
      if (!targ->pq) {
         FREE(targ);
         return NULL;
      }
   } else {
      targ->pq = NULL;
   }
   targ->clean = TRUE;

   targ->pipe.buffer_size = size;
   targ->pipe.buffer_offset = offset;
   targ->pipe.context = pipe;
   targ->pipe.buffer = NULL;
   pipe_resource_reference(&targ->pipe.buffer, res);
   pipe_reference_init(&targ->pipe.reference, 1);

   return &targ->pipe;
}

static void
nv50_so_target_destroy(struct pipe_context *pipe,
                       struct pipe_stream_output_target *ptarg)
{
   struct nv50_so_target *targ = nv50_so_target(ptarg);
   if (targ->pq)
      pipe->destroy_query(pipe, targ->pq);
   pipe_resource_reference(&targ->pipe.buffer, NULL);
   FREE(targ);
}

static void
nv50_set_stream_output_targets(struct pipe_context *pipe,
                               unsigned num_targets,
                               struct pipe_stream_output_target **targets,
                               unsigned append_mask)
{
   struct nv50_context *nv50 = nv50_context(pipe);
   unsigned i;
   boolean serialize = TRUE;
   const boolean can_resume = nv50->screen->base.class_3d >= NVA0_3D_CLASS;

   assert(num_targets <= 4);

   for (i = 0; i < num_targets; ++i) {
      const boolean changed = nv50->so_target[i] != targets[i];
      if (!changed && (append_mask & (1 << i)))
         continue;
      nv50->so_targets_dirty |= 1 << i;

      if (can_resume && changed && nv50->so_target[i]) {
         nva0_so_target_save_offset(pipe, nv50->so_target[i], i, serialize);
         serialize = FALSE;
      }

      if (targets[i] && !(append_mask & (1 << i)))
         nv50_so_target(targets[i])->clean = TRUE;

      pipe_so_target_reference(&nv50->so_target[i], targets[i]);
   }
   for (; i < nv50->num_so_targets; ++i) {
      if (can_resume && nv50->so_target[i]) {
         nva0_so_target_save_offset(pipe, nv50->so_target[i], i, serialize);
         serialize = FALSE;
      }
      pipe_so_target_reference(&nv50->so_target[i], NULL);
      nv50->so_targets_dirty |= 1 << i;
   }
   nv50->num_so_targets = num_targets;
d830 2
a831 2
   if (nv50->so_targets_dirty)
      nv50->dirty |= NV50_NEW_STRMOUT;
d837 49
a885 1
   struct pipe_context *pipe = &nv50->base.pipe;
d887 2
a888 54
   pipe->create_blend_state = nv50_blend_state_create;
   pipe->bind_blend_state = nv50_blend_state_bind;
   pipe->delete_blend_state = nv50_blend_state_delete;

   pipe->create_rasterizer_state = nv50_rasterizer_state_create;
   pipe->bind_rasterizer_state = nv50_rasterizer_state_bind;
   pipe->delete_rasterizer_state = nv50_rasterizer_state_delete;

   pipe->create_depth_stencil_alpha_state = nv50_zsa_state_create;
   pipe->bind_depth_stencil_alpha_state = nv50_zsa_state_bind;
   pipe->delete_depth_stencil_alpha_state = nv50_zsa_state_delete;

   pipe->create_sampler_state = nv50_sampler_state_create;
   pipe->delete_sampler_state = nv50_sampler_state_delete;
   pipe->bind_vertex_sampler_states   = nv50_vp_sampler_states_bind;
   pipe->bind_fragment_sampler_states = nv50_fp_sampler_states_bind;
   pipe->bind_geometry_sampler_states = nv50_gp_sampler_states_bind;

   pipe->create_sampler_view = nv50_create_sampler_view;
   pipe->sampler_view_destroy = nv50_sampler_view_destroy;
   pipe->set_vertex_sampler_views   = nv50_vp_set_sampler_views;
   pipe->set_fragment_sampler_views = nv50_fp_set_sampler_views;
   pipe->set_geometry_sampler_views = nv50_gp_set_sampler_views;
 
   pipe->create_vs_state = nv50_vp_state_create;
   pipe->create_fs_state = nv50_fp_state_create;
   pipe->create_gs_state = nv50_gp_state_create;
   pipe->bind_vs_state = nv50_vp_state_bind;
   pipe->bind_fs_state = nv50_fp_state_bind;
   pipe->bind_gs_state = nv50_gp_state_bind;
   pipe->delete_vs_state = nv50_sp_state_delete;
   pipe->delete_fs_state = nv50_sp_state_delete;
   pipe->delete_gs_state = nv50_sp_state_delete;

   pipe->set_blend_color = nv50_set_blend_color;
   pipe->set_stencil_ref = nv50_set_stencil_ref;
   pipe->set_clip_state = nv50_set_clip_state;
   pipe->set_sample_mask = nv50_set_sample_mask;
   pipe->set_constant_buffer = nv50_set_constant_buffer;
   pipe->set_framebuffer_state = nv50_set_framebuffer_state;
   pipe->set_polygon_stipple = nv50_set_polygon_stipple;
   pipe->set_scissor_states = nv50_set_scissor_states;
   pipe->set_viewport_states = nv50_set_viewport_states;

   pipe->create_vertex_elements_state = nv50_vertex_state_create;
   pipe->delete_vertex_elements_state = nv50_vertex_state_delete;
   pipe->bind_vertex_elements_state = nv50_vertex_state_bind;

   pipe->set_vertex_buffers = nv50_set_vertex_buffers;
   pipe->set_index_buffer = nv50_set_index_buffer;

   pipe->create_stream_output_target = nv50_so_target_create;
   pipe->stream_output_target_destroy = nv50_so_target_destroy;
   pipe->set_stream_output_targets = nv50_set_stream_output_targets;
d890 1
@


