head	1.3;
access;
symbols
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.07.09.21.08.54;	author jsg;	state dead;
branches;
next	1.2;
commitid	WPD6rgPryPkvXOr9;

1.2
date	2013.09.05.14.00.45;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.11.43;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@
#ifndef __NV50_WINSYS_H__
#define __NV50_WINSYS_H__

#include <stdint.h>
#include <unistd.h>

#include "pipe/p_defines.h"

#include "nouveau/nouveau_winsys.h"
#include "nouveau/nouveau_buffer.h"


#ifndef NV04_PFIFO_MAX_PACKET_LEN
#define NV04_PFIFO_MAX_PACKET_LEN 2047
#endif


static INLINE void
nv50_add_bufctx_resident_bo(struct nouveau_bufctx *bufctx, int bin,
                            unsigned flags, struct nouveau_bo *bo)
{
   nouveau_bufctx_refn(bufctx, bin, bo, flags)->priv = NULL;
}

static INLINE void
nv50_add_bufctx_resident(struct nouveau_bufctx *bufctx, int bin,
                         struct nv04_resource *res, unsigned flags)
{
   struct nouveau_bufref *ref =
      nouveau_bufctx_refn(bufctx, bin, res->bo, flags | res->domain);
   ref->priv = res;
   ref->priv_data = flags;
}

#define BCTX_REFN_bo(ctx, bin, fl, bo) \
   nv50_add_bufctx_resident_bo(ctx, NV50_BIND_##bin, fl, bo);

#define BCTX_REFN(bctx, bin, res, acc) \
   nv50_add_bufctx_resident(bctx, NV50_BIND_##bin, res, NOUVEAU_BO_##acc)

static INLINE void
PUSH_REFN(struct nouveau_pushbuf *push, struct nouveau_bo *bo, uint32_t flags)
{
   struct nouveau_pushbuf_refn ref = { bo, flags };
   nouveau_pushbuf_refn(push, &ref, 1);
}


#define SUBC_3D(m) 3, (m)
#define NV50_3D(n) SUBC_3D(NV50_3D_##n)
#define NVA0_3D(n) SUBC_3D(NVA0_3D_##n)

#define SUBC_2D(m) 4, (m)
#define NV50_2D(n) SUBC_2D(NV50_2D_##n)

#define SUBC_M2MF(m) 5, (m)
#define NV50_M2MF(n) SUBC_M2MF(NV50_M2MF_##n)

#define SUBC_COMPUTE(m) 6, (m)
#define NV50_COMPUTE(n) SUBC_COMPUTE(NV50_COMPUTE_##n)

/* These are expected to be on their own pushbufs */
#define SUBC_BSP(m) 2, (m)
#define SUBC_VP(m) 2, (m)


static INLINE uint32_t
NV50_FIFO_PKHDR(int subc, int mthd, unsigned size)
{
   return 0x00000000 | (size << 18) | (subc << 13) | mthd;
}

static INLINE uint32_t
NV50_FIFO_PKHDR_NI(int subc, int mthd, unsigned size)
{
   return 0x40000000 | (size << 18) | (subc << 13) | mthd;
}

static INLINE uint32_t
NV50_FIFO_PKHDR_L(int subc, int mthd)
{
   return 0x00030000 | (subc << 13) | mthd;
}


static INLINE uint32_t
nouveau_bo_memtype(const struct nouveau_bo *bo)
{
   return bo->config.nv50.memtype;
}


static INLINE void
PUSH_DATAh(struct nouveau_pushbuf *push, uint64_t data)
{
   *push->cur++ = (uint32_t)(data >> 32);
}

static INLINE void
BEGIN_NV04(struct nouveau_pushbuf *push, int subc, int mthd, unsigned size)
{
#ifndef NV50_PUSH_EXPLICIT_SPACE_CHECKING
   PUSH_SPACE(push, size + 1);
#endif
   PUSH_DATA (push, NV50_FIFO_PKHDR(subc, mthd, size));
}

static INLINE void
BEGIN_NI04(struct nouveau_pushbuf *push, int subc, int mthd, unsigned size)
{
#ifndef NV50_PUSH_EXPLICIT_SPACE_CHECKING
   PUSH_SPACE(push, size + 1);
#endif
   PUSH_DATA (push, NV50_FIFO_PKHDR_NI(subc, mthd, size));
}

/* long, non-incremental, nv50-only */
static INLINE void
BEGIN_NL50(struct nouveau_pushbuf *push, int subc, int mthd, uint32_t size)
{
#ifndef NV50_PUSH_EXPLICIT_SPACE_CHECKING
   PUSH_SPACE(push, 2);
#endif
   PUSH_DATA (push, NV50_FIFO_PKHDR_L(subc, mthd));
   PUSH_DATA (push, size);
}

#endif /* __NV50_WINSYS_H__ */
@


1.2
log
@Merge Mesa 9.2.0
@
text
@@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d10 2
a11 8
#include "nouveau/nouveau_bo.h"
#include "nouveau/nouveau_channel.h"
#include "nouveau/nouveau_grobj.h"
#include "nouveau/nouveau_device.h"
#include "nouveau/nouveau_resource.h"
#include "nouveau/nouveau_pushbuf.h"
#include "nouveau/nouveau_reloc.h"
#include "nouveau/nouveau_notifier.h"
a12 1
#include "nouveau/nouveau_buffer.h"
a17 3
#define NV50_SUBCH_3D 5
#define NV50_SUBCH_2D 6
#define NV50_SUBCH_MF 7
d19 34
a52 1
#define NV50_MF_(n) NV50_M2MF_##n
d54 2
a55 3
#define RING_3D(n) ((NV50_SUBCH_3D << 13) | NV50_3D_##n)
#define RING_2D(n) ((NV50_SUBCH_2D << 13) | NV50_2D_##n)
#define RING_MF(n) ((NV50_SUBCH_MF << 13) | NV50_MF_(n))
d57 2
a58 3
#define RING_3D_(m) ((NV50_SUBCH_3D << 13) | (m))
#define RING_2D_(m) ((NV50_SUBCH_2D << 13) | (m))
#define RING_MF_(m) ((NV50_SUBCH_MF << 13) | (m))
d60 2
a61 1
#define RING_GR(gr, m) (((gr)->subc << 13) | (m))
d63 3
a65 1
int nouveau_pushbuf_flush(struct nouveau_channel *, unsigned min);
d67 9
a75 2
static inline uint32_t
nouveau_bo_tile_layout(struct nouveau_bo *bo)
d77 1
a77 1
   return bo->tile_flags & NOUVEAU_BO_TILE_LAYOUT_MASK;
d80 2
a81 3
static INLINE void
nouveau_bo_validate(struct nouveau_channel *chan,
                    struct nouveau_bo *bo, unsigned flags)
d83 1
a83 1
   nouveau_reloc_emit(chan, NULL, 0, NULL, bo, 0, 0, flags, 0, 0);
d86 3
a88 3
/* incremental methods */
static INLINE void
BEGIN_RING(struct nouveau_channel *chan, uint32_t mthd, unsigned size)
d90 1
a90 2
   WAIT_RING(chan, size + 1);
   OUT_RING (chan, (size << 18) | mthd);
d93 1
a93 1
/* non-incremental */
d95 1
a95 1
BEGIN_RING_NI(struct nouveau_channel *chan, uint32_t mthd, unsigned size)
d97 1
a97 2
   WAIT_RING(chan, size + 1);
   OUT_RING (chan, (0x2 << 29) | (size << 18) | mthd);
d100 2
a101 3
static INLINE int
OUT_RESRCh(struct nouveau_channel *chan, struct nv04_resource *res,
           unsigned delta, unsigned flags)
d103 4
a106 1
   return OUT_RELOCh(chan, res->bo, res->offset + delta, res->domain | flags);
d109 2
a110 3
static INLINE int
OUT_RESRCl(struct nouveau_channel *chan, struct nv04_resource *res,
           unsigned delta, unsigned flags)
d112 4
a115 3
   if (flags & NOUVEAU_BO_WR)
      res->status |= NOUVEAU_BUFFER_STATUS_GPU_WRITING;
   return OUT_RELOCl(chan, res->bo, res->offset + delta, res->domain | flags);
d118 1
d120 1
a120 1
BIND_RING(struct nouveau_channel *chan, struct nouveau_grobj *gr, unsigned s)
d122 5
a126 13
   struct nouveau_subchannel *subc = &gr->channel->subc[s];

   assert(s < 8);
   if (subc->gr) {
      assert(subc->gr->bound != NOUVEAU_GROBJ_BOUND_EXPLICIT);
      subc->gr->bound = NOUVEAU_GROBJ_UNBOUND;
   }
   subc->gr = gr;
   subc->gr->subc = s;
   subc->gr->bound = NOUVEAU_GROBJ_BOUND_EXPLICIT;

   BEGIN_RING(chan, RING_GR(gr, 0x0000), 1);
   OUT_RING  (chan, gr->handle);
d129 1
a129 1
#endif
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@d10 9
a18 1
#include "nouveau/nouveau_winsys.h"
a20 1

d25 5
d31 3
a33 6
static INLINE void
nv50_add_bufctx_resident_bo(struct nouveau_bufctx *bufctx, int bin,
                            unsigned flags, struct nouveau_bo *bo)
{
   nouveau_bufctx_refn(bufctx, bin, bo, flags)->priv = NULL;
}
d35 3
a37 9
static INLINE void
nv50_add_bufctx_resident(struct nouveau_bufctx *bufctx, int bin,
                         struct nv04_resource *res, unsigned flags)
{
   struct nouveau_bufref *ref =
      nouveau_bufctx_refn(bufctx, bin, res->bo, flags | res->domain);
   ref->priv = res;
   ref->priv_data = flags;
}
d39 1
a39 2
#define BCTX_REFN_bo(ctx, bin, fl, bo) \
   nv50_add_bufctx_resident_bo(ctx, NV50_BIND_##bin, fl, bo);
d41 1
a41 2
#define BCTX_REFN(bctx, bin, res, acc) \
   nv50_add_bufctx_resident(bctx, NV50_BIND_##bin, res, NOUVEAU_BO_##acc)
d43 2
a44 2
static INLINE void
PUSH_REFN(struct nouveau_pushbuf *push, struct nouveau_bo *bo, uint32_t flags)
d46 1
a46 2
   struct nouveau_pushbuf_refn ref = { bo, flags };
   nouveau_pushbuf_refn(push, &ref, 1);
d49 3
a51 21

#define SUBC_3D(m) 3, (m)
#define NV50_3D(n) SUBC_3D(NV50_3D_##n)
#define NVA0_3D(n) SUBC_3D(NVA0_3D_##n)

#define SUBC_2D(m) 4, (m)
#define NV50_2D(n) SUBC_2D(NV50_2D_##n)

#define SUBC_M2MF(m) 5, (m)
#define NV50_M2MF(n) SUBC_M2MF(NV50_M2MF_##n)

#define SUBC_COMPUTE(m) 6, (m)
#define NV50_COMPUTE(n) SUBC_COMPUTE(NV50_COMPUTE_##n)

/* These are expected to be on their own pushbufs */
#define SUBC_BSP(m) 2, (m)
#define SUBC_VP(m) 2, (m)


static INLINE uint32_t
NV50_FIFO_PKHDR(int subc, int mthd, unsigned size)
d53 1
a53 1
   return 0x00000000 | (size << 18) | (subc << 13) | mthd;
d56 3
a58 2
static INLINE uint32_t
NV50_FIFO_PKHDR_NI(int subc, int mthd, unsigned size)
d60 2
a61 1
   return 0x40000000 | (size << 18) | (subc << 13) | mthd;
d64 3
a66 2
static INLINE uint32_t
NV50_FIFO_PKHDR_L(int subc, int mthd)
d68 2
a69 1
   return 0x00030000 | (subc << 13) | mthd;
d72 3
a74 3

static INLINE uint32_t
nouveau_bo_memtype(const struct nouveau_bo *bo)
d76 1
a76 1
   return bo->config.nv50.memtype;
d79 3
a81 3

static INLINE void
PUSH_DATAh(struct nouveau_pushbuf *push, uint64_t data)
d83 3
a85 1
   *push->cur++ = (uint32_t)(data >> 32);
d89 1
a89 1
BEGIN_NV04(struct nouveau_pushbuf *push, int subc, int mthd, unsigned size)
d91 10
a100 5
#ifndef NV50_PUSH_EXPLICIT_SPACE_CHECKING
   PUSH_SPACE(push, size + 1);
#endif
   PUSH_DATA (push, NV50_FIFO_PKHDR(subc, mthd, size));
}
d102 2
a103 7
static INLINE void
BEGIN_NI04(struct nouveau_pushbuf *push, int subc, int mthd, unsigned size)
{
#ifndef NV50_PUSH_EXPLICIT_SPACE_CHECKING
   PUSH_SPACE(push, size + 1);
#endif
   PUSH_DATA (push, NV50_FIFO_PKHDR_NI(subc, mthd, size));
a105 6
/* long, non-incremental, nv50-only */
static INLINE void
BEGIN_NL50(struct nouveau_pushbuf *push, int subc, int mthd, uint32_t size)
{
#ifndef NV50_PUSH_EXPLICIT_SPACE_CHECKING
   PUSH_SPACE(push, 2);
a106 5
   PUSH_DATA (push, NV50_FIFO_PKHDR_L(subc, mthd));
   PUSH_DATA (push, size);
}

#endif /* __NV50_WINSYS_H__ */
@

