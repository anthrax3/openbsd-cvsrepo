head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.07.09.21.08.54;	author jsg;	state dead;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.45;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.43;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@
#include "util/u_format.h"

#include "nv50_context.h"

#include "nv50_defs.xml.h"

struct nv50_transfer {
   struct pipe_transfer base;
   struct nv50_m2mf_rect rect[2];
   uint32_t nblocksx;
   uint32_t nblocksy;
};

void
nv50_m2mf_rect_setup(struct nv50_m2mf_rect *rect,
                     struct pipe_resource *restrict res, unsigned l,
                     unsigned x, unsigned y, unsigned z)
{
   struct nv50_miptree *mt = nv50_miptree(res);
   const unsigned w = u_minify(res->width0, l);
   const unsigned h = u_minify(res->height0, l);

   rect->bo = mt->base.bo;
   rect->domain = mt->base.domain;
   rect->base = mt->level[l].offset;
   rect->pitch = mt->level[l].pitch;
   if (util_format_is_plain(res->format)) {
      rect->width = w << mt->ms_x;
      rect->height = h << mt->ms_y;
      rect->x = x << mt->ms_x;
      rect->y = y << mt->ms_y;
   } else {
      rect->width = util_format_get_nblocksx(res->format, w);
      rect->height = util_format_get_nblocksy(res->format, h);
      rect->x = util_format_get_nblocksx(res->format, x);
      rect->y = util_format_get_nblocksy(res->format, y);
   }
   rect->tile_mode = mt->level[l].tile_mode;
   rect->cpp = util_format_get_blocksize(res->format);

   if (mt->layout_3d) {
      rect->z = z;
      rect->depth = u_minify(res->depth0, l);
   } else {
      rect->base += z * mt->layer_stride;
      rect->z = 0;
      rect->depth = 1;
   }
}

void
nv50_m2mf_transfer_rect(struct nv50_context *nv50,
                        const struct nv50_m2mf_rect *dst,
                        const struct nv50_m2mf_rect *src,
                        uint32_t nblocksx, uint32_t nblocksy)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nouveau_bufctx *bctx = nv50->bufctx;
   const int cpp = dst->cpp;
   uint32_t src_ofst = src->base;
   uint32_t dst_ofst = dst->base;
   uint32_t height = nblocksy;
   uint32_t sy = src->y;
   uint32_t dy = dst->y;

   assert(dst->cpp == src->cpp);

   nouveau_bufctx_refn(bctx, 0, src->bo, src->domain | NOUVEAU_BO_RD);
   nouveau_bufctx_refn(bctx, 0, dst->bo, dst->domain | NOUVEAU_BO_WR);
   nouveau_pushbuf_bufctx(push, bctx);
   nouveau_pushbuf_validate(push);

   if (nouveau_bo_memtype(src->bo)) {
      BEGIN_NV04(push, NV50_M2MF(LINEAR_IN), 6);
      PUSH_DATA (push, 0);
      PUSH_DATA (push, src->tile_mode);
      PUSH_DATA (push, src->width * cpp);
      PUSH_DATA (push, src->height);
      PUSH_DATA (push, src->depth);
      PUSH_DATA (push, src->z);
   } else {
      src_ofst += src->y * src->pitch + src->x * cpp;

      BEGIN_NV04(push, NV50_M2MF(LINEAR_IN), 1);
      PUSH_DATA (push, 1);
      BEGIN_NV04(push, SUBC_M2MF(NV03_M2MF_PITCH_IN), 1);
      PUSH_DATA (push, src->pitch);
   }

   if (nouveau_bo_memtype(dst->bo)) {
      BEGIN_NV04(push, NV50_M2MF(LINEAR_OUT), 6);
      PUSH_DATA (push, 0);
      PUSH_DATA (push, dst->tile_mode);
      PUSH_DATA (push, dst->width * cpp);
      PUSH_DATA (push, dst->height);
      PUSH_DATA (push, dst->depth);
      PUSH_DATA (push, dst->z);
   } else {
      dst_ofst += dst->y * dst->pitch + dst->x * cpp;

      BEGIN_NV04(push, NV50_M2MF(LINEAR_OUT), 1);
      PUSH_DATA (push, 1);
      BEGIN_NV04(push, SUBC_M2MF(NV03_M2MF_PITCH_OUT), 1);
      PUSH_DATA (push, dst->pitch);
   }

   while (height) {
      int line_count = height > 2047 ? 2047 : height;

      BEGIN_NV04(push, NV50_M2MF(OFFSET_IN_HIGH), 2);
      PUSH_DATAh(push, src->bo->offset + src_ofst);
      PUSH_DATAh(push, dst->bo->offset + dst_ofst);

      BEGIN_NV04(push, SUBC_M2MF(NV03_M2MF_OFFSET_IN), 2);
      PUSH_DATA (push, src->bo->offset + src_ofst);
      PUSH_DATA (push, dst->bo->offset + dst_ofst);

      if (nouveau_bo_memtype(src->bo)) {
         BEGIN_NV04(push, NV50_M2MF(TILING_POSITION_IN), 1);
         PUSH_DATA (push, (sy << 16) | (src->x * cpp));
      } else {
         src_ofst += line_count * src->pitch;
      }
      if (nouveau_bo_memtype(dst->bo)) {
         BEGIN_NV04(push, NV50_M2MF(TILING_POSITION_OUT), 1);
         PUSH_DATA (push, (dy << 16) | (dst->x * cpp));
      } else {
         dst_ofst += line_count * dst->pitch;
      }

      BEGIN_NV04(push, SUBC_M2MF(NV03_M2MF_LINE_LENGTH_IN), 4);
      PUSH_DATA (push, nblocksx * cpp);
      PUSH_DATA (push, line_count);
      PUSH_DATA (push, (1 << 8) | (1 << 0));
      PUSH_DATA (push, 0);

      height -= line_count;
      sy += line_count;
      dy += line_count;
   }

   nouveau_bufctx_reset(bctx, 0);
}

void
nv50_sifc_linear_u8(struct nouveau_context *nv,
                    struct nouveau_bo *dst, unsigned offset, unsigned domain,
                    unsigned size, const void *data)
{
   struct nv50_context *nv50 = nv50_context(&nv->pipe);
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   uint32_t *src = (uint32_t *)data;
   unsigned count = (size + 3) / 4;
   unsigned xcoord = offset & 0xff;

   nouveau_bufctx_refn(nv50->bufctx, 0, dst, domain | NOUVEAU_BO_WR);
   nouveau_pushbuf_bufctx(push, nv50->bufctx);
   nouveau_pushbuf_validate(push);

   offset &= ~0xff;

   BEGIN_NV04(push, NV50_2D(DST_FORMAT), 2);
   PUSH_DATA (push, NV50_SURFACE_FORMAT_R8_UNORM);
   PUSH_DATA (push, 1);
   BEGIN_NV04(push, NV50_2D(DST_PITCH), 5);
   PUSH_DATA (push, 262144);
   PUSH_DATA (push, 65536);
   PUSH_DATA (push, 1);
   PUSH_DATAh(push, dst->offset + offset);
   PUSH_DATA (push, dst->offset + offset);
   BEGIN_NV04(push, NV50_2D(SIFC_BITMAP_ENABLE), 2);
   PUSH_DATA (push, 0);
   PUSH_DATA (push, NV50_SURFACE_FORMAT_R8_UNORM);
   BEGIN_NV04(push, NV50_2D(SIFC_WIDTH), 10);
   PUSH_DATA (push, size);
   PUSH_DATA (push, 1);
   PUSH_DATA (push, 0);
   PUSH_DATA (push, 1);
   PUSH_DATA (push, 0);
   PUSH_DATA (push, 1);
   PUSH_DATA (push, 0);
   PUSH_DATA (push, xcoord);
   PUSH_DATA (push, 0);
   PUSH_DATA (push, 0);

   while (count) {
      unsigned nr;

      if (!PUSH_SPACE(push, 16))
         break;
      nr = PUSH_AVAIL(push);
      assert(nr >= 16);
      nr = MIN2(count, nr - 1);
      nr = MIN2(nr, NV04_PFIFO_MAX_PACKET_LEN);

      BEGIN_NI04(push, NV50_2D(SIFC_DATA), nr);
      PUSH_DATAp(push, src, nr);

      src += nr;
      count -= nr;
   }

   nouveau_bufctx_reset(nv50->bufctx, 0);
}

void
nv50_m2mf_copy_linear(struct nouveau_context *nv,
                      struct nouveau_bo *dst, unsigned dstoff, unsigned dstdom,
                      struct nouveau_bo *src, unsigned srcoff, unsigned srcdom,
                      unsigned size)
{
   struct nouveau_pushbuf *push = nv->pushbuf;
   struct nouveau_bufctx *bctx = nv50_context(&nv->pipe)->bufctx;

   nouveau_bufctx_refn(bctx, 0, src, srcdom | NOUVEAU_BO_RD);
   nouveau_bufctx_refn(bctx, 0, dst, dstdom | NOUVEAU_BO_WR);
   nouveau_pushbuf_bufctx(push, bctx);
   nouveau_pushbuf_validate(push);

   BEGIN_NV04(push, NV50_M2MF(LINEAR_IN), 1);
   PUSH_DATA (push, 1);
   BEGIN_NV04(push, NV50_M2MF(LINEAR_OUT), 1);
   PUSH_DATA (push, 1);

   while (size) {
      unsigned bytes = MIN2(size, 1 << 17);

      BEGIN_NV04(push, NV50_M2MF(OFFSET_IN_HIGH), 2);
      PUSH_DATAh(push, src->offset + srcoff);
      PUSH_DATAh(push, dst->offset + dstoff);
      BEGIN_NV04(push, SUBC_M2MF(NV03_M2MF_OFFSET_IN), 2);
      PUSH_DATA (push, src->offset + srcoff);
      PUSH_DATA (push, dst->offset + dstoff);
      BEGIN_NV04(push, SUBC_M2MF(NV03_M2MF_LINE_LENGTH_IN), 4);
      PUSH_DATA (push, bytes);
      PUSH_DATA (push, 1);
      PUSH_DATA (push, (1 << 8) | (1 << 0));
      PUSH_DATA (push, 0);

      srcoff += bytes;
      dstoff += bytes;
      size -= bytes;
   }

   nouveau_bufctx_reset(bctx, 0);
}

void *
nv50_miptree_transfer_map(struct pipe_context *pctx,
                          struct pipe_resource *res,
                          unsigned level,
                          unsigned usage,
                          const struct pipe_box *box,
                          struct pipe_transfer **ptransfer)
{
   struct nv50_screen *screen = nv50_screen(pctx->screen);
   struct nv50_context *nv50 = nv50_context(pctx);
   struct nouveau_device *dev = nv50->screen->base.device;
   const struct nv50_miptree *mt = nv50_miptree(res);
   struct nv50_transfer *tx;
   uint32_t size;
   int ret;
   unsigned flags = 0;

   if (usage & PIPE_TRANSFER_MAP_DIRECTLY)
      return NULL;

   tx = CALLOC_STRUCT(nv50_transfer);
   if (!tx)
      return NULL;

   pipe_resource_reference(&tx->base.resource, res);

   tx->base.level = level;
   tx->base.usage = usage;
   tx->base.box = *box;

   if (util_format_is_plain(res->format)) {
      tx->nblocksx = box->width << mt->ms_x;
      tx->nblocksy = box->height << mt->ms_x;
   } else {
      tx->nblocksx = util_format_get_nblocksx(res->format, box->width);
      tx->nblocksy = util_format_get_nblocksy(res->format, box->height);
   }

   tx->base.stride = tx->nblocksx * util_format_get_blocksize(res->format);
   tx->base.layer_stride = tx->nblocksy * tx->base.stride;

   nv50_m2mf_rect_setup(&tx->rect[0], res, level, box->x, box->y, box->z);

   size = tx->base.layer_stride;

   ret = nouveau_bo_new(dev, NOUVEAU_BO_GART | NOUVEAU_BO_MAP, 0,
                        size * tx->base.box.depth, NULL, &tx->rect[1].bo);
   if (ret) {
      FREE(tx);
      return NULL;
   }

   tx->rect[1].cpp = tx->rect[0].cpp;
   tx->rect[1].width = tx->nblocksx;
   tx->rect[1].height = tx->nblocksy;
   tx->rect[1].depth = 1;
   tx->rect[1].pitch = tx->base.stride;
   tx->rect[1].domain = NOUVEAU_BO_GART;

   if (usage & PIPE_TRANSFER_READ) {
      unsigned base = tx->rect[0].base;
      unsigned z = tx->rect[0].z;
      unsigned i;
      for (i = 0; i < box->depth; ++i) {
         nv50_m2mf_transfer_rect(nv50, &tx->rect[1], &tx->rect[0],
                                 tx->nblocksx, tx->nblocksy);
         if (mt->layout_3d)
            tx->rect[0].z++;
         else
            tx->rect[0].base += mt->layer_stride;
         tx->rect[1].base += size;
      }
      tx->rect[0].z = z;
      tx->rect[0].base = base;
      tx->rect[1].base = 0;
   }

   if (tx->rect[1].bo->map) {
      *ptransfer = &tx->base;
      return tx->rect[1].bo->map;
   }

   if (usage & PIPE_TRANSFER_READ)
      flags = NOUVEAU_BO_RD;
   if (usage & PIPE_TRANSFER_WRITE)
      flags |= NOUVEAU_BO_WR;

   ret = nouveau_bo_map(tx->rect[1].bo, flags, screen->base.client);
   if (ret) {
      nouveau_bo_ref(NULL, &tx->rect[1].bo);
      FREE(tx);
      return NULL;
   }

   *ptransfer = &tx->base;
   return tx->rect[1].bo->map;
}

void
nv50_miptree_transfer_unmap(struct pipe_context *pctx,
                            struct pipe_transfer *transfer)
{
   struct nv50_context *nv50 = nv50_context(pctx);
   struct nv50_transfer *tx = (struct nv50_transfer *)transfer;
   struct nv50_miptree *mt = nv50_miptree(tx->base.resource);
   unsigned i;

   if (tx->base.usage & PIPE_TRANSFER_WRITE) {
      for (i = 0; i < tx->base.box.depth; ++i) {
         nv50_m2mf_transfer_rect(nv50, &tx->rect[0], &tx->rect[1],
                                 tx->nblocksx, tx->nblocksy);
         if (mt->layout_3d)
            tx->rect[0].z++;
         else
            tx->rect[0].base += mt->layer_stride;
         tx->rect[1].base += tx->nblocksy * tx->base.stride;
      }
   }

   nouveau_bo_ref(NULL, &tx->rect[1].bo);
   pipe_resource_reference(&transfer->resource, NULL);

   FREE(tx);
}

void
nv50_cb_push(struct nouveau_context *nv,
             struct nouveau_bo *bo, unsigned domain,
             unsigned base, unsigned size,
             unsigned offset, unsigned words, const uint32_t *data)
{
   struct nouveau_pushbuf *push = nv->pushbuf;
   struct nouveau_bufctx *bctx = nv50_context(&nv->pipe)->bufctx;

   assert(!(offset & 3));
   size = align(size, 0x100);

   nouveau_bufctx_refn(bctx, 0, bo, NOUVEAU_BO_WR | domain);
   nouveau_pushbuf_bufctx(push, bctx);
   nouveau_pushbuf_validate(push);

   while (words) {
      unsigned nr;

      nr = PUSH_AVAIL(push);
      nr = MIN2(nr - 7, words);
      nr = MIN2(nr, NV04_PFIFO_MAX_PACKET_LEN - 1);

      BEGIN_NV04(push, NV50_3D(CB_DEF_ADDRESS_HIGH), 3);
      PUSH_DATAh(push, bo->offset + base);
      PUSH_DATA (push, bo->offset + base);
      PUSH_DATA (push, (NV50_CB_TMP << 16) | (size & 0xffff));
      BEGIN_NV04(push, NV50_3D(CB_ADDR), 1);
      PUSH_DATA (push, (offset << 6) | NV50_CB_TMP);
      BEGIN_NI04(push, NV50_3D(CB_DATA(0)), nr);
      PUSH_DATAp(push, data, nr);

      words -= nr;
      data += nr;
      offset += nr * 4;
   }

   nouveau_bufctx_reset(bctx, 0);
}
@


1.4
log
@Merge Mesa 9.2.0
@
text
@@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a4 1
#include "nv50_transfer.h"
d15 39
a53 2
static void
nv50_m2mf_transfer_rect(struct pipe_screen *pscreen,
d58 2
a59 1
   struct nouveau_channel *chan = nouveau_screen(pscreen)->channel;
d69 13
a81 8
   if (nouveau_bo_tile_layout(src->bo)) {
      BEGIN_RING(chan, RING_MF(LINEAR_IN), 6);
      OUT_RING  (chan, 0);
      OUT_RING  (chan, src->tile_mode << 4);
      OUT_RING  (chan, src->width * cpp);
      OUT_RING  (chan, src->height);
      OUT_RING  (chan, src->depth);
      OUT_RING  (chan, src->z);
d85 4
a88 4
      BEGIN_RING(chan, RING_MF(LINEAR_IN), 1);
      OUT_RING  (chan, 1);
      BEGIN_RING(chan, RING_MF_(NV04_M2MF_PITCH_IN), 1);
      OUT_RING  (chan, src->pitch);
d91 8
a98 8
   if (nouveau_bo_tile_layout(dst->bo)) {
      BEGIN_RING(chan, RING_MF(LINEAR_OUT), 6);
      OUT_RING  (chan, 0);
      OUT_RING  (chan, dst->tile_mode << 4);
      OUT_RING  (chan, dst->width * cpp);
      OUT_RING  (chan, dst->height);
      OUT_RING  (chan, dst->depth);
      OUT_RING  (chan, dst->z);
d102 4
a105 4
      BEGIN_RING(chan, RING_MF(LINEAR_OUT), 1);
      OUT_RING  (chan, 1);
      BEGIN_RING(chan, RING_MF_(NV04_M2MF_PITCH_OUT), 1);
      OUT_RING  (chan, dst->pitch);
d111 11
a121 13
      MARK_RING (chan, 17, 4);

      BEGIN_RING(chan, RING_MF(OFFSET_IN_HIGH), 2);
      OUT_RELOCh(chan, src->bo, src_ofst, src->domain | NOUVEAU_BO_RD);
      OUT_RELOCh(chan, dst->bo, dst_ofst, dst->domain | NOUVEAU_BO_WR);

      BEGIN_RING(chan, RING_MF_(NV04_M2MF_OFFSET_IN), 2);
      OUT_RELOCl(chan, src->bo, src_ofst, src->domain | NOUVEAU_BO_RD);
      OUT_RELOCl(chan, dst->bo, dst_ofst, dst->domain | NOUVEAU_BO_WR);

      if (nouveau_bo_tile_layout(src->bo)) {
         BEGIN_RING(chan, RING_MF(TILING_POSITION_IN), 1);
         OUT_RING  (chan, (sy << 16) | (src->x * cpp));
d125 3
a127 3
      if (nouveau_bo_tile_layout(dst->bo)) {
         BEGIN_RING(chan, RING_MF(TILING_POSITION_OUT), 1);
         OUT_RING  (chan, (dy << 16) | (dst->x * cpp));
d132 5
a136 5
      BEGIN_RING(chan, RING_MF_(NV04_M2MF_LINE_LENGTH_IN), 4);
      OUT_RING  (chan, nblocksx * cpp);
      OUT_RING  (chan, line_count);
      OUT_RING  (chan, (1 << 8) | (1 << 0));
      OUT_RING  (chan, 0);
d142 2
d149 1
a149 1
                    unsigned size, void *data)
d151 2
a152 1
   struct nouveau_channel *chan = nv->screen->channel;
d157 4
d163 23
a185 24
   MARK_RING (chan, 23, 4);
   BEGIN_RING(chan, RING_2D(DST_FORMAT), 2);
   OUT_RING  (chan, NV50_SURFACE_FORMAT_R8_UNORM);
   OUT_RING  (chan, 1);
   BEGIN_RING(chan, RING_2D(DST_PITCH), 5);
   OUT_RING  (chan, 262144);
   OUT_RING  (chan, 65536);
   OUT_RING  (chan, 1);
   OUT_RELOCh(chan, dst, offset, domain | NOUVEAU_BO_WR);
   OUT_RELOCl(chan, dst, offset, domain | NOUVEAU_BO_WR);
   BEGIN_RING(chan, RING_2D(SIFC_BITMAP_ENABLE), 2);
   OUT_RING  (chan, 0);
   OUT_RING  (chan, NV50_SURFACE_FORMAT_R8_UNORM);
   BEGIN_RING(chan, RING_2D(SIFC_WIDTH), 10);
   OUT_RING  (chan, size);
   OUT_RING  (chan, 1);
   OUT_RING  (chan, 0);
   OUT_RING  (chan, 1);
   OUT_RING  (chan, 0);
   OUT_RING  (chan, 1);
   OUT_RING  (chan, 0);
   OUT_RING  (chan, xcoord);
   OUT_RING  (chan, 0);
   OUT_RING  (chan, 0);
d188 1
a188 1
      unsigned nr = AVAIL_RING(chan);
d190 4
a193 5
      if (nr < 9) {
         FIRE_RING(chan);
         nouveau_bo_validate(chan, dst, NOUVEAU_BO_WR);
         continue;
      }
d197 2
a198 2
      BEGIN_RING_NI(chan, RING_2D(SIFC_DATA), nr);
      OUT_RINGp (chan, src, nr);
d203 2
d213 2
a214 1
   struct nouveau_channel *chan = nv->screen->channel;
d216 9
a224 4
   BEGIN_RING(chan, RING_MF(LINEAR_IN), 1);
   OUT_RING  (chan, 1);
   BEGIN_RING(chan, RING_MF(LINEAR_OUT), 1);
   OUT_RING  (chan, 1);
d229 11
a239 12
      MARK_RING (chan, 11, 4);
      BEGIN_RING(chan, RING_MF(OFFSET_IN_HIGH), 2);
      OUT_RELOCh(chan, src, srcoff, srcdom | NOUVEAU_BO_RD);
      OUT_RELOCh(chan, dst, dstoff, dstdom | NOUVEAU_BO_WR);
      BEGIN_RING(chan, RING_MF_(NV04_M2MF_OFFSET_IN), 2);
      OUT_RELOCl(chan, src, srcoff, srcdom | NOUVEAU_BO_RD);
      OUT_RELOCl(chan, dst, dstoff, dstdom | NOUVEAU_BO_WR);
      BEGIN_RING(chan, RING_MF_(NV04_M2MF_LINE_LENGTH_IN), 4);
      OUT_RING  (chan, bytes);
      OUT_RING  (chan, 1);
      OUT_RING  (chan, (1 << 8) | (1 << 0));
      OUT_RING  (chan, 0);
d245 2
d249 2
a250 2
struct pipe_transfer *
nv50_miptree_transfer_new(struct pipe_context *pctx,
d254 2
a255 1
                          const struct pipe_box *box)
d257 1
a258 1
   struct pipe_screen *pscreen = pctx->screen;
d260 1
a260 2
   struct nv50_miptree *mt = nv50_miptree(res);
   struct nv50_miptree_level *lvl = &mt->level[level];
a262 1
   uint32_t w, h, d, z, layer;
d264 1
a268 10
   if (mt->layout_3d) {
      z = box->z;
      d = u_minify(res->depth0, level);
      layer = 0;
   } else {
      z = 0;
      d = 1;
      layer = box->z;
   }

d279 7
a285 2
   tx->nblocksx = util_format_get_nblocksx(res->format, box->width);
   tx->nblocksy = util_format_get_nblocksy(res->format, box->height);
d290 1
a290 16
   w = u_minify(res->width0, level);
   h = u_minify(res->height0, level);

   tx->rect[0].cpp = tx->rect[1].cpp = util_format_get_blocksize(res->format);

   tx->rect[0].bo = mt->base.bo;
   tx->rect[0].base = lvl->offset + layer * mt->layer_stride;
   tx->rect[0].tile_mode = lvl->tile_mode;
   tx->rect[0].x = util_format_get_nblocksx(res->format, box->x);
   tx->rect[0].y = util_format_get_nblocksy(res->format, box->y);
   tx->rect[0].z = z;
   tx->rect[0].width = util_format_get_nblocksx(res->format, w);
   tx->rect[0].height = util_format_get_nblocksy(res->format, h);
   tx->rect[0].depth = d;
   tx->rect[0].pitch = lvl->pitch;
   tx->rect[0].domain = NOUVEAU_BO_VRAM;
d295 1
a295 1
                        size * tx->base.box.depth, &tx->rect[1].bo);
d301 1
d310 1
d313 1
a313 1
         nv50_m2mf_transfer_rect(pscreen, &tx->rect[1], &tx->rect[0],
d326 19
a344 1
   return &tx->base;
d348 2
a349 2
nv50_miptree_transfer_del(struct pipe_context *pctx,
                          struct pipe_transfer *transfer)
d351 1
a351 1
   struct pipe_screen *pscreen = pctx->screen;
d358 1
a358 1
         nv50_m2mf_transfer_rect(pscreen, &tx->rect[0], &tx->rect[1],
d374 5
a378 3
void *
nv50_miptree_transfer_map(struct pipe_context *pctx,
                          struct pipe_transfer *transfer)
d380 2
a381 3
   struct nv50_transfer *tx = (struct nv50_transfer *)transfer;
   int ret;
   unsigned flags = 0;
d383 2
a384 2
   if (tx->rect[1].bo->map)
      return tx->rect[1].bo->map;
d386 24
a409 16
   if (transfer->usage & PIPE_TRANSFER_READ)
      flags = NOUVEAU_BO_RD;
   if (transfer->usage & PIPE_TRANSFER_WRITE)
      flags |= NOUVEAU_BO_WR;

   ret = nouveau_bo_map(tx->rect[1].bo, flags);
   if (ret)
      return NULL;
   return tx->rect[1].bo->map;
}

void
nv50_miptree_transfer_unmap(struct pipe_context *pctx,
                            struct pipe_transfer *transfer)
{
   struct nv50_transfer *tx = (struct nv50_transfer *)transfer;
d411 1
a411 1
   nouveau_bo_unmap(tx->rect[1].bo);
a412 1

@


1.2
log
@Merge Mesa 7.10.3
@
text
@a1 2
#include "pipe/p_context.h"
#include "util/u_inlines.h"
a2 1
#include "util/u_math.h"
d6 2
a7 1
#include "nv50_resource.h"
d10 4
a13 14
	struct pipe_transfer base;
	struct nouveau_bo *bo;
	int map_refcnt;
	unsigned level_offset;
	unsigned level_tiling;
	int level_pitch;
	int level_width;
	int level_height;
	int level_depth;
	int level_x;
	int level_y;
	int level_z;
	unsigned nblocksx;
	unsigned nblocksy;
d17 4
a20 9
nv50_transfer_rect_m2mf(struct pipe_screen *pscreen,
			struct nouveau_bo *src_bo, unsigned src_offset,
			int src_pitch, unsigned src_tile_mode,
			int sx, int sy, int sz, int sw, int sh, int sd,
			struct nouveau_bo *dst_bo, unsigned dst_offset,
			int dst_pitch, unsigned dst_tile_mode,
			int dx, int dy, int dz, int dw, int dh, int dd,
			int cpp, int width, int height,
			unsigned src_reloc, unsigned dst_reloc)
d22 80
a101 85
	struct nv50_screen *screen = nv50_screen(pscreen);
	struct nouveau_channel *chan = screen->m2mf->channel;
	struct nouveau_grobj *m2mf = screen->m2mf;

	src_reloc |= NOUVEAU_BO_RD;
	dst_reloc |= NOUVEAU_BO_WR;

	WAIT_RING (chan, 14);

	if (!nouveau_bo_tile_layout(src_bo)) {
		BEGIN_RING(chan, m2mf,
			NV50_MEMORY_TO_MEMORY_FORMAT_LINEAR_IN, 1);
		OUT_RING  (chan, 1);
		BEGIN_RING(chan, m2mf,
			NV04_MEMORY_TO_MEMORY_FORMAT_PITCH_IN, 1);
		OUT_RING  (chan, src_pitch);
		src_offset += (sy * src_pitch) + (sx * cpp);
	} else {
		BEGIN_RING(chan, m2mf,
			NV50_MEMORY_TO_MEMORY_FORMAT_LINEAR_IN, 6);
		OUT_RING  (chan, 0);
		OUT_RING  (chan, src_tile_mode << 4);
		OUT_RING  (chan, sw * cpp);
		OUT_RING  (chan, sh);
		OUT_RING  (chan, sd);
		OUT_RING  (chan, sz); /* copying only 1 zslice per call */
	}

	if (!nouveau_bo_tile_layout(dst_bo)) {
		BEGIN_RING(chan, m2mf,
			NV50_MEMORY_TO_MEMORY_FORMAT_LINEAR_OUT, 1);
		OUT_RING  (chan, 1);
		BEGIN_RING(chan, m2mf,
			NV04_MEMORY_TO_MEMORY_FORMAT_PITCH_OUT, 1);
		OUT_RING  (chan, dst_pitch);
		dst_offset += (dy * dst_pitch) + (dx * cpp);
	} else {
		BEGIN_RING(chan, m2mf,
			NV50_MEMORY_TO_MEMORY_FORMAT_LINEAR_OUT, 6);
		OUT_RING  (chan, 0);
		OUT_RING  (chan, dst_tile_mode << 4);
		OUT_RING  (chan, dw * cpp);
		OUT_RING  (chan, dh);
		OUT_RING  (chan, dd);
		OUT_RING  (chan, dz); /* copying only 1 zslice per call */
	}

	while (height) {
		int line_count = height > 2047 ? 2047 : height;

		MARK_RING (chan, 15, 4); /* flush on lack of space or relocs */
		BEGIN_RING(chan, m2mf,
			NV50_MEMORY_TO_MEMORY_FORMAT_OFFSET_IN_HIGH, 2);
		OUT_RELOCh(chan, src_bo, src_offset, src_reloc);
		OUT_RELOCh(chan, dst_bo, dst_offset, dst_reloc);
		BEGIN_RING(chan, m2mf,
			NV04_MEMORY_TO_MEMORY_FORMAT_OFFSET_IN, 2);
		OUT_RELOCl(chan, src_bo, src_offset, src_reloc);
		OUT_RELOCl(chan, dst_bo, dst_offset, dst_reloc);
		if (nouveau_bo_tile_layout(src_bo)) {
			BEGIN_RING(chan, m2mf,
				NV50_MEMORY_TO_MEMORY_FORMAT_TILING_POSITION_IN, 1);
			OUT_RING  (chan, (sy << 16) | (sx * cpp));
		} else {
			src_offset += (line_count * src_pitch);
		}
		if (nouveau_bo_tile_layout(dst_bo)) {
			BEGIN_RING(chan, m2mf,
				NV50_MEMORY_TO_MEMORY_FORMAT_TILING_POSITION_OUT, 1);
			OUT_RING  (chan, (dy << 16) | (dx * cpp));
		} else {
			dst_offset += (line_count * dst_pitch);
		}
		BEGIN_RING(chan, m2mf,
			NV04_MEMORY_TO_MEMORY_FORMAT_LINE_LENGTH_IN, 4);
		OUT_RING  (chan, width * cpp);
		OUT_RING  (chan, line_count);
		OUT_RING  (chan, 0x00000101);
		OUT_RING  (chan, 0);
		FIRE_RING (chan);

		height -= line_count;
		sy += line_count;
		dy += line_count;
	}
d104 4
a107 6
struct pipe_transfer *
nv50_miptree_transfer_new(struct pipe_context *pcontext,
			  struct pipe_resource *pt,
			  unsigned level,
			  unsigned usage,
			  const struct pipe_box *box)
d109 49
a157 67
        struct pipe_screen *pscreen = pcontext->screen;
	struct nouveau_device *dev = nouveau_screen(pscreen)->device;
	struct nv50_miptree *mt = nv50_miptree(pt);
	struct nv50_miptree_level *lvl = &mt->level[level];
	struct nv50_transfer *tx;
	unsigned nx, ny, image = 0, boxz = 0;
	int ret;

	/* XXX can't unify these here? */
	if (pt->target == PIPE_TEXTURE_CUBE)
		image = box->z;
	else if (pt->target == PIPE_TEXTURE_3D)
		boxz = box->z;

	tx = CALLOC_STRUCT(nv50_transfer);
	if (!tx)
		return NULL;

	/* Don't handle 3D transfers yet.
	 */
	assert(box->depth == 1);


	pipe_resource_reference(&tx->base.resource, pt);
	tx->base.level = level;
	tx->base.usage = usage;
	tx->base.box = *box;
	tx->nblocksx = util_format_get_nblocksx(pt->format, u_minify(pt->width0, level));
	tx->nblocksy = util_format_get_nblocksy(pt->format, u_minify(pt->height0, level));
	tx->base.stride = tx->nblocksx * util_format_get_blocksize(pt->format);
	tx->base.usage = usage;

	tx->level_pitch = lvl->pitch;
	tx->level_width = u_minify(mt->base.base.width0, level);
	tx->level_height = u_minify(mt->base.base.height0, level);
	tx->level_depth = u_minify(mt->base.base.depth0, level);
	tx->level_offset = lvl->image_offset[image];
	tx->level_tiling = lvl->tile_mode;
	tx->level_z = boxz;
	tx->level_x = util_format_get_nblocksx(pt->format, box->x);
	tx->level_y = util_format_get_nblocksy(pt->format, box->y);
	ret = nouveau_bo_new(dev, NOUVEAU_BO_GART | NOUVEAU_BO_MAP, 0,
			     tx->nblocksy * tx->base.stride, &tx->bo);
	if (ret) {
		FREE(tx);
		return NULL;
	}

	if (usage & PIPE_TRANSFER_READ) {
		nx = util_format_get_nblocksx(pt->format, box->width);
		ny = util_format_get_nblocksy(pt->format, box->height);

		nv50_transfer_rect_m2mf(pscreen, mt->base.bo, tx->level_offset,
					tx->level_pitch, tx->level_tiling,
					box->x, box->y, boxz,
					tx->nblocksx, tx->nblocksy,
					tx->level_depth,
					tx->bo, 0,
					tx->base.stride, tx->bo->tile_mode,
					0, 0, 0,
					tx->nblocksx, tx->nblocksy, 1,
					util_format_get_blocksize(pt->format), nx, ny,
					NOUVEAU_BO_VRAM | NOUVEAU_BO_GART,
					NOUVEAU_BO_GART);
	}

	return &tx->base;
d161 4
a164 2
nv50_miptree_transfer_del(struct pipe_context *pcontext,
			  struct pipe_transfer *ptx)
d166 27
a192 27
	struct nv50_transfer *tx = (struct nv50_transfer *)ptx;
	struct nv50_miptree *mt = nv50_miptree(ptx->resource);
	struct pipe_resource *pt = ptx->resource;

	unsigned nx = util_format_get_nblocksx(pt->format, tx->base.box.width);
	unsigned ny = util_format_get_nblocksy(pt->format, tx->base.box.height);

	if (ptx->usage & PIPE_TRANSFER_WRITE) {
		struct pipe_screen *pscreen = pcontext->screen;

		nv50_transfer_rect_m2mf(pscreen, tx->bo, 0,
					tx->base.stride, tx->bo->tile_mode,
					0, 0, 0,
					tx->nblocksx, tx->nblocksy, 1,
					mt->base.bo, tx->level_offset,
					tx->level_pitch, tx->level_tiling,
					tx->level_x, tx->level_y, tx->level_z,
					tx->nblocksx, tx->nblocksy,
					tx->level_depth,
					util_format_get_blocksize(pt->format), nx, ny,
					NOUVEAU_BO_GART, NOUVEAU_BO_VRAM |
					NOUVEAU_BO_GART);
	}

	nouveau_bo_ref(NULL, &tx->bo);
	pipe_resource_reference(&ptx->resource, NULL);
	FREE(ptx);
d195 6
a200 3
void *
nv50_miptree_transfer_map(struct pipe_context *pcontext,
			  struct pipe_transfer *ptx)
d202 89
a290 18
	struct nv50_transfer *tx = (struct nv50_transfer *)ptx;
	unsigned flags = 0;
	int ret;

	if (tx->map_refcnt++)
		return tx->bo->map;

	if (ptx->usage & PIPE_TRANSFER_WRITE)
		flags |= NOUVEAU_BO_WR;
	if (ptx->usage & PIPE_TRANSFER_READ)
		flags |= NOUVEAU_BO_RD;

	ret = nouveau_bo_map(tx->bo, flags);
	if (ret) {
		tx->map_refcnt = 0;
		return NULL;
	}
	return tx->bo->map;
d294 2
a295 2
nv50_miptree_transfer_unmap(struct pipe_context *pcontext,
			    struct pipe_transfer *ptx)
d297 19
a315 1
	struct nv50_transfer *tx = (struct nv50_transfer *)ptx;
d317 1
a317 3
	if (--tx->map_refcnt)
		return;
	nouveau_bo_unmap(tx->bo);
d320 21
d343 2
a344 5
nv50_upload_sifc(struct nv50_context *nv50,
		 struct nouveau_bo *bo, unsigned dst_offset, unsigned reloc,
		 unsigned dst_format, int dst_w, int dst_h, int dst_pitch,
		 void *src, unsigned src_format, int src_pitch,
		 int x, int y, int w, int h, int cpp)
d346 1
a346 70
	struct nouveau_channel *chan = nv50->screen->base.channel;
	struct nouveau_grobj *eng2d = nv50->screen->eng2d;
	unsigned line_dwords = (w * cpp + 3) / 4;

	reloc |= NOUVEAU_BO_WR;

	MARK_RING (chan, 32, 2); /* flush on lack of space or relocs */

	if (nouveau_bo_tile_layout(bo)) {
		BEGIN_RING(chan, eng2d, NV50_2D_DST_FORMAT, 5);
		OUT_RING  (chan, dst_format);
		OUT_RING  (chan, 0);
		OUT_RING  (chan, bo->tile_mode << 4);
		OUT_RING  (chan, 1);
		OUT_RING  (chan, 0);
	} else {
		BEGIN_RING(chan, eng2d, NV50_2D_DST_FORMAT, 2);
		OUT_RING  (chan, dst_format);
		OUT_RING  (chan, 1);
		BEGIN_RING(chan, eng2d, NV50_2D_DST_PITCH, 1);
		OUT_RING  (chan, dst_pitch);
	}

	BEGIN_RING(chan, eng2d, NV50_2D_DST_WIDTH, 4);
	OUT_RING  (chan, dst_w);
	OUT_RING  (chan, dst_h);
	OUT_RELOCh(chan, bo, dst_offset, reloc);
	OUT_RELOCl(chan, bo, dst_offset, reloc);

	/* NV50_2D_OPERATION_SRCCOPY assumed already set */

	BEGIN_RING(chan, eng2d, NV50_2D_SIFC_BITMAP_ENABLE, 2);
	OUT_RING  (chan, 0);
	OUT_RING  (chan, src_format);
	BEGIN_RING(chan, eng2d, NV50_2D_SIFC_WIDTH, 10);
	OUT_RING  (chan, w);
	OUT_RING  (chan, h);
	OUT_RING  (chan, 0);
	OUT_RING  (chan, 1);
	OUT_RING  (chan, 0);
	OUT_RING  (chan, 1);
	OUT_RING  (chan, 0);
	OUT_RING  (chan, x);
	OUT_RING  (chan, 0);
	OUT_RING  (chan, y);

	while (h--) {
		const uint32_t *p = src;
		unsigned count = line_dwords;

		while (count) {
			unsigned nr = MIN2(count, 1792);

			if (AVAIL_RING(chan) <= nr) {
				FIRE_RING (chan);

				BEGIN_RING(chan, eng2d,
					   NV50_2D_DST_ADDRESS_HIGH, 2);
				OUT_RELOCh(chan, bo, dst_offset, reloc);
				OUT_RELOCl(chan, bo, dst_offset, reloc);
			}
			assert(AVAIL_RING(chan) > nr);

			BEGIN_RING(chan, eng2d,
				   NV50_2D_SIFC_DATA | (2 << 29), nr);
			OUT_RINGp (chan, p, nr);

			p += nr;
			count -= nr;
		}
d348 1
a348 2
		src = (uint8_t *) src + src_pitch;
	}
d350 1
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d8 2
d14 1
d48 1
a48 1
	if (!src_bo->tile_flags) {
d67 1
a67 1
	if (!dst_bo->tile_flags) {
d98 1
a98 1
		if (src_bo->tile_flags) {
d105 1
a105 1
		if (dst_bo->tile_flags) {
d126 6
a131 5
static struct pipe_transfer *
nv50_transfer_new(struct pipe_screen *pscreen, struct pipe_texture *pt,
		  unsigned face, unsigned level, unsigned zslice,
		  enum pipe_transfer_usage usage,
		  unsigned x, unsigned y, unsigned w, unsigned h)
d133 1
d138 1
a138 1
	unsigned nx, ny, image = 0;
d141 1
d143 3
a145 1
		image = face;
d151 9
a159 1
	pipe_texture_reference(&tx->base.texture, pt);
a161 2
	tx->base.width = w;
	tx->base.height = h;
d171 3
a173 3
	tx->level_z = zslice;
	tx->level_x = util_format_get_nblocksx(pt->format, x);
	tx->level_y = util_format_get_nblocksy(pt->format, y);
d182 2
a183 2
		nx = util_format_get_nblocksx(pt->format, tx->base.width);
		ny = util_format_get_nblocksy(pt->format, tx->base.height);
d187 1
a187 1
					x, y, zslice,
d202 3
a204 2
static void
nv50_transfer_del(struct pipe_transfer *ptx)
d207 2
a208 2
	struct nv50_miptree *mt = nv50_miptree(ptx->texture);
	struct pipe_texture *pt = ptx->texture;
d210 2
a211 2
	unsigned nx = util_format_get_nblocksx(pt->format, tx->base.width);
	unsigned ny = util_format_get_nblocksy(pt->format, tx->base.height);
d214 1
a214 1
		struct pipe_screen *pscreen = pt->screen;
d231 1
a231 1
	pipe_texture_reference(&ptx->texture, NULL);
d235 3
a237 2
static void *
nv50_transfer_map(struct pipe_screen *pscreen, struct pipe_transfer *ptx)
d243 3
d252 2
a253 1
	if (ret)
d255 1
d259 3
a261 2
static void
nv50_transfer_unmap(struct pipe_screen *pscreen, struct pipe_transfer *ptx)
d265 2
a269 8
void
nv50_transfer_init_screen_functions(struct pipe_screen *pscreen)
{
	pscreen->get_tex_transfer = nv50_transfer_new;
	pscreen->tex_transfer_destroy = nv50_transfer_del;
	pscreen->transfer_map = nv50_transfer_map;
	pscreen->transfer_unmap = nv50_transfer_unmap;
}
a279 1
	struct nouveau_grobj *tesla = nv50->screen->tesla;
d286 1
a286 1
	if (bo->tile_flags) {
d349 1
a349 1
		src += src_pitch;
a350 3

	BEGIN_RING(chan, tesla, NV50TCL_CODE_CB_FLUSH, 1);
	OUT_RING  (chan, 0);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a7 2
#include "nv50_transfer.h"
#include "nv50_resource.h"
a11 1
	int map_refcnt;
d45 1
a45 1
	if (!nouveau_bo_tile_layout(src_bo)) {
d64 1
a64 1
	if (!nouveau_bo_tile_layout(dst_bo)) {
d95 1
a95 1
		if (nouveau_bo_tile_layout(src_bo)) {
d102 1
a102 1
		if (nouveau_bo_tile_layout(dst_bo)) {
d123 5
a127 6
struct pipe_transfer *
nv50_miptree_transfer_new(struct pipe_context *pcontext,
			  struct pipe_resource *pt,
			  unsigned level,
			  unsigned usage,
			  const struct pipe_box *box)
a128 1
        struct pipe_screen *pscreen = pcontext->screen;
d133 1
a133 1
	unsigned nx, ny, image = 0, boxz = 0;
a135 1
	/* XXX can't unify these here? */
d137 1
a137 3
		image = box->z;
	else if (pt->target == PIPE_TEXTURE_3D)
		boxz = box->z;
d143 1
a143 9
	/* Don't handle 3D transfers yet.
	 */
	assert(box->depth == 1);


	pipe_resource_reference(&tx->base.resource, pt);
	tx->base.level = level;
	tx->base.usage = usage;
	tx->base.box = *box;
d146 2
d157 3
a159 3
	tx->level_z = boxz;
	tx->level_x = util_format_get_nblocksx(pt->format, box->x);
	tx->level_y = util_format_get_nblocksy(pt->format, box->y);
d168 2
a169 2
		nx = util_format_get_nblocksx(pt->format, box->width);
		ny = util_format_get_nblocksy(pt->format, box->height);
d173 1
a173 1
					box->x, box->y, boxz,
d188 2
a189 3
void
nv50_miptree_transfer_del(struct pipe_context *pcontext,
			  struct pipe_transfer *ptx)
d192 2
a193 2
	struct nv50_miptree *mt = nv50_miptree(ptx->resource);
	struct pipe_resource *pt = ptx->resource;
d195 2
a196 2
	unsigned nx = util_format_get_nblocksx(pt->format, tx->base.box.width);
	unsigned ny = util_format_get_nblocksy(pt->format, tx->base.box.height);
d199 1
a199 1
		struct pipe_screen *pscreen = pcontext->screen;
d216 1
a216 1
	pipe_resource_reference(&ptx->resource, NULL);
d220 2
a221 3
void *
nv50_miptree_transfer_map(struct pipe_context *pcontext,
			  struct pipe_transfer *ptx)
a226 3
	if (tx->map_refcnt++)
		return tx->bo->map;

d233 1
a233 2
	if (ret) {
		tx->map_refcnt = 0;
a234 1
	}
d238 2
a239 3
void
nv50_miptree_transfer_unmap(struct pipe_context *pcontext,
			    struct pipe_transfer *ptx)
a242 2
	if (--tx->map_refcnt)
		return;
d246 8
d264 1
d271 1
a271 1
	if (nouveau_bo_tile_layout(bo)) {
d334 1
a334 1
		src = (uint8_t *) src + src_pitch;
d336 3
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d2 2
d5 1
d8 2
a9 2

#include "nv50_defs.xml.h"
d12 14
a25 4
   struct pipe_transfer base;
   struct nv50_m2mf_rect rect[2];
   uint32_t nblocksx;
   uint32_t nblocksy;
d28 10
a37 4
void
nv50_m2mf_rect_setup(struct nv50_m2mf_rect *rect,
                     struct pipe_resource *restrict res, unsigned l,
                     unsigned x, unsigned y, unsigned z)
d39 85
a123 30
   struct nv50_miptree *mt = nv50_miptree(res);
   const unsigned w = u_minify(res->width0, l);
   const unsigned h = u_minify(res->height0, l);

   rect->bo = mt->base.bo;
   rect->domain = mt->base.domain;
   rect->base = mt->level[l].offset;
   rect->pitch = mt->level[l].pitch;
   if (util_format_is_plain(res->format)) {
      rect->width = w << mt->ms_x;
      rect->height = h << mt->ms_y;
      rect->x = x << mt->ms_x;
      rect->y = y << mt->ms_y;
   } else {
      rect->width = util_format_get_nblocksx(res->format, w);
      rect->height = util_format_get_nblocksy(res->format, h);
      rect->x = util_format_get_nblocksx(res->format, x);
      rect->y = util_format_get_nblocksy(res->format, y);
   }
   rect->tile_mode = mt->level[l].tile_mode;
   rect->cpp = util_format_get_blocksize(res->format);

   if (mt->layout_3d) {
      rect->z = z;
      rect->depth = u_minify(res->depth0, l);
   } else {
      rect->base += z * mt->layer_stride;
      rect->z = 0;
      rect->depth = 1;
   }
d126 6
a131 5
void
nv50_m2mf_transfer_rect(struct nv50_context *nv50,
                        const struct nv50_m2mf_rect *dst,
                        const struct nv50_m2mf_rect *src,
                        uint32_t nblocksx, uint32_t nblocksy)
d133 65
a197 84
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nouveau_bufctx *bctx = nv50->bufctx;
   const int cpp = dst->cpp;
   uint32_t src_ofst = src->base;
   uint32_t dst_ofst = dst->base;
   uint32_t height = nblocksy;
   uint32_t sy = src->y;
   uint32_t dy = dst->y;

   assert(dst->cpp == src->cpp);

   nouveau_bufctx_refn(bctx, 0, src->bo, src->domain | NOUVEAU_BO_RD);
   nouveau_bufctx_refn(bctx, 0, dst->bo, dst->domain | NOUVEAU_BO_WR);
   nouveau_pushbuf_bufctx(push, bctx);
   nouveau_pushbuf_validate(push);

   if (nouveau_bo_memtype(src->bo)) {
      BEGIN_NV04(push, NV50_M2MF(LINEAR_IN), 6);
      PUSH_DATA (push, 0);
      PUSH_DATA (push, src->tile_mode);
      PUSH_DATA (push, src->width * cpp);
      PUSH_DATA (push, src->height);
      PUSH_DATA (push, src->depth);
      PUSH_DATA (push, src->z);
   } else {
      src_ofst += src->y * src->pitch + src->x * cpp;

      BEGIN_NV04(push, NV50_M2MF(LINEAR_IN), 1);
      PUSH_DATA (push, 1);
      BEGIN_NV04(push, SUBC_M2MF(NV03_M2MF_PITCH_IN), 1);
      PUSH_DATA (push, src->pitch);
   }

   if (nouveau_bo_memtype(dst->bo)) {
      BEGIN_NV04(push, NV50_M2MF(LINEAR_OUT), 6);
      PUSH_DATA (push, 0);
      PUSH_DATA (push, dst->tile_mode);
      PUSH_DATA (push, dst->width * cpp);
      PUSH_DATA (push, dst->height);
      PUSH_DATA (push, dst->depth);
      PUSH_DATA (push, dst->z);
   } else {
      dst_ofst += dst->y * dst->pitch + dst->x * cpp;

      BEGIN_NV04(push, NV50_M2MF(LINEAR_OUT), 1);
      PUSH_DATA (push, 1);
      BEGIN_NV04(push, SUBC_M2MF(NV03_M2MF_PITCH_OUT), 1);
      PUSH_DATA (push, dst->pitch);
   }

   while (height) {
      int line_count = height > 2047 ? 2047 : height;

      BEGIN_NV04(push, NV50_M2MF(OFFSET_IN_HIGH), 2);
      PUSH_DATAh(push, src->bo->offset + src_ofst);
      PUSH_DATAh(push, dst->bo->offset + dst_ofst);

      BEGIN_NV04(push, SUBC_M2MF(NV03_M2MF_OFFSET_IN), 2);
      PUSH_DATA (push, src->bo->offset + src_ofst);
      PUSH_DATA (push, dst->bo->offset + dst_ofst);

      if (nouveau_bo_memtype(src->bo)) {
         BEGIN_NV04(push, NV50_M2MF(TILING_POSITION_IN), 1);
         PUSH_DATA (push, (sy << 16) | (src->x * cpp));
      } else {
         src_ofst += line_count * src->pitch;
      }
      if (nouveau_bo_memtype(dst->bo)) {
         BEGIN_NV04(push, NV50_M2MF(TILING_POSITION_OUT), 1);
         PUSH_DATA (push, (dy << 16) | (dst->x * cpp));
      } else {
         dst_ofst += line_count * dst->pitch;
      }

      BEGIN_NV04(push, SUBC_M2MF(NV03_M2MF_LINE_LENGTH_IN), 4);
      PUSH_DATA (push, nblocksx * cpp);
      PUSH_DATA (push, line_count);
      PUSH_DATA (push, (1 << 8) | (1 << 0));
      PUSH_DATA (push, 0);

      height -= line_count;
      sy += line_count;
      dy += line_count;
   }
d199 1
a199 1
   nouveau_bufctx_reset(bctx, 0);
d203 2
a204 3
nv50_sifc_linear_u8(struct nouveau_context *nv,
                    struct nouveau_bo *dst, unsigned offset, unsigned domain,
                    unsigned size, const void *data)
d206 27
a232 96
   struct nv50_context *nv50 = nv50_context(&nv->pipe);
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   uint32_t *src = (uint32_t *)data;
   unsigned count = (size + 3) / 4;
   unsigned xcoord = offset & 0xff;

   nouveau_bufctx_refn(nv50->bufctx, 0, dst, domain | NOUVEAU_BO_WR);
   nouveau_pushbuf_bufctx(push, nv50->bufctx);
   nouveau_pushbuf_validate(push);

   offset &= ~0xff;

   BEGIN_NV04(push, NV50_2D(DST_FORMAT), 2);
   PUSH_DATA (push, NV50_SURFACE_FORMAT_R8_UNORM);
   PUSH_DATA (push, 1);
   BEGIN_NV04(push, NV50_2D(DST_PITCH), 5);
   PUSH_DATA (push, 262144);
   PUSH_DATA (push, 65536);
   PUSH_DATA (push, 1);
   PUSH_DATAh(push, dst->offset + offset);
   PUSH_DATA (push, dst->offset + offset);
   BEGIN_NV04(push, NV50_2D(SIFC_BITMAP_ENABLE), 2);
   PUSH_DATA (push, 0);
   PUSH_DATA (push, NV50_SURFACE_FORMAT_R8_UNORM);
   BEGIN_NV04(push, NV50_2D(SIFC_WIDTH), 10);
   PUSH_DATA (push, size);
   PUSH_DATA (push, 1);
   PUSH_DATA (push, 0);
   PUSH_DATA (push, 1);
   PUSH_DATA (push, 0);
   PUSH_DATA (push, 1);
   PUSH_DATA (push, 0);
   PUSH_DATA (push, xcoord);
   PUSH_DATA (push, 0);
   PUSH_DATA (push, 0);

   while (count) {
      unsigned nr;

      if (!PUSH_SPACE(push, 16))
         break;
      nr = PUSH_AVAIL(push);
      assert(nr >= 16);
      nr = MIN2(count, nr - 1);
      nr = MIN2(nr, NV04_PFIFO_MAX_PACKET_LEN);

      BEGIN_NI04(push, NV50_2D(SIFC_DATA), nr);
      PUSH_DATAp(push, src, nr);

      src += nr;
      count -= nr;
   }

   nouveau_bufctx_reset(nv50->bufctx, 0);
}

void
nv50_m2mf_copy_linear(struct nouveau_context *nv,
                      struct nouveau_bo *dst, unsigned dstoff, unsigned dstdom,
                      struct nouveau_bo *src, unsigned srcoff, unsigned srcdom,
                      unsigned size)
{
   struct nouveau_pushbuf *push = nv->pushbuf;
   struct nouveau_bufctx *bctx = nv50_context(&nv->pipe)->bufctx;

   nouveau_bufctx_refn(bctx, 0, src, srcdom | NOUVEAU_BO_RD);
   nouveau_bufctx_refn(bctx, 0, dst, dstdom | NOUVEAU_BO_WR);
   nouveau_pushbuf_bufctx(push, bctx);
   nouveau_pushbuf_validate(push);

   BEGIN_NV04(push, NV50_M2MF(LINEAR_IN), 1);
   PUSH_DATA (push, 1);
   BEGIN_NV04(push, NV50_M2MF(LINEAR_OUT), 1);
   PUSH_DATA (push, 1);

   while (size) {
      unsigned bytes = MIN2(size, 1 << 17);

      BEGIN_NV04(push, NV50_M2MF(OFFSET_IN_HIGH), 2);
      PUSH_DATAh(push, src->offset + srcoff);
      PUSH_DATAh(push, dst->offset + dstoff);
      BEGIN_NV04(push, SUBC_M2MF(NV03_M2MF_OFFSET_IN), 2);
      PUSH_DATA (push, src->offset + srcoff);
      PUSH_DATA (push, dst->offset + dstoff);
      BEGIN_NV04(push, SUBC_M2MF(NV03_M2MF_LINE_LENGTH_IN), 4);
      PUSH_DATA (push, bytes);
      PUSH_DATA (push, 1);
      PUSH_DATA (push, (1 << 8) | (1 << 0));
      PUSH_DATA (push, 0);

      srcoff += bytes;
      dstoff += bytes;
      size -= bytes;
   }

   nouveau_bufctx_reset(bctx, 0);
d236 2
a237 6
nv50_miptree_transfer_map(struct pipe_context *pctx,
                          struct pipe_resource *res,
                          unsigned level,
                          unsigned usage,
                          const struct pipe_box *box,
                          struct pipe_transfer **ptransfer)
d239 18
a256 88
   struct nv50_screen *screen = nv50_screen(pctx->screen);
   struct nv50_context *nv50 = nv50_context(pctx);
   struct nouveau_device *dev = nv50->screen->base.device;
   const struct nv50_miptree *mt = nv50_miptree(res);
   struct nv50_transfer *tx;
   uint32_t size;
   int ret;
   unsigned flags = 0;

   if (usage & PIPE_TRANSFER_MAP_DIRECTLY)
      return NULL;

   tx = CALLOC_STRUCT(nv50_transfer);
   if (!tx)
      return NULL;

   pipe_resource_reference(&tx->base.resource, res);

   tx->base.level = level;
   tx->base.usage = usage;
   tx->base.box = *box;

   if (util_format_is_plain(res->format)) {
      tx->nblocksx = box->width << mt->ms_x;
      tx->nblocksy = box->height << mt->ms_x;
   } else {
      tx->nblocksx = util_format_get_nblocksx(res->format, box->width);
      tx->nblocksy = util_format_get_nblocksy(res->format, box->height);
   }

   tx->base.stride = tx->nblocksx * util_format_get_blocksize(res->format);
   tx->base.layer_stride = tx->nblocksy * tx->base.stride;

   nv50_m2mf_rect_setup(&tx->rect[0], res, level, box->x, box->y, box->z);

   size = tx->base.layer_stride;

   ret = nouveau_bo_new(dev, NOUVEAU_BO_GART | NOUVEAU_BO_MAP, 0,
                        size * tx->base.box.depth, NULL, &tx->rect[1].bo);
   if (ret) {
      FREE(tx);
      return NULL;
   }

   tx->rect[1].cpp = tx->rect[0].cpp;
   tx->rect[1].width = tx->nblocksx;
   tx->rect[1].height = tx->nblocksy;
   tx->rect[1].depth = 1;
   tx->rect[1].pitch = tx->base.stride;
   tx->rect[1].domain = NOUVEAU_BO_GART;

   if (usage & PIPE_TRANSFER_READ) {
      unsigned base = tx->rect[0].base;
      unsigned z = tx->rect[0].z;
      unsigned i;
      for (i = 0; i < box->depth; ++i) {
         nv50_m2mf_transfer_rect(nv50, &tx->rect[1], &tx->rect[0],
                                 tx->nblocksx, tx->nblocksy);
         if (mt->layout_3d)
            tx->rect[0].z++;
         else
            tx->rect[0].base += mt->layer_stride;
         tx->rect[1].base += size;
      }
      tx->rect[0].z = z;
      tx->rect[0].base = base;
      tx->rect[1].base = 0;
   }

   if (tx->rect[1].bo->map) {
      *ptransfer = &tx->base;
      return tx->rect[1].bo->map;
   }

   if (usage & PIPE_TRANSFER_READ)
      flags = NOUVEAU_BO_RD;
   if (usage & PIPE_TRANSFER_WRITE)
      flags |= NOUVEAU_BO_WR;

   ret = nouveau_bo_map(tx->rect[1].bo, flags, screen->base.client);
   if (ret) {
      nouveau_bo_ref(NULL, &tx->rect[1].bo);
      FREE(tx);
      return NULL;
   }

   *ptransfer = &tx->base;
   return tx->rect[1].bo->map;
d260 2
a261 2
nv50_miptree_transfer_unmap(struct pipe_context *pctx,
                            struct pipe_transfer *transfer)
d263 1
a263 16
   struct nv50_context *nv50 = nv50_context(pctx);
   struct nv50_transfer *tx = (struct nv50_transfer *)transfer;
   struct nv50_miptree *mt = nv50_miptree(tx->base.resource);
   unsigned i;

   if (tx->base.usage & PIPE_TRANSFER_WRITE) {
      for (i = 0; i < tx->base.box.depth; ++i) {
         nv50_m2mf_transfer_rect(nv50, &tx->rect[0], &tx->rect[1],
                                 tx->nblocksx, tx->nblocksy);
         if (mt->layout_3d)
            tx->rect[0].z++;
         else
            tx->rect[0].base += mt->layer_stride;
         tx->rect[1].base += tx->nblocksy * tx->base.stride;
      }
   }
d265 4
a268 2
   nouveau_bo_ref(NULL, &tx->rect[1].bo);
   pipe_resource_reference(&transfer->resource, NULL);
a269 2
   FREE(tx);
}
d272 5
a276 4
nv50_cb_push(struct nouveau_context *nv,
             struct nouveau_bo *bo, unsigned domain,
             unsigned base, unsigned size,
             unsigned offset, unsigned words, const uint32_t *data)
d278 70
a347 30
   struct nouveau_pushbuf *push = nv->pushbuf;
   struct nouveau_bufctx *bctx = nv50_context(&nv->pipe)->bufctx;

   assert(!(offset & 3));
   size = align(size, 0x100);

   nouveau_bufctx_refn(bctx, 0, bo, NOUVEAU_BO_WR | domain);
   nouveau_pushbuf_bufctx(push, bctx);
   nouveau_pushbuf_validate(push);

   while (words) {
      unsigned nr;

      nr = PUSH_AVAIL(push);
      nr = MIN2(nr - 7, words);
      nr = MIN2(nr, NV04_PFIFO_MAX_PACKET_LEN - 1);

      BEGIN_NV04(push, NV50_3D(CB_DEF_ADDRESS_HIGH), 3);
      PUSH_DATAh(push, bo->offset + base);
      PUSH_DATA (push, bo->offset + base);
      PUSH_DATA (push, (NV50_CB_TMP << 16) | (size & 0xffff));
      BEGIN_NV04(push, NV50_3D(CB_ADDR), 1);
      PUSH_DATA (push, (offset << 6) | NV50_CB_TMP);
      BEGIN_NI04(push, NV50_3D(CB_DATA(0)), nr);
      PUSH_DATAp(push, data, nr);

      words -= nr;
      data += nr;
      offset += nr * 4;
   }
d349 2
a350 1
   nouveau_bufctx_reset(bctx, 0);
@


