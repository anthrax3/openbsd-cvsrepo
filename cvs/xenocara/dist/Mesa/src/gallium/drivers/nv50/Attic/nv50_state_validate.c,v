head	1.6;
access;
symbols
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.07.09.21.08.54;	author jsg;	state dead;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2014.01.19.03.13.15;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.09.05.14.00.44;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.42;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.01.19.03.03.45;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@
#include "nv50_context.h"
#include "os/os_time.h"

static void
nv50_validate_fb(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct pipe_framebuffer_state *fb = &nv50->framebuffer;
   unsigned i;
   unsigned ms_mode = NV50_3D_MULTISAMPLE_MODE_MS1;
   uint32_t array_size = 0xffff, array_mode = 0;

   nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_FB);

   BEGIN_NV04(push, NV50_3D(RT_CONTROL), 1);
   PUSH_DATA (push, (076543210 << 4) | fb->nr_cbufs);
   BEGIN_NV04(push, NV50_3D(SCREEN_SCISSOR_HORIZ), 2);
   PUSH_DATA (push, fb->width << 16);
   PUSH_DATA (push, fb->height << 16);

   for (i = 0; i < fb->nr_cbufs; ++i) {
      struct nv50_miptree *mt = nv50_miptree(fb->cbufs[i]->texture);
      struct nv50_surface *sf = nv50_surface(fb->cbufs[i]);
      struct nouveau_bo *bo = mt->base.bo;

      array_size = MIN2(array_size, sf->depth);
      if (mt->layout_3d)
         array_mode = NV50_3D_RT_ARRAY_MODE_MODE_3D; /* 1 << 16 */

      /* can't mix 3D with ARRAY or have RTs of different depth/array_size */
      assert(mt->layout_3d || !array_mode || array_size == 1);

      BEGIN_NV04(push, NV50_3D(RT_ADDRESS_HIGH(i)), 5);
      PUSH_DATAh(push, bo->offset + sf->offset);
      PUSH_DATA (push, bo->offset + sf->offset);
      PUSH_DATA (push, nv50_format_table[sf->base.format].rt);
      if (likely(nouveau_bo_memtype(bo))) {
         PUSH_DATA (push, mt->level[sf->base.u.tex.level].tile_mode);
         PUSH_DATA (push, mt->layer_stride >> 2);
         BEGIN_NV04(push, NV50_3D(RT_HORIZ(i)), 2);
         PUSH_DATA (push, sf->width);
         PUSH_DATA (push, sf->height);
         BEGIN_NV04(push, NV50_3D(RT_ARRAY_MODE), 1);
         PUSH_DATA (push, array_mode | array_size);
      } else {
         PUSH_DATA (push, 0);
         PUSH_DATA (push, 0);
         BEGIN_NV04(push, NV50_3D(RT_HORIZ(i)), 2);
         PUSH_DATA (push, NV50_3D_RT_HORIZ_LINEAR | mt->level[0].pitch);
         PUSH_DATA (push, sf->height);
         BEGIN_NV04(push, NV50_3D(RT_ARRAY_MODE), 1);
         PUSH_DATA (push, 0);

         assert(!fb->zsbuf);
         assert(!mt->ms_mode);
      }

      ms_mode = mt->ms_mode;

      if (mt->base.status & NOUVEAU_BUFFER_STATUS_GPU_READING)
         nv50->state.rt_serialize = TRUE;
      mt->base.status |= NOUVEAU_BUFFER_STATUS_GPU_WRITING;
      mt->base.status &= ~NOUVEAU_BUFFER_STATUS_GPU_READING;

      /* only register for writing, otherwise we'd always serialize here */
      BCTX_REFN(nv50->bufctx_3d, FB, &mt->base, WR);
   }

   if (fb->zsbuf) {
      struct nv50_miptree *mt = nv50_miptree(fb->zsbuf->texture);
      struct nv50_surface *sf = nv50_surface(fb->zsbuf);
      struct nouveau_bo *bo = mt->base.bo;
      int unk = mt->base.base.target == PIPE_TEXTURE_3D || sf->depth == 1;

      BEGIN_NV04(push, NV50_3D(ZETA_ADDRESS_HIGH), 5);
      PUSH_DATAh(push, bo->offset + sf->offset);
      PUSH_DATA (push, bo->offset + sf->offset);
      PUSH_DATA (push, nv50_format_table[fb->zsbuf->format].rt);
      PUSH_DATA (push, mt->level[sf->base.u.tex.level].tile_mode);
      PUSH_DATA (push, mt->layer_stride >> 2);
      BEGIN_NV04(push, NV50_3D(ZETA_ENABLE), 1);
      PUSH_DATA (push, 1);
      BEGIN_NV04(push, NV50_3D(ZETA_HORIZ), 3);
      PUSH_DATA (push, sf->width);
      PUSH_DATA (push, sf->height);
      PUSH_DATA (push, (unk << 16) | sf->depth);

      ms_mode = mt->ms_mode;

      if (mt->base.status & NOUVEAU_BUFFER_STATUS_GPU_READING)
         nv50->state.rt_serialize = TRUE;
      mt->base.status |= NOUVEAU_BUFFER_STATUS_GPU_WRITING;
      mt->base.status &= ~NOUVEAU_BUFFER_STATUS_GPU_READING;

      BCTX_REFN(nv50->bufctx_3d, FB, &mt->base, WR);
   } else {
      BEGIN_NV04(push, NV50_3D(ZETA_ENABLE), 1);
      PUSH_DATA (push, 0);
   }

   BEGIN_NV04(push, NV50_3D(MULTISAMPLE_MODE), 1);
   PUSH_DATA (push, ms_mode);

   BEGIN_NV04(push, NV50_3D(VIEWPORT_HORIZ(0)), 2);
   PUSH_DATA (push, fb->width << 16);
   PUSH_DATA (push, fb->height << 16);
}

static void
nv50_validate_blend_colour(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;

   BEGIN_NV04(push, NV50_3D(BLEND_COLOR(0)), 4);
   PUSH_DATAf(push, nv50->blend_colour.color[0]);
   PUSH_DATAf(push, nv50->blend_colour.color[1]);
   PUSH_DATAf(push, nv50->blend_colour.color[2]);
   PUSH_DATAf(push, nv50->blend_colour.color[3]);
}

static void
nv50_validate_stencil_ref(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;

   BEGIN_NV04(push, NV50_3D(STENCIL_FRONT_FUNC_REF), 1);
   PUSH_DATA (push, nv50->stencil_ref.ref_value[0]);
   BEGIN_NV04(push, NV50_3D(STENCIL_BACK_FUNC_REF), 1);
   PUSH_DATA (push, nv50->stencil_ref.ref_value[1]);
}

static void
nv50_validate_stipple(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   unsigned i;

   BEGIN_NV04(push, NV50_3D(POLYGON_STIPPLE_PATTERN(0)), 32);
   for (i = 0; i < 32; ++i)
      PUSH_DATA(push, util_bswap32(nv50->stipple.stipple[i]));
}

static void
nv50_validate_scissor(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct pipe_scissor_state *s = &nv50->scissor;
#ifdef NV50_SCISSORS_CLIPPING
   struct pipe_viewport_state *vp = &nv50->viewport;
   int minx, maxx, miny, maxy;

   if (!(nv50->dirty &
         (NV50_NEW_SCISSOR | NV50_NEW_VIEWPORT | NV50_NEW_FRAMEBUFFER)) &&
       nv50->state.scissor == nv50->rast->pipe.scissor)
      return;
   nv50->state.scissor = nv50->rast->pipe.scissor;

   if (nv50->state.scissor) {
      minx = s->minx;
      maxx = s->maxx;
      miny = s->miny;
      maxy = s->maxy;
   } else {
      minx = 0;
      maxx = nv50->framebuffer.width;
      miny = 0;
      maxy = nv50->framebuffer.height;
   }

   minx = MAX2(minx, (int)(vp->translate[0] - fabsf(vp->scale[0])));
   maxx = MIN2(maxx, (int)(vp->translate[0] + fabsf(vp->scale[0])));
   miny = MAX2(miny, (int)(vp->translate[1] - fabsf(vp->scale[1])));
   maxy = MIN2(maxy, (int)(vp->translate[1] + fabsf(vp->scale[1])));

   BEGIN_NV04(push, NV50_3D(SCISSOR_HORIZ(0)), 2);
   PUSH_DATA (push, (maxx << 16) | minx);
   PUSH_DATA (push, (maxy << 16) | miny);
#else
   BEGIN_NV04(push, NV50_3D(SCISSOR_HORIZ(0)), 2);
   PUSH_DATA (push, (s->maxx << 16) | s->minx);
   PUSH_DATA (push, (s->maxy << 16) | s->miny);
#endif
}

static void
nv50_validate_viewport(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   float zmin, zmax;

   BEGIN_NV04(push, NV50_3D(VIEWPORT_TRANSLATE_X(0)), 3);
   PUSH_DATAf(push, nv50->viewport.translate[0]);
   PUSH_DATAf(push, nv50->viewport.translate[1]);
   PUSH_DATAf(push, nv50->viewport.translate[2]);
   BEGIN_NV04(push, NV50_3D(VIEWPORT_SCALE_X(0)), 3);
   PUSH_DATAf(push, nv50->viewport.scale[0]);
   PUSH_DATAf(push, nv50->viewport.scale[1]);
   PUSH_DATAf(push, nv50->viewport.scale[2]);

   zmin = nv50->viewport.translate[2] - fabsf(nv50->viewport.scale[2]);
   zmax = nv50->viewport.translate[2] + fabsf(nv50->viewport.scale[2]);

#ifdef NV50_SCISSORS_CLIPPING
   BEGIN_NV04(push, NV50_3D(DEPTH_RANGE_NEAR(0)), 2);
   PUSH_DATAf(push, zmin);
   PUSH_DATAf(push, zmax);
#endif
}

static INLINE void
nv50_check_program_ucps(struct nv50_context *nv50,
                        struct nv50_program *vp, uint8_t mask)
{
   const unsigned n = util_logbase2(mask) + 1;

   if (vp->vp.clpd_nr >= n)
      return;
   nv50_program_destroy(nv50, vp);

   vp->vp.clpd_nr = n;
   if (likely(vp == nv50->vertprog)) {
      nv50->dirty |= NV50_NEW_VERTPROG;
      nv50_vertprog_validate(nv50);
   } else {
      nv50->dirty |= NV50_NEW_GMTYPROG;
      nv50_gmtyprog_validate(nv50);
   }
   nv50_fp_linkage_validate(nv50);
}

static void
nv50_validate_clip(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nv50_program *vp;
   uint8_t clip_enable;

   if (nv50->dirty & NV50_NEW_CLIP) {
      BEGIN_NV04(push, NV50_3D(CB_ADDR), 1);
      PUSH_DATA (push, (0 << 8) | NV50_CB_AUX);
      BEGIN_NI04(push, NV50_3D(CB_DATA(0)), PIPE_MAX_CLIP_PLANES * 4);
      PUSH_DATAp(push, &nv50->clip.ucp[0][0], PIPE_MAX_CLIP_PLANES * 4);
   }

   vp = nv50->gmtyprog;
   if (likely(!vp))
      vp = nv50->vertprog;

   clip_enable = nv50->rast->pipe.clip_plane_enable;

   BEGIN_NV04(push, NV50_3D(CLIP_DISTANCE_ENABLE), 1);
   PUSH_DATA (push, clip_enable);

   if (clip_enable)
      nv50_check_program_ucps(nv50, vp, clip_enable);
}

static void
nv50_validate_blend(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;

   PUSH_SPACE(push, nv50->blend->size);
   PUSH_DATAp(push, nv50->blend->state, nv50->blend->size);
}

static void
nv50_validate_zsa(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;

   PUSH_SPACE(push, nv50->zsa->size);
   PUSH_DATAp(push, nv50->zsa->state, nv50->zsa->size);
}

static void
nv50_validate_rasterizer(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;

   PUSH_SPACE(push, nv50->rast->size);
   PUSH_DATAp(push, nv50->rast->state, nv50->rast->size);
}

static void
nv50_validate_sample_mask(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;

   unsigned mask[4] =
   {
      nv50->sample_mask & 0xffff,
      nv50->sample_mask & 0xffff,
      nv50->sample_mask & 0xffff,
      nv50->sample_mask & 0xffff
   };

   BEGIN_NV04(push, NV50_3D(MSAA_MASK(0)), 4);
   PUSH_DATA (push, mask[0]);
   PUSH_DATA (push, mask[1]);
   PUSH_DATA (push, mask[2]);
   PUSH_DATA (push, mask[3]);
}

static void
nv50_switch_pipe_context(struct nv50_context *ctx_to)
{
   struct nv50_context *ctx_from = ctx_to->screen->cur_ctx;

   if (ctx_from)
      ctx_to->state = ctx_from->state;

   ctx_to->dirty = ~0;

   if (!ctx_to->vertex)
      ctx_to->dirty &= ~(NV50_NEW_VERTEX | NV50_NEW_ARRAYS);

   if (!ctx_to->vertprog)
      ctx_to->dirty &= ~NV50_NEW_VERTPROG;
   if (!ctx_to->fragprog)
      ctx_to->dirty &= ~NV50_NEW_FRAGPROG;

   if (!ctx_to->blend)
      ctx_to->dirty &= ~NV50_NEW_BLEND;
   if (!ctx_to->rast)
#ifdef NV50_SCISSORS_CLIPPING
      ctx_to->dirty &= ~(NV50_NEW_RASTERIZER | NV50_NEW_SCISSOR);
#else
      ctx_to->dirty &= ~NV50_NEW_RASTERIZER;
#endif
   if (!ctx_to->zsa)
      ctx_to->dirty &= ~NV50_NEW_ZSA;

   ctx_to->screen->cur_ctx = ctx_to;
}

static struct state_validate {
    void (*func)(struct nv50_context *);
    uint32_t states;
} validate_list[] = {
    { nv50_validate_fb,            NV50_NEW_FRAMEBUFFER },
    { nv50_validate_blend,         NV50_NEW_BLEND },
    { nv50_validate_zsa,           NV50_NEW_ZSA },
    { nv50_validate_sample_mask,   NV50_NEW_SAMPLE_MASK },
    { nv50_validate_rasterizer,    NV50_NEW_RASTERIZER },
    { nv50_validate_blend_colour,  NV50_NEW_BLEND_COLOUR },
    { nv50_validate_stencil_ref,   NV50_NEW_STENCIL_REF },
    { nv50_validate_stipple,       NV50_NEW_STIPPLE },
#ifdef NV50_SCISSORS_CLIPPING
    { nv50_validate_scissor,       NV50_NEW_SCISSOR | NV50_NEW_VIEWPORT |
                                   NV50_NEW_RASTERIZER |
                                   NV50_NEW_FRAMEBUFFER },
#else
    { nv50_validate_scissor,       NV50_NEW_SCISSOR },
#endif
    { nv50_validate_viewport,      NV50_NEW_VIEWPORT },
    { nv50_vertprog_validate,      NV50_NEW_VERTPROG },
    { nv50_gmtyprog_validate,      NV50_NEW_GMTYPROG },
    { nv50_fragprog_validate,      NV50_NEW_FRAGPROG },
    { nv50_fp_linkage_validate,    NV50_NEW_FRAGPROG | NV50_NEW_VERTPROG |
                                   NV50_NEW_GMTYPROG | NV50_NEW_RASTERIZER },
    { nv50_gp_linkage_validate,    NV50_NEW_GMTYPROG | NV50_NEW_VERTPROG },
    { nv50_validate_derived_rs,    NV50_NEW_FRAGPROG | NV50_NEW_RASTERIZER |
                                   NV50_NEW_VERTPROG | NV50_NEW_GMTYPROG },
    { nv50_validate_clip,          NV50_NEW_CLIP | NV50_NEW_RASTERIZER |
                                   NV50_NEW_VERTPROG | NV50_NEW_GMTYPROG },
    { nv50_constbufs_validate,     NV50_NEW_CONSTBUF },
    { nv50_validate_textures,      NV50_NEW_TEXTURES },
    { nv50_validate_samplers,      NV50_NEW_SAMPLERS },
    { nv50_stream_output_validate, NV50_NEW_STRMOUT |
                                   NV50_NEW_VERTPROG | NV50_NEW_GMTYPROG },
    { nv50_vertex_arrays_validate, NV50_NEW_VERTEX | NV50_NEW_ARRAYS }
};
#define validate_list_len (sizeof(validate_list) / sizeof(validate_list[0]))

boolean
nv50_state_validate(struct nv50_context *nv50, uint32_t mask, unsigned words)
{
   uint32_t state_mask;
   int ret;
   unsigned i;

   if (nv50->screen->cur_ctx != nv50)
      nv50_switch_pipe_context(nv50);

   state_mask = nv50->dirty & mask;

   if (state_mask) {
      for (i = 0; i < validate_list_len; ++i) {
         struct state_validate *validate = &validate_list[i];

         if (state_mask & validate->states)
            validate->func(nv50);
      }
      nv50->dirty &= ~state_mask;

      if (nv50->state.rt_serialize) {
         nv50->state.rt_serialize = FALSE;
         BEGIN_NV04(nv50->base.pushbuf, SUBC_3D(NV50_GRAPH_SERIALIZE), 1);
         PUSH_DATA (nv50->base.pushbuf, 0);
      }

      nv50_bufctx_fence(nv50->bufctx_3d, FALSE);
   }
   nouveau_pushbuf_bufctx(nv50->base.pushbuf, nv50->bufctx_3d);
   ret = nouveau_pushbuf_validate(nv50->base.pushbuf);

   if (unlikely(nv50->state.flushed)) {
      nv50->state.flushed = FALSE;
      nv50_bufctx_fence(nv50->bufctx_3d, TRUE);
   }
   return !ret;
}
@


1.5
log
@Merge Mesa 9.2.5
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d64 1
a64 1
      mt->base.status &= NOUVEAU_BUFFER_STATUS_GPU_READING;
d94 1
a94 1
      mt->base.status &= NOUVEAU_BUFFER_STATUS_GPU_READING;
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d8 1
a8 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d11 2
a12 1
   boolean serialize = FALSE;
d14 1
a14 1
   nv50_bufctx_reset(nv50, NV50_BUFCTX_FRAME);
d16 5
a20 7
   BEGIN_RING(chan, RING_3D(RT_CONTROL), 1);
   OUT_RING  (chan, (076543210 << 4) | fb->nr_cbufs);
   BEGIN_RING(chan, RING_3D(SCREEN_SCISSOR_HORIZ), 2);
   OUT_RING  (chan, fb->width << 16);
   OUT_RING  (chan, fb->height << 16);

   MARK_RING(chan, 9 * fb->nr_cbufs, 2 * fb->nr_cbufs);
a25 1
      uint32_t offset = sf->offset;
d27 33
a59 11
      BEGIN_RING(chan, RING_3D(RT_ADDRESS_HIGH(i)), 5);
      OUT_RELOCh(chan, bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR);
      OUT_RELOCl(chan, bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR);
      OUT_RING  (chan, nv50_format_table[sf->base.format].rt);
      OUT_RING  (chan, mt->level[sf->base.u.tex.level].tile_mode << 4);
      OUT_RING  (chan, mt->layer_stride >> 2);
      BEGIN_RING(chan, RING_3D(RT_HORIZ(i)), 2);
      OUT_RING  (chan, sf->width);
      OUT_RING  (chan, sf->height);
      BEGIN_RING(chan, RING_3D(RT_ARRAY_MODE), 1);
      OUT_RING  (chan, sf->depth);
d62 1
a62 1
         serialize = TRUE;
d67 1
a67 2
      nv50_bufctx_add_resident(nv50, NV50_BUFCTX_FRAME, &mt->base,
                               NOUVEAU_BO_VRAM | NOUVEAU_BO_WR);
d74 14
a87 2
      int unk = mt->base.base.target == PIPE_TEXTURE_2D;
      uint32_t offset = sf->offset;
d89 1
a89 13
      MARK_RING (chan, 12, 2);
      BEGIN_RING(chan, RING_3D(ZETA_ADDRESS_HIGH), 5);
      OUT_RELOCh(chan, bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR);
      OUT_RELOCl(chan, bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR);
      OUT_RING  (chan, nv50_format_table[fb->zsbuf->format].rt);
      OUT_RING  (chan, mt->level[sf->base.u.tex.level].tile_mode << 4);
      OUT_RING  (chan, mt->layer_stride >> 2);
      BEGIN_RING(chan, RING_3D(ZETA_ENABLE), 1);
      OUT_RING  (chan, 1);
      BEGIN_RING(chan, RING_3D(ZETA_HORIZ), 3);
      OUT_RING  (chan, sf->width);
      OUT_RING  (chan, sf->height);
      OUT_RING  (chan, (unk << 16) | sf->depth);
d92 1
a92 1
         serialize = TRUE;
d96 1
a96 2
      nv50_bufctx_add_resident(nv50, NV50_BUFCTX_FRAME, &mt->base,
                               NOUVEAU_BO_VRAM | NOUVEAU_BO_WR);
d98 2
a99 2
      BEGIN_RING(chan, RING_3D(ZETA_ENABLE), 1);
      OUT_RING  (chan, 0);
d102 6
a107 8
   BEGIN_RING(chan, RING_3D(VIEWPORT_HORIZ(0)), 2);
   OUT_RING  (chan, fb->width << 16);
   OUT_RING  (chan, fb->height << 16);

   if (serialize) {
      BEGIN_RING(chan, RING_3D(SERIALIZE), 1);
      OUT_RING  (chan, 0);
   }
d113 1
a113 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d115 5
a119 5
   BEGIN_RING(chan, RING_3D(BLEND_COLOR(0)), 4);
   OUT_RINGf (chan, nv50->blend_colour.color[0]);
   OUT_RINGf (chan, nv50->blend_colour.color[1]);
   OUT_RINGf (chan, nv50->blend_colour.color[2]);
   OUT_RINGf (chan, nv50->blend_colour.color[3]);    
d125 1
a125 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d127 4
a130 4
   BEGIN_RING(chan, RING_3D(STENCIL_FRONT_FUNC_REF), 1);
   OUT_RING  (chan, nv50->stencil_ref.ref_value[0]);
   BEGIN_RING(chan, RING_3D(STENCIL_BACK_FUNC_REF), 1);
   OUT_RING  (chan, nv50->stencil_ref.ref_value[1]);
d136 1
a136 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d139 1
a139 1
   BEGIN_RING(chan, RING_3D(POLYGON_STIPPLE_PATTERN(0)), 32);
d141 1
a141 1
      OUT_RING(chan, util_bswap32(nv50->stipple.stipple[i]));
d147 1
a147 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d176 3
a178 3
   BEGIN_RING(chan, RING_3D(SCISSOR_HORIZ(0)), 2);
   OUT_RING  (chan, (maxx << 16) | minx);
   OUT_RING  (chan, (maxy << 16) | miny);
d180 3
a182 3
   BEGIN_RING(chan, RING_3D(SCISSOR_HORIZ(0)), 2);
   OUT_RING  (chan, (s->maxx << 16) | s->minx);
   OUT_RING  (chan, (s->maxy << 16) | s->miny);
d189 1
a189 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d192 8
a199 8
   BEGIN_RING(chan, RING_3D(VIEWPORT_TRANSLATE_X(0)), 3);
   OUT_RINGf (chan, nv50->viewport.translate[0]);
   OUT_RINGf (chan, nv50->viewport.translate[1]);
   OUT_RINGf (chan, nv50->viewport.translate[2]);
   BEGIN_RING(chan, RING_3D(VIEWPORT_SCALE_X(0)), 3);
   OUT_RINGf (chan, nv50->viewport.scale[0]);
   OUT_RINGf (chan, nv50->viewport.scale[1]);
   OUT_RINGf (chan, nv50->viewport.scale[2]);
d205 3
a207 3
   BEGIN_RING(chan, RING_3D(DEPTH_RANGE_NEAR(0)), 2);
   OUT_RINGf (chan, zmin);
   OUT_RINGf (chan, zmax);
d211 3
a213 2
static void
nv50_validate_clip(struct nv50_context *nv50)
d215 1
a215 2
   struct nouveau_channel *chan = nv50->screen->base.channel;
   uint32_t clip;
d217 8
a224 5
   if (nv50->clip.depth_clamp) {
      clip =
         NV50_3D_VIEW_VOLUME_CLIP_CTRL_DEPTH_CLAMP_NEAR |
         NV50_3D_VIEW_VOLUME_CLIP_CTRL_DEPTH_CLAMP_FAR |
         NV50_3D_VIEW_VOLUME_CLIP_CTRL_UNK12_UNK1;
d226 2
a227 1
      clip = 0;
d229 2
d232 13
a244 5
#ifndef NV50_SCISSORS_CLIPPING
   clip |=
      NV50_3D_VIEW_VOLUME_CLIP_CTRL_UNK7 |
      NV50_3D_VIEW_VOLUME_CLIP_CTRL_UNK12_UNK1;
#endif
d246 3
a248 2
   BEGIN_RING(chan, RING_3D(VIEW_VOLUME_CLIP_CTRL), 1);
   OUT_RING  (chan, clip);
d250 1
a250 6
   if (nv50->clip.nr) {
      BEGIN_RING(chan, RING_3D(CB_ADDR), 1);
      OUT_RING  (chan, (0 << 8) | NV50_CB_AUX);
      BEGIN_RING_NI(chan, RING_3D(CB_DATA(0)), nv50->clip.nr * 4);
      OUT_RINGp (chan, &nv50->clip.ucp[0][0], nv50->clip.nr * 4);
   }
d252 2
a253 2
   BEGIN_RING(chan, RING_3D(VP_CLIP_DISTANCE_ENABLE), 1);
   OUT_RING  (chan, (1 << nv50->clip.nr) - 1);
d255 2
a256 2
   if (nv50->vertprog && nv50->clip.nr > nv50->vertprog->vp.clpd_nr)
      nv50->dirty |= NV50_NEW_VERTPROG;
d262 1
a262 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d264 2
a265 2
   WAIT_RING(chan, nv50->blend->size);
   OUT_RINGp(chan, nv50->blend->state, nv50->blend->size);
d271 1
a271 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d273 2
a274 2
   WAIT_RING(chan, nv50->zsa->size);
   OUT_RINGp(chan, nv50->zsa->state, nv50->zsa->size);
d280 1
a280 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d282 22
a303 2
   WAIT_RING(chan, nv50->rast->size);
   OUT_RINGp(chan, nv50->rast->state, nv50->rast->size);
d327 3
d331 1
d345 1
a357 1
    { nv50_validate_clip,          NV50_NEW_CLIP },
d362 1
a362 1
                                   NV50_NEW_GMTYPROG },
d366 2
d371 2
d378 1
a378 1
nv50_state_validate(struct nv50_context *nv50)
d380 2
d387 3
a389 1
   if (nv50->dirty) {
d393 1
a393 1
         if (nv50->dirty & validate->states)
d396 9
a404 1
      nv50->dirty = 0;
d406 2
d409 5
a413 3
   nv50_bufctx_emit_relocs(nv50);

   return TRUE;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a0 23
/*
 * Copyright 2008 Ben Skeggs
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include "util/u_format.h"
d3 1
a3 2
#include "nv50_resource.h"
#include "nouveau/nouveau_stateobj.h"
d5 2
a6 2
static struct nouveau_stateobj *
validate_fb(struct nv50_context *nv50)
d8 85
a92 4
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	struct nouveau_stateobj *so = so_new(32, 79, 18);
	struct pipe_framebuffer_state *fb = &nv50->framebuffer;
	unsigned i, w = 0, h = 0, gw = 0;
d94 4
a97 8
	/* Set nr of active RTs and select RT for each colour output.
	 * FP result 0 always goes to RT[0], bits 4 - 6 are ignored.
	 * Ambiguous assignment results in no rendering (no DATA_ERROR).
	 */
	so_method(so, tesla, NV50TCL_RT_CONTROL, 1);
	so_data  (so, fb->nr_cbufs |
		  (0 <<  4) | (1 <<  7) | (2 << 10) | (3 << 13) |
		  (4 << 16) | (5 << 19) | (6 << 22) | (7 << 25));
d99 6
a104 3
	for (i = 0; i < fb->nr_cbufs; i++) {
		struct pipe_resource *pt = fb->cbufs[i]->texture;
		struct nouveau_bo *bo = nv50_miptree(pt)->base.bo;
d106 4
a109 28
		if (!gw) {
			w = fb->cbufs[i]->width;
			h = fb->cbufs[i]->height;
			gw = 1;
		} else {
			assert(w == fb->cbufs[i]->width);
			assert(h == fb->cbufs[i]->height);
		}

		assert(nv50_format_table[fb->cbufs[i]->format].rt);

		so_method(so, tesla, NV50TCL_RT_HORIZ(i), 2);
		so_data  (so, fb->cbufs[i]->width);
		so_data  (so, fb->cbufs[i]->height);

		so_method(so, tesla, NV50TCL_RT_ADDRESS_HIGH(i), 5);
		so_reloc (so, bo, ((struct nv50_surface *)fb->cbufs[i])->offset, NOUVEAU_BO_VRAM |
			      NOUVEAU_BO_HIGH | NOUVEAU_BO_RDWR, 0, 0);
		so_reloc (so, bo, ((struct nv50_surface *)fb->cbufs[i])->offset, NOUVEAU_BO_VRAM |
			      NOUVEAU_BO_LOW | NOUVEAU_BO_RDWR, 0, 0);
		so_data  (so, nv50_format_table[fb->cbufs[i]->format].rt);
		so_data  (so, nv50_miptree(pt)->
			      level[fb->cbufs[i]->u.tex.level].tile_mode << 4);
		so_data(so, 0x00000000);

		so_method(so, tesla, NV50TCL_RT_ARRAY_MODE, 1);
		so_data  (so, 1);
	}
d111 4
a114 49
	if (fb->zsbuf) {
		struct pipe_resource *pt = fb->zsbuf->texture;
		struct nouveau_bo *bo = nv50_miptree(pt)->base.bo;

		if (!gw) {
			w = fb->zsbuf->width;
			h = fb->zsbuf->height;
			gw = 1;
		} else {
			assert(w == fb->zsbuf->width);
			assert(h == fb->zsbuf->height);
		}

		assert(nv50_format_table[fb->zsbuf->format].rt);

		so_method(so, tesla, NV50TCL_ZETA_ADDRESS_HIGH, 5);
		so_reloc (so, bo, ((struct nv50_surface *)(fb->zsbuf))->offset, NOUVEAU_BO_VRAM |
			      NOUVEAU_BO_HIGH | NOUVEAU_BO_RDWR, 0, 0);
		so_reloc (so, bo, ((struct nv50_surface *)(fb->zsbuf))->offset, NOUVEAU_BO_VRAM |
			      NOUVEAU_BO_LOW | NOUVEAU_BO_RDWR, 0, 0);
		so_data  (so, nv50_format_table[fb->zsbuf->format].rt);
		so_data  (so, nv50_miptree(pt)->
			      level[fb->zsbuf->u.tex.level].tile_mode << 4);
		so_data  (so, 0x00000000);

		so_method(so, tesla, NV50TCL_ZETA_ENABLE, 1);
		so_data  (so, 1);
		so_method(so, tesla, NV50TCL_ZETA_HORIZ, 3);
		so_data  (so, fb->zsbuf->width);
		so_data  (so, fb->zsbuf->height);
		so_data  (so, 0x00010001);
	} else {
		so_method(so, tesla, NV50TCL_ZETA_ENABLE, 1);
		so_data  (so, 0);
	}

	so_method(so, tesla, NV50TCL_VIEWPORT_HORIZ(0), 2);
	so_data  (so, w << 16);
	so_data  (so, h << 16);
	/* set window lower left corner */
	so_method(so, tesla, NV50TCL_WINDOW_OFFSET_X, 2);
	so_data  (so, 0);
	so_data  (so, 0);
	/* set screen scissor rectangle */
	so_method(so, tesla, NV50TCL_SCREEN_SCISSOR_HORIZ, 2);
	so_data  (so, w << 16);
	so_data  (so, h << 16);

	return so;
d118 1
a118 2
nv50_validate_samplers(struct nv50_context *nv50, struct nouveau_stateobj *so,
		       unsigned p)
d120 2
a121 2
	struct nouveau_grobj *eng2d = nv50->screen->eng2d;
	unsigned i, j, dw = nv50->sampler_nr[p] * 8;
d123 3
a125 15
	if (!dw)
		return;
	nv50_so_init_sifc(nv50, so, nv50->screen->tsc, NOUVEAU_BO_VRAM,
			  p * (32 * 8 * 4), dw * 4);

	so_method(so, eng2d, NV50_2D_SIFC_DATA | (2 << 29), dw);

	for (i = 0; i < nv50->sampler_nr[p]; ++i) {
		if (nv50->sampler[p][i])
			so_datap(so, nv50->sampler[p][i]->tsc, 8);
		else {
			for (j = 0; j < 8; ++j) /* you get punished */
				so_data(so, 0); /* ... for leaving holes */
		}
	}
d128 2
a129 2
static struct nouveau_stateobj *
validate_blend(struct nv50_context *nv50)
d131 37
a167 3
	struct nouveau_stateobj *so = NULL;
	so_ref(nv50->blend->so, &so);
	return so;
d170 2
a171 2
static struct nouveau_stateobj *
validate_zsa(struct nv50_context *nv50)
d173 2
a174 4
	struct nouveau_stateobj *so = NULL;
	so_ref(nv50->zsa->so, &so);
	return so;
}
d176 17
a192 6
static struct nouveau_stateobj *
validate_rast(struct nv50_context *nv50)
{
	struct nouveau_stateobj *so = NULL;
	so_ref(nv50->rasterizer->so, &so);
	return so;
d195 2
a196 2
static struct nouveau_stateobj *
validate_blend_colour(struct nv50_context *nv50)
d198 2
a199 2
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	struct nouveau_stateobj *so = so_new(1, 4, 0);
d201 24
a224 7
	so_method(so, tesla, NV50TCL_BLEND_COLOR(0), 4);
	so_data  (so, fui(nv50->blend_colour.color[0]));
	so_data  (so, fui(nv50->blend_colour.color[1]));
	so_data  (so, fui(nv50->blend_colour.color[2]));
	so_data  (so, fui(nv50->blend_colour.color[3]));
	return so;
}
d226 2
a227 5
static struct nouveau_stateobj *
validate_stencil_ref(struct nv50_context *nv50)
{
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	struct nouveau_stateobj *so = so_new(2, 2, 0);
d229 2
a230 5
	so_method(so, tesla, NV50TCL_STENCIL_FRONT_FUNC_REF, 1);
	so_data  (so, nv50->stencil_ref.ref_value[0]);
	so_method(so, tesla, NV50TCL_STENCIL_BACK_FUNC_REF, 1);
	so_data  (so, nv50->stencil_ref.ref_value[1]);
	return so;
d233 2
a234 2
static struct nouveau_stateobj *
validate_stipple(struct nv50_context *nv50)
d236 1
a236 3
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	struct nouveau_stateobj *so = so_new(1, 32, 0);
	int i;
d238 2
a239 4
	so_method(so, tesla, NV50TCL_POLYGON_STIPPLE_PATTERN(0), 32);
	for (i = 0; i < 32; i++)
		so_data(so, util_bswap32(nv50->stipple.stipple[i]));
	return so;
d242 2
a243 2
static struct nouveau_stateobj *
validate_scissor(struct nv50_context *nv50)
d245 1
a245 3
	struct nouveau_grobj *tesla = nv50->screen->tesla;
        struct pipe_scissor_state *s = &nv50->scissor;
	struct nouveau_stateobj *so;
d247 2
a248 5
	so = so_new(1, 2, 0);
	so_method(so, tesla, NV50TCL_SCISSOR_HORIZ(0), 2);
	so_data  (so, (s->maxx << 16) | s->minx);
	so_data  (so, (s->maxy << 16) | s->miny);
	return so;
d251 2
a252 2
static struct nouveau_stateobj *
validate_viewport(struct nv50_context *nv50)
d254 1
a254 2
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	struct nouveau_stateobj *so = so_new(3, 7, 0);
d256 2
a257 14
	so_method(so, tesla, NV50TCL_VIEWPORT_TRANSLATE_X(0), 3);
	so_data  (so, fui(nv50->viewport.translate[0]));
	so_data  (so, fui(nv50->viewport.translate[1]));
	so_data  (so, fui(nv50->viewport.translate[2]));
	so_method(so, tesla, NV50TCL_VIEWPORT_SCALE_X(0), 3);
	so_data  (so, fui(nv50->viewport.scale[0]));
	so_data  (so, fui(nv50->viewport.scale[1]));
	so_data  (so, fui(nv50->viewport.scale[2]));

	/* no idea what 0f90 does */
	so_method(so, tesla, 0x0f90, 1);
	so_data  (so, 0);

	return so;
d260 2
a261 2
static struct nouveau_stateobj *
validate_sampler(struct nv50_context *nv50)
d263 1
a263 3
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	struct nouveau_stateobj *so;
	unsigned nr = 0, i;
d265 2
a266 2
	for (i = 0; i < 3; ++i)
		nr += nv50->sampler_nr[i];
d268 1
a268 1
	so = so_new(1 + 5 * 3, 1 + 19 * 3 + nr * 8, 3 * 2);
d270 2
a271 2
	nv50_validate_samplers(nv50, so, 0); /* VP */
	nv50_validate_samplers(nv50, so, 2); /* FP */
d273 4
a276 2
	so_method(so, tesla, 0x1334, 1); /* flush TSC */
	so_data  (so, 0);
d278 6
a283 2
	return so;
}
d285 1
a285 6
static struct nouveau_stateobj *
validate_vtxbuf(struct nv50_context *nv50)
{
	struct nouveau_stateobj *so = NULL;
	so_ref(nv50->state.vtxbuf, &so);
	return so;
d288 34
a321 7
static struct nouveau_stateobj *
validate_vtxattr(struct nv50_context *nv50)
{
	struct nouveau_stateobj *so = NULL;
	so_ref(nv50->state.vtxattr, &so);
	return so;
}
d323 2
a324 2
static struct nouveau_stateobj *
validate_clip(struct nv50_context *nv50)
d326 1
a326 3
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	struct nouveau_stateobj *so = so_new(1, 1, 0);
	uint32_t vvcc;
d328 2
a329 6
	/* 0x0000 = remove whole primitive only (xyz)
	 * 0x1018 = remove whole primitive only (xy), clamp z
	 * 0x1080 = clip primitive (xyz)
	 * 0x1098 = clip primitive (xy), clamp z
	 */
	vvcc = nv50->clip.depth_clamp ? 0x1098 : 0x1080;
d331 3
a333 2
	so_method(so, tesla, NV50TCL_VIEW_VOLUME_CLIP_CTRL, 1);
	so_data  (so, vvcc);
d335 5
a339 2
	return so;
}
d341 1
a341 28
struct state_validate {
	struct nouveau_stateobj *(*func)(struct nv50_context *nv50);
	unsigned states;
} validate_list[] = {
	{ validate_fb             , NV50_NEW_FRAMEBUFFER                      },
	{ validate_blend          , NV50_NEW_BLEND                            },
	{ validate_zsa            , NV50_NEW_ZSA                              },
	{ nv50_vertprog_validate  , NV50_NEW_VERTPROG | NV50_NEW_VERTPROG_CB  },
	{ nv50_fragprog_validate  , NV50_NEW_FRAGPROG | NV50_NEW_FRAGPROG_CB  },
	{ nv50_geomprog_validate  , NV50_NEW_GEOMPROG | NV50_NEW_GEOMPROG_CB  },
	{ nv50_fp_linkage_validate, NV50_NEW_VERTPROG | NV50_NEW_GEOMPROG |
				    NV50_NEW_FRAGPROG | NV50_NEW_RASTERIZER   },
	{ nv50_gp_linkage_validate, NV50_NEW_VERTPROG | NV50_NEW_GEOMPROG     },
	{ validate_rast           , NV50_NEW_RASTERIZER                       },
	{ validate_blend_colour   , NV50_NEW_BLEND_COLOUR                     },
	{ validate_stencil_ref    , NV50_NEW_STENCIL_REF                      },
	{ validate_stipple        , NV50_NEW_STIPPLE                          },
	{ validate_scissor        , NV50_NEW_SCISSOR                          },
	{ validate_viewport       , NV50_NEW_VIEWPORT                         },
	{ validate_sampler        , NV50_NEW_SAMPLER                          },
	{ nv50_tex_validate       , NV50_NEW_TEXTURE | NV50_NEW_SAMPLER       },
	{ nv50_vbo_validate       , NV50_NEW_ARRAYS                           },
	{ validate_vtxbuf         , NV50_NEW_ARRAYS                           },
	{ validate_vtxattr        , NV50_NEW_ARRAYS                           },
	{ validate_clip           , NV50_NEW_CLIP                             },
	{ NULL                    , 0                                         }
};
#define validate_list_len (sizeof(validate_list) / sizeof(validate_list[0]))
d343 1
a343 109
boolean
nv50_state_validate(struct nv50_context *nv50, unsigned wait_dwords)
{
	struct nouveau_channel *chan = nv50->screen->base.channel;
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	unsigned nr_relocs = 128, nr_dwords = wait_dwords + 128 + 4;
	int ret, i;

	for (i = 0; i < validate_list_len; i++) {
		struct state_validate *validate = &validate_list[i];
		struct nouveau_stateobj *so;

		if (!(nv50->dirty & validate->states))
			continue;

		so = validate->func(nv50);
		if (!so)
			continue;

		nr_dwords += (so->total + so->cur);
		nr_relocs += so->cur_reloc;

		so_ref(so, &nv50->state.hw[i]);
		so_ref(NULL, &so);
		nv50->state.hw_dirty |= (1 << i);
	}
	nv50->dirty = 0;

	if (nv50->screen->cur_ctx != nv50) {
		for (i = 0; i < validate_list_len; i++) {
			if (!nv50->state.hw[i] ||
			    (nv50->state.hw_dirty & (1 << i)))
				continue;

			nr_dwords += (nv50->state.hw[i]->total +
				      nv50->state.hw[i]->cur);
			nr_relocs += nv50->state.hw[i]->cur_reloc;
			nv50->state.hw_dirty |= (1 << i);
		}

		nv50->screen->cur_ctx = nv50;
	}

	ret = MARK_RING(chan, nr_dwords, nr_relocs);
	if (ret) {
		debug_printf("MARK_RING(%d, %d) failed: %d\n",
			     nr_dwords, nr_relocs, ret);
		return FALSE;
	}

	while (nv50->state.hw_dirty) {
		i = ffs(nv50->state.hw_dirty) - 1;
		nv50->state.hw_dirty &= ~(1 << i);

		so_emit(chan, nv50->state.hw[i]);
	}

	/* Yes, really, we need to do this.  If a buffer that is referenced
	 * on the hardware isn't part of changed state above, without doing
	 * this the kernel is given no clue that the buffer is being used
	 * still.  This can cause all sorts of fun issues.
	 */
	nv50_tex_relocs(nv50);
	so_emit_reloc_markers(chan, nv50->state.hw[0]); /* fb */
	so_emit_reloc_markers(chan, nv50->state.hw[3]); /* vp */
	so_emit_reloc_markers(chan, nv50->state.hw[4]); /* fp */
	so_emit_reloc_markers(chan, nv50->state.hw[17]); /* vb */
	nv50_screen_relocs(nv50->screen);

	/* No idea.. */
	BEGIN_RING(chan, tesla, 0x142c, 1);
	OUT_RING  (chan, 0);
	BEGIN_RING(chan, tesla, 0x142c, 1);
	OUT_RING  (chan, 0);
	return TRUE;
}

void nv50_so_init_sifc(struct nv50_context *nv50,
		       struct nouveau_stateobj *so,
		       struct nouveau_bo *bo, unsigned reloc,
		       unsigned offset, unsigned size)
{
	struct nouveau_grobj *eng2d = nv50->screen->eng2d;

	reloc |= NOUVEAU_BO_WR;

	so_method(so, eng2d, NV50_2D_DST_FORMAT, 2);
	so_data  (so, NV50_2D_DST_FORMAT_R8_UNORM);
	so_data  (so, 1);
	so_method(so, eng2d, NV50_2D_DST_PITCH, 5);
	so_data  (so, 262144);
	so_data  (so, 65536);
	so_data  (so, 1);
	so_reloc (so, bo, offset, reloc | NOUVEAU_BO_HIGH, 0, 0);
	so_reloc (so, bo, offset, reloc | NOUVEAU_BO_LOW, 0, 0);
	so_method(so, eng2d, NV50_2D_SIFC_BITMAP_ENABLE, 2);
	so_data  (so, 0);
	so_data  (so, NV50_2D_SIFC_FORMAT_R8_UNORM);
	so_method(so, eng2d, NV50_2D_SIFC_WIDTH, 10);
	so_data  (so, size);
	so_data  (so, 1);
	so_data  (so, 0);
	so_data  (so, 1);
	so_data  (so, 0);
	so_data  (so, 1);
	so_data  (so, 0);
	so_data  (so, 0);
	so_data  (so, 0);
	so_data  (so, 0);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d26 1
d29 2
a30 2
static void
nv50_state_validate_fb(struct nv50_context *nv50)
d35 1
a35 1
	unsigned i, w, h, gw = 0;
d47 1
a47 1
		struct pipe_texture *pt = fb->cbufs[i]->texture;
d59 2
d66 1
a66 1
		so_reloc (so, bo, fb->cbufs[i]->offset, NOUVEAU_BO_VRAM |
d68 1
a68 1
		so_reloc (so, bo, fb->cbufs[i]->offset, NOUVEAU_BO_VRAM |
d70 3
a72 33
		switch (fb->cbufs[i]->format) {
		case PIPE_FORMAT_B8G8R8A8_UNORM:
			so_data(so, NV50TCL_RT_FORMAT_A8R8G8B8_UNORM);
			break;
		case PIPE_FORMAT_B8G8R8X8_UNORM:
			so_data(so, NV50TCL_RT_FORMAT_X8R8G8B8_UNORM);
			break;
		case PIPE_FORMAT_B5G6R5_UNORM:
			so_data(so, NV50TCL_RT_FORMAT_R5G6B5_UNORM);
			break;
		case PIPE_FORMAT_R16G16B16A16_SNORM:
			so_data(so, NV50TCL_RT_FORMAT_R16G16B16A16_SNORM);
			break;
		case PIPE_FORMAT_R16G16B16A16_UNORM:
			so_data(so, NV50TCL_RT_FORMAT_R16G16B16A16_UNORM);
			break;
		case PIPE_FORMAT_R32G32B32A32_FLOAT:
			so_data(so, NV50TCL_RT_FORMAT_R32G32B32A32_FLOAT);
			break;
		case PIPE_FORMAT_R16G16_SNORM:
			so_data(so, NV50TCL_RT_FORMAT_R16G16_SNORM);
			break;
		case PIPE_FORMAT_R16G16_UNORM:
			so_data(so, NV50TCL_RT_FORMAT_R16G16_UNORM);
			break;
		default:
			NOUVEAU_ERR("AIIII unknown format %s\n",
			            util_format_name(fb->cbufs[i]->format));
			so_data(so, NV50TCL_RT_FORMAT_X8R8G8B8_UNORM);
			break;
		}
		so_data(so, nv50_miptree(pt)->
				level[fb->cbufs[i]->level].tile_mode << 4);
d80 1
a80 1
		struct pipe_texture *pt = fb->zsbuf->texture;
d92 2
d95 1
a95 1
		so_reloc (so, bo, fb->zsbuf->offset, NOUVEAU_BO_VRAM |
d97 1
a97 1
		so_reloc (so, bo, fb->zsbuf->offset, NOUVEAU_BO_VRAM |
d99 4
a102 22
		switch (fb->zsbuf->format) {
		case PIPE_FORMAT_Z24S8_UNORM:
			so_data(so, NV50TCL_ZETA_FORMAT_S8Z24_UNORM);
			break;
		case PIPE_FORMAT_Z24X8_UNORM:
			so_data(so, NV50TCL_ZETA_FORMAT_X8Z24_UNORM);
			break;
		case PIPE_FORMAT_S8Z24_UNORM:
			so_data(so, NV50TCL_ZETA_FORMAT_Z24S8_UNORM);
			break;
		case PIPE_FORMAT_Z32_FLOAT:
			so_data(so, NV50TCL_ZETA_FORMAT_Z32_FLOAT);
			break;
		default:
			NOUVEAU_ERR("AIIII unknown format %s\n",
			            util_format_name(fb->zsbuf->format));
			so_data(so, NV50TCL_ZETA_FORMAT_S8Z24_UNORM);
			break;
		}
		so_data(so, nv50_miptree(pt)->
				level[fb->zsbuf->level].tile_mode << 4);
		so_data(so, 0x00000000);
d127 1
a127 6
	/* we set scissors to framebuffer size when they're 'turned off' */
	nv50->dirty |= NV50_NEW_SCISSOR;
	so_ref(NULL, &nv50->state.scissor);

	so_ref(so, &nv50->state.fb);
	so_ref(NULL, &so);
d154 10
a163 2
static void
nv50_state_emit(struct nv50_context *nv50)
d165 4
a168 2
	struct nv50_screen *screen = nv50->screen;
	struct nouveau_channel *chan = screen->base.channel;
d170 13
a182 36
	/* XXX: this is racy for multiple contexts active on separate
	 * threads.
	 */
	if (screen->cur_ctx != nv50) {
		if (nv50->state.fb)
			nv50->state.dirty |= NV50_NEW_FRAMEBUFFER;
		if (nv50->state.blend)
			nv50->state.dirty |= NV50_NEW_BLEND;
		if (nv50->state.zsa)
			nv50->state.dirty |= NV50_NEW_ZSA;
		if (nv50->state.vertprog)
			nv50->state.dirty |= NV50_NEW_VERTPROG;
		if (nv50->state.fragprog)
			nv50->state.dirty |= NV50_NEW_FRAGPROG;
		if (nv50->state.geomprog)
			nv50->state.dirty |= NV50_NEW_GEOMPROG;
		if (nv50->state.rast)
			nv50->state.dirty |= NV50_NEW_RASTERIZER;
		if (nv50->state.blend_colour)
			nv50->state.dirty |= NV50_NEW_BLEND_COLOUR;
		if (nv50->state.stencil_ref)
			nv50->state.dirty |= NV50_NEW_STENCIL_REF;
		if (nv50->state.stipple)
			nv50->state.dirty |= NV50_NEW_STIPPLE;
		if (nv50->state.scissor)
			nv50->state.dirty |= NV50_NEW_SCISSOR;
		if (nv50->state.viewport)
			nv50->state.dirty |= NV50_NEW_VIEWPORT;
		if (nv50->state.tsc_upload)
			nv50->state.dirty |= NV50_NEW_SAMPLER;
		if (nv50->state.tic_upload)
			nv50->state.dirty |= NV50_NEW_TEXTURE;
		if (nv50->state.vtxfmt && nv50->state.vtxbuf)
			nv50->state.dirty |= NV50_NEW_ARRAYS;
		screen->cur_ctx = nv50;
	}
d184 6
a189 41
	if (nv50->state.dirty & NV50_NEW_FRAMEBUFFER)
		so_emit(chan, nv50->state.fb);
	if (nv50->state.dirty & NV50_NEW_BLEND)
		so_emit(chan, nv50->state.blend);
	if (nv50->state.dirty & NV50_NEW_ZSA)
		so_emit(chan, nv50->state.zsa);
	if (nv50->state.dirty & NV50_NEW_VERTPROG)
		so_emit(chan, nv50->state.vertprog);
	if (nv50->state.dirty & NV50_NEW_FRAGPROG)
		so_emit(chan, nv50->state.fragprog);
	if (nv50->state.dirty & NV50_NEW_GEOMPROG && nv50->state.geomprog)
		so_emit(chan, nv50->state.geomprog);
	if (nv50->state.dirty & (NV50_NEW_FRAGPROG | NV50_NEW_VERTPROG |
				 NV50_NEW_GEOMPROG | NV50_NEW_RASTERIZER))
		so_emit(chan, nv50->state.fp_linkage);
	if ((nv50->state.dirty & (NV50_NEW_VERTPROG | NV50_NEW_GEOMPROG))
	    && nv50->state.gp_linkage)
		so_emit(chan, nv50->state.gp_linkage);
	if (nv50->state.dirty & NV50_NEW_RASTERIZER)
		so_emit(chan, nv50->state.rast);
	if (nv50->state.dirty & NV50_NEW_BLEND_COLOUR)
		so_emit(chan, nv50->state.blend_colour);
	if (nv50->state.dirty & NV50_NEW_STENCIL_REF)
		so_emit(chan, nv50->state.stencil_ref);
	if (nv50->state.dirty & NV50_NEW_STIPPLE)
		so_emit(chan, nv50->state.stipple);
	if (nv50->state.dirty & NV50_NEW_SCISSOR)
		so_emit(chan, nv50->state.scissor);
	if (nv50->state.dirty & NV50_NEW_VIEWPORT)
		so_emit(chan, nv50->state.viewport);
	if (nv50->state.dirty & NV50_NEW_SAMPLER)
		so_emit(chan, nv50->state.tsc_upload);
	if (nv50->state.dirty & NV50_NEW_TEXTURE)
		so_emit(chan, nv50->state.tic_upload);
	if (nv50->state.dirty & NV50_NEW_ARRAYS) {
		so_emit(chan, nv50->state.vtxfmt);
		so_emit(chan, nv50->state.vtxbuf);
		if (nv50->state.vtxattr)
			so_emit(chan, nv50->state.vtxattr);
	}
	nv50->state.dirty = 0;
d192 2
a193 2
void
nv50_state_flush_notify(struct nouveau_channel *chan)
d195 2
a196 1
	struct nv50_context *nv50 = chan->user_private;
d198 6
a203 2
	if (nv50->state.tic_upload && !(nv50->dirty & NV50_NEW_TEXTURE))
		so_emit(chan, nv50->state.tic_upload);
d205 6
a210 5
	so_emit_reloc_markers(chan, nv50->state.fb);
	so_emit_reloc_markers(chan, nv50->state.vertprog);
	so_emit_reloc_markers(chan, nv50->state.fragprog);
	so_emit_reloc_markers(chan, nv50->state.vtxbuf);
	so_emit_reloc_markers(chan, nv50->screen->static_init);
d212 4
a215 2
	if (nv50->state.instbuf)
		so_emit_reloc_markers(chan, nv50->state.instbuf);
d218 2
a219 2
boolean
nv50_state_validate(struct nv50_context *nv50)
d222 1
a223 1
	unsigned i;
d225 12
a236 2
	if (nv50->dirty & NV50_NEW_FRAMEBUFFER)
		nv50_state_validate_fb(nv50);
d238 8
a245 2
	if (nv50->dirty & NV50_NEW_BLEND)
		so_ref(nv50->blend->so, &nv50->state.blend);
d247 3
a249 2
	if (nv50->dirty & NV50_NEW_ZSA)
		so_ref(nv50->zsa->so, &nv50->state.zsa);
d251 2
a252 2
	if (nv50->dirty & (NV50_NEW_VERTPROG | NV50_NEW_VERTPROG_CB))
		nv50_vertprog_validate(nv50);
d254 6
a259 2
	if (nv50->dirty & (NV50_NEW_FRAGPROG | NV50_NEW_FRAGPROG_CB))
		nv50_fragprog_validate(nv50);
d261 2
a262 2
	if (nv50->dirty & (NV50_NEW_GEOMPROG | NV50_NEW_GEOMPROG_CB))
		nv50_geomprog_validate(nv50);
d264 1
a264 3
	if (nv50->dirty & (NV50_NEW_FRAGPROG | NV50_NEW_VERTPROG |
			   NV50_NEW_GEOMPROG | NV50_NEW_RASTERIZER))
		nv50_fp_linkage_validate(nv50);
d266 5
a270 2
	if (nv50->dirty & (NV50_NEW_GEOMPROG | NV50_NEW_VERTPROG))
		nv50_gp_linkage_validate(nv50);
d272 2
a273 2
	if (nv50->dirty & NV50_NEW_RASTERIZER)
		so_ref(nv50->rasterizer->so, &nv50->state.rast);
d275 7
a281 10
	if (nv50->dirty & NV50_NEW_BLEND_COLOUR) {
		so = so_new(1, 4, 0);
		so_method(so, tesla, NV50TCL_BLEND_COLOR(0), 4);
		so_data  (so, fui(nv50->blend_colour.color[0]));
		so_data  (so, fui(nv50->blend_colour.color[1]));
		so_data  (so, fui(nv50->blend_colour.color[2]));
		so_data  (so, fui(nv50->blend_colour.color[3]));
		so_ref(so, &nv50->state.blend_colour);
		so_ref(NULL, &so);
	}
d283 7
a289 9
	if (nv50->dirty & NV50_NEW_STENCIL_REF) {
		so = so_new(2, 2, 0);
		so_method(so, tesla, NV50TCL_STENCIL_FRONT_FUNC_REF, 1);
		so_data  (so, nv50->stencil_ref.ref_value[0]);
		so_method(so, tesla, NV50TCL_STENCIL_BACK_FUNC_REF, 1);
		so_data  (so, nv50->stencil_ref.ref_value[1]);
		so_ref(so, &nv50->state.stencil_ref);
		so_ref(NULL, &so);
	}
d291 6
a296 8
	if (nv50->dirty & NV50_NEW_STIPPLE) {
		so = so_new(1, 32, 0);
		so_method(so, tesla, NV50TCL_POLYGON_STIPPLE_PATTERN(0), 32);
		for (i = 0; i < 32; i++)
			so_data(so, util_bswap32(nv50->stipple.stipple[i]));
		so_ref(so, &nv50->state.stipple);
		so_ref(NULL, &so);
	}
d298 6
a303 23
	if (nv50->dirty & (NV50_NEW_SCISSOR | NV50_NEW_RASTERIZER)) {
		struct pipe_rasterizer_state *rast = &nv50->rasterizer->pipe;
		struct pipe_scissor_state *s = &nv50->scissor;

		if (nv50->state.scissor &&
		    (rast->scissor == 0 && nv50->state.scissor_enabled == 0))
			goto scissor_uptodate;
		nv50->state.scissor_enabled = rast->scissor;

		so = so_new(1, 2, 0);
		so_method(so, tesla, NV50TCL_SCISSOR_HORIZ(0), 2);
		if (nv50->state.scissor_enabled) {
			so_data(so, (s->maxx << 16) | s->minx);
			so_data(so, (s->maxy << 16) | s->miny);
		} else {
			so_data(so, (nv50->framebuffer.width << 16));
			so_data(so, (nv50->framebuffer.height << 16));
		}
		so_ref(so, &nv50->state.scissor);
		so_ref(NULL, &so);
		nv50->state.dirty |= NV50_NEW_SCISSOR;
	}
scissor_uptodate:
d305 2
a306 14
	if (nv50->dirty & (NV50_NEW_VIEWPORT | NV50_NEW_RASTERIZER)) {
		if (nv50->state.viewport &&
		    !(nv50->dirty & NV50_NEW_VIEWPORT))
			goto viewport_uptodate;

		so = so_new(5, 9, 0);
		so_method(so, tesla, NV50TCL_VIEWPORT_TRANSLATE_X(0), 3);
		so_data  (so, fui(nv50->viewport.translate[0]));
		so_data  (so, fui(nv50->viewport.translate[1]));
		so_data  (so, fui(nv50->viewport.translate[2]));
		so_method(so, tesla, NV50TCL_VIEWPORT_SCALE_X(0), 3);
		so_data  (so, fui(nv50->viewport.scale[0]));
		so_data  (so, fui(nv50->viewport.scale[1]));
		so_data  (so, fui(nv50->viewport.scale[2]));
d308 2
a309 12
		so_method(so, tesla, NV50TCL_VIEWPORT_TRANSFORM_EN, 1);
		so_data  (so, 1);
		/* 0x0000 = remove whole primitive only (xyz)
		 * 0x1018 = remove whole primitive only (xy), clamp z
		 * 0x1080 = clip primitive (xyz)
		 * 0x1098 = clip primitive (xy), clamp z
		 */
		so_method(so, tesla, NV50TCL_VIEW_VOLUME_CLIP_CTRL, 1);
		so_data  (so, 0x1080);
		/* no idea what 0f90 does */
		so_method(so, tesla, 0x0f90, 1);
		so_data  (so, 0);
d311 28
a338 5
		so_ref(so, &nv50->state.viewport);
		so_ref(NULL, &so);
		nv50->state.dirty |= NV50_NEW_VIEWPORT;
	}
viewport_uptodate:
d340 7
a346 2
	if (nv50->dirty & NV50_NEW_SAMPLER) {
		unsigned nr = 0;
d348 3
a350 2
		for (i = 0; i < PIPE_SHADER_TYPES; ++i)
			nr += nv50->sampler_nr[i];
d352 2
a353 3
		so = so_new(1 + 5 * PIPE_SHADER_TYPES,
			    1 + 19 * PIPE_SHADER_TYPES + nr * 8,
			    PIPE_SHADER_TYPES * 2);
d355 3
a357 2
		nv50_validate_samplers(nv50, so, PIPE_SHADER_VERTEX);
		nv50_validate_samplers(nv50, so, PIPE_SHADER_FRAGMENT);
d359 2
a360 2
		so_method(so, tesla, 0x1334, 1); /* flush TSC */
		so_data  (so, 0);
d362 1
a362 1
		so_ref(so, &nv50->state.tsc_upload);
d364 1
d366 1
d368 11
a378 2
	if (nv50->dirty & (NV50_NEW_TEXTURE | NV50_NEW_SAMPLER))
		nv50_tex_validate(nv50);
d380 9
a388 2
	if (nv50->dirty & NV50_NEW_ARRAYS)
		nv50_vbo_validate(nv50);
d390 6
a395 3
	nv50->state.dirty |= nv50->dirty;
	nv50->dirty = 0;
	nv50_state_emit(nv50);
d397 17
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a25 1
#include "nv50_resource.h"
d28 2
a29 2
static struct nouveau_stateobj *
validate_fb(struct nv50_context *nv50)
d34 1
a34 1
	unsigned i, w = 0, h = 0, gw = 0;
d46 1
a46 1
		struct pipe_resource *pt = fb->cbufs[i]->texture;
a57 2
		assert(nv50_format_table[fb->cbufs[i]->format].rt);

d63 1
a63 1
		so_reloc (so, bo, ((struct nv50_surface *)fb->cbufs[i])->offset, NOUVEAU_BO_VRAM |
d65 1
a65 1
		so_reloc (so, bo, ((struct nv50_surface *)fb->cbufs[i])->offset, NOUVEAU_BO_VRAM |
d67 33
a99 3
		so_data  (so, nv50_format_table[fb->cbufs[i]->format].rt);
		so_data  (so, nv50_miptree(pt)->
			      level[fb->cbufs[i]->u.tex.level].tile_mode << 4);
d107 1
a107 1
		struct pipe_resource *pt = fb->zsbuf->texture;
a118 2
		assert(nv50_format_table[fb->zsbuf->format].rt);

d120 1
a120 1
		so_reloc (so, bo, ((struct nv50_surface *)(fb->zsbuf))->offset, NOUVEAU_BO_VRAM |
d122 1
a122 1
		so_reloc (so, bo, ((struct nv50_surface *)(fb->zsbuf))->offset, NOUVEAU_BO_VRAM |
d124 22
a145 4
		so_data  (so, nv50_format_table[fb->zsbuf->format].rt);
		so_data  (so, nv50_miptree(pt)->
			      level[fb->zsbuf->u.tex.level].tile_mode << 4);
		so_data  (so, 0x00000000);
d170 6
a175 1
	return so;
d202 2
a203 10
static struct nouveau_stateobj *
validate_blend(struct nv50_context *nv50)
{
	struct nouveau_stateobj *so = NULL;
	so_ref(nv50->blend->so, &so);
	return so;
}

static struct nouveau_stateobj *
validate_zsa(struct nv50_context *nv50)
d205 2
a206 4
	struct nouveau_stateobj *so = NULL;
	so_ref(nv50->zsa->so, &so);
	return so;
}
d208 36
a243 7
static struct nouveau_stateobj *
validate_rast(struct nv50_context *nv50)
{
	struct nouveau_stateobj *so = NULL;
	so_ref(nv50->rasterizer->so, &so);
	return so;
}
d245 41
a285 12
static struct nouveau_stateobj *
validate_blend_colour(struct nv50_context *nv50)
{
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	struct nouveau_stateobj *so = so_new(1, 4, 0);

	so_method(so, tesla, NV50TCL_BLEND_COLOR(0), 4);
	so_data  (so, fui(nv50->blend_colour.color[0]));
	so_data  (so, fui(nv50->blend_colour.color[1]));
	so_data  (so, fui(nv50->blend_colour.color[2]));
	so_data  (so, fui(nv50->blend_colour.color[3]));
	return so;
d288 2
a289 2
static struct nouveau_stateobj *
validate_stencil_ref(struct nv50_context *nv50)
d291 1
a291 2
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	struct nouveau_stateobj *so = so_new(2, 2, 0);
d293 2
a294 6
	so_method(so, tesla, NV50TCL_STENCIL_FRONT_FUNC_REF, 1);
	so_data  (so, nv50->stencil_ref.ref_value[0]);
	so_method(so, tesla, NV50TCL_STENCIL_BACK_FUNC_REF, 1);
	so_data  (so, nv50->stencil_ref.ref_value[1]);
	return so;
}
d296 5
a300 6
static struct nouveau_stateobj *
validate_stipple(struct nv50_context *nv50)
{
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	struct nouveau_stateobj *so = so_new(1, 32, 0);
	int i;
d302 2
a303 4
	so_method(so, tesla, NV50TCL_POLYGON_STIPPLE_PATTERN(0), 32);
	for (i = 0; i < 32; i++)
		so_data(so, util_bswap32(nv50->stipple.stipple[i]));
	return so;
d306 2
a307 2
static struct nouveau_stateobj *
validate_scissor(struct nv50_context *nv50)
a309 1
        struct pipe_scissor_state *s = &nv50->scissor;
d311 1
d313 2
a314 6
	so = so_new(1, 2, 0);
	so_method(so, tesla, NV50TCL_SCISSOR_HORIZ(0), 2);
	so_data  (so, (s->maxx << 16) | s->minx);
	so_data  (so, (s->maxy << 16) | s->miny);
	return so;
}
d316 2
a317 5
static struct nouveau_stateobj *
validate_viewport(struct nv50_context *nv50)
{
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	struct nouveau_stateobj *so = so_new(3, 7, 0);
d319 2
a320 8
	so_method(so, tesla, NV50TCL_VIEWPORT_TRANSLATE_X(0), 3);
	so_data  (so, fui(nv50->viewport.translate[0]));
	so_data  (so, fui(nv50->viewport.translate[1]));
	so_data  (so, fui(nv50->viewport.translate[2]));
	so_method(so, tesla, NV50TCL_VIEWPORT_SCALE_X(0), 3);
	so_data  (so, fui(nv50->viewport.scale[0]));
	so_data  (so, fui(nv50->viewport.scale[1]));
	so_data  (so, fui(nv50->viewport.scale[2]));
d322 2
a323 3
	/* no idea what 0f90 does */
	so_method(so, tesla, 0x0f90, 1);
	so_data  (so, 0);
d325 2
a326 2
	return so;
}
d328 2
a329 6
static struct nouveau_stateobj *
validate_sampler(struct nv50_context *nv50)
{
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	struct nouveau_stateobj *so;
	unsigned nr = 0, i;
d331 3
a333 2
	for (i = 0; i < 3; ++i)
		nr += nv50->sampler_nr[i];
d335 2
a336 1
	so = so_new(1 + 5 * 3, 1 + 19 * 3 + nr * 8, 3 * 2);
d338 2
a339 2
	nv50_validate_samplers(nv50, so, 0); /* VP */
	nv50_validate_samplers(nv50, so, 2); /* FP */
d341 10
a350 2
	so_method(so, tesla, 0x1334, 1); /* flush TSC */
	so_data  (so, 0);
d352 9
a360 2
	return so;
}
d362 8
a369 7
static struct nouveau_stateobj *
validate_vtxbuf(struct nv50_context *nv50)
{
	struct nouveau_stateobj *so = NULL;
	so_ref(nv50->state.vtxbuf, &so);
	return so;
}
d371 23
a393 7
static struct nouveau_stateobj *
validate_vtxattr(struct nv50_context *nv50)
{
	struct nouveau_stateobj *so = NULL;
	so_ref(nv50->state.vtxattr, &so);
	return so;
}
d395 14
a408 6
static struct nouveau_stateobj *
validate_clip(struct nv50_context *nv50)
{
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	struct nouveau_stateobj *so = so_new(1, 1, 0);
	uint32_t vvcc;
d410 12
a421 6
	/* 0x0000 = remove whole primitive only (xyz)
	 * 0x1018 = remove whole primitive only (xy), clamp z
	 * 0x1080 = clip primitive (xyz)
	 * 0x1098 = clip primitive (xy), clamp z
	 */
	vvcc = nv50->clip.depth_clamp ? 0x1098 : 0x1080;
d423 5
a427 2
	so_method(so, tesla, NV50TCL_VIEW_VOLUME_CLIP_CTRL, 1);
	so_data  (so, vvcc);
d429 2
a430 2
	return so;
}
d432 2
a433 28
struct state_validate {
	struct nouveau_stateobj *(*func)(struct nv50_context *nv50);
	unsigned states;
} validate_list[] = {
	{ validate_fb             , NV50_NEW_FRAMEBUFFER                      },
	{ validate_blend          , NV50_NEW_BLEND                            },
	{ validate_zsa            , NV50_NEW_ZSA                              },
	{ nv50_vertprog_validate  , NV50_NEW_VERTPROG | NV50_NEW_VERTPROG_CB  },
	{ nv50_fragprog_validate  , NV50_NEW_FRAGPROG | NV50_NEW_FRAGPROG_CB  },
	{ nv50_geomprog_validate  , NV50_NEW_GEOMPROG | NV50_NEW_GEOMPROG_CB  },
	{ nv50_fp_linkage_validate, NV50_NEW_VERTPROG | NV50_NEW_GEOMPROG |
				    NV50_NEW_FRAGPROG | NV50_NEW_RASTERIZER   },
	{ nv50_gp_linkage_validate, NV50_NEW_VERTPROG | NV50_NEW_GEOMPROG     },
	{ validate_rast           , NV50_NEW_RASTERIZER                       },
	{ validate_blend_colour   , NV50_NEW_BLEND_COLOUR                     },
	{ validate_stencil_ref    , NV50_NEW_STENCIL_REF                      },
	{ validate_stipple        , NV50_NEW_STIPPLE                          },
	{ validate_scissor        , NV50_NEW_SCISSOR                          },
	{ validate_viewport       , NV50_NEW_VIEWPORT                         },
	{ validate_sampler        , NV50_NEW_SAMPLER                          },
	{ nv50_tex_validate       , NV50_NEW_TEXTURE | NV50_NEW_SAMPLER       },
	{ nv50_vbo_validate       , NV50_NEW_ARRAYS                           },
	{ validate_vtxbuf         , NV50_NEW_ARRAYS                           },
	{ validate_vtxattr        , NV50_NEW_ARRAYS                           },
	{ validate_clip           , NV50_NEW_CLIP                             },
	{ NULL                    , 0                                         }
};
#define validate_list_len (sizeof(validate_list) / sizeof(validate_list[0]))
d435 3
a437 7
boolean
nv50_state_validate(struct nv50_context *nv50, unsigned wait_dwords)
{
	struct nouveau_channel *chan = nv50->screen->base.channel;
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	unsigned nr_relocs = 128, nr_dwords = wait_dwords + 128 + 4;
	int ret, i;
d439 2
a440 3
	for (i = 0; i < validate_list_len; i++) {
		struct state_validate *validate = &validate_list[i];
		struct nouveau_stateobj *so;
d442 2
a443 9
		if (!(nv50->dirty & validate->states))
			continue;

		so = validate->func(nv50);
		if (!so)
			continue;

		nr_dwords += (so->total + so->cur);
		nr_relocs += so->cur_reloc;
d445 1
a445 1
		so_ref(so, &nv50->state.hw[i]);
a446 1
		nv50->state.hw_dirty |= (1 << i);
a447 1
	nv50->dirty = 0;
d449 2
a450 11
	if (nv50->screen->cur_ctx != nv50) {
		for (i = 0; i < validate_list_len; i++) {
			if (!nv50->state.hw[i] ||
			    (nv50->state.hw_dirty & (1 << i)))
				continue;

			nr_dwords += (nv50->state.hw[i]->total +
				      nv50->state.hw[i]->cur);
			nr_relocs += nv50->state.hw[i]->cur_reloc;
			nv50->state.hw_dirty |= (1 << i);
		}
d452 2
a453 2
		nv50->screen->cur_ctx = nv50;
	}
d455 3
a457 6
	ret = MARK_RING(chan, nr_dwords, nr_relocs);
	if (ret) {
		debug_printf("MARK_RING(%d, %d) failed: %d\n",
			     nr_dwords, nr_relocs, ret);
		return FALSE;
	}
a458 24
	while (nv50->state.hw_dirty) {
		i = ffs(nv50->state.hw_dirty) - 1;
		nv50->state.hw_dirty &= ~(1 << i);

		so_emit(chan, nv50->state.hw[i]);
	}

	/* Yes, really, we need to do this.  If a buffer that is referenced
	 * on the hardware isn't part of changed state above, without doing
	 * this the kernel is given no clue that the buffer is being used
	 * still.  This can cause all sorts of fun issues.
	 */
	nv50_tex_relocs(nv50);
	so_emit_reloc_markers(chan, nv50->state.hw[0]); /* fb */
	so_emit_reloc_markers(chan, nv50->state.hw[3]); /* vp */
	so_emit_reloc_markers(chan, nv50->state.hw[4]); /* fp */
	so_emit_reloc_markers(chan, nv50->state.hw[17]); /* vb */
	nv50_screen_relocs(nv50->screen);

	/* No idea.. */
	BEGIN_RING(chan, tesla, 0x142c, 1);
	OUT_RING  (chan, 0);
	BEGIN_RING(chan, tesla, 0x142c, 1);
	OUT_RING  (chan, 0);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d1 23
d26 2
a27 1
#include "os/os_time.h"
d29 2
a30 2
static void
nv50_validate_fb(struct nv50_context *nv50)
d32 96
a127 100
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct pipe_framebuffer_state *fb = &nv50->framebuffer;
   unsigned i;
   unsigned ms_mode = NV50_3D_MULTISAMPLE_MODE_MS1;
   uint32_t array_size = 0xffff, array_mode = 0;

   nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_FB);

   BEGIN_NV04(push, NV50_3D(RT_CONTROL), 1);
   PUSH_DATA (push, (076543210 << 4) | fb->nr_cbufs);
   BEGIN_NV04(push, NV50_3D(SCREEN_SCISSOR_HORIZ), 2);
   PUSH_DATA (push, fb->width << 16);
   PUSH_DATA (push, fb->height << 16);

   for (i = 0; i < fb->nr_cbufs; ++i) {
      struct nv50_miptree *mt = nv50_miptree(fb->cbufs[i]->texture);
      struct nv50_surface *sf = nv50_surface(fb->cbufs[i]);
      struct nouveau_bo *bo = mt->base.bo;

      array_size = MIN2(array_size, sf->depth);
      if (mt->layout_3d)
         array_mode = NV50_3D_RT_ARRAY_MODE_MODE_3D; /* 1 << 16 */

      /* can't mix 3D with ARRAY or have RTs of different depth/array_size */
      assert(mt->layout_3d || !array_mode || array_size == 1);

      BEGIN_NV04(push, NV50_3D(RT_ADDRESS_HIGH(i)), 5);
      PUSH_DATAh(push, bo->offset + sf->offset);
      PUSH_DATA (push, bo->offset + sf->offset);
      PUSH_DATA (push, nv50_format_table[sf->base.format].rt);
      if (likely(nouveau_bo_memtype(bo))) {
         PUSH_DATA (push, mt->level[sf->base.u.tex.level].tile_mode);
         PUSH_DATA (push, mt->layer_stride >> 2);
         BEGIN_NV04(push, NV50_3D(RT_HORIZ(i)), 2);
         PUSH_DATA (push, sf->width);
         PUSH_DATA (push, sf->height);
         BEGIN_NV04(push, NV50_3D(RT_ARRAY_MODE), 1);
         PUSH_DATA (push, array_mode | array_size);
      } else {
         PUSH_DATA (push, 0);
         PUSH_DATA (push, 0);
         BEGIN_NV04(push, NV50_3D(RT_HORIZ(i)), 2);
         PUSH_DATA (push, NV50_3D_RT_HORIZ_LINEAR | mt->level[0].pitch);
         PUSH_DATA (push, sf->height);
         BEGIN_NV04(push, NV50_3D(RT_ARRAY_MODE), 1);
         PUSH_DATA (push, 0);

         assert(!fb->zsbuf);
         assert(!mt->ms_mode);
      }

      ms_mode = mt->ms_mode;

      if (mt->base.status & NOUVEAU_BUFFER_STATUS_GPU_READING)
         nv50->state.rt_serialize = TRUE;
      mt->base.status |= NOUVEAU_BUFFER_STATUS_GPU_WRITING;
      mt->base.status &= NOUVEAU_BUFFER_STATUS_GPU_READING;

      /* only register for writing, otherwise we'd always serialize here */
      BCTX_REFN(nv50->bufctx_3d, FB, &mt->base, WR);
   }

   if (fb->zsbuf) {
      struct nv50_miptree *mt = nv50_miptree(fb->zsbuf->texture);
      struct nv50_surface *sf = nv50_surface(fb->zsbuf);
      struct nouveau_bo *bo = mt->base.bo;
      int unk = mt->base.base.target == PIPE_TEXTURE_3D || sf->depth == 1;

      BEGIN_NV04(push, NV50_3D(ZETA_ADDRESS_HIGH), 5);
      PUSH_DATAh(push, bo->offset + sf->offset);
      PUSH_DATA (push, bo->offset + sf->offset);
      PUSH_DATA (push, nv50_format_table[fb->zsbuf->format].rt);
      PUSH_DATA (push, mt->level[sf->base.u.tex.level].tile_mode);
      PUSH_DATA (push, mt->layer_stride >> 2);
      BEGIN_NV04(push, NV50_3D(ZETA_ENABLE), 1);
      PUSH_DATA (push, 1);
      BEGIN_NV04(push, NV50_3D(ZETA_HORIZ), 3);
      PUSH_DATA (push, sf->width);
      PUSH_DATA (push, sf->height);
      PUSH_DATA (push, (unk << 16) | sf->depth);

      ms_mode = mt->ms_mode;

      if (mt->base.status & NOUVEAU_BUFFER_STATUS_GPU_READING)
         nv50->state.rt_serialize = TRUE;
      mt->base.status |= NOUVEAU_BUFFER_STATUS_GPU_WRITING;
      mt->base.status &= NOUVEAU_BUFFER_STATUS_GPU_READING;

      BCTX_REFN(nv50->bufctx_3d, FB, &mt->base, WR);
   } else {
      BEGIN_NV04(push, NV50_3D(ZETA_ENABLE), 1);
      PUSH_DATA (push, 0);
   }

   BEGIN_NV04(push, NV50_3D(MULTISAMPLE_MODE), 1);
   PUSH_DATA (push, ms_mode);

   BEGIN_NV04(push, NV50_3D(VIEWPORT_HORIZ(0)), 2);
   PUSH_DATA (push, fb->width << 16);
   PUSH_DATA (push, fb->height << 16);
d131 2
a132 1
nv50_validate_blend_colour(struct nv50_context *nv50)
d134 7
a140 1
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
d142 10
a151 5
   BEGIN_NV04(push, NV50_3D(BLEND_COLOR(0)), 4);
   PUSH_DATAf(push, nv50->blend_colour.color[0]);
   PUSH_DATAf(push, nv50->blend_colour.color[1]);
   PUSH_DATAf(push, nv50->blend_colour.color[2]);
   PUSH_DATAf(push, nv50->blend_colour.color[3]);
d154 2
a155 2
static void
nv50_validate_stencil_ref(struct nv50_context *nv50)
d157 3
a159 6
   struct nouveau_pushbuf *push = nv50->base.pushbuf;

   BEGIN_NV04(push, NV50_3D(STENCIL_FRONT_FUNC_REF), 1);
   PUSH_DATA (push, nv50->stencil_ref.ref_value[0]);
   BEGIN_NV04(push, NV50_3D(STENCIL_BACK_FUNC_REF), 1);
   PUSH_DATA (push, nv50->stencil_ref.ref_value[1]);
d162 2
a163 2
static void
nv50_validate_stipple(struct nv50_context *nv50)
d165 3
a167 6
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   unsigned i;

   BEGIN_NV04(push, NV50_3D(POLYGON_STIPPLE_PATTERN(0)), 32);
   for (i = 0; i < 32; ++i)
      PUSH_DATA(push, util_bswap32(nv50->stipple.stipple[i]));
d170 2
a171 2
static void
nv50_validate_scissor(struct nv50_context *nv50)
d173 3
a175 37
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct pipe_scissor_state *s = &nv50->scissor;
#ifdef NV50_SCISSORS_CLIPPING
   struct pipe_viewport_state *vp = &nv50->viewport;
   int minx, maxx, miny, maxy;

   if (!(nv50->dirty &
         (NV50_NEW_SCISSOR | NV50_NEW_VIEWPORT | NV50_NEW_FRAMEBUFFER)) &&
       nv50->state.scissor == nv50->rast->pipe.scissor)
      return;
   nv50->state.scissor = nv50->rast->pipe.scissor;

   if (nv50->state.scissor) {
      minx = s->minx;
      maxx = s->maxx;
      miny = s->miny;
      maxy = s->maxy;
   } else {
      minx = 0;
      maxx = nv50->framebuffer.width;
      miny = 0;
      maxy = nv50->framebuffer.height;
   }

   minx = MAX2(minx, (int)(vp->translate[0] - fabsf(vp->scale[0])));
   maxx = MIN2(maxx, (int)(vp->translate[0] + fabsf(vp->scale[0])));
   miny = MAX2(miny, (int)(vp->translate[1] - fabsf(vp->scale[1])));
   maxy = MIN2(maxy, (int)(vp->translate[1] + fabsf(vp->scale[1])));

   BEGIN_NV04(push, NV50_3D(SCISSOR_HORIZ(0)), 2);
   PUSH_DATA (push, (maxx << 16) | minx);
   PUSH_DATA (push, (maxy << 16) | miny);
#else
   BEGIN_NV04(push, NV50_3D(SCISSOR_HORIZ(0)), 2);
   PUSH_DATA (push, (s->maxx << 16) | s->minx);
   PUSH_DATA (push, (s->maxy << 16) | s->miny);
#endif
d178 2
a179 2
static void
nv50_validate_viewport(struct nv50_context *nv50)
d181 2
a182 2
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   float zmin, zmax;
d184 6
a189 38
   BEGIN_NV04(push, NV50_3D(VIEWPORT_TRANSLATE_X(0)), 3);
   PUSH_DATAf(push, nv50->viewport.translate[0]);
   PUSH_DATAf(push, nv50->viewport.translate[1]);
   PUSH_DATAf(push, nv50->viewport.translate[2]);
   BEGIN_NV04(push, NV50_3D(VIEWPORT_SCALE_X(0)), 3);
   PUSH_DATAf(push, nv50->viewport.scale[0]);
   PUSH_DATAf(push, nv50->viewport.scale[1]);
   PUSH_DATAf(push, nv50->viewport.scale[2]);

   zmin = nv50->viewport.translate[2] - fabsf(nv50->viewport.scale[2]);
   zmax = nv50->viewport.translate[2] + fabsf(nv50->viewport.scale[2]);

#ifdef NV50_SCISSORS_CLIPPING
   BEGIN_NV04(push, NV50_3D(DEPTH_RANGE_NEAR(0)), 2);
   PUSH_DATAf(push, zmin);
   PUSH_DATAf(push, zmax);
#endif
}

static INLINE void
nv50_check_program_ucps(struct nv50_context *nv50,
                        struct nv50_program *vp, uint8_t mask)
{
   const unsigned n = util_logbase2(mask) + 1;

   if (vp->vp.clpd_nr >= n)
      return;
   nv50_program_destroy(nv50, vp);

   vp->vp.clpd_nr = n;
   if (likely(vp == nv50->vertprog)) {
      nv50->dirty |= NV50_NEW_VERTPROG;
      nv50_vertprog_validate(nv50);
   } else {
      nv50->dirty |= NV50_NEW_GMTYPROG;
      nv50_gmtyprog_validate(nv50);
   }
   nv50_fp_linkage_validate(nv50);
d192 2
a193 2
static void
nv50_validate_clip(struct nv50_context *nv50)
d195 2
a196 14
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nv50_program *vp;
   uint8_t clip_enable;

   if (nv50->dirty & NV50_NEW_CLIP) {
      BEGIN_NV04(push, NV50_3D(CB_ADDR), 1);
      PUSH_DATA (push, (0 << 8) | NV50_CB_AUX);
      BEGIN_NI04(push, NV50_3D(CB_DATA(0)), PIPE_MAX_CLIP_PLANES * 4);
      PUSH_DATAp(push, &nv50->clip.ucp[0][0], PIPE_MAX_CLIP_PLANES * 4);
   }

   vp = nv50->gmtyprog;
   if (likely(!vp))
      vp = nv50->vertprog;
d198 6
a203 1
   clip_enable = nv50->rast->pipe.clip_plane_enable;
d205 6
a210 2
   BEGIN_NV04(push, NV50_3D(CLIP_DISTANCE_ENABLE), 1);
   PUSH_DATA (push, clip_enable);
d212 4
a215 2
   if (clip_enable)
      nv50_check_program_ucps(nv50, vp, clip_enable);
d218 2
a219 2
static void
nv50_validate_blend(struct nv50_context *nv50)
d221 3
a223 1
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
d225 5
a229 2
   PUSH_SPACE(push, nv50->blend->size);
   PUSH_DATAp(push, nv50->blend->state, nv50->blend->size);
d232 2
a233 2
static void
nv50_validate_zsa(struct nv50_context *nv50)
d235 15
a249 1
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
d251 1
a251 2
   PUSH_SPACE(push, nv50->zsa->size);
   PUSH_DATAp(push, nv50->zsa->state, nv50->zsa->size);
d254 2
a255 2
static void
nv50_validate_rasterizer(struct nv50_context *nv50)
d257 6
a262 1
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
d264 9
a272 2
   PUSH_SPACE(push, nv50->rast->size);
   PUSH_DATAp(push, nv50->rast->state, nv50->rast->size);
d275 2
a276 2
static void
nv50_validate_sample_mask(struct nv50_context *nv50)
d278 4
a281 1
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
d283 6
a288 13
   unsigned mask[4] =
   {
      nv50->sample_mask & 0xffff,
      nv50->sample_mask & 0xffff,
      nv50->sample_mask & 0xffff,
      nv50->sample_mask & 0xffff
   };

   BEGIN_NV04(push, NV50_3D(MSAA_MASK(0)), 4);
   PUSH_DATA (push, mask[0]);
   PUSH_DATA (push, mask[1]);
   PUSH_DATA (push, mask[2]);
   PUSH_DATA (push, mask[3]);
d291 2
a292 2
static void
nv50_switch_pipe_context(struct nv50_context *ctx_to)
d294 3
a296 9
   struct nv50_context *ctx_from = ctx_to->screen->cur_ctx;

   if (ctx_from)
      ctx_to->state = ctx_from->state;

   ctx_to->dirty = ~0;

   if (!ctx_to->vertex)
      ctx_to->dirty &= ~(NV50_NEW_VERTEX | NV50_NEW_ARRAYS);
d298 6
a303 4
   if (!ctx_to->vertprog)
      ctx_to->dirty &= ~NV50_NEW_VERTPROG;
   if (!ctx_to->fragprog)
      ctx_to->dirty &= ~NV50_NEW_FRAGPROG;
d305 2
a306 10
   if (!ctx_to->blend)
      ctx_to->dirty &= ~NV50_NEW_BLEND;
   if (!ctx_to->rast)
#ifdef NV50_SCISSORS_CLIPPING
      ctx_to->dirty &= ~(NV50_NEW_RASTERIZER | NV50_NEW_SCISSOR);
#else
      ctx_to->dirty &= ~NV50_NEW_RASTERIZER;
#endif
   if (!ctx_to->zsa)
      ctx_to->dirty &= ~NV50_NEW_ZSA;
d308 1
a308 1
   ctx_to->screen->cur_ctx = ctx_to;
d311 3
a313 3
static struct state_validate {
    void (*func)(struct nv50_context *);
    uint32_t states;
d315 22
a336 32
    { nv50_validate_fb,            NV50_NEW_FRAMEBUFFER },
    { nv50_validate_blend,         NV50_NEW_BLEND },
    { nv50_validate_zsa,           NV50_NEW_ZSA },
    { nv50_validate_sample_mask,   NV50_NEW_SAMPLE_MASK },
    { nv50_validate_rasterizer,    NV50_NEW_RASTERIZER },
    { nv50_validate_blend_colour,  NV50_NEW_BLEND_COLOUR },
    { nv50_validate_stencil_ref,   NV50_NEW_STENCIL_REF },
    { nv50_validate_stipple,       NV50_NEW_STIPPLE },
#ifdef NV50_SCISSORS_CLIPPING
    { nv50_validate_scissor,       NV50_NEW_SCISSOR | NV50_NEW_VIEWPORT |
                                   NV50_NEW_RASTERIZER |
                                   NV50_NEW_FRAMEBUFFER },
#else
    { nv50_validate_scissor,       NV50_NEW_SCISSOR },
#endif
    { nv50_validate_viewport,      NV50_NEW_VIEWPORT },
    { nv50_vertprog_validate,      NV50_NEW_VERTPROG },
    { nv50_gmtyprog_validate,      NV50_NEW_GMTYPROG },
    { nv50_fragprog_validate,      NV50_NEW_FRAGPROG },
    { nv50_fp_linkage_validate,    NV50_NEW_FRAGPROG | NV50_NEW_VERTPROG |
                                   NV50_NEW_GMTYPROG | NV50_NEW_RASTERIZER },
    { nv50_gp_linkage_validate,    NV50_NEW_GMTYPROG | NV50_NEW_VERTPROG },
    { nv50_validate_derived_rs,    NV50_NEW_FRAGPROG | NV50_NEW_RASTERIZER |
                                   NV50_NEW_VERTPROG | NV50_NEW_GMTYPROG },
    { nv50_validate_clip,          NV50_NEW_CLIP | NV50_NEW_RASTERIZER |
                                   NV50_NEW_VERTPROG | NV50_NEW_GMTYPROG },
    { nv50_constbufs_validate,     NV50_NEW_CONSTBUF },
    { nv50_validate_textures,      NV50_NEW_TEXTURES },
    { nv50_validate_samplers,      NV50_NEW_SAMPLERS },
    { nv50_stream_output_validate, NV50_NEW_STRMOUT |
                                   NV50_NEW_VERTPROG | NV50_NEW_GMTYPROG },
    { nv50_vertex_arrays_validate, NV50_NEW_VERTEX | NV50_NEW_ARRAYS }
d341 1
a341 1
nv50_state_validate(struct nv50_context *nv50, uint32_t mask, unsigned words)
d343 106
a448 34
   uint32_t state_mask;
   int ret;
   unsigned i;

   if (nv50->screen->cur_ctx != nv50)
      nv50_switch_pipe_context(nv50);

   state_mask = nv50->dirty & mask;

   if (state_mask) {
      for (i = 0; i < validate_list_len; ++i) {
         struct state_validate *validate = &validate_list[i];

         if (state_mask & validate->states)
            validate->func(nv50);
      }
      nv50->dirty &= ~state_mask;

      if (nv50->state.rt_serialize) {
         nv50->state.rt_serialize = FALSE;
         BEGIN_NV04(nv50->base.pushbuf, SUBC_3D(NV50_GRAPH_SERIALIZE), 1);
         PUSH_DATA (nv50->base.pushbuf, 0);
      }

      nv50_bufctx_fence(nv50->bufctx_3d, FALSE);
   }
   nouveau_pushbuf_bufctx(nv50->base.pushbuf, nv50->bufctx_3d);
   ret = nouveau_pushbuf_validate(nv50->base.pushbuf);

   if (unlikely(nv50->state.flushed)) {
      nv50->state.flushed = FALSE;
      nv50_bufctx_fence(nv50->bufctx_3d, TRUE);
   }
   return !ret;
@


1.1.1.3
log
@Import Mesa 9.2.5
@
text
@d64 1
a64 1
      mt->base.status &= ~NOUVEAU_BUFFER_STATUS_GPU_READING;
d94 1
a94 1
      mt->base.status &= ~NOUVEAU_BUFFER_STATUS_GPU_READING;
@


