head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.07.09.21.08.54;	author jsg;	state dead;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.00.44;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.41;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@#ifndef __NV50_SCREEN_H__
#define __NV50_SCREEN_H__

#include "nouveau/nouveau_screen.h"
#include "nouveau/nouveau_fence.h"
#include "nouveau/nouveau_mm.h"
#include "nouveau/nouveau_heap.h"

#include "nv50_winsys.h"
#include "nv50_stateobj.h"

#define NV50_TIC_MAX_ENTRIES 2048
#define NV50_TSC_MAX_ENTRIES 2048

/* doesn't count reserved slots (for auxiliary constants, immediates, etc.) */
#define NV50_MAX_PIPE_CONSTBUFS 14

struct nv50_context;

#define NV50_CODE_BO_SIZE_LOG2 19

#define NV50_SCREEN_RESIDENT_BO_COUNT 5

struct nv50_blitter;

struct nv50_screen {
   struct nouveau_screen base;

   struct nv50_context *cur_ctx;

   struct nouveau_bo *code;
   struct nouveau_bo *uniforms;
   struct nouveau_bo *txc; /* TIC (offset 0) and TSC (65536) */
   struct nouveau_bo *stack_bo;
   struct nouveau_bo *tls_bo;

   unsigned TPs;
   unsigned MPsInTP;
   unsigned max_tls_space;
   unsigned cur_tls_space;

   struct nouveau_heap *vp_code_heap;
   struct nouveau_heap *gp_code_heap;
   struct nouveau_heap *fp_code_heap;

   struct nv50_blitter *blitter;

   struct {
      void **entries;
      int next;
      uint32_t lock[NV50_TIC_MAX_ENTRIES / 32];
   } tic;
   
   struct {
      void **entries;
      int next;
      uint32_t lock[NV50_TSC_MAX_ENTRIES / 32];
   } tsc;

   struct {
      uint32_t *map;
      struct nouveau_bo *bo;
   } fence;

   struct nouveau_object *sync;

   struct nouveau_object *tesla;
   struct nouveau_object *eng2d;
   struct nouveau_object *m2mf;
};

static INLINE struct nv50_screen *
nv50_screen(struct pipe_screen *screen)
{
   return (struct nv50_screen *)screen;
}

boolean nv50_blitter_create(struct nv50_screen *);
void nv50_blitter_destroy(struct nv50_screen *);

int nv50_screen_tic_alloc(struct nv50_screen *, void *);
int nv50_screen_tsc_alloc(struct nv50_screen *, void *);

static INLINE void
nv50_resource_fence(struct nv04_resource *res, uint32_t flags)
{
   struct nv50_screen *screen = nv50_screen(res->base.screen);

   if (res->mm) {
      nouveau_fence_ref(screen->base.fence.current, &res->fence);
      if (flags & NOUVEAU_BO_WR)
         nouveau_fence_ref(screen->base.fence.current, &res->fence_wr);
   }
}

static INLINE void
nv50_resource_validate(struct nv04_resource *res, uint32_t flags)
{
   if (likely(res->bo)) {
      if (flags & NOUVEAU_BO_WR)
         res->status |= NOUVEAU_BUFFER_STATUS_GPU_WRITING |
            NOUVEAU_BUFFER_STATUS_DIRTY;
      if (flags & NOUVEAU_BO_RD)
         res->status |= NOUVEAU_BUFFER_STATUS_GPU_READING;

      nv50_resource_fence(res, flags);
   }
}

struct nv50_format {
   uint32_t rt;
   uint32_t tic;
   uint32_t vtx;
   uint32_t usage;
};

extern const struct nv50_format nv50_format_table[];

static INLINE void
nv50_screen_tic_unlock(struct nv50_screen *screen, struct nv50_tic_entry *tic)
{
   if (tic->id >= 0)
      screen->tic.lock[tic->id / 32] &= ~(1 << (tic->id % 32));
}

static INLINE void
nv50_screen_tsc_unlock(struct nv50_screen *screen, struct nv50_tsc_entry *tsc)
{
   if (tsc->id >= 0)
      screen->tsc.lock[tsc->id / 32] &= ~(1 << (tsc->id % 32));
}

static INLINE void
nv50_screen_tic_free(struct nv50_screen *screen, struct nv50_tic_entry *tic)
{
   if (tic->id >= 0) {
      screen->tic.entries[tic->id] = NULL;
      screen->tic.lock[tic->id / 32] &= ~(1 << (tic->id % 32));
   }
}

static INLINE void
nv50_screen_tsc_free(struct nv50_screen *screen, struct nv50_tsc_entry *tsc)
{
   if (tsc->id >= 0) {
      screen->tsc.entries[tsc->id] = NULL;
      screen->tsc.lock[tsc->id / 32] &= ~(1 << (tsc->id % 32));
   }
}

extern int nv50_tls_realloc(struct nv50_screen *screen, unsigned tls_space);

#endif
@


1.4
log
@Merge Mesa 9.2.0
@
text
@@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a3 1
#define NOUVEAU_NVC0
d7 2
a8 1
#undef NOUVEAU_NVC0
d15 3
d22 1
a22 2
#define NV50_SCRATCH_SIZE (2 << 20)
#define NV50_SCRATCH_NR_BUFFERS 2
d24 1
a24 1
#define NV50_SCREEN_RESIDENT_BO_COUNT 5
a27 1
   struct nouveau_winsys *nvws;
d37 8
a44 1
   uint64_t tls_size;
d46 1
a46 3
   struct nouveau_resource *vp_code_heap;
   struct nouveau_resource *gp_code_heap;
   struct nouveau_resource *fp_code_heap;
d65 1
a65 3
   struct nouveau_notifier *sync;

   struct nouveau_mman *mm_VRAM_fe0;
d67 3
a69 3
   struct nouveau_grobj *tesla;
   struct nouveau_grobj *eng2d;
   struct nouveau_grobj *m2mf;
d78 2
a79 1
void nv50_screen_make_buffers_resident(struct nv50_screen *);
a90 1

a98 2
   struct nv50_screen *screen = nv50_screen(res->base.screen);

a99 2
      nouveau_bo_validate(screen->base.channel, res->bo, flags);

d101 2
a102 1
         res->status |= NOUVEAU_BUFFER_STATUS_GPU_WRITING;
d150 2
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d4 1
d6 8
d17 7
d25 2
a26 1
	struct nouveau_screen base;
d28 1
a28 1
	struct nouveau_winsys *nvws;
d30 37
a66 1
	struct nv50_context *cur_ctx;
d68 5
a72 4
	struct nouveau_grobj *tesla;
	struct nouveau_grobj *eng2d;
	struct nouveau_grobj *m2mf;
	struct nouveau_notifier *sync;
d74 1
a74 2
	struct nouveau_bo *constbuf_misc[1];
	struct nouveau_bo *constbuf_parm[PIPE_SHADER_TYPES];
d76 2
a77 1
	struct nouveau_resource *immd_heap;
d79 4
a82 2
	struct nouveau_bo *tic;
	struct nouveau_bo *tsc;
d84 2
a85 2
	struct nouveau_bo *stack_bo; /* control flow stack */
	struct nouveau_bo *local_bo; /* l[] memory */
d87 4
a90 2
	boolean force_push;
};
d92 2
a93 2
static INLINE struct nv50_screen *
nv50_screen(struct pipe_screen *screen)
d95 4
a98 2
	return (struct nv50_screen *)screen;
}
d100 4
a103 1
extern void nv50_screen_relocs(struct nv50_screen *);
d105 3
a107 1
extern void nv50_screen_reloc_constbuf(struct nv50_screen *, unsigned cbi);
d110 4
a113 4
	uint32_t rt;
	uint32_t tic;
	uint32_t vtx;
	uint32_t usage;
d117 32
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d5 2
a6 1
#include "nv50_context.h"
d23 1
a23 4
	struct nouveau_resource *immd_heap[1];
	struct nouveau_resource *parm_heap[PIPE_SHADER_TYPES];

	struct pipe_buffer *strm_vbuf[16];
d28 4
a31 1
	struct nouveau_stateobj *static_init;
d40 12
a51 1
void nv50_transfer_init_screen_functions(struct pipe_screen *);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d5 1
a5 2

struct nv50_context;
d22 4
a25 1
	struct nouveau_resource *immd_heap;
d30 1
a30 4
	struct nouveau_bo *stack_bo; /* control flow stack */
	struct nouveau_bo *local_bo; /* l[] memory */

	boolean force_push;
d39 1
a39 12
extern void nv50_screen_relocs(struct nv50_screen *);

extern void nv50_screen_reloc_constbuf(struct nv50_screen *, unsigned cbi);

struct nv50_format {
	uint32_t rt;
	uint32_t tic;
	uint32_t vtx;
	uint32_t usage;
};

extern const struct nv50_format nv50_format_table[];
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a4 3
#include "nouveau/nouveau_fence.h"
#include "nouveau/nouveau_mm.h"
#include "nouveau/nouveau_heap.h"
d6 1
a6 2
#include "nv50_winsys.h"
#include "nv50_stateobj.h"
d8 2
a9 2
#define NV50_TIC_MAX_ENTRIES 2048
#define NV50_TSC_MAX_ENTRIES 2048
d11 1
a11 2
/* doesn't count reserved slots (for auxiliary constants, immediates, etc.) */
#define NV50_MAX_PIPE_CONSTBUFS 14
d13 1
a13 1
struct nv50_context;
d15 4
a18 1
#define NV50_CODE_BO_SIZE_LOG2 19
d20 2
a21 1
#define NV50_SCREEN_RESIDENT_BO_COUNT 5
d23 1
a23 1
struct nv50_blitter;
d25 2
a26 2
struct nv50_screen {
   struct nouveau_screen base;
d28 2
a29 1
   struct nv50_context *cur_ctx;
d31 1
a31 39
   struct nouveau_bo *code;
   struct nouveau_bo *uniforms;
   struct nouveau_bo *txc; /* TIC (offset 0) and TSC (65536) */
   struct nouveau_bo *stack_bo;
   struct nouveau_bo *tls_bo;

   unsigned TPs;
   unsigned MPsInTP;
   unsigned max_tls_space;
   unsigned cur_tls_space;

   struct nouveau_heap *vp_code_heap;
   struct nouveau_heap *gp_code_heap;
   struct nouveau_heap *fp_code_heap;

   struct nv50_blitter *blitter;

   struct {
      void **entries;
      int next;
      uint32_t lock[NV50_TIC_MAX_ENTRIES / 32];
   } tic;
   
   struct {
      void **entries;
      int next;
      uint32_t lock[NV50_TSC_MAX_ENTRIES / 32];
   } tsc;

   struct {
      uint32_t *map;
      struct nouveau_bo *bo;
   } fence;

   struct nouveau_object *sync;

   struct nouveau_object *tesla;
   struct nouveau_object *eng2d;
   struct nouveau_object *m2mf;
d37 1
a37 1
   return (struct nv50_screen *)screen;
d40 1
a40 2
boolean nv50_blitter_create(struct nv50_screen *);
void nv50_blitter_destroy(struct nv50_screen *);
d42 1
a42 28
int nv50_screen_tic_alloc(struct nv50_screen *, void *);
int nv50_screen_tsc_alloc(struct nv50_screen *, void *);

static INLINE void
nv50_resource_fence(struct nv04_resource *res, uint32_t flags)
{
   struct nv50_screen *screen = nv50_screen(res->base.screen);

   if (res->mm) {
      nouveau_fence_ref(screen->base.fence.current, &res->fence);
      if (flags & NOUVEAU_BO_WR)
         nouveau_fence_ref(screen->base.fence.current, &res->fence_wr);
   }
}

static INLINE void
nv50_resource_validate(struct nv04_resource *res, uint32_t flags)
{
   if (likely(res->bo)) {
      if (flags & NOUVEAU_BO_WR)
         res->status |= NOUVEAU_BUFFER_STATUS_GPU_WRITING |
            NOUVEAU_BUFFER_STATUS_DIRTY;
      if (flags & NOUVEAU_BO_RD)
         res->status |= NOUVEAU_BUFFER_STATUS_GPU_READING;

      nv50_resource_fence(res, flags);
   }
}
d45 4
a48 4
   uint32_t rt;
   uint32_t tic;
   uint32_t vtx;
   uint32_t usage;
a51 34

static INLINE void
nv50_screen_tic_unlock(struct nv50_screen *screen, struct nv50_tic_entry *tic)
{
   if (tic->id >= 0)
      screen->tic.lock[tic->id / 32] &= ~(1 << (tic->id % 32));
}

static INLINE void
nv50_screen_tsc_unlock(struct nv50_screen *screen, struct nv50_tsc_entry *tsc)
{
   if (tsc->id >= 0)
      screen->tsc.lock[tsc->id / 32] &= ~(1 << (tsc->id % 32));
}

static INLINE void
nv50_screen_tic_free(struct nv50_screen *screen, struct nv50_tic_entry *tic)
{
   if (tic->id >= 0) {
      screen->tic.entries[tic->id] = NULL;
      screen->tic.lock[tic->id / 32] &= ~(1 << (tic->id % 32));
   }
}

static INLINE void
nv50_screen_tsc_free(struct nv50_screen *screen, struct nv50_tsc_entry *tsc)
{
   if (tsc->id >= 0) {
      screen->tsc.entries[tsc->id] = NULL;
      screen->tsc.lock[tsc->id / 32] &= ~(1 << (tsc->id % 32));
   }
}

extern int nv50_tls_realloc(struct nv50_screen *screen, unsigned tls_space);
@


