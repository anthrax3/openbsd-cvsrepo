head	1.6;
access;
symbols
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.07.09.21.08.54;	author jsg;	state dead;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2014.01.19.03.13.15;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.09.05.14.00.44;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.42;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.01.19.03.03.45;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@/*
 * Copyright 2008 Ben Skeggs
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include "nv50_context.h"
#include "nv50_resource.h"
#include "nv50_texture.xml.h"
#include "nv50_defs.xml.h"

#include "util/u_format.h"

#define NV50_TIC_0_SWIZZLE__MASK                      \
   (NV50_TIC_0_MAPA__MASK | NV50_TIC_0_MAPB__MASK |   \
    NV50_TIC_0_MAPG__MASK | NV50_TIC_0_MAPR__MASK)

static INLINE uint32_t
nv50_tic_swizzle(uint32_t tc, unsigned swz, boolean tex_int)
{
   switch (swz) {
   case PIPE_SWIZZLE_RED:
      return (tc & NV50_TIC_0_MAPR__MASK) >> NV50_TIC_0_MAPR__SHIFT;
   case PIPE_SWIZZLE_GREEN:
      return (tc & NV50_TIC_0_MAPG__MASK) >> NV50_TIC_0_MAPG__SHIFT;
   case PIPE_SWIZZLE_BLUE:
      return (tc & NV50_TIC_0_MAPB__MASK) >> NV50_TIC_0_MAPB__SHIFT;
   case PIPE_SWIZZLE_ALPHA:
      return (tc & NV50_TIC_0_MAPA__MASK) >> NV50_TIC_0_MAPA__SHIFT;
   case PIPE_SWIZZLE_ONE:
      return tex_int ? NV50_TIC_MAP_ONE_INT : NV50_TIC_MAP_ONE_FLOAT;
   case PIPE_SWIZZLE_ZERO:
   default:
      return NV50_TIC_MAP_ZERO;
   }
}

struct pipe_sampler_view *
nv50_create_sampler_view(struct pipe_context *pipe,
                         struct pipe_resource *res,
                         const struct pipe_sampler_view *templ)
{
   uint32_t flags = 0;

   if (res->target == PIPE_TEXTURE_RECT || res->target == PIPE_BUFFER)
      flags |= NV50_TEXVIEW_SCALED_COORDS;

   return nv50_create_texture_view(pipe, res, templ, flags, res->target);
}

struct pipe_sampler_view *
nv50_create_texture_view(struct pipe_context *pipe,
                         struct pipe_resource *texture,
                         const struct pipe_sampler_view *templ,
                         uint32_t flags,
                         enum pipe_texture_target target)
{
   const struct util_format_description *desc;
   uint64_t addr;
   uint32_t *tic;
   uint32_t swz[4];
   uint32_t depth;
   struct nv50_tic_entry *view;
   struct nv50_miptree *mt = nv50_miptree(texture);
   boolean tex_int;

   view = MALLOC_STRUCT(nv50_tic_entry);
   if (!view)
      return NULL;

   view->pipe = *templ;
   view->pipe.reference.count = 1;
   view->pipe.texture = NULL;
   view->pipe.context = pipe;

   view->id = -1;

   pipe_resource_reference(&view->pipe.texture, texture);

   tic = &view->tic[0];

   desc = util_format_description(view->pipe.format);

   /* TIC[0] */

   tic[0] = nv50_format_table[view->pipe.format].tic;

   tex_int = util_format_is_pure_integer(view->pipe.format);

   swz[0] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_r, tex_int);
   swz[1] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_g, tex_int);
   swz[2] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_b, tex_int);
   swz[3] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_a, tex_int);
   tic[0] = (tic[0] & ~NV50_TIC_0_SWIZZLE__MASK) |
      (swz[0] << NV50_TIC_0_MAPR__SHIFT) |
      (swz[1] << NV50_TIC_0_MAPG__SHIFT) |
      (swz[2] << NV50_TIC_0_MAPB__SHIFT) |
      (swz[3] << NV50_TIC_0_MAPA__SHIFT);

   addr = mt->base.address;

   if (mt->base.base.target == PIPE_TEXTURE_1D_ARRAY ||
       mt->base.base.target == PIPE_TEXTURE_2D_ARRAY) {
      addr += view->pipe.u.tex.first_layer * mt->layer_stride;
      depth = view->pipe.u.tex.last_layer - view->pipe.u.tex.first_layer + 1;
   } else {
      depth = mt->base.base.depth0;
   }

   tic[2] = 0x10001000 | NV50_TIC_2_NO_BORDER;

   if (desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB)
      tic[2] |= NV50_TIC_2_COLORSPACE_SRGB;

   if (!(flags & NV50_TEXVIEW_SCALED_COORDS))
      tic[2] |= NV50_TIC_2_NORMALIZED_COORDS;

   if (unlikely(!nouveau_bo_memtype(nv04_resource(texture)->bo))) {
      if (target == PIPE_BUFFER) {
         addr += view->pipe.u.buf.first_element * desc->block.bits / 8;
         tic[2] |= NV50_TIC_2_LINEAR | NV50_TIC_2_TARGET_BUFFER;
         tic[3] = 0;
         tic[4] = /* width */
            view->pipe.u.buf.last_element - view->pipe.u.buf.first_element + 1;
         tic[5] = 0;
      } else {
         tic[2] |= NV50_TIC_2_LINEAR | NV50_TIC_2_TARGET_RECT;
         tic[3] = mt->level[0].pitch;
         tic[4] = mt->base.base.width0;
         tic[5] = (1 << 16) | mt->base.base.height0;
      }
      tic[6] =
      tic[7] = 0;
      tic[1] = addr;
      tic[2] |= addr >> 32;
      return &view->pipe;
   }

   tic[1] = addr;
   tic[2] |= (addr >> 32) & 0xff;

   tic[2] |=
      ((mt->level[0].tile_mode & 0x0f0) << (22 - 4)) |
      ((mt->level[0].tile_mode & 0xf00) << (25 - 8));

   switch (target) {
   case PIPE_TEXTURE_1D:
      tic[2] |= NV50_TIC_2_TARGET_1D;
      break;
   case PIPE_TEXTURE_2D:
      tic[2] |= NV50_TIC_2_TARGET_2D;
      break;
   case PIPE_TEXTURE_RECT:
      tic[2] |= NV50_TIC_2_TARGET_RECT;
      break;
   case PIPE_TEXTURE_3D:
      tic[2] |= NV50_TIC_2_TARGET_3D;
      break;
   case PIPE_TEXTURE_CUBE:
      depth /= 6;
      tic[2] |= NV50_TIC_2_TARGET_CUBE;
      break;
   case PIPE_TEXTURE_1D_ARRAY:
      tic[2] |= NV50_TIC_2_TARGET_1D_ARRAY;
      break;
   case PIPE_TEXTURE_2D_ARRAY:
      tic[2] |= NV50_TIC_2_TARGET_2D_ARRAY;
      break;
   case PIPE_TEXTURE_CUBE_ARRAY:
      depth /= 6;
      tic[2] |= NV50_TIC_2_TARGET_CUBE_ARRAY;
      break;
   case PIPE_BUFFER:
      assert(0); /* should be linear and handled above ! */
      tic[2] |= NV50_TIC_2_TARGET_BUFFER | NV50_TIC_2_LINEAR;
      break;
   default:
      NOUVEAU_ERR("invalid texture target: %d\n", mt->base.base.target);
      return FALSE;
   }

   tic[3] = (flags & NV50_TEXVIEW_FILTER_MSAA8) ? 0x20000000 : 0x00300000;

   tic[4] = (1 << 31) | (mt->base.base.width0 << mt->ms_x);

   tic[5] = (mt->base.base.height0 << mt->ms_y) & 0xffff;
   tic[5] |= depth << 16;
   tic[5] |= mt->base.base.last_level << NV50_TIC_5_LAST_LEVEL__SHIFT;

   tic[6] = (mt->ms_x > 1) ? 0x88000000 : 0x03000000; /* sampling points */

   tic[7] = (view->pipe.u.tex.last_level << 4) | view->pipe.u.tex.first_level;

   if (unlikely(!(tic[2] & NV50_TIC_2_NORMALIZED_COORDS)))
      if (mt->base.base.last_level)
         tic[5] &= ~NV50_TIC_5_LAST_LEVEL__MASK;

   return &view->pipe;
}

static boolean
nv50_validate_tic(struct nv50_context *nv50, int s)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nouveau_bo *txc = nv50->screen->txc;
   unsigned i;
   boolean need_flush = FALSE;

   for (i = 0; i < nv50->num_textures[s]; ++i) {
      struct nv50_tic_entry *tic = nv50_tic_entry(nv50->textures[s][i]);
      struct nv04_resource *res;

      if (!tic) {
         BEGIN_NV04(push, NV50_3D(BIND_TIC(s)), 1);
         PUSH_DATA (push, (i << 1) | 0);
         continue;
      }
      res = &nv50_miptree(tic->pipe.texture)->base;

      if (tic->id < 0) {
         tic->id = nv50_screen_tic_alloc(nv50->screen, tic);

         BEGIN_NV04(push, NV50_2D(DST_FORMAT), 2);
         PUSH_DATA (push, NV50_SURFACE_FORMAT_R8_UNORM);
         PUSH_DATA (push, 1);
         BEGIN_NV04(push, NV50_2D(DST_PITCH), 5);
         PUSH_DATA (push, 262144);
         PUSH_DATA (push, 65536);
         PUSH_DATA (push, 1);
         PUSH_DATAh(push, txc->offset);
         PUSH_DATA (push, txc->offset);
         BEGIN_NV04(push, NV50_2D(SIFC_BITMAP_ENABLE), 2);
         PUSH_DATA (push, 0);
         PUSH_DATA (push, NV50_SURFACE_FORMAT_R8_UNORM);
         BEGIN_NV04(push, NV50_2D(SIFC_WIDTH), 10);
         PUSH_DATA (push, 32);
         PUSH_DATA (push, 1);
         PUSH_DATA (push, 0);
         PUSH_DATA (push, 1);
         PUSH_DATA (push, 0);
         PUSH_DATA (push, 1);
         PUSH_DATA (push, 0);
         PUSH_DATA (push, tic->id * 32);
         PUSH_DATA (push, 0);
         PUSH_DATA (push, 0);
         BEGIN_NI04(push, NV50_2D(SIFC_DATA), 8);
         PUSH_DATAp(push, &tic->tic[0], 8);

         need_flush = TRUE;
      } else
      if (res->status & NOUVEAU_BUFFER_STATUS_GPU_WRITING) {
         BEGIN_NV04(push, NV50_3D(TEX_CACHE_CTL), 1);
         PUSH_DATA (push, 0x20);
      }

      nv50->screen->tic.lock[tic->id / 32] |= 1 << (tic->id % 32);

      res->status &= ~NOUVEAU_BUFFER_STATUS_GPU_WRITING;
      res->status |= NOUVEAU_BUFFER_STATUS_GPU_READING;

      BCTX_REFN(nv50->bufctx_3d, TEXTURES, res, RD);

      BEGIN_NV04(push, NV50_3D(BIND_TIC(s)), 1);
      PUSH_DATA (push, (tic->id << 9) | (i << 1) | 1);
   }
   for (; i < nv50->state.num_textures[s]; ++i) {
      BEGIN_NV04(push, NV50_3D(BIND_TIC(s)), 1);
      PUSH_DATA (push, (i << 1) | 0);
   }
   nv50->state.num_textures[s] = nv50->num_textures[s];

   return need_flush;
}

void nv50_validate_textures(struct nv50_context *nv50)
{
   boolean need_flush;

   need_flush  = nv50_validate_tic(nv50, 0);
   need_flush |= nv50_validate_tic(nv50, 2);

   if (need_flush) {
      BEGIN_NV04(nv50->base.pushbuf, NV50_3D(TIC_FLUSH), 1);
      PUSH_DATA (nv50->base.pushbuf, 0);
   }
}

static boolean
nv50_validate_tsc(struct nv50_context *nv50, int s)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   unsigned i;
   boolean need_flush = FALSE;

   for (i = 0; i < nv50->num_samplers[s]; ++i) {
      struct nv50_tsc_entry *tsc = nv50_tsc_entry(nv50->samplers[s][i]);

      if (!tsc) {
         BEGIN_NV04(push, NV50_3D(BIND_TSC(s)), 1);
         PUSH_DATA (push, (i << 4) | 0);
         continue;
      }
      if (tsc->id < 0) {
         tsc->id = nv50_screen_tsc_alloc(nv50->screen, tsc);

         nv50_sifc_linear_u8(&nv50->base, nv50->screen->txc,
                             65536 + tsc->id * 32,
                             NOUVEAU_BO_VRAM, 32, tsc->tsc);
         need_flush = TRUE;
      }
      nv50->screen->tsc.lock[tsc->id / 32] |= 1 << (tsc->id % 32);

      BEGIN_NV04(push, NV50_3D(BIND_TSC(s)), 1);
      PUSH_DATA (push, (tsc->id << 12) | (i << 4) | 1);
   }
   for (; i < nv50->state.num_samplers[s]; ++i) {
      BEGIN_NV04(push, NV50_3D(BIND_TSC(s)), 1);
      PUSH_DATA (push, (i << 4) | 0);
   }
   nv50->state.num_samplers[s] = nv50->num_samplers[s];

   return need_flush;
}

void nv50_validate_samplers(struct nv50_context *nv50)
{
   boolean need_flush;

   need_flush  = nv50_validate_tsc(nv50, 0);
   need_flush |= nv50_validate_tsc(nv50, 2);

   if (need_flush) {
      BEGIN_NV04(nv50->base.pushbuf, NV50_3D(TSC_FLUSH), 1);
      PUSH_DATA (nv50->base.pushbuf, 0);
   }
}
@


1.5
log
@Merge Mesa 9.2.5
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d274 1
a274 1
      res->status &= NOUVEAU_BUFFER_STATUS_GPU_WRITING;
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d17 4
a20 4
 * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
d56 13
d70 3
a72 1
                         const struct pipe_sampler_view *templ)
d75 1
d104 1
a104 1
   tex_int = FALSE; /* XXX: integer textures */
d116 9
a124 2
   tic[1] = /* mt->base.bo->offset; */ 0;
   tic[2] = /* mt->base.bo->offset >> 32 */ 0;
d126 1
a126 1
   tic[2] |= 0x10001000 | NV50_TIC_2_NO_BORDER;
d131 1
a131 1
   if (mt->base.base.target != PIPE_TEXTURE_RECT)
d134 20
a153 3
   tic[2] |=
      ((mt->base.bo->tile_mode & 0x0f) << (22 - 0)) |
      ((mt->base.bo->tile_mode & 0xf0) << (25 - 4));
d155 2
a156 1
   depth = MAX2(mt->base.base.array_size, mt->base.base.depth0);
d158 3
a160 5
   if (mt->base.base.target == PIPE_TEXTURE_1D_ARRAY ||
       mt->base.base.target == PIPE_TEXTURE_2D_ARRAY) {
      tic[1] = view->pipe.u.tex.first_layer * mt->layer_stride;
      depth = view->pipe.u.tex.last_layer - view->pipe.u.tex.first_layer + 1;
   }
d162 1
a162 1
   switch (mt->base.base.target) {
d177 1
a177 4
      if (depth > 1)
         tic[2] |= NV50_TIC_2_TARGET_CUBE_ARRAY;
      else
         tic[2] |= NV50_TIC_2_TARGET_CUBE;
d185 4
d190 1
d198 1
a198 4
   if (mt->base.base.target == PIPE_BUFFER)
      tic[3] = mt->base.base.width0;
   else
      tic[3] = 0x00300000;
d200 1
a200 1
   tic[4] = (1 << 31) | mt->base.base.width0;
d202 1
a202 1
   tic[5] = mt->base.base.height0 & 0xffff;
d204 1
a204 1
   tic[5] |= mt->base.base.last_level << 28;
d206 1
a206 1
   tic[6] = 0x03000000;
d210 4
d220 1
a220 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d230 2
a231 2
         BEGIN_RING(chan, RING_3D(BIND_TIC(s)), 1);
         OUT_RING  (chan, (i << 1) | 0);
a236 2
         uint32_t offset = tic->tic[1];

d239 25
a263 30
         MARK_RING (chan, 24 + 8, 4);
         BEGIN_RING(chan, RING_2D(DST_FORMAT), 2);
         OUT_RING  (chan, NV50_SURFACE_FORMAT_R8_UNORM);
         OUT_RING  (chan, 1);
         BEGIN_RING(chan, RING_2D(DST_PITCH), 5);
         OUT_RING  (chan, 262144);
         OUT_RING  (chan, 65536);
         OUT_RING  (chan, 1);
         OUT_RELOCh(chan, txc, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_WR);
         OUT_RELOCl(chan, txc, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_WR);
         BEGIN_RING(chan, RING_2D(SIFC_BITMAP_ENABLE), 2);
         OUT_RING  (chan, 0);
         OUT_RING  (chan, NV50_SURFACE_FORMAT_R8_UNORM);
         BEGIN_RING(chan, RING_2D(SIFC_WIDTH), 10);
         OUT_RING  (chan, 32);
         OUT_RING  (chan, 1);
         OUT_RING  (chan, 0);
         OUT_RING  (chan, 1);
         OUT_RING  (chan, 0);
         OUT_RING  (chan, 1);
         OUT_RING  (chan, 0);
         OUT_RING  (chan, tic->id * 32);
         OUT_RING  (chan, 0);
         OUT_RING  (chan, 0);
         BEGIN_RING_NI(chan, RING_2D(SIFC_DATA), 8);
         OUT_RING  (chan, tic->tic[0]);
         OUT_RELOCl(chan, res->bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_RD);
         OUT_RELOC (chan, res->bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_RD |
                    NOUVEAU_BO_HIGH | NOUVEAU_BO_OR, tic->tic[2], tic->tic[2]);
         OUT_RINGp (chan, &tic->tic[3], 5);
d268 2
a269 2
         BEGIN_RING(chan, RING_3D(TEX_CACHE_CTL), 1);
         OUT_RING  (chan, 0x20); //(tic->id << 4) | 1);
d277 1
a277 2
      nv50_bufctx_add_resident(nv50, NV50_BUFCTX_TEXTURES, res,
                               NOUVEAU_BO_VRAM | NOUVEAU_BO_RD);
d279 2
a280 2
      BEGIN_RING(chan, RING_3D(BIND_TIC(s)), 1);
      OUT_RING  (chan, (tic->id << 9) | (i << 1) | 1);
d283 2
a284 2
      BEGIN_RING(chan, RING_3D(BIND_TIC(s)), 1);
      OUT_RING  (chan, (i << 1) | 0);
d299 2
a300 2
      BEGIN_RING(nv50->screen->base.channel, RING_3D(TIC_FLUSH), 1);
      OUT_RING  (nv50->screen->base.channel, 0);
d307 1
a307 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d315 2
a316 2
         BEGIN_RING(chan, RING_3D(BIND_TSC(s)), 1);
         OUT_RING  (chan, (i << 4) | 0);
d329 2
a330 2
      BEGIN_RING(chan, RING_3D(BIND_TSC(s)), 1);
      OUT_RING  (chan, (tsc->id << 12) | (i << 4) | 1);
d333 2
a334 2
      BEGIN_RING(chan, RING_3D(BIND_TSC(s)), 1);
      OUT_RING  (chan, (i << 4) | 0);
d349 2
a350 2
      BEGIN_RING(nv50->screen->base.channel, RING_3D(TSC_FLUSH), 1);
      OUT_RING  (nv50->screen->base.channel, 0);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a23 1
#include "nv50_texture.h"
d25 2
d28 1
a28 2
#include "nouveau/nouveau_stateobj.h"
#include "nouveau/nouveau_reloc.h"
d30 3
a32 1
#include "util/u_format.h"
d35 1
a35 1
nv50_tic_swizzle(uint32_t tc, unsigned swz)
d37 15
a51 15
	switch (swz) {
	case PIPE_SWIZZLE_RED:
		return (tc & NV50TIC_0_0_MAPR_MASK) >> NV50TIC_0_0_MAPR_SHIFT;
	case PIPE_SWIZZLE_GREEN:
		return (tc & NV50TIC_0_0_MAPG_MASK) >> NV50TIC_0_0_MAPG_SHIFT;
	case PIPE_SWIZZLE_BLUE:
		return (tc & NV50TIC_0_0_MAPB_MASK) >> NV50TIC_0_0_MAPB_SHIFT;
	case PIPE_SWIZZLE_ALPHA:
		return (tc & NV50TIC_0_0_MAPA_MASK) >> NV50TIC_0_0_MAPA_SHIFT;
	case PIPE_SWIZZLE_ONE:
		return 7;
	case PIPE_SWIZZLE_ZERO:
	default:
		return 0;
	}
d54 4
a57 2
boolean
nv50_tex_construct(struct nv50_sampler_view *view)
d59 108
a166 51
	const struct util_format_description *desc;
	struct nv50_miptree *mt = nv50_miptree(view->pipe.texture);
	uint32_t swz[4], *tic = view->tic;

	tic[0] = nv50_format_table[view->pipe.format].tic;

	swz[0] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_r);
	swz[1] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_g);
	swz[2] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_b);
	swz[3] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_a);
	view->tic[0] = (tic[0] &  ~NV50TIC_0_0_SWIZZLE_MASK) |
		(swz[0] << NV50TIC_0_0_MAPR_SHIFT) |
		(swz[1] << NV50TIC_0_0_MAPG_SHIFT) |
		(swz[2] << NV50TIC_0_0_MAPB_SHIFT) |
		(swz[3] << NV50TIC_0_0_MAPA_SHIFT);

	tic[2] = 0x50001000;
	tic[2] |= ((mt->base.bo->tile_mode & 0x0f) << 22) |
		  ((mt->base.bo->tile_mode & 0xf0) << 21);

	desc = util_format_description(mt->base.base.format);
	if (desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB)
		tic[2] |= NV50TIC_0_2_COLORSPACE_SRGB;

	switch (mt->base.base.target) {
	case PIPE_TEXTURE_1D:
		tic[2] |= NV50TIC_0_2_TARGET_1D;
		break;
	case PIPE_TEXTURE_2D:
		tic[2] |= NV50TIC_0_2_TARGET_2D;
		break;
	case PIPE_TEXTURE_RECT:
		tic[2] |= NV50TIC_0_2_TARGET_RECT;
		break;
	case PIPE_TEXTURE_3D:
		tic[2] |= NV50TIC_0_2_TARGET_3D;
		break;
	case PIPE_TEXTURE_CUBE:
		tic[2] |= NV50TIC_0_2_TARGET_CUBE;
		break;
	default:
		NOUVEAU_ERR("invalid texture target: %d\n",
			    mt->base.base.target);
		return FALSE;
	}

	tic[3] = 0x00300000;

	tic[4] = (1 << 31) | mt->base.base.width0;
	tic[5] = (mt->base.base.last_level << 28) |
		(mt->base.base.depth0 << 16) | mt->base.base.height0;
d168 1
a168 1
	tic[6] = 0x03000000;
d170 1
a170 1
	tic[7] = (view->pipe.u.tex.last_level << 4) | view->pipe.u.tex.first_level;
d172 1
a172 1
	return TRUE;
d175 78
a252 53
static int
nv50_validate_textures(struct nv50_context *nv50, struct nouveau_stateobj *so,
		       unsigned p)
{
	struct nouveau_grobj *eng2d = nv50->screen->eng2d;
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	unsigned unit, j;

	const unsigned rll = NOUVEAU_BO_VRAM | NOUVEAU_BO_RD | NOUVEAU_BO_LOW;
	const unsigned rlh = NOUVEAU_BO_VRAM | NOUVEAU_BO_RD | NOUVEAU_BO_HIGH
		| NOUVEAU_BO_OR;

	nv50_so_init_sifc(nv50, so, nv50->screen->tic, NOUVEAU_BO_VRAM,
			  p * (32 * 8 * 4), nv50->sampler_view_nr[p] * 8 * 4);

	for (unit = 0; unit < nv50->sampler_view_nr[p]; ++unit) {
		struct nv50_sampler_view *view =
			nv50_sampler_view(nv50->sampler_views[p][unit]);

		so_method(so, eng2d, NV50_2D_SIFC_DATA | (2 << 29), 8);
		if (view) {
			uint32_t tic2 = view->tic[2];
			struct nv50_miptree *mt =
				nv50_miptree(view->pipe.texture);

			tic2 &= ~NV50TIC_0_2_NORMALIZED_COORDS;
			if (nv50->sampler[p][unit]->normalized)
				tic2 |= NV50TIC_0_2_NORMALIZED_COORDS;
			view->tic[2] = tic2;

			so_data  (so, view->tic[0]);
			so_reloc (so, mt->base.bo, 0, rll, 0, 0);
			so_reloc (so, mt->base.bo, 0, rlh, tic2, tic2);
			so_datap (so, &view->tic[3], 5);

			/* Set TEX insn $t src binding $unit in program type p
			 * to TIC, TSC entry (32 * p + unit), mark valid (1).
			 */
			so_method(so, tesla, NV50TCL_BIND_TIC(p), 1);
			so_data  (so, ((32 * p + unit) << 9) | (unit << 1) | 1);
		} else {
			for (j = 0; j < 8; ++j)
				so_data(so, 0);
			so_method(so, tesla, NV50TCL_BIND_TIC(p), 1);
			so_data  (so, (unit << 1) | 0);
		}
	}

	for (; unit < nv50->state.sampler_view_nr[p]; unit++) {
		/* Make other bindings invalid. */
		so_method(so, tesla, NV50TCL_BIND_TIC(p), 1);
		so_data  (so, (unit << 1) | 0);
	}
d254 1
a254 2
	nv50->state.sampler_view_nr[p] = nv50->sampler_view_nr[p];
	return TRUE;
d257 1
a257 2
static void
nv50_emit_texture_relocs(struct nv50_context *nv50, int prog)
d259 9
a267 21
	struct nouveau_channel *chan = nv50->screen->base.channel;
	struct nouveau_bo *tic = nv50->screen->tic;
	int unit;

	for (unit = 0; unit < nv50->sampler_view_nr[prog]; unit++) {
		struct nv50_sampler_view *view;
		struct nv50_miptree *mt;
		const unsigned base = ((prog * 32) + unit) * 32;

		view = nv50_sampler_view(nv50->sampler_views[prog][unit]);
		if (!view)
			continue;
		mt = nv50_miptree(view->pipe.texture);

		nouveau_reloc_emit(chan, tic, base + 4, NULL, mt->base.bo, 0, 0,
				   NOUVEAU_BO_VRAM | NOUVEAU_BO_RD |
				   NOUVEAU_BO_LOW, 0, 0);
		nouveau_reloc_emit(chan, tic, base + 8, NULL, mt->base.bo, 0, 0,
				   NOUVEAU_BO_VRAM | NOUVEAU_BO_RD |
				   NOUVEAU_BO_HIGH, view->tic[2], view->tic[2]);
	}
d270 2
a271 2
void
nv50_tex_relocs(struct nv50_context *nv50)
d273 32
a304 2
	nv50_emit_texture_relocs(nv50, 2); /* FP */
	nv50_emit_texture_relocs(nv50, 0); /* VP */
d307 1
a307 2
struct nouveau_stateobj *
nv50_tex_validate(struct nv50_context *nv50)
d309 1
a309 24
	struct nouveau_stateobj *so;
	struct nouveau_grobj *tesla = nv50->screen->tesla;
	unsigned p, m = 0, d = 0, r = 0;

	for (p = 0; p < 3; ++p) {
		unsigned nr = MAX2(nv50->sampler_view_nr[p],
				   nv50->state.sampler_view_nr[p]);
		m += nr;
		d += nr;
		r += nv50->sampler_view_nr[p];
	}
	m = m * 2 + 3 * 4 + 1;
	d = d * 9 + 3 * 19 + 1;
	r = r * 2 + 3 * 2;

	so = so_new(m, d, r);

	if (nv50_validate_textures(nv50, so, 0) == FALSE ||
	    nv50_validate_textures(nv50, so, 2) == FALSE) {
		so_ref(NULL, &so);

		NOUVEAU_ERR("failed tex validate\n");
		return NULL;
	}
d311 2
a312 2
	so_method(so, tesla, 0x1330, 1); /* flush TIC */
	so_data  (so, 0);
d314 4
a317 1
	return so;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d25 1
d28 1
d32 18
a49 8
#define _MIXED(pf, t0, t1, t2, t3, cr, cg, cb, ca, f)		\
{                                                       	\
	PIPE_FORMAT_##pf,					\
	NV50TIC_0_0_MAPR_##cr | NV50TIC_0_0_TYPER_##t0 |	\
	NV50TIC_0_0_MAPG_##cg | NV50TIC_0_0_TYPEG_##t1 |	\
	NV50TIC_0_0_MAPB_##cb | NV50TIC_0_0_TYPEB_##t2 |	\
	NV50TIC_0_0_MAPA_##ca | NV50TIC_0_0_TYPEA_##t3 |	\
	NV50TIC_0_0_FMT_##f					\
d52 2
a53 52
#define _(pf, t, cr, cg, cb, ca, f) _MIXED(pf, t, t, t, t, cr, cg, cb, ca, f)

struct nv50_texture_format {
	enum pipe_format pf;
	uint32_t hw;
};

#define NV50_TEX_FORMAT_LIST_SIZE \
	(sizeof(nv50_tex_format_list) / sizeof(struct nv50_texture_format))

static const struct nv50_texture_format nv50_tex_format_list[] =
{
	_(B8G8R8A8_UNORM, UNORM, C2, C1, C0, C3,  8_8_8_8),
	_(B8G8R8A8_SRGB,  UNORM, C2, C1, C0, C3,  8_8_8_8),
	_(B8G8R8X8_UNORM, UNORM, C2, C1, C0, ONE, 8_8_8_8),
	_(B8G8R8X8_SRGB,  UNORM, C2, C1, C0, ONE, 8_8_8_8),
	_(B5G5R5A1_UNORM, UNORM, C2, C1, C0, C3,  1_5_5_5),
	_(B4G4R4A4_UNORM, UNORM, C2, C1, C0, C3,  4_4_4_4),

	_(B5G6R5_UNORM, UNORM, C2, C1, C0, ONE, 5_6_5),

	_(L8_UNORM, UNORM, C0, C0, C0, ONE, 8),
	_(A8_UNORM, UNORM, ZERO, ZERO, ZERO, C0, 8),
	_(I8_UNORM, UNORM, C0, C0, C0, C0, 8),

	_(L8A8_UNORM, UNORM, C0, C0, C0, C1, 8_8),

	_(DXT1_RGB, UNORM, C0, C1, C2, ONE, DXT1),
	_(DXT1_RGBA, UNORM, C0, C1, C2, C3, DXT1),
	_(DXT3_RGBA, UNORM, C0, C1, C2, C3, DXT3),
	_(DXT5_RGBA, UNORM, C0, C1, C2, C3, DXT5),

	_MIXED(S8Z24_UNORM, UINT, UNORM, UINT, UINT, C1, C1, C1, ONE, 24_8),
	_MIXED(Z24S8_UNORM, UNORM, UINT, UINT, UINT, C0, C0, C0, ONE, 8_24),

	_(R16G16B16A16_SNORM, UNORM, C0, C1, C2, C3, 16_16_16_16),
	_(R16G16B16A16_UNORM, SNORM, C0, C1, C2, C3, 16_16_16_16),
	_(R32G32B32A32_FLOAT, FLOAT, C0, C1, C2, C3, 32_32_32_32),

	_(R16G16_SNORM, SNORM, C0, C1, ZERO, ONE, 16_16),
	_(R16G16_UNORM, UNORM, C0, C1, ZERO, ONE, 16_16),

	_MIXED(Z32_FLOAT, FLOAT, UINT, UINT, UINT, C0, C0, C0, ONE, 32_DEPTH)

};

#undef _
#undef _MIXED

static int
nv50_tex_construct(struct nv50_context *nv50, struct nouveau_stateobj *so,
		   struct nv50_miptree *mt, int unit, unsigned p)
a54 2
	unsigned i;
	uint32_t mode;
d56 2
d59 1
a59 12
	for (i = 0; i < NV50_TEX_FORMAT_LIST_SIZE; i++)
		if (nv50_tex_format_list[i].pf == mt->base.base.format)
			break;
	if (i == NV50_TEX_FORMAT_LIST_SIZE)
                return 1;

	if (nv50->sampler[p][unit]->normalized)
		mode = 0x50001000 | (1 << 31);
	else {
		mode = 0x50001000 | (7 << 14);
		assert(mt->base.base.target == PIPE_TEXTURE_2D);
	}
d61 13
a73 2
	mode |= ((mt->base.bo->tile_mode & 0x0f) << 22) |
		((mt->base.bo->tile_mode & 0xf0) << 21);
a75 2
	assert(desc);

d77 1
a77 1
		mode |= 0x0400;
d81 1
d84 4
a87 1
		mode |= (1 << 14);
d90 1
a90 1
		mode |= (2 << 14);
d93 1
a93 1
		mode |= (3 << 14);
d96 3
a98 2
		assert(!"unsupported texture target");
		break;
d101 7
a107 10
	so_data (so, nv50_tex_format_list[i].hw);
	so_reloc(so, mt->base.bo, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_LOW |
		 NOUVEAU_BO_RD, 0, 0);
	so_data (so, mode);
	so_data (so, 0x00300000);
	so_data (so, mt->base.base.width0 | (1 << 31));
	so_data (so, (mt->base.base.last_level << 28) |
		 (mt->base.base.depth0 << 16) | mt->base.base.height0);
	so_data (so, 0x03000000);
	so_data (so, mt->base.base.last_level << 4);
d109 3
a111 1
	return 0;
d114 1
a114 5
#ifndef NV50TCL_BIND_TIC
#define NV50TCL_BIND_TIC(n) (0x1448 + 8 * n)
#endif

static boolean
a117 2
	static const unsigned p_remap[PIPE_SHADER_TYPES] = { 0, 2, 1 };

d120 5
a124 1
	unsigned unit, j, p_hw = p_remap[p];
d127 1
a127 1
			  p * (32 * 8 * 4), nv50->miptree_nr[p] * 8 * 4);
d129 3
a131 2
	for (unit = 0; unit < nv50->miptree_nr[p]; ++unit) {
		struct nv50_miptree *mt = nv50->miptree[p][unit];
d134 15
a148 3
		if (mt) {
			if (nv50_tex_construct(nv50, so, mt, unit, p))
				return FALSE;
d152 1
a152 1
			so_method(so, tesla, NV50TCL_BIND_TIC(p_hw), 1);
d157 1
a157 1
			so_method(so, tesla, NV50TCL_BIND_TIC(p_hw), 1);
d162 1
a162 1
	for (; unit < nv50->state.miptree_nr[p]; unit++) {
d164 1
a164 1
		so_method(so, tesla, NV50TCL_BIND_TIC(p_hw), 1);
d168 1
a168 1
	nv50->state.miptree_nr[p] = nv50->miptree_nr[p];
d172 26
d199 7
d210 1
a210 1
	unsigned p, start, push, nrlc;
d212 10
a221 8
	for (nrlc = 0, start = 0, push = 0, p = 0; p < PIPE_SHADER_TYPES; ++p) {
		start += MAX2(nv50->miptree_nr[p], nv50->state.miptree_nr[p]);
		push += MAX2(nv50->miptree_nr[p], nv50->state.miptree_nr[p]);
		nrlc += nv50->miptree_nr[p];
	}
	start = start * 2 + 4 * PIPE_SHADER_TYPES + 2;
	push = push * 9 + 19 * PIPE_SHADER_TYPES + 2;
	nrlc = nrlc * 2 + 2 * PIPE_SHADER_TYPES;
d223 1
a223 1
	so = so_new(start, push, nrlc);
d225 2
a226 2
	if (nv50_validate_textures(nv50, so, PIPE_SHADER_VERTEX) == FALSE ||
	    nv50_validate_textures(nv50, so, PIPE_SHADER_FRAGMENT) == FALSE) {
d230 1
a230 1
		return;
d236 1
a236 2
	so_ref(so, &nv50->state.tic_upload);
	so_ref(NULL, &so);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a24 1
#include "nv50_resource.h"
a26 1
#include "nouveau/nouveau_reloc.h"
d30 21
a50 2
static INLINE uint32_t
nv50_tic_swizzle(uint32_t tc, unsigned swz)
d52 36
a87 16
	switch (swz) {
	case PIPE_SWIZZLE_RED:
		return (tc & NV50TIC_0_0_MAPR_MASK) >> NV50TIC_0_0_MAPR_SHIFT;
	case PIPE_SWIZZLE_GREEN:
		return (tc & NV50TIC_0_0_MAPG_MASK) >> NV50TIC_0_0_MAPG_SHIFT;
	case PIPE_SWIZZLE_BLUE:
		return (tc & NV50TIC_0_0_MAPB_MASK) >> NV50TIC_0_0_MAPB_SHIFT;
	case PIPE_SWIZZLE_ALPHA:
		return (tc & NV50TIC_0_0_MAPA_MASK) >> NV50TIC_0_0_MAPA_SHIFT;
	case PIPE_SWIZZLE_ONE:
		return 7;
	case PIPE_SWIZZLE_ZERO:
	default:
		return 0;
	}
}
d89 3
a91 2
boolean
nv50_tex_construct(struct nv50_sampler_view *view)
d93 2
a95 2
	struct nv50_miptree *mt = nv50_miptree(view->pipe.texture);
	uint32_t swz[4], *tic = view->tic;
d97 12
a108 1
	tic[0] = nv50_format_table[view->pipe.format].tic;
d110 2
a111 13
	swz[0] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_r);
	swz[1] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_g);
	swz[2] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_b);
	swz[3] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_a);
	view->tic[0] = (tic[0] &  ~NV50TIC_0_0_SWIZZLE_MASK) |
		(swz[0] << NV50TIC_0_0_MAPR_SHIFT) |
		(swz[1] << NV50TIC_0_0_MAPG_SHIFT) |
		(swz[2] << NV50TIC_0_0_MAPB_SHIFT) |
		(swz[3] << NV50TIC_0_0_MAPA_SHIFT);

	tic[2] = 0x50001000;
	tic[2] |= ((mt->base.bo->tile_mode & 0x0f) << 22) |
		  ((mt->base.bo->tile_mode & 0xf0) << 21);
d114 2
d117 1
a117 1
		tic[2] |= NV50TIC_0_2_COLORSPACE_SRGB;
a120 1
		tic[2] |= NV50TIC_0_2_TARGET_1D;
d123 1
a123 4
		tic[2] |= NV50TIC_0_2_TARGET_2D;
		break;
	case PIPE_TEXTURE_RECT:
		tic[2] |= NV50TIC_0_2_TARGET_RECT;
d126 1
a126 1
		tic[2] |= NV50TIC_0_2_TARGET_3D;
d129 1
a129 1
		tic[2] |= NV50TIC_0_2_TARGET_CUBE;
d132 2
a133 3
		NOUVEAU_ERR("invalid texture target: %d\n",
			    mt->base.base.target);
		return FALSE;
d136 10
a145 1
	tic[3] = 0x00300000;
d147 2
a148 5
	tic[4] = (1 << 31) | mt->base.base.width0;
	tic[5] = (mt->base.base.last_level << 28) |
		(mt->base.base.depth0 << 16) | mt->base.base.height0;

	tic[6] = 0x03000000;
d150 3
a152 1
	tic[7] = (view->pipe.u.tex.last_level << 4) | view->pipe.u.tex.first_level;
d154 1
a154 4
	return TRUE;
}

static int
d158 2
d162 1
a162 5
	unsigned unit, j;

	const unsigned rll = NOUVEAU_BO_VRAM | NOUVEAU_BO_RD | NOUVEAU_BO_LOW;
	const unsigned rlh = NOUVEAU_BO_VRAM | NOUVEAU_BO_RD | NOUVEAU_BO_HIGH
		| NOUVEAU_BO_OR;
d165 1
a165 1
			  p * (32 * 8 * 4), nv50->sampler_view_nr[p] * 8 * 4);
d167 2
a168 3
	for (unit = 0; unit < nv50->sampler_view_nr[p]; ++unit) {
		struct nv50_sampler_view *view =
			nv50_sampler_view(nv50->sampler_views[p][unit]);
d171 3
a173 15
		if (view) {
			uint32_t tic2 = view->tic[2];
			struct nv50_miptree *mt =
				nv50_miptree(view->pipe.texture);

			tic2 &= ~NV50TIC_0_2_NORMALIZED_COORDS;
			if (nv50->sampler[p][unit]->normalized)
				tic2 |= NV50TIC_0_2_NORMALIZED_COORDS;
			view->tic[2] = tic2;

			so_data  (so, view->tic[0]);
			so_reloc (so, mt->base.bo, 0, rll, 0, 0);
			so_reloc (so, mt->base.bo, 0, rlh, tic2, tic2);
			so_datap (so, &view->tic[3], 5);

d177 1
a177 1
			so_method(so, tesla, NV50TCL_BIND_TIC(p), 1);
d182 1
a182 1
			so_method(so, tesla, NV50TCL_BIND_TIC(p), 1);
d187 1
a187 1
	for (; unit < nv50->state.sampler_view_nr[p]; unit++) {
d189 1
a189 1
		so_method(so, tesla, NV50TCL_BIND_TIC(p), 1);
d193 1
a193 1
	nv50->state.sampler_view_nr[p] = nv50->sampler_view_nr[p];
a196 26
static void
nv50_emit_texture_relocs(struct nv50_context *nv50, int prog)
{
	struct nouveau_channel *chan = nv50->screen->base.channel;
	struct nouveau_bo *tic = nv50->screen->tic;
	int unit;

	for (unit = 0; unit < nv50->sampler_view_nr[prog]; unit++) {
		struct nv50_sampler_view *view;
		struct nv50_miptree *mt;
		const unsigned base = ((prog * 32) + unit) * 32;

		view = nv50_sampler_view(nv50->sampler_views[prog][unit]);
		if (!view)
			continue;
		mt = nv50_miptree(view->pipe.texture);

		nouveau_reloc_emit(chan, tic, base + 4, NULL, mt->base.bo, 0, 0,
				   NOUVEAU_BO_VRAM | NOUVEAU_BO_RD |
				   NOUVEAU_BO_LOW, 0, 0);
		nouveau_reloc_emit(chan, tic, base + 8, NULL, mt->base.bo, 0, 0,
				   NOUVEAU_BO_VRAM | NOUVEAU_BO_RD |
				   NOUVEAU_BO_HIGH, view->tic[2], view->tic[2]);
	}
}

a197 7
nv50_tex_relocs(struct nv50_context *nv50)
{
	nv50_emit_texture_relocs(nv50, 2); /* FP */
	nv50_emit_texture_relocs(nv50, 0); /* VP */
}

struct nouveau_stateobj *
d202 1
a202 1
	unsigned p, m = 0, d = 0, r = 0;
d204 8
a211 10
	for (p = 0; p < 3; ++p) {
		unsigned nr = MAX2(nv50->sampler_view_nr[p],
				   nv50->state.sampler_view_nr[p]);
		m += nr;
		d += nr;
		r += nv50->sampler_view_nr[p];
	}
	m = m * 2 + 3 * 4 + 1;
	d = d * 9 + 3 * 19 + 1;
	r = r * 2 + 3 * 2;
d213 1
a213 1
	so = so_new(m, d, r);
d215 2
a216 2
	if (nv50_validate_textures(nv50, so, 0) == FALSE ||
	    nv50_validate_textures(nv50, so, 2) == FALSE) {
d220 1
a220 1
		return NULL;
d226 2
a227 1
	return so;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d17 4
a20 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d24 1
d26 3
a28 2
#include "nv50_texture.xml.h"
#include "nv50_defs.xml.h"
a31 4
#define NV50_TIC_0_SWIZZLE__MASK                      \
   (NV50_TIC_0_MAPA__MASK | NV50_TIC_0_MAPB__MASK |   \
    NV50_TIC_0_MAPG__MASK | NV50_TIC_0_MAPR__MASK)

d33 1
a33 307
nv50_tic_swizzle(uint32_t tc, unsigned swz, boolean tex_int)
{
   switch (swz) {
   case PIPE_SWIZZLE_RED:
      return (tc & NV50_TIC_0_MAPR__MASK) >> NV50_TIC_0_MAPR__SHIFT;
   case PIPE_SWIZZLE_GREEN:
      return (tc & NV50_TIC_0_MAPG__MASK) >> NV50_TIC_0_MAPG__SHIFT;
   case PIPE_SWIZZLE_BLUE:
      return (tc & NV50_TIC_0_MAPB__MASK) >> NV50_TIC_0_MAPB__SHIFT;
   case PIPE_SWIZZLE_ALPHA:
      return (tc & NV50_TIC_0_MAPA__MASK) >> NV50_TIC_0_MAPA__SHIFT;
   case PIPE_SWIZZLE_ONE:
      return tex_int ? NV50_TIC_MAP_ONE_INT : NV50_TIC_MAP_ONE_FLOAT;
   case PIPE_SWIZZLE_ZERO:
   default:
      return NV50_TIC_MAP_ZERO;
   }
}

struct pipe_sampler_view *
nv50_create_sampler_view(struct pipe_context *pipe,
                         struct pipe_resource *res,
                         const struct pipe_sampler_view *templ)
{
   uint32_t flags = 0;

   if (res->target == PIPE_TEXTURE_RECT || res->target == PIPE_BUFFER)
      flags |= NV50_TEXVIEW_SCALED_COORDS;

   return nv50_create_texture_view(pipe, res, templ, flags, res->target);
}

struct pipe_sampler_view *
nv50_create_texture_view(struct pipe_context *pipe,
                         struct pipe_resource *texture,
                         const struct pipe_sampler_view *templ,
                         uint32_t flags,
                         enum pipe_texture_target target)
{
   const struct util_format_description *desc;
   uint64_t addr;
   uint32_t *tic;
   uint32_t swz[4];
   uint32_t depth;
   struct nv50_tic_entry *view;
   struct nv50_miptree *mt = nv50_miptree(texture);
   boolean tex_int;

   view = MALLOC_STRUCT(nv50_tic_entry);
   if (!view)
      return NULL;

   view->pipe = *templ;
   view->pipe.reference.count = 1;
   view->pipe.texture = NULL;
   view->pipe.context = pipe;

   view->id = -1;

   pipe_resource_reference(&view->pipe.texture, texture);

   tic = &view->tic[0];

   desc = util_format_description(view->pipe.format);

   /* TIC[0] */

   tic[0] = nv50_format_table[view->pipe.format].tic;

   tex_int = util_format_is_pure_integer(view->pipe.format);

   swz[0] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_r, tex_int);
   swz[1] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_g, tex_int);
   swz[2] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_b, tex_int);
   swz[3] = nv50_tic_swizzle(tic[0], view->pipe.swizzle_a, tex_int);
   tic[0] = (tic[0] & ~NV50_TIC_0_SWIZZLE__MASK) |
      (swz[0] << NV50_TIC_0_MAPR__SHIFT) |
      (swz[1] << NV50_TIC_0_MAPG__SHIFT) |
      (swz[2] << NV50_TIC_0_MAPB__SHIFT) |
      (swz[3] << NV50_TIC_0_MAPA__SHIFT);

   addr = mt->base.address;

   if (mt->base.base.target == PIPE_TEXTURE_1D_ARRAY ||
       mt->base.base.target == PIPE_TEXTURE_2D_ARRAY) {
      addr += view->pipe.u.tex.first_layer * mt->layer_stride;
      depth = view->pipe.u.tex.last_layer - view->pipe.u.tex.first_layer + 1;
   } else {
      depth = mt->base.base.depth0;
   }

   tic[2] = 0x10001000 | NV50_TIC_2_NO_BORDER;

   if (desc->colorspace == UTIL_FORMAT_COLORSPACE_SRGB)
      tic[2] |= NV50_TIC_2_COLORSPACE_SRGB;

   if (!(flags & NV50_TEXVIEW_SCALED_COORDS))
      tic[2] |= NV50_TIC_2_NORMALIZED_COORDS;

   if (unlikely(!nouveau_bo_memtype(nv04_resource(texture)->bo))) {
      if (target == PIPE_BUFFER) {
         addr += view->pipe.u.buf.first_element * desc->block.bits / 8;
         tic[2] |= NV50_TIC_2_LINEAR | NV50_TIC_2_TARGET_BUFFER;
         tic[3] = 0;
         tic[4] = /* width */
            view->pipe.u.buf.last_element - view->pipe.u.buf.first_element + 1;
         tic[5] = 0;
      } else {
         tic[2] |= NV50_TIC_2_LINEAR | NV50_TIC_2_TARGET_RECT;
         tic[3] = mt->level[0].pitch;
         tic[4] = mt->base.base.width0;
         tic[5] = (1 << 16) | mt->base.base.height0;
      }
      tic[6] =
      tic[7] = 0;
      tic[1] = addr;
      tic[2] |= addr >> 32;
      return &view->pipe;
   }

   tic[1] = addr;
   tic[2] |= (addr >> 32) & 0xff;

   tic[2] |=
      ((mt->level[0].tile_mode & 0x0f0) << (22 - 4)) |
      ((mt->level[0].tile_mode & 0xf00) << (25 - 8));

   switch (target) {
   case PIPE_TEXTURE_1D:
      tic[2] |= NV50_TIC_2_TARGET_1D;
      break;
   case PIPE_TEXTURE_2D:
      tic[2] |= NV50_TIC_2_TARGET_2D;
      break;
   case PIPE_TEXTURE_RECT:
      tic[2] |= NV50_TIC_2_TARGET_RECT;
      break;
   case PIPE_TEXTURE_3D:
      tic[2] |= NV50_TIC_2_TARGET_3D;
      break;
   case PIPE_TEXTURE_CUBE:
      depth /= 6;
      tic[2] |= NV50_TIC_2_TARGET_CUBE;
      break;
   case PIPE_TEXTURE_1D_ARRAY:
      tic[2] |= NV50_TIC_2_TARGET_1D_ARRAY;
      break;
   case PIPE_TEXTURE_2D_ARRAY:
      tic[2] |= NV50_TIC_2_TARGET_2D_ARRAY;
      break;
   case PIPE_TEXTURE_CUBE_ARRAY:
      depth /= 6;
      tic[2] |= NV50_TIC_2_TARGET_CUBE_ARRAY;
      break;
   case PIPE_BUFFER:
      assert(0); /* should be linear and handled above ! */
      tic[2] |= NV50_TIC_2_TARGET_BUFFER | NV50_TIC_2_LINEAR;
      break;
   default:
      NOUVEAU_ERR("invalid texture target: %d\n", mt->base.base.target);
      return FALSE;
   }

   tic[3] = (flags & NV50_TEXVIEW_FILTER_MSAA8) ? 0x20000000 : 0x00300000;

   tic[4] = (1 << 31) | (mt->base.base.width0 << mt->ms_x);

   tic[5] = (mt->base.base.height0 << mt->ms_y) & 0xffff;
   tic[5] |= depth << 16;
   tic[5] |= mt->base.base.last_level << NV50_TIC_5_LAST_LEVEL__SHIFT;

   tic[6] = (mt->ms_x > 1) ? 0x88000000 : 0x03000000; /* sampling points */

   tic[7] = (view->pipe.u.tex.last_level << 4) | view->pipe.u.tex.first_level;

   if (unlikely(!(tic[2] & NV50_TIC_2_NORMALIZED_COORDS)))
      if (mt->base.base.last_level)
         tic[5] &= ~NV50_TIC_5_LAST_LEVEL__MASK;

   return &view->pipe;
}

static boolean
nv50_validate_tic(struct nv50_context *nv50, int s)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nouveau_bo *txc = nv50->screen->txc;
   unsigned i;
   boolean need_flush = FALSE;

   for (i = 0; i < nv50->num_textures[s]; ++i) {
      struct nv50_tic_entry *tic = nv50_tic_entry(nv50->textures[s][i]);
      struct nv04_resource *res;

      if (!tic) {
         BEGIN_NV04(push, NV50_3D(BIND_TIC(s)), 1);
         PUSH_DATA (push, (i << 1) | 0);
         continue;
      }
      res = &nv50_miptree(tic->pipe.texture)->base;

      if (tic->id < 0) {
         tic->id = nv50_screen_tic_alloc(nv50->screen, tic);

         BEGIN_NV04(push, NV50_2D(DST_FORMAT), 2);
         PUSH_DATA (push, NV50_SURFACE_FORMAT_R8_UNORM);
         PUSH_DATA (push, 1);
         BEGIN_NV04(push, NV50_2D(DST_PITCH), 5);
         PUSH_DATA (push, 262144);
         PUSH_DATA (push, 65536);
         PUSH_DATA (push, 1);
         PUSH_DATAh(push, txc->offset);
         PUSH_DATA (push, txc->offset);
         BEGIN_NV04(push, NV50_2D(SIFC_BITMAP_ENABLE), 2);
         PUSH_DATA (push, 0);
         PUSH_DATA (push, NV50_SURFACE_FORMAT_R8_UNORM);
         BEGIN_NV04(push, NV50_2D(SIFC_WIDTH), 10);
         PUSH_DATA (push, 32);
         PUSH_DATA (push, 1);
         PUSH_DATA (push, 0);
         PUSH_DATA (push, 1);
         PUSH_DATA (push, 0);
         PUSH_DATA (push, 1);
         PUSH_DATA (push, 0);
         PUSH_DATA (push, tic->id * 32);
         PUSH_DATA (push, 0);
         PUSH_DATA (push, 0);
         BEGIN_NI04(push, NV50_2D(SIFC_DATA), 8);
         PUSH_DATAp(push, &tic->tic[0], 8);

         need_flush = TRUE;
      } else
      if (res->status & NOUVEAU_BUFFER_STATUS_GPU_WRITING) {
         BEGIN_NV04(push, NV50_3D(TEX_CACHE_CTL), 1);
         PUSH_DATA (push, 0x20);
      }

      nv50->screen->tic.lock[tic->id / 32] |= 1 << (tic->id % 32);

      res->status &= NOUVEAU_BUFFER_STATUS_GPU_WRITING;
      res->status |= NOUVEAU_BUFFER_STATUS_GPU_READING;

      BCTX_REFN(nv50->bufctx_3d, TEXTURES, res, RD);

      BEGIN_NV04(push, NV50_3D(BIND_TIC(s)), 1);
      PUSH_DATA (push, (tic->id << 9) | (i << 1) | 1);
   }
   for (; i < nv50->state.num_textures[s]; ++i) {
      BEGIN_NV04(push, NV50_3D(BIND_TIC(s)), 1);
      PUSH_DATA (push, (i << 1) | 0);
   }
   nv50->state.num_textures[s] = nv50->num_textures[s];

   return need_flush;
}

void nv50_validate_textures(struct nv50_context *nv50)
{
   boolean need_flush;

   need_flush  = nv50_validate_tic(nv50, 0);
   need_flush |= nv50_validate_tic(nv50, 2);

   if (need_flush) {
      BEGIN_NV04(nv50->base.pushbuf, NV50_3D(TIC_FLUSH), 1);
      PUSH_DATA (nv50->base.pushbuf, 0);
   }
}

static boolean
nv50_validate_tsc(struct nv50_context *nv50, int s)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   unsigned i;
   boolean need_flush = FALSE;

   for (i = 0; i < nv50->num_samplers[s]; ++i) {
      struct nv50_tsc_entry *tsc = nv50_tsc_entry(nv50->samplers[s][i]);

      if (!tsc) {
         BEGIN_NV04(push, NV50_3D(BIND_TSC(s)), 1);
         PUSH_DATA (push, (i << 4) | 0);
         continue;
      }
      if (tsc->id < 0) {
         tsc->id = nv50_screen_tsc_alloc(nv50->screen, tsc);

         nv50_sifc_linear_u8(&nv50->base, nv50->screen->txc,
                             65536 + tsc->id * 32,
                             NOUVEAU_BO_VRAM, 32, tsc->tsc);
         need_flush = TRUE;
      }
      nv50->screen->tsc.lock[tsc->id / 32] |= 1 << (tsc->id % 32);

      BEGIN_NV04(push, NV50_3D(BIND_TSC(s)), 1);
      PUSH_DATA (push, (tsc->id << 12) | (i << 4) | 1);
   }
   for (; i < nv50->state.num_samplers[s]; ++i) {
      BEGIN_NV04(push, NV50_3D(BIND_TSC(s)), 1);
      PUSH_DATA (push, (i << 4) | 0);
   }
   nv50->state.num_samplers[s] = nv50->num_samplers[s];

   return need_flush;
}

void nv50_validate_samplers(struct nv50_context *nv50)
d35 197
a231 1
   boolean need_flush;
d233 2
a234 2
   need_flush  = nv50_validate_tsc(nv50, 0);
   need_flush |= nv50_validate_tsc(nv50, 2);
d236 1
a236 4
   if (need_flush) {
      BEGIN_NV04(nv50->base.pushbuf, NV50_3D(TSC_FLUSH), 1);
      PUSH_DATA (nv50->base.pushbuf, 0);
   }
@


1.1.1.3
log
@Import Mesa 9.2.5
@
text
@d274 1
a274 1
      res->status &= ~NOUVEAU_BUFFER_STATUS_GPU_WRITING;
@


