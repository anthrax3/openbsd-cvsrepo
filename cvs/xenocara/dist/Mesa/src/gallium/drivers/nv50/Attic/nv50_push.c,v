head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.07.09.21.08.54;	author jsg;	state dead;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.00.43;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.40;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@
#include "pipe/p_context.h"
#include "pipe/p_state.h"
#include "util/u_inlines.h"
#include "util/u_format.h"
#include "translate/translate.h"

#include "nv50_context.h"
#include "nv50_resource.h"

#include "nv50_3d.xml.h"

struct push_context {
   struct nouveau_pushbuf *push;

   const void *idxbuf;

   float edgeflag;
   int edgeflag_attr;

   uint32_t vertex_words;
   uint32_t packet_vertex_limit;

   struct translate *translate;

   boolean primitive_restart;
   uint32_t prim;
   uint32_t restart_index;
   uint32_t instance_id;
};

static INLINE unsigned
prim_restart_search_i08(uint8_t *elts, unsigned push, uint8_t index)
{
   unsigned i;
   for (i = 0; i < push; ++i)
      if (elts[i] == index)
         break;
   return i;
}

static INLINE unsigned
prim_restart_search_i16(uint16_t *elts, unsigned push, uint16_t index)
{
   unsigned i;
   for (i = 0; i < push; ++i)
      if (elts[i] == index)
         break;
   return i;
}

static INLINE unsigned
prim_restart_search_i32(uint32_t *elts, unsigned push, uint32_t index)
{
   unsigned i;
   for (i = 0; i < push; ++i)
      if (elts[i] == index)
         break;
   return i;
}

static void
emit_vertices_i08(struct push_context *ctx, unsigned start, unsigned count)
{
   uint8_t *elts = (uint8_t *)ctx->idxbuf + start;

   while (count) {
      unsigned push = MIN2(count, ctx->packet_vertex_limit);
      unsigned size, nr;

      nr = push;
      if (ctx->primitive_restart)
         nr = prim_restart_search_i08(elts, push, ctx->restart_index);

      size = ctx->vertex_words * nr;

      BEGIN_NI04(ctx->push, NV50_3D(VERTEX_DATA), size);

      ctx->translate->run_elts8(ctx->translate, elts, nr, 0, ctx->instance_id,
                                ctx->push->cur);

      ctx->push->cur += size;
      count -= nr;
      elts += nr;

      if (nr != push) {
         count--;
         elts++;
         BEGIN_NV04(ctx->push, NV50_3D(VB_ELEMENT_U32), 1);
         PUSH_DATA (ctx->push, ctx->restart_index);
      }
   }
}

static void
emit_vertices_i16(struct push_context *ctx, unsigned start, unsigned count)
{
   uint16_t *elts = (uint16_t *)ctx->idxbuf + start;

   while (count) {
      unsigned push = MIN2(count, ctx->packet_vertex_limit);
      unsigned size, nr;

      nr = push;
      if (ctx->primitive_restart)
         nr = prim_restart_search_i16(elts, push, ctx->restart_index);

      size = ctx->vertex_words * nr;

      BEGIN_NI04(ctx->push, NV50_3D(VERTEX_DATA), size);

      ctx->translate->run_elts16(ctx->translate, elts, nr, 0, ctx->instance_id,
                                 ctx->push->cur);

      ctx->push->cur += size;
      count -= nr;
      elts += nr;

      if (nr != push) {
         count--;
         elts++;
         BEGIN_NV04(ctx->push, NV50_3D(VB_ELEMENT_U32), 1);
         PUSH_DATA (ctx->push, ctx->restart_index);
      }
   }
}

static void
emit_vertices_i32(struct push_context *ctx, unsigned start, unsigned count)
{
   uint32_t *elts = (uint32_t *)ctx->idxbuf + start;

   while (count) {
      unsigned push = MIN2(count, ctx->packet_vertex_limit);
      unsigned size, nr;

      nr = push;
      if (ctx->primitive_restart)
         nr = prim_restart_search_i32(elts, push, ctx->restart_index);

      size = ctx->vertex_words * nr;

      BEGIN_NI04(ctx->push, NV50_3D(VERTEX_DATA), size);

      ctx->translate->run_elts(ctx->translate, elts, nr, 0, ctx->instance_id,
                               ctx->push->cur);

      ctx->push->cur += size;
      count -= nr;
      elts += nr;

      if (nr != push) {
         count--;
         elts++;
         BEGIN_NV04(ctx->push, NV50_3D(VB_ELEMENT_U32), 1);
         PUSH_DATA (ctx->push, ctx->restart_index);
      }
   }
}

static void
emit_vertices_seq(struct push_context *ctx, unsigned start, unsigned count)
{
   while (count) {
      unsigned push = MIN2(count, ctx->packet_vertex_limit);
      unsigned size = ctx->vertex_words * push;

      BEGIN_NI04(ctx->push, NV50_3D(VERTEX_DATA), size);

      ctx->translate->run(ctx->translate, start, push, 0, ctx->instance_id,
                          ctx->push->cur);
      ctx->push->cur += size;
      count -= push;
      start += push;
   }
}


#define NV50_PRIM_GL_CASE(n) \
   case PIPE_PRIM_##n: return NV50_3D_VERTEX_BEGIN_GL_PRIMITIVE_##n

static INLINE unsigned
nv50_prim_gl(unsigned prim)
{
   switch (prim) {
   NV50_PRIM_GL_CASE(POINTS);
   NV50_PRIM_GL_CASE(LINES);
   NV50_PRIM_GL_CASE(LINE_LOOP);
   NV50_PRIM_GL_CASE(LINE_STRIP);
   NV50_PRIM_GL_CASE(TRIANGLES);
   NV50_PRIM_GL_CASE(TRIANGLE_STRIP);
   NV50_PRIM_GL_CASE(TRIANGLE_FAN);
   NV50_PRIM_GL_CASE(QUADS);
   NV50_PRIM_GL_CASE(QUAD_STRIP);
   NV50_PRIM_GL_CASE(POLYGON);
   NV50_PRIM_GL_CASE(LINES_ADJACENCY);
   NV50_PRIM_GL_CASE(LINE_STRIP_ADJACENCY);
   NV50_PRIM_GL_CASE(TRIANGLES_ADJACENCY);
   NV50_PRIM_GL_CASE(TRIANGLE_STRIP_ADJACENCY);
   /*
   NV50_PRIM_GL_CASE(PATCHES); */
   default:
      return NV50_3D_VERTEX_BEGIN_GL_PRIMITIVE_POINTS;
      break;
   }
}

void
nv50_push_vbo(struct nv50_context *nv50, const struct pipe_draw_info *info)
{
   struct push_context ctx;
   unsigned i, index_size;
   unsigned inst_count = info->instance_count;
   unsigned vert_count = info->count;
   boolean apply_bias = info->indexed && info->index_bias;

   ctx.push = nv50->base.pushbuf;
   ctx.translate = nv50->vertex->translate;
   ctx.packet_vertex_limit = nv50->vertex->packet_vertex_limit;
   ctx.vertex_words = nv50->vertex->vertex_size;

   for (i = 0; i < nv50->num_vtxbufs; ++i) {
      const struct pipe_vertex_buffer *vb = &nv50->vtxbuf[i];
      const uint8_t *data;

      if (unlikely(vb->buffer))
         data = nouveau_resource_map_offset(&nv50->base,
            nv04_resource(vb->buffer), vb->buffer_offset, NOUVEAU_BO_RD);
      else
         data = vb->user_buffer;

      if (apply_bias && likely(!(nv50->vertex->instance_bufs & (1 << i))))
         data += (ptrdiff_t)info->index_bias * vb->stride;

      ctx.translate->set_buffer(ctx.translate, i, data, vb->stride, ~0);
   }

   if (info->indexed) {
      if (nv50->idxbuf.buffer) {
         ctx.idxbuf = nouveau_resource_map_offset(&nv50->base,
            nv04_resource(nv50->idxbuf.buffer), nv50->idxbuf.offset,
            NOUVEAU_BO_RD);
      } else {
         ctx.idxbuf = nv50->idxbuf.user_buffer;
      }
      if (!ctx.idxbuf)
         return;
      index_size = nv50->idxbuf.index_size;
      ctx.primitive_restart = info->primitive_restart;
      ctx.restart_index = info->restart_index;
   } else {
      if (unlikely(info->count_from_stream_output)) {
         struct pipe_context *pipe = &nv50->base.pipe;
         struct nv50_so_target *targ;
         targ = nv50_so_target(info->count_from_stream_output);
         if (!targ->pq) {
            NOUVEAU_ERR("draw_stream_output not supported on pre-NVA0 cards\n");
            return;
         }
         pipe->get_query_result(pipe, targ->pq, TRUE, (void *)&vert_count);
         vert_count /= targ->stride;
      }
      ctx.idxbuf = NULL;
      index_size = 0;
      ctx.primitive_restart = FALSE;
      ctx.restart_index = 0;
   }

   ctx.instance_id = info->start_instance;
   ctx.prim = nv50_prim_gl(info->mode);

   if (info->primitive_restart) {
      BEGIN_NV04(ctx.push, NV50_3D(PRIM_RESTART_ENABLE), 2);
      PUSH_DATA (ctx.push, 1);
      PUSH_DATA (ctx.push, info->restart_index);
   } else
   if (nv50->state.prim_restart) {
      BEGIN_NV04(ctx.push, NV50_3D(PRIM_RESTART_ENABLE), 1);
      PUSH_DATA (ctx.push, 0);
   }
   nv50->state.prim_restart = info->primitive_restart;

   while (inst_count--) {
      BEGIN_NV04(ctx.push, NV50_3D(VERTEX_BEGIN_GL), 1);
      PUSH_DATA (ctx.push, ctx.prim);
      switch (index_size) {
      case 0:
         emit_vertices_seq(&ctx, info->start, vert_count);
         break;
      case 1:
         emit_vertices_i08(&ctx, info->start, vert_count);
         break;
      case 2:
         emit_vertices_i16(&ctx, info->start, vert_count);
         break;
      case 4:
         emit_vertices_i32(&ctx, info->start, vert_count);
         break;
      default:
         assert(0);
         break;
      }
      BEGIN_NV04(ctx.push, NV50_3D(VERTEX_END_GL), 1);
      PUSH_DATA (ctx.push, 0);

      ctx.instance_id++;
      ctx.prim |= NV50_3D_VERTEX_BEGIN_GL_INSTANCE_NEXT;
   }
}
@


1.3
log
@Merge Mesa 9.2.0
@
text
@@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d14 1
a14 1
   struct nouveau_channel *chan;
d16 1
a16 1
   void *idxbuf;
d77 1
a77 1
      BEGIN_RING_NI(ctx->chan, RING_3D(VERTEX_DATA), size);
d79 2
a80 2
      ctx->translate->run_elts8(ctx->translate, elts, nr, ctx->instance_id,
                                ctx->chan->cur);
d82 1
a82 1
      ctx->chan->cur += size;
d89 2
a90 2
         BEGIN_RING(ctx->chan, RING_3D(VB_ELEMENT_U32), 1);
         OUT_RING  (ctx->chan, ctx->restart_index);
d110 1
a110 1
      BEGIN_RING_NI(ctx->chan, RING_3D(VERTEX_DATA), size);
d112 2
a113 2
      ctx->translate->run_elts16(ctx->translate, elts, nr, ctx->instance_id,
                                 ctx->chan->cur);
d115 1
a115 1
      ctx->chan->cur += size;
d122 2
a123 2
         BEGIN_RING(ctx->chan, RING_3D(VB_ELEMENT_U32), 1);
         OUT_RING  (ctx->chan, ctx->restart_index);
d143 1
a143 1
      BEGIN_RING_NI(ctx->chan, RING_3D(VERTEX_DATA), size);
d145 2
a146 2
      ctx->translate->run_elts(ctx->translate, elts, nr, ctx->instance_id,
                               ctx->chan->cur);
d148 1
a148 1
      ctx->chan->cur += size;
d155 2
a156 2
         BEGIN_RING(ctx->chan, RING_3D(VB_ELEMENT_U32), 1);
         OUT_RING  (ctx->chan, ctx->restart_index);
d168 1
a168 1
      BEGIN_RING_NI(ctx->chan, RING_3D(VERTEX_DATA), size);
d170 3
a172 3
      ctx->translate->run(ctx->translate, start, push, ctx->instance_id,
                          ctx->chan->cur);
      ctx->chan->cur += size;
d213 2
a214 1
   unsigned inst = info->instance_count;
d217 1
a217 1
   ctx.chan = nv50->screen->base.channel;
d223 2
a224 3
      uint8_t *data;
      struct pipe_vertex_buffer *vb = &nv50->vtxbuf[i];
      struct nv04_resource *res = nv04_resource(vb->buffer);
d226 5
a230 2
      data = nouveau_resource_map_offset(&nv50->base, res,
                                         vb->buffer_offset, NOUVEAU_BO_RD);
d233 1
a233 1
         data += info->index_bias * vb->stride;
d239 7
a245 3
      ctx.idxbuf = nouveau_resource_map_offset(&nv50->base,
                                               nv04_resource(nv50->idxbuf.buffer),
                                               nv50->idxbuf.offset, NOUVEAU_BO_RD);
d252 11
d273 3
a275 3
      BEGIN_RING(ctx.chan, RING_3D(PRIM_RESTART_ENABLE), 2);
      OUT_RING  (ctx.chan, 1);
      OUT_RING  (ctx.chan, info->restart_index);
d278 2
a279 2
      BEGIN_RING(ctx.chan, RING_3D(PRIM_RESTART_ENABLE), 1);
      OUT_RING  (ctx.chan, 0);
d283 3
a285 3
   while (inst--) {
      BEGIN_RING(ctx.chan, RING_3D(VERTEX_BEGIN_GL), 1);
      OUT_RING  (ctx.chan, ctx.prim);
d288 1
a288 1
         emit_vertices_seq(&ctx, info->start, info->count);
d291 1
a291 1
         emit_vertices_i08(&ctx, info->start, info->count);
d294 1
a294 1
         emit_vertices_i16(&ctx, info->start, info->count);
d297 1
a297 1
         emit_vertices_i32(&ctx, info->start, info->count);
d303 2
a304 2
      BEGIN_RING(ctx.chan, RING_3D(VERTEX_END_GL), 1);
      OUT_RING  (ctx.chan, 0);
a308 6

   if (info->indexed)
      nouveau_resource_unmap(nv04_resource(nv50->idxbuf.buffer));

   for (i = 0; i < nv50->num_vtxbufs; ++i)
      nouveau_resource_unmap(nv04_resource(nv50->vtxbuf[i].buffer));
@


1.1
log
@Initial revision
@
text
@d1 1
d6 1
a6 1
#include "util/u_split_prim.h"
d11 2
d14 1
a14 3
   struct nv50_context *nv50;

   unsigned vtx_size;
a16 2
   int32_t idxbias;
   unsigned idxsize;
d21 9
a29 8
   struct {
      void *map;
      unsigned stride;
      unsigned divisor;
      unsigned step;
      void (*push)(struct nouveau_channel *, void *);
   } attr[16];
   unsigned attr_nr;
d32 2
a33 2
static void
emit_b32_1(struct nouveau_channel *chan, void *data)
d35 6
a40 1
   uint32_t *v = data;
d42 8
a49 1
   OUT_RING(chan, v[0]);
d52 2
a53 2
static void
emit_b32_2(struct nouveau_channel *chan, void *data)
d55 5
a59 4
   uint32_t *v = data;

   OUT_RING(chan, v[0]);
   OUT_RING(chan, v[1]);
d63 1
a63 1
emit_b32_3(struct nouveau_channel *chan, void *data)
d65 1
a65 1
   uint32_t *v = data;
d67 3
a69 4
   OUT_RING(chan, v[0]);
   OUT_RING(chan, v[1]);
   OUT_RING(chan, v[2]);
}
d71 3
a73 4
static void
emit_b32_4(struct nouveau_channel *chan, void *data)
{
   uint32_t *v = data;
d75 1
a75 5
   OUT_RING(chan, v[0]);
   OUT_RING(chan, v[1]);
   OUT_RING(chan, v[2]);
   OUT_RING(chan, v[3]);
}
d77 1
a77 4
static void
emit_b16_1(struct nouveau_channel *chan, void *data)
{
   uint16_t *v = data;
d79 2
a80 2
   OUT_RING(chan, v[0]);
}
d82 3
a84 4
static void
emit_b16_3(struct nouveau_channel *chan, void *data)
{
   uint16_t *v = data;
d86 7
a92 2
   OUT_RING(chan, (v[1] << 16) | v[0]);
   OUT_RING(chan, v[2]);
d96 1
a96 1
emit_b08_1(struct nouveau_channel *chan, void *data)
d98 1
a98 1
   uint8_t *v = data;
d100 3
a102 2
   OUT_RING(chan, v[0]);
}
d104 3
a106 4
static void
emit_b08_3(struct nouveau_channel *chan, void *data)
{
   uint8_t *v = data;
d108 1
a108 2
   OUT_RING(chan, (v[2] << 16) | (v[1] << 8) | v[0]);
}
d110 1
a110 18
static INLINE void
emit_vertex(struct push_context *ctx, unsigned n)
{
   struct nouveau_grobj *tesla = ctx->nv50->screen->tesla;
   struct nouveau_channel *chan = tesla->channel;
   int i;

   if (ctx->edgeflag_attr < 16) {
      float *edgeflag = (float *)
         ((uint8_t *)ctx->attr[ctx->edgeflag_attr].map +
          ctx->attr[ctx->edgeflag_attr].stride * n);

      if (*edgeflag != ctx->edgeflag) {
         BEGIN_RING(chan, tesla, NV50TCL_EDGEFLAG_ENABLE, 1);
         OUT_RING  (chan, *edgeflag ? 1 : 0);
         ctx->edgeflag = *edgeflag;
      }
   }
d112 2
a113 5
   BEGIN_RING_NI(chan, tesla, NV50TCL_VERTEX_DATA, ctx->vtx_size);
   for (i = 0; i < ctx->attr_nr; i++)
      ctx->attr[i].push(chan,
			(uint8_t *)ctx->attr[i].map + ctx->attr[i].stride * n);
}
d115 3
a117 6
static void
emit_edgeflag(void *priv, boolean enabled)
{
   struct push_context *ctx = priv;
   struct nouveau_grobj *tesla = ctx->nv50->screen->tesla;
   struct nouveau_channel *chan = tesla->channel;
d119 7
a125 2
   BEGIN_RING(chan, tesla, NV50TCL_EDGEFLAG_ENABLE, 1);
   OUT_RING  (chan, enabled ? 1 : 0);
d129 1
a129 1
emit_elt08(void *priv, unsigned start, unsigned count)
d131 1
a131 2
   struct push_context *ctx = priv;
   uint8_t *idxbuf = ctx->idxbuf;
d133 3
a135 3
   while (count--)
      emit_vertex(ctx, idxbuf[start++]);
}
d137 3
a139 5
static void
emit_elt08_biased(void *priv, unsigned start, unsigned count)
{
   struct push_context *ctx = priv;
   uint8_t *idxbuf = ctx->idxbuf;
d141 1
a141 3
   while (count--)
      emit_vertex(ctx, idxbuf[start++] + ctx->idxbias);
}
d143 1
a143 5
static void
emit_elt16(void *priv, unsigned start, unsigned count)
{
   struct push_context *ctx = priv;
   uint16_t *idxbuf = ctx->idxbuf;
d145 2
a146 3
   while (count--)
      emit_vertex(ctx, idxbuf[start++]);
}
d148 3
a150 5
static void
emit_elt16_biased(void *priv, unsigned start, unsigned count)
{
   struct push_context *ctx = priv;
   uint16_t *idxbuf = ctx->idxbuf;
d152 7
a158 2
   while (count--)
      emit_vertex(ctx, idxbuf[start++] + ctx->idxbias);
d162 1
a162 1
emit_elt32(void *priv, unsigned start, unsigned count)
d164 12
a175 5
   struct push_context *ctx = priv;
   uint32_t *idxbuf = ctx->idxbuf;

   while (count--)
      emit_vertex(ctx, idxbuf[start++]);
a177 5
static void
emit_elt32_biased(void *priv, unsigned start, unsigned count)
{
   struct push_context *ctx = priv;
   uint32_t *idxbuf = ctx->idxbuf;
d179 2
a180 3
   while (count--)
      emit_vertex(ctx, idxbuf[start++] + ctx->idxbias);
}
d182 2
a183 2
static void
emit_verts(void *priv, unsigned start, unsigned count)
d185 21
a205 2
   while (count--)
      emit_vertex(priv, start++);
d209 1
a209 5
nv50_push_elements_instanced(struct pipe_context *pipe,
                             struct pipe_resource *idxbuf,
                             unsigned idxsize, int idxbias,
                             unsigned mode, unsigned start, unsigned count,
                             unsigned i_start, unsigned i_count)
a210 3
   struct nv50_context *nv50 = nv50_context(pipe);
   struct nouveau_grobj *tesla = nv50->screen->tesla;
   struct nouveau_channel *chan = tesla->channel;
d212 22
a233 26
   const unsigned p_overhead = 4 + /* begin/end */
                               4; /* potential edgeflag enable/disable */
   const unsigned v_overhead = 1 + /* VERTEX_DATA packet header */
                               2; /* potential edgeflag modification */
   struct util_split_prim s;
   unsigned vtx_size;
   boolean nzi = FALSE;
   int i;

   ctx.nv50 = nv50;
   ctx.attr_nr = 0;
   ctx.idxbuf = NULL;
   ctx.vtx_size = 0;
   ctx.edgeflag = 0.5f;
   ctx.edgeflag_attr = nv50->vertprog->vp.edgeflag;

   /* map vertex buffers, determine vertex size */
   for (i = 0; i < nv50->vtxelt->num_elements; i++) {
      struct pipe_vertex_element *ve = &nv50->vtxelt->pipe[i];
      struct pipe_vertex_buffer *vb = &nv50->vtxbuf[ve->vertex_buffer_index];
      struct nouveau_bo *bo = nv50_resource(vb->buffer)->bo;
      unsigned size, nr_components, n;

      if (!(nv50->vbo_fifo & (1 << i)))
         continue;
      n = ctx.attr_nr++;
d235 5
a239 2
      if (nouveau_bo_map(bo, NOUVEAU_BO_RD)) {
         assert(bo->map);
d241 12
a252 3
      }
      ctx.attr[n].map = (uint8_t *)bo->map + vb->buffer_offset + ve->src_offset;
      nouveau_bo_unmap(bo);
d254 10
a263 6
      ctx.attr[n].stride = vb->stride;
      ctx.attr[n].divisor = ve->instance_divisor;
      if (ctx.attr[n].divisor) {
         ctx.attr[n].step = i_start % ve->instance_divisor;
         ctx.attr[n].map = (uint8_t *)ctx.attr[n].map + i_start * vb->stride;
      }
d265 9
a273 12
      size = util_format_get_component_bits(ve->src_format,
                                            UTIL_FORMAT_COLORSPACE_RGB, 0);
      nr_components = util_format_get_nr_components(ve->src_format);
      switch (size) {
      case 8:
         switch (nr_components) {
         case 1: ctx.attr[n].push = emit_b08_1; break;
         case 2: ctx.attr[n].push = emit_b16_1; break;
         case 3: ctx.attr[n].push = emit_b08_3; break;
         case 4: ctx.attr[n].push = emit_b32_1; break;
         }
         ctx.vtx_size++;
d275 2
a276 8
      case 16:
         switch (nr_components) {
         case 1: ctx.attr[n].push = emit_b16_1; break;
         case 2: ctx.attr[n].push = emit_b32_1; break;
         case 3: ctx.attr[n].push = emit_b16_3; break;
         case 4: ctx.attr[n].push = emit_b32_2; break;
         }
         ctx.vtx_size += (nr_components + 1) >> 1;
d278 2
a279 8
      case 32:
         switch (nr_components) {
         case 1: ctx.attr[n].push = emit_b32_1; break;
         case 2: ctx.attr[n].push = emit_b32_2; break;
         case 3: ctx.attr[n].push = emit_b32_3; break;
         case 4: ctx.attr[n].push = emit_b32_4; break;
         }
         ctx.vtx_size += nr_components;
d283 1
a283 1
         return;
d285 2
a286 6
   }
   vtx_size = ctx.vtx_size + v_overhead;

   /* map index buffer, if present */
   if (idxbuf) {
      struct nouveau_bo *bo = nv50_resource(idxbuf)->bo;
d288 2
a289 8
      if (nouveau_bo_map(bo, NOUVEAU_BO_RD)) {
         assert(bo->map);
         return;
      }
      ctx.idxbuf = bo->map;
      ctx.idxbias = idxbias;
      ctx.idxsize = idxsize;
      nouveau_bo_unmap(bo);
d292 2
a293 12
   s.priv = &ctx;
   s.edge = emit_edgeflag;
   if (idxbuf) {
      if (idxsize == 1)
         s.emit = idxbias ? emit_elt08_biased : emit_elt08;
      else
      if (idxsize == 2)
         s.emit = idxbias ? emit_elt16_biased : emit_elt16;
      else
         s.emit = idxbias ? emit_elt32_biased : emit_elt32;
   } else
      s.emit = emit_verts;
d295 2
a296 39
   /* per-instance loop */
   BEGIN_RING(chan, tesla, NV50TCL_CB_ADDR, 2);
   OUT_RING  (chan, NV50_CB_AUX | (24 << 8));
   OUT_RING  (chan, i_start);
   while (i_count--) {
      unsigned max_verts;
      boolean done;

      for (i = 0; i < ctx.attr_nr; i++) {
         if (!ctx.attr[i].divisor ||
              ctx.attr[i].divisor != ++ctx.attr[i].step)
            continue;
         ctx.attr[i].step = 0;
         ctx.attr[i].map = (uint8_t *)ctx.attr[i].map + ctx.attr[i].stride;
      }

      util_split_prim_init(&s, mode, start, count);
      do {
         if (AVAIL_RING(chan) < p_overhead + (6 * vtx_size)) {
            FIRE_RING(chan);
            if (!nv50_state_validate(nv50, p_overhead + (6 * vtx_size))) {
               assert(0);
               return;
            }
         }

         max_verts  = AVAIL_RING(chan);
         max_verts -= p_overhead;
         max_verts /= vtx_size;

         BEGIN_RING(chan, tesla, NV50TCL_VERTEX_BEGIN, 1);
         OUT_RING  (chan, nv50_prim(s.mode) | (nzi ? (1 << 28) : 0));
         done = util_split_prim_next(&s, max_verts);
         BEGIN_RING(chan, tesla, NV50TCL_VERTEX_END, 1);
         OUT_RING  (chan, 0);
      } while (!done);

      nzi = TRUE;
   }
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a0 1

d5 1
a5 1
#include "translate/translate.h"
d10 2
a11 1
#include "nv50_3d.xml.h"
d13 1
a13 2
struct push_context {
   struct nouveau_pushbuf *push;
d15 3
a17 1
   const void *idxbuf;
d22 8
a29 9
   uint32_t vertex_words;
   uint32_t packet_vertex_limit;

   struct translate *translate;

   boolean primitive_restart;
   uint32_t prim;
   uint32_t restart_index;
   uint32_t instance_id;
d32 2
a33 2
static INLINE unsigned
prim_restart_search_i08(uint8_t *elts, unsigned push, uint8_t index)
d35 3
a37 5
   unsigned i;
   for (i = 0; i < push; ++i)
      if (elts[i] == index)
         break;
   return i;
d40 2
a41 2
static INLINE unsigned
prim_restart_search_i16(uint16_t *elts, unsigned push, uint16_t index)
d43 4
a46 5
   unsigned i;
   for (i = 0; i < push; ++i)
      if (elts[i] == index)
         break;
   return i;
d49 2
a50 2
static INLINE unsigned
prim_restart_search_i32(uint32_t *elts, unsigned push, uint32_t index)
d52 5
a56 5
   unsigned i;
   for (i = 0; i < push; ++i)
      if (elts[i] == index)
         break;
   return i;
d60 1
a60 1
emit_vertices_i08(struct push_context *ctx, unsigned start, unsigned count)
d62 1
a62 1
   uint8_t *elts = (uint8_t *)ctx->idxbuf + start;
d64 5
a68 3
   while (count) {
      unsigned push = MIN2(count, ctx->packet_vertex_limit);
      unsigned size, nr;
d70 4
a73 3
      nr = push;
      if (ctx->primitive_restart)
         nr = prim_restart_search_i08(elts, push, ctx->restart_index);
d75 2
a76 1
      size = ctx->vertex_words * nr;
d78 4
a81 1
      BEGIN_NI04(ctx->push, NV50_3D(VERTEX_DATA), size);
d83 3
a85 2
      ctx->translate->run_elts8(ctx->translate, elts, nr, 0, ctx->instance_id,
                                ctx->push->cur);
d87 4
a90 3
      ctx->push->cur += size;
      count -= nr;
      elts += nr;
d92 1
a92 7
      if (nr != push) {
         count--;
         elts++;
         BEGIN_NV04(ctx->push, NV50_3D(VB_ELEMENT_U32), 1);
         PUSH_DATA (ctx->push, ctx->restart_index);
      }
   }
d96 1
a96 1
emit_vertices_i16(struct push_context *ctx, unsigned start, unsigned count)
d98 1
a98 1
   uint16_t *elts = (uint16_t *)ctx->idxbuf + start;
d100 2
a101 3
   while (count) {
      unsigned push = MIN2(count, ctx->packet_vertex_limit);
      unsigned size, nr;
d103 18
a120 3
      nr = push;
      if (ctx->primitive_restart)
         nr = prim_restart_search_i16(elts, push, ctx->restart_index);
d122 5
a126 1
      size = ctx->vertex_words * nr;
d128 6
a133 1
      BEGIN_NI04(ctx->push, NV50_3D(VERTEX_DATA), size);
d135 3
a137 2
      ctx->translate->run_elts16(ctx->translate, elts, nr, 0, ctx->instance_id,
                                 ctx->push->cur);
d139 5
a143 3
      ctx->push->cur += size;
      count -= nr;
      elts += nr;
d145 2
a146 7
      if (nr != push) {
         count--;
         elts++;
         BEGIN_NV04(ctx->push, NV50_3D(VB_ELEMENT_U32), 1);
         PUSH_DATA (ctx->push, ctx->restart_index);
      }
   }
d150 1
a150 1
emit_vertices_i32(struct push_context *ctx, unsigned start, unsigned count)
d152 2
a153 1
   uint32_t *elts = (uint32_t *)ctx->idxbuf + start;
d155 3
a157 3
   while (count) {
      unsigned push = MIN2(count, ctx->packet_vertex_limit);
      unsigned size, nr;
d159 5
a163 3
      nr = push;
      if (ctx->primitive_restart)
         nr = prim_restart_search_i32(elts, push, ctx->restart_index);
d165 3
a167 1
      size = ctx->vertex_words * nr;
d169 5
a173 1
      BEGIN_NI04(ctx->push, NV50_3D(VERTEX_DATA), size);
d175 3
a177 2
      ctx->translate->run_elts(ctx->translate, elts, nr, 0, ctx->instance_id,
                               ctx->push->cur);
d179 5
a183 3
      ctx->push->cur += size;
      count -= nr;
      elts += nr;
d185 2
a186 7
      if (nr != push) {
         count--;
         elts++;
         BEGIN_NV04(ctx->push, NV50_3D(VB_ELEMENT_U32), 1);
         PUSH_DATA (ctx->push, ctx->restart_index);
      }
   }
d190 1
a190 1
emit_vertices_seq(struct push_context *ctx, unsigned start, unsigned count)
d192 5
a196 12
   while (count) {
      unsigned push = MIN2(count, ctx->packet_vertex_limit);
      unsigned size = ctx->vertex_words * push;

      BEGIN_NI04(ctx->push, NV50_3D(VERTEX_DATA), size);

      ctx->translate->run(ctx->translate, start, push, 0, ctx->instance_id,
                          ctx->push->cur);
      ctx->push->cur += size;
      count -= push;
      start += push;
   }
d199 2
a200 6

#define NV50_PRIM_GL_CASE(n) \
   case PIPE_PRIM_##n: return NV50_3D_VERTEX_BEGIN_GL_PRIMITIVE_##n

static INLINE unsigned
nv50_prim_gl(unsigned prim)
d202 2
a203 21
   switch (prim) {
   NV50_PRIM_GL_CASE(POINTS);
   NV50_PRIM_GL_CASE(LINES);
   NV50_PRIM_GL_CASE(LINE_LOOP);
   NV50_PRIM_GL_CASE(LINE_STRIP);
   NV50_PRIM_GL_CASE(TRIANGLES);
   NV50_PRIM_GL_CASE(TRIANGLE_STRIP);
   NV50_PRIM_GL_CASE(TRIANGLE_FAN);
   NV50_PRIM_GL_CASE(QUADS);
   NV50_PRIM_GL_CASE(QUAD_STRIP);
   NV50_PRIM_GL_CASE(POLYGON);
   NV50_PRIM_GL_CASE(LINES_ADJACENCY);
   NV50_PRIM_GL_CASE(LINE_STRIP_ADJACENCY);
   NV50_PRIM_GL_CASE(TRIANGLES_ADJACENCY);
   NV50_PRIM_GL_CASE(TRIANGLE_STRIP_ADJACENCY);
   /*
   NV50_PRIM_GL_CASE(PATCHES); */
   default:
      return NV50_3D_VERTEX_BEGIN_GL_PRIMITIVE_POINTS;
      break;
   }
d207 5
a211 1
nv50_push_vbo(struct nv50_context *nv50, const struct pipe_draw_info *info)
d213 3
d217 33
a249 19
   unsigned i, index_size;
   unsigned inst_count = info->instance_count;
   unsigned vert_count = info->count;
   boolean apply_bias = info->indexed && info->index_bias;

   ctx.push = nv50->base.pushbuf;
   ctx.translate = nv50->vertex->translate;
   ctx.packet_vertex_limit = nv50->vertex->packet_vertex_limit;
   ctx.vertex_words = nv50->vertex->vertex_size;

   for (i = 0; i < nv50->num_vtxbufs; ++i) {
      const struct pipe_vertex_buffer *vb = &nv50->vtxbuf[i];
      const uint8_t *data;

      if (unlikely(vb->buffer))
         data = nouveau_resource_map_offset(&nv50->base,
            nv04_resource(vb->buffer), vb->buffer_offset, NOUVEAU_BO_RD);
      else
         data = vb->user_buffer;
d251 6
a256 2
      if (apply_bias && likely(!(nv50->vertex->instance_bufs & (1 << i))))
         data += (ptrdiff_t)info->index_bias * vb->stride;
d258 35
a292 1
      ctx.translate->set_buffer(ctx.translate, i, data, vb->stride, ~0);
d294 5
d300 2
a301 9
   if (info->indexed) {
      if (nv50->idxbuf.buffer) {
         ctx.idxbuf = nouveau_resource_map_offset(&nv50->base,
            nv04_resource(nv50->idxbuf.buffer), nv50->idxbuf.offset,
            NOUVEAU_BO_RD);
      } else {
         ctx.idxbuf = nv50->idxbuf.user_buffer;
      }
      if (!ctx.idxbuf)
a302 14
      index_size = nv50->idxbuf.index_size;
      ctx.primitive_restart = info->primitive_restart;
      ctx.restart_index = info->restart_index;
   } else {
      if (unlikely(info->count_from_stream_output)) {
         struct pipe_context *pipe = &nv50->base.pipe;
         struct nv50_so_target *targ;
         targ = nv50_so_target(info->count_from_stream_output);
         if (!targ->pq) {
            NOUVEAU_ERR("draw_stream_output not supported on pre-NVA0 cards\n");
            return;
         }
         pipe->get_query_result(pipe, targ->pq, TRUE, (void *)&vert_count);
         vert_count /= targ->stride;
d304 4
a307 4
      ctx.idxbuf = NULL;
      index_size = 0;
      ctx.primitive_restart = FALSE;
      ctx.restart_index = 0;
d310 10
a319 7
   ctx.instance_id = info->start_instance;
   ctx.prim = nv50_prim_gl(info->mode);

   if (info->primitive_restart) {
      BEGIN_NV04(ctx.push, NV50_3D(PRIM_RESTART_ENABLE), 2);
      PUSH_DATA (ctx.push, 1);
      PUSH_DATA (ctx.push, info->restart_index);
d321 1
a321 5
   if (nv50->state.prim_restart) {
      BEGIN_NV04(ctx.push, NV50_3D(PRIM_RESTART_ENABLE), 1);
      PUSH_DATA (ctx.push, 0);
   }
   nv50->state.prim_restart = info->primitive_restart;
d323 14
a336 19
   while (inst_count--) {
      BEGIN_NV04(ctx.push, NV50_3D(VERTEX_BEGIN_GL), 1);
      PUSH_DATA (ctx.push, ctx.prim);
      switch (index_size) {
      case 0:
         emit_vertices_seq(&ctx, info->start, vert_count);
         break;
      case 1:
         emit_vertices_i08(&ctx, info->start, vert_count);
         break;
      case 2:
         emit_vertices_i16(&ctx, info->start, vert_count);
         break;
      case 4:
         emit_vertices_i32(&ctx, info->start, vert_count);
         break;
      default:
         assert(0);
         break;
a337 2
      BEGIN_NV04(ctx.push, NV50_3D(VERTEX_END_GL), 1);
      PUSH_DATA (ctx.push, 0);
d339 22
a360 2
      ctx.instance_id++;
      ctx.prim |= NV50_3D_VERTEX_BEGIN_GL_INSTANCE_NEXT;
@

