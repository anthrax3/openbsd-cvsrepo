head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.07.09.21.08.54;	author jsg;	state dead;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.00.44;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.05;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.11.41;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@/*
 * Copyright 2008 Ben Skeggs
 * Copyright 2010 Christoph Bumiller
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "pipe/p_state.h"
#include "util/u_inlines.h"

#include "nv50_context.h"

void
nv50_constbufs_validate(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   unsigned s;

   for (s = 0; s < 3; ++s) {
      unsigned p;

      if (s == PIPE_SHADER_FRAGMENT)
         p = NV50_3D_SET_PROGRAM_CB_PROGRAM_FRAGMENT;
      else
      if (s == PIPE_SHADER_GEOMETRY)
         p = NV50_3D_SET_PROGRAM_CB_PROGRAM_GEOMETRY;
      else
         p = NV50_3D_SET_PROGRAM_CB_PROGRAM_VERTEX;

      while (nv50->constbuf_dirty[s]) {
         const int i = ffs(nv50->constbuf_dirty[s]) - 1;
         nv50->constbuf_dirty[s] &= ~(1 << i);

         if (nv50->constbuf[s][i].user) {
            const unsigned b = NV50_CB_PVP + s;
            unsigned start = 0;
            unsigned words = nv50->constbuf[s][0].size / 4;
            if (i) {
               NOUVEAU_ERR("user constbufs only supported in slot 0\n");
               continue;
            }
            if (!nv50->state.uniform_buffer_bound[s]) {
               nv50->state.uniform_buffer_bound[s] = TRUE;
               BEGIN_NV04(push, NV50_3D(SET_PROGRAM_CB), 1);
               PUSH_DATA (push, (b << 12) | (i << 8) | p | 1);
            }
            while (words) {
               unsigned nr;

               if (!PUSH_SPACE(push, 16))
                  break;
               nr = PUSH_AVAIL(push);
               assert(nr >= 16);
               nr = MIN2(MIN2(nr - 3, words), NV04_PFIFO_MAX_PACKET_LEN);

               BEGIN_NV04(push, NV50_3D(CB_ADDR), 1);
               PUSH_DATA (push, (start << 8) | b);
               BEGIN_NI04(push, NV50_3D(CB_DATA(0)), nr);
               PUSH_DATAp(push, &nv50->constbuf[s][0].u.data[start * 4], nr);

               start += nr;
               words -= nr;
            }
         } else {
            struct nv04_resource *res =
               nv04_resource(nv50->constbuf[s][i].u.buf);
            if (res) {
               /* TODO: allocate persistent bindings */
               const unsigned b = s * 16 + i;

               assert(nouveau_resource_mapped_by_gpu(&res->base));

               BEGIN_NV04(push, NV50_3D(CB_DEF_ADDRESS_HIGH), 3);
               PUSH_DATAh(push, res->address + nv50->constbuf[s][i].offset);
               PUSH_DATA (push, res->address + nv50->constbuf[s][i].offset);
               PUSH_DATA (push, (b << 16) |
                          (nv50->constbuf[s][i].size & 0xffff));
               BEGIN_NV04(push, NV50_3D(SET_PROGRAM_CB), 1);
               PUSH_DATA (push, (b << 12) | (i << 8) | p | 1);

               BCTX_REFN(nv50->bufctx_3d, CB(s, i), res, RD);
            } else {
               BEGIN_NV04(push, NV50_3D(SET_PROGRAM_CB), 1);
               PUSH_DATA (push, (i << 8) | p | 0);
            }
            if (i == 0)
               nv50->state.uniform_buffer_bound[s] = FALSE;
         }
      }
   }
}

static boolean
nv50_program_validate(struct nv50_context *nv50, struct nv50_program *prog)
{
   if (!prog->translated) {
      prog->translated = nv50_program_translate(
         prog, nv50->screen->base.device->chipset);
      if (!prog->translated)
         return FALSE;
   } else
   if (prog->mem)
      return TRUE;

   return nv50_program_upload_code(nv50, prog);
}

static INLINE void
nv50_program_update_context_state(struct nv50_context *nv50,
                                  struct nv50_program *prog, int stage)
{
   const unsigned flags = NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR;

   if (prog && prog->tls_space) {
      if (nv50->state.new_tls_space)
         nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_TLS);
      if (!nv50->state.tls_required || nv50->state.new_tls_space)
         BCTX_REFN_bo(nv50->bufctx_3d, TLS, flags, nv50->screen->tls_bo);
      nv50->state.new_tls_space = FALSE;
      nv50->state.tls_required |= 1 << stage;
   } else {
      if (nv50->state.tls_required == (1 << stage))
         nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_TLS);
      nv50->state.tls_required &= ~(1 << stage);
   }
}

void
nv50_vertprog_validate(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nv50_program *vp = nv50->vertprog;

   if (!nv50_program_validate(nv50, vp))
         return;
   nv50_program_update_context_state(nv50, vp, 0);

   BEGIN_NV04(push, NV50_3D(VP_ATTR_EN(0)), 2);
   PUSH_DATA (push, vp->vp.attrs[0]);
   PUSH_DATA (push, vp->vp.attrs[1]);
   BEGIN_NV04(push, NV50_3D(VP_REG_ALLOC_RESULT), 1);
   PUSH_DATA (push, vp->max_out);
   BEGIN_NV04(push, NV50_3D(VP_REG_ALLOC_TEMP), 1);
   PUSH_DATA (push, vp->max_gpr);
   BEGIN_NV04(push, NV50_3D(VP_START_ID), 1);
   PUSH_DATA (push, vp->code_base);
}

void
nv50_fragprog_validate(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nv50_program *fp = nv50->fragprog;

   if (!nv50_program_validate(nv50, fp))
         return;
   nv50_program_update_context_state(nv50, fp, 1);

   BEGIN_NV04(push, NV50_3D(FP_REG_ALLOC_TEMP), 1);
   PUSH_DATA (push, fp->max_gpr);
   BEGIN_NV04(push, NV50_3D(FP_RESULT_COUNT), 1);
   PUSH_DATA (push, fp->max_out);
   BEGIN_NV04(push, NV50_3D(FP_CONTROL), 1);
   PUSH_DATA (push, fp->fp.flags[0]);
   BEGIN_NV04(push, NV50_3D(FP_CTRL_UNK196C), 1);
   PUSH_DATA (push, fp->fp.flags[1]);
   BEGIN_NV04(push, NV50_3D(FP_START_ID), 1);
   PUSH_DATA (push, fp->code_base);
}

void
nv50_gmtyprog_validate(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nv50_program *gp = nv50->gmtyprog;

   if (gp) {
      BEGIN_NV04(push, NV50_3D(GP_REG_ALLOC_TEMP), 1);
      PUSH_DATA (push, gp->max_gpr);
      BEGIN_NV04(push, NV50_3D(GP_REG_ALLOC_RESULT), 1);
      PUSH_DATA (push, gp->max_out);
      BEGIN_NV04(push, NV50_3D(GP_OUTPUT_PRIMITIVE_TYPE), 1);
      PUSH_DATA (push, gp->gp.prim_type);
      BEGIN_NV04(push, NV50_3D(GP_VERTEX_OUTPUT_COUNT), 1);
      PUSH_DATA (push, gp->gp.vert_count);
      BEGIN_NV04(push, NV50_3D(GP_START_ID), 1);
      PUSH_DATA (push, gp->code_base);

      nv50->state.prim_size = gp->gp.prim_type; /* enum matches vertex count */
   }
   nv50_program_update_context_state(nv50, gp, 2);

   /* GP_ENABLE is updated in linkage validation */
}

static void
nv50_sprite_coords_validate(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   uint32_t pntc[8], mode;
   struct nv50_program *fp = nv50->fragprog;
   unsigned i, c;
   unsigned m = (nv50->state.interpolant_ctrl >> 8) & 0xff;

   if (!nv50->rast->pipe.point_quad_rasterization) {
      if (nv50->state.point_sprite) {
         BEGIN_NV04(push, NV50_3D(POINT_COORD_REPLACE_MAP(0)), 8);
         for (i = 0; i < 8; ++i)
            PUSH_DATA(push, 0);

         nv50->state.point_sprite = FALSE;
      }
      return;
   } else {
      nv50->state.point_sprite = TRUE;
   }

   memset(pntc, 0, sizeof(pntc));

   for (i = 0; i < fp->in_nr; i++) {
      unsigned n = util_bitcount(fp->in[i].mask);

      if (fp->in[i].sn != TGSI_SEMANTIC_GENERIC) {
         m += n;
         continue;
      }
      if (!(nv50->rast->pipe.sprite_coord_enable & (1 << fp->in[i].si))) {
         m += n;
         continue;
      }

      for (c = 0; c < 4; ++c) {
         if (fp->in[i].mask & (1 << c)) {
            pntc[m / 8] |= (c + 1) << ((m % 8) * 4);
            ++m;
         }
      }
   }

   if (nv50->rast->pipe.sprite_coord_mode == PIPE_SPRITE_COORD_LOWER_LEFT)
      mode = 0x00;
   else
      mode = 0x10;

   BEGIN_NV04(push, NV50_3D(POINT_SPRITE_CTRL), 1);
   PUSH_DATA (push, mode);

   BEGIN_NV04(push, NV50_3D(POINT_COORD_REPLACE_MAP(0)), 8);
   PUSH_DATAp(push, pntc, 8);
}

/* Validate state derived from shaders and the rasterizer cso. */
void
nv50_validate_derived_rs(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   uint32_t color, psize;

   nv50_sprite_coords_validate(nv50);

   if (nv50->state.rasterizer_discard != nv50->rast->pipe.rasterizer_discard) {
      nv50->state.rasterizer_discard = nv50->rast->pipe.rasterizer_discard;
      BEGIN_NV04(push, NV50_3D(RASTERIZE_ENABLE), 1);
      PUSH_DATA (push, !nv50->rast->pipe.rasterizer_discard);
   }

   if (nv50->dirty & NV50_NEW_FRAGPROG)
      return;
   psize = nv50->state.semantic_psize & ~NV50_3D_SEMANTIC_PTSZ_PTSZ_EN__MASK;
   color = nv50->state.semantic_color & ~NV50_3D_SEMANTIC_COLOR_CLMP_EN;

   if (nv50->rast->pipe.clamp_vertex_color)
      color |= NV50_3D_SEMANTIC_COLOR_CLMP_EN;

   if (color != nv50->state.semantic_color) {
      nv50->state.semantic_color = color;
      BEGIN_NV04(push, NV50_3D(SEMANTIC_COLOR), 1);
      PUSH_DATA (push, color);
   }

   if (nv50->rast->pipe.point_size_per_vertex)
      psize |= NV50_3D_SEMANTIC_PTSZ_PTSZ_EN__MASK;

   if (psize != nv50->state.semantic_psize) {
      nv50->state.semantic_psize = psize;
      BEGIN_NV04(push, NV50_3D(SEMANTIC_PTSZ), 1);
      PUSH_DATA (push, psize);
   }
}

static int
nv50_vec4_map(uint8_t *map, int mid, uint32_t lin[4],
              struct nv50_varying *in, struct nv50_varying *out)
{
   int c;
   uint8_t mv = out->mask, mf = in->mask, oid = out->hw;

   for (c = 0; c < 4; ++c) {
      if (mf & 1) {
         if (in->linear)
            lin[mid / 32] |= 1 << (mid % 32);
         if (mv & 1)
            map[mid] = oid;
         else
         if (c == 3)
            map[mid] |= 1;
         ++mid;
      }

      oid += mv & 1;
      mf >>= 1;
      mv >>= 1;
   }

   return mid;
}

void
nv50_fp_linkage_validate(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nv50_program *vp = nv50->gmtyprog ? nv50->gmtyprog : nv50->vertprog;
   struct nv50_program *fp = nv50->fragprog;
   struct nv50_varying dummy;
   int i, n, c, m;
   uint32_t primid = 0;
   uint32_t psiz = 0x000;
   uint32_t interp = fp->fp.interp;
   uint32_t colors = fp->fp.colors;
   uint32_t lin[4];
   uint8_t map[64];
   uint8_t so_map[64];

   if (!(nv50->dirty & (NV50_NEW_VERTPROG |
                        NV50_NEW_FRAGPROG |
                        NV50_NEW_GMTYPROG))) {
      uint8_t bfc, ffc;
      ffc = (nv50->state.semantic_color & NV50_3D_SEMANTIC_COLOR_FFC0_ID__MASK);
      bfc = (nv50->state.semantic_color & NV50_3D_SEMANTIC_COLOR_BFC0_ID__MASK)
         >> 8;
      if (nv50->rast->pipe.light_twoside == ((ffc == bfc) ? 0 : 1))
         return;
   }

   memset(lin, 0x00, sizeof(lin));

   /* XXX: in buggy-endian mode, is the first element of map (u32)0x000000xx
    *  or is it the first byte ?
    */
   memset(map, nv50->gmtyprog ? 0x80 : 0x40, sizeof(map));

   dummy.mask = 0xf; /* map all components of HPOS */
   dummy.linear = 0;
   m = nv50_vec4_map(map, 0, lin, &dummy, &vp->out[0]);

   for (c = 0; c < vp->vp.clpd_nr; ++c)
      map[m++] = vp->vp.clpd[c / 4] + (c % 4);

   colors |= m << 8; /* adjust BFC0 id */

   dummy.mask = 0x0;

   /* if light_twoside is active, FFC0_ID == BFC0_ID is invalid */
   if (nv50->rast->pipe.light_twoside) {
      for (i = 0; i < 2; ++i) {
         n = vp->vp.bfc[i];
         if (fp->vp.bfc[i] >= fp->in_nr)
            continue;
         m = nv50_vec4_map(map, m, lin, &fp->in[fp->vp.bfc[i]],
                           (n < vp->out_nr) ? &vp->out[n] : &dummy);
      }
   }
   colors += m - 4; /* adjust FFC0 id */
   interp |= m << 8; /* set map id where 'normal' FP inputs start */

   for (i = 0; i < fp->in_nr; ++i) {
      for (n = 0; n < vp->out_nr; ++n)
         if (vp->out[n].sn == fp->in[i].sn &&
             vp->out[n].si == fp->in[i].si)
            break;
      m = nv50_vec4_map(map, m, lin,
                        &fp->in[i], (n < vp->out_nr) ? &vp->out[n] : &dummy);
   }

   /* PrimitiveID either is replaced by the system value, or
    * written by the geometry shader into an output register
    */
   if (fp->gp.primid < 0x80) {
      primid = m;
      map[m++] = vp->gp.primid;
   }

   if (nv50->rast->pipe.point_size_per_vertex) {
      psiz = (m << 4) | 1;
      map[m++] = vp->vp.psiz;
   }

   if (nv50->rast->pipe.clamp_vertex_color)
      colors |= NV50_3D_SEMANTIC_COLOR_CLMP_EN;

   if (unlikely(vp->so)) {
      /* Slot i in STRMOUT_MAP specifies the offset where slot i in RESULT_MAP
       * gets written.
       *
       * TODO:
       * Inverting vp->so->map (output -> offset) would probably speed this up.
       */
      memset(so_map, 0, sizeof(so_map));
      for (i = 0; i < vp->so->map_size; ++i) {
         if (vp->so->map[i] == 0xff)
            continue;
         for (c = 0; c < m; ++c)
            if (map[c] == vp->so->map[i] && !so_map[c])
               break;
         if (c == m) {
            c = m;
            map[m++] = vp->so->map[i];
         }
         so_map[c] = 0x80 | i;
      }
      for (c = m; c & 3; ++c)
         so_map[c] = 0;
   }

   n = (m + 3) / 4;
   assert(m <= 64);

   if (unlikely(nv50->gmtyprog)) {
      BEGIN_NV04(push, NV50_3D(GP_RESULT_MAP_SIZE), 1);
      PUSH_DATA (push, m);
      BEGIN_NV04(push, NV50_3D(GP_RESULT_MAP(0)), n);
      PUSH_DATAp(push, map, n);
   } else {
      BEGIN_NV04(push, NV50_3D(VP_GP_BUILTIN_ATTR_EN), 1);
      PUSH_DATA (push, vp->vp.attrs[2]);

      BEGIN_NV04(push, NV50_3D(SEMANTIC_PRIM_ID), 1);
      PUSH_DATA (push, primid);

      BEGIN_NV04(push, NV50_3D(VP_RESULT_MAP_SIZE), 1);
      PUSH_DATA (push, m);
      BEGIN_NV04(push, NV50_3D(VP_RESULT_MAP(0)), n);
      PUSH_DATAp(push, map, n);
   }

   BEGIN_NV04(push, NV50_3D(SEMANTIC_COLOR), 4);
   PUSH_DATA (push, colors);
   PUSH_DATA (push, (vp->vp.clpd_nr << 8) | 4);
   PUSH_DATA (push, 0);
   PUSH_DATA (push, psiz);

   BEGIN_NV04(push, NV50_3D(FP_INTERPOLANT_CTRL), 1);
   PUSH_DATA (push, interp);

   nv50->state.interpolant_ctrl = interp;

   nv50->state.semantic_color = colors;
   nv50->state.semantic_psize = psiz;

   BEGIN_NV04(push, NV50_3D(NOPERSPECTIVE_BITMAP(0)), 4);
   PUSH_DATAp(push, lin, 4);

   BEGIN_NV04(push, NV50_3D(GP_ENABLE), 1);
   PUSH_DATA (push, nv50->gmtyprog ? 1 : 0);

   if (vp->so) {
      BEGIN_NV04(push, NV50_3D(STRMOUT_MAP(0)), n);
      PUSH_DATAp(push, so_map, n);
   }
}

static int
nv50_vp_gp_mapping(uint8_t *map, int m,
                   struct nv50_program *vp, struct nv50_program *gp)
{
   int i, j, c;

   for (i = 0; i < gp->in_nr; ++i) {
      uint8_t oid = 0, mv = 0, mg = gp->in[i].mask;

      for (j = 0; j < vp->out_nr; ++j) {
         if (vp->out[j].sn == gp->in[i].sn &&
             vp->out[j].si == gp->in[i].si) {
            mv = vp->out[j].mask;
            oid = vp->out[j].hw;
            break;
         }
      }

      for (c = 0; c < 4; ++c, mv >>= 1, mg >>= 1) {
         if (mg & mv & 1)
            map[m++] = oid;
         else
         if (mg & 1)
            map[m++] = (c == 3) ? 0x41 : 0x40;
         oid += mv & 1;
      }
   }
   return m;
}

void
nv50_gp_linkage_validate(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nv50_program *vp = nv50->vertprog;
   struct nv50_program *gp = nv50->gmtyprog;
   int m = 0;
   int n;
   uint8_t map[64];

   if (!gp)
      return;
   memset(map, 0, sizeof(map));

   m = nv50_vp_gp_mapping(map, m, vp, gp);

   n = (m + 3) / 4;

   BEGIN_NV04(push, NV50_3D(VP_GP_BUILTIN_ATTR_EN), 1);
   PUSH_DATA (push, vp->vp.attrs[2] | gp->vp.attrs[2]);

   BEGIN_NV04(push, NV50_3D(VP_RESULT_MAP_SIZE), 1);
   PUSH_DATA (push, m);
   BEGIN_NV04(push, NV50_3D(VP_RESULT_MAP(0)), n);
   PUSH_DATAp(push, map, n);
}

void
nv50_stream_output_validate(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nv50_stream_output_state *so;
   uint32_t ctrl;
   unsigned i;
   unsigned prims = ~0;

   so = nv50->gmtyprog ? nv50->gmtyprog->so : nv50->vertprog->so;

   BEGIN_NV04(push, NV50_3D(STRMOUT_ENABLE), 1);
   PUSH_DATA (push, 0);
   if (!so || !nv50->num_so_targets) {
      if (nv50->screen->base.class_3d < NVA0_3D_CLASS) {
         BEGIN_NV04(push, NV50_3D(STRMOUT_PRIMITIVE_LIMIT), 1);
         PUSH_DATA (push, 0);
      }
      BEGIN_NV04(push, NV50_3D(STRMOUT_PARAMS_LATCH), 1);
      PUSH_DATA (push, 1);
      return;
   }

   /* previous TFB needs to complete */
   if (nv50->screen->base.class_3d < NVA0_3D_CLASS) {
      BEGIN_NV04(push, SUBC_3D(NV50_GRAPH_SERIALIZE), 1);
      PUSH_DATA (push, 0);
   }

   ctrl = so->ctrl;
   if (nv50->screen->base.class_3d >= NVA0_3D_CLASS)
      ctrl |= NVA0_3D_STRMOUT_BUFFERS_CTRL_LIMIT_MODE_OFFSET;

   BEGIN_NV04(push, NV50_3D(STRMOUT_BUFFERS_CTRL), 1);
   PUSH_DATA (push, ctrl);

   nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_SO);

   for (i = 0; i < nv50->num_so_targets; ++i) {
      struct nv50_so_target *targ = nv50_so_target(nv50->so_target[i]);
      struct nv04_resource *buf = nv04_resource(targ->pipe.buffer);

      const unsigned n = nv50->screen->base.class_3d >= NVA0_3D_CLASS ? 4 : 3;

      if (n == 4 && !targ->clean)
         nv84_query_fifo_wait(push, targ->pq);
      BEGIN_NV04(push, NV50_3D(STRMOUT_ADDRESS_HIGH(i)), n);
      PUSH_DATAh(push, buf->address + targ->pipe.buffer_offset);
      PUSH_DATA (push, buf->address + targ->pipe.buffer_offset);
      PUSH_DATA (push, so->num_attribs[i]);
      if (n == 4) {
         PUSH_DATA(push, targ->pipe.buffer_size);

         BEGIN_NV04(push, NVA0_3D(STRMOUT_OFFSET(i)), 1);
         if (!targ->clean) {
            assert(targ->pq);
            nv50_query_pushbuf_submit(push, targ->pq, 0x4);
         } else {
            PUSH_DATA(push, 0);
            targ->clean = FALSE;
         }
      } else {
         const unsigned limit = targ->pipe.buffer_size /
            (so->stride[i] * nv50->state.prim_size);
         prims = MIN2(prims, limit);
      }
      BCTX_REFN(nv50->bufctx_3d, SO, buf, WR);
   }
   if (prims != ~0) {
      BEGIN_NV04(push, NV50_3D(STRMOUT_PRIMITIVE_LIMIT), 1);
      PUSH_DATA (push, prims);
   }
   BEGIN_NV04(push, NV50_3D(STRMOUT_PARAMS_LATCH), 1);
   PUSH_DATA (push, 1);
   BEGIN_NV04(push, NV50_3D(STRMOUT_ENABLE), 1);
   PUSH_DATA (push, 1);
}
@


1.3
log
@Merge Mesa 9.2.0
@
text
@@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d18 4
a21 4
 * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
d34 1
a34 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d38 1
a38 3
      struct nv04_resource *res;
      int i;
      unsigned p, b;
d49 1
a49 5
         struct nouveau_bo *bo;
         unsigned start = 0;
         unsigned words = 0;

         i = ffs(nv50->constbuf_dirty[s]) - 1;
d52 12
a63 5
         res = nv04_resource(nv50->constbuf[s][i]);
         if (!res) {
            if (i != 0) {
               BEGIN_RING(chan, RING_3D(SET_PROGRAM_CB), 1);
               OUT_RING  (chan, (i << 8) | p | 0);
d65 2
a66 2
            continue;
         }
d68 10
a77 2
         if (i == 0) {
            b = NV50_CB_PVP + s;
d79 3
a81 3
            /* always upload GL uniforms through CB DATA */
            bo = nv50->screen->uniforms;
            words = res->base.width0 / 4;
d83 20
a102 37
            b = s * 16 + i;

            assert(0);

            if (!nouveau_resource_mapped_by_gpu(&res->base)) {
               nouveau_buffer_migrate(&nv50->base, res, NOUVEAU_BO_VRAM);

               BEGIN_RING(chan, RING_3D(CODE_CB_FLUSH), 1);
               OUT_RING  (chan, 0);
            }
            MARK_RING (chan, 6, 2);
            BEGIN_RING(chan, RING_3D(CB_DEF_ADDRESS_HIGH), 3);
            OUT_RESRCh(chan, res, 0, NOUVEAU_BO_RD);
            OUT_RESRCl(chan, res, 0, NOUVEAU_BO_RD);
            OUT_RING  (chan, (b << 16) | (res->base.width0 & 0xffff));
            BEGIN_RING(chan, RING_3D(SET_PROGRAM_CB), 1);
            OUT_RING  (chan, (b << 12) | (i << 8) | p | 1);

            bo = res->bo;

            nv50_bufctx_add_resident(nv50, NV50_BUFCTX_CONSTANT, res,
                                     res->domain | NOUVEAU_BO_RD);
         }

         if (words) {
            MARK_RING(chan, 8, 1);

            nouveau_bo_validate(chan, bo, res->domain | NOUVEAU_BO_WR);
         }

         while (words) {
            unsigned nr = AVAIL_RING(chan);

            if (nr < 16) {
               FIRE_RING(chan);
               nouveau_bo_validate(chan, bo, res->domain | NOUVEAU_BO_WR);
               continue;
d104 2
a105 9
            nr = MIN2(MIN2(nr - 3, words), NV04_PFIFO_MAX_PACKET_LEN);

            BEGIN_RING(chan, RING_3D(CB_ADDR), 1);
            OUT_RING  (chan, (start << 8) | b);
            BEGIN_RING_NI(chan, RING_3D(CB_DATA(0)), nr);
            OUT_RINGp (chan, &res->data[start * 4], nr);

            start += nr;
            words -= nr;
d114 7
a120 5
   struct nouveau_resource *heap;
   int ret;
   unsigned size;

   if (prog->translated)
d123 2
a124 3
   prog->translated = nv50_program_translate(prog);
   if (!prog->translated)
      return FALSE;
d126 17
a142 12
   if (prog->type == PIPE_SHADER_FRAGMENT) heap = nv50->screen->fp_code_heap;
   else
   if (prog->type == PIPE_SHADER_GEOMETRY) heap = nv50->screen->gp_code_heap;
   else
      heap = nv50->screen->vp_code_heap;

   size = align(prog->code_size, 0x100);

   ret = nouveau_resource_alloc(heap, size, prog, &prog->res);
   if (ret) {
      NOUVEAU_ERR("out of code space for shader type %i\n", prog->type);
      return FALSE;
a143 12
   prog->code_base = prog->res->start;

   nv50_relocate_program(prog, prog->code_base, 0);

   nv50_sifc_linear_u8(&nv50->base, nv50->screen->code,
                       (prog->type << NV50_CODE_BO_SIZE_LOG2) + prog->code_base,
                       NOUVEAU_BO_VRAM, prog->code_size, prog->code);

   BEGIN_RING(nv50->screen->base.channel, RING_3D(CODE_CB_FLUSH), 1);
   OUT_RING  (nv50->screen->base.channel, 0);

   return TRUE;
d149 1
a149 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
a151 6
   if (nv50->clip.nr > vp->vp.clpd_nr) {
      if (vp->translated)
         nv50_program_destroy(nv50, vp);
      vp->vp.clpd_nr = nv50->clip.nr;
   }

d154 1
d156 9
a164 9
   BEGIN_RING(chan, RING_3D(VP_ATTR_EN(0)), 2);
   OUT_RING  (chan, vp->vp.attrs[0]);
   OUT_RING  (chan, vp->vp.attrs[1]);
   BEGIN_RING(chan, RING_3D(VP_REG_ALLOC_RESULT), 1);
   OUT_RING  (chan, vp->max_out);
   BEGIN_RING(chan, RING_3D(VP_REG_ALLOC_TEMP), 1);
   OUT_RING  (chan, vp->max_gpr);
   BEGIN_RING(chan, RING_3D(VP_START_ID), 1);
   OUT_RING  (chan, vp->code_base);
d170 1
a170 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d175 1
d177 10
a186 10
   BEGIN_RING(chan, RING_3D(FP_REG_ALLOC_TEMP), 1);
   OUT_RING  (chan, fp->max_gpr);
   BEGIN_RING(chan, RING_3D(FP_RESULT_COUNT), 1);
   OUT_RING  (chan, fp->max_out);
   BEGIN_RING(chan, RING_3D(FP_CONTROL), 1);
   OUT_RING  (chan, fp->fp.flags[0]);
   BEGIN_RING(chan, RING_3D(FP_CTRL_UNK196C), 1);
   OUT_RING  (chan, fp->fp.flags[1]);
   BEGIN_RING(chan, RING_3D(FP_START_ID), 1);
   OUT_RING  (chan, fp->code_base);
d192 1
a192 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d195 15
a209 4
   if (!gp) /* GP_ENABLE is updated in linkage validation */
      return;
   if (!nv50_program_validate(nv50, gp))
      return;
d211 1
a211 10
   BEGIN_RING(chan, RING_3D(GP_REG_ALLOC_TEMP), 1);
   OUT_RING  (chan, gp->max_gpr);
   BEGIN_RING(chan, RING_3D(GP_REG_ALLOC_RESULT), 1);
   OUT_RING  (chan, gp->max_out);
   BEGIN_RING(chan, RING_3D(GP_OUTPUT_PRIMITIVE_TYPE), 1);
   OUT_RING  (chan, gp->gp.prim_type);
   BEGIN_RING(chan, RING_3D(GP_VERTEX_OUTPUT_COUNT), 1);
   OUT_RING  (chan, gp->gp.vert_count);
   BEGIN_RING(chan, RING_3D(GP_START_ID), 1);
   OUT_RING  (chan, gp->code_base);
d217 1
a217 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d225 1
a225 1
         BEGIN_RING(chan, RING_3D(POINT_COORD_REPLACE_MAP(0)), 8);
d227 1
a227 1
            OUT_RING(chan, 0);
d263 2
a264 2
   BEGIN_RING(chan, RING_3D(POINT_SPRITE_CTRL), 1);
   OUT_RING  (chan, mode);
d266 2
a267 2
   BEGIN_RING(chan, RING_3D(POINT_COORD_REPLACE_MAP(0)), 8);
   OUT_RINGp (chan, pntc, 8);
d274 1
a274 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d279 6
d287 2
a288 2
   psize = nv50->state.semantic_psize & ~NV50_3D_MAP_SEMANTIC_3_PTSZ_EN__MASK;
   color = nv50->state.semantic_color & ~NV50_3D_MAP_SEMANTIC_0_CLMP_EN;
d291 1
a291 1
      color |= NV50_3D_MAP_SEMANTIC_0_CLMP_EN;
d295 2
a296 2
      BEGIN_RING(chan, RING_3D(MAP_SEMANTIC_0), 1);
      OUT_RING  (chan, color);
d300 1
a300 1
      psize |= NV50_3D_MAP_SEMANTIC_3_PTSZ_EN__MASK;
d304 2
a305 2
      BEGIN_RING(chan, RING_3D(MAP_SEMANTIC_3), 1);
      OUT_RING  (chan, psize);
d339 1
a339 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d350 12
d375 1
a375 1
      map[m++] = vp->vp.clpd + c;
d379 2
d383 7
a389 3
      for (i = 0; i < 2; ++i)
         m = nv50_vec4_map(map, m, lin,
                           &fp->in[fp->vp.bfc[i]], &vp->out[vp->vp.bfc[i]]);
a393 1
   dummy.mask = 0x0;
d406 1
a406 1
   if (fp->gp.primid < 0x40) {
d417 25
a441 1
      colors |= NV50_3D_MAP_SEMANTIC_0_CLMP_EN;
d447 4
a450 4
      BEGIN_RING(chan, RING_3D(GP_RESULT_MAP_SIZE), 1);
      OUT_RING  (chan, m);
      BEGIN_RING(chan, RING_3D(GP_RESULT_MAP(0)), n);
      OUT_RINGp (chan, map, n);
d452 2
a453 2
      BEGIN_RING(chan, RING_3D(VP_GP_BUILTIN_ATTR_EN), 1);
      OUT_RING  (chan, vp->vp.attrs[2]);
d455 2
a456 2
      BEGIN_RING(chan, RING_3D(MAP_SEMANTIC_4), 1);
      OUT_RING  (chan, primid);
d458 11
a468 11
      BEGIN_RING(chan, RING_3D(VP_RESULT_MAP_SIZE), 1);
      OUT_RING  (chan, m);
      BEGIN_RING(chan, RING_3D(VP_RESULT_MAP(0)), n);
      OUT_RINGp (chan, map, n);
   }

   BEGIN_RING(chan, RING_3D(MAP_SEMANTIC_0), 4);
   OUT_RING  (chan, colors);
   OUT_RING  (chan, (vp->vp.clpd_nr << 8) | 4);
   OUT_RING  (chan, 0);
   OUT_RING  (chan, psiz);
d470 2
a471 2
   BEGIN_RING(chan, RING_3D(FP_INTERPOLANT_CTRL), 1);
   OUT_RING  (chan, interp);
d478 2
a479 2
   BEGIN_RING(chan, RING_3D(NOPERSPECTIVE_BITMAP(0)), 4);
   OUT_RINGp (chan, lin, 4);
d481 7
a487 2
   BEGIN_RING(chan, RING_3D(GP_ENABLE), 1);
   OUT_RING  (chan, nv50->gmtyprog ? 1 : 0);
d523 1
a523 1
   struct nouveau_channel *chan = nv50->screen->base.channel;
d538 31
a568 2
   BEGIN_RING(chan, RING_3D(VP_GP_BUILTIN_ATTR_EN), 1);
   OUT_RING  (chan, vp->vp.attrs[2] | gp->vp.attrs[2]);
d570 53
a622 4
   BEGIN_RING(chan, RING_3D(VP_RESULT_MAP_SIZE), 1);
   OUT_RING  (chan, m);
   BEGIN_RING(chan, RING_3D(VP_RESULT_MAP(0)), n);
   OUT_RINGp (chan, map, n);
@


1.1
log
@Initial revision
@
text
@d31 2
a32 3
static void
nv50_transfer_constbuf(struct nv50_context *nv50,
                       struct pipe_resource *buf, unsigned size, unsigned cbi)
a33 2
   struct pipe_context *pipe = &nv50->pipe;
   struct pipe_transfer *transfer;
d35 1
a35 3
   struct nouveau_grobj *tesla = nv50->screen->tesla;
   uint32_t *map;
   unsigned count, start;
d37 4
a40 2
   if (buf == NULL)
      return;
d42 7
a48 3
   map = pipe_buffer_map(pipe, buf, PIPE_TRANSFER_READ, &transfer);
   if (!map)
      return;
d50 16
a65 2
   count = (buf->width0 + 3) / 4;
   start = 0;
d67 2
a68 9
   while (count) {
      unsigned nr = AVAIL_RING(chan);

      if (nr < 8) {
         FIRE_RING(chan);
         continue;
      }
      nr = MIN2(count, nr - 7);
      nr = MIN2(nr, NV04_PFIFO_MAX_PACKET_LEN);
d70 21
a90 1
      nv50_screen_reloc_constbuf(nv50->screen, cbi);
d92 1
a92 4
      BEGIN_RING(chan, tesla, NV50TCL_CB_ADDR, 1);
      OUT_RING  (chan, (start << 8) | cbi);
      BEGIN_RING_NI(chan, tesla, NV50TCL_CB_DATA(0), nr);
      OUT_RINGp (chan, map, nr);
d94 3
a96 4
      count -= nr;
      start += nr;
      map += nr;
   }
d98 2
a99 2
   pipe_buffer_unmap(pipe, buf, transfer);
}
d101 2
a102 6
static void
nv50_program_validate_data(struct nv50_context *nv50, struct nv50_program *p)
{
   struct nouveau_channel *chan = nv50->screen->base.channel;
   struct nouveau_grobj *tesla = nv50->screen->tesla;
   unsigned cbi;
d104 2
a105 4
   if (p->immd_size) {
      uint32_t *data = p->immd;
      unsigned count = p->immd_size / 4;
      unsigned start = 0;
d107 11
a117 2
      while (count) {
         unsigned nr = AVAIL_RING(chan);
d119 2
a120 3
         if (nr < 8) {
            FIRE_RING(chan);
            continue;
a121 13
         nr = MIN2(count, nr - 7);
         nr = MIN2(nr, NV04_PFIFO_MAX_PACKET_LEN);

         nv50_screen_reloc_constbuf(nv50->screen, NV50_CB_PMISC);

         BEGIN_RING(chan, tesla, NV50TCL_CB_ADDR, 1);
         OUT_RING  (chan, (start << 8) | NV50_CB_PMISC);
         BEGIN_RING_NI(chan, tesla, NV50TCL_CB_DATA(0), nr);
         OUT_RINGp (chan, data, nr);

         count -= nr;
         start += nr;
         data += nr;
a123 25

   /* If the state tracker doesn't change the constbuf, and it is first
    * validated with a program that doesn't use it, this check prevents
    * it from even being uploaded. */
   /*
   if (p->parm_size == 0)
      return;
   */

   switch (p->type) {
   case PIPE_SHADER_VERTEX:
      cbi = NV50_CB_PVP;
      break;
   case PIPE_SHADER_FRAGMENT:
      cbi = NV50_CB_PFP;
      break;
   case PIPE_SHADER_GEOMETRY:
      cbi = NV50_CB_PGP;
      break;
   default:
      assert(0);
      return;
   }

   nv50_transfer_constbuf(nv50, nv50->constbuf[p->type], p->parm_size, cbi);
d126 2
a127 2
static void
nv50_program_validate_code(struct nv50_context *nv50, struct nv50_program *p)
d129 1
a129 3
   struct nouveau_channel *chan = nv50->screen->base.channel;
   struct nouveau_grobj *tesla = nv50->screen->tesla;
   struct nouveau_grobj *eng2d = nv50->screen->eng2d;
d131 1
a131 3
   unsigned offset;
   unsigned size = p->code_size;
   uint32_t *data = p->code;
d133 2
a134 1
   assert(p->translated);
d136 9
a144 5
   /* TODO: use a single bo (for each type) for shader code */
   if (p->bo)
      return;
   ret = nouveau_bo_new(chan->device, NOUVEAU_BO_VRAM, 0x100, size, &p->bo);
   assert(!ret);
d146 1
a146 1
   offset = p->code_start = 0;
d148 4
a151 45
   BEGIN_RING(chan, eng2d, NV50_2D_DST_FORMAT, 2);
   OUT_RING  (chan, NV50_2D_DST_FORMAT_R8_UNORM);
   OUT_RING  (chan, 1);
   BEGIN_RING(chan, eng2d, NV50_2D_DST_PITCH, 1);
   OUT_RING  (chan, 0x40000);
   BEGIN_RING(chan, eng2d, NV50_2D_DST_WIDTH, 2);
   OUT_RING  (chan, 0x10000);
   OUT_RING  (chan, 1);

   while (size) {
      unsigned nr = size / 4;

      if (AVAIL_RING(chan) < 32)
         FIRE_RING(chan);

      nr = MIN2(nr, AVAIL_RING(chan) - 18);
      nr = MIN2(nr, 1792);
      if (nr < (size / 4))
         nr &= ~0x3f;
      assert(!(size & 3));

      BEGIN_RING(chan, eng2d, NV50_2D_DST_ADDRESS_HIGH, 2);
      OUT_RELOCh(chan, p->bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_WR);
      OUT_RELOCl(chan, p->bo, offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_WR);
      BEGIN_RING(chan, eng2d, NV50_2D_SIFC_BITMAP_ENABLE, 2);
      OUT_RING  (chan, 0);
      OUT_RING  (chan, NV50_2D_SIFC_FORMAT_R8_UNORM);
      BEGIN_RING(chan, eng2d, NV50_2D_SIFC_WIDTH, 10);
      OUT_RING  (chan, nr * 4);
      OUT_RING  (chan, 1);
      OUT_RING  (chan, 0);
      OUT_RING  (chan, 1);
      OUT_RING  (chan, 0);
      OUT_RING  (chan, 1);
      OUT_RING  (chan, 0);
      OUT_RING  (chan, 0);
      OUT_RING  (chan, 0);
      OUT_RING  (chan, 0);

      BEGIN_RING_NI(chan, eng2d, NV50_2D_SIFC_DATA, nr);
      OUT_RINGp (chan, data, nr);

      data += nr;
      offset += nr * 4;
      size -= nr * 4;
d153 1
d155 1
a155 9
   BEGIN_RING(chan, tesla, NV50TCL_CODE_CB_FLUSH, 1);
   OUT_RING  (chan, 0);
}

static void
nv50_vp_update_stateobj(struct nv50_context *nv50, struct nv50_program *p)
{
   struct nouveau_grobj *tesla = nv50->screen->tesla;
   struct nouveau_stateobj *so = so_new(5, 7, 2);
d157 3
a159 1
   nv50_program_validate_code(nv50, p);
d161 2
a162 14
   so_method(so, tesla, NV50TCL_VP_ADDRESS_HIGH, 2);
   so_reloc (so, p->bo, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_RD |
             NOUVEAU_BO_HIGH, 0, 0);
   so_reloc (so, p->bo, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_RD |
             NOUVEAU_BO_LOW, 0, 0);
   so_method(so, tesla, NV50TCL_VP_ATTR_EN_0, 2);
   so_data  (so, p->vp.attrs[0]);
   so_data  (so, p->vp.attrs[1]);
   so_method(so, tesla, NV50TCL_VP_REG_ALLOC_RESULT, 1);
   so_data  (so, p->max_out);
   so_method(so, tesla, NV50TCL_VP_REG_ALLOC_TEMP, 1);
   so_data  (so, p->max_gpr);
   so_method(so, tesla, NV50TCL_VP_START_ID, 1);
   so_data  (so, p->code_start);
d164 1
a164 2
   so_ref(so, &p->so);
   so_ref(NULL, &so);
d167 2
a168 2
static void
nv50_fp_update_stateobj(struct nv50_context *nv50, struct nv50_program *p)
d170 2
a171 20
   struct nouveau_grobj *tesla = nv50->screen->tesla;
	struct nouveau_stateobj *so = so_new(6, 7, 2);

   nv50_program_validate_code(nv50, p);

   so_method(so, tesla, NV50TCL_FP_ADDRESS_HIGH, 2);
   so_reloc (so, p->bo, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_RD |
             NOUVEAU_BO_HIGH, 0, 0);
   so_reloc (so, p->bo, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_RD |
             NOUVEAU_BO_LOW, 0, 0);
   so_method(so, tesla, NV50TCL_FP_REG_ALLOC_TEMP, 1);
   so_data  (so, p->max_gpr);
   so_method(so, tesla, NV50TCL_FP_RESULT_COUNT, 1);
   so_data  (so, p->max_out);
   so_method(so, tesla, NV50TCL_FP_CONTROL, 1);
   so_data  (so, p->fp.flags[0]);
   so_method(so, tesla, NV50TCL_FP_CTRL_UNK196C, 1);
   so_data  (so, p->fp.flags[1]);
   so_method(so, tesla, NV50TCL_FP_START_ID, 1);
   so_data  (so, p->code_start);
d173 18
a190 2
   so_ref(so, &p->so);
   so_ref(NULL, &so);
d193 2
a194 2
static void
nv50_gp_update_stateobj(struct nv50_context *nv50, struct nv50_program *p)
d196 2
a197 4
   struct nouveau_grobj *tesla = nv50->screen->tesla;
	struct nouveau_stateobj *so = so_new(6, 7, 2);

   nv50_program_validate_code(nv50, p);
d199 2
a200 15
   so_method(so, tesla, NV50TCL_GP_ADDRESS_HIGH, 2);
   so_reloc (so, p->bo, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_RD |
             NOUVEAU_BO_HIGH, 0, 0);
   so_reloc (so, p->bo, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_RD |
             NOUVEAU_BO_LOW, 0, 0);
   so_method(so, tesla, NV50TCL_GP_REG_ALLOC_TEMP, 1);
   so_data  (so, p->max_gpr);
   so_method(so, tesla, NV50TCL_GP_REG_ALLOC_RESULT, 1);
   so_data  (so, p->max_out);
   so_method(so, tesla, NV50TCL_GP_OUTPUT_PRIMITIVE_TYPE, 1);
   so_data  (so, p->gp.prim_type);
   so_method(so, tesla, NV50TCL_GP_VERTEX_OUTPUT_COUNT, 1);
   so_data  (so, p->gp.vert_count);
   so_method(so, tesla, NV50TCL_GP_START_ID, 1);
   so_data  (so, p->code_start);
d202 10
a211 2
   so_ref(so, &p->so);
   so_ref(NULL, &so);
d214 2
a215 2
static boolean
nv50_program_validate(struct nv50_program *p)
d217 2
a218 4
   p->translated = nv50_program_tx(p);
   assert(p->translated);
   return p->translated;
}
d220 4
a223 4
static INLINE void
nv50_program_validate_common(struct nv50_context *nv50, struct nv50_program *p)
{
   nv50_program_validate_code(nv50, p);
d225 10
a234 4
   if (p->uses_lmem)
      nv50->req_lmem |= 1 << p->type;
   else
      nv50->req_lmem &= ~(1 << p->type);
d237 2
a238 2
struct nouveau_stateobj *
nv50_vertprog_validate(struct nv50_context *nv50)
d240 5
a244 2
   struct nv50_program *p = nv50->vertprog;
   struct nouveau_stateobj *so = NULL;
d246 5
a250 6
   if (!p->translated) {
      if (nv50_program_validate(p))
         nv50_vp_update_stateobj(nv50, p);
      else
         return NULL;
   }
d252 5
a256 23
   if (nv50->dirty & NV50_NEW_VERTPROG_CB)
      nv50_program_validate_data(nv50, p);

   if (!(nv50->dirty & NV50_NEW_VERTPROG))
      return NULL;

   nv50_program_validate_common(nv50, p);

   so_ref(p->so, &so);
   return so;
}

struct nouveau_stateobj *
nv50_fragprog_validate(struct nv50_context *nv50)
{
   struct nv50_program *p = nv50->fragprog;
   struct nouveau_stateobj *so = NULL;

   if (!p->translated) {
      if (nv50_program_validate(p))
         nv50_fp_update_stateobj(nv50, p);
      else
         return NULL;
d259 1
a259 2
   if (nv50->dirty & NV50_NEW_FRAGPROG_CB)
      nv50_program_validate_data(nv50, p);
d261 2
a262 2
   if (!(nv50->dirty & NV50_NEW_FRAGPROG))
      return NULL;
d264 8
a271 1
   nv50_program_validate_common(nv50, p);
d273 6
a278 19
   so_ref(p->so, &so);
   return so;
}

struct nouveau_stateobj *
nv50_geomprog_validate(struct nv50_context *nv50)
{
   struct nv50_program *p = nv50->geomprog;
   struct nouveau_stateobj *so = NULL;

   /* GP may be NULL, but VP and FP may not */
   if (!p)
      return NULL; /* GP is deactivated in linkage validation */

   if (!p->translated) {
      if (nv50_program_validate(p))
         nv50_gp_update_stateobj(nv50, p);
      else
         return NULL;
d281 4
a284 2
   if (nv50->dirty & NV50_NEW_GEOMPROG_CB)
      nv50_program_validate_data(nv50, p);
d286 2
a287 2
   if (!(nv50->dirty & NV50_NEW_GEOMPROG))
      return NULL;
d289 2
a290 4
   nv50_program_validate_common(nv50, p);

   so_ref(p->so, &so);
   return so;
d293 3
a295 5
/* XXX: this might not work correctly in all cases yet: we assume that
 * an FP generic input that is not written in the VP is gl_PointCoord.
 */
static uint32_t
nv50_pntc_replace(struct nv50_context *nv50, uint32_t pntc[8], unsigned m)
d297 2
a298 3
   struct nv50_program *vp = nv50->vertprog;
   struct nv50_program *fp = nv50->fragprog;
   unsigned i, c;
d300 1
a300 1
   memset(pntc, 0, 8 * sizeof(uint32_t));
d302 4
a305 2
   if (nv50->geomprog)
      vp = nv50->geomprog;
d307 2
a308 2
   for (i = 0; i < fp->in_nr; i++) {
      unsigned j, n = util_bitcount(fp->in[i].mask);
d310 5
a314 8
      if (fp->in[i].sn != TGSI_SEMANTIC_GENERIC) {
         m += n;
         continue;
      }

      for (j = 0; j < vp->out_nr; ++j)
         if (vp->out[j].sn == fp->in[i].sn && vp->out[j].si == fp->in[i].si)
            break;
d316 2
a317 2
      if (j < vp->out_nr) {
         uint32_t en = nv50->rasterizer->pipe.sprite_coord_enable;
d319 4
a322 13
         if (!(en & (1 << vp->out[j].si))) {
            m += n;
            continue;
         }
      }

      /* this is either PointCoord or replaced by sprite coords */
      for (c = 0; c < 4; c++) {
         if (!(fp->in[i].mask & (1 << c)))
            continue;
         pntc[m / 8] |= (c + 1) << ((m % 8) * 4);
         ++m;
      }
a323 3
   if (nv50->rasterizer->pipe.sprite_coord_mode == PIPE_SPRITE_COORD_LOWER_LEFT)
      return 0;
   return (1 << 4);
d327 1
a327 1
nv50_vec4_map(uint32_t *map32, int mid, uint32_t lin[4],
a331 1
   uint8_t *map = (uint8_t *)map32;
d353 1
a353 1
struct nouveau_stateobj *
d356 2
a357 2
   struct nouveau_grobj *tesla = nv50->screen->tesla;
   struct nv50_program *vp;
a358 1
   struct nouveau_stateobj *so;
d361 2
a362 3

   uint32_t map[16], lin[4], pntc[8];

d365 4
a368 4
   uint32_t clip = 0x04;
   uint32_t psiz = 0x000;
   uint32_t primid = 0;
   uint32_t sysval = 0;
d370 4
a373 8
   if (nv50->geomprog) {
      vp = nv50->geomprog;
      memset(map, 0x80, sizeof(map));
   } else {
      vp = nv50->vertprog;
      memset(map, 0x40, sizeof(map));
   }
   memset(lin, 0, sizeof(lin));
d375 1
a376 1
   dummy.mask = 0xf; /* map all components of HPOS */
d379 2
a380 7
   if (vp->vp.clpd < 0x40) {
      for (c = 0; c < vp->vp.clpd_nr; ++c) {
         map[m / 4] |= (vp->vp.clpd + c) << ((m % 4) * 8);
         ++m;
      }
      clip |= vp->vp.clpd_nr << 8;
   }
d384 2
a385 2
   /* if light_twoside is active, it seems FFC0_ID == BFC0_ID is bad */
   if (nv50->rasterizer->pipe.light_twoside) {
d388 1
a388 2
                           &fp->in[fp->vp.bfc[i]],
                           &vp->out[vp->vp.bfc[i]]);
a389 1

d391 1
a391 1
   interp |= m << 8; /* set mid where 'normal' FP inputs start */
d394 1
a394 1
   for (i = 0; i < fp->in_nr; i++) {
a398 1

d401 1
a401 1
	}
d407 2
a408 3
      i = (m % 4) * 8;
      map[m / 4] = (map[m / 4] & ~(0xff << i)) | (vp->gp.primid << i);
      primid = m++;
d411 3
a413 4
   if (nv50->rasterizer->pipe.point_size_per_vertex) {
      i = (m % 4) * 8;
      map[m / 4] = (map[m / 4] & ~(0xff << i)) | (vp->vp.psiz << i);
      psiz = (m++ << 4) | 1;
d416 2
a417 2
   /* now fill the stateobj (at most 28 so_data)  */
   so = so_new(10, 54, 0);
d421 6
a426 5
   if (vp->type == PIPE_SHADER_GEOMETRY) {
      so_method(so, tesla, NV50TCL_GP_RESULT_MAP_SIZE, 1);
      so_data  (so, m);
      so_method(so, tesla, NV50TCL_GP_RESULT_MAP(0), n);
      so_datap (so, map, n);
d428 2
a429 2
      so_method(so, tesla, NV50TCL_VP_GP_BUILTIN_ATTR_EN, 1);
      so_data  (so, vp->vp.attrs[2]);
d431 2
a432 2
      so_method(so, tesla, NV50TCL_MAP_SEMANTIC_4, 1);
      so_data  (so, primid);
d434 4
a437 4
      so_method(so, tesla, NV50TCL_VP_RESULT_MAP_SIZE, 1);
      so_data  (so, m);
      so_method(so, tesla, NV50TCL_VP_RESULT_MAP(0), n);
      so_datap (so, map, n);
d440 5
a444 8
   so_method(so, tesla, NV50TCL_MAP_SEMANTIC_0, 4);
   so_data  (so, colors);
   so_data  (so, clip);
   so_data  (so, sysval);
   so_data  (so, psiz);

   so_method(so, tesla, NV50TCL_FP_INTERPOLANT_CTRL, 1);
   so_data  (so, interp);
d446 2
a447 2
   so_method(so, tesla, NV50TCL_NOPERSPECTIVE_BITMAP(0), 4);
   so_datap (so, lin, 4);
d449 1
a449 4
   if (nv50->rasterizer->pipe.point_quad_rasterization) {
      so_method(so, tesla, NV50TCL_POINT_SPRITE_CTRL, 1);
      so_data  (so,
                nv50_pntc_replace(nv50, pntc, (interp >> 8) & 0xff));
d451 2
a452 3
      so_method(so, tesla, NV50TCL_POINT_COORD_REPLACE_MAP(0), 8);
      so_datap (so, pntc, 8);
   }
d454 2
a455 2
   so_method(so, tesla, NV50TCL_GP_ENABLE, 1);
   so_data  (so, (vp->type == PIPE_SHADER_GEOMETRY) ? 1 : 0);
d457 2
a458 1
   return so;
d462 1
a462 1
nv50_vp_gp_mapping(uint32_t *map32, int m,
a464 1
   uint8_t *map = (uint8_t *)map32;
d491 1
a491 1
struct nouveau_stateobj *
d494 1
a494 2
   struct nouveau_grobj *tesla = nv50->screen->tesla;
   struct nouveau_stateobj *so;
d496 1
a496 2
   struct nv50_program *gp = nv50->geomprog;
   uint32_t map[16];
d498 2
d502 1
a502 1
      return NULL;
d507 1
a507 8
   so = so_new(3, 24 - 3, 0);

   so_method(so, tesla, NV50TCL_VP_GP_BUILTIN_ATTR_EN, 1);
   so_data  (so, vp->vp.attrs[2] | gp->vp.attrs[2]);

   assert(m <= 32);
   so_method(so, tesla, NV50TCL_VP_RESULT_MAP_SIZE, 1);
   so_data  (so, m);
d509 2
a510 3
   m = (m + 3) / 4;
   so_method(so, tesla, NV50TCL_VP_RESULT_MAP(0), m);
   so_datap (so, map, m);
d512 4
a515 1
   return so;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d18 4
a21 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d31 3
a33 2
void
nv50_constbufs_validate(struct nv50_context *nv50)
d35 13
a47 2
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   unsigned s;
d49 2
a50 2
   for (s = 0; s < 3; ++s) {
      unsigned p;
d52 2
a53 7
      if (s == PIPE_SHADER_FRAGMENT)
         p = NV50_3D_SET_PROGRAM_CB_PROGRAM_FRAGMENT;
      else
      if (s == PIPE_SHADER_GEOMETRY)
         p = NV50_3D_SET_PROGRAM_CB_PROGRAM_GEOMETRY;
      else
         p = NV50_3D_SET_PROGRAM_CB_PROGRAM_VERTEX;
d55 3
a57 59
      while (nv50->constbuf_dirty[s]) {
         const int i = ffs(nv50->constbuf_dirty[s]) - 1;
         nv50->constbuf_dirty[s] &= ~(1 << i);

         if (nv50->constbuf[s][i].user) {
            const unsigned b = NV50_CB_PVP + s;
            unsigned start = 0;
            unsigned words = nv50->constbuf[s][0].size / 4;
            if (i) {
               NOUVEAU_ERR("user constbufs only supported in slot 0\n");
               continue;
            }
            if (!nv50->state.uniform_buffer_bound[s]) {
               nv50->state.uniform_buffer_bound[s] = TRUE;
               BEGIN_NV04(push, NV50_3D(SET_PROGRAM_CB), 1);
               PUSH_DATA (push, (b << 12) | (i << 8) | p | 1);
            }
            while (words) {
               unsigned nr;

               if (!PUSH_SPACE(push, 16))
                  break;
               nr = PUSH_AVAIL(push);
               assert(nr >= 16);
               nr = MIN2(MIN2(nr - 3, words), NV04_PFIFO_MAX_PACKET_LEN);

               BEGIN_NV04(push, NV50_3D(CB_ADDR), 1);
               PUSH_DATA (push, (start << 8) | b);
               BEGIN_NI04(push, NV50_3D(CB_DATA(0)), nr);
               PUSH_DATAp(push, &nv50->constbuf[s][0].u.data[start * 4], nr);

               start += nr;
               words -= nr;
            }
         } else {
            struct nv04_resource *res =
               nv04_resource(nv50->constbuf[s][i].u.buf);
            if (res) {
               /* TODO: allocate persistent bindings */
               const unsigned b = s * 16 + i;

               assert(nouveau_resource_mapped_by_gpu(&res->base));

               BEGIN_NV04(push, NV50_3D(CB_DEF_ADDRESS_HIGH), 3);
               PUSH_DATAh(push, res->address + nv50->constbuf[s][i].offset);
               PUSH_DATA (push, res->address + nv50->constbuf[s][i].offset);
               PUSH_DATA (push, (b << 16) |
                          (nv50->constbuf[s][i].size & 0xffff));
               BEGIN_NV04(push, NV50_3D(SET_PROGRAM_CB), 1);
               PUSH_DATA (push, (b << 12) | (i << 8) | p | 1);

               BCTX_REFN(nv50->bufctx_3d, CB(s, i), res, RD);
            } else {
               BEGIN_NV04(push, NV50_3D(SET_PROGRAM_CB), 1);
               PUSH_DATA (push, (i << 8) | p | 0);
            }
            if (i == 0)
               nv50->state.uniform_buffer_bound[s] = FALSE;
         }
d59 13
d73 2
d77 2
a78 2
static boolean
nv50_program_validate(struct nv50_context *nv50, struct nv50_program *prog)
d80 20
a99 8
   if (!prog->translated) {
      prog->translated = nv50_program_translate(
         prog, nv50->screen->base.device->chipset);
      if (!prog->translated)
         return FALSE;
   } else
   if (prog->mem)
      return TRUE;
d101 35
a135 1
   return nv50_program_upload_code(nv50, prog);
d138 2
a139 3
static INLINE void
nv50_program_update_context_state(struct nv50_context *nv50,
                                  struct nv50_program *prog, int stage)
d141 17
a157 1
   const unsigned flags = NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR;
d159 45
a203 11
   if (prog && prog->tls_space) {
      if (nv50->state.new_tls_space)
         nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_TLS);
      if (!nv50->state.tls_required || nv50->state.new_tls_space)
         BCTX_REFN_bo(nv50->bufctx_3d, TLS, flags, nv50->screen->tls_bo);
      nv50->state.new_tls_space = FALSE;
      nv50->state.tls_required |= 1 << stage;
   } else {
      if (nv50->state.tls_required == (1 << stage))
         nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_TLS);
      nv50->state.tls_required &= ~(1 << stage);
d205 3
d210 2
a211 2
void
nv50_vertprog_validate(struct nv50_context *nv50)
d213 19
a231 2
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nv50_program *vp = nv50->vertprog;
d233 2
a234 13
   if (!nv50_program_validate(nv50, vp))
         return;
   nv50_program_update_context_state(nv50, vp, 0);

   BEGIN_NV04(push, NV50_3D(VP_ATTR_EN(0)), 2);
   PUSH_DATA (push, vp->vp.attrs[0]);
   PUSH_DATA (push, vp->vp.attrs[1]);
   BEGIN_NV04(push, NV50_3D(VP_REG_ALLOC_RESULT), 1);
   PUSH_DATA (push, vp->max_out);
   BEGIN_NV04(push, NV50_3D(VP_REG_ALLOC_TEMP), 1);
   PUSH_DATA (push, vp->max_gpr);
   BEGIN_NV04(push, NV50_3D(VP_START_ID), 1);
   PUSH_DATA (push, vp->code_base);
d237 2
a238 2
void
nv50_fragprog_validate(struct nv50_context *nv50)
d240 2
a241 2
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nv50_program *fp = nv50->fragprog;
d243 1
a243 33
   if (!nv50_program_validate(nv50, fp))
         return;
   nv50_program_update_context_state(nv50, fp, 1);

   BEGIN_NV04(push, NV50_3D(FP_REG_ALLOC_TEMP), 1);
   PUSH_DATA (push, fp->max_gpr);
   BEGIN_NV04(push, NV50_3D(FP_RESULT_COUNT), 1);
   PUSH_DATA (push, fp->max_out);
   BEGIN_NV04(push, NV50_3D(FP_CONTROL), 1);
   PUSH_DATA (push, fp->fp.flags[0]);
   BEGIN_NV04(push, NV50_3D(FP_CTRL_UNK196C), 1);
   PUSH_DATA (push, fp->fp.flags[1]);
   BEGIN_NV04(push, NV50_3D(FP_START_ID), 1);
   PUSH_DATA (push, fp->code_base);
}

void
nv50_gmtyprog_validate(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nv50_program *gp = nv50->gmtyprog;

   if (gp) {
      BEGIN_NV04(push, NV50_3D(GP_REG_ALLOC_TEMP), 1);
      PUSH_DATA (push, gp->max_gpr);
      BEGIN_NV04(push, NV50_3D(GP_REG_ALLOC_RESULT), 1);
      PUSH_DATA (push, gp->max_out);
      BEGIN_NV04(push, NV50_3D(GP_OUTPUT_PRIMITIVE_TYPE), 1);
      PUSH_DATA (push, gp->gp.prim_type);
      BEGIN_NV04(push, NV50_3D(GP_VERTEX_OUTPUT_COUNT), 1);
      PUSH_DATA (push, gp->gp.vert_count);
      BEGIN_NV04(push, NV50_3D(GP_START_ID), 1);
      PUSH_DATA (push, gp->code_base);
d245 15
a259 3
      nv50->state.prim_size = gp->gp.prim_type; /* enum matches vertex count */
   }
   nv50_program_update_context_state(nv50, gp, 2);
d261 2
a262 1
   /* GP_ENABLE is updated in linkage validation */
d266 37
a302 1
nv50_sprite_coords_validate(struct nv50_context *nv50)
d304 7
a310 5
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   uint32_t pntc[8], mode;
   struct nv50_program *fp = nv50->fragprog;
   unsigned i, c;
   unsigned m = (nv50->state.interpolant_ctrl >> 8) & 0xff;
d312 5
a316 5
   if (!nv50->rast->pipe.point_quad_rasterization) {
      if (nv50->state.point_sprite) {
         BEGIN_NV04(push, NV50_3D(POINT_COORD_REPLACE_MAP(0)), 8);
         for (i = 0; i < 8; ++i)
            PUSH_DATA(push, 0);
d318 5
a322 5
         nv50->state.point_sprite = FALSE;
      }
      return;
   } else {
      nv50->state.point_sprite = TRUE;
d325 5
a329 1
   memset(pntc, 0, sizeof(pntc));
d331 5
a335 2
   for (i = 0; i < fp->in_nr; i++) {
      unsigned n = util_bitcount(fp->in[i].mask);
d337 5
a341 8
      if (fp->in[i].sn != TGSI_SEMANTIC_GENERIC) {
         m += n;
         continue;
      }
      if (!(nv50->rast->pipe.sprite_coord_enable & (1 << fp->in[i].si))) {
         m += n;
         continue;
      }
d343 5
a347 6
      for (c = 0; c < 4; ++c) {
         if (fp->in[i].mask & (1 << c)) {
            pntc[m / 8] |= (c + 1) << ((m % 8) * 4);
            ++m;
         }
      }
d350 5
a354 4
   if (nv50->rast->pipe.sprite_coord_mode == PIPE_SPRITE_COORD_LOWER_LEFT)
      mode = 0x00;
   else
      mode = 0x10;
d356 1
a356 2
   BEGIN_NV04(push, NV50_3D(POINT_SPRITE_CTRL), 1);
   PUSH_DATA (push, mode);
d358 2
a359 2
   BEGIN_NV04(push, NV50_3D(POINT_COORD_REPLACE_MAP(0)), 8);
   PUSH_DATAp(push, pntc, 8);
d362 2
a363 3
/* Validate state derived from shaders and the rasterizer cso. */
void
nv50_validate_derived_rs(struct nv50_context *nv50)
d365 2
a366 2
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   uint32_t color, psize;
d368 3
a370 1
   nv50_sprite_coords_validate(nv50);
d372 5
a376 4
   if (nv50->state.rasterizer_discard != nv50->rast->pipe.rasterizer_discard) {
      nv50->state.rasterizer_discard = nv50->rast->pipe.rasterizer_discard;
      BEGIN_NV04(push, NV50_3D(RASTERIZE_ENABLE), 1);
      PUSH_DATA (push, !nv50->rast->pipe.rasterizer_discard);
d379 34
a412 4
   if (nv50->dirty & NV50_NEW_FRAGPROG)
      return;
   psize = nv50->state.semantic_psize & ~NV50_3D_SEMANTIC_PTSZ_PTSZ_EN__MASK;
   color = nv50->state.semantic_color & ~NV50_3D_SEMANTIC_COLOR_CLMP_EN;
d414 3
a416 2
   if (nv50->rast->pipe.clamp_vertex_color)
      color |= NV50_3D_SEMANTIC_COLOR_CLMP_EN;
d418 2
a419 5
   if (color != nv50->state.semantic_color) {
      nv50->state.semantic_color = color;
      BEGIN_NV04(push, NV50_3D(SEMANTIC_COLOR), 1);
      PUSH_DATA (push, color);
   }
d421 5
a425 2
   if (nv50->rast->pipe.point_size_per_vertex)
      psize |= NV50_3D_SEMANTIC_PTSZ_PTSZ_EN__MASK;
d427 7
a433 4
   if (psize != nv50->state.semantic_psize) {
      nv50->state.semantic_psize = psize;
      BEGIN_NV04(push, NV50_3D(SEMANTIC_PTSZ), 1);
      PUSH_DATA (push, psize);
d435 3
d441 1
a441 1
nv50_vec4_map(uint8_t *map, int mid, uint32_t lin[4],
d446 1
d468 1
a468 1
void
d471 2
a472 2
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nv50_program *vp = nv50->gmtyprog ? nv50->gmtyprog : nv50->vertprog;
d474 1
d477 3
a479 2
   uint32_t primid = 0;
   uint32_t psiz = 0x000;
d482 11
a492 13
   uint32_t lin[4];
   uint8_t map[64];
   uint8_t so_map[64];

   if (!(nv50->dirty & (NV50_NEW_VERTPROG |
                        NV50_NEW_FRAGPROG |
                        NV50_NEW_GMTYPROG))) {
      uint8_t bfc, ffc;
      ffc = (nv50->state.semantic_color & NV50_3D_SEMANTIC_COLOR_FFC0_ID__MASK);
      bfc = (nv50->state.semantic_color & NV50_3D_SEMANTIC_COLOR_BFC0_ID__MASK)
         >> 8;
      if (nv50->rast->pipe.light_twoside == ((ffc == bfc) ? 0 : 1))
         return;
d494 1
d496 1
a496 7
   memset(lin, 0x00, sizeof(lin));

   /* XXX: in buggy-endian mode, is the first element of map (u32)0x000000xx
    *  or is it the first byte ?
    */
   memset(map, nv50->gmtyprog ? 0x80 : 0x40, sizeof(map));

a497 1
   dummy.linear = 0;
d500 7
a506 2
   for (c = 0; c < vp->vp.clpd_nr; ++c)
      map[m++] = vp->vp.clpd[c / 4] + (c % 4);
d510 7
a516 1
   dummy.mask = 0x0;
a517 10
   /* if light_twoside is active, FFC0_ID == BFC0_ID is invalid */
   if (nv50->rast->pipe.light_twoside) {
      for (i = 0; i < 2; ++i) {
         n = vp->vp.bfc[i];
         if (fp->vp.bfc[i] >= fp->in_nr)
            continue;
         m = nv50_vec4_map(map, m, lin, &fp->in[fp->vp.bfc[i]],
                           (n < vp->out_nr) ? &vp->out[n] : &dummy);
      }
   }
d519 1
a519 1
   interp |= m << 8; /* set map id where 'normal' FP inputs start */
d521 2
a522 1
   for (i = 0; i < fp->in_nr; ++i) {
d527 1
d530 1
a530 1
   }
d535 10
a544 35
   if (fp->gp.primid < 0x80) {
      primid = m;
      map[m++] = vp->gp.primid;
   }

   if (nv50->rast->pipe.point_size_per_vertex) {
      psiz = (m << 4) | 1;
      map[m++] = vp->vp.psiz;
   }

   if (nv50->rast->pipe.clamp_vertex_color)
      colors |= NV50_3D_SEMANTIC_COLOR_CLMP_EN;

   if (unlikely(vp->so)) {
      /* Slot i in STRMOUT_MAP specifies the offset where slot i in RESULT_MAP
       * gets written.
       *
       * TODO:
       * Inverting vp->so->map (output -> offset) would probably speed this up.
       */
      memset(so_map, 0, sizeof(so_map));
      for (i = 0; i < vp->so->map_size; ++i) {
         if (vp->so->map[i] == 0xff)
            continue;
         for (c = 0; c < m; ++c)
            if (map[c] == vp->so->map[i] && !so_map[c])
               break;
         if (c == m) {
            c = m;
            map[m++] = vp->so->map[i];
         }
         so_map[c] = 0x80 | i;
      }
      for (c = m; c & 3; ++c)
         so_map[c] = 0;
d547 3
d552 5
a556 6

   if (unlikely(nv50->gmtyprog)) {
      BEGIN_NV04(push, NV50_3D(GP_RESULT_MAP_SIZE), 1);
      PUSH_DATA (push, m);
      BEGIN_NV04(push, NV50_3D(GP_RESULT_MAP(0)), n);
      PUSH_DATAp(push, map, n);
d558 2
a559 2
      BEGIN_NV04(push, NV50_3D(VP_GP_BUILTIN_ATTR_EN), 1);
      PUSH_DATA (push, vp->vp.attrs[2]);
d561 2
a562 2
      BEGIN_NV04(push, NV50_3D(SEMANTIC_PRIM_ID), 1);
      PUSH_DATA (push, primid);
d564 4
a567 4
      BEGIN_NV04(push, NV50_3D(VP_RESULT_MAP_SIZE), 1);
      PUSH_DATA (push, m);
      BEGIN_NV04(push, NV50_3D(VP_RESULT_MAP(0)), n);
      PUSH_DATAp(push, map, n);
d570 5
a574 5
   BEGIN_NV04(push, NV50_3D(SEMANTIC_COLOR), 4);
   PUSH_DATA (push, colors);
   PUSH_DATA (push, (vp->vp.clpd_nr << 8) | 4);
   PUSH_DATA (push, 0);
   PUSH_DATA (push, psiz);
d576 2
a577 2
   BEGIN_NV04(push, NV50_3D(FP_INTERPOLANT_CTRL), 1);
   PUSH_DATA (push, interp);
d579 2
a580 1
   nv50->state.interpolant_ctrl = interp;
d582 4
a585 2
   nv50->state.semantic_color = colors;
   nv50->state.semantic_psize = psiz;
d587 3
a589 2
   BEGIN_NV04(push, NV50_3D(NOPERSPECTIVE_BITMAP(0)), 4);
   PUSH_DATAp(push, lin, 4);
d591 2
a592 2
   BEGIN_NV04(push, NV50_3D(GP_ENABLE), 1);
   PUSH_DATA (push, nv50->gmtyprog ? 1 : 0);
d594 1
a594 4
   if (vp->so) {
      BEGIN_NV04(push, NV50_3D(STRMOUT_MAP(0)), n);
      PUSH_DATAp(push, so_map, n);
   }
d598 1
a598 1
nv50_vp_gp_mapping(uint8_t *map, int m,
d601 1
d628 1
a628 1
void
d631 2
a632 1
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
d634 2
a635 1
   struct nv50_program *gp = nv50->gmtyprog;
a636 2
   int n;
   uint8_t map[64];
d639 1
a639 1
      return;
d644 4
a647 1
   n = (m + 3) / 4;
d649 3
a651 2
   BEGIN_NV04(push, NV50_3D(VP_GP_BUILTIN_ATTR_EN), 1);
   PUSH_DATA (push, vp->vp.attrs[2] | gp->vp.attrs[2]);
d653 3
a655 28
   BEGIN_NV04(push, NV50_3D(VP_RESULT_MAP_SIZE), 1);
   PUSH_DATA (push, m);
   BEGIN_NV04(push, NV50_3D(VP_RESULT_MAP(0)), n);
   PUSH_DATAp(push, map, n);
}

void
nv50_stream_output_validate(struct nv50_context *nv50)
{
   struct nouveau_pushbuf *push = nv50->base.pushbuf;
   struct nv50_stream_output_state *so;
   uint32_t ctrl;
   unsigned i;
   unsigned prims = ~0;

   so = nv50->gmtyprog ? nv50->gmtyprog->so : nv50->vertprog->so;

   BEGIN_NV04(push, NV50_3D(STRMOUT_ENABLE), 1);
   PUSH_DATA (push, 0);
   if (!so || !nv50->num_so_targets) {
      if (nv50->screen->base.class_3d < NVA0_3D_CLASS) {
         BEGIN_NV04(push, NV50_3D(STRMOUT_PRIMITIVE_LIMIT), 1);
         PUSH_DATA (push, 0);
      }
      BEGIN_NV04(push, NV50_3D(STRMOUT_PARAMS_LATCH), 1);
      PUSH_DATA (push, 1);
      return;
   }
d657 1
a657 53
   /* previous TFB needs to complete */
   if (nv50->screen->base.class_3d < NVA0_3D_CLASS) {
      BEGIN_NV04(push, SUBC_3D(NV50_GRAPH_SERIALIZE), 1);
      PUSH_DATA (push, 0);
   }

   ctrl = so->ctrl;
   if (nv50->screen->base.class_3d >= NVA0_3D_CLASS)
      ctrl |= NVA0_3D_STRMOUT_BUFFERS_CTRL_LIMIT_MODE_OFFSET;

   BEGIN_NV04(push, NV50_3D(STRMOUT_BUFFERS_CTRL), 1);
   PUSH_DATA (push, ctrl);

   nouveau_bufctx_reset(nv50->bufctx_3d, NV50_BIND_SO);

   for (i = 0; i < nv50->num_so_targets; ++i) {
      struct nv50_so_target *targ = nv50_so_target(nv50->so_target[i]);
      struct nv04_resource *buf = nv04_resource(targ->pipe.buffer);

      const unsigned n = nv50->screen->base.class_3d >= NVA0_3D_CLASS ? 4 : 3;

      if (n == 4 && !targ->clean)
         nv84_query_fifo_wait(push, targ->pq);
      BEGIN_NV04(push, NV50_3D(STRMOUT_ADDRESS_HIGH(i)), n);
      PUSH_DATAh(push, buf->address + targ->pipe.buffer_offset);
      PUSH_DATA (push, buf->address + targ->pipe.buffer_offset);
      PUSH_DATA (push, so->num_attribs[i]);
      if (n == 4) {
         PUSH_DATA(push, targ->pipe.buffer_size);

         BEGIN_NV04(push, NVA0_3D(STRMOUT_OFFSET(i)), 1);
         if (!targ->clean) {
            assert(targ->pq);
            nv50_query_pushbuf_submit(push, targ->pq, 0x4);
         } else {
            PUSH_DATA(push, 0);
            targ->clean = FALSE;
         }
      } else {
         const unsigned limit = targ->pipe.buffer_size /
            (so->stride[i] * nv50->state.prim_size);
         prims = MIN2(prims, limit);
      }
      BCTX_REFN(nv50->bufctx_3d, SO, buf, WR);
   }
   if (prims != ~0) {
      BEGIN_NV04(push, NV50_3D(STRMOUT_PRIMITIVE_LIMIT), 1);
      PUSH_DATA (push, prims);
   }
   BEGIN_NV04(push, NV50_3D(STRMOUT_PARAMS_LATCH), 1);
   PUSH_DATA (push, 1);
   BEGIN_NV04(push, NV50_3D(STRMOUT_ENABLE), 1);
   PUSH_DATA (push, 1);
@

