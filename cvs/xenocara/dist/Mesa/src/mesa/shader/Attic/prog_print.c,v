head	1.5;
access;
symbols
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v7_0_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2011.10.23.13.37.44;	author matthieu;	state dead;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.32;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.17.31.41;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.17.31.41;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge Mesa 7.10.3
@
text
@/*
 * Mesa 3-D graphics library
 * Version:  7.3
 *
 * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file prog_print.c
 * Print vertex/fragment programs - for debugging.
 * \author Brian Paul
 */

#include "main/glheader.h"
#include "main/context.h"
#include "main/imports.h"
#include "prog_instruction.h"
#include "prog_parameter.h"
#include "prog_print.h"
#include "prog_statevars.h"



/**
 * Return string name for given program/register file.
 */
static const char *
file_string(gl_register_file f, gl_prog_print_mode mode)
{
   switch (f) {
   case PROGRAM_TEMPORARY:
      return "TEMP";
   case PROGRAM_LOCAL_PARAM:
      return "LOCAL";
   case PROGRAM_ENV_PARAM:
      return "ENV";
   case PROGRAM_STATE_VAR:
      return "STATE";
   case PROGRAM_INPUT:
      return "INPUT";
   case PROGRAM_OUTPUT:
      return "OUTPUT";
   case PROGRAM_NAMED_PARAM:
      return "NAMED";
   case PROGRAM_CONSTANT:
      return "CONST";
   case PROGRAM_UNIFORM:
      return "UNIFORM";
   case PROGRAM_VARYING:
      return "VARYING";
   case PROGRAM_WRITE_ONLY:
      return "WRITE_ONLY";
   case PROGRAM_ADDRESS:
      return "ADDR";
   case PROGRAM_SAMPLER:
      return "SAMPLER";
   case PROGRAM_UNDEFINED:
      return "UNDEFINED";
   default:
      {
         static char s[20];
         _mesa_snprintf(s, sizeof(s), "FILE%u", f);
         return s;
      }
   }
}


/**
 * Return ARB_v/f_prog-style input attrib string.
 */
static const char *
arb_input_attrib_string(GLint index, GLenum progType)
{
   /*
    * These strings should match the VERT_ATTRIB_x and FRAG_ATTRIB_x tokens.
    */
   const char *vertAttribs[] = {
      "vertex.position",
      "vertex.weight",
      "vertex.normal",
      "vertex.color.primary",
      "vertex.color.secondary",
      "vertex.fogcoord",
      "vertex.(six)",
      "vertex.(seven)",
      "vertex.texcoord[0]",
      "vertex.texcoord[1]",
      "vertex.texcoord[2]",
      "vertex.texcoord[3]",
      "vertex.texcoord[4]",
      "vertex.texcoord[5]",
      "vertex.texcoord[6]",
      "vertex.texcoord[7]",
      "vertex.attrib[0]",
      "vertex.attrib[1]",
      "vertex.attrib[2]",
      "vertex.attrib[3]",
      "vertex.attrib[4]",
      "vertex.attrib[5]",
      "vertex.attrib[6]",
      "vertex.attrib[7]",
      "vertex.attrib[8]",
      "vertex.attrib[9]",
      "vertex.attrib[10]",
      "vertex.attrib[11]",
      "vertex.attrib[12]",
      "vertex.attrib[13]",
      "vertex.attrib[14]",
      "vertex.attrib[15]"
   };
   const char *fragAttribs[] = {
      "fragment.position",
      "fragment.color.primary",
      "fragment.color.secondary",
      "fragment.fogcoord",
      "fragment.texcoord[0]",
      "fragment.texcoord[1]",
      "fragment.texcoord[2]",
      "fragment.texcoord[3]",
      "fragment.texcoord[4]",
      "fragment.texcoord[5]",
      "fragment.texcoord[6]",
      "fragment.texcoord[7]",
      "fragment.varying[0]",
      "fragment.varying[1]",
      "fragment.varying[2]",
      "fragment.varying[3]",
      "fragment.varying[4]",
      "fragment.varying[5]",
      "fragment.varying[6]",
      "fragment.varying[7]"
   };

   /* sanity checks */
   assert(strcmp(vertAttribs[VERT_ATTRIB_TEX0], "vertex.texcoord[0]") == 0);
   assert(strcmp(vertAttribs[VERT_ATTRIB_GENERIC15], "vertex.attrib[15]") == 0);

   if (progType == GL_VERTEX_PROGRAM_ARB) {
      assert(index < sizeof(vertAttribs) / sizeof(vertAttribs[0]));
      return vertAttribs[index];
   }
   else {
      assert(index < sizeof(fragAttribs) / sizeof(fragAttribs[0]));
      return fragAttribs[index];
   }
}


/**
 * Print a vertex program's InputsRead field in human-readable format.
 * For debugging.
 */
void
_mesa_print_vp_inputs(GLbitfield inputs)
{
   printf("VP Inputs 0x%x: \n", inputs);
   while (inputs) {
      GLint attr = _mesa_ffs(inputs) - 1;
      const char *name = arb_input_attrib_string(attr,
                                                 GL_VERTEX_PROGRAM_ARB);
      printf("  %d: %s\n", attr, name);
      inputs &= ~(1 << attr);
   }
}


/**
 * Print a fragment program's InputsRead field in human-readable format.
 * For debugging.
 */
void
_mesa_print_fp_inputs(GLbitfield inputs)
{
   printf("FP Inputs 0x%x: \n", inputs);
   while (inputs) {
      GLint attr = _mesa_ffs(inputs) - 1;
      const char *name = arb_input_attrib_string(attr,
                                                 GL_FRAGMENT_PROGRAM_ARB);
      printf("  %d: %s\n", attr, name);
      inputs &= ~(1 << attr);
   }
}



/**
 * Return ARB_v/f_prog-style output attrib string.
 */
static const char *
arb_output_attrib_string(GLint index, GLenum progType)
{
   /*
    * These strings should match the VERT_RESULT_x and FRAG_RESULT_x tokens.
    */
   const char *vertResults[] = {
      "result.position",
      "result.color.primary",
      "result.color.secondary",
      "result.fogcoord",
      "result.texcoord[0]",
      "result.texcoord[1]",
      "result.texcoord[2]",
      "result.texcoord[3]",
      "result.texcoord[4]",
      "result.texcoord[5]",
      "result.texcoord[6]",
      "result.texcoord[7]",
      "result.varying[0]",
      "result.varying[1]",
      "result.varying[2]",
      "result.varying[3]",
      "result.varying[4]",
      "result.varying[5]",
      "result.varying[6]",
      "result.varying[7]"
   };
   const char *fragResults[] = {
      "result.color",
      "result.color(half)",
      "result.depth",
      "result.color[0]",
      "result.color[1]",
      "result.color[2]",
      "result.color[3]"
   };

   if (progType == GL_VERTEX_PROGRAM_ARB) {
      assert(index < sizeof(vertResults) / sizeof(vertResults[0]));
      return vertResults[index];
   }
   else {
      assert(index < sizeof(fragResults) / sizeof(fragResults[0]));
      return fragResults[index];
   }
}


/**
 * Return string representation of the given register.
 * Note that some types of registers (like PROGRAM_UNIFORM) aren't defined
 * by the ARB/NV program languages so we've taken some liberties here.
 * \param f  the register file (PROGRAM_INPUT, PROGRAM_TEMPORARY, etc)
 * \param index  number of the register in the register file
 * \param mode  the output format/mode/style
 * \param prog  pointer to containing program
 */
static const char *
reg_string(gl_register_file f, GLint index, gl_prog_print_mode mode,
           GLboolean relAddr, const struct gl_program *prog)
{
   static char str[100];
   const char *addr = relAddr ? "ADDR+" : "";

   str[0] = 0;

   switch (mode) {
   case PROG_PRINT_DEBUG:
      sprintf(str, "%s[%s%d]", file_string(f, mode), addr, index);
      break;

   case PROG_PRINT_ARB:
      switch (f) {
      case PROGRAM_INPUT:
         sprintf(str, "%s", arb_input_attrib_string(index, prog->Target));
         break;
      case PROGRAM_OUTPUT:
         sprintf(str, "%s", arb_output_attrib_string(index, prog->Target));
         break;
      case PROGRAM_TEMPORARY:
         sprintf(str, "temp%d", index);
         break;
      case PROGRAM_ENV_PARAM:
         sprintf(str, "program.env[%s%d]", addr, index);
         break;
      case PROGRAM_LOCAL_PARAM:
         sprintf(str, "program.local[%s%d]", addr, index);
         break;
      case PROGRAM_VARYING: /* extension */
         sprintf(str, "varying[%s%d]", addr, index);
         break;
      case PROGRAM_CONSTANT: /* extension */
         sprintf(str, "constant[%s%d]", addr, index);
         break;
      case PROGRAM_UNIFORM: /* extension */
         sprintf(str, "uniform[%s%d]", addr, index);
         break;
      case PROGRAM_STATE_VAR:
         {
            struct gl_program_parameter *param
               = prog->Parameters->Parameters + index;
            char *state = _mesa_program_state_string(param->StateIndexes);
            sprintf(str, "%s", state);
            free(state);
         }
         break;
      case PROGRAM_ADDRESS:
         sprintf(str, "A%d", index);
         break;
      default:
         _mesa_problem(NULL, "bad file in reg_string()");
      }
      break;

   case PROG_PRINT_NV:
      switch (f) {
      case PROGRAM_INPUT:
         if (prog->Target == GL_VERTEX_PROGRAM_ARB)
            sprintf(str, "v[%d]", index);
         else
            sprintf(str, "f[%d]", index);
         break;
      case PROGRAM_OUTPUT:
         sprintf(str, "o[%d]", index);
         break;
      case PROGRAM_TEMPORARY:
         sprintf(str, "R%d", index);
         break;
      case PROGRAM_ENV_PARAM:
         sprintf(str, "c[%d]", index);
         break;
      case PROGRAM_VARYING: /* extension */
         sprintf(str, "varying[%s%d]", addr, index);
         break;
      case PROGRAM_UNIFORM: /* extension */
         sprintf(str, "uniform[%s%d]", addr, index);
         break;
      case PROGRAM_CONSTANT: /* extension */
         sprintf(str, "constant[%s%d]", addr, index);
         break;
      case PROGRAM_STATE_VAR: /* extension */
         sprintf(str, "state[%s%d]", addr, index);
         break;
      default:
         _mesa_problem(NULL, "bad file in reg_string()");
      }
      break;

   default:
      _mesa_problem(NULL, "bad mode in reg_string()");
   }

   return str;
}


/**
 * Return a string representation of the given swizzle word.
 * If extended is true, use extended (comma-separated) format.
 * \param swizzle  the swizzle field
 * \param negateBase  4-bit negation vector
 * \param extended  if true, also allow 0, 1 values
 */
const char *
_mesa_swizzle_string(GLuint swizzle, GLuint negateMask, GLboolean extended)
{
   static const char swz[] = "xyzw01!?";  /* See SWIZZLE_x definitions */
   static char s[20];
   GLuint i = 0;

   if (!extended && swizzle == SWIZZLE_NOOP && negateMask == 0)
      return ""; /* no swizzle/negation */

   if (!extended)
      s[i++] = '.';

   if (negateMask & NEGATE_X)
      s[i++] = '-';
   s[i++] = swz[GET_SWZ(swizzle, 0)];

   if (extended) {
      s[i++] = ',';
   }

   if (negateMask & NEGATE_Y)
      s[i++] = '-';
   s[i++] = swz[GET_SWZ(swizzle, 1)];

   if (extended) {
      s[i++] = ',';
   }

   if (negateMask & NEGATE_Z)
      s[i++] = '-';
   s[i++] = swz[GET_SWZ(swizzle, 2)];

   if (extended) {
      s[i++] = ',';
   }

   if (negateMask & NEGATE_W)
      s[i++] = '-';
   s[i++] = swz[GET_SWZ(swizzle, 3)];

   s[i] = 0;
   return s;
}


void
_mesa_print_swizzle(GLuint swizzle)
{
   if (swizzle == SWIZZLE_XYZW) {
      printf(".xyzw\n");
   }
   else {
      const char *s = _mesa_swizzle_string(swizzle, 0, 0);
      printf("%s\n", s);
   }
}


const char *
_mesa_writemask_string(GLuint writeMask)
{
   static char s[10];
   GLuint i = 0;

   if (writeMask == WRITEMASK_XYZW)
      return "";

   s[i++] = '.';
   if (writeMask & WRITEMASK_X)
      s[i++] = 'x';
   if (writeMask & WRITEMASK_Y)
      s[i++] = 'y';
   if (writeMask & WRITEMASK_Z)
      s[i++] = 'z';
   if (writeMask & WRITEMASK_W)
      s[i++] = 'w';

   s[i] = 0;
   return s;
}


const char *
_mesa_condcode_string(GLuint condcode)
{
   switch (condcode) {
   case COND_GT:  return "GT";
   case COND_EQ:  return "EQ";
   case COND_LT:  return "LT";
   case COND_UN:  return "UN";
   case COND_GE:  return "GE";
   case COND_LE:  return "LE";
   case COND_NE:  return "NE";
   case COND_TR:  return "TR";
   case COND_FL:  return "FL";
   default: return "cond???";
   }
}


static void
fprint_dst_reg(FILE * f,
               const struct prog_dst_register *dstReg,
               gl_prog_print_mode mode,
               const struct gl_program *prog)
{
   fprintf(f, "%s%s",
	   reg_string((gl_register_file) dstReg->File,
		      dstReg->Index, mode, dstReg->RelAddr, prog),
	   _mesa_writemask_string(dstReg->WriteMask));
   
   if (dstReg->CondMask != COND_TR) {
      fprintf(f, " (%s.%s)",
	      _mesa_condcode_string(dstReg->CondMask),
	      _mesa_swizzle_string(dstReg->CondSwizzle,
				   GL_FALSE, GL_FALSE));
   }

#if 0
   fprintf(f, "%s[%d]%s",
	   file_string((gl_register_file) dstReg->File, mode),
	   dstReg->Index,
	   _mesa_writemask_string(dstReg->WriteMask));
#endif
}


static void
fprint_src_reg(FILE *f,
               const struct prog_src_register *srcReg, 
               gl_prog_print_mode mode,
               const struct gl_program *prog)
{
   const char *abs = srcReg->Abs ? "|" : "";

   fprintf(f, "%s%s%s%s",
	   abs,
	   reg_string((gl_register_file) srcReg->File,
		      srcReg->Index, mode, srcReg->RelAddr, prog),
	   _mesa_swizzle_string(srcReg->Swizzle,
				srcReg->Negate, GL_FALSE),
	   abs);
#if 0
   fprintf(f, "%s[%d]%s",
	   file_string((gl_register_file) srcReg->File, mode),
	   srcReg->Index,
	   _mesa_swizzle_string(srcReg->Swizzle,
				srcReg->Negate, GL_FALSE));
#endif
}


static void
fprint_comment(FILE *f, const struct prog_instruction *inst)
{
   if (inst->Comment)
      fprintf(f, ";  # %s\n", inst->Comment);
   else
      fprintf(f, ";\n");
}


static void
fprint_alu_instruction(FILE *f,
                       const struct prog_instruction *inst,
                       const char *opcode_string, GLuint numRegs,
                       gl_prog_print_mode mode,
                       const struct gl_program *prog)
{
   GLuint j;

   fprintf(f, "%s", opcode_string);
   if (inst->CondUpdate)
      fprintf(f, ".C");

   /* frag prog only */
   if (inst->SaturateMode == SATURATE_ZERO_ONE)
      fprintf(f, "_SAT");

   fprintf(f, " ");
   if (inst->DstReg.File != PROGRAM_UNDEFINED) {
      fprint_dst_reg(f, &inst->DstReg, mode, prog);
   }
   else {
      fprintf(f, " ???");
   }

   if (numRegs > 0)
      fprintf(f, ", ");

   for (j = 0; j < numRegs; j++) {
      fprint_src_reg(f, inst->SrcReg + j, mode, prog);
      if (j + 1 < numRegs)
	 fprintf(f, ", ");
   }

   fprint_comment(f, inst);
}


void
_mesa_print_alu_instruction(const struct prog_instruction *inst,
                            const char *opcode_string, GLuint numRegs)
{
   fprint_alu_instruction(stderr, inst, opcode_string,
                          numRegs, PROG_PRINT_DEBUG, NULL);
}


/**
 * Print a single vertex/fragment program instruction.
 */
GLint
_mesa_fprint_instruction_opt(FILE *f,
                            const struct prog_instruction *inst,
                            GLint indent,
                            gl_prog_print_mode mode,
                            const struct gl_program *prog)
{
   GLint i;

   if (inst->Opcode == OPCODE_ELSE ||
       inst->Opcode == OPCODE_ENDIF ||
       inst->Opcode == OPCODE_ENDLOOP ||
       inst->Opcode == OPCODE_ENDSUB) {
      indent -= 3;
   }
   for (i = 0; i < indent; i++) {
      fprintf(f, " ");
   }

   switch (inst->Opcode) {
   case OPCODE_PRINT:
      fprintf(f, "PRINT '%s'", (char *) inst->Data);
      if (inst->SrcReg[0].File != PROGRAM_UNDEFINED) {
         fprintf(f, ", ");
         fprintf(f, "%s[%d]%s",
		 file_string((gl_register_file) inst->SrcReg[0].File,
			     mode),
		 inst->SrcReg[0].Index,
		 _mesa_swizzle_string(inst->SrcReg[0].Swizzle,
				      inst->SrcReg[0].Negate, GL_FALSE));
      }
      if (inst->Comment)
         fprintf(f, "  # %s", inst->Comment);
      fprint_comment(f, inst);
      break;
   case OPCODE_SWZ:
      fprintf(f, "SWZ");
      if (inst->SaturateMode == SATURATE_ZERO_ONE)
         fprintf(f, "_SAT");
      fprintf(f, " ");
      fprint_dst_reg(f, &inst->DstReg, mode, prog);
      fprintf(f, ", %s[%d], %s",
	      file_string((gl_register_file) inst->SrcReg[0].File,
			  mode),
	      inst->SrcReg[0].Index,
	      _mesa_swizzle_string(inst->SrcReg[0].Swizzle,
				   inst->SrcReg[0].Negate, GL_TRUE));
      fprint_comment(f, inst);
      break;
   case OPCODE_TEX:
   case OPCODE_TXP:
   case OPCODE_TXL:
   case OPCODE_TXB:
      fprintf(f, "%s", _mesa_opcode_string(inst->Opcode));
      if (inst->SaturateMode == SATURATE_ZERO_ONE)
         fprintf(f, "_SAT");
      fprintf(f, " ");
      fprint_dst_reg(f, &inst->DstReg, mode, prog);
      fprintf(f, ", ");
      fprint_src_reg(f, &inst->SrcReg[0], mode, prog);
      fprintf(f, ", texture[%d], ", inst->TexSrcUnit);
      switch (inst->TexSrcTarget) {
      case TEXTURE_1D_INDEX:   fprintf(f, "1D");    break;
      case TEXTURE_2D_INDEX:   fprintf(f, "2D");    break;
      case TEXTURE_3D_INDEX:   fprintf(f, "3D");    break;
      case TEXTURE_CUBE_INDEX: fprintf(f, "CUBE");  break;
      case TEXTURE_RECT_INDEX: fprintf(f, "RECT");  break;
      case TEXTURE_1D_ARRAY_INDEX: fprintf(f, "1D_ARRAY"); break;
      case TEXTURE_2D_ARRAY_INDEX: fprintf(f, "2D_ARRAY"); break;
      default:
         ;
      }
      if (inst->TexShadow)
         fprintf(f, " SHADOW");
      fprint_comment(f, inst);
      break;

   case OPCODE_KIL:
      fprintf(f, "%s", _mesa_opcode_string(inst->Opcode));
      fprintf(f, " ");
      fprint_src_reg(f, &inst->SrcReg[0], mode, prog);
      fprint_comment(f, inst);
      break;
   case OPCODE_KIL_NV:
      fprintf(f, "%s", _mesa_opcode_string(inst->Opcode));
      fprintf(f, " ");
      fprintf(f, "%s.%s",
	      _mesa_condcode_string(inst->DstReg.CondMask),
	      _mesa_swizzle_string(inst->DstReg.CondSwizzle,
				   GL_FALSE, GL_FALSE));
      fprint_comment(f, inst);
      break;

   case OPCODE_ARL:
      fprintf(f, "ARL ");
      fprint_dst_reg(f, &inst->DstReg, mode, prog);
      fprintf(f, ", ");
      fprint_src_reg(f, &inst->SrcReg[0], mode, prog);
      fprint_comment(f, inst);
      break;
   case OPCODE_BRA:
      fprintf(f, "BRA %d (%s%s)",
	      inst->BranchTarget,
	      _mesa_condcode_string(inst->DstReg.CondMask),
	      _mesa_swizzle_string(inst->DstReg.CondSwizzle, 0, GL_FALSE));
      fprint_comment(f, inst);
      break;
   case OPCODE_IF:
      if (inst->SrcReg[0].File != PROGRAM_UNDEFINED) {
         /* Use ordinary register */
         fprintf(f, "IF ");
         fprint_src_reg(f, &inst->SrcReg[0], mode, prog);
         fprintf(f, "; ");
      }
      else {
         /* Use cond codes */
         fprintf(f, "IF (%s%s);",
		 _mesa_condcode_string(inst->DstReg.CondMask),
		 _mesa_swizzle_string(inst->DstReg.CondSwizzle,
				      0, GL_FALSE));
      }
      fprintf(f, " # (if false, goto %d)", inst->BranchTarget);
      fprint_comment(f, inst);
      return indent + 3;
   case OPCODE_ELSE:
      fprintf(f, "ELSE; # (goto %d)\n", inst->BranchTarget);
      return indent + 3;
   case OPCODE_ENDIF:
      fprintf(f, "ENDIF;\n");
      break;
   case OPCODE_BGNLOOP:
      fprintf(f, "BGNLOOP; # (end at %d)\n", inst->BranchTarget);
      return indent + 3;
   case OPCODE_ENDLOOP:
      fprintf(f, "ENDLOOP; # (goto %d)\n", inst->BranchTarget);
      break;
   case OPCODE_BRK:
   case OPCODE_CONT:
      fprintf(f, "%s (%s%s); # (goto %d)",
	      _mesa_opcode_string(inst->Opcode),
	      _mesa_condcode_string(inst->DstReg.CondMask),
	      _mesa_swizzle_string(inst->DstReg.CondSwizzle, 0, GL_FALSE),
	      inst->BranchTarget);
      fprint_comment(f, inst);
      break;

   case OPCODE_BGNSUB:
      if (mode == PROG_PRINT_NV) {
         fprintf(f, "%s:\n", inst->Comment); /* comment is label */
         return indent;
      }
      else {
         fprintf(f, "BGNSUB");
         fprint_comment(f, inst);
         return indent + 3;
      }
   case OPCODE_ENDSUB:
      if (mode == PROG_PRINT_DEBUG) {
         fprintf(f, "ENDSUB");
         fprint_comment(f, inst);
      }
      break;
   case OPCODE_CAL:
      if (mode == PROG_PRINT_NV) {
         fprintf(f, "CAL %s;  # (goto %d)\n", inst->Comment, inst->BranchTarget);
      }
      else {
         fprintf(f, "CAL %u", inst->BranchTarget);
         fprint_comment(f, inst);
      }
      break;
   case OPCODE_RET:
      fprintf(f, "RET (%s%s)",
	      _mesa_condcode_string(inst->DstReg.CondMask),
	      _mesa_swizzle_string(inst->DstReg.CondSwizzle, 0, GL_FALSE));
      fprint_comment(f, inst);
      break;

   case OPCODE_END:
      fprintf(f, "END\n");
      break;
   case OPCODE_NOP:
      if (mode == PROG_PRINT_DEBUG) {
         fprintf(f, "NOP");
         fprint_comment(f, inst);
      }
      else if (inst->Comment) {
         /* ARB/NV extensions don't have NOP instruction */
         fprintf(f, "# %s\n", inst->Comment);
      }
      break;
   /* XXX may need other special-case instructions */
   default:
      if (inst->Opcode < MAX_OPCODE) {
         /* typical alu instruction */
         fprint_alu_instruction(f, inst,
                                _mesa_opcode_string(inst->Opcode),
                                _mesa_num_inst_src_regs(inst->Opcode),
                                mode, prog);
      }
      else {
         fprint_alu_instruction(f, inst,
                                _mesa_opcode_string(inst->Opcode),
                                3/*_mesa_num_inst_src_regs(inst->Opcode)*/,
                                mode, prog);
      }
      break;
   }
   return indent;
}


GLint
_mesa_print_instruction_opt(const struct prog_instruction *inst,
                            GLint indent,
                            gl_prog_print_mode mode,
                            const struct gl_program *prog)
{
   return _mesa_fprint_instruction_opt(stderr, inst, indent, mode, prog);
}


void
_mesa_print_instruction(const struct prog_instruction *inst)
{
   /* note: 4th param should be ignored for PROG_PRINT_DEBUG */
   _mesa_fprint_instruction_opt(stderr, inst, 0, PROG_PRINT_DEBUG, NULL);
}



/**
 * Print program, with options.
 */
void
_mesa_fprint_program_opt(FILE *f,
                         const struct gl_program *prog,
                         gl_prog_print_mode mode,
                         GLboolean lineNumbers)
{
   GLuint i, indent = 0;

   switch (prog->Target) {
   case GL_VERTEX_PROGRAM_ARB:
      if (mode == PROG_PRINT_ARB)
         fprintf(f, "!!ARBvp1.0\n");
      else if (mode == PROG_PRINT_NV)
         fprintf(f, "!!VP1.0\n");
      else
         fprintf(f, "# Vertex Program/Shader %u\n", prog->Id);
      break;
   case GL_FRAGMENT_PROGRAM_ARB:
   case GL_FRAGMENT_PROGRAM_NV:
      if (mode == PROG_PRINT_ARB)
         fprintf(f, "!!ARBfp1.0\n");
      else if (mode == PROG_PRINT_NV)
         fprintf(f, "!!FP1.0\n");
      else
         fprintf(f, "# Fragment Program/Shader %u\n", prog->Id);
      break;
   }

   for (i = 0; i < prog->NumInstructions; i++) {
      if (lineNumbers)
         fprintf(f, "%3d: ", i);
      indent = _mesa_fprint_instruction_opt(f, prog->Instructions + i,
                                           indent, mode, prog);
   }
}


/**
 * Print program to stderr, default options.
 */
void
_mesa_print_program(const struct gl_program *prog)
{
   _mesa_fprint_program_opt(stderr, prog, PROG_PRINT_DEBUG, GL_TRUE);
}


/**
 * Return binary representation of 64-bit value (as a string).
 * Insert a comma to separate each group of 8 bits.
 * Note we return a pointer to local static storage so this is not
 * re-entrant, etc.
 * XXX move to imports.[ch] if useful elsewhere.
 */
static const char *
binary(GLbitfield64 val)
{
   static char buf[80];
   GLint i, len = 0;
   for (i = 63; i >= 0; --i) {
      if (val & (1ULL << i))
         buf[len++] = '1';
      else if (len > 0 || i == 0)
         buf[len++] = '0';
      if (len > 0 && ((i-1) % 8) == 7)
         buf[len++] = ',';
   }
   buf[len] = '\0';
   return buf;
}


/**
 * Print all of a program's parameters/fields to given file.
 */
static void
_mesa_fprint_program_parameters(FILE *f,
                                GLcontext *ctx,
                                const struct gl_program *prog)
{
   GLuint i;

   fprintf(f, "InputsRead: 0x%x (0b%s)\n",
                 prog->InputsRead, binary(prog->InputsRead));
   fprintf(f, "OutputsWritten: 0x%llx (0b%s)\n",
                 prog->OutputsWritten, binary(prog->OutputsWritten));
   fprintf(f, "NumInstructions=%d\n", prog->NumInstructions);
   fprintf(f, "NumTemporaries=%d\n", prog->NumTemporaries);
   fprintf(f, "NumParameters=%d\n", prog->NumParameters);
   fprintf(f, "NumAttributes=%d\n", prog->NumAttributes);
   fprintf(f, "NumAddressRegs=%d\n", prog->NumAddressRegs);
   fprintf(f, "SamplersUsed: 0x%x (0b%s)\n",
                 prog->SamplersUsed, binary(prog->SamplersUsed));
   fprintf(f, "Samplers=[ ");
   for (i = 0; i < MAX_SAMPLERS; i++) {
      fprintf(f, "%d ", prog->SamplerUnits[i]);
   }
   fprintf(f, "]\n");

   _mesa_load_state_parameters(ctx, prog->Parameters);

#if 0
   fprintf(f, "Local Params:\n");
   for (i = 0; i < MAX_PROGRAM_LOCAL_PARAMS; i++){
      const GLfloat *p = prog->LocalParams[i];
      fprintf(f, "%2d: %f, %f, %f, %f\n", i, p[0], p[1], p[2], p[3]);
   }
#endif	
   _mesa_print_parameter_list(prog->Parameters);
}


/**
 * Print all of a program's parameters/fields to stderr.
 */
void
_mesa_print_program_parameters(GLcontext *ctx, const struct gl_program *prog)
{
   _mesa_fprint_program_parameters(stderr, ctx, prog);
}


/**
 * Print a program parameter list to given file.
 */
static void
_mesa_fprint_parameter_list(FILE *f,
                            const struct gl_program_parameter_list *list)
{
   const gl_prog_print_mode mode = PROG_PRINT_DEBUG;
   GLuint i;

   if (!list)
      return;

   if (0)
      fprintf(f, "param list %p\n", (void *) list);
   fprintf(f, "dirty state flags: 0x%x\n", list->StateFlags);
   for (i = 0; i < list->NumParameters; i++){
      struct gl_program_parameter *param = list->Parameters + i;
      const GLfloat *v = list->ParameterValues[i];
      fprintf(f, "param[%d] sz=%d %s %s = {%.3g, %.3g, %.3g, %.3g}",
	      i, param->Size,
	      file_string(list->Parameters[i].Type, mode),
	      param->Name, v[0], v[1], v[2], v[3]);
      if (param->Flags & PROG_PARAM_BIT_CENTROID)
         fprintf(f, " Centroid");
      if (param->Flags & PROG_PARAM_BIT_INVARIANT)
         fprintf(f, " Invariant");
      if (param->Flags & PROG_PARAM_BIT_FLAT)
         fprintf(f, " Flat");
      if (param->Flags & PROG_PARAM_BIT_LINEAR)
         fprintf(f, " Linear");
      fprintf(f, "\n");
   }
}


/**
 * Print a program parameter list to stderr.
 */
void
_mesa_print_parameter_list(const struct gl_program_parameter_list *list)
{
   _mesa_fprint_parameter_list(stderr, list);
}


/**
 * Write shader and associated info to a file.
 */
void
_mesa_write_shader_to_file(const struct gl_shader *shader)
{
   const char *type;
   char filename[100];
   FILE *f;

   if (shader->Type == GL_FRAGMENT_SHADER)
      type = "frag";
   else
      type = "vert";

   _mesa_snprintf(filename, sizeof(filename), "shader_%u.%s", shader->Name, type);
   f = fopen(filename, "w");
   if (!f) {
      fprintf(stderr, "Unable to open %s for writing\n", filename);
      return;
   }

   fprintf(f, "/* Shader %u source, checksum %u */\n", shader->Name, shader->SourceChecksum);
   fputs(shader->Source, f);
   fprintf(f, "\n");

   fprintf(f, "/* Compile status: %s */\n",
           shader->CompileStatus ? "ok" : "fail");
   if (!shader->CompileStatus) {
      fprintf(f, "/* Log Info: */\n");
      fputs(shader->InfoLog, f);
   }
   else {
      fprintf(f, "/* GPU code */\n");
      fprintf(f, "/*\n");
      _mesa_fprint_program_opt(f, shader->Program, PROG_PRINT_DEBUG, GL_TRUE);
      fprintf(f, "*/\n");
      fprintf(f, "/* Parameters / constants */\n");
      fprintf(f, "/*\n");
      _mesa_fprint_parameter_list(f, shader->Program->Parameters);
      fprintf(f, "*/\n");
   }

   fclose(f);
}


/**
 * Append the shader's uniform info/values to the shader log file.
 * The log file will typically have been created by the
 * _mesa_write_shader_to_file function.
 */
void
_mesa_append_uniforms_to_file(const struct gl_shader *shader,
                              const struct gl_program *prog)
{
   const char *type;
   char filename[100];
   FILE *f;

   if (shader->Type == GL_FRAGMENT_SHADER)
      type = "frag";
   else
      type = "vert";

   _mesa_snprintf(filename, sizeof(filename), "shader_%u.%s", shader->Name, type);
   f = fopen(filename, "a"); /* append */
   if (!f) {
      fprintf(stderr, "Unable to open %s for appending\n", filename);
      return;
   }

   fprintf(f, "/* First-draw parameters / constants */\n");
   fprintf(f, "/*\n");
   _mesa_fprint_parameter_list(f, prog->Parameters);
   fprintf(f, "*/\n");

   fclose(f);
}
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d46 1
a46 1
file_string(enum register_file f, gl_prog_print_mode mode)
d78 5
a82 1
      return "Unknown program file!";
d153 4
d169 37
d261 1
a261 1
 * \param file  the register file (PROGRAM_INPUT, PROGRAM_TEMPORARY, etc)
d267 1
a267 1
reg_string(enum register_file f, GLint index, gl_prog_print_mode mode,
d271 1
d277 1
a277 4
      if (relAddr)
         sprintf(str, "%s[ADDR+%d]", file_string(f, mode), index);
      else
         sprintf(str, "%s[%d]", file_string(f, mode), index);
d292 1
a292 1
         sprintf(str, "program.env[%d]", index);
d295 1
a295 1
         sprintf(str, "program.local[%d]", index);
d298 1
a298 1
         sprintf(str, "varying[%d]", index);
d301 1
a301 1
         sprintf(str, "constant[%d]", index);
d304 1
a304 1
         sprintf(str, "uniform[%d]", index);
d310 3
a312 1
            sprintf(str, _mesa_program_state_string(param->StateIndexes));
d341 1
a341 1
         sprintf(str, "varying[%d]", index);
d344 1
a344 1
         sprintf(str, "uniform[%d]", index);
d347 1
a347 1
         sprintf(str, "constant[%d]", index);
d350 1
a350 1
         sprintf(str, "state[%d]", index);
d373 1
a373 1
_mesa_swizzle_string(GLuint swizzle, GLuint negateBase, GLboolean extended)
d379 1
a379 1
   if (!extended && swizzle == SWIZZLE_NOOP && negateBase == 0)
d385 1
a385 1
   if (negateBase & NEGATE_X)
d393 1
a393 1
   if (negateBase & NEGATE_Y)
d401 1
a401 1
   if (negateBase & NEGATE_Z)
d409 1
a409 1
   if (negateBase & NEGATE_W)
d418 13
d479 5
a483 5
   _mesa_fprintf(f, "%s%s",
                 reg_string((enum register_file) dstReg->File,
                            dstReg->Index, mode, dstReg->RelAddr, prog),
                 _mesa_writemask_string(dstReg->WriteMask));

d485 4
a488 4
      _mesa_fprintf(f, " (%s.%s)",
                    _mesa_condcode_string(dstReg->CondMask),
                    _mesa_swizzle_string(dstReg->CondSwizzle,
                                         GL_FALSE, GL_FALSE));
d492 4
a495 4
   _mesa_fprintf(f, "%s[%d]%s",
                file_string((enum register_file) dstReg->File, mode),
                dstReg->Index,
                _mesa_writemask_string(dstReg->WriteMask));
d506 9
a514 5
   _mesa_fprintf(f, "%s%s",
                 reg_string((enum register_file) srcReg->File,
                            srcReg->Index, mode, srcReg->RelAddr, prog),
                 _mesa_swizzle_string(srcReg->Swizzle,
                                      srcReg->NegateBase, GL_FALSE));
d516 5
a520 5
   _mesa_fprintf(f, "%s[%d]%s",
                 file_string((enum register_file) srcReg->File, mode),
                 srcReg->Index,
                 _mesa_swizzle_string(srcReg->Swizzle,
                                      srcReg->NegateBase, GL_FALSE));
d529 1
a529 1
      _mesa_fprintf(f, ";  # %s\n", inst->Comment);
d531 1
a531 1
      _mesa_fprintf(f, ";\n");
d544 1
a544 1
   _mesa_fprintf(f, "%s", opcode_string);
d546 1
a546 1
      _mesa_fprintf(f, ".C");
d550 1
a550 1
      _mesa_fprintf(f, "_SAT");
d552 1
a552 1
   _mesa_fprintf(f, " ");
d557 1
a557 1
      _mesa_fprintf(f, " ???");
d561 1
a561 1
      _mesa_fprintf(f, ", ");
d566 1
a566 1
	 _mesa_fprintf(f, ", ");
d577 1
a577 1
   fprint_alu_instruction(stdout, inst, opcode_string,
d585 1
a585 1
static GLint
d601 1
a601 1
      _mesa_fprintf(f, " ");
d606 1
a606 1
      _mesa_fprintf(f, "PRINT '%s'", inst->Data);
d608 7
a614 7
         _mesa_fprintf(f, ", ");
         _mesa_fprintf(f, "%s[%d]%s",
                      file_string((enum register_file) inst->SrcReg[0].File,
                                  mode),
                      inst->SrcReg[0].Index,
                      _mesa_swizzle_string(inst->SrcReg[0].Swizzle,
                                           inst->SrcReg[0].NegateBase, GL_FALSE));
d617 1
a617 1
         _mesa_fprintf(f, "  # %s", inst->Comment);
d621 1
a621 1
      _mesa_fprintf(f, "SWZ");
d623 2
a624 2
         _mesa_fprintf(f, "_SAT");
      _mesa_fprintf(f, " ");
d626 6
a631 6
      _mesa_fprintf(f, ", %s[%d], %s",
                   file_string((enum register_file) inst->SrcReg[0].File,
                               mode),
                   inst->SrcReg[0].Index,
                   _mesa_swizzle_string(inst->SrcReg[0].Swizzle,
                                        inst->SrcReg[0].NegateBase, GL_TRUE));
d638 1
a638 1
      _mesa_fprintf(f, "%s", _mesa_opcode_string(inst->Opcode));
d640 2
a641 2
         _mesa_fprintf(f, "_SAT");
      _mesa_fprintf(f, " ");
d643 1
a643 1
      _mesa_fprintf(f, ", ");
d645 1
a645 1
      _mesa_fprintf(f, ", texture[%d], ", inst->TexSrcUnit);
d647 7
a653 5
      case TEXTURE_1D_INDEX:   _mesa_fprintf(f, "1D");    break;
      case TEXTURE_2D_INDEX:   _mesa_fprintf(f, "2D");    break;
      case TEXTURE_3D_INDEX:   _mesa_fprintf(f, "3D");    break;
      case TEXTURE_CUBE_INDEX: _mesa_fprintf(f, "CUBE");  break;
      case TEXTURE_RECT_INDEX: _mesa_fprintf(f, "RECT");  break;
d657 2
d663 2
a664 2
      _mesa_fprintf(f, "%s", _mesa_opcode_string(inst->Opcode));
      _mesa_fprintf(f, " ");
d669 6
a674 6
      _mesa_fprintf(f, "%s", _mesa_opcode_string(inst->Opcode));
      _mesa_fprintf(f, " ");
      _mesa_fprintf(f, "%s.%s",
                   _mesa_condcode_string(inst->DstReg.CondMask),
                   _mesa_swizzle_string(inst->DstReg.CondSwizzle,
                                        GL_FALSE, GL_FALSE));
d679 1
a679 1
      _mesa_fprintf(f, "ARL ");
d681 1
a681 1
      _mesa_fprintf(f, ", ");
d686 4
a689 4
      _mesa_fprintf(f, "BRA %d (%s%s)",
                   inst->BranchTarget,
                   _mesa_condcode_string(inst->DstReg.CondMask),
                   _mesa_swizzle_string(inst->DstReg.CondSwizzle, 0, GL_FALSE));
d695 1
a695 1
         _mesa_fprintf(f, "IF ");
d697 1
a697 1
         _mesa_fprintf(f, "; ");
d701 4
a704 4
         _mesa_fprintf(f, "IF (%s%s);",
                      _mesa_condcode_string(inst->DstReg.CondMask),
                      _mesa_swizzle_string(inst->DstReg.CondSwizzle,
                                           0, GL_FALSE));
d706 1
a706 1
      _mesa_fprintf(f, " # (if false, goto %d)", inst->BranchTarget);
d710 1
a710 1
      _mesa_fprintf(f, "ELSE; # (goto %d)\n", inst->BranchTarget);
d713 1
a713 1
      _mesa_fprintf(f, "ENDIF;\n");
d716 1
a716 1
      _mesa_fprintf(f, "BGNLOOP; # (end at %d)\n", inst->BranchTarget);
d719 1
a719 1
      _mesa_fprintf(f, "ENDLOOP; # (goto %d)\n", inst->BranchTarget);
d723 5
a727 5
      _mesa_fprintf(f, "%s (%s%s); # (goto %d)",
                   _mesa_opcode_string(inst->Opcode),
                   _mesa_condcode_string(inst->DstReg.CondMask),
                   _mesa_swizzle_string(inst->DstReg.CondSwizzle, 0, GL_FALSE),
                   inst->BranchTarget);
d733 1
a733 1
         _mesa_fprintf(f, "%s:\n", inst->Comment); /* comment is label */
d737 1
a737 1
         _mesa_fprintf(f, "BGNSUB");
d743 1
a743 1
         _mesa_fprintf(f, "ENDSUB");
d749 1
a749 1
         _mesa_fprintf(f, "CAL %s;  # (goto %d)\n", inst->Comment, inst->BranchTarget);
d752 1
a752 1
         _mesa_fprintf(f, "CAL %u", inst->BranchTarget);
d757 3
a759 3
      _mesa_fprintf(f, "RET (%s%s)",
                   _mesa_condcode_string(inst->DstReg.CondMask),
                   _mesa_swizzle_string(inst->DstReg.CondSwizzle, 0, GL_FALSE));
d764 1
a764 1
      _mesa_fprintf(f, "END\n");
d768 1
a768 1
         _mesa_fprintf(f, "NOP");
d773 1
a773 1
         _mesa_fprintf(f, "# %s\n", inst->Comment);
d778 13
a790 5
      /* typical alu instruction */
      fprint_alu_instruction(f, inst,
                             _mesa_opcode_string(inst->Opcode),
                             _mesa_num_inst_src_regs(inst->Opcode),
                             mode, prog);
d803 1
a803 1
   return _mesa_fprint_instruction_opt(stdout, inst, indent, mode, prog);
d811 1
a811 1
   _mesa_fprint_instruction_opt(stdout, inst, 0, PROG_PRINT_DEBUG, NULL);
d819 1
a819 1
static void
d830 1
a830 1
         _mesa_fprintf(f, "!!ARBvp1.0\n");
d832 1
a832 1
         _mesa_fprintf(f, "!!VP1.0\n");
d834 1
a834 1
         _mesa_fprintf(f, "# Vertex Program/Shader\n");
d839 1
a839 1
         _mesa_fprintf(f, "!!ARBfp1.0\n");
d841 1
a841 1
         _mesa_fprintf(f, "!!FP1.0\n");
d843 1
a843 1
         _mesa_fprintf(f, "# Fragment Program/Shader\n");
d849 1
a849 1
         _mesa_fprintf(f, "%3d: ", i);
d857 1
a857 1
 * Print program to stdout, default options.
d862 26
a887 1
   _mesa_fprint_program_opt(stdout, prog, PROG_PRINT_DEBUG, GL_TRUE);
d901 12
a912 8
   _mesa_fprintf(f, "InputsRead: 0x%x\n", prog->InputsRead);
   _mesa_fprintf(f, "OutputsWritten: 0x%x\n", prog->OutputsWritten);
   _mesa_fprintf(f, "NumInstructions=%d\n", prog->NumInstructions);
   _mesa_fprintf(f, "NumTemporaries=%d\n", prog->NumTemporaries);
   _mesa_fprintf(f, "NumParameters=%d\n", prog->NumParameters);
   _mesa_fprintf(f, "NumAttributes=%d\n", prog->NumAttributes);
   _mesa_fprintf(f, "NumAddressRegs=%d\n", prog->NumAddressRegs);
   _mesa_fprintf(f, "Samplers=[ ");
d914 1
a914 1
      _mesa_fprintf(f, "%d ", prog->SamplerUnits[i]);
d916 1
a916 1
   _mesa_fprintf(f, "]\n");
d921 1
a921 1
   _mesa_fprintf(f, "Local Params:\n");
d924 1
a924 1
      _mesa_fprintf(f, "%2d: %f, %f, %f, %f\n", i, p[0], p[1], p[2], p[3]);
d932 1
a932 1
 * Print all of a program's parameters/fields to stdout.
d937 1
a937 1
   _mesa_fprint_program_parameters(stdout, ctx, prog);
d954 3
a956 1
   _mesa_fprintf(f, "param list %p\n", (void *) list);
d960 4
a963 4
      _mesa_fprintf(f, "param[%d] sz=%d %s %s = {%.3g, %.3g, %.3g, %.3g}",
                   i, param->Size,
                   file_string(list->Parameters[i].Type, mode),
                   param->Name, v[0], v[1], v[2], v[3]);
d965 1
a965 1
         _mesa_fprintf(f, " Centroid");
d967 1
a967 1
         _mesa_fprintf(f, " Invariant");
d969 1
a969 1
         _mesa_fprintf(f, " Flat");
d971 2
a972 2
         _mesa_fprintf(f, " Linear");
      _mesa_fprintf(f, "\n");
d978 1
a978 1
 * Print a program parameter list to stdout.
d983 1
a983 1
   _mesa_fprint_parameter_list(stdout, list);
d1002 1
a1002 1
   snprintf(filename, strlen(filename), "shader_%u.%s", shader->Name, type);
d1009 1
a1009 1
   fprintf(f, "/* Shader %u source */\n", shader->Name);
d1021 1
d1023 5
d1034 32
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 2
a6 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d32 3
a34 3
#include "glheader.h"
#include "context.h"
#include "imports.h"
d75 2
d89 3
d166 3
d193 6
a198 1
      "result.depth"
d232 1
a232 1
         sprintf(str, "%s[ADDR%s%d]", file_string(f, mode), (index > 0) ? "+" : "", index);
d373 2
a374 2
static const char *
writemask_string(GLuint writeMask)
d416 9
a424 7
print_dst_reg(const struct prog_dst_register *dstReg, gl_prog_print_mode mode,
              const struct gl_program *prog)
{
   _mesa_printf("%s%s",
                reg_string((enum register_file) dstReg->File,
                           dstReg->Index, mode, GL_FALSE, prog),
                writemask_string(dstReg->WriteMask));
d427 4
a430 3
      _mesa_printf(" (%s.%s)",
                   _mesa_condcode_string(dstReg->CondMask),
                   _mesa_swizzle_string(dstReg->CondSwizzle, GL_FALSE, GL_FALSE));
d434 1
a434 1
   _mesa_printf("%s[%d]%s",
d437 1
a437 1
                writemask_string(dstReg->WriteMask));
d441 1
d443 10
a452 8
print_src_reg(const struct prog_src_register *srcReg, gl_prog_print_mode mode,
              const struct gl_program *prog)
{
   _mesa_printf("%s%s",
                reg_string((enum register_file) srcReg->File,
                           srcReg->Index, mode, srcReg->RelAddr, prog),
                _mesa_swizzle_string(srcReg->Swizzle,
                                     srcReg->NegateBase, GL_FALSE));
d454 5
a458 5
   _mesa_printf("%s[%d]%s",
                file_string((enum register_file) srcReg->File, mode),
                srcReg->Index,
                _mesa_swizzle_string(srcReg->Swizzle,
                               srcReg->NegateBase, GL_FALSE));
d462 1
d464 1
a464 1
print_comment(const struct prog_instruction *inst)
d467 1
a467 1
      _mesa_printf(";  # %s\n", inst->Comment);
d469 1
a469 1
      _mesa_printf(";\n");
d474 5
a478 4
print_alu_instruction(const struct prog_instruction *inst,
                      const char *opcode_string, GLuint numRegs,
                      gl_prog_print_mode mode,
                      const struct gl_program *prog)
d482 1
a482 1
   _mesa_printf("%s", opcode_string);
d484 1
a484 1
      _mesa_printf(".C");
d488 1
a488 1
      _mesa_printf("_SAT");
d490 1
a490 1
   _mesa_printf(" ");
d492 1
a492 1
      print_dst_reg(&inst->DstReg, mode, prog);
d495 1
a495 1
      _mesa_printf(" ???");
d499 1
a499 1
      _mesa_printf(", ");
d502 1
a502 1
      print_src_reg(inst->SrcReg + j, mode, prog);
d504 1
a504 1
	 _mesa_printf(", ");
d507 1
a507 1
   print_comment(inst);
d515 2
a516 9
   print_alu_instruction(inst, opcode_string, numRegs, PROG_PRINT_DEBUG, NULL);
}


void
_mesa_print_instruction(const struct prog_instruction *inst)
{
   /* note: 4th param should be ignored for PROG_PRINT_DEBUG */
   _mesa_print_instruction_opt(inst, 0, PROG_PRINT_DEBUG, NULL);
d523 4
a526 2
GLint
_mesa_print_instruction_opt(const struct prog_instruction *inst, GLint indent,
d539 1
a539 1
      _mesa_printf(" ");
d544 1
a544 1
      _mesa_printf("PRINT '%s'", inst->Data);
d546 2
a547 2
         _mesa_printf(", ");
         _mesa_printf("%s[%d]%s",
d555 2
a556 2
         _mesa_printf("  # %s", inst->Comment);
      print_comment(inst);
d559 1
a559 1
      _mesa_printf("SWZ");
d561 4
a564 4
         _mesa_printf("_SAT");
      _mesa_printf(" ");
      print_dst_reg(&inst->DstReg, mode, prog);
      _mesa_printf(", %s[%d], %s",
d570 1
a570 1
      print_comment(inst);
d576 1
a576 1
      _mesa_printf("%s", _mesa_opcode_string(inst->Opcode));
d578 6
a583 6
         _mesa_printf("_SAT");
      _mesa_printf(" ");
      print_dst_reg(&inst->DstReg, mode, prog);
      _mesa_printf(", ");
      print_src_reg(&inst->SrcReg[0], mode, prog);
      _mesa_printf(", texture[%d], ", inst->TexSrcUnit);
d585 5
a589 5
      case TEXTURE_1D_INDEX:   _mesa_printf("1D");    break;
      case TEXTURE_2D_INDEX:   _mesa_printf("2D");    break;
      case TEXTURE_3D_INDEX:   _mesa_printf("3D");    break;
      case TEXTURE_CUBE_INDEX: _mesa_printf("CUBE");  break;
      case TEXTURE_RECT_INDEX: _mesa_printf("RECT");  break;
d593 1
a593 1
      print_comment(inst);
d597 4
a600 4
      _mesa_printf("%s", _mesa_opcode_string(inst->Opcode));
      _mesa_printf(" ");
      print_src_reg(&inst->SrcReg[0], mode, prog);
      print_comment(inst);
d603 3
a605 3
      _mesa_printf("%s", _mesa_opcode_string(inst->Opcode));
      _mesa_printf(" ");
      _mesa_printf("%s.%s",
d609 1
a609 1
      print_comment(inst);
d613 5
a617 5
      _mesa_printf("ARL ");
      print_dst_reg(&inst->DstReg, mode, prog);
      _mesa_printf(", ");
      print_src_reg(&inst->SrcReg[0], mode, prog);
      print_comment(inst);
d620 1
a620 1
      _mesa_printf("BRA %d (%s%s)",
d624 1
a624 1
      print_comment(inst);
d629 3
a631 3
         _mesa_printf("IF ");
         print_src_reg(&inst->SrcReg[0], mode, prog);
         _mesa_printf("; ");
d635 1
a635 1
         _mesa_printf("IF (%s%s);",
d640 2
a641 2
      _mesa_printf(" # (if false, goto %d)", inst->BranchTarget);
      print_comment(inst);
d644 1
a644 1
      _mesa_printf("ELSE; # (goto %d)\n", inst->BranchTarget);
d647 1
a647 1
      _mesa_printf("ENDIF;\n");
d650 1
a650 1
      _mesa_printf("BGNLOOP; # (end at %d)\n", inst->BranchTarget);
d653 1
a653 1
      _mesa_printf("ENDLOOP; # (goto %d)\n", inst->BranchTarget);
d657 1
a657 1
      _mesa_printf("%s (%s%s); # (goto %d)",
d662 1
a662 1
      print_comment(inst);
d667 1
a667 1
         _mesa_printf("%s:\n", inst->Comment); /* comment is label */
d671 2
a672 2
         _mesa_printf("BGNSUB");
         print_comment(inst);
d677 2
a678 2
         _mesa_printf("ENDSUB");
         print_comment(inst);
d683 1
a683 1
         _mesa_printf("CAL %s;  # (goto %d)\n", inst->Comment, inst->BranchTarget);
d686 2
a687 2
         _mesa_printf("CAL %u", inst->BranchTarget);
         print_comment(inst);
d691 1
a691 1
      _mesa_printf("RET (%s%s)",
d694 1
a694 1
      print_comment(inst);
d698 1
a698 1
      _mesa_printf("END\n");
d702 2
a703 2
         _mesa_printf("NOP");
         print_comment(inst);
d707 1
a707 1
         _mesa_printf("# %s\n", inst->Comment);
d713 4
a716 4
      print_alu_instruction(inst,
                            _mesa_opcode_string(inst->Opcode),
                            _mesa_num_inst_src_regs(inst->Opcode),
                            mode, prog);
d723 10
a732 3
/**
 * Print program to stdout, default options.
 */
d734 1
a734 1
_mesa_print_program(const struct gl_program *prog)
d736 2
a737 1
   _mesa_print_program_opt(prog, PROG_PRINT_DEBUG, GL_TRUE);
d741 1
d745 5
a749 4
void
_mesa_print_program_opt(const struct gl_program *prog,
                        gl_prog_print_mode mode,
                        GLboolean lineNumbers)
d756 1
a756 1
         _mesa_printf("!!ARBvp1.0\n");
d758 1
a758 1
         _mesa_printf("!!VP1.0\n");
d760 1
a760 1
         _mesa_printf("# Vertex Program/Shader\n");
d765 1
a765 1
         _mesa_printf("!!ARBfp1.0\n");
d767 1
a767 1
         _mesa_printf("!!FP1.0\n");
d769 1
a769 1
         _mesa_printf("# Fragment Program/Shader\n");
d775 2
a776 2
         _mesa_printf("%3d: ", i);
      indent = _mesa_print_instruction_opt(prog->Instructions + i,
d783 1
a783 1
 * Print all of a program's parameters.
d786 13
a798 1
_mesa_print_program_parameters(GLcontext *ctx, const struct gl_program *prog)
d802 8
a809 8
   _mesa_printf("InputsRead: 0x%x\n", prog->InputsRead);
   _mesa_printf("OutputsWritten: 0x%x\n", prog->OutputsWritten);
   _mesa_printf("NumInstructions=%d\n", prog->NumInstructions);
   _mesa_printf("NumTemporaries=%d\n", prog->NumTemporaries);
   _mesa_printf("NumParameters=%d\n", prog->NumParameters);
   _mesa_printf("NumAttributes=%d\n", prog->NumAttributes);
   _mesa_printf("NumAddressRegs=%d\n", prog->NumAddressRegs);
   _mesa_printf("Samplers=[ ");
d811 1
a811 1
      _mesa_printf("%d ", prog->SamplerUnits[i]);
d813 1
a813 1
   _mesa_printf("]\n");
d818 1
a818 1
   _mesa_printf("Local Params:\n");
d821 1
a821 1
      _mesa_printf("%2d: %f, %f, %f, %f\n", i, p[0], p[1], p[2], p[3]);
d828 3
d832 12
a843 1
_mesa_print_parameter_list(const struct gl_program_parameter_list *list)
d851 1
a851 1
   _mesa_printf("param list %p\n", (void *) list);
d855 1
a855 1
      _mesa_printf("param[%d] sz=%d %s %s = {%.3g, %.3g, %.3g, %.3g};\n",
d859 9
d870 53
@


1.1
log
@Initial revision
@
text
@d102 17
a118 1
      "vertex.texcoord[7]"
d209 1
a209 1
           const struct gl_program *prog)
d217 4
a220 1
      sprintf(str, "%s[%d]", file_string(f, mode), index);
d316 1
a316 1
   static const char swz[] = "xyzw01?!";
d326 1
a326 1
   if (negateBase & 0x1)
d334 1
a334 1
   if (negateBase & 0x2)
d342 1
a342 1
   if (negateBase & 0x4)
d350 1
a350 1
   if (negateBase & 0x8)
d407 1
a407 1
                           dstReg->Index, mode, prog),
d430 1
a430 1
                           srcReg->Index, mode, prog),
d432 1
a432 1
                               srcReg->NegateBase, GL_FALSE));
d547 1
a547 1
      _mesa_printf("%s[%d], %s",
d557 1
d578 17
d596 3
a598 1
      _mesa_printf("ARL addr.x, ");
d761 2
d770 6
a775 1
	
d777 1
a777 1
			
d794 3
@


1.1.1.1
log
@Mesa 7.0.1
@
text
@@
