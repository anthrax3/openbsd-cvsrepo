head	1.8;
access;
symbols
	OPENBSD_5_0:1.7.0.6
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2011.10.23.13.37.44;	author matthieu;	state dead;
branches;
next	1.7;

1.7
date	2010.06.22.20.04.22;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.22.20.06.32;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.14.58.22;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.31.16.36.49;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.17.31.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.17.31.43;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge Mesa 7.10.3
@
text
@/*
 * Mesa 3-D graphics library
 * Version:  7.6
 *
 * Copyright (C) 2004-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file shader_api.c
 * Implementation of GLSL-related API functions
 * \author Brian Paul
 */

/**
 * XXX things to do:
 * 1. Check that the right error code is generated for all _mesa_error() calls.
 * 2. Insert FLUSH_VERTICES calls in various places
 */


#include "main/glheader.h"
#include "main/context.h"
#include "main/hash.h"
#include "shader/program.h"
#include "shader/prog_parameter.h"
#include "shader/prog_statevars.h"
#include "shader/prog_uniform.h"
#include "shader/shader_api.h"
#include "shader/slang/slang_compile.h"
#include "shader/slang/slang_link.h"
#include "main/dispatch.h"


/**
 * Allocate a new gl_shader_program object, initialize it.
 */
static struct gl_shader_program *
_mesa_new_shader_program(GLcontext *ctx, GLuint name)
{
   struct gl_shader_program *shProg;
   shProg = CALLOC_STRUCT(gl_shader_program);
   if (shProg) {
      shProg->Type = GL_SHADER_PROGRAM_MESA;
      shProg->Name = name;
      shProg->RefCount = 1;
      shProg->Attributes = _mesa_new_parameter_list();
   }
   return shProg;
}


/**
 * Clear (free) the shader program state that gets produced by linking.
 */
void
_mesa_clear_shader_program_data(GLcontext *ctx,
                                struct gl_shader_program *shProg)
{
   _mesa_reference_vertprog(ctx, &shProg->VertexProgram, NULL);
   _mesa_reference_fragprog(ctx, &shProg->FragmentProgram, NULL);

   if (shProg->Uniforms) {
      _mesa_free_uniform_list(shProg->Uniforms);
      shProg->Uniforms = NULL;
   }

   if (shProg->Varying) {
      _mesa_free_parameter_list(shProg->Varying);
      shProg->Varying = NULL;
   }
}


/**
 * Free all the data that hangs off a shader program object, but not the
 * object itself.
 */
void
_mesa_free_shader_program_data(GLcontext *ctx,
                               struct gl_shader_program *shProg)
{
   GLuint i;

   assert(shProg->Type == GL_SHADER_PROGRAM_MESA);

   _mesa_clear_shader_program_data(ctx, shProg);

   if (shProg->Attributes) {
      _mesa_free_parameter_list(shProg->Attributes);
      shProg->Attributes = NULL;
   }

   /* detach shaders */
   for (i = 0; i < shProg->NumShaders; i++) {
      _mesa_reference_shader(ctx, &shProg->Shaders[i], NULL);
   }
   shProg->NumShaders = 0;

   if (shProg->Shaders) {
      free(shProg->Shaders);
      shProg->Shaders = NULL;
   }

   if (shProg->InfoLog) {
      free(shProg->InfoLog);
      shProg->InfoLog = NULL;
   }
}


/**
 * Free/delete a shader program object.
 */
void
_mesa_free_shader_program(GLcontext *ctx, struct gl_shader_program *shProg)
{
   _mesa_free_shader_program_data(ctx, shProg);

   free(shProg);
}


/**
 * Set ptr to point to shProg.
 * If ptr is pointing to another object, decrement its refcount (and delete
 * if refcount hits zero).
 * Then set ptr to point to shProg, incrementing its refcount.
 */
/* XXX this could be static */
void
_mesa_reference_shader_program(GLcontext *ctx,
                               struct gl_shader_program **ptr,
                               struct gl_shader_program *shProg)
{
   assert(ptr);
   if (*ptr == shProg) {
      /* no-op */
      return;
   }
   if (*ptr) {
      /* Unreference the old shader program */
      GLboolean deleteFlag = GL_FALSE;
      struct gl_shader_program *old = *ptr;

      ASSERT(old->RefCount > 0);
      old->RefCount--;
#if 0
      printf("ShaderProgram %p ID=%u  RefCount-- to %d\n",
             (void *) old, old->Name, old->RefCount);
#endif
      deleteFlag = (old->RefCount == 0);

      if (deleteFlag) {
         _mesa_HashRemove(ctx->Shared->ShaderObjects, old->Name);
         _mesa_free_shader_program(ctx, old);
      }

      *ptr = NULL;
   }
   assert(!*ptr);

   if (shProg) {
      shProg->RefCount++;
#if 0
      printf("ShaderProgram %p ID=%u  RefCount++ to %d\n",
             (void *) shProg, shProg->Name, shProg->RefCount);
#endif
      *ptr = shProg;
   }
}


/**
 * Lookup a GLSL program object.
 */
struct gl_shader_program *
_mesa_lookup_shader_program(GLcontext *ctx, GLuint name)
{
   struct gl_shader_program *shProg;
   if (name) {
      shProg = (struct gl_shader_program *)
         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
      /* Note that both gl_shader and gl_shader_program objects are kept
       * in the same hash table.  Check the object's type to be sure it's
       * what we're expecting.
       */
      if (shProg && shProg->Type != GL_SHADER_PROGRAM_MESA) {
         return NULL;
      }
      return shProg;
   }
   return NULL;
}


/**
 * As above, but record an error if program is not found.
 */
static struct gl_shader_program *
_mesa_lookup_shader_program_err(GLcontext *ctx, GLuint name,
                                const char *caller)
{
   if (!name) {
      _mesa_error(ctx, GL_INVALID_VALUE, caller);
      return NULL;
   }
   else {
      struct gl_shader_program *shProg = (struct gl_shader_program *)
         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
      if (!shProg) {
         _mesa_error(ctx, GL_INVALID_VALUE, caller);
         return NULL;
      }
      if (shProg->Type != GL_SHADER_PROGRAM_MESA) {
         _mesa_error(ctx, GL_INVALID_OPERATION, caller);
         return NULL;
      }
      return shProg;
   }
}




/**
 * Allocate a new gl_shader object, initialize it.
 */
struct gl_shader *
_mesa_new_shader(GLcontext *ctx, GLuint name, GLenum type)
{
   struct gl_shader *shader;
   assert(type == GL_FRAGMENT_SHADER || type == GL_VERTEX_SHADER);
   shader = CALLOC_STRUCT(gl_shader);
   if (shader) {
      shader->Type = type;
      shader->Name = name;
      shader->RefCount = 1;
   }
   return shader;
}


void
_mesa_free_shader(GLcontext *ctx, struct gl_shader *sh)
{
   if (sh->Source)
      free((void *) sh->Source);
   if (sh->InfoLog)
      free(sh->InfoLog);
   _mesa_reference_program(ctx, &sh->Program, NULL);
   free(sh);
}


/**
 * Set ptr to point to sh.
 * If ptr is pointing to another shader, decrement its refcount (and delete
 * if refcount hits zero).
 * Then set ptr to point to sh, incrementing its refcount.
 */
/* XXX this could be static */
void
_mesa_reference_shader(GLcontext *ctx, struct gl_shader **ptr,
                       struct gl_shader *sh)
{
   assert(ptr);
   if (*ptr == sh) {
      /* no-op */
      return;
   }
   if (*ptr) {
      /* Unreference the old shader */
      GLboolean deleteFlag = GL_FALSE;
      struct gl_shader *old = *ptr;

      ASSERT(old->RefCount > 0);
      old->RefCount--;
      /*printf("SHADER DECR %p (%d) to %d\n",
        (void*) old, old->Name, old->RefCount);*/
      deleteFlag = (old->RefCount == 0);

      if (deleteFlag) {
         _mesa_HashRemove(ctx->Shared->ShaderObjects, old->Name);
         _mesa_free_shader(ctx, old);
      }

      *ptr = NULL;
   }
   assert(!*ptr);

   if (sh) {
      /* reference new */
      sh->RefCount++;
      /*printf("SHADER INCR %p (%d) to %d\n",
        (void*) sh, sh->Name, sh->RefCount);*/
      *ptr = sh;
   }
}


/**
 * Lookup a GLSL shader object.
 */
struct gl_shader *
_mesa_lookup_shader(GLcontext *ctx, GLuint name)
{
   if (name) {
      struct gl_shader *sh = (struct gl_shader *)
         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
      /* Note that both gl_shader and gl_shader_program objects are kept
       * in the same hash table.  Check the object's type to be sure it's
       * what we're expecting.
       */
      if (sh && sh->Type == GL_SHADER_PROGRAM_MESA) {
         return NULL;
      }
      return sh;
   }
   return NULL;
}


/**
 * As above, but record an error if shader is not found.
 */
static struct gl_shader *
_mesa_lookup_shader_err(GLcontext *ctx, GLuint name, const char *caller)
{
   if (!name) {
      _mesa_error(ctx, GL_INVALID_VALUE, caller);
      return NULL;
   }
   else {
      struct gl_shader *sh = (struct gl_shader *)
         _mesa_HashLookup(ctx->Shared->ShaderObjects, name);
      if (!sh) {
         _mesa_error(ctx, GL_INVALID_VALUE, caller);
         return NULL;
      }
      if (sh->Type == GL_SHADER_PROGRAM_MESA) {
         _mesa_error(ctx, GL_INVALID_OPERATION, caller);
         return NULL;
      }
      return sh;
   }
}


/**
 * Return mask of GLSL_x flags by examining the MESA_GLSL env var.
 */
static GLbitfield
get_shader_flags(void)
{
   GLbitfield flags = 0x0;
   const char *env = _mesa_getenv("MESA_GLSL");

   if (env) {
      if (strstr(env, "dump"))
         flags |= GLSL_DUMP;
      if (strstr(env, "log"))
         flags |= GLSL_LOG;
      if (strstr(env, "nopvert"))
         flags |= GLSL_NOP_VERT;
      if (strstr(env, "nopfrag"))
         flags |= GLSL_NOP_FRAG;
      if (strstr(env, "nopt"))
         flags |= GLSL_NO_OPT;
      else if (strstr(env, "opt"))
         flags |= GLSL_OPT;
      if (strstr(env, "uniform"))
         flags |= GLSL_UNIFORMS;
      if (strstr(env, "useprog"))
         flags |= GLSL_USE_PROG;
   }

   return flags;
}


/**
 * Initialize context's shader state.
 */
void
_mesa_init_shader_state(GLcontext * ctx)
{
   /* Device drivers may override these to control what kind of instructions
    * are generated by the GLSL compiler.
    */
   ctx->Shader.EmitHighLevelInstructions = GL_TRUE;
   ctx->Shader.EmitContReturn = GL_TRUE;
   ctx->Shader.EmitCondCodes = GL_FALSE;
   ctx->Shader.EmitComments = GL_FALSE;
   ctx->Shader.Flags = get_shader_flags();

   /* Default pragma settings */
   ctx->Shader.DefaultPragmas.IgnoreOptimize = GL_FALSE;
   ctx->Shader.DefaultPragmas.IgnoreDebug = GL_FALSE;
   ctx->Shader.DefaultPragmas.Optimize = GL_TRUE;
   ctx->Shader.DefaultPragmas.Debug = GL_FALSE;
}


/**
 * Free the per-context shader-related state.
 */
void
_mesa_free_shader_state(GLcontext *ctx)
{
   _mesa_reference_shader_program(ctx, &ctx->Shader.CurrentProgram, NULL);
}


/**
 * Copy string from <src> to <dst>, up to maxLength characters, returning
 * length of <dst> in <length>.
 * \param src  the strings source
 * \param maxLength  max chars to copy
 * \param length  returns number of chars copied
 * \param dst  the string destination
 */
static void
copy_string(GLchar *dst, GLsizei maxLength, GLsizei *length, const GLchar *src)
{
   GLsizei len;
   for (len = 0; len < maxLength - 1 && src && src[len]; len++)
      dst[len] = src[len];
   if (maxLength > 0)
      dst[len] = 0;
   if (length)
      *length = len;
}


static GLboolean
_mesa_is_program(GLcontext *ctx, GLuint name)
{
   struct gl_shader_program *shProg = _mesa_lookup_shader_program(ctx, name);
   return shProg ? GL_TRUE : GL_FALSE;
}


static GLboolean
_mesa_is_shader(GLcontext *ctx, GLuint name)
{
   struct gl_shader *shader = _mesa_lookup_shader(ctx, name);
   return shader ? GL_TRUE : GL_FALSE;
}


/**
 * Called via ctx->Driver.AttachShader()
 */
static void
_mesa_attach_shader(GLcontext *ctx, GLuint program, GLuint shader)
{
   struct gl_shader_program *shProg;
   struct gl_shader *sh;
   GLuint i, n;

   shProg = _mesa_lookup_shader_program_err(ctx, program, "glAttachShader");
   if (!shProg)
      return;

   sh = _mesa_lookup_shader_err(ctx, shader, "glAttachShader");
   if (!sh) {
      return;
   }

   n = shProg->NumShaders;
   for (i = 0; i < n; i++) {
      if (shProg->Shaders[i] == sh) {
         /* The shader is already attched to this program.  The
          * GL_ARB_shader_objects spec says:
          *
          *     "The error INVALID_OPERATION is generated by AttachObjectARB
          *     if <obj> is already attached to <containerObj>."
          */
         _mesa_error(ctx, GL_INVALID_OPERATION, "glAttachShader");
         return;
      }
   }

   /* grow list */
   shProg->Shaders = (struct gl_shader **)
      _mesa_realloc(shProg->Shaders,
                    n * sizeof(struct gl_shader *),
                    (n + 1) * sizeof(struct gl_shader *));
   if (!shProg->Shaders) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glAttachShader");
      return;
   }

   /* append */
   shProg->Shaders[n] = NULL; /* since realloc() didn't zero the new space */
   _mesa_reference_shader(ctx, &shProg->Shaders[n], sh);
   shProg->NumShaders++;
}


static GLint
_mesa_get_attrib_location(GLcontext *ctx, GLuint program,
                          const GLchar *name)
{
   struct gl_shader_program *shProg
      = _mesa_lookup_shader_program_err(ctx, program, "glGetAttribLocation");

   if (!shProg) {
      return -1;
   }

   if (!shProg->LinkStatus) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetAttribLocation(program not linked)");
      return -1;
   }

   if (!name)
      return -1;

   if (shProg->VertexProgram) {
      const struct gl_program_parameter_list *attribs =
         shProg->VertexProgram->Base.Attributes;
      if (attribs) {
         GLint i = _mesa_lookup_parameter_index(attribs, -1, name);
         if (i >= 0) {
            return attribs->Parameters[i].StateIndexes[0];
         }
      }
   }
   return -1;
}


static void
_mesa_bind_attrib_location(GLcontext *ctx, GLuint program, GLuint index,
                           const GLchar *name)
{
   struct gl_shader_program *shProg;
   const GLint size = -1; /* unknown size */
   GLint i, oldIndex;
   GLenum datatype = GL_FLOAT_VEC4;

   shProg = _mesa_lookup_shader_program_err(ctx, program,
                                            "glBindAttribLocation");
   if (!shProg) {
      return;
   }

   if (!name)
      return;

   if (strncmp(name, "gl_", 3) == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glBindAttribLocation(illegal name)");
      return;
   }

   if (index >= ctx->Const.VertexProgram.MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glBindAttribLocation(index)");
      return;
   }

   if (shProg->LinkStatus) {
      /* get current index/location for the attribute */
      oldIndex = _mesa_get_attrib_location(ctx, program, name);
   }
   else {
      oldIndex = -1;
   }

   /* this will replace the current value if it's already in the list */
   i = _mesa_add_attribute(shProg->Attributes, name, size, datatype, index);
   if (i < 0) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBindAttribLocation");
      return;
   }

   /*
    * Note that this attribute binding won't go into effect until
    * glLinkProgram is called again.
    */
}


static GLuint
_mesa_create_shader(GLcontext *ctx, GLenum type)
{
   struct gl_shader *sh;
   GLuint name;

   name = _mesa_HashFindFreeKeyBlock(ctx->Shared->ShaderObjects, 1);

   switch (type) {
   case GL_FRAGMENT_SHADER:
   case GL_VERTEX_SHADER:
      sh = _mesa_new_shader(ctx, name, type);
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "CreateShader(type)");
      return 0;
   }

   _mesa_HashInsert(ctx->Shared->ShaderObjects, name, sh);

   return name;
}


static GLuint 
_mesa_create_program(GLcontext *ctx)
{
   GLuint name;
   struct gl_shader_program *shProg;

   name = _mesa_HashFindFreeKeyBlock(ctx->Shared->ShaderObjects, 1);
   shProg = _mesa_new_shader_program(ctx, name);

   _mesa_HashInsert(ctx->Shared->ShaderObjects, name, shProg);

   assert(shProg->RefCount == 1);

   return name;
}


/**
 * Named w/ "2" to indicate OpenGL 2.x vs GL_ARB_fragment_programs's
 * DeleteProgramARB.
 */
static void
_mesa_delete_program2(GLcontext *ctx, GLuint name)
{
   /*
    * NOTE: deleting shaders/programs works a bit differently than
    * texture objects (and buffer objects, etc).  Shader/program
    * handles/IDs exist in the hash table until the object is really
    * deleted (refcount==0).  With texture objects, the handle/ID is
    * removed from the hash table in glDeleteTextures() while the tex
    * object itself might linger until its refcount goes to zero.
    */
   struct gl_shader_program *shProg;

   shProg = _mesa_lookup_shader_program_err(ctx, name, "glDeleteProgram");
   if (!shProg)
      return;

   shProg->DeletePending = GL_TRUE;

   /* effectively, decr shProg's refcount */
   _mesa_reference_shader_program(ctx, &shProg, NULL);
}


static void
_mesa_delete_shader(GLcontext *ctx, GLuint shader)
{
   struct gl_shader *sh;

   sh = _mesa_lookup_shader_err(ctx, shader, "glDeleteShader");
   if (!sh)
      return;

   sh->DeletePending = GL_TRUE;

   /* effectively, decr sh's refcount */
   _mesa_reference_shader(ctx, &sh, NULL);
}


static void
_mesa_detach_shader(GLcontext *ctx, GLuint program, GLuint shader)
{
   struct gl_shader_program *shProg;
   GLuint n;
   GLuint i, j;

   shProg = _mesa_lookup_shader_program_err(ctx, program, "glDetachShader");
   if (!shProg)
      return;

   n = shProg->NumShaders;

   for (i = 0; i < n; i++) {
      if (shProg->Shaders[i]->Name == shader) {
         /* found it */
         struct gl_shader **newList;

         /* release */
         _mesa_reference_shader(ctx, &shProg->Shaders[i], NULL);

         /* alloc new, smaller array */
         newList = (struct gl_shader **)
            malloc((n - 1) * sizeof(struct gl_shader *));
         if (!newList) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glDetachShader");
            return;
         }
         for (j = 0; j < i; j++) {
            newList[j] = shProg->Shaders[j];
         }
         while (++i < n)
            newList[j++] = shProg->Shaders[i];
         free(shProg->Shaders);

         shProg->Shaders = newList;
         shProg->NumShaders = n - 1;

#ifdef DEBUG
         /* sanity check */
         {
            for (j = 0; j < shProg->NumShaders; j++) {
               assert(shProg->Shaders[j]->Type == GL_VERTEX_SHADER ||
                      shProg->Shaders[j]->Type == GL_FRAGMENT_SHADER);
               assert(shProg->Shaders[j]->RefCount > 0);
            }
         }
#endif

         return;
      }
   }

   /* not found */
   {
      GLenum err;
      if (_mesa_is_shader(ctx, shader))
         err = GL_INVALID_OPERATION;
      else if (_mesa_is_program(ctx, shader))
         err = GL_INVALID_OPERATION;
      else
         err = GL_INVALID_VALUE;
      _mesa_error(ctx, err, "glDetachProgram(shader)");
      return;
   }
}


static GLint
sizeof_glsl_type(GLenum type)
{
   switch (type) {
   case GL_FLOAT:
   case GL_INT:
   case GL_BOOL:
   case GL_SAMPLER_1D:
   case GL_SAMPLER_2D:
   case GL_SAMPLER_3D:
   case GL_SAMPLER_CUBE:
   case GL_SAMPLER_1D_SHADOW:
   case GL_SAMPLER_2D_SHADOW:
   case GL_SAMPLER_2D_RECT_ARB:
   case GL_SAMPLER_2D_RECT_SHADOW_ARB:
   case GL_SAMPLER_1D_ARRAY_EXT:
   case GL_SAMPLER_2D_ARRAY_EXT:
   case GL_SAMPLER_1D_ARRAY_SHADOW_EXT:
   case GL_SAMPLER_2D_ARRAY_SHADOW_EXT:
   case GL_SAMPLER_CUBE_SHADOW_EXT:
      return 1;
   case GL_FLOAT_VEC2:
   case GL_INT_VEC2:
   case GL_BOOL_VEC2:
      return 2;
   case GL_FLOAT_VEC3:
   case GL_INT_VEC3:
   case GL_BOOL_VEC3:
      return 3;
   case GL_FLOAT_VEC4:
   case GL_INT_VEC4:
   case GL_BOOL_VEC4:
      return 4;
   case GL_FLOAT_MAT2:
   case GL_FLOAT_MAT2x3:
   case GL_FLOAT_MAT2x4:
      return 8; /* two float[4] vectors */
   case GL_FLOAT_MAT3:
   case GL_FLOAT_MAT3x2:
   case GL_FLOAT_MAT3x4:
      return 12; /* three float[4] vectors */
   case GL_FLOAT_MAT4:
   case GL_FLOAT_MAT4x2:
   case GL_FLOAT_MAT4x3:
      return 16;  /* four float[4] vectors */
   default:
      _mesa_problem(NULL, "Invalid type in sizeof_glsl_type()");
      return 1;
   }
}


static GLboolean
is_boolean_type(GLenum type)
{
   switch (type) {
   case GL_BOOL:
   case GL_BOOL_VEC2:
   case GL_BOOL_VEC3:
   case GL_BOOL_VEC4:
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
}


static GLboolean
is_integer_type(GLenum type)
{
   switch (type) {
   case GL_INT:
   case GL_INT_VEC2:
   case GL_INT_VEC3:
   case GL_INT_VEC4:
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
}


static GLboolean
is_sampler_type(GLenum type)
{
   switch (type) {
   case GL_SAMPLER_1D:
   case GL_SAMPLER_2D:
   case GL_SAMPLER_3D:
   case GL_SAMPLER_CUBE:
   case GL_SAMPLER_1D_SHADOW:
   case GL_SAMPLER_2D_SHADOW:
   case GL_SAMPLER_2D_RECT_ARB:
   case GL_SAMPLER_2D_RECT_SHADOW_ARB:
   case GL_SAMPLER_1D_ARRAY_EXT:
   case GL_SAMPLER_2D_ARRAY_EXT:
   case GL_SAMPLER_1D_ARRAY_SHADOW_EXT:
   case GL_SAMPLER_2D_ARRAY_SHADOW_EXT:
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
}


static void
_mesa_get_active_attrib(GLcontext *ctx, GLuint program, GLuint index,
                        GLsizei maxLength, GLsizei *length, GLint *size,
                        GLenum *type, GLchar *nameOut)
{
   const struct gl_program_parameter_list *attribs = NULL;
   struct gl_shader_program *shProg;

   shProg = _mesa_lookup_shader_program_err(ctx, program, "glGetActiveAttrib");
   if (!shProg)
      return;

   if (shProg->VertexProgram)
      attribs = shProg->VertexProgram->Base.Attributes;

   if (!attribs || index >= attribs->NumParameters) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetActiveAttrib(index)");
      return;
   }

   copy_string(nameOut, maxLength, length, attribs->Parameters[index].Name);

   if (size)
      *size = attribs->Parameters[index].Size
         / sizeof_glsl_type(attribs->Parameters[index].DataType);

   if (type)
      *type = attribs->Parameters[index].DataType;
}


static struct gl_program_parameter *
get_uniform_parameter(const struct gl_shader_program *shProg, GLuint index)
{
   const struct gl_program *prog = NULL;
   GLint progPos;

   progPos = shProg->Uniforms->Uniforms[index].VertPos;
   if (progPos >= 0) {
      prog = &shProg->VertexProgram->Base;
   }
   else {
      progPos = shProg->Uniforms->Uniforms[index].FragPos;
      if (progPos >= 0) {
         prog = &shProg->FragmentProgram->Base;
      }
   }

   if (!prog || progPos < 0)
      return NULL; /* should never happen */

   return &prog->Parameters->Parameters[progPos];
}


/**
 * Called via ctx->Driver.GetActiveUniform().
 */
static void
_mesa_get_active_uniform(GLcontext *ctx, GLuint program, GLuint index,
                         GLsizei maxLength, GLsizei *length, GLint *size,
                         GLenum *type, GLchar *nameOut)
{
   const struct gl_shader_program *shProg;
   const struct gl_program *prog = NULL;
   const struct gl_program_parameter *param;
   GLint progPos;

   shProg = _mesa_lookup_shader_program_err(ctx, program, "glGetActiveUniform");
   if (!shProg)
      return;

   if (!shProg->Uniforms || index >= shProg->Uniforms->NumUniforms) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetActiveUniform(index)");
      return;
   }

   progPos = shProg->Uniforms->Uniforms[index].VertPos;
   if (progPos >= 0) {
      prog = &shProg->VertexProgram->Base;
   }
   else {
      progPos = shProg->Uniforms->Uniforms[index].FragPos;
      if (progPos >= 0) {
         prog = &shProg->FragmentProgram->Base;
      }
   }

   if (!prog || progPos < 0)
      return; /* should never happen */

   ASSERT(progPos < prog->Parameters->NumParameters);
   param = &prog->Parameters->Parameters[progPos];

   if (nameOut) {
      copy_string(nameOut, maxLength, length, param->Name);
   }

   if (size) {
      GLint typeSize = sizeof_glsl_type(param->DataType);
      if ((GLint) param->Size > typeSize) {
         /* This is an array.
          * Array elements are placed on vector[4] boundaries so they're
          * a multiple of four floats.  We round typeSize up to next multiple
          * of four to get the right size below.
          */
         typeSize = (typeSize + 3) & ~3;
      }
      /* Note that the returned size is in units of the <type>, not bytes */
      *size = param->Size / typeSize;
   }

   if (type) {
      *type = param->DataType;
   }
}


/**
 * Called via ctx->Driver.GetAttachedShaders().
 */
static void
_mesa_get_attached_shaders(GLcontext *ctx, GLuint program, GLsizei maxCount,
                           GLsizei *count, GLuint *obj)
{
   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program, "glGetAttachedShaders");
   if (shProg) {
      GLuint i;
      for (i = 0; i < (GLuint) maxCount && i < shProg->NumShaders; i++) {
         obj[i] = shProg->Shaders[i]->Name;
      }
      if (count)
         *count = i;
   }
}


static GLuint
_mesa_get_handle(GLcontext *ctx, GLenum pname)
{
   GLint handle = 0;
   
   if (pname == GL_PROGRAM_OBJECT_ARB) {
      CALL_GetIntegerv(ctx->Exec, (GL_CURRENT_PROGRAM, &handle));
   } else {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetHandleARB");
   }

   return handle;
}


static void
_mesa_get_programiv(GLcontext *ctx, GLuint program,
                    GLenum pname, GLint *params)
{
   const struct gl_program_parameter_list *attribs;
   struct gl_shader_program *shProg
      = _mesa_lookup_shader_program(ctx, program);

   if (!shProg) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetProgramiv(program)");
      return;
   }

   if (shProg->VertexProgram)
      attribs = shProg->VertexProgram->Base.Attributes;
   else
      attribs = NULL;

   switch (pname) {
   case GL_DELETE_STATUS:
      *params = shProg->DeletePending;
      break; 
   case GL_LINK_STATUS:
      *params = shProg->LinkStatus;
      break;
   case GL_VALIDATE_STATUS:
      *params = shProg->Validated;
      break;
   case GL_INFO_LOG_LENGTH:
      *params = shProg->InfoLog ? strlen(shProg->InfoLog) + 1 : 0;
      break;
   case GL_ATTACHED_SHADERS:
      *params = shProg->NumShaders;
      break;
   case GL_ACTIVE_ATTRIBUTES:
      *params = attribs ? attribs->NumParameters : 0;
      break;
   case GL_ACTIVE_ATTRIBUTE_MAX_LENGTH:
      *params = _mesa_longest_parameter_name(attribs, PROGRAM_INPUT) + 1;
      break;
   case GL_ACTIVE_UNIFORMS:
      *params = shProg->Uniforms ? shProg->Uniforms->NumUniforms : 0;
      break;
   case GL_ACTIVE_UNIFORM_MAX_LENGTH:
      *params = _mesa_longest_uniform_name(shProg->Uniforms);
      if (*params > 0)
         (*params)++;  /* add one for terminating zero */
      break;
   case GL_PROGRAM_BINARY_LENGTH_OES:
      *params = 0;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetProgramiv(pname)");
      return;
   }
}


static void
_mesa_get_shaderiv(GLcontext *ctx, GLuint name, GLenum pname, GLint *params)
{
   struct gl_shader *shader = _mesa_lookup_shader_err(ctx, name, "glGetShaderiv");

   if (!shader) {
      return;
   }

   switch (pname) {
   case GL_SHADER_TYPE:
      *params = shader->Type;
      break;
   case GL_DELETE_STATUS:
      *params = shader->DeletePending;
      break;
   case GL_COMPILE_STATUS:
      *params = shader->CompileStatus;
      break;
   case GL_INFO_LOG_LENGTH:
      *params = shader->InfoLog ? strlen(shader->InfoLog) + 1 : 0;
      break;
   case GL_SHADER_SOURCE_LENGTH:
      *params = shader->Source ? strlen((char *) shader->Source) + 1 : 0;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetShaderiv(pname)");
      return;
   }
}


static void
_mesa_get_program_info_log(GLcontext *ctx, GLuint program, GLsizei bufSize,
                           GLsizei *length, GLchar *infoLog)
{
   struct gl_shader_program *shProg
      = _mesa_lookup_shader_program(ctx, program);
   if (!shProg) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetProgramInfoLog(program)");
      return;
   }
   copy_string(infoLog, bufSize, length, shProg->InfoLog);
}


static void
_mesa_get_shader_info_log(GLcontext *ctx, GLuint shader, GLsizei bufSize,
                          GLsizei *length, GLchar *infoLog)
{
   struct gl_shader *sh = _mesa_lookup_shader(ctx, shader);
   if (!sh) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetShaderInfoLog(shader)");
      return;
   }
   copy_string(infoLog, bufSize, length, sh->InfoLog);
}


/**
 * Called via ctx->Driver.GetShaderSource().
 */
static void
_mesa_get_shader_source(GLcontext *ctx, GLuint shader, GLsizei maxLength,
                        GLsizei *length, GLchar *sourceOut)
{
   struct gl_shader *sh;
   sh = _mesa_lookup_shader_err(ctx, shader, "glGetShaderSource");
   if (!sh) {
      return;
   }
   copy_string(sourceOut, maxLength, length, sh->Source);
}


static void
get_matrix_dims(GLenum type, GLint *rows, GLint *cols)
{
   switch (type) {
   case GL_FLOAT_MAT2:
      *rows = *cols = 2;
      break;
   case GL_FLOAT_MAT2x3:
      *rows = 3;
      *cols = 2;
      break;
   case GL_FLOAT_MAT2x4:
      *rows = 4;
      *cols = 2;
      break;
   case GL_FLOAT_MAT3:
      *rows = 3;
      *cols = 3;
      break;
   case GL_FLOAT_MAT3x2:
      *rows = 2;
      *cols = 3;
      break;
   case GL_FLOAT_MAT3x4:
      *rows = 4;
      *cols = 3;
      break;
   case GL_FLOAT_MAT4:
      *rows = 4;
      *cols = 4;
      break;
   case GL_FLOAT_MAT4x2:
      *rows = 2;
      *cols = 4;
      break;
   case GL_FLOAT_MAT4x3:
      *rows = 3;
      *cols = 4;
      break;
   default:
      *rows = *cols = 0;
   }
}


/**
 * Determine the number of rows and columns occupied by a uniform
 * according to its datatype.  For non-matrix types (such as GL_FLOAT_VEC4),
 * the number of rows = 1 and cols = number of elements in the vector.
 */
static void
get_uniform_rows_cols(const struct gl_program_parameter *p,
                      GLint *rows, GLint *cols)
{
   get_matrix_dims(p->DataType, rows, cols);
   if (*rows == 0 && *cols == 0) {
      /* not a matrix type, probably a float or vector */
      if (p->Size <= 4) {
         *rows = 1;
         *cols = p->Size;
      }
      else {
         *rows = p->Size / 4 + 1;
         if (p->Size % 4 == 0)
            *cols = 4;
         else
            *cols = p->Size % 4;
      }
   }
}


/**
 * Helper for get_uniform[fi]v() functions.
 * Given a shader program name and uniform location, return a pointer
 * to the shader program and return the program parameter position.
 */
static void
lookup_uniform_parameter(GLcontext *ctx, GLuint program, GLint location,
                         struct gl_program **progOut, GLint *paramPosOut)
{
   struct gl_shader_program *shProg
      = _mesa_lookup_shader_program_err(ctx, program, "glGetUniform[if]v");
   struct gl_program *prog = NULL;
   GLint progPos = -1;

   /* if shProg is NULL, we'll have already recorded an error */

   if (shProg) {
      if (!shProg->Uniforms ||
          location < 0 ||
          location >= (GLint) shProg->Uniforms->NumUniforms) {
         _mesa_error(ctx, GL_INVALID_OPERATION,  "glGetUniformfv(location)");
      }
      else {
         /* OK, find the gl_program and program parameter location */
         progPos = shProg->Uniforms->Uniforms[location].VertPos;
         if (progPos >= 0) {
            prog = &shProg->VertexProgram->Base;
         }
         else {
            progPos = shProg->Uniforms->Uniforms[location].FragPos;
            if (progPos >= 0) {
               prog = &shProg->FragmentProgram->Base;
            }
         }
      }
   }

   *progOut = prog;
   *paramPosOut = progPos;
}


/**
 * GLGL uniform arrays and structs require special handling.
 *
 * The GL_ARB_shader_objects spec says that if you use
 * glGetUniformLocation to get the location of an array, you CANNOT
 * access other elements of the array by adding an offset to the
 * returned location.  For example, you must call
 * glGetUniformLocation("foo[16]") if you want to set the 16th element
 * of the array with glUniform().
 *
 * HOWEVER, some other OpenGL drivers allow accessing array elements
 * by adding an offset to the returned array location.  And some apps
 * seem to depend on that behaviour.
 *
 * Mesa's gl_uniform_list doesn't directly support this since each
 * entry in the list describes one uniform variable, not one uniform
 * element.  We could insert dummy entries in the list for each array
 * element after [0] but that causes complications elsewhere.
 *
 * We solve this problem by encoding two values in the location that's
 * returned by glGetUniformLocation():
 *  a) index into gl_uniform_list::Uniforms[] for the uniform
 *  b) an array/field offset (0 for simple types)
 *
 * These two values are encoded in the high and low halves of a GLint.
 * By putting the uniform number in the high part and the offset in the
 * low part, we can support the unofficial ability to index into arrays
 * by adding offsets to the location value.
 */
static void
merge_location_offset(GLint *location, GLint offset)
{
   *location = (*location << 16) | offset;
}


/**
 * Seperate the uniform location and parameter offset.  See above.
 */
static void
split_location_offset(GLint *location, GLint *offset)
{
   *offset = *location & 0xffff;
   *location = *location >> 16;
}



/**
 * Called via ctx->Driver.GetUniformfv().
 */
static void
_mesa_get_uniformfv(GLcontext *ctx, GLuint program, GLint location,
                    GLfloat *params)
{
   struct gl_program *prog;
   GLint paramPos;
   GLint offset;

   split_location_offset(&location, &offset);

   lookup_uniform_parameter(ctx, program, location, &prog, &paramPos);

   if (prog) {
      const struct gl_program_parameter *p =
         &prog->Parameters->Parameters[paramPos];
      GLint rows, cols, i, j, k;

      get_uniform_rows_cols(p, &rows, &cols);

      k = 0;
      for (i = 0; i < rows; i++) {
         for (j = 0; j < cols; j++ ) {
            params[k++] = prog->Parameters->ParameterValues[paramPos+i][j];
         }
      }
   }
}


/**
 * Called via ctx->Driver.GetUniformiv().
 * \sa _mesa_get_uniformfv, only difference is a cast.
 */
static void
_mesa_get_uniformiv(GLcontext *ctx, GLuint program, GLint location,
                    GLint *params)
{
   struct gl_program *prog;
   GLint paramPos;
   GLint offset;

   split_location_offset(&location, &offset);
 
   lookup_uniform_parameter(ctx, program, location, &prog, &paramPos);

   if (prog) {
      const struct gl_program_parameter *p =
         &prog->Parameters->Parameters[paramPos];
      GLint rows, cols, i, j, k;

      get_uniform_rows_cols(p, &rows, &cols);

      k = 0;
      for (i = 0; i < rows; i++) {
         for (j = 0; j < cols; j++ ) {
            params[k++] = (GLint) prog->Parameters->ParameterValues[paramPos+i][j];
         }
      }
   }
}


/**
 * Called via ctx->Driver.GetUniformLocation().
 *
 * The return value will encode two values, the uniform location and an
 * offset (used for arrays, structs).
 */
static GLint
_mesa_get_uniform_location(GLcontext *ctx, GLuint program, const GLchar *name)
{
   GLint offset = 0, location = -1;

   struct gl_shader_program *shProg =
      _mesa_lookup_shader_program_err(ctx, program, "glGetUniformLocation");

   if (!shProg)
      return -1;

   if (shProg->LinkStatus == GL_FALSE) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetUniformfv(program)");
      return -1;
   }

   /* XXX we should return -1 if the uniform was declared, but not
    * actually used.
    */

   /* XXX we need to be able to parse uniform names for structs and arrays
    * such as:
    *   mymatrix[1]
    *   mystruct.field1
    */

   {
      /* handle 1-dimension arrays here... */
      char *c = strchr(name, '[');
      if (c) {
         /* truncate name at [ */
         const GLint len = c - name;
         GLchar *newName = malloc(len + 1);
         if (!newName)
            return -1; /* out of mem */
         memcpy(newName, name, len);
         newName[len] = 0;

         location = _mesa_lookup_uniform(shProg->Uniforms, newName);
         if (location >= 0) {
            const GLint element = atoi(c + 1);
            if (element > 0) {
               /* get type of the uniform array element */
               struct gl_program_parameter *p;
               p = get_uniform_parameter(shProg, location);
               if (p) {
                  GLint rows, cols;
                  get_matrix_dims(p->DataType, &rows, &cols);
                  if (rows < 1)
                     rows = 1;
                  offset = element * rows;
               }
            }
         }

         free(newName);
      }
   }

   if (location < 0) {
      location = _mesa_lookup_uniform(shProg->Uniforms, name);
   }

   if (location >= 0) {
      merge_location_offset(&location, offset);
   }

   return location;
}



/**
 * Called via ctx->Driver.ShaderSource()
 */
static void
_mesa_shader_source(GLcontext *ctx, GLuint shader, const GLchar *source)
{
   struct gl_shader *sh;

   sh = _mesa_lookup_shader_err(ctx, shader, "glShaderSource");
   if (!sh)
      return;

   /* free old shader source string and install new one */
   if (sh->Source) {
      free((void *) sh->Source);
   }
   sh->Source = source;
   sh->CompileStatus = GL_FALSE;
#ifdef DEBUG
   sh->SourceChecksum = _mesa_str_checksum(sh->Source);
#endif
}


/**
 * Called via ctx->Driver.CompileShader()
 */
static void
_mesa_compile_shader(GLcontext *ctx, GLuint shaderObj)
{
   struct gl_shader *sh;

   sh = _mesa_lookup_shader_err(ctx, shaderObj, "glCompileShader");
   if (!sh)
      return;

   /* set default pragma state for shader */
   sh->Pragmas = ctx->Shader.DefaultPragmas;

   /* this call will set the sh->CompileStatus field to indicate if
    * compilation was successful.
    */
   (void) _slang_compile(ctx, sh);
}


/**
 * Called via ctx->Driver.LinkProgram()
 */
static void
_mesa_link_program(GLcontext *ctx, GLuint program)
{
   struct gl_shader_program *shProg;

   shProg = _mesa_lookup_shader_program_err(ctx, program, "glLinkProgram");
   if (!shProg)
      return;

   FLUSH_VERTICES(ctx, _NEW_PROGRAM);

   _slang_link(ctx, program, shProg);

   /* debug code */
   if (0) {
      GLuint i;

      printf("Link %u shaders in program %u: %s\n",
                   shProg->NumShaders, shProg->Name,
                   shProg->LinkStatus ? "Success" : "Failed");

      for (i = 0; i < shProg->NumShaders; i++) {
         printf(" shader %u, type 0x%x\n",
                      shProg->Shaders[i]->Name,
                      shProg->Shaders[i]->Type);
      }
   }
}


/**
 * Print basic shader info (for debug).
 */
static void
print_shader_info(const struct gl_shader_program *shProg)
{
   GLuint i;

   printf("Mesa: glUseProgram(%u)\n", shProg->Name);
   for (i = 0; i < shProg->NumShaders; i++) {
      const char *s;
      switch (shProg->Shaders[i]->Type) {
      case GL_VERTEX_SHADER:
         s = "vertex";
         break;
      case GL_FRAGMENT_SHADER:
         s = "fragment";
         break;
      case GL_GEOMETRY_SHADER:
         s = "geometry";
         break;
      default:
         s = "";
      }
      printf("  %s shader %u, checksum %u\n", s, 
	     shProg->Shaders[i]->Name,
	     shProg->Shaders[i]->SourceChecksum);
   }
   if (shProg->VertexProgram)
      printf("  vert prog %u\n", shProg->VertexProgram->Base.Id);
   if (shProg->FragmentProgram)
      printf("  frag prog %u\n", shProg->FragmentProgram->Base.Id);
}


/**
 * Called via ctx->Driver.UseProgram()
 */
void
_mesa_use_program(GLcontext *ctx, GLuint program)
{
   struct gl_shader_program *shProg;

   if (ctx->Shader.CurrentProgram &&
       ctx->Shader.CurrentProgram->Name == program) {
      /* no-op */
      return;
   }

   if (program) {
      shProg = _mesa_lookup_shader_program_err(ctx, program, "glUseProgram");
      if (!shProg) {
         return;
      }
      if (!shProg->LinkStatus) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glUseProgram(program %u not linked)", program);
         return;
      }

      /* debug code */
      if (ctx->Shader.Flags & GLSL_USE_PROG) {
         print_shader_info(shProg);
      }
   }
   else {
      shProg = NULL;
   }

   if (ctx->Shader.CurrentProgram != shProg) {
      FLUSH_VERTICES(ctx, _NEW_PROGRAM | _NEW_PROGRAM_CONSTANTS);
      _mesa_reference_shader_program(ctx, &ctx->Shader.CurrentProgram, shProg);
   }
}



/**
 * Update the vertex/fragment program's TexturesUsed array.
 *
 * This needs to be called after glUniform(set sampler var) is called.
 * A call to glUniform(samplerVar, value) causes a sampler to point to a
 * particular texture unit.  We know the sampler's texture target
 * (1D/2D/3D/etc) from compile time but the sampler's texture unit is
 * set by glUniform() calls.
 *
 * So, scan the program->SamplerUnits[] and program->SamplerTargets[]
 * information to update the prog->TexturesUsed[] values.
 * Each value of TexturesUsed[unit] is one of zero, TEXTURE_1D_INDEX,
 * TEXTURE_2D_INDEX, TEXTURE_3D_INDEX, etc.
 * We'll use that info for state validation before rendering.
 */
void
_mesa_update_shader_textures_used(struct gl_program *prog)
{
   GLuint s;

   memset(prog->TexturesUsed, 0, sizeof(prog->TexturesUsed));

   for (s = 0; s < MAX_SAMPLERS; s++) {
      if (prog->SamplersUsed & (1 << s)) {
         GLuint unit = prog->SamplerUnits[s];
         GLuint tgt = prog->SamplerTargets[s];
         assert(unit < MAX_TEXTURE_IMAGE_UNITS);
         assert(tgt < NUM_TEXTURE_TARGETS);
         prog->TexturesUsed[unit] |= (1 << tgt);
      }
   }
}


/**
 * Check if the type given by userType is allowed to set a uniform of the
 * target type.  Generally, equivalence is required, but setting Boolean
 * uniforms can be done with glUniformiv or glUniformfv.
 */
static GLboolean
compatible_types(GLenum userType, GLenum targetType)
{
   if (userType == targetType)
      return GL_TRUE;

   if (targetType == GL_BOOL && (userType == GL_FLOAT || userType == GL_INT))
      return GL_TRUE;

   if (targetType == GL_BOOL_VEC2 && (userType == GL_FLOAT_VEC2 ||
                                      userType == GL_INT_VEC2))
      return GL_TRUE;

   if (targetType == GL_BOOL_VEC3 && (userType == GL_FLOAT_VEC3 ||
                                      userType == GL_INT_VEC3))
      return GL_TRUE;

   if (targetType == GL_BOOL_VEC4 && (userType == GL_FLOAT_VEC4 ||
                                      userType == GL_INT_VEC4))
      return GL_TRUE;

   if (is_sampler_type(targetType) && userType == GL_INT)
      return GL_TRUE;

   return GL_FALSE;
}


/**
 * Set the value of a program's uniform variable.
 * \param program  the program whose uniform to update
 * \param index  the index of the program parameter for the uniform
 * \param offset  additional parameter slot offset (for arrays)
 * \param type  the incoming datatype of 'values'
 * \param count  the number of uniforms to set
 * \param elems  number of elements per uniform (1, 2, 3 or 4)
 * \param values  the new values, of datatype 'type'
 */
static void
set_program_uniform(GLcontext *ctx, struct gl_program *program,
                    GLint index, GLint offset,
                    GLenum type, GLsizei count, GLint elems,
                    const void *values)
{
   const struct gl_program_parameter *param =
      &program->Parameters->Parameters[index];

   assert(offset >= 0);
   assert(elems >= 1);
   assert(elems <= 4);

   if (!compatible_types(type, param->DataType)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glUniform(type mismatch)");
      return;
   }

   if (index + offset > (GLint) program->Parameters->Size) {
      /* out of bounds! */
      return;
   }

   if (param->Type == PROGRAM_SAMPLER) {
      /* This controls which texture unit which is used by a sampler */
      GLboolean changed = GL_FALSE;
      GLint i;

      /* this should have been caught by the compatible_types() check */
      ASSERT(type == GL_INT);

      /* loop over number of samplers to change */
      for (i = 0; i < count; i++) {
         GLuint sampler =
            (GLuint) program->Parameters->ParameterValues[index + offset + i][0];
         GLuint texUnit = ((GLuint *) values)[i];

         /* check that the sampler (tex unit index) is legal */
         if (texUnit >= ctx->Const.MaxTextureImageUnits) {
            _mesa_error(ctx, GL_INVALID_VALUE,
                        "glUniform1(invalid sampler/tex unit index)");
            return;
         }

         /* This maps a sampler to a texture unit: */
         if (sampler < MAX_SAMPLERS) {
#if 0
            printf("Set program %p sampler %d '%s' to unit %u\n",
		   program, sampler, param->Name, texUnit);
#endif
            if (program->SamplerUnits[sampler] != texUnit) {
               program->SamplerUnits[sampler] = texUnit;
               changed = GL_TRUE;
            }
         }
      }

      if (changed) {
         /* When a sampler's value changes it usually requires rewriting
          * a GPU program's TEX instructions since there may not be a
          * sampler->texture lookup table.  We signal this with the
          * ProgramStringNotify() callback.
          */
         FLUSH_VERTICES(ctx, _NEW_TEXTURE | _NEW_PROGRAM);
         _mesa_update_shader_textures_used(program);
         /* Do we need to care about the return value here?
          * This should not be the first time the driver was notified of
          * this program.
          */
         (void) ctx->Driver.ProgramStringNotify(ctx, program->Target, program);
      }
   }
   else {
      /* ordinary uniform variable */
      const GLboolean isUniformBool = is_boolean_type(param->DataType);
      const GLboolean areIntValues = is_integer_type(type);
      const GLint slots = (param->Size + 3) / 4;
      const GLint typeSize = sizeof_glsl_type(param->DataType);
      GLsizei k, i;

      if ((GLint) param->Size > typeSize) {
         /* an array */
         /* we'll ignore extra data below */
      }
      else {
         /* non-array: count must be at most one; count == 0 is handled by the loop below */
         if (count > 1) {
            _mesa_error(ctx, GL_INVALID_OPERATION,
                        "glUniform(uniform is not an array)");
            return;
         }
      }

      /* loop over number of array elements */
      for (k = 0; k < count; k++) {
         GLfloat *uniformVal;

         if (offset + k >= slots) {
            /* Extra array data is ignored */
            break;
         }

         /* uniformVal (the destination) is always float[4] */
         uniformVal = program->Parameters->ParameterValues[index + offset + k];

         if (areIntValues) {
            /* convert user's ints to floats */
            const GLint *iValues = ((const GLint *) values) + k * elems;
            for (i = 0; i < elems; i++) {
               uniformVal[i] = (GLfloat) iValues[i];
            }
         }
         else {
            const GLfloat *fValues = ((const GLfloat *) values) + k * elems;
            for (i = 0; i < elems; i++) {
               uniformVal[i] = fValues[i];
            }
         }

         /* if the uniform is bool-valued, convert to 1.0 or 0.0 */
         if (isUniformBool) {
            for (i = 0; i < elems; i++) {
               uniformVal[i] = uniformVal[i] ? 1.0f : 0.0f;
            }
         }
      }
   }
}


/**
 * Called via ctx->Driver.Uniform().
 */
static void
_mesa_uniform(GLcontext *ctx, GLint location, GLsizei count,
              const GLvoid *values, GLenum type)
{
   struct gl_shader_program *shProg = ctx->Shader.CurrentProgram;
   struct gl_uniform *uniform;
   GLint elems, offset;
   GLenum basicType;

   if (!shProg || !shProg->LinkStatus) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glUniform(program not linked)");
      return;
   }

   if (location == -1)
      return;   /* The standard specifies this as a no-op */

   if (location < -1) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glUniform(location)");
      return;
   }

   split_location_offset(&location, &offset);

   if (location < 0 || location >= (GLint) shProg->Uniforms->NumUniforms) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glUniform(location)");
      return;
   }

   if (count < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glUniform(count < 0)");
      return;
   }

   switch (type) {
   case GL_FLOAT:
      basicType = GL_FLOAT;
      elems = 1;
      break;
   case GL_INT:
      basicType = GL_INT;
      elems = 1;
      break;
   case GL_FLOAT_VEC2:
      basicType = GL_FLOAT;
      elems = 2;
      break;
   case GL_INT_VEC2:
      basicType = GL_INT;
      elems = 2;
      break;
   case GL_FLOAT_VEC3:
      basicType = GL_FLOAT;
      elems = 3;
      break;
   case GL_INT_VEC3:
      basicType = GL_INT;
      elems = 3;
      break;
   case GL_FLOAT_VEC4:
      basicType = GL_FLOAT;
      elems = 4;
      break;
   case GL_INT_VEC4:
      basicType = GL_INT;
      elems = 4;
      break;
   default:
      _mesa_problem(ctx, "Invalid type in _mesa_uniform");
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_PROGRAM_CONSTANTS);

   uniform = &shProg->Uniforms->Uniforms[location];

   if (ctx->Shader.Flags & GLSL_UNIFORMS) {
      GLint i;
      printf("Mesa: set program %u uniform %s (loc %d) to: ",
	     shProg->Name, uniform->Name, location);
      if (basicType == GL_INT) {
         const GLint *v = (const GLint *) values;
         for (i = 0; i < count * elems; i++) {
            printf("%d ", v[i]);
         }
      }
      else {
         const GLfloat *v = (const GLfloat *) values;
         for (i = 0; i < count * elems; i++) {
            printf("%g ", v[i]);
         }
      }
      printf("\n");
   }

   /* A uniform var may be used by both a vertex shader and a fragment
    * shader.  We may need to update one or both shader's uniform here:
    */
   if (shProg->VertexProgram) {
      /* convert uniform location to program parameter index */
      GLint index = uniform->VertPos;
      if (index >= 0) {
         set_program_uniform(ctx, &shProg->VertexProgram->Base,
                             index, offset, type, count, elems, values);
      }
   }

   if (shProg->FragmentProgram) {
      /* convert uniform location to program parameter index */
      GLint index = uniform->FragPos;
      if (index >= 0) {
         set_program_uniform(ctx, &shProg->FragmentProgram->Base,
                             index, offset, type, count, elems, values);
      }
   }

   uniform->Initialized = GL_TRUE;
}


/**
 * Set a matrix-valued program parameter.
 */
static void
set_program_uniform_matrix(GLcontext *ctx, struct gl_program *program,
                           GLuint index, GLuint offset,
                           GLuint count, GLuint rows, GLuint cols,
                           GLboolean transpose, const GLfloat *values)
{
   GLuint mat, row, col;
   GLuint src = 0;
   const struct gl_program_parameter * param = &program->Parameters->Parameters[index];
   const GLuint slots = (param->Size + 3) / 4;
   const GLint typeSize = sizeof_glsl_type(param->DataType);
   GLint nr, nc;

   /* check that the number of rows, columns is correct */
   get_matrix_dims(param->DataType, &nr, &nc);
   if (rows != nr || cols != nc) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glUniformMatrix(matrix size mismatch)");
      return;
   }

   if ((GLint) param->Size <= typeSize) {
      /* non-array: count must be at most one; count == 0 is handled by the loop below */
      if (count > 1) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glUniformMatrix(uniform is not an array)");
         return;
      }
   }

   /*
    * Note: the _columns_ of a matrix are stored in program registers, not
    * the rows.  So, the loops below look a little funny.
    * XXX could optimize this a bit...
    */

   /* loop over matrices */
   for (mat = 0; mat < count; mat++) {

      /* each matrix: */
      for (col = 0; col < cols; col++) {
         GLfloat *v;
         if (offset >= slots) {
            /* Ignore writes beyond the end of (the used part of) an array */
            return;
         }
         v = program->Parameters->ParameterValues[index + offset];
         for (row = 0; row < rows; row++) {
            if (transpose) {
               v[row] = values[src + row * cols + col];
            }
            else {
               v[row] = values[src + col * rows + row];
            }
         }

         offset++;
      }

      src += rows * cols;  /* next matrix */
   }
}


/**
 * Called by ctx->Driver.UniformMatrix().
 * Note: cols=2, rows=4  ==>  array[2] of vec4
 */
static void
_mesa_uniform_matrix(GLcontext *ctx, GLint cols, GLint rows,
                     GLint location, GLsizei count,
                     GLboolean transpose, const GLfloat *values)
{
   struct gl_shader_program *shProg = ctx->Shader.CurrentProgram;
   struct gl_uniform *uniform;
   GLint offset;

   if (!shProg || !shProg->LinkStatus) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
         "glUniformMatrix(program not linked)");
      return;
   }

   if (location == -1)
      return;   /* The standard specifies this as a no-op */

   if (location < -1) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glUniformMatrix(location)");
      return;
   }

   split_location_offset(&location, &offset);

   if (location < 0 || location >= (GLint) shProg->Uniforms->NumUniforms) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glUniformMatrix(location)");
      return;
   }
   if (values == NULL) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glUniformMatrix");
      return;
   }

   FLUSH_VERTICES(ctx, _NEW_PROGRAM_CONSTANTS);

   uniform = &shProg->Uniforms->Uniforms[location];

   if (shProg->VertexProgram) {
      /* convert uniform location to program parameter index */
      GLint index = uniform->VertPos;
      if (index >= 0) {
         set_program_uniform_matrix(ctx, &shProg->VertexProgram->Base,
                                    index, offset,
                                    count, rows, cols, transpose, values);
      }
   }

   if (shProg->FragmentProgram) {
      /* convert uniform location to program parameter index */
      GLint index = uniform->FragPos;
      if (index >= 0) {
         set_program_uniform_matrix(ctx, &shProg->FragmentProgram->Base,
                                    index, offset,
                                    count, rows, cols, transpose, values);
      }
   }

   uniform->Initialized = GL_TRUE;
}


/**
 * Validate a program's samplers.
 * Specifically, check that there aren't two samplers of different types
 * pointing to the same texture unit.
 * \return GL_TRUE if valid, GL_FALSE if invalid
 */
static GLboolean
validate_samplers(GLcontext *ctx, const struct gl_program *prog, char *errMsg)
{
   static const char *targetName[] = {
      "TEXTURE_2D_ARRAY",
      "TEXTURE_1D_ARRAY",
      "TEXTURE_CUBE",
      "TEXTURE_3D",
      "TEXTURE_RECT",
      "TEXTURE_2D",
      "TEXTURE_1D",
   };
   GLint targetUsed[MAX_TEXTURE_IMAGE_UNITS];
   GLbitfield samplersUsed = prog->SamplersUsed;
   GLuint i;

   assert(Elements(targetName) == NUM_TEXTURE_TARGETS);

   if (samplersUsed == 0x0)
      return GL_TRUE;

   for (i = 0; i < Elements(targetUsed); i++)
      targetUsed[i] = -1;

   /* walk over bits which are set in 'samplers' */
   while (samplersUsed) {
      GLuint unit;
      gl_texture_index target;
      GLint sampler = _mesa_ffs(samplersUsed) - 1;
      assert(sampler >= 0);
      assert(sampler < MAX_TEXTURE_IMAGE_UNITS);
      unit = prog->SamplerUnits[sampler];
      target = prog->SamplerTargets[sampler];
      if (targetUsed[unit] != -1 && targetUsed[unit] != target) {
         _mesa_snprintf(errMsg, 100,
		  "Texture unit %d is accessed both as %s and %s",
		  unit, targetName[targetUsed[unit]], targetName[target]);
         return GL_FALSE;
      }
      targetUsed[unit] = target;
      samplersUsed ^= (1 << sampler);
   }

   return GL_TRUE;
}


/**
 * Do validation of the given shader program.
 * \param errMsg  returns error message if validation fails.
 * \return GL_TRUE if valid, GL_FALSE if invalid (and set errMsg)
 */
GLboolean
_mesa_validate_shader_program(GLcontext *ctx,
                              const struct gl_shader_program *shProg,
                              char *errMsg)
{
   const struct gl_vertex_program *vp = shProg->VertexProgram;
   const struct gl_fragment_program *fp = shProg->FragmentProgram;

   if (!shProg->LinkStatus) {
      return GL_FALSE;
   }

   /* From the GL spec, a program is invalid if any of these are true:

     any two active samplers in the current program object are of
     different types, but refer to the same texture image unit,

     any active sampler in the current program object refers to a texture
     image unit where fixed-function fragment processing accesses a
     texture target that does not match the sampler type, or 

     the sum of the number of active samplers in the program and the
     number of texture image units enabled for fixed-function fragment
     processing exceeds the combined limit on the total number of texture
     image units allowed.
   */


   /*
    * Check: any two active samplers in the current program object are of
    * different types, but refer to the same texture image unit,
    */
   if (vp && !validate_samplers(ctx, &vp->Base, errMsg)) {
      return GL_FALSE;
   }
   if (fp && !validate_samplers(ctx, &fp->Base, errMsg)) {
      return GL_FALSE;
   }

   return GL_TRUE;
}


/**
 * Called via glValidateProgram()
 */
static void
_mesa_validate_program(GLcontext *ctx, GLuint program)
{
   struct gl_shader_program *shProg;
   char errMsg[100];

   shProg = _mesa_lookup_shader_program_err(ctx, program, "glValidateProgram");
   if (!shProg) {
      return;
   }

   shProg->Validated = _mesa_validate_shader_program(ctx, shProg, errMsg);
   if (!shProg->Validated) {
      /* update info log */
      if (shProg->InfoLog) {
         free(shProg->InfoLog);
      }
      shProg->InfoLog = _mesa_strdup(errMsg);
   }
}


/**
 * Plug in Mesa's GLSL functions into the device driver function table.
 */
void
_mesa_init_glsl_driver_functions(struct dd_function_table *driver)
{
   driver->AttachShader = _mesa_attach_shader;
   driver->BindAttribLocation = _mesa_bind_attrib_location;
   driver->CompileShader = _mesa_compile_shader;
   driver->CreateProgram = _mesa_create_program;
   driver->CreateShader = _mesa_create_shader;
   driver->DeleteProgram2 = _mesa_delete_program2;
   driver->DeleteShader = _mesa_delete_shader;
   driver->DetachShader = _mesa_detach_shader;
   driver->GetActiveAttrib = _mesa_get_active_attrib;
   driver->GetActiveUniform = _mesa_get_active_uniform;
   driver->GetAttachedShaders = _mesa_get_attached_shaders;
   driver->GetAttribLocation = _mesa_get_attrib_location;
   driver->GetHandle = _mesa_get_handle;
   driver->GetProgramiv = _mesa_get_programiv;
   driver->GetProgramInfoLog = _mesa_get_program_info_log;
   driver->GetShaderiv = _mesa_get_shaderiv;
   driver->GetShaderInfoLog = _mesa_get_shader_info_log;
   driver->GetShaderSource = _mesa_get_shader_source;
   driver->GetUniformfv = _mesa_get_uniformfv;
   driver->GetUniformiv = _mesa_get_uniformiv;
   driver->GetUniformLocation = _mesa_get_uniform_location;
   driver->IsProgram = _mesa_is_program;
   driver->IsShader = _mesa_is_shader;
   driver->LinkProgram = _mesa_link_program;
   driver->ShaderSource = _mesa_shader_source;
   driver->Uniform = _mesa_uniform;
   driver->UniformMatrix = _mesa_uniform_matrix;
   driver->UseProgram = _mesa_use_program;
   driver->ValidateProgram = _mesa_validate_program;
}
@


1.7
log
@Update to Mesa 7.8.2. Tested by johan@@. Thanks.
@
text
@@


1.6
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d1263 48
d1319 3
d1352 1
d1354 2
a1371 25
}


/**
 * The value returned by GetUniformLocation actually encodes two things:
 * 1. the index into the prog->Uniforms[] array for the uniform
 * 2. an offset in the prog->ParameterValues[] array for specifying array
 *    elements or structure fields.
 * This function merges those two values.
 */
static void
merge_location_offset(GLint *location, GLint offset)
{
   *location = *location | (offset << 16);
}


/**
 * Seperate the uniform location and parameter offset.  See above.
 */
static void
split_location_offset(GLint *location, GLint *offset)
{
   *offset = (*location >> 16);
   *location = *location & 0xffff;
@


1.5
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d3 1
a3 1
 * Version:  7.5
a41 1
#include "main/macros.h"
a43 1
#include "shader/prog_print.h"
d49 1
a49 6
#include "glapi/dispatch.h"


#ifndef GL_PROGRAM_BINARY_LENGTH_OES
#define GL_PROGRAM_BINARY_LENGTH_OES 0x8741
#endif
d118 1
a118 1
      _mesa_free(shProg->Shaders);
d123 1
a123 1
      _mesa_free(shProg->InfoLog);
d137 1
a137 1
   _mesa_free(shProg);
d265 1
a265 1
      _mesa_free((void *) sh->Source);
d267 1
a267 1
      _mesa_free(sh->InfoLog);
d269 1
a269 1
   _mesa_free(sh);
d367 31
d409 2
a410 1
   ctx->Shader.EmitCondCodes = GL_TRUE; /* XXX probably want GL_FALSE... */
d412 7
d712 1
a712 1
            _mesa_malloc((n - 1) * sizeof(struct gl_shader *));
d722 1
a722 1
         _mesa_free(shProg->Shaders);
d772 2
d853 2
d896 1
a896 1
   const struct gl_program *prog;
d926 1
a926 1
   const struct gl_program *prog;
d962 1
a962 1
      if (param->Size > typeSize) {
d1195 2
a1196 1
 * according to its datatype.
d1205 11
a1215 5
      *rows = p->Size / 4 + 1;
      if (p->Size % 4 == 0)
         *cols = 4;
      else
         *cols = p->Size % 4;
d1384 1
a1384 1
         GLchar *newName = _mesa_malloc(len + 1);
d1387 1
a1387 1
         _mesa_memcpy(newName, name, len);
d1392 1
a1392 1
            const GLint element = _mesa_atoi(c + 1);
d1407 1
a1407 1
         _mesa_free(newName);
d1438 1
a1438 1
      _mesa_free((void *) sh->Source);
d1442 3
d1460 3
d1485 50
a1551 2
   FLUSH_VERTICES(ctx, _NEW_PROGRAM);

d1562 5
d1572 4
a1575 1
   _mesa_reference_shader_program(ctx, &ctx->Shader.CurrentProgram, shProg);
d1604 5
a1608 4
         GLuint u = prog->SamplerUnits[s];
         GLuint t = prog->SamplerTargets[s];
         assert(u < MAX_TEXTURE_IMAGE_UNITS);
         prog->TexturesUsed[u] |= (1 << t);
d1663 1
a1663 1
   struct gl_program_parameter *param =
a1664 2
   const GLboolean isUniformBool = is_boolean_type(param->DataType);
   const GLboolean areIntValues = is_integer_type(type);
d1675 1
a1675 1
   if (index + offset > program->Parameters->Size) {
d1682 1
a1682 1
      GLuint texUnit, sampler;
d1685 2
a1686 7
      /* data type for setting samplers must be int */
      if (type != GL_INT) {
         _mesa_error(ctx, GL_INVALID_OPERATION,
                     "glUniform(only glUniform1i can be used "
                     "to set sampler uniforms)");
         return;
      }
d1688 1
a1688 3
      /* XXX arrays of samplers haven't been tested much, but it's not a
       * common thing...
       */
d1690 3
a1692 2
         sampler = (GLuint) program->Parameters->ParameterValues[index + i][0];
         texUnit = ((GLuint *) values)[i];
d1703 8
a1710 1
            program->SamplerUnits[sampler] = texUnit;
d1714 14
a1727 3
      _mesa_update_shader_textures_used(program);

      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
d1731 2
a1732 1
      GLsizei k, i;
d1735 1
d1737 1
a1737 1
      if (param->Size > typeSize) {
d1742 2
a1743 2
         /* non-array: count must be one */
         if (count != 1) {
d1779 1
a1779 1
               uniformVal[i] = uniformVal[i] ? 1.0 : 0.0;
d1797 1
d1826 3
d1830 1
d1834 3
d1838 1
d1842 3
d1846 1
d1850 3
d1854 1
d1862 1
a1862 1
   FLUSH_VERTICES(ctx, _NEW_PROGRAM);
d1866 19
d1920 4
a1923 1
   GLuint dst = index + offset, src = 0;
d1927 1
a1927 1
   get_matrix_dims(program->Parameters->Parameters[index].DataType, &nr, &nc);
d1934 7
a1940 3
   if (index + offset > program->Parameters->Size) {
      /* out of bounds! */
      return;
d1954 6
a1959 1
         GLfloat *v = program->Parameters->ParameterValues[dst];
d1968 2
a1969 1
         dst++;
d1983 1
a1983 1
                     GLenum matrixType, GLint location, GLsizei count,
d2015 1
a2015 1
   FLUSH_VERTICES(ctx, _NEW_PROGRAM);
d2043 8
a2050 2
static void
_mesa_validate_program(GLcontext *ctx, GLuint program)
d2052 20
a2071 1
   struct gl_shader_program *shProg;
d2073 17
a2089 3
   shProg = _mesa_lookup_shader_program_err(ctx, program, "glValidateProgram");
   if (!shProg) {
      return;
d2092 17
d2110 1
a2110 2
      shProg->Validated = GL_FALSE;
      return;
d2128 38
a2165 1
   shProg->Validated = GL_TRUE;
@


1.4
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d3 1
a3 1
 * Version:  7.2
d6 1
d39 9
a47 9
#include "glheader.h"
#include "context.h"
#include "hash.h"
#include "macros.h"
#include "program.h"
#include "prog_parameter.h"
#include "prog_print.h"
#include "prog_statevars.h"
#include "prog_uniform.h"
d51 1
d54 4
d459 7
a465 1
         /* already attached */
d527 1
a527 1
   GLint i;
d550 8
d775 51
d857 24
d891 1
d917 24
a940 8
   if (nameOut)
      copy_string(nameOut, maxLength, length,
                  prog->Parameters->Parameters[progPos].Name);
   if (size)
      *size = prog->Parameters->Parameters[progPos].Size
         / sizeof_glsl_type(prog->Parameters->Parameters[progPos].DataType);
   if (type)
      *type = prog->Parameters->Parameters[progPos].DataType;
d967 5
a971 14
#if 0
   GET_CURRENT_CONTEXT(ctx);

   switch (pname) {
   case GL_PROGRAM_OBJECT_ARB:
      {
         struct gl2_program_intf **pro = ctx->Shader.CurrentProgram;

         if (pro != NULL)
            return (**pro)._container._generic.
               GetName((struct gl2_generic_intf **) (pro));
      }
      break;
   default:
d974 2
a975 2
#endif
   return 0;
d1027 3
d1112 64
a1175 1
#define MAX_UNIFORM_ELEMENTS 16
d1178 3
a1180 2
 * Helper for GetUniformfv(), GetUniformiv()
 * Returns number of elements written to 'params' output.
d1182 3
a1184 3
static GLuint
get_uniformfv(GLcontext *ctx, GLuint program, GLint location,
              GLfloat *params)
d1187 6
a1192 1
      = _mesa_lookup_shader_program(ctx, program);
d1194 7
a1200 6
      if (shProg->Uniforms &&
          location >= 0 && location < (GLint) shProg->Uniforms->NumUniforms) {
         GLint progPos;
         GLuint i;
         const struct gl_program *prog = NULL;

a1210 14

         ASSERT(prog);
         if (prog) {
            /* See uniformiv() below */                    
            assert(prog->Parameters->Parameters[progPos].Size <= MAX_UNIFORM_ELEMENTS);

            for (i = 0; i < prog->Parameters->Parameters[progPos].Size; i++) {
               params[i] = prog->Parameters->ParameterValues[progPos][i];
            }
            return prog->Parameters->Parameters[progPos].Size;
         }
      }
      else {
         _mesa_error(ctx, GL_INVALID_OPERATION, "glGetUniformfv(location)");
d1213 3
a1215 4
   else {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGetUniformfv(program)");
   }
   return 0;
d1226 19
a1244 1
   (void) get_uniformfv(ctx, program, location, params);
d1250 1
d1256 18
a1273 6
   GLfloat fparams[MAX_UNIFORM_ELEMENTS];
   GLuint n = get_uniformfv(ctx, program, location, fparams);
   GLuint i;
   assert(n <= MAX_UNIFORM_ELEMENTS);
   for (i = 0; i < n; i++) {
      params[i] = (GLint) fparams[i];
d1279 25
d1305 3
d1312 2
d1329 48
a1376 1
   return _mesa_lookup_uniform(shProg->Uniforms, name);
d1414 4
a1417 1
   sh->CompileStatus = _slang_compile(ctx, sh);
d1461 2
a1462 1
         _mesa_error(ctx, GL_INVALID_OPERATION, "glUseProgram");
d1476 13
a1488 1
 * Update the vertex and fragment program's TexturesUsed arrays.
d1490 2
a1491 2
static void
update_textures_used(struct gl_program *prog)
a1507 21
static GLboolean
is_sampler_type(GLenum type)
{
   switch (type) {
   case GL_SAMPLER_1D:
   case GL_SAMPLER_2D:
   case GL_SAMPLER_3D:
   case GL_SAMPLER_CUBE:
   case GL_SAMPLER_1D_SHADOW:
   case GL_SAMPLER_2D_SHADOW:
   case GL_SAMPLER_2D_RECT_ARB:
   case GL_SAMPLER_2D_RECT_SHADOW_ARB:
   case GL_SAMPLER_1D_ARRAY_EXT:
   case GL_SAMPLER_2D_ARRAY_EXT:
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
}


d1544 3
a1546 2
 * \param location  the location/index of the uniform
 * \param type  the datatype of the uniform
d1548 2
a1549 2
 * \param elems  number of elements per uniform
 * \param values  the new values
d1552 4
a1555 2
set_program_uniform(GLcontext *ctx, struct gl_program *program, GLint location,
                    GLenum type, GLsizei count, GLint elems, const void *values)
d1557 10
a1566 2
   if (!compatible_types(type,
                         program->Parameters->Parameters[location].DataType)) {
d1571 6
a1576 1
   if (program->Parameters->Parameters[location].Type == PROGRAM_SAMPLER) {
d1579 1
d1582 1
a1582 1
      if (type != GL_INT || count != 1) {
d1589 13
a1601 2
      sampler = (GLuint) program->Parameters->ParameterValues[location][0];
      texUnit = ((GLuint *) values)[0];
d1603 4
a1606 5
      /* check that the sampler (tex unit index) is legal */
      if (texUnit >= ctx->Const.MaxTextureImageUnits) {
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glUniform1(invalid sampler/tex unit index)");
         return;
d1609 1
a1609 3
      /* This maps a sampler to a texture unit: */
      program->SamplerUnits[sampler] = texUnit;
      update_textures_used(program);
d1616 2
d1619 11
a1629 3
      if (count * elems > (GLint) program->Parameters->Parameters[location].Size) {
         _mesa_error(ctx, GL_INVALID_OPERATION, "glUniform(count too large)");
         return;
d1632 1
d1634 12
a1645 5
         GLfloat *uniformVal = program->Parameters->ParameterValues[location + k];
         if (type == GL_INT ||
             type == GL_INT_VEC2 ||
             type == GL_INT_VEC3 ||
             type == GL_INT_VEC4) {
d1657 7
d1677 2
a1678 1
   GLint elems;
d1688 7
d1729 2
d1735 3
a1737 2
      GLint loc = shProg->Uniforms->Uniforms[location].VertPos;
      if (loc >= 0) {
d1739 1
a1739 1
                             loc, type, count, elems, values);
d1744 3
a1746 2
      GLint loc = shProg->Uniforms->Uniforms[location].FragPos;
      if (loc >= 0) {
d1748 1
a1748 1
                             loc, type, count, elems, values);
a1750 2
}

d1752 1
a1752 42
static void
get_matrix_dims(GLenum type, GLint *rows, GLint *cols)
{
   switch (type) {
   case GL_FLOAT_MAT2:
      *rows = *cols = 2;
      break;
   case GL_FLOAT_MAT2x3:
      *rows = 3;
      *cols = 2;
      break;
   case GL_FLOAT_MAT2x4:
      *rows = 4;
      *cols = 2;
      break;
   case GL_FLOAT_MAT3:
      *rows = 3;
      *cols = 3;
      break;
   case GL_FLOAT_MAT3x2:
      *rows = 2;
      *cols = 3;
      break;
   case GL_FLOAT_MAT3x4:
      *rows = 4;
      *cols = 3;
      break;
   case GL_FLOAT_MAT4:
      *rows = 4;
      *cols = 4;
      break;
   case GL_FLOAT_MAT4x2:
      *rows = 2;
      *cols = 4;
      break;
   case GL_FLOAT_MAT4x3:
      *rows = 3;
      *cols = 4;
      break;
   default:
      *rows = *cols = 0;
   }
d1756 3
d1761 2
a1762 2
                           GLuint location, GLuint count,
                           GLuint rows, GLuint cols,
d1766 1
a1766 1
   GLuint dst = location, src = 0;
d1770 1
a1770 1
   get_matrix_dims(program->Parameters->Parameters[location].DataType, &nr, &nc);
d1773 6
a1778 1
                  "glUniformMatrix(matrix size mismatch");
d1820 2
d1832 7
d1850 2
d1853 3
a1855 2
      GLint loc = shProg->Uniforms->Uniforms[location].VertPos;
      if (loc >= 0) {
d1857 2
a1858 1
                                    loc, count, rows, cols, transpose, values);
d1863 3
a1865 2
      GLint loc = shProg->Uniforms->Uniforms[location].FragPos;
      if (loc >= 0) {
d1867 2
a1868 1
                                    loc, count, rows, cols, transpose, values);
d1871 2
@


1.3
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d3 1
a3 1
 * Version:  7.0
d5 1
a5 1
 * Copyright (C) 2004-2007  Brian Paul   All Rights Reserved.
d46 4
a49 4
#include "shader_api.h"

#include "slang_compile.h"
#include "slang_link.h"
d56 1
a56 1
struct gl_shader_program *
d78 2
a79 17
   if (shProg->VertexProgram) {
      if (shProg->VertexProgram->Base.Parameters == shProg->Uniforms) {
         /* to prevent a double-free in the next call */
         shProg->VertexProgram->Base.Parameters = NULL;
      }
      ctx->Driver.DeleteProgram(ctx, &shProg->VertexProgram->Base);
      shProg->VertexProgram = NULL;
   }

   if (shProg->FragmentProgram) {
      if (shProg->FragmentProgram->Base.Parameters == shProg->Uniforms) {
         /* to prevent a double-free in the next call */
         shProg->FragmentProgram->Base.Parameters = NULL;
      }
      ctx->Driver.DeleteProgram(ctx, &shProg->FragmentProgram->Base);
      shProg->FragmentProgram = NULL;
   }
d82 1
a82 1
      _mesa_free_parameter_list(shProg->Uniforms);
d116 2
d122 5
d137 1
a137 4
   if (shProg->Shaders) {
      _mesa_free(shProg->Shaders);
      shProg->Shaders = NULL;
   }
d166 4
a169 2
      /*printf("SHPROG DECR %p (%d) to %d\n",
        (void*) old, old->Name, old->RefCount);*/
d183 4
a186 2
      /*printf("SHPROG INCR %p (%d) to %d\n",
        (void*) shProg, shProg->Name, shProg->RefCount);*/
d216 29
a264 1
   GLuint i;
d269 1
a269 6
   for (i = 0; i < sh->NumPrograms; i++) {
      assert(sh->Programs[i]);
      ctx->Driver.DeleteProgram(ctx, sh->Programs[i]);
   }
   if (sh->Programs)
      _mesa_free(sh->Programs);
d343 27
d415 10
a424 6
/**
 * Return size (in floats) of the given GLSL type.
 * See also _slang_sizeof_type_specifier().
 */
static GLint
sizeof_glsl_type(GLenum type)
d426 2
a427 38
   switch (type) {
   case GL_BOOL:
   case GL_FLOAT:
   case GL_INT:
      return 1;
   case GL_BOOL_VEC2:
   case GL_FLOAT_VEC2:
   case GL_INT_VEC2:
      return 2;
   case GL_BOOL_VEC3:
   case GL_FLOAT_VEC3:
   case GL_INT_VEC3:
      return 3;
   case GL_BOOL_VEC4:
   case GL_FLOAT_VEC4:
   case GL_INT_VEC4:
      return 4;
   case GL_FLOAT_MAT2:
      return 8;  /* 2 rows of 4, actually */
   case GL_FLOAT_MAT3:
      return 12;  /* 3 rows of 4, actually */
   case GL_FLOAT_MAT4:
      return 16;
   case GL_FLOAT_MAT2x3:
      return 8;   /* 2 rows of 4, actually */
   case GL_FLOAT_MAT2x4:
      return 8;
   case GL_FLOAT_MAT3x2:
      return 12;  /* 3 rows of 4, actually */
   case GL_FLOAT_MAT3x4:
      return 12;
   case GL_FLOAT_MAT4x2:
      return 16;  /* 4 rows of 4, actually */
   case GL_FLOAT_MAT4x3:
      return 16;  /* 4 rows of 4, actually */
   default:
      return 0; /* error */
   }
d434 1
a434 1
void
d437 7
a443 5
   struct gl_shader_program *shProg
      = _mesa_lookup_shader_program(ctx, program);
   struct gl_shader *sh = _mesa_lookup_shader(ctx, shader);
   GLuint n;
   GLuint i;
d445 2
a446 3
   if (!shProg || !sh) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glAttachShader(bad program or shader name)");
a450 1

d475 35
a509 1
void
d513 1
a513 2
   struct gl_shader_program *shProg
      = _mesa_lookup_shader_program(ctx, program);
d515 2
a516 1
   GLint i, oldIndex;
d518 2
a520 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glBindAttribLocation(program)");
d533 3
a535 6
   if (shProg->LinkStatus) {
      /* get current index/location for the attribute */
      oldIndex = _mesa_get_attrib_location(ctx, program, name);
   }
   else {
      oldIndex = -1;
d539 1
a539 1
   i = _mesa_add_attribute(shProg->Attributes, name, size, index);
d542 1
d545 4
a548 6
   if (shProg->VertexProgram && oldIndex >= 0 && oldIndex != index) {
      /* If the index changed, need to search/replace references to that attribute
       * in the vertex program.
       */
      _slang_remap_attribute(&shProg->VertexProgram->Base, oldIndex, index);
   }
d552 1
a552 1
GLuint
d576 1
a576 1
GLuint 
d597 1
a597 1
void
d610 2
a611 3
   shProg = _mesa_lookup_shader_program(ctx, name);
   if (!shProg) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glDeleteProgram(name)");
a612 1
   }
d621 1
a621 1
void
d624 4
a627 2
   struct gl_shader *sh = _mesa_lookup_shader(ctx, shader);
   if (!sh) {
a628 1
   }
d637 1
a637 1
void
d640 1
a640 2
   struct gl_shader_program *shProg
      = _mesa_lookup_shader_program(ctx, program);
d644 2
a645 3
   if (!shProg) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                  "glDetachShader(bad program or shader name)");
a646 1
   }
d655 1
a655 1
         /* derefernce */
d691 61
a751 2
   _mesa_error(ctx, GL_INVALID_VALUE,
               "glDetachShader(shader not found)");
d755 1
a755 1
void
d760 2
a761 6
   static const GLenum vec_types[] = {
      GL_FLOAT, GL_FLOAT_VEC2, GL_FLOAT_VEC3, GL_FLOAT_VEC4
   };
   struct gl_shader_program *shProg
      = _mesa_lookup_shader_program(ctx, program);
   GLint sz;
d763 2
a764 2
   if (!shProg) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetActiveAttrib");
a765 1
   }
d767 4
a770 1
   if (!shProg->Attributes || index >= shProg->Attributes->NumParameters) {
d775 2
a776 3
   copy_string(nameOut, maxLength, length,
               shProg->Attributes->Parameters[index].Name);
   sz = shProg->Attributes->Parameters[index].Size;
d778 5
a782 3
      *size = 1;   /* attributes may not be arrays */
   if (type && sz > 0 && sz <= 4)  /* XXX this is a temporary hack */
      *type = vec_types[sz - 1];
d789 1
a789 1
void
d794 3
a796 3
   struct gl_shader_program *shProg
      = _mesa_lookup_shader_program(ctx, program);
   GLuint ind, j;
d798 2
a799 2
   if (!shProg) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetActiveUniform");
a800 1
   }
d802 1
a802 1
   if (!shProg->Uniforms || index >= shProg->Uniforms->NumParameters) {
d807 8
a814 19
   ind = 0;
   for (j = 0; j < shProg->Uniforms->NumParameters; j++) {
      if (shProg->Uniforms->Parameters[j].Type == PROGRAM_UNIFORM ||
          shProg->Uniforms->Parameters[j].Type == PROGRAM_SAMPLER) {
         if (ind == index) {
            GLuint uSize = shProg->Uniforms->Parameters[j].Size;
            GLenum uType = shProg->Uniforms->Parameters[j].DataType;
            /* found it */
            copy_string(nameOut, maxLength, length,
                        shProg->Uniforms->Parameters[j].Name);
            if (size) {
               /* convert from floats to 'type' (eg: sizeof(mat4x4)=1) */
               *size = uSize / sizeof_glsl_type(uType);
            }
            if (type)
               *type = uType;
            return;
         }
         ind++;
d818 11
a828 1
   _mesa_error(ctx, GL_INVALID_VALUE, "glGetActiveUniform(index)");
d835 1
a835 1
void
d839 2
a840 2
   struct gl_shader_program *shProg
      = _mesa_lookup_shader_program(ctx, program);
d842 2
a843 2
      GLint i;
      for (i = 0; i < maxCount && i < shProg->NumShaders; i++) {
a848 3
   else {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetAttachedShaders");
   }
d852 2
a853 3
GLint
_mesa_get_attrib_location(GLcontext *ctx, GLuint program,
                          const GLchar *name)
d855 2
a856 2
   struct gl_shader_program *shProg
      = _mesa_lookup_shader_program(ctx, program);
d858 4
a861 4
   if (!shProg) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetAttribLocation");
      return -1;
   }
d863 4
a866 34
   if (!shProg->LinkStatus) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                  "glGetAttribLocation(program not linked)");
      return -1;
   }

   if (!name)
      return -1;

   if (shProg->Attributes) {
      GLint i = _mesa_lookup_parameter_index(shProg->Attributes, -1, name);
      if (i >= 0) {
         return shProg->Attributes->Parameters[i].StateIndexes[0];
      }
   }
   return -1;
}


GLuint
_mesa_get_handle(GLcontext *ctx, GLenum pname)
{
#if 0
   GET_CURRENT_CONTEXT(ctx);

   switch (pname) {
   case GL_PROGRAM_OBJECT_ARB:
      {
         struct gl2_program_intf **pro = ctx->Shader.CurrentProgram;

         if (pro != NULL)
            return (**pro)._container._generic.
               GetName((struct gl2_generic_intf **) (pro));
      }
d876 1
a876 1
void
d880 1
d889 5
d911 1
a911 1
      *params = shProg->Attributes ? shProg->Attributes->NumParameters : 0;
d914 1
a914 2
      *params = _mesa_longest_parameter_name(shProg->Attributes,
                                             PROGRAM_INPUT) + 1;
d917 1
a917 3
      *params
         = _mesa_num_parameters_of_type(shProg->Uniforms, PROGRAM_UNIFORM)
         + _mesa_num_parameters_of_type(shProg->Uniforms, PROGRAM_SAMPLER);
d920 1
a920 3
      *params = MAX2(
             _mesa_longest_parameter_name(shProg->Uniforms, PROGRAM_UNIFORM),
             _mesa_longest_parameter_name(shProg->Uniforms, PROGRAM_SAMPLER));
d931 1
a931 1
void
d934 1
a934 1
   struct gl_shader *shader = _mesa_lookup_shader(ctx, name);
a936 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetShaderiv(shader)");
d963 1
a963 1
void
d977 1
a977 1
void
d993 1
a993 1
void
d997 2
a998 1
   struct gl_shader *sh = _mesa_lookup_shader(ctx, shader);
a999 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetShaderSource(shader)");
d1006 2
d1009 2
a1010 1
 * Called via ctx->Driver.GetUniformfv().
d1012 3
a1014 3
void
_mesa_get_uniformfv(GLcontext *ctx, GLuint program, GLint location,
                    GLfloat *params)
d1019 9
a1027 25
      GLint i;
      if (location >= 0 && location < shProg->Uniforms->NumParameters) {
         GLuint uSize;
         GLenum uType;
         GLint rows = 0;
         uType = shProg->Uniforms->Parameters[location].DataType;
         uSize = sizeof_glsl_type(uType);
         /* Matrix types need special handling, because they span several
          * parameters, and may also not be fully packed.
          */
         switch (shProg->Uniforms->Parameters[location].DataType) {
            case GL_FLOAT_MAT2:
            case GL_FLOAT_MAT3x2:
            case GL_FLOAT_MAT4x2:
               rows = 2;
               break;
            case GL_FLOAT_MAT2x3:
            case GL_FLOAT_MAT3:
            case GL_FLOAT_MAT4x3:
               rows = 3;
               break;
            case GL_FLOAT_MAT2x4:
            case GL_FLOAT_MAT3x4:
            case GL_FLOAT_MAT4:
               rows = 4;
d1029 5
a1033 5
         if (rows != 0) {
            GLint r, c;
            for (c = 0, i = 0; c * 4 < uSize; c++)
               for (r = 0; r < rows; r++, i++)
                  params[i] = shProg->Uniforms->ParameterValues[location + c][r];
d1035 8
a1042 3
         else
            for (i = 0; i < uSize; i++) {
               params[i] = shProg->Uniforms->ParameterValues[location][i];
d1044 2
d1048 1
a1048 1
         _mesa_error(ctx, GL_INVALID_VALUE, "glGetUniformfv(location)");
d1052 1
a1052 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetUniformfv(program)");
d1054 1
d1059 1
a1059 1
 * Called via ctx->Driver.GetUniformLocation().
d1061 3
a1063 2
GLint
_mesa_get_uniform_location(GLcontext *ctx, GLuint program, const GLchar *name)
d1065 1
a1065 19
   struct gl_shader_program *shProg
      = _mesa_lookup_shader_program(ctx, program);
   if (shProg) {
      GLuint loc;
      for (loc = 0; loc < shProg->Uniforms->NumParameters; loc++) {
         const struct gl_program_parameter *u
            = shProg->Uniforms->Parameters + loc;
         /* XXX this is a temporary simplification / short-cut.
          * We need to handle things like "e.c[0].b" as seen in the
          * GLSL orange book, page 189.
          */
         if ((u->Type == PROGRAM_UNIFORM ||
              u->Type == PROGRAM_SAMPLER) && !strcmp(u->Name, name)) {
            return loc;
         }
      }
   }
   return -1;

d1069 6
a1074 2
GLboolean
_mesa_is_program(GLcontext *ctx, GLuint name)
d1076 7
a1082 2
   struct gl_shader_program *shProg = _mesa_lookup_shader_program(ctx, name);
   return shProg ? GL_TRUE : GL_FALSE;
d1086 5
a1090 2
GLboolean
_mesa_is_shader(GLcontext *ctx, GLuint name)
d1092 16
a1107 2
   struct gl_shader *shader = _mesa_lookup_shader(ctx, name);
   return shader ? GL_TRUE : GL_FALSE;
d1115 1
a1115 1
void
d1118 4
a1121 3
   struct gl_shader *sh = _mesa_lookup_shader(ctx, shader);
   if (!sh) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glShaderSource(shaderObj)");
a1122 1
   }
d1136 1
a1136 1
void
d1139 1
a1139 1
   struct gl_shader *sh = _mesa_lookup_shader(ctx, shaderObj);
d1141 2
a1142 2
   if (!sh) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glCompileShader(shaderObj)");
a1143 1
   }
d1152 1
a1152 1
void
d1157 2
a1158 3
   shProg = _mesa_lookup_shader_program(ctx, program);
   if (!shProg) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glLinkProgram(program)");
d1160 2
a1161 1
   }
d1184 1
a1184 1
      shProg = _mesa_lookup_shader_program(ctx, program);
d1186 4
a1189 2
         _mesa_error(ctx, GL_INVALID_VALUE,
                     "glUseProgramObjectARB(programObj)");
d1201 1
d1203 1
a1203 1
 * Called via ctx->Driver.Uniform().
d1205 2
a1206 3
void
_mesa_uniform(GLcontext *ctx, GLint location, GLsizei count,
              const GLvoid *values, GLenum type)
d1208 14
a1221 4
   struct gl_shader_program *shProg = ctx->Shader.CurrentProgram;
   GLint elems, i, k;
   GLenum uType;
   GLsizei maxCount;
d1223 17
a1239 3
   if (!shProg || !shProg->LinkStatus) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glUniform(program not linked)");
      return;
d1241 34
a1275 2
   if (location == -1)
      return;   /* The standard specifies this as a no-op */
d1277 16
a1292 5
   /* The spec says this is GL_INVALID_OPERATION, although it seems like it
    * ought to be GL_INVALID_VALUE
    */
   if (location < 0 || location >= (GLint) shProg->Uniforms->NumParameters) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glUniform(location)");
d1296 3
a1298 1
   FLUSH_VERTICES(ctx, _NEW_PROGRAM);
d1300 1
a1300 6
   uType = shProg->Uniforms->Parameters[location].DataType;
   /*
    * If we're setting a sampler, we must use glUniformi1()!
    */
   if (shProg->Uniforms->Parameters[location].Type == PROGRAM_SAMPLER) {
      GLint unit;
d1307 4
d1312 1
a1312 2
      unit = ((GLint *) values)[0];
      if (unit >= ctx->Const.MaxTextureImageUnits) {
d1317 59
d1405 4
a1408 2
   /* OpenGL requires types to match exactly, except that one can convert
    * float or int array to boolean array.
d1410 79
a1488 18
   switch (uType)
   {
      case GL_BOOL:
      case GL_BOOL_VEC2:
      case GL_BOOL_VEC3:
      case GL_BOOL_VEC4:
         if (elems != sizeof_glsl_type(uType)) {
            _mesa_error(ctx, GL_INVALID_OPERATION, "glUniform(count mismatch)");
         }
         break;
      case PROGRAM_SAMPLER:
         break;
      default:
         if (shProg->Uniforms->Parameters[location].Type != PROGRAM_SAMPLER 
             && uType != type) {
            _mesa_error(ctx, GL_INVALID_OPERATION, "glUniform(type mismatch)");
         }
         break;
d1491 4
a1494 4
   /* XXX if this is a base type, then count must equal 1. However, we
    * don't have enough information from the compiler to distinguish a
    * base type from a 1-element array of that type. The standard allows
    * count to overrun an array, in which case the overflow is ignored.
a1495 2
   maxCount = shProg->Uniforms->Parameters[location].Size / elems;
   if (count > maxCount) count = maxCount;
d1497 13
a1509 9
   for (k = 0; k < count; k++) {
      GLfloat *uniformVal = shProg->Uniforms->ParameterValues[location + k];
      if (type == GL_INT ||
          type == GL_INT_VEC2 ||
          type == GL_INT_VEC3 ||
          type == GL_INT_VEC4) {
         const GLint *iValues = ((const GLint *) values) + k * elems;
         for (i = 0; i < elems; i++) {
            uniformVal[i] = (GLfloat) iValues[i];
d1511 1
a1512 14
      else {
         const GLfloat *fValues = ((const GLfloat *) values) + k * elems;
         for (i = 0; i < elems; i++) {
            uniformVal[i] = fValues[i];
         }
      }
      if (uType == GL_BOOL ||
          uType == GL_BOOL_VEC2 ||
          uType == GL_BOOL_VEC3 ||
          uType == GL_BOOL_VEC4) {
          for (i = 0; i < elems; i++)
              uniformVal[i] = uniformVal[i] ? 1.0f : 0.0f;
      }
   }
d1514 1
a1514 6
   if (shProg->Uniforms->Parameters[location].Type == PROGRAM_SAMPLER) {
      if (shProg->VertexProgram)
         _slang_resolve_samplers(shProg, &shProg->VertexProgram->Base);
      if (shProg->FragmentProgram)
         _slang_resolve_samplers(shProg, &shProg->FragmentProgram->Base);
      FLUSH_VERTICES(ctx, _NEW_TEXTURE);
d1521 1
d1523 1
a1523 1
void
a1527 1
   GLsizei maxCount, i;
d1529 1
d1535 1
d1538 3
a1540 5
   /* The spec says this is GL_INVALID_OPERATION, although it seems like it
    * ought to be GL_INVALID_VALUE
    */
   if (location < 0 || location >= (GLint) shProg->Uniforms->NumParameters) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glUniformMatrix(location)");
a1546 4
   if (count < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glUniformMatrix(count < 0)");
      return;
   }
d1550 5
a1554 17
   /*
    * Note: the _columns_ of a matrix are stored in program registers, not
    * the rows.
    */
   /* XXXX need to test 3x3 and 2x2 matrices... */
   maxCount = shProg->Uniforms->Parameters[location].Size / (4 * cols);
   if (count > maxCount)
      count = maxCount;
   for (i = 0; i < count; i++) {
      if (transpose) {
         GLuint row, col;
         for (col = 0; col < cols; col++) {
            GLfloat *v = shProg->Uniforms->ParameterValues[location + col];
            for (row = 0; row < rows; row++) {
               v[row] = values[row * cols + col];
            }
         }
d1556 7
a1562 8
      else {
         GLuint row, col;
         for (col = 0; col < cols; col++) {
            GLfloat *v = shProg->Uniforms->ParameterValues[location + col];
            for (row = 0; row < rows; row++) {
               v[row] = values[col * rows + row];
            }
         }
a1563 2
      location += cols;
      values += rows * cols;
d1568 1
a1568 1
void
d1572 2
a1573 1
   shProg = _mesa_lookup_shader_program(ctx, program);
a1574 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glValidateProgram(program)");
a1576 2
   /* XXX temporary */
   shProg->Validated = GL_TRUE;
d1578 7
a1584 1
   /* From the GL spec:
d1597 40
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d83 1
a83 1
      _mesa_delete_program(ctx, &shProg->VertexProgram->Base);
d92 1
a92 1
      _mesa_delete_program(ctx, &shProg->FragmentProgram->Base);
d250 1
a250 1
      _mesa_delete_program(ctx, sh->Programs[i]);
d373 48
d684 3
a686 3
      *size = sz;
   if (type)
      *type = vec_types[sz]; /* XXX this is a temporary hack */
d717 2
d722 4
a725 2
            if (size)
               *size = shProg->Uniforms->Parameters[j].Size;
d727 1
a727 1
               *type = shProg->Uniforms->Parameters[j].DataType;
d958 29
a986 2
         for (i = 0; i < shProg->Uniforms->Parameters[location].Size; i++) {
            params[i] = shProg->Uniforms->ParameterValues[location][i];
d988 4
d1145 2
d1153 6
d1160 1
a1160 1
      _mesa_error(ctx, GL_INVALID_VALUE, "glUniform(location)");
d1166 1
d1214 21
a1234 3
   if (count * elems > shProg->Uniforms->Parameters[location].Size) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glUniform(count too large)");
      return;
d1237 8
d1262 7
d1289 1
d1296 7
a1302 2
   if (location < 0 || location >= shProg->Uniforms->NumParameters) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glUniformMatrix(location)");
d1309 4
d1321 11
a1331 6
   if (transpose) {
      GLuint row, col;
      for (col = 0; col < cols; col++) {
         GLfloat *v = shProg->Uniforms->ParameterValues[location + col];
         for (row = 0; row < rows; row++) {
            v[row] = values[row * cols + col];
d1334 7
a1340 7
   }
   else {
      GLuint row, col;
      for (col = 0; col < cols; col++) {
         GLfloat *v = shProg->Uniforms->ParameterValues[location + col];
         for (row = 0; row < rows; row++) {
            v[row] = values[col * rows + row];
d1343 2
@


1.1
log
@Initial revision
@
text
@d381 1
a381 1
   const GLuint n = shProg->NumShaders;
d390 2
d553 1
a553 1
   const GLuint n = shProg->NumShaders;
d561 2
@


1.1.1.1
log
@Mesa 7.0.1
@
text
@@
