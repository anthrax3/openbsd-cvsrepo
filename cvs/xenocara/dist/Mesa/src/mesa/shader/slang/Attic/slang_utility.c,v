head	1.4;
access;
symbols
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2011.10.23.13.37.45;	author matthieu;	state dead;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.33;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.11;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.11;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.48;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.51;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge Mesa 7.10.3
@
text
@/*
 * Mesa 3-D graphics library
 * Version:  6.5.3
 *
 * Copyright (C) 2005-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file slang_utility.c
 * slang utilities
 * \author Michal Krol
 */

#include "main/imports.h"
#include "slang_utility.h"
#include "slang_mem.h"

char *
slang_string_concat (char *dst, const char *src)
{
   return strcpy (dst + strlen (dst), src);
}


/* slang_string */

GLvoid
slang_string_init (slang_string *self)
{
   self->data = NULL;
   self->capacity = 0;
   self->length = 0;
   self->fail = GL_FALSE;
}

GLvoid
slang_string_free (slang_string *self)
{
   if (self->data != NULL)
      free(self->data);
}

GLvoid
slang_string_reset (slang_string *self)
{
   self->length = 0;
   self->fail = GL_FALSE;
}

static GLboolean
grow (slang_string *self, GLuint size)
{
   if (self->fail)
      return GL_FALSE;
   if (size > self->capacity) {
      /* do not overflow 32-bit range */
      assert (size < 0x80000000);

      self->data = (char *) (_mesa_realloc (self->data, self->capacity, size * 2));
      self->capacity = size * 2;
      if (self->data == NULL) {
         self->capacity = 0;
         self->fail = GL_TRUE;
         return GL_FALSE;
      }
   }
   return GL_TRUE;
}

GLvoid
slang_string_push (slang_string *self, const slang_string *str)
{
   if (str->fail) {
      self->fail = GL_TRUE;
      return;
   }
   if (grow (self, self->length + str->length)) {
      memcpy (&self->data[self->length], str->data, str->length);
      self->length += str->length;
   }
}

GLvoid
slang_string_pushc (slang_string *self, const char c)
{
   if (grow (self, self->length + 1)) {
      self->data[self->length] = c;
      self->length++;
   }
}

GLvoid
slang_string_pushs (slang_string *self, const char *cstr, GLuint len)
{
   if (grow (self, self->length + len)) {
      memcpy (&self->data[self->length], cstr, len);
      self->length += len;
   }
}

GLvoid
slang_string_pushi (slang_string *self, GLint i)
{
   char buffer[12];

   sprintf (buffer, "%d", i);
   slang_string_pushs (self, buffer, strlen (buffer));
}

const char *
slang_string_cstr (slang_string *self)
{
   if (grow (self, self->length + 1))
      self->data[self->length] = '\0';
   return self->data;
}

/* slang_atom_pool */

void
slang_atom_pool_construct(slang_atom_pool * pool)
{
   GLuint i;

   for (i = 0; i < SLANG_ATOM_POOL_SIZE; i++)
      pool->entries[i] = NULL;
}

void
slang_atom_pool_destruct (slang_atom_pool * pool)
{
   GLuint i;

   for (i = 0; i < SLANG_ATOM_POOL_SIZE; i++) {
      slang_atom_entry * entry;
		
      entry = pool->entries[i];
      while (entry != NULL) {
         slang_atom_entry *next = entry->next;
         _slang_free(entry->id);
         _slang_free(entry);
         entry = next;
      }
   }
}

/*
 * Search the atom pool for an atom with a given name.
 * If atom is not found, create and add it to the pool.
 * Returns ATOM_NULL if the atom was not found and the function failed
 * to create a new atom.
 */
slang_atom
slang_atom_pool_atom(slang_atom_pool * pool, const char * id)
{
   GLuint hash;
   const char * p = id;
   slang_atom_entry ** entry;

   /* Hash a given string to a number in the range [0, ATOM_POOL_SIZE). */
   hash = 0;
   while (*p != '\0') {
      GLuint g;

      hash = (hash << 4) + (GLuint) (*p++);
      g = hash & 0xf0000000;
      if (g != 0)
         hash ^= g >> 24;
      hash &= ~g;
   }
   hash %= SLANG_ATOM_POOL_SIZE;

   /* Now the hash points to a linked list of atoms with names that
    * have the same hash value.  Search the linked list for a given
    * name.
    */
   entry = &pool->entries[hash];
   while (*entry != NULL) {
      /* If the same, return the associated atom. */
      if (slang_string_compare((**entry).id, id) == 0)
         return (slang_atom) (**entry).id;
      /* Grab the next atom in the linked list. */
      entry = &(**entry).next;
   }

   /* Okay, we have not found an atom. Create a new entry for it.
    * Note that the <entry> points to the last entry's <next> field.
    */
   *entry = (slang_atom_entry *) _slang_alloc(sizeof(slang_atom_entry));
   if (*entry == NULL)
      return SLANG_ATOM_NULL;

   /* Initialize a new entry. Because we'll need the actual name of
    * the atom, we use the pointer to this string as an actual atom's
    * value.
    */
   (**entry).next = NULL;
   (**entry).id = _slang_strdup(id);
   if ((**entry).id == NULL)
      return SLANG_ATOM_NULL;
   return (slang_atom) (**entry).id;
}

/**
 * Return the name of a given atom.
 */
const char *
slang_atom_pool_id(slang_atom_pool * pool, slang_atom atom)
{
   return (const char *) (atom);
}
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d38 1
a38 1
   return _mesa_strcpy (dst + _mesa_strlen (dst), src);
d57 1
a57 1
      _mesa_free (self->data);
d95 1
a95 1
      _mesa_memcpy (&self->data[self->length], str->data, str->length);
d113 1
a113 1
      _mesa_memcpy (&self->data[self->length], cstr, len);
d123 1
a123 1
   _mesa_sprintf (buffer, "%d", i);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 2005-2006  Brian Paul   All Rights Reserved.
d31 1
a31 1
#include "imports.h"
d33 1
d35 2
a36 1
char *slang_string_concat (char *dst, const char *src)
d38 95
a132 1
	return _mesa_strcpy (dst + _mesa_strlen (dst), src);
d137 2
a138 1
void slang_atom_pool_construct (slang_atom_pool *pool)
d140 1
a140 1
	GLuint i;
d142 2
a143 2
	for (i = 0; i < SLANG_ATOM_POOL_SIZE; i++)
		pool->entries[i] = NULL;
d146 2
a147 1
void slang_atom_pool_destruct (slang_atom_pool *pool)
d149 1
a149 1
	GLuint i;
d151 2
a152 3
	for (i = 0; i < SLANG_ATOM_POOL_SIZE; i++)
	{
		slang_atom_entry *entry;
d154 8
a161 49
		entry = pool->entries[i];
		while (entry != NULL)
		{
			slang_atom_entry *next;

			next = entry->next;
			slang_alloc_free (entry->id);
			slang_alloc_free (entry);
			entry = next;
		}
	}
}

slang_atom slang_atom_pool_atom (slang_atom_pool *pool, const char *id)
{
	GLuint hash;
	const char *p = id;
	slang_atom_entry **entry;

	hash = 0;
	while (*p != '\0')
	{
		GLuint g;

		hash = (hash << 4) + (GLuint) *p++;
		g = hash & 0xf0000000;
		if (g != 0)
			hash ^= g >> 24;
		hash &= ~g;
	}
	hash %= SLANG_ATOM_POOL_SIZE;

	entry = &pool->entries[hash];
	while (*entry != NULL)
	{
		if (slang_string_compare ((**entry).id, id) == 0)
			return (slang_atom) (**entry).id;
		entry = &(**entry).next;
	}

	*entry = (slang_atom_entry *) slang_alloc_malloc (sizeof (slang_atom_entry));
	if (*entry == NULL)
		return SLANG_ATOM_NULL;

	(**entry).next = NULL;
	(**entry).id = slang_string_duplicate (id);
	if ((**entry).id == NULL)
		return SLANG_ATOM_NULL;
	return (slang_atom) (**entry).id;
d164 8
a171 1
const char *slang_atom_pool_id (slang_atom_pool *pool, slang_atom atom)
d173 46
a218 1
	return (const char *) atom;
d221 8
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.6
a38 93
/* slang_string */

GLvoid
slang_string_init (slang_string *self)
{
   self->data = NULL;
   self->capacity = 0;
   self->length = 0;
   self->fail = GL_FALSE;
}

GLvoid
slang_string_free (slang_string *self)
{
   if (self->data != NULL)
      _mesa_free (self->data);
}

GLvoid
slang_string_reset (slang_string *self)
{
   self->length = 0;
   self->fail = GL_FALSE;
}

static GLboolean
grow (slang_string *self, GLuint size)
{
   if (self->fail)
      return GL_FALSE;
   if (size > self->capacity) {
      /* do not overflow 32-bit range */
      assert (size < 0x80000000);

      self->data = (char *) (_mesa_realloc (self->data, self->capacity, size * 2));
      self->capacity = size * 2;
      if (self->data == NULL) {
         self->capacity = 0;
         self->fail = GL_TRUE;
         return GL_FALSE;
      }
   }
   return GL_TRUE;
}

GLvoid
slang_string_push (slang_string *self, const slang_string *str)
{
   if (str->fail) {
      self->fail = GL_TRUE;
      return;
   }
   if (grow (self, self->length + str->length)) {
      _mesa_memcpy (&self->data[self->length], str->data, str->length);
      self->length += str->length;
   }
}

GLvoid
slang_string_pushc (slang_string *self, const char c)
{
   if (grow (self, self->length + 1)) {
      self->data[self->length] = c;
      self->length++;
   }
}

GLvoid
slang_string_pushs (slang_string *self, const char *cstr, GLuint len)
{
   if (grow (self, self->length + len)) {
      _mesa_memcpy (&self->data[self->length], cstr, len);
      self->length += len;
   }
}

GLvoid
slang_string_pushi (slang_string *self, GLint i)
{
   char buffer[12];

   _mesa_sprintf (buffer, "%d", i);
   slang_string_pushs (self, buffer, strlen (buffer));
}

const char *
slang_string_cstr (slang_string *self)
{
   if (grow (self, self->length + 1))
      self->data[self->length] = '\0';
   return self->data;
}

d41 1
a41 2
void
slang_atom_pool_construct(slang_atom_pool * pool)
d43 1
a43 1
   GLuint i;
d45 2
a46 2
   for (i = 0; i < SLANG_ATOM_POOL_SIZE; i++)
      pool->entries[i] = NULL;
d49 1
a49 2
void
slang_atom_pool_destruct (slang_atom_pool * pool)
d51 1
a51 1
   GLuint i;
d53 3
a55 2
   for (i = 0; i < SLANG_ATOM_POOL_SIZE; i++) {
      slang_atom_entry * entry;
d57 9
a65 8
      entry = pool->entries[i];
      while (entry != NULL) {
         slang_atom_entry *next;

         next = entry->next;
         slang_alloc_free(entry->id);
         slang_alloc_free(entry);
         entry = next;
d70 1
a70 7
/*
 * Search the atom pool for an atom with a given name.
 * If atom is not found, create and add it to the pool.
 * Returns ATOM_NULL if the atom was not found and the function failed to create a new atom.
 */
slang_atom
slang_atom_pool_atom(slang_atom_pool * pool, const char * id)
d72 34
a105 41
   GLuint hash;
   const char * p = id;
   slang_atom_entry ** entry;

   /* Hash a given string to a number in the range [0, ATOM_POOL_SIZE). */
   hash = 0;
   while (*p != '\0') {
      GLuint g;

      hash = (hash << 4) + (GLuint) (*p++);
      g = hash & 0xf0000000;
      if (g != 0)
         hash ^= g >> 24;
      hash &= ~g;
   }
   hash %= SLANG_ATOM_POOL_SIZE;

   /* Now the hash points to a linked list of atoms with names that have the same hash value.
    * Search the linked list for a given name. */
   entry = &pool->entries[hash];
   while (*entry != NULL) {
      /* If the same, return the associated atom. */
      if (slang_string_compare((**entry).id, id) == 0)
         return (slang_atom) (**entry).id;
      /* Grab the next atom in the linked list. */
      entry = &(**entry).next;
   }

   /* Okay, we have not found an atom. Create a new entry for it.
    * Note that the <entry> points to the last entry's <next> field. */
   *entry = (slang_atom_entry *) (slang_alloc_malloc(sizeof(slang_atom_entry)));
   if (*entry == NULL)
      return SLANG_ATOM_NULL;

   /* Initialize a new entry. Because we'll need the actual name of the atom, we use the pointer
    * to this string as an actual atom's value. */
   (**entry).next = NULL;
   (**entry).id = slang_string_duplicate(id);
   if ((**entry).id == NULL)
      return SLANG_ATOM_NULL;
   return (slang_atom) (**entry).id;
d108 1
a108 5
/*
 * Return the name of a given atom.
 */
const char *
slang_atom_pool_id(slang_atom_pool * pool, slang_atom atom)
d110 1
a110 1
	return (const char *) (atom);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 2005-2007  Brian Paul   All Rights Reserved.
a32 1
#include "slang_mem.h"
d34 1
a34 2
char *
slang_string_concat (char *dst, const char *src)
d36 1
a36 1
   return _mesa_strcpy (dst + _mesa_strlen (dst), src);
a38 1

d153 5
a157 3
         slang_atom_entry *next = entry->next;
         _slang_free(entry->id);
         _slang_free(entry);
d159 2
a160 2
      }
   }
d166 1
a166 2
 * Returns ATOM_NULL if the atom was not found and the function failed
 * to create a new atom.
d188 2
a189 4
   /* Now the hash points to a linked list of atoms with names that
    * have the same hash value.  Search the linked list for a given
    * name.
    */
d200 2
a201 3
    * Note that the <entry> points to the last entry's <next> field.
    */
   *entry = (slang_atom_entry *) _slang_alloc(sizeof(slang_atom_entry));
d205 2
a206 4
   /* Initialize a new entry. Because we'll need the actual name of
    * the atom, we use the pointer to this string as an actual atom's
    * value.
    */
d208 1
a208 1
   (**entry).id = _slang_strdup(id);
d214 1
a214 1
/**
d220 1
a220 1
   return (const char *) (atom);
d222 1
@


