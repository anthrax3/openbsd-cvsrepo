head	1.4;
access;
symbols
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2011.10.23.13.37.45;	author matthieu;	state dead;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.33;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.11;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.11;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.31.51;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge Mesa 7.10.3
@
text
@/*
 * Mesa 3-D graphics library
 * Version:  6.5
 *
 * Copyright (C) 2005-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file slang_storage.c
 * slang variable storage
 * \author Michal Krol
 */

#include "main/imports.h"
#include "slang_storage.h"
#include "slang_mem.h"

/* slang_storage_array */

GLboolean
slang_storage_array_construct(slang_storage_array * arr)
{
   arr->type = SLANG_STORE_AGGREGATE;
   arr->aggregate = NULL;
   arr->length = 0;
   return GL_TRUE;
}

GLvoid
slang_storage_array_destruct(slang_storage_array * arr)
{
   if (arr->aggregate != NULL) {
      slang_storage_aggregate_destruct(arr->aggregate);
      _slang_free(arr->aggregate);
   }
}

/* slang_storage_aggregate */

GLboolean
slang_storage_aggregate_construct(slang_storage_aggregate * agg)
{
   agg->arrays = NULL;
   agg->count = 0;
   return GL_TRUE;
}

GLvoid
slang_storage_aggregate_destruct(slang_storage_aggregate * agg)
{
   GLuint i;

   for (i = 0; i < agg->count; i++)
      slang_storage_array_destruct(agg->arrays + i);
   _slang_free(agg->arrays);
}

static slang_storage_array *
slang_storage_aggregate_push_new(slang_storage_aggregate * agg)
{
   slang_storage_array *arr = NULL;

   agg->arrays = (slang_storage_array *)
      _slang_realloc(agg->arrays,
                     agg->count * sizeof(slang_storage_array),
                     (agg->count + 1) * sizeof(slang_storage_array));
   if (agg->arrays != NULL) {
      arr = agg->arrays + agg->count;
      if (!slang_storage_array_construct(arr))
         return NULL;
      agg->count++;
   }
   return arr;
}

/* _slang_aggregate_variable() */

static GLboolean
aggregate_vector(slang_storage_aggregate * agg, slang_storage_type basic_type,
                 GLuint row_count)
{
   slang_storage_array *arr = slang_storage_aggregate_push_new(agg);
   if (arr == NULL)
      return GL_FALSE;
   arr->type = basic_type;
   arr->length = row_count;
   return GL_TRUE;
}

static GLboolean
aggregate_matrix(slang_storage_aggregate * agg, slang_storage_type basic_type,
                 GLuint columns, GLuint rows)
{
   slang_storage_array *arr = slang_storage_aggregate_push_new(agg);
   if (arr == NULL)
      return GL_FALSE;
   arr->type = SLANG_STORE_AGGREGATE;
   arr->length = columns;
   arr->aggregate = (slang_storage_aggregate *)
      _slang_alloc(sizeof(slang_storage_aggregate));
   if (arr->aggregate == NULL)
      return GL_FALSE;
   if (!slang_storage_aggregate_construct(arr->aggregate)) {
      _slang_free(arr->aggregate);
      arr->aggregate = NULL;
      return GL_FALSE;
   }
   if (!aggregate_vector(arr->aggregate, basic_type, rows))
      return GL_FALSE;
   return GL_TRUE;
}


static GLboolean
aggregate_variables(slang_storage_aggregate * agg,
                    slang_variable_scope * vars, slang_function_scope * funcs,
                    slang_struct_scope * structs,
                    slang_variable_scope * globals,
                    slang_atom_pool * atoms)
{
   GLuint i;

   for (i = 0; i < vars->num_variables; i++)
      if (!_slang_aggregate_variable(agg, &vars->variables[i]->type.specifier,
                                     vars->variables[i]->array_len, funcs,
                                     structs, globals, atoms))
         return GL_FALSE;
   return GL_TRUE;
}


GLboolean
_slang_aggregate_variable(slang_storage_aggregate * agg,
                          slang_type_specifier * spec, GLuint array_len,
                          slang_function_scope * funcs,
                          slang_struct_scope * structs,
                          slang_variable_scope * vars,
                          slang_atom_pool * atoms)
{
   switch (spec->type) {
   case SLANG_SPEC_BOOL:
      return aggregate_vector(agg, SLANG_STORE_BOOL, 1);
   case SLANG_SPEC_BVEC2:
      return aggregate_vector(agg, SLANG_STORE_BOOL, 2);
   case SLANG_SPEC_BVEC3:
      return aggregate_vector(agg, SLANG_STORE_BOOL, 3);
   case SLANG_SPEC_BVEC4:
      return aggregate_vector(agg, SLANG_STORE_BOOL, 4);
   case SLANG_SPEC_INT:
      return aggregate_vector(agg, SLANG_STORE_INT, 1);
   case SLANG_SPEC_IVEC2:
      return aggregate_vector(agg, SLANG_STORE_INT, 2);
   case SLANG_SPEC_IVEC3:
      return aggregate_vector(agg, SLANG_STORE_INT, 3);
   case SLANG_SPEC_IVEC4:
      return aggregate_vector(agg, SLANG_STORE_INT, 4);
   case SLANG_SPEC_FLOAT:
      return aggregate_vector(agg, SLANG_STORE_FLOAT, 1);
   case SLANG_SPEC_VEC2:
      return aggregate_vector(agg, SLANG_STORE_FLOAT, 2);
   case SLANG_SPEC_VEC3:
      return aggregate_vector(agg, SLANG_STORE_FLOAT, 3);
   case SLANG_SPEC_VEC4:
      return aggregate_vector(agg, SLANG_STORE_FLOAT, 4);
   case SLANG_SPEC_MAT2:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 2, 2);
   case SLANG_SPEC_MAT3:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 3, 3);
   case SLANG_SPEC_MAT4:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 4, 4);

   case SLANG_SPEC_MAT23:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 2, 3);
   case SLANG_SPEC_MAT32:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 3, 2);
   case SLANG_SPEC_MAT24:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 2, 4);
   case SLANG_SPEC_MAT42:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 4, 2);
   case SLANG_SPEC_MAT34:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 3, 4);
   case SLANG_SPEC_MAT43:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 4, 3);

   case SLANG_SPEC_SAMPLER_1D:
   case SLANG_SPEC_SAMPLER_2D:
   case SLANG_SPEC_SAMPLER_3D:
   case SLANG_SPEC_SAMPLER_CUBE:
   case SLANG_SPEC_SAMPLER_1D_SHADOW:
   case SLANG_SPEC_SAMPLER_2D_SHADOW:
   case SLANG_SPEC_SAMPLER_RECT:
   case SLANG_SPEC_SAMPLER_RECT_SHADOW:
   case SLANG_SPEC_SAMPLER_1D_ARRAY:
   case SLANG_SPEC_SAMPLER_2D_ARRAY:
   case SLANG_SPEC_SAMPLER_1D_ARRAY_SHADOW:
   case SLANG_SPEC_SAMPLER_2D_ARRAY_SHADOW:

      return aggregate_vector(agg, SLANG_STORE_INT, 1);
   case SLANG_SPEC_STRUCT:
      return aggregate_variables(agg, spec->_struct->fields, funcs, structs,
                                 vars, atoms);
   case SLANG_SPEC_ARRAY:
      {
         slang_storage_array *arr;

         arr = slang_storage_aggregate_push_new(agg);
         if (arr == NULL)
            return GL_FALSE;
         arr->type = SLANG_STORE_AGGREGATE;
         arr->aggregate = (slang_storage_aggregate *)
            _slang_alloc(sizeof(slang_storage_aggregate));
         if (arr->aggregate == NULL)
            return GL_FALSE;
         if (!slang_storage_aggregate_construct(arr->aggregate)) {
            _slang_free(arr->aggregate);
            arr->aggregate = NULL;
            return GL_FALSE;
         }
         if (!_slang_aggregate_variable(arr->aggregate, spec->_array, 0,
                                        funcs, structs, vars, atoms))
            return GL_FALSE;
         arr->length = array_len;
         /* TODO: check if 0 < arr->length <= 65535 */
      }
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
}


GLuint
_slang_sizeof_type(slang_storage_type type)
{
   if (type == SLANG_STORE_AGGREGATE)
      return 0;
   if (type == SLANG_STORE_VEC4)
      return 4 * sizeof(GLfloat);
   return sizeof(GLfloat);
}


GLuint
_slang_sizeof_aggregate(const slang_storage_aggregate * agg)
{
   GLuint i, size = 0;

   for (i = 0; i < agg->count; i++) {
      slang_storage_array *arr = &agg->arrays[i];
      GLuint element_size;

      if (arr->type == SLANG_STORE_AGGREGATE)
         element_size = _slang_sizeof_aggregate(arr->aggregate);
      else
         element_size = _slang_sizeof_type(arr->type);
      size += element_size * arr->length;
   }
   return size;
}


#if 0
GLboolean
_slang_flatten_aggregate(slang_storage_aggregate * flat,
                         const slang_storage_aggregate * agg)
{
   GLuint i;

   for (i = 0; i < agg->count; i++) {
      GLuint j;

      for (j = 0; j < agg->arrays[i].length; j++) {
         if (agg->arrays[i].type == SLANG_STORE_AGGREGATE) {
            if (!_slang_flatten_aggregate(flat, agg->arrays[i].aggregate))
               return GL_FALSE;
         }
         else {
            GLuint k, count;
            slang_storage_type type;

            if (agg->arrays[i].type == SLANG_STORE_VEC4) {
               count = 4;
               type = SLANG_STORE_FLOAT;
            }
            else {
               count = 1;
               type = agg->arrays[i].type;
            }

            for (k = 0; k < count; k++) {
               slang_storage_array *arr;

               arr = slang_storage_aggregate_push_new(flat);
               if (arr == NULL)
                  return GL_FALSE;
               arr->type = type;
               arr->length = 1;
            }
         }
      }
   }
   return GL_TRUE;
}
#endif
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d202 13
a214 8
   case SLANG_SPEC_SAMPLER1D:
   case SLANG_SPEC_SAMPLER2D:
   case SLANG_SPEC_SAMPLER3D:
   case SLANG_SPEC_SAMPLERCUBE:
   case SLANG_SPEC_SAMPLER1DSHADOW:
   case SLANG_SPEC_SAMPLER2DSHADOW:
   case SLANG_SPEC_SAMPLER2DRECT:
   case SLANG_SPEC_SAMPLER2DRECTSHADOW:
@


1.1
log
@Initial revision
@
text
@d31 1
a31 1
#include "imports.h"
d33 1
d37 2
a38 1
GLboolean slang_storage_array_construct (slang_storage_array *arr)
d40 4
a43 4
	arr->type = slang_stor_aggregate;
	arr->aggregate = NULL;
	arr->length = 0;
	return GL_TRUE;
d46 2
a47 1
GLvoid slang_storage_array_destruct (slang_storage_array *arr)
d49 4
a52 5
	if (arr->aggregate != NULL)
	{
		slang_storage_aggregate_destruct (arr->aggregate);
		slang_alloc_free (arr->aggregate);
	}
d57 2
a58 1
GLboolean slang_storage_aggregate_construct (slang_storage_aggregate *agg)
d60 3
a62 3
	agg->arrays = NULL;
	agg->count = 0;
	return GL_TRUE;
d65 2
a66 1
GLvoid slang_storage_aggregate_destruct (slang_storage_aggregate *agg)
d68 1
a68 1
	GLuint i;
d70 58
a127 3
	for (i = 0; i < agg->count; i++)
		slang_storage_array_destruct (agg->arrays + i);
	slang_alloc_free (agg->arrays);
d130 7
a136 1
static slang_storage_array *slang_storage_aggregate_push_new (slang_storage_aggregate *agg)
d138 1
a138 1
	slang_storage_array *arr = NULL;
d140 6
a145 10
	agg->arrays = (slang_storage_array *) slang_alloc_realloc (agg->arrays, agg->count * sizeof (
		slang_storage_array), (agg->count + 1) * sizeof (slang_storage_array));
	if (agg->arrays != NULL)
	{
		arr = agg->arrays + agg->count;
		if (!slang_storage_array_construct (arr))
			return NULL;
		agg->count++;
	}
	return arr;
a147 1
/* _slang_aggregate_variable() */
d149 92
a240 178
static GLboolean aggregate_vector (slang_storage_aggregate *agg, slang_storage_type basic_type,
	GLuint row_count)
{
	slang_storage_array *arr = slang_storage_aggregate_push_new (agg);
	if (arr == NULL)
		return GL_FALSE;
	arr->type = basic_type;
	arr->length = row_count;
	return GL_TRUE;
}

static GLboolean aggregate_matrix (slang_storage_aggregate *agg, slang_storage_type basic_type,
	GLuint dimension)
{
	slang_storage_array *arr = slang_storage_aggregate_push_new (agg);
	if (arr == NULL)
		return GL_FALSE;
	arr->type = slang_stor_aggregate;
	arr->length = dimension;
	arr->aggregate = (slang_storage_aggregate *) slang_alloc_malloc (sizeof (slang_storage_aggregate));
	if (arr->aggregate == NULL)
		return GL_FALSE;
	if (!slang_storage_aggregate_construct (arr->aggregate))
	{
		slang_alloc_free (arr->aggregate);
		arr->aggregate = NULL;
		return GL_FALSE;
	}
	if (!aggregate_vector (arr->aggregate, basic_type, dimension))
		return GL_FALSE;
	return GL_TRUE;
}

static GLboolean aggregate_variables (slang_storage_aggregate *agg, slang_variable_scope *vars,
	slang_function_scope *funcs, slang_struct_scope *structs, slang_variable_scope *globals,
	slang_machine *mach, slang_assembly_file *file, slang_atom_pool *atoms)
{
	GLuint i;

	for (i = 0; i < vars->num_variables; i++)
		if (!_slang_aggregate_variable (agg, &vars->variables[i].type.specifier,
				vars->variables[i].array_len, funcs, structs, globals, mach, file, atoms))
			return GL_FALSE;
	return GL_TRUE;
}

GLboolean _slang_evaluate_int (slang_assembly_file *file, slang_machine *pmach,
	slang_assembly_name_space *space, slang_operation *array_size, GLuint *pint,
	slang_atom_pool *atoms)
{
	slang_assembly_file_restore_point point;
	slang_machine mach;
	slang_assemble_ctx A;

	A.file = file;
	A.mach = pmach;
	A.atoms = atoms;
	A.space = *space;
	A.local.ret_size = 0;
	A.local.addr_tmp = 0;
	A.local.swizzle_tmp = 4;

	/* save the current assembly */
	if (!slang_assembly_file_restore_point_save (file, &point))
		return GL_FALSE;

	/* setup the machine */
	mach = *pmach;
	mach.ip = file->count;

	/* allocate local storage for expression */
	if (!slang_assembly_file_push_label (file, slang_asm_local_alloc, 20))
		return GL_FALSE;
	if (!slang_assembly_file_push_label (file, slang_asm_enter, 20))
		return GL_FALSE;

	/* insert the actual expression */
	if (!_slang_assemble_operation (&A, array_size, slang_ref_forbid))
		return GL_FALSE;
	if (!slang_assembly_file_push (file, slang_asm_exit))
		return GL_FALSE;

	/* execute the expression */
	if (!_slang_execute2 (file, &mach))
		return GL_FALSE;

	/* the evaluated expression is on top of the stack */
	*pint = (GLuint) mach.mem[mach.sp + SLANG_MACHINE_GLOBAL_SIZE]._float;

	/* restore the old assembly */
	if (!slang_assembly_file_restore_point_load (file, &point))
		return GL_FALSE;

	return GL_TRUE;
}

GLboolean _slang_aggregate_variable (slang_storage_aggregate *agg, slang_type_specifier *spec,
	GLuint array_len, slang_function_scope *funcs, slang_struct_scope *structs,
	slang_variable_scope *vars, slang_machine *mach, slang_assembly_file *file,
	slang_atom_pool *atoms)
{
	switch (spec->type)
	{
	case slang_spec_bool:
		return aggregate_vector (agg, slang_stor_bool, 1);
	case slang_spec_bvec2:
		return aggregate_vector (agg, slang_stor_bool, 2);
	case slang_spec_bvec3:
		return aggregate_vector (agg, slang_stor_bool, 3);
	case slang_spec_bvec4:
		return aggregate_vector (agg, slang_stor_bool, 4);
	case slang_spec_int:
		return aggregate_vector (agg, slang_stor_int, 1);
	case slang_spec_ivec2:
		return aggregate_vector (agg, slang_stor_int, 2);
	case slang_spec_ivec3:
		return aggregate_vector (agg, slang_stor_int, 3);
	case slang_spec_ivec4:
		return aggregate_vector (agg, slang_stor_int, 4);
	case slang_spec_float:
		return aggregate_vector (agg, slang_stor_float, 1);
	case slang_spec_vec2:
		return aggregate_vector (agg, slang_stor_float, 2);
	case slang_spec_vec3:
		return aggregate_vector (agg, slang_stor_float, 3);
   case slang_spec_vec4:
#if defined(USE_X86_ASM) || defined(SLANG_X86)
      return aggregate_vector (agg, slang_stor_vec4, 1);
#else
      return aggregate_vector (agg, slang_stor_float, 4);
#endif
	case slang_spec_mat2:
		return aggregate_matrix (agg, slang_stor_float, 2);
	case slang_spec_mat3:
		return aggregate_matrix (agg, slang_stor_float, 3);
   case slang_spec_mat4:
#if defined(USE_X86_ASM) || defined(SLANG_X86)
      return aggregate_vector (agg, slang_stor_vec4, 4);
#else
      return aggregate_matrix (agg, slang_stor_float, 4);
#endif
	case slang_spec_sampler1D:
	case slang_spec_sampler2D:
	case slang_spec_sampler3D:
	case slang_spec_samplerCube:
	case slang_spec_sampler1DShadow:
	case slang_spec_sampler2DShadow:
		return aggregate_vector (agg, slang_stor_int, 1);
	case slang_spec_struct:
		return aggregate_variables (agg, spec->_struct->fields, funcs, structs, vars, mach,
			file, atoms);
	case slang_spec_array:
		{
			slang_storage_array *arr;

			arr = slang_storage_aggregate_push_new (agg);
			if (arr == NULL)
				return GL_FALSE;
			arr->type = slang_stor_aggregate;
			arr->aggregate = (slang_storage_aggregate *) slang_alloc_malloc (sizeof (slang_storage_aggregate));
			if (arr->aggregate == NULL)
				return GL_FALSE;
			if (!slang_storage_aggregate_construct (arr->aggregate))
			{
				slang_alloc_free (arr->aggregate);
				arr->aggregate = NULL;
				return GL_FALSE;
			}
			if (!_slang_aggregate_variable (arr->aggregate, spec->_array, 0, funcs, structs,
					vars, mach, file, atoms))
				return GL_FALSE;
			arr->length = array_len;
			/* TODO: check if 0 < arr->length <= 65535 */
		}
		return GL_TRUE;
	default:
		return GL_FALSE;
	}
a242 1
/* _slang_sizeof_type() */
d245 1
a245 1
_slang_sizeof_type (slang_storage_type type)
d247 1
a247 1
   if (type == slang_stor_aggregate)
d249 3
a251 3
   if (type == slang_stor_vec4)
      return 4 * sizeof (GLfloat);
   return sizeof (GLfloat);
a253 1
/* _slang_sizeof_aggregate() */
d255 2
a256 1
GLuint _slang_sizeof_aggregate (const slang_storage_aggregate *agg)
d264 2
a265 2
      if (arr->type == slang_stor_aggregate)
         element_size = _slang_sizeof_aggregate (arr->aggregate);
d267 1
a267 1
         element_size = _slang_sizeof_type (arr->type);
a272 1
/* _slang_flatten_aggregate () */
d274 1
d276 2
a277 1
_slang_flatten_aggregate (slang_storage_aggregate *flat, const slang_storage_aggregate *agg)
d285 2
a286 2
         if (agg->arrays[i].type == slang_stor_aggregate) {
            if (!_slang_flatten_aggregate (flat, agg->arrays[i].aggregate))
d293 1
a293 1
            if (agg->arrays[i].type == slang_stor_vec4) {
d295 1
a295 1
               type = slang_stor_float;
d305 1
a305 1
               arr = slang_storage_aggregate_push_new (flat);
d316 1
a316 1

@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@a32 1
#include "slang_mem.h"
d36 1
a36 2
GLboolean
slang_storage_array_construct(slang_storage_array * arr)
d38 4
a41 4
   arr->type = SLANG_STORE_AGGREGATE;
   arr->aggregate = NULL;
   arr->length = 0;
   return GL_TRUE;
d44 1
a44 2
GLvoid
slang_storage_array_destruct(slang_storage_array * arr)
d46 5
a50 4
   if (arr->aggregate != NULL) {
      slang_storage_aggregate_destruct(arr->aggregate);
      _slang_free(arr->aggregate);
   }
d55 1
a55 2
GLboolean
slang_storage_aggregate_construct(slang_storage_aggregate * agg)
d57 3
a59 3
   agg->arrays = NULL;
   agg->count = 0;
   return GL_TRUE;
d62 1
a62 2
GLvoid
slang_storage_aggregate_destruct(slang_storage_aggregate * agg)
d64 1
a64 1
   GLuint i;
d66 3
a68 21
   for (i = 0; i < agg->count; i++)
      slang_storage_array_destruct(agg->arrays + i);
   _slang_free(agg->arrays);
}

static slang_storage_array *
slang_storage_aggregate_push_new(slang_storage_aggregate * agg)
{
   slang_storage_array *arr = NULL;

   agg->arrays = (slang_storage_array *)
      _slang_realloc(agg->arrays,
                     agg->count * sizeof(slang_storage_array),
                     (agg->count + 1) * sizeof(slang_storage_array));
   if (agg->arrays != NULL) {
      arr = agg->arrays + agg->count;
      if (!slang_storage_array_construct(arr))
         return NULL;
      agg->count++;
   }
   return arr;
d71 3
a73 1
/* _slang_aggregate_variable() */
d75 10
a84 33
static GLboolean
aggregate_vector(slang_storage_aggregate * agg, slang_storage_type basic_type,
                 GLuint row_count)
{
   slang_storage_array *arr = slang_storage_aggregate_push_new(agg);
   if (arr == NULL)
      return GL_FALSE;
   arr->type = basic_type;
   arr->length = row_count;
   return GL_TRUE;
}

static GLboolean
aggregate_matrix(slang_storage_aggregate * agg, slang_storage_type basic_type,
                 GLuint columns, GLuint rows)
{
   slang_storage_array *arr = slang_storage_aggregate_push_new(agg);
   if (arr == NULL)
      return GL_FALSE;
   arr->type = SLANG_STORE_AGGREGATE;
   arr->length = columns;
   arr->aggregate = (slang_storage_aggregate *)
      _slang_alloc(sizeof(slang_storage_aggregate));
   if (arr->aggregate == NULL)
      return GL_FALSE;
   if (!slang_storage_aggregate_construct(arr->aggregate)) {
      _slang_free(arr->aggregate);
      arr->aggregate = NULL;
      return GL_FALSE;
   }
   if (!aggregate_vector(arr->aggregate, basic_type, rows))
      return GL_FALSE;
   return GL_TRUE;
d87 1
d89 2
a90 6
static GLboolean
aggregate_variables(slang_storage_aggregate * agg,
                    slang_variable_scope * vars, slang_function_scope * funcs,
                    slang_struct_scope * structs,
                    slang_variable_scope * globals,
                    slang_atom_pool * atoms)
d92 175
a266 103
   GLuint i;

   for (i = 0; i < vars->num_variables; i++)
      if (!_slang_aggregate_variable(agg, &vars->variables[i]->type.specifier,
                                     vars->variables[i]->array_len, funcs,
                                     structs, globals, atoms))
         return GL_FALSE;
   return GL_TRUE;
}


GLboolean
_slang_aggregate_variable(slang_storage_aggregate * agg,
                          slang_type_specifier * spec, GLuint array_len,
                          slang_function_scope * funcs,
                          slang_struct_scope * structs,
                          slang_variable_scope * vars,
                          slang_atom_pool * atoms)
{
   switch (spec->type) {
   case SLANG_SPEC_BOOL:
      return aggregate_vector(agg, SLANG_STORE_BOOL, 1);
   case SLANG_SPEC_BVEC2:
      return aggregate_vector(agg, SLANG_STORE_BOOL, 2);
   case SLANG_SPEC_BVEC3:
      return aggregate_vector(agg, SLANG_STORE_BOOL, 3);
   case SLANG_SPEC_BVEC4:
      return aggregate_vector(agg, SLANG_STORE_BOOL, 4);
   case SLANG_SPEC_INT:
      return aggregate_vector(agg, SLANG_STORE_INT, 1);
   case SLANG_SPEC_IVEC2:
      return aggregate_vector(agg, SLANG_STORE_INT, 2);
   case SLANG_SPEC_IVEC3:
      return aggregate_vector(agg, SLANG_STORE_INT, 3);
   case SLANG_SPEC_IVEC4:
      return aggregate_vector(agg, SLANG_STORE_INT, 4);
   case SLANG_SPEC_FLOAT:
      return aggregate_vector(agg, SLANG_STORE_FLOAT, 1);
   case SLANG_SPEC_VEC2:
      return aggregate_vector(agg, SLANG_STORE_FLOAT, 2);
   case SLANG_SPEC_VEC3:
      return aggregate_vector(agg, SLANG_STORE_FLOAT, 3);
   case SLANG_SPEC_VEC4:
      return aggregate_vector(agg, SLANG_STORE_FLOAT, 4);
   case SLANG_SPEC_MAT2:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 2, 2);
   case SLANG_SPEC_MAT3:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 3, 3);
   case SLANG_SPEC_MAT4:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 4, 4);

   case SLANG_SPEC_MAT23:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 2, 3);
   case SLANG_SPEC_MAT32:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 3, 2);
   case SLANG_SPEC_MAT24:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 2, 4);
   case SLANG_SPEC_MAT42:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 4, 2);
   case SLANG_SPEC_MAT34:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 3, 4);
   case SLANG_SPEC_MAT43:
      return aggregate_matrix(agg, SLANG_STORE_FLOAT, 4, 3);

   case SLANG_SPEC_SAMPLER1D:
   case SLANG_SPEC_SAMPLER2D:
   case SLANG_SPEC_SAMPLER3D:
   case SLANG_SPEC_SAMPLERCUBE:
   case SLANG_SPEC_SAMPLER1DSHADOW:
   case SLANG_SPEC_SAMPLER2DSHADOW:
   case SLANG_SPEC_SAMPLER2DRECT:
   case SLANG_SPEC_SAMPLER2DRECTSHADOW:
      return aggregate_vector(agg, SLANG_STORE_INT, 1);
   case SLANG_SPEC_STRUCT:
      return aggregate_variables(agg, spec->_struct->fields, funcs, structs,
                                 vars, atoms);
   case SLANG_SPEC_ARRAY:
      {
         slang_storage_array *arr;

         arr = slang_storage_aggregate_push_new(agg);
         if (arr == NULL)
            return GL_FALSE;
         arr->type = SLANG_STORE_AGGREGATE;
         arr->aggregate = (slang_storage_aggregate *)
            _slang_alloc(sizeof(slang_storage_aggregate));
         if (arr->aggregate == NULL)
            return GL_FALSE;
         if (!slang_storage_aggregate_construct(arr->aggregate)) {
            _slang_free(arr->aggregate);
            arr->aggregate = NULL;
            return GL_FALSE;
         }
         if (!_slang_aggregate_variable(arr->aggregate, spec->_array, 0,
                                        funcs, structs, vars, atoms))
            return GL_FALSE;
         arr->length = array_len;
         /* TODO: check if 0 < arr->length <= 65535 */
      }
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
d269 1
d272 1
a272 1
_slang_sizeof_type(slang_storage_type type)
d274 1
a274 1
   if (type == SLANG_STORE_AGGREGATE)
d276 3
a278 3
   if (type == SLANG_STORE_VEC4)
      return 4 * sizeof(GLfloat);
   return sizeof(GLfloat);
d281 1
d283 1
a283 2
GLuint
_slang_sizeof_aggregate(const slang_storage_aggregate * agg)
d291 2
a292 2
      if (arr->type == SLANG_STORE_AGGREGATE)
         element_size = _slang_sizeof_aggregate(arr->aggregate);
d294 1
a294 1
         element_size = _slang_sizeof_type(arr->type);
d300 1
a301 1
#if 0
d303 1
a303 2
_slang_flatten_aggregate(slang_storage_aggregate * flat,
                         const slang_storage_aggregate * agg)
d311 2
a312 2
         if (agg->arrays[i].type == SLANG_STORE_AGGREGATE) {
            if (!_slang_flatten_aggregate(flat, agg->arrays[i].aggregate))
d319 1
a319 1
            if (agg->arrays[i].type == SLANG_STORE_VEC4) {
d321 1
a321 1
               type = SLANG_STORE_FLOAT;
d331 1
a331 1
               arr = slang_storage_aggregate_push_new(flat);
d342 1
a342 1
#endif
@

