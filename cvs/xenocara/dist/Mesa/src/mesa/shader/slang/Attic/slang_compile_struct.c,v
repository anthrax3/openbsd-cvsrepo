head	1.3;
access;
symbols
	OPENBSD_5_0:1.2.0.12
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.8
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.10
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2011.10.23.13.37.45;	author matthieu;	state dead;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.08;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.31.45;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Merge Mesa 7.10.3
@
text
@/*
 * Mesa 3-D graphics library
 * Version:  6.5.3
 *
 * Copyright (C) 2005-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file slang_compile_struct.c
 * slang front-end compiler
 * \author Michal Krol
 */

#include "main/imports.h"
#include "slang_mem.h"
#include "slang_compile.h"


GLvoid
_slang_struct_scope_ctr(slang_struct_scope * self)
{
   self->structs = NULL;
   self->num_structs = 0;
   self->outer_scope = NULL;
}

void
slang_struct_scope_destruct(slang_struct_scope * scope)
{
   GLuint i;

   for (i = 0; i < scope->num_structs; i++)
      slang_struct_destruct(scope->structs + i);
   _slang_free(scope->structs);
   /* do not free scope->outer_scope */
}

int
slang_struct_scope_copy(slang_struct_scope * x, const slang_struct_scope * y)
{
   slang_struct_scope z;
   GLuint i;

   _slang_struct_scope_ctr(&z);
   z.structs = (slang_struct *)
      _slang_alloc(y->num_structs * sizeof(slang_struct));
   if (z.structs == NULL) {
      slang_struct_scope_destruct(&z);
      return 0;
   }
   for (z.num_structs = 0; z.num_structs < y->num_structs; z.num_structs++)
      if (!slang_struct_construct(&z.structs[z.num_structs])) {
         slang_struct_scope_destruct(&z);
         return 0;
      }
   for (i = 0; i < z.num_structs; i++)
      if (!slang_struct_copy(&z.structs[i], &y->structs[i])) {
         slang_struct_scope_destruct(&z);
         return 0;
      }
   z.outer_scope = y->outer_scope;
   slang_struct_scope_destruct(x);
   *x = z;
   return 1;
}

slang_struct *
slang_struct_scope_find(slang_struct_scope * stru, slang_atom a_name,
                        int all_scopes)
{
   GLuint i;

   for (i = 0; i < stru->num_structs; i++)
      if (a_name == stru->structs[i].a_name)
         return &stru->structs[i];
   if (all_scopes && stru->outer_scope != NULL)
      return slang_struct_scope_find(stru->outer_scope, a_name, 1);
   return NULL;
}

/* slang_struct */

int
slang_struct_construct(slang_struct * stru)
{
   stru->a_name = SLANG_ATOM_NULL;
   stru->fields = (slang_variable_scope *)
      _slang_alloc(sizeof(slang_variable_scope));
   if (stru->fields == NULL)
      return 0;
   _slang_variable_scope_ctr(stru->fields);

   stru->structs =
      (slang_struct_scope *) _slang_alloc(sizeof(slang_struct_scope));
   if (stru->structs == NULL) {
      slang_variable_scope_destruct(stru->fields);
      _slang_free(stru->fields);
      return 0;
   }
   _slang_struct_scope_ctr(stru->structs);
   stru->constructor = NULL;
   return 1;
}

void
slang_struct_destruct(slang_struct * stru)
{
   slang_variable_scope_destruct(stru->fields);
   _slang_free(stru->fields);
   slang_struct_scope_destruct(stru->structs);
   _slang_free(stru->structs);
}

int
slang_struct_copy(slang_struct * x, const slang_struct * y)
{
   slang_struct z;

   if (!slang_struct_construct(&z))
      return 0;
   z.a_name = y->a_name;
   if (!slang_variable_scope_copy(z.fields, y->fields)) {
      slang_struct_destruct(&z);
      return 0;
   }
   if (!slang_struct_scope_copy(z.structs, y->structs)) {
      slang_struct_destruct(&z);
      return 0;
   }
   slang_struct_destruct(x);
   *x = z;
   return 1;
}

int
slang_struct_equal(const slang_struct * x, const slang_struct * y)
{
   GLuint i;

   if (x->fields->num_variables != y->fields->num_variables)
      return 0;

   for (i = 0; i < x->fields->num_variables; i++) {
      const slang_variable *varx = x->fields->variables[i];
      const slang_variable *vary = y->fields->variables[i];

      if (varx->a_name != vary->a_name)
         return 0;
      if (!slang_type_specifier_equal(&varx->type.specifier,
                                      &vary->type.specifier))
         return 0;
      if (varx->type.specifier.type == SLANG_SPEC_ARRAY)
         if (varx->array_len != vary->array_len)
            return GL_FALSE;
   }
   return 1;
}
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 2005-2006  Brian Paul   All Rights Reserved.
d31 2
a32 1
#include "imports.h"
a34 3
/*
 * slang_struct_scope
 */
d37 1
a37 1
_slang_struct_scope_ctr (slang_struct_scope *self)
d44 2
a45 1
void slang_struct_scope_destruct (slang_struct_scope *scope)
d47 1
a47 1
	unsigned int i;
d49 47
a95 46
	for (i = 0; i < scope->num_structs; i++)
		slang_struct_destruct (scope->structs + i);
	slang_alloc_free (scope->structs);
	/* do not free scope->outer_scope */
}

int slang_struct_scope_copy (slang_struct_scope *x, const slang_struct_scope *y)
{
	slang_struct_scope z;
	unsigned int i;

   _slang_struct_scope_ctr (&z);
	z.structs = (slang_struct *) slang_alloc_malloc (y->num_structs * sizeof (slang_struct));
	if (z.structs == NULL)
	{
		slang_struct_scope_destruct (&z);
		return 0;
	}
	for (z.num_structs = 0; z.num_structs < y->num_structs; z.num_structs++)
		if (!slang_struct_construct (&z.structs[z.num_structs]))
		{
			slang_struct_scope_destruct (&z);
			return 0;
		}
	for (i = 0; i < z.num_structs; i++)
		if (!slang_struct_copy (&z.structs[i], &y->structs[i]))
		{
			slang_struct_scope_destruct (&z);
			return 0;
		}
	z.outer_scope = y->outer_scope;
	slang_struct_scope_destruct (x);
	*x = z;
	return 1;
}

slang_struct *slang_struct_scope_find (slang_struct_scope *stru, slang_atom a_name, int all_scopes)
{
	unsigned int i;

	for (i = 0; i < stru->num_structs; i++)
		if (a_name == stru->structs[i].a_name)
			return &stru->structs[i];
	if (all_scopes && stru->outer_scope != NULL)
		return slang_struct_scope_find (stru->outer_scope, a_name, 1);
	return NULL;
d100 2
a101 1
int slang_struct_construct (slang_struct *stru)
d103 71
a173 66
	stru->a_name = SLANG_ATOM_NULL;
	stru->fields = (slang_variable_scope *) slang_alloc_malloc (sizeof (slang_variable_scope));
	if (stru->fields == NULL)
		return 0;
   _slang_variable_scope_ctr (stru->fields);
	stru->structs = (slang_struct_scope *) slang_alloc_malloc (sizeof (slang_struct_scope));
	if (stru->structs == NULL)
	{
		slang_variable_scope_destruct (stru->fields);
		slang_alloc_free (stru->fields);
		return 0;
	}
   _slang_struct_scope_ctr (stru->structs);
	return 1;
}

void slang_struct_destruct (slang_struct *stru)
{
	slang_variable_scope_destruct (stru->fields);
	slang_alloc_free (stru->fields);
	slang_struct_scope_destruct (stru->structs);
	slang_alloc_free (stru->structs);
}

int slang_struct_copy (slang_struct *x, const slang_struct *y)
{
	slang_struct z;

	if (!slang_struct_construct (&z))
		return 0;
	z.a_name = y->a_name;
	if (!slang_variable_scope_copy (z.fields, y->fields))
	{
		slang_struct_destruct (&z);
		return 0;
	}
	if (!slang_struct_scope_copy (z.structs, y->structs))
	{
		slang_struct_destruct (&z);
		return 0;
	}
	slang_struct_destruct (x);
	*x = z;
	return 1;
}

int slang_struct_equal (const slang_struct *x, const slang_struct *y)
{
	unsigned int i;

	if (x->fields->num_variables != y->fields->num_variables)
		return 0;
	for (i = 0; i < x->fields->num_variables; i++)
	{
		slang_variable *varx = &x->fields->variables[i];
		slang_variable *vary = &y->fields->variables[i];

		if (varx->a_name != vary->a_name)
			return 0;
		if (!slang_type_specifier_equal (&varx->type.specifier, &vary->type.specifier))
			return 0;
		if (varx->type.specifier.type == slang_spec_array)
			if (varx->array_len != vary->array_len)
				return GL_FALSE;
	}
	return 1;
a174 1

@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 2005-2007  Brian Paul   All Rights Reserved.
a31 1
#include "slang_mem.h"
d34 3
d39 1
a39 1
_slang_struct_scope_ctr(slang_struct_scope * self)
d46 1
a46 2
void
slang_struct_scope_destruct(slang_struct_scope * scope)
d48 1
a48 1
   GLuint i;
d50 46
a95 47
   for (i = 0; i < scope->num_structs; i++)
      slang_struct_destruct(scope->structs + i);
   _slang_free(scope->structs);
   /* do not free scope->outer_scope */
}

int
slang_struct_scope_copy(slang_struct_scope * x, const slang_struct_scope * y)
{
   slang_struct_scope z;
   GLuint i;

   _slang_struct_scope_ctr(&z);
   z.structs = (slang_struct *)
      _slang_alloc(y->num_structs * sizeof(slang_struct));
   if (z.structs == NULL) {
      slang_struct_scope_destruct(&z);
      return 0;
   }
   for (z.num_structs = 0; z.num_structs < y->num_structs; z.num_structs++)
      if (!slang_struct_construct(&z.structs[z.num_structs])) {
         slang_struct_scope_destruct(&z);
         return 0;
      }
   for (i = 0; i < z.num_structs; i++)
      if (!slang_struct_copy(&z.structs[i], &y->structs[i])) {
         slang_struct_scope_destruct(&z);
         return 0;
      }
   z.outer_scope = y->outer_scope;
   slang_struct_scope_destruct(x);
   *x = z;
   return 1;
}

slang_struct *
slang_struct_scope_find(slang_struct_scope * stru, slang_atom a_name,
                        int all_scopes)
{
   GLuint i;

   for (i = 0; i < stru->num_structs; i++)
      if (a_name == stru->structs[i].a_name)
         return &stru->structs[i];
   if (all_scopes && stru->outer_scope != NULL)
      return slang_struct_scope_find(stru->outer_scope, a_name, 1);
   return NULL;
d100 1
a100 2
int
slang_struct_construct(slang_struct * stru)
d102 66
a167 70
   stru->a_name = SLANG_ATOM_NULL;
   stru->fields = (slang_variable_scope *)
      _slang_alloc(sizeof(slang_variable_scope));
   if (stru->fields == NULL)
      return 0;
   _slang_variable_scope_ctr(stru->fields);

   stru->structs =
      (slang_struct_scope *) _slang_alloc(sizeof(slang_struct_scope));
   if (stru->structs == NULL) {
      slang_variable_scope_destruct(stru->fields);
      _slang_free(stru->fields);
      return 0;
   }
   _slang_struct_scope_ctr(stru->structs);
   return 1;
}

void
slang_struct_destruct(slang_struct * stru)
{
   slang_variable_scope_destruct(stru->fields);
   _slang_free(stru->fields);
   slang_struct_scope_destruct(stru->structs);
   _slang_free(stru->structs);
}

int
slang_struct_copy(slang_struct * x, const slang_struct * y)
{
   slang_struct z;

   if (!slang_struct_construct(&z))
      return 0;
   z.a_name = y->a_name;
   if (!slang_variable_scope_copy(z.fields, y->fields)) {
      slang_struct_destruct(&z);
      return 0;
   }
   if (!slang_struct_scope_copy(z.structs, y->structs)) {
      slang_struct_destruct(&z);
      return 0;
   }
   slang_struct_destruct(x);
   *x = z;
   return 1;
}

int
slang_struct_equal(const slang_struct * x, const slang_struct * y)
{
   GLuint i;

   if (x->fields->num_variables != y->fields->num_variables)
      return 0;

   for (i = 0; i < x->fields->num_variables; i++) {
      const slang_variable *varx = x->fields->variables[i];
      const slang_variable *vary = y->fields->variables[i];

      if (varx->a_name != vary->a_name)
         return 0;
      if (!slang_type_specifier_equal(&varx->type.specifier,
                                      &vary->type.specifier))
         return 0;
      if (varx->type.specifier.type == SLANG_SPEC_ARRAY)
         if (varx->array_len != vary->array_len)
            return GL_FALSE;
   }
   return 1;
d169 1
@

