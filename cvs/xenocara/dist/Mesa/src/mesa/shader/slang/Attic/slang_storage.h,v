head	1.3;
access;
symbols
	OPENBSD_5_0:1.2.0.10
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.6
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.8
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2011.10.23.13.37.45;	author matthieu;	state dead;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.11;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.11;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.31.51;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Merge Mesa 7.10.3
@
text
@/*
 * Mesa 3-D graphics library
 * Version:  6.5
 *
 * Copyright (C) 2005-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SLANG_STORAGE_H
#define SLANG_STORAGE_H

#include "slang_compile.h"


/*
 * Program variable data storage is kept completely transparent to the
 * front-end compiler. It is up to the back-end how the data is
 * actually allocated. The slang_storage_type enum provides the basic
 * information about how the memory is interpreted. This abstract
 * piece of memory is called a data slot. A data slot of a particular
 * type has a fixed size.
 *
 * For now, only the three basic types are supported, that is bool,
 * int and float. Other built-in types like vector or matrix can
 * easily be decomposed into a series of basic types.
 *
 * If the vec4 module is enabled, 4-component vectors of floats are
 * used when possible. 4x4 matrices are constructed of 4 vec4 slots.
 */
typedef enum slang_storage_type_
{
   /* core */
   SLANG_STORE_AGGREGATE,
   SLANG_STORE_BOOL,
   SLANG_STORE_INT,
   SLANG_STORE_FLOAT,
   /* vec4 */
   SLANG_STORE_VEC4
} slang_storage_type;


/**
 * The slang_storage_array structure groups data slots of the same
 * type into an array. This array has a fixed length. Arrays are
 * required to have a size equal to the sum of sizes of its
 * elements. They are also required to support indirect
 * addressing. That is, if B references first data slot in the array,
 * S is the size of the data slot and I is the integral index that is
 * not known at compile time, B+I*S references I-th data slot.
 *
 * This structure is also used to break down built-in data types that
 * are not supported directly.  Vectors, like vec3, are constructed
 * from arrays of their basic types. Matrices are formed of an array
 * of column vectors, which are in turn processed as other vectors.
 */
typedef struct slang_storage_array_
{
   slang_storage_type type;
   struct slang_storage_aggregate_ *aggregate;
   GLuint length;
} slang_storage_array;

GLboolean slang_storage_array_construct (slang_storage_array *);
GLvoid slang_storage_array_destruct (slang_storage_array *);


/**
 * The slang_storage_aggregate structure relaxes the indirect
 * addressing requirement for slang_storage_array
 * structure. Aggregates are always accessed statically - its member
 * addresses are well-known at compile time. For example, user-defined
 * types are implemented as aggregates. Aggregates can collect data of
 * a different type.
 */
typedef struct slang_storage_aggregate_
{
   slang_storage_array *arrays;
   GLuint count;
} slang_storage_aggregate;

GLboolean slang_storage_aggregate_construct (slang_storage_aggregate *);
GLvoid slang_storage_aggregate_destruct (slang_storage_aggregate *);


extern GLboolean
_slang_aggregate_variable(slang_storage_aggregate *agg,
                          slang_type_specifier *spec,
                          GLuint array_len,
                          slang_function_scope *funcs,
                          slang_struct_scope *structs,
                          slang_variable_scope *vars,
                          slang_atom_pool *atoms);

/*
 * Returns the size (in machine units) of the given storage type.
 * It is an error to pass-in SLANG_STORE_AGGREGATE.
 * Returns 0 on error.
 */
extern GLuint
_slang_sizeof_type (slang_storage_type);


/**
 * Returns total size (in machine units) of the given aggregate.
 * Returns 0 on error.
 */
extern GLuint
_slang_sizeof_aggregate (const slang_storage_aggregate *);


#if 0
/**
 * Converts structured aggregate to a flat one, with arrays of generic
 * type being one-element long.  Returns GL_TRUE on success.  Returns
 * GL_FALSE otherwise.
 */
extern GLboolean
_slang_flatten_aggregate (slang_storage_aggregate *,
                          const slang_storage_aggregate *);

#endif

#endif /* SLANG_STORAGE_H */
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@@


1.1
log
@Initial revision
@
text
@d25 1
a25 1
#if !defined SLANG_STORAGE_H
a28 2
#include "slang_assemble.h"
#include "slang_execute.h"
a29 3
#if defined __cplusplus
extern "C" {
#endif
d32 6
a37 4
 * Program variable data storage is kept completely transparent to the front-end compiler. It is
 * up to the back-end how the data is actually allocated. The slang_storage_type enum
 * provides the basic information about how the memory is interpreted. This abstract piece
 * of memory is called a data slot. A data slot of a particular type has a fixed size.
d39 3
a41 2
 * For now, only the three basic types are supported, that is bool, int and float. Other built-in
 * types like vector or matrix can easily be decomposed into a series of basic types.
d43 2
a44 2
 * If the vec4 module is enabled, 4-component vectors of floats are used when possible. 4x4 matrices
 * are constructed of 4 vec4 slots.
d49 4
a52 4
   slang_stor_aggregate,
   slang_stor_bool,
   slang_stor_int,
   slang_stor_float,
d54 1
a54 1
   slang_stor_vec4
d57 9
a65 6
/*
 * The slang_storage_array structure groups data slots of the same type into an array. This
 * array has a fixed length. Arrays are required to have a size equal to the sum of sizes of its
 * elements. They are also required to support indirect addressing. That is, if B references
 * first data slot in the array, S is the size of the data slot and I is the integral index that
 * is not known at compile time, B+I*S references I-th data slot.
d67 4
a70 3
 * This structure is also used to break down built-in data types that are not supported directly.
 * Vectors, like vec3, are constructed from arrays of their basic types. Matrices are formed of
 * an array of column vectors, which are in turn processed as other vectors.
d74 3
a76 3
	slang_storage_type type;
	struct slang_storage_aggregate_ *aggregate;	/* slang_stor_aggregate */
	GLuint length;
d82 8
a89 5
/*
 * The slang_storage_aggregate structure relaxes the indirect addressing requirement for
 * slang_storage_array structure. Aggregates are always accessed statically - its member
 * addresses are well-known at compile time. For example, user-defined types are implemented as
 * aggregates. Aggregates can collect data of a different type.
d93 2
a94 2
	slang_storage_array *arrays;
	GLuint count;
d100 1
a107 2
                          slang_machine *mach,
                          slang_assembly_file *file,
a109 8
extern GLboolean
_slang_evaluate_int(slang_assembly_file *file,
                    slang_machine *pmach,
                    slang_assembly_name_space *space,
                    slang_operation *array_size,
                    GLuint *pint,
                    slang_atom_pool *atoms);

d112 1
a112 1
 * It is an error to pass-in slang_stor_aggregate.
d118 2
a119 1
/*
d123 3
a125 1
GLuint _slang_sizeof_aggregate (const slang_storage_aggregate *);
d127 5
a131 5
/*
 * Converts structured aggregate to a flat one, with arrays of generic type being
 * one-element long.
 * Returns GL_TRUE on success.
 * Returns GL_FALSE otherwise.
d133 3
a135 5
GLboolean _slang_flatten_aggregate (slang_storage_aggregate *, const slang_storage_aggregate *);

#ifdef __cplusplus
}
#endif
d139 1
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d25 1
a25 1
#ifndef SLANG_STORAGE_H
d29 2
a30 1
#include "slang_typeinfo.h"
d32 3
d37 4
a40 6
 * Program variable data storage is kept completely transparent to the
 * front-end compiler. It is up to the back-end how the data is
 * actually allocated. The slang_storage_type enum provides the basic
 * information about how the memory is interpreted. This abstract
 * piece of memory is called a data slot. A data slot of a particular
 * type has a fixed size.
d42 2
a43 3
 * For now, only the three basic types are supported, that is bool,
 * int and float. Other built-in types like vector or matrix can
 * easily be decomposed into a series of basic types.
d45 2
a46 2
 * If the vec4 module is enabled, 4-component vectors of floats are
 * used when possible. 4x4 matrices are constructed of 4 vec4 slots.
d51 4
a54 4
   SLANG_STORE_AGGREGATE,
   SLANG_STORE_BOOL,
   SLANG_STORE_INT,
   SLANG_STORE_FLOAT,
d56 1
a56 1
   SLANG_STORE_VEC4
d59 6
a64 9

/**
 * The slang_storage_array structure groups data slots of the same
 * type into an array. This array has a fixed length. Arrays are
 * required to have a size equal to the sum of sizes of its
 * elements. They are also required to support indirect
 * addressing. That is, if B references first data slot in the array,
 * S is the size of the data slot and I is the integral index that is
 * not known at compile time, B+I*S references I-th data slot.
d66 3
a68 4
 * This structure is also used to break down built-in data types that
 * are not supported directly.  Vectors, like vec3, are constructed
 * from arrays of their basic types. Matrices are formed of an array
 * of column vectors, which are in turn processed as other vectors.
d72 3
a74 3
   slang_storage_type type;
   struct slang_storage_aggregate_ *aggregate;
   GLuint length;
d80 5
a84 8

/**
 * The slang_storage_aggregate structure relaxes the indirect
 * addressing requirement for slang_storage_array
 * structure. Aggregates are always accessed statically - its member
 * addresses are well-known at compile time. For example, user-defined
 * types are implemented as aggregates. Aggregates can collect data of
 * a different type.
d88 2
a89 2
   slang_storage_array *arrays;
   GLuint count;
a94 1

d102 2
d106 8
d116 1
a116 1
 * It is an error to pass-in SLANG_STORE_AGGREGATE.
d122 1
a122 2

/**
d126 1
a126 2
extern GLuint
_slang_sizeof_aggregate (const slang_storage_aggregate *);
d128 7
d136 3
a138 9
#if 0
/**
 * Converts structured aggregate to a flat one, with arrays of generic
 * type being one-element long.  Returns GL_TRUE on success.  Returns
 * GL_FALSE otherwise.
 */
extern GLboolean
_slang_flatten_aggregate (slang_storage_aggregate *,
                          const slang_storage_aggregate *);
a141 1
#endif /* SLANG_STORAGE_H */
@

