head	1.5;
access;
symbols
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2011.10.23.13.37.45;	author matthieu;	state dead;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.33;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.08;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.47;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.47;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge Mesa 7.10.3
@
text
@/*
 * Mesa 3-D graphics library
 * Version:  6.5.2
 *
 * Copyright (C) 2005-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SLANG_COMPILE_OPERATION_H
#define SLANG_COMPILE_OPERATION_H


/**
 * Types of slang operations.
 * These are the types of the AST (abstract syntax tree) nodes.
 * [foo] indicates a sub-tree or reference to another type of node
 */
typedef enum slang_operation_type_
{
   SLANG_OPER_NONE,
   SLANG_OPER_BLOCK_NO_NEW_SCOPE,       /* "{" sequence "}" */
   SLANG_OPER_BLOCK_NEW_SCOPE,  /* "{" sequence "}" */
   SLANG_OPER_VARIABLE_DECL,    /* [type] [var] or [var] = [expr] */
   SLANG_OPER_ASM,
   SLANG_OPER_BREAK,            /* "break" statement */
   SLANG_OPER_CONTINUE,         /* "continue" statement */
   SLANG_OPER_DISCARD,          /* "discard" (kill fragment) statement */
   SLANG_OPER_RETURN,           /* "return" [expr]  */
   SLANG_OPER_RETURN_INLINED,   /* "return" [expr] from inlined function  */
   SLANG_OPER_LABEL,            /* a jump target */
   SLANG_OPER_EXPRESSION,       /* [expr] */
   SLANG_OPER_IF,               /* "if" [0] then [1] else [2] */
   SLANG_OPER_WHILE,            /* "while" [cond] [body] */
   SLANG_OPER_DO,               /* "do" [body] "while" [cond] */
   SLANG_OPER_FOR,              /* "for" [init] [while] [incr] [body] */
   SLANG_OPER_VOID,             /* nop */
   SLANG_OPER_LITERAL_BOOL,     /* "true" or "false" */
   SLANG_OPER_LITERAL_INT,      /* integer literal */
   SLANG_OPER_LITERAL_FLOAT,    /* float literal */
   SLANG_OPER_IDENTIFIER,       /* var name, func name, etc */
   SLANG_OPER_SEQUENCE,         /* [expr] "," [expr] "," etc */
   SLANG_OPER_ASSIGN,           /* [var] "=" [expr] */
   SLANG_OPER_ADDASSIGN,        /* [var] "+=" [expr] */
   SLANG_OPER_SUBASSIGN,        /* [var] "-=" [expr] */
   SLANG_OPER_MULASSIGN,        /* [var] "*=" [expr] */
   SLANG_OPER_DIVASSIGN,        /* [var] "/=" [expr] */
   /*SLANG_OPER_MODASSIGN, */
   /*SLANG_OPER_LSHASSIGN, */
   /*SLANG_OPER_RSHASSIGN, */
   /*SLANG_OPER_ORASSIGN, */
   /*SLANG_OPER_XORASSIGN, */
   /*SLANG_OPER_ANDASSIGN, */
   SLANG_OPER_SELECT,           /* [expr] "?" [expr] ":" [expr] */
   SLANG_OPER_LOGICALOR,        /* [expr] "||" [expr] */
   SLANG_OPER_LOGICALXOR,       /* [expr] "^^" [expr] */
   SLANG_OPER_LOGICALAND,       /* [expr] "&&" [expr] */
   /*SLANG_OPER_BITOR, */
   /*SLANG_OPER_BITXOR, */
   /*SLANG_OPER_BITAND, */
   SLANG_OPER_EQUAL,            /* [expr] "==" [expr] */
   SLANG_OPER_NOTEQUAL,         /* [expr] "!=" [expr] */
   SLANG_OPER_LESS,             /* [expr] "<" [expr] */
   SLANG_OPER_GREATER,          /* [expr] ">" [expr] */
   SLANG_OPER_LESSEQUAL,        /* [expr] "<=" [expr] */
   SLANG_OPER_GREATEREQUAL,     /* [expr] ">=" [expr] */
   /*SLANG_OPER_LSHIFT, */
   /*SLANG_OPER_RSHIFT, */
   SLANG_OPER_ADD,              /* [expr] "+" [expr] */
   SLANG_OPER_SUBTRACT,         /* [expr] "-" [expr] */
   SLANG_OPER_MULTIPLY,         /* [expr] "*" [expr] */
   SLANG_OPER_DIVIDE,           /* [expr] "/" [expr] */
   /*SLANG_OPER_MODULUS, */
   SLANG_OPER_PREINCREMENT,     /* "++" [var] */
   SLANG_OPER_PREDECREMENT,     /* "--" [var] */
   SLANG_OPER_PLUS,             /* "-" [expr] */
   SLANG_OPER_MINUS,            /* "+" [expr] */
   /*SLANG_OPER_COMPLEMENT, */
   SLANG_OPER_NOT,              /* "!" [expr] */
   SLANG_OPER_SUBSCRIPT,        /* [expr] "[" [expr] "]" */
   SLANG_OPER_CALL,             /* [func name] [param] [param] [...] */
   SLANG_OPER_NON_INLINED_CALL, /* a real function call */
   SLANG_OPER_METHOD,           /* method call, such as  v.length() */
   SLANG_OPER_FIELD,            /* i.e.: ".next" or ".xzy" or ".xxx" etc */
   SLANG_OPER_POSTINCREMENT,    /* [var] "++" */
   SLANG_OPER_POSTDECREMENT     /* [var] "--" */
} slang_operation_type;


/**
 * A slang_operation is basically a compiled instruction (such as assignment,
 * a while-loop, a conditional, a multiply, a function call, etc).
 * The AST (abstract syntax tree) is built from these nodes.
 * NOTE: This structure could have been implemented as a union of simpler
 * structs which would correspond to the operation types above.
 */
typedef struct slang_operation_
{
   slang_operation_type type;
   struct slang_operation_ *children;
   GLuint num_children;
   GLfloat literal[4];           /**< Used for float, int and bool values */
   GLuint literal_size;          /**< 1, 2, 3, or 4 */
   slang_atom a_id;              /**< type: asm, identifier, call, field */
   slang_atom a_obj;             /**< object in a method call */
   slang_variable_scope *locals; /**< local vars for scope */
   struct slang_function_ *fun;  /**< If type == SLANG_OPER_CALL */
   struct slang_variable_ *var;  /**< If type == slang_oper_identier */
   struct slang_label_ *label;   /**< If type == SLANG_OPER_LABEL */
   /** If type==SLANG_OPER_CALL and we're calling an array constructor,
    * for which there's no real function, we need to have a flag to
    * indicate such.  num_children indicates number of elements.
    */
   GLboolean array_constructor;
} slang_operation;


extern GLboolean
slang_operation_construct(slang_operation *);

extern void
slang_operation_destruct(slang_operation *);

extern void
slang_replace_scope(slang_operation *oper,
                    slang_variable_scope *oldScope,
                    slang_variable_scope *newScope);

extern GLboolean
slang_operation_copy(slang_operation *, const slang_operation *);

extern slang_operation *
slang_operation_new(GLuint count);

extern void
slang_operation_delete(slang_operation *oper);

extern void
slang_operation_free_children(slang_operation *oper);

extern slang_operation *
slang_operation_grow(GLuint *numChildren, slang_operation **children);

extern slang_operation *
slang_operation_insert(GLuint *numChildren, slang_operation **children,
                       GLuint pos);

extern slang_operation *
slang_operation_insert_child(slang_operation *oper, GLuint pos);

extern void
_slang_operation_swap(slang_operation *oper0, slang_operation *oper1);


extern void
slang_operation_add_children(slang_operation *oper, GLuint num_children);


/** Return number of children of given node */
static INLINE GLuint
slang_oper_num_children(const slang_operation *oper)
{
   return oper->num_children;
}

/** Return child of given operation node */
static INLINE slang_operation *
slang_oper_child(slang_operation *oper, GLuint child)
{
   assert(child < oper->num_children);
   return &oper->children[child];
}


/** Return child of given operation node, const version */
static INLINE const slang_operation *
slang_oper_child_const(const slang_operation *oper, GLuint child)
{
   assert(child < oper->num_children);
   return &oper->children[child];
}


/** Init oper to a boolean literal. */
static INLINE void
slang_operation_literal_bool(slang_operation *oper, GLboolean value)
{
   oper->type = SLANG_OPER_LITERAL_BOOL;
   oper->literal[0] =
   oper->literal[1] =
   oper->literal[2] =
   oper->literal[3] = (float) value;
   oper->literal_size = 1;
}


/** Init oper to an int literal. */
static INLINE void
slang_operation_literal_int(slang_operation *oper, GLint value)
{
   oper->type = SLANG_OPER_LITERAL_INT;
   oper->literal[0] =
   oper->literal[1] =
   oper->literal[2] =
   oper->literal[3] = (float) value;
   oper->literal_size = 1;
}


#endif /* SLANG_COMPILE_OPERATION_H */
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d45 1
a129 1
   double x;
d153 3
d163 3
d168 55
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d97 1
d119 1
d124 6
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d25 1
a25 1
#if !defined SLANG_COMPILE_OPERATION_H
a27 3
#if defined __cplusplus
extern "C" {
#endif
d29 5
d36 64
a99 62
	slang_oper_none,
	slang_oper_block_no_new_scope,
	slang_oper_block_new_scope,
	slang_oper_variable_decl,
	slang_oper_asm,
	slang_oper_break,
	slang_oper_continue,
	slang_oper_discard,
	slang_oper_return,
	slang_oper_expression,
	slang_oper_if,
	slang_oper_while,
	slang_oper_do,
	slang_oper_for,
	slang_oper_void,
	slang_oper_literal_bool,
	slang_oper_literal_int,
	slang_oper_literal_float,
	slang_oper_identifier,
	slang_oper_sequence,
	slang_oper_assign,
	slang_oper_addassign,
	slang_oper_subassign,
	slang_oper_mulassign,
	slang_oper_divassign,
	/*slang_oper_modassign,*/
	/*slang_oper_lshassign,*/
	/*slang_oper_rshassign,*/
	/*slang_oper_orassign,*/
	/*slang_oper_xorassign,*/
	/*slang_oper_andassign,*/
	slang_oper_select,
	slang_oper_logicalor,
	slang_oper_logicalxor,
	slang_oper_logicaland,
	/*slang_oper_bitor,*/
	/*slang_oper_bitxor,*/
	/*slang_oper_bitand,*/
	slang_oper_equal,
	slang_oper_notequal,
	slang_oper_less,
	slang_oper_greater,
	slang_oper_lessequal,
	slang_oper_greaterequal,
	/*slang_oper_lshift,*/
	/*slang_oper_rshift,*/
	slang_oper_add,
	slang_oper_subtract,
	slang_oper_multiply,
	slang_oper_divide,
	/*slang_oper_modulus,*/
	slang_oper_preincrement,
	slang_oper_predecrement,
	slang_oper_plus,
	slang_oper_minus,
	/*slang_oper_complement,*/
	slang_oper_not,
	slang_oper_subscript,
	slang_oper_call,
	slang_oper_field,
	slang_oper_postincrement,
	slang_oper_postdecrement
d102 8
d112 10
a121 6
	slang_operation_type type;
	struct slang_operation_ *children;
	unsigned int num_children;
	float literal;		/* type: bool, literal_int, literal_float */
	slang_atom a_id;	/* type: asm, identifier, call, field */
	slang_variable_scope *locals;
a123 7
int slang_operation_construct (slang_operation *);
void slang_operation_destruct (slang_operation *);
int slang_operation_copy (slang_operation *, const slang_operation *);

#ifdef __cplusplus
}
#endif
d125 30
a154 1
#endif
d156 1
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
d25 1
a25 1
#ifndef SLANG_COMPILE_OPERATION_H
a31 6

/**
 * Types of slang operations.
 * These are the types of the AST (abstract syntax tree) nodes.
 * [foo] indicates a sub-tree or reference to another type of node
 */
d34 62
a95 62
   slang_oper_none,
   slang_oper_block_no_new_scope,       /* "{" sequence "}" */
   slang_oper_block_new_scope,  /* "{" sequence "}" */
   slang_oper_variable_decl,    /* [type] [var] or [var] = [expr] */
   slang_oper_asm,
   slang_oper_break,            /* "break" statement */
   slang_oper_continue,         /* "continue" statement */
   slang_oper_discard,          /* "discard" (kill fragment) statement */
   slang_oper_return,           /* "return" [expr]  */
   slang_oper_expression,       /* [expr] */
   slang_oper_if,               /* "if" [0] then [1] else [2] */
   slang_oper_while,            /* "while" [cond] [body] */
   slang_oper_do,               /* "do" [body] "while" [cond] */
   slang_oper_for,              /* "for" [init] [while] [incr] [body] */
   slang_oper_void,             /* nop */
   slang_oper_literal_bool,     /* "true" or "false" */
   slang_oper_literal_int,      /* integer literal */
   slang_oper_literal_float,    /* float literal */
   slang_oper_identifier,       /* var name, func name, etc */
   slang_oper_sequence,         /* [expr] "," [expr] "," etc */
   slang_oper_assign,           /* [var] "=" [expr] */
   slang_oper_addassign,        /* [var] "+=" [expr] */
   slang_oper_subassign,        /* [var] "-=" [expr] */
   slang_oper_mulassign,        /* [var] "*=" [expr] */
   slang_oper_divassign,        /* [var] "/=" [expr] */
   /*slang_oper_modassign, */
   /*slang_oper_lshassign, */
   /*slang_oper_rshassign, */
   /*slang_oper_orassign, */
   /*slang_oper_xorassign, */
   /*slang_oper_andassign, */
   slang_oper_select,           /* [expr] "?" [expr] ":" [expr] */
   slang_oper_logicalor,        /* [expr] "||" [expr] */
   slang_oper_logicalxor,       /* [expr] "^^" [expr] */
   slang_oper_logicaland,       /* [expr] "&&" [expr] */
   /*slang_oper_bitor, */
   /*slang_oper_bitxor, */
   /*slang_oper_bitand, */
   slang_oper_equal,            /* [expr] "==" [expr] */
   slang_oper_notequal,         /* [expr] "!=" [expr] */
   slang_oper_less,             /* [expr] "<" [expr] */
   slang_oper_greater,          /* [expr] ">" [expr] */
   slang_oper_lessequal,        /* [expr] "<=" [expr] */
   slang_oper_greaterequal,     /* [expr] ">=" [expr] */
   /*slang_oper_lshift, */
   /*slang_oper_rshift, */
   slang_oper_add,              /* [expr] "+" [expr] */
   slang_oper_subtract,         /* [expr] "-" [expr] */
   slang_oper_multiply,         /* [expr] "*" [expr] */
   slang_oper_divide,           /* [expr] "/" [expr] */
   /*slang_oper_modulus, */
   slang_oper_preincrement,     /* "++" [var] */
   slang_oper_predecrement,     /* "--" [var] */
   slang_oper_plus,             /* "-" [expr] */
   slang_oper_minus,            /* "+" [expr] */
   /*slang_oper_complement, */
   slang_oper_not,              /* "!" [expr] */
   slang_oper_subscript,        /* [expr] "[" [expr] "]" */
   slang_oper_call,             /* [func name] [param] [param] [...] */
   slang_oper_field,            /* i.e.: ".next" or ".xzy" or ".xxx" etc */
   slang_oper_postincrement,    /* [var] "++" */
   slang_oper_postdecrement     /* [var] "--" */
a97 8

/**
 * A slang_operation is basically a compiled instruction (such as assignment,
 * a while-loop, a conditional, a multiply, a function call, etc).
 * The AST (abstract syntax tree) is built from these nodes.
 * NOTE: This structure could have been implemented as a union of simpler
 * structs which would correspond to the operation types above.
 */
d100 6
a105 6
   slang_operation_type type;
   struct slang_operation_ *children;
   GLuint num_children;
   GLfloat literal;            /**< Used for float, int and bool values */
   slang_atom a_id;            /**< type: asm, identifier, call, field */
   slang_variable_scope *locals;       /**< local vars for scope */
d108 3
a110 13

extern GLboolean
slang_operation_construct(slang_operation *);

extern void
slang_operation_destruct(slang_operation *);

extern GLboolean
slang_operation_copy(slang_operation *, const slang_operation *);

extern slang_operation *
slang_operation_new(GLuint count);

d116 2
a117 1
#endif /* SLANG_COMPILE_OPERATION_H */
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d28 4
d40 62
a101 64
   SLANG_OPER_NONE,
   SLANG_OPER_BLOCK_NO_NEW_SCOPE,       /* "{" sequence "}" */
   SLANG_OPER_BLOCK_NEW_SCOPE,  /* "{" sequence "}" */
   SLANG_OPER_VARIABLE_DECL,    /* [type] [var] or [var] = [expr] */
   SLANG_OPER_ASM,
   SLANG_OPER_BREAK,            /* "break" statement */
   SLANG_OPER_CONTINUE,         /* "continue" statement */
   SLANG_OPER_DISCARD,          /* "discard" (kill fragment) statement */
   SLANG_OPER_RETURN,           /* "return" [expr]  */
   SLANG_OPER_LABEL,            /* a jump target */
   SLANG_OPER_EXPRESSION,       /* [expr] */
   SLANG_OPER_IF,               /* "if" [0] then [1] else [2] */
   SLANG_OPER_WHILE,            /* "while" [cond] [body] */
   SLANG_OPER_DO,               /* "do" [body] "while" [cond] */
   SLANG_OPER_FOR,              /* "for" [init] [while] [incr] [body] */
   SLANG_OPER_VOID,             /* nop */
   SLANG_OPER_LITERAL_BOOL,     /* "true" or "false" */
   SLANG_OPER_LITERAL_INT,      /* integer literal */
   SLANG_OPER_LITERAL_FLOAT,    /* float literal */
   SLANG_OPER_IDENTIFIER,       /* var name, func name, etc */
   SLANG_OPER_SEQUENCE,         /* [expr] "," [expr] "," etc */
   SLANG_OPER_ASSIGN,           /* [var] "=" [expr] */
   SLANG_OPER_ADDASSIGN,        /* [var] "+=" [expr] */
   SLANG_OPER_SUBASSIGN,        /* [var] "-=" [expr] */
   SLANG_OPER_MULASSIGN,        /* [var] "*=" [expr] */
   SLANG_OPER_DIVASSIGN,        /* [var] "/=" [expr] */
   /*SLANG_OPER_MODASSIGN, */
   /*SLANG_OPER_LSHASSIGN, */
   /*SLANG_OPER_RSHASSIGN, */
   /*SLANG_OPER_ORASSIGN, */
   /*SLANG_OPER_XORASSIGN, */
   /*SLANG_OPER_ANDASSIGN, */
   SLANG_OPER_SELECT,           /* [expr] "?" [expr] ":" [expr] */
   SLANG_OPER_LOGICALOR,        /* [expr] "||" [expr] */
   SLANG_OPER_LOGICALXOR,       /* [expr] "^^" [expr] */
   SLANG_OPER_LOGICALAND,       /* [expr] "&&" [expr] */
   /*SLANG_OPER_BITOR, */
   /*SLANG_OPER_BITXOR, */
   /*SLANG_OPER_BITAND, */
   SLANG_OPER_EQUAL,            /* [expr] "==" [expr] */
   SLANG_OPER_NOTEQUAL,         /* [expr] "!=" [expr] */
   SLANG_OPER_LESS,             /* [expr] "<" [expr] */
   SLANG_OPER_GREATER,          /* [expr] ">" [expr] */
   SLANG_OPER_LESSEQUAL,        /* [expr] "<=" [expr] */
   SLANG_OPER_GREATEREQUAL,     /* [expr] ">=" [expr] */
   /*SLANG_OPER_LSHIFT, */
   /*SLANG_OPER_RSHIFT, */
   SLANG_OPER_ADD,              /* [expr] "+" [expr] */
   SLANG_OPER_SUBTRACT,         /* [expr] "-" [expr] */
   SLANG_OPER_MULTIPLY,         /* [expr] "*" [expr] */
   SLANG_OPER_DIVIDE,           /* [expr] "/" [expr] */
   /*SLANG_OPER_MODULUS, */
   SLANG_OPER_PREINCREMENT,     /* "++" [var] */
   SLANG_OPER_PREDECREMENT,     /* "--" [var] */
   SLANG_OPER_PLUS,             /* "-" [expr] */
   SLANG_OPER_MINUS,            /* "+" [expr] */
   /*SLANG_OPER_COMPLEMENT, */
   SLANG_OPER_NOT,              /* "!" [expr] */
   SLANG_OPER_SUBSCRIPT,        /* [expr] "[" [expr] "]" */
   SLANG_OPER_CALL,             /* [func name] [param] [param] [...] */
   SLANG_OPER_INLINED_CALL,     /* inlined function call */
   SLANG_OPER_FIELD,            /* i.e.: ".next" or ".xzy" or ".xxx" etc */
   SLANG_OPER_POSTINCREMENT,    /* [var] "++" */
   SLANG_OPER_POSTDECREMENT     /* [var] "--" */
d117 3
a119 7
   GLfloat literal[4];           /**< Used for float, int and bool values */
   GLuint literal_size;          /**< 1, 2, 3, or 4 */
   slang_atom a_id;              /**< type: asm, identifier, call, field */
   slang_variable_scope *locals; /**< local vars for scope */
   struct slang_function_ *fun;  /**< If type == SLANG_OPER_CALL */
   struct slang_variable_ *var;  /**< If type == slang_oper_identier */
   struct slang_label_ *label;   /**< If type == SLANG_OPER_LABEL */
a134 12
extern void
slang_operation_delete(slang_operation *oper);

extern slang_operation *
slang_operation_grow(GLuint *numChildren, slang_operation **children);

extern slang_operation *
slang_operation_insert(GLuint *numChildren, slang_operation **children,
                       GLuint pos);

extern void
_slang_operation_swap(slang_operation *oper0, slang_operation *oper1);
d136 3
@


