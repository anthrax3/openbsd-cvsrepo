head	1.5;
access;
symbols
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2011.10.23.13.37.45;	author matthieu;	state dead;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.32;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.08;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.47;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.31.47;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge Mesa 7.10.3
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2005-2006  Brian Paul   All Rights Reserved.
 * Copyright (C) 2008 VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file slang_compile.c
 * slang front-end compiler
 * \author Michal Krol
 */

#include "main/imports.h"
#include "main/context.h"
#include "shader/program.h"
#include "shader/programopt.h"
#include "shader/prog_optimize.h"
#include "shader/prog_print.h"
#include "shader/prog_parameter.h"
#include "../../glsl/pp/sl_pp_public.h"
#include "../../glsl/cl/sl_cl_parse.h"
#include "slang_codegen.h"
#include "slang_compile.h"
#include "slang_storage.h"
#include "slang_log.h"
#include "slang_mem.h"
#include "slang_vartable.h"
#include "slang_simplify.h"

/*
 * This is a straightforward implementation of the slang front-end
 * compiler.  Lots of error-checking functionality is missing but
 * every well-formed shader source should compile successfully and
 * execute as expected. However, some semantically ill-formed shaders
 * may be accepted resulting in undefined behaviour.
 */


/** re-defined below, should be the same though */
#define TYPE_SPECIFIER_COUNT 36


/**
 * Check if the given identifier is legal.
 */
static GLboolean
legal_identifier(slang_atom name)
{
   /* "gl_" is a reserved prefix */
   if (strncmp((char *) name, "gl_", 3) == 0) {
      return GL_FALSE;
   }
   return GL_TRUE;
}


/*
 * slang_code_unit
 */

GLvoid
_slang_code_unit_ctr(slang_code_unit * self,
                     struct slang_code_object_ * object)
{
   _slang_variable_scope_ctr(&self->vars);
   _slang_function_scope_ctr(&self->funs);
   _slang_struct_scope_ctr(&self->structs);
   self->object = object;
}

GLvoid
_slang_code_unit_dtr(slang_code_unit * self)
{
   slang_variable_scope_destruct(&self->vars);
   slang_function_scope_destruct(&self->funs);
   slang_struct_scope_destruct(&self->structs);
}

/*
 * slang_code_object
 */

GLvoid
_slang_code_object_ctr(slang_code_object * self)
{
   GLuint i;

   for (i = 0; i < SLANG_BUILTIN_TOTAL; i++)
      _slang_code_unit_ctr(&self->builtin[i], self);
   _slang_code_unit_ctr(&self->unit, self);
   slang_atom_pool_construct(&self->atompool);
}

GLvoid
_slang_code_object_dtr(slang_code_object * self)
{
   GLuint i;

   for (i = 0; i < SLANG_BUILTIN_TOTAL; i++)
      _slang_code_unit_dtr(&self->builtin[i]);
   _slang_code_unit_dtr(&self->unit);
   slang_atom_pool_destruct(&self->atompool);
}


/* slang_parse_ctx */

typedef struct slang_parse_ctx_
{
   const unsigned char *I;
   slang_info_log *L;
   int parsing_builtin;
   GLboolean global_scope;   /**< Is object being declared a global? */
   slang_atom_pool *atoms;
   slang_unit_type type;     /**< Vertex vs. Fragment */
   GLuint version;           /**< user-specified (or default) #version */
} slang_parse_ctx;

/* slang_output_ctx */

typedef struct slang_output_ctx_
{
   slang_variable_scope *vars;
   slang_function_scope *funs;
   slang_struct_scope *structs;
   struct gl_program *program;
   struct gl_sl_pragmas *pragmas;
   slang_var_table *vartable;
   GLuint default_precision[TYPE_SPECIFIER_COUNT];
   GLboolean allow_precision;
   GLboolean allow_invariant;
   GLboolean allow_centroid;
   GLboolean allow_array_types;  /* float[] syntax */
} slang_output_ctx;

/* _slang_compile() */


/* Debugging aid, print file/line where parsing error is detected */
#define RETURN0 \
   do { \
      if (0) \
         printf("slang error at %s:%d\n", __FILE__, __LINE__); \
      return 0; \
   } while (0)


static void
parse_identifier_str(slang_parse_ctx * C, char **id)
{
   *id = (char *) C->I;
   C->I += strlen(*id) + 1;
}

static slang_atom
parse_identifier(slang_parse_ctx * C)
{
   const char *id;

   id = (const char *) C->I;
   C->I += strlen(id) + 1;
   return slang_atom_pool_atom(C->atoms, id);
}

static int
is_hex_digit(char c)
{
   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}

static int
parse_general_number(slang_parse_ctx *ctx, float *number)
{
   char *flt = NULL;

   if (*ctx->I == '0') {
      int value = 0;
      const unsigned char *pi;

      if (ctx->I[1] == 'x' || ctx->I[1] == 'X') {
         ctx->I += 2;
         if (!is_hex_digit(*ctx->I)) {
            return 0;
         }
         do {
            int digit;

            if (*ctx->I >= '0' && *ctx->I <= '9') {
               digit = (int)(*ctx->I - '0');
            } else if (*ctx->I >= 'a' && *ctx->I <= 'f') {
               digit = (int)(*ctx->I - 'a') + 10;
            } else {
               digit = (int)(*ctx->I - 'A') + 10;
            }
            value = value * 0x10 + digit;
            ctx->I++;
         } while (is_hex_digit(*ctx->I));
         if (*ctx->I != '\0') {
            return 0;
         }
         ctx->I++;
         *number = (float)value;
         return 1;
      }

      pi = ctx->I;
      pi++;
      while (*pi >= '0' && *pi <= '7') {
         int digit;

         digit = (int)(*pi - '0');
         value = value * 010 + digit;
         pi++;
      }
      if (*pi == '\0') {
         pi++;
         ctx->I = pi;
         *number = (float)value;
         return 1;
      }
   }

   parse_identifier_str(ctx, &flt);
   flt = _mesa_strdup(flt);
   if (!flt) {
      return 0;
   }
   if (flt[strlen(flt) - 1] == 'f' || flt[strlen(flt) - 1] == 'F') {
      flt[strlen(flt) - 1] = '\0';
   }
   *number = _mesa_strtof(flt, (char **)NULL);
   free(flt);

   return 1;
}

static int
parse_number(slang_parse_ctx * C, int *number)
{
   const int radix = (int) (*C->I++);

   if (radix == 1) {
      float f = 0.0f;

      parse_general_number(C, &f);
      *number = (int)f;
   } else {
      *number = 0;
      while (*C->I != '\0') {
         int digit;
         if (*C->I >= '0' && *C->I <= '9')
            digit = (int) (*C->I - '0');
         else if (*C->I >= 'A' && *C->I <= 'Z')
            digit = (int) (*C->I - 'A') + 10;
         else
            digit = (int) (*C->I - 'a') + 10;
         *number = *number * radix + digit;
         C->I++;
      }
      C->I++;
   }
   if (*number > 65535)
      slang_info_log_warning(C->L, "%d: literal integer overflow.", *number);
   return 1;
}

static int
parse_float(slang_parse_ctx * C, float *number)
{
   if (*C->I == 1) {
      C->I++;
      parse_general_number(C, number);
   } else {
      char *integral = NULL;
      char *fractional = NULL;
      char *exponent = NULL;
      char *whole = NULL;

      parse_identifier_str(C, &integral);
      parse_identifier_str(C, &fractional);
      parse_identifier_str(C, &exponent);

      whole = (char *) _slang_alloc((strlen(integral) +
                                     strlen(fractional) +
                                     strlen(exponent) + 3) * sizeof(char));
      if (whole == NULL) {
         slang_info_log_memory(C->L);
         RETURN0;
      }

      slang_string_copy(whole, integral);
      slang_string_concat(whole, ".");
      slang_string_concat(whole, fractional);
      slang_string_concat(whole, "E");
      slang_string_concat(whole, exponent);

      *number = _mesa_strtof(whole, (char **) NULL);

      _slang_free(whole);
   }

   return 1;
}

/* revision number - increment after each change affecting emitted output */
#define REVISION 5

static int
check_revision(slang_parse_ctx * C)
{
   if (*C->I != REVISION) {
      slang_info_log_error(C->L, "Internal compiler error.");
      RETURN0;
   }
   C->I++;
   return 1;
}

static int parse_statement(slang_parse_ctx *, slang_output_ctx *,
                           slang_operation *);
static int parse_expression(slang_parse_ctx *, slang_output_ctx *,
                            slang_operation *);
static int parse_type_specifier(slang_parse_ctx *, slang_output_ctx *,
                                slang_type_specifier *);
static int
parse_type_array_size(slang_parse_ctx *C,
                      slang_output_ctx *O,
                      GLint *array_len);

static GLboolean
parse_array_len(slang_parse_ctx * C, slang_output_ctx * O, GLuint * len)
{
   slang_operation array_size;
   slang_name_space space;
   GLboolean result;

   if (!slang_operation_construct(&array_size))
      return GL_FALSE;
   if (!parse_expression(C, O, &array_size)) {
      slang_operation_destruct(&array_size);
      return GL_FALSE;
   }

   space.funcs = O->funs;
   space.structs = O->structs;
   space.vars = O->vars;

   /* evaluate compile-time expression which is array size */
   _slang_simplify(&array_size, &space, C->atoms);

   if (array_size.type == SLANG_OPER_LITERAL_INT) {
      result = GL_TRUE;
      *len = (GLint) array_size.literal[0];
   } else if (array_size.type == SLANG_OPER_IDENTIFIER) {
      slang_variable *var = _slang_variable_locate(array_size.locals, array_size.a_id, GL_TRUE);
      if (!var) {
         slang_info_log_error(C->L, "undefined variable '%s'",
                              (char *) array_size.a_id);
         result = GL_FALSE;
      } else if (var->type.qualifier == SLANG_QUAL_CONST &&
                 var->type.specifier.type == SLANG_SPEC_INT) {
         if (var->initializer &&
             var->initializer->type == SLANG_OPER_LITERAL_INT) {
            *len = (GLint) var->initializer->literal[0];
            result = GL_TRUE;
         } else {
            slang_info_log_error(C->L, "unable to parse array size declaration");
            result = GL_FALSE;
         }
      } else {
         slang_info_log_error(C->L, "unable to parse array size declaration");
         result = GL_FALSE;
      }
   } else {
      result = GL_FALSE;
   }

   slang_operation_destruct(&array_size);
   return result;
}

static GLboolean
calculate_var_size(slang_parse_ctx * C, slang_output_ctx * O,
                   slang_variable * var)
{
   slang_storage_aggregate agg;

   if (!slang_storage_aggregate_construct(&agg))
      return GL_FALSE;
   if (!_slang_aggregate_variable(&agg, &var->type.specifier, var->array_len,
                                  O->funs, O->structs, O->vars, C->atoms)) {
      slang_storage_aggregate_destruct(&agg);
      return GL_FALSE;
   }
   var->size = _slang_sizeof_aggregate(&agg);
   slang_storage_aggregate_destruct(&agg);
   return GL_TRUE;
}

static void
promote_type_to_array(slang_parse_ctx *C,
                      slang_fully_specified_type *type,
                      GLint array_len)
{
   slang_type_specifier *baseType =
      slang_type_specifier_new(type->specifier.type, NULL, NULL);

   type->specifier.type = SLANG_SPEC_ARRAY;
   type->specifier._array = baseType;
   type->array_len = array_len;
}


static GLboolean
convert_to_array(slang_parse_ctx * C, slang_variable * var,
                 const slang_type_specifier * sp)
{
   /* sized array - mark it as array, copy the specifier to the array element
    * and parse the expression */
   var->type.specifier.type = SLANG_SPEC_ARRAY;
   var->type.specifier._array = (slang_type_specifier *)
      _slang_alloc(sizeof(slang_type_specifier));
   if (var->type.specifier._array == NULL) {
      slang_info_log_memory(C->L);
      return GL_FALSE;
   }
   slang_type_specifier_ctr(var->type.specifier._array);
   return slang_type_specifier_copy(var->type.specifier._array, sp);
}

/* structure field */
#define FIELD_NONE 0
#define FIELD_NEXT 1
#define FIELD_ARRAY 2

static GLboolean
parse_struct_field_var(slang_parse_ctx * C, slang_output_ctx * O,
                       slang_variable * var, slang_atom a_name,
                       const slang_type_specifier * sp,
                       GLuint array_len)
{
   var->a_name = a_name;
   if (var->a_name == SLANG_ATOM_NULL)
      return GL_FALSE;

   switch (*C->I++) {
   case FIELD_NONE:
      if (array_len != -1) {
         if (!convert_to_array(C, var, sp))
            return GL_FALSE;
         var->array_len = array_len;
      }
      else {
         if (!slang_type_specifier_copy(&var->type.specifier, sp))
            return GL_FALSE;
      }
      break;
   case FIELD_ARRAY:
      if (array_len != -1)
         return GL_FALSE;
      if (!convert_to_array(C, var, sp))
         return GL_FALSE;
      if (!parse_array_len(C, O, &var->array_len))
         return GL_FALSE;
      break;
   default:
      return GL_FALSE;
   }

   return calculate_var_size(C, O, var);
}

static int
parse_struct_field(slang_parse_ctx * C, slang_output_ctx * O,
                   slang_struct * st, slang_type_specifier * sp)
{
   slang_output_ctx o = *O;
   GLint array_len;

   o.structs = st->structs;
   if (!parse_type_specifier(C, &o, sp))
      RETURN0;
   if (!parse_type_array_size(C, &o, &array_len))
      RETURN0;

   do {
      slang_atom a_name;
      slang_variable *var = slang_variable_scope_grow(st->fields);
      if (!var) {
         slang_info_log_memory(C->L);
         RETURN0;
      }
      a_name = parse_identifier(C);
      if (_slang_variable_locate(st->fields, a_name, GL_FALSE)) {
         slang_info_log_error(C->L, "duplicate field '%s'", (char *) a_name);
         RETURN0;
      }

      if (!parse_struct_field_var(C, &o, var, a_name, sp, array_len))
         RETURN0;
   }
   while (*C->I++ != FIELD_NONE);

   return 1;
}

static int
parse_struct(slang_parse_ctx * C, slang_output_ctx * O, slang_struct ** st)
{
   slang_atom a_name;
   const char *name;

   /* parse struct name (if any) and make sure it is unique in current scope */
   a_name = parse_identifier(C);
   if (a_name == SLANG_ATOM_NULL)
      RETURN0;

   name = slang_atom_pool_id(C->atoms, a_name);
   if (name[0] != '\0'
       && slang_struct_scope_find(O->structs, a_name, 0) != NULL) {
      slang_info_log_error(C->L, "%s: duplicate type name.", name);
      RETURN0;
   }

   /* set-up a new struct */
   *st = (slang_struct *) _slang_alloc(sizeof(slang_struct));
   if (*st == NULL) {
      slang_info_log_memory(C->L);
      RETURN0;
   }
   if (!slang_struct_construct(*st)) {
      _slang_free(*st);
      *st = NULL;
      slang_info_log_memory(C->L);
      RETURN0;
   }
   (**st).a_name = a_name;
   (**st).structs->outer_scope = O->structs;

   /* parse individual struct fields */
   do {
      slang_type_specifier sp;

      slang_type_specifier_ctr(&sp);
      if (!parse_struct_field(C, O, *st, &sp)) {
         slang_type_specifier_dtr(&sp);
         RETURN0;
      }
      slang_type_specifier_dtr(&sp);
   }
   while (*C->I++ != FIELD_NONE);

   /* if named struct, copy it to current scope */
   if (name[0] != '\0') {
      slang_struct *s;

      O->structs->structs =
         (slang_struct *) _slang_realloc(O->structs->structs,
                                         O->structs->num_structs
                                         * sizeof(slang_struct),
                                         (O->structs->num_structs + 1)
                                         * sizeof(slang_struct));
      if (O->structs->structs == NULL) {
         slang_info_log_memory(C->L);
         RETURN0;
      }
      s = &O->structs->structs[O->structs->num_structs];
      if (!slang_struct_construct(s))
         RETURN0;
      O->structs->num_structs++;
      if (!slang_struct_copy(s, *st))
         RETURN0;
   }

   return 1;
}


/* invariant qualifer */
#define TYPE_VARIANT    90
#define TYPE_INVARIANT  91

static int
parse_type_variant(slang_parse_ctx * C, slang_type_variant *variant)
{
   GLuint invariant = *C->I++;
   switch (invariant) {
   case TYPE_VARIANT:
      *variant = SLANG_VARIANT;
      return 1;
   case TYPE_INVARIANT:
      *variant = SLANG_INVARIANT;
      return 1;
   default:
      RETURN0;
   }
}


/* centroid qualifer */
#define TYPE_CENTER    95
#define TYPE_CENTROID  96

static int
parse_type_centroid(slang_parse_ctx * C, slang_type_centroid *centroid)
{
   GLuint c = *C->I++;
   switch (c) {
   case TYPE_CENTER:
      *centroid = SLANG_CENTER;
      return 1;
   case TYPE_CENTROID:
      *centroid = SLANG_CENTROID;
      return 1;
   default:
      RETURN0;
   }
}


/* Layout qualifiers */
#define LAYOUT_QUALIFIER_NONE                      0
#define LAYOUT_QUALIFIER_UPPER_LEFT                1
#define LAYOUT_QUALIFIER_PIXEL_CENTER_INTEGER      2

static int
parse_layout_qualifiers(slang_parse_ctx * C, slang_layout_qualifier *layout)
{
   *layout = 0x0;

   /* the layout qualifiers come as a list of LAYOUT_QUALIFER_x tokens,
    * terminated by LAYOUT_QUALIFIER_NONE.
    */
   while (1) {
      GLuint c = *C->I++;
      switch (c) {
      case LAYOUT_QUALIFIER_NONE:
         /* end of list of qualifiers */
         return 1;
      case LAYOUT_QUALIFIER_UPPER_LEFT:
         *layout |= SLANG_LAYOUT_UPPER_LEFT_BIT;
         break;
      case LAYOUT_QUALIFIER_PIXEL_CENTER_INTEGER:
         *layout |= SLANG_LAYOUT_PIXEL_CENTER_INTEGER_BIT;
         break;
      default:
         assert(0 && "Bad layout qualifier");
      }
   }
}


/* type qualifier */
#define TYPE_QUALIFIER_NONE 0
#define TYPE_QUALIFIER_CONST 1
#define TYPE_QUALIFIER_ATTRIBUTE 2
#define TYPE_QUALIFIER_VARYING 3
#define TYPE_QUALIFIER_UNIFORM 4
#define TYPE_QUALIFIER_FIXEDOUTPUT 5
#define TYPE_QUALIFIER_FIXEDINPUT 6

static int
parse_type_qualifier(slang_parse_ctx * C, slang_type_qualifier * qual)
{
   GLuint qualifier = *C->I++;
   switch (qualifier) {
   case TYPE_QUALIFIER_NONE:
      *qual = SLANG_QUAL_NONE;
      break;
   case TYPE_QUALIFIER_CONST:
      *qual = SLANG_QUAL_CONST;
      break;
   case TYPE_QUALIFIER_ATTRIBUTE:
      *qual = SLANG_QUAL_ATTRIBUTE;
      break;
   case TYPE_QUALIFIER_VARYING:
      *qual = SLANG_QUAL_VARYING;
      break;
   case TYPE_QUALIFIER_UNIFORM:
      *qual = SLANG_QUAL_UNIFORM;
      break;
   case TYPE_QUALIFIER_FIXEDOUTPUT:
      *qual = SLANG_QUAL_FIXEDOUTPUT;
      break;
   case TYPE_QUALIFIER_FIXEDINPUT:
      *qual = SLANG_QUAL_FIXEDINPUT;
      break;
   default:
      RETURN0;
   }
   return 1;
}

/* type specifier */
#define TYPE_SPECIFIER_VOID 0
#define TYPE_SPECIFIER_BOOL 1
#define TYPE_SPECIFIER_BVEC2 2
#define TYPE_SPECIFIER_BVEC3 3
#define TYPE_SPECIFIER_BVEC4 4
#define TYPE_SPECIFIER_INT 5
#define TYPE_SPECIFIER_IVEC2 6
#define TYPE_SPECIFIER_IVEC3 7
#define TYPE_SPECIFIER_IVEC4 8
#define TYPE_SPECIFIER_FLOAT 9
#define TYPE_SPECIFIER_VEC2 10
#define TYPE_SPECIFIER_VEC3 11
#define TYPE_SPECIFIER_VEC4 12
#define TYPE_SPECIFIER_MAT2 13
#define TYPE_SPECIFIER_MAT3 14
#define TYPE_SPECIFIER_MAT4 15
#define TYPE_SPECIFIER_SAMPLER1D 16
#define TYPE_SPECIFIER_SAMPLER2D 17
#define TYPE_SPECIFIER_SAMPLER3D 18
#define TYPE_SPECIFIER_SAMPLERCUBE 19
#define TYPE_SPECIFIER_SAMPLER1DSHADOW 20
#define TYPE_SPECIFIER_SAMPLER2DSHADOW 21
#define TYPE_SPECIFIER_SAMPLER2DRECT 22
#define TYPE_SPECIFIER_SAMPLER2DRECTSHADOW 23
#define TYPE_SPECIFIER_STRUCT 24
#define TYPE_SPECIFIER_TYPENAME 25
#define TYPE_SPECIFIER_MAT23 26
#define TYPE_SPECIFIER_MAT32 27
#define TYPE_SPECIFIER_MAT24 28
#define TYPE_SPECIFIER_MAT42 29
#define TYPE_SPECIFIER_MAT34 30
#define TYPE_SPECIFIER_MAT43 31
#define TYPE_SPECIFIER_SAMPLER_1D_ARRAY 32
#define TYPE_SPECIFIER_SAMPLER_2D_ARRAY 33
#define TYPE_SPECIFIER_SAMPLER_1D_ARRAY_SHADOW 34
#define TYPE_SPECIFIER_SAMPLER_2D_ARRAY_SHADOW 35
#define TYPE_SPECIFIER_COUNT 36

static int
parse_type_specifier(slang_parse_ctx * C, slang_output_ctx * O,
                     slang_type_specifier * spec)
{
   int type = *C->I++;
   switch (type) {
   case TYPE_SPECIFIER_VOID:
      spec->type = SLANG_SPEC_VOID;
      break;
   case TYPE_SPECIFIER_BOOL:
      spec->type = SLANG_SPEC_BOOL;
      break;
   case TYPE_SPECIFIER_BVEC2:
      spec->type = SLANG_SPEC_BVEC2;
      break;
   case TYPE_SPECIFIER_BVEC3:
      spec->type = SLANG_SPEC_BVEC3;
      break;
   case TYPE_SPECIFIER_BVEC4:
      spec->type = SLANG_SPEC_BVEC4;
      break;
   case TYPE_SPECIFIER_INT:
      spec->type = SLANG_SPEC_INT;
      break;
   case TYPE_SPECIFIER_IVEC2:
      spec->type = SLANG_SPEC_IVEC2;
      break;
   case TYPE_SPECIFIER_IVEC3:
      spec->type = SLANG_SPEC_IVEC3;
      break;
   case TYPE_SPECIFIER_IVEC4:
      spec->type = SLANG_SPEC_IVEC4;
      break;
   case TYPE_SPECIFIER_FLOAT:
      spec->type = SLANG_SPEC_FLOAT;
      break;
   case TYPE_SPECIFIER_VEC2:
      spec->type = SLANG_SPEC_VEC2;
      break;
   case TYPE_SPECIFIER_VEC3:
      spec->type = SLANG_SPEC_VEC3;
      break;
   case TYPE_SPECIFIER_VEC4:
      spec->type = SLANG_SPEC_VEC4;
      break;
   case TYPE_SPECIFIER_MAT2:
      spec->type = SLANG_SPEC_MAT2;
      break;
   case TYPE_SPECIFIER_MAT3:
      spec->type = SLANG_SPEC_MAT3;
      break;
   case TYPE_SPECIFIER_MAT4:
      spec->type = SLANG_SPEC_MAT4;
      break;
   case TYPE_SPECIFIER_MAT23:
      spec->type = SLANG_SPEC_MAT23;
      break;
   case TYPE_SPECIFIER_MAT32:
      spec->type = SLANG_SPEC_MAT32;
      break;
   case TYPE_SPECIFIER_MAT24:
      spec->type = SLANG_SPEC_MAT24;
      break;
   case TYPE_SPECIFIER_MAT42:
      spec->type = SLANG_SPEC_MAT42;
      break;
   case TYPE_SPECIFIER_MAT34:
      spec->type = SLANG_SPEC_MAT34;
      break;
   case TYPE_SPECIFIER_MAT43:
      spec->type = SLANG_SPEC_MAT43;
      break;
   case TYPE_SPECIFIER_SAMPLER1D:
      spec->type = SLANG_SPEC_SAMPLER_1D;
      break;
   case TYPE_SPECIFIER_SAMPLER2D:
      spec->type = SLANG_SPEC_SAMPLER_2D;
      break;
   case TYPE_SPECIFIER_SAMPLER3D:
      spec->type = SLANG_SPEC_SAMPLER_3D;
      break;
   case TYPE_SPECIFIER_SAMPLERCUBE:
      spec->type = SLANG_SPEC_SAMPLER_CUBE;
      break;
   case TYPE_SPECIFIER_SAMPLER2DRECT:
      spec->type = SLANG_SPEC_SAMPLER_RECT;
      break;
   case TYPE_SPECIFIER_SAMPLER1DSHADOW:
      spec->type = SLANG_SPEC_SAMPLER_1D_SHADOW;
      break;
   case TYPE_SPECIFIER_SAMPLER2DSHADOW:
      spec->type = SLANG_SPEC_SAMPLER_2D_SHADOW;
      break;
   case TYPE_SPECIFIER_SAMPLER2DRECTSHADOW:
      spec->type = SLANG_SPEC_SAMPLER_RECT_SHADOW;
      break;
   case TYPE_SPECIFIER_SAMPLER_1D_ARRAY:
      spec->type = SLANG_SPEC_SAMPLER_1D_ARRAY;
      break;
   case TYPE_SPECIFIER_SAMPLER_2D_ARRAY:
      spec->type = SLANG_SPEC_SAMPLER_2D_ARRAY;
      break;
   case TYPE_SPECIFIER_SAMPLER_1D_ARRAY_SHADOW:
      spec->type = SLANG_SPEC_SAMPLER_1D_ARRAY_SHADOW;
      break;
   case TYPE_SPECIFIER_SAMPLER_2D_ARRAY_SHADOW:
      spec->type = SLANG_SPEC_SAMPLER_2D_ARRAY_SHADOW;
      break;
   case TYPE_SPECIFIER_STRUCT:
      spec->type = SLANG_SPEC_STRUCT;
      if (!parse_struct(C, O, &spec->_struct))
         RETURN0;
      break;
   case TYPE_SPECIFIER_TYPENAME:
      spec->type = SLANG_SPEC_STRUCT;
      {
         slang_atom a_name;
         slang_struct *stru;

         a_name = parse_identifier(C);
         if (a_name == NULL)
            RETURN0;

         stru = slang_struct_scope_find(O->structs, a_name, 1);
         if (stru == NULL) {
            slang_info_log_error(C->L, "undeclared type name '%s'",
                                 slang_atom_pool_id(C->atoms, a_name));
            RETURN0;
         }

         spec->_struct = (slang_struct *) _slang_alloc(sizeof(slang_struct));
         if (spec->_struct == NULL) {
            slang_info_log_memory(C->L);
            RETURN0;
         }
         if (!slang_struct_construct(spec->_struct)) {
            _slang_free(spec->_struct);
            spec->_struct = NULL;
            RETURN0;
         }
         if (!slang_struct_copy(spec->_struct, stru))
            RETURN0;
      }
      break;
   default:
      RETURN0;
   }
   return 1;
}

#define TYPE_SPECIFIER_NONARRAY 0
#define TYPE_SPECIFIER_ARRAY    1

static int
parse_type_array_size(slang_parse_ctx *C,
                      slang_output_ctx *O,
                      GLint *array_len)
{
   GLuint size;

   switch (*C->I++) {
   case TYPE_SPECIFIER_NONARRAY:
      *array_len = -1; /* -1 = not an array */
      break;
   case TYPE_SPECIFIER_ARRAY:
      if (!parse_array_len(C, O, &size))
         RETURN0;
      *array_len = (GLint) size;
      break;
   default:
      assert(0);
      RETURN0;
   }
   return 1;
}

#define PRECISION_DEFAULT 0
#define PRECISION_LOW     1
#define PRECISION_MEDIUM  2
#define PRECISION_HIGH    3

static int
parse_type_precision(slang_parse_ctx *C,
                     slang_type_precision *precision)
{
   GLint prec = *C->I++;
   switch (prec) {
   case PRECISION_DEFAULT:
      *precision = SLANG_PREC_DEFAULT;
      return 1;
   case PRECISION_LOW:
      *precision = SLANG_PREC_LOW;
      return 1;
   case PRECISION_MEDIUM:
      *precision = SLANG_PREC_MEDIUM;
      return 1;
   case PRECISION_HIGH:
      *precision = SLANG_PREC_HIGH;
      return 1;
   default:
      RETURN0;
   }
}

static int
parse_fully_specified_type(slang_parse_ctx * C, slang_output_ctx * O,
                           slang_fully_specified_type * type)
{
   if (!parse_layout_qualifiers(C, &type->layout))
      RETURN0;

   if (!parse_type_variant(C, &type->variant))
      RETURN0;

   if (!parse_type_centroid(C, &type->centroid))
      RETURN0;

   if (!parse_type_qualifier(C, &type->qualifier))
      RETURN0;

   if (!parse_type_precision(C, &type->precision))
      RETURN0;

   if (!parse_type_specifier(C, O, &type->specifier))
      RETURN0;

   if (!parse_type_array_size(C, O, &type->array_len))
      RETURN0;

   if (!O->allow_invariant && type->variant == SLANG_INVARIANT) {
      slang_info_log_error(C->L,
         "'invariant' keyword not allowed (perhaps set #version 120)");
      RETURN0;
   }

   if (!O->allow_centroid && type->centroid == SLANG_CENTROID) {
      slang_info_log_error(C->L,
         "'centroid' keyword not allowed (perhaps set #version 120)");
      RETURN0;
   }
   else if (type->centroid == SLANG_CENTROID &&
            type->qualifier != SLANG_QUAL_VARYING) {
      slang_info_log_error(C->L,
         "'centroid' keyword only allowed for varying vars");
      RETURN0;
   }


   /* need this?
   if (type->qualifier != SLANG_QUAL_VARYING &&
       type->variant == SLANG_INVARIANT) {
      slang_info_log_error(C->L,
                           "invariant qualifer only allowed for varying vars");
      RETURN0;
   }
   */

   if (O->allow_precision) {
      if (type->precision == SLANG_PREC_DEFAULT) {
         assert(type->specifier.type < TYPE_SPECIFIER_COUNT);
         /* use the default precision for this datatype */
         type->precision = O->default_precision[type->specifier.type];
      }
   }
   else {
      /* only default is allowed */
      if (type->precision != SLANG_PREC_DEFAULT) {
         slang_info_log_error(C->L, "precision qualifiers not allowed");
         RETURN0;
      }
   }

   if (!O->allow_array_types && type->array_len >= 0) {
      slang_info_log_error(C->L, "first-class array types not allowed");
      RETURN0;
   }

   if (type->array_len >= 0) {
      /* convert type to array type (ex: convert "int" to "array of int" */
      promote_type_to_array(C, type, type->array_len);
   }

   return 1;
}

/* operation */
#define OP_END 0
#define OP_BLOCK_BEGIN_NO_NEW_SCOPE 1
#define OP_BLOCK_BEGIN_NEW_SCOPE 2
#define OP_DECLARE 3
#define OP_ASM 4
#define OP_BREAK 5
#define OP_CONTINUE 6
#define OP_DISCARD 7
#define OP_RETURN 8
#define OP_EXPRESSION 9
#define OP_IF 10
#define OP_WHILE 11
#define OP_DO 12
#define OP_FOR 13
#define OP_PUSH_VOID 14
#define OP_PUSH_BOOL 15
#define OP_PUSH_INT 16
#define OP_PUSH_FLOAT 17
#define OP_PUSH_IDENTIFIER 18
#define OP_SEQUENCE 19
#define OP_ASSIGN 20
#define OP_ADDASSIGN 21
#define OP_SUBASSIGN 22
#define OP_MULASSIGN 23
#define OP_DIVASSIGN 24
/*#define OP_MODASSIGN 25*/
/*#define OP_LSHASSIGN 26*/
/*#define OP_RSHASSIGN 27*/
/*#define OP_ORASSIGN 28*/
/*#define OP_XORASSIGN 29*/
/*#define OP_ANDASSIGN 30*/
#define OP_SELECT 31
#define OP_LOGICALOR 32
#define OP_LOGICALXOR 33
#define OP_LOGICALAND 34
/*#define OP_BITOR 35*/
/*#define OP_BITXOR 36*/
/*#define OP_BITAND 37*/
#define OP_EQUAL 38
#define OP_NOTEQUAL 39
#define OP_LESS 40
#define OP_GREATER 41
#define OP_LESSEQUAL 42
#define OP_GREATEREQUAL 43
/*#define OP_LSHIFT 44*/
/*#define OP_RSHIFT 45*/
#define OP_ADD 46
#define OP_SUBTRACT 47
#define OP_MULTIPLY 48
#define OP_DIVIDE 49
/*#define OP_MODULUS 50*/
#define OP_PREINCREMENT 51
#define OP_PREDECREMENT 52
#define OP_PLUS 53
#define OP_MINUS 54
/*#define OP_COMPLEMENT 55*/
#define OP_NOT 56
#define OP_SUBSCRIPT 57
#define OP_CALL 58
#define OP_FIELD 59
#define OP_POSTINCREMENT 60
#define OP_POSTDECREMENT 61
#define OP_PRECISION 62
#define OP_METHOD 63


/**
 * When parsing a compound production, this function is used to parse the
 * children.
 * For example, a while-loop compound will have two children, the
 * while condition expression and the loop body.  So, this function will
 * be called twice to parse those two sub-expressions.
 * \param C  the parsing context
 * \param O  the output context
 * \param oper  the operation we're parsing
 * \param statement  indicates whether parsing a statement, or expression
 * \return 1 if success, 0 if error
 */
static int
parse_child_operation(slang_parse_ctx * C, slang_output_ctx * O,
                      slang_operation * oper, GLboolean statement)
{
   slang_operation *ch;

   /* grow child array */
   ch = slang_operation_grow(&oper->num_children, &oper->children);
   if (statement)
      return parse_statement(C, O, ch);
   return parse_expression(C, O, ch);
}

static int parse_declaration(slang_parse_ctx * C, slang_output_ctx * O);

static int
parse_statement(slang_parse_ctx * C, slang_output_ctx * O,
                slang_operation * oper)
{
   int op;

   oper->locals->outer_scope = O->vars;

   op = *C->I++;
   switch (op) {
   case OP_BLOCK_BEGIN_NO_NEW_SCOPE:
      /* parse child statements, do not create new variable scope */
      oper->type = SLANG_OPER_BLOCK_NO_NEW_SCOPE;
      while (*C->I != OP_END)
         if (!parse_child_operation(C, O, oper, GL_TRUE))
            RETURN0;
      C->I++;
      break;
   case OP_BLOCK_BEGIN_NEW_SCOPE:
      /* parse child statements, create new variable scope */
      {
         slang_output_ctx o = *O;

         oper->type = SLANG_OPER_BLOCK_NEW_SCOPE;
         o.vars = oper->locals;
         while (*C->I != OP_END)
            if (!parse_child_operation(C, &o, oper, GL_TRUE))
               RETURN0;
         C->I++;
      }
      break;
   case OP_DECLARE:
      /* local variable declaration, individual declarators are stored as
       * children identifiers
       */
      oper->type = SLANG_OPER_BLOCK_NO_NEW_SCOPE;
      {
         const unsigned int first_var = O->vars->num_variables;

         /* parse the declaration, note that there can be zero or more
          * than one declarators
          */
         if (!parse_declaration(C, O))
            RETURN0;
         if (first_var < O->vars->num_variables) {
            const unsigned int num_vars = O->vars->num_variables - first_var;
            unsigned int i;
            assert(oper->num_children == 0);
            oper->num_children = num_vars;
            oper->children = slang_operation_new(num_vars);
            if (oper->children == NULL) {
               slang_info_log_memory(C->L);
               RETURN0;
            }
            for (i = first_var; i < O->vars->num_variables; i++) {
               slang_operation *o = &oper->children[i - first_var];
               slang_variable *var = O->vars->variables[i];
               o->type = SLANG_OPER_VARIABLE_DECL;
               o->locals->outer_scope = O->vars;
               o->a_id = var->a_name;

               /* new/someday...
               calculate_var_size(C, O, var);
               */

               if (!legal_identifier(o->a_id)) {
                  slang_info_log_error(C->L, "illegal variable name '%s'",
                                       (char *) o->a_id);
                  RETURN0;
               }
            }
         }
      }
      break;
   case OP_ASM:
      /* the __asm statement, parse the mnemonic and all its arguments
       * as expressions
       */
      oper->type = SLANG_OPER_ASM;
      oper->a_id = parse_identifier(C);
      if (oper->a_id == SLANG_ATOM_NULL)
         RETURN0;
      while (*C->I != OP_END) {
         if (!parse_child_operation(C, O, oper, GL_FALSE))
            RETURN0;
      }
      C->I++;
      break;
   case OP_BREAK:
      oper->type = SLANG_OPER_BREAK;
      break;
   case OP_CONTINUE:
      oper->type = SLANG_OPER_CONTINUE;
      break;
   case OP_DISCARD:
      oper->type = SLANG_OPER_DISCARD;
      break;
   case OP_RETURN:
      oper->type = SLANG_OPER_RETURN;
      if (!parse_child_operation(C, O, oper, GL_FALSE))
         RETURN0;
      break;
   case OP_EXPRESSION:
      oper->type = SLANG_OPER_EXPRESSION;
      if (!parse_child_operation(C, O, oper, GL_FALSE))
         RETURN0;
      break;
   case OP_IF:
      oper->type = SLANG_OPER_IF;
      if (!parse_child_operation(C, O, oper, GL_FALSE))
         RETURN0;
      if (!parse_child_operation(C, O, oper, GL_TRUE))
         RETURN0;
      if (!parse_child_operation(C, O, oper, GL_TRUE))
         RETURN0;
      break;
   case OP_WHILE:
      {
         slang_output_ctx o = *O;

         oper->type = SLANG_OPER_WHILE;
         o.vars = oper->locals;
         if (!parse_child_operation(C, &o, oper, GL_TRUE))
            RETURN0;
         if (!parse_child_operation(C, &o, oper, GL_TRUE))
            RETURN0;
      }
      break;
   case OP_DO:
      oper->type = SLANG_OPER_DO;
      if (!parse_child_operation(C, O, oper, GL_TRUE))
         RETURN0;
      if (!parse_child_operation(C, O, oper, GL_FALSE))
         RETURN0;
      break;
   case OP_FOR:
      {
         slang_output_ctx o = *O;

         oper->type = SLANG_OPER_FOR;
         o.vars = oper->locals;
         if (!parse_child_operation(C, &o, oper, GL_TRUE))
            RETURN0;
         if (!parse_child_operation(C, &o, oper, GL_TRUE))
            RETURN0;
         if (!parse_child_operation(C, &o, oper, GL_FALSE))
            RETURN0;
         if (!parse_child_operation(C, &o, oper, GL_TRUE))
            RETURN0;
      }
      break;
   case OP_PRECISION:
      {
         /* set default precision for a type in this scope */
         /* ignored at this time */
         int prec_qual = *C->I++;
         int datatype = *C->I++;
         (void) prec_qual;
         (void) datatype;
      }
      break;
   default:
      /*printf("Unexpected operation %d\n", op);*/
      RETURN0;
   }
   return 1;
}

static int
handle_nary_expression(slang_parse_ctx * C, slang_operation * op,
                       slang_operation ** ops, unsigned int *total_ops,
                       unsigned int n)
{
   unsigned int i;

   op->children = slang_operation_new(n);
   if (op->children == NULL) {
      slang_info_log_memory(C->L);
      RETURN0;
   }
   op->num_children = n;

   for (i = 0; i < n; i++) {
      slang_operation_destruct(&op->children[i]);
      op->children[i] = (*ops)[*total_ops - (n + 1 - i)];
   }

   (*ops)[*total_ops - (n + 1)] = (*ops)[*total_ops - 1];
   *total_ops -= n;

   *ops = (slang_operation *)
      _slang_realloc(*ops,
                     (*total_ops + n) * sizeof(slang_operation),
                     *total_ops * sizeof(slang_operation));
   if (*ops == NULL) {
      slang_info_log_memory(C->L);
      RETURN0;
   }
   return 1;
}

static int
is_constructor_name(const char *name, slang_atom a_name,
                    slang_struct_scope * structs)
{
   if (slang_type_specifier_type_from_string(name) != SLANG_SPEC_VOID)
      return 1;
   return slang_struct_scope_find(structs, a_name, 1) != NULL;
}

#define FUNCTION_CALL_NONARRAY 0
#define FUNCTION_CALL_ARRAY    1

static int
parse_expression(slang_parse_ctx * C, slang_output_ctx * O,
                 slang_operation * oper)
{
   slang_operation *ops = NULL;
   unsigned int num_ops = 0;
   int number;

   while (*C->I != OP_END) {
      slang_operation *op;
      const unsigned int op_code = *C->I++;

      /* allocate default operation, becomes a no-op if not used  */
      ops = (slang_operation *)
         _slang_realloc(ops,
                        num_ops * sizeof(slang_operation),
                        (num_ops + 1) * sizeof(slang_operation));
      if (ops == NULL) {
         slang_info_log_memory(C->L);
         RETURN0;
      }
      op = &ops[num_ops];
      if (!slang_operation_construct(op)) {
         slang_info_log_memory(C->L);
         RETURN0;
      }
      num_ops++;
      op->locals->outer_scope = O->vars;

      switch (op_code) {
      case OP_PUSH_VOID:
         op->type = SLANG_OPER_VOID;
         break;
      case OP_PUSH_BOOL:
         op->type = SLANG_OPER_LITERAL_BOOL;
         if (!parse_number(C, &number))
            RETURN0;
         op->literal[0] =
         op->literal[1] =
         op->literal[2] =
         op->literal[3] = (GLfloat) number;
         op->literal_size = 1;
         break;
      case OP_PUSH_INT:
         op->type = SLANG_OPER_LITERAL_INT;
         if (!parse_number(C, &number))
            RETURN0;
         op->literal[0] =
         op->literal[1] =
         op->literal[2] =
         op->literal[3] = (GLfloat) number;
         op->literal_size = 1;
         break;
      case OP_PUSH_FLOAT:
         op->type = SLANG_OPER_LITERAL_FLOAT;
         if (!parse_float(C, &op->literal[0]))
            RETURN0;
         op->literal[1] =
         op->literal[2] =
         op->literal[3] = op->literal[0];
         op->literal_size = 1;
         break;
      case OP_PUSH_IDENTIFIER:
         op->type = SLANG_OPER_IDENTIFIER;
         op->a_id = parse_identifier(C);
         if (op->a_id == SLANG_ATOM_NULL)
            RETURN0;
         break;
      case OP_SEQUENCE:
         op->type = SLANG_OPER_SEQUENCE;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_ASSIGN:
         op->type = SLANG_OPER_ASSIGN;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_ADDASSIGN:
         op->type = SLANG_OPER_ADDASSIGN;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_SUBASSIGN:
         op->type = SLANG_OPER_SUBASSIGN;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_MULASSIGN:
         op->type = SLANG_OPER_MULASSIGN;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_DIVASSIGN:
         op->type = SLANG_OPER_DIVASSIGN;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
         /*case OP_MODASSIGN: */
         /*case OP_LSHASSIGN: */
         /*case OP_RSHASSIGN: */
         /*case OP_ORASSIGN: */
         /*case OP_XORASSIGN: */
         /*case OP_ANDASSIGN: */
      case OP_SELECT:
         op->type = SLANG_OPER_SELECT;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 3))
            RETURN0;
         break;
      case OP_LOGICALOR:
         op->type = SLANG_OPER_LOGICALOR;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_LOGICALXOR:
         op->type = SLANG_OPER_LOGICALXOR;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_LOGICALAND:
         op->type = SLANG_OPER_LOGICALAND;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
         /*case OP_BITOR: */
         /*case OP_BITXOR: */
         /*case OP_BITAND: */
      case OP_EQUAL:
         op->type = SLANG_OPER_EQUAL;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_NOTEQUAL:
         op->type = SLANG_OPER_NOTEQUAL;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_LESS:
         op->type = SLANG_OPER_LESS;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_GREATER:
         op->type = SLANG_OPER_GREATER;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_LESSEQUAL:
         op->type = SLANG_OPER_LESSEQUAL;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_GREATEREQUAL:
         op->type = SLANG_OPER_GREATEREQUAL;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
         /*case OP_LSHIFT: */
         /*case OP_RSHIFT: */
      case OP_ADD:
         op->type = SLANG_OPER_ADD;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_SUBTRACT:
         op->type = SLANG_OPER_SUBTRACT;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_MULTIPLY:
         op->type = SLANG_OPER_MULTIPLY;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_DIVIDE:
         op->type = SLANG_OPER_DIVIDE;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
         /*case OP_MODULUS: */
      case OP_PREINCREMENT:
         op->type = SLANG_OPER_PREINCREMENT;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            RETURN0;
         break;
      case OP_PREDECREMENT:
         op->type = SLANG_OPER_PREDECREMENT;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            RETURN0;
         break;
      case OP_PLUS:
         op->type = SLANG_OPER_PLUS;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            RETURN0;
         break;
      case OP_MINUS:
         op->type = SLANG_OPER_MINUS;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            RETURN0;
         break;
      case OP_NOT:
         op->type = SLANG_OPER_NOT;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            RETURN0;
         break;
         /*case OP_COMPLEMENT: */
      case OP_SUBSCRIPT:
         op->type = SLANG_OPER_SUBSCRIPT;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            RETURN0;
         break;
      case OP_METHOD:
         op->type = SLANG_OPER_METHOD;
         op->a_obj = parse_identifier(C);
         if (op->a_obj == SLANG_ATOM_NULL)
            RETURN0;

         op->a_id = parse_identifier(C);
         if (op->a_id == SLANG_ATOM_NULL)
            RETURN0;

         assert(*C->I == OP_END);
         C->I++;

         while (*C->I != OP_END)
            if (!parse_child_operation(C, O, op, GL_FALSE))
               RETURN0;
         C->I++;
#if 0
         /* don't lookup the method (not yet anyway) */
         if (!C->parsing_builtin
             && !slang_function_scope_find_by_name(O->funs, op->a_id, 1)) {
            const char *id;

            id = slang_atom_pool_id(C->atoms, op->a_id);
            if (!is_constructor_name(id, op->a_id, O->structs)) {
               slang_info_log_error(C->L, "%s: undeclared function name.", id);
               RETURN0;
            }
         }
#endif
         break;
      case OP_CALL:
         {
            GLboolean array_constructor = GL_FALSE;
            GLint array_constructor_size = 0;

            op->type = SLANG_OPER_CALL;
            op->a_id = parse_identifier(C);
            if (op->a_id == SLANG_ATOM_NULL)
               RETURN0;
            switch (*C->I++) {
            case FUNCTION_CALL_NONARRAY:
               /* Nothing to do. */
               break;
            case FUNCTION_CALL_ARRAY:
               /* Calling an array constructor. For example:
                *   float[3](1.1, 2.2, 3.3);
                */
               if (!O->allow_array_types) {
                  slang_info_log_error(C->L,
                                       "array constructors not allowed "
                                       "in this GLSL version");
                  RETURN0;
               }
               else {
                  /* parse the array constructor size */
                  slang_operation array_size;
                  array_constructor = GL_TRUE;
                  slang_operation_construct(&array_size);
                  if (!parse_expression(C, O, &array_size)) {
                     slang_operation_destruct(&array_size);
                     return GL_FALSE;
                  }
                  if (array_size.type != SLANG_OPER_LITERAL_INT) {
                     slang_info_log_error(C->L,
                        "constructor array size is not an integer");
                     slang_operation_destruct(&array_size);
                     RETURN0;
                  }
                  array_constructor_size = (int) array_size.literal[0];
                  op->array_constructor = GL_TRUE;
                  slang_operation_destruct(&array_size);
               }
               break;
            default:
               assert(0);
               RETURN0;
            }
            while (*C->I != OP_END)
               if (!parse_child_operation(C, O, op, GL_FALSE))
                  RETURN0;
            C->I++;

            if (array_constructor &&
                array_constructor_size != op->num_children) {
               slang_info_log_error(C->L, "number of parameters to array"
                                    " constructor does not match array size");
               RETURN0;
            }

            if (!C->parsing_builtin
                && !slang_function_scope_find_by_name(O->funs, op->a_id, 1)) {
               const char *id;

               id = slang_atom_pool_id(C->atoms, op->a_id);
               if (!is_constructor_name(id, op->a_id, O->structs)) {
                  slang_info_log_error(C->L, "%s: undeclared function name.", id);
                  RETURN0;
               }
            }
         }
         break;
      case OP_FIELD:
         op->type = SLANG_OPER_FIELD;
         op->a_id = parse_identifier(C);
         if (op->a_id == SLANG_ATOM_NULL)
            RETURN0;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            RETURN0;
         break;
      case OP_POSTINCREMENT:
         op->type = SLANG_OPER_POSTINCREMENT;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            RETURN0;
         break;
      case OP_POSTDECREMENT:
         op->type = SLANG_OPER_POSTDECREMENT;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            RETURN0;
         break;
      default:
         RETURN0;
      }
   }
   C->I++;

   slang_operation_destruct(oper);
   *oper = *ops; /* struct copy */
   _slang_free(ops);

   return 1;
}

/* parameter qualifier */
#define PARAM_QUALIFIER_IN 0
#define PARAM_QUALIFIER_OUT 1
#define PARAM_QUALIFIER_INOUT 2

/* function parameter array presence */
#define PARAMETER_ARRAY_NOT_PRESENT 0
#define PARAMETER_ARRAY_PRESENT 1

static int
parse_parameter_declaration(slang_parse_ctx * C, slang_output_ctx * O,
                            slang_variable * param)
{
   int param_qual, precision_qual;

   /* parse and validate the parameter's type qualifiers (there can be
    * two at most) because not all combinations are valid
    */
   if (!parse_type_qualifier(C, &param->type.qualifier))
      RETURN0;

   param_qual = *C->I++;
   switch (param_qual) {
   case PARAM_QUALIFIER_IN:
      if (param->type.qualifier != SLANG_QUAL_CONST
          && param->type.qualifier != SLANG_QUAL_NONE) {
         slang_info_log_error(C->L, "Invalid type qualifier.");
         RETURN0;
      }
      break;
   case PARAM_QUALIFIER_OUT:
      if (param->type.qualifier == SLANG_QUAL_NONE)
         param->type.qualifier = SLANG_QUAL_OUT;
      else {
         slang_info_log_error(C->L, "Invalid type qualifier.");
         RETURN0;
      }
      break;
   case PARAM_QUALIFIER_INOUT:
      if (param->type.qualifier == SLANG_QUAL_NONE)
         param->type.qualifier = SLANG_QUAL_INOUT;
      else {
         slang_info_log_error(C->L, "Invalid type qualifier.");
         RETURN0;
      }
      break;
   default:
      RETURN0;
   }

   /* parse precision qualifier (lowp, mediump, highp */
   precision_qual = *C->I++;
   /* ignored at this time */
   (void) precision_qual;

   /* parse parameter's type specifier and name */
   if (!parse_type_specifier(C, O, &param->type.specifier))
      RETURN0;
   if (!parse_type_array_size(C, O, &param->type.array_len))
      RETURN0;
   param->a_name = parse_identifier(C);
   if (param->a_name == SLANG_ATOM_NULL)
      RETURN0;

   /* first-class array
    */
   if (param->type.array_len >= 0) {
      slang_type_specifier p;

      slang_type_specifier_ctr(&p);
      if (!slang_type_specifier_copy(&p, &param->type.specifier)) {
         slang_type_specifier_dtr(&p);
         RETURN0;
      }
      if (!convert_to_array(C, param, &p)) {
         slang_type_specifier_dtr(&p);
         RETURN0;
      }
      slang_type_specifier_dtr(&p);
      param->array_len = param->type.array_len;
   }

   /* if the parameter is an array, parse its size (the size must be
    * explicitly defined
    */
   if (*C->I++ == PARAMETER_ARRAY_PRESENT) {
      slang_type_specifier p;

      if (param->type.array_len >= 0) {
         slang_info_log_error(C->L, "multi-dimensional arrays not allowed");
         RETURN0;
      }
      slang_type_specifier_ctr(&p);
      if (!slang_type_specifier_copy(&p, &param->type.specifier)) {
         slang_type_specifier_dtr(&p);
         RETURN0;
      }
      if (!convert_to_array(C, param, &p)) {
         slang_type_specifier_dtr(&p);
         RETURN0;
      }
      slang_type_specifier_dtr(&p);
      if (!parse_array_len(C, O, &param->array_len))
         RETURN0;
   }

#if 0
   /* calculate the parameter size */
   if (!calculate_var_size(C, O, param))
      RETURN0;
#endif
   /* TODO: allocate the local address here? */
   return 1;
}

/* function type */
#define FUNCTION_ORDINARY 0
#define FUNCTION_CONSTRUCTOR 1
#define FUNCTION_OPERATOR 2

/* function parameter */
#define PARAMETER_NONE 0
#define PARAMETER_NEXT 1

/* operator type */
#define OPERATOR_ADDASSIGN 1
#define OPERATOR_SUBASSIGN 2
#define OPERATOR_MULASSIGN 3
#define OPERATOR_DIVASSIGN 4
/*#define OPERATOR_MODASSIGN 5*/
/*#define OPERATOR_LSHASSIGN 6*/
/*#define OPERATOR_RSHASSIGN 7*/
/*#define OPERATOR_ANDASSIGN 8*/
/*#define OPERATOR_XORASSIGN 9*/
/*#define OPERATOR_ORASSIGN 10*/
#define OPERATOR_LOGICALXOR 11
/*#define OPERATOR_BITOR 12*/
/*#define OPERATOR_BITXOR 13*/
/*#define OPERATOR_BITAND 14*/
#define OPERATOR_LESS 15
#define OPERATOR_GREATER 16
#define OPERATOR_LESSEQUAL 17
#define OPERATOR_GREATEREQUAL 18
/*#define OPERATOR_LSHIFT 19*/
/*#define OPERATOR_RSHIFT 20*/
#define OPERATOR_MULTIPLY 21
#define OPERATOR_DIVIDE 22
/*#define OPERATOR_MODULUS 23*/
#define OPERATOR_INCREMENT 24
#define OPERATOR_DECREMENT 25
#define OPERATOR_PLUS 26
#define OPERATOR_MINUS 27
/*#define OPERATOR_COMPLEMENT 28*/
#define OPERATOR_NOT 29

static const struct
{
   unsigned int o_code;
   const char *o_name;
} operator_names[] = {
   {OPERATOR_INCREMENT, "++"},
   {OPERATOR_ADDASSIGN, "+="},
   {OPERATOR_PLUS, "+"},
   {OPERATOR_DECREMENT, "--"},
   {OPERATOR_SUBASSIGN, "-="},
   {OPERATOR_MINUS, "-"},
   {OPERATOR_NOT, "!"},
   {OPERATOR_MULASSIGN, "*="},
   {OPERATOR_MULTIPLY, "*"},
   {OPERATOR_DIVASSIGN, "/="},
   {OPERATOR_DIVIDE, "/"},
   {OPERATOR_LESSEQUAL, "<="},
   /*{ OPERATOR_LSHASSIGN, "<<=" }, */
   /*{ OPERATOR_LSHIFT, "<<" }, */
   {OPERATOR_LESS, "<"},
   {OPERATOR_GREATEREQUAL, ">="},
   /*{ OPERATOR_RSHASSIGN, ">>=" }, */
   /*{ OPERATOR_RSHIFT, ">>" }, */
   {OPERATOR_GREATER, ">"},
   /*{ OPERATOR_MODASSIGN, "%=" }, */
   /*{ OPERATOR_MODULUS, "%" }, */
   /*{ OPERATOR_ANDASSIGN, "&=" }, */
   /*{ OPERATOR_BITAND, "&" }, */
   /*{ OPERATOR_ORASSIGN, "|=" }, */
   /*{ OPERATOR_BITOR, "|" }, */
   /*{ OPERATOR_COMPLEMENT, "~" }, */
   /*{ OPERATOR_XORASSIGN, "^=" }, */
   {OPERATOR_LOGICALXOR, "^^"},
   /*{ OPERATOR_BITXOR, "^" } */
};

static slang_atom
parse_operator_name(slang_parse_ctx * C)
{
   unsigned int i;

   for (i = 0; i < sizeof(operator_names) / sizeof(*operator_names); i++) {
      if (operator_names[i].o_code == (unsigned int) (*C->I)) {
         slang_atom atom =
            slang_atom_pool_atom(C->atoms, operator_names[i].o_name);
         if (atom == SLANG_ATOM_NULL) {
            slang_info_log_memory(C->L);
            RETURN0;
         }
         C->I++;
         return atom;
      }
   }
   RETURN0;
}


static int
parse_function_prototype(slang_parse_ctx * C, slang_output_ctx * O,
                         slang_function * func)
{
   GLuint functype;
   /* parse function type and name */
   if (!parse_fully_specified_type(C, O, &func->header.type))
      RETURN0;

   functype = *C->I++;
   switch (functype) {
   case FUNCTION_ORDINARY:
      func->kind = SLANG_FUNC_ORDINARY;
      func->header.a_name = parse_identifier(C);
      if (func->header.a_name == SLANG_ATOM_NULL)
         RETURN0;
      break;
   case FUNCTION_CONSTRUCTOR:
      func->kind = SLANG_FUNC_CONSTRUCTOR;
      if (func->header.type.specifier.type == SLANG_SPEC_STRUCT)
         RETURN0;
      func->header.a_name =
         slang_atom_pool_atom(C->atoms,
                              slang_type_specifier_type_to_string
                              (func->header.type.specifier.type));
      if (func->header.a_name == SLANG_ATOM_NULL) {
         slang_info_log_memory(C->L);
         RETURN0;
      }
      break;
   case FUNCTION_OPERATOR:
      func->kind = SLANG_FUNC_OPERATOR;
      func->header.a_name = parse_operator_name(C);
      if (func->header.a_name == SLANG_ATOM_NULL)
         RETURN0;
      break;
   default:
      RETURN0;
   }

   if (!legal_identifier(func->header.a_name)) {
      slang_info_log_error(C->L, "illegal function name '%s'",
                           (char *) func->header.a_name);
      RETURN0;
   }

   /* parse function parameters */
   while (*C->I++ == PARAMETER_NEXT) {
      slang_variable *p = slang_variable_scope_grow(func->parameters);
      if (!p) {
         slang_info_log_memory(C->L);
         RETURN0;
      }
      if (!parse_parameter_declaration(C, O, p))
         RETURN0;
   }

   /* if the function returns a value, append a hidden __retVal 'out'
    * parameter that corresponds to the return value.
    */
   if (_slang_function_has_return_value(func)) {
      slang_variable *p = slang_variable_scope_grow(func->parameters);
      slang_atom a_retVal = slang_atom_pool_atom(C->atoms, "__retVal");
      assert(a_retVal);
      p->a_name = a_retVal;
      p->type = func->header.type;
      p->type.qualifier = SLANG_QUAL_OUT;
   }

   /* function formal parameters and local variables share the same
    * scope, so save the information about param count in a seperate
    * place also link the scope to the global variable scope so when a
    * given identifier is not found here, the search process continues
    * in the global space
    */
   func->param_count = func->parameters->num_variables;
   func->parameters->outer_scope = O->vars;

   return 1;
}

static int
parse_function_definition(slang_parse_ctx * C, slang_output_ctx * O,
                          slang_function * func)
{
   slang_output_ctx o = *O;

   if (!parse_function_prototype(C, O, func))
      RETURN0;

   /* create function's body operation */
   func->body = (slang_operation *) _slang_alloc(sizeof(slang_operation));
   if (func->body == NULL) {
      slang_info_log_memory(C->L);
      RETURN0;
   }
   if (!slang_operation_construct(func->body)) {
      _slang_free(func->body);
      func->body = NULL;
      slang_info_log_memory(C->L);
      RETURN0;
   }

   /* to parse the body the parse context is modified in order to
    * capture parsed variables into function's local variable scope
    */
   C->global_scope = GL_FALSE;
   o.vars = func->parameters;
   if (!parse_statement(C, &o, func->body))
      RETURN0;

   C->global_scope = GL_TRUE;
   return 1;
}

static GLboolean
initialize_global(slang_assemble_ctx * A, slang_variable * var)
{
   slang_operation op_id, op_assign;
   GLboolean result;

   /* construct the left side of assignment */
   if (!slang_operation_construct(&op_id))
      return GL_FALSE;
   op_id.type = SLANG_OPER_IDENTIFIER;
   op_id.a_id = var->a_name;

   /* put the variable into operation's scope */
   op_id.locals->variables =
      (slang_variable **) _slang_alloc(sizeof(slang_variable *));
   if (op_id.locals->variables == NULL) {
      slang_operation_destruct(&op_id);
      return GL_FALSE;
   }
   op_id.locals->num_variables = 1;
   op_id.locals->variables[0] = var;

   /* construct the assignment expression */
   if (!slang_operation_construct(&op_assign)) {
      op_id.locals->num_variables = 0;
      slang_operation_destruct(&op_id);
      return GL_FALSE;
   }
   op_assign.type = SLANG_OPER_ASSIGN;
   op_assign.children =
      (slang_operation *) _slang_alloc(2 * sizeof(slang_operation));
   if (op_assign.children == NULL) {
      slang_operation_destruct(&op_assign);
      op_id.locals->num_variables = 0;
      slang_operation_destruct(&op_id);
      return GL_FALSE;
   }
   op_assign.num_children = 2;
   op_assign.children[0] = op_id;
   op_assign.children[1] = *var->initializer;

   result = 1;

   /* carefully destroy the operations */
   op_assign.num_children = 0;
   _slang_free(op_assign.children);
   op_assign.children = NULL;
   slang_operation_destruct(&op_assign);
   op_id.locals->num_variables = 0;
   slang_operation_destruct(&op_id);

   if (!result)
      return GL_FALSE;

   return GL_TRUE;
}

/* init declarator list */
#define DECLARATOR_NONE 0
#define DECLARATOR_NEXT 1

/* variable declaration */
#define VARIABLE_NONE 0
#define VARIABLE_IDENTIFIER 1
#define VARIABLE_INITIALIZER 2
#define VARIABLE_ARRAY_EXPLICIT 3
#define VARIABLE_ARRAY_UNKNOWN 4


/**
 * Check if it's OK to re-declare a variable with the given new type.
 * This happens when applying layout qualifiers to gl_FragCoord or
 * (re)setting an array size.
 * If redeclaration is OK, return a pointer to the incoming variable
 * updated with new type info.  Else return NULL;
 */
static slang_variable *
redeclare_variable(slang_variable *var, 
                   const slang_fully_specified_type *type)
{
   if (slang_fully_specified_types_compatible(&var->type, type)) {
      /* replace orig var layout with new layout */
      var->type.layout = type->layout;

      /* XXX there may be other type updates in the future here */

      return var;
   }
   else
      return NULL;
}


/**
 * Parse the initializer for a variable declaration.
 */
static int
parse_init_declarator(slang_parse_ctx * C, slang_output_ctx * O,
                      const slang_fully_specified_type * type)
{
   GET_CURRENT_CONTEXT(ctx); /* a hack */
   slang_variable *var = NULL, *prevDecl;
   slang_atom a_name;

   /* empty init declatator (without name, e.g. "float ;") */
   if (*C->I++ == VARIABLE_NONE)
      return 1;

   a_name = parse_identifier(C);

   /* check if name is already in this scope */
   prevDecl = _slang_variable_locate(O->vars, a_name, C->global_scope);
   if (prevDecl) {
      /* A var with this name has already been declared.
       * Check if redeclaring the var with a different type/layout is legal.
       */
      if (C->global_scope) {
         var = redeclare_variable(prevDecl, type);
      }
      if (!var) {
         slang_info_log_error(C->L,
                   "declaration of '%s' conflicts with previous declaration",
                   (char *) a_name);
         RETURN0;
      }
   }

   if (!var) {
      /* make room for a new variable and initialize it */
      var = slang_variable_scope_grow(O->vars);
      if (!var) {
         slang_info_log_memory(C->L);
         RETURN0;
      }

      /* copy the declarator type qualifier/etc info, parse the identifier */
      var->type.qualifier = type->qualifier;
      var->type.centroid = type->centroid;
      var->type.precision = type->precision;
      var->type.specifier = type->specifier;/*new*/
      var->type.variant = type->variant;
      var->type.layout = type->layout;
      var->type.array_len = type->array_len;
      var->a_name = a_name;
      if (var->a_name == SLANG_ATOM_NULL)
         RETURN0;
   }

   switch (*C->I++) {
   case VARIABLE_NONE:
      /* simple variable declarator - just copy the specifier */
      if (!slang_type_specifier_copy(&var->type.specifier, &type->specifier))
         RETURN0;
      break;
   case VARIABLE_INITIALIZER:
      /* initialized variable - copy the specifier and parse the expression */
      if (0 && type->array_len >= 0) {
         /* The type was something like "float[4]" */
         convert_to_array(C, var, &type->specifier);
         var->array_len = type->array_len;
      }
      else {
         if (!slang_type_specifier_copy(&var->type.specifier, &type->specifier))
            RETURN0;
      }
      var->initializer =
         (slang_operation *) _slang_alloc(sizeof(slang_operation));
      if (var->initializer == NULL) {
         slang_info_log_memory(C->L);
         RETURN0;
      }
      if (!slang_operation_construct(var->initializer)) {
         _slang_free(var->initializer);
         var->initializer = NULL;
         slang_info_log_memory(C->L);
         RETURN0;
      }
      if (!parse_expression(C, O, var->initializer))
         RETURN0;
      break;
   case VARIABLE_ARRAY_UNKNOWN:
      /* unsized array - mark it as array and copy the specifier to
       * the array element
       */
      if (type->array_len >= 0) {
         slang_info_log_error(C->L, "multi-dimensional arrays not allowed");
         RETURN0;
      }
      if (!convert_to_array(C, var, &type->specifier))
         return GL_FALSE;
      break;
   case VARIABLE_ARRAY_EXPLICIT:
      if (type->array_len >= 0) {
         /* the user is trying to do something like: float[2] x[3]; */
         slang_info_log_error(C->L, "multi-dimensional arrays not allowed");
         RETURN0;
      }
      if (!convert_to_array(C, var, &type->specifier))
         return GL_FALSE;
      if (!parse_array_len(C, O, &var->array_len))
         return GL_FALSE;
      break;
   default:
      RETURN0;
   }

   /* allocate global address space for a variable with a known size */
   if (C->global_scope
       && !(var->type.specifier.type == SLANG_SPEC_ARRAY
            && var->array_len == 0)) {
      if (!calculate_var_size(C, O, var))
         return GL_FALSE;
   }

   /* emit code for global var decl */
   if (C->global_scope) {
      slang_assemble_ctx A;
      memset(&A, 0, sizeof(slang_assemble_ctx));
      A.allow_uniform_initializers = C->version > 110;
      A.atoms = C->atoms;
      A.space.funcs = O->funs;
      A.space.structs = O->structs;
      A.space.vars = O->vars;
      A.program = O->program;
      A.pragmas = O->pragmas;
      A.vartable = O->vartable;
      A.log = C->L;
      A.curFuncEndLabel = NULL;
      A.EmitContReturn = ctx->Shader.EmitContReturn;
      if (!_slang_codegen_global_variable(&A, var, C->type))
         RETURN0;
   }

   /* initialize global variable */
   if (C->global_scope) {
      if (var->initializer != NULL) {
         slang_assemble_ctx A;
         memset(&A, 0, sizeof(slang_assemble_ctx));
         A.allow_uniform_initializers = C->version > 110;
         A.atoms = C->atoms;
         A.space.funcs = O->funs;
         A.space.structs = O->structs;
         A.space.vars = O->vars;
         if (!initialize_global(&A, var))
            RETURN0;
      }
   }

   if (var->type.qualifier == SLANG_QUAL_FIXEDINPUT &&
       var->a_name == slang_atom_pool_atom(C->atoms, "gl_FragCoord")) {
      /* set the program's PixelCenterInteger, OriginUpperLeft fields */
      struct gl_fragment_program *fragProg =
         (struct gl_fragment_program *) O->program;

      if (var->type.layout & SLANG_LAYOUT_UPPER_LEFT_BIT) {
         fragProg->OriginUpperLeft = GL_TRUE;
      }
      if (var->type.layout & SLANG_LAYOUT_PIXEL_CENTER_INTEGER_BIT) {
         fragProg->PixelCenterInteger = GL_TRUE;
      }
   }

   return 1;
}

/**
 * Parse a list of variable declarations.  Each variable may have an
 * initializer.
 */
static int
parse_init_declarator_list(slang_parse_ctx * C, slang_output_ctx * O)
{
   slang_fully_specified_type type;

   /* parse the fully specified type, common to all declarators */
   if (!slang_fully_specified_type_construct(&type))
      RETURN0;
   if (!parse_fully_specified_type(C, O, &type)) {
      slang_fully_specified_type_destruct(&type);
      RETURN0;
   }

   /* parse declarators, pass-in the parsed type */
   do {
      if (!parse_init_declarator(C, O, &type)) {
         slang_fully_specified_type_destruct(&type);
         RETURN0;
      }
   }
   while (*C->I++ == DECLARATOR_NEXT);

   slang_fully_specified_type_destruct(&type);
   return 1;
}


/**
 * Parse a function definition or declaration.
 * \param C  parsing context
 * \param O  output context
 * \param definition if non-zero expect a definition, else a declaration
 * \param parsed_func_ret  returns the parsed function
 * \return GL_TRUE if success, GL_FALSE if failure
 */
static GLboolean
parse_function(slang_parse_ctx * C, slang_output_ctx * O, int definition,
               slang_function ** parsed_func_ret)
{
   slang_function parsed_func, *found_func;

   /* parse function definition/declaration */
   if (!slang_function_construct(&parsed_func))
      return GL_FALSE;
   if (definition) {
      if (!parse_function_definition(C, O, &parsed_func)) {
         slang_function_destruct(&parsed_func);
         return GL_FALSE;
      }
   }
   else {
      if (!parse_function_prototype(C, O, &parsed_func)) {
         slang_function_destruct(&parsed_func);
         return GL_FALSE;
      }
   }

   /* find a function with a prototype matching the parsed one - only
    * the current scope is being searched to allow built-in function
    * overriding
    */
   found_func = slang_function_scope_find(O->funs, &parsed_func, 0);
   if (found_func == NULL) {
      /* New function, add it to the function list */
      O->funs->functions =
         (slang_function *) _slang_realloc(O->funs->functions,
                                           O->funs->num_functions
                                           * sizeof(slang_function),
                                           (O->funs->num_functions + 1)
                                           * sizeof(slang_function));
      if (O->funs->functions == NULL) {
         /* Make sure that there are no functions marked, as the
          * allocation is currently NULL, in order to avoid
          * a potental segfault as we clean up later.
          */
         O->funs->num_functions = 0;

         slang_info_log_memory(C->L);
         slang_function_destruct(&parsed_func);
         return GL_FALSE;
      }
      O->funs->functions[O->funs->num_functions] = parsed_func;
      O->funs->num_functions++;

      /* return the newly parsed function */
      *parsed_func_ret = &O->funs->functions[O->funs->num_functions - 1];
   }
   else {
      /* previously defined or declared */
      /* TODO: check function return type qualifiers and specifiers */
      if (definition) {
         if (found_func->body != NULL) {
            slang_info_log_error(C->L, "%s: function already has a body.",
                                 slang_atom_pool_id(C->atoms,
                                                    parsed_func.header.
                                                    a_name));
            slang_function_destruct(&parsed_func);
            return GL_FALSE;
         }

         /* destroy the existing function declaration and replace it
          * with the new one
          */
         slang_function_destruct(found_func);
         *found_func = parsed_func;
      }
      else {
         /* another declaration of the same function prototype - ignore it */
         slang_function_destruct(&parsed_func);
      }

      /* return the found function */
      *parsed_func_ret = found_func;
   }

   return GL_TRUE;
}

/* declaration */
#define DECLARATION_FUNCTION_PROTOTYPE 1
#define DECLARATION_INIT_DECLARATOR_LIST 2

static int
parse_declaration(slang_parse_ctx * C, slang_output_ctx * O)
{
   switch (*C->I++) {
   case DECLARATION_INIT_DECLARATOR_LIST:
      if (!parse_init_declarator_list(C, O))
         RETURN0;
      break;
   case DECLARATION_FUNCTION_PROTOTYPE:
      {
         slang_function *dummy_func;

         if (!parse_function(C, O, 0, &dummy_func))
            RETURN0;
      }
      break;
   default:
      RETURN0;
   }
   return 1;
}

static int
parse_default_precision(slang_parse_ctx * C, slang_output_ctx * O)
{
   int precision, type;

   if (!O->allow_precision) {
      slang_info_log_error(C->L, "syntax error at \"precision\"");
      RETURN0;
   }

   precision = *C->I++;
   switch (precision) {
   case PRECISION_LOW:
   case PRECISION_MEDIUM:
   case PRECISION_HIGH:
      /* OK */
      break;
   default:
      _mesa_problem(NULL, "unexpected precision %d at %s:%d\n",
                    precision, __FILE__, __LINE__);
      RETURN0;
   }

   type = *C->I++;
   switch (type) {
   case TYPE_SPECIFIER_FLOAT:
   case TYPE_SPECIFIER_INT:
   case TYPE_SPECIFIER_SAMPLER1D:
   case TYPE_SPECIFIER_SAMPLER2D:
   case TYPE_SPECIFIER_SAMPLER3D:
   case TYPE_SPECIFIER_SAMPLERCUBE:
   case TYPE_SPECIFIER_SAMPLER1DSHADOW:
   case TYPE_SPECIFIER_SAMPLER2DSHADOW:
   case TYPE_SPECIFIER_SAMPLER2DRECT:
   case TYPE_SPECIFIER_SAMPLER2DRECTSHADOW:
   case TYPE_SPECIFIER_SAMPLER_1D_ARRAY:
   case TYPE_SPECIFIER_SAMPLER_2D_ARRAY:
   case TYPE_SPECIFIER_SAMPLER_1D_ARRAY_SHADOW:
   case TYPE_SPECIFIER_SAMPLER_2D_ARRAY_SHADOW:
      /* OK */
      break;
   default:
      _mesa_problem(NULL, "unexpected type %d at %s:%d\n",
                    type, __FILE__, __LINE__);
      RETURN0;
   }

   assert(type < TYPE_SPECIFIER_COUNT);
   O->default_precision[type] = precision;

   return 1;
}


/**
 * Initialize the default precision for all types.
 * XXX this info isn't used yet.
 */
static void
init_default_precision(slang_output_ctx *O, slang_unit_type type)
{
   GLuint i;
   for (i = 0; i < TYPE_SPECIFIER_COUNT; i++) {
#if FEATURE_es2_glsl
      O->default_precision[i] = PRECISION_LOW;
#else
      O->default_precision[i] = PRECISION_HIGH;
#endif
   }

   if (type == SLANG_UNIT_VERTEX_SHADER) {
      O->default_precision[TYPE_SPECIFIER_FLOAT] = PRECISION_HIGH;
      O->default_precision[TYPE_SPECIFIER_INT] = PRECISION_HIGH;
   }
   else {
      O->default_precision[TYPE_SPECIFIER_INT] = PRECISION_MEDIUM;
   }
}


static int
parse_invariant(slang_parse_ctx * C, slang_output_ctx * O)
{
   if (O->allow_invariant) {
      slang_atom *a = parse_identifier(C);
      /* XXX not doing anything with this var yet */
      /*printf("ID: %s\n", (char*) a);*/
      return a ? 1 : 0;
   }
   else {
      slang_info_log_error(C->L, "syntax error at \"invariant\"");
      RETURN0;
   }
}
      

/* external declaration or default precision specifier */
#define EXTERNAL_NULL 0
#define EXTERNAL_FUNCTION_DEFINITION 1
#define EXTERNAL_DECLARATION 2
#define DEFAULT_PRECISION 3
#define INVARIANT_STMT 4


static GLboolean
parse_code_unit(slang_parse_ctx * C, slang_code_unit * unit,
                struct gl_shader *shader)
{
   GET_CURRENT_CONTEXT(ctx);
   slang_output_ctx o;
   GLboolean success;
   GLuint maxRegs;
   slang_function *mainFunc = NULL;

   if (unit->type == SLANG_UNIT_FRAGMENT_BUILTIN ||
       unit->type == SLANG_UNIT_FRAGMENT_SHADER) {
      maxRegs = ctx->Const.FragmentProgram.MaxTemps;
   }
   else {
      assert(unit->type == SLANG_UNIT_VERTEX_BUILTIN ||
             unit->type == SLANG_UNIT_VERTEX_SHADER);
      maxRegs = ctx->Const.VertexProgram.MaxTemps;
   }

   /* setup output context */
   o.funs = &unit->funs;
   o.structs = &unit->structs;
   o.vars = &unit->vars;
   o.program = shader ? shader->Program : NULL;
   o.pragmas = shader ? &shader->Pragmas : NULL;
   o.vartable = _slang_new_var_table(maxRegs);
   _slang_push_var_table(o.vartable);

   /* allow 'invariant' keyword? */
#if FEATURE_es2_glsl
   o.allow_invariant = GL_TRUE;
#else
   o.allow_invariant = (C->version >= 120) ? GL_TRUE : GL_FALSE;
#endif

   /* allow 'centroid' keyword? */
   o.allow_centroid = (C->version >= 120) ? GL_TRUE : GL_FALSE;

   /* allow 'lowp/mediump/highp' keywords? */
#if FEATURE_es2_glsl
   o.allow_precision = GL_TRUE;
#else
   o.allow_precision = (C->version >= 120) ? GL_TRUE : GL_FALSE;
#endif
   init_default_precision(&o, unit->type);

   /* allow 'float[]' keyword? */
   o.allow_array_types = (C->version >= 120) ? GL_TRUE : GL_FALSE;

   /* parse individual functions and declarations */
   while (*C->I != EXTERNAL_NULL) {
      switch (*C->I++) {
      case EXTERNAL_FUNCTION_DEFINITION:
         {
            slang_function *func;
            success = parse_function(C, &o, 1, &func);
            if (success && strcmp((char *) func->header.a_name, "main") == 0) {
               /* found main() */
               mainFunc = func;
            }
         }
         break;
      case EXTERNAL_DECLARATION:
         success = parse_declaration(C, &o);
         break;
      case DEFAULT_PRECISION:
         success = parse_default_precision(C, &o);
         break;
      case INVARIANT_STMT:
         success = parse_invariant(C, &o);
         break;
      default:
         success = GL_FALSE;
      }

      if (!success) {
         /* xxx free codegen */
         _slang_pop_var_table(o.vartable);
         return GL_FALSE;
      }
   }
   C->I++;

   if (mainFunc) {
      /* assemble (generate code) for main() */
      slang_assemble_ctx A;
      memset(&A, 0, sizeof(slang_assemble_ctx));
      A.atoms = C->atoms;
      A.space.funcs = o.funs;
      A.space.structs = o.structs;
      A.space.vars = o.vars;
      A.program = o.program;
      A.pragmas = &shader->Pragmas;
      A.vartable = o.vartable;
      A.EmitContReturn = ctx->Shader.EmitContReturn;
      A.log = C->L;
      A.allow_uniform_initializers = C->version > 110;

      /* main() takes no parameters */
      if (mainFunc->param_count > 0) {
         slang_info_log_error(A.log, "main() takes no arguments");
         return GL_FALSE;
      }

      _slang_codegen_function(&A, mainFunc);

      shader->Main = GL_TRUE; /* this shader defines main() */

      shader->UnresolvedRefs = A.UnresolvedRefs;
   }

   _slang_pop_var_table(o.vartable);
   _slang_delete_var_table(o.vartable);

   return GL_TRUE;
}

static GLboolean
compile_binary(const unsigned char * prod, slang_code_unit * unit,
               GLuint version,
               slang_unit_type type, slang_info_log * infolog,
               slang_code_unit * builtin, slang_code_unit * downlink,
               struct gl_shader *shader)
{
   slang_parse_ctx C;

   unit->type = type;

   /* setup parse context */
   C.I = prod;
   C.L = infolog;
   C.parsing_builtin = (builtin == NULL);
   C.global_scope = GL_TRUE;
   C.atoms = &unit->object->atompool;
   C.type = type;
   C.version = version;

   if (!check_revision(&C))
      return GL_FALSE;

   if (downlink != NULL) {
      unit->vars.outer_scope = &downlink->vars;
      unit->funs.outer_scope = &downlink->funs;
      unit->structs.outer_scope = &downlink->structs;
   }

   /* parse translation unit */
   return parse_code_unit(&C, unit, shader);
}

static GLboolean
compile_with_grammar(const char *source,
                     slang_code_unit *unit,
                     slang_unit_type type,
                     slang_info_log *infolog,
                     slang_code_unit *builtin,
                     struct gl_shader *shader,
                     struct gl_sl_pragmas *pragmas,
                     unsigned int shader_type,
                     unsigned int parsing_builtin)
{
   struct sl_pp_purify_options options;
   struct sl_pp_context *context;
   unsigned char *prod;
   GLuint size;
   unsigned int version;
   unsigned int maxVersion;
   int result;
   char errmsg[200] = "";

   assert(shader_type == 1 || shader_type == 2);

   memset(&options, 0, sizeof(options));

   context = sl_pp_context_create(source, &options);
   if (!context) {
      slang_info_log_error(infolog, "out of memory");
      return GL_FALSE;
   }

   if (sl_pp_version(context, &version)) {
      slang_info_log_error(infolog, "%s", sl_pp_context_error_message(context));
      sl_pp_context_destroy(context);
      return GL_FALSE;
   }

   if (sl_pp_context_add_extension(context, "GL_ARB_draw_buffers") ||
       sl_pp_context_add_extension(context, "GL_ARB_texture_rectangle")) {
      slang_info_log_error(infolog, "%s", sl_pp_context_error_message(context));
      sl_pp_context_destroy(context);
      return GL_FALSE;
   }

   if (type == SLANG_UNIT_FRAGMENT_SHADER) {
      sl_pp_context_add_extension(context, "GL_ARB_fragment_coord_conventions");
   }


#if FEATURE_es2_glsl
   if (sl_pp_context_add_predefined(context, "GL_ES", "1") ||
       sl_pp_context_add_predefined(context, "GL_FRAGMENT_PRECISION_HIGH", "1")) {
      slang_info_log_error(infolog, "%s", sl_pp_context_error_message(context));
      sl_pp_context_destroy(context);
      return GL_FALSE;
   }
#endif

#if FEATURE_ARB_shading_language_120
   maxVersion = 120;
#elif FEATURE_es2_glsl
   maxVersion = 100;
#else
   maxVersion = 110;
#endif

   if (version > maxVersion ||
       (version != 100 && version != 110 && version != 120)) {
      slang_info_log_error(infolog,
                           "language version %.2f is not supported.",
                           version * 0.01);
      sl_pp_context_destroy(context);
      return GL_FALSE;
   }

   /* Finally check the syntax and generate its binary representation. */
   result = sl_cl_compile(context,
                          shader_type,
                          parsing_builtin,
                          &prod,
                          &size,
                          errmsg,
                          sizeof(errmsg));

   sl_pp_context_destroy(context);

   if (result) {
      /*GLint pos;*/

      slang_info_log_error(infolog, errmsg);
      /* syntax error (possibly in library code) */
#if 0
      {
         int line, col;
         char *s;
         s = (char *) _mesa_find_line_column((const GLubyte *) source,
                                             (const GLubyte *) source + pos,
                                             &line, &col);
         printf("Error on line %d, col %d: %s\n", line, col, s);
      }
#endif
      return GL_FALSE;
   }

   /* Syntax is okay - translate it to internal representation. */
   if (!compile_binary(prod, unit, version, type, infolog, builtin,
                       &builtin[SLANG_BUILTIN_TOTAL - 1],
                       shader)) {
      free(prod);
      return GL_FALSE;
   }
   free(prod);
   return GL_TRUE;
}

static const unsigned char slang_core_gc[] = {
#include "library/slang_core_gc.h"
};

static const unsigned char slang_120_core_gc[] = {
#include "library/slang_120_core_gc.h"
};

static const unsigned char slang_120_fragment_gc[] = {
#include "library/slang_builtin_120_fragment_gc.h"
};

static const unsigned char slang_common_builtin_gc[] = {
#include "library/slang_common_builtin_gc.h"
};

static const unsigned char slang_fragment_builtin_gc[] = {
#include "library/slang_fragment_builtin_gc.h"
};

static const unsigned char slang_vertex_builtin_gc[] = {
#include "library/slang_vertex_builtin_gc.h"
};

static GLboolean
compile_object(const char *source,
               slang_code_object *object,
               slang_unit_type type,
               slang_info_log *infolog,
               struct gl_shader *shader,
               struct gl_sl_pragmas *pragmas)
{
   slang_code_unit *builtins = NULL;
   GLuint base_version = 110;
   unsigned int shader_type;
   unsigned int parsing_builtin;

   /* set shader type - the syntax is slightly different for different shaders */
   if (type == SLANG_UNIT_FRAGMENT_SHADER || type == SLANG_UNIT_FRAGMENT_BUILTIN) {
      shader_type = 1;
   } else {
      shader_type = 2;
   }

   /* enable language extensions */
   parsing_builtin = 1;

   /* if parsing user-specified shader, load built-in library */
   if (type == SLANG_UNIT_FRAGMENT_SHADER || type == SLANG_UNIT_VERTEX_SHADER) {
      /* compile core functionality first */
      if (!compile_binary(slang_core_gc,
                          &object->builtin[SLANG_BUILTIN_CORE],
                          base_version,
                          SLANG_UNIT_FRAGMENT_BUILTIN, infolog,
                          NULL, NULL, NULL))
         return GL_FALSE;

#if FEATURE_ARB_shading_language_120
      if (!compile_binary(slang_120_core_gc,
                          &object->builtin[SLANG_BUILTIN_120_CORE],
                          120,
                          SLANG_UNIT_FRAGMENT_BUILTIN, infolog,
                          NULL, &object->builtin[SLANG_BUILTIN_CORE], NULL))
         return GL_FALSE;
#endif

      /* compile common functions and variables, link to core */
      if (!compile_binary(slang_common_builtin_gc,
                          &object->builtin[SLANG_BUILTIN_COMMON],
#if FEATURE_ARB_shading_language_120
                          120,
#else
                          base_version,
#endif
                          SLANG_UNIT_FRAGMENT_BUILTIN, infolog, NULL,
#if FEATURE_ARB_shading_language_120
                          &object->builtin[SLANG_BUILTIN_120_CORE],
#else
                          &object->builtin[SLANG_BUILTIN_CORE],
#endif
                          NULL))
         return GL_FALSE;

      /* compile target-specific functions and variables, link to common */
      if (type == SLANG_UNIT_FRAGMENT_SHADER) {
         if (!compile_binary(slang_fragment_builtin_gc,
                             &object->builtin[SLANG_BUILTIN_TARGET],
                             base_version,
                             SLANG_UNIT_FRAGMENT_BUILTIN, infolog, NULL,
                             &object->builtin[SLANG_BUILTIN_COMMON], NULL))
            return GL_FALSE;
#if FEATURE_ARB_shading_language_120
         if (!compile_binary(slang_120_fragment_gc,
                             &object->builtin[SLANG_BUILTIN_TARGET],
                             120,
                             SLANG_UNIT_FRAGMENT_BUILTIN, infolog, NULL,
                             &object->builtin[SLANG_BUILTIN_COMMON], NULL))
            return GL_FALSE;
#endif
      }
      else if (type == SLANG_UNIT_VERTEX_SHADER) {
         if (!compile_binary(slang_vertex_builtin_gc,
                             &object->builtin[SLANG_BUILTIN_TARGET],
                             base_version,
                             SLANG_UNIT_VERTEX_BUILTIN, infolog, NULL,
                             &object->builtin[SLANG_BUILTIN_COMMON], NULL))
            return GL_FALSE;
      }

      /* disable language extensions */
      parsing_builtin = 0;

      builtins = object->builtin;
   }

   /* compile the actual shader - pass-in built-in library for external shader */
   return compile_with_grammar(source,
                               &object->unit,
                               type,
                               infolog,
                               builtins,
                               shader,
                               pragmas,
                               shader_type,
                               parsing_builtin);
}


GLboolean
_slang_compile(GLcontext *ctx, struct gl_shader *shader)
{
   GLboolean success;
   slang_info_log info_log;
   slang_code_object obj;
   slang_unit_type type;
   GLenum progTarget;

   if (shader->Type == GL_VERTEX_SHADER) {
      type = SLANG_UNIT_VERTEX_SHADER;
   }
   else {
      assert(shader->Type == GL_FRAGMENT_SHADER);
      type = SLANG_UNIT_FRAGMENT_SHADER;
   }

   if (!shader->Source)
      return GL_FALSE;

   ctx->Shader.MemPool = _slang_new_mempool(1024*1024);

   shader->Main = GL_FALSE;

   /* free the shader's old instructions, etc */
   _mesa_reference_program(ctx, &shader->Program, NULL);

   /* allocate new GPU program, parameter lists, etc. */
   if (shader->Type == GL_VERTEX_SHADER)
      progTarget = GL_VERTEX_PROGRAM_ARB;
   else
      progTarget = GL_FRAGMENT_PROGRAM_ARB;
   shader->Program = ctx->Driver.NewProgram(ctx, progTarget, 1);
   shader->Program->Parameters = _mesa_new_parameter_list();
   shader->Program->Varying = _mesa_new_parameter_list();
   shader->Program->Attributes = _mesa_new_parameter_list();

   slang_info_log_construct(&info_log);
   _slang_code_object_ctr(&obj);

   success = compile_object(shader->Source,
                            &obj,
                            type,
                            &info_log,
                            shader,
                            &shader->Pragmas);

   /* free shader's prev info log */
   if (shader->InfoLog) {
      free(shader->InfoLog);
      shader->InfoLog = NULL;
   }

   if (info_log.text) {
      /* copy info-log string to shader object */
      shader->InfoLog = _mesa_strdup(info_log.text);
   }

   if (info_log.error_flag) {
      success = GL_FALSE;
   }

   slang_info_log_destruct(&info_log);
   _slang_code_object_dtr(&obj);

   _slang_delete_mempool((slang_mempool *) ctx->Shader.MemPool);
   ctx->Shader.MemPool = NULL;

   /* remove any reads of output registers */
#if 0
   printf("Pre-remove output reads:\n");
   _mesa_print_program(shader->Program);
#endif
   _mesa_remove_output_reads(shader->Program, PROGRAM_OUTPUT);
   if (shader->Type == GL_VERTEX_SHADER) {
      /* and remove writes to varying vars in vertex programs */
      _mesa_remove_output_reads(shader->Program, PROGRAM_VARYING);
   }
#if 0
   printf("Post-remove output reads:\n");
   _mesa_print_program(shader->Program);
#endif

   shader->CompileStatus = success;

   if (success) {
      if (shader->Pragmas.Optimize &&
          (ctx->Shader.Flags & GLSL_NO_OPT) == 0) {
         _mesa_optimize_program(ctx, shader->Program);
      }
      if ((ctx->Shader.Flags & GLSL_NOP_VERT) &&
          shader->Program->Target == GL_VERTEX_PROGRAM_ARB) {
         _mesa_nop_vertex_program(ctx,
                                  (struct gl_vertex_program *) shader->Program);
      }
      if ((ctx->Shader.Flags & GLSL_NOP_FRAG) &&
          shader->Program->Target == GL_FRAGMENT_PROGRAM_ARB) {
         _mesa_nop_fragment_program(ctx,
                                (struct gl_fragment_program *) shader->Program);
      }
   }

   if (ctx->Shader.Flags & GLSL_LOG) {
      _mesa_write_shader_to_file(shader);
   }

   return success;
}

@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d35 1
d38 2
a39 1
#include "shader/grammar/grammar_mesa.h"
a41 1
#include "slang_preprocess.h"
a42 1
#include "slang_emit.h"
a47 2
#include "slang_print.h"

d58 1
a58 1
#define TYPE_SPECIFIER_COUNT 32
d68 1
a68 1
   if (_mesa_strncmp((char *) name, "gl_", 3) == 0) {
d128 1
a128 1
   const byte *I;
d170 1
a170 1
   C->I += _mesa_strlen(*id) + 1;
d179 1
a179 1
   C->I += _mesa_strlen(id) + 1;
d184 72
d259 19
a277 10
   *number = 0;
   while (*C->I != '\0') {
      int digit;
      if (*C->I >= '0' && *C->I <= '9')
         digit = (int) (*C->I - '0');
      else if (*C->I >= 'A' && *C->I <= 'Z')
         digit = (int) (*C->I - 'A') + 10;
      else
         digit = (int) (*C->I - 'a') + 10;
      *number = *number * radix + digit;
a279 1
   C->I++;
d288 20
a307 16
   char *integral = NULL;
   char *fractional = NULL;
   char *exponent = NULL;
   char *whole = NULL;

   parse_identifier_str(C, &integral);
   parse_identifier_str(C, &fractional);
   parse_identifier_str(C, &exponent);

   whole = (char *) _slang_alloc((_mesa_strlen(integral) +
                                  _mesa_strlen(fractional) +
                                  _mesa_strlen(exponent) + 3) * sizeof(char));
   if (whole == NULL) {
      slang_info_log_memory(C->L);
      RETURN0;
   }
d309 5
a313 5
   slang_string_copy(whole, integral);
   slang_string_concat(whole, ".");
   slang_string_concat(whole, fractional);
   slang_string_concat(whole, "E");
   slang_string_concat(whole, exponent);
d315 1
a315 1
   *number = (float) (_mesa_strtod(whole, (char **) NULL));
d317 2
a318 1
   _slang_free(whole);
d639 32
d745 5
a749 1
#define TYPE_SPECIFIER_COUNT 32
d755 2
a756 1
   switch (*C->I++) {
d824 1
a824 1
      spec->type = SLANG_SPEC_SAMPLER1D;
d827 1
a827 1
      spec->type = SLANG_SPEC_SAMPLER2D;
d830 1
a830 1
      spec->type = SLANG_SPEC_SAMPLER3D;
d833 1
a833 1
      spec->type = SLANG_SPEC_SAMPLERCUBE;
d836 1
a836 1
      spec->type = SLANG_SPEC_SAMPLER2DRECT;
d839 1
a839 1
      spec->type = SLANG_SPEC_SAMPLER1DSHADOW;
d842 1
a842 1
      spec->type = SLANG_SPEC_SAMPLER2DSHADOW;
d845 13
a857 1
      spec->type = SLANG_SPEC_SAMPLER2DRECTSHADOW;
d959 3
d964 1
a964 1
  
d2084 24
d2114 2
a2115 1
   slang_variable *var;
d2125 10
a2134 2
   if (_slang_variable_locate(O->vars, a_name, GL_FALSE)) {
      slang_info_log_error(C->L,
d2137 2
a2138 1
      RETURN0;
a2140 2
   /* make room for the new variable and initialize it */
   var = slang_variable_scope_grow(O->vars);
d2142 18
a2159 2
      slang_info_log_memory(C->L);
      RETURN0;
a2161 10
   /* copy the declarator type qualifier/etc info, parse the identifier */
   var->type.qualifier = type->qualifier;
   var->type.centroid = type->centroid;
   var->type.precision = type->precision;
   var->type.variant = type->variant;
   var->type.array_len = type->array_len;
   var->a_name = a_name;
   if (var->a_name == SLANG_ATOM_NULL)
      RETURN0;

d2231 2
d2242 1
d2251 2
a2252 1

d2261 15
d2354 6
d2462 4
d2588 1
a2588 2
            if (success &&
                _mesa_strcmp((char *) func->header.a_name, "main") == 0) {
d2618 1
a2618 1

d2626 1
d2628 1
d2639 2
d2650 1
a2650 1
compile_binary(const byte * prod, slang_code_unit * unit,
d2683 5
a2687 3
compile_with_grammar(grammar id, const char *source, slang_code_unit * unit,
                     slang_unit_type type, slang_info_log * infolog,
                     slang_code_unit * builtin,
d2689 49
a2737 7
                     const struct gl_extensions *extensions,
                     struct gl_sl_pragmas *pragmas)
{
   byte *prod;
   GLuint size, start, version;
   slang_string preprocessed;
   GLuint maxVersion;
d2747 2
a2748 5
   /* First retrieve the version number. */
   if (!_slang_preprocess_version(source, &version, &start, infolog))
      return GL_FALSE;

   if (version > maxVersion) {
d2752 1
d2756 13
a2768 8
   /* Now preprocess the source string. */
   slang_string_init(&preprocessed);
   if (!_slang_preprocess_directives(&preprocessed, &source[start],
                                     infolog, extensions, pragmas)) {
      slang_string_free(&preprocessed);
      slang_info_log_error(infolog, "failed to preprocess the source.");
      return GL_FALSE;
   }
d2770 1
a2770 10
   /* Finally check the syntax and generate its binary representation. */
   if (!grammar_fast_check(id,
                           (const byte *) (slang_string_cstr(&preprocessed)),
                           &prod, &size, 65536)) {
      char buf[1024];
      GLint pos;

      slang_string_free(&preprocessed);
      grammar_get_last_error((byte *) (buf), sizeof(buf), &pos);
      slang_info_log_error(infolog, buf);
a2783 1
   slang_string_free(&preprocessed);
d2789 1
a2789 1
      grammar_alloc_free(prod);
d2792 1
a2792 1
   grammar_alloc_free(prod);
d2796 1
a2796 5
LONGSTRING static const char *slang_shader_syn =
#include "library/slang_shader_syn.h"
   ;

static const byte slang_core_gc[] = {
d2800 1
a2800 1
static const byte slang_120_core_gc[] = {
d2804 1
a2804 1
static const byte slang_120_fragment_gc[] = {
d2808 1
a2808 1
static const byte slang_common_builtin_gc[] = {
d2812 1
a2812 1
static const byte slang_fragment_builtin_gc[] = {
d2816 1
a2816 1
static const byte slang_vertex_builtin_gc[] = {
d2821 4
a2824 2
compile_object(grammar * id, const char *source, slang_code_object * object,
               slang_unit_type type, slang_info_log * infolog,
a2825 1
               const struct gl_extensions *extensions,
d2830 2
d2833 5
a2837 9
   /* load GLSL grammar */
   *id = grammar_load_from_text((const byte *) (slang_shader_syn));
   if (*id == 0) {
      byte buf[1024];
      int pos;

      grammar_get_last_error(buf, 1024, &pos);
      slang_info_log_error(infolog, (const char *) (buf));
      return GL_FALSE;
a2839 7
   /* set shader type - the syntax is slightly different for different shaders */
   if (type == SLANG_UNIT_FRAGMENT_SHADER
       || type == SLANG_UNIT_FRAGMENT_BUILTIN)
      grammar_set_reg8(*id, (const byte *) "shader_type", 1);
   else
      grammar_set_reg8(*id, (const byte *) "shader_type", 2);

d2841 1
a2841 1
   grammar_set_reg8(*id, (const byte *) "parsing_builtin", 1);
d2906 2
a2907 5
#if NEW_SLANG /* allow-built-ins */
      grammar_set_reg8(*id, (const byte *) "parsing_builtin", 1);
#else
      grammar_set_reg8(*id, (const byte *) "parsing_builtin", 0);
#endif
d2912 9
a2920 2
   return compile_with_grammar(*id, source, &object->unit, type, infolog,
                               builtins, shader, extensions, pragmas);
a2923 31
static GLboolean
compile_shader(GLcontext *ctx, slang_code_object * object,
               slang_unit_type type, slang_info_log * infolog,
               struct gl_shader *shader)
{
   GLboolean success;
   grammar id = 0;

#if 0 /* for debug */
   _mesa_printf("********* COMPILE SHADER ***********\n");
   _mesa_printf("%s\n", shader->Source);
   _mesa_printf("************************************\n");
#endif

   assert(shader->Program);

   _slang_code_object_dtr(object);
   _slang_code_object_ctr(object);

   success = compile_object(&id, shader->Source, object, type, infolog, shader,
                            &ctx->Extensions, &shader->Pragmas);
   if (id != 0)
      grammar_destroy(id);
   if (!success)
      return GL_FALSE;

   return GL_TRUE;
}



d2931 1
d2948 12
a2959 11
   if (!shader->Program) {
      GLenum progTarget;
      if (shader->Type == GL_VERTEX_SHADER)
         progTarget = GL_VERTEX_PROGRAM_ARB;
      else
         progTarget = GL_FRAGMENT_PROGRAM_ARB;
      shader->Program = ctx->Driver.NewProgram(ctx, progTarget, 1);
      shader->Program->Parameters = _mesa_new_parameter_list();
      shader->Program->Varying = _mesa_new_parameter_list();
      shader->Program->Attributes = _mesa_new_parameter_list();
   }
d2964 6
a2969 1
   success = compile_shader(ctx, &obj, type, &info_log, shader);
d2973 1
a2973 1
      _mesa_free(shader->InfoLog);
d3009 20
a3028 3
#if 0
   _mesa_write_shader_to_file(shader);
#endif
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a2 1
 * Version:  6.5.2
d5 1
a76 12
/**
 * Allocate storage for a variable of 'size' bytes from given pool.
 * Return the allocated address for the variable.
 */
static GLuint
slang_var_pool_alloc(slang_var_pool * pool, unsigned int size)
{
   const GLuint addr = pool->next_addr;
   pool->next_addr += size;
   return addr;
}

a110 1
   self->varpool.next_addr = 0;
a145 1
   slang_var_pool *global_pool;
d147 1
d150 4
d158 10
d224 1
a224 1
      return 0;
d241 1
a241 1
#define REVISION 4
d248 1
a248 1
      return 0;
d260 4
d290 1
a290 1
      slang_variable *var = _slang_locate_variable(array_size.locals, array_size.a_id, GL_TRUE);
d335 14
d353 2
a354 2
   /* sized array - mark it as array, copy the specifier to the array element and
    * parse the expression */
d374 2
a375 1
                       const slang_type_specifier * sp)
d383 9
a391 2
      if (!slang_type_specifier_copy(&var->type.specifier, sp))
         return GL_FALSE;
d394 2
d413 1
d417 3
a419 1
      return 0;
d426 1
a426 1
         return 0;
d429 1
a429 1
      if (_slang_locate_variable(st->fields, a_name, GL_FALSE)) {
d431 1
a431 1
         return 0;
d434 2
a435 2
      if (!parse_struct_field_var(C, &o, var, a_name, sp))
         return 0;
d451 1
a451 1
      return 0;
d457 1
a457 1
      return 0;
d464 1
a464 1
      return 0;
d470 1
a470 1
      return 0;
d482 1
a482 1
         return 0;
d500 1
a500 1
         return 0;
d504 1
a504 1
         return 0;
d507 1
a507 1
         return 0;
d514 42
d568 2
a569 1
   switch (*C->I++) {
d592 1
a592 1
      return 0;
d730 1
a730 1
         return 0;
d740 1
a740 1
            return 0;
d746 1
a746 1
            return 0;
d752 1
a752 1
            return 0;
d757 1
a757 1
            return 0;
d760 1
a760 1
            return 0;
d764 27
a790 1
      return 0;
d801 23
d827 5
a831 1
   GLuint precision;
d834 5
a838 2
      return 0;
   precision = *C->I++;
d840 4
a843 1
      return 0;
d845 32
a876 4
   switch (precision) {
   case PRECISION_DEFAULT:
      assert(type->specifier.type < TYPE_SPECIFIER_COUNT);
      if (type->specifier.type < TYPE_SPECIFIER_COUNT)
d878 13
a890 12
      break;
   case PRECISION_LOW:
      type->precision = SLANG_PREC_LOW;
      break;
   case PRECISION_MEDIUM:
      type->precision = SLANG_PREC_MEDIUM;
      break;
   case PRECISION_HIGH:
      type->precision = SLANG_PREC_HIGH;
      break;
   default:
      return 0;
d893 3
a895 4
#if !FEATURE_es2_glsl
   if (precision != PRECISION_DEFAULT) {
      slang_info_log_error(C->L, "precision qualifiers not allowed");
      return 0;
a896 1
#endif
d964 2
d999 2
d1002 3
a1004 1
   switch (*C->I++) {
d1009 2
a1010 2
         if (!parse_child_operation(C, O, oper, 1))
            return 0;
d1021 2
a1022 2
            if (!parse_child_operation(C, &o, oper, 1))
               return 0;
d1038 1
a1038 1
            return 0;
d1047 1
a1047 1
               return 0;
d1051 1
d1054 5
a1058 1
               o->a_id = O->vars->variables[i]->a_name;
d1063 1
a1063 1
                  return 0;
d1076 1
a1076 1
         return 0;
d1078 2
a1079 2
         if (!parse_child_operation(C, O, oper, 0))
            return 0;
d1094 2
a1095 2
      if (!parse_child_operation(C, O, oper, 0))
         return 0;
d1099 2
a1100 2
      if (!parse_child_operation(C, O, oper, 0))
         return 0;
d1104 6
a1109 6
      if (!parse_child_operation(C, O, oper, 0))
         return 0;
      if (!parse_child_operation(C, O, oper, 1))
         return 0;
      if (!parse_child_operation(C, O, oper, 1))
         return 0;
d1117 4
a1120 4
         if (!parse_child_operation(C, &o, oper, 1))
            return 0;
         if (!parse_child_operation(C, &o, oper, 1))
            return 0;
d1125 4
a1128 4
      if (!parse_child_operation(C, O, oper, 1))
         return 0;
      if (!parse_child_operation(C, O, oper, 0))
         return 0;
d1136 18
a1153 8
         if (!parse_child_operation(C, &o, oper, 1))
            return 0;
         if (!parse_child_operation(C, &o, oper, 1))
            return 0;
         if (!parse_child_operation(C, &o, oper, 0))
            return 0;
         if (!parse_child_operation(C, &o, oper, 1))
            return 0;
d1157 2
a1158 1
      return 0;
d1173 1
a1173 1
      return 0;
d1191 1
a1191 1
      return 0;
d1205 3
d1227 1
a1227 1
         return 0;
d1232 1
a1232 1
         return 0;
d1244 1
a1244 1
            return 0;
d1254 1
a1254 1
            return 0;
d1264 1
a1264 1
            return 0;
d1274 1
a1274 1
            return 0;
d1279 1
a1279 1
            return 0;
d1284 1
a1284 1
            return 0;
d1289 1
a1289 1
            return 0;
d1294 1
a1294 1
            return 0;
d1299 1
a1299 1
            return 0;
d1304 1
a1304 1
            return 0;
d1315 1
a1315 1
            return 0;
d1320 1
a1320 1
            return 0;
d1325 1
a1325 1
            return 0;
d1330 1
a1330 1
            return 0;
d1338 1
a1338 1
            return 0;
d1343 1
a1343 1
            return 0;
d1348 1
a1348 1
            return 0;
d1353 1
a1353 1
            return 0;
d1358 1
a1358 1
            return 0;
d1363 1
a1363 1
            return 0;
d1370 1
a1370 1
            return 0;
d1375 1
a1375 1
            return 0;
d1380 1
a1380 1
            return 0;
d1385 1
a1385 1
            return 0;
d1391 1
a1391 1
            return 0;
d1396 1
a1396 1
            return 0;
d1401 1
a1401 1
            return 0;
d1406 1
a1406 1
            return 0;
d1411 1
a1411 1
            return 0;
d1417 1
a1417 1
            return 0;
d1419 6
a1424 2
      case OP_CALL:
         op->type = SLANG_OPER_CALL;
d1427 5
a1431 1
            return 0;
d1433 2
a1434 2
            if (!parse_child_operation(C, O, op, 0))
               return 0;
d1436 2
a1437 1

d1445 73
a1517 1
               return 0;
d1525 1
a1525 1
            return 0;
d1527 1
a1527 1
            return 0;
d1532 1
a1532 1
            return 0;
d1537 1
a1537 1
            return 0;
d1540 1
a1540 1
         return 0;
d1565 2
d1571 4
a1574 2
      return 0;
   switch (*C->I++) {
d1579 1
a1579 1
         return 0;
d1587 1
a1587 1
         return 0;
d1595 1
a1595 1
         return 0;
d1599 1
a1599 1
      return 0;
d1602 5
d1609 3
a1611 1
      return 0;
d1614 19
a1632 1
      return 0;
d1640 4
d1647 1
a1647 1
         return GL_FALSE;
d1651 1
a1651 1
         return GL_FALSE;
d1655 1
a1655 1
         return GL_FALSE;
d1658 1
d1661 2
a1662 2
      return GL_FALSE;

d1754 1
a1754 1
            return 0;
d1760 1
a1760 1
   return 0;
d1768 1
d1771 4
a1774 2
      return 0;
   switch (*C->I++) {
d1779 1
a1779 1
         return 0;
d1784 1
a1784 1
         return 0;
d1791 1
a1791 1
         return 0;
d1798 1
a1798 1
         return 0;
d1801 1
a1801 1
      return 0;
d1807 1
a1807 1
      return 0;
d1815 1
a1815 1
         return 0;
d1818 1
a1818 1
         return 0;
d1852 1
a1852 1
      return 0;
d1858 1
a1858 1
      return 0;
d1864 1
a1864 1
      return 0;
d1873 1
a1873 1
      return 0;
d1965 1
a1965 1
   if (_slang_locate_variable(O->vars, a_name, GL_FALSE)) {
d1969 1
a1969 1
      return 0;
d1976 1
a1976 1
      return 0;
d1979 1
a1979 1
   /* copy the declarator qualifier type, parse the identifier */
d1981 4
d1987 1
a1987 1
      return 0;
d1993 1
a1993 1
         return 0;
d1997 9
a2005 2
      if (!slang_type_specifier_copy(&var->type.specifier, &type->specifier))
         return 0;
d2010 1
a2010 1
         return 0;
d2016 1
a2016 1
         return 0;
d2019 1
a2019 1
         return 0;
d2023 6
a2028 2
         the array element
      */
d2033 5
d2044 1
a2044 1
      return 0;
a2052 1
      var->address = slang_var_pool_alloc(O->global_pool, var->size);
d2063 1
d2068 1
a2068 1
         return 0;
d2081 1
a2081 1
            return 0;
d2098 1
a2098 1
      return 0;
d2101 1
a2101 1
      return 0;
d2108 1
a2108 1
         return 0;
d2186 1
a2186 1
          * with the new one, remember to save the fixup table
a2187 2
         parsed_func.fixups = found_func->fixups;
         slang_fixup_table_init(&found_func->fixups);
d2213 1
a2213 1
         return 0;
d2220 1
a2220 1
            return 0;
d2224 1
a2224 1
      return 0;
a2231 1
#if FEATURE_es2_glsl
d2234 5
d2249 1
a2249 1
      return 0;
d2269 1
a2269 1
      return 0;
a2275 4
#else
   slang_info_log_error(C->L, "syntax error at \"precision\"");
   return 0;
#endif
d2294 1
a2294 1
#if FEATURE_es2_glsl
a2301 1
#endif
d2308 1
a2308 1
   if (C->version >= 120 || FEATURE_es2_glsl) {
d2316 1
a2316 1
      return 0;
a2349 1
   init_default_precision(&o, unit->type);
a2352 1
   o.global_pool = &unit->object->varpool;
d2354 1
d2358 21
d2423 1
d2481 3
a2483 1
                     struct gl_shader *shader)
d2511 2
a2512 1
   if (!_slang_preprocess_directives(&preprocessed, &source[start], infolog)) {
d2585 3
a2587 1
               struct gl_shader *shader)
d2686 1
a2686 1
                               builtins, shader);
d2709 2
a2710 1
   success = compile_object(&id, shader->Source, object, type, infolog, shader);
d2795 6
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d31 8
a38 2
#include "imports.h"
#include "grammar_mesa.h"
d42 7
d51 4
a54 3
 * This is a straightforward implementation of the slang front-end compiler.
 * Lots of error-checking functionality is missing but every well-formed shader source should
 * compile successfully and execute as expected. However, some semantically ill-formed shaders
a57 1
/* slang_var_pool */
d59 9
a67 1
static GLuint slang_var_pool_alloc (slang_var_pool *pool, unsigned int size)
d69 7
a75 1
	GLuint addr;
d77 10
a86 3
	addr = pool->next_addr;
	pool->next_addr += size;
	return addr;
d94 2
a95 1
_slang_code_unit_ctr (slang_code_unit *self, struct slang_code_object_ *object)
d97 3
a99 3
   _slang_variable_scope_ctr (&self->vars);
   _slang_function_scope_ctr (&self->funs);
   _slang_struct_scope_ctr (&self->structs);
d104 1
a104 1
_slang_code_unit_dtr (slang_code_unit *self)
d106 3
a108 3
   slang_variable_scope_destruct (&self->vars);
   slang_function_scope_destruct (&self->funs);
   slang_struct_scope_destruct (&self->structs);
d116 1
a116 1
_slang_code_object_ctr (slang_code_object *self)
d121 2
a122 4
      _slang_code_unit_ctr (&self->builtin[i], self);
   _slang_code_unit_ctr (&self->unit, self);
   _slang_assembly_file_ctr (&self->assembly);
   slang_machine_ctr (&self->machine);
d124 1
a124 5
   slang_atom_pool_construct (&self->atompool);
   slang_export_data_table_ctr (&self->expdata);
   self->expdata.atoms = &self->atompool;
   slang_export_code_table_ctr (&self->expcode);
   self->expcode.atoms = &self->atompool;
d128 1
a128 1
_slang_code_object_dtr (slang_code_object *self)
d133 3
a135 7
      _slang_code_unit_dtr (&self->builtin[i]);
   _slang_code_unit_dtr (&self->unit);
   slang_assembly_file_destruct (&self->assembly);
   slang_machine_dtr (&self->machine);
   slang_atom_pool_destruct (&self->atompool);
   slang_export_data_table_dtr (&self->expdata);
   slang_export_code_table_ctr (&self->expcode);
a137 1
/* slang_info_log */
d139 1
a139 1
static char *out_of_memory = "Error: Out of memory.\n";
d141 1
a141 1
void slang_info_log_construct (slang_info_log *log)
d143 10
a152 3
	log->text = NULL;
	log->dont_free_text = 0;
}
d154 1
a154 1
void slang_info_log_destruct (slang_info_log *log)
d156 10
a165 3
	if (!log->dont_free_text)
		slang_alloc_free (log->text);
}
d167 2
a168 1
static int slang_info_log_message (slang_info_log *log, const char *prefix, const char *msg)
d170 3
a172 1
   GLuint size;
d174 25
a198 8
	if (log->dont_free_text)
		return 0;
   size = slang_string_length (msg) + 2;
   if (prefix != NULL)
      size += slang_string_length (prefix) + 2;
   if (log->text != NULL) {
      GLuint old_len = slang_string_length (log->text);
      log->text = (char *) (slang_alloc_realloc (log->text, old_len + 1, old_len + size));
d200 24
a223 4
   else {
      log->text = (char *) (slang_alloc_malloc (size));
      if (log->text != NULL)
         log->text[0] = '\0';
d225 23
a247 5
	if (log->text == NULL)
		return 0;
   if (prefix != NULL) {
      slang_string_concat (log->text, prefix);
      slang_string_concat (log->text, ": ");
d249 2
a250 3
	slang_string_concat (log->text, msg);
	slang_string_concat (log->text, "\n");
	return 1;
d253 9
a261 1
int slang_info_log_print (slang_info_log *log, const char *msg, ...)
d263 3
a265 2
   va_list va;
   char buf[1024];
d267 6
a272 5
   va_start (va, msg);
   _mesa_vsprintf (buf, msg, va);
   va_end (va);
   return slang_info_log_message (log, NULL, buf);
}
d274 33
a306 4
int slang_info_log_error (slang_info_log *log, const char *msg, ...)
{
	va_list va;
	char buf[1024];
d308 2
a309 7
	va_start (va, msg);
	_mesa_vsprintf (buf, msg, va);
   va_end (va);
	if (slang_info_log_message (log, "Error", buf))
		return 1;
	slang_info_log_memory (log);
	return 0;
d312 3
a314 1
int slang_info_log_warning (slang_info_log *log, const char *msg, ...)
d316 1
a316 2
	va_list va;
	char buf[1024];
d318 10
a327 7
	va_start (va, msg);
	_mesa_vsprintf (buf, msg, va);
   va_end (va);
	if (slang_info_log_message (log, "Warning", buf))
		return 1;
	slang_info_log_memory (log);
	return 0;
d330 3
a332 1
void slang_info_log_memory (slang_info_log *log)
d334 11
a344 5
	if (!slang_info_log_message (log, "Error", "Out of memory."))
	{
		log->dont_free_text = 1;
		log->text = out_of_memory;
	}
d347 4
a350 1
/* slang_parse_ctx */
d352 4
a355 1
typedef struct slang_parse_ctx_
d357 18
a374 6
	const byte *I;
	slang_info_log *L;
	int parsing_builtin;
	int global_scope;
	slang_atom_pool *atoms;
} slang_parse_ctx;
d376 2
a377 1
/* slang_output_ctx */
d379 3
a381 1
typedef struct slang_output_ctx_
d383 18
a400 7
	slang_variable_scope *vars;
	slang_function_scope *funs;
	slang_struct_scope *structs;
	slang_assembly_file *assembly;
	slang_var_pool *global_pool;
	slang_machine *machine;
} slang_output_ctx;
d402 4
a405 1
/* _slang_compile() */
d407 1
a407 4
static void parse_identifier_str (slang_parse_ctx *C, char **id)
{
	*id = (char *) C->I;
	C->I += _mesa_strlen (*id) + 1;
d410 2
a411 1
static slang_atom parse_identifier (slang_parse_ctx *C)
d413 2
a414 53
	const char *id;
	
	id = (const char *) C->I;
	C->I += _mesa_strlen (id) + 1;
	return slang_atom_pool_atom (C->atoms, id);
}

static int parse_number (slang_parse_ctx *C, int *number)
{
	const int radix = (int) (*C->I++);
	*number = 0;
	while (*C->I != '\0')
	{
		int digit;
		if (*C->I >= '0' && *C->I <= '9')
			digit = (int) (*C->I - '0');
		else if (*C->I >= 'A' && *C->I <= 'Z')
			digit = (int) (*C->I - 'A') + 10;
		else
			digit = (int) (*C->I - 'a') + 10;
		*number = *number * radix + digit;
		C->I++;
	}
	C->I++;
	if (*number > 65535)
      slang_info_log_warning (C->L, "%d: literal integer overflow.", *number);
	return 1;
}

static int parse_float (slang_parse_ctx *C, float *number)
{
	char *integral = NULL;
	char *fractional = NULL;
	char *exponent = NULL;
	char *whole = NULL;

	parse_identifier_str (C, &integral);
	parse_identifier_str (C, &fractional);
	parse_identifier_str (C, &exponent);

	whole = (char *) (slang_alloc_malloc ((_mesa_strlen (integral) + _mesa_strlen (fractional) +
		_mesa_strlen (exponent) + 3) * sizeof (char)));
	if (whole == NULL)
	{
		slang_info_log_memory (C->L);
		return 0;
	}

	slang_string_copy (whole, integral);
	slang_string_concat (whole, ".");
	slang_string_concat (whole, fractional);
	slang_string_concat (whole, "E");
	slang_string_concat (whole, exponent);
d416 4
a419 1
	*number = (float) (_mesa_strtod(whole, (char **)NULL));
d421 6
a426 3
	slang_alloc_free (whole);
	return 1;
}
d428 14
a441 2
/* revision number - increment after each change affecting emitted output */
#define REVISION 3
d443 12
a454 70
static int check_revision (slang_parse_ctx *C)
{
	if (*C->I != REVISION)
	{
      slang_info_log_error (C->L, "Internal compiler error.");
		return 0;
	}
	C->I++;
	return 1;
}

static int parse_statement (slang_parse_ctx *, slang_output_ctx *, slang_operation *);
static int parse_expression (slang_parse_ctx *, slang_output_ctx *, slang_operation *);
static int parse_type_specifier (slang_parse_ctx *, slang_output_ctx *, slang_type_specifier *);

static GLboolean parse_array_len (slang_parse_ctx *C, slang_output_ctx *O, GLuint *len)
{
	slang_operation array_size;
	slang_assembly_name_space space;
	GLboolean result;

	if (!slang_operation_construct (&array_size))
		return GL_FALSE;
	if (!parse_expression (C, O, &array_size))
	{
		slang_operation_destruct (&array_size);
		return GL_FALSE;
	}

	space.funcs = O->funs;
	space.structs = O->structs;
	space.vars = O->vars;
	result = _slang_evaluate_int (O->assembly, O->machine, &space, &array_size, len, C->atoms);
	slang_operation_destruct (&array_size);
	return result;
}

static GLboolean calculate_var_size (slang_parse_ctx *C, slang_output_ctx *O, slang_variable *var)
{
	slang_storage_aggregate agg;

	if (!slang_storage_aggregate_construct (&agg))
		return GL_FALSE;
	if (!_slang_aggregate_variable (&agg, &var->type.specifier, var->array_len, O->funs, O->structs,
			O->vars, O->machine, O->assembly, C->atoms))
	{
		slang_storage_aggregate_destruct (&agg);
		return GL_FALSE;
	}
	var->size = _slang_sizeof_aggregate (&agg);
	slang_storage_aggregate_destruct (&agg);
	return GL_TRUE;
}

static GLboolean convert_to_array (slang_parse_ctx *C, slang_variable *var,
	const slang_type_specifier *sp)
{
	/* sized array - mark it as array, copy the specifier to the array element and
	 * parse the expression */
	var->type.specifier.type = slang_spec_array;
	var->type.specifier._array = (slang_type_specifier *) slang_alloc_malloc (sizeof (
		slang_type_specifier));
	if (var->type.specifier._array == NULL)
	{
		slang_info_log_memory (C->L);
		return GL_FALSE;
	}
	slang_type_specifier_ctr (var->type.specifier._array);
	return slang_type_specifier_copy (var->type.specifier._array, sp);
}
d456 21
a476 4
/* structure field */
#define FIELD_NONE 0
#define FIELD_NEXT 1
#define FIELD_ARRAY 2
d478 2
a479 126
static GLboolean parse_struct_field_var (slang_parse_ctx *C, slang_output_ctx *O, slang_variable *var,
	const slang_type_specifier *sp)
{
	var->a_name = parse_identifier (C);
	if (var->a_name == SLANG_ATOM_NULL)
		return GL_FALSE;

	switch (*C->I++)
	{
	case FIELD_NONE:
		if (!slang_type_specifier_copy (&var->type.specifier, sp))
			return GL_FALSE;
		break;
	case FIELD_ARRAY:
		if (!convert_to_array (C, var, sp))
			return GL_FALSE;
		if (!parse_array_len (C, O, &var->array_len))
			return GL_FALSE;
		break;
	default:
		return GL_FALSE;
	}

	return calculate_var_size (C, O, var);
}

static int parse_struct_field (slang_parse_ctx *C, slang_output_ctx *O, slang_struct *st,
	slang_type_specifier *sp)
{
	slang_output_ctx o = *O;

	o.structs = st->structs;
	if (!parse_type_specifier (C, &o, sp))
		return 0;
	do
	{
		slang_variable *var;

		st->fields->variables = (slang_variable *) slang_alloc_realloc (st->fields->variables,
			st->fields->num_variables * sizeof (slang_variable),
			(st->fields->num_variables + 1) * sizeof (slang_variable));
		if (st->fields->variables == NULL)
		{
			slang_info_log_memory (C->L);
			return 0;
		}
		var = &st->fields->variables[st->fields->num_variables];
		if (!slang_variable_construct (var))
			return 0;
		st->fields->num_variables++;
		if (!parse_struct_field_var (C, &o, var, sp))
			return 0;
	}
	while (*C->I++ != FIELD_NONE);

	return 1;
}

static int parse_struct (slang_parse_ctx *C, slang_output_ctx *O, slang_struct **st)
{
	slang_atom a_name;
	const char *name;

	/* parse struct name (if any) and make sure it is unique in current scope */
	a_name = parse_identifier (C);
	if (a_name == SLANG_ATOM_NULL)
		return 0;
	name = slang_atom_pool_id (C->atoms, a_name);
	if (name[0] != '\0' && slang_struct_scope_find (O->structs, a_name, 0) != NULL)
	{
      slang_info_log_error (C->L, "%s: duplicate type name.", name);
		return 0;
	}

	/* set-up a new struct */
	*st = (slang_struct *) slang_alloc_malloc (sizeof (slang_struct));
	if (*st == NULL)
	{
		slang_info_log_memory (C->L);
		return 0;
	}
	if (!slang_struct_construct (*st))
	{
		slang_alloc_free (*st);
		*st = NULL;
		slang_info_log_memory (C->L);
		return 0;
	}
	(**st).a_name = a_name;
	(**st).structs->outer_scope = O->structs;

	/* parse individual struct fields */
	do
	{
		slang_type_specifier sp;

		slang_type_specifier_ctr (&sp);
		if (!parse_struct_field (C, O, *st, &sp))
		{
			slang_type_specifier_dtr (&sp);
			return 0;
		}
		slang_type_specifier_dtr (&sp);
	}
	while (*C->I++ != FIELD_NONE);

	/* if named struct, copy it to current scope */
	if (name[0] != '\0')
	{
		slang_struct *s;

		O->structs->structs = (slang_struct *) slang_alloc_realloc (O->structs->structs,
			O->structs->num_structs * sizeof (slang_struct),
			(O->structs->num_structs + 1) * sizeof (slang_struct));
		if (O->structs->structs == NULL)
		{
			slang_info_log_memory (C->L);
			return 0;
		}
		s = &O->structs->structs[O->structs->num_structs];
		if (!slang_struct_construct (s))
			return 0;
		O->structs->num_structs++;
		if (!slang_struct_copy (s, *st))
			return 0;
	}
a480 2
	return 1;
}
d491 2
a492 1
static int parse_type_qualifier (slang_parse_ctx *C, slang_type_qualifier *qual)
d494 26
a519 27
	switch (*C->I++)
	{
	case TYPE_QUALIFIER_NONE:
		*qual = slang_qual_none;
		break;
	case TYPE_QUALIFIER_CONST:
		*qual = slang_qual_const;
		break;
	case TYPE_QUALIFIER_ATTRIBUTE:
		*qual = slang_qual_attribute;
		break;
	case TYPE_QUALIFIER_VARYING:
		*qual = slang_qual_varying;
		break;
	case TYPE_QUALIFIER_UNIFORM:
		*qual = slang_qual_uniform;
		break;
	case TYPE_QUALIFIER_FIXEDOUTPUT:
		*qual = slang_qual_fixedoutput;
		break;
	case TYPE_QUALIFIER_FIXEDINPUT:
		*qual = slang_qual_fixedinput;
		break;
	default:
		return 0;
	}
	return 1;
d545 191
a735 2
#define TYPE_SPECIFIER_STRUCT 22
#define TYPE_SPECIFIER_TYPENAME 23
d737 1
a737 121
static int parse_type_specifier (slang_parse_ctx *C, slang_output_ctx *O, slang_type_specifier *spec)
{
	switch (*C->I++)
	{
	case TYPE_SPECIFIER_VOID:
		spec->type = slang_spec_void;
		break;
	case TYPE_SPECIFIER_BOOL:
		spec->type = slang_spec_bool;
		break;
	case TYPE_SPECIFIER_BVEC2:
		spec->type = slang_spec_bvec2;
		break;
	case TYPE_SPECIFIER_BVEC3:
		spec->type = slang_spec_bvec3;
		break;
	case TYPE_SPECIFIER_BVEC4:
		spec->type = slang_spec_bvec4;
		break;
	case TYPE_SPECIFIER_INT:
		spec->type = slang_spec_int;
		break;
	case TYPE_SPECIFIER_IVEC2:
		spec->type = slang_spec_ivec2;
		break;
	case TYPE_SPECIFIER_IVEC3:
		spec->type = slang_spec_ivec3;
		break;
	case TYPE_SPECIFIER_IVEC4:
		spec->type = slang_spec_ivec4;
		break;
	case TYPE_SPECIFIER_FLOAT:
		spec->type = slang_spec_float;
		break;
	case TYPE_SPECIFIER_VEC2:
		spec->type = slang_spec_vec2;
		break;
	case TYPE_SPECIFIER_VEC3:
		spec->type = slang_spec_vec3;
		break;
	case TYPE_SPECIFIER_VEC4:
		spec->type = slang_spec_vec4;
		break;
	case TYPE_SPECIFIER_MAT2:
		spec->type = slang_spec_mat2;
		break;
	case TYPE_SPECIFIER_MAT3:
		spec->type = slang_spec_mat3;
		break;
	case TYPE_SPECIFIER_MAT4:
		spec->type = slang_spec_mat4;
		break;
	case TYPE_SPECIFIER_SAMPLER1D:
		spec->type = slang_spec_sampler1D;
		break;
	case TYPE_SPECIFIER_SAMPLER2D:
		spec->type = slang_spec_sampler2D;
		break;
	case TYPE_SPECIFIER_SAMPLER3D:
		spec->type = slang_spec_sampler3D;
		break;
	case TYPE_SPECIFIER_SAMPLERCUBE:
		spec->type = slang_spec_samplerCube;
		break;
	case TYPE_SPECIFIER_SAMPLER1DSHADOW:
		spec->type = slang_spec_sampler1DShadow;
		break;
	case TYPE_SPECIFIER_SAMPLER2DSHADOW:
		spec->type = slang_spec_sampler2DShadow;
		break;
	case TYPE_SPECIFIER_STRUCT:
		spec->type = slang_spec_struct;
		if (!parse_struct (C, O, &spec->_struct))
			return 0;
		break;
	case TYPE_SPECIFIER_TYPENAME:
		spec->type = slang_spec_struct;
		{
			slang_atom a_name;
			slang_struct *stru;

			a_name = parse_identifier (C);
			if (a_name == NULL)
				return 0;

			stru = slang_struct_scope_find (O->structs, a_name, 1);
			if (stru == NULL)
			{
            slang_info_log_error (C->L, "%s: undeclared type name.",
					slang_atom_pool_id (C->atoms, a_name));
				return 0;
			}

			spec->_struct = (slang_struct *) slang_alloc_malloc (sizeof (slang_struct));
			if (spec->_struct == NULL)
			{
				slang_info_log_memory (C->L);
				return 0;
			}
			if (!slang_struct_construct (spec->_struct))
			{
				slang_alloc_free (spec->_struct);
				spec->_struct = NULL;
				return 0;
			}
			if (!slang_struct_copy (spec->_struct, stru))
				return 0;
		}
		break;
	default:
		return 0;
	}
	return 1;
}

static int parse_fully_specified_type (slang_parse_ctx *C, slang_output_ctx *O,
	slang_fully_specified_type *type)
{
	if (!parse_type_qualifier (C, &type->qualifier))
		return 0;
	return parse_type_specifier (C, O, &type->specifier);
d804 180
a983 2
static int parse_child_operation (slang_parse_ctx *C, slang_output_ctx *O, slang_operation *oper,
	int statement)
d985 296
a1280 1
	slang_operation *ch;
d1282 1
a1282 448
	oper->children = (slang_operation *) slang_alloc_realloc (oper->children,
		oper->num_children * sizeof (slang_operation),
		(oper->num_children + 1) * sizeof (slang_operation));
	if (oper->children == NULL)
	{
		slang_info_log_memory (C->L);
		return 0;
	}
	ch = &oper->children[oper->num_children];
	if (!slang_operation_construct (ch))
	{
		slang_info_log_memory (C->L);
		return 0;
	}
	oper->num_children++;
	if (statement)
		return parse_statement (C, O, ch);
	return parse_expression (C, O, ch);
}

static int parse_declaration (slang_parse_ctx *C, slang_output_ctx *O);

static int parse_statement (slang_parse_ctx *C, slang_output_ctx *O, slang_operation *oper)
{
	oper->locals->outer_scope = O->vars;
	switch (*C->I++)
	{
	case OP_BLOCK_BEGIN_NO_NEW_SCOPE:
		/* parse child statements, do not create new variable scope */
		oper->type = slang_oper_block_no_new_scope;
		while (*C->I != OP_END)
			if (!parse_child_operation (C, O, oper, 1))
				return 0;
		C->I++;
		break;
	case OP_BLOCK_BEGIN_NEW_SCOPE:
		/* parse child statements, create new variable scope */
		{
			slang_output_ctx o = *O;

			oper->type = slang_oper_block_new_scope;
			o.vars = oper->locals;
			while (*C->I != OP_END)
				if (!parse_child_operation (C, &o, oper, 1))
					return 0;
			C->I++;
		}
		break;
	case OP_DECLARE:
		/* local variable declaration, individual declarators are stored as children identifiers */
		oper->type = slang_oper_variable_decl;
		{
			const unsigned int first_var = O->vars->num_variables;

			/* parse the declaration, note that there can be zero or more than one declarators */
			if (!parse_declaration (C, O))
				return 0;
			if (first_var < O->vars->num_variables)
			{
				const unsigned int num_vars = O->vars->num_variables - first_var;
				unsigned int i;

				oper->children = (slang_operation *) slang_alloc_malloc (num_vars * sizeof (
					slang_operation));
				if (oper->children == NULL)
				{
					slang_info_log_memory (C->L);
					return 0;
				}
				for (oper->num_children = 0; oper->num_children < num_vars; oper->num_children++)
					if (!slang_operation_construct (&oper->children[oper->num_children]))
					{
						slang_info_log_memory (C->L);
						return 0;
					}
				for (i = first_var; i < O->vars->num_variables; i++)
				{
					slang_operation *o = &oper->children[i - first_var];

					o->type = slang_oper_identifier;
					o->locals->outer_scope = O->vars;
					o->a_id = O->vars->variables[i].a_name;
				}
			}
		}
		break;
	case OP_ASM:
		/* the __asm statement, parse the mnemonic and all its arguments as expressions */
		oper->type = slang_oper_asm;
		oper->a_id = parse_identifier (C);
		if (oper->a_id == SLANG_ATOM_NULL)
			return 0;
		while (*C->I != OP_END)
			if (!parse_child_operation (C, O, oper, 0))
				return 0;
		C->I++;
		break;
	case OP_BREAK:
		oper->type = slang_oper_break;
		break;
	case OP_CONTINUE:
		oper->type = slang_oper_continue;
		break;
	case OP_DISCARD:
		oper->type = slang_oper_discard;
		break;
	case OP_RETURN:
		oper->type = slang_oper_return;
		if (!parse_child_operation (C, O, oper, 0))
			return 0;
		break;
	case OP_EXPRESSION:
		oper->type = slang_oper_expression;
		if (!parse_child_operation (C, O, oper, 0))
			return 0;
		break;
	case OP_IF:
		oper->type = slang_oper_if;
		if (!parse_child_operation (C, O, oper, 0))
			return 0;
		if (!parse_child_operation (C, O, oper, 1))
			return 0;
		if (!parse_child_operation (C, O, oper, 1))
			return 0;
		break;
	case OP_WHILE:
		{
			slang_output_ctx o = *O;

			oper->type = slang_oper_while;
			o.vars = oper->locals;
			if (!parse_child_operation (C, &o, oper, 1))
				return 0;
			if (!parse_child_operation (C, &o, oper, 1))
				return 0;
		}
		break;
	case OP_DO:
		oper->type = slang_oper_do;
		if (!parse_child_operation (C, O, oper, 1))
			return 0;
		if (!parse_child_operation (C, O, oper, 0))
			return 0;
		break;
	case OP_FOR:
		{
			slang_output_ctx o = *O;

			oper->type = slang_oper_for;
			o.vars = oper->locals;
			if (!parse_child_operation (C, &o, oper, 1))
				return 0;
			if (!parse_child_operation (C, &o, oper, 1))
				return 0;
			if (!parse_child_operation (C, &o, oper, 0))
				return 0;
			if (!parse_child_operation (C, &o, oper, 1))
				return 0;
		}
		break;
	default:
		return 0;
	}
	return 1;
}

static int handle_nary_expression (slang_parse_ctx *C, slang_operation *op, slang_operation **ops,
	unsigned int *total_ops, unsigned int n)
{
	unsigned int i;

	op->children = (slang_operation *) slang_alloc_malloc (n * sizeof (slang_operation));
	if (op->children == NULL)
	{
		slang_info_log_memory (C->L);
		return 0;
	}
	op->num_children = n;

	for (i = 0; i < n; i++)
		op->children[i] = (*ops)[*total_ops - (n + 1 - i)];
	(*ops)[*total_ops - (n + 1)] = (*ops)[*total_ops - 1];
	*total_ops -= n;

	*ops = (slang_operation *) slang_alloc_realloc (*ops, (*total_ops + n) * sizeof (slang_operation),
		*total_ops * sizeof (slang_operation));
	if (*ops == NULL)
	{
		slang_info_log_memory (C->L);
		return 0;
	}
	return 1;
}

static int is_constructor_name (const char *name, slang_atom a_name, slang_struct_scope *structs)
{
	if (slang_type_specifier_type_from_string (name) != slang_spec_void)
		return 1;
	return slang_struct_scope_find (structs, a_name, 1) != NULL;
}

static int parse_expression (slang_parse_ctx *C, slang_output_ctx *O, slang_operation *oper)
{
	slang_operation *ops = NULL;
	unsigned int num_ops = 0;
	int number;

	while (*C->I != OP_END)
	{
		slang_operation *op;
		const unsigned int op_code = *C->I++;

		/* allocate default operation, becomes a no-op if not used  */
		ops = (slang_operation *) slang_alloc_realloc (ops,
			num_ops * sizeof (slang_operation), (num_ops + 1) * sizeof (slang_operation));
		if (ops == NULL)
		{
			slang_info_log_memory (C->L);
			return 0;
		}
		op = &ops[num_ops];
		if (!slang_operation_construct (op))
		{
			slang_info_log_memory (C->L);
			return 0;
		}
		num_ops++;
		op->locals->outer_scope = O->vars;

		switch (op_code)
		{
		case OP_PUSH_VOID:
			op->type = slang_oper_void;
			break;
		case OP_PUSH_BOOL:
			op->type = slang_oper_literal_bool;
			if (!parse_number (C, &number))
				return 0;
			op->literal = (GLfloat) number;
			break;
		case OP_PUSH_INT:
			op->type = slang_oper_literal_int;
			if (!parse_number (C, &number))
				return 0;
			op->literal = (GLfloat) number;
			break;
		case OP_PUSH_FLOAT:
			op->type = slang_oper_literal_float;
			if (!parse_float (C, &op->literal))
				return 0;
			break;
		case OP_PUSH_IDENTIFIER:
			op->type = slang_oper_identifier;
			op->a_id = parse_identifier (C);
			if (op->a_id == SLANG_ATOM_NULL)
				return 0;
			break;
		case OP_SEQUENCE:
			op->type = slang_oper_sequence;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_ASSIGN:
			op->type = slang_oper_assign;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_ADDASSIGN:
			op->type = slang_oper_addassign;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_SUBASSIGN:
			op->type = slang_oper_subassign;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_MULASSIGN:
			op->type = slang_oper_mulassign;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_DIVASSIGN:
			op->type = slang_oper_divassign;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		/*case OP_MODASSIGN:*/
		/*case OP_LSHASSIGN:*/
		/*case OP_RSHASSIGN:*/
		/*case OP_ORASSIGN:*/
		/*case OP_XORASSIGN:*/
		/*case OP_ANDASSIGN:*/
		case OP_SELECT:
			op->type = slang_oper_select;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 3))
				return 0;
			break;
		case OP_LOGICALOR:
			op->type = slang_oper_logicalor;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_LOGICALXOR:
			op->type = slang_oper_logicalxor;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_LOGICALAND:
			op->type = slang_oper_logicaland;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		/*case OP_BITOR:*/
		/*case OP_BITXOR:*/
		/*case OP_BITAND:*/
		case OP_EQUAL:
			op->type = slang_oper_equal;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_NOTEQUAL:
			op->type = slang_oper_notequal;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_LESS:
			op->type = slang_oper_less;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_GREATER:
			op->type = slang_oper_greater;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_LESSEQUAL:
			op->type = slang_oper_lessequal;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_GREATEREQUAL:
			op->type = slang_oper_greaterequal;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		/*case OP_LSHIFT:*/
		/*case OP_RSHIFT:*/
		case OP_ADD:
			op->type = slang_oper_add;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_SUBTRACT:
			op->type = slang_oper_subtract;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_MULTIPLY:
			op->type = slang_oper_multiply;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_DIVIDE:
			op->type = slang_oper_divide;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		/*case OP_MODULUS:*/
		case OP_PREINCREMENT:
			op->type = slang_oper_preincrement;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 1))
				return 0;
			break;
		case OP_PREDECREMENT:
			op->type = slang_oper_predecrement;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 1))
				return 0;
			break;
		case OP_PLUS:
			op->type = slang_oper_plus;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 1))
				return 0;
			break;
		case OP_MINUS:
			op->type = slang_oper_minus;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 1))
				return 0;
			break;
		case OP_NOT:
			op->type = slang_oper_not;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 1))
				return 0;
			break;
		/*case OP_COMPLEMENT:*/
		case OP_SUBSCRIPT:
			op->type = slang_oper_subscript;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 2))
				return 0;
			break;
		case OP_CALL:
			op->type = slang_oper_call;
			op->a_id = parse_identifier (C);
			if (op->a_id == SLANG_ATOM_NULL)
				return 0;
			while (*C->I != OP_END)
				if (!parse_child_operation (C, O, op, 0))
					return 0;
			C->I++;
			if (!C->parsing_builtin && !slang_function_scope_find_by_name (O->funs, op->a_id, 1))
			{
				const char *id;

				id = slang_atom_pool_id (C->atoms, op->a_id);
				if (!is_constructor_name (id, op->a_id, O->structs))
				{
               slang_info_log_error (C->L, "%s: undeclared function name.", id);
					return 0;
				}
			}
			break;
		case OP_FIELD:
			op->type = slang_oper_field;
			op->a_id = parse_identifier (C);
			if (op->a_id == SLANG_ATOM_NULL)
				return 0;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 1))
				return 0;
			break;
		case OP_POSTINCREMENT:
			op->type = slang_oper_postincrement;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 1))
				return 0;
			break;
		case OP_POSTDECREMENT:
			op->type = slang_oper_postdecrement;
			if (!handle_nary_expression (C, op, &ops, &num_ops, 1))
				return 0;
			break;
		default:
			return 0;
		}
	}
	C->I++;

	*oper = *ops;
	slang_alloc_free (ops);
	return 1;
d1294 67
a1360 69
static int parse_parameter_declaration (slang_parse_ctx *C, slang_output_ctx *O,
	slang_variable *param)
{
	/* parse and validate the parameter's type qualifiers (there can be two at most) because
	 * not all combinations are valid */
	if (!parse_type_qualifier (C, &param->type.qualifier))
		return 0;
	switch (*C->I++)
	{
	case PARAM_QUALIFIER_IN:
		if (param->type.qualifier != slang_qual_const && param->type.qualifier != slang_qual_none)
		{
         slang_info_log_error (C->L, "Invalid type qualifier.");
			return 0;
		}
		break;
	case PARAM_QUALIFIER_OUT:
		if (param->type.qualifier == slang_qual_none)
			param->type.qualifier = slang_qual_out;
		else
		{
         slang_info_log_error (C->L, "Invalid type qualifier.");
			return 0;
		}
		break;
	case PARAM_QUALIFIER_INOUT:
		if (param->type.qualifier == slang_qual_none)
			param->type.qualifier = slang_qual_inout;
		else
		{
         slang_info_log_error (C->L, "Invalid type qualifier.");
			return 0;
		}
		break;
	default:
		return 0;
	}

	/* parse parameter's type specifier and name */
	if (!parse_type_specifier (C, O, &param->type.specifier))
		return 0;
	param->a_name = parse_identifier (C);
	if (param->a_name == SLANG_ATOM_NULL)
		return 0;

	/* if the parameter is an array, parse its size (the size must be explicitly defined */
	if (*C->I++ == PARAMETER_ARRAY_PRESENT)
	{
		slang_type_specifier p;

		slang_type_specifier_ctr (&p);
		if (!slang_type_specifier_copy (&p, &param->type.specifier))
		{
			slang_type_specifier_dtr (&p);
			return GL_FALSE;
		}
		if (!convert_to_array (C, param, &p))
		{
			slang_type_specifier_dtr (&p);
			return GL_FALSE;
		}
		slang_type_specifier_dtr (&p);
		if (!parse_array_len (C, O, &param->array_len))
			return GL_FALSE;
	}

	/* calculate the parameter size */
	if (!calculate_var_size (C, O, param))
		return GL_FALSE;
d1362 2
a1363 2
	/* TODO: allocate the local address here? */
	return 1;
d1406 4
a1409 3
static const struct {
	unsigned int o_code;
	const char *o_name;
d1411 29
a1439 29
	{ OPERATOR_INCREMENT, "++" },
	{ OPERATOR_ADDASSIGN, "+=" },
	{ OPERATOR_PLUS, "+" },
	{ OPERATOR_DECREMENT, "--" },
	{ OPERATOR_SUBASSIGN, "-=" },
	{ OPERATOR_MINUS, "-" },
	{ OPERATOR_NOT, "!" },
	{ OPERATOR_MULASSIGN, "*=" },
	{ OPERATOR_MULTIPLY, "*" },
	{ OPERATOR_DIVASSIGN, "/=" },
	{ OPERATOR_DIVIDE, "/" },
	{ OPERATOR_LESSEQUAL, "<=" },
	/*{ OPERATOR_LSHASSIGN, "<<=" },*/
	/*{ OPERATOR_LSHIFT, "<<" },*/
	{ OPERATOR_LESS, "<" },
	{ OPERATOR_GREATEREQUAL, ">=" },
	/*{ OPERATOR_RSHASSIGN, ">>=" },*/
	/*{ OPERATOR_RSHIFT, ">>" },*/
	{ OPERATOR_GREATER, ">" },
	/*{ OPERATOR_MODASSIGN, "%=" },*/
	/*{ OPERATOR_MODULUS, "%" },*/
	/*{ OPERATOR_ANDASSIGN, "&=" },*/
	/*{ OPERATOR_BITAND, "&" },*/
	/*{ OPERATOR_ORASSIGN, "|=" },*/
	/*{ OPERATOR_BITOR, "|" },*/
	/*{ OPERATOR_COMPLEMENT, "~" },*/
	/*{ OPERATOR_XORASSIGN, "^=" },*/
	{ OPERATOR_LOGICALXOR, "^^" },
	/*{ OPERATOR_BITXOR, "^" }*/
d1442 135
a1576 1
static slang_atom parse_operator_name (slang_parse_ctx *C)
d1578 2
a1579 1
	unsigned int i;
d1581 5
a1585 204
	for (i = 0; i < sizeof (operator_names) / sizeof (*operator_names); i++)
	{
		if (operator_names[i].o_code == (unsigned int) (*C->I))
		{
			slang_atom atom = slang_atom_pool_atom (C->atoms, operator_names[i].o_name);
			if (atom == SLANG_ATOM_NULL)
			{
				slang_info_log_memory (C->L);
				return 0;
			}
			C->I++;
			return atom;
		}
	}
	return 0;
}

static int parse_function_prototype (slang_parse_ctx *C, slang_output_ctx *O, slang_function *func)
{
	/* parse function type and name */
	if (!parse_fully_specified_type (C, O, &func->header.type))
		return 0;
	switch (*C->I++)
	{
	case FUNCTION_ORDINARY:
		func->kind = slang_func_ordinary;
		func->header.a_name = parse_identifier (C);
		if (func->header.a_name == SLANG_ATOM_NULL)
			return 0;
		break;
	case FUNCTION_CONSTRUCTOR:
		func->kind = slang_func_constructor;
		if (func->header.type.specifier.type == slang_spec_struct)
			return 0;
		func->header.a_name = slang_atom_pool_atom (C->atoms,
			slang_type_specifier_type_to_string (func->header.type.specifier.type));
		if (func->header.a_name == SLANG_ATOM_NULL)
		{
			slang_info_log_memory (C->L);
			return 0;
		}
		break;
	case FUNCTION_OPERATOR:
		func->kind = slang_func_operator;
		func->header.a_name = parse_operator_name (C);
		if (func->header.a_name == SLANG_ATOM_NULL)
			return 0;
		break;
	default:
		return 0;
	}

	/* parse function parameters */
	while (*C->I++ == PARAMETER_NEXT)
	{
		slang_variable *p;

		func->parameters->variables = (slang_variable *) slang_alloc_realloc (
			func->parameters->variables,
			func->parameters->num_variables * sizeof (slang_variable),
			(func->parameters->num_variables + 1) * sizeof (slang_variable));
		if (func->parameters->variables == NULL)
		{
			slang_info_log_memory (C->L);
			return 0;
		}
		p = &func->parameters->variables[func->parameters->num_variables];
		if (!slang_variable_construct (p))
			return 0;
		func->parameters->num_variables++;
		if (!parse_parameter_declaration (C, O, p))
			return 0;
	}

	/* function formal parameters and local variables share the same scope, so save
	 * the information about param count in a seperate place
	 * also link the scope to the global variable scope so when a given identifier is not
	 * found here, the search process continues in the global space */
	func->param_count = func->parameters->num_variables;
	func->parameters->outer_scope = O->vars;
	return 1;
}

static int parse_function_definition (slang_parse_ctx *C, slang_output_ctx *O, slang_function *func)
{
	slang_output_ctx o = *O;

	if (!parse_function_prototype (C, O, func))
		return 0;

	/* create function's body operation */
	func->body = (slang_operation *) slang_alloc_malloc (sizeof (slang_operation));
	if (func->body == NULL)
	{
		slang_info_log_memory (C->L);
		return 0;
	}
	if (!slang_operation_construct (func->body))
	{
		slang_alloc_free (func->body);
		func->body = NULL;
		slang_info_log_memory (C->L);
		return 0;
	}

	/* to parse the body the parse context is modified in order to capture parsed variables
	 * into function's local variable scope */
	C->global_scope = 0;
	o.vars = func->parameters;
	if (!parse_statement (C, &o, func->body))
		return 0;
	C->global_scope = 1;
	return 1;
}

static GLboolean initialize_global (slang_assemble_ctx *A, slang_variable *var)
{
	slang_assembly_file_restore_point point;
	slang_machine mach;
	slang_assembly_local_info save_local = A->local;
	slang_operation op_id, op_assign;
	GLboolean result;

	/* save the current assembly */
	if (!slang_assembly_file_restore_point_save (A->file, &point))
		return GL_FALSE;

	/* setup the machine */
	mach = *A->mach;
	mach.ip = A->file->count;

	/* allocate local storage for expression */
	A->local.ret_size = 0;
	A->local.addr_tmp = 0;
	A->local.swizzle_tmp = 4;
	if (!slang_assembly_file_push_label (A->file, slang_asm_local_alloc, 20))
		return GL_FALSE;
	if (!slang_assembly_file_push_label (A->file, slang_asm_enter, 20))
		return GL_FALSE;

	/* construct the left side of assignment */
	if (!slang_operation_construct (&op_id))
		return GL_FALSE;
	op_id.type = slang_oper_identifier;
	op_id.a_id = var->a_name;

	/* put the variable into operation's scope */
	op_id.locals->variables = (slang_variable *) slang_alloc_malloc (sizeof (slang_variable));
	if (op_id.locals->variables == NULL)
	{
		slang_operation_destruct (&op_id);
		return GL_FALSE;
	}
	op_id.locals->num_variables = 1;
	op_id.locals->variables[0] = *var;

	/* construct the assignment expression */
	if (!slang_operation_construct (&op_assign))
	{
		op_id.locals->num_variables = 0;
		slang_operation_destruct (&op_id);
		return GL_FALSE;
	}
	op_assign.type = slang_oper_assign;
	op_assign.children = (slang_operation *) slang_alloc_malloc (2 * sizeof (slang_operation));
	if (op_assign.children == NULL)
	{
		slang_operation_destruct (&op_assign);
		op_id.locals->num_variables = 0;
		slang_operation_destruct (&op_id);
		return GL_FALSE;
	}
	op_assign.num_children = 2;
	op_assign.children[0] = op_id;
	op_assign.children[1] = *var->initializer;

	/* insert the actual expression */
	result = _slang_assemble_operation (A, &op_assign, slang_ref_forbid);

	/* carefully destroy the operations */
	op_assign.num_children = 0;
	slang_alloc_free (op_assign.children);
	op_assign.children = NULL;
	slang_operation_destruct (&op_assign);
	op_id.locals->num_variables = 0;
	slang_operation_destruct (&op_id);

	if (!result)
		return GL_FALSE;
	if (!slang_assembly_file_push (A->file, slang_asm_exit))
		return GL_FALSE;

	/* execute the expression */
	if (!_slang_execute2 (A->file, &mach))
		return GL_FALSE;

	/* restore the old assembly */
	if (!slang_assembly_file_restore_point_load (A->file, &point))
		return GL_FALSE;
	A->local = save_local;

	/* now we copy the contents of the initialized variable back to the original machine */
	_mesa_memcpy ((GLubyte *) A->mach->mem + var->address, (GLubyte *) mach.mem + var->address,
		var->size);
d1587 43
a1629 1
	return GL_TRUE;
a1642 4
static int parse_init_declarator (slang_parse_ctx *C, slang_output_ctx *O,
	const slang_fully_specified_type *type)
{
	slang_variable *var;
d1644 102
a1745 76
	/* empty init declatator (without name, e.g. "float ;") */
	if (*C->I++ == VARIABLE_NONE)
		return 1;

	/* make room for the new variable and initialize it */
	O->vars->variables = (slang_variable *) slang_alloc_realloc (O->vars->variables,
		O->vars->num_variables * sizeof (slang_variable),
		(O->vars->num_variables + 1) * sizeof (slang_variable));
	if (O->vars->variables == NULL)
	{
		slang_info_log_memory (C->L);
		return 0;
	}
	var = &O->vars->variables[O->vars->num_variables];
	if (!slang_variable_construct (var))
		return 0;
	O->vars->num_variables++;

	/* copy the declarator qualifier type, parse the identifier */
	var->global = C->global_scope;
	var->type.qualifier = type->qualifier;
	var->a_name = parse_identifier (C);
	if (var->a_name == SLANG_ATOM_NULL)
		return 0;

	switch (*C->I++)
	{
	case VARIABLE_NONE:
		/* simple variable declarator - just copy the specifier */
		if (!slang_type_specifier_copy (&var->type.specifier, &type->specifier))
			return 0;
		break;
	case VARIABLE_INITIALIZER:
		/* initialized variable - copy the specifier and parse the expression */
		if (!slang_type_specifier_copy (&var->type.specifier, &type->specifier))
			return 0;
		var->initializer = (slang_operation *) slang_alloc_malloc (sizeof (slang_operation));
		if (var->initializer == NULL)
		{
			slang_info_log_memory (C->L);
			return 0;
		}
		if (!slang_operation_construct (var->initializer))
		{
			slang_alloc_free (var->initializer);
			var->initializer = NULL;
			slang_info_log_memory (C->L);
			return 0;
		}
		if (!parse_expression (C, O, var->initializer))
			return 0;
		break;
#if 0
	case VARIABLE_ARRAY_UNKNOWN:
		/* unsized array - mark it as array and copy the specifier to the array element */
		if (!convert_to_array (C, var, &type->specifier))
			return GL_FALSE;
		break;
#endif
	case VARIABLE_ARRAY_EXPLICIT:
		if (!convert_to_array (C, var, &type->specifier))
			return GL_FALSE;
		if (!parse_array_len (C, O, &var->array_len))
			return GL_FALSE;
		break;
	default:
		return 0;
	}

	/* allocate global address space for a variable with a known size */
	if (C->global_scope && !(var->type.specifier.type == slang_spec_array && var->array_len == 0))
	{
		if (!calculate_var_size (C, O, var))
			return GL_FALSE;
		var->address = slang_var_pool_alloc (O->global_pool, var->size);
	}
d1747 1
a1747 1
	/* initialize global variable */
a1751 2
         A.file = O->assembly;
         A.mach = O->machine;
d1756 1
a1756 1
         if (!initialize_global (&A, var))
d1759 26
a1784 2
      else {
         _mesa_memset ((GLubyte *) (O->machine->mem) + var->address, 0, var->size);
d1786 5
a1790 2
	}
	return 1;
d1793 12
a1804 1
static int parse_init_declarator_list (slang_parse_ctx *C, slang_output_ctx *O)
d1806 73
a1878 116
	slang_fully_specified_type type;

	/* parse the fully specified type, common to all declarators */
	if (!slang_fully_specified_type_construct (&type))
		return 0;
	if (!parse_fully_specified_type (C, O, &type))
	{
		slang_fully_specified_type_destruct (&type);
		return 0;
	}

	/* parse declarators, pass-in the parsed type */
	do
	{
		if (!parse_init_declarator (C, O, &type))
		{
			slang_fully_specified_type_destruct (&type);
			return 0;
		}
	}
	while (*C->I++ == DECLARATOR_NEXT);

	slang_fully_specified_type_destruct (&type);
	return 1;
}

static int parse_function (slang_parse_ctx *C, slang_output_ctx *O, int definition,
	slang_function **parsed_func_ret)
{
	slang_function parsed_func, *found_func;

	/* parse function definition/declaration */
	if (!slang_function_construct (&parsed_func))
		return 0;
	if (definition)
	{
		if (!parse_function_definition (C, O, &parsed_func))
		{
			slang_function_destruct (&parsed_func);
			return 0;
		}
	}
	else
	{
		if (!parse_function_prototype (C, O, &parsed_func))
		{
			slang_function_destruct (&parsed_func);
			return 0;
		}
	}

	/* find a function with a prototype matching the parsed one - only the current scope
	 * is being searched to allow built-in function overriding */
	found_func = slang_function_scope_find (O->funs, &parsed_func, 0);
	if (found_func == NULL)
	{
		/* add the parsed function to the function list */
		O->funs->functions = (slang_function *) slang_alloc_realloc (O->funs->functions,
			O->funs->num_functions * sizeof (slang_function),
			(O->funs->num_functions + 1) * sizeof (slang_function));
		if (O->funs->functions == NULL)
		{
			slang_info_log_memory (C->L);
			slang_function_destruct (&parsed_func);
			return 0;
		}
		O->funs->functions[O->funs->num_functions] = parsed_func;
		O->funs->num_functions++;

		/* return the newly parsed function */
		*parsed_func_ret = &O->funs->functions[O->funs->num_functions - 1];
	}
	else
	{
		/* TODO: check function return type qualifiers and specifiers */
		if (definition)
		{
			if (found_func->body != NULL)
			{
            slang_info_log_error (C->L, "%s: function already has a body.",
					slang_atom_pool_id (C->atoms, parsed_func.header.a_name));
				slang_function_destruct (&parsed_func);
				return 0;
			}

			/* destroy the existing function declaration and replace it with the new one,
			 * remember to save the fixup table */
			parsed_func.fixups = found_func->fixups;
			slang_fixup_table_init (&found_func->fixups);
			slang_function_destruct (found_func);
			*found_func = parsed_func;
		}
		else
		{
			/* another declaration of the same function prototype - ignore it */
			slang_function_destruct (&parsed_func);
		}

		/* return the found function */
		*parsed_func_ret = found_func;
	}

	/* assemble the parsed function */
	{
		slang_assemble_ctx A;

		A.file = O->assembly;
		A.mach = O->machine;
		A.atoms = C->atoms;
		A.space.funcs = O->funs;
		A.space.structs = O->structs;
		A.space.vars = O->vars;
		if (!_slang_assemble_function (&A, *parsed_func_ret))
			return 0;
	}
	return 1;
d1885 78
a1962 1
static int parse_declaration (slang_parse_ctx *C, slang_output_ctx *O)
d1964 17
a1980 18
	switch (*C->I++)
	{
	case DECLARATION_INIT_DECLARATOR_LIST:
		if (!parse_init_declarator_list (C, O))
			return 0;
		break;
	case DECLARATION_FUNCTION_PROTOTYPE:
		{
			slang_function *dummy_func;

			if (!parse_function (C, O, 0, &dummy_func))
				return 0;
		}
		break;
	default:
		return 0;
	}
	return 1;
d1983 18
a2000 1
/* external declaration */
d2004 3
d2009 2
a2010 1
parse_code_unit (slang_parse_ctx *C, slang_code_unit *unit)
d2012 15
a2026 1
	slang_output_ctx o;
d2029 1
a2032 1
   o.assembly = &unit->object->assembly;
d2034 38
a2071 1
   o.machine = &unit->object->machine;
d2073 27
a2099 23
	/* parse individual functions and declarations */
	while (*C->I != EXTERNAL_NULL)
	{
		switch (*C->I++)
		{
		case EXTERNAL_FUNCTION_DEFINITION:
			{
				slang_function *func;

				if (!parse_function (C, &o, 1, &func))
					return 0;
			}
			break;
		case EXTERNAL_DECLARATION:
			if (!parse_declaration (C, &o))
				return 0;
			break;
		default:
			return 0;
		}
	}
	C->I++;
	return 1;
d2103 5
a2107 2
compile_binary (const byte *prod, slang_code_unit *unit, slang_unit_type type,
                slang_info_log *infolog, slang_code_unit *builtin, slang_code_unit *downlink)
d2119 2
d2122 1
a2122 1
   if (!check_revision (&C))
d2132 1
a2132 1
   return parse_code_unit (&C, unit);
d2136 4
a2139 2
compile_with_grammar (grammar id, const char *source, slang_code_unit *unit, slang_unit_type type,
                      slang_info_log *infolog, slang_code_unit *builtin)
d2141 1
a2141 1
	byte *prod;
d2143 10
d2154 2
a2155 2
	/* retrieve version */
   if (!_slang_preprocess_version (source, &version, &start, infolog))
d2158 4
a2161 2
   if (version > 110) {
      slang_info_log_error (infolog, "language version specified is not supported.");
d2165 5
a2169 7
	/* check the syntax and generate its binary representation */
	if (!grammar_fast_check (id, (const byte *) source + start, &prod, &size, 65536))
	{
		char buf[1024];
		unsigned int pos;
		grammar_get_last_error ( (unsigned char*) buf, 1024, (int*) &pos);
      slang_info_log_error (infolog, buf);
d2171 1
a2171 1
	}
d2173 21
a2193 3
	/* syntax is okay - translate it to internal representation */
   if (!compile_binary (prod, unit, type, infolog, builtin, &builtin[SLANG_BUILTIN_TOTAL - 1])) {
      grammar_alloc_free (prod);
d2196 1
d2198 8
a2205 1
   grammar_alloc_free (prod);
d2209 1
a2209 1
static const char *slang_shader_syn =
d2211 1
a2211 1
;
d2217 8
a2236 6
#if defined(USE_X86_ASM) || defined(SLANG_X86)
static const byte slang_builtin_vec4_gc[] = {
#include "library/slang_builtin_vec4_gc.h"
};
#endif

d2238 3
a2240 2
compile_object (grammar *id, const char *source, slang_code_object *object, slang_unit_type type,
                slang_info_log *infolog)
d2243 1
d2246 28
a2273 26
	*id = grammar_load_from_text ((const byte *) (slang_shader_syn));
	if (*id == 0)
	{
		byte buf[1024];
		int pos;

		grammar_get_last_error (buf, 1024, &pos);
      slang_info_log_error (infolog, (const char *) (buf));
      return GL_FALSE;
	}

	/* set shader type - the syntax is slightly different for different shaders */
	if (type == slang_unit_fragment_shader || type == slang_unit_fragment_builtin)
		grammar_set_reg8 (*id, (const byte *) "shader_type", 1);
	else
		grammar_set_reg8 (*id, (const byte *) "shader_type", 2);

	/* enable language extensions */
	grammar_set_reg8 (*id, (const byte *) "parsing_builtin", 1);

	/* if parsing user-specified shader, load built-in library */
	if (type == slang_unit_fragment_shader || type == slang_unit_vertex_shader)
	{
		/* compile core functionality first */
      if (!compile_binary (slang_core_gc, &object->builtin[SLANG_BUILTIN_CORE],
                           slang_unit_fragment_builtin, infolog, NULL, NULL))
d2276 6
a2281 4
		/* compile common functions and variables, link to core */
      if (!compile_binary (slang_common_builtin_gc, &object->builtin[SLANG_BUILTIN_COMMON],
                           slang_unit_fragment_builtin, infolog, NULL,
                           &object->builtin[SLANG_BUILTIN_CORE]))
d2283 1
d2285 31
a2315 6
		/* compile target-specific functions and variables, link to common */
		if (type == slang_unit_fragment_shader)
		{
         if (!compile_binary (slang_fragment_builtin_gc, &object->builtin[SLANG_BUILTIN_TARGET],
                              slang_unit_fragment_builtin, infolog, NULL,
                              &object->builtin[SLANG_BUILTIN_COMMON]))
d2317 8
a2324 6
		}
		else if (type == slang_unit_vertex_shader)
		{
         if (!compile_binary (slang_vertex_builtin_gc, &object->builtin[SLANG_BUILTIN_TARGET],
                              slang_unit_vertex_builtin, infolog, NULL,
                              &object->builtin[SLANG_BUILTIN_COMMON]))
d2326 1
a2326 1
		}
d2328 5
a2332 6
#if defined(USE_X86_ASM) || defined(SLANG_X86)
      /* compile x86 4-component vector overrides, link to target */
      if (!compile_binary (slang_builtin_vec4_gc, &object->builtin[SLANG_BUILTIN_VEC4],
                           slang_unit_fragment_builtin, infolog, NULL,
                           &object->builtin[SLANG_BUILTIN_TARGET]))
         return GL_FALSE;
a2333 3

		/* disable language extensions */
		grammar_set_reg8 (*id, (const byte *) "parsing_builtin", 0);
d2335 1
a2335 1
	}
d2337 3
a2339 2
	/* compile the actual shader - pass-in built-in library for external shader */
   return compile_with_grammar (*id, source, &object->unit, type, infolog, builtins);
d2342 5
a2346 3
GLboolean
_slang_compile (const char *source, slang_code_object *object, slang_unit_type type,
                slang_info_log *infolog)
d2351 7
a2357 2
   _slang_code_object_dtr (object);
   _slang_code_object_ctr (object);
d2359 4
a2362 1
   success = compile_object (&id, source, object, type, infolog);
d2364 1
a2364 1
      grammar_destroy (id);
d2368 22
a2389 3
   if (!_slang_build_export_data_table (&object->expdata, &object->unit.vars))
      return GL_FALSE;
   if (!_slang_build_export_code_table (&object->expcode, &object->unit.funs, &object->unit))
d2392 55
a2446 4
#if defined(USE_X86_ASM) || defined(SLANG_X86)
   /* XXX: lookup the @@main label */
   if (!_slang_x86_codegen (&object->machine, &object->assembly, object->expcode.entries[0].address))
      return GL_FALSE;
d2449 1
a2449 1
   return GL_TRUE;
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
d38 3
a40 4
 * This is a straightforward implementation of the slang front-end
 * compiler.  Lots of error-checking functionality is missing but
 * every well-formed shader source should compile successfully and
 * execute as expected. However, some semantically ill-formed shaders
d44 1
d46 3
d50 3
a52 10
/**
 * Allocate storage for a variable of 'size' bytes from given pool.
 * Return the allocated address for the variable.
 */
static GLuint
slang_var_pool_alloc(slang_var_pool * pool, unsigned int size)
{
   const GLuint addr = pool->next_addr;
   pool->next_addr += size;
   return addr;
d60 1
a60 2
_slang_code_unit_ctr(slang_code_unit * self,
                     struct slang_code_object_ * object)
d62 3
a64 3
   _slang_variable_scope_ctr(&self->vars);
   _slang_function_scope_ctr(&self->funs);
   _slang_struct_scope_ctr(&self->structs);
d69 1
a69 1
_slang_code_unit_dtr(slang_code_unit * self)
d71 3
a73 3
   slang_variable_scope_destruct(&self->vars);
   slang_function_scope_destruct(&self->funs);
   slang_struct_scope_destruct(&self->structs);
d81 1
a81 1
_slang_code_object_ctr(slang_code_object * self)
d86 4
a89 4
      _slang_code_unit_ctr(&self->builtin[i], self);
   _slang_code_unit_ctr(&self->unit, self);
   _slang_assembly_file_ctr(&self->assembly);
   slang_machine_ctr(&self->machine);
d91 2
a92 2
   slang_atom_pool_construct(&self->atompool);
   slang_export_data_table_ctr(&self->expdata);
d94 1
a94 1
   slang_export_code_table_ctr(&self->expcode);
d99 1
a99 1
_slang_code_object_dtr(slang_code_object * self)
d104 7
a110 7
      _slang_code_unit_dtr(&self->builtin[i]);
   _slang_code_unit_dtr(&self->unit);
   slang_assembly_file_destruct(&self->assembly);
   slang_machine_dtr(&self->machine);
   slang_atom_pool_destruct(&self->atompool);
   slang_export_data_table_dtr(&self->expdata);
   slang_export_code_table_ctr(&self->expcode);
d117 1
a117 2
void
slang_info_log_construct(slang_info_log * log)
d119 2
a120 2
   log->text = NULL;
   log->dont_free_text = 0;
d123 1
a123 2
void
slang_info_log_destruct(slang_info_log * log)
d125 2
a126 2
   if (!log->dont_free_text)
      slang_alloc_free(log->text);
d129 1
a129 3
static int
slang_info_log_message(slang_info_log * log, const char *prefix,
                       const char *msg)
d133 3
a135 3
   if (log->dont_free_text)
      return 0;
   size = slang_string_length(msg) + 2;
d137 1
a137 1
      size += slang_string_length(prefix) + 2;
d139 2
a140 3
      GLuint old_len = slang_string_length(log->text);
      log->text = (char *)
	 slang_alloc_realloc(log->text, old_len + 1, old_len + size);
d143 1
a143 1
      log->text = (char *) (slang_alloc_malloc(size));
d147 2
a148 2
   if (log->text == NULL)
      return 0;
d150 2
a151 2
      slang_string_concat(log->text, prefix);
      slang_string_concat(log->text, ": ");
d153 3
a155 3
   slang_string_concat(log->text, msg);
   slang_string_concat(log->text, "\n");
   return 1;
d158 1
a158 2
int
slang_info_log_print(slang_info_log * log, const char *msg, ...)
d163 4
a166 4
   va_start(va, msg);
   _mesa_vsprintf(buf, msg, va);
   va_end(va);
   return slang_info_log_message(log, NULL, buf);
d169 1
a169 2
int
slang_info_log_error(slang_info_log * log, const char *msg, ...)
d171 2
a172 2
   va_list va;
   char buf[1024];
d174 7
a180 7
   va_start(va, msg);
   _mesa_vsprintf(buf, msg, va);
   va_end(va);
   if (slang_info_log_message(log, "Error", buf))
      return 1;
   slang_info_log_memory(log);
   return 0;
d183 1
a183 2
int
slang_info_log_warning(slang_info_log * log, const char *msg, ...)
d185 2
a186 2
   va_list va;
   char buf[1024];
d188 7
a194 7
   va_start(va, msg);
   _mesa_vsprintf(buf, msg, va);
   va_end(va);
   if (slang_info_log_message(log, "Warning", buf))
      return 1;
   slang_info_log_memory(log);
   return 0;
d197 7
a203 7
void
slang_info_log_memory(slang_info_log * log)
{
   if (!slang_info_log_message(log, "Error", "Out of memory.")) {
      log->dont_free_text = 1;
      log->text = out_of_memory;
   }
d210 5
a214 5
   const byte *I;
   slang_info_log *L;
   int parsing_builtin;
   GLboolean global_scope;   /**< Is object being declared a global? */
   slang_atom_pool *atoms;
d221 6
a226 6
   slang_variable_scope *vars;
   slang_function_scope *funs;
   slang_struct_scope *structs;
   slang_assembly_file *assembly;
   slang_var_pool *global_pool;
   slang_machine *machine;
d231 1
a231 2
static void
parse_identifier_str(slang_parse_ctx * C, char **id)
d233 2
a234 2
   *id = (char *) C->I;
   C->I += _mesa_strlen(*id) + 1;
d237 55
a291 57
static slang_atom
parse_identifier(slang_parse_ctx * C)
{
   const char *id;

   id = (const char *) C->I;
   C->I += _mesa_strlen(id) + 1;
   return slang_atom_pool_atom(C->atoms, id);
}

static int
parse_number(slang_parse_ctx * C, int *number)
{
   const int radix = (int) (*C->I++);
   *number = 0;
   while (*C->I != '\0') {
      int digit;
      if (*C->I >= '0' && *C->I <= '9')
         digit = (int) (*C->I - '0');
      else if (*C->I >= 'A' && *C->I <= 'Z')
         digit = (int) (*C->I - 'A') + 10;
      else
         digit = (int) (*C->I - 'a') + 10;
      *number = *number * radix + digit;
      C->I++;
   }
   C->I++;
   if (*number > 65535)
      slang_info_log_warning(C->L, "%d: literal integer overflow.", *number);
   return 1;
}

static int
parse_float(slang_parse_ctx * C, float *number)
{
   char *integral = NULL;
   char *fractional = NULL;
   char *exponent = NULL;
   char *whole = NULL;

   parse_identifier_str(C, &integral);
   parse_identifier_str(C, &fractional);
   parse_identifier_str(C, &exponent);

   whole = (char *) (slang_alloc_malloc((_mesa_strlen(integral) +
                                         _mesa_strlen(fractional) +
                                         _mesa_strlen(exponent) + 3) * sizeof(char)));
   if (whole == NULL) {
      slang_info_log_memory(C->L);
      return 0;
   }

   slang_string_copy(whole, integral);
   slang_string_concat(whole, ".");
   slang_string_concat(whole, fractional);
   slang_string_concat(whole, "E");
   slang_string_concat(whole, exponent);
d293 1
a293 1
   *number = (float) (_mesa_strtod(whole, (char **) NULL));
d295 2
a296 2
   slang_alloc_free(whole);
   return 1;
d302 1
a302 44
static int
check_revision(slang_parse_ctx * C)
{
   if (*C->I != REVISION) {
      slang_info_log_error(C->L, "Internal compiler error.");
      return 0;
   }
   C->I++;
   return 1;
}

static int parse_statement(slang_parse_ctx *, slang_output_ctx *,
                           slang_operation *);
static int parse_expression(slang_parse_ctx *, slang_output_ctx *,
                            slang_operation *);
static int parse_type_specifier(slang_parse_ctx *, slang_output_ctx *,
                                slang_type_specifier *);

static GLboolean
parse_array_len(slang_parse_ctx * C, slang_output_ctx * O, GLuint * len)
{
   slang_operation array_size;
   slang_assembly_name_space space;
   GLboolean result;

   if (!slang_operation_construct(&array_size))
      return GL_FALSE;
   if (!parse_expression(C, O, &array_size)) {
      slang_operation_destruct(&array_size);
      return GL_FALSE;
   }

   space.funcs = O->funs;
   space.structs = O->structs;
   space.vars = O->vars;
   result = _slang_evaluate_int(O->assembly, O->machine, &space,
                                &array_size, len, C->atoms);
   slang_operation_destruct(&array_size);
   return result;
}

static GLboolean
calculate_var_size(slang_parse_ctx * C, slang_output_ctx * O,
                   slang_variable * var)
d304 67
a370 30
   slang_storage_aggregate agg;

   if (!slang_storage_aggregate_construct(&agg))
      return GL_FALSE;
   if (!_slang_aggregate_variable(&agg, &var->type.specifier, var->array_len,
                                  O->funs, O->structs, O->vars, O->machine,
                                  O->assembly, C->atoms)) {
      slang_storage_aggregate_destruct(&agg);
      return GL_FALSE;
   }
   var->size = _slang_sizeof_aggregate(&agg);
   slang_storage_aggregate_destruct(&agg);
   return GL_TRUE;
}

static GLboolean
convert_to_array(slang_parse_ctx * C, slang_variable * var,
                 const slang_type_specifier * sp)
{
   /* sized array - mark it as array, copy the specifier to the array element and
    * parse the expression */
   var->type.specifier.type = slang_spec_array;
   var->type.specifier._array = (slang_type_specifier *)
      slang_alloc_malloc(sizeof(slang_type_specifier));
   if (var->type.specifier._array == NULL) {
      slang_info_log_memory(C->L);
      return GL_FALSE;
   }
   slang_type_specifier_ctr(var->type.specifier._array);
   return slang_type_specifier_copy(var->type.specifier._array, sp);
d378 2
a379 3
static GLboolean
parse_struct_field_var(slang_parse_ctx * C, slang_output_ctx * O,
                       slang_variable * var, const slang_type_specifier * sp)
d381 123
a503 18
   var->a_name = parse_identifier(C);
   if (var->a_name == SLANG_ATOM_NULL)
      return GL_FALSE;

   switch (*C->I++) {
   case FIELD_NONE:
      if (!slang_type_specifier_copy(&var->type.specifier, sp))
         return GL_FALSE;
      break;
   case FIELD_ARRAY:
      if (!convert_to_array(C, var, sp))
         return GL_FALSE;
      if (!parse_array_len(C, O, &var->array_len))
         return GL_FALSE;
      break;
   default:
      return GL_FALSE;
   }
d505 1
a505 1
   return calculate_var_size(C, O, var);
a507 96
static int
parse_struct_field(slang_parse_ctx * C, slang_output_ctx * O,
                   slang_struct * st, slang_type_specifier * sp)
{
   slang_output_ctx o = *O;

   o.structs = st->structs;
   if (!parse_type_specifier(C, &o, sp))
      return 0;

   do {
      slang_variable *var = slang_variable_scope_grow(st->fields);
      if (!var) {
         slang_info_log_memory(C->L);
         return 0;
      }
      if (!parse_struct_field_var(C, &o, var, sp))
         return 0;
   }
   while (*C->I++ != FIELD_NONE);

   return 1;
}

static int
parse_struct(slang_parse_ctx * C, slang_output_ctx * O, slang_struct ** st)
{
   slang_atom a_name;
   const char *name;

   /* parse struct name (if any) and make sure it is unique in current scope */
   a_name = parse_identifier(C);
   if (a_name == SLANG_ATOM_NULL)
      return 0;

   name = slang_atom_pool_id(C->atoms, a_name);
   if (name[0] != '\0'
       && slang_struct_scope_find(O->structs, a_name, 0) != NULL) {
      slang_info_log_error(C->L, "%s: duplicate type name.", name);
      return 0;
   }

   /* set-up a new struct */
   *st = (slang_struct *) slang_alloc_malloc(sizeof(slang_struct));
   if (*st == NULL) {
      slang_info_log_memory(C->L);
      return 0;
   }
   if (!slang_struct_construct(*st)) {
      slang_alloc_free(*st);
      *st = NULL;
      slang_info_log_memory(C->L);
      return 0;
   }
   (**st).a_name = a_name;
   (**st).structs->outer_scope = O->structs;

   /* parse individual struct fields */
   do {
      slang_type_specifier sp;

      slang_type_specifier_ctr(&sp);
      if (!parse_struct_field(C, O, *st, &sp)) {
         slang_type_specifier_dtr(&sp);
         return 0;
      }
      slang_type_specifier_dtr(&sp);
   }
   while (*C->I++ != FIELD_NONE);

   /* if named struct, copy it to current scope */
   if (name[0] != '\0') {
      slang_struct *s;

      O->structs->structs =
         (slang_struct *) slang_alloc_realloc(O->structs->structs,
                                              O->structs->num_structs *
                                              sizeof(slang_struct),
                                              (O->structs->num_structs +
                                               1) * sizeof(slang_struct));
      if (O->structs->structs == NULL) {
         slang_info_log_memory(C->L);
         return 0;
      }
      s = &O->structs->structs[O->structs->num_structs];
      if (!slang_struct_construct(s))
         return 0;
      O->structs->num_structs++;
      if (!slang_struct_copy(s, *st))
         return 0;
   }

   return 1;
}


d517 1
a517 2
static int
parse_type_qualifier(slang_parse_ctx * C, slang_type_qualifier * qual)
d519 27
a545 26
   switch (*C->I++) {
   case TYPE_QUALIFIER_NONE:
      *qual = slang_qual_none;
      break;
   case TYPE_QUALIFIER_CONST:
      *qual = slang_qual_const;
      break;
   case TYPE_QUALIFIER_ATTRIBUTE:
      *qual = slang_qual_attribute;
      break;
   case TYPE_QUALIFIER_VARYING:
      *qual = slang_qual_varying;
      break;
   case TYPE_QUALIFIER_UNIFORM:
      *qual = slang_qual_uniform;
      break;
   case TYPE_QUALIFIER_FIXEDOUTPUT:
      *qual = slang_qual_fixedoutput;
      break;
   case TYPE_QUALIFIER_FIXEDINPUT:
      *qual = slang_qual_fixedinput;
      break;
   default:
      return 0;
   }
   return 1;
d574 1
a574 117
static int
parse_type_specifier(slang_parse_ctx * C, slang_output_ctx * O,
                     slang_type_specifier * spec)
{
   switch (*C->I++) {
   case TYPE_SPECIFIER_VOID:
      spec->type = slang_spec_void;
      break;
   case TYPE_SPECIFIER_BOOL:
      spec->type = slang_spec_bool;
      break;
   case TYPE_SPECIFIER_BVEC2:
      spec->type = slang_spec_bvec2;
      break;
   case TYPE_SPECIFIER_BVEC3:
      spec->type = slang_spec_bvec3;
      break;
   case TYPE_SPECIFIER_BVEC4:
      spec->type = slang_spec_bvec4;
      break;
   case TYPE_SPECIFIER_INT:
      spec->type = slang_spec_int;
      break;
   case TYPE_SPECIFIER_IVEC2:
      spec->type = slang_spec_ivec2;
      break;
   case TYPE_SPECIFIER_IVEC3:
      spec->type = slang_spec_ivec3;
      break;
   case TYPE_SPECIFIER_IVEC4:
      spec->type = slang_spec_ivec4;
      break;
   case TYPE_SPECIFIER_FLOAT:
      spec->type = slang_spec_float;
      break;
   case TYPE_SPECIFIER_VEC2:
      spec->type = slang_spec_vec2;
      break;
   case TYPE_SPECIFIER_VEC3:
      spec->type = slang_spec_vec3;
      break;
   case TYPE_SPECIFIER_VEC4:
      spec->type = slang_spec_vec4;
      break;
   case TYPE_SPECIFIER_MAT2:
      spec->type = slang_spec_mat2;
      break;
   case TYPE_SPECIFIER_MAT3:
      spec->type = slang_spec_mat3;
      break;
   case TYPE_SPECIFIER_MAT4:
      spec->type = slang_spec_mat4;
      break;
   case TYPE_SPECIFIER_SAMPLER1D:
      spec->type = slang_spec_sampler1D;
      break;
   case TYPE_SPECIFIER_SAMPLER2D:
      spec->type = slang_spec_sampler2D;
      break;
   case TYPE_SPECIFIER_SAMPLER3D:
      spec->type = slang_spec_sampler3D;
      break;
   case TYPE_SPECIFIER_SAMPLERCUBE:
      spec->type = slang_spec_samplerCube;
      break;
   case TYPE_SPECIFIER_SAMPLER1DSHADOW:
      spec->type = slang_spec_sampler1DShadow;
      break;
   case TYPE_SPECIFIER_SAMPLER2DSHADOW:
      spec->type = slang_spec_sampler2DShadow;
      break;
   case TYPE_SPECIFIER_STRUCT:
      spec->type = slang_spec_struct;
      if (!parse_struct(C, O, &spec->_struct))
         return 0;
      break;
   case TYPE_SPECIFIER_TYPENAME:
      spec->type = slang_spec_struct;
      {
         slang_atom a_name;
         slang_struct *stru;

         a_name = parse_identifier(C);
         if (a_name == NULL)
            return 0;

         stru = slang_struct_scope_find(O->structs, a_name, 1);
         if (stru == NULL) {
            slang_info_log_error(C->L, "%s: undeclared type name.",
                                 slang_atom_pool_id(C->atoms, a_name));
            return 0;
         }

         spec->_struct =
            (slang_struct *) slang_alloc_malloc(sizeof(slang_struct));
         if (spec->_struct == NULL) {
            slang_info_log_memory(C->L);
            return 0;
         }
         if (!slang_struct_construct(spec->_struct)) {
            slang_alloc_free(spec->_struct);
            spec->_struct = NULL;
            return 0;
         }
         if (!slang_struct_copy(spec->_struct, stru))
            return 0;
      }
      break;
   default:
      return 0;
   }
   return 1;
}

static int
parse_fully_specified_type(slang_parse_ctx * C, slang_output_ctx * O,
                           slang_fully_specified_type * type)
d576 119
a694 3
   if (!parse_type_qualifier(C, &type->qualifier))
      return 0;
   return parse_type_specifier(C, O, &type->specifier);
d761 2
a762 197

/**
 * When parsing a compound production, this function is used to parse the
 * children.
 * For example, a a while-loop compound will have two children, the
 * while condition expression and the loop body.  So, this function will
 * be called twice to parse those two sub-expressions.
 * \param C  the parsing context
 * \param O  the output context
 * \param oper  the operation we're parsing
 * \param statment  which child of the operation is being parsed
 * \return 1 if success, 0 if error
 */
static int
parse_child_operation(slang_parse_ctx * C, slang_output_ctx * O,
                      slang_operation * oper, unsigned int statement)
{
   slang_operation *ch;

   /* grow child array */
   oper->children = (slang_operation *)
      slang_alloc_realloc(oper->children,
                          oper->num_children * sizeof(slang_operation),
                          (oper->num_children + 1) * sizeof(slang_operation));
   if (oper->children == NULL) {
      slang_info_log_memory(C->L);
      return 0;
   }

   ch = &oper->children[oper->num_children];
   if (!slang_operation_construct(ch)) {
      slang_info_log_memory(C->L);
      return 0;
   }
   oper->num_children++;
   /* XXX I guess the 0th "statement" is not really a statement? */
   if (statement)
      return parse_statement(C, O, ch);
   return parse_expression(C, O, ch);
}

static int parse_declaration(slang_parse_ctx * C, slang_output_ctx * O);

static int
parse_statement(slang_parse_ctx * C, slang_output_ctx * O,
                slang_operation * oper)
{
   oper->locals->outer_scope = O->vars;
   switch (*C->I++) {
   case OP_BLOCK_BEGIN_NO_NEW_SCOPE:
      /* parse child statements, do not create new variable scope */
      oper->type = slang_oper_block_no_new_scope;
      while (*C->I != OP_END)
         if (!parse_child_operation(C, O, oper, 1))
            return 0;
      C->I++;
      break;
   case OP_BLOCK_BEGIN_NEW_SCOPE:
      /* parse child statements, create new variable scope */
      {
         slang_output_ctx o = *O;

         oper->type = slang_oper_block_new_scope;
         o.vars = oper->locals;
         while (*C->I != OP_END)
            if (!parse_child_operation(C, &o, oper, 1))
               return 0;
         C->I++;
      }
      break;
   case OP_DECLARE:
      /* local variable declaration, individual declarators are stored as
       * children identifiers
       */
      oper->type = slang_oper_variable_decl;
      {
         const unsigned int first_var = O->vars->num_variables;

         /* parse the declaration, note that there can be zero or more
          * than one declarators
          */
         if (!parse_declaration(C, O))
            return 0;
         if (first_var < O->vars->num_variables) {
            const unsigned int num_vars = O->vars->num_variables - first_var;
            unsigned int i;

            oper->children = (slang_operation *)
               slang_alloc_malloc(num_vars * sizeof(slang_operation));
            if (oper->children == NULL) {
               slang_info_log_memory(C->L);
               return 0;
            }
            for (oper->num_children = 0; oper->num_children < num_vars;
                 oper->num_children++) {
               if (!slang_operation_construct
                   (&oper->children[oper->num_children])) {
                  slang_info_log_memory(C->L);
                  return 0;
               }
            }
            for (i = first_var; i < O->vars->num_variables; i++) {
               slang_operation *o = &oper->children[i - first_var];
               o->type = slang_oper_identifier;
               o->locals->outer_scope = O->vars;
               o->a_id = O->vars->variables[i].a_name;
            }
         }
      }
      break;
   case OP_ASM:
      /* the __asm statement, parse the mnemonic and all its arguments
       * as expressions
       */
      oper->type = slang_oper_asm;
      oper->a_id = parse_identifier(C);
      if (oper->a_id == SLANG_ATOM_NULL)
         return 0;
      while (*C->I != OP_END) {
         if (!parse_child_operation(C, O, oper, 0))
            return 0;
      }
      C->I++;
      break;
   case OP_BREAK:
      oper->type = slang_oper_break;
      break;
   case OP_CONTINUE:
      oper->type = slang_oper_continue;
      break;
   case OP_DISCARD:
      oper->type = slang_oper_discard;
      break;
   case OP_RETURN:
      oper->type = slang_oper_return;
      if (!parse_child_operation(C, O, oper, 0))
         return 0;
      break;
   case OP_EXPRESSION:
      oper->type = slang_oper_expression;
      if (!parse_child_operation(C, O, oper, 0))
         return 0;
      break;
   case OP_IF:
      oper->type = slang_oper_if;
      if (!parse_child_operation(C, O, oper, 0))
         return 0;
      if (!parse_child_operation(C, O, oper, 1))
         return 0;
      if (!parse_child_operation(C, O, oper, 1))
         return 0;
      break;
   case OP_WHILE:
      {
         slang_output_ctx o = *O;

         oper->type = slang_oper_while;
         o.vars = oper->locals;
         if (!parse_child_operation(C, &o, oper, 1))
            return 0;
         if (!parse_child_operation(C, &o, oper, 1))
            return 0;
      }
      break;
   case OP_DO:
      oper->type = slang_oper_do;
      if (!parse_child_operation(C, O, oper, 1))
         return 0;
      if (!parse_child_operation(C, O, oper, 0))
         return 0;
      break;
   case OP_FOR:
      {
         slang_output_ctx o = *O;

         oper->type = slang_oper_for;
         o.vars = oper->locals;
         if (!parse_child_operation(C, &o, oper, 1))
            return 0;
         if (!parse_child_operation(C, &o, oper, 1))
            return 0;
         if (!parse_child_operation(C, &o, oper, 0))
            return 0;
         if (!parse_child_operation(C, &o, oper, 1))
            return 0;
      }
      break;
   default:
      return 0;
   }
   return 1;
}

static int
handle_nary_expression(slang_parse_ctx * C, slang_operation * op,
                       slang_operation ** ops, unsigned int *total_ops,
                       unsigned int n)
d764 1
a764 9
   unsigned int i;

   op->children =
      (slang_operation *) slang_alloc_malloc(n * sizeof(slang_operation));
   if (op->children == NULL) {
      slang_info_log_memory(C->L);
      return 0;
   }
   op->num_children = n;
d766 448
a1213 273
   for (i = 0; i < n; i++)
      op->children[i] = (*ops)[*total_ops - (n + 1 - i)];
   (*ops)[*total_ops - (n + 1)] = (*ops)[*total_ops - 1];
   *total_ops -= n;

   *ops = (slang_operation *)
      slang_alloc_realloc(*ops,
                          (*total_ops + n) * sizeof(slang_operation),
                          *total_ops * sizeof(slang_operation));
   if (*ops == NULL) {
      slang_info_log_memory(C->L);
      return 0;
   }
   return 1;
}

static int
is_constructor_name(const char *name, slang_atom a_name,
                    slang_struct_scope * structs)
{
   if (slang_type_specifier_type_from_string(name) != slang_spec_void)
      return 1;
   return slang_struct_scope_find(structs, a_name, 1) != NULL;
}

static int
parse_expression(slang_parse_ctx * C, slang_output_ctx * O,
                 slang_operation * oper)
{
   slang_operation *ops = NULL;
   unsigned int num_ops = 0;
   int number;

   while (*C->I != OP_END) {
      slang_operation *op;
      const unsigned int op_code = *C->I++;

      /* allocate default operation, becomes a no-op if not used  */
      ops = (slang_operation *)
         slang_alloc_realloc(ops,
                             num_ops * sizeof(slang_operation),
                             (num_ops + 1) * sizeof(slang_operation));
      if (ops == NULL) {
         slang_info_log_memory(C->L);
         return 0;
      }
      op = &ops[num_ops];
      if (!slang_operation_construct(op)) {
         slang_info_log_memory(C->L);
         return 0;
      }
      num_ops++;
      op->locals->outer_scope = O->vars;

      switch (op_code) {
      case OP_PUSH_VOID:
         op->type = slang_oper_void;
         break;
      case OP_PUSH_BOOL:
         op->type = slang_oper_literal_bool;
         if (!parse_number(C, &number))
            return 0;
         op->literal = (GLfloat) number;
         break;
      case OP_PUSH_INT:
         op->type = slang_oper_literal_int;
         if (!parse_number(C, &number))
            return 0;
         op->literal = (GLfloat) number;
         break;
      case OP_PUSH_FLOAT:
         op->type = slang_oper_literal_float;
         if (!parse_float(C, &op->literal))
            return 0;
         break;
      case OP_PUSH_IDENTIFIER:
         op->type = slang_oper_identifier;
         op->a_id = parse_identifier(C);
         if (op->a_id == SLANG_ATOM_NULL)
            return 0;
         break;
      case OP_SEQUENCE:
         op->type = slang_oper_sequence;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_ASSIGN:
         op->type = slang_oper_assign;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_ADDASSIGN:
         op->type = slang_oper_addassign;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_SUBASSIGN:
         op->type = slang_oper_subassign;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_MULASSIGN:
         op->type = slang_oper_mulassign;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_DIVASSIGN:
         op->type = slang_oper_divassign;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
         /*case OP_MODASSIGN: */
         /*case OP_LSHASSIGN: */
         /*case OP_RSHASSIGN: */
         /*case OP_ORASSIGN: */
         /*case OP_XORASSIGN: */
         /*case OP_ANDASSIGN: */
      case OP_SELECT:
         op->type = slang_oper_select;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 3))
            return 0;
         break;
      case OP_LOGICALOR:
         op->type = slang_oper_logicalor;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_LOGICALXOR:
         op->type = slang_oper_logicalxor;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_LOGICALAND:
         op->type = slang_oper_logicaland;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
         /*case OP_BITOR: */
         /*case OP_BITXOR: */
         /*case OP_BITAND: */
      case OP_EQUAL:
         op->type = slang_oper_equal;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_NOTEQUAL:
         op->type = slang_oper_notequal;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_LESS:
         op->type = slang_oper_less;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_GREATER:
         op->type = slang_oper_greater;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_LESSEQUAL:
         op->type = slang_oper_lessequal;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_GREATEREQUAL:
         op->type = slang_oper_greaterequal;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
         /*case OP_LSHIFT: */
         /*case OP_RSHIFT: */
      case OP_ADD:
         op->type = slang_oper_add;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_SUBTRACT:
         op->type = slang_oper_subtract;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_MULTIPLY:
         op->type = slang_oper_multiply;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_DIVIDE:
         op->type = slang_oper_divide;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
         /*case OP_MODULUS: */
      case OP_PREINCREMENT:
         op->type = slang_oper_preincrement;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            return 0;
         break;
      case OP_PREDECREMENT:
         op->type = slang_oper_predecrement;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            return 0;
         break;
      case OP_PLUS:
         op->type = slang_oper_plus;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            return 0;
         break;
      case OP_MINUS:
         op->type = slang_oper_minus;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            return 0;
         break;
      case OP_NOT:
         op->type = slang_oper_not;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            return 0;
         break;
         /*case OP_COMPLEMENT: */
      case OP_SUBSCRIPT:
         op->type = slang_oper_subscript;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 2))
            return 0;
         break;
      case OP_CALL:
         op->type = slang_oper_call;
         op->a_id = parse_identifier(C);
         if (op->a_id == SLANG_ATOM_NULL)
            return 0;
         while (*C->I != OP_END)
            if (!parse_child_operation(C, O, op, 0))
               return 0;
         C->I++;

         if (!C->parsing_builtin
             && !slang_function_scope_find_by_name(O->funs, op->a_id, 1)) {
            const char *id;

            id = slang_atom_pool_id(C->atoms, op->a_id);
            if (!is_constructor_name(id, op->a_id, O->structs)) {
               slang_info_log_error(C->L, "%s: undeclared function name.", id);
               return 0;
            }
         }
         break;
      case OP_FIELD:
         op->type = slang_oper_field;
         op->a_id = parse_identifier(C);
         if (op->a_id == SLANG_ATOM_NULL)
            return 0;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            return 0;
         break;
      case OP_POSTINCREMENT:
         op->type = slang_oper_postincrement;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            return 0;
         break;
      case OP_POSTDECREMENT:
         op->type = slang_oper_postdecrement;
         if (!handle_nary_expression(C, op, &ops, &num_ops, 1))
            return 0;
         break;
      default:
         return 0;
      }
   }
   C->I++;

   *oper = *ops;
   slang_alloc_free(ops);

   return 1;
d1225 69
a1293 36
static int
parse_parameter_declaration(slang_parse_ctx * C, slang_output_ctx * O,
                            slang_variable * param)
{
   /* parse and validate the parameter's type qualifiers (there can be
    * two at most) because not all combinations are valid
    */
   if (!parse_type_qualifier(C, &param->type.qualifier))
      return 0;
   switch (*C->I++) {
   case PARAM_QUALIFIER_IN:
      if (param->type.qualifier != slang_qual_const
          && param->type.qualifier != slang_qual_none) {
         slang_info_log_error(C->L, "Invalid type qualifier.");
         return 0;
      }
      break;
   case PARAM_QUALIFIER_OUT:
      if (param->type.qualifier == slang_qual_none)
         param->type.qualifier = slang_qual_out;
      else {
         slang_info_log_error(C->L, "Invalid type qualifier.");
         return 0;
      }
      break;
   case PARAM_QUALIFIER_INOUT:
      if (param->type.qualifier == slang_qual_none)
         param->type.qualifier = slang_qual_inout;
      else {
         slang_info_log_error(C->L, "Invalid type qualifier.");
         return 0;
      }
      break;
   default:
      return 0;
   }
d1295 2
a1296 33
   /* parse parameter's type specifier and name */
   if (!parse_type_specifier(C, O, &param->type.specifier))
      return 0;
   param->a_name = parse_identifier(C);
   if (param->a_name == SLANG_ATOM_NULL)
      return 0;

   /* if the parameter is an array, parse its size (the size must be
    * explicitly defined
    */
   if (*C->I++ == PARAMETER_ARRAY_PRESENT) {
      slang_type_specifier p;

      slang_type_specifier_ctr(&p);
      if (!slang_type_specifier_copy(&p, &param->type.specifier)) {
         slang_type_specifier_dtr(&p);
         return GL_FALSE;
      }
      if (!convert_to_array(C, param, &p)) {
         slang_type_specifier_dtr(&p);
         return GL_FALSE;
      }
      slang_type_specifier_dtr(&p);
      if (!parse_array_len(C, O, &param->array_len))
         return GL_FALSE;
   }

   /* calculate the parameter size */
   if (!calculate_var_size(C, O, param))
      return GL_FALSE;

   /* TODO: allocate the local address here? */
   return 1;
d1339 3
a1341 4
static const struct
{
   unsigned int o_code;
   const char *o_name;
d1343 29
a1371 29
   {OPERATOR_INCREMENT, "++"},
   {OPERATOR_ADDASSIGN, "+="},
   {OPERATOR_PLUS, "+"},
   {OPERATOR_DECREMENT, "--"},
   {OPERATOR_SUBASSIGN, "-="},
   {OPERATOR_MINUS, "-"},
   {OPERATOR_NOT, "!"},
   {OPERATOR_MULASSIGN, "*="},
   {OPERATOR_MULTIPLY, "*"},
   {OPERATOR_DIVASSIGN, "/="},
   {OPERATOR_DIVIDE, "/"},
   {OPERATOR_LESSEQUAL, "<="},
   /*{ OPERATOR_LSHASSIGN, "<<=" }, */
   /*{ OPERATOR_LSHIFT, "<<" }, */
   {OPERATOR_LESS, "<"},
   {OPERATOR_GREATEREQUAL, ">="},
   /*{ OPERATOR_RSHASSIGN, ">>=" }, */
   /*{ OPERATOR_RSHIFT, ">>" }, */
   {OPERATOR_GREATER, ">"},
   /*{ OPERATOR_MODASSIGN, "%=" }, */
   /*{ OPERATOR_MODULUS, "%" }, */
   /*{ OPERATOR_ANDASSIGN, "&=" }, */
   /*{ OPERATOR_BITAND, "&" }, */
   /*{ OPERATOR_ORASSIGN, "|=" }, */
   /*{ OPERATOR_BITOR, "|" }, */
   /*{ OPERATOR_COMPLEMENT, "~" }, */
   /*{ OPERATOR_XORASSIGN, "^=" }, */
   {OPERATOR_LOGICALXOR, "^^"},
   /*{ OPERATOR_BITXOR, "^" } */
d1374 1
a1374 116
static slang_atom
parse_operator_name(slang_parse_ctx * C)
{
   unsigned int i;

   for (i = 0; i < sizeof(operator_names) / sizeof(*operator_names); i++) {
      if (operator_names[i].o_code == (unsigned int) (*C->I)) {
         slang_atom atom =
            slang_atom_pool_atom(C->atoms, operator_names[i].o_name);
         if (atom == SLANG_ATOM_NULL) {
            slang_info_log_memory(C->L);
            return 0;
         }
         C->I++;
         return atom;
      }
   }
   return 0;
}

static int
parse_function_prototype(slang_parse_ctx * C, slang_output_ctx * O,
                         slang_function * func)
{
   /* parse function type and name */
   if (!parse_fully_specified_type(C, O, &func->header.type))
      return 0;
   switch (*C->I++) {
   case FUNCTION_ORDINARY:
      func->kind = slang_func_ordinary;
      func->header.a_name = parse_identifier(C);
      if (func->header.a_name == SLANG_ATOM_NULL)
         return 0;
      break;
   case FUNCTION_CONSTRUCTOR:
      func->kind = slang_func_constructor;
      if (func->header.type.specifier.type == slang_spec_struct)
         return 0;
      func->header.a_name =
         slang_atom_pool_atom(C->atoms,
                              slang_type_specifier_type_to_string
                              (func->header.type.specifier.type));
      if (func->header.a_name == SLANG_ATOM_NULL) {
         slang_info_log_memory(C->L);
         return 0;
      }
      break;
   case FUNCTION_OPERATOR:
      func->kind = slang_func_operator;
      func->header.a_name = parse_operator_name(C);
      if (func->header.a_name == SLANG_ATOM_NULL)
         return 0;
      break;
   default:
      return 0;
   }

   /* parse function parameters */
   while (*C->I++ == PARAMETER_NEXT) {
      slang_variable *p = slang_variable_scope_grow(func->parameters);
      if (!p) {
         slang_info_log_memory(C->L);
         return 0;
      }
      if (!parse_parameter_declaration(C, O, p))
         return 0;
   }

   /* function formal parameters and local variables share the same
    * scope, so save the information about param count in a seperate
    * place also link the scope to the global variable scope so when a
    * given identifier is not found here, the search process continues
    * in the global space
    */
   func->param_count = func->parameters->num_variables;
   func->parameters->outer_scope = O->vars;
   return 1;
}

static int
parse_function_definition(slang_parse_ctx * C, slang_output_ctx * O,
                          slang_function * func)
{
   slang_output_ctx o = *O;

   if (!parse_function_prototype(C, O, func))
      return 0;

   /* create function's body operation */
   func->body =
      (slang_operation *) slang_alloc_malloc(sizeof(slang_operation));
   if (func->body == NULL) {
      slang_info_log_memory(C->L);
      return 0;
   }
   if (!slang_operation_construct(func->body)) {
      slang_alloc_free(func->body);
      func->body = NULL;
      slang_info_log_memory(C->L);
      return 0;
   }

   /* to parse the body the parse context is modified in order to
    * capture parsed variables into function's local variable scope
    */
   C->global_scope = GL_FALSE;
   o.vars = func->parameters;
   if (!parse_statement(C, &o, func->body))
      return 0;

   C->global_scope = GL_TRUE;
   return 1;
}

static GLboolean
initialize_global(slang_assemble_ctx * A, slang_variable * var)
d1376 1
a1376 73
   slang_assembly_file_restore_point point;
   slang_machine mach;
   slang_assembly_local_info save_local = A->local;
   slang_operation op_id, op_assign;
   GLboolean result;

   /* save the current assembly */
   if (!slang_assembly_file_restore_point_save(A->file, &point))
      return GL_FALSE;

   /* setup the machine */
   mach = *A->mach;
   mach.ip = A->file->count;

   /* allocate local storage for expression */
   A->local.ret_size = 0;
   A->local.addr_tmp = 0;
   A->local.swizzle_tmp = 4;
   if (!slang_assembly_file_push_label(A->file, slang_asm_local_alloc, 20))
      return GL_FALSE;
   if (!slang_assembly_file_push_label(A->file, slang_asm_enter, 20))
      return GL_FALSE;

   /* construct the left side of assignment */
   if (!slang_operation_construct(&op_id))
      return GL_FALSE;
   op_id.type = slang_oper_identifier;
   op_id.a_id = var->a_name;

   /* put the variable into operation's scope */
   op_id.locals->variables =
      (slang_variable *) slang_alloc_malloc(sizeof(slang_variable));
   if (op_id.locals->variables == NULL) {
      slang_operation_destruct(&op_id);
      return GL_FALSE;
   }
   op_id.locals->num_variables = 1;
   op_id.locals->variables[0] = *var;

   /* construct the assignment expression */
   if (!slang_operation_construct(&op_assign)) {
      op_id.locals->num_variables = 0;
      slang_operation_destruct(&op_id);
      return GL_FALSE;
   }
   op_assign.type = slang_oper_assign;
   op_assign.children =
      (slang_operation *) slang_alloc_malloc(2 * sizeof(slang_operation));
   if (op_assign.children == NULL) {
      slang_operation_destruct(&op_assign);
      op_id.locals->num_variables = 0;
      slang_operation_destruct(&op_id);
      return GL_FALSE;
   }
   op_assign.num_children = 2;
   op_assign.children[0] = op_id;
   op_assign.children[1] = *var->initializer;

   /* insert the actual expression */
   result = _slang_assemble_operation(A, &op_assign, slang_ref_forbid);

   /* carefully destroy the operations */
   op_assign.num_children = 0;
   slang_alloc_free(op_assign.children);
   op_assign.children = NULL;
   slang_operation_destruct(&op_assign);
   op_id.locals->num_variables = 0;
   slang_operation_destruct(&op_id);

   if (!result)
      return GL_FALSE;
   if (!slang_assembly_file_push(A->file, slang_asm_exit))
      return GL_FALSE;
d1378 204
a1581 8
   /* execute the expression */
   if (!_slang_execute2(A->file, &mach))
      return GL_FALSE;

   /* restore the old assembly */
   if (!slang_assembly_file_restore_point_load(A->file, &point))
      return GL_FALSE;
   A->local = save_local;
d1583 1
a1583 5
   /* now we copy the contents of the initialized variable back to the original machine */
   _mesa_memcpy((GLubyte *) A->mach->mem + var->address,
                (GLubyte *) mach.mem + var->address, var->size);

   return GL_TRUE;
d1597 4
d1602 52
a1653 52
/**
 * Parse the initializer for a variable declaration.
 */
static int
parse_init_declarator(slang_parse_ctx * C, slang_output_ctx * O,
                      const slang_fully_specified_type * type)
{
   slang_variable *var;

   /* empty init declatator (without name, e.g. "float ;") */
   if (*C->I++ == VARIABLE_NONE)
      return 1;

   /* make room for the new variable and initialize it */
   var = slang_variable_scope_grow(O->vars);
   if (!var) {
      slang_info_log_memory(C->L);
      return 0;
   }

   /* copy the declarator qualifier type, parse the identifier */
   var->global = C->global_scope;
   var->type.qualifier = type->qualifier;
   var->a_name = parse_identifier(C);
   if (var->a_name == SLANG_ATOM_NULL)
      return 0;

   switch (*C->I++) {
   case VARIABLE_NONE:
      /* simple variable declarator - just copy the specifier */
      if (!slang_type_specifier_copy(&var->type.specifier, &type->specifier))
         return 0;
      break;
   case VARIABLE_INITIALIZER:
      /* initialized variable - copy the specifier and parse the expression */
      if (!slang_type_specifier_copy(&var->type.specifier, &type->specifier))
         return 0;
      var->initializer =
         (slang_operation *) slang_alloc_malloc(sizeof(slang_operation));
      if (var->initializer == NULL) {
         slang_info_log_memory(C->L);
         return 0;
      }
      if (!slang_operation_construct(var->initializer)) {
         slang_alloc_free(var->initializer);
         var->initializer = NULL;
         slang_info_log_memory(C->L);
         return 0;
      }
      if (!parse_expression(C, O, var->initializer))
         return 0;
      break;
d1655 5
a1659 7
   case VARIABLE_ARRAY_UNKNOWN:
      /* unsized array - mark it as array and copy the specifier to
         the array element
      */
      if (!convert_to_array(C, var, &type->specifier))
         return GL_FALSE;
      break;
d1661 17
a1677 9
   case VARIABLE_ARRAY_EXPLICIT:
      if (!convert_to_array(C, var, &type->specifier))
         return GL_FALSE;
      if (!parse_array_len(C, O, &var->array_len))
         return GL_FALSE;
      break;
   default:
      return 0;
   }
d1679 1
a1679 10
   /* allocate global address space for a variable with a known size */
   if (C->global_scope
       && !(var->type.specifier.type == slang_spec_array
            && var->array_len == 0)) {
      if (!calculate_var_size(C, O, var))
         return GL_FALSE;
      var->address = slang_var_pool_alloc(O->global_pool, var->size);
   }

   /* initialize global variable */
d1690 1
a1690 1
         if (!initialize_global(&A, var))
d1694 1
a1694 2
         _mesa_memset((GLubyte *) (O->machine->mem) + var->address, 0,
                      var->size);
d1696 2
a1697 2
   }
   return 1;
d1700 1
a1700 6
/**
 * Parse a list of variable declarations.  Each variable may have an
 * initializer.
 */
static int
parse_init_declarator_list(slang_parse_ctx * C, slang_output_ctx * O)
d1702 116
a1817 121
   slang_fully_specified_type type;

   /* parse the fully specified type, common to all declarators */
   if (!slang_fully_specified_type_construct(&type))
      return 0;
   if (!parse_fully_specified_type(C, O, &type)) {
      slang_fully_specified_type_destruct(&type);
      return 0;
   }

   /* parse declarators, pass-in the parsed type */
   do {
      if (!parse_init_declarator(C, O, &type)) {
         slang_fully_specified_type_destruct(&type);
         return 0;
      }
   }
   while (*C->I++ == DECLARATOR_NEXT);

   slang_fully_specified_type_destruct(&type);
   return 1;
}


/**
 * Parse a function definition or declaration.
 * \param C  parsing context
 * \param O  output context
 * \param definition if non-zero expect a definition, else a declaration
 * \param parsed_func_ret  returns the parsed function
 * \return 1 if success, 0 if failure
 */
static int
parse_function(slang_parse_ctx * C, slang_output_ctx * O, int definition,
               slang_function ** parsed_func_ret)
{
   slang_function parsed_func, *found_func;

   /* parse function definition/declaration */
   if (!slang_function_construct(&parsed_func))
      return 0;
   if (definition) {
      if (!parse_function_definition(C, O, &parsed_func)) {
         slang_function_destruct(&parsed_func);
         return 0;
      }
   }
   else {
      if (!parse_function_prototype(C, O, &parsed_func)) {
         slang_function_destruct(&parsed_func);
         return 0;
      }
   }

   /* find a function with a prototype matching the parsed one - only
    * the current scope is being searched to allow built-in function
    * overriding
    */
   found_func = slang_function_scope_find(O->funs, &parsed_func, 0);
   if (found_func == NULL) {
      /* add the parsed function to the function list */
      O->funs->functions =
         (slang_function *) slang_alloc_realloc(O->funs->functions,
                                                O->funs->num_functions *
                                                sizeof(slang_function),
                                                (O->funs->num_functions +
                                                 1) * sizeof(slang_function));
      if (O->funs->functions == NULL) {
         slang_info_log_memory(C->L);
         slang_function_destruct(&parsed_func);
         return 0;
      }
      O->funs->functions[O->funs->num_functions] = parsed_func;
      O->funs->num_functions++;

      /* return the newly parsed function */
      *parsed_func_ret = &O->funs->functions[O->funs->num_functions - 1];
   }
   else {
      /* TODO: check function return type qualifiers and specifiers */
      if (definition) {
         if (found_func->body != NULL) {
            slang_info_log_error(C->L, "%s: function already has a body.",
                                 slang_atom_pool_id(C->atoms,
                                                    parsed_func.header.
                                                    a_name));
            slang_function_destruct(&parsed_func);
            return 0;
         }

         /* destroy the existing function declaration and replace it
          * with the new one, remember to save the fixup table
          */
         parsed_func.fixups = found_func->fixups;
         slang_fixup_table_init(&found_func->fixups);
         slang_function_destruct(found_func);
         *found_func = parsed_func;
      }
      else {
         /* another declaration of the same function prototype - ignore it */
         slang_function_destruct(&parsed_func);
      }

      /* return the found function */
      *parsed_func_ret = found_func;
   }

   /* assemble the parsed function */
   {
      slang_assemble_ctx A;

      A.file = O->assembly;
      A.mach = O->machine;
      A.atoms = C->atoms;
      A.space.funcs = O->funs;
      A.space.structs = O->structs;
      A.space.vars = O->vars;
      if (!_slang_assemble_function(&A, *parsed_func_ret))
         return 0;
   }
   return 1;
d1824 1
a1824 2
static int
parse_declaration(slang_parse_ctx * C, slang_output_ctx * O)
d1826 18
a1843 17
   switch (*C->I++) {
   case DECLARATION_INIT_DECLARATOR_LIST:
      if (!parse_init_declarator_list(C, O))
         return 0;
      break;
   case DECLARATION_FUNCTION_PROTOTYPE:
      {
         slang_function *dummy_func;

         if (!parse_function(C, O, 0, &dummy_func))
            return 0;
      }
      break;
   default:
      return 0;
   }
   return 1;
d1852 1
a1852 1
parse_code_unit(slang_parse_ctx * C, slang_code_unit * unit)
d1854 1
a1854 1
   slang_output_ctx o;
d1864 23
a1886 21
   /* parse individual functions and declarations */
   while (*C->I != EXTERNAL_NULL) {
      switch (*C->I++) {
      case EXTERNAL_FUNCTION_DEFINITION:
         {
            slang_function *func;

            if (!parse_function(C, &o, 1, &func))
               return 0;
         }
         break;
      case EXTERNAL_DECLARATION:
         if (!parse_declaration(C, &o))
            return 0;
         break;
      default:
         return 0;
      }
   }
   C->I++;
   return 1;
d1890 2
a1891 3
compile_binary(const byte * prod, slang_code_unit * unit,
               slang_unit_type type, slang_info_log * infolog,
               slang_code_unit * builtin, slang_code_unit * downlink)
d1904 1
a1904 1
   if (!check_revision(&C))
d1914 1
a1914 1
   return parse_code_unit(&C, unit);
d1918 2
a1919 3
compile_with_grammar(grammar id, const char *source, slang_code_unit * unit,
                     slang_unit_type type, slang_info_log * infolog,
                     slang_code_unit * builtin)
d1921 1
a1921 1
   byte *prod;
a1922 1
   slang_string preprocessed;
d1924 2
a1925 2
   /* First retrieve the version number. */
   if (!_slang_preprocess_version(source, &version, &start, infolog))
d1929 1
a1929 2
      slang_info_log_error(infolog,
                           "language version specified is not supported.");
d1933 7
a1939 5
   /* Now preprocess the source string. */
   slang_string_init(&preprocessed);
   if (!_slang_preprocess_directives(&preprocessed, &source[start], infolog)) {
      slang_string_free(&preprocessed);
      slang_info_log_error(infolog, "failed to preprocess the source.");
d1941 1
a1941 1
   }
d1943 3
a1945 10
   /* Finally check the syntax and generate its binary representation. */
   if (!grammar_fast_check
       (id, (const byte *) (slang_string_cstr(&preprocessed)), &prod, &size,
        65536)) {
      char buf[1024];
      GLint pos;

      slang_string_free(&preprocessed);
      grammar_get_last_error((byte *) (buf), sizeof(buf), &pos);
      slang_info_log_error(infolog, buf);
a1947 1
   slang_string_free(&preprocessed);
d1949 1
a1949 8
   /* Syntax is okay - translate it to internal representation. */
   if (!compile_binary
       (prod, unit, type, infolog, builtin,
        &builtin[SLANG_BUILTIN_TOTAL - 1])) {
      grammar_alloc_free(prod);
      return GL_FALSE;
   }
   grammar_alloc_free(prod);
d1953 1
a1953 1
LONGSTRING static const char *slang_shader_syn =
d1955 1
a1955 1
   ;
d1980 2
a1981 2
compile_object(grammar * id, const char *source, slang_code_object * object,
               slang_unit_type type, slang_info_log * infolog)
d1986 26
a2011 25
   *id = grammar_load_from_text((const byte *) (slang_shader_syn));
   if (*id == 0) {
      byte buf[1024];
      int pos;

      grammar_get_last_error(buf, 1024, &pos);
      slang_info_log_error(infolog, (const char *) (buf));
      return GL_FALSE;
   }

   /* set shader type - the syntax is slightly different for different shaders */
   if (type == slang_unit_fragment_shader
       || type == slang_unit_fragment_builtin)
      grammar_set_reg8(*id, (const byte *) "shader_type", 1);
   else
      grammar_set_reg8(*id, (const byte *) "shader_type", 2);

   /* enable language extensions */
   grammar_set_reg8(*id, (const byte *) "parsing_builtin", 1);

   /* if parsing user-specified shader, load built-in library */
   if (type == slang_unit_fragment_shader || type == slang_unit_vertex_shader) {
      /* compile core functionality first */
      if (!compile_binary(slang_core_gc, &object->builtin[SLANG_BUILTIN_CORE],
                          slang_unit_fragment_builtin, infolog, NULL, NULL))
d2014 4
a2017 5
      /* compile common functions and variables, link to core */
      if (!compile_binary
          (slang_common_builtin_gc, &object->builtin[SLANG_BUILTIN_COMMON],
           slang_unit_fragment_builtin, infolog, NULL,
           &object->builtin[SLANG_BUILTIN_CORE]))
d2020 6
a2025 7
      /* compile target-specific functions and variables, link to common */
      if (type == slang_unit_fragment_shader) {
         if (!compile_binary
             (slang_fragment_builtin_gc,
              &object->builtin[SLANG_BUILTIN_TARGET],
              slang_unit_fragment_builtin, infolog, NULL,
              &object->builtin[SLANG_BUILTIN_COMMON]))
d2027 6
a2032 6
      }
      else if (type == slang_unit_vertex_shader) {
         if (!compile_binary
             (slang_vertex_builtin_gc, &object->builtin[SLANG_BUILTIN_TARGET],
              slang_unit_vertex_builtin, infolog, NULL,
              &object->builtin[SLANG_BUILTIN_COMMON]))
d2034 1
a2034 1
      }
d2038 3
a2040 4
      if (!compile_binary
          (slang_builtin_vec4_gc, &object->builtin[SLANG_BUILTIN_VEC4],
           slang_unit_fragment_builtin, infolog, NULL,
           &object->builtin[SLANG_BUILTIN_TARGET]))
d2044 2
a2045 2
      /* disable language extensions */
      grammar_set_reg8(*id, (const byte *) "parsing_builtin", 0);
d2047 1
a2047 1
   }
d2049 2
a2050 3
   /* compile the actual shader - pass-in built-in library for external shader */
   return compile_with_grammar(*id, source, &object->unit, type, infolog,
                               builtins);
d2054 2
a2055 2
_slang_compile(const char *source, slang_code_object * object,
               slang_unit_type type, slang_info_log * infolog)
d2060 2
a2061 2
   _slang_code_object_dtr(object);
   _slang_code_object_ctr(object);
d2063 1
a2063 1
   success = compile_object(&id, source, object, type, infolog);
d2065 1
a2065 1
      grammar_destroy(id);
d2069 1
a2069 1
   if (!_slang_build_export_data_table(&object->expdata, &object->unit.vars))
d2071 1
a2071 2
   if (!_slang_build_export_code_table
       (&object->expcode, &object->unit.funs, &object->unit))
d2076 1
a2076 3
   if (!_slang_x86_codegen
       (&object->machine, &object->assembly,
        object->expcode.entries[0].address))
d2082 1
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@a31 3
#include "context.h"
#include "program.h"
#include "prog_parameter.h"
a32 1
#include "slang_codegen.h"
a35 7
#include "slang_emit.h"
#include "slang_log.h"
#include "slang_mem.h"
#include "slang_vartable.h"
#include "slang_simplify.h"

#include "slang_print.h"
d93 2
d97 4
d111 2
d114 64
d180 38
a227 1
   slang_unit_type type;     /**< Vertex vs. Fragment */
d237 1
d239 1
a239 2
   struct gl_program *program;
   slang_var_table *vartable;
d295 3
a297 3
   whole = (char *) _slang_alloc((_mesa_strlen(integral) +
                                  _mesa_strlen(fractional) +
                                  _mesa_strlen(exponent) + 3) * sizeof(char));
d311 1
a311 2
   _slang_free(whole);

d340 1
a340 1
   slang_name_space space;
d353 2
a354 7

   /* evaluate compile-time expression which is array size */
   _slang_simplify(&array_size, &space, C->atoms);
   result = (array_size.type == SLANG_OPER_LITERAL_INT);

   *len = (GLint) array_size.literal[0];

d368 2
a369 1
                                  O->funs, O->structs, O->vars, C->atoms)) {
d384 1
a384 1
   var->type.specifier.type = SLANG_SPEC_ARRAY;
d386 1
a386 1
      _slang_alloc(sizeof(slang_type_specifier));
d469 1
a469 1
   *st = (slang_struct *) _slang_alloc(sizeof(slang_struct));
d475 1
a475 1
      _slang_free(*st);
d501 5
a505 5
         (slang_struct *) _slang_realloc(O->structs->structs,
                                         O->structs->num_structs
                                         * sizeof(slang_struct),
                                         (O->structs->num_structs + 1)
                                         * sizeof(slang_struct));
d536 1
a536 1
      *qual = SLANG_QUAL_NONE;
d539 1
a539 1
      *qual = SLANG_QUAL_CONST;
d542 1
a542 1
      *qual = SLANG_QUAL_ATTRIBUTE;
d545 1
a545 1
      *qual = SLANG_QUAL_VARYING;
d548 1
a548 1
      *qual = SLANG_QUAL_UNIFORM;
d551 1
a551 1
      *qual = SLANG_QUAL_FIXEDOUTPUT;
d554 1
a554 1
      *qual = SLANG_QUAL_FIXEDINPUT;
d585 2
a586 11
#define TYPE_SPECIFIER_SAMPLER2DRECT 22
#define TYPE_SPECIFIER_SAMPLER2DRECTSHADOW 23
#define TYPE_SPECIFIER_STRUCT 24
#define TYPE_SPECIFIER_TYPENAME 25
#define TYPE_SPECIFIER_MAT23 26
#define TYPE_SPECIFIER_MAT32 27
#define TYPE_SPECIFIER_MAT24 28
#define TYPE_SPECIFIER_MAT42 29
#define TYPE_SPECIFIER_MAT34 30
#define TYPE_SPECIFIER_MAT43 31

d594 1
a594 1
      spec->type = SLANG_SPEC_VOID;
d597 1
a597 1
      spec->type = SLANG_SPEC_BOOL;
d600 1
a600 1
      spec->type = SLANG_SPEC_BVEC2;
d603 1
a603 1
      spec->type = SLANG_SPEC_BVEC3;
d606 1
a606 1
      spec->type = SLANG_SPEC_BVEC4;
d609 1
a609 1
      spec->type = SLANG_SPEC_INT;
d612 1
a612 1
      spec->type = SLANG_SPEC_IVEC2;
d615 1
a615 1
      spec->type = SLANG_SPEC_IVEC3;
d618 1
a618 1
      spec->type = SLANG_SPEC_IVEC4;
d621 1
a621 1
      spec->type = SLANG_SPEC_FLOAT;
d624 1
a624 1
      spec->type = SLANG_SPEC_VEC2;
d627 1
a627 1
      spec->type = SLANG_SPEC_VEC3;
d630 1
a630 1
      spec->type = SLANG_SPEC_VEC4;
d633 1
a633 1
      spec->type = SLANG_SPEC_MAT2;
d636 1
a636 1
      spec->type = SLANG_SPEC_MAT3;
d639 1
a639 19
      spec->type = SLANG_SPEC_MAT4;
      break;
   case TYPE_SPECIFIER_MAT23:
      spec->type = SLANG_SPEC_MAT23;
      break;
   case TYPE_SPECIFIER_MAT32:
      spec->type = SLANG_SPEC_MAT32;
      break;
   case TYPE_SPECIFIER_MAT24:
      spec->type = SLANG_SPEC_MAT24;
      break;
   case TYPE_SPECIFIER_MAT42:
      spec->type = SLANG_SPEC_MAT42;
      break;
   case TYPE_SPECIFIER_MAT34:
      spec->type = SLANG_SPEC_MAT34;
      break;
   case TYPE_SPECIFIER_MAT43:
      spec->type = SLANG_SPEC_MAT43;
d642 1
a642 1
      spec->type = SLANG_SPEC_SAMPLER1D;
d645 1
a645 1
      spec->type = SLANG_SPEC_SAMPLER2D;
d648 1
a648 1
      spec->type = SLANG_SPEC_SAMPLER3D;
d651 1
a651 4
      spec->type = SLANG_SPEC_SAMPLERCUBE;
      break;
   case TYPE_SPECIFIER_SAMPLER2DRECT:
      spec->type = SLANG_SPEC_SAMPLER2DRECT;
d654 1
a654 1
      spec->type = SLANG_SPEC_SAMPLER1DSHADOW;
d657 1
a657 4
      spec->type = SLANG_SPEC_SAMPLER2DSHADOW;
      break;
   case TYPE_SPECIFIER_SAMPLER2DRECTSHADOW:
      spec->type = SLANG_SPEC_SAMPLER2DRECTSHADOW;
d660 1
a660 1
      spec->type = SLANG_SPEC_STRUCT;
d665 1
a665 1
      spec->type = SLANG_SPEC_STRUCT;
d676 1
a676 1
            slang_info_log_error(C->L, "undeclared type name '%s'",
d681 2
a682 1
         spec->_struct = (slang_struct *) _slang_alloc(sizeof(slang_struct));
d688 1
a688 1
            _slang_free(spec->_struct);
d708 1
a708 3
   if (!parse_type_specifier(C, O, &type->specifier))
      return 0;
   return 1;
d779 1
a779 1
 * For example, a while-loop compound will have two children, the
d785 1
a785 1
 * \param statement  indicates whether parsing a statement, or expression
d790 1
a790 1
                      slang_operation * oper, GLboolean statement)
d795 16
a810 1
   ch = slang_operation_grow(&oper->num_children, &oper->children);
d826 1
a826 1
      oper->type = SLANG_OPER_BLOCK_NO_NEW_SCOPE;
d837 1
a837 1
         oper->type = SLANG_OPER_BLOCK_NEW_SCOPE;
d849 1
a849 1
      oper->type = SLANG_OPER_BLOCK_NO_NEW_SCOPE;
d861 3
a863 3
            assert(oper->num_children == 0);
            oper->num_children = num_vars;
            oper->children = slang_operation_new(num_vars);
d868 8
d878 1
a878 1
               o->type = SLANG_OPER_VARIABLE_DECL;
d880 1
a880 1
               o->a_id = O->vars->variables[i]->a_name;
d889 1
a889 1
      oper->type = SLANG_OPER_ASM;
d900 1
a900 1
      oper->type = SLANG_OPER_BREAK;
d903 1
a903 1
      oper->type = SLANG_OPER_CONTINUE;
d906 1
a906 1
      oper->type = SLANG_OPER_DISCARD;
d909 1
a909 1
      oper->type = SLANG_OPER_RETURN;
d914 1
a914 1
      oper->type = SLANG_OPER_EXPRESSION;
d919 1
a919 1
      oper->type = SLANG_OPER_IF;
d931 1
a931 1
         oper->type = SLANG_OPER_WHILE;
d940 1
a940 1
      oper->type = SLANG_OPER_DO;
d950 1
a950 1
         oper->type = SLANG_OPER_FOR;
d975 2
a976 1
   op->children = slang_operation_new(n);
d983 1
a983 2
   for (i = 0; i < n; i++) {
      slang_operation_destruct(&op->children[i]);
a984 2
   }

d989 3
a991 3
      _slang_realloc(*ops,
                     (*total_ops + n) * sizeof(slang_operation),
                     *total_ops * sizeof(slang_operation));
d1003 1
a1003 1
   if (slang_type_specifier_type_from_string(name) != SLANG_SPEC_VOID)
d1022 3
a1024 3
         _slang_realloc(ops,
                        num_ops * sizeof(slang_operation),
                        (num_ops + 1) * sizeof(slang_operation));
d1039 1
a1039 1
         op->type = SLANG_OPER_VOID;
d1042 1
a1042 1
         op->type = SLANG_OPER_LITERAL_BOOL;
d1045 1
a1045 5
         op->literal[0] =
         op->literal[1] =
         op->literal[2] =
         op->literal[3] = (GLfloat) number;
         op->literal_size = 1;
d1048 1
a1048 1
         op->type = SLANG_OPER_LITERAL_INT;
d1051 1
a1051 5
         op->literal[0] =
         op->literal[1] =
         op->literal[2] =
         op->literal[3] = (GLfloat) number;
         op->literal_size = 1;
d1054 2
a1055 2
         op->type = SLANG_OPER_LITERAL_FLOAT;
         if (!parse_float(C, &op->literal[0]))
a1056 4
         op->literal[1] =
         op->literal[2] =
         op->literal[3] = op->literal[0];
         op->literal_size = 1;
d1059 1
a1059 1
         op->type = SLANG_OPER_IDENTIFIER;
d1065 1
a1065 1
         op->type = SLANG_OPER_SEQUENCE;
d1070 1
a1070 1
         op->type = SLANG_OPER_ASSIGN;
d1075 1
a1075 1
         op->type = SLANG_OPER_ADDASSIGN;
d1080 1
a1080 1
         op->type = SLANG_OPER_SUBASSIGN;
d1085 1
a1085 1
         op->type = SLANG_OPER_MULASSIGN;
d1090 1
a1090 1
         op->type = SLANG_OPER_DIVASSIGN;
d1101 1
a1101 1
         op->type = SLANG_OPER_SELECT;
d1106 1
a1106 1
         op->type = SLANG_OPER_LOGICALOR;
d1111 1
a1111 1
         op->type = SLANG_OPER_LOGICALXOR;
d1116 1
a1116 1
         op->type = SLANG_OPER_LOGICALAND;
d1124 1
a1124 1
         op->type = SLANG_OPER_EQUAL;
d1129 1
a1129 1
         op->type = SLANG_OPER_NOTEQUAL;
d1134 1
a1134 1
         op->type = SLANG_OPER_LESS;
d1139 1
a1139 1
         op->type = SLANG_OPER_GREATER;
d1144 1
a1144 1
         op->type = SLANG_OPER_LESSEQUAL;
d1149 1
a1149 1
         op->type = SLANG_OPER_GREATEREQUAL;
d1156 1
a1156 1
         op->type = SLANG_OPER_ADD;
d1161 1
a1161 1
         op->type = SLANG_OPER_SUBTRACT;
d1166 1
a1166 1
         op->type = SLANG_OPER_MULTIPLY;
d1171 1
a1171 1
         op->type = SLANG_OPER_DIVIDE;
d1177 1
a1177 1
         op->type = SLANG_OPER_PREINCREMENT;
d1182 1
a1182 1
         op->type = SLANG_OPER_PREDECREMENT;
d1187 1
a1187 1
         op->type = SLANG_OPER_PLUS;
d1192 1
a1192 1
         op->type = SLANG_OPER_MINUS;
d1197 1
a1197 1
         op->type = SLANG_OPER_NOT;
d1203 1
a1203 1
         op->type = SLANG_OPER_SUBSCRIPT;
d1208 1
a1208 1
         op->type = SLANG_OPER_CALL;
d1229 1
a1229 1
         op->type = SLANG_OPER_FIELD;
d1237 1
a1237 1
         op->type = SLANG_OPER_POSTINCREMENT;
d1242 1
a1242 1
         op->type = SLANG_OPER_POSTDECREMENT;
d1252 2
a1253 3
   slang_operation_destruct(oper);
   *oper = *ops; /* struct copy */
   _slang_free(ops);
d1278 2
a1279 2
      if (param->type.qualifier != SLANG_QUAL_CONST
          && param->type.qualifier != SLANG_QUAL_NONE) {
d1285 2
a1286 2
      if (param->type.qualifier == SLANG_QUAL_NONE)
         param->type.qualifier = SLANG_QUAL_OUT;
d1293 2
a1294 2
      if (param->type.qualifier == SLANG_QUAL_NONE)
         param->type.qualifier = SLANG_QUAL_INOUT;
d1444 1
a1444 1
      func->kind = SLANG_FUNC_ORDINARY;
d1450 2
a1451 2
      func->kind = SLANG_FUNC_CONSTRUCTOR;
      if (func->header.type.specifier.type == SLANG_SPEC_STRUCT)
d1463 1
a1463 1
      func->kind = SLANG_FUNC_OPERATOR;
a1482 12
   /* if the function returns a value, append a hidden __retVal 'out'
    * parameter that corresponds to the return value.
    */
   if (_slang_function_has_return_value(func)) {
      slang_variable *p = slang_variable_scope_grow(func->parameters);
      slang_atom a_retVal = slang_atom_pool_atom(C->atoms, "__retVal");
      assert(a_retVal);
      p->a_name = a_retVal;
      p->type = func->header.type;
      p->type.qualifier = SLANG_QUAL_OUT;
   }

a1490 1

d1504 2
a1505 1
   func->body = (slang_operation *) _slang_alloc(sizeof(slang_operation));
d1511 1
a1511 1
      _slang_free(func->body);
d1532 3
d1538 17
d1558 1
a1558 1
   op_id.type = SLANG_OPER_IDENTIFIER;
d1563 1
a1563 1
      (slang_variable **) _slang_alloc(sizeof(slang_variable *));
d1569 1
a1569 1
   op_id.locals->variables[0] = var;
d1577 1
a1577 1
   op_assign.type = SLANG_OPER_ASSIGN;
d1579 1
a1579 1
      (slang_operation *) _slang_alloc(2 * sizeof(slang_operation));
d1590 2
a1591 1
   result = 1;
d1595 1
a1595 1
   _slang_free(op_assign.children);
d1603 15
d1655 1
d1672 1
a1672 1
         (slang_operation *) _slang_alloc(sizeof(slang_operation));
d1678 1
a1678 1
         _slang_free(var->initializer);
d1686 1
d1694 1
a1704 14
   /* emit code for global var decl */
   if (C->global_scope) {
      slang_assemble_ctx A;
      A.atoms = C->atoms;
      A.space.funcs = O->funs;
      A.space.structs = O->structs;
      A.space.vars = O->vars;
      A.program = O->program;
      A.vartable = O->vartable;
      A.curFuncEndLabel = NULL;
      if (!_slang_codegen_global_variable(&A, var, C->type))
         return 0;
   }

d1707 1
a1707 1
       && !(var->type.specifier.type == SLANG_SPEC_ARRAY
d1719 2
d1728 4
d1773 1
a1773 1
 * \return GL_TRUE if success, GL_FALSE if failure
d1775 1
a1775 1
static GLboolean
d1783 1
a1783 1
      return GL_FALSE;
d1787 1
a1787 1
         return GL_FALSE;
d1793 1
a1793 1
         return GL_FALSE;
d1803 1
a1803 1
      /* New function, add it to the function list */
d1805 5
a1809 5
         (slang_function *) _slang_realloc(O->funs->functions,
                                           O->funs->num_functions
                                           * sizeof(slang_function),
                                           (O->funs->num_functions + 1)
                                           * sizeof(slang_function));
d1813 1
a1813 1
         return GL_FALSE;
a1821 1
      /* previously defined or declared */
d1830 1
a1830 1
            return GL_FALSE;
d1854 2
d1860 2
a1861 5
      A.program = O->program;
      A.vartable = O->vartable;
      A.log = C->L;

      _slang_codegen_function(&A, *parsed_func_ret);
d1863 1
a1863 1
   return GL_TRUE;
d1898 1
a1898 2
parse_code_unit(slang_parse_ctx * C, slang_code_unit * unit,
                struct gl_program *program)
a1899 1
   GET_CURRENT_CONTEXT(ctx);
a1900 12
   GLboolean success;
   GLuint maxRegs;

   if (unit->type == SLANG_UNIT_FRAGMENT_BUILTIN ||
       unit->type == SLANG_UNIT_FRAGMENT_SHADER) {
      maxRegs = ctx->Const.FragmentProgram.MaxTemps;
   }
   else {
      assert(unit->type == SLANG_UNIT_VERTEX_BUILTIN ||
             unit->type == SLANG_UNIT_VERTEX_SHADER);
      maxRegs = ctx->Const.VertexProgram.MaxTemps;
   }
d1906 1
d1908 1
a1908 3
   o.program = program;
   o.vartable = _slang_new_var_table(maxRegs);
   _slang_push_var_table(o.vartable);
d1916 3
a1918 1
            success = parse_function(C, &o, 1, &func);
d1922 2
a1923 1
         success = parse_declaration(C, &o);
d1926 1
a1926 7
         success = GL_FALSE;
      }

      if (!success) {
         /* xxx free codegen */
         _slang_pop_var_table(o.vartable);
         return GL_FALSE;
d1930 1
a1930 5

   _slang_pop_var_table(o.vartable);
   _slang_delete_var_table(o.vartable);

   return GL_TRUE;
d1936 1
a1936 2
               slang_code_unit * builtin, slang_code_unit * downlink,
               struct gl_program *program)
a1947 1
   C.type = type;
d1959 1
a1959 1
   return parse_code_unit(&C, unit, program);
d1965 1
a1965 2
                     slang_code_unit * builtin,
                     struct gl_program *program)
a1969 7
   int maxVersion;

#if FEATURE_ARB_shading_language_120
   maxVersion = 120;
#else
   maxVersion = 110;
#endif
d1975 1
a1975 1
   if (version > maxVersion) {
d1977 1
a1977 2
                           "language version %.2f is not supported.",
                           version * 0.01);
d1990 3
a1992 3
   if (!grammar_fast_check(id,
                           (const byte *) (slang_string_cstr(&preprocessed)),
                           &prod, &size, 65536)) {
a1998 11
      /* syntax error (possibly in library code) */
#if 0
      {
         int line, col;
         char *s;
         s = (char *) _mesa_find_line_column((const GLubyte *) source,
                                             (const GLubyte *) source + pos,
                                             &line, &col);
         printf("Error on line %d, col %d: %s\n", line, col, s);
      }
#endif
d2004 3
a2006 3
   if (!compile_binary(prod, unit, type, infolog, builtin,
                       &builtin[SLANG_BUILTIN_TOTAL - 1],
                       program)) {
a2021 4
static const byte slang_120_core_gc[] = {
#include "library/slang_120_core_gc.h"
};

d2034 6
d2042 1
a2042 2
               slang_unit_type type, slang_info_log * infolog,
               struct gl_program *program)
d2058 2
a2059 2
   if (type == SLANG_UNIT_FRAGMENT_SHADER
       || type == SLANG_UNIT_FRAGMENT_BUILTIN)
d2068 1
a2068 1
   if (type == SLANG_UNIT_FRAGMENT_SHADER || type == SLANG_UNIT_VERTEX_SHADER) {
d2070 2
a2071 4
      if (!compile_binary(slang_core_gc,
                          &object->builtin[SLANG_BUILTIN_CORE],
                          SLANG_UNIT_FRAGMENT_BUILTIN, infolog,
                          NULL, NULL, NULL))
a2073 8
#if FEATURE_ARB_shading_language_120
      if (!compile_binary(slang_120_core_gc,
                          &object->builtin[SLANG_BUILTIN_120_CORE],
                          SLANG_UNIT_FRAGMENT_BUILTIN, infolog,
                          NULL, &object->builtin[SLANG_BUILTIN_CORE], NULL))
         return GL_FALSE;
#endif

d2075 4
a2078 9
      if (!compile_binary(slang_common_builtin_gc,
                          &object->builtin[SLANG_BUILTIN_COMMON],
                          SLANG_UNIT_FRAGMENT_BUILTIN, infolog, NULL,
#if FEATURE_ARB_shading_language_120
                          &object->builtin[SLANG_BUILTIN_120_CORE],
#else
                          &object->builtin[SLANG_BUILTIN_CORE],
#endif
                          NULL))
d2082 6
a2087 5
      if (type == SLANG_UNIT_FRAGMENT_SHADER) {
         if (!compile_binary(slang_fragment_builtin_gc,
                             &object->builtin[SLANG_BUILTIN_TARGET],
                             SLANG_UNIT_FRAGMENT_BUILTIN, infolog, NULL,
                             &object->builtin[SLANG_BUILTIN_COMMON], NULL))
d2090 5
a2094 5
      else if (type == SLANG_UNIT_VERTEX_SHADER) {
         if (!compile_binary(slang_vertex_builtin_gc,
                             &object->builtin[SLANG_BUILTIN_TARGET],
                             SLANG_UNIT_VERTEX_BUILTIN, infolog, NULL,
                             &object->builtin[SLANG_BUILTIN_COMMON], NULL))
d2098 9
a2107 3
#if NEW_SLANG /* allow-built-ins */
      grammar_set_reg8(*id, (const byte *) "parsing_builtin", 1);
#else
a2108 1
#endif
d2114 1
a2114 1
                               builtins, program);
d2117 3
a2119 5

static GLboolean
compile_shader(GLcontext *ctx, slang_code_object * object,
               slang_unit_type type, slang_info_log * infolog,
               struct gl_shader *shader)
a2120 1
   struct gl_program *program = shader->Programs[0];
a2123 2
   assert(program);

d2127 1
a2127 1
   success = compile_object(&id, shader->Source, object, type, infolog, program);
d2133 5
a2137 2
   return GL_TRUE;
}
d2139 7
d2147 1
a2147 63

GLboolean
_slang_compile(GLcontext *ctx, struct gl_shader *shader)
{
   GLboolean success;
   slang_info_log info_log;
   slang_code_object obj;
   slang_unit_type type;

   if (shader->Type == GL_VERTEX_SHADER) {
      type = SLANG_UNIT_VERTEX_SHADER;
   }
   else {
      assert(shader->Type == GL_FRAGMENT_SHADER);
      type = SLANG_UNIT_FRAGMENT_SHADER;
   }

   ctx->Shader.MemPool = _slang_new_mempool(1024*1024);

   /* XXX temporary hack */
   if (!shader->Programs) {
      GLenum progTarget;
      if (shader->Type == GL_VERTEX_SHADER)
         progTarget = GL_VERTEX_PROGRAM_ARB;
      else
         progTarget = GL_FRAGMENT_PROGRAM_ARB;
      shader->Programs
         = (struct gl_program **) malloc(sizeof(struct gl_program*));
      shader->Programs[0] = ctx->Driver.NewProgram(ctx, progTarget, 1);
      shader->NumPrograms = 1;

      shader->Programs[0]->Parameters = _mesa_new_parameter_list();
      shader->Programs[0]->Varying = _mesa_new_parameter_list();
      shader->Programs[0]->Attributes = _mesa_new_parameter_list();
   }

   slang_info_log_construct(&info_log);
   _slang_code_object_ctr(&obj);

   success = compile_shader(ctx, &obj, type, &info_log, shader);

   /* free shader's prev info log */
   if (shader->InfoLog) {
      _mesa_free(shader->InfoLog);
      shader->InfoLog = NULL;
   }

   if (info_log.text) {
      /* copy info-log string to shader object */
      shader->InfoLog = _mesa_strdup(info_log.text);
   }

   if (info_log.error_flag) {
      success = GL_FALSE;
   }

   slang_info_log_destruct(&info_log);
   _slang_code_object_dtr(&obj);

   _slang_delete_mempool((slang_mempool *) ctx->Shader.MemPool);
   ctx->Shader.MemPool = NULL;

   return success;
a2148 1

@


