head	1.6;
access;
symbols
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v7_0_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2011.10.23.13.37.45;	author matthieu;	state dead;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.33;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.49;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.17.31.48;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.17.31.48;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge Mesa 7.10.3
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2005-2008  Brian Paul   All Rights Reserved.
 * Copyright (C) 2008 VMware, Inc.   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file slang_emit.c
 * Emit program instructions (PI code) from IR trees.
 * \author Brian Paul
 */

/***
 *** NOTES
 ***
 *** To emit GPU instructions, we basically just do an in-order traversal
 *** of the IR tree.
 ***/


#include "main/imports.h"
#include "main/context.h"
#include "shader/program.h"
#include "shader/prog_instruction.h"
#include "shader/prog_parameter.h"
#include "shader/prog_print.h"
#include "slang_builtin.h"
#include "slang_emit.h"
#include "slang_mem.h"


#define PEEPHOLE_OPTIMIZATIONS 1
#define ANNOTATE 0


typedef struct
{
   slang_info_log *log;
   slang_var_table *vt;
   struct gl_program *prog;
   struct gl_program **Subroutines;
   GLuint NumSubroutines;

   GLuint MaxInstructions;  /**< size of prog->Instructions[] buffer */

   GLboolean UnresolvedFunctions;

   /* code-gen options */
   GLboolean EmitHighLevelInstructions;
   GLboolean EmitCondCodes;
   GLboolean EmitComments;
   GLboolean EmitBeginEndSub; /* XXX TEMPORARY */
} slang_emit_info;



static struct gl_program *
new_subroutine(slang_emit_info *emitInfo, GLuint *id)
{
   GET_CURRENT_CONTEXT(ctx);
   const GLuint n = emitInfo->NumSubroutines;

   emitInfo->Subroutines = (struct gl_program **)
      _mesa_realloc(emitInfo->Subroutines,
                    n * sizeof(struct gl_program *),
                    (n + 1) * sizeof(struct gl_program *));
   emitInfo->Subroutines[n] = ctx->Driver.NewProgram(ctx, emitInfo->prog->Target, 0);
   emitInfo->Subroutines[n]->Parameters = emitInfo->prog->Parameters;
   emitInfo->NumSubroutines++;
   *id = n;
   return emitInfo->Subroutines[n];
}


/**
 * Convert a writemask to a swizzle.  Used for testing cond codes because
 * we only want to test the cond code component(s) that was set by the
 * previous instruction.
 */
static GLuint
writemask_to_swizzle(GLuint writemask)
{
   if (writemask == WRITEMASK_X)
      return SWIZZLE_XXXX;
   if (writemask == WRITEMASK_Y)
      return SWIZZLE_YYYY;
   if (writemask == WRITEMASK_Z)
      return SWIZZLE_ZZZZ;
   if (writemask == WRITEMASK_W)
      return SWIZZLE_WWWW;
   return SWIZZLE_XYZW;  /* shouldn't be hit */
}


/**
 * Convert a swizzle mask to a writemask.
 * Note that the slang_ir_storage->Swizzle field can represent either a
 * swizzle mask or a writemask, depending on how it's used.  For example,
 * when we parse "direction.yz" alone, we don't know whether .yz is a
 * writemask or a swizzle.  In this case, we encode ".yz" in store->Swizzle
 * as a swizzle mask (.yz?? actually).  Later, if direction.yz is used as
 * an R-value, we use store->Swizzle as-is.  Otherwise, if direction.yz is
 * used as an L-value, we convert it to a writemask.
 */
static GLuint
swizzle_to_writemask(GLuint swizzle)
{
   GLuint i, writemask = 0x0;
   for (i = 0; i < 4; i++) {
      GLuint swz = GET_SWZ(swizzle, i);
      if (swz <= SWIZZLE_W) {
         writemask |= (1 << swz);
      }
   }
   return writemask;
}


/**
 * Swizzle a swizzle (function composition).
 * That is, return swz2(swz1), or said another way: swz1.szw2
 * Example: swizzle_swizzle(".zwxx", ".xxyw") yields ".zzwx"
 */
GLuint
_slang_swizzle_swizzle(GLuint swz1, GLuint swz2)
{
   GLuint i, swz, s[4];
   for (i = 0; i < 4; i++) {
      GLuint c = GET_SWZ(swz2, i);
      if (c <= SWIZZLE_W)
         s[i] = GET_SWZ(swz1, c);
      else
         s[i] = c;
   }
   swz = MAKE_SWIZZLE4(s[0], s[1], s[2], s[3]);
   return swz;
}


/**
 * Return the default swizzle mask for accessing a variable of the
 * given size (in floats).  If size = 1, comp is used to identify
 * which component [0..3] of the register holds the variable.
 */
GLuint
_slang_var_swizzle(GLint size, GLint comp)
{
   switch (size) {
   case 1:
      return MAKE_SWIZZLE4(comp, SWIZZLE_NIL, SWIZZLE_NIL, SWIZZLE_NIL);
   case 2:
      return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_NIL, SWIZZLE_NIL);
   case 3:
      return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_NIL);
   default:
      return SWIZZLE_XYZW;
   }
}



/**
 * Allocate storage for the given node (if it hasn't already been allocated).
 *
 * Typically this is temporary storage for an intermediate result (such as
 * for a multiply or add, etc).
 *
 * If n->Store does not exist it will be created and will be of the size
 * specified by defaultSize.
 */
static GLboolean
alloc_node_storage(slang_emit_info *emitInfo, slang_ir_node *n,
                   GLint defaultSize)
{
   assert(!n->Var);
   if (!n->Store) {
      assert(defaultSize > 0);
      n->Store = _slang_new_ir_storage(PROGRAM_TEMPORARY, -1, defaultSize);
      if (!n->Store) {
         return GL_FALSE;
      }
   }

   /* now allocate actual register(s).  I.e. set n->Store->Index >= 0 */
   if (n->Store->Index < 0) {
      if (!_slang_alloc_temp(emitInfo->vt, n->Store)) {
         slang_info_log_error(emitInfo->log,
                              "Ran out of registers, too many temporaries");
         _slang_free(n->Store);
         n->Store = NULL;
         return GL_FALSE;
      }
   }
   return GL_TRUE;
}


/**
 * Free temporary storage, if n->Store is, in fact, temp storage.
 * Otherwise, no-op.
 */
static void
free_node_storage(slang_var_table *vt, slang_ir_node *n)
{
   if (n->Store->File == PROGRAM_TEMPORARY &&
       n->Store->Index >= 0 &&
       n->Opcode != IR_SWIZZLE) {
      if (_slang_is_temp(vt, n->Store)) {
         _slang_free_temp(vt, n->Store);
         n->Store->Index = -1;
         n->Store = NULL; /* XXX this may not be needed */
      }
   }
}


/**
 * Helper function to allocate a short-term temporary.
 * Free it with _slang_free_temp().
 */
static GLboolean
alloc_local_temp(slang_emit_info *emitInfo, slang_ir_storage *temp, GLint size)
{
   assert(size >= 1);
   assert(size <= 4);
   memset(temp, 0, sizeof(*temp));
   temp->Size = size;
   temp->File = PROGRAM_TEMPORARY;
   temp->Index = -1;
   return _slang_alloc_temp(emitInfo->vt, temp);
}


/**
 * Remove any SWIZZLE_NIL terms from given swizzle mask.
 * For a swizzle like .z??? generate .zzzz (replicate single component).
 * Else, for .wx?? generate .wxzw (insert default component for the position).
 */
static GLuint
fix_swizzle(GLuint swizzle)
{
   GLuint c0 = GET_SWZ(swizzle, 0),
      c1 = GET_SWZ(swizzle, 1),
      c2 = GET_SWZ(swizzle, 2),
      c3 = GET_SWZ(swizzle, 3);
   if (c1 == SWIZZLE_NIL && c2 == SWIZZLE_NIL && c3 == SWIZZLE_NIL) {
      /* smear first component across all positions */
      c1 = c2 = c3 = c0;
   }
   else {
      /* insert default swizzle components */
      if (c0 == SWIZZLE_NIL)
         c0 = SWIZZLE_X;
      if (c1 == SWIZZLE_NIL)
         c1 = SWIZZLE_Y;
      if (c2 == SWIZZLE_NIL)
         c2 = SWIZZLE_Z;
      if (c3 == SWIZZLE_NIL)
         c3 = SWIZZLE_W;
   }
   return MAKE_SWIZZLE4(c0, c1, c2, c3);
}



/**
 * Convert IR storage to an instruction dst register.
 */
static void
storage_to_dst_reg(struct prog_dst_register *dst, const slang_ir_storage *st)
{
   const GLboolean relAddr = st->RelAddr;
   const GLint size = st->Size;
   GLint index = st->Index;
   GLuint swizzle = st->Swizzle;

   assert(index >= 0);
   /* if this is storage relative to some parent storage, walk up the tree */
   while (st->Parent) {
      st = st->Parent;
      assert(st->Index >= 0);
      index += st->Index;
      swizzle = _slang_swizzle_swizzle(st->Swizzle, swizzle);
   }

   assert(st->File != PROGRAM_UNDEFINED);
   dst->File = st->File;

   assert(index >= 0);
   dst->Index = index;

   assert(size >= 1);
   assert(size <= 4);

   if (swizzle != SWIZZLE_XYZW) {
      dst->WriteMask = swizzle_to_writemask(swizzle);
   }
   else {
      switch (size) {
      case 1:
         dst->WriteMask = WRITEMASK_X << GET_SWZ(st->Swizzle, 0);
         break;
      case 2:
         dst->WriteMask = WRITEMASK_XY;
         break;
      case 3:
         dst->WriteMask = WRITEMASK_XYZ;
         break;
      case 4:
         dst->WriteMask = WRITEMASK_XYZW;
         break;
      default:
         ; /* error would have been caught above */
      }
   }

   dst->RelAddr = relAddr;
}


/**
 * Convert IR storage to an instruction src register.
 */
static void
storage_to_src_reg(struct prog_src_register *src, const slang_ir_storage *st)
{
   const GLboolean relAddr = st->RelAddr;
   GLint index = st->Index;
   GLuint swizzle = st->Swizzle;

   /* if this is storage relative to some parent storage, walk up the tree */
   assert(index >= 0);
   while (st->Parent) {
      st = st->Parent;
      if (st->Index < 0) {
         /* an error should have been reported already */
         return;
      }
      assert(st->Index >= 0);
      index += st->Index;
      swizzle = _slang_swizzle_swizzle(fix_swizzle(st->Swizzle), swizzle);
   }

   assert(st->File >= 0);
#if 1 /* XXX temporary */
   if (st->File == PROGRAM_UNDEFINED) {
      slang_ir_storage *st0 = (slang_ir_storage *) st;
      st0->File = PROGRAM_TEMPORARY;
   }
#endif
   assert(st->File < PROGRAM_UNDEFINED);
   src->File = st->File;

   assert(index >= 0);
   src->Index = index;

   swizzle = fix_swizzle(swizzle);
   assert(GET_SWZ(swizzle, 0) <= SWIZZLE_W);
   assert(GET_SWZ(swizzle, 1) <= SWIZZLE_W);
   assert(GET_SWZ(swizzle, 2) <= SWIZZLE_W);
   assert(GET_SWZ(swizzle, 3) <= SWIZZLE_W);
   src->Swizzle = swizzle;

   src->RelAddr = relAddr;
}


/*
 * Setup storage pointing to a scalar constant/literal.
 */
static void
constant_to_storage(slang_emit_info *emitInfo,
                    GLfloat val,
                    slang_ir_storage *store)
{
   GLuint swizzle;
   GLint reg;
   GLfloat value[4];

   value[0] = val;
   reg = _mesa_add_unnamed_constant(emitInfo->prog->Parameters,
                                        value, 1, &swizzle);

   memset(store, 0, sizeof(*store));
   store->File = PROGRAM_CONSTANT;
   store->Index = reg;
   store->Swizzle = swizzle;
}


/**
 * Add new instruction at end of given program.
 * \param prog  the program to append instruction onto
 * \param opcode  opcode for the new instruction
 * \return pointer to the new instruction
 */
static struct prog_instruction *
new_instruction(slang_emit_info *emitInfo, gl_inst_opcode opcode)
{
   struct gl_program *prog = emitInfo->prog;
   struct prog_instruction *inst;

#if 0
   /* print prev inst */
   if (prog->NumInstructions > 0) {
      _mesa_print_instruction(prog->Instructions + prog->NumInstructions - 1);
   }
#endif
   assert(prog->NumInstructions <= emitInfo->MaxInstructions);

   if (prog->NumInstructions == emitInfo->MaxInstructions) {
      /* grow the instruction buffer */
      emitInfo->MaxInstructions += 20;
      prog->Instructions =
         _mesa_realloc_instructions(prog->Instructions,
                                    prog->NumInstructions,
                                    emitInfo->MaxInstructions);
      if (!prog->Instructions) {
         return NULL;
      }
   }

   inst = prog->Instructions + prog->NumInstructions;
   prog->NumInstructions++;
   _mesa_init_instructions(inst, 1);
   inst->Opcode = opcode;
   inst->BranchTarget = -1; /* invalid */
   /*
   printf("New inst %d: %p %s\n", prog->NumInstructions-1,(void*)inst,
          _mesa_opcode_string(inst->Opcode));
   */
   return inst;
}


static struct prog_instruction *
emit_arl_load(slang_emit_info *emitInfo,
              gl_register_file file, GLint index, GLuint swizzle)
{
   struct prog_instruction *inst = new_instruction(emitInfo, OPCODE_ARL);
   if (inst) {
      inst->SrcReg[0].File = file;
      inst->SrcReg[0].Index = index;
      inst->SrcReg[0].Swizzle = fix_swizzle(swizzle);
      inst->DstReg.File = PROGRAM_ADDRESS;
      inst->DstReg.Index = 0;
      inst->DstReg.WriteMask = WRITEMASK_X;
   }
   return inst;
}


/**
 * Emit a new instruction with given opcode, operands.
 * At this point the instruction may have multiple indirect register
 * loads/stores.  We convert those into ARL loads and address-relative
 * operands.  See comments inside.
 * At some point in the future we could directly emit indirectly addressed
 * registers in Mesa GPU instructions.
 */
static struct prog_instruction *
emit_instruction(slang_emit_info *emitInfo,
                 gl_inst_opcode opcode,
                 const slang_ir_storage *dst,
                 const slang_ir_storage *src0,
                 const slang_ir_storage *src1,
                 const slang_ir_storage *src2)
{
   struct prog_instruction *inst;
   GLuint numIndirect = 0;
   const slang_ir_storage *src[3];
   slang_ir_storage newSrc[3], newDst;
   GLuint i;
   GLboolean isTemp[3];

   isTemp[0] = isTemp[1] = isTemp[2] = GL_FALSE;

   src[0] = src0;
   src[1] = src1;
   src[2] = src2;

   /* count up how many operands are indirect loads */
   for (i = 0; i < 3; i++) {
      if (src[i] && src[i]->IsIndirect)
         numIndirect++;
   }
   if (dst && dst->IsIndirect)
      numIndirect++;

   /* Take special steps for indirect register loads.
    * If we had multiple address registers this would be simpler.
    * For example, this GLSL code:
    *    x[i] = y[j] + z[k];
    * would translate into something like:
    *    ARL ADDR.x, i;
    *    ARL ADDR.y, j;
    *    ARL ADDR.z, k;
    *    ADD TEMP[ADDR.x+5], TEMP[ADDR.y+9], TEMP[ADDR.z+4];
    * But since we currently only have one address register we have to do this:
    *    ARL ADDR.x, i;
    *    MOV t1, TEMP[ADDR.x+9];
    *    ARL ADDR.x, j;
    *    MOV t2, TEMP[ADDR.x+4];
    *    ARL ADDR.x, k;
    *    ADD TEMP[ADDR.x+5], t1, t2;
    * The code here figures this out...
    */
   if (numIndirect > 0) {
      for (i = 0; i < 3; i++) {
         if (src[i] && src[i]->IsIndirect) {
            /* load the ARL register with the indirect register */
            emit_arl_load(emitInfo,
                          src[i]->IndirectFile,
                          src[i]->IndirectIndex,
                          src[i]->IndirectSwizzle);

            if (numIndirect > 1) {
               /* Need to load src[i] into a temporary register */
               slang_ir_storage srcRelAddr;
               alloc_local_temp(emitInfo, &newSrc[i], src[i]->Size);
               isTemp[i] = GL_TRUE;

               /* set RelAddr flag on src register */
               srcRelAddr = *src[i];
               srcRelAddr.RelAddr = GL_TRUE;
               srcRelAddr.IsIndirect = GL_FALSE; /* not really needed */

               /* MOV newSrc, srcRelAddr; */
               inst = emit_instruction(emitInfo,
                                       OPCODE_MOV,
                                       &newSrc[i],
                                       &srcRelAddr,
                                       NULL,
                                       NULL);
               if (!inst) {
                  return NULL;
               }

               src[i] = &newSrc[i];
            }
            else {
               /* just rewrite the src[i] storage to be ARL-relative */
               newSrc[i] = *src[i];
               newSrc[i].RelAddr = GL_TRUE;
               newSrc[i].IsIndirect = GL_FALSE; /* not really needed */
               src[i] = &newSrc[i];
            }
         }
      }
   }

   /* Take special steps for indirect dest register write */
   if (dst && dst->IsIndirect) {
      /* load the ARL register with the indirect register */
      emit_arl_load(emitInfo,
                    dst->IndirectFile,
                    dst->IndirectIndex,
                    dst->IndirectSwizzle);
      newDst = *dst;
      newDst.RelAddr = GL_TRUE;
      newDst.IsIndirect = GL_FALSE;
      dst = &newDst;
   }

   /* OK, emit the instruction and its dst, src regs */
   inst = new_instruction(emitInfo, opcode);
   if (!inst)
      return NULL;

   if (dst)
      storage_to_dst_reg(&inst->DstReg, dst);

   for (i = 0; i < 3; i++) {
      if (src[i])
         storage_to_src_reg(&inst->SrcReg[i], src[i]);
   }

   /* Free any temp registers that we allocated above */
   for (i = 0; i < 3; i++) {
      if (isTemp[i])
         _slang_free_temp(emitInfo->vt, &newSrc[i]);
   }

   return inst;
}



/**
 * Put a comment on the given instruction.
 */
static void
inst_comment(struct prog_instruction *inst, const char *comment)
{
   if (inst)
      inst->Comment = _mesa_strdup(comment);
}



/**
 * Return pointer to last instruction in program.
 */
static struct prog_instruction *
prev_instruction(slang_emit_info *emitInfo)
{
   struct gl_program *prog = emitInfo->prog;
   if (prog->NumInstructions == 0)
      return NULL;
   else
      return prog->Instructions + prog->NumInstructions - 1;
}


static struct prog_instruction *
emit(slang_emit_info *emitInfo, slang_ir_node *n);


/**
 * Return an annotation string for given node's storage.
 */
static char *
storage_annotation(const slang_ir_node *n, const struct gl_program *prog)
{
#if ANNOTATE
   const slang_ir_storage *st = n->Store;
   static char s[100] = "";

   if (!st)
      return _mesa_strdup("");

   switch (st->File) {
   case PROGRAM_CONSTANT:
      if (st->Index >= 0) {
         const GLfloat *val = prog->Parameters->ParameterValues[st->Index];
         if (st->Swizzle == SWIZZLE_NOOP)
            sprintf(s, "{%g, %g, %g, %g}", val[0], val[1], val[2], val[3]);
         else {
            sprintf(s, "%g", val[GET_SWZ(st->Swizzle, 0)]);
         }
      }
      break;
   case PROGRAM_TEMPORARY:
      if (n->Var)
         sprintf(s, "%s", (char *) n->Var->a_name);
      else
         sprintf(s, "t[%d]", st->Index);
      break;
   case PROGRAM_STATE_VAR:
   case PROGRAM_UNIFORM:
      sprintf(s, "%s", prog->Parameters->Parameters[st->Index].Name);
      break;
   case PROGRAM_VARYING:
      sprintf(s, "%s", prog->Varying->Parameters[st->Index].Name);
      break;
   case PROGRAM_INPUT:
      sprintf(s, "input[%d]", st->Index);
      break;
   case PROGRAM_OUTPUT:
      sprintf(s, "output[%d]", st->Index);
      break;
   default:
      s[0] = 0;
   }
   return _mesa_strdup(s);
#else
   return NULL;
#endif
}


/**
 * Return an annotation string for an instruction.
 */
static char *
instruction_annotation(gl_inst_opcode opcode, char *dstAnnot,
                       char *srcAnnot0, char *srcAnnot1, char *srcAnnot2)
{
#if ANNOTATE
   const char *operator;
   char *s;
   int len = 50;

   if (dstAnnot)
      len += strlen(dstAnnot);
   else
      dstAnnot = _mesa_strdup("");

   if (srcAnnot0)
      len += strlen(srcAnnot0);
   else
      srcAnnot0 = _mesa_strdup("");

   if (srcAnnot1)
      len += strlen(srcAnnot1);
   else
      srcAnnot1 = _mesa_strdup("");

   if (srcAnnot2)
      len += strlen(srcAnnot2);
   else
      srcAnnot2 = _mesa_strdup("");

   switch (opcode) {
   case OPCODE_ADD:
      operator = "+";
      break;
   case OPCODE_SUB:
      operator = "-";
      break;
   case OPCODE_MUL:
      operator = "*";
      break;
   case OPCODE_DP2:
      operator = "DP2";
      break;
   case OPCODE_DP3:
      operator = "DP3";
      break;
   case OPCODE_DP4:
      operator = "DP4";
      break;
   case OPCODE_XPD:
      operator = "XPD";
      break;
   case OPCODE_RSQ:
      operator = "RSQ";
      break;
   case OPCODE_SGT:
      operator = ">";
      break;
   default:
      operator = ",";
   }

   s = (char *) malloc(len);
   sprintf(s, "%s = %s %s %s %s", dstAnnot,
           srcAnnot0, operator, srcAnnot1, srcAnnot2);
   assert(strlen(s) < len);

   free(dstAnnot);
   free(srcAnnot0);
   free(srcAnnot1);
   free(srcAnnot2);

   return s;
#else
   return NULL;
#endif
}


/**
 * Emit an instruction that's just a comment.
 */
static struct prog_instruction *
emit_comment(slang_emit_info *emitInfo, const char *comment)
{
   struct prog_instruction *inst = new_instruction(emitInfo, OPCODE_NOP);
   if (inst) {
      inst_comment(inst, comment);
   }
   return inst;
}


/**
 * Generate code for a simple arithmetic instruction.
 * Either 1, 2 or 3 operands.
 */
static struct prog_instruction *
emit_arith(slang_emit_info *emitInfo, slang_ir_node *n)
{
   const slang_ir_info *info = _slang_ir_info(n->Opcode);
   struct prog_instruction *inst;
   GLuint i;

   assert(info);
   assert(info->InstOpcode != OPCODE_NOP);

#if PEEPHOLE_OPTIMIZATIONS
   /* Look for MAD opportunity */
   if (info->NumParams == 2 &&
       n->Opcode == IR_ADD && n->Children[0]->Opcode == IR_MUL) {
      /* found pattern IR_ADD(IR_MUL(A, B), C) */
      emit(emitInfo, n->Children[0]->Children[0]);  /* A */
      emit(emitInfo, n->Children[0]->Children[1]);  /* B */
      emit(emitInfo, n->Children[1]);  /* C */
      if (!alloc_node_storage(emitInfo, n, -1)) {  /* dest */
         return NULL;
      }

      inst = emit_instruction(emitInfo,
                              OPCODE_MAD,
                              n->Store,
                              n->Children[0]->Children[0]->Store,
                              n->Children[0]->Children[1]->Store,
                              n->Children[1]->Store);

      free_node_storage(emitInfo->vt, n->Children[0]->Children[0]);
      free_node_storage(emitInfo->vt, n->Children[0]->Children[1]);
      free_node_storage(emitInfo->vt, n->Children[1]);
      return inst;
   }

   if (info->NumParams == 2 &&
       n->Opcode == IR_ADD && n->Children[1]->Opcode == IR_MUL) {
      /* found pattern IR_ADD(A, IR_MUL(B, C)) */
      emit(emitInfo, n->Children[0]);  /* A */
      emit(emitInfo, n->Children[1]->Children[0]);  /* B */
      emit(emitInfo, n->Children[1]->Children[1]);  /* C */
      if (!alloc_node_storage(emitInfo, n, -1)) {  /* dest */
         return NULL;
      }

      inst = emit_instruction(emitInfo,
                              OPCODE_MAD,
                              n->Store,
                              n->Children[1]->Children[0]->Store,
                              n->Children[1]->Children[1]->Store,
                              n->Children[0]->Store);

      free_node_storage(emitInfo->vt, n->Children[1]->Children[0]);
      free_node_storage(emitInfo->vt, n->Children[1]->Children[1]);
      free_node_storage(emitInfo->vt, n->Children[0]);
      return inst;
   }
#endif

   /* gen code for children, may involve temp allocation */
   for (i = 0; i < info->NumParams; i++) {
      emit(emitInfo, n->Children[i]);
      if (!n->Children[i] || !n->Children[i]->Store) {
         /* error recovery */
         return NULL;
      }
   }

   /* result storage */
   if (!alloc_node_storage(emitInfo, n, -1)) {
      return NULL;
   }

   inst = emit_instruction(emitInfo,
                           info->InstOpcode,
                           n->Store,  /* dest */
                           (info->NumParams > 0 ? n->Children[0]->Store : NULL),
                           (info->NumParams > 1 ? n->Children[1]->Store : NULL),
                           (info->NumParams > 2 ? n->Children[2]->Store : NULL)
                           );

   /* free temps */
   for (i = 0; i < info->NumParams; i++)
      free_node_storage(emitInfo->vt, n->Children[i]);

   return inst;
}


/**
 * Emit code for == and != operators.  These could normally be handled
 * by emit_arith() except we need to be able to handle structure comparisons.
 */
static struct prog_instruction *
emit_compare(slang_emit_info *emitInfo, slang_ir_node *n)
{
   struct prog_instruction *inst = NULL;
   GLint size;

   assert(n->Opcode == IR_EQUAL || n->Opcode == IR_NOTEQUAL);

   /* gen code for children */
   emit(emitInfo, n->Children[0]);
   emit(emitInfo, n->Children[1]);

   if (n->Children[0]->Store->Size != n->Children[1]->Store->Size) {
      /* XXX this error should have been caught in slang_codegen.c */
      slang_info_log_error(emitInfo->log, "invalid operands to == or !=");
      n->Store = NULL;
      return NULL;
   }

   /* final result is 1 bool */
   if (!alloc_node_storage(emitInfo, n, 1))
      return NULL;

   size = n->Children[0]->Store->Size;

   if (size == 1) {
      gl_inst_opcode opcode = n->Opcode == IR_EQUAL ? OPCODE_SEQ : OPCODE_SNE;
      inst =  emit_instruction(emitInfo,
                               opcode,
                               n->Store, /* dest */
                               n->Children[0]->Store,
                               n->Children[1]->Store,
                               NULL);
   }
   else if (size <= 4) {
      /* compare two vectors.
       * Unfortunately, there's no instruction to compare vectors and
       * return a scalar result.  Do it with some compare and dot product
       * instructions...
       */
      GLuint swizzle;
      gl_inst_opcode dotOp;
      slang_ir_storage tempStore;

      if (!alloc_local_temp(emitInfo, &tempStore, 4)) {
         n->Store = NULL;
         return NULL;
         /* out of temps */
      }

      if (size == 4) {
         dotOp = OPCODE_DP4;
         swizzle = SWIZZLE_XYZW;
      }
      else if (size == 3) {
         dotOp = OPCODE_DP3;
         swizzle = SWIZZLE_XYZW;
      }
      else {
         assert(size == 2);
         dotOp = OPCODE_DP3; /* XXX use OPCODE_DP2 eventually */
         swizzle = MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Y, SWIZZLE_Y);
      }

      /* Compute inequality (temp = (A != B)) */
      inst = emit_instruction(emitInfo,
                              OPCODE_SNE,
                              &tempStore,
                              n->Children[0]->Store,
                              n->Children[1]->Store,
                              NULL);
      if (!inst) {
         return NULL;
      }
      inst_comment(inst, "Compare values");

      /* Compute val = DOT(temp, temp)  (reduction) */
      inst = emit_instruction(emitInfo,
                              dotOp,
                              n->Store,
                              &tempStore,
                              &tempStore,
                              NULL);
      if (!inst) {
         return NULL;
      }
      inst->SrcReg[0].Swizzle = inst->SrcReg[1].Swizzle = swizzle; /*override*/
      inst_comment(inst, "Reduce vec to bool");

      _slang_free_temp(emitInfo->vt, &tempStore); /* free temp */

      if (n->Opcode == IR_EQUAL) {
         /* compute val = !val.x  with SEQ val, val, 0; */
         slang_ir_storage zero;
         constant_to_storage(emitInfo, 0.0, &zero);
         inst = emit_instruction(emitInfo,
                                 OPCODE_SEQ,
                                 n->Store, /* dest */
                                 n->Store,
                                 &zero,
                                 NULL);
         if (!inst) {
            return NULL;
         }
         inst_comment(inst, "Invert true/false");
      }
   }
   else {
      /* size > 4, struct or array compare.
       * XXX this won't work reliably for structs with padding!!
       */
      GLint i, num = (n->Children[0]->Store->Size + 3) / 4;
      slang_ir_storage accTemp, sneTemp;

      if (!alloc_local_temp(emitInfo, &accTemp, 4))
         return NULL;

      if (!alloc_local_temp(emitInfo, &sneTemp, 4))
         return NULL;

      for (i = 0; i < num; i++) {
         slang_ir_storage srcStore0 = *n->Children[0]->Store;
         slang_ir_storage srcStore1 = *n->Children[1]->Store;
         srcStore0.Index += i;
         srcStore1.Index += i;

         if (i == 0) {
            /* SNE accTemp, left[i], right[i] */
            inst = emit_instruction(emitInfo, OPCODE_SNE,
                                    &accTemp, /* dest */
                                    &srcStore0,
                                    &srcStore1,
                                    NULL);
            if (!inst) {
               return NULL;
            }
            inst_comment(inst, "Begin struct/array comparison");
         }
         else {
            /* SNE sneTemp, left[i], right[i] */
            inst = emit_instruction(emitInfo, OPCODE_SNE,
                                    &sneTemp, /* dest */
                                    &srcStore0,
                                    &srcStore1,
                                    NULL);
            if (!inst) {
               return NULL;
            }
            /* ADD accTemp, accTemp, sneTemp; # like logical-OR */
            inst = emit_instruction(emitInfo, OPCODE_ADD,
                                    &accTemp, /* dest */
                                    &accTemp,
                                    &sneTemp,
                                    NULL);
            if (!inst) {
               return NULL;
            }
         }
      }

      /* compute accTemp.x || accTemp.y || accTemp.z || accTemp.w with DOT4 */
      inst = emit_instruction(emitInfo, OPCODE_DP4,
                              n->Store,
                              &accTemp,
                              &accTemp,
                              NULL);
      if (!inst) {
         return NULL;
      }
      inst_comment(inst, "End struct/array comparison");

      if (n->Opcode == IR_EQUAL) {
         /* compute tmp.x = !tmp.x  via tmp.x = (tmp.x == 0) */
         slang_ir_storage zero;
         constant_to_storage(emitInfo, 0.0, &zero);
         inst = emit_instruction(emitInfo, OPCODE_SEQ,
                                 n->Store, /* dest */
                                 n->Store,
                                 &zero,
                                 NULL);
         if (!inst) {
            return NULL;
         }
         inst_comment(inst, "Invert true/false");
      }

      _slang_free_temp(emitInfo->vt, &accTemp);
      _slang_free_temp(emitInfo->vt, &sneTemp);
   }

   /* free temps */
   free_node_storage(emitInfo->vt, n->Children[0]);
   free_node_storage(emitInfo->vt, n->Children[1]);

   return inst;
}



/**
 * Generate code for an IR_CLAMP instruction.
 */
static struct prog_instruction *
emit_clamp(slang_emit_info *emitInfo, slang_ir_node *n)
{
   struct prog_instruction *inst;
   slang_ir_node tmpNode;

   assert(n->Opcode == IR_CLAMP);
   /* ch[0] = value
    * ch[1] = min limit
    * ch[2] = max limit
    */

   inst = emit(emitInfo, n->Children[0]);

   /* If lower limit == 0.0 and upper limit == 1.0,
    *    set prev instruction's SaturateMode field to SATURATE_ZERO_ONE.
    * Else,
    *    emit OPCODE_MIN, OPCODE_MAX sequence.
    */
#if 0
   /* XXX this isn't quite finished yet */
   if (n->Children[1]->Opcode == IR_FLOAT &&
       n->Children[1]->Value[0] == 0.0 &&
       n->Children[1]->Value[1] == 0.0 &&
       n->Children[1]->Value[2] == 0.0 &&
       n->Children[1]->Value[3] == 0.0 &&
       n->Children[2]->Opcode == IR_FLOAT &&
       n->Children[2]->Value[0] == 1.0 &&
       n->Children[2]->Value[1] == 1.0 &&
       n->Children[2]->Value[2] == 1.0 &&
       n->Children[2]->Value[3] == 1.0) {
      if (!inst) {
         inst = prev_instruction(prog);
      }
      if (inst && inst->Opcode != OPCODE_NOP) {
         /* and prev instruction's DstReg matches n->Children[0]->Store */
         inst->SaturateMode = SATURATE_ZERO_ONE;
         n->Store = n->Children[0]->Store;
         return inst;
      }
   }
#else
   (void) inst;
#endif

   if (!alloc_node_storage(emitInfo, n, n->Children[0]->Store->Size))
      return NULL;

   emit(emitInfo, n->Children[1]);
   emit(emitInfo, n->Children[2]);

   /* Some GPUs don't allow reading from output registers.  So if the
    * dest for this clamp() is an output reg, we can't use that reg for
    * the intermediate result.  Use a temp register instead.
    */
   memset(&tmpNode, 0, sizeof(tmpNode));
   if (!alloc_node_storage(emitInfo, &tmpNode, n->Store->Size)) {
      return NULL;
   }

   /* tmp = max(ch[0], ch[1]) */
   inst = emit_instruction(emitInfo, OPCODE_MAX,
                           tmpNode.Store, /* dest */
                           n->Children[0]->Store,
                           n->Children[1]->Store,
                           NULL);
   if (!inst) {
      return NULL;
   }

   /* n->dest = min(tmp, ch[2]) */
   inst = emit_instruction(emitInfo, OPCODE_MIN,
                           n->Store, /* dest */
                           tmpNode.Store,
                           n->Children[2]->Store,
                           NULL);

   free_node_storage(emitInfo->vt, &tmpNode);

   return inst;
}


static struct prog_instruction *
emit_negation(slang_emit_info *emitInfo, slang_ir_node *n)
{
   /* Implement as MOV dst, -src; */
   /* XXX we could look at the previous instruction and in some circumstances
    * modify it to accomplish the negation.
    */
   struct prog_instruction *inst;

   emit(emitInfo, n->Children[0]);

   if (!alloc_node_storage(emitInfo, n, n->Children[0]->Store->Size))
      return NULL;

   inst = emit_instruction(emitInfo,
                           OPCODE_MOV,
                           n->Store, /* dest */
                           n->Children[0]->Store,
                           NULL,
                           NULL);
   if (inst) {
      inst->SrcReg[0].Negate = NEGATE_XYZW;
   }
   return inst;
}


static struct prog_instruction *
emit_label(slang_emit_info *emitInfo, const slang_ir_node *n)
{
   assert(n->Label);
#if 0
   /* XXX this fails in loop tail code - investigate someday */
   assert(_slang_label_get_location(n->Label) < 0);
   _slang_label_set_location(n->Label, emitInfo->prog->NumInstructions,
                             emitInfo->prog);
#else
   if (_slang_label_get_location(n->Label) < 0)
      _slang_label_set_location(n->Label, emitInfo->prog->NumInstructions,
                                emitInfo->prog);
#endif
   return NULL;
}


/**
 * Emit code for a function call.
 * Note that for each time a function is called, we emit the function's
 * body code again because the set of available registers may be different.
 */
static struct prog_instruction *
emit_fcall(slang_emit_info *emitInfo, slang_ir_node *n)
{
   struct gl_program *progSave;
   struct prog_instruction *inst;
   GLuint subroutineId;
   GLuint maxInstSave;

   assert(n->Opcode == IR_CALL);
   assert(n->Label);

   /* save/push cur program */
   maxInstSave = emitInfo->MaxInstructions;
   progSave = emitInfo->prog;

   emitInfo->prog = new_subroutine(emitInfo, &subroutineId);
   emitInfo->MaxInstructions = emitInfo->prog->NumInstructions;

   _slang_label_set_location(n->Label, emitInfo->prog->NumInstructions,
                             emitInfo->prog);

   if (emitInfo->EmitBeginEndSub) {
      /* BGNSUB isn't a real instruction.
       * We require a label (i.e. "foobar:") though, if we're going to
       * print the program in the NV format.  The BNGSUB instruction is
       * really just a NOP to attach the label to.
       */
      inst = new_instruction(emitInfo, OPCODE_BGNSUB);
      if (!inst) {
         return NULL;
      }
      inst_comment(inst, n->Label->Name);
   }

   /* body of function: */
   emit(emitInfo, n->Children[0]);
   n->Store = n->Children[0]->Store;

   /* add RET instruction now, if needed */
   inst = prev_instruction(emitInfo);
   if (inst && inst->Opcode != OPCODE_RET) {
      inst = new_instruction(emitInfo, OPCODE_RET);
      if (!inst) {
         return NULL;
      }
   }

   if (emitInfo->EmitBeginEndSub) {
      inst = new_instruction(emitInfo, OPCODE_ENDSUB);
      if (!inst) {
         return NULL;
      }
      inst_comment(inst, n->Label->Name);
   }

   /* pop/restore cur program */
   emitInfo->prog = progSave;
   emitInfo->MaxInstructions = maxInstSave;

   /* emit the function call */
   inst = new_instruction(emitInfo, OPCODE_CAL);
   if (!inst) {
      return NULL;
   }
   /* The branch target is just the subroutine number (changed later) */
   inst->BranchTarget = subroutineId;
   inst_comment(inst, n->Label->Name);
   assert(inst->BranchTarget >= 0);

   return inst;
}


/**
 * Emit code for a 'return' statement.
 */
static struct prog_instruction *
emit_return(slang_emit_info *emitInfo, slang_ir_node *n)
{
   struct prog_instruction *inst;
   assert(n);
   assert(n->Opcode == IR_RETURN);
   assert(n->Label);
   inst = new_instruction(emitInfo, OPCODE_RET);
   if (inst) {
      inst->DstReg.CondMask = COND_TR;  /* always return */
   }
   return inst;
}


static struct prog_instruction *
emit_kill(slang_emit_info *emitInfo)
{
   struct gl_fragment_program *fp;
   struct prog_instruction *inst;
   /* NV-KILL - discard fragment depending on condition code.
    * Note that ARB-KILL depends on sign of vector operand.
    */
   inst = new_instruction(emitInfo, OPCODE_KIL_NV);
   if (!inst) {
      return NULL;
   }
   inst->DstReg.CondMask = COND_TR;  /* always kill */

   assert(emitInfo->prog->Target == GL_FRAGMENT_PROGRAM_ARB);
   fp = (struct gl_fragment_program *) emitInfo->prog;
   fp->UsesKill = GL_TRUE;

   return inst;
}


static struct prog_instruction *
emit_tex(slang_emit_info *emitInfo, slang_ir_node *n)
{
   struct prog_instruction *inst;
   gl_inst_opcode opcode;
   GLboolean shadow = GL_FALSE;

   switch (n->Opcode) {
   case IR_TEX:
      opcode = OPCODE_TEX;
      break;
   case IR_TEX_SH:
      opcode = OPCODE_TEX;
      shadow = GL_TRUE;
      break;
   case IR_TEXB:
      opcode = OPCODE_TXB;
      break;
   case IR_TEXB_SH:
      opcode = OPCODE_TXB;
      shadow = GL_TRUE;
      break;
   case IR_TEXP:
      opcode = OPCODE_TXP;
      break;
   case IR_TEXP_SH:
      opcode = OPCODE_TXP;
      shadow = GL_TRUE;
      break;
   default:
      _mesa_problem(NULL, "Bad IR TEX code");
      return NULL;
   }

   if (n->Children[0]->Opcode == IR_ELEMENT) {
      /* array is the sampler (a uniform which'll indicate the texture unit) */
      assert(n->Children[0]->Children[0]->Store);
      assert(n->Children[0]->Children[0]->Store->File == PROGRAM_SAMPLER);

      emit(emitInfo, n->Children[0]);

      n->Children[0]->Var = n->Children[0]->Children[0]->Var;
   } else {
      /* this is the sampler (a uniform which'll indicate the texture unit) */
      assert(n->Children[0]->Store);
      assert(n->Children[0]->Store->File == PROGRAM_SAMPLER);
   }

   /* emit code for the texcoord operand */
   (void) emit(emitInfo, n->Children[1]);

   /* alloc storage for result of texture fetch */
   if (!alloc_node_storage(emitInfo, n, 4))
      return NULL;

   /* emit TEX instruction;  Child[1] is the texcoord */
   inst = emit_instruction(emitInfo,
                           opcode,
                           n->Store,
                           n->Children[1]->Store,
                           NULL,
                           NULL);
   if (!inst) {
      return NULL;
   }

   inst->TexShadow = shadow;

   /* Store->Index is the uniform/sampler index */
   assert(n->Children[0]->Store->Index >= 0);
   inst->TexSrcUnit = n->Children[0]->Store->Index;
   inst->TexSrcTarget = n->Children[0]->Store->TexTarget;

   /* mark the sampler as being used */
   _mesa_use_uniform(emitInfo->prog->Parameters,
                     (char *) n->Children[0]->Var->a_name);

   return inst;
}


/**
 * Assignment/copy
 */
static struct prog_instruction *
emit_copy(slang_emit_info *emitInfo, slang_ir_node *n)
{
   struct prog_instruction *inst;

   assert(n->Opcode == IR_COPY);

   /* lhs */
   emit(emitInfo, n->Children[0]);
   if (!n->Children[0]->Store || n->Children[0]->Store->Index < 0) {
      /* an error should have been already recorded */
      return NULL;
   }

   /* rhs */
   assert(n->Children[1]);
   inst = emit(emitInfo, n->Children[1]);

   if (!n->Children[1]->Store || n->Children[1]->Store->Index < 0) {
      if (!emitInfo->log->text && !emitInfo->UnresolvedFunctions) {
         /* XXX this error should have been caught in slang_codegen.c */
         slang_info_log_error(emitInfo->log, "invalid assignment");
      }
      return NULL;
   }

   assert(n->Children[1]->Store->Index >= 0);

   /*assert(n->Children[0]->Store->Size == n->Children[1]->Store->Size);*/

   n->Store = n->Children[0]->Store;

   if (n->Store->File == PROGRAM_SAMPLER) {
      /* no code generated for sampler assignments,
       * just copy the sampler index/target at compile time.
       */
      n->Store->Index = n->Children[1]->Store->Index;
      n->Store->TexTarget = n->Children[1]->Store->TexTarget;
      return NULL;
   }

#if PEEPHOLE_OPTIMIZATIONS
   if (inst &&
       (n->Children[1]->Opcode != IR_SWIZZLE) &&
       _slang_is_temp(emitInfo->vt, n->Children[1]->Store) &&
       (inst->DstReg.File == n->Children[1]->Store->File) &&
       (inst->DstReg.Index == n->Children[1]->Store->Index) &&
       !n->Children[0]->Store->IsIndirect &&
       n->Children[0]->Store->Size <= 4) {
      /* Peephole optimization:
       * The Right-Hand-Side has its results in a temporary place.
       * Modify the RHS (and the prev instruction) to store its results
       * in the destination specified by n->Children[0].
       * Then, this MOVE is a no-op.
       * Ex:
       *   MUL tmp, x, y;
       *   MOV a, tmp;
       * becomes:
       *   MUL a, x, y;
       */

      /* fixup the previous instruction (which stored the RHS result) */
      assert(n->Children[0]->Store->Index >= 0);
      storage_to_dst_reg(&inst->DstReg, n->Children[0]->Store);
      return inst;
   }
   else
#endif
   {
      if (n->Children[0]->Store->Size > 4) {
         /* move matrix/struct etc (block of registers) */
         slang_ir_storage dstStore = *n->Children[0]->Store;
         slang_ir_storage srcStore = *n->Children[1]->Store;
         GLint size = srcStore.Size;
         ASSERT(n->Children[1]->Store->Swizzle == SWIZZLE_NOOP);
         dstStore.Size = 4;
         srcStore.Size = 4;
         while (size >= 4) {
            inst = emit_instruction(emitInfo, OPCODE_MOV,
                                    &dstStore,
                                    &srcStore,
                                    NULL,
                                    NULL);
            if (!inst) {
               return NULL;
            }
            inst_comment(inst, "IR_COPY block");
            srcStore.Index++;
            dstStore.Index++;
            size -= 4;
         }
      }
      else {
         /* single register move */
         char *srcAnnot, *dstAnnot;
         assert(n->Children[0]->Store->Index >= 0);
         inst = emit_instruction(emitInfo, OPCODE_MOV,
                                 n->Children[0]->Store, /* dest */
                                 n->Children[1]->Store,
                                 NULL,
                                 NULL);
         if (!inst) {
            return NULL;
         }
         dstAnnot = storage_annotation(n->Children[0], emitInfo->prog);
         srcAnnot = storage_annotation(n->Children[1], emitInfo->prog);
         inst->Comment = instruction_annotation(inst->Opcode, dstAnnot,
                                                srcAnnot, NULL, NULL);
      }
      free_node_storage(emitInfo->vt, n->Children[1]);
      return inst;
   }
}


/**
 * An IR_COND node wraps a boolean expression which is used by an
 * IF or WHILE test.  This is where we'll set condition codes, if needed.
 */
static struct prog_instruction *
emit_cond(slang_emit_info *emitInfo, slang_ir_node *n)
{
   struct prog_instruction *inst;

   assert(n->Opcode == IR_COND);

   if (!n->Children[0])
      return NULL;

   /* emit code for the expression */
   inst = emit(emitInfo, n->Children[0]);

   if (!n->Children[0]->Store) {
      /* error recovery */
      return NULL;
   }

   assert(n->Children[0]->Store);
   /*assert(n->Children[0]->Store->Size == 1);*/

   if (emitInfo->EmitCondCodes) {
      if (inst &&
          n->Children[0]->Store &&
          inst->DstReg.File == n->Children[0]->Store->File &&
          inst->DstReg.Index == n->Children[0]->Store->Index) {
         /* The previous instruction wrote to the register who's value
          * we're testing.  Just fix that instruction so that the
          * condition codes are computed.
          */
         inst->CondUpdate = GL_TRUE;
         n->Store = n->Children[0]->Store;
         return inst;
      }
      else {
         /* This'll happen for things like "if (i) ..." where no code
          * is normally generated for the expression "i".
          * Generate a move instruction just to set condition codes.
          */
         if (!alloc_node_storage(emitInfo, n, 1))
            return NULL;
         inst = emit_instruction(emitInfo, OPCODE_MOV,
                                 n->Store, /* dest */
                                 n->Children[0]->Store,
                                 NULL,
                                 NULL);
         if (!inst) {
            return NULL;
         }
         inst->CondUpdate = GL_TRUE;
         inst_comment(inst, "COND expr");
         _slang_free_temp(emitInfo->vt, n->Store);
         return inst;
      }
   }
   else {
      /* No-op: the boolean result of the expression is in a regular reg */
      n->Store = n->Children[0]->Store;
      return inst;
   }
}


/**
 * Logical-NOT
 */
static struct prog_instruction *
emit_not(slang_emit_info *emitInfo, slang_ir_node *n)
{
   static const struct {
      gl_inst_opcode op, opNot;
   } operators[] = {
      { OPCODE_SLT, OPCODE_SGE },
      { OPCODE_SLE, OPCODE_SGT },
      { OPCODE_SGT, OPCODE_SLE },
      { OPCODE_SGE, OPCODE_SLT },
      { OPCODE_SEQ, OPCODE_SNE },
      { OPCODE_SNE, OPCODE_SEQ },
      { 0, 0 }
   };
   struct prog_instruction *inst;
   slang_ir_storage zero;
   GLuint i;

   /* child expr */
   inst = emit(emitInfo, n->Children[0]);

#if PEEPHOLE_OPTIMIZATIONS
   if (inst) {
      /* if the prev instruction was a comparison instruction, invert it */
      for (i = 0; operators[i].op; i++) {
         if (inst->Opcode == operators[i].op) {
            inst->Opcode = operators[i].opNot;
            n->Store = n->Children[0]->Store;
            return inst;
         }
      }
   }
#endif

   /* else, invert using SEQ (v = v == 0) */
   if (!alloc_node_storage(emitInfo, n, n->Children[0]->Store->Size))
      return NULL;

   constant_to_storage(emitInfo, 0.0, &zero);
   inst = emit_instruction(emitInfo,
                           OPCODE_SEQ,
                           n->Store,
                           n->Children[0]->Store,
                           &zero,
                           NULL);
   if (!inst) {
      return NULL;
   }
   inst_comment(inst, "NOT");

   free_node_storage(emitInfo->vt, n->Children[0]);

   return inst;
}


static struct prog_instruction *
emit_if(slang_emit_info *emitInfo, slang_ir_node *n)
{
   struct gl_program *prog = emitInfo->prog;
   GLuint ifInstLoc, elseInstLoc = 0;
   GLuint condWritemask = 0;

   /* emit condition expression code */
   {
      struct prog_instruction *inst;
      inst = emit(emitInfo, n->Children[0]);
      if (emitInfo->EmitCondCodes) {
         if (!inst) {
            /* error recovery */
            return NULL;
         }
         condWritemask = inst->DstReg.WriteMask;
      }
   }

   if (!n->Children[0]->Store)
      return NULL;

#if 0
   assert(n->Children[0]->Store->Size == 1); /* a bool! */
#endif

   ifInstLoc = prog->NumInstructions;
   if (emitInfo->EmitHighLevelInstructions) {
      if (emitInfo->EmitCondCodes) {
         /* IF condcode THEN ... */
         struct prog_instruction *ifInst = new_instruction(emitInfo, OPCODE_IF);
         if (!ifInst) {
            return NULL;
         }
         ifInst->DstReg.CondMask = COND_NE;  /* if cond is non-zero */
         /* only test the cond code (1 of 4) that was updated by the
          * previous instruction.
          */
         ifInst->DstReg.CondSwizzle = writemask_to_swizzle(condWritemask);
      }
      else {
         struct prog_instruction *inst;

         /* IF src[0] THEN ... */
         inst = emit_instruction(emitInfo, OPCODE_IF,
                                 NULL, /* dst */
                                 n->Children[0]->Store, /* op0 */
                                 NULL,
                                 NULL);
         if (!inst) {
            return NULL;
         }
      }
   }
   else {
      /* conditional jump to else, or endif */
      struct prog_instruction *ifInst = new_instruction(emitInfo, OPCODE_BRA);
      if (!ifInst) {
         return NULL;
      }
      ifInst->DstReg.CondMask = COND_EQ;  /* BRA if cond is zero */
      inst_comment(ifInst, "if zero");
      ifInst->DstReg.CondSwizzle = writemask_to_swizzle(condWritemask);
   }

   /* if body */
   emit(emitInfo, n->Children[1]);

   if (n->Children[2]) {
      /* have else body */
      elseInstLoc = prog->NumInstructions;
      if (emitInfo->EmitHighLevelInstructions) {
         struct prog_instruction *inst = new_instruction(emitInfo, OPCODE_ELSE);
         if (!inst) {
            return NULL;
         }
         prog->Instructions[ifInstLoc].BranchTarget = prog->NumInstructions - 1;
      }
      else {
         /* jump to endif instruction */
         struct prog_instruction *inst = new_instruction(emitInfo, OPCODE_BRA);
         if (!inst) {
            return NULL;
         }
         inst_comment(inst, "else");
         inst->DstReg.CondMask = COND_TR;  /* always branch */
         prog->Instructions[ifInstLoc].BranchTarget = prog->NumInstructions;
      }
      emit(emitInfo, n->Children[2]);
   }
   else {
      /* no else body */
      prog->Instructions[ifInstLoc].BranchTarget = prog->NumInstructions;
   }

   if (emitInfo->EmitHighLevelInstructions) {
      struct prog_instruction *inst = new_instruction(emitInfo, OPCODE_ENDIF);
      if (!inst) {
         return NULL;
      }
   }

   if (elseInstLoc) {
      /* point ELSE instruction BranchTarget at ENDIF */
      if (emitInfo->EmitHighLevelInstructions) {
         prog->Instructions[elseInstLoc].BranchTarget = prog->NumInstructions - 1;
      }
      else {
         prog->Instructions[elseInstLoc].BranchTarget = prog->NumInstructions;
      }
   }
   return NULL;
}


static struct prog_instruction *
emit_loop(slang_emit_info *emitInfo, slang_ir_node *n)
{
   struct gl_program *prog = emitInfo->prog;
   struct prog_instruction *endInst;
   GLuint beginInstLoc, tailInstLoc, endInstLoc;
   slang_ir_node *ir;

   /* emit OPCODE_BGNLOOP */
   beginInstLoc = prog->NumInstructions;
   if (emitInfo->EmitHighLevelInstructions) {
      struct prog_instruction *inst = new_instruction(emitInfo, OPCODE_BGNLOOP);
      if (!inst) {
         return NULL;
      }
   }

   /* body */
   emit(emitInfo, n->Children[0]);

   /* tail */
   tailInstLoc = prog->NumInstructions;
   if (n->Children[1]) {
      if (emitInfo->EmitComments)
         emit_comment(emitInfo, "Loop tail code:");
      emit(emitInfo, n->Children[1]);
   }

   endInstLoc = prog->NumInstructions;
   if (emitInfo->EmitHighLevelInstructions) {
      /* emit OPCODE_ENDLOOP */
      endInst = new_instruction(emitInfo, OPCODE_ENDLOOP);
      if (!endInst) {
         return NULL;
      }
   }
   else {
      /* emit unconditional BRA-nch */
      endInst = new_instruction(emitInfo, OPCODE_BRA);
      if (!endInst) {
         return NULL;
      }
      endInst->DstReg.CondMask = COND_TR;  /* always true */
   }
   /* ENDLOOP's BranchTarget points to the BGNLOOP inst */
   endInst->BranchTarget = beginInstLoc;

   if (emitInfo->EmitHighLevelInstructions) {
      /* BGNLOOP's BranchTarget points to the ENDLOOP inst */
      prog->Instructions[beginInstLoc].BranchTarget = prog->NumInstructions -1;
   }

   /* Done emitting loop code.  Now walk over the loop's linked list of
    * BREAK and CONT nodes, filling in their BranchTarget fields (which
    * will point to the corresponding ENDLOOP instruction.
    */
   for (ir = n->List; ir; ir = ir->List) {
      struct prog_instruction *inst = prog->Instructions + ir->InstLocation;
      assert(inst->BranchTarget < 0);
      if (ir->Opcode == IR_BREAK ||
          ir->Opcode == IR_BREAK_IF_TRUE) {
         assert(inst->Opcode == OPCODE_BRK ||
                inst->Opcode == OPCODE_BRA);
         /* go to instruction at end of loop */
         if (emitInfo->EmitHighLevelInstructions) {
            inst->BranchTarget = endInstLoc;
         }
         else {
            inst->BranchTarget = endInstLoc + 1;
         }
      }
      else {
         assert(ir->Opcode == IR_CONT ||
                ir->Opcode == IR_CONT_IF_TRUE);
         assert(inst->Opcode == OPCODE_CONT ||
                inst->Opcode == OPCODE_BRA);
         /* go to instruction at tail of loop */
         inst->BranchTarget = endInstLoc;
      }
   }
   return NULL;
}


/**
 * Unconditional "continue" or "break" statement.
 * Either OPCODE_CONT, OPCODE_BRK or OPCODE_BRA will be emitted.
 */
static struct prog_instruction *
emit_cont_break(slang_emit_info *emitInfo, slang_ir_node *n)
{
   gl_inst_opcode opcode;
   struct prog_instruction *inst;

   if (n->Opcode == IR_CONT) {
      /* we need to execute the loop's tail code before doing CONT */
      assert(n->Parent);
      assert(n->Parent->Opcode == IR_LOOP);
      if (n->Parent->Children[1]) {
         /* emit tail code */
         if (emitInfo->EmitComments) {
            emit_comment(emitInfo, "continue - tail code:");
         }
         emit(emitInfo, n->Parent->Children[1]);
      }
   }

   /* opcode selection */
   if (emitInfo->EmitHighLevelInstructions) {
      opcode = (n->Opcode == IR_CONT) ? OPCODE_CONT : OPCODE_BRK;
   }
   else {
      opcode = OPCODE_BRA;
   }
   n->InstLocation = emitInfo->prog->NumInstructions;
   inst = new_instruction(emitInfo, opcode);
   if (inst) {
      inst->DstReg.CondMask = COND_TR;  /* always true */
   }
   return inst;
}


/**
 * Conditional "continue" or "break" statement.
 * Either OPCODE_CONT, OPCODE_BRK or OPCODE_BRA will be emitted.
 */
static struct prog_instruction *
emit_cont_break_if_true(slang_emit_info *emitInfo, slang_ir_node *n)
{
   struct prog_instruction *inst;

   assert(n->Opcode == IR_CONT_IF_TRUE ||
          n->Opcode == IR_BREAK_IF_TRUE);

   /* evaluate condition expr, setting cond codes */
   inst = emit(emitInfo, n->Children[0]);
   if (emitInfo->EmitCondCodes) {
      assert(inst);
      inst->CondUpdate = GL_TRUE;
   }

   n->InstLocation = emitInfo->prog->NumInstructions;

   /* opcode selection */
   if (emitInfo->EmitHighLevelInstructions) {
      const gl_inst_opcode opcode
         = (n->Opcode == IR_CONT_IF_TRUE) ? OPCODE_CONT : OPCODE_BRK;
      if (emitInfo->EmitCondCodes) {
         /* Get the writemask from the previous instruction which set
          * the condcodes.  Use that writemask as the CondSwizzle.
          */
         const GLuint condWritemask = inst->DstReg.WriteMask;
         inst = new_instruction(emitInfo, opcode);
         if (inst) {
            inst->DstReg.CondMask = COND_NE;
            inst->DstReg.CondSwizzle = writemask_to_swizzle(condWritemask);
         }
         return inst;
      }
      else {
         /* IF reg
          *    BRK/CONT;
          * ENDIF
          */
         GLint ifInstLoc;
         ifInstLoc = emitInfo->prog->NumInstructions;
         inst = emit_instruction(emitInfo, OPCODE_IF,
                                 NULL, /* dest */
                                 n->Children[0]->Store,
                                 NULL,
                                 NULL);
         if (!inst) {
            return NULL;
         }
         n->InstLocation = emitInfo->prog->NumInstructions;

         inst = new_instruction(emitInfo, opcode);
         if (!inst) {
            return NULL;
         }
         inst = new_instruction(emitInfo, OPCODE_ENDIF);
         if (!inst) {
            return NULL;
         }

         emitInfo->prog->Instructions[ifInstLoc].BranchTarget
            = emitInfo->prog->NumInstructions - 1;
         return inst;
      }
   }
   else {
      const GLuint condWritemask = inst->DstReg.WriteMask;
      assert(emitInfo->EmitCondCodes);
      inst = new_instruction(emitInfo, OPCODE_BRA);
      if (inst) {
         inst->DstReg.CondMask = COND_NE;
         inst->DstReg.CondSwizzle = writemask_to_swizzle(condWritemask);
      }
      return inst;
   }
}


/**
 * Return the size of a swizzle mask given that some swizzle components
 * may be NIL/undefined.  For example:
 *  swizzle_size(".zzxx") = 4
 *  swizzle_size(".xy??") = 2
 *  swizzle_size(".w???") = 1
 */
static GLuint
swizzle_size(GLuint swizzle)
{
   GLuint i;
   for (i = 0; i < 4; i++) {
      if (GET_SWZ(swizzle, i) == SWIZZLE_NIL)
         return i;
   }
   return 4;
}


static struct prog_instruction *
emit_swizzle(slang_emit_info *emitInfo, slang_ir_node *n)
{
   struct prog_instruction *inst;

   inst = emit(emitInfo, n->Children[0]);

   if (!n->Store->Parent) {
      /* this covers a case such as "(b ? p : q).x" */
      n->Store->Parent = n->Children[0]->Store;
      assert(n->Store->Parent);
   }

   {
      const GLuint swizzle = n->Store->Swizzle;
      /* new storage is parent storage with updated Swizzle + Size fields */
      _slang_copy_ir_storage(n->Store, n->Store->Parent);
      /* Apply this node's swizzle to parent's storage */
      n->Store->Swizzle = _slang_swizzle_swizzle(n->Store->Swizzle, swizzle);
      /* Update size */
      n->Store->Size = swizzle_size(n->Store->Swizzle);
   }

   assert(!n->Store->Parent);
   assert(n->Store->Index >= 0);

   return inst;
}


/**
 * Dereference array element:  element == array[index]
 * This basically involves emitting code for computing the array index
 * and updating the node/element's storage info.
 */
static struct prog_instruction *
emit_array_element(slang_emit_info *emitInfo, slang_ir_node *n)
{
   slang_ir_storage *arrayStore, *indexStore;
   const int elemSize = n->Store->Size;           /* number of floats */
   const GLint elemSizeVec = (elemSize + 3) / 4;  /* number of vec4 */
   struct prog_instruction *inst;

   assert(n->Opcode == IR_ELEMENT);
   assert(elemSize > 0);

   /* special case for built-in state variables, like light state */
   {
      slang_ir_storage *root = n->Store;
      assert(!root->Parent);
      while (root->Parent)
         root = root->Parent;

      if (root->File == PROGRAM_STATE_VAR) {
         GLboolean direct;
         GLint index =
            _slang_alloc_statevar(n, emitInfo->prog->Parameters, &direct);
         if (index < 0) {
            /* error */
            return NULL;
         }
         if (direct) {
            n->Store->Index = index;
            return NULL; /* all done */
         }
      }
   }

   /* do codegen for array itself */
   emit(emitInfo, n->Children[0]);
   arrayStore = n->Children[0]->Store;

   /* The initial array element storage is the array's storage,
    * then modified below.
    */
   _slang_copy_ir_storage(n->Store, arrayStore);


   if (n->Children[1]->Opcode == IR_FLOAT) {
      /* Constant array index */
      const GLint element = (GLint) n->Children[1]->Value[0];

      /* this element's storage is the array's storage, plus constant offset */
      n->Store->Index += elemSizeVec * element;
   }
   else {
      /* Variable array index */

      /* do codegen for array index expression */
      emit(emitInfo, n->Children[1]);
      indexStore = n->Children[1]->Store;

      if (indexStore->IsIndirect) {
         /* need to put the array index into a temporary since we can't
          * directly support a[b[i]] constructs.
          */


         /*indexStore = tempstore();*/
      }


      if (elemSize > 4) {
         /* need to multiply array index by array element size */
         struct prog_instruction *inst;
         slang_ir_storage *indexTemp;
         slang_ir_storage elemSizeStore;

         /* allocate 1 float indexTemp */
         indexTemp = _slang_new_ir_storage(PROGRAM_TEMPORARY, -1, 1);
         _slang_alloc_temp(emitInfo->vt, indexTemp);

         /* allocate a constant containing the element size */
         constant_to_storage(emitInfo, (float) elemSizeVec, &elemSizeStore);

         /* multiply array index by element size */
         inst = emit_instruction(emitInfo,
                                 OPCODE_MUL,
                                 indexTemp, /* dest */
                                 indexStore, /* the index */
                                 &elemSizeStore,
                                 NULL);
         if (!inst) {
            return NULL;
         }

         indexStore = indexTemp;
      }

      if (arrayStore->IsIndirect) {
         /* ex: in a[i][j], a[i] (the arrayStore) is indirect */
         /* Need to add indexStore to arrayStore->Indirect store */
         slang_ir_storage indirectArray;
         slang_ir_storage *indexTemp;

         _slang_init_ir_storage(&indirectArray,
                                arrayStore->IndirectFile,
                                arrayStore->IndirectIndex,
                                1,
                                arrayStore->IndirectSwizzle);

         /* allocate 1 float indexTemp */
         indexTemp = _slang_new_ir_storage(PROGRAM_TEMPORARY, -1, 1);
         _slang_alloc_temp(emitInfo->vt, indexTemp);

         inst = emit_instruction(emitInfo,
                                 OPCODE_ADD,
                                 indexTemp,      /* dest */
                                 indexStore,     /* the index */
                                 &indirectArray, /* indirect array base */
                                 NULL);
         if (!inst) {
            return NULL;
         }

         indexStore = indexTemp;
      }

      /* update the array element storage info */
      n->Store->IsIndirect = GL_TRUE;
      n->Store->IndirectFile = indexStore->File;
      n->Store->IndirectIndex = indexStore->Index;
      n->Store->IndirectSwizzle = indexStore->Swizzle;
   }

   n->Store->Size = elemSize;
   n->Store->Swizzle = _slang_var_swizzle(elemSize, 0);

   return NULL; /* no instruction */
}


/**
 * Resolve storage for accessing a structure field.
 */
static struct prog_instruction *
emit_struct_field(slang_emit_info *emitInfo, slang_ir_node *n)
{
   slang_ir_storage *root = n->Store;
   GLint fieldOffset, fieldSize;

   assert(n->Opcode == IR_FIELD);

   assert(!root->Parent);
   while (root->Parent)
      root = root->Parent;

   /* If this is the field of a state var, allocate constant/uniform
    * storage for it now if we haven't already.
    * Note that we allocate storage (uniform/constant slots) for state
    * variables here rather than at declaration time so we only allocate
    * space for the ones that we actually use!
    */
   if (root->File == PROGRAM_STATE_VAR) {
      GLboolean direct;
      GLint index = _slang_alloc_statevar(n, emitInfo->prog->Parameters, &direct);
      if (index < 0) {
         slang_info_log_error(emitInfo->log, "Error parsing state variable");
         return NULL;
      }
      if (direct) {
         root->Index = index;
         return NULL; /* all done */
      }
   }

   /* do codegen for struct */
   emit(emitInfo, n->Children[0]);
   assert(n->Children[0]->Store->Index >= 0);


   fieldOffset = n->Store->Index;
   fieldSize = n->Store->Size;

   _slang_copy_ir_storage(n->Store, n->Children[0]->Store);

   n->Store->Index = n->Children[0]->Store->Index + fieldOffset / 4;
   n->Store->Size = fieldSize;

   switch (fieldSize) {
   case 1:
      {
         GLint swz = fieldOffset % 4;
         n->Store->Swizzle = MAKE_SWIZZLE4(swz, swz, swz, swz);
      }
      break;
   case 2:
      n->Store->Swizzle = MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y,
                                        SWIZZLE_NIL, SWIZZLE_NIL);
      break;
   case 3:
      n->Store->Swizzle = MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y,
                                        SWIZZLE_Z, SWIZZLE_NIL);
      break;
   default:
      n->Store->Swizzle = SWIZZLE_XYZW;
   }

   assert(n->Store->Index >= 0);

   return NULL; /* no instruction */
}


/**
 * Emit code for a variable declaration.
 * This usually doesn't result in any code generation, but just
 * memory allocation.
 */
static struct prog_instruction *
emit_var_decl(slang_emit_info *emitInfo, slang_ir_node *n)
{
   assert(n->Store);
   assert(n->Store->File != PROGRAM_UNDEFINED);
   assert(n->Store->Size > 0);
   /*assert(n->Store->Index < 0);*/

   if (!n->Var || n->Var->isTemp) {
      /* a nameless/temporary variable, will be freed after first use */
      /*NEW*/
      if (n->Store->Index < 0 && !_slang_alloc_temp(emitInfo->vt, n->Store)) {
         slang_info_log_error(emitInfo->log,
                              "Ran out of registers, too many temporaries");
         return NULL;
      }
   }
   else {
      /* a regular variable */
      _slang_add_variable(emitInfo->vt, n->Var);
      if (!_slang_alloc_var(emitInfo->vt, n->Store)) {
         slang_info_log_error(emitInfo->log,
                              "Ran out of registers, too many variables");
         return NULL;
      }
      /*
        printf("IR_VAR_DECL %s %d store %p\n",
        (char*) n->Var->a_name, n->Store->Index, (void*) n->Store);
      */
      assert(n->Var->store == n->Store);
   }
   if (emitInfo->EmitComments) {
      /* emit NOP with comment describing the variable's storage location */
      char s[1000];
      sprintf(s, "TEMP[%d]%s = variable %s (size %d)",
              n->Store->Index,
              _mesa_swizzle_string(n->Store->Swizzle, 0, GL_FALSE), 
              (n->Var ? (char *) n->Var->a_name : "anonymous"),
              n->Store->Size);
      emit_comment(emitInfo, s);
   }
   return NULL;
}


/**
 * Emit code for a reference to a variable.
 * Actually, no code is generated but we may do some memory allocation.
 * In particular, state vars (uniforms) are allocated on an as-needed basis.
 */
static struct prog_instruction *
emit_var_ref(slang_emit_info *emitInfo, slang_ir_node *n)
{
   assert(n->Store);
   assert(n->Store->File != PROGRAM_UNDEFINED);

   if (n->Store->File == PROGRAM_STATE_VAR && n->Store->Index < 0) {
      GLboolean direct;
      GLint index = _slang_alloc_statevar(n, emitInfo->prog->Parameters, &direct);
      if (index < 0) {
         /* error */
         char s[100];
         /* XXX isn't this really an out of memory/resources error? */
         _mesa_snprintf(s, sizeof(s), "Undefined variable '%s'",
		  (char *) n->Var->a_name);
         slang_info_log_error(emitInfo->log, s);
         return NULL;
      }

      n->Store->Index = index;
   }
   else if (n->Store->File == PROGRAM_UNIFORM ||
            n->Store->File == PROGRAM_SAMPLER) {
      /* mark var as used */
      _mesa_use_uniform(emitInfo->prog->Parameters, (char *) n->Var->a_name);
   }
   else if (n->Store->File == PROGRAM_INPUT) {
      assert(n->Store->Index >= 0);
      emitInfo->prog->InputsRead |= (1 << n->Store->Index);
   }

   if (n->Store->Index < 0) {
      /* probably ran out of registers */
      return NULL;
   }
   assert(n->Store->Size > 0);

   return NULL;
}


static struct prog_instruction *
emit(slang_emit_info *emitInfo, slang_ir_node *n)
{
   struct prog_instruction *inst;
   if (!n)
      return NULL;

   if (emitInfo->log->error_flag) {
      return NULL;
   }

   if (n->Comment) {
      inst = new_instruction(emitInfo, OPCODE_NOP);
      if (inst) {
         inst->Comment = _mesa_strdup(n->Comment);
      }
      inst = NULL;
   }

   switch (n->Opcode) {
   case IR_SEQ:
      /* sequence of two sub-trees */
      assert(n->Children[0]);
      assert(n->Children[1]);
      emit(emitInfo, n->Children[0]);
      if (emitInfo->log->error_flag)
         return NULL;
      inst = emit(emitInfo, n->Children[1]);
#if 0
      assert(!n->Store);
#endif
      n->Store = n->Children[1]->Store;
      return inst;

   case IR_SCOPE:
      /* new variable scope */
      _slang_push_var_table(emitInfo->vt);
      inst = emit(emitInfo, n->Children[0]);
      _slang_pop_var_table(emitInfo->vt);
      return inst;

   case IR_VAR_DECL:
      /* Variable declaration - allocate a register for it */
      inst = emit_var_decl(emitInfo, n);
      return inst;

   case IR_VAR:
      /* Reference to a variable
       * Storage should have already been resolved/allocated.
       */
      return emit_var_ref(emitInfo, n);

   case IR_ELEMENT:
      return emit_array_element(emitInfo, n);
   case IR_FIELD:
      return emit_struct_field(emitInfo, n);
   case IR_SWIZZLE:
      return emit_swizzle(emitInfo, n);

   /* Simple arithmetic */
   /* unary */
   case IR_MOVE:
   case IR_RSQ:
   case IR_RCP:
   case IR_FLOOR:
   case IR_FRAC:
   case IR_F_TO_I:
   case IR_I_TO_F:
   case IR_ABS:
   case IR_SIN:
   case IR_COS:
   case IR_DDX:
   case IR_DDY:
   case IR_EXP:
   case IR_EXP2:
   case IR_LOG2:
   case IR_NOISE1:
   case IR_NOISE2:
   case IR_NOISE3:
   case IR_NOISE4:
   case IR_NRM4:
   case IR_NRM3:
   /* binary */
   case IR_ADD:
   case IR_SUB:
   case IR_MUL:
   case IR_DOT4:
   case IR_DOT3:
   case IR_DOT2:
   case IR_CROSS:
   case IR_MIN:
   case IR_MAX:
   case IR_SEQUAL:
   case IR_SNEQUAL:
   case IR_SGE:
   case IR_SGT:
   case IR_SLE:
   case IR_SLT:
   case IR_POW:
   /* trinary operators */
   case IR_LRP:
   case IR_CMP:
      return emit_arith(emitInfo, n);

   case IR_EQUAL:
   case IR_NOTEQUAL:
      return emit_compare(emitInfo, n);

   case IR_CLAMP:
      return emit_clamp(emitInfo, n);
   case IR_TEX:
   case IR_TEXB:
   case IR_TEXP:
   case IR_TEX_SH:
   case IR_TEXB_SH:
   case IR_TEXP_SH:
      return emit_tex(emitInfo, n);
   case IR_NEG:
      return emit_negation(emitInfo, n);
   case IR_FLOAT:
      /* find storage location for this float constant */
      n->Store->Index = _mesa_add_unnamed_constant(emitInfo->prog->Parameters,
                                                   n->Value,
                                                   n->Store->Size,
                                                   &n->Store->Swizzle);
      if (n->Store->Index < 0) {
         slang_info_log_error(emitInfo->log, "Ran out of space for constants");
         return NULL;
      }
      return NULL;

   case IR_COPY:
      return emit_copy(emitInfo, n);

   case IR_COND:
      return emit_cond(emitInfo, n);

   case IR_NOT:
      return emit_not(emitInfo, n);

   case IR_LABEL:
      return emit_label(emitInfo, n);

   case IR_KILL:
      return emit_kill(emitInfo);

   case IR_CALL:
      /* new variable scope for subroutines/function calls */
      _slang_push_var_table(emitInfo->vt);
      inst = emit_fcall(emitInfo, n);
      _slang_pop_var_table(emitInfo->vt);
      return inst;

   case IR_IF:
      return emit_if(emitInfo, n);

   case IR_LOOP:
      return emit_loop(emitInfo, n);
   case IR_BREAK_IF_TRUE:
   case IR_CONT_IF_TRUE:
      return emit_cont_break_if_true(emitInfo, n);
   case IR_BREAK:
      /* fall-through */
   case IR_CONT:
      return emit_cont_break(emitInfo, n);

   case IR_BEGIN_SUB:
      return new_instruction(emitInfo, OPCODE_BGNSUB);
   case IR_END_SUB:
      return new_instruction(emitInfo, OPCODE_ENDSUB);
   case IR_RETURN:
      return emit_return(emitInfo, n);

   case IR_NOP:
      return NULL;

   default:
      _mesa_problem(NULL, "Unexpected IR opcode in emit()\n");
   }
   return NULL;
}


/**
 * After code generation, any subroutines will be in separate program
 * objects.  This function appends all the subroutines onto the main
 * program and resolves the linking of all the branch/call instructions.
 * XXX this logic should really be part of the linking process...
 */
static void
_slang_resolve_subroutines(slang_emit_info *emitInfo)
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_program *mainP = emitInfo->prog;
   GLuint *subroutineLoc, i, total;

   subroutineLoc
      = (GLuint *) malloc(emitInfo->NumSubroutines * sizeof(GLuint));

   /* total number of instructions */
   total = mainP->NumInstructions;
   for (i = 0; i < emitInfo->NumSubroutines; i++) {
      subroutineLoc[i] = total;
      total += emitInfo->Subroutines[i]->NumInstructions;
   }

   /* adjust BranchTargets within the functions */
   for (i = 0; i < emitInfo->NumSubroutines; i++) {
      struct gl_program *sub = emitInfo->Subroutines[i];
      GLuint j;
      for (j = 0; j < sub->NumInstructions; j++) {
         struct prog_instruction *inst = sub->Instructions + j;
         if (inst->Opcode != OPCODE_CAL && inst->BranchTarget >= 0) {
            inst->BranchTarget += subroutineLoc[i];
         }
      }
   }

   /* append subroutines' instructions after main's instructions */
   mainP->Instructions = _mesa_realloc_instructions(mainP->Instructions,
                                                    mainP->NumInstructions,
                                                    total);
   mainP->NumInstructions = total;
   for (i = 0; i < emitInfo->NumSubroutines; i++) {
      struct gl_program *sub = emitInfo->Subroutines[i];
      _mesa_copy_instructions(mainP->Instructions + subroutineLoc[i],
                              sub->Instructions,
                              sub->NumInstructions);
      /* delete subroutine code */
      sub->Parameters = NULL; /* prevent double-free */
      _mesa_reference_program(ctx, &emitInfo->Subroutines[i], NULL);
   }

   /* free subroutine list */
   if (emitInfo->Subroutines) {
      free(emitInfo->Subroutines);
      emitInfo->Subroutines = NULL;
   }
   emitInfo->NumSubroutines = 0;

   /* Examine CAL instructions.
    * At this point, the BranchTarget field of the CAL instruction is
    * the number/id of the subroutine to call (an index into the
    * emitInfo->Subroutines list).
    * Translate that into an actual instruction location now.
    */
   for (i = 0; i < mainP->NumInstructions; i++) {
      struct prog_instruction *inst = mainP->Instructions + i;
      if (inst->Opcode == OPCODE_CAL) {
         const GLuint f = inst->BranchTarget;
         inst->BranchTarget = subroutineLoc[f];
      }
   }

   free(subroutineLoc);
}



/**
 * Convert the IR tree into GPU instructions.
 * \param n  root of IR tree
 * \param vt  variable table
 * \param prog  program to put GPU instructions into
 * \param pragmas  controls codegen options
 * \param withEnd  if true, emit END opcode at end
 * \param log  log for emitting errors/warnings/info
 */
GLboolean
_slang_emit_code(slang_ir_node *n, slang_var_table *vt,
                 struct gl_program *prog,
                 const struct gl_sl_pragmas *pragmas,
                 GLboolean withEnd,
                 slang_info_log *log)
{
   GET_CURRENT_CONTEXT(ctx);
   GLboolean success;
   slang_emit_info emitInfo;
   GLuint maxUniforms;

   emitInfo.log = log;
   emitInfo.vt = vt;
   emitInfo.prog = prog;
   emitInfo.Subroutines = NULL;
   emitInfo.NumSubroutines = 0;
   emitInfo.MaxInstructions = prog->NumInstructions;

   emitInfo.EmitHighLevelInstructions = ctx->Shader.EmitHighLevelInstructions;
   emitInfo.EmitCondCodes = ctx->Shader.EmitCondCodes;
   emitInfo.EmitComments = ctx->Shader.EmitComments || pragmas->Debug;
   emitInfo.EmitBeginEndSub = GL_TRUE;

   if (!emitInfo.EmitCondCodes) {
      emitInfo.EmitHighLevelInstructions = GL_TRUE;
   }      

   /* Check uniform/constant limits */
   if (prog->Target == GL_FRAGMENT_PROGRAM_ARB) {
      maxUniforms = ctx->Const.FragmentProgram.MaxUniformComponents / 4;
   }
   else {
      assert(prog->Target == GL_VERTEX_PROGRAM_ARB);
      maxUniforms = ctx->Const.VertexProgram.MaxUniformComponents / 4;
   }
   if (prog->Parameters->NumParameters > maxUniforms) {
      slang_info_log_error(log, "Constant/uniform register limit exceeded "
                           "(max=%u vec4)", maxUniforms);

      return GL_FALSE;
   }

   (void) emit(&emitInfo, n);

   /* finish up by adding the END opcode to program */
   if (withEnd) {
      struct prog_instruction *inst;
      inst = new_instruction(&emitInfo, OPCODE_END);
      if (!inst) {
         return GL_FALSE;
      }
   }

   _slang_resolve_subroutines(&emitInfo);

   success = GL_TRUE;

#if 0
   printf("*********** End emit code (%u inst):\n", prog->NumInstructions);
   _mesa_print_program(prog);
   _mesa_print_program_parameters(ctx,prog);
#endif

   return success;
}
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a40 1
#include "main/macros.h"
d64 2
d83 2
a84 2
                    n * sizeof(struct gl_program),
                    (n + 1) * sizeof(struct gl_program));
d197 3
d244 1
a244 1
   _mesa_bzero(temp, sizeof(*temp));
d436 3
d456 1
a456 1
              enum register_file file, GLint index, GLuint swizzle)
d459 8
a466 6
   inst->SrcReg[0].File = file;
   inst->SrcReg[0].Index = index;
   inst->SrcReg[0].Swizzle = fix_swizzle(swizzle);
   inst->DstReg.File = PROGRAM_ADDRESS;
   inst->DstReg.Index = 0;
   inst->DstReg.WriteMask = WRITEMASK_X;
d553 3
d757 1
a757 1
   assert(_mesa_strlen(s) < len);
d778 3
a780 1
   inst_comment(inst, comment);
d807 3
a809 1
      alloc_node_storage(emitInfo, n, -1);  /* dest */
d830 3
a832 1
      alloc_node_storage(emitInfo, n, -1);  /* dest */
d858 3
a860 1
   alloc_node_storage(emitInfo, n, -1);
d895 1
d953 3
d965 3
d983 3
d1015 3
d1027 3
d1036 3
d1048 3
d1062 3
d1125 2
d1139 4
a1142 2
   _mesa_bzero(&tmpNode, sizeof(tmpNode));
   alloc_node_storage(emitInfo, &tmpNode, n->Store->Size);
d1150 3
d1187 3
a1189 1
   inst->SrcReg[0].NegateBase = NEGATE_XYZW;
d1245 3
d1259 3
d1266 3
d1278 3
d1301 3
a1303 1
   inst->DstReg.CondMask = COND_TR;  /* always return */
d1317 3
d1335 1
d1337 2
a1338 1
   if (n->Opcode == IR_TEX) {
d1340 9
a1348 2
   }
   else if (n->Opcode == IR_TEXB) {
d1350 6
a1355 3
   }
   else {
      assert(n->Opcode == IR_TEXP);
d1357 5
d1392 5
d1433 2
a1434 1
      if (!emitInfo->log->text) {
d1497 3
d1515 3
d1579 3
d1644 3
d1686 4
a1689 2
         struct prog_instruction *ifInst;
         ifInst = new_instruction(emitInfo, OPCODE_IF);
d1697 2
d1700 8
a1707 5
         emit_instruction(emitInfo, OPCODE_IF,
                          NULL, /* dst */
                          n->Children[0]->Store, /* op0 */
                          NULL,
                          NULL);
d1713 3
d1728 5
a1732 1
         (void) new_instruction(emitInfo, OPCODE_ELSE);
d1736 4
a1739 2
         struct prog_instruction *inst;
         inst = new_instruction(emitInfo, OPCODE_BRA);
d1742 1
a1743 1
      prog->Instructions[ifInstLoc].BranchTarget = prog->NumInstructions;
d1752 4
a1755 1
      (void) new_instruction(emitInfo, OPCODE_ENDIF);
d1758 8
a1765 2
   if (n->Children[2]) {
      prog->Instructions[elseInstLoc].BranchTarget = prog->NumInstructions;
d1782 4
a1785 1
      (void) new_instruction(emitInfo, OPCODE_BGNLOOP);
d1803 3
d1810 3
d1825 1
a1825 1
    * will point to the ENDLOOP+1 or BGNLOOP instructions, respectively).
d1834 7
a1840 2
         /* go to instruction after end of loop */
         inst->BranchTarget = endInstLoc + 1;
d1887 3
a1889 1
   inst->DstReg.CondMask = COND_TR;  /* always true */
d1925 4
a1928 2
         inst->DstReg.CondMask = COND_NE;
         inst->DstReg.CondSwizzle = writemask_to_swizzle(condWritemask);
d1943 3
d1949 3
d1953 3
d1958 1
a1958 1
            = emitInfo->prog->NumInstructions;
d1966 4
a1969 2
      inst->DstReg.CondMask = COND_NE;
      inst->DstReg.CondSwizzle = writemask_to_swizzle(condWritemask);
d2116 3
d2145 3
d2305 1
d2307 1
a2307 1
                        (char *) n->Var->a_name);
d2345 8
d2435 1
d2447 3
d2531 1
a2531 1
      = (GLuint *) _mesa_malloc(emitInfo->NumSubroutines * sizeof(GLuint));
d2569 1
a2569 1
      _mesa_free(emitInfo->Subroutines);
d2588 1
a2588 1
   _mesa_free(subroutineLoc);
d2651 3
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a2 1
 * Version:  7.1
d5 1
d63 2
d113 24
d158 22
d284 1
a284 2
storage_to_dst_reg(struct prog_dst_register *dst, const slang_ir_storage *st,
                   GLuint writemask)
d286 1
d291 1
d295 1
d309 2
a310 4
   if (size == 1) {
      GLuint comp = GET_SWZ(swizzle, 0);
      assert(comp < 4);
      dst->WriteMask = WRITEMASK_X << comp;
d313 16
a328 1
      dst->WriteMask = writemask;
d330 2
d346 1
d349 5
d383 1
a383 1
 * Setup an instrucion src register to point to a scalar constant.
d386 3
a388 2
constant_to_src_reg(struct prog_src_register *src, GLfloat val,
                    slang_emit_info *emitInfo)
d390 2
a391 2
   GLuint zeroSwizzle;
   GLint zeroReg;
d395 7
a401 7
   zeroReg = _mesa_add_unnamed_constant(emitInfo->prog->Parameters,
                                        value, 1, &zeroSwizzle);
   assert(zeroReg >= 0);

   src->File = PROGRAM_CONSTANT;
   src->Index = zeroReg;
   src->Swizzle = zeroSwizzle;
d423 11
a433 3
   prog->Instructions = _mesa_realloc_instructions(prog->Instructions,
                                                   prog->NumInstructions,
                                                   prog->NumInstructions + 1);
d447 160
d720 3
d763 1
a763 1
emit_comment(slang_emit_info *emitInfo, const char *s)
d766 1
a766 3
   if (inst) {
      inst->Comment = _mesa_strdup(s);
   }
d778 1
a779 2
   const slang_ir_info *info = _slang_ir_info(n->Opcode);
   char *srcAnnot[3], *dstAnnot;
a780 6
   slang_ir_node *temps[3];

   /* we'll save pointers to nodes/storage to free in temps[] until
    * the very end.
    */
   temps[0] = temps[1] = temps[2] = NULL;
a784 2
   srcAnnot[0] = srcAnnot[1] = srcAnnot[2] = dstAnnot = NULL;

d793 13
a805 9
      /* generate MAD instruction */
      inst = new_instruction(emitInfo, OPCODE_MAD);
      /* operands: A, B, C: */
      storage_to_src_reg(&inst->SrcReg[0], n->Children[0]->Children[0]->Store);
      storage_to_src_reg(&inst->SrcReg[1], n->Children[0]->Children[1]->Store);
      storage_to_src_reg(&inst->SrcReg[2], n->Children[1]->Store);
      temps[0] = n->Children[0]->Children[0];
      temps[1] = n->Children[0]->Children[1];
      temps[2] = n->Children[1];
d807 3
a809 2
   else if (info->NumParams == 2 &&
            n->Opcode == IR_ADD && n->Children[1]->Opcode == IR_MUL) {
d814 13
a826 9
      /* generate MAD instruction */
      inst = new_instruction(emitInfo, OPCODE_MAD);
      /* operands: B, C, A */
      storage_to_src_reg(&inst->SrcReg[0], n->Children[1]->Children[0]->Store);
      storage_to_src_reg(&inst->SrcReg[1], n->Children[1]->Children[1]->Store);
      storage_to_src_reg(&inst->SrcReg[2], n->Children[0]->Store);
      temps[0] = n->Children[1]->Children[0];
      temps[1] = n->Children[1]->Children[1];
      temps[2] = n->Children[0];
a827 1
   else
a828 2
   {
      /* normal case */
d830 6
a835 7
      /* gen code for children */
      for (i = 0; i < info->NumParams; i++) {
         emit(emitInfo, n->Children[i]);
         if (!n->Children[i] || !n->Children[i]->Store) {
            /* error recovery */
            return NULL;
         }
a836 13

      /* gen this instruction and src registers */
      inst = new_instruction(emitInfo, info->InstOpcode);
      for (i = 0; i < info->NumParams; i++)
         storage_to_src_reg(&inst->SrcReg[i], n->Children[i]->Store);

      /* annotation */
      for (i = 0; i < info->NumParams; i++)
         srcAnnot[i] = storage_annotation(n->Children[i], emitInfo->prog);

      /* record (potential) temps to free */
      for (i = 0; i < info->NumParams; i++)
         temps[i] = n->Children[i];
a840 7
   assert(n->Store->Index >= 0);
   if (n->Store->Size == 2)
      n->Writemask = WRITEMASK_XY;
   else if (n->Store->Size == 3)
      n->Writemask = WRITEMASK_XYZ;
   else if (n->Store->Size == 1)
      n->Writemask = WRITEMASK_X << GET_SWZ(n->Store->Swizzle, 0);
d842 7
d850 3
a852 11
   storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);

   dstAnnot = storage_annotation(n, emitInfo->prog);

   inst->Comment = instruction_annotation(inst->Opcode, dstAnnot, srcAnnot[0],
                                          srcAnnot[1], srcAnnot[2]);

   /* really free temps now */
   for (i = 0; i < 3; i++)
      if (temps[i])
         free_node_storage(emitInfo->vt, temps[i]);
a853 1
   /*_mesa_print_instruction(inst);*/
d865 1
a865 1
   struct prog_instruction *inst;
d876 1
d887 7
a893 7
      gl_inst_opcode opcode;

      opcode = n->Opcode == IR_EQUAL ? OPCODE_SEQ : OPCODE_SNE;
      inst = new_instruction(emitInfo, opcode);
      storage_to_src_reg(&inst->SrcReg[0], n->Children[0]->Store);
      storage_to_src_reg(&inst->SrcReg[1], n->Children[1]->Store);
      storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);
d896 5
d906 1
d921 1
a921 1
         dotOp = OPCODE_DP3;
d926 7
a932 5
      inst = new_instruction(emitInfo, OPCODE_SNE);
      storage_to_dst_reg(&inst->DstReg, &tempStore, n->Writemask);
      storage_to_src_reg(&inst->SrcReg[0], n->Children[0]->Store);
      storage_to_src_reg(&inst->SrcReg[1], n->Children[1]->Store);
      inst->Comment = _mesa_strdup("Compare values");
d935 6
a940 4
      inst = new_instruction(emitInfo, dotOp);
      storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);
      storage_to_src_reg(&inst->SrcReg[0], &tempStore);
      storage_to_src_reg(&inst->SrcReg[1], &tempStore);
d942 1
a942 1
      inst->Comment = _mesa_strdup("Reduce vec to bool");
d948 9
a956 5
         inst = new_instruction(emitInfo, OPCODE_SEQ);
         storage_to_src_reg(&inst->SrcReg[0], n->Store);
         constant_to_src_reg(&inst->SrcReg[1], 0.0, emitInfo);
         storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);
         inst->Comment = _mesa_strdup("Invert true/false");
d973 5
a977 6
         /* SNE sneTemp, left[i], right[i] */
         inst = new_instruction(emitInfo, OPCODE_SNE);
         storage_to_src_reg(&inst->SrcReg[0], n->Children[0]->Store);
         storage_to_src_reg(&inst->SrcReg[1], n->Children[1]->Store);
         inst->SrcReg[0].Index += i;
         inst->SrcReg[1].Index += i;
d979 7
a985 2
            storage_to_dst_reg(&inst->DstReg, &accTemp, WRITEMASK_XYZW);
            inst->Comment = _mesa_strdup("Begin struct/array comparison");
d988 6
a993 2
            storage_to_dst_reg(&inst->DstReg, &sneTemp, WRITEMASK_XYZW);

d995 5
a999 4
            inst = new_instruction(emitInfo, OPCODE_ADD);
            storage_to_dst_reg(&inst->DstReg, &accTemp, WRITEMASK_XYZW);
            storage_to_src_reg(&inst->SrcReg[0], &accTemp);
            storage_to_src_reg(&inst->SrcReg[1], &sneTemp);
d1004 6
a1009 5
      inst = new_instruction(emitInfo, OPCODE_DP4);
      storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);
      storage_to_src_reg(&inst->SrcReg[0], &accTemp);
      storage_to_src_reg(&inst->SrcReg[1], &accTemp);
      inst->Comment = _mesa_strdup("End struct/array comparison");
d1013 8
a1020 5
         inst = new_instruction(emitInfo, OPCODE_SEQ);
         storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);
         storage_to_src_reg(&inst->SrcReg[0], n->Store);
         constant_to_src_reg(&inst->SrcReg[1], 0.0, emitInfo);
         inst->Comment = _mesa_strdup("Invert true/false");
d1096 5
a1100 4
   inst = new_instruction(emitInfo, OPCODE_MAX);
   storage_to_dst_reg(&inst->DstReg, tmpNode.Store, n->Writemask);
   storage_to_src_reg(&inst->SrcReg[0], n->Children[0]->Store);
   storage_to_src_reg(&inst->SrcReg[1], n->Children[1]->Store);
d1103 5
a1107 4
   inst = new_instruction(emitInfo, OPCODE_MIN);
   storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);
   storage_to_src_reg(&inst->SrcReg[0], tmpNode.Store);
   storage_to_src_reg(&inst->SrcReg[1], n->Children[2]->Store);
d1129 6
a1134 3
   inst = new_instruction(emitInfo, OPCODE_MOV);
   storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);
   storage_to_src_reg(&inst->SrcReg[0], n->Children[0]->Store);
d1169 1
d1175 1
d1177 1
d1179 1
d1191 1
a1191 1
      inst->Comment = _mesa_strdup(n->Label->Name);
d1206 1
a1206 1
      inst->Comment = _mesa_strdup(n->Label->Name);
d1211 1
d1217 1
a1217 1
   inst->Comment = _mesa_strdup(n->Label->Name);
d1263 1
a1263 2

   (void) emit(emitInfo, n->Children[1]);
d1266 1
a1266 1
      inst = new_instruction(emitInfo, OPCODE_TEX);
d1269 1
a1269 1
      inst = new_instruction(emitInfo, OPCODE_TXB);
d1273 15
a1287 1
      inst = new_instruction(emitInfo, OPCODE_TXP);
d1290 4
d1297 7
a1303 1
   storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);
d1305 4
a1308 3
   /* Child[1] is the coord */
   assert(n->Children[1]->Store->Index >= 0);
   storage_to_src_reg(&inst->SrcReg[0], n->Children[1]->Store);
d1310 3
a1312 7
   /* Child[0] is the sampler (a uniform which'll indicate the texture unit) */
   assert(n->Children[0]->Store);
   /* Store->Index is the sampler index */
   assert(n->Children[0]->Store->Index >= 0);
   /* Store->Size is the texture target */
   assert(n->Children[0]->Store->Size >= TEXTURE_1D_INDEX);
   assert(n->Children[0]->Store->Size <= TEXTURE_RECT_INDEX);
a1313 9
   inst->TexSrcTarget = n->Children[0]->Store->Size;
#if 0
   inst->TexSrcUnit = 27; /* Dummy value; the TexSrcUnit will be computed at
                           * link time, using the sampler uniform's value.
                           */
   inst->Sampler = n->Children[0]->Store->Index; /* i.e. uniform's index */
#else
   inst->TexSrcUnit = n->Children[0]->Store->Index; /* i.e. uniform's index */
#endif
d1352 9
d1363 1
d1366 3
a1368 1
       (inst->DstReg.Index == n->Children[1]->Store->Index)) {
d1374 5
a1379 3
      if (n->Children[1]->Opcode != IR_SWIZZLE)
         _slang_free_temp(emitInfo->vt, n->Children[1]->Store);
      *n->Children[1]->Store = *n->Children[0]->Store;
d1383 1
a1383 6

      /* use tighter writemask when possible */
      if (n->Writemask == WRITEMASK_XYZW)
         n->Writemask = inst->DstReg.WriteMask;

      storage_to_dst_reg(&inst->DstReg, n->Children[0]->Store, n->Writemask);
a1393 1
         ASSERT(n->Children[0]->Writemask == WRITEMASK_XYZW);
d1398 6
a1403 4
            inst = new_instruction(emitInfo, OPCODE_MOV);
            inst->Comment = _mesa_strdup("IR_COPY block");
            storage_to_dst_reg(&inst->DstReg, &dstStore, n->Writemask);
            storage_to_src_reg(&inst->SrcReg[0], &srcStore);
a1411 1
         inst = new_instruction(emitInfo, OPCODE_MOV);
d1413 5
a1417 2
         storage_to_dst_reg(&inst->DstReg, n->Children[0]->Store, n->Writemask);
         storage_to_src_reg(&inst->SrcReg[0], n->Children[1]->Store);
d1474 5
a1478 1
         inst = new_instruction(emitInfo, OPCODE_MOV);
d1480 1
a1480 2
         storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);
         storage_to_src_reg(&inst->SrcReg[0], n->Children[0]->Store);
a1481 1
         inst->Comment = _mesa_strdup("COND expr");
d1511 1
d1534 9
a1542 4
   inst = new_instruction(emitInfo, OPCODE_SEQ);
   storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);
   storage_to_src_reg(&inst->SrcReg[0], n->Children[0]->Store);
   constant_to_src_reg(&inst->SrcReg[1], 0.0, emitInfo);
a1544 1
   inst->Comment = _mesa_strdup("NOT");
a1577 1
      struct prog_instruction *ifInst = new_instruction(emitInfo, OPCODE_IF);
d1579 3
d1589 6
a1594 2
         /* test reg.x */
         storage_to_src_reg(&ifInst->SrcReg[0], n->Children[0]->Store);
d1601 1
a1601 1
      ifInst->Comment = _mesa_strdup("if zero");
d1618 1
a1618 1
         inst->Comment = _mesa_strdup("else");
d1789 5
a1793 2
         inst = new_instruction(emitInfo, OPCODE_IF);
         storage_to_src_reg(&inst->SrcReg[0], n->Children[0]->Store);
d1815 19
d1841 2
a1842 2
   /* setup storage info, if needed */
   if (!n->Store->Parent)
d1844 12
d1857 2
a1858 1
   assert(n->Store->Parent);
d1865 3
a1867 2
 * Dereference array element.  Just resolve storage for the array
 * element represented by this node.
d1872 4
a1875 1
   slang_ir_storage *root;
d1878 1
a1878 4
   assert(n->Store);
   assert(n->Store->File == PROGRAM_UNDEFINED);
   assert(n->Store->Parent);
   assert(n->Store->Size > 0);
d1880 20
a1899 8
   root = n->Store;
   while (root->Parent)
      root = root->Parent;

   if (root->File == PROGRAM_STATE_VAR) {
      GLint index = _slang_alloc_statevar(n, emitInfo->prog->Parameters);
      assert(n->Store->Index == index);
      return NULL;
d1902 1
a1902 1
   /* do codegen for array */
d1904 7
d1913 1
a1913 4
      /* Constant array index.
       * Set Store's index to be the offset of the array element in
       * the register file.
       */
a1914 1
      const GLint sz = (n->Store->Size + 3) / 4; /* size in slots/registers */
d1916 2
a1917 2
      n->Store->Index = sz * element;
      assert(n->Store->Parent);
a1920 1
      struct prog_instruction *inst;
d1924 7
d1932 2
a1933 1
      inst = new_instruction(emitInfo, OPCODE_ARL);
a1934 2
      storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);
      storage_to_src_reg(&inst->SrcReg[0], n->Children[1]->Store);
d1936 5
a1940 3
      inst->DstReg.File = PROGRAM_ADDRESS;
      inst->DstReg.Index = 0; /* always address register [0] */
      inst->Comment = _mesa_strdup("ARL ADDR");
d1942 49
a1990 1
      n->Store->RelAddr = GL_TRUE;
d1993 2
a1994 3
   /* if array element size is one, make sure we only access X */
   if (n->Store->Size == 1)
      n->Store->Swizzle = SWIZZLE_XXXX;
d2007 1
d2011 1
d2022 3
a2024 2
      root->Index = _slang_alloc_statevar(n, emitInfo->prog->Parameters);
      if (root->Index < 0) {
d2028 4
d2033 31
a2063 3
   else {
      /* do codegen for struct */
      emit(emitInfo, n->Children[0]);
d2066 2
a2079 2
   struct prog_instruction *inst;

d2106 1
a2106 1
      assert(n->Var->aux == n->Store);
d2116 1
a2116 2
      inst = emit_comment(emitInfo, s);
      return inst;
d2124 1
a2124 1
 * Actually, no code is generated but we may do some memory alloation.
d2134 12
a2145 1
      n->Store->Index = _slang_alloc_statevar(n, emitInfo->prog->Parameters);
d2147 2
a2148 1
   else if (n->Store->File == PROGRAM_UNIFORM) {
d2152 4
d2239 2
d2247 1
d2361 1
a2361 1
   /* adjust BrancTargets within the functions */
d2414 9
a2422 1

d2425 3
a2427 1
                 struct gl_program *prog, GLboolean withEnd,
d2440 1
d2444 1
a2444 1
   emitInfo.EmitComments = ctx->Shader.EmitComments;
d2460 3
a2462 1
      slang_info_log_error(log, "Constant/uniform register limit exceeded");
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d3 1
a3 1
 * Version:  7.0.3
d5 1
a5 1
 * Copyright (C) 2005-2007  Brian Paul   All Rights Reserved.
d82 1
a82 1
   emitInfo->Subroutines[n] = _mesa_new_program(ctx, emitInfo->prog->Target, 0);
d111 3
a113 1
 * Swizzle a swizzle.  That is, return swz2(swz1)
d115 2
a116 2
static GLuint
swizzle_swizzle(GLuint swz1, GLuint swz2)
d121 4
a124 1
      s[i] = GET_SWZ(swz1, c);
a130 15
slang_ir_storage *
_slang_new_ir_storage(enum register_file file, GLint index, GLint size)
{
   slang_ir_storage *st;
   st = (slang_ir_storage *) _slang_alloc(sizeof(slang_ir_storage));
   if (st) {
      st->File = file;
      st->Index = index;
      st->Size = size;
      st->Swizzle = SWIZZLE_NOOP;
   }
   return st;
}


d132 7
a138 2
 * Allocate temporary storage for an intermediate result (such as for
 * a multiply or add, etc.
d141 2
a142 1
alloc_temp_storage(slang_emit_info *emitInfo, slang_ir_node *n, GLint size)
d145 14
a158 9
   assert(!n->Store);
   assert(size > 0);
   n->Store = _slang_new_ir_storage(PROGRAM_TEMPORARY, -1, size);
   if (!_slang_alloc_temp(emitInfo->vt, n->Store)) {
      slang_info_log_error(emitInfo->log,
                           "Ran out of registers, too many temporaries");
      _slang_free(n->Store);
      n->Store = NULL;
      return GL_FALSE;
d169 1
a169 1
free_temp_storage(slang_var_table *vt, slang_ir_node *n)
d177 1
a177 3
         n->Store->Size = -1;
         /*_mesa_free(n->Store);*/ /* XXX leak */
         n->Store = NULL;
d184 49
d239 12
a250 1
   assert(st->Index >= 0);
d252 9
a260 6
   dst->Index = st->Index;
   assert(st->File != PROGRAM_UNDEFINED);
   assert(st->Size >= 1);
   assert(st->Size <= 4);
   if (st->Size == 1) {
      GLuint comp = GET_SWZ(st->Swizzle, 0);
d276 11
a286 6
   static const GLuint defaultSwizzle[4] = {
      MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_X, SWIZZLE_X, SWIZZLE_X),
      MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_W),
      MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_W),
      MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_W)
   };
d288 6
a294 2
   assert(st->Size >= 1);
   assert(st->Size <= 4);
a295 5
   src->Index = st->Index;
   if (st->Swizzle != SWIZZLE_NOOP)
      src->Swizzle = st->Swizzle;
   else
      src->Swizzle = defaultSwizzle[st->Size - 1]; /*XXX really need this?*/
d297 11
a307 4
   assert(GET_SWZ(src->Swizzle, 0) <= 3);
   assert(GET_SWZ(src->Swizzle, 1) <= 3);
   assert(GET_SWZ(src->Swizzle, 2) <= 3);
   assert(GET_SWZ(src->Swizzle, 3) <= 3);
d541 6
d567 3
a569 3
      free_temp_storage(emitInfo->vt, n->Children[0]->Children[0]);
      free_temp_storage(emitInfo->vt, n->Children[0]->Children[1]);
      free_temp_storage(emitInfo->vt, n->Children[1]);
d583 3
a585 3
      free_temp_storage(emitInfo->vt, n->Children[1]->Children[0]);
      free_temp_storage(emitInfo->vt, n->Children[1]->Children[1]);
      free_temp_storage(emitInfo->vt, n->Children[0]);
d610 1
a610 1
      /* free temps */
d612 1
a612 1
         free_temp_storage(emitInfo->vt, n->Children[i]);
d616 10
a625 5
   if (!n->Store) {
      /* XXX this size isn't correct, it depends on the operands */
      if (!alloc_temp_storage(emitInfo, n, info->ResultSize))
         return NULL;
   }
d633 5
d659 9
a667 1
   assert(n->Children[0]->Store->Size == n->Children[1]->Store->Size);
a672 5
      if (!n->Store) {
         if (!alloc_temp_storage(emitInfo, n, 1))  /* 1 bool */
            return NULL;
      }

d682 5
a686 5
      
      assert(!n->Store);
      if (!n->Store) {
         if (!alloc_temp_storage(emitInfo, n, size))  /* 'size' bools */
            return NULL;
d703 1
a703 1
      /* Compute equality, inequality (tmp1 = (A ?= B)) */
d705 1
a707 1
      storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);
d710 1
a710 1
      /* Compute tmp2 = DOT(tmp1, tmp1)  (reduction) */
d712 3
a714 2
      storage_to_src_reg(&inst->SrcReg[0], n->Store);
      storage_to_src_reg(&inst->SrcReg[1], n->Store);
a715 4
      free_temp_storage(emitInfo->vt, n); /* free tmp1 */
      if (!alloc_temp_storage(emitInfo, n, 1))  /* alloc tmp2 */
         return NULL;
      storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);
d718 2
d721 1
a721 1
         /* compute tmp2.x = !tmp2.x  via tmp2.x = (tmp2.x == 0) */
d730 3
a732 2
      /* size > 4, struct compare */
#if 0
d734 8
a741 1
      /*printf("BEGIN COMPARE size %d\n", num);*/
d743 18
a760 11
         inst = new_instruction(emitInfo, opcode);
         inst->SrcReg[0].File = n->Children[0]->Store->File;
         inst->SrcReg[0].Index = n->Children[0]->Store->Index + i;
         inst->SrcReg[1].File = n->Children[1]->Store->File;
         inst->SrcReg[1].Index = n->Children[1]->Store->Index + i;
         inst->DstReg.File = n->Store->File;
         inst->DstReg.Index = n->Store->Index;

         inst->CondUpdate = 1; /* update cond code */
         if (i > 0) {
            inst->DstReg.CondMask = COND_NE; /* update if !=0 */
a761 1
         /*_mesa_print_instruction(inst);*/
d763 3
d767 15
a781 3
#endif
      _mesa_problem(NULL, "struct comparison not implemented yet");
      inst = NULL;
d785 2
a786 2
   free_temp_storage(emitInfo->vt, n->Children[0]);
   free_temp_storage(emitInfo->vt, n->Children[1]);
d839 2
a840 3
   if (!n->Store)
      if (!alloc_temp_storage(emitInfo, n, n->Children[0]->Store->Size))
         return NULL;
d850 1
a850 1
   alloc_temp_storage(emitInfo, &tmpNode, n->Store->Size);
d864 1
a864 1
   free_temp_storage(emitInfo->vt, &tmpNode);
d881 2
a882 3
   if (!n->Store)
      if (!alloc_temp_storage(emitInfo, n, n->Children[0]->Store->Size))
         return NULL;
d996 1
a996 1
   inst->DstReg.CondMask = COND_TR;  /* always branch */
d1024 2
a1025 3
   if (!n->Store)
      if (!alloc_temp_storage(emitInfo, n, 4))
         return NULL;
a1029 1
   assert(n->Children[1]->Store->File != PROGRAM_UNDEFINED);
a1040 1
   inst->Sampler = n->Children[0]->Store->Index; /* i.e. uniform's index */
d1042 1
d1046 4
d1054 3
d1058 1
a1058 1
emit_move(slang_emit_info *emitInfo, slang_ir_node *n)
d1062 2
d1102 1
d1105 5
d1127 1
a1127 1
            inst->Comment = _mesa_strdup("IR_MOVE block");
d1147 1
a1147 1
      free_temp_storage(emitInfo->vt, n->Children[1]);
d1196 1
a1196 1
         if (!alloc_temp_storage(emitInfo, n, 1))
d1252 2
a1253 3
   if (!n->Store)
      if (!alloc_temp_storage(emitInfo, n, n->Children[0]->Store->Size))
         return NULL;
d1259 1
a1259 1
   free_temp_storage(emitInfo->vt, n->Children[0]);
d1286 3
a1522 35

/**
 * Remove any SWIZZLE_NIL terms from given swizzle mask (smear prev term).
 * Ex: fix_swizzle("zyNN") -> "zyyy"
 */
static GLuint
fix_swizzle(GLuint swizzle)
{
   GLuint swz[4], i;
   for (i = 0; i < 4; i++) {
      swz[i] = GET_SWZ(swizzle, i);
      if (swz[i] == SWIZZLE_NIL) {
         swz[i] = swz[i - 1];
      }
   }
   return MAKE_SWIZZLE4(swz[0], swz[1], swz[2], swz[3]);
}


/**
 * Return the number of components actually named by the swizzle.
 * Recall that swizzles may have undefined/don't-care values.
 */
static GLuint
swizzle_size(GLuint swizzle)
{
   GLuint size = 0, i;
   for (i = 0; i < 4; i++) {
      GLuint swz = GET_SWZ(swizzle, i);
      size += (swz >= 0 && swz <= 3);
   }
   return size;
}


a1525 1
   GLuint swizzle;
d1530 3
a1532 10
#ifdef DEBUG
   {
      GLuint s = n->Children[0]->Store->Swizzle;
      assert(GET_SWZ(s, 0) != SWIZZLE_NIL);
      assert(GET_SWZ(s, 1) != SWIZZLE_NIL);
      assert(GET_SWZ(s, 2) != SWIZZLE_NIL);
      assert(GET_SWZ(s, 3) != SWIZZLE_NIL);
   }
#endif
   /* For debug: n->Var = n->Children[0]->Var; */
d1534 1
a1534 15
   /* "pull-up" the child's storage info, applying our swizzle info */
   n->Store->File  = n->Children[0]->Store->File;
   n->Store->Index = n->Children[0]->Store->Index;
   n->Store->Size = swizzle_size(n->Store->Swizzle);
#if 0
   printf("Emit Swizzle %s  reg %d  chSize %d  mySize %d\n",
          _mesa_swizzle_string(n->Store->Swizzle, 0, 0),
          n->Store->Index, n->Children[0]->Store->Size,
          n->Store->Size);
#endif

   /* apply this swizzle to child's swizzle to get composed swizzle */
   swizzle = fix_swizzle(n->Store->Swizzle); /* remove the don't care terms */
   n->Store->Swizzle = swizzle_swizzle(n->Children[0]->Store->Swizzle,
                                       swizzle);
d1547 3
d1551 2
a1552 1
   assert(n->Store->File != PROGRAM_UNDEFINED);
d1555 7
a1561 2
   if (n->Store->File == PROGRAM_STATE_VAR) {
      n->Store->Index = _slang_alloc_statevar(n, emitInfo->prog->Parameters);
d1565 3
d1569 9
a1577 4
      /* Constant index */
      const GLint arrayAddr = n->Children[0]->Store->Index;
      const GLint index = (GLint) n->Children[1]->Value[0];
      n->Store->Index = arrayAddr + index;
d1580 16
a1595 5
      /* Variable index - PROBLEM */
      const GLint arrayAddr = n->Children[0]->Store->Index;
      const GLint index = 0;
      _mesa_problem(NULL, "variable array indexes not supported yet!");
      n->Store->Index = arrayAddr + index;
d1597 5
d1612 16
a1627 3
   if (n->Store->File == PROGRAM_STATE_VAR) {
      n->Store->Index = _slang_alloc_statevar(n, emitInfo->prog->Parameters);
      if (n->Store->Index < 0) {
d1633 30
a1662 6
      GLint offset = n->FieldOffset / 4;
      assert(n->Children[0]->Store->Index >= 0);
      n->Store->Index = n->Children[0]->Store->Index + offset;
      if (n->Store->Size == 1) {
         GLint swz = n->FieldOffset % 4;
         n->Store->Swizzle = MAKE_SWIZZLE4(swz, swz, swz, swz);
d1664 8
a1671 2
      else {
         n->Store->Swizzle = SWIZZLE_XYZW;
d1673 16
d1690 30
a1719 1
   return NULL; /* no instruction */
d1730 4
d1740 2
d1758 2
a1759 39
      assert(n->Store);
      assert(n->Store->File != PROGRAM_UNDEFINED);
      assert(n->Store->Size > 0);
      /*assert(n->Store->Index < 0);*/
      if (!n->Var || n->Var->isTemp) {
         /* a nameless/temporary variable, will be freed after first use */
         /*NEW*/
         if (n->Store->Index < 0 && !_slang_alloc_temp(emitInfo->vt, n->Store)) {
            slang_info_log_error(emitInfo->log,
                                 "Ran out of registers, too many temporaries");
            return NULL;
         }
      }
      else {
         /* a regular variable */
         _slang_add_variable(emitInfo->vt, n->Var);
         if (!_slang_alloc_var(emitInfo->vt, n->Store)) {
            slang_info_log_error(emitInfo->log,
                                 "Ran out of registers, too many variables");
            return NULL;
         }
         /*
         printf("IR_VAR_DECL %s %d store %p\n",
                (char*) n->Var->a_name, n->Store->Index, (void*) n->Store);
         */
         assert(n->Var->aux == n->Store);
      }
      if (emitInfo->EmitComments) {
         /* emit NOP with comment describing the variable's storage location */
         char s[1000];
         sprintf(s, "TEMP[%d]%s = variable %s (size %d)",
                 n->Store->Index,
                 _mesa_swizzle_string(n->Store->Swizzle, 0, GL_FALSE), 
                 (n->Var ? (char *) n->Var->a_name : "anonymous"),
                 n->Store->Size);
         inst = emit_comment(emitInfo, s);
         return inst;
      }
      return NULL;
d1765 1
a1765 14
      assert(n->Store);
      assert(n->Store->File != PROGRAM_UNDEFINED);

      if (n->Store->File == PROGRAM_STATE_VAR &&
          n->Store->Index < 0) {
         n->Store->Index = _slang_alloc_statevar(n, emitInfo->prog->Parameters);
      }

      if (n->Store->Index < 0) {
         /* probably ran out of registers */
         return NULL;
      }
      assert(n->Store->Size > 0);
      break;
a1773 14
   case IR_I_TO_F:
      /* just move */
      emit(emitInfo, n->Children[0]);
      inst = new_instruction(emitInfo, OPCODE_MOV);
      if (!n->Store) {
         if (!alloc_temp_storage(emitInfo, n, 1))
            return NULL;
      }
      storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);
      storage_to_src_reg(&inst->SrcReg[0], n->Children[0]->Store);
      if (emitInfo->EmitComments)
         inst->Comment = _mesa_strdup("int to float");
      return NULL;

d1776 1
d1782 1
d1788 3
a1810 2
   case IR_EXP:
   case IR_EXP2:
d1839 2
a1840 2
   case IR_MOVE:
      return emit_move(emitInfo, n);
d1938 1
a1938 1
      _mesa_delete_program(ctx, sub);
d1976 1
d1992 13
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.3
d680 1
d726 7
d735 1
a735 1
   storage_to_dst_reg(&inst->DstReg, n->Store, n->Writemask);
d739 1
a739 1
   /* tmp = min(tmp, ch[2]) */
d742 1
a742 1
   storage_to_src_reg(&inst->SrcReg[0], n->Store);
d745 2
d872 1
d879 5
d1505 4
@


1.1.1.1
log
@Mesa 7.0.1
@
text
@@
