head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.8
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.6
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.4.0.8
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2013.09.05.14.06.54;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.32;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.32;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.32.18;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.49;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.17.39;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */



#include "main/glheader.h"
#include "main/colormac.h"
#include "main/light.h"
#include "main/macros.h"
#include "main/imports.h"
#include "main/simple_list.h"
#include "main/mtypes.h"

#include "math/m_translate.h"

#include "t_context.h"
#include "t_pipeline.h"
#include "tnl.h"

#define LIGHT_TWOSIDE       0x1
#define LIGHT_MATERIAL      0x2
#define MAX_LIGHT_FUNC      0x4

typedef void (*light_func)( struct gl_context *ctx,
			    struct vertex_buffer *VB,
			    struct tnl_pipeline_stage *stage,
			    GLvector4f *input );

/**
 * Information for updating current material attributes from vertex color,
 * for GL_COLOR_MATERIAL.
 */
struct material_cursor {
   const GLfloat *ptr;    /* points to src vertex color (in VB array) */
   GLuint stride;         /* stride to next vertex color (bytes) */
   GLfloat *current;      /* points to material attribute to update */
   GLuint size;           /* vertex/color size: 1, 2, 3 or 4 */
};

/**
 * Data private to this pipeline stage.
 */
struct light_stage_data {
   GLvector4f Input;
   GLvector4f LitColor[2];
   GLvector4f LitSecondary[2];
   light_func *light_func_tab;

   struct material_cursor mat[MAT_ATTRIB_MAX];
   GLuint mat_count;
   GLuint mat_bitmask;
};


#define LIGHT_STAGE_DATA(stage) ((struct light_stage_data *)(stage->privatePtr))



/**********************************************************************/
/*****                  Lighting computation                      *****/
/**********************************************************************/


/*
 * Notes:
 *   When two-sided lighting is enabled we compute the color (or index)
 *   for both the front and back side of the primitive.  Then, when the
 *   orientation of the facet is later learned, we can determine which
 *   color (or index) to use for rendering.
 *
 *   KW: We now know orientation in advance and only shade for
 *       the side or sides which are actually required.
 *
 * Variables:
 *   n = normal vector
 *   V = vertex position
 *   P = light source position
 *   Pe = (0,0,0,1)
 *
 * Precomputed:
 *   IF P[3]==0 THEN
 *       // light at infinity
 *       IF local_viewer THEN
 *           _VP_inf_norm = unit vector from V to P      // Precompute
 *       ELSE
 *           // eye at infinity
 *           _h_inf_norm = Normalize( VP + <0,0,1> )     // Precompute
 *       ENDIF
 *   ENDIF
 *
 * Functions:
 *   Normalize( v ) = normalized vector v
 *   Magnitude( v ) = length of vector v
 */



static void
validate_shine_table( struct gl_context *ctx, GLuint side, GLfloat shininess )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct tnl_shine_tab *list = tnl->_ShineTabList;
   struct tnl_shine_tab *s;

   ASSERT(side < 2);

   foreach(s, list)
      if ( s->shininess == shininess )
	 break;

   if (s == list) {
      GLint j;
      GLfloat *m;

      foreach(s, list)
	 if (s->refcount == 0)
	    break;

      m = s->tab;
      m[0] = 0.0;
      if (shininess == 0.0) {
	 for (j = 1 ; j <= SHINE_TABLE_SIZE ; j++)
	    m[j] = 1.0;
      }
      else {
	 for (j = 1 ; j < SHINE_TABLE_SIZE ; j++) {
            GLdouble t, x = j / (GLfloat) (SHINE_TABLE_SIZE - 1);
            if (x < 0.005) /* underflow check */
               x = 0.005;
            t = pow(x, shininess);
	    if (t > 1e-20)
	       m[j] = (GLfloat) t;
	    else
	       m[j] = 0.0;
	 }
	 m[SHINE_TABLE_SIZE] = 1.0;
      }

      s->shininess = shininess;
   }

   if (tnl->_ShineTable[side])
      tnl->_ShineTable[side]->refcount--;

   tnl->_ShineTable[side] = s;
   move_to_tail( list, s );
   s->refcount++;
}


void
_tnl_validate_shine_tables( struct gl_context *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   GLfloat shininess;
   
   shininess = ctx->Light.Material.Attrib[MAT_ATTRIB_FRONT_SHININESS][0];
   if (!tnl->_ShineTable[0] || tnl->_ShineTable[0]->shininess != shininess)
      validate_shine_table( ctx, 0, shininess );

   shininess = ctx->Light.Material.Attrib[MAT_ATTRIB_BACK_SHININESS][0];
   if (!tnl->_ShineTable[1] || tnl->_ShineTable[1]->shininess != shininess)
      validate_shine_table( ctx, 1, shininess );
}


/**
 * In the case of colormaterial, the effected material attributes
 * should already have been bound to point to the incoming color data,
 * prior to running the pipeline.
 * This function copies the vertex's color to the material attributes
 * which are tracking glColor.
 * It's called per-vertex in the lighting loop.
 */
static void
update_materials(struct gl_context *ctx, struct light_stage_data *store)
{
   GLuint i;

   for (i = 0 ; i < store->mat_count ; i++) {
      /* update the material */
      COPY_CLEAN_4V(store->mat[i].current, store->mat[i].size, store->mat[i].ptr);
      /* increment src vertex color pointer */
      STRIDE_F(store->mat[i].ptr, store->mat[i].stride);
   }
      
   /* recompute derived light/material values */
   _mesa_update_material( ctx, store->mat_bitmask );
   /* XXX we should only call this if we're tracking/changing the specular
    * exponent.
    */
   _tnl_validate_shine_tables( ctx );
}


/**
 * Prepare things prior to running the lighting stage.
 * Return number of material attributes which will track vertex color.
 */
static GLuint
prepare_materials(struct gl_context *ctx,
                  struct vertex_buffer *VB, struct light_stage_data *store)
{
   GLuint i;
   
   store->mat_count = 0;
   store->mat_bitmask = 0;

   /* Examine the _ColorMaterialBitmask to determine which materials
    * track vertex color.  Override the material attribute's pointer
    * with the color pointer for each one.
    */
   if (ctx->Light.ColorMaterialEnabled) {
      const GLuint bitmask = ctx->Light._ColorMaterialBitmask;
      for (i = 0 ; i < MAT_ATTRIB_MAX ; i++)
	 if (bitmask & (1<<i))
	    VB->AttribPtr[_TNL_ATTRIB_MAT_FRONT_AMBIENT + i] = VB->AttribPtr[_TNL_ATTRIB_COLOR0];
   }

   /* Now, for each material attribute that's tracking vertex color, save
    * some values (ptr, stride, size, current) that we'll need in
    * update_materials(), above, that'll actually copy the vertex color to
    * the material attribute(s).
    */
   for (i = _TNL_FIRST_MAT; i <= _TNL_LAST_MAT; i++) {
      if (VB->AttribPtr[i]->stride) {
	 const GLuint j = store->mat_count++;
	 const GLuint attr = i - _TNL_ATTRIB_MAT_FRONT_AMBIENT;
	 store->mat[j].ptr    = VB->AttribPtr[i]->start;
	 store->mat[j].stride = VB->AttribPtr[i]->stride;
	 store->mat[j].size   = VB->AttribPtr[i]->size;
	 store->mat[j].current = ctx->Light.Material.Attrib[attr];
	 store->mat_bitmask |= (1<<attr);
      }
   }

   /* FIXME: Is this already done?
    */
   _mesa_update_material( ctx, ~0 );

   _tnl_validate_shine_tables( ctx );

   return store->mat_count;
}

/*
 * Compute dp ^ SpecularExponent.
 * Lerp between adjacent values in the f(x) lookup table, giving a
 * continuous function, with adequate overall accuracy.  (Though still
 * pretty good compared to a straight lookup).
 */
static inline GLfloat
lookup_shininess(const struct gl_context *ctx, GLuint face, GLfloat dp)
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   const struct tnl_shine_tab *tab = tnl->_ShineTable[face];
   float f = dp * (SHINE_TABLE_SIZE - 1);
   int k = (int) f;
   if (k < 0 /* gcc may cast an overflow float value to negative int value */
	|| k > SHINE_TABLE_SIZE - 2)
      return powf(dp, tab->shininess);
   else
      return tab->tab[k] + (f - k) * (tab->tab[k+1] - tab->tab[k]);
}

/* Tables for all the shading functions.
 */
static light_func _tnl_light_tab[MAX_LIGHT_FUNC];
static light_func _tnl_light_fast_tab[MAX_LIGHT_FUNC];
static light_func _tnl_light_fast_single_tab[MAX_LIGHT_FUNC];
static light_func _tnl_light_spec_tab[MAX_LIGHT_FUNC];

#define TAG(x)           x
#define IDX              (0)
#include "t_vb_lighttmp.h"

#define TAG(x)           x##_twoside
#define IDX              (LIGHT_TWOSIDE)
#include "t_vb_lighttmp.h"

#define TAG(x)           x##_material
#define IDX              (LIGHT_MATERIAL)
#include "t_vb_lighttmp.h"

#define TAG(x)           x##_twoside_material
#define IDX              (LIGHT_TWOSIDE|LIGHT_MATERIAL)
#include "t_vb_lighttmp.h"


static void init_lighting_tables( void )
{
   static int done;

   if (!done) {
      init_light_tab();
      init_light_tab_twoside();
      init_light_tab_material();
      init_light_tab_twoside_material();
      done = 1;
   }
}


static GLboolean run_lighting( struct gl_context *ctx, 
			       struct tnl_pipeline_stage *stage )
{
   struct light_stage_data *store = LIGHT_STAGE_DATA(stage);
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct vertex_buffer *VB = &tnl->vb;
   GLvector4f *input = ctx->_NeedEyeCoords ? VB->EyePtr : VB->AttribPtr[_TNL_ATTRIB_POS];
   GLuint idx;

   if (!ctx->Light.Enabled || ctx->VertexProgram._Current)
      return GL_TRUE;

   /* Make sure we can talk about position x,y and z:
    */
   if (input->size <= 2 && input == VB->AttribPtr[_TNL_ATTRIB_POS]) {

      _math_trans_4f( store->Input.data,
		      VB->AttribPtr[_TNL_ATTRIB_POS]->data,
		      VB->AttribPtr[_TNL_ATTRIB_POS]->stride,
		      GL_FLOAT,
		      VB->AttribPtr[_TNL_ATTRIB_POS]->size,
		      0,
		      VB->Count );

      if (input->size <= 2) {
	 /* Clean z.
	  */
	 _mesa_vector4f_clean_elem(&store->Input, VB->Count, 2);
      }
	 
      if (input->size <= 1) {
	 /* Clean y.
	  */
	 _mesa_vector4f_clean_elem(&store->Input, VB->Count, 1);
      }

      input = &store->Input;
   }
   
   idx = 0;

   if (prepare_materials( ctx, VB, store ))
      idx |= LIGHT_MATERIAL;

   if (ctx->Light.Model.TwoSide)
      idx |= LIGHT_TWOSIDE;

   /* The individual functions know about replaying side-effects
    * vs. full re-execution. 
    */
   store->light_func_tab[idx]( ctx, VB, stage, input );

   return GL_TRUE;
}


/* Called in place of do_lighting when the light table may have changed.
 */
static void validate_lighting( struct gl_context *ctx,
					struct tnl_pipeline_stage *stage )
{
   light_func *tab;

   if (!ctx->Light.Enabled || ctx->VertexProgram._Current)
      return;

   if (ctx->Light._NeedVertices) {
      if (ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR)
	 tab = _tnl_light_spec_tab;
      else
	 tab = _tnl_light_tab;
   }
   else {
      if (ctx->Light.EnabledList.next == ctx->Light.EnabledList.prev)
	 tab = _tnl_light_fast_single_tab;
      else
	 tab = _tnl_light_fast_tab;
   }


   LIGHT_STAGE_DATA(stage)->light_func_tab = tab;

   /* This and the above should only be done on _NEW_LIGHT:
    */
   TNL_CONTEXT(ctx)->Driver.NotifyMaterialChange( ctx );
}



/* Called the first time stage->run is called.  In effect, don't
 * allocate data until the first time the stage is run.
 */
static GLboolean init_lighting( struct gl_context *ctx,
				struct tnl_pipeline_stage *stage )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct light_stage_data *store;
   GLuint size = tnl->vb.Size;

   stage->privatePtr = malloc(sizeof(*store));
   store = LIGHT_STAGE_DATA(stage);
   if (!store)
      return GL_FALSE;

   /* Do onetime init.
    */
   init_lighting_tables();

   _mesa_vector4f_alloc( &store->Input, 0, size, 32 );
   _mesa_vector4f_alloc( &store->LitColor[0], 0, size, 32 );
   _mesa_vector4f_alloc( &store->LitColor[1], 0, size, 32 );
   _mesa_vector4f_alloc( &store->LitSecondary[0], 0, size, 32 );
   _mesa_vector4f_alloc( &store->LitSecondary[1], 0, size, 32 );

   store->LitColor[0].size = 4;
   store->LitColor[1].size = 4;
   store->LitSecondary[0].size = 3;
   store->LitSecondary[1].size = 3;

   return GL_TRUE;
}




static void dtr( struct tnl_pipeline_stage *stage )
{
   struct light_stage_data *store = LIGHT_STAGE_DATA(stage);

   if (store) {
      _mesa_vector4f_free( &store->Input );
      _mesa_vector4f_free( &store->LitColor[0] );
      _mesa_vector4f_free( &store->LitColor[1] );
      _mesa_vector4f_free( &store->LitSecondary[0] );
      _mesa_vector4f_free( &store->LitSecondary[1] );
      free( store );
      stage->privatePtr = NULL;
   }
}

const struct tnl_pipeline_stage _tnl_lighting_stage =
{
   "lighting",			/* name */
   NULL,			/* private_data */
   init_lighting,
   dtr,				/* destroy */
   validate_lighting,
   run_lighting
};
@


1.5
log
@Merge Mesa 9.2.0
@
text
@@


1.4
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  6.5
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d39 1
d80 108
d213 1
a213 1
   _mesa_validate_all_lighting_tables( ctx );
d230 1
a230 1
   /* Examine the ColorMaterialBitmask to determine which materials
d235 1
a235 1
      const GLuint bitmask = ctx->Light.ColorMaterialBitmask;
d261 2
a262 1
   _mesa_validate_all_lighting_tables( ctx );
d267 20
d424 1
a424 1
   stage->privatePtr = MALLOC(sizeof(*store));
d460 1
a460 1
      FREE( store );
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d44 1
a44 1
typedef void (*light_func)( GLcontext *ctx,
d88 1
a88 1
update_materials(GLcontext *ctx, struct light_stage_data *store)
d113 1
a113 1
prepare_materials(GLcontext *ctx,
d195 1
a195 1
static GLboolean run_lighting( GLcontext *ctx, 
d253 1
a253 1
static void validate_lighting( GLcontext *ctx,
d287 1
a287 1
static GLboolean init_lighting( GLcontext *ctx,
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a66 1
   GLvector4f LitIndex[2];
d129 1
a129 1
	    VB->AttribPtr[_TNL_ATTRIB_MAT_FRONT_AMBIENT + i] = VB->ColorPtr[0];
a162 1
static light_func _tnl_light_ci_tab[MAX_LIGHT_FUNC];
d201 1
a201 1
   GLvector4f *input = ctx->_NeedEyeCoords ? VB->EyePtr : VB->ObjPtr;
d209 1
a209 1
   if (input->size <= 2 && input == VB->ObjPtr) {
d212 2
a213 2
		      VB->ObjPtr->data,
		      VB->ObjPtr->stride,
d215 1
a215 1
		      VB->ObjPtr->size,
a246 4
   VB->AttribPtr[_TNL_ATTRIB_COLOR0] = VB->ColorPtr[0];
   VB->AttribPtr[_TNL_ATTRIB_COLOR1] = VB->SecondaryColorPtr[0];
   VB->AttribPtr[_TNL_ATTRIB_COLOR_INDEX] = VB->IndexPtr[0];

d261 11
a271 13
   if (ctx->Visual.rgbMode) {
      if (ctx->Light._NeedVertices) {
	 if (ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR)
	    tab = _tnl_light_spec_tab;
	 else
	    tab = _tnl_light_tab;
      }
      else {
	 if (ctx->Light.EnabledList.next == ctx->Light.EnabledList.prev)
	    tab = _tnl_light_fast_single_tab;
	 else
	    tab = _tnl_light_fast_tab;
      }
a272 2
   else
      tab = _tnl_light_ci_tab;
a307 2
   _mesa_vector4f_alloc( &store->LitIndex[0], 0, size, 32 );
   _mesa_vector4f_alloc( &store->LitIndex[1], 0, size, 32 );
a313 5
   store->LitIndex[0].size = 1;
   store->LitIndex[0].stride = sizeof(GLfloat);
   store->LitIndex[1].size = 1;
   store->LitIndex[1].stride = sizeof(GLfloat);

a329 2
      _mesa_vector4f_free( &store->LitIndex[0] );
      _mesa_vector4f_free( &store->LitIndex[1] );
@


1.1
log
@Initial revision
@
text
@d27 7
a33 7
#include "glheader.h"
#include "colormac.h"
#include "light.h"
#include "macros.h"
#include "imports.h"
#include "simple_list.h"
#include "mtypes.h"
d206 1
a206 4
   if (ctx->ShaderObjects._VertexShaderPresent)
      return GL_TRUE;

   if (!ctx->Light.Enabled || ctx->VertexProgram._Enabled)
d264 1
a264 4
   if (ctx->ShaderObjects._VertexShaderPresent)
      return;

   if (!ctx->Light.Enabled || ctx->VertexProgram._Enabled)
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d206 4
a209 1
   if (!ctx->Light.Enabled || ctx->VertexProgram._Current)
d267 4
a270 1
   if (!ctx->Light.Enabled || ctx->VertexProgram._Current)
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d27 7
a33 7
#include "main/glheader.h"
#include "main/colormac.h"
#include "main/light.h"
#include "main/macros.h"
#include "main/imports.h"
#include "main/simple_list.h"
#include "main/mtypes.h"
d44 1
a44 1
typedef void (*light_func)( struct gl_context *ctx,
d67 1
d89 1
a89 1
update_materials(struct gl_context *ctx, struct light_stage_data *store)
d114 1
a114 1
prepare_materials(struct gl_context *ctx,
d130 1
a130 1
	    VB->AttribPtr[_TNL_ATTRIB_MAT_FRONT_AMBIENT + i] = VB->AttribPtr[_TNL_ATTRIB_COLOR0];
d164 1
d197 1
a197 1
static GLboolean run_lighting( struct gl_context *ctx, 
d203 1
a203 1
   GLvector4f *input = ctx->_NeedEyeCoords ? VB->EyePtr : VB->AttribPtr[_TNL_ATTRIB_POS];
d211 1
a211 1
   if (input->size <= 2 && input == VB->AttribPtr[_TNL_ATTRIB_POS]) {
d214 2
a215 2
		      VB->AttribPtr[_TNL_ATTRIB_POS]->data,
		      VB->AttribPtr[_TNL_ATTRIB_POS]->stride,
d217 1
a217 1
		      VB->AttribPtr[_TNL_ATTRIB_POS]->size,
d249 4
d259 1
a259 1
static void validate_lighting( struct gl_context *ctx,
d267 13
a279 11
   if (ctx->Light._NeedVertices) {
      if (ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR)
	 tab = _tnl_light_spec_tab;
      else
	 tab = _tnl_light_tab;
   }
   else {
      if (ctx->Light.EnabledList.next == ctx->Light.EnabledList.prev)
	 tab = _tnl_light_fast_single_tab;
      else
	 tab = _tnl_light_fast_tab;
d281 2
d297 1
a297 1
static GLboolean init_lighting( struct gl_context *ctx,
d318 2
d326 5
d347 2
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a38 1
#include "tnl.h"
a78 108
/**********************************************************************/
/*****                  Lighting computation                      *****/
/**********************************************************************/


/*
 * Notes:
 *   When two-sided lighting is enabled we compute the color (or index)
 *   for both the front and back side of the primitive.  Then, when the
 *   orientation of the facet is later learned, we can determine which
 *   color (or index) to use for rendering.
 *
 *   KW: We now know orientation in advance and only shade for
 *       the side or sides which are actually required.
 *
 * Variables:
 *   n = normal vector
 *   V = vertex position
 *   P = light source position
 *   Pe = (0,0,0,1)
 *
 * Precomputed:
 *   IF P[3]==0 THEN
 *       // light at infinity
 *       IF local_viewer THEN
 *           _VP_inf_norm = unit vector from V to P      // Precompute
 *       ELSE
 *           // eye at infinity
 *           _h_inf_norm = Normalize( VP + <0,0,1> )     // Precompute
 *       ENDIF
 *   ENDIF
 *
 * Functions:
 *   Normalize( v ) = normalized vector v
 *   Magnitude( v ) = length of vector v
 */



static void
validate_shine_table( struct gl_context *ctx, GLuint side, GLfloat shininess )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct tnl_shine_tab *list = tnl->_ShineTabList;
   struct tnl_shine_tab *s;

   ASSERT(side < 2);

   foreach(s, list)
      if ( s->shininess == shininess )
	 break;

   if (s == list) {
      GLint j;
      GLfloat *m;

      foreach(s, list)
	 if (s->refcount == 0)
	    break;

      m = s->tab;
      m[0] = 0.0;
      if (shininess == 0.0) {
	 for (j = 1 ; j <= SHINE_TABLE_SIZE ; j++)
	    m[j] = 1.0;
      }
      else {
	 for (j = 1 ; j < SHINE_TABLE_SIZE ; j++) {
            GLdouble t, x = j / (GLfloat) (SHINE_TABLE_SIZE - 1);
            if (x < 0.005) /* underflow check */
               x = 0.005;
            t = pow(x, shininess);
	    if (t > 1e-20)
	       m[j] = (GLfloat) t;
	    else
	       m[j] = 0.0;
	 }
	 m[SHINE_TABLE_SIZE] = 1.0;
      }

      s->shininess = shininess;
   }

   if (tnl->_ShineTable[side])
      tnl->_ShineTable[side]->refcount--;

   tnl->_ShineTable[side] = s;
   move_to_tail( list, s );
   s->refcount++;
}


void
_tnl_validate_shine_tables( struct gl_context *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   GLfloat shininess;
   
   shininess = ctx->Light.Material.Attrib[MAT_ATTRIB_FRONT_SHININESS][0];
   if (!tnl->_ShineTable[0] || tnl->_ShineTable[0]->shininess != shininess)
      validate_shine_table( ctx, 0, shininess );

   shininess = ctx->Light.Material.Attrib[MAT_ATTRIB_BACK_SHININESS][0];
   if (!tnl->_ShineTable[1] || tnl->_ShineTable[1]->shininess != shininess)
      validate_shine_table( ctx, 1, shininess );
}


d104 1
a104 1
   _tnl_validate_shine_tables( ctx );
d121 1
a121 1
   /* Examine the _ColorMaterialBitmask to determine which materials
d126 1
a126 1
      const GLuint bitmask = ctx->Light._ColorMaterialBitmask;
d152 1
a152 2

   _tnl_validate_shine_tables( ctx );
a156 20
/*
 * Compute dp ^ SpecularExponent.
 * Lerp between adjacent values in the f(x) lookup table, giving a
 * continuous function, with adequate overall accuracy.  (Though still
 * pretty good compared to a straight lookup).
 */
static inline GLfloat
lookup_shininess(const struct gl_context *ctx, GLuint face, GLfloat dp)
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   const struct tnl_shine_tab *tab = tnl->_ShineTable[face];
   float f = dp * (SHINE_TABLE_SIZE - 1);
   int k = (int) f;
   if (k < 0 /* gcc may cast an overflow float value to negative int value */
	|| k > SHINE_TABLE_SIZE - 2)
      return powf(dp, tab->shininess);
   else
      return tab->tab[k] + (f - k) * (tab->tab[k+1] - tab->tab[k]);
}

d294 1
a294 1
   stage->privatePtr = malloc(sizeof(*store));
d330 1
a330 1
      free( store );
@


