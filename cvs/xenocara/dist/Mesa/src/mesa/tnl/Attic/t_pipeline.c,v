head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.4.0.8
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.09.05.14.06.53;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.29;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.32.17;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.49;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.17.37;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.35.13;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Whitwell <keithw@@vmware.com>
 */

#include "main/glheader.h"
#include "main/context.h"
#include "main/imports.h"
#include "main/mtypes.h"

#include "t_context.h"
#include "t_pipeline.h"
#include "t_vp_build.h"
#include "t_vertex.h"

void _tnl_install_pipeline( struct gl_context *ctx,
			    const struct tnl_pipeline_stage **stages )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   GLuint i;

   tnl->pipeline.new_state = ~0;

   /* Create a writeable copy of each stage.
    */
   for (i = 0 ; i < MAX_PIPELINE_STAGES && stages[i] ; i++) {
      struct tnl_pipeline_stage *s = &tnl->pipeline.stages[i];
      memcpy(s, stages[i], sizeof(*s));
      if (s->create)
	 s->create(ctx, s);
   }

   tnl->pipeline.nr_stages = i;
}

void _tnl_destroy_pipeline( struct gl_context *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   GLuint i;

   for (i = 0 ; i < tnl->pipeline.nr_stages ; i++) {
      struct tnl_pipeline_stage *s = &tnl->pipeline.stages[i];
      if (s->destroy)
	 s->destroy(s);
   }

   tnl->pipeline.nr_stages = 0;
}



static GLuint check_input_changes( struct gl_context *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   GLuint i;
   
   for (i = 0; i <= _TNL_LAST_MAT; i++) {
      if (tnl->vb.AttribPtr[i]->size != tnl->pipeline.last_attrib_size[i] ||
	  tnl->vb.AttribPtr[i]->stride != tnl->pipeline.last_attrib_stride[i]) {
	 tnl->pipeline.last_attrib_size[i] = tnl->vb.AttribPtr[i]->size;
	 tnl->pipeline.last_attrib_stride[i] = tnl->vb.AttribPtr[i]->stride;
	 tnl->pipeline.input_changes |= 1<<i;
      }
   }

   return tnl->pipeline.input_changes;
}


static GLuint check_output_changes( struct gl_context *ctx )
{
#if 0
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   
   for (i = 0; i < VARYING_SLOT_MAX; i++) {
      if (tnl->vb.ResultPtr[i]->size != tnl->last_result_size[i] ||
	  tnl->vb.ResultPtr[i]->stride != tnl->last_result_stride[i]) {
	 tnl->last_result_size[i] = tnl->vb.ResultPtr[i]->size;
	 tnl->last_result_stride[i] = tnl->vb.ResultPtr[i]->stride;
	 tnl->pipeline.output_changes |= 1<<i;
      }
   }

   if (tnl->pipeline.output_changes) 
      tnl->Driver.NotifyOutputChanges( ctx, tnl->pipeline.output_changes );
   
   return tnl->pipeline.output_changes;
#else
   return ~0;
#endif
}


void _tnl_run_pipeline( struct gl_context *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   unsigned short __tmp;
   GLuint i;

   if (!tnl->vb.Count)
      return;

   /* Check for changed input sizes or change in stride to/from zero
    * (ie const or non-const).
    */
   if (check_input_changes( ctx ) || tnl->pipeline.new_state) {
      if (ctx->VertexProgram._MaintainTnlProgram)
	 _tnl_UpdateFixedFunctionProgram( ctx );

      for (i = 0; i < tnl->pipeline.nr_stages ; i++) {
	 struct tnl_pipeline_stage *s = &tnl->pipeline.stages[i];
	 if (s->validate)
	    s->validate( ctx, s );
      }
      
      tnl->pipeline.new_state = 0;
      tnl->pipeline.input_changes = 0;
      
      /* Pipeline can only change its output in response to either a
       * statechange or an input size/stride change.  No other changes
       * are allowed.
       */
      if (check_output_changes( ctx ))
	 _tnl_notify_pipeline_output_change( ctx );
   }

#ifndef _OPENMP
   /* Don't adjust FPU precision mode in case multiple threads are to be used.
    * This would require that the additional threads also changed the FPU mode
    * which is quite a mess as this had to be done in all parallelized sections;
    * otherwise the master thread and all other threads are running in different
    * modes, producing inconsistent results.
    * Note that all x64 implementations don't define/use START_FAST_MATH, so
    * this is "hack" is only used in i386 mode
    */
   START_FAST_MATH(__tmp);
#endif

   for (i = 0; i < tnl->pipeline.nr_stages ; i++) {
      struct tnl_pipeline_stage *s = &tnl->pipeline.stages[i];
      if (!s->run( ctx, s ))
	 break;
   }

#ifndef _OPENMP
   END_FAST_MATH(__tmp);
#endif
}



/* The default pipeline.  This is useful for software rasterizers, and
 * simple hardware rasterizers.  For customization, I don't recommend
 * tampering with the internals of these stages in the way that
 * drivers did in Mesa 3.4.  These stages are basically black boxes,
 * and should be left intact.
 *
 * To customize the pipeline, consider:
 *
 * - removing redundant stages (making sure that the software rasterizer
 *   can cope with this on fallback paths).  An example is fog
 *   coordinate generation, which is not required in the FX driver.
 *
 * - replacing general-purpose machine-independent stages with
 *   general-purpose machine-specific stages.  There is no example of
 *   this to date, though it must be borne in mind that all subsequent
 *   stages that reference the output of the new stage must cope with
 *   any machine-specific data introduced.  This may not be easy
 *   unless there are no such stages (ie the new stage is the last in
 *   the pipe).
 *
 * - inserting optimized (but specialized) stages ahead of the
 *   general-purpose fallback implementation.  For example, the old
 *   fastpath mechanism, which only works when the VB->Elts input is
 *   available, can be duplicated by placing the fastpath stage at the
 *   head of this pipeline.  Such specialized stages are currently
 *   constrained to have no outputs (ie. they must either finish the *
 *   pipeline by returning GL_FALSE from run(), or do nothing).
 *
 * Some work can be done to lift some of the restrictions in the final
 * case, if it becomes necessary to do so.
 */
const struct tnl_pipeline_stage *_tnl_default_pipeline[] = {
   &_tnl_vertex_transform_stage,
   &_tnl_normal_transform_stage,
   &_tnl_lighting_stage,
   &_tnl_texgen_stage,
   &_tnl_texture_transform_stage,
   &_tnl_point_attenuation_stage,
   &_tnl_vertex_program_stage, 
   &_tnl_fog_coordinate_stage,
   &_tnl_render_stage,
   NULL 
};

const struct tnl_pipeline_stage *_tnl_vp_pipeline[] = {
   &_tnl_vertex_program_stage,
   &_tnl_render_stage,
   NULL
};
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.5
log
@Merge Mesa 9.2.0
@
text
@d25 1
a25 1
 *    Keith Whitwell <keith@@tungstengraphics.com>
@


1.4
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  6.5.3
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d97 1
a97 1
   for (i = 0; i < VERT_RESULT_MAX; i++) {
d149 9
d159 1
d167 1
d169 1
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d38 1
a38 1
void _tnl_install_pipeline( GLcontext *ctx,
d58 1
a58 1
void _tnl_destroy_pipeline( GLcontext *ctx )
d74 1
a74 1
static GLuint check_input_changes( GLcontext *ctx )
d92 1
a92 1
static GLuint check_output_changes( GLcontext *ctx )
d116 1
a116 1
void _tnl_run_pipeline( GLcontext *ctx )
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a30 1
#include "main/state.h"
d50 1
a50 1
      MEMCPY(s, stages[i], sizeof(*s));
a86 4

   if (tnl->pipeline.input_changes &&
      tnl->Driver.NotifyInputChanges) 
      tnl->Driver.NotifyInputChanges( ctx, tnl->pipeline.input_changes );
@


1.1
log
@Initial revision
@
text
@a0 1

d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d28 5
a32 5
#include "glheader.h"
#include "context.h"
#include "imports.h"
#include "state.h"
#include "mtypes.h"
d134 1
a134 1
      if (ctx->_MaintainTnlProgram)
a201 1
   &_tnl_fog_coordinate_stage,
a204 2
#if defined(FEATURE_NV_vertex_program) || defined(FEATURE_ARB_vertex_program)
   &_tnl_arb_vertex_program_stage,
d206 1
a206 4
#endif
#if FEATURE_ARB_vertex_shader
   &_tnl_arb_vertex_shader_stage,
#endif
d212 1
a212 1
   &_tnl_arb_vertex_program_stage,
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d1 1
d4 1
a4 1
 * Version:  6.5.3
d6 1
a6 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d135 1
a135 1
      if (ctx->VertexProgram._MaintainTnlProgram)
d207 2
d210 4
d219 1
a219 1
   &_tnl_vertex_program_stage,
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d28 5
a32 4
#include "main/glheader.h"
#include "main/context.h"
#include "main/imports.h"
#include "main/mtypes.h"
d39 1
a39 1
void _tnl_install_pipeline( struct gl_context *ctx,
d51 1
a51 1
      memcpy(s, stages[i], sizeof(*s));
d59 1
a59 1
void _tnl_destroy_pipeline( struct gl_context *ctx )
d75 1
a75 1
static GLuint check_input_changes( struct gl_context *ctx )
d89 4
d97 1
a97 1
static GLuint check_output_changes( struct gl_context *ctx )
d121 1
a121 1
void _tnl_run_pipeline( struct gl_context *ctx )
d202 1
a206 1
   &_tnl_fog_coordinate_stage,
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d97 1
a97 1
   for (i = 0; i < VARYING_SLOT_MAX; i++) {
a148 9
#ifndef _OPENMP
   /* Don't adjust FPU precision mode in case multiple threads are to be used.
    * This would require that the additional threads also changed the FPU mode
    * which is quite a mess as this had to be done in all parallelized sections;
    * otherwise the master thread and all other threads are running in different
    * modes, producing inconsistent results.
    * Note that all x64 implementations don't define/use START_FAST_MATH, so
    * this is "hack" is only used in i386 mode
    */
a149 1
#endif
a156 1
#ifndef _OPENMP
a157 1
#endif
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d25 1
a25 1
 *    Keith Whitwell <keithw@@vmware.com>
@


