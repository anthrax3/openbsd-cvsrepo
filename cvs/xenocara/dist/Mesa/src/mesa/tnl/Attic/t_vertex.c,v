head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	4ry2gvZGMXkCUD2n;

1.8
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.7;
commitid	mcxB0JvoI9gTDYXU;

1.7
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.14.06.54;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.46;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.36;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.33;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.32.20;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.49;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.17.41;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.35.13;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.13.34;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.50.40;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
 * VMWARE AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Whitwell <keithw@@vmware.com>
 */

#include "main/glheader.h"
#include "main/context.h"
#include "main/colormac.h"
#include "swrast/s_chan.h"
#include "t_context.h"
#include "t_vertex.h"

#define DBG 0

/* Build and manage clipspace/ndc/window vertices.
 */

static GLboolean match_fastpath( struct tnl_clipspace *vtx,
				 const struct tnl_clipspace_fastpath *fp)
{
   GLuint j;

   if (vtx->attr_count != fp->attr_count) 
      return GL_FALSE;

   for (j = 0; j < vtx->attr_count; j++) 
      if (vtx->attr[j].format != fp->attr[j].format ||
	  vtx->attr[j].inputsize != fp->attr[j].size ||
	  vtx->attr[j].vertoffset != fp->attr[j].offset) 
	 return GL_FALSE;
      
   if (fp->match_strides) {
      if (vtx->vertex_size != fp->vertex_size)
	 return GL_FALSE;

      for (j = 0; j < vtx->attr_count; j++) 
	 if (vtx->attr[j].inputstride != fp->attr[j].stride) 
	    return GL_FALSE;
   }
   
   return GL_TRUE;
}

static GLboolean search_fastpath_emit( struct tnl_clipspace *vtx )
{
   struct tnl_clipspace_fastpath *fp = vtx->fastpath;

   for ( ; fp ; fp = fp->next) {
      if (match_fastpath(vtx, fp)) {
         vtx->emit = fp->func;
	 return GL_TRUE;
      }
   }

   return GL_FALSE;
}

void _tnl_register_fastpath( struct tnl_clipspace *vtx,
			     GLboolean match_strides )
{
   struct tnl_clipspace_fastpath *fastpath = CALLOC_STRUCT(tnl_clipspace_fastpath);
   GLuint i;

   if (fastpath == NULL) {
      _mesa_error_no_memory(__func__);
      return;
   }

   fastpath->vertex_size = vtx->vertex_size;
   fastpath->attr_count = vtx->attr_count;
   fastpath->match_strides = match_strides;
   fastpath->func = vtx->emit;
   fastpath->attr = malloc(vtx->attr_count * sizeof(fastpath->attr[0]));

   if (fastpath->attr == NULL) {
      free(fastpath);
      _mesa_error_no_memory(__func__);
      return;
   }

   for (i = 0; i < vtx->attr_count; i++) {
      fastpath->attr[i].format = vtx->attr[i].format;
      fastpath->attr[i].stride = vtx->attr[i].inputstride;
      fastpath->attr[i].size = vtx->attr[i].inputsize;
      fastpath->attr[i].offset = vtx->attr[i].vertoffset;
   }

   fastpath->next = vtx->fastpath;
   vtx->fastpath = fastpath;
}



/***********************************************************************
 * Build codegen functions or return generic ones:
 */
static void choose_emit_func( struct gl_context *ctx, GLuint count, GLubyte *dest)
{
   struct vertex_buffer *VB = &TNL_CONTEXT(ctx)->vb;
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   struct tnl_clipspace_attr *a = vtx->attr;
   const GLuint attr_count = vtx->attr_count;
   GLuint j;

   for (j = 0; j < attr_count; j++) {
      GLvector4f *vptr = VB->AttribPtr[a[j].attrib];
      a[j].inputstride = vptr->stride;
      a[j].inputsize = vptr->size;
      a[j].emit = a[j].insert[vptr->size - 1]; /* not always used */
   }

   vtx->emit = NULL;
   
   /* Does this match an existing (hardwired, codegen or known-bad)
    * fastpath?
    */
   if (search_fastpath_emit(vtx)) {
      /* Use this result.  If it is null, then it is already known
       * that the current state will fail for codegen and there is no
       * point trying again.
       */
   }
   else if (vtx->codegen_emit) {
      vtx->codegen_emit(ctx);
   }

   if (!vtx->emit) {
      _tnl_generate_hardwired_emit(ctx);
   }

   /* Otherwise use the generic version:
    */
   if (!vtx->emit)
      vtx->emit = _tnl_generic_emit;

   vtx->emit( ctx, count, dest );
}



static void choose_interp_func( struct gl_context *ctx,
				GLfloat t,
				GLuint edst, GLuint eout, GLuint ein,
				GLboolean force_boundary )
{
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   GLboolean unfilled = (ctx->Polygon.FrontMode != GL_FILL ||
                         ctx->Polygon.BackMode != GL_FILL);
   GLboolean twosided = ctx->Light.Enabled && ctx->Light.Model.TwoSide;

   if (vtx->need_extras && (twosided || unfilled)) {
      vtx->interp = _tnl_generic_interp_extras;
   } else {
      vtx->interp = _tnl_generic_interp;
   }

   vtx->interp( ctx, t, edst, eout, ein, force_boundary );
}


static void choose_copy_pv_func(  struct gl_context *ctx, GLuint edst, GLuint esrc )
{
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   GLboolean unfilled = (ctx->Polygon.FrontMode != GL_FILL ||
                         ctx->Polygon.BackMode != GL_FILL);

   GLboolean twosided = ctx->Light.Enabled && ctx->Light.Model.TwoSide;

   if (vtx->need_extras && (twosided || unfilled)) {
      vtx->copy_pv = _tnl_generic_copy_pv_extras;
   } else {
      vtx->copy_pv = _tnl_generic_copy_pv;
   }

   vtx->copy_pv( ctx, edst, esrc );
}


/***********************************************************************
 * Public entrypoints, mostly dispatch to the above:
 */


/* Interpolate between two vertices to produce a third:
 */
void _tnl_interp( struct gl_context *ctx,
		  GLfloat t,
		  GLuint edst, GLuint eout, GLuint ein,
		  GLboolean force_boundary )
{
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   vtx->interp( ctx, t, edst, eout, ein, force_boundary );
}

/* Copy colors from one vertex to another:
 */
void _tnl_copy_pv(  struct gl_context *ctx, GLuint edst, GLuint esrc )
{
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   vtx->copy_pv( ctx, edst, esrc );
}


/* Extract a named attribute from a hardware vertex.  Will have to
 * reverse any viewport transformation, swizzling or other conversions
 * which may have been applied:
 */
void _tnl_get_attr( struct gl_context *ctx, const void *vin,
			      GLenum attr, GLfloat *dest )
{
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   const struct tnl_clipspace_attr *a = vtx->attr;
   const GLuint attr_count = vtx->attr_count;
   GLuint j;

   for (j = 0; j < attr_count; j++) {
      if (a[j].attrib == attr) {
	 a[j].extract( &a[j], dest, (GLubyte *)vin + a[j].vertoffset );
	 return;
      }
   }

   /* Else return the value from ctx->Current.
    */
   if (attr == _TNL_ATTRIB_POINTSIZE) {
      /* If the hardware vertex doesn't have point size then use size from
       * struct gl_context.  XXX this will be wrong if drawing attenuated points!
       */
      dest[0] = ctx->Point.Size;
   }
   else {
      memcpy( dest, ctx->Current.Attrib[attr], 4*sizeof(GLfloat));
   }
}


/* Complementary operation to the above.
 */
void _tnl_set_attr( struct gl_context *ctx, void *vout,
		    GLenum attr, const GLfloat *src )
{
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   const struct tnl_clipspace_attr *a = vtx->attr;
   const GLuint attr_count = vtx->attr_count;
   GLuint j;

   for (j = 0; j < attr_count; j++) {
      if (a[j].attrib == attr) {
	 a[j].insert[4-1]( &a[j], (GLubyte *)vout + a[j].vertoffset, src );
	 return;
      }
   }
}


void *_tnl_get_vertex( struct gl_context *ctx, GLuint nr )
{
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);

   return vtx->vertex_buf + nr * vtx->vertex_size;
}

void _tnl_invalidate_vertex_state( struct gl_context *ctx, GLuint new_state )
{
   /* if two-sided lighting changes or filled/unfilled polygon state changes */
   if (new_state & (_NEW_LIGHT | _NEW_POLYGON) ) {
      struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
      vtx->new_inputs = ~0;
      vtx->interp = choose_interp_func;
      vtx->copy_pv = choose_copy_pv_func;
   }
}

static void invalidate_funcs( struct tnl_clipspace *vtx )
{
   vtx->emit = choose_emit_func;
   vtx->interp = choose_interp_func;
   vtx->copy_pv = choose_copy_pv_func;
   vtx->new_inputs = ~0;
}

GLuint _tnl_install_attrs( struct gl_context *ctx, const struct tnl_attr_map *map,
			   GLuint nr, const GLfloat *vp, 
			   GLuint unpacked_size )
{
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   GLuint offset = 0;
   GLuint i, j;

   assert(nr < _TNL_ATTRIB_MAX);
   assert(nr == 0 || map[0].attrib == VERT_ATTRIB_POS);

   vtx->new_inputs = ~0;
   vtx->need_viewport = GL_FALSE;

   if (vp) {
      vtx->need_viewport = GL_TRUE;
   }

   for (j = 0, i = 0; i < nr; i++) {
      const GLuint format = map[i].format;
      if (format == EMIT_PAD) {
	 if (DBG)
	    printf("%d: pad %d, offset %d\n", i,  
		   map[i].offset, offset);  

	 offset += map[i].offset;

      }
      else {
	 GLuint tmpoffset;

	 if (unpacked_size) 
	    tmpoffset = map[i].offset;
	 else
	    tmpoffset = offset;

	 if (vtx->attr_count != j ||
	     vtx->attr[j].attrib != map[i].attrib ||
	     vtx->attr[j].format != format ||
	     vtx->attr[j].vertoffset != tmpoffset) {
	    invalidate_funcs(vtx);

	    vtx->attr[j].attrib = map[i].attrib;
	    vtx->attr[j].format = format;
	    vtx->attr[j].vp = vp;
	    vtx->attr[j].insert = _tnl_format_info[format].insert;
	    vtx->attr[j].extract = _tnl_format_info[format].extract;
	    vtx->attr[j].vertattrsize = _tnl_format_info[format].attrsize;
	    vtx->attr[j].vertoffset = tmpoffset;
	 }

	 
	 if (DBG)
	    printf("%d: %s, vp %p, offset %d\n", i,  
		   _tnl_format_info[format].name, (void *)vp,
		   vtx->attr[j].vertoffset);   

	 offset += _tnl_format_info[format].attrsize;
	 j++;
      }
   }

   vtx->attr_count = j;

   if (unpacked_size)
      vtx->vertex_size = unpacked_size;
   else
      vtx->vertex_size = offset;

   assert(vtx->vertex_size <= vtx->max_vertex_size);
   return vtx->vertex_size;
}



void _tnl_invalidate_vertices( struct gl_context *ctx, GLuint newinputs )
{
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   vtx->new_inputs |= newinputs;
}


/* This event has broader use beyond this file - will move elsewhere
 * and probably invoke a driver callback.
 */
void _tnl_notify_pipeline_output_change( struct gl_context *ctx )
{
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   invalidate_funcs(vtx);
}


static void adjust_input_ptrs( struct gl_context *ctx, GLint diff)
{
   struct vertex_buffer *VB = &TNL_CONTEXT(ctx)->vb;
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   struct tnl_clipspace_attr *a = vtx->attr;
   const GLuint count = vtx->attr_count;
   GLuint j;

   diff -= 1;
   for (j=0; j<count; ++j) {
           register GLvector4f *vptr = VB->AttribPtr[a->attrib];
	   (a++)->inputptr += diff*vptr->stride;
   }
}

static void update_input_ptrs( struct gl_context *ctx, GLuint start )
{
   struct vertex_buffer *VB = &TNL_CONTEXT(ctx)->vb;
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   struct tnl_clipspace_attr *a = vtx->attr;
   const GLuint count = vtx->attr_count;
   GLuint j;
   
   for (j = 0; j < count; j++) {
      GLvector4f *vptr = VB->AttribPtr[a[j].attrib];

      if (vtx->emit != choose_emit_func) {
	 assert(a[j].inputstride == vptr->stride);
	 assert(a[j].inputsize == vptr->size);
      }

      a[j].inputptr = ((GLubyte *)vptr->data) + start * vptr->stride;
   }
   
   if (a->vp) {
      vtx->vp_scale[0] = a->vp[MAT_SX];
      vtx->vp_scale[1] = a->vp[MAT_SY];
      vtx->vp_scale[2] = a->vp[MAT_SZ];
      vtx->vp_scale[3] = 1.0;
      vtx->vp_xlate[0] = a->vp[MAT_TX];
      vtx->vp_xlate[1] = a->vp[MAT_TY];
      vtx->vp_xlate[2] = a->vp[MAT_TZ];
      vtx->vp_xlate[3] = 0.0;
   }
}


void _tnl_build_vertices( struct gl_context *ctx,
			  GLuint start,
			  GLuint end,
			  GLuint newinputs )
{
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);  
   update_input_ptrs( ctx, start );      
   vtx->emit( ctx, end - start, 
	      (GLubyte *)(vtx->vertex_buf + 
			  start * vtx->vertex_size));
}

/* Emit VB vertices start..end to dest.  Note that VB vertex at
 * postion start will be emitted to dest at position zero.
 */
void *_tnl_emit_vertices_to_buffer( struct gl_context *ctx,
				    GLuint start,
				    GLuint end,
				    void *dest )
{
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);

   update_input_ptrs(ctx, start);
   /* Note: dest should not be adjusted for non-zero 'start' values:
    */
   vtx->emit( ctx, end - start, (GLubyte*) dest );	
   return (void *)((GLubyte *)dest + vtx->vertex_size * (end - start));
}

/* Emit indexed VB vertices start..end to dest.  Note that VB vertex at
 * postion start will be emitted to dest at position zero.
 */

void *_tnl_emit_indexed_vertices_to_buffer( struct gl_context *ctx,
					    const GLuint *elts,
					    GLuint start,
					    GLuint end,
					    void *dest )
{
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   GLuint oldIndex;
   GLubyte *cdest = dest;

   update_input_ptrs(ctx, oldIndex = elts[start++]);
   vtx->emit( ctx, 1, cdest );
   cdest += vtx->vertex_size;

   for (; start < end; ++start) {
      adjust_input_ptrs(ctx, elts[start] - oldIndex);
      oldIndex = elts[start];
      vtx->emit( ctx, 1, cdest);
      cdest += vtx->vertex_size;
   }

   return (void *) cdest;
}


void _tnl_init_vertices( struct gl_context *ctx, 
			GLuint vb_size,
			GLuint max_vertex_size )
{
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);  

   _tnl_install_attrs( ctx, NULL, 0, NULL, 0 );

   vtx->need_extras = GL_TRUE;
   if (max_vertex_size > vtx->max_vertex_size) {
      _tnl_free_vertices( ctx );
      vtx->max_vertex_size = max_vertex_size;
      vtx->vertex_buf = _mesa_align_calloc(vb_size * max_vertex_size, 32 );
      invalidate_funcs(vtx);
   }

   switch(CHAN_TYPE) {
   case GL_UNSIGNED_BYTE:
      vtx->chan_scale[0] = 255.0;
      vtx->chan_scale[1] = 255.0;
      vtx->chan_scale[2] = 255.0;
      vtx->chan_scale[3] = 255.0;
      break;
   case GL_UNSIGNED_SHORT:
      vtx->chan_scale[0] = 65535.0;
      vtx->chan_scale[1] = 65535.0;
      vtx->chan_scale[2] = 65535.0;
      vtx->chan_scale[3] = 65535.0;
      break;
   default:
      vtx->chan_scale[0] = 1.0;
      vtx->chan_scale[1] = 1.0;
      vtx->chan_scale[2] = 1.0;
      vtx->chan_scale[3] = 1.0;
      break;
   }

   vtx->identity[0] = 0.0;
   vtx->identity[1] = 0.0;
   vtx->identity[2] = 0.0;
   vtx->identity[3] = 1.0;

   vtx->codegen_emit = NULL;

#ifdef USE_SSE_ASM
   if (!_mesa_getenv("MESA_NO_CODEGEN"))
      vtx->codegen_emit = _tnl_generate_sse_emit;
#endif
}


void _tnl_free_vertices( struct gl_context *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   if (tnl) {
      struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
      struct tnl_clipspace_fastpath *fp, *tmp;

      _mesa_align_free(vtx->vertex_buf);
      vtx->vertex_buf = NULL;

      for (fp = vtx->fastpath ; fp ; fp = tmp) {
         tmp = fp->next;
         free(fp->attr);

         /* KW: At the moment, fp->func is constrained to be allocated by
          * _mesa_exec_alloc(), as the hardwired fastpaths in
          * t_vertex_generic.c are handled specially.  It would be nice
          * to unify them, but this probably won't change until this
          * module gets another overhaul.
          */
         _mesa_exec_free((void *) fp->func);
         free(fp);
      }

      vtx->fastpath = NULL;
   }
}
@


1.9
log
@Merge Mesa 10.2.9
@
text
@@


1.8
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d546 1
a546 1
   if (!getenv("MESA_NO_CODEGEN"))
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d546 1
a546 1
   if (!_mesa_getenv("MESA_NO_CODEGEN"))
@


1.6
log
@Merge Mesa 9.2.0
@
text
@d2 1
a2 1
 * Copyright 2003 Tungsten Graphics, inc.
d19 1
a19 1
 * TUNGSTEN GRAPHICS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
d25 1
a25 1
 *    Keith Whitwell <keithw@@tungstengraphics.com>
d86 5
d95 7
a101 2
   fastpath->attr =
      malloc(vtx->attr_count * sizeof(fastpath->attr[0]));
d559 2
a560 4
      if (vtx->vertex_buf) {
         _mesa_align_free(vtx->vertex_buf);
         vtx->vertex_buf = NULL;
      }
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d31 1
a31 1

d90 1
a90 1
   fastpath->attr = (struct tnl_attr_type *)
d159 3
d163 1
a163 2
   if (vtx->need_extras && 
       (ctx->_TriangleCaps & (DD_TRI_LIGHT_TWOSIDE|DD_TRI_UNFILLED))) {
d176 4
d181 1
a181 2
   if (vtx->need_extras && 
       (ctx->_TriangleCaps & (DD_TRI_LIGHT_TWOSIDE|DD_TRI_UNFILLED))) {
d277 2
a278 1
   if (new_state & (_DD_NEW_TRI_LIGHT_TWOSIDE|_DD_NEW_TRI_UNFILLED) ) {
d503 1
a503 1
      vtx->vertex_buf = (GLubyte *)_mesa_align_calloc(vb_size * max_vertex_size, 32 );
d556 1
a556 1
         FREE(fp->attr);
d565 1
a565 1
         FREE(fp);
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d109 1
a109 1
static void choose_emit_func( GLcontext *ctx, GLuint count, GLubyte *dest)
d153 1
a153 1
static void choose_interp_func( GLcontext *ctx,
d171 1
a171 1
static void choose_copy_pv_func(  GLcontext *ctx, GLuint edst, GLuint esrc )
d193 1
a193 1
void _tnl_interp( GLcontext *ctx,
d204 1
a204 1
void _tnl_copy_pv(  GLcontext *ctx, GLuint edst, GLuint esrc )
d215 1
a215 1
void _tnl_get_attr( GLcontext *ctx, const void *vin,
d234 1
a234 1
       * GLcontext.  XXX this will be wrong if drawing attenuated points!
d246 1
a246 1
void _tnl_set_attr( GLcontext *ctx, void *vout,
d263 1
a263 1
void *_tnl_get_vertex( GLcontext *ctx, GLuint nr )
d270 1
a270 1
void _tnl_invalidate_vertex_state( GLcontext *ctx, GLuint new_state )
d288 1
a288 1
GLuint _tnl_install_attrs( GLcontext *ctx, const struct tnl_attr_map *map,
d363 1
a363 1
void _tnl_invalidate_vertices( GLcontext *ctx, GLuint newinputs )
d373 1
a373 1
void _tnl_notify_pipeline_output_change( GLcontext *ctx )
d380 1
a380 1
static void adjust_input_ptrs( GLcontext *ctx, GLint diff)
d395 1
a395 1
static void update_input_ptrs( GLcontext *ctx, GLuint start )
d427 1
a427 1
void _tnl_build_vertices( GLcontext *ctx,
d442 1
a442 1
void *_tnl_emit_vertices_to_buffer( GLcontext *ctx,
d460 1
a460 1
void *_tnl_emit_indexed_vertices_to_buffer( GLcontext *ctx,
d485 1
a485 1
void _tnl_init_vertices( GLcontext *ctx, 
d536 1
a536 1
void _tnl_free_vertices( GLcontext *ctx )
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d91 1
a91 1
      _mesa_malloc(vtx->attr_count * sizeof(fastpath->attr[0]));
d239 1
a239 1
      _mesa_memcpy( dest, ctx->Current.Attrib[attr], 4*sizeof(GLfloat));
d310 2
a311 2
	    _mesa_printf("%d: pad %d, offset %d\n", i,  
			 map[i].offset, offset);  
d341 3
a343 3
	    _mesa_printf("%d: %s, vp %p, offset %d\n", i,  
			 _tnl_format_info[format].name, (void *)vp,
			 vtx->attr[j].vertoffset);   
d386 1
a386 1
   int j;
d497 1
a497 1
      vtx->vertex_buf = (GLubyte *)ALIGN_CALLOC(vb_size * max_vertex_size, 32 );
d538 23
a560 2
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   struct tnl_clipspace_fastpath *fp, *tmp;
d562 1
a562 3
   if (vtx->vertex_buf) {
      ALIGN_FREE(vtx->vertex_buf);
      vtx->vertex_buf = NULL;
a563 16
   
   for (fp = vtx->fastpath ; fp ; fp = tmp) {
      tmp = fp->next;
      FREE(fp->attr);

      /* KW: At the moment, fp->func is constrained to be allocated by
       * _mesa_exec_alloc(), as the hardwired fastpaths in
       * t_vertex_generic.c are handled specially.  It would be nice
       * to unify them, but this probably won't change until this
       * module gets another overhaul.
       */
      _mesa_exec_free((void *) fp->func);
      FREE(fp);
   }
   
   vtx->fastpath = NULL;
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d28 3
a30 3
#include "glheader.h"
#include "context.h"
#include "colormac.h"
d379 16
a449 1

d454 28
@


1.1
log
@Initial revision
@
text
@d232 9
a240 1
   _mesa_memcpy( dest, ctx->Current.Attrib[attr], 4*sizeof(GLfloat));
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d232 1
a232 9
   if (attr == _TNL_ATTRIB_POINTSIZE) {
      /* If the hardware vertex doesn't have point size then use size from
       * GLcontext.  XXX this will be wrong if drawing attenuated points!
       */
      dest[0] = ctx->Point._Size;
   }
   else {
      _mesa_memcpy( dest, ctx->Current.Attrib[attr], 4*sizeof(GLfloat));
   }
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d28 3
a30 3
#include "main/glheader.h"
#include "main/context.h"
#include "main/colormac.h"
d91 1
a91 1
      malloc(vtx->attr_count * sizeof(fastpath->attr[0]));
d109 1
a109 1
static void choose_emit_func( struct gl_context *ctx, GLuint count, GLubyte *dest)
d153 1
a153 1
static void choose_interp_func( struct gl_context *ctx,
d171 1
a171 1
static void choose_copy_pv_func(  struct gl_context *ctx, GLuint edst, GLuint esrc )
d193 1
a193 1
void _tnl_interp( struct gl_context *ctx,
d204 1
a204 1
void _tnl_copy_pv(  struct gl_context *ctx, GLuint edst, GLuint esrc )
d215 1
a215 1
void _tnl_get_attr( struct gl_context *ctx, const void *vin,
d234 1
a234 1
       * struct gl_context.  XXX this will be wrong if drawing attenuated points!
d236 1
a236 1
      dest[0] = ctx->Point.Size;
d239 1
a239 1
      memcpy( dest, ctx->Current.Attrib[attr], 4*sizeof(GLfloat));
d246 1
a246 1
void _tnl_set_attr( struct gl_context *ctx, void *vout,
d263 1
a263 1
void *_tnl_get_vertex( struct gl_context *ctx, GLuint nr )
d270 1
a270 1
void _tnl_invalidate_vertex_state( struct gl_context *ctx, GLuint new_state )
d288 1
a288 1
GLuint _tnl_install_attrs( struct gl_context *ctx, const struct tnl_attr_map *map,
d310 2
a311 2
	    printf("%d: pad %d, offset %d\n", i,  
		   map[i].offset, offset);  
d341 3
a343 3
	    printf("%d: %s, vp %p, offset %d\n", i,  
		   _tnl_format_info[format].name, (void *)vp,
		   vtx->attr[j].vertoffset);   
d363 1
a363 1
void _tnl_invalidate_vertices( struct gl_context *ctx, GLuint newinputs )
d373 1
a373 1
void _tnl_notify_pipeline_output_change( struct gl_context *ctx )
d379 1
a379 17

static void adjust_input_ptrs( struct gl_context *ctx, GLint diff)
{
   struct vertex_buffer *VB = &TNL_CONTEXT(ctx)->vb;
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   struct tnl_clipspace_attr *a = vtx->attr;
   const GLuint count = vtx->attr_count;
   GLuint j;

   diff -= 1;
   for (j=0; j<count; ++j) {
           register GLvector4f *vptr = VB->AttribPtr[a->attrib];
	   (a++)->inputptr += diff*vptr->stride;
   }
}

static void update_input_ptrs( struct gl_context *ctx, GLuint start )
d411 1
a411 1
void _tnl_build_vertices( struct gl_context *ctx,
d426 1
a426 1
void *_tnl_emit_vertices_to_buffer( struct gl_context *ctx,
d434 1
a440 13
/* Emit indexed VB vertices start..end to dest.  Note that VB vertex at
 * postion start will be emitted to dest at position zero.
 */

void *_tnl_emit_indexed_vertices_to_buffer( struct gl_context *ctx,
					    const GLuint *elts,
					    GLuint start,
					    GLuint end,
					    void *dest )
{
   struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
   GLuint oldIndex;
   GLubyte *cdest = dest;
d442 1
a442 16
   update_input_ptrs(ctx, oldIndex = elts[start++]);
   vtx->emit( ctx, 1, cdest );
   cdest += vtx->vertex_size;

   for (; start < end; ++start) {
      adjust_input_ptrs(ctx, elts[start] - oldIndex);
      oldIndex = elts[start];
      vtx->emit( ctx, 1, cdest);
      cdest += vtx->vertex_size;
   }

   return (void *) cdest;
}


void _tnl_init_vertices( struct gl_context *ctx, 
d454 1
a454 1
      vtx->vertex_buf = (GLubyte *)_mesa_align_calloc(vb_size * max_vertex_size, 32 );
d493 1
a493 1
void _tnl_free_vertices( struct gl_context *ctx )
d495 2
a496 4
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   if (tnl) {
      struct tnl_clipspace *vtx = GET_VERTEX_STATE(ctx);
      struct tnl_clipspace_fastpath *fp, *tmp;
d498 17
a514 20
      if (vtx->vertex_buf) {
         _mesa_align_free(vtx->vertex_buf);
         vtx->vertex_buf = NULL;
      }

      for (fp = vtx->fastpath ; fp ; fp = tmp) {
         tmp = fp->next;
         FREE(fp->attr);

         /* KW: At the moment, fp->func is constrained to be allocated by
          * _mesa_exec_alloc(), as the hardwired fastpaths in
          * t_vertex_generic.c are handled specially.  It would be nice
          * to unify them, but this probably won't change until this
          * module gets another overhaul.
          */
         _mesa_exec_free((void *) fp->func);
         FREE(fp);
      }

      vtx->fastpath = NULL;
d516 2
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d31 1
a31 1
#include "swrast/s_chan.h"
d90 1
a90 1
   fastpath->attr =
a158 3
   GLboolean unfilled = (ctx->Polygon.FrontMode != GL_FILL ||
                         ctx->Polygon.BackMode != GL_FILL);
   GLboolean twosided = ctx->Light.Enabled && ctx->Light.Model.TwoSide;
d160 2
a161 1
   if (vtx->need_extras && (twosided || unfilled)) {
a173 4
   GLboolean unfilled = (ctx->Polygon.FrontMode != GL_FILL ||
                         ctx->Polygon.BackMode != GL_FILL);

   GLboolean twosided = ctx->Light.Enabled && ctx->Light.Model.TwoSide;
d175 2
a176 1
   if (vtx->need_extras && (twosided || unfilled)) {
d272 1
a272 2
   /* if two-sided lighting changes or filled/unfilled polygon state changes */
   if (new_state & (_NEW_LIGHT | _NEW_POLYGON) ) {
d497 1
a497 1
      vtx->vertex_buf = _mesa_align_calloc(vb_size * max_vertex_size, 32 );
d550 1
a550 1
         free(fp->attr);
d559 1
a559 1
         free(fp);
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d2 1
a2 1
 * Copyright 2003 VMware, Inc.
d19 1
a19 1
 * VMWARE AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
d25 1
a25 1
 *    Keith Whitwell <keithw@@vmware.com>
a85 5
   if (fastpath == NULL) {
      _mesa_error_no_memory(__func__);
      return;
   }

d90 2
a91 7
   fastpath->attr = malloc(vtx->attr_count * sizeof(fastpath->attr[0]));

   if (fastpath->attr == NULL) {
      free(fastpath);
      _mesa_error_no_memory(__func__);
      return;
   }
d549 4
a552 2
      _mesa_align_free(vtx->vertex_buf);
      vtx->vertex_buf = NULL;
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@d546 1
a546 1
   if (!getenv("MESA_NO_CODEGEN"))
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d546 1
a546 1
   if (!_mesa_getenv("MESA_NO_CODEGEN"))
@


