head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.6
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.55;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2013.09.05.14.06.53;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.29;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.29;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.52;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.32.17;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.49;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.17.36;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file t_context.h
 * \brief TnL module datatypes and definitions.
 * \author Keith Whitwell
 */


/**
 * \mainpage The TNL-module
 *
 * TNL stands for "transform and lighting", i.e. this module implements
 * a pipeline that receives as input a buffer of vertices and does all
 * necessary transformations (rotations, clipping, vertex shader etc.)
 * and passes then the output to the rasterizer.
 *
 * The tnl_pipeline contains the array of all stages, which should be
 * applied. Each stage is a black-box, which is described by an
 * tnl_pipeline_stage. The function ::_tnl_run_pipeline applies all the
 * stages to the vertex_buffer TNLcontext::vb, where the vertex data
 * is stored. The last stage in the pipeline is the rasterizer.
 *
 */


#ifndef _T_CONTEXT_H
#define _T_CONTEXT_H

#include "main/glheader.h"
#include "main/imports.h"
#include "main/mtypes.h"

#include "math/m_vector.h"

#include "vbo/vbo.h"

#define MAX_PIPELINE_STAGES     30

/*
 * Note: The first attributes match the VERT_ATTRIB_* definitions
 * in mtypes.h.  However, the tnl module has additional attributes
 * for materials, color indexes, edge flags, etc.
 */
/* Although it's nice to use these as bit indexes in a DWORD flag, we
 * could manage without if necessary.  Another limit currently is the
 * number of bits allocated for these numbers in places like vertex
 * program instruction formats and register layouts.
 */
/* The bit space exhaustion is a fact now, done by _TNL_ATTRIB_ATTRIBUTE* for
 * GLSL vertex shader which cannot be aliased with conventional vertex attribs.
 * Compacting _TNL_ATTRIB_MAT_* attribs would not work, they would not give
 * as many free bits (11 plus already 1 free bit) as _TNL_ATTRIB_ATTRIBUTE*
 * attribs want (16).
 */
enum {
	_TNL_ATTRIB_POS = 0,
	_TNL_ATTRIB_WEIGHT = 1,
	_TNL_ATTRIB_NORMAL = 2,
	_TNL_ATTRIB_COLOR0 = 3,
	_TNL_ATTRIB_COLOR1 = 4,
	_TNL_ATTRIB_FOG = 5,
	_TNL_ATTRIB_COLOR_INDEX = 6,
	_TNL_ATTRIB_EDGEFLAG = 7,
	_TNL_ATTRIB_TEX0 = 8,
	_TNL_ATTRIB_TEX1 = 9,
	_TNL_ATTRIB_TEX2 = 10,
	_TNL_ATTRIB_TEX3 = 11,
	_TNL_ATTRIB_TEX4 = 12,
	_TNL_ATTRIB_TEX5 = 13,
	_TNL_ATTRIB_TEX6 = 14,
	_TNL_ATTRIB_TEX7 = 15,

	_TNL_ATTRIB_GENERIC0 = 17, /* doesn't really exist! */
	_TNL_ATTRIB_GENERIC1 = 18,
	_TNL_ATTRIB_GENERIC2 = 19,
	_TNL_ATTRIB_GENERIC3 = 20,
	_TNL_ATTRIB_GENERIC4 = 21,
	_TNL_ATTRIB_GENERIC5 = 22,
	_TNL_ATTRIB_GENERIC6 = 23,
	_TNL_ATTRIB_GENERIC7 = 24,
	_TNL_ATTRIB_GENERIC8 = 25,
	_TNL_ATTRIB_GENERIC9 = 26,
	_TNL_ATTRIB_GENERIC10 = 27,
	_TNL_ATTRIB_GENERIC11 = 28,
	_TNL_ATTRIB_GENERIC12 = 29,
	_TNL_ATTRIB_GENERIC13 = 30,
	_TNL_ATTRIB_GENERIC14 = 31,
	_TNL_ATTRIB_GENERIC15 = 32,

	/* These alias with the generics, but they are not active
	 * concurrently, so it's not a problem.  The TNL module
	 * doesn't have to do anything about this as this is how they
	 * are passed into the _draw_prims callback.
	 *
	 * When we generate fixed-function replacement programs (in
	 * t_vp_build.c currently), they refer to the appropriate
	 * generic attribute in order to pick up per-vertex material
	 * data.
	 */
	_TNL_ATTRIB_MAT_FRONT_AMBIENT = 17,
	_TNL_ATTRIB_MAT_BACK_AMBIENT = 18,
	_TNL_ATTRIB_MAT_FRONT_DIFFUSE = 19,
	_TNL_ATTRIB_MAT_BACK_DIFFUSE = 20,
	_TNL_ATTRIB_MAT_FRONT_SPECULAR = 21,
	_TNL_ATTRIB_MAT_BACK_SPECULAR = 22,
	_TNL_ATTRIB_MAT_FRONT_EMISSION = 23,
	_TNL_ATTRIB_MAT_BACK_EMISSION = 24,
	_TNL_ATTRIB_MAT_FRONT_SHININESS = 25,
	_TNL_ATTRIB_MAT_BACK_SHININESS = 26,
	_TNL_ATTRIB_MAT_FRONT_INDEXES = 27,
	_TNL_ATTRIB_MAT_BACK_INDEXES = 28,

	/* This is really a VARYING_SLOT, not an attrib.  Need to fix
	 * tnl to understand the difference.
	 */
	_TNL_ATTRIB_POINTSIZE = 16,

	_TNL_ATTRIB_MAX = 33
} ;

#define _TNL_ATTRIB_TEX(u)       (_TNL_ATTRIB_TEX0 + (u))
#define _TNL_ATTRIB_GENERIC(n) (_TNL_ATTRIB_GENERIC0 + (n))

/* special index used for handing invalid glVertexAttribute() indices */
#define _TNL_ATTRIB_ERROR    (_TNL_ATTRIB_GENERIC15 + 1)

/**
 * Handy attribute ranges:
 */
#define _TNL_FIRST_PROG      _TNL_ATTRIB_WEIGHT
#define _TNL_LAST_PROG       _TNL_ATTRIB_TEX7

#define _TNL_FIRST_TEX       _TNL_ATTRIB_TEX0
#define _TNL_LAST_TEX        _TNL_ATTRIB_TEX7

#define _TNL_FIRST_GENERIC _TNL_ATTRIB_GENERIC0
#define _TNL_LAST_GENERIC  _TNL_ATTRIB_GENERIC15

#define _TNL_FIRST_MAT       _TNL_ATTRIB_MAT_FRONT_AMBIENT /* GENERIC0 */
#define _TNL_LAST_MAT        _TNL_ATTRIB_MAT_BACK_INDEXES  /* GENERIC11 */

/* Number of available texture attributes */
#define _TNL_NUM_TEX 8

/* Number of available generic attributes */
#define _TNL_NUM_GENERIC 16

/* Number of attributes used for evaluators */
#define _TNL_NUM_EVAL 16


#define PRIM_BEGIN     0x10
#define PRIM_END       0x20
#define PRIM_MODE_MASK 0x0f

static inline GLuint _tnl_translate_prim( const struct _mesa_prim *prim )
{
   GLuint flag;
   flag = prim->mode;
   if (prim->begin) flag |= PRIM_BEGIN;
   if (prim->end) flag |= PRIM_END;
   return flag;
}




/**
 * Contains the current state of a running pipeline.
 */
struct vertex_buffer
{
   GLuint Size;  /**< Max vertices per vertex buffer, constant */

   /* Constant over the pipeline.
    */
   GLuint Count;  /**< Number of vertices currently in buffer */

   /* Pointers to current data.  Most of the data is in AttribPtr -- all of
    * it that is one of VERT_ATTRIB_X.  For things only produced by TNL,
    * such as backface color or eye-space coordinates, they are stored
    * here.
    */
   GLuint      *Elts;		                
   GLvector4f  *EyePtr;		                /* _TNL_BIT_POS */
   GLvector4f  *ClipPtr;	                /* _TNL_BIT_POS */
   GLvector4f  *NdcPtr;                         /* _TNL_BIT_POS */
   GLubyte     ClipOrMask;	                /* _TNL_BIT_POS */
   GLubyte     ClipAndMask;	                /* _TNL_BIT_POS */
   GLubyte     *ClipMask;		        /* _TNL_BIT_POS */
   GLfloat     *NormalLengthPtr;	        /* _TNL_BIT_NORMAL */
   GLboolean   *EdgeFlag;	                /* _TNL_BIT_EDGEFLAG */
   GLvector4f  *BackfaceIndexPtr;
   GLvector4f  *BackfaceColorPtr;
   GLvector4f  *BackfaceSecondaryColorPtr;

   const struct _mesa_prim  *Primitive;	              
   GLuint      PrimitiveCount;	      

   /* Inputs to the vertex program stage */
   GLvector4f *AttribPtr[_TNL_ATTRIB_MAX];
};


/**
 * Describes an individual operation on the pipeline.
 */
struct tnl_pipeline_stage
{
   const char *name;

   /* Private data for the pipeline stage:
    */
   void *privatePtr;

   /* Allocate private data
    */
   GLboolean (*create)( struct gl_context *ctx, struct tnl_pipeline_stage * );

   /* Free private data.
    */
   void (*destroy)( struct tnl_pipeline_stage * );

   /* Called on any statechange or input array size change or
    * input array change to/from zero stride.
    */
   void (*validate)( struct gl_context *ctx, struct tnl_pipeline_stage * );

   /* Called from _tnl_run_pipeline().  The stage.changed_inputs value
    * encodes all inputs to thee struct which have changed.  If
    * non-zero, recompute all affected outputs of the stage, otherwise
    * execute any 'sideeffects' of the stage.
    *
    * Return value: GL_TRUE - keep going
    *               GL_FALSE - finished pipeline
    */
   GLboolean (*run)( struct gl_context *ctx, struct tnl_pipeline_stage * );
};



/** Contains the array of all pipeline stages.
 * The default values are defined at the end of t_pipeline.c 
 */
struct tnl_pipeline {
   
   GLuint last_attrib_stride[_TNL_ATTRIB_MAX];
   GLuint last_attrib_size[_TNL_ATTRIB_MAX];
   GLuint input_changes;
   GLuint new_state;

   struct tnl_pipeline_stage stages[MAX_PIPELINE_STAGES+1];
   GLuint nr_stages;
};

struct tnl_clipspace;
struct tnl_clipspace_attr;

typedef void (*tnl_extract_func)( const struct tnl_clipspace_attr *a, 
				  GLfloat *out, 
				  const GLubyte *v );

typedef void (*tnl_insert_func)( const struct tnl_clipspace_attr *a, 
				 GLubyte *v, 
				 const GLfloat *in );

typedef void (*tnl_emit_func)( struct gl_context *ctx, 
			       GLuint count, 
			       GLubyte *dest );


/**
 * Describes how to convert/move a vertex attribute from a vertex array
 * to a vertex structure.
 */
struct tnl_clipspace_attr
{
   GLuint attrib;          /* which vertex attrib (0=position, etc) */
   GLuint format;
   GLuint vertoffset;      /* position of the attrib in the vertex struct */
   GLuint vertattrsize;    /* size of the attribute in bytes */
   GLubyte *inputptr;
   GLuint inputstride;
   GLuint inputsize;
   const tnl_insert_func *insert;
   tnl_insert_func emit;
   tnl_extract_func extract;
   const GLfloat *vp;   /* NDC->Viewport mapping matrix */
};




typedef void (*tnl_points_func)( struct gl_context *ctx, GLuint first, GLuint last );
typedef void (*tnl_line_func)( struct gl_context *ctx, GLuint v1, GLuint v2 );
typedef void (*tnl_triangle_func)( struct gl_context *ctx,
				   GLuint v1, GLuint v2, GLuint v3 );
typedef void (*tnl_quad_func)( struct gl_context *ctx, GLuint v1, GLuint v2,
			       GLuint v3, GLuint v4 );
typedef void (*tnl_render_func)( struct gl_context *ctx, GLuint start, GLuint count,
				 GLuint flags );
typedef void (*tnl_interp_func)( struct gl_context *ctx,
				 GLfloat t, GLuint dst, GLuint out, GLuint in,
				 GLboolean force_boundary );
typedef void (*tnl_copy_pv_func)( struct gl_context *ctx, GLuint dst, GLuint src );
typedef void (*tnl_setup_func)( struct gl_context *ctx,
				GLuint start, GLuint end,
				GLuint new_inputs);


struct tnl_attr_type {
   GLuint format;
   GLuint size;
   GLuint stride;
   GLuint offset;
};

struct tnl_clipspace_fastpath {
   GLuint vertex_size;
   GLuint attr_count;
   GLboolean match_strides;

   struct tnl_attr_type *attr;

   tnl_emit_func func;
   struct tnl_clipspace_fastpath *next;
};

/**
 * Used to describe conversion of vertex arrays to vertex structures.
 * I.e. Structure of arrays to arrays of structs.
 */
struct tnl_clipspace
{
   GLboolean need_extras;
   
   GLuint new_inputs;

   GLubyte *vertex_buf;
   GLuint vertex_size;
   GLuint max_vertex_size;

   struct tnl_clipspace_attr attr[_TNL_ATTRIB_MAX];
   GLuint attr_count;

   tnl_emit_func emit;
   tnl_interp_func interp;
   tnl_copy_pv_func copy_pv;

   /* Parameters and constants for codegen:
    */
   GLboolean need_viewport;
   GLfloat vp_scale[4];		
   GLfloat vp_xlate[4];
   GLfloat chan_scale[4];
   GLfloat identity[4];

   struct tnl_clipspace_fastpath *fastpath;
   
   void (*codegen_emit)( struct gl_context *ctx );
};


#define SHINE_TABLE_SIZE 256	/**< Material shininess lookup table sizes */

/**
 * Material shininess lookup table.
 */
struct tnl_shine_tab
{
   struct tnl_shine_tab *next, *prev;
   GLfloat tab[SHINE_TABLE_SIZE+1];
   GLfloat shininess;
   GLuint refcount;
};


struct tnl_device_driver
{
   /***
    *** TNL Pipeline
    ***/

   void (*RunPipeline)(struct gl_context *ctx);
   /* Replaces PipelineStart/PipelineFinish -- intended to allow
    * drivers to wrap _tnl_run_pipeline() with code to validate state
    * and grab/release hardware locks.  
    */

   void (*NotifyMaterialChange)(struct gl_context *ctx);
   /* Alert tnl-aware drivers of changes to material.
    */

   /***
    *** Rendering -- These functions called only from t_vb_render.c
    ***/
   struct
   {
      void (*Start)(struct gl_context *ctx);
      void (*Finish)(struct gl_context *ctx);
      /* Called before and after all rendering operations, including DrawPixels,
       * ReadPixels, Bitmap, span functions, and CopyTexImage, etc commands.
       * These are a suitable place for grabbing/releasing hardware locks.
       */

      void (*PrimitiveNotify)(struct gl_context *ctx, GLenum mode);
      /* Called between RenderStart() and RenderFinish() to indicate the
       * type of primitive we're about to draw.  Mode will be one of the
       * modes accepted by glBegin().
       */

      tnl_interp_func Interp;
      /* The interp function is called by the clipping routines when we need
       * to generate an interpolated vertex.  All pertinant vertex ancilliary
       * data should be computed by interpolating between the 'in' and 'out'
       * vertices.
       */

      tnl_copy_pv_func CopyPV;
      /* The copy function is used to make a copy of a vertex.  All pertinant
       * vertex attributes should be copied.
       */

      void (*ClippedPolygon)( struct gl_context *ctx, const GLuint *elts, GLuint n );
      /* Render a polygon with <n> vertices whose indexes are in the <elts>
       * array.
       */

      void (*ClippedLine)( struct gl_context *ctx, GLuint v0, GLuint v1 );
      /* Render a line between the two vertices given by indexes v0 and v1. */

      tnl_points_func           Points; /* must now respect vb->elts */
      tnl_line_func             Line;
      tnl_triangle_func         Triangle;
      tnl_quad_func             Quad;
      /* These functions are called in order to render points, lines,
       * triangles and quads.  These are only called via the T&L module.
       */

      tnl_render_func          *PrimTabVerts;
      tnl_render_func          *PrimTabElts;
      /* Render whole unclipped primitives (points, lines, linestrips,
       * lineloops, etc).  The tables are indexed by the GL enum of the
       * primitive to be rendered.  RenderTabVerts is used for non-indexed
       * arrays of vertices.  RenderTabElts is used for indexed arrays of
       * vertices.
       */

      void (*ResetLineStipple)( struct gl_context *ctx );
      /* Reset the hardware's line stipple counter.
       */

      tnl_setup_func BuildVertices;
      /* This function is called whenever new vertices are required for
       * rendering.  The vertices in question are those n such that start
       * <= n < end.  The new_inputs parameter indicates those fields of
       * the vertex which need to be updated, if only a partial repair of
       * the vertex is required.
       *
       * This function is called only from _tnl_render_stage in tnl/t_render.c.
       */
      

      GLboolean (*Multipass)( struct gl_context *ctx, GLuint passno );
      /* Driver may request additional render passes by returning GL_TRUE
       * when this function is called.  This function will be called
       * after the first pass, and passes will be made until the function
       * returns GL_FALSE.  If no function is registered, only one pass
       * is made.
       *
       * This function will be first invoked with passno == 1.
       */
   } Render;
};


/**
 * Context state for T&L context.
 */
typedef struct
{
   /* Driver interface.
    */
   struct tnl_device_driver Driver;

   /* Pipeline
    */
   struct tnl_pipeline pipeline;
   struct vertex_buffer vb;

   /* Clipspace/ndc/window vertex managment:
    */
   struct tnl_clipspace clipspace;

   /* Probably need a better configuration mechanism:
    */
   GLboolean NeedNdcCoords;
   GLboolean AllowVertexFog;
   GLboolean AllowPixelFog;
   GLboolean _DoVertexFog;  /* eval fog function at each vertex? */

   GLbitfield64 render_inputs_bitset;

   GLvector4f tmp_inputs[VERT_ATTRIB_MAX];

   /* Temp storage for t_draw.c: 
    */
   GLubyte *block[VERT_ATTRIB_MAX];
   GLuint nr_blocks;

   GLuint CurInstance;

   struct tnl_shine_tab *_ShineTable[2]; /**< Active shine tables */
   struct tnl_shine_tab *_ShineTabList;  /**< MRU list of inactive shine tables */
   /**@@}*/
} TNLcontext;



#define TNL_CONTEXT(ctx) ((TNLcontext *)((ctx)->swtnl_context))


#define TYPE_IDX(t) ((t) & 0xf)
#define MAX_TYPES TYPE_IDX(GL_DOUBLE)+1      /* 0xa + 1 */


extern void
tnl_clip_prepare(struct gl_context *ctx);


#endif
@


1.7
log
@Merge Mesa 9.2.0
@
text
@@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  6.5
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d53 1
a53 1
#include "main/bitset.h"
d96 16
a111 16
	_TNL_ATTRIB_GENERIC0 = 16, /* doesn't really exist! */
	_TNL_ATTRIB_GENERIC1 = 17,
	_TNL_ATTRIB_GENERIC2 = 18,
	_TNL_ATTRIB_GENERIC3 = 19,
	_TNL_ATTRIB_GENERIC4 = 20,
	_TNL_ATTRIB_GENERIC5 = 21,
	_TNL_ATTRIB_GENERIC6 = 22,
	_TNL_ATTRIB_GENERIC7 = 23,
	_TNL_ATTRIB_GENERIC8 = 24,
	_TNL_ATTRIB_GENERIC9 = 25,
	_TNL_ATTRIB_GENERIC10 = 26,
	_TNL_ATTRIB_GENERIC11 = 27,
	_TNL_ATTRIB_GENERIC12 = 28,
	_TNL_ATTRIB_GENERIC13 = 29,
	_TNL_ATTRIB_GENERIC14 = 30,
	_TNL_ATTRIB_GENERIC15 = 31,
d123 12
a134 12
	_TNL_ATTRIB_MAT_FRONT_AMBIENT = 16,
	_TNL_ATTRIB_MAT_BACK_AMBIENT = 17,
	_TNL_ATTRIB_MAT_FRONT_DIFFUSE = 18,
	_TNL_ATTRIB_MAT_BACK_DIFFUSE = 19,
	_TNL_ATTRIB_MAT_FRONT_SPECULAR = 20,
	_TNL_ATTRIB_MAT_BACK_SPECULAR = 21,
	_TNL_ATTRIB_MAT_FRONT_EMISSION = 22,
	_TNL_ATTRIB_MAT_BACK_EMISSION = 23,
	_TNL_ATTRIB_MAT_FRONT_SHININESS = 24,
	_TNL_ATTRIB_MAT_BACK_SHININESS = 25,
	_TNL_ATTRIB_MAT_FRONT_INDEXES = 26,
	_TNL_ATTRIB_MAT_BACK_INDEXES = 27,
d136 1
a136 1
	/* This is really a VERT_RESULT, not an attrib.  Need to fix
d141 1
a141 1
	_TNL_ATTRIB_MAX = 32
d165 3
d179 1
a179 1
static INLINE GLuint _tnl_translate_prim( const struct _mesa_prim *prim )
d224 1
a224 1
   GLvector4f *AttribPtr[_TNL_ATTRIB_MAX];      /* GL_NV_vertex_program */
d387 14
a499 13
#define DECLARE_RENDERINPUTS(name) BITSET64_DECLARE(name, _TNL_ATTRIB_MAX)
#define RENDERINPUTS_COPY BITSET64_COPY
#define RENDERINPUTS_EQUAL BITSET64_EQUAL
#define RENDERINPUTS_ZERO BITSET64_ZERO
#define RENDERINPUTS_ONES BITSET64_ONES
#define RENDERINPUTS_TEST BITSET64_TEST
#define RENDERINPUTS_SET BITSET64_SET
#define RENDERINPUTS_CLEAR BITSET64_CLEAR
#define RENDERINPUTS_TEST_RANGE BITSET64_TEST_RANGE
#define RENDERINPUTS_SET_RANGE BITSET64_SET_RANGE
#define RENDERINPUTS_CLEAR_RANGE BITSET64_CLEAR_RANGE


d525 1
a525 1
   DECLARE_RENDERINPUTS(render_inputs_bitset);
d536 3
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d530 2
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a55 1
#include "math/m_matrix.h"
a56 1
#include "math/m_xform.h"
d238 1
a238 1
   GLboolean (*create)( GLcontext *ctx, struct tnl_pipeline_stage * );
d247 1
a247 1
   void (*validate)( GLcontext *ctx, struct tnl_pipeline_stage * );
d257 1
a257 1
   GLboolean (*run)( GLcontext *ctx, struct tnl_pipeline_stage * );
d287 1
a287 1
typedef void (*tnl_emit_func)( GLcontext *ctx, 
d314 3
a316 3
typedef void (*tnl_points_func)( GLcontext *ctx, GLuint first, GLuint last );
typedef void (*tnl_line_func)( GLcontext *ctx, GLuint v1, GLuint v2 );
typedef void (*tnl_triangle_func)( GLcontext *ctx,
d318 1
a318 1
typedef void (*tnl_quad_func)( GLcontext *ctx, GLuint v1, GLuint v2,
d320 1
a320 1
typedef void (*tnl_render_func)( GLcontext *ctx, GLuint start, GLuint count,
d322 1
a322 1
typedef void (*tnl_interp_func)( GLcontext *ctx,
d325 2
a326 2
typedef void (*tnl_copy_pv_func)( GLcontext *ctx, GLuint dst, GLuint src );
typedef void (*tnl_setup_func)( GLcontext *ctx,
d380 1
a380 1
   void (*codegen_emit)( GLcontext *ctx );
d390 1
a390 1
   void (*RunPipeline)(GLcontext *ctx);
d396 1
a396 1
   void (*NotifyMaterialChange)(GLcontext *ctx);
d405 2
a406 2
      void (*Start)(GLcontext *ctx);
      void (*Finish)(GLcontext *ctx);
d412 1
a412 1
      void (*PrimitiveNotify)(GLcontext *ctx, GLenum mode);
d430 1
a430 1
      void (*ClippedPolygon)( GLcontext *ctx, const GLuint *elts, GLuint n );
d435 1
a435 1
      void (*ClippedLine)( GLcontext *ctx, GLuint v0, GLuint v1 );
d455 1
a455 1
      void (*ResetLineStipple)( GLcontext *ctx );
d470 1
a470 1
      GLboolean (*Multipass)( GLcontext *ctx, GLuint passno );
d542 1
a542 1
tnl_clip_prepare(GLcontext *ctx);
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d53 1
d201 4
a204 3
   /* Pointers to current data.
    * XXX some of these fields alias AttribPtr below and should be removed
    * such as NormalPtr, TexCoordPtr, FogCoordPtr, etc.
a206 1
   GLvector4f  *ObjPtr;		                /* _TNL_BIT_POS */
a212 1
   GLvector4f  *NormalPtr;	                /* _TNL_BIT_NORMAL */
d215 3
a217 5
   GLvector4f  *TexCoordPtr[MAX_TEXTURE_COORD_UNITS]; /* VERT_TEX_0..n */
   GLvector4f  *IndexPtr[2];	                /* _TNL_BIT_INDEX */
   GLvector4f  *ColorPtr[2];	                /* _TNL_BIT_COLOR0 */
   GLvector4f  *SecondaryColorPtr[2];           /* _TNL_BIT_COLOR1 */
   GLvector4f  *FogCoordPtr;	                /* _TNL_BIT_FOG */
a401 5
   void (*NotifyInputChanges)(GLcontext *ctx, GLuint bitmask);
   /* Alert tnl-aware drivers of changes to size and stride of input
    * arrays.
    */

d541 4
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a387 13
struct tnl_cache_item {
   GLuint hash;
   void *key;
   struct gl_vertex_program *prog;
   struct tnl_cache_item *next;
};

struct tnl_cache {
   struct tnl_cache_item **items;
   GLuint size, n_items;
};


a537 4

   /* Cache of fixed-function-replacing vertex programs:
    */
   struct tnl_cache *vp_cache;
@


1.1
log
@Initial revision
@
text
@a45 23
 * The initial vertex_buffer data may either come from an ::immediate
 * structure or client vertex_arrays or display lists:
 *
 *
 * - The ::immediate structure records all the GL commands issued between
 * glBegin and glEnd.  \n
 * The structure accumulates data, until it is either full or it is
 * flushed (usually by a state change). Before starting then the pipeline,
 * the collected vertex data in ::immediate has to be pushed into
 * TNLcontext::vb.
 * This happens in ::_tnl_vb_bind_immediate. The pipeline is then run by
 * calling tnl_device_driver::RunPipeline = ::_tnl_run_pipeline, which
 * is stored in TNLcontext::Driver.   \n
 * An ::immediate does (for performance reasons) usually not finish with a
 * glEnd, and hence it also does not need to start with a glBegin.
 * This means that the last vertices of one ::immediate may need to be
 * saved for the next one.
 *
 *
 * - NOT SURE ABOUT THIS: The vertex_arrays structure is used to handle
 * glDrawArrays etc.  \n
 * Here, the data of the vertex_arrays is copied by ::_tnl_vb_bind_arrays
 * into TNLcontext::vb, so that the pipeline can be started.
d52 2
a53 2
#include "glheader.h"
#include "mtypes.h"
d59 1
d87 1
a87 1
	_TNL_ATTRIB_SEVEN = 7,
d96 2
a97 1
	_TNL_ATTRIB_GENERIC0 = 16,
d113 30
a142 15
	_TNL_ATTRIB_MAT_FRONT_AMBIENT = 32,
	_TNL_ATTRIB_MAT_BACK_AMBIENT = 33,
	_TNL_ATTRIB_MAT_FRONT_DIFFUSE = 34,
	_TNL_ATTRIB_MAT_BACK_DIFFUSE = 35,
	_TNL_ATTRIB_MAT_FRONT_SPECULAR = 36,
	_TNL_ATTRIB_MAT_BACK_SPECULAR = 37,
	_TNL_ATTRIB_MAT_FRONT_EMISSION = 38,
	_TNL_ATTRIB_MAT_BACK_EMISSION = 39,
	_TNL_ATTRIB_MAT_FRONT_SHININESS = 40,
	_TNL_ATTRIB_MAT_BACK_SHININESS = 41,
	_TNL_ATTRIB_MAT_FRONT_INDEXES = 42,
	_TNL_ATTRIB_MAT_BACK_INDEXES = 43,
	_TNL_ATTRIB_EDGEFLAG = 44,
	_TNL_ATTRIB_POINTSIZE = 45,
	_TNL_ATTRIB_MAX = 46
d163 2
a164 2
#define _TNL_FIRST_MAT       _TNL_ATTRIB_MAT_FRONT_AMBIENT
#define _TNL_LAST_MAT        _TNL_ATTRIB_MAT_BACK_INDEXES
d172 1
a174 1
#define PRIM_WEAK      0x40
d177 8
a184 34
/* 
 */
struct tnl_prim {
   GLuint mode;
   GLuint start;
   GLuint count;
};



struct tnl_eval1_map {
   struct gl_1d_map *map;
   GLuint sz;
};

struct tnl_eval2_map {
   struct gl_2d_map *map;
   GLuint sz;
};

struct tnl_eval {
   GLuint new_state;
   struct tnl_eval1_map map1[_TNL_NUM_EVAL];
   struct tnl_eval2_map map2[_TNL_NUM_EVAL];
};


#define TNL_MAX_PRIM 16
#define TNL_MAX_COPIED_VERTS 3

struct tnl_copied_vtx {
   GLfloat buffer[_TNL_ATTRIB_MAX * 4 * TNL_MAX_COPIED_VERTS];
   GLuint nr;
};
a185 1
#define VERT_BUFFER_SIZE 2048	/* 8kbytes */
a187 171
typedef void (*tnl_attrfv_func)( const GLfloat * );

struct _tnl_dynfn {
   struct _tnl_dynfn *next, *prev;
   GLuint key;
   char *code;
};

struct _tnl_dynfn_lists {
   struct _tnl_dynfn Vertex[4];
   struct _tnl_dynfn Attribute[4];
};

struct _tnl_dynfn_generators {
   struct _tnl_dynfn *(*Vertex[4])( GLcontext *ctx, int key );
   struct _tnl_dynfn *(*Attribute[4])( GLcontext *ctx, int key );
};

#define _TNL_MAX_ATTR_CODEGEN 32


/**
 * The assembly of vertices in immediate mode is separated from
 * display list compilation.  This allows a simpler immediate mode
 * treatment and a display list compiler better suited to
 * hardware-acceleration.
 */
struct tnl_vtx {
   GLfloat buffer[VERT_BUFFER_SIZE];
   GLubyte attrsz[_TNL_ATTRIB_MAX];
   GLuint vertex_size;
   struct tnl_prim prim[TNL_MAX_PRIM];
   GLuint prim_count;
   GLfloat *vbptr;		      /* cursor, points into buffer */
   GLfloat vertex[_TNL_ATTRIB_MAX*4]; /* current vertex */
   GLfloat *attrptr[_TNL_ATTRIB_MAX]; /* points into vertex */
   GLfloat *current[_TNL_ATTRIB_MAX]; /* points into ctx->Current, etc */
   GLfloat CurrentFloatEdgeFlag;
   GLuint counter, initial_counter;
   struct tnl_copied_vtx copied;

   /** Note extra space for error handler: */
   tnl_attrfv_func tabfv[_TNL_ATTRIB_ERROR+1][4];

   struct _tnl_dynfn_lists cache;
   struct _tnl_dynfn_generators gen;

   struct tnl_eval eval;
   GLboolean *edgeflag_tmp;
   GLboolean have_materials;
};




/* For display lists, this structure holds a run of vertices of the
 * same format, and a strictly well-formed set of begin/end pairs,
 * starting on the first vertex and ending at the last.  Vertex
 * copying on buffer breaks is precomputed according to these
 * primitives, though there are situations where the copying will need
 * correction at execute-time, perhaps by replaying the list as
 * immediate mode commands.
 *
 * On executing this list, the 'current' values may be updated with
 * the values of the final vertex, and often no fixup of the start of
 * the vertex list is required.
 *
 * Eval and other commands that don't fit into these vertex lists are
 * compiled using the fallback opcode mechanism provided by dlist.c.
 */
struct tnl_vertex_list {
   GLubyte attrsz[_TNL_ATTRIB_MAX];
   GLuint vertex_size;

   GLfloat *buffer;
   GLuint count;
   GLuint wrap_count;		/* number of copied vertices at start */
   GLboolean have_materials;	/* bit of a hack - quick check for materials */
   GLboolean dangling_attr_ref;	/* current attr implicitly referenced 
				   outside the list */

   GLfloat *normal_lengths;
   struct tnl_prim *prim;
   GLuint prim_count;

   struct tnl_vertex_store *vertex_store;
   struct tnl_primitive_store *prim_store;
};

/* These buffers should be a reasonable size to support upload to
 * hardware?  Maybe drivers should stitch them back together, or
 * specify a desired size?
 */
#define SAVE_BUFFER_SIZE (16*1024)
#define SAVE_PRIM_SIZE   128

/* Storage to be shared among several vertex_lists.
 */
struct tnl_vertex_store {
   GLfloat buffer[SAVE_BUFFER_SIZE];
   GLuint used;
   GLuint refcount;
};

struct tnl_primitive_store {
   struct tnl_prim buffer[SAVE_PRIM_SIZE];
   GLuint used;
   GLuint refcount;
};


struct tnl_save {
   GLubyte attrsz[_TNL_ATTRIB_MAX];
   GLuint vertex_size;

   GLfloat *buffer;
   GLuint count;
   GLuint wrap_count;
   GLuint replay_flags;

   struct tnl_prim *prim;
   GLuint prim_count, prim_max;

   struct tnl_vertex_store *vertex_store;
   struct tnl_primitive_store *prim_store;

   GLfloat *vbptr;		   /* cursor, points into buffer */
   GLfloat vertex[_TNL_ATTRIB_MAX*4];	   /* current values */
   GLfloat *attrptr[_TNL_ATTRIB_MAX];
   GLuint counter, initial_counter;
   GLboolean dangling_attr_ref;
   GLboolean have_materials;

   GLuint opcode_vertex_list;

   struct tnl_copied_vtx copied;
   
   GLfloat CurrentFloatEdgeFlag;

   GLfloat *current[_TNL_ATTRIB_MAX]; /* points into ctx->ListState */
   GLubyte *currentsz[_TNL_ATTRIB_MAX];

   void (*tabfv[_TNL_ATTRIB_MAX][4])( const GLfloat * );
};


/**
 * A collection of vertex arrays.
 */
struct tnl_vertex_arrays
{
   /* Conventional vertex attribute arrays */
   GLvector4f  Obj;
   GLvector4f  Normal;
   GLvector4f  Color;
   GLvector4f  SecondaryColor;
   GLvector4f  FogCoord;
   GLvector4f  TexCoord[MAX_TEXTURE_COORD_UNITS];
   GLvector4f  Index;

   GLubyte     *EdgeFlag;
   GLuint      *Elt;

   /* These attributes don't alias with the conventional attributes.
    * The GL_NV_vertex_program extension defines 16 extra sets of vertex
    * arrays which have precedent over the conventional arrays when enabled.
    */
   /* XXX I think the array size is wronge (47 vs. 16) */
   GLvector4f  Attribs[_TNL_ATTRIB_MAX];
};

a219 1
   GLvector4f  *VaryingPtr[MAX_VARYING_VECTORS];
d221 1
a221 1
   struct tnl_prim  *Primitive;	              
a224 1
   /* XXX This array may be too large (47 vs. 16) */
d391 1
a391 1
   void *data;
a421 6
   GLboolean (*NotifyBegin)(GLcontext *ctx, GLenum p);
   /* Allow drivers to hook in optimized begin/end engines.
    * Return value:  GL_TRUE - driver handled the begin
    *                GL_FALSE - driver didn't handle the begin
    */

a526 8
   /* Execute:
    */
   struct tnl_vtx vtx;
   
   /* Compile:
    */
   struct tnl_save save;

a531 7
   /* GLvectors for binding to vb:
    */
   struct tnl_vertex_arrays vtx_inputs;
   struct tnl_vertex_arrays save_inputs;
   struct tnl_vertex_arrays current;
   struct tnl_vertex_arrays array_inputs;

a538 3
   GLboolean LoopbackDListCassettes;
   GLboolean CalcDListNormalLengths;
   GLboolean IsolateMaterials;
a540 2
   GLboolean AllowCodegen;

d543 1
a543 5
   /* If True, it means we started a glBegin/End primtive with an invalid
    * vertex/fragment program or incomplete framebuffer.  In that case,
    * discard any buffered vertex data.
    */
   GLboolean DiscardPrimitive;
d545 1
a545 1
   DECLARE_RENDERINPUTS(render_inputs_bitset);
d547 4
a550 2
   GLvertexformat exec_vtxfmt;
   GLvertexformat save_vtxfmt;
d552 2
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a250 1
   GLubyte active_sz[_TNL_ATTRIB_MAX];
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d46 23
a81 1
#include "vbo/vbo.h"
d109 1
a109 1
	_TNL_ATTRIB_EDGEFLAG = 7,
d118 1
a118 2

	_TNL_ATTRIB_GENERIC0 = 16, /* doesn't really exist! */
d134 15
a148 30

	/* These alias with the generics, but they are not active
	 * concurrently, so it's not a problem.  The TNL module
	 * doesn't have to do anything about this as this is how they
	 * are passed into the _draw_prims callback.
	 *
	 * When we generate fixed-function replacement programs (in
	 * t_vp_build.c currently), they refer to the appropriate
	 * generic attribute in order to pick up per-vertex material
	 * data.
	 */
	_TNL_ATTRIB_MAT_FRONT_AMBIENT = 16,
	_TNL_ATTRIB_MAT_BACK_AMBIENT = 17,
	_TNL_ATTRIB_MAT_FRONT_DIFFUSE = 18,
	_TNL_ATTRIB_MAT_BACK_DIFFUSE = 19,
	_TNL_ATTRIB_MAT_FRONT_SPECULAR = 20,
	_TNL_ATTRIB_MAT_BACK_SPECULAR = 21,
	_TNL_ATTRIB_MAT_FRONT_EMISSION = 22,
	_TNL_ATTRIB_MAT_BACK_EMISSION = 23,
	_TNL_ATTRIB_MAT_FRONT_SHININESS = 24,
	_TNL_ATTRIB_MAT_BACK_SHININESS = 25,
	_TNL_ATTRIB_MAT_FRONT_INDEXES = 26,
	_TNL_ATTRIB_MAT_BACK_INDEXES = 27,

	/* This is really a VERT_RESULT, not an attrib.  Need to fix
	 * tnl to understand the difference.
	 */
	_TNL_ATTRIB_POINTSIZE = 16,

	_TNL_ATTRIB_MAX = 32
d169 2
a170 2
#define _TNL_FIRST_MAT       _TNL_ATTRIB_MAT_FRONT_AMBIENT /* GENERIC0 */
#define _TNL_LAST_MAT        _TNL_ATTRIB_MAT_BACK_INDEXES  /* GENERIC11 */
a177 1

d180 1
d183 183
a365 8
static INLINE GLuint _tnl_translate_prim( const struct _mesa_prim *prim )
{
   GLuint flag;
   flag = prim->mode;
   if (prim->begin) flag |= PRIM_BEGIN;
   if (prim->end) flag |= PRIM_END;
   return flag;
}
d368 24
d425 1
d427 1
a427 1
   const struct _mesa_prim  *Primitive;	              
d431 1
d629 6
d740 8
d753 7
d767 3
d772 2
d776 6
d784 2
a785 6
   GLvector4f tmp_inputs[VERT_ATTRIB_MAX];

   /* Temp storage for t_draw.c: 
    */
   GLubyte *block[VERT_ATTRIB_MAX];
   GLuint nr_blocks;
a786 2
   /* Cache of fixed-function-replacing vertex programs:
    */
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d52 2
a53 3
#include "main/glheader.h"
#include "main/bitset.h"
#include "main/mtypes.h"
d55 1
d57 1
d200 3
a202 4
   /* Pointers to current data.  Most of the data is in AttribPtr -- all of
    * it that is one of VERT_ATTRIB_X.  For things only produced by TNL,
    * such as backface color or eye-space coordinates, they are stored
    * here.
d205 1
d212 1
d215 5
a219 3
   GLvector4f  *BackfaceIndexPtr;
   GLvector4f  *BackfaceColorPtr;
   GLvector4f  *BackfaceSecondaryColorPtr;
d242 1
a242 1
   GLboolean (*create)( struct gl_context *ctx, struct tnl_pipeline_stage * );
d251 1
a251 1
   void (*validate)( struct gl_context *ctx, struct tnl_pipeline_stage * );
d261 1
a261 1
   GLboolean (*run)( struct gl_context *ctx, struct tnl_pipeline_stage * );
d291 1
a291 1
typedef void (*tnl_emit_func)( struct gl_context *ctx, 
d318 3
a320 3
typedef void (*tnl_points_func)( struct gl_context *ctx, GLuint first, GLuint last );
typedef void (*tnl_line_func)( struct gl_context *ctx, GLuint v1, GLuint v2 );
typedef void (*tnl_triangle_func)( struct gl_context *ctx,
d322 1
a322 1
typedef void (*tnl_quad_func)( struct gl_context *ctx, GLuint v1, GLuint v2,
d324 1
a324 1
typedef void (*tnl_render_func)( struct gl_context *ctx, GLuint start, GLuint count,
d326 1
a326 1
typedef void (*tnl_interp_func)( struct gl_context *ctx,
d329 2
a330 2
typedef void (*tnl_copy_pv_func)( struct gl_context *ctx, GLuint dst, GLuint src );
typedef void (*tnl_setup_func)( struct gl_context *ctx,
d384 14
a397 1
   void (*codegen_emit)( struct gl_context *ctx );
d407 1
a407 1
   void (*RunPipeline)(struct gl_context *ctx);
d413 1
a413 1
   void (*NotifyMaterialChange)(struct gl_context *ctx);
d417 5
d427 2
a428 2
      void (*Start)(struct gl_context *ctx);
      void (*Finish)(struct gl_context *ctx);
d434 1
a434 1
      void (*PrimitiveNotify)(struct gl_context *ctx, GLenum mode);
d452 1
a452 1
      void (*ClippedPolygon)( struct gl_context *ctx, const GLuint *elts, GLuint n );
d457 1
a457 1
      void (*ClippedLine)( struct gl_context *ctx, GLuint v0, GLuint v1 );
d477 1
a477 1
      void (*ResetLineStipple)( struct gl_context *ctx );
d492 1
a492 1
      GLboolean (*Multipass)( struct gl_context *ctx, GLuint passno );
d552 4
a564 4


extern void
tnl_clip_prepare(struct gl_context *ctx);
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d53 1
a53 1
#include "main/imports.h"
d96 16
a111 16
	_TNL_ATTRIB_GENERIC0 = 17, /* doesn't really exist! */
	_TNL_ATTRIB_GENERIC1 = 18,
	_TNL_ATTRIB_GENERIC2 = 19,
	_TNL_ATTRIB_GENERIC3 = 20,
	_TNL_ATTRIB_GENERIC4 = 21,
	_TNL_ATTRIB_GENERIC5 = 22,
	_TNL_ATTRIB_GENERIC6 = 23,
	_TNL_ATTRIB_GENERIC7 = 24,
	_TNL_ATTRIB_GENERIC8 = 25,
	_TNL_ATTRIB_GENERIC9 = 26,
	_TNL_ATTRIB_GENERIC10 = 27,
	_TNL_ATTRIB_GENERIC11 = 28,
	_TNL_ATTRIB_GENERIC12 = 29,
	_TNL_ATTRIB_GENERIC13 = 30,
	_TNL_ATTRIB_GENERIC14 = 31,
	_TNL_ATTRIB_GENERIC15 = 32,
d123 12
a134 12
	_TNL_ATTRIB_MAT_FRONT_AMBIENT = 17,
	_TNL_ATTRIB_MAT_BACK_AMBIENT = 18,
	_TNL_ATTRIB_MAT_FRONT_DIFFUSE = 19,
	_TNL_ATTRIB_MAT_BACK_DIFFUSE = 20,
	_TNL_ATTRIB_MAT_FRONT_SPECULAR = 21,
	_TNL_ATTRIB_MAT_BACK_SPECULAR = 22,
	_TNL_ATTRIB_MAT_FRONT_EMISSION = 23,
	_TNL_ATTRIB_MAT_BACK_EMISSION = 24,
	_TNL_ATTRIB_MAT_FRONT_SHININESS = 25,
	_TNL_ATTRIB_MAT_BACK_SHININESS = 26,
	_TNL_ATTRIB_MAT_FRONT_INDEXES = 27,
	_TNL_ATTRIB_MAT_BACK_INDEXES = 28,
d136 1
a136 1
	/* This is really a VARYING_SLOT, not an attrib.  Need to fix
d141 1
a141 1
	_TNL_ATTRIB_MAX = 33
a164 3
/* Number of available texture attributes */
#define _TNL_NUM_TEX 8

d176 1
a176 1
static inline GLuint _tnl_translate_prim( const struct _mesa_prim *prim )
d221 1
a221 1
   GLvector4f *AttribPtr[_TNL_ATTRIB_MAX];
a383 14
#define SHINE_TABLE_SIZE 256	/**< Material shininess lookup table sizes */

/**
 * Material shininess lookup table.
 */
struct tnl_shine_tab
{
   struct tnl_shine_tab *next, *prev;
   GLfloat tab[SHINE_TABLE_SIZE+1];
   GLfloat shininess;
   GLuint refcount;
};


d483 13
d521 1
a521 1
   GLbitfield64 render_inputs_bitset;
a529 5
   GLuint CurInstance;

   struct tnl_shine_tab *_ShineTable[2]; /**< Active shine tables */
   struct tnl_shine_tab *_ShineTabList;  /**< MRU list of inactive shine tables */
   /**@@}*/
@


