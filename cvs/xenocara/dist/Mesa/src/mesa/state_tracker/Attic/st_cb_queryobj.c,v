head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.06.44;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.22;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.10;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.13.18;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.50.24;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/


/**
 * glBegin/EndQuery interface to pipe
 *
 * \author Brian Paul
 */


#include "main/imports.h"
#include "main/context.h"

#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "pipe/p_screen.h"
#include "st_context.h"
#include "st_cb_queryobj.h"
#include "st_cb_bitmap.h"


static struct gl_query_object *
st_NewQueryObject(struct gl_context *ctx, GLuint id)
{
   struct st_query_object *stq = ST_CALLOC_STRUCT(st_query_object);
   if (stq) {
      stq->base.Id = id;
      stq->base.Ready = GL_TRUE;
      stq->pq = NULL;
      stq->type = PIPE_QUERY_TYPES; /* an invalid value */
      return &stq->base;
   }
   return NULL;
}



static void
st_DeleteQuery(struct gl_context *ctx, struct gl_query_object *q)
{
   struct pipe_context *pipe = st_context(ctx)->pipe;
   struct st_query_object *stq = st_query_object(q);

   if (stq->pq) {
      pipe->destroy_query(pipe, stq->pq);
      stq->pq = NULL;
   }

   if (stq->pq_begin) {
      pipe->destroy_query(pipe, stq->pq_begin);
      stq->pq_begin = NULL;
   }

   free(stq);
}


static void
st_BeginQuery(struct gl_context *ctx, struct gl_query_object *q)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   struct st_query_object *stq = st_query_object(q);
   unsigned type;

   st_flush_bitmap_cache(st_context(ctx));

   /* convert GL query type to Gallium query type */
   switch (q->Target) {
   case GL_ANY_SAMPLES_PASSED:
   case GL_ANY_SAMPLES_PASSED_CONSERVATIVE:
      /* fall-through */
   case GL_SAMPLES_PASSED_ARB:
      type = PIPE_QUERY_OCCLUSION_COUNTER;
      break;
   case GL_PRIMITIVES_GENERATED:
      type = PIPE_QUERY_PRIMITIVES_GENERATED;
      break;
   case GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:
      type = PIPE_QUERY_PRIMITIVES_EMITTED;
      break;
   case GL_TIME_ELAPSED:
      if (st->has_time_elapsed)
         type = PIPE_QUERY_TIME_ELAPSED;
      else
         type = PIPE_QUERY_TIMESTAMP;
      break;
   default:
      assert(0 && "unexpected query target in st_BeginQuery()");
      return;
   }

   if (stq->type != type) {
      /* free old query of different type */
      if (stq->pq) {
         pipe->destroy_query(pipe, stq->pq);
         stq->pq = NULL;
      }
      if (stq->pq_begin) {
         pipe->destroy_query(pipe, stq->pq_begin);
         stq->pq_begin = NULL;
      }
      stq->type = PIPE_QUERY_TYPES; /* an invalid value */
   }

   if (q->Target == GL_TIME_ELAPSED &&
       type == PIPE_QUERY_TIMESTAMP) {
      /* Determine time elapsed by emitting two timestamp queries. */
      if (!stq->pq_begin) {
         stq->pq_begin = pipe->create_query(pipe, type);
         stq->type = type;
      }
      pipe->end_query(pipe, stq->pq_begin);
   } else {
      if (!stq->pq) {
         stq->pq = pipe->create_query(pipe, type);
         stq->type = type;
      }
      if (stq->pq) {
         pipe->begin_query(pipe, stq->pq);
      }
      else {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBeginQuery");
         return;
      }
   }
   assert(stq->type == type);
}


static void
st_EndQuery(struct gl_context *ctx, struct gl_query_object *q)
{
   struct pipe_context *pipe = st_context(ctx)->pipe;
   struct st_query_object *stq = st_query_object(q);

   st_flush_bitmap_cache(st_context(ctx));

   if ((q->Target == GL_TIMESTAMP ||
        q->Target == GL_TIME_ELAPSED) &&
       !stq->pq) {
      stq->pq = pipe->create_query(pipe, PIPE_QUERY_TIMESTAMP);
      stq->type = PIPE_QUERY_TIMESTAMP;
   }

   if (stq->pq)
      pipe->end_query(pipe, stq->pq);
}


static boolean
get_query_result(struct pipe_context *pipe,
                 struct st_query_object *stq,
                 boolean wait)
{
   if (!stq->pq) {
      /* Only needed in case we failed to allocate the gallium query earlier.
       * Return TRUE so we don't spin on this forever.
       */
      return TRUE;
   }

   if (!pipe->get_query_result(pipe,
                               stq->pq,
                               wait,
                               (void *)&stq->base.Result)) {
      return FALSE;
   }

   if (stq->base.Target == GL_TIME_ELAPSED &&
       stq->type == PIPE_QUERY_TIMESTAMP) {
      /* Calculate the elapsed time from the two timestamp queries */
      GLuint64EXT Result0 = 0;
      assert(stq->pq_begin);
      pipe->get_query_result(pipe, stq->pq_begin, TRUE, (void *)&Result0);
      stq->base.Result -= Result0;
   } else {
      assert(!stq->pq_begin);
   }

   return TRUE;
}


static void
st_WaitQuery(struct gl_context *ctx, struct gl_query_object *q)
{
   struct pipe_context *pipe = st_context(ctx)->pipe;
   struct st_query_object *stq = st_query_object(q);

   /* this function should only be called if we don't have a ready result */
   assert(!stq->base.Ready);

   while (!stq->base.Ready &&
	  !get_query_result(pipe, stq, TRUE))
   {
      /* nothing */
   }
			    
   q->Ready = GL_TRUE;
}


static void
st_CheckQuery(struct gl_context *ctx, struct gl_query_object *q)
{
   struct pipe_context *pipe = st_context(ctx)->pipe;
   struct st_query_object *stq = st_query_object(q);
   assert(!q->Ready);   /* we should not get called if Ready is TRUE */
   q->Ready = get_query_result(pipe, stq, FALSE);
}


static uint64_t
st_GetTimestamp(struct gl_context *ctx)
{
   struct pipe_screen *screen = st_context(ctx)->pipe->screen;

   return screen->get_timestamp(screen);
}


void st_init_query_functions(struct dd_function_table *functions)
{
   functions->NewQueryObject = st_NewQueryObject;
   functions->DeleteQuery = st_DeleteQuery;
   functions->BeginQuery = st_BeginQuery;
   functions->EndQuery = st_EndQuery;
   functions->WaitQuery = st_WaitQuery;
   functions->CheckQuery = st_CheckQuery;
   functions->GetTimestamp = st_GetTimestamp;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d135 1
a135 1
         stq->pq_begin = pipe->create_query(pipe, type, 0);
d141 1
a141 1
         stq->pq = pipe->create_query(pipe, type, q->Stream);
d167 1
a167 1
      stq->pq = pipe->create_query(pipe, PIPE_QUERY_TIMESTAMP, 0);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d135 1
a135 1
         stq->pq_begin = pipe->create_query(pipe, type);
d141 1
a141 1
         stq->pq = pipe->create_query(pipe, type);
d167 1
a167 1
      stq->pq = pipe->create_query(pipe, PIPE_QUERY_TIMESTAMP);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d144 7
a150 1
      pipe->begin_query(pipe, stq->pq);
d171 2
a172 1
   pipe->end_query(pipe, stq->pq);
d181 7
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a37 1
#include "main/mfeatures.h"
d41 1
a46 2
#if FEATURE_queryobj

d74 5
d86 2
a87 1
   struct pipe_context *pipe = st_context(ctx)->pipe;
d96 1
d107 5
a111 2
   case GL_TIME_ELAPSED_EXT:
      type = PIPE_QUERY_TIME_ELAPSED;
d118 1
a118 1
   if (stq->pq && stq->type != type) {
d120 8
a127 2
      pipe->destroy_query(pipe, stq->pq);
      stq->pq = NULL;
d131 14
a144 3
   if (!stq->pq) {
      stq->pq = pipe->create_query(pipe, type);
      stq->type = type;
a145 1

a146 2

   pipe->begin_query(pipe, stq->pq);
d158 7
d169 27
d206 1
a206 4
	  !pipe->get_query_result(pipe, 
				  stq->pq,
				  TRUE,
				  &q->Result))
d221 1
a221 1
   q->Ready = pipe->get_query_result(pipe, stq->pq, FALSE, &q->Result);
d225 7
d242 1
a243 2

#endif /* FEATURE_queryobj */
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d38 1
d44 1
d87 2
d91 2
d133 2
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a37 1
#include "main/image.h"
d45 2
d48 1
a48 1
st_NewQueryObject(GLcontext *ctx, GLuint id)
d55 1
d64 1
a64 1
st_DeleteQuery(GLcontext *ctx, struct gl_query_object *q)
d66 1
a66 1
   struct pipe_context *pipe = ctx->st->pipe;
d79 1
a79 1
st_BeginQuery(GLcontext *ctx, struct gl_query_object *q)
d81 1
a81 1
   struct pipe_context *pipe = ctx->st->pipe;
d83 1
d85 1
d88 10
a97 2
      if (!stq->pq)
	 stq->pq = pipe->create_query( pipe, PIPE_QUERY_OCCLUSION_COUNTER );
d100 1
a100 1
      assert(0);
d104 14
d123 1
a123 1
st_EndQuery(GLcontext *ctx, struct gl_query_object *q)
d125 1
a125 1
   struct pipe_context *pipe = ctx->st->pipe;
d133 1
a133 1
st_WaitQuery(GLcontext *ctx, struct gl_query_object *q)
d135 1
a135 1
   struct pipe_context *pipe = ctx->st->pipe;
d155 1
a155 1
st_CheckQuery(GLcontext *ctx, struct gl_query_object *q)
d157 1
a157 1
   struct pipe_context *pipe = ctx->st->pipe;
d175 2
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d38 1
a45 2
#if FEATURE_queryobj

d47 1
a47 1
st_NewQueryObject(struct gl_context *ctx, GLuint id)
a53 1
      stq->type = PIPE_QUERY_TYPES; /* an invalid value */
d62 1
a62 1
st_DeleteQuery(struct gl_context *ctx, struct gl_query_object *q)
d64 1
a64 1
   struct pipe_context *pipe = st_context(ctx)->pipe;
d77 1
a77 1
st_BeginQuery(struct gl_context *ctx, struct gl_query_object *q)
d79 1
a79 1
   struct pipe_context *pipe = st_context(ctx)->pipe;
a80 1
   unsigned type;
a81 1
   /* convert GL query type to Gallium query type */
d84 2
a85 10
      type = PIPE_QUERY_OCCLUSION_COUNTER;
      break;
   case GL_PRIMITIVES_GENERATED:
      type = PIPE_QUERY_PRIMITIVES_GENERATED;
      break;
   case GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:
      type = PIPE_QUERY_PRIMITIVES_EMITTED;
      break;
   case GL_TIME_ELAPSED_EXT:
      type = PIPE_QUERY_TIME_ELAPSED;
d88 1
a88 1
      assert(0 && "unexpected query target in st_BeginQuery()");
a91 14
   if (stq->pq && stq->type != type) {
      /* free old query of different type */
      pipe->destroy_query(pipe, stq->pq);
      stq->pq = NULL;
      stq->type = PIPE_QUERY_TYPES; /* an invalid value */
   }

   if (!stq->pq) {
      stq->pq = pipe->create_query(pipe, type);
      stq->type = type;
   }

   assert(stq->type == type);

d97 1
a97 1
st_EndQuery(struct gl_context *ctx, struct gl_query_object *q)
d99 1
a99 1
   struct pipe_context *pipe = st_context(ctx)->pipe;
d107 1
a107 1
st_WaitQuery(struct gl_context *ctx, struct gl_query_object *q)
d109 1
a109 1
   struct pipe_context *pipe = st_context(ctx)->pipe;
d129 1
a129 1
st_CheckQuery(struct gl_context *ctx, struct gl_query_object *q)
d131 1
a131 1
   struct pipe_context *pipe = st_context(ctx)->pipe;
a148 2

#endif /* FEATURE_queryobj */
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a40 1
#include "pipe/p_screen.h"
a42 1
#include "st_cb_bitmap.h"
d45 2
a73 5
   if (stq->pq_begin) {
      pipe->destroy_query(pipe, stq->pq_begin);
      stq->pq_begin = NULL;
   }

d81 1
a81 2
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
a84 2
   st_flush_bitmap_cache(st_context(ctx));

a86 3
   case GL_ANY_SAMPLES_PASSED:
   case GL_ANY_SAMPLES_PASSED_CONSERVATIVE:
      /* fall-through */
d96 2
a97 5
   case GL_TIME_ELAPSED:
      if (st->has_time_elapsed)
         type = PIPE_QUERY_TIME_ELAPSED;
      else
         type = PIPE_QUERY_TIMESTAMP;
d104 1
a104 1
   if (stq->type != type) {
d106 2
a107 8
      if (stq->pq) {
         pipe->destroy_query(pipe, stq->pq);
         stq->pq = NULL;
      }
      if (stq->pq_begin) {
         pipe->destroy_query(pipe, stq->pq_begin);
         stq->pq_begin = NULL;
      }
d111 3
a113 14
   if (q->Target == GL_TIME_ELAPSED &&
       type == PIPE_QUERY_TIMESTAMP) {
      /* Determine time elapsed by emitting two timestamp queries. */
      if (!stq->pq_begin) {
         stq->pq_begin = pipe->create_query(pipe, type);
         stq->type = type;
      }
      pipe->end_query(pipe, stq->pq_begin);
   } else {
      if (!stq->pq) {
         stq->pq = pipe->create_query(pipe, type);
         stq->type = type;
      }
      pipe->begin_query(pipe, stq->pq);
d115 1
d117 2
a127 9
   st_flush_bitmap_cache(st_context(ctx));

   if ((q->Target == GL_TIMESTAMP ||
        q->Target == GL_TIME_ELAPSED) &&
       !stq->pq) {
      stq->pq = pipe->create_query(pipe, PIPE_QUERY_TIMESTAMP);
      stq->type = PIPE_QUERY_TIMESTAMP;
   }

a131 27
static boolean
get_query_result(struct pipe_context *pipe,
                 struct st_query_object *stq,
                 boolean wait)
{
   if (!pipe->get_query_result(pipe,
                               stq->pq,
                               wait,
                               (void *)&stq->base.Result)) {
      return FALSE;
   }

   if (stq->base.Target == GL_TIME_ELAPSED &&
       stq->type == PIPE_QUERY_TIMESTAMP) {
      /* Calculate the elapsed time from the two timestamp queries */
      GLuint64EXT Result0 = 0;
      assert(stq->pq_begin);
      pipe->get_query_result(pipe, stq->pq_begin, TRUE, (void *)&Result0);
      stq->base.Result -= Result0;
   } else {
      assert(!stq->pq_begin);
   }

   return TRUE;
}


d142 4
a145 1
	  !get_query_result(pipe, stq, TRUE))
d160 1
a160 1
   q->Ready = get_query_result(pipe, stq, FALSE);
a163 7
static uint64_t
st_GetTimestamp(struct gl_context *ctx)
{
   struct pipe_screen *screen = st_context(ctx)->pipe->screen;

   return screen->get_timestamp(screen);
}
a173 1
   functions->GetTimestamp = st_GetTimestamp;
d175 2
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d144 1
a144 7
      if (stq->pq) {
         pipe->begin_query(pipe, stq->pq);
      }
      else {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBeginQuery");
         return;
      }
d165 1
a165 2
   if (stq->pq)
      pipe->end_query(pipe, stq->pq);
a173 7
   if (!stq->pq) {
      /* Only needed in case we failed to allocate the gallium query earlier.
       * Return TRUE so we don't spin on this forever.
       */
      return TRUE;
   }

@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d135 1
a135 1
         stq->pq_begin = pipe->create_query(pipe, type, 0);
d141 1
a141 1
         stq->pq = pipe->create_query(pipe, type, q->Stream);
d167 1
a167 1
      stq->pq = pipe->create_query(pipe, PIPE_QUERY_TIMESTAMP, 0);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d135 1
a135 1
         stq->pq_begin = pipe->create_query(pipe, type);
d141 1
a141 1
         stq->pq = pipe->create_query(pipe, type);
d167 1
a167 1
      stq->pq = pipe->create_query(pipe, PIPE_QUERY_TIMESTAMP);
@


