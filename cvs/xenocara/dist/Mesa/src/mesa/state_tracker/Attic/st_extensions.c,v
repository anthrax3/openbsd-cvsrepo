head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.06.45;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.24;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.11;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.13.20;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.50.26;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * Copyright (c) 2008 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "main/imports.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/version.h"

#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "pipe/p_screen.h"
#include "util/u_math.h"

#include "st_context.h"
#include "st_extensions.h"
#include "st_format.h"


/*
 * Note: we use these function rather than the MIN2, MAX2, CLAMP macros to
 * avoid evaluating arguments (which are often function calls) more than once.
 */

static unsigned _min(unsigned a, unsigned b)
{
   return (a < b) ? a : b;
}

static float _maxf(float a, float b)
{
   return (a > b) ? a : b;
}

static int _clamp(int a, int min, int max)
{
   if (a < min)
      return min;
   else if (a > max)
      return max;
   else
      return a;
}


/**
 * Query driver to get implementation limits.
 * Note that we have to limit/clamp against Mesa's internal limits too.
 */
void st_init_limits(struct st_context *st)
{
   struct pipe_screen *screen = st->pipe->screen;
   struct gl_constants *c = &st->ctx->Const;
   unsigned sh;
   boolean can_ubo = TRUE;

   c->MaxTextureLevels
      = _min(screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS),
            MAX_TEXTURE_LEVELS);

   c->Max3DTextureLevels
      = _min(screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_3D_LEVELS),
            MAX_3D_TEXTURE_LEVELS);

   c->MaxCubeTextureLevels
      = _min(screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_CUBE_LEVELS),
            MAX_CUBE_TEXTURE_LEVELS);

   c->MaxTextureRectSize
      = _min(1 << (c->MaxTextureLevels - 1), MAX_TEXTURE_RECT_SIZE);

   c->MaxArrayTextureLayers
      = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS);

   /* Define max viewport size and max renderbuffer size in terms of
    * max texture size (note: max tex RECT size = max tex 2D size).
    * If this isn't true for some hardware we'll need new PIPE_CAP_ queries.
    */
   c->MaxViewportWidth =
   c->MaxViewportHeight =
   c->MaxRenderbufferSize = c->MaxTextureRectSize;

   c->MaxDrawBuffers = c->MaxColorAttachments =
      _clamp(screen->get_param(screen, PIPE_CAP_MAX_RENDER_TARGETS),
             1, MAX_DRAW_BUFFERS);

   c->MaxDualSourceDrawBuffers
      = _clamp(screen->get_param(screen, PIPE_CAP_MAX_DUAL_SOURCE_RENDER_TARGETS),
              0, MAX_DRAW_BUFFERS);

   c->MaxLineWidth
      = _maxf(1.0f, screen->get_paramf(screen,
                                       PIPE_CAPF_MAX_LINE_WIDTH));
   c->MaxLineWidthAA
      = _maxf(1.0f, screen->get_paramf(screen,
                                       PIPE_CAPF_MAX_LINE_WIDTH_AA));

   c->MaxPointSize
      = _maxf(1.0f, screen->get_paramf(screen,
                                       PIPE_CAPF_MAX_POINT_WIDTH));
   c->MaxPointSizeAA
      = _maxf(1.0f, screen->get_paramf(screen,
                                       PIPE_CAPF_MAX_POINT_WIDTH_AA));
   /* called after _mesa_create_context/_mesa_init_point, fix default user
    * settable max point size up
    */
   st->ctx->Point.MaxSize = MAX2(c->MaxPointSize, c->MaxPointSizeAA);
   /* these are not queryable. Note that GL basically mandates a 1.0 minimum
    * for non-aa sizes, but we can go down to 0.0 for aa points.
    */
   c->MinPointSize = 1.0f;
   c->MinPointSizeAA = 0.0f;

   c->MaxTextureMaxAnisotropy
      = _maxf(2.0f, screen->get_paramf(screen,
                                 PIPE_CAPF_MAX_TEXTURE_ANISOTROPY));

   c->MaxTextureLodBias
      = screen->get_paramf(screen, PIPE_CAPF_MAX_TEXTURE_LOD_BIAS);

   c->QuadsFollowProvokingVertexConvention = screen->get_param(
      screen, PIPE_CAP_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION);

   c->MaxUniformBlockSize =
      screen->get_shader_param(screen, PIPE_SHADER_FRAGMENT,
                               PIPE_SHADER_CAP_MAX_CONSTS) * 16;
   if (c->MaxUniformBlockSize < 16384) {
      can_ubo = FALSE;
   }

   for (sh = 0; sh < PIPE_SHADER_TYPES; ++sh) {
      struct gl_shader_compiler_options *options;
      struct gl_program_constants *pc;

      switch (sh) {
      case PIPE_SHADER_FRAGMENT:
         pc = &c->Program[MESA_SHADER_FRAGMENT];
         options = &st->ctx->ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
         break;
      case PIPE_SHADER_VERTEX:
         pc = &c->Program[MESA_SHADER_VERTEX];
         options = &st->ctx->ShaderCompilerOptions[MESA_SHADER_VERTEX];
         break;
      case PIPE_SHADER_GEOMETRY:
         pc = &c->Program[MESA_SHADER_GEOMETRY];
         options = &st->ctx->ShaderCompilerOptions[MESA_SHADER_GEOMETRY];
         break;
      default:
         /* compute shader, etc. */
         continue;
      }

      pc->MaxTextureImageUnits =
         _min(screen->get_shader_param(screen, sh,
                                       PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS),
              MAX_TEXTURE_IMAGE_UNITS);

      pc->MaxInstructions    = pc->MaxNativeInstructions    =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_INSTRUCTIONS);
      pc->MaxAluInstructions = pc->MaxNativeAluInstructions =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS);
      pc->MaxTexInstructions = pc->MaxNativeTexInstructions =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS);
      pc->MaxTexIndirections = pc->MaxNativeTexIndirections =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS);
      pc->MaxAttribs         = pc->MaxNativeAttribs         =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_INPUTS);
      pc->MaxTemps           = pc->MaxNativeTemps           =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_TEMPS);
      pc->MaxAddressRegs     = pc->MaxNativeAddressRegs     =
         _min(screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_ADDRS),
              MAX_PROGRAM_ADDRESS_REGS);
      pc->MaxParameters      = pc->MaxNativeParameters      =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_CONSTS);

      pc->MaxUniformComponents = 4 * MIN2(pc->MaxNativeParameters, MAX_UNIFORMS);

      pc->MaxUniformBlocks =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_CONST_BUFFERS);
      if (pc->MaxUniformBlocks)
         pc->MaxUniformBlocks -= 1; /* The first one is for ordinary uniforms. */
      pc->MaxUniformBlocks = _min(pc->MaxUniformBlocks, MAX_UNIFORM_BUFFERS);

      pc->MaxCombinedUniformComponents = (pc->MaxUniformComponents +
                                          c->MaxUniformBlockSize / 4 *
                                          pc->MaxUniformBlocks);

      /* Gallium doesn't really care about local vs. env parameters so use the
       * same limits.
       */
      pc->MaxLocalParams = MIN2(pc->MaxParameters, MAX_PROGRAM_LOCAL_PARAMS);
      pc->MaxEnvParams = MIN2(pc->MaxParameters, MAX_PROGRAM_ENV_PARAMS);

      options->EmitNoNoise = TRUE;

      /* TODO: make these more fine-grained if anyone needs it */
      options->MaxIfDepth = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH);
      options->EmitNoLoops = !screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH);
      options->EmitNoFunctions = !screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_SUBROUTINES);
      options->EmitNoMainReturn = !screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_SUBROUTINES);

      options->EmitNoCont = !screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_TGSI_CONT_SUPPORTED);

      options->EmitNoIndirectInput = !screen->get_shader_param(screen, sh,
                                        PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR);
      options->EmitNoIndirectOutput = !screen->get_shader_param(screen, sh,
                                        PIPE_SHADER_CAP_INDIRECT_OUTPUT_ADDR);
      options->EmitNoIndirectTemp = !screen->get_shader_param(screen, sh,
                                        PIPE_SHADER_CAP_INDIRECT_TEMP_ADDR);
      options->EmitNoIndirectUniform = !screen->get_shader_param(screen, sh,
                                        PIPE_SHADER_CAP_INDIRECT_CONST_ADDR);

      if (pc->MaxNativeInstructions &&
          (options->EmitNoIndirectUniform || pc->MaxUniformBlocks < 12)) {
         can_ubo = FALSE;
      }

      if (options->EmitNoLoops)
         options->MaxUnrollIterations = MIN2(screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_INSTRUCTIONS), 65536);
      else
         options->MaxUnrollIterations = 255; /* SM3 limit */
      options->LowerClipDistance = true;
   }

   c->MaxCombinedTextureImageUnits =
         _min(c->Program[MESA_SHADER_VERTEX].MaxTextureImageUnits +
              c->Program[MESA_SHADER_GEOMETRY].MaxTextureImageUnits +
              c->Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits,
              MAX_COMBINED_TEXTURE_IMAGE_UNITS);

   /* This depends on program constants. */
   c->MaxTextureCoordUnits
      = _min(c->Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits, MAX_TEXTURE_COORD_UNITS);

   c->MaxTextureUnits = _min(c->Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits, c->MaxTextureCoordUnits);

   c->Program[MESA_SHADER_VERTEX].MaxAttribs = MIN2(c->Program[MESA_SHADER_VERTEX].MaxAttribs, 16);

   /* PIPE_SHADER_CAP_MAX_INPUTS for the FS specifies the maximum number
    * of inputs. It's always 2 colors + N generic inputs. */
   c->MaxVarying = screen->get_shader_param(screen, PIPE_SHADER_FRAGMENT,
                                            PIPE_SHADER_CAP_MAX_INPUTS);
   c->MaxVarying = MIN2(c->MaxVarying, MAX_VARYING);
   c->Program[MESA_SHADER_FRAGMENT].MaxInputComponents = c->MaxVarying * 4;
   c->Program[MESA_SHADER_VERTEX].MaxOutputComponents = c->MaxVarying * 4;
   c->Program[MESA_SHADER_GEOMETRY].MaxInputComponents = c->MaxVarying * 4;
   c->Program[MESA_SHADER_GEOMETRY].MaxOutputComponents = c->MaxVarying * 4;
   c->MaxGeometryOutputVertices = screen->get_param(screen, PIPE_CAP_MAX_GEOMETRY_OUTPUT_VERTICES);
   c->MaxGeometryTotalOutputComponents = screen->get_param(screen, PIPE_CAP_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS);

   c->MinProgramTexelOffset = screen->get_param(screen, PIPE_CAP_MIN_TEXEL_OFFSET);
   c->MaxProgramTexelOffset = screen->get_param(screen, PIPE_CAP_MAX_TEXEL_OFFSET);

   c->MaxProgramTextureGatherComponents = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_GATHER_COMPONENTS);
   c->MinProgramTextureGatherOffset = screen->get_param(screen, PIPE_CAP_MIN_TEXTURE_GATHER_OFFSET);
   c->MaxProgramTextureGatherOffset = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_GATHER_OFFSET);

   c->MaxTransformFeedbackBuffers =
      screen->get_param(screen, PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS);
   c->MaxTransformFeedbackBuffers = MIN2(c->MaxTransformFeedbackBuffers, MAX_FEEDBACK_BUFFERS);
   c->MaxTransformFeedbackSeparateComponents =
      screen->get_param(screen, PIPE_CAP_MAX_STREAM_OUTPUT_SEPARATE_COMPONENTS);
   c->MaxTransformFeedbackInterleavedComponents =
      screen->get_param(screen, PIPE_CAP_MAX_STREAM_OUTPUT_INTERLEAVED_COMPONENTS);

   c->StripTextureBorder = GL_TRUE;

   c->GLSLSkipStrictMaxUniformLimitCheck =
      screen->get_param(screen, PIPE_CAP_TGSI_CAN_COMPACT_CONSTANTS);

   if (can_ubo) {
      st->ctx->Extensions.ARB_uniform_buffer_object = GL_TRUE;
      c->UniformBufferOffsetAlignment =
         screen->get_param(screen, PIPE_CAP_CONSTANT_BUFFER_OFFSET_ALIGNMENT);
      c->MaxCombinedUniformBlocks = c->MaxUniformBufferBindings =
         c->Program[MESA_SHADER_VERTEX].MaxUniformBlocks +
         c->Program[MESA_SHADER_GEOMETRY].MaxUniformBlocks +
         c->Program[MESA_SHADER_FRAGMENT].MaxUniformBlocks;
      assert(c->MaxCombinedUniformBlocks <= MAX_COMBINED_UNIFORM_BUFFERS);
   }
}


/**
 * Given a member \c x of struct gl_extensions, return offset of
 * \c x in bytes.
 */
#define o(x) offsetof(struct gl_extensions, x)


struct st_extension_cap_mapping {
   int extension_offset;
   int cap;
};

struct st_extension_format_mapping {
   int extension_offset[2];
   enum pipe_format format[8];

   /* If TRUE, at least one format must be supported for the extensions to be
    * advertised. If FALSE, all the formats must be supported. */
   GLboolean need_at_least_one;
};

/**
 * Enable extensions if certain pipe formats are supported by the driver.
 * What extensions will be enabled and what formats must be supported is
 * described by the array of st_extension_format_mapping.
 *
 * target and bind_flags are passed to is_format_supported.
 */
static void init_format_extensions(struct st_context *st,
                           const struct st_extension_format_mapping *mapping,
                           unsigned num_mappings,
                           enum pipe_texture_target target,
                           unsigned bind_flags)
{
   struct pipe_screen *screen = st->pipe->screen;
   GLboolean *extensions = (GLboolean *) &st->ctx->Extensions;
   unsigned i;
   int j;
   int num_formats = Elements(mapping->format);
   int num_ext = Elements(mapping->extension_offset);

   for (i = 0; i < num_mappings; i++) {
      int num_supported = 0;

      /* Examine each format in the list. */
      for (j = 0; j < num_formats && mapping[i].format[j]; j++) {
         if (screen->is_format_supported(screen, mapping[i].format[j],
                                         target, 0, bind_flags)) {
            num_supported++;
         }
      }

      if (!num_supported ||
          (!mapping[i].need_at_least_one && num_supported != j)) {
         continue;
      }

      /* Enable all extensions in the list. */
      for (j = 0; j < num_ext && mapping[i].extension_offset[j]; j++)
         extensions[mapping[i].extension_offset[j]] = GL_TRUE;
   }
}

/**
 * Use pipe_screen::get_param() to query PIPE_CAP_ values to determine
 * which GL extensions are supported.
 * Quite a few extensions are always supported because they are standard
 * features or can be built on top of other gallium features.
 * Some fine tuning may still be needed.
 */
void st_init_extensions(struct st_context *st)
{
   struct pipe_screen *screen = st->pipe->screen;
   struct gl_context *ctx = st->ctx;
   int i, glsl_feature_level;
   GLboolean *extensions = (GLboolean *) &ctx->Extensions;

   static const struct st_extension_cap_mapping cap_mapping[] = {
      { o(ARB_base_instance),                PIPE_CAP_START_INSTANCE                   },
      { o(ARB_buffer_storage),               PIPE_CAP_BUFFER_MAP_PERSISTENT_COHERENT },
      { o(ARB_depth_clamp),                  PIPE_CAP_DEPTH_CLIP_DISABLE               },
      { o(ARB_depth_texture),                PIPE_CAP_TEXTURE_SHADOW_MAP               },
      { o(ARB_draw_buffers_blend),           PIPE_CAP_INDEP_BLEND_FUNC                 },
      { o(ARB_draw_instanced),               PIPE_CAP_TGSI_INSTANCEID                  },
      { o(ARB_fragment_program_shadow),      PIPE_CAP_TEXTURE_SHADOW_MAP               },
      { o(ARB_instanced_arrays),             PIPE_CAP_VERTEX_ELEMENT_INSTANCE_DIVISOR  },
      { o(ARB_occlusion_query),              PIPE_CAP_OCCLUSION_QUERY                  },
      { o(ARB_occlusion_query2),             PIPE_CAP_OCCLUSION_QUERY                  },
      { o(ARB_point_sprite),                 PIPE_CAP_POINT_SPRITE                     },
      { o(ARB_seamless_cube_map),            PIPE_CAP_SEAMLESS_CUBE_MAP                },
      { o(ARB_shader_stencil_export),        PIPE_CAP_SHADER_STENCIL_EXPORT            },
      { o(ARB_shader_texture_lod),           PIPE_CAP_SM3                              },
      { o(ARB_shadow),                       PIPE_CAP_TEXTURE_SHADOW_MAP               },
      { o(ARB_texture_mirror_clamp_to_edge), PIPE_CAP_TEXTURE_MIRROR_CLAMP             },
      { o(ARB_texture_non_power_of_two),     PIPE_CAP_NPOT_TEXTURES                    },
      { o(ARB_timer_query),                  PIPE_CAP_QUERY_TIMESTAMP                  },
      { o(ARB_transform_feedback2),          PIPE_CAP_STREAM_OUTPUT_PAUSE_RESUME       },
      { o(ARB_transform_feedback3),          PIPE_CAP_STREAM_OUTPUT_PAUSE_RESUME       },

      { o(EXT_blend_equation_separate),      PIPE_CAP_BLEND_EQUATION_SEPARATE          },
      { o(EXT_draw_buffers2),                PIPE_CAP_INDEP_BLEND_ENABLE               },
      { o(EXT_stencil_two_side),             PIPE_CAP_TWO_SIDED_STENCIL                },
      { o(EXT_texture_array),                PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS         },
      { o(EXT_texture_filter_anisotropic),   PIPE_CAP_ANISOTROPIC_FILTER               },
      { o(EXT_texture_mirror_clamp),         PIPE_CAP_TEXTURE_MIRROR_CLAMP             },
      { o(EXT_texture_swizzle),              PIPE_CAP_TEXTURE_SWIZZLE                  },
      { o(EXT_transform_feedback),           PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS        },

      { o(AMD_seamless_cubemap_per_texture), PIPE_CAP_SEAMLESS_CUBE_MAP_PER_TEXTURE    },
      { o(ATI_separate_stencil),             PIPE_CAP_TWO_SIDED_STENCIL                },
      { o(ATI_texture_mirror_once),          PIPE_CAP_TEXTURE_MIRROR_CLAMP             },
      { o(NV_conditional_render),            PIPE_CAP_CONDITIONAL_RENDER               },
      { o(NV_texture_barrier),               PIPE_CAP_TEXTURE_BARRIER                  },
      /* GL_NV_point_sprite is not supported by gallium because we don't
       * support the GL_POINT_SPRITE_R_MODE_NV option. */

      { o(OES_standard_derivatives),         PIPE_CAP_SM3                              },
      { o(ARB_texture_cube_map_array),       PIPE_CAP_CUBE_MAP_ARRAY                   },
      { o(ARB_texture_multisample),          PIPE_CAP_TEXTURE_MULTISAMPLE              },
      { o(ARB_texture_query_lod),            PIPE_CAP_TEXTURE_QUERY_LOD                },
      { o(ARB_sample_shading),               PIPE_CAP_SAMPLE_SHADING                   },
   };

   /* Required: render target and sampler support */
   static const struct st_extension_format_mapping rendertarget_mapping[] = {
      { { o(ARB_texture_float) },
        { PIPE_FORMAT_R32G32B32A32_FLOAT,
          PIPE_FORMAT_R16G16B16A16_FLOAT } },

      { { o(ARB_texture_rgb10_a2ui) },
        { PIPE_FORMAT_R10G10B10A2_UINT,
          PIPE_FORMAT_B10G10R10A2_UINT },
         GL_TRUE }, /* at least one format must be supported */

      { { o(EXT_framebuffer_sRGB) },
        { PIPE_FORMAT_A8B8G8R8_SRGB,
          PIPE_FORMAT_B8G8R8A8_SRGB },
         GL_TRUE }, /* at least one format must be supported */

      { { o(EXT_packed_float) },
        { PIPE_FORMAT_R11G11B10_FLOAT } },

      { { o(EXT_texture_integer) },
        { PIPE_FORMAT_R32G32B32A32_UINT,
          PIPE_FORMAT_R32G32B32A32_SINT } },

      { { o(ARB_texture_rg) },
        { PIPE_FORMAT_R8_UNORM,
          PIPE_FORMAT_R8G8_UNORM } },
   };

   /* Required: depth stencil and sampler support */
   static const struct st_extension_format_mapping depthstencil_mapping[] = {
      { { o(ARB_depth_buffer_float) },
        { PIPE_FORMAT_Z32_FLOAT,
          PIPE_FORMAT_Z32_FLOAT_S8X24_UINT } },
   };

   /* Required: sampler support */
   static const struct st_extension_format_mapping texture_mapping[] = {
      { { o(ARB_texture_compression_rgtc) },
        { PIPE_FORMAT_RGTC1_UNORM,
          PIPE_FORMAT_RGTC1_SNORM,
          PIPE_FORMAT_RGTC2_UNORM,
          PIPE_FORMAT_RGTC2_SNORM } },

      { { o(EXT_texture_compression_latc) },
        { PIPE_FORMAT_LATC1_UNORM,
          PIPE_FORMAT_LATC1_SNORM,
          PIPE_FORMAT_LATC2_UNORM,
          PIPE_FORMAT_LATC2_SNORM } },

      { { o(EXT_texture_compression_s3tc),
          o(ANGLE_texture_compression_dxt) },
        { PIPE_FORMAT_DXT1_RGB,
          PIPE_FORMAT_DXT1_RGBA,
          PIPE_FORMAT_DXT3_RGBA,
          PIPE_FORMAT_DXT5_RGBA } },

      { { o(EXT_texture_shared_exponent) },
        { PIPE_FORMAT_R9G9B9E5_FLOAT } },

      { { o(EXT_texture_snorm) },
        { PIPE_FORMAT_R8G8B8A8_SNORM } },

      { { o(EXT_texture_sRGB),
          o(EXT_texture_sRGB_decode) },
        { PIPE_FORMAT_A8B8G8R8_SRGB,
          PIPE_FORMAT_B8G8R8A8_SRGB },
        GL_TRUE }, /* at least one format must be supported */

      { { o(ATI_texture_compression_3dc) },
        { PIPE_FORMAT_LATC2_UNORM } },

      { { o(MESA_ycbcr_texture) },
        { PIPE_FORMAT_UYVY,
          PIPE_FORMAT_YUYV },
        GL_TRUE }, /* at least one format must be supported */

      { { o(OES_compressed_ETC1_RGB8_texture) },
        { PIPE_FORMAT_ETC1_RGB8 } },
   };

   /* Required: vertex fetch support. */
   static const struct st_extension_format_mapping vertex_mapping[] = {
      { { o(ARB_vertex_type_2_10_10_10_rev) },
        { PIPE_FORMAT_R10G10B10A2_UNORM,
          PIPE_FORMAT_B10G10R10A2_UNORM,
          PIPE_FORMAT_R10G10B10A2_SNORM,
          PIPE_FORMAT_B10G10R10A2_SNORM,
          PIPE_FORMAT_R10G10B10A2_USCALED,
          PIPE_FORMAT_B10G10R10A2_USCALED,
          PIPE_FORMAT_R10G10B10A2_SSCALED,
          PIPE_FORMAT_B10G10R10A2_SSCALED } },
      { { o(ARB_vertex_type_10f_11f_11f_rev) },
        { PIPE_FORMAT_R11G11B10_FLOAT } },
   };

   static const struct st_extension_format_mapping tbo_rgb32[] = {
      { {o(ARB_texture_buffer_object_rgb32) },
        { PIPE_FORMAT_R32G32B32_FLOAT,
          PIPE_FORMAT_R32G32B32_UINT,
          PIPE_FORMAT_R32G32B32_SINT,
        } },
   };

   /*
    * Extensions that are supported by all Gallium drivers:
    */
   ctx->Extensions.ARB_ES2_compatibility = GL_TRUE;
   ctx->Extensions.ARB_draw_elements_base_vertex = GL_TRUE;
   ctx->Extensions.ARB_explicit_attrib_location = GL_TRUE;
   ctx->Extensions.ARB_fragment_coord_conventions = GL_TRUE;
   ctx->Extensions.ARB_fragment_program = GL_TRUE;
   ctx->Extensions.ARB_fragment_shader = GL_TRUE;
   ctx->Extensions.ARB_half_float_vertex = GL_TRUE;
   ctx->Extensions.ARB_internalformat_query = GL_TRUE;
   ctx->Extensions.ARB_map_buffer_range = GL_TRUE;
   ctx->Extensions.ARB_texture_border_clamp = GL_TRUE; /* XXX temp */
   ctx->Extensions.ARB_texture_cube_map = GL_TRUE;
   ctx->Extensions.ARB_texture_env_combine = GL_TRUE;
   ctx->Extensions.ARB_texture_env_crossbar = GL_TRUE;
   ctx->Extensions.ARB_texture_env_dot3 = GL_TRUE;
   ctx->Extensions.ARB_vertex_program = GL_TRUE;
   ctx->Extensions.ARB_vertex_shader = GL_TRUE;

   ctx->Extensions.EXT_blend_color = GL_TRUE;
   ctx->Extensions.EXT_blend_func_separate = GL_TRUE;
   ctx->Extensions.EXT_blend_minmax = GL_TRUE;
   ctx->Extensions.EXT_gpu_program_parameters = GL_TRUE;
   ctx->Extensions.EXT_pixel_buffer_object = GL_TRUE;
   ctx->Extensions.EXT_point_parameters = GL_TRUE;
   ctx->Extensions.EXT_provoking_vertex = GL_TRUE;

   ctx->Extensions.EXT_texture_env_dot3 = GL_TRUE;
   ctx->Extensions.EXT_vertex_array_bgra = GL_TRUE;

   ctx->Extensions.ATI_texture_env_combine3 = GL_TRUE;

   ctx->Extensions.MESA_pack_invert = GL_TRUE;

   ctx->Extensions.NV_fog_distance = GL_TRUE;
   ctx->Extensions.NV_texture_env_combine4 = GL_TRUE;
   ctx->Extensions.NV_texture_rectangle = GL_TRUE;
   ctx->Extensions.NV_vdpau_interop = GL_TRUE;

   ctx->Extensions.OES_EGL_image = GL_TRUE;
   ctx->Extensions.OES_EGL_image_external = GL_TRUE;
   ctx->Extensions.OES_draw_texture = GL_TRUE;

   /* Expose the extensions which directly correspond to gallium caps. */
   for (i = 0; i < Elements(cap_mapping); i++) {
      if (screen->get_param(screen, cap_mapping[i].cap)) {
         extensions[cap_mapping[i].extension_offset] = GL_TRUE;
      }
   }

   /* Expose the extensions which directly correspond to gallium formats. */
   init_format_extensions(st, rendertarget_mapping,
                          Elements(rendertarget_mapping), PIPE_TEXTURE_2D,
                          PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW);
   init_format_extensions(st, depthstencil_mapping,
                          Elements(depthstencil_mapping), PIPE_TEXTURE_2D,
                          PIPE_BIND_DEPTH_STENCIL | PIPE_BIND_SAMPLER_VIEW);
   init_format_extensions(st, texture_mapping, Elements(texture_mapping),
                          PIPE_TEXTURE_2D, PIPE_BIND_SAMPLER_VIEW);
   init_format_extensions(st, vertex_mapping, Elements(vertex_mapping),
                          PIPE_BUFFER, PIPE_BIND_VERTEX_BUFFER);

   /* Figure out GLSL support. */
   glsl_feature_level = screen->get_param(screen, PIPE_CAP_GLSL_FEATURE_LEVEL);

   ctx->Const.GLSLVersion = glsl_feature_level;
   if (glsl_feature_level >= 330)
      ctx->Const.GLSLVersion = 330;

   _mesa_override_glsl_version(st->ctx);

   if (st->options.force_glsl_version > 0 &&
       st->options.force_glsl_version <= ctx->Const.GLSLVersion) {
      ctx->Const.ForceGLSLVersion = st->options.force_glsl_version;
   }

   /* This extension needs full OpenGL 3.2, but we don't know if that's
    * supported at this point. Only check the GLSL version. */
   if (ctx->Const.GLSLVersion >= 150 &&
       screen->get_param(screen, PIPE_CAP_TGSI_VS_LAYER)) {
      ctx->Extensions.AMD_vertex_shader_layer = GL_TRUE;
   }

   if (ctx->Const.GLSLVersion >= 130) {
      ctx->Const.NativeIntegers = GL_TRUE;
      ctx->Const.MaxClipPlanes = 8;

      /* Extensions that either depend on GLSL 1.30 or are a subset thereof. */
      ctx->Extensions.ARB_conservative_depth = GL_TRUE;
      ctx->Extensions.ARB_shading_language_packing = GL_TRUE;
      ctx->Extensions.OES_depth_texture_cube_map = GL_TRUE;
      ctx->Extensions.ARB_shading_language_420pack = GL_TRUE;

      if (!st->options.disable_shader_bit_encoding) {
         ctx->Extensions.ARB_shader_bit_encoding = GL_TRUE;
      }

      ctx->Extensions.EXT_shader_integer_mix = GL_TRUE;
   } else {
      /* Optional integer support for GLSL 1.2. */
      if (screen->get_shader_param(screen, PIPE_SHADER_VERTEX,
                                   PIPE_SHADER_CAP_INTEGERS) &&
          screen->get_shader_param(screen, PIPE_SHADER_FRAGMENT,
                                   PIPE_SHADER_CAP_INTEGERS)) {
         ctx->Const.NativeIntegers = GL_TRUE;

         ctx->Extensions.EXT_shader_integer_mix = GL_TRUE;
      }
   }

   ctx->Const.UniformBooleanTrue = ctx->Const.NativeIntegers ? ~0 : fui(1.0f);

   /* Below are the cases which cannot be moved into tables easily. */

   if (!ctx->Mesa_DXTn && !st->options.force_s3tc_enable) {
      ctx->Extensions.EXT_texture_compression_s3tc = GL_FALSE;
      ctx->Extensions.ANGLE_texture_compression_dxt = GL_FALSE;
   }

   if (screen->get_shader_param(screen, PIPE_SHADER_GEOMETRY,
                                PIPE_SHADER_CAP_MAX_INSTRUCTIONS) > 0) {
#if 0 /* XXX re-enable when GLSL compiler again supports geometry shaders */
      ctx->Extensions.ARB_geometry_shader4 = GL_TRUE;
#endif
   }

   ctx->Extensions.NV_primitive_restart = GL_TRUE;
   if (!screen->get_param(screen, PIPE_CAP_PRIMITIVE_RESTART)) {
      ctx->Const.PrimitiveRestartInSoftware = GL_TRUE;
   }

   /* ARB_color_buffer_float. */
   if (screen->get_param(screen, PIPE_CAP_VERTEX_COLOR_UNCLAMPED)) {
      ctx->Extensions.ARB_color_buffer_float = GL_TRUE;

      if (!screen->get_param(screen, PIPE_CAP_VERTEX_COLOR_CLAMPED)) {
         st->clamp_vert_color_in_shader = TRUE;
      }

      if (!screen->get_param(screen, PIPE_CAP_FRAGMENT_COLOR_CLAMPED)) {
         st->clamp_frag_color_in_shader = TRUE;
      }

      /* For drivers which cannot do color clamping, it's better to just
       * disable ARB_color_buffer_float in the core profile, because
       * the clamping is deprecated there anyway. */
      if (ctx->API == API_OPENGL_CORE &&
          (st->clamp_frag_color_in_shader || st->clamp_vert_color_in_shader)) {
         st->clamp_vert_color_in_shader = GL_FALSE;
         st->clamp_frag_color_in_shader = GL_FALSE;
         ctx->Extensions.ARB_color_buffer_float = GL_FALSE;
      }
   }

   if (screen->fence_finish) {
      ctx->Extensions.ARB_sync = GL_TRUE;
   }

   /* Maximum sample count. */
   for (i = 16; i > 0; --i) {
      enum pipe_format pformat = st_choose_format(st, GL_RGBA,
                                                  GL_NONE, GL_NONE,
                                                  PIPE_TEXTURE_2D, i,
                                                  PIPE_BIND_RENDER_TARGET, FALSE);
      if (pformat != PIPE_FORMAT_NONE) {
         ctx->Const.MaxSamples = i;
         ctx->Const.MaxColorTextureSamples = i;
         break;
      }
   }
   for (i = ctx->Const.MaxSamples; i > 0; --i) {
      enum pipe_format pformat = st_choose_format(st, GL_DEPTH_STENCIL,
                                                  GL_NONE, GL_NONE,
                                                  PIPE_TEXTURE_2D, i,
                                                  PIPE_BIND_DEPTH_STENCIL, FALSE);
      if (pformat != PIPE_FORMAT_NONE) {
         ctx->Const.MaxDepthTextureSamples = i;
         break;
      }
   }
   for (i = ctx->Const.MaxSamples; i > 0; --i) {
      enum pipe_format pformat = st_choose_format(st, GL_RGBA_INTEGER,
                                                  GL_NONE, GL_NONE,
                                                  PIPE_TEXTURE_2D, i,
                                                  PIPE_BIND_RENDER_TARGET, FALSE);
      if (pformat != PIPE_FORMAT_NONE) {
         ctx->Const.MaxIntegerSamples = i;
         break;
      }
   }
   if (ctx->Const.MaxSamples == 1) {
      /* one sample doesn't really make sense */
      ctx->Const.MaxSamples = 0;
   }
   else if (ctx->Const.MaxSamples >= 2) {
      ctx->Extensions.EXT_framebuffer_multisample = GL_TRUE;
      ctx->Extensions.EXT_framebuffer_multisample_blit_scaled = GL_TRUE;
   }

   if (ctx->Const.MaxSamples == 0 && screen->get_param(screen, PIPE_CAP_FAKE_SW_MSAA)) {
	ctx->Const.FakeSWMSAA = GL_TRUE;
        ctx->Extensions.EXT_framebuffer_multisample = GL_TRUE;
        ctx->Extensions.EXT_framebuffer_multisample_blit_scaled = GL_TRUE;
        ctx->Extensions.ARB_texture_multisample = GL_TRUE;
   }

   if (ctx->Const.MaxDualSourceDrawBuffers > 0 &&
       !st->options.disable_blend_func_extended)
      ctx->Extensions.ARB_blend_func_extended = GL_TRUE;

   st->has_time_elapsed =
      screen->get_param(screen, PIPE_CAP_QUERY_TIME_ELAPSED);

   if (st->has_time_elapsed ||
       ctx->Extensions.ARB_timer_query) {
      ctx->Extensions.EXT_timer_query = GL_TRUE;
   }

   if (ctx->Extensions.ARB_transform_feedback2 &&
       ctx->Extensions.ARB_draw_instanced) {
      ctx->Extensions.ARB_transform_feedback_instanced = GL_TRUE;
   }
   if (st->options.force_glsl_extensions_warn)
      ctx->Const.ForceGLSLExtensionsWarn = 1;

   if (st->options.disable_glsl_line_continuations)
      ctx->Const.DisableGLSLLineContinuations = 1;

   ctx->Const.MinMapBufferAlignment =
      screen->get_param(screen, PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT);

   if (screen->get_param(screen, PIPE_CAP_TEXTURE_BUFFER_OBJECTS)) {
      ctx->Extensions.ARB_texture_buffer_object = GL_TRUE;

      ctx->Const.MaxTextureBufferSize =
         _min(screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_BUFFER_SIZE),
              (1u << 31) - 1);
      ctx->Const.TextureBufferOffsetAlignment =
         screen->get_param(screen, PIPE_CAP_TEXTURE_BUFFER_OFFSET_ALIGNMENT);

      if (ctx->Const.TextureBufferOffsetAlignment)
         ctx->Extensions.ARB_texture_buffer_range = GL_TRUE;

      init_format_extensions(st, tbo_rgb32, Elements(tbo_rgb32),
                             PIPE_BUFFER, PIPE_BIND_SAMPLER_VIEW);
   }

   if (screen->get_param(screen, PIPE_CAP_MIXED_FRAMEBUFFER_SIZES)) {
      ctx->Extensions.ARB_framebuffer_object = GL_TRUE;
   }

   /* Unpacking a varying in the fragment shader costs 1 texture indirection.
    * If the number of available texture indirections is very limited, then we
    * prefer to disable varying packing rather than run the risk of varying
    * packing preventing a shader from running.
    */
   if (screen->get_shader_param(screen, PIPE_SHADER_FRAGMENT,
                                PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS) <= 8) {
      /* We can't disable varying packing if transform feedback is available,
       * because transform feedback code assumes a packed varying layout.
       */
      if (!ctx->Extensions.EXT_transform_feedback)
         ctx->Const.DisableVaryingPacking = GL_TRUE;
   }

   if (ctx->API == API_OPENGL_CORE) {
      ctx->Const.MaxViewports = screen->get_param(screen, PIPE_CAP_MAX_VIEWPORTS);
      if (ctx->Const.MaxViewports >= 16) {
         ctx->Const.ViewportBounds.Min = -16384.0;
         ctx->Const.ViewportBounds.Max = 16384.0;
         ctx->Extensions.ARB_viewport_array = GL_TRUE;
      }
   }
   if (ctx->Const.MaxProgramTextureGatherComponents > 0)
      ctx->Extensions.ARB_texture_gather = GL_TRUE;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d74 1
a74 2
void st_init_limits(struct pipe_screen *screen,
                    struct gl_constants *c, struct gl_extensions *extensions)
d76 2
d128 4
a131 1

d150 1
a150 1
                               PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE);
d162 1
a162 1
         options = &c->ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
d166 1
a166 1
         options = &c->ShaderCompilerOptions[MESA_SHADER_VERTEX];
d170 1
a170 1
         options = &c->ShaderCompilerOptions[MESA_SHADER_GEOMETRY];
d195 2
a196 1
         sh == PIPE_SHADER_VERTEX ? 1 : 0;
d198 1
a198 6
         screen->get_shader_param(screen, sh,
                   PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE) / sizeof(float[4]);
      pc->MaxInputComponents =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_INPUTS) * 4;
      pc->MaxOutputComponents =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_OUTPUTS) * 4;
d244 2
a245 1

d268 4
a288 8
   c->MaxVertexStreams =
      MAX2(1, screen->get_param(screen, PIPE_CAP_MAX_VERTEX_STREAMS));

   /* The vertex stream must fit into pipe_stream_output_info::stream */
   assert(c->MaxVertexStreams <= 4);

   c->MaxVertexAttribStride
      = screen->get_param(screen, PIPE_CAP_MAX_VERTEX_ATTRIB_STRIDE);
d296 1
a296 1
      extensions->ARB_uniform_buffer_object = GL_TRUE;
d336 5
a340 7
static void
init_format_extensions(struct pipe_screen *screen,
                       struct gl_extensions *extensions,
                       const struct st_extension_format_mapping *mapping,
                       unsigned num_mappings,
                       enum pipe_texture_target target,
                       unsigned bind_flags)
d342 2
a343 1
   GLboolean *extension_table = (GLboolean *) extensions;
d367 1
a367 25
         extension_table[mapping[i].extension_offset[j]] = GL_TRUE;
   }
}


/**
 * Given a list of formats and bind flags, return the maximum number
 * of samples supported by any of those formats.
 */
static unsigned
get_max_samples_for_formats(struct pipe_screen *screen,
                            unsigned num_formats,
                            enum pipe_format *formats,
                            unsigned max_samples,
                            unsigned bind)
{
   unsigned i, f;

   for (i = max_samples; i > 0; --i) {
      for (f = 0; f < num_formats; f++) {
         if (screen->is_format_supported(screen, formats[f],
                                         PIPE_TEXTURE_2D, i, bind)) {
            return i;
         }
      }
a368 1
   return 0;
a370 1

d378 1
a378 5
void st_init_extensions(struct pipe_screen *screen,
                        struct gl_constants *consts,
                        struct gl_extensions *extensions,
                        struct st_config_options *options,
                        boolean has_lib_dxtc)
d380 2
d383 1
a383 1
   GLboolean *extension_table = (GLboolean *) extensions;
a428 5
      { o(ARB_draw_indirect),                PIPE_CAP_DRAW_INDIRECT                    },
      { o(ARB_derivative_control),           PIPE_CAP_TGSI_FS_FINE_DERIVATIVE          },
      { o(ARB_conditional_render_inverted),  PIPE_CAP_CONDITIONAL_RENDER_INVERTED      },
      { o(ARB_texture_view),                 PIPE_CAP_SAMPLER_VIEW_TARGET              },
      { o(ARB_clip_control),                 PIPE_CAP_CLIP_HALFZ                       },
a486 6
      { { o(ARB_texture_compression_bptc) },
        { PIPE_FORMAT_BPTC_RGBA_UNORM,
          PIPE_FORMAT_BPTC_SRGBA,
          PIPE_FORMAT_BPTC_RGB_FLOAT,
          PIPE_FORMAT_BPTC_RGB_UFLOAT } },

d508 1
a508 8
        { PIPE_FORMAT_ETC1_RGB8,
          PIPE_FORMAT_R8G8B8A8_UNORM },
        GL_TRUE }, /* at least one format must be supported */

      { { o(ARB_stencil_texturing) },
        { PIPE_FORMAT_X24S8_UINT,
          PIPE_FORMAT_S8X24_UINT },
        GL_TRUE }, /* at least one format must be supported */
d537 40
a576 40
   extensions->ARB_ES2_compatibility = GL_TRUE;
   extensions->ARB_draw_elements_base_vertex = GL_TRUE;
   extensions->ARB_explicit_attrib_location = GL_TRUE;
   extensions->ARB_explicit_uniform_location = GL_TRUE;
   extensions->ARB_fragment_coord_conventions = GL_TRUE;
   extensions->ARB_fragment_program = GL_TRUE;
   extensions->ARB_fragment_shader = GL_TRUE;
   extensions->ARB_half_float_vertex = GL_TRUE;
   extensions->ARB_internalformat_query = GL_TRUE;
   extensions->ARB_map_buffer_range = GL_TRUE;
   extensions->ARB_texture_border_clamp = GL_TRUE; /* XXX temp */
   extensions->ARB_texture_cube_map = GL_TRUE;
   extensions->ARB_texture_env_combine = GL_TRUE;
   extensions->ARB_texture_env_crossbar = GL_TRUE;
   extensions->ARB_texture_env_dot3 = GL_TRUE;
   extensions->ARB_vertex_program = GL_TRUE;
   extensions->ARB_vertex_shader = GL_TRUE;

   extensions->EXT_blend_color = GL_TRUE;
   extensions->EXT_blend_func_separate = GL_TRUE;
   extensions->EXT_blend_minmax = GL_TRUE;
   extensions->EXT_gpu_program_parameters = GL_TRUE;
   extensions->EXT_pixel_buffer_object = GL_TRUE;
   extensions->EXT_point_parameters = GL_TRUE;
   extensions->EXT_provoking_vertex = GL_TRUE;

   extensions->EXT_texture_env_dot3 = GL_TRUE;
   extensions->EXT_vertex_array_bgra = GL_TRUE;

   extensions->ATI_texture_env_combine3 = GL_TRUE;

   extensions->MESA_pack_invert = GL_TRUE;

   extensions->NV_fog_distance = GL_TRUE;
   extensions->NV_texture_env_combine4 = GL_TRUE;
   extensions->NV_texture_rectangle = GL_TRUE;

   extensions->OES_EGL_image = GL_TRUE;
   extensions->OES_EGL_image_external = GL_TRUE;
   extensions->OES_draw_texture = GL_TRUE;
d581 1
a581 1
         extension_table[cap_mapping[i].extension_offset] = GL_TRUE;
d586 1
a586 1
   init_format_extensions(screen, extensions, rendertarget_mapping,
d589 1
a589 1
   init_format_extensions(screen, extensions, depthstencil_mapping,
d592 4
a595 6
   init_format_extensions(screen, extensions, texture_mapping,
                          Elements(texture_mapping), PIPE_TEXTURE_2D,
                          PIPE_BIND_SAMPLER_VIEW);
   init_format_extensions(screen, extensions, vertex_mapping,
                          Elements(vertex_mapping), PIPE_BUFFER,
                          PIPE_BIND_VERTEX_BUFFER);
d600 1
a600 1
   consts->GLSLVersion = glsl_feature_level;
d602 1
a602 1
      consts->GLSLVersion = 330;
d604 1
a604 1
   _mesa_override_glsl_version(consts);
d606 3
a608 3
   if (options->force_glsl_version > 0 &&
       options->force_glsl_version <= consts->GLSLVersion) {
      consts->ForceGLSLVersion = options->force_glsl_version;
a610 3
   if (glsl_feature_level >= 400)
      extensions->ARB_gpu_shader5 = GL_TRUE;

d613 3
a615 3
   if (consts->GLSLVersion >= 150 &&
       screen->get_param(screen, PIPE_CAP_TGSI_VS_LAYER_VIEWPORT)) {
      extensions->AMD_vertex_shader_layer = GL_TRUE;
d618 3
a620 3
   if (consts->GLSLVersion >= 130) {
      consts->NativeIntegers = GL_TRUE;
      consts->MaxClipPlanes = 8;
d623 4
a626 5
      extensions->ARB_conservative_depth = GL_TRUE;
      extensions->ARB_shading_language_packing = GL_TRUE;
      extensions->OES_depth_texture_cube_map = GL_TRUE;
      extensions->ARB_shading_language_420pack = GL_TRUE;
      extensions->ARB_texture_query_levels = GL_TRUE;
d628 2
a629 2
      if (!options->disable_shader_bit_encoding) {
         extensions->ARB_shader_bit_encoding = GL_TRUE;
d632 1
a632 1
      extensions->EXT_shader_integer_mix = GL_TRUE;
d639 1
a639 1
         consts->NativeIntegers = GL_TRUE;
d641 1
a641 1
         extensions->EXT_shader_integer_mix = GL_TRUE;
d645 1
a645 1
   consts->UniformBooleanTrue = consts->NativeIntegers ? ~0 : fui(1.0f);
d649 3
a651 3
   if (!has_lib_dxtc && !options->force_s3tc_enable) {
      extensions->EXT_texture_compression_s3tc = GL_FALSE;
      extensions->ANGLE_texture_compression_dxt = GL_FALSE;
d657 1
a657 1
      extensions->ARB_geometry_shader4 = GL_TRUE;
d661 3
a663 2
   if (screen->get_param(screen, PIPE_CAP_PRIMITIVE_RESTART)) {
      extensions->NV_primitive_restart = GL_TRUE;
d668 19
a686 1
      extensions->ARB_color_buffer_float = GL_TRUE;
d690 1
a690 1
      extensions->ARB_sync = GL_TRUE;
d694 10
a703 37
   {
      enum pipe_format color_formats[] = {
         PIPE_FORMAT_R8G8B8A8_UNORM,
         PIPE_FORMAT_B8G8R8A8_UNORM,
         PIPE_FORMAT_A8R8G8B8_UNORM,
         PIPE_FORMAT_A8B8G8R8_UNORM,
      };
      enum pipe_format depth_formats[] = {
         PIPE_FORMAT_Z16_UNORM,
         PIPE_FORMAT_Z24X8_UNORM,
         PIPE_FORMAT_X8Z24_UNORM,
         PIPE_FORMAT_Z32_UNORM,
         PIPE_FORMAT_Z32_FLOAT
      };
      enum pipe_format int_formats[] = {
         PIPE_FORMAT_R8G8B8A8_SINT
      };

      consts->MaxSamples =
         get_max_samples_for_formats(screen, Elements(color_formats),
                                     color_formats, 16,
                                     PIPE_BIND_RENDER_TARGET);

      consts->MaxColorTextureSamples =
         get_max_samples_for_formats(screen, Elements(color_formats),
                                     color_formats, consts->MaxSamples,
                                     PIPE_BIND_SAMPLER_VIEW);

      consts->MaxDepthTextureSamples =
         get_max_samples_for_formats(screen, Elements(depth_formats),
                                     depth_formats, consts->MaxSamples,
                                     PIPE_BIND_SAMPLER_VIEW);

      consts->MaxIntegerSamples =
         get_max_samples_for_formats(screen, Elements(int_formats),
                                     int_formats, consts->MaxSamples,
                                     PIPE_BIND_SAMPLER_VIEW);
d705 21
a725 1
   if (consts->MaxSamples == 1) {
d727 1
a727 1
      consts->MaxSamples = 0;
d729 3
a731 3
   else if (consts->MaxSamples >= 2) {
      extensions->EXT_framebuffer_multisample = GL_TRUE;
      extensions->EXT_framebuffer_multisample_blit_scaled = GL_TRUE;
d734 5
a738 5
   if (consts->MaxSamples == 0 && screen->get_param(screen, PIPE_CAP_FAKE_SW_MSAA)) {
	consts->FakeSWMSAA = GL_TRUE;
        extensions->EXT_framebuffer_multisample = GL_TRUE;
        extensions->EXT_framebuffer_multisample_blit_scaled = GL_TRUE;
        extensions->ARB_texture_multisample = GL_TRUE;
d741 3
a743 3
   if (consts->MaxDualSourceDrawBuffers > 0 &&
       !options->disable_blend_func_extended)
      extensions->ARB_blend_func_extended = GL_TRUE;
d745 6
a750 3
   if (screen->get_param(screen, PIPE_CAP_QUERY_TIME_ELAPSED) ||
       extensions->ARB_timer_query) {
      extensions->EXT_timer_query = GL_TRUE;
d753 3
a755 3
   if (extensions->ARB_transform_feedback2 &&
       extensions->ARB_draw_instanced) {
      extensions->ARB_transform_feedback_instanced = GL_TRUE;
d757 2
a758 5
   if (options->force_glsl_extensions_warn)
      consts->ForceGLSLExtensionsWarn = 1;

   if (options->disable_glsl_line_continuations)
      consts->DisableGLSLLineContinuations = 1;
d760 2
a761 2
   if (options->allow_glsl_extension_directive_midshader)
      consts->AllowGLSLExtensionDirectiveMidShader = GL_TRUE;
d763 1
a763 1
   consts->MinMapBufferAlignment =
d767 1
a767 1
      extensions->ARB_texture_buffer_object = GL_TRUE;
d769 1
a769 1
      consts->MaxTextureBufferSize =
d772 1
a772 1
      consts->TextureBufferOffsetAlignment =
d775 2
a776 2
      if (consts->TextureBufferOffsetAlignment)
         extensions->ARB_texture_buffer_range = GL_TRUE;
d778 2
a779 3
      init_format_extensions(screen, extensions, tbo_rgb32,
                             Elements(tbo_rgb32), PIPE_BUFFER,
                             PIPE_BIND_SAMPLER_VIEW);
d783 1
a783 1
      extensions->ARB_framebuffer_object = GL_TRUE;
d796 2
a797 2
      if (!extensions->EXT_transform_feedback)
         consts->DisableVaryingPacking = GL_TRUE;
d800 7
a806 46
   consts->MaxViewports = screen->get_param(screen, PIPE_CAP_MAX_VIEWPORTS);
   if (consts->MaxViewports >= 16) {
      consts->ViewportBounds.Min = -16384.0;
      consts->ViewportBounds.Max = 16384.0;
      extensions->ARB_viewport_array = GL_TRUE;
      extensions->ARB_fragment_layer_viewport = GL_TRUE;
      if (extensions->AMD_vertex_shader_layer)
         extensions->AMD_vertex_shader_viewport_index = GL_TRUE;
   }

   if (consts->MaxProgramTextureGatherComponents > 0)
      extensions->ARB_texture_gather = GL_TRUE;

   /* GL_ARB_ES3_compatibility.
    *
    * Assume that ES3 is supported if GLSL 3.30 is supported.
    * (OpenGL 3.3 is a requirement for that extension.)
    */
   if (consts->GLSLVersion >= 330 &&
       /* Requirements for ETC2 emulation. */
       screen->is_format_supported(screen, PIPE_FORMAT_R8G8B8A8_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_B8G8R8A8_SRGB,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_R16_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_R16G16_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_R16_SNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_R16G16_SNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW)) {
      extensions->ARB_ES3_compatibility = GL_TRUE;
   }

   if (screen->get_video_param &&
       screen->get_video_param(screen, PIPE_VIDEO_PROFILE_UNKNOWN,
                               PIPE_VIDEO_ENTRYPOINT_BITSTREAM,
                               PIPE_VIDEO_CAP_SUPPORTS_INTERLACED)) {
      extensions->NV_vdpau_interop = GL_TRUE;
d808 2
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d37 1
d74 2
a75 1
void st_init_limits(struct st_context *st)
a76 2
   struct pipe_screen *screen = st->pipe->screen;
   struct gl_constants *c = &st->ctx->Const;
d127 1
a127 4
   /* called after _mesa_create_context/_mesa_init_point, fix default user
    * settable max point size up
    */
   st->ctx->Point.MaxSize = MAX2(c->MaxPointSize, c->MaxPointSizeAA);
d146 1
a146 1
                               PIPE_SHADER_CAP_MAX_CONSTS) * 16;
d158 1
a158 1
         options = &st->ctx->ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
d162 1
a162 1
         options = &st->ctx->ShaderCompilerOptions[MESA_SHADER_VERTEX];
d166 1
a166 1
         options = &st->ctx->ShaderCompilerOptions[MESA_SHADER_GEOMETRY];
d191 1
a191 2
         _min(screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_ADDRS),
              MAX_PROGRAM_ADDRESS_REGS);
d193 6
a198 1
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_CONSTS);
d244 1
a244 2
      else
         options->MaxUnrollIterations = 255; /* SM3 limit */
a266 4
   c->Program[MESA_SHADER_FRAGMENT].MaxInputComponents = c->MaxVarying * 4;
   c->Program[MESA_SHADER_VERTEX].MaxOutputComponents = c->MaxVarying * 4;
   c->Program[MESA_SHADER_GEOMETRY].MaxInputComponents = c->MaxVarying * 4;
   c->Program[MESA_SHADER_GEOMETRY].MaxOutputComponents = c->MaxVarying * 4;
a276 2
   c->UniformBooleanTrue = ~0;

d284 8
d299 1
a299 1
      st->ctx->Extensions.ARB_uniform_buffer_object = GL_TRUE;
d339 7
a345 5
static void init_format_extensions(struct st_context *st,
                           const struct st_extension_format_mapping *mapping,
                           unsigned num_mappings,
                           enum pipe_texture_target target,
                           unsigned bind_flags)
d347 1
a347 2
   struct pipe_screen *screen = st->pipe->screen;
   GLboolean *extensions = (GLboolean *) &st->ctx->Extensions;
d371 1
a371 1
         extensions[mapping[i].extension_offset[j]] = GL_TRUE;
d375 26
d408 5
a412 1
void st_init_extensions(struct st_context *st)
a413 2
   struct pipe_screen *screen = st->pipe->screen;
   struct gl_context *ctx = st->ctx;
d415 1
a415 1
   GLboolean *extensions = (GLboolean *) &ctx->Extensions;
d461 5
d524 6
d551 8
a558 1
        { PIPE_FORMAT_ETC1_RGB8 } },
d587 40
a626 40
   ctx->Extensions.ARB_ES2_compatibility = GL_TRUE;
   ctx->Extensions.ARB_draw_elements_base_vertex = GL_TRUE;
   ctx->Extensions.ARB_explicit_attrib_location = GL_TRUE;
   ctx->Extensions.ARB_fragment_coord_conventions = GL_TRUE;
   ctx->Extensions.ARB_fragment_program = GL_TRUE;
   ctx->Extensions.ARB_fragment_shader = GL_TRUE;
   ctx->Extensions.ARB_half_float_vertex = GL_TRUE;
   ctx->Extensions.ARB_internalformat_query = GL_TRUE;
   ctx->Extensions.ARB_map_buffer_range = GL_TRUE;
   ctx->Extensions.ARB_texture_border_clamp = GL_TRUE; /* XXX temp */
   ctx->Extensions.ARB_texture_cube_map = GL_TRUE;
   ctx->Extensions.ARB_texture_env_combine = GL_TRUE;
   ctx->Extensions.ARB_texture_env_crossbar = GL_TRUE;
   ctx->Extensions.ARB_texture_env_dot3 = GL_TRUE;
   ctx->Extensions.ARB_vertex_program = GL_TRUE;
   ctx->Extensions.ARB_vertex_shader = GL_TRUE;

   ctx->Extensions.EXT_blend_color = GL_TRUE;
   ctx->Extensions.EXT_blend_func_separate = GL_TRUE;
   ctx->Extensions.EXT_blend_minmax = GL_TRUE;
   ctx->Extensions.EXT_gpu_program_parameters = GL_TRUE;
   ctx->Extensions.EXT_pixel_buffer_object = GL_TRUE;
   ctx->Extensions.EXT_point_parameters = GL_TRUE;
   ctx->Extensions.EXT_provoking_vertex = GL_TRUE;

   ctx->Extensions.EXT_texture_env_dot3 = GL_TRUE;
   ctx->Extensions.EXT_vertex_array_bgra = GL_TRUE;

   ctx->Extensions.ATI_texture_env_combine3 = GL_TRUE;

   ctx->Extensions.MESA_pack_invert = GL_TRUE;

   ctx->Extensions.NV_fog_distance = GL_TRUE;
   ctx->Extensions.NV_texture_env_combine4 = GL_TRUE;
   ctx->Extensions.NV_texture_rectangle = GL_TRUE;
   ctx->Extensions.NV_vdpau_interop = GL_TRUE;

   ctx->Extensions.OES_EGL_image = GL_TRUE;
   ctx->Extensions.OES_EGL_image_external = GL_TRUE;
   ctx->Extensions.OES_draw_texture = GL_TRUE;
d631 1
a631 1
         extensions[cap_mapping[i].extension_offset] = GL_TRUE;
d636 1
a636 1
   init_format_extensions(st, rendertarget_mapping,
d639 1
a639 1
   init_format_extensions(st, depthstencil_mapping,
d642 6
a647 4
   init_format_extensions(st, texture_mapping, Elements(texture_mapping),
                          PIPE_TEXTURE_2D, PIPE_BIND_SAMPLER_VIEW);
   init_format_extensions(st, vertex_mapping, Elements(vertex_mapping),
                          PIPE_BUFFER, PIPE_BIND_VERTEX_BUFFER);
d652 1
a652 1
   ctx->Const.GLSLVersion = glsl_feature_level;
d654 1
a654 1
      ctx->Const.GLSLVersion = 330;
d656 1
a656 1
   _mesa_override_glsl_version(st->ctx);
d658 3
a660 3
   if (st->options.force_glsl_version > 0 &&
       st->options.force_glsl_version <= ctx->Const.GLSLVersion) {
      ctx->Const.ForceGLSLVersion = st->options.force_glsl_version;
d663 3
d668 3
a670 3
   if (ctx->Const.GLSLVersion >= 150 &&
       screen->get_param(screen, PIPE_CAP_TGSI_VS_LAYER)) {
      ctx->Extensions.AMD_vertex_shader_layer = GL_TRUE;
d673 3
a675 3
   if (ctx->Const.GLSLVersion >= 130) {
      ctx->Const.NativeIntegers = GL_TRUE;
      ctx->Const.MaxClipPlanes = 8;
d678 5
a682 4
      ctx->Extensions.ARB_conservative_depth = GL_TRUE;
      ctx->Extensions.ARB_shading_language_packing = GL_TRUE;
      ctx->Extensions.OES_depth_texture_cube_map = GL_TRUE;
      ctx->Extensions.ARB_shading_language_420pack = GL_TRUE;
d684 2
a685 2
      if (!st->options.disable_shader_bit_encoding) {
         ctx->Extensions.ARB_shader_bit_encoding = GL_TRUE;
d688 1
a688 1
      ctx->Extensions.EXT_shader_integer_mix = GL_TRUE;
d695 1
a695 1
         ctx->Const.NativeIntegers = GL_TRUE;
d697 1
a697 1
         ctx->Extensions.EXT_shader_integer_mix = GL_TRUE;
d701 2
d705 3
a707 3
   if (!ctx->Mesa_DXTn && !st->options.force_s3tc_enable) {
      ctx->Extensions.EXT_texture_compression_s3tc = GL_FALSE;
      ctx->Extensions.ANGLE_texture_compression_dxt = GL_FALSE;
d713 1
a713 1
      ctx->Extensions.ARB_geometry_shader4 = GL_TRUE;
d717 2
a718 3
   ctx->Extensions.NV_primitive_restart = GL_TRUE;
   if (!screen->get_param(screen, PIPE_CAP_PRIMITIVE_RESTART)) {
      ctx->Const.PrimitiveRestartInSoftware = GL_TRUE;
d723 1
a723 19
      ctx->Extensions.ARB_color_buffer_float = GL_TRUE;

      if (!screen->get_param(screen, PIPE_CAP_VERTEX_COLOR_CLAMPED)) {
         st->clamp_vert_color_in_shader = TRUE;
      }

      if (!screen->get_param(screen, PIPE_CAP_FRAGMENT_COLOR_CLAMPED)) {
         st->clamp_frag_color_in_shader = TRUE;
      }

      /* For drivers which cannot do color clamping, it's better to just
       * disable ARB_color_buffer_float in the core profile, because
       * the clamping is deprecated there anyway. */
      if (ctx->API == API_OPENGL_CORE &&
          (st->clamp_frag_color_in_shader || st->clamp_vert_color_in_shader)) {
         st->clamp_vert_color_in_shader = GL_FALSE;
         st->clamp_frag_color_in_shader = GL_FALSE;
         ctx->Extensions.ARB_color_buffer_float = GL_FALSE;
      }
d727 1
a727 1
      ctx->Extensions.ARB_sync = GL_TRUE;
d731 37
a767 10
   for (i = 16; i > 0; --i) {
      enum pipe_format pformat = st_choose_format(st, GL_RGBA,
                                                  GL_NONE, GL_NONE,
                                                  PIPE_TEXTURE_2D, i,
                                                  PIPE_BIND_RENDER_TARGET, FALSE);
      if (pformat != PIPE_FORMAT_NONE) {
         ctx->Const.MaxSamples = i;
         ctx->Const.MaxColorTextureSamples = i;
         break;
      }
d769 1
a769 21
   for (i = ctx->Const.MaxSamples; i > 0; --i) {
      enum pipe_format pformat = st_choose_format(st, GL_DEPTH_STENCIL,
                                                  GL_NONE, GL_NONE,
                                                  PIPE_TEXTURE_2D, i,
                                                  PIPE_BIND_DEPTH_STENCIL, FALSE);
      if (pformat != PIPE_FORMAT_NONE) {
         ctx->Const.MaxDepthTextureSamples = i;
         break;
      }
   }
   for (i = ctx->Const.MaxSamples; i > 0; --i) {
      enum pipe_format pformat = st_choose_format(st, GL_RGBA_INTEGER,
                                                  GL_NONE, GL_NONE,
                                                  PIPE_TEXTURE_2D, i,
                                                  PIPE_BIND_RENDER_TARGET, FALSE);
      if (pformat != PIPE_FORMAT_NONE) {
         ctx->Const.MaxIntegerSamples = i;
         break;
      }
   }
   if (ctx->Const.MaxSamples == 1) {
d771 1
a771 1
      ctx->Const.MaxSamples = 0;
d773 3
a775 3
   else if (ctx->Const.MaxSamples >= 2) {
      ctx->Extensions.EXT_framebuffer_multisample = GL_TRUE;
      ctx->Extensions.EXT_framebuffer_multisample_blit_scaled = GL_TRUE;
d778 5
a782 5
   if (ctx->Const.MaxSamples == 0 && screen->get_param(screen, PIPE_CAP_FAKE_SW_MSAA)) {
	ctx->Const.FakeSWMSAA = GL_TRUE;
        ctx->Extensions.EXT_framebuffer_multisample = GL_TRUE;
        ctx->Extensions.EXT_framebuffer_multisample_blit_scaled = GL_TRUE;
        ctx->Extensions.ARB_texture_multisample = GL_TRUE;
d785 3
a787 3
   if (ctx->Const.MaxDualSourceDrawBuffers > 0 &&
       !st->options.disable_blend_func_extended)
      ctx->Extensions.ARB_blend_func_extended = GL_TRUE;
d789 4
a792 2
   st->has_time_elapsed =
      screen->get_param(screen, PIPE_CAP_QUERY_TIME_ELAPSED);
d794 3
a796 3
   if (st->has_time_elapsed ||
       ctx->Extensions.ARB_timer_query) {
      ctx->Extensions.EXT_timer_query = GL_TRUE;
d798 2
d801 2
a802 6
   if (ctx->Extensions.ARB_transform_feedback2 &&
       ctx->Extensions.ARB_draw_instanced) {
      ctx->Extensions.ARB_transform_feedback_instanced = GL_TRUE;
   }
   if (st->options.force_glsl_extensions_warn)
      ctx->Const.ForceGLSLExtensionsWarn = 1;
d804 2
a805 2
   if (st->options.disable_glsl_line_continuations)
      ctx->Const.DisableGLSLLineContinuations = 1;
d807 1
a807 1
   ctx->Const.MinMapBufferAlignment =
d811 1
a811 1
      ctx->Extensions.ARB_texture_buffer_object = GL_TRUE;
d813 1
a813 1
      ctx->Const.MaxTextureBufferSize =
d816 1
a816 1
      ctx->Const.TextureBufferOffsetAlignment =
d819 2
a820 2
      if (ctx->Const.TextureBufferOffsetAlignment)
         ctx->Extensions.ARB_texture_buffer_range = GL_TRUE;
d822 3
a824 2
      init_format_extensions(st, tbo_rgb32, Elements(tbo_rgb32),
                             PIPE_BUFFER, PIPE_BIND_SAMPLER_VIEW);
d828 1
a828 1
      ctx->Extensions.ARB_framebuffer_object = GL_TRUE;
d841 2
a842 2
      if (!ctx->Extensions.EXT_transform_feedback)
         ctx->Const.DisableVaryingPacking = GL_TRUE;
d845 46
a890 7
   if (ctx->API == API_OPENGL_CORE) {
      ctx->Const.MaxViewports = screen->get_param(screen, PIPE_CAP_MAX_VIEWPORTS);
      if (ctx->Const.MaxViewports >= 16) {
         ctx->Const.ViewportBounds.Min = -16384.0;
         ctx->Const.ViewportBounds.Max = 16384.0;
         ctx->Extensions.ARB_viewport_array = GL_TRUE;
      }
a891 2
   if (ctx->Const.MaxProgramTextureGatherComponents > 0)
      ctx->Extensions.ARB_texture_gather = GL_TRUE;
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d22 1
a22 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d42 6
a97 4
   c->MaxCombinedTextureImageUnits
      = _min(screen->get_param(screen, PIPE_CAP_MAX_COMBINED_SAMPLERS),
             MAX_COMBINED_TEXTURE_IMAGE_UNITS);

d160 1
a160 1
         pc = &c->FragmentProgram;
d164 1
a164 1
         pc = &c->VertexProgram;
d168 1
a168 1
         pc = &c->GeometryProgram;
d248 6
d256 1
a256 1
      = _min(c->FragmentProgram.MaxTextureImageUnits, MAX_TEXTURE_COORD_UNITS);
d258 1
a258 1
   c->MaxTextureUnits = _min(c->FragmentProgram.MaxTextureImageUnits, c->MaxTextureCoordUnits);
d260 1
a260 1
   c->VertexProgram.MaxAttribs = MIN2(c->VertexProgram.MaxAttribs, 16);
d267 6
a272 1
   c->MaxVaryingComponents = c->MaxVarying * 4;
d277 4
d301 3
a303 3
         c->VertexProgram.MaxUniformBlocks +
         c->GeometryProgram.MaxUniformBlocks +
         c->FragmentProgram.MaxUniformBlocks;
d388 1
d402 1
a423 1
      { o(MESA_texture_array),               PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS         },
d427 3
a429 1
      { o(ARB_texture_multisample),          PIPE_CAP_TEXTURE_MULTISAMPLE              }
d439 3
a441 1
        { PIPE_FORMAT_B10G10R10A2_UINT } },
a464 6

      { { o(ARB_framebuffer_object),
          o(EXT_packed_depth_stencil) },
        { PIPE_FORMAT_S8_UINT_Z24_UNORM,
          PIPE_FORMAT_Z24_UNORM_S8_UINT },
        GL_TRUE }, /* at least one format must be supported */
d523 2
a543 1
   ctx->Extensions.ARB_half_float_pixel = GL_TRUE;
a557 1
   ctx->Extensions.EXT_framebuffer_blit = GL_TRUE;
a562 7
   /* IMPORTANT:
    *    Don't enable EXT_separate_shader_objects. It disallows a certain
    *    optimization in the GLSL compiler and therefore is considered
    *    harmful.
    */
   ctx->Extensions.EXT_separate_shader_objects = GL_FALSE;

d573 1
d601 3
a603 7
   if (glsl_feature_level >= 140) {
      ctx->Const.GLSLVersion = 140;
   } else if (glsl_feature_level >= 130) {
      ctx->Const.GLSLVersion = 130;
   } else {
      ctx->Const.GLSLVersion = 120;
   }
d612 7
d632 2
d641 2
d730 8
d764 1
a764 3
   if (ctx->Const.MinMapBufferAlignment >= 64) {
      ctx->Extensions.ARB_map_buffer_alignment = GL_TRUE;
   }
d781 3
d798 11
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d32 1
a32 1
#include "main/mfeatures.h"
d40 1
d42 1
a42 2

static int _min(int a, int b)
d71 2
a72 1
   gl_shader_type sh;
d89 2
a90 7
   c->MaxTextureImageUnits
      = _min(screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_IMAGE_UNITS),
            MAX_TEXTURE_IMAGE_UNITS);

   c->MaxVertexTextureImageUnits
      = _min(screen->get_param(screen, PIPE_CAP_MAX_VERTEX_TEXTURE_UNITS),
             MAX_VERTEX_TEXTURE_IMAGE_UNITS);
d96 15
a110 8
   c->MaxTextureCoordUnits
      = _min(c->MaxTextureImageUnits, MAX_TEXTURE_COORD_UNITS);

   c->MaxTextureUnits = _min(c->MaxTextureImageUnits, c->MaxTextureCoordUnits);

   c->MaxDrawBuffers
      = _clamp(screen->get_param(screen, PIPE_CAP_MAX_RENDER_TARGETS),
              1, MAX_DRAW_BUFFERS);
d113 2
a114 1
      = _maxf(1.0f, screen->get_paramf(screen, PIPE_CAP_MAX_LINE_WIDTH));
d116 2
a117 1
      = _maxf(1.0f, screen->get_paramf(screen, PIPE_CAP_MAX_LINE_WIDTH_AA));
d120 2
a121 1
      = _maxf(1.0f, screen->get_paramf(screen, PIPE_CAP_MAX_POINT_WIDTH));
d123 2
a124 1
      = _maxf(1.0f, screen->get_paramf(screen, PIPE_CAP_MAX_POINT_WIDTH_AA));
d136 2
a137 1
      = _maxf(2.0f, screen->get_paramf(screen, PIPE_CAP_MAX_TEXTURE_ANISOTROPY));
d140 4
a143 1
      = screen->get_paramf(screen, PIPE_CAP_MAX_TEXTURE_LOD_BIAS);
d145 9
a153 10
   c->MaxDrawBuffers
      = CLAMP(screen->get_param(screen, PIPE_CAP_MAX_RENDER_TARGETS),
              1, MAX_DRAW_BUFFERS);

   /* Quads always follow GL provoking rules. */
   c->QuadsFollowProvokingVertexConvention = GL_FALSE;

   for (sh = 0; sh < MESA_SHADER_TYPES; ++sh) {
      struct gl_shader_compiler_options *options =
         &st->ctx->ShaderCompilerOptions[sh];
d159 1
d163 1
d167 1
d170 1
a170 1
         assert(0);
d174 40
a213 11
      pc->MaxNativeInstructions    = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_INSTRUCTIONS);
      pc->MaxNativeAluInstructions = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS);
      pc->MaxNativeTexInstructions = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS);
      pc->MaxNativeTexIndirections = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS);
      pc->MaxNativeAttribs         = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_INPUTS);
      pc->MaxNativeTemps           = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_TEMPS);
      pc->MaxNativeAddressRegs     = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_ADDRS);
      pc->MaxNativeParameters      = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_CONSTS);
      pc->MaxUniformComponents     = 4 * MIN2(pc->MaxNativeParameters, MAX_UNIFORMS);
      /* raise MaxParameters if native support is higher */
      pc->MaxParameters            = MAX2(pc->MaxParameters, pc->MaxNativeParameters);
d218 1
a218 1
      options->EmitNoIfs = !screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH);
d234 5
d241 3
d246 12
a257 6
   /* PIPE_CAP_MAX_FS_INPUTS specifies the number of COLORn + GENERICn inputs
    * and is set in MaxNativeAttribs. It's always 2 colors + N generic
    * attributes. The GLSL compiler never uses COLORn for varyings, so we
    * subtract the 2 colors to get the maximum number of varyings (generic
    * attributes) supported by a driver. */
   c->MaxVarying = screen->get_shader_param(screen, PIPE_SHADER_FRAGMENT, PIPE_SHADER_CAP_MAX_INPUTS) - 2;
d259 6
d266 22
a287 3
   /* XXX we'll need a better query here someday */
   if (screen->get_param(screen, PIPE_CAP_GLSL)) {
      c->GLSLVersion = 120;
d292 33
a324 1
static GLboolean st_get_s3tc_override(void)
d326 27
a352 4
   const char *override = _mesa_getenv("force_s3tc_enable");
   if (override && !strcmp(override, "true"))
      return GL_TRUE;
   return GL_FALSE;
a354 1

d366 150
d520 1
a520 1
   ctx->Extensions.ARB_copy_buffer = GL_TRUE;
d522 1
d525 1
d527 2
a529 2
   ctx->Extensions.ARB_multisample = GL_TRUE;
   ctx->Extensions.ARB_sampler_objects = GL_TRUE;
a530 1
   ctx->Extensions.ARB_texture_compression = GL_TRUE;
a534 2
   ctx->Extensions.ARB_vertex_array_object = GL_TRUE;
   ctx->Extensions.ARB_vertex_buffer_object = GL_TRUE;
d536 1
a536 1
   ctx->Extensions.ARB_window_pos = GL_TRUE;
a539 1
   ctx->Extensions.EXT_blend_logic_op = GL_TRUE;
a540 1
   ctx->Extensions.EXT_blend_subtract = GL_TRUE;
a541 3
   ctx->Extensions.EXT_framebuffer_object = GL_TRUE;
   ctx->Extensions.EXT_framebuffer_multisample = GL_TRUE;
   ctx->Extensions.EXT_fog_coord = GL_TRUE;
a542 1
   ctx->Extensions.EXT_multi_draw_arrays = GL_TRUE;
d546 8
a553 4
   ctx->Extensions.EXT_secondary_color = GL_TRUE;
   ctx->Extensions.EXT_stencil_wrap = GL_TRUE;
   ctx->Extensions.EXT_texture_env_add = GL_TRUE;
   ctx->Extensions.EXT_texture_env_combine = GL_TRUE;
a554 1
   ctx->Extensions.EXT_texture_lod_bias = GL_TRUE;
a555 4
   if (ctx->API == API_OPENGLES || ctx->API == API_OPENGLES2)
	   ctx->Extensions.EXT_texture_format_BGRA8888 = GL_TRUE;

   ctx->Extensions.APPLE_vertex_array_object = GL_TRUE;
d561 1
a561 2
   ctx->Extensions.NV_blend_square = GL_TRUE;
   ctx->Extensions.NV_texgen_reflection = GL_TRUE;
a563 5
#if 0
   /* possibly could support the following two */
   ctx->Extensions.NV_vertex_program = GL_TRUE;
   ctx->Extensions.NV_vertex_program1_1 = GL_TRUE;
#endif
a564 1
#if FEATURE_OES_EGL_image
d566 1
a566 2
#endif
#if FEATURE_OES_draw_texture
a567 1
#endif
d569 6
a574 1
   ctx->Extensions.SGIS_generate_mipmap = GL_TRUE;
d576 39
a614 6
   /*
    * Extensions that depend on the driver/hardware:
    */
   if (screen->get_param(screen, PIPE_CAP_MAX_RENDER_TARGETS) > 0) {
      ctx->Extensions.ARB_draw_buffers = GL_TRUE;
   }
d616 11
a626 2
   if (screen->get_param(screen, PIPE_CAP_TEXTURE_SWIZZLE) > 0) {
      ctx->Extensions.EXT_texture_swizzle = GL_TRUE;
d629 1
a629 8
   if (screen->get_param(screen, PIPE_CAP_GLSL)) {
      ctx->Extensions.ARB_fragment_shader = GL_TRUE;
      ctx->Extensions.ARB_vertex_shader = GL_TRUE;
      ctx->Extensions.ARB_shader_objects = GL_TRUE;
      ctx->Extensions.ARB_shading_language_100 = GL_TRUE;
      ctx->Extensions.ARB_explicit_attrib_location = GL_TRUE;
      ctx->Extensions.EXT_separate_shader_objects = GL_TRUE;
   }
d631 3
a633 2
   if (screen->get_param(screen, PIPE_CAP_TEXTURE_MIRROR_REPEAT) > 0) {
      ctx->Extensions.ARB_texture_mirrored_repeat = GL_TRUE;
d636 5
a640 2
   if (screen->get_param(screen, PIPE_CAP_BLEND_EQUATION_SEPARATE)) {
      ctx->Extensions.EXT_blend_equation_separate = GL_TRUE;
d643 3
a645 3
   if (screen->get_param(screen, PIPE_CAP_TEXTURE_MIRROR_CLAMP) > 0) {
      ctx->Extensions.EXT_texture_mirror_clamp = GL_TRUE;
      ctx->Extensions.ATI_texture_mirror_once = GL_TRUE;
d648 3
a650 3
   if (screen->get_param(screen, PIPE_CAP_NPOT_TEXTURES)) {
      ctx->Extensions.ARB_texture_non_power_of_two = GL_TRUE;
   }
d652 3
a654 3
   if (screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_IMAGE_UNITS) > 1) {
      ctx->Extensions.ARB_multitexture = GL_TRUE;
   }
d656 3
a658 4
   if (screen->get_param(screen, PIPE_CAP_TWO_SIDED_STENCIL)) {
      ctx->Extensions.ATI_separate_stencil = GL_TRUE;
      ctx->Extensions.EXT_stencil_two_side = GL_TRUE;
   }
d660 9
a668 2
   if (screen->get_param(screen, PIPE_CAP_ANISOTROPIC_FILTER)) {
      ctx->Extensions.EXT_texture_filter_anisotropic = GL_TRUE;
d671 2
a672 5
   if (screen->get_param(screen, PIPE_CAP_POINT_SPRITE)) {
      ctx->Extensions.ARB_point_sprite = GL_TRUE;
      /* GL_NV_point_sprite is not supported by gallium because we don't
       * support the GL_POINT_SPRITE_R_MODE_NV option.
       */
d675 11
a685 3
   if (screen->get_param(screen, PIPE_CAP_OCCLUSION_QUERY)) {
      ctx->Extensions.ARB_occlusion_query = GL_TRUE;
      ctx->Extensions.ARB_occlusion_query2 = GL_TRUE;
d687 9
a695 2
   if (screen->get_param(screen, PIPE_CAP_TIMER_QUERY)) {
     ctx->Extensions.EXT_timer_query = GL_TRUE;
d697 9
a705 7

   if (screen->get_param(screen, PIPE_CAP_TEXTURE_SHADOW_MAP)) {
      ctx->Extensions.ARB_depth_texture = GL_TRUE;
      ctx->Extensions.ARB_fragment_program_shadow = GL_TRUE;
      ctx->Extensions.ARB_shadow = GL_TRUE;
      ctx->Extensions.EXT_shadow_funcs = GL_TRUE;
      /*ctx->Extensions.ARB_shadow_ambient = GL_TRUE;*/
d707 3
a709 156

   /* GL_EXT_packed_depth_stencil requires both the ability to render to
    * a depth/stencil buffer and texture from depth/stencil source.
    */
   if (screen->is_format_supported(screen, PIPE_FORMAT_S8_USCALED_Z24_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_DEPTH_STENCIL) &&
       screen->is_format_supported(screen, PIPE_FORMAT_S8_USCALED_Z24_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW)) {
      ctx->Extensions.EXT_packed_depth_stencil = GL_TRUE;
   }
   else if (screen->is_format_supported(screen, PIPE_FORMAT_Z24_UNORM_S8_USCALED,
                                        PIPE_TEXTURE_2D, 0,
                                        PIPE_BIND_DEPTH_STENCIL) &&
            screen->is_format_supported(screen, PIPE_FORMAT_Z24_UNORM_S8_USCALED,
                                        PIPE_TEXTURE_2D, 0,
                                        PIPE_BIND_SAMPLER_VIEW)) {
      ctx->Extensions.EXT_packed_depth_stencil = GL_TRUE;
   }

   /* float support - assume nothing exclusively supports 64-bit floats */
   if (screen->is_format_supported(screen, PIPE_FORMAT_R32G32B32A32_FLOAT,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW |
                                   PIPE_BIND_RENDER_TARGET) &&
      screen->is_format_supported(screen, PIPE_FORMAT_R16G16B16A16_FLOAT,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW |
                                   PIPE_BIND_RENDER_TARGET)) {
      ctx->Extensions.ARB_texture_float = GL_TRUE;
   }

   /* sRGB support */
   if (screen->is_format_supported(screen, PIPE_FORMAT_A8B8G8R8_SRGB,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) ||
      screen->is_format_supported(screen, PIPE_FORMAT_B8G8R8A8_SRGB,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW)) {
      ctx->Extensions.EXT_texture_sRGB = GL_TRUE;
      ctx->Extensions.EXT_texture_sRGB_decode = GL_TRUE;
      if (screen->is_format_supported(screen, PIPE_FORMAT_A8B8G8R8_SRGB,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_RENDER_TARGET) ||
          screen->is_format_supported(screen, PIPE_FORMAT_B8G8R8A8_SRGB,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_RENDER_TARGET)) {
         ctx->Extensions.EXT_framebuffer_sRGB = GL_TRUE;
         ctx->Const.sRGBCapable = GL_TRUE;
      }
   }

   if (screen->is_format_supported(screen, PIPE_FORMAT_R8G8_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW)) {
      ctx->Extensions.ARB_texture_rg = GL_TRUE;
   }

   /* s3tc support */
   if (screen->is_format_supported(screen, PIPE_FORMAT_DXT5_RGBA,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       (ctx->Mesa_DXTn || st_get_s3tc_override())) {
      ctx->Extensions.EXT_texture_compression_s3tc = GL_TRUE;
      ctx->Extensions.S3_s3tc = GL_TRUE;
   }

   if (screen->is_format_supported(screen, PIPE_FORMAT_RGTC1_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_RGTC1_SNORM,
				   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_RGTC2_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_RGTC2_SNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW)
       ) {
     ctx->Extensions.ARB_texture_compression_rgtc = GL_TRUE;
   }

   if (screen->is_format_supported(screen, PIPE_FORMAT_LATC1_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_LATC1_SNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_LATC2_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_LATC2_SNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW)) {
      ctx->Extensions.EXT_texture_compression_latc = GL_TRUE;
   }

   if (screen->is_format_supported(screen, PIPE_FORMAT_LATC2_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW)) {
      ctx->Extensions.ATI_texture_compression_3dc = GL_TRUE;
   }

   if (screen->is_format_supported(screen, PIPE_FORMAT_R8G8B8A8_SNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW)) {
      ctx->Extensions.EXT_texture_snorm = GL_TRUE;
   }

   /* ycbcr support */
   if (screen->is_format_supported(screen, PIPE_FORMAT_UYVY, 
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) ||
       screen->is_format_supported(screen, PIPE_FORMAT_YUYV, 
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW)) {
      ctx->Extensions.MESA_ycbcr_texture = GL_TRUE;
   }

   /* GL_EXT_texture_array */
   if (screen->get_param(screen, PIPE_CAP_ARRAY_TEXTURES)) {
      ctx->Extensions.EXT_texture_array = GL_TRUE;
      ctx->Extensions.MESA_texture_array = GL_TRUE;
   }

   /* GL_ARB_framebuffer_object */
   if (ctx->Extensions.EXT_packed_depth_stencil) {
      /* we support always support GL_EXT_framebuffer_blit */
      ctx->Extensions.ARB_framebuffer_object = GL_TRUE;
   }

   if (st->pipe->render_condition) {
      ctx->Extensions.NV_conditional_render = GL_TRUE;
   }

   if (screen->get_param(screen, PIPE_CAP_INDEP_BLEND_ENABLE)) {
      ctx->Extensions.EXT_draw_buffers2 = GL_TRUE;
   }

   if (screen->get_param(screen, PIPE_CAP_INDEP_BLEND_FUNC)) {
      ctx->Extensions.ARB_draw_buffers_blend = GL_TRUE;
   }

   /* GL_ARB_half_float_vertex */
   if (screen->is_format_supported(screen, PIPE_FORMAT_R16G16B16A16_FLOAT,
                                   PIPE_BUFFER, 0,
                                   PIPE_BIND_VERTEX_BUFFER)) {
      ctx->Extensions.ARB_half_float_vertex = GL_TRUE;
   }

   if (screen->is_format_supported(screen, PIPE_FORMAT_R32G32B32A32_FIXED,
                                   PIPE_BUFFER, 0,
                                   PIPE_BIND_VERTEX_BUFFER)) {
      ctx->Extensions.ARB_ES2_compatibility = GL_TRUE;
d711 2
a712 5

   if (screen->get_shader_param(screen, PIPE_SHADER_GEOMETRY, PIPE_SHADER_CAP_MAX_INSTRUCTIONS) > 0) {
#if 0 /* XXX re-enable when GLSL compiler again supports geometry shaders */
      ctx->Extensions.ARB_geometry_shader4 = GL_TRUE;
#endif
d715 3
a717 3
   if (screen->get_param(screen, PIPE_CAP_PRIMITIVE_RESTART)) {
      ctx->Extensions.NV_primitive_restart = GL_TRUE;
   }
d719 2
a720 3
   if (screen->get_param(screen, PIPE_CAP_DEPTH_CLAMP)) {
      ctx->Extensions.ARB_depth_clamp = GL_TRUE;
   }
d722 3
a724 27
   /* This extension does not actually require support of floating point
    * render targets, just clamping controls.
    * Advertise this extension if either fragment color clamping is supported
    * or no render targets having color values outside of the range [0, 1]
    * are supported, in which case the fragment color clamping has no effect
    * on rendering.
    */
   if (screen->get_param(screen, PIPE_CAP_FRAGMENT_COLOR_CLAMP_CONTROL) ||
       (!screen->is_format_supported(screen, PIPE_FORMAT_R8G8B8A8_SNORM,
                                     PIPE_TEXTURE_2D, 0,
                                     PIPE_BIND_RENDER_TARGET) &&
        !screen->is_format_supported(screen, PIPE_FORMAT_R16G16B16A16_SNORM,
                                     PIPE_TEXTURE_2D, 0,
                                     PIPE_BIND_RENDER_TARGET) &&
        !screen->is_format_supported(screen, PIPE_FORMAT_R16G16B16A16_FLOAT,
                                     PIPE_TEXTURE_2D, 0,
                                     PIPE_BIND_RENDER_TARGET) &&
        !screen->is_format_supported(screen, PIPE_FORMAT_R32G32B32A32_FLOAT,
                                     PIPE_TEXTURE_2D, 0,
                                     PIPE_BIND_RENDER_TARGET) &&
        !screen->is_format_supported(screen, PIPE_FORMAT_R11G11B10_FLOAT,
                                     PIPE_TEXTURE_2D, 0,
                                     PIPE_BIND_RENDER_TARGET) &&
        !screen->is_format_supported(screen, PIPE_FORMAT_R9G9B9E5_FLOAT,
                                     PIPE_TEXTURE_2D, 0,
                                     PIPE_BIND_RENDER_TARGET))) {
      ctx->Extensions.ARB_color_buffer_float = GL_TRUE;
d727 3
a729 2
   if (screen->get_param(screen, PIPE_CAP_SHADER_STENCIL_EXPORT)) {
      ctx->Extensions.ARB_shader_stencil_export = GL_TRUE;
d731 2
d734 2
a735 6
   if (screen->get_param(screen, PIPE_CAP_TGSI_INSTANCEID)) {
      ctx->Extensions.ARB_draw_instanced = GL_TRUE;
   }
   if (screen->get_param(screen, PIPE_CAP_VERTEX_ELEMENT_INSTANCE_DIVISOR)) {
      ctx->Extensions.ARB_instanced_arrays = GL_TRUE;
   }
d737 4
a740 2
   if (screen->fence_finish) {
      ctx->Extensions.ARB_sync = GL_TRUE;
d742 2
d745 5
a749 3
   if (st->pipe->texture_barrier) {
      ctx->Extensions.NV_texture_barrier = GL_TRUE;
   }
d751 2
a752 5
   if (screen->is_format_supported(screen, PIPE_FORMAT_R9G9B9E5_FLOAT,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW)) {
      ctx->Extensions.EXT_texture_shared_exponent = GL_TRUE;
   }
d754 2
a755 5
   if (screen->is_format_supported(screen, PIPE_FORMAT_R11G11B10_FLOAT,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_RENDER_TARGET |
                                   PIPE_BIND_SAMPLER_VIEW)) {
      ctx->Extensions.EXT_packed_float = GL_TRUE;
a757 7
   if (screen->get_param(screen, PIPE_CAP_SEAMLESS_CUBE_MAP_PER_TEXTURE)) {
      ctx->Extensions.ARB_seamless_cube_map = GL_TRUE;
      ctx->Extensions.AMD_seamless_cubemap_per_texture = GL_TRUE;
   }
   else if (screen->get_param(screen, PIPE_CAP_SEAMLESS_CUBE_MAP)) {
      ctx->Extensions.ARB_seamless_cube_map = GL_TRUE;
   }
d759 12
a770 2
   if (screen->get_param(screen, PIPE_CAP_SM3)) {
      ctx->Extensions.ARB_shader_texture_lod = GL_TRUE;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d32 1
d170 2
d192 1
a192 1
      if(options->EmitNoLoops)
d211 9
d239 1
d242 1
d275 2
d362 1
d381 1
a381 1
                                   PIPE_BIND_DEPTH_STENCIL, 0) &&
d384 1
a384 1
                                   PIPE_BIND_SAMPLER_VIEW, 0)) {
d389 1
a389 1
                                        PIPE_BIND_DEPTH_STENCIL, 0) &&
d392 1
a392 1
                                        PIPE_BIND_SAMPLER_VIEW, 0)) {
d396 12
d411 1
a411 1
                                   PIPE_BIND_SAMPLER_VIEW, 0) ||
d414 1
a414 1
                                   PIPE_BIND_SAMPLER_VIEW, 0)) {
d416 10
d430 1
a430 1
                                   PIPE_BIND_SAMPLER_VIEW, 0)) {
d437 2
a438 5
                                   PIPE_BIND_SAMPLER_VIEW, 0) &&
       (ctx->Mesa_DXTn ||
        screen->is_format_supported(screen, PIPE_FORMAT_DXT5_RGBA,
                                    PIPE_TEXTURE_2D, 0,
                                    PIPE_BIND_RENDER_TARGET, 0))) {
d443 43
d489 1
a489 1
                                   PIPE_BIND_SAMPLER_VIEW, 0) ||
d492 1
a492 1
                                   PIPE_BIND_SAMPLER_VIEW, 0)) {
d496 6
d516 4
d523 1
a523 1
                                   PIPE_BIND_VERTEX_BUFFER, 0)) {
d527 4
a530 3
#if 0 /* not yet */
   if (screen->get_param(screen, PIPE_CAP_INDEP_BLEND_FUNC)) {
      ctx->Extensions.ARB_draw_buffers_blend = GL_TRUE;
a531 1
#endif
d547 29
d578 40
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d70 1
a70 1
   struct gl_program_constants *pc;
d137 2
a138 4
   /* Is TGSI_OPCODE_CONT supported? */
   /* XXX separate query for early function return? */
   st->ctx->Shader.EmitContReturn =
      screen->get_param(screen, PIPE_CAP_TGSI_CONT_SUPPORTED);
d140 62
d203 1
a203 87
      /*
       * In the lack of more fine grained capabilities, if the pipe driver supports
       * GLSL then assume native limits match Mesa software limits.
       */

      pc = &c->FragmentProgram;
      pc->MaxNativeInstructions      = pc->MaxInstructions;
      pc->MaxNativeAluInstructions   = pc->MaxAluInstructions;
      pc->MaxNativeTexInstructions   = pc->MaxTexInstructions;
      pc->MaxNativeTexIndirections   = pc->MaxTexIndirections;
      pc->MaxNativeAttribs           = pc->MaxAttribs;
      pc->MaxNativeTemps             = pc->MaxTemps;
      pc->MaxNativeAddressRegs       = pc->MaxAddressRegs;
      pc->MaxNativeParameters        = pc->MaxParameters;

      pc = &c->VertexProgram;
      pc->MaxNativeInstructions      = pc->MaxInstructions;
      pc->MaxNativeAluInstructions   = pc->MaxAluInstructions;
      pc->MaxNativeTexInstructions   = pc->MaxTexInstructions;
      pc->MaxNativeTexIndirections   = pc->MaxTexIndirections;
      pc->MaxNativeAttribs           = pc->MaxAttribs;
      pc->MaxNativeTemps             = pc->MaxTemps;
      pc->MaxNativeAddressRegs       = pc->MaxAddressRegs;
      pc->MaxNativeParameters        = pc->MaxParameters;
   } else if (screen->get_param(screen, PIPE_CAP_SM3)) {
      /*
       * Assume the hardware meets the minimum requirements
       * for Shader Model 3.
       *
       * See also:
       * - http://msdn.microsoft.com/en-us/library/bb172920(VS.85).aspx
       * - http://msdn.microsoft.com/en-us/library/bb172963(VS.85).aspx
       */

      pc = &c->FragmentProgram;
      pc->MaxNativeInstructions      = 512; /* D3DMIN30SHADERINSTRUCTIONS */
      pc->MaxNativeAluInstructions   = pc->MaxNativeInstructions;
      pc->MaxNativeTexInstructions   = pc->MaxNativeInstructions;
      pc->MaxNativeTexIndirections   = pc->MaxNativeTexInstructions;
      pc->MaxNativeAttribs           = 10;
      pc->MaxNativeTemps             = 32;
      pc->MaxNativeAddressRegs       = 1; /* aL */
      pc->MaxNativeParameters        = 224;

      pc = &c->VertexProgram;
      pc->MaxNativeInstructions      = 512; /* D3DMIN30SHADERINSTRUCTIONS */
      pc->MaxNativeAluInstructions   = pc->MaxNativeInstructions;
      pc->MaxNativeTexInstructions   = pc->MaxNativeInstructions;
      pc->MaxNativeTexIndirections   = pc->MaxNativeTexInstructions;
      pc->MaxNativeAttribs           = 16;
      pc->MaxNativeTemps             = 32;
      pc->MaxNativeAddressRegs       = 2; /* a0 and aL */
      pc->MaxNativeParameters        = 256;
   } else {
      /*
       * Assume the hardware meets the minimum requirements
       * for Shader Model 2.
       *
       * See also:
       * - http://msdn.microsoft.com/en-us/library/bb172918(VS.85).aspx
       * - http://msdn.microsoft.com/en-us/library/bb172961(VS.85).aspx
       */

      pc = &c->FragmentProgram;
      pc->MaxNativeInstructions      = 96; /* D3DPS20_MIN_NUMINSTRUCTIONSLOTS */
      pc->MaxNativeAluInstructions   = 64;
      pc->MaxNativeTexInstructions   = 32;
      pc->MaxNativeTexIndirections   = pc->MaxNativeTexInstructions;
      pc->MaxNativeAttribs           = 10; /* 2 color + 8 texture coord */
      pc->MaxNativeTemps             = 12; /* D3DPS20_MIN_NUMTEMPS */
      pc->MaxNativeAddressRegs       = 0;
      pc->MaxNativeParameters        = 16;

      pc = &c->VertexProgram;
      pc->MaxNativeInstructions      = 256;
      pc->MaxNativeAluInstructions   = 256;
      pc->MaxNativeTexInstructions   = 0;
      pc->MaxNativeTexIndirections   = 0;
      pc->MaxNativeAttribs           = 16;
      pc->MaxNativeTemps             = 12; /* D3DVS20_MIN_NUMTEMPS */
      pc->MaxNativeAddressRegs       = 2; /* a0 and aL */
      pc->MaxNativeParameters        = 256;
   }

   if (!screen->get_param(screen, PIPE_CAP_MAX_VERTEX_TEXTURE_UNITS)) {
      c->VertexProgram.MaxNativeTexInstructions = 0;
      c->VertexProgram.MaxNativeTexIndirections = 0;
d218 1
a218 1
   GLcontext *ctx = st->ctx;
d224 1
d238 1
d249 1
d264 4
d271 6
d278 3
a284 1
   ctx->Extensions.SGI_color_matrix = GL_TRUE;
d294 4
d303 2
a304 1
      ctx->Extensions.ARB_shading_language_120 = GL_TRUE;
d317 1
a321 1
      ctx->Extensions.NV_texture_rectangle = GL_TRUE;
d347 3
d353 1
d362 6
a367 6
   if (screen->is_format_supported(screen, PIPE_FORMAT_S8Z24_UNORM,
                                   PIPE_TEXTURE_2D, 
                                   PIPE_TEXTURE_USAGE_DEPTH_STENCIL, 0) &&
       screen->is_format_supported(screen, PIPE_FORMAT_S8Z24_UNORM,
                                   PIPE_TEXTURE_2D, 
                                   PIPE_TEXTURE_USAGE_SAMPLER, 0)) {
d370 6
a375 6
   else if (screen->is_format_supported(screen, PIPE_FORMAT_Z24S8_UNORM,
                                        PIPE_TEXTURE_2D, 
                                        PIPE_TEXTURE_USAGE_DEPTH_STENCIL, 0) &&
            screen->is_format_supported(screen, PIPE_FORMAT_Z24S8_UNORM,
                                        PIPE_TEXTURE_2D, 
                                        PIPE_TEXTURE_USAGE_SAMPLER, 0)) {
d381 2
a382 2
                                   PIPE_TEXTURE_2D, 
                                   PIPE_TEXTURE_USAGE_SAMPLER, 0) ||
d384 2
a385 2
                                   PIPE_TEXTURE_2D, 
                                   PIPE_TEXTURE_USAGE_SAMPLER, 0)) {
d389 6
d397 2
a398 2
                                   PIPE_TEXTURE_2D,
                                   PIPE_TEXTURE_USAGE_SAMPLER, 0) &&
d401 2
a402 2
                                    PIPE_TEXTURE_2D,
                                    PIPE_TEXTURE_USAGE_RENDER_TARGET, 0))) {
d409 2
a410 2
                                   PIPE_TEXTURE_2D, 
                                   PIPE_TEXTURE_USAGE_SAMPLER, 0) ||
d412 2
a413 2
                                   PIPE_TEXTURE_2D, 
                                   PIPE_TEXTURE_USAGE_SAMPLER, 0)) {
d431 7
d443 18
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d70 1
a70 1
   gl_shader_type sh;
d137 4
a140 2
   /* Quads always follow GL provoking rules. */
   c->QuadsFollowProvokingVertexConvention = GL_FALSE;
d142 34
a175 60
   for (sh = 0; sh < MESA_SHADER_TYPES; ++sh) {
      struct gl_shader_compiler_options *options =
         &st->ctx->ShaderCompilerOptions[sh];
      struct gl_program_constants *pc;

      switch (sh) {
      case PIPE_SHADER_FRAGMENT:
         pc = &c->FragmentProgram;
         break;
      case PIPE_SHADER_VERTEX:
         pc = &c->VertexProgram;
         break;
      case PIPE_SHADER_GEOMETRY:
         pc = &c->GeometryProgram;
         break;
      default:
         assert(0);
         continue;
      }

      pc->MaxNativeInstructions    = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_INSTRUCTIONS);
      pc->MaxNativeAluInstructions = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS);
      pc->MaxNativeTexInstructions = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS);
      pc->MaxNativeTexIndirections = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS);
      pc->MaxNativeAttribs         = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_INPUTS);
      pc->MaxNativeTemps           = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_TEMPS);
      pc->MaxNativeAddressRegs     = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_ADDRS);
      pc->MaxNativeParameters      = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_CONSTS);
      pc->MaxUniformComponents     = 4 * MIN2(pc->MaxNativeParameters, MAX_UNIFORMS);

      options->EmitNoNoise = TRUE;

      /* TODO: make these more fine-grained if anyone needs it */
      options->EmitNoIfs = !screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH);
      options->EmitNoLoops = !screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH);
      options->EmitNoFunctions = !screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_SUBROUTINES);
      options->EmitNoMainReturn = !screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_SUBROUTINES);

      options->EmitNoCont = !screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_TGSI_CONT_SUPPORTED);

      options->EmitNoIndirectInput = !screen->get_shader_param(screen, sh,
                                        PIPE_SHADER_CAP_INDIRECT_INPUT_ADDR);
      options->EmitNoIndirectOutput = !screen->get_shader_param(screen, sh,
                                        PIPE_SHADER_CAP_INDIRECT_OUTPUT_ADDR);
      options->EmitNoIndirectTemp = !screen->get_shader_param(screen, sh,
                                        PIPE_SHADER_CAP_INDIRECT_TEMP_ADDR);
      options->EmitNoIndirectUniform = !screen->get_shader_param(screen, sh,
                                        PIPE_SHADER_CAP_INDIRECT_CONST_ADDR);

      if(options->EmitNoLoops)
         options->MaxUnrollIterations = MIN2(screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_INSTRUCTIONS), 65536);
   }

   /* PIPE_CAP_MAX_FS_INPUTS specifies the number of COLORn + GENERICn inputs
    * and is set in MaxNativeAttribs. It's always 2 colors + N generic
    * attributes. The GLSL compiler never uses COLORn for varyings, so we
    * subtract the 2 colors to get the maximum number of varyings (generic
    * attributes) supported by a driver. */
   c->MaxVarying = screen->get_shader_param(screen, PIPE_SHADER_FRAGMENT, PIPE_SHADER_CAP_MAX_INPUTS) - 2;
   c->MaxVarying = MIN2(c->MaxVarying, MAX_VARYING);
d177 53
a229 3
   /* XXX we'll need a better query here someday */
   if (screen->get_param(screen, PIPE_CAP_GLSL)) {
      c->GLSLVersion = 120;
d244 1
a244 1
   struct gl_context *ctx = st->ctx;
a249 1
   ctx->Extensions.ARB_draw_elements_base_vertex = GL_TRUE;
a262 1
   ctx->Extensions.ARB_window_pos = GL_TRUE;
a272 1
   ctx->Extensions.EXT_gpu_program_parameters = GL_TRUE;
a286 4
   ctx->Extensions.ATI_texture_env_combine3 = GL_TRUE;

   ctx->Extensions.MESA_pack_invert = GL_TRUE;

a289 6
   ctx->Extensions.NV_texture_rectangle = GL_TRUE;
#if 0
   /* possibly could support the following two */
   ctx->Extensions.NV_vertex_program = GL_TRUE;
   ctx->Extensions.NV_vertex_program1_1 = GL_TRUE;
#endif
a290 3
#if FEATURE_OES_EGL_image
   ctx->Extensions.OES_EGL_image = GL_TRUE;
#endif
d295 1
a304 4
   if (screen->get_param(screen, PIPE_CAP_TEXTURE_SWIZZLE) > 0) {
      ctx->Extensions.EXT_texture_swizzle = GL_TRUE;
   }

d310 1
a310 2
      ctx->Extensions.ARB_explicit_attrib_location = GL_TRUE;
      ctx->Extensions.EXT_separate_shader_objects = GL_TRUE;
a322 1
      ctx->Extensions.ATI_texture_mirror_once = GL_TRUE;
d327 1
a352 3
   if (screen->get_param(screen, PIPE_CAP_TIMER_QUERY)) {
     ctx->Extensions.EXT_timer_query = GL_TRUE;
   }
a355 1
      ctx->Extensions.ARB_fragment_program_shadow = GL_TRUE;
d364 6
a369 6
   if (screen->is_format_supported(screen, PIPE_FORMAT_S8_USCALED_Z24_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_DEPTH_STENCIL, 0) &&
       screen->is_format_supported(screen, PIPE_FORMAT_S8_USCALED_Z24_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW, 0)) {
d372 6
a377 6
   else if (screen->is_format_supported(screen, PIPE_FORMAT_Z24_UNORM_S8_USCALED,
                                        PIPE_TEXTURE_2D, 0,
                                        PIPE_BIND_DEPTH_STENCIL, 0) &&
            screen->is_format_supported(screen, PIPE_FORMAT_Z24_UNORM_S8_USCALED,
                                        PIPE_TEXTURE_2D, 0,
                                        PIPE_BIND_SAMPLER_VIEW, 0)) {
d383 2
a384 2
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW, 0) ||
d386 2
a387 2
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW, 0)) {
a390 6
   if (screen->is_format_supported(screen, PIPE_FORMAT_R8G8_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW, 0)) {
      ctx->Extensions.ARB_texture_rg = GL_TRUE;
   }

d393 2
a394 2
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW, 0) &&
d397 2
a398 2
                                    PIPE_TEXTURE_2D, 0,
                                    PIPE_BIND_RENDER_TARGET, 0))) {
d405 2
a406 2
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW, 0) ||
d408 2
a409 2
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW, 0)) {
a426 7
   /* GL_ARB_half_float_vertex */
   if (screen->is_format_supported(screen, PIPE_FORMAT_R16G16B16A16_FLOAT,
                                   PIPE_BUFFER, 0,
                                   PIPE_BIND_VERTEX_BUFFER, 0)) {
      ctx->Extensions.ARB_half_float_vertex = GL_TRUE;
   }

a431 18

   if (screen->get_shader_param(screen, PIPE_SHADER_GEOMETRY, PIPE_SHADER_CAP_MAX_INSTRUCTIONS) > 0) {
#if 0 /* XXX re-enable when GLSL compiler again supports geometry shaders */
      ctx->Extensions.ARB_geometry_shader4 = GL_TRUE;
#endif
   }

   if (screen->get_param(screen, PIPE_CAP_PRIMITIVE_RESTART)) {
      ctx->Extensions.NV_primitive_restart = GL_TRUE;
   }

   if (screen->get_param(screen, PIPE_CAP_DEPTH_CLAMP)) {
      ctx->Extensions.ARB_depth_clamp = GL_TRUE;
   }

   if (screen->get_param(screen, PIPE_CAP_SHADER_STENCIL_EXPORT)) {
      ctx->Extensions.ARB_shader_stencil_export = GL_TRUE;
   }
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a31 1
#include "main/version.h"
a38 1
#include "st_format.h"
d40 2
a41 1
static unsigned _min(unsigned a, unsigned b)
d70 1
a70 2
   unsigned sh;
   boolean can_ubo = TRUE;
d87 7
a93 2
   c->MaxArrayTextureLayers
      = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS);
d99 8
a106 15
   /* Define max viewport size and max renderbuffer size in terms of
    * max texture size (note: max tex RECT size = max tex 2D size).
    * If this isn't true for some hardware we'll need new PIPE_CAP_ queries.
    */
   c->MaxViewportWidth =
   c->MaxViewportHeight =
   c->MaxRenderbufferSize = c->MaxTextureRectSize;

   c->MaxDrawBuffers = c->MaxColorAttachments =
      _clamp(screen->get_param(screen, PIPE_CAP_MAX_RENDER_TARGETS),
             1, MAX_DRAW_BUFFERS);

   c->MaxDualSourceDrawBuffers
      = _clamp(screen->get_param(screen, PIPE_CAP_MAX_DUAL_SOURCE_RENDER_TARGETS),
              0, MAX_DRAW_BUFFERS);
d109 1
a109 2
      = _maxf(1.0f, screen->get_paramf(screen,
                                       PIPE_CAPF_MAX_LINE_WIDTH));
d111 1
a111 2
      = _maxf(1.0f, screen->get_paramf(screen,
                                       PIPE_CAPF_MAX_LINE_WIDTH_AA));
d114 1
a114 2
      = _maxf(1.0f, screen->get_paramf(screen,
                                       PIPE_CAPF_MAX_POINT_WIDTH));
d116 1
a116 2
      = _maxf(1.0f, screen->get_paramf(screen,
                                       PIPE_CAPF_MAX_POINT_WIDTH_AA));
d128 1
a128 2
      = _maxf(2.0f, screen->get_paramf(screen,
                                 PIPE_CAPF_MAX_TEXTURE_ANISOTROPY));
d131 1
a131 4
      = screen->get_paramf(screen, PIPE_CAPF_MAX_TEXTURE_LOD_BIAS);

   c->QuadsFollowProvokingVertexConvention = screen->get_param(
      screen, PIPE_CAP_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION);
d133 10
a142 9
   c->MaxUniformBlockSize =
      screen->get_shader_param(screen, PIPE_SHADER_FRAGMENT,
                               PIPE_SHADER_CAP_MAX_CONSTS) * 16;
   if (c->MaxUniformBlockSize < 16384) {
      can_ubo = FALSE;
   }

   for (sh = 0; sh < PIPE_SHADER_TYPES; ++sh) {
      struct gl_shader_compiler_options *options;
a147 1
         options = &st->ctx->ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
a150 1
         options = &st->ctx->ShaderCompilerOptions[MESA_SHADER_VERTEX];
a153 1
         options = &st->ctx->ShaderCompilerOptions[MESA_SHADER_GEOMETRY];
d156 1
a156 1
         /* compute shader, etc. */
d160 9
a168 40
      pc->MaxTextureImageUnits =
         _min(screen->get_shader_param(screen, sh,
                                       PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS),
              MAX_TEXTURE_IMAGE_UNITS);

      pc->MaxInstructions    = pc->MaxNativeInstructions    =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_INSTRUCTIONS);
      pc->MaxAluInstructions = pc->MaxNativeAluInstructions =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_ALU_INSTRUCTIONS);
      pc->MaxTexInstructions = pc->MaxNativeTexInstructions =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_TEX_INSTRUCTIONS);
      pc->MaxTexIndirections = pc->MaxNativeTexIndirections =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS);
      pc->MaxAttribs         = pc->MaxNativeAttribs         =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_INPUTS);
      pc->MaxTemps           = pc->MaxNativeTemps           =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_TEMPS);
      pc->MaxAddressRegs     = pc->MaxNativeAddressRegs     =
         _min(screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_ADDRS),
              MAX_PROGRAM_ADDRESS_REGS);
      pc->MaxParameters      = pc->MaxNativeParameters      =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_CONSTS);

      pc->MaxUniformComponents = 4 * MIN2(pc->MaxNativeParameters, MAX_UNIFORMS);

      pc->MaxUniformBlocks =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_CONST_BUFFERS);
      if (pc->MaxUniformBlocks)
         pc->MaxUniformBlocks -= 1; /* The first one is for ordinary uniforms. */
      pc->MaxUniformBlocks = _min(pc->MaxUniformBlocks, MAX_UNIFORM_BUFFERS);

      pc->MaxCombinedUniformComponents = (pc->MaxUniformComponents +
                                          c->MaxUniformBlockSize / 4 *
                                          pc->MaxUniformBlocks);

      /* Gallium doesn't really care about local vs. env parameters so use the
       * same limits.
       */
      pc->MaxLocalParams = MIN2(pc->MaxParameters, MAX_PROGRAM_LOCAL_PARAMS);
      pc->MaxEnvParams = MIN2(pc->MaxParameters, MAX_PROGRAM_ENV_PARAMS);
d173 1
a173 1
      options->MaxIfDepth = screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_CONTROL_FLOW_DEPTH);
d189 1
a189 6
      if (pc->MaxNativeInstructions &&
          (options->EmitNoIndirectUniform || pc->MaxUniformBlocks < 12)) {
         can_ubo = FALSE;
      }

      if (options->EmitNoLoops)
a190 3
      else
         options->MaxUnrollIterations = 255; /* SM3 limit */
      options->LowerClipDistance = true;
d193 6
a198 12
   /* This depends on program constants. */
   c->MaxTextureCoordUnits
      = _min(c->FragmentProgram.MaxTextureImageUnits, MAX_TEXTURE_COORD_UNITS);

   c->MaxTextureUnits = _min(c->FragmentProgram.MaxTextureImageUnits, c->MaxTextureCoordUnits);

   c->VertexProgram.MaxAttribs = MIN2(c->VertexProgram.MaxAttribs, 16);

   /* PIPE_SHADER_CAP_MAX_INPUTS for the FS specifies the maximum number
    * of inputs. It's always 2 colors + N generic inputs. */
   c->MaxVarying = screen->get_shader_param(screen, PIPE_SHADER_FRAGMENT,
                                            PIPE_SHADER_CAP_MAX_INPUTS);
a199 4
   c->MaxVaryingComponents = c->MaxVarying * 4;

   c->MinProgramTexelOffset = screen->get_param(screen, PIPE_CAP_MIN_TEXEL_OFFSET);
   c->MaxProgramTexelOffset = screen->get_param(screen, PIPE_CAP_MAX_TEXEL_OFFSET);
d201 3
a203 24
   c->UniformBooleanTrue = ~0;

   c->MaxTransformFeedbackBuffers =
      screen->get_param(screen, PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS);
   c->MaxTransformFeedbackBuffers = MIN2(c->MaxTransformFeedbackBuffers, MAX_FEEDBACK_BUFFERS);
   c->MaxTransformFeedbackSeparateComponents =
      screen->get_param(screen, PIPE_CAP_MAX_STREAM_OUTPUT_SEPARATE_COMPONENTS);
   c->MaxTransformFeedbackInterleavedComponents =
      screen->get_param(screen, PIPE_CAP_MAX_STREAM_OUTPUT_INTERLEAVED_COMPONENTS);

   c->StripTextureBorder = GL_TRUE;

   c->GLSLSkipStrictMaxUniformLimitCheck =
      screen->get_param(screen, PIPE_CAP_TGSI_CAN_COMPACT_CONSTANTS);

   if (can_ubo) {
      st->ctx->Extensions.ARB_uniform_buffer_object = GL_TRUE;
      c->UniformBufferOffsetAlignment =
         screen->get_param(screen, PIPE_CAP_CONSTANT_BUFFER_OFFSET_ALIGNMENT);
      c->MaxCombinedUniformBlocks = c->MaxUniformBufferBindings =
         c->VertexProgram.MaxUniformBlocks +
         c->GeometryProgram.MaxUniformBlocks +
         c->FragmentProgram.MaxUniformBlocks;
      assert(c->MaxCombinedUniformBlocks <= MAX_COMBINED_UNIFORM_BUFFERS);
a208 63
 * Given a member \c x of struct gl_extensions, return offset of
 * \c x in bytes.
 */
#define o(x) offsetof(struct gl_extensions, x)


struct st_extension_cap_mapping {
   int extension_offset;
   int cap;
};

struct st_extension_format_mapping {
   int extension_offset[2];
   enum pipe_format format[8];

   /* If TRUE, at least one format must be supported for the extensions to be
    * advertised. If FALSE, all the formats must be supported. */
   GLboolean need_at_least_one;
};

/**
 * Enable extensions if certain pipe formats are supported by the driver.
 * What extensions will be enabled and what formats must be supported is
 * described by the array of st_extension_format_mapping.
 *
 * target and bind_flags are passed to is_format_supported.
 */
static void init_format_extensions(struct st_context *st,
                           const struct st_extension_format_mapping *mapping,
                           unsigned num_mappings,
                           enum pipe_texture_target target,
                           unsigned bind_flags)
{
   struct pipe_screen *screen = st->pipe->screen;
   GLboolean *extensions = (GLboolean *) &st->ctx->Extensions;
   unsigned i;
   int j;
   int num_formats = Elements(mapping->format);
   int num_ext = Elements(mapping->extension_offset);

   for (i = 0; i < num_mappings; i++) {
      int num_supported = 0;

      /* Examine each format in the list. */
      for (j = 0; j < num_formats && mapping[i].format[j]; j++) {
         if (screen->is_format_supported(screen, mapping[i].format[j],
                                         target, 0, bind_flags)) {
            num_supported++;
         }
      }

      if (!num_supported ||
          (!mapping[i].need_at_least_one && num_supported != j)) {
         continue;
      }

      /* Enable all extensions in the list. */
      for (j = 0; j < num_ext && mapping[i].extension_offset[j]; j++)
         extensions[mapping[i].extension_offset[j]] = GL_TRUE;
   }
}

/**
a218 150
   int i, glsl_feature_level;
   GLboolean *extensions = (GLboolean *) &ctx->Extensions;

   static const struct st_extension_cap_mapping cap_mapping[] = {
      { o(ARB_base_instance),                PIPE_CAP_START_INSTANCE                   },
      { o(ARB_depth_clamp),                  PIPE_CAP_DEPTH_CLIP_DISABLE               },
      { o(ARB_depth_texture),                PIPE_CAP_TEXTURE_SHADOW_MAP               },
      { o(ARB_draw_buffers_blend),           PIPE_CAP_INDEP_BLEND_FUNC                 },
      { o(ARB_draw_instanced),               PIPE_CAP_TGSI_INSTANCEID                  },
      { o(ARB_fragment_program_shadow),      PIPE_CAP_TEXTURE_SHADOW_MAP               },
      { o(ARB_instanced_arrays),             PIPE_CAP_VERTEX_ELEMENT_INSTANCE_DIVISOR  },
      { o(ARB_occlusion_query),              PIPE_CAP_OCCLUSION_QUERY                  },
      { o(ARB_occlusion_query2),             PIPE_CAP_OCCLUSION_QUERY                  },
      { o(ARB_point_sprite),                 PIPE_CAP_POINT_SPRITE                     },
      { o(ARB_seamless_cube_map),            PIPE_CAP_SEAMLESS_CUBE_MAP                },
      { o(ARB_shader_stencil_export),        PIPE_CAP_SHADER_STENCIL_EXPORT            },
      { o(ARB_shader_texture_lod),           PIPE_CAP_SM3                              },
      { o(ARB_shadow),                       PIPE_CAP_TEXTURE_SHADOW_MAP               },
      { o(ARB_texture_non_power_of_two),     PIPE_CAP_NPOT_TEXTURES                    },
      { o(ARB_timer_query),                  PIPE_CAP_QUERY_TIMESTAMP                  },
      { o(ARB_transform_feedback2),          PIPE_CAP_STREAM_OUTPUT_PAUSE_RESUME       },
      { o(ARB_transform_feedback3),          PIPE_CAP_STREAM_OUTPUT_PAUSE_RESUME       },

      { o(EXT_blend_equation_separate),      PIPE_CAP_BLEND_EQUATION_SEPARATE          },
      { o(EXT_draw_buffers2),                PIPE_CAP_INDEP_BLEND_ENABLE               },
      { o(EXT_stencil_two_side),             PIPE_CAP_TWO_SIDED_STENCIL                },
      { o(EXT_texture_array),                PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS         },
      { o(EXT_texture_filter_anisotropic),   PIPE_CAP_ANISOTROPIC_FILTER               },
      { o(EXT_texture_mirror_clamp),         PIPE_CAP_TEXTURE_MIRROR_CLAMP             },
      { o(EXT_texture_swizzle),              PIPE_CAP_TEXTURE_SWIZZLE                  },
      { o(EXT_transform_feedback),           PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS        },

      { o(AMD_seamless_cubemap_per_texture), PIPE_CAP_SEAMLESS_CUBE_MAP_PER_TEXTURE    },
      { o(ATI_separate_stencil),             PIPE_CAP_TWO_SIDED_STENCIL                },
      { o(ATI_texture_mirror_once),          PIPE_CAP_TEXTURE_MIRROR_CLAMP             },
      { o(NV_conditional_render),            PIPE_CAP_CONDITIONAL_RENDER               },
      { o(NV_texture_barrier),               PIPE_CAP_TEXTURE_BARRIER                  },
      /* GL_NV_point_sprite is not supported by gallium because we don't
       * support the GL_POINT_SPRITE_R_MODE_NV option. */
      { o(MESA_texture_array),               PIPE_CAP_MAX_TEXTURE_ARRAY_LAYERS         },

      { o(OES_standard_derivatives),         PIPE_CAP_SM3                              },
      { o(ARB_texture_cube_map_array),       PIPE_CAP_CUBE_MAP_ARRAY                   },
      { o(ARB_texture_multisample),          PIPE_CAP_TEXTURE_MULTISAMPLE              }
   };

   /* Required: render target and sampler support */
   static const struct st_extension_format_mapping rendertarget_mapping[] = {
      { { o(ARB_texture_float) },
        { PIPE_FORMAT_R32G32B32A32_FLOAT,
          PIPE_FORMAT_R16G16B16A16_FLOAT } },

      { { o(ARB_texture_rgb10_a2ui) },
        { PIPE_FORMAT_B10G10R10A2_UINT } },

      { { o(EXT_framebuffer_sRGB) },
        { PIPE_FORMAT_A8B8G8R8_SRGB,
          PIPE_FORMAT_B8G8R8A8_SRGB },
         GL_TRUE }, /* at least one format must be supported */

      { { o(EXT_packed_float) },
        { PIPE_FORMAT_R11G11B10_FLOAT } },

      { { o(EXT_texture_integer) },
        { PIPE_FORMAT_R32G32B32A32_UINT,
          PIPE_FORMAT_R32G32B32A32_SINT } },

      { { o(ARB_texture_rg) },
        { PIPE_FORMAT_R8_UNORM,
          PIPE_FORMAT_R8G8_UNORM } },
   };

   /* Required: depth stencil and sampler support */
   static const struct st_extension_format_mapping depthstencil_mapping[] = {
      { { o(ARB_depth_buffer_float) },
        { PIPE_FORMAT_Z32_FLOAT,
          PIPE_FORMAT_Z32_FLOAT_S8X24_UINT } },

      { { o(ARB_framebuffer_object),
          o(EXT_packed_depth_stencil) },
        { PIPE_FORMAT_S8_UINT_Z24_UNORM,
          PIPE_FORMAT_Z24_UNORM_S8_UINT },
        GL_TRUE }, /* at least one format must be supported */
   };

   /* Required: sampler support */
   static const struct st_extension_format_mapping texture_mapping[] = {
      { { o(ARB_texture_compression_rgtc) },
        { PIPE_FORMAT_RGTC1_UNORM,
          PIPE_FORMAT_RGTC1_SNORM,
          PIPE_FORMAT_RGTC2_UNORM,
          PIPE_FORMAT_RGTC2_SNORM } },

      { { o(EXT_texture_compression_latc) },
        { PIPE_FORMAT_LATC1_UNORM,
          PIPE_FORMAT_LATC1_SNORM,
          PIPE_FORMAT_LATC2_UNORM,
          PIPE_FORMAT_LATC2_SNORM } },

      { { o(EXT_texture_compression_s3tc),
          o(ANGLE_texture_compression_dxt) },
        { PIPE_FORMAT_DXT1_RGB,
          PIPE_FORMAT_DXT1_RGBA,
          PIPE_FORMAT_DXT3_RGBA,
          PIPE_FORMAT_DXT5_RGBA } },

      { { o(EXT_texture_shared_exponent) },
        { PIPE_FORMAT_R9G9B9E5_FLOAT } },

      { { o(EXT_texture_snorm) },
        { PIPE_FORMAT_R8G8B8A8_SNORM } },

      { { o(EXT_texture_sRGB),
          o(EXT_texture_sRGB_decode) },
        { PIPE_FORMAT_A8B8G8R8_SRGB,
          PIPE_FORMAT_B8G8R8A8_SRGB },
        GL_TRUE }, /* at least one format must be supported */

      { { o(ATI_texture_compression_3dc) },
        { PIPE_FORMAT_LATC2_UNORM } },

      { { o(MESA_ycbcr_texture) },
        { PIPE_FORMAT_UYVY,
          PIPE_FORMAT_YUYV },
        GL_TRUE }, /* at least one format must be supported */

      { { o(OES_compressed_ETC1_RGB8_texture) },
        { PIPE_FORMAT_ETC1_RGB8 } },
   };

   /* Required: vertex fetch support. */
   static const struct st_extension_format_mapping vertex_mapping[] = {
      { { o(ARB_vertex_type_2_10_10_10_rev) },
        { PIPE_FORMAT_R10G10B10A2_UNORM,
          PIPE_FORMAT_B10G10R10A2_UNORM,
          PIPE_FORMAT_R10G10B10A2_SNORM,
          PIPE_FORMAT_B10G10R10A2_SNORM,
          PIPE_FORMAT_R10G10B10A2_USCALED,
          PIPE_FORMAT_B10G10R10A2_USCALED,
          PIPE_FORMAT_R10G10B10A2_SSCALED,
          PIPE_FORMAT_B10G10R10A2_SSCALED } },
   };

   static const struct st_extension_format_mapping tbo_rgb32[] = {
      { {o(ARB_texture_buffer_object_rgb32) },
        { PIPE_FORMAT_R32G32B32_FLOAT,
          PIPE_FORMAT_R32G32B32_UINT,
          PIPE_FORMAT_R32G32B32_SINT,
        } },
   };
d223 1
a223 1
   ctx->Extensions.ARB_ES2_compatibility = GL_TRUE;
a224 1
   ctx->Extensions.ARB_explicit_attrib_location = GL_TRUE;
a226 4
   ctx->Extensions.ARB_fragment_shader = GL_TRUE;
   ctx->Extensions.ARB_half_float_pixel = GL_TRUE;
   ctx->Extensions.ARB_half_float_vertex = GL_TRUE;
   ctx->Extensions.ARB_internalformat_query = GL_TRUE;
d228 1
d230 1
d235 2
d238 1
a238 1
   ctx->Extensions.ARB_vertex_shader = GL_TRUE;
d242 1
d244 1
d246 3
d250 1
d254 4
a257 8

   /* IMPORTANT:
    *    Don't enable EXT_separate_shader_objects. It disallows a certain
    *    optimization in the GLSL compiler and therefore is considered
    *    harmful.
    */
   ctx->Extensions.EXT_separate_shader_objects = GL_FALSE;

d259 1
d262 2
d268 2
a269 1
   ctx->Extensions.NV_fog_distance = GL_TRUE;
d272 5
d278 1
d280 2
a281 1
   ctx->Extensions.OES_EGL_image_external = GL_TRUE;
d283 3
d287 5
a291 5
   /* Expose the extensions which directly correspond to gallium caps. */
   for (i = 0; i < Elements(cap_mapping); i++) {
      if (screen->get_param(screen, cap_mapping[i].cap)) {
         extensions[cap_mapping[i].extension_offset] = GL_TRUE;
      }
d294 3
a296 39
   /* Expose the extensions which directly correspond to gallium formats. */
   init_format_extensions(st, rendertarget_mapping,
                          Elements(rendertarget_mapping), PIPE_TEXTURE_2D,
                          PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW);
   init_format_extensions(st, depthstencil_mapping,
                          Elements(depthstencil_mapping), PIPE_TEXTURE_2D,
                          PIPE_BIND_DEPTH_STENCIL | PIPE_BIND_SAMPLER_VIEW);
   init_format_extensions(st, texture_mapping, Elements(texture_mapping),
                          PIPE_TEXTURE_2D, PIPE_BIND_SAMPLER_VIEW);
   init_format_extensions(st, vertex_mapping, Elements(vertex_mapping),
                          PIPE_BUFFER, PIPE_BIND_VERTEX_BUFFER);

   /* Figure out GLSL support. */
   glsl_feature_level = screen->get_param(screen, PIPE_CAP_GLSL_FEATURE_LEVEL);

   if (glsl_feature_level >= 140) {
      ctx->Const.GLSLVersion = 140;
   } else if (glsl_feature_level >= 130) {
      ctx->Const.GLSLVersion = 130;
   } else {
      ctx->Const.GLSLVersion = 120;
   }

   _mesa_override_glsl_version(st->ctx);

   if (st->options.force_glsl_version > 0 &&
       st->options.force_glsl_version <= ctx->Const.GLSLVersion) {
      ctx->Const.ForceGLSLVersion = st->options.force_glsl_version;
   }

   if (ctx->Const.GLSLVersion >= 130) {
      ctx->Const.NativeIntegers = GL_TRUE;
      ctx->Const.MaxClipPlanes = 8;

      /* Extensions that either depend on GLSL 1.30 or are a subset thereof. */
      ctx->Extensions.ARB_conservative_depth = GL_TRUE;
      ctx->Extensions.ARB_shading_language_packing = GL_TRUE;
      ctx->Extensions.OES_depth_texture_cube_map = GL_TRUE;
      ctx->Extensions.ARB_shading_language_420pack = GL_TRUE;
d298 7
a304 11
      if (!st->options.disable_shader_bit_encoding) {
         ctx->Extensions.ARB_shader_bit_encoding = GL_TRUE;
      }
   } else {
      /* Optional integer support for GLSL 1.2. */
      if (screen->get_shader_param(screen, PIPE_SHADER_VERTEX,
                                   PIPE_SHADER_CAP_INTEGERS) &&
          screen->get_shader_param(screen, PIPE_SHADER_FRAGMENT,
                                   PIPE_SHADER_CAP_INTEGERS)) {
         ctx->Const.NativeIntegers = GL_TRUE;
      }
d307 3
a309 1
   /* Below are the cases which cannot be moved into tables easily. */
d311 2
a312 3
   if (!ctx->Mesa_DXTn && !st->options.force_s3tc_enable) {
      ctx->Extensions.EXT_texture_compression_s3tc = GL_FALSE;
      ctx->Extensions.ANGLE_texture_compression_dxt = GL_FALSE;
d315 3
a317 5
   if (screen->get_shader_param(screen, PIPE_SHADER_GEOMETRY,
                                PIPE_SHADER_CAP_MAX_INSTRUCTIONS) > 0) {
#if 0 /* XXX re-enable when GLSL compiler again supports geometry shaders */
      ctx->Extensions.ARB_geometry_shader4 = GL_TRUE;
#endif
d320 2
a321 3
   ctx->Extensions.NV_primitive_restart = GL_TRUE;
   if (!screen->get_param(screen, PIPE_CAP_PRIMITIVE_RESTART)) {
      ctx->Const.PrimitiveRestartInSoftware = GL_TRUE;
d324 3
a326 3
   /* ARB_color_buffer_float. */
   if (screen->get_param(screen, PIPE_CAP_VERTEX_COLOR_UNCLAMPED)) {
      ctx->Extensions.ARB_color_buffer_float = GL_TRUE;
d328 4
a331 3
      if (!screen->get_param(screen, PIPE_CAP_VERTEX_COLOR_CLAMPED)) {
         st->clamp_vert_color_in_shader = TRUE;
      }
d333 2
a334 13
      if (!screen->get_param(screen, PIPE_CAP_FRAGMENT_COLOR_CLAMPED)) {
         st->clamp_frag_color_in_shader = TRUE;
      }

      /* For drivers which cannot do color clamping, it's better to just
       * disable ARB_color_buffer_float in the core profile, because
       * the clamping is deprecated there anyway. */
      if (ctx->API == API_OPENGL_CORE &&
          (st->clamp_frag_color_in_shader || st->clamp_vert_color_in_shader)) {
         st->clamp_vert_color_in_shader = GL_FALSE;
         st->clamp_frag_color_in_shader = GL_FALSE;
         ctx->Extensions.ARB_color_buffer_float = GL_FALSE;
      }
d337 5
a341 2
   if (screen->fence_finish) {
      ctx->Extensions.ARB_sync = GL_TRUE;
d344 2
a345 11
   /* Maximum sample count. */
   for (i = 16; i > 0; --i) {
      enum pipe_format pformat = st_choose_format(st, GL_RGBA,
                                                  GL_NONE, GL_NONE,
                                                  PIPE_TEXTURE_2D, i,
                                                  PIPE_BIND_RENDER_TARGET, FALSE);
      if (pformat != PIPE_FORMAT_NONE) {
         ctx->Const.MaxSamples = i;
         ctx->Const.MaxColorTextureSamples = i;
         break;
      }
d347 2
a348 9
   for (i = ctx->Const.MaxSamples; i > 0; --i) {
      enum pipe_format pformat = st_choose_format(st, GL_DEPTH_STENCIL,
                                                  GL_NONE, GL_NONE,
                                                  PIPE_TEXTURE_2D, i,
                                                  PIPE_BIND_DEPTH_STENCIL, FALSE);
      if (pformat != PIPE_FORMAT_NONE) {
         ctx->Const.MaxDepthTextureSamples = i;
         break;
      }
d350 7
a356 16
   for (i = ctx->Const.MaxSamples; i > 0; --i) {
      enum pipe_format pformat = st_choose_format(st, GL_RGBA_INTEGER,
                                                  GL_NONE, GL_NONE,
                                                  PIPE_TEXTURE_2D, i,
                                                  PIPE_BIND_RENDER_TARGET, FALSE);
      if (pformat != PIPE_FORMAT_NONE) {
         ctx->Const.MaxIntegerSamples = i;
         break;
      }
   }
   if (ctx->Const.MaxSamples == 1) {
      /* one sample doesn't really make sense */
      ctx->Const.MaxSamples = 0;
   }
   else if (ctx->Const.MaxSamples >= 2) {
      ctx->Extensions.EXT_framebuffer_multisample = GL_TRUE;
d359 82
a440 10
   if (ctx->Const.MaxDualSourceDrawBuffers > 0 &&
       !st->options.disable_blend_func_extended)
      ctx->Extensions.ARB_blend_func_extended = GL_TRUE;

   st->has_time_elapsed =
      screen->get_param(screen, PIPE_CAP_QUERY_TIME_ELAPSED);

   if (st->has_time_elapsed ||
       ctx->Extensions.ARB_timer_query) {
      ctx->Extensions.EXT_timer_query = GL_TRUE;
d442 1
d444 4
a447 3
   if (ctx->Extensions.ARB_transform_feedback2 &&
       ctx->Extensions.ARB_draw_instanced) {
      ctx->Extensions.ARB_transform_feedback_instanced = GL_TRUE;
a448 5
   if (st->options.force_glsl_extensions_warn)
      ctx->Const.ForceGLSLExtensionsWarn = 1;

   if (st->options.disable_glsl_line_continuations)
      ctx->Const.DisableGLSLLineContinuations = 1;
d450 2
a451 4
   ctx->Const.MinMapBufferAlignment =
      screen->get_param(screen, PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT);
   if (ctx->Const.MinMapBufferAlignment >= 64) {
      ctx->Extensions.ARB_map_buffer_alignment = GL_TRUE;
a452 2
   if (screen->get_param(screen, PIPE_CAP_TEXTURE_BUFFER_OBJECTS)) {
      ctx->Extensions.ARB_texture_buffer_object = GL_TRUE;
d454 2
a455 11
      ctx->Const.MaxTextureBufferSize =
         _min(screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_BUFFER_SIZE),
              (1u << 31) - 1);
      ctx->Const.TextureBufferOffsetAlignment =
         screen->get_param(screen, PIPE_CAP_TEXTURE_BUFFER_OFFSET_ALIGNMENT);

      if (ctx->Const.TextureBufferOffsetAlignment)
         ctx->Extensions.ARB_texture_buffer_range = GL_TRUE;

      init_format_extensions(st, tbo_rgb32, Elements(tbo_rgb32),
                             PIPE_BUFFER, PIPE_BIND_SAMPLER_VIEW);
d458 2
a459 13

   /* Unpacking a varying in the fragment shader costs 1 texture indirection.
    * If the number of available texture indirections is very limited, then we
    * prefer to disable varying packing rather than run the risk of varying
    * packing preventing a shader from running.
    */
   if (screen->get_shader_param(screen, PIPE_SHADER_FRAGMENT,
                                PIPE_SHADER_CAP_MAX_TEX_INDIRECTIONS) <= 8) {
      /* We can't disable varying packing if transform feedback is available,
       * because transform feedback code assumes a packed varying layout.
       */
      if (!ctx->Extensions.EXT_transform_feedback)
         ctx->Const.DisableVaryingPacking = GL_TRUE;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d22 1
a22 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a41 6

/*
 * Note: we use these function rather than the MIN2, MAX2, CLAMP macros to
 * avoid evaluating arguments (which are often function calls) more than once.
 */

d92 4
d158 1
a158 1
         pc = &c->Program[MESA_SHADER_FRAGMENT];
d162 1
a162 1
         pc = &c->Program[MESA_SHADER_VERTEX];
d166 1
a166 1
         pc = &c->Program[MESA_SHADER_GEOMETRY];
a245 6
   c->MaxCombinedTextureImageUnits =
         _min(c->Program[MESA_SHADER_VERTEX].MaxTextureImageUnits +
              c->Program[MESA_SHADER_GEOMETRY].MaxTextureImageUnits +
              c->Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits,
              MAX_COMBINED_TEXTURE_IMAGE_UNITS);

d248 1
a248 1
      = _min(c->Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits, MAX_TEXTURE_COORD_UNITS);
d250 1
a250 1
   c->MaxTextureUnits = _min(c->Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits, c->MaxTextureCoordUnits);
d252 1
a252 1
   c->Program[MESA_SHADER_VERTEX].MaxAttribs = MIN2(c->Program[MESA_SHADER_VERTEX].MaxAttribs, 16);
d259 1
a259 6
   c->Program[MESA_SHADER_FRAGMENT].MaxInputComponents = c->MaxVarying * 4;
   c->Program[MESA_SHADER_VERTEX].MaxOutputComponents = c->MaxVarying * 4;
   c->Program[MESA_SHADER_GEOMETRY].MaxInputComponents = c->MaxVarying * 4;
   c->Program[MESA_SHADER_GEOMETRY].MaxOutputComponents = c->MaxVarying * 4;
   c->MaxGeometryOutputVertices = screen->get_param(screen, PIPE_CAP_MAX_GEOMETRY_OUTPUT_VERTICES);
   c->MaxGeometryTotalOutputComponents = screen->get_param(screen, PIPE_CAP_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS);
a263 4
   c->MaxProgramTextureGatherComponents = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_GATHER_COMPONENTS);
   c->MinProgramTextureGatherOffset = screen->get_param(screen, PIPE_CAP_MIN_TEXTURE_GATHER_OFFSET);
   c->MaxProgramTextureGatherOffset = screen->get_param(screen, PIPE_CAP_MAX_TEXTURE_GATHER_OFFSET);

d284 3
a286 3
         c->Program[MESA_SHADER_VERTEX].MaxUniformBlocks +
         c->Program[MESA_SHADER_GEOMETRY].MaxUniformBlocks +
         c->Program[MESA_SHADER_FRAGMENT].MaxUniformBlocks;
a370 1
      { o(ARB_buffer_storage),               PIPE_CAP_BUFFER_MAP_PERSISTENT_COHERENT },
a383 1
      { o(ARB_texture_mirror_clamp_to_edge), PIPE_CAP_TEXTURE_MIRROR_CLAMP             },
d405 1
d409 1
a409 3
      { o(ARB_texture_multisample),          PIPE_CAP_TEXTURE_MULTISAMPLE              },
      { o(ARB_texture_query_lod),            PIPE_CAP_TEXTURE_QUERY_LOD                },
      { o(ARB_sample_shading),               PIPE_CAP_SAMPLE_SHADING                   },
d419 1
a419 3
        { PIPE_FORMAT_R10G10B10A2_UINT,
          PIPE_FORMAT_B10G10R10A2_UINT },
         GL_TRUE }, /* at least one format must be supported */
d443 6
a506 2
      { { o(ARB_vertex_type_10f_11f_11f_rev) },
        { PIPE_FORMAT_R11G11B10_FLOAT } },
d526 1
d541 1
d547 7
a563 1
   ctx->Extensions.NV_vdpau_interop = GL_TRUE;
d591 7
a597 3
   ctx->Const.GLSLVersion = glsl_feature_level;
   if (glsl_feature_level >= 330)
      ctx->Const.GLSLVersion = 330;
a605 7
   /* This extension needs full OpenGL 3.2, but we don't know if that's
    * supported at this point. Only check the GLSL version. */
   if (ctx->Const.GLSLVersion >= 150 &&
       screen->get_param(screen, PIPE_CAP_TGSI_VS_LAYER)) {
      ctx->Extensions.AMD_vertex_shader_layer = GL_TRUE;
   }

a618 2

      ctx->Extensions.EXT_shader_integer_mix = GL_TRUE;
a625 2

         ctx->Extensions.EXT_shader_integer_mix = GL_TRUE;
a712 8
      ctx->Extensions.EXT_framebuffer_multisample_blit_scaled = GL_TRUE;
   }

   if (ctx->Const.MaxSamples == 0 && screen->get_param(screen, PIPE_CAP_FAKE_SW_MSAA)) {
	ctx->Const.FakeSWMSAA = GL_TRUE;
        ctx->Extensions.EXT_framebuffer_multisample = GL_TRUE;
        ctx->Extensions.EXT_framebuffer_multisample_blit_scaled = GL_TRUE;
        ctx->Extensions.ARB_texture_multisample = GL_TRUE;
d739 3
a741 1

a757 3
   if (screen->get_param(screen, PIPE_CAP_MIXED_FRAMEBUFFER_SIZES)) {
      ctx->Extensions.ARB_framebuffer_object = GL_TRUE;
   }
a771 11

   if (ctx->API == API_OPENGL_CORE) {
      ctx->Const.MaxViewports = screen->get_param(screen, PIPE_CAP_MAX_VIEWPORTS);
      if (ctx->Const.MaxViewports >= 16) {
         ctx->Const.ViewportBounds.Min = -16384.0;
         ctx->Const.ViewportBounds.Max = 16384.0;
         ctx->Extensions.ARB_viewport_array = GL_TRUE;
      }
   }
   if (ctx->Const.MaxProgramTextureGatherComponents > 0)
      ctx->Extensions.ARB_texture_gather = GL_TRUE;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a36 1
#include "util/u_math.h"
d73 1
a73 2
void st_init_limits(struct pipe_screen *screen,
                    struct gl_constants *c, struct gl_extensions *extensions)
d75 2
d127 4
a130 1

d149 1
a149 1
                               PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE);
d161 1
a161 1
         options = &c->ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
d165 1
a165 1
         options = &c->ShaderCompilerOptions[MESA_SHADER_VERTEX];
d169 1
a169 1
         options = &c->ShaderCompilerOptions[MESA_SHADER_GEOMETRY];
d194 2
a195 1
         sh == PIPE_SHADER_VERTEX ? 1 : 0;
d197 1
a197 6
         screen->get_shader_param(screen, sh,
                   PIPE_SHADER_CAP_MAX_CONST_BUFFER_SIZE) / sizeof(float[4]);
      pc->MaxInputComponents =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_INPUTS) * 4;
      pc->MaxOutputComponents =
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_OUTPUTS) * 4;
d243 2
a244 1

d267 4
d281 2
a289 8
   c->MaxVertexStreams =
      MAX2(1, screen->get_param(screen, PIPE_CAP_MAX_VERTEX_STREAMS));

   /* The vertex stream must fit into pipe_stream_output_info::stream */
   assert(c->MaxVertexStreams <= 4);

   c->MaxVertexAttribStride
      = screen->get_param(screen, PIPE_CAP_MAX_VERTEX_ATTRIB_STRIDE);
d297 1
a297 1
      extensions->ARB_uniform_buffer_object = GL_TRUE;
d337 5
a341 7
static void
init_format_extensions(struct pipe_screen *screen,
                       struct gl_extensions *extensions,
                       const struct st_extension_format_mapping *mapping,
                       unsigned num_mappings,
                       enum pipe_texture_target target,
                       unsigned bind_flags)
d343 2
a344 1
   GLboolean *extension_table = (GLboolean *) extensions;
d368 1
a368 1
         extension_table[mapping[i].extension_offset[j]] = GL_TRUE;
a371 26

/**
 * Given a list of formats and bind flags, return the maximum number
 * of samples supported by any of those formats.
 */
static unsigned
get_max_samples_for_formats(struct pipe_screen *screen,
                            unsigned num_formats,
                            enum pipe_format *formats,
                            unsigned max_samples,
                            unsigned bind)
{
   unsigned i, f;

   for (i = max_samples; i > 0; --i) {
      for (f = 0; f < num_formats; f++) {
         if (screen->is_format_supported(screen, formats[f],
                                         PIPE_TEXTURE_2D, i, bind)) {
            return i;
         }
      }
   }
   return 0;
}


d379 1
a379 5
void st_init_extensions(struct pipe_screen *screen,
                        struct gl_constants *consts,
                        struct gl_extensions *extensions,
                        struct st_config_options *options,
                        boolean has_lib_dxtc)
d381 2
d384 1
a384 1
   GLboolean *extension_table = (GLboolean *) extensions;
a429 5
      { o(ARB_draw_indirect),                PIPE_CAP_DRAW_INDIRECT                    },
      { o(ARB_derivative_control),           PIPE_CAP_TGSI_FS_FINE_DERIVATIVE          },
      { o(ARB_conditional_render_inverted),  PIPE_CAP_CONDITIONAL_RENDER_INVERTED      },
      { o(ARB_texture_view),                 PIPE_CAP_SAMPLER_VIEW_TARGET              },
      { o(ARB_clip_control),                 PIPE_CAP_CLIP_HALFZ                       },
a487 6
      { { o(ARB_texture_compression_bptc) },
        { PIPE_FORMAT_BPTC_RGBA_UNORM,
          PIPE_FORMAT_BPTC_SRGBA,
          PIPE_FORMAT_BPTC_RGB_FLOAT,
          PIPE_FORMAT_BPTC_RGB_UFLOAT } },

d509 1
a509 8
        { PIPE_FORMAT_ETC1_RGB8,
          PIPE_FORMAT_R8G8B8A8_UNORM },
        GL_TRUE }, /* at least one format must be supported */

      { { o(ARB_stencil_texturing) },
        { PIPE_FORMAT_X24S8_UINT,
          PIPE_FORMAT_S8X24_UINT },
        GL_TRUE }, /* at least one format must be supported */
d538 40
a577 40
   extensions->ARB_ES2_compatibility = GL_TRUE;
   extensions->ARB_draw_elements_base_vertex = GL_TRUE;
   extensions->ARB_explicit_attrib_location = GL_TRUE;
   extensions->ARB_explicit_uniform_location = GL_TRUE;
   extensions->ARB_fragment_coord_conventions = GL_TRUE;
   extensions->ARB_fragment_program = GL_TRUE;
   extensions->ARB_fragment_shader = GL_TRUE;
   extensions->ARB_half_float_vertex = GL_TRUE;
   extensions->ARB_internalformat_query = GL_TRUE;
   extensions->ARB_map_buffer_range = GL_TRUE;
   extensions->ARB_texture_border_clamp = GL_TRUE; /* XXX temp */
   extensions->ARB_texture_cube_map = GL_TRUE;
   extensions->ARB_texture_env_combine = GL_TRUE;
   extensions->ARB_texture_env_crossbar = GL_TRUE;
   extensions->ARB_texture_env_dot3 = GL_TRUE;
   extensions->ARB_vertex_program = GL_TRUE;
   extensions->ARB_vertex_shader = GL_TRUE;

   extensions->EXT_blend_color = GL_TRUE;
   extensions->EXT_blend_func_separate = GL_TRUE;
   extensions->EXT_blend_minmax = GL_TRUE;
   extensions->EXT_gpu_program_parameters = GL_TRUE;
   extensions->EXT_pixel_buffer_object = GL_TRUE;
   extensions->EXT_point_parameters = GL_TRUE;
   extensions->EXT_provoking_vertex = GL_TRUE;

   extensions->EXT_texture_env_dot3 = GL_TRUE;
   extensions->EXT_vertex_array_bgra = GL_TRUE;

   extensions->ATI_texture_env_combine3 = GL_TRUE;

   extensions->MESA_pack_invert = GL_TRUE;

   extensions->NV_fog_distance = GL_TRUE;
   extensions->NV_texture_env_combine4 = GL_TRUE;
   extensions->NV_texture_rectangle = GL_TRUE;

   extensions->OES_EGL_image = GL_TRUE;
   extensions->OES_EGL_image_external = GL_TRUE;
   extensions->OES_draw_texture = GL_TRUE;
d582 1
a582 1
         extension_table[cap_mapping[i].extension_offset] = GL_TRUE;
d587 1
a587 1
   init_format_extensions(screen, extensions, rendertarget_mapping,
d590 1
a590 1
   init_format_extensions(screen, extensions, depthstencil_mapping,
d593 4
a596 6
   init_format_extensions(screen, extensions, texture_mapping,
                          Elements(texture_mapping), PIPE_TEXTURE_2D,
                          PIPE_BIND_SAMPLER_VIEW);
   init_format_extensions(screen, extensions, vertex_mapping,
                          Elements(vertex_mapping), PIPE_BUFFER,
                          PIPE_BIND_VERTEX_BUFFER);
d601 1
a601 1
   consts->GLSLVersion = glsl_feature_level;
d603 1
a603 1
      consts->GLSLVersion = 330;
d605 1
a605 1
   _mesa_override_glsl_version(consts);
d607 3
a609 3
   if (options->force_glsl_version > 0 &&
       options->force_glsl_version <= consts->GLSLVersion) {
      consts->ForceGLSLVersion = options->force_glsl_version;
a611 3
   if (glsl_feature_level >= 400)
      extensions->ARB_gpu_shader5 = GL_TRUE;

d614 3
a616 3
   if (consts->GLSLVersion >= 150 &&
       screen->get_param(screen, PIPE_CAP_TGSI_VS_LAYER_VIEWPORT)) {
      extensions->AMD_vertex_shader_layer = GL_TRUE;
d619 3
a621 3
   if (consts->GLSLVersion >= 130) {
      consts->NativeIntegers = GL_TRUE;
      consts->MaxClipPlanes = 8;
d624 4
a627 5
      extensions->ARB_conservative_depth = GL_TRUE;
      extensions->ARB_shading_language_packing = GL_TRUE;
      extensions->OES_depth_texture_cube_map = GL_TRUE;
      extensions->ARB_shading_language_420pack = GL_TRUE;
      extensions->ARB_texture_query_levels = GL_TRUE;
d629 2
a630 2
      if (!options->disable_shader_bit_encoding) {
         extensions->ARB_shader_bit_encoding = GL_TRUE;
d633 1
a633 1
      extensions->EXT_shader_integer_mix = GL_TRUE;
d640 1
a640 1
         consts->NativeIntegers = GL_TRUE;
d642 1
a642 1
         extensions->EXT_shader_integer_mix = GL_TRUE;
a645 2
   consts->UniformBooleanTrue = consts->NativeIntegers ? ~0 : fui(1.0f);

d648 3
a650 3
   if (!has_lib_dxtc && !options->force_s3tc_enable) {
      extensions->EXT_texture_compression_s3tc = GL_FALSE;
      extensions->ANGLE_texture_compression_dxt = GL_FALSE;
d656 1
a656 1
      extensions->ARB_geometry_shader4 = GL_TRUE;
d660 3
a662 2
   if (screen->get_param(screen, PIPE_CAP_PRIMITIVE_RESTART)) {
      extensions->NV_primitive_restart = GL_TRUE;
d667 19
a685 1
      extensions->ARB_color_buffer_float = GL_TRUE;
d689 1
a689 1
      extensions->ARB_sync = GL_TRUE;
d693 10
a702 37
   {
      enum pipe_format color_formats[] = {
         PIPE_FORMAT_R8G8B8A8_UNORM,
         PIPE_FORMAT_B8G8R8A8_UNORM,
         PIPE_FORMAT_A8R8G8B8_UNORM,
         PIPE_FORMAT_A8B8G8R8_UNORM,
      };
      enum pipe_format depth_formats[] = {
         PIPE_FORMAT_Z16_UNORM,
         PIPE_FORMAT_Z24X8_UNORM,
         PIPE_FORMAT_X8Z24_UNORM,
         PIPE_FORMAT_Z32_UNORM,
         PIPE_FORMAT_Z32_FLOAT
      };
      enum pipe_format int_formats[] = {
         PIPE_FORMAT_R8G8B8A8_SINT
      };

      consts->MaxSamples =
         get_max_samples_for_formats(screen, Elements(color_formats),
                                     color_formats, 16,
                                     PIPE_BIND_RENDER_TARGET);

      consts->MaxColorTextureSamples =
         get_max_samples_for_formats(screen, Elements(color_formats),
                                     color_formats, consts->MaxSamples,
                                     PIPE_BIND_SAMPLER_VIEW);

      consts->MaxDepthTextureSamples =
         get_max_samples_for_formats(screen, Elements(depth_formats),
                                     depth_formats, consts->MaxSamples,
                                     PIPE_BIND_SAMPLER_VIEW);

      consts->MaxIntegerSamples =
         get_max_samples_for_formats(screen, Elements(int_formats),
                                     int_formats, consts->MaxSamples,
                                     PIPE_BIND_SAMPLER_VIEW);
d704 21
a724 1
   if (consts->MaxSamples == 1) {
d726 1
a726 1
      consts->MaxSamples = 0;
d728 3
a730 3
   else if (consts->MaxSamples >= 2) {
      extensions->EXT_framebuffer_multisample = GL_TRUE;
      extensions->EXT_framebuffer_multisample_blit_scaled = GL_TRUE;
d733 5
a737 5
   if (consts->MaxSamples == 0 && screen->get_param(screen, PIPE_CAP_FAKE_SW_MSAA)) {
	consts->FakeSWMSAA = GL_TRUE;
        extensions->EXT_framebuffer_multisample = GL_TRUE;
        extensions->EXT_framebuffer_multisample_blit_scaled = GL_TRUE;
        extensions->ARB_texture_multisample = GL_TRUE;
d740 6
a745 3
   if (consts->MaxDualSourceDrawBuffers > 0 &&
       !options->disable_blend_func_extended)
      extensions->ARB_blend_func_extended = GL_TRUE;
d747 3
a749 3
   if (screen->get_param(screen, PIPE_CAP_QUERY_TIME_ELAPSED) ||
       extensions->ARB_timer_query) {
      extensions->EXT_timer_query = GL_TRUE;
d752 3
a754 3
   if (extensions->ARB_transform_feedback2 &&
       extensions->ARB_draw_instanced) {
      extensions->ARB_transform_feedback_instanced = GL_TRUE;
d756 2
a757 5
   if (options->force_glsl_extensions_warn)
      consts->ForceGLSLExtensionsWarn = 1;

   if (options->disable_glsl_line_continuations)
      consts->DisableGLSLLineContinuations = 1;
d759 2
a760 2
   if (options->allow_glsl_extension_directive_midshader)
      consts->AllowGLSLExtensionDirectiveMidShader = GL_TRUE;
d762 1
a762 1
   consts->MinMapBufferAlignment =
d766 1
a766 1
      extensions->ARB_texture_buffer_object = GL_TRUE;
d768 1
a768 1
      consts->MaxTextureBufferSize =
d771 1
a771 1
      consts->TextureBufferOffsetAlignment =
d774 2
a775 2
      if (consts->TextureBufferOffsetAlignment)
         extensions->ARB_texture_buffer_range = GL_TRUE;
d777 2
a778 3
      init_format_extensions(screen, extensions, tbo_rgb32,
                             Elements(tbo_rgb32), PIPE_BUFFER,
                             PIPE_BIND_SAMPLER_VIEW);
d782 1
a782 1
      extensions->ARB_framebuffer_object = GL_TRUE;
d795 2
a796 2
      if (!extensions->EXT_transform_feedback)
         consts->DisableVaryingPacking = GL_TRUE;
d799 7
a805 46
   consts->MaxViewports = screen->get_param(screen, PIPE_CAP_MAX_VIEWPORTS);
   if (consts->MaxViewports >= 16) {
      consts->ViewportBounds.Min = -16384.0;
      consts->ViewportBounds.Max = 16384.0;
      extensions->ARB_viewport_array = GL_TRUE;
      extensions->ARB_fragment_layer_viewport = GL_TRUE;
      if (extensions->AMD_vertex_shader_layer)
         extensions->AMD_vertex_shader_viewport_index = GL_TRUE;
   }

   if (consts->MaxProgramTextureGatherComponents > 0)
      extensions->ARB_texture_gather = GL_TRUE;

   /* GL_ARB_ES3_compatibility.
    *
    * Assume that ES3 is supported if GLSL 3.30 is supported.
    * (OpenGL 3.3 is a requirement for that extension.)
    */
   if (consts->GLSLVersion >= 330 &&
       /* Requirements for ETC2 emulation. */
       screen->is_format_supported(screen, PIPE_FORMAT_R8G8B8A8_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_B8G8R8A8_SRGB,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_R16_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_R16G16_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_R16_SNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW) &&
       screen->is_format_supported(screen, PIPE_FORMAT_R16G16_SNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW)) {
      extensions->ARB_ES3_compatibility = GL_TRUE;
   }

   if (screen->get_video_param &&
       screen->get_video_param(screen, PIPE_VIDEO_PROFILE_UNKNOWN,
                               PIPE_VIDEO_ENTRYPOINT_BITSTREAM,
                               PIPE_VIDEO_CAP_SUPPORTS_INTERLACED)) {
      extensions->NV_vdpau_interop = GL_TRUE;
d807 2
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d74 2
a75 1
void st_init_limits(struct st_context *st)
a76 2
   struct pipe_screen *screen = st->pipe->screen;
   struct gl_constants *c = &st->ctx->Const;
d127 1
a127 4
   /* called after _mesa_create_context/_mesa_init_point, fix default user
    * settable max point size up
    */
   st->ctx->Point.MaxSize = MAX2(c->MaxPointSize, c->MaxPointSizeAA);
d146 1
a146 1
                               PIPE_SHADER_CAP_MAX_CONSTS) * 16;
d158 1
a158 1
         options = &st->ctx->ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
d162 1
a162 1
         options = &st->ctx->ShaderCompilerOptions[MESA_SHADER_VERTEX];
d166 1
a166 1
         options = &st->ctx->ShaderCompilerOptions[MESA_SHADER_GEOMETRY];
d191 1
a191 2
         _min(screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_ADDRS),
              MAX_PROGRAM_ADDRESS_REGS);
d193 6
a198 1
         screen->get_shader_param(screen, sh, PIPE_SHADER_CAP_MAX_CONSTS);
d244 1
a244 2
      else
         options->MaxUnrollIterations = 255; /* SM3 limit */
a266 4
   c->Program[MESA_SHADER_FRAGMENT].MaxInputComponents = c->MaxVarying * 4;
   c->Program[MESA_SHADER_VERTEX].MaxOutputComponents = c->MaxVarying * 4;
   c->Program[MESA_SHADER_GEOMETRY].MaxInputComponents = c->MaxVarying * 4;
   c->Program[MESA_SHADER_GEOMETRY].MaxOutputComponents = c->MaxVarying * 4;
d284 8
d299 1
a299 1
      st->ctx->Extensions.ARB_uniform_buffer_object = GL_TRUE;
d339 7
a345 5
static void init_format_extensions(struct st_context *st,
                           const struct st_extension_format_mapping *mapping,
                           unsigned num_mappings,
                           enum pipe_texture_target target,
                           unsigned bind_flags)
d347 1
a347 2
   struct pipe_screen *screen = st->pipe->screen;
   GLboolean *extensions = (GLboolean *) &st->ctx->Extensions;
d371 25
a395 1
         extensions[mapping[i].extension_offset[j]] = GL_TRUE;
d397 1
d400 1
d408 5
a412 1
void st_init_extensions(struct st_context *st)
a413 2
   struct pipe_screen *screen = st->pipe->screen;
   struct gl_context *ctx = st->ctx;
d415 1
a415 1
   GLboolean *extensions = (GLboolean *) &ctx->Extensions;
d461 5
d524 6
d551 8
a558 1
        { PIPE_FORMAT_ETC1_RGB8 } },
d587 40
a626 40
   ctx->Extensions.ARB_ES2_compatibility = GL_TRUE;
   ctx->Extensions.ARB_draw_elements_base_vertex = GL_TRUE;
   ctx->Extensions.ARB_explicit_attrib_location = GL_TRUE;
   ctx->Extensions.ARB_fragment_coord_conventions = GL_TRUE;
   ctx->Extensions.ARB_fragment_program = GL_TRUE;
   ctx->Extensions.ARB_fragment_shader = GL_TRUE;
   ctx->Extensions.ARB_half_float_vertex = GL_TRUE;
   ctx->Extensions.ARB_internalformat_query = GL_TRUE;
   ctx->Extensions.ARB_map_buffer_range = GL_TRUE;
   ctx->Extensions.ARB_texture_border_clamp = GL_TRUE; /* XXX temp */
   ctx->Extensions.ARB_texture_cube_map = GL_TRUE;
   ctx->Extensions.ARB_texture_env_combine = GL_TRUE;
   ctx->Extensions.ARB_texture_env_crossbar = GL_TRUE;
   ctx->Extensions.ARB_texture_env_dot3 = GL_TRUE;
   ctx->Extensions.ARB_vertex_program = GL_TRUE;
   ctx->Extensions.ARB_vertex_shader = GL_TRUE;

   ctx->Extensions.EXT_blend_color = GL_TRUE;
   ctx->Extensions.EXT_blend_func_separate = GL_TRUE;
   ctx->Extensions.EXT_blend_minmax = GL_TRUE;
   ctx->Extensions.EXT_gpu_program_parameters = GL_TRUE;
   ctx->Extensions.EXT_pixel_buffer_object = GL_TRUE;
   ctx->Extensions.EXT_point_parameters = GL_TRUE;
   ctx->Extensions.EXT_provoking_vertex = GL_TRUE;

   ctx->Extensions.EXT_texture_env_dot3 = GL_TRUE;
   ctx->Extensions.EXT_vertex_array_bgra = GL_TRUE;

   ctx->Extensions.ATI_texture_env_combine3 = GL_TRUE;

   ctx->Extensions.MESA_pack_invert = GL_TRUE;

   ctx->Extensions.NV_fog_distance = GL_TRUE;
   ctx->Extensions.NV_texture_env_combine4 = GL_TRUE;
   ctx->Extensions.NV_texture_rectangle = GL_TRUE;
   ctx->Extensions.NV_vdpau_interop = GL_TRUE;

   ctx->Extensions.OES_EGL_image = GL_TRUE;
   ctx->Extensions.OES_EGL_image_external = GL_TRUE;
   ctx->Extensions.OES_draw_texture = GL_TRUE;
d631 1
a631 1
         extensions[cap_mapping[i].extension_offset] = GL_TRUE;
d636 1
a636 1
   init_format_extensions(st, rendertarget_mapping,
d639 1
a639 1
   init_format_extensions(st, depthstencil_mapping,
d642 6
a647 4
   init_format_extensions(st, texture_mapping, Elements(texture_mapping),
                          PIPE_TEXTURE_2D, PIPE_BIND_SAMPLER_VIEW);
   init_format_extensions(st, vertex_mapping, Elements(vertex_mapping),
                          PIPE_BUFFER, PIPE_BIND_VERTEX_BUFFER);
d652 1
a652 1
   ctx->Const.GLSLVersion = glsl_feature_level;
d654 1
a654 1
      ctx->Const.GLSLVersion = 330;
d656 1
a656 1
   _mesa_override_glsl_version(st->ctx);
d658 3
a660 3
   if (st->options.force_glsl_version > 0 &&
       st->options.force_glsl_version <= ctx->Const.GLSLVersion) {
      ctx->Const.ForceGLSLVersion = st->options.force_glsl_version;
d663 3
d668 3
a670 3
   if (ctx->Const.GLSLVersion >= 150 &&
       screen->get_param(screen, PIPE_CAP_TGSI_VS_LAYER)) {
      ctx->Extensions.AMD_vertex_shader_layer = GL_TRUE;
d673 3
a675 3
   if (ctx->Const.GLSLVersion >= 130) {
      ctx->Const.NativeIntegers = GL_TRUE;
      ctx->Const.MaxClipPlanes = 8;
d678 5
a682 4
      ctx->Extensions.ARB_conservative_depth = GL_TRUE;
      ctx->Extensions.ARB_shading_language_packing = GL_TRUE;
      ctx->Extensions.OES_depth_texture_cube_map = GL_TRUE;
      ctx->Extensions.ARB_shading_language_420pack = GL_TRUE;
d684 2
a685 2
      if (!st->options.disable_shader_bit_encoding) {
         ctx->Extensions.ARB_shader_bit_encoding = GL_TRUE;
d688 1
a688 1
      ctx->Extensions.EXT_shader_integer_mix = GL_TRUE;
d695 1
a695 1
         ctx->Const.NativeIntegers = GL_TRUE;
d697 1
a697 1
         ctx->Extensions.EXT_shader_integer_mix = GL_TRUE;
d701 1
a701 1
   ctx->Const.UniformBooleanTrue = ctx->Const.NativeIntegers ? ~0 : fui(1.0f);
d705 3
a707 3
   if (!ctx->Mesa_DXTn && !st->options.force_s3tc_enable) {
      ctx->Extensions.EXT_texture_compression_s3tc = GL_FALSE;
      ctx->Extensions.ANGLE_texture_compression_dxt = GL_FALSE;
d713 1
a713 1
      ctx->Extensions.ARB_geometry_shader4 = GL_TRUE;
d717 2
a718 3
   ctx->Extensions.NV_primitive_restart = GL_TRUE;
   if (!screen->get_param(screen, PIPE_CAP_PRIMITIVE_RESTART)) {
      ctx->Const.PrimitiveRestartInSoftware = GL_TRUE;
d723 1
a723 19
      ctx->Extensions.ARB_color_buffer_float = GL_TRUE;

      if (!screen->get_param(screen, PIPE_CAP_VERTEX_COLOR_CLAMPED)) {
         st->clamp_vert_color_in_shader = TRUE;
      }

      if (!screen->get_param(screen, PIPE_CAP_FRAGMENT_COLOR_CLAMPED)) {
         st->clamp_frag_color_in_shader = TRUE;
      }

      /* For drivers which cannot do color clamping, it's better to just
       * disable ARB_color_buffer_float in the core profile, because
       * the clamping is deprecated there anyway. */
      if (ctx->API == API_OPENGL_CORE &&
          (st->clamp_frag_color_in_shader || st->clamp_vert_color_in_shader)) {
         st->clamp_vert_color_in_shader = GL_FALSE;
         st->clamp_frag_color_in_shader = GL_FALSE;
         ctx->Extensions.ARB_color_buffer_float = GL_FALSE;
      }
d727 1
a727 1
      ctx->Extensions.ARB_sync = GL_TRUE;
d731 37
a767 10
   for (i = 16; i > 0; --i) {
      enum pipe_format pformat = st_choose_format(st, GL_RGBA,
                                                  GL_NONE, GL_NONE,
                                                  PIPE_TEXTURE_2D, i,
                                                  PIPE_BIND_RENDER_TARGET, FALSE);
      if (pformat != PIPE_FORMAT_NONE) {
         ctx->Const.MaxSamples = i;
         ctx->Const.MaxColorTextureSamples = i;
         break;
      }
d769 1
a769 21
   for (i = ctx->Const.MaxSamples; i > 0; --i) {
      enum pipe_format pformat = st_choose_format(st, GL_DEPTH_STENCIL,
                                                  GL_NONE, GL_NONE,
                                                  PIPE_TEXTURE_2D, i,
                                                  PIPE_BIND_DEPTH_STENCIL, FALSE);
      if (pformat != PIPE_FORMAT_NONE) {
         ctx->Const.MaxDepthTextureSamples = i;
         break;
      }
   }
   for (i = ctx->Const.MaxSamples; i > 0; --i) {
      enum pipe_format pformat = st_choose_format(st, GL_RGBA_INTEGER,
                                                  GL_NONE, GL_NONE,
                                                  PIPE_TEXTURE_2D, i,
                                                  PIPE_BIND_RENDER_TARGET, FALSE);
      if (pformat != PIPE_FORMAT_NONE) {
         ctx->Const.MaxIntegerSamples = i;
         break;
      }
   }
   if (ctx->Const.MaxSamples == 1) {
d771 1
a771 1
      ctx->Const.MaxSamples = 0;
d773 3
a775 3
   else if (ctx->Const.MaxSamples >= 2) {
      ctx->Extensions.EXT_framebuffer_multisample = GL_TRUE;
      ctx->Extensions.EXT_framebuffer_multisample_blit_scaled = GL_TRUE;
d778 5
a782 5
   if (ctx->Const.MaxSamples == 0 && screen->get_param(screen, PIPE_CAP_FAKE_SW_MSAA)) {
	ctx->Const.FakeSWMSAA = GL_TRUE;
        ctx->Extensions.EXT_framebuffer_multisample = GL_TRUE;
        ctx->Extensions.EXT_framebuffer_multisample_blit_scaled = GL_TRUE;
        ctx->Extensions.ARB_texture_multisample = GL_TRUE;
d785 3
a787 3
   if (ctx->Const.MaxDualSourceDrawBuffers > 0 &&
       !st->options.disable_blend_func_extended)
      ctx->Extensions.ARB_blend_func_extended = GL_TRUE;
d789 4
a792 2
   st->has_time_elapsed =
      screen->get_param(screen, PIPE_CAP_QUERY_TIME_ELAPSED);
d794 3
a796 3
   if (st->has_time_elapsed ||
       ctx->Extensions.ARB_timer_query) {
      ctx->Extensions.EXT_timer_query = GL_TRUE;
d798 2
d801 2
a802 6
   if (ctx->Extensions.ARB_transform_feedback2 &&
       ctx->Extensions.ARB_draw_instanced) {
      ctx->Extensions.ARB_transform_feedback_instanced = GL_TRUE;
   }
   if (st->options.force_glsl_extensions_warn)
      ctx->Const.ForceGLSLExtensionsWarn = 1;
d804 2
a805 2
   if (st->options.disable_glsl_line_continuations)
      ctx->Const.DisableGLSLLineContinuations = 1;
d807 1
a807 1
   ctx->Const.MinMapBufferAlignment =
d811 1
a811 1
      ctx->Extensions.ARB_texture_buffer_object = GL_TRUE;
d813 1
a813 1
      ctx->Const.MaxTextureBufferSize =
d816 1
a816 1
      ctx->Const.TextureBufferOffsetAlignment =
d819 2
a820 2
      if (ctx->Const.TextureBufferOffsetAlignment)
         ctx->Extensions.ARB_texture_buffer_range = GL_TRUE;
d822 3
a824 2
      init_format_extensions(st, tbo_rgb32, Elements(tbo_rgb32),
                             PIPE_BUFFER, PIPE_BIND_SAMPLER_VIEW);
d828 1
a828 1
      ctx->Extensions.ARB_framebuffer_object = GL_TRUE;
d841 2
a842 2
      if (!ctx->Extensions.EXT_transform_feedback)
         ctx->Const.DisableVaryingPacking = GL_TRUE;
d845 46
a890 7
   if (ctx->API == API_OPENGL_CORE) {
      ctx->Const.MaxViewports = screen->get_param(screen, PIPE_CAP_MAX_VIEWPORTS);
      if (ctx->Const.MaxViewports >= 16) {
         ctx->Const.ViewportBounds.Min = -16384.0;
         ctx->Const.ViewportBounds.Max = 16384.0;
         ctx->Extensions.ARB_viewport_array = GL_TRUE;
      }
a891 2
   if (ctx->Const.MaxProgramTextureGatherComponents > 0)
      ctx->Extensions.ARB_texture_gather = GL_TRUE;
@


