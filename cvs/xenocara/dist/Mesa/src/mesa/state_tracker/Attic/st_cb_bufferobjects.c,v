head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.06.42;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.20;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.10;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.13.17;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.50.23;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/


/**
 * Functions for pixel buffer objects and vertex/element buffer objects.
 */


#include "main/imports.h"
#include "main/mtypes.h"
#include "main/arrayobj.h"
#include "main/bufferobj.h"

#include "st_context.h"
#include "st_cb_bufferobjects.h"
#include "st_debug.h"

#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "util/u_inlines.h"


/**
 * There is some duplication between mesa's bufferobjects and our
 * bufmgr buffers.  Both have an integer handle and a hashtable to
 * lookup an opaque structure.  It would be nice if the handles and
 * internal structure where somehow shared.
 */
static struct gl_buffer_object *
st_bufferobj_alloc(struct gl_context *ctx, GLuint name, GLenum target)
{
   struct st_buffer_object *st_obj = ST_CALLOC_STRUCT(st_buffer_object);

   if (!st_obj)
      return NULL;

   _mesa_initialize_buffer_object(ctx, &st_obj->Base, name, target);

   return &st_obj->Base;
}



/**
 * Deallocate/free a vertex/pixel buffer object.
 * Called via glDeleteBuffersARB().
 */
static void
st_bufferobj_free(struct gl_context *ctx, struct gl_buffer_object *obj)
{
   struct st_buffer_object *st_obj = st_buffer_object(obj);

   assert(obj->RefCount == 0);
   _mesa_buffer_unmap_all_mappings(ctx, obj);

   if (st_obj->buffer)
      pipe_resource_reference(&st_obj->buffer, NULL);

   free(st_obj->Base.Label);
   free(st_obj);
}



/**
 * Replace data in a subrange of buffer object.  If the data range
 * specified by size + offset extends beyond the end of the buffer or
 * if data is NULL, no copy is performed.
 * Called via glBufferSubDataARB().
 */
static void
st_bufferobj_subdata(struct gl_context *ctx,
		     GLintptrARB offset,
		     GLsizeiptrARB size,
		     const GLvoid * data, struct gl_buffer_object *obj)
{
   struct st_buffer_object *st_obj = st_buffer_object(obj);

   /* we may be called from VBO code, so double-check params here */
   ASSERT(offset >= 0);
   ASSERT(size >= 0);
   ASSERT(offset + size <= obj->Size);

   if (!size)
      return;

   /*
    * According to ARB_vertex_buffer_object specification, if data is null,
    * then the contents of the buffer object's data store is undefined. We just
    * ignore, and leave it unchanged.
    */
   if (!data)
      return;

   if (!st_obj->buffer) {
      /* we probably ran out of memory during buffer allocation */
      return;
   }

   /* Now that transfers are per-context, we don't have to figure out
    * flushing here.  Usually drivers won't need to flush in this case
    * even if the buffer is currently referenced by hardware - they
    * just queue the upload as dma rather than mapping the underlying
    * buffer directly.
    */
   pipe_buffer_write(st_context(ctx)->pipe,
		     st_obj->buffer,
		     offset, size, data);
}


/**
 * Called via glGetBufferSubDataARB().
 */
static void
st_bufferobj_get_subdata(struct gl_context *ctx,
                         GLintptrARB offset,
                         GLsizeiptrARB size,
                         GLvoid * data, struct gl_buffer_object *obj)
{
   struct st_buffer_object *st_obj = st_buffer_object(obj);

   /* we may be called from VBO code, so double-check params here */
   ASSERT(offset >= 0);
   ASSERT(size >= 0);
   ASSERT(offset + size <= obj->Size);

   if (!size)
      return;

   if (!st_obj->buffer) {
      /* we probably ran out of memory during buffer allocation */
      return;
   }

   pipe_buffer_read(st_context(ctx)->pipe, st_obj->buffer,
                    offset, size, data);
}


/**
 * Allocate space for and store data in a buffer object.  Any data that was
 * previously stored in the buffer object is lost.  If data is NULL,
 * memory will be allocated, but no copy will occur.
 * Called via ctx->Driver.BufferData().
 * \return GL_TRUE for success, GL_FALSE if out of memory
 */
static GLboolean
st_bufferobj_data(struct gl_context *ctx,
		  GLenum target,
		  GLsizeiptrARB size,
		  const GLvoid * data,
		  GLenum usage,
                  GLbitfield storageFlags,
		  struct gl_buffer_object *obj)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   struct st_buffer_object *st_obj = st_buffer_object(obj);
   unsigned bind, pipe_usage, pipe_flags = 0;

   if (size && data && st_obj->buffer &&
       st_obj->Base.Size == size &&
       st_obj->Base.Usage == usage &&
       st_obj->Base.StorageFlags == storageFlags) {
      /* Just discard the old contents and write new data.
       * This should be the same as creating a new buffer, but we avoid
       * a lot of validation in Mesa.
       */
      struct pipe_box box;

      u_box_1d(0, size, &box);
      pipe->transfer_inline_write(pipe, st_obj->buffer, 0,
                                  PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE,
                                  &box, data, 0, 0);
      return GL_TRUE;
   }

   st_obj->Base.Size = size;
   st_obj->Base.Usage = usage;
   st_obj->Base.StorageFlags = storageFlags;

   switch (target) {
   case GL_PIXEL_PACK_BUFFER_ARB:
   case GL_PIXEL_UNPACK_BUFFER_ARB:
      bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;
      break;
   case GL_ARRAY_BUFFER_ARB:
      bind = PIPE_BIND_VERTEX_BUFFER;
      break;
   case GL_ELEMENT_ARRAY_BUFFER_ARB:
      bind = PIPE_BIND_INDEX_BUFFER;
      break;
   case GL_TEXTURE_BUFFER:
      bind = PIPE_BIND_SAMPLER_VIEW;
      break;
   case GL_TRANSFORM_FEEDBACK_BUFFER:
      bind = PIPE_BIND_STREAM_OUTPUT;
      break;
   case GL_UNIFORM_BUFFER:
      bind = PIPE_BIND_CONSTANT_BUFFER;
      break;
   default:
      bind = 0;
   }

   /* Set usage. */
   if (st_obj->Base.Immutable) {
      /* BufferStorage */
      if (storageFlags & GL_CLIENT_STORAGE_BIT)
         pipe_usage = PIPE_USAGE_STAGING;
      else
         pipe_usage = PIPE_USAGE_DEFAULT;
   }
   else {
      /* BufferData */
      switch (usage) {
      case GL_STATIC_DRAW:
      case GL_STATIC_READ:
      case GL_STATIC_COPY:
      default:
	 pipe_usage = PIPE_USAGE_DEFAULT;
         break;
      case GL_DYNAMIC_DRAW:
      case GL_DYNAMIC_READ:
      case GL_DYNAMIC_COPY:
         pipe_usage = PIPE_USAGE_DYNAMIC;
         break;
      case GL_STREAM_DRAW:
      case GL_STREAM_READ:
      case GL_STREAM_COPY:
         pipe_usage = PIPE_USAGE_STREAM;
         break;
      }
   }

   /* Set flags. */
   if (storageFlags & GL_MAP_PERSISTENT_BIT)
      pipe_flags |= PIPE_RESOURCE_FLAG_MAP_PERSISTENT;
   if (storageFlags & GL_MAP_COHERENT_BIT)
      pipe_flags |= PIPE_RESOURCE_FLAG_MAP_COHERENT;

   pipe_resource_reference( &st_obj->buffer, NULL );

   if (ST_DEBUG & DEBUG_BUFFER) {
      debug_printf("Create buffer size %td bind 0x%x\n", size, bind);
   }

   if (size != 0) {
      struct pipe_resource buffer;

      memset(&buffer, 0, sizeof buffer);
      buffer.target = PIPE_BUFFER;
      buffer.format = PIPE_FORMAT_R8_UNORM; /* want TYPELESS or similar */
      buffer.bind = bind;
      buffer.usage = pipe_usage;
      buffer.flags = pipe_flags;
      buffer.width0 = size;
      buffer.height0 = 1;
      buffer.depth0 = 1;
      buffer.array_size = 1;

      st_obj->buffer = pipe->screen->resource_create(pipe->screen, &buffer);

      if (!st_obj->buffer) {
         /* out of memory */
         st_obj->Base.Size = 0;
         return GL_FALSE;
      }

      if (data)
         pipe_buffer_write(pipe, st_obj->buffer, 0, size, data);
   }

   /* BufferData may change an array or uniform buffer, need to update it */
   st->dirty.st |= ST_NEW_VERTEX_ARRAYS | ST_NEW_UNIFORM_BUFFER;

   return GL_TRUE;
}


/**
 * Called via glMapBufferRange().
 */
static void *
st_bufferobj_map_range(struct gl_context *ctx,
                       GLintptr offset, GLsizeiptr length, GLbitfield access,
                       struct gl_buffer_object *obj,
                       gl_map_buffer_index index)
{
   struct pipe_context *pipe = st_context(ctx)->pipe;
   struct st_buffer_object *st_obj = st_buffer_object(obj);
   enum pipe_transfer_usage flags = 0x0;

   if (access & GL_MAP_WRITE_BIT)
      flags |= PIPE_TRANSFER_WRITE;

   if (access & GL_MAP_READ_BIT)
      flags |= PIPE_TRANSFER_READ;

   if (access & GL_MAP_FLUSH_EXPLICIT_BIT)
      flags |= PIPE_TRANSFER_FLUSH_EXPLICIT;

   if (access & GL_MAP_INVALIDATE_BUFFER_BIT) {
      flags |= PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE;
   }
   else if (access & GL_MAP_INVALIDATE_RANGE_BIT) {
      if (offset == 0 && length == obj->Size)
         flags |= PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE;
      else
         flags |= PIPE_TRANSFER_DISCARD_RANGE;
   }

   if (access & GL_MAP_UNSYNCHRONIZED_BIT)
      flags |= PIPE_TRANSFER_UNSYNCHRONIZED;

   if (access & GL_MAP_PERSISTENT_BIT)
      flags |= PIPE_TRANSFER_PERSISTENT;

   if (access & GL_MAP_COHERENT_BIT)
      flags |= PIPE_TRANSFER_COHERENT;

   /* ... other flags ...
    */

   if (access & MESA_MAP_NOWAIT_BIT)
      flags |= PIPE_TRANSFER_DONTBLOCK;

   assert(offset >= 0);
   assert(length >= 0);
   assert(offset < obj->Size);
   assert(offset + length <= obj->Size);

   obj->Mappings[index].Pointer = pipe_buffer_map_range(pipe,
                                        st_obj->buffer,
                                        offset, length,
                                        flags,
                                        &st_obj->transfer[index]);
   if (obj->Mappings[index].Pointer) {
      obj->Mappings[index].Offset = offset;
      obj->Mappings[index].Length = length;
      obj->Mappings[index].AccessFlags = access;
   }
   else {
      st_obj->transfer[index] = NULL;
   }

   return obj->Mappings[index].Pointer;
}


static void
st_bufferobj_flush_mapped_range(struct gl_context *ctx,
                                GLintptr offset, GLsizeiptr length,
                                struct gl_buffer_object *obj,
                                gl_map_buffer_index index)
{
   struct pipe_context *pipe = st_context(ctx)->pipe;
   struct st_buffer_object *st_obj = st_buffer_object(obj);

   /* Subrange is relative to mapped range */
   assert(offset >= 0);
   assert(length >= 0);
   assert(offset + length <= obj->Mappings[index].Length);
   assert(obj->Mappings[index].Pointer);

   if (!length)
      return;

   pipe_buffer_flush_mapped_range(pipe, st_obj->transfer[index],
                                  obj->Mappings[index].Offset + offset,
                                  length);
}


/**
 * Called via glUnmapBufferARB().
 */
static GLboolean
st_bufferobj_unmap(struct gl_context *ctx, struct gl_buffer_object *obj,
                   gl_map_buffer_index index)
{
   struct pipe_context *pipe = st_context(ctx)->pipe;
   struct st_buffer_object *st_obj = st_buffer_object(obj);

   if (obj->Mappings[index].Length)
      pipe_buffer_unmap(pipe, st_obj->transfer[index]);

   st_obj->transfer[index] = NULL;
   obj->Mappings[index].Pointer = NULL;
   obj->Mappings[index].Offset = 0;
   obj->Mappings[index].Length = 0;
   return GL_TRUE;
}


/**
 * Called via glCopyBufferSubData().
 */
static void
st_copy_buffer_subdata(struct gl_context *ctx,
                       struct gl_buffer_object *src,
                       struct gl_buffer_object *dst,
                       GLintptr readOffset, GLintptr writeOffset,
                       GLsizeiptr size)
{
   struct pipe_context *pipe = st_context(ctx)->pipe;
   struct st_buffer_object *srcObj = st_buffer_object(src);
   struct st_buffer_object *dstObj = st_buffer_object(dst);
   struct pipe_box box;

   if (!size)
      return;

   /* buffer should not already be mapped */
   assert(!_mesa_check_disallowed_mapping(src));
   assert(!_mesa_check_disallowed_mapping(dst));

   u_box_1d(readOffset, size, &box);

   pipe->resource_copy_region(pipe, dstObj->buffer, 0, writeOffset, 0, 0,
                              srcObj->buffer, 0, &box);
}

/**
 * Called via glClearBufferSubData().
 */
static void
st_clear_buffer_subdata(struct gl_context *ctx,
                        GLintptr offset, GLsizeiptr size,
                        const GLvoid *clearValue,
                        GLsizeiptr clearValueSize,
                        struct gl_buffer_object *bufObj)
{
   struct pipe_context *pipe = st_context(ctx)->pipe;
   struct st_buffer_object *buf = st_buffer_object(bufObj);
   static const char zeros[16] = {0};

   if (!pipe->clear_buffer) {
      _mesa_buffer_clear_subdata(ctx, offset, size,
                                 clearValue, clearValueSize, bufObj);
      return;
   }

   if (!clearValue)
      clearValue = zeros;

   pipe->clear_buffer(pipe, buf->buffer, offset, size,
                      clearValue, clearValueSize);
}


/* TODO: if buffer wasn't created with appropriate usage flags, need
 * to recreate it now and copy contents -- or possibly create a
 * gallium entrypoint to extend the usage flags and let the driver
 * decide if a copy is necessary.
 */
void
st_bufferobj_validate_usage(struct st_context *st,
			    struct st_buffer_object *obj,
			    unsigned usage)
{
}


void
st_init_bufferobject_functions(struct dd_function_table *functions)
{
   /* plug in default driver fallbacks (such as for ClearBufferSubData) */
   _mesa_init_buffer_object_functions(functions);

   functions->NewBufferObject = st_bufferobj_alloc;
   functions->DeleteBuffer = st_bufferobj_free;
   functions->BufferData = st_bufferobj_data;
   functions->BufferSubData = st_bufferobj_subdata;
   functions->GetBufferSubData = st_bufferobj_get_subdata;
   functions->MapBufferRange = st_bufferobj_map_range;
   functions->FlushMappedBufferRange = st_bufferobj_flush_mapped_range;
   functions->UnmapBuffer = st_bufferobj_unmap;
   functions->CopyBufferSubData = st_copy_buffer_subdata;
   functions->ClearBufferSubData = st_clear_buffer_subdata;

   /* For GL_APPLE_vertex_array_object */
   functions->NewArrayObject = _mesa_new_vao;
   functions->DeleteArrayObject = _mesa_delete_vao;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a33 2
#include <inttypes.h>  /* for PRId64 macro */

d55 1
a55 1
st_bufferobj_alloc(struct gl_context *ctx, GLuint name)
d62 1
a62 1
   _mesa_initialize_buffer_object(ctx, &st_obj->Base, name);
a227 3
   case GL_DRAW_INDIRECT_BUFFER:
      bind = PIPE_BIND_COMMAND_ARGS_BUFFER;
      break;
d244 1
d250 1
d255 1
a258 5
      case GL_STATIC_READ:
      case GL_DYNAMIC_READ:
      case GL_STREAM_READ:
         pipe_usage = PIPE_USAGE_STAGING;
         break;
d271 1
a271 2
      debug_printf("Create buffer size %" PRId64 " bind 0x%x\n",
                   (int64_t) size, bind);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d34 2
d57 1
a57 1
st_bufferobj_alloc(struct gl_context *ctx, GLuint name, GLenum target)
d64 1
a64 1
   _mesa_initialize_buffer_object(ctx, &st_obj->Base, name, target);
d230 3
a248 1
      case GL_STATIC_READ:
a253 1
      case GL_DYNAMIC_READ:
a257 1
      case GL_STREAM_READ:
d261 5
d278 2
a279 1
      debug_printf("Create buffer size %td bind 0x%x\n", size, bind);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d2 2
a3 2
 * 
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d5 1
a5 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
 * 
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d25 1
a25 1
 * 
d79 1
a79 1
   assert(st_obj->transfer == NULL);
d81 1
a81 1
   if (st_obj->buffer) 
d84 1
d178 2
a179 1
		  GLenum usage, 
d185 1
a185 1
   unsigned bind, pipe_usage;
d188 3
a190 1
       st_obj->Base.Size == size && st_obj->Base.Usage == usage) {
d206 3
a208 2
   
   switch(target) {
d232 28
a259 18
   switch (usage) {
   case GL_STATIC_DRAW:
   case GL_STATIC_READ:
   case GL_STATIC_COPY:
      pipe_usage = PIPE_USAGE_STATIC;
      break;
   case GL_DYNAMIC_DRAW:
   case GL_DYNAMIC_READ:
   case GL_DYNAMIC_COPY:
      pipe_usage = PIPE_USAGE_DYNAMIC;
      break;
   case GL_STREAM_DRAW:
   case GL_STREAM_READ:
   case GL_STREAM_COPY:
      pipe_usage = PIPE_USAGE_STREAM;
      break;
   default:
      pipe_usage = PIPE_USAGE_DEFAULT;
d262 6
d275 14
a288 2
      st_obj->buffer = pipe_buffer_create(pipe->screen, bind,
                                          pipe_usage, size);
d313 2
a314 1
                       struct gl_buffer_object *obj)
d338 1
a338 1
   
d342 6
d359 1
a359 1
   obj->Pointer = pipe_buffer_map_range(pipe,
d363 5
a367 5
                                        &st_obj->transfer);
   if (obj->Pointer) {
      obj->Offset = offset;
      obj->Length = length;
      obj->AccessFlags = access;
d370 1
a370 1
      st_obj->transfer = NULL;
d373 1
a373 1
   return obj->Pointer;
d380 2
a381 1
                                struct gl_buffer_object *obj)
d389 3
a391 3
   assert(offset + length <= obj->Length);
   assert(obj->Pointer);
   
d395 3
a397 2
   pipe_buffer_flush_mapped_range(pipe, st_obj->transfer, 
                                  obj->Offset + offset, length);
d405 2
a406 1
st_bufferobj_unmap(struct gl_context *ctx, struct gl_buffer_object *obj)
d411 2
a412 2
   if (obj->Length)
      pipe_buffer_unmap(pipe, st_obj->transfer);
d414 4
a417 4
   st_obj->transfer = NULL;
   obj->Pointer = NULL;
   obj->Offset = 0;
   obj->Length = 0;
d437 1
a437 1
   if(!size)
d441 2
a442 2
   assert(!src->Pointer);
   assert(!dst->Pointer);
d450 27
d494 3
d506 1
d509 2
a510 2
   functions->NewArrayObject = _mesa_new_array_object;
   functions->DeleteArrayObject = _mesa_delete_array_object;
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d41 1
d62 1
a62 1
   _mesa_initialize_buffer_object(&st_obj->Base, name, target);
a96 1
		     GLenum target,
d119 5
a140 1
                         GLenum target,
d155 5
d185 15
d214 9
d249 4
d258 2
a264 1
      return GL_TRUE;
d267 3
a274 49
 * Dummy data whose's pointer is used for zero size buffers or ranges.
 */
static long st_bufferobj_zero_length = 0;



/**
 * Called via glMapBufferARB().
 */
static void *
st_bufferobj_map(struct gl_context *ctx, GLenum target, GLenum access,
                 struct gl_buffer_object *obj)
{
   struct st_buffer_object *st_obj = st_buffer_object(obj);
   uint flags;

   switch (access) {
   case GL_WRITE_ONLY:
      flags = PIPE_TRANSFER_WRITE;
      break;
   case GL_READ_ONLY:
      flags = PIPE_TRANSFER_READ;
      break;
   case GL_READ_WRITE:
   default:
      flags = PIPE_TRANSFER_READ_WRITE;
      break;      
   }

   /* Handle zero-size buffers here rather than in drivers */
   if (obj->Size == 0) {
      obj->Pointer = &st_bufferobj_zero_length;
   }
   else {
      obj->Pointer = pipe_buffer_map(st_context(ctx)->pipe,
                                     st_obj->buffer,
                                     flags,
                                     &st_obj->transfer);
   }

   if (obj->Pointer) {
      obj->Offset = 0;
      obj->Length = obj->Size;
   }
   return obj->Pointer;
}


/**
d278 1
a278 1
st_bufferobj_map_range(struct gl_context *ctx, GLenum target, 
d319 5
a323 18
   /*
    * We go out of way here to hide the degenerate yet valid case of zero
    * length range from the pipe driver.
    */
   if (!length) {
      obj->Pointer = &st_bufferobj_zero_length;
   }
   else {
      obj->Pointer = pipe_buffer_map_range(pipe, 
                                           st_obj->buffer,
                                           offset, length,
                                           flags,
                                           &st_obj->transfer);
      if (obj->Pointer) {
         obj->Pointer = (ubyte *) obj->Pointer + offset;
      }
   }
   
d329 3
d338 1
a338 1
st_bufferobj_flush_mapped_range(struct gl_context *ctx, GLenum target, 
d363 1
a363 1
st_bufferobj_unmap(struct gl_context *ctx, GLenum target, struct gl_buffer_object *obj)
a428 1
   functions->MapBuffer = st_bufferobj_map;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d174 1
a174 1
   unsigned buffer_usage;
d182 1
a182 1
      buffer_usage = PIPE_BIND_RENDER_TARGET;
d185 1
a185 1
      buffer_usage = PIPE_BIND_VERTEX_BUFFER;
d188 1
a188 1
      buffer_usage = PIPE_BIND_INDEX_BUFFER;
d191 21
a211 1
      buffer_usage = 0;
d217 2
a218 1
      st_obj->buffer = pipe_buffer_create(pipe->screen, buffer_usage, size);
d225 1
a225 2
         pipe_buffer_write(st_context(ctx)->pipe, st_obj->buffer, 0,
				       size, data);
d303 9
a311 5
   if (access & GL_MAP_INVALIDATE_RANGE_BIT)
      flags |= PIPE_TRANSFER_DISCARD;

   if (access & GL_MAP_INVALIDATE_BUFFER_BIT)
      flags |= PIPE_TRANSFER_DISCARD;
d387 1
a387 1
      pipe_buffer_unmap(pipe, st_obj->buffer, st_obj->transfer);
d410 1
a410 3
   struct pipe_transfer *src_transfer;
   struct pipe_transfer *dst_transfer;
   ubyte *srcPtr, *dstPtr;
d419 1
a419 14
   srcPtr = (ubyte *) pipe_buffer_map_range(pipe,
                                            srcObj->buffer,
                                            readOffset, size,
                                            PIPE_TRANSFER_READ,
					    &src_transfer);

   dstPtr = (ubyte *) pipe_buffer_map_range(pipe,
                                            dstObj->buffer,
                                            writeOffset, size,
                                            PIPE_TRANSFER_WRITE,
					    &dst_transfer);

   if (srcPtr && dstPtr)
      memcpy(dstPtr + writeOffset, srcPtr + readOffset, size);
d421 2
a422 2
   pipe_buffer_unmap(pipe, srcObj->buffer, src_transfer);
   pipe_buffer_unmap(pipe, dstObj->buffer, dst_transfer);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a38 1
#include "st_inlines.h"
d54 1
a54 1
st_bufferobj_alloc(GLcontext *ctx, GLuint name, GLenum target)
d73 1
a73 1
st_bufferobj_free(GLcontext *ctx, struct gl_buffer_object *obj)
d78 1
d81 1
a81 1
      pipe_buffer_reference(&st_obj->buffer, NULL);
d95 1
a95 1
st_bufferobj_subdata(GLcontext *ctx,
d119 9
a127 2
   st_cond_flush_pipe_buffer_write(st_context(ctx), st_obj->buffer,
				   offset, size, data);
d135 1
a135 1
st_bufferobj_get_subdata(GLcontext *ctx,
d151 2
a152 2
   st_cond_flush_pipe_buffer_read(st_context(ctx), st_obj->buffer,
				  offset, size, data);
d164 1
a164 1
st_bufferobj_data(GLcontext *ctx,
d182 1
a182 1
      buffer_usage = PIPE_BUFFER_USAGE_PIXEL;
d185 1
a185 1
      buffer_usage = PIPE_BUFFER_USAGE_VERTEX;
d188 1
a188 1
      buffer_usage = PIPE_BUFFER_USAGE_INDEX;
d194 1
a194 1
   pipe_buffer_reference( &st_obj->buffer, NULL );
d197 1
a197 1
      st_obj->buffer = pipe_buffer_create(pipe->screen, 32, buffer_usage, size);
d204 1
a204 1
         st_no_flush_pipe_buffer_write(st_context(ctx), st_obj->buffer, 0,
d214 7
d224 1
a224 1
st_bufferobj_map(GLcontext *ctx, GLenum target, GLenum access,
d232 1
a232 1
      flags = PIPE_BUFFER_USAGE_CPU_WRITE;
d235 1
a235 1
      flags = PIPE_BUFFER_USAGE_CPU_READ;
a237 1
      /* fall-through */
d239 1
a239 1
      flags = PIPE_BUFFER_USAGE_CPU_READ | PIPE_BUFFER_USAGE_CPU_WRITE;
d243 11
a253 3
   obj->Pointer = st_cond_flush_pipe_buffer_map(st_context(ctx),
						st_obj->buffer,
						flags);
a262 7
 * Dummy data whose's pointer is used for zero length ranges.
 */
static long
st_bufferobj_zero_length_range = 0;


/**
d266 1
a266 1
st_bufferobj_map_range(GLcontext *ctx, GLenum target, 
d272 1
a272 1
   uint flags = 0x0;
d275 1
a275 1
      flags |= PIPE_BUFFER_USAGE_CPU_WRITE;
d278 1
a278 1
      flags |= PIPE_BUFFER_USAGE_CPU_READ;
d281 7
a287 1
      flags |= PIPE_BUFFER_USAGE_FLUSH_EXPLICIT;
d290 1
a290 1
      flags |= PIPE_BUFFER_USAGE_UNSYNCHRONIZED;
d296 1
a296 1
      flags |= PIPE_BUFFER_USAGE_DONTBLOCK;
d308 1
a308 1
      obj->Pointer = &st_bufferobj_zero_length_range;
d311 5
a315 1
      obj->Pointer = pipe_buffer_map_range(pipe->screen, st_obj->buffer, offset, length, flags);
d332 1
a332 1
st_bufferobj_flush_mapped_range(GLcontext *ctx, GLenum target, 
d343 1
d348 1
a348 1
   pipe_buffer_flush_mapped_range(pipe->screen, st_obj->buffer, 
d357 1
a357 1
st_bufferobj_unmap(GLcontext *ctx, GLenum target, struct gl_buffer_object *obj)
d362 2
a363 2
   if(obj->Length)
      pipe_buffer_unmap(pipe->screen, st_obj->buffer);
d365 1
d377 1
a377 1
st_copy_buffer_subdata(GLcontext *ctx,
d386 2
d397 1
a397 1
   srcPtr = (ubyte *) pipe_buffer_map_range(pipe->screen,
d400 2
a401 1
                                            PIPE_BUFFER_USAGE_CPU_READ);
d403 1
a403 1
   dstPtr = (ubyte *) pipe_buffer_map_range(pipe->screen,
d406 2
a407 1
                                            PIPE_BUFFER_USAGE_CPU_WRITE);
d412 15
a426 2
   pipe_buffer_unmap(pipe->screen, srcObj->buffer);
   pipe_buffer_unmap(pipe->screen, dstObj->buffer);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d39 1
d55 1
a55 1
st_bufferobj_alloc(struct gl_context *ctx, GLuint name, GLenum target)
d74 1
a74 1
st_bufferobj_free(struct gl_context *ctx, struct gl_buffer_object *obj)
a78 1
   assert(st_obj->transfer == NULL);
d81 1
a81 1
      pipe_resource_reference(&st_obj->buffer, NULL);
d95 1
a95 1
st_bufferobj_subdata(struct gl_context *ctx,
d119 2
a120 9
   /* Now that transfers are per-context, we don't have to figure out
    * flushing here.  Usually drivers won't need to flush in this case
    * even if the buffer is currently referenced by hardware - they
    * just queue the upload as dma rather than mapping the underlying
    * buffer directly.
    */
   pipe_buffer_write(st_context(ctx)->pipe,
		     st_obj->buffer,
		     offset, size, data);
d128 1
a128 1
st_bufferobj_get_subdata(struct gl_context *ctx,
d144 2
a145 2
   pipe_buffer_read(st_context(ctx)->pipe, st_obj->buffer,
                    offset, size, data);
d157 1
a157 1
st_bufferobj_data(struct gl_context *ctx,
d175 1
a175 1
      buffer_usage = PIPE_BIND_RENDER_TARGET;
d178 1
a178 1
      buffer_usage = PIPE_BIND_VERTEX_BUFFER;
d181 1
a181 1
      buffer_usage = PIPE_BIND_INDEX_BUFFER;
d187 1
a187 1
   pipe_resource_reference( &st_obj->buffer, NULL );
d190 1
a190 1
      st_obj->buffer = pipe_buffer_create(pipe->screen, buffer_usage, size);
d197 1
a197 1
         pipe_buffer_write(st_context(ctx)->pipe, st_obj->buffer, 0,
a206 7
 * Dummy data whose's pointer is used for zero size buffers or ranges.
 */
static long st_bufferobj_zero_length = 0;



/**
d210 1
a210 1
st_bufferobj_map(struct gl_context *ctx, GLenum target, GLenum access,
d218 1
a218 1
      flags = PIPE_TRANSFER_WRITE;
d221 1
a221 1
      flags = PIPE_TRANSFER_READ;
d224 1
d226 1
a226 1
      flags = PIPE_TRANSFER_READ_WRITE;
d230 3
a232 11
   /* Handle zero-size buffers here rather than in drivers */
   if (obj->Size == 0) {
      obj->Pointer = &st_bufferobj_zero_length;
   }
   else {
      obj->Pointer = pipe_buffer_map(st_context(ctx)->pipe,
                                     st_obj->buffer,
                                     flags,
                                     &st_obj->transfer);
   }

d242 7
d252 1
a252 1
st_bufferobj_map_range(struct gl_context *ctx, GLenum target, 
d258 1
a258 1
   enum pipe_transfer_usage flags = 0x0;
d261 1
a261 1
      flags |= PIPE_TRANSFER_WRITE;
d264 1
a264 1
      flags |= PIPE_TRANSFER_READ;
d267 1
a267 7
      flags |= PIPE_TRANSFER_FLUSH_EXPLICIT;

   if (access & GL_MAP_INVALIDATE_RANGE_BIT)
      flags |= PIPE_TRANSFER_DISCARD;

   if (access & GL_MAP_INVALIDATE_BUFFER_BIT)
      flags |= PIPE_TRANSFER_DISCARD;
d270 1
a270 1
      flags |= PIPE_TRANSFER_UNSYNCHRONIZED;
d276 1
a276 1
      flags |= PIPE_TRANSFER_DONTBLOCK;
d288 1
a288 1
      obj->Pointer = &st_bufferobj_zero_length;
d291 1
a291 5
      obj->Pointer = pipe_buffer_map_range(pipe, 
                                           st_obj->buffer,
                                           offset, length,
                                           flags,
                                           &st_obj->transfer);
d308 1
a308 1
st_bufferobj_flush_mapped_range(struct gl_context *ctx, GLenum target, 
a318 1
   assert(obj->Pointer);
d323 1
a323 1
   pipe_buffer_flush_mapped_range(pipe, st_obj->transfer, 
d332 1
a332 1
st_bufferobj_unmap(struct gl_context *ctx, GLenum target, struct gl_buffer_object *obj)
d337 2
a338 2
   if (obj->Length)
      pipe_buffer_unmap(pipe, st_obj->buffer, st_obj->transfer);
a339 1
   st_obj->transfer = NULL;
d351 1
a351 1
st_copy_buffer_subdata(struct gl_context *ctx,
a359 2
   struct pipe_transfer *src_transfer;
   struct pipe_transfer *dst_transfer;
d369 1
a369 1
   srcPtr = (ubyte *) pipe_buffer_map_range(pipe,
d372 1
a372 2
                                            PIPE_TRANSFER_READ,
					    &src_transfer);
d374 1
a374 1
   dstPtr = (ubyte *) pipe_buffer_map_range(pipe,
d377 1
a377 2
                                            PIPE_TRANSFER_WRITE,
					    &dst_transfer);
d382 2
a383 15
   pipe_buffer_unmap(pipe, srcObj->buffer, src_transfer);
   pipe_buffer_unmap(pipe, dstObj->buffer, dst_transfer);
}


/* TODO: if buffer wasn't created with appropriate usage flags, need
 * to recreate it now and copy contents -- or possibly create a
 * gallium entrypoint to extend the usage flags and let the driver
 * decide if a copy is necessary.
 */
void
st_bufferobj_validate_usage(struct st_context *st,
			    struct st_buffer_object *obj,
			    unsigned usage)
{
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a40 1
#include "st_debug.h"
d61 1
a61 1
   _mesa_initialize_buffer_object(ctx, &st_obj->Base, name, target);
d96 1
a118 5
   if (!st_obj->buffer) {
      /* we probably ran out of memory during buffer allocation */
      return;
   }

d136 1
a150 5
   if (!st_obj->buffer) {
      /* we probably ran out of memory during buffer allocation */
      return;
   }

d174 1
a174 16
   unsigned bind, pipe_usage;

   if (size && data && st_obj->buffer &&
       st_obj->Base.Size == size && st_obj->Base.Usage == usage) {
      /* Just discard the old contents and write new data.
       * This should be the same as creating a new buffer, but we avoid
       * a lot of validation in Mesa.
       */
      struct pipe_box box;

      u_box_1d(0, size, &box);
      pipe->transfer_inline_write(pipe, st_obj->buffer, 0,
                                  PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE,
                                  &box, data, 0, 0);
      return GL_TRUE;
   }
d182 1
a182 1
      bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;
d185 1
a185 1
      bind = PIPE_BIND_VERTEX_BUFFER;
d188 1
a188 10
      bind = PIPE_BIND_INDEX_BUFFER;
      break;
   case GL_TEXTURE_BUFFER:
      bind = PIPE_BIND_SAMPLER_VIEW;
      break;
   case GL_TRANSFORM_FEEDBACK_BUFFER:
      bind = PIPE_BIND_STREAM_OUTPUT;
      break;
   case GL_UNIFORM_BUFFER:
      bind = PIPE_BIND_CONSTANT_BUFFER;
d191 1
a191 21
      bind = 0;
   }

   switch (usage) {
   case GL_STATIC_DRAW:
   case GL_STATIC_READ:
   case GL_STATIC_COPY:
      pipe_usage = PIPE_USAGE_STATIC;
      break;
   case GL_DYNAMIC_DRAW:
   case GL_DYNAMIC_READ:
   case GL_DYNAMIC_COPY:
      pipe_usage = PIPE_USAGE_DYNAMIC;
      break;
   case GL_STREAM_DRAW:
   case GL_STREAM_READ:
   case GL_STREAM_COPY:
      pipe_usage = PIPE_USAGE_STREAM;
      break;
   default:
      pipe_usage = PIPE_USAGE_DEFAULT;
a195 4
   if (ST_DEBUG & DEBUG_BUFFER) {
      debug_printf("Create buffer size %td bind 0x%x\n", size, bind);
   }

d197 1
a197 2
      st_obj->buffer = pipe_buffer_create(pipe->screen, bind,
                                          pipe_usage, size);
a199 2
         /* out of memory */
         st_obj->Base.Size = 0;
d204 3
a206 1
         pipe_buffer_write(pipe, st_obj->buffer, 0, size, data);
d209 3
a211 2
   /* BufferData may change an array or uniform buffer, need to update it */
   st->dirty.st |= ST_NEW_VERTEX_ARRAYS | ST_NEW_UNIFORM_BUFFER;
d213 46
a258 1
   return GL_TRUE;
d266 1
a266 1
st_bufferobj_map_range(struct gl_context *ctx,
d283 5
a287 9
   if (access & GL_MAP_INVALIDATE_BUFFER_BIT) {
      flags |= PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE;
   }
   else if (access & GL_MAP_INVALIDATE_RANGE_BIT) {
      if (offset == 0 && length == obj->Size)
         flags |= PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE;
      else
         flags |= PIPE_TRANSFER_DISCARD_RANGE;
   }
d303 18
a320 5
   obj->Pointer = pipe_buffer_map_range(pipe,
                                        st_obj->buffer,
                                        offset, length,
                                        flags,
                                        &st_obj->transfer);
a325 3
   else {
      st_obj->transfer = NULL;
   }
d332 1
a332 1
st_bufferobj_flush_mapped_range(struct gl_context *ctx,
d357 1
a357 1
st_bufferobj_unmap(struct gl_context *ctx, struct gl_buffer_object *obj)
d363 1
a363 1
      pipe_buffer_unmap(pipe, st_obj->transfer);
d386 3
a388 1
   struct pipe_box box;
d397 14
a410 1
   u_box_1d(readOffset, size, &box);
d412 2
a413 2
   pipe->resource_copy_region(pipe, dstObj->buffer, 0, writeOffset, 0, 0,
                              srcObj->buffer, 0, &box);
d438 1
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d2 2
a3 2
 *
 * Copyright 2007 VMware, Inc.
d5 1
a5 1
 *
d13 1
a13 1
 *
d17 1
a17 1
 *
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d25 1
a25 1
 *
d79 1
a79 1
   _mesa_buffer_unmap_all_mappings(ctx, obj);
d81 1
a81 1
   if (st_obj->buffer)
a83 1
   free(st_obj->Base.Label);
d177 1
a177 2
		  GLenum usage,
                  GLbitfield storageFlags,
d183 1
a183 1
   unsigned bind, pipe_usage, pipe_flags = 0;
d186 1
a186 3
       st_obj->Base.Size == size &&
       st_obj->Base.Usage == usage &&
       st_obj->Base.StorageFlags == storageFlags) {
d202 2
a203 3
   st_obj->Base.StorageFlags = storageFlags;

   switch (target) {
d227 18
a244 7
   /* Set usage. */
   if (st_obj->Base.Immutable) {
      /* BufferStorage */
      if (storageFlags & GL_CLIENT_STORAGE_BIT)
         pipe_usage = PIPE_USAGE_STAGING;
      else
         pipe_usage = PIPE_USAGE_DEFAULT;
a245 27
   else {
      /* BufferData */
      switch (usage) {
      case GL_STATIC_DRAW:
      case GL_STATIC_READ:
      case GL_STATIC_COPY:
      default:
	 pipe_usage = PIPE_USAGE_DEFAULT;
         break;
      case GL_DYNAMIC_DRAW:
      case GL_DYNAMIC_READ:
      case GL_DYNAMIC_COPY:
         pipe_usage = PIPE_USAGE_DYNAMIC;
         break;
      case GL_STREAM_DRAW:
      case GL_STREAM_READ:
      case GL_STREAM_COPY:
         pipe_usage = PIPE_USAGE_STREAM;
         break;
      }
   }

   /* Set flags. */
   if (storageFlags & GL_MAP_PERSISTENT_BIT)
      pipe_flags |= PIPE_RESOURCE_FLAG_MAP_PERSISTENT;
   if (storageFlags & GL_MAP_COHERENT_BIT)
      pipe_flags |= PIPE_RESOURCE_FLAG_MAP_COHERENT;
d254 2
a255 14
      struct pipe_resource buffer;

      memset(&buffer, 0, sizeof buffer);
      buffer.target = PIPE_BUFFER;
      buffer.format = PIPE_FORMAT_R8_UNORM; /* want TYPELESS or similar */
      buffer.bind = bind;
      buffer.usage = pipe_usage;
      buffer.flags = pipe_flags;
      buffer.width0 = size;
      buffer.height0 = 1;
      buffer.depth0 = 1;
      buffer.array_size = 1;

      st_obj->buffer = pipe->screen->resource_create(pipe->screen, &buffer);
d280 1
a280 2
                       struct gl_buffer_object *obj,
                       gl_map_buffer_index index)
d304 1
a304 1

a307 6
   if (access & GL_MAP_PERSISTENT_BIT)
      flags |= PIPE_TRANSFER_PERSISTENT;

   if (access & GL_MAP_COHERENT_BIT)
      flags |= PIPE_TRANSFER_COHERENT;

d319 1
a319 1
   obj->Mappings[index].Pointer = pipe_buffer_map_range(pipe,
d323 5
a327 5
                                        &st_obj->transfer[index]);
   if (obj->Mappings[index].Pointer) {
      obj->Mappings[index].Offset = offset;
      obj->Mappings[index].Length = length;
      obj->Mappings[index].AccessFlags = access;
d330 1
a330 1
      st_obj->transfer[index] = NULL;
d333 1
a333 1
   return obj->Mappings[index].Pointer;
d340 1
a340 2
                                struct gl_buffer_object *obj,
                                gl_map_buffer_index index)
d348 3
a350 3
   assert(offset + length <= obj->Mappings[index].Length);
   assert(obj->Mappings[index].Pointer);

d354 2
a355 3
   pipe_buffer_flush_mapped_range(pipe, st_obj->transfer[index],
                                  obj->Mappings[index].Offset + offset,
                                  length);
d363 1
a363 2
st_bufferobj_unmap(struct gl_context *ctx, struct gl_buffer_object *obj,
                   gl_map_buffer_index index)
d368 2
a369 2
   if (obj->Mappings[index].Length)
      pipe_buffer_unmap(pipe, st_obj->transfer[index]);
d371 4
a374 4
   st_obj->transfer[index] = NULL;
   obj->Mappings[index].Pointer = NULL;
   obj->Mappings[index].Offset = 0;
   obj->Mappings[index].Length = 0;
d394 1
a394 1
   if (!size)
d398 2
a399 2
   assert(!_mesa_check_disallowed_mapping(src));
   assert(!_mesa_check_disallowed_mapping(dst));
a406 27
/**
 * Called via glClearBufferSubData().
 */
static void
st_clear_buffer_subdata(struct gl_context *ctx,
                        GLintptr offset, GLsizeiptr size,
                        const GLvoid *clearValue,
                        GLsizeiptr clearValueSize,
                        struct gl_buffer_object *bufObj)
{
   struct pipe_context *pipe = st_context(ctx)->pipe;
   struct st_buffer_object *buf = st_buffer_object(bufObj);
   static const char zeros[16] = {0};

   if (!pipe->clear_buffer) {
      _mesa_buffer_clear_subdata(ctx, offset, size,
                                 clearValue, clearValueSize, bufObj);
      return;
   }

   if (!clearValue)
      clearValue = zeros;

   pipe->clear_buffer(pipe, buf->buffer, offset, size,
                      clearValue, clearValueSize);
}

a423 3
   /* plug in default driver fallbacks (such as for ClearBufferSubData) */
   _mesa_init_buffer_object_functions(functions);

a432 1
   functions->ClearBufferSubData = st_clear_buffer_subdata;
d435 2
a436 2
   functions->NewArrayObject = _mesa_new_vao;
   functions->DeleteArrayObject = _mesa_delete_vao;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a33 2
#include <inttypes.h>  /* for PRId64 macro */

d55 1
a55 1
st_bufferobj_alloc(struct gl_context *ctx, GLuint name)
d62 1
a62 1
   _mesa_initialize_buffer_object(ctx, &st_obj->Base, name);
a227 3
   case GL_DRAW_INDIRECT_BUFFER:
      bind = PIPE_BIND_COMMAND_ARGS_BUFFER;
      break;
d244 1
d250 1
d255 1
a258 5
      case GL_STATIC_READ:
      case GL_DYNAMIC_READ:
      case GL_STREAM_READ:
         pipe_usage = PIPE_USAGE_STAGING;
         break;
d271 1
a271 2
      debug_printf("Create buffer size %" PRId64 " bind 0x%x\n",
                   (int64_t) size, bind);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d34 2
d57 1
a57 1
st_bufferobj_alloc(struct gl_context *ctx, GLuint name, GLenum target)
d64 1
a64 1
   _mesa_initialize_buffer_object(ctx, &st_obj->Base, name, target);
d230 3
a248 1
      case GL_STATIC_READ:
a253 1
      case GL_DYNAMIC_READ:
a257 1
      case GL_STREAM_READ:
d261 5
d278 2
a279 1
      debug_printf("Create buffer size %td bind 0x%x\n", size, bind);
@


