head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.06.42;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.20;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.10;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

 /*
  * Authors:
  *   Brian Paul
  */

#include "main/imports.h"
#include "main/image.h"
#include "main/bufferobj.h"
#include "main/macros.h"
#include "main/pbo.h"
#include "program/program.h"
#include "program/prog_print.h"

#include "st_context.h"
#include "st_atom.h"
#include "st_atom_constbuf.h"
#include "st_program.h"
#include "st_cb_bitmap.h"
#include "st_texture.h"

#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "pipe/p_shader_tokens.h"
#include "util/u_inlines.h"
#include "util/u_draw_quad.h"
#include "util/u_simple_shaders.h"
#include "util/u_upload_mgr.h"
#include "program/prog_instruction.h"
#include "cso_cache/cso_context.h"


/**
 * glBitmaps are drawn as textured quads.  The user's bitmap pattern
 * is stored in a texture image.  An alpha8 texture format is used.
 * The fragment shader samples a bit (texel) from the texture, then
 * discards the fragment if the bit is off.
 *
 * Note that we actually store the inverse image of the bitmap to
 * simplify the fragment program.  An "on" bit gets stored as texel=0x0
 * and an "off" bit is stored as texel=0xff.  Then we kill the
 * fragment if the negated texel value is less than zero.
 */


/**
 * The bitmap cache attempts to accumulate multiple glBitmap calls in a
 * buffer which is then rendered en mass upon a flush, state change, etc.
 * A wide, short buffer is used to target the common case of a series
 * of glBitmap calls being used to draw text.
 */
static GLboolean UseBitmapCache = GL_TRUE;


#define BITMAP_CACHE_WIDTH  512
#define BITMAP_CACHE_HEIGHT 32

struct bitmap_cache
{
   /** Window pos to render the cached image */
   GLint xpos, ypos;
   /** Bounds of region used in window coords */
   GLint xmin, ymin, xmax, ymax;

   GLfloat color[4];

   /** Bitmap's Z position */
   GLfloat zpos;

   struct pipe_resource *texture;
   struct pipe_transfer *trans;

   GLboolean empty;

   /** An I8 texture image: */
   ubyte *buffer;
};


/** Epsilon for Z comparisons */
#define Z_EPSILON 1e-06


/**
 * Make fragment program for glBitmap:
 *   Sample the texture and kill the fragment if the bit is 0.
 * This program will be combined with the user's fragment program.
 */
static struct st_fragment_program *
make_bitmap_fragment_program(struct gl_context *ctx, GLuint samplerIndex)
{
   struct st_context *st = st_context(ctx);
   struct st_fragment_program *stfp;
   struct gl_program *p;
   GLuint ic = 0;

   p = ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 0);
   if (!p)
      return NULL;

   p->NumInstructions = 3;

   p->Instructions = _mesa_alloc_instructions(p->NumInstructions);
   if (!p->Instructions) {
      ctx->Driver.DeleteProgram(ctx, p);
      return NULL;
   }
   _mesa_init_instructions(p->Instructions, p->NumInstructions);

   /* TEX tmp0, fragment.texcoord[0], texture[0], 2D; */
   p->Instructions[ic].Opcode = OPCODE_TEX;
   p->Instructions[ic].DstReg.File = PROGRAM_TEMPORARY;
   p->Instructions[ic].DstReg.Index = 0;
   p->Instructions[ic].SrcReg[0].File = PROGRAM_INPUT;
   p->Instructions[ic].SrcReg[0].Index = VARYING_SLOT_TEX0;
   p->Instructions[ic].TexSrcUnit = samplerIndex;
   p->Instructions[ic].TexSrcTarget = TEXTURE_2D_INDEX;
   ic++;

   /* KIL if -tmp0 < 0 # texel=0 -> keep / texel=0 -> discard */
   p->Instructions[ic].Opcode = OPCODE_KIL;
   p->Instructions[ic].SrcReg[0].File = PROGRAM_TEMPORARY;

   if (st->bitmap.tex_format == PIPE_FORMAT_L8_UNORM)
      p->Instructions[ic].SrcReg[0].Swizzle = SWIZZLE_XXXX;

   p->Instructions[ic].SrcReg[0].Index = 0;
   p->Instructions[ic].SrcReg[0].Negate = NEGATE_XYZW;
   ic++;

   /* END; */
   p->Instructions[ic++].Opcode = OPCODE_END;

   assert(ic == p->NumInstructions);

   p->InputsRead = VARYING_BIT_TEX0;
   p->OutputsWritten = 0x0;
   p->SamplersUsed = (1 << samplerIndex);

   stfp = (struct st_fragment_program *) p;
   stfp->Base.UsesKill = GL_TRUE;

   return stfp;
}


static struct gl_program *
make_bitmap_fragment_program_glsl(struct st_context *st,
                                  struct st_fragment_program *orig,
                                  GLuint samplerIndex)
{
   struct gl_context *ctx = st->ctx;
   struct st_fragment_program *fp = (struct st_fragment_program *)
      ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 0);

   if (!fp)
      return NULL;
   
   get_bitmap_visitor(fp, orig->glsl_to_tgsi, samplerIndex);
   return &fp->Base.Base;
}


static int
find_free_bit(uint bitfield)
{
   int i;
   for (i = 0; i < 32; i++) {
      if ((bitfield & (1 << i)) == 0) {
         return i;
      }
   }
   return -1;
}


/**
 * Combine basic bitmap fragment program with the user-defined program.
 * \param st  current context
 * \param fpIn  the incoming fragment program
 * \param fpOut  the new fragment program which does fragment culling
 * \param bitmap_sampler  sampler number for the bitmap texture
 */
void
st_make_bitmap_fragment_program(struct st_context *st,
                                struct gl_fragment_program *fpIn,
                                struct gl_fragment_program **fpOut,
                                GLuint *bitmap_sampler)
{
   struct st_fragment_program *bitmap_prog;
   struct st_fragment_program *stfpIn = (struct st_fragment_program *) fpIn;
   struct gl_program *newProg;
   uint sampler;

   /*
    * Generate new program which is the user-defined program prefixed
    * with the bitmap sampler/kill instructions.
    */
   sampler = find_free_bit(fpIn->Base.SamplersUsed);
   
   if (stfpIn->glsl_to_tgsi)
      newProg = make_bitmap_fragment_program_glsl(st, stfpIn, sampler);
   else {
      bitmap_prog = make_bitmap_fragment_program(st->ctx, sampler);

      newProg = _mesa_combine_programs(st->ctx,
                                       &bitmap_prog->Base.Base,
                                       &fpIn->Base);
      /* done with this after combining */
      st_reference_fragprog(st, &bitmap_prog, NULL);
   }

#if 0
   {
      printf("Combined bitmap program:\n");
      _mesa_print_program(newProg);
      printf("InputsRead: 0x%x\n", newProg->InputsRead);
      printf("OutputsWritten: 0x%x\n", newProg->OutputsWritten);
      _mesa_print_parameter_list(newProg->Parameters);
   }
#endif

   /* return results */
   *fpOut = (struct gl_fragment_program *) newProg;
   *bitmap_sampler = sampler;
}


/**
 * Copy user-provide bitmap bits into texture buffer, expanding
 * bits into texels.
 * "On" bits will set texels to 0x0.
 * "Off" bits will not modify texels.
 * Note that the image is actually going to be upside down in
 * the texture.  We deal with that with texcoords.
 */
static void
unpack_bitmap(struct st_context *st,
              GLint px, GLint py, GLsizei width, GLsizei height,
              const struct gl_pixelstore_attrib *unpack,
              const GLubyte *bitmap,
              ubyte *destBuffer, uint destStride)
{
   destBuffer += py * destStride + px;

   _mesa_expand_bitmap(width, height, unpack, bitmap,
                       destBuffer, destStride, 0x0);
}


/**
 * Create a texture which represents a bitmap image.
 */
static struct pipe_resource *
make_bitmap_texture(struct gl_context *ctx, GLsizei width, GLsizei height,
                    const struct gl_pixelstore_attrib *unpack,
                    const GLubyte *bitmap)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   struct pipe_transfer *transfer;
   ubyte *dest;
   struct pipe_resource *pt;

   /* PBO source... */
   bitmap = _mesa_map_pbo_source(ctx, unpack, bitmap);
   if (!bitmap) {
      return NULL;
   }

   /**
    * Create texture to hold bitmap pattern.
    */
   pt = st_texture_create(st, st->internal_target, st->bitmap.tex_format,
                          0, width, height, 1, 1, 0,
                          PIPE_BIND_SAMPLER_VIEW);
   if (!pt) {
      _mesa_unmap_pbo_source(ctx, unpack);
      return NULL;
   }

   dest = pipe_transfer_map(st->pipe, pt, 0, 0,
                            PIPE_TRANSFER_WRITE,
                            0, 0, width, height, &transfer);

   /* Put image into texture transfer */
   memset(dest, 0xff, height * transfer->stride);
   unpack_bitmap(st, 0, 0, width, height, unpack, bitmap,
                 dest, transfer->stride);

   _mesa_unmap_pbo_source(ctx, unpack);

   /* Release transfer */
   pipe_transfer_unmap(pipe, transfer);
   return pt;
}

static void
setup_bitmap_vertex_data(struct st_context *st, bool normalized,
                         int x, int y, int width, int height,
                         float z, const float color[4],
			 struct pipe_resource **vbuf,
			 unsigned *vbuf_offset)
{
   const GLfloat fb_width = (GLfloat)st->state.framebuffer.width;
   const GLfloat fb_height = (GLfloat)st->state.framebuffer.height;
   const GLfloat x0 = (GLfloat)x;
   const GLfloat x1 = (GLfloat)(x + width);
   const GLfloat y0 = (GLfloat)y;
   const GLfloat y1 = (GLfloat)(y + height);
   GLfloat sLeft = (GLfloat)0.0, sRight = (GLfloat)1.0;
   GLfloat tTop = (GLfloat)0.0, tBot = (GLfloat)1.0 - tTop;
   const GLfloat clip_x0 = (GLfloat)(x0 / fb_width * 2.0 - 1.0);
   const GLfloat clip_y0 = (GLfloat)(y0 / fb_height * 2.0 - 1.0);
   const GLfloat clip_x1 = (GLfloat)(x1 / fb_width * 2.0 - 1.0);
   const GLfloat clip_y1 = (GLfloat)(y1 / fb_height * 2.0 - 1.0);
   GLuint i;
   float (*vertices)[3][4];  /**< vertex pos + color + texcoord */

   if(!normalized)
   {
      sRight = (GLfloat) width;
      tBot = (GLfloat) height;
   }

   if (u_upload_alloc(st->uploader, 0, 4 * sizeof(vertices[0]),
                      vbuf_offset, vbuf, (void **) &vertices) != PIPE_OK) {
      return;
   }

   /* Positions are in clip coords since we need to do clipping in case
    * the bitmap quad goes beyond the window bounds.
    */
   vertices[0][0][0] = clip_x0;
   vertices[0][0][1] = clip_y0;
   vertices[0][2][0] = sLeft;
   vertices[0][2][1] = tTop;

   vertices[1][0][0] = clip_x1;
   vertices[1][0][1] = clip_y0;
   vertices[1][2][0] = sRight;
   vertices[1][2][1] = tTop;
   
   vertices[2][0][0] = clip_x1;
   vertices[2][0][1] = clip_y1;
   vertices[2][2][0] = sRight;
   vertices[2][2][1] = tBot;
   
   vertices[3][0][0] = clip_x0;
   vertices[3][0][1] = clip_y1;
   vertices[3][2][0] = sLeft;
   vertices[3][2][1] = tBot;
   
   /* same for all verts: */
   for (i = 0; i < 4; i++) {
      vertices[i][0][2] = z;
      vertices[i][0][3] = 1.0f;
      vertices[i][1][0] = color[0];
      vertices[i][1][1] = color[1];
      vertices[i][1][2] = color[2];
      vertices[i][1][3] = color[3];
      vertices[i][2][2] = 0.0; /*R*/
      vertices[i][2][3] = 1.0; /*Q*/
   }

   u_upload_unmap(st->uploader);
}



/**
 * Render a glBitmap by drawing a textured quad
 */
static void
draw_bitmap_quad(struct gl_context *ctx, GLint x, GLint y, GLfloat z,
                 GLsizei width, GLsizei height,
                 struct pipe_sampler_view *sv,
                 const GLfloat *color)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   struct cso_context *cso = st->cso_context;
   struct st_fp_variant *fpv;
   struct st_fp_variant_key key;
   GLuint maxSize;
   GLuint offset;
   struct pipe_resource *vbuf = NULL;

   memset(&key, 0, sizeof(key));
   key.st = st;
   key.bitmap = GL_TRUE;
   key.clamp_color = st->clamp_frag_color_in_shader &&
                     st->ctx->Color._ClampFragmentColor;

   fpv = st_get_fp_variant(st, st->fp, &key);

   /* As an optimization, Mesa's fragment programs will sometimes get the
    * primary color from a statevar/constant rather than a varying variable.
    * when that's the case, we need to ensure that we use the 'color'
    * parameter and not the current attribute color (which may have changed
    * through glRasterPos and state validation.
    * So, we force the proper color here.  Not elegant, but it works.
    */
   {
      GLfloat colorSave[4];
      COPY_4V(colorSave, ctx->Current.Attrib[VERT_ATTRIB_COLOR0]);
      COPY_4V(ctx->Current.Attrib[VERT_ATTRIB_COLOR0], color);
      st_upload_constants(st, fpv->parameters, PIPE_SHADER_FRAGMENT);
      COPY_4V(ctx->Current.Attrib[VERT_ATTRIB_COLOR0], colorSave);
   }


   /* limit checks */
   /* XXX if the bitmap is larger than the max texture size, break
    * it up into chunks.
    */
   maxSize = 1 << (pipe->screen->get_param(pipe->screen,
                                    PIPE_CAP_MAX_TEXTURE_2D_LEVELS) - 1);
   assert(width <= (GLsizei)maxSize);
   assert(height <= (GLsizei)maxSize);

   cso_save_rasterizer(cso);
   cso_save_samplers(cso, PIPE_SHADER_FRAGMENT);
   cso_save_sampler_views(cso, PIPE_SHADER_FRAGMENT);
   cso_save_viewport(cso);
   cso_save_fragment_shader(cso);
   cso_save_stream_outputs(cso);
   cso_save_vertex_shader(cso);
   cso_save_geometry_shader(cso);
   cso_save_vertex_elements(cso);
   cso_save_aux_vertex_buffer_slot(cso);

   /* rasterizer state: just scissor */
   st->bitmap.rasterizer.scissor = ctx->Scissor.EnableFlags & 1;
   cso_set_rasterizer(cso, &st->bitmap.rasterizer);

   /* fragment shader state: TEX lookup program */
   cso_set_fragment_shader_handle(cso, fpv->driver_shader);

   /* vertex shader state: position + texcoord pass-through */
   cso_set_vertex_shader_handle(cso, st->bitmap.vs);

   /* geometry shader state: disabled */
   cso_set_geometry_shader_handle(cso, NULL);

   /* user samplers, plus our bitmap sampler */
   {
      struct pipe_sampler_state *samplers[PIPE_MAX_SAMPLERS];
      uint num = MAX2(fpv->bitmap_sampler + 1,
                      st->state.num_samplers[PIPE_SHADER_FRAGMENT]);
      uint i;
      for (i = 0; i < st->state.num_samplers[PIPE_SHADER_FRAGMENT]; i++) {
         samplers[i] = &st->state.samplers[PIPE_SHADER_FRAGMENT][i];
      }
      samplers[fpv->bitmap_sampler] =
         &st->bitmap.samplers[sv->texture->target != PIPE_TEXTURE_RECT];
      cso_set_samplers(cso, PIPE_SHADER_FRAGMENT, num,
                       (const struct pipe_sampler_state **) samplers);
   }

   /* user textures, plus the bitmap texture */
   {
      struct pipe_sampler_view *sampler_views[PIPE_MAX_SAMPLERS];
      uint num = MAX2(fpv->bitmap_sampler + 1,
                      st->state.num_sampler_views[PIPE_SHADER_FRAGMENT]);
      memcpy(sampler_views, st->state.sampler_views[PIPE_SHADER_FRAGMENT],
             sizeof(sampler_views));
      sampler_views[fpv->bitmap_sampler] = sv;
      cso_set_sampler_views(cso, PIPE_SHADER_FRAGMENT, num, sampler_views);
   }

   /* viewport state: viewport matching window dims */
   {
      const GLboolean invert = st->state.fb_orientation == Y_0_TOP;
      const GLfloat width = (GLfloat)st->state.framebuffer.width;
      const GLfloat height = (GLfloat)st->state.framebuffer.height;
      struct pipe_viewport_state vp;
      vp.scale[0] =  0.5f * width;
      vp.scale[1] = height * (invert ? -0.5f : 0.5f);
      vp.scale[2] = 0.5f;
      vp.scale[3] = 1.0f;
      vp.translate[0] = 0.5f * width;
      vp.translate[1] = 0.5f * height;
      vp.translate[2] = 0.5f;
      vp.translate[3] = 0.0f;
      cso_set_viewport(cso, &vp);
   }

   cso_set_vertex_elements(cso, 3, st->velems_util_draw);
   cso_set_stream_outputs(st->cso_context, 0, NULL, NULL);

   /* convert Z from [0,1] to [-1,-1] to match viewport Z scale/bias */
   z = z * 2.0f - 1.0f;

   /* draw textured quad */
   setup_bitmap_vertex_data(st, sv->texture->target != PIPE_TEXTURE_RECT,
			    x, y, width, height, z, color, &vbuf, &offset);

   if (vbuf) {
      util_draw_vertex_buffer(pipe, st->cso_context, vbuf,
                              cso_get_aux_vertex_buffer_slot(st->cso_context),
                              offset,
                              PIPE_PRIM_TRIANGLE_FAN,
                              4,  /* verts */
                              3); /* attribs/vert */
   }

   /* restore state */
   cso_restore_rasterizer(cso);
   cso_restore_samplers(cso, PIPE_SHADER_FRAGMENT);
   cso_restore_sampler_views(cso, PIPE_SHADER_FRAGMENT);
   cso_restore_viewport(cso);
   cso_restore_fragment_shader(cso);
   cso_restore_vertex_shader(cso);
   cso_restore_geometry_shader(cso);
   cso_restore_vertex_elements(cso);
   cso_restore_aux_vertex_buffer_slot(cso);
   cso_restore_stream_outputs(cso);

   pipe_resource_reference(&vbuf, NULL);
}


static void
reset_cache(struct st_context *st)
{
   struct bitmap_cache *cache = st->bitmap.cache;

   /*memset(cache->buffer, 0xff, sizeof(cache->buffer));*/
   cache->empty = GL_TRUE;

   cache->xmin = 1000000;
   cache->xmax = -1000000;
   cache->ymin = 1000000;
   cache->ymax = -1000000;

   assert(!cache->texture);

   /* allocate a new texture */
   cache->texture = st_texture_create(st, PIPE_TEXTURE_2D,
                                      st->bitmap.tex_format, 0,
                                      BITMAP_CACHE_WIDTH, BITMAP_CACHE_HEIGHT,
                                      1, 1, 0,
				      PIPE_BIND_SAMPLER_VIEW);
}


/** Print bitmap image to stdout (debug) */
static void
print_cache(const struct bitmap_cache *cache)
{
   int i, j, k;

   for (i = 0; i < BITMAP_CACHE_HEIGHT; i++) {
      k = BITMAP_CACHE_WIDTH * (BITMAP_CACHE_HEIGHT - i - 1);
      for (j = 0; j < BITMAP_CACHE_WIDTH; j++) {
         if (cache->buffer[k])
            printf("X");
         else
            printf(" ");
         k++;
      }
      printf("\n");
   }
}


/**
 * Create gallium pipe_transfer object for the bitmap cache.
 */
static void
create_cache_trans(struct st_context *st)
{
   struct pipe_context *pipe = st->pipe;
   struct bitmap_cache *cache = st->bitmap.cache;

   if (cache->trans)
      return;

   /* Map the texture transfer.
    * Subsequent glBitmap calls will write into the texture image.
    */
   cache->buffer = pipe_transfer_map(pipe, cache->texture, 0, 0,
                                     PIPE_TRANSFER_WRITE, 0, 0,
                                     BITMAP_CACHE_WIDTH,
                                     BITMAP_CACHE_HEIGHT, &cache->trans);

   /* init image to all 0xff */
   memset(cache->buffer, 0xff, cache->trans->stride * BITMAP_CACHE_HEIGHT);
}


/**
 * If there's anything in the bitmap cache, draw/flush it now.
 */
void
st_flush_bitmap_cache(struct st_context *st)
{
   if (!st->bitmap.cache->empty) {
      struct bitmap_cache *cache = st->bitmap.cache;

      struct pipe_context *pipe = st->pipe;
      struct pipe_sampler_view *sv;

      assert(cache->xmin <= cache->xmax);

/*    printf("flush size %d x %d  at %d, %d\n",
             cache->xmax - cache->xmin,
             cache->ymax - cache->ymin,
             cache->xpos, cache->ypos);
*/

      /* The texture transfer has been mapped until now.
          * So unmap and release the texture transfer before drawing.
          */
      if (cache->trans && cache->buffer) {
         if (0)
            print_cache(cache);
         pipe_transfer_unmap(pipe, cache->trans);
         cache->buffer = NULL;
         cache->trans = NULL;
      }

      sv = st_create_texture_sampler_view(st->pipe, cache->texture);
      if (sv) {
         draw_bitmap_quad(st->ctx,
                          cache->xpos,
                          cache->ypos,
                          cache->zpos,
                          BITMAP_CACHE_WIDTH, BITMAP_CACHE_HEIGHT,
                          sv,
                          cache->color);

         pipe_sampler_view_reference(&sv, NULL);
      }

      /* release/free the texture */
      pipe_resource_reference(&cache->texture, NULL);

      reset_cache(st);
   }
}


/**
 * Try to accumulate this glBitmap call in the bitmap cache.
 * \return  GL_TRUE for success, GL_FALSE if bitmap is too large, etc.
 */
static GLboolean
accum_bitmap(struct gl_context *ctx,
             GLint x, GLint y, GLsizei width, GLsizei height,
             const struct gl_pixelstore_attrib *unpack,
             const GLubyte *bitmap )
{
   struct st_context *st = ctx->st;
   struct bitmap_cache *cache = st->bitmap.cache;
   int px = -999, py = -999;
   const GLfloat z = st->ctx->Current.RasterPos[2];

   if (width > BITMAP_CACHE_WIDTH ||
       height > BITMAP_CACHE_HEIGHT)
      return GL_FALSE; /* too big to cache */

   if (!cache->empty) {
      px = x - cache->xpos;  /* pos in buffer */
      py = y - cache->ypos;
      if (px < 0 || px + width > BITMAP_CACHE_WIDTH ||
          py < 0 || py + height > BITMAP_CACHE_HEIGHT ||
          !TEST_EQ_4V(st->ctx->Current.RasterColor, cache->color) ||
          ((fabs(z - cache->zpos) > Z_EPSILON))) {
         /* This bitmap would extend beyond cache bounds, or the bitmap
          * color is changing
          * so flush and continue.
          */
         st_flush_bitmap_cache(st);
      }
   }

   if (cache->empty) {
      /* Initialize.  Center bitmap vertically in the buffer. */
      px = 0;
      py = (BITMAP_CACHE_HEIGHT - height) / 2;
      cache->xpos = x;
      cache->ypos = y - py;
      cache->zpos = z;
      cache->empty = GL_FALSE;
      COPY_4FV(cache->color, st->ctx->Current.RasterColor);
   }

   assert(px != -999);
   assert(py != -999);

   if (x < cache->xmin)
      cache->xmin = x;
   if (y < cache->ymin)
      cache->ymin = y;
   if (x + width > cache->xmax)
      cache->xmax = x + width;
   if (y + height > cache->ymax)
      cache->ymax = y + height;

   /* create the transfer if needed */
   create_cache_trans(st);

   /* PBO source... */
   bitmap = _mesa_map_pbo_source(ctx, unpack, bitmap);
   if (!bitmap) {
      return FALSE;
   }

   unpack_bitmap(st, px, py, width, height, unpack, bitmap,
                 cache->buffer, BITMAP_CACHE_WIDTH);

   _mesa_unmap_pbo_source(ctx, unpack);

   return GL_TRUE; /* accumulated */
}



/**
 * Called via ctx->Driver.Bitmap()
 */
static void
st_Bitmap(struct gl_context *ctx, GLint x, GLint y,
          GLsizei width, GLsizei height,
          const struct gl_pixelstore_attrib *unpack, const GLubyte *bitmap )
{
   struct st_context *st = st_context(ctx);
   struct pipe_resource *pt;

   if (width == 0 || height == 0)
      return;

   st_validate_state(st);

   if (!st->bitmap.vs) {
      /* create pass-through vertex shader now */
      const uint semantic_names[] = { TGSI_SEMANTIC_POSITION,
                                      TGSI_SEMANTIC_COLOR,
        st->needs_texcoord_semantic ? TGSI_SEMANTIC_TEXCOORD :
                                      TGSI_SEMANTIC_GENERIC };
      const uint semantic_indexes[] = { 0, 0, 0 };
      st->bitmap.vs = util_make_vertex_passthrough_shader(st->pipe, 3,
                                                          semantic_names,
                                                          semantic_indexes);
   }

   if (UseBitmapCache && accum_bitmap(ctx, x, y, width, height, unpack, bitmap))
      return;

   pt = make_bitmap_texture(ctx, width, height, unpack, bitmap);
   if (pt) {
      struct pipe_sampler_view *sv =
         st_create_texture_sampler_view(st->pipe, pt);

      assert(pt->target == PIPE_TEXTURE_2D || pt->target == PIPE_TEXTURE_RECT);

      if (sv) {
         draw_bitmap_quad(ctx, x, y, ctx->Current.RasterPos[2],
                          width, height, sv,
                          st->ctx->Current.RasterColor);

         pipe_sampler_view_reference(&sv, NULL);
      }

      /* release/free the texture */
      pipe_resource_reference(&pt, NULL);
   }
}


/** Per-context init */
void
st_init_bitmap_functions(struct dd_function_table *functions)
{
   functions->Bitmap = st_Bitmap;
}


/** Per-context init */
void
st_init_bitmap(struct st_context *st)
{
   struct pipe_sampler_state *sampler = &st->bitmap.samplers[0];
   struct pipe_context *pipe = st->pipe;
   struct pipe_screen *screen = pipe->screen;

   /* init sampler state once */
   memset(sampler, 0, sizeof(*sampler));
   sampler->wrap_s = PIPE_TEX_WRAP_CLAMP;
   sampler->wrap_t = PIPE_TEX_WRAP_CLAMP;
   sampler->wrap_r = PIPE_TEX_WRAP_CLAMP;
   sampler->min_img_filter = PIPE_TEX_FILTER_NEAREST;
   sampler->min_mip_filter = PIPE_TEX_MIPFILTER_NONE;
   sampler->mag_img_filter = PIPE_TEX_FILTER_NEAREST;
   st->bitmap.samplers[1] = *sampler;
   st->bitmap.samplers[1].normalized_coords = 1;

   /* init baseline rasterizer state once */
   memset(&st->bitmap.rasterizer, 0, sizeof(st->bitmap.rasterizer));
   st->bitmap.rasterizer.half_pixel_center = 1;
   st->bitmap.rasterizer.bottom_edge_rule = 1;
   st->bitmap.rasterizer.depth_clip = 1;

   /* find a usable texture format */
   if (screen->is_format_supported(screen, PIPE_FORMAT_I8_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW)) {
      st->bitmap.tex_format = PIPE_FORMAT_I8_UNORM;
   }
   else if (screen->is_format_supported(screen, PIPE_FORMAT_A8_UNORM,
                                        PIPE_TEXTURE_2D, 0,
                                        PIPE_BIND_SAMPLER_VIEW)) {
      st->bitmap.tex_format = PIPE_FORMAT_A8_UNORM;
   }
   else if (screen->is_format_supported(screen, PIPE_FORMAT_L8_UNORM,
                                        PIPE_TEXTURE_2D, 0,
                                        PIPE_BIND_SAMPLER_VIEW)) {
      st->bitmap.tex_format = PIPE_FORMAT_L8_UNORM;
   }
   else {
      /* XXX support more formats */
      assert(0);
   }

   /* alloc bitmap cache object */
   st->bitmap.cache = ST_CALLOC_STRUCT(bitmap_cache);

   reset_cache(st);
}


/** Per-context tear-down */
void
st_destroy_bitmap(struct st_context *st)
{
   struct pipe_context *pipe = st->pipe;
   struct bitmap_cache *cache = st->bitmap.cache;

   if (st->bitmap.vs) {
      cso_delete_vertex_shader(st->cso_context, st->bitmap.vs);
      st->bitmap.vs = NULL;
   }

   if (cache) {
      if (cache->trans && cache->buffer) {
         pipe_transfer_unmap(pipe, cache->trans);
      }
      pipe_resource_reference(&st->bitmap.cache->texture, NULL);
      free(st->bitmap.cache);
      st->bitmap.cache = NULL;
   }
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d460 1
a460 1
   st->bitmap.rasterizer.scissor = ctx->Scissor.Enabled;
d516 1
a516 1
   cso_set_stream_outputs(st->cso_context, 0, NULL, 0);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a36 1
#include "main/mfeatures.h"
d54 1
a58 2
#if FEATURE_drawpix

d141 1
a141 1
   p->Instructions[ic].SrcReg[0].Index = FRAG_ATTRIB_TEX0;
d162 1
a162 1
   p->InputsRead = FRAG_BIT_TEX0;
d173 17
d217 1
d226 5
a230 1
   bitmap_prog = make_bitmap_fragment_program(st->ctx, sampler);
d232 6
a237 5
   newProg = _mesa_combine_programs(st->ctx,
                                    &bitmap_prog->Base.Base,
                                    &fpIn->Base);
   /* done with this after combining */
   st_reference_fragprog(st, &bitmap_prog, NULL);
d301 1
a301 1
                          0, width, height, 1, 1,
d308 3
a310 5
   transfer = pipe_get_transfer(st->pipe, pt, 0, 0,
                                PIPE_TRANSFER_WRITE,
                                0, 0, width, height);

   dest = pipe_transfer_map(pipe, transfer);
a320 2
   pipe->transfer_destroy(pipe, transfer);

d324 1
a324 1
static GLuint
d327 3
a329 1
                         float z, const float color[4])
d331 2
a332 4
   struct pipe_context *pipe = st->pipe;
   const struct gl_framebuffer *fb = st->ctx->DrawBuffer;
   const GLfloat fb_width = (GLfloat)fb->Width;
   const GLfloat fb_height = (GLfloat)fb->Height;
a342 1
   const GLuint max_slots = 1; /* 4096 / sizeof(st->bitmap.vertices); */
d344 1
d348 2
a349 2
      sRight = width;
      tBot = height;
d352 3
a354 21
   /* XXX: Need to improve buffer_write to allow NO_WAIT (as well as
    * no_flush) updates to buffers where we know there is no conflict
    * with previous data.  Currently using max_slots > 1 will cause
    * synchronous rendering if the driver flushes its command buffers
    * between one bitmap and the next.  Our flush hook below isn't
    * sufficient to catch this as the driver doesn't tell us when it
    * flushes its own command buffers.  Until this gets fixed, pay the
    * price of allocating a new buffer for each bitmap cache-flush to
    * avoid synchronous rendering.
    */
   if (st->bitmap.vbuf_slot >= max_slots) {
      pipe_resource_reference(&st->bitmap.vbuf, NULL);
      st->bitmap.vbuf_slot = 0;
   }

   if (!st->bitmap.vbuf) {
      st->bitmap.vbuf = pipe_buffer_create(pipe->screen, 
                                           PIPE_BIND_VERTEX_BUFFER,
                                           PIPE_USAGE_STREAM,
                                           max_slots *
                                           sizeof(st->bitmap.vertices));
d360 9
a368 9
   st->bitmap.vertices[0][0][0] = clip_x0;
   st->bitmap.vertices[0][0][1] = clip_y0;
   st->bitmap.vertices[0][2][0] = sLeft;
   st->bitmap.vertices[0][2][1] = tTop;

   st->bitmap.vertices[1][0][0] = clip_x1;
   st->bitmap.vertices[1][0][1] = clip_y0;
   st->bitmap.vertices[1][2][0] = sRight;
   st->bitmap.vertices[1][2][1] = tTop;
d370 4
a373 4
   st->bitmap.vertices[2][0][0] = clip_x1;
   st->bitmap.vertices[2][0][1] = clip_y1;
   st->bitmap.vertices[2][2][0] = sRight;
   st->bitmap.vertices[2][2][1] = tBot;
d375 4
a378 4
   st->bitmap.vertices[3][0][0] = clip_x0;
   st->bitmap.vertices[3][0][1] = clip_y1;
   st->bitmap.vertices[3][2][0] = sLeft;
   st->bitmap.vertices[3][2][1] = tBot;
d382 9
a390 17
      st->bitmap.vertices[i][0][2] = z;
      st->bitmap.vertices[i][0][3] = 1.0;
      st->bitmap.vertices[i][1][0] = color[0];
      st->bitmap.vertices[i][1][1] = color[1];
      st->bitmap.vertices[i][1][2] = color[2];
      st->bitmap.vertices[i][1][3] = color[3];
      st->bitmap.vertices[i][2][2] = 0.0; /*R*/
      st->bitmap.vertices[i][2][3] = 1.0; /*Q*/
   }

   /* put vertex data into vbuf */
   pipe_buffer_write_nooverlap(st->pipe,
                               st->bitmap.vbuf,
                               st->bitmap.vbuf_slot
                               * sizeof(st->bitmap.vertices),
                               sizeof st->bitmap.vertices,
                               st->bitmap.vertices);
d392 1
a392 1
   return st->bitmap.vbuf_slot++ * sizeof st->bitmap.vertices;
d413 1
d418 2
d449 2
a450 2
   cso_save_samplers(cso);
   cso_save_fragment_sampler_views(cso);
d453 1
d455 1
d457 1
a457 1
   cso_save_vertex_buffers(cso);
d469 3
d475 2
a476 1
      uint num = MAX2(fpv->bitmap_sampler + 1, st->state.num_samplers);
d478 2
a479 2
      for (i = 0; i < st->state.num_samplers; i++) {
         samplers[i] = &st->state.samplers[i];
d483 2
a484 1
      cso_set_samplers(cso, num, (const struct pipe_sampler_state **) samplers);
d490 4
a493 2
      uint num = MAX2(fpv->bitmap_sampler + 1, st->state.num_textures);
      memcpy(sampler_views, st->state.sampler_views, sizeof(sampler_views));
d495 1
a495 1
      cso_set_fragment_sampler_views(cso, num, sampler_views);
d500 3
a502 4
      const struct gl_framebuffer *fb = st->ctx->DrawBuffer;
      const GLboolean invert = (st_fb_orientation(fb) == Y_0_TOP);
      const GLfloat width = (GLfloat)fb->Width;
      const GLfloat height = (GLfloat)fb->Height;
d516 1
d519 1
a519 1
   z = z * 2.0 - 1.0;
d522 2
a523 8
   offset = setup_bitmap_vertex_data(st,
                                     sv->texture->target != PIPE_TEXTURE_RECT,
                                     x, y, width, height, z, color);

   util_draw_vertex_buffer(pipe, st->cso_context, st->bitmap.vbuf, offset,
                           PIPE_PRIM_TRIANGLE_FAN,
                           4,  /* verts */
                           3); /* attribs/vert */
d525 8
d536 2
a537 2
   cso_restore_samplers(cso);
   cso_restore_fragment_sampler_views(cso);
d541 1
d543 4
a546 1
   cso_restore_vertex_buffers(cso);
a552 1
   struct pipe_context *pipe = st->pipe;
a562 5
   if (cache->trans) {
      pipe->transfer_destroy(pipe, cache->trans);
      cache->trans = NULL;
   }

d569 1
a569 1
                                      1, 1,
d609 4
a612 5
   cache->trans = pipe_get_transfer(st->pipe, cache->texture, 0, 0,
                                    PIPE_TRANSFER_WRITE, 0, 0,
                                    BITMAP_CACHE_WIDTH,
                                    BITMAP_CACHE_HEIGHT);
   cache->buffer = pipe_transfer_map(pipe, cache->trans);
d628 9
a636 10
      if (st->ctx->DrawBuffer) {
         struct pipe_context *pipe = st->pipe;
         struct pipe_sampler_view *sv;

         assert(cache->xmin <= cache->xmax);
 
/*         printf("flush size %d x %d  at %d, %d\n",
                cache->xmax - cache->xmin,
                cache->ymax - cache->ymin,
                cache->xpos, cache->ypos);
d639 1
a639 1
         /* The texture transfer has been mapped until now.
d642 7
a648 19
         if (cache->trans) {
            if (0)
               print_cache(cache);
            pipe_transfer_unmap(pipe, cache->trans);
            cache->buffer = NULL;

            pipe->transfer_destroy(pipe, cache->trans);
            cache->trans = NULL;
         }

         sv = st_create_texture_sampler_view(st->pipe, cache->texture);
         if (sv) {
            draw_bitmap_quad(st->ctx,
                             cache->xpos,
                             cache->ypos,
                             cache->zpos,
                             BITMAP_CACHE_WIDTH, BITMAP_CACHE_HEIGHT,
                             sv,
                             cache->color);
d650 11
a660 2
            pipe_sampler_view_reference(&sv, NULL);
         }
a671 16
 * Flush bitmap cache and release vertex buffer.
 */
void
st_flush_bitmap( struct st_context *st )
{
   st_flush_bitmap_cache(st);

   /* Release vertex buffer to avoid synchronous rendering if we were
    * to map it in the next frame.
    */
   pipe_resource_reference(&st->bitmap.vbuf, NULL);
   st->bitmap.vbuf_slot = 0;
}


/**
d676 1
a676 1
accum_bitmap(struct st_context *st,
d681 1
d731 6
d740 2
d767 1
d775 1
a775 1
   if (UseBitmapCache && accum_bitmap(st, x, y, width, height, unpack, bitmap))
d828 3
a830 1
   st->bitmap.rasterizer.gl_rasterization_rules = 1;
a871 5
   if (st->bitmap.vbuf) {
      pipe_resource_reference(&st->bitmap.vbuf, NULL);
      st->bitmap.vbuf = NULL;
   }

d873 1
a873 1
      if (cache->trans) {
a874 1
         pipe->transfer_destroy(pipe, cache->trans);
a880 2

#endif /* FEATURE_drawpix */
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d37 2
d190 4
d195 16
a210 5
static struct st_fragment_program *
combined_bitmap_fragment_program(struct gl_context *ctx)
{
   struct st_context *st = st_context(ctx);
   struct st_fragment_program *stfp = st->fp;
d212 5
a216 18
   if (!stfp->bitmap_program) {
      /*
       * Generate new program which is the user-defined program prefixed
       * with the bitmap sampler/kill instructions.
       */
      struct st_fragment_program *bitmap_prog;
      uint sampler;

      sampler = find_free_bit(st->fp->Base.Base.SamplersUsed);
      bitmap_prog = make_bitmap_fragment_program(ctx, sampler);

      stfp->bitmap_program = (struct st_fragment_program *)
         _mesa_combine_programs(ctx,
                                &bitmap_prog->Base.Base, &stfp->Base.Base);
      stfp->bitmap_program->bitmap_sampler = sampler;

      /* done with this after combining */
      st_reference_fragprog(st, &bitmap_prog, NULL);
d219 7
a225 8
      {
         struct gl_program *p = &stfp->bitmap_program->Base.Base;
         printf("Combined bitmap program:\n");
         _mesa_print_program(p);
         printf("InputsRead: 0x%x\n", p->InputsRead);
         printf("OutputsWritten: 0x%x\n", p->OutputsWritten);
         _mesa_print_parameter_list(p->Parameters);
      }
d228 3
a230 5
      /* translate to TGSI tokens */
      st_translate_fragment_program(st, stfp->bitmap_program);
   }

   return stfp->bitmap_program;
d280 1
a280 1
                          0, width, height, 1,
d353 3
a355 1
                                           max_slots * sizeof(st->bitmap.vertices));
d395 5
a399 4
                                           st->bitmap.vbuf,
                                           st->bitmap.vbuf_slot * sizeof st->bitmap.vertices,
                                           sizeof st->bitmap.vertices,
                                           st->bitmap.vertices);
d418 2
a419 1
   struct st_fragment_program *stfp;
d423 5
a427 1
   stfp = combined_bitmap_fragment_program(ctx);
d440 1
a440 1
      st_upload_constants(st, stfp->Base.Base.Parameters, PIPE_SHADER_FRAGMENT);
d449 2
a450 1
   maxSize = 1 << (pipe->screen->get_param(pipe->screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS) - 1);
d461 1
d468 1
a468 1
   cso_set_fragment_shader_handle(cso, stfp->driver_shader);
d476 1
a476 1
      uint num = MAX2(stfp->bitmap_sampler + 1, st->state.num_samplers);
d481 2
a482 1
      samplers[stfp->bitmap_sampler] = &st->bitmap.samplers[sv->texture->target != PIPE_TEXTURE_RECT];
d489 1
a489 1
      uint num = MAX2(stfp->bitmap_sampler + 1, st->state.num_textures);
d491 1
a491 1
      sampler_views[stfp->bitmap_sampler] = sv;
d519 3
a521 1
   offset = setup_bitmap_vertex_data(st, sv->texture->target != PIPE_TEXTURE_RECT, x, y, width, height, z, color);
d523 1
a523 1
   util_draw_vertex_buffer(pipe, st->bitmap.vbuf, offset,
d537 1
d566 1
a566 1
                                      1,
d591 3
d672 3
a674 1
/* Flush bitmap cache and release vertex buffer.
d760 2
a761 1
st_Bitmap(struct gl_context *ctx, GLint x, GLint y, GLsizei width, GLsizei height,
d788 2
a789 1
      struct pipe_sampler_view *sv = st_create_texture_sampler_view(st->pipe, pt);
d839 3
a841 2
   if (screen->is_format_supported(screen, PIPE_FORMAT_I8_UNORM, PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW, 0)) {
d844 3
a846 2
   else if (screen->is_format_supported(screen, PIPE_FORMAT_A8_UNORM, PIPE_TEXTURE_2D, 0,
                                        PIPE_BIND_SAMPLER_VIEW, 0)) {
d849 3
a851 2
   else if (screen->is_format_supported(screen, PIPE_FORMAT_L8_UNORM, PIPE_TEXTURE_2D, 0,
                                        PIPE_BIND_SAMPLER_VIEW, 0)) {
a871 2


@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d37 2
a38 2
#include "shader/program.h"
#include "shader/prog_print.h"
a45 1
#include "st_inlines.h"
d49 1
d53 1
a53 1
#include "shader/prog_instruction.h"
d57 1
d96 1
a96 1
   struct pipe_texture *texture;
d116 1
a116 1
make_bitmap_fragment_program(GLcontext *ctx, GLuint samplerIndex)
d118 1
d150 1
a150 1
   if (ctx->st->bitmap.tex_format == PIPE_FORMAT_L8_UNORM)
d190 1
a190 1
combined_bitmap_fragment_program(GLcontext *ctx)
d192 1
a192 1
   struct st_context *st = ctx->st;
d258 2
a259 2
static struct pipe_texture *
make_bitmap_texture(GLcontext *ctx, GLsizei width, GLsizei height,
d263 2
a264 2
   struct pipe_context *pipe = ctx->st->pipe;
   struct pipe_screen *screen = pipe->screen;
d267 1
a267 1
   struct pipe_texture *pt;
d278 1
a278 1
   pt = st_texture_create(ctx->st, PIPE_TEXTURE_2D, ctx->st->bitmap.tex_format,
d280 1
a280 1
                          PIPE_TEXTURE_USAGE_SAMPLER);
d286 3
a288 3
   transfer = st_no_flush_get_tex_transfer(st_context(ctx), pt, 0, 0, 0,
					   PIPE_TRANSFER_WRITE,
					   0, 0, width, height);
d290 1
a290 1
   dest = screen->transfer_map(screen, transfer);
d294 1
a294 1
   unpack_bitmap(ctx->st, 0, 0, width, height, unpack, bitmap,
d300 2
a301 2
   screen->transfer_unmap(screen, transfer);
   screen->tex_transfer_destroy(transfer);
d307 1
a307 1
setup_bitmap_vertex_data(struct st_context *st,
d319 2
a320 2
   const GLfloat sLeft = (GLfloat)0.0, sRight = (GLfloat)1.0;
   const GLfloat tTop = (GLfloat)0.0, tBot = (GLfloat)1.0 - tTop;
d325 8
a343 3
   const GLuint max_slots = 1; /* 4096 / sizeof(st->bitmap.vertices); */
   GLuint i;

d345 1
a345 1
      pipe_buffer_reference(&st->bitmap.vbuf, NULL);
d350 2
a351 2
      st->bitmap.vbuf = pipe_buffer_create(pipe->screen, 32, 
                                           PIPE_BUFFER_USAGE_VERTEX,
d391 1
a391 1
   st_no_flush_pipe_buffer_write_nooverlap(st,
d406 1
a406 1
draw_bitmap_quad(GLcontext *ctx, GLint x, GLint y, GLfloat z,
d408 1
a408 1
                 struct pipe_texture *pt,
d411 3
a413 3
   struct st_context *st = ctx->st;
   struct pipe_context *pipe = ctx->st->pipe;
   struct cso_context *cso = ctx->st->cso_context;
d446 1
a446 1
   cso_save_sampler_textures(cso);
d450 1
d470 1
a470 1
      samplers[stfp->bitmap_sampler] = &st->bitmap.sampler;
d476 1
a476 1
      struct pipe_texture *textures[PIPE_MAX_SAMPLERS];
d478 3
a480 3
      memcpy(textures, st->state.sampler_texture, sizeof(textures));
      textures[stfp->bitmap_sampler] = pt;
      cso_set_sampler_textures(cso, num, textures);
d501 2
d507 1
a507 1
   offset = setup_bitmap_vertex_data(st, x, y, width, height, z, color);
d518 1
a518 1
   cso_restore_sampler_textures(cso);
d522 1
a529 1
   struct pipe_screen *screen = pipe->screen;
d541 1
a541 1
      screen->tex_transfer_destroy(cache->trans);
d551 2
a552 1
                                      1, PIPE_TEXTURE_USAGE_SAMPLER);
a579 1
   struct pipe_screen *screen = pipe->screen;
d588 5
a592 5
   cache->trans = st_no_flush_get_tex_transfer(st, cache->texture, 0, 0, 0,
					       PIPE_TRANSFER_WRITE, 0, 0,
					       BITMAP_CACHE_WIDTH,
					       BITMAP_CACHE_HEIGHT);
   cache->buffer = screen->transfer_map(screen, cache->trans);
d610 1
a610 1
         struct pipe_screen *screen = pipe->screen;
d626 1
a626 1
            screen->transfer_unmap(screen, cache->trans);
d629 1
a629 1
            screen->tex_transfer_destroy(cache->trans);
d633 12
a644 7
         draw_bitmap_quad(st->ctx,
                          cache->xpos,
                          cache->ypos,
                          cache->zpos,
                          BITMAP_CACHE_WIDTH, BITMAP_CACHE_HEIGHT,
                          cache->texture,
                          cache->color);
d648 1
a648 1
      pipe_texture_reference(&cache->texture, NULL);
d664 1
a664 1
   pipe_buffer_reference(&st->bitmap.vbuf, NULL);
d740 1
a740 1
st_Bitmap(GLcontext *ctx, GLint x, GLint y, GLsizei width, GLsizei height,
d743 2
a744 2
   struct st_context *st = ctx->st;
   struct pipe_texture *pt;
d767 12
a778 4
      assert(pt->target == PIPE_TEXTURE_2D);
      draw_bitmap_quad(ctx, x, y, ctx->Current.RasterPos[2],
                       width, height, pt,
                       st->ctx->Current.RasterColor);
d780 1
a780 1
      pipe_texture_reference(&pt, NULL);
d797 1
a797 1
   struct pipe_sampler_state *sampler = &st->bitmap.sampler;
d809 2
a810 1
   sampler->normalized_coords = 1;
d817 2
a818 2
   if (screen->is_format_supported(screen, PIPE_FORMAT_I8_UNORM, PIPE_TEXTURE_2D, 
                                   PIPE_TEXTURE_USAGE_SAMPLER, 0)) {
d821 2
a822 2
   else if (screen->is_format_supported(screen, PIPE_FORMAT_A8_UNORM, PIPE_TEXTURE_2D, 
                                        PIPE_TEXTURE_USAGE_SAMPLER, 0)) {
d825 2
a826 2
   else if (screen->is_format_supported(screen, PIPE_FORMAT_L8_UNORM, PIPE_TEXTURE_2D, 
                                        PIPE_TEXTURE_USAGE_SAMPLER, 0)) {
a845 1
   struct pipe_screen *screen = pipe->screen;
d856 1
a856 1
      pipe_buffer_reference(&st->bitmap.vbuf, NULL);
d862 2
a863 2
         screen->transfer_unmap(screen, cache->trans);
         screen->tex_transfer_destroy(cache->trans);
d865 1
a865 1
      pipe_texture_reference(&st->bitmap.cache->texture, NULL);
d870 2
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d37 2
a38 2
#include "program/program.h"
#include "program/prog_print.h"
d46 1
a49 1
#include "pipe/p_shader_tokens.h"
d53 1
a53 1
#include "program/prog_instruction.h"
a56 1
#if FEATURE_drawpix
d95 1
a95 1
   struct pipe_resource *texture;
d115 1
a115 1
make_bitmap_fragment_program(struct gl_context *ctx, GLuint samplerIndex)
a116 1
   struct st_context *st = st_context(ctx);
d148 1
a148 1
   if (st->bitmap.tex_format == PIPE_FORMAT_L8_UNORM)
d188 1
a188 1
combined_bitmap_fragment_program(struct gl_context *ctx)
d190 1
a190 1
   struct st_context *st = st_context(ctx);
d256 2
a257 2
static struct pipe_resource *
make_bitmap_texture(struct gl_context *ctx, GLsizei width, GLsizei height,
d261 2
a262 2
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
d265 1
a265 1
   struct pipe_resource *pt;
d276 1
a276 1
   pt = st_texture_create(st, st->internal_target, st->bitmap.tex_format,
d278 1
a278 1
                          PIPE_BIND_SAMPLER_VIEW);
d284 3
a286 3
   transfer = pipe_get_transfer(st->pipe, pt, 0, 0,
                                PIPE_TRANSFER_WRITE,
                                0, 0, width, height);
d288 1
a288 1
   dest = pipe_transfer_map(pipe, transfer);
d292 1
a292 1
   unpack_bitmap(st, 0, 0, width, height, unpack, bitmap,
d298 2
a299 2
   pipe_transfer_unmap(pipe, transfer);
   pipe->transfer_destroy(pipe, transfer);
d305 1
a305 1
setup_bitmap_vertex_data(struct st_context *st, bool normalized,
d317 2
a318 2
   GLfloat sLeft = (GLfloat)0.0, sRight = (GLfloat)1.0;
   GLfloat tTop = (GLfloat)0.0, tBot = (GLfloat)1.0 - tTop;
a322 8
   const GLuint max_slots = 1; /* 4096 / sizeof(st->bitmap.vertices); */
   GLuint i;

   if(!normalized)
   {
      sRight = width;
      tBot = height;
   }
d334 3
d338 1
a338 1
      pipe_resource_reference(&st->bitmap.vbuf, NULL);
d343 2
a344 2
      st->bitmap.vbuf = pipe_buffer_create(pipe->screen, 
                                           PIPE_BIND_VERTEX_BUFFER,
d384 1
a384 1
   pipe_buffer_write_nooverlap(st->pipe,
d399 1
a399 1
draw_bitmap_quad(struct gl_context *ctx, GLint x, GLint y, GLfloat z,
d401 1
a401 1
                 struct pipe_sampler_view *sv,
d404 3
a406 3
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   struct cso_context *cso = st->cso_context;
d439 1
a439 1
   cso_save_fragment_sampler_views(cso);
a442 1
   cso_save_vertex_elements(cso);
d462 1
a462 1
      samplers[stfp->bitmap_sampler] = &st->bitmap.samplers[sv->texture->target != PIPE_TEXTURE_RECT];
d468 1
a468 1
      struct pipe_sampler_view *sampler_views[PIPE_MAX_SAMPLERS];
d470 3
a472 3
      memcpy(sampler_views, st->state.sampler_views, sizeof(sampler_views));
      sampler_views[stfp->bitmap_sampler] = sv;
      cso_set_fragment_sampler_views(cso, num, sampler_views);
a492 2
   cso_set_vertex_elements(cso, 3, st->velems_util_draw);

d497 1
a497 1
   offset = setup_bitmap_vertex_data(st, sv->texture->target != PIPE_TEXTURE_RECT, x, y, width, height, z, color);
d508 1
a508 1
   cso_restore_fragment_sampler_views(cso);
a511 1
   cso_restore_vertex_elements(cso);
d519 1
d531 1
a531 1
      pipe->transfer_destroy(pipe, cache->trans);
d541 1
a541 2
                                      1,
				      PIPE_BIND_SAMPLER_VIEW);
d569 1
d578 5
a582 5
   cache->trans = pipe_get_transfer(st->pipe, cache->texture, 0, 0,
                                    PIPE_TRANSFER_WRITE, 0, 0,
                                    BITMAP_CACHE_WIDTH,
                                    BITMAP_CACHE_HEIGHT);
   cache->buffer = pipe_transfer_map(pipe, cache->trans);
d600 1
a600 1
         struct pipe_sampler_view *sv;
d616 1
a616 1
            pipe_transfer_unmap(pipe, cache->trans);
d619 1
a619 1
            pipe->transfer_destroy(pipe, cache->trans);
d623 7
a629 12
         sv = st_create_texture_sampler_view(st->pipe, cache->texture);
         if (sv) {
            draw_bitmap_quad(st->ctx,
                             cache->xpos,
                             cache->ypos,
                             cache->zpos,
                             BITMAP_CACHE_WIDTH, BITMAP_CACHE_HEIGHT,
                             sv,
                             cache->color);

            pipe_sampler_view_reference(&sv, NULL);
         }
d633 1
a633 1
      pipe_resource_reference(&cache->texture, NULL);
d649 1
a649 1
   pipe_resource_reference(&st->bitmap.vbuf, NULL);
d725 1
a725 1
st_Bitmap(struct gl_context *ctx, GLint x, GLint y, GLsizei width, GLsizei height,
d728 2
a729 2
   struct st_context *st = st_context(ctx);
   struct pipe_resource *pt;
d752 4
a755 12
      struct pipe_sampler_view *sv = st_create_texture_sampler_view(st->pipe, pt);

      assert(pt->target == PIPE_TEXTURE_2D || pt->target == PIPE_TEXTURE_RECT);

      if (sv) {
         draw_bitmap_quad(ctx, x, y, ctx->Current.RasterPos[2],
                          width, height, sv,
                          st->ctx->Current.RasterColor);

         pipe_sampler_view_reference(&sv, NULL);
      }

d757 1
a757 1
      pipe_resource_reference(&pt, NULL);
d774 1
a774 1
   struct pipe_sampler_state *sampler = &st->bitmap.samplers[0];
d786 1
a786 2
   st->bitmap.samplers[1] = *sampler;
   st->bitmap.samplers[1].normalized_coords = 1;
d793 2
a794 2
   if (screen->is_format_supported(screen, PIPE_FORMAT_I8_UNORM, PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW, 0)) {
d797 2
a798 2
   else if (screen->is_format_supported(screen, PIPE_FORMAT_A8_UNORM, PIPE_TEXTURE_2D, 0,
                                        PIPE_BIND_SAMPLER_VIEW, 0)) {
d801 2
a802 2
   else if (screen->is_format_supported(screen, PIPE_FORMAT_L8_UNORM, PIPE_TEXTURE_2D, 0,
                                        PIPE_BIND_SAMPLER_VIEW, 0)) {
d822 1
d833 1
a833 1
      pipe_resource_reference(&st->bitmap.vbuf, NULL);
d839 2
a840 2
         pipe_transfer_unmap(pipe, cache->trans);
         pipe->transfer_destroy(pipe, cache->trans);
d842 1
a842 1
      pipe_resource_reference(&st->bitmap.cache->texture, NULL);
a846 2

#endif /* FEATURE_drawpix */
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a36 1
#include "main/pbo.h"
a52 1
#include "util/u_upload_mgr.h"
d57 2
d141 1
a141 1
   p->Instructions[ic].SrcReg[0].Index = VARYING_SLOT_TEX0;
d162 1
a162 1
   p->InputsRead = VARYING_BIT_TEX0;
a172 17
static struct gl_program *
make_bitmap_fragment_program_glsl(struct st_context *st,
                                  struct st_fragment_program *orig,
                                  GLuint samplerIndex)
{
   struct gl_context *ctx = st->ctx;
   struct st_fragment_program *fp = (struct st_fragment_program *)
      ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 0);

   if (!fp)
      return NULL;
   
   get_bitmap_visitor(fp, orig->glsl_to_tgsi, samplerIndex);
   return &fp->Base.Base;
}


a187 4
 * \param st  current context
 * \param fpIn  the incoming fragment program
 * \param fpOut  the new fragment program which does fragment culling
 * \param bitmap_sampler  sampler number for the bitmap texture
d189 21
a209 21
void
st_make_bitmap_fragment_program(struct st_context *st,
                                struct gl_fragment_program *fpIn,
                                struct gl_fragment_program **fpOut,
                                GLuint *bitmap_sampler)
{
   struct st_fragment_program *bitmap_prog;
   struct st_fragment_program *stfpIn = (struct st_fragment_program *) fpIn;
   struct gl_program *newProg;
   uint sampler;

   /*
    * Generate new program which is the user-defined program prefixed
    * with the bitmap sampler/kill instructions.
    */
   sampler = find_free_bit(fpIn->Base.SamplersUsed);
   
   if (stfpIn->glsl_to_tgsi)
      newProg = make_bitmap_fragment_program_glsl(st, stfpIn, sampler);
   else {
      bitmap_prog = make_bitmap_fragment_program(st->ctx, sampler);
a210 3
      newProg = _mesa_combine_programs(st->ctx,
                                       &bitmap_prog->Base.Base,
                                       &fpIn->Base);
a212 1
   }
d215 12
a226 6
   {
      printf("Combined bitmap program:\n");
      _mesa_print_program(newProg);
      printf("InputsRead: 0x%x\n", newProg->InputsRead);
      printf("OutputsWritten: 0x%x\n", newProg->OutputsWritten);
      _mesa_print_parameter_list(newProg->Parameters);
a227 1
#endif
d229 1
a229 3
   /* return results */
   *fpOut = (struct gl_fragment_program *) newProg;
   *bitmap_sampler = sampler;
d279 1
a279 1
                          0, width, height, 1, 1, 0,
d286 5
a290 3
   dest = pipe_transfer_map(st->pipe, pt, 0, 0,
                            PIPE_TRANSFER_WRITE,
                            0, 0, width, height, &transfer);
d301 2
d306 1
a306 1
static void
d309 1
a309 3
                         float z, const float color[4],
			 struct pipe_resource **vbuf,
			 unsigned *vbuf_offset)
d311 4
a314 2
   const GLfloat fb_width = (GLfloat)st->state.framebuffer.width;
   const GLfloat fb_height = (GLfloat)st->state.framebuffer.height;
d325 1
a326 1
   float (*vertices)[3][4];  /**< vertex pos + color + texcoord */
d330 2
a331 2
      sRight = (GLfloat) width;
      tBot = (GLfloat) height;
d334 19
a352 3
   if (u_upload_alloc(st->uploader, 0, 4 * sizeof(vertices[0]),
                      vbuf_offset, vbuf, (void **) &vertices) != PIPE_OK) {
      return;
d358 9
a366 9
   vertices[0][0][0] = clip_x0;
   vertices[0][0][1] = clip_y0;
   vertices[0][2][0] = sLeft;
   vertices[0][2][1] = tTop;

   vertices[1][0][0] = clip_x1;
   vertices[1][0][1] = clip_y0;
   vertices[1][2][0] = sRight;
   vertices[1][2][1] = tTop;
d368 4
a371 4
   vertices[2][0][0] = clip_x1;
   vertices[2][0][1] = clip_y1;
   vertices[2][2][0] = sRight;
   vertices[2][2][1] = tBot;
d373 4
a376 4
   vertices[3][0][0] = clip_x0;
   vertices[3][0][1] = clip_y1;
   vertices[3][2][0] = sLeft;
   vertices[3][2][1] = tBot;
d380 16
a395 9
      vertices[i][0][2] = z;
      vertices[i][0][3] = 1.0f;
      vertices[i][1][0] = color[0];
      vertices[i][1][1] = color[1];
      vertices[i][1][2] = color[2];
      vertices[i][1][3] = color[3];
      vertices[i][2][2] = 0.0; /*R*/
      vertices[i][2][3] = 1.0; /*Q*/
   }
d397 1
a397 1
   u_upload_unmap(st->uploader);
d414 1
a414 2
   struct st_fp_variant *fpv;
   struct st_fp_variant_key key;
a416 7
   struct pipe_resource *vbuf = NULL;

   memset(&key, 0, sizeof(key));
   key.st = st;
   key.bitmap = GL_TRUE;
   key.clamp_color = st->clamp_frag_color_in_shader &&
                     st->ctx->Color._ClampFragmentColor;
d418 1
a418 1
   fpv = st_get_fp_variant(st, st->fp, &key);
d431 1
a431 1
      st_upload_constants(st, fpv->parameters, PIPE_SHADER_FRAGMENT);
d440 1
a440 2
   maxSize = 1 << (pipe->screen->get_param(pipe->screen,
                                    PIPE_CAP_MAX_TEXTURE_2D_LEVELS) - 1);
d445 2
a446 2
   cso_save_samplers(cso, PIPE_SHADER_FRAGMENT);
   cso_save_sampler_views(cso, PIPE_SHADER_FRAGMENT);
a448 1
   cso_save_stream_outputs(cso);
a449 1
   cso_save_geometry_shader(cso);
a450 1
   cso_save_aux_vertex_buffer_slot(cso);
d457 1
a457 1
   cso_set_fragment_shader_handle(cso, fpv->driver_shader);
a461 3
   /* geometry shader state: disabled */
   cso_set_geometry_shader_handle(cso, NULL);

d465 1
a465 2
      uint num = MAX2(fpv->bitmap_sampler + 1,
                      st->state.num_samplers[PIPE_SHADER_FRAGMENT]);
d467 2
a468 2
      for (i = 0; i < st->state.num_samplers[PIPE_SHADER_FRAGMENT]; i++) {
         samplers[i] = &st->state.samplers[PIPE_SHADER_FRAGMENT][i];
d470 2
a471 4
      samplers[fpv->bitmap_sampler] =
         &st->bitmap.samplers[sv->texture->target != PIPE_TEXTURE_RECT];
      cso_set_samplers(cso, PIPE_SHADER_FRAGMENT, num,
                       (const struct pipe_sampler_state **) samplers);
d477 4
a480 6
      uint num = MAX2(fpv->bitmap_sampler + 1,
                      st->state.num_sampler_views[PIPE_SHADER_FRAGMENT]);
      memcpy(sampler_views, st->state.sampler_views[PIPE_SHADER_FRAGMENT],
             sizeof(sampler_views));
      sampler_views[fpv->bitmap_sampler] = sv;
      cso_set_sampler_views(cso, PIPE_SHADER_FRAGMENT, num, sampler_views);
d485 4
a488 3
      const GLboolean invert = st->state.fb_orientation == Y_0_TOP;
      const GLfloat width = (GLfloat)st->state.framebuffer.width;
      const GLfloat height = (GLfloat)st->state.framebuffer.height;
a501 1
   cso_set_stream_outputs(st->cso_context, 0, NULL, 0);
d504 1
a504 1
   z = z * 2.0f - 1.0f;
d507 6
a512 2
   setup_bitmap_vertex_data(st, sv->texture->target != PIPE_TEXTURE_RECT,
			    x, y, width, height, z, color, &vbuf, &offset);
a513 8
   if (vbuf) {
      util_draw_vertex_buffer(pipe, st->cso_context, vbuf,
                              cso_get_aux_vertex_buffer_slot(st->cso_context),
                              offset,
                              PIPE_PRIM_TRIANGLE_FAN,
                              4,  /* verts */
                              3); /* attribs/vert */
   }
d517 2
a518 2
   cso_restore_samplers(cso, PIPE_SHADER_FRAGMENT);
   cso_restore_sampler_views(cso, PIPE_SHADER_FRAGMENT);
a521 1
   cso_restore_geometry_shader(cso);
a522 4
   cso_restore_aux_vertex_buffer_slot(cso);
   cso_restore_stream_outputs(cso);

   pipe_resource_reference(&vbuf, NULL);
d529 1
d540 5
d551 1
a551 1
                                      1, 1, 0,
a575 3
/**
 * Create gallium pipe_transfer object for the bitmap cache.
 */
d588 5
a592 4
   cache->buffer = pipe_transfer_map(pipe, cache->texture, 0, 0,
                                     PIPE_TRANSFER_WRITE, 0, 0,
                                     BITMAP_CACHE_WIDTH,
                                     BITMAP_CACHE_HEIGHT, &cache->trans);
d608 10
a617 9
      struct pipe_context *pipe = st->pipe;
      struct pipe_sampler_view *sv;

      assert(cache->xmin <= cache->xmax);

/*    printf("flush size %d x %d  at %d, %d\n",
             cache->xmax - cache->xmin,
             cache->ymax - cache->ymin,
             cache->xpos, cache->ypos);
d620 1
a620 1
      /* The texture transfer has been mapped until now.
d623 19
a641 17
      if (cache->trans && cache->buffer) {
         if (0)
            print_cache(cache);
         pipe_transfer_unmap(pipe, cache->trans);
         cache->buffer = NULL;
         cache->trans = NULL;
      }

      sv = st_create_texture_sampler_view(st->pipe, cache->texture);
      if (sv) {
         draw_bitmap_quad(st->ctx,
                          cache->xpos,
                          cache->ypos,
                          cache->zpos,
                          BITMAP_CACHE_WIDTH, BITMAP_CACHE_HEIGHT,
                          sv,
                          cache->color);
d643 2
a644 1
         pipe_sampler_view_reference(&sv, NULL);
d654 14
d674 1
a674 1
accum_bitmap(struct gl_context *ctx,
a678 1
   struct st_context *st = ctx->st;
a727 6
   /* PBO source... */
   bitmap = _mesa_map_pbo_source(ctx, unpack, bitmap);
   if (!bitmap) {
      return FALSE;
   }

a730 2
   _mesa_unmap_pbo_source(ctx, unpack);

d740 1
a740 2
st_Bitmap(struct gl_context *ctx, GLint x, GLint y,
          GLsizei width, GLsizei height,
a754 1
        st->needs_texcoord_semantic ? TGSI_SEMANTIC_TEXCOORD :
d762 1
a762 1
   if (UseBitmapCache && accum_bitmap(ctx, x, y, width, height, unpack, bitmap))
d767 1
a767 2
      struct pipe_sampler_view *sv =
         st_create_texture_sampler_view(st->pipe, pt);
d814 1
a814 3
   st->bitmap.rasterizer.half_pixel_center = 1;
   st->bitmap.rasterizer.bottom_edge_rule = 1;
   st->bitmap.rasterizer.depth_clip = 1;
d817 2
a818 3
   if (screen->is_format_supported(screen, PIPE_FORMAT_I8_UNORM,
                                   PIPE_TEXTURE_2D, 0,
                                   PIPE_BIND_SAMPLER_VIEW)) {
d821 2
a822 3
   else if (screen->is_format_supported(screen, PIPE_FORMAT_A8_UNORM,
                                        PIPE_TEXTURE_2D, 0,
                                        PIPE_BIND_SAMPLER_VIEW)) {
d825 2
a826 3
   else if (screen->is_format_supported(screen, PIPE_FORMAT_L8_UNORM,
                                        PIPE_TEXTURE_2D, 0,
                                        PIPE_BIND_SAMPLER_VIEW)) {
d848 2
d855 5
d861 1
a861 1
      if (cache->trans && cache->buffer) {
d863 1
d870 2
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d460 1
a460 1
   st->bitmap.rasterizer.scissor = ctx->Scissor.EnableFlags & 1;
d516 1
a516 1
   cso_set_stream_outputs(st->cso_context, 0, NULL, NULL);
@


