head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2014.01.19.03.13.15;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.09.05.14.06.43;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.22;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.01.19.03.04.45;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.35.10;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/**
 * GL_SELECT and GL_FEEDBACK render modes.
 * Basically, we use a private instance of the 'draw' module for doing
 * selection/feedback.  It would be nice to use the transform_feedback
 * hardware feature, but it's defined as happening pre-clip and we want
 * post-clipped primitives.  Also, there's concerns about the efficiency
 * of using the hardware for this anyway.
 *
 * Authors:
 *   Brian Paul
 */

#include "main/imports.h"
#include "main/context.h"
#include "main/feedback.h"

#include "vbo/vbo.h"

#include "st_context.h"
#include "st_draw.h"
#include "st_cb_feedback.h"

#include "pipe/p_context.h"
#include "pipe/p_defines.h"

#include "draw/draw_context.h"
#include "draw/draw_pipe.h"


/**
 * This is actually used for both feedback and selection.
 */
struct feedback_stage
{
   struct draw_stage stage;   /**< Base class */
   struct gl_context *ctx;            /**< Rendering context */
   GLboolean reset_stipple_counter;
};


/**********************************************************************
 * GL Feedback functions
 **********************************************************************/

static INLINE struct feedback_stage *
feedback_stage( struct draw_stage *stage )
{
   return (struct feedback_stage *)stage;
}


static void
feedback_vertex(struct gl_context *ctx, const struct draw_context *draw,
                const struct vertex_header *v)
{
   const struct st_context *st = st_context(ctx);
   GLfloat win[4];
   const GLfloat *color, *texcoord;
   GLuint slot;

   win[0] = v->data[0][0];
   if (st_fb_orientation(ctx->DrawBuffer) == Y_0_TOP)
      win[1] = ctx->DrawBuffer->Height - v->data[0][1];
   else
      win[1] = v->data[0][1];
   win[2] = v->data[0][2];
   win[3] = 1.0F / v->data[0][3];

   /* XXX
    * When we compute vertex layout, save info about position of the
    * color and texcoord attribs to use here.
    */

   slot = st->vertex_result_to_slot[VARYING_SLOT_COL0];
   if (slot != ~0U)
      color = v->data[slot];
   else
      color = ctx->Current.Attrib[VERT_ATTRIB_COLOR0];

   slot = st->vertex_result_to_slot[VARYING_SLOT_TEX0];
   if (slot != ~0U)
      texcoord = v->data[slot];
   else
      texcoord = ctx->Current.Attrib[VERT_ATTRIB_TEX0];

   _mesa_feedback_vertex(ctx, win, color, texcoord);
}


static void
feedback_tri( struct draw_stage *stage, struct prim_header *prim )
{
   struct feedback_stage *fs = feedback_stage(stage);
   struct draw_context *draw = stage->draw;
   _mesa_feedback_token(fs->ctx, (GLfloat) GL_POLYGON_TOKEN);
   _mesa_feedback_token(fs->ctx, (GLfloat) 3); /* three vertices */
   feedback_vertex(fs->ctx, draw, prim->v[0]);
   feedback_vertex(fs->ctx, draw, prim->v[1]);
   feedback_vertex(fs->ctx, draw, prim->v[2]);
}


static void
feedback_line( struct draw_stage *stage, struct prim_header *prim )
{
   struct feedback_stage *fs = feedback_stage(stage);
   struct draw_context *draw = stage->draw;
   if (fs->reset_stipple_counter) {
      _mesa_feedback_token(fs->ctx, (GLfloat) GL_LINE_RESET_TOKEN);
      fs->reset_stipple_counter = GL_FALSE;
   }
   else {
      _mesa_feedback_token(fs->ctx, (GLfloat) GL_LINE_TOKEN);
   }
   feedback_vertex(fs->ctx, draw, prim->v[0]);
   feedback_vertex(fs->ctx, draw, prim->v[1]);
}


static void
feedback_point( struct draw_stage *stage, struct prim_header *prim )
{
   struct feedback_stage *fs = feedback_stage(stage);
   struct draw_context *draw = stage->draw;
   _mesa_feedback_token(fs->ctx, (GLfloat) GL_POINT_TOKEN);
   feedback_vertex(fs->ctx, draw, prim->v[0]);
}


static void
feedback_flush( struct draw_stage *stage, unsigned flags )
{
   /* no-op */
}


static void
feedback_reset_stipple_counter( struct draw_stage *stage )
{
   struct feedback_stage *fs = feedback_stage(stage);
   fs->reset_stipple_counter = GL_TRUE;
}


static void
feedback_destroy( struct draw_stage *stage )
{
   /* no-op */
}

/**
 * Create GL feedback drawing stage.
 */
static struct draw_stage *
draw_glfeedback_stage(struct gl_context *ctx, struct draw_context *draw)
{
   struct feedback_stage *fs = ST_CALLOC_STRUCT(feedback_stage);

   fs->stage.draw = draw;
   fs->stage.next = NULL;
   fs->stage.point = feedback_point;
   fs->stage.line = feedback_line;
   fs->stage.tri = feedback_tri;
   fs->stage.flush = feedback_flush;
   fs->stage.reset_stipple_counter = feedback_reset_stipple_counter;
   fs->stage.destroy = feedback_destroy;
   fs->ctx = ctx;

   return &fs->stage;
}



/**********************************************************************
 * GL Selection functions
 **********************************************************************/

static void
select_tri( struct draw_stage *stage, struct prim_header *prim )
{
   struct feedback_stage *fs = feedback_stage(stage);
   _mesa_update_hitflag( fs->ctx, prim->v[0]->data[0][2] );
   _mesa_update_hitflag( fs->ctx, prim->v[1]->data[0][2] );
   _mesa_update_hitflag( fs->ctx, prim->v[2]->data[0][2] );
}

static void
select_line( struct draw_stage *stage, struct prim_header *prim )
{
   struct feedback_stage *fs = feedback_stage(stage);
   _mesa_update_hitflag( fs->ctx, prim->v[0]->data[0][2] );
   _mesa_update_hitflag( fs->ctx, prim->v[1]->data[0][2] );
}


static void
select_point( struct draw_stage *stage, struct prim_header *prim )
{
   struct feedback_stage *fs = feedback_stage(stage);
   _mesa_update_hitflag( fs->ctx, prim->v[0]->data[0][2] );
}


static void
select_flush( struct draw_stage *stage, unsigned flags )
{
   /* no-op */
}


static void
select_reset_stipple_counter( struct draw_stage *stage )
{
   /* no-op */
}

static void
select_destroy( struct draw_stage *stage )
{
   /* no-op */
}


/**
 * Create GL selection mode drawing stage.
 */
static struct draw_stage *
draw_glselect_stage(struct gl_context *ctx, struct draw_context *draw)
{
   struct feedback_stage *fs = ST_CALLOC_STRUCT(feedback_stage);

   fs->stage.draw = draw;
   fs->stage.next = NULL;
   fs->stage.point = select_point;
   fs->stage.line = select_line;
   fs->stage.tri = select_tri;
   fs->stage.flush = select_flush;
   fs->stage.reset_stipple_counter = select_reset_stipple_counter;
   fs->stage.destroy = select_destroy;
   fs->ctx = ctx;

   return &fs->stage;
}


static void
st_RenderMode(struct gl_context *ctx, GLenum newMode )
{
   struct st_context *st = st_context(ctx);
   struct draw_context *draw = st->draw;

   if (newMode == GL_RENDER) {
      /* restore normal VBO draw function */
      vbo_set_draw_func(ctx, st_draw_vbo);
   }
   else if (newMode == GL_SELECT) {
      if (!st->selection_stage)
         st->selection_stage = draw_glselect_stage(ctx, draw);
      draw_set_rasterize_stage(draw, st->selection_stage);
      /* Plug in new vbo draw function */
      vbo_set_draw_func(ctx, st_feedback_draw_vbo);
   }
   else {
      if (!st->feedback_stage)
         st->feedback_stage = draw_glfeedback_stage(ctx, draw);
      draw_set_rasterize_stage(draw, st->feedback_stage);
      /* Plug in new vbo draw function */
      vbo_set_draw_func(ctx, st_feedback_draw_vbo);
      /* need to generate/use a vertex program that emits pos/color/tex */
      st->dirty.st |= ST_NEW_VERTEX_PROGRAM;
   }
}



void st_init_feedback_functions(struct dd_function_table *functions)
{
   functions->RenderMode = st_RenderMode;
}
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.5
log
@Merge Mesa 9.2.5
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.4
log
@Merge Mesa 9.2.0
@
text
@a87 1
   /* Recall that Y=0=Top of window for Gallium wincoords */
d89 4
a92 1
   win[1] = ctx->DrawBuffer->Height - v->data[0][1];
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a42 1
#include "main/mfeatures.h"
a56 2
#if FEATURE_feedback

d99 1
a99 1
   slot = st->vertex_result_to_slot[VERT_RESULT_COL0];
d105 1
a105 1
   slot = st->vertex_result_to_slot[VERT_RESULT_TEX0];
a304 2

#endif /* FEATURE_feedback */
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d43 1
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d57 2
d65 1
a65 1
   GLcontext *ctx;            /**< Rendering context */
d82 1
a82 1
feedback_vertex(GLcontext *ctx, const struct draw_context *draw,
d85 1
a85 1
   const struct st_context *st = ctx->st;
d182 1
a182 1
draw_glfeedback_stage(GLcontext *ctx, struct draw_context *draw)
d255 1
a255 1
draw_glselect_stage(GLcontext *ctx, struct draw_context *draw)
d274 1
a274 1
st_RenderMode(GLcontext *ctx, GLenum newMode )
d276 1
a276 1
   struct st_context *st = ctx->st;
d307 2
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a56 2
#if FEATURE_feedback

d63 1
a63 1
   struct gl_context *ctx;            /**< Rendering context */
d80 1
a80 1
feedback_vertex(struct gl_context *ctx, const struct draw_context *draw,
d83 1
a83 1
   const struct st_context *st = st_context(ctx);
d180 1
a180 1
draw_glfeedback_stage(struct gl_context *ctx, struct draw_context *draw)
d253 1
a253 1
draw_glselect_stage(struct gl_context *ctx, struct draw_context *draw)
d272 1
a272 1
st_RenderMode(struct gl_context *ctx, GLenum newMode )
d274 1
a274 1
   struct st_context *st = st_context(ctx);
a304 2

#endif /* FEATURE_feedback */
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d57 2
d101 1
a101 1
   slot = st->vertex_result_to_slot[VARYING_SLOT_COL0];
d107 1
a107 1
   slot = st->vertex_result_to_slot[VARYING_SLOT_TEX0];
d307 2
@


1.1.1.3
log
@Import Mesa 9.2.5
@
text
@d88 1
d90 1
a90 4
   if (st_fb_orientation(ctx->DrawBuffer) == Y_0_TOP)
      win[1] = ctx->DrawBuffer->Height - v->data[0][1];
   else
      win[1] = v->data[0][1];
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
@


