head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.06.41;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.20;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.10;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.13.16;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.50.22;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  *   Brian Paul
  */


#include "main/macros.h"
#include "main/mtypes.h"
#include "main/samplerobj.h"
#include "main/texobj.h"
#include "program/prog_instruction.h"

#include "st_context.h"
#include "st_atom.h"
#include "st_texture.h"
#include "st_format.h"
#include "st_cb_texture.h"
#include "pipe/p_context.h"
#include "util/u_format.h"
#include "util/u_inlines.h"
#include "cso_cache/cso_context.h"


/**
 * Return swizzle1(swizzle2)
 */
static unsigned
swizzle_swizzle(unsigned swizzle1, unsigned swizzle2)
{
   unsigned i, swz[4];

   for (i = 0; i < 4; i++) {
      unsigned s = GET_SWZ(swizzle1, i);
      switch (s) {
      case SWIZZLE_X:
      case SWIZZLE_Y:
      case SWIZZLE_Z:
      case SWIZZLE_W:
         swz[i] = GET_SWZ(swizzle2, s);
         break;
      case SWIZZLE_ZERO:
         swz[i] = SWIZZLE_ZERO;
         break;
      case SWIZZLE_ONE:
         swz[i] = SWIZZLE_ONE;
         break;
      default:
         assert(!"Bad swizzle term");
         swz[i] = SWIZZLE_X;
      }
   }

   return MAKE_SWIZZLE4(swz[0], swz[1], swz[2], swz[3]);
}


/**
 * Given a user-specified texture base format, the actual gallium texture
 * format and the current GL_DEPTH_MODE, return a texture swizzle.
 *
 * Consider the case where the user requests a GL_RGB internal texture
 * format the driver actually uses an RGBA format.  The A component should
 * be ignored and sampling from the texture should always return (r,g,b,1).
 * But if we rendered to the texture we might have written A values != 1.
 * By sampling the texture with a ".xyz1" swizzle we'll get the expected A=1.
 * This function computes the texture swizzle needed to get the expected
 * values.
 *
 * In the case of depth textures, the GL_DEPTH_MODE state determines the
 * texture swizzle.
 *
 * This result must be composed with the user-specified swizzle to get
 * the final swizzle.
 */
static unsigned
compute_texture_format_swizzle(GLenum baseFormat, GLenum depthMode,
                               enum pipe_format actualFormat)
{
   switch (baseFormat) {
   case GL_RGBA:
      return SWIZZLE_XYZW;
   case GL_RGB:
      if (util_format_has_alpha(actualFormat))
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_ONE);
      else
         return SWIZZLE_XYZW;
   case GL_RG:
      if (util_format_get_nr_components(actualFormat) > 2)
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_ZERO, SWIZZLE_ONE);
      else
         return SWIZZLE_XYZW;
   case GL_RED:
      if (util_format_get_nr_components(actualFormat) > 1)
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_ZERO,
                              SWIZZLE_ZERO, SWIZZLE_ONE);
      else
         return SWIZZLE_XYZW;
   case GL_ALPHA:
      if (util_format_get_nr_components(actualFormat) > 1)
         return MAKE_SWIZZLE4(SWIZZLE_ZERO, SWIZZLE_ZERO,
                              SWIZZLE_ZERO, SWIZZLE_W);
      else
         return SWIZZLE_XYZW;
   case GL_LUMINANCE:
      if (util_format_get_nr_components(actualFormat) > 1)
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_X, SWIZZLE_X, SWIZZLE_ONE);
      else
         return SWIZZLE_XYZW;
   case GL_LUMINANCE_ALPHA:
      if (util_format_get_nr_components(actualFormat) > 2)
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_X, SWIZZLE_X, SWIZZLE_W);
      else
         return SWIZZLE_XYZW;
   case GL_INTENSITY:
      if (util_format_get_nr_components(actualFormat) > 1)
         return SWIZZLE_XXXX;
      else
         return SWIZZLE_XYZW;
   case GL_STENCIL_INDEX:
      return SWIZZLE_XYZW;
   case GL_DEPTH_STENCIL:
      /* fall-through */
   case GL_DEPTH_COMPONENT:
      /* Now examine the depth mode */
      switch (depthMode) {
      case GL_LUMINANCE:
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_X, SWIZZLE_X, SWIZZLE_ONE);
      case GL_INTENSITY:
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_X, SWIZZLE_X, SWIZZLE_X);
      case GL_ALPHA:
         return MAKE_SWIZZLE4(SWIZZLE_ZERO, SWIZZLE_ZERO,
                              SWIZZLE_ZERO, SWIZZLE_X);
      case GL_RED:
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_ZERO,
                              SWIZZLE_ZERO, SWIZZLE_ONE);
      default:
         assert(!"Unexpected depthMode");
         return SWIZZLE_XYZW;
      }
   default:
      assert(!"Unexpected baseFormat");
      return SWIZZLE_XYZW;
   }
}


static unsigned
get_texture_format_swizzle(const struct st_texture_object *stObj)
{
   const struct gl_texture_image *texImage =
      stObj->base.Image[0][stObj->base.BaseLevel];
   unsigned tex_swizzle;

   if (texImage) {
      tex_swizzle = compute_texture_format_swizzle(texImage->_BaseFormat,
                                                   stObj->base.DepthMode,
                                                   stObj->pt->format);
   }
   else {
      tex_swizzle = SWIZZLE_XYZW;
   }

   /* Combine the texture format swizzle with user's swizzle */
   return swizzle_swizzle(stObj->base._Swizzle, tex_swizzle);
}

                            
/**
 * Return TRUE if the texture's sampler view swizzle is equal to
 * the texture's swizzle.
 *
 * \param stObj  the st texture object,
 */
static boolean
check_sampler_swizzle(const struct st_texture_object *stObj,
		      struct pipe_sampler_view *sv)
{
   unsigned swizzle = get_texture_format_swizzle(stObj);

   return ((sv->swizzle_r != GET_SWZ(swizzle, 0)) ||
           (sv->swizzle_g != GET_SWZ(swizzle, 1)) ||
           (sv->swizzle_b != GET_SWZ(swizzle, 2)) ||
           (sv->swizzle_a != GET_SWZ(swizzle, 3)));
}


static struct pipe_sampler_view *
st_create_texture_sampler_view_from_stobj(struct pipe_context *pipe,
					  struct st_texture_object *stObj,
                                          const struct gl_sampler_object *samp,
					  enum pipe_format format)
{
   struct pipe_sampler_view templ;
   unsigned swizzle = get_texture_format_swizzle(stObj);

   u_sampler_view_default_template(&templ,
                                   stObj->pt,
                                   format);

   if (stObj->pt->target == PIPE_BUFFER) {
      unsigned base, size;
      unsigned f, n;
      const struct util_format_description *desc
         = util_format_description(templ.format);

      base = stObj->base.BufferOffset;
      if (base >= stObj->pt->width0)
         return NULL;
      size = MIN2(stObj->pt->width0 - base, (unsigned)stObj->base.BufferSize);

      f = ((base * 8) / desc->block.bits) * desc->block.width;
      n = ((size * 8) / desc->block.bits) * desc->block.width;
      if (!n)
         return NULL;
      templ.u.buf.first_element = f;
      templ.u.buf.last_element  = f + (n - 1);
   } else {
      templ.u.tex.first_level = stObj->base.BaseLevel;
   }

   if (swizzle != SWIZZLE_NOOP) {
      templ.swizzle_r = GET_SWZ(swizzle, 0);
      templ.swizzle_g = GET_SWZ(swizzle, 1);
      templ.swizzle_b = GET_SWZ(swizzle, 2);
      templ.swizzle_a = GET_SWZ(swizzle, 3);
   }

   return pipe->create_sampler_view(pipe, stObj->pt, &templ);
}


static struct pipe_sampler_view *
st_get_texture_sampler_view_from_stobj(struct st_context *st,
                                       struct st_texture_object *stObj,
                                       const struct gl_sampler_object *samp,
				       enum pipe_format format)
{
   struct pipe_sampler_view **sv;

   if (!stObj || !stObj->pt) {
      return NULL;
   }

   sv = st_texture_get_sampler_view(st, stObj);

   /* if sampler view has changed dereference it */
   if (*sv) {
      if (check_sampler_swizzle(stObj, *sv) ||
	  (format != (*sv)->format) ||
	  stObj->base.BaseLevel != (*sv)->u.tex.first_level) {
	 pipe_sampler_view_reference(sv, NULL);
      }
   }

   if (!*sv) {
      *sv = st_create_texture_sampler_view_from_stobj(st->pipe, stObj, samp, format);

   } else if ((*sv)->context != st->pipe) {
      /* Recreate view in correct context, use existing view as template */
      struct pipe_sampler_view *new_sv =
         st->pipe->create_sampler_view(st->pipe, stObj->pt, *sv);
      pipe_sampler_view_reference(sv, NULL);
      *sv = new_sv;
   }

   return *sv;
}

static GLboolean
update_single_texture(struct st_context *st,
                      struct pipe_sampler_view **sampler_view,
		      GLuint texUnit)
{
   struct gl_context *ctx = st->ctx;
   const struct gl_sampler_object *samp;
   struct gl_texture_object *texObj;
   struct st_texture_object *stObj;
   enum pipe_format view_format;
   GLboolean retval;

   samp = _mesa_get_samplerobj(ctx, texUnit);

   texObj = ctx->Texture.Unit[texUnit]._Current;

   if (!texObj) {
      texObj = _mesa_get_fallback_texture(ctx, TEXTURE_2D_INDEX);
      samp = &texObj->Sampler;
   }
   stObj = st_texture_object(texObj);

   retval = st_finalize_texture(ctx, st->pipe, texObj);
   if (!retval) {
      /* out of mem */
      return GL_FALSE;
   }

   /* Determine the format of the texture sampler view */
   if (texObj->Target == GL_TEXTURE_BUFFER) {
      view_format =
         st_mesa_format_to_pipe_format(stObj->base._BufferObjectFormat);
   }
   else {
      view_format =
         stObj->surface_based ? stObj->surface_format : stObj->pt->format;

      /* If sRGB decoding is off, use the linear format */
      if (samp->sRGBDecode == GL_SKIP_DECODE_EXT) {
         view_format = util_format_linear(view_format);
      }
   }

   *sampler_view = st_get_texture_sampler_view_from_stobj(st, stObj, samp,
							  view_format);
   return GL_TRUE;
}



static void
update_textures(struct st_context *st,
                unsigned shader_stage,
                const struct gl_program *prog,
                unsigned max_units,
                struct pipe_sampler_view **sampler_views,
                unsigned *num_textures)
{
   const GLuint old_max = *num_textures;
   GLbitfield samplers_used = prog->SamplersUsed;
   GLuint unit, new_count;

   if (samplers_used == 0x0 && old_max == 0)
      return;

   *num_textures = 0;

   /* loop over sampler units (aka tex image units) */
   for (unit = 0; unit < max_units; unit++, samplers_used >>= 1) {
      struct pipe_sampler_view *sampler_view = NULL;

      if (samplers_used & 1) {
         const GLuint texUnit = prog->SamplerUnits[unit];
         GLboolean retval;

         retval = update_single_texture(st, &sampler_view, texUnit);
         if (retval == GL_FALSE)
            continue;

         *num_textures = unit + 1;
      }
      else if (samplers_used == 0 && unit >= old_max) {
         /* if we've reset all the old views and we have no more new ones */
         break;
      }

      pipe_sampler_view_reference(&(sampler_views[unit]), sampler_view);
   }

   /* Ex: if old_max = 3 and *num_textures = 1, we need to pass an
    * array of views={X, NULL, NULL} to unref the old texture views
    * at positions [1] and [2].
    */
   new_count = MAX2(*num_textures, old_max);
   assert(new_count <= max_units);

   cso_set_sampler_views(st->cso_context,
                         shader_stage,
                         new_count,
                         sampler_views);
}



static void
update_vertex_textures(struct st_context *st)
{
   const struct gl_context *ctx = st->ctx;

   if (ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits > 0) {
      update_textures(st,
                      PIPE_SHADER_VERTEX,
                      &ctx->VertexProgram._Current->Base,
                      ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits,
                      st->state.sampler_views[PIPE_SHADER_VERTEX],
                      &st->state.num_sampler_views[PIPE_SHADER_VERTEX]);
   }
}


static void
update_fragment_textures(struct st_context *st)
{
   const struct gl_context *ctx = st->ctx;

   update_textures(st,
                   PIPE_SHADER_FRAGMENT,
                   &ctx->FragmentProgram._Current->Base,
                   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits,
                   st->state.sampler_views[PIPE_SHADER_FRAGMENT],
                   &st->state.num_sampler_views[PIPE_SHADER_FRAGMENT]);
}


static void
update_geometry_textures(struct st_context *st)
{
   const struct gl_context *ctx = st->ctx;

   if (ctx->GeometryProgram._Current) {
      update_textures(st,
                      PIPE_SHADER_GEOMETRY,
                      &ctx->GeometryProgram._Current->Base,
                      ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits,
                      st->state.sampler_views[PIPE_SHADER_GEOMETRY],
                      &st->state.num_sampler_views[PIPE_SHADER_GEOMETRY]);
   }
}


const struct st_tracked_state st_update_fragment_texture = {
   "st_update_texture",					/* name */
   {							/* dirty */
      _NEW_TEXTURE,					/* mesa */
      ST_NEW_FRAGMENT_PROGRAM,				/* st */
   },
   update_fragment_textures				/* update */
};


const struct st_tracked_state st_update_vertex_texture = {
   "st_update_vertex_texture",				/* name */
   {							/* dirty */
      _NEW_TEXTURE,					/* mesa */
      ST_NEW_VERTEX_PROGRAM,				/* st */
   },
   update_vertex_textures				/* update */
};


const struct st_tracked_state st_update_geometry_texture = {
   "st_update_geometry_texture",			/* name */
   {							/* dirty */
      _NEW_TEXTURE,					/* mesa */
      ST_NEW_GEOMETRY_PROGRAM,				/* st */
   },
   update_geometry_textures				/* update */
};



static void
finalize_textures(struct st_context *st)
{
   struct gl_context *ctx = st->ctx;
   struct gl_fragment_program *fprog = ctx->FragmentProgram._Current;
   const GLboolean prev_missing_textures = st->missing_textures;
   GLuint su;

   st->missing_textures = GL_FALSE;

   for (su = 0; su < ctx->Const.MaxTextureCoordUnits; su++) {
      if (fprog->Base.SamplersUsed & (1 << su)) {
         const GLuint texUnit = fprog->Base.SamplerUnits[su];
         struct gl_texture_object *texObj
            = ctx->Texture.Unit[texUnit]._Current;

         if (texObj) {
            GLboolean retval;

            retval = st_finalize_texture(ctx, st->pipe, texObj);
            if (!retval) {
               /* out of mem */
               st->missing_textures = GL_TRUE;
               continue;
            }
         }
      }
   }

   if (prev_missing_textures != st->missing_textures)
      st->dirty.st |= ST_NEW_FRAGMENT_PROGRAM;
}


const struct st_tracked_state st_finalize_textures = {
   "st_finalize_textures",		/* name */
   {					/* dirty */
      _NEW_TEXTURE,			/* mesa */
      0,				/* st */
   },
   finalize_textures			/* update */
};
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d195 1
a195 1

d197 1
a197 1
 * Return TRUE if the texture's sampler view swizzle is not equal to
a214 17
static unsigned last_level(struct st_texture_object *stObj)
{
   unsigned ret = MIN2(stObj->base.MinLevel + stObj->base._MaxLevel,
                       stObj->pt->last_level);
   if (stObj->base.Immutable)
      ret = MIN2(ret, stObj->base.MinLevel + stObj->base.NumLevels - 1);
   return ret;
}

static unsigned last_layer(struct st_texture_object *stObj)
{
   if (stObj->base.Immutable && stObj->pt->array_size > 1)
      return MIN2(stObj->base.MinLayer + stObj->base.NumLayers - 1,
                  stObj->pt->array_size - 1);
   return stObj->pt->array_size - 1;
}

d246 1
a246 7
      templ.u.tex.first_level = stObj->base.MinLevel + stObj->base.BaseLevel;
      templ.u.tex.last_level = last_level(stObj);
      assert(templ.u.tex.first_level <= templ.u.tex.last_level);
      templ.u.tex.first_layer = stObj->base.MinLayer;
      templ.u.tex.last_layer = last_layer(stObj);
      assert(templ.u.tex.first_layer <= templ.u.tex.last_layer);
      templ.target = gl_target_to_pipe(stObj->base.Target);
a273 4
   if (stObj->base.StencilSampling &&
       util_format_is_depth_and_stencil(format))
      format = util_format_stencil_only(format);

d278 1
a278 5
          gl_target_to_pipe(stObj->base.Target) != (*sv)->target ||
          stObj->base.MinLevel + stObj->base.BaseLevel != (*sv)->u.tex.first_level ||
          last_level(stObj) != (*sv)->u.tex.last_level ||
          stObj->base.MinLayer != (*sv)->u.tex.first_layer ||
          last_layer(stObj) != (*sv)->u.tex.last_layer) {
d328 1
a328 1
         st_mesa_format_to_pipe_format(st, stObj->base._BufferObjectFormat);
d357 1
a357 1
   GLuint unit;
d386 7
d395 1
a395 1
                         *num_textures,
d440 1
a440 1
                      ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxTextureImageUnits,
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d195 1
a195 1
                            
d197 1
a197 1
 * Return TRUE if the texture's sampler view swizzle is equal to
d215 17
d263 7
a269 1
      templ.u.tex.first_level = stObj->base.BaseLevel;
d297 4
d305 5
a309 1
	  stObj->base.BaseLevel != (*sv)->u.tex.first_level) {
d359 1
a359 1
         st_mesa_format_to_pipe_format(stObj->base._BufferObjectFormat);
d388 1
a388 1
   GLuint unit, new_count;
a416 7
   /* Ex: if old_max = 3 and *num_textures = 1, we need to pass an
    * array of views={X, NULL, NULL} to unref the old texture views
    * at positions [1] and [2].
    */
   new_count = MAX2(*num_textures, old_max);
   assert(new_count <= max_units);

d419 1
a419 1
                         new_count,
d464 1
a464 1
                      ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits,
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d53 1
a53 7
 * Combine depth texture mode with "swizzle" so that depth mode swizzling
 * takes place before texture swizzling, and return the resulting swizzle.
 * If the format is not a depth format, return "swizzle" unchanged.
 *
 * \param format     PIPE_FORMAT_*.
 * \param swizzle    Texture swizzle, a bitmask computed using MAKE_SWIZZLE4.
 * \param depthmode  One of GL_LUMINANCE, GL_INTENSITY, GL_ALPHA, GL_RED.
d55 2
a56 2
static GLuint
apply_depthmode(enum pipe_format format, GLuint swizzle, GLenum depthmode)
d58 1
a58 4
   const struct util_format_description *desc =
         util_format_description(format);
   unsigned char swiz[4];
   unsigned i;
d60 19
a78 4
   if (desc->colorspace != UTIL_FORMAT_COLORSPACE_ZS ||
       desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_NONE) {
      /* Not a depth format. */
      return swizzle;
d81 3
a83 2
   for (i = 0; i < 4; i++)
      swiz[i] = GET_SWZ(swizzle, i);
d85 69
a153 1
   switch (depthmode) {
d155 1
a155 8
         /* Rewrite reads from W to ONE, and reads from XYZ to XXX. */
         for (i = 0; i < 4; i++)
            if (swiz[i] == SWIZZLE_W)
               swiz[i] = SWIZZLE_ONE;
            else if (swiz[i] < SWIZZLE_W)
               swiz[i] = SWIZZLE_X;
         break;

d157 1
a157 6
         /* Rewrite reads from XYZW to XXXX. */
         for (i = 0; i < 4; i++)
            if (swiz[i] <= SWIZZLE_W)
               swiz[i] = SWIZZLE_X;
         break;

d159 2
a160 7
         /* Rewrite reads from W to X, and reads from XYZ to 000. */
         for (i = 0; i < 4; i++)
            if (swiz[i] == SWIZZLE_W)
               swiz[i] = SWIZZLE_X;
            else if (swiz[i] < SWIZZLE_W)
               swiz[i] = SWIZZLE_ZERO;
         break;
d162 9
a170 7
	 /* Rewrite reads W to 1, XYZ to X00 */
	 for (i = 0; i < 4; i++)
	    if (swiz[i] == SWIZZLE_W)
	       swiz[i] = SWIZZLE_ONE;
	    else if (swiz[i] == SWIZZLE_Y || swiz[i] == SWIZZLE_Z)
	       swiz[i] = SWIZZLE_ZERO;
	 break;
d172 1
d174 19
a192 1
   return MAKE_SWIZZLE4(swiz[0], swiz[1], swiz[2], swiz[3]);
d195 1
a195 1

d197 2
a198 3
 * Return TRUE if the swizzling described by "swizzle" and
 * "depthmode" (for depth textures only) is different from the swizzling
 * set in the given sampler view.
d200 1
a200 3
 * \param sv         A sampler view.
 * \param swizzle    Texture swizzle, a bitmask computed using MAKE_SWIZZLE4.
 * \param depthmode  One of GL_LUMINANCE, GL_INTENSITY, GL_ALPHA.
d203 2
a204 2
check_sampler_swizzle(struct pipe_sampler_view *sv,
                      GLuint swizzle, GLenum depthmode)
d206 1
a206 1
   swizzle = apply_depthmode(sv->texture->format, swizzle, depthmode);
d208 4
a211 6
   if ((sv->swizzle_r != GET_SWZ(swizzle, 0)) ||
       (sv->swizzle_g != GET_SWZ(swizzle, 1)) ||
       (sv->swizzle_b != GET_SWZ(swizzle, 2)) ||
       (sv->swizzle_a != GET_SWZ(swizzle, 3)))
      return TRUE;
   return FALSE;
d222 1
a222 3
   GLuint swizzle = apply_depthmode(stObj->pt->format,
                                    stObj->base._Swizzle,
                                    stObj->base.DepthMode);
d261 2
a262 2
st_get_texture_sampler_view_from_stobj(struct st_texture_object *stObj,
				       struct pipe_context *pipe,
d266 2
d272 9
a280 3
   if (!stObj->sampler_view) {
      stObj->sampler_view =
         st_create_texture_sampler_view_from_stobj(pipe, stObj, samp, format);
d283 12
a294 1
   return stObj->sampler_view;
a296 1

a301 1
   struct pipe_context *pipe = st->pipe;
d340 1
a340 13
   /* if sampler view has changed dereference it */
   if (stObj->sampler_view) {
      if (check_sampler_swizzle(stObj->sampler_view,
				stObj->base._Swizzle,
				stObj->base.DepthMode) ||
	  (view_format != stObj->sampler_view->format) ||
	  stObj->base.BaseLevel != stObj->sampler_view->u.tex.first_level) {
	 pipe_sampler_view_reference(&stObj->sampler_view, NULL);
      }
   }

   *sampler_view = st_get_texture_sampler_view_from_stobj(stObj, pipe,
							  samp,
d406 1
a406 1
   if (ctx->Const.VertexProgram.MaxTextureImageUnits > 0) {
d410 1
a410 1
                      ctx->Const.VertexProgram.MaxTextureImageUnits,
d425 1
a425 1
                   ctx->Const.FragmentProgram.MaxTextureImageUnits,
d440 1
a440 1
                      ctx->Const.FragmentProgram.MaxTextureImageUnits,
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d2 1
a2 1
 * 
d5 1
a5 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
 * 
d25 1
a25 1
 * 
d33 1
a33 1
 
d38 1
d141 1
a141 1
static INLINE struct pipe_sampler_view *
d150 1
a150 1
                                    samp->DepthMode);
d155 21
a175 1
   templ.u.tex.first_level = stObj->base.BaseLevel;
d188 1
a188 1
static INLINE struct pipe_sampler_view *
d206 1
d208 2
a209 1
update_single_texture(struct st_context *st, struct pipe_sampler_view **sampler_view,
d217 1
a217 1
   enum pipe_format st_view_format;
d225 1
a225 1
      texObj = st_get_default_texture(st);
d237 11
a247 16
   st_view_format = stObj->pt->format;
   {
      const struct st_texture_image *firstImage =
	 st_texture_image(stObj->base.Image[0][stObj->base.BaseLevel]);
      const gl_format texFormat = firstImage->base.TexFormat;
      enum pipe_format firstImageFormat =
	 st_mesa_format_to_pipe_format(texFormat);

      if ((samp->sRGBDecode == GL_SKIP_DECODE_EXT) &&
	  (_mesa_get_format_color_encoding(texFormat) == GL_SRGB)) {
	 /* don't do sRGB->RGB conversion.  Interpret the texture
	  * texture data as linear values.
	  */
	 const gl_format linearFormat =
	    _mesa_get_srgb_format_linear(texFormat);
	 firstImageFormat = st_mesa_format_to_pipe_format(linearFormat);
a248 3

      if (firstImageFormat != stObj->pt->format)
	 st_view_format = firstImageFormat;
a250 1

d255 2
a256 2
				samp->DepthMode) ||
	  (st_view_format != stObj->sampler_view->format) ||
d264 1
a264 1
							  st_view_format);
d268 9
a276 2
static void 
update_vertex_textures(struct st_context *st)
d278 6
a283 3
   const struct gl_context *ctx = st->ctx;
   struct gl_vertex_program *vprog = ctx->VertexProgram._Current;
   GLuint su;
d285 1
a285 1
   st->state.num_vertex_textures = 0;
d288 1
a288 1
   for (su = 0; su < ctx->Const.MaxTextureImageUnits; su++) {
d290 3
a292 1
      if (vprog->Base.SamplersUsed & (1 << su)) {
a293 1
         GLuint texUnit;
d295 13
a307 1
	 texUnit = vprog->Base.SamplerUnits[su];
d309 12
a320 3
	 retval = update_single_texture(st, &sampler_view, texUnit);
	 if (retval == GL_FALSE)
	    continue;
a321 1
	 st->state.num_vertex_textures = su + 1;
a322 3
      }
      pipe_sampler_view_reference(&st->state.sampler_vertex_views[su], sampler_view);
   }
d324 12
a335 6
   if (ctx->Const.MaxVertexTextureImageUnits > 0) {
      GLuint numUnits = MIN2(st->state.num_vertex_textures,
                             ctx->Const.MaxVertexTextureImageUnits);
      cso_set_vertex_sampler_views(st->cso_context,
                                   numUnits,
                                   st->state.sampler_vertex_views);
d339 2
a340 1
static void 
a343 2
   struct gl_fragment_program *fprog = ctx->FragmentProgram._Current;
   GLuint su;
d345 7
a351 1
   st->state.num_textures = 0;
a352 6
   /* loop over sampler units (aka tex image units) */
   for (su = 0; su < ctx->Const.MaxTextureImageUnits; su++) {
      struct pipe_sampler_view *sampler_view = NULL;
      if (fprog->Base.SamplersUsed & (1 << su)) {
         GLboolean retval;
         GLuint texUnit;
d354 4
a357 5
	 texUnit = fprog->Base.SamplerUnits[su];

	 retval = update_single_texture(st, &sampler_view, texUnit);
	 if (retval == GL_FALSE)
	    continue;
d359 7
a365 3
         st->state.num_textures = su + 1;
      }
      pipe_sampler_view_reference(&st->state.sampler_views[su], sampler_view);
d367 1
a368 4
   cso_set_fragment_sampler_views(st->cso_context,
                                  st->state.num_textures,
                                  st->state.sampler_views);
}
d370 1
a370 1
const struct st_tracked_state st_update_texture = {
d379 1
d381 1
a381 1
   "st_update_vertex_texture",					/* name */
d389 13
a401 1
static void 
a432 1

@


1.2
log
@Merge Mesa 7.10.3
@
text
@d36 2
d50 1
d60 2
a61 2
static GLuint apply_depthmode(enum pipe_format format,
                              GLuint swizzle, GLenum depthmode)
d115 1
d125 3
a127 2
static boolean check_sampler_swizzle(struct pipe_sampler_view *sv,
                                     GLuint swizzle, GLenum depthmode)
d135 2
a136 2
      return true;
   return false;
d139 1
d143 1
a144 1
					  
d149 1
a149 1
                                    stObj->base.DepthMode);
d154 1
d170 1
a171 1

d178 2
a179 1
      stObj->sampler_view = st_create_texture_sampler_view_from_stobj(pipe, stObj, format);
d185 106
d292 1
a292 1
update_textures(struct st_context *st)
d294 2
a295 5
   struct pipe_context *pipe = st->pipe;
   struct gl_vertex_program *vprog = st->ctx->VertexProgram._Current;
   struct gl_fragment_program *fprog = st->ctx->FragmentProgram._Current;
   const GLbitfield samplersUsed = (vprog->Base.SamplersUsed |
                                    fprog->Base.SamplersUsed);
d301 1
a301 1
   for (su = 0; su < st->ctx->Const.MaxTextureImageUnits; su++) {
d303 1
a303 4
      enum pipe_format st_view_format;
      if (samplersUsed & (1 << su)) {
         struct gl_texture_object *texObj;
         struct st_texture_object *stObj;
d307 5
a311 27
         if (fprog->Base.SamplersUsed & (1 << su))
            texUnit = fprog->Base.SamplerUnits[su];
         else
            texUnit = vprog->Base.SamplerUnits[su];

         texObj = st->ctx->Texture.Unit[texUnit]._Current;

         if (!texObj) {
            texObj = st_get_default_texture(st);
         }
         stObj = st_texture_object(texObj);

         retval = st_finalize_texture(st->ctx, st->pipe, texObj);
         if (!retval) {
            /* out of mem */
            continue;
         }

	 st_view_format = stObj->pt->format;
	 {
	    struct st_texture_image *firstImage;
	    enum pipe_format firstImageFormat;
	    firstImage = st_texture_image(stObj->base.Image[0][stObj->base.BaseLevel]);

	    firstImageFormat = st_mesa_format_to_pipe_format(firstImage->base.TexFormat);
	    if (firstImageFormat != stObj->pt->format)
	       st_view_format = firstImageFormat;
a312 1
	 }
a313 10

	 /* if sampler view has changed dereference it */
	 if (stObj->sampler_view)
            if (check_sampler_swizzle(stObj->sampler_view,
                                      stObj->base._Swizzle,
                                      stObj->base.DepthMode) ||
                (st_view_format != stObj->sampler_view->format))
	       pipe_sampler_view_reference(&stObj->sampler_view, NULL);

         sampler_view = st_get_texture_sampler_view_from_stobj(stObj, pipe, st_view_format);
a320 6
   if (st->ctx->Const.MaxVertexTextureImageUnits > 0) {
      cso_set_vertex_sampler_views(st->cso_context,
                                   MIN2(st->state.num_textures,
                                        st->ctx->Const.MaxVertexTextureImageUnits),
                                   st->state.sampler_views);
   }
a322 1

d329 1
a329 1
   update_textures					/* update */
d332 8
a339 2


d344 2
a345 1
   struct gl_fragment_program *fprog = st->ctx->FragmentProgram._Current;
d351 1
a351 1
   for (su = 0; su < st->ctx->Const.MaxTextureCoordUnits; su++) {
d355 1
a355 1
            = st->ctx->Texture.Unit[texUnit]._Current;
d360 1
a360 1
            retval = st_finalize_texture(st->ctx, st->pipe, texObj);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d36 1
d41 1
d44 1
d48 128
d180 1
d191 2
a192 2
      struct pipe_texture *pt = NULL;

d196 1
a196 1
         GLboolean flush, retval;
d211 1
a211 1
         retval = st_finalize_texture(st->ctx, st->pipe, texObj, &flush);
d217 11
d230 7
a236 2
         pt = st_get_stobj_texture(stObj);
      }
d238 1
a238 3
      /*
      if (pt) {
         printf("%s su=%u non-null\n", __FUNCTION__, su);
d240 1
a240 6
      else {
         printf("%s su=%u null\n", __FUNCTION__, su);
      }
      */

      pipe_texture_reference(&st->state.sampler_texture[su], pt);
d243 3
a245 3
   cso_set_sampler_textures(st->cso_context,
                            st->state.num_textures,
                            st->state.sampler_texture);
d247 4
a250 4
      cso_set_vertex_sampler_textures(st->cso_context,
                                      MIN2(st->state.num_textures,
                                           st->ctx->Const.MaxVertexTextureImageUnits),
                                      st->state.sampler_texture);
a280 1
         struct st_texture_object *stObj = st_texture_object(texObj);
d283 1
a283 1
            GLboolean flush, retval;
d285 1
a285 1
            retval = st_finalize_texture(st->ctx, st->pipe, texObj, &flush);
a290 2

            stObj->teximage_realloc = TRUE;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a35 1
#include "program/prog_instruction.h"
a39 1
#include "st_format.h"
a41 1
#include "util/u_format.h"
a44 128
/**
 * Combine depth texture mode with "swizzle" so that depth mode swizzling
 * takes place before texture swizzling, and return the resulting swizzle.
 * If the format is not a depth format, return "swizzle" unchanged.
 *
 * \param format     PIPE_FORMAT_*.
 * \param swizzle    Texture swizzle, a bitmask computed using MAKE_SWIZZLE4.
 * \param depthmode  One of GL_LUMINANCE, GL_INTENSITY, GL_ALPHA, GL_RED.
 */
static GLuint apply_depthmode(enum pipe_format format,
                              GLuint swizzle, GLenum depthmode)
{
   const struct util_format_description *desc =
         util_format_description(format);
   unsigned char swiz[4];
   unsigned i;

   if (desc->colorspace != UTIL_FORMAT_COLORSPACE_ZS ||
       desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_NONE) {
      /* Not a depth format. */
      return swizzle;
   }

   for (i = 0; i < 4; i++)
      swiz[i] = GET_SWZ(swizzle, i);

   switch (depthmode) {
      case GL_LUMINANCE:
         /* Rewrite reads from W to ONE, and reads from XYZ to XXX. */
         for (i = 0; i < 4; i++)
            if (swiz[i] == SWIZZLE_W)
               swiz[i] = SWIZZLE_ONE;
            else if (swiz[i] < SWIZZLE_W)
               swiz[i] = SWIZZLE_X;
         break;

      case GL_INTENSITY:
         /* Rewrite reads from XYZW to XXXX. */
         for (i = 0; i < 4; i++)
            if (swiz[i] <= SWIZZLE_W)
               swiz[i] = SWIZZLE_X;
         break;

      case GL_ALPHA:
         /* Rewrite reads from W to X, and reads from XYZ to 000. */
         for (i = 0; i < 4; i++)
            if (swiz[i] == SWIZZLE_W)
               swiz[i] = SWIZZLE_X;
            else if (swiz[i] < SWIZZLE_W)
               swiz[i] = SWIZZLE_ZERO;
         break;
      case GL_RED:
	 /* Rewrite reads W to 1, XYZ to X00 */
	 for (i = 0; i < 4; i++)
	    if (swiz[i] == SWIZZLE_W)
	       swiz[i] = SWIZZLE_ONE;
	    else if (swiz[i] == SWIZZLE_Y || swiz[i] == SWIZZLE_Z)
	       swiz[i] = SWIZZLE_ZERO;
	 break;
   }

   return MAKE_SWIZZLE4(swiz[0], swiz[1], swiz[2], swiz[3]);
}

/**
 * Return TRUE if the swizzling described by "swizzle" and
 * "depthmode" (for depth textures only) is different from the swizzling
 * set in the given sampler view.
 *
 * \param sv         A sampler view.
 * \param swizzle    Texture swizzle, a bitmask computed using MAKE_SWIZZLE4.
 * \param depthmode  One of GL_LUMINANCE, GL_INTENSITY, GL_ALPHA.
 */
static boolean check_sampler_swizzle(struct pipe_sampler_view *sv,
                                     GLuint swizzle, GLenum depthmode)
{
   swizzle = apply_depthmode(sv->texture->format, swizzle, depthmode);

   if ((sv->swizzle_r != GET_SWZ(swizzle, 0)) ||
       (sv->swizzle_g != GET_SWZ(swizzle, 1)) ||
       (sv->swizzle_b != GET_SWZ(swizzle, 2)) ||
       (sv->swizzle_a != GET_SWZ(swizzle, 3)))
      return true;
   return false;
}

static INLINE struct pipe_sampler_view *
st_create_texture_sampler_view_from_stobj(struct pipe_context *pipe,
					  struct st_texture_object *stObj,
					  enum pipe_format format)
					  
{
   struct pipe_sampler_view templ;
   GLuint swizzle = apply_depthmode(stObj->pt->format,
                                    stObj->base._Swizzle,
                                    stObj->base.DepthMode);

   u_sampler_view_default_template(&templ,
                                   stObj->pt,
                                   format);

   if (swizzle != SWIZZLE_NOOP) {
      templ.swizzle_r = GET_SWZ(swizzle, 0);
      templ.swizzle_g = GET_SWZ(swizzle, 1);
      templ.swizzle_b = GET_SWZ(swizzle, 2);
      templ.swizzle_a = GET_SWZ(swizzle, 3);
   }

   return pipe->create_sampler_view(pipe, stObj->pt, &templ);
}


static INLINE struct pipe_sampler_view *
st_get_texture_sampler_view_from_stobj(struct st_texture_object *stObj,
				       struct pipe_context *pipe,
				       enum pipe_format format)

{
   if (!stObj || !stObj->pt) {
      return NULL;
   }

   if (!stObj->sampler_view) {
      stObj->sampler_view = st_create_texture_sampler_view_from_stobj(pipe, stObj, format);
   }

   return stObj->sampler_view;
}
a48 1
   struct pipe_context *pipe = st->pipe;
d59 2
a60 2
      struct pipe_sampler_view *sampler_view = NULL;
      enum pipe_format st_view_format;
d64 1
a64 1
         GLboolean retval;
d79 1
a79 1
         retval = st_finalize_texture(st->ctx, st->pipe, texObj);
a84 11
	 st_view_format = stObj->pt->format;
	 {
	    struct st_texture_image *firstImage;
	    enum pipe_format firstImageFormat;
	    firstImage = st_texture_image(stObj->base.Image[0][stObj->base.BaseLevel]);

	    firstImageFormat = st_mesa_format_to_pipe_format(firstImage->base.TexFormat);
	    if (firstImageFormat != stObj->pt->format)
	       st_view_format = firstImageFormat;

	 }
d87 2
a88 7
	 /* if sampler view has changed dereference it */
	 if (stObj->sampler_view)
            if (check_sampler_swizzle(stObj->sampler_view,
                                      stObj->base._Swizzle,
                                      stObj->base.DepthMode) ||
                (st_view_format != stObj->sampler_view->format))
	       pipe_sampler_view_reference(&stObj->sampler_view, NULL);
d90 3
a92 1
         sampler_view = st_get_texture_sampler_view_from_stobj(stObj, pipe, st_view_format);
d94 6
a99 1
      pipe_sampler_view_reference(&st->state.sampler_views[su], sampler_view);
d102 3
a104 3
   cso_set_fragment_sampler_views(st->cso_context,
                                  st->state.num_textures,
                                  st->state.sampler_views);
d106 4
a109 4
      cso_set_vertex_sampler_views(st->cso_context,
                                   MIN2(st->state.num_textures,
                                        st->ctx->Const.MaxVertexTextureImageUnits),
                                   st->state.sampler_views);
d140 1
d143 1
a143 1
            GLboolean retval;
d145 1
a145 1
            retval = st_finalize_texture(st->ctx, st->pipe, texObj);
d151 2
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d2 1
a2 1
 *
d5 1
a5 1
 *
d13 1
a13 1
 *
d17 1
a17 1
 *
d25 1
a25 1
 *
d33 1
a33 1

a35 3
#include "main/mtypes.h"
#include "main/samplerobj.h"
#include "main/texobj.h"
a47 1

d57 2
a58 2
static GLuint
apply_depthmode(enum pipe_format format, GLuint swizzle, GLenum depthmode)
a111 1

d121 2
a122 3
static boolean
check_sampler_swizzle(struct pipe_sampler_view *sv,
                      GLuint swizzle, GLenum depthmode)
d130 2
a131 2
      return TRUE;
   return FALSE;
d134 1
a134 2

static struct pipe_sampler_view *
a136 1
                                          const struct gl_sampler_object *samp,
d138 1
a148 21
   if (stObj->pt->target == PIPE_BUFFER) {
      unsigned base, size;
      unsigned f, n;
      const struct util_format_description *desc
         = util_format_description(templ.format);

      base = stObj->base.BufferOffset;
      if (base >= stObj->pt->width0)
         return NULL;
      size = MIN2(stObj->pt->width0 - base, (unsigned)stObj->base.BufferSize);

      f = ((base * 8) / desc->block.bits) * desc->block.width;
      n = ((size * 8) / desc->block.bits) * desc->block.width;
      if (!n)
         return NULL;
      templ.u.buf.first_element = f;
      templ.u.buf.last_element  = f + (n - 1);
   } else {
      templ.u.tex.first_level = stObj->base.BaseLevel;
   }

d160 1
a160 1
static struct pipe_sampler_view *
a162 1
                                       const struct gl_sampler_object *samp,
d164 1
d171 1
a171 2
      stObj->sampler_view =
         st_create_texture_sampler_view_from_stobj(pipe, stObj, samp, format);
d177 2
a178 5

static GLboolean
update_single_texture(struct st_context *st,
                      struct pipe_sampler_view **sampler_view,
		      GLuint texUnit)
d181 5
a185 16
   struct gl_context *ctx = st->ctx;
   const struct gl_sampler_object *samp;
   struct gl_texture_object *texObj;
   struct st_texture_object *stObj;
   enum pipe_format view_format;
   GLboolean retval;

   samp = _mesa_get_samplerobj(ctx, texUnit);

   texObj = ctx->Texture.Unit[texUnit]._Current;

   if (!texObj) {
      texObj = _mesa_get_fallback_texture(ctx, TEXTURE_2D_INDEX);
      samp = &texObj->Sampler;
   }
   stObj = st_texture_object(texObj);
d187 1
a187 56
   retval = st_finalize_texture(ctx, st->pipe, texObj);
   if (!retval) {
      /* out of mem */
      return GL_FALSE;
   }

   /* Determine the format of the texture sampler view */
   if (texObj->Target == GL_TEXTURE_BUFFER) {
      view_format =
         st_mesa_format_to_pipe_format(stObj->base._BufferObjectFormat);
   }
   else {
      view_format =
         stObj->surface_based ? stObj->surface_format : stObj->pt->format;

      /* If sRGB decoding is off, use the linear format */
      if (samp->sRGBDecode == GL_SKIP_DECODE_EXT) {
         view_format = util_format_linear(view_format);
      }
   }

   /* if sampler view has changed dereference it */
   if (stObj->sampler_view) {
      if (check_sampler_swizzle(stObj->sampler_view,
				stObj->base._Swizzle,
				stObj->base.DepthMode) ||
	  (view_format != stObj->sampler_view->format) ||
	  stObj->base.BaseLevel != stObj->sampler_view->u.tex.first_level) {
	 pipe_sampler_view_reference(&stObj->sampler_view, NULL);
      }
   }

   *sampler_view = st_get_texture_sampler_view_from_stobj(stObj, pipe,
							  samp,
							  view_format);
   return GL_TRUE;
}



static void
update_textures(struct st_context *st,
                unsigned shader_stage,
                const struct gl_program *prog,
                unsigned max_units,
                struct pipe_sampler_view **sampler_views,
                unsigned *num_textures)
{
   const GLuint old_max = *num_textures;
   GLbitfield samplers_used = prog->SamplersUsed;
   GLuint unit, new_count;

   if (samplers_used == 0x0 && old_max == 0)
      return;

   *num_textures = 0;
d190 1
a190 1
   for (unit = 0; unit < max_units; unit++, samplers_used >>= 1) {
d192 4
a195 3

      if (samplers_used & 1) {
         const GLuint texUnit = prog->SamplerUnits[unit];
d197 1
d199 4
a202 10
         retval = update_single_texture(st, &sampler_view, texUnit);
         if (retval == GL_FALSE)
            continue;

         *num_textures = unit + 1;
      }
      else if (samplers_used == 0 && unit >= old_max) {
         /* if we've reset all the old views and we have no more new ones */
         break;
      }
d204 1
a204 2
      pipe_sampler_view_reference(&(sampler_views[unit]), sampler_view);
   }
d206 4
a209 12
   /* Ex: if old_max = 3 and *num_textures = 1, we need to pass an
    * array of views={X, NULL, NULL} to unref the old texture views
    * at positions [1] and [2].
    */
   new_count = MAX2(*num_textures, old_max);
   assert(new_count <= max_units);

   cso_set_sampler_views(st->cso_context,
                         shader_stage,
                         new_count,
                         sampler_views);
}
d211 5
d217 20
d238 3
a240 12
static void
update_vertex_textures(struct st_context *st)
{
   const struct gl_context *ctx = st->ctx;

   if (ctx->Const.VertexProgram.MaxTextureImageUnits > 0) {
      update_textures(st,
                      PIPE_SHADER_VERTEX,
                      &ctx->VertexProgram._Current->Base,
                      ctx->Const.VertexProgram.MaxTextureImageUnits,
                      st->state.sampler_views[PIPE_SHADER_VERTEX],
                      &st->state.num_sampler_views[PIPE_SHADER_VERTEX]);
a241 1
}
d243 8
a250 27

static void
update_fragment_textures(struct st_context *st)
{
   const struct gl_context *ctx = st->ctx;

   update_textures(st,
                   PIPE_SHADER_FRAGMENT,
                   &ctx->FragmentProgram._Current->Base,
                   ctx->Const.FragmentProgram.MaxTextureImageUnits,
                   st->state.sampler_views[PIPE_SHADER_FRAGMENT],
                   &st->state.num_sampler_views[PIPE_SHADER_FRAGMENT]);
}


static void
update_geometry_textures(struct st_context *st)
{
   const struct gl_context *ctx = st->ctx;

   if (ctx->GeometryProgram._Current) {
      update_textures(st,
                      PIPE_SHADER_GEOMETRY,
                      &ctx->GeometryProgram._Current->Base,
                      ctx->Const.FragmentProgram.MaxTextureImageUnits,
                      st->state.sampler_views[PIPE_SHADER_GEOMETRY],
                      &st->state.num_sampler_views[PIPE_SHADER_GEOMETRY]);
d255 1
a255 1
const struct st_tracked_state st_update_fragment_texture = {
d261 1
a261 11
   update_fragment_textures				/* update */
};


const struct st_tracked_state st_update_vertex_texture = {
   "st_update_vertex_texture",				/* name */
   {							/* dirty */
      _NEW_TEXTURE,					/* mesa */
      ST_NEW_VERTEX_PROGRAM,				/* st */
   },
   update_vertex_textures				/* update */
a264 9
const struct st_tracked_state st_update_geometry_texture = {
   "st_update_geometry_texture",			/* name */
   {							/* dirty */
      _NEW_TEXTURE,					/* mesa */
      ST_NEW_GEOMETRY_PROGRAM,				/* st */
   },
   update_geometry_textures				/* update */
};

d267 1
a267 1
static void
d270 1
a270 2
   struct gl_context *ctx = st->ctx;
   struct gl_fragment_program *fprog = ctx->FragmentProgram._Current;
d276 1
a276 1
   for (su = 0; su < ctx->Const.MaxTextureCoordUnits; su++) {
d280 1
a280 1
            = ctx->Texture.Unit[texUnit]._Current;
d285 1
a285 1
            retval = st_finalize_texture(ctx, st->pipe, texObj);
d298 1
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
  *   Keith Whitwell <keithw@@vmware.com>
d53 7
a59 1
 * Return swizzle1(swizzle2)
d61 2
a62 2
static unsigned
swizzle_swizzle(unsigned swizzle1, unsigned swizzle2)
d64 4
a67 1
   unsigned i, swz[4];
d69 4
a72 19
   for (i = 0; i < 4; i++) {
      unsigned s = GET_SWZ(swizzle1, i);
      switch (s) {
      case SWIZZLE_X:
      case SWIZZLE_Y:
      case SWIZZLE_Z:
      case SWIZZLE_W:
         swz[i] = GET_SWZ(swizzle2, s);
         break;
      case SWIZZLE_ZERO:
         swz[i] = SWIZZLE_ZERO;
         break;
      case SWIZZLE_ONE:
         swz[i] = SWIZZLE_ONE;
         break;
      default:
         assert(!"Bad swizzle term");
         swz[i] = SWIZZLE_X;
      }
d75 2
a76 2
   return MAKE_SWIZZLE4(swz[0], swz[1], swz[2], swz[3]);
}
d78 9
a87 71
/**
 * Given a user-specified texture base format, the actual gallium texture
 * format and the current GL_DEPTH_MODE, return a texture swizzle.
 *
 * Consider the case where the user requests a GL_RGB internal texture
 * format the driver actually uses an RGBA format.  The A component should
 * be ignored and sampling from the texture should always return (r,g,b,1).
 * But if we rendered to the texture we might have written A values != 1.
 * By sampling the texture with a ".xyz1" swizzle we'll get the expected A=1.
 * This function computes the texture swizzle needed to get the expected
 * values.
 *
 * In the case of depth textures, the GL_DEPTH_MODE state determines the
 * texture swizzle.
 *
 * This result must be composed with the user-specified swizzle to get
 * the final swizzle.
 */
static unsigned
compute_texture_format_swizzle(GLenum baseFormat, GLenum depthMode,
                               enum pipe_format actualFormat)
{
   switch (baseFormat) {
   case GL_RGBA:
      return SWIZZLE_XYZW;
   case GL_RGB:
      if (util_format_has_alpha(actualFormat))
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_ONE);
      else
         return SWIZZLE_XYZW;
   case GL_RG:
      if (util_format_get_nr_components(actualFormat) > 2)
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_ZERO, SWIZZLE_ONE);
      else
         return SWIZZLE_XYZW;
   case GL_RED:
      if (util_format_get_nr_components(actualFormat) > 1)
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_ZERO,
                              SWIZZLE_ZERO, SWIZZLE_ONE);
      else
         return SWIZZLE_XYZW;
   case GL_ALPHA:
      if (util_format_get_nr_components(actualFormat) > 1)
         return MAKE_SWIZZLE4(SWIZZLE_ZERO, SWIZZLE_ZERO,
                              SWIZZLE_ZERO, SWIZZLE_W);
      else
         return SWIZZLE_XYZW;
   case GL_LUMINANCE:
      if (util_format_get_nr_components(actualFormat) > 1)
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_X, SWIZZLE_X, SWIZZLE_ONE);
      else
         return SWIZZLE_XYZW;
   case GL_LUMINANCE_ALPHA:
      if (util_format_get_nr_components(actualFormat) > 2)
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_X, SWIZZLE_X, SWIZZLE_W);
      else
         return SWIZZLE_XYZW;
   case GL_INTENSITY:
      if (util_format_get_nr_components(actualFormat) > 1)
         return SWIZZLE_XXXX;
      else
         return SWIZZLE_XYZW;
   case GL_STENCIL_INDEX:
      return SWIZZLE_XYZW;
   case GL_DEPTH_STENCIL:
      /* fall-through */
   case GL_DEPTH_COMPONENT:
      /* Now examine the depth mode */
      switch (depthMode) {
      case GL_LUMINANCE:
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_X, SWIZZLE_X, SWIZZLE_ONE);
d89 6
a94 1
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_X, SWIZZLE_X, SWIZZLE_X);
d96 7
a102 2
         return MAKE_SWIZZLE4(SWIZZLE_ZERO, SWIZZLE_ZERO,
                              SWIZZLE_ZERO, SWIZZLE_X);
d104 7
a110 9
         return MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_ZERO,
                              SWIZZLE_ZERO, SWIZZLE_ONE);
      default:
         assert(!"Unexpected depthMode");
         return SWIZZLE_XYZW;
      }
   default:
      assert(!"Unexpected baseFormat");
      return SWIZZLE_XYZW;
d112 2
a116 21
static unsigned
get_texture_format_swizzle(const struct st_texture_object *stObj)
{
   const struct gl_texture_image *texImage =
      stObj->base.Image[0][stObj->base.BaseLevel];
   unsigned tex_swizzle;

   if (texImage) {
      tex_swizzle = compute_texture_format_swizzle(texImage->_BaseFormat,
                                                   stObj->base.DepthMode,
                                                   stObj->pt->format);
   }
   else {
      tex_swizzle = SWIZZLE_XYZW;
   }

   /* Combine the texture format swizzle with user's swizzle */
   return swizzle_swizzle(stObj->base._Swizzle, tex_swizzle);
}

                            
d118 3
a120 2
 * Return TRUE if the texture's sampler view swizzle is equal to
 * the texture's swizzle.
d122 3
a124 1
 * \param stObj  the st texture object,
d127 2
a128 2
check_sampler_swizzle(const struct st_texture_object *stObj,
		      struct pipe_sampler_view *sv)
d130 1
a130 1
   unsigned swizzle = get_texture_format_swizzle(stObj);
d132 6
a137 4
   return ((sv->swizzle_r != GET_SWZ(swizzle, 0)) ||
           (sv->swizzle_g != GET_SWZ(swizzle, 1)) ||
           (sv->swizzle_b != GET_SWZ(swizzle, 2)) ||
           (sv->swizzle_a != GET_SWZ(swizzle, 3)));
d148 3
a150 1
   unsigned swizzle = get_texture_format_swizzle(stObj);
d189 2
a190 2
st_get_texture_sampler_view_from_stobj(struct st_context *st,
                                       struct st_texture_object *stObj,
a193 2
   struct pipe_sampler_view **sv;

d198 3
a200 9
   sv = st_texture_get_sampler_view(st, stObj);

   /* if sampler view has changed dereference it */
   if (*sv) {
      if (check_sampler_swizzle(stObj, *sv) ||
	  (format != (*sv)->format) ||
	  stObj->base.BaseLevel != (*sv)->u.tex.first_level) {
	 pipe_sampler_view_reference(sv, NULL);
      }
d203 2
a204 2
   if (!*sv) {
      *sv = st_create_texture_sampler_view_from_stobj(st->pipe, stObj, samp, format);
a205 10
   } else if ((*sv)->context != st->pipe) {
      /* Recreate view in correct context, use existing view as template */
      struct pipe_sampler_view *new_sv =
         st->pipe->create_sampler_view(st->pipe, stObj->pt, *sv);
      pipe_sampler_view_reference(sv, NULL);
      *sv = new_sv;
   }

   return *sv;
}
d212 1
d251 13
a263 1
   *sampler_view = st_get_texture_sampler_view_from_stobj(st, stObj, samp,
d329 1
a329 1
   if (ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits > 0) {
d333 1
a333 1
                      ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits,
d348 1
a348 1
                   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits,
d363 1
a363 1
                      ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits,
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d195 1
a195 1

d197 1
a197 1
 * Return TRUE if the texture's sampler view swizzle is not equal to
a214 17
static unsigned last_level(struct st_texture_object *stObj)
{
   unsigned ret = MIN2(stObj->base.MinLevel + stObj->base._MaxLevel,
                       stObj->pt->last_level);
   if (stObj->base.Immutable)
      ret = MIN2(ret, stObj->base.MinLevel + stObj->base.NumLevels - 1);
   return ret;
}

static unsigned last_layer(struct st_texture_object *stObj)
{
   if (stObj->base.Immutable && stObj->pt->array_size > 1)
      return MIN2(stObj->base.MinLayer + stObj->base.NumLayers - 1,
                  stObj->pt->array_size - 1);
   return stObj->pt->array_size - 1;
}

d246 1
a246 7
      templ.u.tex.first_level = stObj->base.MinLevel + stObj->base.BaseLevel;
      templ.u.tex.last_level = last_level(stObj);
      assert(templ.u.tex.first_level <= templ.u.tex.last_level);
      templ.u.tex.first_layer = stObj->base.MinLayer;
      templ.u.tex.last_layer = last_layer(stObj);
      assert(templ.u.tex.first_layer <= templ.u.tex.last_layer);
      templ.target = gl_target_to_pipe(stObj->base.Target);
a273 4
   if (stObj->base.StencilSampling &&
       util_format_is_depth_and_stencil(format))
      format = util_format_stencil_only(format);

d278 1
a278 5
          gl_target_to_pipe(stObj->base.Target) != (*sv)->target ||
          stObj->base.MinLevel + stObj->base.BaseLevel != (*sv)->u.tex.first_level ||
          last_level(stObj) != (*sv)->u.tex.last_level ||
          stObj->base.MinLayer != (*sv)->u.tex.first_layer ||
          last_layer(stObj) != (*sv)->u.tex.last_layer) {
d328 1
a328 1
         st_mesa_format_to_pipe_format(st, stObj->base._BufferObjectFormat);
d357 1
a357 1
   GLuint unit;
d386 7
d395 1
a395 1
                         *num_textures,
d440 1
a440 1
                      ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxTextureImageUnits,
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d195 1
a195 1
                            
d197 1
a197 1
 * Return TRUE if the texture's sampler view swizzle is equal to
d215 17
d263 7
a269 1
      templ.u.tex.first_level = stObj->base.BaseLevel;
d297 4
d305 5
a309 1
	  stObj->base.BaseLevel != (*sv)->u.tex.first_level) {
d359 1
a359 1
         st_mesa_format_to_pipe_format(stObj->base._BufferObjectFormat);
d388 1
a388 1
   GLuint unit, new_count;
a416 7
   /* Ex: if old_max = 3 and *num_textures = 1, we need to pass an
    * array of views={X, NULL, NULL} to unref the old texture views
    * at positions [1] and [2].
    */
   new_count = MAX2(*num_textures, old_max);
   assert(new_count <= max_units);

d419 1
a419 1
                         new_count,
d464 1
a464 1
                      ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits,
@


