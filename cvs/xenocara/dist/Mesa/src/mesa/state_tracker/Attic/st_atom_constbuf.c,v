head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.06.41;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.19;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.10;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/*
 * Authors:
 *   Keith Whitwell <keithw@@vmware.com>
 *   Brian Paul
 */

#include "main/imports.h"
#include "program/prog_parameter.h"
#include "program/prog_print.h"

#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "util/u_inlines.h"
#include "util/u_upload_mgr.h"
#include "cso_cache/cso_context.h"

#include "st_debug.h"
#include "st_context.h"
#include "st_atom.h"
#include "st_atom_constbuf.h"
#include "st_program.h"
#include "st_cb_bufferobjects.h"

/**
 * Pass the given program parameters to the graphics pipe as a
 * constant buffer.
 * \param shader_type  either PIPE_SHADER_VERTEX or PIPE_SHADER_FRAGMENT
 */
void st_upload_constants( struct st_context *st,
                          struct gl_program_parameter_list *params,
                          unsigned shader_type)
{
   assert(shader_type == PIPE_SHADER_VERTEX ||
          shader_type == PIPE_SHADER_FRAGMENT ||
          shader_type == PIPE_SHADER_GEOMETRY);

   /* update constants */
   if (params && params->NumParameters) {
      struct pipe_constant_buffer cb;
      const uint paramBytes = params->NumParameters * sizeof(GLfloat) * 4;

      /* Update the constants which come from fixed-function state, such as
       * transformation matrices, fog factors, etc.  The rest of the values in
       * the parameters list are explicitly set by the user with glUniform,
       * glProgramParameter(), etc.
       */
      _mesa_load_state_parameters(st->ctx, params);

      /* We always need to get a new buffer, to keep the drivers simple and
       * avoid gratuitous rendering synchronization.
       * Let's use a user buffer to avoid an unnecessary copy.
       */
      if (st->constbuf_uploader) {
         cb.buffer = NULL;
         cb.user_buffer = NULL;
         u_upload_data(st->constbuf_uploader, 0, paramBytes,
                       params->ParameterValues, &cb.buffer_offset, &cb.buffer);
         u_upload_unmap(st->constbuf_uploader);
      } else {
         cb.buffer = NULL;
         cb.user_buffer = params->ParameterValues;
         cb.buffer_offset = 0;
      }
      cb.buffer_size = paramBytes;

      if (ST_DEBUG & DEBUG_CONSTANTS) {
         debug_printf("%s(shader=%d, numParams=%d, stateFlags=0x%x)\n",
                      __FUNCTION__, shader_type, params->NumParameters,
                      params->StateFlags);
         _mesa_print_parameter_list(params);
      }

      cso_set_constant_buffer(st->cso_context, shader_type, 0, &cb);
      pipe_resource_reference(&cb.buffer, NULL);

      st->state.constants[shader_type].ptr = params->ParameterValues;
      st->state.constants[shader_type].size = paramBytes;
   }
   else if (st->state.constants[shader_type].ptr) {
      /* Unbind. */
      st->state.constants[shader_type].ptr = NULL;
      st->state.constants[shader_type].size = 0;
      cso_set_constant_buffer(st->cso_context, shader_type, 0, NULL);
   }
}


/**
 * Vertex shader:
 */
static void update_vs_constants(struct st_context *st )
{
   struct st_vertex_program *vp = st->vp;
   struct gl_program_parameter_list *params = vp->Base.Base.Parameters;

   st_upload_constants( st, params, PIPE_SHADER_VERTEX );
}


const struct st_tracked_state st_update_vs_constants = {
   "st_update_vs_constants",				/* name */
   {							/* dirty */
      _NEW_PROGRAM_CONSTANTS,                           /* mesa */
      ST_NEW_VERTEX_PROGRAM,				/* st */
   },
   update_vs_constants					/* update */
};



/**
 * Fragment shader:
 */
static void update_fs_constants(struct st_context *st )
{
   struct st_fragment_program *fp = st->fp;
   struct gl_program_parameter_list *params = fp->Base.Base.Parameters;

   st_upload_constants( st, params, PIPE_SHADER_FRAGMENT );
}


const struct st_tracked_state st_update_fs_constants = {
   "st_update_fs_constants",				/* name */
   {							/* dirty */
      _NEW_PROGRAM_CONSTANTS,                           /* mesa */
      ST_NEW_FRAGMENT_PROGRAM,				/* st */
   },
   update_fs_constants					/* update */
};

/* Geometry shader:
 */
static void update_gs_constants(struct st_context *st )
{
   struct st_geometry_program *gp = st->gp;
   struct gl_program_parameter_list *params;

   if (gp) {
      params = gp->Base.Base.Parameters;
      st_upload_constants( st, params, PIPE_SHADER_GEOMETRY );
   }
}

const struct st_tracked_state st_update_gs_constants = {
   "st_update_gs_constants",				/* name */
   {							/* dirty */
      _NEW_PROGRAM_CONSTANTS,                           /* mesa */
      ST_NEW_GEOMETRY_PROGRAM,				/* st */
   },
   update_gs_constants					/* update */
};

static void st_bind_ubos(struct st_context *st,
                           struct gl_shader *shader,
                           unsigned shader_type)
{
   unsigned i;
   struct pipe_constant_buffer cb = { 0 };

   if (!shader)
      return;

   for (i = 0; i < shader->NumUniformBlocks; i++) {
      struct gl_uniform_buffer_binding *binding;
      struct st_buffer_object *st_obj;

      binding = &st->ctx->UniformBufferBindings[shader->UniformBlocks[i].Binding];
      st_obj = st_buffer_object(binding->BufferObject);

      cb.buffer = st_obj->buffer;

      if (cb.buffer) {
         cb.buffer_offset = binding->Offset;
         cb.buffer_size = cb.buffer->width0 - binding->Offset;

         /* AutomaticSize is FALSE if the buffer was set with BindBufferRange.
          * Take the minimum just to be sure.
          */
         if (!binding->AutomaticSize)
            cb.buffer_size = MIN2(cb.buffer_size, (unsigned) binding->Size);
      }
      else {
         cb.buffer_offset = 0;
         cb.buffer_size = 0;
      }

      cso_set_constant_buffer(st->cso_context, shader_type, 1 + i, &cb);
   }
}

static void bind_vs_ubos(struct st_context *st)
{
   struct gl_shader_program *prog =
      st->ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX];

   if (!prog)
      return;

   st_bind_ubos(st, prog->_LinkedShaders[MESA_SHADER_VERTEX], PIPE_SHADER_VERTEX);
}

const struct st_tracked_state st_bind_vs_ubos = {
   "st_bind_vs_ubos",
   {
      0,
      ST_NEW_VERTEX_PROGRAM | ST_NEW_UNIFORM_BUFFER,
   },
   bind_vs_ubos
};

static void bind_fs_ubos(struct st_context *st)
{
   struct gl_shader_program *prog =
      st->ctx->_Shader->CurrentProgram[MESA_SHADER_FRAGMENT];

   if (!prog)
      return;

   st_bind_ubos(st, prog->_LinkedShaders[MESA_SHADER_FRAGMENT], PIPE_SHADER_FRAGMENT);
}

const struct st_tracked_state st_bind_fs_ubos = {
   "st_bind_fs_ubos",
   {
      0,
      ST_NEW_FRAGMENT_PROGRAM | ST_NEW_UNIFORM_BUFFER,
   },
   bind_fs_ubos
};

static void bind_gs_ubos(struct st_context *st)
{
   struct gl_shader_program *prog =
      st->ctx->_Shader->CurrentProgram[MESA_SHADER_GEOMETRY];

   if (!prog)
      return;

   st_bind_ubos(st, prog->_LinkedShaders[MESA_SHADER_GEOMETRY], PIPE_SHADER_GEOMETRY);
}

const struct st_tracked_state st_bind_gs_ubos = {
   "st_bind_gs_ubos",
   {
      0,
      ST_NEW_GEOMETRY_PROGRAM | ST_NEW_UNIFORM_BUFFER,
   },
   bind_gs_ubos
};
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
 *   Keith Whitwell <keith@@tungstengraphics.com>
d221 2
a222 1
   struct gl_shader_program *prog = st->ctx->Shader.CurrentVertexProgram;
d241 2
a242 1
   struct gl_shader_program *prog = st->ctx->Shader.CurrentFragmentProgram;
d259 10
d270 8
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d41 2
d49 1
a49 1

a59 2
   struct pipe_context *pipe = st->pipe;

d66 1
a66 1
      struct pipe_resource *cbuf;
d80 12
a91 4
      cbuf = pipe_user_buffer_create(pipe->screen,
                                     params->ParameterValues,
                                     paramBytes,
                                     PIPE_BIND_CONSTANT_BUFFER);
d94 1
a94 1
	 debug_printf("%s(shader=%d, numParams=%d, stateFlags=0x%x)\n", 
d100 2
a101 2
      st->pipe->set_constant_buffer(st->pipe, shader_type, 0, cbuf);
      pipe_resource_reference(&cbuf, NULL);
d107 1
d110 1
a110 1
      st->pipe->set_constant_buffer(st->pipe, shader_type, 0, NULL);
d130 1
a130 1
      (_NEW_PROGRAM | _NEW_PROGRAM_CONSTANTS),          /* mesa */
d153 1
a153 1
      (_NEW_PROGRAM | _NEW_PROGRAM_CONSTANTS),          /* mesa */
d175 1
a175 1
      (_NEW_PROGRAM | _NEW_PROGRAM_CONSTANTS),          /* mesa */
d180 78
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a58 1
   struct pipe_resource **cbuf = &st->state.constants[shader_type];
d66 1
d78 1
d80 4
a83 4
      pipe_resource_reference(cbuf, NULL );
      *cbuf = pipe_buffer_create(pipe->screen,
				 PIPE_BIND_CONSTANT_BUFFER,
				 paramBytes );
d92 2
a93 4
      /* load Mesa constants into the constant buffer */
      pipe_buffer_write(st->pipe, *cbuf,
				    0, paramBytes,
				    params->ParameterValues);
d95 2
a96 1
      st->pipe->set_constant_buffer(st->pipe, shader_type, 0, *cbuf);
d98 3
a100 4
   else if (*cbuf) {
      st->constants.tracked_state[shader_type].dirty.mesa = 0x0;

      pipe_resource_reference(cbuf, NULL);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d35 2
a36 2
#include "shader/prog_parameter.h"
#include "shader/prog_print.h"
a46 1
#include "st_inlines.h"
d59 1
a59 1
   struct pipe_buffer **cbuf = &st->state.constants[shader_type];
d62 2
a63 1
          shader_type == PIPE_SHADER_FRAGMENT);
d69 5
d79 4
a82 4
      pipe_buffer_reference(cbuf, NULL );
      *cbuf = pipe_buffer_create(pipe->screen, 16,
                                        PIPE_BUFFER_USAGE_CONSTANT,
					paramBytes );
d92 3
a94 4
      if (cbuf)
         st_no_flush_pipe_buffer_write(st, *cbuf,
				       0, paramBytes,
				       params->ParameterValues);
d98 1
a98 1
   else {
d100 3
d151 21
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d35 2
a36 2
#include "program/prog_parameter.h"
#include "program/prog_print.h"
d47 1
d60 1
a60 1
   struct pipe_resource **cbuf = &st->state.constants[shader_type];
d63 1
a63 2
          shader_type == PIPE_SHADER_FRAGMENT ||
          shader_type == PIPE_SHADER_GEOMETRY);
a68 5
      /* Update the constants which come from fixed-function state, such as
       * transformation matrices, fog factors, etc.  The rest of the values in
       * the parameters list are explicitly set by the user with glUniform,
       * glProgramParameter(), etc.
       */
d74 4
a77 4
      pipe_resource_reference(cbuf, NULL );
      *cbuf = pipe_buffer_create(pipe->screen,
				 PIPE_BIND_CONSTANT_BUFFER,
				 paramBytes );
d87 4
a90 3
      pipe_buffer_write(st->pipe, *cbuf,
				    0, paramBytes,
				    params->ParameterValues);
d94 1
a94 1
   else if (*cbuf) {
a95 3

      pipe_resource_reference(cbuf, NULL);
      st->pipe->set_constant_buffer(st->pipe, shader_type, 0, NULL);
a143 21
/* Geometry shader:
 */
static void update_gs_constants(struct st_context *st )
{
   struct st_geometry_program *gp = st->gp;
   struct gl_program_parameter_list *params;

   if (gp) {
      params = gp->Base.Base.Parameters;
      st_upload_constants( st, params, PIPE_SHADER_GEOMETRY );
   }
}

const struct st_tracked_state st_update_gs_constants = {
   "st_update_gs_constants",				/* name */
   {							/* dirty */
      (_NEW_PROGRAM | _NEW_PROGRAM_CONSTANTS),          /* mesa */
      ST_NEW_GEOMETRY_PROGRAM,				/* st */
   },
   update_gs_constants					/* update */
};
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a40 2
#include "util/u_upload_mgr.h"
#include "cso_cache/cso_context.h"
d47 1
a47 1
#include "st_cb_bufferobjects.h"
d58 3
a66 1
      struct pipe_constant_buffer cb;
a77 1
       * Let's use a user buffer to avoid an unnecessary copy.
d79 4
a82 12
      if (st->constbuf_uploader) {
         cb.buffer = NULL;
         cb.user_buffer = NULL;
         u_upload_data(st->constbuf_uploader, 0, paramBytes,
                       params->ParameterValues, &cb.buffer_offset, &cb.buffer);
         u_upload_unmap(st->constbuf_uploader);
      } else {
         cb.buffer = NULL;
         cb.user_buffer = params->ParameterValues;
         cb.buffer_offset = 0;
      }
      cb.buffer_size = paramBytes;
d85 1
a85 1
         debug_printf("%s(shader=%d, numParams=%d, stateFlags=0x%x)\n",
d91 4
a94 2
      cso_set_constant_buffer(st->cso_context, shader_type, 0, &cb);
      pipe_resource_reference(&cb.buffer, NULL);
d96 1
a96 2
      st->state.constants[shader_type].ptr = params->ParameterValues;
      st->state.constants[shader_type].size = paramBytes;
d98 5
a102 5
   else if (st->state.constants[shader_type].ptr) {
      /* Unbind. */
      st->state.constants[shader_type].ptr = NULL;
      st->state.constants[shader_type].size = 0;
      cso_set_constant_buffer(st->cso_context, shader_type, 0, NULL);
d122 1
a122 1
      _NEW_PROGRAM_CONSTANTS,                           /* mesa */
d145 1
a145 1
      _NEW_PROGRAM_CONSTANTS,                           /* mesa */
d167 1
a167 1
      _NEW_PROGRAM_CONSTANTS,                           /* mesa */
a171 78

static void st_bind_ubos(struct st_context *st,
                           struct gl_shader *shader,
                           unsigned shader_type)
{
   unsigned i;
   struct pipe_constant_buffer cb = { 0 };

   if (!shader)
      return;

   for (i = 0; i < shader->NumUniformBlocks; i++) {
      struct gl_uniform_buffer_binding *binding;
      struct st_buffer_object *st_obj;

      binding = &st->ctx->UniformBufferBindings[shader->UniformBlocks[i].Binding];
      st_obj = st_buffer_object(binding->BufferObject);

      cb.buffer = st_obj->buffer;

      if (cb.buffer) {
         cb.buffer_offset = binding->Offset;
         cb.buffer_size = cb.buffer->width0 - binding->Offset;

         /* AutomaticSize is FALSE if the buffer was set with BindBufferRange.
          * Take the minimum just to be sure.
          */
         if (!binding->AutomaticSize)
            cb.buffer_size = MIN2(cb.buffer_size, (unsigned) binding->Size);
      }
      else {
         cb.buffer_offset = 0;
         cb.buffer_size = 0;
      }

      cso_set_constant_buffer(st->cso_context, shader_type, 1 + i, &cb);
   }
}

static void bind_vs_ubos(struct st_context *st)
{
   struct gl_shader_program *prog = st->ctx->Shader.CurrentVertexProgram;

   if (!prog)
      return;

   st_bind_ubos(st, prog->_LinkedShaders[MESA_SHADER_VERTEX], PIPE_SHADER_VERTEX);
}

const struct st_tracked_state st_bind_vs_ubos = {
   "st_bind_vs_ubos",
   {
      0,
      ST_NEW_VERTEX_PROGRAM | ST_NEW_UNIFORM_BUFFER,
   },
   bind_vs_ubos
};

static void bind_fs_ubos(struct st_context *st)
{
   struct gl_shader_program *prog = st->ctx->Shader.CurrentFragmentProgram;

   if (!prog)
      return;

   st_bind_ubos(st, prog->_LinkedShaders[MESA_SHADER_FRAGMENT], PIPE_SHADER_FRAGMENT);
}

const struct st_tracked_state st_bind_fs_ubos = {
   "st_bind_fs_ubos",
   {
      0,
      ST_NEW_FRAGMENT_PROGRAM | ST_NEW_UNIFORM_BUFFER,
   },
   bind_fs_ubos
};


@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
 *   Keith Whitwell <keithw@@vmware.com>
d221 1
a221 2
   struct gl_shader_program *prog =
      st->ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX];
d240 1
a240 2
   struct gl_shader_program *prog =
      st->ctx->_Shader->CurrentProgram[MESA_SHADER_FRAGMENT];
a256 10
static void bind_gs_ubos(struct st_context *st)
{
   struct gl_shader_program *prog =
      st->ctx->_Shader->CurrentProgram[MESA_SHADER_GEOMETRY];

   if (!prog)
      return;

   st_bind_ubos(st, prog->_LinkedShaders[MESA_SHADER_GEOMETRY], PIPE_SHADER_GEOMETRY);
}
a257 8
const struct st_tracked_state st_bind_gs_ubos = {
   "st_bind_gs_ubos",
   {
      0,
      ST_NEW_GEOMETRY_PROGRAM | ST_NEW_UNIFORM_BUFFER,
   },
   bind_gs_ubos
};
@


