head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.09.07.15.20.07;	author jsg;	state Exp;
branches;
next	1.5;
commitid	7kimTMT4YlQauAIU;

1.5
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.06.44;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.23;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.11;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2014.09.07.15.07.50;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	dm8VnQHhowGHmemJ;

1.1.1.5
date	2015.01.25.14.13.19;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.50.25;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "main/bufferobj.h"
#include "main/enums.h"
#include "main/fbobject.h"
#include "main/formats.h"
#include "main/image.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/mipmap.h"
#include "main/pack.h"
#include "main/pbo.h"
#include "main/pixeltransfer.h"
#include "main/texcompress.h"
#include "main/texgetimage.h"
#include "main/teximage.h"
#include "main/texobj.h"
#include "main/texstore.h"

#include "state_tracker/st_debug.h"
#include "state_tracker/st_context.h"
#include "state_tracker/st_cb_fbo.h"
#include "state_tracker/st_cb_flush.h"
#include "state_tracker/st_cb_texture.h"
#include "state_tracker/st_cb_bufferobjects.h"
#include "state_tracker/st_format.h"
#include "state_tracker/st_texture.h"
#include "state_tracker/st_gen_mipmap.h"
#include "state_tracker/st_atom.h"

#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "util/u_inlines.h"
#include "pipe/p_shader_tokens.h"
#include "util/u_tile.h"
#include "util/u_format.h"
#include "util/u_surface.h"
#include "util/u_sampler.h"
#include "util/u_math.h"
#include "util/u_box.h"

#define DBG if (0) printf


enum pipe_texture_target
gl_target_to_pipe(GLenum target)
{
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
      return PIPE_TEXTURE_1D;
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
      return PIPE_TEXTURE_2D;
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_PROXY_TEXTURE_RECTANGLE_NV:
      return PIPE_TEXTURE_RECT;
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      return PIPE_TEXTURE_3D;
   case GL_TEXTURE_CUBE_MAP_ARB:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
      return PIPE_TEXTURE_CUBE;
   case GL_TEXTURE_1D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
      return PIPE_TEXTURE_1D_ARRAY;
   case GL_TEXTURE_2D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return PIPE_TEXTURE_2D_ARRAY;
   case GL_TEXTURE_BUFFER:
      return PIPE_BUFFER;
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
      return PIPE_TEXTURE_CUBE_ARRAY;
   default:
      assert(0);
      return 0;
   }
}


/** called via ctx->Driver.NewTextureImage() */
static struct gl_texture_image *
st_NewTextureImage(struct gl_context * ctx)
{
   DBG("%s\n", __FUNCTION__);
   (void) ctx;
   return (struct gl_texture_image *) ST_CALLOC_STRUCT(st_texture_image);
}


/** called via ctx->Driver.DeleteTextureImage() */
static void
st_DeleteTextureImage(struct gl_context * ctx, struct gl_texture_image *img)
{
   /* nothing special (yet) for st_texture_image */
   _mesa_delete_texture_image(ctx, img);
}


/** called via ctx->Driver.NewTextureObject() */
static struct gl_texture_object *
st_NewTextureObject(struct gl_context * ctx, GLuint name, GLenum target)
{
   struct st_texture_object *obj = ST_CALLOC_STRUCT(st_texture_object);

   DBG("%s\n", __FUNCTION__);
   _mesa_initialize_texture_object(ctx, &obj->base, name, target);

   return &obj->base;
}

/** called via ctx->Driver.DeleteTextureObject() */
static void 
st_DeleteTextureObject(struct gl_context *ctx,
                       struct gl_texture_object *texObj)
{
   struct st_texture_object *stObj = st_texture_object(texObj);

   pipe_resource_reference(&stObj->pt, NULL);
   st_texture_release_all_sampler_views(stObj);
   st_texture_free_sampler_views(stObj);
   _mesa_delete_texture_object(ctx, texObj);
}


/** called via ctx->Driver.FreeTextureImageBuffer() */
static void
st_FreeTextureImageBuffer(struct gl_context *ctx,
                          struct gl_texture_image *texImage)
{
   struct st_texture_image *stImage = st_texture_image(texImage);

   DBG("%s\n", __FUNCTION__);

   if (stImage->pt) {
      pipe_resource_reference(&stImage->pt, NULL);
   }

   _mesa_align_free(stImage->TexData);
   stImage->TexData = NULL;

   free(stImage->transfer);
   stImage->transfer = NULL;
   stImage->num_transfers = 0;
}


/** called via ctx->Driver.MapTextureImage() */
static void
st_MapTextureImage(struct gl_context *ctx,
                   struct gl_texture_image *texImage,
                   GLuint slice, GLuint x, GLuint y, GLuint w, GLuint h,
                   GLbitfield mode,
                   GLubyte **mapOut, GLint *rowStrideOut)
{
   struct st_context *st = st_context(ctx);
   struct st_texture_image *stImage = st_texture_image(texImage);
   unsigned pipeMode;
   GLubyte *map;
   struct pipe_transfer *transfer;

   pipeMode = 0x0;
   if (mode & GL_MAP_READ_BIT)
      pipeMode |= PIPE_TRANSFER_READ;
   if (mode & GL_MAP_WRITE_BIT)
      pipeMode |= PIPE_TRANSFER_WRITE;
   if (mode & GL_MAP_INVALIDATE_RANGE_BIT)
      pipeMode |= PIPE_TRANSFER_DISCARD_RANGE;

   map = st_texture_image_map(st, stImage, pipeMode, x, y, slice, w, h, 1,
                              &transfer);
   if (map) {
      *mapOut = map;
      *rowStrideOut = transfer->stride;
   }
   else {
      *mapOut = NULL;
      *rowStrideOut = 0;
   }
}


/** called via ctx->Driver.UnmapTextureImage() */
static void
st_UnmapTextureImage(struct gl_context *ctx,
                     struct gl_texture_image *texImage,
                     GLuint slice)
{
   struct st_context *st = st_context(ctx);
   struct st_texture_image *stImage  = st_texture_image(texImage);
   st_texture_image_unmap(st, stImage, slice);
}


/**
 * Return default texture resource binding bitmask for the given format.
 */
static GLuint
default_bindings(struct st_context *st, enum pipe_format format)
{
   struct pipe_screen *screen = st->pipe->screen;
   const unsigned target = PIPE_TEXTURE_2D;
   unsigned bindings;

   if (util_format_is_depth_or_stencil(format))
      bindings = PIPE_BIND_SAMPLER_VIEW | PIPE_BIND_DEPTH_STENCIL;
   else
      bindings = PIPE_BIND_SAMPLER_VIEW | PIPE_BIND_RENDER_TARGET;

   if (screen->is_format_supported(screen, format, target, 0, bindings))
      return bindings;
   else {
      /* Try non-sRGB. */
      format = util_format_linear(format);

      if (screen->is_format_supported(screen, format, target, 0, bindings))
         return bindings;
      else
         return PIPE_BIND_SAMPLER_VIEW;
   }
}


/**
 * Given the size of a mipmap image, try to compute the size of the level=0
 * mipmap image.
 *
 * Note that this isn't always accurate for odd-sized, non-POW textures.
 * For example, if level=1 and width=40 then the level=0 width may be 80 or 81.
 *
 * \return GL_TRUE for success, GL_FALSE for failure
 */
static GLboolean
guess_base_level_size(GLenum target,
                      GLuint width, GLuint height, GLuint depth, GLuint level,
                      GLuint *width0, GLuint *height0, GLuint *depth0)
{ 
   assert(width >= 1);
   assert(height >= 1);
   assert(depth >= 1);

   if (level > 0) {
      /* Guess the size of the base level.
       * Depending on the image's size, we can't always make a guess here.
       */
      switch (target) {
      case GL_TEXTURE_1D:
      case GL_TEXTURE_1D_ARRAY:
         width <<= level;
         break;

      case GL_TEXTURE_2D:
      case GL_TEXTURE_2D_ARRAY:
         /* We can't make a good guess here, because the base level dimensions
          * can be non-square.
          */
         if (width == 1 || height == 1) {
            return GL_FALSE;
         }
         width <<= level;
         height <<= level;
         break;

      case GL_TEXTURE_CUBE_MAP:
      case GL_TEXTURE_CUBE_MAP_ARRAY:
         width <<= level;
         height <<= level;
         break;

      case GL_TEXTURE_3D:
         /* We can't make a good guess here, because the base level dimensions
          * can be non-cube.
          */
         if (width == 1 || height == 1 || depth == 1) {
            return GL_FALSE;
         }
         width <<= level;
         height <<= level;
         depth <<= level;
         break;

      case GL_TEXTURE_RECTANGLE:
         break;

      default:
         assert(0);
      }
   }

   *width0 = width;
   *height0 = height;
   *depth0 = depth;

   return GL_TRUE;
}


/**
 * Try to allocate a pipe_resource object for the given st_texture_object.
 *
 * We use the given st_texture_image as a clue to determine the size of the
 * mipmap image at level=0.
 *
 * \return GL_TRUE for success, GL_FALSE if out of memory.
 */
static GLboolean
guess_and_alloc_texture(struct st_context *st,
			struct st_texture_object *stObj,
			const struct st_texture_image *stImage)
{
   GLuint lastLevel, width, height, depth;
   GLuint bindings;
   GLuint ptWidth, ptHeight, ptDepth, ptLayers;
   enum pipe_format fmt;

   DBG("%s\n", __FUNCTION__);

   assert(!stObj->pt);

   if (!guess_base_level_size(stObj->base.Target,
                              stImage->base.Width2,
                              stImage->base.Height2,
                              stImage->base.Depth2,
                              stImage->base.Level,
                              &width, &height, &depth)) {
      /* we can't determine the image size at level=0 */
      stObj->width0 = stObj->height0 = stObj->depth0 = 0;
      /* this is not an out of memory error */
      return GL_TRUE;
   }

   /* At this point, (width x height x depth) is the expected size of
    * the level=0 mipmap image.
    */

   /* Guess a reasonable value for lastLevel.  With OpenGL we have no
    * idea how many mipmap levels will be in a texture until we start
    * to render with it.  Make an educated guess here but be prepared
    * to re-allocating a texture buffer with space for more (or fewer)
    * mipmap levels later.
    */
   if ((stObj->base.Sampler.MinFilter == GL_NEAREST ||
        stObj->base.Sampler.MinFilter == GL_LINEAR ||
        (stObj->base.BaseLevel == 0 &&
         stObj->base.MaxLevel == 0) ||
        stImage->base._BaseFormat == GL_DEPTH_COMPONENT ||
        stImage->base._BaseFormat == GL_DEPTH_STENCIL_EXT) &&
       !stObj->base.GenerateMipmap &&
       stImage->base.Level == 0) {
      /* only alloc space for a single mipmap level */
      lastLevel = 0;
   }
   else {
      /* alloc space for a full mipmap */
      lastLevel = _mesa_get_tex_max_num_levels(stObj->base.Target,
                                               width, height, depth) - 1;
   }

   /* Save the level=0 dimensions */
   stObj->width0 = width;
   stObj->height0 = height;
   stObj->depth0 = depth;

   fmt = st_mesa_format_to_pipe_format(stImage->base.TexFormat);

   bindings = default_bindings(st, fmt);

   st_gl_texture_dims_to_pipe_dims(stObj->base.Target,
                                   width, height, depth,
                                   &ptWidth, &ptHeight, &ptDepth, &ptLayers);

   stObj->pt = st_texture_create(st,
                                 gl_target_to_pipe(stObj->base.Target),
                                 fmt,
                                 lastLevel,
                                 ptWidth,
                                 ptHeight,
                                 ptDepth,
                                 ptLayers, 0,
                                 bindings);

   stObj->lastLevel = lastLevel;

   DBG("%s returning %d\n", __FUNCTION__, (stObj->pt != NULL));

   return stObj->pt != NULL;
}


/**
 * Called via ctx->Driver.AllocTextureImageBuffer().
 * If the texture object/buffer already has space for the indicated image,
 * we're done.  Otherwise, allocate memory for the new texture image.
 */
static GLboolean
st_AllocTextureImageBuffer(struct gl_context *ctx,
                           struct gl_texture_image *texImage)
{
   struct st_context *st = st_context(ctx);
   struct st_texture_image *stImage = st_texture_image(texImage);
   struct st_texture_object *stObj = st_texture_object(texImage->TexObject);
   const GLuint level = texImage->Level;
   GLuint width = texImage->Width;
   GLuint height = texImage->Height;
   GLuint depth = texImage->Depth;

   DBG("%s\n", __FUNCTION__);

   assert(!stImage->TexData);
   assert(!stImage->pt); /* xxx this might be wrong */

   /* Look if the parent texture object has space for this image */
   if (stObj->pt &&
       level <= stObj->pt->last_level &&
       st_texture_match_image(stObj->pt, texImage)) {
      /* this image will fit in the existing texture object's memory */
      pipe_resource_reference(&stImage->pt, stObj->pt);
      return GL_TRUE;
   }

   /* The parent texture object does not have space for this image */

   pipe_resource_reference(&stObj->pt, NULL);
   st_texture_release_all_sampler_views(stObj);

   if (!guess_and_alloc_texture(st, stObj, stImage)) {
      /* Probably out of memory.
       * Try flushing any pending rendering, then retry.
       */
      st_finish(st);
      if (!guess_and_alloc_texture(st, stObj, stImage)) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage");
         return GL_FALSE;
      }
   }

   if (stObj->pt &&
       st_texture_match_image(stObj->pt, texImage)) {
      /* The image will live in the object's mipmap memory */
      pipe_resource_reference(&stImage->pt, stObj->pt);
      assert(stImage->pt);
      return GL_TRUE;
   }
   else {
      /* Create a new, temporary texture/resource/buffer to hold this
       * one texture image.  Note that when we later access this image
       * (either for mapping or copying) we'll want to always specify
       * mipmap level=0, even if the image represents some other mipmap
       * level.
       */
      enum pipe_format format =
         st_mesa_format_to_pipe_format(texImage->TexFormat);
      GLuint bindings = default_bindings(st, format);
      GLuint ptWidth, ptHeight, ptDepth, ptLayers;

      st_gl_texture_dims_to_pipe_dims(stObj->base.Target,
                                      width, height, depth,
                                      &ptWidth, &ptHeight, &ptDepth, &ptLayers);

      stImage->pt = st_texture_create(st,
                                      gl_target_to_pipe(stObj->base.Target),
                                      format,
                                      0, /* lastLevel */
                                      ptWidth,
                                      ptHeight,
                                      ptDepth,
                                      ptLayers, 0,
                                      bindings);
      return stImage->pt != NULL;
   }
}


/**
 * Preparation prior to glTexImage.  Basically check the 'surface_based'
 * field and switch to a "normal" tex image if necessary.
 */
static void
prep_teximage(struct gl_context *ctx, struct gl_texture_image *texImage,
              GLenum format, GLenum type)
{
   struct gl_texture_object *texObj = texImage->TexObject;
   struct st_texture_object *stObj = st_texture_object(texObj);

   /* switch to "normal" */
   if (stObj->surface_based) {
      const GLenum target = texObj->Target;
      const GLuint level = texImage->Level;
      mesa_format texFormat;

      _mesa_clear_texture_object(ctx, texObj);
      pipe_resource_reference(&stObj->pt, NULL);

      /* oops, need to init this image again */
      texFormat = _mesa_choose_texture_format(ctx, texObj, target, level,
                                              texImage->InternalFormat, format,
                                              type);

      _mesa_init_teximage_fields(ctx, texImage,
                                 texImage->Width, texImage->Height,
                                 texImage->Depth, texImage->Border,
                                 texImage->InternalFormat, texFormat);

      stObj->surface_based = GL_FALSE;
   }
}


/**
 * Return a writemask for the gallium blit. The parameters can be base
 * formats or "format" from glDrawPixels/glTexImage/glGetTexImage.
 */
unsigned
st_get_blit_mask(GLenum srcFormat, GLenum dstFormat)
{
   switch (dstFormat) {
   case GL_DEPTH_STENCIL:
      switch (srcFormat) {
      case GL_DEPTH_STENCIL:
         return PIPE_MASK_ZS;
      case GL_DEPTH_COMPONENT:
         return PIPE_MASK_Z;
      case GL_STENCIL_INDEX:
         return PIPE_MASK_S;
      default:
         assert(0);
         return 0;
      }

   case GL_DEPTH_COMPONENT:
      switch (srcFormat) {
      case GL_DEPTH_STENCIL:
      case GL_DEPTH_COMPONENT:
         return PIPE_MASK_Z;
      default:
         assert(0);
         return 0;
      }

   case GL_STENCIL_INDEX:
      switch (srcFormat) {
      case GL_STENCIL_INDEX:
         return PIPE_MASK_S;
      default:
         assert(0);
         return 0;
      }

   default:
      return PIPE_MASK_RGBA;
   }
}


static void
st_TexSubImage(struct gl_context *ctx, GLuint dims,
               struct gl_texture_image *texImage,
               GLint xoffset, GLint yoffset, GLint zoffset,
               GLint width, GLint height, GLint depth,
               GLenum format, GLenum type, const void *pixels,
               const struct gl_pixelstore_attrib *unpack)
{
   struct st_context *st = st_context(ctx);
   struct st_texture_image *stImage = st_texture_image(texImage);
   struct st_texture_object *stObj = st_texture_object(texImage->TexObject);
   struct pipe_context *pipe = st->pipe;
   struct pipe_screen *screen = pipe->screen;
   struct pipe_resource *dst = stImage->pt;
   struct pipe_resource *src = NULL;
   struct pipe_resource src_templ;
   struct pipe_transfer *transfer;
   struct pipe_blit_info blit;
   enum pipe_format src_format, dst_format;
   mesa_format mesa_src_format;
   GLenum gl_target = texImage->TexObject->Target;
   unsigned bind;
   GLubyte *map;

   if (!st->prefer_blit_based_texture_transfer) {
      goto fallback;
   }

   if (!dst) {
      goto fallback;
   }

   /* XXX Fallback for depth-stencil formats due to an incomplete stencil
    * blit implementation in some drivers. */
   if (format == GL_DEPTH_STENCIL) {
      goto fallback;
   }

   /* If the base internal format and the texture format don't match,
    * we can't use blit-based TexSubImage. */
   if (texImage->_BaseFormat !=
       _mesa_get_format_base_format(texImage->TexFormat)) {
      goto fallback;
   }

   /* See if the texture format already matches the format and type,
    * in which case the memcpy-based fast path will likely be used and
    * we don't have to blit. */
   if (_mesa_format_matches_format_and_type(texImage->TexFormat, format,
                                            type, unpack->SwapBytes)) {
      goto fallback;
   }

   if (format == GL_DEPTH_COMPONENT || format == GL_DEPTH_STENCIL)
      bind = PIPE_BIND_DEPTH_STENCIL;
   else
      bind = PIPE_BIND_RENDER_TARGET;

   /* See if the destination format is supported.
    * For luminance and intensity, only the red channel is stored there. */
   dst_format = util_format_linear(dst->format);
   dst_format = util_format_luminance_to_red(dst_format);
   dst_format = util_format_intensity_to_red(dst_format);

   if (!dst_format ||
       !screen->is_format_supported(screen, dst_format, dst->target,
                                    dst->nr_samples, bind)) {
      goto fallback;
   }

   /* Choose the source format. */
   src_format = st_choose_matching_format(screen, PIPE_BIND_SAMPLER_VIEW,
                                          format, type, unpack->SwapBytes);
   if (!src_format) {
      goto fallback;
   }

   mesa_src_format = st_pipe_format_to_mesa_format(src_format);

   /* There is no reason to do this if we cannot use memcpy for the temporary
    * source texture at least. This also takes transfer ops into account,
    * etc. */
   if (!_mesa_texstore_can_use_memcpy(ctx,
                             _mesa_get_format_base_format(mesa_src_format),
                             mesa_src_format, format, type, unpack)) {
      goto fallback;
   }

   /* TexSubImage only sets a single cubemap face. */
   if (gl_target == GL_TEXTURE_CUBE_MAP) {
      gl_target = GL_TEXTURE_2D;
   }

   /* Initialize the source texture description. */
   memset(&src_templ, 0, sizeof(src_templ));
   src_templ.target = gl_target_to_pipe(gl_target);
   src_templ.format = src_format;
   src_templ.bind = PIPE_BIND_SAMPLER_VIEW;
   src_templ.usage = PIPE_USAGE_STAGING;

   st_gl_texture_dims_to_pipe_dims(gl_target, width, height, depth,
                                   &src_templ.width0, &src_templ.height0,
                                   &src_templ.depth0, &src_templ.array_size);

   /* Check for NPOT texture support. */
   if (!screen->get_param(screen, PIPE_CAP_NPOT_TEXTURES) &&
       (!util_is_power_of_two(src_templ.width0) ||
        !util_is_power_of_two(src_templ.height0) ||
        !util_is_power_of_two(src_templ.depth0))) {
      goto fallback;
   }

   /* Create the source texture. */
   src = screen->resource_create(screen, &src_templ);
   if (!src) {
      goto fallback;
   }

   /* Map source pixels. */
   pixels = _mesa_validate_pbo_teximage(ctx, dims, width, height, depth,
                                        format, type, pixels, unpack,
                                        "glTexSubImage");
   if (!pixels) {
      /* This is a GL error. */
      pipe_resource_reference(&src, NULL);
      return;
   }

   /* From now on, we need the gallium representation of dimensions. */
   if (gl_target == GL_TEXTURE_1D_ARRAY) {
      zoffset = yoffset;
      yoffset = 0;
      depth = height;
      height = 1;
   }

   map = pipe_transfer_map_3d(pipe, src, 0, PIPE_TRANSFER_WRITE, 0, 0, 0,
                              width, height, depth, &transfer);
   if (!map) {
      _mesa_unmap_teximage_pbo(ctx, unpack);
      pipe_resource_reference(&src, NULL);
      goto fallback;
   }

   /* Upload pixels (just memcpy). */
   {
      const uint bytesPerRow = width * util_format_get_blocksize(src_format);
      GLuint row, slice;

      for (slice = 0; slice < (unsigned) depth; slice++) {
         if (gl_target == GL_TEXTURE_1D_ARRAY) {
            /* 1D array textures.
             * We need to convert gallium coords to GL coords.
             */
            GLvoid *src = _mesa_image_address3d(unpack, pixels,
                                                width, depth, format,
                                                type, 0, slice, 0);
            memcpy(map, src, bytesPerRow);
         }
         else {
            ubyte *slice_map = map;

            for (row = 0; row < (unsigned) height; row++) {
               GLvoid *src = _mesa_image_address3d(unpack, pixels,
                                                   width, height, format,
                                                   type, slice, row, 0);
               memcpy(slice_map, src, bytesPerRow);
               slice_map += transfer->stride;
            }
         }
         map += transfer->layer_stride;
      }
   }

   pipe_transfer_unmap(pipe, transfer);
   _mesa_unmap_teximage_pbo(ctx, unpack);

   /* Blit. */
   memset(&blit, 0, sizeof(blit));
   blit.src.resource = src;
   blit.src.level = 0;
   blit.src.format = src_format;
   blit.dst.resource = dst;
   blit.dst.level = stObj->pt != stImage->pt ? 0 : texImage->Level;
   blit.dst.format = dst_format;
   blit.src.box.x = blit.src.box.y = blit.src.box.z = 0;
   blit.dst.box.x = xoffset;
   blit.dst.box.y = yoffset;
   blit.dst.box.z = zoffset + texImage->Face;
   blit.src.box.width = blit.dst.box.width = width;
   blit.src.box.height = blit.dst.box.height = height;
   blit.src.box.depth = blit.dst.box.depth = depth;
   blit.mask = st_get_blit_mask(format, texImage->_BaseFormat);
   blit.filter = PIPE_TEX_FILTER_NEAREST;
   blit.scissor_enable = FALSE;

   st->pipe->blit(st->pipe, &blit);

   pipe_resource_reference(&src, NULL);
   return;

fallback:
   _mesa_store_texsubimage(ctx, dims, texImage, xoffset, yoffset, zoffset,
                           width, height, depth, format, type, pixels,
                           unpack);
}

static void
st_TexImage(struct gl_context * ctx, GLuint dims,
            struct gl_texture_image *texImage,
            GLenum format, GLenum type, const void *pixels,
            const struct gl_pixelstore_attrib *unpack)
{
   assert(dims == 1 || dims == 2 || dims == 3);

   prep_teximage(ctx, texImage, format, type);

   if (texImage->Width == 0 || texImage->Height == 0 || texImage->Depth == 0)
      return;

   /* allocate storage for texture data */
   if (!ctx->Driver.AllocTextureImageBuffer(ctx, texImage)) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage%uD", dims);
      return;
   }

   st_TexSubImage(ctx, dims, texImage, 0, 0, 0,
                  texImage->Width, texImage->Height, texImage->Depth,
                  format, type, pixels, unpack);
}


static void
st_CompressedTexImage(struct gl_context *ctx, GLuint dims,
                      struct gl_texture_image *texImage,
                      GLsizei imageSize, const GLvoid *data)
{
   prep_teximage(ctx, texImage, GL_NONE, GL_NONE);
   _mesa_store_compressed_teximage(ctx, dims, texImage, imageSize, data);
}




/**
 * Called via ctx->Driver.GetTexImage()
 *
 * This uses a blit to copy the texture to a texture format which matches
 * the format and type combo and then a fast read-back is done using memcpy.
 * We can do arbitrary X/Y/Z/W/0/1 swizzling here as long as there is
 * a format which matches the swizzling.
 *
 * If such a format isn't available, it falls back to _mesa_get_teximage.
 *
 * NOTE: Drivers usually do a blit to convert between tiled and linear
 *       texture layouts during texture uploads/downloads, so the blit
 *       we do here should be free in such cases.
 */
static void
st_GetTexImage(struct gl_context * ctx,
               GLenum format, GLenum type, GLvoid * pixels,
               struct gl_texture_image *texImage)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   struct pipe_screen *screen = pipe->screen;
   GLuint width = texImage->Width;
   GLuint height = texImage->Height;
   GLuint depth = texImage->Depth;
   struct st_texture_image *stImage = st_texture_image(texImage);
   struct pipe_resource *src = st_texture_object(texImage->TexObject)->pt;
   struct pipe_resource *dst = NULL;
   struct pipe_resource dst_templ;
   enum pipe_format dst_format, src_format;
   mesa_format mesa_format;
   GLenum gl_target = texImage->TexObject->Target;
   enum pipe_texture_target pipe_target;
   struct pipe_blit_info blit;
   unsigned bind = PIPE_BIND_TRANSFER_READ;
   struct pipe_transfer *tex_xfer;
   ubyte *map = NULL;
   boolean done = FALSE;

   if (!st->prefer_blit_based_texture_transfer &&
       !_mesa_is_format_compressed(texImage->TexFormat)) {
      /* Try to avoid the fallback if we're doing texture decompression here */
      goto fallback;
   }

   if (!stImage->pt || !src) {
      goto fallback;
   }

   /* XXX Fallback to _mesa_get_teximage for depth-stencil formats
    * due to an incomplete stencil blit implementation in some drivers. */
   if (format == GL_DEPTH_STENCIL) {
      goto fallback;
   }

   /* If the base internal format and the texture format don't match, we have
    * to fall back to _mesa_get_teximage. */
   if (texImage->_BaseFormat !=
       _mesa_get_format_base_format(texImage->TexFormat)) {
      goto fallback;
   }

   /* See if the texture format already matches the format and type,
    * in which case the memcpy-based fast path will be used. */
   if (_mesa_format_matches_format_and_type(texImage->TexFormat, format,
                                            type, ctx->Pack.SwapBytes)) {
      goto fallback;
   }

   /* Convert the source format to what is expected by GetTexImage
    * and see if it's supported.
    *
    * This only applies to glGetTexImage:
    * - Luminance must be returned as (L,0,0,1).
    * - Luminance alpha must be returned as (L,0,0,A).
    * - Intensity must be returned as (I,0,0,1)
    */
   src_format = util_format_linear(src->format);
   src_format = util_format_luminance_to_red(src_format);
   src_format = util_format_intensity_to_red(src_format);

   if (!src_format ||
       !screen->is_format_supported(screen, src_format, src->target,
                                    src->nr_samples,
                                    PIPE_BIND_SAMPLER_VIEW)) {
      goto fallback;
   }

   if (format == GL_DEPTH_COMPONENT || format == GL_DEPTH_STENCIL)
      bind |= PIPE_BIND_DEPTH_STENCIL;
   else
      bind |= PIPE_BIND_RENDER_TARGET;

   /* GetTexImage only returns a single face for cubemaps. */
   if (gl_target == GL_TEXTURE_CUBE_MAP) {
      gl_target = GL_TEXTURE_2D;
   }
   pipe_target = gl_target_to_pipe(gl_target);

   /* Choose the destination format by finding the best match
    * for the format+type combo. */
   dst_format = st_choose_matching_format(screen, bind, format, type,
					  ctx->Pack.SwapBytes);

   if (dst_format == PIPE_FORMAT_NONE) {
      GLenum dst_glformat;

      /* Fall back to _mesa_get_teximage except for compressed formats,
       * where decompression with a blit is always preferred. */
      if (!util_format_is_compressed(src->format)) {
         goto fallback;
      }

      /* Set the appropriate format for the decompressed texture.
       * Luminance and sRGB formats shouldn't appear here.*/
      switch (src_format) {
      case PIPE_FORMAT_DXT1_RGB:
      case PIPE_FORMAT_DXT1_RGBA:
      case PIPE_FORMAT_DXT3_RGBA:
      case PIPE_FORMAT_DXT5_RGBA:
      case PIPE_FORMAT_RGTC1_UNORM:
      case PIPE_FORMAT_RGTC2_UNORM:
      case PIPE_FORMAT_ETC1_RGB8:
         dst_glformat = GL_RGBA8;
         break;
      case PIPE_FORMAT_RGTC1_SNORM:
      case PIPE_FORMAT_RGTC2_SNORM:
         if (!ctx->Extensions.EXT_texture_snorm)
            goto fallback;
         dst_glformat = GL_RGBA8_SNORM;
         break;
      /* TODO: for BPTC_*FLOAT, set RGBA32F and check for ARB_texture_float */
      default:
         assert(0);
         goto fallback;
      }

      dst_format = st_choose_format(st, dst_glformat, format, type,
                                    pipe_target, 0, bind, FALSE);

      if (dst_format == PIPE_FORMAT_NONE) {
         /* unable to get an rgba format!?! */
         goto fallback;
      }
   }

   /* create the destination texture */
   memset(&dst_templ, 0, sizeof(dst_templ));
   dst_templ.target = pipe_target;
   dst_templ.format = dst_format;
   dst_templ.bind = bind;
   dst_templ.usage = PIPE_USAGE_STAGING;

   st_gl_texture_dims_to_pipe_dims(gl_target, width, height, depth,
                                   &dst_templ.width0, &dst_templ.height0,
                                   &dst_templ.depth0, &dst_templ.array_size);

   dst = screen->resource_create(screen, &dst_templ);
   if (!dst) {
      goto fallback;
   }

   /* From now on, we need the gallium representation of dimensions. */
   if (gl_target == GL_TEXTURE_1D_ARRAY) {
      depth = height;
      height = 1;
   }

   memset(&blit, 0, sizeof(blit));
   blit.src.resource = src;
   blit.src.level = texImage->Level;
   blit.src.format = src_format;
   blit.dst.resource = dst;
   blit.dst.level = 0;
   blit.dst.format = dst->format;
   blit.src.box.x = blit.dst.box.x = 0;
   blit.src.box.y = blit.dst.box.y = 0;
   blit.src.box.z = texImage->Face;
   blit.dst.box.z = 0;
   blit.src.box.width = blit.dst.box.width = width;
   blit.src.box.height = blit.dst.box.height = height;
   blit.src.box.depth = blit.dst.box.depth = depth;
   blit.mask = st_get_blit_mask(texImage->_BaseFormat, format);
   blit.filter = PIPE_TEX_FILTER_NEAREST;
   blit.scissor_enable = FALSE;

   /* blit/render/decompress */
   st->pipe->blit(st->pipe, &blit);

   pixels = _mesa_map_pbo_dest(ctx, &ctx->Pack, pixels);

   map = pipe_transfer_map_3d(pipe, dst, 0, PIPE_TRANSFER_READ,
                              0, 0, 0, width, height, depth, &tex_xfer);
   if (!map) {
      goto end;
   }

   mesa_format = st_pipe_format_to_mesa_format(dst_format);

   /* copy/pack data into user buffer */
   if (_mesa_format_matches_format_and_type(mesa_format, format, type,
                                            ctx->Pack.SwapBytes)) {
      /* memcpy */
      const uint bytesPerRow = width * util_format_get_blocksize(dst_format);
      GLuint row, slice;

      for (slice = 0; slice < depth; slice++) {
         if (gl_target == GL_TEXTURE_1D_ARRAY) {
            /* 1D array textures.
             * We need to convert gallium coords to GL coords.
             */
            GLvoid *dest = _mesa_image_address3d(&ctx->Pack, pixels,
                                                 width, depth, format,
                                                 type, 0, slice, 0);
            memcpy(dest, map, bytesPerRow);
         }
         else {
            ubyte *slice_map = map;

            for (row = 0; row < height; row++) {
               GLvoid *dest = _mesa_image_address3d(&ctx->Pack, pixels,
                                                    width, height, format,
                                                    type, slice, row, 0);
               memcpy(dest, slice_map, bytesPerRow);
               slice_map += tex_xfer->stride;
            }
         }
         map += tex_xfer->layer_stride;
      }
   }
   else {
      /* format translation via floats */
      GLuint row, slice;
      GLfloat *rgba;

      assert(util_format_is_compressed(src->format));

      rgba = malloc(width * 4 * sizeof(GLfloat));
      if (!rgba) {
         goto end;
      }

      if (ST_DEBUG & DEBUG_FALLBACK)
         debug_printf("%s: fallback format translation\n", __FUNCTION__);

      for (slice = 0; slice < depth; slice++) {
         if (gl_target == GL_TEXTURE_1D_ARRAY) {
            /* 1D array textures.
             * We need to convert gallium coords to GL coords.
             */
            GLvoid *dest = _mesa_image_address3d(&ctx->Pack, pixels,
                                                 width, depth, format,
                                                 type, 0, slice, 0);

            /* get float[4] rgba row from surface */
            pipe_get_tile_rgba_format(tex_xfer, map, 0, 0, width, 1,
                                      dst_format, rgba);

            _mesa_pack_rgba_span_float(ctx, width, (GLfloat (*)[4]) rgba, format,
                                       type, dest, &ctx->Pack, 0);
         }
         else {
            for (row = 0; row < height; row++) {
               GLvoid *dest = _mesa_image_address3d(&ctx->Pack, pixels,
                                                    width, height, format,
                                                    type, slice, row, 0);

               /* get float[4] rgba row from surface */
               pipe_get_tile_rgba_format(tex_xfer, map, 0, row, width, 1,
                                         dst_format, rgba);

               _mesa_pack_rgba_span_float(ctx, width, (GLfloat (*)[4]) rgba, format,
                                          type, dest, &ctx->Pack, 0);
            }
         }
         map += tex_xfer->layer_stride;
      }

      free(rgba);
   }
   done = TRUE;

end:
   if (map)
      pipe_transfer_unmap(pipe, tex_xfer);

   _mesa_unmap_pbo_dest(ctx, &ctx->Pack);
   pipe_resource_reference(&dst, NULL);

fallback:
   if (!done) {
      _mesa_get_teximage(ctx, format, type, pixels, texImage);
   }
}


/**
 * Do a CopyTexSubImage operation using a read transfer from the source,
 * a write transfer to the destination and get_tile()/put_tile() to access
 * the pixels/texels.
 *
 * Note: srcY=0=TOP of renderbuffer
 */
static void
fallback_copy_texsubimage(struct gl_context *ctx,
                          struct st_renderbuffer *strb,
                          struct st_texture_image *stImage,
                          GLenum baseFormat,
                          GLint destX, GLint destY, GLint slice,
                          GLint srcX, GLint srcY,
                          GLsizei width, GLsizei height)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   struct pipe_transfer *src_trans;
   GLubyte *texDest;
   enum pipe_transfer_usage transfer_usage;
   void *map;
   unsigned dst_width = width;
   unsigned dst_height = height;
   unsigned dst_depth = 1;
   struct pipe_transfer *transfer;

   if (ST_DEBUG & DEBUG_FALLBACK)
      debug_printf("%s: fallback processing\n", __FUNCTION__);

   if (st_fb_orientation(ctx->ReadBuffer) == Y_0_TOP) {
      srcY = strb->Base.Height - srcY - height;
   }

   map = pipe_transfer_map(pipe,
                           strb->texture,
                           strb->surface->u.tex.level,
                           strb->surface->u.tex.first_layer,
                           PIPE_TRANSFER_READ,
                           srcX, srcY,
                           width, height, &src_trans);

   if ((baseFormat == GL_DEPTH_COMPONENT ||
        baseFormat == GL_DEPTH_STENCIL) &&
       util_format_is_depth_and_stencil(stImage->pt->format))
      transfer_usage = PIPE_TRANSFER_READ_WRITE;
   else
      transfer_usage = PIPE_TRANSFER_WRITE;

   texDest = st_texture_image_map(st, stImage, transfer_usage,
                                  destX, destY, slice,
                                  dst_width, dst_height, dst_depth,
                                  &transfer);

   if (baseFormat == GL_DEPTH_COMPONENT ||
       baseFormat == GL_DEPTH_STENCIL) {
      const GLboolean scaleOrBias = (ctx->Pixel.DepthScale != 1.0F ||
                                     ctx->Pixel.DepthBias != 0.0F);
      GLint row, yStep;
      uint *data;

      /* determine bottom-to-top vs. top-to-bottom order for src buffer */
      if (st_fb_orientation(ctx->ReadBuffer) == Y_0_TOP) {
         srcY = height - 1;
         yStep = -1;
      }
      else {
         srcY = 0;
         yStep = 1;
      }

      data = malloc(width * sizeof(uint));

      if (data) {
         /* To avoid a large temp memory allocation, do copy row by row */
         for (row = 0; row < height; row++, srcY += yStep) {
            pipe_get_tile_z(src_trans, map, 0, srcY, width, 1, data);
            if (scaleOrBias) {
               _mesa_scale_and_bias_depth_uint(ctx, width, data);
            }

            if (stImage->pt->target == PIPE_TEXTURE_1D_ARRAY) {
               pipe_put_tile_z(transfer, texDest + row*transfer->layer_stride,
                               0, 0, width, 1, data);
            }
            else {
               pipe_put_tile_z(transfer, texDest, 0, row, width, 1, data);
            }
         }
      }
      else {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage()");
      }

      free(data);
   }
   else {
      /* RGBA format */
      GLfloat *tempSrc =
         malloc(width * height * 4 * sizeof(GLfloat));

      if (tempSrc && texDest) {
         const GLint dims = 2;
         GLint dstRowStride;
         struct gl_texture_image *texImage = &stImage->base;
         struct gl_pixelstore_attrib unpack = ctx->DefaultPacking;

         if (st_fb_orientation(ctx->ReadBuffer) == Y_0_TOP) {
            unpack.Invert = GL_TRUE;
         }

         if (stImage->pt->target == PIPE_TEXTURE_1D_ARRAY) {
            dstRowStride = transfer->layer_stride;
         }
         else {
            dstRowStride = transfer->stride;
         }

         /* get float/RGBA image from framebuffer */
         /* XXX this usually involves a lot of int/float conversion.
          * try to avoid that someday.
          */
         pipe_get_tile_rgba_format(src_trans, map, 0, 0, width, height,
                                   util_format_linear(strb->texture->format),
                                   tempSrc);

         /* Store into texture memory.
          * Note that this does some special things such as pixel transfer
          * ops and format conversion.  In particular, if the dest tex format
          * is actually RGBA but the user created the texture as GL_RGB we
          * need to fill-in/override the alpha channel with 1.0.
          */
         _mesa_texstore(ctx, dims,
                        texImage->_BaseFormat, 
                        texImage->TexFormat, 
                        dstRowStride,
                        &texDest,
                        width, height, 1,
                        GL_RGBA, GL_FLOAT, tempSrc, /* src */
                        &unpack);
      }
      else {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexSubImage");
      }

      free(tempSrc);
   }

   st_texture_image_unmap(st, stImage, slice);
   pipe->transfer_unmap(pipe, src_trans);
}


/**
 * Do a CopyTex[Sub]Image1/2/3D() using a hardware (blit) path if possible.
 * Note that the region to copy has already been clipped so we know we
 * won't read from outside the source renderbuffer's bounds.
 *
 * Note: srcY=0=Bottom of renderbuffer (GL convention)
 */
static void
st_CopyTexSubImage(struct gl_context *ctx, GLuint dims,
                   struct gl_texture_image *texImage,
                   GLint destX, GLint destY, GLint slice,
                   struct gl_renderbuffer *rb,
                   GLint srcX, GLint srcY, GLsizei width, GLsizei height)
{
   struct st_texture_image *stImage = st_texture_image(texImage);
   struct st_texture_object *stObj = st_texture_object(texImage->TexObject);
   struct st_renderbuffer *strb = st_renderbuffer(rb);
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   struct pipe_screen *screen = pipe->screen;
   struct pipe_blit_info blit;
   enum pipe_format dst_format;
   GLboolean do_flip = (st_fb_orientation(ctx->ReadBuffer) == Y_0_TOP);
   unsigned bind;
   GLint srcY0, srcY1;

   if (!strb || !strb->surface || !stImage->pt) {
      debug_printf("%s: null strb or stImage\n", __FUNCTION__);
      return;
   }

   if (_mesa_texstore_needs_transfer_ops(ctx, texImage->_BaseFormat,
                                         texImage->TexFormat)) {
      goto fallback;
   }

   /* The base internal format must match the mesa format, so make sure
    * e.g. an RGB internal format is really allocated as RGB and not as RGBA.
    */
   if (texImage->_BaseFormat !=
       _mesa_get_format_base_format(texImage->TexFormat) ||
       rb->_BaseFormat != _mesa_get_format_base_format(rb->Format)) {
      goto fallback;
   }

   /* Choose the destination format to match the TexImage behavior. */
   dst_format = util_format_linear(stImage->pt->format);
   dst_format = util_format_luminance_to_red(dst_format);
   dst_format = util_format_intensity_to_red(dst_format);

   /* See if the destination format is supported. */
   if (texImage->_BaseFormat == GL_DEPTH_STENCIL ||
       texImage->_BaseFormat == GL_DEPTH_COMPONENT) {
      bind = PIPE_BIND_DEPTH_STENCIL;
   }
   else {
      bind = PIPE_BIND_RENDER_TARGET;
   }

   if (!dst_format ||
       !screen->is_format_supported(screen, dst_format, stImage->pt->target,
                                    stImage->pt->nr_samples, bind)) {
      goto fallback;
   }

   /* Y flipping for the main framebuffer. */
   if (do_flip) {
      srcY1 = strb->Base.Height - srcY - height;
      srcY0 = srcY1 + height;
   }
   else {
      srcY0 = srcY;
      srcY1 = srcY0 + height;
   }

   /* Blit the texture.
    * This supports flipping, format conversions, and downsampling.
    */
   memset(&blit, 0, sizeof(blit));
   blit.src.resource = strb->texture;
   blit.src.format = util_format_linear(strb->surface->format);
   blit.src.level = strb->surface->u.tex.level;
   blit.src.box.x = srcX;
   blit.src.box.y = srcY0;
   blit.src.box.z = strb->surface->u.tex.first_layer;
   blit.src.box.width = width;
   blit.src.box.height = srcY1 - srcY0;
   blit.src.box.depth = 1;
   blit.dst.resource = stImage->pt;
   blit.dst.format = dst_format;
   blit.dst.level = stObj->pt != stImage->pt ? 0 : texImage->Level;
   blit.dst.box.x = destX;
   blit.dst.box.y = destY;
   blit.dst.box.z = stImage->base.Face + slice;
   blit.dst.box.width = width;
   blit.dst.box.height = height;
   blit.dst.box.depth = 1;
   blit.mask = st_get_blit_mask(rb->_BaseFormat, texImage->_BaseFormat);
   blit.filter = PIPE_TEX_FILTER_NEAREST;
   pipe->blit(pipe, &blit);
   return;

fallback:
   /* software fallback */
   fallback_copy_texsubimage(ctx,
                             strb, stImage, texImage->_BaseFormat,
                             destX, destY, slice,
                             srcX, srcY, width, height);
}


/**
 * Copy image data from stImage into the texture object 'stObj' at level
 * 'dstLevel'.
 */
static void
copy_image_data_to_texture(struct st_context *st,
			   struct st_texture_object *stObj,
                           GLuint dstLevel,
			   struct st_texture_image *stImage)
{
   /* debug checks */
   {
      const struct gl_texture_image *dstImage =
         stObj->base.Image[stImage->base.Face][dstLevel];
      assert(dstImage);
      assert(dstImage->Width == stImage->base.Width);
      assert(dstImage->Height == stImage->base.Height);
      assert(dstImage->Depth == stImage->base.Depth);
   }

   if (stImage->pt) {
      /* Copy potentially with the blitter:
       */
      GLuint src_level;
      if (stImage->pt->last_level == 0)
         src_level = 0;
      else
         src_level = stImage->base.Level;

      assert(src_level <= stImage->pt->last_level);
      assert(u_minify(stImage->pt->width0, src_level) == stImage->base.Width);
      assert(stImage->pt->target == PIPE_TEXTURE_1D_ARRAY ||
             u_minify(stImage->pt->height0, src_level) == stImage->base.Height);
      assert(stImage->pt->target == PIPE_TEXTURE_2D_ARRAY ||
             stImage->pt->target == PIPE_TEXTURE_CUBE_ARRAY ||
             u_minify(stImage->pt->depth0, src_level) == stImage->base.Depth);

      st_texture_image_copy(st->pipe,
                            stObj->pt, dstLevel,  /* dest texture, level */
                            stImage->pt, src_level, /* src texture, level */
                            stImage->base.Face);

      pipe_resource_reference(&stImage->pt, NULL);
   }
   else if (stImage->TexData) {
      /* Copy from malloc'd memory */
      /* XXX this should be re-examined/tested with a compressed format */
      GLuint blockSize = util_format_get_blocksize(stObj->pt->format);
      GLuint srcRowStride = stImage->base.Width * blockSize;
      GLuint srcSliceStride = stImage->base.Height * srcRowStride;
      st_texture_image_data(st,
                            stObj->pt,
                            stImage->base.Face,
                            dstLevel,
                            stImage->TexData,
                            srcRowStride,
                            srcSliceStride);
      _mesa_align_free(stImage->TexData);
      stImage->TexData = NULL;
   }

   pipe_resource_reference(&stImage->pt, stObj->pt);
}


/**
 * Called during state validation.  When this function is finished,
 * the texture object should be ready for rendering.
 * \return GL_TRUE for success, GL_FALSE for failure (out of mem)
 */
GLboolean
st_finalize_texture(struct gl_context *ctx,
		    struct pipe_context *pipe,
		    struct gl_texture_object *tObj)
{
   struct st_context *st = st_context(ctx);
   struct st_texture_object *stObj = st_texture_object(tObj);
   const GLuint nr_faces = (stObj->base.Target == GL_TEXTURE_CUBE_MAP) ? 6 : 1;
   GLuint face;
   struct st_texture_image *firstImage;
   enum pipe_format firstImageFormat;
   GLuint ptWidth, ptHeight, ptDepth, ptLayers, ptNumSamples;

   if (_mesa_is_texture_complete(tObj, &tObj->Sampler)) {
      /* The texture is complete and we know exactly how many mipmap levels
       * are present/needed.  This is conditional because we may be called
       * from the st_generate_mipmap() function when the texture object is
       * incomplete.  In that case, we'll have set stObj->lastLevel before
       * we get here.
       */
      if (stObj->base.Sampler.MinFilter == GL_LINEAR ||
          stObj->base.Sampler.MinFilter == GL_NEAREST)
         stObj->lastLevel = stObj->base.BaseLevel;
      else
         stObj->lastLevel = stObj->base._MaxLevel;
   }

   if (tObj->Target == GL_TEXTURE_BUFFER) {
      struct st_buffer_object *st_obj = st_buffer_object(tObj->BufferObject);

      if (!st_obj) {
         pipe_resource_reference(&stObj->pt, NULL);
         st_texture_release_all_sampler_views(stObj);
         return GL_TRUE;
      }

      if (st_obj->buffer != stObj->pt) {
         pipe_resource_reference(&stObj->pt, st_obj->buffer);
         st_texture_release_all_sampler_views(stObj);
         stObj->width0 = stObj->pt->width0 / _mesa_get_format_bytes(tObj->_BufferObjectFormat);
         stObj->height0 = 1;
         stObj->depth0 = 1;
      }
      return GL_TRUE;

   }

   firstImage = st_texture_image(stObj->base.Image[0][stObj->base.BaseLevel]);
   assert(firstImage);

   /* If both firstImage and stObj point to a texture which can contain
    * all active images, favour firstImage.  Note that because of the
    * completeness requirement, we know that the image dimensions
    * will match.
    */
   if (firstImage->pt &&
       firstImage->pt != stObj->pt &&
       (!stObj->pt || firstImage->pt->last_level >= stObj->pt->last_level)) {
      pipe_resource_reference(&stObj->pt, firstImage->pt);
      st_texture_release_all_sampler_views(stObj);
   }

   /* If this texture comes from a window system, there is nothing else to do. */
   if (stObj->surface_based) {
      return GL_TRUE;
   }

   /* Find gallium format for the Mesa texture */
   firstImageFormat = st_mesa_format_to_pipe_format(firstImage->base.TexFormat);

   /* Find size of level=0 Gallium mipmap image, plus number of texture layers */
   {
      GLuint width, height, depth;
      if (!guess_base_level_size(stObj->base.Target,
                                 firstImage->base.Width2,
                                 firstImage->base.Height2,
                                 firstImage->base.Depth2,
                                 firstImage->base.Level,
                                 &width, &height, &depth)) {
         width = stObj->width0;
         height = stObj->height0;
         depth = stObj->depth0;
      }
      /* convert GL dims to Gallium dims */
      st_gl_texture_dims_to_pipe_dims(stObj->base.Target, width, height, depth,
                                      &ptWidth, &ptHeight, &ptDepth, &ptLayers);
      ptNumSamples = firstImage->base.NumSamples;
   }

   /* If we already have a gallium texture, check that it matches the texture
    * object's format, target, size, num_levels, etc.
    */
   if (stObj->pt) {
      if (stObj->pt->target != gl_target_to_pipe(stObj->base.Target) ||
          stObj->pt->format != firstImageFormat ||
          stObj->pt->last_level < stObj->lastLevel ||
          stObj->pt->width0 != ptWidth ||
          stObj->pt->height0 != ptHeight ||
          stObj->pt->depth0 != ptDepth ||
          stObj->pt->nr_samples != ptNumSamples ||
          stObj->pt->array_size != ptLayers)
      {
         /* The gallium texture does not match the Mesa texture so delete the
          * gallium texture now.  We'll make a new one below.
          */
         pipe_resource_reference(&stObj->pt, NULL);
         st_texture_release_all_sampler_views(stObj);
         st->dirty.st |= ST_NEW_FRAMEBUFFER;
      }
   }

   /* May need to create a new gallium texture:
    */
   if (!stObj->pt) {
      GLuint bindings = default_bindings(st, firstImageFormat);

      stObj->pt = st_texture_create(st,
                                    gl_target_to_pipe(stObj->base.Target),
                                    firstImageFormat,
                                    stObj->lastLevel,
                                    ptWidth,
                                    ptHeight,
                                    ptDepth,
                                    ptLayers, ptNumSamples,
                                    bindings);

      if (!stObj->pt) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage");
         return GL_FALSE;
      }
   }

   /* Pull in any images not in the object's texture:
    */
   for (face = 0; face < nr_faces; face++) {
      GLuint level;
      for (level = stObj->base.BaseLevel; level <= stObj->lastLevel; level++) {
         struct st_texture_image *stImage =
            st_texture_image(stObj->base.Image[face][level]);

         /* Need to import images in main memory or held in other textures.
          */
         if (stImage && stObj->pt != stImage->pt) {
            if (level == 0 ||
                (stImage->base.Width == u_minify(stObj->width0, level) &&
                 stImage->base.Height == u_minify(stObj->height0, level) &&
                 stImage->base.Depth == u_minify(stObj->depth0, level))) {
               /* src image fits expected dest mipmap level size */
               copy_image_data_to_texture(st, stObj, level, stImage);
            }
         }
      }
   }

   return GL_TRUE;
}


/**
 * Called via ctx->Driver.AllocTextureStorage() to allocate texture memory
 * for a whole mipmap stack.
 */
static GLboolean
st_AllocTextureStorage(struct gl_context *ctx,
                       struct gl_texture_object *texObj,
                       GLsizei levels, GLsizei width,
                       GLsizei height, GLsizei depth)
{
   const GLuint numFaces = _mesa_num_tex_faces(texObj->Target);
   struct gl_texture_image *texImage = texObj->Image[0][0];
   struct st_context *st = st_context(ctx);
   struct st_texture_object *stObj = st_texture_object(texObj);
   struct pipe_screen *screen = st->pipe->screen;
   GLuint ptWidth, ptHeight, ptDepth, ptLayers, bindings;
   enum pipe_format fmt;
   GLint level;
   GLuint num_samples = texImage->NumSamples;

   assert(levels > 0);

   /* Save the level=0 dimensions */
   stObj->width0 = width;
   stObj->height0 = height;
   stObj->depth0 = depth;
   stObj->lastLevel = levels - 1;

   fmt = st_mesa_format_to_pipe_format(texImage->TexFormat);

   bindings = default_bindings(st, fmt);

   /* Raise the sample count if the requested one is unsupported. */
   if (num_samples > 1) {
      boolean found = FALSE;

      for (; num_samples <= ctx->Const.MaxSamples; num_samples++) {
         if (screen->is_format_supported(screen, fmt, PIPE_TEXTURE_2D,
                                         num_samples,
                                         PIPE_BIND_SAMPLER_VIEW)) {
            /* Update the sample count in gl_texture_image as well. */
            texImage->NumSamples = num_samples;
            found = TRUE;
            break;
         }
      }

      if (!found) {
         return GL_FALSE;
      }
   }

   st_gl_texture_dims_to_pipe_dims(texObj->Target,
                                   width, height, depth,
                                   &ptWidth, &ptHeight, &ptDepth, &ptLayers);

   stObj->pt = st_texture_create(st,
                                 gl_target_to_pipe(texObj->Target),
                                 fmt,
                                 levels - 1,
                                 ptWidth,
                                 ptHeight,
                                 ptDepth,
                                 ptLayers, num_samples,
                                 bindings);
   if (!stObj->pt)
      return GL_FALSE;

   /* Set image resource pointers */
   for (level = 0; level < levels; level++) {
      GLuint face;
      for (face = 0; face < numFaces; face++) {
         struct st_texture_image *stImage =
            st_texture_image(texObj->Image[face][level]);
         pipe_resource_reference(&stImage->pt, stObj->pt);
      }
   }

   return GL_TRUE;
}


static GLboolean
st_TestProxyTexImage(struct gl_context *ctx, GLenum target,
                     GLint level, mesa_format format,
                     GLint width, GLint height,
                     GLint depth, GLint border)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;

   if (width == 0 || height == 0 || depth == 0) {
      /* zero-sized images are legal, and always fit! */
      return GL_TRUE;
   }

   if (pipe->screen->can_create_resource) {
      /* Ask the gallium driver if the texture is too large */
      struct gl_texture_object *texObj =
         _mesa_get_current_tex_object(ctx, target);
      struct pipe_resource pt;

      /* Setup the pipe_resource object
       */
      memset(&pt, 0, sizeof(pt));

      pt.target = gl_target_to_pipe(target);
      pt.format = st_mesa_format_to_pipe_format(format);

      st_gl_texture_dims_to_pipe_dims(target,
                                      width, height, depth,
                                      &pt.width0, &pt.height0,
                                      &pt.depth0, &pt.array_size);

      if (level == 0 && (texObj->Sampler.MinFilter == GL_LINEAR ||
                         texObj->Sampler.MinFilter == GL_NEAREST)) {
         /* assume just one mipmap level */
         pt.last_level = 0;
      }
      else {
         /* assume a full set of mipmaps */
         pt.last_level = _mesa_logbase2(MAX3(width, height, depth));
      }

      return pipe->screen->can_create_resource(pipe->screen, &pt);
   }
   else {
      /* Use core Mesa fallback */
      return _mesa_test_proxy_teximage(ctx, target, level, format,
                                       width, height, depth, border);
   }
}


void
st_init_texture_functions(struct dd_function_table *functions)
{
   functions->ChooseTextureFormat = st_ChooseTextureFormat;
   functions->QuerySamplesForFormat = st_QuerySamplesForFormat;
   functions->TexImage = st_TexImage;
   functions->TexSubImage = st_TexSubImage;
   functions->CompressedTexSubImage = _mesa_store_compressed_texsubimage;
   functions->CopyTexSubImage = st_CopyTexSubImage;
   functions->GenerateMipmap = st_generate_mipmap;

   functions->GetTexImage = st_GetTexImage;

   /* compressed texture functions */
   functions->CompressedTexImage = st_CompressedTexImage;
   functions->GetCompressedTexImage = _mesa_get_compressed_teximage;

   functions->NewTextureObject = st_NewTextureObject;
   functions->NewTextureImage = st_NewTextureImage;
   functions->DeleteTextureImage = st_DeleteTextureImage;
   functions->DeleteTexture = st_DeleteTextureObject;
   functions->AllocTextureImageBuffer = st_AllocTextureImageBuffer;
   functions->FreeTextureImageBuffer = st_FreeTextureImageBuffer;
   functions->MapTextureImage = st_MapTextureImage;
   functions->UnmapTextureImage = st_UnmapTextureImage;

   /* XXX Temporary until we can query pipe's texture sizes */
   functions->TestProxyTexImage = st_TestProxyTexImage;

   functions->AllocTextureStorage = st_AllocTextureStorage;
}
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a39 1
#include "main/texcompress_etc.h"
a153 1
   struct st_context *st = st_context(ctx);
d157 1
a157 1
   st_texture_release_all_sampler_views(st, stObj);
d210 2
a211 26
      if (_mesa_is_format_etc2(texImage->TexFormat) ||
          (texImage->TexFormat == MESA_FORMAT_ETC1_RGB8 && !st->has_etc1)) {
         /* ETC isn't supported by gallium and it's represented
          * by uncompressed formats. Only write transfers with precompressed
          * data are supported by ES3, which makes this really simple.
          *
          * Just create a temporary storage where the ETC texture will
          * be stored. It will be decompressed in the Unmap function.
          */
         unsigned z = transfer->box.z;
         struct st_texture_image_transfer *itransfer = &stImage->transfer[z];

         itransfer->temp_data =
            malloc(_mesa_format_image_size(texImage->TexFormat, w, h, 1));
         itransfer->temp_stride =
            _mesa_format_row_stride(texImage->TexFormat, w);
         itransfer->map = map;

         *mapOut = itransfer->temp_data;
         *rowStrideOut = itransfer->temp_stride;
      }
      else {
         /* supported mapping */
         *mapOut = map;
         *rowStrideOut = transfer->stride;
      }
a227 29

   if (_mesa_is_format_etc2(texImage->TexFormat) ||
       (texImage->TexFormat == MESA_FORMAT_ETC1_RGB8 && !st->has_etc1)) {
      /* Decompress the ETC texture to the mapped one. */
      unsigned z = slice + stImage->base.Face;
      struct st_texture_image_transfer *itransfer = &stImage->transfer[z];
      struct pipe_transfer *transfer = itransfer->transfer;

      assert(z == transfer->box.z);

      if (texImage->TexFormat == MESA_FORMAT_ETC1_RGB8) {
         _mesa_etc1_unpack_rgba8888(itransfer->map, transfer->stride,
                                    itransfer->temp_data,
                                    itransfer->temp_stride,
                                    transfer->box.width, transfer->box.height);
      }
      else {
         _mesa_unpack_etc2_format(itransfer->map, transfer->stride,
                                  itransfer->temp_data, itransfer->temp_stride,
                                  transfer->box.width, transfer->box.height,
                                  texImage->TexFormat);
      }

      free(itransfer->temp_data);
      itransfer->temp_data = NULL;
      itransfer->temp_stride = 0;
      itransfer->map = 0;
   }

d401 1
a401 1
   fmt = st_mesa_format_to_pipe_format(st, stImage->base.TexFormat);
d452 1
a452 1
       st_texture_match_image(st, stObj->pt, texImage)) {
d461 1
a461 1
   st_texture_release_all_sampler_views(st, stObj);
d475 1
a475 1
       st_texture_match_image(st, stObj->pt, texImage)) {
d489 1
a489 1
         st_mesa_format_to_pipe_format(st, texImage->TexFormat);
a615 3
   assert(!_mesa_is_format_etc2(texImage->TexFormat) &&
          texImage->TexFormat != MESA_FORMAT_ETC1_RGB8);

d663 1
a663 1
   src_format = st_choose_matching_format(st, PIPE_BIND_SAMPLER_VIEW,
d775 1
a775 1
   blit.dst.level = stObj->pt != stImage->pt ? 0 : texImage->TexObject->MinLevel + texImage->Level;
d780 1
a780 1
   blit.dst.box.z = zoffset + texImage->Face + texImage->TexObject->MinLayer;
d862 1
a862 2
   struct st_texture_object *stObj = st_texture_object(texImage->TexObject);
   struct pipe_resource *src = stObj->pt;
a874 3
   assert(!_mesa_is_format_etc2(texImage->TexFormat) &&
          texImage->TexFormat != MESA_FORMAT_ETC1_RGB8);

d913 1
a913 4
   if (stObj->surface_based)
      src_format = util_format_linear(stObj->surface_format);
   else
      src_format = util_format_linear(src->format);
d937 1
a937 1
   dst_format = st_choose_matching_format(st, bind, format, type,
a958 1
      case PIPE_FORMAT_BPTC_RGBA_UNORM:
d967 1
a967 6
      case PIPE_FORMAT_BPTC_RGB_FLOAT:
      case PIPE_FORMAT_BPTC_RGB_UFLOAT:
         if (!ctx->Extensions.ARB_texture_float)
            goto fallback;
         dst_glformat = GL_RGBA32F;
         break;
d1006 1
a1006 1
   blit.src.level = texImage->Level + texImage->TexObject->MinLevel;
d1013 1
a1013 1
   blit.src.box.z = texImage->Face + texImage->TexObject->MinLayer;
a1310 3
   assert(!_mesa_is_format_etc2(texImage->TexFormat) &&
          texImage->TexFormat != MESA_FORMAT_ETC1_RGB8);

d1375 1
a1375 1
   blit.dst.level = stObj->pt != stImage->pt ? 0 : texImage->Level + texImage->TexObject->MinLevel;
d1378 1
a1378 1
   blit.dst.box.z = stImage->base.Face + slice + texImage->TexObject->MinLayer;
a1478 3
   if (tObj->Immutable)
      return GL_TRUE;

d1498 1
a1498 1
         st_texture_release_all_sampler_views(st, stObj);
d1504 1
a1504 1
         st_texture_release_all_sampler_views(st, stObj);
d1525 1
a1525 1
      st_texture_release_all_sampler_views(st, stObj);
d1534 1
a1534 2
   firstImageFormat =
      st_mesa_format_to_pipe_format(st, firstImage->base.TexFormat);
d1572 1
a1572 1
         st_texture_release_all_sampler_views(st, stObj);
d1652 1
a1652 1
   fmt = st_mesa_format_to_pipe_format(st, texImage->TexFormat);
d1731 1
a1731 1
      pt.format = st_mesa_format_to_pipe_format(st, format);
a1756 38
static GLboolean
st_TextureView(struct gl_context *ctx,
               struct gl_texture_object *texObj,
               struct gl_texture_object *origTexObj)
{
   struct st_texture_object *orig = st_texture_object(origTexObj);
   struct st_texture_object *tex = st_texture_object(texObj);
   struct gl_texture_image *image = texObj->Image[0][0];

   const int numFaces = _mesa_num_tex_faces(texObj->Target);
   const int numLevels = texObj->NumLevels;

   int face;
   int level;

   pipe_resource_reference(&tex->pt, orig->pt);

   /* Set image resource pointers */
   for (level = 0; level < numLevels; level++) {
      for (face = 0; face < numFaces; face++) {
         struct st_texture_image *stImage =
            st_texture_image(texObj->Image[face][level]);
         pipe_resource_reference(&stImage->pt, tex->pt);
      }
   }

   tex->surface_based = GL_TRUE;
   tex->surface_format =
      st_mesa_format_to_pipe_format(st_context(ctx), image->TexFormat);

   tex->width0 = image->Width;
   tex->height0 = image->Height;
   tex->depth0 = image->Depth;
   tex->lastLevel = numLevels - 1;

   return GL_TRUE;
}

a1787 1
   functions->TextureView = st_TextureView;
@


1.6
log
@Merge Mesa 10.2.7
@
text
@d40 1
d155 1
d159 1
a159 1
   st_texture_release_all_sampler_views(stObj);
d212 26
a237 2
      *mapOut = map;
      *rowStrideOut = transfer->stride;
d254 29
d456 1
a456 1
   fmt = st_mesa_format_to_pipe_format(stImage->base.TexFormat);
d507 1
a507 1
       st_texture_match_image(stObj->pt, texImage)) {
d516 1
a516 1
   st_texture_release_all_sampler_views(stObj);
d530 1
a530 1
       st_texture_match_image(stObj->pt, texImage)) {
d544 1
a544 1
         st_mesa_format_to_pipe_format(texImage->TexFormat);
d671 3
d721 1
a721 1
   src_format = st_choose_matching_format(screen, PIPE_BIND_SAMPLER_VIEW,
d833 1
a833 1
   blit.dst.level = stObj->pt != stImage->pt ? 0 : texImage->Level;
d838 1
a838 1
   blit.dst.box.z = zoffset + texImage->Face;
d920 2
a921 1
   struct pipe_resource *src = st_texture_object(texImage->TexObject)->pt;
d934 3
d975 4
a978 1
   src_format = util_format_linear(src->format);
d1002 1
a1002 1
   dst_format = st_choose_matching_format(screen, bind, format, type,
d1024 1
d1033 6
a1038 1
      /* TODO: for BPTC_*FLOAT, set RGBA32F and check for ARB_texture_float */
d1077 1
a1077 1
   blit.src.level = texImage->Level;
d1084 1
a1084 1
   blit.src.box.z = texImage->Face;
d1382 3
d1449 1
a1449 1
   blit.dst.level = stObj->pt != stImage->pt ? 0 : texImage->Level;
d1452 1
a1452 1
   blit.dst.box.z = stImage->base.Face + slice;
d1553 3
d1575 1
a1575 1
         st_texture_release_all_sampler_views(stObj);
d1581 1
a1581 1
         st_texture_release_all_sampler_views(stObj);
d1602 1
a1602 1
      st_texture_release_all_sampler_views(stObj);
d1611 2
a1612 1
   firstImageFormat = st_mesa_format_to_pipe_format(firstImage->base.TexFormat);
d1650 1
a1650 1
         st_texture_release_all_sampler_views(stObj);
d1730 1
a1730 1
   fmt = st_mesa_format_to_pipe_format(texImage->TexFormat);
d1809 1
a1809 1
      pt.format = st_mesa_format_to_pipe_format(format);
d1835 38
d1904 1
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d722 2
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
a153 1
   struct st_context *st = st_context(ctx);
d155 4
a158 5
   if (stObj->pt)
      pipe_resource_reference(&stObj->pt, NULL);
   if (stObj->sampler_view) {
      pipe_sampler_view_release(st->pipe, &stObj->sampler_view);
   }
d176 6
a181 4
   if (stImage->TexData) {
      _mesa_align_free(stImage->TexData);
      stImage->TexData = NULL;
   }
d197 1
d207 2
a208 1
   map = st_texture_image_map(st, stImage, pipeMode, x, y, slice, w, h, 1);
d211 1
a211 1
      *rowStrideOut = stImage->transfer->stride;
d228 1
a228 1
   st_texture_image_unmap(st, stImage);
d461 1
a461 1
   pipe_sampler_view_release(st->pipe, &stObj->sampler_view);
d526 1
a526 1
      gl_format texFormat;
d611 1
a611 1
   gl_format mesa_src_format;
d768 1
d864 1
a864 1
   gl_format mesa_format;
d873 3
a875 1
   if (!st->prefer_blit_based_texture_transfer) {
d1002 1
d1155 1
d1166 2
a1167 2
                           strb->rtt_level,
                           strb->rtt_face + strb->rtt_slice,
d1181 2
a1182 1
                                  dst_width, dst_height, dst_depth);
d1212 1
a1212 2
               pipe_put_tile_z(stImage->transfer,
                               texDest + row*stImage->transfer->layer_stride,
d1216 1
a1216 2
               pipe_put_tile_z(stImage->transfer, texDest, 0, row, width, 1,
                               data);
d1242 1
a1242 1
            dstRowStride = stImage->transfer->layer_stride;
d1245 1
a1245 1
            dstRowStride = stImage->transfer->stride;
d1278 1
a1278 1
   st_texture_image_unmap(st, stImage);
d1494 6
d1502 1
a1502 1
         pipe_sampler_view_release(st->pipe, &stObj->sampler_view);
d1523 1
a1523 1
      pipe_sampler_view_release(st->pipe, &stObj->sampler_view);
d1570 1
a1570 1
         pipe_sampler_view_release(st->pipe, &stObj->sampler_view);
d1706 1
a1706 1
                     GLint level, gl_format format,
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a27 1
#include "main/mfeatures.h"
a39 1
#include "main/texfetch.h"
d50 1
a60 1
#include "util/u_blit.h"
d70 1
a70 1
static enum pipe_texture_target
d75 1
d78 4
d84 1
d87 1
d90 7
d99 1
d102 3
d108 3
d128 9
d144 1
a144 1
   _mesa_initialize_texture_object(&obj->base, name, target);
d159 1
a159 9
      if (stObj->sampler_view->context != st->pipe) {
         /* Take "ownership" of this texture sampler view by setting
          * its context pointer to this context.  This avoids potential
          * crashes when the texture object is shared among contexts
          * and the original/owner context has already been destroyed.
          */
         stObj->sampler_view->context = st->pipe;
      }
      pipe_sampler_view_reference(&stObj->sampler_view, NULL);
d165 1
a165 1
/** called via ctx->Driver.FreeTexImageData() */
d167 2
a168 1
st_FreeTextureImageData(struct gl_context * ctx, struct gl_texture_image *texImage)
d178 3
a180 3
   if (texImage->Data) {
      _mesa_align_free(texImage->Data);
      texImage->Data = NULL;
d185 31
a215 24
/**
 * From linux kernel i386 header files, copes with odd sizes better
 * than COPY_DWORDS would:
 * XXX Put this in src/mesa/main/imports.h ???
 */
#if defined(PIPE_CC_GCC) && defined(PIPE_ARCH_X86)
static INLINE void *
__memcpy(void *to, const void *from, size_t n)
{
   int d0, d1, d2;
   __asm__ __volatile__("rep ; movsl\n\t"
                        "testb $2,%b4\n\t"
                        "je 1f\n\t"
                        "movsw\n"
                        "1:\ttestb $1,%b4\n\t"
                        "je 2f\n\t"
                        "movsb\n" "2:":"=&c"(d0), "=&D"(d1), "=&S"(d2)
                        :"0"(n / 4), "q"(n), "1"((long) to), "2"((long) from)
                        :"memory");
   return (to);
}
#else
#define __memcpy(a,b,c) memcpy(a,b,c)
#endif
d218 5
a222 15
/**
 * The system memcpy (at least on ubuntu 5.10) has problems copying
 * to agp (writecombined) memory from a source which isn't 64-byte
 * aligned - there is a 4x performance falloff.
 *
 * The x86 __memcpy is immune to this but is slightly slower
 * (10%-ish) than the system memcpy.
 *
 * The sse_memcpy seems to have a slight cliff at 64/32 bytes, but
 * isn't much faster than x86_memcpy for agp copies.
 * 
 * TODO: switch dynamically.
 */
static void *
do_memcpy(void *dest, const void *src, size_t n)
d224 3
a226 5
   if ((((unsigned long) src) & 63) || (((unsigned long) dest) & 63)) {
      return __memcpy(dest, src, n);
   }
   else
      return memcpy(dest, src, n);
a258 29
/** Return number of image dimensions (1, 2 or 3) for a texture target. */
static GLuint
get_texture_dims(GLenum target)
{
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_1D_ARRAY_EXT:
   case GL_TEXTURE_BUFFER:
      return 1;
   case GL_TEXTURE_2D:
   case GL_TEXTURE_CUBE_MAP_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_TEXTURE_2D_ARRAY_EXT:
      return 2;
   case GL_TEXTURE_3D:
      return 3;
   default:
      assert(0 && "invalid texture target in get_texture_dims()");
      return 1;
   }
}


a272 2
   const GLuint dims = get_texture_dims(target);

d278 41
a318 7
      /* Depending on the image's size, we can't always make a guess here */
      if ((dims >= 1 && width == 1) ||
          (dims >= 2 && height == 1) ||
          (dims >= 3 && depth == 1)) {
         /* we can't determine the image size at level=0 */
         return GL_FALSE;
      }
d320 2
a321 9
      /* grow the image size until we hit level = 0 */
      while (level > 0) {
         if (width > 1)
            width <<= 1;
         if (height > 1)
            height <<= 1;
         if (depth > 1)
            depth <<= 1;
         level--;
d323 1
a323 1
   }      
d359 1
a359 1
                              stImage->level,
d379 2
d384 1
a384 1
       stImage->level == 0) {
d390 2
a391 4
      GLuint l2width = util_logbase2(width);
      GLuint l2height = util_logbase2(height);
      GLuint l2depth = util_logbase2(depth);
      lastLevel = MAX2(MAX2(l2width, l2height), l2depth);
d414 1
a414 1
                                 ptLayers,
d417 2
d426 3
a428 5
 * Adjust pixel unpack params and image dimensions to strip off the
 * texture border.
 * Gallium doesn't support texture borders.  They've seldem been used
 * and seldom been implemented correctly anyway.
 * \param unpackNew  returns the new pixel unpack parameters
d430 76
a505 28
static void
strip_texture_border(GLint border,
                     GLint *width, GLint *height, GLint *depth,
                     const struct gl_pixelstore_attrib *unpack,
                     struct gl_pixelstore_attrib *unpackNew)
{
   assert(border > 0);  /* sanity check */

   *unpackNew = *unpack;

   if (unpackNew->RowLength == 0)
      unpackNew->RowLength = *width;

   if (depth && unpackNew->ImageHeight == 0)
      unpackNew->ImageHeight = *height;

   unpackNew->SkipPixels += border;
   if (height)
      unpackNew->SkipRows += border;
   if (depth)
      unpackNew->SkipImages += border;

   assert(*width >= 3);
   *width = *width - 2 * border;
   if (height && *height >= 3)
      *height = *height - 2 * border;
   if (depth && *depth >= 3)
      *depth = *depth - 2 * border;
d510 2
a511 1
 * Do glTexImage1/2/3D().
d514 2
a515 11
st_TexImage(struct gl_context * ctx,
            GLint dims,
            GLenum target, GLint level,
            GLint internalFormat,
            GLint width, GLint height, GLint depth,
            GLint border,
            GLenum format, GLenum type, const void *pixels,
            const struct gl_pixelstore_attrib *unpack,
            struct gl_texture_object *texObj,
            struct gl_texture_image *texImage,
            GLsizei imageSize, GLboolean compressed_src)
d517 1
a517 1
   struct st_context *st = st_context(ctx);
a518 7
   struct st_texture_image *stImage = st_texture_image(texImage);
   GLuint dstRowStride = 0;
   struct gl_pixelstore_attrib unpackNB;
   enum pipe_transfer_usage transfer_usage = 0;

   DBG("%s target %s level %d %dx%dx%d border %d\n", __FUNCTION__,
       _mesa_lookup_enum_by_nr(target), level, width, height, depth, border);
d522 2
d531 2
a532 1
                                              internalFormat, format, type);
d534 4
a537 3
      _mesa_init_teximage_fields(ctx, target, texImage,
                                 width, height, depth, border,
                                 internalFormat, texFormat);
d541 2
d544 42
a585 14
   /* gallium does not support texture borders, strip it off */
   if (border) {
      strip_texture_border(border, &width, &height, &depth, unpack, &unpackNB);
      unpack = &unpackNB;
      texImage->Width = width;
      texImage->Height = height;
      texImage->Depth = depth;
      texImage->Border = 0;
      border = 0;
   }
   else {
      assert(texImage->Width == width);
      assert(texImage->Height == height);
      assert(texImage->Depth == depth);
d587 1
a588 2
   stImage->face = _mesa_tex_target_to_face(target);
   stImage->level = level;
d590 23
a612 1
   _mesa_set_fetch_functions(texImage, dims);
d614 2
a615 6
   /* Release the reference to a potentially orphaned buffer.   
    * Release any old malloced memory.
    */
   if (stImage->pt) {
      pipe_resource_reference(&stImage->pt, NULL);
      assert(!texImage->Data);
d617 3
a619 2
   else if (texImage->Data) {
      _mesa_align_free(texImage->Data);
d622 4
a625 13
   /*
    * See if the new image is somehow incompatible with the existing
    * mipmap.  If so, free the old mipmap.
    */
   if (stObj->pt) {
      if (level > (GLint) stObj->pt->last_level ||
          !st_texture_match_image(stObj->pt, &stImage->base,
                                  stImage->face, stImage->level)) {
         DBG("release it\n");
         pipe_resource_reference(&stObj->pt, NULL);
         assert(!stObj->pt);
         pipe_sampler_view_reference(&stObj->sampler_view, NULL);
      }
d628 5
a632 3
   if (width == 0 || height == 0 || depth == 0) {
      /* stop after freeing old image */
      return;
d635 6
a640 11
   if (!stObj->pt) {
      if (!guess_and_alloc_texture(st, stObj, stImage)) {
         /* Probably out of memory.
          * Try flushing any pending rendering, then retry.
          */
         st_finish(st);
         if (!guess_and_alloc_texture(st, stObj, stImage)) {
            _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage");
            return;
         }
      }
d643 10
a652 1
   assert(!stImage->pt);
d654 5
a658 7
   /* Check if this texture image can live inside the texture object's buffer.
    * If so, store the image there.  Otherwise the image will temporarily live
    * in its own buffer.
    */
   if (stObj->pt &&
       st_texture_match_image(stObj->pt, &stImage->base,
                              stImage->face, stImage->level)) {
d660 5
a664 2
      pipe_resource_reference(&stImage->pt, stObj->pt);
      assert(stImage->pt);
d667 1
a667 2
   if (!stImage->pt)
      DBG("XXX: Image did not fit into texture - storing in local memory!\n");
d669 7
a675 15
   /* Pixel data may come from regular user memory or a PBO.  For the later,
    * do bounds checking and map the PBO to read pixels data from it.
    *
    * XXX we should try to use a GPU-accelerated path to copy the image data
    * from the PBO to the texture.
    */
   if (compressed_src) {
      pixels = _mesa_validate_pbo_compressed_teximage(ctx, imageSize, pixels,
						      unpack,
						      "glCompressedTexImage");
   }
   else {
      pixels = _mesa_validate_pbo_teximage(ctx, dims, width, height, 1,
					   format, type,
					   pixels, unpack, "glTexImage");
d678 3
a680 4
   /* for a 1D array upload the image as a series of layer with height = 1 */
   if (target == GL_TEXTURE_1D_ARRAY) {
      depth = height;
      height = 1;
d683 6
a688 9
   /*
    * Prepare to store the texture data.  Either map the gallium texture buffer
    * memory or malloc space for it.
    */
   if (stImage->pt) {
      if (!pixels) {
         /* We've allocated texture resource, but have no pixel data - all done. */
         goto done;
      }
d690 3
a692 6
      /* Store the image in the gallium transfer object */
      if (format == GL_DEPTH_COMPONENT &&
          util_format_is_depth_and_stencil(stImage->pt->format))
         transfer_usage = PIPE_TRANSFER_READ_WRITE;
      else
         transfer_usage = PIPE_TRANSFER_WRITE;
d694 6
a699 4
      texImage->Data = st_texture_image_map(st, stImage, 0,
                                            transfer_usage, 0, 0, width, height);
      if(stImage->transfer)
         dstRowStride = stImage->transfer->stride;
a700 5
   else {
      /* Allocate regular memory and store the image there temporarily.   */
      GLuint imageSize = _mesa_format_image_size(texImage->TexFormat,
                                                 width, height, depth);
      dstRowStride = _mesa_format_row_stride(texImage->TexFormat, width);
d702 4
a705 1
      texImage->Data = _mesa_align_malloc(imageSize, 16);
d708 7
a714 2
   if (!texImage->Data) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage");
d718 12
a729 3
   if (!pixels) {
      /* We've allocated texture memory, but have no pixel data - all done. */
      goto done;
d732 17
a748 2
   DBG("Upload image %dx%dx%d row_len %x pitch %x\n",
       width, height, depth, width, dstRowStride);
d750 7
a756 19
   /* Copy user texture image into the texture buffer.
    */
   if (compressed_src) {
      const GLuint srcRowStride =
         _mesa_format_row_stride(texImage->TexFormat, width);
      if (dstRowStride == srcRowStride) {
         memcpy(texImage->Data, pixels, imageSize);
      }
      else {
         char *dst = texImage->Data;
         const char *src = pixels;
         GLuint i, bw, bh, lines;
         _mesa_get_format_block_size(texImage->TexFormat, &bw, &bh);
         lines = (height + bh - 1) / bh;

         for (i = 0; i < lines; ++i) {
            memcpy(dst, src, srcRowStride);
            dst += dstRowStride;
            src += srcRowStride;
d758 1
a758 30
      }
   }
   else {
      const GLuint srcImageStride =
         _mesa_image_image_stride(unpack, width, height, format, type);
      GLint i;
      const GLubyte *src = (const GLubyte *) pixels;

      for (i = 0; i < depth; i++) {
	 if (!_mesa_texstore(ctx, dims, 
                             texImage->_BaseFormat, 
                             texImage->TexFormat, 
                             texImage->Data,
                             0, 0, 0, /* dstX/Y/Zoffset */
                             dstRowStride,
                             texImage->ImageOffsets,
                             width, height, 1,
                             format, type, src, unpack)) {
	    _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage");
	 }

	 if (stImage->pt && i + 1 < depth) {
            /* unmap this slice */
	    st_texture_image_unmap(st, stImage);
            /* map next slice of 3D texture */
	    texImage->Data = st_texture_image_map(st, stImage, i + 1,
                                                  transfer_usage, 0, 0,
                                                  width, height);
	    src += srcImageStride;
	 }
d762 1
a762 1
done:
d765 27
a791 4
   if (stImage->pt && texImage->Data) {
      st_texture_image_unmap(st, stImage);
      texImage->Data = NULL;
   }
a793 1

d795 6
a800 14
st_TexImage3D(struct gl_context * ctx,
              GLenum target, GLint level,
              GLint internalFormat,
              GLint width, GLint height, GLint depth,
              GLint border,
              GLenum format, GLenum type, const void *pixels,
              const struct gl_pixelstore_attrib *unpack,
              struct gl_texture_object *texObj,
              struct gl_texture_image *texImage)
{
   st_TexImage(ctx, 3, target, level, internalFormat, width, height, depth,
               border, format, type, pixels, unpack, texObj, texImage,
               0, GL_FALSE);
}
d802 1
d804 2
a805 13
static void
st_TexImage2D(struct gl_context * ctx,
              GLenum target, GLint level,
              GLint internalFormat,
              GLint width, GLint height, GLint border,
              GLenum format, GLenum type, const void *pixels,
              const struct gl_pixelstore_attrib *unpack,
              struct gl_texture_object *texObj,
              struct gl_texture_image *texImage)
{
   st_TexImage(ctx, 2, target, level, internalFormat, width, height, 1, border,
               format, type, pixels, unpack, texObj, texImage, 0, GL_FALSE);
}
d807 5
d813 3
a815 12
static void
st_TexImage1D(struct gl_context * ctx,
              GLenum target, GLint level,
              GLint internalFormat,
              GLint width, GLint border,
              GLenum format, GLenum type, const void *pixels,
              const struct gl_pixelstore_attrib *unpack,
              struct gl_texture_object *texObj,
              struct gl_texture_image *texImage)
{
   st_TexImage(ctx, 1, target, level, internalFormat, width, 1, 1, border,
               format, type, pixels, unpack, texObj, texImage, 0, GL_FALSE);
d820 3
a822 6
st_CompressedTexImage2D(struct gl_context *ctx, GLenum target, GLint level,
                        GLint internalFormat,
                        GLint width, GLint height, GLint border,
                        GLsizei imageSize, const GLvoid *data,
                        struct gl_texture_object *texObj,
                        struct gl_texture_image *texImage)
d824 2
a825 2
   st_TexImage(ctx, 2, target, level, internalFormat, width, height, 1, border,
               0, 0, data, &ctx->Unpack, texObj, texImage, imageSize, GL_TRUE);
d830 1
d832 12
a843 2
 * glGetTexImage() helper: decompress a compressed texture by rendering
 * a textured quad.  Store the results in the user's buffer.
d846 3
a848 4
decompress_with_blit(struct gl_context * ctx, GLenum target, GLint level,
                     GLenum format, GLenum type, GLvoid *pixels,
                     struct gl_texture_object *texObj,
                     struct gl_texture_image *texImage)
d852 4
d857 9
a865 7
   struct st_texture_object *stObj = st_texture_object(texObj);
   struct pipe_sampler_view *src_view =
      st_get_texture_sampler_view(stObj, pipe);
   const GLuint width = texImage->Width;
   const GLuint height = texImage->Height;
   struct pipe_surface *dst_surface;
   struct pipe_resource *dst_texture;
d867 2
a868 2
   unsigned bind = (PIPE_BIND_RENDER_TARGET | /* util_blit may choose to render */
		    PIPE_BIND_TRANSFER_READ);
d870 2
a871 6
   /* create temp / dest surface */
   if (!util_create_rgba_surface(pipe, width, height, bind,
                                 &dst_texture, &dst_surface)) {
      _mesa_problem(ctx, "util_create_rgba_surface() failed "
                    "in decompress_with_blit()");
      return;
d874 2
a875 3
   /* Disable conditional rendering. */
   if (st->render_condition) {
      pipe->render_condition(pipe, NULL, 0);
d878 4
a881 38
   /* blit/render/decompress */
   util_blit_pixels_tex(st->blit,
                        src_view,      /* pipe_resource (src) */
                        0, 0,             /* src x0, y0 */
                        width, height,    /* src x1, y1 */
                        dst_surface,      /* pipe_surface (dst) */
                        0, 0,             /* dst x0, y0 */
                        width, height,    /* dst x1, y1 */
                        0.0,              /* z */
                        PIPE_TEX_MIPFILTER_NEAREST);

   /* Restore conditional rendering state. */
   if (st->render_condition) {
      pipe->render_condition(pipe, st->render_condition,
                             st->condition_mode);
   }

   /* map the dst_surface so we can read from it */
   tex_xfer = pipe_get_transfer(pipe,
                                dst_texture, 0, 0,
                                PIPE_TRANSFER_READ,
                                0, 0, width, height);

   pixels = _mesa_map_pbo_dest(ctx, &ctx->Pack, pixels);

   /* copy/pack data into user buffer */
   if (st_equal_formats(stImage->pt->format, format, type)) {
      /* memcpy */
      const uint bytesPerRow = width * util_format_get_blocksize(stImage->pt->format);
      ubyte *map = pipe_transfer_map(pipe, tex_xfer);
      GLuint row;
      for (row = 0; row < height; row++) {
         GLvoid *dest = _mesa_image_address2d(&ctx->Pack, pixels, width,
                                              height, format, type, row, 0);
         memcpy(dest, map, bytesPerRow);
         map += tex_xfer->stride;
      }
      pipe_transfer_unmap(pipe, tex_xfer);
a882 16
   else {
      /* format translation via floats */
      GLuint row;
      enum pipe_format pformat = util_format_linear(dst_texture->format);
      for (row = 0; row < height; row++) {
         const GLbitfield transferOps = 0x0; /* bypassed for glGetTexImage() */
         GLfloat rgba[4 * MAX_WIDTH];
         GLvoid *dest = _mesa_image_address2d(&ctx->Pack, pixels, width,
                                              height, format, type, row, 0);

         if (ST_DEBUG & DEBUG_FALLBACK)
            debug_printf("%s: fallback format translation\n", __FUNCTION__);

         /* get float[4] rgba row from surface */
         pipe_get_tile_rgba_format(pipe, tex_xfer, 0, row, width, 1,
                                   pformat, rgba);
d884 5
a888 3
         _mesa_pack_rgba_span_float(ctx, width, (GLfloat (*)[4]) rgba, format,
                                    type, dest, &ctx->Pack, transferOps);
      }
d891 5
a895 38
   _mesa_unmap_pbo_dest(ctx, &ctx->Pack);

   pipe->transfer_destroy(pipe, tex_xfer);

   /* destroy the temp / dest surface */
   util_destroy_rgba_surface(dst_texture, dst_surface);
}



/**
 * Need to map texture image into memory before copying image data,
 * then unmap it.
 */
static void
st_get_tex_image(struct gl_context * ctx, GLenum target, GLint level,
                 GLenum format, GLenum type, GLvoid * pixels,
                 struct gl_texture_object *texObj,
                 struct gl_texture_image *texImage, GLboolean compressed_dst)
{
   struct st_context *st = st_context(ctx);
   struct st_texture_image *stImage = st_texture_image(texImage);
   const GLuint dstImageStride =
      _mesa_image_image_stride(&ctx->Pack, texImage->Width, texImage->Height,
                               format, type);
   GLuint depth, i;
   GLubyte *dest;

   if (stImage->pt &&
       util_format_is_s3tc(stImage->pt->format) &&
       !compressed_dst) {
      /* Need to decompress the texture.
       * We'll do this by rendering a textured quad.
       * Note that we only expect RGBA formats (no Z/depth formats).
       */
      decompress_with_blit(ctx, target, level, format, type, pixels,
                           texObj, texImage);
      return;
d898 17
a914 24
   /* Map */
   if (stImage->pt) {
      /* Image is stored in hardware format in a buffer managed by the
       * kernel.  Need to explicitly map and unmap it.
       */
      texImage->Data = st_texture_image_map(st, stImage, 0,
                                            PIPE_TRANSFER_READ, 0, 0,
                                            stImage->base.Width,
                                            stImage->base.Height);
      /* compute stride in texels from stride in bytes */
      texImage->RowStride = stImage->transfer->stride
         * util_format_get_blockwidth(stImage->pt->format)
         / util_format_get_blocksize(stImage->pt->format);
   }
   else {
      /* Otherwise, the image should actually be stored in
       * texImage->Data.  This is pretty confusing for
       * everybody, I'd much prefer to separate the two functions of
       * texImage->Data - storage for texture images in main memory
       * and access (ie mappings) of images.  In other words, we'd
       * create a new texImage->Map field and leave Data simply for
       * storage.
       */
      assert(texImage->Data);
d917 4
a920 16
   depth = texImage->Depth;
   texImage->Depth = 1;

   dest = (GLubyte *) pixels;

   _mesa_set_fetch_functions(texImage, get_texture_dims(target));

   for (i = 0; i < depth; i++) {
      if (compressed_dst) {
	 _mesa_get_compressed_teximage(ctx, target, level, dest,
				       texObj, texImage);
      }
      else {
	 _mesa_get_teximage(ctx, target, level, format, type, dest,
			    texObj, texImage);
      }
d922 67
a988 10
      if (stImage->pt && i + 1 < depth) {
         /* unmap this slice */
	 st_texture_image_unmap(st, stImage);
         /* map next slice of 3D texture */
	 texImage->Data = st_texture_image_map(st, stImage, i + 1,
                                               PIPE_TRANSFER_READ, 0, 0,
                                               stImage->base.Width,
                                               stImage->base.Height);
	 dest += dstImageStride;
      }
d991 4
a994 6
   texImage->Depth = depth;

   /* Unmap */
   if (stImage->pt) {
      st_texture_image_unmap(st, stImage);
      texImage->Data = NULL;
a995 1
}
d997 16
d1014 2
a1015 9
static void
st_GetTexImage(struct gl_context * ctx, GLenum target, GLint level,
               GLenum format, GLenum type, GLvoid * pixels,
               struct gl_texture_object *texObj,
               struct gl_texture_image *texImage)
{
   st_get_tex_image(ctx, target, level, format, type, pixels, texObj, texImage,
                    GL_FALSE);
}
d1017 1
d1019 4
a1022 45
static void
st_GetCompressedTexImage(struct gl_context *ctx, GLenum target, GLint level,
                         GLvoid *pixels,
                         struct gl_texture_object *texObj,
                         struct gl_texture_image *texImage)
{
   st_get_tex_image(ctx, target, level, 0, 0, pixels, texObj, texImage,
                    GL_TRUE);
}



static void
st_TexSubimage(struct gl_context *ctx, GLint dims, GLenum target, GLint level,
               GLint xoffset, GLint yoffset, GLint zoffset,
               GLint width, GLint height, GLint depth,
               GLenum format, GLenum type, const void *pixels,
               const struct gl_pixelstore_attrib *packing,
               struct gl_texture_object *texObj,
               struct gl_texture_image *texImage)
{
   struct st_context *st = st_context(ctx);
   struct st_texture_image *stImage = st_texture_image(texImage);
   GLuint dstRowStride;
   const GLuint srcImageStride =
      _mesa_image_image_stride(packing, width, height, format, type);
   GLint i;
   const GLubyte *src;
   /* init to silence warning only: */
   enum pipe_transfer_usage transfer_usage = PIPE_TRANSFER_WRITE;

   DBG("%s target %s level %d offset %d,%d %dx%d\n", __FUNCTION__,
       _mesa_lookup_enum_by_nr(target),
       level, xoffset, yoffset, width, height);

   pixels =
      _mesa_validate_pbo_teximage(ctx, dims, width, height, depth, format,
                                  type, pixels, packing, "glTexSubImage2D");
   if (!pixels)
      return;

   /* for a 1D array upload the image as a series of layer with height = 1 */
   if (target == GL_TEXTURE_1D_ARRAY) {
      depth = height;
      height = 1;
d1025 1
a1025 9
   /* Map buffer if necessary.  Need to lock to prevent other contexts
    * from uploading the buffer under us.
    */
   if (stImage->pt) {
      if (format == GL_DEPTH_COMPONENT &&
          util_format_is_depth_and_stencil(stImage->pt->format))
         transfer_usage = PIPE_TRANSFER_READ_WRITE;
      else
         transfer_usage = PIPE_TRANSFER_WRITE;
d1027 6
a1032 5
      texImage->Data = st_texture_image_map(st, stImage, zoffset, 
                                            transfer_usage,
                                            xoffset, yoffset,
                                            width, height);
   }
d1034 12
a1045 4
   if (!texImage->Data) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexSubImage");
      goto done;
   }
d1047 9
a1055 25
   src = (const GLubyte *) pixels;
   dstRowStride = stImage->transfer->stride;

   for (i = 0; i < depth; i++) {
      if (!_mesa_texstore(ctx, dims, texImage->_BaseFormat,
                          texImage->TexFormat,
                          texImage->Data,
                          0, 0, 0,
                          dstRowStride,
                          texImage->ImageOffsets,
                          width, height, 1,
                          format, type, src, packing)) {
	 _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexSubImage");
      }

      if (stImage->pt && i + 1 < depth) {
         /* unmap this slice */
	 st_texture_image_unmap(st, stImage);
         /* map next slice of 3D texture */
	 texImage->Data = st_texture_image_map(st, stImage,
                                               zoffset + i + 1,
                                               transfer_usage,
                                               xoffset, yoffset,
                                               width, height);
	 src += srcImageStride;
d1058 4
d1063 1
a1063 2
done:
   _mesa_unmap_teximage_pbo(ctx, packing);
d1065 4
a1068 5
   if (stImage->pt && texImage->Data) {
      st_texture_image_unmap(st, stImage);
      texImage->Data = NULL;
   }
}
d1070 2
d1073 12
d1086 12
a1097 53
static void
st_TexSubImage3D(struct gl_context *ctx, GLenum target, GLint level,
                 GLint xoffset, GLint yoffset, GLint zoffset,
                 GLsizei width, GLsizei height, GLsizei depth,
                 GLenum format, GLenum type, const GLvoid *pixels,
                 const struct gl_pixelstore_attrib *packing,
                 struct gl_texture_object *texObj,
                 struct gl_texture_image *texImage)
{
   st_TexSubimage(ctx, 3, target, level, xoffset, yoffset, zoffset,
                  width, height, depth, format, type,
                  pixels, packing, texObj, texImage);
}


static void
st_TexSubImage2D(struct gl_context *ctx, GLenum target, GLint level,
                 GLint xoffset, GLint yoffset,
                 GLsizei width, GLsizei height,
                 GLenum format, GLenum type, const GLvoid * pixels,
                 const struct gl_pixelstore_attrib *packing,
                 struct gl_texture_object *texObj,
                 struct gl_texture_image *texImage)
{
   st_TexSubimage(ctx, 2, target, level, xoffset, yoffset, 0,
                  width, height, 1, format, type,
                  pixels, packing, texObj, texImage);
}


static void
st_TexSubImage1D(struct gl_context *ctx, GLenum target, GLint level,
                 GLint xoffset, GLsizei width, GLenum format, GLenum type,
                 const GLvoid * pixels,
                 const struct gl_pixelstore_attrib *packing,
                 struct gl_texture_object *texObj,
                 struct gl_texture_image *texImage)
{
   st_TexSubimage(ctx, 1, target, level, xoffset, 0, 0, width, 1, 1,
                  format, type, pixels, packing, texObj, texImage);
}


static void
st_CompressedTexSubImage1D(struct gl_context *ctx, GLenum target, GLint level,
                           GLint xoffset, GLsizei width,
                           GLenum format,
                           GLsizei imageSize, const GLvoid *data,
                           struct gl_texture_object *texObj,
                           struct gl_texture_image *texImage)
{
   assert(0);
}
d1099 6
d1106 1
a1106 31
static void
st_CompressedTexSubImage2D(struct gl_context *ctx, GLenum target, GLint level,
                           GLint xoffset, GLint yoffset,
                           GLsizei width, GLint height,
                           GLenum format,
                           GLsizei imageSize, const GLvoid *data,
                           struct gl_texture_object *texObj,
                           struct gl_texture_image *texImage)
{
   struct st_context *st = st_context(ctx);
   struct st_texture_image *stImage = st_texture_image(texImage);
   int srcBlockStride;
   int dstBlockStride;
   int y;
   enum pipe_format pformat;

   if (stImage->pt) {
      pformat = stImage->pt->format;

      texImage->Data = st_texture_image_map(st, stImage, 0, 
                                            PIPE_TRANSFER_WRITE,
                                            xoffset, yoffset,
                                            width, height);
      
      srcBlockStride = util_format_get_stride(pformat, width);
      dstBlockStride = stImage->transfer->stride;
   } else {
      assert(stImage->pt);
      /* TODO find good values for block and strides */
      /* TODO also adjust texImage->data for yoffset/xoffset */
      return;
d1108 1
d1110 3
a1112 4
   if (!texImage->Data) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCompressedTexSubImage");
      return;
   }
d1114 2
a1115 9
   assert(xoffset % util_format_get_blockwidth(pformat) == 0);
   assert(yoffset % util_format_get_blockheight(pformat) == 0);

   for (y = 0; y < height; y += util_format_get_blockheight(pformat)) {
      /* don't need to adjust for xoffset and yoffset as st_texture_image_map does that */
      const char *src = (const char*)data + srcBlockStride * util_format_get_nblocksy(pformat, y);
      char *dst = (char*)texImage->Data + dstBlockStride * util_format_get_nblocksy(pformat, y);
      memcpy(dst, src, util_format_get_stride(pformat, width));
   }
d1117 3
a1119 3
   if (stImage->pt) {
      st_texture_image_unmap(st, stImage);
      texImage->Data = NULL;
a1123 14
static void
st_CompressedTexSubImage3D(struct gl_context *ctx, GLenum target, GLint level,
                           GLint xoffset, GLint yoffset, GLint zoffset,
                           GLsizei width, GLint height, GLint depth,
                           GLenum format,
                           GLsizei imageSize, const GLvoid *data,
                           struct gl_texture_object *texObj,
                           struct gl_texture_image *texImage)
{
   assert(0);
}



d1132 1
a1132 1
fallback_copy_texsubimage(struct gl_context *ctx, GLenum target, GLint level,
d1136 1
a1136 1
                          GLint destX, GLint destY, GLint destZ,
d1143 1
a1143 1
   GLvoid *texDest;
d1145 4
a1152 2
   assert(width <= MAX_WIDTH);

d1157 7
a1163 7
   src_trans = pipe_get_transfer(pipe,
                                 strb->texture,
                                 strb->rtt_level,
                                 strb->rtt_face + strb->rtt_slice,
                                 PIPE_TRANSFER_READ,
                                 srcX, srcY,
                                 width, height);
d1172 3
a1174 3
   /* XXX this used to ignore destZ param */
   texDest = st_texture_image_map(st, stImage, destZ, transfer_usage,
                                  destX, destY, width, height);
d1181 1
d1193 19
a1211 6
      /* To avoid a large temp memory allocation, do copy row by row */
      for (row = 0; row < height; row++, srcY += yStep) {
         uint data[MAX_WIDTH];
         pipe_get_tile_z(pipe, src_trans, 0, srcY, width, 1, data);
         if (scaleOrBias) {
            _mesa_scale_and_bias_depth_uint(ctx, width, data);
a1212 1
         pipe_put_tile_z(pipe, stImage->transfer, 0, row, width, 1, data);
d1214 5
d1223 1
a1223 1
         (GLfloat *) malloc(width * height * 4 * sizeof(GLfloat));
d1227 1
a1227 1
         const GLint dstRowStride = stImage->transfer->stride;
d1235 7
d1246 1
a1246 1
         pipe_get_tile_rgba_format(pipe, src_trans, 0, 0, width, height,
a1258 2
                        texDest,
                        0, 0, 0,
d1260 1
a1260 1
                        texImage->ImageOffsets,
d1269 1
a1269 2
      if (tempSrc)
         free(tempSrc);
d1273 1
a1273 67
   pipe->transfer_destroy(pipe, src_trans);
}



/**
 * If the format of the src renderbuffer and the format of the dest
 * texture are compatible (in terms of blitting), return a TGSI writemask
 * to be used during the blit.
 * If the src/dest are incompatible, return 0.
 */
static unsigned
compatible_src_dst_formats(struct gl_context *ctx,
                           const struct gl_renderbuffer *src,
                           const struct gl_texture_image *dst)
{
   /* Get logical base formats for the src and dest.
    * That is, use the user-requested formats and not the actual, device-
    * chosen formats.
    * For example, the user may have requested an A8 texture but the
    * driver may actually be using an RGBA texture format.  When we
    * copy/blit to that texture, we only want to copy the Alpha channel
    * and not the RGB channels.
    *
    * Similarly, when the src FBO was created an RGB format may have been
    * requested but the driver actually chose an RGBA format.  In that case,
    * we don't want to copy the undefined Alpha channel to the dest texture
    * (it should be 1.0).
    */
   const GLenum srcFormat = _mesa_base_fbo_format(ctx, src->InternalFormat);
   const GLenum dstFormat = _mesa_base_tex_format(ctx, dst->InternalFormat);

   /**
    * XXX when we have red-only and red/green renderbuffers we'll need
    * to add more cases here (or implement a general-purpose routine that
    * queries the existance of the R,G,B,A channels in the src and dest).
    */
   if (srcFormat == dstFormat) {
      /* This is the same as matching_base_formats, which should
       * always pass, as it did previously.
       */
      return TGSI_WRITEMASK_XYZW;
   }
   else if (srcFormat == GL_RGB && dstFormat == GL_RGBA) {
      /* Make sure that A in the dest is 1.  The actual src format
       * may be RGBA and have undefined A values.
       */
      return TGSI_WRITEMASK_XYZ;
   }
   else if (srcFormat == GL_RGBA && dstFormat == GL_RGB) {
      /* Make sure that A in the dest is 1.  The actual dst format
       * may be RGBA and will need A=1 to provide proper alpha values
       * when sampled later.
       */
      return TGSI_WRITEMASK_XYZ;
   }
   else {
      if (ST_DEBUG & DEBUG_FALLBACK)
         debug_printf("%s failed for src %s, dst %s\n",
                      __FUNCTION__, 
                      _mesa_lookup_enum_by_nr(srcFormat),
                      _mesa_lookup_enum_by_nr(dstFormat));

      /* Otherwise fail.
       */
      return 0;
   }
a1276 1

d1285 6
a1290 12
st_copy_texsubimage(struct gl_context *ctx,
                    GLenum target, GLint level,
                    GLint destX, GLint destY, GLint destZ,
                    GLint srcX, GLint srcY,
                    GLsizei width, GLsizei height)
{
   struct gl_texture_unit *texUnit =
      &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   struct gl_texture_object *texObj =
      _mesa_select_tex_object(ctx, texUnit, target);
   struct gl_texture_image *texImage =
      _mesa_select_tex_image(ctx, texObj, target, level);
d1292 2
a1293 3
   const GLenum texBaseFormat = texImage->_BaseFormat;
   struct gl_framebuffer *fb = ctx->ReadBuffer;
   struct st_renderbuffer *strb;
d1297 2
a1298 5
   enum pipe_format dest_format, src_format;
   GLboolean use_fallback = GL_TRUE;
   GLboolean matching_base_formats;
   GLuint format_writemask, sample_count;
   struct pipe_surface *dest_surface = NULL;
d1300 2
a1301 17

   /* make sure finalize_textures has been called? 
    */
   if (0) st_validate_state(st);

   /* determine if copying depth or color data */
   if (texBaseFormat == GL_DEPTH_COMPONENT ||
       texBaseFormat == GL_DEPTH_STENCIL) {
      strb = st_renderbuffer(fb->_DepthBuffer);
      if (strb->Base.Wrapped) {
         strb = st_renderbuffer(strb->Base.Wrapped);
      }
   }
   else {
      /* texBaseFormat == GL_RGB, GL_RGBA, GL_ALPHA, etc */
      strb = st_renderbuffer(fb->_ColorReadBuffer);
   }
d1308 4
a1311 5
   sample_count = strb->surface->texture->nr_samples;
   /* I believe this would be legal, presumably would need to do a resolve
      for color, and for depth/stencil spec says to just use one of the
      depth/stencil samples per pixel? Need some transfer clarifications. */
   assert(sample_count < 2);
d1313 7
a1319 4
   if (srcX < 0) {
      width -= -srcX;
      destX += -srcX;
      srcX = 0;
d1322 9
a1330 4
   if (srcY < 0) {
      height -= -srcY;
      destY += -srcY;
      srcY = 0;
d1332 2
a1333 5

   if (destX < 0) {
      width -= -destX;
      srcX += -destX;
      destX = 0;
d1336 4
a1339 4
   if (destY < 0) {
      height -= -destY;
      srcY += -destY;
      destY = 0;
d1342 4
a1345 106
   if (width < 0 || height < 0)
      return;


   assert(strb);
   assert(strb->surface);
   assert(stImage->pt);

   src_format = strb->surface->format;
   dest_format = stImage->pt->format;

   /*
    * Determine if the src framebuffer and dest texture have the same
    * base format.  We need this to detect a case such as the framebuffer
    * being GL_RGBA but the texture being GL_RGB.  If the actual hardware
    * texture format stores RGBA we need to set A=1 (overriding the
    * framebuffer's alpha values).  We can't do that with the blit or
    * textured-quad paths.
    */
   matching_base_formats =
      (_mesa_get_format_base_format(strb->Base.Format) ==
       _mesa_get_format_base_format(texImage->TexFormat));
   format_writemask = compatible_src_dst_formats(ctx, &strb->Base, texImage);

   if (ctx->_ImageTransferState == 0x0) {

      if (matching_base_formats &&
          src_format == dest_format &&
          !do_flip)
      {
         /* use surface_copy() / blit */
         struct pipe_box src_box;
         u_box_2d_zslice(srcX, srcY, strb->surface->u.tex.first_layer,
                         width, height, &src_box);

         /* for resource_copy_region(), y=0=top, always */
         pipe->resource_copy_region(pipe,
                                    /* dest */
                                    stImage->pt,
                                    stImage->level,
                                    destX, destY, destZ + stImage->face,
                                    /* src */
                                    strb->texture,
                                    strb->surface->u.tex.level,
                                    &src_box);
         use_fallback = GL_FALSE;
      }
      else if (format_writemask &&
               texBaseFormat != GL_DEPTH_COMPONENT &&
               texBaseFormat != GL_DEPTH_STENCIL &&
               screen->is_format_supported(screen, src_format,
                                           PIPE_TEXTURE_2D, sample_count,
                                           PIPE_BIND_SAMPLER_VIEW) &&
               screen->is_format_supported(screen, dest_format,
                                           PIPE_TEXTURE_2D, 0,
                                           PIPE_BIND_RENDER_TARGET)) {
         /* draw textured quad to do the copy */
         GLint srcY0, srcY1;
         struct pipe_surface surf_tmpl;
         memset(&surf_tmpl, 0, sizeof(surf_tmpl));
         surf_tmpl.format = util_format_linear(stImage->pt->format);
         surf_tmpl.usage = PIPE_BIND_RENDER_TARGET;
         surf_tmpl.u.tex.level = stImage->level;
         surf_tmpl.u.tex.first_layer = stImage->face + destZ;
         surf_tmpl.u.tex.last_layer = stImage->face + destZ;

         dest_surface = pipe->create_surface(pipe, stImage->pt,
                                             &surf_tmpl);

         if (do_flip) {
            srcY1 = strb->Base.Height - srcY - height;
            srcY0 = srcY1 + height;
         }
         else {
            srcY0 = srcY;
            srcY1 = srcY0 + height;
         }

         /* Disable conditional rendering. */
         if (st->render_condition) {
            pipe->render_condition(pipe, NULL, 0);
         }

         util_blit_pixels_writemask(st->blit,
                                    strb->texture,
                                    strb->surface->u.tex.level,
                                    srcX, srcY0,
                                    srcX + width, srcY1,
                                    strb->surface->u.tex.first_layer,
                                    dest_surface,
                                    destX, destY,
                                    destX + width, destY + height,
                                    0.0, PIPE_TEX_MIPFILTER_NEAREST,
                                    format_writemask);

         /* Restore conditional rendering state. */
         if (st->render_condition) {
            pipe->render_condition(pipe, st->render_condition,
                                   st->condition_mode);
         }

         use_fallback = GL_FALSE;
      }

      if (dest_surface)
         pipe_surface_reference(&dest_surface, NULL);
d1347 3
a1349 7

   if (use_fallback) {
      /* software fallback */
      fallback_copy_texsubimage(ctx, target, level,
                                strb, stImage, texBaseFormat,
                                destX, destY, destZ,
                                srcX, srcY, width, height);
a1350 1
}
d1352 2
a1353 16


static void
st_CopyTexImage1D(struct gl_context * ctx, GLenum target, GLint level,
                  GLenum internalFormat,
                  GLint x, GLint y, GLsizei width, GLint border)
{
   struct gl_texture_unit *texUnit =
      &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   struct gl_texture_object *texObj =
      _mesa_select_tex_object(ctx, texUnit, target);
   struct gl_texture_image *texImage =
      _mesa_select_tex_image(ctx, texObj, target, level);

   /* Setup or redefine the texture object, texture and texture
    * image.  Don't populate yet.  
d1355 30
a1384 70
   ctx->Driver.TexImage1D(ctx, target, level, internalFormat,
                          width, border,
                          GL_RGBA, CHAN_TYPE, NULL,
                          &ctx->DefaultPacking, texObj, texImage);

   st_copy_texsubimage(ctx, target, level,
                       0, 0, 0,  /* destX,Y,Z */
                       x, y, width, 1);  /* src X, Y, size */
}


static void
st_CopyTexImage2D(struct gl_context * ctx, GLenum target, GLint level,
                  GLenum internalFormat,
                  GLint x, GLint y, GLsizei width, GLsizei height,
                  GLint border)
{
   struct gl_texture_unit *texUnit =
      &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   struct gl_texture_object *texObj =
      _mesa_select_tex_object(ctx, texUnit, target);
   struct gl_texture_image *texImage =
      _mesa_select_tex_image(ctx, texObj, target, level);

   /* Setup or redefine the texture object, texture and texture
    * image.  Don't populate yet.  
    */
   ctx->Driver.TexImage2D(ctx, target, level, internalFormat,
                          width, height, border,
                          GL_RGBA, CHAN_TYPE, NULL,
                          &ctx->DefaultPacking, texObj, texImage);

   st_copy_texsubimage(ctx, target, level,
                       0, 0, 0,  /* destX,Y,Z */
                       x, y, width, height);  /* src X, Y, size */
}


static void
st_CopyTexSubImage1D(struct gl_context * ctx, GLenum target, GLint level,
                     GLint xoffset, GLint x, GLint y, GLsizei width)
{
   const GLint yoffset = 0, zoffset = 0;
   const GLsizei height = 1;
   st_copy_texsubimage(ctx, target, level,
                       xoffset, yoffset, zoffset,  /* destX,Y,Z */
                       x, y, width, height);  /* src X, Y, size */
}


static void
st_CopyTexSubImage2D(struct gl_context * ctx, GLenum target, GLint level,
                     GLint xoffset, GLint yoffset,
                     GLint x, GLint y, GLsizei width, GLsizei height)
{
   const GLint zoffset = 0;
   st_copy_texsubimage(ctx, target, level,
                       xoffset, yoffset, zoffset,  /* destX,Y,Z */
                       x, y, width, height);  /* src X, Y, size */
}


static void
st_CopyTexSubImage3D(struct gl_context * ctx, GLenum target, GLint level,
                     GLint xoffset, GLint yoffset, GLint zoffset,
                     GLint x, GLint y, GLsizei width, GLsizei height)
{
   st_copy_texsubimage(ctx, target, level,
                       xoffset, yoffset, zoffset,  /* destX,Y,Z */
                       x, y, width, height);  /* src X, Y, size */
d1401 1
a1401 1
         stObj->base.Image[stImage->face][dstLevel];
d1411 14
d1427 2
a1428 2
                            stImage->pt, stImage->level, /* src texture, level */
                            stImage->face);
d1432 6
a1437 1
   else if (stImage->base.Data) {
d1440 1
a1440 1
                            stImage->face,
d1442 5
a1446 8
                            stImage->base.Data,
                            stImage->base.RowStride * 
                            util_format_get_blocksize(stObj->pt->format),
                            stImage->base.RowStride *
                            stImage->base.Height *
                            util_format_get_blocksize(stObj->pt->format));
      _mesa_align_free(stImage->base.Data);
      stImage->base.Data = NULL;
d1469 1
a1469 1
   GLuint ptWidth, ptHeight, ptDepth, ptLayers;
d1471 1
a1471 1
   if (stObj->base._Complete) {
d1485 14
d1511 6
a1516 1
      pipe_sampler_view_reference(&stObj->sampler_view, NULL);
d1529 1
a1529 1
                                 stObj->base.BaseLevel,
d1538 1
d1546 1
a1546 1
          !st_sampler_compat_formats(stObj->pt->format, firstImageFormat) ||
d1551 1
d1558 1
a1558 1
         pipe_sampler_view_reference(&stObj->sampler_view, NULL);
d1575 1
a1575 1
                                    ptLayers,
d1595 4
a1598 3
            if (level == 0 || (stImage->base.Width == u_minify(stObj->width0, level) &&
                stImage->base.Height == u_minify(stObj->height0, level) &&
                stImage->base.Depth == u_minify(stObj->depth0, level))) {
d1611 2
a1612 3
 * Returns pointer to a default/dummy texture.
 * This is typically used when the current shader has tex/sample instructions
 * but the user has not provided a (any) texture(s).
d1614 5
a1618 2
struct gl_texture_object *
st_get_default_texture(struct st_context *st)
d1620 19
a1638 6
   if (!st->default_texture) {
      static const GLenum target = GL_TEXTURE_2D;
      GLubyte pixels[16][16][4];
      struct gl_texture_object *texObj;
      struct gl_texture_image *texImg;
      GLuint i, j;
d1640 14
a1653 9
      /* The ARB_fragment_program spec says (0,0,0,1) should be returned
       * when attempting to sample incomplete textures.
       */
      for (i = 0; i < 16; i++) {
         for (j = 0; j < 16; j++) {
            pixels[i][j][0] = 0;
            pixels[i][j][1] = 0;
            pixels[i][j][2] = 0;
            pixels[i][j][3] = 255;
d1657 48
a1704 1
      texObj = st->ctx->Driver.NewTextureObject(st->ctx, 0, target);
d1706 5
a1710 1
      texImg = _mesa_get_tex_image(st->ctx, texObj, target, 0);
d1712 3
a1714 3
      _mesa_init_teximage_fields(st->ctx, target, texImg,
                                 16, 16, 1, 0,  /* w, h, d, border */
                                 GL_RGBA, MESA_FORMAT_RGBA8888);
d1716 2
a1717 7
      st_TexImage(st->ctx, 2, target,
                  0, GL_RGBA,    /* level, intformat */
                  16, 16, 1, 0,  /* w, h, d, border */
                  GL_RGBA, GL_UNSIGNED_BYTE, pixels,
                  &st->ctx->DefaultPacking,
                  texObj, texImg,
                  0, 0);
d1719 14
a1732 3
      texObj->Sampler.MinFilter = GL_NEAREST;
      texObj->Sampler.MagFilter = GL_NEAREST;
      texObj->_Complete = GL_TRUE;
d1734 6
a1739 1
      st->default_texture = texObj;
a1740 1
   return st->default_texture;
d1748 5
a1752 14
   functions->TexImage1D = st_TexImage1D;
   functions->TexImage2D = st_TexImage2D;
   functions->TexImage3D = st_TexImage3D;
   functions->TexSubImage1D = st_TexSubImage1D;
   functions->TexSubImage2D = st_TexSubImage2D;
   functions->TexSubImage3D = st_TexSubImage3D;
   functions->CompressedTexSubImage1D = st_CompressedTexSubImage1D;
   functions->CompressedTexSubImage2D = st_CompressedTexSubImage2D;
   functions->CompressedTexSubImage3D = st_CompressedTexSubImage3D;
   functions->CopyTexImage1D = st_CopyTexImage1D;
   functions->CopyTexImage2D = st_CopyTexImage2D;
   functions->CopyTexSubImage1D = st_CopyTexSubImage1D;
   functions->CopyTexSubImage2D = st_CopyTexSubImage2D;
   functions->CopyTexSubImage3D = st_CopyTexSubImage3D;
d1758 2
a1759 2
   functions->CompressedTexImage2D = st_CompressedTexImage2D;
   functions->GetCompressedTexImage = st_GetCompressedTexImage;
d1763 1
d1765 4
a1768 1
   functions->FreeTexImageData = st_FreeTextureImageData;
d1770 2
a1771 1
   functions->TextureMemCpy = do_memcpy;
d1773 1
a1773 2
   /* XXX Temporary until we can query pipe's texture sizes */
   functions->TestProxyTexImage = _mesa_test_proxy_teximage;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d38 1
a77 1

a79 1

a81 1

a83 1

d86 6
a91 1

a221 1
   const unsigned geom = 0x0;
d229 1
a229 1
   if (screen->is_format_supported(screen, format, target, 0, bindings, geom))
d231 9
a239 2
   else
      return PIPE_BIND_SAMPLER_VIEW;
d250 1
d273 49
d334 1
a334 2
   const GLuint dims = get_texture_dims(stObj->base.Target);
   GLuint level, lastLevel, width, height, depth;
d336 1
d343 10
a352 20
   level = stImage->level;
   width = stImage->base.Width2;  /* size w/out border */
   height = stImage->base.Height2;
   depth = stImage->base.Depth2;

   assert(width > 0);
   assert(height > 0);
   assert(depth > 0);

   /* Depending on the image's size, we can't always make a guess here.
    */
   if (level > 0) {
      if ( (dims >= 1 && width == 1) ||
           (dims >= 2 && height == 1) ||
           (dims >= 3 && depth == 1) ) {
         /* we can't determine the image size at level=0 */
         stObj->width0 = stObj->height0 = stObj->depth0 = 0;
         /* this is not an out of memory error */
         return GL_TRUE;
      }
a354 13
   /* grow the image size until we hit level = 0 */
   while (level > 0) {
      if (width != 1)
         width <<= 1;
      if (height != 1)
         height <<= 1;
      if (depth != 1)
         depth <<= 1;
      level--;
   }      

   assert(level == 0);

d365 2
a366 2
   if ((stObj->base.MinFilter == GL_NEAREST ||
        stObj->base.MinFilter == GL_LINEAR ||
d391 4
d399 4
a402 3
                                 width,
                                 height,
                                 depth,
a449 119
 * Try to do texture compression via rendering.  If the Gallium driver
 * can render into a compressed surface this will allow us to do texture
 * compression.
 * \return GL_TRUE for success, GL_FALSE for failure
 */
static GLboolean
compress_with_blit(struct gl_context * ctx,
                   GLenum target, GLint level,
                   GLint xoffset, GLint yoffset, GLint zoffset,
                   GLint width, GLint height, GLint depth,
                   GLenum format, GLenum type, const void *pixels,
                   const struct gl_pixelstore_attrib *unpack,
                   struct gl_texture_image *texImage)
{
   const GLuint dstImageOffsets[1] = {0};
   struct st_texture_image *stImage = st_texture_image(texImage);
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   struct pipe_screen *screen = pipe->screen;
   gl_format mesa_format;
   struct pipe_resource templ;
   struct pipe_resource *src_tex;
   struct pipe_sampler_view view_templ;
   struct pipe_sampler_view *src_view;
   struct pipe_surface *dst_surface, surf_tmpl;
   struct pipe_transfer *tex_xfer;
   void *map;

   if (!stImage->pt) {
      /* XXX: Can this happen? Should we assert? */
      return GL_FALSE;
   }

   /* get destination surface (in the compressed texture) */
   memset(&surf_tmpl, 0, sizeof(surf_tmpl));
   surf_tmpl.format = stImage->pt->format;
   surf_tmpl.usage = PIPE_BIND_RENDER_TARGET;
   surf_tmpl.u.tex.level = stImage->level;
   surf_tmpl.u.tex.first_layer = stImage->face;
   surf_tmpl.u.tex.last_layer = stImage->face;
   dst_surface = pipe->create_surface(pipe, stImage->pt, &surf_tmpl);
   if (!dst_surface) {
      /* can't render into this format (or other problem) */
      return GL_FALSE;
   }

   /* Choose format for the temporary RGBA texture image.
    */
   mesa_format = st_ChooseTextureFormat(ctx, GL_RGBA, format, type);
   assert(mesa_format);
   if (!mesa_format)
      return GL_FALSE;

   /* Create the temporary source texture
    */
   memset(&templ, 0, sizeof(templ));
   templ.target = st->internal_target;
   templ.format = st_mesa_format_to_pipe_format(mesa_format);
   templ.width0 = width;
   templ.height0 = height;
   templ.depth0 = 1;
   templ.array_size = 1;
   templ.last_level = 0;
   templ.usage = PIPE_USAGE_DEFAULT;
   templ.bind = PIPE_BIND_SAMPLER_VIEW;
   src_tex = screen->resource_create(screen, &templ);

   if (!src_tex)
      return GL_FALSE;

   /* Put user's tex data into the temporary texture
    */
   tex_xfer = pipe_get_transfer(st_context(ctx)->pipe, src_tex,
                                0, 0, /* layer, level are zero */
                                PIPE_TRANSFER_WRITE,
                                0, 0, width, height); /* x, y, w, h */
   map = pipe_transfer_map(pipe, tex_xfer);

   _mesa_texstore(ctx, 2, GL_RGBA, mesa_format,
                  map,              /* dest ptr */
                  0, 0, 0,          /* dest x/y/z offset */
                  tex_xfer->stride, /* dest row stride (bytes) */
                  dstImageOffsets,  /* image offsets (for 3D only) */
                  width, height, 1, /* size */
                  format, type,     /* source format/type */
                  pixels,           /* source data */
                  unpack);          /* source data packing */

   pipe_transfer_unmap(pipe, tex_xfer);
   pipe->transfer_destroy(pipe, tex_xfer);

   /* Create temporary sampler view */
   u_sampler_view_default_template(&view_templ,
                                   src_tex,
                                   src_tex->format);
   src_view = pipe->create_sampler_view(pipe, src_tex, &view_templ);


   /* copy / compress image */
   util_blit_pixels_tex(st->blit,
                        src_view,         /* sampler view (src) */
                        0, 0,             /* src x0, y0 */
                        width, height,    /* src x1, y1 */
                        dst_surface,      /* pipe_surface (dst) */
                        xoffset, yoffset, /* dst x0, y0 */
                        xoffset + width,  /* dst x1 */
                        yoffset + height, /* dst y1 */
                        0.0,              /* z */
                        PIPE_TEX_MIPFILTER_NEAREST);

   pipe_surface_reference(&dst_surface, NULL);
   pipe_resource_reference(&src_tex, NULL);
   pipe_sampler_view_reference(&src_view, NULL);

   return GL_TRUE;
}


/**
a465 1
   struct pipe_screen *screen = st->pipe->screen;
d592 4
a595 16
   /* See if we can do texture compression with a blit/render.
    */
   if (!compressed_src &&
       !ctx->Mesa_DXTn &&
       _mesa_is_format_compressed(texImage->TexFormat) &&
       screen->is_format_supported(screen,
                                   stImage->pt->format,
                                   stImage->pt->target, 0,
                                   PIPE_BIND_RENDER_TARGET, 0)) {
      if (!pixels)
         goto done;

      if (compress_with_blit(ctx, target, level, 0, 0, 0, width, height, depth,
                             format, type, pixels, unpack, texImage)) {
         goto done;
      }
d603 6
a608 1
      /* Store the image in the gallium texture memory buffer */
d821 1
a821 1
   tex_xfer = pipe_get_transfer(st_context(ctx)->pipe,
d845 1
d856 2
a857 1
         pipe_get_tile_rgba(pipe, tex_xfer, 0, row, width, 1, rgba);
a1001 1
   struct pipe_screen *screen = st->pipe->screen;
d1021 4
a1024 14
   /* See if we can do texture compression with a blit/render.
    */
   if (!ctx->Mesa_DXTn &&
       _mesa_is_format_compressed(texImage->TexFormat) &&
       screen->is_format_supported(screen,
                                   stImage->pt->format,
                                   stImage->pt->target, 0,
                                   PIPE_BIND_RENDER_TARGET, 0)) {
      if (compress_with_blit(ctx, target, level,
                             xoffset, yoffset, zoffset,
                             width, height, depth,
                             format, type, pixels, packing, texImage)) {
         goto done;
      }
d1242 1
a1242 1
   src_trans = pipe_get_transfer(st_context(ctx)->pipe,
d1244 2
a1245 1
                                 0, 0,
d1306 3
a1308 1
         pipe_get_tile_rgba(pipe, src_trans, 0, 0, width, height, tempSrc);
d1545 1
a1545 2
                                           PIPE_BIND_SAMPLER_VIEW,
                                           0) &&
d1548 1
a1548 2
                                           PIPE_BIND_RENDER_TARGET,
                                           0)) {
d1553 1
a1553 1
         surf_tmpl.format = stImage->pt->format;
d1713 1
a1713 1
         stObj->base.Image[stImage->face][stImage->level];
d1765 1
d1774 2
a1775 2
      if (stObj->base.MinFilter == GL_LINEAR ||
          stObj->base.MinFilter == GL_NEAREST)
d1799 18
d1824 4
a1827 3
          stObj->pt->width0 != stObj->width0 ||
          stObj->pt->height0 != stObj->height0 ||
          stObj->pt->depth0 != stObj->depth0)
d1847 4
a1850 3
                                    stObj->width0,
                                    stObj->height0,
                                    stObj->depth0,
d1870 6
a1875 1
            copy_image_data_to_texture(st, stObj, level, stImage);
d1927 2
a1928 2
      texObj->MinFilter = GL_NEAREST;
      texObj->MagFilter = GL_NEAREST;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a29 3
#if FEATURE_convolve
#include "main/convolve.h"
#endif
d37 2
d49 1
a51 1
#include "state_tracker/st_public.h"
a53 1
#include "state_tracker/st_inlines.h"
d64 1
d66 1
a66 1

d79 2
d82 1
a82 1
      return PIPE_TEXTURE_2D;
d99 1
a99 1
st_NewTextureImage(GLcontext * ctx)
d109 1
a109 1
st_NewTextureObject(GLcontext * ctx, GLuint name, GLenum target)
d119 1
a119 1
/** called via ctx->Driver.DeleteTextureImage() */
d121 1
a121 1
st_DeleteTextureObject(GLcontext *ctx,
d124 1
d127 12
a138 2
      pipe_texture_reference(&stObj->pt, NULL);

d145 1
a145 1
st_FreeTextureImageData(GLcontext * ctx, struct gl_texture_image *texImage)
d152 1
a152 1
      pipe_texture_reference(&stImage->pt, NULL);
d213 1
a213 1
 * Return default texture usage bitmask for the given texture format.
d216 1
a216 1
default_usage(enum pipe_format fmt)
d218 7
a224 3
   GLuint usage = PIPE_TEXTURE_USAGE_SAMPLER;
   if (util_format_is_depth_or_stencil(fmt))
      usage |= PIPE_TEXTURE_USAGE_DEPTH_STENCIL;
d226 34
a259 2
      usage |= PIPE_TEXTURE_USAGE_RENDER_TARGET;
   return usage;
d264 1
a264 2
 * Allocate a pipe_texture object for the given st_texture_object using
 * the given st_texture_image to guess the mipmap size/levels.
d266 2
a267 6
 * [comments...]
 * Otherwise, store it in memory if (Border != 0) or (any dimension ==
 * 1).
 *    
 * Otherwise, if max_level >= level >= min_level, create texture with
 * space for images from min_level down to max_level.
d269 1
a269 2
 * Otherwise, create texture with space for images from (level 0)..(1x1).
 * Consider pruning this texture at a validation if the saving is worth it.
d271 1
a271 1
static void
d276 3
a278 6
   GLuint firstLevel;
   GLuint lastLevel;
   GLuint width = stImage->base.Width2;  /* size w/out border */
   GLuint height = stImage->base.Height2;
   GLuint depth = stImage->base.Depth2;
   GLuint i, usage;
d285 21
a305 17
   if (stObj->pt &&
       (GLint) stImage->level > stObj->base.BaseLevel &&
       (stImage->base.Width == 1 ||
        (stObj->base.Target != GL_TEXTURE_1D &&
         stImage->base.Height == 1) ||
        (stObj->base.Target == GL_TEXTURE_3D &&
         stImage->base.Depth == 1)))
      return;

   /* If this image disrespects BaseLevel, allocate from level zero.
    * Usually BaseLevel == 0, so it's unlikely to happen.
    */
   if ((GLint) stImage->level < stObj->base.BaseLevel)
      firstLevel = 0;
   else
      firstLevel = stObj->base.BaseLevel;

d307 2
a308 3
   /* Figure out image dimensions at start level. 
    */
   for (i = stImage->level; i > firstLevel; i--) {
d315 4
a318 1
   }
d320 3
a322 4
   if (width == 0 || height == 0 || depth == 0) {
      /* no texture needed */
      return;
   }
d324 5
a328 4
   /* Guess a reasonable value for lastLevel.  This is probably going
    * to be wrong fairly often and might mean that we have to look at
    * resizable buffers, or require that buffers implement lazy
    * pagetable arrangements.
d335 1
a335 1
       stImage->level == firstLevel) {
d337 1
a337 1
      lastLevel = firstLevel;
d344 1
a344 1
      lastLevel = firstLevel + MAX2(MAX2(l2width, l2height), l2depth);
d347 5
d354 1
a354 1
   usage = default_usage(fmt);
d363 3
a365 1
                                 usage);
d367 1
a367 1
   DBG("%s - success\n", __FUNCTION__);
d416 1
a416 1
compress_with_blit(GLcontext * ctx,
d426 3
a428 1
   struct pipe_screen *screen = ctx->st->pipe->screen;
d430 5
a434 3
   struct pipe_texture templ;
   struct pipe_texture *src_tex;
   struct pipe_surface *dst_surface;
d444 7
a450 3
   dst_surface = screen->get_tex_surface(screen, stImage->pt,
                                         stImage->face, stImage->level, 0,
                                         PIPE_BUFFER_USAGE_GPU_WRITE);
d466 1
a466 1
   templ.target = PIPE_TEXTURE_2D;
d471 1
d473 3
a475 2
   templ.tex_usage = PIPE_TEXTURE_USAGE_SAMPLER;
   src_tex = screen->texture_create(screen, &templ);
d482 5
a486 5
   tex_xfer = st_cond_flush_get_tex_transfer(st_context(ctx), src_tex,
					     0, 0, 0, /* face, level are zero */
					     PIPE_TRANSFER_WRITE,
					     0, 0, width, height); /* x, y, w, h */
   map = screen->transfer_map(screen, tex_xfer);
d498 9
a506 2
   screen->transfer_unmap(screen, tex_xfer);
   screen->tex_transfer_destroy(tex_xfer);
d509 2
a510 2
   util_blit_pixels_tex(ctx->st->blit,
                        src_tex,          /* pipe_texture (src) */
d521 2
a522 1
   pipe_texture_reference(&src_tex, NULL);
d532 1
a532 1
st_TexImage(GLcontext * ctx,
d544 2
a545 1
   struct pipe_screen *screen = ctx->st->pipe->screen;
a547 2
   GLint postConvWidth, postConvHeight;
   GLint texelBytes, sizeInBytes;
d557 2
d560 10
d583 5
a587 3

   postConvWidth = width;
   postConvHeight = height;
a591 7
#if FEATURE_convolve
   if (ctx->_ImageTransferState & IMAGE_CONVOLUTION_BIT) {
      _mesa_adjust_image_for_convolution(ctx, dims, &postConvWidth,
                                         &postConvHeight);
   }
#endif

a593 17
   if (_mesa_is_format_compressed(texImage->TexFormat)) {
      /* must be a compressed format */
      texelBytes = 0;
   }
   else {
      texelBytes = _mesa_get_format_bytes(texImage->TexFormat);
      
      /* Minimum pitch of 32 bytes */
      if (postConvWidth * texelBytes < 32) {
	 postConvWidth = 32 / texelBytes;
	 texImage->RowStride = postConvWidth;
      }
      
      /* we'll set RowStride elsewhere when the texture is a "mapped" state */
      /*assert(texImage->RowStride == postConvWidth);*/
   }

d598 1
a598 1
      pipe_texture_reference(&stImage->pt, NULL);
d610 1
a610 2
      if (stObj->teximage_realloc ||
          level > (GLint) stObj->pt->last_level ||
d614 1
a614 1
         pipe_texture_reference(&stObj->pt, NULL);
d616 1
a616 1
         stObj->teximage_realloc = FALSE;
d626 1
a626 2
      guess_and_alloc_texture(ctx->st, stObj, stImage);
      if (!stObj->pt) {
d630 2
a631 3
         st_finish(ctx->st);
         guess_and_alloc_texture(ctx->st, stObj, stImage);
         if (!stObj->pt) {
d640 4
d646 1
a646 1
                                 stImage->face, stImage->level)) {
d648 1
a648 1
      pipe_texture_reference(&stImage->pt, stObj->pt);
d655 5
a659 3
   /* st_CopyTexImage calls this function with pixels == NULL, with
    * the expectation that the texture will be set up but nothing
    * more will be done.  This is where those calls return:
a671 4
   /* Note: we can't check for pixels==NULL until after we've allocated
    * memory for the texture.
    */

d679 2
a680 2
                                   stImage->pt->target,
                                   PIPE_TEXTURE_USAGE_RENDER_TARGET, 0)) {
d690 4
d695 1
d702 2
a703 4
      texImage->Data = st_texture_image_map(ctx->st, stImage, 0,
                                            transfer_usage, 0, 0,
                                            stImage->base.Width,
                                            stImage->base.Height);
d709 3
a711 12
      if (_mesa_is_format_compressed(texImage->TexFormat)) {
         sizeInBytes = _mesa_format_image_size(texImage->TexFormat,
                                               texImage->Width,
                                               texImage->Height,
                                               texImage->Depth);
         dstRowStride = _mesa_format_row_stride(texImage->TexFormat, width);
         assert(dims != 3);
      }
      else {
         dstRowStride = postConvWidth * texelBytes;
         sizeInBytes = depth * dstRowStride * postConvHeight;
      }
d713 1
a713 1
      texImage->Data = _mesa_align_malloc(sizeInBytes, 16);
d721 2
a722 1
   if (!pixels)
d724 1
d727 1
a727 1
       width, height, depth, width * texelBytes, dstRowStride);
d729 1
a729 3
   /* Copy data.  Would like to know when it's ok for us to eg. use
    * the blitter to copy.  Or, use the hardware to do the format
    * conversion and copy:
d732 3
a734 2
      const GLuint srcImageStride = _mesa_format_row_stride(texImage->TexFormat, width);
      if(dstRowStride == srcImageStride)
d736 2
a737 2
      else
      {
d744 2
a745 3
         for(i = 0; i < lines; ++i)
         {
            memcpy(dst, src, srcImageStride);
d747 1
a747 1
            src += srcImageStride;
d772 1
a772 1
	    st_texture_image_unmap(ctx->st, stImage);
d774 1
a774 1
	    texImage->Data = st_texture_image_map(ctx->st, stImage, i + 1,
d776 1
a776 2
                                                  stImage->base.Width,
                                                  stImage->base.Height);
d786 1
a786 1
      st_texture_image_unmap(ctx->st, stImage);
d793 1
a793 1
st_TexImage3D(GLcontext * ctx,
d810 1
a810 1
st_TexImage2D(GLcontext * ctx,
d825 1
a825 1
st_TexImage1D(GLcontext * ctx,
d840 1
a840 1
st_CompressedTexImage2D(GLcontext *ctx, GLenum target, GLint level,
d858 1
a858 1
decompress_with_blit(GLcontext * ctx, GLenum target, GLint level,
d863 2
a864 1
   struct pipe_screen *screen = ctx->st->pipe->screen;
d866 3
d872 1
a872 1
   struct pipe_texture *dst_texture;
d874 2
d878 1
a878 1
   if (!util_create_rgba_surface(screen, width, height,
d885 5
d891 2
a892 2
   util_blit_pixels_tex(ctx->st->blit,
                        stImage->pt,      /* pipe_texture (src) */
d901 6
d908 4
a911 4
   tex_xfer = st_cond_flush_get_tex_transfer(st_context(ctx),
					     dst_texture, 0, 0, 0,
					     PIPE_TRANSFER_READ,
					     0, 0, width, height);
d919 1
a919 1
      ubyte *map = screen->transfer_map(screen, tex_xfer);
d927 1
a927 1
      screen->transfer_unmap(screen, tex_xfer);
d942 1
a942 1
         pipe_get_tile_rgba(tex_xfer, 0, row, width, 1, rgba);
d951 1
a951 1
   screen->tex_transfer_destroy(tex_xfer);
d964 1
a964 1
st_get_tex_image(GLcontext * ctx, GLenum target, GLint level,
d969 1
d978 1
a978 1
       util_format_is_compressed(stImage->pt->format) &&
d994 1
a994 6
      unsigned face = _mesa_tex_target_to_face(target);

      st_teximage_flush_before_map(ctx->st, stImage->pt, face, level,
				   PIPE_TRANSFER_READ);

      texImage->Data = st_texture_image_map(ctx->st, stImage, 0,
d1020 2
d1034 1
a1034 1
	 st_texture_image_unmap(ctx->st, stImage);
d1036 1
a1036 1
	 texImage->Data = st_texture_image_map(ctx->st, stImage, i + 1,
d1048 1
a1048 1
      st_texture_image_unmap(ctx->st, stImage);
d1055 1
a1055 1
st_GetTexImage(GLcontext * ctx, GLenum target, GLint level,
d1066 1
a1066 1
st_GetCompressedTexImage(GLcontext *ctx, GLenum target, GLint level,
d1078 1
a1078 1
st_TexSubimage(GLcontext *ctx, GLint dims, GLenum target, GLint level,
d1086 2
a1087 1
   struct pipe_screen *screen = ctx->st->pipe->screen;
d1113 2
a1114 2
                                   stImage->pt->target,
                                   PIPE_TEXTURE_USAGE_RENDER_TARGET, 0)) {
a1126 2
      unsigned face = _mesa_tex_target_to_face(target);

d1133 1
a1133 3
      st_teximage_flush_before_map(ctx->st, stImage->pt, face, level,
				   transfer_usage);
      texImage->Data = st_texture_image_map(ctx->st, stImage, zoffset, 
d1161 1
a1161 1
	 st_texture_image_unmap(ctx->st, stImage);
d1163 1
a1163 1
	 texImage->Data = st_texture_image_map(ctx->st, stImage,
d1176 1
a1176 1
      st_texture_image_unmap(ctx->st, stImage);
d1184 1
a1184 1
st_TexSubImage3D(GLcontext *ctx, GLenum target, GLint level,
d1199 1
a1199 1
st_TexSubImage2D(GLcontext *ctx, GLenum target, GLint level,
d1214 1
a1214 1
st_TexSubImage1D(GLcontext *ctx, GLenum target, GLint level,
d1227 1
a1227 1
st_CompressedTexSubImage1D(GLcontext *ctx, GLenum target, GLint level,
d1239 1
a1239 1
st_CompressedTexSubImage2D(GLcontext *ctx, GLenum target, GLint level,
d1247 1
d1252 1
a1252 1
   enum pipe_format pformat= stImage->pt->format;
d1255 1
a1255 1
      unsigned face = _mesa_tex_target_to_face(target);
d1257 1
a1257 3
      st_teximage_flush_before_map(ctx->st, stImage->pt, face, level,
				   PIPE_TRANSFER_WRITE);
      texImage->Data = st_texture_image_map(ctx->st, stImage, 0, 
a1277 2
   assert(width % util_format_get_blockwidth(pformat) == 0);
   assert(height % util_format_get_blockheight(pformat) == 0);
d1287 1
a1287 1
      st_texture_image_unmap(ctx->st, stImage);
d1294 1
a1294 1
st_CompressedTexSubImage3D(GLcontext *ctx, GLenum target, GLint level,
d1315 1
a1315 1
fallback_copy_texsubimage(GLcontext *ctx, GLenum target, GLint level,
d1323 2
a1324 2
   struct pipe_context *pipe = ctx->st->pipe;
   struct pipe_screen *screen = pipe->screen;
d1328 1
a1328 1
   
d1338 6
a1343 6
   src_trans = st_cond_flush_get_tex_transfer( st_context(ctx),
					       strb->texture,
					       0, 0, 0,
					       PIPE_TRANSFER_READ,
					       srcX, srcY,
					       width, height);
d1352 2
a1353 4
   st_teximage_flush_before_map(ctx->st, stImage->pt, 0, 0,
				transfer_usage);

   texDest = st_texture_image_map(ctx->st, stImage, 0, transfer_usage,
d1375 1
a1375 1
         pipe_get_tile_z(src_trans, 0, srcY, width, 1, data);
d1379 1
a1379 1
         pipe_put_tile_z(stImage->transfer, 0, row, width, 1, data);
d1401 1
a1401 1
         pipe_get_tile_rgba(src_trans, 0, 0, width, height, tempSrc);
d1428 2
a1429 2
   st_texture_image_unmap(ctx->st, stImage);
   screen->tex_transfer_destroy(src_trans);
d1441 1
a1441 1
compatible_src_dst_formats(GLcontext *ctx,
d1508 1
a1508 1
st_copy_texsubimage(GLcontext *ctx,
d1524 2
a1525 1
   struct pipe_context *pipe = ctx->st->pipe;
d1530 1
a1530 1
   GLuint format_writemask;
a1533 3
   /* any rendering in progress must flushed before we grab the fb image */
   st_flush(ctx->st, PIPE_FLUSH_RENDER_CACHE, NULL);

d1536 1
a1536 1
   if (0) st_validate_state(ctx->st);
d1542 3
d1556 6
d1612 1
a1612 2
      if (pipe->surface_copy &&
          matching_base_formats &&
d1614 1
a1614 1
          !do_flip) 
d1617 14
a1630 16

         dest_surface = screen->get_tex_surface(screen, stImage->pt,
                                                stImage->face, stImage->level,
                                                destZ,
                                                PIPE_BUFFER_USAGE_GPU_WRITE);

         /* for surface_copy(), y=0=top, always */
         pipe->surface_copy(pipe,
                            /* dest */
                            dest_surface,
                            destX, destY,
                            /* src */
                            strb->surface,
                            srcX, srcY,
                            /* size */
                            width, height);
d1637 2
a1638 2
                                           PIPE_TEXTURE_2D, 
                                           PIPE_TEXTURE_USAGE_SAMPLER,
d1641 2
a1642 2
                                           PIPE_TEXTURE_2D, 
                                           PIPE_TEXTURE_USAGE_RENDER_TARGET,
d1646 7
d1654 2
a1655 4
         dest_surface = screen->get_tex_surface(screen, stImage->pt,
                                                stImage->face, stImage->level,
                                                destZ,
                                                PIPE_BUFFER_USAGE_GPU_WRITE);
d1665 9
a1673 2
         util_blit_pixels_writemask(ctx->st->blit,
                                    strb->surface,
d1676 1
d1682 7
d1708 1
a1708 1
st_CopyTexImage1D(GLcontext * ctx, GLenum target, GLint level,
d1734 1
a1734 1
st_CopyTexImage2D(GLcontext * ctx, GLenum target, GLint level,
d1761 1
a1761 1
st_CopyTexSubImage1D(GLcontext * ctx, GLenum target, GLint level,
d1773 1
a1773 1
st_CopyTexSubImage2D(GLcontext * ctx, GLenum target, GLint level,
d1785 1
a1785 1
st_CopyTexSubImage3D(GLcontext * ctx, GLenum target, GLint level,
d1795 4
d1805 10
d1820 1
a1820 1
                            stImage->pt, /* src texture */
d1823 1
a1823 1
      pipe_texture_reference(&stImage->pt, NULL);
a1825 5
      /* More straightforward upload.  
       */
      st_teximage_flush_before_map(st, stObj->pt, stImage->face, dstLevel,
				   PIPE_TRANSFER_WRITE);

d1840 1
a1840 1
   pipe_texture_reference(&stImage->pt, stObj->pt);
d1850 1
a1850 1
st_finalize_texture(GLcontext *ctx,
d1852 1
a1852 2
		    struct gl_texture_object *tObj,
		    GLboolean *needFlush)
d1854 1
d1857 1
a1857 1
   GLuint blockSize, face;
d1859 1
a1859 2

   *needFlush = GL_FALSE;
d1872 1
a1872 1
         stObj->lastLevel = stObj->base._MaxLevel - stObj->base.BaseLevel;
d1876 1
d1885 3
a1887 2
       firstImage->pt->last_level >= stObj->lastLevel) {
      pipe_texture_reference(&stObj->pt, firstImage->pt);
d1890 2
a1891 2
   /* bytes per pixel block (blocks are usually 1x1) */
   blockSize = _mesa_get_format_bytes(firstImage->base.TexFormat);
a1896 2
      const enum pipe_format fmt =
         st_mesa_format_to_pipe_format(firstImage->base.TexFormat);
d1898 1
a1898 1
          stObj->pt->format != fmt ||
d1900 3
a1902 3
          stObj->pt->width0 != firstImage->base.Width2 ||
          stObj->pt->height0 != firstImage->base.Height2 ||
          stObj->pt->depth0 != firstImage->base.Depth2)
d1904 6
a1909 2
         pipe_texture_reference(&stObj->pt, NULL);
         ctx->st->dirty.st |= ST_NEW_FRAMEBUFFER;
d1916 1
a1916 3
      const enum pipe_format fmt =
         st_mesa_format_to_pipe_format(firstImage->base.TexFormat);
      GLuint usage = default_usage(fmt);
d1918 1
a1918 1
      stObj->pt = st_texture_create(ctx->st,
d1920 1
a1920 1
                                    fmt,
d1922 4
a1925 4
                                    firstImage->base.Width2,
                                    firstImage->base.Height2,
                                    firstImage->base.Depth2,
                                    usage);
d1937 1
a1937 1
      for (level = 0; level <= stObj->lastLevel; level++) {
d1939 1
a1939 1
            st_texture_image(stObj->base.Image[face][stObj->base.BaseLevel + level]);
d1944 1
a1944 2
            copy_image_data_to_texture(ctx->st, stObj, level, stImage);
	    *needFlush = GL_TRUE;
d1986 1
a1986 1
                                 GL_RGBA);
a2035 1
   functions->UpdateTexturePalette = 0;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d30 3
a39 2
#include "main/pack.h"
#include "main/pixeltransfer.h"
a49 1
#include "state_tracker/st_cb_flush.h"
d52 1
d55 1
a65 1
#include "util/u_sampler.h"
d67 1
a67 1
#include "util/u_box.h"
d80 1
a82 3
   case GL_TEXTURE_RECTANGLE_NV:
      return PIPE_TEXTURE_RECT;

d98 1
a98 1
st_NewTextureImage(struct gl_context * ctx)
d108 1
a108 1
st_NewTextureObject(struct gl_context * ctx, GLuint name, GLenum target)
d118 1
a118 1
/** called via ctx->Driver.DeleteTextureObject() */
d120 1
a120 1
st_DeleteTextureObject(struct gl_context *ctx,
a122 1
   struct st_context *st = st_context(ctx);
d125 2
a126 12
      pipe_resource_reference(&stObj->pt, NULL);
   if (stObj->sampler_view) {
      if (stObj->sampler_view->context != st->pipe) {
         /* Take "ownership" of this texture sampler view by setting
          * its context pointer to this context.  This avoids potential
          * crashes when the texture object is shared among contexts
          * and the original/owner context has already been destroyed.
          */
         stObj->sampler_view->context = st->pipe;
      }
      pipe_sampler_view_reference(&stObj->sampler_view, NULL);
   }
d133 1
a133 1
st_FreeTextureImageData(struct gl_context * ctx, struct gl_texture_image *texImage)
d140 1
a140 1
      pipe_resource_reference(&stImage->pt, NULL);
d201 1
a201 1
 * Return default texture resource binding bitmask for the given format.
d204 1
a204 1
default_bindings(struct st_context *st, enum pipe_format format)
d206 3
a208 7
   struct pipe_screen *screen = st->pipe->screen;
   const unsigned target = PIPE_TEXTURE_2D;
   const unsigned geom = 0x0;
   unsigned bindings;

   if (util_format_is_depth_or_stencil(format))
      bindings = PIPE_BIND_SAMPLER_VIEW | PIPE_BIND_DEPTH_STENCIL;
d210 2
a211 34
      bindings = PIPE_BIND_SAMPLER_VIEW | PIPE_BIND_RENDER_TARGET;

   if (screen->is_format_supported(screen, format, target, 0, bindings, geom))
      return bindings;
   else
      return PIPE_BIND_SAMPLER_VIEW;
}


/** Return number of image dimensions (1, 2 or 3) for a texture target. */
static GLuint
get_texture_dims(GLenum target)
{
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_1D_ARRAY_EXT:
      return 1;
   case GL_TEXTURE_2D:
   case GL_TEXTURE_CUBE_MAP_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_TEXTURE_2D_ARRAY_EXT:
      return 2;
   case GL_TEXTURE_3D:
      return 3;
   default:
      assert(0 && "invalid texture target in get_texture_dims()");
      return 1;
   }
d216 2
a217 1
 * Try to allocate a pipe_resource object for the given st_texture_object.
d219 6
a224 2
 * We use the given st_texture_image as a clue to determine the size of the
 * mipmap image at level=0.
d226 2
a227 1
 * \return GL_TRUE for success, GL_FALSE if out of memory.
d229 1
a229 1
static GLboolean
d234 6
a239 3
   const GLuint dims = get_texture_dims(stObj->base.Target);
   GLuint level, lastLevel, width, height, depth;
   GLuint bindings;
d246 17
a262 21
   level = stImage->level;
   width = stImage->base.Width2;  /* size w/out border */
   height = stImage->base.Height2;
   depth = stImage->base.Depth2;

   assert(width > 0);
   assert(height > 0);
   assert(depth > 0);

   /* Depending on the image's size, we can't always make a guess here.
    */
   if (level > 0) {
      if ( (dims >= 1 && width == 1) ||
           (dims >= 2 && height == 1) ||
           (dims >= 3 && depth == 1) ) {
         /* we can't determine the image size at level=0 */
         stObj->width0 = stObj->height0 = stObj->depth0 = 0;
         /* this is not an out of memory error */
         return GL_TRUE;
      }
   }
d264 3
a266 2
   /* grow the image size until we hit level = 0 */
   while (level > 0) {
d273 1
a273 2
      level--;
   }      
d275 4
a278 5
   assert(level == 0);

   /* At this point, (width x height x depth) is the expected size of
    * the level=0 mipmap image.
    */
d280 4
a283 5
   /* Guess a reasonable value for lastLevel.  With OpenGL we have no
    * idea how many mipmap levels will be in a texture until we start
    * to render with it.  Make an educated guess here but be prepared
    * to re-allocating a texture buffer with space for more (or fewer)
    * mipmap levels later.
d290 1
a290 1
       stImage->level == 0) {
d292 1
a292 1
      lastLevel = 0;
d299 1
a299 1
      lastLevel = MAX2(MAX2(l2width, l2height), l2depth);
a301 5
   /* Save the level=0 dimensions */
   stObj->width0 = width;
   stObj->height0 = height;
   stObj->depth0 = depth;

d304 1
a304 1
   bindings = default_bindings(st, fmt);
d313 1
a313 3
                                 bindings);

   DBG("%s returning %d\n", __FUNCTION__, (stObj->pt != NULL));
d315 1
a315 1
   return stObj->pt != NULL;
d364 1
a364 1
compress_with_blit(struct gl_context * ctx,
d374 1
a374 3
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   struct pipe_screen *screen = pipe->screen;
d376 3
a378 5
   struct pipe_resource templ;
   struct pipe_resource *src_tex;
   struct pipe_sampler_view view_templ;
   struct pipe_sampler_view *src_view;
   struct pipe_surface *dst_surface, surf_tmpl;
d388 3
a390 7
   memset(&surf_tmpl, 0, sizeof(surf_tmpl));
   surf_tmpl.format = stImage->pt->format;
   surf_tmpl.usage = PIPE_BIND_RENDER_TARGET;
   surf_tmpl.u.tex.level = stImage->level;
   surf_tmpl.u.tex.first_layer = stImage->face;
   surf_tmpl.u.tex.last_layer = stImage->face;
   dst_surface = pipe->create_surface(pipe, stImage->pt, &surf_tmpl);
d406 1
a406 1
   templ.target = st->internal_target;
a410 1
   templ.array_size = 1;
d412 2
a413 3
   templ.usage = PIPE_USAGE_DEFAULT;
   templ.bind = PIPE_BIND_SAMPLER_VIEW;
   src_tex = screen->resource_create(screen, &templ);
d420 5
a424 5
   tex_xfer = pipe_get_transfer(st_context(ctx)->pipe, src_tex,
                                0, 0, /* layer, level are zero */
                                PIPE_TRANSFER_WRITE,
                                0, 0, width, height); /* x, y, w, h */
   map = pipe_transfer_map(pipe, tex_xfer);
d436 2
a437 9
   pipe_transfer_unmap(pipe, tex_xfer);
   pipe->transfer_destroy(pipe, tex_xfer);

   /* Create temporary sampler view */
   u_sampler_view_default_template(&view_templ,
                                   src_tex,
                                   src_tex->format);
   src_view = pipe->create_sampler_view(pipe, src_tex, &view_templ);

d440 2
a441 2
   util_blit_pixels_tex(st->blit,
                        src_view,         /* sampler view (src) */
d452 1
a452 2
   pipe_resource_reference(&src_tex, NULL);
   pipe_sampler_view_reference(&src_view, NULL);
d462 1
a462 1
st_TexImage(struct gl_context * ctx,
d474 1
a474 2
   struct st_context *st = st_context(ctx);
   struct pipe_screen *screen = st->pipe->screen;
d477 2
a487 2
      gl_format texFormat;

a488 10
      pipe_resource_reference(&stObj->pt, NULL);

      /* oops, need to init this image again */
      texFormat = _mesa_choose_texture_format(ctx, texObj, target, level,
                                              internalFormat, format, type);

      _mesa_init_teximage_fields(ctx, target, texImage,
                                 width, height, depth, border,
                                 internalFormat, texFormat);

d502 3
a504 5
   else {
      assert(texImage->Width == width);
      assert(texImage->Height == height);
      assert(texImage->Depth == depth);
   }
d509 7
d518 17
d539 1
a539 1
      pipe_resource_reference(&stImage->pt, NULL);
d551 2
a552 1
      if (level > (GLint) stObj->pt->last_level ||
d556 1
a556 1
         pipe_resource_reference(&stObj->pt, NULL);
d558 1
a558 1
         pipe_sampler_view_reference(&stObj->sampler_view, NULL);
d568 2
a569 1
      if (!guess_and_alloc_texture(st, stObj, stImage)) {
d573 3
a575 2
         st_finish(st);
         if (!guess_and_alloc_texture(st, stObj, stImage)) {
a583 4
   /* Check if this texture image can live inside the texture object's buffer.
    * If so, store the image there.  Otherwise the image will temporarily live
    * in its own buffer.
    */
d586 1
a586 1
                              stImage->face, stImage->level)) {
d588 1
a588 1
      pipe_resource_reference(&stImage->pt, stObj->pt);
d595 3
a597 5
   /* Pixel data may come from regular user memory or a PBO.  For the later,
    * do bounds checking and map the PBO to read pixels data from it.
    *
    * XXX we should try to use a GPU-accelerated path to copy the image data
    * from the PBO to the texture.
d610 4
d621 2
a622 2
                                   stImage->pt->target, 0,
                                   PIPE_BIND_RENDER_TARGET, 0)) {
a631 4
   /*
    * Prepare to store the texture data.  Either map the gallium texture buffer
    * memory or malloc space for it.
    */
a632 1
      /* Store the image in the gallium texture memory buffer */
d639 4
a642 2
      texImage->Data = st_texture_image_map(st, stImage, 0,
                                            transfer_usage, 0, 0, width, height);
d648 12
a659 3
      GLuint imageSize = _mesa_format_image_size(texImage->TexFormat,
                                                 width, height, depth);
      dstRowStride = _mesa_format_row_stride(texImage->TexFormat, width);
d661 1
a661 1
      texImage->Data = _mesa_align_malloc(imageSize, 16);
d669 1
a669 2
   if (!pixels) {
      /* We've allocated texture memory, but have no pixel data - all done. */
a670 1
   }
d673 1
a673 1
       width, height, depth, width, dstRowStride);
d675 3
a677 1
   /* Copy user texture image into the texture buffer.
d680 2
a681 3
      const GLuint srcRowStride =
         _mesa_format_row_stride(texImage->TexFormat, width);
      if (dstRowStride == srcRowStride) {
d683 2
a684 2
      }
      else {
d691 3
a693 2
         for (i = 0; i < lines; ++i) {
            memcpy(dst, src, srcRowStride);
d695 1
a695 1
            src += srcRowStride;
d720 1
a720 1
	    st_texture_image_unmap(st, stImage);
d722 1
a722 1
	    texImage->Data = st_texture_image_map(st, stImage, i + 1,
d724 2
a725 1
                                                  width, height);
d735 1
a735 1
      st_texture_image_unmap(st, stImage);
d742 1
a742 1
st_TexImage3D(struct gl_context * ctx,
d759 1
a759 1
st_TexImage2D(struct gl_context * ctx,
d774 1
a774 1
st_TexImage1D(struct gl_context * ctx,
d789 1
a789 1
st_CompressedTexImage2D(struct gl_context *ctx, GLenum target, GLint level,
d807 1
a807 1
decompress_with_blit(struct gl_context * ctx, GLenum target, GLint level,
d812 1
a812 2
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
a813 3
   struct st_texture_object *stObj = st_texture_object(texObj);
   struct pipe_sampler_view *src_view =
      st_get_texture_sampler_view(stObj, pipe);
d817 1
a817 1
   struct pipe_resource *dst_texture;
a818 2
   unsigned bind = (PIPE_BIND_RENDER_TARGET | /* util_blit may choose to render */
		    PIPE_BIND_TRANSFER_READ);
d821 1
a821 1
   if (!util_create_rgba_surface(pipe, width, height, bind,
a827 5
   /* Disable conditional rendering. */
   if (st->render_condition) {
      pipe->render_condition(pipe, NULL, 0);
   }

d829 2
a830 2
   util_blit_pixels_tex(st->blit,
                        src_view,      /* pipe_resource (src) */
a838 6
   /* Restore conditional rendering state. */
   if (st->render_condition) {
      pipe->render_condition(pipe, st->render_condition,
                             st->condition_mode);
   }

d840 4
a843 4
   tex_xfer = pipe_get_transfer(st_context(ctx)->pipe,
                                dst_texture, 0, 0,
                                PIPE_TRANSFER_READ,
                                0, 0, width, height);
d851 1
a851 1
      ubyte *map = pipe_transfer_map(pipe, tex_xfer);
d859 1
a859 1
      pipe_transfer_unmap(pipe, tex_xfer);
d874 1
a874 1
         pipe_get_tile_rgba(pipe, tex_xfer, 0, row, width, 1, rgba);
d883 1
a883 1
   pipe->transfer_destroy(pipe, tex_xfer);
d896 1
a896 1
st_get_tex_image(struct gl_context * ctx, GLenum target, GLint level,
a900 1
   struct st_context *st = st_context(ctx);
d909 1
a909 1
       util_format_is_s3tc(stImage->pt->format) &&
d925 6
a930 1
      texImage->Data = st_texture_image_map(st, stImage, 0,
a955 2
   _mesa_set_fetch_functions(texImage, get_texture_dims(target));

d968 1
a968 1
	 st_texture_image_unmap(st, stImage);
d970 1
a970 1
	 texImage->Data = st_texture_image_map(st, stImage, i + 1,
d982 1
a982 1
      st_texture_image_unmap(st, stImage);
d989 1
a989 1
st_GetTexImage(struct gl_context * ctx, GLenum target, GLint level,
d1000 1
a1000 1
st_GetCompressedTexImage(struct gl_context *ctx, GLenum target, GLint level,
d1012 1
a1012 1
st_TexSubimage(struct gl_context *ctx, GLint dims, GLenum target, GLint level,
d1020 1
a1020 2
   struct st_context *st = st_context(ctx);
   struct pipe_screen *screen = st->pipe->screen;
d1046 2
a1047 2
                                   stImage->pt->target, 0,
                                   PIPE_BIND_RENDER_TARGET, 0)) {
d1060 2
d1068 3
a1070 1
      texImage->Data = st_texture_image_map(st, stImage, zoffset, 
d1098 1
a1098 1
	 st_texture_image_unmap(st, stImage);
d1100 1
a1100 1
	 texImage->Data = st_texture_image_map(st, stImage,
d1113 1
a1113 1
      st_texture_image_unmap(st, stImage);
d1121 1
a1121 1
st_TexSubImage3D(struct gl_context *ctx, GLenum target, GLint level,
d1136 1
a1136 1
st_TexSubImage2D(struct gl_context *ctx, GLenum target, GLint level,
d1151 1
a1151 1
st_TexSubImage1D(struct gl_context *ctx, GLenum target, GLint level,
d1164 1
a1164 1
st_CompressedTexSubImage1D(struct gl_context *ctx, GLenum target, GLint level,
d1176 1
a1176 1
st_CompressedTexSubImage2D(struct gl_context *ctx, GLenum target, GLint level,
a1183 1
   struct st_context *st = st_context(ctx);
d1188 1
a1188 1
   enum pipe_format pformat;
d1191 1
a1191 1
      pformat = stImage->pt->format;
d1193 3
a1195 1
      texImage->Data = st_texture_image_map(st, stImage, 0, 
d1216 2
d1227 1
a1227 1
      st_texture_image_unmap(st, stImage);
d1234 1
a1234 1
st_CompressedTexSubImage3D(struct gl_context *ctx, GLenum target, GLint level,
d1255 1
a1255 1
fallback_copy_texsubimage(struct gl_context *ctx, GLenum target, GLint level,
d1263 2
a1264 2
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
d1268 1
a1268 1

d1278 6
a1283 6
   src_trans = pipe_get_transfer(st_context(ctx)->pipe,
                                 strb->texture,
                                 0, 0,
                                 PIPE_TRANSFER_READ,
                                 srcX, srcY,
                                 width, height);
d1292 4
a1295 2
   /* XXX this used to ignore destZ param */
   texDest = st_texture_image_map(st, stImage, destZ, transfer_usage,
d1317 1
a1317 1
         pipe_get_tile_z(pipe, src_trans, 0, srcY, width, 1, data);
d1321 1
a1321 1
         pipe_put_tile_z(pipe, stImage->transfer, 0, row, width, 1, data);
d1343 1
a1343 1
         pipe_get_tile_rgba(pipe, src_trans, 0, 0, width, height, tempSrc);
d1370 2
a1371 2
   st_texture_image_unmap(st, stImage);
   pipe->transfer_destroy(pipe, src_trans);
d1383 1
a1383 1
compatible_src_dst_formats(struct gl_context *ctx,
d1450 1
a1450 1
st_copy_texsubimage(struct gl_context *ctx,
d1466 1
a1466 2
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
d1471 1
a1471 1
   GLuint format_writemask, sample_count;
d1475 3
d1480 1
a1480 1
   if (0) st_validate_state(st);
a1485 3
      if (strb->Base.Wrapped) {
         strb = st_renderbuffer(strb->Base.Wrapped);
      }
a1496 6
   sample_count = strb->surface->texture->nr_samples;
   /* I believe this would be legal, presumably would need to do a resolve
      for color, and for depth/stencil spec says to just use one of the
      depth/stencil samples per pixel? Need some transfer clarifications. */
   assert(sample_count < 2);

d1547 2
a1548 1
      if (matching_base_formats &&
d1550 1
a1550 1
          !do_flip)
d1553 16
a1568 14
         struct pipe_box src_box;
         u_box_2d_zslice(srcX, srcY, strb->surface->u.tex.first_layer,
                         width, height, &src_box);

         /* for resource_copy_region(), y=0=top, always */
         pipe->resource_copy_region(pipe,
                                    /* dest */
                                    stImage->pt,
                                    stImage->level,
                                    destX, destY, destZ + stImage->face,
                                    /* src */
                                    strb->texture,
                                    strb->surface->u.tex.level,
                                    &src_box);
d1575 2
a1576 2
                                           PIPE_TEXTURE_2D, sample_count,
                                           PIPE_BIND_SAMPLER_VIEW,
d1579 2
a1580 2
                                           PIPE_TEXTURE_2D, 0,
                                           PIPE_BIND_RENDER_TARGET,
a1583 7
         struct pipe_surface surf_tmpl;
         memset(&surf_tmpl, 0, sizeof(surf_tmpl));
         surf_tmpl.format = stImage->pt->format;
         surf_tmpl.usage = PIPE_BIND_RENDER_TARGET;
         surf_tmpl.u.tex.level = stImage->level;
         surf_tmpl.u.tex.first_layer = stImage->face + destZ;
         surf_tmpl.u.tex.last_layer = stImage->face + destZ;
d1585 4
a1588 2
         dest_surface = pipe->create_surface(pipe, stImage->pt,
                                             &surf_tmpl);
d1598 2
a1599 9

         /* Disable conditional rendering. */
         if (st->render_condition) {
            pipe->render_condition(pipe, NULL, 0);
         }

         util_blit_pixels_writemask(st->blit,
                                    strb->texture,
                                    strb->surface->u.tex.level,
a1601 1
                                    strb->surface->u.tex.first_layer,
a1606 7

         /* Restore conditional rendering state. */
         if (st->render_condition) {
            pipe->render_condition(pipe, st->render_condition,
                                   st->condition_mode);
         }

d1626 1
a1626 1
st_CopyTexImage1D(struct gl_context * ctx, GLenum target, GLint level,
d1652 1
a1652 1
st_CopyTexImage2D(struct gl_context * ctx, GLenum target, GLint level,
d1679 1
a1679 1
st_CopyTexSubImage1D(struct gl_context * ctx, GLenum target, GLint level,
d1691 1
a1691 1
st_CopyTexSubImage2D(struct gl_context * ctx, GLenum target, GLint level,
d1703 1
a1703 1
st_CopyTexSubImage3D(struct gl_context * ctx, GLenum target, GLint level,
a1712 4
/**
 * Copy image data from stImage into the texture object 'stObj' at level
 * 'dstLevel'.
 */
a1718 10
   /* debug checks */
   {
      const struct gl_texture_image *dstImage =
         stObj->base.Image[stImage->face][stImage->level];
      assert(dstImage);
      assert(dstImage->Width == stImage->base.Width);
      assert(dstImage->Height == stImage->base.Height);
      assert(dstImage->Depth == stImage->base.Depth);
   }

d1724 1
a1724 1
                            stImage->pt, stImage->level, /* src texture, level */
d1727 1
a1727 1
      pipe_resource_reference(&stImage->pt, NULL);
d1730 5
d1749 1
a1749 1
   pipe_resource_reference(&stImage->pt, stObj->pt);
d1759 1
a1759 1
st_finalize_texture(struct gl_context *ctx,
d1761 2
a1762 1
		    struct gl_texture_object *tObj)
a1763 1
   struct st_context *st = st_context(ctx);
d1766 1
a1766 1
   GLuint face;
d1768 2
a1769 1
   enum pipe_format firstImageFormat;
d1782 1
a1782 1
         stObj->lastLevel = stObj->base._MaxLevel;
a1785 1
   assert(firstImage);
d1794 2
a1795 3
       (!stObj->pt || firstImage->pt->last_level >= stObj->pt->last_level)) {
      pipe_resource_reference(&stObj->pt, firstImage->pt);
      pipe_sampler_view_reference(&stObj->sampler_view, NULL);
d1798 2
a1799 2
   /* Find gallium format for the Mesa texture */
   firstImageFormat = st_mesa_format_to_pipe_format(firstImage->base.TexFormat);
d1805 2
d1808 1
a1808 1
          !st_sampler_compat_formats(stObj->pt->format, firstImageFormat) ||
d1810 3
a1812 3
          stObj->pt->width0 != stObj->width0 ||
          stObj->pt->height0 != stObj->height0 ||
          stObj->pt->depth0 != stObj->depth0)
d1814 2
a1815 6
         /* The gallium texture does not match the Mesa texture so delete the
          * gallium texture now.  We'll make a new one below.
          */
         pipe_resource_reference(&stObj->pt, NULL);
         pipe_sampler_view_reference(&stObj->sampler_view, NULL);
         st->dirty.st |= ST_NEW_FRAMEBUFFER;
d1822 3
a1824 1
      GLuint bindings = default_bindings(st, firstImageFormat);
d1826 1
a1826 1
      stObj->pt = st_texture_create(st,
d1828 1
a1828 1
                                    firstImageFormat,
d1830 4
a1833 4
                                    stObj->width0,
                                    stObj->height0,
                                    stObj->depth0,
                                    bindings);
d1845 1
a1845 1
      for (level = stObj->base.BaseLevel; level <= stObj->lastLevel; level++) {
d1847 1
a1847 1
            st_texture_image(stObj->base.Image[face][level]);
d1852 2
a1853 1
            copy_image_data_to_texture(st, stObj, level, stImage);
d1895 1
a1895 1
                                 GL_RGBA, MESA_FORMAT_RGBA8888);
d1945 1
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d28 1
a37 1
#include "main/pbo.h"
d40 1
a50 1
#include "state_tracker/st_cb_bufferobjects.h"
d61 1
d71 1
a71 1
enum pipe_texture_target
a75 1
   case GL_PROXY_TEXTURE_1D:
d77 1
a78 4
   case GL_PROXY_TEXTURE_2D:
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
d80 1
a81 1
   case GL_PROXY_TEXTURE_RECTANGLE_NV:
d83 1
a84 1
   case GL_PROXY_TEXTURE_3D:
d86 1
a87 7
   case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
d89 1
a89 13
   case GL_TEXTURE_1D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_1D_ARRAY_EXT:
      return PIPE_TEXTURE_1D_ARRAY;
   case GL_TEXTURE_2D_ARRAY_EXT:
   case GL_PROXY_TEXTURE_2D_ARRAY_EXT:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return PIPE_TEXTURE_2D_ARRAY;
   case GL_TEXTURE_BUFFER:
      return PIPE_BUFFER;
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
      return PIPE_TEXTURE_CUBE_ARRAY;
a106 9
/** called via ctx->Driver.DeleteTextureImage() */
static void
st_DeleteTextureImage(struct gl_context * ctx, struct gl_texture_image *img)
{
   /* nothing special (yet) for st_texture_image */
   _mesa_delete_texture_image(ctx, img);
}


d114 1
a114 1
   _mesa_initialize_texture_object(ctx, &obj->base, name, target);
d129 9
a137 1
      pipe_sampler_view_release(st->pipe, &stObj->sampler_view);
d143 1
a143 1
/** called via ctx->Driver.FreeTextureImageBuffer() */
d145 1
a145 2
st_FreeTextureImageBuffer(struct gl_context *ctx,
                          struct gl_texture_image *texImage)
d155 3
a157 3
   if (stImage->TexData) {
      _mesa_align_free(stImage->TexData);
      stImage->TexData = NULL;
d162 24
a185 31
/** called via ctx->Driver.MapTextureImage() */
static void
st_MapTextureImage(struct gl_context *ctx,
                   struct gl_texture_image *texImage,
                   GLuint slice, GLuint x, GLuint y, GLuint w, GLuint h,
                   GLbitfield mode,
                   GLubyte **mapOut, GLint *rowStrideOut)
{
   struct st_context *st = st_context(ctx);
   struct st_texture_image *stImage = st_texture_image(texImage);
   unsigned pipeMode;
   GLubyte *map;

   pipeMode = 0x0;
   if (mode & GL_MAP_READ_BIT)
      pipeMode |= PIPE_TRANSFER_READ;
   if (mode & GL_MAP_WRITE_BIT)
      pipeMode |= PIPE_TRANSFER_WRITE;
   if (mode & GL_MAP_INVALIDATE_RANGE_BIT)
      pipeMode |= PIPE_TRANSFER_DISCARD_RANGE;

   map = st_texture_image_map(st, stImage, pipeMode, x, y, slice, w, h, 1);
   if (map) {
      *mapOut = map;
      *rowStrideOut = stImage->transfer->stride;
   }
   else {
      *mapOut = NULL;
      *rowStrideOut = 0;
   }
}
d188 15
a202 5
/** called via ctx->Driver.UnmapTextureImage() */
static void
st_UnmapTextureImage(struct gl_context *ctx,
                     struct gl_texture_image *texImage,
                     GLuint slice)
d204 5
a208 3
   struct st_context *st = st_context(ctx);
   struct st_texture_image *stImage  = st_texture_image(texImage);
   st_texture_image_unmap(st, stImage);
d220 1
d228 1
a228 1
   if (screen->is_format_supported(screen, format, target, 0, bindings))
d230 2
a231 9
   else {
      /* Try non-sRGB. */
      format = util_format_linear(format);

      if (screen->is_format_supported(screen, format, target, 0, bindings))
         return bindings;
      else
         return PIPE_BIND_SAMPLER_VIEW;
   }
d235 24
a258 64
/**
 * Given the size of a mipmap image, try to compute the size of the level=0
 * mipmap image.
 *
 * Note that this isn't always accurate for odd-sized, non-POW textures.
 * For example, if level=1 and width=40 then the level=0 width may be 80 or 81.
 *
 * \return GL_TRUE for success, GL_FALSE for failure
 */
static GLboolean
guess_base_level_size(GLenum target,
                      GLuint width, GLuint height, GLuint depth, GLuint level,
                      GLuint *width0, GLuint *height0, GLuint *depth0)
{ 
   assert(width >= 1);
   assert(height >= 1);
   assert(depth >= 1);

   if (level > 0) {
      /* Guess the size of the base level.
       * Depending on the image's size, we can't always make a guess here.
       */
      switch (target) {
      case GL_TEXTURE_1D:
      case GL_TEXTURE_1D_ARRAY:
         width <<= level;
         break;

      case GL_TEXTURE_2D:
      case GL_TEXTURE_2D_ARRAY:
         /* We can't make a good guess here, because the base level dimensions
          * can be non-square.
          */
         if (width == 1 || height == 1) {
            return GL_FALSE;
         }
         width <<= level;
         height <<= level;
         break;

      case GL_TEXTURE_CUBE_MAP:
      case GL_TEXTURE_CUBE_MAP_ARRAY:
         width <<= level;
         height <<= level;
         break;

      case GL_TEXTURE_3D:
         /* We can't make a good guess here, because the base level dimensions
          * can be non-cube.
          */
         if (width == 1 || height == 1 || depth == 1) {
            return GL_FALSE;
         }
         width <<= level;
         height <<= level;
         depth <<= level;
         break;

      case GL_TEXTURE_RECTANGLE:
         break;

      default:
         assert(0);
      }
a259 6

   *width0 = width;
   *height0 = height;
   *depth0 = depth;

   return GL_TRUE;
d276 2
a277 1
   GLuint lastLevel, width, height, depth;
a278 1
   GLuint ptWidth, ptHeight, ptDepth, ptLayers;
d285 20
a304 10
   if (!guess_base_level_size(stObj->base.Target,
                              stImage->base.Width2,
                              stImage->base.Height2,
                              stImage->base.Depth2,
                              stImage->base.Level,
                              &width, &height, &depth)) {
      /* we can't determine the image size at level=0 */
      stObj->width0 = stObj->height0 = stObj->depth0 = 0;
      /* this is not an out of memory error */
      return GL_TRUE;
d307 13
d330 2
a331 4
   if ((stObj->base.Sampler.MinFilter == GL_NEAREST ||
        stObj->base.Sampler.MinFilter == GL_LINEAR ||
        (stObj->base.BaseLevel == 0 &&
         stObj->base.MaxLevel == 0) ||
d335 1
a335 1
       stImage->base.Level == 0) {
d341 4
a344 2
      lastLevel = _mesa_get_tex_max_num_levels(stObj->base.Target,
                                               width, height, depth) - 1;
a355 4
   st_gl_texture_dims_to_pipe_dims(stObj->base.Target,
                                   width, height, depth,
                                   &ptWidth, &ptHeight, &ptDepth, &ptLayers);

d360 3
a362 4
                                 ptWidth,
                                 ptHeight,
                                 ptDepth,
                                 ptLayers, 0,
a364 2
   stObj->lastLevel = lastLevel;

d372 42
a413 3
 * Called via ctx->Driver.AllocTextureImageBuffer().
 * If the texture object/buffer already has space for the indicated image,
 * we're done.  Otherwise, allocate memory for the new texture image.
d416 7
a422 2
st_AllocTextureImageBuffer(struct gl_context *ctx,
                           struct gl_texture_image *texImage)
d424 2
d427 10
a436 6
   struct st_texture_image *stImage = st_texture_image(texImage);
   struct st_texture_object *stObj = st_texture_object(texImage->TexObject);
   const GLuint level = texImage->Level;
   GLuint width = texImage->Width;
   GLuint height = texImage->Height;
   GLuint depth = texImage->Depth;
d438 4
a441 1
   DBG("%s\n", __FUNCTION__);
d443 12
a454 2
   assert(!stImage->TexData);
   assert(!stImage->pt); /* xxx this might be wrong */
d456 6
a461 8
   /* Look if the parent texture object has space for this image */
   if (stObj->pt &&
       level <= stObj->pt->last_level &&
       st_texture_match_image(stObj->pt, texImage)) {
      /* this image will fit in the existing texture object's memory */
      pipe_resource_reference(&stImage->pt, stObj->pt);
      return GL_TRUE;
   }
d463 13
a475 1
   /* The parent texture object does not have space for this image */
d477 2
a478 2
   pipe_resource_reference(&stObj->pt, NULL);
   pipe_sampler_view_release(st->pipe, &stObj->sampler_view);
d480 43
a522 10
   if (!guess_and_alloc_texture(st, stObj, stImage)) {
      /* Probably out of memory.
       * Try flushing any pending rendering, then retry.
       */
      st_finish(st);
      if (!guess_and_alloc_texture(st, stObj, stImage)) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage");
         return GL_FALSE;
      }
   }
d524 1
a524 34
   if (stObj->pt &&
       st_texture_match_image(stObj->pt, texImage)) {
      /* The image will live in the object's mipmap memory */
      pipe_resource_reference(&stImage->pt, stObj->pt);
      assert(stImage->pt);
      return GL_TRUE;
   }
   else {
      /* Create a new, temporary texture/resource/buffer to hold this
       * one texture image.  Note that when we later access this image
       * (either for mapping or copying) we'll want to always specify
       * mipmap level=0, even if the image represents some other mipmap
       * level.
       */
      enum pipe_format format =
         st_mesa_format_to_pipe_format(texImage->TexFormat);
      GLuint bindings = default_bindings(st, format);
      GLuint ptWidth, ptHeight, ptDepth, ptLayers;

      st_gl_texture_dims_to_pipe_dims(stObj->base.Target,
                                      width, height, depth,
                                      &ptWidth, &ptHeight, &ptDepth, &ptLayers);

      stImage->pt = st_texture_create(st,
                                      gl_target_to_pipe(stObj->base.Target),
                                      format,
                                      0, /* lastLevel */
                                      ptWidth,
                                      ptHeight,
                                      ptDepth,
                                      ptLayers, 0,
                                      bindings);
      return stImage->pt != NULL;
   }
d529 1
a529 2
 * Preparation prior to glTexImage.  Basically check the 'surface_based'
 * field and switch to a "normal" tex image if necessary.
d532 11
a542 2
prep_teximage(struct gl_context *ctx, struct gl_texture_image *texImage,
              GLenum format, GLenum type)
d544 2
a545 1
   struct gl_texture_object *texObj = texImage->TexObject;
d547 7
a556 2
      const GLenum target = texObj->Target;
      const GLuint level = texImage->Level;
d564 1
a564 2
                                              texImage->InternalFormat, format,
                                              type);
d566 3
a568 4
      _mesa_init_teximage_fields(ctx, texImage,
                                 texImage->Width, texImage->Height,
                                 texImage->Depth, texImage->Border,
                                 texImage->InternalFormat, texFormat);
a571 1
}
d573 14
a586 43

/**
 * Return a writemask for the gallium blit. The parameters can be base
 * formats or "format" from glDrawPixels/glTexImage/glGetTexImage.
 */
unsigned
st_get_blit_mask(GLenum srcFormat, GLenum dstFormat)
{
   switch (dstFormat) {
   case GL_DEPTH_STENCIL:
      switch (srcFormat) {
      case GL_DEPTH_STENCIL:
         return PIPE_MASK_ZS;
      case GL_DEPTH_COMPONENT:
         return PIPE_MASK_Z;
      case GL_STENCIL_INDEX:
         return PIPE_MASK_S;
      default:
         assert(0);
         return 0;
      }

   case GL_DEPTH_COMPONENT:
      switch (srcFormat) {
      case GL_DEPTH_STENCIL:
      case GL_DEPTH_COMPONENT:
         return PIPE_MASK_Z;
      default:
         assert(0);
         return 0;
      }

   case GL_STENCIL_INDEX:
      switch (srcFormat) {
      case GL_STENCIL_INDEX:
         return PIPE_MASK_S;
      default:
         assert(0);
         return 0;
      }

   default:
      return PIPE_MASK_RGBA;
a587 1
}
d589 2
d592 1
a592 23
static void
st_TexSubImage(struct gl_context *ctx, GLuint dims,
               struct gl_texture_image *texImage,
               GLint xoffset, GLint yoffset, GLint zoffset,
               GLint width, GLint height, GLint depth,
               GLenum format, GLenum type, const void *pixels,
               const struct gl_pixelstore_attrib *unpack)
{
   struct st_context *st = st_context(ctx);
   struct st_texture_image *stImage = st_texture_image(texImage);
   struct st_texture_object *stObj = st_texture_object(texImage->TexObject);
   struct pipe_context *pipe = st->pipe;
   struct pipe_screen *screen = pipe->screen;
   struct pipe_resource *dst = stImage->pt;
   struct pipe_resource *src = NULL;
   struct pipe_resource src_templ;
   struct pipe_transfer *transfer;
   struct pipe_blit_info blit;
   enum pipe_format src_format, dst_format;
   gl_format mesa_src_format;
   GLenum gl_target = texImage->TexObject->Target;
   unsigned bind;
   GLubyte *map;
d594 6
a599 2
   if (!st->prefer_blit_based_texture_transfer) {
      goto fallback;
d601 2
a602 3

   if (!dst) {
      goto fallback;
d605 13
a617 4
   /* XXX Fallback for depth-stencil formats due to an incomplete stencil
    * blit implementation in some drivers. */
   if (format == GL_DEPTH_STENCIL) {
      goto fallback;
d620 3
a622 5
   /* If the base internal format and the texture format don't match,
    * we can't use blit-based TexSubImage. */
   if (texImage->_BaseFormat !=
       _mesa_get_format_base_format(texImage->TexFormat)) {
      goto fallback;
d625 11
a635 6
   /* See if the texture format already matches the format and type,
    * in which case the memcpy-based fast path will likely be used and
    * we don't have to blit. */
   if (_mesa_format_matches_format_and_type(texImage->TexFormat, format,
                                            type, unpack->SwapBytes)) {
      goto fallback;
d638 1
a638 4
   if (format == GL_DEPTH_COMPONENT || format == GL_DEPTH_STENCIL)
      bind = PIPE_BIND_DEPTH_STENCIL;
   else
      bind = PIPE_BIND_RENDER_TARGET;
d640 7
a646 5
   /* See if the destination format is supported.
    * For luminance and intensity, only the red channel is stored there. */
   dst_format = util_format_linear(dst->format);
   dst_format = util_format_luminance_to_red(dst_format);
   dst_format = util_format_intensity_to_red(dst_format);
d648 2
a649 4
   if (!dst_format ||
       !screen->is_format_supported(screen, dst_format, dst->target,
                                    dst->nr_samples, bind)) {
      goto fallback;
d652 13
a664 5
   /* Choose the source format. */
   src_format = st_choose_matching_format(screen, PIPE_BIND_SAMPLER_VIEW,
                                          format, type, unpack->SwapBytes);
   if (!src_format) {
      goto fallback;
d666 4
a669 10

   mesa_src_format = st_pipe_format_to_mesa_format(src_format);

   /* There is no reason to do this if we cannot use memcpy for the temporary
    * source texture at least. This also takes transfer ops into account,
    * etc. */
   if (!_mesa_texstore_can_use_memcpy(ctx,
                             _mesa_get_format_base_format(mesa_src_format),
                             mesa_src_format, format, type, unpack)) {
      goto fallback;
d672 16
a687 3
   /* TexSubImage only sets a single cubemap face. */
   if (gl_target == GL_TEXTURE_CUBE_MAP) {
      gl_target = GL_TEXTURE_2D;
d690 11
a700 6
   /* Initialize the source texture description. */
   memset(&src_templ, 0, sizeof(src_templ));
   src_templ.target = gl_target_to_pipe(gl_target);
   src_templ.format = src_format;
   src_templ.bind = PIPE_BIND_SAMPLER_VIEW;
   src_templ.usage = PIPE_USAGE_STAGING;
d702 4
a705 10
   st_gl_texture_dims_to_pipe_dims(gl_target, width, height, depth,
                                   &src_templ.width0, &src_templ.height0,
                                   &src_templ.depth0, &src_templ.array_size);

   /* Check for NPOT texture support. */
   if (!screen->get_param(screen, PIPE_CAP_NPOT_TEXTURES) &&
       (!util_is_power_of_two(src_templ.width0) ||
        !util_is_power_of_two(src_templ.height0) ||
        !util_is_power_of_two(src_templ.depth0))) {
      goto fallback;
d707 5
d713 1
a713 4
   /* Create the source texture. */
   src = screen->resource_create(screen, &src_templ);
   if (!src) {
      goto fallback;
d716 2
a717 7
   /* Map source pixels. */
   pixels = _mesa_validate_pbo_teximage(ctx, dims, width, height, depth,
                                        format, type, pixels, unpack,
                                        "glTexSubImage");
   if (!pixels) {
      /* This is a GL error. */
      pipe_resource_reference(&src, NULL);
d721 3
a723 4
   /* From now on, we need the gallium representation of dimensions. */
   if (gl_target == GL_TEXTURE_1D_ARRAY) {
      depth = height;
      height = 1;
d726 2
a727 7
   map = pipe_transfer_map_3d(pipe, src, 0, PIPE_TRANSFER_WRITE, 0, 0, 0,
                              width, height, depth, &transfer);
   if (!map) {
      _mesa_unmap_teximage_pbo(ctx, unpack);
      pipe_resource_reference(&src, NULL);
      goto fallback;
   }
d729 19
a747 14
   /* Upload pixels (just memcpy). */
   {
      const uint bytesPerRow = width * util_format_get_blocksize(src_format);
      GLuint row, slice;

      for (slice = 0; slice < (unsigned) depth; slice++) {
         if (gl_target == GL_TEXTURE_1D_ARRAY) {
            /* 1D array textures.
             * We need to convert gallium coords to GL coords.
             */
            GLvoid *src = _mesa_image_address3d(unpack, pixels,
                                                width, depth, format,
                                                type, 0, slice, 0);
            memcpy(map, src, bytesPerRow);
d749 30
a778 12
         else {
            ubyte *slice_map = map;

            for (row = 0; row < (unsigned) height; row++) {
               GLvoid *src = _mesa_image_address3d(unpack, pixels,
                                                   width, height, format,
                                                   type, slice, row, 0);
               memcpy(slice_map, src, bytesPerRow);
               slice_map += transfer->stride;
            }
         }
         map += transfer->layer_stride;
d782 1
a782 1
   pipe_transfer_unmap(pipe, transfer);
d785 4
a788 27
   /* Blit. */
   blit.src.resource = src;
   blit.src.level = 0;
   blit.src.format = src_format;
   blit.dst.resource = dst;
   blit.dst.level = stObj->pt != stImage->pt ? 0 : texImage->Level;
   blit.dst.format = dst_format;
   blit.src.box.x = blit.src.box.y = blit.src.box.z = 0;
   blit.dst.box.x = xoffset;
   blit.dst.box.y = yoffset;
   blit.dst.box.z = zoffset + texImage->Face;
   blit.src.box.width = blit.dst.box.width = width;
   blit.src.box.height = blit.dst.box.height = height;
   blit.src.box.depth = blit.dst.box.depth = depth;
   blit.mask = st_get_blit_mask(format, texImage->_BaseFormat);
   blit.filter = PIPE_TEX_FILTER_NEAREST;
   blit.scissor_enable = FALSE;

   st->pipe->blit(st->pipe, &blit);

   pipe_resource_reference(&src, NULL);
   return;

fallback:
   _mesa_store_texsubimage(ctx, dims, texImage, xoffset, yoffset, zoffset,
                           width, height, depth, format, type, pixels,
                           unpack);
d791 1
d793 14
a806 6
st_TexImage(struct gl_context * ctx, GLuint dims,
            struct gl_texture_image *texImage,
            GLenum format, GLenum type, const void *pixels,
            const struct gl_pixelstore_attrib *unpack)
{
   assert(dims == 1 || dims == 2 || dims == 3);
a807 1
   prep_teximage(ctx, texImage, format, type);
d809 13
a821 2
   if (texImage->Width == 0 || texImage->Height == 0 || texImage->Depth == 0)
      return;
a822 5
   /* allocate storage for texture data */
   if (!ctx->Driver.AllocTextureImageBuffer(ctx, texImage)) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage%uD", dims);
      return;
   }
d824 12
a835 3
   st_TexSubImage(ctx, dims, texImage, 0, 0, 0,
                  texImage->Width, texImage->Height, texImage->Depth,
                  format, type, pixels, unpack);
d840 6
a845 3
st_CompressedTexImage(struct gl_context *ctx, GLuint dims,
                      struct gl_texture_image *texImage,
                      GLsizei imageSize, const GLvoid *data)
d847 2
a848 2
   prep_teximage(ctx, texImage, GL_NONE, GL_NONE);
   _mesa_store_compressed_teximage(ctx, dims, texImage, imageSize, data);
a852 1

d854 2
a855 12
 * Called via ctx->Driver.GetTexImage()
 *
 * This uses a blit to copy the texture to a texture format which matches
 * the format and type combo and then a fast read-back is done using memcpy.
 * We can do arbitrary X/Y/Z/W/0/1 swizzling here as long as there is
 * a format which matches the swizzling.
 *
 * If such a format isn't available, it falls back to _mesa_get_teximage.
 *
 * NOTE: Drivers usually do a blit to convert between tiled and linear
 *       texture layouts during texture uploads/downloads, so the blit
 *       we do here should be free in such cases.
d858 4
a861 3
st_GetTexImage(struct gl_context * ctx,
               GLenum format, GLenum type, GLvoid * pixels,
               struct gl_texture_image *texImage)
a864 4
   struct pipe_screen *screen = pipe->screen;
   GLuint width = texImage->Width;
   GLuint height = texImage->Height;
   GLuint depth = texImage->Depth;
d866 7
a872 9
   struct pipe_resource *src = st_texture_object(texImage->TexObject)->pt;
   struct pipe_resource *dst = NULL;
   struct pipe_resource dst_templ;
   enum pipe_format dst_format, src_format;
   gl_format mesa_format;
   GLenum gl_target = texImage->TexObject->Target;
   enum pipe_texture_target pipe_target;
   struct pipe_blit_info blit;
   unsigned bind = PIPE_BIND_TRANSFER_READ;
d874 2
a875 2
   ubyte *map = NULL;
   boolean done = FALSE;
d877 6
a882 2
   if (!st->prefer_blit_based_texture_transfer) {
      goto fallback;
d885 3
a887 2
   if (!stImage->pt || !src) {
      goto fallback;
d890 38
a927 4
   /* XXX Fallback to _mesa_get_teximage for depth-stencil formats
    * due to an incomplete stencil blit implementation in some drivers. */
   if (format == GL_DEPTH_STENCIL) {
      goto fallback;
d929 11
d941 6
a946 5
   /* If the base internal format and the texture format don't match, we have
    * to fall back to _mesa_get_teximage. */
   if (texImage->_BaseFormat !=
       _mesa_get_format_base_format(texImage->TexFormat)) {
      goto fallback;
d949 38
a986 5
   /* See if the texture format already matches the format and type,
    * in which case the memcpy-based fast path will be used. */
   if (_mesa_format_matches_format_and_type(texImage->TexFormat, format,
                                            type, ctx->Pack.SwapBytes)) {
      goto fallback;
d989 24
a1012 17
   /* Convert the source format to what is expected by GetTexImage
    * and see if it's supported.
    *
    * This only applies to glGetTexImage:
    * - Luminance must be returned as (L,0,0,1).
    * - Luminance alpha must be returned as (L,0,0,A).
    * - Intensity must be returned as (I,0,0,1)
    */
   src_format = util_format_linear(src->format);
   src_format = util_format_luminance_to_red(src_format);
   src_format = util_format_intensity_to_red(src_format);

   if (!src_format ||
       !screen->is_format_supported(screen, src_format, src->target,
                                    src->nr_samples,
                                    PIPE_BIND_SAMPLER_VIEW)) {
      goto fallback;
d1015 6
a1020 4
   if (format == GL_DEPTH_COMPONENT || format == GL_DEPTH_STENCIL)
      bind |= PIPE_BIND_DEPTH_STENCIL;
   else
      bind |= PIPE_BIND_RENDER_TARGET;
d1022 9
a1030 91
   /* GetTexImage only returns a single face for cubemaps. */
   if (gl_target == GL_TEXTURE_CUBE_MAP) {
      gl_target = GL_TEXTURE_2D;
   }
   pipe_target = gl_target_to_pipe(gl_target);

   /* Choose the destination format by finding the best match
    * for the format+type combo. */
   dst_format = st_choose_matching_format(screen, bind, format, type,
					  ctx->Pack.SwapBytes);

   if (dst_format == PIPE_FORMAT_NONE) {
      GLenum dst_glformat;

      /* Fall back to _mesa_get_teximage except for compressed formats,
       * where decompression with a blit is always preferred. */
      if (!util_format_is_compressed(src->format)) {
         goto fallback;
      }

      /* Set the appropriate format for the decompressed texture.
       * Luminance and sRGB formats shouldn't appear here.*/
      switch (src_format) {
      case PIPE_FORMAT_DXT1_RGB:
      case PIPE_FORMAT_DXT1_RGBA:
      case PIPE_FORMAT_DXT3_RGBA:
      case PIPE_FORMAT_DXT5_RGBA:
      case PIPE_FORMAT_RGTC1_UNORM:
      case PIPE_FORMAT_RGTC2_UNORM:
      case PIPE_FORMAT_ETC1_RGB8:
         dst_glformat = GL_RGBA8;
         break;
      case PIPE_FORMAT_RGTC1_SNORM:
      case PIPE_FORMAT_RGTC2_SNORM:
         if (!ctx->Extensions.EXT_texture_snorm)
            goto fallback;
         dst_glformat = GL_RGBA8_SNORM;
         break;
      /* TODO: for BPTC_*FLOAT, set RGBA32F and check for ARB_texture_float */
      default:
         assert(0);
         goto fallback;
      }

      dst_format = st_choose_format(st, dst_glformat, format, type,
                                    pipe_target, 0, bind, FALSE);

      if (dst_format == PIPE_FORMAT_NONE) {
         /* unable to get an rgba format!?! */
         goto fallback;
      }
   }

   /* create the destination texture */
   memset(&dst_templ, 0, sizeof(dst_templ));
   dst_templ.target = pipe_target;
   dst_templ.format = dst_format;
   dst_templ.bind = bind;
   dst_templ.usage = PIPE_USAGE_STAGING;

   st_gl_texture_dims_to_pipe_dims(gl_target, width, height, depth,
                                   &dst_templ.width0, &dst_templ.height0,
                                   &dst_templ.depth0, &dst_templ.array_size);

   dst = screen->resource_create(screen, &dst_templ);
   if (!dst) {
      goto fallback;
   }

   /* From now on, we need the gallium representation of dimensions. */
   if (gl_target == GL_TEXTURE_1D_ARRAY) {
      depth = height;
      height = 1;
   }

   blit.src.resource = src;
   blit.src.level = texImage->Level;
   blit.src.format = src_format;
   blit.dst.resource = dst;
   blit.dst.level = 0;
   blit.dst.format = dst->format;
   blit.src.box.x = blit.dst.box.x = 0;
   blit.src.box.y = blit.dst.box.y = 0;
   blit.src.box.z = texImage->Face;
   blit.dst.box.z = 0;
   blit.src.box.width = blit.dst.box.width = width;
   blit.src.box.height = blit.dst.box.height = height;
   blit.src.box.depth = blit.dst.box.depth = depth;
   blit.mask = st_get_blit_mask(texImage->_BaseFormat, format);
   blit.filter = PIPE_TEX_FILTER_NEAREST;
   blit.scissor_enable = FALSE;
d1032 11
a1042 2
   /* blit/render/decompress */
   st->pipe->blit(st->pipe, &blit);
d1044 1
a1044 1
   pixels = _mesa_map_pbo_dest(ctx, &ctx->Pack, pixels);
d1046 4
a1049 4
   map = pipe_transfer_map_3d(pipe, dst, 0, PIPE_TRANSFER_READ,
                              0, 0, 0, width, height, depth, &tex_xfer);
   if (!map) {
      goto end;
d1051 23
a1074 1
   mesa_format = st_pipe_format_to_mesa_format(dst_format);
a1075 6
   /* copy/pack data into user buffer */
   if (_mesa_format_matches_format_and_type(mesa_format, format, type,
                                            ctx->Pack.SwapBytes)) {
      /* memcpy */
      const uint bytesPerRow = width * util_format_get_blocksize(dst_format);
      GLuint row, slice;
d1077 29
a1105 12
      for (slice = 0; slice < depth; slice++) {
         if (gl_target == GL_TEXTURE_1D_ARRAY) {
            /* 1D array textures.
             * We need to convert gallium coords to GL coords.
             */
            GLvoid *dest = _mesa_image_address3d(&ctx->Pack, pixels,
                                                 width, depth, format,
                                                 type, 0, slice, 0);
            memcpy(dest, map, bytesPerRow);
         }
         else {
            ubyte *slice_map = map;
d1107 13
a1119 9
            for (row = 0; row < height; row++) {
               GLvoid *dest = _mesa_image_address3d(&ctx->Pack, pixels,
                                                    width, height, format,
                                                    type, slice, row, 0);
               memcpy(dest, slice_map, bytesPerRow);
               slice_map += tex_xfer->stride;
            }
         }
         map += tex_xfer->layer_stride;
a1121 4
   else {
      /* format translation via floats */
      GLuint row, slice;
      GLfloat *rgba;
d1123 35
a1157 1
      assert(util_format_is_compressed(src->format));
d1159 10
a1168 3
      rgba = malloc(width * 4 * sizeof(GLfloat));
      if (!rgba) {
         goto end;
d1170 66
a1236 2
      if (ST_DEBUG & DEBUG_FALLBACK)
         debug_printf("%s: fallback format translation\n", __FUNCTION__);
d1238 18
a1255 12
      for (slice = 0; slice < depth; slice++) {
         if (gl_target == GL_TEXTURE_1D_ARRAY) {
            /* 1D array textures.
             * We need to convert gallium coords to GL coords.
             */
            GLvoid *dest = _mesa_image_address3d(&ctx->Pack, pixels,
                                                 width, depth, format,
                                                 type, 0, slice, 0);

            /* get float[4] rgba row from surface */
            pipe_get_tile_rgba_format(tex_xfer, map, 0, 0, width, 1,
                                      dst_format, rgba);
d1257 13
a1269 19
            _mesa_pack_rgba_span_float(ctx, width, (GLfloat (*)[4]) rgba, format,
                                       type, dest, &ctx->Pack, 0);
         }
         else {
            for (row = 0; row < height; row++) {
               GLvoid *dest = _mesa_image_address3d(&ctx->Pack, pixels,
                                                    width, height, format,
                                                    type, slice, row, 0);

               /* get float[4] rgba row from surface */
               pipe_get_tile_rgba_format(tex_xfer, map, 0, row, width, 1,
                                         dst_format, rgba);

               _mesa_pack_rgba_span_float(ctx, width, (GLfloat (*)[4]) rgba, format,
                                          type, dest, &ctx->Pack, 0);
            }
         }
         map += tex_xfer->layer_stride;
      }
d1271 3
a1273 1
      free(rgba);
a1274 1
   done = TRUE;
d1276 2
a1277 3
end:
   if (map)
      pipe_transfer_unmap(pipe, tex_xfer);
d1279 6
a1284 2
   _mesa_unmap_pbo_dest(ctx, &ctx->Pack);
   pipe_resource_reference(&dst, NULL);
d1286 3
a1288 3
fallback:
   if (!done) {
      _mesa_get_teximage(ctx, format, type, pixels, texImage);
d1293 14
d1315 1
a1315 1
fallback_copy_texsubimage(struct gl_context *ctx,
d1319 1
a1319 1
                          GLint destX, GLint destY, GLint slice,
d1326 1
a1326 1
   GLubyte *texDest;
a1327 4
   void *map;
   unsigned dst_width = width;
   unsigned dst_height = height;
   unsigned dst_depth = 1;
d1332 2
d1338 6
a1343 7
   map = pipe_transfer_map(pipe,
                           strb->texture,
                           strb->rtt_level,
                           strb->rtt_face + strb->rtt_slice,
                           PIPE_TRANSFER_READ,
                           srcX, srcY,
                           width, height, &src_trans);
d1352 3
a1354 3
   texDest = st_texture_image_map(st, stImage, transfer_usage,
                                  destX, destY, slice,
                                  dst_width, dst_height, dst_depth);
a1360 1
      uint *data;
d1372 6
a1377 19
      data = malloc(width * sizeof(uint));

      if (data) {
         /* To avoid a large temp memory allocation, do copy row by row */
         for (row = 0; row < height; row++, srcY += yStep) {
            pipe_get_tile_z(src_trans, map, 0, srcY, width, 1, data);
            if (scaleOrBias) {
               _mesa_scale_and_bias_depth_uint(ctx, width, data);
            }

            if (stImage->pt->target == PIPE_TEXTURE_1D_ARRAY) {
               pipe_put_tile_z(stImage->transfer,
                               texDest + row*stImage->transfer->layer_stride,
                               0, 0, width, 1, data);
            }
            else {
               pipe_put_tile_z(stImage->transfer, texDest, 0, row, width, 1,
                               data);
            }
d1379 1
a1380 5
      else {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage()");
      }

      free(data);
d1385 1
a1385 1
         malloc(width * height * 4 * sizeof(GLfloat));
d1389 1
a1389 1
         GLint dstRowStride;
a1396 7
         if (stImage->pt->target == PIPE_TEXTURE_1D_ARRAY) {
            dstRowStride = stImage->transfer->layer_stride;
         }
         else {
            dstRowStride = stImage->transfer->stride;
         }

d1401 1
a1401 3
         pipe_get_tile_rgba_format(src_trans, map, 0, 0, width, height,
                                   util_format_linear(strb->texture->format),
                                   tempSrc);
d1412 2
d1415 1
a1415 1
                        &texDest,
d1424 2
a1425 1
      free(tempSrc);
d1429 1
a1429 1
   pipe->transfer_unmap(pipe, src_trans);
d1433 67
d1508 12
a1519 6
st_CopyTexSubImage(struct gl_context *ctx, GLuint dims,
                   struct gl_texture_image *texImage,
                   GLint destX, GLint destY, GLint slice,
                   struct gl_renderbuffer *rb,
                   GLint srcX, GLint srcY, GLsizei width, GLsizei height)
{
d1521 3
a1523 2
   struct st_texture_object *stObj = st_texture_object(texImage->TexObject);
   struct st_renderbuffer *strb = st_renderbuffer(rb);
d1527 5
a1531 2
   struct pipe_blit_info blit;
   enum pipe_format dst_format;
d1533 17
a1549 2
   unsigned bind;
   GLint srcY0, srcY1;
d1556 10
a1565 3
   if (_mesa_texstore_needs_transfer_ops(ctx, texImage->_BaseFormat,
                                         texImage->TexFormat)) {
      goto fallback;
d1568 4
a1571 7
   /* The base internal format must match the mesa format, so make sure
    * e.g. an RGB internal format is really allocated as RGB and not as RGBA.
    */
   if (texImage->_BaseFormat !=
       _mesa_get_format_base_format(texImage->TexFormat) ||
       rb->_BaseFormat != _mesa_get_format_base_format(rb->Format)) {
      goto fallback;
d1574 5
a1578 4
   /* Choose the destination format to match the TexImage behavior. */
   dst_format = util_format_linear(stImage->pt->format);
   dst_format = util_format_luminance_to_red(dst_format);
   dst_format = util_format_intensity_to_red(dst_format);
d1580 4
a1583 4
   /* See if the destination format is supported. */
   if (texImage->_BaseFormat == GL_DEPTH_STENCIL ||
       texImage->_BaseFormat == GL_DEPTH_COMPONENT) {
      bind = PIPE_BIND_DEPTH_STENCIL;
d1585 109
a1693 2
   else {
      bind = PIPE_BIND_RENDER_TARGET;
d1696 6
a1701 4
   if (!dst_format ||
       !screen->is_format_supported(screen, dst_format, stImage->pt->target,
                                    stImage->pt->nr_samples, bind)) {
      goto fallback;
d1703 3
d1707 38
a1744 9
   /* Y flipping for the main framebuffer. */
   if (do_flip) {
      srcY1 = strb->Base.Height - srcY - height;
      srcY0 = srcY1 + height;
   }
   else {
      srcY0 = srcY;
      srcY1 = srcY0 + height;
   }
d1746 2
a1747 2
   /* Blit the texture.
    * This supports flipping, format conversions, and downsampling.
d1749 43
a1791 30
   memset(&blit, 0, sizeof(blit));
   blit.src.resource = strb->texture;
   blit.src.format = util_format_linear(strb->surface->format);
   blit.src.level = strb->surface->u.tex.level;
   blit.src.box.x = srcX;
   blit.src.box.y = srcY0;
   blit.src.box.z = strb->surface->u.tex.first_layer;
   blit.src.box.width = width;
   blit.src.box.height = srcY1 - srcY0;
   blit.src.box.depth = 1;
   blit.dst.resource = stImage->pt;
   blit.dst.format = dst_format;
   blit.dst.level = stObj->pt != stImage->pt ? 0 : texImage->Level;
   blit.dst.box.x = destX;
   blit.dst.box.y = destY;
   blit.dst.box.z = stImage->base.Face + slice;
   blit.dst.box.width = width;
   blit.dst.box.height = height;
   blit.dst.box.depth = 1;
   blit.mask = st_get_blit_mask(rb->_BaseFormat, texImage->_BaseFormat);
   blit.filter = PIPE_TEX_FILTER_NEAREST;
   pipe->blit(pipe, &blit);
   return;

fallback:
   /* software fallback */
   fallback_copy_texsubimage(ctx,
                             strb, stImage, texImage->_BaseFormat,
                             destX, destY, slice,
                             srcX, srcY, width, height);
d1808 1
a1808 1
         stObj->base.Image[stImage->base.Face][dstLevel];
a1817 14
      GLuint src_level;
      if (stImage->pt->last_level == 0)
         src_level = 0;
      else
         src_level = stImage->base.Level;

      assert(src_level <= stImage->pt->last_level);
      assert(u_minify(stImage->pt->width0, src_level) == stImage->base.Width);
      assert(stImage->pt->target == PIPE_TEXTURE_1D_ARRAY ||
             u_minify(stImage->pt->height0, src_level) == stImage->base.Height);
      assert(stImage->pt->target == PIPE_TEXTURE_2D_ARRAY ||
             stImage->pt->target == PIPE_TEXTURE_CUBE_ARRAY ||
             u_minify(stImage->pt->depth0, src_level) == stImage->base.Depth);

d1820 2
a1821 2
                            stImage->pt, src_level, /* src texture, level */
                            stImage->base.Face);
d1825 1
a1825 6
   else if (stImage->TexData) {
      /* Copy from malloc'd memory */
      /* XXX this should be re-examined/tested with a compressed format */
      GLuint blockSize = util_format_get_blocksize(stObj->pt->format);
      GLuint srcRowStride = stImage->base.Width * blockSize;
      GLuint srcSliceStride = stImage->base.Height * srcRowStride;
d1828 1
a1828 1
                            stImage->base.Face,
d1830 8
a1837 5
                            stImage->TexData,
                            srcRowStride,
                            srcSliceStride);
      _mesa_align_free(stImage->TexData);
      stImage->TexData = NULL;
a1859 1
   GLuint ptWidth, ptHeight, ptDepth, ptLayers, ptNumSamples;
d1861 1
a1861 1
   if (_mesa_is_texture_complete(tObj, &tObj->Sampler)) {
d1868 2
a1869 2
      if (stObj->base.Sampler.MinFilter == GL_LINEAR ||
          stObj->base.Sampler.MinFilter == GL_NEAREST)
a1874 14
   if (tObj->Target == GL_TEXTURE_BUFFER) {
      struct st_buffer_object *st_obj = st_buffer_object(tObj->BufferObject);

      if (st_obj->buffer != stObj->pt) {
         pipe_resource_reference(&stObj->pt, st_obj->buffer);
         pipe_sampler_view_release(st->pipe, &stObj->sampler_view);
         stObj->width0 = stObj->pt->width0 / _mesa_get_format_bytes(tObj->_BufferObjectFormat);
         stObj->height0 = 1;
         stObj->depth0 = 1;
      }
      return GL_TRUE;

   }

d1887 1
a1887 6
      pipe_sampler_view_release(st->pipe, &stObj->sampler_view);
   }

   /* If this texture comes from a window system, there is nothing else to do. */
   if (stObj->surface_based) {
      return GL_TRUE;
a1892 19
   /* Find size of level=0 Gallium mipmap image, plus number of texture layers */
   {
      GLuint width, height, depth;
      if (!guess_base_level_size(stObj->base.Target,
                                 firstImage->base.Width2,
                                 firstImage->base.Height2,
                                 firstImage->base.Depth2,
                                 firstImage->base.Level,
                                 &width, &height, &depth)) {
         width = stObj->width0;
         height = stObj->height0;
         depth = stObj->depth0;
      }
      /* convert GL dims to Gallium dims */
      st_gl_texture_dims_to_pipe_dims(stObj->base.Target, width, height, depth,
                                      &ptWidth, &ptHeight, &ptDepth, &ptLayers);
      ptNumSamples = firstImage->base.NumSamples;
   }

d1898 1
a1898 1
          stObj->pt->format != firstImageFormat ||
d1900 3
a1902 5
          stObj->pt->width0 != ptWidth ||
          stObj->pt->height0 != ptHeight ||
          stObj->pt->depth0 != ptDepth ||
          stObj->pt->nr_samples != ptNumSamples ||
          stObj->pt->array_size != ptLayers)
d1908 1
a1908 1
         pipe_sampler_view_release(st->pipe, &stObj->sampler_view);
d1922 3
a1924 4
                                    ptWidth,
                                    ptHeight,
                                    ptDepth,
                                    ptLayers, ptNumSamples,
d1944 1
a1944 7
            if (level == 0 ||
                (stImage->base.Width == u_minify(stObj->width0, level) &&
                 stImage->base.Height == u_minify(stObj->height0, level) &&
                 stImage->base.Depth == u_minify(stObj->depth0, level))) {
               /* src image fits expected dest mipmap level size */
               copy_image_data_to_texture(st, stObj, level, stImage);
            }
d1954 3
a1956 2
 * Called via ctx->Driver.AllocTextureStorage() to allocate texture memory
 * for a whole mipmap stack.
d1958 2
a1959 5
static GLboolean
st_AllocTextureStorage(struct gl_context *ctx,
                       struct gl_texture_object *texObj,
                       GLsizei levels, GLsizei width,
                       GLsizei height, GLsizei depth)
d1961 6
a1966 9
   const GLuint numFaces = _mesa_num_tex_faces(texObj->Target);
   struct gl_texture_image *texImage = texObj->Image[0][0];
   struct st_context *st = st_context(ctx);
   struct st_texture_object *stObj = st_texture_object(texObj);
   struct pipe_screen *screen = st->pipe->screen;
   GLuint ptWidth, ptHeight, ptDepth, ptLayers, bindings;
   enum pipe_format fmt;
   GLint level;
   GLuint num_samples = texImage->NumSamples;
d1968 9
a1976 24
   assert(levels > 0);

   /* Save the level=0 dimensions */
   stObj->width0 = width;
   stObj->height0 = height;
   stObj->depth0 = depth;
   stObj->lastLevel = levels - 1;

   fmt = st_mesa_format_to_pipe_format(texImage->TexFormat);

   bindings = default_bindings(st, fmt);

   /* Raise the sample count if the requested one is unsupported. */
   if (num_samples > 1) {
      boolean found = FALSE;

      for (; num_samples <= ctx->Const.MaxSamples; num_samples++) {
         if (screen->is_format_supported(screen, fmt, PIPE_TEXTURE_2D,
                                         num_samples,
                                         PIPE_BIND_SAMPLER_VIEW)) {
            /* Update the sample count in gl_texture_image as well. */
            texImage->NumSamples = num_samples;
            found = TRUE;
            break;
d1980 1
a1980 20
      if (!found) {
         return GL_FALSE;
      }
   }

   st_gl_texture_dims_to_pipe_dims(texObj->Target,
                                   width, height, depth,
                                   &ptWidth, &ptHeight, &ptDepth, &ptLayers);

   stObj->pt = st_texture_create(st,
                                 gl_target_to_pipe(texObj->Target),
                                 fmt,
                                 levels - 1,
                                 ptWidth,
                                 ptHeight,
                                 ptDepth,
                                 ptLayers, num_samples,
                                 bindings);
   if (!stObj->pt)
      return GL_FALSE;
d1982 1
a1982 9
   /* Set image resource pointers */
   for (level = 0; level < levels; level++) {
      GLuint face;
      for (face = 0; face < numFaces; face++) {
         struct st_texture_image *stImage =
            st_texture_image(texObj->Image[face][level]);
         pipe_resource_reference(&stImage->pt, stObj->pt);
      }
   }
d1984 3
a1986 2
   return GL_TRUE;
}
d1988 7
d1996 3
a1998 8
static GLboolean
st_TestProxyTexImage(struct gl_context *ctx, GLenum target,
                     GLint level, gl_format format,
                     GLint width, GLint height,
                     GLint depth, GLint border)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
d2000 1
a2000 39
   if (width == 0 || height == 0 || depth == 0) {
      /* zero-sized images are legal, and always fit! */
      return GL_TRUE;
   }

   if (pipe->screen->can_create_resource) {
      /* Ask the gallium driver if the texture is too large */
      struct gl_texture_object *texObj =
         _mesa_get_current_tex_object(ctx, target);
      struct pipe_resource pt;

      /* Setup the pipe_resource object
       */
      memset(&pt, 0, sizeof(pt));

      pt.target = gl_target_to_pipe(target);
      pt.format = st_mesa_format_to_pipe_format(format);

      st_gl_texture_dims_to_pipe_dims(target,
                                      width, height, depth,
                                      &pt.width0, &pt.height0,
                                      &pt.depth0, &pt.array_size);

      if (level == 0 && (texObj->Sampler.MinFilter == GL_LINEAR ||
                         texObj->Sampler.MinFilter == GL_NEAREST)) {
         /* assume just one mipmap level */
         pt.last_level = 0;
      }
      else {
         /* assume a full set of mipmaps */
         pt.last_level = _mesa_logbase2(MAX3(width, height, depth));
      }

      return pipe->screen->can_create_resource(pipe->screen, &pt);
   }
   else {
      /* Use core Mesa fallback */
      return _mesa_test_proxy_teximage(ctx, target, level, format,
                                       width, height, depth, border);
d2002 1
d2010 14
a2023 5
   functions->QuerySamplesForFormat = st_QuerySamplesForFormat;
   functions->TexImage = st_TexImage;
   functions->TexSubImage = st_TexSubImage;
   functions->CompressedTexSubImage = _mesa_store_compressed_texsubimage;
   functions->CopyTexSubImage = st_CopyTexSubImage;
d2029 2
a2030 2
   functions->CompressedTexImage = st_CompressedTexImage;
   functions->GetCompressedTexImage = _mesa_get_compressed_teximage;
a2033 1
   functions->DeleteTextureImage = st_DeleteTextureImage;
d2035 3
a2037 4
   functions->AllocTextureImageBuffer = st_AllocTextureImageBuffer;
   functions->FreeTextureImageBuffer = st_FreeTextureImageBuffer;
   functions->MapTextureImage = st_MapTextureImage;
   functions->UnmapTextureImage = st_UnmapTextureImage;
d2040 1
a2040 3
   functions->TestProxyTexImage = st_TestProxyTexImage;

   functions->AllocTextureStorage = st_AllocTextureStorage;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d154 1
d156 5
a160 4

   pipe_resource_reference(&stObj->pt, NULL);
   st_texture_release_all_sampler_views(stObj);
   st_texture_free_sampler_views(stObj);
d178 4
a181 6
   _mesa_align_free(stImage->TexData);
   stImage->TexData = NULL;

   free(stImage->transfer);
   stImage->transfer = NULL;
   stImage->num_transfers = 0;
a196 1
   struct pipe_transfer *transfer;
d206 1
a206 2
   map = st_texture_image_map(st, stImage, pipeMode, x, y, slice, w, h, 1,
                              &transfer);
d209 1
a209 1
      *rowStrideOut = transfer->stride;
d226 1
a226 1
   st_texture_image_unmap(st, stImage, slice);
d459 1
a459 1
   st_texture_release_all_sampler_views(stObj);
d524 1
a524 1
      mesa_format texFormat;
d609 1
a609 1
   mesa_format mesa_src_format;
a765 1
   memset(&blit, 0, sizeof(blit));
d861 1
a861 1
   mesa_format mesa_format;
d870 1
a870 3
   if (!st->prefer_blit_based_texture_transfer &&
       !_mesa_is_format_compressed(texImage->TexFormat)) {
      /* Try to avoid the fallback if we're doing texture decompression here */
a996 1
   memset(&blit, 0, sizeof(blit));
a1148 1
   struct pipe_transfer *transfer;
d1159 2
a1160 2
                           strb->surface->u.tex.level,
                           strb->surface->u.tex.first_layer,
d1174 1
a1174 2
                                  dst_width, dst_height, dst_depth,
                                  &transfer);
d1204 2
a1205 1
               pipe_put_tile_z(transfer, texDest + row*transfer->layer_stride,
d1209 2
a1210 1
               pipe_put_tile_z(transfer, texDest, 0, row, width, 1, data);
d1236 1
a1236 1
            dstRowStride = transfer->layer_stride;
d1239 1
a1239 1
            dstRowStride = transfer->stride;
d1272 1
a1272 1
   st_texture_image_unmap(st, stImage, slice);
a1487 6
      if (!st_obj) {
         pipe_resource_reference(&stObj->pt, NULL);
         st_texture_release_all_sampler_views(stObj);
         return GL_TRUE;
      }

d1490 1
a1490 1
         st_texture_release_all_sampler_views(stObj);
d1511 1
a1511 1
      st_texture_release_all_sampler_views(stObj);
d1558 1
a1558 1
         st_texture_release_all_sampler_views(stObj);
d1694 1
a1694 1
                     GLint level, mesa_format format,
@


1.1.1.4
log
@Import Mesa 10.2.7
@
text
@a721 2
      zoffset = yoffset;
      yoffset = 0;
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@a39 1
#include "main/texcompress_etc.h"
a153 1
   struct st_context *st = st_context(ctx);
d157 1
a157 1
   st_texture_release_all_sampler_views(st, stObj);
d210 2
a211 26
      if (_mesa_is_format_etc2(texImage->TexFormat) ||
          (texImage->TexFormat == MESA_FORMAT_ETC1_RGB8 && !st->has_etc1)) {
         /* ETC isn't supported by gallium and it's represented
          * by uncompressed formats. Only write transfers with precompressed
          * data are supported by ES3, which makes this really simple.
          *
          * Just create a temporary storage where the ETC texture will
          * be stored. It will be decompressed in the Unmap function.
          */
         unsigned z = transfer->box.z;
         struct st_texture_image_transfer *itransfer = &stImage->transfer[z];

         itransfer->temp_data =
            malloc(_mesa_format_image_size(texImage->TexFormat, w, h, 1));
         itransfer->temp_stride =
            _mesa_format_row_stride(texImage->TexFormat, w);
         itransfer->map = map;

         *mapOut = itransfer->temp_data;
         *rowStrideOut = itransfer->temp_stride;
      }
      else {
         /* supported mapping */
         *mapOut = map;
         *rowStrideOut = transfer->stride;
      }
a227 29

   if (_mesa_is_format_etc2(texImage->TexFormat) ||
       (texImage->TexFormat == MESA_FORMAT_ETC1_RGB8 && !st->has_etc1)) {
      /* Decompress the ETC texture to the mapped one. */
      unsigned z = slice + stImage->base.Face;
      struct st_texture_image_transfer *itransfer = &stImage->transfer[z];
      struct pipe_transfer *transfer = itransfer->transfer;

      assert(z == transfer->box.z);

      if (texImage->TexFormat == MESA_FORMAT_ETC1_RGB8) {
         _mesa_etc1_unpack_rgba8888(itransfer->map, transfer->stride,
                                    itransfer->temp_data,
                                    itransfer->temp_stride,
                                    transfer->box.width, transfer->box.height);
      }
      else {
         _mesa_unpack_etc2_format(itransfer->map, transfer->stride,
                                  itransfer->temp_data, itransfer->temp_stride,
                                  transfer->box.width, transfer->box.height,
                                  texImage->TexFormat);
      }

      free(itransfer->temp_data);
      itransfer->temp_data = NULL;
      itransfer->temp_stride = 0;
      itransfer->map = 0;
   }

d401 1
a401 1
   fmt = st_mesa_format_to_pipe_format(st, stImage->base.TexFormat);
d452 1
a452 1
       st_texture_match_image(st, stObj->pt, texImage)) {
d461 1
a461 1
   st_texture_release_all_sampler_views(st, stObj);
d475 1
a475 1
       st_texture_match_image(st, stObj->pt, texImage)) {
d489 1
a489 1
         st_mesa_format_to_pipe_format(st, texImage->TexFormat);
a615 3
   assert(!_mesa_is_format_etc2(texImage->TexFormat) &&
          texImage->TexFormat != MESA_FORMAT_ETC1_RGB8);

d663 1
a663 1
   src_format = st_choose_matching_format(st, PIPE_BIND_SAMPLER_VIEW,
d775 1
a775 1
   blit.dst.level = stObj->pt != stImage->pt ? 0 : texImage->TexObject->MinLevel + texImage->Level;
d780 1
a780 1
   blit.dst.box.z = zoffset + texImage->Face + texImage->TexObject->MinLayer;
d862 1
a862 2
   struct st_texture_object *stObj = st_texture_object(texImage->TexObject);
   struct pipe_resource *src = stObj->pt;
a874 3
   assert(!_mesa_is_format_etc2(texImage->TexFormat) &&
          texImage->TexFormat != MESA_FORMAT_ETC1_RGB8);

d913 1
a913 4
   if (stObj->surface_based)
      src_format = util_format_linear(stObj->surface_format);
   else
      src_format = util_format_linear(src->format);
d937 1
a937 1
   dst_format = st_choose_matching_format(st, bind, format, type,
a958 1
      case PIPE_FORMAT_BPTC_RGBA_UNORM:
d967 1
a967 6
      case PIPE_FORMAT_BPTC_RGB_FLOAT:
      case PIPE_FORMAT_BPTC_RGB_UFLOAT:
         if (!ctx->Extensions.ARB_texture_float)
            goto fallback;
         dst_glformat = GL_RGBA32F;
         break;
d1006 1
a1006 1
   blit.src.level = texImage->Level + texImage->TexObject->MinLevel;
d1013 1
a1013 1
   blit.src.box.z = texImage->Face + texImage->TexObject->MinLayer;
a1310 3
   assert(!_mesa_is_format_etc2(texImage->TexFormat) &&
          texImage->TexFormat != MESA_FORMAT_ETC1_RGB8);

d1375 1
a1375 1
   blit.dst.level = stObj->pt != stImage->pt ? 0 : texImage->Level + texImage->TexObject->MinLevel;
d1378 1
a1378 1
   blit.dst.box.z = stImage->base.Face + slice + texImage->TexObject->MinLayer;
a1478 3
   if (tObj->Immutable)
      return GL_TRUE;

d1498 1
a1498 1
         st_texture_release_all_sampler_views(st, stObj);
d1504 1
a1504 1
         st_texture_release_all_sampler_views(st, stObj);
d1525 1
a1525 1
      st_texture_release_all_sampler_views(st, stObj);
d1534 1
a1534 2
   firstImageFormat =
      st_mesa_format_to_pipe_format(st, firstImage->base.TexFormat);
d1572 1
a1572 1
         st_texture_release_all_sampler_views(st, stObj);
d1652 1
a1652 1
   fmt = st_mesa_format_to_pipe_format(st, texImage->TexFormat);
d1731 1
a1731 1
      pt.format = st_mesa_format_to_pipe_format(st, format);
a1756 38
static GLboolean
st_TextureView(struct gl_context *ctx,
               struct gl_texture_object *texObj,
               struct gl_texture_object *origTexObj)
{
   struct st_texture_object *orig = st_texture_object(origTexObj);
   struct st_texture_object *tex = st_texture_object(texObj);
   struct gl_texture_image *image = texObj->Image[0][0];

   const int numFaces = _mesa_num_tex_faces(texObj->Target);
   const int numLevels = texObj->NumLevels;

   int face;
   int level;

   pipe_resource_reference(&tex->pt, orig->pt);

   /* Set image resource pointers */
   for (level = 0; level < numLevels; level++) {
      for (face = 0; face < numFaces; face++) {
         struct st_texture_image *stImage =
            st_texture_image(texObj->Image[face][level]);
         pipe_resource_reference(&stImage->pt, tex->pt);
      }
   }

   tex->surface_based = GL_TRUE;
   tex->surface_format =
      st_mesa_format_to_pipe_format(st_context(ctx), image->TexFormat);

   tex->width0 = image->Width;
   tex->height0 = image->Height;
   tex->depth0 = image->Depth;
   tex->lastLevel = numLevels - 1;

   return GL_TRUE;
}

a1787 1
   functions->TextureView = st_TextureView;
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d40 1
d155 1
d159 1
a159 1
   st_texture_release_all_sampler_views(stObj);
d212 26
a237 2
      *mapOut = map;
      *rowStrideOut = transfer->stride;
d254 29
d456 1
a456 1
   fmt = st_mesa_format_to_pipe_format(stImage->base.TexFormat);
d507 1
a507 1
       st_texture_match_image(stObj->pt, texImage)) {
d516 1
a516 1
   st_texture_release_all_sampler_views(stObj);
d530 1
a530 1
       st_texture_match_image(stObj->pt, texImage)) {
d544 1
a544 1
         st_mesa_format_to_pipe_format(texImage->TexFormat);
d671 3
d721 1
a721 1
   src_format = st_choose_matching_format(screen, PIPE_BIND_SAMPLER_VIEW,
d833 1
a833 1
   blit.dst.level = stObj->pt != stImage->pt ? 0 : texImage->Level;
d838 1
a838 1
   blit.dst.box.z = zoffset + texImage->Face;
d920 2
a921 1
   struct pipe_resource *src = st_texture_object(texImage->TexObject)->pt;
d934 3
d975 4
a978 1
   src_format = util_format_linear(src->format);
d1002 1
a1002 1
   dst_format = st_choose_matching_format(screen, bind, format, type,
d1024 1
d1033 6
a1038 1
      /* TODO: for BPTC_*FLOAT, set RGBA32F and check for ARB_texture_float */
d1077 1
a1077 1
   blit.src.level = texImage->Level;
d1084 1
a1084 1
   blit.src.box.z = texImage->Face;
d1382 3
d1449 1
a1449 1
   blit.dst.level = stObj->pt != stImage->pt ? 0 : texImage->Level;
d1452 1
a1452 1
   blit.dst.box.z = stImage->base.Face + slice;
d1553 3
d1575 1
a1575 1
         st_texture_release_all_sampler_views(stObj);
d1581 1
a1581 1
         st_texture_release_all_sampler_views(stObj);
d1602 1
a1602 1
      st_texture_release_all_sampler_views(stObj);
d1611 2
a1612 1
   firstImageFormat = st_mesa_format_to_pipe_format(firstImage->base.TexFormat);
d1650 1
a1650 1
         st_texture_release_all_sampler_views(stObj);
d1730 1
a1730 1
   fmt = st_mesa_format_to_pipe_format(texImage->TexFormat);
d1809 1
a1809 1
      pt.format = st_mesa_format_to_pipe_format(format);
d1835 38
d1904 1
@


