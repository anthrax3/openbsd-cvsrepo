head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.11.24.06.19.52;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.09.05.14.06.45;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.23;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.11.24.06.03.15;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.35.11;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.13.20;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.50.26;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

/*
 * This file implements the st_draw_vbo() function which is called from
 * Mesa's VBO module.  All point/line/triangle rendering is done through
 * this function whether the user called glBegin/End, glDrawArrays,
 * glDrawElements, glEvalMesh, or glCalList, etc.
 *
 * Authors:
 *   Keith Whitwell <keithw@@vmware.com>
 */


#include "main/imports.h"
#include "main/image.h"
#include "main/bufferobj.h"
#include "main/macros.h"

#include "vbo/vbo.h"

#include "st_context.h"
#include "st_atom.h"
#include "st_cb_bufferobjects.h"
#include "st_cb_xformfb.h"
#include "st_debug.h"
#include "st_draw.h"
#include "st_program.h"

#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "util/u_inlines.h"
#include "util/u_format.h"
#include "util/u_prim.h"
#include "util/u_draw_quad.h"
#include "util/u_upload_mgr.h"
#include "draw/draw_context.h"
#include "cso_cache/cso_context.h"

#include "../glsl/ir_uniform.h"


/**
 * This is very similar to vbo_all_varyings_in_vbos() but we are
 * only interested in per-vertex data.  See bug 38626.
 */
static GLboolean
all_varyings_in_vbos(const struct gl_client_array *arrays[])
{
   GLuint i;

   for (i = 0; i < VERT_ATTRIB_MAX; i++)
      if (arrays[i]->StrideB &&
          !arrays[i]->InstanceDivisor &&
          !_mesa_is_bufferobj(arrays[i]->BufferObj))
	 return GL_FALSE;

   return GL_TRUE;
}


/**
 * Basically, translate Mesa's index buffer information into
 * a pipe_index_buffer object.
 * \return TRUE or FALSE for success/failure
 */
static boolean
setup_index_buffer(struct st_context *st,
                   const struct _mesa_index_buffer *ib,
                   struct pipe_index_buffer *ibuffer)
{
   struct gl_buffer_object *bufobj = ib->obj;

   ibuffer->index_size = vbo_sizeof_ib_type(ib->type);

   /* get/create the index buffer object */
   if (_mesa_is_bufferobj(bufobj)) {
      /* indices are in a real VBO */
      ibuffer->buffer = st_buffer_object(bufobj)->buffer;
      ibuffer->offset = pointer_to_offset(ib->ptr);
   }
   else if (st->indexbuf_uploader) {
      /* upload indexes from user memory into a real buffer */
      if (u_upload_data(st->indexbuf_uploader, 0,
                        ib->count * ibuffer->index_size, ib->ptr,
                        &ibuffer->offset, &ibuffer->buffer) != PIPE_OK) {
         /* out of memory */
         return FALSE;
      }
      u_upload_unmap(st->indexbuf_uploader);
   }
   else {
      /* indices are in user space memory */
      ibuffer->user_buffer = ib->ptr;
   }

   cso_set_index_buffer(st->cso_context, ibuffer);
   return TRUE;
}


/**
 * Prior to drawing, check that any uniforms referenced by the
 * current shader have been set.  If a uniform has not been set,
 * issue a warning.
 */
static void
check_uniforms(struct gl_context *ctx)
{
   struct gl_shader_program **shProg = ctx->_Shader->CurrentProgram;
   unsigned j;

   for (j = 0; j < 3; j++) {
      unsigned i;

      if (shProg[j] == NULL || !shProg[j]->LinkStatus)
	 continue;

      for (i = 0; i < shProg[j]->NumUserUniformStorage; i++) {
         const struct gl_uniform_storage *u = &shProg[j]->UniformStorage[i];
         if (!u->initialized) {
            _mesa_warning(ctx,
                          "Using shader with uninitialized uniform: %s",
                          u->name);
         }
      }
   }
}


/**
 * Translate OpenGL primtive type (GL_POINTS, GL_TRIANGLE_STRIP, etc) to
 * the corresponding Gallium type.
 */
static unsigned
translate_prim(const struct gl_context *ctx, unsigned prim)
{
   /* GL prims should match Gallium prims, spot-check a few */
   STATIC_ASSERT(GL_POINTS == PIPE_PRIM_POINTS);
   STATIC_ASSERT(GL_QUADS == PIPE_PRIM_QUADS);
   STATIC_ASSERT(GL_TRIANGLE_STRIP_ADJACENCY == PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY);

   return prim;
}


/**
 * This function gets plugged into the VBO module and is called when
 * we have something to render.
 * Basically, translate the information into the format expected by gallium.
 */
void
st_draw_vbo(struct gl_context *ctx,
            const struct _mesa_prim *prims,
            GLuint nr_prims,
            const struct _mesa_index_buffer *ib,
	    GLboolean index_bounds_valid,
            GLuint min_index,
            GLuint max_index,
            struct gl_transform_feedback_object *tfb_vertcount,
            struct gl_buffer_object *indirect)
{
   struct st_context *st = st_context(ctx);
   struct pipe_index_buffer ibuffer = {0};
   struct pipe_draw_info info;
   const struct gl_client_array **arrays = ctx->Array._DrawArrays;
   unsigned i;

   /* Mesa core state should have been validated already */
   assert(ctx->NewState == 0x0);

   /* Validate state. */
   if (st->dirty.st || ctx->NewDriverState) {
      st_validate_state(st);

#if 0
      if (MESA_VERBOSE & VERBOSE_GLSL) {
         check_uniforms(ctx);
      }
#else
      (void) check_uniforms;
#endif
   }

   if (st->vertex_array_out_of_memory) {
      return;
   }

   util_draw_init_info(&info);

   if (ib) {
      /* Get index bounds for user buffers. */
      if (!index_bounds_valid)
         if (!all_varyings_in_vbos(arrays))
            vbo_get_minmax_indices(ctx, prims, ib, &min_index, &max_index,
                                   nr_prims);

      if (!setup_index_buffer(st, ib, &ibuffer)) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBegin/DrawElements/DrawArray");
         return;
      }

      info.indexed = TRUE;
      if (min_index != ~0 && max_index != ~0) {
         info.min_index = min_index;
         info.max_index = max_index;
      }

      /* The VBO module handles restart for the non-indexed GLDrawArrays
       * so we only set these fields for indexed drawing:
       */
      info.primitive_restart = ctx->Array._PrimitiveRestart;
      info.restart_index = ctx->Array.RestartIndex;
   }
   else {
      /* Transform feedback drawing is always non-indexed. */
      /* Set info.count_from_stream_output. */
      if (tfb_vertcount) {
         st_transform_feedback_draw_init(tfb_vertcount, &info);
      }
   }

   /* do actual drawing */
   for (i = 0; i < nr_prims; i++) {
      info.mode = translate_prim(ctx, prims[i].mode);
      info.start = prims[i].start;
      info.count = prims[i].count;
      info.start_instance = prims[i].base_instance;
      info.instance_count = prims[i].num_instances;
      info.index_bias = prims[i].basevertex;
      if (!ib) {
         info.min_index = info.start;
         info.max_index = info.start + info.count - 1;
      }

      if (ST_DEBUG & DEBUG_DRAW) {
         debug_printf("st/draw: mode %s  start %u  count %u  indexed %d\n",
                      u_prim_name(info.mode),
                      info.start,
                      info.count,
                      info.indexed);
      }

      if (info.count_from_stream_output) {
         cso_draw_vbo(st->cso_context, &info);
      }
      else if (info.primitive_restart) {
         /* don't trim, restarts might be inside index list */
         cso_draw_vbo(st->cso_context, &info);
      }
      else if (u_trim_pipe_prim(prims[i].mode, &info.count)) {
         cso_draw_vbo(st->cso_context, &info);
      }
   }

   if (ib && st->indexbuf_uploader && !_mesa_is_bufferobj(ib->obj)) {
      pipe_resource_reference(&ibuffer.buffer, NULL);
   }
}


void
st_init_draw(struct st_context *st)
{
   struct gl_context *ctx = st->ctx;

   vbo_set_draw_func(ctx, st_draw_vbo);

   st->draw = draw_create(st->pipe); /* for selection/feedback */

   /* Disable draw options that might convert points/lines to tris, etc.
    * as that would foul-up feedback/selection mode.
    */
   draw_wide_line_threshold(st->draw, 1000.0f);
   draw_wide_point_threshold(st->draw, 1000.0f);
   draw_enable_line_stipple(st->draw, FALSE);
   draw_enable_point_sprites(st->draw, FALSE);
}


void
st_destroy_draw(struct st_context *st)
{
   draw_destroy(st->draw);
}
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a42 1
#include "main/varray.h"
d237 1
a237 1
      info.restart_index = _mesa_primitive_restart_index(ctx, ib->type);
a246 8
   if (indirect) {
      info.indirect = st_buffer_object(indirect)->buffer;

      /* Primitive restart is not handled by the VBO module in this case. */
      info.primitive_restart = ctx->Array._PrimitiveRestart;
      info.restart_index = ctx->Array.RestartIndex;
   }

a258 1
      info.indirect_offset = prims[i].indirect_offset;
d268 1
a268 1
      if (info.count_from_stream_output || info.indirect) {
@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d43 1
d238 1
a238 1
      info.restart_index = ctx->Array.RestartIndex;
d248 8
d268 1
d278 1
a278 1
      if (info.count_from_stream_output) {
@


1.5
log
@Merge Mesa 9.2.3
ok mpi@@ kettenis@@
@
text
@d2 2
a3 2
 * 
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d5 1
a5 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
 * 
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d25 1
a25 1
 * 
d35 1
a35 1
 *   Keith Whitwell <keith@@tungstengraphics.com>
d75 1
a75 1
   
d107 1
d134 1
a134 5
   struct gl_shader_program *shProg[3] = {
      ctx->Shader.CurrentVertexProgram,
      ctx->Shader.CurrentGeometryProgram,
      ctx->Shader.CurrentFragmentProgram,
   };
a166 10
   /* Avoid quadstrips if it's easy to do so:
    * Note: it's important to do the correct trimming if we change the
    * prim type!  We do that wherever this function is called.
    */
   if (prim == GL_QUAD_STRIP &&
       ctx->Light.ShadeModel != GL_FLAT &&
       ctx->Polygon.FrontMode == GL_FILL &&
       ctx->Polygon.BackMode == GL_FILL)
      prim = GL_TRIANGLE_STRIP;

d184 2
a185 1
            struct gl_transform_feedback_object *tfb_vertcount)
d214 1
d249 1
a249 1
      info.mode = translate_prim( ctx, prims[i].mode );
d275 1
a275 1
      else if (u_trim_pipe_prim(prims[i].mode, &info.count))
d277 1
@


1.4
log
@Merge Mesa 9.2.0
@
text
@a211 3
      if (st->vertex_array_out_of_memory)
         return;

d219 4
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a33 4
 * We basically convert the VBO's vertex attribute/array information into
 * Gallium vertex state, bind the vertex buffer objects and call
 * pipe->draw_vbo().
 *
a42 2
#include "main/mfeatures.h"
#include "program/prog_uniform.h"
d49 2
d60 1
d64 1
a64 167

static GLuint double_types[4] = {
   PIPE_FORMAT_R64_FLOAT,
   PIPE_FORMAT_R64G64_FLOAT,
   PIPE_FORMAT_R64G64B64_FLOAT,
   PIPE_FORMAT_R64G64B64A64_FLOAT
};

static GLuint float_types[4] = {
   PIPE_FORMAT_R32_FLOAT,
   PIPE_FORMAT_R32G32_FLOAT,
   PIPE_FORMAT_R32G32B32_FLOAT,
   PIPE_FORMAT_R32G32B32A32_FLOAT
};

static GLuint half_float_types[4] = {
   PIPE_FORMAT_R16_FLOAT,
   PIPE_FORMAT_R16G16_FLOAT,
   PIPE_FORMAT_R16G16B16_FLOAT,
   PIPE_FORMAT_R16G16B16A16_FLOAT
};

static GLuint uint_types_norm[4] = {
   PIPE_FORMAT_R32_UNORM,
   PIPE_FORMAT_R32G32_UNORM,
   PIPE_FORMAT_R32G32B32_UNORM,
   PIPE_FORMAT_R32G32B32A32_UNORM
};

static GLuint uint_types_scale[4] = {
   PIPE_FORMAT_R32_USCALED,
   PIPE_FORMAT_R32G32_USCALED,
   PIPE_FORMAT_R32G32B32_USCALED,
   PIPE_FORMAT_R32G32B32A32_USCALED
};

static GLuint int_types_norm[4] = {
   PIPE_FORMAT_R32_SNORM,
   PIPE_FORMAT_R32G32_SNORM,
   PIPE_FORMAT_R32G32B32_SNORM,
   PIPE_FORMAT_R32G32B32A32_SNORM
};

static GLuint int_types_scale[4] = {
   PIPE_FORMAT_R32_SSCALED,
   PIPE_FORMAT_R32G32_SSCALED,
   PIPE_FORMAT_R32G32B32_SSCALED,
   PIPE_FORMAT_R32G32B32A32_SSCALED
};

static GLuint ushort_types_norm[4] = {
   PIPE_FORMAT_R16_UNORM,
   PIPE_FORMAT_R16G16_UNORM,
   PIPE_FORMAT_R16G16B16_UNORM,
   PIPE_FORMAT_R16G16B16A16_UNORM
};

static GLuint ushort_types_scale[4] = {
   PIPE_FORMAT_R16_USCALED,
   PIPE_FORMAT_R16G16_USCALED,
   PIPE_FORMAT_R16G16B16_USCALED,
   PIPE_FORMAT_R16G16B16A16_USCALED
};

static GLuint short_types_norm[4] = {
   PIPE_FORMAT_R16_SNORM,
   PIPE_FORMAT_R16G16_SNORM,
   PIPE_FORMAT_R16G16B16_SNORM,
   PIPE_FORMAT_R16G16B16A16_SNORM
};

static GLuint short_types_scale[4] = {
   PIPE_FORMAT_R16_SSCALED,
   PIPE_FORMAT_R16G16_SSCALED,
   PIPE_FORMAT_R16G16B16_SSCALED,
   PIPE_FORMAT_R16G16B16A16_SSCALED
};

static GLuint ubyte_types_norm[4] = {
   PIPE_FORMAT_R8_UNORM,
   PIPE_FORMAT_R8G8_UNORM,
   PIPE_FORMAT_R8G8B8_UNORM,
   PIPE_FORMAT_R8G8B8A8_UNORM
};

static GLuint ubyte_types_scale[4] = {
   PIPE_FORMAT_R8_USCALED,
   PIPE_FORMAT_R8G8_USCALED,
   PIPE_FORMAT_R8G8B8_USCALED,
   PIPE_FORMAT_R8G8B8A8_USCALED
};

static GLuint byte_types_norm[4] = {
   PIPE_FORMAT_R8_SNORM,
   PIPE_FORMAT_R8G8_SNORM,
   PIPE_FORMAT_R8G8B8_SNORM,
   PIPE_FORMAT_R8G8B8A8_SNORM
};

static GLuint byte_types_scale[4] = {
   PIPE_FORMAT_R8_SSCALED,
   PIPE_FORMAT_R8G8_SSCALED,
   PIPE_FORMAT_R8G8B8_SSCALED,
   PIPE_FORMAT_R8G8B8A8_SSCALED
};

static GLuint fixed_types[4] = {
   PIPE_FORMAT_R32_FIXED,
   PIPE_FORMAT_R32G32_FIXED,
   PIPE_FORMAT_R32G32B32_FIXED,
   PIPE_FORMAT_R32G32B32A32_FIXED
};



/**
 * Return a PIPE_FORMAT_x for the given GL datatype and size.
 */
enum pipe_format
st_pipe_vertex_format(GLenum type, GLuint size, GLenum format,
                      GLboolean normalized)
{
   assert((type >= GL_BYTE && type <= GL_DOUBLE) ||
          type == GL_FIXED || type == GL_HALF_FLOAT);
   assert(size >= 1);
   assert(size <= 4);
   assert(format == GL_RGBA || format == GL_BGRA);

   if (format == GL_BGRA) {
      /* this is an odd-ball case */
      assert(type == GL_UNSIGNED_BYTE);
      assert(normalized);
      return PIPE_FORMAT_B8G8R8A8_UNORM;
   }

   if (normalized) {
      switch (type) {
      case GL_DOUBLE: return double_types[size-1];
      case GL_FLOAT: return float_types[size-1];
      case GL_HALF_FLOAT: return half_float_types[size-1];
      case GL_INT: return int_types_norm[size-1];
      case GL_SHORT: return short_types_norm[size-1];
      case GL_BYTE: return byte_types_norm[size-1];
      case GL_UNSIGNED_INT: return uint_types_norm[size-1];
      case GL_UNSIGNED_SHORT: return ushort_types_norm[size-1];
      case GL_UNSIGNED_BYTE: return ubyte_types_norm[size-1];
      case GL_FIXED: return fixed_types[size-1];
      default: assert(0); return 0;
      }
   }
   else {
      switch (type) {
      case GL_DOUBLE: return double_types[size-1];
      case GL_FLOAT: return float_types[size-1];
      case GL_HALF_FLOAT: return half_float_types[size-1];
      case GL_INT: return int_types_scale[size-1];
      case GL_SHORT: return short_types_scale[size-1];
      case GL_BYTE: return byte_types_scale[size-1];
      case GL_UNSIGNED_INT: return uint_types_scale[size-1];
      case GL_UNSIGNED_SHORT: return ushort_types_scale[size-1];
      case GL_UNSIGNED_BYTE: return ubyte_types_scale[size-1];
      case GL_FIXED: return fixed_types[size-1];
      default: assert(0); return 0;
      }
   }
   return PIPE_FORMAT_NONE; /* silence compiler warning */
}
d68 2
a69 2
 * This is very similar to vbo_all_varyings_in_vbos() but we test
 * the stride.  See bug 38626.
d77 3
a79 1
      if (arrays[i]->StrideB && !_mesa_is_bufferobj(arrays[i]->BufferObj))
d87 3
a89 2
 * Examine the active arrays to determine if we have interleaved
 * vertex arrays all living in one VBO, or all living in user space.
d91 4
a94 4
static GLboolean
is_interleaved_arrays(const struct st_vertex_program *vp,
                      const struct st_vp_variant *vpv,
                      const struct gl_client_array **arrays)
d96 1
a96 26
   GLuint attr;
   const struct gl_buffer_object *firstBufObj = NULL;
   GLint firstStride = -1;
   const GLubyte *firstPtr = NULL;
   GLboolean userSpaceBuffer = GL_FALSE;

   for (attr = 0; attr < vpv->num_inputs; attr++) {
      const GLuint mesaAttr = vp->index_to_input[attr];
      const struct gl_client_array *array = arrays[mesaAttr];
      const struct gl_buffer_object *bufObj = array->BufferObj;
      const GLsizei stride = array->StrideB; /* in bytes */

      if (attr == 0) {
         /* save info about the first array */
         firstStride = stride;
         firstPtr = array->Ptr;         
         firstBufObj = bufObj;
         userSpaceBuffer = !bufObj || !bufObj->Name;
      }
      else {
         /* check if other arrays interleave with the first, in same buffer */
         if (stride != firstStride)
            return GL_FALSE; /* strides don't match */

         if (bufObj != firstBufObj)
            return GL_FALSE; /* arrays in different VBOs */
d98 1
a98 2
         if (abs(array->Ptr - firstPtr) > firstStride)
            return GL_FALSE; /* arrays start too far apart */
d100 12
a111 2
         if ((!bufObj || !_mesa_is_bufferobj(bufObj)) != userSpaceBuffer)
            return GL_FALSE; /* mix of VBO and user-space arrays */
d113 1
d115 3
a117 34

   return GL_TRUE;
}


/**
 * Set up for drawing interleaved arrays that all live in one VBO
 * or all live in user space.
 * \param vbuffer  returns vertex buffer info
 * \param velements  returns vertex element info
 */
static void
setup_interleaved_attribs(struct gl_context *ctx,
                          const struct st_vertex_program *vp,
                          const struct st_vp_variant *vpv,
                          const struct gl_client_array **arrays,
                          struct pipe_vertex_buffer *vbuffer,
                          struct pipe_vertex_element velements[],
                          unsigned max_index,
                          unsigned num_instances)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   GLuint attr;
   const GLubyte *low_addr = NULL;

   /* Find the lowest address of the arrays we're drawing */
   if (vpv->num_inputs) {
      low_addr = arrays[vp->index_to_input[0]]->Ptr;

      for (attr = 1; attr < vpv->num_inputs; attr++) {
         const GLubyte *start = arrays[vp->index_to_input[attr]]->Ptr;
         low_addr = MIN2(low_addr, start);
      }
d120 2
a121 183
   for (attr = 0; attr < vpv->num_inputs; attr++) {
      const GLuint mesaAttr = vp->index_to_input[attr];
      const struct gl_client_array *array = arrays[mesaAttr];
      struct gl_buffer_object *bufobj = array->BufferObj;
      struct st_buffer_object *stobj = st_buffer_object(bufobj);
      unsigned src_offset = (unsigned) (array->Ptr - low_addr);
      GLuint element_size = array->_ElementSize;
      GLsizei stride = array->StrideB;

      assert(element_size == array->Size * _mesa_sizeof_type(array->Type));

      if (attr == 0) {
         if (bufobj && _mesa_is_bufferobj(bufobj)) {
            vbuffer->buffer = NULL;
            pipe_resource_reference(&vbuffer->buffer, stobj->buffer);
            vbuffer->buffer_offset = pointer_to_offset(low_addr);
         }
         else {
            uint divisor = array->InstanceDivisor;
            uint last_index = divisor ? num_instances / divisor : max_index;
            uint bytes = src_offset + stride * last_index + element_size;

            vbuffer->buffer = pipe_user_buffer_create(pipe->screen,
                                                      (void*) low_addr,
                                                      bytes,
                                                      PIPE_BIND_VERTEX_BUFFER);
            vbuffer->buffer_offset = 0;

            /* Track user vertex buffers. */
            pipe_resource_reference(&st->user_attrib[0].buffer, vbuffer->buffer);
            st->user_attrib[0].element_size = element_size;
            st->user_attrib[0].stride = stride;
            st->num_user_attribs = 1;
         }
         vbuffer->stride = stride; /* in bytes */
      }

      velements[attr].src_offset = src_offset;
      velements[attr].instance_divisor = array->InstanceDivisor;
      velements[attr].vertex_buffer_index = 0;
      velements[attr].src_format = st_pipe_vertex_format(array->Type,
                                                         array->Size,
                                                         array->Format,
                                                         array->Normalized);
      assert(velements[attr].src_format);
   }
}


/**
 * Set up a separate pipe_vertex_buffer and pipe_vertex_element for each
 * vertex attribute.
 * \param vbuffer  returns vertex buffer info
 * \param velements  returns vertex element info
 */
static void
setup_non_interleaved_attribs(struct gl_context *ctx,
                              const struct st_vertex_program *vp,
                              const struct st_vp_variant *vpv,
                              const struct gl_client_array **arrays,
                              struct pipe_vertex_buffer vbuffer[],
                              struct pipe_vertex_element velements[],
                              unsigned max_index,
                              unsigned num_instances)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   GLuint attr;

   for (attr = 0; attr < vpv->num_inputs; attr++) {
      const GLuint mesaAttr = vp->index_to_input[attr];
      const struct gl_client_array *array = arrays[mesaAttr];
      struct gl_buffer_object *bufobj = array->BufferObj;
      GLuint element_size = array->_ElementSize;
      GLsizei stride = array->StrideB;

      assert(element_size == array->Size * _mesa_sizeof_type(array->Type));

      if (bufobj && _mesa_is_bufferobj(bufobj)) {
         /* Attribute data is in a VBO.
          * Recall that for VBOs, the gl_client_array->Ptr field is
          * really an offset from the start of the VBO, not a pointer.
          */
         struct st_buffer_object *stobj = st_buffer_object(bufobj);
         assert(stobj->buffer);

         vbuffer[attr].buffer = NULL;
         pipe_resource_reference(&vbuffer[attr].buffer, stobj->buffer);
         vbuffer[attr].buffer_offset = pointer_to_offset(array->Ptr);
      }
      else {
         /* wrap user data */
         uint bytes;
         void *ptr;

         if (array->Ptr) {
            uint divisor = array->InstanceDivisor;
            uint last_index = divisor ? num_instances / divisor : max_index;

            bytes = stride * last_index + element_size;

            ptr = (void *) array->Ptr;
         }
         else {
            /* no array, use ctx->Current.Attrib[] value */
            bytes = element_size = sizeof(ctx->Current.Attrib[0]);
            ptr = (void *) ctx->Current.Attrib[mesaAttr];
            stride = 0;
         }

         assert(ptr);
         assert(bytes);

         vbuffer[attr].buffer =
            pipe_user_buffer_create(pipe->screen, ptr, bytes,
                                    PIPE_BIND_VERTEX_BUFFER);

         vbuffer[attr].buffer_offset = 0;

         /* Track user vertex buffers. */
         pipe_resource_reference(&st->user_attrib[attr].buffer, vbuffer[attr].buffer);
         st->user_attrib[attr].element_size = element_size;
         st->user_attrib[attr].stride = stride;
         st->num_user_attribs = MAX2(st->num_user_attribs, attr + 1);
      }

      /* common-case setup */
      vbuffer[attr].stride = stride; /* in bytes */

      velements[attr].src_offset = 0;
      velements[attr].instance_divisor = array->InstanceDivisor;
      velements[attr].vertex_buffer_index = attr;
      velements[attr].src_format = st_pipe_vertex_format(array->Type,
                                                         array->Size,
                                                         array->Format,
                                                         array->Normalized);
      assert(velements[attr].src_format);
   }
}


static void
setup_index_buffer(struct gl_context *ctx,
                   const struct _mesa_index_buffer *ib,
                   struct pipe_index_buffer *ibuffer)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;

   memset(ibuffer, 0, sizeof(*ibuffer));
   if (ib) {
      struct gl_buffer_object *bufobj = ib->obj;

      switch (ib->type) {
      case GL_UNSIGNED_INT:
         ibuffer->index_size = 4;
         break;
      case GL_UNSIGNED_SHORT:
         ibuffer->index_size = 2;
         break;
      case GL_UNSIGNED_BYTE:
         ibuffer->index_size = 1;
         break;
      default:
         assert(0);
	 return;
      }

      /* get/create the index buffer object */
      if (bufobj && _mesa_is_bufferobj(bufobj)) {
         /* elements/indexes are in a real VBO */
         struct st_buffer_object *stobj = st_buffer_object(bufobj);
         pipe_resource_reference(&ibuffer->buffer, stobj->buffer);
         ibuffer->offset = pointer_to_offset(ib->ptr);
      }
      else {
         /* element/indicies are in user space memory */
         ibuffer->buffer =
            pipe_user_buffer_create(pipe->screen, (void *) ib->ptr,
                                    ib->count * ibuffer->index_size,
                                    PIPE_BIND_INDEX_BUFFER);
      }
   }
d146 3
a148 3
      for (i = 0; i < shProg[j]->Uniforms->NumUniforms; i++) {
         const struct gl_uniform *u = &shProg[j]->Uniforms->Uniforms[i];
         if (!u->Initialized) {
d151 1
a151 1
                          u->Name);
d166 3
a168 3
   assert(GL_POINTS == PIPE_PRIM_POINTS);
   assert(GL_QUADS == PIPE_PRIM_QUADS);
   assert(GL_TRIANGLE_STRIP_ADJACENCY == PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY);
a183 60
static void
st_validate_varrays(struct gl_context *ctx,
                    const struct gl_client_array **arrays,
                    unsigned max_index,
                    unsigned num_instances)
{
   struct st_context *st = st_context(ctx);
   const struct st_vertex_program *vp;
   const struct st_vp_variant *vpv;
   struct pipe_vertex_buffer vbuffer[PIPE_MAX_SHADER_INPUTS];
   struct pipe_vertex_element velements[PIPE_MAX_ATTRIBS];
   unsigned num_vbuffers, num_velements;
   GLuint attr;
   unsigned i;

   /* must get these after state validation! */
   vp = st->vp;
   vpv = st->vp_variant;

   memset(velements, 0, sizeof(struct pipe_vertex_element) * vpv->num_inputs);

   /* Unreference any user vertex buffers. */
   for (i = 0; i < st->num_user_attribs; i++) {
      pipe_resource_reference(&st->user_attrib[i].buffer, NULL);
   }
   st->num_user_attribs = 0;

   /*
    * Setup the vbuffer[] and velements[] arrays.
    */
   if (is_interleaved_arrays(vp, vpv, arrays)) {
      setup_interleaved_attribs(ctx, vp, vpv, arrays, vbuffer, velements,
                                max_index, num_instances);

      num_vbuffers = 1;
      num_velements = vpv->num_inputs;
      if (num_velements == 0)
         num_vbuffers = 0;
   }
   else {
      setup_non_interleaved_attribs(ctx, vp, vpv, arrays,
                                    vbuffer, velements, max_index,
                                    num_instances);
      num_vbuffers = vpv->num_inputs;
      num_velements = vpv->num_inputs;
   }

   cso_set_vertex_buffers(st->cso_context, num_vbuffers, vbuffer);
   cso_set_vertex_elements(st->cso_context, num_velements, velements);

   /* unreference buffers (frees wrapped user-space buffer objects)
    * This is OK, because the pipe driver should reference buffers by itself
    * in set_vertex_buffers. */
   for (attr = 0; attr < num_vbuffers; attr++) {
      pipe_resource_reference(&vbuffer[attr].buffer, NULL);
      assert(!vbuffer[attr].buffer);
   }
}


a190 1
            const struct gl_client_array **arrays,
d196 2
a197 1
            GLuint max_index)
d200 1
a200 2
   struct pipe_context *pipe = st->pipe;
   struct pipe_index_buffer ibuffer;
d202 2
a203 4
   unsigned i, num_instances = 1;
   GLboolean new_array =
      st->dirty.st &&
      (st->dirty.mesa & (_NEW_ARRAY | _NEW_PROGRAM | _NEW_BUFFER_OBJECT)) != 0;
a207 22
   if (ib) {
      /* Gallium probably doesn't want this in some cases. */
      if (!index_bounds_valid)
         if (!all_varyings_in_vbos(arrays))
            vbo_get_minmax_index(ctx, prims, ib, &min_index, &max_index);

      for (i = 0; i < nr_prims; i++) {
         num_instances = MAX2(num_instances, prims[i].num_instances);
      }
   }
   else {
      /* Get min/max index for non-indexed drawing. */
      min_index = ~0;
      max_index = 0;

      for (i = 0; i < nr_prims; i++) {
         min_index = MIN2(min_index, prims[i].start);
         max_index = MAX2(max_index, prims[i].start + prims[i].count - 1);
         num_instances = MAX2(num_instances, prims[i].num_instances);
      }
   }

d209 1
a209 13
   if (st->dirty.st) {
      GLboolean vertDataEdgeFlags;

      /* sanity check for pointer arithmetic below */
      assert(sizeof(arrays[0]->Ptr[0]) == 1);

      vertDataEdgeFlags = arrays[VERT_ATTRIB_EDGEFLAG]->BufferObj &&
                          arrays[VERT_ATTRIB_EDGEFLAG]->BufferObj->Name;
      if (vertDataEdgeFlags != st->vertdata_edgeflags) {
         st->vertdata_edgeflags = vertDataEdgeFlags;
         st->dirty.st |= ST_NEW_EDGEFLAGS_DATA;
      }

d212 2
a213 3
      if (new_array) {
         st_validate_varrays(ctx, arrays, max_index, num_instances);
      }
d224 11
a234 17
   /* Notify the driver that the content of user buffers may have been
    * changed. */
   assert(max_index >= min_index);
   if (!new_array && st->num_user_attribs) {
      for (i = 0; i < st->num_user_attribs; i++) {
         if (st->user_attrib[i].buffer) {
            unsigned element_size = st->user_attrib[i].element_size;
            unsigned stride = st->user_attrib[i].stride;
            unsigned min_offset = min_index * stride;
            unsigned max_offset = max_index * stride + element_size;

            assert(max_offset > min_offset);

            pipe->redefine_user_buffer(pipe, st->user_attrib[i].buffer,
                                       min_offset,
                                       max_offset - min_offset);
         }
a235 4
   }

   setup_index_buffer(ctx, ib, &ibuffer);
   pipe->set_index_buffer(pipe, &ibuffer);
a236 2
   util_draw_init_info(&info);
   if (ib) {
d242 13
a256 3
   info.primitive_restart = ctx->Array.PrimitiveRestart;
   info.restart_index = ctx->Array.RestartIndex;

d262 1
d270 17
a286 2
      if (u_trim_pipe_prim(info.mode, &info.count))
         pipe->draw_vbo(pipe, &info);
d289 3
a291 1
   pipe_resource_reference(&ibuffer.buffer, NULL);
a301 1
#if FEATURE_feedback || FEATURE_rastpos
a310 1
#endif
a316 1
#if FEATURE_feedback || FEATURE_rastpos
a317 1
#endif
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d36 1
a36 1
 * pipe->draw_elements(), pipe->draw_range_elements() or pipe->draw_arrays().
d45 1
d47 1
d185 1
a185 1
GLuint
d215 1
a215 1
      }      
d230 1
a230 1
      }      
d232 1
a232 1
   return 0; /* silence compiler warning */
d236 12
d249 2
a255 1
 * \param userSpace  returns whether the arrays are in user space.
d259 2
a260 3
                      const struct st_vp_varient *vpv,
                      const struct gl_client_array **arrays,
                      GLboolean *userSpace)
d265 2
a266 3
   GLuint num_client_arrays = 0;
   const GLubyte *client_addr = NULL;
   GLboolean user_memory;
d270 3
a272 2
      const struct gl_buffer_object *bufObj = arrays[mesaAttr]->BufferObj;
      const GLsizei stride = arrays[mesaAttr]->StrideB; /* in bytes */
d274 2
a275 1
      if (firstStride < 0) {
d277 1
a277 26
         user_memory = !bufObj || !bufObj->Name;
      }
      else if (firstStride != stride) {
         return GL_FALSE;
      }
         
      if (!bufObj || !bufObj->Name) {
         num_client_arrays++;
         /* Try to detect if the client-space arrays are
          * "close" to each other.
          */
         if (!user_memory) {
            return GL_FALSE;
         }
         if (!client_addr) {
            client_addr = arrays[mesaAttr]->Ptr;
         }
         else if (abs(arrays[mesaAttr]->Ptr - client_addr) > firstStride) {
            /* arrays start too far apart */
            return GL_FALSE;
         }
      }
      else if (!firstBufObj) {
         if (user_memory) {
            return GL_FALSE;
         }
d279 1
d281 4
a284 4
      else if (bufObj != firstBufObj) {
         return GL_FALSE;
      }
   }
d286 2
a287 3
   *userSpace = (num_client_arrays == vpv->num_inputs);
   /* debug_printf("user space: %s (%d arrays, %d inputs)\n",
      (int)*userSpace ? "Yes" : "No", num_client_arrays, vp->num_inputs); */
d289 2
a290 17
   return GL_TRUE;
}


/**
 * Compute the memory range occupied by the arrays.
 */
static void
get_arrays_bounds(const struct st_vertex_program *vp,
                  const struct st_vp_varient *vpv,
                  const struct gl_client_array **arrays,
                  GLuint max_index,
                  const GLubyte **low, const GLubyte **high)
{
   const GLubyte *low_addr = NULL;
   const GLubyte *high_addr = NULL;
   GLuint attr;
d292 2
a293 20
   /* debug_printf("get_arrays_bounds: Handling %u attrs\n", vpv->num_inputs); */

   for (attr = 0; attr < vpv->num_inputs; attr++) {
      const GLuint mesaAttr = vp->index_to_input[attr];
      const GLint stride = arrays[mesaAttr]->StrideB;
      const GLubyte *start = arrays[mesaAttr]->Ptr;
      const unsigned sz = (arrays[mesaAttr]->Size * 
                           _mesa_sizeof_type(arrays[mesaAttr]->Type));
      const GLubyte *end = start + (max_index * stride) + sz;

      /* debug_printf("attr %u: stride %d size %u start %p end %p\n",
         attr, stride, sz, start, end); */

      if (attr == 0) {
         low_addr = start;
         high_addr = end;
      }
      else {
         low_addr = MIN2(low_addr, start);
         high_addr = MAX2(high_addr, end);
d297 1
a297 2
   *low = low_addr;
   *high = high_addr;
d310 1
a310 1
                          const struct st_vp_varient *vpv,
a311 2
                          GLuint max_index,
                          GLboolean userSpace,
d313 3
a315 1
                          struct pipe_vertex_element velements[])
d320 11
a330 1
   const GLubyte *offset0 = NULL;
d334 2
a335 1
      struct gl_buffer_object *bufobj = arrays[mesaAttr]->BufferObj;
d337 3
a339 1
      GLsizei stride = arrays[mesaAttr]->StrideB;
d341 1
a341 1
      /*printf("stobj %u = %p\n", attr, (void*)stobj);*/
d344 4
a347 12
         const GLubyte *low, *high;

         get_arrays_bounds(vp, vpv, arrays, max_index, &low, &high);
         /* debug_printf("buffer range: %p %p range %d max index %u\n",
            low, high, high - low, max_index); */

         offset0 = low;
         if (userSpace) {
            vbuffer->buffer =
               pipe_user_buffer_create(pipe->screen, (void *) low, high - low,
				       PIPE_BIND_VERTEX_BUFFER);
            vbuffer->buffer_offset = 0;
d350 15
a364 3
            vbuffer->buffer = NULL;
            pipe_resource_reference(&vbuffer->buffer, stobj->buffer);
            vbuffer->buffer_offset = pointer_to_offset(low);
a366 1
         vbuffer->max_index = max_index;
d369 2
a370 3
      velements[attr].src_offset =
         (unsigned) (arrays[mesaAttr]->Ptr - offset0);
      velements[attr].instance_divisor = 0;
d372 4
a375 5
      velements[attr].src_format =
         st_pipe_vertex_format(arrays[mesaAttr]->Type,
                               arrays[mesaAttr]->Size,
                               arrays[mesaAttr]->Format,
                               arrays[mesaAttr]->Normalized);
d390 1
a390 1
                              const struct st_vp_varient *vpv,
a391 2
                              GLuint max_index,
                              GLboolean *userSpace,
d393 3
a395 1
                              struct pipe_vertex_element velements[])
d403 4
a406 2
      struct gl_buffer_object *bufobj = arrays[mesaAttr]->BufferObj;
      GLsizei stride = arrays[mesaAttr]->StrideB;
d408 1
a408 1
      *userSpace = GL_FALSE;
d410 1
a410 1
      if (bufobj && bufobj->Name) {
a416 1
         /*printf("stobj %u = %p\n", attr, (void*) stobj);*/
d420 1
a420 2
         vbuffer[attr].buffer_offset = pointer_to_offset(arrays[mesaAttr]->Ptr);
         velements[attr].src_offset = 0;
d423 1
a423 1
         /* attribute data is in user-space memory, not a VBO */
d425 5
a429 3
         /*printf("user-space array %d stride %d\n", attr, stride);*/
	
         *userSpace = GL_TRUE;
d431 3
a433 14
         /* wrap user data */
         if (arrays[mesaAttr]->Ptr) {
            /* user's vertex array */
            if (arrays[mesaAttr]->StrideB) {
               bytes = arrays[mesaAttr]->StrideB * (max_index + 1);
            }
            else {
               bytes = arrays[mesaAttr]->Size
                  * _mesa_sizeof_type(arrays[mesaAttr]->Type);
            }
            vbuffer[attr].buffer = 
	       pipe_user_buffer_create(pipe->screen,
				       (void *) arrays[mesaAttr]->Ptr, bytes,
				       PIPE_BIND_VERTEX_BUFFER);
d437 2
a438 6
            bytes = sizeof(ctx->Current.Attrib[0]);
            vbuffer[attr].buffer = 
	       pipe_user_buffer_create(pipe->screen,
				       (void *) ctx->Current.Attrib[mesaAttr],
				       bytes,
				       PIPE_BIND_VERTEX_BUFFER);
d442 7
d450 6
a455 1
         velements[attr].src_offset = 0;
a457 2
      assert(velements[attr].src_offset <= 2048); /* 11-bit field */

d460 3
a462 2
      vbuffer[attr].max_index = max_index;
      velements[attr].instance_divisor = 0;
d464 4
a467 5
      velements[attr].src_format
         = st_pipe_vertex_format(arrays[mesaAttr]->Type,
                                 arrays[mesaAttr]->Size,
                                 arrays[mesaAttr]->Format,
                                 arrays[mesaAttr]->Normalized);
d501 1
a501 1
      if (bufobj && bufobj->Name) {
d517 1
d564 2
a565 2
    * Note: it's imporant to do the correct trimming if we change the prim type!
    * We do that wherever this function is called.
d577 59
a653 6
   const struct st_vertex_program *vp;
   const struct st_vp_varient *vpv;
   struct pipe_vertex_buffer vbuffer[PIPE_MAX_SHADER_INPUTS];
   GLuint attr;
   struct pipe_vertex_element velements[PIPE_MAX_ATTRIBS];
   unsigned num_vbuffers, num_velements;
a654 2
   GLboolean userSpace = GL_FALSE;
   GLboolean vertDataEdgeFlags;
d656 4
a659 1
   unsigned i;
d664 20
a683 13
   /* Gallium probably doesn't want this in some cases. */
   if (!index_bounds_valid)
      if (!vbo_all_varyings_in_vbos(arrays))
	 vbo_get_minmax_index(ctx, prims, ib, &min_index, &max_index);

   /* sanity check for pointer arithmetic below */
   assert(sizeof(arrays[0]->Ptr[0]) == 1);

   vertDataEdgeFlags = arrays[VERT_ATTRIB_EDGEFLAG]->BufferObj &&
                       arrays[VERT_ATTRIB_EDGEFLAG]->BufferObj->Name;
   if (vertDataEdgeFlags != st->vertdata_edgeflags) {
      st->vertdata_edgeflags = vertDataEdgeFlags;
      st->dirty.st |= ST_NEW_EDGEFLAGS_DATA;
d686 3
a688 1
   st_validate_state(st);
d690 15
a704 3
   /* must get these after state validation! */
   vp = st->vp;
   vpv = st->vp_varient;
d707 3
a709 3
   if (MESA_VERBOSE & VERBOSE_GLSL) {
      check_uniforms(ctx);
   }
d711 1
a711 1
   (void) check_uniforms;
a712 20

   memset(velements, 0, sizeof(struct pipe_vertex_element) * vpv->num_inputs);
   /*
    * Setup the vbuffer[] and velements[] arrays.
    */
   if (is_interleaved_arrays(vp, vpv, arrays, &userSpace)) {
      /*printf("Draw interleaved\n");*/
      setup_interleaved_attribs(ctx, vp, vpv, arrays, max_index, userSpace,
                                vbuffer, velements);
      num_vbuffers = 1;
      num_velements = vpv->num_inputs;
      if (num_velements == 0)
         num_vbuffers = 0;
   }
   else {
      /*printf("Draw non-interleaved\n");*/
      setup_non_interleaved_attribs(ctx, vp, vpv, arrays, max_index,
                                    &userSpace, vbuffer, velements);
      num_vbuffers = vpv->num_inputs;
      num_velements = vpv->num_inputs;
d715 17
a731 13
#if 0
   {
      GLuint i;
      for (i = 0; i < num_vbuffers; i++) {
         printf("buffers[%d].stride = %u\n", i, vbuffer[i].stride);
         printf("buffers[%d].max_index = %u\n", i, vbuffer[i].max_index);
         printf("buffers[%d].buffer_offset = %u\n", i, vbuffer[i].buffer_offset);
         printf("buffers[%d].buffer = %p\n", i, (void*) vbuffer[i].buffer);
      }
      for (i = 0; i < num_velements; i++) {
         printf("vlements[%d].vbuffer_index = %u\n", i, velements[i].vertex_buffer_index);
         printf("vlements[%d].src_offset = %u\n", i, velements[i].src_offset);
         printf("vlements[%d].format = %s\n", i, util_format_name(velements[i].src_format));
a733 4
#endif

   pipe->set_vertex_buffers(pipe, num_vbuffers, vbuffer);
   cso_set_vertex_elements(st->cso_context, num_velements, velements);
d747 2
a748 2
   info.primitive_restart = st->ctx->Array.PrimitiveRestart;
   info.restart_index = st->ctx->Array.RestartIndex;
a766 11

   /* unreference buffers (frees wrapped user-space buffer objects) */
   for (attr = 0; attr < num_vbuffers; attr++) {
      pipe_resource_reference(&vbuffer[attr].buffer, NULL);
      assert(!vbuffer[attr].buffer);
   }

   if (userSpace) 
   {
      pipe->set_vertex_buffers(pipe, 0, NULL);
   }
d770 2
a771 1
void st_init_draw( struct st_context *st )
d791 2
a792 1
void st_destroy_draw( struct st_context *st )
a797 2


@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d46 1
a46 1
#include "shader/prog_uniform.h"
d60 4
d80 7
d188 1
a188 1
          type == GL_FIXED);
d197 1
a197 1
      return PIPE_FORMAT_A8R8G8B8_UNORM;
d204 1
d219 1
d253 1
d262 1
d273 3
d285 3
d296 2
a297 1
   /* printf("user space: %d (%d %d)\n", (int) *userSpace,num_client_arrays,vp->num_inputs); */
d317 2
d327 3
d352 1
a352 1
setup_interleaved_attribs(GLcontext *ctx,
d361 2
a362 1
   struct pipe_context *pipe = ctx->st->pipe;
d378 2
a379 1
         /*printf("buffer range: %p %p  %d\n", low, high, high-low);*/
d384 2
a385 1
               pipe_user_buffer_create(pipe->screen, (void *) low, high - low);
d390 1
a390 1
            pipe_buffer_reference(&vbuffer->buffer, stobj->buffer);
a400 1
      velements[attr].nr_components = arrays[mesaAttr]->Size;
d418 1
a418 1
setup_non_interleaved_attribs(GLcontext *ctx,
d427 2
a428 1
   struct pipe_context *pipe = ctx->st->pipe;
d448 1
a448 1
         pipe_buffer_reference(&vbuffer[attr].buffer, stobj->buffer);
d469 4
a472 2
            vbuffer[attr].buffer = pipe_user_buffer_create(pipe->screen,
                           (void *) arrays[mesaAttr]->Ptr, bytes);
d477 5
a481 2
            vbuffer[attr].buffer = pipe_user_buffer_create(pipe->screen,
                           (void *) ctx->Current.Attrib[mesaAttr], bytes);
a495 1
      velements[attr].nr_components = arrays[mesaAttr]->Size;
d506 43
d556 1
a556 1
check_uniforms(GLcontext *ctx)
d558 15
a572 5
   const struct gl_shader_program *shProg = ctx->Shader.CurrentProgram;
   if (shProg && shProg->LinkStatus) {
      GLuint i;
      for (i = 0; i < shProg->Uniforms->NumUniforms; i++) {
         const struct gl_uniform *u = &shProg->Uniforms->Uniforms[i];
d583 6
a588 2
static unsigned translate_prim( GLcontext *ctx,
                                unsigned prim )
d590 5
d596 2
d608 2
d616 1
a616 1
st_draw_vbo(GLcontext *ctx,
d625 2
a626 1
   struct pipe_context *pipe = ctx->st->pipe;
d633 1
d636 2
d652 3
a654 3
   if (vertDataEdgeFlags != ctx->st->vertdata_edgeflags) {
      ctx->st->vertdata_edgeflags = vertDataEdgeFlags;
      ctx->st->dirty.st |= ST_NEW_EDGEFLAGS_DATA;
d657 1
a657 1
   st_validate_state(ctx->st);
d660 2
a661 2
   vp = ctx->st->vp;
   vpv = ctx->st->vp_varient;
d671 1
a703 1
         printf("vlements[%d].nr_comps = %u\n", i, velements[i].nr_components);
d710 1
a710 1
   pipe->set_vertex_elements(pipe, num_velements, velements);
d712 2
a713 2
   if (num_vbuffers == 0 || num_velements == 0)
      return;
d715 1
a715 1
   /* do actual drawing */
d717 4
a720 33
      /* indexed primitive */
      struct gl_buffer_object *bufobj = ib->obj;
      struct pipe_buffer *indexBuf = NULL;
      unsigned indexSize, indexOffset, i;
      unsigned prim;

      switch (ib->type) {
      case GL_UNSIGNED_INT:
         indexSize = 4;
         break;
      case GL_UNSIGNED_SHORT:
         indexSize = 2;
         break;
      case GL_UNSIGNED_BYTE:
         indexSize = 1;
         break;
      default:
         assert(0);
	 return;
      }

      /* get/create the index buffer object */
      if (bufobj && bufobj->Name) {
         /* elements/indexes are in a real VBO */
         struct st_buffer_object *stobj = st_buffer_object(bufobj);
         pipe_buffer_reference(&indexBuf, stobj->buffer);
         indexOffset = pointer_to_offset(ib->ptr) / indexSize;
      }
      else {
         /* element/indicies are in user space memory */
         indexBuf = pipe_user_buffer_create(pipe->screen, (void *) ib->ptr,
                                            ib->count * indexSize);
         indexOffset = 0;
d722 1
d724 2
a725 8
      /* draw */
      if (pipe->draw_range_elements && min_index != ~0 && max_index != ~0) {
         /* XXX: exercise temporary path to pass min/max directly
          * through to driver & draw module.  These interfaces still
          * need a bit of work...
          */
         for (i = 0; i < nr_prims; i++) {
            prim = translate_prim( ctx, prims[i].mode );
d727 10
a736 13
            pipe->draw_range_elements(pipe, indexBuf, indexSize,
                                      min_index, max_index, prim,
                                      prims[i].start + indexOffset, prims[i].count);
         }
      }
      else {
         for (i = 0; i < nr_prims; i++) {
            prim = translate_prim( ctx, prims[i].mode );
            
            pipe->draw_elements(pipe, indexBuf, indexSize,
                                prim,
                                prims[i].start + indexOffset, prims[i].count);
         }
d739 2
a740 1
      pipe_buffer_reference(&indexBuf, NULL);
a741 7
   else {
      /* non-indexed */
      GLuint i;
      GLuint prim;

      for (i = 0; i < nr_prims; i++) {
         prim = translate_prim( ctx, prims[i].mode );
d743 1
a743 3
         pipe->draw_arrays(pipe, prim, prims[i].start, prims[i].count);
      }
   }
d747 1
a747 1
      pipe_buffer_reference(&vbuffer[attr].buffer, NULL);
d760 1
a760 1
   GLcontext *ctx = st->ctx;
d763 12
d780 3
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d46 1
a46 1
#include "program/prog_uniform.h"
a59 4
#include "util/u_prim.h"
#include "util/u_draw_quad.h"
#include "draw/draw_context.h"
#include "cso_cache/cso_context.h"
a75 7
static GLuint half_float_types[4] = {
   PIPE_FORMAT_R16_FLOAT,
   PIPE_FORMAT_R16G16_FLOAT,
   PIPE_FORMAT_R16G16B16_FLOAT,
   PIPE_FORMAT_R16G16B16A16_FLOAT
};

d177 1
a177 1
          type == GL_FIXED || type == GL_HALF_FLOAT);
d186 1
a186 1
      return PIPE_FORMAT_B8G8R8A8_UNORM;
a192 1
      case GL_HALF_FLOAT: return half_float_types[size-1];
a206 1
      case GL_HALF_FLOAT: return half_float_types[size-1];
a239 1
   GLboolean user_memory;
a247 1
         user_memory = !bufObj || !bufObj->Name;
a257 3
         if (!user_memory) {
            return GL_FALSE;
         }
a266 3
         if (user_memory) {
            return GL_FALSE;
         }
d275 1
a275 2
   /* debug_printf("user space: %s (%d arrays, %d inputs)\n",
      (int)*userSpace ? "Yes" : "No", num_client_arrays, vp->num_inputs); */
a294 2
   /* debug_printf("get_arrays_bounds: Handling %u attrs\n", vpv->num_inputs); */

a302 3
      /* debug_printf("attr %u: stride %d size %u start %p end %p\n",
         attr, stride, sz, start, end); */

d325 1
a325 1
setup_interleaved_attribs(struct gl_context *ctx,
d334 1
a334 2
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
d350 1
a350 2
         /* debug_printf("buffer range: %p %p range %d max index %u\n",
            low, high, high - low, max_index); */
d355 1
a355 2
               pipe_user_buffer_create(pipe->screen, (void *) low, high - low,
				       PIPE_BIND_VERTEX_BUFFER);
d360 1
a360 1
            pipe_resource_reference(&vbuffer->buffer, stobj->buffer);
d371 1
d389 1
a389 1
setup_non_interleaved_attribs(struct gl_context *ctx,
d398 1
a398 2
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
d418 1
a418 1
         pipe_resource_reference(&vbuffer[attr].buffer, stobj->buffer);
d439 2
a440 4
            vbuffer[attr].buffer = 
	       pipe_user_buffer_create(pipe->screen,
				       (void *) arrays[mesaAttr]->Ptr, bytes,
				       PIPE_BIND_VERTEX_BUFFER);
d445 2
a446 5
            vbuffer[attr].buffer = 
	       pipe_user_buffer_create(pipe->screen,
				       (void *) ctx->Current.Attrib[mesaAttr],
				       bytes,
				       PIPE_BIND_VERTEX_BUFFER);
d461 1
a471 43
static void
setup_index_buffer(struct gl_context *ctx,
                   const struct _mesa_index_buffer *ib,
                   struct pipe_index_buffer *ibuffer)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;

   memset(ibuffer, 0, sizeof(*ibuffer));
   if (ib) {
      struct gl_buffer_object *bufobj = ib->obj;

      switch (ib->type) {
      case GL_UNSIGNED_INT:
         ibuffer->index_size = 4;
         break;
      case GL_UNSIGNED_SHORT:
         ibuffer->index_size = 2;
         break;
      case GL_UNSIGNED_BYTE:
         ibuffer->index_size = 1;
         break;
      default:
         assert(0);
	 return;
      }

      /* get/create the index buffer object */
      if (bufobj && bufobj->Name) {
         /* elements/indexes are in a real VBO */
         struct st_buffer_object *stobj = st_buffer_object(bufobj);
         pipe_resource_reference(&ibuffer->buffer, stobj->buffer);
         ibuffer->offset = pointer_to_offset(ib->ptr);
      }
      else {
         /* element/indicies are in user space memory */
         ibuffer->buffer =
            pipe_user_buffer_create(pipe->screen, (void *) ib->ptr,
                                    ib->count * ibuffer->index_size,
                                    PIPE_BIND_INDEX_BUFFER);
      }
   }
}
d479 1
a479 1
check_uniforms(struct gl_context *ctx)
d481 5
a485 15
   struct gl_shader_program *shProg[3] = {
      ctx->Shader.CurrentVertexProgram,
      ctx->Shader.CurrentGeometryProgram,
      ctx->Shader.CurrentFragmentProgram,
   };
   unsigned j;

   for (j = 0; j < 3; j++) {
      unsigned i;

      if (shProg[j] == NULL || !shProg[j]->LinkStatus)
	 continue;

      for (i = 0; i < shProg[j]->Uniforms->NumUniforms; i++) {
         const struct gl_uniform *u = &shProg[j]->Uniforms->Uniforms[i];
d496 2
a497 6
/**
 * Translate OpenGL primtive type (GL_POINTS, GL_TRIANGLE_STRIP, etc) to
 * the corresponding Gallium type.
 */
static unsigned
translate_prim(const struct gl_context *ctx, unsigned prim)
a498 5
   /* GL prims should match Gallium prims, spot-check a few */
   assert(GL_POINTS == PIPE_PRIM_POINTS);
   assert(GL_QUADS == PIPE_PRIM_QUADS);
   assert(GL_TRIANGLE_STRIP_ADJACENCY == PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY);

a499 2
    * Note: it's imporant to do the correct trimming if we change the prim type!
    * We do that wherever this function is called.
a509 2


d516 1
a516 1
st_draw_vbo(struct gl_context *ctx,
d525 1
a525 2
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
a531 1
   struct pipe_index_buffer ibuffer;
a533 2
   struct pipe_draw_info info;
   unsigned i;
d548 3
a550 3
   if (vertDataEdgeFlags != st->vertdata_edgeflags) {
      st->vertdata_edgeflags = vertDataEdgeFlags;
      st->dirty.st |= ST_NEW_EDGEFLAGS_DATA;
d553 1
a553 1
   st_validate_state(st);
d556 2
a557 2
   vp = st->vp;
   vpv = st->vp_varient;
a566 1
   memset(velements, 0, sizeof(struct pipe_vertex_element) * vpv->num_inputs);
d599 1
d606 1
a606 1
   cso_set_vertex_elements(st->cso_context, num_velements, velements);
d608 2
a609 2
   setup_index_buffer(ctx, ib, &ibuffer);
   pipe->set_index_buffer(pipe, &ibuffer);
d611 1
a611 1
   util_draw_init_info(&info);
d613 33
a645 4
      info.indexed = TRUE;
      if (min_index != ~0 && max_index != ~0) {
         info.min_index = min_index;
         info.max_index = max_index;
a646 1
   }
d648 8
a655 2
   info.primitive_restart = st->ctx->Array.PrimitiveRestart;
   info.restart_index = st->ctx->Array.RestartIndex;
d657 13
a669 10
   /* do actual drawing */
   for (i = 0; i < nr_prims; i++) {
      info.mode = translate_prim( ctx, prims[i].mode );
      info.start = prims[i].start;
      info.count = prims[i].count;
      info.instance_count = prims[i].num_instances;
      info.index_bias = prims[i].basevertex;
      if (!ib) {
         info.min_index = info.start;
         info.max_index = info.start + info.count - 1;
d672 1
a672 2
      if (u_trim_pipe_prim(info.mode, &info.count))
         pipe->draw_vbo(pipe, &info);
d674 7
d682 3
a684 1
   pipe_resource_reference(&ibuffer.buffer, NULL);
d688 1
a688 1
      pipe_resource_reference(&vbuffer[attr].buffer, NULL);
d701 1
a701 1
   struct gl_context *ctx = st->ctx;
a703 12

#if FEATURE_feedback || FEATURE_rastpos
   st->draw = draw_create(st->pipe); /* for selection/feedback */

   /* Disable draw options that might convert points/lines to tris, etc.
    * as that would foul-up feedback/selection mode.
    */
   draw_wide_line_threshold(st->draw, 1000.0f);
   draw_wide_point_threshold(st->draw, 1000.0f);
   draw_enable_line_stipple(st->draw, FALSE);
   draw_enable_point_sprites(st->draw, FALSE);
#endif
a708 3
#if FEATURE_feedback || FEATURE_rastpos
   draw_destroy(st->draw);
#endif
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d34 4
a44 1
#include "main/bufferobj.h"
d46 1
a52 2
#include "st_cb_xformfb.h"
#include "st_debug.h"
a61 1
#include "util/u_upload_mgr.h"
d65 170
a234 1
#include "../glsl/ir_uniform.h"
d238 3
a240 2
 * This is very similar to vbo_all_varyings_in_vbos() but we are
 * only interested in per-vertex data.  See bug 38626.
d243 4
a246 1
all_varyings_in_vbos(const struct gl_client_array *arrays[])
d248 50
a297 7
   GLuint i;
   
   for (i = 0; i < VERT_ATTRIB_MAX; i++)
      if (arrays[i]->StrideB &&
          !arrays[i]->InstanceDivisor &&
          !_mesa_is_bufferobj(arrays[i]->BufferObj))
	 return GL_FALSE;
d304 112
a415 3
 * Basically, translate Mesa's index buffer information into
 * a pipe_index_buffer object.
 * \return TRUE or FALSE for success/failure
d417 91
a507 2
static boolean
setup_index_buffer(struct st_context *st,
d511 6
a516 1
   struct gl_buffer_object *bufobj = ib->obj;
d518 14
a531 1
   ibuffer->index_size = vbo_sizeof_ib_type(ib->type);
d533 13
a545 12
   /* get/create the index buffer object */
   if (_mesa_is_bufferobj(bufobj)) {
      /* indices are in a real VBO */
      ibuffer->buffer = st_buffer_object(bufobj)->buffer;
      ibuffer->offset = pointer_to_offset(ib->ptr);
   }
   else if (st->indexbuf_uploader) {
      if (u_upload_data(st->indexbuf_uploader, 0,
                        ib->count * ibuffer->index_size, ib->ptr,
                        &ibuffer->offset, &ibuffer->buffer) != PIPE_OK) {
         /* out of memory */
         return FALSE;
a546 5
      u_upload_unmap(st->indexbuf_uploader);
   }
   else {
      /* indices are in user space memory */
      ibuffer->user_buffer = ib->ptr;
a547 3

   cso_set_index_buffer(st->cso_context, ibuffer);
   return TRUE;
a549 1

d571 3
a573 3
      for (i = 0; i < shProg[j]->NumUserUniformStorage; i++) {
         const struct gl_uniform_storage *u = &shProg[j]->UniformStorage[i];
         if (!u->initialized) {
d576 1
a576 1
                          u->name);
d591 3
a593 3
   STATIC_ASSERT(GL_POINTS == PIPE_PRIM_POINTS);
   STATIC_ASSERT(GL_QUADS == PIPE_PRIM_QUADS);
   STATIC_ASSERT(GL_TRIANGLE_STRIP_ADJACENCY == PIPE_PRIM_TRIANGLE_STRIP_ADJACENCY);
d596 2
a597 2
    * Note: it's important to do the correct trimming if we change the
    * prim type!  We do that wherever this function is called.
d609 1
d617 1
d623 1
a623 2
            GLuint max_index,
            struct gl_transform_feedback_object *tfb_vertcount)
d626 10
a635 1
   struct pipe_index_buffer ibuffer = {0};
a636 1
   const struct gl_client_array **arrays = ctx->Array._DrawArrays;
d642 16
a657 3
   /* Validate state. */
   if (st->dirty.st || ctx->NewDriverState) {
      st_validate_state(st);
d659 3
a661 2
      if (st->vertex_array_out_of_memory)
         return;
d664 3
a666 3
      if (MESA_VERBOSE & VERBOSE_GLSL) {
         check_uniforms(ctx);
      }
d668 1
a668 1
      (void) check_uniforms;
d670 13
d684 30
a716 11
      /* Get index bounds for user buffers. */
      if (!index_bounds_valid)
         if (!all_varyings_in_vbos(arrays))
            vbo_get_minmax_indices(ctx, prims, ib, &min_index, &max_index,
                                   nr_prims);

      if (!setup_index_buffer(st, ib, &ibuffer)) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBegin/DrawElements/DrawArray");
         return;
      }

d722 1
d724 2
a725 13
      /* The VBO module handles restart for the non-indexed GLDrawArrays
       * so we only set these fields for indexed drawing:
       */
      info.primitive_restart = ctx->Array._PrimitiveRestart;
      info.restart_index = ctx->Array.RestartIndex;
   }
   else {
      /* Transform feedback drawing is always non-indexed. */
      /* Set info.count_from_stream_output. */
      if (tfb_vertcount) {
         st_transform_feedback_draw_init(tfb_vertcount, &info);
      }
   }
a731 1
      info.start_instance = prims[i].base_instance;
d739 5
a743 7
      if (ST_DEBUG & DEBUG_DRAW) {
         debug_printf("st/draw: mode %s  start %u  count %u  indexed %d\n",
                      u_prim_name(info.mode),
                      info.start,
                      info.count,
                      info.indexed);
      }
d745 4
a748 9
      if (info.count_from_stream_output) {
         cso_draw_vbo(st->cso_context, &info);
      }
      else if (info.primitive_restart) {
         /* don't trim, restarts might be inside index list */
         cso_draw_vbo(st->cso_context, &info);
      }
      else if (u_trim_pipe_prim(prims[i].mode, &info.count))
         cso_draw_vbo(st->cso_context, &info);
d751 3
a753 2
   if (ib && st->indexbuf_uploader && !_mesa_is_bufferobj(ib->obj)) {
      pipe_resource_reference(&ibuffer.buffer, NULL);
d758 1
a758 2
void
st_init_draw(struct st_context *st)
d764 1
d774 1
d778 1
a778 2
void
st_destroy_draw(struct st_context *st)
d780 1
d782 1
d784 2
@


1.1.1.3
log
@Import Mesa 9.2.3
@
text
@d212 3
a221 4
   }

   if (st->vertex_array_out_of_memory) {
      return;
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d2 2
a3 2
 *
 * Copyright 2007 VMware, Inc.
d5 1
a5 1
 *
d13 1
a13 1
 *
d17 1
a17 1
 *
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d25 1
a25 1
 *
d35 1
a35 1
 *   Keith Whitwell <keithw@@vmware.com>
d75 1
a75 1

a106 1
      /* upload indexes from user memory into a real buffer */
d133 5
a137 1
   struct gl_shader_program **shProg = ctx->_Shader->CurrentProgram;
d170 10
d197 1
a197 2
            struct gl_transform_feedback_object *tfb_vertcount,
            struct gl_buffer_object *indirect)
a225 1

d260 1
a260 1
      info.mode = translate_prim(ctx, prims[i].mode);
d286 1
a286 1
      else if (u_trim_pipe_prim(prims[i].mode, &info.count)) {
a287 1
      }
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@a42 1
#include "main/varray.h"
d237 1
a237 1
      info.restart_index = _mesa_primitive_restart_index(ctx, ib->type);
a246 8
   if (indirect) {
      info.indirect = st_buffer_object(indirect)->buffer;

      /* Primitive restart is not handled by the VBO module in this case. */
      info.primitive_restart = ctx->Array._PrimitiveRestart;
      info.restart_index = ctx->Array.RestartIndex;
   }

a258 1
      info.indirect_offset = prims[i].indirect_offset;
d268 1
a268 1
      if (info.count_from_stream_output || info.indirect) {
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d43 1
d238 1
a238 1
      info.restart_index = ctx->Array.RestartIndex;
d248 8
d268 1
d278 1
a278 1
      if (info.count_from_stream_output) {
@


