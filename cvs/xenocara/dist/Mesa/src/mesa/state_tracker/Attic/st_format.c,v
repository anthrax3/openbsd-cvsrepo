head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.06.45;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.24;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.11;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.13.21;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.50.27;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * Copyright (c) 2008-2010 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/


/**
 * Mesa / Gallium format conversion and format selection code.
 * \author Brian Paul
 */

#include "main/imports.h"
#include "main/context.h"
#include "main/glformats.h"
#include "main/texgetimage.h"
#include "main/teximage.h"
#include "main/texstore.h"
#include "main/image.h"
#include "main/macros.h"

#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "pipe/p_screen.h"
#include "util/u_format.h"
#include "st_cb_texture.h"
#include "st_context.h"
#include "st_format.h"


/**
 * Translate Mesa format to Gallium format.
 */
enum pipe_format
st_mesa_format_to_pipe_format(mesa_format mesaFormat)
{
   switch (mesaFormat) {
   case MESA_FORMAT_A8B8G8R8_UNORM:
      return PIPE_FORMAT_ABGR8888_UNORM;
   case MESA_FORMAT_R8G8B8A8_UNORM:
      return PIPE_FORMAT_RGBA8888_UNORM;
   case MESA_FORMAT_B8G8R8A8_UNORM:
      return PIPE_FORMAT_BGRA8888_UNORM;
   case MESA_FORMAT_A8R8G8B8_UNORM:
      return PIPE_FORMAT_ARGB8888_UNORM;
   case MESA_FORMAT_X8B8G8R8_UNORM:
      return PIPE_FORMAT_XBGR8888_UNORM;
   case MESA_FORMAT_R8G8B8X8_UNORM:
      return PIPE_FORMAT_RGBX8888_UNORM;
   case MESA_FORMAT_B8G8R8X8_UNORM:
      return PIPE_FORMAT_BGRX8888_UNORM;
   case MESA_FORMAT_X8R8G8B8_UNORM:
      return PIPE_FORMAT_XRGB8888_UNORM;
   case MESA_FORMAT_B5G5R5A1_UNORM:
      return PIPE_FORMAT_B5G5R5A1_UNORM;
   case MESA_FORMAT_B4G4R4A4_UNORM:
      return PIPE_FORMAT_B4G4R4A4_UNORM;
   case MESA_FORMAT_B5G6R5_UNORM:
      return PIPE_FORMAT_B5G6R5_UNORM;
   case MESA_FORMAT_B2G3R3_UNORM:
      return PIPE_FORMAT_B2G3R3_UNORM;
   case MESA_FORMAT_B10G10R10A2_UNORM:
      return PIPE_FORMAT_B10G10R10A2_UNORM;
   case MESA_FORMAT_L4A4_UNORM:
      return PIPE_FORMAT_L4A4_UNORM;
   case MESA_FORMAT_L8A8_UNORM:
      return PIPE_FORMAT_L8A8_UNORM;
   case MESA_FORMAT_L16A16_UNORM:
      return PIPE_FORMAT_L16A16_UNORM;
   case MESA_FORMAT_A_UNORM8:
      return PIPE_FORMAT_A8_UNORM;
   case MESA_FORMAT_A_UNORM16:
      return PIPE_FORMAT_A16_UNORM;
   case MESA_FORMAT_L_UNORM8:
      return PIPE_FORMAT_L8_UNORM;
   case MESA_FORMAT_L_UNORM16:
      return PIPE_FORMAT_L16_UNORM;
   case MESA_FORMAT_I_UNORM8:
      return PIPE_FORMAT_I8_UNORM;
   case MESA_FORMAT_I_UNORM16:
      return PIPE_FORMAT_I16_UNORM;
   case MESA_FORMAT_Z_UNORM16:
      return PIPE_FORMAT_Z16_UNORM;
   case MESA_FORMAT_Z_UNORM32:
      return PIPE_FORMAT_Z32_UNORM;
   case MESA_FORMAT_S8_UINT_Z24_UNORM:
      return PIPE_FORMAT_S8_UINT_Z24_UNORM;
   case MESA_FORMAT_Z24_UNORM_S8_UINT:
      return PIPE_FORMAT_Z24_UNORM_S8_UINT;
   case MESA_FORMAT_X8_UINT_Z24_UNORM:
      return PIPE_FORMAT_X8Z24_UNORM;
   case MESA_FORMAT_Z24_UNORM_X8_UINT:
      return PIPE_FORMAT_Z24X8_UNORM;
   case MESA_FORMAT_S_UINT8:
      return PIPE_FORMAT_S8_UINT;
   case MESA_FORMAT_Z_FLOAT32:
      return PIPE_FORMAT_Z32_FLOAT;
   case MESA_FORMAT_Z32_FLOAT_S8X24_UINT:
      return PIPE_FORMAT_Z32_FLOAT_S8X24_UINT;
   case MESA_FORMAT_YCBCR:
      return PIPE_FORMAT_UYVY;
   case MESA_FORMAT_YCBCR_REV:
      return PIPE_FORMAT_YUYV;
   case MESA_FORMAT_RGB_DXT1:
      return PIPE_FORMAT_DXT1_RGB;
   case MESA_FORMAT_RGBA_DXT1:
      return PIPE_FORMAT_DXT1_RGBA;
   case MESA_FORMAT_RGBA_DXT3:
      return PIPE_FORMAT_DXT3_RGBA;
   case MESA_FORMAT_RGBA_DXT5:
      return PIPE_FORMAT_DXT5_RGBA;
   case MESA_FORMAT_SRGB_DXT1:
      return PIPE_FORMAT_DXT1_SRGB;
   case MESA_FORMAT_SRGBA_DXT1:
      return PIPE_FORMAT_DXT1_SRGBA;
   case MESA_FORMAT_SRGBA_DXT3:
      return PIPE_FORMAT_DXT3_SRGBA;
   case MESA_FORMAT_SRGBA_DXT5:
      return PIPE_FORMAT_DXT5_SRGBA;
   case MESA_FORMAT_L8A8_SRGB:
      return PIPE_FORMAT_L8A8_SRGB;
   case MESA_FORMAT_L_SRGB8:
      return PIPE_FORMAT_L8_SRGB;
   case MESA_FORMAT_BGR_SRGB8:
      return PIPE_FORMAT_R8G8B8_SRGB;
   case MESA_FORMAT_A8B8G8R8_SRGB:
      return PIPE_FORMAT_A8B8G8R8_SRGB;
   case MESA_FORMAT_B8G8R8A8_SRGB:
      return PIPE_FORMAT_B8G8R8A8_SRGB;
   case MESA_FORMAT_R8G8B8A8_SRGB:
      return PIPE_FORMAT_R8G8B8A8_SRGB;
   case MESA_FORMAT_RGBA_FLOAT32:
      return PIPE_FORMAT_R32G32B32A32_FLOAT;
   case MESA_FORMAT_RGBA_FLOAT16:
      return PIPE_FORMAT_R16G16B16A16_FLOAT;
   case MESA_FORMAT_RGB_FLOAT32:
      return PIPE_FORMAT_R32G32B32_FLOAT;
   case MESA_FORMAT_RGB_FLOAT16:
      return PIPE_FORMAT_R16G16B16_FLOAT;
   case MESA_FORMAT_LA_FLOAT32:
      return PIPE_FORMAT_L32A32_FLOAT;
   case MESA_FORMAT_LA_FLOAT16:
      return PIPE_FORMAT_L16A16_FLOAT;
   case MESA_FORMAT_L_FLOAT32:
      return PIPE_FORMAT_L32_FLOAT;
   case MESA_FORMAT_L_FLOAT16:
      return PIPE_FORMAT_L16_FLOAT;
   case MESA_FORMAT_A_FLOAT32:
      return PIPE_FORMAT_A32_FLOAT;
   case MESA_FORMAT_A_FLOAT16:
      return PIPE_FORMAT_A16_FLOAT;
   case MESA_FORMAT_I_FLOAT32:
      return PIPE_FORMAT_I32_FLOAT;
   case MESA_FORMAT_I_FLOAT16:
      return PIPE_FORMAT_I16_FLOAT;
   case MESA_FORMAT_R_FLOAT32:
      return PIPE_FORMAT_R32_FLOAT;
   case MESA_FORMAT_R_FLOAT16:
      return PIPE_FORMAT_R16_FLOAT;
   case MESA_FORMAT_RG_FLOAT32:
      return PIPE_FORMAT_R32G32_FLOAT;
   case MESA_FORMAT_RG_FLOAT16:
      return PIPE_FORMAT_R16G16_FLOAT;

   case MESA_FORMAT_R_UNORM8:
      return PIPE_FORMAT_R8_UNORM;
   case MESA_FORMAT_R_UNORM16:
      return PIPE_FORMAT_R16_UNORM;
   case MESA_FORMAT_R8G8_UNORM:
      return PIPE_FORMAT_R8G8_UNORM;
   case MESA_FORMAT_R16G16_UNORM:
      return PIPE_FORMAT_R16G16_UNORM;
   case MESA_FORMAT_RGBA_UNORM16:
      return PIPE_FORMAT_R16G16B16A16_UNORM;

   /* signed int formats */
   case MESA_FORMAT_A_UINT8:
      return PIPE_FORMAT_A8_UINT;
   case MESA_FORMAT_A_UINT16:
      return PIPE_FORMAT_A16_UINT;
   case MESA_FORMAT_A_UINT32:
      return PIPE_FORMAT_A32_UINT;

   case MESA_FORMAT_A_SINT8:
      return PIPE_FORMAT_A8_SINT;
   case MESA_FORMAT_A_SINT16:
      return PIPE_FORMAT_A16_SINT;
   case MESA_FORMAT_A_SINT32:
      return PIPE_FORMAT_A32_SINT;

   case MESA_FORMAT_I_UINT8:
      return PIPE_FORMAT_I8_UINT;
   case MESA_FORMAT_I_UINT16:
      return PIPE_FORMAT_I16_UINT;
   case MESA_FORMAT_I_UINT32:
      return PIPE_FORMAT_I32_UINT;

   case MESA_FORMAT_I_SINT8:
      return PIPE_FORMAT_I8_SINT;
   case MESA_FORMAT_I_SINT16:
      return PIPE_FORMAT_I16_SINT;
   case MESA_FORMAT_I_SINT32:
      return PIPE_FORMAT_I32_SINT;

   case MESA_FORMAT_L_UINT8:
      return PIPE_FORMAT_L8_UINT;
   case MESA_FORMAT_L_UINT16:
      return PIPE_FORMAT_L16_UINT;
   case MESA_FORMAT_L_UINT32:
      return PIPE_FORMAT_L32_UINT;

   case MESA_FORMAT_L_SINT8:
      return PIPE_FORMAT_L8_SINT;
   case MESA_FORMAT_L_SINT16:
      return PIPE_FORMAT_L16_SINT;
   case MESA_FORMAT_L_SINT32:
      return PIPE_FORMAT_L32_SINT;

   case MESA_FORMAT_LA_UINT8:
      return PIPE_FORMAT_L8A8_UINT;
   case MESA_FORMAT_LA_UINT16:
      return PIPE_FORMAT_L16A16_UINT;
   case MESA_FORMAT_LA_UINT32:
      return PIPE_FORMAT_L32A32_UINT;

   case MESA_FORMAT_LA_SINT8:
      return PIPE_FORMAT_L8A8_SINT;
   case MESA_FORMAT_LA_SINT16:
      return PIPE_FORMAT_L16A16_SINT;
   case MESA_FORMAT_LA_SINT32:
      return PIPE_FORMAT_L32A32_SINT;

   case MESA_FORMAT_R_SINT8:
      return PIPE_FORMAT_R8_SINT;
   case MESA_FORMAT_RG_SINT8:
      return PIPE_FORMAT_R8G8_SINT;
   case MESA_FORMAT_RGB_SINT8:
      return PIPE_FORMAT_R8G8B8_SINT;
   case MESA_FORMAT_RGBA_SINT8:
      return PIPE_FORMAT_R8G8B8A8_SINT;
   case MESA_FORMAT_R_SINT16:
      return PIPE_FORMAT_R16_SINT;
   case MESA_FORMAT_RG_SINT16:
      return PIPE_FORMAT_R16G16_SINT;
   case MESA_FORMAT_RGB_SINT16:
      return PIPE_FORMAT_R16G16B16_SINT;
   case MESA_FORMAT_RGBA_SINT16:
      return PIPE_FORMAT_R16G16B16A16_SINT;
   case MESA_FORMAT_R_SINT32:
      return PIPE_FORMAT_R32_SINT;
   case MESA_FORMAT_RG_SINT32:
      return PIPE_FORMAT_R32G32_SINT;
   case MESA_FORMAT_RGB_SINT32:
      return PIPE_FORMAT_R32G32B32_SINT;
   case MESA_FORMAT_RGBA_SINT32:
      return PIPE_FORMAT_R32G32B32A32_SINT;

   /* unsigned int formats */
   case MESA_FORMAT_R_UINT8:
      return PIPE_FORMAT_R8_UINT;
   case MESA_FORMAT_RG_UINT8:
      return PIPE_FORMAT_R8G8_UINT;
   case MESA_FORMAT_RGB_UINT8:
      return PIPE_FORMAT_R8G8B8_UINT;
   case MESA_FORMAT_RGBA_UINT8:
      return PIPE_FORMAT_R8G8B8A8_UINT;
   case MESA_FORMAT_R_UINT16:
      return PIPE_FORMAT_R16_UINT;
   case MESA_FORMAT_RG_UINT16:
      return PIPE_FORMAT_R16G16_UINT;
   case MESA_FORMAT_RGB_UINT16:
      return PIPE_FORMAT_R16G16B16_UINT;
   case MESA_FORMAT_RGBA_UINT16:
      return PIPE_FORMAT_R16G16B16A16_UINT;
   case MESA_FORMAT_R_UINT32:
      return PIPE_FORMAT_R32_UINT;
   case MESA_FORMAT_RG_UINT32:
      return PIPE_FORMAT_R32G32_UINT;
   case MESA_FORMAT_RGB_UINT32:
      return PIPE_FORMAT_R32G32B32_UINT;
   case MESA_FORMAT_RGBA_UINT32:
      return PIPE_FORMAT_R32G32B32A32_UINT;

   case MESA_FORMAT_R_RGTC1_UNORM:
      return PIPE_FORMAT_RGTC1_UNORM;
   case MESA_FORMAT_R_RGTC1_SNORM:
      return PIPE_FORMAT_RGTC1_SNORM;
   case MESA_FORMAT_RG_RGTC2_UNORM:
      return PIPE_FORMAT_RGTC2_UNORM;
   case MESA_FORMAT_RG_RGTC2_SNORM:
      return PIPE_FORMAT_RGTC2_SNORM;

   case MESA_FORMAT_L_LATC1_UNORM:
      return PIPE_FORMAT_LATC1_UNORM;
   case MESA_FORMAT_L_LATC1_SNORM:
      return PIPE_FORMAT_LATC1_SNORM;
   case MESA_FORMAT_LA_LATC2_UNORM:
      return PIPE_FORMAT_LATC2_UNORM;
   case MESA_FORMAT_LA_LATC2_SNORM:
      return PIPE_FORMAT_LATC2_SNORM;

   case MESA_FORMAT_ETC1_RGB8:
      return PIPE_FORMAT_ETC1_RGB8;

   /* signed normalized formats */
   case MESA_FORMAT_R_SNORM8:
      return PIPE_FORMAT_R8_SNORM;
   case MESA_FORMAT_R8G8_SNORM:
      return PIPE_FORMAT_R8G8_SNORM;
   case MESA_FORMAT_R8G8B8A8_SNORM:
      return PIPE_FORMAT_R8G8B8A8_SNORM;

   case MESA_FORMAT_A_SNORM8:
      return PIPE_FORMAT_A8_SNORM;
   case MESA_FORMAT_L_SNORM8:
      return PIPE_FORMAT_L8_SNORM;
   case MESA_FORMAT_L8A8_SNORM:
      return PIPE_FORMAT_L8A8_SNORM;
   case MESA_FORMAT_I_SNORM8:
      return PIPE_FORMAT_I8_SNORM;

   case MESA_FORMAT_R_SNORM16:
      return PIPE_FORMAT_R16_SNORM;
   case MESA_FORMAT_R16G16_SNORM:
      return PIPE_FORMAT_R16G16_SNORM;
   case MESA_FORMAT_RGBA_SNORM16:
      return PIPE_FORMAT_R16G16B16A16_SNORM;

   case MESA_FORMAT_A_SNORM16:
      return PIPE_FORMAT_A16_SNORM;
   case MESA_FORMAT_L_SNORM16:
      return PIPE_FORMAT_L16_SNORM;
   case MESA_FORMAT_LA_SNORM16:
      return PIPE_FORMAT_L16A16_SNORM;
   case MESA_FORMAT_I_SNORM16:
      return PIPE_FORMAT_I16_SNORM;

   case MESA_FORMAT_R9G9B9E5_FLOAT:
      return PIPE_FORMAT_R9G9B9E5_FLOAT;
   case MESA_FORMAT_R11G11B10_FLOAT:
      return PIPE_FORMAT_R11G11B10_FLOAT;
   case MESA_FORMAT_B10G10R10A2_UINT:
      return PIPE_FORMAT_B10G10R10A2_UINT;
   case MESA_FORMAT_R10G10B10A2_UINT:
      return PIPE_FORMAT_R10G10B10A2_UINT;

   case MESA_FORMAT_B4G4R4X4_UNORM:
      return PIPE_FORMAT_B4G4R4X4_UNORM;
   case MESA_FORMAT_B5G5R5X1_UNORM:
      return PIPE_FORMAT_B5G5R5X1_UNORM;
   case MESA_FORMAT_R8G8B8X8_SNORM:
      return PIPE_FORMAT_R8G8B8X8_SNORM;
   case MESA_FORMAT_R8G8B8X8_SRGB:
      return PIPE_FORMAT_R8G8B8X8_SRGB;
   case MESA_FORMAT_RGBX_UINT8:
      return PIPE_FORMAT_R8G8B8X8_UINT;
   case MESA_FORMAT_RGBX_SINT8:
      return PIPE_FORMAT_R8G8B8X8_SINT;
   case MESA_FORMAT_B10G10R10X2_UNORM:
      return PIPE_FORMAT_B10G10R10X2_UNORM;
   case MESA_FORMAT_RGBX_UNORM16:
      return PIPE_FORMAT_R16G16B16X16_UNORM;
   case MESA_FORMAT_RGBX_SNORM16:
      return PIPE_FORMAT_R16G16B16X16_SNORM;
   case MESA_FORMAT_RGBX_FLOAT16:
      return PIPE_FORMAT_R16G16B16X16_FLOAT;
   case MESA_FORMAT_RGBX_UINT16:
      return PIPE_FORMAT_R16G16B16X16_UINT;
   case MESA_FORMAT_RGBX_SINT16:
      return PIPE_FORMAT_R16G16B16X16_SINT;
   case MESA_FORMAT_RGBX_FLOAT32:
      return PIPE_FORMAT_R32G32B32X32_FLOAT;
   case MESA_FORMAT_RGBX_UINT32:
      return PIPE_FORMAT_R32G32B32X32_UINT;
   case MESA_FORMAT_RGBX_SINT32:
      return PIPE_FORMAT_R32G32B32X32_SINT;

   case MESA_FORMAT_B8G8R8X8_SRGB:
      return PIPE_FORMAT_B8G8R8X8_SRGB;

   default:
      return PIPE_FORMAT_NONE;
   }
}


/**
 * Translate Gallium format to Mesa format.
 */
mesa_format
st_pipe_format_to_mesa_format(enum pipe_format format)
{
   switch (format) {
   case PIPE_FORMAT_ABGR8888_UNORM:
      return MESA_FORMAT_A8B8G8R8_UNORM;
   case PIPE_FORMAT_RGBA8888_UNORM:
      return MESA_FORMAT_R8G8B8A8_UNORM;
   case PIPE_FORMAT_BGRA8888_UNORM:
      return MESA_FORMAT_B8G8R8A8_UNORM;
   case PIPE_FORMAT_ARGB8888_UNORM:
      return MESA_FORMAT_A8R8G8B8_UNORM;
   case PIPE_FORMAT_XBGR8888_UNORM:
      return MESA_FORMAT_X8B8G8R8_UNORM;
   case PIPE_FORMAT_RGBX8888_UNORM:
      return MESA_FORMAT_R8G8B8X8_UNORM;
   case PIPE_FORMAT_BGRX8888_UNORM:
      return MESA_FORMAT_B8G8R8X8_UNORM;
   case PIPE_FORMAT_XRGB8888_UNORM:
      return MESA_FORMAT_X8R8G8B8_UNORM;
   case PIPE_FORMAT_B5G5R5A1_UNORM:
      return MESA_FORMAT_B5G5R5A1_UNORM;
   case PIPE_FORMAT_B4G4R4A4_UNORM:
      return MESA_FORMAT_B4G4R4A4_UNORM;
   case PIPE_FORMAT_B5G6R5_UNORM:
      return MESA_FORMAT_B5G6R5_UNORM;
   case PIPE_FORMAT_B2G3R3_UNORM:
      return MESA_FORMAT_B2G3R3_UNORM;
   case PIPE_FORMAT_B10G10R10A2_UNORM:
      return MESA_FORMAT_B10G10R10A2_UNORM;
   case PIPE_FORMAT_L4A4_UNORM:
      return MESA_FORMAT_L4A4_UNORM;
   case PIPE_FORMAT_L8A8_UNORM:
      return MESA_FORMAT_L8A8_UNORM;
   case PIPE_FORMAT_L16A16_UNORM:
      return MESA_FORMAT_L16A16_UNORM;
   case PIPE_FORMAT_A8_UNORM:
      return MESA_FORMAT_A_UNORM8;
   case PIPE_FORMAT_A16_UNORM:
      return MESA_FORMAT_A_UNORM16;
   case PIPE_FORMAT_L8_UNORM:
      return MESA_FORMAT_L_UNORM8;
   case PIPE_FORMAT_L16_UNORM:
      return MESA_FORMAT_L_UNORM16;
   case PIPE_FORMAT_I8_UNORM:
      return MESA_FORMAT_I_UNORM8;
   case PIPE_FORMAT_I16_UNORM:
      return MESA_FORMAT_I_UNORM16;
   case PIPE_FORMAT_S8_UINT:
      return MESA_FORMAT_S_UINT8;

   case PIPE_FORMAT_R16G16B16A16_UNORM:
      return MESA_FORMAT_RGBA_UNORM16;

   case PIPE_FORMAT_Z16_UNORM:
      return MESA_FORMAT_Z_UNORM16;
   case PIPE_FORMAT_Z32_UNORM:
      return MESA_FORMAT_Z_UNORM32;
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
      return MESA_FORMAT_S8_UINT_Z24_UNORM;
   case PIPE_FORMAT_X8Z24_UNORM:
      return MESA_FORMAT_X8_UINT_Z24_UNORM;
   case PIPE_FORMAT_Z24X8_UNORM:
      return MESA_FORMAT_Z24_UNORM_X8_UINT;
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
      return MESA_FORMAT_Z24_UNORM_S8_UINT;
   case PIPE_FORMAT_Z32_FLOAT:
      return MESA_FORMAT_Z_FLOAT32;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      return MESA_FORMAT_Z32_FLOAT_S8X24_UINT;

   case PIPE_FORMAT_UYVY:
      return MESA_FORMAT_YCBCR;
   case PIPE_FORMAT_YUYV:
      return MESA_FORMAT_YCBCR_REV;

   case PIPE_FORMAT_DXT1_RGB:
      return MESA_FORMAT_RGB_DXT1;
   case PIPE_FORMAT_DXT1_RGBA:
      return MESA_FORMAT_RGBA_DXT1;
   case PIPE_FORMAT_DXT3_RGBA:
      return MESA_FORMAT_RGBA_DXT3;
   case PIPE_FORMAT_DXT5_RGBA:
      return MESA_FORMAT_RGBA_DXT5;
   case PIPE_FORMAT_DXT1_SRGB:
      return MESA_FORMAT_SRGB_DXT1;
   case PIPE_FORMAT_DXT1_SRGBA:
      return MESA_FORMAT_SRGBA_DXT1;
   case PIPE_FORMAT_DXT3_SRGBA:
      return MESA_FORMAT_SRGBA_DXT3;
   case PIPE_FORMAT_DXT5_SRGBA:
      return MESA_FORMAT_SRGBA_DXT5;
   case PIPE_FORMAT_L8A8_SRGB:
      return MESA_FORMAT_L8A8_SRGB;
   case PIPE_FORMAT_L8_SRGB:
      return MESA_FORMAT_L_SRGB8;
   case PIPE_FORMAT_R8G8B8_SRGB:
      return MESA_FORMAT_BGR_SRGB8;
   case PIPE_FORMAT_A8B8G8R8_SRGB:
      return MESA_FORMAT_A8B8G8R8_SRGB;
   case PIPE_FORMAT_B8G8R8A8_SRGB:
      return MESA_FORMAT_B8G8R8A8_SRGB;
   case PIPE_FORMAT_R32G32B32A32_FLOAT:
      return MESA_FORMAT_RGBA_FLOAT32;
   case PIPE_FORMAT_R16G16B16A16_FLOAT:
      return MESA_FORMAT_RGBA_FLOAT16;
   case PIPE_FORMAT_R32G32B32_FLOAT:
      return MESA_FORMAT_RGB_FLOAT32;
   case PIPE_FORMAT_R16G16B16_FLOAT:
      return MESA_FORMAT_RGB_FLOAT16;
   case PIPE_FORMAT_L32A32_FLOAT:
      return MESA_FORMAT_LA_FLOAT32;
   case PIPE_FORMAT_L16A16_FLOAT:
      return MESA_FORMAT_LA_FLOAT16;
   case PIPE_FORMAT_L32_FLOAT:
      return MESA_FORMAT_L_FLOAT32;
   case PIPE_FORMAT_L16_FLOAT:
      return MESA_FORMAT_L_FLOAT16;
   case PIPE_FORMAT_A32_FLOAT:
      return MESA_FORMAT_A_FLOAT32;
   case PIPE_FORMAT_A16_FLOAT:
      return MESA_FORMAT_A_FLOAT16;
   case PIPE_FORMAT_I32_FLOAT:
      return MESA_FORMAT_I_FLOAT32;
   case PIPE_FORMAT_I16_FLOAT:
      return MESA_FORMAT_I_FLOAT16;
   case PIPE_FORMAT_R32_FLOAT:
      return MESA_FORMAT_R_FLOAT32;
   case PIPE_FORMAT_R16_FLOAT:
      return MESA_FORMAT_R_FLOAT16;
   case PIPE_FORMAT_R32G32_FLOAT:
      return MESA_FORMAT_RG_FLOAT32;
   case PIPE_FORMAT_R16G16_FLOAT:
      return MESA_FORMAT_RG_FLOAT16;

   case PIPE_FORMAT_R8_UNORM:
      return MESA_FORMAT_R_UNORM8;
   case PIPE_FORMAT_R16_UNORM:
      return MESA_FORMAT_R_UNORM16;
   case PIPE_FORMAT_R8G8_UNORM:
      return MESA_FORMAT_R8G8_UNORM;
   case PIPE_FORMAT_R16G16_UNORM:
      return MESA_FORMAT_R16G16_UNORM;

   case PIPE_FORMAT_A8_UINT:
      return MESA_FORMAT_A_UINT8;
   case PIPE_FORMAT_A16_UINT:
      return MESA_FORMAT_A_UINT16;
   case PIPE_FORMAT_A32_UINT:
      return MESA_FORMAT_A_UINT32;
   case PIPE_FORMAT_A8_SINT:
      return MESA_FORMAT_A_SINT8;
   case PIPE_FORMAT_A16_SINT:
      return MESA_FORMAT_A_SINT16;
   case PIPE_FORMAT_A32_SINT:
      return MESA_FORMAT_A_SINT32;

   case PIPE_FORMAT_I8_UINT:
      return MESA_FORMAT_I_UINT8;
   case PIPE_FORMAT_I16_UINT:
      return MESA_FORMAT_I_UINT16;
   case PIPE_FORMAT_I32_UINT:
      return MESA_FORMAT_I_UINT32;
   case PIPE_FORMAT_I8_SINT:
      return MESA_FORMAT_I_SINT8;
   case PIPE_FORMAT_I16_SINT:
      return MESA_FORMAT_I_SINT16;
   case PIPE_FORMAT_I32_SINT:
      return MESA_FORMAT_I_SINT32;

  case PIPE_FORMAT_L8_UINT:
      return MESA_FORMAT_L_UINT8;
   case PIPE_FORMAT_L16_UINT:
      return MESA_FORMAT_L_UINT16;
   case PIPE_FORMAT_L32_UINT:
      return MESA_FORMAT_L_UINT32;
   case PIPE_FORMAT_L8_SINT:
      return MESA_FORMAT_L_SINT8;
   case PIPE_FORMAT_L16_SINT:
      return MESA_FORMAT_L_SINT16;
   case PIPE_FORMAT_L32_SINT:
      return MESA_FORMAT_L_SINT32;

   case PIPE_FORMAT_L8A8_UINT:
      return MESA_FORMAT_LA_UINT8;
   case PIPE_FORMAT_L16A16_UINT:
      return MESA_FORMAT_LA_UINT16;
   case PIPE_FORMAT_L32A32_UINT:
      return MESA_FORMAT_LA_UINT32;
   case PIPE_FORMAT_L8A8_SINT:
      return MESA_FORMAT_LA_SINT8;
   case PIPE_FORMAT_L16A16_SINT:
      return MESA_FORMAT_LA_SINT16;
   case PIPE_FORMAT_L32A32_SINT:
      return MESA_FORMAT_LA_SINT32;

   case PIPE_FORMAT_R8_SINT:
      return MESA_FORMAT_R_SINT8;
   case PIPE_FORMAT_R8G8_SINT:
      return MESA_FORMAT_RG_SINT8;
   case PIPE_FORMAT_R8G8B8_SINT:
      return MESA_FORMAT_RGB_SINT8;
   case PIPE_FORMAT_R8G8B8A8_SINT:
      return MESA_FORMAT_RGBA_SINT8;

   case PIPE_FORMAT_R16_SINT:
      return MESA_FORMAT_R_SINT16;
   case PIPE_FORMAT_R16G16_SINT:
      return MESA_FORMAT_RG_SINT16;
   case PIPE_FORMAT_R16G16B16_SINT:
      return MESA_FORMAT_RGB_SINT16;
   case PIPE_FORMAT_R16G16B16A16_SINT:
      return MESA_FORMAT_RGBA_SINT16;

   case PIPE_FORMAT_R32_SINT:
      return MESA_FORMAT_R_SINT32;
   case PIPE_FORMAT_R32G32_SINT:
      return MESA_FORMAT_RG_SINT32;
   case PIPE_FORMAT_R32G32B32_SINT:
      return MESA_FORMAT_RGB_SINT32;
   case PIPE_FORMAT_R32G32B32A32_SINT:
      return MESA_FORMAT_RGBA_SINT32;

   /* unsigned int formats */
   case PIPE_FORMAT_R8_UINT:
      return MESA_FORMAT_R_UINT8;
   case PIPE_FORMAT_R8G8_UINT:
      return MESA_FORMAT_RG_UINT8;
   case PIPE_FORMAT_R8G8B8_UINT:
      return MESA_FORMAT_RGB_UINT8;
   case PIPE_FORMAT_R8G8B8A8_UINT:
      return MESA_FORMAT_RGBA_UINT8;

   case PIPE_FORMAT_R16_UINT:
      return MESA_FORMAT_R_UINT16;
   case PIPE_FORMAT_R16G16_UINT:
      return MESA_FORMAT_RG_UINT16;
   case PIPE_FORMAT_R16G16B16_UINT:
      return MESA_FORMAT_RGB_UINT16;
   case PIPE_FORMAT_R16G16B16A16_UINT:
      return MESA_FORMAT_RGBA_UINT16;

   case PIPE_FORMAT_R32_UINT:
      return MESA_FORMAT_R_UINT32;
   case PIPE_FORMAT_R32G32_UINT:
      return MESA_FORMAT_RG_UINT32;
   case PIPE_FORMAT_R32G32B32_UINT:
      return MESA_FORMAT_RGB_UINT32;
   case PIPE_FORMAT_R32G32B32A32_UINT:
      return MESA_FORMAT_RGBA_UINT32;

   case PIPE_FORMAT_RGTC1_UNORM:
      return MESA_FORMAT_R_RGTC1_UNORM;
   case PIPE_FORMAT_RGTC1_SNORM:
      return MESA_FORMAT_R_RGTC1_SNORM;
   case PIPE_FORMAT_RGTC2_UNORM:
      return MESA_FORMAT_RG_RGTC2_UNORM;
   case PIPE_FORMAT_RGTC2_SNORM:
      return MESA_FORMAT_RG_RGTC2_SNORM;

   case PIPE_FORMAT_LATC1_UNORM:
      return MESA_FORMAT_L_LATC1_UNORM;
   case PIPE_FORMAT_LATC1_SNORM:
      return MESA_FORMAT_L_LATC1_SNORM;
   case PIPE_FORMAT_LATC2_UNORM:
      return MESA_FORMAT_LA_LATC2_UNORM;
   case PIPE_FORMAT_LATC2_SNORM:
      return MESA_FORMAT_LA_LATC2_SNORM;

   case PIPE_FORMAT_ETC1_RGB8:
      return MESA_FORMAT_ETC1_RGB8;

   /* signed normalized formats */
   case PIPE_FORMAT_R8_SNORM:
      return MESA_FORMAT_R_SNORM8;
   case PIPE_FORMAT_R8G8_SNORM:
      return MESA_FORMAT_R8G8_SNORM;
   case PIPE_FORMAT_R8G8B8A8_SNORM:
      return MESA_FORMAT_R8G8B8A8_SNORM;

   case PIPE_FORMAT_A8_SNORM:
      return MESA_FORMAT_A_SNORM8;
   case PIPE_FORMAT_L8_SNORM:
      return MESA_FORMAT_L_SNORM8;
   case PIPE_FORMAT_L8A8_SNORM:
      return MESA_FORMAT_L8A8_SNORM;
   case PIPE_FORMAT_I8_SNORM:
      return MESA_FORMAT_I_SNORM8;

   case PIPE_FORMAT_R16_SNORM:
      return MESA_FORMAT_R_SNORM16;
   case PIPE_FORMAT_R16G16_SNORM:
      return MESA_FORMAT_R16G16_SNORM;
   case PIPE_FORMAT_R16G16B16A16_SNORM:
      return MESA_FORMAT_RGBA_SNORM16;

   case PIPE_FORMAT_A16_SNORM:
      return MESA_FORMAT_A_SNORM16;
   case PIPE_FORMAT_L16_SNORM:
      return MESA_FORMAT_L_SNORM16;
   case PIPE_FORMAT_L16A16_SNORM:
      return MESA_FORMAT_LA_SNORM16;
   case PIPE_FORMAT_I16_SNORM:
      return MESA_FORMAT_I_SNORM16;

   case PIPE_FORMAT_R9G9B9E5_FLOAT:
      return MESA_FORMAT_R9G9B9E5_FLOAT;
   case PIPE_FORMAT_R11G11B10_FLOAT:
      return MESA_FORMAT_R11G11B10_FLOAT;

   case PIPE_FORMAT_B10G10R10A2_UINT:
      return MESA_FORMAT_B10G10R10A2_UINT;
   case PIPE_FORMAT_R10G10B10A2_UINT:
      return MESA_FORMAT_R10G10B10A2_UINT;

   case PIPE_FORMAT_B4G4R4X4_UNORM:
      return MESA_FORMAT_B4G4R4X4_UNORM;
   case PIPE_FORMAT_B5G5R5X1_UNORM:
      return MESA_FORMAT_B5G5R5X1_UNORM;
   case PIPE_FORMAT_R8G8B8X8_SNORM:
      return MESA_FORMAT_R8G8B8X8_SNORM;
   case PIPE_FORMAT_R8G8B8X8_SRGB:
      return MESA_FORMAT_R8G8B8X8_SRGB;
   case PIPE_FORMAT_R8G8B8X8_UINT:
      return MESA_FORMAT_RGBX_UINT8;
   case PIPE_FORMAT_R8G8B8X8_SINT:
      return MESA_FORMAT_RGBX_SINT8;
   case PIPE_FORMAT_B10G10R10X2_UNORM:
      return MESA_FORMAT_B10G10R10X2_UNORM;
   case PIPE_FORMAT_R16G16B16X16_UNORM:
      return MESA_FORMAT_RGBX_UNORM16;
   case PIPE_FORMAT_R16G16B16X16_SNORM:
      return MESA_FORMAT_RGBX_SNORM16;
   case PIPE_FORMAT_R16G16B16X16_FLOAT:
      return MESA_FORMAT_RGBX_FLOAT16;
   case PIPE_FORMAT_R16G16B16X16_UINT:
      return MESA_FORMAT_RGBX_UINT16;
   case PIPE_FORMAT_R16G16B16X16_SINT:
      return MESA_FORMAT_RGBX_SINT16;
   case PIPE_FORMAT_R32G32B32X32_FLOAT:
      return MESA_FORMAT_RGBX_FLOAT32;
   case PIPE_FORMAT_R32G32B32X32_UINT:
      return MESA_FORMAT_RGBX_UINT32;
   case PIPE_FORMAT_R32G32B32X32_SINT:
      return MESA_FORMAT_RGBX_SINT32;

   case PIPE_FORMAT_B8G8R8X8_SRGB:
      return MESA_FORMAT_B8G8R8X8_SRGB;
   case PIPE_FORMAT_R8G8B8A8_SRGB:
      return MESA_FORMAT_R8G8B8A8_SRGB;

   default:
      return MESA_FORMAT_NONE;
   }
}


/**
 * Debug only: check that the two functions above correctly map
 * Mesa formats to Gallium formats and back again.
 */
static void
test_format_conversion(void)
{
   GLuint i;

   /* test all Mesa formats */
   for (i = 1; i < MESA_FORMAT_COUNT; i++) {
      enum pipe_format pf = st_mesa_format_to_pipe_format(i);
      if (pf != PIPE_FORMAT_NONE) {
         mesa_format mf = st_pipe_format_to_mesa_format(pf);
         assert(mf == i);
      }
   }

   /* Test all Gallium formats */
   for (i = 1; i < PIPE_FORMAT_COUNT; i++) {
      mesa_format mf = st_pipe_format_to_mesa_format(i);
      if (mf != MESA_FORMAT_NONE) {
         enum pipe_format pf = st_mesa_format_to_pipe_format(mf);
         assert(pf == i);
      }
   }
}


/**
 * Map GL texture formats to Gallium pipe formats.
 */
struct format_mapping
{
   GLenum glFormats[18];       /**< list of GLenum formats, 0-terminated */
   enum pipe_format pipeFormats[13]; /**< list of pipe formats, 0-terminated */
};


#define DEFAULT_RGBA_FORMATS \
      PIPE_FORMAT_B8G8R8A8_UNORM, \
      PIPE_FORMAT_R8G8B8A8_UNORM, \
      PIPE_FORMAT_A8R8G8B8_UNORM, \
      PIPE_FORMAT_A8B8G8R8_UNORM, \
      0

#define DEFAULT_RGB_FORMATS \
      PIPE_FORMAT_B8G8R8X8_UNORM, \
      PIPE_FORMAT_R8G8B8X8_UNORM, \
      PIPE_FORMAT_X8R8G8B8_UNORM, \
      PIPE_FORMAT_X8B8G8R8_UNORM, \
      PIPE_FORMAT_B5G6R5_UNORM, \
      DEFAULT_RGBA_FORMATS

#define DEFAULT_SRGBA_FORMATS \
      PIPE_FORMAT_B8G8R8A8_SRGB, \
      PIPE_FORMAT_A8R8G8B8_SRGB, \
      PIPE_FORMAT_A8B8G8R8_SRGB, \
      0

#define DEFAULT_DEPTH_FORMATS \
      PIPE_FORMAT_Z24X8_UNORM, \
      PIPE_FORMAT_X8Z24_UNORM, \
      PIPE_FORMAT_Z16_UNORM, \
      PIPE_FORMAT_Z24_UNORM_S8_UINT, \
      PIPE_FORMAT_S8_UINT_Z24_UNORM, \
      0

#define DEFAULT_SNORM8_RGBA_FORMATS \
      PIPE_FORMAT_R8G8B8A8_SNORM, \
      0

#define DEFAULT_UNORM16_RGBA_FORMATS \
      PIPE_FORMAT_R16G16B16A16_UNORM, \
      DEFAULT_RGBA_FORMATS


/**
 * This table maps OpenGL texture format enums to Gallium pipe_format enums.
 * Multiple GL enums might map to multiple pipe_formats.
 * The first pipe format in the list that's supported is the one that's chosen.
 */
static const struct format_mapping format_map[] = {
   /* Basic RGB, RGBA formats */
   {
      { GL_RGB10, 0 },
      { PIPE_FORMAT_B10G10R10X2_UNORM, PIPE_FORMAT_B10G10R10A2_UNORM,
        DEFAULT_RGB_FORMATS }
   },
   {
      { GL_RGB10_A2, 0 },
      { PIPE_FORMAT_B10G10R10A2_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { 4, GL_RGBA, GL_RGBA8, 0 },
      { PIPE_FORMAT_R8G8B8A8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_BGRA, 0 },
      { PIPE_FORMAT_B8G8R8A8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { 3, GL_RGB, GL_RGB8, 0 },
      { DEFAULT_RGB_FORMATS }
   },
   {
      { GL_RGB12, GL_RGB16, 0 },
      { PIPE_FORMAT_R16G16B16X16_UNORM, PIPE_FORMAT_R16G16B16A16_UNORM,
        DEFAULT_RGB_FORMATS }
   },
   {
      { GL_RGBA12, GL_RGBA16, 0 },
      { PIPE_FORMAT_R16G16B16A16_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_RGBA4, GL_RGBA2, 0 },
      { PIPE_FORMAT_B4G4R4A4_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_RGB5_A1, 0 },
      { PIPE_FORMAT_B5G5R5A1_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_R3_G3_B2, 0 },
      { PIPE_FORMAT_B2G3R3_UNORM, PIPE_FORMAT_B5G6R5_UNORM,
        PIPE_FORMAT_B5G5R5A1_UNORM, DEFAULT_RGB_FORMATS }
   },
   {
      { GL_RGB4 },
      { PIPE_FORMAT_B4G4R4X4_UNORM, PIPE_FORMAT_B4G4R4A4_UNORM,
        DEFAULT_RGB_FORMATS }
   },
   {
      { GL_RGB5 },
      { PIPE_FORMAT_B5G5R5X1_UNORM, PIPE_FORMAT_B5G5R5A1_UNORM,
        DEFAULT_RGB_FORMATS }
   },
   {
      { GL_RGB565 },
      { PIPE_FORMAT_B5G6R5_UNORM, DEFAULT_RGB_FORMATS }
   },

   /* basic Alpha formats */
   {
      { GL_ALPHA12, GL_ALPHA16, 0 },
      { PIPE_FORMAT_A16_UNORM, PIPE_FORMAT_A8_UNORM,
        DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_COMPRESSED_ALPHA, 0 },
      { PIPE_FORMAT_A8_UNORM, DEFAULT_RGBA_FORMATS }
   },

   /* basic Luminance formats */
   {
      { GL_LUMINANCE12, GL_LUMINANCE16, 0 },
      { PIPE_FORMAT_L16_UNORM, PIPE_FORMAT_L8_UNORM, DEFAULT_RGB_FORMATS }
   },
   {
      { 1, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, 0 },
      { PIPE_FORMAT_L8_UNORM, DEFAULT_RGB_FORMATS }
   },

   /* basic Luminance/Alpha formats */
   {
      { GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12,
        GL_LUMINANCE16_ALPHA16, 0},
      { PIPE_FORMAT_L16A16_UNORM, PIPE_FORMAT_L8A8_UNORM,
        DEFAULT_RGBA_FORMATS }
   },
   {
      { 2, GL_LUMINANCE_ALPHA, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, 0 },
      { PIPE_FORMAT_L8A8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_LUMINANCE4_ALPHA4, 0 },
      { PIPE_FORMAT_L4A4_UNORM, PIPE_FORMAT_L8A8_UNORM,
        DEFAULT_RGBA_FORMATS }
   },

   /* basic Intensity formats */
   {
      { GL_INTENSITY12, GL_INTENSITY16, 0 },
      { PIPE_FORMAT_I16_UNORM, PIPE_FORMAT_I8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8,
        GL_COMPRESSED_INTENSITY, 0 },
      { PIPE_FORMAT_I8_UNORM, DEFAULT_RGBA_FORMATS }
   },

   /* YCbCr */
   {
      { GL_YCBCR_MESA, 0 },
      { PIPE_FORMAT_UYVY, PIPE_FORMAT_YUYV, 0 }
   },

   /* compressed formats */ /* XXX PIPE_BIND_SAMPLER_VIEW only */
   {
      { GL_COMPRESSED_RGB, 0 },
      { PIPE_FORMAT_DXT1_RGB, DEFAULT_RGB_FORMATS }
   },
   {
      { GL_COMPRESSED_RGBA, 0 },
      { PIPE_FORMAT_DXT5_RGBA, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_RGB_S3TC, GL_RGB4_S3TC, GL_COMPRESSED_RGB_S3TC_DXT1_EXT, 0 },
      { PIPE_FORMAT_DXT1_RGB, 0 }
   },
   {
      { GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, 0 },
      { PIPE_FORMAT_DXT1_RGBA, 0 }
   },
   {
      { GL_RGBA_S3TC, GL_RGBA4_S3TC, GL_COMPRESSED_RGBA_S3TC_DXT3_EXT, 0 },
      { PIPE_FORMAT_DXT3_RGBA, 0 }
   },
   {
      { GL_COMPRESSED_RGBA_S3TC_DXT5_EXT, 0 },
      { PIPE_FORMAT_DXT5_RGBA, 0 }
   },

#if 0
   {
      { GL_COMPRESSED_RGB_FXT1_3DFX, 0 },
      { PIPE_FORMAT_RGB_FXT1, 0 }
   },
   {
      { GL_COMPRESSED_RGBA_FXT1_3DFX, 0 },
      { PIPE_FORMAT_RGBA_FXT1, 0 }
   },
#endif

   /* Depth formats */
   {
      { GL_DEPTH_COMPONENT16, 0 },
      { PIPE_FORMAT_Z16_UNORM, DEFAULT_DEPTH_FORMATS }
   },
   {
      { GL_DEPTH_COMPONENT24, 0 },
      { PIPE_FORMAT_Z24X8_UNORM, PIPE_FORMAT_X8Z24_UNORM,
        DEFAULT_DEPTH_FORMATS }
   },
   {
      { GL_DEPTH_COMPONENT32, 0 },
      { PIPE_FORMAT_Z32_UNORM, DEFAULT_DEPTH_FORMATS }
   },
   {
      { GL_DEPTH_COMPONENT, 0 },
      { DEFAULT_DEPTH_FORMATS }
   },
   {
      { GL_DEPTH_COMPONENT32F, 0 },
      { PIPE_FORMAT_Z32_FLOAT, 0 }
   },

   /* stencil formats */
   {
      { GL_STENCIL_INDEX, GL_STENCIL_INDEX1_EXT, GL_STENCIL_INDEX4_EXT,
        GL_STENCIL_INDEX8_EXT, GL_STENCIL_INDEX16_EXT, 0 },
      {
         PIPE_FORMAT_S8_UINT, PIPE_FORMAT_Z24_UNORM_S8_UINT,
         PIPE_FORMAT_S8_UINT_Z24_UNORM, 0
      }
   },

   /* Depth / Stencil formats */
   {
      { GL_DEPTH_STENCIL_EXT, GL_DEPTH24_STENCIL8_EXT, 0 },
      { PIPE_FORMAT_Z24_UNORM_S8_UINT, PIPE_FORMAT_S8_UINT_Z24_UNORM, 0 }
   },
   {
      { GL_DEPTH32F_STENCIL8, 0 },
      { PIPE_FORMAT_Z32_FLOAT_S8X24_UINT, 0 }
   },

   /* sRGB formats */
   {
      { GL_SRGB_EXT, GL_SRGB8_EXT, 0 },
      { PIPE_FORMAT_R8G8B8X8_SRGB, PIPE_FORMAT_B8G8R8X8_SRGB,
        DEFAULT_SRGBA_FORMATS }
   },
   {
      { GL_SRGB_ALPHA_EXT, GL_SRGB8_ALPHA8_EXT, 0 },
      { DEFAULT_SRGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_SRGB_EXT, GL_COMPRESSED_SRGB_S3TC_DXT1_EXT, 0 },
      { PIPE_FORMAT_DXT1_SRGB, PIPE_FORMAT_R8G8B8X8_SRGB,
        PIPE_FORMAT_B8G8R8X8_SRGB, DEFAULT_SRGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, 0 },
      { PIPE_FORMAT_DXT1_SRGBA, 0 }
   },
   {
      { GL_COMPRESSED_SRGB_ALPHA_EXT,
        GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, 0 },
      { PIPE_FORMAT_DXT3_SRGBA, DEFAULT_SRGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, 0 },
      { PIPE_FORMAT_DXT5_SRGBA, 0 }
   },
   {
      { GL_SLUMINANCE_ALPHA_EXT, GL_SLUMINANCE8_ALPHA8_EXT,
        GL_COMPRESSED_SLUMINANCE_ALPHA_EXT, 0 },
      { PIPE_FORMAT_L8A8_SRGB, DEFAULT_SRGBA_FORMATS }
   },
   {
      { GL_SLUMINANCE_EXT, GL_SLUMINANCE8_EXT, GL_COMPRESSED_SLUMINANCE_EXT,
        0 },
      { PIPE_FORMAT_L8_SRGB, DEFAULT_SRGBA_FORMATS }
   },

   /* 16-bit float formats */
   {
      { GL_RGBA16F_ARB, 0 },
      { PIPE_FORMAT_R16G16B16A16_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },
   {
      { GL_RGB16F_ARB, 0 },
      { PIPE_FORMAT_R16G16B16_FLOAT, PIPE_FORMAT_R16G16B16X16_FLOAT,
        PIPE_FORMAT_R16G16B16A16_FLOAT,
        PIPE_FORMAT_R32G32B32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA16F_ARB, 0 },
      { PIPE_FORMAT_L16A16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT,
        PIPE_FORMAT_L32A32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },
   {
      { GL_ALPHA16F_ARB, 0 },
      { PIPE_FORMAT_A16_FLOAT, PIPE_FORMAT_L16A16_FLOAT,
        PIPE_FORMAT_A32_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT,
        PIPE_FORMAT_L32A32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },
   {
      { GL_INTENSITY16F_ARB, 0 },
      { PIPE_FORMAT_I16_FLOAT, PIPE_FORMAT_L16A16_FLOAT,
        PIPE_FORMAT_I32_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT,
        PIPE_FORMAT_L32A32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },
   {
      { GL_LUMINANCE16F_ARB, 0 },
      { PIPE_FORMAT_L16_FLOAT, PIPE_FORMAT_L16A16_FLOAT,
        PIPE_FORMAT_L32_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT,
        PIPE_FORMAT_L32A32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },
   {
      { GL_R16F, 0 },
      { PIPE_FORMAT_R16_FLOAT, PIPE_FORMAT_R16G16_FLOAT,
        PIPE_FORMAT_R32_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT,
        PIPE_FORMAT_R32G32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },
   {
      { GL_RG16F, 0 },
      { PIPE_FORMAT_R16G16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT,
        PIPE_FORMAT_R32G32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },

   /* 32-bit float formats */
   {
      { GL_RGBA32F_ARB, 0 },
      { PIPE_FORMAT_R32G32B32A32_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },
   {
      { GL_RGB32F_ARB, 0 },
      { PIPE_FORMAT_R32G32B32_FLOAT, PIPE_FORMAT_R32G32B32X32_FLOAT,
        PIPE_FORMAT_R32G32B32A32_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA32F_ARB, 0 },
      { PIPE_FORMAT_L32A32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT,
        PIPE_FORMAT_L16A16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },
   {
      { GL_ALPHA32F_ARB, 0 },
      { PIPE_FORMAT_A32_FLOAT, PIPE_FORMAT_L32A32_FLOAT,
        PIPE_FORMAT_R32G32B32A32_FLOAT, PIPE_FORMAT_A16_FLOAT,
        PIPE_FORMAT_L16A16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },
   {
      { GL_INTENSITY32F_ARB, 0 },
      { PIPE_FORMAT_I32_FLOAT, PIPE_FORMAT_L32A32_FLOAT,
        PIPE_FORMAT_R32G32B32A32_FLOAT, PIPE_FORMAT_I16_FLOAT,
        PIPE_FORMAT_L16A16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },
   {
      { GL_LUMINANCE32F_ARB, 0 },
      { PIPE_FORMAT_L32_FLOAT, PIPE_FORMAT_L32A32_FLOAT,
        PIPE_FORMAT_R32G32B32A32_FLOAT, PIPE_FORMAT_L16_FLOAT,
        PIPE_FORMAT_L16A16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },
   {
      { GL_R32F, 0 },
      { PIPE_FORMAT_R32_FLOAT, PIPE_FORMAT_R32G32_FLOAT,
        PIPE_FORMAT_R32G32B32A32_FLOAT, PIPE_FORMAT_R16_FLOAT,
        PIPE_FORMAT_R16G16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },
   {
      { GL_RG32F, 0 },
      { PIPE_FORMAT_R32G32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT,
        PIPE_FORMAT_R16G16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },

   /* R, RG formats */
   {
      { GL_RED, GL_R8, 0 },
      { PIPE_FORMAT_R8_UNORM, PIPE_FORMAT_R8G8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_RG, GL_RG8, 0 },
      { PIPE_FORMAT_R8G8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_R16, 0 },
      { PIPE_FORMAT_R16_UNORM, PIPE_FORMAT_R16G16_UNORM,
        DEFAULT_UNORM16_RGBA_FORMATS }
   },
   {
      { GL_RG16, 0 },
      { PIPE_FORMAT_R16G16_UNORM, DEFAULT_UNORM16_RGBA_FORMATS }
   },

   /* compressed R, RG formats */
   {
      { GL_COMPRESSED_RED, GL_COMPRESSED_RED_RGTC1, 0 },
      { PIPE_FORMAT_RGTC1_UNORM, PIPE_FORMAT_R8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_SIGNED_RED_RGTC1, 0 },
      { PIPE_FORMAT_RGTC1_SNORM, DEFAULT_SNORM8_RGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_RG, GL_COMPRESSED_RG_RGTC2, 0 },
      { PIPE_FORMAT_RGTC2_UNORM, PIPE_FORMAT_R8G8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_SIGNED_RG_RGTC2, 0 },
      { PIPE_FORMAT_RGTC2_SNORM, DEFAULT_SNORM8_RGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_LATC1_EXT, 0 },
      { PIPE_FORMAT_LATC1_UNORM, PIPE_FORMAT_L8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT, 0 },
      { PIPE_FORMAT_LATC1_SNORM, DEFAULT_SNORM8_RGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT,
        GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI, 0 },
      { PIPE_FORMAT_LATC2_UNORM, PIPE_FORMAT_L8A8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT, 0 },
      { PIPE_FORMAT_LATC2_SNORM, DEFAULT_SNORM8_RGBA_FORMATS }
   },

   /* ETC1 */
   {
      { GL_ETC1_RGB8_OES, 0 },
      { PIPE_FORMAT_ETC1_RGB8, 0 }
   },

   /* signed/unsigned integer formats.
    */
   {
      { GL_RGBA_INTEGER_EXT,
        GL_BGRA_INTEGER_EXT,
        GL_RGBA8I_EXT, 0 },
      { PIPE_FORMAT_R8G8B8A8_SINT, 0 }
   },
   {
      { GL_RGB_INTEGER_EXT, 
        GL_BGR_INTEGER_EXT,
        GL_RGB8I_EXT,
        GL_BLUE_INTEGER_EXT, 0 },
      { PIPE_FORMAT_R8G8B8_SINT, PIPE_FORMAT_R8G8B8X8_SINT,
        PIPE_FORMAT_R8G8B8A8_SINT, 0 }
   },
   {
      { GL_ALPHA_INTEGER_EXT,
        GL_ALPHA8I_EXT, 0 },
      { PIPE_FORMAT_A8_SINT, 0 }
   },
   {
      { GL_ALPHA16I_EXT, 0 },
      { PIPE_FORMAT_A16_SINT, 0 }
   },
   {
      { GL_ALPHA32I_EXT, 0 },
      { PIPE_FORMAT_A32_SINT, 0 }
   },
   {
      { GL_ALPHA8UI_EXT, 0 },
      { PIPE_FORMAT_A8_UINT, 0 }
   },
   {
      { GL_ALPHA16UI_EXT, 0 },
      { PIPE_FORMAT_A16_UINT, 0 }
   },
   {
      { GL_ALPHA32UI_EXT, 0 },
      { PIPE_FORMAT_A32_UINT, 0 }
   },
   {
      { GL_INTENSITY8I_EXT, 0 },
      { PIPE_FORMAT_I8_SINT, 0 }
   },
   {
      { GL_INTENSITY16I_EXT, 0 },
      { PIPE_FORMAT_I16_SINT, 0 }
   },
   {
      { GL_INTENSITY32I_EXT, 0 },
      { PIPE_FORMAT_I32_SINT, 0 }
   },
   {
      { GL_INTENSITY8UI_EXT, 0 },
      { PIPE_FORMAT_I8_UINT, 0 }
   },
   {
      { GL_INTENSITY16UI_EXT, 0 },
      { PIPE_FORMAT_I16_UINT, 0 }
   },
   {
      { GL_INTENSITY32UI_EXT, 0 },
      { PIPE_FORMAT_I32_UINT, 0 }
   },
   {
      { GL_LUMINANCE8I_EXT, 0 },
      { PIPE_FORMAT_L8_SINT, 0 }
   },
   {
      { GL_LUMINANCE16I_EXT, 0 },
      { PIPE_FORMAT_L16_SINT, 0 }
   },
   {
      { GL_LUMINANCE32I_EXT, 0 },
      { PIPE_FORMAT_L32_SINT, 0 }
   },
   {
      { GL_LUMINANCE_INTEGER_EXT,
        GL_LUMINANCE8UI_EXT, 0 },
      { PIPE_FORMAT_L8_UINT, 0 }
   },
   {
      { GL_LUMINANCE16UI_EXT, 0 },
      { PIPE_FORMAT_L16_UINT, 0 }
   },
   {
      { GL_LUMINANCE32UI_EXT, 0 },
      { PIPE_FORMAT_L32_UINT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA_INTEGER_EXT,
        GL_LUMINANCE_ALPHA8I_EXT, 0 },
      { PIPE_FORMAT_L8A8_SINT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA16I_EXT, 0 },
      { PIPE_FORMAT_L16A16_SINT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA32I_EXT, 0 },
      { PIPE_FORMAT_L32A32_SINT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA8UI_EXT, 0 },
      { PIPE_FORMAT_L8A8_UINT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA16UI_EXT, 0 },
      { PIPE_FORMAT_L16A16_UINT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA32UI_EXT, 0 },
      { PIPE_FORMAT_L32A32_UINT, 0 }
   },
   {
      { GL_RGB16I_EXT, 0 },
      { PIPE_FORMAT_R16G16B16_SINT, PIPE_FORMAT_R16G16B16X16_SINT,
        PIPE_FORMAT_R16G16B16A16_SINT, 0 },
   },
   {
      { GL_RGBA16I_EXT, 0 },
      { PIPE_FORMAT_R16G16B16A16_SINT, 0 },
   },
   {
      { GL_RGB32I_EXT, 0 },
      { PIPE_FORMAT_R32G32B32_SINT, PIPE_FORMAT_R32G32B32X32_SINT,
        PIPE_FORMAT_R32G32B32A32_SINT, 0 },
   },
   {
      { GL_RGBA32I_EXT, 0 },
      { PIPE_FORMAT_R32G32B32A32_SINT, 0 }
   },
   {
      { GL_RGBA8UI_EXT, 0 },
      { PIPE_FORMAT_R8G8B8A8_UINT, 0 }
   },
   {
      { GL_RGB8UI_EXT, 0 },
      { PIPE_FORMAT_R8G8B8_UINT, PIPE_FORMAT_R8G8B8X8_UINT,
        PIPE_FORMAT_R8G8B8A8_UINT, 0 }
   },
   {
      { GL_RGB16UI_EXT, 0 },
      { PIPE_FORMAT_R16G16B16_UINT, PIPE_FORMAT_R16G16B16X16_UINT,
        PIPE_FORMAT_R16G16B16A16_UINT, 0 }
   },
   {
      { GL_RGBA16UI_EXT, 0 },
      { PIPE_FORMAT_R16G16B16A16_UINT, 0 }
   },
   {
      { GL_RGB32UI_EXT, 0},
      { PIPE_FORMAT_R32G32B32_UINT, PIPE_FORMAT_R32G32B32X32_UINT,
        PIPE_FORMAT_R32G32B32A32_UINT, 0 }
   },
   {
      { GL_RGBA32UI_EXT, 0},
      { PIPE_FORMAT_R32G32B32A32_UINT, 0 }
   },
   {
     { GL_R8I, GL_RED_INTEGER_EXT, 0},
     { PIPE_FORMAT_R8_SINT, 0},
   },
   {
     { GL_R16I, 0},
     { PIPE_FORMAT_R16_SINT, 0},
   },
   {
     { GL_R32I, 0},
     { PIPE_FORMAT_R32_SINT, 0},
   },
  {
     { GL_R8UI, 0},
     { PIPE_FORMAT_R8_UINT, 0},
   },
   {
     { GL_R16UI, 0},
     { PIPE_FORMAT_R16_UINT, 0},
   },
   {
     { GL_R32UI, 0},
     { PIPE_FORMAT_R32_UINT, 0},
   },
   {
     { GL_RG8I, GL_GREEN_INTEGER_EXT, 0},
     { PIPE_FORMAT_R8G8_SINT, 0},
   },
   {
     { GL_RG16I, 0},
     { PIPE_FORMAT_R16G16_SINT, 0},
   },
   {
     { GL_RG32I, 0},
     { PIPE_FORMAT_R32G32_SINT, 0},
   },
  {
     { GL_RG8UI, 0},
     { PIPE_FORMAT_R8G8_UINT, 0},
   },
   {
     { GL_RG16UI, 0},
     { PIPE_FORMAT_R16G16_UINT, 0},
   },
   {
     { GL_RG32UI, 0},
     { PIPE_FORMAT_R32G32_UINT, 0},
   },
   /* signed normalized formats */
   {
      { GL_RED_SNORM, GL_R8_SNORM, 0 },
      { PIPE_FORMAT_R8_SNORM, PIPE_FORMAT_R8G8_SNORM,
        PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_R16_SNORM, 0 },
      { PIPE_FORMAT_R16_SNORM,
        PIPE_FORMAT_R16G16_SNORM,
        PIPE_FORMAT_R16G16B16A16_SNORM,
        PIPE_FORMAT_R8_SNORM,
        PIPE_FORMAT_R8G8_SNORM,
        PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_RG_SNORM, GL_RG8_SNORM, 0 },
      { PIPE_FORMAT_R8G8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_RG16_SNORM, 0 },
      { PIPE_FORMAT_R16G16_SNORM, PIPE_FORMAT_R16G16B16A16_SNORM,
        PIPE_FORMAT_R8G8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_RGB_SNORM, GL_RGB8_SNORM, 0 },
      { PIPE_FORMAT_R8G8B8X8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_RGBA_SNORM, GL_RGBA8_SNORM, 0 },
      { PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_RGB16_SNORM, 0 },
      { PIPE_FORMAT_R16G16B16X16_SNORM, PIPE_FORMAT_R16G16B16A16_SNORM,
        PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_RGBA16_SNORM, 0 },
      { PIPE_FORMAT_R16G16B16A16_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_ALPHA_SNORM, GL_ALPHA8_SNORM, 0 },
      { PIPE_FORMAT_A8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_ALPHA16_SNORM, 0 },
      { PIPE_FORMAT_A16_SNORM, PIPE_FORMAT_R16G16B16A16_SNORM,
        PIPE_FORMAT_A8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_LUMINANCE_SNORM, GL_LUMINANCE8_SNORM, 0 },
      { PIPE_FORMAT_L8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_LUMINANCE16_SNORM, 0 },
      { PIPE_FORMAT_L16_SNORM, PIPE_FORMAT_R16G16B16A16_SNORM,
        PIPE_FORMAT_L8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA_SNORM, GL_LUMINANCE8_ALPHA8_SNORM, 0 },
      { PIPE_FORMAT_L8A8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_LUMINANCE16_ALPHA16_SNORM, 0 },
      { PIPE_FORMAT_L16A16_SNORM, PIPE_FORMAT_R16G16B16A16_SNORM,
        PIPE_FORMAT_L8A8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_INTENSITY_SNORM, GL_INTENSITY8_SNORM, 0 },
      { PIPE_FORMAT_I8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_INTENSITY16_SNORM, 0 },
      { PIPE_FORMAT_I16_SNORM, PIPE_FORMAT_R16G16B16A16_SNORM,
        PIPE_FORMAT_I8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_RGB9_E5, 0 },
      { PIPE_FORMAT_R9G9B9E5_FLOAT, 0 }
   },
   {
      { GL_R11F_G11F_B10F, 0 },
      { PIPE_FORMAT_R11G11B10_FLOAT, 0 }
   },
   {
      { GL_RGB10_A2UI, 0 },
      { PIPE_FORMAT_R10G10B10A2_UINT, PIPE_FORMAT_B10G10R10A2_UINT, 0 }
   },
};


/**
 * Return first supported format from the given list.
 * \param allow_dxt  indicates whether it's OK to return a DXT format.
 */
static enum pipe_format
find_supported_format(struct pipe_screen *screen,
                      const enum pipe_format formats[],
                      enum pipe_texture_target target,
                      unsigned sample_count,
                      unsigned tex_usage,
                      boolean allow_dxt)
{
   uint i;
   for (i = 0; formats[i]; i++) {
      if (screen->is_format_supported(screen, formats[i], target,
                                      sample_count, tex_usage)) {
         if (!allow_dxt && util_format_is_s3tc(formats[i])) {
            /* we can't return a dxt format, continue searching */
            continue;
         }

         return formats[i];
      }
   }
   return PIPE_FORMAT_NONE;
}

struct exact_format_mapping
{
   GLenum format;
   GLenum type;
   enum pipe_format pformat;
};

static const struct exact_format_mapping rgba8888_tbl[] =
{
   { GL_RGBA,     GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_ABGR8888_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_ABGR8888_UNORM },
   { GL_RGBA,     GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_RGBA8888_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_RGBA8888_UNORM },
   { GL_BGRA,     GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_ARGB8888_UNORM },
   { GL_BGRA,     GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_BGRA8888_UNORM },
   { GL_RGBA,     GL_UNSIGNED_BYTE,               PIPE_FORMAT_R8G8B8A8_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_BYTE,               PIPE_FORMAT_A8B8G8R8_UNORM },
   { GL_BGRA,     GL_UNSIGNED_BYTE,               PIPE_FORMAT_B8G8R8A8_UNORM },
   { 0,           0,                              0                          }
};

static const struct exact_format_mapping rgbx8888_tbl[] =
{
   { GL_RGBA,     GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_XBGR8888_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_XBGR8888_UNORM },
   { GL_RGBA,     GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_RGBX8888_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_RGBX8888_UNORM },
   { GL_BGRA,     GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_XRGB8888_UNORM },
   { GL_BGRA,     GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_BGRX8888_UNORM },
   { GL_RGBA,     GL_UNSIGNED_BYTE,               PIPE_FORMAT_R8G8B8X8_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_BYTE,               PIPE_FORMAT_X8B8G8R8_UNORM },
   { GL_BGRA,     GL_UNSIGNED_BYTE,               PIPE_FORMAT_B8G8R8X8_UNORM },
   { 0,           0,                              0                          }
};

static const struct exact_format_mapping rgba1010102_tbl[] =
{
   { GL_BGRA,     GL_UNSIGNED_INT_2_10_10_10_REV, PIPE_FORMAT_B10G10R10A2_UNORM },
   /* No Mesa formats for these Gallium formats:
   { GL_RGBA,     GL_UNSIGNED_INT_2_10_10_10_REV, PIPE_FORMAT_R10G10B10A2_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT_10_10_10_2,     PIPE_FORMAT_R10G10B10A2_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT,                PIPE_FORMAT_R10G10B10A2_UNORM },
   */
   { 0,           0,                              0                             }
};

/**
 * If there is an exact pipe_format match for {internalFormat, format, type}
 * return that, otherwise return PIPE_FORMAT_NONE so we can do fuzzy matching.
 */
static enum pipe_format
find_exact_format(GLint internalFormat, GLenum format, GLenum type)
{
   uint i;
   const struct exact_format_mapping* tbl;

   if (format == GL_NONE || type == GL_NONE)
      return PIPE_FORMAT_NONE;

   switch (internalFormat) {
   case 4:
   case GL_RGBA:
   case GL_RGBA8:
      tbl = rgba8888_tbl;
      break;
   case 3:
   case GL_RGB:
   case GL_RGB8:
      tbl = rgbx8888_tbl;
      break;
   case GL_RGB10_A2:
      tbl = rgba1010102_tbl;
      break;
   default:
      return PIPE_FORMAT_NONE;
   }

   for (i = 0; tbl[i].format; i++)
      if (tbl[i].format == format && tbl[i].type == type)
         return tbl[i].pformat;

   return PIPE_FORMAT_NONE;
}

/**
 * Given an OpenGL internalFormat value for a texture or surface, return
 * the best matching PIPE_FORMAT_x, or PIPE_FORMAT_NONE if there's no match.
 * This is called during glTexImage2D, for example.
 *
 * The bindings parameter typically has PIPE_BIND_SAMPLER_VIEW set, plus
 * either PIPE_BINDING_RENDER_TARGET or PIPE_BINDING_DEPTH_STENCIL if
 * we want render-to-texture ability.
 *
 * \param internalFormat  the user value passed to glTexImage2D
 * \param target  one of PIPE_TEXTURE_x
 * \param bindings  bitmask of PIPE_BIND_x flags.
 * \param allow_dxt  indicates whether it's OK to return a DXT format.  This
 *                   only matters when internalFormat names a generic or
 *                   specific compressed format.  And that should only happen
 *                   when we're getting called from gl[Copy]TexImage().
 */
enum pipe_format
st_choose_format(struct st_context *st, GLenum internalFormat,
                 GLenum format, GLenum type,
                 enum pipe_texture_target target, unsigned sample_count,
                 unsigned bindings, boolean allow_dxt)
{
   struct pipe_screen *screen = st->pipe->screen;
   int i, j;
   enum pipe_format pf;

#ifdef DEBUG
   {
      static boolean firstCall = TRUE;
      if (firstCall) {
         test_format_conversion();
         firstCall = FALSE;
      }
   }
#else
   (void) test_format_conversion;
#endif

   /* can't render to compressed formats at this time */
   if (_mesa_is_compressed_format(st->ctx, internalFormat)
       && (bindings & ~PIPE_BIND_SAMPLER_VIEW)) {
      return PIPE_FORMAT_NONE;
   }

   /* search for exact matches */
   pf = find_exact_format(internalFormat, format, type);
   if (pf != PIPE_FORMAT_NONE &&
       screen->is_format_supported(screen, pf,
                                   target, sample_count, bindings))
      return pf;

   /* search table for internalFormat */
   for (i = 0; i < Elements(format_map); i++) {
      const struct format_mapping *mapping = &format_map[i];
      for (j = 0; mapping->glFormats[j]; j++) {
         if (mapping->glFormats[j] == internalFormat) {
            /* Found the desired internal format.  Find first pipe format
             * which is supported by the driver.
             */
            return find_supported_format(screen, mapping->pipeFormats,
                                         target, sample_count, bindings,
                                         allow_dxt);
         }
      }
   }

   _mesa_problem(NULL, "unhandled format!\n");
   return PIPE_FORMAT_NONE;
}


/**
 * Called by FBO code to choose a PIPE_FORMAT_ for drawing surfaces.
 */
enum pipe_format
st_choose_renderbuffer_format(struct st_context *st,
                              GLenum internalFormat, unsigned sample_count)
{
   uint usage;
   if (_mesa_is_depth_or_stencil_format(internalFormat))
      usage = PIPE_BIND_DEPTH_STENCIL;
   else
      usage = PIPE_BIND_RENDER_TARGET;
   return st_choose_format(st, internalFormat, GL_NONE, GL_NONE,
                           PIPE_TEXTURE_2D, sample_count, usage, FALSE);
}


/**
 * Given an OpenGL user-requested format and type, and swapBytes state,
 * return the format which exactly matches those parameters, so that
 * a memcpy-based transfer can be done.
 *
 * If no format is supported, return PIPE_FORMAT_NONE.
 */
enum pipe_format
st_choose_matching_format(struct pipe_screen *screen, unsigned bind,
			  GLenum format, GLenum type, GLboolean swapBytes)
{
   mesa_format mesa_format;

   for (mesa_format = 1; mesa_format < MESA_FORMAT_COUNT; mesa_format++) {
      if (_mesa_get_format_color_encoding(mesa_format) == GL_SRGB) {
         continue;
      }
      if (_mesa_get_format_bits(mesa_format, GL_TEXTURE_INTENSITY_SIZE) > 0) {
         /* If `format` is GL_RED/GL_RED_INTEGER, then we might match some
          * intensity formats, which we don't want.
          */
         continue;
      }

      if (_mesa_format_matches_format_and_type(mesa_format, format, type,
                                               swapBytes)) {
         enum pipe_format format = st_mesa_format_to_pipe_format(mesa_format);

         if (format &&
             screen->is_format_supported(screen, format, PIPE_TEXTURE_2D, 0,
                                         bind)) {
            return format;
         }
         /* It's unlikely to find 2 matching Mesa formats. */
         break;
      }
   }
   return PIPE_FORMAT_NONE;
}


/**
 * Called via ctx->Driver.ChooseTextureFormat().
 */
mesa_format
st_ChooseTextureFormat(struct gl_context *ctx, GLenum target,
                       GLint internalFormat,
                       GLenum format, GLenum type)
{
   const boolean want_renderable =
      internalFormat == 3 || internalFormat == 4 ||
      internalFormat == GL_RGB || internalFormat == GL_RGBA ||
      internalFormat == GL_RGB8 || internalFormat == GL_RGBA8 ||
      internalFormat == GL_BGRA;
   struct st_context *st = st_context(ctx);
   enum pipe_format pFormat;
   unsigned bindings;
   enum pipe_texture_target pTarget = gl_target_to_pipe(target);

   if (target == GL_TEXTURE_1D || target == GL_TEXTURE_1D_ARRAY) {
      /* We don't do compression for these texture targets because of
       * difficulty with sub-texture updates on non-block boundaries, etc.
       * So change the internal format request to an uncompressed format.
       */
      internalFormat =
        _mesa_generic_compressed_format_to_uncompressed_format(internalFormat);
   }

   /* GL textures may wind up being render targets, but we don't know
    * that in advance.  Specify potential render target flags now.
    */
   bindings = PIPE_BIND_SAMPLER_VIEW;
   if (want_renderable) {
      if (_mesa_is_depth_or_stencil_format(internalFormat))
	 bindings |= PIPE_BIND_DEPTH_STENCIL;
      else
	 bindings |= PIPE_BIND_RENDER_TARGET;
   }

   /* GLES allows the driver to choose any format which matches
    * the format+type combo, because GLES only supports unsized internal
    * formats and expects the driver to choose whatever suits it.
    */
   if (_mesa_is_gles(ctx)) {
      GLenum baseFormat = _mesa_base_tex_format(ctx, internalFormat);
      GLenum basePackFormat = _mesa_base_pack_format(format);
      GLenum iformat = internalFormat;

      /* Treat GL_BGRA as GL_RGBA. */
      if (iformat == GL_BGRA)
         iformat = GL_RGBA;

      /* Check if the internalformat is unsized and compatible
       * with the "format".
       */
      if (iformat == baseFormat && iformat == basePackFormat) {
         pFormat = st_choose_matching_format(st->pipe->screen, bindings,
                                             format, type,
                                             ctx->Unpack.SwapBytes);

         if (pFormat != PIPE_FORMAT_NONE)
            return st_pipe_format_to_mesa_format(pFormat);

         /* try choosing format again, this time without render target bindings */
         pFormat = st_choose_matching_format(st->pipe->screen,
                                             PIPE_BIND_SAMPLER_VIEW,
                                             format, type,
                                             ctx->Unpack.SwapBytes);
         if (pFormat != PIPE_FORMAT_NONE)
            return st_pipe_format_to_mesa_format(pFormat);
      }
   }

   pFormat = st_choose_format(st, internalFormat, format, type,
                              pTarget, 0, bindings, ctx->Mesa_DXTn);

   if (pFormat == PIPE_FORMAT_NONE) {
      /* try choosing format again, this time without render target bindings */
      pFormat = st_choose_format(st, internalFormat, format, type,
                                 pTarget, 0, PIPE_BIND_SAMPLER_VIEW,
                                 ctx->Mesa_DXTn);
   }

   if (pFormat == PIPE_FORMAT_NONE) {
      /* no luck at all */
      return MESA_FORMAT_NONE;
   }

   return st_pipe_format_to_mesa_format(pFormat);
}


/**
 * Called via ctx->Driver.ChooseTextureFormat().
 */
size_t
st_QuerySamplesForFormat(struct gl_context *ctx, GLenum target,
                         GLenum internalFormat, int samples[16])
{
   struct st_context *st = st_context(ctx);
   enum pipe_format format;
   unsigned i, bind, num_sample_counts = 0;

   (void) target;

   if (_mesa_is_depth_or_stencil_format(internalFormat))
      bind = PIPE_BIND_DEPTH_STENCIL;
   else
      bind = PIPE_BIND_RENDER_TARGET;

   /* If an sRGB framebuffer is unsupported, sRGB formats behave like linear
    * formats.
    */
   if (!ctx->Extensions.EXT_framebuffer_sRGB) {
      internalFormat = _mesa_get_linear_internalformat(internalFormat);
   }

   /* Set sample counts in descending order. */
   for (i = 16; i > 1; i--) {
      format = st_choose_format(st, internalFormat, GL_NONE, GL_NONE,
                                PIPE_TEXTURE_2D, i, bind, FALSE);

      if (format != PIPE_FORMAT_NONE) {
         samples[num_sample_counts++] = i;
      }
   }

   if (!num_sample_counts) {
      samples[num_sample_counts++] = 1;
   }

   return num_sample_counts;
}


/**
 * This is used for translating texture border color and the clear
 * color.  For example, the clear color is interpreted according to
 * the renderbuffer's base format.  For example, if clearing a
 * GL_LUMINANCE buffer, we'll return colorOut[0] = colorOut[1] =
 * colorOut[2] = colorIn[0].
 * Similarly for texture border colors.
 */
void
st_translate_color(const union gl_color_union *colorIn,
                   union pipe_color_union *colorOut,
                   GLenum baseFormat, GLboolean is_integer)
{
   if (is_integer) {
      const int *in = colorIn->i;
      int *out = colorOut->i;

      switch (baseFormat) {
      case GL_RED:
         out[0] = in[0];
         out[1] = 0;
         out[2] = 0;
         out[3] = 1;
         break;
      case GL_RG:
         out[0] = in[0];
         out[1] = in[1];
         out[2] = 0;
         out[3] = 1;
         break;
      case GL_RGB:
         out[0] = in[0];
         out[1] = in[1];
         out[2] = in[2];
         out[3] = 1;
         break;
      case GL_ALPHA:
         out[0] = out[1] = out[2] = 0;
         out[3] = in[3];
         break;
      case GL_LUMINANCE:
         out[0] = out[1] = out[2] = in[0];
         out[3] = 1;
         break;
      case GL_LUMINANCE_ALPHA:
         out[0] = out[1] = out[2] = in[0];
         out[3] = in[3];
         break;
      case GL_INTENSITY:
         out[0] = out[1] = out[2] = out[3] = in[0];
         break;
      default:
         COPY_4V(out, in);
      }
   }
   else {
      const float *in = colorIn->f;
      float *out = colorOut->f;

      switch (baseFormat) {
      case GL_RED:
         out[0] = in[0];
         out[1] = 0.0F;
         out[2] = 0.0F;
         out[3] = 1.0F;
         break;
      case GL_RG:
         out[0] = in[0];
         out[1] = in[1];
         out[2] = 0.0F;
         out[3] = 1.0F;
         break;
      case GL_RGB:
         out[0] = in[0];
         out[1] = in[1];
         out[2] = in[2];
         out[3] = 1.0F;
         break;
      case GL_ALPHA:
         out[0] = out[1] = out[2] = 0.0F;
         out[3] = in[3];
         break;
      case GL_LUMINANCE:
         out[0] = out[1] = out[2] = in[0];
         out[3] = 1.0F;
         break;
      case GL_LUMINANCE_ALPHA:
         out[0] = out[1] = out[2] = in[0];
         out[3] = in[3];
         break;
      case GL_INTENSITY:
         out[0] = out[1] = out[2] = out[3] = in[0];
         break;
      default:
         COPY_4V(out, in);
      }
   }
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d57 1
a57 1
st_mesa_format_to_pipe_format(struct st_context *st, mesa_format mesaFormat)
a85 2
   case MESA_FORMAT_R10G10B10A2_UNORM:
      return PIPE_FORMAT_R10G10B10A2_UNORM;
d89 1
a89 3
      return PIPE_FORMAT_LA88_UNORM;
   case MESA_FORMAT_A8L8_UNORM:
      return PIPE_FORMAT_AL88_UNORM;
d91 1
a91 3
      return PIPE_FORMAT_LA1616_UNORM;
   case MESA_FORMAT_A16L16_UNORM:
      return PIPE_FORMAT_AL1616_UNORM;
d143 1
a143 3
      return PIPE_FORMAT_LA88_SRGB;
   case MESA_FORMAT_A8L8_SRGB:
      return PIPE_FORMAT_AL88_SRGB;
d149 3
a151 1
      return PIPE_FORMAT_ABGR8888_SRGB;
d153 1
a153 5
      return PIPE_FORMAT_RGBA8888_SRGB;
   case MESA_FORMAT_B8G8R8A8_SRGB:
      return PIPE_FORMAT_BGRA8888_SRGB;
   case MESA_FORMAT_A8R8G8B8_SRGB:
      return PIPE_FORMAT_ARGB8888_SRGB;
d192 1
a192 3
      return PIPE_FORMAT_RG88_UNORM;
   case MESA_FORMAT_G8R8_UNORM:
      return PIPE_FORMAT_GR88_UNORM;
d194 1
a194 3
      return PIPE_FORMAT_RG1616_UNORM;
   case MESA_FORMAT_G16R16_UNORM:
      return PIPE_FORMAT_GR1616_UNORM;
a323 2
   /* The destination RGBA format mustn't be changed, because it's also
    * a destination format of the unpack/decompression function. */
d325 1
a325 10
      return st->has_etc1 ? PIPE_FORMAT_ETC1_RGB8 : PIPE_FORMAT_R8G8B8A8_UNORM;

   case MESA_FORMAT_BPTC_RGBA_UNORM:
      return PIPE_FORMAT_BPTC_RGBA_UNORM;
   case MESA_FORMAT_BPTC_SRGB_ALPHA_UNORM:
      return PIPE_FORMAT_BPTC_SRGBA;
   case MESA_FORMAT_BPTC_RGB_SIGNED_FLOAT:
      return PIPE_FORMAT_BPTC_RGB_FLOAT;
   case MESA_FORMAT_BPTC_RGB_UNSIGNED_FLOAT:
      return PIPE_FORMAT_BPTC_RGB_UFLOAT;
d331 1
a331 3
      return PIPE_FORMAT_RG88_SNORM;
   case MESA_FORMAT_G8R8_SNORM:
      return PIPE_FORMAT_GR88_SNORM;
d333 1
a333 3
      return PIPE_FORMAT_RGBA8888_SNORM;
   case MESA_FORMAT_A8B8G8R8_SNORM:
      return PIPE_FORMAT_ABGR8888_SNORM;
d340 1
a340 3
      return PIPE_FORMAT_LA88_SNORM;
   case MESA_FORMAT_A8L8_SNORM:
      return PIPE_FORMAT_AL88_SNORM;
d347 1
a347 3
      return PIPE_FORMAT_RG1616_SNORM;
   case MESA_FORMAT_G16R16_SNORM:
      return PIPE_FORMAT_GR1616_SNORM;
d374 1
a374 3
      return PIPE_FORMAT_RGBX8888_SNORM;
   case MESA_FORMAT_X8B8G8R8_SNORM:
      return PIPE_FORMAT_XBGR8888_SNORM;
d376 1
a376 3
      return PIPE_FORMAT_RGBX8888_SRGB;
   case MESA_FORMAT_X8B8G8R8_SRGB:
      return PIPE_FORMAT_XBGR8888_SRGB;
d401 1
a401 23
      return PIPE_FORMAT_BGRX8888_SRGB;
   case MESA_FORMAT_X8R8G8B8_SRGB:
      return PIPE_FORMAT_XRGB8888_SRGB;

   /* ETC2 formats are emulated as uncompressed ones.
    * The destination formats mustn't be changed, because they are also
    * destination formats of the unpack/decompression function. */
   case MESA_FORMAT_ETC2_RGB8:
   case MESA_FORMAT_ETC2_RGBA8_EAC:
   case MESA_FORMAT_ETC2_RGB8_PUNCHTHROUGH_ALPHA1:
      return PIPE_FORMAT_R8G8B8A8_UNORM;
   case MESA_FORMAT_ETC2_SRGB8:
   case MESA_FORMAT_ETC2_SRGB8_ALPHA8_EAC:
   case MESA_FORMAT_ETC2_SRGB8_PUNCHTHROUGH_ALPHA1:
      return PIPE_FORMAT_B8G8R8A8_SRGB;
   case MESA_FORMAT_ETC2_R11_EAC:
      return PIPE_FORMAT_R16_UNORM;
   case MESA_FORMAT_ETC2_RG11_EAC:
      return PIPE_FORMAT_R16G16_UNORM;
   case MESA_FORMAT_ETC2_SIGNED_R11_EAC:
      return PIPE_FORMAT_R16_SNORM;
   case MESA_FORMAT_ETC2_SIGNED_RG11_EAC:
      return PIPE_FORMAT_R16G16_SNORM;
a441 2
   case PIPE_FORMAT_R10G10B10A2_UNORM:
      return MESA_FORMAT_R10G10B10A2_UNORM;
d444 1
a444 1
   case PIPE_FORMAT_LA88_UNORM:
d446 1
a446 3
   case PIPE_FORMAT_AL88_UNORM:
      return MESA_FORMAT_A8L8_UNORM;
   case PIPE_FORMAT_LA1616_UNORM:
a447 2
   case PIPE_FORMAT_AL1616_UNORM:
      return MESA_FORMAT_A16L16_UNORM;
d504 1
a504 1
   case PIPE_FORMAT_LA88_SRGB:
a505 2
   case PIPE_FORMAT_AL88_SRGB:
      return MESA_FORMAT_A8L8_SRGB;
d510 1
a510 1
   case PIPE_FORMAT_ABGR8888_SRGB:
d512 1
a512 3
   case PIPE_FORMAT_RGBA8888_SRGB:
      return MESA_FORMAT_R8G8B8A8_SRGB;
   case PIPE_FORMAT_BGRA8888_SRGB:
a513 2
   case PIPE_FORMAT_ARGB8888_SRGB:
      return MESA_FORMAT_A8R8G8B8_SRGB;
d551 1
a551 1
   case PIPE_FORMAT_RG88_UNORM:
d553 1
a553 3
   case PIPE_FORMAT_GR88_UNORM:
      return MESA_FORMAT_G8R8_UNORM;
   case PIPE_FORMAT_RG1616_UNORM:
a554 2
   case PIPE_FORMAT_GR1616_UNORM:
      return MESA_FORMAT_G16R16_UNORM;
a683 9
   case PIPE_FORMAT_BPTC_RGBA_UNORM:
      return MESA_FORMAT_BPTC_RGBA_UNORM;
   case PIPE_FORMAT_BPTC_SRGBA:
      return MESA_FORMAT_BPTC_SRGB_ALPHA_UNORM;
   case PIPE_FORMAT_BPTC_RGB_FLOAT:
      return MESA_FORMAT_BPTC_RGB_SIGNED_FLOAT;
   case PIPE_FORMAT_BPTC_RGB_UFLOAT:
      return MESA_FORMAT_BPTC_RGB_UNSIGNED_FLOAT;

d687 1
a687 1
   case PIPE_FORMAT_RG88_SNORM:
d689 1
a689 3
   case PIPE_FORMAT_GR88_SNORM:
      return MESA_FORMAT_G8R8_SNORM;
   case PIPE_FORMAT_RGBA8888_SNORM:
a690 2
   case PIPE_FORMAT_ABGR8888_SNORM:
      return MESA_FORMAT_A8B8G8R8_SNORM;
d696 1
a696 1
   case PIPE_FORMAT_LA88_SNORM:
a697 2
   case PIPE_FORMAT_AL88_SNORM:
      return MESA_FORMAT_A8L8_SNORM;
d703 1
a703 1
   case PIPE_FORMAT_RG1616_SNORM:
a704 2
   case PIPE_FORMAT_GR1616_SNORM:
      return MESA_FORMAT_G16R16_SNORM;
d731 1
a731 1
   case PIPE_FORMAT_RGBX8888_SNORM:
d733 1
a733 3
   case PIPE_FORMAT_XBGR8888_SNORM:
      return MESA_FORMAT_X8B8G8R8_SNORM;
   case PIPE_FORMAT_RGBX8888_SRGB:
a734 2
   case PIPE_FORMAT_XBGR8888_SRGB:
      return MESA_FORMAT_X8B8G8R8_SRGB;
d758 1
a758 1
   case PIPE_FORMAT_BGRX8888_SRGB:
d760 2
a761 2
   case PIPE_FORMAT_XRGB8888_SRGB:
      return MESA_FORMAT_X8R8G8B8_SRGB;
d774 1
a774 1
test_format_conversion(struct st_context *st)
d780 1
a780 9
      enum pipe_format pf;

      /* ETC formats are translated differently, skip them. */
      if (_mesa_is_format_etc2(i))
         continue;
      if (i == MESA_FORMAT_ETC1_RGB8 && !st->has_etc1)
         continue;

      pf = st_mesa_format_to_pipe_format(st, i);
a789 5

      /* ETC formats are translated differently, skip them. */
      if (i == PIPE_FORMAT_ETC1_RGB8 && !st->has_etc1)
         continue;

d791 1
a791 1
         enum pipe_format pf = st_mesa_format_to_pipe_format(st, mf);
a824 1
      PIPE_FORMAT_R8G8B8A8_SRGB, \
d860 1
a860 2
      { PIPE_FORMAT_B10G10R10A2_UNORM, PIPE_FORMAT_R10G10B10A2_UNORM,
        DEFAULT_RGBA_FORMATS }
d864 1
a864 1
      { DEFAULT_RGBA_FORMATS }
d868 1
a868 1
      { DEFAULT_RGBA_FORMATS }
a1235 18
   /* BPTC */
   {
      { GL_COMPRESSED_RGBA_BPTC_UNORM, 0 },
      { PIPE_FORMAT_BPTC_RGBA_UNORM, 0 },
   },
   {
      { GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM, 0 },
      { PIPE_FORMAT_BPTC_SRGBA, 0 },
   },
   {
      { GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT, 0 },
      { PIPE_FORMAT_BPTC_RGB_FLOAT, 0 },
   },
   {
      { GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT, 0 },
      { PIPE_FORMAT_BPTC_RGB_UFLOAT, 0 },
   },

d1678 1
a1678 1
         test_format_conversion(st);
d1744 1
a1744 1
st_choose_matching_format(struct st_context *st, unsigned bind,
a1746 1
   struct pipe_screen *screen = st->pipe->screen;
d1762 1
a1762 2
         enum pipe_format format =
            st_mesa_format_to_pipe_format(st, mesa_format);
d1832 2
a1833 1
         pFormat = st_choose_matching_format(st, bindings, format, type,
d1840 2
a1841 1
         pFormat = st_choose_matching_format(st, PIPE_BIND_SAMPLER_VIEW,
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d57 1
a57 1
st_mesa_format_to_pipe_format(mesa_format mesaFormat)
d86 2
d91 3
a93 1
      return PIPE_FORMAT_L8A8_UNORM;
d95 3
a97 1
      return PIPE_FORMAT_L16A16_UNORM;
d149 3
a151 1
      return PIPE_FORMAT_L8A8_SRGB;
d157 3
a159 1
      return PIPE_FORMAT_A8B8G8R8_SRGB;
d161 3
a163 3
      return PIPE_FORMAT_B8G8R8A8_SRGB;
   case MESA_FORMAT_R8G8B8A8_SRGB:
      return PIPE_FORMAT_R8G8B8A8_SRGB;
d202 3
a204 1
      return PIPE_FORMAT_R8G8_UNORM;
d206 3
a208 1
      return PIPE_FORMAT_R16G16_UNORM;
d338 2
d341 10
a350 1
      return PIPE_FORMAT_ETC1_RGB8;
d356 3
a358 1
      return PIPE_FORMAT_R8G8_SNORM;
d360 3
a362 1
      return PIPE_FORMAT_R8G8B8A8_SNORM;
d369 3
a371 1
      return PIPE_FORMAT_L8A8_SNORM;
d378 3
a380 1
      return PIPE_FORMAT_R16G16_SNORM;
d407 3
a409 1
      return PIPE_FORMAT_R8G8B8X8_SNORM;
d411 3
a413 1
      return PIPE_FORMAT_R8G8B8X8_SRGB;
d438 23
a460 1
      return PIPE_FORMAT_B8G8R8X8_SRGB;
d501 2
d505 1
a505 1
   case PIPE_FORMAT_L8A8_UNORM:
d507 3
a509 1
   case PIPE_FORMAT_L16A16_UNORM:
d511 2
d569 1
a569 1
   case PIPE_FORMAT_L8A8_SRGB:
d571 2
d577 1
a577 1
   case PIPE_FORMAT_A8B8G8R8_SRGB:
d579 3
a581 1
   case PIPE_FORMAT_B8G8R8A8_SRGB:
d583 2
d622 1
a622 1
   case PIPE_FORMAT_R8G8_UNORM:
d624 3
a626 1
   case PIPE_FORMAT_R16G16_UNORM:
d628 2
d759 9
d771 1
a771 1
   case PIPE_FORMAT_R8G8_SNORM:
d773 3
a775 1
   case PIPE_FORMAT_R8G8B8A8_SNORM:
d777 2
d784 1
a784 1
   case PIPE_FORMAT_L8A8_SNORM:
d786 2
d793 1
a793 1
   case PIPE_FORMAT_R16G16_SNORM:
d795 2
d823 1
a823 1
   case PIPE_FORMAT_R8G8B8X8_SNORM:
d825 3
a827 1
   case PIPE_FORMAT_R8G8B8X8_SRGB:
d829 2
d854 1
a854 1
   case PIPE_FORMAT_B8G8R8X8_SRGB:
d856 2
a857 2
   case PIPE_FORMAT_R8G8B8A8_SRGB:
      return MESA_FORMAT_R8G8B8A8_SRGB;
d870 1
a870 1
test_format_conversion(void)
d876 9
a884 1
      enum pipe_format pf = st_mesa_format_to_pipe_format(i);
d894 5
d900 1
a900 1
         enum pipe_format pf = st_mesa_format_to_pipe_format(mf);
d934 1
d970 2
a971 1
      { PIPE_FORMAT_B10G10R10A2_UNORM, DEFAULT_RGBA_FORMATS }
d975 1
a975 1
      { PIPE_FORMAT_R8G8B8A8_UNORM, DEFAULT_RGBA_FORMATS }
d979 1
a979 1
      { PIPE_FORMAT_B8G8R8A8_UNORM, DEFAULT_RGBA_FORMATS }
d1347 18
d1807 1
a1807 1
         test_format_conversion();
d1873 1
a1873 1
st_choose_matching_format(struct pipe_screen *screen, unsigned bind,
d1876 1
d1892 2
a1893 1
         enum pipe_format format = st_mesa_format_to_pipe_format(mesa_format);
d1963 1
a1963 2
         pFormat = st_choose_matching_format(st->pipe->screen, bindings,
                                             format, type,
d1970 1
a1970 2
         pFormat = st_choose_matching_format(st->pipe->screen,
                                             PIPE_BIND_SAMPLER_VIEW,
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d22 1
a22 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d38 2
d48 1
d57 1
a57 1
st_mesa_format_to_pipe_format(gl_format mesaFormat)
d60 1
a60 1
   case MESA_FORMAT_RGBA8888:
d62 1
a62 1
   case MESA_FORMAT_RGBA8888_REV:
d64 1
a64 1
   case MESA_FORMAT_ARGB8888:
d66 1
a66 1
   case MESA_FORMAT_ARGB8888_REV:
d68 1
a68 1
   case MESA_FORMAT_RGBX8888:
d70 1
a70 1
   case MESA_FORMAT_RGBX8888_REV:
d72 1
a72 1
   case MESA_FORMAT_XRGB8888:
d74 1
a74 1
   case MESA_FORMAT_XRGB8888_REV:
d76 1
a76 1
   case MESA_FORMAT_ARGB1555:
d78 1
a78 1
   case MESA_FORMAT_ARGB4444:
d80 1
a80 1
   case MESA_FORMAT_RGB565:
d82 1
a82 1
   case MESA_FORMAT_RGB332:
d84 1
a84 1
   case MESA_FORMAT_ARGB2101010:
d86 1
a86 1
   case MESA_FORMAT_AL44:
d88 1
a88 1
   case MESA_FORMAT_AL88:
d90 1
a90 1
   case MESA_FORMAT_AL1616:
d92 1
a92 1
   case MESA_FORMAT_A8:
d94 1
a94 1
   case MESA_FORMAT_A16:
d96 1
a96 1
   case MESA_FORMAT_L8:
d98 1
a98 1
   case MESA_FORMAT_L16:
d100 1
a100 1
   case MESA_FORMAT_I8:
d102 1
a102 1
   case MESA_FORMAT_I16:
d104 1
a104 1
   case MESA_FORMAT_Z16:
d106 1
a106 1
   case MESA_FORMAT_Z32:
d108 1
a108 1
   case MESA_FORMAT_Z24_S8:
d110 1
a110 1
   case MESA_FORMAT_S8_Z24:
d112 1
a112 1
   case MESA_FORMAT_Z24_X8:
d114 1
a114 1
   case MESA_FORMAT_X8_Z24:
d116 1
a116 1
   case MESA_FORMAT_S8:
d118 1
a118 1
   case MESA_FORMAT_Z32_FLOAT:
d120 1
a120 1
   case MESA_FORMAT_Z32_FLOAT_X24S8:
d124 2
d142 1
a142 1
   case MESA_FORMAT_SLA8:
d144 1
a144 1
   case MESA_FORMAT_SL8:
d146 1
a146 1
   case MESA_FORMAT_SRGB8:
d148 1
a148 1
   case MESA_FORMAT_SRGBA8:
d150 1
a150 1
   case MESA_FORMAT_SARGB8:
d152 2
d162 1
a162 1
   case MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32:
d164 1
a164 1
   case MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16:
d166 1
a166 1
   case MESA_FORMAT_LUMINANCE_FLOAT32:
d168 1
a168 1
   case MESA_FORMAT_LUMINANCE_FLOAT16:
d170 1
a170 1
   case MESA_FORMAT_ALPHA_FLOAT32:
d172 1
a172 1
   case MESA_FORMAT_ALPHA_FLOAT16:
d174 1
a174 1
   case MESA_FORMAT_INTENSITY_FLOAT32:
d176 1
a176 1
   case MESA_FORMAT_INTENSITY_FLOAT16:
d187 1
a187 1
   case MESA_FORMAT_R8:
d189 1
a189 1
   case MESA_FORMAT_R16:
d191 1
a191 1
   case MESA_FORMAT_GR88:
d193 1
a193 1
   case MESA_FORMAT_GR1616:
d195 1
a195 1
   case MESA_FORMAT_RGBA_16:
d199 1
a199 1
   case MESA_FORMAT_ALPHA_UINT8:
d201 1
a201 1
   case MESA_FORMAT_ALPHA_UINT16:
d203 1
a203 1
   case MESA_FORMAT_ALPHA_UINT32:
d206 1
a206 1
   case MESA_FORMAT_ALPHA_INT8:
d208 1
a208 1
   case MESA_FORMAT_ALPHA_INT16:
d210 1
a210 1
   case MESA_FORMAT_ALPHA_INT32:
d213 1
a213 1
   case MESA_FORMAT_INTENSITY_UINT8:
d215 1
a215 1
   case MESA_FORMAT_INTENSITY_UINT16:
d217 1
a217 1
   case MESA_FORMAT_INTENSITY_UINT32:
d220 1
a220 1
   case MESA_FORMAT_INTENSITY_INT8:
d222 1
a222 1
   case MESA_FORMAT_INTENSITY_INT16:
d224 1
a224 1
   case MESA_FORMAT_INTENSITY_INT32:
d227 1
a227 1
   case MESA_FORMAT_LUMINANCE_UINT8:
d229 1
a229 1
   case MESA_FORMAT_LUMINANCE_UINT16:
d231 1
a231 1
   case MESA_FORMAT_LUMINANCE_UINT32:
d234 1
a234 1
   case MESA_FORMAT_LUMINANCE_INT8:
d236 1
a236 1
   case MESA_FORMAT_LUMINANCE_INT16:
d238 1
a238 1
   case MESA_FORMAT_LUMINANCE_INT32:
d241 1
a241 1
   case MESA_FORMAT_LUMINANCE_ALPHA_UINT8:
d243 1
a243 1
   case MESA_FORMAT_LUMINANCE_ALPHA_UINT16:
d245 1
a245 1
   case MESA_FORMAT_LUMINANCE_ALPHA_UINT32:
d248 1
a248 1
   case MESA_FORMAT_LUMINANCE_ALPHA_INT8:
d250 1
a250 1
   case MESA_FORMAT_LUMINANCE_ALPHA_INT16:
d252 1
a252 1
   case MESA_FORMAT_LUMINANCE_ALPHA_INT32:
d255 1
a255 1
   case MESA_FORMAT_R_INT8:
d257 1
a257 1
   case MESA_FORMAT_RG_INT8:
d259 1
a259 1
   case MESA_FORMAT_RGB_INT8:
d261 1
a261 1
   case MESA_FORMAT_RGBA_INT8:
d263 1
a263 1
   case MESA_FORMAT_R_INT16:
d265 1
a265 1
   case MESA_FORMAT_RG_INT16:
d267 1
a267 1
   case MESA_FORMAT_RGB_INT16:
d269 1
a269 1
   case MESA_FORMAT_RGBA_INT16:
d271 1
a271 1
   case MESA_FORMAT_R_INT32:
d273 1
a273 1
   case MESA_FORMAT_RG_INT32:
d275 1
a275 1
   case MESA_FORMAT_RGB_INT32:
d277 1
a277 1
   case MESA_FORMAT_RGBA_INT32:
d306 1
a306 1
   case MESA_FORMAT_RED_RGTC1:
d308 1
a308 1
   case MESA_FORMAT_SIGNED_RED_RGTC1:
d310 1
a310 1
   case MESA_FORMAT_RG_RGTC2:
d312 1
a312 1
   case MESA_FORMAT_SIGNED_RG_RGTC2:
d315 1
a315 1
   case MESA_FORMAT_L_LATC1:
d317 1
a317 1
   case MESA_FORMAT_SIGNED_L_LATC1:
d319 1
a319 1
   case MESA_FORMAT_LA_LATC2:
d321 1
a321 1
   case MESA_FORMAT_SIGNED_LA_LATC2:
d328 1
a328 1
   case MESA_FORMAT_SIGNED_R8:
d330 1
a330 1
   case MESA_FORMAT_SIGNED_RG88_REV:
d332 1
a332 1
   case MESA_FORMAT_SIGNED_RGBA8888_REV:
d335 1
a335 1
   case MESA_FORMAT_SIGNED_A8:
d337 1
a337 1
   case MESA_FORMAT_SIGNED_L8:
d339 1
a339 1
   case MESA_FORMAT_SIGNED_AL88:
d341 1
a341 1
   case MESA_FORMAT_SIGNED_I8:
d344 1
a344 1
   case MESA_FORMAT_SIGNED_R16:
d346 1
a346 1
   case MESA_FORMAT_SIGNED_GR1616:
d348 1
a348 1
   case MESA_FORMAT_SIGNED_RGBA_16:
d351 1
a351 1
   case MESA_FORMAT_SIGNED_A16:
d353 1
a353 1
   case MESA_FORMAT_SIGNED_L16:
d355 1
a355 1
   case MESA_FORMAT_SIGNED_AL1616:
d357 1
a357 1
   case MESA_FORMAT_SIGNED_I16:
d360 1
a360 1
   case MESA_FORMAT_RGB9_E5_FLOAT:
d362 1
a362 1
   case MESA_FORMAT_R11_G11_B10_FLOAT:
d364 1
a364 1
   case MESA_FORMAT_ARGB2101010_UINT:
d366 2
d369 1
a369 1
   case MESA_FORMAT_XRGB4444_UNORM:
d371 1
a371 1
   case MESA_FORMAT_XRGB1555_UNORM:
d373 1
a373 1
   case MESA_FORMAT_XBGR8888_SNORM:
d375 1
a375 1
   case MESA_FORMAT_XBGR8888_SRGB:
d377 1
a377 1
   case MESA_FORMAT_XBGR8888_UINT:
d379 1
a379 1
   case MESA_FORMAT_XBGR8888_SINT:
d381 1
a381 1
   case MESA_FORMAT_XRGB2101010_UNORM:
d383 1
a383 1
   case MESA_FORMAT_XBGR16161616_UNORM:
d385 1
a385 1
   case MESA_FORMAT_XBGR16161616_SNORM:
d387 1
a387 1
   case MESA_FORMAT_XBGR16161616_FLOAT:
d389 1
a389 1
   case MESA_FORMAT_XBGR16161616_UINT:
d391 1
a391 1
   case MESA_FORMAT_XBGR16161616_SINT:
d393 1
a393 1
   case MESA_FORMAT_XBGR32323232_FLOAT:
d395 1
a395 1
   case MESA_FORMAT_XBGR32323232_UINT:
d397 1
a397 1
   case MESA_FORMAT_XBGR32323232_SINT:
d400 3
d412 1
a412 1
gl_format
d417 1
a417 1
      return MESA_FORMAT_RGBA8888;
d419 1
a419 1
      return MESA_FORMAT_RGBA8888_REV;
d421 1
a421 1
      return MESA_FORMAT_ARGB8888;
d423 1
a423 1
      return MESA_FORMAT_ARGB8888_REV;
d425 1
a425 1
      return MESA_FORMAT_RGBX8888;
d427 1
a427 1
      return MESA_FORMAT_RGBX8888_REV;
d429 1
a429 1
      return MESA_FORMAT_XRGB8888;
d431 1
a431 1
      return MESA_FORMAT_XRGB8888_REV;
d433 1
a433 1
      return MESA_FORMAT_ARGB1555;
d435 1
a435 1
      return MESA_FORMAT_ARGB4444;
d437 1
a437 1
      return MESA_FORMAT_RGB565;
d439 1
a439 1
      return MESA_FORMAT_RGB332;
d441 1
a441 1
      return MESA_FORMAT_ARGB2101010;
d443 1
a443 1
      return MESA_FORMAT_AL44;
d445 1
a445 1
      return MESA_FORMAT_AL88;
d447 1
a447 1
      return MESA_FORMAT_AL1616;
d449 1
a449 1
      return MESA_FORMAT_A8;
d451 1
a451 1
      return MESA_FORMAT_A16;
d453 1
a453 1
      return MESA_FORMAT_L8;
d455 1
a455 1
      return MESA_FORMAT_L16;
d457 1
a457 1
      return MESA_FORMAT_I8;
d459 1
a459 1
      return MESA_FORMAT_I16;
d461 1
a461 1
      return MESA_FORMAT_S8;
d464 1
a464 1
      return MESA_FORMAT_RGBA_16;
d467 1
a467 1
      return MESA_FORMAT_Z16;
d469 1
a469 1
      return MESA_FORMAT_Z32;
d471 1
a471 1
      return MESA_FORMAT_Z24_S8;
d473 1
a473 1
      return MESA_FORMAT_Z24_X8;
d475 1
a475 1
      return MESA_FORMAT_X8_Z24;
d477 1
a477 1
      return MESA_FORMAT_S8_Z24;
d479 1
a479 1
      return MESA_FORMAT_Z32_FLOAT;
d481 1
a481 1
      return MESA_FORMAT_Z32_FLOAT_X24S8;
d505 1
a505 1
      return MESA_FORMAT_SLA8;
d507 1
a507 1
      return MESA_FORMAT_SL8;
d509 1
a509 1
      return MESA_FORMAT_SRGB8;
d511 1
a511 1
      return MESA_FORMAT_SRGBA8;
d513 1
a513 1
      return MESA_FORMAT_SARGB8;
d523 1
a523 1
      return MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32;
d525 1
a525 1
      return MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16;
d527 1
a527 1
      return MESA_FORMAT_LUMINANCE_FLOAT32;
d529 1
a529 1
      return MESA_FORMAT_LUMINANCE_FLOAT16;
d531 1
a531 1
      return MESA_FORMAT_ALPHA_FLOAT32;
d533 1
a533 1
      return MESA_FORMAT_ALPHA_FLOAT16;
d535 1
a535 1
      return MESA_FORMAT_INTENSITY_FLOAT32;
d537 1
a537 1
      return MESA_FORMAT_INTENSITY_FLOAT16;
d548 1
a548 1
      return MESA_FORMAT_R8;
d550 1
a550 1
      return MESA_FORMAT_R16;
d552 1
a552 1
      return MESA_FORMAT_GR88;
d554 1
a554 1
      return MESA_FORMAT_GR1616;
d557 1
a557 1
      return MESA_FORMAT_ALPHA_UINT8;
d559 1
a559 1
      return MESA_FORMAT_ALPHA_UINT16;
d561 1
a561 1
      return MESA_FORMAT_ALPHA_UINT32;
d563 1
a563 1
      return MESA_FORMAT_ALPHA_INT8;
d565 1
a565 1
      return MESA_FORMAT_ALPHA_INT16;
d567 1
a567 1
      return MESA_FORMAT_ALPHA_INT32;
d570 1
a570 1
      return MESA_FORMAT_INTENSITY_UINT8;
d572 1
a572 1
      return MESA_FORMAT_INTENSITY_UINT16;
d574 1
a574 1
      return MESA_FORMAT_INTENSITY_UINT32;
d576 1
a576 1
      return MESA_FORMAT_INTENSITY_INT8;
d578 1
a578 1
      return MESA_FORMAT_INTENSITY_INT16;
d580 1
a580 1
      return MESA_FORMAT_INTENSITY_INT32;
d583 1
a583 1
      return MESA_FORMAT_LUMINANCE_UINT8;
d585 1
a585 1
      return MESA_FORMAT_LUMINANCE_UINT16;
d587 1
a587 1
      return MESA_FORMAT_LUMINANCE_UINT32;
d589 1
a589 1
      return MESA_FORMAT_LUMINANCE_INT8;
d591 1
a591 1
      return MESA_FORMAT_LUMINANCE_INT16;
d593 1
a593 1
      return MESA_FORMAT_LUMINANCE_INT32;
d596 1
a596 1
      return MESA_FORMAT_LUMINANCE_ALPHA_UINT8;
d598 1
a598 1
      return MESA_FORMAT_LUMINANCE_ALPHA_UINT16;
d600 1
a600 1
      return MESA_FORMAT_LUMINANCE_ALPHA_UINT32;
d602 1
a602 1
      return MESA_FORMAT_LUMINANCE_ALPHA_INT8;
d604 1
a604 1
      return MESA_FORMAT_LUMINANCE_ALPHA_INT16;
d606 1
a606 1
      return MESA_FORMAT_LUMINANCE_ALPHA_INT32;
d609 1
a609 1
      return MESA_FORMAT_R_INT8;
d611 1
a611 1
      return MESA_FORMAT_RG_INT8;
d613 1
a613 1
      return MESA_FORMAT_RGB_INT8;
d615 1
a615 1
      return MESA_FORMAT_RGBA_INT8;
d618 1
a618 1
      return MESA_FORMAT_R_INT16;
d620 1
a620 1
      return MESA_FORMAT_RG_INT16;
d622 1
a622 1
      return MESA_FORMAT_RGB_INT16;
d624 1
a624 1
      return MESA_FORMAT_RGBA_INT16;
d627 1
a627 1
      return MESA_FORMAT_R_INT32;
d629 1
a629 1
      return MESA_FORMAT_RG_INT32;
d631 1
a631 1
      return MESA_FORMAT_RGB_INT32;
d633 1
a633 1
      return MESA_FORMAT_RGBA_INT32;
d664 1
a664 1
      return MESA_FORMAT_RED_RGTC1;
d666 1
a666 1
      return MESA_FORMAT_SIGNED_RED_RGTC1;
d668 1
a668 1
      return MESA_FORMAT_RG_RGTC2;
d670 1
a670 1
      return MESA_FORMAT_SIGNED_RG_RGTC2;
d673 1
a673 1
      return MESA_FORMAT_L_LATC1;
d675 1
a675 1
      return MESA_FORMAT_SIGNED_L_LATC1;
d677 1
a677 1
      return MESA_FORMAT_LA_LATC2;
d679 1
a679 1
      return MESA_FORMAT_SIGNED_LA_LATC2;
d686 1
a686 1
      return MESA_FORMAT_SIGNED_R8;
d688 1
a688 1
      return MESA_FORMAT_SIGNED_RG88_REV;
d690 1
a690 1
      return MESA_FORMAT_SIGNED_RGBA8888_REV;
d693 1
a693 1
      return MESA_FORMAT_SIGNED_A8;
d695 1
a695 1
      return MESA_FORMAT_SIGNED_L8;
d697 1
a697 1
      return MESA_FORMAT_SIGNED_AL88;
d699 1
a699 1
      return MESA_FORMAT_SIGNED_I8;
d702 1
a702 1
      return MESA_FORMAT_SIGNED_R16;
d704 1
a704 1
      return MESA_FORMAT_SIGNED_GR1616;
d706 1
a706 1
      return MESA_FORMAT_SIGNED_RGBA_16;
d709 1
a709 1
      return MESA_FORMAT_SIGNED_A16;
d711 1
a711 1
      return MESA_FORMAT_SIGNED_L16;
d713 1
a713 1
      return MESA_FORMAT_SIGNED_AL1616;
d715 1
a715 1
      return MESA_FORMAT_SIGNED_I16;
d718 1
a718 1
      return MESA_FORMAT_RGB9_E5_FLOAT;
d720 1
a720 1
      return MESA_FORMAT_R11_G11_B10_FLOAT;
d723 3
a725 1
      return MESA_FORMAT_ARGB2101010_UINT;
d728 1
a728 1
      return MESA_FORMAT_XRGB4444_UNORM;
d730 1
a730 1
      return MESA_FORMAT_XRGB1555_UNORM;
d732 1
a732 1
      return MESA_FORMAT_XBGR8888_SNORM;
d734 1
a734 1
      return MESA_FORMAT_XBGR8888_SRGB;
d736 1
a736 1
      return MESA_FORMAT_XBGR8888_UINT;
d738 1
a738 1
      return MESA_FORMAT_XBGR8888_SINT;
d740 1
a740 1
      return MESA_FORMAT_XRGB2101010_UNORM;
d742 1
a742 1
      return MESA_FORMAT_XBGR16161616_UNORM;
d744 1
a744 1
      return MESA_FORMAT_XBGR16161616_SNORM;
d746 1
a746 1
      return MESA_FORMAT_XBGR16161616_FLOAT;
d748 1
a748 1
      return MESA_FORMAT_XBGR16161616_UINT;
d750 1
a750 1
      return MESA_FORMAT_XBGR16161616_SINT;
d752 1
a752 1
      return MESA_FORMAT_XBGR32323232_FLOAT;
d754 1
a754 1
      return MESA_FORMAT_XBGR32323232_UINT;
d756 6
a761 1
      return MESA_FORMAT_XBGR32323232_SINT;
a763 1
      assert(0);
d770 29
d1049 2
a1050 1
      { PIPE_FORMAT_R8G8B8X8_SRGB, DEFAULT_SRGBA_FORMATS }
d1059 1
a1059 1
        DEFAULT_SRGBA_FORMATS }
d1531 1
a1531 1
      { PIPE_FORMAT_B10G10R10A2_UINT, 0 }
d1674 12
d1747 1
a1747 1
   gl_format mesa_format;
d1753 6
d1780 1
a1780 1
gl_format
d1793 1
d1815 34
d1850 1
a1850 1
                              PIPE_TEXTURE_2D, 0, bindings, ctx->Mesa_DXTn);
d1855 1
a1855 1
                                 PIPE_TEXTURE_2D, 0, PIPE_BIND_SAMPLER_VIEW,
d1920 1
a1920 1
st_translate_color(union gl_color_union *colorIn,
d1925 1
a1925 1
      int *in = colorIn->i;
d1967 1
a1967 1
      float *in = colorIn->f;
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d37 1
a40 1
#include "main/mfeatures.h"
a49 97
static GLuint
format_max_bits(enum pipe_format format)
{
   GLuint size = util_format_get_component_bits(format, UTIL_FORMAT_COLORSPACE_RGB, 0);

   size = MAX2(size, util_format_get_component_bits(format, UTIL_FORMAT_COLORSPACE_RGB, 1));
   size = MAX2(size, util_format_get_component_bits(format, UTIL_FORMAT_COLORSPACE_RGB, 2));
   size = MAX2(size, util_format_get_component_bits(format, UTIL_FORMAT_COLORSPACE_RGB, 3));
   size = MAX2(size, util_format_get_component_bits(format, UTIL_FORMAT_COLORSPACE_ZS, 0));
   size = MAX2(size, util_format_get_component_bits(format, UTIL_FORMAT_COLORSPACE_ZS, 1));
   return size;
}


/**
 * Return basic GL datatype for the given gallium format.
 */
GLenum
st_format_datatype(enum pipe_format format)
{
   const struct util_format_description *desc;
   int i;

   desc = util_format_description(format);
   assert(desc);

   /* Find the first non-VOID channel. */
   for (i = 0; i < 4; i++) {
       if (desc->channel[i].type != UTIL_FORMAT_TYPE_VOID) {
           break;
       }
   }

   if (desc->layout == UTIL_FORMAT_LAYOUT_PLAIN) {
      if (format == PIPE_FORMAT_B5G5R5A1_UNORM ||
          format == PIPE_FORMAT_B5G6R5_UNORM) {
         return GL_UNSIGNED_SHORT;
      }
      else if (format == PIPE_FORMAT_R11G11B10_FLOAT ||
               format == PIPE_FORMAT_R9G9B9E5_FLOAT) {
         return GL_FLOAT;
      }
      else if (format == PIPE_FORMAT_Z24_UNORM_S8_USCALED ||
               format == PIPE_FORMAT_S8_USCALED_Z24_UNORM ||
               format == PIPE_FORMAT_Z24X8_UNORM ||
               format == PIPE_FORMAT_X8Z24_UNORM) {
         return GL_UNSIGNED_INT_24_8;
      }
      else {
         const GLuint size = format_max_bits(format);

         assert(i < 4);
         if (i == 4)
            return GL_NONE;

         if (size == 8) {
            if (desc->channel[i].type == UTIL_FORMAT_TYPE_UNSIGNED)
               return GL_UNSIGNED_BYTE;
            else
               return GL_BYTE;
         }
         else if (size == 16) {
            if (desc->channel[i].type == UTIL_FORMAT_TYPE_FLOAT)
               return GL_HALF_FLOAT;
            if (desc->channel[i].type == UTIL_FORMAT_TYPE_UNSIGNED)
               return GL_UNSIGNED_SHORT;
            else
               return GL_SHORT;
         }
         else if (size <= 32) {
            if (desc->channel[i].type == UTIL_FORMAT_TYPE_FLOAT)
               return GL_FLOAT;
            if (desc->channel[i].type == UTIL_FORMAT_TYPE_UNSIGNED)
               return GL_UNSIGNED_INT;
            else
               return GL_INT;
         }
         else {
            assert(size == 64);
            assert(desc->channel[i].type == UTIL_FORMAT_TYPE_FLOAT);
            return GL_DOUBLE;
         }
      }
   }
   else if (format == PIPE_FORMAT_UYVY) {
      return GL_UNSIGNED_SHORT;
   }
   else if (format == PIPE_FORMAT_YUYV) {
      return GL_UNSIGNED_SHORT;
   }
   else {
      /* probably a compressed format, unsupported anyway */
      return GL_NONE;
   }
}


d58 1
a58 1
      return PIPE_FORMAT_A8B8G8R8_UNORM;
d60 1
a60 1
      return PIPE_FORMAT_R8G8B8A8_UNORM;
d62 1
a62 1
      return PIPE_FORMAT_B8G8R8A8_UNORM;
d64 5
a68 1
      return PIPE_FORMAT_A8R8G8B8_UNORM;
d70 1
a70 1
      return PIPE_FORMAT_B8G8R8X8_UNORM;
d72 1
a72 1
      return PIPE_FORMAT_X8R8G8B8_UNORM;
d106 1
a106 1
      return PIPE_FORMAT_S8_USCALED_Z24_UNORM;
d108 1
a108 1
      return PIPE_FORMAT_Z24_UNORM_S8_USCALED;
d114 5
a118 1
      return PIPE_FORMAT_S8_USCALED;
a120 1
#if FEATURE_texture_s3tc
a128 1
#if FEATURE_EXT_texture_sRGB
a136 3
#endif
#endif
#if FEATURE_EXT_texture_sRGB
a146 1
#endif
d184 1
a184 1
   case MESA_FORMAT_RG88:
d186 1
a186 1
   case MESA_FORMAT_RG1616:
d192 62
d255 7
a261 1
      return PIPE_FORMAT_R8G8B8A8_SSCALED;
d263 7
a269 1
      return PIPE_FORMAT_R16G16B16A16_SSCALED;
d271 1
a271 1
      return PIPE_FORMAT_R32G32B32A32_SSCALED;
d274 6
d281 7
a287 1
      return PIPE_FORMAT_R8G8B8A8_USCALED;
d289 7
a295 1
      return PIPE_FORMAT_R16G16B16A16_USCALED;
d297 1
a297 1
      return PIPE_FORMAT_R32G32B32A32_USCALED;
d317 3
d357 33
a391 1
      assert(0);
d404 1
a404 1
   case PIPE_FORMAT_A8B8G8R8_UNORM:
d406 1
a406 1
   case PIPE_FORMAT_R8G8B8A8_UNORM:
d408 1
a408 1
   case PIPE_FORMAT_B8G8R8A8_UNORM:
d410 1
a410 1
   case PIPE_FORMAT_A8R8G8B8_UNORM:
d412 5
a416 1
   case PIPE_FORMAT_B8G8R8X8_UNORM:
d418 1
a418 1
   case PIPE_FORMAT_X8R8G8B8_UNORM:
d448 1
a448 1
   case PIPE_FORMAT_S8_USCALED:
d458 1
a458 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d464 1
a464 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d466 4
a475 1
#if FEATURE_texture_s3tc
a483 1
#if FEATURE_EXT_texture_sRGB
a491 4
#endif
#endif

#if FEATURE_EXT_texture_sRGB
a501 1
#endif
d540 1
a540 1
      return MESA_FORMAT_RG88;
d542 1
a542 1
      return MESA_FORMAT_RG1616;
d544 59
a602 2
   /* signed int formats */
   case PIPE_FORMAT_R8G8B8A8_SSCALED:
d604 8
a611 1
   case PIPE_FORMAT_R16G16B16A16_SSCALED:
d613 8
a620 1
   case PIPE_FORMAT_R32G32B32A32_SSCALED:
d624 7
a630 1
   case PIPE_FORMAT_R8G8B8A8_USCALED:
d632 8
a639 1
   case PIPE_FORMAT_R16G16B16A16_USCALED:
d641 8
a648 1
   case PIPE_FORMAT_R32G32B32A32_USCALED:
d669 3
d710 34
d757 1
a757 1
   enum pipe_format pipeFormats[10]; /**< list of pipe formats, 0-terminated */
d763 1
a765 1
      PIPE_FORMAT_B5G6R5_UNORM, \
d770 1
a772 3
      PIPE_FORMAT_B8G8R8A8_UNORM, \
      PIPE_FORMAT_A8R8G8B8_UNORM, \
      PIPE_FORMAT_A8B8G8R8_UNORM, \
d774 1
a774 1
      0
d786 2
a787 2
      PIPE_FORMAT_Z24_UNORM_S8_USCALED, \
      PIPE_FORMAT_S8_USCALED_Z24_UNORM, \
d790 9
d807 6
a812 1
      { GL_RGB10, GL_RGB10_A2, 0 },
d828 6
a833 1
      { GL_RGB12, GL_RGB16, GL_RGBA12, GL_RGBA16, 0 },
d847 1
a847 1
        PIPE_FORMAT_B5G5R5A1_UNORM, DEFAULT_RGBA_FORMATS }
d850 12
a861 3
      { GL_RGB5, GL_RGB4 },
      { PIPE_FORMAT_B5G6R5_UNORM, PIPE_FORMAT_B5G5R5A1_UNORM,
        DEFAULT_RGBA_FORMATS }
d974 4
d984 2
a985 2
         PIPE_FORMAT_S8_USCALED, PIPE_FORMAT_Z24_UNORM_S8_USCALED,
         PIPE_FORMAT_S8_USCALED_Z24_UNORM, 0
d992 5
a996 1
      { PIPE_FORMAT_Z24_UNORM_S8_USCALED, PIPE_FORMAT_S8_USCALED_Z24_UNORM, 0 }
d1001 5
a1005 1
      { GL_SRGB_EXT, GL_SRGB8_EXT, GL_SRGB_ALPHA_EXT, GL_SRGB8_ALPHA8_EXT, 0 },
d1010 2
a1011 1
      { PIPE_FORMAT_DXT1_SRGB, DEFAULT_SRGBA_FORMATS }
d1028 1
a1028 1
        GL_COMPRESSED_SLUMINANCE_EXT, GL_COMPRESSED_SLUMINANCE_ALPHA_EXT, 0 },
d1032 2
a1033 1
      { GL_SLUMINANCE_EXT, GL_SLUMINANCE8_EXT, 0 },
d1044 2
a1045 1
      { PIPE_FORMAT_R16G16B16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT,
d1090 2
a1091 2
      { PIPE_FORMAT_R32G32B32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT,
        PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
d1131 1
a1131 1
      { PIPE_FORMAT_R8_UNORM, 0 }
d1135 1
a1135 1
      { PIPE_FORMAT_R8G8_UNORM, 0 }
d1139 2
a1140 1
      { PIPE_FORMAT_R16_UNORM, 0 }
d1144 1
a1144 1
      { PIPE_FORMAT_R16G16_UNORM, 0 }
d1150 1
a1150 1
      { PIPE_FORMAT_RGTC1_UNORM, PIPE_FORMAT_R8_UNORM, 0 }
d1154 1
a1154 1
      { PIPE_FORMAT_RGTC1_SNORM, 0 }
d1158 1
a1158 1
      { PIPE_FORMAT_RGTC2_UNORM, PIPE_FORMAT_R8G8_UNORM, 0 }
d1162 1
a1162 1
      { PIPE_FORMAT_RGTC2_SNORM, 0 }
d1166 1
a1166 1
      { PIPE_FORMAT_LATC1_UNORM, PIPE_FORMAT_L8_UNORM, 0 }
d1170 1
a1170 1
      { PIPE_FORMAT_LATC1_SNORM, 0 }
d1175 1
a1175 1
      { PIPE_FORMAT_LATC2_UNORM, PIPE_FORMAT_L8A8_UNORM, 0 }
d1179 7
a1185 1
      { PIPE_FORMAT_LATC2_SNORM, 0 }
a1188 2
    * XXX Mesa only has formats for RGBA signed/unsigned integer formats.
    * If/when new formats are added this code should be updated.
d1191 7
a1197 6
      { GL_RED_INTEGER_EXT,
        GL_GREEN_INTEGER_EXT,
        GL_BLUE_INTEGER_EXT,
        GL_ALPHA_INTEGER_EXT,
        GL_RGB_INTEGER_EXT,
        GL_RGBA_INTEGER_EXT,
a1198 4
        GL_BGRA_INTEGER_EXT,
        GL_LUMINANCE_INTEGER_EXT,
        GL_LUMINANCE_ALPHA_INTEGER_EXT,
        GL_RGBA8I_EXT,
d1200 80
a1279 3
        GL_ALPHA8I_EXT,
        GL_INTENSITY8I_EXT,
        GL_LUMINANCE8I_EXT,
d1281 9
a1289 1
      { PIPE_FORMAT_R8G8B8A8_SSCALED, 0 }
d1292 83
a1374 8
      {
         GL_RGBA16I_EXT,
         GL_RGB16I_EXT,
         GL_ALPHA16I_EXT,
         GL_INTENSITY16I_EXT,
         GL_LUMINANCE16I_EXT,
         GL_LUMINANCE_ALPHA16I_EXT, 0 },
      { PIPE_FORMAT_R16G16B16A16_SSCALED, 0 },
d1377 2
a1378 8
      {
         GL_RGBA32I_EXT,
         GL_RGB32I_EXT,
         GL_ALPHA32I_EXT,
         GL_INTENSITY32I_EXT,
         GL_LUMINANCE32I_EXT,
         GL_LUMINANCE_ALPHA32I_EXT, 0 },
      { PIPE_FORMAT_R32G32B32A32_SSCALED, 0 }
d1381 6
a1386 8
      {
         GL_RGBA8UI_EXT,
         GL_RGB8UI_EXT,
         GL_ALPHA8UI_EXT,
         GL_INTENSITY8UI_EXT,
         GL_LUMINANCE8UI_EXT,
         GL_LUMINANCE_ALPHA8UI_EXT, 0 },
      { PIPE_FORMAT_R8G8B8A8_USCALED, 0 }
d1389 2
a1390 8
      {
         GL_RGBA16UI_EXT,
         GL_RGB16UI_EXT,
         GL_ALPHA16UI_EXT,
         GL_INTENSITY16UI_EXT,
         GL_LUMINANCE16UI_EXT,
         GL_LUMINANCE_ALPHA16UI_EXT, 0 },
      { PIPE_FORMAT_R16G16B16A16_USCALED, 0 }
d1393 2
a1394 8
      {
         GL_RGBA32UI_EXT,
         GL_RGB32UI_EXT,
         GL_ALPHA32UI_EXT,
         GL_INTENSITY32UI_EXT,
         GL_LUMINANCE32UI_EXT,
         GL_LUMINANCE_ALPHA32UI_EXT, 0 },
      { PIPE_FORMAT_R32G32B32A32_USCALED, 0 }
a1395 1

d1421 5
a1425 1
      { GL_RGB_SNORM, GL_RGB8_SNORM, GL_RGBA_SNORM, GL_RGBA8_SNORM, 0 },
d1429 6
a1434 1
      { GL_RGB16_SNORM, GL_RGBA16_SNORM, 0 },
d1480 5
a1484 1
   }
d1490 1
d1497 2
a1498 1
                      unsigned tex_usage)
d1504 5
d1524 6
a1529 6
   { GL_RGBA,     GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_A8B8G8R8_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_A8B8G8R8_UNORM },
   { GL_RGBA,     GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_R8G8B8A8_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_R8G8B8A8_UNORM },
   { GL_BGRA,     GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_A8R8G8B8_UNORM },
   { GL_BGRA,     GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_B8G8R8A8_UNORM },
d1538 6
a1543 8
   { GL_BGRA,     GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_X8R8G8B8_UNORM },
   { GL_BGRA,     GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_B8G8R8X8_UNORM },
   { GL_BGRA,     GL_UNSIGNED_BYTE,               PIPE_FORMAT_B8G8R8X8_UNORM },
   /* No Mesa formats for these Gallium formats:
   { GL_RGBA,     GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_X8B8G8R8_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_X8B8G8R8_UNORM },
   { GL_RGBA,     GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_R8G8B8X8_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_R8G8B8X8_UNORM },
d1546 1
a1546 1
   */
d1611 4
d1617 1
a1617 1
st_choose_format(struct pipe_screen *screen, GLenum internalFormat,
d1620 1
a1620 1
                 unsigned bindings)
d1622 1
a1622 1
   GET_CURRENT_CONTEXT(ctx); /* XXX this should be a function parameter */
d1627 1
a1627 1
   if (_mesa_is_compressed_format(ctx, internalFormat)
d1648 2
a1649 1
                                         target, sample_count, bindings);
d1663 1
a1663 1
st_choose_renderbuffer_format(struct pipe_screen *screen,
d1671 37
a1707 2
   return st_choose_format(screen, internalFormat, GL_NONE, GL_NONE, PIPE_TEXTURE_2D,
                           sample_count, usage);
d1711 3
d1715 3
a1717 2
st_ChooseTextureFormat_renderable(struct gl_context *ctx, GLint internalFormat,
				  GLenum format, GLenum type, GLboolean renderable)
d1719 6
a1724 1
   struct pipe_screen *screen = st_context(ctx)->pipe->screen;
d1726 1
a1726 1
   uint bindings;
d1728 8
a1735 2
   (void) format;
   (void) type;
d1741 1
a1741 1
   if (renderable) {
d1748 2
a1749 2
   pFormat = st_choose_format(screen, internalFormat, format, type,
                              PIPE_TEXTURE_2D, 0, bindings);
d1753 3
a1755 2
      pFormat = st_choose_format(screen, internalFormat, format, type,
                                 PIPE_TEXTURE_2D, 0, PIPE_BIND_SAMPLER_VIEW);
d1770 3
a1772 3
gl_format
st_ChooseTextureFormat(struct gl_context *ctx, GLint internalFormat,
                       GLenum format, GLenum type)
d1774 5
a1778 5
   boolean want_renderable =
      internalFormat == 3 || internalFormat == 4 ||
      internalFormat == GL_RGB || internalFormat == GL_RGBA ||
      internalFormat == GL_RGB8 || internalFormat == GL_RGBA8 ||
      internalFormat == GL_BGRA;
d1780 4
a1783 3
   return st_ChooseTextureFormat_renderable(ctx, internalFormat,
					    format, type, want_renderable);
}
d1785 5
a1789 16
/**
 * Test if a gallium format is equivalent to a GL format/type.
 */
GLboolean
st_equal_formats(enum pipe_format pFormat, GLenum format, GLenum type)
{
   switch (pFormat) {
   case PIPE_FORMAT_A8B8G8R8_UNORM:
      return format == GL_RGBA && type == GL_UNSIGNED_BYTE;
   case PIPE_FORMAT_A8R8G8B8_UNORM:
      return format == GL_BGRA && type == GL_UNSIGNED_BYTE;
   case PIPE_FORMAT_B5G6R5_UNORM:
      return format == GL_RGB && type == GL_UNSIGNED_SHORT_5_6_5;
   /* XXX more combos... */
   default:
      return GL_FALSE;
a1790 1
}
d1792 9
a1800 5
GLboolean
st_sampler_compat_formats(enum pipe_format format1, enum pipe_format format2)
{
   if (format1 == format2)
      return GL_TRUE;
d1802 3
a1804 23
   if (format1 == PIPE_FORMAT_B8G8R8A8_UNORM &&
       format2 == PIPE_FORMAT_B8G8R8X8_UNORM)
      return GL_TRUE;

   if (format1 == PIPE_FORMAT_B8G8R8X8_UNORM &&
       format2 == PIPE_FORMAT_B8G8R8A8_UNORM)
      return GL_TRUE;

   if (format1 == PIPE_FORMAT_A8B8G8R8_UNORM &&
       format2 == PIPE_FORMAT_X8B8G8R8_UNORM)
      return GL_TRUE;

   if (format1 == PIPE_FORMAT_X8B8G8R8_UNORM &&
       format2 == PIPE_FORMAT_A8B8G8R8_UNORM)
      return GL_TRUE;

   if (format1 == PIPE_FORMAT_A8R8G8B8_UNORM &&
       format2 == PIPE_FORMAT_X8R8G8B8_UNORM)
      return GL_TRUE;

   if (format1 == PIPE_FORMAT_X8R8G8B8_UNORM &&
       format2 == PIPE_FORMAT_A8R8G8B8_UNORM)
      return GL_TRUE;
d1806 1
a1806 1
   return GL_FALSE;
a1809 1

d1814 3
a1816 2
 * GL_LUMINANCE buffer, ClearColor[0] = luminance and ClearColor[1] =
 * alpha.  Similarly for texture border colors.
d1819 3
a1821 2
st_translate_color(const GLfloat colorIn[4], GLenum baseFormat,
                   GLfloat colorOut[4])
d1823 83
a1905 36
   switch (baseFormat) {
   case GL_RED:
      colorOut[0] = colorIn[0];
      colorOut[1] = 0.0F;
      colorOut[2] = 0.0F;
      colorOut[3] = 1.0F;
      break;
   case GL_RG:
      colorOut[0] = colorIn[0];
      colorOut[1] = colorIn[1];
      colorOut[2] = 0.0F;
      colorOut[3] = 1.0F;
      break;
   case GL_RGB:
      colorOut[0] = colorIn[0];
      colorOut[1] = colorIn[1];
      colorOut[2] = colorIn[2];
      colorOut[3] = 1.0F;
      break;
   case GL_ALPHA:
      colorOut[0] = colorOut[1] = colorOut[2] = 0.0;
      colorOut[3] = colorIn[3];
      break;
   case GL_LUMINANCE:
      colorOut[0] = colorOut[1] = colorOut[2] = colorIn[0];
      colorOut[3] = 1.0;
      break;
   case GL_LUMINANCE_ALPHA:
      colorOut[0] = colorOut[1] = colorOut[2] = colorIn[0];
      colorOut[3] = colorIn[3];
      break;
   case GL_INTENSITY:
      colorOut[0] = colorOut[1] = colorOut[2] = colorOut[3] = colorIn[0];
      break;
   default:
      COPY_4V(colorOut, colorIn);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d40 1
d88 4
d112 2
d119 3
a121 2
         else {
            assert( size <= 32 );
d127 5
d172 6
d180 2
d184 2
d188 2
d192 2
d242 33
d302 56
d390 6
d398 2
d402 2
d406 2
d410 2
a416 2
   case PIPE_FORMAT_R16G16B16A16_SNORM:
      return MESA_FORMAT_SIGNED_RGBA_16;
d469 32
d527 56
d591 542
d1136 1
a1136 1
find_supported_format(struct pipe_screen *screen, 
a1137 1
                      uint num_formats,
d1140 1
a1140 2
                      unsigned tex_usage,
                      unsigned geom_flags)
d1143 1
a1143 1
   for (i = 0; i < num_formats; i++) {
d1145 1
a1145 1
                                      sample_count, tex_usage, geom_flags)) {
d1152 47
d1201 2
a1202 1
 * Find an RGBA format supported by the context/winsys.
d1205 7
a1211 15
default_rgba_format(struct pipe_screen *screen, 
                    enum pipe_texture_target target,
                    unsigned sample_count,
                    unsigned tex_usage,
                    unsigned geom_flags)
{
   static const enum pipe_format colorFormats[] = {
      PIPE_FORMAT_B8G8R8A8_UNORM,
      PIPE_FORMAT_A8R8G8B8_UNORM,
      PIPE_FORMAT_A8B8G8R8_UNORM,
      PIPE_FORMAT_B5G6R5_UNORM
   };
   return find_supported_format(screen, colorFormats, Elements(colorFormats),
                                target, sample_count, tex_usage, geom_flags);
}
d1213 17
d1231 3
a1233 22
/**
 * Find an RGB format supported by the context/winsys.
 */
static enum pipe_format
default_rgb_format(struct pipe_screen *screen, 
                   enum pipe_texture_target target,
                   unsigned sample_count,
                   unsigned tex_usage,
                   unsigned geom_flags)
{
   static const enum pipe_format colorFormats[] = {
      PIPE_FORMAT_B8G8R8X8_UNORM,
      PIPE_FORMAT_X8R8G8B8_UNORM,
      PIPE_FORMAT_X8B8G8R8_UNORM,
      PIPE_FORMAT_B8G8R8A8_UNORM,
      PIPE_FORMAT_A8R8G8B8_UNORM,
      PIPE_FORMAT_A8B8G8R8_UNORM,
      PIPE_FORMAT_B5G6R5_UNORM
   };
   return find_supported_format(screen, colorFormats, Elements(colorFormats),
                                target, sample_count, tex_usage, geom_flags);
}
d1235 1
a1235 17
/**
 * Find an sRGBA format supported by the context/winsys.
 */
static enum pipe_format
default_srgba_format(struct pipe_screen *screen, 
                    enum pipe_texture_target target,
                    unsigned sample_count,
                    unsigned tex_usage,
                    unsigned geom_flags)
{
   static const enum pipe_format colorFormats[] = {
      PIPE_FORMAT_B8G8R8A8_SRGB,
      PIPE_FORMAT_A8R8G8B8_SRGB,
      PIPE_FORMAT_A8B8G8R8_SRGB,
   };
   return find_supported_format(screen, colorFormats, Elements(colorFormats),
                                target, sample_count, tex_usage, geom_flags);
a1237 1

d1253 1
d1257 7
a1263 122
   unsigned geom_flags = 0; /* we don't care about POT vs. NPOT here, yet */

   switch (internalFormat) {
   case 4:
   case GL_RGBA:
   case GL_RGBA8:
   case GL_RGB10_A2:
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );

   case 3:
   case GL_RGB:
      return default_rgb_format( screen, target, sample_count, bindings,
                                 geom_flags );
   case GL_RGBA12:
   case GL_RGBA16:
      if (screen->is_format_supported( screen, PIPE_FORMAT_R16G16B16A16_UNORM,
                                             target, sample_count, bindings,
                                             geom_flags ))
         return PIPE_FORMAT_R16G16B16A16_UNORM;
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );

   case GL_RGBA4:
   case GL_RGBA2:
      if (screen->is_format_supported( screen, PIPE_FORMAT_B4G4R4A4_UNORM,
                                       target, sample_count, bindings,
                                       geom_flags ))
         return PIPE_FORMAT_B4G4R4A4_UNORM;
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );

   case GL_RGB5_A1:
      if (screen->is_format_supported( screen, PIPE_FORMAT_B5G5R5A1_UNORM,
                                       target, sample_count, bindings,
                                       geom_flags ))
         return PIPE_FORMAT_B5G5R5A1_UNORM;
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );

   case GL_RGB8:
   case GL_RGB10:
   case GL_RGB12:
   case GL_RGB16:
      return default_rgb_format( screen, target, sample_count, bindings,
                                 geom_flags );

   case GL_RGB5:
   case GL_RGB4:
   case GL_R3_G3_B2:
      if (screen->is_format_supported( screen, PIPE_FORMAT_B5G6R5_UNORM,
                                       target, sample_count, bindings,
                                       geom_flags ))
         return PIPE_FORMAT_B5G6R5_UNORM;
      if (screen->is_format_supported( screen, PIPE_FORMAT_B5G5R5A1_UNORM,
                                       target, sample_count, bindings,
                                       geom_flags ))
         return PIPE_FORMAT_B5G5R5A1_UNORM;
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );

   case GL_ALPHA:
   case GL_ALPHA4:
   case GL_ALPHA8:
   case GL_ALPHA12:
   case GL_ALPHA16:
   case GL_COMPRESSED_ALPHA:
      if (screen->is_format_supported( screen, PIPE_FORMAT_A8_UNORM, target,
                                       sample_count, bindings, geom_flags ))
         return PIPE_FORMAT_A8_UNORM;
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );

   case 1:
   case GL_LUMINANCE:
   case GL_LUMINANCE4:
   case GL_LUMINANCE8:
   case GL_LUMINANCE12:
   case GL_LUMINANCE16:
   case GL_COMPRESSED_LUMINANCE:
      if (screen->is_format_supported( screen, PIPE_FORMAT_L8_UNORM, target,
                                       sample_count, bindings, geom_flags ))
         return PIPE_FORMAT_L8_UNORM;
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );

   case 2:
   case GL_LUMINANCE_ALPHA:
   case GL_LUMINANCE4_ALPHA4:
   case GL_LUMINANCE6_ALPHA2:
   case GL_LUMINANCE8_ALPHA8:
   case GL_LUMINANCE12_ALPHA4:
   case GL_LUMINANCE12_ALPHA12:
   case GL_LUMINANCE16_ALPHA16:
   case GL_COMPRESSED_LUMINANCE_ALPHA:
      if (screen->is_format_supported( screen, PIPE_FORMAT_L8A8_UNORM, target,
                                       sample_count, bindings, geom_flags ))
         return PIPE_FORMAT_L8A8_UNORM;
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );

   case GL_INTENSITY:
   case GL_INTENSITY4:
   case GL_INTENSITY8:
   case GL_INTENSITY12:
   case GL_INTENSITY16:
   case GL_COMPRESSED_INTENSITY:
      if (screen->is_format_supported( screen, PIPE_FORMAT_I8_UNORM, target,
                                       sample_count, bindings, geom_flags ))
         return PIPE_FORMAT_I8_UNORM;
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );

   case GL_YCBCR_MESA:
      if (screen->is_format_supported(screen, PIPE_FORMAT_UYVY, target,
                                      sample_count, bindings, geom_flags)) {
         return PIPE_FORMAT_UYVY;
      }
      if (screen->is_format_supported(screen, PIPE_FORMAT_YUYV, target,
                                      sample_count, bindings, geom_flags)) {
         return PIPE_FORMAT_YUYV;
      }
d1265 1
d1267 18
a1284 97
   case GL_COMPRESSED_RED:
   case GL_COMPRESSED_RG:
   case GL_COMPRESSED_RGB:
      /* can only sample from compressed formats */
      if (bindings & ~PIPE_BIND_SAMPLER_VIEW)
         return PIPE_FORMAT_NONE;
      else if (screen->is_format_supported(screen, PIPE_FORMAT_DXT1_RGB,
                                           target, sample_count, bindings,
                                           geom_flags))
         return PIPE_FORMAT_DXT1_RGB;
      else
         return default_rgb_format(screen, target, sample_count, bindings,
                                   geom_flags);

   case GL_COMPRESSED_RGBA:
      /* can only sample from compressed formats */
      if (bindings & ~PIPE_BIND_SAMPLER_VIEW)
         return PIPE_FORMAT_NONE;
      else if (screen->is_format_supported(screen, PIPE_FORMAT_DXT3_RGBA,
                                           target, sample_count, bindings,
                                           geom_flags))
         return PIPE_FORMAT_DXT3_RGBA;
      else
         return default_rgba_format(screen, target, sample_count, bindings,
                                    geom_flags);

   case GL_RGB_S3TC:
   case GL_RGB4_S3TC:
   case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_DXT1_RGB,
                                      target, sample_count, bindings,
                                      geom_flags))
         return PIPE_FORMAT_DXT1_RGB;
      else
         return PIPE_FORMAT_NONE;

   case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_DXT1_RGBA,
                                      target, sample_count, bindings,
                                      geom_flags))
         return PIPE_FORMAT_DXT1_RGBA;
      else
         return PIPE_FORMAT_NONE;

   case GL_RGBA_S3TC:
   case GL_RGBA4_S3TC:
   case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_DXT3_RGBA,
                                      target, sample_count, bindings,
                                      geom_flags))
         return PIPE_FORMAT_DXT3_RGBA;
      else
         return PIPE_FORMAT_NONE;

   case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_DXT5_RGBA,
                                      target, sample_count, bindings,
                                      geom_flags))
         return PIPE_FORMAT_DXT5_RGBA;
      else
         return PIPE_FORMAT_NONE;

#if 0
   case GL_COMPRESSED_RGB_FXT1_3DFX:
      return PIPE_FORMAT_RGB_FXT1;
   case GL_COMPRESSED_RGBA_FXT1_3DFX:
      return PIPE_FORMAT_RGB_FXT1;
#endif

   case GL_DEPTH_COMPONENT16:
      if (screen->is_format_supported(screen, PIPE_FORMAT_Z16_UNORM, target,
                                      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_Z16_UNORM;
      /* fall-through */
   case GL_DEPTH_COMPONENT24:
      if (screen->is_format_supported(screen, PIPE_FORMAT_Z24_UNORM_S8_USCALED,
                                      target, sample_count, bindings, geom_flags))
         return PIPE_FORMAT_Z24_UNORM_S8_USCALED;
      if (screen->is_format_supported(screen, PIPE_FORMAT_S8_USCALED_Z24_UNORM,
                                      target, sample_count, bindings, geom_flags))
         return PIPE_FORMAT_S8_USCALED_Z24_UNORM;
      /* fall-through */
   case GL_DEPTH_COMPONENT32:
      if (screen->is_format_supported(screen, PIPE_FORMAT_Z32_UNORM, target,
                                      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_Z32_UNORM;
      /* fall-through */
   case GL_DEPTH_COMPONENT:
      {
         static const enum pipe_format formats[] = {
            PIPE_FORMAT_Z16_UNORM,
            PIPE_FORMAT_Z32_UNORM,
            PIPE_FORMAT_Z24_UNORM_S8_USCALED,
            PIPE_FORMAT_S8_USCALED_Z24_UNORM
         };
         return find_supported_format(screen, formats, Elements(formats),
                                      target, sample_count, bindings, geom_flags);
d1286 1
d1288 2
a1289 199
   case GL_STENCIL_INDEX:
   case GL_STENCIL_INDEX1_EXT:
   case GL_STENCIL_INDEX4_EXT:
   case GL_STENCIL_INDEX8_EXT:
   case GL_STENCIL_INDEX16_EXT:
      {
         static const enum pipe_format formats[] = {
            PIPE_FORMAT_S8_USCALED,
            PIPE_FORMAT_Z24_UNORM_S8_USCALED,
            PIPE_FORMAT_S8_USCALED_Z24_UNORM
         };
         return find_supported_format(screen, formats, Elements(formats),
                                      target, sample_count, bindings, geom_flags);
      }

   case GL_DEPTH_STENCIL_EXT:
   case GL_DEPTH24_STENCIL8_EXT:
      {
         static const enum pipe_format formats[] = {
            PIPE_FORMAT_Z24_UNORM_S8_USCALED,
            PIPE_FORMAT_S8_USCALED_Z24_UNORM
         };
         return find_supported_format(screen, formats, Elements(formats),
                                      target, sample_count, bindings, geom_flags);
      }

   case GL_SRGB_EXT:
   case GL_SRGB8_EXT:
   case GL_COMPRESSED_SRGB_EXT:
   case GL_COMPRESSED_SRGB_ALPHA_EXT:
   case GL_SRGB_ALPHA_EXT:
   case GL_SRGB8_ALPHA8_EXT:
      return default_srgba_format( screen, target, sample_count, bindings,
                                   geom_flags );
   case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
      return PIPE_FORMAT_DXT1_SRGB;
   case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
      return PIPE_FORMAT_DXT1_SRGBA;
   case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
      return PIPE_FORMAT_DXT3_SRGBA;
   case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
      return PIPE_FORMAT_DXT5_SRGBA;

   case GL_SLUMINANCE_ALPHA_EXT:
   case GL_SLUMINANCE8_ALPHA8_EXT:
   case GL_COMPRESSED_SLUMINANCE_EXT:
   case GL_COMPRESSED_SLUMINANCE_ALPHA_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_L8A8_SRGB, target,
                                      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_L8A8_SRGB;
      return default_srgba_format( screen, target, sample_count, bindings,
                                   geom_flags );

   case GL_SLUMINANCE_EXT:
   case GL_SLUMINANCE8_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_L8_SRGB, target,
                                      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_L8_SRGB;
      return default_srgba_format( screen, target, sample_count, bindings,
                                   geom_flags );

   case GL_RED:
   case GL_R8:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R8_UNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_R8_UNORM;
      return PIPE_FORMAT_NONE;
   case GL_RG:
   case GL_RG8:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R8G8_UNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_R8G8_UNORM;
      return PIPE_FORMAT_NONE;

   case GL_R16:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R16_UNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_R16_UNORM;
      return PIPE_FORMAT_NONE;

   case GL_RG16:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R16G16_UNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_R16G16_UNORM;
      return PIPE_FORMAT_NONE;

   case GL_COMPRESSED_RED_RGTC1:
      if (screen->is_format_supported(screen, PIPE_FORMAT_RGTC1_UNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_RGTC1_UNORM;
      return PIPE_FORMAT_NONE;

   case GL_COMPRESSED_SIGNED_RED_RGTC1:
      if (screen->is_format_supported(screen, PIPE_FORMAT_RGTC1_SNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_RGTC1_SNORM;
      return PIPE_FORMAT_NONE;

   case GL_COMPRESSED_RG_RGTC2:
      if (screen->is_format_supported(screen, PIPE_FORMAT_RGTC2_UNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_RGTC2_UNORM;
      return PIPE_FORMAT_NONE;

   case GL_COMPRESSED_SIGNED_RG_RGTC2:
      if (screen->is_format_supported(screen, PIPE_FORMAT_RGTC2_SNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_RGTC2_SNORM;
      return PIPE_FORMAT_NONE;

   /* signed/unsigned integer formats.
    * XXX Mesa only has formats for RGBA signed/unsigned integer formats.
    * If/when new formats are added this code should be updated.
    */
   case GL_RED_INTEGER_EXT:
   case GL_GREEN_INTEGER_EXT:
   case GL_BLUE_INTEGER_EXT:
   case GL_ALPHA_INTEGER_EXT:
   case GL_RGB_INTEGER_EXT:
   case GL_RGBA_INTEGER_EXT:
   case GL_BGR_INTEGER_EXT:
   case GL_BGRA_INTEGER_EXT:
   case GL_LUMINANCE_INTEGER_EXT:
   case GL_LUMINANCE_ALPHA_INTEGER_EXT:
      /* fall-through */
   case GL_RGBA8I_EXT:
   case GL_RGB8I_EXT:
   case GL_ALPHA8I_EXT:
   case GL_INTENSITY8I_EXT:
   case GL_LUMINANCE8I_EXT:
   case GL_LUMINANCE_ALPHA8I_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R8G8B8A8_SSCALED,
                                      target,
				      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_R8G8B8A8_SSCALED;
      return PIPE_FORMAT_NONE;
   case GL_RGBA16I_EXT:
   case GL_RGB16I_EXT:
   case GL_ALPHA16I_EXT:
   case GL_INTENSITY16I_EXT:
   case GL_LUMINANCE16I_EXT:
   case GL_LUMINANCE_ALPHA16I_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R16G16B16A16_SSCALED,
                                      target,
				      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_R16G16B16A16_SSCALED;
      return PIPE_FORMAT_NONE;
   case GL_RGBA32I_EXT:
   case GL_RGB32I_EXT:
   case GL_ALPHA32I_EXT:
   case GL_INTENSITY32I_EXT:
   case GL_LUMINANCE32I_EXT:
   case GL_LUMINANCE_ALPHA32I_EXT:
      /* xxx */
      if (screen->is_format_supported(screen, PIPE_FORMAT_R32G32B32A32_SSCALED,
                                      target,
				      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_R32G32B32A32_SSCALED;
      return PIPE_FORMAT_NONE;

   case GL_RGBA8UI_EXT:
   case GL_RGB8UI_EXT:
   case GL_ALPHA8UI_EXT:
   case GL_INTENSITY8UI_EXT:
   case GL_LUMINANCE8UI_EXT:
   case GL_LUMINANCE_ALPHA8UI_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R8G8B8A8_USCALED,
                                      target,
				      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_R8G8B8A8_USCALED;
      return PIPE_FORMAT_NONE;

   case GL_RGBA16UI_EXT:
   case GL_RGB16UI_EXT:
   case GL_ALPHA16UI_EXT:
   case GL_INTENSITY16UI_EXT:
   case GL_LUMINANCE16UI_EXT:
   case GL_LUMINANCE_ALPHA16UI_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R16G16B16A16_USCALED,
                                      target,
				      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_R16G16B16A16_USCALED;
      return PIPE_FORMAT_NONE;

   case GL_RGBA32UI_EXT:
   case GL_RGB32UI_EXT:
   case GL_ALPHA32UI_EXT:
   case GL_INTENSITY32UI_EXT:
   case GL_LUMINANCE32UI_EXT:
   case GL_LUMINANCE_ALPHA32UI_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R32G32B32A32_USCALED,
                                      target,
				      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_R32G32B32A32_USCALED;
      return PIPE_FORMAT_NONE;

   default:
      return PIPE_FORMAT_NONE;
   }
d1305 1
a1305 1
   return st_choose_format(screen, internalFormat, PIPE_TEXTURE_2D,
a1309 3
/**
 * Called via ctx->Driver.chooseTextureFormat().
 */
d1325 2
a1326 3
   if (renderable == GL_TRUE) {
      if (_mesa_is_depth_format(internalFormat) ||
	  _mesa_is_depth_or_stencil_format(internalFormat))
d1328 1
a1328 1
      else 
d1332 1
a1332 1
   pFormat = st_choose_format(screen, internalFormat,
d1337 1
a1337 1
      pFormat = st_choose_format(screen, internalFormat,
d1349 4
d1357 6
d1364 1
a1364 1
					    format, type, GL_TRUE);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d38 1
a38 1
#include "main/enums.h"
d70 1
d75 7
d87 4
a90 2
      else if (format == PIPE_FORMAT_Z24S8_UNORM ||
               format == PIPE_FORMAT_S8Z24_UNORM) {
d95 5
d101 1
a101 1
            if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED)
d107 1
a107 1
            if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED)
d114 1
a114 1
            if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED)
d128 2
a129 2
      /* compressed format? */
      assert(0);
a130 3

   assert(0);
   return GL_NONE;
d141 4
a144 2
      /* fix this */
   case MESA_FORMAT_ARGB8888_REV:
d147 2
d151 2
d172 1
a172 1
      return PIPE_FORMAT_S8Z24_UNORM;
d174 1
a174 1
      return PIPE_FORMAT_Z24S8_UNORM;
d179 2
d215 27
d244 1
a244 1
      return 0;
d256 4
d262 2
a265 2
   case PIPE_FORMAT_A8R8G8B8_UNORM:
      return MESA_FORMAT_ARGB8888_REV;
d282 1
a282 1
   case PIPE_FORMAT_S8_UNORM:
d285 2
d294 1
a294 1
   case PIPE_FORMAT_S8Z24_UNORM:
d300 1
a300 1
   case PIPE_FORMAT_Z24S8_UNORM:
d341 26
d375 23
d403 2
a404 1
                    unsigned tex_usage, 
d413 2
a414 7
   uint i;
   for (i = 0; i < Elements(colorFormats); i++) {
      if (screen->is_format_supported( screen, colorFormats[i], target, tex_usage, geom_flags )) {
         return colorFormats[i];
      }
   }
   return PIPE_FORMAT_NONE;
d417 1
d424 2
a425 1
                   unsigned tex_usage, 
d437 2
a438 7
   uint i;
   for (i = 0; i < Elements(colorFormats); i++) {
      if (screen->is_format_supported( screen, colorFormats[i], target, tex_usage, geom_flags )) {
         return colorFormats[i];
      }
   }
   return PIPE_FORMAT_NONE;
d447 2
a448 1
                    unsigned tex_usage, 
d456 2
a457 50
   uint i;
   for (i = 0; i < Elements(colorFormats); i++) {
      if (screen->is_format_supported( screen, colorFormats[i], target, tex_usage, geom_flags )) {
         return colorFormats[i];
      }
   }
   return PIPE_FORMAT_NONE;
}

/**
 * Search list of formats for first RGBA format with >8 bits/channel.
 */
static enum pipe_format
default_deep_rgba_format(struct pipe_screen *screen, 
                         enum pipe_texture_target target,
                         unsigned tex_usage, 
                         unsigned geom_flags)
{
   if (screen->is_format_supported(screen, PIPE_FORMAT_R16G16B16A16_SNORM, target, tex_usage, geom_flags)) {
      return PIPE_FORMAT_R16G16B16A16_SNORM;
   }
   if (tex_usage & PIPE_TEXTURE_USAGE_RENDER_TARGET)
      return default_rgba_format(screen, target, tex_usage, geom_flags);
   else
      return PIPE_FORMAT_NONE;
}


/**
 * Find an Z format supported by the context/winsys.
 */
static enum pipe_format
default_depth_format(struct pipe_screen *screen, 
                     enum pipe_texture_target target,
                     unsigned tex_usage, 
                     unsigned geom_flags)
{
   static const enum pipe_format zFormats[] = {
      PIPE_FORMAT_Z16_UNORM,
      PIPE_FORMAT_Z32_UNORM,
      PIPE_FORMAT_Z24S8_UNORM,
      PIPE_FORMAT_S8Z24_UNORM
   };
   uint i;
   for (i = 0; i < Elements(zFormats); i++) {
      if (screen->is_format_supported( screen, zFormats[i], target, tex_usage, geom_flags )) {
         return zFormats[i];
      }
   }
   return PIPE_FORMAT_NONE;
d464 7
d472 1
a472 2
 * \param tex_usage  either PIPE_TEXTURE_USAGE_RENDER_TARGET
 *                   or PIPE_TEXTURE_USAGE_SAMPLER
d476 2
a477 1
                 enum pipe_texture_target target, unsigned tex_usage)
d479 1
a479 1
   unsigned geom_flags = 0;
a483 1
   case GL_COMPRESSED_RGBA:
d486 3
a488 2
   case GL_RGBA12:
      return default_rgba_format( screen, target, tex_usage, geom_flags );
d491 3
a493 2
   case GL_COMPRESSED_RGB:
      return default_rgb_format( screen, target, tex_usage, geom_flags );
d495 6
a500 4
      if (tex_usage & PIPE_TEXTURE_USAGE_RENDER_TARGET)
         return default_deep_rgba_format( screen, target, tex_usage, geom_flags );
      else
         return default_rgba_format( screen, target, tex_usage, geom_flags );
d504 3
a506 1
      if (screen->is_format_supported( screen, PIPE_FORMAT_B4G4R4A4_UNORM, target, tex_usage, geom_flags ))
d508 2
a509 1
      return default_rgba_format( screen, target, tex_usage, geom_flags );
d512 3
a514 1
      if (screen->is_format_supported( screen, PIPE_FORMAT_B5G5R5A1_UNORM, target, tex_usage, geom_flags ))
d516 2
a517 1
      return default_rgba_format( screen, target, tex_usage, geom_flags );
d523 2
a524 1
      return default_rgb_format( screen, target, tex_usage, geom_flags );
d529 3
a531 1
      if (screen->is_format_supported( screen, PIPE_FORMAT_B5G6R5_UNORM, target, tex_usage, geom_flags ))
d533 3
a535 1
      if (screen->is_format_supported( screen, PIPE_FORMAT_B5G5R5A1_UNORM, target, tex_usage, geom_flags ))
d537 2
a538 1
      return default_rgba_format( screen, target, tex_usage, geom_flags );
d546 2
a547 1
      if (screen->is_format_supported( screen, PIPE_FORMAT_A8_UNORM, target, tex_usage, geom_flags ))
d549 2
a550 1
      return default_rgba_format( screen, target, tex_usage, geom_flags );
d559 2
a560 1
      if (screen->is_format_supported( screen, PIPE_FORMAT_L8_UNORM, target, tex_usage, geom_flags ))
d562 2
a563 1
      return default_rgba_format( screen, target, tex_usage, geom_flags );
d574 2
a575 1
      if (screen->is_format_supported( screen, PIPE_FORMAT_L8A8_UNORM, target, tex_usage, geom_flags ))
d577 2
a578 1
      return default_rgba_format( screen, target, tex_usage, geom_flags );
d586 2
a587 1
      if (screen->is_format_supported( screen, PIPE_FORMAT_I8_UNORM, target, tex_usage, geom_flags ))
d589 2
a590 1
      return default_rgba_format( screen, target, tex_usage, geom_flags );
d593 2
a594 2
      if (screen->is_format_supported(screen, PIPE_FORMAT_UYVY,
                                      target, tex_usage, geom_flags)) {
d597 2
a598 2
      if (screen->is_format_supported(screen, PIPE_FORMAT_YUYV,
                                      target, tex_usage, geom_flags)) {
d603 26
d632 6
a637 1
      return PIPE_FORMAT_DXT1_RGB;
d640 6
a645 1
      return PIPE_FORMAT_DXT1_RGBA;
d650 6
a655 1
      return PIPE_FORMAT_DXT3_RGBA;
d658 6
a663 1
      return PIPE_FORMAT_DXT5_RGBA;
d673 2
a674 1
      if (screen->is_format_supported( screen, PIPE_FORMAT_Z16_UNORM, target, tex_usage, geom_flags ))
d678 6
a683 4
      if (screen->is_format_supported( screen, PIPE_FORMAT_Z24S8_UNORM, target, tex_usage, geom_flags ))
         return PIPE_FORMAT_Z24S8_UNORM;
      if (screen->is_format_supported( screen, PIPE_FORMAT_S8Z24_UNORM, target, tex_usage, geom_flags ))
         return PIPE_FORMAT_S8Z24_UNORM;
d686 2
a687 1
      if (screen->is_format_supported( screen, PIPE_FORMAT_Z32_UNORM, target, tex_usage, geom_flags ))
d691 10
a700 1
      return default_depth_format( screen, target, tex_usage, geom_flags );
d707 9
a715 7
      if (screen->is_format_supported( screen, PIPE_FORMAT_S8_UNORM, target, tex_usage, geom_flags ))
         return PIPE_FORMAT_S8_UNORM;
      if (screen->is_format_supported( screen, PIPE_FORMAT_Z24S8_UNORM, target, tex_usage, geom_flags ))
         return PIPE_FORMAT_Z24S8_UNORM;
      if (screen->is_format_supported( screen, PIPE_FORMAT_S8Z24_UNORM, target, tex_usage, geom_flags ))
         return PIPE_FORMAT_S8Z24_UNORM;
      return PIPE_FORMAT_NONE;
d719 8
a726 5
      if (screen->is_format_supported( screen, PIPE_FORMAT_Z24S8_UNORM, target, tex_usage, geom_flags ))
         return PIPE_FORMAT_Z24S8_UNORM;
      if (screen->is_format_supported( screen, PIPE_FORMAT_S8Z24_UNORM, target, tex_usage, geom_flags ))
         return PIPE_FORMAT_S8Z24_UNORM;
      return PIPE_FORMAT_NONE;
d734 2
a735 1
      return default_srgba_format( screen, target, tex_usage, geom_flags );
d749 2
a750 1
      if (screen->is_format_supported( screen, PIPE_FORMAT_L8A8_SRGB, target, tex_usage, geom_flags ))
d752 2
a753 1
      return default_srgba_format( screen, target, tex_usage, geom_flags );
d757 2
a758 1
      if (screen->is_format_supported( screen, PIPE_FORMAT_L8_SRGB, target, tex_usage, geom_flags ))
d760 2
a761 1
      return default_srgba_format( screen, target, tex_usage, geom_flags );
d763 121
a883 1
   default:
a884 2
   }
}
d886 11
a897 16
static GLboolean
is_depth_or_stencil_format(GLenum internalFormat)
{
   switch (internalFormat) {
   case GL_DEPTH_COMPONENT:
   case GL_DEPTH_COMPONENT16:
   case GL_DEPTH_COMPONENT24:
   case GL_DEPTH_COMPONENT32:
   case GL_STENCIL_INDEX:
   case GL_STENCIL_INDEX1_EXT:
   case GL_STENCIL_INDEX4_EXT:
   case GL_STENCIL_INDEX8_EXT:
   case GL_STENCIL_INDEX16_EXT:
   case GL_DEPTH_STENCIL_EXT:
   case GL_DEPTH24_STENCIL8_EXT:
      return GL_TRUE;
d899 1
a899 1
      return GL_FALSE;
d903 1
d909 1
a909 1
                              GLenum internalFormat)
d912 2
a913 2
   if (is_depth_or_stencil_format(internalFormat))
      usage = PIPE_TEXTURE_USAGE_DEPTH_STENCIL;
d915 3
a917 2
      usage = PIPE_TEXTURE_USAGE_RENDER_TARGET;
   return st_choose_format(screen, internalFormat, PIPE_TEXTURE_2D, usage);
d925 2
a926 2
st_ChooseTextureFormat(GLcontext *ctx, GLint internalFormat,
                       GLenum format, GLenum type)
d928 1
d930 1
d935 23
a957 3
   pFormat = st_choose_format(ctx->st->pipe->screen, internalFormat,
                              PIPE_TEXTURE_2D, PIPE_TEXTURE_USAGE_SAMPLER);
   if (pFormat == PIPE_FORMAT_NONE)
d959 1
d964 7
d988 85
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d38 1
a38 1
#include "main/image.h"
a69 1
   int i;
a73 7
   /* Find the first non-VOID channel. */
   for (i = 0; i < 4; i++) {
       if (desc->channel[i].type != UTIL_FORMAT_TYPE_VOID) {
           break;
       }
   }

d79 2
a80 4
      else if (format == PIPE_FORMAT_Z24_UNORM_S8_USCALED ||
               format == PIPE_FORMAT_S8_USCALED_Z24_UNORM ||
               format == PIPE_FORMAT_Z24X8_UNORM ||
               format == PIPE_FORMAT_X8Z24_UNORM) {
a84 5

         assert(i < 4);
         if (i == 4)
            return GL_NONE;

d86 1
a86 1
            if (desc->channel[i].type == UTIL_FORMAT_TYPE_UNSIGNED)
d92 1
a92 1
            if (desc->channel[i].type == UTIL_FORMAT_TYPE_UNSIGNED)
d99 1
a99 1
            if (desc->channel[i].type == UTIL_FORMAT_TYPE_UNSIGNED)
d113 2
a114 2
      /* probably a compressed format, unsupported anyway */
      return GL_NONE;
d116 3
d129 2
a130 4
   case MESA_FORMAT_RGBA8888:
      return PIPE_FORMAT_A8B8G8R8_UNORM;
   case MESA_FORMAT_RGBA8888_REV:
      return PIPE_FORMAT_R8G8B8A8_UNORM;
a132 2
   case MESA_FORMAT_ARGB8888_REV:
      return PIPE_FORMAT_A8R8G8B8_UNORM;
a134 2
   case MESA_FORMAT_XRGB8888_REV:
      return PIPE_FORMAT_X8R8G8B8_UNORM;
d154 1
a154 1
      return PIPE_FORMAT_S8_USCALED_Z24_UNORM;
d156 1
a156 1
      return PIPE_FORMAT_Z24_UNORM_S8_USCALED;
a160 2
   case MESA_FORMAT_S8:
      return PIPE_FORMAT_S8_USCALED;
a194 27
   case MESA_FORMAT_R8:
      return PIPE_FORMAT_R8_UNORM;
   case MESA_FORMAT_R16:
      return PIPE_FORMAT_R16_UNORM;
   case MESA_FORMAT_RG88:
      return PIPE_FORMAT_R8G8_UNORM;
   case MESA_FORMAT_RG1616:
      return PIPE_FORMAT_R16G16_UNORM;
   case MESA_FORMAT_RGBA_16:
      return PIPE_FORMAT_R16G16B16A16_UNORM;

   /* signed int formats */
   case MESA_FORMAT_RGBA_INT8:
      return PIPE_FORMAT_R8G8B8A8_SSCALED;
   case MESA_FORMAT_RGBA_INT16:
      return PIPE_FORMAT_R16G16B16A16_SSCALED;
   case MESA_FORMAT_RGBA_INT32:
      return PIPE_FORMAT_R32G32B32A32_SSCALED;

   /* unsigned int formats */
   case MESA_FORMAT_RGBA_UINT8:
      return PIPE_FORMAT_R8G8B8A8_USCALED;
   case MESA_FORMAT_RGBA_UINT16:
      return PIPE_FORMAT_R16G16B16A16_USCALED;
   case MESA_FORMAT_RGBA_UINT32:
      return PIPE_FORMAT_R32G32B32A32_USCALED;

d197 1
a197 1
      return PIPE_FORMAT_NONE;
a208 4
   case PIPE_FORMAT_A8B8G8R8_UNORM:
      return MESA_FORMAT_RGBA8888;
   case PIPE_FORMAT_R8G8B8A8_UNORM:
      return MESA_FORMAT_RGBA8888_REV;
d211 2
a214 2
   case PIPE_FORMAT_B8G8R8X8_UNORM:
      return MESA_FORMAT_XRGB8888;
d231 1
a231 1
   case PIPE_FORMAT_S8_USCALED:
a233 2
   case PIPE_FORMAT_R16G16B16A16_UNORM:
      return MESA_FORMAT_RGBA_16;
d241 1
a241 1
   case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d247 1
a247 1
   case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
a287 26

   case PIPE_FORMAT_R8_UNORM:
      return MESA_FORMAT_R8;
   case PIPE_FORMAT_R16_UNORM:
      return MESA_FORMAT_R16;
   case PIPE_FORMAT_R8G8_UNORM:
      return MESA_FORMAT_RG88;
   case PIPE_FORMAT_R16G16_UNORM:
      return MESA_FORMAT_RG1616;

   /* signed int formats */
   case PIPE_FORMAT_R8G8B8A8_SSCALED:
      return MESA_FORMAT_RGBA_INT8;
   case PIPE_FORMAT_R16G16B16A16_SSCALED:
      return MESA_FORMAT_RGBA_INT16;
   case PIPE_FORMAT_R32G32B32A32_SSCALED:
      return MESA_FORMAT_RGBA_INT32;

   /* unsigned int formats */
   case PIPE_FORMAT_R8G8B8A8_USCALED:
      return MESA_FORMAT_RGBA_UINT8;
   case PIPE_FORMAT_R16G16B16A16_USCALED:
      return MESA_FORMAT_RGBA_UINT16;
   case PIPE_FORMAT_R32G32B32A32_USCALED:
      return MESA_FORMAT_RGBA_UINT32;

a295 23
 * Return first supported format from the given list.
 */
static enum pipe_format
find_supported_format(struct pipe_screen *screen, 
                      const enum pipe_format formats[],
                      uint num_formats,
                      enum pipe_texture_target target,
                      unsigned sample_count,
                      unsigned tex_usage,
                      unsigned geom_flags)
{
   uint i;
   for (i = 0; i < num_formats; i++) {
      if (screen->is_format_supported(screen, formats[i], target,
                                      sample_count, tex_usage, geom_flags)) {
         return formats[i];
      }
   }
   return PIPE_FORMAT_NONE;
}


/**
d301 1
a301 2
                    unsigned sample_count,
                    unsigned tex_usage,
d310 7
a316 2
   return find_supported_format(screen, colorFormats, Elements(colorFormats),
                                target, sample_count, tex_usage, geom_flags);
a318 1

d325 1
a325 2
                   unsigned sample_count,
                   unsigned tex_usage,
d337 7
a343 2
   return find_supported_format(screen, colorFormats, Elements(colorFormats),
                                target, sample_count, tex_usage, geom_flags);
d352 1
a352 2
                    unsigned sample_count,
                    unsigned tex_usage,
d360 50
a409 2
   return find_supported_format(screen, colorFormats, Elements(colorFormats),
                                target, sample_count, tex_usage, geom_flags);
a415 7
 * This is called during glTexImage2D, for example.
 *
 * The bindings parameter typically has PIPE_BIND_SAMPLER_VIEW set, plus
 * either PIPE_BINDING_RENDER_TARGET or PIPE_BINDING_DEPTH_STENCIL if
 * we want render-to-texture ability.
 *
 * \param internalFormat  the user value passed to glTexImage2D
d417 2
a418 1
 * \param bindings  bitmask of PIPE_BIND_x flags.
d422 1
a422 2
                 enum pipe_texture_target target, unsigned sample_count,
                 unsigned bindings)
d424 1
a424 1
   unsigned geom_flags = 0; /* we don't care about POT vs. NPOT here, yet */
d429 1
d432 2
a433 3
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );

d436 2
a437 3
      return default_rgb_format( screen, target, sample_count, bindings,
                                 geom_flags );
   case GL_RGBA12:
d439 4
a442 6
      if (screen->is_format_supported( screen, PIPE_FORMAT_R16G16B16A16_UNORM,
                                             target, sample_count, bindings,
                                             geom_flags ))
         return PIPE_FORMAT_R16G16B16A16_UNORM;
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );
d446 1
a446 3
      if (screen->is_format_supported( screen, PIPE_FORMAT_B4G4R4A4_UNORM,
                                       target, sample_count, bindings,
                                       geom_flags ))
d448 1
a448 2
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );
d451 1
a451 3
      if (screen->is_format_supported( screen, PIPE_FORMAT_B5G5R5A1_UNORM,
                                       target, sample_count, bindings,
                                       geom_flags ))
d453 1
a453 2
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );
d459 1
a459 2
      return default_rgb_format( screen, target, sample_count, bindings,
                                 geom_flags );
d464 1
a464 3
      if (screen->is_format_supported( screen, PIPE_FORMAT_B5G6R5_UNORM,
                                       target, sample_count, bindings,
                                       geom_flags ))
d466 1
a466 3
      if (screen->is_format_supported( screen, PIPE_FORMAT_B5G5R5A1_UNORM,
                                       target, sample_count, bindings,
                                       geom_flags ))
d468 1
a468 2
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );
d476 1
a476 2
      if (screen->is_format_supported( screen, PIPE_FORMAT_A8_UNORM, target,
                                       sample_count, bindings, geom_flags ))
d478 1
a478 2
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );
d487 1
a487 2
      if (screen->is_format_supported( screen, PIPE_FORMAT_L8_UNORM, target,
                                       sample_count, bindings, geom_flags ))
d489 1
a489 2
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );
d500 1
a500 2
      if (screen->is_format_supported( screen, PIPE_FORMAT_L8A8_UNORM, target,
                                       sample_count, bindings, geom_flags ))
d502 1
a502 2
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );
d510 1
a510 2
      if (screen->is_format_supported( screen, PIPE_FORMAT_I8_UNORM, target,
                                       sample_count, bindings, geom_flags ))
d512 1
a512 2
      return default_rgba_format( screen, target, sample_count, bindings,
                                  geom_flags );
d515 2
a516 2
      if (screen->is_format_supported(screen, PIPE_FORMAT_UYVY, target,
                                      sample_count, bindings, geom_flags)) {
d519 2
a520 2
      if (screen->is_format_supported(screen, PIPE_FORMAT_YUYV, target,
                                      sample_count, bindings, geom_flags)) {
a524 26
   case GL_COMPRESSED_RED:
   case GL_COMPRESSED_RG:
   case GL_COMPRESSED_RGB:
      /* can only sample from compressed formats */
      if (bindings & ~PIPE_BIND_SAMPLER_VIEW)
         return PIPE_FORMAT_NONE;
      else if (screen->is_format_supported(screen, PIPE_FORMAT_DXT1_RGB,
                                           target, sample_count, bindings,
                                           geom_flags))
         return PIPE_FORMAT_DXT1_RGB;
      else
         return default_rgb_format(screen, target, sample_count, bindings,
                                   geom_flags);

   case GL_COMPRESSED_RGBA:
      /* can only sample from compressed formats */
      if (bindings & ~PIPE_BIND_SAMPLER_VIEW)
         return PIPE_FORMAT_NONE;
      else if (screen->is_format_supported(screen, PIPE_FORMAT_DXT3_RGBA,
                                           target, sample_count, bindings,
                                           geom_flags))
         return PIPE_FORMAT_DXT3_RGBA;
      else
         return default_rgba_format(screen, target, sample_count, bindings,
                                    geom_flags);

d528 1
a528 6
      if (screen->is_format_supported(screen, PIPE_FORMAT_DXT1_RGB,
                                      target, sample_count, bindings,
                                      geom_flags))
         return PIPE_FORMAT_DXT1_RGB;
      else
         return PIPE_FORMAT_NONE;
d531 1
a531 6
      if (screen->is_format_supported(screen, PIPE_FORMAT_DXT1_RGBA,
                                      target, sample_count, bindings,
                                      geom_flags))
         return PIPE_FORMAT_DXT1_RGBA;
      else
         return PIPE_FORMAT_NONE;
d536 1
a536 6
      if (screen->is_format_supported(screen, PIPE_FORMAT_DXT3_RGBA,
                                      target, sample_count, bindings,
                                      geom_flags))
         return PIPE_FORMAT_DXT3_RGBA;
      else
         return PIPE_FORMAT_NONE;
d539 1
a539 6
      if (screen->is_format_supported(screen, PIPE_FORMAT_DXT5_RGBA,
                                      target, sample_count, bindings,
                                      geom_flags))
         return PIPE_FORMAT_DXT5_RGBA;
      else
         return PIPE_FORMAT_NONE;
d549 1
a549 2
      if (screen->is_format_supported(screen, PIPE_FORMAT_Z16_UNORM, target,
                                      sample_count, bindings, geom_flags))
d553 4
a556 6
      if (screen->is_format_supported(screen, PIPE_FORMAT_Z24_UNORM_S8_USCALED,
                                      target, sample_count, bindings, geom_flags))
         return PIPE_FORMAT_Z24_UNORM_S8_USCALED;
      if (screen->is_format_supported(screen, PIPE_FORMAT_S8_USCALED_Z24_UNORM,
                                      target, sample_count, bindings, geom_flags))
         return PIPE_FORMAT_S8_USCALED_Z24_UNORM;
d559 1
a559 2
      if (screen->is_format_supported(screen, PIPE_FORMAT_Z32_UNORM, target,
                                      sample_count, bindings, geom_flags))
d563 1
a563 10
      {
         static const enum pipe_format formats[] = {
            PIPE_FORMAT_Z16_UNORM,
            PIPE_FORMAT_Z32_UNORM,
            PIPE_FORMAT_Z24_UNORM_S8_USCALED,
            PIPE_FORMAT_S8_USCALED_Z24_UNORM
         };
         return find_supported_format(screen, formats, Elements(formats),
                                      target, sample_count, bindings, geom_flags);
      }
d570 7
a576 9
      {
         static const enum pipe_format formats[] = {
            PIPE_FORMAT_S8_USCALED,
            PIPE_FORMAT_Z24_UNORM_S8_USCALED,
            PIPE_FORMAT_S8_USCALED_Z24_UNORM
         };
         return find_supported_format(screen, formats, Elements(formats),
                                      target, sample_count, bindings, geom_flags);
      }
d580 5
a584 8
      {
         static const enum pipe_format formats[] = {
            PIPE_FORMAT_Z24_UNORM_S8_USCALED,
            PIPE_FORMAT_S8_USCALED_Z24_UNORM
         };
         return find_supported_format(screen, formats, Elements(formats),
                                      target, sample_count, bindings, geom_flags);
      }
d592 1
a592 2
      return default_srgba_format( screen, target, sample_count, bindings,
                                   geom_flags );
d606 1
a606 2
      if (screen->is_format_supported(screen, PIPE_FORMAT_L8A8_SRGB, target,
                                      sample_count, bindings, geom_flags))
d608 1
a608 2
      return default_srgba_format( screen, target, sample_count, bindings,
                                   geom_flags );
d612 1
a612 2
      if (screen->is_format_supported(screen, PIPE_FORMAT_L8_SRGB, target,
                                      sample_count, bindings, geom_flags))
d614 1
a614 2
      return default_srgba_format( screen, target, sample_count, bindings,
                                   geom_flags );
d616 1
a616 11
   case GL_RED:
   case GL_R8:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R8_UNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_R8_UNORM;
      return PIPE_FORMAT_NONE;
   case GL_RG:
   case GL_RG8:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R8G8_UNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_R8G8_UNORM;
d618 2
a620 121
   case GL_R16:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R16_UNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_R16_UNORM;
      return PIPE_FORMAT_NONE;

   case GL_RG16:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R16G16_UNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_R16G16_UNORM;
      return PIPE_FORMAT_NONE;

   case GL_COMPRESSED_RED_RGTC1:
      if (screen->is_format_supported(screen, PIPE_FORMAT_RGTC1_UNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_RGTC1_UNORM;
      return PIPE_FORMAT_NONE;

   case GL_COMPRESSED_SIGNED_RED_RGTC1:
      if (screen->is_format_supported(screen, PIPE_FORMAT_RGTC1_SNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_RGTC1_SNORM;
      return PIPE_FORMAT_NONE;

   case GL_COMPRESSED_RG_RGTC2:
      if (screen->is_format_supported(screen, PIPE_FORMAT_RGTC2_UNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_RGTC2_UNORM;
      return PIPE_FORMAT_NONE;

   case GL_COMPRESSED_SIGNED_RG_RGTC2:
      if (screen->is_format_supported(screen, PIPE_FORMAT_RGTC2_SNORM, target,
				      sample_count, bindings, geom_flags))
	      return PIPE_FORMAT_RGTC2_SNORM;
      return PIPE_FORMAT_NONE;

   /* signed/unsigned integer formats.
    * XXX Mesa only has formats for RGBA signed/unsigned integer formats.
    * If/when new formats are added this code should be updated.
    */
   case GL_RED_INTEGER_EXT:
   case GL_GREEN_INTEGER_EXT:
   case GL_BLUE_INTEGER_EXT:
   case GL_ALPHA_INTEGER_EXT:
   case GL_RGB_INTEGER_EXT:
   case GL_RGBA_INTEGER_EXT:
   case GL_BGR_INTEGER_EXT:
   case GL_BGRA_INTEGER_EXT:
   case GL_LUMINANCE_INTEGER_EXT:
   case GL_LUMINANCE_ALPHA_INTEGER_EXT:
      /* fall-through */
   case GL_RGBA8I_EXT:
   case GL_RGB8I_EXT:
   case GL_ALPHA8I_EXT:
   case GL_INTENSITY8I_EXT:
   case GL_LUMINANCE8I_EXT:
   case GL_LUMINANCE_ALPHA8I_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R8G8B8A8_SSCALED,
                                      target,
				      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_R8G8B8A8_SSCALED;
      return PIPE_FORMAT_NONE;
   case GL_RGBA16I_EXT:
   case GL_RGB16I_EXT:
   case GL_ALPHA16I_EXT:
   case GL_INTENSITY16I_EXT:
   case GL_LUMINANCE16I_EXT:
   case GL_LUMINANCE_ALPHA16I_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R16G16B16A16_SSCALED,
                                      target,
				      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_R16G16B16A16_SSCALED;
      return PIPE_FORMAT_NONE;
   case GL_RGBA32I_EXT:
   case GL_RGB32I_EXT:
   case GL_ALPHA32I_EXT:
   case GL_INTENSITY32I_EXT:
   case GL_LUMINANCE32I_EXT:
   case GL_LUMINANCE_ALPHA32I_EXT:
      /* xxx */
      if (screen->is_format_supported(screen, PIPE_FORMAT_R32G32B32A32_SSCALED,
                                      target,
				      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_R32G32B32A32_SSCALED;
      return PIPE_FORMAT_NONE;

   case GL_RGBA8UI_EXT:
   case GL_RGB8UI_EXT:
   case GL_ALPHA8UI_EXT:
   case GL_INTENSITY8UI_EXT:
   case GL_LUMINANCE8UI_EXT:
   case GL_LUMINANCE_ALPHA8UI_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R8G8B8A8_USCALED,
                                      target,
				      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_R8G8B8A8_USCALED;
      return PIPE_FORMAT_NONE;

   case GL_RGBA16UI_EXT:
   case GL_RGB16UI_EXT:
   case GL_ALPHA16UI_EXT:
   case GL_INTENSITY16UI_EXT:
   case GL_LUMINANCE16UI_EXT:
   case GL_LUMINANCE_ALPHA16UI_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R16G16B16A16_USCALED,
                                      target,
				      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_R16G16B16A16_USCALED;
      return PIPE_FORMAT_NONE;

   case GL_RGBA32UI_EXT:
   case GL_RGB32UI_EXT:
   case GL_ALPHA32UI_EXT:
   case GL_INTENSITY32UI_EXT:
   case GL_LUMINANCE32UI_EXT:
   case GL_LUMINANCE_ALPHA32UI_EXT:
      if (screen->is_format_supported(screen, PIPE_FORMAT_R32G32B32A32_USCALED,
                                      target,
				      sample_count, bindings, geom_flags))
         return PIPE_FORMAT_R32G32B32A32_USCALED;
      return PIPE_FORMAT_NONE;
d622 16
d639 1
a639 1
      return PIPE_FORMAT_NONE;
a642 1

d648 1
a648 1
                              GLenum internalFormat, unsigned sample_count)
d651 2
a652 2
   if (_mesa_is_depth_or_stencil_format(internalFormat))
      usage = PIPE_BIND_DEPTH_STENCIL;
d654 2
a655 3
      usage = PIPE_BIND_RENDER_TARGET;
   return st_choose_format(screen, internalFormat, PIPE_TEXTURE_2D,
                           sample_count, usage);
d663 2
a664 2
st_ChooseTextureFormat_renderable(struct gl_context *ctx, GLint internalFormat,
				  GLenum format, GLenum type, GLboolean renderable)
a665 1
   struct pipe_screen *screen = st_context(ctx)->pipe->screen;
a666 1
   uint bindings;
d671 3
a673 23
   /* GL textures may wind up being render targets, but we don't know
    * that in advance.  Specify potential render target flags now.
    */
   bindings = PIPE_BIND_SAMPLER_VIEW;
   if (renderable == GL_TRUE) {
      if (_mesa_is_depth_format(internalFormat) ||
	  _mesa_is_depth_or_stencil_format(internalFormat))
	 bindings |= PIPE_BIND_DEPTH_STENCIL;
      else 
	 bindings |= PIPE_BIND_RENDER_TARGET;
   }

   pFormat = st_choose_format(screen, internalFormat,
                              PIPE_TEXTURE_2D, 0, bindings);

   if (pFormat == PIPE_FORMAT_NONE) {
      /* try choosing format again, this time without render target bindings */
      pFormat = st_choose_format(screen, internalFormat,
                                 PIPE_TEXTURE_2D, 0, PIPE_BIND_SAMPLER_VIEW);
   }

   if (pFormat == PIPE_FORMAT_NONE) {
      /* no luck at all */
a674 1
   }
a678 7
gl_format
st_ChooseTextureFormat(struct gl_context *ctx, GLint internalFormat,
                       GLenum format, GLenum type)
{
   return st_ChooseTextureFormat_renderable(ctx, internalFormat,
					    format, type, GL_TRUE);
}
a695 85
   }
}

GLboolean
st_sampler_compat_formats(enum pipe_format format1, enum pipe_format format2)
{
   if (format1 == format2)
      return GL_TRUE;

   if (format1 == PIPE_FORMAT_B8G8R8A8_UNORM &&
       format2 == PIPE_FORMAT_B8G8R8X8_UNORM)
      return GL_TRUE;

   if (format1 == PIPE_FORMAT_B8G8R8X8_UNORM &&
       format2 == PIPE_FORMAT_B8G8R8A8_UNORM)
      return GL_TRUE;

   if (format1 == PIPE_FORMAT_A8B8G8R8_UNORM &&
       format2 == PIPE_FORMAT_X8B8G8R8_UNORM)
      return GL_TRUE;

   if (format1 == PIPE_FORMAT_X8B8G8R8_UNORM &&
       format2 == PIPE_FORMAT_A8B8G8R8_UNORM)
      return GL_TRUE;

   if (format1 == PIPE_FORMAT_A8R8G8B8_UNORM &&
       format2 == PIPE_FORMAT_X8R8G8B8_UNORM)
      return GL_TRUE;

   if (format1 == PIPE_FORMAT_X8R8G8B8_UNORM &&
       format2 == PIPE_FORMAT_A8R8G8B8_UNORM)
      return GL_TRUE;

   return GL_FALSE;
}



/**
 * This is used for translating texture border color and the clear
 * color.  For example, the clear color is interpreted according to
 * the renderbuffer's base format.  For example, if clearing a
 * GL_LUMINANCE buffer, ClearColor[0] = luminance and ClearColor[1] =
 * alpha.  Similarly for texture border colors.
 */
void
st_translate_color(const GLfloat colorIn[4], GLenum baseFormat,
                   GLfloat colorOut[4])
{
   switch (baseFormat) {
   case GL_RED:
      colorOut[0] = colorIn[0];
      colorOut[1] = 0.0F;
      colorOut[2] = 0.0F;
      colorOut[3] = 1.0F;
      break;
   case GL_RG:
      colorOut[0] = colorIn[0];
      colorOut[1] = colorIn[1];
      colorOut[2] = 0.0F;
      colorOut[3] = 1.0F;
      break;
   case GL_RGB:
      colorOut[0] = colorIn[0];
      colorOut[1] = colorIn[1];
      colorOut[2] = colorIn[2];
      colorOut[3] = 1.0F;
      break;
   case GL_ALPHA:
      colorOut[0] = colorOut[1] = colorOut[2] = 0.0;
      colorOut[3] = colorIn[3];
      break;
   case GL_LUMINANCE:
      colorOut[0] = colorOut[1] = colorOut[2] = colorIn[0];
      colorOut[3] = 1.0;
      break;
   case GL_LUMINANCE_ALPHA:
      colorOut[0] = colorOut[1] = colorOut[2] = colorIn[0];
      colorOut[3] = colorIn[3];
      break;
   case GL_INTENSITY:
      colorOut[0] = colorOut[1] = colorOut[2] = colorOut[3] = colorIn[0];
      break;
   default:
      COPY_4V(colorOut, colorIn);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a36 1
#include "main/glformats.h"
d49 85
d142 1
a142 1
      return PIPE_FORMAT_ABGR8888_UNORM;
d144 1
a144 1
      return PIPE_FORMAT_RGBA8888_UNORM;
d146 1
a146 1
      return PIPE_FORMAT_BGRA8888_UNORM;
d148 1
a148 5
      return PIPE_FORMAT_ARGB8888_UNORM;
   case MESA_FORMAT_RGBX8888:
      return PIPE_FORMAT_XBGR8888_UNORM;
   case MESA_FORMAT_RGBX8888_REV:
      return PIPE_FORMAT_RGBX8888_UNORM;
d150 1
a150 1
      return PIPE_FORMAT_BGRX8888_UNORM;
d152 1
a152 1
      return PIPE_FORMAT_XRGB8888_UNORM;
a158 6
   case MESA_FORMAT_RGB332:
      return PIPE_FORMAT_B2G3R3_UNORM;
   case MESA_FORMAT_ARGB2101010:
      return PIPE_FORMAT_B10G10R10A2_UNORM;
   case MESA_FORMAT_AL44:
      return PIPE_FORMAT_L4A4_UNORM;
a160 2
   case MESA_FORMAT_AL1616:
      return PIPE_FORMAT_L16A16_UNORM;
a162 2
   case MESA_FORMAT_A16:
      return PIPE_FORMAT_A16_UNORM;
a164 2
   case MESA_FORMAT_L16:
      return PIPE_FORMAT_L16_UNORM;
a166 2
   case MESA_FORMAT_I16:
      return PIPE_FORMAT_I16_UNORM;
d172 1
a172 1
      return PIPE_FORMAT_S8_UINT_Z24_UNORM;
d174 1
a174 1
      return PIPE_FORMAT_Z24_UNORM_S8_UINT;
d180 1
a180 5
      return PIPE_FORMAT_S8_UINT;
   case MESA_FORMAT_Z32_FLOAT:
      return PIPE_FORMAT_Z32_FLOAT;
   case MESA_FORMAT_Z32_FLOAT_X24S8:
      return PIPE_FORMAT_Z32_FLOAT_S8X24_UINT;
d183 1
d192 1
d201 3
d214 1
a214 33
   case MESA_FORMAT_RGBA_FLOAT32:
      return PIPE_FORMAT_R32G32B32A32_FLOAT;
   case MESA_FORMAT_RGBA_FLOAT16:
      return PIPE_FORMAT_R16G16B16A16_FLOAT;
   case MESA_FORMAT_RGB_FLOAT32:
      return PIPE_FORMAT_R32G32B32_FLOAT;
   case MESA_FORMAT_RGB_FLOAT16:
      return PIPE_FORMAT_R16G16B16_FLOAT;
   case MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32:
      return PIPE_FORMAT_L32A32_FLOAT;
   case MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16:
      return PIPE_FORMAT_L16A16_FLOAT;
   case MESA_FORMAT_LUMINANCE_FLOAT32:
      return PIPE_FORMAT_L32_FLOAT;
   case MESA_FORMAT_LUMINANCE_FLOAT16:
      return PIPE_FORMAT_L16_FLOAT;
   case MESA_FORMAT_ALPHA_FLOAT32:
      return PIPE_FORMAT_A32_FLOAT;
   case MESA_FORMAT_ALPHA_FLOAT16:
      return PIPE_FORMAT_A16_FLOAT;
   case MESA_FORMAT_INTENSITY_FLOAT32:
      return PIPE_FORMAT_I32_FLOAT;
   case MESA_FORMAT_INTENSITY_FLOAT16:
      return PIPE_FORMAT_I16_FLOAT;
   case MESA_FORMAT_R_FLOAT32:
      return PIPE_FORMAT_R32_FLOAT;
   case MESA_FORMAT_R_FLOAT16:
      return PIPE_FORMAT_R16_FLOAT;
   case MESA_FORMAT_RG_FLOAT32:
      return PIPE_FORMAT_R32G32_FLOAT;
   case MESA_FORMAT_RG_FLOAT16:
      return PIPE_FORMAT_R16G16_FLOAT;

d219 1
a219 1
   case MESA_FORMAT_GR88:
d221 1
a221 1
   case MESA_FORMAT_GR1616:
a226 62
   case MESA_FORMAT_ALPHA_UINT8:
      return PIPE_FORMAT_A8_UINT;
   case MESA_FORMAT_ALPHA_UINT16:
      return PIPE_FORMAT_A16_UINT;
   case MESA_FORMAT_ALPHA_UINT32:
      return PIPE_FORMAT_A32_UINT;

   case MESA_FORMAT_ALPHA_INT8:
      return PIPE_FORMAT_A8_SINT;
   case MESA_FORMAT_ALPHA_INT16:
      return PIPE_FORMAT_A16_SINT;
   case MESA_FORMAT_ALPHA_INT32:
      return PIPE_FORMAT_A32_SINT;

   case MESA_FORMAT_INTENSITY_UINT8:
      return PIPE_FORMAT_I8_UINT;
   case MESA_FORMAT_INTENSITY_UINT16:
      return PIPE_FORMAT_I16_UINT;
   case MESA_FORMAT_INTENSITY_UINT32:
      return PIPE_FORMAT_I32_UINT;

   case MESA_FORMAT_INTENSITY_INT8:
      return PIPE_FORMAT_I8_SINT;
   case MESA_FORMAT_INTENSITY_INT16:
      return PIPE_FORMAT_I16_SINT;
   case MESA_FORMAT_INTENSITY_INT32:
      return PIPE_FORMAT_I32_SINT;

   case MESA_FORMAT_LUMINANCE_UINT8:
      return PIPE_FORMAT_L8_UINT;
   case MESA_FORMAT_LUMINANCE_UINT16:
      return PIPE_FORMAT_L16_UINT;
   case MESA_FORMAT_LUMINANCE_UINT32:
      return PIPE_FORMAT_L32_UINT;

   case MESA_FORMAT_LUMINANCE_INT8:
      return PIPE_FORMAT_L8_SINT;
   case MESA_FORMAT_LUMINANCE_INT16:
      return PIPE_FORMAT_L16_SINT;
   case MESA_FORMAT_LUMINANCE_INT32:
      return PIPE_FORMAT_L32_SINT;

   case MESA_FORMAT_LUMINANCE_ALPHA_UINT8:
      return PIPE_FORMAT_L8A8_UINT;
   case MESA_FORMAT_LUMINANCE_ALPHA_UINT16:
      return PIPE_FORMAT_L16A16_UINT;
   case MESA_FORMAT_LUMINANCE_ALPHA_UINT32:
      return PIPE_FORMAT_L32A32_UINT;

   case MESA_FORMAT_LUMINANCE_ALPHA_INT8:
      return PIPE_FORMAT_L8A8_SINT;
   case MESA_FORMAT_LUMINANCE_ALPHA_INT16:
      return PIPE_FORMAT_L16A16_SINT;
   case MESA_FORMAT_LUMINANCE_ALPHA_INT32:
      return PIPE_FORMAT_L32A32_SINT;

   case MESA_FORMAT_R_INT8:
      return PIPE_FORMAT_R8_SINT;
   case MESA_FORMAT_RG_INT8:
      return PIPE_FORMAT_R8G8_SINT;
   case MESA_FORMAT_RGB_INT8:
      return PIPE_FORMAT_R8G8B8_SINT;
d228 1
a228 7
      return PIPE_FORMAT_R8G8B8A8_SINT;
   case MESA_FORMAT_R_INT16:
      return PIPE_FORMAT_R16_SINT;
   case MESA_FORMAT_RG_INT16:
      return PIPE_FORMAT_R16G16_SINT;
   case MESA_FORMAT_RGB_INT16:
      return PIPE_FORMAT_R16G16B16_SINT;
d230 1
a230 7
      return PIPE_FORMAT_R16G16B16A16_SINT;
   case MESA_FORMAT_R_INT32:
      return PIPE_FORMAT_R32_SINT;
   case MESA_FORMAT_RG_INT32:
      return PIPE_FORMAT_R32G32_SINT;
   case MESA_FORMAT_RGB_INT32:
      return PIPE_FORMAT_R32G32B32_SINT;
d232 1
a232 1
      return PIPE_FORMAT_R32G32B32A32_SINT;
a234 6
   case MESA_FORMAT_R_UINT8:
      return PIPE_FORMAT_R8_UINT;
   case MESA_FORMAT_RG_UINT8:
      return PIPE_FORMAT_R8G8_UINT;
   case MESA_FORMAT_RGB_UINT8:
      return PIPE_FORMAT_R8G8B8_UINT;
d236 1
a236 7
      return PIPE_FORMAT_R8G8B8A8_UINT;
   case MESA_FORMAT_R_UINT16:
      return PIPE_FORMAT_R16_UINT;
   case MESA_FORMAT_RG_UINT16:
      return PIPE_FORMAT_R16G16_UINT;
   case MESA_FORMAT_RGB_UINT16:
      return PIPE_FORMAT_R16G16B16_UINT;
d238 1
a238 7
      return PIPE_FORMAT_R16G16B16A16_UINT;
   case MESA_FORMAT_R_UINT32:
      return PIPE_FORMAT_R32_UINT;
   case MESA_FORMAT_RG_UINT32:
      return PIPE_FORMAT_R32G32_UINT;
   case MESA_FORMAT_RGB_UINT32:
      return PIPE_FORMAT_R32G32B32_UINT;
d240 1
a240 93
      return PIPE_FORMAT_R32G32B32A32_UINT;

   case MESA_FORMAT_RED_RGTC1:
      return PIPE_FORMAT_RGTC1_UNORM;
   case MESA_FORMAT_SIGNED_RED_RGTC1:
      return PIPE_FORMAT_RGTC1_SNORM;
   case MESA_FORMAT_RG_RGTC2:
      return PIPE_FORMAT_RGTC2_UNORM;
   case MESA_FORMAT_SIGNED_RG_RGTC2:
      return PIPE_FORMAT_RGTC2_SNORM;

   case MESA_FORMAT_L_LATC1:
      return PIPE_FORMAT_LATC1_UNORM;
   case MESA_FORMAT_SIGNED_L_LATC1:
      return PIPE_FORMAT_LATC1_SNORM;
   case MESA_FORMAT_LA_LATC2:
      return PIPE_FORMAT_LATC2_UNORM;
   case MESA_FORMAT_SIGNED_LA_LATC2:
      return PIPE_FORMAT_LATC2_SNORM;

   case MESA_FORMAT_ETC1_RGB8:
      return PIPE_FORMAT_ETC1_RGB8;

   /* signed normalized formats */
   case MESA_FORMAT_SIGNED_R8:
      return PIPE_FORMAT_R8_SNORM;
   case MESA_FORMAT_SIGNED_RG88_REV:
      return PIPE_FORMAT_R8G8_SNORM;
   case MESA_FORMAT_SIGNED_RGBA8888_REV:
      return PIPE_FORMAT_R8G8B8A8_SNORM;

   case MESA_FORMAT_SIGNED_A8:
      return PIPE_FORMAT_A8_SNORM;
   case MESA_FORMAT_SIGNED_L8:
      return PIPE_FORMAT_L8_SNORM;
   case MESA_FORMAT_SIGNED_AL88:
      return PIPE_FORMAT_L8A8_SNORM;
   case MESA_FORMAT_SIGNED_I8:
      return PIPE_FORMAT_I8_SNORM;

   case MESA_FORMAT_SIGNED_R16:
      return PIPE_FORMAT_R16_SNORM;
   case MESA_FORMAT_SIGNED_GR1616:
      return PIPE_FORMAT_R16G16_SNORM;
   case MESA_FORMAT_SIGNED_RGBA_16:
      return PIPE_FORMAT_R16G16B16A16_SNORM;

   case MESA_FORMAT_SIGNED_A16:
      return PIPE_FORMAT_A16_SNORM;
   case MESA_FORMAT_SIGNED_L16:
      return PIPE_FORMAT_L16_SNORM;
   case MESA_FORMAT_SIGNED_AL1616:
      return PIPE_FORMAT_L16A16_SNORM;
   case MESA_FORMAT_SIGNED_I16:
      return PIPE_FORMAT_I16_SNORM;

   case MESA_FORMAT_RGB9_E5_FLOAT:
      return PIPE_FORMAT_R9G9B9E5_FLOAT;
   case MESA_FORMAT_R11_G11_B10_FLOAT:
      return PIPE_FORMAT_R11G11B10_FLOAT;
   case MESA_FORMAT_ARGB2101010_UINT:
      return PIPE_FORMAT_B10G10R10A2_UINT;

   case MESA_FORMAT_XRGB4444_UNORM:
      return PIPE_FORMAT_B4G4R4X4_UNORM;
   case MESA_FORMAT_XRGB1555_UNORM:
      return PIPE_FORMAT_B5G5R5X1_UNORM;
   case MESA_FORMAT_XBGR8888_SNORM:
      return PIPE_FORMAT_R8G8B8X8_SNORM;
   case MESA_FORMAT_XBGR8888_SRGB:
      return PIPE_FORMAT_R8G8B8X8_SRGB;
   case MESA_FORMAT_XBGR8888_UINT:
      return PIPE_FORMAT_R8G8B8X8_UINT;
   case MESA_FORMAT_XBGR8888_SINT:
      return PIPE_FORMAT_R8G8B8X8_SINT;
   case MESA_FORMAT_XRGB2101010_UNORM:
      return PIPE_FORMAT_B10G10R10X2_UNORM;
   case MESA_FORMAT_XBGR16161616_UNORM:
      return PIPE_FORMAT_R16G16B16X16_UNORM;
   case MESA_FORMAT_XBGR16161616_SNORM:
      return PIPE_FORMAT_R16G16B16X16_SNORM;
   case MESA_FORMAT_XBGR16161616_FLOAT:
      return PIPE_FORMAT_R16G16B16X16_FLOAT;
   case MESA_FORMAT_XBGR16161616_UINT:
      return PIPE_FORMAT_R16G16B16X16_UINT;
   case MESA_FORMAT_XBGR16161616_SINT:
      return PIPE_FORMAT_R16G16B16X16_SINT;
   case MESA_FORMAT_XBGR32323232_FLOAT:
      return PIPE_FORMAT_R32G32B32X32_FLOAT;
   case MESA_FORMAT_XBGR32323232_UINT:
      return PIPE_FORMAT_R32G32B32X32_UINT;
   case MESA_FORMAT_XBGR32323232_SINT:
      return PIPE_FORMAT_R32G32B32X32_SINT;
d243 1
d256 1
a256 1
   case PIPE_FORMAT_ABGR8888_UNORM:
d258 1
a258 1
   case PIPE_FORMAT_RGBA8888_UNORM:
d260 1
a260 1
   case PIPE_FORMAT_BGRA8888_UNORM:
d262 1
a262 1
   case PIPE_FORMAT_ARGB8888_UNORM:
d264 1
a264 5
   case PIPE_FORMAT_XBGR8888_UNORM:
      return MESA_FORMAT_RGBX8888;
   case PIPE_FORMAT_RGBX8888_UNORM:
      return MESA_FORMAT_RGBX8888_REV;
   case PIPE_FORMAT_BGRX8888_UNORM:
d266 1
a266 1
   case PIPE_FORMAT_XRGB8888_UNORM:
a273 6
   case PIPE_FORMAT_B2G3R3_UNORM:
      return MESA_FORMAT_RGB332;
   case PIPE_FORMAT_B10G10R10A2_UNORM:
      return MESA_FORMAT_ARGB2101010;
   case PIPE_FORMAT_L4A4_UNORM:
      return MESA_FORMAT_AL44;
a275 2
   case PIPE_FORMAT_L16A16_UNORM:
      return MESA_FORMAT_AL1616;
a277 2
   case PIPE_FORMAT_A16_UNORM:
      return MESA_FORMAT_A16;
a279 2
   case PIPE_FORMAT_L16_UNORM:
      return MESA_FORMAT_L16;
d282 1
a282 3
   case PIPE_FORMAT_I16_UNORM:
      return MESA_FORMAT_I16;
   case PIPE_FORMAT_S8_UINT:
d287 2
d294 1
a294 1
   case PIPE_FORMAT_S8_UINT_Z24_UNORM:
d300 1
a300 1
   case PIPE_FORMAT_Z24_UNORM_S8_UINT:
a301 4
   case PIPE_FORMAT_Z32_FLOAT:
      return MESA_FORMAT_Z32_FLOAT;
   case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
      return MESA_FORMAT_Z32_FLOAT_X24S8;
d308 1
d317 1
d326 4
d340 1
a340 32
   case PIPE_FORMAT_R32G32B32A32_FLOAT:
      return MESA_FORMAT_RGBA_FLOAT32;
   case PIPE_FORMAT_R16G16B16A16_FLOAT:
      return MESA_FORMAT_RGBA_FLOAT16;
   case PIPE_FORMAT_R32G32B32_FLOAT:
      return MESA_FORMAT_RGB_FLOAT32;
   case PIPE_FORMAT_R16G16B16_FLOAT:
      return MESA_FORMAT_RGB_FLOAT16;
   case PIPE_FORMAT_L32A32_FLOAT:
      return MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32;
   case PIPE_FORMAT_L16A16_FLOAT:
      return MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16;
   case PIPE_FORMAT_L32_FLOAT:
      return MESA_FORMAT_LUMINANCE_FLOAT32;
   case PIPE_FORMAT_L16_FLOAT:
      return MESA_FORMAT_LUMINANCE_FLOAT16;
   case PIPE_FORMAT_A32_FLOAT:
      return MESA_FORMAT_ALPHA_FLOAT32;
   case PIPE_FORMAT_A16_FLOAT:
      return MESA_FORMAT_ALPHA_FLOAT16;
   case PIPE_FORMAT_I32_FLOAT:
      return MESA_FORMAT_INTENSITY_FLOAT32;
   case PIPE_FORMAT_I16_FLOAT:
      return MESA_FORMAT_INTENSITY_FLOAT16;
   case PIPE_FORMAT_R32_FLOAT:
      return MESA_FORMAT_R_FLOAT32;
   case PIPE_FORMAT_R16_FLOAT:
      return MESA_FORMAT_R_FLOAT16;
   case PIPE_FORMAT_R32G32_FLOAT:
      return MESA_FORMAT_RG_FLOAT32;
   case PIPE_FORMAT_R16G16_FLOAT:
      return MESA_FORMAT_RG_FLOAT16;
d347 1
a347 1
      return MESA_FORMAT_GR88;
d349 1
a349 1
      return MESA_FORMAT_GR1616;
d351 2
a352 59
   case PIPE_FORMAT_A8_UINT:
      return MESA_FORMAT_ALPHA_UINT8;
   case PIPE_FORMAT_A16_UINT:
      return MESA_FORMAT_ALPHA_UINT16;
   case PIPE_FORMAT_A32_UINT:
      return MESA_FORMAT_ALPHA_UINT32;
   case PIPE_FORMAT_A8_SINT:
      return MESA_FORMAT_ALPHA_INT8;
   case PIPE_FORMAT_A16_SINT:
      return MESA_FORMAT_ALPHA_INT16;
   case PIPE_FORMAT_A32_SINT:
      return MESA_FORMAT_ALPHA_INT32;

   case PIPE_FORMAT_I8_UINT:
      return MESA_FORMAT_INTENSITY_UINT8;
   case PIPE_FORMAT_I16_UINT:
      return MESA_FORMAT_INTENSITY_UINT16;
   case PIPE_FORMAT_I32_UINT:
      return MESA_FORMAT_INTENSITY_UINT32;
   case PIPE_FORMAT_I8_SINT:
      return MESA_FORMAT_INTENSITY_INT8;
   case PIPE_FORMAT_I16_SINT:
      return MESA_FORMAT_INTENSITY_INT16;
   case PIPE_FORMAT_I32_SINT:
      return MESA_FORMAT_INTENSITY_INT32;

  case PIPE_FORMAT_L8_UINT:
      return MESA_FORMAT_LUMINANCE_UINT8;
   case PIPE_FORMAT_L16_UINT:
      return MESA_FORMAT_LUMINANCE_UINT16;
   case PIPE_FORMAT_L32_UINT:
      return MESA_FORMAT_LUMINANCE_UINT32;
   case PIPE_FORMAT_L8_SINT:
      return MESA_FORMAT_LUMINANCE_INT8;
   case PIPE_FORMAT_L16_SINT:
      return MESA_FORMAT_LUMINANCE_INT16;
   case PIPE_FORMAT_L32_SINT:
      return MESA_FORMAT_LUMINANCE_INT32;

   case PIPE_FORMAT_L8A8_UINT:
      return MESA_FORMAT_LUMINANCE_ALPHA_UINT8;
   case PIPE_FORMAT_L16A16_UINT:
      return MESA_FORMAT_LUMINANCE_ALPHA_UINT16;
   case PIPE_FORMAT_L32A32_UINT:
      return MESA_FORMAT_LUMINANCE_ALPHA_UINT32;
   case PIPE_FORMAT_L8A8_SINT:
      return MESA_FORMAT_LUMINANCE_ALPHA_INT8;
   case PIPE_FORMAT_L16A16_SINT:
      return MESA_FORMAT_LUMINANCE_ALPHA_INT16;
   case PIPE_FORMAT_L32A32_SINT:
      return MESA_FORMAT_LUMINANCE_ALPHA_INT32;

   case PIPE_FORMAT_R8_SINT:
      return MESA_FORMAT_R_INT8;
   case PIPE_FORMAT_R8G8_SINT:
      return MESA_FORMAT_RG_INT8;
   case PIPE_FORMAT_R8G8B8_SINT:
      return MESA_FORMAT_RGB_INT8;
   case PIPE_FORMAT_R8G8B8A8_SINT:
d354 1
a354 8

   case PIPE_FORMAT_R16_SINT:
      return MESA_FORMAT_R_INT16;
   case PIPE_FORMAT_R16G16_SINT:
      return MESA_FORMAT_RG_INT16;
   case PIPE_FORMAT_R16G16B16_SINT:
      return MESA_FORMAT_RGB_INT16;
   case PIPE_FORMAT_R16G16B16A16_SINT:
d356 1
a356 8

   case PIPE_FORMAT_R32_SINT:
      return MESA_FORMAT_R_INT32;
   case PIPE_FORMAT_R32G32_SINT:
      return MESA_FORMAT_RG_INT32;
   case PIPE_FORMAT_R32G32B32_SINT:
      return MESA_FORMAT_RGB_INT32;
   case PIPE_FORMAT_R32G32B32A32_SINT:
d360 1
a360 7
   case PIPE_FORMAT_R8_UINT:
      return MESA_FORMAT_R_UINT8;
   case PIPE_FORMAT_R8G8_UINT:
      return MESA_FORMAT_RG_UINT8;
   case PIPE_FORMAT_R8G8B8_UINT:
      return MESA_FORMAT_RGB_UINT8;
   case PIPE_FORMAT_R8G8B8A8_UINT:
d362 1
a362 8

   case PIPE_FORMAT_R16_UINT:
      return MESA_FORMAT_R_UINT16;
   case PIPE_FORMAT_R16G16_UINT:
      return MESA_FORMAT_RG_UINT16;
   case PIPE_FORMAT_R16G16B16_UINT:
      return MESA_FORMAT_RGB_UINT16;
   case PIPE_FORMAT_R16G16B16A16_UINT:
d364 1
a364 8

   case PIPE_FORMAT_R32_UINT:
      return MESA_FORMAT_R_UINT32;
   case PIPE_FORMAT_R32G32_UINT:
      return MESA_FORMAT_RG_UINT32;
   case PIPE_FORMAT_R32G32B32_UINT:
      return MESA_FORMAT_RGB_UINT32;
   case PIPE_FORMAT_R32G32B32A32_UINT:
a366 93
   case PIPE_FORMAT_RGTC1_UNORM:
      return MESA_FORMAT_RED_RGTC1;
   case PIPE_FORMAT_RGTC1_SNORM:
      return MESA_FORMAT_SIGNED_RED_RGTC1;
   case PIPE_FORMAT_RGTC2_UNORM:
      return MESA_FORMAT_RG_RGTC2;
   case PIPE_FORMAT_RGTC2_SNORM:
      return MESA_FORMAT_SIGNED_RG_RGTC2;

   case PIPE_FORMAT_LATC1_UNORM:
      return MESA_FORMAT_L_LATC1;
   case PIPE_FORMAT_LATC1_SNORM:
      return MESA_FORMAT_SIGNED_L_LATC1;
   case PIPE_FORMAT_LATC2_UNORM:
      return MESA_FORMAT_LA_LATC2;
   case PIPE_FORMAT_LATC2_SNORM:
      return MESA_FORMAT_SIGNED_LA_LATC2;

   case PIPE_FORMAT_ETC1_RGB8:
      return MESA_FORMAT_ETC1_RGB8;

   /* signed normalized formats */
   case PIPE_FORMAT_R8_SNORM:
      return MESA_FORMAT_SIGNED_R8;
   case PIPE_FORMAT_R8G8_SNORM:
      return MESA_FORMAT_SIGNED_RG88_REV;
   case PIPE_FORMAT_R8G8B8A8_SNORM:
      return MESA_FORMAT_SIGNED_RGBA8888_REV;

   case PIPE_FORMAT_A8_SNORM:
      return MESA_FORMAT_SIGNED_A8;
   case PIPE_FORMAT_L8_SNORM:
      return MESA_FORMAT_SIGNED_L8;
   case PIPE_FORMAT_L8A8_SNORM:
      return MESA_FORMAT_SIGNED_AL88;
   case PIPE_FORMAT_I8_SNORM:
      return MESA_FORMAT_SIGNED_I8;

   case PIPE_FORMAT_R16_SNORM:
      return MESA_FORMAT_SIGNED_R16;
   case PIPE_FORMAT_R16G16_SNORM:
      return MESA_FORMAT_SIGNED_GR1616;
   case PIPE_FORMAT_R16G16B16A16_SNORM:
      return MESA_FORMAT_SIGNED_RGBA_16;

   case PIPE_FORMAT_A16_SNORM:
      return MESA_FORMAT_SIGNED_A16;
   case PIPE_FORMAT_L16_SNORM:
      return MESA_FORMAT_SIGNED_L16;
   case PIPE_FORMAT_L16A16_SNORM:
      return MESA_FORMAT_SIGNED_AL1616;
   case PIPE_FORMAT_I16_SNORM:
      return MESA_FORMAT_SIGNED_I16;

   case PIPE_FORMAT_R9G9B9E5_FLOAT:
      return MESA_FORMAT_RGB9_E5_FLOAT;
   case PIPE_FORMAT_R11G11B10_FLOAT:
      return MESA_FORMAT_R11_G11_B10_FLOAT;

   case PIPE_FORMAT_B10G10R10A2_UINT:
      return MESA_FORMAT_ARGB2101010_UINT;

   case PIPE_FORMAT_B4G4R4X4_UNORM:
      return MESA_FORMAT_XRGB4444_UNORM;
   case PIPE_FORMAT_B5G5R5X1_UNORM:
      return MESA_FORMAT_XRGB1555_UNORM;
   case PIPE_FORMAT_R8G8B8X8_SNORM:
      return MESA_FORMAT_XBGR8888_SNORM;
   case PIPE_FORMAT_R8G8B8X8_SRGB:
      return MESA_FORMAT_XBGR8888_SRGB;
   case PIPE_FORMAT_R8G8B8X8_UINT:
      return MESA_FORMAT_XBGR8888_UINT;
   case PIPE_FORMAT_R8G8B8X8_SINT:
      return MESA_FORMAT_XBGR8888_SINT;
   case PIPE_FORMAT_B10G10R10X2_UNORM:
      return MESA_FORMAT_XRGB2101010_UNORM;
   case PIPE_FORMAT_R16G16B16X16_UNORM:
      return MESA_FORMAT_XBGR16161616_UNORM;
   case PIPE_FORMAT_R16G16B16X16_SNORM:
      return MESA_FORMAT_XBGR16161616_SNORM;
   case PIPE_FORMAT_R16G16B16X16_FLOAT:
      return MESA_FORMAT_XBGR16161616_FLOAT;
   case PIPE_FORMAT_R16G16B16X16_UINT:
      return MESA_FORMAT_XBGR16161616_UINT;
   case PIPE_FORMAT_R16G16B16X16_SINT:
      return MESA_FORMAT_XBGR16161616_SINT;
   case PIPE_FORMAT_R32G32B32X32_FLOAT:
      return MESA_FORMAT_XBGR32323232_FLOAT;
   case PIPE_FORMAT_R32G32B32X32_UINT:
      return MESA_FORMAT_XBGR32323232_UINT;
   case PIPE_FORMAT_R32G32B32X32_SINT:
      return MESA_FORMAT_XBGR32323232_SINT;

a374 737
 * Map GL texture formats to Gallium pipe formats.
 */
struct format_mapping
{
   GLenum glFormats[18];       /**< list of GLenum formats, 0-terminated */
   enum pipe_format pipeFormats[13]; /**< list of pipe formats, 0-terminated */
};


#define DEFAULT_RGBA_FORMATS \
      PIPE_FORMAT_B8G8R8A8_UNORM, \
      PIPE_FORMAT_R8G8B8A8_UNORM, \
      PIPE_FORMAT_A8R8G8B8_UNORM, \
      PIPE_FORMAT_A8B8G8R8_UNORM, \
      0

#define DEFAULT_RGB_FORMATS \
      PIPE_FORMAT_B8G8R8X8_UNORM, \
      PIPE_FORMAT_R8G8B8X8_UNORM, \
      PIPE_FORMAT_X8R8G8B8_UNORM, \
      PIPE_FORMAT_X8B8G8R8_UNORM, \
      PIPE_FORMAT_B5G6R5_UNORM, \
      DEFAULT_RGBA_FORMATS

#define DEFAULT_SRGBA_FORMATS \
      PIPE_FORMAT_B8G8R8A8_SRGB, \
      PIPE_FORMAT_A8R8G8B8_SRGB, \
      PIPE_FORMAT_A8B8G8R8_SRGB, \
      0

#define DEFAULT_DEPTH_FORMATS \
      PIPE_FORMAT_Z24X8_UNORM, \
      PIPE_FORMAT_X8Z24_UNORM, \
      PIPE_FORMAT_Z16_UNORM, \
      PIPE_FORMAT_Z24_UNORM_S8_UINT, \
      PIPE_FORMAT_S8_UINT_Z24_UNORM, \
      0

#define DEFAULT_SNORM8_RGBA_FORMATS \
      PIPE_FORMAT_R8G8B8A8_SNORM, \
      0

#define DEFAULT_UNORM16_RGBA_FORMATS \
      PIPE_FORMAT_R16G16B16A16_UNORM, \
      DEFAULT_RGBA_FORMATS


/**
 * This table maps OpenGL texture format enums to Gallium pipe_format enums.
 * Multiple GL enums might map to multiple pipe_formats.
 * The first pipe format in the list that's supported is the one that's chosen.
 */
static const struct format_mapping format_map[] = {
   /* Basic RGB, RGBA formats */
   {
      { GL_RGB10, 0 },
      { PIPE_FORMAT_B10G10R10X2_UNORM, PIPE_FORMAT_B10G10R10A2_UNORM,
        DEFAULT_RGB_FORMATS }
   },
   {
      { GL_RGB10_A2, 0 },
      { PIPE_FORMAT_B10G10R10A2_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { 4, GL_RGBA, GL_RGBA8, 0 },
      { PIPE_FORMAT_R8G8B8A8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_BGRA, 0 },
      { PIPE_FORMAT_B8G8R8A8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { 3, GL_RGB, GL_RGB8, 0 },
      { DEFAULT_RGB_FORMATS }
   },
   {
      { GL_RGB12, GL_RGB16, 0 },
      { PIPE_FORMAT_R16G16B16X16_UNORM, PIPE_FORMAT_R16G16B16A16_UNORM,
        DEFAULT_RGB_FORMATS }
   },
   {
      { GL_RGBA12, GL_RGBA16, 0 },
      { PIPE_FORMAT_R16G16B16A16_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_RGBA4, GL_RGBA2, 0 },
      { PIPE_FORMAT_B4G4R4A4_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_RGB5_A1, 0 },
      { PIPE_FORMAT_B5G5R5A1_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_R3_G3_B2, 0 },
      { PIPE_FORMAT_B2G3R3_UNORM, PIPE_FORMAT_B5G6R5_UNORM,
        PIPE_FORMAT_B5G5R5A1_UNORM, DEFAULT_RGB_FORMATS }
   },
   {
      { GL_RGB4 },
      { PIPE_FORMAT_B4G4R4X4_UNORM, PIPE_FORMAT_B4G4R4A4_UNORM,
        DEFAULT_RGB_FORMATS }
   },
   {
      { GL_RGB5 },
      { PIPE_FORMAT_B5G5R5X1_UNORM, PIPE_FORMAT_B5G5R5A1_UNORM,
        DEFAULT_RGB_FORMATS }
   },
   {
      { GL_RGB565 },
      { PIPE_FORMAT_B5G6R5_UNORM, DEFAULT_RGB_FORMATS }
   },

   /* basic Alpha formats */
   {
      { GL_ALPHA12, GL_ALPHA16, 0 },
      { PIPE_FORMAT_A16_UNORM, PIPE_FORMAT_A8_UNORM,
        DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_COMPRESSED_ALPHA, 0 },
      { PIPE_FORMAT_A8_UNORM, DEFAULT_RGBA_FORMATS }
   },

   /* basic Luminance formats */
   {
      { GL_LUMINANCE12, GL_LUMINANCE16, 0 },
      { PIPE_FORMAT_L16_UNORM, PIPE_FORMAT_L8_UNORM, DEFAULT_RGB_FORMATS }
   },
   {
      { 1, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, 0 },
      { PIPE_FORMAT_L8_UNORM, DEFAULT_RGB_FORMATS }
   },

   /* basic Luminance/Alpha formats */
   {
      { GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12,
        GL_LUMINANCE16_ALPHA16, 0},
      { PIPE_FORMAT_L16A16_UNORM, PIPE_FORMAT_L8A8_UNORM,
        DEFAULT_RGBA_FORMATS }
   },
   {
      { 2, GL_LUMINANCE_ALPHA, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, 0 },
      { PIPE_FORMAT_L8A8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_LUMINANCE4_ALPHA4, 0 },
      { PIPE_FORMAT_L4A4_UNORM, PIPE_FORMAT_L8A8_UNORM,
        DEFAULT_RGBA_FORMATS }
   },

   /* basic Intensity formats */
   {
      { GL_INTENSITY12, GL_INTENSITY16, 0 },
      { PIPE_FORMAT_I16_UNORM, PIPE_FORMAT_I8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8,
        GL_COMPRESSED_INTENSITY, 0 },
      { PIPE_FORMAT_I8_UNORM, DEFAULT_RGBA_FORMATS }
   },

   /* YCbCr */
   {
      { GL_YCBCR_MESA, 0 },
      { PIPE_FORMAT_UYVY, PIPE_FORMAT_YUYV, 0 }
   },

   /* compressed formats */ /* XXX PIPE_BIND_SAMPLER_VIEW only */
   {
      { GL_COMPRESSED_RGB, 0 },
      { PIPE_FORMAT_DXT1_RGB, DEFAULT_RGB_FORMATS }
   },
   {
      { GL_COMPRESSED_RGBA, 0 },
      { PIPE_FORMAT_DXT5_RGBA, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_RGB_S3TC, GL_RGB4_S3TC, GL_COMPRESSED_RGB_S3TC_DXT1_EXT, 0 },
      { PIPE_FORMAT_DXT1_RGB, 0 }
   },
   {
      { GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, 0 },
      { PIPE_FORMAT_DXT1_RGBA, 0 }
   },
   {
      { GL_RGBA_S3TC, GL_RGBA4_S3TC, GL_COMPRESSED_RGBA_S3TC_DXT3_EXT, 0 },
      { PIPE_FORMAT_DXT3_RGBA, 0 }
   },
   {
      { GL_COMPRESSED_RGBA_S3TC_DXT5_EXT, 0 },
      { PIPE_FORMAT_DXT5_RGBA, 0 }
   },

#if 0
   {
      { GL_COMPRESSED_RGB_FXT1_3DFX, 0 },
      { PIPE_FORMAT_RGB_FXT1, 0 }
   },
   {
      { GL_COMPRESSED_RGBA_FXT1_3DFX, 0 },
      { PIPE_FORMAT_RGBA_FXT1, 0 }
   },
#endif

   /* Depth formats */
   {
      { GL_DEPTH_COMPONENT16, 0 },
      { PIPE_FORMAT_Z16_UNORM, DEFAULT_DEPTH_FORMATS }
   },
   {
      { GL_DEPTH_COMPONENT24, 0 },
      { PIPE_FORMAT_Z24X8_UNORM, PIPE_FORMAT_X8Z24_UNORM,
        DEFAULT_DEPTH_FORMATS }
   },
   {
      { GL_DEPTH_COMPONENT32, 0 },
      { PIPE_FORMAT_Z32_UNORM, DEFAULT_DEPTH_FORMATS }
   },
   {
      { GL_DEPTH_COMPONENT, 0 },
      { DEFAULT_DEPTH_FORMATS }
   },
   {
      { GL_DEPTH_COMPONENT32F, 0 },
      { PIPE_FORMAT_Z32_FLOAT, 0 }
   },

   /* stencil formats */
   {
      { GL_STENCIL_INDEX, GL_STENCIL_INDEX1_EXT, GL_STENCIL_INDEX4_EXT,
        GL_STENCIL_INDEX8_EXT, GL_STENCIL_INDEX16_EXT, 0 },
      {
         PIPE_FORMAT_S8_UINT, PIPE_FORMAT_Z24_UNORM_S8_UINT,
         PIPE_FORMAT_S8_UINT_Z24_UNORM, 0
      }
   },

   /* Depth / Stencil formats */
   {
      { GL_DEPTH_STENCIL_EXT, GL_DEPTH24_STENCIL8_EXT, 0 },
      { PIPE_FORMAT_Z24_UNORM_S8_UINT, PIPE_FORMAT_S8_UINT_Z24_UNORM, 0 }
   },
   {
      { GL_DEPTH32F_STENCIL8, 0 },
      { PIPE_FORMAT_Z32_FLOAT_S8X24_UINT, 0 }
   },

   /* sRGB formats */
   {
      { GL_SRGB_EXT, GL_SRGB8_EXT, 0 },
      { PIPE_FORMAT_R8G8B8X8_SRGB, DEFAULT_SRGBA_FORMATS }
   },
   {
      { GL_SRGB_ALPHA_EXT, GL_SRGB8_ALPHA8_EXT, 0 },
      { DEFAULT_SRGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_SRGB_EXT, GL_COMPRESSED_SRGB_S3TC_DXT1_EXT, 0 },
      { PIPE_FORMAT_DXT1_SRGB, PIPE_FORMAT_R8G8B8X8_SRGB,
        DEFAULT_SRGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, 0 },
      { PIPE_FORMAT_DXT1_SRGBA, 0 }
   },
   {
      { GL_COMPRESSED_SRGB_ALPHA_EXT,
        GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, 0 },
      { PIPE_FORMAT_DXT3_SRGBA, DEFAULT_SRGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, 0 },
      { PIPE_FORMAT_DXT5_SRGBA, 0 }
   },
   {
      { GL_SLUMINANCE_ALPHA_EXT, GL_SLUMINANCE8_ALPHA8_EXT,
        GL_COMPRESSED_SLUMINANCE_ALPHA_EXT, 0 },
      { PIPE_FORMAT_L8A8_SRGB, DEFAULT_SRGBA_FORMATS }
   },
   {
      { GL_SLUMINANCE_EXT, GL_SLUMINANCE8_EXT, GL_COMPRESSED_SLUMINANCE_EXT,
        0 },
      { PIPE_FORMAT_L8_SRGB, DEFAULT_SRGBA_FORMATS }
   },

   /* 16-bit float formats */
   {
      { GL_RGBA16F_ARB, 0 },
      { PIPE_FORMAT_R16G16B16A16_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },
   {
      { GL_RGB16F_ARB, 0 },
      { PIPE_FORMAT_R16G16B16_FLOAT, PIPE_FORMAT_R16G16B16X16_FLOAT,
        PIPE_FORMAT_R16G16B16A16_FLOAT,
        PIPE_FORMAT_R32G32B32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA16F_ARB, 0 },
      { PIPE_FORMAT_L16A16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT,
        PIPE_FORMAT_L32A32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },
   {
      { GL_ALPHA16F_ARB, 0 },
      { PIPE_FORMAT_A16_FLOAT, PIPE_FORMAT_L16A16_FLOAT,
        PIPE_FORMAT_A32_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT,
        PIPE_FORMAT_L32A32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },
   {
      { GL_INTENSITY16F_ARB, 0 },
      { PIPE_FORMAT_I16_FLOAT, PIPE_FORMAT_L16A16_FLOAT,
        PIPE_FORMAT_I32_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT,
        PIPE_FORMAT_L32A32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },
   {
      { GL_LUMINANCE16F_ARB, 0 },
      { PIPE_FORMAT_L16_FLOAT, PIPE_FORMAT_L16A16_FLOAT,
        PIPE_FORMAT_L32_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT,
        PIPE_FORMAT_L32A32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },
   {
      { GL_R16F, 0 },
      { PIPE_FORMAT_R16_FLOAT, PIPE_FORMAT_R16G16_FLOAT,
        PIPE_FORMAT_R32_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT,
        PIPE_FORMAT_R32G32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },
   {
      { GL_RG16F, 0 },
      { PIPE_FORMAT_R16G16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT,
        PIPE_FORMAT_R32G32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT, 0 }
   },

   /* 32-bit float formats */
   {
      { GL_RGBA32F_ARB, 0 },
      { PIPE_FORMAT_R32G32B32A32_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },
   {
      { GL_RGB32F_ARB, 0 },
      { PIPE_FORMAT_R32G32B32_FLOAT, PIPE_FORMAT_R32G32B32X32_FLOAT,
        PIPE_FORMAT_R32G32B32A32_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA32F_ARB, 0 },
      { PIPE_FORMAT_L32A32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT,
        PIPE_FORMAT_L16A16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },
   {
      { GL_ALPHA32F_ARB, 0 },
      { PIPE_FORMAT_A32_FLOAT, PIPE_FORMAT_L32A32_FLOAT,
        PIPE_FORMAT_R32G32B32A32_FLOAT, PIPE_FORMAT_A16_FLOAT,
        PIPE_FORMAT_L16A16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },
   {
      { GL_INTENSITY32F_ARB, 0 },
      { PIPE_FORMAT_I32_FLOAT, PIPE_FORMAT_L32A32_FLOAT,
        PIPE_FORMAT_R32G32B32A32_FLOAT, PIPE_FORMAT_I16_FLOAT,
        PIPE_FORMAT_L16A16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },
   {
      { GL_LUMINANCE32F_ARB, 0 },
      { PIPE_FORMAT_L32_FLOAT, PIPE_FORMAT_L32A32_FLOAT,
        PIPE_FORMAT_R32G32B32A32_FLOAT, PIPE_FORMAT_L16_FLOAT,
        PIPE_FORMAT_L16A16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },
   {
      { GL_R32F, 0 },
      { PIPE_FORMAT_R32_FLOAT, PIPE_FORMAT_R32G32_FLOAT,
        PIPE_FORMAT_R32G32B32A32_FLOAT, PIPE_FORMAT_R16_FLOAT,
        PIPE_FORMAT_R16G16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },
   {
      { GL_RG32F, 0 },
      { PIPE_FORMAT_R32G32_FLOAT, PIPE_FORMAT_R32G32B32A32_FLOAT,
        PIPE_FORMAT_R16G16_FLOAT, PIPE_FORMAT_R16G16B16A16_FLOAT, 0 }
   },

   /* R, RG formats */
   {
      { GL_RED, GL_R8, 0 },
      { PIPE_FORMAT_R8_UNORM, PIPE_FORMAT_R8G8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_RG, GL_RG8, 0 },
      { PIPE_FORMAT_R8G8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_R16, 0 },
      { PIPE_FORMAT_R16_UNORM, PIPE_FORMAT_R16G16_UNORM,
        DEFAULT_UNORM16_RGBA_FORMATS }
   },
   {
      { GL_RG16, 0 },
      { PIPE_FORMAT_R16G16_UNORM, DEFAULT_UNORM16_RGBA_FORMATS }
   },

   /* compressed R, RG formats */
   {
      { GL_COMPRESSED_RED, GL_COMPRESSED_RED_RGTC1, 0 },
      { PIPE_FORMAT_RGTC1_UNORM, PIPE_FORMAT_R8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_SIGNED_RED_RGTC1, 0 },
      { PIPE_FORMAT_RGTC1_SNORM, DEFAULT_SNORM8_RGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_RG, GL_COMPRESSED_RG_RGTC2, 0 },
      { PIPE_FORMAT_RGTC2_UNORM, PIPE_FORMAT_R8G8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_SIGNED_RG_RGTC2, 0 },
      { PIPE_FORMAT_RGTC2_SNORM, DEFAULT_SNORM8_RGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_LATC1_EXT, 0 },
      { PIPE_FORMAT_LATC1_UNORM, PIPE_FORMAT_L8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT, 0 },
      { PIPE_FORMAT_LATC1_SNORM, DEFAULT_SNORM8_RGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT,
        GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI, 0 },
      { PIPE_FORMAT_LATC2_UNORM, PIPE_FORMAT_L8A8_UNORM, DEFAULT_RGBA_FORMATS }
   },
   {
      { GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT, 0 },
      { PIPE_FORMAT_LATC2_SNORM, DEFAULT_SNORM8_RGBA_FORMATS }
   },

   /* ETC1 */
   {
      { GL_ETC1_RGB8_OES, 0 },
      { PIPE_FORMAT_ETC1_RGB8, 0 }
   },

   /* signed/unsigned integer formats.
    */
   {
      { GL_RGBA_INTEGER_EXT,
        GL_BGRA_INTEGER_EXT,
        GL_RGBA8I_EXT, 0 },
      { PIPE_FORMAT_R8G8B8A8_SINT, 0 }
   },
   {
      { GL_RGB_INTEGER_EXT, 
        GL_BGR_INTEGER_EXT,
        GL_RGB8I_EXT,
        GL_BLUE_INTEGER_EXT, 0 },
      { PIPE_FORMAT_R8G8B8_SINT, PIPE_FORMAT_R8G8B8X8_SINT,
        PIPE_FORMAT_R8G8B8A8_SINT, 0 }
   },
   {
      { GL_ALPHA_INTEGER_EXT,
        GL_ALPHA8I_EXT, 0 },
      { PIPE_FORMAT_A8_SINT, 0 }
   },
   {
      { GL_ALPHA16I_EXT, 0 },
      { PIPE_FORMAT_A16_SINT, 0 }
   },
   {
      { GL_ALPHA32I_EXT, 0 },
      { PIPE_FORMAT_A32_SINT, 0 }
   },
   {
      { GL_ALPHA8UI_EXT, 0 },
      { PIPE_FORMAT_A8_UINT, 0 }
   },
   {
      { GL_ALPHA16UI_EXT, 0 },
      { PIPE_FORMAT_A16_UINT, 0 }
   },
   {
      { GL_ALPHA32UI_EXT, 0 },
      { PIPE_FORMAT_A32_UINT, 0 }
   },
   {
      { GL_INTENSITY8I_EXT, 0 },
      { PIPE_FORMAT_I8_SINT, 0 }
   },
   {
      { GL_INTENSITY16I_EXT, 0 },
      { PIPE_FORMAT_I16_SINT, 0 }
   },
   {
      { GL_INTENSITY32I_EXT, 0 },
      { PIPE_FORMAT_I32_SINT, 0 }
   },
   {
      { GL_INTENSITY8UI_EXT, 0 },
      { PIPE_FORMAT_I8_UINT, 0 }
   },
   {
      { GL_INTENSITY16UI_EXT, 0 },
      { PIPE_FORMAT_I16_UINT, 0 }
   },
   {
      { GL_INTENSITY32UI_EXT, 0 },
      { PIPE_FORMAT_I32_UINT, 0 }
   },
   {
      { GL_LUMINANCE8I_EXT, 0 },
      { PIPE_FORMAT_L8_SINT, 0 }
   },
   {
      { GL_LUMINANCE16I_EXT, 0 },
      { PIPE_FORMAT_L16_SINT, 0 }
   },
   {
      { GL_LUMINANCE32I_EXT, 0 },
      { PIPE_FORMAT_L32_SINT, 0 }
   },
   {
      { GL_LUMINANCE_INTEGER_EXT,
        GL_LUMINANCE8UI_EXT, 0 },
      { PIPE_FORMAT_L8_UINT, 0 }
   },
   {
      { GL_LUMINANCE16UI_EXT, 0 },
      { PIPE_FORMAT_L16_UINT, 0 }
   },
   {
      { GL_LUMINANCE32UI_EXT, 0 },
      { PIPE_FORMAT_L32_UINT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA_INTEGER_EXT,
        GL_LUMINANCE_ALPHA8I_EXT, 0 },
      { PIPE_FORMAT_L8A8_SINT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA16I_EXT, 0 },
      { PIPE_FORMAT_L16A16_SINT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA32I_EXT, 0 },
      { PIPE_FORMAT_L32A32_SINT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA8UI_EXT, 0 },
      { PIPE_FORMAT_L8A8_UINT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA16UI_EXT, 0 },
      { PIPE_FORMAT_L16A16_UINT, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA32UI_EXT, 0 },
      { PIPE_FORMAT_L32A32_UINT, 0 }
   },
   {
      { GL_RGB16I_EXT, 0 },
      { PIPE_FORMAT_R16G16B16_SINT, PIPE_FORMAT_R16G16B16X16_SINT,
        PIPE_FORMAT_R16G16B16A16_SINT, 0 },
   },
   {
      { GL_RGBA16I_EXT, 0 },
      { PIPE_FORMAT_R16G16B16A16_SINT, 0 },
   },
   {
      { GL_RGB32I_EXT, 0 },
      { PIPE_FORMAT_R32G32B32_SINT, PIPE_FORMAT_R32G32B32X32_SINT,
        PIPE_FORMAT_R32G32B32A32_SINT, 0 },
   },
   {
      { GL_RGBA32I_EXT, 0 },
      { PIPE_FORMAT_R32G32B32A32_SINT, 0 }
   },
   {
      { GL_RGBA8UI_EXT, 0 },
      { PIPE_FORMAT_R8G8B8A8_UINT, 0 }
   },
   {
      { GL_RGB8UI_EXT, 0 },
      { PIPE_FORMAT_R8G8B8_UINT, PIPE_FORMAT_R8G8B8X8_UINT,
        PIPE_FORMAT_R8G8B8A8_UINT, 0 }
   },
   {
      { GL_RGB16UI_EXT, 0 },
      { PIPE_FORMAT_R16G16B16_UINT, PIPE_FORMAT_R16G16B16X16_UINT,
        PIPE_FORMAT_R16G16B16A16_UINT, 0 }
   },
   {
      { GL_RGBA16UI_EXT, 0 },
      { PIPE_FORMAT_R16G16B16A16_UINT, 0 }
   },
   {
      { GL_RGB32UI_EXT, 0},
      { PIPE_FORMAT_R32G32B32_UINT, PIPE_FORMAT_R32G32B32X32_UINT,
        PIPE_FORMAT_R32G32B32A32_UINT, 0 }
   },
   {
      { GL_RGBA32UI_EXT, 0},
      { PIPE_FORMAT_R32G32B32A32_UINT, 0 }
   },
   {
     { GL_R8I, GL_RED_INTEGER_EXT, 0},
     { PIPE_FORMAT_R8_SINT, 0},
   },
   {
     { GL_R16I, 0},
     { PIPE_FORMAT_R16_SINT, 0},
   },
   {
     { GL_R32I, 0},
     { PIPE_FORMAT_R32_SINT, 0},
   },
  {
     { GL_R8UI, 0},
     { PIPE_FORMAT_R8_UINT, 0},
   },
   {
     { GL_R16UI, 0},
     { PIPE_FORMAT_R16_UINT, 0},
   },
   {
     { GL_R32UI, 0},
     { PIPE_FORMAT_R32_UINT, 0},
   },
   {
     { GL_RG8I, GL_GREEN_INTEGER_EXT, 0},
     { PIPE_FORMAT_R8G8_SINT, 0},
   },
   {
     { GL_RG16I, 0},
     { PIPE_FORMAT_R16G16_SINT, 0},
   },
   {
     { GL_RG32I, 0},
     { PIPE_FORMAT_R32G32_SINT, 0},
   },
  {
     { GL_RG8UI, 0},
     { PIPE_FORMAT_R8G8_UINT, 0},
   },
   {
     { GL_RG16UI, 0},
     { PIPE_FORMAT_R16G16_UINT, 0},
   },
   {
     { GL_RG32UI, 0},
     { PIPE_FORMAT_R32G32_UINT, 0},
   },
   /* signed normalized formats */
   {
      { GL_RED_SNORM, GL_R8_SNORM, 0 },
      { PIPE_FORMAT_R8_SNORM, PIPE_FORMAT_R8G8_SNORM,
        PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_R16_SNORM, 0 },
      { PIPE_FORMAT_R16_SNORM,
        PIPE_FORMAT_R16G16_SNORM,
        PIPE_FORMAT_R16G16B16A16_SNORM,
        PIPE_FORMAT_R8_SNORM,
        PIPE_FORMAT_R8G8_SNORM,
        PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_RG_SNORM, GL_RG8_SNORM, 0 },
      { PIPE_FORMAT_R8G8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_RG16_SNORM, 0 },
      { PIPE_FORMAT_R16G16_SNORM, PIPE_FORMAT_R16G16B16A16_SNORM,
        PIPE_FORMAT_R8G8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_RGB_SNORM, GL_RGB8_SNORM, 0 },
      { PIPE_FORMAT_R8G8B8X8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_RGBA_SNORM, GL_RGBA8_SNORM, 0 },
      { PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_RGB16_SNORM, 0 },
      { PIPE_FORMAT_R16G16B16X16_SNORM, PIPE_FORMAT_R16G16B16A16_SNORM,
        PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_RGBA16_SNORM, 0 },
      { PIPE_FORMAT_R16G16B16A16_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_ALPHA_SNORM, GL_ALPHA8_SNORM, 0 },
      { PIPE_FORMAT_A8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_ALPHA16_SNORM, 0 },
      { PIPE_FORMAT_A16_SNORM, PIPE_FORMAT_R16G16B16A16_SNORM,
        PIPE_FORMAT_A8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_LUMINANCE_SNORM, GL_LUMINANCE8_SNORM, 0 },
      { PIPE_FORMAT_L8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_LUMINANCE16_SNORM, 0 },
      { PIPE_FORMAT_L16_SNORM, PIPE_FORMAT_R16G16B16A16_SNORM,
        PIPE_FORMAT_L8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_LUMINANCE_ALPHA_SNORM, GL_LUMINANCE8_ALPHA8_SNORM, 0 },
      { PIPE_FORMAT_L8A8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_LUMINANCE16_ALPHA16_SNORM, 0 },
      { PIPE_FORMAT_L16A16_SNORM, PIPE_FORMAT_R16G16B16A16_SNORM,
        PIPE_FORMAT_L8A8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_INTENSITY_SNORM, GL_INTENSITY8_SNORM, 0 },
      { PIPE_FORMAT_I8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_INTENSITY16_SNORM, 0 },
      { PIPE_FORMAT_I16_SNORM, PIPE_FORMAT_R16G16B16A16_SNORM,
        PIPE_FORMAT_I8_SNORM, PIPE_FORMAT_R8G8B8A8_SNORM, 0 }
   },
   {
      { GL_RGB9_E5, 0 },
      { PIPE_FORMAT_R9G9B9E5_FLOAT, 0 }
   },
   {
      { GL_R11F_G11F_B10F, 0 },
      { PIPE_FORMAT_R11G11B10_FLOAT, 0 }
   },
   {
      { GL_RGB10_A2UI, 0 },
      { PIPE_FORMAT_B10G10R10A2_UINT, 0 }
   },
};


/**
a375 1
 * \param allow_dxt  indicates whether it's OK to return a DXT format.
d378 1
a378 1
find_supported_format(struct pipe_screen *screen,
d380 1
d384 1
a384 1
                      boolean allow_dxt)
d387 1
a387 1
   for (i = 0; formats[i]; i++) {
d389 1
a389 6
                                      sample_count, tex_usage)) {
         if (!allow_dxt && util_format_is_s3tc(formats[i])) {
            /* we can't return a dxt format, continue searching */
            continue;
         }

a395 6
struct exact_format_mapping
{
   GLenum format;
   GLenum type;
   enum pipe_format pformat;
};
d397 9
a405 1
static const struct exact_format_mapping rgba8888_tbl[] =
d407 9
a415 11
   { GL_RGBA,     GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_ABGR8888_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_ABGR8888_UNORM },
   { GL_RGBA,     GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_RGBA8888_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_RGBA8888_UNORM },
   { GL_BGRA,     GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_ARGB8888_UNORM },
   { GL_BGRA,     GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_BGRA8888_UNORM },
   { GL_RGBA,     GL_UNSIGNED_BYTE,               PIPE_FORMAT_R8G8B8A8_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_BYTE,               PIPE_FORMAT_A8B8G8R8_UNORM },
   { GL_BGRA,     GL_UNSIGNED_BYTE,               PIPE_FORMAT_B8G8R8A8_UNORM },
   { 0,           0,                              0                          }
};
a416 13
static const struct exact_format_mapping rgbx8888_tbl[] =
{
   { GL_RGBA,     GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_XBGR8888_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_XBGR8888_UNORM },
   { GL_RGBA,     GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_RGBX8888_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_RGBX8888_UNORM },
   { GL_BGRA,     GL_UNSIGNED_INT_8_8_8_8,        PIPE_FORMAT_XRGB8888_UNORM },
   { GL_BGRA,     GL_UNSIGNED_INT_8_8_8_8_REV,    PIPE_FORMAT_BGRX8888_UNORM },
   { GL_RGBA,     GL_UNSIGNED_BYTE,               PIPE_FORMAT_R8G8B8X8_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_BYTE,               PIPE_FORMAT_X8B8G8R8_UNORM },
   { GL_BGRA,     GL_UNSIGNED_BYTE,               PIPE_FORMAT_B8G8R8X8_UNORM },
   { 0,           0,                              0                          }
};
d418 9
a426 1
static const struct exact_format_mapping rgba1010102_tbl[] =
d428 12
a439 8
   { GL_BGRA,     GL_UNSIGNED_INT_2_10_10_10_REV, PIPE_FORMAT_B10G10R10A2_UNORM },
   /* No Mesa formats for these Gallium formats:
   { GL_RGBA,     GL_UNSIGNED_INT_2_10_10_10_REV, PIPE_FORMAT_R10G10B10A2_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT_10_10_10_2,     PIPE_FORMAT_R10G10B10A2_UNORM },
   { GL_ABGR_EXT, GL_UNSIGNED_INT,                PIPE_FORMAT_R10G10B10A2_UNORM },
   */
   { 0,           0,                              0                             }
};
d442 1
a442 2
 * If there is an exact pipe_format match for {internalFormat, format, type}
 * return that, otherwise return PIPE_FORMAT_NONE so we can do fuzzy matching.
d445 5
a449 1
find_exact_format(GLint internalFormat, GLenum format, GLenum type)
d451 8
a458 27
   uint i;
   const struct exact_format_mapping* tbl;

   if (format == GL_NONE || type == GL_NONE)
      return PIPE_FORMAT_NONE;

   switch (internalFormat) {
   case 4:
   case GL_RGBA:
   case GL_RGBA8:
      tbl = rgba8888_tbl;
      break;
   case 3:
   case GL_RGB:
   case GL_RGB8:
      tbl = rgbx8888_tbl;
      break;
   case GL_RGB10_A2:
      tbl = rgba1010102_tbl;
      break;
   default:
      return PIPE_FORMAT_NONE;
   }

   for (i = 0; tbl[i].format; i++)
      if (tbl[i].format == format && tbl[i].type == type)
         return tbl[i].pformat;
a459 2
   return PIPE_FORMAT_NONE;
}
a472 4
 * \param allow_dxt  indicates whether it's OK to return a DXT format.  This
 *                   only matters when internalFormat names a generic or
 *                   specific compressed format.  And that should only happen
 *                   when we're getting called from gl[Copy]TexImage().
d475 1
a475 2
st_choose_format(struct st_context *st, GLenum internalFormat,
                 GLenum format, GLenum type,
d477 1
a477 1
                 unsigned bindings, boolean allow_dxt)
d479 122
a600 7
   struct pipe_screen *screen = st->pipe->screen;
   int i, j;
   enum pipe_format pf;

   /* can't render to compressed formats at this time */
   if (_mesa_is_compressed_format(st->ctx, internalFormat)
       && (bindings & ~PIPE_BIND_SAMPLER_VIEW)) {
a601 1
   }
d603 123
a725 19
   /* search for exact matches */
   pf = find_exact_format(internalFormat, format, type);
   if (pf != PIPE_FORMAT_NONE &&
       screen->is_format_supported(screen, pf,
                                   target, sample_count, bindings))
      return pf;

   /* search table for internalFormat */
   for (i = 0; i < Elements(format_map); i++) {
      const struct format_mapping *mapping = &format_map[i];
      for (j = 0; mapping->glFormats[j]; j++) {
         if (mapping->glFormats[j] == internalFormat) {
            /* Found the desired internal format.  Find first pipe format
             * which is supported by the driver.
             */
            return find_supported_format(screen, mapping->pipeFormats,
                                         target, sample_count, bindings,
                                         allow_dxt);
         }
d727 173
a900 3

   _mesa_problem(NULL, "unhandled format!\n");
   return PIPE_FORMAT_NONE;
d908 1
a908 1
st_choose_renderbuffer_format(struct st_context *st,
d916 2
a917 37
   return st_choose_format(st, internalFormat, GL_NONE, GL_NONE,
                           PIPE_TEXTURE_2D, sample_count, usage, FALSE);
}


/**
 * Given an OpenGL user-requested format and type, and swapBytes state,
 * return the format which exactly matches those parameters, so that
 * a memcpy-based transfer can be done.
 *
 * If no format is supported, return PIPE_FORMAT_NONE.
 */
enum pipe_format
st_choose_matching_format(struct pipe_screen *screen, unsigned bind,
			  GLenum format, GLenum type, GLboolean swapBytes)
{
   gl_format mesa_format;

   for (mesa_format = 1; mesa_format < MESA_FORMAT_COUNT; mesa_format++) {
      if (_mesa_get_format_color_encoding(mesa_format) == GL_SRGB) {
         continue;
      }

      if (_mesa_format_matches_format_and_type(mesa_format, format, type,
                                               swapBytes)) {
         enum pipe_format format = st_mesa_format_to_pipe_format(mesa_format);

         if (format &&
             screen->is_format_supported(screen, format, PIPE_TEXTURE_2D, 0,
                                         bind)) {
            return format;
         }
         /* It's unlikely to find 2 matching Mesa formats. */
         break;
      }
   }
   return PIPE_FORMAT_NONE;
d922 1
a922 1
 * Called via ctx->Driver.ChooseTextureFormat().
d925 2
a926 3
st_ChooseTextureFormat(struct gl_context *ctx, GLenum target,
                       GLint internalFormat,
                       GLenum format, GLenum type)
d928 1
a928 6
   const boolean want_renderable =
      internalFormat == 3 || internalFormat == 4 ||
      internalFormat == GL_RGB || internalFormat == GL_RGBA ||
      internalFormat == GL_RGB8 || internalFormat == GL_RGBA8 ||
      internalFormat == GL_BGRA;
   struct st_context *st = st_context(ctx);
d930 1
a930 1
   unsigned bindings;
d932 2
a933 8
   if (target == GL_TEXTURE_1D || target == GL_TEXTURE_1D_ARRAY) {
      /* We don't do compression for these texture targets because of
       * difficulty with sub-texture updates on non-block boundaries, etc.
       * So change the internal format request to an uncompressed format.
       */
      internalFormat =
        _mesa_generic_compressed_format_to_uncompressed_format(internalFormat);
   }
d939 3
a941 2
   if (want_renderable) {
      if (_mesa_is_depth_or_stencil_format(internalFormat))
d943 1
a943 1
      else
d947 2
a948 2
   pFormat = st_choose_format(st, internalFormat, format, type,
                              PIPE_TEXTURE_2D, 0, bindings, ctx->Mesa_DXTn);
d952 2
a953 3
      pFormat = st_choose_format(st, internalFormat, format, type,
                                 PIPE_TEXTURE_2D, 0, PIPE_BIND_SAMPLER_VIEW,
                                 ctx->Mesa_DXTn);
d964 7
d973 1
a973 1
 * Called via ctx->Driver.ChooseTextureFormat().
d975 2
a976 3
size_t
st_QuerySamplesForFormat(struct gl_context *ctx, GLenum target,
                         GLenum internalFormat, int samples[16])
d978 10
a987 16
   struct st_context *st = st_context(ctx);
   enum pipe_format format;
   unsigned i, bind, num_sample_counts = 0;

   (void) target;

   if (_mesa_is_depth_or_stencil_format(internalFormat))
      bind = PIPE_BIND_DEPTH_STENCIL;
   else
      bind = PIPE_BIND_RENDER_TARGET;

   /* If an sRGB framebuffer is unsupported, sRGB formats behave like linear
    * formats.
    */
   if (!ctx->Extensions.EXT_framebuffer_sRGB) {
      internalFormat = _mesa_get_linear_internalformat(internalFormat);
d989 1
d991 5
a995 4
   /* Set sample counts in descending order. */
   for (i = 16; i > 1; i--) {
      format = st_choose_format(st, internalFormat, GL_NONE, GL_NONE,
                                PIPE_TEXTURE_2D, i, bind, FALSE);
d997 23
a1019 4
      if (format != PIPE_FORMAT_NONE) {
         samples[num_sample_counts++] = i;
      }
   }
d1021 2
a1022 3
   if (!num_sample_counts) {
      samples[num_sample_counts++] = 1;
   }
a1023 2
   return num_sample_counts;
}
d1030 2
a1031 3
 * GL_LUMINANCE buffer, we'll return colorOut[0] = colorOut[1] =
 * colorOut[2] = colorIn[0].
 * Similarly for texture border colors.
d1034 2
a1035 3
st_translate_color(union gl_color_union *colorIn,
                   union pipe_color_union *colorOut,
                   GLenum baseFormat, GLboolean is_integer)
d1037 36
a1072 83
   if (is_integer) {
      int *in = colorIn->i;
      int *out = colorOut->i;

      switch (baseFormat) {
      case GL_RED:
         out[0] = in[0];
         out[1] = 0;
         out[2] = 0;
         out[3] = 1;
         break;
      case GL_RG:
         out[0] = in[0];
         out[1] = in[1];
         out[2] = 0;
         out[3] = 1;
         break;
      case GL_RGB:
         out[0] = in[0];
         out[1] = in[1];
         out[2] = in[2];
         out[3] = 1;
         break;
      case GL_ALPHA:
         out[0] = out[1] = out[2] = 0;
         out[3] = in[3];
         break;
      case GL_LUMINANCE:
         out[0] = out[1] = out[2] = in[0];
         out[3] = 1;
         break;
      case GL_LUMINANCE_ALPHA:
         out[0] = out[1] = out[2] = in[0];
         out[3] = in[3];
         break;
      case GL_INTENSITY:
         out[0] = out[1] = out[2] = out[3] = in[0];
         break;
      default:
         COPY_4V(out, in);
      }
   }
   else {
      float *in = colorIn->f;
      float *out = colorOut->f;

      switch (baseFormat) {
      case GL_RED:
         out[0] = in[0];
         out[1] = 0.0F;
         out[2] = 0.0F;
         out[3] = 1.0F;
         break;
      case GL_RG:
         out[0] = in[0];
         out[1] = in[1];
         out[2] = 0.0F;
         out[3] = 1.0F;
         break;
      case GL_RGB:
         out[0] = in[0];
         out[1] = in[1];
         out[2] = in[2];
         out[3] = 1.0F;
         break;
      case GL_ALPHA:
         out[0] = out[1] = out[2] = 0.0F;
         out[3] = in[3];
         break;
      case GL_LUMINANCE:
         out[0] = out[1] = out[2] = in[0];
         out[3] = 1.0F;
         break;
      case GL_LUMINANCE_ALPHA:
         out[0] = out[1] = out[2] = in[0];
         out[3] = in[3];
         break;
      case GL_INTENSITY:
         out[0] = out[1] = out[2] = out[3] = in[0];
         break;
      default:
         COPY_4V(out, in);
      }
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d22 1
a22 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a37 2
#include "main/texgetimage.h"
#include "main/teximage.h"
a45 1
#include "st_cb_texture.h"
d54 1
a54 1
st_mesa_format_to_pipe_format(mesa_format mesaFormat)
d57 1
a57 1
   case MESA_FORMAT_A8B8G8R8_UNORM:
d59 1
a59 1
   case MESA_FORMAT_R8G8B8A8_UNORM:
d61 1
a61 1
   case MESA_FORMAT_B8G8R8A8_UNORM:
d63 1
a63 1
   case MESA_FORMAT_A8R8G8B8_UNORM:
d65 1
a65 1
   case MESA_FORMAT_X8B8G8R8_UNORM:
d67 1
a67 1
   case MESA_FORMAT_R8G8B8X8_UNORM:
d69 1
a69 1
   case MESA_FORMAT_B8G8R8X8_UNORM:
d71 1
a71 1
   case MESA_FORMAT_X8R8G8B8_UNORM:
d73 1
a73 1
   case MESA_FORMAT_B5G5R5A1_UNORM:
d75 1
a75 1
   case MESA_FORMAT_B4G4R4A4_UNORM:
d77 1
a77 1
   case MESA_FORMAT_B5G6R5_UNORM:
d79 1
a79 1
   case MESA_FORMAT_B2G3R3_UNORM:
d81 1
a81 1
   case MESA_FORMAT_B10G10R10A2_UNORM:
d83 1
a83 1
   case MESA_FORMAT_L4A4_UNORM:
d85 1
a85 1
   case MESA_FORMAT_L8A8_UNORM:
d87 1
a87 1
   case MESA_FORMAT_L16A16_UNORM:
d89 1
a89 1
   case MESA_FORMAT_A_UNORM8:
d91 1
a91 1
   case MESA_FORMAT_A_UNORM16:
d93 1
a93 1
   case MESA_FORMAT_L_UNORM8:
d95 1
a95 1
   case MESA_FORMAT_L_UNORM16:
d97 1
a97 1
   case MESA_FORMAT_I_UNORM8:
d99 1
a99 1
   case MESA_FORMAT_I_UNORM16:
d101 1
a101 1
   case MESA_FORMAT_Z_UNORM16:
d103 1
a103 1
   case MESA_FORMAT_Z_UNORM32:
d105 1
a105 1
   case MESA_FORMAT_S8_UINT_Z24_UNORM:
d107 1
a107 1
   case MESA_FORMAT_Z24_UNORM_S8_UINT:
d109 1
a109 1
   case MESA_FORMAT_X8_UINT_Z24_UNORM:
d111 1
a111 1
   case MESA_FORMAT_Z24_UNORM_X8_UINT:
d113 1
a113 1
   case MESA_FORMAT_S_UINT8:
d115 1
a115 1
   case MESA_FORMAT_Z_FLOAT32:
d117 1
a117 1
   case MESA_FORMAT_Z32_FLOAT_S8X24_UINT:
a120 2
   case MESA_FORMAT_YCBCR_REV:
      return PIPE_FORMAT_YUYV;
d137 1
a137 1
   case MESA_FORMAT_L8A8_SRGB:
d139 1
a139 1
   case MESA_FORMAT_L_SRGB8:
d141 1
a141 1
   case MESA_FORMAT_BGR_SRGB8:
d143 1
a143 1
   case MESA_FORMAT_A8B8G8R8_SRGB:
d145 1
a145 1
   case MESA_FORMAT_B8G8R8A8_SRGB:
a146 2
   case MESA_FORMAT_R8G8B8A8_SRGB:
      return PIPE_FORMAT_R8G8B8A8_SRGB;
d155 1
a155 1
   case MESA_FORMAT_LA_FLOAT32:
d157 1
a157 1
   case MESA_FORMAT_LA_FLOAT16:
d159 1
a159 1
   case MESA_FORMAT_L_FLOAT32:
d161 1
a161 1
   case MESA_FORMAT_L_FLOAT16:
d163 1
a163 1
   case MESA_FORMAT_A_FLOAT32:
d165 1
a165 1
   case MESA_FORMAT_A_FLOAT16:
d167 1
a167 1
   case MESA_FORMAT_I_FLOAT32:
d169 1
a169 1
   case MESA_FORMAT_I_FLOAT16:
d180 1
a180 1
   case MESA_FORMAT_R_UNORM8:
d182 1
a182 1
   case MESA_FORMAT_R_UNORM16:
d184 1
a184 1
   case MESA_FORMAT_R8G8_UNORM:
d186 1
a186 1
   case MESA_FORMAT_R16G16_UNORM:
d188 1
a188 1
   case MESA_FORMAT_RGBA_UNORM16:
d192 1
a192 1
   case MESA_FORMAT_A_UINT8:
d194 1
a194 1
   case MESA_FORMAT_A_UINT16:
d196 1
a196 1
   case MESA_FORMAT_A_UINT32:
d199 1
a199 1
   case MESA_FORMAT_A_SINT8:
d201 1
a201 1
   case MESA_FORMAT_A_SINT16:
d203 1
a203 1
   case MESA_FORMAT_A_SINT32:
d206 1
a206 1
   case MESA_FORMAT_I_UINT8:
d208 1
a208 1
   case MESA_FORMAT_I_UINT16:
d210 1
a210 1
   case MESA_FORMAT_I_UINT32:
d213 1
a213 1
   case MESA_FORMAT_I_SINT8:
d215 1
a215 1
   case MESA_FORMAT_I_SINT16:
d217 1
a217 1
   case MESA_FORMAT_I_SINT32:
d220 1
a220 1
   case MESA_FORMAT_L_UINT8:
d222 1
a222 1
   case MESA_FORMAT_L_UINT16:
d224 1
a224 1
   case MESA_FORMAT_L_UINT32:
d227 1
a227 1
   case MESA_FORMAT_L_SINT8:
d229 1
a229 1
   case MESA_FORMAT_L_SINT16:
d231 1
a231 1
   case MESA_FORMAT_L_SINT32:
d234 1
a234 1
   case MESA_FORMAT_LA_UINT8:
d236 1
a236 1
   case MESA_FORMAT_LA_UINT16:
d238 1
a238 1
   case MESA_FORMAT_LA_UINT32:
d241 1
a241 1
   case MESA_FORMAT_LA_SINT8:
d243 1
a243 1
   case MESA_FORMAT_LA_SINT16:
d245 1
a245 1
   case MESA_FORMAT_LA_SINT32:
d248 1
a248 1
   case MESA_FORMAT_R_SINT8:
d250 1
a250 1
   case MESA_FORMAT_RG_SINT8:
d252 1
a252 1
   case MESA_FORMAT_RGB_SINT8:
d254 1
a254 1
   case MESA_FORMAT_RGBA_SINT8:
d256 1
a256 1
   case MESA_FORMAT_R_SINT16:
d258 1
a258 1
   case MESA_FORMAT_RG_SINT16:
d260 1
a260 1
   case MESA_FORMAT_RGB_SINT16:
d262 1
a262 1
   case MESA_FORMAT_RGBA_SINT16:
d264 1
a264 1
   case MESA_FORMAT_R_SINT32:
d266 1
a266 1
   case MESA_FORMAT_RG_SINT32:
d268 1
a268 1
   case MESA_FORMAT_RGB_SINT32:
d270 1
a270 1
   case MESA_FORMAT_RGBA_SINT32:
d299 1
a299 1
   case MESA_FORMAT_R_RGTC1_UNORM:
d301 1
a301 1
   case MESA_FORMAT_R_RGTC1_SNORM:
d303 1
a303 1
   case MESA_FORMAT_RG_RGTC2_UNORM:
d305 1
a305 1
   case MESA_FORMAT_RG_RGTC2_SNORM:
d308 1
a308 1
   case MESA_FORMAT_L_LATC1_UNORM:
d310 1
a310 1
   case MESA_FORMAT_L_LATC1_SNORM:
d312 1
a312 1
   case MESA_FORMAT_LA_LATC2_UNORM:
d314 1
a314 1
   case MESA_FORMAT_LA_LATC2_SNORM:
d321 1
a321 1
   case MESA_FORMAT_R_SNORM8:
d323 1
a323 1
   case MESA_FORMAT_R8G8_SNORM:
d325 1
a325 1
   case MESA_FORMAT_R8G8B8A8_SNORM:
d328 1
a328 1
   case MESA_FORMAT_A_SNORM8:
d330 1
a330 1
   case MESA_FORMAT_L_SNORM8:
d332 1
a332 1
   case MESA_FORMAT_L8A8_SNORM:
d334 1
a334 1
   case MESA_FORMAT_I_SNORM8:
d337 1
a337 1
   case MESA_FORMAT_R_SNORM16:
d339 1
a339 1
   case MESA_FORMAT_R16G16_SNORM:
d341 1
a341 1
   case MESA_FORMAT_RGBA_SNORM16:
d344 1
a344 1
   case MESA_FORMAT_A_SNORM16:
d346 1
a346 1
   case MESA_FORMAT_L_SNORM16:
d348 1
a348 1
   case MESA_FORMAT_LA_SNORM16:
d350 1
a350 1
   case MESA_FORMAT_I_SNORM16:
d353 1
a353 1
   case MESA_FORMAT_R9G9B9E5_FLOAT:
d355 1
a355 1
   case MESA_FORMAT_R11G11B10_FLOAT:
d357 1
a357 1
   case MESA_FORMAT_B10G10R10A2_UINT:
a358 2
   case MESA_FORMAT_R10G10B10A2_UINT:
      return PIPE_FORMAT_R10G10B10A2_UINT;
d360 1
a360 1
   case MESA_FORMAT_B4G4R4X4_UNORM:
d362 1
a362 1
   case MESA_FORMAT_B5G5R5X1_UNORM:
d364 1
a364 1
   case MESA_FORMAT_R8G8B8X8_SNORM:
d366 1
a366 1
   case MESA_FORMAT_R8G8B8X8_SRGB:
d368 1
a368 1
   case MESA_FORMAT_RGBX_UINT8:
d370 1
a370 1
   case MESA_FORMAT_RGBX_SINT8:
d372 1
a372 1
   case MESA_FORMAT_B10G10R10X2_UNORM:
d374 1
a374 1
   case MESA_FORMAT_RGBX_UNORM16:
d376 1
a376 1
   case MESA_FORMAT_RGBX_SNORM16:
d378 1
a378 1
   case MESA_FORMAT_RGBX_FLOAT16:
d380 1
a380 1
   case MESA_FORMAT_RGBX_UINT16:
d382 1
a382 1
   case MESA_FORMAT_RGBX_SINT16:
d384 1
a384 1
   case MESA_FORMAT_RGBX_FLOAT32:
d386 1
a386 1
   case MESA_FORMAT_RGBX_UINT32:
d388 1
a388 1
   case MESA_FORMAT_RGBX_SINT32:
a390 3
   case MESA_FORMAT_B8G8R8X8_SRGB:
      return PIPE_FORMAT_B8G8R8X8_SRGB;

d400 1
a400 1
mesa_format
d405 1
a405 1
      return MESA_FORMAT_A8B8G8R8_UNORM;
d407 1
a407 1
      return MESA_FORMAT_R8G8B8A8_UNORM;
d409 1
a409 1
      return MESA_FORMAT_B8G8R8A8_UNORM;
d411 1
a411 1
      return MESA_FORMAT_A8R8G8B8_UNORM;
d413 1
a413 1
      return MESA_FORMAT_X8B8G8R8_UNORM;
d415 1
a415 1
      return MESA_FORMAT_R8G8B8X8_UNORM;
d417 1
a417 1
      return MESA_FORMAT_B8G8R8X8_UNORM;
d419 1
a419 1
      return MESA_FORMAT_X8R8G8B8_UNORM;
d421 1
a421 1
      return MESA_FORMAT_B5G5R5A1_UNORM;
d423 1
a423 1
      return MESA_FORMAT_B4G4R4A4_UNORM;
d425 1
a425 1
      return MESA_FORMAT_B5G6R5_UNORM;
d427 1
a427 1
      return MESA_FORMAT_B2G3R3_UNORM;
d429 1
a429 1
      return MESA_FORMAT_B10G10R10A2_UNORM;
d431 1
a431 1
      return MESA_FORMAT_L4A4_UNORM;
d433 1
a433 1
      return MESA_FORMAT_L8A8_UNORM;
d435 1
a435 1
      return MESA_FORMAT_L16A16_UNORM;
d437 1
a437 1
      return MESA_FORMAT_A_UNORM8;
d439 1
a439 1
      return MESA_FORMAT_A_UNORM16;
d441 1
a441 1
      return MESA_FORMAT_L_UNORM8;
d443 1
a443 1
      return MESA_FORMAT_L_UNORM16;
d445 1
a445 1
      return MESA_FORMAT_I_UNORM8;
d447 1
a447 1
      return MESA_FORMAT_I_UNORM16;
d449 1
a449 1
      return MESA_FORMAT_S_UINT8;
d452 1
a452 1
      return MESA_FORMAT_RGBA_UNORM16;
d455 1
a455 1
      return MESA_FORMAT_Z_UNORM16;
d457 1
a457 1
      return MESA_FORMAT_Z_UNORM32;
d459 1
a459 1
      return MESA_FORMAT_S8_UINT_Z24_UNORM;
d461 1
a461 1
      return MESA_FORMAT_X8_UINT_Z24_UNORM;
d463 1
a463 1
      return MESA_FORMAT_Z24_UNORM_X8_UINT;
d465 1
a465 1
      return MESA_FORMAT_Z24_UNORM_S8_UINT;
d467 1
a467 1
      return MESA_FORMAT_Z_FLOAT32;
d469 1
a469 1
      return MESA_FORMAT_Z32_FLOAT_S8X24_UINT;
d493 1
a493 1
      return MESA_FORMAT_L8A8_SRGB;
d495 1
a495 1
      return MESA_FORMAT_L_SRGB8;
d497 1
a497 1
      return MESA_FORMAT_BGR_SRGB8;
d499 1
a499 1
      return MESA_FORMAT_A8B8G8R8_SRGB;
d501 1
a501 1
      return MESA_FORMAT_B8G8R8A8_SRGB;
d511 1
a511 1
      return MESA_FORMAT_LA_FLOAT32;
d513 1
a513 1
      return MESA_FORMAT_LA_FLOAT16;
d515 1
a515 1
      return MESA_FORMAT_L_FLOAT32;
d517 1
a517 1
      return MESA_FORMAT_L_FLOAT16;
d519 1
a519 1
      return MESA_FORMAT_A_FLOAT32;
d521 1
a521 1
      return MESA_FORMAT_A_FLOAT16;
d523 1
a523 1
      return MESA_FORMAT_I_FLOAT32;
d525 1
a525 1
      return MESA_FORMAT_I_FLOAT16;
d536 1
a536 1
      return MESA_FORMAT_R_UNORM8;
d538 1
a538 1
      return MESA_FORMAT_R_UNORM16;
d540 1
a540 1
      return MESA_FORMAT_R8G8_UNORM;
d542 1
a542 1
      return MESA_FORMAT_R16G16_UNORM;
d545 1
a545 1
      return MESA_FORMAT_A_UINT8;
d547 1
a547 1
      return MESA_FORMAT_A_UINT16;
d549 1
a549 1
      return MESA_FORMAT_A_UINT32;
d551 1
a551 1
      return MESA_FORMAT_A_SINT8;
d553 1
a553 1
      return MESA_FORMAT_A_SINT16;
d555 1
a555 1
      return MESA_FORMAT_A_SINT32;
d558 1
a558 1
      return MESA_FORMAT_I_UINT8;
d560 1
a560 1
      return MESA_FORMAT_I_UINT16;
d562 1
a562 1
      return MESA_FORMAT_I_UINT32;
d564 1
a564 1
      return MESA_FORMAT_I_SINT8;
d566 1
a566 1
      return MESA_FORMAT_I_SINT16;
d568 1
a568 1
      return MESA_FORMAT_I_SINT32;
d571 1
a571 1
      return MESA_FORMAT_L_UINT8;
d573 1
a573 1
      return MESA_FORMAT_L_UINT16;
d575 1
a575 1
      return MESA_FORMAT_L_UINT32;
d577 1
a577 1
      return MESA_FORMAT_L_SINT8;
d579 1
a579 1
      return MESA_FORMAT_L_SINT16;
d581 1
a581 1
      return MESA_FORMAT_L_SINT32;
d584 1
a584 1
      return MESA_FORMAT_LA_UINT8;
d586 1
a586 1
      return MESA_FORMAT_LA_UINT16;
d588 1
a588 1
      return MESA_FORMAT_LA_UINT32;
d590 1
a590 1
      return MESA_FORMAT_LA_SINT8;
d592 1
a592 1
      return MESA_FORMAT_LA_SINT16;
d594 1
a594 1
      return MESA_FORMAT_LA_SINT32;
d597 1
a597 1
      return MESA_FORMAT_R_SINT8;
d599 1
a599 1
      return MESA_FORMAT_RG_SINT8;
d601 1
a601 1
      return MESA_FORMAT_RGB_SINT8;
d603 1
a603 1
      return MESA_FORMAT_RGBA_SINT8;
d606 1
a606 1
      return MESA_FORMAT_R_SINT16;
d608 1
a608 1
      return MESA_FORMAT_RG_SINT16;
d610 1
a610 1
      return MESA_FORMAT_RGB_SINT16;
d612 1
a612 1
      return MESA_FORMAT_RGBA_SINT16;
d615 1
a615 1
      return MESA_FORMAT_R_SINT32;
d617 1
a617 1
      return MESA_FORMAT_RG_SINT32;
d619 1
a619 1
      return MESA_FORMAT_RGB_SINT32;
d621 1
a621 1
      return MESA_FORMAT_RGBA_SINT32;
d652 1
a652 1
      return MESA_FORMAT_R_RGTC1_UNORM;
d654 1
a654 1
      return MESA_FORMAT_R_RGTC1_SNORM;
d656 1
a656 1
      return MESA_FORMAT_RG_RGTC2_UNORM;
d658 1
a658 1
      return MESA_FORMAT_RG_RGTC2_SNORM;
d661 1
a661 1
      return MESA_FORMAT_L_LATC1_UNORM;
d663 1
a663 1
      return MESA_FORMAT_L_LATC1_SNORM;
d665 1
a665 1
      return MESA_FORMAT_LA_LATC2_UNORM;
d667 1
a667 1
      return MESA_FORMAT_LA_LATC2_SNORM;
d674 1
a674 1
      return MESA_FORMAT_R_SNORM8;
d676 1
a676 1
      return MESA_FORMAT_R8G8_SNORM;
d678 1
a678 1
      return MESA_FORMAT_R8G8B8A8_SNORM;
d681 1
a681 1
      return MESA_FORMAT_A_SNORM8;
d683 1
a683 1
      return MESA_FORMAT_L_SNORM8;
d685 1
a685 1
      return MESA_FORMAT_L8A8_SNORM;
d687 1
a687 1
      return MESA_FORMAT_I_SNORM8;
d690 1
a690 1
      return MESA_FORMAT_R_SNORM16;
d692 1
a692 1
      return MESA_FORMAT_R16G16_SNORM;
d694 1
a694 1
      return MESA_FORMAT_RGBA_SNORM16;
d697 1
a697 1
      return MESA_FORMAT_A_SNORM16;
d699 1
a699 1
      return MESA_FORMAT_L_SNORM16;
d701 1
a701 1
      return MESA_FORMAT_LA_SNORM16;
d703 1
a703 1
      return MESA_FORMAT_I_SNORM16;
d706 1
a706 1
      return MESA_FORMAT_R9G9B9E5_FLOAT;
d708 1
a708 1
      return MESA_FORMAT_R11G11B10_FLOAT;
d711 1
a711 3
      return MESA_FORMAT_B10G10R10A2_UINT;
   case PIPE_FORMAT_R10G10B10A2_UINT:
      return MESA_FORMAT_R10G10B10A2_UINT;
d714 1
a714 1
      return MESA_FORMAT_B4G4R4X4_UNORM;
d716 1
a716 1
      return MESA_FORMAT_B5G5R5X1_UNORM;
d718 1
a718 1
      return MESA_FORMAT_R8G8B8X8_SNORM;
d720 1
a720 1
      return MESA_FORMAT_R8G8B8X8_SRGB;
d722 1
a722 1
      return MESA_FORMAT_RGBX_UINT8;
d724 1
a724 1
      return MESA_FORMAT_RGBX_SINT8;
d726 1
a726 1
      return MESA_FORMAT_B10G10R10X2_UNORM;
d728 1
a728 1
      return MESA_FORMAT_RGBX_UNORM16;
d730 1
a730 1
      return MESA_FORMAT_RGBX_SNORM16;
d732 1
a732 1
      return MESA_FORMAT_RGBX_FLOAT16;
d734 1
a734 1
      return MESA_FORMAT_RGBX_UINT16;
d736 1
a736 1
      return MESA_FORMAT_RGBX_SINT16;
d738 1
a738 1
      return MESA_FORMAT_RGBX_FLOAT32;
d740 1
a740 1
      return MESA_FORMAT_RGBX_UINT32;
d742 1
a742 6
      return MESA_FORMAT_RGBX_SINT32;

   case PIPE_FORMAT_B8G8R8X8_SRGB:
      return MESA_FORMAT_B8G8R8X8_SRGB;
   case PIPE_FORMAT_R8G8B8A8_SRGB:
      return MESA_FORMAT_R8G8B8A8_SRGB;
d745 1
a751 29
 * Debug only: check that the two functions above correctly map
 * Mesa formats to Gallium formats and back again.
 */
static void
test_format_conversion(void)
{
   GLuint i;

   /* test all Mesa formats */
   for (i = 1; i < MESA_FORMAT_COUNT; i++) {
      enum pipe_format pf = st_mesa_format_to_pipe_format(i);
      if (pf != PIPE_FORMAT_NONE) {
         mesa_format mf = st_pipe_format_to_mesa_format(pf);
         assert(mf == i);
      }
   }

   /* Test all Gallium formats */
   for (i = 1; i < PIPE_FORMAT_COUNT; i++) {
      mesa_format mf = st_pipe_format_to_mesa_format(i);
      if (mf != MESA_FORMAT_NONE) {
         enum pipe_format pf = st_mesa_format_to_pipe_format(mf);
         assert(pf == i);
      }
   }
}


/**
d1002 1
a1002 2
      { PIPE_FORMAT_R8G8B8X8_SRGB, PIPE_FORMAT_B8G8R8X8_SRGB,
        DEFAULT_SRGBA_FORMATS }
d1011 1
a1011 1
        PIPE_FORMAT_B8G8R8X8_SRGB, DEFAULT_SRGBA_FORMATS }
d1483 1
a1483 1
      { PIPE_FORMAT_R10G10B10A2_UINT, PIPE_FORMAT_B10G10R10A2_UINT, 0 }
a1625 12
#ifdef DEBUG
   {
      static boolean firstCall = TRUE;
      if (firstCall) {
         test_format_conversion();
         firstCall = FALSE;
      }
   }
#else
   (void) test_format_conversion;
#endif

d1687 1
a1687 1
   mesa_format mesa_format;
a1692 6
      if (_mesa_get_format_bits(mesa_format, GL_TEXTURE_INTENSITY_SIZE) > 0) {
         /* If `format` is GL_RED/GL_RED_INTEGER, then we might match some
          * intensity formats, which we don't want.
          */
         continue;
      }
d1714 1
a1714 1
mesa_format
a1726 1
   enum pipe_texture_target pTarget = gl_target_to_pipe(target);
a1747 34
   /* GLES allows the driver to choose any format which matches
    * the format+type combo, because GLES only supports unsized internal
    * formats and expects the driver to choose whatever suits it.
    */
   if (_mesa_is_gles(ctx)) {
      GLenum baseFormat = _mesa_base_tex_format(ctx, internalFormat);
      GLenum basePackFormat = _mesa_base_pack_format(format);
      GLenum iformat = internalFormat;

      /* Treat GL_BGRA as GL_RGBA. */
      if (iformat == GL_BGRA)
         iformat = GL_RGBA;

      /* Check if the internalformat is unsized and compatible
       * with the "format".
       */
      if (iformat == baseFormat && iformat == basePackFormat) {
         pFormat = st_choose_matching_format(st->pipe->screen, bindings,
                                             format, type,
                                             ctx->Unpack.SwapBytes);

         if (pFormat != PIPE_FORMAT_NONE)
            return st_pipe_format_to_mesa_format(pFormat);

         /* try choosing format again, this time without render target bindings */
         pFormat = st_choose_matching_format(st->pipe->screen,
                                             PIPE_BIND_SAMPLER_VIEW,
                                             format, type,
                                             ctx->Unpack.SwapBytes);
         if (pFormat != PIPE_FORMAT_NONE)
            return st_pipe_format_to_mesa_format(pFormat);
      }
   }

d1749 1
a1749 1
                              pTarget, 0, bindings, ctx->Mesa_DXTn);
d1754 1
a1754 1
                                 pTarget, 0, PIPE_BIND_SAMPLER_VIEW,
d1819 1
a1819 1
st_translate_color(const union gl_color_union *colorIn,
d1824 1
a1824 1
      const int *in = colorIn->i;
d1866 1
a1866 1
      const float *in = colorIn->f;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d57 1
a57 1
st_mesa_format_to_pipe_format(struct st_context *st, mesa_format mesaFormat)
a85 2
   case MESA_FORMAT_R10G10B10A2_UNORM:
      return PIPE_FORMAT_R10G10B10A2_UNORM;
d89 1
a89 3
      return PIPE_FORMAT_LA88_UNORM;
   case MESA_FORMAT_A8L8_UNORM:
      return PIPE_FORMAT_AL88_UNORM;
d91 1
a91 3
      return PIPE_FORMAT_LA1616_UNORM;
   case MESA_FORMAT_A16L16_UNORM:
      return PIPE_FORMAT_AL1616_UNORM;
d143 1
a143 3
      return PIPE_FORMAT_LA88_SRGB;
   case MESA_FORMAT_A8L8_SRGB:
      return PIPE_FORMAT_AL88_SRGB;
d149 3
a151 1
      return PIPE_FORMAT_ABGR8888_SRGB;
d153 1
a153 5
      return PIPE_FORMAT_RGBA8888_SRGB;
   case MESA_FORMAT_B8G8R8A8_SRGB:
      return PIPE_FORMAT_BGRA8888_SRGB;
   case MESA_FORMAT_A8R8G8B8_SRGB:
      return PIPE_FORMAT_ARGB8888_SRGB;
d192 1
a192 3
      return PIPE_FORMAT_RG88_UNORM;
   case MESA_FORMAT_G8R8_UNORM:
      return PIPE_FORMAT_GR88_UNORM;
d194 1
a194 3
      return PIPE_FORMAT_RG1616_UNORM;
   case MESA_FORMAT_G16R16_UNORM:
      return PIPE_FORMAT_GR1616_UNORM;
a323 2
   /* The destination RGBA format mustn't be changed, because it's also
    * a destination format of the unpack/decompression function. */
d325 1
a325 10
      return st->has_etc1 ? PIPE_FORMAT_ETC1_RGB8 : PIPE_FORMAT_R8G8B8A8_UNORM;

   case MESA_FORMAT_BPTC_RGBA_UNORM:
      return PIPE_FORMAT_BPTC_RGBA_UNORM;
   case MESA_FORMAT_BPTC_SRGB_ALPHA_UNORM:
      return PIPE_FORMAT_BPTC_SRGBA;
   case MESA_FORMAT_BPTC_RGB_SIGNED_FLOAT:
      return PIPE_FORMAT_BPTC_RGB_FLOAT;
   case MESA_FORMAT_BPTC_RGB_UNSIGNED_FLOAT:
      return PIPE_FORMAT_BPTC_RGB_UFLOAT;
d331 1
a331 3
      return PIPE_FORMAT_RG88_SNORM;
   case MESA_FORMAT_G8R8_SNORM:
      return PIPE_FORMAT_GR88_SNORM;
d333 1
a333 3
      return PIPE_FORMAT_RGBA8888_SNORM;
   case MESA_FORMAT_A8B8G8R8_SNORM:
      return PIPE_FORMAT_ABGR8888_SNORM;
d340 1
a340 3
      return PIPE_FORMAT_LA88_SNORM;
   case MESA_FORMAT_A8L8_SNORM:
      return PIPE_FORMAT_AL88_SNORM;
d347 1
a347 3
      return PIPE_FORMAT_RG1616_SNORM;
   case MESA_FORMAT_G16R16_SNORM:
      return PIPE_FORMAT_GR1616_SNORM;
d374 1
a374 3
      return PIPE_FORMAT_RGBX8888_SNORM;
   case MESA_FORMAT_X8B8G8R8_SNORM:
      return PIPE_FORMAT_XBGR8888_SNORM;
d376 1
a376 3
      return PIPE_FORMAT_RGBX8888_SRGB;
   case MESA_FORMAT_X8B8G8R8_SRGB:
      return PIPE_FORMAT_XBGR8888_SRGB;
d401 1
a401 23
      return PIPE_FORMAT_BGRX8888_SRGB;
   case MESA_FORMAT_X8R8G8B8_SRGB:
      return PIPE_FORMAT_XRGB8888_SRGB;

   /* ETC2 formats are emulated as uncompressed ones.
    * The destination formats mustn't be changed, because they are also
    * destination formats of the unpack/decompression function. */
   case MESA_FORMAT_ETC2_RGB8:
   case MESA_FORMAT_ETC2_RGBA8_EAC:
   case MESA_FORMAT_ETC2_RGB8_PUNCHTHROUGH_ALPHA1:
      return PIPE_FORMAT_R8G8B8A8_UNORM;
   case MESA_FORMAT_ETC2_SRGB8:
   case MESA_FORMAT_ETC2_SRGB8_ALPHA8_EAC:
   case MESA_FORMAT_ETC2_SRGB8_PUNCHTHROUGH_ALPHA1:
      return PIPE_FORMAT_B8G8R8A8_SRGB;
   case MESA_FORMAT_ETC2_R11_EAC:
      return PIPE_FORMAT_R16_UNORM;
   case MESA_FORMAT_ETC2_RG11_EAC:
      return PIPE_FORMAT_R16G16_UNORM;
   case MESA_FORMAT_ETC2_SIGNED_R11_EAC:
      return PIPE_FORMAT_R16_SNORM;
   case MESA_FORMAT_ETC2_SIGNED_RG11_EAC:
      return PIPE_FORMAT_R16G16_SNORM;
a441 2
   case PIPE_FORMAT_R10G10B10A2_UNORM:
      return MESA_FORMAT_R10G10B10A2_UNORM;
d444 1
a444 1
   case PIPE_FORMAT_LA88_UNORM:
d446 1
a446 3
   case PIPE_FORMAT_AL88_UNORM:
      return MESA_FORMAT_A8L8_UNORM;
   case PIPE_FORMAT_LA1616_UNORM:
a447 2
   case PIPE_FORMAT_AL1616_UNORM:
      return MESA_FORMAT_A16L16_UNORM;
d504 1
a504 1
   case PIPE_FORMAT_LA88_SRGB:
a505 2
   case PIPE_FORMAT_AL88_SRGB:
      return MESA_FORMAT_A8L8_SRGB;
d510 1
a510 1
   case PIPE_FORMAT_ABGR8888_SRGB:
d512 1
a512 3
   case PIPE_FORMAT_RGBA8888_SRGB:
      return MESA_FORMAT_R8G8B8A8_SRGB;
   case PIPE_FORMAT_BGRA8888_SRGB:
a513 2
   case PIPE_FORMAT_ARGB8888_SRGB:
      return MESA_FORMAT_A8R8G8B8_SRGB;
d551 1
a551 1
   case PIPE_FORMAT_RG88_UNORM:
d553 1
a553 3
   case PIPE_FORMAT_GR88_UNORM:
      return MESA_FORMAT_G8R8_UNORM;
   case PIPE_FORMAT_RG1616_UNORM:
a554 2
   case PIPE_FORMAT_GR1616_UNORM:
      return MESA_FORMAT_G16R16_UNORM;
a683 9
   case PIPE_FORMAT_BPTC_RGBA_UNORM:
      return MESA_FORMAT_BPTC_RGBA_UNORM;
   case PIPE_FORMAT_BPTC_SRGBA:
      return MESA_FORMAT_BPTC_SRGB_ALPHA_UNORM;
   case PIPE_FORMAT_BPTC_RGB_FLOAT:
      return MESA_FORMAT_BPTC_RGB_SIGNED_FLOAT;
   case PIPE_FORMAT_BPTC_RGB_UFLOAT:
      return MESA_FORMAT_BPTC_RGB_UNSIGNED_FLOAT;

d687 1
a687 1
   case PIPE_FORMAT_RG88_SNORM:
d689 1
a689 3
   case PIPE_FORMAT_GR88_SNORM:
      return MESA_FORMAT_G8R8_SNORM;
   case PIPE_FORMAT_RGBA8888_SNORM:
a690 2
   case PIPE_FORMAT_ABGR8888_SNORM:
      return MESA_FORMAT_A8B8G8R8_SNORM;
d696 1
a696 1
   case PIPE_FORMAT_LA88_SNORM:
a697 2
   case PIPE_FORMAT_AL88_SNORM:
      return MESA_FORMAT_A8L8_SNORM;
d703 1
a703 1
   case PIPE_FORMAT_RG1616_SNORM:
a704 2
   case PIPE_FORMAT_GR1616_SNORM:
      return MESA_FORMAT_G16R16_SNORM;
d731 1
a731 1
   case PIPE_FORMAT_RGBX8888_SNORM:
d733 1
a733 3
   case PIPE_FORMAT_XBGR8888_SNORM:
      return MESA_FORMAT_X8B8G8R8_SNORM;
   case PIPE_FORMAT_RGBX8888_SRGB:
a734 2
   case PIPE_FORMAT_XBGR8888_SRGB:
      return MESA_FORMAT_X8B8G8R8_SRGB;
d758 1
a758 1
   case PIPE_FORMAT_BGRX8888_SRGB:
d760 2
a761 2
   case PIPE_FORMAT_XRGB8888_SRGB:
      return MESA_FORMAT_X8R8G8B8_SRGB;
d774 1
a774 1
test_format_conversion(struct st_context *st)
d780 1
a780 9
      enum pipe_format pf;

      /* ETC formats are translated differently, skip them. */
      if (_mesa_is_format_etc2(i))
         continue;
      if (i == MESA_FORMAT_ETC1_RGB8 && !st->has_etc1)
         continue;

      pf = st_mesa_format_to_pipe_format(st, i);
a789 5

      /* ETC formats are translated differently, skip them. */
      if (i == PIPE_FORMAT_ETC1_RGB8 && !st->has_etc1)
         continue;

d791 1
a791 1
         enum pipe_format pf = st_mesa_format_to_pipe_format(st, mf);
a824 1
      PIPE_FORMAT_R8G8B8A8_SRGB, \
d860 1
a860 2
      { PIPE_FORMAT_B10G10R10A2_UNORM, PIPE_FORMAT_R10G10B10A2_UNORM,
        DEFAULT_RGBA_FORMATS }
d864 1
a864 1
      { DEFAULT_RGBA_FORMATS }
d868 1
a868 1
      { DEFAULT_RGBA_FORMATS }
a1235 18
   /* BPTC */
   {
      { GL_COMPRESSED_RGBA_BPTC_UNORM, 0 },
      { PIPE_FORMAT_BPTC_RGBA_UNORM, 0 },
   },
   {
      { GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM, 0 },
      { PIPE_FORMAT_BPTC_SRGBA, 0 },
   },
   {
      { GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT, 0 },
      { PIPE_FORMAT_BPTC_RGB_FLOAT, 0 },
   },
   {
      { GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT, 0 },
      { PIPE_FORMAT_BPTC_RGB_UFLOAT, 0 },
   },

d1678 1
a1678 1
         test_format_conversion(st);
d1744 1
a1744 1
st_choose_matching_format(struct st_context *st, unsigned bind,
a1746 1
   struct pipe_screen *screen = st->pipe->screen;
d1762 1
a1762 2
         enum pipe_format format =
            st_mesa_format_to_pipe_format(st, mesa_format);
d1832 2
a1833 1
         pFormat = st_choose_matching_format(st, bindings, format, type,
d1840 2
a1841 1
         pFormat = st_choose_matching_format(st, PIPE_BIND_SAMPLER_VIEW,
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d57 1
a57 1
st_mesa_format_to_pipe_format(mesa_format mesaFormat)
d86 2
d91 3
a93 1
      return PIPE_FORMAT_L8A8_UNORM;
d95 3
a97 1
      return PIPE_FORMAT_L16A16_UNORM;
d149 3
a151 1
      return PIPE_FORMAT_L8A8_SRGB;
d157 3
a159 1
      return PIPE_FORMAT_A8B8G8R8_SRGB;
d161 3
a163 3
      return PIPE_FORMAT_B8G8R8A8_SRGB;
   case MESA_FORMAT_R8G8B8A8_SRGB:
      return PIPE_FORMAT_R8G8B8A8_SRGB;
d202 3
a204 1
      return PIPE_FORMAT_R8G8_UNORM;
d206 3
a208 1
      return PIPE_FORMAT_R16G16_UNORM;
d338 2
d341 10
a350 1
      return PIPE_FORMAT_ETC1_RGB8;
d356 3
a358 1
      return PIPE_FORMAT_R8G8_SNORM;
d360 3
a362 1
      return PIPE_FORMAT_R8G8B8A8_SNORM;
d369 3
a371 1
      return PIPE_FORMAT_L8A8_SNORM;
d378 3
a380 1
      return PIPE_FORMAT_R16G16_SNORM;
d407 3
a409 1
      return PIPE_FORMAT_R8G8B8X8_SNORM;
d411 3
a413 1
      return PIPE_FORMAT_R8G8B8X8_SRGB;
d438 23
a460 1
      return PIPE_FORMAT_B8G8R8X8_SRGB;
d501 2
d505 1
a505 1
   case PIPE_FORMAT_L8A8_UNORM:
d507 3
a509 1
   case PIPE_FORMAT_L16A16_UNORM:
d511 2
d569 1
a569 1
   case PIPE_FORMAT_L8A8_SRGB:
d571 2
d577 1
a577 1
   case PIPE_FORMAT_A8B8G8R8_SRGB:
d579 3
a581 1
   case PIPE_FORMAT_B8G8R8A8_SRGB:
d583 2
d622 1
a622 1
   case PIPE_FORMAT_R8G8_UNORM:
d624 3
a626 1
   case PIPE_FORMAT_R16G16_UNORM:
d628 2
d759 9
d771 1
a771 1
   case PIPE_FORMAT_R8G8_SNORM:
d773 3
a775 1
   case PIPE_FORMAT_R8G8B8A8_SNORM:
d777 2
d784 1
a784 1
   case PIPE_FORMAT_L8A8_SNORM:
d786 2
d793 1
a793 1
   case PIPE_FORMAT_R16G16_SNORM:
d795 2
d823 1
a823 1
   case PIPE_FORMAT_R8G8B8X8_SNORM:
d825 3
a827 1
   case PIPE_FORMAT_R8G8B8X8_SRGB:
d829 2
d854 1
a854 1
   case PIPE_FORMAT_B8G8R8X8_SRGB:
d856 2
a857 2
   case PIPE_FORMAT_R8G8B8A8_SRGB:
      return MESA_FORMAT_R8G8B8A8_SRGB;
d870 1
a870 1
test_format_conversion(void)
d876 9
a884 1
      enum pipe_format pf = st_mesa_format_to_pipe_format(i);
d894 5
d900 1
a900 1
         enum pipe_format pf = st_mesa_format_to_pipe_format(mf);
d934 1
d970 2
a971 1
      { PIPE_FORMAT_B10G10R10A2_UNORM, DEFAULT_RGBA_FORMATS }
d975 1
a975 1
      { PIPE_FORMAT_R8G8B8A8_UNORM, DEFAULT_RGBA_FORMATS }
d979 1
a979 1
      { PIPE_FORMAT_B8G8R8A8_UNORM, DEFAULT_RGBA_FORMATS }
d1347 18
d1807 1
a1807 1
         test_format_conversion();
d1873 1
a1873 1
st_choose_matching_format(struct pipe_screen *screen, unsigned bind,
d1876 1
d1892 2
a1893 1
         enum pipe_format format = st_mesa_format_to_pipe_format(mesa_format);
d1963 1
a1963 2
         pFormat = st_choose_matching_format(st->pipe->screen, bindings,
                                             format, type,
d1970 1
a1970 2
         pFormat = st_choose_matching_format(st->pipe->screen,
                                             PIPE_BIND_SAMPLER_VIEW,
@


