head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.06.41;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.47;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.20;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.10;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.13.16;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.50.22;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  *   Brian Paul
  */
 

#include "main/macros.h"
#include "main/mtypes.h"
#include "main/glformats.h"
#include "main/samplerobj.h"
#include "main/texobj.h"

#include "st_context.h"
#include "st_cb_texture.h"
#include "st_format.h"
#include "st_atom.h"
#include "st_texture.h"
#include "pipe/p_context.h"
#include "pipe/p_defines.h"

#include "cso_cache/cso_context.h"

#include "util/u_format.h"


/**
 * Convert GLenum texcoord wrap tokens to pipe tokens.
 */
static GLuint
gl_wrap_xlate(GLenum wrap)
{
   switch (wrap) {
   case GL_REPEAT:
      return PIPE_TEX_WRAP_REPEAT;
   case GL_CLAMP:
      return PIPE_TEX_WRAP_CLAMP;
   case GL_CLAMP_TO_EDGE:
      return PIPE_TEX_WRAP_CLAMP_TO_EDGE;
   case GL_CLAMP_TO_BORDER:
      return PIPE_TEX_WRAP_CLAMP_TO_BORDER;
   case GL_MIRRORED_REPEAT:
      return PIPE_TEX_WRAP_MIRROR_REPEAT;
   case GL_MIRROR_CLAMP_EXT:
      return PIPE_TEX_WRAP_MIRROR_CLAMP;
   case GL_MIRROR_CLAMP_TO_EDGE_EXT:
      return PIPE_TEX_WRAP_MIRROR_CLAMP_TO_EDGE;
   case GL_MIRROR_CLAMP_TO_BORDER_EXT:
      return PIPE_TEX_WRAP_MIRROR_CLAMP_TO_BORDER;
   default:
      assert(0);
      return 0;
   }
}


static GLuint
gl_filter_to_mip_filter(GLenum filter)
{
   switch (filter) {
   case GL_NEAREST:
   case GL_LINEAR:
      return PIPE_TEX_MIPFILTER_NONE;

   case GL_NEAREST_MIPMAP_NEAREST:
   case GL_LINEAR_MIPMAP_NEAREST:
      return PIPE_TEX_MIPFILTER_NEAREST;

   case GL_NEAREST_MIPMAP_LINEAR:
   case GL_LINEAR_MIPMAP_LINEAR:
      return PIPE_TEX_MIPFILTER_LINEAR;

   default:
      assert(0);
      return PIPE_TEX_MIPFILTER_NONE;
   }
}


static GLuint
gl_filter_to_img_filter(GLenum filter)
{
   switch (filter) {
   case GL_NEAREST:
   case GL_NEAREST_MIPMAP_NEAREST:
   case GL_NEAREST_MIPMAP_LINEAR:
      return PIPE_TEX_FILTER_NEAREST;

   case GL_LINEAR:
   case GL_LINEAR_MIPMAP_NEAREST:
   case GL_LINEAR_MIPMAP_LINEAR:
      return PIPE_TEX_FILTER_LINEAR;

   default:
      assert(0);
      return PIPE_TEX_FILTER_NEAREST;
   }
}


static void
convert_sampler(struct st_context *st,
                struct pipe_sampler_state *sampler,
                GLuint texUnit)
{
   const struct gl_texture_object *texobj;
   struct gl_context *ctx = st->ctx;
   struct gl_sampler_object *msamp;
   const struct gl_texture_image *teximg;
   GLenum texBaseFormat;

   texobj = ctx->Texture.Unit[texUnit]._Current;
   if (!texobj) {
      texobj = _mesa_get_fallback_texture(ctx, TEXTURE_2D_INDEX);
   }

   teximg = texobj->Image[0][texobj->BaseLevel];
   texBaseFormat = teximg ? teximg->_BaseFormat : GL_RGBA;

   msamp = _mesa_get_samplerobj(ctx, texUnit);

   memset(sampler, 0, sizeof(*sampler));
   sampler->wrap_s = gl_wrap_xlate(msamp->WrapS);
   sampler->wrap_t = gl_wrap_xlate(msamp->WrapT);
   sampler->wrap_r = gl_wrap_xlate(msamp->WrapR);

   sampler->min_img_filter = gl_filter_to_img_filter(msamp->MinFilter);
   sampler->min_mip_filter = gl_filter_to_mip_filter(msamp->MinFilter);
   sampler->mag_img_filter = gl_filter_to_img_filter(msamp->MagFilter);

   if (texobj->Target != GL_TEXTURE_RECTANGLE_ARB)
      sampler->normalized_coords = 1;

   sampler->lod_bias = ctx->Texture.Unit[texUnit].LodBias + msamp->LodBias;

   sampler->min_lod = CLAMP(msamp->MinLod,
                            0.0f,
                            (GLfloat) texobj->MaxLevel - texobj->BaseLevel);
   sampler->max_lod = MIN2((GLfloat) texobj->MaxLevel - texobj->BaseLevel,
                           msamp->MaxLod);
   if (sampler->max_lod < sampler->min_lod) {
      /* The GL spec doesn't seem to specify what to do in this case.
       * Swap the values.
       */
      float tmp = sampler->max_lod;
      sampler->max_lod = sampler->min_lod;
      sampler->min_lod = tmp;
      assert(sampler->min_lod <= sampler->max_lod);
   }

   /* For non-black borders... */
   if (msamp->BorderColor.ui[0] ||
       msamp->BorderColor.ui[1] ||
       msamp->BorderColor.ui[2] ||
       msamp->BorderColor.ui[3]) {
      const struct st_texture_object *stobj = st_texture_object_const(texobj);
      const GLboolean is_integer = texobj->_IsIntegerFormat;
      const struct pipe_sampler_view *sv = NULL;
      union pipe_color_union border_color;
      GLuint i;

      /* Just search for the first used view. We can do this because the
         swizzle is per-texture, not per context. */
      /* XXX: clean that up to not use the sampler view at all */
      for (i = 0; i < stobj->num_sampler_views; ++i) {
         if (stobj->sampler_views[i]) {
            sv = stobj->sampler_views[i];
            break;
         }
      }

      if (st->apply_texture_swizzle_to_border_color && sv) {
         const unsigned char swz[4] =
         {
            sv->swizzle_r,
            sv->swizzle_g,
            sv->swizzle_b,
            sv->swizzle_a,
         };

         st_translate_color(&msamp->BorderColor,
                            &border_color,
                            texBaseFormat, is_integer);

         util_format_apply_color_swizzle(&sampler->border_color,
                                         &border_color, swz, is_integer);
      } else {
         st_translate_color(&msamp->BorderColor,
                            &sampler->border_color,
                            texBaseFormat, is_integer);
      }
   }

   sampler->max_anisotropy = (msamp->MaxAnisotropy == 1.0 ?
                              0 : (GLuint) msamp->MaxAnisotropy);

   /* If sampling a depth texture and using shadow comparison */
   if ((texBaseFormat == GL_DEPTH_COMPONENT ||
        texBaseFormat == GL_DEPTH_STENCIL) &&
       msamp->CompareMode == GL_COMPARE_R_TO_TEXTURE) {
      sampler->compare_mode = PIPE_TEX_COMPARE_R_TO_TEXTURE;
      sampler->compare_func = st_compare_func_to_pipe(msamp->CompareFunc);
   }

   sampler->seamless_cube_map =
      ctx->Texture.CubeMapSeamless || msamp->CubeMapSeamless;
}


/**
 * Update the gallium driver's sampler state for fragment, vertex or
 * geometry shader stage.
 */
static void
update_shader_samplers(struct st_context *st,
                       unsigned shader_stage,
                       const struct gl_program *prog,
                       unsigned max_units,
                       struct pipe_sampler_state *samplers,
                       unsigned *num_samplers)
{
   GLuint unit;
   GLbitfield samplers_used;
   const GLuint old_max = *num_samplers;

   samplers_used = prog->SamplersUsed;

   if (*num_samplers == 0 && samplers_used == 0x0)
       return;

   *num_samplers = 0;

   /* loop over sampler units (aka tex image units) */
   for (unit = 0; unit < max_units; unit++, samplers_used >>= 1) {
      struct pipe_sampler_state *sampler = samplers + unit;

      if (samplers_used & 1) {
         const GLuint texUnit = prog->SamplerUnits[unit];

         convert_sampler(st, sampler, texUnit);

         *num_samplers = unit + 1;

         cso_single_sampler(st->cso_context, shader_stage, unit, sampler);
      }
      else if (samplers_used != 0 || unit < old_max) {
         cso_single_sampler(st->cso_context, shader_stage, unit, NULL);
      }
      else {
         /* if we've reset all the old samplers and we have no more new ones */
         break;
      }
   }

   cso_single_sampler_done(st->cso_context, shader_stage);
}


static void
update_samplers(struct st_context *st)
{
   const struct gl_context *ctx = st->ctx;

   update_shader_samplers(st,
                          PIPE_SHADER_FRAGMENT,
                          &ctx->FragmentProgram._Current->Base,
                          ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits,
                          st->state.samplers[PIPE_SHADER_FRAGMENT],
                          &st->state.num_samplers[PIPE_SHADER_FRAGMENT]);

   update_shader_samplers(st,
                          PIPE_SHADER_VERTEX,
                          &ctx->VertexProgram._Current->Base,
                          ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits,
                          st->state.samplers[PIPE_SHADER_VERTEX],
                          &st->state.num_samplers[PIPE_SHADER_VERTEX]);

   if (ctx->GeometryProgram._Current) {
      update_shader_samplers(st,
                             PIPE_SHADER_GEOMETRY,
                             &ctx->GeometryProgram._Current->Base,
                             ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxTextureImageUnits,
                             st->state.samplers[PIPE_SHADER_GEOMETRY],
                             &st->state.num_samplers[PIPE_SHADER_GEOMETRY]);
   }
}


const struct st_tracked_state st_update_sampler = {
   "st_update_sampler",					/* name */
   {							/* dirty */
      _NEW_TEXTURE,					/* mesa */
      0,						/* st */
   },
   update_samplers					/* update */
};
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d163 5
a167 2
   sampler->min_lod = MAX2(msamp->MinLod, 0.0f);
   sampler->max_lod = msamp->MaxLod;
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d163 2
a164 5
   sampler->min_lod = CLAMP(msamp->MinLod,
                            0.0f,
                            (GLfloat) texobj->MaxLevel - texobj->BaseLevel);
   sampler->max_lod = MIN2((GLfloat) texobj->MaxLevel - texobj->BaseLevel,
                           msamp->MaxLod);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d133 1
a133 1
   struct gl_texture_object *texobj;
d136 2
d144 3
d178 1
d183 3
a185 3
      struct st_texture_object *stobj = st_texture_object(texobj);
      struct gl_texture_image *teximg;
      GLboolean is_integer = GL_FALSE;
d187 1
d189 8
a196 4
      teximg = texobj->Image[0][texobj->BaseLevel];

      if (teximg) {
         is_integer = _mesa_is_enum_format_integer(teximg->InternalFormat);
d199 1
a199 1
      if (st->apply_texture_swizzle_to_border_color && stobj->sampler_view) {
d202 4
a205 4
            stobj->sampler_view->swizzle_r,
            stobj->sampler_view->swizzle_g,
            stobj->sampler_view->swizzle_b,
            stobj->sampler_view->swizzle_a,
d210 1
a210 1
                            teximg ? teximg->_BaseFormat : GL_RGBA, is_integer);
d217 1
a217 1
                            teximg ? teximg->_BaseFormat : GL_RGBA, is_integer);
d224 4
a227 2
   /* only care about ARB_shadow, not SGI shadow */
   if (msamp->CompareMode == GL_COMPARE_R_TO_TEXTURE) {
d229 1
a229 2
      sampler->compare_func
         = st_compare_func_to_pipe(msamp->CompareFunc);
d294 1
a294 1
                          ctx->Const.FragmentProgram.MaxTextureImageUnits,
d301 1
a301 1
                          ctx->Const.VertexProgram.MaxTextureImageUnits,
d309 1
a309 1
                             ctx->Const.GeometryProgram.MaxTextureImageUnits,
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d37 1
d39 1
d51 2
d139 1
a139 1
      texobj = st_get_default_texture(st);
d177 1
d179 2
d184 24
a207 3
      st_translate_color(msamp->BorderColor.f,
                         teximg ? teximg->_BaseFormat : GL_RGBA,
                         sampler->border_color);
d225 4
d230 6
a235 1
update_vertex_samplers(struct st_context *st)
d237 3
a239 16
   const struct gl_context *ctx = st->ctx;
   struct gl_vertex_program *vprog = ctx->VertexProgram._Current;
   GLuint su;

   st->state.num_vertex_samplers = 0;

   /* loop over sampler units (aka tex image units) */
   for (su = 0; su < ctx->Const.MaxVertexTextureImageUnits; su++) {
      struct pipe_sampler_state *sampler = st->state.vertex_samplers + su;

      if (vprog->Base.SamplersUsed & (1 << su)) {
	 GLuint texUnit;

	 texUnit = vprog->Base.SamplerUnits[su];

	 convert_sampler(st, sampler, texUnit);
d241 1
a241 1
	 st->state.num_vertex_samplers = su + 1;
d243 2
a244 7
	 cso_single_vertex_sampler(st->cso_context, su, sampler);
      } else {
	 cso_single_vertex_sampler(st->cso_context, su, NULL);
      }
   }
   cso_single_vertex_sampler_done(st->cso_context);
}
d246 1
a246 9

static void
update_fragment_samplers(struct st_context *st)
{
   const struct gl_context *ctx = st->ctx;
   struct gl_fragment_program *fprog = ctx->FragmentProgram._Current;
   GLuint su;

   st->state.num_samplers = 0;
d249 2
a250 2
   for (su = 0; su < ctx->Const.MaxTextureImageUnits; su++) {
      struct pipe_sampler_state *sampler = st->state.samplers + su;
d252 2
d255 1
a255 2
      if (fprog->Base.SamplersUsed & (1 << su)) {
         GLuint texUnit;
d257 1
a257 1
	 texUnit = fprog->Base.SamplerUnits[su];
d259 4
a262 6
	 convert_sampler(st, sampler, texUnit);

         st->state.num_samplers = su + 1;

         /*printf("%s su=%u non-null\n", __FUNCTION__, su);*/
         cso_single_sampler(st->cso_context, su, sampler);
d265 2
a266 2
         /*printf("%s su=%u null\n", __FUNCTION__, su);*/
         cso_single_sampler(st->cso_context, su, NULL);
d270 1
a270 1
   cso_single_sampler_done(st->cso_context);
d277 24
a300 2
    update_fragment_samplers(st);
    update_vertex_samplers(st);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d36 2
d43 1
d124 106
a229 2
static void 
update_samplers(struct st_context *st)
d231 2
a232 4
   struct gl_vertex_program *vprog = st->ctx->VertexProgram._Current;
   struct gl_fragment_program *fprog = st->ctx->FragmentProgram._Current;
   const GLbitfield samplersUsed = (vprog->Base.SamplersUsed |
                                    fprog->Base.SamplersUsed);
d238 1
a238 1
   for (su = 0; su < st->ctx->Const.MaxTextureImageUnits; su++) {
a240 1
      memset(sampler, 0, sizeof(*sampler));
d242 1
a242 3
      if (samplersUsed & (1 << su)) {
         struct gl_texture_object *texobj;
         struct gl_texture_image *teximg;
d245 3
a247 54
         if (fprog->Base.SamplersUsed & (1 << su))
            texUnit = fprog->Base.SamplerUnits[su];
         else
            texUnit = vprog->Base.SamplerUnits[su];

         texobj = st->ctx->Texture.Unit[texUnit]._Current;
         if (!texobj) {
            texobj = st_get_default_texture(st);
         }

         teximg = texobj->Image[0][texobj->BaseLevel];

         sampler->wrap_s = gl_wrap_xlate(texobj->WrapS);
         sampler->wrap_t = gl_wrap_xlate(texobj->WrapT);
         sampler->wrap_r = gl_wrap_xlate(texobj->WrapR);

         sampler->min_img_filter = gl_filter_to_img_filter(texobj->MinFilter);
         sampler->min_mip_filter = gl_filter_to_mip_filter(texobj->MinFilter);
         sampler->mag_img_filter = gl_filter_to_img_filter(texobj->MagFilter);

         if (texobj->Target != GL_TEXTURE_RECTANGLE_ARB)
            sampler->normalized_coords = 1;

         sampler->lod_bias = st->ctx->Texture.Unit[texUnit].LodBias +
            texobj->LodBias;

         sampler->min_lod = texobj->BaseLevel + texobj->MinLod;
         if (sampler->min_lod < texobj->BaseLevel)
            sampler->min_lod = texobj->BaseLevel;

         sampler->max_lod = MIN2((GLfloat) texobj->MaxLevel,
                                 (texobj->MaxLod + texobj->BaseLevel));
         if (sampler->max_lod < sampler->min_lod) {
            /* The GL spec doesn't seem to specify what to do in this case.
             * Swap the values.
             */
            float tmp = sampler->max_lod;
            sampler->max_lod = sampler->min_lod;
            sampler->min_lod = tmp;
            assert(sampler->min_lod <= sampler->max_lod);
         }

         st_translate_color(texobj->BorderColor.f,
                            teximg ? teximg->_BaseFormat : GL_RGBA,
                            sampler->border_color);

	 sampler->max_anisotropy = (texobj->MaxAnisotropy == 1.0 ? 0 : (GLuint)texobj->MaxAnisotropy);

         /* only care about ARB_shadow, not SGI shadow */
         if (texobj->CompareMode == GL_COMPARE_R_TO_TEXTURE) {
            sampler->compare_mode = PIPE_TEX_COMPARE_R_TO_TEXTURE;
            sampler->compare_func
               = st_compare_func_to_pipe(texobj->CompareFunc);
         }
a252 3
         if (su < st->ctx->Const.MaxVertexTextureImageUnits) {
            cso_single_vertex_sampler(st->cso_context, su, sampler);
         }
a256 3
         if (su < st->ctx->Const.MaxVertexTextureImageUnits) {
            cso_single_vertex_sampler(st->cso_context, su, NULL);
         }
d261 8
a268 3
   if (st->ctx->Const.MaxVertexTextureImageUnits > 0) {
      cso_single_vertex_sampler_done(st->cso_context);
   }
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d39 1
a120 31
static void
xlate_border_color(const GLfloat *colorIn, GLenum baseFormat, GLfloat *colorOut)
{
   switch (baseFormat) {
   case GL_RGB:
      colorOut[0] = colorIn[0];
      colorOut[1] = colorIn[1];
      colorOut[2] = colorIn[2];
      colorOut[3] = 1.0F;
      break;
   case GL_ALPHA:
      colorOut[0] = colorOut[1] = colorOut[2] = 0.0;
      colorOut[3] = colorIn[3];
      break;
   case GL_LUMINANCE:
      colorOut[0] = colorOut[1] = colorOut[2] = colorIn[0];
      colorOut[3] = 1.0;
      break;
   case GL_LUMINANCE_ALPHA:
      colorOut[0] = colorOut[1] = colorOut[2] = colorIn[0];
      colorOut[3] = colorIn[3];
      break;
   case GL_INTENSITY:
      colorOut[0] = colorOut[1] = colorOut[2] = colorOut[3] = colorIn[0];
      break;
   default:
      COPY_4V(colorOut, colorIn);
   }
}


d166 9
a174 4
         sampler->lod_bias = st->ctx->Texture.Unit[su].LodBias;
         sampler->min_lod = MAX2(0.0f, texobj->MinLod);
         sampler->max_lod = MIN2(texobj->MaxLevel - texobj->BaseLevel,
                                 texobj->MaxLod);
d185 1
a185 1
         xlate_border_color(texobj->BorderColor.f,
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a38 1
#include "st_format.h"
d120 31
d196 4
a199 9
         sampler->lod_bias = st->ctx->Texture.Unit[texUnit].LodBias +
            texobj->LodBias;

         sampler->min_lod = texobj->BaseLevel + texobj->MinLod;
         if (sampler->min_lod < texobj->BaseLevel)
            sampler->min_lod = texobj->BaseLevel;

         sampler->max_lod = MIN2((GLfloat) texobj->MaxLevel,
                                 (texobj->MaxLod + texobj->BaseLevel));
d210 1
a210 1
         st_translate_color(texobj->BorderColor.f,
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a35 4
#include "main/mtypes.h"
#include "main/glformats.h"
#include "main/samplerobj.h"
#include "main/texobj.h"
a40 1
#include "st_texture.h"
a45 2
#include "util/u_format.h"

d121 2
a122 108
static void
convert_sampler(struct st_context *st,
                struct pipe_sampler_state *sampler,
                GLuint texUnit)
{
   struct gl_texture_object *texobj;
   struct gl_context *ctx = st->ctx;
   struct gl_sampler_object *msamp;

   texobj = ctx->Texture.Unit[texUnit]._Current;
   if (!texobj) {
      texobj = _mesa_get_fallback_texture(ctx, TEXTURE_2D_INDEX);
   }

   msamp = _mesa_get_samplerobj(ctx, texUnit);

   memset(sampler, 0, sizeof(*sampler));
   sampler->wrap_s = gl_wrap_xlate(msamp->WrapS);
   sampler->wrap_t = gl_wrap_xlate(msamp->WrapT);
   sampler->wrap_r = gl_wrap_xlate(msamp->WrapR);

   sampler->min_img_filter = gl_filter_to_img_filter(msamp->MinFilter);
   sampler->min_mip_filter = gl_filter_to_mip_filter(msamp->MinFilter);
   sampler->mag_img_filter = gl_filter_to_img_filter(msamp->MagFilter);

   if (texobj->Target != GL_TEXTURE_RECTANGLE_ARB)
      sampler->normalized_coords = 1;

   sampler->lod_bias = ctx->Texture.Unit[texUnit].LodBias + msamp->LodBias;

   sampler->min_lod = CLAMP(msamp->MinLod,
                            0.0f,
                            (GLfloat) texobj->MaxLevel - texobj->BaseLevel);
   sampler->max_lod = MIN2((GLfloat) texobj->MaxLevel - texobj->BaseLevel,
                           msamp->MaxLod);
   if (sampler->max_lod < sampler->min_lod) {
      /* The GL spec doesn't seem to specify what to do in this case.
       * Swap the values.
       */
      float tmp = sampler->max_lod;
      sampler->max_lod = sampler->min_lod;
      sampler->min_lod = tmp;
      assert(sampler->min_lod <= sampler->max_lod);
   }

   if (msamp->BorderColor.ui[0] ||
       msamp->BorderColor.ui[1] ||
       msamp->BorderColor.ui[2] ||
       msamp->BorderColor.ui[3]) {
      struct st_texture_object *stobj = st_texture_object(texobj);
      struct gl_texture_image *teximg;
      GLboolean is_integer = GL_FALSE;
      union pipe_color_union border_color;

      teximg = texobj->Image[0][texobj->BaseLevel];

      if (teximg) {
         is_integer = _mesa_is_enum_format_integer(teximg->InternalFormat);
      }

      if (st->apply_texture_swizzle_to_border_color && stobj->sampler_view) {
         const unsigned char swz[4] =
         {
            stobj->sampler_view->swizzle_r,
            stobj->sampler_view->swizzle_g,
            stobj->sampler_view->swizzle_b,
            stobj->sampler_view->swizzle_a,
         };

         st_translate_color(&msamp->BorderColor,
                            &border_color,
                            teximg ? teximg->_BaseFormat : GL_RGBA, is_integer);

         util_format_apply_color_swizzle(&sampler->border_color,
                                         &border_color, swz, is_integer);
      } else {
         st_translate_color(&msamp->BorderColor,
                            &sampler->border_color,
                            teximg ? teximg->_BaseFormat : GL_RGBA, is_integer);
      }
   }

   sampler->max_anisotropy = (msamp->MaxAnisotropy == 1.0 ?
                              0 : (GLuint) msamp->MaxAnisotropy);

   /* only care about ARB_shadow, not SGI shadow */
   if (msamp->CompareMode == GL_COMPARE_R_TO_TEXTURE) {
      sampler->compare_mode = PIPE_TEX_COMPARE_R_TO_TEXTURE;
      sampler->compare_func
         = st_compare_func_to_pipe(msamp->CompareFunc);
   }

   sampler->seamless_cube_map =
      ctx->Texture.CubeMapSeamless || msamp->CubeMapSeamless;
}


/**
 * Update the gallium driver's sampler state for fragment, vertex or
 * geometry shader stage.
 */
static void
update_shader_samplers(struct st_context *st,
                       unsigned shader_stage,
                       const struct gl_program *prog,
                       unsigned max_units,
                       struct pipe_sampler_state *samplers,
                       unsigned *num_samplers)
d124 5
a128 5
   GLuint unit;
   GLbitfield samplers_used;
   const GLuint old_max = *num_samplers;

   samplers_used = prog->SamplersUsed;
d130 1
a130 4
   if (*num_samplers == 0 && samplers_used == 0x0)
       return;

   *num_samplers = 0;
d133 2
a134 5
   for (unit = 0; unit < max_units; unit++, samplers_used >>= 1) {
      struct pipe_sampler_state *sampler = samplers + unit;

      if (samplers_used & 1) {
         const GLuint texUnit = prog->SamplerUnits[unit];
d136 1
a136 1
         convert_sampler(st, sampler, texUnit);
d138 67
a204 6
         *num_samplers = unit + 1;

         cso_single_sampler(st->cso_context, shader_stage, unit, sampler);
      }
      else if (samplers_used != 0 || unit < old_max) {
         cso_single_sampler(st->cso_context, shader_stage, unit, NULL);
d207 5
a211 2
         /* if we've reset all the old samplers and we have no more new ones */
         break;
d215 3
a217 30
   cso_single_sampler_done(st->cso_context, shader_stage);
}


static void
update_samplers(struct st_context *st)
{
   const struct gl_context *ctx = st->ctx;

   update_shader_samplers(st,
                          PIPE_SHADER_FRAGMENT,
                          &ctx->FragmentProgram._Current->Base,
                          ctx->Const.FragmentProgram.MaxTextureImageUnits,
                          st->state.samplers[PIPE_SHADER_FRAGMENT],
                          &st->state.num_samplers[PIPE_SHADER_FRAGMENT]);

   update_shader_samplers(st,
                          PIPE_SHADER_VERTEX,
                          &ctx->VertexProgram._Current->Base,
                          ctx->Const.VertexProgram.MaxTextureImageUnits,
                          st->state.samplers[PIPE_SHADER_VERTEX],
                          &st->state.num_samplers[PIPE_SHADER_VERTEX]);

   if (ctx->GeometryProgram._Current) {
      update_shader_samplers(st,
                             PIPE_SHADER_GEOMETRY,
                             &ctx->GeometryProgram._Current->Base,
                             ctx->Const.GeometryProgram.MaxTextureImageUnits,
                             st->state.samplers[PIPE_SHADER_GEOMETRY],
                             &st->state.num_samplers[PIPE_SHADER_GEOMETRY]);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d30 1
a30 1
  *   Keith Whitwell <keithw@@vmware.com>
d133 1
a133 1
   const struct gl_texture_object *texobj;
a135 2
   const struct gl_texture_image *teximg;
   GLenum texBaseFormat;
a141 3
   teximg = texobj->Image[0][texobj->BaseLevel];
   texBaseFormat = teximg ? teximg->_BaseFormat : GL_RGBA;

a172 1
   /* For non-black borders... */
d177 3
a179 3
      const struct st_texture_object *stobj = st_texture_object_const(texobj);
      const GLboolean is_integer = texobj->_IsIntegerFormat;
      const struct pipe_sampler_view *sv = NULL;
a180 1
      GLuint i;
d182 4
a185 8
      /* Just search for the first used view. We can do this because the
         swizzle is per-texture, not per context. */
      /* XXX: clean that up to not use the sampler view at all */
      for (i = 0; i < stobj->num_sampler_views; ++i) {
         if (stobj->sampler_views[i]) {
            sv = stobj->sampler_views[i];
            break;
         }
d188 1
a188 1
      if (st->apply_texture_swizzle_to_border_color && sv) {
d191 4
a194 4
            sv->swizzle_r,
            sv->swizzle_g,
            sv->swizzle_b,
            sv->swizzle_a,
d199 1
a199 1
                            texBaseFormat, is_integer);
d206 1
a206 1
                            texBaseFormat, is_integer);
d213 2
a214 4
   /* If sampling a depth texture and using shadow comparison */
   if ((texBaseFormat == GL_DEPTH_COMPONENT ||
        texBaseFormat == GL_DEPTH_STENCIL) &&
       msamp->CompareMode == GL_COMPARE_R_TO_TEXTURE) {
d216 2
a217 1
      sampler->compare_func = st_compare_func_to_pipe(msamp->CompareFunc);
d282 1
a282 1
                          ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits,
d289 1
a289 1
                          ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits,
d297 1
a297 1
                             ctx->Const.Program[MESA_SHADER_GEOMETRY].MaxTextureImageUnits,
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d163 5
a167 2
   sampler->min_lod = MAX2(msamp->MinLod, 0.0f);
   sampler->max_lod = msamp->MaxLod;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d163 2
a164 5
   sampler->min_lod = CLAMP(msamp->MinLod,
                            0.0f,
                            (GLfloat) texobj->MaxLevel - texobj->BaseLevel);
   sampler->max_lod = MIN2((GLfloat) texobj->MaxLevel - texobj->BaseLevel,
                           msamp->MaxLod);
@


