head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.06.46;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.27;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.11;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.13.24;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.50.30;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include <stdio.h>

#include "st_context.h"
#include "st_format.h"
#include "st_texture.h"
#include "st_cb_fbo.h"
#include "main/enums.h"

#include "pipe/p_state.h"
#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "util/u_inlines.h"
#include "util/u_format.h"
#include "util/u_rect.h"
#include "util/u_math.h"
#include "util/u_memory.h"


#define DBG if(0) printf


/**
 * Allocate a new pipe_resource object
 * width0, height0, depth0 are the dimensions of the level 0 image
 * (the highest resolution).  last_level indicates how many mipmap levels
 * to allocate storage for.  For non-mipmapped textures, this will be zero.
 */
struct pipe_resource *
st_texture_create(struct st_context *st,
                  enum pipe_texture_target target,
		  enum pipe_format format,
		  GLuint last_level,
		  GLuint width0,
		  GLuint height0,
		  GLuint depth0,
                  GLuint layers,
                  GLuint nr_samples,
                  GLuint bind )
{
   struct pipe_resource pt, *newtex;
   struct pipe_screen *screen = st->pipe->screen;

   assert(target < PIPE_MAX_TEXTURE_TYPES);
   assert(width0 > 0);
   assert(height0 > 0);
   assert(depth0 > 0);
   if (target == PIPE_TEXTURE_CUBE)
      assert(layers == 6);

   DBG("%s target %d format %s last_level %d\n", __FUNCTION__,
       (int) target, util_format_name(format), last_level);

   assert(format);
   assert(screen->is_format_supported(screen, format, target, 0,
                                      PIPE_BIND_SAMPLER_VIEW));

   memset(&pt, 0, sizeof(pt));
   pt.target = target;
   pt.format = format;
   pt.last_level = last_level;
   pt.width0 = width0;
   pt.height0 = height0;
   pt.depth0 = depth0;
   pt.array_size = (target == PIPE_TEXTURE_CUBE ? 6 : layers);
   pt.usage = PIPE_USAGE_DEFAULT;
   pt.bind = bind;
   pt.flags = 0;
   pt.nr_samples = nr_samples;

   newtex = screen->resource_create(screen, &pt);

   assert(!newtex || pipe_is_referenced(&newtex->reference));

   return newtex;
}


/**
 * In OpenGL the number of 1D array texture layers is the "height" and
 * the number of 2D array texture layers is the "depth".  In Gallium the
 * number of layers in an array texture is a separate 'array_size' field.
 * This function converts dimensions from the former to the later.
 */
void
st_gl_texture_dims_to_pipe_dims(GLenum texture,
                                GLuint widthIn,
                                GLuint heightIn,
                                GLuint depthIn,
                                GLuint *widthOut,
                                GLuint *heightOut,
                                GLuint *depthOut,
                                GLuint *layersOut)
{
   switch (texture) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
      assert(heightIn == 1);
      assert(depthIn == 1);
      *widthOut = widthIn;
      *heightOut = 1;
      *depthOut = 1;
      *layersOut = 1;
      break;
   case GL_TEXTURE_1D_ARRAY:
   case GL_PROXY_TEXTURE_1D_ARRAY:
      assert(depthIn == 1);
      *widthOut = widthIn;
      *heightOut = 1;
      *depthOut = 1;
      *layersOut = heightIn;
      break;
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
   case GL_TEXTURE_RECTANGLE:
   case GL_PROXY_TEXTURE_RECTANGLE:
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE:
      assert(depthIn == 1);
      *widthOut = widthIn;
      *heightOut = heightIn;
      *depthOut = 1;
      *layersOut = 1;
      break;
   case GL_TEXTURE_CUBE_MAP:
   case GL_PROXY_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
      assert(depthIn == 1);
      *widthOut = widthIn;
      *heightOut = heightIn;
      *depthOut = 1;
      *layersOut = 6;
      break;
   case GL_TEXTURE_2D_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      *widthOut = widthIn;
      *heightOut = heightIn;
      *depthOut = 1;
      *layersOut = depthIn;
      break;
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
      *widthOut = widthIn;
      *heightOut = heightIn;
      *depthOut = 1;
      *layersOut = depthIn;
      break;
   default:
      assert(0 && "Unexpected texture in st_gl_texture_dims_to_pipe_dims()");
      /* fall-through */
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      *widthOut = widthIn;
      *heightOut = heightIn;
      *depthOut = depthIn;
      *layersOut = 1;
      break;
   }
}


/**
 * Check if a texture image can be pulled into a unified mipmap texture.
 */
GLboolean
st_texture_match_image(const struct pipe_resource *pt,
                       const struct gl_texture_image *image)
{
   GLuint ptWidth, ptHeight, ptDepth, ptLayers;

   /* Images with borders are never pulled into mipmap textures. 
    */
   if (image->Border) 
      return GL_FALSE;

   /* Check if this image's format matches the established texture's format.
    */
   if (st_mesa_format_to_pipe_format(image->TexFormat) != pt->format)
      return GL_FALSE;

   st_gl_texture_dims_to_pipe_dims(image->TexObject->Target,
                                   image->Width, image->Height, image->Depth,
                                   &ptWidth, &ptHeight, &ptDepth, &ptLayers);

   /* Test if this image's size matches what's expected in the
    * established texture.
    */
   if (ptWidth != u_minify(pt->width0, image->Level) ||
       ptHeight != u_minify(pt->height0, image->Level) ||
       ptDepth != u_minify(pt->depth0, image->Level) ||
       ptLayers != pt->array_size)
      return GL_FALSE;

   return GL_TRUE;
}


/**
 * Map a texture image and return the address for a particular 2D face/slice/
 * layer.  The stImage indicates the cube face and mipmap level.  The slice
 * of the 3D texture is passed in 'zoffset'.
 * \param usage  one of the PIPE_TRANSFER_x values
 * \param x, y, w, h  the region of interest of the 2D image.
 * \return address of mapping or NULL if any error
 */
GLubyte *
st_texture_image_map(struct st_context *st, struct st_texture_image *stImage,
                     enum pipe_transfer_usage usage,
                     GLuint x, GLuint y, GLuint z,
                     GLuint w, GLuint h, GLuint d,
                     struct pipe_transfer **transfer)
{
   struct st_texture_object *stObj =
      st_texture_object(stImage->base.TexObject);
   GLuint level;
   void *map;

   DBG("%s \n", __FUNCTION__);

   if (!stImage->pt)
      return NULL;

   if (stObj->pt != stImage->pt)
      level = 0;
   else
      level = stImage->base.Level;

   z += stImage->base.Face;

   map = pipe_transfer_map_3d(st->pipe, stImage->pt, level, usage,
                              x, y, z, w, h, d, transfer);
   if (map) {
      /* Enlarge the transfer array if it's not large enough. */
      if (z >= stImage->num_transfers) {
         unsigned new_size = z + 1;

         stImage->transfer = realloc(stImage->transfer,
                                     new_size * sizeof(void*));
         memset(&stImage->transfer[stImage->num_transfers], 0,
               (new_size - stImage->num_transfers) * sizeof(void*));
         stImage->num_transfers = new_size;
      }

      assert(!stImage->transfer[z]);
      stImage->transfer[z] = *transfer;
   }
   return map;
}


void
st_texture_image_unmap(struct st_context *st,
                       struct st_texture_image *stImage, unsigned slice)
{
   struct pipe_context *pipe = st->pipe;
   struct pipe_transfer **transfer =
      &stImage->transfer[slice + stImage->base.Face];

   DBG("%s\n", __FUNCTION__);

   pipe_transfer_unmap(pipe, *transfer);
   *transfer = NULL;
}


/* Upload data for a particular image.
 */
void
st_texture_image_data(struct st_context *st,
                      struct pipe_resource *dst,
                      GLuint face,
                      GLuint level,
                      void *src,
                      GLuint src_row_stride, GLuint src_image_stride)
{
   struct pipe_context *pipe = st->pipe;
   GLuint i;
   const GLubyte *srcUB = src;
   GLuint layers;

   if (dst->target == PIPE_TEXTURE_1D_ARRAY ||
       dst->target == PIPE_TEXTURE_2D_ARRAY ||
       dst->target == PIPE_TEXTURE_CUBE_ARRAY)
      layers = dst->array_size;
   else
      layers = u_minify(dst->depth0, level);

   DBG("%s\n", __FUNCTION__);

   for (i = 0; i < layers; i++) {
      struct pipe_box box;
      u_box_2d_zslice(0, 0, face + i,
                      u_minify(dst->width0, level),
                      u_minify(dst->height0, level),
                      &box);

      pipe->transfer_inline_write(pipe, dst, level, PIPE_TRANSFER_WRITE,
                                  &box, srcUB, src_row_stride, 0);

      srcUB += src_image_stride;
   }
}


/**
 * For debug only: get/print center pixel in the src resource.
 */
static void
print_center_pixel(struct pipe_context *pipe, struct pipe_resource *src)
{
   struct pipe_transfer *xfer;
   struct pipe_box region;
   ubyte *map;

   region.x = src->width0 / 2;
   region.y = src->height0 / 2;
   region.z = 0;
   region.width = 1;
   region.height = 1;
   region.depth = 1;

   map = pipe->transfer_map(pipe, src, 0, PIPE_TRANSFER_READ, &region, &xfer);

   printf("center pixel: %d %d %d %d\n", map[0], map[1], map[2], map[3]);

   pipe->transfer_unmap(pipe, xfer);
}


/**
 * Copy the image at level=0 in 'src' to the 'dst' resource at 'dstLevel'.
 * This is used to copy mipmap images from one texture buffer to another.
 * This typically happens when our initial guess at the total texture size
 * is incorrect (see the guess_and_alloc_texture() function).
 */
void
st_texture_image_copy(struct pipe_context *pipe,
                      struct pipe_resource *dst, GLuint dstLevel,
                      struct pipe_resource *src, GLuint srcLevel,
                      GLuint face)
{
   GLuint width = u_minify(dst->width0, dstLevel);
   GLuint height = u_minify(dst->height0, dstLevel);
   GLuint depth = u_minify(dst->depth0, dstLevel);
   struct pipe_box src_box;
   GLuint i;

   if (u_minify(src->width0, srcLevel) != width ||
       u_minify(src->height0, srcLevel) != height ||
       u_minify(src->depth0, srcLevel) != depth) {
      /* The source image size doesn't match the destination image size.
       * This can happen in some degenerate situations such as rendering to a
       * cube map face which was set up with mismatched texture sizes.
       */
      return;
   }

   src_box.x = 0;
   src_box.y = 0;
   src_box.width = width;
   src_box.height = height;
   src_box.depth = 1;
   /* Loop over 3D image slices */
   /* could (and probably should) use "true" 3d box here -
      but drivers can't quite handle it yet */
   for (i = face; i < face + depth; i++) {
      src_box.z = i;

      if (0)  {
         print_center_pixel(pipe, src);
      }

      pipe->resource_copy_region(pipe,
                                 dst,
                                 dstLevel,
                                 0, 0, i,/* destX, Y, Z */
                                 src,
                                 srcLevel,
                                 &src_box);
   }
}


struct pipe_resource *
st_create_color_map_texture(struct gl_context *ctx)
{
   struct st_context *st = st_context(ctx);
   struct pipe_resource *pt;
   enum pipe_format format;
   const uint texSize = 256; /* simple, and usually perfect */

   /* find an RGBA texture format */
   format = st_choose_format(st, GL_RGBA, GL_NONE, GL_NONE,
                             PIPE_TEXTURE_2D, 0, PIPE_BIND_SAMPLER_VIEW,
                             FALSE);

   /* create texture for color map/table */
   pt = st_texture_create(st, PIPE_TEXTURE_2D, format, 0,
                          texSize, texSize, 1, 1, 0, PIPE_BIND_SAMPLER_VIEW);
   return pt;
}

/**
 * Try to find a matching sampler view for the given context.
 * If none is found an empty slot is initialized with a
 * template and returned instead.
 */
struct pipe_sampler_view **
st_texture_get_sampler_view(struct st_context *st,
                            struct st_texture_object *stObj)
{
   struct pipe_sampler_view *used = NULL, **free = NULL;
   GLuint i;

   for (i = 0; i < stObj->num_sampler_views; ++i) {
      struct pipe_sampler_view **sv = &stObj->sampler_views[i];
      /* Is the array entry used ? */
      if (*sv) {
         /* Yes, check if it's the right one */
         if ((*sv)->context == st->pipe)
            return sv;

         /* Wasn't the right one, but remember it as template */
         used = *sv;
      } else {
         /* Found a free slot, remember that */
         free = sv;
      }
   }

   /* Couldn't find a slot for our context, create a new one */

   if (!free) {
      /* Haven't even found a free one, resize the array */
      GLuint old_size = stObj->num_sampler_views * sizeof(void *);
      GLuint new_size = old_size + sizeof(void *);
      stObj->sampler_views = REALLOC(stObj->sampler_views, old_size, new_size);
      free = &stObj->sampler_views[stObj->num_sampler_views++];
      *free = NULL;
   }

   /* Add just any sampler view to be used as a template */
   if (used)
      pipe_sampler_view_reference(free, used);

   return free;
}

void
st_texture_release_sampler_view(struct st_context *st,
                                struct st_texture_object *stObj)
{
   GLuint i;

   for (i = 0; i < stObj->num_sampler_views; ++i) {
      struct pipe_sampler_view **sv = &stObj->sampler_views[i];

      if (*sv && (*sv)->context == st->pipe) {
         pipe_sampler_view_reference(sv, NULL);
         break;
      }
   }
}

void
st_texture_release_all_sampler_views(struct st_texture_object *stObj)
{
   GLuint i;

   for (i = 0; i < stObj->num_sampler_views; ++i)
      pipe_sampler_view_reference(&stObj->sampler_views[i], NULL);
}


void
st_texture_free_sampler_views(struct st_texture_object *stObj)
{
   /* NOTE:
    * We use FREE() here to match REALLOC() above.  Both come from
    * u_memory.h, not imports.h.  If we mis-match MALLOC/FREE from
    * those two headers we can trash the heap.
    */
   FREE(stObj->sampler_views);
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d91 1
a91 1
   pt.array_size = layers;
d200 1
a200 2
st_texture_match_image(struct st_context *st,
                       const struct pipe_resource *pt,
d212 1
a212 1
   if (st_mesa_format_to_pipe_format(st, image->TexFormat) != pt->format)
a261 7
   if (stObj->base.Immutable) {
      level += stObj->base.MinLevel;
      z += stObj->base.MinLayer;
      if (stObj->pt->array_size > 1)
         d = MIN2(d, stObj->base.NumLayers);
   }

d272 1
a272 1
                     new_size * sizeof(struct st_texture_image_transfer));
d274 1
a274 2
                (new_size - stImage->num_transfers) *
                sizeof(struct st_texture_image_transfer));
d278 2
a279 2
      assert(!stImage->transfer[z].transfer);
      stImage->transfer[z].transfer = *transfer;
d290 2
a291 7
   struct st_texture_object *stObj =
      st_texture_object(stImage->base.TexObject);
   struct pipe_transfer **transfer;

   if (stObj->base.Immutable)
      slice += stObj->base.MinLayer;
   transfer = &stImage->transfer[slice + stImage->base.Face].transfer;
a396 8

   if (src->target == PIPE_TEXTURE_1D_ARRAY ||
       src->target == PIPE_TEXTURE_2D_ARRAY ||
       src->target == PIPE_TEXTURE_CUBE_ARRAY) {
      face = 0;
      depth = src->array_size;
   }

d500 1
a500 2
st_texture_release_all_sampler_views(struct st_context *st,
                                     struct st_texture_object *stObj)
a503 1
   /* XXX This should use sampler_views[i]->pipe, not st->pipe */
d505 1
a505 1
      pipe_sampler_view_release(st->pipe, &stObj->sampler_views[i]);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d91 1
a91 1
   pt.array_size = (target == PIPE_TEXTURE_CUBE ? 6 : layers);
d200 2
a201 1
st_texture_match_image(const struct pipe_resource *pt,
d213 1
a213 1
   if (st_mesa_format_to_pipe_format(image->TexFormat) != pt->format)
d263 7
d280 1
a280 1
                                     new_size * sizeof(void*));
d282 2
a283 1
               (new_size - stImage->num_transfers) * sizeof(void*));
d287 2
a288 2
      assert(!stImage->transfer[z]);
      stImage->transfer[z] = *transfer;
d299 7
a305 2
   struct pipe_transfer **transfer =
      &stImage->transfer[slice + stImage->base.Face];
d411 8
d522 2
a523 1
st_texture_release_all_sampler_views(struct st_texture_object *stObj)
d527 1
d529 1
a529 1
      pipe_sampler_view_reference(&stObj->sampler_views[i], NULL);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d43 1
d244 2
a245 1
                     GLuint w, GLuint h, GLuint d)
d250 1
d262 20
a281 3
   return pipe_transfer_map_3d(st->pipe, stImage->pt, level, usage,
                               x, y, z + stImage->base.Face,
                               w, h, d, &stImage->transfer);
d287 1
a287 1
                       struct st_texture_image *stImage)
d290 2
d295 2
a296 2
   pipe_transfer_unmap(pipe, stImage->transfer);
   stImage->transfer = NULL;
d437 82
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d63 1
d76 2
a77 3
   DBG("%s target %s format %s last_level %d\n", __FUNCTION__,
       _mesa_lookup_enum_by_nr(target),
       _mesa_lookup_enum_by_nr(format), last_level);
d94 1
d122 1
d131 1
d139 1
d141 4
d152 7
d166 10
d185 1
d200 1
a200 2
                       const struct gl_texture_image *image,
                       GLuint face, GLuint level)
d221 3
a223 3
   if (ptWidth != u_minify(pt->width0, level) ||
       ptHeight != u_minify(pt->height0, level) ||
       ptDepth != u_minify(pt->depth0, level) ||
d241 3
a243 2
                     GLuint zoffset, enum pipe_transfer_usage usage,
                     GLuint x, GLuint y, GLuint w, GLuint h)
d245 3
a247 2
   struct pipe_context *pipe = st->pipe;
   struct pipe_resource *pt = stImage->pt;
d251 2
a252 3
   stImage->transfer = pipe_get_transfer(st->pipe, pt, stImage->level,
                                         stImage->face + zoffset,
                                         usage, x, y, w, h);
d254 2
a255 2
   if (stImage->transfer)
      return pipe_transfer_map(pipe, stImage->transfer);
d257 5
a261 1
      return NULL;
d274 1
a274 33

   pipe->transfer_destroy(pipe, stImage->transfer);
}



/**
 * Upload data to a rectangular sub-region.  Lots of choices how to do this:
 *
 * - memcpy by span to current destination
 * - upload data as new buffer and blit
 *
 * Currently always memcpy.
 */
static void
st_surface_data(struct pipe_context *pipe,
		struct pipe_transfer *dst,
		unsigned dstx, unsigned dsty,
		const void *src, unsigned src_stride,
		unsigned srcx, unsigned srcy, unsigned width, unsigned height)
{
   void *map = pipe_transfer_map(pipe, dst);

   assert(dst->resource);
   util_copy_rect(map,
                  dst->resource->format,
                  dst->stride,
                  dstx, dsty, 
                  width, height, 
                  src, src_stride, 
                  srcx, srcy);

   pipe_transfer_unmap(pipe, dst);
a290 1
   struct pipe_transfer *dst_transfer;
d294 2
a295 1
       dst->target == PIPE_TEXTURE_2D_ARRAY)
d303 5
a307 12
      dst_transfer = pipe_get_transfer(st->pipe, dst, level, face + i,
                                       PIPE_TRANSFER_WRITE, 0, 0,
                                       u_minify(dst->width0, level),
                                       u_minify(dst->height0, level));

      st_surface_data(pipe, dst_transfer,
		      0, 0,                             /* dstx, dsty */
		      srcUB,
		      src_row_stride,
		      0, 0,                             /* source x, y */
		      u_minify(dst->width0, level),
                      u_minify(dst->height0, level));    /* width, height */
d309 2
a310 1
      pipe->transfer_destroy(pipe, dst_transfer);
d334 1
a334 2
   xfer = pipe->get_transfer(pipe, src, 0, PIPE_TRANSFER_READ, &region);
   map = pipe->transfer_map(pipe, xfer);
a338 1
   pipe->transfer_destroy(pipe, xfer);
d393 20
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d62 1
d72 2
d81 1
a81 1
                                      PIPE_BIND_SAMPLER_VIEW, 0));
d90 1
a90 1
   pt.array_size = (target == PIPE_TEXTURE_CUBE ? 6 : 1);
d104 66
d177 2
d189 4
d196 4
a199 3
   if (image->Width != u_minify(pt->width0, level) ||
       image->Height != u_minify(pt->height0, level) ||
       image->Depth != u_minify(pt->depth0, level))
a290 1
   GLuint depth = u_minify(dst->depth0, level);
d294 7
d304 1
a304 1
   for (i = 0; i < depth; i++) {
d369 10
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d28 2
a31 1
#include "st_public.h"
a33 1
#include "st_inlines.h"
a34 5
#include "main/texfetch.h"
#include "main/teximage.h"
#include "main/texobj.h"

#undef Elements  /* fix re-defined macro warning */
a46 18
#if 0
static GLenum
target_to_target(GLenum target)
{
   switch (target) {
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
      return GL_TEXTURE_CUBE_MAP_ARB;
   default:
      return target;
   }
}
#endif

d49 1
a49 1
 * Allocate a new pipe_texture object
d54 1
a54 1
struct pipe_texture *
d62 1
a62 1
                  GLuint usage )
d64 1
a64 1
   struct pipe_texture pt, *newtex;
d67 4
a70 1
   assert(target <= PIPE_TEXTURE_CUBE);
d77 2
a78 2
   assert(screen->is_format_supported(screen, format, target, 
                                      PIPE_TEXTURE_USAGE_SAMPLER, 0));
d87 4
a90 1
   pt.tex_usage = usage;
d92 1
a92 1
   newtex = screen->texture_create(screen, &pt);
d104 1
a104 1
st_texture_match_image(const struct pipe_texture *pt,
a129 36
#if 000
/* Although we use the image_offset[] array to store relative offsets
 * to cube faces, Mesa doesn't know anything about this and expects
 * each cube face to be treated as a separate image.
 *
 * These functions present that view to mesa:
 */
const GLuint *
st_texture_depth_offsets(struct pipe_texture *pt, GLuint level)
{
   static const GLuint zero = 0;

   if (pt->target != PIPE_TEXTURE_3D || pt->level[level].nr_images == 1)
      return &zero;
   else
      return pt->level[level].image_offset;
}


/**
 * Return the offset to the given mipmap texture image within the
 * texture memory buffer, in bytes.
 */
GLuint
st_texture_image_offset(const struct pipe_texture * pt,
                        GLuint face, GLuint level)
{
   if (pt->target == PIPE_TEXTURE_CUBE)
      return (pt->level[level].level_offset +
              pt->level[level].image_offset[face] * pt->cpp);
   else
      return pt->level[level].level_offset;
}
#endif


d131 6
a136 4
 * Map a teximage in a mipmap texture.
 * \param row_stride  returns row stride in bytes
 * \param image_stride  returns image stride in bytes (for 3D textures).
 * \return address of mapping
d140 1
a140 1
		     GLuint zoffset, enum pipe_transfer_usage usage,
d144 1
a144 2
   struct pipe_screen *screen = pipe->screen;
   struct pipe_texture *pt = stImage->pt;
d148 3
a150 3
   stImage->transfer = st_no_flush_get_tex_transfer(st, pt, stImage->face,
						    stImage->level, zoffset,
						    usage, x, y, w, h);
d153 1
a153 1
      return screen->transfer_map(screen, stImage->transfer);
d163 1
a163 1
   struct pipe_screen *screen = st->pipe->screen;
d167 1
a167 1
   screen->transfer_unmap(screen, stImage->transfer);
d169 1
a169 1
   screen->tex_transfer_destroy(stImage->transfer);
d189 1
a189 2
   struct pipe_screen *screen = pipe->screen;
   void *map = screen->transfer_map(screen, dst);
d191 1
a191 1
   assert(dst->texture);
d193 1
a193 1
                  dst->texture->format,
d200 1
a200 1
   screen->transfer_unmap(screen, dst);
d208 1
a208 1
                      struct pipe_texture *dst,
a214 1
   struct pipe_screen *screen = pipe->screen;
d223 4
a226 4
      dst_transfer = st_no_flush_get_tex_transfer(st, dst, face, level, i,
						  PIPE_TRANSFER_WRITE, 0, 0,
						  u_minify(dst->width0, level),
                                                  u_minify(dst->height0, level));
d234 1
a234 1
                      u_minify(dst->height0, level));      /* width, height */
d236 1
a236 1
      screen->tex_transfer_destroy(dst_transfer);
a242 73
/* Copy mipmap image between textures
 */
void
st_texture_image_copy(struct pipe_context *pipe,
                      struct pipe_texture *dst, GLuint dstLevel,
                      struct pipe_texture *src,
                      GLuint face)
{
   struct pipe_screen *screen = pipe->screen;
   GLuint width = u_minify(dst->width0, dstLevel); 
   GLuint height = u_minify(dst->height0, dstLevel); 
   GLuint depth = u_minify(dst->depth0, dstLevel); 
   struct pipe_surface *src_surface;
   struct pipe_surface *dst_surface;
   GLuint i;

   for (i = 0; i < depth; i++) {
      GLuint srcLevel;

      /* find src texture level of needed size */
      for (srcLevel = 0; srcLevel <= src->last_level; srcLevel++) {
         if (u_minify(src->width0, srcLevel) == width &&
             u_minify(src->height0, srcLevel) == height) {
            break;
         }
      }
      assert(u_minify(src->width0, srcLevel) == width);
      assert(u_minify(src->height0, srcLevel) == height);

#if 0
      {
         src_surface = screen->get_tex_surface(screen, src, face, srcLevel, i,
                                               PIPE_BUFFER_USAGE_CPU_READ);
         ubyte *map = screen->surface_map(screen, src_surface, PIPE_BUFFER_USAGE_CPU_READ);
         map += src_surface->width * src_surface->height * 4 / 2;
         printf("%s center pixel: %d %d %d %d (pt %p[%d] -> %p[%d])\n",
                __FUNCTION__,
                map[0], map[1], map[2], map[3],
                src, srcLevel, dst, dstLevel);

         screen->surface_unmap(screen, src_surface);
         pipe_surface_reference(&src_surface, NULL);
      }
#endif

      dst_surface = screen->get_tex_surface(screen, dst, face, dstLevel, i,
                                            PIPE_BUFFER_USAGE_GPU_WRITE);

      src_surface = screen->get_tex_surface(screen, src, face, srcLevel, i,
                                            PIPE_BUFFER_USAGE_GPU_READ);

      if (pipe->surface_copy) {
         pipe->surface_copy(pipe,
			    dst_surface,
			    0, 0, /* destX, Y */
			    src_surface,
			    0, 0, /* srcX, Y */
			    width, height);
      } else {
         util_surface_copy(pipe, FALSE,
			   dst_surface,
			   0, 0, /* destX, Y */
			   src_surface,
			   0, 0, /* srcX, Y */
			   width, height);
      }

      pipe_surface_reference(&src_surface, NULL);
      pipe_surface_reference(&dst_surface, NULL);
   }
}


d244 1
a244 11
 * Bind a pipe surface to a texture object.  After the call,
 * the texture object is marked dirty and will be (re-)validated.
 *
 * If this is the first surface bound, the texture object is said to
 * switch from normal to surface based.  It will be cleared first in
 * this case.
 *
 * \param ps      pipe surface to be unbound
 * \param target  texture target
 * \param level   image level
 * \param format  internal format of the texture
d246 2
a247 3
int
st_bind_texture_surface(struct pipe_surface *ps, int target, int level,
                        enum pipe_format format)
d249 10
a258 28
   GET_CURRENT_CONTEXT(ctx);
   const GLuint unit = ctx->Texture.CurrentUnit;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   struct st_texture_object *stObj;
   struct st_texture_image *stImage;
   GLenum internalFormat;

   switch (target) {
   case ST_TEXTURE_2D:
      target = GL_TEXTURE_2D;
      break;
   case ST_TEXTURE_RECT:
      target = GL_TEXTURE_RECTANGLE_ARB;
      break;
   default:
      return 0;
   }

   /* map pipe format to base format for now */
   if (util_format_get_component_bits(format, UTIL_FORMAT_COLORSPACE_RGB, 3) > 0)
      internalFormat = GL_RGBA;
   else
      internalFormat = GL_RGB;

   texObj = _mesa_select_tex_object(ctx, texUnit, target);
   _mesa_lock_texture(ctx, texObj);
d260 2
a261 6
   stObj = st_texture_object(texObj);
   /* switch to surface based */
   if (!stObj->surface_based) {
      _mesa_clear_texture_object(ctx, texObj);
      stObj->surface_based = GL_TRUE;
   }
d263 1
a263 2
   texImage = _mesa_get_tex_image(ctx, texObj, target, level);
   stImage = st_texture_image(texImage);
d265 2
a266 11
   _mesa_init_teximage_fields(ctx, target, texImage,
                              ps->width, ps->height, 1, 0, internalFormat);
   texImage->TexFormat = st_ChooseTextureFormat(ctx, internalFormat,
                                                GL_RGBA, GL_UNSIGNED_BYTE);
   _mesa_set_fetch_functions(texImage, 2);
   pipe_texture_reference(&stImage->pt, ps->texture);

   _mesa_dirty_texobj(ctx, texObj, GL_TRUE);
   _mesa_unlock_texture(ctx, texObj);
   
   return 1;
d271 4
a274 6
 * Unbind a pipe surface from a texture object.  After the call,
 * the texture object is marked dirty and will be (re-)validated.
 *
 * \param ps      pipe surface to be unbound
 * \param target  texture target
 * \param level   image level
d276 5
a280 2
int
st_unbind_texture_surface(struct pipe_surface *ps, int target, int level)
d282 5
a286 18
   GET_CURRENT_CONTEXT(ctx);
   const GLuint unit = ctx->Texture.CurrentUnit;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   struct st_texture_object *stObj;
   struct st_texture_image *stImage;

   switch (target) {
   case ST_TEXTURE_2D:
      target = GL_TEXTURE_2D;
      break;
   case ST_TEXTURE_RECT:
      target = GL_TEXTURE_RECTANGLE_ARB;
      break;
   default:
      return 0;
   }
d288 10
a297 1
   texObj = _mesa_select_tex_object(ctx, texUnit, target);
d299 3
a301 11
   _mesa_lock_texture(ctx, texObj);

   texImage = _mesa_get_tex_image(ctx, texObj, target, level);
   stObj = st_texture_object(texObj);
   stImage = st_texture_image(texImage);

   /* Make sure the pipe surface is still bound.  The texture object is still
    * considered surface based even if this is the last bound surface. */
   if (stImage->pt == ps->texture) {
      pipe_texture_reference(&stImage->pt, NULL);
      _mesa_clear_texture_image(ctx, texImage);
d303 7
a309 1
      _mesa_dirty_texobj(ctx, texObj, GL_TRUE);
a310 4

   _mesa_unlock_texture(ctx, texObj);
   
   return 1;
a312 103

/** Redirect rendering into stfb's surface to a texture image */
int
st_bind_teximage(struct st_framebuffer *stfb, uint surfIndex,
                 int target, int format, int level)
{
   GET_CURRENT_CONTEXT(ctx);
   struct st_context *st = ctx->st;
   struct pipe_context *pipe = st->pipe;
   struct pipe_screen *screen = pipe->screen;
   const GLuint unit = ctx->Texture.CurrentUnit;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   struct st_texture_image *stImage;
   struct st_renderbuffer *strb;
   GLint face = 0, slice = 0;

   assert(surfIndex <= ST_SURFACE_DEPTH);

   strb = st_renderbuffer(stfb->Base.Attachment[surfIndex].Renderbuffer);

   if (strb->texture_save || strb->surface_save) {
      /* Error! */
      return 0;
   }

   if (target == ST_TEXTURE_2D) {
      texObj = texUnit->CurrentTex[TEXTURE_2D_INDEX];
      texImage = _mesa_get_tex_image(ctx, texObj, GL_TEXTURE_2D, level);
      stImage = st_texture_image(texImage);
   }
   else {
      /* unsupported target */
      return 0;
   }

   st_flush(ctx->st, PIPE_FLUSH_RENDER_CACHE, NULL);

   /* save the renderbuffer's surface/texture info */
   pipe_texture_reference(&strb->texture_save, strb->texture);
   pipe_surface_reference(&strb->surface_save, strb->surface);

   /* plug in new surface/texture info */
   pipe_texture_reference(&strb->texture, stImage->pt);
   strb->surface = screen->get_tex_surface(screen, strb->texture,
                                           face, level, slice,
                                           (PIPE_BUFFER_USAGE_GPU_READ |
                                            PIPE_BUFFER_USAGE_GPU_WRITE));

   st->dirty.st |= ST_NEW_FRAMEBUFFER;

   return 1;
}


/** Undo surface-to-texture binding */
int
st_release_teximage(struct st_framebuffer *stfb, uint surfIndex,
                    int target, int format, int level)
{
   GET_CURRENT_CONTEXT(ctx);
   struct st_context *st = ctx->st;
   struct st_renderbuffer *strb;

   assert(surfIndex <= ST_SURFACE_DEPTH);

   strb = st_renderbuffer(stfb->Base.Attachment[surfIndex].Renderbuffer);

   if (!strb->texture_save || !strb->surface_save) {
      /* Error! */
      return 0;
   }

   st_flush(ctx->st, PIPE_FLUSH_RENDER_CACHE, NULL);

   /* free tex surface, restore original */
   pipe_surface_reference(&strb->surface, strb->surface_save);
   pipe_texture_reference(&strb->texture, strb->texture_save);

   pipe_surface_reference(&strb->surface_save, NULL);
   pipe_texture_reference(&strb->texture_save, NULL);

   st->dirty.st |= ST_NEW_FRAMEBUFFER;

   return 1;
}

void
st_teximage_flush_before_map(struct st_context *st,
			     struct pipe_texture *pt,
			     unsigned int face,
			     unsigned int level,
			     enum pipe_transfer_usage usage)
{
   struct pipe_context *pipe = st->pipe;
   unsigned referenced =
      pipe->is_texture_referenced(pipe, pt, face, level);

   if (referenced && ((referenced & PIPE_REFERENCED_FOR_WRITE) ||
		      (usage & PIPE_TRANSFER_WRITE)))
      st->pipe->flush(st->pipe, PIPE_FLUSH_RENDER_CACHE, NULL);
}
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a27 2
#include <stdio.h>

d30 1
d33 1
d35 5
d52 18
d72 1
a72 1
 * Allocate a new pipe_resource object
d77 1
a77 1
struct pipe_resource *
d85 1
a85 1
                  GLuint bind )
d87 1
a87 1
   struct pipe_resource pt, *newtex;
d90 1
a90 4
   assert(target < PIPE_MAX_TEXTURE_TYPES);
   assert(width0 > 0);
   assert(height0 > 0);
   assert(depth0 > 0);
d97 2
a98 2
   assert(screen->is_format_supported(screen, format, target, 0,
                                      PIPE_BIND_SAMPLER_VIEW, 0));
d107 1
a107 4
   pt.array_size = (target == PIPE_TEXTURE_CUBE ? 6 : 1);
   pt.usage = PIPE_USAGE_DEFAULT;
   pt.bind = bind;
   pt.flags = 0;
d109 1
a109 1
   newtex = screen->resource_create(screen, &pt);
d121 1
a121 1
st_texture_match_image(const struct pipe_resource *pt,
d147 36
d184 4
a187 6
 * Map a texture image and return the address for a particular 2D face/slice/
 * layer.  The stImage indicates the cube face and mipmap level.  The slice
 * of the 3D texture is passed in 'zoffset'.
 * \param usage  one of the PIPE_TRANSFER_x values
 * \param x, y, w, h  the region of interest of the 2D image.
 * \return address of mapping or NULL if any error
d191 1
a191 1
                     GLuint zoffset, enum pipe_transfer_usage usage,
d195 2
a196 1
   struct pipe_resource *pt = stImage->pt;
d200 3
a202 3
   stImage->transfer = pipe_get_transfer(st->pipe, pt, stImage->level,
                                         stImage->face + zoffset,
                                         usage, x, y, w, h);
d205 1
a205 1
      return pipe_transfer_map(pipe, stImage->transfer);
d215 1
a215 1
   struct pipe_context *pipe = st->pipe;
d219 1
a219 1
   pipe_transfer_unmap(pipe, stImage->transfer);
d221 1
a221 1
   pipe->transfer_destroy(pipe, stImage->transfer);
d241 2
a242 1
   void *map = pipe_transfer_map(pipe, dst);
d244 1
a244 1
   assert(dst->resource);
d246 1
a246 1
                  dst->resource->format,
d253 1
a253 1
   pipe_transfer_unmap(pipe, dst);
d261 1
a261 1
                      struct pipe_resource *dst,
d268 1
d277 4
a280 4
      dst_transfer = pipe_get_transfer(st->pipe, dst, level, face + i,
                                       PIPE_TRANSFER_WRITE, 0, 0,
                                       u_minify(dst->width0, level),
                                       u_minify(dst->height0, level));
d288 1
a288 1
                      u_minify(dst->height0, level));    /* width, height */
d290 1
a290 1
      pipe->transfer_destroy(pipe, dst_transfer);
d297 73
d371 11
a381 1
 * For debug only: get/print center pixel in the src resource.
d383 3
a385 2
static void
print_center_pixel(struct pipe_context *pipe, struct pipe_resource *src)
d387 28
a414 10
   struct pipe_transfer *xfer;
   struct pipe_box region;
   ubyte *map;

   region.x = src->width0 / 2;
   region.y = src->height0 / 2;
   region.z = 0;
   region.width = 1;
   region.height = 1;
   region.depth = 1;
d416 6
a421 2
   xfer = pipe->get_transfer(pipe, src, 0, PIPE_TRANSFER_READ, &region);
   map = pipe->transfer_map(pipe, xfer);
d423 2
a424 1
   printf("center pixel: %d %d %d %d\n", map[0], map[1], map[2], map[3]);
d426 11
a436 2
   pipe->transfer_unmap(pipe, xfer);
   pipe->transfer_destroy(pipe, xfer);
d441 6
a446 4
 * Copy the image at level=0 in 'src' to the 'dst' resource at 'dstLevel'.
 * This is used to copy mipmap images from one texture buffer to another.
 * This typically happens when our initial guess at the total texture size
 * is incorrect (see the guess_and_alloc_texture() function).
d448 104
a551 5
void
st_texture_image_copy(struct pipe_context *pipe,
                      struct pipe_resource *dst, GLuint dstLevel,
                      struct pipe_resource *src, GLuint srcLevel,
                      GLuint face)
d553 3
a555 5
   GLuint width = u_minify(dst->width0, dstLevel);
   GLuint height = u_minify(dst->height0, dstLevel);
   GLuint depth = u_minify(dst->depth0, dstLevel);
   struct pipe_box src_box;
   GLuint i;
d557 1
a557 10
   src_box.x = 0;
   src_box.y = 0;
   src_box.width = width;
   src_box.height = height;
   src_box.depth = 1;
   /* Loop over 3D image slices */
   /* could (and probably should) use "true" 3d box here -
      but drivers can't quite handle it yet */
   for (i = face; i < face + depth; i++) {
      src_box.z = i;
d559 1
a559 3
      if (0)  {
         print_center_pixel(pipe, src);
      }
d561 3
a563 7
      pipe->resource_copy_region(pipe,
                                 dst,
                                 dstLevel,
                                 0, 0, i,/* destX, Y, Z */
                                 src,
                                 srcLevel,
                                 &src_box);
d565 13
d580 15
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a61 2
                  GLuint layers,
                  GLuint nr_samples,
a70 2
   if (target == PIPE_TEXTURE_CUBE)
      assert(layers == 6);
d72 3
a74 2
   DBG("%s target %d format %s last_level %d\n", __FUNCTION__,
       (int) target, util_format_name(format), last_level);
d78 1
a78 1
                                      PIPE_BIND_SAMPLER_VIEW));
d87 1
a87 1
   pt.array_size = (target == PIPE_TEXTURE_CUBE ? 6 : layers);
a90 1
   pt.nr_samples = nr_samples;
a100 91
 * In OpenGL the number of 1D array texture layers is the "height" and
 * the number of 2D array texture layers is the "depth".  In Gallium the
 * number of layers in an array texture is a separate 'array_size' field.
 * This function converts dimensions from the former to the later.
 */
void
st_gl_texture_dims_to_pipe_dims(GLenum texture,
                                GLuint widthIn,
                                GLuint heightIn,
                                GLuint depthIn,
                                GLuint *widthOut,
                                GLuint *heightOut,
                                GLuint *depthOut,
                                GLuint *layersOut)
{
   switch (texture) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
      assert(heightIn == 1);
      assert(depthIn == 1);
      *widthOut = widthIn;
      *heightOut = 1;
      *depthOut = 1;
      *layersOut = 1;
      break;
   case GL_TEXTURE_1D_ARRAY:
   case GL_PROXY_TEXTURE_1D_ARRAY:
      assert(depthIn == 1);
      *widthOut = widthIn;
      *heightOut = 1;
      *depthOut = 1;
      *layersOut = heightIn;
      break;
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
   case GL_TEXTURE_RECTANGLE:
   case GL_PROXY_TEXTURE_RECTANGLE:
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE:
      assert(depthIn == 1);
      *widthOut = widthIn;
      *heightOut = heightIn;
      *depthOut = 1;
      *layersOut = 1;
      break;
   case GL_TEXTURE_CUBE_MAP:
   case GL_PROXY_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
      assert(depthIn == 1);
      *widthOut = widthIn;
      *heightOut = heightIn;
      *depthOut = 1;
      *layersOut = 6;
      break;
   case GL_TEXTURE_2D_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_PROXY_TEXTURE_2D_ARRAY:
   case GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY:
      *widthOut = widthIn;
      *heightOut = heightIn;
      *depthOut = 1;
      *layersOut = depthIn;
      break;
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
      *widthOut = widthIn;
      *heightOut = heightIn;
      *depthOut = 1;
      *layersOut = depthIn;
      break;
   default:
      assert(0 && "Unexpected texture in st_gl_texture_dims_to_pipe_dims()");
      /* fall-through */
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      *widthOut = widthIn;
      *heightOut = heightIn;
      *depthOut = depthIn;
      *layersOut = 1;
      break;
   }
}


/**
d105 2
a106 1
                       const struct gl_texture_image *image)
a107 2
   GLuint ptWidth, ptHeight, ptDepth, ptLayers;

a117 4
   st_gl_texture_dims_to_pipe_dims(image->TexObject->Target,
                                   image->Width, image->Height, image->Depth,
                                   &ptWidth, &ptHeight, &ptDepth, &ptLayers);

d121 3
a123 4
   if (ptWidth != u_minify(pt->width0, image->Level) ||
       ptHeight != u_minify(pt->height0, image->Level) ||
       ptDepth != u_minify(pt->depth0, image->Level) ||
       ptLayers != pt->array_size)
d140 2
a141 3
                     enum pipe_transfer_usage usage,
                     GLuint x, GLuint y, GLuint z,
                     GLuint w, GLuint h, GLuint d)
d143 2
a144 3
   struct st_texture_object *stObj =
      st_texture_object(stImage->base.TexObject);
   GLuint level;
d148 3
a150 2
   if (!stImage->pt)
      return NULL;
d152 2
a153 2
   if (stObj->pt != stImage->pt)
      level = 0;
d155 1
a155 5
      level = stImage->base.Level;

   return pipe_transfer_map_3d(st->pipe, stImage->pt, level, usage,
                               x, y, z + stImage->base.Face,
                               w, h, d, &stImage->transfer);
d168 33
a200 1
   stImage->transfer = NULL;
d215 1
d218 1
a218 8
   GLuint layers;

   if (dst->target == PIPE_TEXTURE_1D_ARRAY ||
       dst->target == PIPE_TEXTURE_2D_ARRAY ||
       dst->target == PIPE_TEXTURE_CUBE_ARRAY)
      layers = dst->array_size;
   else
      layers = u_minify(dst->depth0, level);
d222 13
a234 6
   for (i = 0; i < layers; i++) {
      struct pipe_box box;
      u_box_2d_zslice(0, 0, face + i,
                      u_minify(dst->width0, level),
                      u_minify(dst->height0, level),
                      &box);
d236 1
a236 2
      pipe->transfer_inline_write(pipe, dst, level, PIPE_TRANSFER_WRITE,
                                  &box, srcUB, src_row_stride, 0);
d260 2
a261 1
   map = pipe->transfer_map(pipe, src, 0, PIPE_TRANSFER_READ, &region, &xfer);
d266 1
a287 10
   if (u_minify(src->width0, srcLevel) != width ||
       u_minify(src->height0, srcLevel) != height ||
       u_minify(src->depth0, srcLevel) != depth) {
      /* The source image size doesn't match the destination image size.
       * This can happen in some degenerate situations such as rendering to a
       * cube map face which was set up with mismatched texture sizes.
       */
      return;
   }

a310 20
}


struct pipe_resource *
st_create_color_map_texture(struct gl_context *ctx)
{
   struct st_context *st = st_context(ctx);
   struct pipe_resource *pt;
   enum pipe_format format;
   const uint texSize = 256; /* simple, and usually perfect */

   /* find an RGBA texture format */
   format = st_choose_format(st, GL_RGBA, GL_NONE, GL_NONE,
                             PIPE_TEXTURE_2D, 0, PIPE_BIND_SAMPLER_VIEW,
                             FALSE);

   /* create texture for color map/table */
   pt = st_texture_create(st, PIPE_TEXTURE_2D, format, 0,
                          texSize, texSize, 1, 1, 0, PIPE_BIND_SAMPLER_VIEW);
   return pt;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a42 1
#include "util/u_memory.h"
d243 1
a243 2
                     GLuint w, GLuint h, GLuint d,
                     struct pipe_transfer **transfer)
a247 1
   void *map;
d259 3
a261 20
   z += stImage->base.Face;

   map = pipe_transfer_map_3d(st->pipe, stImage->pt, level, usage,
                              x, y, z, w, h, d, transfer);
   if (map) {
      /* Enlarge the transfer array if it's not large enough. */
      if (z >= stImage->num_transfers) {
         unsigned new_size = z + 1;

         stImage->transfer = realloc(stImage->transfer,
                                     new_size * sizeof(void*));
         memset(&stImage->transfer[stImage->num_transfers], 0,
               (new_size - stImage->num_transfers) * sizeof(void*));
         stImage->num_transfers = new_size;
      }

      assert(!stImage->transfer[z]);
      stImage->transfer[z] = *transfer;
   }
   return map;
d267 1
a267 1
                       struct st_texture_image *stImage, unsigned slice)
a269 2
   struct pipe_transfer **transfer =
      &stImage->transfer[slice + stImage->base.Face];
d273 2
a274 2
   pipe_transfer_unmap(pipe, *transfer);
   *transfer = NULL;
a414 82
/**
 * Try to find a matching sampler view for the given context.
 * If none is found an empty slot is initialized with a
 * template and returned instead.
 */
struct pipe_sampler_view **
st_texture_get_sampler_view(struct st_context *st,
                            struct st_texture_object *stObj)
{
   struct pipe_sampler_view *used = NULL, **free = NULL;
   GLuint i;

   for (i = 0; i < stObj->num_sampler_views; ++i) {
      struct pipe_sampler_view **sv = &stObj->sampler_views[i];
      /* Is the array entry used ? */
      if (*sv) {
         /* Yes, check if it's the right one */
         if ((*sv)->context == st->pipe)
            return sv;

         /* Wasn't the right one, but remember it as template */
         used = *sv;
      } else {
         /* Found a free slot, remember that */
         free = sv;
      }
   }

   /* Couldn't find a slot for our context, create a new one */

   if (!free) {
      /* Haven't even found a free one, resize the array */
      GLuint old_size = stObj->num_sampler_views * sizeof(void *);
      GLuint new_size = old_size + sizeof(void *);
      stObj->sampler_views = REALLOC(stObj->sampler_views, old_size, new_size);
      free = &stObj->sampler_views[stObj->num_sampler_views++];
      *free = NULL;
   }

   /* Add just any sampler view to be used as a template */
   if (used)
      pipe_sampler_view_reference(free, used);

   return free;
}

void
st_texture_release_sampler_view(struct st_context *st,
                                struct st_texture_object *stObj)
{
   GLuint i;

   for (i = 0; i < stObj->num_sampler_views; ++i) {
      struct pipe_sampler_view **sv = &stObj->sampler_views[i];

      if (*sv && (*sv)->context == st->pipe) {
         pipe_sampler_view_reference(sv, NULL);
         break;
      }
   }
}

void
st_texture_release_all_sampler_views(struct st_texture_object *stObj)
{
   GLuint i;

   for (i = 0; i < stObj->num_sampler_views; ++i)
      pipe_sampler_view_reference(&stObj->sampler_views[i], NULL);
}


void
st_texture_free_sampler_views(struct st_texture_object *stObj)
{
   /* NOTE:
    * We use FREE() here to match REALLOC() above.  Both come from
    * u_memory.h, not imports.h.  If we mis-match MALLOC/FREE from
    * those two headers we can trash the heap.
    */
   FREE(stObj->sampler_views);
}
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d91 1
a91 1
   pt.array_size = layers;
d200 1
a200 2
st_texture_match_image(struct st_context *st,
                       const struct pipe_resource *pt,
d212 1
a212 1
   if (st_mesa_format_to_pipe_format(st, image->TexFormat) != pt->format)
a261 7
   if (stObj->base.Immutable) {
      level += stObj->base.MinLevel;
      z += stObj->base.MinLayer;
      if (stObj->pt->array_size > 1)
         d = MIN2(d, stObj->base.NumLayers);
   }

d272 1
a272 1
                     new_size * sizeof(struct st_texture_image_transfer));
d274 1
a274 2
                (new_size - stImage->num_transfers) *
                sizeof(struct st_texture_image_transfer));
d278 2
a279 2
      assert(!stImage->transfer[z].transfer);
      stImage->transfer[z].transfer = *transfer;
d290 2
a291 7
   struct st_texture_object *stObj =
      st_texture_object(stImage->base.TexObject);
   struct pipe_transfer **transfer;

   if (stObj->base.Immutable)
      slice += stObj->base.MinLayer;
   transfer = &stImage->transfer[slice + stImage->base.Face].transfer;
a396 8

   if (src->target == PIPE_TEXTURE_1D_ARRAY ||
       src->target == PIPE_TEXTURE_2D_ARRAY ||
       src->target == PIPE_TEXTURE_CUBE_ARRAY) {
      face = 0;
      depth = src->array_size;
   }

d500 1
a500 2
st_texture_release_all_sampler_views(struct st_context *st,
                                     struct st_texture_object *stObj)
a503 1
   /* XXX This should use sampler_views[i]->pipe, not st->pipe */
d505 1
a505 1
      pipe_sampler_view_release(st->pipe, &stObj->sampler_views[i]);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d91 1
a91 1
   pt.array_size = (target == PIPE_TEXTURE_CUBE ? 6 : layers);
d200 2
a201 1
st_texture_match_image(const struct pipe_resource *pt,
d213 1
a213 1
   if (st_mesa_format_to_pipe_format(image->TexFormat) != pt->format)
d263 7
d280 1
a280 1
                                     new_size * sizeof(void*));
d282 2
a283 1
               (new_size - stImage->num_transfers) * sizeof(void*));
d287 2
a288 2
      assert(!stImage->transfer[z]);
      stImage->transfer[z] = *transfer;
d299 7
a305 2
   struct pipe_transfer **transfer =
      &stImage->transfer[slice + stImage->base.Face];
d411 8
d522 2
a523 1
st_texture_release_all_sampler_views(struct st_texture_object *stObj)
d527 1
d529 1
a529 1
      pipe_sampler_view_reference(&stObj->sampler_views[i], NULL);
@


