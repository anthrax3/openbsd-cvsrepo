head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.54;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.22;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.09.01;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.06.43;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.20;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.45;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.48;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.17.21;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.35.10;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.13.18;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.50.24;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2007 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

 /*
  * Authors:
  *   Brian Paul
  */

#include "main/imports.h"
#include "main/image.h"
#include "main/bufferobj.h"
#include "main/format_pack.h"
#include "main/macros.h"
#include "main/mtypes.h"
#include "main/pack.h"
#include "main/pbo.h"
#include "main/readpix.h"
#include "main/texformat.h"
#include "main/teximage.h"
#include "main/texstore.h"
#include "main/glformats.h"
#include "program/program.h"
#include "program/prog_print.h"
#include "program/prog_instruction.h"

#include "st_atom.h"
#include "st_atom_constbuf.h"
#include "st_cb_drawpixels.h"
#include "st_cb_readpixels.h"
#include "st_cb_fbo.h"
#include "st_context.h"
#include "st_debug.h"
#include "st_format.h"
#include "st_program.h"
#include "st_texture.h"

#include "pipe/p_context.h"
#include "pipe/p_defines.h"
#include "tgsi/tgsi_ureg.h"
#include "util/u_draw_quad.h"
#include "util/u_format.h"
#include "util/u_inlines.h"
#include "util/u_math.h"
#include "util/u_tile.h"
#include "util/u_upload_mgr.h"
#include "cso_cache/cso_context.h"


/**
 * Check if the given program is:
 * 0: MOVE result.color, fragment.color;
 * 1: END;
 */
static GLboolean
is_passthrough_program(const struct gl_fragment_program *prog)
{
   if (prog->Base.NumInstructions == 2) {
      const struct prog_instruction *inst = prog->Base.Instructions;
      if (inst[0].Opcode == OPCODE_MOV &&
          inst[1].Opcode == OPCODE_END &&
          inst[0].DstReg.File == PROGRAM_OUTPUT &&
          inst[0].DstReg.Index == FRAG_RESULT_COLOR &&
          inst[0].DstReg.WriteMask == WRITEMASK_XYZW &&
          inst[0].SrcReg[0].File == PROGRAM_INPUT &&
          inst[0].SrcReg[0].Index == VARYING_SLOT_COL0 &&
          inst[0].SrcReg[0].Swizzle == SWIZZLE_XYZW) {
         return GL_TRUE;
      }
   }
   return GL_FALSE;
}


/**
 * Returns a fragment program which implements the current pixel transfer ops.
 */
static struct gl_fragment_program *
get_glsl_pixel_transfer_program(struct st_context *st,
                                struct st_fragment_program *orig)
{
   int pixelMaps = 0, scaleAndBias = 0;
   struct gl_context *ctx = st->ctx;
   struct st_fragment_program *fp = (struct st_fragment_program *)
      ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 0);

   if (!fp)
      return NULL;

   if (ctx->Pixel.RedBias != 0.0 || ctx->Pixel.RedScale != 1.0 ||
       ctx->Pixel.GreenBias != 0.0 || ctx->Pixel.GreenScale != 1.0 ||
       ctx->Pixel.BlueBias != 0.0 || ctx->Pixel.BlueScale != 1.0 ||
       ctx->Pixel.AlphaBias != 0.0 || ctx->Pixel.AlphaScale != 1.0) {
      scaleAndBias = 1;
   }

   pixelMaps = ctx->Pixel.MapColorFlag;

   if (pixelMaps) {
      /* create the colormap/texture now if not already done */
      if (!st->pixel_xfer.pixelmap_texture) {
         st->pixel_xfer.pixelmap_texture = st_create_color_map_texture(ctx);
         st->pixel_xfer.pixelmap_sampler_view =
            st_create_texture_sampler_view(st->pipe,
                                           st->pixel_xfer.pixelmap_texture);
      }
   }

   get_pixel_transfer_visitor(fp, orig->glsl_to_tgsi,
                              scaleAndBias, pixelMaps);

   return &fp->Base;
}


/**
 * Make fragment shader for glDraw/CopyPixels.  This shader is made
 * by combining the pixel transfer shader with the user-defined shader.
 * \param fpIn  the current/incoming fragment program
 * \param fpOut  returns the combined fragment program
 */
void
st_make_drawpix_fragment_program(struct st_context *st,
                                 struct gl_fragment_program *fpIn,
                                 struct gl_fragment_program **fpOut)
{
   struct gl_program *newProg;
   struct st_fragment_program *stfp = (struct st_fragment_program *) fpIn;

   if (is_passthrough_program(fpIn)) {
      newProg = (struct gl_program *) _mesa_clone_fragment_program(st->ctx,
                                             &st->pixel_xfer.program->Base);
   }
   else if (stfp->glsl_to_tgsi != NULL) {
      newProg = (struct gl_program *) get_glsl_pixel_transfer_program(st, stfp);
   }
   else {
#if 0
      /* debug */
      printf("Base program:\n");
      _mesa_print_program(&fpIn->Base);
      printf("DrawPix program:\n");
      _mesa_print_program(&st->pixel_xfer.program->Base.Base);
#endif
      newProg = _mesa_combine_programs(st->ctx,
                                       &st->pixel_xfer.program->Base.Base,
                                       &fpIn->Base);
   }

#if 0
   /* debug */
   printf("Combined DrawPixels program:\n");
   _mesa_print_program(newProg);
   printf("InputsRead: 0x%x\n", newProg->InputsRead);
   printf("OutputsWritten: 0x%x\n", newProg->OutputsWritten);
   _mesa_print_parameter_list(newProg->Parameters);
#endif

   *fpOut = (struct gl_fragment_program *) newProg;
}


/**
 * Create fragment program that does a TEX() instruction to get a Z and/or
 * stencil value value, then writes to FRAG_RESULT_DEPTH/FRAG_RESULT_STENCIL.
 * Used for glDrawPixels(GL_DEPTH_COMPONENT / GL_STENCIL_INDEX).
 * Pass fragment color through as-is.
 * \return pointer to the gl_fragment program
 */
struct gl_fragment_program *
st_make_drawpix_z_stencil_program(struct st_context *st,
                                  GLboolean write_depth,
                                  GLboolean write_stencil)
{
   struct gl_context *ctx = st->ctx;
   struct gl_program *p;
   struct gl_fragment_program *fp;
   GLuint ic = 0;
   const GLuint shaderIndex = write_depth * 2 + write_stencil;

   assert(shaderIndex < Elements(st->drawpix.shaders));

   if (st->drawpix.shaders[shaderIndex]) {
      /* already have the proper shader */
      return st->drawpix.shaders[shaderIndex];
   }

   /*
    * Create shader now
    */
   p = ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 0);
   if (!p)
      return NULL;

   p->NumInstructions = write_depth ? 3 : 1;
   p->NumInstructions += write_stencil ? 1 : 0;

   p->Instructions = _mesa_alloc_instructions(p->NumInstructions);
   if (!p->Instructions) {
      ctx->Driver.DeleteProgram(ctx, p);
      return NULL;
   }
   _mesa_init_instructions(p->Instructions, p->NumInstructions);

   if (write_depth) {
      /* TEX result.depth, fragment.texcoord[0], texture[0], 2D; */
      p->Instructions[ic].Opcode = OPCODE_TEX;
      p->Instructions[ic].DstReg.File = PROGRAM_OUTPUT;
      p->Instructions[ic].DstReg.Index = FRAG_RESULT_DEPTH;
      p->Instructions[ic].DstReg.WriteMask = WRITEMASK_Z;
      p->Instructions[ic].SrcReg[0].File = PROGRAM_INPUT;
      p->Instructions[ic].SrcReg[0].Index = VARYING_SLOT_TEX0;
      p->Instructions[ic].TexSrcUnit = 0;
      p->Instructions[ic].TexSrcTarget = TEXTURE_2D_INDEX;
      ic++;
      /* MOV result.color, fragment.color; */
      p->Instructions[ic].Opcode = OPCODE_MOV;
      p->Instructions[ic].DstReg.File = PROGRAM_OUTPUT;
      p->Instructions[ic].DstReg.Index = FRAG_RESULT_COLOR;
      p->Instructions[ic].SrcReg[0].File = PROGRAM_INPUT;
      p->Instructions[ic].SrcReg[0].Index = VARYING_SLOT_COL0;
      ic++;
   }

   if (write_stencil) {
      /* TEX result.stencil, fragment.texcoord[0], texture[0], 2D; */
      p->Instructions[ic].Opcode = OPCODE_TEX;
      p->Instructions[ic].DstReg.File = PROGRAM_OUTPUT;
      p->Instructions[ic].DstReg.Index = FRAG_RESULT_STENCIL;
      p->Instructions[ic].DstReg.WriteMask = WRITEMASK_Y;
      p->Instructions[ic].SrcReg[0].File = PROGRAM_INPUT;
      p->Instructions[ic].SrcReg[0].Index = VARYING_SLOT_TEX0;
      p->Instructions[ic].TexSrcUnit = 1;
      p->Instructions[ic].TexSrcTarget = TEXTURE_2D_INDEX;
      ic++;
   }

   /* END; */
   p->Instructions[ic++].Opcode = OPCODE_END;

   assert(ic == p->NumInstructions);

   p->InputsRead = VARYING_BIT_TEX0 | VARYING_BIT_COL0;
   p->OutputsWritten = 0;
   if (write_depth) {
      p->OutputsWritten |= BITFIELD64_BIT(FRAG_RESULT_DEPTH);
      p->OutputsWritten |= BITFIELD64_BIT(FRAG_RESULT_COLOR);
   }
   if (write_stencil)
      p->OutputsWritten |= BITFIELD64_BIT(FRAG_RESULT_STENCIL);

   p->SamplersUsed =  0x1;  /* sampler 0 (bit 0) is used */
   if (write_stencil)
      p->SamplersUsed |= 1 << 1;

   fp = (struct gl_fragment_program *) p;

   /* save the new shader */
   st->drawpix.shaders[shaderIndex] = fp;

   return fp;
}


/**
 * Create a simple vertex shader that just passes through the
 * vertex position and texcoord (and optionally, color).
 */
static void *
make_passthrough_vertex_shader(struct st_context *st, 
                               GLboolean passColor)
{
   const unsigned texcoord_semantic = st->needs_texcoord_semantic ?
      TGSI_SEMANTIC_TEXCOORD : TGSI_SEMANTIC_GENERIC;

   if (!st->drawpix.vert_shaders[passColor]) {
      struct ureg_program *ureg = ureg_create( TGSI_PROCESSOR_VERTEX );

      if (ureg == NULL)
         return NULL;

      /* MOV result.pos, vertex.pos; */
      ureg_MOV(ureg, 
               ureg_DECL_output( ureg, TGSI_SEMANTIC_POSITION, 0 ),
               ureg_DECL_vs_input( ureg, 0 ));
      
      /* MOV result.texcoord0, vertex.attr[1]; */
      ureg_MOV(ureg, 
               ureg_DECL_output( ureg, texcoord_semantic, 0 ),
               ureg_DECL_vs_input( ureg, 1 ));
      
      if (passColor) {
         /* MOV result.color0, vertex.attr[2]; */
         ureg_MOV(ureg, 
                  ureg_DECL_output( ureg, TGSI_SEMANTIC_COLOR, 0 ),
                  ureg_DECL_vs_input( ureg, 2 ));
      }

      ureg_END( ureg );
      
      st->drawpix.vert_shaders[passColor] = 
         ureg_create_shader_and_destroy( ureg, st->pipe );
   }

   return st->drawpix.vert_shaders[passColor];
}


/**
 * Return a texture internalFormat for drawing/copying an image
 * of the given format and type.
 */
static GLenum
internal_format(struct gl_context *ctx, GLenum format, GLenum type)
{
   switch (format) {
   case GL_DEPTH_COMPONENT:
      switch (type) {
      case GL_UNSIGNED_SHORT:
         return GL_DEPTH_COMPONENT16;

      case GL_UNSIGNED_INT:
         return GL_DEPTH_COMPONENT32;

      case GL_FLOAT:
         if (ctx->Extensions.ARB_depth_buffer_float)
            return GL_DEPTH_COMPONENT32F;
         else
            return GL_DEPTH_COMPONENT;

      default:
         return GL_DEPTH_COMPONENT;
      }

   case GL_DEPTH_STENCIL:
      switch (type) {
      case GL_FLOAT_32_UNSIGNED_INT_24_8_REV:
         return GL_DEPTH32F_STENCIL8;

      case GL_UNSIGNED_INT_24_8:
      default:
         return GL_DEPTH24_STENCIL8;
      }

   case GL_STENCIL_INDEX:
      return GL_STENCIL_INDEX;

   default:
      if (_mesa_is_enum_format_integer(format)) {
         switch (type) {
         case GL_BYTE:
            return GL_RGBA8I;
         case GL_UNSIGNED_BYTE:
            return GL_RGBA8UI;
         case GL_SHORT:
            return GL_RGBA16I;
         case GL_UNSIGNED_SHORT:
            return GL_RGBA16UI;
         case GL_INT:
            return GL_RGBA32I;
         case GL_UNSIGNED_INT:
            return GL_RGBA32UI;
         default:
            assert(0 && "Unexpected type in internal_format()");
            return GL_RGBA_INTEGER;
         }
      }
      else {
         switch (type) {
         case GL_UNSIGNED_BYTE:
         case GL_UNSIGNED_INT_8_8_8_8:
         case GL_UNSIGNED_INT_8_8_8_8_REV:
         default:
            return GL_RGBA8;

         case GL_UNSIGNED_BYTE_3_3_2:
         case GL_UNSIGNED_BYTE_2_3_3_REV:
            return GL_R3_G3_B2;

         case GL_UNSIGNED_SHORT_4_4_4_4:
         case GL_UNSIGNED_SHORT_4_4_4_4_REV:
            return GL_RGBA4;

         case GL_UNSIGNED_SHORT_5_6_5:
         case GL_UNSIGNED_SHORT_5_6_5_REV:
            return GL_RGB565;

         case GL_UNSIGNED_SHORT_5_5_5_1:
         case GL_UNSIGNED_SHORT_1_5_5_5_REV:
            return GL_RGB5_A1;

         case GL_UNSIGNED_INT_10_10_10_2:
         case GL_UNSIGNED_INT_2_10_10_10_REV:
            return GL_RGB10_A2;

         case GL_UNSIGNED_SHORT:
         case GL_UNSIGNED_INT:
            return GL_RGBA16;

         case GL_BYTE:
            return
               ctx->Extensions.EXT_texture_snorm ? GL_RGBA8_SNORM : GL_RGBA8;

         case GL_SHORT:
         case GL_INT:
            return
               ctx->Extensions.EXT_texture_snorm ? GL_RGBA16_SNORM : GL_RGBA16;

         case GL_HALF_FLOAT_ARB:
            return
               ctx->Extensions.ARB_texture_float ? GL_RGBA16F :
               ctx->Extensions.EXT_texture_snorm ? GL_RGBA16_SNORM : GL_RGBA16;

         case GL_FLOAT:
         case GL_DOUBLE:
            return
               ctx->Extensions.ARB_texture_float ? GL_RGBA32F :
               ctx->Extensions.EXT_texture_snorm ? GL_RGBA16_SNORM : GL_RGBA16;

         case GL_UNSIGNED_INT_5_9_9_9_REV:
            assert(ctx->Extensions.EXT_texture_shared_exponent);
            return GL_RGB9_E5;

         case GL_UNSIGNED_INT_10F_11F_11F_REV:
            assert(ctx->Extensions.EXT_packed_float);
            return GL_R11F_G11F_B10F;
         }
      }
   }
}


/**
 * Create a temporary texture to hold an image of the given size.
 * If width, height are not POT and the driver only handles POT textures,
 * allocate the next larger size of texture that is POT.
 */
static struct pipe_resource *
alloc_texture(struct st_context *st, GLsizei width, GLsizei height,
              enum pipe_format texFormat, unsigned bind)
{
   struct pipe_resource *pt;

   pt = st_texture_create(st, st->internal_target, texFormat, 0,
                          width, height, 1, 1, 0, bind);

   return pt;
}


/**
 * Make texture containing an image for glDrawPixels image.
 * If 'pixels' is NULL, leave the texture image data undefined.
 */
static struct pipe_resource *
make_texture(struct st_context *st,
	     GLsizei width, GLsizei height, GLenum format, GLenum type,
	     const struct gl_pixelstore_attrib *unpack,
	     const GLvoid *pixels)
{
   struct gl_context *ctx = st->ctx;
   struct pipe_context *pipe = st->pipe;
   mesa_format mformat;
   struct pipe_resource *pt;
   enum pipe_format pipeFormat;
   GLenum baseInternalFormat;

   /* Choose a pixel format for the temp texture which will hold the
    * image to draw.
    */
   pipeFormat = st_choose_matching_format(pipe->screen, PIPE_BIND_SAMPLER_VIEW,
                                          format, type, unpack->SwapBytes);

   if (pipeFormat != PIPE_FORMAT_NONE) {
      mformat = st_pipe_format_to_mesa_format(pipeFormat);
      baseInternalFormat = _mesa_get_format_base_format(mformat);
   }
   else {
      /* Use the generic approach. */
      GLenum intFormat = internal_format(ctx, format, type);

      baseInternalFormat = _mesa_base_tex_format(ctx, intFormat);
      pipeFormat = st_choose_format(st, intFormat, format, type,
                                    PIPE_TEXTURE_2D, 0, PIPE_BIND_SAMPLER_VIEW,
                                    FALSE);
      assert(pipeFormat != PIPE_FORMAT_NONE);
      mformat = st_pipe_format_to_mesa_format(pipeFormat);
   }

   pixels = _mesa_map_pbo_source(ctx, unpack, pixels);
   if (!pixels)
      return NULL;

   /* alloc temporary texture */
   pt = alloc_texture(st, width, height, pipeFormat, PIPE_BIND_SAMPLER_VIEW);
   if (!pt) {
      _mesa_unmap_pbo_source(ctx, unpack);
      return NULL;
   }

   {
      struct pipe_transfer *transfer;
      GLboolean success;
      GLubyte *dest;
      const GLbitfield imageTransferStateSave = ctx->_ImageTransferState;

      /* we'll do pixel transfer in a fragment shader */
      ctx->_ImageTransferState = 0x0;

      /* map texture transfer */
      dest = pipe_transfer_map(pipe, pt, 0, 0,
                               PIPE_TRANSFER_WRITE, 0, 0,
                               width, height, &transfer);


      /* Put image into texture transfer.
       * Note that the image is actually going to be upside down in
       * the texture.  We deal with that with texcoords.
       */
      success = _mesa_texstore(ctx, 2,           /* dims */
                               baseInternalFormat, /* baseInternalFormat */
                               mformat,          /* mesa_format */
                               transfer->stride, /* dstRowStride, bytes */
                               &dest,            /* destSlices */
                               width, height, 1, /* size */
                               format, type,     /* src format/type */
                               pixels,           /* data source */
                               unpack);

      /* unmap */
      pipe_transfer_unmap(pipe, transfer);

      assert(success);

      /* restore */
      ctx->_ImageTransferState = imageTransferStateSave;
   }

   _mesa_unmap_pbo_source(ctx, unpack);

   return pt;
}


/**
 * Draw quad with texcoords and optional color.
 * Coords are gallium window coords with y=0=top.
 * \param color  may be null
 * \param invertTex  if true, flip texcoords vertically
 */
static void
draw_quad(struct gl_context *ctx, GLfloat x0, GLfloat y0, GLfloat z,
          GLfloat x1, GLfloat y1, const GLfloat *color,
          GLboolean invertTex, GLfloat maxXcoord, GLfloat maxYcoord)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   GLfloat (*verts)[3][4]; /* four verts, three attribs, XYZW */
   struct pipe_resource *buf = NULL;
   unsigned offset;

   if (u_upload_alloc(st->uploader, 0, 4 * sizeof(verts[0]), &offset,
                      &buf, (void **) &verts) != PIPE_OK) {
      return;
   }

   /* setup vertex data */
   {
      const struct gl_framebuffer *fb = st->ctx->DrawBuffer;
      const GLfloat fb_width = (GLfloat) fb->Width;
      const GLfloat fb_height = (GLfloat) fb->Height;
      const GLfloat clip_x0 = x0 / fb_width * 2.0f - 1.0f;
      const GLfloat clip_y0 = y0 / fb_height * 2.0f - 1.0f;
      const GLfloat clip_x1 = x1 / fb_width * 2.0f - 1.0f;
      const GLfloat clip_y1 = y1 / fb_height * 2.0f - 1.0f;
      const GLfloat sLeft = 0.0f, sRight = maxXcoord;
      const GLfloat tTop = invertTex ? maxYcoord : 0.0f;
      const GLfloat tBot = invertTex ? 0.0f : maxYcoord;
      GLuint i;

      /* upper-left */
      verts[0][0][0] = clip_x0;    /* v[0].attr[0].x */
      verts[0][0][1] = clip_y0;    /* v[0].attr[0].y */

      /* upper-right */
      verts[1][0][0] = clip_x1;
      verts[1][0][1] = clip_y0;

      /* lower-right */
      verts[2][0][0] = clip_x1;
      verts[2][0][1] = clip_y1;

      /* lower-left */
      verts[3][0][0] = clip_x0;
      verts[3][0][1] = clip_y1;

      verts[0][1][0] = sLeft; /* v[0].attr[1].S */
      verts[0][1][1] = tTop;  /* v[0].attr[1].T */
      verts[1][1][0] = sRight;
      verts[1][1][1] = tTop;
      verts[2][1][0] = sRight;
      verts[2][1][1] = tBot;
      verts[3][1][0] = sLeft;
      verts[3][1][1] = tBot;

      /* same for all verts: */
      if (color) {
         for (i = 0; i < 4; i++) {
            verts[i][0][2] = z;         /* v[i].attr[0].z */
            verts[i][0][3] = 1.0f;      /* v[i].attr[0].w */
            verts[i][2][0] = color[0];  /* v[i].attr[2].r */
            verts[i][2][1] = color[1];  /* v[i].attr[2].g */
            verts[i][2][2] = color[2];  /* v[i].attr[2].b */
            verts[i][2][3] = color[3];  /* v[i].attr[2].a */
            verts[i][1][2] = 0.0f;      /* v[i].attr[1].R */
            verts[i][1][3] = 1.0f;      /* v[i].attr[1].Q */
         }
      }
      else {
         for (i = 0; i < 4; i++) {
            verts[i][0][2] = z;    /*Z*/
            verts[i][0][3] = 1.0f; /*W*/
            verts[i][1][2] = 0.0f; /*R*/
            verts[i][1][3] = 1.0f; /*Q*/
         }
      }
   }

   u_upload_unmap(st->uploader);
   util_draw_vertex_buffer(pipe, st->cso_context, buf,
                           cso_get_aux_vertex_buffer_slot(st->cso_context),
                           offset,
			   PIPE_PRIM_QUADS,
			   4,  /* verts */
			   3); /* attribs/vert */
   pipe_resource_reference(&buf, NULL);
}



static void
draw_textured_quad(struct gl_context *ctx, GLint x, GLint y, GLfloat z,
                   GLsizei width, GLsizei height,
                   GLfloat zoomX, GLfloat zoomY,
                   struct pipe_sampler_view **sv,
                   int num_sampler_view,
                   void *driver_vp,
                   void *driver_fp,
                   const GLfloat *color,
                   GLboolean invertTex,
                   GLboolean write_depth, GLboolean write_stencil)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   struct cso_context *cso = st->cso_context;
   GLfloat x0, y0, x1, y1;
   GLsizei maxSize;
   boolean normalized = sv[0]->texture->target != PIPE_TEXTURE_RECT;

   /* limit checks */
   /* XXX if DrawPixels image is larger than max texture size, break
    * it up into chunks.
    */
   maxSize = 1 << (pipe->screen->get_param(pipe->screen,
                                        PIPE_CAP_MAX_TEXTURE_2D_LEVELS) - 1);
   assert(width <= maxSize);
   assert(height <= maxSize);

   cso_save_rasterizer(cso);
   cso_save_viewport(cso);
   cso_save_samplers(cso, PIPE_SHADER_FRAGMENT);
   cso_save_sampler_views(cso, PIPE_SHADER_FRAGMENT);
   cso_save_fragment_shader(cso);
   cso_save_stream_outputs(cso);
   cso_save_vertex_shader(cso);
   cso_save_geometry_shader(cso);
   cso_save_vertex_elements(cso);
   cso_save_aux_vertex_buffer_slot(cso);
   if (write_stencil) {
      cso_save_depth_stencil_alpha(cso);
      cso_save_blend(cso);
   }

   /* rasterizer state: just scissor */
   {
      struct pipe_rasterizer_state rasterizer;
      memset(&rasterizer, 0, sizeof(rasterizer));
      rasterizer.clamp_fragment_color = !st->clamp_frag_color_in_shader &&
                                        ctx->Color._ClampFragmentColor;
      rasterizer.half_pixel_center = 1;
      rasterizer.bottom_edge_rule = 1;
      rasterizer.depth_clip = !ctx->Transform.DepthClamp;
      rasterizer.scissor = ctx->Scissor.EnableFlags;
      cso_set_rasterizer(cso, &rasterizer);
   }

   if (write_stencil) {
      /* Stencil writing bypasses the normal fragment pipeline to
       * disable color writing and set stencil test to always pass.
       */
      struct pipe_depth_stencil_alpha_state dsa;
      struct pipe_blend_state blend;

      /* depth/stencil */
      memset(&dsa, 0, sizeof(dsa));
      dsa.stencil[0].enabled = 1;
      dsa.stencil[0].func = PIPE_FUNC_ALWAYS;
      dsa.stencil[0].writemask = ctx->Stencil.WriteMask[0] & 0xff;
      dsa.stencil[0].zpass_op = PIPE_STENCIL_OP_REPLACE;
      if (write_depth) {
         /* writing depth+stencil: depth test always passes */
         dsa.depth.enabled = 1;
         dsa.depth.writemask = ctx->Depth.Mask;
         dsa.depth.func = PIPE_FUNC_ALWAYS;
      }
      cso_set_depth_stencil_alpha(cso, &dsa);

      /* blend (colormask) */
      memset(&blend, 0, sizeof(blend));
      cso_set_blend(cso, &blend);
   }

   /* fragment shader state: TEX lookup program */
   cso_set_fragment_shader_handle(cso, driver_fp);

   /* vertex shader state: position + texcoord pass-through */
   cso_set_vertex_shader_handle(cso, driver_vp);

   /* geometry shader state: disabled */
   cso_set_geometry_shader_handle(cso, NULL);

   /* texture sampling state: */
   {
      struct pipe_sampler_state sampler;
      memset(&sampler, 0, sizeof(sampler));
      sampler.wrap_s = PIPE_TEX_WRAP_CLAMP;
      sampler.wrap_t = PIPE_TEX_WRAP_CLAMP;
      sampler.wrap_r = PIPE_TEX_WRAP_CLAMP;
      sampler.min_img_filter = PIPE_TEX_FILTER_NEAREST;
      sampler.min_mip_filter = PIPE_TEX_MIPFILTER_NONE;
      sampler.mag_img_filter = PIPE_TEX_FILTER_NEAREST;
      sampler.normalized_coords = normalized;

      cso_single_sampler(cso, PIPE_SHADER_FRAGMENT, 0, &sampler);
      if (num_sampler_view > 1) {
         cso_single_sampler(cso, PIPE_SHADER_FRAGMENT, 1, &sampler);
      }
      cso_single_sampler_done(cso, PIPE_SHADER_FRAGMENT);
   }

   /* viewport state: viewport matching window dims */
   {
      const float w = (float) ctx->DrawBuffer->Width;
      const float h = (float) ctx->DrawBuffer->Height;
      struct pipe_viewport_state vp;
      vp.scale[0] =  0.5f * w;
      vp.scale[1] = -0.5f * h;
      vp.scale[2] = 0.5f;
      vp.scale[3] = 1.0f;
      vp.translate[0] = 0.5f * w;
      vp.translate[1] = 0.5f * h;
      vp.translate[2] = 0.5f;
      vp.translate[3] = 0.0f;
      cso_set_viewport(cso, &vp);
   }

   cso_set_vertex_elements(cso, 3, st->velems_util_draw);
   cso_set_stream_outputs(st->cso_context, 0, NULL, NULL);

   /* texture state: */
   cso_set_sampler_views(cso, PIPE_SHADER_FRAGMENT, num_sampler_view, sv);

   /* Compute Gallium window coords (y=0=top) with pixel zoom.
    * Recall that these coords are transformed by the current
    * vertex shader and viewport transformation.
    */
   if (st_fb_orientation(ctx->DrawBuffer) == Y_0_BOTTOM) {
      y = ctx->DrawBuffer->Height - (int) (y + height * ctx->Pixel.ZoomY);
      invertTex = !invertTex;
   }

   x0 = (GLfloat) x;
   x1 = x + width * ctx->Pixel.ZoomX;
   y0 = (GLfloat) y;
   y1 = y + height * ctx->Pixel.ZoomY;

   /* convert Z from [0,1] to [-1,-1] to match viewport Z scale/bias */
   z = z * 2.0f - 1.0f;

   draw_quad(ctx, x0, y0, z, x1, y1, color, invertTex,
             normalized ? ((GLfloat) width / sv[0]->texture->width0) : (GLfloat)width,
             normalized ? ((GLfloat) height / sv[0]->texture->height0) : (GLfloat)height);

   /* restore state */
   cso_restore_rasterizer(cso);
   cso_restore_viewport(cso);
   cso_restore_samplers(cso, PIPE_SHADER_FRAGMENT);
   cso_restore_sampler_views(cso, PIPE_SHADER_FRAGMENT);
   cso_restore_fragment_shader(cso);
   cso_restore_vertex_shader(cso);
   cso_restore_geometry_shader(cso);
   cso_restore_vertex_elements(cso);
   cso_restore_aux_vertex_buffer_slot(cso);
   cso_restore_stream_outputs(cso);
   if (write_stencil) {
      cso_restore_depth_stencil_alpha(cso);
      cso_restore_blend(cso);
   }
}


/**
 * Software fallback to do glDrawPixels(GL_STENCIL_INDEX) when we
 * can't use a fragment shader to write stencil values.
 */
static void
draw_stencil_pixels(struct gl_context *ctx, GLint x, GLint y,
                    GLsizei width, GLsizei height, GLenum format, GLenum type,
                    const struct gl_pixelstore_attrib *unpack,
                    const GLvoid *pixels)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   struct st_renderbuffer *strb;
   enum pipe_transfer_usage usage;
   struct pipe_transfer *pt;
   const GLboolean zoom = ctx->Pixel.ZoomX != 1.0 || ctx->Pixel.ZoomY != 1.0;
   ubyte *stmap;
   struct gl_pixelstore_attrib clippedUnpack = *unpack;
   GLubyte *sValues;
   GLuint *zValues;

   if (!zoom) {
      if (!_mesa_clip_drawpixels(ctx, &x, &y, &width, &height,
                                 &clippedUnpack)) {
         /* totally clipped */
         return;
      }
   }

   strb = st_renderbuffer(ctx->DrawBuffer->
                          Attachment[BUFFER_STENCIL].Renderbuffer);

   if (st_fb_orientation(ctx->DrawBuffer) == Y_0_TOP) {
      y = ctx->DrawBuffer->Height - y - height;
   }

   if (format == GL_STENCIL_INDEX && 
       _mesa_is_format_packed_depth_stencil(strb->Base.Format)) {
      /* writing stencil to a combined depth+stencil buffer */
      usage = PIPE_TRANSFER_READ_WRITE;
   }
   else {
      usage = PIPE_TRANSFER_WRITE;
   }

   stmap = pipe_transfer_map(pipe, strb->texture,
                             strb->surface->u.tex.level,
                             strb->surface->u.tex.first_layer,
                             usage, x, y,
                             width, height, &pt);

   pixels = _mesa_map_pbo_source(ctx, &clippedUnpack, pixels);
   assert(pixels);

   sValues = malloc(width * sizeof(GLubyte));
   zValues = malloc(width * sizeof(GLuint));

   if (sValues && zValues) {
      GLint row;
      for (row = 0; row < height; row++) {
         GLfloat *zValuesFloat = (GLfloat*)zValues;
         GLenum destType = GL_UNSIGNED_BYTE;
         const GLvoid *source = _mesa_image_address2d(&clippedUnpack, pixels,
                                                      width, height,
                                                      format, type,
                                                      row, 0);
         _mesa_unpack_stencil_span(ctx, width, destType, sValues,
                                   type, source, &clippedUnpack,
                                   ctx->_ImageTransferState);

         if (format == GL_DEPTH_STENCIL) {
            GLenum ztype =
               pt->resource->format == PIPE_FORMAT_Z32_FLOAT_S8X24_UINT ?
               GL_FLOAT : GL_UNSIGNED_INT;

            _mesa_unpack_depth_span(ctx, width, ztype, zValues,
                                    (1 << 24) - 1, type, source,
                                    &clippedUnpack);
         }

         if (zoom) {
            _mesa_problem(ctx, "Gallium glDrawPixels(GL_STENCIL) with "
                          "zoom not complete");
         }

         {
            GLint spanY;

            if (st_fb_orientation(ctx->DrawBuffer) == Y_0_TOP) {
               spanY = height - row - 1;
            }
            else {
               spanY = row;
            }

            /* now pack the stencil (and Z) values in the dest format */
            switch (pt->resource->format) {
            case PIPE_FORMAT_S8_UINT:
               {
                  ubyte *dest = stmap + spanY * pt->stride;
                  assert(usage == PIPE_TRANSFER_WRITE);
                  memcpy(dest, sValues, width);
               }
               break;
            case PIPE_FORMAT_Z24_UNORM_S8_UINT:
               if (format == GL_DEPTH_STENCIL) {
                  uint *dest = (uint *) (stmap + spanY * pt->stride);
                  GLint k;
                  assert(usage == PIPE_TRANSFER_WRITE);
                  for (k = 0; k < width; k++) {
                     dest[k] = zValues[k] | (sValues[k] << 24);
                  }
               }
               else {
                  uint *dest = (uint *) (stmap + spanY * pt->stride);
                  GLint k;
                  assert(usage == PIPE_TRANSFER_READ_WRITE);
                  for (k = 0; k < width; k++) {
                     dest[k] = (dest[k] & 0xffffff) | (sValues[k] << 24);
                  }
               }
               break;
            case PIPE_FORMAT_S8_UINT_Z24_UNORM:
               if (format == GL_DEPTH_STENCIL) {
                  uint *dest = (uint *) (stmap + spanY * pt->stride);
                  GLint k;
                  assert(usage == PIPE_TRANSFER_WRITE);
                  for (k = 0; k < width; k++) {
                     dest[k] = (zValues[k] << 8) | (sValues[k] & 0xff);
                  }
               }
               else {
                  uint *dest = (uint *) (stmap + spanY * pt->stride);
                  GLint k;
                  assert(usage == PIPE_TRANSFER_READ_WRITE);
                  for (k = 0; k < width; k++) {
                     dest[k] = (dest[k] & 0xffffff00) | (sValues[k] & 0xff);
                  }
               }
               break;
            case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
               if (format == GL_DEPTH_STENCIL) {
                  uint *dest = (uint *) (stmap + spanY * pt->stride);
                  GLfloat *destf = (GLfloat*)dest;
                  GLint k;
                  assert(usage == PIPE_TRANSFER_WRITE);
                  for (k = 0; k < width; k++) {
                     destf[k*2] = zValuesFloat[k];
                     dest[k*2+1] = sValues[k] & 0xff;
                  }
               }
               else {
                  uint *dest = (uint *) (stmap + spanY * pt->stride);
                  GLint k;
                  assert(usage == PIPE_TRANSFER_READ_WRITE);
                  for (k = 0; k < width; k++) {
                     dest[k*2+1] = sValues[k] & 0xff;
                  }
               }
               break;
            default:
               assert(0);
            }
         }
      }
   }
   else {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glDrawPixels()");
   }

   free(sValues);
   free(zValues);

   _mesa_unmap_pbo_source(ctx, &clippedUnpack);

   /* unmap the stencil buffer */
   pipe_transfer_unmap(pipe, pt);
}


/**
 * Get fragment program variant for a glDrawPixels or glCopyPixels
 * command for RGBA data.
 */
static struct st_fp_variant *
get_color_fp_variant(struct st_context *st)
{
   struct gl_context *ctx = st->ctx;
   struct st_fp_variant_key key;
   struct st_fp_variant *fpv;

   memset(&key, 0, sizeof(key));

   key.st = st;
   key.drawpixels = 1;
   key.scaleAndBias = (ctx->Pixel.RedBias != 0.0 ||
                       ctx->Pixel.RedScale != 1.0 ||
                       ctx->Pixel.GreenBias != 0.0 ||
                       ctx->Pixel.GreenScale != 1.0 ||
                       ctx->Pixel.BlueBias != 0.0 ||
                       ctx->Pixel.BlueScale != 1.0 ||
                       ctx->Pixel.AlphaBias != 0.0 ||
                       ctx->Pixel.AlphaScale != 1.0);
   key.pixelMaps = ctx->Pixel.MapColorFlag;
   key.clamp_color = st->clamp_frag_color_in_shader &&
                     st->ctx->Color._ClampFragmentColor;

   fpv = st_get_fp_variant(st, st->fp, &key);

   return fpv;
}


/**
 * Get fragment program variant for a glDrawPixels or glCopyPixels
 * command for depth/stencil data.
 */
static struct st_fp_variant *
get_depth_stencil_fp_variant(struct st_context *st, GLboolean write_depth,
                             GLboolean write_stencil)
{
   struct st_fp_variant_key key;
   struct st_fp_variant *fpv;

   memset(&key, 0, sizeof(key));

   key.st = st;
   key.drawpixels = 1;
   key.drawpixels_z = write_depth;
   key.drawpixels_stencil = write_stencil;

   fpv = st_get_fp_variant(st, st->fp, &key);

   return fpv;
}


/**
 * Clamp glDrawPixels width and height to the maximum texture size.
 */
static void
clamp_size(struct pipe_context *pipe, GLsizei *width, GLsizei *height,
           struct gl_pixelstore_attrib *unpack)
{
   const int maxSize =
      1 << (pipe->screen->get_param(pipe->screen,
                                    PIPE_CAP_MAX_TEXTURE_2D_LEVELS) - 1);

   if (*width > maxSize) {
      if (unpack->RowLength == 0)
         unpack->RowLength = *width;
      *width = maxSize;
   }
   if (*height > maxSize) {
      *height = maxSize;
   }
}


/**
 * Called via ctx->Driver.DrawPixels()
 */
static void
st_DrawPixels(struct gl_context *ctx, GLint x, GLint y,
              GLsizei width, GLsizei height,
              GLenum format, GLenum type,
              const struct gl_pixelstore_attrib *unpack, const GLvoid *pixels)
{
   void *driver_vp, *driver_fp;
   struct st_context *st = st_context(ctx);
   const GLfloat *color;
   struct pipe_context *pipe = st->pipe;
   GLboolean write_stencil = GL_FALSE, write_depth = GL_FALSE;
   struct pipe_sampler_view *sv[2];
   int num_sampler_view = 1;
   struct st_fp_variant *fpv;
   struct gl_pixelstore_attrib clippedUnpack;

   /* Mesa state should be up to date by now */
   assert(ctx->NewState == 0x0);

   st_validate_state(st);

   /* Limit the size of the glDrawPixels to the max texture size.
    * Strictly speaking, that's not correct but since we don't handle
    * larger images yet, this is better than crashing.
    */
   clippedUnpack = *unpack;
   unpack = &clippedUnpack;
   clamp_size(st->pipe, &width, &height, &clippedUnpack);

   if (format == GL_DEPTH_STENCIL)
      write_stencil = write_depth = GL_TRUE;
   else if (format == GL_STENCIL_INDEX)
      write_stencil = GL_TRUE;
   else if (format == GL_DEPTH_COMPONENT)
      write_depth = GL_TRUE;

   if (write_stencil &&
       !pipe->screen->get_param(pipe->screen, PIPE_CAP_SHADER_STENCIL_EXPORT)) {
      /* software fallback */
      draw_stencil_pixels(ctx, x, y, width, height, format, type,
                          unpack, pixels);
      return;
   }

   /*
    * Get vertex/fragment shaders
    */
   if (write_depth || write_stencil) {
      fpv = get_depth_stencil_fp_variant(st, write_depth, write_stencil);

      driver_fp = fpv->driver_shader;

      driver_vp = make_passthrough_vertex_shader(st, GL_TRUE);

      color = ctx->Current.RasterColor;
   }
   else {
      fpv = get_color_fp_variant(st);

      driver_fp = fpv->driver_shader;

      driver_vp = make_passthrough_vertex_shader(st, GL_FALSE);

      color = NULL;
      if (st->pixel_xfer.pixelmap_enabled) {
	  sv[1] = st->pixel_xfer.pixelmap_sampler_view;
	  num_sampler_view++;
      }
   }

   /* update fragment program constants */
   st_upload_constants(st, fpv->parameters, PIPE_SHADER_FRAGMENT);

   /* draw with textured quad */
   {
      struct pipe_resource *pt
         = make_texture(st, width, height, format, type, unpack, pixels);
      if (pt) {
         sv[0] = st_create_texture_sampler_view(st->pipe, pt);

         if (sv[0]) {
            /* Create a second sampler view to read stencil.
             * The stencil is written using the shader stencil export
             * functionality. */
            if (write_stencil) {
               enum pipe_format stencil_format =
                     util_format_stencil_only(pt->format);

               sv[1] = st_create_texture_sampler_view_format(st->pipe, pt,
                                                             stencil_format);
               num_sampler_view++;
            }

            draw_textured_quad(ctx, x, y, ctx->Current.RasterPos[2],
                               width, height,
                               ctx->Pixel.ZoomX, ctx->Pixel.ZoomY,
                               sv,
                               num_sampler_view,
                               driver_vp,
                               driver_fp,
                               color, GL_FALSE, write_depth, write_stencil);
            pipe_sampler_view_reference(&sv[0], NULL);
            if (num_sampler_view > 1)
               pipe_sampler_view_reference(&sv[1], NULL);
         }
         pipe_resource_reference(&pt, NULL);
      }
   }
}



/**
 * Software fallback for glCopyPixels(GL_STENCIL).
 */
static void
copy_stencil_pixels(struct gl_context *ctx, GLint srcx, GLint srcy,
                    GLsizei width, GLsizei height,
                    GLint dstx, GLint dsty)
{
   struct st_renderbuffer *rbDraw;
   struct pipe_context *pipe = st_context(ctx)->pipe;
   enum pipe_transfer_usage usage;
   struct pipe_transfer *ptDraw;
   ubyte *drawMap;
   ubyte *buffer;
   int i;

   buffer = malloc(width * height * sizeof(ubyte));
   if (!buffer) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels(stencil)");
      return;
   }

   /* Get the dest renderbuffer */
   rbDraw = st_renderbuffer(ctx->DrawBuffer->
                            Attachment[BUFFER_STENCIL].Renderbuffer);

   /* this will do stencil pixel transfer ops */
   _mesa_readpixels(ctx, srcx, srcy, width, height,
                    GL_STENCIL_INDEX, GL_UNSIGNED_BYTE,
                    &ctx->DefaultPacking, buffer);

   if (0) {
      /* debug code: dump stencil values */
      GLint row, col;
      for (row = 0; row < height; row++) {
         printf("%3d: ", row);
         for (col = 0; col < width; col++) {
            printf("%02x ", buffer[col + row * width]);
         }
         printf("\n");
      }
   }

   if (_mesa_is_format_packed_depth_stencil(rbDraw->Base.Format))
      usage = PIPE_TRANSFER_READ_WRITE;
   else
      usage = PIPE_TRANSFER_WRITE;

   if (st_fb_orientation(ctx->DrawBuffer) == Y_0_TOP) {
      dsty = rbDraw->Base.Height - dsty - height;
   }

   assert(util_format_get_blockwidth(rbDraw->texture->format) == 1);
   assert(util_format_get_blockheight(rbDraw->texture->format) == 1);

   /* map the stencil buffer */
   drawMap = pipe_transfer_map(pipe,
                               rbDraw->texture,
                               rbDraw->surface->u.tex.level,
                               rbDraw->surface->u.tex.first_layer,
                               usage, dstx, dsty,
                               width, height, &ptDraw);

   /* draw */
   /* XXX PixelZoom not handled yet */
   for (i = 0; i < height; i++) {
      ubyte *dst;
      const ubyte *src;
      int y;

      y = i;

      if (st_fb_orientation(ctx->DrawBuffer) == Y_0_TOP) {
         y = height - y - 1;
      }

      dst = drawMap + y * ptDraw->stride;
      src = buffer + i * width;

      _mesa_pack_ubyte_stencil_row(rbDraw->Base.Format, width, src, dst);
   }

   free(buffer);

   /* unmap the stencil buffer */
   pipe_transfer_unmap(pipe, ptDraw);
}


/**
 * Return renderbuffer to use for reading color pixels for glCopyPixels
 */
static struct st_renderbuffer *
st_get_color_read_renderbuffer(struct gl_context *ctx)
{
   struct gl_framebuffer *fb = ctx->ReadBuffer;
   struct st_renderbuffer *strb =
      st_renderbuffer(fb->_ColorReadBuffer);

   return strb;
}


/**
 * \return TRUE if two regions overlap, FALSE otherwise
 */
static boolean
regions_overlap(int srcX0, int srcY0,
                int srcX1, int srcY1,
                int dstX0, int dstY0,
                int dstX1, int dstY1)
{
   if (MAX2(srcX0, srcX1) < MIN2(dstX0, dstX1))
      return FALSE; /* src completely left of dst */

   if (MAX2(dstX0, dstX1) < MIN2(srcX0, srcX1))
      return FALSE; /* dst completely left of src */

   if (MAX2(srcY0, srcY1) < MIN2(dstY0, dstY1))
      return FALSE; /* src completely above dst */

   if (MAX2(dstY0, dstY1) < MIN2(srcY0, srcY1))
      return FALSE; /* dst completely above src */

   return TRUE; /* some overlap */
}


/**
 * Try to do a glCopyPixels for simple cases with a blit by calling
 * pipe->blit().
 *
 * We can do this when we're copying color pixels (depth/stencil
 * eventually) with no pixel zoom, no pixel transfer ops, no
 * per-fragment ops, and the src/dest regions don't overlap.
 */
static GLboolean
blit_copy_pixels(struct gl_context *ctx, GLint srcx, GLint srcy,
                 GLsizei width, GLsizei height,
                 GLint dstx, GLint dsty, GLenum type)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   struct pipe_screen *screen = pipe->screen;
   struct gl_pixelstore_attrib pack, unpack;
   GLint readX, readY, readW, readH, drawX, drawY, drawW, drawH;

   if (type == GL_COLOR &&
       ctx->Pixel.ZoomX == 1.0 &&
       ctx->Pixel.ZoomY == 1.0 &&
       ctx->_ImageTransferState == 0x0 &&
       !ctx->Color.BlendEnabled &&
       !ctx->Color.AlphaEnabled &&
       !ctx->Depth.Test &&
       !ctx->Fog.Enabled &&
       !ctx->Stencil.Enabled &&
       !ctx->FragmentProgram.Enabled &&
       !ctx->VertexProgram.Enabled &&
       !ctx->_Shader->CurrentProgram[MESA_SHADER_FRAGMENT] &&
       ctx->DrawBuffer->_NumColorDrawBuffers == 1 &&
       !ctx->Query.CondRenderQuery &&
       !ctx->Query.CurrentOcclusionObject) {
      struct st_renderbuffer *rbRead, *rbDraw;

      /*
       * Clip the read region against the src buffer bounds.
       * We'll still allocate a temporary buffer/texture for the original
       * src region size but we'll only read the region which is on-screen.
       * This may mean that we draw garbage pixels into the dest region, but
       * that's expected.
       */
      readX = srcx;
      readY = srcy;
      readW = width;
      readH = height;
      pack = ctx->DefaultPacking;
      if (!_mesa_clip_readpixels(ctx, &readX, &readY, &readW, &readH, &pack))
         return GL_TRUE; /* all done */

      /* clip against dest buffer bounds and scissor box */
      drawX = dstx + pack.SkipPixels;
      drawY = dsty + pack.SkipRows;
      unpack = pack;
      if (!_mesa_clip_drawpixels(ctx, &drawX, &drawY, &readW, &readH, &unpack))
         return GL_TRUE; /* all done */

      readX = readX - pack.SkipPixels + unpack.SkipPixels;
      readY = readY - pack.SkipRows + unpack.SkipRows;

      drawW = readW;
      drawH = readH;

      rbRead = st_get_color_read_renderbuffer(ctx);
      rbDraw = st_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0]);

      /* Flip src/dst position depending on the orientation of buffers. */
      if (st_fb_orientation(ctx->ReadBuffer) == Y_0_TOP) {
         readY = rbRead->Base.Height - readY;
         readH = -readH;
      }

      if (st_fb_orientation(ctx->DrawBuffer) == Y_0_TOP) {
         /* We can't flip the destination for pipe->blit, so we only adjust
          * its position and flip the source.
          */
         drawY = rbDraw->Base.Height - drawY - drawH;
         readY += readH;
         readH = -readH;
      }

      if (rbRead != rbDraw ||
          !regions_overlap(readX, readY, readX + readW, readY + readH,
                           drawX, drawY, drawX + drawW, drawY + drawH)) {
         struct pipe_blit_info blit;

         memset(&blit, 0, sizeof(blit));
         blit.src.resource = rbRead->texture;
         blit.src.level = rbRead->surface->u.tex.level;
         blit.src.format = rbRead->texture->format;
         blit.src.box.x = readX;
         blit.src.box.y = readY;
         blit.src.box.z = rbRead->surface->u.tex.first_layer;
         blit.src.box.width = readW;
         blit.src.box.height = readH;
         blit.src.box.depth = 1;
         blit.dst.resource = rbDraw->texture;
         blit.dst.level = rbDraw->surface->u.tex.level;
         blit.dst.format = rbDraw->texture->format;
         blit.dst.box.x = drawX;
         blit.dst.box.y = drawY;
         blit.dst.box.z = rbDraw->surface->u.tex.first_layer;
         blit.dst.box.width = drawW;
         blit.dst.box.height = drawH;
         blit.dst.box.depth = 1;
         blit.mask = PIPE_MASK_RGBA;
         blit.filter = PIPE_TEX_FILTER_NEAREST;

         if (screen->is_format_supported(screen, blit.src.format,
                                         blit.src.resource->target,
                                         blit.src.resource->nr_samples,
                                         PIPE_BIND_SAMPLER_VIEW) &&
             screen->is_format_supported(screen, blit.dst.format,
                                         blit.dst.resource->target,
                                         blit.dst.resource->nr_samples,
                                         PIPE_BIND_RENDER_TARGET)) {
            pipe->blit(pipe, &blit);
            return GL_TRUE;
         }
      }
   }

   return GL_FALSE;
}


static void
st_CopyPixels(struct gl_context *ctx, GLint srcx, GLint srcy,
              GLsizei width, GLsizei height,
              GLint dstx, GLint dsty, GLenum type)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   struct pipe_screen *screen = pipe->screen;
   struct st_renderbuffer *rbRead;
   void *driver_vp, *driver_fp;
   struct pipe_resource *pt;
   struct pipe_sampler_view *sv[2];
   int num_sampler_view = 1;
   GLfloat *color;
   enum pipe_format srcFormat;
   unsigned srcBind;
   GLboolean invertTex = GL_FALSE;
   GLint readX, readY, readW, readH;
   struct gl_pixelstore_attrib pack = ctx->DefaultPacking;
   struct st_fp_variant *fpv;

   st_validate_state(st);

   if (type == GL_DEPTH_STENCIL) {
      /* XXX make this more efficient */
      st_CopyPixels(ctx, srcx, srcy, width, height, dstx, dsty, GL_STENCIL);
      st_CopyPixels(ctx, srcx, srcy, width, height, dstx, dsty, GL_DEPTH);
      return;
   }

   if (type == GL_STENCIL) {
      /* can't use texturing to do stencil */
      copy_stencil_pixels(ctx, srcx, srcy, width, height, dstx, dsty);
      return;
   }

   if (blit_copy_pixels(ctx, srcx, srcy, width, height, dstx, dsty, type))
      return;

   /*
    * The subsequent code implements glCopyPixels by copying the source
    * pixels into a temporary texture that's then applied to a textured quad.
    * When we draw the textured quad, all the usual per-fragment operations
    * are handled.
    */


   /*
    * Get vertex/fragment shaders
    */
   if (type == GL_COLOR) {
      rbRead = st_get_color_read_renderbuffer(ctx);
      color = NULL;

      fpv = get_color_fp_variant(st);
      driver_fp = fpv->driver_shader;

      driver_vp = make_passthrough_vertex_shader(st, GL_FALSE);

      if (st->pixel_xfer.pixelmap_enabled) {
         sv[1] = st->pixel_xfer.pixelmap_sampler_view;
         num_sampler_view++;
      }
   }
   else {
      assert(type == GL_DEPTH);
      rbRead = st_renderbuffer(ctx->ReadBuffer->
                               Attachment[BUFFER_DEPTH].Renderbuffer);
      color = ctx->Current.Attrib[VERT_ATTRIB_COLOR0];

      fpv = get_depth_stencil_fp_variant(st, GL_TRUE, GL_FALSE);
      driver_fp = fpv->driver_shader;

      driver_vp = make_passthrough_vertex_shader(st, GL_TRUE);
   }

   /* update fragment program constants */
   st_upload_constants(st, fpv->parameters, PIPE_SHADER_FRAGMENT);

   /* Choose the format for the temporary texture. */
   srcFormat = rbRead->texture->format;
   srcBind = PIPE_BIND_SAMPLER_VIEW |
      (type == GL_COLOR ? PIPE_BIND_RENDER_TARGET : PIPE_BIND_DEPTH_STENCIL);

   if (!screen->is_format_supported(screen, srcFormat, st->internal_target, 0,
                                    srcBind)) {
      /* srcFormat is non-renderable. Find a compatible renderable format. */
      if (type == GL_DEPTH) {
         srcFormat = st_choose_format(st, GL_DEPTH_COMPONENT, GL_NONE,
                                      GL_NONE, st->internal_target, 0,
                                      srcBind, FALSE);
      }
      else {
         assert(type == GL_COLOR);

         if (util_format_is_float(srcFormat)) {
            srcFormat = st_choose_format(st, GL_RGBA32F, GL_NONE,
                                         GL_NONE, st->internal_target, 0,
                                         srcBind, FALSE);
         }
         else if (util_format_is_pure_sint(srcFormat)) {
            srcFormat = st_choose_format(st, GL_RGBA32I, GL_NONE,
                                         GL_NONE, st->internal_target, 0,
                                         srcBind, FALSE);
         }
         else if (util_format_is_pure_uint(srcFormat)) {
            srcFormat = st_choose_format(st, GL_RGBA32UI, GL_NONE,
                                         GL_NONE, st->internal_target, 0,
                                         srcBind, FALSE);
         }
         else if (util_format_is_snorm(srcFormat)) {
            srcFormat = st_choose_format(st, GL_RGBA16_SNORM, GL_NONE,
                                         GL_NONE, st->internal_target, 0,
                                         srcBind, FALSE);
         }
         else {
            srcFormat = st_choose_format(st, GL_RGBA, GL_NONE,
                                         GL_NONE, st->internal_target, 0,
                                         srcBind, FALSE);
         }
      }

      if (srcFormat == PIPE_FORMAT_NONE) {
         assert(0 && "cannot choose a format for src of CopyPixels");
         return;
      }
   }

   /* Invert src region if needed */
   if (st_fb_orientation(ctx->ReadBuffer) == Y_0_TOP) {
      srcy = ctx->ReadBuffer->Height - srcy - height;
      invertTex = !invertTex;
   }

   /* Clip the read region against the src buffer bounds.
    * We'll still allocate a temporary buffer/texture for the original
    * src region size but we'll only read the region which is on-screen.
    * This may mean that we draw garbage pixels into the dest region, but
    * that's expected.
    */
   readX = srcx;
   readY = srcy;
   readW = width;
   readH = height;
   if (!_mesa_clip_readpixels(ctx, &readX, &readY, &readW, &readH, &pack)) {
      /* The source region is completely out of bounds.  Do nothing.
       * The GL spec says "Results of copies from outside the window,
       * or from regions of the window that are not exposed, are
       * hardware dependent and undefined."
       */
      return;
   }

   readW = MAX2(0, readW);
   readH = MAX2(0, readH);

   /* Allocate the temporary texture. */
   pt = alloc_texture(st, width, height, srcFormat, srcBind);
   if (!pt)
      return;

   sv[0] = st_create_texture_sampler_view(st->pipe, pt);
   if (!sv[0]) {
      pipe_resource_reference(&pt, NULL);
      return;
   }

   /* Copy the src region to the temporary texture. */
   {
      struct pipe_blit_info blit;

      memset(&blit, 0, sizeof(blit));
      blit.src.resource = rbRead->texture;
      blit.src.level = rbRead->surface->u.tex.level;
      blit.src.format = rbRead->texture->format;
      blit.src.box.x = readX;
      blit.src.box.y = readY;
      blit.src.box.z = rbRead->surface->u.tex.first_layer;
      blit.src.box.width = readW;
      blit.src.box.height = readH;
      blit.src.box.depth = 1;
      blit.dst.resource = pt;
      blit.dst.level = 0;
      blit.dst.format = pt->format;
      blit.dst.box.x = pack.SkipPixels;
      blit.dst.box.y = pack.SkipRows;
      blit.dst.box.z = 0;
      blit.dst.box.width = readW;
      blit.dst.box.height = readH;
      blit.dst.box.depth = 1;
      blit.mask = util_format_get_mask(pt->format) & ~PIPE_MASK_S;
      blit.filter = PIPE_TEX_FILTER_NEAREST;

      pipe->blit(pipe, &blit);
   }

   /* OK, the texture 'pt' contains the src image/pixels.  Now draw a
    * textured quad with that texture.
    */
   draw_textured_quad(ctx, dstx, dsty, ctx->Current.RasterPos[2],
                      width, height, ctx->Pixel.ZoomX, ctx->Pixel.ZoomY,
                      sv,
                      num_sampler_view,
                      driver_vp, 
                      driver_fp,
                      color, invertTex, GL_FALSE, GL_FALSE);

   pipe_resource_reference(&pt, NULL);
   pipe_sampler_view_reference(&sv[0], NULL);
}



void st_init_drawpixels_functions(struct dd_function_table *functions)
{
   functions->DrawPixels = st_DrawPixels;
   functions->CopyPixels = st_CopyPixels;
}


void
st_destroy_drawpix(struct st_context *st)
{
   GLuint i;

   for (i = 0; i < Elements(st->drawpix.shaders); i++) {
      if (st->drawpix.shaders[i])
         _mesa_reference_fragprog(st->ctx, &st->drawpix.shaders[i], NULL);
   }

   st_reference_fragprog(st, &st->pixel_xfer.combined_prog, NULL);
   if (st->drawpix.vert_shaders[0])
      cso_delete_vertex_shader(st->cso_context, st->drawpix.vert_shaders[0]);
   if (st->drawpix.vert_shaders[1])
      cso_delete_vertex_shader(st->cso_context, st->drawpix.vert_shaders[1]);
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d494 1
a494 1
   pipeFormat = st_choose_matching_format(st, PIPE_BIND_SAMPLER_VIEW,
d497 5
a501 1
   if (pipeFormat == PIPE_FORMAT_NONE) {
d505 1
d510 1
a511 3

   mformat = st_pipe_format_to_mesa_format(pipeFormat);
   baseInternalFormat = _mesa_get_format_base_format(mformat);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d494 1
a494 1
   pipeFormat = st_choose_matching_format(pipe->screen, PIPE_BIND_SAMPLER_VIEW,
d497 1
a497 5
   if (pipeFormat != PIPE_FORMAT_NONE) {
      mformat = st_pipe_format_to_mesa_format(pipeFormat);
      baseInternalFormat = _mesa_get_format_base_format(mformat);
   }
   else {
a500 1
      baseInternalFormat = _mesa_base_tex_format(ctx, intFormat);
a504 1
      mformat = st_pipe_format_to_mesa_format(pipeFormat);
d506 3
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d486 1
a486 1
   gl_format mformat;
d545 1
a545 1
                               mformat,          /* gl_format */
d716 1
a716 1
      rasterizer.scissor = ctx->Scissor.Enabled;
d791 1
a791 1
   cso_set_stream_outputs(st->cso_context, 0, NULL, 0);
d881 2
a882 1
                             strb->rtt_level, strb->rtt_face + strb->rtt_slice,
d1267 2
a1268 2
                               rbDraw->rtt_level,
                               rbDraw->rtt_face + rbDraw->rtt_slice,
d1367 1
a1367 1
       !ctx->Shader.CurrentFragmentProgram &&
d1426 1
a1426 1
         blit.src.level = rbRead->rtt_level;
d1430 1
a1430 1
         blit.src.box.z = rbRead->rtt_face + rbRead->rtt_slice;
d1435 1
a1435 1
         blit.dst.level = rbDraw->rtt_level;
d1439 1
a1439 1
         blit.dst.box.z = rbDraw->rtt_face + rbDraw->rtt_slice;
d1637 1
a1637 1
      blit.src.level = rbRead->rtt_level;
d1641 1
a1641 1
      blit.src.box.z = rbRead->rtt_face + rbRead->rtt_slice;
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d36 1
a37 1
#include "main/mfeatures.h"
d41 1
d45 1
d69 1
a72 2
#if FEATURE_drawpix

d89 1
a89 1
          inst[0].SrcReg[0].Index == FRAG_ATTRIB_COL0 &&
d98 40
d151 1
d157 3
d218 1
a218 1
   p->NumInstructions = write_depth ? 2 : 1;
d235 1
a235 1
      p->Instructions[ic].SrcReg[0].Index = FRAG_ATTRIB_TEX0;
d239 7
d255 1
a255 1
      p->Instructions[ic].SrcReg[0].Index = FRAG_ATTRIB_TEX0;
d266 1
a266 1
   p->InputsRead = FRAG_BIT_TEX0 | FRAG_BIT_COL0;
d268 1
a268 1
   if (write_depth)
d270 2
d296 3
d312 1
a312 1
               ureg_DECL_output( ureg, TGSI_SEMANTIC_GENERIC, 0 ),
a332 20
 * Return a texture base format for drawing/copying an image
 * of the given format.
 */
static GLenum
base_format(GLenum format)
{
   switch (format) {
   case GL_DEPTH_COMPONENT:
      return GL_DEPTH_COMPONENT;
   case GL_DEPTH_STENCIL:
      return GL_DEPTH_STENCIL;
   case GL_STENCIL_INDEX:
      return GL_STENCIL_INDEX;
   default:
      return GL_RGBA;
   }
}


/**
d341 17
a357 1
      return GL_DEPTH_COMPONENT;
d359 9
a367 1
      return GL_DEPTH_STENCIL;
d370 1
d372 1
a372 1
      if (_mesa_is_integer_format(format)) {
d401 2
d409 2
d463 1
a463 1
              enum pipe_format texFormat)
d468 1
a468 1
                          width, height, 1, 1, PIPE_BIND_SAMPLER_VIEW);
d489 1
a489 1
   GLenum baseInternalFormat, intFormat;
d491 5
a495 2
   intFormat = internal_format(ctx, format, type);
   baseInternalFormat = _mesa_base_tex_format(ctx, intFormat);
d497 7
a503 3
   mformat = st_ChooseTextureFormat_renderable(ctx, intFormat,
                                               format, type, GL_FALSE);
   assert(mformat);
d505 7
a511 2
   pipeFormat = st_mesa_format_to_pipe_format(mformat);
   assert(pipeFormat);
d518 1
a518 1
   pt = alloc_texture(st, width, height, pipeFormat);
a525 1
      static const GLuint dstImageOffsets = 0;
a532 4
      transfer = pipe_get_transfer(st->pipe, pt, 0, 0,
                                   PIPE_TRANSFER_WRITE, 0, 0,
                                   width, height);

d534 3
a536 1
      dest = pipe_transfer_map(pipe, transfer);
a545 2
                               dest,             /* dest */
                               0, 0, 0,          /* dstX/Y/Zoffset */
d547 1
a547 1
                               &dstImageOffsets, /* dstImageOffsets */
a554 1
      pipe->transfer_destroy(pipe, transfer);
d581 8
a588 1
   GLfloat verts[4][3][4]; /* four verts, three attribs, XYZW */
d652 8
a659 16
   {
      struct pipe_resource *buf;

      /* allocate/load buffer object with vertex data */
      buf = pipe_buffer_create(pipe->screen,
			       PIPE_BIND_VERTEX_BUFFER,
			       PIPE_USAGE_STATIC,
                               sizeof(verts));
      pipe_buffer_write(st->pipe, buf, 0, sizeof(verts), verts);

      util_draw_vertex_buffer(pipe, st->cso_context, buf, 0,
                              PIPE_PRIM_QUADS,
                              4,  /* verts */
                              3); /* attribs/vert */
      pipe_resource_reference(&buf, NULL);
   }
d694 2
a695 2
   cso_save_samplers(cso);
   cso_save_fragment_sampler_views(cso);
d697 1
d699 1
d701 1
a701 1
   cso_save_vertex_buffers(cso);
d711 5
a715 2
      rasterizer.clamp_fragment_color = ctx->Color._ClampFragmentColor;
      rasterizer.gl_rasterization_rules = 1;
d752 2
d767 1
a767 1
      cso_single_sampler(cso, 0, &sampler);
d769 1
a769 1
         cso_single_sampler(cso, 1, &sampler);
d771 1
a771 1
      cso_single_sampler_done(cso);
d791 1
d794 1
a794 1
   cso_set_fragment_sampler_views(cso, num_sampler_view, sv);
d811 1
a811 1
   z = z * 2.0 - 1.0;
d820 2
a821 2
   cso_restore_samplers(cso);
   cso_restore_fragment_sampler_views(cso);
d824 1
d826 2
a827 1
   cso_restore_vertex_buffers(cso);
a850 1
   GLint skipPixels;
d853 2
d871 3
a873 3
   if(format != GL_DEPTH_STENCIL && 
      util_format_get_component_bits(strb->format,
                                     UTIL_FORMAT_COLORSPACE_ZS, 0) != 0)
d875 2
a876 1
   else
d878 1
d880 4
a883 6
   pt = pipe_get_transfer(pipe, strb->texture,
                          strb->rtt_level, strb->rtt_face + strb->rtt_slice,
                          usage, x, y,
                          width, height);

   stmap = pipe_transfer_map(pipe, pt);
d888 4
a891 5
   /* if width > MAX_WIDTH, have to process image in chunks */
   skipPixels = 0;
   while (skipPixels < width) {
      const GLint spanX = skipPixels;
      const GLint spanWidth = MIN2(width - skipPixels, MAX_WIDTH);
d894 1
a894 2
         GLubyte sValues[MAX_WIDTH];
         GLuint zValues[MAX_WIDTH];
d899 2
a900 2
                                                      row, skipPixels);
         _mesa_unpack_stencil_span(ctx, spanWidth, destType, sValues,
d905 5
a909 1
            _mesa_unpack_depth_span(ctx, spanWidth, GL_UNSIGNED_INT, zValues,
d931 1
a931 1
            case PIPE_FORMAT_S8_USCALED:
d933 1
a933 1
                  ubyte *dest = stmap + spanY * pt->stride + spanX;
d935 1
a935 1
                  memcpy(dest, sValues, spanWidth);
d938 1
a938 1
            case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d940 1
a940 1
                  uint *dest = (uint *) (stmap + spanY * pt->stride + spanX*4);
d943 1
a943 1
                  for (k = 0; k < spanWidth; k++) {
d948 1
a948 1
                  uint *dest = (uint *) (stmap + spanY * pt->stride + spanX*4);
d951 1
a951 1
                  for (k = 0; k < spanWidth; k++) {
d956 1
a956 1
            case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d958 1
a958 1
                  uint *dest = (uint *) (stmap + spanY * pt->stride + spanX*4);
d961 1
a961 1
                  for (k = 0; k < spanWidth; k++) {
d966 1
a966 1
                  uint *dest = (uint *) (stmap + spanY * pt->stride + spanX*4);
d969 1
a969 1
                  for (k = 0; k < spanWidth; k++) {
d974 20
d999 3
a1001 1
      skipPixels += spanWidth;
d1004 3
a1010 1
   pipe->transfer_destroy(pipe, pt);
d1038 2
d1072 22
a1108 1
   enum pipe_format stencil_format = PIPE_FORMAT_NONE;
d1110 14
d1132 6
a1137 18
   if (write_stencil) {
      enum pipe_format tex_format;
      /* can we write to stencil if not fallback */
      if (!pipe->screen->get_param(pipe->screen, PIPE_CAP_SHADER_STENCIL_EXPORT))
	 goto stencil_fallback;

      tex_format = st_choose_format(st->pipe->screen, base_format(format),
                                    GL_NONE, GL_NONE,
                                    PIPE_TEXTURE_2D,
				    0, PIPE_BIND_SAMPLER_VIEW);
      if (tex_format == PIPE_FORMAT_Z24_UNORM_S8_USCALED)
	 stencil_format = PIPE_FORMAT_X24S8_USCALED;
      else if (tex_format == PIPE_FORMAT_S8_USCALED_Z24_UNORM)
	 stencil_format = PIPE_FORMAT_S8X24_USCALED;
      else
	 stencil_format = PIPE_FORMAT_S8_USCALED;
      if (stencil_format == PIPE_FORMAT_NONE)
	 goto stencil_fallback;
a1139 5
   /* Mesa state should be up to date by now */
   assert(ctx->NewState == 0x0);

   st_validate_state(st);

d1177 8
a1184 2
	    if (write_stencil) {
	       sv[1] = st_create_texture_sampler_view_format(st->pipe, pt,
d1186 2
a1187 2
	       num_sampler_view++;
	    }
a1203 5
   return;

stencil_fallback:
   draw_stencil_pixels(ctx, x, y, width, height, format, type,
		       unpack, pixels);
d1230 3
a1232 6
   /* Get the dest renderbuffer.  If there's a wrapper, use the
    * underlying renderbuffer.
    */
   rbDraw = st_renderbuffer(ctx->DrawBuffer->_StencilBuffer);
   if (rbDraw->Base.Wrapped)
      rbDraw = st_renderbuffer(rbDraw->Base.Wrapped);
d1235 3
a1237 3
   st_read_stencil_pixels(ctx, srcx, srcy, width, height,
                          GL_STENCIL_INDEX, GL_UNSIGNED_BYTE,
                          &ctx->DefaultPacking, buffer);
d1251 1
a1251 2
   if (util_format_get_component_bits(rbDraw->format,
                                     UTIL_FORMAT_COLORSPACE_ZS, 0) != 0)
d1260 2
a1261 9
   ptDraw = pipe_get_transfer(pipe,
                              rbDraw->texture,
                              rbDraw->rtt_level,
                              rbDraw->rtt_face + rbDraw->rtt_slice,
                              usage, dstx, dsty,
                              width, height);

   assert(util_format_get_blockwidth(ptDraw->resource->format) == 1);
   assert(util_format_get_blockheight(ptDraw->resource->format) == 1);
d1264 6
a1269 1
   drawMap = pipe_transfer_map(pipe, ptDraw);
d1287 1
a1287 30
      switch (ptDraw->resource->format) {
      case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
         {
            uint *dst4 = (uint *) dst;
            int j;
            assert(usage == PIPE_TRANSFER_READ_WRITE);
            for (j = 0; j < width; j++) {
               *dst4 = (*dst4 & 0xffffff) | (src[j] << 24);
               dst4++;
            }
         }
         break;
      case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
         {
            uint *dst4 = (uint *) dst;
            int j;
            assert(usage == PIPE_TRANSFER_READ_WRITE);
            for (j = 0; j < width; j++) {
               *dst4 = (*dst4 & 0xffffff00) | (src[j] & 0xff);
               dst4++;
            }
         }
         break;
      case PIPE_FORMAT_S8_USCALED:
         assert(usage == PIPE_TRANSFER_WRITE);
         memcpy(dst, src, width);
         break;
      default:
         assert(0);
      }
a1293 1
   pipe->transfer_destroy(pipe, ptDraw);
d1297 22
a1318 4
/** Do the src/dest regions overlap? */
static GLboolean
regions_overlap(GLint srcX, GLint srcY, GLint dstX, GLint dstY,
                GLsizei width, GLsizei height)
d1320 13
a1332 7
   if (srcX + width <= dstX ||
       dstX + width <= srcX ||
       srcY + height <= dstY ||
       dstY + height <= srcY)
      return GL_FALSE;
   else
      return GL_TRUE;
d1338 1
a1338 1
 * pipe->resource_copy_region().
d1342 1
a1342 2
 * per-fragment ops, the src/dest regions don't overlap and the
 * src/dest pixel formats are the same.
d1351 1
d1353 1
a1353 1
   GLint readX, readY, readW, readH;
a1366 1
       st_fb_orientation(ctx->ReadBuffer) == st_fb_orientation(ctx->DrawBuffer) &&
d1368 2
a1369 1
       !ctx->Query.CondRenderQuery) {
a1370 1
      GLint drawX, drawY;
d1397 3
d1403 52
a1454 10
      if ((rbRead != rbDraw ||
           !regions_overlap(readX, readY, drawX, drawY, readW, readH)) &&
          rbRead->Base.Format == rbDraw->Base.Format) {
         struct pipe_box srcBox;

         /* flip src/dst position if needed */
         if (st_fb_orientation(ctx->ReadBuffer) == Y_0_TOP) {
            /* both buffers will have the same orientation */
            readY = ctx->ReadBuffer->Height - readY - readH;
            drawY = ctx->DrawBuffer->Height - drawY - readH;
a1455 9

         u_box_2d(readX, readY, readW, readH, &srcBox);

         pipe->resource_copy_region(pipe,
                                    rbDraw->texture,
                                    rbDraw->rtt_level, drawX, drawY, 0,
                                    rbRead->texture,
                                    rbRead->rtt_level, &srcBox);
         return GL_TRUE;
d1477 2
a1478 1
   enum pipe_format srcFormat, texFormat;
a1480 1
   GLuint sample_count;
d1486 7
d1523 2
a1524 2
	  sv[1] = st->pixel_xfer.pixelmap_sampler_view;
	  num_sampler_view++;
d1529 2
a1530 1
      rbRead = st_renderbuffer(ctx->ReadBuffer->_DepthBuffer);
d1542 1
a1542 10

   if (rbRead->Base.Wrapped)
      rbRead = st_renderbuffer(rbRead->Base.Wrapped);

   sample_count = rbRead->texture->nr_samples;
   /* I believe this would be legal, presumably would need to do a resolve
      for color, and for depth/stencil spec says to just use one of the
      depth/stencil samples per pixel? Need some transfer clarifications. */
   assert(sample_count < 2);

d1544 2
d1547 3
a1549 7
   if (screen->is_format_supported(screen, srcFormat, st->internal_target,
                                   sample_count,
                                   PIPE_BIND_SAMPLER_VIEW)) {
      texFormat = srcFormat;
   }
   else {
      /* srcFormat can't be used as a texture format */
d1551 3
a1553 4
         texFormat = st_choose_format(screen, GL_DEPTH_COMPONENT,
                                      GL_NONE, GL_NONE, st->internal_target,
				      sample_count, PIPE_BIND_DEPTH_STENCIL);
         assert(texFormat != PIPE_FORMAT_NONE);
d1556 32
a1587 5
         /* default color format */
         texFormat = st_choose_format(screen, GL_RGBA,
                                      GL_NONE, GL_NONE, st->internal_target,
                                      sample_count, PIPE_BIND_SAMPLER_VIEW);
         assert(texFormat != PIPE_FORMAT_NONE);
d1607 9
a1615 1
   _mesa_clip_readpixels(ctx, &readX, &readY, &readW, &readH, &pack);
d1619 2
a1620 2
   /* alloc temporary texture */
   pt = alloc_texture(st, width, height, texFormat);
d1630 3
a1632 13
   /* Make temporary texture which is a copy of the src region.
    */
   if (srcFormat == texFormat) {
      struct pipe_box src_box;
      u_box_2d(readX, readY, readW, readH, &src_box);
      /* copy source framebuffer surface into mipmap/texture */
      pipe->resource_copy_region(pipe,
                                 pt,                                /* dest tex */
                                 0,                                 /* dest lvl */
                                 pack.SkipPixels, pack.SkipRows, 0, /* dest pos */
                                 rbRead->texture,                   /* src tex */
                                 rbRead->rtt_level,                 /* src lvl */
                                 &src_box);
d1634 21
a1654 44
   }
   else {
      /* CPU-based fallback/conversion */
      struct pipe_transfer *ptRead =
         pipe_get_transfer(st->pipe, rbRead->texture,
                           rbRead->rtt_level,
                           rbRead->rtt_face + rbRead->rtt_slice,
                           PIPE_TRANSFER_READ,
                           readX, readY, readW, readH);
      struct pipe_transfer *ptTex;
      enum pipe_transfer_usage transfer_usage;

      if (ST_DEBUG & DEBUG_FALLBACK)
         debug_printf("%s: fallback processing\n", __FUNCTION__);

      if (type == GL_DEPTH && util_format_is_depth_and_stencil(pt->format))
         transfer_usage = PIPE_TRANSFER_READ_WRITE;
      else
         transfer_usage = PIPE_TRANSFER_WRITE;

      ptTex = pipe_get_transfer(st->pipe, pt, 0, 0, transfer_usage,
                                0, 0, width, height);

      /* copy image from ptRead surface to ptTex surface */
      if (type == GL_COLOR) {
         /* alternate path using get/put_tile() */
         GLfloat *buf = (GLfloat *) malloc(width * height * 4 * sizeof(GLfloat));
         enum pipe_format readFormat, drawFormat;
         readFormat = util_format_linear(rbRead->texture->format);
         drawFormat = util_format_linear(pt->format);
         pipe_get_tile_rgba_format(pipe, ptRead, 0, 0, readW, readH,
                                   readFormat, buf);
         pipe_put_tile_rgba_format(pipe, ptTex, pack.SkipPixels, pack.SkipRows,
                                   readW, readH, drawFormat, buf);
         free(buf);
      }
      else {
         /* GL_DEPTH */
         GLuint *buf = (GLuint *) malloc(width * height * sizeof(GLuint));
         pipe_get_tile_z(pipe, ptRead, 0, 0, readW, readH, buf);
         pipe_put_tile_z(pipe, ptTex, pack.SkipPixels, pack.SkipRows,
                         readW, readH, buf);
         free(buf);
      }
d1656 1
a1656 2
      pipe->transfer_destroy(pipe, ptRead);
      pipe->transfer_destroy(pipe, ptTex);
d1695 1
a1695 1
      ureg_free_tokens(st->drawpix.vert_shaders[0]);
d1697 1
a1697 1
      ureg_free_tokens(st->drawpix.vert_shaders[1]);
a1698 2

#endif /* FEATURE_drawpix */
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d37 2
d40 1
d42 1
d101 2
a102 1
 * \return pointer to Gallium driver fragment shader
d104 4
a107 2
static void *
combined_drawpix_fragment_program(struct gl_context *ctx)
d109 1
a109 2
   struct st_context *st = st_context(ctx);
   struct st_fragment_program *stfp;
d111 3
a113 6
   if (st->pixel_xfer.program->serialNo == st->pixel_xfer.xfer_prog_sn
       && st->fp->serialNo == st->pixel_xfer.user_prog_sn) {
      /* the pixel tranfer program has not changed and the user-defined
       * program has not changed, so re-use the combined program.
       */
      stfp = st->pixel_xfer.combined_prog;
a115 8
      /* Concatenate the pixel transfer program with the current user-
       * defined program.
       */
      if (is_passthrough_program(&st->fp->Base)) {
         stfp = (struct st_fragment_program *)
            _mesa_clone_fragment_program(ctx, &st->pixel_xfer.program->Base);
      }
      else {
d117 5
a121 4
         printf("Base program:\n");
         _mesa_print_program(&st->fp->Base.Base);
         printf("DrawPix program:\n");
         _mesa_print_program(&st->pixel_xfer.program->Base.Base);
d123 4
a126 5
         stfp = (struct st_fragment_program *)
            _mesa_combine_programs(ctx,
                                   &st->pixel_xfer.program->Base.Base,
                                   &st->fp->Base.Base);
      }
d129 6
a134 8
      {
         struct gl_program *p = &stfp->Base.Base;
         printf("Combined DrawPixels program:\n");
         _mesa_print_program(p);
         printf("InputsRead: 0x%x\n", p->InputsRead);
         printf("OutputsWritten: 0x%x\n", p->OutputsWritten);
         _mesa_print_parameter_list(p->Parameters);
      }
d137 1
a137 18
      /* translate to TGSI tokens */
      st_translate_fragment_program(st, stfp);

      /* save new program, update serial numbers */
      st->pixel_xfer.xfer_prog_sn = st->pixel_xfer.program->serialNo;
      st->pixel_xfer.user_prog_sn = st->fp->serialNo;
      st->pixel_xfer.combined_prog_sn = stfp->serialNo;
      /* can't reference new program directly, already have a reference on it */
      st_reference_fragprog(st, &st->pixel_xfer.combined_prog, NULL);
      st->pixel_xfer.combined_prog = stfp;
   }

   /* Ideally we'd have updated the pipe constants during the normal
    * st/atom mechanism.  But we can't since this is specific to glDrawPixels.
    */
   st_upload_constants(st, stfp->Base.Base.Parameters, PIPE_SHADER_FRAGMENT);

   return stfp->driver_shader;
d142 1
a142 1
 * Create fragment shader that does a TEX() instruction to get a Z and/or
d146 1
a146 1
 * \return pointer to the Gallium driver fragment shader
d148 4
a151 3
static void *
make_fragment_shader_z_stencil(struct st_context *st, GLboolean write_depth,
                               GLboolean write_stencil)
d155 1
a155 1
   struct st_fragment_program *stp;
d163 1
a163 1
      return st->drawpix.shaders[shaderIndex]->driver_shader;
d217 1
a217 1
      p->OutputsWritten |= (1 << FRAG_RESULT_DEPTH);
d219 1
a219 1
      p->OutputsWritten |= (1 << FRAG_RESULT_STENCIL);
d225 1
a225 1
   stp = st_fragment_program((struct gl_fragment_program *) p);
d228 1
a228 1
   st->drawpix.shaders[shaderIndex] = stp;
d230 1
a230 3
   st_translate_fragment_program(st, stp);

   return stp->driver_shader;
a233 1

d300 1
a300 1
internal_format(GLenum format, GLenum type)
d330 55
a384 1
         return GL_RGBA;
d402 1
a402 1
                          width, height, 1, PIPE_BIND_SAMPLER_VIEW);
d423 1
a423 2
   GLuint cpp;
   GLenum baseFormat, intFormat;
d425 2
a426 2
   baseFormat = base_format(format);
   intFormat = internal_format(format, type);
a433 1
   cpp = util_format_get_blocksize(pipeFormat);
d469 1
a469 1
                               baseFormat,       /* baseInternalFormat */
d579 1
d583 1
a583 1
      util_draw_vertex_buffer(pipe, buf, 0,
d628 1
d638 1
d746 1
d796 1
a796 1
   pt = pipe_get_transfer(st_context(ctx)->pipe, strb->texture,
d907 55
d978 1
d992 1
a992 1
      
d994 1
d1012 3
d1016 4
a1019 1
      driver_fp = make_fragment_shader_z_stencil(st, write_depth, write_stencil);
d1021 1
d1025 4
a1028 1
      driver_fp = combined_drawpix_fragment_program(ctx);
d1030 1
d1038 3
d1135 1
a1135 1
   ptDraw = pipe_get_transfer(st_context(ctx)->pipe,
d1204 107
d1330 1
d1340 14
d1357 4
a1360 1
      driver_fp = combined_drawpix_fragment_program(ctx);
d1362 1
d1372 4
a1375 1
      driver_fp = make_fragment_shader_z_stencil(st, GL_TRUE, GL_FALSE);
d1379 4
d1396 1
a1396 1
                                   PIPE_BIND_SAMPLER_VIEW, 0)) {
d1403 2
a1404 2
                                      st->internal_target, sample_count,
                                      PIPE_BIND_DEPTH_STENCIL);
d1409 2
a1410 1
         texFormat = st_choose_format(screen, GL_RGBA, st->internal_target,
d1452 1
a1452 1
    /* copy source framebuffer surface into mipmap/texture */
d1488 7
a1494 3
         pipe_get_tile_rgba(pipe, ptRead, 0, 0, readW, readH, buf);
         pipe_put_tile_rgba(pipe, ptTex, pack.SkipPixels, pack.SkipRows,
                            readW, readH, buf);
d1541 1
a1541 1
         st_reference_fragprog(st, &st->drawpix.shaders[i], NULL);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d37 1
d40 3
a42 2
#include "shader/program.h"
#include "shader/prog_print.h"
a43 2
#include "st_debug.h"
#include "st_context.h"
a45 1
#include "st_program.h"
d49 2
d52 1
a53 1
#include "st_inlines.h"
a56 1
#include "util/u_inlines.h"
a57 1
#include "util/u_tile.h"
d60 1
d62 1
a62 2
#include "util/u_rect.h"
#include "shader/prog_instruction.h"
d66 2
d100 1
a100 1
combined_drawpix_fragment_program(GLcontext *ctx)
d166 3
a168 2
 * Create fragment shader that does a TEX() instruction to get a Z
 * value, then writes to FRAG_RESULT_DEPTH.
d173 2
a174 1
make_fragment_shader_z(struct st_context *st)
d176 1
a176 1
   GLcontext *ctx = st->ctx;
d178 1
d180 1
d182 5
a186 2
   if (st->drawpix.z_shader) {
      return st->drawpix.z_shader->driver_shader;
d196 2
a197 1
   p->NumInstructions = 3;
d206 25
a230 18
   /* TEX result.depth, fragment.texcoord[0], texture[0], 2D; */
   p->Instructions[ic].Opcode = OPCODE_TEX;
   p->Instructions[ic].DstReg.File = PROGRAM_OUTPUT;
   p->Instructions[ic].DstReg.Index = FRAG_RESULT_DEPTH;
   p->Instructions[ic].DstReg.WriteMask = WRITEMASK_Z;
   p->Instructions[ic].SrcReg[0].File = PROGRAM_INPUT;
   p->Instructions[ic].SrcReg[0].Index = FRAG_ATTRIB_TEX0;
   p->Instructions[ic].TexSrcUnit = 0;
   p->Instructions[ic].TexSrcTarget = TEXTURE_2D_INDEX;
   ic++;

   /* MOV result.color, fragment.color */
   p->Instructions[ic].Opcode = OPCODE_MOV;
   p->Instructions[ic].DstReg.File = PROGRAM_OUTPUT;
   p->Instructions[ic].DstReg.Index = FRAG_RESULT_COLOR;
   p->Instructions[ic].SrcReg[0].File = PROGRAM_INPUT;
   p->Instructions[ic].SrcReg[0].Index = FRAG_ATTRIB_COL0;
   ic++;
d238 9
a246 2
   p->OutputsWritten = (1 << FRAG_RESULT_COLOR) | (1 << FRAG_RESULT_DEPTH);
   p->SamplersUsed = 0x1;  /* sampler 0 (bit 0) is used */
d248 1
a248 2
   st->drawpix.z_shader = (struct st_fragment_program *) p;
   st_translate_fragment_program(st, st->drawpix.z_shader);
d250 6
a255 1
   return st->drawpix.z_shader->driver_shader;
d269 1
a269 2
      struct ureg_program *ureg = 
         ureg_create( TGSI_PROCESSOR_VERTEX );
d302 2
a303 2
 * Return a texture internalFormat for drawing/copying an image
 * of the given type.
d322 59
d384 1
a384 1
static struct pipe_texture *
d390 1
a390 1
   GLcontext *ctx = st->ctx;
a391 1
   struct pipe_screen *screen = pipe->screen;
d393 1
a393 1
   struct pipe_texture *pt;
d396 1
a396 2
   GLenum baseFormat;
   int ptw, pth;
d399 1
d401 2
a402 1
   mformat = st_ChooseTextureFormat(ctx, baseFormat, format, type);
d413 2
a414 23
   /* Need to use POT texture? */
   ptw = width;
   pth = height;
   if (!screen->get_param(screen, PIPE_CAP_NPOT_TEXTURES)) {
      int l2pt, maxSize;

      l2pt = util_logbase2(width);
      if (1<<l2pt != width) {
         ptw = 1<<(l2pt+1);
      }
      l2pt = util_logbase2(height);
      if (1<<l2pt != height) {
         pth = 1<<(l2pt+1);
      }

      /* Check against maximum texture size */
      maxSize = 1 << (pipe->screen->get_param(pipe->screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS) - 1);
      assert(ptw <= maxSize);
      assert(pth <= maxSize);
   }

   pt = st_texture_create(st, PIPE_TEXTURE_2D, pipeFormat, 0, ptw, pth, 1,
                          PIPE_TEXTURE_USAGE_SAMPLER);
d430 3
a432 3
      transfer = st_no_flush_get_tex_transfer(st, pt, 0, 0, 0,
					      PIPE_TRANSFER_WRITE, 0, 0,
					      width, height);
d435 1
a435 1
      dest = screen->transfer_map(screen, transfer);
d455 2
a456 2
      screen->transfer_unmap(screen, transfer);
      screen->tex_transfer_destroy(transfer);
d477 1
a477 1
draw_quad(GLcontext *ctx, GLfloat x0, GLfloat y0, GLfloat z,
d548 1
a548 1
      struct pipe_buffer *buf;
d551 2
a552 1
      buf = pipe_buffer_create(pipe->screen, 32, PIPE_BUFFER_USAGE_VERTEX,
d554 1
a554 1
      st_no_flush_pipe_buffer_write(st, buf, 0, sizeof(verts), verts);
d560 1
a560 1
      pipe_buffer_reference(&buf, NULL);
d567 1
a567 1
draw_textured_quad(GLcontext *ctx, GLint x, GLint y, GLfloat z,
d570 2
a571 1
                   struct pipe_texture *pt,
d575 2
a576 1
                   GLboolean invertTex)
d583 1
d589 2
a590 1
   maxSize = 1 << (pipe->screen->get_param(pipe->screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS) - 1);
d597 1
a597 1
   cso_save_sampler_textures(cso);
d600 5
d615 26
d658 1
a658 1
      sampler.normalized_coords = 1;
d661 1
a661 1
      if (st->pixel_xfer.pixelmap_enabled) {
d683 2
d686 1
a686 9
   if (st->pixel_xfer.pixelmap_enabled) {
      struct pipe_texture *textures[2];
      textures[0] = pt;
      textures[1] = st->pixel_xfer.pixelmap_texture;
      pipe->set_fragment_sampler_textures(pipe, 2, textures);
   }
   else {
      pipe->set_fragment_sampler_textures(pipe, 1, &pt);
   }
d706 2
a707 2
	     (GLfloat) width / pt->width0,
	     (GLfloat) height / pt->height0);
d713 1
a713 1
   cso_restore_sampler_textures(cso);
d716 5
d724 4
d729 1
a729 1
draw_stencil_pixels(GLcontext *ctx, GLint x, GLint y,
a735 1
   struct pipe_screen *screen = pipe->screen;
d760 2
a761 1
      util_format_get_component_bits(strb->format, UTIL_FORMAT_COLORSPACE_ZS, 0) != 0)
d766 4
a769 3
   pt = st_cond_flush_get_tex_transfer(st_context(ctx), strb->texture, 0, 0, 0,
				       usage, x, y,
				       width, height);
d771 1
a771 1
   stmap = screen->transfer_map(screen, pt);
d816 2
a817 2
            switch (pt->texture->format) {
            case PIPE_FORMAT_S8_UNORM:
d824 1
a824 1
            case PIPE_FORMAT_Z24S8_UNORM:
d842 1
a842 1
            case PIPE_FORMAT_S8Z24_UNORM:
d871 2
a872 2
   screen->transfer_unmap(screen, pt);
   screen->tex_transfer_destroy(pt);
d880 2
a881 1
st_DrawPixels(GLcontext *ctx, GLint x, GLint y, GLsizei width, GLsizei height,
d888 30
a917 6

   if (format == GL_STENCIL_INDEX ||
       format == GL_DEPTH_STENCIL) {
      draw_stencil_pixels(ctx, x, y, width, height, format, type,
                          unpack, pixels);
      return;
d925 2
a926 2
   if (format == GL_DEPTH_COMPONENT) {
      driver_fp = make_fragment_shader_z(st);
d934 4
d942 1
a942 1
      struct pipe_texture *pt
d945 22
a966 7
         draw_textured_quad(ctx, x, y, ctx->Current.RasterPos[2],
                            width, height, ctx->Pixel.ZoomX, ctx->Pixel.ZoomY,
                            pt, 
                            driver_vp, 
                            driver_fp,
                            color, GL_FALSE);
         pipe_texture_reference(&pt, NULL);
d969 5
d978 3
d982 1
a982 1
copy_stencil_pixels(GLcontext *ctx, GLint srcx, GLint srcy,
d986 2
a987 2
   struct st_renderbuffer *rbDraw = st_renderbuffer(ctx->DrawBuffer->_StencilBuffer);
   struct pipe_screen *screen = ctx->st->pipe->screen;
d1000 7
d1012 14
a1025 1
   if(util_format_get_component_bits(rbDraw->format, UTIL_FORMAT_COLORSPACE_ZS, 0) != 0)
d1029 1
a1029 1
   
d1034 6
a1039 4
   ptDraw = st_cond_flush_get_tex_transfer(st_context(ctx),
					   rbDraw->texture, 0, 0, 0,
					   usage, dstx, dsty,
					   width, height);
d1041 2
a1042 2
   assert(util_format_get_blockwidth(ptDraw->texture->format) == 1);
   assert(util_format_get_blockheight(ptDraw->texture->format) == 1);
d1045 1
a1045 1
   drawMap = screen->transfer_map(screen, ptDraw);
d1063 2
a1064 2
      switch (ptDraw->texture->format) {
      case PIPE_FORMAT_Z24S8_UNORM:
d1075 1
a1075 1
      case PIPE_FORMAT_S8Z24_UNORM:
d1086 1
a1086 1
      case PIPE_FORMAT_S8_UNORM:
d1098 2
a1099 2
   screen->transfer_unmap(screen, ptDraw);
   screen->tex_transfer_destroy(ptDraw);
d1104 1
a1104 1
st_CopyPixels(GLcontext *ctx, GLint srcx, GLint srcy,
d1113 3
a1115 1
   struct pipe_texture *pt;
a1117 1
   int ptw, pth;
d1120 1
a1122 2
   pipe->flush(pipe, PIPE_FLUSH_RENDER_CACHE, NULL);

d1136 4
d1145 1
a1145 1
      driver_fp = make_fragment_shader_z(st);
d1149 9
d1160 3
a1162 2
   if (screen->is_format_supported(screen, srcFormat, PIPE_TEXTURE_2D, 
                                   PIPE_TEXTURE_USAGE_SAMPLER, 0)) {
d1169 2
a1170 2
                                      PIPE_TEXTURE_2D, 
                                      PIPE_TEXTURE_USAGE_DEPTH_STENCIL);
d1175 2
a1176 2
         texFormat = st_choose_format(screen, GL_RGBA, PIPE_TEXTURE_2D, 
                                      PIPE_TEXTURE_USAGE_SAMPLER);
d1201 2
a1202 24
   /* Need to use POT texture? */
   ptw = width;
   pth = height;
   if (!screen->get_param(screen, PIPE_CAP_NPOT_TEXTURES)) {
      int l2pt, maxSize;

      l2pt = util_logbase2(width);
      if (1<<l2pt != width) {
         ptw = 1<<(l2pt+1);
      }
      l2pt = util_logbase2(height);
      if (1<<l2pt != height) {
         pth = 1<<(l2pt+1);
      }

      /* Check against maximum texture size */
      maxSize = 1 << (pipe->screen->get_param(pipe->screen, PIPE_CAP_MAX_TEXTURE_2D_LEVELS) - 1);
      assert(ptw <= maxSize);
      assert(pth <= maxSize);
   }

   pt = st_texture_create(st, PIPE_TEXTURE_2D, texFormat, 0,
                          ptw, pth, 1,
                          PIPE_TEXTURE_USAGE_SAMPLER);
d1206 6
d1215 10
a1224 25
      /* copy source framebuffer surface into mipmap/texture */
      struct pipe_surface *psRead = screen->get_tex_surface(screen,
                                       rbRead->texture, 0, 0, 0,
                                       PIPE_BUFFER_USAGE_GPU_READ);
      struct pipe_surface *psTex = screen->get_tex_surface(screen, pt, 0, 0, 0, 
                                      PIPE_BUFFER_USAGE_GPU_WRITE );
      if (pipe->surface_copy) {
         pipe->surface_copy(pipe,
                            psTex,                               /* dest surf */
                            pack.SkipPixels, pack.SkipRows,      /* dest pos */
                            psRead,                              /* src surf */
                            readX, readY, readW, readH);         /* src region */
      } else {
         util_surface_copy(pipe, FALSE,
                           psTex,
                           pack.SkipPixels, pack.SkipRows,
                           psRead,
                           readX, readY, readW, readH);
      }

      if (0) {
         /* debug */
         debug_dump_surface("copypixsrcsurf", psRead);
         debug_dump_surface("copypixtemptex", psTex);
      }
a1225 2
      pipe_surface_reference(&psRead, NULL); 
      pipe_surface_reference(&psTex, NULL);
d1230 5
a1234 3
         st_cond_flush_get_tex_transfer(st, rbRead->texture, 0, 0, 0,
                                        PIPE_TRANSFER_READ,
                                        readX, readY, readW, readH);
d1246 2
a1247 2
      ptTex = st_cond_flush_get_tex_transfer(st, pt, 0, 0, 0, transfer_usage,
                                             0, 0, width, height);
d1253 2
a1254 2
         pipe_get_tile_rgba(ptRead, readX, readY, readW, readH, buf);
         pipe_put_tile_rgba(ptTex, pack.SkipPixels, pack.SkipRows,
d1261 3
a1263 3
         pipe_get_tile_z(ptRead, readX, readY, readW, readH, buf);
         pipe_put_tile_z(ptTex, pack.SkipPixels, pack.SkipRows,
                            readW, readH, buf);
d1267 2
a1268 2
      screen->tex_transfer_destroy(ptRead);
      screen->tex_transfer_destroy(ptTex);
d1276 2
a1277 1
                      pt, 
d1280 1
a1280 1
                      color, invertTex);
d1282 2
a1283 1
   pipe_texture_reference(&pt, NULL);
d1298 7
a1304 1
   st_reference_fragprog(st, &st->drawpix.z_shader, NULL);
d1307 1
a1307 1
      free(st->drawpix.vert_shaders[0]);
d1309 1
a1309 1
      free(st->drawpix.vert_shaders[1]);
d1311 2
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a36 1
#include "main/pack.h"
d39 2
a40 3
#include "program/program.h"
#include "program/prog_print.h"
#include "program/prog_instruction.h"
d42 2
d46 1
a49 2
#include "st_context.h"
#include "st_debug.h"
a50 1
#include "st_program.h"
d52 1
d56 1
d58 1
a60 1
#include "util/u_inlines.h"
d62 2
a63 1
#include "util/u_tile.h"
a66 2
#if FEATURE_drawpix

d99 1
a99 1
combined_drawpix_fragment_program(struct gl_context *ctx)
d165 2
a166 3
 * Create fragment shader that does a TEX() instruction to get a Z and/or
 * stencil value value, then writes to FRAG_RESULT_DEPTH/FRAG_RESULT_STENCIL.
 * Used for glDrawPixels(GL_DEPTH_COMPONENT / GL_STENCIL_INDEX).
d171 1
a171 2
make_fragment_shader_z_stencil(struct st_context *st, GLboolean write_depth,
                               GLboolean write_stencil)
d173 1
a173 1
   struct gl_context *ctx = st->ctx;
a174 1
   struct st_fragment_program *stp;
a175 1
   const GLuint shaderIndex = write_depth * 2 + write_stencil;
d177 2
a178 5
   assert(shaderIndex < Elements(st->drawpix.shaders));

   if (st->drawpix.shaders[shaderIndex]) {
      /* already have the proper shader */
      return st->drawpix.shaders[shaderIndex]->driver_shader;
d188 1
a188 2
   p->NumInstructions = write_depth ? 2 : 1;
   p->NumInstructions += write_stencil ? 1 : 0;
d197 18
a214 25
   if (write_depth) {
      /* TEX result.depth, fragment.texcoord[0], texture[0], 2D; */
      p->Instructions[ic].Opcode = OPCODE_TEX;
      p->Instructions[ic].DstReg.File = PROGRAM_OUTPUT;
      p->Instructions[ic].DstReg.Index = FRAG_RESULT_DEPTH;
      p->Instructions[ic].DstReg.WriteMask = WRITEMASK_Z;
      p->Instructions[ic].SrcReg[0].File = PROGRAM_INPUT;
      p->Instructions[ic].SrcReg[0].Index = FRAG_ATTRIB_TEX0;
      p->Instructions[ic].TexSrcUnit = 0;
      p->Instructions[ic].TexSrcTarget = TEXTURE_2D_INDEX;
      ic++;
   }

   if (write_stencil) {
      /* TEX result.stencil, fragment.texcoord[0], texture[0], 2D; */
      p->Instructions[ic].Opcode = OPCODE_TEX;
      p->Instructions[ic].DstReg.File = PROGRAM_OUTPUT;
      p->Instructions[ic].DstReg.Index = FRAG_RESULT_STENCIL;
      p->Instructions[ic].DstReg.WriteMask = WRITEMASK_Y;
      p->Instructions[ic].SrcReg[0].File = PROGRAM_INPUT;
      p->Instructions[ic].SrcReg[0].Index = FRAG_ATTRIB_TEX0;
      p->Instructions[ic].TexSrcUnit = 1;
      p->Instructions[ic].TexSrcTarget = TEXTURE_2D_INDEX;
      ic++;
   }
d222 2
a223 9
   p->OutputsWritten = 0;
   if (write_depth)
      p->OutputsWritten |= (1 << FRAG_RESULT_DEPTH);
   if (write_stencil)
      p->OutputsWritten |= (1 << FRAG_RESULT_STENCIL);

   p->SamplersUsed =  0x1;  /* sampler 0 (bit 0) is used */
   if (write_stencil)
      p->SamplersUsed |= 1 << 1;
d225 2
a226 1
   stp = st_fragment_program((struct gl_fragment_program *) p);
d228 1
a228 6
   /* save the new shader */
   st->drawpix.shaders[shaderIndex] = stp;

   st_translate_fragment_program(st, stp);

   return stp->driver_shader;
d242 2
a243 1
      struct ureg_program *ureg = ureg_create( TGSI_PROCESSOR_VERTEX );
d276 2
a277 2
 * Return a texture base format for drawing/copying an image
 * of the given format.
a295 59
 * Return a texture internalFormat for drawing/copying an image
 * of the given format and type.
 */
static GLenum
internal_format(GLenum format, GLenum type)
{
   switch (format) {
   case GL_DEPTH_COMPONENT:
      return GL_DEPTH_COMPONENT;
   case GL_DEPTH_STENCIL:
      return GL_DEPTH_STENCIL;
   case GL_STENCIL_INDEX:
      return GL_STENCIL_INDEX;
   default:
      if (_mesa_is_integer_format(format)) {
         switch (type) {
         case GL_BYTE:
            return GL_RGBA8I;
         case GL_UNSIGNED_BYTE:
            return GL_RGBA8UI;
         case GL_SHORT:
            return GL_RGBA16I;
         case GL_UNSIGNED_SHORT:
            return GL_RGBA16UI;
         case GL_INT:
            return GL_RGBA32I;
         case GL_UNSIGNED_INT:
            return GL_RGBA32UI;
         default:
            assert(0 && "Unexpected type in internal_format()");
            return GL_RGBA_INTEGER;
         }
      }
      else {
         return GL_RGBA;
      }
   }
}


/**
 * Create a temporary texture to hold an image of the given size.
 * If width, height are not POT and the driver only handles POT textures,
 * allocate the next larger size of texture that is POT.
 */
static struct pipe_resource *
alloc_texture(struct st_context *st, GLsizei width, GLsizei height,
              enum pipe_format texFormat)
{
   struct pipe_resource *pt;

   pt = st_texture_create(st, st->internal_target, texFormat, 0,
                          width, height, 1, PIPE_BIND_SAMPLER_VIEW);

   return pt;
}


/**
d299 1
a299 1
static struct pipe_resource *
d305 1
a305 1
   struct gl_context *ctx = st->ctx;
d307 1
d309 1
a309 1
   struct pipe_resource *pt;
d312 2
a313 1
   GLenum baseFormat, intFormat;
a315 1
   intFormat = internal_format(format, type);
d317 1
a317 2
   mformat = st_ChooseTextureFormat_renderable(ctx, intFormat,
                                               format, type, GL_FALSE);
d328 23
a350 2
   /* alloc temporary texture */
   pt = alloc_texture(st, width, height, pipeFormat);
d366 3
a368 3
      transfer = pipe_get_transfer(st->pipe, pt, 0, 0,
                                   PIPE_TRANSFER_WRITE, 0, 0,
                                   width, height);
d371 1
a371 1
      dest = pipe_transfer_map(pipe, transfer);
d391 2
a392 2
      pipe_transfer_unmap(pipe, transfer);
      pipe->transfer_destroy(pipe, transfer);
d413 1
a413 1
draw_quad(struct gl_context *ctx, GLfloat x0, GLfloat y0, GLfloat z,
d484 1
a484 1
      struct pipe_resource *buf;
d487 1
a487 2
      buf = pipe_buffer_create(pipe->screen,
			       PIPE_BIND_VERTEX_BUFFER,
d489 1
a489 1
      pipe_buffer_write(st->pipe, buf, 0, sizeof(verts), verts);
d495 1
a495 1
      pipe_resource_reference(&buf, NULL);
d502 1
a502 1
draw_textured_quad(struct gl_context *ctx, GLint x, GLint y, GLfloat z,
d505 1
a505 2
                   struct pipe_sampler_view **sv,
                   int num_sampler_view,
d509 1
a509 2
                   GLboolean invertTex,
                   GLboolean write_depth, GLboolean write_stencil)
a515 1
   boolean normalized = sv[0]->texture->target != PIPE_TEXTURE_RECT;
d521 1
a521 2
   maxSize = 1 << (pipe->screen->get_param(pipe->screen,
                                        PIPE_CAP_MAX_TEXTURE_2D_LEVELS) - 1);
d528 1
a528 1
   cso_save_fragment_sampler_views(cso);
a530 5
   cso_save_vertex_elements(cso);
   if (write_stencil) {
      cso_save_depth_stencil_alpha(cso);
      cso_save_blend(cso);
   }
a540 26
   if (write_stencil) {
      /* Stencil writing bypasses the normal fragment pipeline to
       * disable color writing and set stencil test to always pass.
       */
      struct pipe_depth_stencil_alpha_state dsa;
      struct pipe_blend_state blend;

      /* depth/stencil */
      memset(&dsa, 0, sizeof(dsa));
      dsa.stencil[0].enabled = 1;
      dsa.stencil[0].func = PIPE_FUNC_ALWAYS;
      dsa.stencil[0].writemask = ctx->Stencil.WriteMask[0] & 0xff;
      dsa.stencil[0].zpass_op = PIPE_STENCIL_OP_REPLACE;
      if (write_depth) {
         /* writing depth+stencil: depth test always passes */
         dsa.depth.enabled = 1;
         dsa.depth.writemask = ctx->Depth.Mask;
         dsa.depth.func = PIPE_FUNC_ALWAYS;
      }
      cso_set_depth_stencil_alpha(cso, &dsa);

      /* blend (colormask) */
      memset(&blend, 0, sizeof(blend));
      cso_set_blend(cso, &blend);
   }

d558 1
a558 1
      sampler.normalized_coords = normalized;
d561 1
a561 1
      if (num_sampler_view > 1) {
a582 2
   cso_set_vertex_elements(cso, 3, st->velems_util_draw);

d584 9
a592 1
   cso_set_fragment_sampler_views(cso, num_sampler_view, sv);
d612 2
a613 2
             normalized ? ((GLfloat) width / sv[0]->texture->width0) : (GLfloat)width,
             normalized ? ((GLfloat) height / sv[0]->texture->height0) : (GLfloat)height);
d619 1
a619 1
   cso_restore_fragment_sampler_views(cso);
a621 5
   cso_restore_vertex_elements(cso);
   if (write_stencil) {
      cso_restore_depth_stencil_alpha(cso);
      cso_restore_blend(cso);
   }
a624 4
/**
 * Software fallback to do glDrawPixels(GL_STENCIL_INDEX) when we
 * can't use a fragment shader to write stencil values.
 */
d626 1
a626 1
draw_stencil_pixels(struct gl_context *ctx, GLint x, GLint y,
d633 1
d658 1
a658 2
      util_format_get_component_bits(strb->format,
                                     UTIL_FORMAT_COLORSPACE_ZS, 0) != 0)
d663 3
a665 4
   pt = pipe_get_transfer(st_context(ctx)->pipe, strb->texture,
                          strb->rtt_level, strb->rtt_face + strb->rtt_slice,
                          usage, x, y,
                          width, height);
d667 1
a667 1
   stmap = pipe_transfer_map(pipe, pt);
d712 2
a713 2
            switch (pt->resource->format) {
            case PIPE_FORMAT_S8_USCALED:
d720 1
a720 1
            case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d738 1
a738 1
            case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d767 2
a768 2
   pipe_transfer_unmap(pipe, pt);
   pipe->transfer_destroy(pipe, pt);
d776 1
a776 2
st_DrawPixels(struct gl_context *ctx, GLint x, GLint y,
              GLsizei width, GLsizei height,
d783 6
a788 30
   struct pipe_context *pipe = st->pipe;
   GLboolean write_stencil = GL_FALSE, write_depth = GL_FALSE;
   struct pipe_sampler_view *sv[2];
   int num_sampler_view = 1;
   enum pipe_format stencil_format = PIPE_FORMAT_NONE;

   if (format == GL_DEPTH_STENCIL)
      write_stencil = write_depth = GL_TRUE;
   else if (format == GL_STENCIL_INDEX)
      write_stencil = GL_TRUE;
   else if (format == GL_DEPTH_COMPONENT)
      write_depth = GL_TRUE;

   if (write_stencil) {
      enum pipe_format tex_format;
      /* can we write to stencil if not fallback */
      if (!pipe->screen->get_param(pipe->screen, PIPE_CAP_SHADER_STENCIL_EXPORT))
	 goto stencil_fallback;
      
      tex_format = st_choose_format(st->pipe->screen, base_format(format),
                                    PIPE_TEXTURE_2D,
				    0, PIPE_BIND_SAMPLER_VIEW);
      if (tex_format == PIPE_FORMAT_Z24_UNORM_S8_USCALED)
	 stencil_format = PIPE_FORMAT_X24S8_USCALED;
      else if (tex_format == PIPE_FORMAT_S8_USCALED_Z24_UNORM)
	 stencil_format = PIPE_FORMAT_S8X24_USCALED;
      else
	 stencil_format = PIPE_FORMAT_S8_USCALED;
      if (stencil_format == PIPE_FORMAT_NONE)
	 goto stencil_fallback;
d796 2
a797 2
   if (write_depth || write_stencil) {
      driver_fp = make_fragment_shader_z_stencil(st, write_depth, write_stencil);
a804 4
      if (st->pixel_xfer.pixelmap_enabled) {
	  sv[1] = st->pixel_xfer.pixelmap_sampler_view;
	  num_sampler_view++;
      }
d809 1
a809 1
      struct pipe_resource *pt
d812 7
a818 22
         sv[0] = st_create_texture_sampler_view(st->pipe, pt);

         if (sv[0]) {
	    if (write_stencil) {
	       sv[1] = st_create_texture_sampler_view_format(st->pipe, pt,
                                                             stencil_format);
	       num_sampler_view++;
	    }

            draw_textured_quad(ctx, x, y, ctx->Current.RasterPos[2],
                               width, height,
                               ctx->Pixel.ZoomX, ctx->Pixel.ZoomY,
                               sv,
                               num_sampler_view,
                               driver_vp,
                               driver_fp,
                               color, GL_FALSE, write_depth, write_stencil);
            pipe_sampler_view_reference(&sv[0], NULL);
            if (num_sampler_view > 1)
               pipe_sampler_view_reference(&sv[1], NULL);
         }
         pipe_resource_reference(&pt, NULL);
a820 5
   return;

stencil_fallback:
   draw_stencil_pixels(ctx, x, y, width, height, format, type,
		       unpack, pixels);
a824 3
/**
 * Software fallback for glCopyPixels(GL_STENCIL).
 */
d826 1
a826 1
copy_stencil_pixels(struct gl_context *ctx, GLint srcx, GLint srcy,
d830 2
a831 2
   struct st_renderbuffer *rbDraw;
   struct pipe_context *pipe = st_context(ctx)->pipe;
a843 7
   /* Get the dest renderbuffer.  If there's a wrapper, use the
    * underlying renderbuffer.
    */
   rbDraw = st_renderbuffer(ctx->DrawBuffer->_StencilBuffer);
   if (rbDraw->Base.Wrapped)
      rbDraw = st_renderbuffer(rbDraw->Base.Wrapped);

d849 1
a849 14
   if (0) {
      /* debug code: dump stencil values */
      GLint row, col;
      for (row = 0; row < height; row++) {
         printf("%3d: ", row);
         for (col = 0; col < width; col++) {
            printf("%02x ", buffer[col + row * width]);
         }
         printf("\n");
      }
   }

   if (util_format_get_component_bits(rbDraw->format,
                                     UTIL_FORMAT_COLORSPACE_ZS, 0) != 0)
d853 1
a853 1

d858 4
a861 6
   ptDraw = pipe_get_transfer(st_context(ctx)->pipe,
                              rbDraw->texture,
                              rbDraw->rtt_level,
                              rbDraw->rtt_face + rbDraw->rtt_slice,
                              usage, dstx, dsty,
                              width, height);
d863 2
a864 2
   assert(util_format_get_blockwidth(ptDraw->resource->format) == 1);
   assert(util_format_get_blockheight(ptDraw->resource->format) == 1);
d867 1
a867 1
   drawMap = pipe_transfer_map(pipe, ptDraw);
d885 2
a886 2
      switch (ptDraw->resource->format) {
      case PIPE_FORMAT_Z24_UNORM_S8_USCALED:
d897 1
a897 1
      case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
d908 1
a908 1
      case PIPE_FORMAT_S8_USCALED:
d920 2
a921 2
   pipe_transfer_unmap(pipe, ptDraw);
   pipe->transfer_destroy(pipe, ptDraw);
d926 1
a926 1
st_CopyPixels(struct gl_context *ctx, GLint srcx, GLint srcy,
d935 1
a935 3
   struct pipe_resource *pt;
   struct pipe_sampler_view *sv[2];
   int num_sampler_view = 1;
d938 1
a940 1
   GLuint sample_count;
d943 2
a957 4
      if (st->pixel_xfer.pixelmap_enabled) {
	  sv[1] = st->pixel_xfer.pixelmap_sampler_view;
	  num_sampler_view++;
      }
d963 1
a963 1
      driver_fp = make_fragment_shader_z_stencil(st, GL_TRUE, GL_FALSE);
a966 9
   if (rbRead->Base.Wrapped)
      rbRead = st_renderbuffer(rbRead->Base.Wrapped);

   sample_count = rbRead->texture->nr_samples;
   /* I believe this would be legal, presumably would need to do a resolve
      for color, and for depth/stencil spec says to just use one of the
      depth/stencil samples per pixel? Need some transfer clarifications. */
   assert(sample_count < 2);

d969 2
a970 3
   if (screen->is_format_supported(screen, srcFormat, st->internal_target,
                                   sample_count,
                                   PIPE_BIND_SAMPLER_VIEW, 0)) {
d977 2
a978 2
                                      st->internal_target, sample_count,
                                      PIPE_BIND_DEPTH_STENCIL);
d983 2
a984 2
         texFormat = st_choose_format(screen, GL_RGBA, st->internal_target,
                                      sample_count, PIPE_BIND_SAMPLER_VIEW);
d1009 24
a1032 2
   /* alloc temporary texture */
   pt = alloc_texture(st, width, height, texFormat);
a1035 6
   sv[0] = st_create_texture_sampler_view(st->pipe, pt);
   if (!sv[0]) {
      pipe_resource_reference(&pt, NULL);
      return;
   }

d1039 25
a1063 10
      struct pipe_box src_box;
      u_box_2d(readX, readY, readW, readH, &src_box);
    /* copy source framebuffer surface into mipmap/texture */
      pipe->resource_copy_region(pipe,
                                 pt,                                /* dest tex */
                                 0,                                 /* dest lvl */
                                 pack.SkipPixels, pack.SkipRows, 0, /* dest pos */
                                 rbRead->texture,                   /* src tex */
                                 rbRead->rtt_level,                 /* src lvl */
                                 &src_box);
d1065 2
d1071 3
a1073 5
         pipe_get_transfer(st->pipe, rbRead->texture,
                           rbRead->rtt_level,
                           rbRead->rtt_face + rbRead->rtt_slice,
                           PIPE_TRANSFER_READ,
                           readX, readY, readW, readH);
d1085 2
a1086 2
      ptTex = pipe_get_transfer(st->pipe, pt, 0, 0, transfer_usage,
                                0, 0, width, height);
d1092 2
a1093 2
         pipe_get_tile_rgba(pipe, ptRead, 0, 0, readW, readH, buf);
         pipe_put_tile_rgba(pipe, ptTex, pack.SkipPixels, pack.SkipRows,
d1100 3
a1102 3
         pipe_get_tile_z(pipe, ptRead, 0, 0, readW, readH, buf);
         pipe_put_tile_z(pipe, ptTex, pack.SkipPixels, pack.SkipRows,
                         readW, readH, buf);
d1106 2
a1107 2
      pipe->transfer_destroy(pipe, ptRead);
      pipe->transfer_destroy(pipe, ptTex);
d1115 1
a1115 2
                      sv,
                      num_sampler_view,
d1118 1
a1118 1
                      color, invertTex, GL_FALSE, GL_FALSE);
d1120 1
a1120 2
   pipe_resource_reference(&pt, NULL);
   pipe_sampler_view_reference(&sv[0], NULL);
d1135 1
a1135 7
   GLuint i;

   for (i = 0; i < Elements(st->drawpix.shaders); i++) {
      if (st->drawpix.shaders[i])
         st_reference_fragprog(st, &st->drawpix.shaders[i], NULL);
   }

d1138 1
a1138 1
      ureg_free_tokens(st->drawpix.vert_shaders[0]);
d1140 1
a1140 1
      ureg_free_tokens(st->drawpix.vert_shaders[1]);
a1141 2

#endif /* FEATURE_drawpix */
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a35 1
#include "main/format_pack.h"
a36 1
#include "main/mtypes.h"
a37 2
#include "main/pbo.h"
#include "main/readpix.h"
a38 1
#include "main/teximage.h"
a39 1
#include "main/glformats.h"
a62 1
#include "util/u_upload_mgr.h"
d66 2
d84 1
a84 1
          inst[0].SrcReg[0].Index == VARYING_SLOT_COL0 &&
a92 40
/**
 * Returns a fragment program which implements the current pixel transfer ops.
 */
static struct gl_fragment_program *
get_glsl_pixel_transfer_program(struct st_context *st,
                                struct st_fragment_program *orig)
{
   int pixelMaps = 0, scaleAndBias = 0;
   struct gl_context *ctx = st->ctx;
   struct st_fragment_program *fp = (struct st_fragment_program *)
      ctx->Driver.NewProgram(ctx, GL_FRAGMENT_PROGRAM_ARB, 0);

   if (!fp)
      return NULL;

   if (ctx->Pixel.RedBias != 0.0 || ctx->Pixel.RedScale != 1.0 ||
       ctx->Pixel.GreenBias != 0.0 || ctx->Pixel.GreenScale != 1.0 ||
       ctx->Pixel.BlueBias != 0.0 || ctx->Pixel.BlueScale != 1.0 ||
       ctx->Pixel.AlphaBias != 0.0 || ctx->Pixel.AlphaScale != 1.0) {
      scaleAndBias = 1;
   }

   pixelMaps = ctx->Pixel.MapColorFlag;

   if (pixelMaps) {
      /* create the colormap/texture now if not already done */
      if (!st->pixel_xfer.pixelmap_texture) {
         st->pixel_xfer.pixelmap_texture = st_create_color_map_texture(ctx);
         st->pixel_xfer.pixelmap_sampler_view =
            st_create_texture_sampler_view(st->pipe,
                                           st->pixel_xfer.pixelmap_texture);
      }
   }

   get_pixel_transfer_visitor(fp, orig->glsl_to_tgsi,
                              scaleAndBias, pixelMaps);

   return &fp->Base;
}

d97 1
a97 2
 * \param fpIn  the current/incoming fragment program
 * \param fpOut  returns the combined fragment program
d99 2
a100 4
void
st_make_drawpix_fragment_program(struct st_context *st,
                                 struct gl_fragment_program *fpIn,
                                 struct gl_fragment_program **fpOut)
d102 2
a103 2
   struct gl_program *newProg;
   struct st_fragment_program *stfp = (struct st_fragment_program *) fpIn;
d105 6
a110 6
   if (is_passthrough_program(fpIn)) {
      newProg = (struct gl_program *) _mesa_clone_fragment_program(st->ctx,
                                             &st->pixel_xfer.program->Base);
   }
   else if (stfp->glsl_to_tgsi != NULL) {
      newProg = (struct gl_program *) get_glsl_pixel_transfer_program(st, stfp);
d113 8
d122 4
a125 5
      /* debug */
      printf("Base program:\n");
      _mesa_print_program(&fpIn->Base);
      printf("DrawPix program:\n");
      _mesa_print_program(&st->pixel_xfer.program->Base.Base);
d127 5
a131 4
      newProg = _mesa_combine_programs(st->ctx,
                                       &st->pixel_xfer.program->Base.Base,
                                       &fpIn->Base);
   }
d134 8
a141 6
   /* debug */
   printf("Combined DrawPixels program:\n");
   _mesa_print_program(newProg);
   printf("InputsRead: 0x%x\n", newProg->InputsRead);
   printf("OutputsWritten: 0x%x\n", newProg->OutputsWritten);
   _mesa_print_parameter_list(newProg->Parameters);
d144 18
a161 1
   *fpOut = (struct gl_fragment_program *) newProg;
d166 1
a166 1
 * Create fragment program that does a TEX() instruction to get a Z and/or
d170 1
a170 1
 * \return pointer to the gl_fragment program
d172 3
a174 4
struct gl_fragment_program *
st_make_drawpix_z_stencil_program(struct st_context *st,
                                  GLboolean write_depth,
                                  GLboolean write_stencil)
d178 1
a178 1
   struct gl_fragment_program *fp;
d186 1
a186 1
      return st->drawpix.shaders[shaderIndex];
d196 1
a196 1
   p->NumInstructions = write_depth ? 3 : 1;
d213 1
a213 1
      p->Instructions[ic].SrcReg[0].Index = VARYING_SLOT_TEX0;
a216 7
      /* MOV result.color, fragment.color; */
      p->Instructions[ic].Opcode = OPCODE_MOV;
      p->Instructions[ic].DstReg.File = PROGRAM_OUTPUT;
      p->Instructions[ic].DstReg.Index = FRAG_RESULT_COLOR;
      p->Instructions[ic].SrcReg[0].File = PROGRAM_INPUT;
      p->Instructions[ic].SrcReg[0].Index = VARYING_SLOT_COL0;
      ic++;
d226 1
a226 1
      p->Instructions[ic].SrcReg[0].Index = VARYING_SLOT_TEX0;
d237 1
a237 1
   p->InputsRead = VARYING_BIT_TEX0 | VARYING_BIT_COL0;
d239 2
a240 4
   if (write_depth) {
      p->OutputsWritten |= BITFIELD64_BIT(FRAG_RESULT_DEPTH);
      p->OutputsWritten |= BITFIELD64_BIT(FRAG_RESULT_COLOR);
   }
d242 1
a242 1
      p->OutputsWritten |= BITFIELD64_BIT(FRAG_RESULT_STENCIL);
d248 1
a248 1
   fp = (struct gl_fragment_program *) p;
d251 3
a253 1
   st->drawpix.shaders[shaderIndex] = fp;
d255 1
a255 1
   return fp;
d259 1
a267 3
   const unsigned texcoord_semantic = st->needs_texcoord_semantic ?
      TGSI_SEMANTIC_TEXCOORD : TGSI_SEMANTIC_GENERIC;

d281 1
a281 1
               ureg_DECL_output( ureg, texcoord_semantic, 0 ),
d302 20
d326 1
a326 1
internal_format(struct gl_context *ctx, GLenum format, GLenum type)
d330 1
a330 17
      switch (type) {
      case GL_UNSIGNED_SHORT:
         return GL_DEPTH_COMPONENT16;

      case GL_UNSIGNED_INT:
         return GL_DEPTH_COMPONENT32;

      case GL_FLOAT:
         if (ctx->Extensions.ARB_depth_buffer_float)
            return GL_DEPTH_COMPONENT32F;
         else
            return GL_DEPTH_COMPONENT;

      default:
         return GL_DEPTH_COMPONENT;
      }

d332 1
a332 9
      switch (type) {
      case GL_FLOAT_32_UNSIGNED_INT_24_8_REV:
         return GL_DEPTH32F_STENCIL8;

      case GL_UNSIGNED_INT_24_8:
      default:
         return GL_DEPTH24_STENCIL8;
      }

a334 1

d336 1
a336 1
      if (_mesa_is_enum_format_integer(format)) {
d356 1
a356 59
         switch (type) {
         case GL_UNSIGNED_BYTE:
         case GL_UNSIGNED_INT_8_8_8_8:
         case GL_UNSIGNED_INT_8_8_8_8_REV:
         default:
            return GL_RGBA8;

         case GL_UNSIGNED_BYTE_3_3_2:
         case GL_UNSIGNED_BYTE_2_3_3_REV:
            return GL_R3_G3_B2;

         case GL_UNSIGNED_SHORT_4_4_4_4:
         case GL_UNSIGNED_SHORT_4_4_4_4_REV:
            return GL_RGBA4;

         case GL_UNSIGNED_SHORT_5_6_5:
         case GL_UNSIGNED_SHORT_5_6_5_REV:
            return GL_RGB565;

         case GL_UNSIGNED_SHORT_5_5_5_1:
         case GL_UNSIGNED_SHORT_1_5_5_5_REV:
            return GL_RGB5_A1;

         case GL_UNSIGNED_INT_10_10_10_2:
         case GL_UNSIGNED_INT_2_10_10_10_REV:
            return GL_RGB10_A2;

         case GL_UNSIGNED_SHORT:
         case GL_UNSIGNED_INT:
            return GL_RGBA16;

         case GL_BYTE:
            return
               ctx->Extensions.EXT_texture_snorm ? GL_RGBA8_SNORM : GL_RGBA8;

         case GL_SHORT:
         case GL_INT:
            return
               ctx->Extensions.EXT_texture_snorm ? GL_RGBA16_SNORM : GL_RGBA16;

         case GL_HALF_FLOAT_ARB:
            return
               ctx->Extensions.ARB_texture_float ? GL_RGBA16F :
               ctx->Extensions.EXT_texture_snorm ? GL_RGBA16_SNORM : GL_RGBA16;

         case GL_FLOAT:
         case GL_DOUBLE:
            return
               ctx->Extensions.ARB_texture_float ? GL_RGBA32F :
               ctx->Extensions.EXT_texture_snorm ? GL_RGBA16_SNORM : GL_RGBA16;

         case GL_UNSIGNED_INT_5_9_9_9_REV:
            assert(ctx->Extensions.EXT_texture_shared_exponent);
            return GL_RGB9_E5;

         case GL_UNSIGNED_INT_10F_11F_11F_REV:
            assert(ctx->Extensions.EXT_packed_float);
            return GL_R11F_G11F_B10F;
         }
d369 1
a369 1
              enum pipe_format texFormat, unsigned bind)
d374 1
a374 1
                          width, height, 1, 1, 0, bind);
d395 2
a396 1
   GLenum baseInternalFormat;
d398 2
a399 5
   /* Choose a pixel format for the temp texture which will hold the
    * image to draw.
    */
   pipeFormat = st_choose_matching_format(pipe->screen, PIPE_BIND_SAMPLER_VIEW,
                                          format, type, unpack->SwapBytes);
d401 7
a407 15
   if (pipeFormat != PIPE_FORMAT_NONE) {
      mformat = st_pipe_format_to_mesa_format(pipeFormat);
      baseInternalFormat = _mesa_get_format_base_format(mformat);
   }
   else {
      /* Use the generic approach. */
      GLenum intFormat = internal_format(ctx, format, type);

      baseInternalFormat = _mesa_base_tex_format(ctx, intFormat);
      pipeFormat = st_choose_format(st, intFormat, format, type,
                                    PIPE_TEXTURE_2D, 0, PIPE_BIND_SAMPLER_VIEW,
                                    FALSE);
      assert(pipeFormat != PIPE_FORMAT_NONE);
      mformat = st_pipe_format_to_mesa_format(pipeFormat);
   }
d414 1
a414 1
   pt = alloc_texture(st, width, height, pipeFormat, PIPE_BIND_SAMPLER_VIEW);
d422 1
d430 4
d435 1
a435 3
      dest = pipe_transfer_map(pipe, pt, 0, 0,
                               PIPE_TRANSFER_WRITE, 0, 0,
                               width, height, &transfer);
d443 1
a443 1
                               baseInternalFormat, /* baseInternalFormat */
d445 2
d448 1
a448 1
                               &dest,            /* destSlices */
d456 1
d483 1
a483 8
   GLfloat (*verts)[3][4]; /* four verts, three attribs, XYZW */
   struct pipe_resource *buf = NULL;
   unsigned offset;

   if (u_upload_alloc(st->uploader, 0, 4 * sizeof(verts[0]), &offset,
                      &buf, (void **) &verts) != PIPE_OK) {
      return;
   }
d547 15
a561 8
   u_upload_unmap(st->uploader);
   util_draw_vertex_buffer(pipe, st->cso_context, buf,
                           cso_get_aux_vertex_buffer_slot(st->cso_context),
                           offset,
			   PIPE_PRIM_QUADS,
			   4,  /* verts */
			   3); /* attribs/vert */
   pipe_resource_reference(&buf, NULL);
d596 2
a597 2
   cso_save_samplers(cso, PIPE_SHADER_FRAGMENT);
   cso_save_sampler_views(cso, PIPE_SHADER_FRAGMENT);
a598 1
   cso_save_stream_outputs(cso);
a599 1
   cso_save_geometry_shader(cso);
a600 1
   cso_save_aux_vertex_buffer_slot(cso);
d610 1
a610 5
      rasterizer.clamp_fragment_color = !st->clamp_frag_color_in_shader &&
                                        ctx->Color._ClampFragmentColor;
      rasterizer.half_pixel_center = 1;
      rasterizer.bottom_edge_rule = 1;
      rasterizer.depth_clip = !ctx->Transform.DepthClamp;
a646 2
   /* geometry shader state: disabled */
   cso_set_geometry_shader_handle(cso, NULL);
d660 1
a660 1
      cso_single_sampler(cso, PIPE_SHADER_FRAGMENT, 0, &sampler);
d662 1
a662 1
         cso_single_sampler(cso, PIPE_SHADER_FRAGMENT, 1, &sampler);
d664 1
a664 1
      cso_single_sampler_done(cso, PIPE_SHADER_FRAGMENT);
a683 1
   cso_set_stream_outputs(st->cso_context, 0, NULL, 0);
d686 1
a686 1
   cso_set_sampler_views(cso, PIPE_SHADER_FRAGMENT, num_sampler_view, sv);
d703 1
a703 1
   z = z * 2.0f - 1.0f;
d712 2
a713 2
   cso_restore_samplers(cso, PIPE_SHADER_FRAGMENT);
   cso_restore_sampler_views(cso, PIPE_SHADER_FRAGMENT);
a715 1
   cso_restore_geometry_shader(cso);
a716 2
   cso_restore_aux_vertex_buffer_slot(cso);
   cso_restore_stream_outputs(cso);
d740 1
a742 2
   GLubyte *sValues;
   GLuint *zValues;
d759 3
a761 3
   if (format == GL_STENCIL_INDEX && 
       _mesa_is_format_packed_depth_stencil(strb->Base.Format)) {
      /* writing stencil to a combined depth+stencil buffer */
d763 1
a763 2
   }
   else {
a764 1
   }
d766 6
a771 4
   stmap = pipe_transfer_map(pipe, strb->texture,
                             strb->rtt_level, strb->rtt_face + strb->rtt_slice,
                             usage, x, y,
                             width, height, &pt);
d776 5
a780 4
   sValues = malloc(width * sizeof(GLubyte));
   zValues = malloc(width * sizeof(GLuint));

   if (sValues && zValues) {
d783 2
a784 1
         GLfloat *zValuesFloat = (GLfloat*)zValues;
d789 2
a790 2
                                                      row, 0);
         _mesa_unpack_stencil_span(ctx, width, destType, sValues,
d795 1
a795 5
            GLenum ztype =
               pt->resource->format == PIPE_FORMAT_Z32_FLOAT_S8X24_UINT ?
               GL_FLOAT : GL_UNSIGNED_INT;

            _mesa_unpack_depth_span(ctx, width, ztype, zValues,
d817 1
a817 1
            case PIPE_FORMAT_S8_UINT:
d819 1
a819 1
                  ubyte *dest = stmap + spanY * pt->stride;
d821 1
a821 1
                  memcpy(dest, sValues, width);
d824 1
a824 1
            case PIPE_FORMAT_Z24_UNORM_S8_UINT:
d826 1
a826 1
                  uint *dest = (uint *) (stmap + spanY * pt->stride);
d829 1
a829 1
                  for (k = 0; k < width; k++) {
d834 1
a834 1
                  uint *dest = (uint *) (stmap + spanY * pt->stride);
d837 1
a837 1
                  for (k = 0; k < width; k++) {
d842 1
a842 1
            case PIPE_FORMAT_S8_UINT_Z24_UNORM:
d844 1
a844 1
                  uint *dest = (uint *) (stmap + spanY * pt->stride);
d847 1
a847 1
                  for (k = 0; k < width; k++) {
d852 1
a852 1
                  uint *dest = (uint *) (stmap + spanY * pt->stride);
d855 1
a855 1
                  for (k = 0; k < width; k++) {
a859 20
            case PIPE_FORMAT_Z32_FLOAT_S8X24_UINT:
               if (format == GL_DEPTH_STENCIL) {
                  uint *dest = (uint *) (stmap + spanY * pt->stride);
                  GLfloat *destf = (GLfloat*)dest;
                  GLint k;
                  assert(usage == PIPE_TRANSFER_WRITE);
                  for (k = 0; k < width; k++) {
                     destf[k*2] = zValuesFloat[k];
                     dest[k*2+1] = sValues[k] & 0xff;
                  }
               }
               else {
                  uint *dest = (uint *) (stmap + spanY * pt->stride);
                  GLint k;
                  assert(usage == PIPE_TRANSFER_READ_WRITE);
                  for (k = 0; k < width; k++) {
                     dest[k*2+1] = sValues[k] & 0xff;
                  }
               }
               break;
d865 1
a865 3
   }
   else {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glDrawPixels()");
a867 3
   free(sValues);
   free(zValues);

d872 1
a872 79
}


/**
 * Get fragment program variant for a glDrawPixels or glCopyPixels
 * command for RGBA data.
 */
static struct st_fp_variant *
get_color_fp_variant(struct st_context *st)
{
   struct gl_context *ctx = st->ctx;
   struct st_fp_variant_key key;
   struct st_fp_variant *fpv;

   memset(&key, 0, sizeof(key));

   key.st = st;
   key.drawpixels = 1;
   key.scaleAndBias = (ctx->Pixel.RedBias != 0.0 ||
                       ctx->Pixel.RedScale != 1.0 ||
                       ctx->Pixel.GreenBias != 0.0 ||
                       ctx->Pixel.GreenScale != 1.0 ||
                       ctx->Pixel.BlueBias != 0.0 ||
                       ctx->Pixel.BlueScale != 1.0 ||
                       ctx->Pixel.AlphaBias != 0.0 ||
                       ctx->Pixel.AlphaScale != 1.0);
   key.pixelMaps = ctx->Pixel.MapColorFlag;
   key.clamp_color = st->clamp_frag_color_in_shader &&
                     st->ctx->Color._ClampFragmentColor;

   fpv = st_get_fp_variant(st, st->fp, &key);

   return fpv;
}


/**
 * Get fragment program variant for a glDrawPixels or glCopyPixels
 * command for depth/stencil data.
 */
static struct st_fp_variant *
get_depth_stencil_fp_variant(struct st_context *st, GLboolean write_depth,
                             GLboolean write_stencil)
{
   struct st_fp_variant_key key;
   struct st_fp_variant *fpv;

   memset(&key, 0, sizeof(key));

   key.st = st;
   key.drawpixels = 1;
   key.drawpixels_z = write_depth;
   key.drawpixels_stencil = write_stencil;

   fpv = st_get_fp_variant(st, st->fp, &key);

   return fpv;
}


/**
 * Clamp glDrawPixels width and height to the maximum texture size.
 */
static void
clamp_size(struct pipe_context *pipe, GLsizei *width, GLsizei *height,
           struct gl_pixelstore_attrib *unpack)
{
   const int maxSize =
      1 << (pipe->screen->get_param(pipe->screen,
                                    PIPE_CAP_MAX_TEXTURE_2D_LEVELS) - 1);

   if (*width > maxSize) {
      if (unpack->RowLength == 0)
         unpack->RowLength = *width;
      *width = maxSize;
   }
   if (*height > maxSize) {
      *height = maxSize;
   }
d892 1
a892 15
   struct st_fp_variant *fpv;
   struct gl_pixelstore_attrib clippedUnpack;

   /* Mesa state should be up to date by now */
   assert(ctx->NewState == 0x0);

   st_validate_state(st);

   /* Limit the size of the glDrawPixels to the max texture size.
    * Strictly speaking, that's not correct but since we don't handle
    * larger images yet, this is better than crashing.
    */
   clippedUnpack = *unpack;
   unpack = &clippedUnpack;
   clamp_size(st->pipe, &width, &height, &clippedUnpack);
d901 17
a917 6
   if (write_stencil &&
       !pipe->screen->get_param(pipe->screen, PIPE_CAP_SHADER_STENCIL_EXPORT)) {
      /* software fallback */
      draw_stencil_pixels(ctx, x, y, width, height, format, type,
                          unpack, pixels);
      return;
d920 2
a921 5
   /*
    * Get vertex/fragment shaders
    */
   if (write_depth || write_stencil) {
      fpv = get_depth_stencil_fp_variant(st, write_depth, write_stencil);
d923 1
a923 1
      driver_fp = fpv->driver_shader;
d925 2
a927 1

d931 1
a931 4
      fpv = get_color_fp_variant(st);

      driver_fp = fpv->driver_shader;

a932 1

a939 3
   /* update fragment program constants */
   st_upload_constants(st, fpv->parameters, PIPE_SHADER_FRAGMENT);

d948 2
a949 8
            /* Create a second sampler view to read stencil.
             * The stencil is written using the shader stencil export
             * functionality. */
            if (write_stencil) {
               enum pipe_format stencil_format =
                     util_format_stencil_only(pt->format);

               sv[1] = st_create_texture_sampler_view_format(st->pipe, pt,
d951 2
a952 2
               num_sampler_view++;
            }
d969 5
d1000 6
a1005 3
   /* Get the dest renderbuffer */
   rbDraw = st_renderbuffer(ctx->DrawBuffer->
                            Attachment[BUFFER_STENCIL].Renderbuffer);
d1008 3
a1010 3
   _mesa_readpixels(ctx, srcx, srcy, width, height,
                    GL_STENCIL_INDEX, GL_UNSIGNED_BYTE,
                    &ctx->DefaultPacking, buffer);
d1024 2
a1025 1
   if (_mesa_is_format_packed_depth_stencil(rbDraw->Base.Format))
d1034 9
a1042 2
   assert(util_format_get_blockwidth(rbDraw->texture->format) == 1);
   assert(util_format_get_blockheight(rbDraw->texture->format) == 1);
d1045 1
a1045 6
   drawMap = pipe_transfer_map(pipe,
                               rbDraw->texture,
                               rbDraw->rtt_level,
                               rbDraw->rtt_face + rbDraw->rtt_slice,
                               usage, dstx, dsty,
                               width, height, &ptDraw);
d1063 30
a1092 1
      _mesa_pack_ubyte_stencil_row(rbDraw->Base.Format, width, src, dst);
d1099 1
a1099 166
}


/**
 * Return renderbuffer to use for reading color pixels for glCopyPixels
 */
static struct st_renderbuffer *
st_get_color_read_renderbuffer(struct gl_context *ctx)
{
   struct gl_framebuffer *fb = ctx->ReadBuffer;
   struct st_renderbuffer *strb =
      st_renderbuffer(fb->_ColorReadBuffer);

   return strb;
}


/**
 * \return TRUE if two regions overlap, FALSE otherwise
 */
static boolean
regions_overlap(int srcX0, int srcY0,
                int srcX1, int srcY1,
                int dstX0, int dstY0,
                int dstX1, int dstY1)
{
   if (MAX2(srcX0, srcX1) < MIN2(dstX0, dstX1))
      return FALSE; /* src completely left of dst */

   if (MAX2(dstX0, dstX1) < MIN2(srcX0, srcX1))
      return FALSE; /* dst completely left of src */

   if (MAX2(srcY0, srcY1) < MIN2(dstY0, dstY1))
      return FALSE; /* src completely above dst */

   if (MAX2(dstY0, dstY1) < MIN2(srcY0, srcY1))
      return FALSE; /* dst completely above src */

   return TRUE; /* some overlap */
}


/**
 * Try to do a glCopyPixels for simple cases with a blit by calling
 * pipe->blit().
 *
 * We can do this when we're copying color pixels (depth/stencil
 * eventually) with no pixel zoom, no pixel transfer ops, no
 * per-fragment ops, and the src/dest regions don't overlap.
 */
static GLboolean
blit_copy_pixels(struct gl_context *ctx, GLint srcx, GLint srcy,
                 GLsizei width, GLsizei height,
                 GLint dstx, GLint dsty, GLenum type)
{
   struct st_context *st = st_context(ctx);
   struct pipe_context *pipe = st->pipe;
   struct pipe_screen *screen = pipe->screen;
   struct gl_pixelstore_attrib pack, unpack;
   GLint readX, readY, readW, readH, drawX, drawY, drawW, drawH;

   if (type == GL_COLOR &&
       ctx->Pixel.ZoomX == 1.0 &&
       ctx->Pixel.ZoomY == 1.0 &&
       ctx->_ImageTransferState == 0x0 &&
       !ctx->Color.BlendEnabled &&
       !ctx->Color.AlphaEnabled &&
       !ctx->Depth.Test &&
       !ctx->Fog.Enabled &&
       !ctx->Stencil.Enabled &&
       !ctx->FragmentProgram.Enabled &&
       !ctx->VertexProgram.Enabled &&
       !ctx->Shader.CurrentFragmentProgram &&
       ctx->DrawBuffer->_NumColorDrawBuffers == 1 &&
       !ctx->Query.CondRenderQuery &&
       !ctx->Query.CurrentOcclusionObject) {
      struct st_renderbuffer *rbRead, *rbDraw;

      /*
       * Clip the read region against the src buffer bounds.
       * We'll still allocate a temporary buffer/texture for the original
       * src region size but we'll only read the region which is on-screen.
       * This may mean that we draw garbage pixels into the dest region, but
       * that's expected.
       */
      readX = srcx;
      readY = srcy;
      readW = width;
      readH = height;
      pack = ctx->DefaultPacking;
      if (!_mesa_clip_readpixels(ctx, &readX, &readY, &readW, &readH, &pack))
         return GL_TRUE; /* all done */

      /* clip against dest buffer bounds and scissor box */
      drawX = dstx + pack.SkipPixels;
      drawY = dsty + pack.SkipRows;
      unpack = pack;
      if (!_mesa_clip_drawpixels(ctx, &drawX, &drawY, &readW, &readH, &unpack))
         return GL_TRUE; /* all done */

      readX = readX - pack.SkipPixels + unpack.SkipPixels;
      readY = readY - pack.SkipRows + unpack.SkipRows;

      drawW = readW;
      drawH = readH;

      rbRead = st_get_color_read_renderbuffer(ctx);
      rbDraw = st_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0]);

      /* Flip src/dst position depending on the orientation of buffers. */
      if (st_fb_orientation(ctx->ReadBuffer) == Y_0_TOP) {
         readY = rbRead->Base.Height - readY;
         readH = -readH;
      }

      if (st_fb_orientation(ctx->DrawBuffer) == Y_0_TOP) {
         /* We can't flip the destination for pipe->blit, so we only adjust
          * its position and flip the source.
          */
         drawY = rbDraw->Base.Height - drawY - drawH;
         readY += readH;
         readH = -readH;
      }

      if (rbRead != rbDraw ||
          !regions_overlap(readX, readY, readX + readW, readY + readH,
                           drawX, drawY, drawX + drawW, drawY + drawH)) {
         struct pipe_blit_info blit;

         memset(&blit, 0, sizeof(blit));
         blit.src.resource = rbRead->texture;
         blit.src.level = rbRead->rtt_level;
         blit.src.format = rbRead->texture->format;
         blit.src.box.x = readX;
         blit.src.box.y = readY;
         blit.src.box.z = rbRead->rtt_face + rbRead->rtt_slice;
         blit.src.box.width = readW;
         blit.src.box.height = readH;
         blit.src.box.depth = 1;
         blit.dst.resource = rbDraw->texture;
         blit.dst.level = rbDraw->rtt_level;
         blit.dst.format = rbDraw->texture->format;
         blit.dst.box.x = drawX;
         blit.dst.box.y = drawY;
         blit.dst.box.z = rbDraw->rtt_face + rbDraw->rtt_slice;
         blit.dst.box.width = drawW;
         blit.dst.box.height = drawH;
         blit.dst.box.depth = 1;
         blit.mask = PIPE_MASK_RGBA;
         blit.filter = PIPE_TEX_FILTER_NEAREST;

         if (screen->is_format_supported(screen, blit.src.format,
                                         blit.src.resource->target,
                                         blit.src.resource->nr_samples,
                                         PIPE_BIND_SAMPLER_VIEW) &&
             screen->is_format_supported(screen, blit.dst.format,
                                         blit.dst.resource->target,
                                         blit.dst.resource->nr_samples,
                                         PIPE_BIND_RENDER_TARGET)) {
            pipe->blit(pipe, &blit);
            return GL_TRUE;
         }
      }
   }

   return GL_FALSE;
d1117 1
a1117 2
   enum pipe_format srcFormat;
   unsigned srcBind;
d1120 1
a1121 1
   struct st_fp_variant *fpv;
a1124 7
   if (type == GL_DEPTH_STENCIL) {
      /* XXX make this more efficient */
      st_CopyPixels(ctx, srcx, srcy, width, height, dstx, dsty, GL_STENCIL);
      st_CopyPixels(ctx, srcx, srcy, width, height, dstx, dsty, GL_DEPTH);
      return;
   }

a1130 14
   if (blit_copy_pixels(ctx, srcx, srcy, width, height, dstx, dsty, type))
      return;

   /*
    * The subsequent code implements glCopyPixels by copying the source
    * pixels into a temporary texture that's then applied to a textured quad.
    * When we draw the textured quad, all the usual per-fragment operations
    * are handled.
    */


   /*
    * Get vertex/fragment shaders
    */
d1134 1
a1134 4

      fpv = get_color_fp_variant(st);
      driver_fp = fpv->driver_shader;

a1135 1

d1137 2
a1138 2
         sv[1] = st->pixel_xfer.pixelmap_sampler_view;
         num_sampler_view++;
d1143 1
a1143 2
      rbRead = st_renderbuffer(ctx->ReadBuffer->
                               Attachment[BUFFER_DEPTH].Renderbuffer);
d1145 1
a1145 4

      fpv = get_depth_stencil_fp_variant(st, GL_TRUE, GL_FALSE);
      driver_fp = fpv->driver_shader;

d1149 8
a1156 2
   /* update fragment program constants */
   st_upload_constants(st, fpv->parameters, PIPE_SHADER_FRAGMENT);
a1157 1
   /* Choose the format for the temporary texture. */
a1158 2
   srcBind = PIPE_BIND_SAMPLER_VIEW |
      (type == GL_COLOR ? PIPE_BIND_RENDER_TARGET : PIPE_BIND_DEPTH_STENCIL);
d1160 7
a1166 3
   if (!screen->is_format_supported(screen, srcFormat, st->internal_target, 0,
                                    srcBind)) {
      /* srcFormat is non-renderable. Find a compatible renderable format. */
d1168 4
a1171 3
         srcFormat = st_choose_format(st, GL_DEPTH_COMPONENT, GL_NONE,
                                      GL_NONE, st->internal_target, 0,
                                      srcBind, FALSE);
d1174 4
a1177 32
         assert(type == GL_COLOR);

         if (util_format_is_float(srcFormat)) {
            srcFormat = st_choose_format(st, GL_RGBA32F, GL_NONE,
                                         GL_NONE, st->internal_target, 0,
                                         srcBind, FALSE);
         }
         else if (util_format_is_pure_sint(srcFormat)) {
            srcFormat = st_choose_format(st, GL_RGBA32I, GL_NONE,
                                         GL_NONE, st->internal_target, 0,
                                         srcBind, FALSE);
         }
         else if (util_format_is_pure_uint(srcFormat)) {
            srcFormat = st_choose_format(st, GL_RGBA32UI, GL_NONE,
                                         GL_NONE, st->internal_target, 0,
                                         srcBind, FALSE);
         }
         else if (util_format_is_snorm(srcFormat)) {
            srcFormat = st_choose_format(st, GL_RGBA16_SNORM, GL_NONE,
                                         GL_NONE, st->internal_target, 0,
                                         srcBind, FALSE);
         }
         else {
            srcFormat = st_choose_format(st, GL_RGBA, GL_NONE,
                                         GL_NONE, st->internal_target, 0,
                                         srcBind, FALSE);
         }
      }

      if (srcFormat == PIPE_FORMAT_NONE) {
         assert(0 && "cannot choose a format for src of CopyPixels");
         return;
d1197 1
a1197 9
   if (!_mesa_clip_readpixels(ctx, &readX, &readY, &readW, &readH, &pack)) {
      /* The source region is completely out of bounds.  Do nothing.
       * The GL spec says "Results of copies from outside the window,
       * or from regions of the window that are not exposed, are
       * hardware dependent and undefined."
       */
      return;
   }

d1201 2
a1202 2
   /* Allocate the temporary texture. */
   pt = alloc_texture(st, width, height, srcFormat, srcBind);
d1212 13
a1224 3
   /* Copy the src region to the temporary texture. */
   {
      struct pipe_blit_info blit;
d1226 40
a1265 21
      memset(&blit, 0, sizeof(blit));
      blit.src.resource = rbRead->texture;
      blit.src.level = rbRead->rtt_level;
      blit.src.format = rbRead->texture->format;
      blit.src.box.x = readX;
      blit.src.box.y = readY;
      blit.src.box.z = rbRead->rtt_face + rbRead->rtt_slice;
      blit.src.box.width = readW;
      blit.src.box.height = readH;
      blit.src.box.depth = 1;
      blit.dst.resource = pt;
      blit.dst.level = 0;
      blit.dst.format = pt->format;
      blit.dst.box.x = pack.SkipPixels;
      blit.dst.box.y = pack.SkipRows;
      blit.dst.box.z = 0;
      blit.dst.box.width = readW;
      blit.dst.box.height = readH;
      blit.dst.box.depth = 1;
      blit.mask = util_format_get_mask(pt->format) & ~PIPE_MASK_S;
      blit.filter = PIPE_TEX_FILTER_NEAREST;
d1267 2
a1268 1
      pipe->blit(pipe, &blit);
d1302 1
a1302 1
         _mesa_reference_fragprog(st->ctx, &st->drawpix.shaders[i], NULL);
d1307 1
a1307 1
      cso_delete_vertex_shader(st->cso_context, st->drawpix.vert_shaders[0]);
d1309 1
a1309 1
      cso_delete_vertex_shader(st->cso_context, st->drawpix.vert_shaders[1]);
d1311 2
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2007 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d486 1
a486 1
   mesa_format mformat;
d545 1
a545 1
                               mformat,          /* mesa_format */
d716 1
a716 1
      rasterizer.scissor = ctx->Scissor.EnableFlags;
d791 1
a791 1
   cso_set_stream_outputs(st->cso_context, 0, NULL, NULL);
d881 1
a881 2
                             strb->surface->u.tex.level,
                             strb->surface->u.tex.first_layer,
d1266 2
a1267 2
                               rbDraw->surface->u.tex.level,
                               rbDraw->surface->u.tex.first_layer,
d1366 1
a1366 1
       !ctx->_Shader->CurrentProgram[MESA_SHADER_FRAGMENT] &&
d1425 1
a1425 1
         blit.src.level = rbRead->surface->u.tex.level;
d1429 1
a1429 1
         blit.src.box.z = rbRead->surface->u.tex.first_layer;
d1434 1
a1434 1
         blit.dst.level = rbDraw->surface->u.tex.level;
d1438 1
a1438 1
         blit.dst.box.z = rbDraw->surface->u.tex.first_layer;
d1636 1
a1636 1
      blit.src.level = rbRead->surface->u.tex.level;
d1640 1
a1640 1
      blit.src.box.z = rbRead->surface->u.tex.first_layer;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d494 1
a494 1
   pipeFormat = st_choose_matching_format(st, PIPE_BIND_SAMPLER_VIEW,
d497 5
a501 1
   if (pipeFormat == PIPE_FORMAT_NONE) {
d505 1
d510 1
a511 3

   mformat = st_pipe_format_to_mesa_format(pipeFormat);
   baseInternalFormat = _mesa_get_format_base_format(mformat);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d494 1
a494 1
   pipeFormat = st_choose_matching_format(pipe->screen, PIPE_BIND_SAMPLER_VIEW,
d497 1
a497 5
   if (pipeFormat != PIPE_FORMAT_NONE) {
      mformat = st_pipe_format_to_mesa_format(pipeFormat);
      baseInternalFormat = _mesa_get_format_base_format(mformat);
   }
   else {
a500 1
      baseInternalFormat = _mesa_base_tex_format(ctx, intFormat);
a504 1
      mformat = st_pipe_format_to_mesa_format(pipeFormat);
d506 3
@


