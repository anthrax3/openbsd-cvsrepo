head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.9
	v10_4_3:1.1.1.8
	v10_2_7:1.1.1.7
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.7
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.6
	v9_2_3:1.1.1.6
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.11.24.06.19.52;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2013.09.05.14.05.58;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.17;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.27;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.19;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.52;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.52;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.58;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.30.16;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.44;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.11;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.11.24.06.01.18;	author jsg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.07.09.20.34.57;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.8
date	2015.01.25.14.12.18;	author jsg;	state Exp;
branches;
next	1.1.1.9;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.9
date	2015.02.20.22.49.25;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/*
 * Off-Screen Mesa rendering / Rendering into client memory space
 *
 * Note on thread safety:  this driver is thread safe.  All
 * functions are reentrant.  The notion of current context is
 * managed by the core _mesa_make_current() and _mesa_get_current_context()
 * functions.  Those functions are thread-safe.
 */


#include "main/glheader.h"
#include "GL/osmesa.h"
#include "main/api_exec.h"
#include "main/context.h"
#include "main/extensions.h"
#include "main/formats.h"
#include "main/framebuffer.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/mipmap.h"
#include "main/mtypes.h"
#include "main/renderbuffer.h"
#include "main/version.h"
#include "main/vtxfmt.h"
#include "swrast/swrast.h"
#include "swrast_setup/swrast_setup.h"
#include "swrast/s_context.h"
#include "swrast/s_lines.h"
#include "swrast/s_renderbuffer.h"
#include "swrast/s_triangle.h"
#include "tnl/tnl.h"
#include "tnl/t_context.h"
#include "tnl/t_pipeline.h"
#include "drivers/common/driverfuncs.h"
#include "drivers/common/meta.h"
#include "vbo/vbo.h"


#define OSMESA_RENDERBUFFER_CLASS 0x053


/**
 * OSMesa rendering context, derived from core Mesa struct gl_context.
 */
struct osmesa_context
{
   struct gl_context mesa;		/*< Base class - this must be first */
   struct gl_config *gl_visual;		/*< Describes the buffers */
   struct swrast_renderbuffer *srb;     /*< The user's colorbuffer */
   struct gl_framebuffer *gl_buffer;	/*< The framebuffer, containing user's rb */
   GLenum format;		/*< User-specified context format */
   GLint userRowLength;		/*< user-specified number of pixels per row */
   GLint rInd, gInd, bInd, aInd;/*< index offsets for RGBA formats */
   GLvoid *rowaddr[SWRAST_MAX_HEIGHT];	/*< address of first pixel in each image row */
   GLboolean yup;		/*< TRUE  -> Y increases upward */
				/*< FALSE -> Y increases downward */
   GLenum DataType;
};


static INLINE OSMesaContext
OSMESA_CONTEXT(struct gl_context *ctx)
{
   /* Just cast, since we're using structure containment */
   return (OSMesaContext) ctx;
}


/**********************************************************************/
/*** Private Device Driver Functions                                ***/
/**********************************************************************/


static const GLubyte *
get_string( struct gl_context *ctx, GLenum name )
{
   (void) ctx;
   switch (name) {
      case GL_RENDERER:
#if CHAN_BITS == 32
         return (const GLubyte *) "Mesa OffScreen32";
#elif CHAN_BITS == 16
         return (const GLubyte *) "Mesa OffScreen16";
#else
         return (const GLubyte *) "Mesa OffScreen";
#endif
      default:
         return NULL;
   }
}


static void
osmesa_update_state( struct gl_context *ctx, GLuint new_state )
{
   /* easy - just propogate */
   _swrast_InvalidateState( ctx, new_state );
   _swsetup_InvalidateState( ctx, new_state );
   _tnl_InvalidateState( ctx, new_state );
   _vbo_InvalidateState( ctx, new_state );
}



/**
 * Macros for optimized line/triangle rendering.
 * Only for 8-bit channel, RGBA, BGRA, ARGB formats.
 */

#define PACK_RGBA(DST, R, G, B, A)	\
do {					\
   (DST)[osmesa->rInd] = R;		\
   (DST)[osmesa->gInd] = G;		\
   (DST)[osmesa->bInd] = B;		\
   (DST)[osmesa->aInd] = A;		\
} while (0)

#define PIXELADDR4(X,Y)  ((GLchan *) osmesa->rowaddr[Y] + 4 * (X))


/**
 * Draw a flat-shaded, RGB line into an osmesa buffer.
 */
#define NAME flat_rgba_line
#define CLIP_HACK 1
#define SETUP_CODE						\
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);		\
   const GLchan *color = vert1->color;

#define PLOT(X, Y)						\
do {								\
   GLchan *p = PIXELADDR4(X, Y);				\
   PACK_RGBA(p, color[0], color[1], color[2], color[3]);	\
} while (0)

#include "swrast/s_linetemp.h"



/**
 * Draw a flat-shaded, Z-less, RGB line into an osmesa buffer.
 */
#define NAME flat_rgba_z_line
#define CLIP_HACK 1
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define SETUP_CODE					\
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);	\
   const GLchan *color = vert1->color;

#define PLOT(X, Y)					\
do {							\
   if (Z < *zPtr) {					\
      GLchan *p = PIXELADDR4(X, Y);			\
      PACK_RGBA(p, color[RCOMP], color[GCOMP],		\
                   color[BCOMP], color[ACOMP]);		\
      *zPtr = Z;					\
   }							\
} while (0)

#include "swrast/s_linetemp.h"



/**
 * Analyze context state to see if we can provide a fast line drawing
 * function.  Otherwise, return NULL.
 */
static swrast_line_func
osmesa_choose_line_function( struct gl_context *ctx )
{
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);

   if (ctx->DrawBuffer &&
       ctx->DrawBuffer->Visual.redBits == 32) {
      /* the special-case line functions in this file don't work
       * for float color channels.
       */
      return NULL;
   }

   if (ctx->RenderMode != GL_RENDER ||
       ctx->Line.SmoothFlag ||
       ctx->Texture._MaxEnabledTexImageUnit == -1 ||
       ctx->Light.ShadeModel != GL_FLAT ||
       ctx->Line.Width != 1.0F ||
       ctx->Line.StippleFlag ||
       ctx->Line.SmoothFlag) {
      return NULL;
   }

   if (osmesa->format != OSMESA_RGBA &&
       osmesa->format != OSMESA_BGRA &&
       osmesa->format != OSMESA_ARGB) {
      return NULL;
   }

   if (swrast->_RasterMask == DEPTH_BIT
       && ctx->Depth.Func == GL_LESS
       && ctx->Depth.Mask == GL_TRUE
       && ctx->Visual.depthBits == DEFAULT_SOFTWARE_DEPTH_BITS) {
      return flat_rgba_z_line;
   }

   if (swrast->_RasterMask == 0) {
      return flat_rgba_line;
   }

   return (swrast_line_func) NULL;
}


/**********************************************************************/
/*****                 Optimized triangle rendering               *****/
/**********************************************************************/


/*
 * Smooth-shaded, z-less triangle, RGBA color.
 */
#define NAME smooth_rgba_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define SETUP_CODE \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLchan *img = PIXELADDR4(span.x, span.y); 			\
   for (i = 0; i < span.end; i++, img += 4) {			\
      const GLuint z = FixedToDepth(span.z);			\
      if (z < zRow[i]) {					\
         PACK_RGBA(img, FixedToChan(span.red),			\
            FixedToChan(span.green), FixedToChan(span.blue),	\
            FixedToChan(span.alpha));				\
         zRow[i] = z;						\
      }								\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
      span.alpha += span.alphaStep;				\
      span.z += span.zStep;					\
   }                                                            \
}
#include "swrast/s_tritemp.h"



/*
 * Flat-shaded, z-less triangle, RGBA color.
 */
#define NAME flat_rgba_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define SETUP_CODE						\
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);		\
   GLuint pixel;						\
   PACK_RGBA((GLchan *) &pixel, v2->color[0], v2->color[1],	\
                                v2->color[2], v2->color[3]);

#define RENDER_SPAN( span ) {				\
   GLuint i;						\
   GLuint *img = (GLuint *) PIXELADDR4(span.x, span.y);	\
   for (i = 0; i < span.end; i++) {			\
      const GLuint z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {				\
         img[i] = pixel;				\
         zRow[i] = z;					\
      }							\
      span.z += span.zStep;				\
   }                                                    \
}

#include "swrast/s_tritemp.h"



/**
 * Return pointer to an optimized triangle function if possible.
 */
static swrast_tri_func
osmesa_choose_triangle_function( struct gl_context *ctx )
{
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
   const SWcontext *swrast = SWRAST_CONTEXT(ctx);

   if (ctx->DrawBuffer &&
       ctx->DrawBuffer->Visual.redBits == 32) {
      /* the special-case triangle functions in this file don't work
       * for float color channels.
       */
      return NULL;
   }

   if (ctx->RenderMode != GL_RENDER ||
       ctx->Polygon.SmoothFlag ||
       ctx->Polygon.StippleFlag ||
       ctx->Texture._MaxEnabledTexImageUnit != -1) {
      return NULL;
   }

   if (osmesa->format != OSMESA_RGBA &&
       osmesa->format != OSMESA_BGRA &&
       osmesa->format != OSMESA_ARGB) {
      return NULL;
   }

   if (ctx->Polygon.CullFlag &&
       ctx->Polygon.CullFaceMode == GL_FRONT_AND_BACK) {
      return NULL;
   }

   if (swrast->_RasterMask == DEPTH_BIT &&
       ctx->Depth.Func == GL_LESS &&
       ctx->Depth.Mask == GL_TRUE &&
       ctx->Visual.depthBits == DEFAULT_SOFTWARE_DEPTH_BITS) {
      if (ctx->Light.ShadeModel == GL_SMOOTH) {
         return smooth_rgba_z_triangle;
      }
      else {
         return flat_rgba_z_triangle;
      }
   }

   return NULL;
}



/* Override for the swrast triangle-selection function.  Try to use one
 * of our internal triangle functions, otherwise fall back to the
 * standard swrast functions.
 */
static void
osmesa_choose_triangle( struct gl_context *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

   swrast->Triangle = osmesa_choose_triangle_function( ctx );
   if (!swrast->Triangle)
      _swrast_choose_triangle( ctx );
}

static void
osmesa_choose_line( struct gl_context *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

   swrast->Line = osmesa_choose_line_function( ctx );
   if (!swrast->Line)
      _swrast_choose_line( ctx );
}



/**
 * Recompute the values of the context's rowaddr array.
 */
static void
compute_row_addresses( OSMesaContext osmesa )
{
   GLint bytesPerRow, i;
   GLubyte *origin = (GLubyte *) osmesa->srb->Buffer;
   GLint rowlength; /* in pixels */
   GLint height = osmesa->srb->Base.Height;

   if (osmesa->userRowLength)
      rowlength = osmesa->userRowLength;
   else
      rowlength = osmesa->srb->Base.Width;

   bytesPerRow = rowlength * _mesa_get_format_bytes(osmesa->srb->Base.Format);

   if (osmesa->yup) {
      /* Y=0 is bottom line of window */
      for (i = 0; i < height; i++) {
         osmesa->rowaddr[i] = (GLvoid *) ((GLubyte *) origin + i * bytesPerRow);
      }
   }
   else {
      /* Y=0 is top line of window */
      for (i = 0; i < height; i++) {
         GLint j = height - i - 1;
         osmesa->rowaddr[i] = (GLvoid *) ((GLubyte *) origin + j * bytesPerRow);
      }
   }
}



/**
 * Don't use _mesa_delete_renderbuffer since we can't free rb->Buffer.
 */
static void
osmesa_delete_renderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
{
   _mesa_delete_renderbuffer(ctx, rb);
}


/**
 * Allocate renderbuffer storage.  We don't actually allocate any storage
 * since we're using a user-provided buffer.
 * Just set up all the gl_renderbuffer methods.
 */
static GLboolean
osmesa_renderbuffer_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
                            GLenum internalFormat, GLuint width, GLuint height)
{
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);

   /* Note: we can ignoring internalFormat for "window-system" renderbuffers */
   (void) internalFormat;

   /* Given the user-provided format and type, figure out which MESA_FORMAT_x
    * to use.
    * XXX There aren't Mesa formats for all the possible combinations here!
    * XXX Specifically, there's only RGBA-order 16-bit/channel and float
    * XXX formats.
    * XXX The 8-bit/channel formats should all be OK.
    */
   if (osmesa->format == OSMESA_RGBA) {
      if (osmesa->DataType == GL_UNSIGNED_BYTE) {
         if (_mesa_little_endian())
            rb->Format = MESA_FORMAT_R8G8B8A8_UNORM;
         else
            rb->Format = MESA_FORMAT_A8B8G8R8_UNORM;
      }
      else if (osmesa->DataType == GL_UNSIGNED_SHORT) {
         rb->Format = MESA_FORMAT_RGBA_UNORM16;
      }
      else {
         rb->Format = MESA_FORMAT_RGBA_FLOAT32;
      }
   }
   else if (osmesa->format == OSMESA_BGRA) {
      if (osmesa->DataType == GL_UNSIGNED_BYTE) {
         if (_mesa_little_endian())
            rb->Format = MESA_FORMAT_B8G8R8A8_UNORM;
         else
            rb->Format = MESA_FORMAT_A8R8G8B8_UNORM;
      }
      else if (osmesa->DataType == GL_UNSIGNED_SHORT) {
         _mesa_warning(ctx, "Unsupported OSMesa format BGRA/GLushort");
         rb->Format = MESA_FORMAT_RGBA_UNORM16; /* not exactly right */
      }
      else {
         _mesa_warning(ctx, "Unsupported OSMesa format BGRA/GLfloat");
         rb->Format = MESA_FORMAT_RGBA_FLOAT32; /* not exactly right */
      }
   }
   else if (osmesa->format == OSMESA_ARGB) {
      if (osmesa->DataType == GL_UNSIGNED_BYTE) {
         if (_mesa_little_endian())
            rb->Format = MESA_FORMAT_A8R8G8B8_UNORM;
         else
            rb->Format = MESA_FORMAT_B8G8R8A8_UNORM;
      }
      else if (osmesa->DataType == GL_UNSIGNED_SHORT) {
         _mesa_warning(ctx, "Unsupported OSMesa format ARGB/GLushort");
         rb->Format = MESA_FORMAT_RGBA_UNORM16; /* not exactly right */
      }
      else {
         _mesa_warning(ctx, "Unsupported OSMesa format ARGB/GLfloat");
         rb->Format = MESA_FORMAT_RGBA_FLOAT32; /* not exactly right */
      }
   }
   else if (osmesa->format == OSMESA_RGB) {
      if (osmesa->DataType == GL_UNSIGNED_BYTE) {
         rb->Format = MESA_FORMAT_BGR_UNORM8;
      }
      else if (osmesa->DataType == GL_UNSIGNED_SHORT) {
         _mesa_warning(ctx, "Unsupported OSMesa format RGB/GLushort");
         rb->Format = MESA_FORMAT_RGBA_UNORM16; /* not exactly right */
      }
      else {
         _mesa_warning(ctx, "Unsupported OSMesa format RGB/GLfloat");
         rb->Format = MESA_FORMAT_RGBA_FLOAT32; /* not exactly right */
      }
   }
   else if (osmesa->format == OSMESA_BGR) {
      if (osmesa->DataType == GL_UNSIGNED_BYTE) {
         rb->Format = MESA_FORMAT_RGB_UNORM8;
      }
      else if (osmesa->DataType == GL_UNSIGNED_SHORT) {
         _mesa_warning(ctx, "Unsupported OSMesa format BGR/GLushort");
         rb->Format = MESA_FORMAT_RGBA_UNORM16; /* not exactly right */
      }
      else {
         _mesa_warning(ctx, "Unsupported OSMesa format BGR/GLfloat");
         rb->Format = MESA_FORMAT_RGBA_FLOAT32; /* not exactly right */
      }
   }
   else if (osmesa->format == OSMESA_RGB_565) {
      ASSERT(osmesa->DataType == GL_UNSIGNED_BYTE);
      rb->Format = MESA_FORMAT_B5G6R5_UNORM;
   }
   else {
      _mesa_problem(ctx, "bad pixel format in osmesa renderbuffer_storage");
   }

   rb->Width = width;
   rb->Height = height;

   compute_row_addresses( osmesa );

   return GL_TRUE;
}


/**
 * Allocate a new renderbuffer to describe the user-provided color buffer.
 */
static struct swrast_renderbuffer *
new_osmesa_renderbuffer(struct gl_context *ctx, GLenum format, GLenum type)
{
   const GLuint name = 0;
   struct swrast_renderbuffer *srb = CALLOC_STRUCT(swrast_renderbuffer);

   if (srb) {
      _mesa_init_renderbuffer(&srb->Base, name);

      srb->Base.ClassID = OSMESA_RENDERBUFFER_CLASS;
      srb->Base.RefCount = 1;
      srb->Base.Delete = osmesa_delete_renderbuffer;
      srb->Base.AllocStorage = osmesa_renderbuffer_storage;

      srb->Base.InternalFormat = GL_RGBA;
      srb->Base._BaseFormat = GL_RGBA;

      return srb;
   }
   return NULL;
}



static void
osmesa_MapRenderbuffer(struct gl_context *ctx,
                       struct gl_renderbuffer *rb,
                       GLuint x, GLuint y, GLuint w, GLuint h,
                       GLbitfield mode,
                       GLubyte **mapOut, GLint *rowStrideOut)
{
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);

   if (rb->ClassID == OSMESA_RENDERBUFFER_CLASS) {
      /* this is an OSMesa renderbuffer which wraps user memory */
      struct swrast_renderbuffer *srb = swrast_renderbuffer(rb);
      const GLuint bpp = _mesa_get_format_bytes(rb->Format);
      GLint rowStride; /* in bytes */

      if (osmesa->userRowLength)
         rowStride = osmesa->userRowLength * bpp;
      else
         rowStride = rb->Width * bpp;

      if (!osmesa->yup) {
         /* Y=0 is top line of window */
         y = rb->Height - y - 1;
         *rowStrideOut = -rowStride;
      }
      else {
         *rowStrideOut = rowStride;
      }

      *mapOut = (GLubyte *) srb->Buffer + y * rowStride + x * bpp;
   }
   else {
      _swrast_map_soft_renderbuffer(ctx, rb, x, y, w, h, mode,
                                    mapOut, rowStrideOut);
   }
}


static void
osmesa_UnmapRenderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
{
   if (rb->ClassID == OSMESA_RENDERBUFFER_CLASS) {
      /* no-op */
   }
   else {
      _swrast_unmap_soft_renderbuffer(ctx, rb);
   }
}


/**********************************************************************/
/*****                    Public Functions                        *****/
/**********************************************************************/


/**
 * Create an Off-Screen Mesa rendering context.  The only attribute needed is
 * an RGBA vs Color-Index mode flag.
 *
 * Input:  format - Must be GL_RGBA
 *         sharelist - specifies another OSMesaContext with which to share
 *                     display lists.  NULL indicates no sharing.
 * Return:  an OSMesaContext or 0 if error
 */
GLAPI OSMesaContext GLAPIENTRY
OSMesaCreateContext( GLenum format, OSMesaContext sharelist )
{
   return OSMesaCreateContextExt(format, DEFAULT_SOFTWARE_DEPTH_BITS,
                                 8, 0, sharelist);
}



/**
 * New in Mesa 3.5
 *
 * Create context and specify size of ancillary buffers.
 */
GLAPI OSMesaContext GLAPIENTRY
OSMesaCreateContextExt( GLenum format, GLint depthBits, GLint stencilBits,
                        GLint accumBits, OSMesaContext sharelist )
{
   OSMesaContext osmesa;
   struct dd_function_table functions;
   GLint rind, gind, bind, aind;
   GLint redBits = 0, greenBits = 0, blueBits = 0, alphaBits =0;

   rind = gind = bind = aind = 0;
   if (format==OSMESA_RGBA) {
      redBits = CHAN_BITS;
      greenBits = CHAN_BITS;
      blueBits = CHAN_BITS;
      alphaBits = CHAN_BITS;
      rind = 0;
      gind = 1;
      bind = 2;
      aind = 3;
   }
   else if (format==OSMESA_BGRA) {
      redBits = CHAN_BITS;
      greenBits = CHAN_BITS;
      blueBits = CHAN_BITS;
      alphaBits = CHAN_BITS;
      bind = 0;
      gind = 1;
      rind = 2;
      aind = 3;
   }
   else if (format==OSMESA_ARGB) {
      redBits = CHAN_BITS;
      greenBits = CHAN_BITS;
      blueBits = CHAN_BITS;
      alphaBits = CHAN_BITS;
      aind = 0;
      rind = 1;
      gind = 2;
      bind = 3;
   }
   else if (format==OSMESA_RGB) {
      redBits = CHAN_BITS;
      greenBits = CHAN_BITS;
      blueBits = CHAN_BITS;
      alphaBits = 0;
      rind = 0;
      gind = 1;
      bind = 2;
   }
   else if (format==OSMESA_BGR) {
      redBits = CHAN_BITS;
      greenBits = CHAN_BITS;
      blueBits = CHAN_BITS;
      alphaBits = 0;
      rind = 2;
      gind = 1;
      bind = 0;
   }
#if CHAN_TYPE == GL_UNSIGNED_BYTE
   else if (format==OSMESA_RGB_565) {
      redBits = 5;
      greenBits = 6;
      blueBits = 5;
      alphaBits = 0;
      rind = 0; /* not used */
      gind = 0;
      bind = 0;
   }
#endif
   else {
      return NULL;
   }

   osmesa = (OSMesaContext) CALLOC_STRUCT(osmesa_context);
   if (osmesa) {
      osmesa->gl_visual = _mesa_create_visual( GL_FALSE,    /* double buffer */
                                               GL_FALSE,    /* stereo */
                                               redBits,
                                               greenBits,
                                               blueBits,
                                               alphaBits,
                                               depthBits,
                                               stencilBits,
                                               accumBits,
                                               accumBits,
                                               accumBits,
                                               alphaBits ? accumBits : 0,
                                               1            /* num samples */
                                               );
      if (!osmesa->gl_visual) {
         free(osmesa);
         return NULL;
      }

      /* Initialize device driver function table */
      _mesa_init_driver_functions(&functions);
      /* override with our functions */
      functions.GetString = get_string;
      functions.UpdateState = osmesa_update_state;

      if (!_mesa_initialize_context(&osmesa->mesa,
                                    API_OPENGL_COMPAT,
                                    osmesa->gl_visual,
                                    sharelist ? &sharelist->mesa
                                              : (struct gl_context *) NULL,
                                    &functions)) {
         _mesa_destroy_visual( osmesa->gl_visual );
         free(osmesa);
         return NULL;
      }

      _mesa_enable_sw_extensions(&(osmesa->mesa));

      osmesa->gl_buffer = _mesa_create_framebuffer(osmesa->gl_visual);
      if (!osmesa->gl_buffer) {
         _mesa_destroy_visual( osmesa->gl_visual );
         _mesa_free_context_data( &osmesa->mesa );
         free(osmesa);
         return NULL;
      }

      /* Create depth/stencil/accum buffers.  We'll create the color
       * buffer later in OSMesaMakeCurrent().
       */
      _swrast_add_soft_renderbuffers(osmesa->gl_buffer,
                                     GL_FALSE, /* color */
                                     osmesa->gl_visual->haveDepthBuffer,
                                     osmesa->gl_visual->haveStencilBuffer,
                                     osmesa->gl_visual->haveAccumBuffer,
                                     GL_FALSE, /* alpha */
                                     GL_FALSE /* aux */ );

      osmesa->format = format;
      osmesa->userRowLength = 0;
      osmesa->yup = GL_TRUE;
      osmesa->rInd = rind;
      osmesa->gInd = gind;
      osmesa->bInd = bind;
      osmesa->aInd = aind;

      _mesa_meta_init(&osmesa->mesa);

      /* Initialize the software rasterizer and helper modules. */
      {
	 struct gl_context *ctx = &osmesa->mesa;
         SWcontext *swrast;
         TNLcontext *tnl;

	 if (!_swrast_CreateContext( ctx ) ||
             !_vbo_CreateContext( ctx ) ||
             !_tnl_CreateContext( ctx ) ||
             !_swsetup_CreateContext( ctx )) {
            _mesa_destroy_visual(osmesa->gl_visual);
            _mesa_free_context_data(ctx);
            free(osmesa);
            return NULL;
         }
	
	 _swsetup_Wakeup( ctx );

         /* use default TCL pipeline */
         tnl = TNL_CONTEXT(ctx);
         tnl->Driver.RunPipeline = _tnl_run_pipeline;

         ctx->Driver.MapRenderbuffer = osmesa_MapRenderbuffer;
         ctx->Driver.UnmapRenderbuffer = osmesa_UnmapRenderbuffer;

         ctx->Driver.GenerateMipmap = _mesa_generate_mipmap;

         /* Extend the software rasterizer with our optimized line and triangle
          * drawing functions.
          */
         swrast = SWRAST_CONTEXT( ctx );
         swrast->choose_line = osmesa_choose_line;
         swrast->choose_triangle = osmesa_choose_triangle;

         _mesa_compute_version(ctx);

         /* Exec table initialization requires the version to be computed */
         _mesa_initialize_dispatch_tables(ctx);
         _mesa_initialize_vbo_vtxfmt(ctx);
      }
   }
   return osmesa;
}


/**
 * Destroy an Off-Screen Mesa rendering context.
 *
 * \param osmesa  the context to destroy
 */
GLAPI void GLAPIENTRY
OSMesaDestroyContext( OSMesaContext osmesa )
{
   if (osmesa) {
      if (osmesa->srb)
         _mesa_reference_renderbuffer((struct gl_renderbuffer **) &osmesa->srb, NULL);

      _mesa_meta_free( &osmesa->mesa );

      _swsetup_DestroyContext( &osmesa->mesa );
      _tnl_DestroyContext( &osmesa->mesa );
      _vbo_DestroyContext( &osmesa->mesa );
      _swrast_DestroyContext( &osmesa->mesa );

      _mesa_destroy_visual( osmesa->gl_visual );
      _mesa_reference_framebuffer( &osmesa->gl_buffer, NULL );

      _mesa_free_context_data( &osmesa->mesa );
      free( osmesa );
   }
}


/**
 * Bind an OSMesaContext to an image buffer.  The image buffer is just a
 * block of memory which the client provides.  Its size must be at least
 * as large as width*height*sizeof(type).  Its address should be a multiple
 * of 4 if using RGBA mode.
 *
 * Image data is stored in the order of glDrawPixels:  row-major order
 * with the lower-left image pixel stored in the first array position
 * (ie. bottom-to-top).
 *
 * If the context's viewport hasn't been initialized yet, it will now be
 * initialized to (0,0,width,height).
 *
 * Input:  osmesa - the rendering context
 *         buffer - the image buffer memory
 *         type - data type for pixel components
 *            Normally, only GL_UNSIGNED_BYTE and GL_UNSIGNED_SHORT_5_6_5
 *            are supported.  But if Mesa's been compiled with CHAN_BITS==16
 *            then type may be GL_UNSIGNED_SHORT or GL_UNSIGNED_BYTE.  And if
 *            Mesa's been build with CHAN_BITS==32 then type may be GL_FLOAT,
 *            GL_UNSIGNED_SHORT or GL_UNSIGNED_BYTE.
 *         width, height - size of image buffer in pixels, at least 1
 * Return:  GL_TRUE if success, GL_FALSE if error because of invalid osmesa,
 *          invalid buffer address, invalid type, width<1, height<1,
 *          width>internal limit or height>internal limit.
 */
GLAPI GLboolean GLAPIENTRY
OSMesaMakeCurrent( OSMesaContext osmesa, void *buffer, GLenum type,
                   GLsizei width, GLsizei height )
{
   if (!osmesa || !buffer ||
       width < 1 || height < 1 ||
       width > SWRAST_MAX_WIDTH || height > SWRAST_MAX_HEIGHT) {
      return GL_FALSE;
   }

   if (osmesa->format == OSMESA_RGB_565 && type != GL_UNSIGNED_SHORT_5_6_5) {
      return GL_FALSE;
   }

#if 0
   if (!(type == GL_UNSIGNED_BYTE ||
         (type == GL_UNSIGNED_SHORT && CHAN_BITS >= 16) ||
         (type == GL_FLOAT && CHAN_BITS == 32))) {
      /* i.e. is sizeof(type) * 8 > CHAN_BITS? */
      return GL_FALSE;
   }
#endif

   osmesa_update_state( &osmesa->mesa, 0 );

   /* Call this periodically to detect when the user has begun using
    * GL rendering from multiple threads.
    */
   _glapi_check_multithread();


   /* Create a front/left color buffer which wraps the user-provided buffer.
    * There is no back color buffer.
    * If the user tries to use a 8, 16 or 32-bit/channel buffer that
    * doesn't match what Mesa was compiled for (CHAN_BITS) the
    * _mesa_add_renderbuffer() function will create a "wrapper" renderbuffer
    * that converts rendering from CHAN_BITS to the user-requested channel
    * size.
    */
   if (!osmesa->srb) {
      osmesa->srb = new_osmesa_renderbuffer(&osmesa->mesa, osmesa->format, type);
      _mesa_remove_renderbuffer(osmesa->gl_buffer, BUFFER_FRONT_LEFT);
      _mesa_add_renderbuffer(osmesa->gl_buffer, BUFFER_FRONT_LEFT,
                             &osmesa->srb->Base);
      assert(osmesa->srb->Base.RefCount == 2);
   }

   osmesa->DataType = type;

   /* Set renderbuffer fields.  Set width/height = 0 to force 
    * osmesa_renderbuffer_storage() being called by _mesa_resize_framebuffer()
    */
   osmesa->srb->Buffer = buffer;
   osmesa->srb->Base.Width = osmesa->srb->Base.Height = 0;

   /* Set the framebuffer's size.  This causes the
    * osmesa_renderbuffer_storage() function to get called.
    */
   _mesa_resize_framebuffer(&osmesa->mesa, osmesa->gl_buffer, width, height);

   _mesa_make_current( &osmesa->mesa, osmesa->gl_buffer, osmesa->gl_buffer );

   /* Remove renderbuffer attachment, then re-add.  This installs the
    * renderbuffer adaptor/wrapper if needed (for bpp conversion).
    */
   _mesa_remove_renderbuffer(osmesa->gl_buffer, BUFFER_FRONT_LEFT);
   _mesa_add_renderbuffer(osmesa->gl_buffer, BUFFER_FRONT_LEFT,
                          &osmesa->srb->Base);


   /* this updates the visual's red/green/blue/alphaBits fields */
   _mesa_update_framebuffer_visual(&osmesa->mesa, osmesa->gl_buffer);

   /* update the framebuffer size */
   _mesa_resize_framebuffer(&osmesa->mesa, osmesa->gl_buffer, width, height);

   return GL_TRUE;
}



GLAPI OSMesaContext GLAPIENTRY
OSMesaGetCurrentContext( void )
{
   struct gl_context *ctx = _mesa_get_current_context();
   if (ctx)
      return (OSMesaContext) ctx;
   else
      return NULL;
}



GLAPI void GLAPIENTRY
OSMesaPixelStore( GLint pname, GLint value )
{
   OSMesaContext osmesa = OSMesaGetCurrentContext();

   switch (pname) {
      case OSMESA_ROW_LENGTH:
         if (value<0) {
            _mesa_error( &osmesa->mesa, GL_INVALID_VALUE,
                      "OSMesaPixelStore(value)" );
            return;
         }
         osmesa->userRowLength = value;
         break;
      case OSMESA_Y_UP:
         osmesa->yup = value ? GL_TRUE : GL_FALSE;
         break;
      default:
         _mesa_error( &osmesa->mesa, GL_INVALID_ENUM, "OSMesaPixelStore(pname)" );
         return;
   }

   compute_row_addresses( osmesa );
}


GLAPI void GLAPIENTRY
OSMesaGetIntegerv( GLint pname, GLint *value )
{
   OSMesaContext osmesa = OSMesaGetCurrentContext();

   switch (pname) {
      case OSMESA_WIDTH:
         if (osmesa->gl_buffer)
            *value = osmesa->gl_buffer->Width;
         else
            *value = 0;
         return;
      case OSMESA_HEIGHT:
         if (osmesa->gl_buffer)
            *value = osmesa->gl_buffer->Height;
         else
            *value = 0;
         return;
      case OSMESA_FORMAT:
         *value = osmesa->format;
         return;
      case OSMESA_TYPE:
         /* current color buffer's data type */
         *value = osmesa->DataType;
         return;
      case OSMESA_ROW_LENGTH:
         *value = osmesa->userRowLength;
         return;
      case OSMESA_Y_UP:
         *value = osmesa->yup;
         return;
      case OSMESA_MAX_WIDTH:
         *value = SWRAST_MAX_WIDTH;
         return;
      case OSMESA_MAX_HEIGHT:
         *value = SWRAST_MAX_HEIGHT;
         return;
      default:
         _mesa_error(&osmesa->mesa, GL_INVALID_ENUM, "OSMesaGetIntergerv(pname)");
         return;
   }
}


/**
 * Return the depth buffer associated with an OSMesa context.
 * Input:  c - the OSMesa context
 * Output:  width, height - size of buffer in pixels
 *          bytesPerValue - bytes per depth value (2 or 4)
 *          buffer - pointer to depth buffer values
 * Return:  GL_TRUE or GL_FALSE to indicate success or failure.
 */
GLAPI GLboolean GLAPIENTRY
OSMesaGetDepthBuffer( OSMesaContext c, GLint *width, GLint *height,
                      GLint *bytesPerValue, void **buffer )
{
   struct swrast_renderbuffer *srb = NULL;

   if (c->gl_buffer)
      srb = swrast_renderbuffer(c->gl_buffer->
                                Attachment[BUFFER_DEPTH].Renderbuffer);

   if (!srb || !srb->Buffer) {
      *width = 0;
      *height = 0;
      *bytesPerValue = 0;
      *buffer = 0;
      return GL_FALSE;
   }
   else {
      *width = srb->Base.Width;
      *height = srb->Base.Height;
      if (c->gl_visual->depthBits <= 16)
         *bytesPerValue = sizeof(GLushort);
      else
         *bytesPerValue = sizeof(GLuint);
      *buffer = (void *) srb->Buffer;
      return GL_TRUE;
   }
}


/**
 * Return the color buffer associated with an OSMesa context.
 * Input:  c - the OSMesa context
 * Output:  width, height - size of buffer in pixels
 *          format - the pixel format (OSMESA_FORMAT)
 *          buffer - pointer to color buffer values
 * Return:  GL_TRUE or GL_FALSE to indicate success or failure.
 */
GLAPI GLboolean GLAPIENTRY
OSMesaGetColorBuffer( OSMesaContext osmesa, GLint *width,
                      GLint *height, GLint *format, void **buffer )
{
   if (osmesa->srb && osmesa->srb->Buffer) {
      *width = osmesa->srb->Base.Width;
      *height = osmesa->srb->Base.Height;
      *format = osmesa->format;
      *buffer = (void *) osmesa->srb->Buffer;
      return GL_TRUE;
   }
   else {
      *width = 0;
      *height = 0;
      *format = 0;
      *buffer = 0;
      return GL_FALSE;
   }
}


struct name_function
{
   const char *Name;
   OSMESAproc Function;
};

static struct name_function functions[] = {
   { "OSMesaCreateContext", (OSMESAproc) OSMesaCreateContext },
   { "OSMesaCreateContextExt", (OSMESAproc) OSMesaCreateContextExt },
   { "OSMesaDestroyContext", (OSMESAproc) OSMesaDestroyContext },
   { "OSMesaMakeCurrent", (OSMESAproc) OSMesaMakeCurrent },
   { "OSMesaGetCurrentContext", (OSMESAproc) OSMesaGetCurrentContext },
   { "OSMesaPixelsStore", (OSMESAproc) OSMesaPixelStore },
   { "OSMesaGetIntegerv", (OSMESAproc) OSMesaGetIntegerv },
   { "OSMesaGetDepthBuffer", (OSMESAproc) OSMesaGetDepthBuffer },
   { "OSMesaGetColorBuffer", (OSMESAproc) OSMesaGetColorBuffer },
   { "OSMesaGetProcAddress", (OSMESAproc) OSMesaGetProcAddress },
   { "OSMesaColorClamp", (OSMESAproc) OSMesaColorClamp },
   { "OSMesaPostprocess", (OSMESAproc) OSMesaPostprocess },
   { NULL, NULL }
};


GLAPI OSMESAproc GLAPIENTRY
OSMesaGetProcAddress( const char *funcName )
{
   int i;
   for (i = 0; functions[i].Name; i++) {
      if (strcmp(functions[i].Name, funcName) == 0)
         return functions[i].Function;
   }
   return _glapi_get_proc_address(funcName);
}


GLAPI void GLAPIENTRY
OSMesaColorClamp(GLboolean enable)
{
   OSMesaContext osmesa = OSMesaGetCurrentContext();

   if (enable == GL_TRUE) {
      osmesa->mesa.Color.ClampFragmentColor = GL_TRUE;
   }
   else {
      osmesa->mesa.Color.ClampFragmentColor = GL_FIXED_ONLY_ARB;
   }
}


GLAPI void GLAPIENTRY
OSMesaPostprocess(OSMesaContext osmesa, const char *filter,
                  unsigned enable_value)
{
   fprintf(stderr,
           "OSMesaPostProcess() is only available with gallium drivers\n");
}



/**
 * When GLX_INDIRECT_RENDERING is defined, some symbols are missing in
 * libglapi.a.  We need to define them here.
 */
#ifdef GLX_INDIRECT_RENDERING

#define GL_GLEXT_PROTOTYPES
#include "GL/gl.h"
#include "glapi/glapi.h"
#include "glapi/glapitable.h"

#if defined(USE_MGL_NAMESPACE)
#define NAME(func)  mgl##func
#else
#define NAME(func)  gl##func
#endif

#define DISPATCH(FUNC, ARGS, MESSAGE)		\
   GET_DISPATCH()->FUNC ARGS

#define RETURN_DISPATCH(FUNC, ARGS, MESSAGE) 	\
   return GET_DISPATCH()->FUNC ARGS

/* skip normal ones */
#define _GLAPI_SKIP_NORMAL_ENTRY_POINTS
#include "glapi/glapitemp.h"

#endif /* GLX_INDIRECT_RENDERING */
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d86 1
a86 1
static inline OSMesaContext
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d86 1
a86 1
static INLINE OSMesaContext
@


1.7
log
@Merge Mesa 9.2.3
ok mpi@@ kettenis@@
@
text
@d208 10
a217 7
   if (ctx->RenderMode != GL_RENDER)      return NULL;
   if (ctx->Line.SmoothFlag)              return NULL;
   if (ctx->Texture._EnabledUnits)        return NULL;
   if (ctx->Light.ShadeModel != GL_FLAT)  return NULL;
   if (ctx->Line.Width != 1.0F)           return NULL;
   if (ctx->Line.StippleFlag)             return NULL;
   if (ctx->Line.SmoothFlag)              return NULL;
d220 3
a222 1
       osmesa->format != OSMESA_ARGB)     return NULL;
d224 3
a226 3
   if (swrast->_RasterMask==DEPTH_BIT
       && ctx->Depth.Func==GL_LESS
       && ctx->Depth.Mask==GL_TRUE
d228 1
a228 1
      return (swrast_line_func) flat_rgba_z_line;
d232 1
a232 1
      return (swrast_line_func) flat_rgba_line;
d319 8
a326 1
      return (swrast_tri_func) NULL;
a328 4
   if (ctx->RenderMode != GL_RENDER)    return (swrast_tri_func) NULL;
   if (ctx->Polygon.SmoothFlag)         return (swrast_tri_func) NULL;
   if (ctx->Polygon.StippleFlag)        return (swrast_tri_func) NULL;
   if (ctx->Texture._EnabledUnits)      return (swrast_tri_func) NULL;
d331 8
a338 4
       osmesa->format != OSMESA_ARGB)   return (swrast_tri_func) NULL;
   if (ctx->Polygon.CullFlag && 
       ctx->Polygon.CullFaceMode == GL_FRONT_AND_BACK)
                                        return (swrast_tri_func) NULL;
d345 1
a345 1
         return (swrast_tri_func) smooth_rgba_z_triangle;
d348 1
a348 1
         return (swrast_tri_func) flat_rgba_z_triangle;
d351 2
a352 1
   return (swrast_tri_func) NULL;
d452 1
a452 1
            rb->Format = MESA_FORMAT_RGBA8888_REV;
d454 1
a454 1
            rb->Format = MESA_FORMAT_RGBA8888;
d457 1
a457 1
         rb->Format = MESA_FORMAT_RGBA_16;
d466 1
a466 1
            rb->Format = MESA_FORMAT_ARGB8888;
d468 1
a468 1
            rb->Format = MESA_FORMAT_ARGB8888_REV;
d472 1
a472 1
         rb->Format = MESA_FORMAT_RGBA_16; /* not exactly right */
d482 1
a482 1
            rb->Format = MESA_FORMAT_ARGB8888_REV;
d484 1
a484 1
            rb->Format = MESA_FORMAT_ARGB8888;
d488 1
a488 1
         rb->Format = MESA_FORMAT_RGBA_16; /* not exactly right */
d497 1
a497 1
         rb->Format = MESA_FORMAT_RGB888;
d501 1
a501 1
         rb->Format = MESA_FORMAT_RGBA_16; /* not exactly right */
d510 1
a510 1
         rb->Format = MESA_FORMAT_BGR888;
d514 1
a514 1
         rb->Format = MESA_FORMAT_RGBA_16; /* not exactly right */
d523 1
a523 1
      rb->Format = MESA_FORMAT_RGB565;
d1132 1
d1161 10
@


1.6
log
@Merge Mesa 9.2.0
@
text
@d200 8
d308 8
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  6.5.3
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d38 1
d44 2
d48 2
d54 1
d64 2
d74 1
a74 1
   struct gl_renderbuffer *rb;  /*< The user's colorbuffer */
d79 1
a79 1
   GLvoid *rowaddr[MAX_HEIGHT];	/*< address of first pixel in each image row */
d82 1
a129 366
/**********************************************************************/
/*****        Read/write spans/arrays of pixels                   *****/
/**********************************************************************/

/* 8-bit RGBA */
#define NAME(PREFIX) PREFIX##_RGBA8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLubyte *P = (GLubyte *) osmesa->rowaddr[Y] + 4 * (X)
#define INC_PIXEL_PTR(P) P += 4
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[0] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[2] = VALUE[BCOMP];  \
   DST[3] = VALUE[ACOMP]
#define STORE_PIXEL_RGB(DST, X, Y, VALUE) \
   DST[0] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[2] = VALUE[BCOMP];  \
   DST[3] = 255
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[0];  \
   DST[GCOMP] = SRC[1];  \
   DST[BCOMP] = SRC[2];  \
   DST[ACOMP] = SRC[3]
#include "swrast/s_spantemp.h"

/* 16-bit RGBA */
#define NAME(PREFIX) PREFIX##_RGBA16
#define RB_TYPE GLushort
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLushort *P = (GLushort *) osmesa->rowaddr[Y] + 4 * (X)
#define INC_PIXEL_PTR(P) P += 4
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[0] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[2] = VALUE[BCOMP];  \
   DST[3] = VALUE[ACOMP]
#define STORE_PIXEL_RGB(DST, X, Y, VALUE) \
   DST[0] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[2] = VALUE[BCOMP];  \
   DST[3] = 65535
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[0];  \
   DST[GCOMP] = SRC[1];  \
   DST[BCOMP] = SRC[2];  \
   DST[ACOMP] = SRC[3]
#include "swrast/s_spantemp.h"

/* 32-bit RGBA */
#define NAME(PREFIX) PREFIX##_RGBA32
#define RB_TYPE GLfloat
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLfloat *P = (GLfloat *) osmesa->rowaddr[Y] + 4 * (X)
#define INC_PIXEL_PTR(P) P += 4
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[0] = MAX2((VALUE[RCOMP]), 0.0F); \
   DST[1] = MAX2((VALUE[GCOMP]), 0.0F); \
   DST[2] = MAX2((VALUE[BCOMP]), 0.0F); \
   DST[3] = CLAMP((VALUE[ACOMP]), 0.0F, 1.0F)
#define STORE_PIXEL_RGB(DST, X, Y, VALUE) \
   DST[0] = MAX2((VALUE[RCOMP]), 0.0F); \
   DST[1] = MAX2((VALUE[GCOMP]), 0.0F); \
   DST[2] = MAX2((VALUE[BCOMP]), 0.0F); \
   DST[3] = 1.0F
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[0];  \
   DST[GCOMP] = SRC[1];  \
   DST[BCOMP] = SRC[2];  \
   DST[ACOMP] = SRC[3]
#include "swrast/s_spantemp.h"


/* 8-bit BGRA */
#define NAME(PREFIX) PREFIX##_BGRA8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLubyte *P = (GLubyte *) osmesa->rowaddr[Y] + 4 * (X)
#define INC_PIXEL_PTR(P) P += 4
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[2] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[0] = VALUE[BCOMP];  \
   DST[3] = VALUE[ACOMP]
#define STORE_PIXEL_RGB(DST, X, Y, VALUE) \
   DST[2] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[0] = VALUE[BCOMP];  \
   DST[3] = 255
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[2];  \
   DST[GCOMP] = SRC[1];  \
   DST[BCOMP] = SRC[0];  \
   DST[ACOMP] = SRC[3]
#include "swrast/s_spantemp.h"

/* 16-bit BGRA */
#define NAME(PREFIX) PREFIX##_BGRA16
#define RB_TYPE GLushort
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLushort *P = (GLushort *) osmesa->rowaddr[Y] + 4 * (X)
#define INC_PIXEL_PTR(P) P += 4
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[2] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[0] = VALUE[BCOMP];  \
   DST[3] = VALUE[ACOMP]
#define STORE_PIXEL_RGB(DST, X, Y, VALUE) \
   DST[2] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[0] = VALUE[BCOMP];  \
   DST[3] = 65535
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[2];  \
   DST[GCOMP] = SRC[1];  \
   DST[BCOMP] = SRC[0];  \
   DST[ACOMP] = SRC[3]
#include "swrast/s_spantemp.h"

/* 32-bit BGRA */
#define NAME(PREFIX) PREFIX##_BGRA32
#define RB_TYPE GLfloat
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLfloat *P = (GLfloat *) osmesa->rowaddr[Y] + 4 * (X)
#define INC_PIXEL_PTR(P) P += 4
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[2] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[0] = VALUE[BCOMP];  \
   DST[3] = VALUE[ACOMP]
#define STORE_PIXEL_RGB(DST, X, Y, VALUE) \
   DST[2] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[0] = VALUE[BCOMP];  \
   DST[3] = 1.0F
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[2];  \
   DST[GCOMP] = SRC[1];  \
   DST[BCOMP] = SRC[0];  \
   DST[ACOMP] = SRC[3]
#include "swrast/s_spantemp.h"


/* 8-bit ARGB */
#define NAME(PREFIX) PREFIX##_ARGB8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLubyte *P = (GLubyte *) osmesa->rowaddr[Y] + 4 * (X)
#define INC_PIXEL_PTR(P) P += 4
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[1] = VALUE[RCOMP];  \
   DST[2] = VALUE[GCOMP];  \
   DST[3] = VALUE[BCOMP];  \
   DST[0] = VALUE[ACOMP]
#define STORE_PIXEL_RGB(DST, X, Y, VALUE) \
   DST[1] = VALUE[RCOMP];  \
   DST[2] = VALUE[GCOMP];  \
   DST[3] = VALUE[BCOMP];  \
   DST[0] = 255
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[1];  \
   DST[GCOMP] = SRC[2];  \
   DST[BCOMP] = SRC[3];  \
   DST[ACOMP] = SRC[0]
#include "swrast/s_spantemp.h"

/* 16-bit ARGB */
#define NAME(PREFIX) PREFIX##_ARGB16
#define RB_TYPE GLushort
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLushort *P = (GLushort *) osmesa->rowaddr[Y] + 4 * (X)
#define INC_PIXEL_PTR(P) P += 4
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[1] = VALUE[RCOMP];  \
   DST[2] = VALUE[GCOMP];  \
   DST[3] = VALUE[BCOMP];  \
   DST[0] = VALUE[ACOMP]
#define STORE_PIXEL_RGB(DST, X, Y, VALUE) \
   DST[1] = VALUE[RCOMP];  \
   DST[2] = VALUE[GCOMP];  \
   DST[3] = VALUE[BCOMP];  \
   DST[0] = 65535
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[1];  \
   DST[GCOMP] = SRC[2];  \
   DST[BCOMP] = SRC[3];  \
   DST[ACOMP] = SRC[0]
#include "swrast/s_spantemp.h"

/* 32-bit ARGB */
#define NAME(PREFIX) PREFIX##_ARGB32
#define RB_TYPE GLfloat
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLfloat *P = (GLfloat *) osmesa->rowaddr[Y] + 4 * (X)
#define INC_PIXEL_PTR(P) P += 4
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[1] = VALUE[RCOMP];  \
   DST[2] = VALUE[GCOMP];  \
   DST[3] = VALUE[BCOMP];  \
   DST[0] = VALUE[ACOMP]
#define STORE_PIXEL_RGB(DST, X, Y, VALUE) \
   DST[1] = VALUE[RCOMP];  \
   DST[2] = VALUE[GCOMP];  \
   DST[3] = VALUE[BCOMP];  \
   DST[0] = 1.0F
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[1];  \
   DST[GCOMP] = SRC[2];  \
   DST[BCOMP] = SRC[3];  \
   DST[ACOMP] = SRC[0]
#include "swrast/s_spantemp.h"


/* 8-bit RGB */
#define NAME(PREFIX) PREFIX##_RGB8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLubyte *P = (GLubyte *) osmesa->rowaddr[Y] + 3 * (X)
#define INC_PIXEL_PTR(P) P += 3
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[0] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[2] = VALUE[BCOMP]
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[0];  \
   DST[GCOMP] = SRC[1];  \
   DST[BCOMP] = SRC[2];  \
   DST[ACOMP] = 255
#include "swrast/s_spantemp.h"

/* 16-bit RGB */
#define NAME(PREFIX) PREFIX##_RGB16
#define RB_TYPE GLushort
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLushort *P = (GLushort *) osmesa->rowaddr[Y] + 3 * (X)
#define INC_PIXEL_PTR(P) P += 3
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[0] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[2] = VALUE[BCOMP]
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[0];  \
   DST[GCOMP] = SRC[1];  \
   DST[BCOMP] = SRC[2];  \
   DST[ACOMP] = 65535U
#include "swrast/s_spantemp.h"

/* 32-bit RGB */
#define NAME(PREFIX) PREFIX##_RGB32
#define RB_TYPE GLfloat
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLfloat *P = (GLfloat *) osmesa->rowaddr[Y] + 3 * (X)
#define INC_PIXEL_PTR(P) P += 3
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[0] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[2] = VALUE[BCOMP]
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[0];  \
   DST[GCOMP] = SRC[1];  \
   DST[BCOMP] = SRC[2];  \
   DST[ACOMP] = 1.0F
#include "swrast/s_spantemp.h"


/* 8-bit BGR */
#define NAME(PREFIX) PREFIX##_BGR8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLubyte *P = (GLubyte *) osmesa->rowaddr[Y] + 3 * (X)
#define INC_PIXEL_PTR(P) P += 3
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[2] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[0] = VALUE[BCOMP]
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[2];  \
   DST[GCOMP] = SRC[1];  \
   DST[BCOMP] = SRC[0];  \
   DST[ACOMP] = 255
#include "swrast/s_spantemp.h"

/* 16-bit BGR */
#define NAME(PREFIX) PREFIX##_BGR16
#define RB_TYPE GLushort
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLushort *P = (GLushort *) osmesa->rowaddr[Y] + 3 * (X)
#define INC_PIXEL_PTR(P) P += 3
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[2] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[0] = VALUE[BCOMP]
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[2];  \
   DST[GCOMP] = SRC[1];  \
   DST[BCOMP] = SRC[0];  \
   DST[ACOMP] = 65535
#include "swrast/s_spantemp.h"

/* 32-bit BGR */
#define NAME(PREFIX) PREFIX##_BGR32
#define RB_TYPE GLfloat
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLfloat *P = (GLfloat *) osmesa->rowaddr[Y] + 3 * (X)
#define INC_PIXEL_PTR(P) P += 3
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[2] = VALUE[RCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[0] = VALUE[BCOMP]
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[2];  \
   DST[GCOMP] = SRC[1];  \
   DST[BCOMP] = SRC[0];  \
   DST[ACOMP] = 1.0F
#include "swrast/s_spantemp.h"


/* 16-bit 5/6/5 RGB */
#define NAME(PREFIX) PREFIX##_RGB_565
#define RB_TYPE GLubyte
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLushort *P = (GLushort *) osmesa->rowaddr[Y] + (X)
#define INC_PIXEL_PTR(P) P += 1
#define STORE_PIXEL(DST, X, Y, VALUE) \
   *DST = ( (((VALUE[RCOMP]) & 0xf8) << 8) | (((VALUE[GCOMP]) & 0xfc) << 3) | ((VALUE[BCOMP]) >> 3) )
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = ( (((*SRC) >> 8) & 0xf8) | (((*SRC) >> 11) & 0x7) ); \
   DST[GCOMP] = ( (((*SRC) >> 3) & 0xfc) | (((*SRC) >>  5) & 0x3) ); \
   DST[BCOMP] = ( (((*SRC) << 3) & 0xf8) | (((*SRC)      ) & 0x7) ); \
   DST[ACOMP] = CHAN_MAX
#include "swrast/s_spantemp.h"


a199 3
   if (osmesa->rb->DataType != GL_UNSIGNED_BYTE)
      return NULL;

a300 3
   if (osmesa->rb->DataType != GL_UNSIGNED_BYTE)
      return (swrast_tri_func) NULL;

d360 2
a361 3
   GLint bytesPerPixel, bytesPerRow, i;
   GLubyte *origin = (GLubyte *) osmesa->rb->Data;
   GLint bpc; /* bytes per channel */
d363 1
a363 1
   GLint height = osmesa->rb->Height;
d368 1
a368 26
      rowlength = osmesa->rb->Width;

   if (osmesa->rb->DataType == GL_UNSIGNED_BYTE)
      bpc = 1;
   else if (osmesa->rb->DataType == GL_UNSIGNED_SHORT)
      bpc = 2;
   else if (osmesa->rb->DataType == GL_FLOAT)
      bpc = 4;
   else {
      _mesa_problem(&osmesa->mesa,
                    "Unexpected datatype in osmesa::compute_row_addresses");
      return;
   }

   if ((osmesa->format == OSMESA_RGB) || (osmesa->format == OSMESA_BGR)) {
      /* RGB mode */
      bytesPerPixel = 3 * bpc;
   }
   else if (osmesa->format == OSMESA_RGB_565) {
      /* 5/6/5 RGB pixel in 16 bits */
      bytesPerPixel = 2;
   }
   else {
      /* RGBA mode */
      bytesPerPixel = 4 * bpc;
   }
d370 1
a370 1
   bytesPerRow = rowlength * bytesPerPixel;
d390 1
a390 1
 * Don't use _mesa_delete_renderbuffer since we can't free rb->Data.
d393 1
a393 1
osmesa_delete_renderbuffer(struct gl_renderbuffer *rb)
d395 1
a395 1
   free(rb);
a408 8
   GLint bpc; /* bits per channel */

   if (rb->DataType == GL_UNSIGNED_BYTE)
      bpc = 8;
   else if (rb->DataType == GL_UNSIGNED_SHORT)
      bpc = 16;
   else
      bpc = 32;
d413 7
d421 8
a428 17
      if (rb->DataType == GL_UNSIGNED_BYTE) {
         rb->GetRow = get_row_RGBA8;
         rb->GetValues = get_values_RGBA8;
         rb->PutRow = put_row_RGBA8;
         rb->PutRowRGB = put_row_rgb_RGBA8;
         rb->PutMonoRow = put_mono_row_RGBA8;
         rb->PutValues = put_values_RGBA8;
         rb->PutMonoValues = put_mono_values_RGBA8;
      }
      else if (rb->DataType == GL_UNSIGNED_SHORT) {
         rb->GetRow = get_row_RGBA16;
         rb->GetValues = get_values_RGBA16;
         rb->PutRow = put_row_RGBA16;
         rb->PutRowRGB = put_row_rgb_RGBA16;
         rb->PutMonoRow = put_mono_row_RGBA16;
         rb->PutValues = put_values_RGBA16;
         rb->PutMonoValues = put_mono_values_RGBA16;
d431 1
a431 7
         rb->GetRow = get_row_RGBA32;
         rb->GetValues = get_values_RGBA32;
         rb->PutRow = put_row_RGBA32;
         rb->PutRowRGB = put_row_rgb_RGBA32;
         rb->PutMonoRow = put_mono_row_RGBA32;
         rb->PutValues = put_values_RGBA32;
         rb->PutMonoValues = put_mono_values_RGBA32;
d435 9
a443 17
      if (rb->DataType == GL_UNSIGNED_BYTE) {
         rb->GetRow = get_row_BGRA8;
         rb->GetValues = get_values_BGRA8;
         rb->PutRow = put_row_BGRA8;
         rb->PutRowRGB = put_row_rgb_BGRA8;
         rb->PutMonoRow = put_mono_row_BGRA8;
         rb->PutValues = put_values_BGRA8;
         rb->PutMonoValues = put_mono_values_BGRA8;
      }
      else if (rb->DataType == GL_UNSIGNED_SHORT) {
         rb->GetRow = get_row_BGRA16;
         rb->GetValues = get_values_BGRA16;
         rb->PutRow = put_row_BGRA16;
         rb->PutRowRGB = put_row_rgb_BGRA16;
         rb->PutMonoRow = put_mono_row_BGRA16;
         rb->PutValues = put_values_BGRA16;
         rb->PutMonoValues = put_mono_values_BGRA16;
d446 2
a447 7
         rb->GetRow = get_row_BGRA32;
         rb->GetValues = get_values_BGRA32;
         rb->PutRow = put_row_BGRA32;
         rb->PutRowRGB = put_row_rgb_BGRA32;
         rb->PutMonoRow = put_mono_row_BGRA32;
         rb->PutValues = put_values_BGRA32;
         rb->PutMonoValues = put_mono_values_BGRA32;
d451 9
a459 17
      if (rb->DataType == GL_UNSIGNED_BYTE) {
         rb->GetRow = get_row_ARGB8;
         rb->GetValues = get_values_ARGB8;
         rb->PutRow = put_row_ARGB8;
         rb->PutRowRGB = put_row_rgb_ARGB8;
         rb->PutMonoRow = put_mono_row_ARGB8;
         rb->PutValues = put_values_ARGB8;
         rb->PutMonoValues = put_mono_values_ARGB8;
      }
      else if (rb->DataType == GL_UNSIGNED_SHORT) {
         rb->GetRow = get_row_ARGB16;
         rb->GetValues = get_values_ARGB16;
         rb->PutRow = put_row_ARGB16;
         rb->PutRowRGB = put_row_rgb_ARGB16;
         rb->PutMonoRow = put_mono_row_ARGB16;
         rb->PutValues = put_values_ARGB16;
         rb->PutMonoValues = put_mono_values_ARGB16;
d462 2
a463 7
         rb->GetRow = get_row_ARGB32;
         rb->GetValues = get_values_ARGB32;
         rb->PutRow = put_row_ARGB32;
         rb->PutRowRGB = put_row_rgb_ARGB32;
         rb->PutMonoRow = put_mono_row_ARGB32;
         rb->PutValues = put_values_ARGB32;
         rb->PutMonoValues = put_mono_values_ARGB32;
d467 6
a472 17
      if (rb->DataType == GL_UNSIGNED_BYTE) {
         rb->GetRow = get_row_RGB8;
         rb->GetValues = get_values_RGB8;
         rb->PutRow = put_row_RGB8;
         rb->PutRowRGB = put_row_rgb_RGB8;
         rb->PutMonoRow = put_mono_row_RGB8;
         rb->PutValues = put_values_RGB8;
         rb->PutMonoValues = put_mono_values_RGB8;
      }
      else if (rb->DataType == GL_UNSIGNED_SHORT) {
         rb->GetRow = get_row_RGB16;
         rb->GetValues = get_values_RGB16;
         rb->PutRow = put_row_RGB16;
         rb->PutRowRGB = put_row_rgb_RGB16;
         rb->PutMonoRow = put_mono_row_RGB16;
         rb->PutValues = put_values_RGB16;
         rb->PutMonoValues = put_mono_values_RGB16;
d475 2
a476 7
         rb->GetRow = get_row_RGB32;
         rb->GetValues = get_values_RGB32;
         rb->PutRow = put_row_RGB32;
         rb->PutRowRGB = put_row_rgb_RGB32;
         rb->PutMonoRow = put_mono_row_RGB32;
         rb->PutValues = put_values_RGB32;
         rb->PutMonoValues = put_mono_values_RGB32;
d480 6
a485 17
      if (rb->DataType == GL_UNSIGNED_BYTE) {
         rb->GetRow = get_row_BGR8;
         rb->GetValues = get_values_BGR8;
         rb->PutRow = put_row_BGR8;
         rb->PutRowRGB = put_row_rgb_BGR8;
         rb->PutMonoRow = put_mono_row_BGR8;
         rb->PutValues = put_values_BGR8;
         rb->PutMonoValues = put_mono_values_BGR8;
      }
      else if (rb->DataType == GL_UNSIGNED_SHORT) {
         rb->GetRow = get_row_BGR16;
         rb->GetValues = get_values_BGR16;
         rb->PutRow = put_row_BGR16;
         rb->PutRowRGB = put_row_rgb_BGR16;
         rb->PutMonoRow = put_mono_row_BGR16;
         rb->PutValues = put_values_BGR16;
         rb->PutMonoValues = put_mono_values_BGR16;
d488 2
a489 7
         rb->GetRow = get_row_BGR32;
         rb->GetValues = get_values_BGR32;
         rb->PutRow = put_row_BGR32;
         rb->PutRowRGB = put_row_rgb_BGR32;
         rb->PutMonoRow = put_mono_row_BGR32;
         rb->PutValues = put_values_BGR32;
         rb->PutMonoValues = put_mono_values_BGR32;
d493 2
a494 8
      ASSERT(rb->DataType == GL_UNSIGNED_BYTE);
      rb->GetRow = get_row_RGB_565;
      rb->GetValues = get_values_RGB_565;
      rb->PutRow = put_row_RGB_565;
      rb->PutRowRGB = put_row_rgb_RGB_565;
      rb->PutMonoRow = put_mono_row_RGB_565;
      rb->PutValues = put_values_RGB_565;
      rb->PutMonoValues = put_mono_values_RGB_565;
d512 1
a512 1
static struct gl_renderbuffer *
d516 47
a562 20
   struct gl_renderbuffer *rb = _mesa_new_renderbuffer(ctx, name);
   if (rb) {
      rb->RefCount = 1;
      rb->Delete = osmesa_delete_renderbuffer;
      rb->AllocStorage = osmesa_renderbuffer_storage;

      rb->InternalFormat = GL_RGBA;
      switch (type) {
      case GL_UNSIGNED_BYTE:
         rb->Format = MESA_FORMAT_RGBA8888;
         break;
      case GL_UNSIGNED_SHORT:
         rb->Format = MESA_FORMAT_RGBA_16;
         break;
      case GL_FLOAT:
         rb->Format = MESA_FORMAT_RGBA_FLOAT32;
         break;
      default:
         assert(0 && "Unexpected type in new_osmesa_renderbuffer()");
         rb->Format = MESA_FORMAT_RGBA8888;
d564 18
a581 2
      rb->_BaseFormat = GL_RGBA;
      rb->DataType = type;
a582 1
   return rb;
a712 1
      functions.GetBufferSize = NULL;
d715 1
a715 1
                                    API_OPENGL,
d719 1
a719 1
                                    &functions, (void *) osmesa)) {
a725 5
      _mesa_enable_1_3_extensions(&(osmesa->mesa));
      _mesa_enable_1_4_extensions(&(osmesa->mesa));
      _mesa_enable_1_5_extensions(&(osmesa->mesa));
      _mesa_enable_2_0_extensions(&(osmesa->mesa));
      _mesa_enable_2_1_extensions(&(osmesa->mesa));
d738 7
a744 7
      _mesa_add_soft_renderbuffers(osmesa->gl_buffer,
                                   GL_FALSE, /* color */
                                   osmesa->gl_visual->haveDepthBuffer,
                                   osmesa->gl_visual->haveStencilBuffer,
                                   osmesa->gl_visual->haveAccumBuffer,
                                   GL_FALSE, /* alpha */
                                   GL_FALSE /* aux */ );
d778 5
d789 6
d810 2
a811 2
      if (osmesa->rb)
         _mesa_reference_renderbuffer(&osmesa->rb, NULL);
d861 1
a861 1
       width > MAX_WIDTH || height > MAX_HEIGHT) {
d894 2
a895 2
   if (!osmesa->rb) {
      osmesa->rb = new_osmesa_renderbuffer(&osmesa->mesa, osmesa->format, type);
d897 3
a899 2
      _mesa_add_renderbuffer(osmesa->gl_buffer, BUFFER_FRONT_LEFT, osmesa->rb);
      assert(osmesa->rb->RefCount == 2);
d902 2
d907 2
a908 2
   osmesa->rb->Data = buffer;
   osmesa->rb->Width = osmesa->rb->Height = 0;
a913 1
   osmesa->gl_buffer->Initialized = GL_TRUE; /* XXX TEMPORARY? */
d921 2
a922 1
   _mesa_add_renderbuffer(osmesa->gl_buffer, BUFFER_FRONT_LEFT, osmesa->rb);
d997 1
a997 6
         if (osmesa->rb) {
            *value = osmesa->rb->DataType;
         }
         else {
            *value = 0;
         }
d1006 1
a1006 1
         *value = MAX_WIDTH;
d1009 1
a1009 1
         *value = MAX_HEIGHT;
d1030 1
a1030 1
   struct gl_renderbuffer *rb = NULL;
d1033 2
a1034 1
      rb = c->gl_buffer->Attachment[BUFFER_DEPTH].Renderbuffer;
d1036 1
a1036 1
   if (!rb || !rb->Data) {
d1044 2
a1045 2
      *width = rb->Width;
      *height = rb->Height;
d1050 1
a1050 1
      *buffer = rb->Data;
d1068 3
a1070 3
   if (osmesa->rb && osmesa->rb->Data) {
      *width = osmesa->rb->Width;
      *height = osmesa->rb->Height;
d1072 1
a1072 1
      *buffer = osmesa->rb->Data;
@


1.4
log
@Merge Mesa 7.10.3
@
text
@a517 3
#ifdef WIN32
#include "..\swrast\s_linetemp.h"
#else
a518 1
#endif
a542 3
#ifdef WIN32
#include "..\swrast\s_linetemp.h"
#else
a543 1
#endif
a618 3
#ifdef WIN32
#include "..\swrast\s_tritemp.h"
#else
a619 1
#endif
d647 1
a647 3
#ifdef WIN32
#include "..\swrast\s_tritemp.h"
#else
a648 1
#endif
d1143 1
d1345 1
a1345 1
   _mesa_update_framebuffer_visual(osmesa->gl_buffer);
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d60 1
a60 1
 * OSMesa rendering context, derived from core Mesa GLcontext.
d64 2
a65 2
   GLcontext mesa;		/*< Base class - this must be first */
   GLvisual *gl_visual;		/*< Describes the buffers */
d67 1
a67 1
   GLframebuffer *gl_buffer;	/*< The framebuffer, containing user's rb */
d78 1
a78 1
OSMESA_CONTEXT(GLcontext *ctx)
d91 1
a91 1
get_string( GLcontext *ctx, GLenum name )
d110 1
a110 1
osmesa_update_state( GLcontext *ctx, GLuint new_state )
d560 1
a560 1
osmesa_choose_line_function( GLcontext *ctx )
d671 1
a671 1
osmesa_choose_triangle_function( GLcontext *ctx )
d711 1
a711 1
osmesa_choose_triangle( GLcontext *ctx )
d721 1
a721 1
osmesa_choose_line( GLcontext *ctx )
d809 1
a809 1
osmesa_renderbuffer_storage(GLcontext *ctx, struct gl_renderbuffer *rb,
d997 1
a997 1
new_osmesa_renderbuffer(GLcontext *ctx, GLenum format, GLenum type)
d1012 1
a1012 1
         rb->Format = MESA_FORMAT_SIGNED_RGBA_16;
a1063 1
   GLenum type = CHAN_TYPE;
d1160 1
a1160 1
                                              : (GLcontext *) NULL,
d1205 1
a1205 1
	 GLcontext *ctx = &osmesa->mesa;
d1330 6
a1335 3
   osmesa->rb = new_osmesa_renderbuffer(&osmesa->mesa, osmesa->format, type);
   _mesa_add_renderbuffer(osmesa->gl_buffer, BUFFER_FRONT_LEFT, osmesa->rb);
   assert(osmesa->rb->RefCount == 2);
d1372 1
a1372 1
   GLcontext *ctx = _mesa_get_current_context();
d1570 28
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d40 1
d54 1
a486 18
/* color index */
#define NAME(PREFIX) PREFIX##_CI
#define CI_MODE
#define RB_TYPE GLubyte
#define SPAN_VARS \
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
#define INIT_PIXEL_PTR(P, X, Y) \
   GLubyte *P = (GLubyte *) osmesa->rowaddr[Y] + (X)
#define INC_PIXEL_PTR(P) P += 1
#define STORE_PIXEL(DST, X, Y, VALUE) \
   *DST = VALUE[0]
#define FETCH_PIXEL(DST, SRC) \
   DST = SRC[0]
#include "swrast/s_spantemp.h"




d761 1
a761 5
   if (osmesa->format == OSMESA_COLOR_INDEX) {
      /* CI mode */
      bytesPerPixel = 1 * sizeof(GLubyte);
   }
   else if ((osmesa->format == OSMESA_RGB) || (osmesa->format == OSMESA_BGR)) {
d799 1
a799 1
   _mesa_free(rb);
a821 5
   rb->RedBits =
   rb->GreenBits =
   rb->BlueBits =
   rb->AlphaBits = bpc;

a852 1
      rb->RedBits = rb->GreenBits = rb->BlueBits = rb->AlphaBits = bpc;
a881 1
      rb->RedBits = rb->GreenBits = rb->BlueBits = rb->AlphaBits = bpc;
a910 1
      rb->RedBits = rb->GreenBits = rb->BlueBits = rb->AlphaBits = bpc;
a939 1
      rb->RedBits = rb->GreenBits = rb->BlueBits = bpc;
a968 1
      rb->RedBits = rb->GreenBits = rb->BlueBits = bpc;
a978 12
      rb->RedBits = 5;
      rb->GreenBits = 6;
      rb->BlueBits = 5;
   }
   else if (osmesa->format == OSMESA_COLOR_INDEX) {
      rb->GetRow = get_row_CI;
      rb->GetValues = get_values_CI;
      rb->PutRow = put_row_CI;
      rb->PutMonoRow = put_mono_row_CI;
      rb->PutValues = put_values_CI;
      rb->PutMonoValues = put_mono_values_CI;
      rb->IndexBits = 8;
d1006 14
a1019 11
      if (format == OSMESA_COLOR_INDEX) {
         rb->InternalFormat = GL_COLOR_INDEX;
         rb->_ActualFormat = GL_COLOR_INDEX8_EXT;
         rb->_BaseFormat = GL_COLOR_INDEX;
         rb->DataType = GL_UNSIGNED_BYTE;
      }
      else {
         rb->InternalFormat = GL_RGBA;
         rb->_ActualFormat = GL_RGBA;
         rb->_BaseFormat = GL_RGBA;
         rb->DataType = type;
d1021 2
d1037 1
a1037 1
 * Input:  format - either GL_RGBA or GL_COLOR_INDEX
a1044 1
   const GLint accumBits = (format == OSMESA_COLOR_INDEX) ? 0 : 16;
d1046 1
a1046 1
                                 8, accumBits, sharelist);
d1063 1
a1063 2
   GLint indexBits = 0, redBits = 0, greenBits = 0, blueBits = 0, alphaBits =0;
   GLboolean rgbmode;
d1067 1
a1067 6
   if (format==OSMESA_COLOR_INDEX) {
      indexBits = 8;
      rgbmode = GL_FALSE;
   }
   else if (format==OSMESA_RGBA) {
      indexBits = 0;
a1075 1
      rgbmode = GL_TRUE;
a1077 1
      indexBits = 0;
a1085 1
      rgbmode = GL_TRUE;
a1087 1
      indexBits = 0;
a1095 1
      rgbmode = GL_TRUE;
a1097 1
      indexBits = 0;
a1104 1
      rgbmode = GL_TRUE;
a1106 1
      indexBits = 0;
a1113 1
      rgbmode = GL_TRUE;
a1116 1
      indexBits = 0;
a1123 1
      rgbmode = GL_TRUE;
d1132 1
a1132 2
      osmesa->gl_visual = _mesa_create_visual( rgbmode,
                                               GL_FALSE,    /* double buffer */
a1137 1
                                               indexBits,
d1147 1
a1147 1
         _mesa_free(osmesa);
d1164 1
a1164 1
         _mesa_free(osmesa);
d1179 1
a1179 1
         _mesa_free(osmesa);
d1183 3
a1185 5
      /* create front color buffer in user-provided memory (no back buffer) */
      osmesa->rb = new_osmesa_renderbuffer(&osmesa->mesa, format, type);
      _mesa_add_renderbuffer(osmesa->gl_buffer, BUFFER_FRONT_LEFT, osmesa->rb);
      assert(osmesa->rb->RefCount == 2);
                        
d1202 2
d1216 1
a1216 1
            _mesa_free(osmesa);
d1250 2
d1258 1
a1258 1
      _mesa_unreference_framebuffer( &osmesa->gl_buffer );
d1261 1
a1261 1
      _mesa_free( osmesa );
d1322 13
a1338 1
   osmesa->rb->DataType = type;
d1547 1
a1547 1
      if (_mesa_strcmp(functions[i].Name, funcName) == 0)
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d36 1
a36 1
#include "glheader.h"
d38 6
a43 7
#include "context.h"
#include "extensions.h"
#include "framebuffer.h"
#include "imports.h"
#include "mtypes.h"
#include "renderbuffer.h"
#include "array_cache/acache.h"
d53 1
a66 2
   GLint width, height;		/*< size of image buffer */
   GLint rowlength;		/*< number of pixels per row */
a112 1
   _ac_InvalidateState( ctx, new_state );
d114 1
a117 17
/**
 * Just return the current buffer size.
 * There's no window to track the size of.
 */
static void
get_buffer_size( GLframebuffer *buffer, GLuint *width, GLuint *height )
{
   /* don't use GET_CURRENT_CONTEXT(ctx) here - it's a problem on Windows */
   GLcontext *ctx = (GLcontext *) _glapi_get_context();
   (void) buffer;
   if (ctx) {
      OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
      *width = osmesa->width;
      *height = osmesa->height;
   }
}

d581 3
a583 1
   if (CHAN_BITS != 8)                    return NULL;
d692 3
a694 1
   if (CHAN_BITS != 8)                  return (swrast_tri_func) NULL;
d747 66
d842 5
d1029 2
d1044 1
a1064 59

/**
 * Recompute the values of the context's rowaddr array.
 */
static void
compute_row_addresses( OSMesaContext osmesa )
{
   GLint bytesPerPixel, bytesPerRow, i;
   GLubyte *origin = (GLubyte *) osmesa->rb->Data;
   GLint bpc; /* bytes per channel */

   if (osmesa->rb->DataType == GL_UNSIGNED_BYTE)
      bpc = 1;
   else if (osmesa->rb->DataType == GL_UNSIGNED_SHORT)
      bpc = 2;
   else if (osmesa->rb->DataType == GL_FLOAT)
      bpc = 4;
   else {
      _mesa_problem(&osmesa->mesa,
                    "Unexpected datatype in osmesa::compute_row_addresses");
      return;
   }

   if (osmesa->format == OSMESA_COLOR_INDEX) {
      /* CI mode */
      bytesPerPixel = 1 * sizeof(GLubyte);
   }
   else if ((osmesa->format == OSMESA_RGB) || (osmesa->format == OSMESA_BGR)) {
      /* RGB mode */
      bytesPerPixel = 3 * bpc;
   }
   else if (osmesa->format == OSMESA_RGB_565) {
      /* 5/6/5 RGB pixel in 16 bits */
      bytesPerPixel = 2;
   }
   else {
      /* RGBA mode */
      bytesPerPixel = 4 * bpc;
   }

   bytesPerRow = osmesa->rowlength * bytesPerPixel;

   if (osmesa->yup) {
      /* Y=0 is bottom line of window */
      for (i = 0; i < MAX_HEIGHT; i++) {
         osmesa->rowaddr[i] = (GLvoid *) ((GLubyte *) origin + i * bytesPerRow);
      }
   }
   else {
      /* Y=0 is top line of window */
      for (i = 0; i < MAX_HEIGHT; i++) {
         GLint j = osmesa->height - i - 1;
         osmesa->rowaddr[i] = (GLvoid *) ((GLubyte *) origin + j * bytesPerRow);
      }
   }
}



d1213 1
a1213 1
      functions.GetBufferSize = get_buffer_size;
d1229 2
d1243 1
a1253 2
      osmesa->width = 0;
      osmesa->height = 0;
a1254 1
      osmesa->rowlength = 0;
d1268 1
a1268 1
             !_ac_CreateContext( ctx ) ||
d1304 3
d1309 1
a1309 1
      _ac_DestroyContext( &osmesa->mesa );
d1313 2
a1314 1
      _mesa_destroy_framebuffer( osmesa->gl_buffer );
d1361 1
d1368 1
a1368 8

   /* Need to set these before calling _mesa_make_current() since the first
    * time the context is bound, _mesa_make_current() will call our
    * get_buffer_size() function to initialize the viewport.  These are the
    * values returned by get_buffer_size():
    */
   osmesa->width = width;
   osmesa->height = height;
d1377 3
a1379 7
   _mesa_make_current( &osmesa->mesa, osmesa->gl_buffer, osmesa->gl_buffer );

   if (osmesa->userRowLength)
      osmesa->rowlength = osmesa->userRowLength;
   else
      osmesa->rowlength = width;

d1382 7
a1388 1
   compute_row_addresses( osmesa );
d1390 1
a1390 3
   /* update the color renderbuffer's format, type, width, height */
   osmesa_renderbuffer_storage(&osmesa->mesa, osmesa->rb,
                               osmesa->rb->InternalFormat, width, height);
d1393 1
a1393 1
    * renderbuffer adaptor/wrapper if needed.
a1434 1
         osmesa->rowlength = value ? value : osmesa->width;
d1455 4
a1458 1
         *value = osmesa->width;
d1461 4
a1464 1
         *value = osmesa->height;
d1522 2
a1523 2
      *width = c->gl_buffer->Width;
      *height = c->gl_buffer->Height;
d1580 1
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d67 2
d120 17
d600 1
a600 3
   if (osmesa->rb->DataType != GL_UNSIGNED_BYTE)
      return NULL;

d709 1
a709 3
   if (osmesa->rb->DataType != GL_UNSIGNED_BYTE)
      return (swrast_tri_func) NULL;

a761 66

/**
 * Recompute the values of the context's rowaddr array.
 */
static void
compute_row_addresses( OSMesaContext osmesa )
{
   GLint bytesPerPixel, bytesPerRow, i;
   GLubyte *origin = (GLubyte *) osmesa->rb->Data;
   GLint bpc; /* bytes per channel */
   GLint rowlength; /* in pixels */
   GLint height = osmesa->rb->Height;

   if (osmesa->userRowLength)
      rowlength = osmesa->userRowLength;
   else
      rowlength = osmesa->rb->Width;

   if (osmesa->rb->DataType == GL_UNSIGNED_BYTE)
      bpc = 1;
   else if (osmesa->rb->DataType == GL_UNSIGNED_SHORT)
      bpc = 2;
   else if (osmesa->rb->DataType == GL_FLOAT)
      bpc = 4;
   else {
      _mesa_problem(&osmesa->mesa,
                    "Unexpected datatype in osmesa::compute_row_addresses");
      return;
   }

   if (osmesa->format == OSMESA_COLOR_INDEX) {
      /* CI mode */
      bytesPerPixel = 1 * sizeof(GLubyte);
   }
   else if ((osmesa->format == OSMESA_RGB) || (osmesa->format == OSMESA_BGR)) {
      /* RGB mode */
      bytesPerPixel = 3 * bpc;
   }
   else if (osmesa->format == OSMESA_RGB_565) {
      /* 5/6/5 RGB pixel in 16 bits */
      bytesPerPixel = 2;
   }
   else {
      /* RGBA mode */
      bytesPerPixel = 4 * bpc;
   }

   bytesPerRow = rowlength * bytesPerPixel;

   if (osmesa->yup) {
      /* Y=0 is bottom line of window */
      for (i = 0; i < height; i++) {
         osmesa->rowaddr[i] = (GLvoid *) ((GLubyte *) origin + i * bytesPerRow);
      }
   }
   else {
      /* Y=0 is top line of window */
      for (i = 0; i < height; i++) {
         GLint j = height - i - 1;
         osmesa->rowaddr[i] = (GLvoid *) ((GLubyte *) origin + j * bytesPerRow);
      }
   }
}



a790 5
   rb->RedBits =
   rb->GreenBits =
   rb->BlueBits =
   rb->AlphaBits = bpc;

a972 2
   compute_row_addresses( osmesa );

d1006 59
d1213 1
a1213 1
      functions.GetBufferSize = NULL;
d1251 2
d1254 1
a1356 1
#if 0
d1363 8
a1370 1
#endif
d1379 7
a1385 3
   /* Set renderbuffer fields.  Set width/height = 0 to force 
    * osmesa_renderbuffer_storage() being called by _mesa_resize_framebuffer()
    */
d1388 1
a1388 7
   osmesa->rb->Width = osmesa->rb->Height = 0;

   /* Set the framebuffer's size.  This causes the
    * osmesa_renderbuffer_storage() function to get called.
    */
   _mesa_resize_framebuffer(&osmesa->mesa, osmesa->gl_buffer, width, height);
   osmesa->gl_buffer->Initialized = GL_TRUE; /* XXX TEMPORARY? */
d1390 3
a1392 1
   _mesa_make_current( &osmesa->mesa, osmesa->gl_buffer, osmesa->gl_buffer );
d1395 1
a1395 1
    * renderbuffer adaptor/wrapper if needed (for bpp conversion).
d1437 1
d1458 1
a1458 4
         if (osmesa->gl_buffer)
            *value = osmesa->gl_buffer->Width;
         else
            *value = 0;
d1461 1
a1461 4
         if (osmesa->gl_buffer)
            *value = osmesa->gl_buffer->Height;
         else
            *value = 0;
d1519 2
a1520 2
      *width = rb->Width;
      *height = rb->Height;
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d44 1
a53 1
#include "vbo/vbo.h"
d113 1
a114 1
   _vbo_InvalidateState( ctx, new_state );
a1043 1
      rb->RefCount = 1;
a1239 1
      assert(osmesa->rb->RefCount == 2);
d1264 1
a1264 1
             !_vbo_CreateContext( ctx ) ||
a1299 3
      if (osmesa->rb)
         _mesa_reference_renderbuffer(&osmesa->rb, NULL);

d1302 1
a1302 1
      _vbo_DestroyContext( &osmesa->mesa );
d1306 1
a1306 2
      _mesa_unreference_framebuffer( &osmesa->gl_buffer );

a1571 1
   { "OSMesaColorClamp", (OSMESAproc) OSMesaColorClamp },
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d36 1
a36 1
#include "main/glheader.h"
d38 6
a43 7
#include "main/context.h"
#include "main/extensions.h"
#include "main/formats.h"
#include "main/framebuffer.h"
#include "main/imports.h"
#include "main/mtypes.h"
#include "main/renderbuffer.h"
a52 1
#include "drivers/common/meta.h"
d58 1
a58 1
 * OSMesa rendering context, derived from core Mesa struct gl_context.
d62 2
a63 2
   struct gl_context mesa;		/*< Base class - this must be first */
   struct gl_config *gl_visual;		/*< Describes the buffers */
d65 1
a65 1
   struct gl_framebuffer *gl_buffer;	/*< The framebuffer, containing user's rb */
d76 1
a76 1
OSMESA_CONTEXT(struct gl_context *ctx)
d89 1
a89 1
get_string( struct gl_context *ctx, GLenum name )
d108 1
a108 1
osmesa_update_state( struct gl_context *ctx, GLuint new_state )
d485 18
d576 1
a576 1
osmesa_choose_line_function( struct gl_context *ctx )
d687 1
a687 1
osmesa_choose_triangle_function( struct gl_context *ctx )
d727 1
a727 1
osmesa_choose_triangle( struct gl_context *ctx )
d737 1
a737 1
osmesa_choose_line( struct gl_context *ctx )
d777 5
a781 1
   if ((osmesa->format == OSMESA_RGB) || (osmesa->format == OSMESA_BGR)) {
d819 1
a819 1
   free(rb);
d829 1
a829 1
osmesa_renderbuffer_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
d842 5
d878 1
d908 1
d938 1
d968 1
d998 1
d1009 12
d1039 1
a1039 1
new_osmesa_renderbuffer(struct gl_context *ctx, GLenum format, GLenum type)
d1048 11
a1058 14
      rb->InternalFormat = GL_RGBA;
      switch (type) {
      case GL_UNSIGNED_BYTE:
         rb->Format = MESA_FORMAT_RGBA8888;
         break;
      case GL_UNSIGNED_SHORT:
         rb->Format = MESA_FORMAT_RGBA_16;
         break;
      case GL_FLOAT:
         rb->Format = MESA_FORMAT_RGBA_FLOAT32;
         break;
      default:
         assert(0 && "Unexpected type in new_osmesa_renderbuffer()");
         rb->Format = MESA_FORMAT_RGBA8888;
a1059 2
      rb->_BaseFormat = GL_RGBA;
      rb->DataType = type;
d1074 1
a1074 1
 * Input:  format - Must be GL_RGBA
d1082 1
d1084 1
a1084 1
                                 8, 0, sharelist);
d1101 3
a1103 1
   GLint redBits = 0, greenBits = 0, blueBits = 0, alphaBits =0;
d1106 6
a1111 1
   if (format==OSMESA_RGBA) {
d1120 1
d1123 1
d1132 1
d1135 1
d1144 1
d1147 1
d1155 1
d1158 1
d1166 1
d1170 1
d1178 1
d1187 2
a1188 1
      osmesa->gl_visual = _mesa_create_visual( GL_FALSE,    /* double buffer */
d1194 1
d1204 1
a1204 1
         free(osmesa);
d1218 1
a1218 1
                                              : (struct gl_context *) NULL,
d1221 1
a1221 1
         free(osmesa);
a1228 2
      _mesa_enable_2_0_extensions(&(osmesa->mesa));
      _mesa_enable_2_1_extensions(&(osmesa->mesa));
d1234 1
a1234 1
         free(osmesa);
d1238 5
a1242 3
      /* Create depth/stencil/accum buffers.  We'll create the color
       * buffer later in OSMesaMakeCurrent().
       */
a1258 2
      _mesa_meta_init(&osmesa->mesa);

d1261 1
a1261 1
	 struct gl_context *ctx = &osmesa->mesa;
d1271 1
a1271 1
            free(osmesa);
a1304 2
      _mesa_meta_free( &osmesa->mesa );

d1311 1
a1311 1
      _mesa_reference_framebuffer( &osmesa->gl_buffer, NULL );
d1314 1
a1314 1
      free( osmesa );
a1374 16

   /* Create a front/left color buffer which wraps the user-provided buffer.
    * There is no back color buffer.
    * If the user tries to use a 8, 16 or 32-bit/channel buffer that
    * doesn't match what Mesa was compiled for (CHAN_BITS) the
    * _mesa_add_renderbuffer() function will create a "wrapper" renderbuffer
    * that converts rendering from CHAN_BITS to the user-requested channel
    * size.
    */
   if (!osmesa->rb) {
      osmesa->rb = new_osmesa_renderbuffer(&osmesa->mesa, osmesa->format, type);
      _mesa_remove_renderbuffer(osmesa->gl_buffer, BUFFER_FRONT_LEFT);
      _mesa_add_renderbuffer(osmesa->gl_buffer, BUFFER_FRONT_LEFT, osmesa->rb);
      assert(osmesa->rb->RefCount == 2);
   }

d1379 1
d1411 1
a1411 1
   struct gl_context *ctx = _mesa_get_current_context();
d1588 1
a1588 1
      if (strcmp(functions[i].Name, funcName) == 0)
a1608 28
/**
 * When GLX_INDIRECT_RENDERING is defined, some symbols are missing in
 * libglapi.a.  We need to define them here.
 */
#ifdef GLX_INDIRECT_RENDERING

#define GL_GLEXT_PROTOTYPES
#include "GL/gl.h"
#include "glapi/glapi.h"
#include "glapi/glapitable.h"

#if defined(USE_MGL_NAMESPACE)
#define NAME(func)  mgl##func
#else
#define NAME(func)  gl##func
#endif

#define DISPATCH(FUNC, ARGS, MESSAGE)		\
   GET_DISPATCH()->FUNC ARGS

#define RETURN_DISPATCH(FUNC, ARGS, MESSAGE) 	\
   return GET_DISPATCH()->FUNC ARGS

/* skip normal ones */
#define _GLAPI_SKIP_NORMAL_ENTRY_POINTS
#include "glapi/glapitemp.h"

#endif /* GLX_INDIRECT_RENDERING */
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a37 1
#include "main/api_exec.h"
a42 2
#include "main/macros.h"
#include "main/mipmap.h"
a44 2
#include "main/version.h"
#include "main/vtxfmt.h"
a48 1
#include "swrast/s_renderbuffer.h"
a57 2
#define OSMESA_RENDERBUFFER_CLASS 0x053

d66 1
a66 1
   struct swrast_renderbuffer *srb;     /*< The user's colorbuffer */
d71 1
a71 1
   GLvoid *rowaddr[SWRAST_MAX_HEIGHT];	/*< address of first pixel in each image row */
a73 1
   GLenum DataType;
d121 366
d518 3
d522 1
d547 3
d551 1
d565 3
d627 3
d631 1
d659 3
a661 1

d663 1
d676 3
d738 3
a740 2
   GLint bytesPerRow, i;
   GLubyte *origin = (GLubyte *) osmesa->srb->Buffer;
d742 1
a742 1
   GLint height = osmesa->srb->Base.Height;
d747 1
a747 1
      rowlength = osmesa->srb->Base.Width;
d749 26
a774 1
   bytesPerRow = rowlength * _mesa_get_format_bytes(osmesa->srb->Base.Format);
d794 1
a794 1
 * Don't use _mesa_delete_renderbuffer since we can't free rb->Buffer.
d797 1
a797 1
osmesa_delete_renderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
d799 1
a799 1
   _mesa_delete_renderbuffer(ctx, rb);
d813 8
a824 7
   /* Given the user-provided format and type, figure out which MESA_FORMAT_x
    * to use.
    * XXX There aren't Mesa formats for all the possible combinations here!
    * XXX Specifically, there's only RGBA-order 16-bit/channel and float
    * XXX formats.
    * XXX The 8-bit/channel formats should all be OK.
    */
d826 17
a842 8
      if (osmesa->DataType == GL_UNSIGNED_BYTE) {
         if (_mesa_little_endian())
            rb->Format = MESA_FORMAT_RGBA8888_REV;
         else
            rb->Format = MESA_FORMAT_RGBA8888;
      }
      else if (osmesa->DataType == GL_UNSIGNED_SHORT) {
         rb->Format = MESA_FORMAT_RGBA_16;
d845 7
a851 1
         rb->Format = MESA_FORMAT_RGBA_FLOAT32;
d855 17
a871 9
      if (osmesa->DataType == GL_UNSIGNED_BYTE) {
         if (_mesa_little_endian())
            rb->Format = MESA_FORMAT_ARGB8888;
         else
            rb->Format = MESA_FORMAT_ARGB8888_REV;
      }
      else if (osmesa->DataType == GL_UNSIGNED_SHORT) {
         _mesa_warning(ctx, "Unsupported OSMesa format BGRA/GLushort");
         rb->Format = MESA_FORMAT_RGBA_16; /* not exactly right */
d874 7
a880 2
         _mesa_warning(ctx, "Unsupported OSMesa format BGRA/GLfloat");
         rb->Format = MESA_FORMAT_RGBA_FLOAT32; /* not exactly right */
d884 17
a900 9
      if (osmesa->DataType == GL_UNSIGNED_BYTE) {
         if (_mesa_little_endian())
            rb->Format = MESA_FORMAT_ARGB8888_REV;
         else
            rb->Format = MESA_FORMAT_ARGB8888;
      }
      else if (osmesa->DataType == GL_UNSIGNED_SHORT) {
         _mesa_warning(ctx, "Unsupported OSMesa format ARGB/GLushort");
         rb->Format = MESA_FORMAT_RGBA_16; /* not exactly right */
d903 7
a909 2
         _mesa_warning(ctx, "Unsupported OSMesa format ARGB/GLfloat");
         rb->Format = MESA_FORMAT_RGBA_FLOAT32; /* not exactly right */
d913 17
a929 6
      if (osmesa->DataType == GL_UNSIGNED_BYTE) {
         rb->Format = MESA_FORMAT_RGB888;
      }
      else if (osmesa->DataType == GL_UNSIGNED_SHORT) {
         _mesa_warning(ctx, "Unsupported OSMesa format RGB/GLushort");
         rb->Format = MESA_FORMAT_RGBA_16; /* not exactly right */
d932 7
a938 2
         _mesa_warning(ctx, "Unsupported OSMesa format RGB/GLfloat");
         rb->Format = MESA_FORMAT_RGBA_FLOAT32; /* not exactly right */
d942 17
a958 6
      if (osmesa->DataType == GL_UNSIGNED_BYTE) {
         rb->Format = MESA_FORMAT_BGR888;
      }
      else if (osmesa->DataType == GL_UNSIGNED_SHORT) {
         _mesa_warning(ctx, "Unsupported OSMesa format BGR/GLushort");
         rb->Format = MESA_FORMAT_RGBA_16; /* not exactly right */
d961 7
a967 2
         _mesa_warning(ctx, "Unsupported OSMesa format BGR/GLfloat");
         rb->Format = MESA_FORMAT_RGBA_FLOAT32; /* not exactly right */
d971 8
a978 2
      ASSERT(osmesa->DataType == GL_UNSIGNED_BYTE);
      rb->Format = MESA_FORMAT_RGB565;
d996 1
a996 1
static struct swrast_renderbuffer *
d1000 20
a1019 44
   struct swrast_renderbuffer *srb = CALLOC_STRUCT(swrast_renderbuffer);

   if (srb) {
      _mesa_init_renderbuffer(&srb->Base, name);

      srb->Base.ClassID = OSMESA_RENDERBUFFER_CLASS;
      srb->Base.RefCount = 1;
      srb->Base.Delete = osmesa_delete_renderbuffer;
      srb->Base.AllocStorage = osmesa_renderbuffer_storage;

      srb->Base.InternalFormat = GL_RGBA;
      srb->Base._BaseFormat = GL_RGBA;

      return srb;
   }
   return NULL;
}



static void
osmesa_MapRenderbuffer(struct gl_context *ctx,
                       struct gl_renderbuffer *rb,
                       GLuint x, GLuint y, GLuint w, GLuint h,
                       GLbitfield mode,
                       GLubyte **mapOut, GLint *rowStrideOut)
{
   const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);

   if (rb->ClassID == OSMESA_RENDERBUFFER_CLASS) {
      /* this is an OSMesa renderbuffer which wraps user memory */
      struct swrast_renderbuffer *srb = swrast_renderbuffer(rb);
      const GLuint bpp = _mesa_get_format_bytes(rb->Format);
      GLint rowStride; /* in bytes */

      if (osmesa->userRowLength)
         rowStride = osmesa->userRowLength * bpp;
      else
         rowStride = rb->Width * bpp;

      if (!osmesa->yup) {
         /* Y=0 is top line of window */
         y = rb->Height - y - 1;
         *rowStrideOut = -rowStride;
d1021 2
a1022 21
      else {
         *rowStrideOut = rowStride;
      }

      *mapOut = (GLubyte *) srb->Buffer + y * rowStride + x * bpp;
   }
   else {
      _swrast_map_soft_renderbuffer(ctx, rb, x, y, w, h, mode,
                                    mapOut, rowStrideOut);
   }
}


static void
osmesa_UnmapRenderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
{
   if (rb->ClassID == OSMESA_RENDERBUFFER_CLASS) {
      /* no-op */
   }
   else {
      _swrast_unmap_soft_renderbuffer(ctx, rb);
d1024 1
d1155 1
a1157 1
                                    API_OPENGL_COMPAT,
d1161 1
a1161 1
                                    &functions)) {
d1168 5
d1185 7
a1191 7
      _swrast_add_soft_renderbuffers(osmesa->gl_buffer,
                                     GL_FALSE, /* color */
                                     osmesa->gl_visual->haveDepthBuffer,
                                     osmesa->gl_visual->haveStencilBuffer,
                                     osmesa->gl_visual->haveAccumBuffer,
                                     GL_FALSE, /* alpha */
                                     GL_FALSE /* aux */ );
a1224 5
         ctx->Driver.MapRenderbuffer = osmesa_MapRenderbuffer;
         ctx->Driver.UnmapRenderbuffer = osmesa_UnmapRenderbuffer;

         ctx->Driver.GenerateMipmap = _mesa_generate_mipmap;

a1230 6

         _mesa_compute_version(ctx);

         /* Exec table initialization requires the version to be computed */
         _mesa_initialize_dispatch_tables(ctx);
         _mesa_initialize_vbo_vtxfmt(ctx);
d1246 2
a1247 2
      if (osmesa->srb)
         _mesa_reference_renderbuffer((struct gl_renderbuffer **) &osmesa->srb, NULL);
d1297 1
a1297 1
       width > SWRAST_MAX_WIDTH || height > SWRAST_MAX_HEIGHT) {
d1330 2
a1331 2
   if (!osmesa->srb) {
      osmesa->srb = new_osmesa_renderbuffer(&osmesa->mesa, osmesa->format, type);
d1333 2
a1334 3
      _mesa_add_renderbuffer(osmesa->gl_buffer, BUFFER_FRONT_LEFT,
                             &osmesa->srb->Base);
      assert(osmesa->srb->Base.RefCount == 2);
a1336 2
   osmesa->DataType = type;

d1340 2
a1341 2
   osmesa->srb->Buffer = buffer;
   osmesa->srb->Base.Width = osmesa->srb->Base.Height = 0;
d1347 1
d1355 1
a1355 2
   _mesa_add_renderbuffer(osmesa->gl_buffer, BUFFER_FRONT_LEFT,
                          &osmesa->srb->Base);
d1359 1
a1359 1
   _mesa_update_framebuffer_visual(&osmesa->mesa, osmesa->gl_buffer);
d1430 6
a1435 1
         *value = osmesa->DataType;
d1444 1
a1444 1
         *value = SWRAST_MAX_WIDTH;
d1447 1
a1447 1
         *value = SWRAST_MAX_HEIGHT;
d1468 1
a1468 1
   struct swrast_renderbuffer *srb = NULL;
d1471 1
a1471 2
      srb = swrast_renderbuffer(c->gl_buffer->
                                Attachment[BUFFER_DEPTH].Renderbuffer);
d1473 1
a1473 1
   if (!srb || !srb->Buffer) {
d1481 2
a1482 2
      *width = srb->Base.Width;
      *height = srb->Base.Height;
d1487 1
a1487 1
      *buffer = (void *) srb->Buffer;
d1505 3
a1507 3
   if (osmesa->srb && osmesa->srb->Buffer) {
      *width = osmesa->srb->Base.Width;
      *height = osmesa->srb->Base.Height;
d1509 1
a1509 1
      *buffer = (void *) osmesa->srb->Buffer;
@


1.1.1.6
log
@Import Mesa 9.2.3
@
text
@a199 8
   if (ctx->DrawBuffer &&
       ctx->DrawBuffer->Visual.redBits == 32) {
      /* the special-case line functions in this file don't work
       * for float color channels.
       */
      return NULL;
   }

a299 8

   if (ctx->DrawBuffer &&
       ctx->DrawBuffer->Visual.redBits == 32) {
      /* the special-case triangle functions in this file don't work
       * for float color channels.
       */
      return (swrast_tri_func) NULL;
   }
@


1.1.1.7
log
@Import Mesa 10.2.3
@
text
@d208 7
a214 10
   if (ctx->RenderMode != GL_RENDER ||
       ctx->Line.SmoothFlag ||
       ctx->Texture._MaxEnabledTexImageUnit == -1 ||
       ctx->Light.ShadeModel != GL_FLAT ||
       ctx->Line.Width != 1.0F ||
       ctx->Line.StippleFlag ||
       ctx->Line.SmoothFlag) {
      return NULL;
   }

d217 1
a217 3
       osmesa->format != OSMESA_ARGB) {
      return NULL;
   }
d219 3
a221 3
   if (swrast->_RasterMask == DEPTH_BIT
       && ctx->Depth.Func == GL_LESS
       && ctx->Depth.Mask == GL_TRUE
d223 1
a223 1
      return flat_rgba_z_line;
d227 1
a227 1
      return flat_rgba_line;
d314 1
a314 8
      return NULL;
   }

   if (ctx->RenderMode != GL_RENDER ||
       ctx->Polygon.SmoothFlag ||
       ctx->Polygon.StippleFlag ||
       ctx->Texture._MaxEnabledTexImageUnit != -1) {
      return NULL;
d317 4
d323 4
a326 8
       osmesa->format != OSMESA_ARGB) {
      return NULL;
   }

   if (ctx->Polygon.CullFlag &&
       ctx->Polygon.CullFaceMode == GL_FRONT_AND_BACK) {
      return NULL;
   }
d333 1
a333 1
         return smooth_rgba_z_triangle;
d336 1
a336 1
         return flat_rgba_z_triangle;
d339 1
a339 2

   return NULL;
d439 1
a439 1
            rb->Format = MESA_FORMAT_R8G8B8A8_UNORM;
d441 1
a441 1
            rb->Format = MESA_FORMAT_A8B8G8R8_UNORM;
d444 1
a444 1
         rb->Format = MESA_FORMAT_RGBA_UNORM16;
d453 1
a453 1
            rb->Format = MESA_FORMAT_B8G8R8A8_UNORM;
d455 1
a455 1
            rb->Format = MESA_FORMAT_A8R8G8B8_UNORM;
d459 1
a459 1
         rb->Format = MESA_FORMAT_RGBA_UNORM16; /* not exactly right */
d469 1
a469 1
            rb->Format = MESA_FORMAT_A8R8G8B8_UNORM;
d471 1
a471 1
            rb->Format = MESA_FORMAT_B8G8R8A8_UNORM;
d475 1
a475 1
         rb->Format = MESA_FORMAT_RGBA_UNORM16; /* not exactly right */
d484 1
a484 1
         rb->Format = MESA_FORMAT_BGR_UNORM8;
d488 1
a488 1
         rb->Format = MESA_FORMAT_RGBA_UNORM16; /* not exactly right */
d497 1
a497 1
         rb->Format = MESA_FORMAT_RGB_UNORM8;
d501 1
a501 1
         rb->Format = MESA_FORMAT_RGBA_UNORM16; /* not exactly right */
d510 1
a510 1
      rb->Format = MESA_FORMAT_B5G6R5_UNORM;
a1118 1
   { "OSMesaPostprocess", (OSMESAproc) OSMesaPostprocess },
a1146 10


GLAPI void GLAPIENTRY
OSMesaPostprocess(OSMesaContext osmesa, const char *filter,
                  unsigned enable_value)
{
   fprintf(stderr,
           "OSMesaPostProcess() is only available with gallium drivers\n");
}

@


1.1.1.8
log
@Import Mesa 10.4.3
@
text
@d86 1
a86 1
static inline OSMesaContext
@


1.1.1.9
log
@Import Mesa 10.2.9
@
text
@d86 1
a86 1
static INLINE OSMesaContext
@


