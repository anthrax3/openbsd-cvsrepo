head	1.4;
access;
symbols
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2010.05.22.20.06.16;	author matthieu;	state dead;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.40;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.40;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.55;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.27.42;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@/*
 * Copyright (C) 2004-2007 Claudio Ciccani <klan@@directfb.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * 
 * Based on glfbdev.c, written by Brian Paul.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <pthread.h>

#include <directfb.h>
#include <directfb_version.h>

#include <directfbgl.h>

#include <direct/mem.h>
#include <direct/messages.h>
#include <direct/interface.h>

#undef CLAMP
#include "main/glheader.h"
#include "main/buffers.h"
#include "main/context.h"
#include "main/extensions.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
#include "main/imports.h"
#include "main/texformat.h"
#include "main/teximage.h"
#include "main/texstore.h"
#include "vbo/vbo.h"
#include "swrast/swrast.h"
#include "swrast_setup/swrast_setup.h"
#include "tnl/tnl.h"
#include "tnl/t_context.h"
#include "tnl/t_pipeline.h"
#include "drivers/common/driverfuncs.h"


#define VERSION_CODE( M, m, r )  (((M) * 1000) + ((m) * 100) + ((r)))
#define DIRECTFB_VERSION_CODE    VERSION_CODE( DIRECTFB_MAJOR_VERSION, \
                                               DIRECTFB_MINOR_VERSION, \
                                               DIRECTFB_MICRO_VERSION )


static DFBResult
Probe( void *data );

static DFBResult
Construct( IDirectFBGL      *thiz,
           IDirectFBSurface *surface );

#include <direct/interface_implementation.h>

DIRECT_INTERFACE_IMPLEMENTATION( IDirectFBGL, Mesa )

/*
 * private data struct of IDirectFBGL
 */
typedef struct {
     int                     ref;       /* reference counter */
     
     int                     locked;
     
     IDirectFBSurface       *surface;
     DFBSurfacePixelFormat   format;
     int                     width;
     int                     height;
     
     struct {
          GLubyte           *start;
          GLubyte           *end;
          int                pitch;
     } video;

     GLvisual                visual;
     GLframebuffer           framebuffer;
     GLcontext               context;
     struct gl_renderbuffer  render;
} IDirectFBGL_data;

/******************************************************************************/

static pthread_mutex_t global_lock = PTHREAD_MUTEX_INITIALIZER;
static unsigned int    global_ref  = 0;

static INLINE int directfbgl_init( void )
{
     pthread_mutexattr_t attr;
     int                 ret;
     
     if (global_ref++)
          return 0;

     pthread_mutexattr_init( &attr );
     pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_ERRORCHECK );
     ret = pthread_mutex_init( &global_lock, &attr );
     pthread_mutexattr_destroy( &attr );

     return ret;
}

static INLINE void directfbgl_finish( void )
{
     if (--global_ref == 0)
          pthread_mutex_destroy( &global_lock );
}

#define directfbgl_lock()    pthread_mutex_lock( &global_lock )
#define directfbgl_unlock()  pthread_mutex_unlock( &global_lock )

/******************************************************************************/

static bool  directfbgl_init_visual    ( GLvisual              *visual,
                                         DFBSurfacePixelFormat  format );
static bool  directfbgl_create_context ( GLcontext             *context,
                                         GLframebuffer         *framebuffer,
                                         GLvisual              *visual,
                                         IDirectFBGL_data      *data );
static void  directfbgl_destroy_context( GLcontext             *context,
                                         GLframebuffer         *framebuffer );

/******************************************************************************/


static void
IDirectFBGL_Mesa_Destruct( IDirectFBGL *thiz )
{
     IDirectFBGL_data *data = (IDirectFBGL_data*) thiz->priv;

     directfbgl_destroy_context( &data->context, &data->framebuffer );
     
     if (data->surface)
          data->surface->Release( data->surface );

     DIRECT_DEALLOCATE_INTERFACE( thiz );

     directfbgl_finish();
}

static DFBResult
IDirectFBGL_Mesa_AddRef( IDirectFBGL *thiz )
{
     DIRECT_INTERFACE_GET_DATA( IDirectFBGL );

     data->ref++;

     return DFB_OK;
}

static DFBResult
IDirectFBGL_Mesa_Release( IDirectFBGL *thiz )
{
     DIRECT_INTERFACE_GET_DATA( IDirectFBGL )

     if (--data->ref == 0) 
          IDirectFBGL_Mesa_Destruct( thiz );

     return DFB_OK;
}

static DFBResult
IDirectFBGL_Mesa_Lock( IDirectFBGL *thiz )
{
     IDirectFBSurface *surface;
     int               width   = 0;
     int               height  = 0;
     DFBResult         ret;
     
     DIRECT_INTERFACE_GET_DATA( IDirectFBGL );

     if (data->locked) {
          data->locked++;
          return DFB_OK;
     }

     if (directfbgl_lock())
          return DFB_LOCKED;

     surface = data->surface;
     surface->GetSize( surface, &width, &height );
     
     ret = surface->Lock( surface, DSLF_READ | DSLF_WRITE, 
                          (void*)&data->video.start, &data->video.pitch );
     if (ret) {
          D_ERROR( "DirectFBGL/Mesa: couldn't lock surface.\n" );
          directfbgl_unlock();
          return ret;
     }
     data->video.end = data->video.start + (height-1) * data->video.pitch;

     data->render.Data = data->video.start;

     _mesa_make_current( &data->context, 
                         &data->framebuffer, &data->framebuffer );
     
     if (data->width != width || data->height != height) {
          _mesa_resize_framebuffer( &data->context, 
                                    &data->framebuffer, width, height );
          data->width  = width;
          data->height = height;                        
     }

     data->locked++;
     
     return DFB_OK;
}

static DFBResult
IDirectFBGL_Mesa_Unlock( IDirectFBGL *thiz )
{     
     DIRECT_INTERFACE_GET_DATA( IDirectFBGL );

     if (!data->locked)
          return DFB_OK;
          
     if (--data->locked == 0) {
          _mesa_make_current( NULL, NULL, NULL );
     
          data->surface->Unlock( data->surface );

          directfbgl_unlock();
     }
     
     return DFB_OK;
}

static DFBResult
IDirectFBGL_Mesa_GetAttributes( IDirectFBGL     *thiz,
                                DFBGLAttributes *attributes )
{
     DFBSurfaceCapabilities   caps;
     GLvisual                *visual;
     
     DIRECT_INTERFACE_GET_DATA( IDirectFBGL );

     if (!attributes)
          return DFB_INVARG;

     data->surface->GetCapabilities( data->surface, &caps );

     visual = &data->visual;
     
     attributes->buffer_size      = visual->rgbBits ? : visual->indexBits;
     attributes->depth_size       = visual->depthBits;
     attributes->stencil_size     = visual->stencilBits;
     attributes->aux_buffers      = visual->numAuxBuffers;
     attributes->red_size         = visual->redBits;
     attributes->green_size       = visual->greenBits;
     attributes->blue_size        = visual->blueBits;
     attributes->alpha_size       = visual->alphaBits;
     attributes->accum_red_size   = visual->accumRedBits;
     attributes->accum_green_size = visual->accumGreenBits;
     attributes->accum_blue_size  = visual->accumBlueBits;
     attributes->accum_alpha_size = visual->accumAlphaBits;
     attributes->double_buffer    = ((caps & DSCAPS_FLIPPING) != 0);
     attributes->stereo           = (visual->stereoMode != 0);

     return DFB_OK;
}

#if DIRECTFBGL_INTERFACE_VERSION >= 1
static DFBResult
IDirectFBGL_Mesa_GetProcAddress( IDirectFBGL  *thiz,
                                 const char   *name,
                                 void        **ret_address )
{
     DIRECT_INTERFACE_GET_DATA( IDirectFBGL );

     if (!name)
          return DFB_INVARG;
          
     if (!ret_address)
          return DFB_INVARG;
          
     *ret_address = _glapi_get_proc_address( name );
          
     return (*ret_address) ? DFB_OK : DFB_UNSUPPORTED;
}
#endif


/* exported symbols */

static DFBResult
Probe( void *data )
{
     return DFB_OK;
}

static DFBResult
Construct( IDirectFBGL *thiz, IDirectFBSurface *surface )
{
     DFBResult ret;
     
     /* Initialize global resources. */
     if (directfbgl_init())
          return DFB_INIT;
     
     /* Allocate interface data. */
     DIRECT_ALLOCATE_INTERFACE_DATA( thiz, IDirectFBGL );
 
     /* Initialize interface data. */
     data->ref = 1;

     /* Duplicate destination surface. */
     ret = surface->GetSubSurface( surface, NULL, &data->surface );
     if (ret) {
          IDirectFBGL_Mesa_Destruct( thiz );
          return ret;
     }

     data->surface->GetPixelFormat( data->surface, &data->format );
     data->surface->GetSize( data->surface, &data->width, &data->height );

     /* Configure visual. */
     if (!directfbgl_init_visual( &data->visual, data->format )) {
          D_ERROR( "DirectFBGL/Mesa: failed to initialize visual.\n" );
          IDirectFBGL_Mesa_Destruct( thiz );
          return DFB_UNSUPPORTED;
     }
     
     /* Create context. */
     if (!directfbgl_create_context( &data->context,
                                     &data->framebuffer,
                                     &data->visual, data )) {
          D_ERROR( "DirectFBGL/Mesa: failed to create context.\n" );
          IDirectFBGL_Mesa_Destruct( thiz );
          return DFB_UNSUPPORTED;
     }

     /* Assign interface pointers. */
     thiz->AddRef         = IDirectFBGL_Mesa_AddRef;
     thiz->Release        = IDirectFBGL_Mesa_Release;
     thiz->Lock           = IDirectFBGL_Mesa_Lock;
     thiz->Unlock         = IDirectFBGL_Mesa_Unlock;
     thiz->GetAttributes  = IDirectFBGL_Mesa_GetAttributes;
#if DIRECTFBGL_INTERFACE_VERSION >= 1
     thiz->GetProcAddress = IDirectFBGL_Mesa_GetProcAddress;
#endif 

     return DFB_OK;
}


/***************************** Driver functions ******************************/

static const GLubyte*
dfbGetString( GLcontext *ctx, GLenum pname )
{
     return NULL;
}

static void
dfbUpdateState( GLcontext *ctx, GLuint new_state )
{
     _swrast_InvalidateState( ctx, new_state );
     _swsetup_InvalidateState( ctx, new_state );
     _vbo_InvalidateState( ctx, new_state );
     _tnl_InvalidateState( ctx, new_state );
}

static void
dfbGetBufferSize( GLframebuffer *buffer, GLuint *width, GLuint *height )
{
     GLcontext        *ctx  = _mesa_get_current_context();
     IDirectFBGL_data *data = (IDirectFBGL_data*) ctx->DriverCtx;

     *width  = (GLuint) data->width;
     *height = (GLuint) data->height;
}

/**
 * We only implement this function as a mechanism to check if the
 * framebuffer size has changed (and update corresponding state).
 */
static void
dfbSetViewport( GLcontext *ctx, GLint x, GLint y, GLsizei w, GLsizei h )
{
     /* Nothing to do (the surface can't be resized while it's locked). */
     return;
}

static void
dfbClear( GLcontext *ctx, GLbitfield mask )
{
     IDirectFBGL_data *data = (IDirectFBGL_data*) ctx->DriverCtx;
 
#define BUFFER_BIT_MASK (BUFFER_BIT_FRONT_LEFT | BUFFER_BIT_FRONT_RIGHT | \
                         BUFFER_BIT_BACK_LEFT  | BUFFER_BIT_BACK_RIGHT  )
     if (mask & BUFFER_BIT_MASK  &&
         ctx->Color.ColorMask[0] &&
         ctx->Color.ColorMask[1] &&
         ctx->Color.ColorMask[2] &&
         ctx->Color.ColorMask[3])
     {
          DFBRegion clip;
          GLubyte   a, r, g, b;
          
          UNCLAMPED_FLOAT_TO_UBYTE( a, ctx->Color.ClearColor[ACOMP] );
          UNCLAMPED_FLOAT_TO_UBYTE( r, ctx->Color.ClearColor[RCOMP] );
          UNCLAMPED_FLOAT_TO_UBYTE( g, ctx->Color.ClearColor[GCOMP] );
          UNCLAMPED_FLOAT_TO_UBYTE( b, ctx->Color.ClearColor[BCOMP] );

          clip.x1 = ctx->DrawBuffer->_Xmin;
          clip.y1 = ctx->DrawBuffer->_Ymin;
          clip.x2 = ctx->DrawBuffer->_Xmax - 1;
          clip.y2 = ctx->DrawBuffer->_Ymax - 1;
          data->surface->SetClip( data->surface, &clip );
          
          data->surface->Unlock( data->surface );
          
          data->surface->Clear( data->surface, r, g, b, a );
          
          data->surface->Lock( data->surface, DSLF_READ | DSLF_WRITE,
                               (void*)&data->video.start, &data->video.pitch );
          data->video.end = data->video.start + (data->height-1) * data->video.pitch;
          data->render.Data = data->video.start;
          
          mask &= ~BUFFER_BIT_MASK;
     }
#undef BUFFER_BIT_MASK
     
     if (mask)
          _swrast_Clear( ctx, mask );
}


/************************ RenderBuffer functions *****************************/

static void
dfbDeleteRenderbuffer( struct gl_renderbuffer *render )
{
     return;
}

static GLboolean
dfbRenderbufferStorage( GLcontext *ctx, struct gl_renderbuffer *render,
                        GLenum internalFormat, GLuint width, GLuint height )
{
     return GL_TRUE;
}


/***************************** Span functions ********************************/

/* RGB332 */
#define NAME(PREFIX) PREFIX##_RGB332
#define FORMAT GL_RGBA8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   IDirectFBGL_data *data = (IDirectFBGL_data*) ctx->DriverCtx;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLubyte *P = data->video.end - (Y) * data->video.pitch + (X);
#define INC_PIXEL_PTR(P) P += 1
#define STORE_PIXEL(P, X, Y, S) \
   *P = ( (((S[RCOMP]) & 0xe0)     ) | \
          (((S[GCOMP]) & 0xe0) >> 3) | \
          (((S[BCOMP])       ) >> 6) )
#define FETCH_PIXEL(D, P) \
   D[RCOMP] = ((*P & 0xe0)     ); \
   D[GCOMP] = ((*P & 0x1c) << 3); \
   D[BCOMP] = ((*P & 0x03) << 6); \
   D[ACOMP] = 0xff

#include "swrast/s_spantemp.h"

/* ARGB4444 */
#define NAME(PREFIX) PREFIX##_ARGB4444
#define FORMAT GL_RGBA8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   IDirectFBGL_data *data = (IDirectFBGL_data*) ctx->DriverCtx;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLushort *P = (GLushort *) (data->video.end - (Y) * data->video.pitch + (X) * 2);
#define INC_PIXEL_PTR(P) P += 1
#define STORE_PIXEL_RGB(P, X, Y, S) \
   *P = ( 0xf000                     | \
          (((S[RCOMP]) & 0xf0) << 4) | \
          (((S[GCOMP]) & 0xf0)     ) | \
          (((S[BCOMP]) & 0xf0) >> 4) )
#define STORE_PIXEL(P, X, Y, S) \
   *P = ( (((S[ACOMP]) & 0xf0) << 8) | \
          (((S[RCOMP]) & 0xf0) << 4) | \
          (((S[GCOMP]) & 0xf0)     ) | \
          (((S[BCOMP]) & 0xf0) >> 4) )
#define FETCH_PIXEL(D, P) \
   D[RCOMP] = ((*P & 0x0f00) >> 4) | ((*P & 0x0f00) >>  8); \
   D[GCOMP] = ((*P & 0x00f0)     ) | ((*P & 0x00f0) >>  4); \
   D[BCOMP] = ((*P & 0x000f) << 4) | ((*P & 0x000f)      ); \
   D[ACOMP] = ((*P & 0xf000) >> 8) | ((*P & 0xf000) >> 12)

#include "swrast/s_spantemp.h"

/* RGB444 */
#define NAME(PREFIX) PREFIX##_RGB444
#define FORMAT GL_RGBA8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   IDirectFBGL_data *data = (IDirectFBGL_data*) ctx->DriverCtx;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLushort *P = (GLushort *) (data->video.end - (Y) * data->video.pitch + (X) * 2);
#define INC_PIXEL_PTR(P) P += 1
#define STORE_PIXEL(P, X, Y, S) \
   *P = ( (((S[RCOMP]) & 0xf0) << 4) | \
          (((S[GCOMP]) & 0xf0)     ) | \
          (((S[BCOMP]) & 0xf0) >> 4) )
#define FETCH_PIXEL(D, P) \
   D[RCOMP] = ((*P & 0x0f00) >> 4) | ((*P & 0x0f00) >> 8); \
   D[GCOMP] = ((*P & 0x00f0)     ) | ((*P & 0x00f0) >> 4); \
   D[BCOMP] = ((*P & 0x000f) << 4) | ((*P & 0x000f)     ); \
   D[ACOMP] = 0xff

#include "swrast/s_spantemp.h"

/* ARGB2554 */
#define NAME(PREFIX) PREFIX##_ARGB2554
#define FORMAT GL_RGBA8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   IDirectFBGL_data *data = (IDirectFBGL_data*) ctx->DriverCtx;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLushort *P = (GLushort *) (data->video.end - (Y) * data->video.pitch + (X) * 2);
#define INC_PIXEL_PTR(P) P += 1
#define STORE_PIXEL_RGB(P, X, Y, S) \
   *P = ( 0xc000                     | \
          (((S[RCOMP]) & 0xf8) << 6) | \
          (((S[GCOMP]) & 0xf8) << 1) | \
          (((S[BCOMP]) & 0xf0) >> 4) )
#define STORE_PIXEL(P, X, Y, S) \
   *P = ( (((S[ACOMP]) & 0xc0) << 8) | \
          (((S[RCOMP]) & 0xf8) << 6) | \
          (((S[GCOMP]) & 0xf8) << 1) | \
          (((S[BCOMP]) & 0xf0) >> 4) )
#define FETCH_PIXEL(D, P) \
   D[RCOMP] = ((*P & 0x3e00) >>  9); \
   D[GCOMP] = ((*P & 0x01f0) >>  4); \
   D[BCOMP] = ((*P & 0x000f) <<  4); \
   D[ACOMP] = ((*P & 0xc000) >> 14)

#include "swrast/s_spantemp.h"
   
/* ARGB1555 */
#define NAME(PREFIX) PREFIX##_ARGB1555
#define FORMAT GL_RGBA8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   IDirectFBGL_data *data = (IDirectFBGL_data*) ctx->DriverCtx;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLushort *P = (GLushort *) (data->video.end - (Y) * data->video.pitch + (X) * 2);
#define INC_PIXEL_PTR(P) P += 1
#define STORE_PIXEL_RGB(P, X, Y, S) \
   *P = ( 0x8000                      | \
          (((S[RCOMP]) & 0xf8) <<  7) | \
          (((S[GCOMP]) & 0xf8) <<  2) | \
          (((S[BCOMP])       ) >>  3) )
#define STORE_PIXEL(P, X, Y, S) \
   *P = ( (((S[ACOMP]) & 0x80) << 16) | \
          (((S[RCOMP]) & 0xf8) <<  7) | \
          (((S[GCOMP]) & 0xf8) <<  2) | \
          (((S[BCOMP])       ) >>  3) )
#define FETCH_PIXEL(D, P) \
   D[RCOMP] = ((*P & 0x7c00) >> 7) | ((*P & 0x7c00) >> 12); \
   D[GCOMP] = ((*P & 0x03e0) >> 2) | ((*P & 0x03e0) >>  7); \
   D[BCOMP] = ((*P & 0x001f) << 3) | ((*P & 0x001f) <<  2); \
   D[ACOMP] = ((*P & 0x8000) ? 0xff : 0)

#include "swrast/s_spantemp.h"

/* RGB555 */
#define NAME(PREFIX) PREFIX##_RGB555
#define FORMAT GL_RGBA8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   IDirectFBGL_data *data = (IDirectFBGL_data*) ctx->DriverCtx;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLushort *P = (GLushort *) (data->video.end - (Y) * data->video.pitch + (X) * 2);
#define INC_PIXEL_PTR(P) P += 1
#define STORE_PIXEL(P, X, Y, S) \
   *P = ( (((S[RCOMP]) & 0xf8) <<  7) | \
          (((S[GCOMP]) & 0xf8) <<  2) | \
          (((S[BCOMP])       ) >>  3) )
#define FETCH_PIXEL(D, P) \
   D[RCOMP] = ((*P & 0x7c00) >> 7) | ((*P & 0x7c00) >> 12); \
   D[GCOMP] = ((*P & 0x03e0) >> 2) | ((*P & 0x03e0) >>  7); \
   D[BCOMP] = ((*P & 0x001f) << 3) | ((*P & 0x001f) <<  2); \
   D[ACOMP] = 0xff

#include "swrast/s_spantemp.h"

/* RGB16 */
#define NAME(PREFIX) PREFIX##_RGB16
#define FORMAT GL_RGBA8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   IDirectFBGL_data *data = (IDirectFBGL_data*) ctx->DriverCtx;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLushort *P = (GLushort *) (data->video.end - (Y) * data->video.pitch + (X) * 2);
#define INC_PIXEL_PTR(P) P += 1
#define STORE_PIXEL(P, X, Y, S) \
   *P = ( (((S[RCOMP]) & 0xf8) << 8) | \
          (((S[GCOMP]) & 0xfc) << 3) | \
          (((S[BCOMP])       ) >> 3) )
#define FETCH_PIXEL(D, P) \
   D[RCOMP] = ((*P & 0xf800) >> 8) | ((*P & 0xf800) >> 13); \
   D[GCOMP] = ((*P & 0x07e0) >> 3) | ((*P & 0x07e0) >>  9); \
   D[BCOMP] = ((*P & 0x001f) << 3) | ((*P & 0x001f) >>  2); \
   D[ACOMP] = 0xff

#include "swrast/s_spantemp.h"

/* RGB24 */
#define NAME(PREFIX) PREFIX##_RGB24
#define FORMAT GL_RGBA8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   IDirectFBGL_data *data = ctx->DriverCtx;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLubyte *P = data->video.end - (Y) * data->video.pitch + (X) * 3;
#define INC_PIXEL_PTR(P) P += 3
#define STORE_PIXEL(P, X, Y, S) \
   P[0] = S[BCOMP];  P[1] = S[GCOMP];  P[2] = S[BCOMP]
#define FETCH_PIXEL(D, P) \
   D[RCOMP] = P[2];  D[GCOMP] = P[1];  D[BCOMP] = P[0]; D[ACOMP] = 0xff

#include "swrast/s_spantemp.h"

/* RGB32 */
#define NAME(PREFIX) PREFIX##_RGB32
#define FORMAT GL_RGBA8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   IDirectFBGL_data *data = (IDirectFBGL_data*) ctx->DriverCtx;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLuint *P = (GLuint*) (data->video.end - (Y) * data->video.pitch + (X) * 4);
#define INC_PIXEL_PTR(P) P += 1
#define STORE_PIXEL(P, X, Y, S) \
   *P = ( ((S[RCOMP]) << 16) | \
          ((S[GCOMP]) <<  8) | \
          ((S[BCOMP])      ) )
#define FETCH_PIXEL(D, P) \
   D[RCOMP] = ((*P & 0x00ff0000) >> 16); \
   D[GCOMP] = ((*P & 0x0000ff00) >>  8); \
   D[BCOMP] = ((*P & 0x000000ff)      ); \
   D[ACOMP] = 0xff

#include "swrast/s_spantemp.h"
   
/* ARGB */
#define NAME(PREFIX) PREFIX##_ARGB
#define FORMAT GL_RGBA8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   IDirectFBGL_data *data = (IDirectFBGL_data*) ctx->DriverCtx;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLuint *P = (GLuint*) (data->video.end - (Y) * data->video.pitch + (X) * 4);
#define INC_PIXEL_PTR(P) P += 1
#define STORE_PIXEL_RGB(P, X, Y, S) \
   *P = ( 0xff000000         | \
          ((S[RCOMP]) << 16) | \
          ((S[GCOMP]) <<  8) | \
          ((S[BCOMP])      ) )
#define STORE_PIXEL(P, X, Y, S) \
   *P = ( ((S[ACOMP]) << 24) | \
          ((S[RCOMP]) << 16) | \
          ((S[GCOMP]) <<  8) | \
          ((S[BCOMP])      ) )
#define FETCH_PIXEL(D, P) \
   D[RCOMP] = ((*P & 0x00ff0000) >> 16); \
   D[GCOMP] = ((*P & 0x0000ff00) >>  8); \
   D[BCOMP] = ((*P & 0x000000ff)      ); \
   D[ACOMP] = ((*P & 0xff000000) >> 24)

#include "swrast/s_spantemp.h"

/* AiRGB */
#define NAME(PREFIX) PREFIX##_AiRGB
#define FORMAT GL_RGBA8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   IDirectFBGL_data *data = (IDirectFBGL_data*) ctx->DriverCtx;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLuint *P = (GLuint*) (data->video.end - (Y) * data->video.pitch + (X) * 4);
#define INC_PIXEL_PTR(P) P += 1
#define STORE_PIXEL_RGB(P, X, Y, S) \
   *P = ( ((S[RCOMP]) << 16) | \
          ((S[GCOMP]) <<  8) | \
          ((S[BCOMP])      ) )
#define STORE_PIXEL(P, X, Y, S) \
   *P = ( (((S[ACOMP]) ^ 0xff) << 24) | \
          (((S[RCOMP])       ) << 16) | \
          (((S[GCOMP])       ) <<  8) | \
          (((S[BCOMP])       )      ) )
#define FETCH_PIXEL(D, P) \
   D[RCOMP] =  ((*P & 0x00ff0000) >> 16); \
   D[GCOMP] =  ((*P & 0x0000ff00) >>  8); \
   D[BCOMP] =  ((*P & 0x000000ff)      ); \
   D[ACOMP] = (((*P & 0xff000000) >> 24) ^ 0xff)

#include "swrast/s_spantemp.h"


/*****************************************************************************/

static bool
directfbgl_init_visual( GLvisual              *visual,
                        DFBSurfacePixelFormat  format )
{
     GLboolean  rgbFlag        = GL_TRUE;
     GLboolean  dbFlag         = GL_FALSE;
     GLboolean  stereoFlag     = GL_FALSE;
     GLint      redBits        = 0;
     GLint      blueBits       = 0;
     GLint      greenBits      = 0;
     GLint      alphaBits      = 0;
     GLint      indexBits      = 0;
     GLint      depthBits      = 0;
     GLint      stencilBits    = 0;
     GLint      accumRedBits   = 0;
     GLint      accumGreenBits = 0;
     GLint      accumBlueBits  = 0;
     GLint      accumAlphaBits = 0;
     GLint      numSamples     = 0;

     /* FIXME: LUT8 support. */
     switch (format) {
          case DSPF_RGB332:
               redBits   = 3;
               greenBits = 3;
               blueBits  = 2;
               break;
          case DSPF_ARGB4444:
               alphaBits = 4;
          case DSPF_RGB444:
               redBits   = 4;
               greenBits = 4;
               blueBits  = 4;
               break;
          case DSPF_ARGB2554:
               alphaBits = 2;
               redBits   = 5;
               greenBits = 5;
               blueBits  = 4;
               break;
          case DSPF_ARGB1555:
               alphaBits = 1;
          case DSPF_RGB555:
               redBits   = 5;
               greenBits = 5;
               blueBits  = 5;
               break;
          case DSPF_RGB16:
               redBits   = 5;
               greenBits = 6;
               blueBits  = 5;
               break;
          case DSPF_ARGB:
          case DSPF_AiRGB:
               alphaBits = 8;
          case DSPF_RGB24:
          case DSPF_RGB32:
               redBits   = 8;
               greenBits = 8;
               blueBits  = 8;
               break;
          default:
               D_WARN( "unsupported pixelformat" );
               return false;
     }

     if (rgbFlag) {
          accumRedBits   = redBits;
          accumGreenBits = greenBits;
          accumBlueBits  = blueBits;
          accumAlphaBits = alphaBits;
          depthBits      = redBits + greenBits + blueBits;
          stencilBits    = alphaBits;
     } else
          depthBits      = 8;

     return _mesa_initialize_visual( visual,
                                     rgbFlag, dbFlag, stereoFlag,
                                     redBits, greenBits, blueBits, alphaBits,
                                     indexBits, depthBits, stencilBits,
                                     accumRedBits, accumGreenBits,
                                     accumBlueBits, accumAlphaBits,
                                     numSamples );
}

static bool
directfbgl_create_context( GLcontext        *context,
                           GLframebuffer    *framebuffer,
                           GLvisual         *visual,
                           IDirectFBGL_data *data )
{
     struct dd_function_table functions;
     
     _mesa_initialize_framebuffer( framebuffer, visual ); 
     
     _mesa_init_driver_functions( &functions );
     functions.GetString     = dfbGetString;
     functions.UpdateState   = dfbUpdateState;
     functions.GetBufferSize = dfbGetBufferSize;
     functions.Viewport      = dfbSetViewport;
     functions.Clear         = dfbClear;
     
     if (!_mesa_initialize_context( context, visual, NULL,
                                    &functions, (void*) data )) {
          D_DEBUG( "DirectFBGL/Mesa: _mesa_initialize_context() failed.\n" );
          _mesa_free_framebuffer_data( framebuffer );
          return false;
     }

     _swrast_CreateContext( context );
     _vbo_CreateContext( context );
     _tnl_CreateContext( context );
     _swsetup_CreateContext( context );
     _swsetup_Wakeup( context );

     _mesa_init_renderbuffer( &data->render, 0 );
     data->render.InternalFormat = GL_RGBA;
     data->render._BaseFormat    = GL_RGBA;
     data->render.DataType       = GL_UNSIGNED_BYTE;
     data->render.Data           = data->video.start;
     data->render.Delete         = dfbDeleteRenderbuffer;
     data->render.AllocStorage   = dfbRenderbufferStorage;
     
     switch (data->format) {
          case DSPF_RGB332:
               data->render.GetRow        = get_row_RGB332;
               data->render.GetValues     = get_values_RGB332;
               data->render.PutRow        = put_row_RGB332;
               data->render.PutRowRGB     = put_row_rgb_RGB332;
               data->render.PutMonoRow    = put_mono_row_RGB332;
               data->render.PutValues     = put_values_RGB332;
               data->render.PutMonoValues = put_mono_values_RGB332;
               break;
          case DSPF_ARGB4444: 
               data->render.GetRow        = get_row_ARGB4444;
               data->render.GetValues     = get_values_ARGB4444;
               data->render.PutRow        = put_row_ARGB4444;
               data->render.PutRowRGB     = put_row_rgb_ARGB4444;
               data->render.PutMonoRow    = put_mono_row_ARGB4444;
               data->render.PutValues     = put_values_ARGB4444;
               data->render.PutMonoValues = put_mono_values_ARGB4444;
               break;
          case DSPF_RGB444: 
               data->render.GetRow        = get_row_RGB444;
               data->render.GetValues     = get_values_RGB444;
               data->render.PutRow        = put_row_RGB444;
               data->render.PutRowRGB     = put_row_rgb_RGB444;
               data->render.PutMonoRow    = put_mono_row_RGB444;
               data->render.PutValues     = put_values_RGB444;
               data->render.PutMonoValues = put_mono_values_RGB444;
               break;
          case DSPF_ARGB2554: 
               data->render.GetRow        = get_row_ARGB2554;
               data->render.GetValues     = get_values_ARGB2554;
               data->render.PutRow        = put_row_ARGB2554;
               data->render.PutRowRGB     = put_row_rgb_ARGB2554;
               data->render.PutMonoRow    = put_mono_row_ARGB2554;
               data->render.PutValues     = put_values_ARGB2554;
               data->render.PutMonoValues = put_mono_values_ARGB2554;
               break;
          case DSPF_ARGB1555:
               data->render.GetRow        = get_row_ARGB1555;
               data->render.GetValues     = get_values_ARGB1555;
               data->render.PutRow        = put_row_ARGB1555;
               data->render.PutRowRGB     = put_row_rgb_ARGB1555;
               data->render.PutMonoRow    = put_mono_row_ARGB1555;
               data->render.PutValues     = put_values_ARGB1555;
               data->render.PutMonoValues = put_mono_values_ARGB1555;
               break;
          case DSPF_RGB555:
               data->render.GetRow        = get_row_RGB555;
               data->render.GetValues     = get_values_RGB555;
               data->render.PutRow        = put_row_RGB555;
               data->render.PutRowRGB     = put_row_rgb_RGB555;
               data->render.PutMonoRow    = put_mono_row_RGB555;
               data->render.PutValues     = put_values_RGB555;
               data->render.PutMonoValues = put_mono_values_RGB555;
               break;
          case DSPF_RGB16:
               data->render.GetRow        = get_row_RGB16;
               data->render.GetValues     = get_values_RGB16;
               data->render.PutRow        = put_row_RGB16;
               data->render.PutRowRGB     = put_row_rgb_RGB16;
               data->render.PutMonoRow    = put_mono_row_RGB16;
               data->render.PutValues     = put_values_RGB16;
               data->render.PutMonoValues = put_mono_values_RGB16;
               break;
          case DSPF_RGB24:
               data->render.GetRow        = get_row_RGB24;
               data->render.GetValues     = get_values_RGB24;
               data->render.PutRow        = put_row_RGB24;
               data->render.PutRowRGB     = put_row_rgb_RGB24;
               data->render.PutMonoRow    = put_mono_row_RGB24;
               data->render.PutValues     = put_values_RGB24;
               data->render.PutMonoValues = put_mono_values_RGB24;
               break;
          case DSPF_RGB32:
               data->render.GetRow        = get_row_RGB32;
               data->render.GetValues     = get_values_RGB32;
               data->render.PutRow        = put_row_RGB32;
               data->render.PutRowRGB     = put_row_rgb_RGB32;
               data->render.PutMonoRow    = put_mono_row_RGB32;
               data->render.PutValues     = put_values_RGB32;
               data->render.PutMonoValues = put_mono_values_RGB32;
               break;
          case DSPF_ARGB:
               data->render.GetRow        = get_row_ARGB;
               data->render.GetValues     = get_values_ARGB;
               data->render.PutRow        = put_row_ARGB;
               data->render.PutRowRGB     = put_row_rgb_ARGB;
               data->render.PutMonoRow    = put_mono_row_ARGB;
               data->render.PutValues     = put_values_ARGB;
               data->render.PutMonoValues = put_mono_values_ARGB;
               break;
          case DSPF_AiRGB:
               data->render.GetRow        = get_row_AiRGB;
               data->render.GetValues     = get_values_AiRGB;
               data->render.PutRow        = put_row_AiRGB;
               data->render.PutRowRGB     = put_row_rgb_AiRGB;
               data->render.PutMonoRow    = put_mono_row_AiRGB;
               data->render.PutValues     = put_values_AiRGB;
               data->render.PutMonoValues = put_mono_values_AiRGB;
               break;
          default:
               D_BUG( "unexpected pixelformat" );
               return false;
     }

     data->render.Width = data->width;
     data->render.Height = data->height;

     _mesa_add_renderbuffer( framebuffer, BUFFER_FRONT_LEFT, &data->render );
     
     _mesa_add_soft_renderbuffers( framebuffer,
                                   GL_FALSE,
                                   visual->haveDepthBuffer,
                                   visual->haveStencilBuffer,
                                   visual->haveAccumBuffer,
                                   GL_FALSE,
                                   GL_FALSE );

     TNL_CONTEXT( context )->Driver.RunPipeline = _tnl_run_pipeline;

     _mesa_enable_sw_extensions( context );
     
     return true;
}

static void
directfbgl_destroy_context( GLcontext     *context,
                            GLframebuffer *framebuffer )
{
     _swsetup_DestroyContext( context );
     _swrast_DestroyContext( context );
     _tnl_DestroyContext( context );
     _vbo_DestroyContext( context );
     //_mesa_free_framebuffer_data( framebuffer );
     _mesa_free_context_data( context );
}    
 
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d39 10
a48 10
#include "glheader.h"
#include "buffers.h"
#include "context.h"
#include "extensions.h"
#include "framebuffer.h"
#include "renderbuffer.h"
#include "imports.h"
#include "texformat.h"
#include "teximage.h"
#include "texstore.h"
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2006 Claudio Ciccani <klan@@users.sf.net>
d4 6
a9 5
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
d11 6
a16 6
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
a28 4
#include <direct/messages.h>
#include <direct/interface.h>
#include <direct/mem.h>

d32 1
a32 4
#define VERSION_CODE( M, m, r )  (((M) * 1000) + ((m) * 100) + ((r)))
#define DIRECTFB_VERSION_CODE    VERSION_CODE( DIRECTFB_MAJOR_VERSION, \
                                               DIRECTFB_MINOR_VERSION, \
                                               DIRECTFB_MICRO_VERSION )
d34 3
d38 1
a38 5
#ifdef CLAMP
# undef CLAMP
#endif 

#include "GL/directfbgl.h"
d49 1
a49 1
#include "array_cache/acache.h"
d58 6
d81 1
a81 1
     DFBBoolean              locked;
d89 2
a90 2
          __u8              *start;
          __u8              *end;
d105 1
a105 1
static inline int directfbgl_init( void )
d121 1
a121 1
static inline void directfbgl_finish( void )
a136 1
                                         DFBSurfacePixelFormat  format,
d186 1
a186 1
     DFBResult         err;
d190 4
a193 2
     if (data->locked)
          return DFB_LOCKED;
d201 1
a201 1
     err = surface->Lock( surface, DSLF_READ | DSLF_WRITE, 
d203 1
a203 1
     if (err != DFB_OK) {
d205 2
a206 1
          return err;
d216 2
d219 1
a219 2
          data->height = height;
          _mesa_ResizeBuffersMESA();
d222 1
a222 1
     data->locked = DFB_TRUE;
d234 3
a236 2

     _mesa_make_current( NULL, NULL, NULL );
d238 1
a238 1
     data->surface->Unlock( data->surface );
d240 2
a241 3
     directfbgl_unlock();

     data->locked = DFB_FALSE;
d274 1
a274 1
     attributes->double_buffer    = (caps & DSCAPS_FLIPPING) ? 1 : 0;
d280 20
d312 2
d322 1
a322 2
     data->ref     = 1;
     data->surface = surface;
d324 9
a332 3
     surface->AddRef( surface );
     surface->GetPixelFormat( surface, &data->format );
     surface->GetSize( surface, &data->width, &data->height );
d342 3
a344 2
     if (!directfbgl_create_context( &data->context, &data->framebuffer,
                                     &data->visual, data->format, data )) {
d351 8
a358 5
     thiz->AddRef        = IDirectFBGL_Mesa_AddRef;
     thiz->Release       = IDirectFBGL_Mesa_Release;
     thiz->Lock          = IDirectFBGL_Mesa_Lock;
     thiz->Unlock        = IDirectFBGL_Mesa_Unlock;
     thiz->GetAttributes = IDirectFBGL_Mesa_GetAttributes;
d377 1
a377 1
     _ac_InvalidateState( ctx, new_state );
d391 4
d398 2
a399 1
     _mesa_ResizeBuffersMESA();
d403 1
a403 2
dfbClear( GLcontext *ctx, GLbitfield mask, GLboolean all,
          GLint x, GLint y, GLint width, GLint height )
d406 7
a412 5
     
     if (mask & BUFFER_BIT_FRONT_LEFT &&
         ctx->Color.ColorMask[0]      &&
         ctx->Color.ColorMask[1]      &&
         ctx->Color.ColorMask[2]      &&
d416 1
a416 1
          __u8 a, r, g, b;
d423 6
a429 14

#if DIRECTFB_VERSION_CODE >= VERSION_CODE(0,9,25)
          data->surface->GetClip( data->surface, &clip );
#else
          (void)clip;
#endif
          
          if (all) {
               data->surface->SetClip( data->surface, NULL );
          }
          else {
               DFBRegion reg = { x1:x, y1:y, x2:x+width-1, y2:y+height-1 };
               data->surface->SetClip( data->surface, &reg );
          }
a431 4

#if DIRECTFB_VERSION_CODE >= VERSION_CODE(0,9,25)
          data->surface->SetClip( data->surface, &clip );
#endif
d435 2
d438 1
a438 1
          mask &= ~BUFFER_BIT_FRONT_LEFT;
d440 1
d443 3
a445 4
          _swrast_Clear( ctx, mask, all, x, y, width, height );
}        
          
     
d506 25
a530 4
   D[RCOMP] = ((*P & 0x0f00) >> 4); \
   D[GCOMP] = ((*P & 0x00f0)     ); \
   D[BCOMP] = ((*P & 0x000f) << 4); \
   D[ACOMP] = ((*P & 0xf000) >> 8)
d581 3
a583 3
   D[RCOMP] = ((*P & 0x7c00) >> 7); \
   D[GCOMP] = ((*P & 0x03e0) >> 2); \
   D[BCOMP] = ((*P & 0x001f) << 3); \
d588 21
d623 3
a625 3
   D[RCOMP] = ((*P & 0xf800) >> 8); \
   D[GCOMP] = ((*P & 0x07e0) >> 3); \
   D[BCOMP] = ((*P & 0x001f) << 3); \
d751 2
a755 1
               alphaBits = 4;
d758 1
a761 1
               alphaBits = 2;
d764 2
a768 1
               alphaBits = 1;
d809 4
a812 5
directfbgl_create_context( GLcontext             *context,
                           GLframebuffer         *framebuffer,
                           GLvisual              *visual,
                           DFBSurfacePixelFormat  format,
                           IDirectFBGL_data      *data )
d833 1
a833 1
     _ac_CreateContext( context );
d846 1
a846 1
     switch (format) {
d851 1
d860 1
d865 9
d878 1
d887 1
d892 9
d905 1
d914 1
d923 1
d932 1
d941 1
d951 3
d975 5
a979 2
     _mesa_free_framebuffer_data( framebuffer );
     _mesa_notifyDestroy( context );
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d28 4
d35 4
a38 1
#include <directfbgl.h>
a39 3
#include <direct/mem.h>
#include <direct/messages.h>
#include <direct/interface.h>
d41 5
a45 1
#undef CLAMP
a64 6
#define VERSION_CODE( M, m, r )  (((M) * 1000) + ((m) * 100) + ((r)))
#define DIRECTFB_VERSION_CODE    VERSION_CODE( DIRECTFB_MAJOR_VERSION, \
                                               DIRECTFB_MINOR_VERSION, \
                                               DIRECTFB_MICRO_VERSION )


d82 1
a82 1
     int                     locked;
d90 2
a91 2
          GLubyte           *start;
          GLubyte           *end;
d188 1
a188 1
     DFBResult         ret;
d192 2
a193 4
     if (data->locked) {
          data->locked++;
          return DFB_OK;
     }
d201 1
a201 1
     ret = surface->Lock( surface, DSLF_READ | DSLF_WRITE, 
d203 1
a203 1
     if (ret) {
d205 1
a205 2
          directfbgl_unlock();
          return ret;
a214 2
          _mesa_resize_framebuffer( &data->context, 
                                    &data->framebuffer, width, height );
d216 2
a217 1
          data->height = height;                        
d220 1
a220 1
     data->locked++;
d232 2
a233 3
          
     if (--data->locked == 0) {
          _mesa_make_current( NULL, NULL, NULL );
d235 3
a237 1
          data->surface->Unlock( data->surface );
d239 1
a239 2
          directfbgl_unlock();
     }
d272 1
a272 1
     attributes->double_buffer    = ((caps & DSCAPS_FLIPPING) != 0);
a277 20
#if DIRECTFBGL_INTERFACE_VERSION >= 1
static DFBResult
IDirectFBGL_Mesa_GetProcAddress( IDirectFBGL  *thiz,
                                 const char   *name,
                                 void        **ret_address )
{
     DIRECT_INTERFACE_GET_DATA( IDirectFBGL );

     if (!name)
          return DFB_INVARG;
          
     if (!ret_address)
          return DFB_INVARG;
          
     *ret_address = _glapi_get_proc_address( name );
          
     return (*ret_address) ? DFB_OK : DFB_UNSUPPORTED;
}
#endif

a289 2
     DFBResult ret;
     
d298 2
a299 1
     data->ref = 1;
d301 3
a303 9
     /* Duplicate destination surface. */
     ret = surface->GetSubSurface( surface, NULL, &data->surface );
     if (ret) {
          IDirectFBGL_Mesa_Destruct( thiz );
          return ret;
     }

     data->surface->GetPixelFormat( data->surface, &data->format );
     data->surface->GetSize( data->surface, &data->width, &data->height );
d321 5
a325 8
     thiz->AddRef         = IDirectFBGL_Mesa_AddRef;
     thiz->Release        = IDirectFBGL_Mesa_Release;
     thiz->Lock           = IDirectFBGL_Mesa_Lock;
     thiz->Unlock         = IDirectFBGL_Mesa_Unlock;
     thiz->GetAttributes  = IDirectFBGL_Mesa_GetAttributes;
#if DIRECTFBGL_INTERFACE_VERSION >= 1
     thiz->GetProcAddress = IDirectFBGL_Mesa_GetProcAddress;
#endif 
a357 4
/**
 * We only implement this function as a mechanism to check if the
 * framebuffer size has changed (and update corresponding state).
 */
d361 1
a361 2
     /* Nothing to do (the surface can't be resized while it's locked). */
     return;
d365 2
a366 1
dfbClear( GLcontext *ctx, GLbitfield mask )
d369 5
a373 7
 
#define BUFFER_BIT_MASK (BUFFER_BIT_FRONT_LEFT | BUFFER_BIT_FRONT_RIGHT | \
                         BUFFER_BIT_BACK_LEFT  | BUFFER_BIT_BACK_RIGHT  )
     if (mask & BUFFER_BIT_MASK  &&
         ctx->Color.ColorMask[0] &&
         ctx->Color.ColorMask[1] &&
         ctx->Color.ColorMask[2] &&
d377 1
a377 1
          GLubyte   a, r, g, b;
d384 7
a390 5
          clip.x1 = ctx->DrawBuffer->_Xmin;
          clip.y1 = ctx->DrawBuffer->_Ymin;
          clip.x2 = ctx->DrawBuffer->_Xmax - 1;
          clip.y2 = ctx->DrawBuffer->_Ymax - 1;
          data->surface->SetClip( data->surface, &clip );
d392 7
a398 1
          data->surface->Unlock( data->surface );
d401 4
a407 2
          data->video.end = data->video.start + (data->height-1) * data->video.pitch;
          data->render.Data = data->video.start;
d409 1
a409 1
          mask &= ~BUFFER_BIT_MASK;
a410 1
#undef BUFFER_BIT_MASK
d413 4
a416 3
          _swrast_Clear( ctx, mask );
}

a778 1
               data->render.PutRowRGB     = put_row_rgb_RGB332;
a786 1
               data->render.PutRowRGB     = put_row_rgb_ARGB4444;
a794 1
               data->render.PutRowRGB     = put_row_rgb_ARGB2554;
a802 1
               data->render.PutRowRGB     = put_row_rgb_ARGB1555;
a810 1
               data->render.PutRowRGB     = put_row_rgb_RGB16;
a818 1
               data->render.PutRowRGB     = put_row_rgb_RGB24;
a826 1
               data->render.PutRowRGB     = put_row_rgb_RGB32;
a834 1
               data->render.PutRowRGB     = put_row_rgb_ARGB;
a842 1
               data->render.PutRowRGB     = put_row_rgb_AiRGB;
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d2 1
a2 1
 * Copyright (C) 2004-2007 Claudio Ciccani <klan@@directfb.org>
d4 5
a8 6
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
d10 6
a15 6
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
d48 1
a48 1
#include "vbo/vbo.h"
d376 1
a376 1
     _vbo_InvalidateState( ctx, new_state );
d789 1
a789 1
     _vbo_CreateContext( context );
@


