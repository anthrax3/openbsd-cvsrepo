head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.6.0.8
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.6
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.06.11;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.28;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.17.41.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.19.08.12.55;	author aanriot;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.03;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.01;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.30.27;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.13;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.57;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/**
 * \file xm_buffer.h
 * Framebuffer and renderbuffer-related functions.
 */


#include "glxheader.h"
#include "xmesaP.h"
#include "main/imports.h"
#include "main/formats.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
#include "swrast/s_renderbuffer.h"


#define XMESA_RENDERBUFFER 0x1234


#if defined(USE_XSHM) 
static volatile int mesaXErrorFlag = 0;

/**
 * Catches potential Xlib errors.
 */
static int
mesaHandleXError(XMesaDisplay *dpy, XErrorEvent *event)
{
   (void) dpy;
   (void) event;
   mesaXErrorFlag = 1;
   return 0;
}

/**
 * Allocate a shared memory XImage back buffer for the given XMesaBuffer.
 * Return:  GL_TRUE if success, GL_FALSE if error
 */
static GLboolean
alloc_back_shm_ximage(XMesaBuffer b, GLuint width, GLuint height)
{
   /*
    * We have to do a _lot_ of error checking here to be sure we can
    * really use the XSHM extension.  It seems different servers trigger
    * errors at different points if the extension won't work.  Therefore
    * we have to be very careful...
    */
   GC gc;
   int (*old_handler)(XMesaDisplay *, XErrorEvent *);

   if (width == 0 || height == 0) {
      /* this will be true the first time we're called on 'b' */
      return GL_FALSE;
   }

   b->backxrb->ximage = XShmCreateImage(b->xm_visual->display,
                                        b->xm_visual->visinfo->visual,
                                        b->xm_visual->visinfo->depth,
                                        ZPixmap, NULL, &b->shminfo,
                                        width, height);
   if (b->backxrb->ximage == NULL) {
      _mesa_warning(NULL, "alloc_back_buffer: Shared memory error (XShmCreateImage), disabling.\n");
      b->shm = 0;
      return GL_FALSE;
   }

   b->shminfo.shmid = shmget(IPC_PRIVATE, b->backxrb->ximage->bytes_per_line
			     * b->backxrb->ximage->height, IPC_CREAT|0777);
   if (b->shminfo.shmid < 0) {
      _mesa_warning(NULL, "shmget failed while allocating back buffer.\n");
      XDestroyImage(b->backxrb->ximage);
      b->backxrb->ximage = NULL;
      _mesa_warning(NULL, "alloc_back_buffer: Shared memory error (shmget), disabling.\n");
      b->shm = 0;
      return GL_FALSE;
   }

   b->shminfo.shmaddr = b->backxrb->ximage->data
                      = (char*)shmat(b->shminfo.shmid, 0, 0);
   if (b->shminfo.shmaddr == (char *) -1) {
      _mesa_warning(NULL, "shmat() failed while allocating back buffer.\n");
      XDestroyImage(b->backxrb->ximage);
      shmctl(b->shminfo.shmid, IPC_RMID, 0);
      b->backxrb->ximage = NULL;
      _mesa_warning(NULL, "alloc_back_buffer: Shared memory error (shmat), disabling.\n");
      b->shm = 0;
      return GL_FALSE;
   }

   b->shminfo.readOnly = False;
   mesaXErrorFlag = 0;
   old_handler = XSetErrorHandler(mesaHandleXError);
   /* This may trigger the X protocol error we're ready to catch: */
   XShmAttach(b->xm_visual->display, &b->shminfo);
   XSync(b->xm_visual->display, False);

   if (mesaXErrorFlag) {
      /* we are on a remote display, this error is normal, don't print it */
      XFlush(b->xm_visual->display);
      mesaXErrorFlag = 0;
      XDestroyImage(b->backxrb->ximage);
      shmdt(b->shminfo.shmaddr);
      shmctl(b->shminfo.shmid, IPC_RMID, 0);
      b->backxrb->ximage = NULL;
      b->shm = 0;
      (void) XSetErrorHandler(old_handler);
      return GL_FALSE;
   }

   shmctl(b->shminfo.shmid, IPC_RMID, 0); /* nobody else needs it */

   /* Finally, try an XShmPutImage to be really sure the extension works */
   gc = XCreateGC(b->xm_visual->display, b->frontxrb->drawable, 0, NULL);
   XShmPutImage(b->xm_visual->display, b->frontxrb->drawable, gc,
		 b->backxrb->ximage, 0, 0, 0, 0, 1, 1 /*one pixel*/, False);
   XSync(b->xm_visual->display, False);
   XFreeGC(b->xm_visual->display, gc);
   (void) XSetErrorHandler(old_handler);
   if (mesaXErrorFlag) {
      XFlush(b->xm_visual->display);
      mesaXErrorFlag = 0;
      XDestroyImage(b->backxrb->ximage);
      shmdt(b->shminfo.shmaddr);
      shmctl(b->shminfo.shmid, IPC_RMID, 0);
      b->backxrb->ximage = NULL;
      b->shm = 0;
      return GL_FALSE;
   }

   return GL_TRUE;
}
#else
static GLboolean
alloc_back_shm_ximage(XMesaBuffer b, GLuint width, GLuint height)
{
   /* Can't compile XSHM support */
   return GL_FALSE;
}
#endif



/**
 * Setup an off-screen pixmap or Ximage to use as the back buffer.
 * Input:  b - the X/Mesa buffer
 */
static void
alloc_back_buffer(XMesaBuffer b, GLuint width, GLuint height)
{
   if (b->db_mode == BACK_XIMAGE) {
      /* Deallocate the old backxrb->ximage, if any */
      if (b->backxrb->ximage) {
#if defined(USE_XSHM) 
	 if (b->shm) {
	    XShmDetach(b->xm_visual->display, &b->shminfo);
	    XDestroyImage(b->backxrb->ximage);
	    shmdt(b->shminfo.shmaddr);
	 }
	 else
#endif
	   XMesaDestroyImage(b->backxrb->ximage);
	 b->backxrb->ximage = NULL;
      }

      if (width == 0 || height == 0)
         return;

      /* Allocate new back buffer */
      if (b->shm == 0 || !alloc_back_shm_ximage(b, width, height)) {
	 /* Allocate a regular XImage for the back buffer. */
	 b->backxrb->ximage = XCreateImage(b->xm_visual->display,
                                      b->xm_visual->visinfo->visual,
                                      GET_VISUAL_DEPTH(b->xm_visual),
				      ZPixmap, 0,   /* format, offset */
				      NULL,
                                      width, height,
				      8, 0);  /* pad, bytes_per_line */
	 if (!b->backxrb->ximage) {
	    _mesa_warning(NULL, "alloc_back_buffer: XCreateImage failed.\n");
            return;
	 }
         b->backxrb->ximage->data = malloc(b->backxrb->ximage->height
                                        * b->backxrb->ximage->bytes_per_line);
         if (!b->backxrb->ximage->data) {
            _mesa_warning(NULL, "alloc_back_buffer: MALLOC failed.\n");
            XMesaDestroyImage(b->backxrb->ximage);
            b->backxrb->ximage = NULL;
         }
      }
      b->backxrb->pixmap = None;
   }
   else if (b->db_mode == BACK_PIXMAP) {
      /* Free the old back pixmap */
      if (b->backxrb->pixmap) {
         XMesaFreePixmap(b->xm_visual->display, b->backxrb->pixmap);
         b->backxrb->pixmap = 0;
      }

      if (width > 0 && height > 0) {
         /* Allocate new back pixmap */
         b->backxrb->pixmap = XMesaCreatePixmap(b->xm_visual->display,
                                                b->frontxrb->drawable,
                                                width, height,
                                                GET_VISUAL_DEPTH(b->xm_visual));
      }

      b->backxrb->ximage = NULL;
      b->backxrb->drawable = b->backxrb->pixmap;
   }
}


static void
xmesa_delete_renderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
{
   /* XXX Note: the ximage or Pixmap attached to this renderbuffer
    * should probably get freed here, but that's currently done in
    * XMesaDestroyBuffer().
    */
   free(rb);
}


/**
 * Reallocate renderbuffer storage for front color buffer.
 * Called via gl_renderbuffer::AllocStorage()
 */
static GLboolean
xmesa_alloc_front_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
                          GLenum internalFormat, GLuint width, GLuint height)
{
   struct xmesa_renderbuffer *xrb = xmesa_renderbuffer(rb);

   /* just clear these to be sure we don't accidentally use them */
   xrb->origin2 = NULL;
   xrb->origin3 = NULL;
   xrb->origin4 = NULL;

   /* for the FLIP macro: */
   xrb->bottom = height - 1;

   rb->Width = width;
   rb->Height = height;
   rb->InternalFormat = internalFormat;

   return GL_TRUE;
}


/**
 * Reallocate renderbuffer storage for back color buffer.
 * Called via gl_renderbuffer::AllocStorage()
 */
static GLboolean
xmesa_alloc_back_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
                         GLenum internalFormat, GLuint width, GLuint height)
{
   struct xmesa_renderbuffer *xrb = xmesa_renderbuffer(rb);

   /* reallocate the back buffer XImage or Pixmap */
   assert(xrb->Parent);
   alloc_back_buffer(xrb->Parent, width, height);

   /* same as front buffer */
   /* XXX why is this here? */
   (void) xmesa_alloc_front_storage(ctx, rb, internalFormat, width, height);

   /* plus... */
   if (xrb->ximage) {
      /* Needed by PIXELADDR2 macro */
      xrb->width2 = xrb->ximage->bytes_per_line / 2;
      xrb->origin2 = (GLushort *) xrb->ximage->data + xrb->width2 * (height - 1);

      /* Needed by PIXELADDR3 macro */
      xrb->width3 = xrb->ximage->bytes_per_line;
      xrb->origin3 = (GLubyte *) xrb->ximage->data + xrb->width3 * (height - 1);

      /* Needed by PIXELADDR4 macro */
      xrb->width4 = xrb->ximage->width;
      xrb->origin4 = (GLuint *) xrb->ximage->data + xrb->width4 * (height - 1);
   }
   else {
      /* out of memory or buffer size is 0 x 0 */
      xrb->width2 = xrb->width3 = xrb->width4 = 0;
      xrb->origin2 = NULL;
      xrb->origin3 = NULL;
      xrb->origin4 = NULL;
   }

   return GL_TRUE;
}


/**
 * Used for allocating front/back renderbuffers for an X window.
 */
struct xmesa_renderbuffer *
xmesa_new_renderbuffer(struct gl_context *ctx, GLuint name,
                       const struct xmesa_visual *xmvis,
                       GLboolean backBuffer)
{
   struct xmesa_renderbuffer *xrb = CALLOC_STRUCT(xmesa_renderbuffer);
   if (xrb) {
      GLuint name = 0;
      _mesa_init_renderbuffer(&xrb->Base.Base, name);

      xrb->Base.Base.Delete = xmesa_delete_renderbuffer;
      if (backBuffer)
         xrb->Base.Base.AllocStorage = xmesa_alloc_back_storage;
      else
         xrb->Base.Base.AllocStorage = xmesa_alloc_front_storage;

      xrb->Base.Base.InternalFormat = GL_RGBA;
      xrb->Base.Base._BaseFormat = GL_RGBA;
      xrb->Base.Base.ClassID = XMESA_RENDERBUFFER;

      switch (xmvis->undithered_pf) {
      case PF_8R8G8B:
         /* This will really only happen for pixmaps.  We'll access the
          * pixmap via a temporary XImage which will be 32bpp.
          */
         xrb->Base.Base.Format = MESA_FORMAT_B8G8R8X8_UNORM;
         break;
      case PF_8A8R8G8B:
         xrb->Base.Base.Format = MESA_FORMAT_B8G8R8A8_UNORM;
         break;
      case PF_8A8B8G8R:
         xrb->Base.Base.Format = MESA_FORMAT_R8G8B8A8_UNORM;
         break;
      case PF_5R6G5B:
         xrb->Base.Base.Format = MESA_FORMAT_B5G6R5_UNORM;
         break;
      default:
         _mesa_warning(ctx, "Bad pixel format in xmesa_new_renderbuffer");
         xrb->Base.Base.Format = MESA_FORMAT_B8G8R8A8_UNORM;
         break;
      }

      /* only need to set Red/Green/EtcBits fields for user-created RBs */
   }
   return xrb;
}


/**
 * Called via gl_framebuffer::Delete() method when this buffer
 * is _really_ being deleted.
 */
void
xmesa_delete_framebuffer(struct gl_framebuffer *fb)
{
   XMesaBuffer b = XMESA_BUFFER(fb);

   if (b->num_alloced > 0) {
      /* If no other buffer uses this X colormap then free the colors. */
      if (!xmesa_find_buffer(b->display, b->cmap, b)) {
         XFreeColors(b->display, b->cmap,
                     b->alloced_colors, b->num_alloced, 0);
      }
   }

   if (b->gc)
      XMesaFreeGC(b->display, b->gc);
   if (b->cleargc)
      XMesaFreeGC(b->display, b->cleargc);
   if (b->swapgc)
      XMesaFreeGC(b->display, b->swapgc);

   if (fb->Visual.doubleBufferMode) {
      /* free back ximage/pixmap/shmregion */
      if (b->backxrb->ximage) {
#if defined(USE_XSHM) 
         if (b->shm) {
            XShmDetach( b->display, &b->shminfo );
            XDestroyImage( b->backxrb->ximage );
            shmdt( b->shminfo.shmaddr );
         }
         else
#endif
            XMesaDestroyImage( b->backxrb->ximage );
         b->backxrb->ximage = NULL;
      }
      if (b->backxrb->pixmap) {
         XMesaFreePixmap( b->display, b->backxrb->pixmap );
      }
   }

   _mesa_free_framebuffer_data(fb);
   free(fb);
}


/**
 * Called via ctx->Driver.MapRenderbuffer()
 */
void
xmesa_MapRenderbuffer(struct gl_context *ctx,
                      struct gl_renderbuffer *rb,
                      GLuint x, GLuint y, GLuint w, GLuint h,
                      GLbitfield mode,
                      GLubyte **mapOut, GLint *rowStrideOut)
{
   struct xmesa_renderbuffer *xrb = xmesa_renderbuffer(rb);

   if (xrb->Base.Base.ClassID == XMESA_RENDERBUFFER) {
      XImage *ximage = xrb->ximage;

      assert(!xrb->map_mode); /* only a single mapping allowed */

      xrb->map_mode = mode;
      xrb->map_x = x;
      xrb->map_y = y;
      xrb->map_w = w;
      xrb->map_h = h;

      if (ximage) {
         int y2 = rb->Height - y - 1;

         *mapOut = (GLubyte *) ximage->data
            + y2 * ximage->bytes_per_line
            + x * ximage->bits_per_pixel / 8;
      }
      else {
         /* this must be a pixmap/window renderbuffer */
         int (*old_handler)(XMesaDisplay *, XErrorEvent *);
         int y2 = rb->Height - y - h;

         assert(xrb->pixmap);

         /* Install error handler for XGetImage() in case the the window
          * isn't mapped.  If we fail we'll create a temporary XImage.
          */
         mesaXErrorFlag = 0;
         old_handler = XSetErrorHandler(mesaHandleXError);

         /* read pixel data out of the pixmap/window into an XImage */
         ximage = XGetImage(xrb->Parent->display,
                            xrb->pixmap, x, y2, w, h,
                            AllPlanes, ZPixmap);

         XSetErrorHandler(old_handler);

         if (mesaXErrorFlag) {
            /* create new, temporary XImage */
            int bytes_per_line =
               _mesa_format_row_stride(xrb->Base.Base.Format,
                                       xrb->Base.Base.Width);
            char *image = malloc(bytes_per_line *
                                          xrb->Base.Base.Height);
            ximage = XCreateImage(xrb->Parent->display,
                                  xrb->Parent->xm_visual->visinfo->visual,
                                  xrb->Parent->xm_visual->visinfo->depth,
                                  ZPixmap, /* format */
                                  0, /* offset */
                                  image, /* data */
                                  xrb->Base.Base.Width,
                                  xrb->Base.Base.Height,
                                  8, /* pad */
                                  bytes_per_line);
         }

         if (!ximage) {
            *mapOut = NULL;
            *rowStrideOut = 0;
            return;
         }

         xrb->map_ximage = ximage;

         /* the first row of the OpenGL image is last row of the XImage */
         *mapOut = (GLubyte *) ximage->data
            + (h - 1) * ximage->bytes_per_line;
      }

      /* We return a negative stride here since XImage data is upside down
       * with respect to OpenGL images.
       */
      *rowStrideOut = -ximage->bytes_per_line;
      return;
   }

   /* otherwise, this is an ordinary malloc-based renderbuffer */
   _swrast_map_soft_renderbuffer(ctx, rb, x, y, w, h, mode,
                                 mapOut, rowStrideOut);
}


/**
 * Called via ctx->Driver.UnmapRenderbuffer()
 */
void
xmesa_UnmapRenderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
{
   struct xmesa_renderbuffer *xrb = xmesa_renderbuffer(rb);

   if (xrb->Base.Base.ClassID == XMESA_RENDERBUFFER) {
      XImage *ximage = xrb->ximage;

      if (!ximage) {
         /* this must be a pixmap/window renderbuffer */
         assert(xrb->pixmap);
         assert(xrb->map_ximage);
         if (xrb->map_ximage) {
            if (xrb->map_mode & GL_MAP_WRITE_BIT) {
               /* put modified ximage data back into the pixmap/window */
               int y2 = rb->Height - xrb->map_y - xrb->map_h;
               GC gc = XCreateGC(xrb->Parent->display, xrb->pixmap, 0, NULL);

               XPutImage(xrb->Parent->display,
                         xrb->pixmap,              /* dest */
                         gc,
                         xrb->map_ximage,          /* source */
                         0, 0,                     /* src x, y */
                         xrb->map_x, y2,           /* dest x, y */
                         xrb->map_w, xrb->map_h);  /* size */

               XFreeGC(xrb->Parent->display, gc);
            }
            XMesaDestroyImage(xrb->map_ximage);
            xrb->map_ximage = NULL;
         }
      }

      xrb->map_mode = 0x0;

      return;
   }

   /* otherwise, this is an ordinary malloc-based renderbuffer */
   _swrast_unmap_soft_renderbuffer(ctx, rb);
}


@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@d346 1
a346 1
         xrb->Base.Base.Format = MESA_FORMAT_XRGB8888;
d349 1
a349 1
         xrb->Base.Base.Format = MESA_FORMAT_ARGB8888;
d352 1
a352 1
         xrb->Base.Base.Format = MESA_FORMAT_RGBA8888_REV;
d355 1
a355 1
         xrb->Base.Base.Format = MESA_FORMAT_RGB565;
d359 1
a359 1
         xrb->Base.Base.Format = MESA_FORMAT_ARGB8888;
@


1.6
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  6.5.2
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d38 4
d206 1
a206 1
         b->backxrb->ximage->data = (char *) MALLOC(b->backxrb->ximage->height
d238 1
a238 1
xmesa_delete_renderbuffer(struct gl_renderbuffer *rb)
a258 1
   xrb->origin1 = NULL;
a293 4
      /* Needed by PIXELADDR1 macro */
      xrb->width1 = xrb->ximage->bytes_per_line;
      xrb->origin1 = (GLubyte *) xrb->ximage->data + xrb->width1 * (height - 1);

d308 1
a308 2
      xrb->width1 = xrb->width2 = xrb->width3 = xrb->width4 = 0;
      xrb->origin1 = NULL;
d318 3
d322 2
a323 1
xmesa_new_renderbuffer(struct gl_context *ctx, GLuint name, const struct gl_config *visual,
d329 1
a329 1
      _mesa_init_renderbuffer(&xrb->Base, name);
d331 1
a331 1
      xrb->Base.Delete = xmesa_delete_renderbuffer;
d333 1
a333 1
         xrb->Base.AllocStorage = xmesa_alloc_back_storage;
d335 27
a361 1
         xrb->Base.AllocStorage = xmesa_alloc_front_storage;
a362 4
      xrb->Base.InternalFormat = GL_RGBA;
      xrb->Base.Format = MESA_FORMAT_RGBA8888;
      xrb->Base._BaseFormat = GL_RGBA;
      xrb->Base.DataType = GL_UNSIGNED_BYTE;
d409 75
a483 4
         if (b->xm_visual->hpcr_clear_flag) {
            XMesaFreePixmap( b->display,
                             b->xm_visual->hpcr_clear_pixmap );
            XMesaDestroyImage( b->xm_visual->hpcr_clear_ximage );
d485 12
d498 6
d506 45
a550 4
   if (b->rowimage) {
      free( b->rowimage->data );
      b->rowimage->data = NULL;
      XMesaDestroyImage( b->rowimage );
d553 2
a554 2
   _mesa_free_framebuffer_data(fb);
   free(fb);
d556 2
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d40 1
a40 1
#if defined(USE_XSHM) && !defined(XFree86Server)
d173 1
a173 1
#if defined(USE_XSHM) && !defined(XFree86Server)
a190 4
#ifdef XFree86Server
	 b->backxrb->ximage = XMesaCreateImage(b->xm_visual->BitsPerPixel,
                                               width, height, NULL);
#else
a197 1
#endif
d249 1
a249 1
xmesa_alloc_front_storage(GLcontext *ctx, struct gl_renderbuffer *rb,
d276 1
a276 1
xmesa_alloc_back_storage(GLcontext *ctx, struct gl_renderbuffer *rb,
d321 1
a321 1
xmesa_new_renderbuffer(GLcontext *ctx, GLuint name, const GLvisual *visual,
a356 7
#ifdef XFree86Server
         int client = 0;
         if (b->frontxrb->drawable)
            client = CLIENT_ID(b->frontxrb->drawable->id);
         (void)FreeColors(b->cmap, client,
                          b->num_alloced, b->alloced_colors, 0);
#else
a358 1
#endif
d372 1
a372 1
#if defined(USE_XSHM) && !defined(XFree86Server)
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d35 1
d245 1
a245 1
   _mesa_free(rb);
d340 4
a343 15
      if (visual->rgbMode) {
         xrb->Base.InternalFormat = GL_RGBA;
         xrb->Base._BaseFormat = GL_RGBA;
         xrb->Base.DataType = GL_UNSIGNED_BYTE;
         xrb->Base.RedBits = visual->redBits;
         xrb->Base.GreenBits = visual->greenBits;
         xrb->Base.BlueBits = visual->blueBits;
         xrb->Base.AlphaBits = visual->alphaBits;
      }
      else {
         xrb->Base.InternalFormat = GL_COLOR_INDEX;
         xrb->Base._BaseFormat = GL_COLOR_INDEX;
         xrb->Base.DataType = GL_UNSIGNED_INT;
         xrb->Base.IndexBits = visual->indexBits;
      }
d407 1
a407 1
      _mesa_free( b->rowimage->data );
d413 1
a413 1
   _mesa_free(fb);
@


1.3
log
@merge Mesa 7.0.1
@
text
@a32 1
#include "GL/xmesa.h"
d34 3
a36 3
#include "imports.h"
#include "framebuffer.h"
#include "renderbuffer.h"
d232 1
@


1.2
log
@assorted fixes for dealing with zero-size frame/renderbuffers.

from freedesktop (mesa-commits) with help from games/bzflag;
ok matthieu@@
@
text
@d36 1
d40 1
a40 1
#ifndef XFree86Server
a53 2
#endif

a58 1
#ifndef XFree86Server
a61 1
#ifdef USE_XSHM
d151 1
d153 3
a157 1
#endif
d189 2
d192 2
a193 4
      /* Allocate a regular XImage for the back buffer. */
      b->backxrb->ximage = XMesaCreateImage(b->xm_visual->BitsPerPixel,
                                            width, height, NULL);
      {
a194 2
      if (b->shm == 0 || !alloc_back_shm_ximage(b, width, height)) {
	 /* Allocate a regular XImage for the back buffer. */
a217 1

d360 8
d369 15
d385 40
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 1999-2005  Brian Paul   All Rights Reserved.
d26 6
d39 201
d253 1
d264 1
d280 1
a280 1
 * XXX we should resize the back pixmap/ximage here.
d288 4
d293 1
d315 6
a320 2
      /* this assertion will fail if we happend to run out of memory */
      /*assert(xrb->pixmap);*/
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
a25 6
/**
 * \file xm_buffer.h
 * Framebuffer and renderbuffer-related functions.
 */


a32 200
#ifndef XFree86Server
static volatile int mesaXErrorFlag = 0;

/**
 * Catches potential Xlib errors.
 */
static int
mesaHandleXError(XMesaDisplay *dpy, XErrorEvent *event)
{
   (void) dpy;
   (void) event;
   mesaXErrorFlag = 1;
   return 0;
}
#endif


/**
 * Allocate a shared memory XImage back buffer for the given XMesaBuffer.
 * Return:  GL_TRUE if success, GL_FALSE if error
 */
#ifndef XFree86Server
static GLboolean
alloc_back_shm_ximage(XMesaBuffer b, GLuint width, GLuint height)
{
#ifdef USE_XSHM
   /*
    * We have to do a _lot_ of error checking here to be sure we can
    * really use the XSHM extension.  It seems different servers trigger
    * errors at different points if the extension won't work.  Therefore
    * we have to be very careful...
    */
   GC gc;
   int (*old_handler)(XMesaDisplay *, XErrorEvent *);

   if (width == 0 || height == 0) {
      /* this will be true the first time we're called on 'b' */
      return GL_FALSE;
   }

   b->backxrb->ximage = XShmCreateImage(b->xm_visual->display,
                                        b->xm_visual->visinfo->visual,
                                        b->xm_visual->visinfo->depth,
                                        ZPixmap, NULL, &b->shminfo,
                                        width, height);
   if (b->backxrb->ximage == NULL) {
      _mesa_warning(NULL, "alloc_back_buffer: Shared memory error (XShmCreateImage), disabling.\n");
      b->shm = 0;
      return GL_FALSE;
   }

   b->shminfo.shmid = shmget(IPC_PRIVATE, b->backxrb->ximage->bytes_per_line
			     * b->backxrb->ximage->height, IPC_CREAT|0777);
   if (b->shminfo.shmid < 0) {
      _mesa_warning(NULL, "shmget failed while allocating back buffer.\n");
      XDestroyImage(b->backxrb->ximage);
      b->backxrb->ximage = NULL;
      _mesa_warning(NULL, "alloc_back_buffer: Shared memory error (shmget), disabling.\n");
      b->shm = 0;
      return GL_FALSE;
   }

   b->shminfo.shmaddr = b->backxrb->ximage->data
                      = (char*)shmat(b->shminfo.shmid, 0, 0);
   if (b->shminfo.shmaddr == (char *) -1) {
      _mesa_warning(NULL, "shmat() failed while allocating back buffer.\n");
      XDestroyImage(b->backxrb->ximage);
      shmctl(b->shminfo.shmid, IPC_RMID, 0);
      b->backxrb->ximage = NULL;
      _mesa_warning(NULL, "alloc_back_buffer: Shared memory error (shmat), disabling.\n");
      b->shm = 0;
      return GL_FALSE;
   }

   b->shminfo.readOnly = False;
   mesaXErrorFlag = 0;
   old_handler = XSetErrorHandler(mesaHandleXError);
   /* This may trigger the X protocol error we're ready to catch: */
   XShmAttach(b->xm_visual->display, &b->shminfo);
   XSync(b->xm_visual->display, False);

   if (mesaXErrorFlag) {
      /* we are on a remote display, this error is normal, don't print it */
      XFlush(b->xm_visual->display);
      mesaXErrorFlag = 0;
      XDestroyImage(b->backxrb->ximage);
      shmdt(b->shminfo.shmaddr);
      shmctl(b->shminfo.shmid, IPC_RMID, 0);
      b->backxrb->ximage = NULL;
      b->shm = 0;
      (void) XSetErrorHandler(old_handler);
      return GL_FALSE;
   }

   shmctl(b->shminfo.shmid, IPC_RMID, 0); /* nobody else needs it */

   /* Finally, try an XShmPutImage to be really sure the extension works */
   gc = XCreateGC(b->xm_visual->display, b->frontxrb->drawable, 0, NULL);
   XShmPutImage(b->xm_visual->display, b->frontxrb->drawable, gc,
		 b->backxrb->ximage, 0, 0, 0, 0, 1, 1 /*one pixel*/, False);
   XSync(b->xm_visual->display, False);
   XFreeGC(b->xm_visual->display, gc);
   (void) XSetErrorHandler(old_handler);
   if (mesaXErrorFlag) {
      XFlush(b->xm_visual->display);
      mesaXErrorFlag = 0;
      XDestroyImage(b->backxrb->ximage);
      shmdt(b->shminfo.shmaddr);
      shmctl(b->shminfo.shmid, IPC_RMID, 0);
      b->backxrb->ximage = NULL;
      b->shm = 0;
      return GL_FALSE;
   }

   return GL_TRUE;
#else
   /* Can't compile XSHM support */
   return GL_FALSE;
#endif
}
#endif



/**
 * Setup an off-screen pixmap or Ximage to use as the back buffer.
 * Input:  b - the X/Mesa buffer
 */
static void
alloc_back_buffer(XMesaBuffer b, GLuint width, GLuint height)
{
   if (width == 0 || height == 0)
      return;

   if (b->db_mode == BACK_XIMAGE) {
      /* Deallocate the old backxrb->ximage, if any */
      if (b->backxrb->ximage) {
#if defined(USE_XSHM) && !defined(XFree86Server)
	 if (b->shm) {
	    XShmDetach(b->xm_visual->display, &b->shminfo);
	    XDestroyImage(b->backxrb->ximage);
	    shmdt(b->shminfo.shmaddr);
	 }
	 else
#endif
	   XMesaDestroyImage(b->backxrb->ximage);
	 b->backxrb->ximage = NULL;
      }

      /* Allocate new back buffer */
#ifdef XFree86Server
      /* Allocate a regular XImage for the back buffer. */
      b->backxrb->ximage = XMesaCreateImage(b->xm_visual->BitsPerPixel,
                                            width, height, NULL);
      {
#else
      if (b->shm == 0 || !alloc_back_shm_ximage(b, width, height)) {
	 /* Allocate a regular XImage for the back buffer. */
	 b->backxrb->ximage = XCreateImage(b->xm_visual->display,
                                      b->xm_visual->visinfo->visual,
                                      GET_VISUAL_DEPTH(b->xm_visual),
				      ZPixmap, 0,   /* format, offset */
				      NULL,
                                      width, height,
				      8, 0);  /* pad, bytes_per_line */
#endif
	 if (!b->backxrb->ximage) {
	    _mesa_warning(NULL, "alloc_back_buffer: XCreateImage failed.\n");
            return;
	 }
         b->backxrb->ximage->data = (char *) MALLOC(b->backxrb->ximage->height
                                        * b->backxrb->ximage->bytes_per_line);
         if (!b->backxrb->ximage->data) {
            _mesa_warning(NULL, "alloc_back_buffer: MALLOC failed.\n");
            XMesaDestroyImage(b->backxrb->ximage);
            b->backxrb->ximage = NULL;
         }
      }
      b->backxrb->pixmap = None;
   }
   else if (b->db_mode == BACK_PIXMAP) {
      if (!width)
         width = 1;
      if (!height)
         height = 1;

      /* Free the old back pixmap */
      if (b->backxrb->pixmap) {
	 XMesaFreePixmap(b->xm_visual->display, b->backxrb->pixmap);
      }
      /* Allocate new back pixmap */
      b->backxrb->pixmap = XMesaCreatePixmap(b->xm_visual->display,
                                             b->frontxrb->drawable,
                                             width, height,
                                             GET_VISUAL_DEPTH(b->xm_visual));
      b->backxrb->ximage = NULL;
   }
}


d71 1
a78 4
   /* reallocate the back buffer XImage or Pixmap */
   assert(xrb->Parent);
   alloc_back_buffer(xrb->Parent, width, height);

a79 1
   /* XXX why is this here? */
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@a35 1
#include "framebuffer.h"
d39 1
a39 1
#if defined(USE_XSHM) && !defined(XFree86Server)
d53 2
d60 1
d64 1
a153 1
}
a154 3
static GLboolean
alloc_back_shm_ximage(XMesaBuffer b, GLuint width, GLuint height)
{
d157 1
d170 3
a187 3
      if (width == 0 || height == 0)
         return;

d189 6
a196 4
#ifdef XFree86Server
	 b->backxrb->ximage = XMesaCreateImage(b->xm_visual->BitsPerPixel,
                                               width, height, NULL);
#else
d220 5
d227 1
a227 2
         XMesaFreePixmap(b->xm_visual->display, b->backxrb->pixmap);
         b->backxrb->pixmap = 0;
d229 5
a233 9

      if (width > 0 && height > 0) {
         /* Allocate new back pixmap */
         b->backxrb->pixmap = XMesaCreatePixmap(b->xm_visual->display,
                                                b->frontxrb->drawable,
                                                width, height,
                                                GET_VISUAL_DEPTH(b->xm_visual));
      }

a251 1
 * Called via gl_renderbuffer::AllocStorage()
a261 1
   xrb->origin3 = NULL;
a276 1
 * Called via gl_renderbuffer::AllocStorage()
d311 2
a312 6
      /* out of memory or buffer size is 0 x 0 */
      xrb->width1 = xrb->width2 = xrb->width3 = xrb->width4 = 0;
      xrb->origin1 = NULL;
      xrb->origin2 = NULL;
      xrb->origin3 = NULL;
      xrb->origin4 = NULL;
a354 55
/**
 * Called via gl_framebuffer::Delete() method when this buffer
 * is _really_ being deleted.
 */
void
xmesa_delete_framebuffer(struct gl_framebuffer *fb)
{
   XMesaBuffer b = XMESA_BUFFER(fb);

   if (b->num_alloced > 0) {
      /* If no other buffer uses this X colormap then free the colors. */
      if (!xmesa_find_buffer(b->display, b->cmap, b)) {
#ifdef XFree86Server
         int client = 0;
         if (b->frontxrb->drawable)
            client = CLIENT_ID(b->frontxrb->drawable->id);
         (void)FreeColors(b->cmap, client,
                          b->num_alloced, b->alloced_colors, 0);
#else
         XFreeColors(b->display, b->cmap,
                     b->alloced_colors, b->num_alloced, 0);
#endif
      }
   }

   if (b->gc)
      XMesaFreeGC(b->display, b->gc);
   if (b->cleargc)
      XMesaFreeGC(b->display, b->cleargc);
   if (b->swapgc)
      XMesaFreeGC(b->display, b->swapgc);

   if (fb->Visual.doubleBufferMode) {
      /* free back ximage/pixmap/shmregion */
      if (b->backxrb->ximage) {
#if defined(USE_XSHM) && !defined(XFree86Server)
         if (b->shm) {
            XShmDetach( b->display, &b->shminfo );
            XDestroyImage( b->backxrb->ximage );
            shmdt( b->shminfo.shmaddr );
         }
         else
#endif
            XMesaDestroyImage( b->backxrb->ximage );
         b->backxrb->ximage = NULL;
      }
      if (b->backxrb->pixmap) {
         XMesaFreePixmap( b->display, b->backxrb->pixmap );
         if (b->xm_visual->hpcr_clear_flag) {
            XMesaFreePixmap( b->display,
                             b->xm_visual->hpcr_clear_pixmap );
            XMesaDestroyImage( b->xm_visual->hpcr_clear_ximage );
         }
      }
   }
a355 5
   if (b->rowimage) {
      _mesa_free( b->rowimage->data );
      b->rowimage->data = NULL;
      XMesaDestroyImage( b->rowimage );
   }
a356 3
   _mesa_free_framebuffer_data(fb);
   _mesa_free(fb);
}
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d33 1
d35 3
a37 4
#include "main/imports.h"
#include "main/formats.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
d40 1
a40 1
#if defined(USE_XSHM) 
d173 1
a173 1
#if defined(USE_XSHM) 
d191 4
d202 1
a232 1
      b->backxrb->drawable = b->backxrb->pixmap;
d244 1
a244 1
   free(rb);
d253 1
a253 1
xmesa_alloc_front_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
d280 1
a280 1
xmesa_alloc_back_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
d325 1
a325 1
xmesa_new_renderbuffer(struct gl_context *ctx, GLuint name, const struct gl_config *visual,
d339 15
a353 4
      xrb->Base.InternalFormat = GL_RGBA;
      xrb->Base.Format = MESA_FORMAT_RGBA8888;
      xrb->Base._BaseFormat = GL_RGBA;
      xrb->Base.DataType = GL_UNSIGNED_BYTE;
d372 7
d381 1
d395 1
a395 1
#if defined(USE_XSHM) 
d417 1
a417 1
      free( b->rowimage->data );
d423 1
a423 1
   free(fb);
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a37 4
#include "swrast/s_renderbuffer.h"


#define XMESA_RENDERBUFFER 0x1234
d202 1
a202 1
         b->backxrb->ximage->data = malloc(b->backxrb->ximage->height
d234 1
a234 1
xmesa_delete_renderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
d255 1
d291 4
d309 2
a310 1
      xrb->width2 = xrb->width3 = xrb->width4 = 0;
a319 3
/**
 * Used for allocating front/back renderbuffers for an X window.
 */
d321 1
a321 2
xmesa_new_renderbuffer(struct gl_context *ctx, GLuint name,
                       const struct xmesa_visual *xmvis,
d327 1
a327 1
      _mesa_init_renderbuffer(&xrb->Base.Base, name);
d329 1
a329 1
      xrb->Base.Base.Delete = xmesa_delete_renderbuffer;
d331 1
a331 1
         xrb->Base.Base.AllocStorage = xmesa_alloc_back_storage;
d333 1
a333 27
         xrb->Base.Base.AllocStorage = xmesa_alloc_front_storage;

      xrb->Base.Base.InternalFormat = GL_RGBA;
      xrb->Base.Base._BaseFormat = GL_RGBA;
      xrb->Base.Base.ClassID = XMESA_RENDERBUFFER;

      switch (xmvis->undithered_pf) {
      case PF_8R8G8B:
         /* This will really only happen for pixmaps.  We'll access the
          * pixmap via a temporary XImage which will be 32bpp.
          */
         xrb->Base.Base.Format = MESA_FORMAT_XRGB8888;
         break;
      case PF_8A8R8G8B:
         xrb->Base.Base.Format = MESA_FORMAT_ARGB8888;
         break;
      case PF_8A8B8G8R:
         xrb->Base.Base.Format = MESA_FORMAT_RGBA8888_REV;
         break;
      case PF_5R6G5B:
         xrb->Base.Base.Format = MESA_FORMAT_RGB565;
         break;
      default:
         _mesa_warning(ctx, "Bad pixel format in xmesa_new_renderbuffer");
         xrb->Base.Base.Format = MESA_FORMAT_ARGB8888;
         break;
      }
d335 4
d385 4
a388 75
      }
   }

   _mesa_free_framebuffer_data(fb);
   free(fb);
}


/**
 * Called via ctx->Driver.MapRenderbuffer()
 */
void
xmesa_MapRenderbuffer(struct gl_context *ctx,
                      struct gl_renderbuffer *rb,
                      GLuint x, GLuint y, GLuint w, GLuint h,
                      GLbitfield mode,
                      GLubyte **mapOut, GLint *rowStrideOut)
{
   struct xmesa_renderbuffer *xrb = xmesa_renderbuffer(rb);

   if (xrb->Base.Base.ClassID == XMESA_RENDERBUFFER) {
      XImage *ximage = xrb->ximage;

      assert(!xrb->map_mode); /* only a single mapping allowed */

      xrb->map_mode = mode;
      xrb->map_x = x;
      xrb->map_y = y;
      xrb->map_w = w;
      xrb->map_h = h;

      if (ximage) {
         int y2 = rb->Height - y - 1;

         *mapOut = (GLubyte *) ximage->data
            + y2 * ximage->bytes_per_line
            + x * ximage->bits_per_pixel / 8;
      }
      else {
         /* this must be a pixmap/window renderbuffer */
         int (*old_handler)(XMesaDisplay *, XErrorEvent *);
         int y2 = rb->Height - y - h;

         assert(xrb->pixmap);

         /* Install error handler for XGetImage() in case the the window
          * isn't mapped.  If we fail we'll create a temporary XImage.
          */
         mesaXErrorFlag = 0;
         old_handler = XSetErrorHandler(mesaHandleXError);

         /* read pixel data out of the pixmap/window into an XImage */
         ximage = XGetImage(xrb->Parent->display,
                            xrb->pixmap, x, y2, w, h,
                            AllPlanes, ZPixmap);

         XSetErrorHandler(old_handler);

         if (mesaXErrorFlag) {
            /* create new, temporary XImage */
            int bytes_per_line =
               _mesa_format_row_stride(xrb->Base.Base.Format,
                                       xrb->Base.Base.Width);
            char *image = malloc(bytes_per_line *
                                          xrb->Base.Base.Height);
            ximage = XCreateImage(xrb->Parent->display,
                                  xrb->Parent->xm_visual->visinfo->visual,
                                  xrb->Parent->xm_visual->visinfo->depth,
                                  ZPixmap, /* format */
                                  0, /* offset */
                                  image, /* data */
                                  xrb->Base.Base.Width,
                                  xrb->Base.Base.Height,
                                  8, /* pad */
                                  bytes_per_line);
a389 12

         if (!ximage) {
            *mapOut = NULL;
            *rowStrideOut = 0;
            return;
         }

         xrb->map_ximage = ximage;

         /* the first row of the OpenGL image is last row of the XImage */
         *mapOut = (GLubyte *) ximage->data
            + (h - 1) * ximage->bytes_per_line;
a390 6

      /* We return a negative stride here since XImage data is upside down
       * with respect to OpenGL images.
       */
      *rowStrideOut = -ximage->bytes_per_line;
      return;
d393 4
a396 45
   /* otherwise, this is an ordinary malloc-based renderbuffer */
   _swrast_map_soft_renderbuffer(ctx, rb, x, y, w, h, mode,
                                 mapOut, rowStrideOut);
}


/**
 * Called via ctx->Driver.UnmapRenderbuffer()
 */
void
xmesa_UnmapRenderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
{
   struct xmesa_renderbuffer *xrb = xmesa_renderbuffer(rb);

   if (xrb->Base.Base.ClassID == XMESA_RENDERBUFFER) {
      XImage *ximage = xrb->ximage;

      if (!ximage) {
         /* this must be a pixmap/window renderbuffer */
         assert(xrb->pixmap);
         assert(xrb->map_ximage);
         if (xrb->map_ximage) {
            if (xrb->map_mode & GL_MAP_WRITE_BIT) {
               /* put modified ximage data back into the pixmap/window */
               int y2 = rb->Height - xrb->map_y - xrb->map_h;
               GC gc = XCreateGC(xrb->Parent->display, xrb->pixmap, 0, NULL);

               XPutImage(xrb->Parent->display,
                         xrb->pixmap,              /* dest */
                         gc,
                         xrb->map_ximage,          /* source */
                         0, 0,                     /* src x, y */
                         xrb->map_x, y2,           /* dest x, y */
                         xrb->map_w, xrb->map_h);  /* size */

               XFreeGC(xrb->Parent->display, gc);
            }
            XMesaDestroyImage(xrb->map_ximage);
            xrb->map_ximage = NULL;
         }
      }

      xrb->map_mode = 0x0;

      return;
d399 2
a400 2
   /* otherwise, this is an ordinary malloc-based renderbuffer */
   _swrast_unmap_soft_renderbuffer(ctx, rb);
a401 2


@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d346 1
a346 1
         xrb->Base.Base.Format = MESA_FORMAT_B8G8R8X8_UNORM;
d349 1
a349 1
         xrb->Base.Base.Format = MESA_FORMAT_B8G8R8A8_UNORM;
d352 1
a352 1
         xrb->Base.Base.Format = MESA_FORMAT_R8G8B8A8_UNORM;
d355 1
a355 1
         xrb->Base.Base.Format = MESA_FORMAT_B5G6R5_UNORM;
d359 1
a359 1
         xrb->Base.Base.Format = MESA_FORMAT_B8G8R8A8_UNORM;
@


