head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.14.06.12;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.28;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.07;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.30.31;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.16.14;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.57;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/*
 * This file contains "accelerated" triangle functions.  It should be
 * fairly easy to write new special-purpose triangle functions and hook
 * them into this module.
 */


#include "main/imports.h"
#include "main/mtypes.h"
#include "glxheader.h"
#include "xmesaP.h"

/* Internal swrast includes:
 */
#include "swrast/s_context.h"
#include "swrast/s_depth.h"
#include "swrast/s_triangle.h"


#define GET_XRB(XRB)  struct xmesa_renderbuffer *XRB = \
   xmesa_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0])


/**********************************************************************/
/***                   Triangle rendering                           ***/
/**********************************************************************/


#if CHAN_BITS == 8

/*
 * XImage, smooth, depth-buffered, PF_TRUECOLOR triangle.
 */
#define NAME smooth_TRUECOLOR_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define INTERP_RGB 1
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);

#define RENDER_SPAN( span ) {					\
   GLint x = span.x, y = YFLIP(xrb, span.y);			\
   GLuint i;							\
   for (i = 0; i < span.end; i++, x++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
         unsigned long p;					\
         PACK_TRUECOLOR(p, FixedToInt(span.red),		\
            FixedToInt(span.green), FixedToInt(span.blue));	\
         XMesaPutPixel(xrb->ximage, x, y, p);			\
         zRow[i] = z;						\
      }								\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
      span.z += span.zStep;					\
   } }

#include "swrast/s_tritemp.h"




/*
 * XImage, smooth, depth-buffered, PF_8A8B8G8R triangle.
 */
#define NAME smooth_8A8B8G8R_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR4(xrb, X, Y)
#define PIXEL_TYPE GLuint
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   for (i = 0; i < span.end; i++) {				\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
         pRow[i] = PACK_8A8B8G8R(FixedToInt(span.red),		\
            FixedToInt(span.green), FixedToInt(span.blue),	\
            FixedToInt(span.alpha));				\
         zRow[i] = z;						\
      }								\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
      span.alpha += span.alphaStep;				\
      span.z += span.zStep;					\
   } }

#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, depth-buffered, PF_8A8R8G8B triangle.
 */
#define NAME smooth_8A8R8G8B_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR4(xrb, X, Y)
#define PIXEL_TYPE GLuint
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   GET_XRB(xrb);

#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   for (i = 0; i < span.end; i++) {				\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
         pRow[i] = PACK_8A8R8G8B(FixedToInt(span.red),		\
            FixedToInt(span.green), FixedToInt(span.blue),	\
            FixedToInt(span.alpha));				\
         zRow[i] = z;						\
      }								\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
      span.alpha += span.alphaStep;				\
      span.z += span.zStep;					\
   } }

#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, depth-buffered, PF_8R8G8B triangle.
 */
#define NAME smooth_8R8G8B_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define INTERP_RGB 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR4(xrb, X, Y)
#define PIXEL_TYPE GLuint
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   GET_XRB(xrb);

#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   for (i = 0; i < span.end; i++) {				\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
         pRow[i] = PACK_8R8G8B(FixedToInt(span.red),		\
            FixedToInt(span.green), FixedToInt(span.blue));	\
         zRow[i] = z;						\
      }								\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
      span.z += span.zStep;					\
   } }

#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, depth-buffered, PF_8R8G8B24 triangle.
 */
#define NAME smooth_8R8G8B24_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define INTERP_RGB 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR3(xrb, X, Y)
#define PIXEL_TYPE bgr_t
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   for (i = 0; i < span.end; i++) {				\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
	 PIXEL_TYPE *ptr = pRow + i;				\
         ptr->r = FixedToInt(span.red);				\
         ptr->g = FixedToInt(span.green);			\
         ptr->b = FixedToInt(span.blue);			\
         zRow[i] = z;						\
      }								\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
      span.z += span.zStep;					\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, depth-buffered, PF_TRUEDITHER triangle.
 */
#define NAME smooth_TRUEDITHER_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define INTERP_RGB 1
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);			\
   for (i = 0; i < span.end; i++, x++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
         unsigned long p;					\
         PACK_TRUEDITHER(p, x, y, FixedToInt(span.red),		\
            FixedToInt(span.green), FixedToInt(span.blue));	\
         XMesaPutPixel(xrb->ximage, x, y, p);			\
         zRow[i] = z;						\
      }								\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
      span.z += span.zStep;					\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, depth-buffered, PF_5R6G5B triangle.
 */
#define NAME smooth_5R6G5B_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define INTERP_RGB 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR2(xrb, X, Y)
#define PIXEL_TYPE GLushort
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   for (i = 0; i < span.end; i++) {				\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
         pRow[i] = PACK_5R6G5B(FixedToInt(span.red),		\
            FixedToInt(span.green), FixedToInt(span.blue));	\
         zRow[i] = z;						\
      }								\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
      span.z += span.zStep;					\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, depth-buffered, PF_DITHER_5R6G5B triangle.
 */
#define NAME smooth_DITHER_5R6G5B_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define INTERP_RGB 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR2(xrb, X, Y)
#define PIXEL_TYPE GLushort
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);			\
   for (i = 0; i < span.end; i++, x++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
         PACK_TRUEDITHER(pRow[i], x, y, FixedToInt(span.red),	\
            FixedToInt(span.green), FixedToInt(span.blue));	\
         zRow[i] = z;						\
      }								\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
      span.z += span.zStep;					\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, depth-buffered, PF_TRUECOLOR triangle.
 */
#define NAME flat_TRUECOLOR_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);						\
   XMesaImage *img = xrb->ximage;				\
   unsigned long pixel;						\
   PACK_TRUECOLOR(pixel, v2->color[0], v2->color[1], v2->color[2]);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);			\
   for (i = 0; i < span.end; i++, x++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
         XMesaPutPixel(img, x, y, pixel);			\
         zRow[i] = z;						\
      }								\
      span.z += span.zStep;					\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, depth-buffered, PF_8A8B8G8R triangle.
 */
#define NAME flat_8A8B8G8R_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR4(xrb, X, Y)
#define PIXEL_TYPE GLuint
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE					\
   GET_XRB(xrb);					\
   GLuint p = PACK_8A8B8G8R( v2->color[0], v2->color[1],\
                             v2->color[2], v2->color[3]);
#define RENDER_SPAN( span ) {				\
   GLuint i;						\
   for (i = 0; i < span.end; i++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);	\
      if (z < zRow[i]) {				\
	 pRow[i] = (PIXEL_TYPE) p;			\
         zRow[i] = z;					\
      }							\
      span.z += span.zStep;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, depth-buffered, PF_8A8R8G8B triangle.
 */
#define NAME flat_8A8R8G8B_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR4(xrb, X, Y)
#define PIXEL_TYPE GLuint
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE					\
   GET_XRB(xrb);					\
   GLuint p = PACK_8A8R8G8B(v2->color[0], v2->color[1],	\
                            v2->color[2], v2->color[3]);
#define RENDER_SPAN( span ) {				\
   GLuint i;						\
   for (i = 0; i < span.end; i++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);	\
      if (z < zRow[i]) {				\
	 pRow[i] = (PIXEL_TYPE) p;			\
         zRow[i] = z;					\
      }							\
      span.z += span.zStep;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, depth-buffered, PF_8R8G8B triangle.
 */
#define NAME flat_8R8G8B_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR4(xrb, X, Y)
#define PIXEL_TYPE GLuint
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE					\
   GET_XRB(xrb);					\
   GLuint p = PACK_8R8G8B( v2->color[0], v2->color[1], v2->color[2] );
#define RENDER_SPAN( span ) {			\
   GLuint i;					\
   for (i = 0; i < span.end; i++) {		\
      DEPTH_TYPE z = FixedToDepth(span.z);	\
      if (z < zRow[i]) {			\
	 pRow[i] = (PIXEL_TYPE) p;		\
         zRow[i] = z;				\
      }						\
      span.z += span.zStep;			\
   } }

#include "swrast/s_tritemp.h"



/*
 * XImage, flat, depth-buffered, PF_8R8G8B24 triangle.
 */
#define NAME flat_8R8G8B24_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR3(xrb, X, Y)
#define PIXEL_TYPE bgr_t
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE					\
   GET_XRB(xrb);					\
   const GLubyte *color = v2->color;
#define RENDER_SPAN( span ) {				\
   GLuint i;						\
   for (i = 0; i < span.end; i++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);	\
      if (z < zRow[i]) {				\
	 PIXEL_TYPE *ptr = pRow + i;			\
         ptr->r = color[RCOMP];				\
         ptr->g = color[GCOMP];				\
         ptr->b = color[BCOMP];				\
         zRow[i] = z;					\
      }							\
      span.z += span.zStep;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, depth-buffered, PF_TRUEDITHER triangle.
 */
#define NAME flat_TRUEDITHER_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);						\
   XMesaImage *img = xrb->ximage;
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);			\
   for (i = 0; i < span.end; i++, x++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
         unsigned long p;					\
         PACK_TRUEDITHER(p, x, y, v2->color[0],			\
            v2->color[1], v2->color[2]);			\
         XMesaPutPixel(img, x, y, p);				\
         zRow[i] = z;						\
      }								\
      span.z += span.zStep;					\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, depth-buffered, PF_5R6G5B triangle.
 */
#define NAME flat_5R6G5B_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR2(xrb, X, Y)
#define PIXEL_TYPE GLushort
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE					\
   GET_XRB(xrb);					\
   GLushort p = PACK_5R6G5B( v2->color[0], v2->color[1], v2->color[2] );
#define RENDER_SPAN( span ) {				\
   GLuint i;						\
   for (i = 0; i < span.end; i++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);	\
      if (z < zRow[i]) {				\
	 pRow[i] = (PIXEL_TYPE) p;			\
         zRow[i] = z;					\
      }							\
      span.z += span.zStep;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, depth-buffered, PF_DITHER_5R6G5B triangle.
 */
#define NAME flat_DITHER_5R6G5B_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR2(xrb, X, Y)
#define PIXEL_TYPE GLushort
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);						\
   const GLubyte *color = v2->color;
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);			\
   for (i = 0; i < span.end; i++, x++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
	 PACK_TRUEDITHER(pRow[i], x, y, color[RCOMP],		\
			 color[GCOMP], color[BCOMP]);		\
         zRow[i] = z;						\
      }								\
      span.z += span.zStep;					\
   } }
#include "swrast/s_tritemp.h"


/*
 * XImage, smooth, NON-depth-buffered, PF_TRUECOLOR triangle.
 */
#define NAME smooth_TRUECOLOR_triangle
#define INTERP_RGB 1
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);						\
   XMesaImage *img = xrb->ximage;
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);	\
   for (i = 0; i < span.end; i++, x++) {			\
      unsigned long p;						\
      PACK_TRUECOLOR(p, FixedToInt(span.red),			\
         FixedToInt(span.green), FixedToInt(span.blue));	\
      XMesaPutPixel(img, x, y, p);				\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, NON-depth-buffered, PF_8A8B8G8R triangle.
 */
#define NAME smooth_8A8B8G8R_triangle
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR4(xrb, X, Y)
#define PIXEL_TYPE GLuint
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   for (i = 0; i < span.end; i++) {				\
      pRow[i] = PACK_8A8B8G8R(FixedToInt(span.red),		\
         FixedToInt(span.green), FixedToInt(span.blue),		\
         FixedToInt(span.alpha));				\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
      span.alpha += span.alphaStep;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, NON-depth-buffered, PF_8A8R8G8B triangle.
 */
#define NAME smooth_8A8R8G8B_triangle
#define INTERP_RGB 1
#define INTERP_ALPHA 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR4(xrb, X, Y)
#define PIXEL_TYPE GLuint
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   for (i = 0; i < span.end; i++) {				\
      pRow[i] = PACK_8A8R8G8B(FixedToInt(span.red),		\
         FixedToInt(span.green), FixedToInt(span.blue),		\
         FixedToInt(span.alpha));				\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
      span.alpha += span.alphaStep;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, NON-depth-buffered, PF_8R8G8B triangle.
 */
#define NAME smooth_8R8G8B_triangle
#define INTERP_RGB 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR4(xrb, X, Y)
#define PIXEL_TYPE GLuint
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   for (i = 0; i < span.end; i++) {				\
      pRow[i] = PACK_8R8G8B(FixedToInt(span.red),		\
         FixedToInt(span.green), FixedToInt(span.blue) );	\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, NON-depth-buffered, PF_8R8G8B triangle.
 */
#define NAME smooth_8R8G8B24_triangle
#define INTERP_RGB 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR3(xrb, X, Y)
#define PIXEL_TYPE bgr_t
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE					\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {				\
   GLuint i;						\
   PIXEL_TYPE *pixel = pRow;				\
   for (i = 0; i < span.end; i++, pixel++) {		\
      pixel->r = FixedToInt(span.red);			\
      pixel->g = FixedToInt(span.green);		\
      pixel->b = FixedToInt(span.blue);			\
      span.red += span.redStep;				\
      span.green += span.greenStep;			\
      span.blue += span.blueStep;			\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, NON-depth-buffered, PF_TRUEDITHER triangle.
 */
#define NAME smooth_TRUEDITHER_triangle
#define INTERP_RGB 1
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);						\
   XMesaImage *img = xrb->ximage;
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);	\
   for (i = 0; i < span.end; i++, x++) {			\
      unsigned long p;						\
      PACK_TRUEDITHER(p, x, y, FixedToInt(span.red),		\
         FixedToInt(span.green), FixedToInt(span.blue));	\
      XMesaPutPixel(img, x, y, p );				\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, NON-depth-buffered, PF_5R6G5B triangle.
 */
#define NAME smooth_5R6G5B_triangle
#define INTERP_RGB 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR2(xrb, X, Y)
#define PIXEL_TYPE GLushort
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   for (i = 0; i < span.end; i++) {				\
      pRow[i] = (PIXEL_TYPE) PACK_5R6G5B(FixedToInt(span.red),	\
         FixedToInt(span.green), FixedToInt(span.blue));	\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, NON-depth-buffered, PF_DITHER_5R6G5B triangle.
 */
#define NAME smooth_DITHER_5R6G5B_triangle
#define INTERP_RGB 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR2(xrb, X, Y)
#define PIXEL_TYPE GLushort
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);	\
   for (i = 0; i < span.end; i++, x++) {			\
      PACK_TRUEDITHER(pRow[i], x, y, FixedToInt(span.red),	\
         FixedToInt(span.green), FixedToInt(span.blue));	\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, NON-depth-buffered, PF_TRUECOLOR triangle.
 */
#define NAME flat_TRUECOLOR_triangle
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);						\
   XMesaImage *img = xrb->ximage;				\
   unsigned long pixel;						\
   PACK_TRUECOLOR(pixel, v2->color[0], v2->color[1], v2->color[2]);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);	\
   for (i = 0; i < span.end; i++, x++) {			\
      XMesaPutPixel(img, x, y, pixel);				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, NON-depth-buffered, PF_8A8B8G8R triangle.
 */
#define NAME flat_8A8B8G8R_triangle
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR4(xrb, X, Y)
#define PIXEL_TYPE GLuint
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE					\
   GET_XRB(xrb);					\
   unsigned long p = PACK_8B8G8R( v2->color[0],		\
		 v2->color[1], v2->color[2] );
#define RENDER_SPAN( span ) {				\
   GLuint i;						\
   for (i = 0; i < span.end; i++) {			\
      pRow[i] = (PIXEL_TYPE) p;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, NON-depth-buffered, PF_8A8R8G8B triangle.
 */
#define NAME flat_8A8R8G8B_triangle
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR4(xrb, X, Y)
#define PIXEL_TYPE GLuint
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE					\
   GET_XRB(xrb);					\
   unsigned long p = PACK_8R8G8B( v2->color[0],		\
		 v2->color[1], v2->color[2] );
#define RENDER_SPAN( span ) {				\
   GLuint i;						\
   for (i = 0; i < span.end; i++) {			\
      pRow[i] = (PIXEL_TYPE) p;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, NON-depth-buffered, PF_8R8G8B triangle.
 */
#define NAME flat_8R8G8B_triangle
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR4(xrb, X, Y)
#define PIXEL_TYPE GLuint
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE					\
   GET_XRB(xrb);					\
   unsigned long p = PACK_8R8G8B( v2->color[0],		\
		 v2->color[1], v2->color[2] );
#define RENDER_SPAN( span ) {				\
   GLuint i;						\
   for (i = 0; i < span.end; i++) {			\
      pRow[i] = (PIXEL_TYPE) p;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, NON-depth-buffered, PF_8R8G8B24 triangle.
 */
#define NAME flat_8R8G8B24_triangle
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR3(xrb, X, Y)
#define PIXEL_TYPE bgr_t
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE					\
   GET_XRB(xrb);					\
   const GLubyte *color = v2->color;
#define RENDER_SPAN( span ) {				\
   GLuint i;						\
   PIXEL_TYPE *pixel = pRow;				\
   for (i = 0; i < span.end; i++, pixel++) {		\
      pixel->r = color[RCOMP];				\
      pixel->g = color[GCOMP];				\
      pixel->b = color[BCOMP];				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, NON-depth-buffered, PF_TRUEDITHER triangle.
 */
#define NAME flat_TRUEDITHER_triangle
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);						\
   XMesaImage *img = xrb->ximage;
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);	\
   for (i = 0; i < span.end; i++, x++) {			\
      unsigned long p;						\
      PACK_TRUEDITHER(p, x, y, v2->color[0],			\
               v2->color[1], v2->color[2] );			\
      XMesaPutPixel(img, x, y, p);				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, NON-depth-buffered, PF_5R6G5B triangle.
 */
#define NAME flat_5R6G5B_triangle
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR2(xrb, X, Y)
#define PIXEL_TYPE GLushort
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE					\
   GET_XRB(xrb);					\
   unsigned long p = PACK_5R6G5B( v2->color[0],		\
		 v2->color[1], v2->color[2] );
#define RENDER_SPAN( span ) {				\
   GLuint i;						\
   for (i = 0; i < span.end; i++) {			\
      pRow[i] = (PIXEL_TYPE) p;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, NON-depth-buffered, PF_DITHER_5R6G5B triangle.
 */
#define NAME flat_DITHER_5R6G5B_triangle
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR2(xrb, X, Y)
#define PIXEL_TYPE GLushort
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);						\
   const GLubyte *color = v2->color;
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);	\
   for (i = 0; i < span.end; i++, x++) {			\
      PACK_TRUEDITHER(pRow[i], x, y, color[RCOMP],		\
         color[GCOMP], color[BCOMP]);				\
   } }
#include "swrast/s_tritemp.h"



#endif /* CHAN_BITS == 8 */


#if defined(DEBUG) && CHAN_BITS == 8
extern void _xmesa_print_triangle_func( swrast_tri_func triFunc );
void _xmesa_print_triangle_func( swrast_tri_func triFunc )
{
   printf("XMesa tri func = ");
   if (triFunc ==smooth_TRUECOLOR_z_triangle)
      printf("smooth_TRUECOLOR_z_triangle\n");
   else if (triFunc ==smooth_8A8B8G8R_z_triangle)
      printf("smooth_8A8B8G8R_z_triangle\n");
   else if (triFunc ==smooth_8A8R8G8B_z_triangle)
      printf("smooth_8A8R8G8B_z_triangle\n");
   else if (triFunc ==smooth_8R8G8B_z_triangle)
      printf("smooth_8R8G8B_z_triangle\n");
   else if (triFunc ==smooth_8R8G8B24_z_triangle)
      printf("smooth_8R8G8B24_z_triangle\n");
   else if (triFunc ==smooth_TRUEDITHER_z_triangle)
      printf("smooth_TRUEDITHER_z_triangle\n");
   else if (triFunc ==smooth_5R6G5B_z_triangle)
      printf("smooth_5R6G5B_z_triangle\n");
   else if (triFunc ==smooth_DITHER_5R6G5B_z_triangle)
      printf("smooth_DITHER_5R6G5B_z_triangle\n");
   else if (triFunc ==flat_TRUECOLOR_z_triangle)
      printf("flat_TRUECOLOR_z_triangle\n");
   else if (triFunc ==flat_8A8B8G8R_z_triangle)
      printf("flat_8A8B8G8R_z_triangle\n");
   else if (triFunc ==flat_8A8R8G8B_z_triangle)
      printf("flat_8A8R8G8B_z_triangle\n");
   else if (triFunc ==flat_8R8G8B_z_triangle)
      printf("flat_8R8G8B_z_triangle\n");
   else if (triFunc ==flat_8R8G8B24_z_triangle)
      printf("flat_8R8G8B24_z_triangle\n");
   else if (triFunc ==flat_TRUEDITHER_z_triangle)
      printf("flat_TRUEDITHER_z_triangle\n");
   else if (triFunc ==flat_5R6G5B_z_triangle)
      printf("flat_5R6G5B_z_triangle\n");
   else if (triFunc ==flat_DITHER_5R6G5B_z_triangle)
      printf("flat_DITHER_5R6G5B_z_triangle\n");
   else if (triFunc ==smooth_TRUECOLOR_triangle)
      printf("smooth_TRUECOLOR_triangle\n");
   else if (triFunc ==smooth_8A8B8G8R_triangle)
      printf("smooth_8A8B8G8R_triangle\n");
   else if (triFunc ==smooth_8A8R8G8B_triangle)
      printf("smooth_8A8R8G8B_triangle\n");
   else if (triFunc ==smooth_8R8G8B_triangle)
      printf("smooth_8R8G8B_triangle\n");
   else if (triFunc ==smooth_8R8G8B24_triangle)
      printf("smooth_8R8G8B24_triangle\n");
   else if (triFunc ==smooth_TRUEDITHER_triangle)
      printf("smooth_TRUEDITHER_triangle\n");
   else if (triFunc ==smooth_5R6G5B_triangle)
      printf("smooth_5R6G5B_triangle\n");
   else if (triFunc ==smooth_DITHER_5R6G5B_triangle)
      printf("smooth_DITHER_5R6G5B_triangle\n");
   else if (triFunc ==flat_TRUECOLOR_triangle)
      printf("flat_TRUECOLOR_triangle\n");
   else if (triFunc ==flat_TRUEDITHER_triangle)
      printf("flat_TRUEDITHER_triangle\n");
   else if (triFunc ==flat_8A8B8G8R_triangle)
      printf("flat_8A8B8G8R_triangle\n");
   else if (triFunc ==flat_8A8R8G8B_triangle)
      printf("flat_8A8R8G8B_triangle\n");
   else if (triFunc ==flat_8R8G8B_triangle)
      printf("flat_8R8G8B_triangle\n");
   else if (triFunc ==flat_8R8G8B24_triangle)
      printf("flat_8R8G8B24_triangle\n");
   else if (triFunc ==flat_5R6G5B_triangle)
      printf("flat_5R6G5B_triangle\n");
   else if (triFunc ==flat_DITHER_5R6G5B_triangle)
      printf("flat_DITHER_5R6G5B_triangle\n");
   else
      printf("???\n");
}
#endif


#ifdef DEBUG

/* record the current triangle function name */
static const char *triFuncName = NULL;

#define USE(triFunc)                   \
do {                                   \
    triFuncName = #triFunc;            \
    return triFunc;                    \
} while (0)

#else

#define USE(triFunc)  return triFunc

#endif


/**
 * Return pointer to line drawing function, or NULL if we should use a
 * swrast fallback.
 */
static swrast_tri_func
get_triangle_func(struct gl_context *ctx)
{
#if CHAN_BITS == 8
   SWcontext *swrast = SWRAST_CONTEXT(ctx);
   XMesaContext xmesa = XMESA_CONTEXT(ctx);
   const struct xmesa_renderbuffer *xrb;

#ifdef DEBUG
   triFuncName = NULL;
#endif

   /* trivial fallback tests */
   if ((ctx->DrawBuffer->_ColorDrawBufferIndexes[0] != BUFFER_BIT_FRONT_LEFT) &&
       (ctx->DrawBuffer->_ColorDrawBufferIndexes[0] != BUFFER_BIT_BACK_LEFT))
      return (swrast_tri_func) NULL;
   if (ctx->RenderMode != GL_RENDER)
      return (swrast_tri_func) NULL;
   if (ctx->Polygon.SmoothFlag)
      return (swrast_tri_func) NULL;
   if (ctx->Texture._MaxEnabledTexImageUnit != -1)
      return (swrast_tri_func) NULL;
   if (swrast->_RasterMask & MULTI_DRAW_BIT)
      return (swrast_tri_func) NULL;
   if (ctx->Polygon.CullFlag && 
       ctx->Polygon.CullFaceMode == GL_FRONT_AND_BACK)
      return (swrast_tri_func) NULL;

   xrb = xmesa_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0]);

   if (xrb->ximage) {
      if (   ctx->Light.ShadeModel==GL_SMOOTH
          && swrast->_RasterMask==DEPTH_BIT
          && ctx->Depth.Func==GL_LESS
          && ctx->Depth.Mask==GL_TRUE
          && ctx->Visual.depthBits == DEFAULT_SOFTWARE_DEPTH_BITS
          && ctx->Polygon.StippleFlag==GL_FALSE) {
         switch (xmesa->pixelformat) {
            case PF_Truecolor:
	       USE(smooth_TRUECOLOR_z_triangle);
            case PF_8A8B8G8R:
               USE(smooth_8A8B8G8R_z_triangle);
            case PF_8A8R8G8B:
               USE(smooth_8A8R8G8B_z_triangle);
            case PF_8R8G8B:
               USE(smooth_8R8G8B_z_triangle);
            case PF_8R8G8B24:
               USE(smooth_8R8G8B24_z_triangle);
            case PF_Dither_True:
               USE(smooth_TRUEDITHER_z_triangle);
            case PF_5R6G5B:
               USE(smooth_5R6G5B_z_triangle);
            case PF_Dither_5R6G5B:
               USE(smooth_DITHER_5R6G5B_z_triangle);
            default:
               return (swrast_tri_func) NULL;
         }
      }
      if (   ctx->Light.ShadeModel==GL_FLAT
          && swrast->_RasterMask==DEPTH_BIT
          && ctx->Depth.Func==GL_LESS
          && ctx->Depth.Mask==GL_TRUE
          && ctx->Visual.depthBits == DEFAULT_SOFTWARE_DEPTH_BITS
          && ctx->Polygon.StippleFlag==GL_FALSE) {
         switch (xmesa->pixelformat) {
            case PF_Truecolor:
	       USE(flat_TRUECOLOR_z_triangle);
            case PF_8A8B8G8R:
               USE(flat_8A8B8G8R_z_triangle);
            case PF_8A8R8G8B:
               USE(flat_8A8R8G8B_z_triangle);
            case PF_8R8G8B:
               USE(flat_8R8G8B_z_triangle);
            case PF_8R8G8B24:
               USE(flat_8R8G8B24_z_triangle);
            case PF_Dither_True:
               USE(flat_TRUEDITHER_z_triangle);
            case PF_5R6G5B:
               USE(flat_5R6G5B_z_triangle);
            case PF_Dither_5R6G5B:
               USE(flat_DITHER_5R6G5B_z_triangle);
            default:
               return (swrast_tri_func) NULL;
         }
      }
      if (   swrast->_RasterMask==0   /* no depth test */
          && ctx->Light.ShadeModel==GL_SMOOTH
          && ctx->Polygon.StippleFlag==GL_FALSE) {
         switch (xmesa->pixelformat) {
            case PF_Truecolor:
	       USE(smooth_TRUECOLOR_triangle);
            case PF_8A8B8G8R:
               USE(smooth_8A8B8G8R_triangle);
            case PF_8A8R8G8B:
               USE(smooth_8A8R8G8B_triangle);
            case PF_8R8G8B:
               USE(smooth_8R8G8B_triangle);
            case PF_8R8G8B24:
               USE(smooth_8R8G8B24_triangle);
            case PF_Dither_True:
               USE(smooth_TRUEDITHER_triangle);
            case PF_5R6G5B:
               USE(smooth_5R6G5B_triangle);
            case PF_Dither_5R6G5B:
               USE(smooth_DITHER_5R6G5B_triangle);
            default:
               return (swrast_tri_func) NULL;
         }
      }

      if (   swrast->_RasterMask==0   /* no depth test */
          && ctx->Light.ShadeModel==GL_FLAT
          && ctx->Polygon.StippleFlag==GL_FALSE) {
         switch (xmesa->pixelformat) {
            case PF_Truecolor:
	       USE(flat_TRUECOLOR_triangle);
            case PF_Dither_True:
	       USE(flat_TRUEDITHER_triangle);
            case PF_8A8B8G8R:
               USE(flat_8A8B8G8R_triangle);
            case PF_8A8R8G8B:
               USE(flat_8A8R8G8B_triangle);
            case PF_8R8G8B:
               USE(flat_8R8G8B_triangle);
            case PF_8R8G8B24:
               USE(flat_8R8G8B24_triangle);
            case PF_5R6G5B:
               USE(flat_5R6G5B_triangle);
            case PF_Dither_5R6G5B:
               USE(flat_DITHER_5R6G5B_triangle);
            default:
               return (swrast_tri_func) NULL;
         }
      }
   }
#endif /* CHAN_BITS == 8 */

   return (swrast_tri_func) NULL;
}


/* Override for the swrast tri-selection function.  Try to use one
 * of our internal tri functions, otherwise fall back to the
 * standard swrast functions.
 */
void xmesa_choose_triangle( struct gl_context *ctx )
{
   SWcontext *swrast = SWRAST_CONTEXT(ctx);

   if (!(swrast->Triangle = get_triangle_func( ctx )))
      _swrast_choose_triangle( ctx );
}

@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@d1018 1
a1018 1
   if (ctx->Texture._EnabledUnits)
@


1.5
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  6.5
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
a32 2
#include "main/depth.h"
#include "main/macros.h"
d46 1
a46 1
   xmesa_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0]->Wrapped)
a316 126
 * XImage, smooth, depth-buffered, 8-bit, PF_DITHER8 triangle.
 */
#define NAME smooth_DITHER8_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define INTERP_RGB 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR1(xrb, X, Y)
#define PIXEL_TYPE GLubyte
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);			\
   XDITHER_SETUP(y);						\
   for (i = 0; i < span.end; i++, x++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
         pRow[i] = (PIXEL_TYPE) XDITHER(x, FixedToInt(span.red),\
            FixedToInt(span.green), FixedToInt(span.blue) );	\
         zRow[i] = z;						\
      }								\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
      span.z += span.zStep;					\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, depth-buffered, PF_DITHER triangle.
 */
#define NAME smooth_DITHER_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define INTERP_RGB 1
#define SETUP_CODE						\
   GET_XRB(xrb);						\
   XMesaImage *img = xrb->ximage;
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);			\
   XDITHER_SETUP(y);						\
   for (i = 0; i < span.end; i++, x++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
         unsigned long p = XDITHER(x, FixedToInt(span.red),	\
            FixedToInt(span.green), FixedToInt(span.blue));	\
	 XMesaPutPixel(img, x, y, p);			       	\
         zRow[i] = z;						\
      }								\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
      span.z += span.zStep;					\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, depth-buffered, 8-bit PF_LOOKUP triangle.
 */
#define NAME smooth_LOOKUP8_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define INTERP_RGB 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR1(xrb, X, Y)
#define PIXEL_TYPE GLubyte
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   LOOKUP_SETUP;						\
   for (i = 0; i < span.end; i++) {				\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
         pRow[i] = LOOKUP(FixedToInt(span.red),			\
            FixedToInt(span.green), FixedToInt(span.blue));	\
         zRow[i] = z;						\
      }								\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
      span.z += span.zStep;					\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, depth-buffered, 8-bit PF_HPCR triangle.
 */
#define NAME smooth_HPCR_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define INTERP_RGB 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR1(xrb, X, Y)
#define PIXEL_TYPE GLubyte
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);			\
   for (i = 0; i < span.end; i++, x++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
         pRow[i] = DITHER_HPCR(x, y, FixedToInt(span.red),	\
            FixedToInt(span.green), FixedToInt(span.blue) );	\
         zRow[i] = z;						\
      }								\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
      span.z += span.zStep;					\
   } }
#include "swrast/s_tritemp.h"



/*
a534 116

/*
 * XImage, flat, depth-buffered, 8-bit PF_DITHER triangle.
 */
#define NAME flat_DITHER8_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR1(xrb, X, Y)
#define PIXEL_TYPE GLubyte
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   GET_XRB(xrb);						\
   FLAT_DITHER_SETUP( v2->color[0], v2->color[1], v2->color[2] );
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);			\
   FLAT_DITHER_ROW_SETUP(YFLIP(xrb, y));			\
   for (i = 0; i < span.end; i++, x++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
	 pRow[i] = (PIXEL_TYPE) FLAT_DITHER(x);			\
         zRow[i] = z;						\
      }								\
      span.z += span.zStep;					\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, depth-buffered, PF_DITHER triangle.
 */
#define NAME flat_DITHER_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define SETUP_CODE						\
   GET_XRB(xrb);					\
   XMesaImage *img = xrb->ximage;		\
   FLAT_DITHER_SETUP( v2->color[0], v2->color[1], v2->color[2] );
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);	\
   FLAT_DITHER_ROW_SETUP(y);					\
   for (i = 0; i < span.end; i++, x++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
         unsigned long p = FLAT_DITHER(x);			\
	 XMesaPutPixel(img, x, y, p);				\
         zRow[i] = z;						\
      }								\
      span.z += span.zStep;					\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, depth-buffered, 8-bit PF_HPCR triangle.
 */
#define NAME flat_HPCR_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR1(xrb, X, Y)
#define PIXEL_TYPE GLubyte
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);						\
   GLubyte r = v2->color[0];					\
   GLubyte g = v2->color[1];					\
   GLubyte b = v2->color[2];
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);	\
   for (i = 0; i < span.end; i++, x++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);		\
      if (z < zRow[i]) {					\
	 pRow[i] = (PIXEL_TYPE) DITHER_HPCR(x, y, r, g, b);	\
         zRow[i] = z;						\
      }								\
      span.z += span.zStep;					\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, depth-buffered, 8-bit PF_LOOKUP triangle.
 */
#define NAME flat_LOOKUP8_z_triangle
#define INTERP_Z 1
#define DEPTH_TYPE DEFAULT_SOFTWARE_DEPTH_TYPE
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR1(xrb, X, Y)
#define PIXEL_TYPE GLubyte
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE					\
   GET_XRB(xrb);					\
   LOOKUP_SETUP;					\
   GLubyte r = v2->color[0];				\
   GLubyte g = v2->color[1];				\
   GLubyte b = v2->color[2];				\
   GLubyte p = LOOKUP(r,g,b);
#define RENDER_SPAN( span ) {				\
   GLuint i;						\
   for (i = 0; i < span.end; i++) {			\
      const DEPTH_TYPE z = FixedToDepth(span.z);	\
      if (z < zRow[i]) {				\
	 pRow[i] = p;					\
         zRow[i] = z;					\
      }							\
      span.z += span.zStep;				\
   } }
#include "swrast/s_tritemp.h"



a733 98
 * XImage, smooth, NON-depth-buffered, 8-bit PF_DITHER triangle.
 */
#define NAME smooth_DITHER8_triangle
#define INTERP_RGB 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR1(xrb, X, Y)
#define PIXEL_TYPE GLubyte
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);	\
   XDITHER_SETUP(y);						\
   for (i = 0; i < span.end; i++, x++) {			\
      pRow[i] = (PIXEL_TYPE) XDITHER(x, FixedToInt(span.red),	\
         FixedToInt(span.green), FixedToInt(span.blue) );	\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, NON-depth-buffered, PF_DITHER triangle.
 */
#define NAME smooth_DITHER_triangle
#define INTERP_RGB 1
#define SETUP_CODE						\
   GET_XRB(xrb);						\
   XMesaImage *img = xrb->ximage;
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);	\
   XDITHER_SETUP(y);						\
   for (i = 0; i < span.end; i++, x++) {			\
      unsigned long p = XDITHER(x, FixedToInt(span.red),	\
         FixedToInt(span.green), FixedToInt(span.blue) );	\
      XMesaPutPixel(img, x, y, p);				\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, NON-depth-buffered, 8-bit PF_LOOKUP triangle.
 */
#define NAME smooth_LOOKUP8_triangle
#define INTERP_RGB 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR1(xrb, X, Y)
#define PIXEL_TYPE GLubyte
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   LOOKUP_SETUP;						\
   for (i = 0; i < span.end; i++) {				\
      pRow[i] = LOOKUP(FixedToInt(span.red),			\
         FixedToInt(span.green), FixedToInt(span.blue));	\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, smooth, NON-depth-buffered, 8-bit PF_HPCR triangle.
 */
#define NAME smooth_HPCR_triangle
#define INTERP_RGB 1
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR1(xrb, X, Y)
#define PIXEL_TYPE GLubyte
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);	\
   for (i = 0; i < span.end; i++, x++) {			\
      pRow[i] = DITHER_HPCR(x, y, FixedToInt(span.red),		\
         FixedToInt(span.green), FixedToInt(span.blue));	\
      span.red += span.redStep;					\
      span.green += span.greenStep;				\
      span.blue += span.blueStep;				\
   } }
#include "swrast/s_tritemp.h"



/*
a897 86
/*
 * XImage, flat, NON-depth-buffered, 8-bit PF_DITHER triangle.
 */
#define NAME flat_DITHER8_triangle
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR1(xrb, X, Y)
#define PIXEL_TYPE GLubyte
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   GET_XRB(xrb);						\
   FLAT_DITHER_SETUP( v2->color[0], v2->color[1], v2->color[2] );
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);	\
   FLAT_DITHER_ROW_SETUP(YFLIP(xrb, y));		\
   for (i = 0; i < span.end; i++, x++) {			\
      pRow[i] = (PIXEL_TYPE) FLAT_DITHER(x);			\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, NON-depth-buffered, PF_DITHER triangle.
 */
#define NAME flat_DITHER_triangle
#define SETUP_CODE						\
   GET_XRB(xrb);						\
   XMesaImage *img = xrb->ximage;				\
   FLAT_DITHER_SETUP( v2->color[0], v2->color[1], v2->color[2] );
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);	\
   FLAT_DITHER_ROW_SETUP(y);					\
   for (i = 0; i < span.end; i++, x++) {			\
      unsigned long p = FLAT_DITHER(x);				\
      XMesaPutPixel(img, x, y, p );				\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, NON-depth-buffered, 8-bit PF_HPCR triangle.
 */
#define NAME flat_HPCR_triangle
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR1(xrb, X, Y)
#define PIXEL_TYPE GLubyte
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE						\
   XMesaContext xmesa = XMESA_CONTEXT(ctx);			\
   GET_XRB(xrb);						\
   GLubyte r = v2->color[0];					\
   GLubyte g = v2->color[1];					\
   GLubyte b = v2->color[2];
#define RENDER_SPAN( span ) {					\
   GLuint i;							\
   GLint x = span.x, y = YFLIP(xrb, span.y);	\
   for (i = 0; i < span.end; i++, x++) {			\
      pRow[i] = (PIXEL_TYPE) DITHER_HPCR(x, y, r, g, b);	\
   } }
#include "swrast/s_tritemp.h"



/*
 * XImage, flat, NON-depth-buffered, 8-bit PF_LOOKUP triangle.
 */
#define NAME flat_LOOKUP8_triangle
#define PIXEL_ADDRESS(X,Y) PIXEL_ADDR1(xrb, X, Y)
#define PIXEL_TYPE GLubyte
#define BYTES_PER_ROW (xrb->ximage->bytes_per_line)
#define SETUP_CODE					\
   GET_XRB(xrb);					\
   LOOKUP_SETUP;					\
   GLubyte r = v2->color[0];				\
   GLubyte g = v2->color[1];				\
   GLubyte b = v2->color[2];				\
   GLubyte p = LOOKUP(r,g,b);
#define RENDER_SPAN( span ) {         	 		\
   GLuint i;						\
   for (i = 0; i < span.end; i++) {			\
      pRow[i] = (PIXEL_TYPE) p;				\
   } }
#include "swrast/s_tritemp.h"


a921 6
   else if (triFunc ==smooth_HPCR_z_triangle)
      printf("smooth_HPCR_z_triangle\n");
   else if (triFunc ==smooth_DITHER8_z_triangle)
      printf("smooth_DITHER8_z_triangle\n");
   else if (triFunc ==smooth_LOOKUP8_z_triangle)
      printf("smooth_LOOKUP8_z_triangle\n");
a937 6
   else if (triFunc ==flat_HPCR_z_triangle)
      printf("flat_HPCR_z_triangle\n");
   else if (triFunc ==flat_DITHER8_z_triangle)
      printf("flat_DITHER8_z_triangle\n");
   else if (triFunc ==flat_LOOKUP8_z_triangle)
      printf("flat_LOOKUP8_z_triangle\n");
a953 6
   else if (triFunc ==smooth_HPCR_triangle)
      printf("smooth_HPCR_triangle\n");
   else if (triFunc ==smooth_DITHER8_triangle)
      printf("smooth_DITHER8_triangle\n");
   else if (triFunc ==smooth_LOOKUP8_triangle)
      printf("smooth_LOOKUP8_triangle\n");
a969 6
   else if (triFunc ==flat_HPCR_triangle)
      printf("flat_HPCR_triangle\n");
   else if (triFunc ==flat_DITHER8_triangle)
      printf("flat_DITHER8_triangle\n");
   else if (triFunc ==flat_LOOKUP8_triangle)
      printf("flat_LOOKUP8_triangle\n");
a1003 2
   XMesaBuffer xmbuf = XMESA_BUFFER(ctx->DrawBuffer);
   const int depth = GET_VISUAL_DEPTH(xmesa->xm_visual);
a1024 2
   if (xmbuf->swAlpha)
      return (swrast_tri_func) NULL;
d1026 1
a1026 1
   xrb = xmesa_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0]->Wrapped);
a1051 12
            case PF_HPCR:
	       USE(smooth_HPCR_z_triangle);
            case PF_Dither:
               if (depth == 8)
                  USE(smooth_DITHER8_z_triangle);
               else
                  USE(smooth_DITHER_z_triangle);
            case PF_Lookup:
               if (depth == 8)
                  USE(smooth_LOOKUP8_z_triangle);
               else
                  return (swrast_tri_func) NULL;
a1078 12
            case PF_HPCR:
	       USE(flat_HPCR_z_triangle);
            case PF_Dither:
               if (depth == 8)
                  USE(flat_DITHER8_z_triangle);
               else
                  USE(flat_DITHER_z_triangle);
            case PF_Lookup:
               if (depth == 8)
                  USE(flat_LOOKUP8_z_triangle);
               else
                  return (swrast_tri_func) NULL;
a1102 12
            case PF_HPCR:
	       USE(smooth_HPCR_triangle);
            case PF_Dither:
               if (depth == 8)
                  USE(smooth_DITHER8_triangle);
               else
                  USE(smooth_DITHER_triangle);
            case PF_Lookup:
               if (depth == 8)
                  USE(smooth_LOOKUP8_triangle);
               else
                  return (swrast_tri_func) NULL;
a1127 12
            case PF_HPCR:
	       USE(flat_HPCR_triangle);
            case PF_Dither:
               if (depth == 8)
                  USE(flat_DITHER8_triangle);
               else
                  USE(flat_DITHER_triangle);
            case PF_Lookup:
               if (depth == 8)
                  USE(flat_LOOKUP8_triangle);
               else
                  return (swrast_tri_func) NULL;
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d1451 1
a1451 1
get_triangle_func(GLcontext *ctx)
d1647 1
a1647 1
void xmesa_choose_triangle( GLcontext *ctx )
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d1333 1
a1333 1
   _mesa_printf("XMesa tri func = ");
d1335 1
a1335 1
      _mesa_printf("smooth_TRUECOLOR_z_triangle\n");
d1337 1
a1337 1
      _mesa_printf("smooth_8A8B8G8R_z_triangle\n");
d1339 1
a1339 1
      _mesa_printf("smooth_8A8R8G8B_z_triangle\n");
d1341 1
a1341 1
      _mesa_printf("smooth_8R8G8B_z_triangle\n");
d1343 1
a1343 1
      _mesa_printf("smooth_8R8G8B24_z_triangle\n");
d1345 1
a1345 1
      _mesa_printf("smooth_TRUEDITHER_z_triangle\n");
d1347 1
a1347 1
      _mesa_printf("smooth_5R6G5B_z_triangle\n");
d1349 1
a1349 1
      _mesa_printf("smooth_DITHER_5R6G5B_z_triangle\n");
d1351 1
a1351 1
      _mesa_printf("smooth_HPCR_z_triangle\n");
d1353 1
a1353 1
      _mesa_printf("smooth_DITHER8_z_triangle\n");
d1355 1
a1355 1
      _mesa_printf("smooth_LOOKUP8_z_triangle\n");
d1357 1
a1357 1
      _mesa_printf("flat_TRUECOLOR_z_triangle\n");
d1359 1
a1359 1
      _mesa_printf("flat_8A8B8G8R_z_triangle\n");
d1361 1
a1361 1
      _mesa_printf("flat_8A8R8G8B_z_triangle\n");
d1363 1
a1363 1
      _mesa_printf("flat_8R8G8B_z_triangle\n");
d1365 1
a1365 1
      _mesa_printf("flat_8R8G8B24_z_triangle\n");
d1367 1
a1367 1
      _mesa_printf("flat_TRUEDITHER_z_triangle\n");
d1369 1
a1369 1
      _mesa_printf("flat_5R6G5B_z_triangle\n");
d1371 1
a1371 1
      _mesa_printf("flat_DITHER_5R6G5B_z_triangle\n");
d1373 1
a1373 1
      _mesa_printf("flat_HPCR_z_triangle\n");
d1375 1
a1375 1
      _mesa_printf("flat_DITHER8_z_triangle\n");
d1377 1
a1377 1
      _mesa_printf("flat_LOOKUP8_z_triangle\n");
d1379 1
a1379 1
      _mesa_printf("smooth_TRUECOLOR_triangle\n");
d1381 1
a1381 1
      _mesa_printf("smooth_8A8B8G8R_triangle\n");
d1383 1
a1383 1
      _mesa_printf("smooth_8A8R8G8B_triangle\n");
d1385 1
a1385 1
      _mesa_printf("smooth_8R8G8B_triangle\n");
d1387 1
a1387 1
      _mesa_printf("smooth_8R8G8B24_triangle\n");
d1389 1
a1389 1
      _mesa_printf("smooth_TRUEDITHER_triangle\n");
d1391 1
a1391 1
      _mesa_printf("smooth_5R6G5B_triangle\n");
d1393 1
a1393 1
      _mesa_printf("smooth_DITHER_5R6G5B_triangle\n");
d1395 1
a1395 1
      _mesa_printf("smooth_HPCR_triangle\n");
d1397 1
a1397 1
      _mesa_printf("smooth_DITHER8_triangle\n");
d1399 1
a1399 1
      _mesa_printf("smooth_LOOKUP8_triangle\n");
d1401 1
a1401 1
      _mesa_printf("flat_TRUECOLOR_triangle\n");
d1403 1
a1403 1
      _mesa_printf("flat_TRUEDITHER_triangle\n");
d1405 1
a1405 1
      _mesa_printf("flat_8A8B8G8R_triangle\n");
d1407 1
a1407 1
      _mesa_printf("flat_8A8R8G8B_triangle\n");
d1409 1
a1409 1
      _mesa_printf("flat_8R8G8B_triangle\n");
d1411 1
a1411 1
      _mesa_printf("flat_8R8G8B24_triangle\n");
d1413 1
a1413 1
      _mesa_printf("flat_5R6G5B_triangle\n");
d1415 1
a1415 1
      _mesa_printf("flat_DITHER_5R6G5B_triangle\n");
d1417 1
a1417 1
      _mesa_printf("flat_HPCR_triangle\n");
d1419 1
a1419 1
      _mesa_printf("flat_DITHER8_triangle\n");
d1421 1
a1421 1
      _mesa_printf("flat_LOOKUP8_triangle\n");
d1423 1
a1423 1
      _mesa_printf("???\n");
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d33 4
a37 4
#include "depth.h"
#include "macros.h"
#include "imports.h"
#include "mtypes.h"
@


1.1
log
@Initial revision
@
text
@d48 1
a48 1
   xmesa_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0][0]->Wrapped)
d69 1
a69 1
#define RENDER_SPAN( span )					\
d85 1
a85 1
   }
d99 1
d105 1
a105 1
#define RENDER_SPAN( span )					\
d110 3
a112 2
         pRow[i] = PACK_8B8G8R(FixedToInt(span.red),		\
            FixedToInt(span.green), FixedToInt(span.blue));	\
d118 1
d120 1
a120 1
   }
d133 1
d140 1
a140 1
#define RENDER_SPAN( span )					\
d145 3
a147 2
         pRow[i] = PACK_8R8G8B(FixedToInt(span.red),		\
            FixedToInt(span.green), FixedToInt(span.blue));	\
d153 1
d155 1
a155 1
   }
d174 1
a174 1
#define RENDER_SPAN( span )					\
d187 1
a187 1
   }
d205 1
a205 1
#define RENDER_SPAN( span ) 					\
d220 1
a220 1
   }
d235 1
a235 1
#define RENDER_SPAN( span )					\
d251 1
a251 1
   }
d268 1
a268 1
#define RENDER_SPAN( span )					\
d281 1
a281 1
   }
d299 1
a299 1
#define RENDER_SPAN( span )					\
d313 1
a313 1
   }
d330 1
a330 1
#define RENDER_SPAN( span )					\
d345 1
a345 1
   }
d360 1
a360 1
#define RENDER_SPAN( span )					\
d376 1
a376 1
   }
d393 1
a393 1
#define RENDER_SPAN( span )					\
d407 1
a407 1
   }
d425 1
a425 1
#define RENDER_SPAN( span )					\
d439 1
a439 1
   }
d456 1
a456 1
#define RENDER_SPAN( span )					\
d466 1
a466 1
   }
d482 3
a484 2
   GLuint p = PACK_8B8G8R( v2->color[0], v2->color[1], v2->color[2] );
#define RENDER_SPAN( span )				\
d493 1
a493 1
   }
d509 3
a511 2
   GLuint p = PACK_8R8G8B( v2->color[0], v2->color[1], v2->color[2] );
#define RENDER_SPAN( span )				\
d520 1
a520 1
   }
d537 1
a537 1
#define RENDER_SPAN( span )			\
d546 1
a546 1
   }
d564 1
a564 1
#define RENDER_SPAN( span )				\
d576 1
a576 1
   }
d591 1
a591 1
#define RENDER_SPAN( span )					\
d604 1
a604 1
   }
d621 1
a621 1
#define RENDER_SPAN( span )				\
d630 1
a630 1
   }
d648 1
a648 1
#define RENDER_SPAN( span )					\
d659 1
a659 1
   }
d676 1
a676 1
#define RENDER_SPAN( span )					\
d687 1
a687 1
   }
d702 1
a702 1
#define RENDER_SPAN( span )					\
d714 1
a714 1
   }
d734 1
a734 1
#define RENDER_SPAN( span )					\
d744 1
a744 1
   }
d765 1
a765 1
#define RENDER_SPAN( span )				\
d774 1
a774 1
   }
d788 1
a788 1
#define RENDER_SPAN( span )					\
d799 1
a799 1
   }
d809 1
d815 1
a815 1
#define RENDER_SPAN( span )					\
d818 3
a820 2
      pRow[i] = PACK_8B8G8R(FixedToInt(span.red),		\
         FixedToInt(span.green), FixedToInt(span.blue) );	\
d824 2
a825 1
   }
d835 1
d841 1
a841 1
#define RENDER_SPAN( span )					\
d844 3
a846 2
      pRow[i] = PACK_8R8G8B(FixedToInt(span.red),		\
         FixedToInt(span.green), FixedToInt(span.blue) );	\
d850 2
a851 1
   }
d866 1
a866 1
#define RENDER_SPAN( span )					\
d874 1
a874 1
   }
d889 1
a889 1
#define RENDER_SPAN( span )				\
d899 1
a899 1
   }
d913 1
a913 1
#define RENDER_SPAN( span )					\
d924 1
a924 1
   }
d939 1
a939 1
#define RENDER_SPAN( span )					\
d947 1
a947 1
   }
d963 1
a963 1
#define RENDER_SPAN( span )					\
d972 1
a972 1
   }
d987 1
a987 1
#define RENDER_SPAN( span )					\
d997 1
a997 1
   }
d1010 1
a1010 1
#define RENDER_SPAN( span )					\
d1021 1
a1021 1
   }
d1036 1
a1036 1
#define RENDER_SPAN( span )					\
d1045 1
a1045 1
   }
d1061 1
a1061 1
#define RENDER_SPAN( span )					\
d1070 1
a1070 1
   }
d1085 1
a1085 1
#define RENDER_SPAN( span )					\
d1090 1
a1090 1
   }
d1106 1
a1106 1
#define RENDER_SPAN( span )				\
d1110 1
a1110 1
   }
d1126 1
a1126 1
#define RENDER_SPAN( span )				\
d1130 1
a1130 1
   }
d1146 1
a1146 1
#define RENDER_SPAN( span )				\
d1150 1
a1150 1
   }
d1165 1
a1165 1
#define RENDER_SPAN( span )				\
d1172 1
a1172 1
   }
d1185 1
a1185 1
#define RENDER_SPAN( span )					\
d1193 1
a1193 1
   }
d1209 1
a1209 1
#define RENDER_SPAN( span )				\
d1213 1
a1213 1
   }
d1229 1
a1229 1
#define RENDER_SPAN( span )					\
d1235 1
a1235 1
   }
d1250 1
a1250 1
#define RENDER_SPAN( span )					\
d1256 1
a1256 1
   }
d1269 1
a1269 1
#define RENDER_SPAN( span )					\
d1276 1
a1276 1
   }
d1294 1
a1294 1
#define RENDER_SPAN( span )					\
d1299 1
a1299 1
   }
d1318 1
a1318 1
#define RENDER_SPAN( span )         	 		\
d1322 1
a1322 1
   }
d1453 1
d1456 3
a1458 2
   int depth = GET_VISUAL_DEPTH(xmesa->xm_visual);
   struct xmesa_renderbuffer *xrb;
a1463 1
#if CHAN_BITS == 8
d1465 2
a1466 2
   if ((ctx->DrawBuffer->_ColorDrawBufferMask[0]
        & (BUFFER_BIT_FRONT_LEFT | BUFFER_BIT_BACK_LEFT)) == 0)
d1479 2
d1482 1
a1482 1
   xrb = xmesa_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0][0]->Wrapped);
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@a98 1
#define INTERP_ALPHA 1
d109 2
a110 3
         pRow[i] = PACK_8A8B8G8R(FixedToInt(span.red),		\
            FixedToInt(span.green), FixedToInt(span.blue),	\
            FixedToInt(span.alpha));				\
a115 1
      span.alpha += span.alphaStep;				\
a129 1
#define INTERP_ALPHA 1
d141 2
a142 3
         pRow[i] = PACK_8A8R8G8B(FixedToInt(span.red),		\
            FixedToInt(span.green), FixedToInt(span.blue),	\
            FixedToInt(span.alpha));				\
a147 1
      span.alpha += span.alphaStep;				\
d476 1
a476 2
   GLuint p = PACK_8A8B8G8R( v2->color[0], v2->color[1],\
                             v2->color[2], v2->color[3]);
d502 1
a502 2
   GLuint p = PACK_8A8R8G8B(v2->color[0], v2->color[1],	\
                            v2->color[2], v2->color[3]);
a800 1
#define INTERP_ALPHA 1
d809 2
a810 3
      pRow[i] = PACK_8A8B8G8R(FixedToInt(span.red),		\
         FixedToInt(span.green), FixedToInt(span.blue),		\
         FixedToInt(span.alpha));				\
a813 1
      span.alpha += span.alphaStep;				\
a823 1
#define INTERP_ALPHA 1
d832 2
a833 3
      pRow[i] = PACK_8A8R8G8B(FixedToInt(span.red),		\
         FixedToInt(span.green), FixedToInt(span.blue),		\
         FixedToInt(span.alpha));				\
a836 1
      span.alpha += span.alphaStep;				\
a1438 1
#if CHAN_BITS == 8
d1441 2
a1442 3
   XMesaBuffer xmbuf = XMESA_BUFFER(ctx->DrawBuffer);
   const int depth = GET_VISUAL_DEPTH(xmesa->xm_visual);
   const struct xmesa_renderbuffer *xrb;
d1448 1
a1462 2
      return (swrast_tri_func) NULL;
   if (xmbuf->swAlpha)
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@a32 4
#include "main/depth.h"
#include "main/macros.h"
#include "main/imports.h"
#include "main/mtypes.h"
d34 4
d48 1
a48 1
   xmesa_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0]->Wrapped)
d69 1
a69 1
#define RENDER_SPAN( span ) {					\
d85 1
a85 1
   } }
d105 1
a105 1
#define RENDER_SPAN( span ) {					\
d120 1
a120 1
   } }
d140 1
a140 1
#define RENDER_SPAN( span ) {					\
d155 1
a155 1
   } }
d174 1
a174 1
#define RENDER_SPAN( span ) {					\
d187 1
a187 1
   } }
d205 1
a205 1
#define RENDER_SPAN( span ) {					\
d220 1
a220 1
   } }
d235 1
a235 1
#define RENDER_SPAN( span ) {					\
d251 1
a251 1
   } }
d268 1
a268 1
#define RENDER_SPAN( span ) {					\
d281 1
a281 1
   } }
d299 1
a299 1
#define RENDER_SPAN( span ) {					\
d313 1
a313 1
   } }
d330 1
a330 1
#define RENDER_SPAN( span ) {					\
d345 1
a345 1
   } }
d360 1
a360 1
#define RENDER_SPAN( span ) {					\
d376 1
a376 1
   } }
d393 1
a393 1
#define RENDER_SPAN( span ) {					\
d407 1
a407 1
   } }
d425 1
a425 1
#define RENDER_SPAN( span ) {					\
d439 1
a439 1
   } }
d456 1
a456 1
#define RENDER_SPAN( span ) {					\
d466 1
a466 1
   } }
d484 1
a484 1
#define RENDER_SPAN( span ) {				\
d493 1
a493 1
   } }
d511 1
a511 1
#define RENDER_SPAN( span ) {				\
d520 1
a520 1
   } }
d537 1
a537 1
#define RENDER_SPAN( span ) {			\
d546 1
a546 1
   } }
d564 1
a564 1
#define RENDER_SPAN( span ) {				\
d576 1
a576 1
   } }
d591 1
a591 1
#define RENDER_SPAN( span ) {					\
d604 1
a604 1
   } }
d621 1
a621 1
#define RENDER_SPAN( span ) {				\
d630 1
a630 1
   } }
d648 1
a648 1
#define RENDER_SPAN( span ) {					\
d659 1
a659 1
   } }
d676 1
a676 1
#define RENDER_SPAN( span ) {					\
d687 1
a687 1
   } }
d702 1
a702 1
#define RENDER_SPAN( span ) {					\
d714 1
a714 1
   } }
d734 1
a734 1
#define RENDER_SPAN( span ) {					\
d744 1
a744 1
   } }
d765 1
a765 1
#define RENDER_SPAN( span ) {				\
d774 1
a774 1
   } }
d788 1
a788 1
#define RENDER_SPAN( span ) {					\
d799 1
a799 1
   } }
d815 1
a815 1
#define RENDER_SPAN( span ) {					\
d825 1
a825 1
   } }
d841 1
a841 1
#define RENDER_SPAN( span ) {					\
d851 1
a851 1
   } }
d866 1
a866 1
#define RENDER_SPAN( span ) {					\
d874 1
a874 1
   } }
d889 1
a889 1
#define RENDER_SPAN( span ) {				\
d899 1
a899 1
   } }
d913 1
a913 1
#define RENDER_SPAN( span ) {					\
d924 1
a924 1
   } }
d939 1
a939 1
#define RENDER_SPAN( span ) {					\
d947 1
a947 1
   } }
d963 1
a963 1
#define RENDER_SPAN( span ) {					\
d972 1
a972 1
   } }
d987 1
a987 1
#define RENDER_SPAN( span ) {					\
d997 1
a997 1
   } }
d1010 1
a1010 1
#define RENDER_SPAN( span ) {					\
d1021 1
a1021 1
   } }
d1036 1
a1036 1
#define RENDER_SPAN( span ) {					\
d1045 1
a1045 1
   } }
d1061 1
a1061 1
#define RENDER_SPAN( span ) {					\
d1070 1
a1070 1
   } }
d1085 1
a1085 1
#define RENDER_SPAN( span ) {					\
d1090 1
a1090 1
   } }
d1106 1
a1106 1
#define RENDER_SPAN( span ) {				\
d1110 1
a1110 1
   } }
d1126 1
a1126 1
#define RENDER_SPAN( span ) {				\
d1130 1
a1130 1
   } }
d1146 1
a1146 1
#define RENDER_SPAN( span ) {				\
d1150 1
a1150 1
   } }
d1165 1
a1165 1
#define RENDER_SPAN( span ) {				\
d1172 1
a1172 1
   } }
d1185 1
a1185 1
#define RENDER_SPAN( span ) {					\
d1193 1
a1193 1
   } }
d1209 1
a1209 1
#define RENDER_SPAN( span ) {				\
d1213 1
a1213 1
   } }
d1229 1
a1229 1
#define RENDER_SPAN( span ) {					\
d1235 1
a1235 1
   } }
d1250 1
a1250 1
#define RENDER_SPAN( span ) {					\
d1256 1
a1256 1
   } }
d1269 1
a1269 1
#define RENDER_SPAN( span ) {					\
d1276 1
a1276 1
   } }
d1294 1
a1294 1
#define RENDER_SPAN( span ) {					\
d1299 1
a1299 1
   } }
d1318 1
a1318 1
#define RENDER_SPAN( span ) {         	 		\
d1322 1
a1322 1
   } }
d1333 1
a1333 1
   printf("XMesa tri func = ");
d1335 1
a1335 1
      printf("smooth_TRUECOLOR_z_triangle\n");
d1337 1
a1337 1
      printf("smooth_8A8B8G8R_z_triangle\n");
d1339 1
a1339 1
      printf("smooth_8A8R8G8B_z_triangle\n");
d1341 1
a1341 1
      printf("smooth_8R8G8B_z_triangle\n");
d1343 1
a1343 1
      printf("smooth_8R8G8B24_z_triangle\n");
d1345 1
a1345 1
      printf("smooth_TRUEDITHER_z_triangle\n");
d1347 1
a1347 1
      printf("smooth_5R6G5B_z_triangle\n");
d1349 1
a1349 1
      printf("smooth_DITHER_5R6G5B_z_triangle\n");
d1351 1
a1351 1
      printf("smooth_HPCR_z_triangle\n");
d1353 1
a1353 1
      printf("smooth_DITHER8_z_triangle\n");
d1355 1
a1355 1
      printf("smooth_LOOKUP8_z_triangle\n");
d1357 1
a1357 1
      printf("flat_TRUECOLOR_z_triangle\n");
d1359 1
a1359 1
      printf("flat_8A8B8G8R_z_triangle\n");
d1361 1
a1361 1
      printf("flat_8A8R8G8B_z_triangle\n");
d1363 1
a1363 1
      printf("flat_8R8G8B_z_triangle\n");
d1365 1
a1365 1
      printf("flat_8R8G8B24_z_triangle\n");
d1367 1
a1367 1
      printf("flat_TRUEDITHER_z_triangle\n");
d1369 1
a1369 1
      printf("flat_5R6G5B_z_triangle\n");
d1371 1
a1371 1
      printf("flat_DITHER_5R6G5B_z_triangle\n");
d1373 1
a1373 1
      printf("flat_HPCR_z_triangle\n");
d1375 1
a1375 1
      printf("flat_DITHER8_z_triangle\n");
d1377 1
a1377 1
      printf("flat_LOOKUP8_z_triangle\n");
d1379 1
a1379 1
      printf("smooth_TRUECOLOR_triangle\n");
d1381 1
a1381 1
      printf("smooth_8A8B8G8R_triangle\n");
d1383 1
a1383 1
      printf("smooth_8A8R8G8B_triangle\n");
d1385 1
a1385 1
      printf("smooth_8R8G8B_triangle\n");
d1387 1
a1387 1
      printf("smooth_8R8G8B24_triangle\n");
d1389 1
a1389 1
      printf("smooth_TRUEDITHER_triangle\n");
d1391 1
a1391 1
      printf("smooth_5R6G5B_triangle\n");
d1393 1
a1393 1
      printf("smooth_DITHER_5R6G5B_triangle\n");
d1395 1
a1395 1
      printf("smooth_HPCR_triangle\n");
d1397 1
a1397 1
      printf("smooth_DITHER8_triangle\n");
d1399 1
a1399 1
      printf("smooth_LOOKUP8_triangle\n");
d1401 1
a1401 1
      printf("flat_TRUECOLOR_triangle\n");
d1403 1
a1403 1
      printf("flat_TRUEDITHER_triangle\n");
d1405 1
a1405 1
      printf("flat_8A8B8G8R_triangle\n");
d1407 1
a1407 1
      printf("flat_8A8R8G8B_triangle\n");
d1409 1
a1409 1
      printf("flat_8R8G8B_triangle\n");
d1411 1
a1411 1
      printf("flat_8R8G8B24_triangle\n");
d1413 1
a1413 1
      printf("flat_5R6G5B_triangle\n");
d1415 1
a1415 1
      printf("flat_DITHER_5R6G5B_triangle\n");
d1417 1
a1417 1
      printf("flat_HPCR_triangle\n");
d1419 1
a1419 1
      printf("flat_DITHER8_triangle\n");
d1421 1
a1421 1
      printf("flat_LOOKUP8_triangle\n");
d1423 1
a1423 1
      printf("???\n");
d1451 1
a1451 1
get_triangle_func(struct gl_context *ctx)
d1465 2
a1466 2
   if ((ctx->DrawBuffer->_ColorDrawBufferIndexes[0] != BUFFER_BIT_FRONT_LEFT) &&
       (ctx->DrawBuffer->_ColorDrawBufferIndexes[0] != BUFFER_BIT_BACK_LEFT))
d1482 1
a1482 1
   xrb = xmesa_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0]->Wrapped);
d1647 1
a1647 1
void xmesa_choose_triangle( struct gl_context *ctx )
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d33 2
d48 1
a48 1
   xmesa_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0])
d319 126
d663 116
d978 98
d1240 86
d1350 6
d1372 6
d1394 6
d1416 6
d1456 2
d1479 2
d1482 1
a1482 1
   xrb = xmesa_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0]);
d1508 12
d1547 12
d1583 12
d1620 12
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d1018 1
a1018 1
   if (ctx->Texture._MaxEnabledTexImageUnit != -1)
@


