head	1.13;
access;
symbols
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.12;
commitid	TnlogFl9nOv2eaRf;

1.12
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.11;
commitid	4ry2gvZGMXkCUD2n;

1.11
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.10;
commitid	mcxB0JvoI9gTDYXU;

1.10
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.9;
commitid	WPD6rgPryPkvXOr9;

1.9
date	2013.09.05.14.06.11;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.17.13.58.17;	author mpi;	state Exp;
branches;
next	1.7;

1.7
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.22.20.06.28;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.14.58.20;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.17.41.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.19.08.12.55;	author aanriot;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.03;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.01;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.30.27;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.44;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.13;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.57;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.12.20;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.49.27;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.13
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file xm_api.c
 *
 * All the XMesa* API functions.
 *
 *
 * NOTES:
 *
 * The window coordinate system origin (0,0) is in the lower-left corner
 * of the window.  X11's window coordinate origin is in the upper-left
 * corner of the window.  Therefore, most drawing functions in this
 * file have to flip Y coordinates.
 *
 * Define USE_XSHM in the Makefile with -DUSE_XSHM if you want to compile
 * in support for the MIT Shared Memory extension.  If enabled, when you
 * use an Ximage for the back buffer in double buffered mode, the "swap"
 * operation will be faster.  You must also link with -lXext.
 *
 * Byte swapping:  If the Mesa host and the X display use a different
 * byte order then there's some trickiness to be aware of when using
 * XImages.  The byte ordering used for the XImage is that of the X
 * display, not the Mesa host.
 * The color-to-pixel encoding for True/DirectColor must be done
 * according to the display's visual red_mask, green_mask, and blue_mask.
 * If XPutPixel is used to put a pixel into an XImage then XPutPixel will
 * do byte swapping if needed.  If one wants to directly "poke" the pixel
 * into the XImage's buffer then the pixel must be byte swapped first.  In
 * Mesa, when byte swapping is needed we use the PF_TRUECOLOR pixel format
 * and use XPutPixel everywhere except in the implementation of
 * glClear(GL_COLOR_BUFFER_BIT).  We want this function to be fast so
 * instead of using XPutPixel we "poke" our values after byte-swapping
 * the clear pixel value if needed.
 *
 */

#ifdef __CYGWIN__
#undef WIN32
#undef __WIN32__
#endif

#include "glxheader.h"
#include "xmesaP.h"
#include "main/api_exec.h"
#include "main/context.h"
#include "main/extensions.h"
#include "main/framebuffer.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/renderbuffer.h"
#include "main/teximage.h"
#include "main/version.h"
#include "main/vtxfmt.h"
#include "swrast/swrast.h"
#include "swrast/s_renderbuffer.h"
#include "swrast_setup/swrast_setup.h"
#include "vbo/vbo.h"
#include "tnl/tnl.h"
#include "tnl/t_context.h"
#include "tnl/t_pipeline.h"
#include "drivers/common/driverfuncs.h"
#include "drivers/common/meta.h"

/**
 * Global X driver lock
 */
mtx_t _xmesa_lock;



/**********************************************************************/
/*****                     X Utility Functions                    *****/
/**********************************************************************/


/**
 * Return the host's byte order as LSBFirst or MSBFirst ala X.
 */
static int host_byte_order( void )
{
   int i = 1;
   char *cptr = (char *) &i;
   return (*cptr==1) ? LSBFirst : MSBFirst;
}


/**
 * Check if the X Shared Memory extension is available.
 * Return:  0 = not available
 *          1 = shared XImage support available
 *          2 = shared Pixmap support available also
 */
static int check_for_xshm( XMesaDisplay *display )
{
#if defined(USE_XSHM) 
   int ignore;

   if (XQueryExtension( display, "MIT-SHM", &ignore, &ignore, &ignore )) {
      /* Note: we're no longer calling XShmQueryVersion() here.  It seems
       * to be flakey (triggers a spurious X protocol error when we close
       * one display connection and start using a new one.  XShm has been
       * around a long time and hasn't changed so if MIT_SHM is supported
       * we assume we're good to go.
       */
      return 2;
   }
   else {
      return 0;
   }
#else
   /* No  XSHM support */
   return 0;
#endif
}


/**
 * Apply gamma correction to an intensity value in [0..max].  Return the
 * new intensity value.
 */
static GLint
gamma_adjust( GLfloat gamma, GLint value, GLint max )
{
   if (gamma == 1.0) {
      return value;
   }
   else {
      double x = (double) value / (double) max;
      return IROUND_POS((GLfloat) max * pow(x, 1.0F/gamma));
   }
}



/**
 * Return the true number of bits per pixel for XImages.
 * For example, if we request a 24-bit deep visual we may actually need/get
 * 32bpp XImages.  This function returns the appropriate bpp.
 * Input:  dpy - the X display
 *         visinfo - desribes the visual to be used for XImages
 * Return:  true number of bits per pixel for XImages
 */
static int
bits_per_pixel( XMesaVisual xmv )
{
   XMesaDisplay *dpy = xmv->display;
   XMesaVisualInfo visinfo = xmv->visinfo;
   XMesaImage *img;
   int bitsPerPixel;
   /* Create a temporary XImage */
   img = XCreateImage( dpy, visinfo->visual, visinfo->depth,
		       ZPixmap, 0,           /*format, offset*/
		       malloc(8),    /*data*/
		       1, 1,                 /*width, height*/
		       32,                   /*bitmap_pad*/
		       0                     /*bytes_per_line*/
                     );
   assert(img);
   /* grab the bits/pixel value */
   bitsPerPixel = img->bits_per_pixel;
   /* free the XImage */
   free( img->data );
   img->data = NULL;
   XMesaDestroyImage( img );
   return bitsPerPixel;
}



/*
 * Determine if a given X window ID is valid (window exists).
 * Do this by calling XGetWindowAttributes() for the window and
 * checking if we catch an X error.
 * Input:  dpy - the display
 *         win - the window to check for existance
 * Return:  GL_TRUE - window exists
 *          GL_FALSE - window doesn't exist
 */
static GLboolean WindowExistsFlag;

static int window_exists_err_handler( XMesaDisplay* dpy, XErrorEvent* xerr )
{
   (void) dpy;
   if (xerr->error_code == BadWindow) {
      WindowExistsFlag = GL_FALSE;
   }
   return 0;
}

static GLboolean window_exists( XMesaDisplay *dpy, Window win )
{
   XWindowAttributes wa;
   int (*old_handler)( XMesaDisplay*, XErrorEvent* );
   WindowExistsFlag = GL_TRUE;
   old_handler = XSetErrorHandler(window_exists_err_handler);
   XGetWindowAttributes( dpy, win, &wa ); /* dummy request */
   XSetErrorHandler(old_handler);
   return WindowExistsFlag;
}

static Status
get_drawable_size( XMesaDisplay *dpy, Drawable d, GLuint *width, GLuint *height )
{
   Window root;
   Status stat;
   int xpos, ypos;
   unsigned int w, h, bw, depth;
   stat = XGetGeometry(dpy, d, &root, &xpos, &ypos, &w, &h, &bw, &depth);
   *width = w;
   *height = h;
   return stat;
}


/**
 * Return the size of the window (or pixmap) that corresponds to the
 * given XMesaBuffer.
 * \param width  returns width in pixels
 * \param height  returns height in pixels
 */
void
xmesa_get_window_size(XMesaDisplay *dpy, XMesaBuffer b,
                      GLuint *width, GLuint *height)
{
   Status stat;

   mtx_lock(&_xmesa_lock);
   XSync(b->xm_visual->display, 0); /* added for Chromium */
   stat = get_drawable_size(dpy, b->frontxrb->pixmap, width, height);
   mtx_unlock(&_xmesa_lock);

   if (!stat) {
      /* probably querying a window that's recently been destroyed */
      _mesa_warning(NULL, "XGetGeometry failed!\n");
      *width = *height = 1;
   }
}



/**********************************************************************/
/*****                Linked list of XMesaBuffers                 *****/
/**********************************************************************/

XMesaBuffer XMesaBufferList = NULL;


/**
 * Allocate a new XMesaBuffer object which corresponds to the given drawable.
 * Note that XMesaBuffer is derived from struct gl_framebuffer.
 * The new XMesaBuffer will not have any size (Width=Height=0).
 *
 * \param d  the corresponding X drawable (window or pixmap)
 * \param type  either WINDOW, PIXMAP or PBUFFER, describing d
 * \param vis  the buffer's visual
 * \param cmap  the window's colormap, if known.
 * \return new XMesaBuffer or NULL if any problem
 */
static XMesaBuffer
create_xmesa_buffer(XMesaDrawable d, BufferType type,
                    XMesaVisual vis, XMesaColormap cmap)
{
   XMesaBuffer b;

   ASSERT(type == WINDOW || type == PIXMAP || type == PBUFFER);

   b = (XMesaBuffer) CALLOC_STRUCT(xmesa_buffer);
   if (!b)
      return NULL;

   b->display = vis->display;
   b->xm_visual = vis;
   b->type = type;
   b->cmap = cmap;

   _mesa_initialize_window_framebuffer(&b->mesa_buffer, &vis->mesa_visual);
   b->mesa_buffer.Delete = xmesa_delete_framebuffer;

   /*
    * Front renderbuffer
    */
   b->frontxrb = xmesa_new_renderbuffer(NULL, 0, vis, GL_FALSE);
   if (!b->frontxrb) {
      free(b);
      return NULL;
   }
   b->frontxrb->Parent = b;
   b->frontxrb->drawable = d;
   b->frontxrb->pixmap = (XMesaPixmap) d;
   _mesa_add_renderbuffer(&b->mesa_buffer, BUFFER_FRONT_LEFT,
                          &b->frontxrb->Base.Base);

   /*
    * Back renderbuffer
    */
   if (vis->mesa_visual.doubleBufferMode) {
      b->backxrb = xmesa_new_renderbuffer(NULL, 0, vis, GL_TRUE);
      if (!b->backxrb) {
         /* XXX free front xrb too */
         free(b);
         return NULL;
      }
      b->backxrb->Parent = b;
      /* determine back buffer implementation */
      b->db_mode = vis->ximage_flag ? BACK_XIMAGE : BACK_PIXMAP;
      
      _mesa_add_renderbuffer(&b->mesa_buffer, BUFFER_BACK_LEFT,
                             &b->backxrb->Base.Base);
   }

   /*
    * Other renderbuffer (depth, stencil, etc)
    */
   _swrast_add_soft_renderbuffers(&b->mesa_buffer,
                                  GL_FALSE,  /* color */
                                  vis->mesa_visual.haveDepthBuffer,
                                  vis->mesa_visual.haveStencilBuffer,
                                  vis->mesa_visual.haveAccumBuffer,
                                  GL_FALSE,  /* software alpha buffer */
                                  vis->mesa_visual.numAuxBuffers > 0 );

   /* GLX_EXT_texture_from_pixmap */
   b->TextureTarget = 0;
   b->TextureFormat = GLX_TEXTURE_FORMAT_NONE_EXT;
   b->TextureMipmap = 0;

   /* insert buffer into linked list */
   b->Next = XMesaBufferList;
   XMesaBufferList = b;

   return b;
}


/**
 * Find an XMesaBuffer by matching X display and colormap but NOT matching
 * the notThis buffer.
 */
XMesaBuffer
xmesa_find_buffer(XMesaDisplay *dpy, XMesaColormap cmap, XMesaBuffer notThis)
{
   XMesaBuffer b;
   for (b=XMesaBufferList; b; b=b->Next) {
      if (b->display==dpy && b->cmap==cmap && b!=notThis) {
         return b;
      }
   }
   return NULL;
}


/**
 * Remove buffer from linked list, delete if no longer referenced.
 */
static void
xmesa_free_buffer(XMesaBuffer buffer)
{
   XMesaBuffer prev = NULL, b;

   for (b = XMesaBufferList; b; b = b->Next) {
      if (b == buffer) {
         struct gl_framebuffer *fb = &buffer->mesa_buffer;

         /* unlink buffer from list */
         if (prev)
            prev->Next = buffer->Next;
         else
            XMesaBufferList = buffer->Next;

         /* mark as delete pending */
         fb->DeletePending = GL_TRUE;

         /* Since the X window for the XMesaBuffer is going away, we don't
          * want to dereference this pointer in the future.
          */
         b->frontxrb->drawable = 0;

         /* Unreference.  If count = zero we'll really delete the buffer */
         _mesa_reference_framebuffer(&fb, NULL);

         return;
      }
      /* continue search */
      prev = b;
   }
   /* buffer not found in XMesaBufferList */
   _mesa_problem(NULL,"xmesa_free_buffer() - buffer not found\n");
}




/**********************************************************************/
/*****                   Misc Private Functions                   *****/
/**********************************************************************/


/**
 * Setup RGB rendering for a window with a True/DirectColor visual.
 */
static void
setup_truecolor(XMesaVisual v, XMesaBuffer buffer, XMesaColormap cmap)
{
   unsigned long rmask, gmask, bmask;
   (void) buffer;
   (void) cmap;

   /* Compute red multiplier (mask) and bit shift */
   v->rshift = 0;
   rmask = GET_REDMASK(v);
   while ((rmask & 1)==0) {
      v->rshift++;
      rmask = rmask >> 1;
   }

   /* Compute green multiplier (mask) and bit shift */
   v->gshift = 0;
   gmask = GET_GREENMASK(v);
   while ((gmask & 1)==0) {
      v->gshift++;
      gmask = gmask >> 1;
   }

   /* Compute blue multiplier (mask) and bit shift */
   v->bshift = 0;
   bmask = GET_BLUEMASK(v);
   while ((bmask & 1)==0) {
      v->bshift++;
      bmask = bmask >> 1;
   }

   /*
    * Compute component-to-pixel lookup tables and dithering kernel
    */
   {
      static GLubyte kernel[16] = {
          0*16,  8*16,  2*16, 10*16,
         12*16,  4*16, 14*16,  6*16,
          3*16, 11*16,  1*16,  9*16,
         15*16,  7*16, 13*16,  5*16,
      };
      GLint rBits = _mesa_bitcount(rmask);
      GLint gBits = _mesa_bitcount(gmask);
      GLint bBits = _mesa_bitcount(bmask);
      GLint maxBits;
      GLuint i;

      /* convert pixel components in [0,_mask] to RGB values in [0,255] */
      for (i=0; i<=rmask; i++)
         v->PixelToR[i] = (unsigned char) ((i * 255) / rmask);
      for (i=0; i<=gmask; i++)
         v->PixelToG[i] = (unsigned char) ((i * 255) / gmask);
      for (i=0; i<=bmask; i++)
         v->PixelToB[i] = (unsigned char) ((i * 255) / bmask);

      /* convert RGB values from [0,255] to pixel components */

      for (i=0;i<256;i++) {
         GLint r = gamma_adjust(v->RedGamma,   i, 255);
         GLint g = gamma_adjust(v->GreenGamma, i, 255);
         GLint b = gamma_adjust(v->BlueGamma,  i, 255);
         v->RtoPixel[i] = (r >> (8-rBits)) << v->rshift;
         v->GtoPixel[i] = (g >> (8-gBits)) << v->gshift;
         v->BtoPixel[i] = (b >> (8-bBits)) << v->bshift;
      }
      /* overflow protection */
      for (i=256;i<512;i++) {
         v->RtoPixel[i] = v->RtoPixel[255];
         v->GtoPixel[i] = v->GtoPixel[255];
         v->BtoPixel[i] = v->BtoPixel[255];
      }

      /* setup dithering kernel */
      maxBits = rBits;
      if (gBits > maxBits)  maxBits = gBits;
      if (bBits > maxBits)  maxBits = bBits;
      for (i=0;i<16;i++) {
         v->Kernel[i] = kernel[i] >> maxBits;
      }

      v->undithered_pf = PF_Truecolor;
      v->dithered_pf = (GET_VISUAL_DEPTH(v)<24) ? PF_Dither_True : PF_Truecolor;
   }

   /*
    * Now check for TrueColor visuals which we can optimize.
    */
   if (   GET_REDMASK(v)  ==0x0000ff
       && GET_GREENMASK(v)==0x00ff00
       && GET_BLUEMASK(v) ==0xff0000
       && CHECK_BYTE_ORDER(v)
       && v->BitsPerPixel==32
       && v->RedGamma==1.0 && v->GreenGamma==1.0 && v->BlueGamma==1.0) {
      /* common 32 bpp config used on SGI, Sun */
      v->undithered_pf = v->dithered_pf = PF_8A8B8G8R; /* ABGR */
   }
   else if (GET_REDMASK(v)  == 0xff0000
         && GET_GREENMASK(v)== 0x00ff00
         && GET_BLUEMASK(v) == 0x0000ff
         && CHECK_BYTE_ORDER(v)
         && v->RedGamma == 1.0 && v->GreenGamma == 1.0 && v->BlueGamma == 1.0){
      if (v->BitsPerPixel==32) {
         /* if 32 bpp, and visual indicates 8 bpp alpha channel */
         if (GET_VISUAL_DEPTH(v) == 32 && v->mesa_visual.alphaBits == 8)
            v->undithered_pf = v->dithered_pf = PF_8A8R8G8B; /* ARGB */
         else
            v->undithered_pf = v->dithered_pf = PF_8R8G8B; /* xRGB */
      }
      else if (v->BitsPerPixel == 24) {
         v->undithered_pf = v->dithered_pf = PF_8R8G8B24; /* RGB */
      }
   }
   else if (GET_REDMASK(v)  ==0xf800
       &&   GET_GREENMASK(v)==0x07e0
       &&   GET_BLUEMASK(v) ==0x001f
       && CHECK_BYTE_ORDER(v)
       && v->BitsPerPixel==16
       && v->RedGamma==1.0 && v->GreenGamma==1.0 && v->BlueGamma==1.0) {
      /* 5-6-5 RGB */
      v->undithered_pf = PF_5R6G5B;
      v->dithered_pf = PF_Dither_5R6G5B;
   }
}


/**
 * When a context is bound for the first time, we can finally finish
 * initializing the context's visual and buffer information.
 * \param v  the XMesaVisual to initialize
 * \param b  the XMesaBuffer to initialize (may be NULL)
 * \param rgb_flag  TRUE = RGBA mode, FALSE = color index mode
 * \param window  the window/pixmap we're rendering into
 * \param cmap  the colormap associated with the window/pixmap
 * \return GL_TRUE=success, GL_FALSE=failure
 */
static GLboolean
initialize_visual_and_buffer(XMesaVisual v, XMesaBuffer b,
                             XMesaDrawable window,
                             XMesaColormap cmap)
{
   const int xclass = v->visualType;


   ASSERT(!b || b->xm_visual == v);

   /* Save true bits/pixel */
   v->BitsPerPixel = bits_per_pixel(v);
   assert(v->BitsPerPixel > 0);

   /* RGB WINDOW:
    * We support RGB rendering into almost any kind of visual.
    */
   if (xclass == GLX_TRUE_COLOR || xclass == GLX_DIRECT_COLOR) {
      setup_truecolor( v, b, cmap );
   }
   else {
      _mesa_warning(NULL, "XMesa: RGB mode rendering not supported in given visual.\n");
      return GL_FALSE;
   }
   v->mesa_visual.indexBits = 0;

   if (_mesa_getenv("MESA_NO_DITHER")) {
      v->dithered_pf = v->undithered_pf;
   }


   /*
    * If MESA_INFO env var is set print out some debugging info
    * which can help Brian figure out what's going on when a user
    * reports bugs.
    */
   if (_mesa_getenv("MESA_INFO")) {
      printf("X/Mesa visual = %p\n", (void *) v);
      printf("X/Mesa dithered pf = %u\n", v->dithered_pf);
      printf("X/Mesa undithered pf = %u\n", v->undithered_pf);
      printf("X/Mesa level = %d\n", v->mesa_visual.level);
      printf("X/Mesa depth = %d\n", GET_VISUAL_DEPTH(v));
      printf("X/Mesa bits per pixel = %d\n", v->BitsPerPixel);
   }

   if (b && window) {
      /* Do window-specific initializations */

      /* these should have been set in create_xmesa_buffer */
      ASSERT(b->frontxrb->drawable == window);
      ASSERT(b->frontxrb->pixmap == (XMesaPixmap) window);

      /* Setup for single/double buffering */
      if (v->mesa_visual.doubleBufferMode) {
         /* Double buffered */
         b->shm = check_for_xshm( v->display );
      }

      /* X11 graphics contexts */
      b->gc = XCreateGC( v->display, window, 0, NULL );
      XMesaSetFunction( v->display, b->gc, GXcopy );

      /* cleargc - for glClear() */
      b->cleargc = XCreateGC( v->display, window, 0, NULL );
      XMesaSetFunction( v->display, b->cleargc, GXcopy );

      /*
       * Don't generate Graphics Expose/NoExpose events in swapbuffers().
       * Patch contributed by Michael Pichler May 15, 1995.
       */
      {
         XGCValues gcvalues;
         gcvalues.graphics_exposures = False;
         b->swapgc = XCreateGC(v->display, window,
                               GCGraphicsExposures, &gcvalues);
      }
      XMesaSetFunction( v->display, b->swapgc, GXcopy );
   }

   return GL_TRUE;
}



/*
 * Convert an RGBA color to a pixel value.
 */
unsigned long
xmesa_color_to_pixel(struct gl_context *ctx,
                     GLubyte r, GLubyte g, GLubyte b, GLubyte a,
                     GLuint pixelFormat)
{
   XMesaContext xmesa = XMESA_CONTEXT(ctx);
   switch (pixelFormat) {
      case PF_Truecolor:
         {
            unsigned long p;
            PACK_TRUECOLOR( p, r, g, b );
            return p;
         }
      case PF_8A8B8G8R:
         return PACK_8A8B8G8R( r, g, b, a );
      case PF_8A8R8G8B:
         return PACK_8A8R8G8B( r, g, b, a );
      case PF_8R8G8B:
         /* fall through */
      case PF_8R8G8B24:
         return PACK_8R8G8B( r, g, b );
      case PF_5R6G5B:
         return PACK_5R6G5B( r, g, b );
      case PF_Dither_True:
         /* fall through */
      case PF_Dither_5R6G5B:
         {
            unsigned long p;
            PACK_TRUEDITHER(p, 1, 0, r, g, b);
            return p;
         }
      default:
         _mesa_problem(ctx, "Bad pixel format in xmesa_color_to_pixel");
   }
   return 0;
}


#define NUM_VISUAL_TYPES   6

/**
 * Convert an X visual type to a GLX visual type.
 * 
 * \param visualType X visual type (i.e., \c TrueColor, \c StaticGray, etc.)
 *        to be converted.
 * \return If \c visualType is a valid X visual type, a GLX visual type will
 *         be returned.  Otherwise \c GLX_NONE will be returned.
 * 
 * \note
 * This code was lifted directly from lib/GL/glx/glcontextmodes.c in the
 * DRI CVS tree.
 */
static GLint
xmesa_convert_from_x_visual_type( int visualType )
{
    static const int glx_visual_types[ NUM_VISUAL_TYPES ] = {
	GLX_STATIC_GRAY,  GLX_GRAY_SCALE,
	GLX_STATIC_COLOR, GLX_PSEUDO_COLOR,
	GLX_TRUE_COLOR,   GLX_DIRECT_COLOR
    };

    return ( (unsigned) visualType < NUM_VISUAL_TYPES )
	? glx_visual_types[ visualType ] : GLX_NONE;
}


/**********************************************************************/
/*****                       Public Functions                     *****/
/**********************************************************************/


/*
 * Create a new X/Mesa visual.
 * Input:  display - X11 display
 *         visinfo - an XVisualInfo pointer
 *         rgb_flag - GL_TRUE = RGB mode,
 *                    GL_FALSE = color index mode
 *         alpha_flag - alpha buffer requested?
 *         db_flag - GL_TRUE = double-buffered,
 *                   GL_FALSE = single buffered
 *         stereo_flag - stereo visual?
 *         ximage_flag - GL_TRUE = use an XImage for back buffer,
 *                       GL_FALSE = use an off-screen pixmap for back buffer
 *         depth_size - requested bits/depth values, or zero
 *         stencil_size - requested bits/stencil values, or zero
 *         accum_red_size - requested bits/red accum values, or zero
 *         accum_green_size - requested bits/green accum values, or zero
 *         accum_blue_size - requested bits/blue accum values, or zero
 *         accum_alpha_size - requested bits/alpha accum values, or zero
 *         num_samples - number of samples/pixel if multisampling, or zero
 *         level - visual level, usually 0
 *         visualCaveat - ala the GLX extension, usually GLX_NONE
 * Return;  a new XMesaVisual or 0 if error.
 */
PUBLIC
XMesaVisual XMesaCreateVisual( XMesaDisplay *display,
                               XMesaVisualInfo visinfo,
                               GLboolean rgb_flag,
                               GLboolean alpha_flag,
                               GLboolean db_flag,
                               GLboolean stereo_flag,
                               GLboolean ximage_flag,
                               GLint depth_size,
                               GLint stencil_size,
                               GLint accum_red_size,
                               GLint accum_green_size,
                               GLint accum_blue_size,
                               GLint accum_alpha_size,
                               GLint num_samples,
                               GLint level,
                               GLint visualCaveat )
{
   char *gamma;
   XMesaVisual v;
   GLint red_bits, green_bits, blue_bits, alpha_bits;

   /* For debugging only */
   if (_mesa_getenv("MESA_XSYNC")) {
      /* This makes debugging X easier.
       * In your debugger, set a breakpoint on _XError to stop when an
       * X protocol error is generated.
       */
      XSynchronize( display, 1 );
   }

   /* Color-index rendering not supported. */
   if (!rgb_flag)
      return NULL;

   v = (XMesaVisual) CALLOC_STRUCT(xmesa_visual);
   if (!v) {
      return NULL;
   }

   v->display = display;

   /* Save a copy of the XVisualInfo struct because the user may Xfree()
    * the struct but we may need some of the information contained in it
    * at a later time.
    */
   v->visinfo = (XVisualInfo *) malloc(sizeof(*visinfo));
   if(!v->visinfo) {
      free(v);
      return NULL;
   }
   memcpy(v->visinfo, visinfo, sizeof(*visinfo));

   /* check for MESA_GAMMA environment variable */
   gamma = _mesa_getenv("MESA_GAMMA");
   if (gamma) {
      v->RedGamma = v->GreenGamma = v->BlueGamma = 0.0;
      sscanf( gamma, "%f %f %f", &v->RedGamma, &v->GreenGamma, &v->BlueGamma );
      if (v->RedGamma<=0.0)    v->RedGamma = 1.0;
      if (v->GreenGamma<=0.0)  v->GreenGamma = v->RedGamma;
      if (v->BlueGamma<=0.0)   v->BlueGamma = v->RedGamma;
   }
   else {
      v->RedGamma = v->GreenGamma = v->BlueGamma = 1.0;
   }

   v->ximage_flag = ximage_flag;

   v->mesa_visual.redMask = visinfo->red_mask;
   v->mesa_visual.greenMask = visinfo->green_mask;
   v->mesa_visual.blueMask = visinfo->blue_mask;
   v->visualID = visinfo->visualid;
   v->screen = visinfo->screen;

#if !(defined(__cplusplus) || defined(c_plusplus))
   v->visualType = xmesa_convert_from_x_visual_type(visinfo->class);
#else
   v->visualType = xmesa_convert_from_x_visual_type(visinfo->c_class);
#endif

   v->mesa_visual.visualRating = visualCaveat;

   if (alpha_flag)
      v->mesa_visual.alphaBits = 8;

   (void) initialize_visual_and_buffer( v, NULL, 0, 0 );

   {
      const int xclass = v->visualType;
      if (xclass == GLX_TRUE_COLOR || xclass == GLX_DIRECT_COLOR) {
         red_bits   = _mesa_bitcount(GET_REDMASK(v));
         green_bits = _mesa_bitcount(GET_GREENMASK(v));
         blue_bits  = _mesa_bitcount(GET_BLUEMASK(v));
      }
      else {
         /* this is an approximation */
         int depth;
         depth = GET_VISUAL_DEPTH(v);
         red_bits = depth / 3;
         depth -= red_bits;
         green_bits = depth / 2;
         depth -= green_bits;
         blue_bits = depth;
         alpha_bits = 0;
         assert( red_bits + green_bits + blue_bits == GET_VISUAL_DEPTH(v) );
      }
      alpha_bits = v->mesa_visual.alphaBits;
   }

   if (!_mesa_initialize_visual(&v->mesa_visual,
                                db_flag, stereo_flag,
                                red_bits, green_bits,
                                blue_bits, alpha_bits,
                                depth_size,
                                stencil_size,
                                accum_red_size, accum_green_size,
                                accum_blue_size, accum_alpha_size,
                                0)) {
      free(v);
      return NULL;
   }

   /* XXX minor hack */
   v->mesa_visual.level = level;
   return v;
}


PUBLIC
void XMesaDestroyVisual( XMesaVisual v )
{
   free(v->visinfo);
   free(v);
}



/**
 * Create a new XMesaContext.
 * \param v  the XMesaVisual
 * \param share_list  another XMesaContext with which to share display
 *                    lists or NULL if no sharing is wanted.
 * \return an XMesaContext or NULL if error.
 */
PUBLIC
XMesaContext XMesaCreateContext( XMesaVisual v, XMesaContext share_list )
{
   static GLboolean firstTime = GL_TRUE;
   XMesaContext c;
   struct gl_context *mesaCtx;
   struct dd_function_table functions;
   TNLcontext *tnl;

   if (firstTime) {
      mtx_init(&_xmesa_lock, mtx_plain);
      firstTime = GL_FALSE;
   }

   /* Note: the XMesaContext contains a Mesa struct gl_context struct (inheritance) */
   c = (XMesaContext) CALLOC_STRUCT(xmesa_context);
   if (!c)
      return NULL;

   mesaCtx = &(c->mesa);

   /* initialize with default driver functions, then plug in XMesa funcs */
   _mesa_init_driver_functions(&functions);
   xmesa_init_driver_functions(v, &functions);
   if (!_mesa_initialize_context(mesaCtx, API_OPENGL_COMPAT, &v->mesa_visual,
                      share_list ? &(share_list->mesa) : (struct gl_context *) NULL,
                      &functions)) {
      free(c);
      return NULL;
   }

   /* Enable this to exercise fixed function -> shader translation
    * with software rendering.
    */
   if (0) {
      mesaCtx->VertexProgram._MaintainTnlProgram = GL_TRUE;
      mesaCtx->FragmentProgram._MaintainTexEnvProgram = GL_TRUE;
   }

   _mesa_enable_sw_extensions(mesaCtx);

#if ENABLE_EXT_timer_query
    mesaCtx->Extensions.EXT_timer_query = GL_TRUE;
#endif


   /* finish up xmesa context initializations */
   c->direct = GL_TRUE;
   c->swapbytes = CHECK_BYTE_ORDER(v) ? GL_FALSE : GL_TRUE;
   c->xm_visual = v;
   c->xm_buffer = NULL;   /* set later by XMesaMakeCurrent */
   c->display = v->display;
   c->pixelformat = v->dithered_pf;      /* Dithering is enabled by default */

   /* Initialize the software rasterizer and helper modules.
    */
   if (!_swrast_CreateContext( mesaCtx ) ||
       !_vbo_CreateContext( mesaCtx ) ||
       !_tnl_CreateContext( mesaCtx ) ||
       !_swsetup_CreateContext( mesaCtx )) {
      _mesa_free_context_data(&c->mesa);
      free(c);
      return NULL;
   }

   /* tnl setup */
   tnl = TNL_CONTEXT(mesaCtx);
   tnl->Driver.RunPipeline = _tnl_run_pipeline;
   /* swrast setup */
   xmesa_register_swrast_functions( mesaCtx );
   _swsetup_Wakeup(mesaCtx);

   _mesa_meta_init(mesaCtx);

   _mesa_compute_version(mesaCtx);

    /* Exec table initialization requires the version to be computed */
   _mesa_initialize_dispatch_tables(mesaCtx);
   _mesa_initialize_vbo_vtxfmt(mesaCtx);

   return c;
}



PUBLIC
void XMesaDestroyContext( XMesaContext c )
{
   struct gl_context *mesaCtx = &c->mesa;

   _mesa_meta_free( mesaCtx );

   _swsetup_DestroyContext( mesaCtx );
   _swrast_DestroyContext( mesaCtx );
   _tnl_DestroyContext( mesaCtx );
   _vbo_DestroyContext( mesaCtx );
   _mesa_free_context_data( mesaCtx );
   free( c );
}



/**
 * Private function for creating an XMesaBuffer which corresponds to an
 * X window or pixmap.
 * \param v  the window's XMesaVisual
 * \param w  the window we're wrapping
 * \return  new XMesaBuffer or NULL if error
 */
PUBLIC XMesaBuffer
XMesaCreateWindowBuffer(XMesaVisual v, XMesaWindow w)
{
   XWindowAttributes attr;
   XMesaBuffer b;
   XMesaColormap cmap;
   int depth;

   assert(v);
   assert(w);

   /* Check that window depth matches visual depth */
   XGetWindowAttributes( v->display, w, &attr );
   depth = attr.depth;
   if (GET_VISUAL_DEPTH(v) != depth) {
      _mesa_warning(NULL, "XMesaCreateWindowBuffer: depth mismatch between visual (%d) and window (%d)!\n",
                    GET_VISUAL_DEPTH(v), depth);
      return NULL;
   }

   /* Find colormap */
   if (attr.colormap) {
      cmap = attr.colormap;
   }
   else {
      _mesa_warning(NULL, "Window %u has no colormap!\n", (unsigned int) w);
      /* this is weird, a window w/out a colormap!? */
      /* OK, let's just allocate a new one and hope for the best */
      cmap = XCreateColormap(v->display, w, attr.visual, AllocNone);
   }

   b = create_xmesa_buffer((XMesaDrawable) w, WINDOW, v, cmap);
   if (!b)
      return NULL;

   if (!initialize_visual_and_buffer( v, b, (XMesaDrawable) w, cmap )) {
      xmesa_free_buffer(b);
      return NULL;
   }

   return b;
}



/**
 * Create a new XMesaBuffer from an X pixmap.
 *
 * \param v    the XMesaVisual
 * \param p    the pixmap
 * \param cmap the colormap, may be 0 if using a \c GLX_TRUE_COLOR or
 *             \c GLX_DIRECT_COLOR visual for the pixmap
 * \returns new XMesaBuffer or NULL if error
 */
PUBLIC XMesaBuffer
XMesaCreatePixmapBuffer(XMesaVisual v, XMesaPixmap p, XMesaColormap cmap)
{
   XMesaBuffer b;

   assert(v);

   b = create_xmesa_buffer((XMesaDrawable) p, PIXMAP, v, cmap);
   if (!b)
      return NULL;

   if (!initialize_visual_and_buffer(v, b, (XMesaDrawable) p, cmap)) {
      xmesa_free_buffer(b);
      return NULL;
   }

   return b;
}


/**
 * For GLX_EXT_texture_from_pixmap
 */
XMesaBuffer
XMesaCreatePixmapTextureBuffer(XMesaVisual v, XMesaPixmap p,
                               XMesaColormap cmap,
                               int format, int target, int mipmap)
{
   GET_CURRENT_CONTEXT(ctx);
   XMesaBuffer b;
   GLuint width, height;

   assert(v);

   b = create_xmesa_buffer((XMesaDrawable) p, PIXMAP, v, cmap);
   if (!b)
      return NULL;

   /* get pixmap size, update framebuffer/renderbuffer dims */
   xmesa_get_window_size(v->display, b, &width, &height);
   _mesa_resize_framebuffer(NULL, &(b->mesa_buffer), width, height);

   if (target == 0) {
      /* examine dims */
      if (ctx->Extensions.ARB_texture_non_power_of_two) {
         target = GLX_TEXTURE_2D_EXT;
      }
      else if (   _mesa_bitcount(width)  == 1
               && _mesa_bitcount(height) == 1) {
         /* power of two size */
         if (height == 1) {
            target = GLX_TEXTURE_1D_EXT;
         }
         else {
            target = GLX_TEXTURE_2D_EXT;
         }
      }
      else if (ctx->Extensions.NV_texture_rectangle) {
         target = GLX_TEXTURE_RECTANGLE_EXT;
      }
      else {
         /* non power of two textures not supported */
         XMesaDestroyBuffer(b);
         return 0;
      }
   }

   b->TextureTarget = target;
   b->TextureFormat = format;
   b->TextureMipmap = mipmap;

   if (!initialize_visual_and_buffer(v, b, (XMesaDrawable) p, cmap)) {
      xmesa_free_buffer(b);
      return NULL;
   }

   return b;
}



XMesaBuffer
XMesaCreatePBuffer(XMesaVisual v, XMesaColormap cmap,
                   unsigned int width, unsigned int height)
{
   XMesaWindow root;
   XMesaDrawable drawable;  /* X Pixmap Drawable */
   XMesaBuffer b;

   /* allocate pixmap for front buffer */
   root = RootWindow( v->display, v->visinfo->screen );
   drawable = XCreatePixmap(v->display, root, width, height,
                            v->visinfo->depth);
   if (!drawable)
      return NULL;

   b = create_xmesa_buffer(drawable, PBUFFER, v, cmap);
   if (!b)
      return NULL;

   if (!initialize_visual_and_buffer(v, b, drawable, cmap)) {
      xmesa_free_buffer(b);
      return NULL;
   }

   return b;
}



/*
 * Deallocate an XMesaBuffer structure and all related info.
 */
PUBLIC void
XMesaDestroyBuffer(XMesaBuffer b)
{
   xmesa_free_buffer(b);
}


/**
 * Query the current window size and update the corresponding struct gl_framebuffer
 * and all attached renderbuffers.
 * Called when:
 *  1. the first time a buffer is bound to a context.
 *  2. from glViewport to poll for window size changes
 *  3. from the XMesaResizeBuffers() API function.
 * Note: it's possible (and legal) for xmctx to be NULL.  That can happen
 * when resizing a buffer when no rendering context is bound.
 */
void
xmesa_check_and_update_buffer_size(XMesaContext xmctx, XMesaBuffer drawBuffer)
{
   GLuint width, height;
   xmesa_get_window_size(drawBuffer->display, drawBuffer, &width, &height);
   if (drawBuffer->mesa_buffer.Width != width ||
       drawBuffer->mesa_buffer.Height != height) {
      struct gl_context *ctx = xmctx ? &xmctx->mesa : NULL;
      _mesa_resize_framebuffer(ctx, &(drawBuffer->mesa_buffer), width, height);
   }
}


/*
 * Bind buffer b to context c and make c the current rendering context.
 */
GLboolean XMesaMakeCurrent( XMesaContext c, XMesaBuffer b )
{
   return XMesaMakeCurrent2( c, b, b );
}


/*
 * Bind buffer b to context c and make c the current rendering context.
 */
PUBLIC
GLboolean XMesaMakeCurrent2( XMesaContext c, XMesaBuffer drawBuffer,
                             XMesaBuffer readBuffer )
{
   if (c) {
      if (!drawBuffer || !readBuffer)
         return GL_FALSE;  /* must specify buffers! */

      if (&(c->mesa) == _mesa_get_current_context()
          && c->mesa.DrawBuffer == &drawBuffer->mesa_buffer
          && c->mesa.ReadBuffer == &readBuffer->mesa_buffer
          && XMESA_BUFFER(c->mesa.DrawBuffer)->wasCurrent) {
         /* same context and buffer, do nothing */
         return GL_TRUE;
      }

      c->xm_buffer = drawBuffer;

      /* Call this periodically to detect when the user has begun using
       * GL rendering from multiple threads.
       */
      _glapi_check_multithread();

      xmesa_check_and_update_buffer_size(c, drawBuffer);
      if (readBuffer != drawBuffer)
         xmesa_check_and_update_buffer_size(c, readBuffer);

      _mesa_make_current(&(c->mesa),
                         &drawBuffer->mesa_buffer,
                         &readBuffer->mesa_buffer);

      /*
       * Must recompute and set these pixel values because colormap
       * can be different for different windows.
       */
      c->clearpixel = xmesa_color_to_pixel( &c->mesa,
					    c->clearcolor[0],
					    c->clearcolor[1],
					    c->clearcolor[2],
					    c->clearcolor[3],
					    c->xm_visual->undithered_pf);
      XMesaSetForeground(c->display, drawBuffer->cleargc, c->clearpixel);

      /* Solution to Stephane Rehel's problem with glXReleaseBuffersMESA(): */
      drawBuffer->wasCurrent = GL_TRUE;
   }
   else {
      /* Detach */
      _mesa_make_current( NULL, NULL, NULL );
   }
   return GL_TRUE;
}


/*
 * Unbind the context c from its buffer.
 */
GLboolean XMesaUnbindContext( XMesaContext c )
{
   /* A no-op for XFree86 integration purposes */
   return GL_TRUE;
}


XMesaContext XMesaGetCurrentContext( void )
{
   GET_CURRENT_CONTEXT(ctx);
   if (ctx) {
      XMesaContext xmesa = XMESA_CONTEXT(ctx);
      return xmesa;
   }
   else {
      return 0;
   }
}


XMesaBuffer XMesaGetCurrentBuffer( void )
{
   GET_CURRENT_CONTEXT(ctx);
   if (ctx) {
      XMesaBuffer xmbuf = XMESA_BUFFER(ctx->DrawBuffer);
      return xmbuf;
   }
   else {
      return 0;
   }
}


/* New in Mesa 3.1 */
XMesaBuffer XMesaGetCurrentReadBuffer( void )
{
   GET_CURRENT_CONTEXT(ctx);
   if (ctx) {
      return XMESA_BUFFER(ctx->ReadBuffer);
   }
   else {
      return 0;
   }
}



GLboolean XMesaSetFXmode( GLint mode )
{
   (void) mode;
   return GL_FALSE;
}



/*
 * Copy the back buffer to the front buffer.  If there's no back buffer
 * this is a no-op.
 */
PUBLIC
void XMesaSwapBuffers( XMesaBuffer b )
{
   GET_CURRENT_CONTEXT(ctx);

   if (!b->backxrb) {
      /* single buffered */
      return;
   }

   /* If we're swapping the buffer associated with the current context
    * we have to flush any pending rendering commands first.
    */
   if (ctx && ctx->DrawBuffer == &(b->mesa_buffer))
      _mesa_notifySwapBuffers(ctx);

   if (b->db_mode) {
      if (b->backxrb->ximage) {
	 /* Copy Ximage (back buf) from client memory to server window */
#if defined(USE_XSHM) 
	 if (b->shm) {
            /*mtx_lock(&_xmesa_lock);*/
	    XShmPutImage( b->xm_visual->display, b->frontxrb->drawable,
			  b->swapgc,
			  b->backxrb->ximage, 0, 0,
			  0, 0, b->mesa_buffer.Width, b->mesa_buffer.Height,
                          False );
            /*mtx_unlock(&_xmesa_lock);*/
	 }
	 else
#endif
         {
            /*mtx_lock(&_xmesa_lock);*/
            XMesaPutImage( b->xm_visual->display, b->frontxrb->drawable,
			   b->swapgc,
			   b->backxrb->ximage, 0, 0,
			   0, 0, b->mesa_buffer.Width, b->mesa_buffer.Height );
            /*mtx_unlock(&_xmesa_lock);*/
         }
      }
      else if (b->backxrb->pixmap) {
	 /* Copy pixmap (back buf) to window (front buf) on server */
         /*mtx_lock(&_xmesa_lock);*/
	 XMesaCopyArea( b->xm_visual->display,
			b->backxrb->pixmap,   /* source drawable */
			b->frontxrb->drawable,  /* dest. drawable */
			b->swapgc,
			0, 0, b->mesa_buffer.Width, b->mesa_buffer.Height,
			0, 0                 /* dest region */
		      );
         /*mtx_unlock(&_xmesa_lock);*/
      }
   }
   XSync( b->xm_visual->display, False );
}



/*
 * Copy sub-region of back buffer to front buffer
 */
void XMesaCopySubBuffer( XMesaBuffer b, int x, int y, int width, int height )
{
   GET_CURRENT_CONTEXT(ctx);

   /* If we're swapping the buffer associated with the current context
    * we have to flush any pending rendering commands first.
    */
   if (ctx && ctx->DrawBuffer == &(b->mesa_buffer))
      _mesa_notifySwapBuffers(ctx);

   if (!b->backxrb) {
      /* single buffered */
      return; 
   }

   if (b->db_mode) {
      int yTop = b->mesa_buffer.Height - y - height;
      if (b->backxrb->ximage) {
         /* Copy Ximage from host's memory to server's window */
#if defined(USE_XSHM) 
         if (b->shm) {
            /* XXX assuming width and height aren't too large! */
            XShmPutImage( b->xm_visual->display, b->frontxrb->drawable,
                          b->swapgc,
                          b->backxrb->ximage, x, yTop,
                          x, yTop, width, height, False );
            /* wait for finished event??? */
         }
         else
#endif
         {
            /* XXX assuming width and height aren't too large! */
            XMesaPutImage( b->xm_visual->display, b->frontxrb->drawable,
			   b->swapgc,
			   b->backxrb->ximage, x, yTop,
			   x, yTop, width, height );
         }
      }
      else {
         /* Copy pixmap to window on server */
         XMesaCopyArea( b->xm_visual->display,
			b->backxrb->pixmap,           /* source drawable */
			b->frontxrb->drawable,        /* dest. drawable */
			b->swapgc,
			x, yTop, width, height,  /* source region */
			x, yTop                  /* dest region */
                      );
      }
   }
}


/*
 * Return a pointer to the XMesa backbuffer Pixmap or XImage.  This function
 * is a way to get "under the hood" of X/Mesa so one can manipulate the
 * back buffer directly.
 * Output:  pixmap - pointer to back buffer's Pixmap, or 0
 *          ximage - pointer to back buffer's XImage, or NULL
 * Return:  GL_TRUE = context is double buffered
 *          GL_FALSE = context is single buffered
 */
GLboolean XMesaGetBackBuffer( XMesaBuffer b,
                              XMesaPixmap *pixmap,
                              XMesaImage **ximage )
{
   if (b->db_mode) {
      if (pixmap)
         *pixmap = b->backxrb->pixmap;
      if (ximage)
         *ximage = b->backxrb->ximage;
      return GL_TRUE;
   }
   else {
      *pixmap = 0;
      *ximage = NULL;
      return GL_FALSE;
   }
}


/*
 * Return the depth buffer associated with an XMesaBuffer.
 * Input:  b - the XMesa buffer handle
 * Output:  width, height - size of buffer in pixels
 *          bytesPerValue - bytes per depth value (2 or 4)
 *          buffer - pointer to depth buffer values
 * Return:  GL_TRUE or GL_FALSE to indicate success or failure.
 */
GLboolean XMesaGetDepthBuffer( XMesaBuffer b, GLint *width, GLint *height,
                               GLint *bytesPerValue, void **buffer )
{
   struct gl_renderbuffer *rb
      = b->mesa_buffer.Attachment[BUFFER_DEPTH].Renderbuffer;
   struct xmesa_renderbuffer *xrb = xmesa_renderbuffer(rb);

   if (!xrb || !xrb->Base.Buffer) {
      *width = 0;
      *height = 0;
      *bytesPerValue = 0;
      *buffer = 0;
      return GL_FALSE;
   }
   else {
      *width = b->mesa_buffer.Width;
      *height = b->mesa_buffer.Height;
      *bytesPerValue = b->mesa_buffer.Visual.depthBits <= 16
         ? sizeof(GLushort) : sizeof(GLuint);
      *buffer = (void *) xrb->Base.Buffer;
      return GL_TRUE;
   }
}


void XMesaFlush( XMesaContext c )
{
   if (c && c->xm_visual) {
      XSync( c->xm_visual->display, False );
   }
}



const char *XMesaGetString( XMesaContext c, int name )
{
   (void) c;
   if (name==XMESA_VERSION) {
      return "5.0";
   }
   else if (name==XMESA_EXTENSIONS) {
      return "";
   }
   else {
      return NULL;
   }
}



XMesaBuffer XMesaFindBuffer( XMesaDisplay *dpy, XMesaDrawable d )
{
   XMesaBuffer b;
   for (b=XMesaBufferList; b; b=b->Next) {
      if (b->frontxrb->drawable == d && b->display == dpy) {
         return b;
      }
   }
   return NULL;
}


/**
 * Free/destroy all XMesaBuffers associated with given display.
 */
void xmesa_destroy_buffers_on_display(XMesaDisplay *dpy)
{
   XMesaBuffer b, next;
   for (b = XMesaBufferList; b; b = next) {
      next = b->Next;
      if (b->display == dpy) {
         xmesa_free_buffer(b);
      }
   }
}


/*
 * Look for XMesaBuffers whose X window has been destroyed.
 * Deallocate any such XMesaBuffers.
 */
void XMesaGarbageCollect( XMesaDisplay* dpy )
{
   XMesaBuffer b, next;
   for (b=XMesaBufferList; b; b=next) {
      next = b->Next;
      if (b->display && b->display == dpy && b->frontxrb->drawable && b->type == WINDOW) {
         XSync(b->display, False);
         if (!window_exists( b->display, b->frontxrb->drawable )) {
            /* found a dead window, free the ancillary info */
            XMesaDestroyBuffer( b );
         }
      }
   }
}


unsigned long XMesaDitherColor( XMesaContext xmesa, GLint x, GLint y,
                                GLfloat red, GLfloat green,
                                GLfloat blue, GLfloat alpha )
{
   GLint r = (GLint) (red   * 255.0F);
   GLint g = (GLint) (green * 255.0F);
   GLint b = (GLint) (blue  * 255.0F);
   GLint a = (GLint) (alpha * 255.0F);

   switch (xmesa->pixelformat) {
      case PF_Truecolor:
         {
            unsigned long p;
            PACK_TRUECOLOR( p, r, g, b );
            return p;
         }
      case PF_8A8B8G8R:
         return PACK_8A8B8G8R( r, g, b, a );
      case PF_8A8R8G8B:
         return PACK_8A8R8G8B( r, g, b, a );
      case PF_8R8G8B:
         return PACK_8R8G8B( r, g, b );
      case PF_5R6G5B:
         return PACK_5R6G5B( r, g, b );
      case PF_Dither_5R6G5B:
         /* fall through */
      case PF_Dither_True:
         {
            unsigned long p;
            PACK_TRUEDITHER(p, x, y, r, g, b);
            return p;
         }
      default:
         _mesa_problem(NULL, "Bad pixel format in XMesaDitherColor");
   }
   return 0;
}


/*
 * This is typically called when the window size changes and we need
 * to reallocate the buffer's back/depth/stencil/accum buffers.
 */
PUBLIC void
XMesaResizeBuffers( XMesaBuffer b )
{
   GET_CURRENT_CONTEXT(ctx);
   XMesaContext xmctx = XMESA_CONTEXT(ctx);
   if (!xmctx)
      return;
   xmesa_check_and_update_buffer_size(xmctx, b);
}


static GLint
xbuffer_to_renderbuffer(int buffer)
{
   assert(MAX_AUX_BUFFERS <= 4);

   switch (buffer) {
   case GLX_FRONT_LEFT_EXT:
      return BUFFER_FRONT_LEFT;
   case GLX_FRONT_RIGHT_EXT:
      return BUFFER_FRONT_RIGHT;
   case GLX_BACK_LEFT_EXT:
      return BUFFER_BACK_LEFT;
   case GLX_BACK_RIGHT_EXT:
      return BUFFER_BACK_RIGHT;
   case GLX_AUX0_EXT:
      return BUFFER_AUX0;
   case GLX_AUX1_EXT:
   case GLX_AUX2_EXT:
   case GLX_AUX3_EXT:
   case GLX_AUX4_EXT:
   case GLX_AUX5_EXT:
   case GLX_AUX6_EXT:
   case GLX_AUX7_EXT:
   case GLX_AUX8_EXT:
   case GLX_AUX9_EXT:
   default:
      /* BadValue error */
      return -1;
   }
}


PUBLIC void
XMesaBindTexImage(XMesaDisplay *dpy, XMesaBuffer drawable, int buffer,
                  const int *attrib_list)
{
#if 0
   GET_CURRENT_CONTEXT(ctx);
   const GLuint unit = ctx->Texture.CurrentUnit;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *texObj;
#endif
   struct gl_renderbuffer *rb;
   struct xmesa_renderbuffer *xrb;
   GLint b;
   XMesaImage *img = NULL;
   GLboolean freeImg = GL_FALSE;

   b = xbuffer_to_renderbuffer(buffer);
   if (b < 0)
      return;

   if (drawable->TextureFormat == GLX_TEXTURE_FORMAT_NONE_EXT)
      return; /* BadMatch error */

   rb = drawable->mesa_buffer.Attachment[b].Renderbuffer;
   if (!rb) {
      /* invalid buffer */
      return;
   }
   xrb = xmesa_renderbuffer(rb);

#if 0
   switch (drawable->TextureTarget) {
   case GLX_TEXTURE_1D_EXT:
      texObj = texUnit->CurrentTex[TEXTURE_1D_INDEX];
      break;
   case GLX_TEXTURE_2D_EXT:
      texObj = texUnit->CurrentTex[TEXTURE_2D_INDEX];
      break;
   case GLX_TEXTURE_RECTANGLE_EXT:
      texObj = texUnit->CurrentTex[TEXTURE_RECT_INDEX];
      break;
   default:
      return; /* BadMatch error */
   }
#endif

   /*
    * The following is a quick and simple way to implement
    * BindTexImage.  The better way is to write some new FetchTexel()
    * functions which would extract texels from XImages.  We'd still
    * need to use GetImage when texturing from a Pixmap (front buffer)
    * but texturing from a back buffer (XImage) would avoid an image
    * copy.
    */

   /* get XImage */
   if (xrb->pixmap) {
      img = XMesaGetImage(dpy, xrb->pixmap, 0, 0, rb->Width, rb->Height, ~0L,
			  ZPixmap);
      freeImg = GL_TRUE;
   }
   else if (xrb->ximage) {
      img = xrb->ximage;
   }

   /* store the XImage as a new texture image */
   if (img) {
      GLenum format, type, intFormat;
      if (img->bits_per_pixel == 32) {
         format = GL_BGRA;
         type = GL_UNSIGNED_BYTE;
         intFormat = GL_RGBA;
      }
      else if (img->bits_per_pixel == 24) {
         format = GL_BGR;
         type = GL_UNSIGNED_BYTE;
         intFormat = GL_RGB;
      }
      else if (img->bits_per_pixel == 16) {
         format = GL_BGR;
         type = GL_UNSIGNED_SHORT_5_6_5;
         intFormat = GL_RGB;
      }
      else {
         _mesa_problem(NULL, "Unexpected XImage format in XMesaBindTexImage");
         return;
      }
      if (drawable->TextureFormat == GLX_TEXTURE_FORMAT_RGBA_EXT) {
         intFormat = GL_RGBA;
      }
      else if (drawable->TextureFormat == GLX_TEXTURE_FORMAT_RGB_EXT) {
         intFormat = GL_RGB;
      }

      _mesa_TexImage2D(GL_TEXTURE_2D, 0, intFormat, rb->Width, rb->Height, 0,
                       format, type, img->data);

      if (freeImg) {
	 XMesaDestroyImage(img);
      }
   }
}



PUBLIC void
XMesaReleaseTexImage(XMesaDisplay *dpy, XMesaBuffer drawable, int buffer)
{
   const GLint b = xbuffer_to_renderbuffer(buffer);
   if (b < 0)
      return;

   /* no-op for now */
}

@


1.12
log
@Merge Mesa 10.2.9
@
text
@@


1.11
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d585 1
a585 1
   if (getenv("MESA_NO_DITHER")) {
d595 1
a595 1
   if (getenv("MESA_INFO")) {
d763 1
a763 1
   if (getenv("MESA_XSYNC")) {
d794 1
a794 1
   gamma = getenv("MESA_GAMMA");
@


1.10
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d585 1
a585 1
   if (_mesa_getenv("MESA_NO_DITHER")) {
d595 1
a595 1
   if (_mesa_getenv("MESA_INFO")) {
d763 1
a763 1
   if (_mesa_getenv("MESA_XSYNC")) {
d794 1
a794 1
   gamma = _mesa_getenv("MESA_GAMMA");
@


1.9
log
@Merge Mesa 9.2.0
@
text
@a76 1
#include "glapi/glthread.h"
d90 1
a90 1
_glthread_Mutex _xmesa_lock;
d250 1
a250 1
   _glthread_LOCK_MUTEX(_xmesa_lock);
d253 1
a253 1
   _glthread_UNLOCK_MUTEX(_xmesa_lock);
d858 1
a858 1
      FREE(v);
d894 1
a894 1
      _glthread_INIT_MUTEX(_xmesa_lock);
d931 1
d1339 1
a1339 1
            /*_glthread_LOCK_MUTEX(_xmesa_lock);*/
d1345 1
a1345 1
            /*_glthread_UNLOCK_MUTEX(_xmesa_lock);*/
d1350 1
a1350 1
            /*_glthread_LOCK_MUTEX(_xmesa_lock);*/
d1355 1
a1355 1
            /*_glthread_UNLOCK_MUTEX(_xmesa_lock);*/
d1360 1
a1360 1
         /*_glthread_LOCK_MUTEX(_xmesa_lock);*/
d1368 1
a1368 1
         /*_glthread_UNLOCK_MUTEX(_xmesa_lock);*/
@


1.8
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d67 1
d75 2
d79 1
a94 62
/**
 * Lookup tables for HPCR pixel format:
 */
static short hpcr_rgbTbl[3][256] = {
{
 16,  16,  17,  17,  18,  18,  19,  19,  20,  20,  21,  21,  22,  22,  23,  23,
 24,  24,  25,  25,  26,  26,  27,  27,  28,  28,  29,  29,  30,  30,  31,  31,
 32,  32,  33,  33,  34,  34,  35,  35,  36,  36,  37,  37,  38,  38,  39,  39,
 32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,
 48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,
 64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
 80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,
 96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239
},
{
 16,  16,  17,  17,  18,  18,  19,  19,  20,  20,  21,  21,  22,  22,  23,  23,
 24,  24,  25,  25,  26,  26,  27,  27,  28,  28,  29,  29,  30,  30,  31,  31,
 32,  32,  33,  33,  34,  34,  35,  35,  36,  36,  37,  37,  38,  38,  39,  39,
 32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,
 48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,
 64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
 80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,
 96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239
},
{
 32,  32,  33,  33,  34,  34,  35,  35,  36,  36,  37,  37,  38,  38,  39,  39,
 40,  40,  41,  41,  42,  42,  43,  43,  44,  44,  45,  45,  46,  46,  47,  47,
 48,  48,  49,  49,  50,  50,  51,  51,  52,  52,  53,  53,  54,  54,  55,  55,
 56,  56,  57,  57,  58,  58,  59,  59,  60,  60,  61,  61,  62,  62,  63,  63,
 64,  64,  65,  65,  66,  66,  67,  67,  68,  68,  69,  69,  70,  70,  71,  71,
 72,  72,  73,  73,  74,  74,  75,  75,  76,  76,  77,  77,  78,  78,  79,  79,
 80,  80,  81,  81,  82,  82,  83,  83,  84,  84,  85,  85,  86,  86,  87,  87,
 80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,
 96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223
}
};



d120 1
a120 2
   int major, minor, ignore;
   Bool pixmaps;
d123 7
a129 6
      if (XShmQueryVersion( display, &major, &minor, &pixmaps )==True) {
	 return (pixmaps==True) ? 2 : 1;
      }
      else {
	 return 0;
      }
d177 1
a177 1
		       (char*) MALLOC(8),    /*data*/
d306 1
a306 1
   b->frontxrb = xmesa_new_renderbuffer(NULL, 0, &vis->mesa_visual, GL_FALSE);
d315 1
a315 1
                          &b->frontxrb->Base);
d321 1
a321 1
      b->backxrb = xmesa_new_renderbuffer(NULL, 0, &vis->mesa_visual, GL_TRUE);
d332 1
a332 16
                             &b->backxrb->Base);
   }

   /*
    * Software alpha planes
    */
   if (vis->mesa_visual.alphaBits > 0
       && vis->undithered_pf != PF_8A8B8G8R
       && vis->undithered_pf != PF_8A8R8G8B) {
      /* Visual has alpha, but pixel format doesn't support it.
       * We'll use an alpha renderbuffer wrapper.
       */
      b->swAlpha = GL_TRUE;
   }
   else {
      b->swAlpha = GL_FALSE;
d338 7
a344 7
   _mesa_add_soft_renderbuffers(&b->mesa_buffer,
                                GL_FALSE,  /* color */
                                vis->mesa_visual.haveDepthBuffer,
                                vis->mesa_visual.haveStencilBuffer,
                                vis->mesa_visual.haveAccumBuffer,
                                b->swAlpha,
                                vis->mesa_visual.numAuxBuffers > 0 );
a414 15
/**
 * Copy X color table stuff from one XMesaBuffer to another.
 */
static void
copy_colortable_info(XMesaBuffer dst, const XMesaBuffer src)
{
   memcpy(dst->color_table, src->color_table, sizeof(src->color_table));
   memcpy(dst->pixel_to_r, src->pixel_to_r, sizeof(src->pixel_to_r));
   memcpy(dst->pixel_to_g, src->pixel_to_g, sizeof(src->pixel_to_g));
   memcpy(dst->pixel_to_b, src->pixel_to_b, sizeof(src->pixel_to_b));
   dst->num_alloced = src->num_alloced;
   memcpy(dst->alloced_colors, src->alloced_colors,
          sizeof(src->alloced_colors));
}

a422 319
 * A replacement for XAllocColor.  This function should never
 * fail to allocate a color.  When XAllocColor fails, we return
 * the nearest matching color.  If we have to allocate many colors
 * this function isn't too efficient; the XQueryColors() could be
 * done just once.
 * Written by Michael Pichler, Brian Paul, Mark Kilgard
 * Input:  dpy - X display
 *         cmap - X colormap
 *         cmapSize - size of colormap
 * In/Out: color - the XColor struct
 * Output:  exact - 1=exact color match, 0=closest match
 *          alloced - 1=XAlloc worked, 0=XAlloc failed
 */
static void
noFaultXAllocColor( int client,
                    XMesaDisplay *dpy,
                    XMesaColormap cmap,
                    int cmapSize,
                    XMesaColor *color,
                    int *exact, int *alloced )
{
   /* we'll try to cache ctable for better remote display performance */
   static Display *prevDisplay = NULL;
   static XMesaColormap prevCmap = 0;
   static int prevCmapSize = 0;
   static XMesaColor *ctable = NULL;
   XMesaColor subColor;
   int i, bestmatch;
   double mindist;       /* 3*2^16^2 exceeds long int precision. */

   (void) client;

   /* First try just using XAllocColor. */
   if (XAllocColor(dpy, cmap, color))
   {
      *exact = 1;
      *alloced = 1;
      return;
   }

   /* Alloc failed, search for closest match */

   /* Retrieve color table entries. */
   /* XXX alloca candidate. */
   if (prevDisplay != dpy || prevCmap != cmap
       || prevCmapSize != cmapSize || !ctable) {
      /* free previously cached color table */
      if (ctable)
         free(ctable);
      /* Get the color table from X */
      ctable = (XMesaColor *) MALLOC(cmapSize * sizeof(XMesaColor));
      assert(ctable);
      for (i = 0; i < cmapSize; i++) {
         ctable[i].pixel = i;
      }
      XQueryColors(dpy, cmap, ctable, cmapSize);
      prevDisplay = dpy;
      prevCmap = cmap;
      prevCmapSize = cmapSize;
   }

   /* Find best match. */
   bestmatch = -1;
   mindist = 0.0;
   for (i = 0; i < cmapSize; i++) {
      double dr = 0.30 * ((double) color->red - (double) ctable[i].red);
      double dg = 0.59 * ((double) color->green - (double) ctable[i].green);
      double db = 0.11 * ((double) color->blue - (double) ctable[i].blue);
      double dist = dr * dr + dg * dg + db * db;
      if (bestmatch < 0 || dist < mindist) {
         bestmatch = i;
         mindist = dist;
      }
   }

   /* Return result. */
   subColor.red   = ctable[bestmatch].red;
   subColor.green = ctable[bestmatch].green;
   subColor.blue  = ctable[bestmatch].blue;
   /* Try to allocate the closest match color.  This should only
    * fail if the cell is read/write.  Otherwise, we're incrementing
    * the cell's reference count.
    */
   if (XAllocColor(dpy, cmap, &subColor)) {
      *alloced = 1;
   }
   else {
      /* do this to work around a problem reported by Frank Ortega */
      subColor.pixel = (unsigned long) bestmatch;
      subColor.red   = ctable[bestmatch].red;
      subColor.green = ctable[bestmatch].green;
      subColor.blue  = ctable[bestmatch].blue;
      subColor.flags = DoRed | DoGreen | DoBlue;
      *alloced = 0;
   }
   /* don't free table, save it for next time */

   *color = subColor;
   *exact = 0;
}



/**
 * Do setup for PF_GRAYSCALE pixel format.
 * Note that buffer may be NULL.
 */
static GLboolean
setup_grayscale(int client, XMesaVisual v,
                XMesaBuffer buffer, XMesaColormap cmap)
{
   if (GET_VISUAL_DEPTH(v)<4 || GET_VISUAL_DEPTH(v)>16) {
      return GL_FALSE;
   }

   if (buffer) {
      XMesaBuffer prevBuffer;

      if (!cmap) {
         return GL_FALSE;
      }

      prevBuffer = xmesa_find_buffer(v->display, cmap, buffer);
      if (prevBuffer) {
         /* Copy colormap stuff from previous XMesaBuffer which uses same
          * X colormap.  Do this to avoid time spent in noFaultXAllocColor.
          */
         copy_colortable_info(buffer, prevBuffer);
      }
      else {
         /* Allocate 256 shades of gray */
         int gray;
         int colorsfailed = 0;
         for (gray=0;gray<256;gray++) {
            GLint r = gamma_adjust( v->RedGamma,   gray, 255 );
            GLint g = gamma_adjust( v->GreenGamma, gray, 255 );
            GLint b = gamma_adjust( v->BlueGamma,  gray, 255 );
            int exact, alloced;
            XMesaColor xcol;
            xcol.red   = (r << 8) | r;
            xcol.green = (g << 8) | g;
            xcol.blue  = (b << 8) | b;
            noFaultXAllocColor( client, v->display,
                                cmap, GET_COLORMAP_SIZE(v),
                                &xcol, &exact, &alloced );
            if (!exact) {
               colorsfailed++;
            }
            if (alloced) {
               assert(buffer->num_alloced<256);
               buffer->alloced_colors[buffer->num_alloced] = xcol.pixel;
               buffer->num_alloced++;
            }

            /*OLD
            assert(gray < 576);
            buffer->color_table[gray*3+0] = xcol.pixel;
            buffer->color_table[gray*3+1] = xcol.pixel;
            buffer->color_table[gray*3+2] = xcol.pixel;
            assert(xcol.pixel < 65536);
            buffer->pixel_to_r[xcol.pixel] = gray * 30 / 100;
            buffer->pixel_to_g[xcol.pixel] = gray * 59 / 100;
            buffer->pixel_to_b[xcol.pixel] = gray * 11 / 100;
            */
            buffer->color_table[gray] = xcol.pixel;
            assert(xcol.pixel < 65536);
            buffer->pixel_to_r[xcol.pixel] = gray;
            buffer->pixel_to_g[xcol.pixel] = gray;
            buffer->pixel_to_b[xcol.pixel] = gray;
         }

         if (colorsfailed && _mesa_getenv("MESA_DEBUG")) {
            _mesa_warning(NULL,
                  "Note: %d out of 256 needed colors do not match exactly.\n",
                  colorsfailed );
         }
      }
   }

   v->dithered_pf = PF_Grayscale;
   v->undithered_pf = PF_Grayscale;
   return GL_TRUE;
}



/**
 * Setup RGB rendering for a window with a PseudoColor, StaticColor,
 * or 8-bit TrueColor visual visual.  We try to allocate a palette of 225
 * colors (5 red, 9 green, 5 blue) and dither to approximate a 24-bit RGB
 * color.  While this function was originally designed just for 8-bit
 * visuals, it has also proven to work from 4-bit up to 16-bit visuals.
 * Dithering code contributed by Bob Mercier.
 */
static GLboolean
setup_dithered_color(int client, XMesaVisual v,
                     XMesaBuffer buffer, XMesaColormap cmap)
{
   if (GET_VISUAL_DEPTH(v)<4 || GET_VISUAL_DEPTH(v)>16) {
      return GL_FALSE;
   }

   if (buffer) {
      XMesaBuffer prevBuffer;

      if (!cmap) {
         return GL_FALSE;
      }

      prevBuffer = xmesa_find_buffer(v->display, cmap, buffer);
      if (prevBuffer) {
         /* Copy colormap stuff from previous, matching XMesaBuffer.
          * Do this to avoid time spent in noFaultXAllocColor.
          */
         copy_colortable_info(buffer, prevBuffer);
      }
      else {
         /* Allocate X colors and initialize color_table[], red_table[], etc */
         int r, g, b, i;
         int colorsfailed = 0;
         for (r = 0; r < DITH_R; r++) {
            for (g = 0; g < DITH_G; g++) {
               for (b = 0; b < DITH_B; b++) {
                  XMesaColor xcol;
                  int exact, alloced;
                  xcol.red  =gamma_adjust(v->RedGamma,   r*65535/(DITH_R-1),65535);
                  xcol.green=gamma_adjust(v->GreenGamma, g*65535/(DITH_G-1),65535);
                  xcol.blue =gamma_adjust(v->BlueGamma,  b*65535/(DITH_B-1),65535);
                  noFaultXAllocColor( client, v->display,
                                      cmap, GET_COLORMAP_SIZE(v),
                                      &xcol, &exact, &alloced );
                  if (!exact) {
                     colorsfailed++;
                  }
                  if (alloced) {
                     assert(buffer->num_alloced<256);
                     buffer->alloced_colors[buffer->num_alloced] = xcol.pixel;
                     buffer->num_alloced++;
                  }
                  i = DITH_MIX( r, g, b );
                  assert(i < 576);
                  buffer->color_table[i] = xcol.pixel;
                  assert(xcol.pixel < 65536);
                  buffer->pixel_to_r[xcol.pixel] = r * 255 / (DITH_R-1);
                  buffer->pixel_to_g[xcol.pixel] = g * 255 / (DITH_G-1);
                  buffer->pixel_to_b[xcol.pixel] = b * 255 / (DITH_B-1);
               }
            }
         }

         if (colorsfailed && _mesa_getenv("MESA_DEBUG")) {
            _mesa_warning(NULL,
                  "Note: %d out of %d needed colors do not match exactly.\n",
                  colorsfailed, DITH_R * DITH_G * DITH_B );
         }
      }
   }

   v->dithered_pf = PF_Dither;
   v->undithered_pf = PF_Lookup;
   return GL_TRUE;
}


/**
 * Setup for Hewlett Packard Color Recovery 8-bit TrueColor mode.
 * HPCR simulates 24-bit color fidelity with an 8-bit frame buffer.
 * Special dithering tables have to be initialized.
 */
static void
setup_8bit_hpcr(XMesaVisual v)
{
   /* HP Color Recovery contributed by:  Alex De Bruyn (ad@@lms.be)
    * To work properly, the atom _HP_RGB_SMOOTH_MAP_LIST must be defined
    * on the root window AND the colormap obtainable by XGetRGBColormaps
    * for that atom must be set on the window.  (see also tkInitWindow)
    * If that colormap is not set, the output will look stripy.
    */

   /* Setup color tables with gamma correction */
   int i;
   double g;

   g = 1.0 / v->RedGamma;
   for (i=0; i<256; i++) {
      GLint red = IROUND_POS(255.0 * pow( hpcr_rgbTbl[0][i]/255.0, g ));
      v->hpcr_rgbTbl[0][i] = CLAMP( red, 16, 239 );
   }

   g = 1.0 / v->GreenGamma;
   for (i=0; i<256; i++) {
      GLint green = IROUND_POS(255.0 * pow( hpcr_rgbTbl[1][i]/255.0, g ));
      v->hpcr_rgbTbl[1][i] = CLAMP( green, 16, 239 );
   }

   g = 1.0 / v->BlueGamma;
   for (i=0; i<256; i++) {
      GLint blue = IROUND_POS(255.0 * pow( hpcr_rgbTbl[2][i]/255.0, g ));
      v->hpcr_rgbTbl[2][i] = CLAMP( blue, 32, 223 );
   }
   v->undithered_pf = PF_HPCR;  /* can't really disable dithering for now */
   v->dithered_pf = PF_HPCR;

   /* which method should I use to clear */
   /* GL_FALSE: keep the ordinary method  */
   /* GL_TRUE : clear with dither pattern */
   v->hpcr_clear_flag = _mesa_getenv("MESA_HPCR_CLEAR") ? GL_TRUE : GL_FALSE;

   if (v->hpcr_clear_flag) {
      v->hpcr_clear_pixmap = XMesaCreatePixmap(v->display,
                                               DefaultRootWindow(v->display),
                                               16, 2, 8);
      v->hpcr_clear_ximage = XGetImage(v->display, v->hpcr_clear_pixmap,
                                       0, 0, 16, 2, AllPlanes, ZPixmap);
   }
}


/**
a546 7
   else if (GET_REDMASK(v)  ==0xe0
       &&   GET_GREENMASK(v)==0x1c
       &&   GET_BLUEMASK(v) ==0x03
       && CHECK_FOR_HPCR(v)) {
      /* 8-bit HP color recovery */
      setup_8bit_hpcr( v );
   }
a549 15

/**
 * Setup RGB rendering for a window with a monochrome visual.
 */
static void
setup_monochrome( XMesaVisual v, XMesaBuffer b )
{
   (void) b;
   v->dithered_pf = v->undithered_pf = PF_1Bit;
   /* if black=1 then we must flip pixel values */
   v->bitFlip = (GET_BLACK_PIXEL(v) != 0);
}



a564 1
   int client = 0;
a579 14
   else if (xclass == GLX_STATIC_GRAY && GET_VISUAL_DEPTH(v) == 1) {
      setup_monochrome( v, b );
   }
   else if (xclass == GLX_GRAY_SCALE || xclass == GLX_STATIC_GRAY) {
      if (!setup_grayscale( client, v, b, cmap )) {
	 return GL_FALSE;
      }
   }
   else if ((xclass == GLX_PSEUDO_COLOR || xclass == GLX_STATIC_COLOR)
	    && GET_VISUAL_DEPTH(v)>=4 && GET_VISUAL_DEPTH(v)<=16) {
      if (!setup_dithered_color( client, v, b, cmap )) {
	 return GL_FALSE;
      }
   }
a605 2
      char *data;

a636 30
      /*
       * Set fill style and tile pixmap once for all for HPCR stuff
       * (instead of doing it each time in clear_color_HPCR_pixmap())
       * Initialize whole stuff
       * Patch contributed by Jacques Leroy March 8, 1998.
       */
      if (v->hpcr_clear_flag && b->backxrb && b->backxrb->pixmap) {
         int i;
         for (i = 0; i < 16; i++) {
            XMesaPutPixel(v->hpcr_clear_ximage, i, 0, 0);
            XMesaPutPixel(v->hpcr_clear_ximage, i, 1, 0);
         }
         XMesaPutImage(b->display, (XMesaDrawable) v->hpcr_clear_pixmap,
                       b->cleargc, v->hpcr_clear_ximage, 0, 0, 0, 0, 16, 2);
         XMesaSetFillStyle( v->display, b->cleargc, FillTiled);
         XMesaSetTile( v->display, b->cleargc, v->hpcr_clear_pixmap );
      }

      /* Initialize the row buffer XImage for use in write_color_span() */
      data = (char*) MALLOC(MAX_WIDTH*4);
      b->rowimage = XCreateImage( v->display,
                                  v->visinfo->visual,
                                  v->visinfo->depth,
                                  ZPixmap, 0,           /*format, offset*/
                                  data,                 /*data*/
                                  MAX_WIDTH, 1,         /*width, height*/
                                  32,                   /*bitmap_pad*/
                                  0                     /*bytes_per_line*/ );
      if (!b->rowimage)
         return GL_FALSE;
a653 2
      case PF_Index:
         return 0;
a669 17
      case PF_Dither:
         {
            DITHER_SETUP;
            return DITHER( 1, 0, r, g, b );
         }
      case PF_1Bit:
         /* 382 = (3*255)/2 */
         return ((r+g+b) > 382) ^ xmesa->xm_visual->bitFlip;
      case PF_HPCR:
         return DITHER_HPCR(1, 1, r, g, b);
      case PF_Lookup:
         {
            LOOKUP_SETUP;
            return LOOKUP( r, g, b );
         }
      case PF_Grayscale:
         return GRAY_RGB( r, g, b );
d787 1
a787 1
   v->visinfo = (XVisualInfo *) MALLOC(sizeof(*visinfo));
d850 12
a861 9
   _mesa_initialize_visual( &v->mesa_visual,
                            db_flag, stereo_flag,
                            red_bits, green_bits,
                            blue_bits, alpha_bits,
                            depth_size,
                            stencil_size,
                            accum_red_size, accum_green_size,
                            accum_blue_size, accum_alpha_size,
                            0 );
d909 1
a909 1
   if (!_mesa_initialize_context(mesaCtx, API_OPENGL, &v->mesa_visual,
d911 1
a911 1
                      &functions, (void *) c)) {
d925 1
a925 12
   _mesa_enable_1_3_extensions(mesaCtx);
   _mesa_enable_1_4_extensions(mesaCtx);
   _mesa_enable_1_5_extensions(mesaCtx);
   _mesa_enable_2_0_extensions(mesaCtx);
   _mesa_enable_2_1_extensions(mesaCtx);
#if ENABLE_EXT_texure_compression_s3tc
    if (mesaCtx->Mesa_DXTn) {
       _mesa_enable_extension(mesaCtx, "GL_EXT_texture_compression_s3tc");
       _mesa_enable_extension(mesaCtx, "GL_S3_s3tc");
    }
    _mesa_enable_extension(mesaCtx, "GL_3DFX_texture_compression_FXT1");
#endif
d927 1
a927 1
    _mesa_enable_extension(mesaCtx, "GL_EXT_timer_query");
d958 6
a973 4
#ifdef FX
   FXdestroyContext( XMESA_BUFFER(mesaCtx->DrawBuffer) );
#endif

a1186 1
   drawBuffer->mesa_buffer.Initialized = GL_TRUE; /* XXX TEMPORARY? */
a1219 5
#ifdef FX
      if (FXmakeCurrent( drawBuffer ))
         return GL_TRUE;
#endif

a1305 2

#ifndef FX
a1310 1
#endif
a1334 4
#ifdef FX
      if (FXswapBuffers(b))
         return;
#endif
a1369 3

      if (b->swAlpha)
         _mesa_copy_soft_alpha_renderbuffers(ctx, &b->mesa_buffer);
a1395 4
#ifdef FX
      if (FXswapBuffers(b))
         return;
#endif
d1472 3
a1474 1
   if (!rb || !rb->Data) {
d1486 1
a1486 1
      *buffer = rb->Data;
a1567 1
   struct gl_context *ctx = &xmesa->mesa;
a1573 2
      case PF_Index:
         return 0;
a1587 17
      case PF_Dither:
         {
            DITHER_SETUP;
            return DITHER( x, y, r, g, b );
         }
      case PF_1Bit:
         /* 382 = (3*255)/2 */
         return ((r+g+b) > 382) ^ xmesa->xm_visual->bitFlip;
      case PF_HPCR:
         return DITHER_HPCR(x, y, r, g, b);
      case PF_Lookup:
         {
            LOOKUP_SETUP;
            return LOOKUP( r, g, b );
         }
      case PF_Grayscale:
         return GRAY_RGB( r, g, b );
@


1.7
log
@Merge Mesa 7.10.3
@
text
@d1401 1
a1401 1
   if (!_mesa_initialize_context(mesaCtx, &v->mesa_visual,
d2067 1
a2067 1
void XMesaGarbageCollect( void )
d2072 1
a2072 1
      if (b->display && b->frontxrb->drawable && b->type == WINDOW) {
@


1.6
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a160 1
#ifndef XFree86Server
a166 1
#endif
d177 1
a177 1
#if defined(USE_XSHM) && !defined(XFree86Server)
d211 1
a211 1
      return IROUND_POS((GLfloat) max * _mesa_pow(x, 1.0F/gamma));
a227 10
#ifdef XFree86Server
   const int depth = xmv->nplanes;
   int i;
   assert(depth > 0);
   for (i = 0; i < screenInfo.numPixmapFormats; i++) {
      if (screenInfo.formats[i].depth == depth)
         return screenInfo.formats[i].bitsPerPixel;
   }
   return depth;  /* should never get here, but this should be safe */
#else
a247 1
#endif
a260 1
#ifndef XFree86Server
a294 1
#endif
a306 4
#ifdef XFree86Server
   *width = MIN2(b->frontxrb->drawable->width, MAX_WIDTH);
   *height = MIN2(b->frontxrb->drawable->height, MAX_HEIGHT);
#else
a318 1
#endif
d332 1
a332 1
 * Note that XMesaBuffer is derived from GLframebuffer.
a531 4
#ifdef XFree86Server
   Pixel *ppixIn;
   xrgb *ctable;
#else
a536 1
#endif
a543 6
#ifdef XFree86Server
   if (AllocColor(cmap,
		  &color->red, &color->green, &color->blue,
		  &color->pixel,
		  client) == Success)
#else
a544 1
#endif
a554 8
#ifdef XFree86Server
   ppixIn = (Pixel *) MALLOC(cmapSize * sizeof(Pixel));
   ctable = (xrgb *) MALLOC(cmapSize * sizeof(xrgb));
   for (i = 0; i < cmapSize; i++) {
      ppixIn[i] = i;
   }
   QueryColors(cmap, cmapSize, ppixIn, ctable);
#else
a570 1
#endif
a593 6
#ifdef XFree86Server
   if (AllocColor(cmap,
		  &subColor.red, &subColor.green, &subColor.blue,
		  &subColor.pixel,
		  client) == Success) {
#else
a594 1
#endif
a605 4
#ifdef XFree86Server
   free(ppixIn);
   free(ctable);
#else
a606 1
#endif
d796 1
a796 1
      GLint red = IROUND_POS(255.0 * _mesa_pow( hpcr_rgbTbl[0][i]/255.0, g ));
d802 1
a802 1
      GLint green = IROUND_POS(255.0 * _mesa_pow( hpcr_rgbTbl[1][i]/255.0, g ));
d808 1
a808 1
      GLint blue = IROUND_POS(255.0 * _mesa_pow( hpcr_rgbTbl[2][i]/255.0, g ));
a822 1
#ifndef XFree86Server
a824 1
#endif
d995 1
a995 1
   const int xclass = v->mesa_visual.visualType;
a996 3
#ifdef XFree86Server
   client = (window) ? CLIENT_ID(window->id) : 0;
#endif
a1064 3
#ifdef XFree86Server
      b->gc = CreateScratchGC(v->display, window->depth);
#else
a1065 1
#endif
a1068 3
#ifdef XFree86Server
      b->cleargc = CreateScratchGC(v->display, window->depth);
#else
a1069 1
#endif
a1075 8
#ifdef XFree86Server
      b->swapgc = CreateScratchGC(v->display, window->depth);
      {
         CARD32 v[1];
         v[0] = FALSE;
         dixChangeGC(NullClient, b->swapgc, GCGraphicsExposures, v, NULL);
      }
#else
a1081 1
#endif
a1102 3
#ifdef XFree86Server
      b->rowimage = XMesaCreateImage(GET_VISUAL_DEPTH(v), MAX_WIDTH, 1, data);
#else
a1110 1
#endif
d1124 1
a1124 1
xmesa_color_to_pixel(GLcontext *ctx,
a1257 1
#ifndef XFree86Server
a1265 1
#endif
a1281 1
#ifndef XFree86Server
a1287 1
#endif
a1303 16
#ifdef XFree86Server
   /* We could calculate these values by ourselves.  nplanes is either the sum
    * of the red, green, and blue bits or the number index bits.
    * ColormapEntries is either (1U << index_bits) or
    * (1U << max(redBits, greenBits, blueBits)).
    */
   assert(visinfo->nplanes > 0);
   v->nplanes = visinfo->nplanes;
   v->ColormapEntries = visinfo->ColormapEntries;

   v->mesa_visual.redMask = visinfo->redMask;
   v->mesa_visual.greenMask = visinfo->greenMask;
   v->mesa_visual.blueMask = visinfo->blueMask;
   v->mesa_visual.visualID = visinfo->vid;
   v->mesa_visual.screen = 0; /* FIXME: What should be done here? */
#else
d1307 2
a1308 3
   v->mesa_visual.visualID = visinfo->visualid;
   v->mesa_visual.screen = visinfo->screen;
#endif
d1310 2
a1311 2
#if defined(XFree86Server) || !(defined(__cplusplus) || defined(c_plusplus))
   v->mesa_visual.visualType = xmesa_convert_from_x_visual_type(visinfo->class);
d1313 1
a1313 1
   v->mesa_visual.visualType = xmesa_convert_from_x_visual_type(visinfo->c_class);
d1324 1
a1324 1
      const int xclass = v->mesa_visual.visualType;
a1363 1
#ifndef XFree86Server
a1364 1
#endif
d1382 1
a1382 1
   GLcontext *mesaCtx;
d1391 1
a1391 1
   /* Note: the XMesaContext contains a Mesa GLcontext struct (inheritance) */
d1402 1
a1402 1
                      share_list ? &(share_list->mesa) : (GLcontext *) NULL,
a1432 6
#ifdef XFree86Server
   /* If we're running in the X server, do bounds checking to prevent
    * segfaults and server crashes!
    */
   mesaCtx->Const.CheckArrayBounds = GL_TRUE;
#endif
d1469 1
a1469 1
   GLcontext *mesaCtx = &c->mesa;
a1496 1
#ifndef XFree86Server
a1497 1
#endif
a1505 3
#ifdef XFree86Server
   depth = ((XMesaDrawable)w)->depth;
#else
a1507 1
#endif
a1514 3
#ifdef XFree86Server
   cmap = (ColormapPtr)LookupIDByType(wColormap(w), RT_COLORMAP);
#else
a1523 1
#endif
a1632 1
#ifndef XFree86Server
a1653 3
#else
   return 0;
#endif
d1669 1
a1669 1
 * Query the current window size and update the corresponding GLframebuffer
d1685 1
a1685 1
      GLcontext *ctx = xmctx ? &xmctx->mesa : NULL;
a1811 34
#ifdef XFree86Server
PUBLIC
GLboolean XMesaForceCurrent(XMesaContext c)
{
   if (c) {
      _glapi_set_dispatch(c->mesa.CurrentDispatch);

      if (&(c->mesa) != _mesa_get_current_context()) {
	 _mesa_make_current(&c->mesa, c->mesa.DrawBuffer, c->mesa.ReadBuffer);
      }
   }
   else {
      _mesa_make_current(NULL, NULL, NULL);
   }
   return GL_TRUE;
}


PUBLIC
GLboolean XMesaLoseCurrent(XMesaContext c)
{
   (void) c;
   _mesa_make_current(NULL, NULL, NULL);
   return GL_TRUE;
}


PUBLIC
GLboolean XMesaCopyContext( XMesaContext xm_src, XMesaContext xm_dst, GLuint mask )
{
   _mesa_copy_context(&xm_src->mesa, &xm_dst->mesa, mask);
   return GL_TRUE;
}
#endif /* XFree86Server */
d1851 1
a1851 1
#if defined(USE_XSHM) && !defined(XFree86Server)
a1887 1
#if !defined(XFree86Server)
a1888 1
#endif
d1919 1
a1919 1
#if defined(USE_XSHM) && !defined(XFree86Server)
a1960 1
#ifndef XFree86Server
a1977 1
#endif /* XFree86Server */
a2013 3
#ifdef XFree86Server
      /* NOT_NEEDED */
#else
a2014 1
#endif
a2072 3
#ifdef XFree86Server
	 /* NOT_NEEDED */
#else
a2077 1
#endif
d2087 1
a2087 1
   GLcontext *ctx = &xmesa->mesa;
@


1.5
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d82 1
d256 1
a256 1
   _mesa_free( img->data );
d378 1
a378 1
   _mesa_initialize_framebuffer(&b->mesa_buffer, &vis->mesa_visual);
d386 1
a386 1
      _mesa_free(b);
d402 1
a402 1
         _mesa_free(b);
d496 1
a496 1
         _mesa_unreference_framebuffer(&fb);
d514 4
a517 4
   MEMCPY(dst->color_table, src->color_table, sizeof(src->color_table));
   MEMCPY(dst->pixel_to_r, src->pixel_to_r, sizeof(src->pixel_to_r));
   MEMCPY(dst->pixel_to_g, src->pixel_to_g, sizeof(src->pixel_to_g));
   MEMCPY(dst->pixel_to_b, src->pixel_to_b, sizeof(src->pixel_to_b));
d519 1
a519 1
   MEMCPY(dst->alloced_colors, src->alloced_colors,
d599 1
a599 1
         _mesa_free(ctable);
d655 2
a656 2
   _mesa_free(ppixIn);
   _mesa_free(ctable);
d687 1
a687 3
      if (prevBuffer &&
          (buffer->xm_visual->mesa_visual.rgbMode ==
           prevBuffer->xm_visual->mesa_visual.rgbMode)) {
d774 1
a774 3
      if (prevBuffer &&
          (buffer->xm_visual->mesa_visual.rgbMode ==
           prevBuffer->xm_visual->mesa_visual.rgbMode)) {
d1046 1
a1046 1
                             GLboolean rgb_flag, XMesaDrawable window,
d1050 1
d1062 8
a1069 7
   if (rgb_flag == GL_FALSE) {
      /* COLOR-INDEXED WINDOW:
       * Even if the visual is TrueColor or DirectColor we treat it as
       * being color indexed.  This is weird but might be useful to someone.
       */
      v->dithered_pf = v->undithered_pf = PF_Index;
      v->mesa_visual.indexBits = GET_VISUAL_DEPTH(v);
d1071 3
a1073 7
   else {
      /* RGB WINDOW:
       * We support RGB rendering into almost any kind of visual.
       */
      const int xclass = v->mesa_visual.visualType;
      if (xclass == GLX_TRUE_COLOR || xclass == GLX_DIRECT_COLOR) {
	 setup_truecolor( v, b, cmap );
d1075 4
a1078 16
      else if (xclass == GLX_STATIC_GRAY && GET_VISUAL_DEPTH(v) == 1) {
	 setup_monochrome( v, b );
      }
      else if (xclass == GLX_GRAY_SCALE || xclass == GLX_STATIC_GRAY) {
         if (!setup_grayscale( client, v, b, cmap )) {
            return GL_FALSE;
         }
      }
      else if ((xclass == GLX_PSEUDO_COLOR || xclass == GLX_STATIC_COLOR)
               && GET_VISUAL_DEPTH(v)>=4 && GET_VISUAL_DEPTH(v)<=16) {
	 if (!setup_dithered_color( client, v, b, cmap )) {
            return GL_FALSE;
         }
      }
      else {
	 _mesa_warning(NULL, "XMesa: RGB mode rendering not supported in given visual.\n");
d1081 6
a1086 1
      v->mesa_visual.indexBits = 0;
d1088 2
a1089 3
      if (_mesa_getenv("MESA_NO_DITHER")) {
	 v->dithered_pf = v->undithered_pf;
      }
d1099 6
a1104 6
      _mesa_printf("X/Mesa visual = %p\n", (void *) v);
      _mesa_printf("X/Mesa dithered pf = %u\n", v->dithered_pf);
      _mesa_printf("X/Mesa undithered pf = %u\n", v->undithered_pf);
      _mesa_printf("X/Mesa level = %d\n", v->mesa_visual.level);
      _mesa_printf("X/Mesa depth = %d\n", GET_VISUAL_DEPTH(v));
      _mesa_printf("X/Mesa bits per pixel = %d\n", v->BitsPerPixel);
a1291 61
#ifdef IN_DRI_DRIVER
#define need_GL_VERSION_1_3
#define need_GL_VERSION_1_4
#define need_GL_VERSION_1_5
#define need_GL_VERSION_2_0

/* sw extensions for imaging */
#define need_GL_EXT_blend_color
#define need_GL_EXT_blend_minmax
#define need_GL_EXT_convolution
#define need_GL_EXT_histogram
#define need_GL_SGI_color_table

/* sw extensions not associated with some GL version */
#define need_GL_ARB_shader_objects
#define need_GL_ARB_vertex_program
#define need_GL_APPLE_vertex_array_object
#define need_GL_ATI_fragment_shader
#define need_GL_EXT_depth_bounds_test
#define need_GL_EXT_framebuffer_object
#define need_GL_EXT_framebuffer_blit
#define need_GL_EXT_gpu_program_parameters
#define need_GL_EXT_paletted_texture
#define need_GL_IBM_multimode_draw_arrays
#define need_GL_MESA_resize_buffers
#define need_GL_NV_vertex_program
#define need_GL_NV_fragment_program

#include "extension_helper.h"
#include "utils.h"

const struct dri_extension card_extensions[] =
{
   { "GL_VERSION_1_3",			GL_VERSION_1_3_functions },
   { "GL_VERSION_1_4",			GL_VERSION_1_4_functions },
   { "GL_VERSION_1_5",			GL_VERSION_1_5_functions },
   { "GL_VERSION_2_0",			GL_VERSION_2_0_functions },

   { "GL_EXT_blend_color",		GL_EXT_blend_color_functions },
   { "GL_EXT_blend_minmax",		GL_EXT_blend_minmax_functions },
   { "GL_EXT_convolution",		GL_EXT_convolution_functions },
   { "GL_EXT_histogram",		GL_EXT_histogram_functions },
   { "GL_SGI_color_table",		GL_SGI_color_table_functions },

   { "GL_ARB_shader_objects",		GL_ARB_shader_objects_functions },
   { "GL_ARB_vertex_program",		GL_ARB_vertex_program_functions },
   { "GL_APPLE_vertex_array_object",	GL_APPLE_vertex_array_object_functions },
   { "GL_ATI_fragment_shader",		GL_ATI_fragment_shader_functions },
   { "GL_EXT_depth_bounds_test",	GL_EXT_depth_bounds_test_functions },
   { "GL_EXT_framebuffer_object",	GL_EXT_framebuffer_object_functions },
   { "GL_EXT_framebuffer_blit",		GL_EXT_framebuffer_blit_functions },
   { "GL_EXT_gpu_program_parameters",	GL_EXT_gpu_program_parameters_functions },
   { "GL_EXT_paletted_texture",		GL_EXT_paletted_texture_functions },
   { "GL_IBM_multimode_draw_arrays",	GL_IBM_multimode_draw_arrays_functions },
   { "GL_MESA_resize_buffers",		GL_MESA_resize_buffers_functions },
   { "GL_NV_vertex_program",		GL_NV_vertex_program_functions },
   { "GL_NV_fragment_program",		GL_NV_fragment_program_functions },
   { NULL,				NULL }
};
#endif

a1336 8
#ifdef IN_DRI_DRIVER
   /* driInitExtensions() should be called once per screen to setup extension
    * indices.  There is no need to call it when the context is created since
    * XMesa enables mesa sw extensions on its own.
    */
   driInitExtensions( NULL, card_extensions, GL_FALSE );
#endif

d1348 4
d1359 1
a1359 1
   /* Save a copy of the XVisualInfo struct because the user may X_mesa_free()
d1366 1
a1366 1
      _mesa_free(v);
d1369 1
a1369 1
   MEMCPY(v->visinfo, visinfo, sizeof(*visinfo));
d1421 1
a1421 1
   (void) initialize_visual_and_buffer( v, NULL, rgb_flag, 0, 0 );
d1446 1
a1446 1
                            rgb_flag, db_flag, stereo_flag,
a1448 1
                            v->mesa_visual.indexBits,
d1465 1
a1465 1
   _mesa_free(v->visinfo);
d1467 1
a1467 1
   _mesa_free(v);
d1506 1
a1506 1
      _mesa_free(c);
d1510 8
d1556 1
a1556 1
      _mesa_free(c);
d1567 2
d1583 2
d1590 1
a1590 1
   _mesa_free( c );
d1647 1
a1647 2
   if (!initialize_visual_and_buffer( v, b, v->mesa_visual.rgbMode,
                                      (XMesaDrawable) w, cmap )) {
d1677 1
a1677 2
   if (!initialize_visual_and_buffer(v, b, v->mesa_visual.rgbMode,
				     (XMesaDrawable) p, cmap)) {
d1737 1
a1737 2
   if (!initialize_visual_and_buffer(v, b, v->mesa_visual.rgbMode,
				     (XMesaDrawable) p, cmap)) {
d1767 1
a1767 2
   if (!initialize_visual_and_buffer(v, b, v->mesa_visual.rgbMode,
				     drawable, cmap)) {
d1862 11
a1872 13
      if (c->xm_visual->mesa_visual.rgbMode) {
         /*
          * Must recompute and set these pixel values because colormap
          * can be different for different windows.
          */
         c->clearpixel = xmesa_color_to_pixel( &c->mesa,
                                               c->clearcolor[0],
                                               c->clearcolor[1],
                                               c->clearcolor[2],
                                               c->clearcolor[3],
                                               c->xm_visual->undithered_pf);
         XMesaSetForeground(c->display, drawBuffer->cleargc, c->clearpixel);
      }
a2341 1
      return BUFFER_AUX1;
a2342 1
      return BUFFER_AUX2;
a2343 1
      return BUFFER_AUX3;
@


1.4
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a65 1
#include "GL/xmesa.h"
a69 1
#include "glapi/glthread.h"
d74 1
d2466 1
a2466 1
      texObj = texUnit->Current1D;
d2469 1
a2469 1
      texObj = texUnit->Current2D;
d2472 1
a2472 1
      texObj = texUnit->CurrentRect;
@


1.3
log
@merge Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.2
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d68 8
a75 7
#include "context.h"
#include "extensions.h"
#include "framebuffer.h"
#include "glthread.h"
#include "imports.h"
#include "macros.h"
#include "renderbuffer.h"
d296 13
a311 1

a325 1
   Window root;
a326 2
   int xpos, ypos;
   unsigned int w, h, bw, depth;
d330 1
a330 2
   stat = XGetGeometry(dpy, b->frontxrb->pixmap, &root, &xpos, &ypos,
                       &w, &h, &bw, &depth);
d333 1
a333 5
   if (stat) {
      *width = w;
      *height = h;
   }
   else {
d439 5
d1306 61
d1412 8
d1595 1
d1597 1
a1597 1
    if (c->Mesa_DXTn) {
d1756 61
d2396 151
@


1.2
log
@assorted fixes for dealing with zero-size frame/renderbuffers.

from freedesktop (mesa-commits) with help from games/bzflag;
ok matthieu@@
@
text
@d77 1
a77 1
#include "array_cache/acache.h"
a82 4
#ifdef XFree86Server
#include <GL/glxtokens.h>
#endif

d178 1
a178 3
#if defined(XFree86Server)
   return 0;
#elif defined(USE_XSHM)
d342 1
a342 1
static XMesaBuffer XMesaBufferList = NULL;
a359 1
   GLboolean swAlpha;
d374 1
d379 1
a379 2
   b->frontxrb = xmesa_new_renderbuffer(NULL, 0, &vis->mesa_visual,
                                           GL_FALSE);
d394 1
a394 2
      b->backxrb = xmesa_new_renderbuffer(NULL, 0, &vis->mesa_visual,
                                          GL_TRUE);
d417 1
a417 1
      swAlpha = GL_TRUE;
d420 1
a420 1
      swAlpha = GL_FALSE;
d431 1
a431 1
                                swAlpha,
d433 1
a433 1
   
d446 2
a447 2
static XMesaBuffer
find_xmesa_buffer(XMesaDisplay *dpy, XMesaColormap cmap, XMesaBuffer notThis)
d460 1
a460 2
 * Free an XMesaBuffer, remove from linked list, perhaps free X colormap
 * entries.
d463 1
a463 1
free_xmesa_buffer(int client, XMesaBuffer buffer)
d466 6
a471 4
   (void) client;
   for (b=XMesaBufferList; b; b=b->Next) {
      if (b==buffer) {
         /* unlink bufer from list */
a475 14
         /* Check to free X colors */
         if (buffer->num_alloced>0) {
            /* If no other buffer uses this X colormap then free the colors. */
            if (!find_xmesa_buffer(buffer->display, buffer->cmap, buffer)) {
#ifdef XFree86Server
               (void)FreeColors(buffer->cmap, client,
				buffer->num_alloced, buffer->alloced_colors,
				0);
#else
               XFreeColors(buffer->display, buffer->cmap,
                           buffer->alloced_colors, buffer->num_alloced, 0);
#endif
            }
         }
d477 10
a486 2
         _mesa_free_framebuffer_data(&buffer->mesa_buffer);
         _mesa_free(buffer);
d494 1
a494 1
   _mesa_problem(NULL,"free_xmesa_buffer() - buffer not found\n");
d676 1
a676 1
      prevBuffer = find_xmesa_buffer(v->display, cmap, buffer);
d765 1
a765 1
      prevBuffer = find_xmesa_buffer(v->display, cmap, buffer);
a972 1
       && sizeof(GLuint)==4
d975 1
a975 1
      v->undithered_pf = v->dithered_pf = PF_8A8B8G8R;
d977 15
a991 22
   else if (GET_REDMASK(v)  ==0xff0000
       &&   GET_GREENMASK(v)==0x00ff00
       &&   GET_BLUEMASK(v) ==0x0000ff
       && CHECK_BYTE_ORDER(v)
       && v->BitsPerPixel==32
       && sizeof(GLuint)==4
       && v->RedGamma==1.0 && v->GreenGamma==1.0 && v->BlueGamma==1.0) {
      /* common 32 bpp config used on Linux, HP, IBM */
      if (GET_VISUAL_DEPTH(v)==32)
	  v->undithered_pf = v->dithered_pf = PF_8A8R8G8B;
      else
	  v->undithered_pf = v->dithered_pf = PF_8R8G8B;
   }
   else if (GET_REDMASK(v)  ==0xff0000
       &&   GET_GREENMASK(v)==0x00ff00
       &&   GET_BLUEMASK(v) ==0x0000ff
       && CHECK_BYTE_ORDER(v)
       && v->BitsPerPixel==24
       && sizeof(GLuint)==4
       && v->RedGamma==1.0 && v->GreenGamma==1.0 && v->BlueGamma==1.0) {
      /* common packed 24 bpp config used on Linux */
      v->undithered_pf = v->dithered_pf = PF_8R8G8B24;
a997 1
       && sizeof(GLushort)==2
d999 1
a999 1
      /* 5-6-5 color weight on common PC VGA boards */
d1007 1
d1039 1
a1039 1
initialize_visual_and_buffer(int client, XMesaVisual v, XMesaBuffer b,
d1043 6
d1112 2
d1181 1
d1183 1
a1183 2
      b->rowimage = XMesaCreateImage(GET_VISUAL_DEPTH(v), MAX_WIDTH, 1,
				     (char *)MALLOC(MAX_WIDTH*4));
d1189 1
a1189 1
                                  (char*) MALLOC(MAX_WIDTH*4),  /*data*/
d1319 1
a1356 5
   /*
    * In the X server, NULL is passed in for the display.  It will have
    * to be set before using this visual.  See XMesaSetVisualDisplay()
    * below.
    */
d1418 4
a1421 1
   (void) initialize_visual_and_buffer( 0, v, NULL, rgb_flag, 0, 0 );
a1428 1
         alpha_bits = 0;
d1442 1
a1444 3
   if (alpha_flag && alpha_bits == 0)
      alpha_bits = 8;

d1462 1
a1462 6
void XMesaSetVisualDisplay( XMesaDisplay *dpy, XMesaVisual v )
{
    v->display = dpy;
}


d1480 1
d1527 7
d1544 1
a1544 1
       !_ac_CreateContext( mesaCtx ) ||
d1564 1
d1568 1
d1570 2
a1571 1
   XMesaBuffer xmbuf = XMESA_BUFFER(mesaCtx->DrawBuffer);
a1572 3
   if (xmbuf && xmbuf->FXctx)
      fxMesaDestroyContext(xmbuf->FXctx);
#endif
d1576 1
a1576 1
   _ac_DestroyContext( mesaCtx );
a1587 1
 * \param c  context used to initialize the buffer if 3Dfx mode in use.
d1590 2
a1591 2
XMesaBuffer
XMesaCreateWindowBuffer2(XMesaVisual v, XMesaWindow w, XMesaContext c)
a1595 4
#ifdef FX
   char *fxEnvVar;
#endif
   int client = 0;
d1598 1
a1601 1
   (void) c;
d1605 1
a1605 7
   client = CLIENT_ID(((XMesaDrawable)w)->id);

   if (GET_VISUAL_DEPTH(v) != ((XMesaDrawable)w)->depth) {
      _mesa_warning(NULL, "XMesaCreateWindowBuffer: depth mismatch between visual (%d) and window (%d)!\n",
                    GET_VISUAL_DEPTH(v), ((XMesaDrawable) w)->depth);
      return NULL;
   }
d1608 3
a1610 2

   if (GET_VISUAL_DEPTH(v) != attr.depth) {
d1612 1
a1612 1
                    GET_VISUAL_DEPTH(v), attr.depth);
a1614 1
#endif
d1635 1
a1635 1
   if (!initialize_visual_and_buffer( client, v, b, v->mesa_visual.rgbMode,
d1637 1
a1637 1
      free_xmesa_buffer(client, b);
a1640 79
#ifdef FX
   fxEnvVar = _mesa_getenv("MESA_GLX_FX");
   if (fxEnvVar) {
     if (fxEnvVar[0]!='d') {
       int attribs[100];
       int numAttribs = 0;
       int hw;
       if (v->mesa_visual.depthBits > 0) {
	 attribs[numAttribs++] = FXMESA_DEPTH_SIZE;
	 attribs[numAttribs++] = v->mesa_visual.depthBits;
       }
       if (v->mesa_visual.doubleBufferMode) {
	 attribs[numAttribs++] = FXMESA_DOUBLEBUFFER;
       }
       if (v->mesa_visual.accumRedBits > 0) {
	 attribs[numAttribs++] = FXMESA_ACCUM_SIZE;
	 attribs[numAttribs++] = v->mesa_visual.accumRedBits;
       }
       if (v->mesa_visual.stencilBits > 0) {
         attribs[numAttribs++] = FXMESA_STENCIL_SIZE;
         attribs[numAttribs++] = v->mesa_visual.stencilBits;
       }
       if (v->mesa_visual.alphaBits > 0) {
         attribs[numAttribs++] = FXMESA_ALPHA_SIZE;
         attribs[numAttribs++] = v->mesa_visual.alphaBits;
       }
       if (1) {
         attribs[numAttribs++] = FXMESA_SHARE_CONTEXT;
         attribs[numAttribs++] = (int) &(c->mesa);
       }
       attribs[numAttribs++] = FXMESA_NONE;

       /* [dBorca] we should take an envvar for `fxMesaSelectCurrentBoard'!!! */
       hw = fxMesaSelectCurrentBoard(0);

       /* if these fail, there's a new bug somewhere */
       ASSERT(b->mesa_buffer.Width > 0);
       ASSERT(b->mesa_buffer.Height > 0);

       if ((hw == GR_SSTTYPE_VOODOO) || (hw == GR_SSTTYPE_Voodoo2)) {
         b->FXctx = fxMesaCreateBestContext(0, b->mesa_buffer.Width,
                                            b->mesa_buffer.Height, attribs);
         if ((v->undithered_pf!=PF_Index) && (b->backxrb->ximage)) {
	   b->FXisHackUsable = b->FXctx ? GL_TRUE : GL_FALSE;
	   if (b->FXctx && (fxEnvVar[0]=='w' || fxEnvVar[0]=='W')) {
	     b->FXwindowHack = GL_TRUE;
	     FX_grSstControl(GR_CONTROL_DEACTIVATE);
	   }
           else {
	     b->FXwindowHack = GL_FALSE;
	   }
         }
       }
       else {
         if (fxEnvVar[0]=='w' || fxEnvVar[0]=='W')
	   b->FXctx = fxMesaCreateContext(w, GR_RESOLUTION_NONE,
					  GR_REFRESH_75Hz, attribs);
         else
	   b->FXctx = fxMesaCreateBestContext(0, b->mesa_buffer.Width,
                                              b->mesa_buffer.Height, attribs);
         b->FXisHackUsable = GL_FALSE;
         b->FXwindowHack = GL_FALSE;
       }
       /*
       fprintf(stderr,
               "voodoo %d, wid %d height %d hack: usable %d active %d\n",
               hw, b->mesa_buffer.Width, b->mesa_buffer.Height,
	       b->FXisHackUsable, b->FXwindowHack);
       */
     }
   }
   else {
      _mesa_warning(NULL, "WARNING: This Mesa Library includes the Glide driver but\n");
      _mesa_warning(NULL, "         you have not defined the MESA_GLX_FX env. var.\n");
      _mesa_warning(NULL, "         (check the README.3DFX file for more information).\n\n");
      _mesa_warning(NULL, "         you can disable this message with a 'export MESA_GLX_FX=disable'.\n");
   }
#endif

a1644 6
XMesaBuffer
XMesaCreateWindowBuffer(XMesaVisual v, XMesaWindow w)
{
   return XMesaCreateWindowBuffer2( v, w, NULL );
}

d1655 1
a1655 1
XMesaBuffer
a1657 1
   int client = 0;
d1666 1
a1666 5
#ifdef XFree86Server
   client = CLIENT_ID(((XMesaDrawable)p)->id);
#endif

   if (!initialize_visual_and_buffer(client, v, b, v->mesa_visual.rgbMode,
d1668 1
a1668 1
      free_xmesa_buffer(client, b);
d1681 1
a1681 4
#ifdef XFree86Server
   return 0;
#else
   int client = 0;
d1697 1
a1697 1
   if (!initialize_visual_and_buffer(client, v, b, v->mesa_visual.rgbMode,
d1699 1
a1699 1
      free_xmesa_buffer(client, b);
d1704 2
d1714 2
a1715 1
void XMesaDestroyBuffer( XMesaBuffer b )
d1717 1
a1717 40
   int client = 0;

#ifdef XFree86Server
   if (b->frontxrb->drawable)
       client = CLIENT_ID(b->frontxrb->drawable->id);
#endif

   if (b->gc)  XMesaFreeGC( b->xm_visual->display, b->gc );
   if (b->cleargc)  XMesaFreeGC( b->xm_visual->display, b->cleargc );
   if (b->swapgc)  XMesaFreeGC( b->xm_visual->display, b->swapgc );

   if (b->xm_visual->mesa_visual.doubleBufferMode)
   {
      if (b->backxrb->ximage) {
#if defined(USE_XSHM) && !defined(XFree86Server)
         if (b->shm) {
            XShmDetach( b->xm_visual->display, &b->shminfo );
            XDestroyImage( b->backxrb->ximage );
            shmdt( b->shminfo.shmaddr );
         }
         else
#endif
            XMesaDestroyImage( b->backxrb->ximage );
      }
      if (b->backxrb->pixmap) {
         XMesaFreePixmap( b->xm_visual->display, b->backxrb->pixmap );
         if (b->xm_visual->hpcr_clear_flag) {
            XMesaFreePixmap( b->xm_visual->display,
                             b->xm_visual->hpcr_clear_pixmap );
            XMesaDestroyImage( b->xm_visual->hpcr_clear_ximage );
         }
      }
   }
   if (b->rowimage) {
      _mesa_free( b->rowimage->data );
      b->rowimage->data = NULL;
      XMesaDestroyImage( b->rowimage );
   }

   free_xmesa_buffer(client, b);
d1738 1
a1738 1
       GLcontext *ctx = xmctx ? &xmctx->mesa : NULL;
d1757 1
a1764 9
#ifdef FX
      if (drawBuffer->FXctx) {
         fxMesaMakeCurrent(drawBuffer->FXctx);

         c->xm_buffer = drawBuffer;

         return GL_TRUE;
      }
#endif
d1775 5
d1867 2
d1872 2
d1885 1
d1894 2
a1895 4
/*
 * Switch 3Dfx support hack between window and full-screen mode.
 */
GLboolean XMesaSetFXmode( GLint mode )
d1897 2
a1898 41
#ifdef FX
   const char *fx = _mesa_getenv("MESA_GLX_FX");
   if (fx && fx[0] != 'd') {
      GET_CURRENT_CONTEXT(ctx);
      GrHwConfiguration hw;
      if (!FX_grSstQueryHardware(&hw)) {
         /*fprintf(stderr, "!grSstQueryHardware\n");*/
         return GL_FALSE;
      }
      if (hw.num_sst < 1) {
         /*fprintf(stderr, "hw.num_sst < 1\n");*/
         return GL_FALSE;
      }
      if (ctx) {
         /* [dBorca] Hack alert: 
	  * oh, this is sooo wrong: ctx above is
	  * really an fxMesaContext, not an XMesaContext
	  */
         XMesaBuffer xmbuf = XMESA_BUFFER(ctx->DrawBuffer);
         if (mode == XMESA_FX_WINDOW) {
	    if (xmbuf->FXisHackUsable) {
	       FX_grSstControl(GR_CONTROL_DEACTIVATE);
	       xmbuf->FXwindowHack = GL_TRUE;
	       return GL_TRUE;
	    }
	 }
	 else if (mode == XMESA_FX_FULLSCREEN) {
	    FX_grSstControl(GR_CONTROL_ACTIVATE);
	    xmbuf->FXwindowHack = GL_FALSE;
	    return GL_TRUE;
	 }
	 else {
	    /* Error: Bad mode value */
	 }
      }
   }
   /*fprintf(stderr, "fallthrough\n");*/
#else
   (void) mode;
#endif
   return GL_FALSE;
d1900 1
d1903 2
a1904 6

#ifdef FX
/*
 * Read image from VooDoo frame buffer into X/Mesa's back XImage.
 */
static void FXgetImage( XMesaBuffer b )
d1906 2
a1907 80
   GET_CURRENT_CONTEXT(ctx);
   static unsigned short pixbuf[MAX_WIDTH];
   GLuint x, y;
   GLuint width, height;
   XMesaContext xmesa = XMESA_CONTEXT(ctx);

#ifdef XFree86Server
   x = b->frontxrb->pixmap->x;
   y = b->frontxrb->pixmap->y;
   width = b->frontxrb->pixmap->width;
   height = b->frontxrb->pixmap->height;
   depth = b->frontxrb->pixmap->depth;
#else
   xmesa_get_window_size(b->display, b, &width, &height);
   x = y = 0;
#endif
   if (b->mesa_buffer.Width != width || b->mesa_buffer.Height != height) {
      b->mesa_buffer.Width = MIN2((int)width, b->FXctx->width);
      b->mesa_buffer.Height = MIN2((int)height, b->FXctx->height);
      if (b->mesa_buffer.Width & 1)
         b->mesa_buffer.Width--;  /* prevent odd width */
   }

   /* [dBorca] we're always in the right GR_COLORFORMAT... aren't we? */
   /* grLfbWriteColorFormat(GR_COLORFORMAT_ARGB); */
   if (b->xm_visual->undithered_pf==PF_5R6G5B) {
      /* Special case: 16bpp RGB */
      grLfbReadRegion( GR_BUFFER_FRONTBUFFER,       /* src buffer */
                       0, b->FXctx->height - b->mesa_buffer.Height,  /*pos*/
                       b->mesa_buffer.Width, b->mesa_buffer.Height,  /* size */
                       b->mesa_buffer.Width * sizeof(GLushort), /* stride */
                       b->backxrb->ximage->data);         /* dest buffer */
   }
   else if (b->xm_visual->dithered_pf==PF_Dither
	    && GET_VISUAL_DEPTH(b->xm_visual)==8) {
      /* Special case: 8bpp RGB */
      for (y=0;y<b->mesa_buffer.Height;y++) {
         GLubyte *ptr = (GLubyte*) b->backxrb->ximage->data
                        + b->backxrb->ximage->bytes_per_line * y;
         XDITHER_SETUP(y);

         /* read row from 3Dfx frame buffer */
         grLfbReadRegion( GR_BUFFER_FRONTBUFFER,
                          0, b->FXctx->height-(b->mesa_buffer.Height-y),
                          b->mesa_buffer.Width, 1,
                          0,
                          pixbuf );

         /* write to XImage back buffer */
         for (x=0;x<b->mesa_buffer.Width;x++) {
            GLubyte r = (pixbuf[x] & 0xf800) >> 8;
            GLubyte g = (pixbuf[x] & 0x07e0) >> 3;
            GLubyte b = (pixbuf[x] & 0x001f) << 3;
            *ptr++ = XDITHER( x, r, g, b);
         }
      }
   }
   else {
      /* General case: slow! */
      for (y=0;y<b->mesa_buffer.Height;y++) {
         /* read row from 3Dfx frame buffer */
         grLfbReadRegion( GR_BUFFER_FRONTBUFFER,
                          0, b->FXctx->height-(b->mesa_buffer.Height-y),
                          b->mesa_buffer.Width, 1,
                          0,
                          pixbuf );

         /* write to XImage back buffer */
         for (x=0;x<b->mesa_buffer.Width;x++) {
            XMesaPutPixel(b->backxrb->ximage,x,y,
			  xmesa_color_to_pixel(ctx,
					       (pixbuf[x] & 0xf800) >> 8,
					       (pixbuf[x] & 0x07e0) >> 3,
					       (pixbuf[x] & 0x001f) << 3,
					       0xff,
                                               b->xm_visual->undithered_pf));
         }
      }
   }
   /* grLfbWriteColorFormat(GR_COLORFORMAT_ABGR); */
d1912 1
d1917 1
d1935 2
a1936 8
      if (b->FXctx) {
         fxMesaSwapBuffers();

         if (b->FXwindowHack)
            FXgetImage(b);
         else
            return;
      }
d1938 2
a1939 2
     if (b->backxrb->ximage) {
        /* Copy Ximage (back buf) from client memory to server window */
d1973 3
d2005 2
a2006 7
      if (b->FXctx) {
         fxMesaSwapBuffers();
         if (b->FXwindowHack)
            FXgetImage(b);
         else
            return;
      }
d2154 1
a2154 1
         free_xmesa_buffer(0, b);
a2183 9
void XMesaReset( void )
{
    while (XMesaBufferList)
	XMesaDestroyBuffer(XMesaBufferList);

    XMesaBufferList = NULL;
}


d2247 1
a2247 1
void
d2252 2
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5.1
d25 4
a28 2
/*
 * This file contains the implementations of all the XMesa* functions.
a72 2
#include "matrix.h"
#include "mtypes.h"
a74 3
#include "texformat.h"
#include "texobj.h"
#include "texstore.h"
d87 1
a87 1
/*
d94 1
a94 1
/*
d161 1
a161 1
/*
d174 1
a174 17
/*
 * Error handling.
 */
#ifndef XFree86Server
static volatile int mesaXErrorFlag = 0;

static int mesaHandleXError( XMesaDisplay *dpy, XErrorEvent *event )
{
   (void) dpy;
   (void) event;
   mesaXErrorFlag = 1;
   return 0;
}
#endif


/*
d206 1
a206 1
/*
d210 2
a211 1
static GLint gamma_adjust( GLfloat gamma, GLint value, GLint max )
d224 1
a224 1
/*
d232 3
a235 3

static int bits_per_pixel( XMesaVisual xmv )
{
a243 2
}

a244 3

static int bits_per_pixel( XMesaVisual xmv )
{
d265 1
a266 1
#endif
d305 39
d352 9
a360 2
 * Allocate a new XMesaBuffer, initialize basic fields and add to
 * the list of all buffers.
d363 2
a364 1
alloc_xmesa_buffer(XMesaVisual vis, BufferType type, XMesaColormap cmap)
d366 4
a369 3
   XMesaBuffer b = (XMesaBuffer) CALLOC_STRUCT(xmesa_buffer);
   if (b) {
      GLboolean swAlpha;
d371 3
a373 4
      b->display = vis->display;
      b->xm_visual = vis;
      b->type = type;
      b->cmap = cmap;
d375 4
a378 1
      _mesa_initialize_framebuffer(&b->mesa_buffer, &vis->mesa_visual);
d380 1
a380 3
      /* Allocate the framebuffer's renderbuffers */
      assert(!b->mesa_buffer.Attachment[BUFFER_FRONT_LEFT].Renderbuffer);
      assert(!b->mesa_buffer.Attachment[BUFFER_BACK_LEFT].Renderbuffer);
d382 4
a385 2
      /* front renderbuffer */
      b->frontxrb = xmesa_new_renderbuffer(NULL, 0, &vis->mesa_visual,
d387 9
a395 2
      _mesa_add_renderbuffer(&b->mesa_buffer, BUFFER_FRONT_LEFT,
                             &b->frontxrb->Base);
d397 18
a414 23
      /* back renderbuffer */
      if (vis->mesa_visual.doubleBufferMode) {
         b->backxrb = xmesa_new_renderbuffer(NULL, 0, &vis->mesa_visual,
                                             GL_TRUE);
         /* determine back buffer implementation */
         b->db_mode = vis->ximage_flag ? BACK_XIMAGE : BACK_PIXMAP;

         _mesa_add_renderbuffer(&b->mesa_buffer, BUFFER_BACK_LEFT,
                                &b->backxrb->Base);
      }

      /* determine if we need software alpha planes */
      if (vis->mesa_visual.alphaBits > 0
          && vis->undithered_pf != PF_8A8B8G8R
          && vis->undithered_pf != PF_8A8R8G8B) {
         /* Visual has alpha, but pixel format doesn't support it.
          * We'll use an alpha renderbuffer wrapper.
          */
         swAlpha = GL_TRUE;
      }
      else {
         swAlpha = GL_FALSE;
      }
d416 10
a425 11
      _mesa_add_soft_renderbuffers(&b->mesa_buffer,
                                   GL_FALSE,  /* color */
                                   vis->mesa_visual.haveDepthBuffer,
                                   vis->mesa_visual.haveStencilBuffer,
                                   vis->mesa_visual.haveAccumBuffer,
                                   swAlpha,
                                   vis->mesa_visual.numAuxBuffers > 0 );

      /* insert into linked list */
      b->Next = XMesaBufferList;
      XMesaBufferList = b;
d427 19
d450 1
a450 1
/*
d454 2
a455 3
static XMesaBuffer find_xmesa_buffer(XMesaDisplay *dpy,
                                     XMesaColormap cmap,
                                     XMesaBuffer notThis)
d467 1
a467 1
/*
d471 2
a472 1
static void free_xmesa_buffer(int client, XMesaBuffer buffer)
d511 5
a515 2
/* Copy X color table stuff from one XMesaBuffer to another. */
static void copy_colortable_info(XMesaBuffer dst, const XMesaBuffer src)
a533 192
 * Allocate a shared memory XImage back buffer for the given XMesaBuffer.
 * Return:  GL_TRUE if success, GL_FALSE if error
 */
#ifndef XFree86Server
static GLboolean
alloc_shm_back_buffer(XMesaBuffer b, GLuint width, GLuint height)
{
#ifdef USE_XSHM
   /*
    * We have to do a _lot_ of error checking here to be sure we can
    * really use the XSHM extension.  It seems different servers trigger
    * errors at different points if the extension won't work.  Therefore
    * we have to be very careful...
    */
   GC gc;
   int (*old_handler)( XMesaDisplay *, XErrorEvent * );

   if (width == 0 || height == 0) {
      /* this will be true the first time we're called on 'b' */
      return GL_FALSE;
   }

   b->backxrb->ximage = XShmCreateImage(b->xm_visual->display,
                                        b->xm_visual->visinfo->visual,
                                        b->xm_visual->visinfo->depth,
                                        ZPixmap, NULL, &b->shminfo,
                                        width, height);
   if (b->backxrb->ximage == NULL) {
      _mesa_warning(NULL, "alloc_back_buffer: Shared memory error (XShmCreateImage), disabling.\n");
      b->shm = 0;
      return GL_FALSE;
   }

   b->shminfo.shmid = shmget( IPC_PRIVATE, b->backxrb->ximage->bytes_per_line
			     * b->backxrb->ximage->height, IPC_CREAT|0777 );
   if (b->shminfo.shmid < 0) {
      _mesa_warning(NULL, "shmget failed while allocating back buffer.\n");
      XDestroyImage( b->backxrb->ximage );
      b->backxrb->ximage = NULL;
      _mesa_warning(NULL, "alloc_back_buffer: Shared memory error (shmget), disabling.\n");
      b->shm = 0;
      return GL_FALSE;
   }

   b->shminfo.shmaddr = b->backxrb->ximage->data
                      = (char*)shmat( b->shminfo.shmid, 0, 0 );
   if (b->shminfo.shmaddr == (char *) -1) {
      _mesa_warning(NULL, "shmat() failed while allocating back buffer.\n");
      XDestroyImage( b->backxrb->ximage );
      shmctl( b->shminfo.shmid, IPC_RMID, 0 );
      b->backxrb->ximage = NULL;
      _mesa_warning(NULL, "alloc_back_buffer: Shared memory error (shmat), disabling.\n");
      b->shm = 0;
      return GL_FALSE;
   }

   b->shminfo.readOnly = False;
   mesaXErrorFlag = 0;
   old_handler = XSetErrorHandler( mesaHandleXError );
   /* This may trigger the X protocol error we're ready to catch: */
   XShmAttach( b->xm_visual->display, &b->shminfo );
   XSync( b->xm_visual->display, False );

   if (mesaXErrorFlag) {
      /* we are on a remote display, this error is normal, don't print it */
      XFlush( b->xm_visual->display );
      mesaXErrorFlag = 0;
      XDestroyImage( b->backxrb->ximage );
      shmdt( b->shminfo.shmaddr );
      shmctl( b->shminfo.shmid, IPC_RMID, 0 );
      b->backxrb->ximage = NULL;
      b->shm = 0;
      (void) XSetErrorHandler( old_handler );
      return GL_FALSE;
   }

   shmctl( b->shminfo.shmid, IPC_RMID, 0 ); /* nobody else needs it */

   /* Finally, try an XShmPutImage to be really sure the extension works */
   gc = XCreateGC( b->xm_visual->display, b->frontxrb->drawable, 0, NULL );
   XShmPutImage( b->xm_visual->display, b->frontxrb->drawable, gc,
		 b->backxrb->ximage, 0, 0, 0, 0, 1, 1 /*one pixel*/, False );
   XSync( b->xm_visual->display, False );
   XFreeGC( b->xm_visual->display, gc );
   (void) XSetErrorHandler( old_handler );
   if (mesaXErrorFlag) {
      XFlush( b->xm_visual->display );
      mesaXErrorFlag = 0;
      XDestroyImage( b->backxrb->ximage );
      shmdt( b->shminfo.shmaddr );
      shmctl( b->shminfo.shmid, IPC_RMID, 0 );
      b->backxrb->ximage = NULL;
      b->shm = 0;
      return GL_FALSE;
   }

   return GL_TRUE;
#else
   /* Can't compile XSHM support */
   return GL_FALSE;
#endif
}
#endif




/*
 * Setup an off-screen pixmap or Ximage to use as the back buffer.
 * Input:  b - the X/Mesa buffer
 */
void
xmesa_alloc_back_buffer( XMesaBuffer b, GLuint width, GLuint height )
{
   if (width == 0 || height == 0)
      return;

   if (b->db_mode == BACK_XIMAGE) {
      /* Deallocate the old backxrb->ximage, if any */
      if (b->backxrb->ximage) {
#if defined(USE_XSHM) && !defined(XFree86Server)
	 if (b->shm) {
	    XShmDetach( b->xm_visual->display, &b->shminfo );
	    XDestroyImage( b->backxrb->ximage );
	    shmdt( b->shminfo.shmaddr );
	 }
	 else
#endif
	   XMesaDestroyImage( b->backxrb->ximage );
	 b->backxrb->ximage = NULL;
      }

      /* Allocate new back buffer */
#ifdef XFree86Server
      /* Allocate a regular XImage for the back buffer. */
      b->backxrb->ximage = XMesaCreateImage(b->xm_visual->BitsPerPixel,
                                            width, height, NULL);
      {
#else
      if (b->shm == 0 || !alloc_shm_back_buffer(b, width, height)) {
	 /* Allocate a regular XImage for the back buffer. */
	 b->backxrb->ximage = XCreateImage( b->xm_visual->display,
                                      b->xm_visual->visinfo->visual,
                                      GET_VISUAL_DEPTH(b->xm_visual),
				      ZPixmap, 0,   /* format, offset */
				      NULL,
                                      width, height,
				      8, 0 );  /* pad, bytes_per_line */
#endif
	 if (!b->backxrb->ximage) {
	    _mesa_warning(NULL, "alloc_back_buffer: XCreateImage failed.\n");
            return;
	 }
         b->backxrb->ximage->data = (char *) MALLOC( b->backxrb->ximage->height
                                        * b->backxrb->ximage->bytes_per_line );
         if (!b->backxrb->ximage->data) {
            _mesa_warning(NULL, "alloc_back_buffer: MALLOC failed.\n");
            XMesaDestroyImage( b->backxrb->ximage );
            b->backxrb->ximage = NULL;
         }
         else {
            /* this call just updates the width/origin fields in the xrb */
            b->backxrb->Base.AllocStorage(NULL, &b->backxrb->Base, 
                                          b->backxrb->Base.InternalFormat,
                                          b->backxrb->ximage->width,
                                          b->backxrb->ximage->height);
         }
      }
      b->backxrb->pixmap = None;
   }
   else if (b->db_mode == BACK_PIXMAP) {
      if (!width)
         width = 1;
      if (!height)
         height = 1;

      /* Free the old back pixmap */
      if (b->backxrb->pixmap) {
	 XMesaFreePixmap( b->xm_visual->display, b->backxrb->pixmap );
      }
      /* Allocate new back pixmap */
      b->backxrb->pixmap = XMesaCreatePixmap( b->xm_visual->display,
                                              b->frontxrb->drawable,
                                              width, height,
                                              GET_VISUAL_DEPTH(b->xm_visual) );
      b->backxrb->ximage = NULL;
   }
}



/*
d576 1
a576 1
		  client) == Success) {
d578 1
a578 1
   if (XAllocColor(dpy, cmap, color)) {
d580 1
d670 1
a670 2

/*
d674 3
a676 2
static GLboolean setup_grayscale( int client, XMesaVisual v,
                                  XMesaBuffer buffer, XMesaColormap cmap )
d755 1
a755 1
/*
d763 3
a765 2
static GLboolean setup_dithered_color( int client, XMesaVisual v,
                                       XMesaBuffer buffer, XMesaColormap cmap )
d835 1
a835 1
/*
d840 2
a841 1
static void setup_8bit_hpcr( XMesaVisual v )
d891 1
a891 1
/*
d894 2
a895 2
static void setup_truecolor( XMesaVisual v, XMesaBuffer buffer,
                             XMesaColormap cmap )
d1035 1
a1035 1
/*
d1038 2
a1039 1
static void setup_monochrome( XMesaVisual v, XMesaBuffer b )
d1049 14
a1062 16
/*
 * When a context is "made current" for the first time, we can finally
 * finish initializing the context's visual and buffer information.
 * Input:  v - the XMesaVisual to initialize
 *         b - the XMesaBuffer to initialize (may be NULL)
 *         rgb_flag - TRUE = RGBA mode, FALSE = color index mode
 *         window - the window/pixmap we're rendering into
 *         cmap - the colormap associated with the window/pixmap
 * Return:  GL_TRUE=success, GL_FALSE=failure
 */
static GLboolean initialize_visual_and_buffer( int client,
                                               XMesaVisual v,
                                               XMesaBuffer b,
                                               GLboolean rgb_flag,
                                               XMesaDrawable window,
                                               XMesaColormap cmap )
d1064 1
a1064 16
   struct xmesa_renderbuffer *front_xrb, *back_xrb;
#ifndef XFree86Server
   XGCValues gcvalues;
#endif

   if (b) {
      assert(b->xm_visual == v);
   }

   if (b) {
      front_xrb = b->frontxrb;
      back_xrb = b->backxrb;
   }
   else {
      front_xrb = back_xrb = NULL;
   }
d1070 1
a1070 2

   if (rgb_flag==GL_FALSE) {
d1083 1
a1083 1
      if (xclass==GLX_TRUE_COLOR || xclass==GLX_DIRECT_COLOR) {
d1086 1
a1086 1
      else if (xclass==GLX_STATIC_GRAY && GET_VISUAL_DEPTH(v)==1) {
d1089 1
a1089 1
      else if (xclass==GLX_GRAY_SCALE || xclass==GLX_STATIC_GRAY) {
d1094 1
a1094 1
      else if ((xclass==GLX_PSEUDO_COLOR || xclass==GLX_STATIC_COLOR)
d1129 3
a1131 2
      b->frontxrb->drawable = window;
      b->frontxrb->pixmap = (XMesaPixmap) window;
a1136 1
         xmesa_alloc_back_buffer(b, b->mesa_buffer.Width, b->mesa_buffer.Height);
d1167 6
a1172 3
      gcvalues.graphics_exposures = False;
      b->swapgc = XCreateGC( v->display, window,
                              GCGraphicsExposures, &gcvalues);
d1181 10
a1190 11
      if (v->hpcr_clear_flag && back_xrb->pixmap) {
	int i;
	for (i=0; i<16; i++)
        {
	   XMesaPutPixel(v->hpcr_clear_ximage, i, 0, 0);
	   XMesaPutPixel(v->hpcr_clear_ximage, i, 1, 0);
        }
        XMesaPutImage(b->display, (XMesaDrawable) v->hpcr_clear_pixmap,
		      b->cleargc, v->hpcr_clear_ximage, 0, 0, 0, 0, 16, 2);
	XMesaSetFillStyle( v->display, b->cleargc, FillTiled);
	XMesaSetTile( v->display, b->cleargc, v->hpcr_clear_pixmap );
d1353 1
a1359 3
#ifdef XFree86Server
      /* NOT_NEEDED */
#else
d1361 1
a1362 1
   }
d1439 1
a1439 1
      if (xclass==GLX_TRUE_COLOR || xclass==GLX_DIRECT_COLOR) {
d1597 7
a1603 7
/*
 * XXX this isn't a public function!  It's a hack for the 3Dfx driver.
 * Create a new XMesaBuffer from an X window.
 * Input:  v - the XMesaVisual
 *         w - the window
 *         c - the context
 * Return:  new XMesaBuffer or NULL if error
d1619 1
d1656 2
a1657 2
   b = alloc_xmesa_buffer(v, WINDOW, cmap);
   if (!b) {
a1658 1
   }
d1773 2
a1774 2
   b = alloc_xmesa_buffer(v, PIXMAP, cmap);
   if (!b) {
a1775 1
   }
d1804 5
a1808 2
   b = alloc_xmesa_buffer(v, PBUFFER, cmap);
   if (!b) {
a1809 1
   }
d1811 3
a1813 3
   /* allocate pixmap for front buffer */
   root = RootWindow( v->display, v->visinfo->screen );
   drawable = XCreatePixmap( v->display, root, width, height, v->visinfo->depth );
d1875 23
d1930 1
a1930 1
          && ((XMesaBuffer) c->mesa.DrawBuffer)->wasCurrent) {
d1942 4
d2016 1
a2016 1
      return (XMesaBuffer) (ctx->ReadBuffer);
d2105 1
a2105 3
   int xpos, ypos;
   XMesaWindow root;
   unsigned int bw, depth, width, height;
d2115 2
a2116 2
   XGetGeometry( b->xm_visual->display, b->frontxrb->pixmap,
                 &root, &xpos, &ypos, &width, &height, &bw, &depth);
a2122 1
      xmesa_alloc_back_buffer(b, b->mesa_buffer.Width, b->mesa_buffer.Height);
d2217 1
a2217 1
	 /* Copy Ximage from host's memory to server's window */
d2239 2
a2240 2
      else {
	 /* Copy pixmap to window on server */
d2536 2
a2537 1
void XMesaResizeBuffers( XMesaBuffer b )
a2538 2
#ifdef XFree86Server
   GLuint winwidth, winheight;
d2540 2
a2541 14

   winwidth = MIN2(b->frontxrb->drawable->width, MAX_WIDTH);
   winheight = MIN2(b->frontxrb->drawable->height, MAX_HEIGHT);

   xmesa_resize_buffers(ctx, &(b->mesa_buffer), winwidth, winheight);
#else
   Window root;
   int xpos, ypos;
   unsigned int width, height, bw, depth;
   GET_CURRENT_CONTEXT(ctx);
   XGetGeometry( b->xm_visual->display, b->frontxrb->pixmap,
                 &root, &xpos, &ypos, &width, &height, &bw, &depth);
   xmesa_resize_buffers(ctx, &(b->mesa_buffer), width, height);
#endif
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d3 1
a3 1
 * Version:  6.5.2
d25 2
a26 4
/**
 * \file xm_api.c
 *
 * All the XMesa* API functions.
d71 2
d75 3
d90 1
a90 1
/**
d97 1
a97 1
/**
d164 1
a164 1
/**
d177 17
a193 1
/**
d225 1
a225 1
/**
d229 1
a229 2
static GLint
gamma_adjust( GLfloat gamma, GLint value, GLint max )
d242 1
a242 1
/**
d250 3
a252 2
static int
bits_per_pixel( XMesaVisual xmv )
a253 1
#ifdef XFree86Server
d262 2
d265 3
d288 1
a289 1
}
a327 39
/**
 * Return the size of the window (or pixmap) that corresponds to the
 * given XMesaBuffer.
 * \param width  returns width in pixels
 * \param height  returns height in pixels
 */
void
xmesa_get_window_size(XMesaDisplay *dpy, XMesaBuffer b,
                      GLuint *width, GLuint *height)
{
#ifdef XFree86Server
   *width = MIN2(b->frontxrb->drawable->width, MAX_WIDTH);
   *height = MIN2(b->frontxrb->drawable->height, MAX_HEIGHT);
#else
   Window root;
   Status stat;
   int xpos, ypos;
   unsigned int w, h, bw, depth;

   _glthread_LOCK_MUTEX(_xmesa_lock);
   XSync(b->xm_visual->display, 0); /* added for Chromium */
   stat = XGetGeometry(dpy, b->frontxrb->pixmap, &root, &xpos, &ypos,
                       &w, &h, &bw, &depth);
   _glthread_UNLOCK_MUTEX(_xmesa_lock);

   if (stat) {
      *width = w;
      *height = h;
   }
   else {
      /* probably querying a window that's recently been destroyed */
      _mesa_warning(NULL, "XGetGeometry failed!\n");
      *width = *height = 1;
   }
#endif
}



d336 2
a337 9
 * Allocate a new XMesaBuffer object which corresponds to the given drawable.
 * Note that XMesaBuffer is derived from GLframebuffer.
 * The new XMesaBuffer will not have any size (Width=Height=0).
 *
 * \param d  the corresponding X drawable (window or pixmap)
 * \param type  either WINDOW, PIXMAP or PBUFFER, describing d
 * \param vis  the buffer's visual
 * \param cmap  the window's colormap, if known.
 * \return new XMesaBuffer or NULL if any problem
d340 1
a340 2
create_xmesa_buffer(XMesaDrawable d, BufferType type,
                    XMesaVisual vis, XMesaColormap cmap)
d342 3
a344 4
   GLboolean swAlpha;
   XMesaBuffer b;

   ASSERT(type == WINDOW || type == PIXMAP || type == PBUFFER);
d346 4
a349 3
   b = (XMesaBuffer) CALLOC_STRUCT(xmesa_buffer);
   if (!b)
      return NULL;
d351 1
a351 4
   b->display = vis->display;
   b->xm_visual = vis;
   b->type = type;
   b->cmap = cmap;
d353 3
a355 1
   _mesa_initialize_framebuffer(&b->mesa_buffer, &vis->mesa_visual);
d357 2
a358 4
   /*
    * Front renderbuffer
    */
   b->frontxrb = xmesa_new_renderbuffer(NULL, 0, &vis->mesa_visual,
d360 2
a361 9
   if (!b->frontxrb) {
      _mesa_free(b);
      return NULL;
   }
   b->frontxrb->Parent = b;
   b->frontxrb->drawable = d;
   b->frontxrb->pixmap = (XMesaPixmap) d;
   _mesa_add_renderbuffer(&b->mesa_buffer, BUFFER_FRONT_LEFT,
                          &b->frontxrb->Base);
d363 23
a385 18
   /*
    * Back renderbuffer
    */
   if (vis->mesa_visual.doubleBufferMode) {
      b->backxrb = xmesa_new_renderbuffer(NULL, 0, &vis->mesa_visual,
                                          GL_TRUE);
      if (!b->backxrb) {
         /* XXX free front xrb too */
         _mesa_free(b);
         return NULL;
      }
      b->backxrb->Parent = b;
      /* determine back buffer implementation */
      b->db_mode = vis->ximage_flag ? BACK_XIMAGE : BACK_PIXMAP;
      
      _mesa_add_renderbuffer(&b->mesa_buffer, BUFFER_BACK_LEFT,
                             &b->backxrb->Base);
   }
d387 11
a397 10
   /*
    * Software alpha planes
    */
   if (vis->mesa_visual.alphaBits > 0
       && vis->undithered_pf != PF_8A8B8G8R
       && vis->undithered_pf != PF_8A8R8G8B) {
      /* Visual has alpha, but pixel format doesn't support it.
       * We'll use an alpha renderbuffer wrapper.
       */
      swAlpha = GL_TRUE;
a398 19
   else {
      swAlpha = GL_FALSE;
   }

   /*
    * Other renderbuffer (depth, stencil, etc)
    */
   _mesa_add_soft_renderbuffers(&b->mesa_buffer,
                                GL_FALSE,  /* color */
                                vis->mesa_visual.haveDepthBuffer,
                                vis->mesa_visual.haveStencilBuffer,
                                vis->mesa_visual.haveAccumBuffer,
                                swAlpha,
                                vis->mesa_visual.numAuxBuffers > 0 );
   
   /* insert buffer into linked list */
   b->Next = XMesaBufferList;
   XMesaBufferList = b;

d403 1
a403 1
/**
d407 3
a409 2
static XMesaBuffer
find_xmesa_buffer(XMesaDisplay *dpy, XMesaColormap cmap, XMesaBuffer notThis)
d421 1
a421 1
/**
d425 1
a425 2
static void
free_xmesa_buffer(int client, XMesaBuffer buffer)
d464 2
a465 5
/**
 * Copy X color table stuff from one XMesaBuffer to another.
 */
static void
copy_colortable_info(XMesaBuffer dst, const XMesaBuffer src)
d484 192
d718 1
a718 1
		  client) == Success)
d720 1
a720 1
   if (XAllocColor(dpy, cmap, color))
a721 1
   {
d811 2
a812 1
/**
d816 2
a817 3
static GLboolean
setup_grayscale(int client, XMesaVisual v,
                XMesaBuffer buffer, XMesaColormap cmap)
d896 1
a896 1
/**
d904 2
a905 3
static GLboolean
setup_dithered_color(int client, XMesaVisual v,
                     XMesaBuffer buffer, XMesaColormap cmap)
d975 1
a975 1
/**
d980 1
a980 2
static void
setup_8bit_hpcr(XMesaVisual v)
d1030 1
a1030 1
/**
d1033 2
a1034 2
static void
setup_truecolor(XMesaVisual v, XMesaBuffer buffer, XMesaColormap cmap)
d1174 1
a1174 1
/**
d1177 1
a1177 2
static void
setup_monochrome( XMesaVisual v, XMesaBuffer b )
d1187 16
a1202 14
/**
 * When a context is bound for the first time, we can finally finish
 * initializing the context's visual and buffer information.
 * \param v  the XMesaVisual to initialize
 * \param b  the XMesaBuffer to initialize (may be NULL)
 * \param rgb_flag  TRUE = RGBA mode, FALSE = color index mode
 * \param window  the window/pixmap we're rendering into
 * \param cmap  the colormap associated with the window/pixmap
 * \return GL_TRUE=success, GL_FALSE=failure
 */
static GLboolean
initialize_visual_and_buffer(int client, XMesaVisual v, XMesaBuffer b,
                             GLboolean rgb_flag, XMesaDrawable window,
                             XMesaColormap cmap)
d1204 16
a1219 1
   ASSERT(!b || b->xm_visual == v);
d1225 2
a1226 1
   if (rgb_flag == GL_FALSE) {
d1239 1
a1239 1
      if (xclass == GLX_TRUE_COLOR || xclass == GLX_DIRECT_COLOR) {
d1242 1
a1242 1
      else if (xclass == GLX_STATIC_GRAY && GET_VISUAL_DEPTH(v) == 1) {
d1245 1
a1245 1
      else if (xclass == GLX_GRAY_SCALE || xclass == GLX_STATIC_GRAY) {
d1250 1
a1250 1
      else if ((xclass == GLX_PSEUDO_COLOR || xclass == GLX_STATIC_COLOR)
d1285 2
a1286 3
      /* these should have been set in create_xmesa_buffer */
      ASSERT(b->frontxrb->drawable == window);
      ASSERT(b->frontxrb->pixmap == (XMesaPixmap) window);
d1292 1
d1323 3
a1325 6
      {
         XGCValues gcvalues;
         gcvalues.graphics_exposures = False;
         b->swapgc = XCreateGC(v->display, window,
                               GCGraphicsExposures, &gcvalues);
      }
d1334 11
a1344 10
      if (v->hpcr_clear_flag && b->backxrb && b->backxrb->pixmap) {
         int i;
         for (i = 0; i < 16; i++) {
            XMesaPutPixel(v->hpcr_clear_ximage, i, 0, 0);
            XMesaPutPixel(v->hpcr_clear_ximage, i, 1, 0);
         }
         XMesaPutImage(b->display, (XMesaDrawable) v->hpcr_clear_pixmap,
                       b->cleargc, v->hpcr_clear_ximage, 0, 0, 0, 0, 16, 2);
         XMesaSetFillStyle( v->display, b->cleargc, FillTiled);
         XMesaSetTile( v->display, b->cleargc, v->hpcr_clear_pixmap );
a1506 1
#ifndef XFree86Server
d1513 3
d1517 1
a1518 1
#endif
d1595 1
a1595 1
      if (xclass == GLX_TRUE_COLOR || xclass == GLX_DIRECT_COLOR) {
d1753 7
a1759 7
/**
 * Private function for creating an XMesaBuffer which corresponds to an
 * X window or pixmap.
 * \param v  the window's XMesaVisual
 * \param w  the window we're wrapping
 * \param c  context used to initialize the buffer if 3Dfx mode in use.
 * \return  new XMesaBuffer or NULL if error
a1774 1
   assert(w);
d1811 2
a1812 2
   b = create_xmesa_buffer((XMesaDrawable) w, WINDOW, v, cmap);
   if (!b)
d1814 1
d1929 2
a1930 2
   b = create_xmesa_buffer((XMesaDrawable) p, PIXMAP, v, cmap);
   if (!b)
d1932 1
d1961 5
d1968 1
a1968 8
   drawable = XCreatePixmap(v->display, root, width, height,
                            v->visinfo->depth);
   if (!drawable)
      return NULL;

   b = create_xmesa_buffer(drawable, PBUFFER, v, cmap);
   if (!b)
      return NULL;
a2029 21
/**
 * Query the current window size and update the corresponding GLframebuffer
 * and all attached renderbuffers.
 * Called when:
 *  1. the first time a buffer is bound to a context.
 *  2. from glViewport to poll for window size changes
 *  3. from the XMesaResizeBuffers() API function.
 */
void
xmesa_check_and_update_buffer_size(XMesaContext xmctx, XMesaBuffer drawBuffer)
{
   GLuint width, height;
   xmesa_get_window_size(xmctx->display, drawBuffer, &width, &height);
   if (drawBuffer->mesa_buffer.Width != width ||
       drawBuffer->mesa_buffer.Height != height) {
      _mesa_resize_framebuffer(&(xmctx->mesa),
                               &(drawBuffer->mesa_buffer), width, height);
   }
   drawBuffer->mesa_buffer.Initialized = GL_TRUE; /* XXX TEMPORARY? */
}

d2062 1
a2062 1
          && XMESA_BUFFER(c->mesa.DrawBuffer)->wasCurrent) {
a2073 4
      xmesa_check_and_update_buffer_size(c, drawBuffer);
      if (readBuffer != drawBuffer)
         xmesa_check_and_update_buffer_size(c, readBuffer);

d2144 1
a2144 1
      return XMESA_BUFFER(ctx->ReadBuffer);
d2233 3
a2235 1
   GLuint width, height;
d2245 2
a2246 2
   xmesa_get_window_size(b->display, b, &width, &height);
   x = y = 0;
d2253 1
d2667 1
a2667 2
void
XMesaResizeBuffers( XMesaBuffer b )
d2669 2
d2672 14
a2685 2
   XMesaContext xmctx = XMESA_CONTEXT(ctx);
   xmesa_check_and_update_buffer_size(xmctx, b);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d77 1
a77 1
#include "vbo/vbo.h"
d83 4
d182 3
a184 1
#if defined(USE_XSHM) && !defined(XFree86Server)
d348 1
a348 1
XMesaBuffer XMesaBufferList = NULL;
d366 1
a380 1
   b->mesa_buffer.Delete = xmesa_delete_framebuffer;
d385 2
a386 1
   b->frontxrb = xmesa_new_renderbuffer(NULL, 0, &vis->mesa_visual, GL_FALSE);
d401 2
a402 1
      b->backxrb = xmesa_new_renderbuffer(NULL, 0, &vis->mesa_visual, GL_TRUE);
d425 1
a425 1
      b->swAlpha = GL_TRUE;
d428 1
a428 1
      b->swAlpha = GL_FALSE;
d439 1
a439 1
                                b->swAlpha,
d441 1
a441 1

d454 2
a455 2
XMesaBuffer
xmesa_find_buffer(XMesaDisplay *dpy, XMesaColormap cmap, XMesaBuffer notThis)
d468 2
a469 1
 * Remove buffer from linked list, delete if no longer referenced.
d472 1
a472 1
xmesa_free_buffer(XMesaBuffer buffer)
d475 4
a478 6

   for (b = XMesaBufferList; b; b = b->Next) {
      if (b == buffer) {
         struct gl_framebuffer *fb = &buffer->mesa_buffer;

         /* unlink buffer from list */
d483 14
d498 2
a499 10
         /* mark as delete pending */
         fb->DeletePending = GL_TRUE;

         /* Since the X window for the XMesaBuffer is going away, we don't
          * want to dereference this pointer in the future.
          */
         b->frontxrb->drawable = 0;

         /* Unreference.  If count = zero we'll really delete the buffer */
         _mesa_unreference_framebuffer(&fb);
d507 1
a507 1
   _mesa_problem(NULL,"xmesa_free_buffer() - buffer not found\n");
d689 1
a689 1
      prevBuffer = xmesa_find_buffer(v->display, cmap, buffer);
d778 1
a778 1
      prevBuffer = xmesa_find_buffer(v->display, cmap, buffer);
d986 1
d989 1
a989 1
      v->undithered_pf = v->dithered_pf = PF_8A8B8G8R; /* ABGR */
d991 22
a1012 15
   else if (GET_REDMASK(v)  == 0xff0000
         && GET_GREENMASK(v)== 0x00ff00
         && GET_BLUEMASK(v) == 0x0000ff
         && CHECK_BYTE_ORDER(v)
         && v->RedGamma == 1.0 && v->GreenGamma == 1.0 && v->BlueGamma == 1.0){
      if (v->BitsPerPixel==32) {
         /* if 32 bpp, and visual indicates 8 bpp alpha channel */
         if (GET_VISUAL_DEPTH(v) == 32 && v->mesa_visual.alphaBits == 8)
            v->undithered_pf = v->dithered_pf = PF_8A8R8G8B; /* ARGB */
         else
            v->undithered_pf = v->dithered_pf = PF_8R8G8B; /* xRGB */
      }
      else if (v->BitsPerPixel == 24) {
         v->undithered_pf = v->dithered_pf = PF_8R8G8B24; /* RGB */
      }
d1019 1
d1021 1
a1021 1
      /* 5-6-5 RGB */
a1028 1
      /* 8-bit HP color recovery */
d1060 1
a1060 1
initialize_visual_and_buffer(XMesaVisual v, XMesaBuffer b,
a1063 6
   int client = 0;

#ifdef XFree86Server
   client = (window) ? CLIENT_ID(window->id) : 0;
#endif

a1126 2
      char *data;

a1193 1
      data = (char*) MALLOC(MAX_WIDTH*4);
d1195 2
a1196 1
      b->rowimage = XMesaCreateImage(GET_VISUAL_DEPTH(v), MAX_WIDTH, 1, data);
d1202 1
a1202 1
                                  data,                 /*data*/
a1331 1
PUBLIC
d1369 5
d1435 1
a1435 4
   if (alpha_flag)
      v->mesa_visual.alphaBits = 8;

   (void) initialize_visual_and_buffer( v, NULL, rgb_flag, 0, 0 );
d1443 1
a1456 1
      alpha_bits = v->mesa_visual.alphaBits;
d1459 3
d1479 6
a1484 1
PUBLIC
a1501 1
PUBLIC
a1547 7
#ifdef XFree86Server
   /* If we're running in the X server, do bounds checking to prevent
    * segfaults and server crashes!
    */
   mesaCtx->Const.CheckArrayBounds = GL_TRUE;
#endif

d1558 1
a1558 1
       !_vbo_CreateContext( mesaCtx ) ||
a1577 1
PUBLIC
d1581 2
d1584 2
a1585 2
#ifdef FX
   FXdestroyContext( XMESA_BUFFER(mesaCtx->DrawBuffer) );
a1586 1

d1590 1
a1590 1
   _vbo_DestroyContext( mesaCtx );
d1602 1
d1605 2
a1606 2
PUBLIC XMesaBuffer
XMesaCreateWindowBuffer(XMesaVisual v, XMesaWindow w)
d1611 4
a1616 1
   int depth;
d1620 1
d1624 7
a1630 1
   depth = ((XMesaDrawable)w)->depth;
d1633 2
a1634 3
   depth = attr.depth;
#endif
   if (GET_VISUAL_DEPTH(v) != depth) {
d1636 1
a1636 1
                    GET_VISUAL_DEPTH(v), depth);
d1639 1
d1660 1
a1660 1
   if (!initialize_visual_and_buffer( v, b, v->mesa_visual.rgbMode,
d1662 1
a1662 1
      xmesa_free_buffer(b);
d1666 79
d1749 6
d1765 1
a1765 1
PUBLIC XMesaBuffer
d1768 1
d1777 5
a1781 1
   if (!initialize_visual_and_buffer(v, b, v->mesa_visual.rgbMode,
d1783 1
a1783 1
      xmesa_free_buffer(b);
d1796 4
a1799 1
#ifndef XFree86Server
d1815 1
a1815 1
   if (!initialize_visual_and_buffer(v, b, v->mesa_visual.rgbMode,
d1817 1
a1817 1
      xmesa_free_buffer(b);
a1821 2
#else
   return 0;
d1830 1
a1830 2
PUBLIC void
XMesaDestroyBuffer(XMesaBuffer b)
d1832 40
a1871 1
   xmesa_free_buffer(b);
a1881 2
 * Note: it's possible (and legal) for xmctx to be NULL.  That can happen
 * when resizing a buffer when no rendering context is bound.
d1887 1
a1887 1
   xmesa_get_window_size(drawBuffer->display, drawBuffer, &width, &height);
d1890 2
a1891 2
      GLcontext *ctx = xmctx ? &xmctx->mesa : NULL;
      _mesa_resize_framebuffer(ctx, &(drawBuffer->mesa_buffer), width, height);
a1908 1
PUBLIC
d1916 9
a1934 5
#ifdef FX
      if (FXmakeCurrent( drawBuffer ))
         return GL_TRUE;
#endif

a2021 2
#ifdef XFree86Server
PUBLIC
a2024 2
      _glapi_set_dispatch(c->mesa.CurrentDispatch);

a2035 1
PUBLIC
d2044 4
a2047 2
PUBLIC
GLboolean XMesaCopyContext( XMesaContext xm_src, XMesaContext xm_dst, GLuint mask )
d2049 41
a2089 2
   _mesa_copy_context(&xm_src->mesa, &xm_dst->mesa, mask);
   return GL_TRUE;
a2090 1
#endif /* XFree86Server */
d2093 6
a2098 2
#ifndef FX
GLboolean XMesaSetFXmode( GLint mode )
d2100 80
a2179 2
   (void) mode;
   return GL_FALSE;
a2183 1

a2187 1
PUBLIC
d2205 8
a2212 2
      if (FXswapBuffers(b))
         return;
d2214 2
a2215 2
      if (b->backxrb->ximage) {
	 /* Copy Ximage (back buf) from client memory to server window */
d2237 2
a2238 2
      else if (b->backxrb->pixmap) {
	 /* Copy pixmap (back buf) to window (front buf) on server */
a2248 3

      if (b->swAlpha)
         _mesa_copy_soft_alpha_renderbuffers(ctx, &b->mesa_buffer);
d2278 7
a2284 2
      if (FXswapBuffers(b))
         return;
d2432 1
a2432 1
         xmesa_free_buffer(b);
d2462 9
d2534 1
a2534 1
PUBLIC void
a2538 2
   if (!xmctx)
      return;
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d66 1
d68 7
a74 8
#include "main/context.h"
#include "main/extensions.h"
#include "main/framebuffer.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/renderbuffer.h"
#include "main/teximage.h"
#include "glapi/glthread.h"
a81 1
#include "drivers/common/meta.h"
d160 1
d167 1
d178 1
a178 1
#if defined(USE_XSHM) 
d212 1
a212 1
      return IROUND_POS((GLfloat) max * pow(x, 1.0F/gamma));
d229 10
d255 1
a255 1
   free( img->data );
d259 1
d273 1
d295 1
a296 12
static Status
get_drawable_size( XMesaDisplay *dpy, Drawable d, GLuint *width, GLuint *height )
{
   Window root;
   Status stat;
   int xpos, ypos;
   unsigned int w, h, bw, depth;
   stat = XGetGeometry(dpy, d, &root, &xpos, &ypos, &w, &h, &bw, &depth);
   *width = w;
   *height = h;
   return stat;
}
d309 5
d315 2
d320 2
a321 1
   stat = get_drawable_size(dpy, b->frontxrb->pixmap, width, height);
d324 5
a328 1
   if (!stat) {
d333 1
d347 1
a347 1
 * Note that XMesaBuffer is derived from struct gl_framebuffer.
d373 1
a373 1
   _mesa_initialize_window_framebuffer(&b->mesa_buffer, &vis->mesa_visual);
d381 1
a381 1
      free(b);
d397 1
a397 1
         free(b);
a433 5
   /* GLX_EXT_texture_from_pixmap */
   b->TextureTarget = 0;
   b->TextureFormat = GLX_TEXTURE_FORMAT_NONE_EXT;
   b->TextureMipmap = 0;

d486 1
a486 1
         _mesa_reference_framebuffer(&fb, NULL);
d504 4
a507 4
   memcpy(dst->color_table, src->color_table, sizeof(src->color_table));
   memcpy(dst->pixel_to_r, src->pixel_to_r, sizeof(src->pixel_to_r));
   memcpy(dst->pixel_to_g, src->pixel_to_g, sizeof(src->pixel_to_g));
   memcpy(dst->pixel_to_b, src->pixel_to_b, sizeof(src->pixel_to_b));
d509 1
a509 1
   memcpy(dst->alloced_colors, src->alloced_colors,
d542 4
d551 1
d559 6
d566 1
d577 8
d589 1
a589 1
         free(ctable);
d601 1
d625 6
d632 1
d644 4
d649 1
d677 3
a679 1
      if (prevBuffer) {
d766 3
a768 1
      if (prevBuffer) {
d843 1
a843 1
      GLint red = IROUND_POS(255.0 * pow( hpcr_rgbTbl[0][i]/255.0, g ));
d849 1
a849 1
      GLint green = IROUND_POS(255.0 * pow( hpcr_rgbTbl[1][i]/255.0, g ));
d855 1
a855 1
      GLint blue = IROUND_POS(255.0 * pow( hpcr_rgbTbl[2][i]/255.0, g ));
d870 1
d873 1
d1040 1
a1040 1
                             XMesaDrawable window,
a1043 1
   const int xclass = v->visualType;
d1045 3
d1055 7
a1061 5
   /* RGB WINDOW:
    * We support RGB rendering into almost any kind of visual.
    */
   if (xclass == GLX_TRUE_COLOR || xclass == GLX_DIRECT_COLOR) {
      setup_truecolor( v, b, cmap );
d1063 21
a1083 6
   else if (xclass == GLX_STATIC_GRAY && GET_VISUAL_DEPTH(v) == 1) {
      setup_monochrome( v, b );
   }
   else if (xclass == GLX_GRAY_SCALE || xclass == GLX_STATIC_GRAY) {
      if (!setup_grayscale( client, v, b, cmap )) {
	 return GL_FALSE;
d1085 2
a1086 4
   }
   else if ((xclass == GLX_PSEUDO_COLOR || xclass == GLX_STATIC_COLOR)
	    && GET_VISUAL_DEPTH(v)>=4 && GET_VISUAL_DEPTH(v)<=16) {
      if (!setup_dithered_color( client, v, b, cmap )) {
d1089 1
a1089 6
   }
   else {
      _mesa_warning(NULL, "XMesa: RGB mode rendering not supported in given visual.\n");
      return GL_FALSE;
   }
   v->mesa_visual.indexBits = 0;
d1091 3
a1093 2
   if (_mesa_getenv("MESA_NO_DITHER")) {
      v->dithered_pf = v->undithered_pf;
d1103 6
a1108 6
      printf("X/Mesa visual = %p\n", (void *) v);
      printf("X/Mesa dithered pf = %u\n", v->dithered_pf);
      printf("X/Mesa undithered pf = %u\n", v->undithered_pf);
      printf("X/Mesa level = %d\n", v->mesa_visual.level);
      printf("X/Mesa depth = %d\n", GET_VISUAL_DEPTH(v));
      printf("X/Mesa bits per pixel = %d\n", v->BitsPerPixel);
d1127 3
d1131 1
d1135 3
d1139 1
d1146 8
d1160 1
d1182 3
d1193 1
d1207 1
a1207 1
xmesa_color_to_pixel(struct gl_context *ctx,
d1341 1
d1350 1
a1350 4

   /* Color-index rendering not supported. */
   if (!rgb_flag)
      return NULL;
d1359 1
a1359 1
   /* Save a copy of the XVisualInfo struct because the user may Xfree()
d1363 1
d1366 1
a1366 1
      free(v);
d1369 2
a1370 1
   memcpy(v->visinfo, visinfo, sizeof(*visinfo));
d1387 16
d1406 3
a1408 2
   v->visualID = visinfo->visualid;
   v->screen = visinfo->screen;
d1410 2
a1411 2
#if !(defined(__cplusplus) || defined(c_plusplus))
   v->visualType = xmesa_convert_from_x_visual_type(visinfo->class);
d1413 1
a1413 1
   v->visualType = xmesa_convert_from_x_visual_type(visinfo->c_class);
d1421 1
a1421 1
   (void) initialize_visual_and_buffer( v, NULL, 0, 0 );
d1424 1
a1424 1
      const int xclass = v->visualType;
d1446 1
a1446 1
                            db_flag, stereo_flag,
d1449 1
d1465 4
a1468 2
   free(v->visinfo);
   free(v);
d1485 1
a1485 1
   struct gl_context *mesaCtx;
d1494 1
a1494 1
   /* Note: the XMesaContext contains a Mesa struct gl_context struct (inheritance) */
d1505 1
a1505 1
                      share_list ? &(share_list->mesa) : (struct gl_context *) NULL,
d1507 1
a1507 1
      free(c);
a1510 8
   /* Enable this to exercise fixed function -> shader translation
    * with software rendering.
    */
   if (0) {
      mesaCtx->VertexProgram._MaintainTnlProgram = GL_TRUE;
      mesaCtx->FragmentProgram._MaintainTexEnvProgram = GL_TRUE;
   }

a1515 1
   _mesa_enable_2_1_extensions(mesaCtx);
d1517 1
a1517 1
    if (mesaCtx->Mesa_DXTn) {
d1527 6
d1548 1
a1548 1
      free(c);
a1558 2
   _mesa_meta_init(mesaCtx);

d1567 1
a1567 1
   struct gl_context *mesaCtx = &c->mesa;
a1572 2
   _mesa_meta_free( mesaCtx );

d1578 1
a1578 1
   free( c );
d1593 1
d1595 1
d1604 3
d1609 1
d1617 3
d1629 1
d1635 2
a1636 1
   if (!initialize_visual_and_buffer( v, b, (XMesaDrawable) w, cmap )) {
d1666 2
a1667 61
   if (!initialize_visual_and_buffer(v, b, (XMesaDrawable) p, cmap)) {
      xmesa_free_buffer(b);
      return NULL;
   }

   return b;
}


/**
 * For GLX_EXT_texture_from_pixmap
 */
XMesaBuffer
XMesaCreatePixmapTextureBuffer(XMesaVisual v, XMesaPixmap p,
                               XMesaColormap cmap,
                               int format, int target, int mipmap)
{
   GET_CURRENT_CONTEXT(ctx);
   XMesaBuffer b;
   GLuint width, height;

   assert(v);

   b = create_xmesa_buffer((XMesaDrawable) p, PIXMAP, v, cmap);
   if (!b)
      return NULL;

   /* get pixmap size, update framebuffer/renderbuffer dims */
   xmesa_get_window_size(v->display, b, &width, &height);
   _mesa_resize_framebuffer(NULL, &(b->mesa_buffer), width, height);

   if (target == 0) {
      /* examine dims */
      if (ctx->Extensions.ARB_texture_non_power_of_two) {
         target = GLX_TEXTURE_2D_EXT;
      }
      else if (   _mesa_bitcount(width)  == 1
               && _mesa_bitcount(height) == 1) {
         /* power of two size */
         if (height == 1) {
            target = GLX_TEXTURE_1D_EXT;
         }
         else {
            target = GLX_TEXTURE_2D_EXT;
         }
      }
      else if (ctx->Extensions.NV_texture_rectangle) {
         target = GLX_TEXTURE_RECTANGLE_EXT;
      }
      else {
         /* non power of two textures not supported */
         XMesaDestroyBuffer(b);
         return 0;
      }
   }

   b->TextureTarget = target;
   b->TextureFormat = format;
   b->TextureMipmap = mipmap;

   if (!initialize_visual_and_buffer(v, b, (XMesaDrawable) p, cmap)) {
d1681 1
d1697 2
a1698 1
   if (!initialize_visual_and_buffer(v, b, drawable, cmap)) {
d1704 3
d1722 1
a1722 1
 * Query the current window size and update the corresponding struct gl_framebuffer
d1738 1
a1738 1
      struct gl_context *ctx = xmctx ? &xmctx->mesa : NULL;
d1793 13
a1805 11
      /*
       * Must recompute and set these pixel values because colormap
       * can be different for different windows.
       */
      c->clearpixel = xmesa_color_to_pixel( &c->mesa,
					    c->clearcolor[0],
					    c->clearcolor[1],
					    c->clearcolor[2],
					    c->clearcolor[3],
					    c->xm_visual->undithered_pf);
      XMesaSetForeground(c->display, drawBuffer->cleargc, c->clearpixel);
d1867 34
d1940 1
a1940 1
#if defined(USE_XSHM) 
d1977 1
d1979 1
d2010 1
a2010 1
#if defined(USE_XSHM) 
d2052 1
d2070 1
d2107 3
d2111 1
d2170 3
d2178 1
d2188 1
a2188 1
   struct gl_context *ctx = &xmesa->mesa;
a2254 148
}


static GLint
xbuffer_to_renderbuffer(int buffer)
{
   assert(MAX_AUX_BUFFERS <= 4);

   switch (buffer) {
   case GLX_FRONT_LEFT_EXT:
      return BUFFER_FRONT_LEFT;
   case GLX_FRONT_RIGHT_EXT:
      return BUFFER_FRONT_RIGHT;
   case GLX_BACK_LEFT_EXT:
      return BUFFER_BACK_LEFT;
   case GLX_BACK_RIGHT_EXT:
      return BUFFER_BACK_RIGHT;
   case GLX_AUX0_EXT:
      return BUFFER_AUX0;
   case GLX_AUX1_EXT:
   case GLX_AUX2_EXT:
   case GLX_AUX3_EXT:
   case GLX_AUX4_EXT:
   case GLX_AUX5_EXT:
   case GLX_AUX6_EXT:
   case GLX_AUX7_EXT:
   case GLX_AUX8_EXT:
   case GLX_AUX9_EXT:
   default:
      /* BadValue error */
      return -1;
   }
}


PUBLIC void
XMesaBindTexImage(XMesaDisplay *dpy, XMesaBuffer drawable, int buffer,
                  const int *attrib_list)
{
#if 0
   GET_CURRENT_CONTEXT(ctx);
   const GLuint unit = ctx->Texture.CurrentUnit;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *texObj;
#endif
   struct gl_renderbuffer *rb;
   struct xmesa_renderbuffer *xrb;
   GLint b;
   XMesaImage *img = NULL;
   GLboolean freeImg = GL_FALSE;

   b = xbuffer_to_renderbuffer(buffer);
   if (b < 0)
      return;

   if (drawable->TextureFormat == GLX_TEXTURE_FORMAT_NONE_EXT)
      return; /* BadMatch error */

   rb = drawable->mesa_buffer.Attachment[b].Renderbuffer;
   if (!rb) {
      /* invalid buffer */
      return;
   }
   xrb = xmesa_renderbuffer(rb);

#if 0
   switch (drawable->TextureTarget) {
   case GLX_TEXTURE_1D_EXT:
      texObj = texUnit->CurrentTex[TEXTURE_1D_INDEX];
      break;
   case GLX_TEXTURE_2D_EXT:
      texObj = texUnit->CurrentTex[TEXTURE_2D_INDEX];
      break;
   case GLX_TEXTURE_RECTANGLE_EXT:
      texObj = texUnit->CurrentTex[TEXTURE_RECT_INDEX];
      break;
   default:
      return; /* BadMatch error */
   }
#endif

   /*
    * The following is a quick and simple way to implement
    * BindTexImage.  The better way is to write some new FetchTexel()
    * functions which would extract texels from XImages.  We'd still
    * need to use GetImage when texturing from a Pixmap (front buffer)
    * but texturing from a back buffer (XImage) would avoid an image
    * copy.
    */

   /* get XImage */
   if (xrb->pixmap) {
      img = XMesaGetImage(dpy, xrb->pixmap, 0, 0, rb->Width, rb->Height, ~0L,
			  ZPixmap);
      freeImg = GL_TRUE;
   }
   else if (xrb->ximage) {
      img = xrb->ximage;
   }

   /* store the XImage as a new texture image */
   if (img) {
      GLenum format, type, intFormat;
      if (img->bits_per_pixel == 32) {
         format = GL_BGRA;
         type = GL_UNSIGNED_BYTE;
         intFormat = GL_RGBA;
      }
      else if (img->bits_per_pixel == 24) {
         format = GL_BGR;
         type = GL_UNSIGNED_BYTE;
         intFormat = GL_RGB;
      }
      else if (img->bits_per_pixel == 16) {
         format = GL_BGR;
         type = GL_UNSIGNED_SHORT_5_6_5;
         intFormat = GL_RGB;
      }
      else {
         _mesa_problem(NULL, "Unexpected XImage format in XMesaBindTexImage");
         return;
      }
      if (drawable->TextureFormat == GLX_TEXTURE_FORMAT_RGBA_EXT) {
         intFormat = GL_RGBA;
      }
      else if (drawable->TextureFormat == GLX_TEXTURE_FORMAT_RGB_EXT) {
         intFormat = GL_RGB;
      }

      _mesa_TexImage2D(GL_TEXTURE_2D, 0, intFormat, rb->Width, rb->Height, 0,
                       format, type, img->data);

      if (freeImg) {
	 XMesaDestroyImage(img);
      }
   }
}



PUBLIC void
XMesaReleaseTexImage(XMesaDisplay *dpy, XMesaBuffer drawable, int buffer)
{
   const GLint b = xbuffer_to_renderbuffer(buffer);
   if (b < 0)
      return;

   /* no-op for now */
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a66 1
#include "main/api_exec.h"
a73 2
#include "main/version.h"
#include "main/vtxfmt.h"
a75 1
#include "swrast/s_renderbuffer.h"
d91 62
d178 2
a179 1
   int ignore;
d182 6
a187 7
      /* Note: we're no longer calling XShmQueryVersion() here.  It seems
       * to be flakey (triggers a spurious X protocol error when we close
       * one display connection and start using a new one.  XShm has been
       * around a long time and hasn't changed so if MIT_SHM is supported
       * we assume we're good to go.
       */
      return 2;
d235 1
a235 1
		       malloc(8),    /*data*/
d364 1
a364 1
   b->frontxrb = xmesa_new_renderbuffer(NULL, 0, vis, GL_FALSE);
d373 1
a373 1
                          &b->frontxrb->Base.Base);
d379 1
a379 1
      b->backxrb = xmesa_new_renderbuffer(NULL, 0, vis, GL_TRUE);
d390 16
a405 1
                             &b->backxrb->Base.Base);
d411 7
a417 7
   _swrast_add_soft_renderbuffers(&b->mesa_buffer,
                                  GL_FALSE,  /* color */
                                  vis->mesa_visual.haveDepthBuffer,
                                  vis->mesa_visual.haveStencilBuffer,
                                  vis->mesa_visual.haveAccumBuffer,
                                  GL_FALSE,  /* software alpha buffer */
                                  vis->mesa_visual.numAuxBuffers > 0 );
d488 15
d511 319
d954 7
d964 15
d994 1
d1010 14
d1050 2
d1083 30
d1130 2
d1148 17
d1282 1
a1282 1
   v->visinfo = (XVisualInfo *) malloc(sizeof(*visinfo));
d1345 9
a1353 12
   if (!_mesa_initialize_visual(&v->mesa_visual,
                                db_flag, stereo_flag,
                                red_bits, green_bits,
                                blue_bits, alpha_bits,
                                depth_size,
                                stencil_size,
                                accum_red_size, accum_green_size,
                                accum_blue_size, accum_alpha_size,
                                0)) {
      FREE(v);
      return NULL;
   }
d1401 1
a1401 1
   if (!_mesa_initialize_context(mesaCtx, API_OPENGL_COMPAT, &v->mesa_visual,
d1403 1
a1403 1
                      &functions)) {
d1417 12
a1428 1

d1430 1
a1430 1
    mesaCtx->Extensions.EXT_timer_query = GL_TRUE;
a1460 6
   _mesa_compute_version(mesaCtx);

    /* Exec table initialization requires the version to be computed */
   _mesa_initialize_dispatch_tables(mesaCtx);
   _mesa_initialize_vbo_vtxfmt(mesaCtx);

d1471 4
d1688 1
d1722 5
d1813 2
d1820 1
d1845 4
d1884 3
d1913 4
d1993 1
a1993 3
   struct xmesa_renderbuffer *xrb = xmesa_renderbuffer(rb);

   if (!xrb || !xrb->Base.Buffer) {
d2005 1
a2005 1
      *buffer = (void *) xrb->Base.Buffer;
d2067 1
a2067 1
void XMesaGarbageCollect( XMesaDisplay* dpy )
d2072 1
a2072 1
      if (b->display && b->display == dpy && b->frontxrb->drawable && b->type == WINDOW) {
d2087 1
d2094 2
d2110 17
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d77 1
d91 1
a91 1
mtx_t _xmesa_lock;
d251 1
a251 1
   mtx_lock(&_xmesa_lock);
d254 1
a254 1
   mtx_unlock(&_xmesa_lock);
d859 1
a859 1
      free(v);
d895 1
a895 1
      mtx_init(&_xmesa_lock, mtx_plain);
a931 1
   c->direct = GL_TRUE;
d1339 1
a1339 1
            /*mtx_lock(&_xmesa_lock);*/
d1345 1
a1345 1
            /*mtx_unlock(&_xmesa_lock);*/
d1350 1
a1350 1
            /*mtx_lock(&_xmesa_lock);*/
d1355 1
a1355 1
            /*mtx_unlock(&_xmesa_lock);*/
d1360 1
a1360 1
         /*mtx_lock(&_xmesa_lock);*/
d1368 1
a1368 1
         /*mtx_unlock(&_xmesa_lock);*/
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@d585 1
a585 1
   if (getenv("MESA_NO_DITHER")) {
d595 1
a595 1
   if (getenv("MESA_INFO")) {
d763 1
a763 1
   if (getenv("MESA_XSYNC")) {
d794 1
a794 1
   gamma = getenv("MESA_GAMMA");
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d585 1
a585 1
   if (_mesa_getenv("MESA_NO_DITHER")) {
d595 1
a595 1
   if (_mesa_getenv("MESA_INFO")) {
d763 1
a763 1
   if (_mesa_getenv("MESA_XSYNC")) {
d794 1
a794 1
   gamma = _mesa_getenv("MESA_GAMMA");
@


