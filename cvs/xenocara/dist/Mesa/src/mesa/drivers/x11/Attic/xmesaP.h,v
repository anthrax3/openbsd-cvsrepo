head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2015.02.20.23.09.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	4ry2gvZGMXkCUD2n;

1.8
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.7;
commitid	mcxB0JvoI9gTDYXU;

1.7
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.14.06.12;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.28;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.03;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.01;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.30.31;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.45;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.14;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.57;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.12.21;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.49.28;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#ifndef XMESAP_H
#define XMESAP_H


#include "c11/threads.h"
#include "xmesa.h"
#include "main/mtypes.h"
#include "swrast/s_context.h"


extern mtx_t _xmesa_lock;

extern XMesaBuffer XMesaBufferList;

/* for PF_8R8G8B24 pixel format */
typedef struct {
   GLubyte b;
   GLubyte g;
   GLubyte r;
} bgr_t;


struct xmesa_renderbuffer;


/* Function pointer for clearing color buffers */
typedef void (*ClearFunc)( struct gl_context *ctx, struct xmesa_renderbuffer *xrb,
                           GLint x, GLint y, GLint width, GLint height );




/** Framebuffer pixel formats */
enum pixel_format {
   PF_Truecolor,	/**< TrueColor or DirectColor, any depth */
   PF_Dither_True,	/**< TrueColor with dithering */
   PF_8A8R8G8B,		/**< 32-bit TrueColor:  8-A, 8-R, 8-G, 8-B bits */
   PF_8A8B8G8R,		/**< 32-bit TrueColor:  8-A, 8-B, 8-G, 8-R bits */
   PF_8R8G8B,		/**< 32-bit TrueColor:  8-R, 8-G, 8-B bits */
   PF_8R8G8B24,		/**< 24-bit TrueColor:  8-R, 8-G, 8-B bits */
   PF_5R6G5B,		/**< 16-bit TrueColor:  5-R, 6-G, 5-B bits */
   PF_Dither_5R6G5B	/**< 16-bit dithered TrueColor: 5-R, 6-G, 5-B */
};


/**
 * Visual inforation, derived from struct gl_config.
 * Basically corresponds to an XVisualInfo.
 */
struct xmesa_visual {
   struct gl_config mesa_visual;	/* Device independent visual parameters */
   XMesaDisplay *display;	/* The X11 display */
   int screen, visualID;
   int visualType;
   XMesaVisualInfo visinfo;	/* X's visual info (pointer to private copy) */
   XVisualInfo *vishandle;	/* Only used in fakeglx.c */
   GLint BitsPerPixel;		/* True bits per pixel for XImages */

   GLboolean ximage_flag;	/* Use XImage for back buffer (not pixmap)? */

   enum pixel_format dithered_pf;  /* Pixel format when dithering */
   enum pixel_format undithered_pf;/* Pixel format when not dithering */

   GLfloat RedGamma;		/* Gamma values, 1.0 is default */
   GLfloat GreenGamma;
   GLfloat BlueGamma;

   /* For PF_TRUECOLOR */
   GLint rshift, gshift, bshift;/* Pixel color component shifts */
   GLubyte Kernel[16];		/* Dither kernel */
   unsigned long RtoPixel[512];	/* RGB to pixel conversion */
   unsigned long GtoPixel[512];
   unsigned long BtoPixel[512];
   GLubyte PixelToR[256];	/* Pixel to RGB conversion */
   GLubyte PixelToG[256];
   GLubyte PixelToB[256];
};


/**
 * Context info, derived from struct gl_context.
 * Basically corresponds to a GLXContext.
 */
struct xmesa_context {
   struct gl_context mesa;		/* the core library context (containment) */
   XMesaVisual xm_visual;	/* Describes the buffers */
   XMesaBuffer xm_buffer;	/* current span/point/line/triangle buffer */

   XMesaDisplay *display;	/* == xm_visual->display */
   GLboolean swapbytes;		/* Host byte order != display byte order? */
   GLboolean direct;		/* Direct rendering context? */

   enum pixel_format pixelformat;

   GLubyte clearcolor[4];		/* current clearing color */
   unsigned long clearpixel;		/* current clearing pixel value */
};


/**
 * Types of X/GLX drawables we might render into.
 */
typedef enum {
   WINDOW,          /* An X window */
   GLXWINDOW,       /* GLX window */
   PIXMAP,          /* GLX pixmap */
   PBUFFER          /* GLX Pbuffer */
} BufferType;


/** Values for db_mode: */
/*@@{*/
#define BACK_PIXMAP	1
#define BACK_XIMAGE	2
/*@@}*/


/**
 * An xmesa_renderbuffer represents the back or front color buffer.
 * For the front color buffer:
 *    <drawable> is the X window
 * For the back color buffer:
 *    Either <ximage> or <pixmap> will be used, never both.
 * In any case, <drawable> always equals <pixmap>.
 * For stand-alone Mesa, we could merge <drawable> and <pixmap> into one
 * field.  We don't do that for the server-side GLcore module because
 * pixmaps and drawables are different and we'd need a bunch of casts.
 */
struct xmesa_renderbuffer
{
   struct swrast_renderbuffer Base;  /* Base class */

   XMesaBuffer Parent;  /**< The XMesaBuffer this renderbuffer belongs to */
   XMesaDrawable drawable;	/* Usually the X window ID */
   XMesaPixmap pixmap;	/* Back color buffer */
   XMesaImage *ximage;	/* The back buffer, if not using a Pixmap */

   GLushort *origin2;	/* used for PIXEL_ADDR2 macro */
   GLint width2;
   GLubyte *origin3;	/* used for PIXEL_ADDR3 macro */
   GLint width3;
   GLuint *origin4;	/* used for PIXEL_ADDR4 macro */
   GLint width4;

   GLint bottom;	/* used for FLIP macro, equals height - 1 */

   ClearFunc clearFunc;

   GLuint map_x, map_y, map_w, map_h;
   GLbitfield map_mode;
   XMesaImage *map_ximage;
};


/**
 * Framebuffer information, derived from.
 * Basically corresponds to a GLXDrawable.
 */
struct xmesa_buffer {
   struct gl_framebuffer mesa_buffer;	/* depth, stencil, accum, etc buffers */
				/* This MUST BE FIRST! */
   GLboolean wasCurrent;	/* was ever the current buffer? */
   XMesaVisual xm_visual;	/* the X/Mesa visual */

   XMesaDisplay *display;
   BufferType type;             /* window, pixmap, pbuffer or glxwindow */

   GLboolean largestPbuffer;    /**< for pbuffers */
   GLboolean preservedContents; /**< for pbuffers */

   struct xmesa_renderbuffer *frontxrb; /* front color renderbuffer */
   struct xmesa_renderbuffer *backxrb;  /* back color renderbuffer */

   XMesaColormap cmap;		/* the X colormap */

   unsigned long selectedEvents;/* for pbuffers only */

   GLint db_mode;		/* 0 = single buffered */
				/* BACK_PIXMAP = use Pixmap for back buffer */
				/* BACK_XIMAGE = use XImage for back buffer */
   GLuint shm;			/* X Shared Memory extension status:	*/
				/*    0 = not available			*/
				/*    1 = XImage support available	*/
				/*    2 = Pixmap support available too	*/
#if defined(USE_XSHM) 
   XShmSegmentInfo shminfo;
#endif

   //   XMesaImage *rowimage;	/* Used for optimized span writing */
   XMesaPixmap stipple_pixmap;	/* For polygon stippling */
   XMesaGC stipple_gc;		/* For polygon stippling */

   XMesaGC gc;			/* scratch GC for span, line, tri drawing */
   XMesaGC cleargc;		/* GC for clearing the color buffer */
   XMesaGC swapgc;		/* GC for swapping the color buffers */

   /* The following are here instead of in the XMesaVisual
    * because they depend on the window's colormap.
    */

   /* For PF_DITHER, PF_LOOKUP, PF_GRAYSCALE */
   unsigned long color_table[576];	/* RGB -> pixel value */

   /* For PF_DITHER, PF_LOOKUP, PF_GRAYSCALE */
   GLubyte pixel_to_r[65536];		/* pixel value -> red */
   GLubyte pixel_to_g[65536];		/* pixel value -> green */
   GLubyte pixel_to_b[65536];		/* pixel value -> blue */

   /* Used to do XAllocColor/XFreeColors accounting: */
   int num_alloced;
   unsigned long alloced_colors[256];

   /* GLX_EXT_texture_from_pixmap */
   GLint TextureTarget; /** GLX_TEXTURE_1D_EXT, for example */
   GLint TextureFormat; /** GLX_TEXTURE_FORMAT_RGB_EXT, for example */
   GLint TextureMipmap; /** 0 or 1 */

   struct xmesa_buffer *Next;	/* Linked list pointer: */
};


/**
 * If pixelformat==PF_TRUECOLOR:
 */
#define PACK_TRUECOLOR( PIXEL, R, G, B )	\
   PIXEL = xmesa->xm_visual->RtoPixel[R]	\
         | xmesa->xm_visual->GtoPixel[G]	\
         | xmesa->xm_visual->BtoPixel[B];	\


/**
 * If pixelformat==PF_TRUEDITHER:
 */
#define PACK_TRUEDITHER( PIXEL, X, Y, R, G, B )			\
{								\
   int d = xmesa->xm_visual->Kernel[((X)&3) | (((Y)&3)<<2)];	\
   PIXEL = xmesa->xm_visual->RtoPixel[(R)+d]			\
         | xmesa->xm_visual->GtoPixel[(G)+d]			\
         | xmesa->xm_visual->BtoPixel[(B)+d];			\
}



/**
 * If pixelformat==PF_8A8B8G8R:
 */
#define PACK_8A8B8G8R( R, G, B, A )	\
	( ((A) << 24) | ((B) << 16) | ((G) << 8) | (R) )


/**
 * Like PACK_8A8B8G8R() but don't use alpha.  This is usually an acceptable
 * shortcut.
 */
#define PACK_8B8G8R( R, G, B )   ( ((B) << 16) | ((G) << 8) | (R) )



/**
 * If pixelformat==PF_8R8G8B:
 */
#define PACK_8R8G8B( R, G, B)	 ( ((R) << 16) | ((G) << 8) | (B) )


/**
 * If pixelformat==PF_5R6G5B:
 */
#define PACK_5R6G5B( R, G, B)	 ( (((R) & 0xf8) << 8) | (((G) & 0xfc) << 3) | ((B) >> 3) )


/**
 * If pixelformat==PF_8A8R8G8B:
 */
#define PACK_8A8R8G8B( R, G, B, A )	\
	( ((A) << 24) | ((R) << 16) | ((G) << 8) | (B) )




/**
 * Converts a GL window Y coord to an X window Y coord:
 */
#define YFLIP(XRB, Y)  ((XRB)->bottom - (Y))


/**
 * Return the address of a 2, 3 or 4-byte pixel in the buffer's XImage:
 * X==0 is left, Y==0 is bottom.
 */
#define PIXEL_ADDR2(XRB, X, Y)  \
   ( (XRB)->origin2 - (Y) * (XRB)->width2 + (X) )

#define PIXEL_ADDR3(XRB, X, Y)  \
   ( (bgr_t *) ( (XRB)->origin3 - (Y) * (XRB)->width3 + 3 * (X) ))

#define PIXEL_ADDR4(XRB, X, Y)  \
   ( (XRB)->origin4 - (Y) * (XRB)->width4 + (X) )



/*
 * External functions:
 */

extern struct xmesa_renderbuffer *
xmesa_new_renderbuffer(struct gl_context *ctx, GLuint name,
                       const struct xmesa_visual *xmvis,
                       GLboolean backBuffer);

extern void
xmesa_delete_framebuffer(struct gl_framebuffer *fb);

extern XMesaBuffer
xmesa_find_buffer(XMesaDisplay *dpy, XMesaColormap cmap, XMesaBuffer notThis);

extern unsigned long
xmesa_color_to_pixel( struct gl_context *ctx,
                      GLubyte r, GLubyte g, GLubyte b, GLubyte a,
                      GLuint pixelFormat );

extern void
xmesa_get_window_size(XMesaDisplay *dpy, XMesaBuffer b,
                      GLuint *width, GLuint *height);

extern void
xmesa_check_and_update_buffer_size(XMesaContext xmctx, XMesaBuffer drawBuffer);

extern void
xmesa_init_driver_functions( XMesaVisual xmvisual,
                             struct dd_function_table *driver );

extern void
xmesa_update_state( struct gl_context *ctx, GLbitfield new_state );


extern void
xmesa_MapRenderbuffer(struct gl_context *ctx,
                      struct gl_renderbuffer *rb,
                      GLuint x, GLuint y, GLuint w, GLuint h,
                      GLbitfield mode,
                      GLubyte **mapOut, GLint *rowStrideOut);

extern void
xmesa_UnmapRenderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb);

extern void
xmesa_destroy_buffers_on_display(XMesaDisplay *dpy);


/**
 * Using a function instead of an ordinary cast is safer.
 */
static INLINE struct xmesa_renderbuffer *
xmesa_renderbuffer(struct gl_renderbuffer *rb)
{
   return (struct xmesa_renderbuffer *) rb;
}


/**
 * Return pointer to XMesaContext corresponding to a Mesa struct gl_context.
 * Since we're using structure containment, it's just a cast!.
 */
static INLINE XMesaContext
XMESA_CONTEXT(struct gl_context *ctx)
{
   return (XMesaContext) ctx;
}


/**
 * Return pointer to XMesaBuffer corresponding to a Mesa struct gl_framebuffer.
 * Since we're using structure containment, it's just a cast!.
 */
static INLINE XMesaBuffer
XMESA_BUFFER(struct gl_framebuffer *b)
{
   return (XMesaBuffer) b;
}


/* Plugged into the software rasterizer.  Try to use internal
 * swrast-style point, line and triangle functions.
 */
extern void xmesa_choose_point( struct gl_context *ctx );
extern void xmesa_choose_line( struct gl_context *ctx );
extern void xmesa_choose_triangle( struct gl_context *ctx );


extern void xmesa_register_swrast_functions( struct gl_context *ctx );



#if   defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
#define ENABLE_EXT_timer_query 1 /* should have 64-bit GLuint64EXT */
#else
#define ENABLE_EXT_timer_query 0 /* may not have 64-bit GLuint64EXT */
#endif


#define TEST_META_FUNCS 0


#endif
@


1.9
log
@Merge Mesa 10.2.9
@
text
@@


1.8
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d378 1
a378 1
static inline struct xmesa_renderbuffer *
d389 1
a389 1
static inline XMesaContext
d400 1
a400 1
static inline XMesaBuffer
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d378 1
a378 1
static INLINE struct xmesa_renderbuffer *
d389 1
a389 1
static INLINE XMesaContext
d400 1
a400 1
static INLINE XMesaBuffer
@


1.6
log
@Merge Mesa 9.2.0
@
text
@d30 1
d36 1
a36 1
extern _glthread_Mutex _xmesa_lock;
@


1.5
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d32 1
a32 4
#if defined(FX)
#include "fxmesa.h"
#include "xm_glide.h"
#endif
a58 1
   PF_Index,		/**< Color Index mode */
a65 5
   PF_Dither,		/**< Color-mapped RGB with dither */
   PF_Lookup,		/**< Color-mapped RGB without dither */
   PF_HPCR,		/**< HP Color Recovery (ad@@lms.be 30/08/95) */
   PF_1Bit,		/**< monochrome dithering of RGB */
   PF_Grayscale,	/**< Grayscale or StaticGray */
a100 10

   /* For PF_HPCR */
   short       hpcr_rgbTbl[3][256];
   GLboolean   hpcr_clear_flag;
   GLubyte     hpcr_clear_ximage_pattern[2][16];
   XMesaImage *hpcr_clear_ximage;
   XMesaPixmap hpcr_clear_pixmap;

   /* For PF_1BIT */
   int bitFlip;
d155 1
a155 1
   struct gl_renderbuffer Base;  /* Base class */
a161 2
   GLubyte *origin1;	/* used for PIXEL_ADDR1 macro */
   GLint width1;
d172 4
a204 2
   GLboolean swAlpha;

d213 1
a213 1
   XMesaImage *rowimage;	/* Used for optimized span writing */
a236 7
#if defined( FX )
   /* For 3Dfx Glide only */
   GLboolean FXisHackUsable;	/* Can we render into window? */
   GLboolean FXwindowHack;	/* Are we rendering into a window? */
   fxMesaContext FXctx;
#endif

a302 128
/**
 * If pixelformat==PF_DITHER:
 *
 * Improved 8-bit RGB dithering code contributed by Bob Mercier
 * (mercier@@hollywood.cinenet.net).  Thanks Bob!
 */
#ifdef DITHER666
# define DITH_R   6
# define DITH_G   6
# define DITH_B   6
# define DITH_MIX(r,g,b)  (((r) * DITH_G + (g)) * DITH_B + (b))
#else
# define DITH_R	5
# define DITH_G	9
# define DITH_B	5
# define DITH_MIX(r,g,b)  (((g) << 6) | ((b) << 3) | (r))
#endif
#define DITH_DX	4
#define DITH_DY	4
#define DITH_N	(DITH_DX * DITH_DY)

#define _dither(C, c, d)   (((unsigned)((DITH_N * (C - 1) + 1) * c + d)) >> 12)

#define MAXC	256
extern const int xmesa_kernel8[DITH_DY * DITH_DX];

/* Dither for random X,Y */
#define DITHER_SETUP						\
	int __d;						\
	unsigned long *ctable = XMESA_BUFFER(ctx->DrawBuffer)->color_table;

#define DITHER( X, Y, R, G, B )				\
	(__d = xmesa_kernel8[(((Y)&3)<<2) | ((X)&3)],	\
	 ctable[DITH_MIX(_dither(DITH_R, (R), __d),	\
		         _dither(DITH_G, (G), __d),	\
		         _dither(DITH_B, (B), __d))])

/* Dither for random X, fixed Y */
#define XDITHER_SETUP(Y)					\
	int __d;						\
	unsigned long *ctable = XMESA_BUFFER(ctx->DrawBuffer)->color_table;	\
	const int *kernel = &xmesa_kernel8[ ((Y)&3) << 2 ];

#define XDITHER( X, R, G, B )				\
	(__d = kernel[(X)&3],				\
	ctable[DITH_MIX(_dither(DITH_R, (R), __d),	\
		        _dither(DITH_G, (G), __d),	\
		        _dither(DITH_B, (B), __d))])



/*
 * Dithering for flat-shaded triangles.  Precompute all 16 possible
 * pixel values given the triangle's RGB color.  Contributed by Martin Shenk.
 */
#define FLAT_DITHER_SETUP( R, G, B )					\
	GLushort ditherValues[16];					\
	{								\
	   unsigned long *ctable = XMESA_BUFFER(ctx->DrawBuffer)->color_table;	\
	   int msdr = (DITH_N*((DITH_R)-1)+1) * (R);			\
	   int msdg = (DITH_N*((DITH_G)-1)+1) * (G);			\
	   int msdb = (DITH_N*((DITH_B)-1)+1) * (B);			\
	   int i;							\
	   for (i=0;i<16;i++) {						\
	      int k = xmesa_kernel8[i];					\
	      int j = DITH_MIX( (msdr+k)>>12, (msdg+k)>>12, (msdb+k)>>12 );\
	      ditherValues[i] = (GLushort) ctable[j];			\
	   }								\
        }

#define FLAT_DITHER_ROW_SETUP(Y)					\
	GLushort *ditherRow = ditherValues + ( ((Y)&3) << 2);

#define FLAT_DITHER(X)  ditherRow[(X)&3]



/**
 * If pixelformat==PF_LOOKUP:
 */
#define _dither_lookup(C, c)   (((unsigned)((DITH_N * (C - 1) + 1) * c)) >> 12)

#define LOOKUP_SETUP						\
	unsigned long *ctable = XMESA_BUFFER(ctx->DrawBuffer)->color_table

#define LOOKUP( R, G, B )				\
	ctable[DITH_MIX(_dither_lookup(DITH_R, (R)),	\
		        _dither_lookup(DITH_G, (G)),	\
		        _dither_lookup(DITH_B, (B)))]


/**
 * If pixelformat==PF_HPCR:
 *
 *      HP Color Recovery dithering               (ad@@lms.be 30/08/95)
 *      HP has on its 8-bit 700-series computers, a feature called
 *      'Color Recovery'.  This allows near 24-bit output (so they say).
 *      It is enabled by selecting the 8-bit  TrueColor  visual AND
 *      corresponding  colormap (see tkInitWindow) AND doing some special
 *      dither.
 */
extern const short xmesa_HPCR_DRGB[3][2][16];

#define DITHER_HPCR( X, Y, R, G, B )					   \
  ( ((xmesa->xm_visual->hpcr_rgbTbl[0][R] + xmesa_HPCR_DRGB[0][(Y)&1][(X)&15]) & 0xE0)     \
  |(((xmesa->xm_visual->hpcr_rgbTbl[1][G] + xmesa_HPCR_DRGB[1][(Y)&1][(X)&15]) & 0xE0)>>3) \
  | ((xmesa->xm_visual->hpcr_rgbTbl[2][B] + xmesa_HPCR_DRGB[2][(Y)&1][(X)&15])>>6)	   \
  )



/**
 * If pixelformat==PF_1BIT:
 */
extern const int xmesa_kernel1[16];

#define SETUP_1BIT  int bitFlip = xmesa->xm_visual->bitFlip
#define DITHER_1BIT( X, Y, R, G, B )	\
	(( ((int)(R)+(int)(G)+(int)(B)) > xmesa_kernel1[(((Y)&3) << 2) | ((X)&3)] ) ^ bitFlip)



/**
 * If pixelformat==PF_GRAYSCALE:
 */
#define GRAY_RGB( R, G, B )   XMESA_BUFFER(ctx->DrawBuffer)->color_table[((R) + (G) + (B))/3]


d311 1
a311 1
 * Return the address of a 1, 2 or 4-byte pixel in the buffer's XImage:
a313 3
#define PIXEL_ADDR1(XRB, X, Y)  \
   ( (XRB)->origin1 - (Y) * (XRB)->width1 + (X) )

d330 2
a331 1
xmesa_new_renderbuffer(struct gl_context *ctx, GLuint name, const struct gl_config *visual,
d359 1
d361 8
a368 2
xmesa_set_renderbuffer_funcs(struct xmesa_renderbuffer *xrb,
                             enum pixel_format pixelformat, GLint depth);
a416 2

#define ENABLE_EXT_texure_compression_s3tc 0 /* SW texture compression */
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a35 3
#ifdef XFree86Server
#include "xm_image.h"
#endif
d54 1
a54 1
typedef void (*ClearFunc)( GLcontext *ctx, struct xmesa_renderbuffer *xrb,
d80 1
a80 1
 * Visual inforation, derived from GLvisual.
d84 1
a84 1
   GLvisual mesa_visual;	/* Device independent visual parameters */
d86 2
a87 4
#ifdef XFree86Server
   GLint ColormapEntries;
   GLint nplanes;
#else
a89 1
#endif
d124 1
a124 1
 * Context info, derived from GLcontext.
d128 1
a128 1
   GLcontext mesa;		/* the core library context (containment) */
d201 1
a201 1
   GLframebuffer mesa_buffer;	/* depth, stencil, accum, etc buffers */
d228 1
a228 1
#if defined(USE_XSHM) && !defined(XFree86Server)
a253 3
#if defined(XFree86Server)
   Pixel alloced_colors[256];
#else
a254 1
#endif
d487 1
a487 1
xmesa_new_renderbuffer(GLcontext *ctx, GLuint name, const GLvisual *visual,
d497 1
a497 1
xmesa_color_to_pixel( GLcontext *ctx,
d513 1
a513 1
xmesa_update_state( GLcontext *ctx, GLbitfield new_state );
d534 1
a534 1
 * Return pointer to XMesaContext corresponding to a Mesa GLcontext.
d538 1
a538 1
XMESA_CONTEXT(GLcontext *ctx)
d545 1
a545 1
 * Return pointer to XMesaBuffer corresponding to a Mesa GLframebuffer.
d549 1
a549 1
XMESA_BUFFER(GLframebuffer *b)
d558 3
a560 3
extern void xmesa_choose_point( GLcontext *ctx );
extern void xmesa_choose_line( GLcontext *ctx );
extern void xmesa_choose_triangle( GLcontext *ctx );
d563 1
a563 1
extern void xmesa_register_swrast_functions( GLcontext *ctx );
d569 1
a569 3
#ifdef XFree86Server
#define ENABLE_EXT_timer_query 0
#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d215 3
d434 1
a434 1
 *      HP has on it's 8-bit 700-series computers, a feature called
d586 4
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d30 2
a31 2
#include "GL/xmesa.h"
#include "mtypes.h"
d33 1
a33 1
#include "GL/fxmesa.h"
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
a29 5
#ifdef XFree86Server
# include "xf86glx_util.h"
#elif defined(USE_XSHM)
# include <X11/extensions/XShm.h>
#endif
d34 4
a37 1
#include "../glide/fxdrv.h"
d43 1
d58 1
a58 2
                            GLboolean all, GLint x, GLint y,
                            GLint width, GLint height );
d68 2
a69 1
   PF_8A8B8G8R,		/**< 32-bit TrueColor:  8-A, 8-B, 8-G, 8-R */
d71 1
d78 1
a78 3
   PF_8R8G8B24,		/**< 24-bit TrueColor: 8-R, 8-G, 8-B bits */
   PF_Dither_5R6G5B,	/**< 16-bit dithered TrueColor: 5-R, 6-G, 5-B */
   PF_8A8R8G8B		/**< 32-bit TrueColor:  8-A, 8-R, 8-G, 8-B */
d82 3
a84 2
/*
 * "Derived" from GLvisual.  Basically corresponds to an XVisualInfo.
d129 3
a131 2
/*
 * "Derived" from __GLcontextRec.  Basically corresponds to a GLXContext.
d149 3
a151 1

d160 2
a161 1
/* Values for db_mode: */
d164 1
d182 1
d202 3
a204 2
/*
 * "Derived" from GLframebuffer.  Basically corresponds to a GLXDrawable.
d225 1
d270 5
d279 1
a279 1
/*
d288 1
a288 1
/*
d301 1
a301 1
/*
d308 1
a308 1
/*
d316 1
a316 1
/*
d322 1
a322 1
/*
d328 1
a328 1
/*
d336 1
a336 1
/*
d413 1
a413 1
/*
d427 1
a427 2

/*
d447 1
a447 1
/*
d458 1
a458 1
/*
d465 1
a465 1
/*
d471 1
a471 1
/*
a488 17

/*
 * Return pointer to XMesaContext corresponding to a Mesa GLcontext.
 * Since we're using structure containment, it's just a cast!.
 * XXX should use inlined function for better type safety.
 */
#define XMESA_CONTEXT(MESACTX)  ((XMesaContext) (MESACTX))

/*
 * Return pointer to XMesaBuffer corresponding to a Mesa GLframebuffer.
 * Since we're using structure containment, it's just a cast!.
 * XXX should use inlined function for better type safety.
 */
#define XMESA_BUFFER(MESABUFF)  ((XMesaBuffer) (MESABUFF))



d497 6
d509 2
a510 1
xmesa_alloc_back_buffer(XMesaBuffer b, GLuint width, GLuint height);
d512 2
a513 2
extern void xmesa_resize_buffers(GLcontext *ctx, GLframebuffer *buffer,
                                 GLuint width, GLuint height);
d515 3
a517 2
extern void xmesa_init_driver_functions( XMesaVisual xmvisual,
                                         struct dd_function_table *driver );
d519 2
a520 1
extern void xmesa_update_state( GLcontext *ctx, GLbitfield new_state );
d526 2
a527 1
extern void xmesa_destroy_buffers_on_display(XMesaDisplay *dpy);
d540 22
a571 15


/* XXX this is a hack to implement shared display lists with 3Dfx */
extern XMesaBuffer XMesaCreateWindowBuffer2( XMesaVisual v,
					     XMesaWindow w,
					     XMesaContext c );

/*
 * These are the extra routines required for integration with XFree86.
 * None of these routines should be user visible. -KEM
 */
extern void XMesaSetVisualDisplay( XMesaDisplay *dpy, XMesaVisual v );
extern GLboolean XMesaForceCurrent(XMesaContext c);
extern GLboolean XMesaLoseCurrent(XMesaContext c);
extern void XMesaReset( void );
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d59 2
a60 1
                           GLint x, GLint y, GLint width, GLint height );
d84 2
a85 3
/**
 * Visual inforation, derived from GLvisual.
 * Basically corresponds to an XVisualInfo.
d130 2
a131 3
/**
 * Context info, dDerived from GLcontext.
 * Basically corresponds to a GLXContext.
d149 1
a149 3
/**
 * Types of X/GLX drawables we might render into.
 */
d158 1
a158 2
/** Values for db_mode: */
/*@@{*/
a160 1
/*@@}*/
a177 1
   XMesaBuffer Parent;  /**< The XMesaBuffer this renderbuffer belongs to */
d197 2
a198 3
/**
 * Framebuffer information, derived from.
 * Basically corresponds to a GLXDrawable.
d267 1
a267 1
/**
d276 1
a276 1
/**
d289 1
a289 1
/**
d296 1
a296 1
/**
d304 1
a304 1
/**
d310 1
a310 1
/**
d316 1
a316 1
/**
d324 1
a324 1
/**
d401 1
a401 1
/**
d415 2
a416 1
/**
d436 1
a436 1
/**
d447 1
a447 1
/**
d454 1
a454 1
/**
d460 1
a460 1
/**
d478 17
d509 1
a509 2
xmesa_get_window_size(XMesaDisplay *dpy, XMesaBuffer b,
                      GLuint *width, GLuint *height);
d511 2
a512 2
extern void
xmesa_check_and_update_buffer_size(XMesaContext xmctx, XMesaBuffer drawBuffer);
d514 2
a515 3
extern void
xmesa_init_driver_functions( XMesaVisual xmvisual,
                             struct dd_function_table *driver );
d517 1
a517 2
extern void
xmesa_update_state( GLcontext *ctx, GLbitfield new_state );
d523 1
a523 2
extern void
xmesa_destroy_buffers_on_display(XMesaDisplay *dpy);
a532 24
}


/**
 * Return pointer to XMesaContext corresponding to a Mesa GLcontext.
 * Since we're using structure containment, it's just a cast!.
 * XXX should use inlined function for better type safety.
 */
static INLINE XMesaContext
XMESA_CONTEXT(GLcontext *ctx)
{
   return (XMesaContext) ctx;
}


/**
 * Return pointer to XMesaBuffer corresponding to a Mesa GLframebuffer.
 * Since we're using structure containment, it's just a cast!.
 * XXX should use inlined function for better type safety.
 */
static INLINE XMesaBuffer
XMESA_BUFFER(GLframebuffer *b)
{
   return (XMesaBuffer) b;
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d30 5
d39 1
a39 4
#include "xm_glide.h"
#endif
#ifdef XFree86Server
#include "xm_image.h"
a44 1
extern XMesaBuffer XMesaBufferList;
d69 1
a69 2
   PF_8A8R8G8B,		/**< 32-bit TrueColor:  8-A, 8-R, 8-G, 8-B bits */
   PF_8A8B8G8R,		/**< 32-bit TrueColor:  8-A, 8-B, 8-G, 8-R bits */
a70 1
   PF_8R8G8B24,		/**< 24-bit TrueColor:  8-R, 8-G, 8-B bits */
d77 3
a79 1
   PF_Dither_5R6G5B	/**< 16-bit dithered TrueColor: 5-R, 6-G, 5-B */
a225 1
   GLboolean swAlpha;
a491 6
extern void
xmesa_delete_framebuffer(struct gl_framebuffer *fb);

extern XMesaBuffer
xmesa_find_buffer(XMesaDisplay *dpy, XMesaColormap cmap, XMesaBuffer notThis);

d563 15
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d30 2
a31 2
#include "xmesa.h"
#include "main/mtypes.h"
d33 1
a33 1
#include "fxmesa.h"
d36 3
d57 1
a57 1
typedef void (*ClearFunc)( struct gl_context *ctx, struct xmesa_renderbuffer *xrb,
d83 1
a83 1
 * Visual inforation, derived from struct gl_config.
d87 1
a87 1
   struct gl_config mesa_visual;	/* Device independent visual parameters */
d89 4
a92 2
   int screen, visualID;
   int visualType;
d95 1
d130 1
a130 1
 * Context info, derived from struct gl_context.
d134 1
a134 1
   struct gl_context mesa;		/* the core library context (containment) */
d207 1
a207 1
   struct gl_framebuffer mesa_buffer;	/* depth, stencil, accum, etc buffers */
a214 3
   GLboolean largestPbuffer;    /**< for pbuffers */
   GLboolean preservedContents; /**< for pbuffers */

d231 1
a231 1
#if defined(USE_XSHM) 
d257 3
d261 1
a269 5
   /* GLX_EXT_texture_from_pixmap */
   GLint TextureTarget; /** GLX_TEXTURE_1D_EXT, for example */
   GLint TextureFormat; /** GLX_TEXTURE_FORMAT_RGB_EXT, for example */
   GLint TextureMipmap; /** 0 or 1 */

d426 1
a426 1
 *      HP has on its 8-bit 700-series computers, a feature called
d489 1
a489 1
xmesa_new_renderbuffer(struct gl_context *ctx, GLuint name, const struct gl_config *visual,
d499 1
a499 1
xmesa_color_to_pixel( struct gl_context *ctx,
d515 1
a515 1
xmesa_update_state( struct gl_context *ctx, GLbitfield new_state );
d536 1
a536 1
 * Return pointer to XMesaContext corresponding to a Mesa struct gl_context.
d538 1
d541 1
a541 1
XMESA_CONTEXT(struct gl_context *ctx)
d548 1
a548 1
 * Return pointer to XMesaBuffer corresponding to a Mesa struct gl_framebuffer.
d550 1
d553 1
a553 1
XMESA_BUFFER(struct gl_framebuffer *b)
d562 3
a564 3
extern void xmesa_choose_point( struct gl_context *ctx );
extern void xmesa_choose_line( struct gl_context *ctx );
extern void xmesa_choose_triangle( struct gl_context *ctx );
d567 1
a567 1
extern void xmesa_register_swrast_functions( struct gl_context *ctx );
d573 3
a575 1
#if   defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
a579 4


#define TEST_META_FUNCS 0

@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
d32 4
a35 1
#include "swrast/s_context.h"
d62 1
d70 5
d110 10
d174 1
a174 1
   struct swrast_renderbuffer Base;  /* Base class */
d181 2
a192 4

   GLuint map_x, map_y, map_w, map_h;
   GLbitfield map_mode;
   XMesaImage *map_ximage;
d222 2
d232 1
a232 1
   //   XMesaImage *rowimage;	/* Used for optimized span writing */
d256 7
d329 128
d465 1
a465 1
 * Return the address of a 2, 3 or 4-byte pixel in the buffer's XImage:
d468 3
d487 1
a487 2
xmesa_new_renderbuffer(struct gl_context *ctx, GLuint name,
                       const struct xmesa_visual *xmvis,
a514 1

d516 2
a517 8
xmesa_MapRenderbuffer(struct gl_context *ctx,
                      struct gl_renderbuffer *rb,
                      GLuint x, GLuint y, GLuint w, GLuint h,
                      GLbitfield mode,
                      GLubyte **mapOut, GLint *rowStrideOut);

extern void
xmesa_UnmapRenderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb);
d566 2
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@a29 1
#include "c11/threads.h"
d35 1
a35 1
extern mtx_t _xmesa_lock;
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@d378 1
a378 1
static inline struct xmesa_renderbuffer *
d389 1
a389 1
static inline XMesaContext
d400 1
a400 1
static inline XMesaBuffer
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d378 1
a378 1
static INLINE struct xmesa_renderbuffer *
d389 1
a389 1
static INLINE XMesaContext
d400 1
a400 1
static INLINE XMesaBuffer
@


