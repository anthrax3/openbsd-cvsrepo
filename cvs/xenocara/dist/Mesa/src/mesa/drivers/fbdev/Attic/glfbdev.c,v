head	1.8;
access;
symbols
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2013.09.05.14.05.57;	author jsg;	state dead;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.26;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.41;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.19;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.42;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.42;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.55;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.30.06;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.44;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge Mesa 9.2.0
@
text
@/*
 * Mesa 3-D graphics library
 * Version:  7.1
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */


/*
 * OpenGL (Mesa) interface for fbdev.
 * For info about fbdev:
 * http://www.tldp.org/HOWTO/Framebuffer-HOWTO.html
 *
 * known VGA modes
 * Colours   640x400 640x480 800x600 1024x768 1152x864 1280x1024 1600x1200
 * --------+--------------------------------------------------------------
 *  4 bits |    ?       ?     0x302      ?        ?        ?         ?
 *  8 bits |  0x300   0x301   0x303    0x305    0x161    0x307     0x31C
 * 15 bits |    ?     0x310   0x313    0x316    0x162    0x319     0x31D
 * 16 bits |    ?     0x311   0x314    0x317    0x163    0x31A     0x31E
 * 24 bits |    ?     0x312   0x315    0x318      ?      0x31B     0x31F
 * 32 bits |    ?       ?       ?        ?      0x164      ?
 */

#ifdef USE_GLFBDEV_DRIVER

#include "GL/glfbdev.h"
#include <linux/fb.h>
#include "main/glheader.h"
#include "main/buffers.h"
#include "main/context.h"
#include "main/extensions.h"
#include "main/fbobject.h"
#include "main/framebuffer.h"
#include "main/imports.h"
#include "main/renderbuffer.h"
#include "main/texformat.h"
#include "main/teximage.h"
#include "main/texstore.h"
#include "vbo/vbo.h"
#include "swrast/swrast.h"
#include "swrast_setup/swrast_setup.h"
#include "tnl/tnl.h"
#include "tnl/t_context.h"
#include "tnl/t_pipeline.h"
#include "drivers/common/driverfuncs.h"


/**
 * Pixel formats we support:
 */
#define PF_B8G8R8     1
#define PF_B8G8R8A8   2
#define PF_B5G6R5     3
#define PF_B5G5R5     4


/**
 * Derived from Mesa's struct gl_config class.
 */
struct GLFBDevVisualRec {
   struct gl_config glvisual;              /* base class */
   struct fb_fix_screeninfo fix;
   struct fb_var_screeninfo var;
   int pixelFormat;
};

/**
 * Derived from Mesa's struct gl_framebuffer class.
 */
struct GLFBDevBufferRec {
   struct gl_framebuffer glframebuffer;    /* base class */
   GLFBDevVisualPtr visual;
   struct fb_fix_screeninfo fix;
   struct fb_var_screeninfo var;
   size_t size;                    /* color buffer size in bytes */
   GLuint bytesPerPixel;
};

/**
 * Derived from Mesa's struct gl_context class.
 */
struct GLFBDevContextRec {
   struct gl_context glcontext;            /* base class */
   GLFBDevVisualPtr visual;
   GLFBDevBufferPtr drawBuffer;
   GLFBDevBufferPtr readBuffer;
   GLFBDevBufferPtr curBuffer;
};

/**
 * Derived from Mesa's gl_renderbuffer class.
 */
struct GLFBDevRenderbufferRec {
   struct gl_renderbuffer Base;
   GLubyte *bottom;                /* pointer to last row */
   GLuint rowStride;               /* in bytes */
   GLboolean mallocedBuffer;
};


/**********************************************************************/
/* Internal device driver functions                                   */
/**********************************************************************/


static const GLubyte *
get_string(struct gl_context *ctx, GLenum pname)
{
   (void) ctx;
   switch (pname) {
      case GL_RENDERER:
         return (const GLubyte *) "Mesa glfbdev";
      default:
         return NULL;
   }
}


static void
update_state( struct gl_context *ctx, GLuint new_state )
{
   /* not much to do here - pass it on */
   _swrast_InvalidateState( ctx, new_state );
   _swsetup_InvalidateState( ctx, new_state );
   _vbo_InvalidateState( ctx, new_state );
   _tnl_InvalidateState( ctx, new_state );
}


static void
get_buffer_size( struct gl_framebuffer *buffer, GLuint *width, GLuint *height )
{
   const GLFBDevBufferPtr fbdevbuffer = (GLFBDevBufferPtr) buffer;
   *width = fbdevbuffer->var.xres;
   *height = fbdevbuffer->var.yres;
}


/**
 * We only implement this function as a mechanism to check if the
 * framebuffer size has changed (and update corresponding state).
 */
static void
viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
{
   GLuint newWidth, newHeight;
   struct gl_framebuffer *buffer;

   buffer = ctx->WinSysDrawBuffer;
   get_buffer_size( buffer, &newWidth, &newHeight );
   if (buffer->Width != newWidth || buffer->Height != newHeight) {
      _mesa_resize_framebuffer(ctx, buffer, newWidth, newHeight );
   }

   buffer = ctx->WinSysReadBuffer;
   get_buffer_size( buffer, &newWidth, &newHeight );
   if (buffer->Width != newWidth || buffer->Height != newHeight) {
      _mesa_resize_framebuffer(ctx, buffer, newWidth, newHeight );
   }
}


/*
 * Generate code for span functions.
 */

/* 24-bit BGR */
#define NAME(PREFIX) PREFIX##_B8G8R8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   struct GLFBDevRenderbufferRec *frb = (struct GLFBDevRenderbufferRec *) rb;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLubyte *P = frb->bottom - (Y) * frb->rowStride + (X) * 3
#define INC_PIXEL_PTR(P) P += 3
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[0] = VALUE[BCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[2] = VALUE[RCOMP]
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[2];  \
   DST[GCOMP] = SRC[1];  \
   DST[BCOMP] = SRC[0];  \
   DST[ACOMP] = CHAN_MAX

#include "swrast/s_spantemp.h"


/* 32-bit BGRA */
#define NAME(PREFIX) PREFIX##_B8G8R8A8
#define RB_TYPE GLubyte
#define SPAN_VARS \
   struct GLFBDevRenderbufferRec *frb = (struct GLFBDevRenderbufferRec *) rb;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLubyte *P = frb->bottom - (Y) * frb->rowStride + (X) * 4
#define INC_PIXEL_PTR(P) P += 4
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[0] = VALUE[BCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[2] = VALUE[RCOMP];  \
   DST[3] = VALUE[ACOMP]
#define STORE_PIXEL_RGB(DST, X, Y, VALUE) \
   DST[0] = VALUE[BCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[2] = VALUE[RCOMP];
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = SRC[2];  \
   DST[GCOMP] = SRC[1];  \
   DST[BCOMP] = SRC[0];  \
   DST[ACOMP] = SRC[3]

#include "swrast/s_spantemp.h"


/* 16-bit BGR (XXX implement dithering someday) */
#define NAME(PREFIX) PREFIX##_B5G6R5
#define RB_TYPE GLubyte
#define SPAN_VARS \
   struct GLFBDevRenderbufferRec *frb = (struct GLFBDevRenderbufferRec *) rb;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLushort *P = (GLushort *) (frb->bottom - (Y) * frb->rowStride + (X) * 2)
#define INC_PIXEL_PTR(P) P += 1
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[0] = ( (((VALUE[RCOMP]) & 0xf8) << 8) | (((VALUE[GCOMP]) & 0xfc) << 3) | ((VALUE[BCOMP]) >> 3) )
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = ( (((SRC[0]) >> 8) & 0xf8) | (((SRC[0]) >> 11) & 0x7) ); \
   DST[GCOMP] = ( (((SRC[0]) >> 3) & 0xfc) | (((SRC[0]) >>  5) & 0x3) ); \
   DST[BCOMP] = ( (((SRC[0]) << 3) & 0xf8) | (((SRC[0])      ) & 0x7) ); \
   DST[ACOMP] = CHAN_MAX

#include "swrast/s_spantemp.h"


/* 15-bit BGR (XXX implement dithering someday) */
#define NAME(PREFIX) PREFIX##_B5G5R5
#define RB_TYPE GLubyte
#define SPAN_VARS \
   struct GLFBDevRenderbufferRec *frb = (struct GLFBDevRenderbufferRec *) rb;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLushort *P = (GLushort *) (frb->bottom - (Y) * frb->rowStride + (X) * 2)
#define INC_PIXEL_PTR(P) P += 1
#define STORE_PIXEL(DST, X, Y, VALUE) \
   DST[0] = ( (((VALUE[RCOMP]) & 0xf8) << 7) | (((VALUE[GCOMP]) & 0xf8) << 2) | ((VALUE[BCOMP]) >> 3) )
#define FETCH_PIXEL(DST, SRC) \
   DST[RCOMP] = ( (((SRC[0]) >> 7) & 0xf8) | (((SRC[0]) >> 10) & 0x7) ); \
   DST[GCOMP] = ( (((SRC[0]) >> 2) & 0xf8) | (((SRC[0]) >>  5) & 0x7) ); \
   DST[BCOMP] = ( (((SRC[0]) << 3) & 0xf8) | (((SRC[0])      ) & 0x7) ); \
   DST[ACOMP] = CHAN_MAX

#include "swrast/s_spantemp.h"


/**********************************************************************/
/* Public API functions                                               */
/**********************************************************************/


const char *
glFBDevGetString( int str )
{
   switch (str) {
   case GLFBDEV_VENDOR:
      return "Mesa Project";
   case GLFBDEV_VERSION:
      return "1.0.1";
   default:
      return NULL;
   }
}


GLFBDevProc
glFBDevGetProcAddress( const char *procName )
{
   struct name_address {
      const char *name;
      const GLFBDevProc func;
   };
   static const struct name_address functions[] = {
      { "glFBDevGetString", (GLFBDevProc) glFBDevGetString },
      { "glFBDevGetProcAddress", (GLFBDevProc) glFBDevGetProcAddress },
      { "glFBDevCreateVisual", (GLFBDevProc) glFBDevCreateVisual },
      { "glFBDevDestroyVisual", (GLFBDevProc) glFBDevDestroyVisual },
      { "glFBDevGetVisualAttrib", (GLFBDevProc) glFBDevGetVisualAttrib },
      { "glFBDevCreateBuffer", (GLFBDevProc) glFBDevCreateBuffer },
      { "glFBDevDestroyBuffer", (GLFBDevProc) glFBDevDestroyBuffer },
      { "glFBDevGetBufferAttrib", (GLFBDevProc) glFBDevGetBufferAttrib },
      { "glFBDevGetCurrentDrawBuffer", (GLFBDevProc) glFBDevGetCurrentDrawBuffer },
      { "glFBDevGetCurrentReadBuffer", (GLFBDevProc) glFBDevGetCurrentReadBuffer },
      { "glFBDevSwapBuffers", (GLFBDevProc) glFBDevSwapBuffers },
      { "glFBDevCreateContext", (GLFBDevProc) glFBDevCreateContext },
      { "glFBDevDestroyContext", (GLFBDevProc) glFBDevDestroyContext },
      { "glFBDevGetContextAttrib", (GLFBDevProc) glFBDevGetContextAttrib },
      { "glFBDevGetCurrentContext", (GLFBDevProc) glFBDevGetCurrentContext },
      { "glFBDevMakeCurrent", (GLFBDevProc) glFBDevMakeCurrent },
      { NULL, NULL }
   };
   const struct name_address *entry;
   for (entry = functions; entry->name; entry++) {
      if (strcmp(entry->name, procName) == 0) {
         return entry->func;
      }
   }
   return _glapi_get_proc_address(procName);
}


GLFBDevVisualPtr
glFBDevCreateVisual( const struct fb_fix_screeninfo *fixInfo,
                     const struct fb_var_screeninfo *varInfo,
                     const int *attribs )
{
   GLFBDevVisualPtr vis;
   const int *attrib;
   GLboolean dbFlag = GL_FALSE, stereoFlag = GL_FALSE;
   GLint redBits = 0, greenBits = 0, blueBits = 0, alphaBits = 0;
   GLint depthBits = 0, stencilBits = 0;
   GLint accumRedBits = 0, accumGreenBits = 0;
   GLint accumBlueBits = 0, accumAlphaBits = 0;
   GLint numSamples = 0;

   ASSERT(fixInfo);
   ASSERT(varInfo);

   vis = CALLOC_STRUCT(GLFBDevVisualRec);
   if (!vis)
      return NULL;

   vis->fix = *fixInfo;  /* struct assignment */
   vis->var = *varInfo;  /* struct assignment */

   for (attrib = attribs; attrib && *attrib != GLFBDEV_NONE; attrib++) {
      switch (*attrib) {
      case GLFBDEV_DOUBLE_BUFFER:
         dbFlag = GL_TRUE;
         break;
      case GLFBDEV_DEPTH_SIZE:
         depthBits = attrib[1];
         attrib++;
         break;
      case GLFBDEV_STENCIL_SIZE:
         stencilBits = attrib[1];
         attrib++;
         break;
      case GLFBDEV_ACCUM_SIZE:
         accumRedBits = accumGreenBits = accumBlueBits = accumAlphaBits
            = attrib[1];
         attrib++;
         break;
      case GLFBDEV_LEVEL:
         /* ignored for now */
         break;
      case GLFBDEV_MULTISAMPLE:
         numSamples = attrib[1];
         attrib++;
         break;
      case GLFBDEV_COLOR_INDEX:
         /* Mesa no longer supports color-index rendering. */
      default:
         /* unexpected token */
         free(vis);
         return NULL;
      }
   }

   redBits   = varInfo->red.length;
   greenBits = varInfo->green.length;
   blueBits  = varInfo->blue.length;
   alphaBits = varInfo->transp.length;

   if (fixInfo->visual == FB_VISUAL_TRUECOLOR ||
       fixInfo->visual == FB_VISUAL_DIRECTCOLOR) {
      if (varInfo->bits_per_pixel == 24
          && varInfo->red.offset == 16
          && varInfo->green.offset == 8
          && varInfo->blue.offset == 0) {
         vis->pixelFormat = PF_B8G8R8;
      }
      else if (varInfo->bits_per_pixel == 32
               && varInfo->red.offset == 16
               && varInfo->green.offset == 8
               && varInfo->blue.offset == 0) {
         vis->pixelFormat = PF_B8G8R8A8;
      }
      else if (varInfo->bits_per_pixel == 16
               && varInfo->red.offset == 11
               && varInfo->green.offset == 5
               && varInfo->blue.offset == 0) {
         vis->pixelFormat = PF_B5G6R5;
      }
      else if (varInfo->bits_per_pixel == 16
               && varInfo->red.offset == 10
               && varInfo->green.offset == 5
               && varInfo->blue.offset == 0) {
         vis->pixelFormat = PF_B5G5R5;
      }
      else {
         _mesa_problem(NULL, "Unsupported fbdev RGB visual/bitdepth!\n");
         free(vis);
         return NULL;
      }
   }

   if (!_mesa_initialize_visual(&vis->glvisual, dbFlag, stereoFlag,
                                redBits, greenBits, blueBits, alphaBits,
                                depthBits, stencilBits,
                                accumRedBits, accumGreenBits,
                                accumBlueBits, accumAlphaBits,
                                numSamples)) {
      /* something was invalid */
      free(vis);
      return NULL;
   }

   return vis;
}


void
glFBDevDestroyVisual( GLFBDevVisualPtr visual )
{
   if (visual)
      free(visual);
}


int
glFBDevGetVisualAttrib( const GLFBDevVisualPtr visual, int attrib)
{
   /* XXX unfinished */
   (void) visual;
   (void) attrib;
   return -1;
}


static void
delete_renderbuffer(struct gl_renderbuffer *rb)
{
   struct GLFBDevRenderbufferRec *frb = (struct GLFBDevRenderbufferRec *) rb;
   if (frb->mallocedBuffer) {
      free(frb->Base.Data);
   }
   free(frb);
}


static GLboolean
renderbuffer_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
                     GLenum internalFormat, GLuint width, GLuint height)
{
   /* no-op: the renderbuffer storage is allocated just once when it's
    * created.  Never resized or reallocated.
    */
   return GL_TRUE;
}


static struct GLFBDevRenderbufferRec *
new_glfbdev_renderbuffer(void *bufferStart, const GLFBDevVisualPtr visual)
{
   struct GLFBDevRenderbufferRec *rb = CALLOC_STRUCT(GLFBDevRenderbufferRec);
   if (rb) {
      GLuint name = 0;
      int pixelFormat = visual->pixelFormat;

      _mesa_init_renderbuffer(&rb->Base, name);

      rb->Base.Delete = delete_renderbuffer;
      rb->Base.AllocStorage = renderbuffer_storage;

      if (pixelFormat == PF_B8G8R8) {
         rb->Base.GetRow = get_row_B8G8R8;
         rb->Base.GetValues = get_values_B8G8R8;
         rb->Base.PutRow = put_row_B8G8R8;
         rb->Base.PutRowRGB = put_row_rgb_B8G8R8;
         rb->Base.PutMonoRow = put_mono_row_B8G8R8;
         rb->Base.PutValues = put_values_B8G8R8;
         rb->Base.PutMonoValues = put_mono_values_B8G8R8;
      }
      else if (pixelFormat == PF_B8G8R8A8) {
         rb->Base.GetRow = get_row_B8G8R8A8;
         rb->Base.GetValues = get_values_B8G8R8A8;
         rb->Base.PutRow = put_row_B8G8R8A8;
         rb->Base.PutRowRGB = put_row_rgb_B8G8R8A8;
         rb->Base.PutMonoRow = put_mono_row_B8G8R8A8;
         rb->Base.PutValues = put_values_B8G8R8A8;
         rb->Base.PutMonoValues = put_mono_values_B8G8R8A8;
      }
      else if (pixelFormat == PF_B5G6R5) {
         rb->Base.GetRow = get_row_B5G6R5;
         rb->Base.GetValues = get_values_B5G6R5;
         rb->Base.PutRow = put_row_B5G6R5;
         rb->Base.PutRowRGB = put_row_rgb_B5G6R5;
         rb->Base.PutMonoRow = put_mono_row_B5G6R5;
         rb->Base.PutValues = put_values_B5G6R5;
         rb->Base.PutMonoValues = put_mono_values_B5G6R5;
      }
      else if (pixelFormat == PF_B5G5R5) {
         rb->Base.GetRow = get_row_B5G5R5;
         rb->Base.GetValues = get_values_B5G5R5;
         rb->Base.PutRow = put_row_B5G5R5;
         rb->Base.PutRowRGB = put_row_rgb_B5G5R5;
         rb->Base.PutMonoRow = put_mono_row_B5G5R5;
         rb->Base.PutValues = put_values_B5G5R5;
         rb->Base.PutMonoValues = put_mono_values_B5G5R5;
      }

      rb->Base.InternalFormat = GL_RGBA;
      rb->Base._BaseFormat = GL_RGBA;
      rb->Base.DataType = GL_UNSIGNED_BYTE;
      rb->Base.Data = bufferStart;

      rb->rowStride = visual->var.xres_virtual * visual->var.bits_per_pixel / 8;
      rb->bottom = (GLubyte *) bufferStart
                 + (visual->var.yres - 1) * rb->rowStride;

      rb->Base.Width = visual->var.xres;
      rb->Base.Height = visual->var.yres;

      /*
      rb->Base.RedBits = visual->var.red.length;
      rb->Base.GreenBits = visual->var.green.length;
      rb->Base.BlueBits = visual->var.blue.length;
      rb->Base.AlphaBits = visual->var.transp.length;
      */

      rb->Base.InternalFormat = pixelFormat;
   }
   return rb;
}

GLFBDevBufferPtr
glFBDevCreateBuffer( const struct fb_fix_screeninfo *fixInfo,
                     const struct fb_var_screeninfo *varInfo,
                     const GLFBDevVisualPtr visual,
                     void *frontBuffer, void *backBuffer, size_t size )
{
   struct GLFBDevRenderbufferRec *frontrb, *backrb;
   GLFBDevBufferPtr buf;

   ASSERT(visual);
   ASSERT(frontBuffer);
   ASSERT(size > 0);

   /* this is to update the visual if there was a resize and the
      buffer is created again */
   visual->var = *varInfo;
   visual->fix = *fixInfo;

   if (visual->fix.visual != fixInfo->visual ||
       visual->fix.type != fixInfo->type ||
       visual->var.bits_per_pixel != varInfo->bits_per_pixel ||
       visual->var.grayscale != varInfo->grayscale ||
       visual->var.red.offset != varInfo->red.offset ||
       visual->var.green.offset != varInfo->green.offset ||
       visual->var.blue.offset != varInfo->blue.offset ||
       visual->var.transp.offset != varInfo->transp.offset) {
      /* visual mismatch! */
      return NULL;
   }

   buf = CALLOC_STRUCT(GLFBDevBufferRec);
   if (!buf)
      return NULL;

   /* basic framebuffer setup */
   _mesa_initialize_window_framebuffer(&buf->glframebuffer, &visual->glvisual);
   /* add front renderbuffer */
   frontrb = new_glfbdev_renderbuffer(frontBuffer, visual);
   _mesa_add_renderbuffer(&buf->glframebuffer, BUFFER_FRONT_LEFT,
                          &frontrb->Base);
   /* add back renderbuffer */
   if (visual->glvisual.doubleBufferMode) {
      const int malloced = !backBuffer;
      if (malloced) {
         /* malloc a back buffer */
         backBuffer = malloc(size);
         if (!backBuffer) {
            _mesa_free_framebuffer_data(&buf->glframebuffer);
            free(buf);
            return NULL;
         }
      }

      backrb = new_glfbdev_renderbuffer(backBuffer, visual);
      if (!backrb) {
         /* out of mem */
         return NULL;
      }
      backrb->mallocedBuffer = malloced;

      _mesa_add_renderbuffer(&buf->glframebuffer, BUFFER_BACK_LEFT,
                             &backrb->Base);
   }
   /* add software renderbuffers */
   _mesa_add_soft_renderbuffers(&buf->glframebuffer,
                                GL_FALSE, /* color */
                                visual->glvisual.haveDepthBuffer,
                                visual->glvisual.haveStencilBuffer,
                                visual->glvisual.haveAccumBuffer,
                                GL_FALSE, /* alpha */
                                GL_FALSE /* aux bufs */);

   buf->fix = *fixInfo;   /* struct assignment */
   buf->var = *varInfo;   /* struct assignment */
   buf->visual = visual;  /* ptr assignment */
   buf->size = size;
   buf->bytesPerPixel = visual->var.bits_per_pixel / 8;

   return buf;
}


void
glFBDevDestroyBuffer( GLFBDevBufferPtr buffer )
{
   if (buffer) {
      /* check if destroying the current buffer */
      GLFBDevBufferPtr curDraw = glFBDevGetCurrentDrawBuffer();
      GLFBDevBufferPtr curRead = glFBDevGetCurrentReadBuffer();
      if (buffer == curDraw || buffer == curRead) {
         glFBDevMakeCurrent( NULL, NULL, NULL);
      }
      {
         struct gl_framebuffer *fb = &buffer->glframebuffer;
         _mesa_reference_framebuffer(&fb, NULL);
      }
   }
}


int
glFBDevGetBufferAttrib( const GLFBDevBufferPtr buffer, int attrib)
{
   (void) buffer;
   (void) attrib;
   return -1;
}


GLFBDevBufferPtr
glFBDevGetCurrentDrawBuffer( void )
{
   GLFBDevContextPtr fbdevctx = glFBDevGetCurrentContext();
   if (fbdevctx)
      return fbdevctx->drawBuffer;
   else
      return NULL;
}


GLFBDevBufferPtr
glFBDevGetCurrentReadBuffer( void )
{
   GLFBDevContextPtr fbdevctx = glFBDevGetCurrentContext();
   if (fbdevctx)
      return fbdevctx->readBuffer;
   else
      return NULL;
}


void
glFBDevSwapBuffers( GLFBDevBufferPtr buffer )
{
   GLFBDevContextPtr fbdevctx = glFBDevGetCurrentContext();
   struct GLFBDevRenderbufferRec *frontrb = (struct GLFBDevRenderbufferRec *)
      buffer->glframebuffer.Attachment[BUFFER_FRONT_LEFT].Renderbuffer;
   struct GLFBDevRenderbufferRec *backrb = (struct GLFBDevRenderbufferRec *)
      buffer->glframebuffer.Attachment[BUFFER_BACK_LEFT].Renderbuffer;

   if (!buffer || !buffer->visual->glvisual.doubleBufferMode)
      return;

   /* check if swapping currently bound buffer */
   if (fbdevctx->drawBuffer == buffer) {
      /* flush pending rendering */
      _mesa_notifySwapBuffers(&fbdevctx->glcontext);
   }

   ASSERT(frontrb->Base.Data);
   ASSERT(backrb->Base.Data);
   memcpy(frontrb->Base.Data, backrb->Base.Data, buffer->size);
}


GLFBDevContextPtr
glFBDevCreateContext( const GLFBDevVisualPtr visual, GLFBDevContextPtr share )
{
   GLFBDevContextPtr ctx;
   struct gl_context *glctx;
   struct dd_function_table functions;

   ASSERT(visual);

   ctx = CALLOC_STRUCT(GLFBDevContextRec);
   if (!ctx)
      return NULL;

   /* build table of device driver functions */
   _mesa_init_driver_functions(&functions);
   functions.GetString = get_string;
   functions.UpdateState = update_state;
   functions.GetBufferSize = get_buffer_size;
   functions.Viewport = viewport;

   if (!_mesa_initialize_context(&ctx->glcontext, API_OPENGL, &visual->glvisual,
                                 share ? &share->glcontext : NULL,
                                 &functions, (void *) ctx)) {
      free(ctx);
      return NULL;
   }

   ctx->visual = visual;

   /* Create module contexts */
   glctx = (struct gl_context *) &ctx->glcontext;
   _swrast_CreateContext( glctx );
   _vbo_CreateContext( glctx );
   _tnl_CreateContext( glctx );
   _swsetup_CreateContext( glctx );
   _swsetup_Wakeup( glctx );

   /* use default TCL pipeline */
   {
      TNLcontext *tnl = TNL_CONTEXT(glctx);
      tnl->Driver.RunPipeline = _tnl_run_pipeline;
   }

   _mesa_enable_sw_extensions(glctx);
   _mesa_enable_1_3_extensions(glctx);
   _mesa_enable_1_4_extensions(glctx);
   _mesa_enable_1_5_extensions(glctx);
   _mesa_enable_2_0_extensions(glctx);
   _mesa_enable_2_1_extensions(glctx);

   return ctx;
}


void
glFBDevDestroyContext( GLFBDevContextPtr context )
{
   GLFBDevContextPtr fbdevctx = glFBDevGetCurrentContext();

   if (context) {
      struct gl_context *mesaCtx = &context->glcontext;

      _swsetup_DestroyContext( mesaCtx );
      _swrast_DestroyContext( mesaCtx );
      _tnl_DestroyContext( mesaCtx );
      _vbo_DestroyContext( mesaCtx );

      if (fbdevctx == context) {
         /* destroying current context */
         _mesa_make_current(NULL, NULL, NULL);
      }
      _mesa_free_context_data(&context->glcontext);
      free(context);
   }
}


int
glFBDevGetContextAttrib( const GLFBDevContextPtr context, int attrib)
{
   (void) context;
   (void) attrib;
   return -1;
}


GLFBDevContextPtr
glFBDevGetCurrentContext( void )
{
   GET_CURRENT_CONTEXT(ctx);
   return (GLFBDevContextPtr) ctx;
}


int
glFBDevMakeCurrent( GLFBDevContextPtr context,
                    GLFBDevBufferPtr drawBuffer,
                    GLFBDevBufferPtr readBuffer )
{
   if (context && drawBuffer && readBuffer) {
      /* Make sure the context's visual and the buffers' visuals match.
       * XXX we might do this by comparing specific fields like bits_per_pixel,
       * visual, etc. in the future.
       */
      if (context->visual != drawBuffer->visual ||
          context->visual != readBuffer->visual) {
         return 0;
      }
      _mesa_make_current( &context->glcontext,
                          &drawBuffer->glframebuffer,
                          &readBuffer->glframebuffer );
      context->drawBuffer = drawBuffer;
      context->readBuffer = readBuffer;
      context->curBuffer = drawBuffer;
   }
   else {
      /* unbind */
      _mesa_make_current( NULL, NULL, NULL );
   }

   return 1;
}

#endif /* USE_GLFBDEV_DRIVER */
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.6
log
@Merge Mesa 7.10.3
@
text
@d725 1
a725 1
   if (!_mesa_initialize_context(&ctx->glcontext, &visual->glvisual,
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d44 1
a45 1
#include "GL/glfbdev.h"
d76 1
a76 1
 * Derived from Mesa's GLvisual class.
d79 1
a79 1
   GLvisual glvisual;              /* base class */
d86 1
a86 1
 * Derived from Mesa's GLframebuffer class.
d89 1
a89 1
   GLframebuffer glframebuffer;    /* base class */
d98 1
a98 1
 * Derived from Mesa's GLcontext class.
d101 1
a101 1
   GLcontext glcontext;            /* base class */
d125 1
a125 1
get_string(GLcontext *ctx, GLenum pname)
d138 1
a138 1
update_state( GLcontext *ctx, GLuint new_state )
d149 1
a149 1
get_buffer_size( GLframebuffer *buffer, GLuint *width, GLuint *height )
d162 1
a162 1
viewport(GLcontext *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
d165 1
a165 1
   GLframebuffer *buffer;
d219 4
d466 1
a466 1
renderbuffer_storage(GLcontext *ctx, struct gl_renderbuffer *rb,
d538 1
d543 1
d709 1
a709 1
   GLcontext *glctx;
d735 1
a735 1
   glctx = (GLcontext *) &ctx->glcontext;
d765 1
a765 1
      GLcontext *mesaCtx = &context->glcontext;
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a72 1
#define PF_CI8        5
a265 19
/* 8-bit color index */
#define NAME(PREFIX) PREFIX##_CI8
#define CI_MODE
#define RB_TYPE GLubyte
#define SPAN_VARS \
   struct GLFBDevRenderbufferRec *frb = (struct GLFBDevRenderbufferRec *) rb;
#define INIT_PIXEL_PTR(P, X, Y) \
   GLubyte *P = frb->bottom - (Y) * frb->rowStride + (X)
#define INC_PIXEL_PTR(P) P += 1
#define STORE_PIXEL(DST, X, Y, VALUE) \
   *DST = VALUE[0]
#define FETCH_PIXEL(DST, SRC) \
   DST = SRC[0]

#include "swrast/s_spantemp.h"




d313 1
a313 1
      if (_mesa_strcmp(entry->name, procName) == 0) {
d328 1
a328 1
   GLboolean rgbFlag = GL_TRUE, dbFlag = GL_FALSE, stereoFlag = GL_FALSE;
d330 1
a330 1
   GLint indexBits = 0, depthBits = 0, stencilBits = 0;
a349 3
      case GLFBDEV_COLOR_INDEX:
         rgbFlag = GL_FALSE;
         break;
d370 2
d374 1
a374 1
         _mesa_free(vis);
d379 30
a408 45
   if (rgbFlag) {
      redBits   = varInfo->red.length;
      greenBits = varInfo->green.length;
      blueBits  = varInfo->blue.length;
      alphaBits = varInfo->transp.length;

      if (fixInfo->visual == FB_VISUAL_TRUECOLOR ||
          fixInfo->visual == FB_VISUAL_DIRECTCOLOR) {
         if (varInfo->bits_per_pixel == 24
             && varInfo->red.offset == 16
             && varInfo->green.offset == 8
             && varInfo->blue.offset == 0) {
            vis->pixelFormat = PF_B8G8R8;
         }
         else if (varInfo->bits_per_pixel == 32
                  && varInfo->red.offset == 16
                  && varInfo->green.offset == 8
                  && varInfo->blue.offset == 0) {
            vis->pixelFormat = PF_B8G8R8A8;
         }
         else if (varInfo->bits_per_pixel == 16
                  && varInfo->red.offset == 11
                  && varInfo->green.offset == 5
                  && varInfo->blue.offset == 0) {
            vis->pixelFormat = PF_B5G6R5;
         }
         else if (varInfo->bits_per_pixel == 16
                  && varInfo->red.offset == 10
                  && varInfo->green.offset == 5
                  && varInfo->blue.offset == 0) {
            vis->pixelFormat = PF_B5G5R5;
         }
         else {
            _mesa_problem(NULL, "Unsupported fbdev RGB visual/bitdepth!\n");
            _mesa_free(vis);
            return NULL;
         }
      }
   }
   else {
      indexBits = varInfo->bits_per_pixel;
      if ((fixInfo->visual == FB_VISUAL_PSEUDOCOLOR ||
           fixInfo->visual == FB_VISUAL_STATIC_PSEUDOCOLOR)
          && varInfo->bits_per_pixel == 8) {
         vis->pixelFormat = PF_CI8;
d411 2
a412 2
         _mesa_problem(NULL, "Unsupported fbdev CI visual/bitdepth!\n");
         _mesa_free(vis);
d417 1
a417 1
   if (!_mesa_initialize_visual(&vis->glvisual, rgbFlag, dbFlag, stereoFlag,
d419 1
a419 1
                                indexBits, depthBits, stencilBits,
d424 1
a424 1
      _mesa_free(vis);
d436 1
a436 1
      _mesa_free(visual);
d455 1
a455 1
      _mesa_free(frb->Base.Data);
d457 1
a457 1
   _mesa_free(frb);
a520 8
      else if (pixelFormat == PF_CI8) {
         rb->Base.GetRow = get_row_CI8;
         rb->Base.GetValues = get_values_CI8;
         rb->Base.PutRow = put_row_CI8;
         rb->Base.PutMonoRow = put_mono_row_CI8;
         rb->Base.PutValues = put_values_CI8;
         rb->Base.PutMonoValues = put_mono_values_CI8;
      }
d522 2
a523 8
      if (pixelFormat == PF_CI8) {
         rb->Base.InternalFormat = GL_COLOR_INDEX8_EXT;
         rb->Base._BaseFormat = GL_COLOR_INDEX;
      }
      else {
         rb->Base.InternalFormat = GL_RGBA;
         rb->Base._BaseFormat = GL_RGBA;
      }
d579 1
a579 1
   _mesa_initialize_framebuffer(&buf->glframebuffer, &visual->glvisual);
d589 1
a589 1
         backBuffer = _mesa_malloc(size);
d592 1
a592 1
            _mesa_free(buf);
d638 1
a638 1
         _mesa_unreference_framebuffer(&fb);
d695 1
a695 1
   _mesa_memcpy(frontrb->Base.Data, backrb->Base.Data, buffer->size);
d722 1
a722 1
      _mesa_free(ctx);
d771 1
a771 1
      _mesa_free(context);
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a43 1
#include "glheader.h"
d46 11
a56 10
#include "buffers.h"
#include "context.h"
#include "extensions.h"
#include "fbobject.h"
#include "framebuffer.h"
#include "imports.h"
#include "renderbuffer.h"
#include "texformat.h"
#include "teximage.h"
#include "texstore.h"
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d3 1
a3 1
 * Version:  6.5.1
d5 1
a5 1
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
d66 3
d76 1
a76 1
/*
d86 1
a86 1
/*
d98 1
a98 1
/*
d109 1
a109 1
/*
a119 5

#define GLFBDEV_CONTEXT(CTX)  ((GLFBDevContextPtr) (CTX))
#define GLFBDEV_BUFFER(BUF)  ((GLFBDevBufferPtr) (BUF))


d152 1
a152 1
   const GLFBDevBufferPtr fbdevbuffer = GLFBDEV_BUFFER(buffer);
d390 2
a391 2
	 numSamples = attrib[1];
	 attrib++;
d407 30
a436 30
	  fixInfo->visual == FB_VISUAL_DIRECTCOLOR) {
	 if(varInfo->bits_per_pixel == 24
	    && varInfo->red.offset == 16
	    && varInfo->green.offset == 8
	    && varInfo->blue.offset == 0)
	    vis->pixelFormat = PF_B8G8R8;

	 else if(varInfo->bits_per_pixel == 32
		 && varInfo->red.offset == 16
		 && varInfo->green.offset == 8
		 && varInfo->blue.offset == 0)
	    vis->pixelFormat = PF_B8G8R8A8;

	 else if(varInfo->bits_per_pixel == 16
		 && varInfo->red.offset == 11
		 && varInfo->green.offset == 5
		 && varInfo->blue.offset == 0)
	    vis->pixelFormat = PF_B5G6R5;

	 else if(varInfo->bits_per_pixel == 16
		 && varInfo->red.offset == 10
		 && varInfo->green.offset == 5
		 && varInfo->blue.offset == 0)
	    vis->pixelFormat = PF_B5G5R5;

	 else {
	    _mesa_problem(NULL, "Unsupported fbdev RGB visual/bitdepth!\n");
	    _mesa_free(vis);
	    return NULL;
	 }
d579 1
a579 1
	  + (visual->var.yres - 1) * rb->rowStride;
d636 1
a636 1
      int malloced = !backBuffer;
d648 5
a652 2
      if(malloced)
	 backrb->mallocedBuffer = GL_TRUE;
a685 5
#if 0
      /* free the software depth, stencil, accum buffers */
      _mesa_free_framebuffer_data(&buffer->glframebuffer);
      _mesa_free(buffer);
#else
a689 1
#endif
@


1.1
log
@Initial revision
@
text
@d57 1
a57 1
#include "array_cache/acache.h"
d146 1
a146 1
   _ac_InvalidateState( ctx, new_state );
d160 4
d167 14
a180 2
   /* poll for window size change and realloc software Z/stencil/etc if needed */
   _mesa_ResizeBuffersMESA();
d685 1
d689 6
d786 1
a786 1
   _ac_CreateContext( glctx );
d798 5
d814 7
a823 1
         _mesa_notifyDestroy(&context->glcontext);
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a159 4
/**
 * We only implement this function as a mechanism to check if the
 * framebuffer size has changed (and update corresponding state).
 */
d163 2
a164 14
   GLuint newWidth, newHeight;
   GLframebuffer *buffer;

   buffer = ctx->WinSysDrawBuffer;
   get_buffer_size( buffer, &newWidth, &newHeight );
   if (buffer->Width != newWidth || buffer->Height != newHeight) {
      _mesa_resize_framebuffer(ctx, buffer, newWidth, newHeight );
   }

   buffer = ctx->WinSysReadBuffer;
   get_buffer_size( buffer, &newWidth, &newHeight );
   if (buffer->Width != newWidth || buffer->Height != newHeight) {
      _mesa_resize_framebuffer(ctx, buffer, newWidth, newHeight );
   }
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d57 1
a57 1
#include "vbo/vbo.h"
d146 1
a146 1
   _vbo_InvalidateState( ctx, new_state );
a684 1
#if 0
a687 6
#else
      {
         struct gl_framebuffer *fb = &buffer->glframebuffer;
         _mesa_unreference_framebuffer(&fb);
      }
#endif
d779 1
a779 1
   _vbo_CreateContext( glctx );
a801 7
      GLcontext *mesaCtx = &context->glcontext;

      _swsetup_DestroyContext( mesaCtx );
      _swrast_DestroyContext( mesaCtx );
      _tnl_DestroyContext( mesaCtx );
      _vbo_DestroyContext( mesaCtx );

d805 1
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d44 2
d47 10
a56 12
#include <linux/fb.h>
#include "main/glheader.h"
#include "main/buffers.h"
#include "main/context.h"
#include "main/extensions.h"
#include "main/fbobject.h"
#include "main/framebuffer.h"
#include "main/imports.h"
#include "main/renderbuffer.h"
#include "main/texformat.h"
#include "main/teximage.h"
#include "main/texstore.h"
a65 3
/**
 * Pixel formats we support:
 */
d70 1
d73 2
a74 2
/**
 * Derived from Mesa's struct gl_config class.
d77 1
a77 1
   struct gl_config glvisual;              /* base class */
d83 2
a84 2
/**
 * Derived from Mesa's struct gl_framebuffer class.
d87 1
a87 1
   struct gl_framebuffer glframebuffer;    /* base class */
d95 2
a96 2
/**
 * Derived from Mesa's struct gl_context class.
d99 1
a99 1
   struct gl_context glcontext;            /* base class */
d106 1
a106 1
/**
d117 5
d128 1
a128 1
get_string(struct gl_context *ctx, GLenum pname)
d141 1
a141 1
update_state( struct gl_context *ctx, GLuint new_state )
d152 1
a152 1
get_buffer_size( struct gl_framebuffer *buffer, GLuint *width, GLuint *height )
d154 1
a154 1
   const GLFBDevBufferPtr fbdevbuffer = (GLFBDevBufferPtr) buffer;
d165 1
a165 1
viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
d168 1
a168 1
   struct gl_framebuffer *buffer;
a221 4
#define STORE_PIXEL_RGB(DST, X, Y, VALUE) \
   DST[0] = VALUE[BCOMP];  \
   DST[1] = VALUE[GCOMP];  \
   DST[2] = VALUE[RCOMP];
d269 19
d335 1
a335 1
      if (strcmp(entry->name, procName) == 0) {
d350 1
a350 1
   GLboolean dbFlag = GL_FALSE, stereoFlag = GL_FALSE;
d352 1
a352 1
   GLint depthBits = 0, stencilBits = 0;
d372 3
d392 2
a393 2
         numSamples = attrib[1];
         attrib++;
a394 2
      case GLFBDEV_COLOR_INDEX:
         /* Mesa no longer supports color-index rendering. */
d397 1
a397 1
         free(vis);
d402 45
a446 30
   redBits   = varInfo->red.length;
   greenBits = varInfo->green.length;
   blueBits  = varInfo->blue.length;
   alphaBits = varInfo->transp.length;

   if (fixInfo->visual == FB_VISUAL_TRUECOLOR ||
       fixInfo->visual == FB_VISUAL_DIRECTCOLOR) {
      if (varInfo->bits_per_pixel == 24
          && varInfo->red.offset == 16
          && varInfo->green.offset == 8
          && varInfo->blue.offset == 0) {
         vis->pixelFormat = PF_B8G8R8;
      }
      else if (varInfo->bits_per_pixel == 32
               && varInfo->red.offset == 16
               && varInfo->green.offset == 8
               && varInfo->blue.offset == 0) {
         vis->pixelFormat = PF_B8G8R8A8;
      }
      else if (varInfo->bits_per_pixel == 16
               && varInfo->red.offset == 11
               && varInfo->green.offset == 5
               && varInfo->blue.offset == 0) {
         vis->pixelFormat = PF_B5G6R5;
      }
      else if (varInfo->bits_per_pixel == 16
               && varInfo->red.offset == 10
               && varInfo->green.offset == 5
               && varInfo->blue.offset == 0) {
         vis->pixelFormat = PF_B5G5R5;
d449 2
a450 2
         _mesa_problem(NULL, "Unsupported fbdev RGB visual/bitdepth!\n");
         free(vis);
d455 1
a455 1
   if (!_mesa_initialize_visual(&vis->glvisual, dbFlag, stereoFlag,
d457 1
a457 1
                                depthBits, stencilBits,
d462 1
a462 1
      free(vis);
d474 1
a474 1
      free(visual);
d493 1
a493 1
      free(frb->Base.Data);
d495 1
a495 1
   free(frb);
d500 1
a500 1
renderbuffer_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
d559 8
d568 8
a575 2
      rb->Base.InternalFormat = GL_RGBA;
      rb->Base._BaseFormat = GL_RGBA;
d581 1
a581 1
                 + (visual->var.yres - 1) * rb->rowStride;
a585 1
      /*
a589 1
      */
d631 1
a631 1
   _mesa_initialize_window_framebuffer(&buf->glframebuffer, &visual->glvisual);
d638 1
a638 1
      const int malloced = !backBuffer;
d641 1
a641 1
         backBuffer = malloc(size);
d644 1
a644 1
            free(buf);
d650 2
a651 5
      if (!backrb) {
         /* out of mem */
         return NULL;
      }
      backrb->mallocedBuffer = malloced;
d685 5
d692 1
a692 1
         _mesa_reference_framebuffer(&fb, NULL);
d694 1
d750 1
a750 1
   memcpy(frontrb->Base.Data, backrb->Base.Data, buffer->size);
d758 1
a758 1
   struct gl_context *glctx;
d777 1
a777 1
      free(ctx);
d784 1
a784 1
   glctx = (struct gl_context *) &ctx->glcontext;
a797 5
   _mesa_enable_1_3_extensions(glctx);
   _mesa_enable_1_4_extensions(glctx);
   _mesa_enable_1_5_extensions(glctx);
   _mesa_enable_2_0_extensions(glctx);
   _mesa_enable_2_1_extensions(glctx);
d809 1
a809 1
      struct gl_context *mesaCtx = &context->glcontext;
d821 1
a821 1
      free(context);
@


