head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.09.07.15.20.07;	author jsg;	state Exp;
branches;
next	1.8;
commitid	7kimTMT4YlQauAIU;

1.8
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.11.24.06.19.52;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2013.10.05.09.53.58;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2013.09.05.14.04.03;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.22.20.04.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.35;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.16.15;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.10.05.09.25.58;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.11.24.06.01.28;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.58;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2014.09.07.15.06.52;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	dm8VnQHhowGHmemJ;

1.1.1.7
date	2015.01.25.14.12.22;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.49.29;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * Meta operations.  Some GL operations can be expressed in terms of
 * other GL operations.  For example, glBlitFramebuffer() can be done
 * with texture mapping and glClear() can be done with polygon rendering.
 *
 * \author Brian Paul
 */


#include "main/glheader.h"
#include "main/mtypes.h"
#include "main/imports.h"
#include "main/arbprogram.h"
#include "main/arrayobj.h"
#include "main/blend.h"
#include "main/blit.h"
#include "main/bufferobj.h"
#include "main/buffers.h"
#include "main/colortab.h"
#include "main/condrender.h"
#include "main/depth.h"
#include "main/enable.h"
#include "main/fbobject.h"
#include "main/feedback.h"
#include "main/formats.h"
#include "main/glformats.h"
#include "main/image.h"
#include "main/macros.h"
#include "main/matrix.h"
#include "main/mipmap.h"
#include "main/multisample.h"
#include "main/objectlabel.h"
#include "main/pipelineobj.h"
#include "main/pixel.h"
#include "main/pbo.h"
#include "main/polygon.h"
#include "main/queryobj.h"
#include "main/readpix.h"
#include "main/scissor.h"
#include "main/shaderapi.h"
#include "main/shaderobj.h"
#include "main/state.h"
#include "main/stencil.h"
#include "main/texobj.h"
#include "main/texenv.h"
#include "main/texgetimage.h"
#include "main/teximage.h"
#include "main/texparam.h"
#include "main/texstate.h"
#include "main/transformfeedback.h"
#include "main/uniforms.h"
#include "main/varray.h"
#include "main/viewport.h"
#include "main/samplerobj.h"
#include "program/program.h"
#include "swrast/swrast.h"
#include "drivers/common/meta.h"
#include "main/enums.h"
#include "main/glformats.h"
#include "../glsl/ralloc.h"

/** Return offset in bytes of the field within a vertex struct */
#define OFFSET(FIELD) ((void *) offsetof(struct vertex, FIELD))

static void
meta_clear(struct gl_context *ctx, GLbitfield buffers, bool glsl);

static struct blit_shader *
choose_blit_shader(GLenum target, struct blit_shader_table *table);

static void cleanup_temp_texture(struct temp_texture *tex);
static void meta_glsl_clear_cleanup(struct clear_state *clear);
static void meta_decompress_cleanup(struct decompress_state *decompress);
static void meta_drawpix_cleanup(struct drawpix_state *drawpix);

void
_mesa_meta_bind_fbo_image(GLenum attachment,
                          struct gl_texture_image *texImage, GLuint layer)
{
   struct gl_texture_object *texObj = texImage->TexObject;
   int level = texImage->Level;
   GLenum target = texObj->Target;

   switch (target) {
   case GL_TEXTURE_1D:
      _mesa_FramebufferTexture1D(GL_FRAMEBUFFER,
                                 attachment,
                                 target,
                                 texObj->Name,
                                 level);
      break;
   case GL_TEXTURE_1D_ARRAY:
   case GL_TEXTURE_2D_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_3D:
      _mesa_FramebufferTextureLayer(GL_FRAMEBUFFER,
                                    attachment,
                                    texObj->Name,
                                    level,
                                    layer);
      break;
   default: /* 2D / cube */
      if (target == GL_TEXTURE_CUBE_MAP)
         target = GL_TEXTURE_CUBE_MAP_POSITIVE_X + texImage->Face;

      _mesa_FramebufferTexture2D(GL_FRAMEBUFFER,
                                 attachment,
                                 target,
                                 texObj->Name,
                                 level);
   }
}

GLuint
_mesa_meta_compile_shader_with_debug(struct gl_context *ctx, GLenum target,
                                     const GLcharARB *source)
{
   GLuint shader;
   GLint ok, size;
   GLchar *info;

   shader = _mesa_CreateShader(target);
   _mesa_ShaderSource(shader, 1, &source, NULL);
   _mesa_CompileShader(shader);

   _mesa_GetShaderiv(shader, GL_COMPILE_STATUS, &ok);
   if (ok)
      return shader;

   _mesa_GetShaderiv(shader, GL_INFO_LOG_LENGTH, &size);
   if (size == 0) {
      _mesa_DeleteShader(shader);
      return 0;
   }

   info = malloc(size);
   if (!info) {
      _mesa_DeleteShader(shader);
      return 0;
   }

   _mesa_GetShaderInfoLog(shader, size, NULL, info);
   _mesa_problem(ctx,
		 "meta program compile failed:\n%s\n"
		 "source:\n%s\n",
		 info, source);

   free(info);
   _mesa_DeleteShader(shader);

   return 0;
}

GLuint
_mesa_meta_link_program_with_debug(struct gl_context *ctx, GLuint program)
{
   GLint ok, size;
   GLchar *info;

   _mesa_LinkProgram(program);

   _mesa_GetProgramiv(program, GL_LINK_STATUS, &ok);
   if (ok)
      return program;

   _mesa_GetProgramiv(program, GL_INFO_LOG_LENGTH, &size);
   if (size == 0)
      return 0;

   info = malloc(size);
   if (!info)
      return 0;

   _mesa_GetProgramInfoLog(program, size, NULL, info);
   _mesa_problem(ctx, "meta program link failed:\n%s", info);

   free(info);

   return 0;
}

void
_mesa_meta_compile_and_link_program(struct gl_context *ctx,
                                    const char *vs_source,
                                    const char *fs_source,
                                    const char *name,
                                    GLuint *program)
{
   GLuint vs = _mesa_meta_compile_shader_with_debug(ctx, GL_VERTEX_SHADER,
                                                    vs_source);
   GLuint fs = _mesa_meta_compile_shader_with_debug(ctx, GL_FRAGMENT_SHADER,
                                                    fs_source);

   *program = _mesa_CreateProgram();
   _mesa_AttachShader(*program, fs);
   _mesa_DeleteShader(fs);
   _mesa_AttachShader(*program, vs);
   _mesa_DeleteShader(vs);
   _mesa_BindAttribLocation(*program, 0, "position");
   _mesa_BindAttribLocation(*program, 1, "texcoords");
   _mesa_meta_link_program_with_debug(ctx, *program);
   _mesa_ObjectLabel(GL_PROGRAM, *program, -1, name);

   _mesa_UseProgram(*program);
}

/**
 * Generate a generic shader to blit from a texture to a framebuffer
 *
 * \param ctx       Current GL context
 * \param texTarget Texture target that will be the source of the blit
 *
 * \returns a handle to a shader program on success or zero on failure.
 */
void
_mesa_meta_setup_blit_shader(struct gl_context *ctx,
                             GLenum target,
                             struct blit_shader_table *table)
{
   char *vs_source, *fs_source;
   void *const mem_ctx = ralloc_context(NULL);
   struct blit_shader *shader = choose_blit_shader(target, table);
   const char *vs_input, *vs_output, *fs_input, *vs_preprocess, *fs_preprocess;

   if (ctx->Const.GLSLVersion < 130) {
      vs_preprocess = "";
      vs_input = "attribute";
      vs_output = "varying";
      fs_preprocess = "#extension GL_EXT_texture_array : enable";
      fs_input = "varying";
   } else {
      vs_preprocess = "#version 130";
      vs_input = "in";
      vs_output = "out";
      fs_preprocess = "#version 130";
      fs_input = "in";
      shader->func = "texture";
   }

   assert(shader != NULL);

   if (shader->shader_prog != 0) {
      _mesa_UseProgram(shader->shader_prog);
      return;
   }

   vs_source = ralloc_asprintf(mem_ctx,
                "%s\n"
                "%s vec2 position;\n"
                "%s vec4 textureCoords;\n"
                "%s vec4 texCoords;\n"
                "void main()\n"
                "{\n"
                "   texCoords = textureCoords;\n"
                "   gl_Position = vec4(position, 0.0, 1.0);\n"
                "}\n",
                vs_preprocess, vs_input, vs_input, vs_output);

   fs_source = ralloc_asprintf(mem_ctx,
                "%s\n"
                "#extension GL_ARB_texture_cube_map_array: enable\n"
                "uniform %s texSampler;\n"
                "%s vec4 texCoords;\n"
                "void main()\n"
                "{\n"
                "   gl_FragColor = %s(texSampler, %s);\n"
                "   gl_FragDepth = gl_FragColor.x;\n"
                "}\n",
                fs_preprocess, shader->type, fs_input,
                shader->func, shader->texcoords);

   _mesa_meta_compile_and_link_program(ctx, vs_source, fs_source,
                                       ralloc_asprintf(mem_ctx, "%s blit",
                                                       shader->type),
                                       &shader->shader_prog);
   ralloc_free(mem_ctx);
}

/**
 * Configure vertex buffer and vertex array objects for tests
 *
 * Regardless of whether a new VAO and new VBO are created, the objects
 * referenced by \c VAO and \c VBO will be bound into the GL state vector
 * when this function terminates.
 *
 * \param VAO       Storage for vertex array object handle.  If 0, a new VAO
 *                  will be created.
 * \param VBO       Storage for vertex buffer object handle.  If 0, a new VBO
 *                  will be created.  The new VBO will have storage for 4
 *                  \c vertex structures.
 * \param use_generic_attributes  Should generic attributes 0 and 1 be used,
 *                  or should traditional, fixed-function color and texture
 *                  coordinate be used?
 * \param vertex_size  Number of components for attribute 0 / vertex.
 * \param texcoord_size  Number of components for attribute 1 / texture
 *                  coordinate.  If this is 0, attribute 1 will not be set or
 *                  enabled.
 * \param color_size  Number of components for attribute 1 / primary color.
 *                  If this is 0, attribute 1 will not be set or enabled.
 *
 * \note If \c use_generic_attributes is \c true, \c color_size must be zero.
 * Use \c texcoord_size instead.
 */
void
_mesa_meta_setup_vertex_objects(GLuint *VAO, GLuint *VBO,
                                bool use_generic_attributes,
                                unsigned vertex_size, unsigned texcoord_size,
                                unsigned color_size)
{
   if (*VAO == 0) {
      assert(*VBO == 0);

      /* create vertex array object */
      _mesa_GenVertexArrays(1, VAO);
      _mesa_BindVertexArray(*VAO);

      /* create vertex array buffer */
      _mesa_GenBuffers(1, VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER, *VBO);
      _mesa_BufferData(GL_ARRAY_BUFFER, 4 * sizeof(struct vertex), NULL,
                       GL_DYNAMIC_DRAW);

      /* setup vertex arrays */
      if (use_generic_attributes) {
         assert(color_size == 0);

         _mesa_VertexAttribPointer(0, vertex_size, GL_FLOAT, GL_FALSE,
                                   sizeof(struct vertex), OFFSET(x));
         _mesa_EnableVertexAttribArray(0);

         if (texcoord_size > 0) {
            _mesa_VertexAttribPointer(1, texcoord_size, GL_FLOAT, GL_FALSE,
                                      sizeof(struct vertex), OFFSET(tex));
            _mesa_EnableVertexAttribArray(1);
         }
      } else {
         _mesa_VertexPointer(vertex_size, GL_FLOAT, sizeof(struct vertex),
                             OFFSET(x));
         _mesa_EnableClientState(GL_VERTEX_ARRAY);

         if (texcoord_size > 0) {
            _mesa_TexCoordPointer(texcoord_size, GL_FLOAT,
                                  sizeof(struct vertex), OFFSET(tex));
            _mesa_EnableClientState(GL_TEXTURE_COORD_ARRAY);
         }

         if (color_size > 0) {
            _mesa_ColorPointer(color_size, GL_FLOAT,
                               sizeof(struct vertex), OFFSET(r));
            _mesa_EnableClientState(GL_COLOR_ARRAY);
         }
      }
   } else {
      _mesa_BindVertexArray(*VAO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER, *VBO);
   }
}

/**
 * Initialize meta-ops for a context.
 * To be called once during context creation.
 */
void
_mesa_meta_init(struct gl_context *ctx)
{
   ASSERT(!ctx->Meta);

   ctx->Meta = CALLOC_STRUCT(gl_meta_state);
}

static GLenum
gl_buffer_index_to_drawbuffers_enum(gl_buffer_index bufindex)
{
   assert(bufindex < BUFFER_COUNT);

   if (bufindex >= BUFFER_COLOR0)
      return GL_COLOR_ATTACHMENT0 + bufindex - BUFFER_COLOR0;
   else if (bufindex == BUFFER_FRONT_LEFT)
      return GL_FRONT_LEFT;
   else if (bufindex == BUFFER_FRONT_RIGHT)
      return GL_FRONT_RIGHT;
   else if (bufindex == BUFFER_BACK_LEFT)
      return GL_BACK_LEFT;
   else if (bufindex == BUFFER_BACK_RIGHT)
      return GL_BACK_RIGHT;

   return GL_NONE;
}

/**
 * Free context meta-op state.
 * To be called once during context destruction.
 */
void
_mesa_meta_free(struct gl_context *ctx)
{
   GET_CURRENT_CONTEXT(old_context);
   _mesa_make_current(ctx, NULL, NULL);
   _mesa_meta_glsl_blit_cleanup(&ctx->Meta->Blit);
   meta_glsl_clear_cleanup(&ctx->Meta->Clear);
   _mesa_meta_glsl_generate_mipmap_cleanup(&ctx->Meta->Mipmap);
   cleanup_temp_texture(&ctx->Meta->TempTex);
   meta_decompress_cleanup(&ctx->Meta->Decompress);
   meta_drawpix_cleanup(&ctx->Meta->DrawPix);
   if (old_context)
      _mesa_make_current(old_context, old_context->WinSysDrawBuffer, old_context->WinSysReadBuffer);
   else
      _mesa_make_current(NULL, NULL, NULL);
   free(ctx->Meta);
   ctx->Meta = NULL;
}


/**
 * Enter meta state.  This is like a light-weight version of glPushAttrib
 * but it also resets most GL state back to default values.
 *
 * \param state  bitmask of MESA_META_* flags indicating which attribute groups
 *               to save and reset to their defaults
 */
void
_mesa_meta_begin(struct gl_context *ctx, GLbitfield state)
{
   struct save_state *save;

   /* hope MAX_META_OPS_DEPTH is large enough */
   assert(ctx->Meta->SaveStackDepth < MAX_META_OPS_DEPTH);

   save = &ctx->Meta->Save[ctx->Meta->SaveStackDepth++];
   memset(save, 0, sizeof(*save));
   save->SavedState = state;

   /* We always push into desktop GL mode and pop out at the end.  No sense in
    * writing our shaders varying based on the user's context choice, when
    * Mesa can handle either.
    */
   save->API = ctx->API;
   ctx->API = API_OPENGL_COMPAT;

   /* Pausing transform feedback needs to be done early, or else we won't be
    * able to change other state.
    */
   save->TransformFeedbackNeedsResume =
      _mesa_is_xfb_active_and_unpaused(ctx);
   if (save->TransformFeedbackNeedsResume)
      _mesa_PauseTransformFeedback();

   /* After saving the current occlusion object, call EndQuery so that no
    * occlusion querying will be active during the meta-operation.
    */
   if (state & MESA_META_OCCLUSION_QUERY) {
      save->CurrentOcclusionObject = ctx->Query.CurrentOcclusionObject;
      if (save->CurrentOcclusionObject)
         _mesa_EndQuery(save->CurrentOcclusionObject->Target);
   }

   if (state & MESA_META_ALPHA_TEST) {
      save->AlphaEnabled = ctx->Color.AlphaEnabled;
      save->AlphaFunc = ctx->Color.AlphaFunc;
      save->AlphaRef = ctx->Color.AlphaRef;
      if (ctx->Color.AlphaEnabled)
         _mesa_set_enable(ctx, GL_ALPHA_TEST, GL_FALSE);
   }

   if (state & MESA_META_BLEND) {
      save->BlendEnabled = ctx->Color.BlendEnabled;
      if (ctx->Color.BlendEnabled) {
         if (ctx->Extensions.EXT_draw_buffers2) {
            GLuint i;
            for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
               _mesa_set_enablei(ctx, GL_BLEND, i, GL_FALSE);
            }
         }
         else {
            _mesa_set_enable(ctx, GL_BLEND, GL_FALSE);
         }
      }
      save->ColorLogicOpEnabled = ctx->Color.ColorLogicOpEnabled;
      if (ctx->Color.ColorLogicOpEnabled)
         _mesa_set_enable(ctx, GL_COLOR_LOGIC_OP, GL_FALSE);
   }

   if (state & MESA_META_COLOR_MASK) {
      memcpy(save->ColorMask, ctx->Color.ColorMask,
             sizeof(ctx->Color.ColorMask));
      if (!ctx->Color.ColorMask[0][0] ||
          !ctx->Color.ColorMask[0][1] ||
          !ctx->Color.ColorMask[0][2] ||
          !ctx->Color.ColorMask[0][3])
         _mesa_ColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
   }

   if (state & MESA_META_DEPTH_TEST) {
      save->Depth = ctx->Depth; /* struct copy */
      if (ctx->Depth.Test)
         _mesa_set_enable(ctx, GL_DEPTH_TEST, GL_FALSE);
   }

   if (state & MESA_META_FOG) {
      save->Fog = ctx->Fog.Enabled;
      if (ctx->Fog.Enabled)
         _mesa_set_enable(ctx, GL_FOG, GL_FALSE);
   }

   if (state & MESA_META_PIXEL_STORE) {
      save->Pack = ctx->Pack;
      save->Unpack = ctx->Unpack;
      ctx->Pack = ctx->DefaultPacking;
      ctx->Unpack = ctx->DefaultPacking;
   }

   if (state & MESA_META_PIXEL_TRANSFER) {
      save->RedScale = ctx->Pixel.RedScale;
      save->RedBias = ctx->Pixel.RedBias;
      save->GreenScale = ctx->Pixel.GreenScale;
      save->GreenBias = ctx->Pixel.GreenBias;
      save->BlueScale = ctx->Pixel.BlueScale;
      save->BlueBias = ctx->Pixel.BlueBias;
      save->AlphaScale = ctx->Pixel.AlphaScale;
      save->AlphaBias = ctx->Pixel.AlphaBias;
      save->MapColorFlag = ctx->Pixel.MapColorFlag;
      ctx->Pixel.RedScale = 1.0F;
      ctx->Pixel.RedBias = 0.0F;
      ctx->Pixel.GreenScale = 1.0F;
      ctx->Pixel.GreenBias = 0.0F;
      ctx->Pixel.BlueScale = 1.0F;
      ctx->Pixel.BlueBias = 0.0F;
      ctx->Pixel.AlphaScale = 1.0F;
      ctx->Pixel.AlphaBias = 0.0F;
      ctx->Pixel.MapColorFlag = GL_FALSE;
      /* XXX more state */
      ctx->NewState |=_NEW_PIXEL;
   }

   if (state & MESA_META_RASTERIZATION) {
      save->FrontPolygonMode = ctx->Polygon.FrontMode;
      save->BackPolygonMode = ctx->Polygon.BackMode;
      save->PolygonOffset = ctx->Polygon.OffsetFill;
      save->PolygonSmooth = ctx->Polygon.SmoothFlag;
      save->PolygonStipple = ctx->Polygon.StippleFlag;
      save->PolygonCull = ctx->Polygon.CullFlag;
      _mesa_PolygonMode(GL_FRONT_AND_BACK, GL_FILL);
      _mesa_set_enable(ctx, GL_POLYGON_OFFSET_FILL, GL_FALSE);
      _mesa_set_enable(ctx, GL_POLYGON_SMOOTH, GL_FALSE);
      _mesa_set_enable(ctx, GL_POLYGON_STIPPLE, GL_FALSE);
      _mesa_set_enable(ctx, GL_CULL_FACE, GL_FALSE);
   }

   if (state & MESA_META_SCISSOR) {
      save->Scissor = ctx->Scissor; /* struct copy */
      _mesa_set_enable(ctx, GL_SCISSOR_TEST, GL_FALSE);
   }

   if (state & MESA_META_SHADER) {
      int i;

      if (ctx->Extensions.ARB_vertex_program) {
         save->VertexProgramEnabled = ctx->VertexProgram.Enabled;
         _mesa_reference_vertprog(ctx, &save->VertexProgram,
				  ctx->VertexProgram.Current);
         _mesa_set_enable(ctx, GL_VERTEX_PROGRAM_ARB, GL_FALSE);
      }

      if (ctx->Extensions.ARB_fragment_program) {
         save->FragmentProgramEnabled = ctx->FragmentProgram.Enabled;
         _mesa_reference_fragprog(ctx, &save->FragmentProgram,
				  ctx->FragmentProgram.Current);
         _mesa_set_enable(ctx, GL_FRAGMENT_PROGRAM_ARB, GL_FALSE);
      }

      if (ctx->Extensions.ATI_fragment_shader) {
         save->ATIFragmentShaderEnabled = ctx->ATIFragmentShader.Enabled;
         _mesa_set_enable(ctx, GL_FRAGMENT_SHADER_ATI, GL_FALSE);
      }

      if (ctx->Pipeline.Current) {
         _mesa_reference_pipeline_object(ctx, &save->Pipeline,
                                         ctx->Pipeline.Current);
         _mesa_BindProgramPipeline(0);
      }

      /* Save the shader state from ctx->Shader (instead of ctx->_Shader) so
       * that we don't have to worry about the current pipeline state.
       */
      for (i = 0; i <= MESA_SHADER_FRAGMENT; i++) {
         _mesa_reference_shader_program(ctx, &save->Shader[i],
                                        ctx->Shader.CurrentProgram[i]);
      }
      _mesa_reference_shader_program(ctx, &save->ActiveShader,
                                     ctx->Shader.ActiveProgram);

      _mesa_UseProgram(0);
   }

   if (state & MESA_META_STENCIL_TEST) {
      save->Stencil = ctx->Stencil; /* struct copy */
      if (ctx->Stencil.Enabled)
         _mesa_set_enable(ctx, GL_STENCIL_TEST, GL_FALSE);
      /* NOTE: other stencil state not reset */
   }

   if (state & MESA_META_TEXTURE) {
      GLuint u, tgt;

      save->ActiveUnit = ctx->Texture.CurrentUnit;
      save->ClientActiveUnit = ctx->Array.ActiveTexture;
      save->EnvMode = ctx->Texture.Unit[0].EnvMode;

      /* Disable all texture units */
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
         save->TexEnabled[u] = ctx->Texture.Unit[u].Enabled;
         save->TexGenEnabled[u] = ctx->Texture.Unit[u].TexGenEnabled;
         if (ctx->Texture.Unit[u].Enabled ||
             ctx->Texture.Unit[u].TexGenEnabled) {
            _mesa_ActiveTexture(GL_TEXTURE0 + u);
            _mesa_set_enable(ctx, GL_TEXTURE_2D, GL_FALSE);
            if (ctx->Extensions.ARB_texture_cube_map)
               _mesa_set_enable(ctx, GL_TEXTURE_CUBE_MAP, GL_FALSE);

            _mesa_set_enable(ctx, GL_TEXTURE_1D, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_3D, GL_FALSE);
            if (ctx->Extensions.NV_texture_rectangle)
               _mesa_set_enable(ctx, GL_TEXTURE_RECTANGLE, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_GEN_S, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_GEN_T, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_GEN_R, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_GEN_Q, GL_FALSE);
         }
      }

      /* save current texture objects for unit[0] only */
      for (tgt = 0; tgt < NUM_TEXTURE_TARGETS; tgt++) {
         _mesa_reference_texobj(&save->CurrentTexture[tgt],
                                ctx->Texture.Unit[0].CurrentTex[tgt]);
      }

      /* set defaults for unit[0] */
      _mesa_ActiveTexture(GL_TEXTURE0);
      _mesa_ClientActiveTexture(GL_TEXTURE0);
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
   }

   if (state & MESA_META_TRANSFORM) {
      GLuint activeTexture = ctx->Texture.CurrentUnit;
      memcpy(save->ModelviewMatrix, ctx->ModelviewMatrixStack.Top->m,
             16 * sizeof(GLfloat));
      memcpy(save->ProjectionMatrix, ctx->ProjectionMatrixStack.Top->m,
             16 * sizeof(GLfloat));
      memcpy(save->TextureMatrix, ctx->TextureMatrixStack[0].Top->m,
             16 * sizeof(GLfloat));
      save->MatrixMode = ctx->Transform.MatrixMode;
      /* set 1:1 vertex:pixel coordinate transform */
      _mesa_ActiveTexture(GL_TEXTURE0);
      _mesa_MatrixMode(GL_TEXTURE);
      _mesa_LoadIdentity();
      _mesa_ActiveTexture(GL_TEXTURE0 + activeTexture);
      _mesa_MatrixMode(GL_MODELVIEW);
      _mesa_LoadIdentity();
      _mesa_MatrixMode(GL_PROJECTION);
      _mesa_LoadIdentity();

      /* glOrtho with width = 0 or height = 0 generates GL_INVALID_VALUE.
       * This can occur when there is no draw buffer.
       */
      if (ctx->DrawBuffer->Width != 0 && ctx->DrawBuffer->Height != 0)
         _mesa_Ortho(0.0, ctx->DrawBuffer->Width,
                     0.0, ctx->DrawBuffer->Height,
                     -1.0, 1.0);
   }

   if (state & MESA_META_CLIP) {
      save->ClipPlanesEnabled = ctx->Transform.ClipPlanesEnabled;
      if (ctx->Transform.ClipPlanesEnabled) {
         GLuint i;
         for (i = 0; i < ctx->Const.MaxClipPlanes; i++) {
            _mesa_set_enable(ctx, GL_CLIP_PLANE0 + i, GL_FALSE);
         }
      }
   }

   if (state & MESA_META_VERTEX) {
      /* save vertex array object state */
      _mesa_reference_vao(ctx, &save->VAO,
                                   ctx->Array.VAO);
      _mesa_reference_buffer_object(ctx, &save->ArrayBufferObj,
                                    ctx->Array.ArrayBufferObj);
      /* set some default state? */
   }

   if (state & MESA_META_VIEWPORT) {
      /* save viewport state */
      save->ViewportX = ctx->ViewportArray[0].X;
      save->ViewportY = ctx->ViewportArray[0].Y;
      save->ViewportW = ctx->ViewportArray[0].Width;
      save->ViewportH = ctx->ViewportArray[0].Height;
      /* set viewport to match window size */
      if (ctx->ViewportArray[0].X != 0 ||
          ctx->ViewportArray[0].Y != 0 ||
          ctx->ViewportArray[0].Width != (float) ctx->DrawBuffer->Width ||
          ctx->ViewportArray[0].Height != (float) ctx->DrawBuffer->Height) {
         _mesa_set_viewport(ctx, 0, 0, 0,
                            ctx->DrawBuffer->Width, ctx->DrawBuffer->Height);
      }
      /* save depth range state */
      save->DepthNear = ctx->ViewportArray[0].Near;
      save->DepthFar = ctx->ViewportArray[0].Far;
      /* set depth range to default */
      _mesa_DepthRange(0.0, 1.0);
   }

   if (state & MESA_META_CLAMP_FRAGMENT_COLOR) {
      save->ClampFragmentColor = ctx->Color.ClampFragmentColor;

      /* Generally in here we want to do clamping according to whether
       * it's for the pixel path (ClampFragmentColor is GL_TRUE),
       * regardless of the internal implementation of the metaops.
       */
      if (ctx->Color.ClampFragmentColor != GL_TRUE &&
          ctx->Extensions.ARB_color_buffer_float)
	 _mesa_ClampColor(GL_CLAMP_FRAGMENT_COLOR, GL_FALSE);
   }

   if (state & MESA_META_CLAMP_VERTEX_COLOR) {
      save->ClampVertexColor = ctx->Light.ClampVertexColor;

      /* Generally in here we never want vertex color clamping --
       * result clamping is only dependent on fragment clamping.
       */
      if (ctx->Extensions.ARB_color_buffer_float)
         _mesa_ClampColor(GL_CLAMP_VERTEX_COLOR, GL_FALSE);
   }

   if (state & MESA_META_CONDITIONAL_RENDER) {
      save->CondRenderQuery = ctx->Query.CondRenderQuery;
      save->CondRenderMode = ctx->Query.CondRenderMode;

      if (ctx->Query.CondRenderQuery)
	 _mesa_EndConditionalRender();
   }

   if (state & MESA_META_SELECT_FEEDBACK) {
      save->RenderMode = ctx->RenderMode;
      if (ctx->RenderMode == GL_SELECT) {
	 save->Select = ctx->Select; /* struct copy */
	 _mesa_RenderMode(GL_RENDER);
      } else if (ctx->RenderMode == GL_FEEDBACK) {
	 save->Feedback = ctx->Feedback; /* struct copy */
	 _mesa_RenderMode(GL_RENDER);
      }
   }

   if (state & MESA_META_MULTISAMPLE) {
      save->Multisample = ctx->Multisample; /* struct copy */

      if (ctx->Multisample.Enabled)
         _mesa_set_multisample(ctx, GL_FALSE);
      if (ctx->Multisample.SampleCoverage)
         _mesa_set_enable(ctx, GL_SAMPLE_COVERAGE, GL_FALSE);
      if (ctx->Multisample.SampleAlphaToCoverage)
         _mesa_set_enable(ctx, GL_SAMPLE_ALPHA_TO_COVERAGE, GL_FALSE);
      if (ctx->Multisample.SampleAlphaToOne)
         _mesa_set_enable(ctx, GL_SAMPLE_ALPHA_TO_ONE, GL_FALSE);
      if (ctx->Multisample.SampleShading)
         _mesa_set_enable(ctx, GL_SAMPLE_SHADING, GL_FALSE);
      if (ctx->Multisample.SampleMask)
         _mesa_set_enable(ctx, GL_SAMPLE_MASK, GL_FALSE);
   }

   if (state & MESA_META_FRAMEBUFFER_SRGB) {
      save->sRGBEnabled = ctx->Color.sRGBEnabled;
      if (ctx->Color.sRGBEnabled)
         _mesa_set_framebuffer_srgb(ctx, GL_FALSE);
   }

   if (state & MESA_META_DRAW_BUFFERS) {
      int buf, real_color_buffers = 0;
      memset(save->ColorDrawBuffers, 0, sizeof(save->ColorDrawBuffers));

      for (buf = 0; buf < ctx->Const.MaxDrawBuffers; buf++) {
         int buf_index = ctx->DrawBuffer->_ColorDrawBufferIndexes[buf];
         if (buf_index == -1)
            continue;

         save->ColorDrawBuffers[buf] =
            gl_buffer_index_to_drawbuffers_enum(buf_index);

         if (++real_color_buffers >= ctx->DrawBuffer->_NumColorDrawBuffers)
            break;
      }
   }

   /* misc */
   {
      save->Lighting = ctx->Light.Enabled;
      if (ctx->Light.Enabled)
         _mesa_set_enable(ctx, GL_LIGHTING, GL_FALSE);
      save->RasterDiscard = ctx->RasterDiscard;
      if (ctx->RasterDiscard)
         _mesa_set_enable(ctx, GL_RASTERIZER_DISCARD, GL_FALSE);

      save->DrawBufferName = ctx->DrawBuffer->Name;
      save->ReadBufferName = ctx->ReadBuffer->Name;
      save->RenderbufferName = (ctx->CurrentRenderbuffer ?
                                ctx->CurrentRenderbuffer->Name : 0);
   }
}


/**
 * Leave meta state.  This is like a light-weight version of glPopAttrib().
 */
void
_mesa_meta_end(struct gl_context *ctx)
{
   struct save_state *save = &ctx->Meta->Save[ctx->Meta->SaveStackDepth - 1];
   const GLbitfield state = save->SavedState;
   int i;

   /* After starting a new occlusion query, initialize the results to the
    * values saved previously. The driver will then continue to increment
    * these values.
    */
   if (state & MESA_META_OCCLUSION_QUERY) {
      if (save->CurrentOcclusionObject) {
         _mesa_BeginQuery(save->CurrentOcclusionObject->Target,
                          save->CurrentOcclusionObject->Id);
         ctx->Query.CurrentOcclusionObject->Result = save->CurrentOcclusionObject->Result;
      }
   }

   if (state & MESA_META_ALPHA_TEST) {
      if (ctx->Color.AlphaEnabled != save->AlphaEnabled)
         _mesa_set_enable(ctx, GL_ALPHA_TEST, save->AlphaEnabled);
      _mesa_AlphaFunc(save->AlphaFunc, save->AlphaRef);
   }

   if (state & MESA_META_BLEND) {
      if (ctx->Color.BlendEnabled != save->BlendEnabled) {
         if (ctx->Extensions.EXT_draw_buffers2) {
            GLuint i;
            for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
               _mesa_set_enablei(ctx, GL_BLEND, i, (save->BlendEnabled >> i) & 1);
            }
         }
         else {
            _mesa_set_enable(ctx, GL_BLEND, (save->BlendEnabled & 1));
         }
      }
      if (ctx->Color.ColorLogicOpEnabled != save->ColorLogicOpEnabled)
         _mesa_set_enable(ctx, GL_COLOR_LOGIC_OP, save->ColorLogicOpEnabled);
   }

   if (state & MESA_META_COLOR_MASK) {
      GLuint i;
      for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
         if (!TEST_EQ_4V(ctx->Color.ColorMask[i], save->ColorMask[i])) {
            if (i == 0) {
               _mesa_ColorMask(save->ColorMask[i][0], save->ColorMask[i][1],
                               save->ColorMask[i][2], save->ColorMask[i][3]);
            }
            else {
               _mesa_ColorMaski(i,
                                      save->ColorMask[i][0],
                                      save->ColorMask[i][1],
                                      save->ColorMask[i][2],
                                      save->ColorMask[i][3]);
            }
         }
      }
   }

   if (state & MESA_META_DEPTH_TEST) {
      if (ctx->Depth.Test != save->Depth.Test)
         _mesa_set_enable(ctx, GL_DEPTH_TEST, save->Depth.Test);
      _mesa_DepthFunc(save->Depth.Func);
      _mesa_DepthMask(save->Depth.Mask);
   }

   if (state & MESA_META_FOG) {
      _mesa_set_enable(ctx, GL_FOG, save->Fog);
   }

   if (state & MESA_META_PIXEL_STORE) {
      ctx->Pack = save->Pack;
      ctx->Unpack = save->Unpack;
   }

   if (state & MESA_META_PIXEL_TRANSFER) {
      ctx->Pixel.RedScale = save->RedScale;
      ctx->Pixel.RedBias = save->RedBias;
      ctx->Pixel.GreenScale = save->GreenScale;
      ctx->Pixel.GreenBias = save->GreenBias;
      ctx->Pixel.BlueScale = save->BlueScale;
      ctx->Pixel.BlueBias = save->BlueBias;
      ctx->Pixel.AlphaScale = save->AlphaScale;
      ctx->Pixel.AlphaBias = save->AlphaBias;
      ctx->Pixel.MapColorFlag = save->MapColorFlag;
      /* XXX more state */
      ctx->NewState |=_NEW_PIXEL;
   }

   if (state & MESA_META_RASTERIZATION) {
      _mesa_PolygonMode(GL_FRONT, save->FrontPolygonMode);
      _mesa_PolygonMode(GL_BACK, save->BackPolygonMode);
      _mesa_set_enable(ctx, GL_POLYGON_STIPPLE, save->PolygonStipple);
      _mesa_set_enable(ctx, GL_POLYGON_SMOOTH, save->PolygonSmooth);
      _mesa_set_enable(ctx, GL_POLYGON_OFFSET_FILL, save->PolygonOffset);
      _mesa_set_enable(ctx, GL_CULL_FACE, save->PolygonCull);
   }

   if (state & MESA_META_SCISSOR) {
      unsigned i;

      for (i = 0; i < ctx->Const.MaxViewports; i++) {
         _mesa_set_scissor(ctx, i,
                           save->Scissor.ScissorArray[i].X,
                           save->Scissor.ScissorArray[i].Y,
                           save->Scissor.ScissorArray[i].Width,
                           save->Scissor.ScissorArray[i].Height);
         _mesa_set_enablei(ctx, GL_SCISSOR_TEST, i,
                           (save->Scissor.EnableFlags >> i) & 1);
      }
   }

   if (state & MESA_META_SHADER) {
      static const GLenum targets[] = {
         GL_VERTEX_SHADER,
         GL_GEOMETRY_SHADER,
         GL_FRAGMENT_SHADER,
      };

      bool any_shader;

      if (ctx->Extensions.ARB_vertex_program) {
         _mesa_set_enable(ctx, GL_VERTEX_PROGRAM_ARB,
                          save->VertexProgramEnabled);
         _mesa_reference_vertprog(ctx, &ctx->VertexProgram.Current, 
                                  save->VertexProgram);
	 _mesa_reference_vertprog(ctx, &save->VertexProgram, NULL);
      }

      if (ctx->Extensions.ARB_fragment_program) {
         _mesa_set_enable(ctx, GL_FRAGMENT_PROGRAM_ARB,
                          save->FragmentProgramEnabled);
         _mesa_reference_fragprog(ctx, &ctx->FragmentProgram.Current,
                                  save->FragmentProgram);
	 _mesa_reference_fragprog(ctx, &save->FragmentProgram, NULL);
      }

      if (ctx->Extensions.ATI_fragment_shader) {
         _mesa_set_enable(ctx, GL_FRAGMENT_SHADER_ATI,
                          save->ATIFragmentShaderEnabled);
      }

      any_shader = false;
      for (i = 0; i <= MESA_SHADER_FRAGMENT; i++) {
         /* It is safe to call _mesa_use_shader_program even if the extension
          * necessary for that program state is not supported.  In that case,
          * the saved program object must be NULL and the currently bound
          * program object must be NULL.  _mesa_use_shader_program is a no-op
          * in that case.
          */
         _mesa_use_shader_program(ctx, targets[i],
                                  save->Shader[i],
                                  &ctx->Shader);

         /* Do this *before* killing the reference. :)
          */
         if (save->Shader[i] != NULL)
            any_shader = true;

         _mesa_reference_shader_program(ctx, &save->Shader[i], NULL);
      }

      _mesa_reference_shader_program(ctx, &ctx->Shader.ActiveProgram,
                                     save->ActiveShader);
      _mesa_reference_shader_program(ctx, &save->ActiveShader, NULL);

      /* If there were any stages set with programs, use ctx->Shader as the
       * current shader state.  Otherwise, use Pipeline.Default.  The pipeline
       * hasn't been restored yet, and that may modify ctx->_Shader further.
       */
      if (any_shader)
         _mesa_reference_pipeline_object(ctx, &ctx->_Shader,
                                         &ctx->Shader);
      else
         _mesa_reference_pipeline_object(ctx, &ctx->_Shader,
                                         ctx->Pipeline.Default);

      if (save->Pipeline) {
         _mesa_bind_pipeline(ctx, save->Pipeline);

         _mesa_reference_pipeline_object(ctx, &save->Pipeline, NULL);
      }
   }

   if (state & MESA_META_STENCIL_TEST) {
      const struct gl_stencil_attrib *stencil = &save->Stencil;

      _mesa_set_enable(ctx, GL_STENCIL_TEST, stencil->Enabled);
      _mesa_ClearStencil(stencil->Clear);
      if (ctx->Extensions.EXT_stencil_two_side) {
         _mesa_set_enable(ctx, GL_STENCIL_TEST_TWO_SIDE_EXT,
                          stencil->TestTwoSide);
         _mesa_ActiveStencilFaceEXT(stencil->ActiveFace
                                    ? GL_BACK : GL_FRONT);
      }
      /* front state */
      _mesa_StencilFuncSeparate(GL_FRONT,
                                stencil->Function[0],
                                stencil->Ref[0],
                                stencil->ValueMask[0]);
      _mesa_StencilMaskSeparate(GL_FRONT, stencil->WriteMask[0]);
      _mesa_StencilOpSeparate(GL_FRONT, stencil->FailFunc[0],
                              stencil->ZFailFunc[0],
                              stencil->ZPassFunc[0]);
      /* back state */
      _mesa_StencilFuncSeparate(GL_BACK,
                                stencil->Function[1],
                                stencil->Ref[1],
                                stencil->ValueMask[1]);
      _mesa_StencilMaskSeparate(GL_BACK, stencil->WriteMask[1]);
      _mesa_StencilOpSeparate(GL_BACK, stencil->FailFunc[1],
                              stencil->ZFailFunc[1],
                              stencil->ZPassFunc[1]);
   }

   if (state & MESA_META_TEXTURE) {
      GLuint u, tgt;

      ASSERT(ctx->Texture.CurrentUnit == 0);

      /* restore texenv for unit[0] */
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, save->EnvMode);

      /* restore texture objects for unit[0] only */
      for (tgt = 0; tgt < NUM_TEXTURE_TARGETS; tgt++) {
	 if (ctx->Texture.Unit[0].CurrentTex[tgt] != save->CurrentTexture[tgt]) {
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    _mesa_reference_texobj(&ctx->Texture.Unit[0].CurrentTex[tgt],
				   save->CurrentTexture[tgt]);
	 }
         _mesa_reference_texobj(&save->CurrentTexture[tgt], NULL);
      }

      /* Restore fixed function texture enables, texgen */
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
         if (ctx->Texture.Unit[u].Enabled != save->TexEnabled[u]) {
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            ctx->Texture.Unit[u].Enabled = save->TexEnabled[u];
         }

         if (ctx->Texture.Unit[u].TexGenEnabled != save->TexGenEnabled[u]) {
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            ctx->Texture.Unit[u].TexGenEnabled = save->TexGenEnabled[u];
         }
      }

      /* restore current unit state */
      _mesa_ActiveTexture(GL_TEXTURE0 + save->ActiveUnit);
      _mesa_ClientActiveTexture(GL_TEXTURE0 + save->ClientActiveUnit);
   }

   if (state & MESA_META_TRANSFORM) {
      GLuint activeTexture = ctx->Texture.CurrentUnit;
      _mesa_ActiveTexture(GL_TEXTURE0);
      _mesa_MatrixMode(GL_TEXTURE);
      _mesa_LoadMatrixf(save->TextureMatrix);
      _mesa_ActiveTexture(GL_TEXTURE0 + activeTexture);

      _mesa_MatrixMode(GL_MODELVIEW);
      _mesa_LoadMatrixf(save->ModelviewMatrix);

      _mesa_MatrixMode(GL_PROJECTION);
      _mesa_LoadMatrixf(save->ProjectionMatrix);

      _mesa_MatrixMode(save->MatrixMode);
   }

   if (state & MESA_META_CLIP) {
      if (save->ClipPlanesEnabled) {
         GLuint i;
         for (i = 0; i < ctx->Const.MaxClipPlanes; i++) {
            if (save->ClipPlanesEnabled & (1 << i)) {
               _mesa_set_enable(ctx, GL_CLIP_PLANE0 + i, GL_TRUE);
            }
         }
      }
   }

   if (state & MESA_META_VERTEX) {
      /* restore vertex buffer object */
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, save->ArrayBufferObj->Name);
      _mesa_reference_buffer_object(ctx, &save->ArrayBufferObj, NULL);

      /* restore vertex array object */
      _mesa_BindVertexArray(save->VAO->Name);
      _mesa_reference_vao(ctx, &save->VAO, NULL);
   }

   if (state & MESA_META_VIEWPORT) {
      if (save->ViewportX != ctx->ViewportArray[0].X ||
          save->ViewportY != ctx->ViewportArray[0].Y ||
          save->ViewportW != ctx->ViewportArray[0].Width ||
          save->ViewportH != ctx->ViewportArray[0].Height) {
         _mesa_set_viewport(ctx, 0, save->ViewportX, save->ViewportY,
                            save->ViewportW, save->ViewportH);
      }
      _mesa_DepthRange(save->DepthNear, save->DepthFar);
   }

   if (state & MESA_META_CLAMP_FRAGMENT_COLOR &&
       ctx->Extensions.ARB_color_buffer_float) {
      _mesa_ClampColor(GL_CLAMP_FRAGMENT_COLOR, save->ClampFragmentColor);
   }

   if (state & MESA_META_CLAMP_VERTEX_COLOR &&
       ctx->Extensions.ARB_color_buffer_float) {
      _mesa_ClampColor(GL_CLAMP_VERTEX_COLOR, save->ClampVertexColor);
   }

   if (state & MESA_META_CONDITIONAL_RENDER) {
      if (save->CondRenderQuery)
	 _mesa_BeginConditionalRender(save->CondRenderQuery->Id,
				      save->CondRenderMode);
   }

   if (state & MESA_META_SELECT_FEEDBACK) {
      if (save->RenderMode == GL_SELECT) {
	 _mesa_RenderMode(GL_SELECT);
	 ctx->Select = save->Select;
      } else if (save->RenderMode == GL_FEEDBACK) {
	 _mesa_RenderMode(GL_FEEDBACK);
	 ctx->Feedback = save->Feedback;
      }
   }

   if (state & MESA_META_MULTISAMPLE) {
      struct gl_multisample_attrib *ctx_ms = &ctx->Multisample;
      struct gl_multisample_attrib *save_ms = &save->Multisample;

      if (ctx_ms->Enabled != save_ms->Enabled)
         _mesa_set_multisample(ctx, save_ms->Enabled);
      if (ctx_ms->SampleCoverage != save_ms->SampleCoverage)
         _mesa_set_enable(ctx, GL_SAMPLE_COVERAGE, save_ms->SampleCoverage);
      if (ctx_ms->SampleAlphaToCoverage != save_ms->SampleAlphaToCoverage)
         _mesa_set_enable(ctx, GL_SAMPLE_ALPHA_TO_COVERAGE, save_ms->SampleAlphaToCoverage);
      if (ctx_ms->SampleAlphaToOne != save_ms->SampleAlphaToOne)
         _mesa_set_enable(ctx, GL_SAMPLE_ALPHA_TO_ONE, save_ms->SampleAlphaToOne);
      if (ctx_ms->SampleCoverageValue != save_ms->SampleCoverageValue ||
          ctx_ms->SampleCoverageInvert != save_ms->SampleCoverageInvert) {
         _mesa_SampleCoverage(save_ms->SampleCoverageValue,
                              save_ms->SampleCoverageInvert);
      }
      if (ctx_ms->SampleShading != save_ms->SampleShading)
         _mesa_set_enable(ctx, GL_SAMPLE_SHADING, save_ms->SampleShading);
      if (ctx_ms->SampleMask != save_ms->SampleMask)
         _mesa_set_enable(ctx, GL_SAMPLE_MASK, save_ms->SampleMask);
      if (ctx_ms->SampleMaskValue != save_ms->SampleMaskValue)
         _mesa_SampleMaski(0, save_ms->SampleMaskValue);
      if (ctx_ms->MinSampleShadingValue != save_ms->MinSampleShadingValue)
         _mesa_MinSampleShading(save_ms->MinSampleShadingValue);
   }

   if (state & MESA_META_FRAMEBUFFER_SRGB) {
      if (ctx->Color.sRGBEnabled != save->sRGBEnabled)
         _mesa_set_framebuffer_srgb(ctx, save->sRGBEnabled);
   }

   /* misc */
   if (save->Lighting) {
      _mesa_set_enable(ctx, GL_LIGHTING, GL_TRUE);
   }
   if (save->RasterDiscard) {
      _mesa_set_enable(ctx, GL_RASTERIZER_DISCARD, GL_TRUE);
   }
   if (save->TransformFeedbackNeedsResume)
      _mesa_ResumeTransformFeedback();

   if (ctx->DrawBuffer->Name != save->DrawBufferName)
      _mesa_BindFramebuffer(GL_DRAW_FRAMEBUFFER, save->DrawBufferName);

   if (ctx->ReadBuffer->Name != save->ReadBufferName)
      _mesa_BindFramebuffer(GL_READ_FRAMEBUFFER, save->ReadBufferName);

   if (!ctx->CurrentRenderbuffer ||
       ctx->CurrentRenderbuffer->Name != save->RenderbufferName)
      _mesa_BindRenderbuffer(GL_RENDERBUFFER, save->RenderbufferName);

   if (state & MESA_META_DRAW_BUFFERS) {
      _mesa_DrawBuffers(ctx->Const.MaxDrawBuffers, save->ColorDrawBuffers);
   }

   ctx->Meta->SaveStackDepth--;

   ctx->API = save->API;
}


/**
 * Determine whether Mesa is currently in a meta state.
 */
GLboolean
_mesa_meta_in_progress(struct gl_context *ctx)
{
   return ctx->Meta->SaveStackDepth != 0;
}


/**
 * Convert Z from a normalized value in the range [0, 1] to an object-space
 * Z coordinate in [-1, +1] so that drawing at the new Z position with the
 * default/identity ortho projection results in the original Z value.
 * Used by the meta-Clear, Draw/CopyPixels and Bitmap functions where the Z
 * value comes from the clear value or raster position.
 */
static INLINE GLfloat
invert_z(GLfloat normZ)
{
   GLfloat objZ = 1.0f - 2.0f * normZ;
   return objZ;
}


/**
 * One-time init for a temp_texture object.
 * Choose tex target, compute max tex size, etc.
 */
static void
init_temp_texture(struct gl_context *ctx, struct temp_texture *tex)
{
   /* prefer texture rectangle */
   if (_mesa_is_desktop_gl(ctx) && ctx->Extensions.NV_texture_rectangle) {
      tex->Target = GL_TEXTURE_RECTANGLE;
      tex->MaxSize = ctx->Const.MaxTextureRectSize;
      tex->NPOT = GL_TRUE;
   }
   else {
      /* use 2D texture, NPOT if possible */
      tex->Target = GL_TEXTURE_2D;
      tex->MaxSize = 1 << (ctx->Const.MaxTextureLevels - 1);
      tex->NPOT = ctx->Extensions.ARB_texture_non_power_of_two;
   }
   tex->MinSize = 16;  /* 16 x 16 at least */
   assert(tex->MaxSize > 0);

   _mesa_GenTextures(1, &tex->TexObj);
}

static void
cleanup_temp_texture(struct temp_texture *tex)
{
   if (!tex->TexObj)
     return;
   _mesa_DeleteTextures(1, &tex->TexObj);
   tex->TexObj = 0;
}


/**
 * Return pointer to temp_texture info for non-bitmap ops.
 * This does some one-time init if needed.
 */
struct temp_texture *
_mesa_meta_get_temp_texture(struct gl_context *ctx)
{
   struct temp_texture *tex = &ctx->Meta->TempTex;

   if (!tex->TexObj) {
      init_temp_texture(ctx, tex);
   }

   return tex;
}


/**
 * Return pointer to temp_texture info for _mesa_meta_bitmap().
 * We use a separate texture for bitmaps to reduce texture
 * allocation/deallocation.
 */
static struct temp_texture *
get_bitmap_temp_texture(struct gl_context *ctx)
{
   struct temp_texture *tex = &ctx->Meta->Bitmap.Tex;

   if (!tex->TexObj) {
      init_temp_texture(ctx, tex);
   }

   return tex;
}

/**
 * Return pointer to depth temp_texture.
 * This does some one-time init if needed.
 */
struct temp_texture *
_mesa_meta_get_temp_depth_texture(struct gl_context *ctx)
{
   struct temp_texture *tex = &ctx->Meta->Blit.depthTex;

   if (!tex->TexObj) {
      init_temp_texture(ctx, tex);
   }

   return tex;
}

/**
 * Compute the width/height of texture needed to draw an image of the
 * given size.  Return a flag indicating whether the current texture
 * can be re-used (glTexSubImage2D) or if a new texture needs to be
 * allocated (glTexImage2D).
 * Also, compute s/t texcoords for drawing.
 *
 * \return GL_TRUE if new texture is needed, GL_FALSE otherwise
 */
GLboolean
_mesa_meta_alloc_texture(struct temp_texture *tex,
                         GLsizei width, GLsizei height, GLenum intFormat)
{
   GLboolean newTex = GL_FALSE;

   ASSERT(width <= tex->MaxSize);
   ASSERT(height <= tex->MaxSize);

   if (width > tex->Width ||
       height > tex->Height ||
       intFormat != tex->IntFormat) {
      /* alloc new texture (larger or different format) */

      if (tex->NPOT) {
         /* use non-power of two size */
         tex->Width = MAX2(tex->MinSize, width);
         tex->Height = MAX2(tex->MinSize, height);
      }
      else {
         /* find power of two size */
         GLsizei w, h;
         w = h = tex->MinSize;
         while (w < width)
            w *= 2;
         while (h < height)
            h *= 2;
         tex->Width = w;
         tex->Height = h;
      }

      tex->IntFormat = intFormat;

      newTex = GL_TRUE;
   }

   /* compute texcoords */
   if (tex->Target == GL_TEXTURE_RECTANGLE) {
      tex->Sright = (GLfloat) width;
      tex->Ttop = (GLfloat) height;
   }
   else {
      tex->Sright = (GLfloat) width / tex->Width;
      tex->Ttop = (GLfloat) height / tex->Height;
   }

   return newTex;
}


/**
 * Setup/load texture for glCopyPixels or glBlitFramebuffer.
 */
void
_mesa_meta_setup_copypix_texture(struct gl_context *ctx,
                                 struct temp_texture *tex,
                                 GLint srcX, GLint srcY,
                                 GLsizei width, GLsizei height,
                                 GLenum intFormat,
                                 GLenum filter)
{
   bool newTex;

   _mesa_BindTexture(tex->Target, tex->TexObj);
   _mesa_TexParameteri(tex->Target, GL_TEXTURE_MIN_FILTER, filter);
   _mesa_TexParameteri(tex->Target, GL_TEXTURE_MAG_FILTER, filter);
   _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

   newTex = _mesa_meta_alloc_texture(tex, width, height, intFormat);

   /* copy framebuffer image to texture */
   if (newTex) {
      /* create new tex image */
      if (tex->Width == width && tex->Height == height) {
         /* create new tex with framebuffer data */
         _mesa_CopyTexImage2D(tex->Target, 0, tex->IntFormat,
                              srcX, srcY, width, height, 0);
      }
      else {
         /* create empty texture */
         _mesa_TexImage2D(tex->Target, 0, tex->IntFormat,
                          tex->Width, tex->Height, 0,
                          intFormat, GL_UNSIGNED_BYTE, NULL);
         /* load image */
         _mesa_CopyTexSubImage2D(tex->Target, 0,
                                 0, 0, srcX, srcY, width, height);
      }
   }
   else {
      /* replace existing tex image */
      _mesa_CopyTexSubImage2D(tex->Target, 0,
                              0, 0, srcX, srcY, width, height);
   }
}


/**
 * Setup/load texture for glDrawPixels.
 */
void
_mesa_meta_setup_drawpix_texture(struct gl_context *ctx,
                                 struct temp_texture *tex,
                                 GLboolean newTex,
                                 GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels)
{
   _mesa_BindTexture(tex->Target, tex->TexObj);
   _mesa_TexParameteri(tex->Target, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
   _mesa_TexParameteri(tex->Target, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
   _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

   /* copy pixel data to texture */
   if (newTex) {
      /* create new tex image */
      if (tex->Width == width && tex->Height == height) {
         /* create new tex and load image data */
         _mesa_TexImage2D(tex->Target, 0, tex->IntFormat,
                          tex->Width, tex->Height, 0, format, type, pixels);
      }
      else {
	 struct gl_buffer_object *save_unpack_obj = NULL;

	 _mesa_reference_buffer_object(ctx, &save_unpack_obj,
				       ctx->Unpack.BufferObj);
	 _mesa_BindBuffer(GL_PIXEL_UNPACK_BUFFER_ARB, 0);
         /* create empty texture */
         _mesa_TexImage2D(tex->Target, 0, tex->IntFormat,
                          tex->Width, tex->Height, 0, format, type, NULL);
	 if (save_unpack_obj != NULL)
	    _mesa_BindBuffer(GL_PIXEL_UNPACK_BUFFER_ARB,
				save_unpack_obj->Name);
         /* load image */
         _mesa_TexSubImage2D(tex->Target, 0,
                             0, 0, width, height, format, type, pixels);
      }
   }
   else {
      /* replace existing tex image */
      _mesa_TexSubImage2D(tex->Target, 0,
                          0, 0, width, height, format, type, pixels);
   }
}

void
_mesa_meta_setup_ff_tnl_for_blit(GLuint *VAO, GLuint *VBO,
                                 unsigned texcoord_size)
{
   _mesa_meta_setup_vertex_objects(VAO, VBO, false, 2, texcoord_size, 0);

   /* setup projection matrix */
   _mesa_MatrixMode(GL_PROJECTION);
   _mesa_LoadIdentity();
}

/**
 * Meta implementation of ctx->Driver.Clear() in terms of polygon rendering.
 */
void
_mesa_meta_Clear(struct gl_context *ctx, GLbitfield buffers)
{
   meta_clear(ctx, buffers, false);
}

void
_mesa_meta_glsl_Clear(struct gl_context *ctx, GLbitfield buffers)
{
   meta_clear(ctx, buffers, true);
}

static void
meta_glsl_clear_init(struct gl_context *ctx, struct clear_state *clear)
{
   const char *vs_source =
      "attribute vec4 position;\n"
      "void main()\n"
      "{\n"
      "   gl_Position = position;\n"
      "}\n";
   const char *gs_source =
      "#version 150\n"
      "layout(triangles) in;\n"
      "layout(triangle_strip, max_vertices = 4) out;\n"
      "uniform int layer;\n"
      "void main()\n"
      "{\n"
      "  for (int i = 0; i < 3; i++) {\n"
      "    gl_Layer = layer;\n"
      "    gl_Position = gl_in[i].gl_Position;\n"
      "    EmitVertex();\n"
      "  }\n"
      "}\n";
   const char *fs_source =
      "uniform vec4 color;\n"
      "void main()\n"
      "{\n"
      "   gl_FragColor = color;\n"
      "}\n";
   GLuint vs, gs = 0, fs;
   bool has_integer_textures;

   _mesa_meta_setup_vertex_objects(&clear->VAO, &clear->VBO, true, 3, 0, 0);

   if (clear->ShaderProg != 0)
      return;

   vs = _mesa_CreateShader(GL_VERTEX_SHADER);
   _mesa_ShaderSource(vs, 1, &vs_source, NULL);
   _mesa_CompileShader(vs);

   if (_mesa_has_geometry_shaders(ctx)) {
      gs = _mesa_CreateShader(GL_GEOMETRY_SHADER);
      _mesa_ShaderSource(gs, 1, &gs_source, NULL);
      _mesa_CompileShader(gs);
   }

   fs = _mesa_CreateShader(GL_FRAGMENT_SHADER);
   _mesa_ShaderSource(fs, 1, &fs_source, NULL);
   _mesa_CompileShader(fs);

   clear->ShaderProg = _mesa_CreateProgram();
   _mesa_AttachShader(clear->ShaderProg, fs);
   _mesa_DeleteShader(fs);
   if (gs != 0)
      _mesa_AttachShader(clear->ShaderProg, gs);
   _mesa_AttachShader(clear->ShaderProg, vs);
   _mesa_DeleteShader(vs);
   _mesa_BindAttribLocation(clear->ShaderProg, 0, "position");
   _mesa_LinkProgram(clear->ShaderProg);

   clear->ColorLocation = _mesa_GetUniformLocation(clear->ShaderProg,
						      "color");
   if (gs != 0) {
      clear->LayerLocation = _mesa_GetUniformLocation(clear->ShaderProg,
						      "layer");
   }

   has_integer_textures = _mesa_is_gles3(ctx) ||
      (_mesa_is_desktop_gl(ctx) && ctx->Const.GLSLVersion >= 130);

   if (has_integer_textures) {
      void *shader_source_mem_ctx = ralloc_context(NULL);
      const char *vs_int_source =
         ralloc_asprintf(shader_source_mem_ctx,
                         "#version 130\n"
                         "in vec4 position;\n"
                         "void main()\n"
                         "{\n"
                         "   gl_Position = position;\n"
                         "}\n");
      const char *fs_int_source =
         ralloc_asprintf(shader_source_mem_ctx,
                         "#version 130\n"
                         "uniform ivec4 color;\n"
                         "out ivec4 out_color;\n"
                         "\n"
                         "void main()\n"
                         "{\n"
                         "   out_color = color;\n"
                         "}\n");

      vs = _mesa_meta_compile_shader_with_debug(ctx, GL_VERTEX_SHADER,
                                                vs_int_source);
      fs = _mesa_meta_compile_shader_with_debug(ctx, GL_FRAGMENT_SHADER,
                                                fs_int_source);
      ralloc_free(shader_source_mem_ctx);

      clear->IntegerShaderProg = _mesa_CreateProgram();
      _mesa_AttachShader(clear->IntegerShaderProg, fs);
      _mesa_DeleteShader(fs);
      if (gs != 0)
         _mesa_AttachShader(clear->IntegerShaderProg, gs);
      _mesa_AttachShader(clear->IntegerShaderProg, vs);
      _mesa_DeleteShader(vs);
      _mesa_BindAttribLocation(clear->IntegerShaderProg, 0, "position");

      /* Note that user-defined out attributes get automatically assigned
       * locations starting from 0, so we don't need to explicitly
       * BindFragDataLocation to 0.
       */

      _mesa_ObjectLabel(GL_PROGRAM, clear->IntegerShaderProg, -1,
                        "integer clear");
      _mesa_meta_link_program_with_debug(ctx, clear->IntegerShaderProg);

      clear->IntegerColorLocation =
	 _mesa_GetUniformLocation(clear->IntegerShaderProg, "color");
      if (gs != 0) {
         clear->IntegerLayerLocation =
            _mesa_GetUniformLocation(clear->IntegerShaderProg, "layer");
      }
   }
   if (gs != 0)
      _mesa_DeleteShader(gs);
}

static void
meta_glsl_clear_cleanup(struct clear_state *clear)
{
   if (clear->VAO == 0)
      return;
   _mesa_DeleteVertexArrays(1, &clear->VAO);
   clear->VAO = 0;
   _mesa_DeleteBuffers(1, &clear->VBO);
   clear->VBO = 0;
   _mesa_DeleteProgram(clear->ShaderProg);
   clear->ShaderProg = 0;

   if (clear->IntegerShaderProg) {
      _mesa_DeleteProgram(clear->IntegerShaderProg);
      clear->IntegerShaderProg = 0;
   }
}

/**
 * Given a bitfield of BUFFER_BIT_x draw buffers, call glDrawBuffers to
 * set GL to only draw to those buffers.
 *
 * Since the bitfield has no associated order, the assignment of draw buffer
 * indices to color attachment indices is rather arbitrary.
 */
static void
drawbuffers_from_bitfield(GLbitfield bits)
{
   GLenum enums[MAX_DRAW_BUFFERS];
   int i = 0;
   int n;

   /* This function is only legal for color buffer bitfields. */
   assert((bits & ~BUFFER_BITS_COLOR) == 0);

   /* Make sure we don't overflow any arrays. */
   assert(_mesa_bitcount(bits) <= MAX_DRAW_BUFFERS);

   enums[0] = GL_NONE;

   if (bits & BUFFER_BIT_FRONT_LEFT)
      enums[i++] = GL_FRONT_LEFT;

   if (bits & BUFFER_BIT_FRONT_RIGHT)
      enums[i++] = GL_FRONT_RIGHT;

   if (bits & BUFFER_BIT_BACK_LEFT)
      enums[i++] = GL_BACK_LEFT;

   if (bits & BUFFER_BIT_BACK_RIGHT)
      enums[i++] = GL_BACK_RIGHT;

   for (n = 0; n < MAX_COLOR_ATTACHMENTS; n++) {
      if (bits & (1 << (BUFFER_COLOR0 + n)))
         enums[i++] = GL_COLOR_ATTACHMENT0 + n;
   }

   _mesa_DrawBuffers(i, enums);
}

/**
 * Meta implementation of ctx->Driver.Clear() in terms of polygon rendering.
 */
static void
meta_clear(struct gl_context *ctx, GLbitfield buffers, bool glsl)
{
   struct clear_state *clear = &ctx->Meta->Clear;
   GLbitfield metaSave;
   const GLuint stencilMax = (1 << ctx->DrawBuffer->Visual.stencilBits) - 1;
   struct gl_framebuffer *fb = ctx->DrawBuffer;
   float x0, y0, x1, y1, z;
   struct vertex verts[4];
   int i;

   metaSave = (MESA_META_ALPHA_TEST |
	       MESA_META_BLEND |
	       MESA_META_DEPTH_TEST |
	       MESA_META_RASTERIZATION |
	       MESA_META_SHADER |
	       MESA_META_STENCIL_TEST |
	       MESA_META_VERTEX |
	       MESA_META_VIEWPORT |
	       MESA_META_CLIP |
	       MESA_META_CLAMP_FRAGMENT_COLOR |
               MESA_META_MULTISAMPLE |
               MESA_META_OCCLUSION_QUERY);

   if (!glsl) {
      metaSave |= MESA_META_FOG |
                  MESA_META_PIXEL_TRANSFER |
                  MESA_META_TRANSFORM |
                  MESA_META_TEXTURE |
                  MESA_META_CLAMP_VERTEX_COLOR |
                  MESA_META_SELECT_FEEDBACK;
   }

   if (buffers & BUFFER_BITS_COLOR) {
      metaSave |= MESA_META_DRAW_BUFFERS;
   } else {
      /* We'll use colormask to disable color writes.  Otherwise,
       * respect color mask
       */
      metaSave |= MESA_META_COLOR_MASK;
   }

   _mesa_meta_begin(ctx, metaSave);

   if (glsl) {
      meta_glsl_clear_init(ctx, clear);

      x0 = ((float) fb->_Xmin / fb->Width)  * 2.0f - 1.0f;
      y0 = ((float) fb->_Ymin / fb->Height) * 2.0f - 1.0f;
      x1 = ((float) fb->_Xmax / fb->Width)  * 2.0f - 1.0f;
      y1 = ((float) fb->_Ymax / fb->Height) * 2.0f - 1.0f;
      z = -invert_z(ctx->Depth.Clear);
   } else {
      _mesa_meta_setup_vertex_objects(&clear->VAO, &clear->VBO, false, 3, 0, 4);

      x0 = (float) fb->_Xmin;
      y0 = (float) fb->_Ymin;
      x1 = (float) fb->_Xmax;
      y1 = (float) fb->_Ymax;
      z = invert_z(ctx->Depth.Clear);
   }

   if (fb->_IntegerColor) {
      assert(glsl);
      _mesa_UseProgram(clear->IntegerShaderProg);
      _mesa_Uniform4iv(clear->IntegerColorLocation, 1,
			  ctx->Color.ClearColor.i);
   } else if (glsl) {
      _mesa_UseProgram(clear->ShaderProg);
      _mesa_Uniform4fv(clear->ColorLocation, 1,
			  ctx->Color.ClearColor.f);
   }

   /* GL_COLOR_BUFFER_BIT */
   if (buffers & BUFFER_BITS_COLOR) {
      /* Only draw to the buffers we were asked to clear. */
      drawbuffers_from_bitfield(buffers & BUFFER_BITS_COLOR);

      /* leave colormask state as-is */

      /* Clears never have the color clamped. */
      if (ctx->Extensions.ARB_color_buffer_float)
         _mesa_ClampColor(GL_CLAMP_FRAGMENT_COLOR, GL_FALSE);
   }
   else {
      ASSERT(metaSave & MESA_META_COLOR_MASK);
      _mesa_ColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
   }

   /* GL_DEPTH_BUFFER_BIT */
   if (buffers & BUFFER_BIT_DEPTH) {
      _mesa_set_enable(ctx, GL_DEPTH_TEST, GL_TRUE);
      _mesa_DepthFunc(GL_ALWAYS);
      _mesa_DepthMask(GL_TRUE);
   }
   else {
      assert(!ctx->Depth.Test);
   }

   /* GL_STENCIL_BUFFER_BIT */
   if (buffers & BUFFER_BIT_STENCIL) {
      _mesa_set_enable(ctx, GL_STENCIL_TEST, GL_TRUE);
      _mesa_StencilOpSeparate(GL_FRONT_AND_BACK,
                              GL_REPLACE, GL_REPLACE, GL_REPLACE);
      _mesa_StencilFuncSeparate(GL_FRONT_AND_BACK, GL_ALWAYS,
                                ctx->Stencil.Clear & stencilMax,
                                ctx->Stencil.WriteMask[0]);
   }
   else {
      assert(!ctx->Stencil.Enabled);
   }

   /* vertex positions */
   verts[0].x = x0;
   verts[0].y = y0;
   verts[0].z = z;
   verts[1].x = x1;
   verts[1].y = y0;
   verts[1].z = z;
   verts[2].x = x1;
   verts[2].y = y1;
   verts[2].z = z;
   verts[3].x = x0;
   verts[3].y = y1;
   verts[3].z = z;

   if (!glsl) {
      for (i = 0; i < 4; i++) {
         verts[i].r = ctx->Color.ClearColor.f[0];
         verts[i].g = ctx->Color.ClearColor.f[1];
         verts[i].b = ctx->Color.ClearColor.f[2];
         verts[i].a = ctx->Color.ClearColor.f[3];
      }
   }

   /* upload new vertex data */
   _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts), verts,
		       GL_DYNAMIC_DRAW_ARB);

   /* draw quad(s) */
   if (fb->MaxNumLayers > 0) {
      unsigned layer;
      assert(glsl);
      for (layer = 0; layer < fb->MaxNumLayers; layer++) {
         if (fb->_IntegerColor)
            _mesa_Uniform1i(clear->IntegerLayerLocation, layer);
         else
            _mesa_Uniform1i(clear->LayerLocation, layer);
         _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
      }
   } else {
      _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
   }

   _mesa_meta_end(ctx);
}

/**
 * Meta implementation of ctx->Driver.CopyPixels() in terms
 * of texture mapping and polygon rendering and GLSL shaders.
 */
void
_mesa_meta_CopyPixels(struct gl_context *ctx, GLint srcX, GLint srcY,
                      GLsizei width, GLsizei height,
                      GLint dstX, GLint dstY, GLenum type)
{
   struct copypix_state *copypix = &ctx->Meta->CopyPix;
   struct temp_texture *tex = _mesa_meta_get_temp_texture(ctx);
   struct vertex verts[4];

   if (type != GL_COLOR ||
       ctx->_ImageTransferState ||
       ctx->Fog.Enabled ||
       width > tex->MaxSize ||
       height > tex->MaxSize) {
      /* XXX avoid this fallback */
      _swrast_CopyPixels(ctx, srcX, srcY, width, height, dstX, dstY, type);
      return;
   }

   /* Most GL state applies to glCopyPixels, but a there's a few things
    * we need to override:
    */
   _mesa_meta_begin(ctx, (MESA_META_RASTERIZATION |
                          MESA_META_SHADER |
                          MESA_META_TEXTURE |
                          MESA_META_TRANSFORM |
                          MESA_META_CLIP |
                          MESA_META_VERTEX |
                          MESA_META_VIEWPORT));

   _mesa_meta_setup_vertex_objects(&copypix->VAO, &copypix->VBO, false,
                                   3, 2, 0);

   /* Silence valgrind warnings about reading uninitialized stack. */
   memset(verts, 0, sizeof(verts));

   /* Alloc/setup texture */
   _mesa_meta_setup_copypix_texture(ctx, tex, srcX, srcY, width, height,
                                    GL_RGBA, GL_NEAREST);

   /* vertex positions, texcoords (after texture allocation!) */
   {
      const GLfloat dstX0 = (GLfloat) dstX;
      const GLfloat dstY0 = (GLfloat) dstY;
      const GLfloat dstX1 = dstX + width * ctx->Pixel.ZoomX;
      const GLfloat dstY1 = dstY + height * ctx->Pixel.ZoomY;
      const GLfloat z = invert_z(ctx->Current.RasterPos[2]);

      verts[0].x = dstX0;
      verts[0].y = dstY0;
      verts[0].z = z;
      verts[0].tex[0] = 0.0F;
      verts[0].tex[1] = 0.0F;
      verts[1].x = dstX1;
      verts[1].y = dstY0;
      verts[1].z = z;
      verts[1].tex[0] = tex->Sright;
      verts[1].tex[1] = 0.0F;
      verts[2].x = dstX1;
      verts[2].y = dstY1;
      verts[2].z = z;
      verts[2].tex[0] = tex->Sright;
      verts[2].tex[1] = tex->Ttop;
      verts[3].x = dstX0;
      verts[3].y = dstY1;
      verts[3].z = z;
      verts[3].tex[0] = 0.0F;
      verts[3].tex[1] = tex->Ttop;

      /* upload new vertex data */
      _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
   }

   _mesa_set_enable(ctx, tex->Target, GL_TRUE);

   /* draw textured quad */
   _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);

   _mesa_set_enable(ctx, tex->Target, GL_FALSE);

   _mesa_meta_end(ctx);
}

static void
meta_drawpix_cleanup(struct drawpix_state *drawpix)
{
   if (drawpix->VAO != 0) {
      _mesa_DeleteVertexArrays(1, &drawpix->VAO);
      drawpix->VAO = 0;

      _mesa_DeleteBuffers(1, &drawpix->VBO);
      drawpix->VBO = 0;
   }

   if (drawpix->StencilFP != 0) {
      _mesa_DeleteProgramsARB(1, &drawpix->StencilFP);
      drawpix->StencilFP = 0;
   }

   if (drawpix->DepthFP != 0) {
      _mesa_DeleteProgramsARB(1, &drawpix->DepthFP);
      drawpix->DepthFP = 0;
   }
}

/**
 * When the glDrawPixels() image size is greater than the max rectangle
 * texture size we use this function to break the glDrawPixels() image
 * into tiles which fit into the max texture size.
 */
static void
tiled_draw_pixels(struct gl_context *ctx,
                  GLint tileSize,
                  GLint x, GLint y, GLsizei width, GLsizei height,
                  GLenum format, GLenum type,
                  const struct gl_pixelstore_attrib *unpack,
                  const GLvoid *pixels)
{
   struct gl_pixelstore_attrib tileUnpack = *unpack;
   GLint i, j;

   if (tileUnpack.RowLength == 0)
      tileUnpack.RowLength = width;

   for (i = 0; i < width; i += tileSize) {
      const GLint tileWidth = MIN2(tileSize, width - i);
      const GLint tileX = (GLint) (x + i * ctx->Pixel.ZoomX);

      tileUnpack.SkipPixels = unpack->SkipPixels + i;

      for (j = 0; j < height; j += tileSize) {
         const GLint tileHeight = MIN2(tileSize, height - j);
         const GLint tileY = (GLint) (y + j * ctx->Pixel.ZoomY);

         tileUnpack.SkipRows = unpack->SkipRows + j;

         _mesa_meta_DrawPixels(ctx, tileX, tileY, tileWidth, tileHeight,
                               format, type, &tileUnpack, pixels);
      }
   }
}


/**
 * One-time init for drawing stencil pixels.
 */
static void
init_draw_stencil_pixels(struct gl_context *ctx)
{
   /* This program is run eight times, once for each stencil bit.
    * The stencil values to draw are found in an 8-bit alpha texture.
    * We read the texture/stencil value and test if bit 'b' is set.
    * If the bit is not set, use KIL to kill the fragment.
    * Finally, we use the stencil test to update the stencil buffer.
    *
    * The basic algorithm for checking if a bit is set is:
    *   if (is_odd(value / (1 << bit)))
    *      result is one (or non-zero).
    *   else
    *      result is zero.
    * The program parameter contains three values:
    *   parm.x = 255 / (1 << bit)
    *   parm.y = 0.5
    *   parm.z = 0.0
    */
   static const char *program =
      "!!ARBfp1.0\n"
      "PARAM parm = program.local[0]; \n"
      "TEMP t; \n"
      "TEX t, fragment.texcoord[0], texture[0], %s; \n"   /* NOTE %s here! */
      "# t = t * 255 / bit \n"
      "MUL t.x, t.a, parm.x; \n"
      "# t = (int) t \n"
      "FRC t.y, t.x; \n"
      "SUB t.x, t.x, t.y; \n"
      "# t = t * 0.5 \n"
      "MUL t.x, t.x, parm.y; \n"
      "# t = fract(t.x) \n"
      "FRC t.x, t.x; # if t.x != 0, then the bit is set \n"
      "# t.x = (t.x == 0 ? 1 : 0) \n"
      "SGE t.x, -t.x, parm.z; \n"
      "KIL -t.x; \n"
      "# for debug only \n"
      "#MOV result.color, t.x; \n"
      "END \n";
   char program2[1000];
   struct drawpix_state *drawpix = &ctx->Meta->DrawPix;
   struct temp_texture *tex = _mesa_meta_get_temp_texture(ctx);
   const char *texTarget;

   assert(drawpix->StencilFP == 0);

   /* replace %s with "RECT" or "2D" */
   assert(strlen(program) + 4 < sizeof(program2));
   if (tex->Target == GL_TEXTURE_RECTANGLE)
      texTarget = "RECT";
   else
      texTarget = "2D";
   _mesa_snprintf(program2, sizeof(program2), program, texTarget);

   _mesa_GenProgramsARB(1, &drawpix->StencilFP);
   _mesa_BindProgramARB(GL_FRAGMENT_PROGRAM_ARB, drawpix->StencilFP);
   _mesa_ProgramStringARB(GL_FRAGMENT_PROGRAM_ARB, GL_PROGRAM_FORMAT_ASCII_ARB,
                          strlen(program2), (const GLubyte *) program2);
}


/**
 * One-time init for drawing depth pixels.
 */
static void
init_draw_depth_pixels(struct gl_context *ctx)
{
   static const char *program =
      "!!ARBfp1.0\n"
      "PARAM color = program.local[0]; \n"
      "TEX result.depth, fragment.texcoord[0], texture[0], %s; \n"
      "MOV result.color, color; \n"
      "END \n";
   char program2[200];
   struct drawpix_state *drawpix = &ctx->Meta->DrawPix;
   struct temp_texture *tex = _mesa_meta_get_temp_texture(ctx);
   const char *texTarget;

   assert(drawpix->DepthFP == 0);

   /* replace %s with "RECT" or "2D" */
   assert(strlen(program) + 4 < sizeof(program2));
   if (tex->Target == GL_TEXTURE_RECTANGLE)
      texTarget = "RECT";
   else
      texTarget = "2D";
   _mesa_snprintf(program2, sizeof(program2), program, texTarget);

   _mesa_GenProgramsARB(1, &drawpix->DepthFP);
   _mesa_BindProgramARB(GL_FRAGMENT_PROGRAM_ARB, drawpix->DepthFP);
   _mesa_ProgramStringARB(GL_FRAGMENT_PROGRAM_ARB, GL_PROGRAM_FORMAT_ASCII_ARB,
                          strlen(program2), (const GLubyte *) program2);
}


/**
 * Meta implementation of ctx->Driver.DrawPixels() in terms
 * of texture mapping and polygon rendering.
 */
void
_mesa_meta_DrawPixels(struct gl_context *ctx,
                      GLint x, GLint y, GLsizei width, GLsizei height,
                      GLenum format, GLenum type,
                      const struct gl_pixelstore_attrib *unpack,
                      const GLvoid *pixels)
{
   struct drawpix_state *drawpix = &ctx->Meta->DrawPix;
   struct temp_texture *tex = _mesa_meta_get_temp_texture(ctx);
   const struct gl_pixelstore_attrib unpackSave = ctx->Unpack;
   const GLuint origStencilMask = ctx->Stencil.WriteMask[0];
   struct vertex verts[4];
   GLenum texIntFormat;
   GLboolean fallback, newTex;
   GLbitfield metaExtraSave = 0x0;

   /*
    * Determine if we can do the glDrawPixels with texture mapping.
    */
   fallback = GL_FALSE;
   if (ctx->Fog.Enabled) {
      fallback = GL_TRUE;
   }

   if (_mesa_is_color_format(format)) {
      /* use more compact format when possible */
      /* XXX disable special case for GL_LUMINANCE for now to work around
       * apparent i965 driver bug (see bug #23670).
       */
      if (/*format == GL_LUMINANCE ||*/ format == GL_LUMINANCE_ALPHA)
         texIntFormat = format;
      else
         texIntFormat = GL_RGBA;

      /* If we're not supposed to clamp the resulting color, then just
       * promote our texture to fully float.  We could do better by
       * just going for the matching set of channels, in floating
       * point.
       */
      if (ctx->Color.ClampFragmentColor != GL_TRUE &&
	  ctx->Extensions.ARB_texture_float)
	 texIntFormat = GL_RGBA32F;
   }
   else if (_mesa_is_stencil_format(format)) {
      if (ctx->Extensions.ARB_fragment_program &&
          ctx->Pixel.IndexShift == 0 &&
          ctx->Pixel.IndexOffset == 0 &&
          type == GL_UNSIGNED_BYTE) {
         /* We'll store stencil as alpha.  This only works for GLubyte
          * image data because of how incoming values are mapped to alpha
          * in [0,1].
          */
         texIntFormat = GL_ALPHA;
         metaExtraSave = (MESA_META_COLOR_MASK |
                          MESA_META_DEPTH_TEST |
                          MESA_META_PIXEL_TRANSFER |
                          MESA_META_SHADER |
                          MESA_META_STENCIL_TEST);
      }
      else {
         fallback = GL_TRUE;
      }
   }
   else if (_mesa_is_depth_format(format)) {
      if (ctx->Extensions.ARB_depth_texture &&
          ctx->Extensions.ARB_fragment_program) {
         texIntFormat = GL_DEPTH_COMPONENT;
         metaExtraSave = (MESA_META_SHADER);
      }
      else {
         fallback = GL_TRUE;
      }
   }
   else {
      fallback = GL_TRUE;
   }

   if (fallback) {
      _swrast_DrawPixels(ctx, x, y, width, height,
                         format, type, unpack, pixels);
      return;
   }

   /*
    * Check image size against max texture size, draw as tiles if needed.
    */
   if (width > tex->MaxSize || height > tex->MaxSize) {
      tiled_draw_pixels(ctx, tex->MaxSize, x, y, width, height,
                        format, type, unpack, pixels);
      return;
   }

   /* Most GL state applies to glDrawPixels (like blending, stencil, etc),
    * but a there's a few things we need to override:
    */
   _mesa_meta_begin(ctx, (MESA_META_RASTERIZATION |
                          MESA_META_SHADER |
                          MESA_META_TEXTURE |
                          MESA_META_TRANSFORM |
                          MESA_META_CLIP |
                          MESA_META_VERTEX |
                          MESA_META_VIEWPORT |
                          metaExtraSave));

   newTex = _mesa_meta_alloc_texture(tex, width, height, texIntFormat);

   _mesa_meta_setup_vertex_objects(&drawpix->VAO, &drawpix->VBO, false,
                                   3, 2, 0);

   /* Silence valgrind warnings about reading uninitialized stack. */
   memset(verts, 0, sizeof(verts));

   /* vertex positions, texcoords (after texture allocation!) */
   {
      const GLfloat x0 = (GLfloat) x;
      const GLfloat y0 = (GLfloat) y;
      const GLfloat x1 = x + width * ctx->Pixel.ZoomX;
      const GLfloat y1 = y + height * ctx->Pixel.ZoomY;
      const GLfloat z = invert_z(ctx->Current.RasterPos[2]);

      verts[0].x = x0;
      verts[0].y = y0;
      verts[0].z = z;
      verts[0].tex[0] = 0.0F;
      verts[0].tex[1] = 0.0F;
      verts[1].x = x1;
      verts[1].y = y0;
      verts[1].z = z;
      verts[1].tex[0] = tex->Sright;
      verts[1].tex[1] = 0.0F;
      verts[2].x = x1;
      verts[2].y = y1;
      verts[2].z = z;
      verts[2].tex[0] = tex->Sright;
      verts[2].tex[1] = tex->Ttop;
      verts[3].x = x0;
      verts[3].y = y1;
      verts[3].z = z;
      verts[3].tex[0] = 0.0F;
      verts[3].tex[1] = tex->Ttop;
   }

   /* upload new vertex data */
   _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
                       verts, GL_DYNAMIC_DRAW_ARB);

   /* set given unpack params */
   ctx->Unpack = *unpack;

   _mesa_set_enable(ctx, tex->Target, GL_TRUE);

   if (_mesa_is_stencil_format(format)) {
      /* Drawing stencil */
      GLint bit;

      if (!drawpix->StencilFP)
         init_draw_stencil_pixels(ctx);

      _mesa_meta_setup_drawpix_texture(ctx, tex, newTex, width, height,
                                       GL_ALPHA, type, pixels);

      _mesa_ColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);

      _mesa_set_enable(ctx, GL_STENCIL_TEST, GL_TRUE);

      /* set all stencil bits to 0 */
      _mesa_StencilOp(GL_REPLACE, GL_REPLACE, GL_REPLACE);
      _mesa_StencilFunc(GL_ALWAYS, 0, 255);
      _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
  
      /* set stencil bits to 1 where needed */
      _mesa_StencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);

      _mesa_BindProgramARB(GL_FRAGMENT_PROGRAM_ARB, drawpix->StencilFP);
      _mesa_set_enable(ctx, GL_FRAGMENT_PROGRAM_ARB, GL_TRUE);

      for (bit = 0; bit < ctx->DrawBuffer->Visual.stencilBits; bit++) {
         const GLuint mask = 1 << bit;
         if (mask & origStencilMask) {
            _mesa_StencilFunc(GL_ALWAYS, mask, mask);
            _mesa_StencilMask(mask);

            _mesa_ProgramLocalParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, 0,
                                             255.0f / mask, 0.5f, 0.0f, 0.0f);

            _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
         }
      }
   }
   else if (_mesa_is_depth_format(format)) {
      /* Drawing depth */
      if (!drawpix->DepthFP)
         init_draw_depth_pixels(ctx);

      _mesa_BindProgramARB(GL_FRAGMENT_PROGRAM_ARB, drawpix->DepthFP);
      _mesa_set_enable(ctx, GL_FRAGMENT_PROGRAM_ARB, GL_TRUE);

      /* polygon color = current raster color */
      _mesa_ProgramLocalParameter4fvARB(GL_FRAGMENT_PROGRAM_ARB, 0,
                                        ctx->Current.RasterColor);

      _mesa_meta_setup_drawpix_texture(ctx, tex, newTex, width, height,
                                       format, type, pixels);

      _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
   }
   else {
      /* Drawing RGBA */
      _mesa_meta_setup_drawpix_texture(ctx, tex, newTex, width, height,
                                       format, type, pixels);
      _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
   }

   _mesa_set_enable(ctx, tex->Target, GL_FALSE);

   /* restore unpack params */
   ctx->Unpack = unpackSave;

   _mesa_meta_end(ctx);
}

static GLboolean
alpha_test_raster_color(struct gl_context *ctx)
{
   GLfloat alpha = ctx->Current.RasterColor[ACOMP];
   GLfloat ref = ctx->Color.AlphaRef;

   switch (ctx->Color.AlphaFunc) {
      case GL_NEVER:
	 return GL_FALSE;
      case GL_LESS:
	 return alpha < ref;
      case GL_EQUAL:
	 return alpha == ref;
      case GL_LEQUAL:
	 return alpha <= ref;
      case GL_GREATER:
	 return alpha > ref;
      case GL_NOTEQUAL:
	 return alpha != ref;
      case GL_GEQUAL:
	 return alpha >= ref;
      case GL_ALWAYS:
	 return GL_TRUE;
      default:
	 assert(0);
	 return GL_FALSE;
   }
}

/**
 * Do glBitmap with a alpha texture quad.  Use the alpha test to cull
 * the 'off' bits.  A bitmap cache as in the gallium/mesa state
 * tracker would improve performance a lot.
 */
void
_mesa_meta_Bitmap(struct gl_context *ctx,
                  GLint x, GLint y, GLsizei width, GLsizei height,
                  const struct gl_pixelstore_attrib *unpack,
                  const GLubyte *bitmap1)
{
   struct bitmap_state *bitmap = &ctx->Meta->Bitmap;
   struct temp_texture *tex = get_bitmap_temp_texture(ctx);
   const GLenum texIntFormat = GL_ALPHA;
   const struct gl_pixelstore_attrib unpackSave = *unpack;
   GLubyte fg, bg;
   struct vertex verts[4];
   GLboolean newTex;
   GLubyte *bitmap8;

   /*
    * Check if swrast fallback is needed.
    */
   if (ctx->_ImageTransferState ||
       ctx->FragmentProgram._Enabled ||
       ctx->Fog.Enabled ||
       ctx->Texture._MaxEnabledTexImageUnit != -1 ||
       width > tex->MaxSize ||
       height > tex->MaxSize) {
      _swrast_Bitmap(ctx, x, y, width, height, unpack, bitmap1);
      return;
   }

   if (ctx->Color.AlphaEnabled && !alpha_test_raster_color(ctx))
      return;

   /* Most GL state applies to glBitmap (like blending, stencil, etc),
    * but a there's a few things we need to override:
    */
   _mesa_meta_begin(ctx, (MESA_META_ALPHA_TEST |
                          MESA_META_PIXEL_STORE |
                          MESA_META_RASTERIZATION |
                          MESA_META_SHADER |
                          MESA_META_TEXTURE |
                          MESA_META_TRANSFORM |
                          MESA_META_CLIP |
                          MESA_META_VERTEX |
                          MESA_META_VIEWPORT));

   _mesa_meta_setup_vertex_objects(&bitmap->VAO, &bitmap->VBO, false, 3, 2, 4);

   newTex = _mesa_meta_alloc_texture(tex, width, height, texIntFormat);

   /* Silence valgrind warnings about reading uninitialized stack. */
   memset(verts, 0, sizeof(verts));

   /* vertex positions, texcoords, colors (after texture allocation!) */
   {
      const GLfloat x0 = (GLfloat) x;
      const GLfloat y0 = (GLfloat) y;
      const GLfloat x1 = (GLfloat) (x + width);
      const GLfloat y1 = (GLfloat) (y + height);
      const GLfloat z = invert_z(ctx->Current.RasterPos[2]);
      GLuint i;

      verts[0].x = x0;
      verts[0].y = y0;
      verts[0].z = z;
      verts[0].tex[0] = 0.0F;
      verts[0].tex[1] = 0.0F;
      verts[1].x = x1;
      verts[1].y = y0;
      verts[1].z = z;
      verts[1].tex[0] = tex->Sright;
      verts[1].tex[1] = 0.0F;
      verts[2].x = x1;
      verts[2].y = y1;
      verts[2].z = z;
      verts[2].tex[0] = tex->Sright;
      verts[2].tex[1] = tex->Ttop;
      verts[3].x = x0;
      verts[3].y = y1;
      verts[3].z = z;
      verts[3].tex[0] = 0.0F;
      verts[3].tex[1] = tex->Ttop;

      for (i = 0; i < 4; i++) {
         verts[i].r = ctx->Current.RasterColor[0];
         verts[i].g = ctx->Current.RasterColor[1];
         verts[i].b = ctx->Current.RasterColor[2];
         verts[i].a = ctx->Current.RasterColor[3];
      }

      /* upload new vertex data */
      _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
   }

   /* choose different foreground/background alpha values */
   CLAMPED_FLOAT_TO_UBYTE(fg, ctx->Current.RasterColor[ACOMP]);
   bg = (fg > 127 ? 0 : 255);

   bitmap1 = _mesa_map_pbo_source(ctx, &unpackSave, bitmap1);
   if (!bitmap1) {
      _mesa_meta_end(ctx);
      return;
   }

   bitmap8 = malloc(width * height);
   if (bitmap8) {
      memset(bitmap8, bg, width * height);
      _mesa_expand_bitmap(width, height, &unpackSave, bitmap1,
                          bitmap8, width, fg);

      _mesa_set_enable(ctx, tex->Target, GL_TRUE);

      _mesa_set_enable(ctx, GL_ALPHA_TEST, GL_TRUE);
      _mesa_AlphaFunc(GL_NOTEQUAL, UBYTE_TO_FLOAT(bg));

      _mesa_meta_setup_drawpix_texture(ctx, tex, newTex, width, height,
                                       GL_ALPHA, GL_UNSIGNED_BYTE, bitmap8);

      _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);

      _mesa_set_enable(ctx, tex->Target, GL_FALSE);

      free(bitmap8);
   }

   _mesa_unmap_pbo_source(ctx, &unpackSave);

   _mesa_meta_end(ctx);
}

/**
 * Compute the texture coordinates for the four vertices of a quad for
 * drawing a 2D texture image or slice of a cube/3D texture.
 * \param faceTarget  GL_TEXTURE_1D/2D/3D or cube face name
 * \param slice  slice of a 1D/2D array texture or 3D texture
 * \param width  width of the texture image
 * \param height  height of the texture image
 * \param coords0/1/2/3  returns the computed texcoords
 */
void
_mesa_meta_setup_texture_coords(GLenum faceTarget,
                                GLint slice,
                                GLint width,
                                GLint height,
                                GLint depth,
                                GLfloat coords0[4],
                                GLfloat coords1[4],
                                GLfloat coords2[4],
                                GLfloat coords3[4])
{
   static const GLfloat st[4][2] = {
      {0.0f, 0.0f}, {1.0f, 0.0f}, {1.0f, 1.0f}, {0.0f, 1.0f}
   };
   GLuint i;
   GLfloat r;

   if (faceTarget == GL_TEXTURE_CUBE_MAP_ARRAY)
      faceTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + slice % 6;

   /* Currently all texture targets want the W component to be 1.0.
    */
   coords0[3] = 1.0F;
   coords1[3] = 1.0F;
   coords2[3] = 1.0F;
   coords3[3] = 1.0F;

   switch (faceTarget) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_TEXTURE_3D:
   case GL_TEXTURE_2D_ARRAY:
      if (faceTarget == GL_TEXTURE_3D) {
         assert(slice < depth);
         assert(depth >= 1);
         r = (slice + 0.5f) / depth;
      }
      else if (faceTarget == GL_TEXTURE_2D_ARRAY)
         r = (float) slice;
      else
         r = 0.0F;
      coords0[0] = 0.0F; /* s */
      coords0[1] = 0.0F; /* t */
      coords0[2] = r; /* r */
      coords1[0] = 1.0F;
      coords1[1] = 0.0F;
      coords1[2] = r;
      coords2[0] = 1.0F;
      coords2[1] = 1.0F;
      coords2[2] = r;
      coords3[0] = 0.0F;
      coords3[1] = 1.0F;
      coords3[2] = r;
      break;
   case GL_TEXTURE_RECTANGLE_ARB:
      coords0[0] = 0.0F; /* s */
      coords0[1] = 0.0F; /* t */
      coords0[2] = 0.0F; /* r */
      coords1[0] = (float) width;
      coords1[1] = 0.0F;
      coords1[2] = 0.0F;
      coords2[0] = (float) width;
      coords2[1] = (float) height;
      coords2[2] = 0.0F;
      coords3[0] = 0.0F;
      coords3[1] = (float) height;
      coords3[2] = 0.0F;
      break;
   case GL_TEXTURE_1D_ARRAY:
      coords0[0] = 0.0F; /* s */
      coords0[1] = (float) slice; /* t */
      coords0[2] = 0.0F; /* r */
      coords1[0] = 1.0f;
      coords1[1] = (float) slice;
      coords1[2] = 0.0F;
      coords2[0] = 1.0F;
      coords2[1] = (float) slice;
      coords2[2] = 0.0F;
      coords3[0] = 0.0F;
      coords3[1] = (float) slice;
      coords3[2] = 0.0F;
      break;

   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
      /* loop over quad verts */
      for (i = 0; i < 4; i++) {
         /* Compute sc = +/-scale and tc = +/-scale.
          * Not +/-1 to avoid cube face selection ambiguity near the edges,
          * though that can still sometimes happen with this scale factor...
          */
         const GLfloat scale = 0.9999f;
         const GLfloat sc = (2.0f * st[i][0] - 1.0f) * scale;
         const GLfloat tc = (2.0f * st[i][1] - 1.0f) * scale;
         GLfloat *coord;

         switch (i) {
         case 0:
            coord = coords0;
            break;
         case 1:
            coord = coords1;
            break;
         case 2:
            coord = coords2;
            break;
         case 3:
            coord = coords3;
            break;
         default:
            assert(0);
         }

         coord[3] = (float) (slice / 6);

         switch (faceTarget) {
         case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
            coord[0] = 1.0f;
            coord[1] = -tc;
            coord[2] = -sc;
            break;
         case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
            coord[0] = -1.0f;
            coord[1] = -tc;
            coord[2] = sc;
            break;
         case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
            coord[0] = sc;
            coord[1] = 1.0f;
            coord[2] = tc;
            break;
         case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
            coord[0] = sc;
            coord[1] = -1.0f;
            coord[2] = -tc;
            break;
         case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
            coord[0] = sc;
            coord[1] = -tc;
            coord[2] = 1.0f;
            break;
         case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
            coord[0] = -sc;
            coord[1] = -tc;
            coord[2] = -1.0f;
            break;
         default:
            assert(0);
         }
      }
      break;
   default:
      assert(!"unexpected target in _mesa_meta_setup_texture_coords()");
   }
}

static struct blit_shader *
choose_blit_shader(GLenum target, struct blit_shader_table *table)
{
   switch(target) {
   case GL_TEXTURE_1D:
      table->sampler_1d.type = "sampler1D";
      table->sampler_1d.func = "texture1D";
      table->sampler_1d.texcoords = "texCoords.x";
      return &table->sampler_1d;
   case GL_TEXTURE_2D:
      table->sampler_2d.type = "sampler2D";
      table->sampler_2d.func = "texture2D";
      table->sampler_2d.texcoords = "texCoords.xy";
      return &table->sampler_2d;
   case GL_TEXTURE_RECTANGLE:
      table->sampler_rect.type = "sampler2DRect";
      table->sampler_rect.func = "texture2DRect";
      table->sampler_rect.texcoords = "texCoords.xy";
      return &table->sampler_rect;
   case GL_TEXTURE_3D:
      /* Code for mipmap generation with 3D textures is not used yet.
       * It's a sw fallback.
       */
      table->sampler_3d.type = "sampler3D";
      table->sampler_3d.func = "texture3D";
      table->sampler_3d.texcoords = "texCoords.xyz";
      return &table->sampler_3d;
   case GL_TEXTURE_CUBE_MAP:
      table->sampler_cubemap.type = "samplerCube";
      table->sampler_cubemap.func = "textureCube";
      table->sampler_cubemap.texcoords = "texCoords.xyz";
      return &table->sampler_cubemap;
   case GL_TEXTURE_1D_ARRAY:
      table->sampler_1d_array.type = "sampler1DArray";
      table->sampler_1d_array.func = "texture1DArray";
      table->sampler_1d_array.texcoords = "texCoords.xy";
      return &table->sampler_1d_array;
   case GL_TEXTURE_2D_ARRAY:
      table->sampler_2d_array.type = "sampler2DArray";
      table->sampler_2d_array.func = "texture2DArray";
      table->sampler_2d_array.texcoords = "texCoords.xyz";
      return &table->sampler_2d_array;
   case GL_TEXTURE_CUBE_MAP_ARRAY:
      table->sampler_cubemap_array.type = "samplerCubeArray";
      table->sampler_cubemap_array.func = "textureCubeArray";
      table->sampler_cubemap_array.texcoords = "texCoords.xyzw";
      return &table->sampler_cubemap_array;
   default:
      _mesa_problem(NULL, "Unexpected texture target 0x%x in"
                    " setup_texture_sampler()\n", target);
      return NULL;
   }
}

void
_mesa_meta_blit_shader_table_cleanup(struct blit_shader_table *table)
{
   _mesa_DeleteProgram(table->sampler_1d.shader_prog);
   _mesa_DeleteProgram(table->sampler_2d.shader_prog);
   _mesa_DeleteProgram(table->sampler_3d.shader_prog);
   _mesa_DeleteProgram(table->sampler_rect.shader_prog);
   _mesa_DeleteProgram(table->sampler_cubemap.shader_prog);
   _mesa_DeleteProgram(table->sampler_1d_array.shader_prog);
   _mesa_DeleteProgram(table->sampler_2d_array.shader_prog);
   _mesa_DeleteProgram(table->sampler_cubemap_array.shader_prog);

   table->sampler_1d.shader_prog = 0;
   table->sampler_2d.shader_prog = 0;
   table->sampler_3d.shader_prog = 0;
   table->sampler_rect.shader_prog = 0;
   table->sampler_cubemap.shader_prog = 0;
   table->sampler_1d_array.shader_prog = 0;
   table->sampler_2d_array.shader_prog = 0;
   table->sampler_cubemap_array.shader_prog = 0;
}

/**
 * Determine the GL data type to use for the temporary image read with
 * ReadPixels() and passed to Tex[Sub]Image().
 */
static GLenum
get_temp_image_type(struct gl_context *ctx, mesa_format format)
{
   const GLenum baseFormat = _mesa_get_format_base_format(format);
   const GLint format_red_bits = _mesa_get_format_bits(format, GL_RED_BITS);
   GLenum datatype = _mesa_get_format_datatype(format);

   switch (baseFormat) {
   case GL_RGBA:
   case GL_RGB:
   case GL_RG:
   case GL_RED:
   case GL_ALPHA:
   case GL_LUMINANCE:
   case GL_LUMINANCE_ALPHA:
   case GL_INTENSITY:
      if (datatype == GL_INT || datatype == GL_UNSIGNED_INT) {
         return datatype;
      } else if (format_red_bits <= 8) {
         return GL_UNSIGNED_BYTE;
      } else if (format_red_bits <= 16) {
         return GL_UNSIGNED_SHORT;
      }
      return GL_FLOAT;
   case GL_DEPTH_COMPONENT: {
      if (datatype == GL_FLOAT)
         return GL_FLOAT;
      else
         return GL_UNSIGNED_INT;
   }
   case GL_DEPTH_STENCIL: {
      GLenum datatype = _mesa_get_format_datatype(format);
      if (datatype == GL_FLOAT)
         return GL_FLOAT_32_UNSIGNED_INT_24_8_REV;
      else
         return GL_UNSIGNED_INT_24_8;
   }
   default:
      _mesa_problem(ctx, "Unexpected format %d in get_temp_image_type()",
		    baseFormat);
      return 0;
   }
}

/**
 * Attempts to wrap the destination texture in an FBO and use
 * glBlitFramebuffer() to implement glCopyTexSubImage().
 */
static bool
copytexsubimage_using_blit_framebuffer(struct gl_context *ctx, GLuint dims,
                                       struct gl_texture_image *texImage,
                                       GLint xoffset,
                                       GLint yoffset,
                                       GLint zoffset,
                                       struct gl_renderbuffer *rb,
                                       GLint x, GLint y,
                                       GLsizei width, GLsizei height)
{
   struct gl_texture_object *texObj = texImage->TexObject;
   GLuint fbo;
   bool success = false;
   GLbitfield mask;
   GLenum status;

   if (!ctx->Extensions.ARB_framebuffer_object)
      return false;

   _mesa_unlock_texture(ctx, texObj);

   _mesa_meta_begin(ctx, MESA_META_ALL & ~MESA_META_DRAW_BUFFERS);

   _mesa_GenFramebuffers(1, &fbo);
   _mesa_BindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo);

   if (rb->_BaseFormat == GL_DEPTH_STENCIL ||
       rb->_BaseFormat == GL_DEPTH_COMPONENT) {
      _mesa_meta_bind_fbo_image(GL_DEPTH_ATTACHMENT, texImage, zoffset);
      mask = GL_DEPTH_BUFFER_BIT;

      if (rb->_BaseFormat == GL_DEPTH_STENCIL &&
          texImage->_BaseFormat == GL_DEPTH_STENCIL) {
         _mesa_meta_bind_fbo_image(GL_STENCIL_ATTACHMENT, texImage, zoffset);
         mask |= GL_STENCIL_BUFFER_BIT;
      }
      _mesa_DrawBuffer(GL_NONE);
   } else {
      _mesa_meta_bind_fbo_image(GL_COLOR_ATTACHMENT0, texImage, zoffset);
      mask = GL_COLOR_BUFFER_BIT;
      _mesa_DrawBuffer(GL_COLOR_ATTACHMENT0);
   }

   status = _mesa_CheckFramebufferStatus(GL_DRAW_FRAMEBUFFER);
   if (status != GL_FRAMEBUFFER_COMPLETE)
      goto out;

   ctx->Meta->Blit.no_ctsi_fallback = true;

   /* Since we've bound a new draw framebuffer, we need to update
    * its derived state -- _Xmin, etc -- for BlitFramebuffer's clipping to
    * be correct.
    */
   _mesa_update_state(ctx);

   /* We skip the core BlitFramebuffer checks for format consistency, which
    * are too strict for CopyTexImage.  We know meta will be fine with format
    * changes.
    */
   mask = _mesa_meta_BlitFramebuffer(ctx, x, y,
                                     x + width, y + height,
                                     xoffset, yoffset,
                                     xoffset + width, yoffset + height,
                                     mask, GL_NEAREST);
   ctx->Meta->Blit.no_ctsi_fallback = false;
   success = mask == 0x0;

 out:
   _mesa_lock_texture(ctx, texObj);
   _mesa_DeleteFramebuffers(1, &fbo);
   _mesa_meta_end(ctx);
   return success;
}

/**
 * Helper for _mesa_meta_CopyTexSubImage1/2/3D() functions.
 * Have to be careful with locking and meta state for pixel transfer.
 */
void
_mesa_meta_CopyTexSubImage(struct gl_context *ctx, GLuint dims,
                           struct gl_texture_image *texImage,
                           GLint xoffset, GLint yoffset, GLint zoffset,
                           struct gl_renderbuffer *rb,
                           GLint x, GLint y,
                           GLsizei width, GLsizei height)
{
   struct gl_texture_object *texObj = texImage->TexObject;
   GLenum format, type;
   GLint bpp;
   void *buf;

   if (copytexsubimage_using_blit_framebuffer(ctx, dims,
                                              texImage,
                                              xoffset, yoffset, zoffset,
                                              rb,
                                              x, y,
                                              width, height)) {
      return;
   }

   /* Choose format/type for temporary image buffer */
   format = _mesa_get_format_base_format(texImage->TexFormat);
   if (format == GL_LUMINANCE ||
       format == GL_LUMINANCE_ALPHA ||
       format == GL_INTENSITY) {
      /* We don't want to use GL_LUMINANCE, GL_INTENSITY, etc. for the
       * temp image buffer because glReadPixels will do L=R+G+B which is
       * not what we want (should be L=R).
       */
      format = GL_RGBA;
   }

   type = get_temp_image_type(ctx, texImage->TexFormat);
   if (_mesa_is_format_integer_color(texImage->TexFormat)) {
      format = _mesa_base_format_to_integer_format(format);
   }
   bpp = _mesa_bytes_per_pixel(format, type);
   if (bpp <= 0) {
      _mesa_problem(ctx, "Bad bpp in _mesa_meta_CopyTexSubImage()");
      return;
   }

   /*
    * Alloc image buffer (XXX could use a PBO)
    */
   buf = malloc(width * height * bpp);
   if (!buf) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage%uD", dims);
      return;
   }

   _mesa_unlock_texture(ctx, texObj); /* need to unlock first */

   /*
    * Read image from framebuffer (disable pixel transfer ops)
    */
   _mesa_meta_begin(ctx, MESA_META_PIXEL_STORE | MESA_META_PIXEL_TRANSFER);
   ctx->Driver.ReadPixels(ctx, x, y, width, height,
			  format, type, &ctx->Pack, buf);
   _mesa_meta_end(ctx);

   _mesa_update_state(ctx); /* to update pixel transfer state */

   /*
    * Store texture data (with pixel transfer ops)
    */
   _mesa_meta_begin(ctx, MESA_META_PIXEL_STORE);

   if (texImage->TexObject->Target == GL_TEXTURE_1D_ARRAY) {
      assert(yoffset == 0);
      ctx->Driver.TexSubImage(ctx, dims, texImage,
                              xoffset, zoffset, 0, width, 1, 1,
                              format, type, buf, &ctx->Unpack);
   } else {
      ctx->Driver.TexSubImage(ctx, dims, texImage,
                              xoffset, yoffset, zoffset, width, height, 1,
                              format, type, buf, &ctx->Unpack);
   }

   _mesa_meta_end(ctx);

   _mesa_lock_texture(ctx, texObj); /* re-lock */

   free(buf);
}


static void
meta_decompress_cleanup(struct decompress_state *decompress)
{
   if (decompress->FBO != 0) {
      _mesa_DeleteFramebuffers(1, &decompress->FBO);
      _mesa_DeleteRenderbuffers(1, &decompress->RBO);
   }

   if (decompress->VAO != 0) {
      _mesa_DeleteVertexArrays(1, &decompress->VAO);
      _mesa_DeleteBuffers(1, &decompress->VBO);
   }

   if (decompress->Sampler != 0)
      _mesa_DeleteSamplers(1, &decompress->Sampler);

   memset(decompress, 0, sizeof(*decompress));
}

/**
 * Decompress a texture image by drawing a quad with the compressed
 * texture and reading the pixels out of the color buffer.
 * \param slice  which slice of a 3D texture or layer of a 1D/2D texture
 * \param destFormat  format, ala glReadPixels
 * \param destType  type, ala glReadPixels
 * \param dest  destination buffer
 * \param destRowLength  dest image rowLength (ala GL_PACK_ROW_LENGTH)
 */
static void
decompress_texture_image(struct gl_context *ctx,
                         struct gl_texture_image *texImage,
                         GLuint slice,
                         GLenum destFormat, GLenum destType,
                         GLvoid *dest)
{
   struct decompress_state *decompress = &ctx->Meta->Decompress;
   struct gl_texture_object *texObj = texImage->TexObject;
   const GLint width = texImage->Width;
   const GLint height = texImage->Height;
   const GLint depth = texImage->Height;
   const GLenum target = texObj->Target;
   GLenum faceTarget;
   struct vertex verts[4];
   GLuint samplerSave;
   const bool use_glsl_version = ctx->Extensions.ARB_vertex_shader &&
                                      ctx->Extensions.ARB_fragment_shader;

   if (slice > 0) {
      assert(target == GL_TEXTURE_3D ||
             target == GL_TEXTURE_2D_ARRAY ||
             target == GL_TEXTURE_CUBE_MAP_ARRAY);
   }

   switch (target) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_1D_ARRAY:
      assert(!"No compressed 1D textures.");
      return;

   case GL_TEXTURE_3D:
      assert(!"No compressed 3D textures.");
      return;

   case GL_TEXTURE_CUBE_MAP_ARRAY:
      faceTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + (slice % 6);
      break;

   case GL_TEXTURE_CUBE_MAP:
      faceTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + texImage->Face;
      break;

   default:
      faceTarget = target;
      break;
   }

   _mesa_meta_begin(ctx, MESA_META_ALL & ~(MESA_META_PIXEL_STORE |
                                           MESA_META_DRAW_BUFFERS));

   samplerSave = ctx->Texture.Unit[ctx->Texture.CurrentUnit].Sampler ?
         ctx->Texture.Unit[ctx->Texture.CurrentUnit].Sampler->Name : 0;

   /* Create/bind FBO/renderbuffer */
   if (decompress->FBO == 0) {
      _mesa_GenFramebuffers(1, &decompress->FBO);
      _mesa_GenRenderbuffers(1, &decompress->RBO);
      _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, decompress->FBO);
      _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, decompress->RBO);
      _mesa_FramebufferRenderbuffer(GL_FRAMEBUFFER_EXT,
                                       GL_COLOR_ATTACHMENT0_EXT,
                                       GL_RENDERBUFFER_EXT,
                                       decompress->RBO);
   }
   else {
      _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, decompress->FBO);
   }

   /* alloc dest surface */
   if (width > decompress->Width || height > decompress->Height) {
      _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, decompress->RBO);
      _mesa_RenderbufferStorage(GL_RENDERBUFFER_EXT, GL_RGBA,
                                   width, height);
      decompress->Width = width;
      decompress->Height = height;
   }

   if (use_glsl_version) {
      _mesa_meta_setup_vertex_objects(&decompress->VAO, &decompress->VBO, true,
                                      2, 4, 0);

      _mesa_meta_setup_blit_shader(ctx, target, &decompress->shaders);
   } else {
      _mesa_meta_setup_ff_tnl_for_blit(&decompress->VAO, &decompress->VBO, 3);
   }

   if (!decompress->Sampler) {
      _mesa_GenSamplers(1, &decompress->Sampler);
      _mesa_BindSampler(ctx->Texture.CurrentUnit, decompress->Sampler);
      /* nearest filtering */
      _mesa_SamplerParameteri(decompress->Sampler, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
      _mesa_SamplerParameteri(decompress->Sampler, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
      /* No sRGB decode or encode.*/
      if (ctx->Extensions.EXT_texture_sRGB_decode) {
         _mesa_SamplerParameteri(decompress->Sampler, GL_TEXTURE_SRGB_DECODE_EXT,
                             GL_SKIP_DECODE_EXT);
      }

   } else {
      _mesa_BindSampler(ctx->Texture.CurrentUnit, decompress->Sampler);
   }

   /* Silence valgrind warnings about reading uninitialized stack. */
   memset(verts, 0, sizeof(verts));

   _mesa_meta_setup_texture_coords(faceTarget, slice, width, height, depth,
                                   verts[0].tex,
                                   verts[1].tex,
                                   verts[2].tex,
                                   verts[3].tex);

   /* setup vertex positions */
   verts[0].x = -1.0F;
   verts[0].y = -1.0F;
   verts[1].x =  1.0F;
   verts[1].y = -1.0F;
   verts[2].x =  1.0F;
   verts[2].y =  1.0F;
   verts[3].x = -1.0F;
   verts[3].y =  1.0F;

   _mesa_set_viewport(ctx, 0, 0, 0, width, height);

   /* upload new vertex data */
   _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);

   /* setup texture state */
   _mesa_BindTexture(target, texObj->Name);

   if (!use_glsl_version)
      _mesa_set_enable(ctx, target, GL_TRUE);

   {
      /* save texture object state */
      const GLint baseLevelSave = texObj->BaseLevel;
      const GLint maxLevelSave = texObj->MaxLevel;

      /* restrict sampling to the texture level of interest */
      if (target != GL_TEXTURE_RECTANGLE_ARB) {
         _mesa_TexParameteri(target, GL_TEXTURE_BASE_LEVEL, texImage->Level);
         _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, texImage->Level);
      }

      /* render quad w/ texture into renderbuffer */
      _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
      
      /* Restore texture object state, the texture binding will
       * be restored by _mesa_meta_end().
       */
      if (target != GL_TEXTURE_RECTANGLE_ARB) {
         _mesa_TexParameteri(target, GL_TEXTURE_BASE_LEVEL, baseLevelSave);
         _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, maxLevelSave);
      }

   }

   /* read pixels from renderbuffer */
   {
      GLenum baseTexFormat = texImage->_BaseFormat;
      GLenum destBaseFormat = _mesa_base_tex_format(ctx, destFormat);

      /* The pixel transfer state will be set to default values at this point
       * (see MESA_META_PIXEL_TRANSFER) so pixel transfer ops are effectively
       * turned off (as required by glGetTexImage) but we need to handle some
       * special cases.  In particular, single-channel texture values are
       * returned as red and two-channel texture values are returned as
       * red/alpha.
       */
      if ((baseTexFormat == GL_LUMINANCE ||
           baseTexFormat == GL_LUMINANCE_ALPHA ||
           baseTexFormat == GL_INTENSITY) ||
          /* If we're reading back an RGB(A) texture (using glGetTexImage) as
	   * luminance then we need to return L=tex(R).
	   */
          ((baseTexFormat == GL_RGBA ||
            baseTexFormat == GL_RGB  ||
            baseTexFormat == GL_RG) &&
          (destBaseFormat == GL_LUMINANCE ||
           destBaseFormat == GL_LUMINANCE_ALPHA ||
           destBaseFormat == GL_LUMINANCE_INTEGER_EXT ||
           destBaseFormat == GL_LUMINANCE_ALPHA_INTEGER_EXT))) {
         /* Green and blue must be zero */
         _mesa_PixelTransferf(GL_GREEN_SCALE, 0.0f);
         _mesa_PixelTransferf(GL_BLUE_SCALE, 0.0f);
      }

      _mesa_ReadPixels(0, 0, width, height, destFormat, destType, dest);
   }

   /* disable texture unit */
   if (!use_glsl_version)
      _mesa_set_enable(ctx, target, GL_FALSE);

   _mesa_BindSampler(ctx->Texture.CurrentUnit, samplerSave);

   _mesa_meta_end(ctx);
}


/**
 * This is just a wrapper around _mesa_get_tex_image() and
 * decompress_texture_image().  Meta functions should not be directly called
 * from core Mesa.
 */
void
_mesa_meta_GetTexImage(struct gl_context *ctx,
                       GLenum format, GLenum type, GLvoid *pixels,
                       struct gl_texture_image *texImage)
{
   /* We can only use the decompress-with-blit method here if the texels are
    * unsigned, normalized values.  We could handle signed and unnormalized 
    * with floating point renderbuffers...
    */
   if (_mesa_is_format_compressed(texImage->TexFormat) &&
       _mesa_get_format_datatype(texImage->TexFormat)
       == GL_UNSIGNED_NORMALIZED) {
      struct gl_texture_object *texObj = texImage->TexObject;
      GLuint slice;
      /* Need to unlock the texture here to prevent deadlock... */
      _mesa_unlock_texture(ctx, texObj);
      for (slice = 0; slice < texImage->Depth; slice++) {
         void *dst;
         if (texImage->TexObject->Target == GL_TEXTURE_2D_ARRAY
             || texImage->TexObject->Target == GL_TEXTURE_CUBE_MAP_ARRAY) {
            /* Setup pixel packing.  SkipPixels and SkipRows will be applied
             * in the decompress_texture_image() function's call to
             * glReadPixels but we need to compute the dest slice's address
             * here (according to SkipImages and ImageHeight).
             */
            struct gl_pixelstore_attrib packing = ctx->Pack;
            packing.SkipPixels = 0;
            packing.SkipRows = 0;
            dst = _mesa_image_address3d(&packing, pixels, texImage->Width,
                                        texImage->Height, format, type,
                                        slice, 0, 0);
         }
         else {
            dst = pixels;
         }
         decompress_texture_image(ctx, texImage, slice, format, type, dst);
      }
      /* ... and relock it */
      _mesa_lock_texture(ctx, texObj);
   }
   else {
      _mesa_get_teximage(ctx, format, type, pixels, texImage);
   }
}


/**
 * Meta implementation of ctx->Driver.DrawTex() in terms
 * of polygon rendering.
 */
void
_mesa_meta_DrawTex(struct gl_context *ctx, GLfloat x, GLfloat y, GLfloat z,
                   GLfloat width, GLfloat height)
{
   struct drawtex_state *drawtex = &ctx->Meta->DrawTex;
   struct vertex {
      GLfloat x, y, z, st[MAX_TEXTURE_UNITS][2];
   };
   struct vertex verts[4];
   GLuint i;

   _mesa_meta_begin(ctx, (MESA_META_RASTERIZATION |
                          MESA_META_SHADER |
                          MESA_META_TRANSFORM |
                          MESA_META_VERTEX |
                          MESA_META_VIEWPORT));

   if (drawtex->VAO == 0) {
      /* one-time setup */
      GLint active_texture;

      /* create vertex array object */
      _mesa_GenVertexArrays(1, &drawtex->VAO);
      _mesa_BindVertexArray(drawtex->VAO);

      /* create vertex array buffer */
      _mesa_GenBuffers(1, &drawtex->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, drawtex->VBO);
      _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
                          NULL, GL_DYNAMIC_DRAW_ARB);

      /* client active texture is not part of the array object */
      active_texture = ctx->Array.ActiveTexture;

      /* setup vertex arrays */
      _mesa_VertexPointer(3, GL_FLOAT, sizeof(struct vertex), OFFSET(x));
      _mesa_EnableClientState(GL_VERTEX_ARRAY);
      for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
         _mesa_ClientActiveTexture(GL_TEXTURE0 + i);
         _mesa_TexCoordPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(st[i]));
         _mesa_EnableClientState(GL_TEXTURE_COORD_ARRAY);
      }

      /* restore client active texture */
      _mesa_ClientActiveTexture(GL_TEXTURE0 + active_texture);
   }
   else {
      _mesa_BindVertexArray(drawtex->VAO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, drawtex->VBO);
   }

   /* vertex positions, texcoords */
   {
      const GLfloat x1 = x + width;
      const GLfloat y1 = y + height;

      z = CLAMP(z, 0.0f, 1.0f);
      z = invert_z(z);

      verts[0].x = x;
      verts[0].y = y;
      verts[0].z = z;

      verts[1].x = x1;
      verts[1].y = y;
      verts[1].z = z;

      verts[2].x = x1;
      verts[2].y = y1;
      verts[2].z = z;

      verts[3].x = x;
      verts[3].y = y1;
      verts[3].z = z;

      for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
         const struct gl_texture_object *texObj;
         const struct gl_texture_image *texImage;
         GLfloat s, t, s1, t1;
         GLuint tw, th;

         if (!ctx->Texture.Unit[i]._Current) {
            GLuint j;
            for (j = 0; j < 4; j++) {
               verts[j].st[i][0] = 0.0f;
               verts[j].st[i][1] = 0.0f;
            }
            continue;
         }

         texObj = ctx->Texture.Unit[i]._Current;
         texImage = texObj->Image[0][texObj->BaseLevel];
         tw = texImage->Width2;
         th = texImage->Height2;

         s = (GLfloat) texObj->CropRect[0] / tw;
         t = (GLfloat) texObj->CropRect[1] / th;
         s1 = (GLfloat) (texObj->CropRect[0] + texObj->CropRect[2]) / tw;
         t1 = (GLfloat) (texObj->CropRect[1] + texObj->CropRect[3]) / th;

         verts[0].st[i][0] = s;
         verts[0].st[i][1] = t;

         verts[1].st[i][0] = s1;
         verts[1].st[i][1] = t;

         verts[2].st[i][0] = s1;
         verts[2].st[i][1] = t1;

         verts[3].st[i][0] = s;
         verts[3].st[i][1] = t1;
      }

      _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
   }

   _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);

   _mesa_meta_end(ctx);
}
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a42 1
#include "main/clear.h"
a49 1
#include "main/format_unpack.h"
a73 1
#include "main/texstore.h"
d84 1
a84 1
#include "util/ralloc.h"
d101 1
a101 1
_mesa_meta_bind_fbo_image(GLenum fboTarget, GLenum attachment,
d106 1
a106 1
   GLenum texTarget = texObj->Target;
d108 1
a108 1
   switch (texTarget) {
d110 1
a110 1
      _mesa_FramebufferTexture1D(fboTarget,
d112 1
a112 1
                                 texTarget,
d121 1
a121 1
      _mesa_FramebufferTextureLayer(fboTarget,
d128 2
a129 2
      if (texTarget == GL_TEXTURE_CUBE_MAP)
         texTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + texImage->Face;
d131 1
a131 1
      _mesa_FramebufferTexture2D(fboTarget,
d133 1
a133 1
                                 texTarget,
a219 1
   _mesa_ObjectLabel(GL_PROGRAM, *program, -1, name);
d227 1
d396 19
a507 5
   if (state & MESA_META_DITHER) {
      save->DitherFlag = ctx->Color.DitherFlag;
      _mesa_set_enable(ctx, GL_DITHER, GL_TRUE);
   }

a693 6

      if (ctx->Extensions.ARB_clip_control) {
         save->ClipOrigin = ctx->Transform.ClipOrigin;
         save->ClipDepthMode = ctx->Transform.ClipDepthMode;
         _mesa_ClipControl(GL_LOWER_LEFT, GL_NEGATIVE_ONE_TO_ONE);
      }
d801 14
a814 3
      struct gl_framebuffer *fb = ctx->DrawBuffer;
      memcpy(save->ColorDrawBuffers, fb->ColorDrawBuffer,
             sizeof(save->ColorDrawBuffers));
a877 3
   if (state & MESA_META_DITHER)
      _mesa_set_enable(ctx, GL_DITHER, save->DitherFlag);

a1102 3

      if (ctx->Extensions.ARB_clip_control)
         _mesa_ClipControl(save->ClipOrigin, save->ClipDepthMode);
d1216 1
a1216 1
      _mesa_drawbuffers(ctx, ctx->Const.MaxDrawBuffers, save->ColorDrawBuffers, NULL);
d1242 1
a1242 1
static inline GLfloat
a1517 2
      "#extension GL_AMD_vertex_shader_layer : enable\n"
      "#extension GL_ARB_draw_instanced : enable\n"
a1520 3
      "#ifdef GL_AMD_vertex_shader_layer\n"
      "   gl_Layer = gl_InstanceID;\n"
      "#endif\n"
d1523 13
d1542 1
a1542 1
   GLuint vs, fs;
d1554 6
d1567 2
a1571 1
   _mesa_ObjectLabel(GL_PROGRAM, clear->ShaderProg, -1, "meta clear");
d1574 6
a1579 1
   clear->ColorLocation = _mesa_GetUniformLocation(clear->ShaderProg, "color");
a1588 2
                         "#extension GL_AMD_vertex_shader_layer : enable\n"
                         "#extension GL_ARB_draw_instanced : enable\n"
a1591 3
                         "#ifdef GL_AMD_vertex_shader_layer\n"
                         "   gl_Layer = gl_InstanceID;\n"
                         "#endif\n"
d1614 2
d1631 4
d1636 2
d1665 2
a1666 2
void
_mesa_meta_drawbuffers_from_bitfield(GLbitfield bits)
d1779 1
a1779 1
      _mesa_meta_drawbuffers_from_bitfield(buffers & BUFFER_BITS_COLOR);
d1844 9
a1852 1
      _mesa_DrawArraysInstanced(GL_TRIANGLE_FAN, 0, 4, fb->MaxNumLayers);
d2615 1
a2615 1
            unreachable("not reached");
a2744 1
   const GLenum datatype = _mesa_get_format_datatype(format);
d2746 1
d2765 1
a2765 1
   case GL_DEPTH_COMPONENT:
d2770 3
a2772 1
   case GL_DEPTH_STENCIL:
d2777 1
d2799 1
d2808 2
d2817 1
a2817 2
      _mesa_meta_bind_fbo_image(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
                                texImage, zoffset);
d2822 1
a2822 2
         _mesa_meta_bind_fbo_image(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT,
                                   texImage, zoffset);
d2827 1
a2827 2
      _mesa_meta_bind_fbo_image(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                                texImage, zoffset);
d2857 1
d2875 1
d2920 2
d2950 2
a2954 10
static void
meta_decompress_fbo_cleanup(struct decompress_fbo_state *decompress_fbo)
{
   if (decompress_fbo->FBO != 0) {
      _mesa_DeleteFramebuffers(1, &decompress_fbo->FBO);
      _mesa_DeleteRenderbuffers(1, &decompress_fbo->RBO);
   }

   memset(decompress_fbo, 0, sizeof(*decompress_fbo));
}
d2959 4
a2962 2
   meta_decompress_fbo_cleanup(&decompress->byteFBO);
   meta_decompress_fbo_cleanup(&decompress->floatFBO);
d2984 1
a2984 1
static bool
a2991 1
   struct decompress_fbo_state *decompress_fbo;
a2996 1
   GLenum rbFormat;
a2999 1
   GLenum status;
a3002 13
   switch (_mesa_get_format_datatype(texImage->TexFormat)) {
   case GL_FLOAT:
      decompress_fbo = &decompress->floatFBO;
      rbFormat = GL_RGBA32F;
      break;
   case GL_UNSIGNED_NORMALIZED:
      decompress_fbo = &decompress->byteFBO;
      rbFormat = GL_RGBA;
      break;
   default:
      return false;
   }

d3013 1
a3013 1
      return false;
d3017 1
a3017 1
      return false;
d3039 5
a3043 5
   if (decompress_fbo->FBO == 0) {
      _mesa_GenFramebuffers(1, &decompress_fbo->FBO);
      _mesa_GenRenderbuffers(1, &decompress_fbo->RBO);
      _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, decompress_fbo->FBO);
      _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, decompress_fbo->RBO);
d3047 1
a3047 1
                                       decompress_fbo->RBO);
d3050 1
a3050 1
      _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, decompress_fbo->FBO);
d3054 6
a3059 14
   if (width > decompress_fbo->Width || height > decompress_fbo->Height) {
      _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, decompress_fbo->RBO);
      _mesa_RenderbufferStorage(GL_RENDERBUFFER_EXT, rbFormat,
                                width, height);
      status = _mesa_CheckFramebufferStatus(GL_DRAW_FRAMEBUFFER);
      if (status != GL_FRAMEBUFFER_COMPLETE) {
         /* If the framebuffer isn't complete then we'll leave
          * decompress_fbo->Width as zero so that it will fail again next time
          * too */
         _mesa_meta_end(ctx);
         return false;
      }
      decompress_fbo->Width = width;
      decompress_fbo->Height = height;
a3180 2

   return true;
d3194 8
a3201 1
   if (_mesa_is_format_compressed(texImage->TexFormat)) {
d3203 2
a3204 2
      bool result;

d3224 1
a3224 4
         result = decompress_texture_image(ctx, texImage, slice,
                                           format, type, dst);
         if (!result)
            break;
d3226 5
a3230 3

      if (result)
         return;
a3231 2

   _mesa_get_teximage(ctx, format, type, pixels, texImage);
a3357 185
}

static bool
cleartexsubimage_color(struct gl_context *ctx,
                       struct gl_texture_image *texImage,
                       const GLvoid *clearValue,
                       GLint zoffset)
{
   mesa_format format;
   union gl_color_union colorValue;
   GLenum datatype;
   GLenum status;

   _mesa_meta_bind_fbo_image(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                             texImage, zoffset);

   status = _mesa_CheckFramebufferStatus(GL_DRAW_FRAMEBUFFER);
   if (status != GL_FRAMEBUFFER_COMPLETE)
      return false;

   /* We don't want to apply an sRGB conversion so override the format */
   format = _mesa_get_srgb_format_linear(texImage->TexFormat);
   datatype = _mesa_get_format_datatype(format);

   switch (datatype) {
   case GL_UNSIGNED_INT:
   case GL_INT:
      if (clearValue)
         _mesa_unpack_uint_rgba_row(format, 1, clearValue,
                                    (GLuint (*)[4]) colorValue.ui);
      else
         memset(&colorValue, 0, sizeof colorValue);
      if (datatype == GL_INT)
         _mesa_ClearBufferiv(GL_COLOR, 0, colorValue.i);
      else
         _mesa_ClearBufferuiv(GL_COLOR, 0, colorValue.ui);
      break;
   default:
      if (clearValue)
         _mesa_unpack_rgba_row(format, 1, clearValue,
                               (GLfloat (*)[4]) colorValue.f);
      else
         memset(&colorValue, 0, sizeof colorValue);
      _mesa_ClearBufferfv(GL_COLOR, 0, colorValue.f);
      break;
   }

   return true;
}

static bool
cleartexsubimage_depth_stencil(struct gl_context *ctx,
                               struct gl_texture_image *texImage,
                               const GLvoid *clearValue,
                               GLint zoffset)
{
   GLint stencilValue;
   GLfloat depthValue;
   GLenum status;

   _mesa_meta_bind_fbo_image(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
                             texImage, zoffset);

   if (texImage->_BaseFormat == GL_DEPTH_STENCIL)
      _mesa_meta_bind_fbo_image(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT,
                                texImage, zoffset);

   status = _mesa_CheckFramebufferStatus(GL_DRAW_FRAMEBUFFER);
   if (status != GL_FRAMEBUFFER_COMPLETE)
      return false;

   if (clearValue) {
      GLuint depthStencilValue[2];

      /* Convert the clearValue from whatever format it's in to a floating
       * point value for the depth and an integer value for the stencil index
       */
      _mesa_unpack_float_32_uint_24_8_depth_stencil_row(texImage->TexFormat,
                                                        1, /* n */
                                                        clearValue,
                                                        depthStencilValue);
      /* We need a memcpy here instead of a cast because we need to
       * reinterpret the bytes as a float rather than converting it
       */
      memcpy(&depthValue, depthStencilValue, sizeof depthValue);
      stencilValue = depthStencilValue[1] & 0xff;
   } else {
      depthValue = 0.0f;
      stencilValue = 0;
   }

   if (texImage->_BaseFormat == GL_DEPTH_STENCIL)
      _mesa_ClearBufferfi(GL_DEPTH_STENCIL, 0, depthValue, stencilValue);
   else
      _mesa_ClearBufferfv(GL_DEPTH, 0, &depthValue);

   return true;
}

static bool
cleartexsubimage_for_zoffset(struct gl_context *ctx,
                             struct gl_texture_image *texImage,
                             GLint zoffset,
                             const GLvoid *clearValue)
{
   GLuint fbo;
   bool success;

   _mesa_GenFramebuffers(1, &fbo);
   _mesa_BindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo);

   switch(texImage->_BaseFormat) {
   case GL_DEPTH_STENCIL:
   case GL_DEPTH_COMPONENT:
      success = cleartexsubimage_depth_stencil(ctx, texImage,
                                               clearValue, zoffset);
      break;
   default:
      success = cleartexsubimage_color(ctx, texImage, clearValue, zoffset);
      break;
   }

   _mesa_DeleteFramebuffers(1, &fbo);

   return success;
}

static bool
cleartexsubimage_using_fbo(struct gl_context *ctx,
                           struct gl_texture_image *texImage,
                           GLint xoffset, GLint yoffset, GLint zoffset,
                           GLsizei width, GLsizei height, GLsizei depth,
                           const GLvoid *clearValue)
{
   bool success = true;
   GLint z;

   _mesa_meta_begin(ctx,
                    MESA_META_SCISSOR |
                    MESA_META_COLOR_MASK |
                    MESA_META_DITHER |
                    MESA_META_FRAMEBUFFER_SRGB);

   _mesa_set_enable(ctx, GL_DITHER, GL_FALSE);

   _mesa_set_enable(ctx, GL_SCISSOR_TEST, GL_TRUE);
   _mesa_Scissor(xoffset, yoffset, width, height);

   for (z = zoffset; z < zoffset + depth; z++) {
      if (!cleartexsubimage_for_zoffset(ctx, texImage, z, clearValue)) {
         success = false;
         break;
      }
   }

   _mesa_meta_end(ctx);

   return success;
}

extern void
_mesa_meta_ClearTexSubImage(struct gl_context *ctx,
                            struct gl_texture_image *texImage,
                            GLint xoffset, GLint yoffset, GLint zoffset,
                            GLsizei width, GLsizei height, GLsizei depth,
                            const GLvoid *clearValue)
{
   bool res;

   res = cleartexsubimage_using_fbo(ctx, texImage,
                                    xoffset, yoffset, zoffset,
                                    width, height, depth,
                                    clearValue);

   if (res)
      return;

   _mesa_warning(ctx,
                 "Falling back to mapping the texture in "
                 "glClearTexSubImage\n");

   _mesa_store_cleartexsubimage(ctx, texImage,
                                xoffset, yoffset, zoffset,
                                width, height, depth,
                                clearValue);
@


1.9
log
@Merge Mesa 10.2.7
@
text
@d43 1
d51 1
d76 1
d87 1
a87 1
#include "../glsl/ralloc.h"
d104 1
a104 1
_mesa_meta_bind_fbo_image(GLenum attachment,
d109 1
a109 1
   GLenum target = texObj->Target;
d111 1
a111 1
   switch (target) {
d113 1
a113 1
      _mesa_FramebufferTexture1D(GL_FRAMEBUFFER,
d115 1
a115 1
                                 target,
d124 1
a124 1
      _mesa_FramebufferTextureLayer(GL_FRAMEBUFFER,
d131 2
a132 2
      if (target == GL_TEXTURE_CUBE_MAP)
         target = GL_TEXTURE_CUBE_MAP_POSITIVE_X + texImage->Face;
d134 1
a134 1
      _mesa_FramebufferTexture2D(GL_FRAMEBUFFER,
d136 1
a136 1
                                 target,
d223 1
a230 1
   _mesa_ObjectLabel(GL_PROGRAM, *program, -1, name);
a398 19
static GLenum
gl_buffer_index_to_drawbuffers_enum(gl_buffer_index bufindex)
{
   assert(bufindex < BUFFER_COUNT);

   if (bufindex >= BUFFER_COLOR0)
      return GL_COLOR_ATTACHMENT0 + bufindex - BUFFER_COLOR0;
   else if (bufindex == BUFFER_FRONT_LEFT)
      return GL_FRONT_LEFT;
   else if (bufindex == BUFFER_FRONT_RIGHT)
      return GL_FRONT_RIGHT;
   else if (bufindex == BUFFER_BACK_LEFT)
      return GL_BACK_LEFT;
   else if (bufindex == BUFFER_BACK_RIGHT)
      return GL_BACK_RIGHT;

   return GL_NONE;
}

d492 5
d683 6
d796 3
a798 14
      int buf, real_color_buffers = 0;
      memset(save->ColorDrawBuffers, 0, sizeof(save->ColorDrawBuffers));

      for (buf = 0; buf < ctx->Const.MaxDrawBuffers; buf++) {
         int buf_index = ctx->DrawBuffer->_ColorDrawBufferIndexes[buf];
         if (buf_index == -1)
            continue;

         save->ColorDrawBuffers[buf] =
            gl_buffer_index_to_drawbuffers_enum(buf_index);

         if (++real_color_buffers >= ctx->DrawBuffer->_NumColorDrawBuffers)
            break;
      }
d862 3
d1090 3
d1206 1
a1206 1
      _mesa_DrawBuffers(ctx->Const.MaxDrawBuffers, save->ColorDrawBuffers);
d1232 1
a1232 1
static INLINE GLfloat
d1508 2
d1513 3
a1517 13
   const char *gs_source =
      "#version 150\n"
      "layout(triangles) in;\n"
      "layout(triangle_strip, max_vertices = 4) out;\n"
      "uniform int layer;\n"
      "void main()\n"
      "{\n"
      "  for (int i = 0; i < 3; i++) {\n"
      "    gl_Layer = layer;\n"
      "    gl_Position = gl_in[i].gl_Position;\n"
      "    EmitVertex();\n"
      "  }\n"
      "}\n";
d1524 1
a1524 1
   GLuint vs, gs = 0, fs;
a1535 6
   if (_mesa_has_geometry_shaders(ctx)) {
      gs = _mesa_CreateShader(GL_GEOMETRY_SHADER);
      _mesa_ShaderSource(gs, 1, &gs_source, NULL);
      _mesa_CompileShader(gs);
   }

a1542 2
   if (gs != 0)
      _mesa_AttachShader(clear->ShaderProg, gs);
d1546 1
d1549 1
a1549 6
   clear->ColorLocation = _mesa_GetUniformLocation(clear->ShaderProg,
						      "color");
   if (gs != 0) {
      clear->LayerLocation = _mesa_GetUniformLocation(clear->ShaderProg,
						      "layer");
   }
d1559 2
d1564 3
a1588 2
      if (gs != 0)
         _mesa_AttachShader(clear->IntegerShaderProg, gs);
a1603 4
      if (gs != 0) {
         clear->IntegerLayerLocation =
            _mesa_GetUniformLocation(clear->IntegerShaderProg, "layer");
      }
a1604 2
   if (gs != 0)
      _mesa_DeleteShader(gs);
d1632 2
a1633 2
static void
drawbuffers_from_bitfield(GLbitfield bits)
d1746 1
a1746 1
      drawbuffers_from_bitfield(buffers & BUFFER_BITS_COLOR);
d1811 1
a1811 9
      unsigned layer;
      assert(glsl);
      for (layer = 0; layer < fb->MaxNumLayers; layer++) {
         if (fb->_IntegerColor)
            _mesa_Uniform1i(clear->IntegerLayerLocation, layer);
         else
            _mesa_Uniform1i(clear->LayerLocation, layer);
         _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
      }
d2574 1
a2574 1
            assert(0);
d2704 1
a2705 1
   GLenum datatype = _mesa_get_format_datatype(format);
d2724 1
a2724 1
   case GL_DEPTH_COMPONENT: {
d2729 1
a2729 3
   }
   case GL_DEPTH_STENCIL: {
      GLenum datatype = _mesa_get_format_datatype(format);
a2733 1
   }
a2754 1
   struct gl_texture_object *texObj = texImage->TexObject;
a2762 2
   _mesa_unlock_texture(ctx, texObj);

d2770 2
a2771 1
      _mesa_meta_bind_fbo_image(GL_DEPTH_ATTACHMENT, texImage, zoffset);
d2776 2
a2777 1
         _mesa_meta_bind_fbo_image(GL_STENCIL_ATTACHMENT, texImage, zoffset);
d2782 2
a2783 1
      _mesa_meta_bind_fbo_image(GL_COLOR_ATTACHMENT0, texImage, zoffset);
a2812 1
   _mesa_lock_texture(ctx, texObj);
a2829 1
   struct gl_texture_object *texObj = texImage->TexObject;
a2873 2
   _mesa_unlock_texture(ctx, texObj); /* need to unlock first */

a2901 2
   _mesa_lock_texture(ctx, texObj); /* re-lock */

d2905 10
d2919 2
a2920 4
   if (decompress->FBO != 0) {
      _mesa_DeleteFramebuffers(1, &decompress->FBO);
      _mesa_DeleteRenderbuffers(1, &decompress->RBO);
   }
d2942 1
a2942 1
static void
d2950 1
d2956 1
d2960 1
d2964 13
d2987 1
a2987 1
      return;
d2991 1
a2991 1
      return;
d3013 5
a3017 5
   if (decompress->FBO == 0) {
      _mesa_GenFramebuffers(1, &decompress->FBO);
      _mesa_GenRenderbuffers(1, &decompress->RBO);
      _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, decompress->FBO);
      _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, decompress->RBO);
d3021 1
a3021 1
                                       decompress->RBO);
d3024 1
a3024 1
      _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, decompress->FBO);
d3028 14
a3041 6
   if (width > decompress->Width || height > decompress->Height) {
      _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, decompress->RBO);
      _mesa_RenderbufferStorage(GL_RENDERBUFFER_EXT, GL_RGBA,
                                   width, height);
      decompress->Width = width;
      decompress->Height = height;
d3163 2
d3178 1
a3178 8
   /* We can only use the decompress-with-blit method here if the texels are
    * unsigned, normalized values.  We could handle signed and unnormalized 
    * with floating point renderbuffers...
    */
   if (_mesa_is_format_compressed(texImage->TexFormat) &&
       _mesa_get_format_datatype(texImage->TexFormat)
       == GL_UNSIGNED_NORMALIZED) {
      struct gl_texture_object *texObj = texImage->TexObject;
d3180 2
a3181 2
      /* Need to unlock the texture here to prevent deadlock... */
      _mesa_unlock_texture(ctx, texObj);
d3201 4
a3204 1
         decompress_texture_image(ctx, texImage, slice, format, type, dst);
d3206 3
a3208 5
      /* ... and relock it */
      _mesa_lock_texture(ctx, texObj);
   }
   else {
      _mesa_get_teximage(ctx, format, type, pixels, texImage);
d3210 2
d3338 185
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d2744 3
a2746 3
   GLenum baseFormat;

   baseFormat = _mesa_get_format_base_format(format);
d2757 3
a2759 1
      if (ctx->DrawBuffer->Visual.redBits <= 8) {
d2761 1
a2761 1
      } else if (ctx->DrawBuffer->Visual.redBits <= 16) {
a2762 5
      } else {
         GLenum datatype = _mesa_get_format_datatype(format);
         if (datatype == GL_INT || datatype == GL_UNSIGNED_INT)
            return datatype;
         return GL_FLOAT;
d2764 1
a2765 1
      GLenum datatype = _mesa_get_format_datatype(format);
@


1.7
log
@Merge Mesa 9.2.3
ok mpi@@ kettenis@@
@
text
@d40 1
d55 3
d89 2
a90 7
/**
 * State which we may save/restore across meta ops.
 * XXX this may be incomplete...
 */
struct save_state
{
   GLbitfield SavedState;  /**< bitmask of MESA_META_* flags */
d92 2
a93 2
   /** MESA_META_CLEAR (and others?) */
   struct gl_query_object *CurrentOcclusionObject;
d95 4
a98 106
   /** MESA_META_ALPHA_TEST */
   GLboolean AlphaEnabled;
   GLenum AlphaFunc;
   GLclampf AlphaRef;

   /** MESA_META_BLEND */
   GLbitfield BlendEnabled;
   GLboolean ColorLogicOpEnabled;

   /** MESA_META_COLOR_MASK */
   GLubyte ColorMask[MAX_DRAW_BUFFERS][4];

   /** MESA_META_DEPTH_TEST */
   struct gl_depthbuffer_attrib Depth;

   /** MESA_META_FOG */
   GLboolean Fog;

   /** MESA_META_PIXEL_STORE */
   struct gl_pixelstore_attrib Pack, Unpack;

   /** MESA_META_PIXEL_TRANSFER */
   GLfloat RedBias, RedScale;
   GLfloat GreenBias, GreenScale;
   GLfloat BlueBias, BlueScale;
   GLfloat AlphaBias, AlphaScale;
   GLfloat DepthBias, DepthScale;
   GLboolean MapColorFlag;

   /** MESA_META_RASTERIZATION */
   GLenum FrontPolygonMode, BackPolygonMode;
   GLboolean PolygonOffset;
   GLboolean PolygonSmooth;
   GLboolean PolygonStipple;
   GLboolean PolygonCull;

   /** MESA_META_SCISSOR */
   struct gl_scissor_attrib Scissor;

   /** MESA_META_SHADER */
   GLboolean VertexProgramEnabled;
   struct gl_vertex_program *VertexProgram;
   GLboolean FragmentProgramEnabled;
   struct gl_fragment_program *FragmentProgram;
   GLboolean ATIFragmentShaderEnabled;
   struct gl_shader_program *VertexShader;
   struct gl_shader_program *GeometryShader;
   struct gl_shader_program *FragmentShader;
   struct gl_shader_program *ActiveShader;

   /** MESA_META_STENCIL_TEST */
   struct gl_stencil_attrib Stencil;

   /** MESA_META_TRANSFORM */
   GLenum MatrixMode;
   GLfloat ModelviewMatrix[16];
   GLfloat ProjectionMatrix[16];
   GLfloat TextureMatrix[16];

   /** MESA_META_CLIP */
   GLbitfield ClipPlanesEnabled;

   /** MESA_META_TEXTURE */
   GLuint ActiveUnit;
   GLuint ClientActiveUnit;
   /** for unit[0] only */
   struct gl_texture_object *CurrentTexture[NUM_TEXTURE_TARGETS];
   /** mask of TEXTURE_2D_BIT, etc */
   GLbitfield TexEnabled[MAX_TEXTURE_UNITS];
   GLbitfield TexGenEnabled[MAX_TEXTURE_UNITS];
   GLuint EnvMode;  /* unit[0] only */

   /** MESA_META_VERTEX */
   struct gl_array_object *ArrayObj;
   struct gl_buffer_object *ArrayBufferObj;

   /** MESA_META_VIEWPORT */
   GLint ViewportX, ViewportY, ViewportW, ViewportH;
   GLclampd DepthNear, DepthFar;

   /** MESA_META_CLAMP_FRAGMENT_COLOR */
   GLenum ClampFragmentColor;

   /** MESA_META_CLAMP_VERTEX_COLOR */
   GLenum ClampVertexColor;

   /** MESA_META_CONDITIONAL_RENDER */
   struct gl_query_object *CondRenderQuery;
   GLenum CondRenderMode;

   /** MESA_META_SELECT_FEEDBACK */
   GLenum RenderMode;
   struct gl_selection Select;
   struct gl_feedback Feedback;

   /** MESA_META_MULTISAMPLE */
   GLboolean MultisampleEnabled;

   /** MESA_META_FRAMEBUFFER_SRGB */
   GLboolean sRGBEnabled;

   /** Miscellaneous (always disabled) */
   GLboolean Lighting;
   GLboolean RasterDiscard;
   GLboolean TransformFeedbackNeedsResume;
};
d100 3
a102 6
/**
 * Temporary texture used for glBlitFramebuffer, glDrawPixels, etc.
 * This is currently shared by all the meta ops.  But we could create a
 * separate one for each of glDrawPixel, glBlitFramebuffer, glCopyPixels, etc.
 */
struct temp_texture
d104 3
a106 9
   GLuint TexObj;
   GLenum Target;         /**< GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE */
   GLsizei MinSize;       /**< Min texture size to allocate */
   GLsizei MaxSize;       /**< Max possible texture size */
   GLboolean NPOT;        /**< Non-power of two size OK? */
   GLsizei Width, Height; /**< Current texture size */
   GLenum IntFormat;
   GLfloat Sright, Ttop;  /**< right, top texcoords */
};
d108 22
d131 7
a137 137
/**
 * State for glBlitFramebufer()
 */
struct blit_state
{
   GLuint ArrayObj;
   GLuint VBO;
   GLuint DepthFP;
   GLuint ShaderProg;
   GLuint RectShaderProg;
   struct temp_texture depthTex;
};


/**
 * State for glClear()
 */
struct clear_state
{
   GLuint ArrayObj;
   GLuint VBO;
   GLuint ShaderProg;
   GLint ColorLocation;

   GLuint IntegerShaderProg;
   GLint IntegerColorLocation;
};


/**
 * State for glCopyPixels()
 */
struct copypix_state
{
   GLuint ArrayObj;
   GLuint VBO;
};


/**
 * State for glDrawPixels()
 */
struct drawpix_state
{
   GLuint ArrayObj;

   GLuint StencilFP;  /**< Fragment program for drawing stencil images */
   GLuint DepthFP;  /**< Fragment program for drawing depth images */
};


/**
 * State for glBitmap()
 */
struct bitmap_state
{
   GLuint ArrayObj;
   GLuint VBO;
   struct temp_texture Tex;  /**< separate texture from other meta ops */
};

/**
 * State for GLSL texture sampler which is used to generate fragment
 * shader in _mesa_meta_generate_mipmap().
 */
struct glsl_sampler {
   const char *type;
   const char *func;
   const char *texcoords;
   GLuint shader_prog;
};

/**
 * State for _mesa_meta_generate_mipmap()
 */
struct gen_mipmap_state
{
   GLuint ArrayObj;
   GLuint VBO;
   GLuint FBO;
   GLuint Sampler;
   GLuint ShaderProg;
   struct glsl_sampler sampler_1d;
   struct glsl_sampler sampler_2d;
   struct glsl_sampler sampler_3d;
   struct glsl_sampler sampler_cubemap;
   struct glsl_sampler sampler_1d_array;
   struct glsl_sampler sampler_2d_array;
};

/**
 * State for texture decompression
 */
struct decompress_state
{
   GLuint ArrayObj;
   GLuint VBO, FBO, RBO, Sampler;
   GLint Width, Height;
};

/**
 * State for glDrawTex()
 */
struct drawtex_state
{
   GLuint ArrayObj;
   GLuint VBO;
};

#define MAX_META_OPS_DEPTH      8
/**
 * All per-context meta state.
 */
struct gl_meta_state
{
   /** Stack of state saved during meta-ops */
   struct save_state Save[MAX_META_OPS_DEPTH];
   /** Save stack depth */
   GLuint SaveStackDepth;

   struct temp_texture TempTex;

   struct blit_state Blit;    /**< For _mesa_meta_BlitFramebuffer() */
   struct clear_state Clear;  /**< For _mesa_meta_Clear() */
   struct copypix_state CopyPix;  /**< For _mesa_meta_CopyPixels() */
   struct drawpix_state DrawPix;  /**< For _mesa_meta_DrawPixels() */
   struct bitmap_state Bitmap;    /**< For _mesa_meta_Bitmap() */
   struct gen_mipmap_state Mipmap;    /**< For _mesa_meta_GenerateMipmap() */
   struct decompress_state Decompress;  /**< For texture decompression */
   struct drawtex_state DrawTex;  /**< For _mesa_meta_DrawTex() */
};

static void meta_glsl_blit_cleanup(struct gl_context *ctx, struct blit_state *blit);
static void cleanup_temp_texture(struct gl_context *ctx, struct temp_texture *tex);
static void meta_glsl_clear_cleanup(struct gl_context *ctx, struct clear_state *clear);
static void meta_glsl_generate_mipmap_cleanup(struct gl_context *ctx,
                                              struct gen_mipmap_state *mipmap);
d139 3
a141 2
static GLuint
compile_shader_with_debug(struct gl_context *ctx, GLenum target, const GLcharARB *source)
d147 1
a147 1
   shader = _mesa_CreateShaderObjectARB(target);
d157 1
a157 1
      _mesa_DeleteObjectARB(shader);
d163 1
a163 1
      _mesa_DeleteObjectARB(shader);
d167 1
a167 1
   _mesa_GetProgramInfoLog(shader, size, NULL, info);
d174 1
a174 1
   _mesa_DeleteObjectARB(shader);
d179 2
a180 2
static GLuint
link_program_with_debug(struct gl_context *ctx, GLuint program)
d207 177
d396 18
d424 6
a429 4
   meta_glsl_blit_cleanup(ctx, &ctx->Meta->Blit);
   meta_glsl_clear_cleanup(ctx, &ctx->Meta->Clear);
   meta_glsl_generate_mipmap_cleanup(ctx, &ctx->Meta->Mipmap);
   cleanup_temp_texture(ctx, &ctx->Meta->TempTex);
d458 7
d524 1
a524 3
   if ((state & MESA_META_FOG)
       && ctx->API != API_OPENGL_CORE
       && ctx->API != API_OPENGLES2) {
d569 2
a570 4
      if (ctx->API == API_OPENGL_COMPAT) {
         _mesa_set_enable(ctx, GL_POLYGON_SMOOTH, GL_FALSE);
         _mesa_set_enable(ctx, GL_POLYGON_STIPPLE, GL_FALSE);
      }
d580 3
a582 1
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_vertex_program) {
d589 1
a589 1
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_fragment_program) {
d596 1
a596 1
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ATI_fragment_shader) {
d601 13
a613 6
      _mesa_reference_shader_program(ctx, &save->VertexShader,
                                     ctx->Shader.CurrentVertexProgram);
      _mesa_reference_shader_program(ctx, &save->GeometryShader,
                                     ctx->Shader.CurrentGeometryProgram);
      _mesa_reference_shader_program(ctx, &save->FragmentShader,
                                     ctx->Shader.CurrentFragmentProgram);
d635 18
a652 27
      if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES) {
         for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
            save->TexEnabled[u] = ctx->Texture.Unit[u].Enabled;
            save->TexGenEnabled[u] = ctx->Texture.Unit[u].TexGenEnabled;
            if (ctx->Texture.Unit[u].Enabled ||
                ctx->Texture.Unit[u].TexGenEnabled) {
               _mesa_ActiveTexture(GL_TEXTURE0 + u);
               _mesa_set_enable(ctx, GL_TEXTURE_2D, GL_FALSE);
               if (ctx->Extensions.ARB_texture_cube_map)
                  _mesa_set_enable(ctx, GL_TEXTURE_CUBE_MAP, GL_FALSE);
               if (_mesa_is_gles(ctx) &&
                   ctx->Extensions.OES_EGL_image_external)
                  _mesa_set_enable(ctx, GL_TEXTURE_EXTERNAL_OES, GL_FALSE);

               if (ctx->API == API_OPENGL_COMPAT) {
                  _mesa_set_enable(ctx, GL_TEXTURE_1D, GL_FALSE);
                  _mesa_set_enable(ctx, GL_TEXTURE_3D, GL_FALSE);
                  if (ctx->Extensions.NV_texture_rectangle)
                     _mesa_set_enable(ctx, GL_TEXTURE_RECTANGLE, GL_FALSE);
                  _mesa_set_enable(ctx, GL_TEXTURE_GEN_S, GL_FALSE);
                  _mesa_set_enable(ctx, GL_TEXTURE_GEN_T, GL_FALSE);
                  _mesa_set_enable(ctx, GL_TEXTURE_GEN_R, GL_FALSE);
                  _mesa_set_enable(ctx, GL_TEXTURE_GEN_Q, GL_FALSE);
               } else {
                  _mesa_set_enable(ctx, GL_TEXTURE_GEN_STR_OES, GL_FALSE);
               }
            }
d665 1
a665 3
      if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES) {
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
      }
d708 2
a709 2
      _mesa_reference_array_object(ctx, &save->ArrayObj,
                                   ctx->Array.ArrayObj);
d717 4
a720 4
      save->ViewportX = ctx->Viewport.X;
      save->ViewportY = ctx->Viewport.Y;
      save->ViewportW = ctx->Viewport.Width;
      save->ViewportH = ctx->Viewport.Height;
d722 5
a726 5
      if (ctx->Viewport.X != 0 ||
          ctx->Viewport.Y != 0 ||
          ctx->Viewport.Width != ctx->DrawBuffer->Width ||
          ctx->Viewport.Height != ctx->DrawBuffer->Height) {
         _mesa_set_viewport(ctx, 0, 0,
d730 2
a731 2
      save->DepthNear = ctx->Viewport.Near;
      save->DepthFar = ctx->Viewport.Far;
d778 2
a779 1
      save->MultisampleEnabled = ctx->Multisample.Enabled;
d782 10
d800 17
d825 5
d842 1
d904 1
a904 3
   if ((state & MESA_META_FOG)
       && ctx->API != API_OPENGL_CORE
       && ctx->API != API_OPENGLES2) {
d928 4
a931 12
      /* Core context requires that front and back mode be the same.
       */
      if (ctx->API == API_OPENGL_CORE) {
         _mesa_PolygonMode(GL_FRONT_AND_BACK, save->FrontPolygonMode);
      } else {
         _mesa_PolygonMode(GL_FRONT, save->FrontPolygonMode);
         _mesa_PolygonMode(GL_BACK, save->BackPolygonMode);
      }
      if (ctx->API == API_OPENGL_COMPAT) {
         _mesa_set_enable(ctx, GL_POLYGON_STIPPLE, save->PolygonStipple);
         _mesa_set_enable(ctx, GL_POLYGON_SMOOTH, save->PolygonSmooth);
      }
d937 11
a947 3
      _mesa_set_enable(ctx, GL_SCISSOR_TEST, save->Scissor.Enabled);
      _mesa_Scissor(save->Scissor.X, save->Scissor.Y,
                    save->Scissor.Width, save->Scissor.Height);
d951 9
a959 1
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_vertex_program) {
d967 1
a967 1
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_fragment_program) {
d975 1
a975 1
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ATI_fragment_shader) {
d980 16
a995 2
      if (ctx->Extensions.ARB_vertex_shader)
	 _mesa_use_shader_program(ctx, GL_VERTEX_SHADER, save->VertexShader);
d997 2
a998 7
      if (ctx->Extensions.ARB_geometry_shader4)
	 _mesa_use_shader_program(ctx, GL_GEOMETRY_SHADER_ARB,
				  save->GeometryShader);

      if (ctx->Extensions.ARB_fragment_shader)
	 _mesa_use_shader_program(ctx, GL_FRAGMENT_SHADER,
				  save->FragmentShader);
d1001 13
a1013 1
				     save->ActiveShader);
d1015 5
a1019 4
      _mesa_reference_shader_program(ctx, &save->VertexShader, NULL);
      _mesa_reference_shader_program(ctx, &save->GeometryShader, NULL);
      _mesa_reference_shader_program(ctx, &save->FragmentShader, NULL);
      _mesa_reference_shader_program(ctx, &save->ActiveShader, NULL);
d1027 1
a1027 1
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.EXT_stencil_two_side) {
d1059 1
a1059 3
      if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES) {
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, save->EnvMode);
      }
d1072 5
a1076 6
      if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES) {
         for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
            if (ctx->Texture.Unit[u].Enabled != save->TexEnabled[u]) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               ctx->Texture.Unit[u].Enabled = save->TexEnabled[u];
            }
d1078 3
a1080 4
            if (ctx->Texture.Unit[u].TexGenEnabled != save->TexGenEnabled[u]) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               ctx->Texture.Unit[u].TexGenEnabled = save->TexGenEnabled[u];
            }
d1122 2
a1123 2
      _mesa_BindVertexArray(save->ArrayObj->Name);
      _mesa_reference_array_object(ctx, &save->ArrayObj, NULL);
d1127 5
a1131 5
      if (save->ViewportX != ctx->Viewport.X ||
          save->ViewportY != ctx->Viewport.Y ||
          save->ViewportW != ctx->Viewport.Width ||
          save->ViewportH != ctx->Viewport.Height) {
         _mesa_set_viewport(ctx, save->ViewportX, save->ViewportY,
d1164 24
a1187 2
      if (ctx->Multisample.Enabled != save->MultisampleEnabled)
         _mesa_set_multisample(ctx, save->MultisampleEnabled);
d1205 14
d1220 2
d1276 1
a1276 1
cleanup_temp_texture(struct gl_context *ctx, struct temp_texture *tex)
d1289 2
a1290 2
static struct temp_texture *
get_temp_texture(struct gl_context *ctx)
d1323 2
a1324 2
static struct temp_texture *
get_temp_depth_texture(struct gl_context *ctx)
d1344 3
a1346 3
static GLboolean
alloc_texture(struct temp_texture *tex,
              GLsizei width, GLsizei height, GLenum intFormat)
d1397 7
a1403 7
static void
setup_copypix_texture(struct gl_context *ctx,
                      struct temp_texture *tex,
                      GLboolean newTex,
                      GLint srcX, GLint srcY,
                      GLsizei width, GLsizei height, GLenum intFormat,
                      GLenum filter)
d1405 2
d1410 3
a1412 2
   if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES)
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
d1443 7
a1449 8
static void
setup_drawpix_texture(struct gl_context *ctx,
		      struct temp_texture *tex,
                      GLboolean newTex,
                      GLenum texIntFormat,
                      GLsizei width, GLsizei height,
                      GLenum format, GLenum type,
                      const GLvoid *pixels)
d1454 1
a1454 2
   if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES)
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
d1488 5
d1494 4
d1500 1
a1500 1
 * One-time init for drawing depth pixels.
d1502 2
a1503 2
static void
init_blit_depth_pixels(struct gl_context *ctx)
d1505 2
a1506 8
   static const char *program =
      "!!ARBfp1.0\n"
      "TEX result.depth, fragment.texcoord[0], texture[0], %s; \n"
      "END \n";
   char program2[200];
   struct blit_state *blit = &ctx->Meta->Blit;
   struct temp_texture *tex = get_temp_texture(ctx);
   const char *texTarget;
d1508 4
a1511 14
   assert(blit->DepthFP == 0);

   /* replace %s with "RECT" or "2D" */
   assert(strlen(program) + 4 < sizeof(program2));
   if (tex->Target == GL_TEXTURE_RECTANGLE)
      texTarget = "RECT";
   else
      texTarget = "2D";
   _mesa_snprintf(program2, sizeof(program2), program, texTarget);

   _mesa_GenProgramsARB(1, &blit->DepthFP);
   _mesa_BindProgramARB(GL_FRAGMENT_PROGRAM_ARB, blit->DepthFP);
   _mesa_ProgramStringARB(GL_FRAGMENT_PROGRAM_ARB, GL_PROGRAM_FORMAT_ASCII_ARB,
                          strlen(program2), (const GLubyte *) program2);
d1515 1
a1515 2
setup_ff_blit_framebuffer(struct gl_context *ctx,
                          struct blit_state *blit)
d1517 27
a1543 4
   struct vertex {
      GLfloat x, y, s, t;
   };
   struct vertex verts[4];
d1545 1
a1545 2
   if (blit->ArrayObj == 0) {
      /* one-time setup */
d1547 2
a1548 3
      /* create vertex array object */
      _mesa_GenVertexArrays(1, &blit->ArrayObj);
      _mesa_BindVertexArray(blit->ArrayObj);
d1550 3
a1552 5
      /* create vertex array buffer */
      _mesa_GenBuffers(1, &blit->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, blit->VBO);
      _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
                          NULL, GL_DYNAMIC_DRAW_ARB);
d1554 4
a1557 5
      /* setup vertex arrays */
      _mesa_VertexPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(x));
      _mesa_TexCoordPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(s));
      _mesa_EnableClientState(GL_VERTEX_ARRAY);
      _mesa_EnableClientState(GL_TEXTURE_COORD_ARRAY);
d1560 3
a1562 4
   /* setup projection matrix */
   _mesa_MatrixMode(GL_PROJECTION);
   _mesa_LoadIdentity();
   _mesa_Ortho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);
d1564 9
a1572 1
}
d1574 6
a1579 15
static void
setup_glsl_blit_framebuffer(struct gl_context *ctx,
                            struct blit_state *blit,
                            GLenum target)
{
   struct vertex {
      GLfloat x, y, s, t;
   };
   struct vertex verts[4];
   const char *vs_source;
   char *fs_source;
   GLuint vs, fs;
   void *mem_ctx;
   GLuint ShaderProg;
   GLboolean texture_2d = (target == GL_TEXTURE_2D);
d1581 1
a1581 698
   /* target = GL_TEXTURE_RECTANGLE is not supported in GLES 3.0 */
   assert(_mesa_is_desktop_gl(ctx) || texture_2d);

   /* Check if already initialized */
   if (blit->ArrayObj == 0) {

      /* create vertex array object */
      _mesa_GenVertexArrays(1, &blit->ArrayObj);
      _mesa_BindVertexArray(blit->ArrayObj);

      /* create vertex array buffer */
      _mesa_GenBuffers(1, &blit->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, blit->VBO);
      _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
                          NULL, GL_DYNAMIC_DRAW_ARB);

      /* setup vertex arrays */
      _mesa_VertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE,
                                   sizeof(struct vertex), OFFSET(x));
      _mesa_VertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE,
                                   sizeof(struct vertex), OFFSET(s));

      _mesa_EnableVertexAttribArray(0);
      _mesa_EnableVertexAttribArray(1);
   }

   /* Generate a relevant fragment shader program for the texture target */
   if ((target == GL_TEXTURE_2D && blit->ShaderProg != 0) ||
       (target == GL_TEXTURE_RECTANGLE && blit->RectShaderProg != 0)) {
      return;
   }

   mem_ctx = ralloc_context(NULL);

   if (ctx->Const.GLSLVersion < 130) {
      vs_source =
         "attribute vec2 position;\n"
         "attribute vec2 textureCoords;\n"
         "varying vec2 texCoords;\n"
         "void main()\n"
         "{\n"
         "   texCoords = textureCoords;\n"
         "   gl_Position = vec4(position, 0.0, 1.0);\n"
         "}\n";

      fs_source = ralloc_asprintf(mem_ctx,
                                  "#ifdef GL_ES\n"
                                  "precision highp float;\n"
                                  "#endif\n"
                                  "uniform %s texSampler;\n"
                                  "varying vec2 texCoords;\n"
                                  "void main()\n"
                                  "{\n"
                                  "   gl_FragColor = %s(texSampler, texCoords);\n"
                                  "   gl_FragDepth = gl_FragColor.r;\n"
                                  "}\n",
                                  texture_2d ? "sampler2D" : "sampler2DRect",
                                  texture_2d ? "texture2D" : "texture2DRect");
   }
   else {
      vs_source = ralloc_asprintf(mem_ctx,
                                  "#version %s\n"
                                  "in vec2 position;\n"
                                  "in vec2 textureCoords;\n"
                                  "out vec2 texCoords;\n"
                                  "void main()\n"
                                  "{\n"
                                  "   texCoords = textureCoords;\n"
                                  "   gl_Position = vec4(position, 0.0, 1.0);\n"
                                  "}\n",
                                  _mesa_is_desktop_gl(ctx) ? "130" : "300 es");
      fs_source = ralloc_asprintf(mem_ctx,
                                  "#version %s\n"
                                  "#ifdef GL_ES\n"
                                  "precision highp float;\n"
                                  "#endif\n"
                                  "uniform %s texSampler;\n"
                                  "in vec2 texCoords;\n"
                                  "out vec4 out_color;\n"
                                  "\n"
                                  "void main()\n"
                                  "{\n"
                                  "   out_color = %s(texSampler, texCoords);\n"
                                  "   gl_FragDepth = out_color.r;\n"
                                  "}\n",
                                  _mesa_is_desktop_gl(ctx) ? "130" : "300 es",
                                  texture_2d ? "sampler2D" : "sampler2DRect",
                                  texture_2d ? "texture" : "texture2DRect");
   }

   vs = compile_shader_with_debug(ctx, GL_VERTEX_SHADER, vs_source);
   fs = compile_shader_with_debug(ctx, GL_FRAGMENT_SHADER, fs_source);

   ShaderProg = _mesa_CreateProgramObjectARB();
   _mesa_AttachShader(ShaderProg, fs);
   _mesa_DeleteObjectARB(fs);
   _mesa_AttachShader(ShaderProg, vs);
   _mesa_DeleteObjectARB(vs);
   _mesa_BindAttribLocation(ShaderProg, 0, "position");
   _mesa_BindAttribLocation(ShaderProg, 1, "texcoords");
   link_program_with_debug(ctx, ShaderProg);
   ralloc_free(mem_ctx);
   if (texture_2d)
      blit->ShaderProg = ShaderProg;
   else
      blit->RectShaderProg = ShaderProg;
}

/**
 * Try to do a glBlitFramebuffer using no-copy texturing.
 * We can do this when the src renderbuffer is actually a texture.
 * But if the src buffer == dst buffer we cannot do this.
 *
 * \return new buffer mask indicating the buffers left to blit using the
 *         normal path.
 */
static GLbitfield
blitframebuffer_texture(struct gl_context *ctx,
                        GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
                        GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
                        GLbitfield mask, GLenum filter, GLint flipX,
                        GLint flipY, GLboolean glsl_version)
{
   if (mask & GL_COLOR_BUFFER_BIT) {
      const struct gl_framebuffer *drawFb = ctx->DrawBuffer;
      const struct gl_framebuffer *readFb = ctx->ReadBuffer;
      const struct gl_renderbuffer_attachment *drawAtt;
      const struct gl_renderbuffer_attachment *readAtt =
         &readFb->Attachment[readFb->_ColorReadBufferIndex];

      if (readAtt && readAtt->Texture) {
         struct blit_state *blit = &ctx->Meta->Blit;
         const GLint dstX = MIN2(dstX0, dstX1);
         const GLint dstY = MIN2(dstY0, dstY1);
         const GLint dstW = abs(dstX1 - dstX0);
         const GLint dstH = abs(dstY1 - dstY0);
         const struct gl_texture_object *texObj = readAtt->Texture;
         const GLuint srcLevel = readAtt->TextureLevel;
         const GLint baseLevelSave = texObj->BaseLevel;
         const GLint maxLevelSave = texObj->MaxLevel;
         const GLenum target = texObj->Target;
         GLuint sampler, samplerSave =
            ctx->Texture.Unit[ctx->Texture.CurrentUnit].Sampler ?
            ctx->Texture.Unit[ctx->Texture.CurrentUnit].Sampler->Name : 0;
         int i;

         /* Iterate through all draw buffers */
         for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++) {
            int idx = ctx->DrawBuffer->_ColorDrawBufferIndexes[i];
            if (idx == -1)
               continue;
            drawAtt = &drawFb->Attachment[idx];

            if (drawAtt->Texture == readAtt->Texture) {
               /* Can't use same texture as both the source and dest.  We need
                * to handle overlapping blits and besides, some hw may not
                * support this.
                */
               return mask;
            }
         }

         if (target != GL_TEXTURE_2D && target != GL_TEXTURE_RECTANGLE_ARB) {
            /* Can't handle other texture types at this time */
            return mask;
         }

         /* Choose between glsl version and fixed function version of
          * BlitFramebuffer function.
          */
         if (glsl_version) {
            setup_glsl_blit_framebuffer(ctx, blit, target);
            if (target == GL_TEXTURE_2D)
               _mesa_UseProgram(blit->ShaderProg);
            else
               _mesa_UseProgram(blit->RectShaderProg);
         }
         else {
            setup_ff_blit_framebuffer(ctx, &ctx->Meta->Blit);
         }

         _mesa_BindVertexArray(blit->ArrayObj);
         _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, blit->VBO);

         _mesa_GenSamplers(1, &sampler);
         _mesa_BindSampler(ctx->Texture.CurrentUnit, sampler);

         /*
         printf("Blit from texture!\n");
         printf("  srcAtt %p  dstAtt %p\n", readAtt, drawAtt);
         printf("  srcTex %p  dstText %p\n", texObj, drawAtt->Texture);
         */

         /* Prepare src texture state */
         _mesa_BindTexture(target, texObj->Name);
         _mesa_SamplerParameteri(sampler, GL_TEXTURE_MIN_FILTER, filter);
         _mesa_SamplerParameteri(sampler, GL_TEXTURE_MAG_FILTER, filter);
         if (target != GL_TEXTURE_RECTANGLE_ARB) {
            _mesa_TexParameteri(target, GL_TEXTURE_BASE_LEVEL, srcLevel);
            _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, srcLevel);
         }
         _mesa_SamplerParameteri(sampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
         _mesa_SamplerParameteri(sampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	 /* Always do our blits with no sRGB decode or encode.  Note that
          * GL_FRAMEBUFFER_SRGB has already been disabled by
          * _mesa_meta_begin().
          */
	 if (ctx->Extensions.EXT_texture_sRGB_decode) {
	    _mesa_SamplerParameteri(sampler, GL_TEXTURE_SRGB_DECODE_EXT,
				GL_SKIP_DECODE_EXT);
	 }

         if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES) {
            _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
            _mesa_set_enable(ctx, target, GL_TRUE);
	 }

         /* Prepare vertex data (the VBO was previously created and bound) */
         {
            struct vertex {
               GLfloat x, y, s, t;
            };
            struct vertex verts[4];
            GLfloat s0, t0, s1, t1;

            if (target == GL_TEXTURE_2D) {
               const struct gl_texture_image *texImage
                   = _mesa_select_tex_image(ctx, texObj, target, srcLevel);
               s0 = srcX0 / (float) texImage->Width;
               s1 = srcX1 / (float) texImage->Width;
               t0 = srcY0 / (float) texImage->Height;
               t1 = srcY1 / (float) texImage->Height;
            }
            else {
               assert(target == GL_TEXTURE_RECTANGLE_ARB);
               s0 = srcX0;
               s1 = srcX1;
               t0 = srcY0;
               t1 = srcY1;
            }

            /* setup vertex positions */
            verts[0].x = -1.0F * flipX;
            verts[0].y = -1.0F * flipY;
            verts[1].x =  1.0F * flipX;
            verts[1].y = -1.0F * flipY;
            verts[2].x =  1.0F * flipX;
            verts[2].y =  1.0F * flipY;
            verts[3].x = -1.0F * flipX;
            verts[3].y =  1.0F * flipY;

            verts[0].s = s0;
            verts[0].t = t0;
            verts[1].s = s1;
            verts[1].t = t0;
            verts[2].s = s1;
            verts[2].t = t1;
            verts[3].s = s0;
            verts[3].t = t1;

            _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
         }

         /* setup viewport */
         _mesa_set_viewport(ctx, dstX, dstY, dstW, dstH);
         _mesa_ColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
         _mesa_DepthMask(GL_FALSE);
         _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);

         /* Restore texture object state, the texture binding will
          * be restored by _mesa_meta_end().
          */
         if (target != GL_TEXTURE_RECTANGLE_ARB) {
            _mesa_TexParameteri(target, GL_TEXTURE_BASE_LEVEL, baseLevelSave);
            _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, maxLevelSave);
         }

         _mesa_BindSampler(ctx->Texture.CurrentUnit, samplerSave);
         _mesa_DeleteSamplers(1, &sampler);

         /* Done with color buffer */
         mask &= ~GL_COLOR_BUFFER_BIT;
      }
   }

   return mask;
}


/**
 * Meta implementation of ctx->Driver.BlitFramebuffer() in terms
 * of texture mapping and polygon rendering.
 */
void
_mesa_meta_BlitFramebuffer(struct gl_context *ctx,
                           GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
                           GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
                           GLbitfield mask, GLenum filter)
{
   struct blit_state *blit = &ctx->Meta->Blit;
   struct temp_texture *tex = get_temp_texture(ctx);
   struct temp_texture *depthTex = get_temp_depth_texture(ctx);
   const GLsizei maxTexSize = tex->MaxSize;
   const GLint srcX = MIN2(srcX0, srcX1);
   const GLint srcY = MIN2(srcY0, srcY1);
   const GLint srcW = abs(srcX1 - srcX0);
   const GLint srcH = abs(srcY1 - srcY0);
   const GLint dstX = MIN2(dstX0, dstX1);
   const GLint dstY = MIN2(dstY0, dstY1);
   const GLint dstW = abs(dstX1 - dstX0);
   const GLint dstH = abs(dstY1 - dstY0);
   const GLint srcFlipX = (srcX1 - srcX0) / srcW;
   const GLint srcFlipY = (srcY1 - srcY0) / srcH;
   const GLint dstFlipX = (dstX1 - dstX0) / dstW;
   const GLint dstFlipY = (dstY1 - dstY0) / dstH;
   const GLint flipX = srcFlipX * dstFlipX;
   const GLint flipY = srcFlipY * dstFlipY;

   struct vertex {
      GLfloat x, y, s, t;
   };
   struct vertex verts[4];
   GLboolean newTex;
   const GLboolean use_glsl_version = ctx->Extensions.ARB_vertex_shader &&
                                      ctx->Extensions.ARB_fragment_shader &&
                                      (ctx->API != API_OPENGLES);

   /* In addition to falling back if the blit size is larger than the maximum
    * texture size, fallback if the source is multisampled.  This fallback can
    * be removed once Mesa gets support ARB_texture_multisample.
    */
   if (srcW > maxTexSize || srcH > maxTexSize
       || ctx->ReadBuffer->Visual.samples > 0) {
      /* XXX avoid this fallback */
      _swrast_BlitFramebuffer(ctx, srcX0, srcY0, srcX1, srcY1,
                              dstX0, dstY0, dstX1, dstY1, mask, filter);
      return;
   }

   /* only scissor effects blit so save/clear all other relevant state */
   _mesa_meta_begin(ctx, ~MESA_META_SCISSOR);

   /* Try faster, direct texture approach first */
   mask = blitframebuffer_texture(ctx, srcX0, srcY0, srcX1, srcY1,
                                  dstX0, dstY0, dstX1, dstY1, mask, filter,
                                  dstFlipX, dstFlipY, use_glsl_version);
   if (mask == 0x0) {
      _mesa_meta_end(ctx);
      return;
   }

   /* Choose between glsl version and fixed function version of
    * BlitFramebuffer function.
    */
   if (use_glsl_version) {
      setup_glsl_blit_framebuffer(ctx, blit, tex->Target);
      if (tex->Target == GL_TEXTURE_2D)
         _mesa_UseProgram(blit->ShaderProg);
      else
         _mesa_UseProgram(blit->RectShaderProg);
   }
   else {
      setup_ff_blit_framebuffer(ctx, blit);
   }

   _mesa_BindVertexArray(blit->ArrayObj);
   _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, blit->VBO);

   /* Continue with "normal" approach which involves copying the src rect
    * into a temporary texture and is "blitted" by drawing a textured quad.
    */
   {
      /* setup vertex positions */
      verts[0].x = -1.0F * flipX;
      verts[0].y = -1.0F * flipY;
      verts[1].x =  1.0F * flipX;
      verts[1].y = -1.0F * flipY;
      verts[2].x =  1.0F * flipX;
      verts[2].y =  1.0F * flipY;
      verts[3].x = -1.0F * flipX;
      verts[3].y =  1.0F * flipY;

   }

   /* glEnable() in gles2 and gles3 doesn't allow GL_TEXTURE_{1D, 2D, etc.}
    * tokens.
    */
   if (_mesa_is_desktop_gl(ctx) || ctx->API == API_OPENGLES)
      _mesa_set_enable(ctx, tex->Target, GL_TRUE);

   if (mask & GL_COLOR_BUFFER_BIT) {
      const struct gl_framebuffer *readFb = ctx->ReadBuffer;
      const struct gl_renderbuffer *colorReadRb = readFb->_ColorReadBuffer;
      const GLenum rb_base_format =
         _mesa_base_tex_format(ctx, colorReadRb->InternalFormat);

      /* Using  the exact source rectangle to create the texture does incorrect
       * linear filtering along the edges. So, allocate the texture extended along
       * edges by one pixel in x, y directions.
       */
      newTex = alloc_texture(tex, srcW + 2, srcH + 2, rb_base_format);
      setup_copypix_texture(ctx, tex, newTex,
                            srcX - 1, srcY - 1, srcW + 2, srcH + 2,
                            rb_base_format, filter);
      /* texcoords (after texture allocation!) */
      {
         verts[0].s = 1.0F;
         verts[0].t = 1.0F;
         verts[1].s = tex->Sright - 1.0F;
         verts[1].t = 1.0F;
         verts[2].s = tex->Sright - 1.0F;
         verts[2].t = tex->Ttop - 1.0F;
         verts[3].s = 1.0F;
         verts[3].t = tex->Ttop - 1.0F;

         /* upload new vertex data */
         _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
      }

      _mesa_set_viewport(ctx, dstX, dstY, dstW, dstH);
      _mesa_ColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
      _mesa_set_enable(ctx, GL_DEPTH_TEST, GL_FALSE);
      _mesa_DepthMask(GL_FALSE);
      _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
      mask &= ~GL_COLOR_BUFFER_BIT;
   }

   if ((mask & GL_DEPTH_BUFFER_BIT) &&
       _mesa_is_desktop_gl(ctx) &&
       ctx->Extensions.ARB_depth_texture &&
       ctx->Extensions.ARB_fragment_program) {

      GLuint *tmp = malloc(srcW * srcH * sizeof(GLuint));

      if (tmp) {

         newTex = alloc_texture(depthTex, srcW, srcH, GL_DEPTH_COMPONENT);
         _mesa_ReadPixels(srcX, srcY, srcW, srcH, GL_DEPTH_COMPONENT,
                          GL_UNSIGNED_INT, tmp);
         setup_drawpix_texture(ctx, depthTex, newTex, GL_DEPTH_COMPONENT,
                               srcW, srcH, GL_DEPTH_COMPONENT,
                               GL_UNSIGNED_INT, tmp);

         /* texcoords (after texture allocation!) */
         {
            verts[0].s = 0.0F;
            verts[0].t = 0.0F;
            verts[1].s = depthTex->Sright;
            verts[1].t = 0.0F;
            verts[2].s = depthTex->Sright;
            verts[2].t = depthTex->Ttop;
            verts[3].s = 0.0F;
            verts[3].t = depthTex->Ttop;

            /* upload new vertex data */
            _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
         }

         if (!blit->DepthFP)
            init_blit_depth_pixels(ctx);

         _mesa_BindProgramARB(GL_FRAGMENT_PROGRAM_ARB, blit->DepthFP);
         _mesa_set_enable(ctx, GL_FRAGMENT_PROGRAM_ARB, GL_TRUE);
         _mesa_ColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
         _mesa_set_enable(ctx, GL_DEPTH_TEST, GL_TRUE);
         _mesa_DepthFunc(GL_ALWAYS);
         _mesa_DepthMask(GL_TRUE);

         _mesa_set_viewport(ctx, dstX, dstY, dstW, dstH);
         _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
         _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
         mask &= ~GL_DEPTH_BUFFER_BIT;

         free(tmp);
      }
   }

   if (mask & GL_STENCIL_BUFFER_BIT) {
      /* XXX can't easily do stencil */
   }

   if (_mesa_is_desktop_gl(ctx) || ctx->API == API_OPENGLES)
      _mesa_set_enable(ctx, tex->Target, GL_FALSE);

   _mesa_meta_end(ctx);

   if (mask) {
      _swrast_BlitFramebuffer(ctx, srcX0, srcY0, srcX1, srcY1,
                              dstX0, dstY0, dstX1, dstY1, mask, filter);
   }
}

static void
meta_glsl_blit_cleanup(struct gl_context *ctx, struct blit_state *blit)
{
   if (blit->ArrayObj) {
      _mesa_DeleteVertexArrays(1, &blit->ArrayObj);
      blit->ArrayObj = 0;
      _mesa_DeleteBuffers(1, &blit->VBO);
      blit->VBO = 0;
   }
   if (blit->DepthFP) {
      _mesa_DeleteProgramsARB(1, &blit->DepthFP);
      blit->DepthFP = 0;
   }

   _mesa_DeleteObjectARB(blit->ShaderProg);
   blit->ShaderProg = 0;
   _mesa_DeleteObjectARB(blit->RectShaderProg);
   blit->RectShaderProg = 0;

   _mesa_DeleteTextures(1, &blit->depthTex.TexObj);
   blit->depthTex.TexObj = 0;
}


/**
 * Meta implementation of ctx->Driver.Clear() in terms of polygon rendering.
 */
void
_mesa_meta_Clear(struct gl_context *ctx, GLbitfield buffers)
{
   struct clear_state *clear = &ctx->Meta->Clear;
   struct vertex {
      GLfloat x, y, z, r, g, b, a;
   };
   struct vertex verts[4];
   /* save all state but scissor, pixel pack/unpack */
   GLbitfield metaSave = (MESA_META_ALL -
			  MESA_META_SCISSOR -
			  MESA_META_PIXEL_STORE -
			  MESA_META_CONDITIONAL_RENDER -
                          MESA_META_FRAMEBUFFER_SRGB);
   const GLuint stencilMax = (1 << ctx->DrawBuffer->Visual.stencilBits) - 1;

   if (buffers & BUFFER_BITS_COLOR) {
      /* if clearing color buffers, don't save/restore colormask */
      metaSave -= MESA_META_COLOR_MASK;
   }

   _mesa_meta_begin(ctx, metaSave);

   if (clear->ArrayObj == 0) {
      /* one-time setup */

      /* create vertex array object */
      _mesa_GenVertexArrays(1, &clear->ArrayObj);
      _mesa_BindVertexArray(clear->ArrayObj);

      /* create vertex array buffer */
      _mesa_GenBuffers(1, &clear->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, clear->VBO);

      /* setup vertex arrays */
      _mesa_VertexPointer(3, GL_FLOAT, sizeof(struct vertex), OFFSET(x));
      _mesa_ColorPointer(4, GL_FLOAT, sizeof(struct vertex), OFFSET(r));
      _mesa_EnableClientState(GL_VERTEX_ARRAY);
      _mesa_EnableClientState(GL_COLOR_ARRAY);
   }
   else {
      _mesa_BindVertexArray(clear->ArrayObj);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, clear->VBO);
   }

   /* GL_COLOR_BUFFER_BIT */
   if (buffers & BUFFER_BITS_COLOR) {
      /* leave colormask, glDrawBuffer state as-is */

      /* Clears never have the color clamped. */
      if (ctx->Extensions.ARB_color_buffer_float)
         _mesa_ClampColor(GL_CLAMP_FRAGMENT_COLOR, GL_FALSE);
   }
   else {
      ASSERT(metaSave & MESA_META_COLOR_MASK);
      _mesa_ColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
   }

   /* GL_DEPTH_BUFFER_BIT */
   if (buffers & BUFFER_BIT_DEPTH) {
      _mesa_set_enable(ctx, GL_DEPTH_TEST, GL_TRUE);
      _mesa_DepthFunc(GL_ALWAYS);
      _mesa_DepthMask(GL_TRUE);
   }
   else {
      assert(!ctx->Depth.Test);
   }

   /* GL_STENCIL_BUFFER_BIT */
   if (buffers & BUFFER_BIT_STENCIL) {
      _mesa_set_enable(ctx, GL_STENCIL_TEST, GL_TRUE);
      _mesa_StencilOpSeparate(GL_FRONT_AND_BACK,
                              GL_REPLACE, GL_REPLACE, GL_REPLACE);
      _mesa_StencilFuncSeparate(GL_FRONT_AND_BACK, GL_ALWAYS,
                                ctx->Stencil.Clear & stencilMax,
                                ctx->Stencil.WriteMask[0]);
   }
   else {
      assert(!ctx->Stencil.Enabled);
   }

   /* vertex positions/colors */
   {
      const GLfloat x0 = (GLfloat) ctx->DrawBuffer->_Xmin;
      const GLfloat y0 = (GLfloat) ctx->DrawBuffer->_Ymin;
      const GLfloat x1 = (GLfloat) ctx->DrawBuffer->_Xmax;
      const GLfloat y1 = (GLfloat) ctx->DrawBuffer->_Ymax;
      const GLfloat z = invert_z(ctx->Depth.Clear);
      GLuint i;

      verts[0].x = x0;
      verts[0].y = y0;
      verts[0].z = z;
      verts[1].x = x1;
      verts[1].y = y0;
      verts[1].z = z;
      verts[2].x = x1;
      verts[2].y = y1;
      verts[2].z = z;
      verts[3].x = x0;
      verts[3].y = y1;
      verts[3].z = z;

      /* vertex colors */
      for (i = 0; i < 4; i++) {
         verts[i].r = ctx->Color.ClearColor.f[0];
         verts[i].g = ctx->Color.ClearColor.f[1];
         verts[i].b = ctx->Color.ClearColor.f[2];
         verts[i].a = ctx->Color.ClearColor.f[3];
      }

      /* upload new vertex data */
      _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts), verts,
			  GL_DYNAMIC_DRAW_ARB);
   }

   /* draw quad */
   _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);

   _mesa_meta_end(ctx);
}

static void
meta_glsl_clear_init(struct gl_context *ctx, struct clear_state *clear)
{
   const char *vs_source =
      "attribute vec4 position;\n"
      "void main()\n"
      "{\n"
      "   gl_Position = position;\n"
      "}\n";
   const char *fs_source =
      "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "uniform vec4 color;\n"
      "void main()\n"
      "{\n"
      "   gl_FragColor = color;\n"
      "}\n";
   GLuint vs, fs;
   bool has_integer_textures;

   if (clear->ArrayObj != 0)
      return;

   /* create vertex array object */
   _mesa_GenVertexArrays(1, &clear->ArrayObj);
   _mesa_BindVertexArray(clear->ArrayObj);

   /* create vertex array buffer */
   _mesa_GenBuffers(1, &clear->VBO);
   _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, clear->VBO);

   /* setup vertex arrays */
   _mesa_VertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *)0);
   _mesa_EnableVertexAttribArray(0);

   vs = _mesa_CreateShaderObjectARB(GL_VERTEX_SHADER);
   _mesa_ShaderSource(vs, 1, &vs_source, NULL);
   _mesa_CompileShader(vs);

   fs = _mesa_CreateShaderObjectARB(GL_FRAGMENT_SHADER);
   _mesa_ShaderSource(fs, 1, &fs_source, NULL);
   _mesa_CompileShader(fs);

   clear->ShaderProg = _mesa_CreateProgramObjectARB();
   _mesa_AttachShader(clear->ShaderProg, fs);
   _mesa_DeleteObjectARB(fs);
   _mesa_AttachShader(clear->ShaderProg, vs);
   _mesa_DeleteObjectARB(vs);
   _mesa_BindAttribLocation(clear->ShaderProg, 0, "position");
   _mesa_LinkProgram(clear->ShaderProg);

   clear->ColorLocation = _mesa_GetUniformLocation(clear->ShaderProg,
						      "color");

   has_integer_textures = _mesa_is_gles3(ctx) ||
d1588 1
a1588 1
                         "#version %s\n"
d1593 1
a1593 2
                         "}\n",
                         _mesa_is_desktop_gl(ctx) ? "130" : "300 es");
d1596 1
a1596 4
                         "#version %s\n"
                         "#ifdef GL_ES\n"
                         "precision highp float;\n"
                         "#endif\n"
d1603 1
a1603 2
                         "}\n",
                         _mesa_is_desktop_gl(ctx) ? "130" : "300 es");
d1605 4
a1608 2
      vs = compile_shader_with_debug(ctx, GL_VERTEX_SHADER, vs_int_source);
      fs = compile_shader_with_debug(ctx, GL_FRAGMENT_SHADER, fs_int_source);
d1611 1
a1611 1
      clear->IntegerShaderProg = _mesa_CreateProgramObjectARB();
d1613 3
a1615 1
      _mesa_DeleteObjectARB(fs);
d1617 1
a1617 1
      _mesa_DeleteObjectARB(vs);
d1625 3
a1627 1
      link_program_with_debug(ctx, clear->IntegerShaderProg);
d1631 4
d1636 2
d1641 1
a1641 1
meta_glsl_clear_cleanup(struct gl_context *ctx, struct clear_state *clear)
d1643 1
a1643 1
   if (clear->ArrayObj == 0)
d1645 2
a1646 2
   _mesa_DeleteVertexArrays(1, &clear->ArrayObj);
   clear->ArrayObj = 0;
d1649 1
a1649 1
   _mesa_DeleteObjectARB(clear->ShaderProg);
d1653 1
a1653 1
      _mesa_DeleteObjectARB(clear->IntegerShaderProg);
d1659 42
d1703 2
a1704 2
void
_mesa_meta_glsl_Clear(struct gl_context *ctx, GLbitfield buffers)
d1710 3
a1712 8
   const float x0 = ((float)fb->_Xmin / fb->Width)  * 2.0f - 1.0f;
   const float y0 = ((float)fb->_Ymin / fb->Height) * 2.0f - 1.0f;
   const float x1 = ((float)fb->_Xmax / fb->Width)  * 2.0f - 1.0f;
   const float y1 = ((float)fb->_Ymax / fb->Height) * 2.0f - 1.0f;
   const float z = -invert_z(ctx->Depth.Clear);
   struct vertex {
      GLfloat x, y, z;
   } verts[4];
d1727 12
a1738 1
   if (!(buffers & BUFFER_BITS_COLOR)) {
d1747 17
a1763 1
   meta_glsl_clear_init(ctx, clear);
d1766 1
d1770 1
a1770 1
   } else {
a1775 3
   _mesa_BindVertexArray(clear->ArrayObj);
   _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, clear->VBO);

d1778 4
a1781 1
      /* leave colormask, glDrawBuffer state as-is */
d1829 9
d1842 14
a1855 2
   /* draw quad */
   _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
d1870 1
a1870 4
   struct temp_texture *tex = get_temp_texture(ctx);
   struct vertex {
      GLfloat x, y, z, s, t;
   };
a1871 2
   GLboolean newTex;
   GLenum intFormat = GL_RGBA;
d1894 2
a1895 2
   if (copypix->ArrayObj == 0) {
      /* one-time setup */
d1897 2
a1898 3
      /* create vertex array object */
      _mesa_GenVertexArrays(1, &copypix->ArrayObj);
      _mesa_BindVertexArray(copypix->ArrayObj);
d1900 3
a1902 18
      /* create vertex array buffer */
      _mesa_GenBuffers(1, &copypix->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, copypix->VBO);
      _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
                          NULL, GL_DYNAMIC_DRAW_ARB);

      /* setup vertex arrays */
      _mesa_VertexPointer(3, GL_FLOAT, sizeof(struct vertex), OFFSET(x));
      _mesa_TexCoordPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(s));
      _mesa_EnableClientState(GL_VERTEX_ARRAY);
      _mesa_EnableClientState(GL_TEXTURE_COORD_ARRAY);
   }
   else {
      _mesa_BindVertexArray(copypix->ArrayObj);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, copypix->VBO);
   }

   newTex = alloc_texture(tex, width, height, intFormat);
d1915 2
a1916 2
      verts[0].s = 0.0F;
      verts[0].t = 0.0F;
d1920 2
a1921 2
      verts[1].s = tex->Sright;
      verts[1].t = 0.0F;
d1925 2
a1926 2
      verts[2].s = tex->Sright;
      verts[2].t = tex->Ttop;
d1930 2
a1931 2
      verts[3].s = 0.0F;
      verts[3].t = tex->Ttop;
a1936 4
   /* Alloc/setup texture */
   setup_copypix_texture(ctx, tex, newTex, srcX, srcY, width, height,
                         GL_RGBA, GL_NEAREST);

d1947 10
d1958 10
d2051 1
a2051 1
   struct temp_texture *tex = get_temp_texture(ctx);
d2085 1
a2085 1
   struct temp_texture *tex = get_temp_texture(ctx);
d2117 1
a2117 1
   struct temp_texture *tex = get_temp_texture(ctx);
a2119 3
   struct vertex {
      GLfloat x, y, z, s, t;
   };
a2123 1
   GLuint vbo;
d2213 7
a2219 1
   newTex = alloc_texture(tex, width, height, texIntFormat);
d2232 2
a2233 2
      verts[0].s = 0.0F;
      verts[0].t = 0.0F;
d2237 2
a2238 2
      verts[1].s = tex->Sright;
      verts[1].t = 0.0F;
d2242 2
a2243 2
      verts[2].s = tex->Sright;
      verts[2].t = tex->Ttop;
d2247 2
a2248 2
      verts[3].s = 0.0F;
      verts[3].t = tex->Ttop;
d2251 1
a2251 9
   if (drawpix->ArrayObj == 0) {
      /* one-time setup: create vertex array object */
      _mesa_GenVertexArrays(1, &drawpix->ArrayObj);
   }
   _mesa_BindVertexArray(drawpix->ArrayObj);

   /* create vertex array buffer */
   _mesa_GenBuffers(1, &vbo);
   _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, vbo);
a2254 6
   /* setup vertex arrays */
   _mesa_VertexPointer(3, GL_FLOAT, sizeof(struct vertex), OFFSET(x));
   _mesa_TexCoordPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(s));
   _mesa_EnableClientState(GL_VERTEX_ARRAY);
   _mesa_EnableClientState(GL_TEXTURE_COORD_ARRAY);

d2267 2
a2268 2
      setup_drawpix_texture(ctx, tex, newTex, texIntFormat, width, height,
                            GL_ALPHA, type, pixels);
d2292 1
a2292 1
                                             255.0 / mask, 0.5, 0.0, 0.0);
d2310 2
a2311 2
      setup_drawpix_texture(ctx, tex, newTex, texIntFormat, width, height,
                            format, type, pixels);
d2317 2
a2318 2
      setup_drawpix_texture(ctx, tex, newTex, texIntFormat, width, height,
                            format, type, pixels);
a2323 2
   _mesa_DeleteBuffers(1, &vbo);

a2374 3
   struct vertex {
      GLfloat x, y, z, s, t, r, g, b, a;
   };
d2385 1
a2385 1
       ctx->Texture._EnabledUnits ||
d2408 1
a2408 12
   if (bitmap->ArrayObj == 0) {
      /* one-time setup */

      /* create vertex array object */
      _mesa_GenVertexArraysAPPLE(1, &bitmap->ArrayObj);
      _mesa_BindVertexArrayAPPLE(bitmap->ArrayObj);

      /* create vertex array buffer */
      _mesa_GenBuffers(1, &bitmap->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, bitmap->VBO);
      _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
                          NULL, GL_DYNAMIC_DRAW_ARB);
d2410 1
a2410 12
      /* setup vertex arrays */
      _mesa_VertexPointer(3, GL_FLOAT, sizeof(struct vertex), OFFSET(x));
      _mesa_TexCoordPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(s));
      _mesa_ColorPointer(4, GL_FLOAT, sizeof(struct vertex), OFFSET(r));
      _mesa_EnableClientState(GL_VERTEX_ARRAY);
      _mesa_EnableClientState(GL_TEXTURE_COORD_ARRAY);
      _mesa_EnableClientState(GL_COLOR_ARRAY);
   }
   else {
      _mesa_BindVertexArray(bitmap->ArrayObj);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, bitmap->VBO);
   }
d2412 2
a2413 1
   newTex = alloc_texture(tex, width, height, texIntFormat);
d2427 2
a2428 2
      verts[0].s = 0.0F;
      verts[0].t = 0.0F;
d2432 2
a2433 2
      verts[1].s = tex->Sright;
      verts[1].t = 0.0F;
d2437 2
a2438 2
      verts[2].s = tex->Sright;
      verts[2].t = tex->Ttop;
d2442 2
a2443 2
      verts[3].s = 0.0F;
      verts[3].t = tex->Ttop;
d2477 2
a2478 2
      setup_drawpix_texture(ctx, tex, newTex, texIntFormat, width, height,
                            GL_ALPHA, GL_UNSIGNED_BYTE, bitmap8);
a2491 96

/**
 * Check if the call to _mesa_meta_GenerateMipmap() will require a
 * software fallback.  The fallback path will require that the texture
 * images are mapped.
 * \return GL_TRUE if a fallback is needed, GL_FALSE otherwise
 */
GLboolean
_mesa_meta_check_generate_mipmap_fallback(struct gl_context *ctx, GLenum target,
                                          struct gl_texture_object *texObj)
{
   const GLuint fboSave = ctx->DrawBuffer->Name;
   struct gen_mipmap_state *mipmap = &ctx->Meta->Mipmap;
   struct gl_texture_image *baseImage;
   GLuint srcLevel;
   GLenum status;

   /* check for fallbacks */
   if (target == GL_TEXTURE_3D ||
       target == GL_TEXTURE_1D_ARRAY ||
       target == GL_TEXTURE_2D_ARRAY) {
      _mesa_perf_debug(ctx, MESA_DEBUG_SEVERITY_HIGH,
                       "glGenerateMipmap() to %s target\n",
                       _mesa_lookup_enum_by_nr(target));
      return GL_TRUE;
   }

   srcLevel = texObj->BaseLevel;
   baseImage = _mesa_select_tex_image(ctx, texObj, target, srcLevel);
   if (!baseImage) {
      _mesa_perf_debug(ctx, MESA_DEBUG_SEVERITY_HIGH,
                       "glGenerateMipmap() couldn't find base teximage\n");
      return GL_TRUE;
   }

   if (_mesa_is_format_compressed(baseImage->TexFormat)) {
      _mesa_perf_debug(ctx, MESA_DEBUG_SEVERITY_HIGH,
                       "glGenerateMipmap() with %s format\n",
                       _mesa_get_format_name(baseImage->TexFormat));
      return GL_TRUE;
   }

   if (_mesa_get_format_color_encoding(baseImage->TexFormat) == GL_SRGB &&
       !ctx->Extensions.EXT_texture_sRGB_decode) {
      /* The texture format is sRGB but we can't turn off sRGB->linear
       * texture sample conversion.  So we won't be able to generate the
       * right colors when rendering.  Need to use a fallback.
       */
      _mesa_perf_debug(ctx, MESA_DEBUG_SEVERITY_HIGH,
                       "glGenerateMipmap() of sRGB texture without "
                       "sRGB decode\n");
      return GL_TRUE;
   }

   /*
    * Test that we can actually render in the texture's format.
    */
   if (!mipmap->FBO)
      _mesa_GenFramebuffers(1, &mipmap->FBO);
   _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, mipmap->FBO);

   if (target == GL_TEXTURE_1D) {
      _mesa_FramebufferTexture1D(GL_FRAMEBUFFER_EXT,
                                    GL_COLOR_ATTACHMENT0_EXT,
                                    target, texObj->Name, srcLevel);
   }
#if 0
   /* other work is needed to enable 3D mipmap generation */
   else if (target == GL_TEXTURE_3D) {
      GLint zoffset = 0;
      _mesa_FramebufferTexture3D(GL_FRAMEBUFFER_EXT,
                                    GL_COLOR_ATTACHMENT0_EXT,
                                    target, texObj->Name, srcLevel, zoffset);
   }
#endif
   else {
      /* 2D / cube */
      _mesa_FramebufferTexture2D(GL_FRAMEBUFFER_EXT,
                                    GL_COLOR_ATTACHMENT0_EXT,
                                    target, texObj->Name, srcLevel);
   }

   status = _mesa_CheckFramebufferStatus(GL_FRAMEBUFFER_EXT);

   _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, fboSave);

   if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
      _mesa_perf_debug(ctx, MESA_DEBUG_SEVERITY_HIGH,
                       "glGenerateMipmap() got incomplete FBO\n");
      return GL_TRUE;
   }

   return GL_FALSE;
}


d2501 10
a2510 10
static void
setup_texture_coords(GLenum faceTarget,
                     GLint slice,
                     GLint width,
                     GLint height,
                     GLint depth,
                     GLfloat coords0[3],
                     GLfloat coords1[3],
                     GLfloat coords2[3],
                     GLfloat coords3[3])
d2518 10
d2539 1
a2539 1
         r = slice;
d2559 1
a2559 1
      coords1[0] = width;
d2562 2
a2563 2
      coords2[0] = width;
      coords2[1] = height;
d2566 1
a2566 1
      coords3[1] = height;
d2571 1
a2571 1
      coords0[1] = slice; /* t */
d2574 1
a2574 1
      coords1[1] = slice;
d2577 1
a2577 1
      coords2[1] = slice;
d2580 1
a2580 1
      coords3[1] = slice;
d2618 2
d2657 1
a2657 27
      assert(0 && "unexpected target in meta setup_texture_coords()");
   }
}


static void
setup_ff_generate_mipmap(struct gl_context *ctx,
                         struct gen_mipmap_state *mipmap)
{
   struct vertex {
      GLfloat x, y, tex[3];
   };

   if (mipmap->ArrayObj == 0) {
      /* one-time setup */
      /* create vertex array object */
      _mesa_GenVertexArraysAPPLE(1, &mipmap->ArrayObj);
      _mesa_BindVertexArrayAPPLE(mipmap->ArrayObj);

      /* create vertex array buffer */
      _mesa_GenBuffers(1, &mipmap->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, mipmap->VBO);
      /* setup vertex arrays */
      _mesa_VertexPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(x));
      _mesa_TexCoordPointer(3, GL_FLOAT, sizeof(struct vertex), OFFSET(tex));
      _mesa_EnableClientState(GL_VERTEX_ARRAY);
      _mesa_EnableClientState(GL_TEXTURE_COORD_ARRAY);
a2658 5

   /* setup projection matrix */
   _mesa_MatrixMode(GL_PROJECTION);
   _mesa_LoadIdentity();
   _mesa_Ortho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);
d2661 2
a2662 3

static struct glsl_sampler *
setup_texture_sampler(GLenum target, struct gen_mipmap_state *mipmap)
d2666 4
a2669 4
      mipmap->sampler_1d.type = "sampler1D";
      mipmap->sampler_1d.func = "texture1D";
      mipmap->sampler_1d.texcoords = "texCoords.x";
      return &mipmap->sampler_1d;
d2671 9
a2679 4
      mipmap->sampler_2d.type = "sampler2D";
      mipmap->sampler_2d.func = "texture2D";
      mipmap->sampler_2d.texcoords = "texCoords.xy";
      return &mipmap->sampler_2d;
d2684 4
a2687 4
      mipmap->sampler_3d.type = "sampler3D";
      mipmap->sampler_3d.func = "texture3D";
      mipmap->sampler_3d.texcoords = "texCoords";
      return &mipmap->sampler_3d;
d2689 4
a2692 4
      mipmap->sampler_cubemap.type = "samplerCube";
      mipmap->sampler_cubemap.func = "textureCube";
      mipmap->sampler_cubemap.texcoords = "texCoords";
      return &mipmap->sampler_cubemap;
d2694 4
a2697 4
      mipmap->sampler_1d_array.type = "sampler1DArray";
      mipmap->sampler_1d_array.func = "texture1DArray";
      mipmap->sampler_1d_array.texcoords = "texCoords.xy";
      return &mipmap->sampler_1d_array;
d2699 9
a2707 4
      mipmap->sampler_2d_array.type = "sampler2DArray";
      mipmap->sampler_2d_array.func = "texture2DArray";
      mipmap->sampler_2d_array.texcoords = "texCoords";
      return &mipmap->sampler_2d_array;
a2714 148

static void
setup_glsl_generate_mipmap(struct gl_context *ctx,
                           struct gen_mipmap_state *mipmap,
                           GLenum target)
{
   struct vertex {
      GLfloat x, y, tex[3];
   };
   struct glsl_sampler *sampler;
   const char *vs_source;
   char *fs_source;
   GLuint vs, fs;
   void *mem_ctx;

   /* Check if already initialized */
   if (mipmap->ArrayObj == 0) {

      /* create vertex array object */
      _mesa_GenVertexArrays(1, &mipmap->ArrayObj);
      _mesa_BindVertexArray(mipmap->ArrayObj);

      /* create vertex array buffer */
      _mesa_GenBuffers(1, &mipmap->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, mipmap->VBO);

      /* setup vertex arrays */
      _mesa_VertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE,
                                   sizeof(struct vertex), OFFSET(x));
      _mesa_VertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE,
                                   sizeof(struct vertex), OFFSET(tex));
      _mesa_EnableVertexAttribArray(0);
      _mesa_EnableVertexAttribArray(1);
   }

   /* Generate a fragment shader program appropriate for the texture target */
   sampler = setup_texture_sampler(target, mipmap);
   assert(sampler != NULL);
   if (sampler->shader_prog != 0) {
      mipmap->ShaderProg = sampler->shader_prog;
      return;
   }

   mem_ctx = ralloc_context(NULL);

   if (ctx->API == API_OPENGLES2 || ctx->Const.GLSLVersion < 130) {
      vs_source =
         "attribute vec2 position;\n"
         "attribute vec3 textureCoords;\n"
         "varying vec3 texCoords;\n"
         "void main()\n"
         "{\n"
         "   texCoords = textureCoords;\n"
         "   gl_Position = vec4(position, 0.0, 1.0);\n"
         "}\n";

      fs_source = ralloc_asprintf(mem_ctx,
                                  "#extension GL_EXT_texture_array : enable\n"
                                  "#ifdef GL_ES\n"
                                  "precision highp float;\n"
                                  "#endif\n"
                                  "uniform %s texSampler;\n"
                                  "varying vec3 texCoords;\n"
                                  "void main()\n"
                                  "{\n"
                                  "   gl_FragColor = %s(texSampler, %s);\n"
                                  "}\n",
                                  sampler->type,
                                  sampler->func, sampler->texcoords);
   }
   else {
      vs_source = ralloc_asprintf(mem_ctx,
                                  "#version %s\n"
                                  "in vec2 position;\n"
                                  "in vec3 textureCoords;\n"
                                  "out vec3 texCoords;\n"
                                  "void main()\n"
                                  "{\n"
                                  "   texCoords = textureCoords;\n"
                                  "   gl_Position = vec4(position, 0.0, 1.0);\n"
                                  "}\n",
                                  _mesa_is_desktop_gl(ctx) ? "130" : "300 es");
      fs_source = ralloc_asprintf(mem_ctx,
                                  "#version %s\n"
                                  "#ifdef GL_ES\n"
                                  "precision highp float;\n"
                                  "#endif\n"
                                  "uniform %s texSampler;\n"
                                  "in vec3 texCoords;\n"
                                  "out vec4 out_color;\n"
                                  "\n"
                                  "void main()\n"
                                  "{\n"
                                  "   out_color = texture(texSampler, %s);\n"
                                  "}\n",
                                  _mesa_is_desktop_gl(ctx) ? "130" : "300 es",
                                  sampler->type,
                                  sampler->texcoords);
   }

   vs = compile_shader_with_debug(ctx, GL_VERTEX_SHADER, vs_source);
   fs = compile_shader_with_debug(ctx, GL_FRAGMENT_SHADER, fs_source);

   mipmap->ShaderProg = _mesa_CreateProgramObjectARB();
   _mesa_AttachShader(mipmap->ShaderProg, fs);
   _mesa_DeleteObjectARB(fs);
   _mesa_AttachShader(mipmap->ShaderProg, vs);
   _mesa_DeleteObjectARB(vs);
   _mesa_BindAttribLocation(mipmap->ShaderProg, 0, "position");
   _mesa_BindAttribLocation(mipmap->ShaderProg, 1, "texcoords");
   link_program_with_debug(ctx, mipmap->ShaderProg);
   sampler->shader_prog = mipmap->ShaderProg;
   ralloc_free(mem_ctx);
}


static void
meta_glsl_generate_mipmap_cleanup(struct gl_context *ctx,
                                 struct gen_mipmap_state *mipmap)
{
   if (mipmap->ArrayObj == 0)
      return;
   _mesa_DeleteVertexArrays(1, &mipmap->ArrayObj);
   mipmap->ArrayObj = 0;
   _mesa_DeleteBuffers(1, &mipmap->VBO);
   mipmap->VBO = 0;

   _mesa_DeleteObjectARB(mipmap->sampler_1d.shader_prog);
   _mesa_DeleteObjectARB(mipmap->sampler_2d.shader_prog);
   _mesa_DeleteObjectARB(mipmap->sampler_3d.shader_prog);
   _mesa_DeleteObjectARB(mipmap->sampler_cubemap.shader_prog);
   _mesa_DeleteObjectARB(mipmap->sampler_1d_array.shader_prog);
   _mesa_DeleteObjectARB(mipmap->sampler_2d_array.shader_prog);

   mipmap->sampler_1d.shader_prog = 0;
   mipmap->sampler_2d.shader_prog = 0;
   mipmap->sampler_3d.shader_prog = 0;
   mipmap->sampler_cubemap.shader_prog = 0;
   mipmap->sampler_1d_array.shader_prog = 0;
   mipmap->sampler_2d_array.shader_prog = 0;
}


/**
 * Called via ctx->Driver.GenerateMipmap()
 * Note: We don't yet support 3D textures, 1D/2D array textures or texture
 * borders.
 */
d2716 1
a2716 2
_mesa_meta_GenerateMipmap(struct gl_context *ctx, GLenum target,
                          struct gl_texture_object *texObj)
d2718 17
a2734 219
   struct gen_mipmap_state *mipmap = &ctx->Meta->Mipmap;
   struct vertex {
      GLfloat x, y, tex[3];
   };
   struct vertex verts[4];
   const GLuint baseLevel = texObj->BaseLevel;
   const GLuint maxLevel = texObj->MaxLevel;
   const GLint maxLevelSave = texObj->MaxLevel;
   const GLboolean genMipmapSave = texObj->GenerateMipmap;
   const GLuint fboSave = ctx->DrawBuffer->Name;
   const GLuint currentTexUnitSave = ctx->Texture.CurrentUnit;
   const GLboolean use_glsl_version = ctx->Extensions.ARB_vertex_shader &&
                                      ctx->Extensions.ARB_fragment_shader &&
				      (ctx->API != API_OPENGLES);
   GLenum faceTarget;
   GLuint dstLevel;
   const GLint slice = 0;
   GLuint samplerSave;

   if (_mesa_meta_check_generate_mipmap_fallback(ctx, target, texObj)) {
      _mesa_generate_mipmap(ctx, target, texObj);
      return;
   }

   if (target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X &&
       target <= GL_TEXTURE_CUBE_MAP_NEGATIVE_Z) {
      faceTarget = target;
      target = GL_TEXTURE_CUBE_MAP;
   }
   else {
      faceTarget = target;
   }

   _mesa_meta_begin(ctx, MESA_META_ALL);

   /* Choose between glsl version and fixed function version of
    * GenerateMipmap function.
    */
   if (use_glsl_version) {
      setup_glsl_generate_mipmap(ctx, mipmap, target);
      _mesa_UseProgram(mipmap->ShaderProg);
   }
   else {
      setup_ff_generate_mipmap(ctx, mipmap);
      _mesa_set_enable(ctx, target, GL_TRUE);
   }

   _mesa_BindVertexArray(mipmap->ArrayObj);
   _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, mipmap->VBO);

   samplerSave = ctx->Texture.Unit[ctx->Texture.CurrentUnit].Sampler ?
      ctx->Texture.Unit[ctx->Texture.CurrentUnit].Sampler->Name : 0;

   if (currentTexUnitSave != 0)
      _mesa_BindTexture(target, texObj->Name);

   if (!mipmap->FBO) {
      _mesa_GenFramebuffers(1, &mipmap->FBO);
   }

   if (!mipmap->Sampler) {
      _mesa_GenSamplers(1, &mipmap->Sampler);
      _mesa_BindSampler(ctx->Texture.CurrentUnit, mipmap->Sampler);

      _mesa_SamplerParameteri(mipmap->Sampler,
                              GL_TEXTURE_MIN_FILTER,
                              GL_LINEAR_MIPMAP_LINEAR);
      _mesa_SamplerParameteri(mipmap->Sampler, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
      _mesa_SamplerParameteri(mipmap->Sampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
      _mesa_SamplerParameteri(mipmap->Sampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
      _mesa_SamplerParameteri(mipmap->Sampler, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

      /* We don't want to encode or decode sRGB values; treat them as linear.
       * This is not technically correct for GLES3 but we don't get any API
       * error at the moment.
       */
      if (ctx->Extensions.EXT_texture_sRGB_decode) {
         _mesa_SamplerParameteri(mipmap->Sampler, GL_TEXTURE_SRGB_DECODE_EXT,
               GL_SKIP_DECODE_EXT);
      }

   } else {
      _mesa_BindSampler(ctx->Texture.CurrentUnit, mipmap->Sampler);
   }

   _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, mipmap->FBO);

   if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES)
      _mesa_TexParameteri(target, GL_GENERATE_MIPMAP, GL_FALSE);
   else
      assert(!genMipmapSave);

   /* Setup texture coordinates */
   setup_texture_coords(faceTarget,
                        slice,
                        0, 0, 1, /* width, height never used here */
                        verts[0].tex,
                        verts[1].tex,
                        verts[2].tex,
                        verts[3].tex);

   /* setup vertex positions */
   verts[0].x = -1.0F;
   verts[0].y = -1.0F;
   verts[1].x =  1.0F;
   verts[1].y = -1.0F;
   verts[2].x =  1.0F;
   verts[2].y =  1.0F;
   verts[3].x = -1.0F;
   verts[3].y =  1.0F;

   /* upload vertex data */
   _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
                       verts, GL_DYNAMIC_DRAW_ARB);

   /* texture is already locked, unlock now */
   _mesa_unlock_texture(ctx, texObj);

   for (dstLevel = baseLevel + 1; dstLevel <= maxLevel; dstLevel++) {
      const struct gl_texture_image *srcImage;
      const GLuint srcLevel = dstLevel - 1;
      GLsizei srcWidth, srcHeight, srcDepth;
      GLsizei dstWidth, dstHeight, dstDepth;
      GLenum status;

      srcImage = _mesa_select_tex_image(ctx, texObj, faceTarget, srcLevel);
      assert(srcImage->Border == 0);

      /* src size */
      srcWidth = srcImage->Width;
      srcHeight = srcImage->Height;
      srcDepth = srcImage->Depth;

      /* new dst size */
      dstWidth = MAX2(1, srcWidth / 2);
      dstHeight = MAX2(1, srcHeight / 2);
      dstDepth = MAX2(1, srcDepth / 2);

      if (dstWidth == srcImage->Width &&
          dstHeight == srcImage->Height &&
          dstDepth == srcImage->Depth) {
         /* all done */
         break;
      }

      /* Allocate storage for the destination mipmap image(s) */

      /* Set MaxLevel large enough to hold the new level when we allocate it */
      _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, dstLevel);

      if (!_mesa_prepare_mipmap_level(ctx, texObj, dstLevel,
                                      dstWidth, dstHeight, dstDepth,
                                      srcImage->Border,
                                      srcImage->InternalFormat,
                                      srcImage->TexFormat)) {
         /* All done.  We either ran out of memory or we would go beyond the
          * last valid level of an immutable texture if we continued.
          */
         break;
      }

      /* limit minification to src level */
      _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, srcLevel);

      /* Set to draw into the current dstLevel */
      if (target == GL_TEXTURE_1D) {
         _mesa_FramebufferTexture1D(GL_FRAMEBUFFER_EXT,
                                       GL_COLOR_ATTACHMENT0_EXT,
                                       target,
                                       texObj->Name,
                                       dstLevel);
      }
      else if (target == GL_TEXTURE_3D) {
         GLint zoffset = 0; /* XXX unfinished */
         _mesa_FramebufferTexture3D(GL_FRAMEBUFFER_EXT,
                                       GL_COLOR_ATTACHMENT0_EXT,
                                       target,
                                       texObj->Name,
                                       dstLevel, zoffset);
      }
      else {
         /* 2D / cube */
         _mesa_FramebufferTexture2D(GL_FRAMEBUFFER_EXT,
                                       GL_COLOR_ATTACHMENT0_EXT,
                                       faceTarget,
                                       texObj->Name,
                                       dstLevel);
      }

      _mesa_DrawBuffer(GL_COLOR_ATTACHMENT0_EXT);

      /* sanity check */
      status = _mesa_CheckFramebufferStatus(GL_FRAMEBUFFER_EXT);
      if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
         _mesa_problem(ctx, "Unexpected incomplete framebuffer in "
                       "_mesa_meta_GenerateMipmap()");
         break;
      }

      assert(dstWidth == ctx->DrawBuffer->Width);
      assert(dstHeight == ctx->DrawBuffer->Height);

      /* setup viewport */
      _mesa_set_viewport(ctx, 0, 0, dstWidth, dstHeight);

      _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
   }

   _mesa_lock_texture(ctx, texObj); /* relock */

   _mesa_BindSampler(ctx->Texture.CurrentUnit, samplerSave);

   _mesa_meta_end(ctx);

   _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, maxLevelSave);
   if (genMipmapSave)
      _mesa_TexParameteri(target, GL_GENERATE_MIPMAP, genMipmapSave);

   _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, fboSave);
a2736 1

d2742 1
a2742 1
get_temp_image_type(struct gl_context *ctx, gl_format format)
d2788 77
d2883 9
d2959 19
a3000 3
   struct vertex {
      GLfloat x, y, tex[3];
   };
a3001 2
   GLuint fboDrawSave, fboReadSave;
   GLuint rbSave;
d3003 2
d3008 2
a3009 1
             target == GL_TEXTURE_2D_ARRAY);
d3012 15
a3026 1
   if (target == GL_TEXTURE_CUBE_MAP) {
d3028 3
a3030 2
   }
   else {
d3032 1
d3035 2
a3036 6
   /* save fbo bindings (not saved by _mesa_meta_begin()) */
   fboDrawSave = ctx->DrawBuffer->Name;
   fboReadSave = ctx->ReadBuffer->Name;
   rbSave = ctx->CurrentRenderbuffer ? ctx->CurrentRenderbuffer->Name : 0;

   _mesa_meta_begin(ctx, MESA_META_ALL & ~MESA_META_PIXEL_STORE);
d3065 3
a3067 5
   /* setup VBO data */
   if (decompress->ArrayObj == 0) {
      /* create vertex array object */
      _mesa_GenVertexArrays(1, &decompress->ArrayObj);
      _mesa_BindVertexArray(decompress->ArrayObj);
d3069 3
a3071 15
      /* create vertex array buffer */
      _mesa_GenBuffers(1, &decompress->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, decompress->VBO);
      _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
                          NULL, GL_DYNAMIC_DRAW_ARB);

      /* setup vertex arrays */
      _mesa_VertexPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(x));
      _mesa_TexCoordPointer(3, GL_FLOAT, sizeof(struct vertex), OFFSET(tex));
      _mesa_EnableClientState(GL_VERTEX_ARRAY);
      _mesa_EnableClientState(GL_TEXTURE_COORD_ARRAY);
   }
   else {
      _mesa_BindVertexArray(decompress->ArrayObj);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, decompress->VBO);
d3090 8
a3097 5
   setup_texture_coords(faceTarget, slice, width, height, depth,
                        verts[0].tex,
                        verts[1].tex,
                        verts[2].tex,
                        verts[3].tex);
d3100 8
a3107 8
   verts[0].x = 0.0F;
   verts[0].y = 0.0F;
   verts[1].x = width;
   verts[1].y = 0.0F;
   verts[2].x = width;
   verts[2].y = height;
   verts[3].x = 0.0F;
   verts[3].y = height;
d3109 1
a3109 4
   _mesa_MatrixMode(GL_PROJECTION);
   _mesa_LoadIdentity();
   _mesa_Ortho(0.0, width, 0.0, height, -1.0, 1.0);
   _mesa_set_viewport(ctx, 0, 0, width, height);
d3116 3
a3118 1
   _mesa_set_enable(ctx, target, GL_TRUE);
d3178 2
a3179 1
   _mesa_set_enable(ctx, target, GL_FALSE);
a3183 10

   /* restore fbo bindings */
   if (fboDrawSave == fboReadSave) {
      _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, fboDrawSave);
   }
   else {
      _mesa_BindFramebuffer(GL_DRAW_FRAMEBUFFER_EXT, fboDrawSave);
      _mesa_BindFramebuffer(GL_READ_FRAMEBUFFER_EXT, fboReadSave);
   }
   _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, rbSave);
d3210 2
a3211 1
         if (texImage->TexObject->Target == GL_TEXTURE_2D_ARRAY) {
d3259 1
a3259 1
   if (drawtex->ArrayObj == 0) {
d3264 2
a3265 2
      _mesa_GenVertexArrays(1, &drawtex->ArrayObj);
      _mesa_BindVertexArray(drawtex->ArrayObj);
d3289 1
a3289 1
      _mesa_BindVertexArray(drawtex->ArrayObj);
d3323 1
a3323 1
         if (!ctx->Texture.Unit[i]._ReallyEnabled) {
@


1.6
log
@Merge Mesa 9.2.1
@
text
@d1518 3
a1596 2
   _mesa_EnableVertexAttribArray(0);
   _mesa_EnableVertexAttribArray(1);
@


1.5
log
@Merge Mesa 9.2.0
@
text
@d4025 5
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.6
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d47 1
d49 1
d54 1
d57 1
d66 1
d70 2
d74 1
d78 3
a80 1

a84 27

/**
 * Flags passed to _mesa_meta_begin().
 */
/*@@{*/
#define META_ALL              ~0x0
#define META_ALPHA_TEST        0x1
#define META_BLEND             0x2  /**< includes logicop */
#define META_COLOR_MASK        0x4
#define META_DEPTH_TEST        0x8
#define META_FOG              0x10
#define META_PIXEL_STORE      0x20
#define META_PIXEL_TRANSFER   0x40
#define META_RASTERIZATION    0x80
#define META_SCISSOR         0x100
#define META_SHADER          0x200
#define META_STENCIL_TEST    0x400
#define META_TRANSFORM       0x800 /**< modelview, projection, clip planes */
#define META_TEXTURE        0x1000
#define META_VERTEX         0x2000
#define META_VIEWPORT       0x4000
#define META_CLAMP_FRAGMENT_COLOR 0x8000
#define META_CLAMP_VERTEX_COLOR 0x10000
#define META_CONDITIONAL_RENDER 0x20000
/*@@}*/


d91 1
a91 1
   GLbitfield SavedState;  /**< bitmask of META_* flags */
d93 4
a96 1
   /** META_ALPHA_TEST */
d101 1
a101 1
   /** META_BLEND */
d105 1
a105 1
   /** META_COLOR_MASK */
d108 1
a108 1
   /** META_DEPTH_TEST */
d111 1
a111 1
   /** META_FOG */
d114 1
a114 1
   /** META_PIXEL_STORE */
d117 1
a117 1
   /** META_PIXEL_TRANSFER */
d125 1
a125 1
   /** META_RASTERIZATION */
d132 1
a132 1
   /** META_SCISSOR */
d135 1
a135 1
   /** META_SHADER */
d140 1
d146 1
a146 1
   /** META_STENCIL_TEST */
d149 1
a149 1
   /** META_TRANSFORM */
d154 2
d158 1
a158 1
   /** META_TEXTURE */
d168 1
a168 1
   /** META_VERTEX */
d172 1
a172 1
   /** META_VIEWPORT */
d176 1
a176 1
   /** META_CLAMP_FRAGMENT_COLOR */
d179 1
a179 1
   /** META_CLAMP_VERTEX_COLOR */
d182 1
a182 1
   /** META_CONDITIONAL_RENDER */
d186 11
d199 2
a202 1

d229 3
d242 5
d282 10
d301 8
d311 20
a330 1
#define MAX_META_OPS_DEPTH      2
d349 2
d353 72
d446 10
a455 4
   /* Note: Any textures, VBOs, etc, that we allocate should get
    * freed by the normal context destruction code.  But this would be
    * the place to free other meta data someday.
    */
d465 1
a465 1
 * \param state  bitmask of META_* flags indicating which attribute groups
d468 1
a468 1
static void
d480 18
a497 1
   if (state & META_ALPHA_TEST) {
d505 1
a505 1
   if (state & META_BLEND) {
d523 1
a523 1
   if (state & META_COLOR_MASK) {
d533 1
a533 1
   if (state & META_DEPTH_TEST) {
d539 3
a541 1
   if (state & META_FOG) {
d547 1
a547 1
   if (state & META_PIXEL_STORE) {
d554 1
a554 1
   if (state & META_PIXEL_TRANSFER) {
d577 1
a577 1
   if (state & META_RASTERIZATION) {
d586 4
a589 2
      _mesa_set_enable(ctx, GL_POLYGON_SMOOTH, GL_FALSE);
      _mesa_set_enable(ctx, GL_POLYGON_STIPPLE, GL_FALSE);
d593 1
a593 1
   if (state & META_SCISSOR) {
d598 2
a599 2
   if (state & META_SHADER) {
      if (ctx->Extensions.ARB_vertex_program) {
d606 1
a606 1
      if (ctx->Extensions.ARB_fragment_program) {
d613 13
a625 9
      if (ctx->Extensions.ARB_shader_objects) {
	 _mesa_reference_shader_program(ctx, &save->VertexShader,
					ctx->Shader.CurrentVertexProgram);
	 _mesa_reference_shader_program(ctx, &save->GeometryShader,
					ctx->Shader.CurrentGeometryProgram);
	 _mesa_reference_shader_program(ctx, &save->FragmentShader,
					ctx->Shader.CurrentFragmentProgram);
	 _mesa_reference_shader_program(ctx, &save->ActiveShader,
					ctx->Shader.ActiveProgram);
d627 1
a627 2
         _mesa_UseProgramObjectARB(0);
      }
d630 1
a630 1
   if (state & META_STENCIL_TEST) {
d637 1
a637 1
   if (state & META_TEXTURE) {
d645 27
a671 16
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
         save->TexEnabled[u] = ctx->Texture.Unit[u].Enabled;
         save->TexGenEnabled[u] = ctx->Texture.Unit[u].TexGenEnabled;
         if (ctx->Texture.Unit[u].Enabled ||
             ctx->Texture.Unit[u].TexGenEnabled) {
            _mesa_ActiveTextureARB(GL_TEXTURE0 + u);
            _mesa_set_enable(ctx, GL_TEXTURE_1D, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_2D, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_3D, GL_FALSE);
            if (ctx->Extensions.ARB_texture_cube_map)
               _mesa_set_enable(ctx, GL_TEXTURE_CUBE_MAP, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_RECTANGLE, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_GEN_S, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_GEN_T, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_GEN_R, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_GEN_Q, GL_FALSE);
d682 5
a686 3
      _mesa_ActiveTextureARB(GL_TEXTURE0);
      _mesa_ClientActiveTextureARB(GL_TEXTURE0);
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
d689 1
a689 1
   if (state & META_TRANSFORM) {
d699 1
a699 1
      _mesa_ActiveTextureARB(GL_TEXTURE0);
d702 1
a702 1
      _mesa_ActiveTextureARB(GL_TEXTURE0 + activeTexture);
d707 11
a717 3
      _mesa_Ortho(0.0, ctx->DrawBuffer->Width,
                  0.0, ctx->DrawBuffer->Height,
                  -1.0, 1.0);
d727 1
a727 1
   if (state & META_VERTEX) {
d736 1
a736 1
   if (state & META_VIEWPORT) {
d757 1
a757 1
   if (state & META_CLAMP_FRAGMENT_COLOR) {
d764 3
a766 2
      if (ctx->Color.ClampFragmentColor != GL_TRUE)
	 _mesa_ClampColorARB(GL_CLAMP_FRAGMENT_COLOR, GL_FALSE);
d769 1
a769 1
   if (state & META_CLAMP_VERTEX_COLOR) {
d775 2
a776 1
      _mesa_ClampColorARB(GL_CLAMP_VERTEX_COLOR, GL_FALSE);
d779 1
a779 1
   if (state & META_CONDITIONAL_RENDER) {
d787 23
d815 3
d825 1
a825 1
static void
d828 1
a828 1
   struct save_state *save = &ctx->Meta->Save[--ctx->Meta->SaveStackDepth];
d831 13
a843 1
   if (state & META_ALPHA_TEST) {
d849 1
a849 1
   if (state & META_BLEND) {
d865 1
a865 1
   if (state & META_COLOR_MASK) {
d874 1
a874 1
               _mesa_ColorMaskIndexed(i,
d884 1
a884 1
   if (state & META_DEPTH_TEST) {
d891 3
a893 1
   if (state & META_FOG) {
d897 1
a897 1
   if (state & META_PIXEL_STORE) {
d902 1
a902 1
   if (state & META_PIXEL_TRANSFER) {
d916 13
a928 4
   if (state & META_RASTERIZATION) {
      _mesa_PolygonMode(GL_FRONT, save->FrontPolygonMode);
      _mesa_PolygonMode(GL_BACK, save->BackPolygonMode);
      _mesa_set_enable(ctx, GL_POLYGON_STIPPLE, save->PolygonStipple);
a929 1
      _mesa_set_enable(ctx, GL_POLYGON_SMOOTH, save->PolygonSmooth);
d933 1
a933 1
   if (state & META_SCISSOR) {
d939 2
a940 2
   if (state & META_SHADER) {
      if (ctx->Extensions.ARB_vertex_program) {
d948 1
a948 1
      if (ctx->Extensions.ARB_fragment_program) {
d956 5
d974 5
d981 1
a981 1
   if (state & META_STENCIL_TEST) {
d986 1
a986 1
      if (ctx->Extensions.EXT_stencil_two_side) {
d1012 1
a1012 1
   if (state & META_TEXTURE) {
d1018 3
a1020 1
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, save->EnvMode);
d1024 5
a1028 2
         _mesa_reference_texobj(&ctx->Texture.Unit[0].CurrentTex[tgt],
                                save->CurrentTexture[tgt]);
d1032 12
a1043 28
      /* Re-enable textures, texgen */
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
         if (save->TexEnabled[u]) {
            _mesa_ActiveTextureARB(GL_TEXTURE0 + u);

            if (save->TexEnabled[u] & TEXTURE_1D_BIT)
               _mesa_set_enable(ctx, GL_TEXTURE_1D, GL_TRUE);
            if (save->TexEnabled[u] & TEXTURE_2D_BIT)
               _mesa_set_enable(ctx, GL_TEXTURE_2D, GL_TRUE);
            if (save->TexEnabled[u] & TEXTURE_3D_BIT)
               _mesa_set_enable(ctx, GL_TEXTURE_3D, GL_TRUE);
            if (save->TexEnabled[u] & TEXTURE_CUBE_BIT)
               _mesa_set_enable(ctx, GL_TEXTURE_CUBE_MAP, GL_TRUE);
            if (save->TexEnabled[u] & TEXTURE_RECT_BIT)
               _mesa_set_enable(ctx, GL_TEXTURE_RECTANGLE, GL_TRUE);
         }

         if (save->TexGenEnabled[u]) {
            _mesa_ActiveTextureARB(GL_TEXTURE0 + u);

            if (save->TexGenEnabled[u] & S_BIT)
               _mesa_set_enable(ctx, GL_TEXTURE_GEN_S, GL_TRUE);
            if (save->TexGenEnabled[u] & T_BIT)
               _mesa_set_enable(ctx, GL_TEXTURE_GEN_T, GL_TRUE);
            if (save->TexGenEnabled[u] & R_BIT)
               _mesa_set_enable(ctx, GL_TEXTURE_GEN_R, GL_TRUE);
            if (save->TexGenEnabled[u] & Q_BIT)
               _mesa_set_enable(ctx, GL_TEXTURE_GEN_Q, GL_TRUE);
d1048 2
a1049 2
      _mesa_ActiveTextureARB(GL_TEXTURE0 + save->ActiveUnit);
      _mesa_ClientActiveTextureARB(GL_TEXTURE0 + save->ClientActiveUnit);
d1052 1
a1052 1
   if (state & META_TRANSFORM) {
d1054 1
a1054 1
      _mesa_ActiveTextureARB(GL_TEXTURE0);
d1057 1
a1057 1
      _mesa_ActiveTextureARB(GL_TEXTURE0 + activeTexture);
d1066 1
d1068 1
d1079 1
a1079 1
   if (state & META_VERTEX) {
d1081 1
a1081 1
      _mesa_BindBufferARB(GL_ARRAY_BUFFER_ARB, save->ArrayBufferObj->Name);
d1089 1
a1089 1
   if (state & META_VIEWPORT) {
d1100 3
a1102 2
   if (state & META_CLAMP_FRAGMENT_COLOR) {
      _mesa_ClampColorARB(GL_CLAMP_FRAGMENT_COLOR, save->ClampFragmentColor);
d1105 3
a1107 2
   if (state & META_CLAMP_VERTEX_COLOR) {
      _mesa_ClampColorARB(GL_CLAMP_VERTEX_COLOR, save->ClampVertexColor);
d1110 1
a1110 1
   if (state & META_CONDITIONAL_RENDER) {
d1116 20
d1140 17
d1170 1
a1170 1
   GLfloat objZ = 1.0 - 2.0 * normZ;
d1183 1
a1183 1
   if (ctx->Extensions.NV_texture_rectangle) {
d1200 9
d1244 15
d1323 2
a1324 1
setup_copypix_texture(struct temp_texture *tex,
d1333 2
a1334 1
   _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
d1377 2
a1378 1
   _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
d1393 1
a1393 1
	 _mesa_BindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0);
d1398 1
a1398 1
	    _mesa_BindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB,
d1439 2
a1440 2
   _mesa_GenPrograms(1, &blit->DepthFP);
   _mesa_BindProgram(GL_FRAGMENT_PROGRAM_ARB, blit->DepthFP);
d1445 158
d1616 2
a1617 1
                        GLbitfield mask, GLenum filter)
d1622 1
a1622 2
      const struct gl_renderbuffer_attachment *drawAtt =
         &drawFb->Attachment[drawFb->_ColorDrawBufferIndexes[0]];
d1627 5
a1633 2
         const GLenum minFilterSave = texObj->Sampler.MinFilter;
         const GLenum magFilterSave = texObj->Sampler.MagFilter;
a1635 4
         const GLenum wrapSSave = texObj->Sampler.WrapS;
         const GLenum wrapTSave = texObj->Sampler.WrapT;
         const GLenum srgbSave = texObj->Sampler.sRGBDecode;
         const GLenum fbo_srgb_save = ctx->Color.sRGBEnabled;
d1637 19
a1655 7

         if (drawAtt->Texture == readAtt->Texture) {
            /* Can't use same texture as both the source and dest.  We need
             * to handle overlapping blits and besides, some hw may not
             * support this.
             */
            return mask;
d1663 20
d1691 2
a1692 2
         _mesa_TexParameteri(target, GL_TEXTURE_MIN_FILTER, filter);
         _mesa_TexParameteri(target, GL_TEXTURE_MAG_FILTER, filter);
d1697 2
a1698 2
         _mesa_TexParameteri(target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
         _mesa_TexParameteri(target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
d1700 4
a1703 1
	 /* Always do our blits with no sRGB decode or encode.*/
d1705 1
a1705 1
	    _mesa_TexParameteri(target, GL_TEXTURE_SRGB_DECODE_EXT,
a1707 3
         if (ctx->Extensions.EXT_framebuffer_sRGB) {
            _mesa_Disable(GL_FRAMEBUFFER_SRGB_EXT);
         }
d1709 4
a1712 2
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
         _mesa_set_enable(ctx, target, GL_TRUE);
d1738 9
a1746 8
            verts[0].x = (GLfloat) dstX0;
            verts[0].y = (GLfloat) dstY0;
            verts[1].x = (GLfloat) dstX1;
            verts[1].y = (GLfloat) dstY0;
            verts[2].x = (GLfloat) dstX1;
            verts[2].y = (GLfloat) dstY1;
            verts[3].x = (GLfloat) dstX0;
            verts[3].y = (GLfloat) dstY1;
d1757 1
a1757 1
            _mesa_BufferSubDataARB(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
d1760 4
a1768 2
         _mesa_TexParameteri(target, GL_TEXTURE_MIN_FILTER, minFilterSave);
         _mesa_TexParameteri(target, GL_TEXTURE_MAG_FILTER, magFilterSave);
d1773 3
a1775 8
         _mesa_TexParameteri(target, GL_TEXTURE_WRAP_S, wrapSSave);
         _mesa_TexParameteri(target, GL_TEXTURE_WRAP_T, wrapTSave);
	 if (ctx->Extensions.EXT_texture_sRGB_decode) {
	    _mesa_TexParameteri(target, GL_TEXTURE_SRGB_DECODE_EXT, srgbSave);
	 }
	 if (ctx->Extensions.EXT_framebuffer_sRGB && fbo_srgb_save) {
	    _mesa_Enable(GL_FRAMEBUFFER_SRGB_EXT);
	 }
d1798 1
d1804 11
a1814 2
   const GLboolean srcFlipX = srcX1 < srcX0;
   const GLboolean srcFlipY = srcY1 < srcY0;
d1820 10
a1829 2

   if (srcW > maxTexSize || srcH > maxTexSize) {
a1835 12
   if (srcFlipX) {
      GLint tmp = dstX0;
      dstX0 = dstX1;
      dstX1 = tmp;
   }

   if (srcFlipY) {
      GLint tmp = dstY0;
      dstY0 = dstY1;
      dstY1 = tmp;
   }

d1837 1
a1837 25
   _mesa_meta_begin(ctx, ~META_SCISSOR);

   if (blit->ArrayObj == 0) {
      /* one-time setup */

      /* create vertex array object */
      _mesa_GenVertexArrays(1, &blit->ArrayObj);
      _mesa_BindVertexArray(blit->ArrayObj);

      /* create vertex array buffer */
      _mesa_GenBuffersARB(1, &blit->VBO);
      _mesa_BindBufferARB(GL_ARRAY_BUFFER_ARB, blit->VBO);
      _mesa_BufferDataARB(GL_ARRAY_BUFFER_ARB, sizeof(verts),
                          NULL, GL_DYNAMIC_DRAW_ARB);

      /* setup vertex arrays */
      _mesa_VertexPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(x));
      _mesa_TexCoordPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(s));
      _mesa_EnableClientState(GL_VERTEX_ARRAY);
      _mesa_EnableClientState(GL_TEXTURE_COORD_ARRAY);
   }
   else {
      _mesa_BindVertexArray(blit->ArrayObj);
      _mesa_BindBufferARB(GL_ARRAY_BUFFER_ARB, blit->VBO);
   }
d1841 2
a1842 1
                                  dstX0, dstY0, dstX1, dstY1, mask, filter);
d1848 17
a1867 4

   newTex = alloc_texture(tex, srcW, srcH, GL_RGBA);

   /* vertex positions/texcoords (after texture allocation!) */
d1869 9
a1877 17
      verts[0].x = (GLfloat) dstX0;
      verts[0].y = (GLfloat) dstY0;
      verts[1].x = (GLfloat) dstX1;
      verts[1].y = (GLfloat) dstY0;
      verts[2].x = (GLfloat) dstX1;
      verts[2].y = (GLfloat) dstY1;
      verts[3].x = (GLfloat) dstX0;
      verts[3].y = (GLfloat) dstY1;

      verts[0].s = 0.0F;
      verts[0].t = 0.0F;
      verts[1].s = tex->Sright;
      verts[1].t = 0.0F;
      verts[2].s = tex->Sright;
      verts[2].t = tex->Ttop;
      verts[3].s = 0.0F;
      verts[3].t = tex->Ttop;
a1878 2
      /* upload new vertex data */
      _mesa_BufferSubDataARB(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
d1881 5
a1885 1
   _mesa_set_enable(ctx, tex->Target, GL_TRUE);
d1888 32
a1919 2
      setup_copypix_texture(tex, newTex, srcX, srcY, srcW, srcH,
                            GL_RGBA, filter);
d1924 7
a1930 2
   if (mask & GL_DEPTH_BUFFER_BIT) {
      GLuint *tmp = (GLuint *) malloc(srcW * srcH * sizeof(GLuint));
a1931 2
         if (!blit->DepthFP)
            init_blit_depth_pixels(ctx);
d1933 6
a1938 2
         /* maybe change tex format here */
         newTex = alloc_texture(tex, srcW, srcH, GL_DEPTH_COMPONENT);
d1940 10
a1949 2
         _mesa_ReadPixels(srcX, srcY, srcW, srcH,
                          GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, tmp);
d1951 6
a1956 2
         setup_drawpix_texture(ctx, tex, newTex, GL_DEPTH_COMPONENT, srcW, srcH,
                               GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, tmp);
d1958 1
a1958 1
         _mesa_BindProgram(GL_FRAGMENT_PROGRAM_ARB, blit->DepthFP);
d1965 2
d1978 2
a1979 1
   _mesa_set_enable(ctx, tex->Target, GL_FALSE);
d1989 23
d2025 5
a2029 4
   GLbitfield metaSave = (META_ALL -
			  META_SCISSOR -
			  META_PIXEL_STORE -
			  META_CONDITIONAL_RENDER);
d2034 1
a2034 1
      metaSave -= META_COLOR_MASK;
d2047 2
a2048 2
      _mesa_GenBuffersARB(1, &clear->VBO);
      _mesa_BindBufferARB(GL_ARRAY_BUFFER_ARB, clear->VBO);
d2058 1
a2058 1
      _mesa_BindBufferARB(GL_ARRAY_BUFFER_ARB, clear->VBO);
d2066 2
a2067 1
      _mesa_ClampColorARB(GL_CLAMP_FRAGMENT_COLOR, GL_FALSE);
d2070 1
a2070 1
      ASSERT(metaSave & META_COLOR_MASK);
d2121 4
a2124 4
         verts[i].r = ctx->Color.ClearColorUnclamped[0];
         verts[i].g = ctx->Color.ClearColorUnclamped[1];
         verts[i].b = ctx->Color.ClearColorUnclamped[2];
         verts[i].a = ctx->Color.ClearColorUnclamped[3];
d2128 1
a2128 1
      _mesa_BufferDataARB(GL_ARRAY_BUFFER_ARB, sizeof(verts), verts,
d2138 240
d2381 1
a2381 1
 * of texture mapping and polygon rendering.
d2410 7
a2416 6
   _mesa_meta_begin(ctx, (META_RASTERIZATION |
                          META_SHADER |
                          META_TEXTURE |
                          META_TRANSFORM |
                          META_VERTEX |
                          META_VIEWPORT));
d2426 3
a2428 3
      _mesa_GenBuffersARB(1, &copypix->VBO);
      _mesa_BindBufferARB(GL_ARRAY_BUFFER_ARB, copypix->VBO);
      _mesa_BufferDataARB(GL_ARRAY_BUFFER_ARB, sizeof(verts),
d2439 1
a2439 1
      _mesa_BindBufferARB(GL_ARRAY_BUFFER_ARB, copypix->VBO);
d2474 1
a2474 1
      _mesa_BufferSubDataARB(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
d2478 1
a2478 1
   setup_copypix_texture(tex, newTex, srcX, srcY, width, height,
d2588 2
a2589 2
   _mesa_GenPrograms(1, &drawpix->StencilFP);
   _mesa_BindProgram(GL_FRAGMENT_PROGRAM_ARB, drawpix->StencilFP);
d2622 2
a2623 2
   _mesa_GenPrograms(1, &drawpix->DepthFP);
   _mesa_BindProgram(GL_FRAGMENT_PROGRAM_ARB, drawpix->DepthFP);
d2657 1
a2657 2
   if (ctx->_ImageTransferState ||
       ctx->Fog.Enabled) {
d2690 5
a2694 4
         metaExtraSave = (META_COLOR_MASK |
                          META_DEPTH_TEST |
                          META_SHADER |
                          META_STENCIL_TEST);
d2704 1
a2704 1
         metaExtraSave = (META_SHADER);
d2732 7
a2738 7
   _mesa_meta_begin(ctx, (META_RASTERIZATION |
                          META_SHADER |
                          META_TEXTURE |
                          META_TRANSFORM |
                          META_VERTEX |
                          META_VIEWPORT |
			  META_CLAMP_FRAGMENT_COLOR |
d2780 3
a2782 3
   _mesa_GenBuffersARB(1, &vbo);
   _mesa_BindBufferARB(GL_ARRAY_BUFFER_ARB, vbo);
   _mesa_BufferDataARB(GL_ARRAY_BUFFER_ARB, sizeof(verts),
d2818 1
a2818 1
      _mesa_BindProgram(GL_FRAGMENT_PROGRAM_ARB, drawpix->StencilFP);
d2839 1
a2839 1
      _mesa_BindProgram(GL_FRAGMENT_PROGRAM_ARB, drawpix->DepthFP);
d2860 1
a2860 1
   _mesa_DeleteBuffersARB(1, &vbo);
d2939 9
a2947 8
   _mesa_meta_begin(ctx, (META_ALPHA_TEST |
                          META_PIXEL_STORE |
                          META_RASTERIZATION |
                          META_SHADER |
                          META_TEXTURE |
                          META_TRANSFORM |
                          META_VERTEX |
                          META_VIEWPORT));
d2957 3
a2959 3
      _mesa_GenBuffersARB(1, &bitmap->VBO);
      _mesa_BindBufferARB(GL_ARRAY_BUFFER_ARB, bitmap->VBO);
      _mesa_BufferDataARB(GL_ARRAY_BUFFER_ARB, sizeof(verts),
d2972 1
a2972 1
      _mesa_BindBufferARB(GL_ARRAY_BUFFER_ARB, bitmap->VBO);
d3015 1
a3015 1
      _mesa_BufferSubDataARB(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
d3028 1
a3028 1
   bitmap8 = (GLubyte *) malloc(width * height);
d3072 6
a3077 2
   if (!ctx->Extensions.EXT_framebuffer_object ||
       target == GL_TEXTURE_3D) {
d3083 10
a3092 1
   if (!baseImage || _mesa_is_format_compressed(baseImage->TexFormat)) {
d3102 3
d3112 2
a3113 2
      _mesa_GenFramebuffersEXT(1, &mipmap->FBO);
   _mesa_BindFramebufferEXT(GL_FRAMEBUFFER_EXT, mipmap->FBO);
d3116 1
a3116 1
      _mesa_FramebufferTexture1DEXT(GL_FRAMEBUFFER_EXT,
d3124 1
a3124 1
      _mesa_FramebufferTexture3DEXT(GL_FRAMEBUFFER_EXT,
d3131 1
a3131 1
      _mesa_FramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT,
d3136 1
a3136 1
   status = _mesa_CheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
d3138 1
a3138 1
   _mesa_BindFramebufferEXT(GL_FRAMEBUFFER_EXT, fboSave);
d3141 2
d3151 376
d3528 2
a3529 1
 * Note: texture borders and 3D texture support not yet complete.
d3537 1
a3537 1
      GLfloat x, y, s, t, r;
a3541 2
   const GLenum minFilterSave = texObj->Sampler.MinFilter;
   const GLenum magFilterSave = texObj->Sampler.MagFilter;
a3543 5
   const GLenum wrapSSave = texObj->Sampler.WrapS;
   const GLenum wrapTSave = texObj->Sampler.WrapT;
   const GLenum wrapRSave = texObj->Sampler.WrapR;
   const GLenum srgbDecodeSave = texObj->Sampler.sRGBDecode;
   const GLenum srgbBufferSave = ctx->Color.sRGBEnabled;
d3545 4
a3548 1
   const GLuint original_active_unit = ctx->Texture.CurrentUnit;
d3551 2
a3552 1
   GLuint border = 0;
d3568 1
a3568 1
   _mesa_meta_begin(ctx, META_ALL);
d3570 11
a3580 2
   if (original_active_unit != 0)
      _mesa_BindTexture(target, texObj->Name);
d3582 2
a3583 2
   if (mipmap->ArrayObj == 0) {
      /* one-time setup */
d3585 2
a3586 3
      /* create vertex array object */
      _mesa_GenVertexArraysAPPLE(1, &mipmap->ArrayObj);
      _mesa_BindVertexArrayAPPLE(mipmap->ArrayObj);
d3588 2
a3589 5
      /* create vertex array buffer */
      _mesa_GenBuffersARB(1, &mipmap->VBO);
      _mesa_BindBufferARB(GL_ARRAY_BUFFER_ARB, mipmap->VBO);
      _mesa_BufferDataARB(GL_ARRAY_BUFFER_ARB, sizeof(verts),
                          NULL, GL_DYNAMIC_DRAW_ARB);
d3591 2
a3592 9
      /* setup vertex arrays */
      _mesa_VertexPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(x));
      _mesa_TexCoordPointer(3, GL_FLOAT, sizeof(struct vertex), OFFSET(s));
      _mesa_EnableClientState(GL_VERTEX_ARRAY);
      _mesa_EnableClientState(GL_TEXTURE_COORD_ARRAY);
   }
   else {
      _mesa_BindVertexArray(mipmap->ArrayObj);
      _mesa_BindBufferARB(GL_ARRAY_BUFFER_ARB, mipmap->VBO);
d3595 20
a3614 4
   if (!mipmap->FBO) {
      _mesa_GenFramebuffersEXT(1, &mipmap->FBO);
   }
   _mesa_BindFramebufferEXT(GL_FRAMEBUFFER_EXT, mipmap->FBO);
d3616 2
a3617 14
   _mesa_TexParameteri(target, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
   _mesa_TexParameteri(target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
   _mesa_TexParameteri(target, GL_GENERATE_MIPMAP, GL_FALSE);
   _mesa_TexParameteri(target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
   _mesa_TexParameteri(target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
   _mesa_TexParameteri(target, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

   /* We don't want to encode or decode sRGB values; treat them as linear */
   if (ctx->Extensions.EXT_texture_sRGB_decode) {
      _mesa_TexParameteri(target, GL_TEXTURE_SRGB_DECODE_EXT,
                          GL_SKIP_DECODE_EXT);
   }
   if (ctx->Extensions.EXT_framebuffer_sRGB) {
      _mesa_Disable(GL_FRAMEBUFFER_SRGB_EXT);
d3620 1
a3620 1
   _mesa_set_enable(ctx, target, GL_TRUE);
d3622 4
a3625 27
   /* setup texcoords once (XXX what about border?) */
   switch (faceTarget) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
      verts[0].s = 0.0F;
      verts[0].t = 0.0F;
      verts[0].r = 0.0F;
      verts[1].s = 1.0F;
      verts[1].t = 0.0F;
      verts[1].r = 0.0F;
      verts[2].s = 1.0F;
      verts[2].t = 1.0F;
      verts[2].r = 0.0F;
      verts[3].s = 0.0F;
      verts[3].t = 1.0F;
      verts[3].r = 0.0F;
      break;
   case GL_TEXTURE_3D:
      abort();
      break;
   default:
      /* cube face */
      {
         static const GLfloat st[4][2] = {
            {0.0f, 0.0f}, {1.0f, 0.0f}, {1.0f, 1.0f}, {0.0f, 1.0f}
         };
         GLuint i;
d3627 8
a3634 49
         /* loop over quad verts */
         for (i = 0; i < 4; i++) {
            /* Compute sc = +/-scale and tc = +/-scale.
             * Not +/-1 to avoid cube face selection ambiguity near the edges,
             * though that can still sometimes happen with this scale factor...
             */
            const GLfloat scale = 0.9999f;
            const GLfloat sc = (2.0f * st[i][0] - 1.0f) * scale;
            const GLfloat tc = (2.0f * st[i][1] - 1.0f) * scale;

            switch (faceTarget) {
            case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
               verts[i].s = 1.0f;
               verts[i].t = -tc;
               verts[i].r = -sc;
               break;
            case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
               verts[i].s = -1.0f;
               verts[i].t = -tc;
               verts[i].r = sc;
               break;
            case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
               verts[i].s = sc;
               verts[i].t = 1.0f;
               verts[i].r = tc;
               break;
            case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
               verts[i].s = sc;
               verts[i].t = -1.0f;
               verts[i].r = -tc;
               break;
            case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
               verts[i].s = sc;
               verts[i].t = -tc;
               verts[i].r = 1.0f;
               break;
            case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
               verts[i].s = -sc;
               verts[i].t = -tc;
               verts[i].r = -1.0f;
               break;
            default:
               assert(0);
            }
         }
      }
   }

   _mesa_set_enable(ctx, target, GL_TRUE);
d3637 8
a3644 13
   {
      verts[0].x = 0.0F;
      verts[0].y = 0.0F;
      verts[1].x = 1.0F;
      verts[1].y = 0.0F;
      verts[2].x = 1.0F;
      verts[2].y = 1.0F;
      verts[3].x = 0.0F;
      verts[3].y = 1.0F;
      
      /* upload new vertex data */
      _mesa_BufferSubDataARB(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
   }
d3646 3
a3648 4
   /* setup projection matrix */
   _mesa_MatrixMode(GL_PROJECTION);
   _mesa_LoadIdentity();
   _mesa_Ortho(0.0, 1.0, 0.0, 1.0, -1.0, 1.0);
d3661 1
a3661 1
      assert(srcImage->Border == 0); /* XXX we can fix this */
d3663 9
a3671 9
      /* src size w/out border */
      srcWidth = srcImage->Width - 2 * border;
      srcHeight = srcImage->Height - 2 * border;
      srcDepth = srcImage->Depth - 2 * border;

      /* new dst size w/ border */
      dstWidth = MAX2(1, srcWidth / 2) + 2 * border;
      dstHeight = MAX2(1, srcHeight / 2) + 2 * border;
      dstDepth = MAX2(1, srcDepth / 2) + 2 * border;
d3680 3
a3682 1
      /* Set MaxLevel large enough to hold the new level when we allocate it  */
d3685 9
a3693 34
      /* Create empty dest image */
      if (target == GL_TEXTURE_1D) {
         _mesa_TexImage1D(target, dstLevel, srcImage->InternalFormat,
                          dstWidth, border,
                          GL_RGBA, GL_UNSIGNED_BYTE, NULL);
      }
      else if (target == GL_TEXTURE_3D) {
         _mesa_TexImage3D(target, dstLevel, srcImage->InternalFormat,
                          dstWidth, dstHeight, dstDepth, border,
                          GL_RGBA, GL_UNSIGNED_BYTE, NULL);
      }
      else {
         /* 2D or cube */
         _mesa_TexImage2D(faceTarget, dstLevel, srcImage->InternalFormat,
                          dstWidth, dstHeight, border,
                          GL_RGBA, GL_UNSIGNED_BYTE, NULL);

         if (target == GL_TEXTURE_CUBE_MAP) {
            /* If texturing from a cube, we need to make sure all src faces
             * have been defined (even if we're not sampling from them.)
             * Otherwise the texture object will be 'incomplete' and
             * texturing from it will not be allowed.
             */
            GLuint face;
            for (face = 0; face < 6; face++) {
               if (!texObj->Image[face][srcLevel] ||
                   texObj->Image[face][srcLevel]->Width != srcWidth) {
                  _mesa_TexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + face,
                                   srcLevel, srcImage->InternalFormat,
                                   srcWidth, srcHeight, border,
                                   GL_RGBA, GL_UNSIGNED_BYTE, NULL);
               }
            }
         }
d3701 1
a3701 1
         _mesa_FramebufferTexture1DEXT(GL_FRAMEBUFFER_EXT,
d3709 1
a3709 1
         _mesa_FramebufferTexture3DEXT(GL_FRAMEBUFFER_EXT,
d3717 1
a3717 1
         _mesa_FramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT,
d3727 1
a3727 1
      status = _mesa_CheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
d3729 2
a3730 1
         abort();
d3743 1
a3743 7
   if (ctx->Extensions.EXT_texture_sRGB_decode) {
      _mesa_TexParameteri(target, GL_TEXTURE_SRGB_DECODE_EXT,
                          srgbDecodeSave);
   }
   if (ctx->Extensions.EXT_framebuffer_sRGB && srgbBufferSave) {
      _mesa_Enable(GL_FRAMEBUFFER_SRGB_EXT);
   }
d3745 1
a3745 1
   _mesa_lock_texture(ctx, texObj); /* relock */
a3748 2
   _mesa_TexParameteri(target, GL_TEXTURE_MIN_FILTER, minFilterSave);
   _mesa_TexParameteri(target, GL_TEXTURE_MAG_FILTER, magFilterSave);
d3750 2
a3751 4
   _mesa_TexParameteri(target, GL_GENERATE_MIPMAP, genMipmapSave);
   _mesa_TexParameteri(target, GL_TEXTURE_WRAP_S, wrapSSave);
   _mesa_TexParameteri(target, GL_TEXTURE_WRAP_T, wrapTSave);
   _mesa_TexParameteri(target, GL_TEXTURE_WRAP_R, wrapRSave);
d3753 1
a3753 1
   _mesa_BindFramebufferEXT(GL_FRAMEBUFFER_EXT, fboSave);
d3762 1
a3762 1
get_temp_image_type(struct gl_context *ctx, GLenum baseFormat)
d3764 4
d3771 2
d3777 1
a3777 1
      if (ctx->DrawBuffer->Visual.redBits <= 8)
d3779 1
a3779 1
      else if (ctx->DrawBuffer->Visual.redBits <= 8)
d3781 17
d3799 2
a3800 5
         return GL_FLOAT;
   case GL_DEPTH_COMPONENT:
      return GL_UNSIGNED_INT;
   case GL_DEPTH_STENCIL:
      return GL_UNSIGNED_INT_24_8;
d3802 2
a3803 1
      _mesa_problem(ctx, "Unexpected format in get_temp_image_type()");
d3810 1
a3810 1
 * Helper for _mesa_meta_CopyTexImage1/2D() functions.
d3813 7
a3819 4
static void
copy_tex_image(struct gl_context *ctx, GLuint dims, GLenum target, GLint level,
               GLenum internalFormat, GLint x, GLint y,
               GLsizei width, GLsizei height, GLint border)
d3821 1
a3821 2
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
a3824 4
   struct gl_renderbuffer *read_rb = ctx->ReadBuffer->_ColorReadBuffer;

   texObj = _mesa_get_current_tex_object(ctx, target);
   texImage = _mesa_get_tex_image(ctx, texObj, target, level);
d3827 7
a3833 10
   format = _mesa_base_tex_format(ctx, internalFormat);

   if (format == GL_LUMINANCE &&
       _mesa_get_format_base_format(read_rb->Format) != GL_LUMINANCE) {
      /* The glReadPixels() path will convert RGB to luminance by
       * summing R+G+B.  glCopyTexImage() is supposed to behave as
       * glCopyPixels, which doesn't do that change, and instead
       * leaves it up to glTexImage which converts RGB to luminance by
       * just taking the R channel.  To avoid glReadPixels() trashing
       * our data, use RGBA for our temporary image.
d3838 4
a3841 1
   type = get_temp_image_type(ctx, format);
d3844 1
a3844 1
      _mesa_problem(ctx, "Bad bpp in meta copy_tex_image()");
d3853 1
a3853 1
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexImage%uD", dims);
d3862 1
a3862 1
   _mesa_meta_begin(ctx, META_PIXEL_STORE | META_PIXEL_TRANSFER);
d3867 1
a3867 6
   if (texImage->Data) {
      ctx->Driver.FreeTexImageData(ctx, texImage);
   }

   /* The texture's format was already chosen in _mesa_CopyTexImage() */
   ASSERT(texImage->TexFormat != MESA_FORMAT_NONE);
d3872 1
a3872 1
   _mesa_meta_begin(ctx, META_PIXEL_STORE);
d3874 10
a3883 1
   _mesa_update_state(ctx); /* to update pixel transfer state */
a3884 10
   if (target == GL_TEXTURE_1D) {
      ctx->Driver.TexImage1D(ctx, target, level, internalFormat,
                             width, border, format, type,
                             buf, &ctx->Unpack, texObj, texImage);
   }
   else {
      ctx->Driver.TexImage2D(ctx, target, level, internalFormat,
                             width, height, border, format, type,
                             buf, &ctx->Unpack, texObj, texImage);
   }
d3893 99
a3991 8
void
_mesa_meta_CopyTexImage1D(struct gl_context *ctx, GLenum target, GLint level,
                          GLenum internalFormat, GLint x, GLint y,
                          GLsizei width, GLint border)
{
   copy_tex_image(ctx, 1, target, level, internalFormat, x, y,
                  width, 1, border);
}
d3993 21
d4015 9
a4023 8
void
_mesa_meta_CopyTexImage2D(struct gl_context *ctx, GLenum target, GLint level,
                          GLenum internalFormat, GLint x, GLint y,
                          GLsizei width, GLsizei height, GLint border)
{
   copy_tex_image(ctx, 2, target, level, internalFormat, x, y,
                  width, height, border);
}
d4025 2
d4028 3
d4032 4
a4035 16
/**
 * Helper for _mesa_meta_CopyTexSubImage1/2/3D() functions.
 * Have to be careful with locking and meta state for pixel transfer.
 */
static void
copy_tex_sub_image(struct gl_context *ctx,
                   GLuint dims, GLenum target, GLint level,
                   GLint xoffset, GLint yoffset, GLint zoffset,
                   GLint x, GLint y,
                   GLsizei width, GLsizei height)
{
   struct gl_texture_object *texObj;
   struct gl_texture_image *texImage;
   GLenum format, type;
   GLint bpp;
   void *buf;
d4037 5
a4041 2
   texObj = _mesa_get_current_tex_object(ctx, target);
   texImage = _mesa_select_tex_image(ctx, texObj, target, level);
d4043 5
a4047 8
   /* Choose format/type for temporary image buffer */
   format = _mesa_get_format_base_format(texImage->TexFormat);
   if (format == GL_LUMINANCE ||
       format == GL_LUMINANCE_ALPHA ||
       format == GL_INTENSITY) {
      /* We don't want to use GL_LUMINANCE, GL_INTENSITY, etc. for the
       * temp image buffer because glReadPixels will do L=R+G+B which is
       * not what we want (should be L=R).
d4049 5
a4053 1
      format = GL_RGBA;
d4056 31
a4086 5
   type = get_temp_image_type(ctx, format);
   bpp = _mesa_bytes_per_pixel(format, type);
   if (bpp <= 0) {
      _mesa_problem(ctx, "Bad bpp in meta copy_tex_sub_image()");
      return;
d4089 2
a4090 8
   /*
    * Alloc image buffer (XXX could use a PBO)
    */
   buf = malloc(width * height * bpp);
   if (!buf) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage%uD", dims);
      return;
   }
d4092 1
a4092 1
   _mesa_unlock_texture(ctx, texObj); /* need to unlock first */
a4093 6
   /*
    * Read image from framebuffer (disable pixel transfer ops)
    */
   _mesa_meta_begin(ctx, META_PIXEL_STORE | META_PIXEL_TRANSFER);
   ctx->Driver.ReadPixels(ctx, x, y, width, height,
			  format, type, &ctx->Pack, buf);
d4096 11
a4106 1
   _mesa_update_state(ctx); /* to update pixel transfer state */
d4108 13
a4120 2
   /*
    * Store texture data (with pixel transfer ops)
d4122 29
a4150 10
   _mesa_meta_begin(ctx, META_PIXEL_STORE);
   if (target == GL_TEXTURE_1D) {
      ctx->Driver.TexSubImage1D(ctx, target, level, xoffset,
                                width, format, type, buf,
                                &ctx->Unpack, texObj, texImage);
   }
   else if (target == GL_TEXTURE_3D) {
      ctx->Driver.TexSubImage3D(ctx, target, level, xoffset, yoffset, zoffset,
                                width, height, 1, format, type, buf,
                                &ctx->Unpack, texObj, texImage);
d4153 1
a4153 3
      ctx->Driver.TexSubImage2D(ctx, target, level, xoffset, yoffset,
                                width, height, format, type, buf,
                                &ctx->Unpack, texObj, texImage);
a4154 5
   _mesa_meta_end(ctx);

   _mesa_lock_texture(ctx, texObj); /* re-lock */

   free(buf);
d4158 4
d4163 2
a4164 3
_mesa_meta_CopyTexSubImage1D(struct gl_context *ctx, GLenum target, GLint level,
                             GLint xoffset,
                             GLint x, GLint y, GLsizei width)
d4166 6
a4171 3
   copy_tex_sub_image(ctx, 1, target, level, xoffset, 0, 0,
                      x, y, width, 1);
}
d4173 5
d4179 3
a4181 9
void
_mesa_meta_CopyTexSubImage2D(struct gl_context *ctx, GLenum target, GLint level,
                             GLint xoffset, GLint yoffset,
                             GLint x, GLint y,
                             GLsizei width, GLsizei height)
{
   copy_tex_sub_image(ctx, 2, target, level, xoffset, yoffset, 0,
                      x, y, width, height);
}
d4183 3
d4187 5
a4191 9
void
_mesa_meta_CopyTexSubImage3D(struct gl_context *ctx, GLenum target, GLint level,
                             GLint xoffset, GLint yoffset, GLint zoffset,
                             GLint x, GLint y,
                             GLsizei width, GLsizei height)
{
   copy_tex_sub_image(ctx, 3, target, level, xoffset, yoffset, zoffset,
                      x, y, width, height);
}
d4193 2
d4196 8
a4203 6
void
_mesa_meta_CopyColorTable(struct gl_context *ctx,
                          GLenum target, GLenum internalformat,
                          GLint x, GLint y, GLsizei width)
{
   GLfloat *buf;
d4205 6
a4210 4
   buf = (GLfloat *) malloc(width * 4 * sizeof(GLfloat));
   if (!buf) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyColorTable");
      return;
d4213 43
a4255 6
   /*
    * Read image from framebuffer (disable pixel transfer ops)
    */
   _mesa_meta_begin(ctx, META_PIXEL_STORE | META_PIXEL_TRANSFER);
   ctx->Driver.ReadPixels(ctx, x, y, width, 1,
                          GL_RGBA, GL_FLOAT, &ctx->Pack, buf);
d4257 4
a4260 1
   _mesa_ColorTable(target, internalformat, width, GL_RGBA, GL_FLOAT, buf);
d4262 2
a4263 1
   _mesa_meta_end(ctx);
d4265 2
a4266 2
   free(buf);
}
d4268 2
d4271 3
a4273 5
void
_mesa_meta_CopyColorSubTable(struct gl_context *ctx,GLenum target, GLsizei start,
                             GLint x, GLint y, GLsizei width)
{
   GLfloat *buf;
d4275 1
a4275 4
   buf = (GLfloat *) malloc(width * 4 * sizeof(GLfloat));
   if (!buf) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyColorSubTable");
      return;
d4278 1
a4278 8
   /*
    * Read image from framebuffer (disable pixel transfer ops)
    */
   _mesa_meta_begin(ctx, META_PIXEL_STORE | META_PIXEL_TRANSFER);
   ctx->Driver.ReadPixels(ctx, x, y, width, 1,
                          GL_RGBA, GL_FLOAT, &ctx->Pack, buf);

   _mesa_ColorSubTable(target, start, width, GL_RGBA, GL_FLOAT, buf);
a4280 2

   free(buf);
@


1.3
log
@Merge Mesa 7.10.3
@
text
@d43 1
d52 1
d96 3
d187 10
d474 1
a474 1
					ctx->Shader.CurrentFragmentProgram);
d586 28
d878 14
d1183 2
a1184 2
         const GLenum minFilterSave = texObj->MinFilter;
         const GLenum magFilterSave = texObj->MagFilter;
d1187 4
a1190 2
         const GLenum wrapSSave = texObj->WrapS;
         const GLenum wrapTSave = texObj->WrapT;
d1222 10
d1293 6
d1483 4
a1486 1
   GLbitfield metaSave = META_ALL - META_SCISSOR - META_PIXEL_STORE;
d1521 3
d1577 4
a1580 4
         verts[i].r = ctx->Color.ClearColor[0];
         verts[i].g = ctx->Color.ClearColor[1];
         verts[i].b = ctx->Color.ClearColor[2];
         verts[i].a = ctx->Color.ClearColor[3];
d1886 9
d1953 1
d2297 9
d2361 2
a2362 3
   const GLenum minFilterSave = texObj->MinFilter;
   const GLenum magFilterSave = texObj->MagFilter;
   const GLint baseLevelSave = texObj->BaseLevel;
d2365 5
a2369 3
   const GLenum wrapSSave = texObj->WrapS;
   const GLenum wrapTSave = texObj->WrapT;
   const GLenum wrapRSave = texObj->WrapR;
d2424 1
a2424 1
   _mesa_TexParameteri(target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
d2431 9
d2609 1
a2609 2
      /* limit sampling to src level */
      _mesa_TexParameteri(target, GL_TEXTURE_BASE_LEVEL, srcLevel);
d2655 8
a2668 1
   _mesa_TexParameteri(target, GL_TEXTURE_BASE_LEVEL, baseLevelSave);
d2724 1
d2731 13
d2845 10
@


1.2
log
@Update to Mesa 7.8.2. Tested by johan@@. Thanks.
@
text
@d37 1
a42 1
#include "main/convolve.h"
d54 2
a55 1
#include "main/shaders.h"
d65 1
a65 2
#include "shader/program.h"
#include "shader/arbprogram.h"
d107 2
a132 3
   GLboolean Convolution1DEnabled;
   GLboolean Convolution2DEnabled;
   GLboolean Separable2DEnabled;
d149 4
a152 1
   GLuint Shader;
d269 1
a269 1

d275 4
a278 1
   struct save_state Save;    /**< state saved during meta-ops */
d296 1
a296 1
_mesa_meta_init(GLcontext *ctx)
d309 1
a309 1
_mesa_meta_free(GLcontext *ctx)
d328 1
a328 1
_mesa_meta_begin(GLcontext *ctx, GLbitfield state)
d330 4
a333 1
   struct save_state *save = &ctx->Meta->Save;
d335 2
d341 2
a403 3
      save->Convolution1DEnabled = ctx->Pixel.Convolution1DEnabled;
      save->Convolution2DEnabled = ctx->Pixel.Convolution2DEnabled;
      save->Separable2DEnabled = ctx->Pixel.Separable2DEnabled;
a412 3
      ctx->Pixel.Convolution1DEnabled = GL_FALSE;
      ctx->Pixel.Convolution2DEnabled = GL_FALSE;
      ctx->Pixel.Separable2DEnabled = GL_FALSE;
d439 2
a440 1
         save->VertexProgram = ctx->VertexProgram.Current;
d446 2
a447 1
         save->FragmentProgram = ctx->FragmentProgram.Current;
d452 9
a460 2
         save->Shader = ctx->Shader.CurrentProgram ?
            ctx->Shader.CurrentProgram->Name : 0;
d489 2
a490 1
            _mesa_set_enable(ctx, GL_TEXTURE_CUBE_MAP, GL_FALSE);
d584 1
a584 1
_mesa_meta_end(GLcontext *ctx)
d586 1
a586 1
   struct save_state *save = &ctx->Meta->Save;
d592 1
a655 3
      ctx->Pixel.Convolution1DEnabled = save->Convolution1DEnabled;
      ctx->Pixel.Convolution2DEnabled = save->Convolution2DEnabled;
      ctx->Pixel.Separable2DEnabled = save->Separable2DEnabled;
d681 1
d689 1
d692 13
a704 3
      if (ctx->Extensions.ARB_shader_objects) {
         _mesa_UseProgramObjectARB(save->Shader);
      }
d750 1
d862 1
a862 1
init_temp_texture(GLcontext *ctx, struct temp_texture *tex)
a879 1
   _mesa_BindTexture(tex->Target, tex->TexObj);
d888 1
a888 1
get_temp_texture(GLcontext *ctx)
d906 1
a906 1
get_bitmap_temp_texture(GLcontext *ctx)
d1022 1
a1022 1
setup_drawpix_texture(GLcontext *ctx,
d1073 1
a1073 1
init_blit_depth_pixels(GLcontext *ctx)
d1110 1
a1110 1
blitframebuffer_texture(GLcontext *ctx,
d1239 1
a1239 1
_mesa_meta_BlitFramebuffer(GLcontext *ctx,
d1400 1
a1400 1
_mesa_meta_Clear(GLcontext *ctx, GLbitfield buffers)
d1409 1
d1465 1
a1465 1
                                ctx->Stencil.Clear & 0x7fffffff,
d1519 1
a1519 1
_mesa_meta_CopyPixels(GLcontext *ctx, GLint srcX, GLint srcY,
d1633 1
a1633 1
tiled_draw_pixels(GLcontext *ctx,
d1669 1
a1669 1
init_draw_stencil_pixels(GLcontext *ctx)
d1733 1
a1733 1
init_draw_depth_pixels(GLcontext *ctx)
d1768 1
a1768 1
_mesa_meta_DrawPixels(GLcontext *ctx,
d1992 28
d2022 3
a2024 5
 * Do glBitmap with a alpha texture quad.  Use the alpha test to
 * cull the 'off' bits.  If alpha test is already enabled, fall back
 * to swrast (should be a rare case).
 * A bitmap cache as in the gallium/mesa state tracker would
 * improve performance a lot.
d2027 1
a2027 1
_mesa_meta_Bitmap(GLcontext *ctx,
d2036 1
d2048 1
a2048 1
       ctx->Color.AlphaEnabled ||
d2057 3
d2141 4
d2146 2
a2147 1
   if (!bitmap1)
d2149 1
d2151 1
a2151 1
   bitmap8 = (GLubyte *) calloc(1, width * height);
d2153 1
d2155 1
a2155 1
                          bitmap8, width, 0xff);
d2160 1
a2160 1
      _mesa_AlphaFunc(GL_GREATER, 0.0);
d2185 1
a2185 1
_mesa_meta_check_generate_mipmap_fallback(GLcontext *ctx, GLenum target,
d2251 1
a2251 1
_mesa_meta_GenerateMipmap(GLcontext *ctx, GLenum target,
d2460 3
d2568 1
a2568 1
get_temp_image_type(GLcontext *ctx, GLenum baseFormat)
d2599 1
a2599 1
copy_tex_image(GLcontext *ctx, GLuint dims, GLenum target, GLint level,
a2604 1
   GLsizei postConvWidth = width, postConvHeight = height;
d2612 1
a2629 6
   if (texImage->TexFormat == MESA_FORMAT_NONE)
      texImage->TexFormat = ctx->Driver.ChooseTextureFormat(ctx,
                                                            internalFormat,
                                                            format,
                                                            type);

a2639 10
   /*
    * Prepare for new texture image size/data
    */
#if FEATURE_convolve
   if (_mesa_is_color_format(internalFormat)) {
      _mesa_adjust_image_for_convolution(ctx, 2,
                                         &postConvWidth, &postConvHeight);
   }
#endif

d2644 2
a2645 3
   _mesa_init_teximage_fields(ctx, target, texImage,
                              postConvWidth, postConvHeight, 1,
                              border, internalFormat);
d2673 1
a2673 1
_mesa_meta_CopyTexImage1D(GLcontext *ctx, GLenum target, GLint level,
d2683 1
a2683 1
_mesa_meta_CopyTexImage2D(GLcontext *ctx, GLenum target, GLint level,
d2698 2
a2699 1
copy_tex_sub_image(GLcontext *ctx, GLuint dims, GLenum target, GLint level,
d2713 1
d2771 1
a2771 1
_mesa_meta_CopyTexSubImage1D(GLcontext *ctx, GLenum target, GLint level,
d2781 1
a2781 1
_mesa_meta_CopyTexSubImage2D(GLcontext *ctx, GLenum target, GLint level,
d2792 1
a2792 1
_mesa_meta_CopyTexSubImage3D(GLcontext *ctx, GLenum target, GLint level,
d2803 1
a2803 1
_mesa_meta_CopyColorTable(GLcontext *ctx,
d2831 1
a2831 1
_mesa_meta_CopyColorSubTable(GLcontext *ctx,GLenum target, GLsizei start,
a2849 61

   _mesa_meta_end(ctx);

   free(buf);
}


void
_mesa_meta_CopyConvolutionFilter1D(GLcontext *ctx, GLenum target,
                                   GLenum internalFormat,
                                   GLint x, GLint y, GLsizei width)
{
   GLfloat *buf;

   buf = (GLfloat *) malloc(width * 4 * sizeof(GLfloat));
   if (!buf) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyConvolutionFilter2D");
      return;
   }

   /*
    * Read image from framebuffer (disable pixel transfer ops)
    */
   _mesa_meta_begin(ctx, META_PIXEL_STORE | META_PIXEL_TRANSFER);
   _mesa_update_state(ctx);
   ctx->Driver.ReadPixels(ctx, x, y, width, 1,
                          GL_RGBA, GL_FLOAT, &ctx->Pack, buf);

   _mesa_ConvolutionFilter1D(target, internalFormat, width,
                             GL_RGBA, GL_FLOAT, buf);

   _mesa_meta_end(ctx);

   free(buf);
}


void
_mesa_meta_CopyConvolutionFilter2D(GLcontext *ctx, GLenum target,
                                   GLenum internalFormat, GLint x, GLint y,
                                   GLsizei width, GLsizei height)
{
   GLfloat *buf;

   buf = (GLfloat *) malloc(width * height * 4 * sizeof(GLfloat));
   if (!buf) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyConvolutionFilter2D");
      return;
   }

   /*
    * Read image from framebuffer (disable pixel transfer ops)
    */
   _mesa_meta_begin(ctx, META_PIXEL_STORE | META_PIXEL_TRANSFER);
   _mesa_update_state(ctx);

   ctx->Driver.ReadPixels(ctx, x, y, width, height,
                          GL_RGBA, GL_FLOAT, &ctx->Pack, buf);

   _mesa_ConvolutionFilter2D(target, internalFormat, width, height,
                             GL_RGBA, GL_FLOAT, buf);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d816 15
d1451 1
a1451 1
      const GLfloat z = 1.0 - 2.0 * ctx->Depth.Clear;
d1557 1
a1557 1
      const GLfloat z = ctx->Current.RasterPos[2];
d1846 1
a1846 1
      const GLfloat z = ctx->Current.RasterPos[2];
d2049 1
a2049 1
      const GLfloat z = ctx->Current.RasterPos[2];
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a36 1
#include "main/arbprogram.h"
d42 1
d54 1
a54 2
#include "main/shaderapi.h"
#include "main/shaderobj.h"
d64 2
a65 1
#include "program/program.h"
a106 2
   GLenum AlphaFunc;
   GLclampf AlphaRef;
d131 3
d150 1
a150 4
   struct gl_shader_program *VertexShader;
   struct gl_shader_program *GeometryShader;
   struct gl_shader_program *FragmentShader;
   struct gl_shader_program *ActiveShader;
d267 1
a267 1
#define MAX_META_OPS_DEPTH      2
d273 1
a273 4
   /** Stack of state saved during meta-ops */
   struct save_state Save[MAX_META_OPS_DEPTH];
   /** Save stack depth */
   GLuint SaveStackDepth;
d291 1
a291 1
_mesa_meta_init(struct gl_context *ctx)
d304 1
a304 1
_mesa_meta_free(struct gl_context *ctx)
d323 1
a323 1
_mesa_meta_begin(struct gl_context *ctx, GLbitfield state)
d325 1
a325 4
   struct save_state *save;

   /* hope MAX_META_OPS_DEPTH is large enough */
   assert(ctx->Meta->SaveStackDepth < MAX_META_OPS_DEPTH);
a326 2
   save = &ctx->Meta->Save[ctx->Meta->SaveStackDepth++];
   memset(save, 0, sizeof(*save));
a330 2
      save->AlphaFunc = ctx->Color.AlphaFunc;
      save->AlphaRef = ctx->Color.AlphaRef;
d392 3
d404 3
d433 1
a433 2
         _mesa_reference_vertprog(ctx, &save->VertexProgram,
				  ctx->VertexProgram.Current);
d439 1
a439 2
         _mesa_reference_fragprog(ctx, &save->FragmentProgram,
				  ctx->FragmentProgram.Current);
d444 2
a445 9
	 _mesa_reference_shader_program(ctx, &save->VertexShader,
					ctx->Shader.CurrentVertexProgram);
	 _mesa_reference_shader_program(ctx, &save->GeometryShader,
					ctx->Shader.CurrentGeometryProgram);
	 _mesa_reference_shader_program(ctx, &save->FragmentShader,
					ctx->Shader.CurrentFragmentProgram);
	 _mesa_reference_shader_program(ctx, &save->ActiveShader,
					ctx->Shader.CurrentFragmentProgram);

d474 1
a474 2
            if (ctx->Extensions.ARB_texture_cube_map)
               _mesa_set_enable(ctx, GL_TEXTURE_CUBE_MAP, GL_FALSE);
d568 1
a568 1
_mesa_meta_end(struct gl_context *ctx)
d570 1
a570 1
   struct save_state *save = &ctx->Meta->Save[--ctx->Meta->SaveStackDepth];
a575 1
      _mesa_AlphaFunc(save->AlphaFunc, save->AlphaRef);
d639 3
a666 1
	 _mesa_reference_vertprog(ctx, &save->VertexProgram, NULL);
a673 1
	 _mesa_reference_fragprog(ctx, &save->FragmentProgram, NULL);
d676 3
a678 13
      if (ctx->Extensions.ARB_vertex_shader)
	 _mesa_use_shader_program(ctx, GL_VERTEX_SHADER, save->VertexShader);

      if (ctx->Extensions.ARB_geometry_shader4)
	 _mesa_use_shader_program(ctx, GL_GEOMETRY_SHADER_ARB,
				  save->GeometryShader);

      if (ctx->Extensions.ARB_fragment_shader)
	 _mesa_use_shader_program(ctx, GL_FRAGMENT_SHADER,
				  save->FragmentShader);

      _mesa_reference_shader_program(ctx, &ctx->Shader.ActiveProgram,
				     save->ActiveShader);
a723 1
         _mesa_reference_texobj(&save->CurrentTexture[tgt], NULL);
a815 15
 * Convert Z from a normalized value in the range [0, 1] to an object-space
 * Z coordinate in [-1, +1] so that drawing at the new Z position with the
 * default/identity ortho projection results in the original Z value.
 * Used by the meta-Clear, Draw/CopyPixels and Bitmap functions where the Z
 * value comes from the clear value or raster position.
 */
static INLINE GLfloat
invert_z(GLfloat normZ)
{
   GLfloat objZ = 1.0 - 2.0 * normZ;
   return objZ;
}


/**
d820 1
a820 1
init_temp_texture(struct gl_context *ctx, struct temp_texture *tex)
d838 1
d847 1
a847 1
get_temp_texture(struct gl_context *ctx)
d865 1
a865 1
get_bitmap_temp_texture(struct gl_context *ctx)
d981 1
a981 1
setup_drawpix_texture(struct gl_context *ctx,
d1032 1
a1032 1
init_blit_depth_pixels(struct gl_context *ctx)
d1069 1
a1069 1
blitframebuffer_texture(struct gl_context *ctx,
d1198 1
a1198 1
_mesa_meta_BlitFramebuffer(struct gl_context *ctx,
d1359 1
a1359 1
_mesa_meta_Clear(struct gl_context *ctx, GLbitfield buffers)
a1367 1
   const GLuint stencilMax = (1 << ctx->DrawBuffer->Visual.stencilBits) - 1;
d1423 1
a1423 1
                                ctx->Stencil.Clear & stencilMax,
d1436 1
a1436 1
      const GLfloat z = invert_z(ctx->Depth.Clear);
d1477 1
a1477 1
_mesa_meta_CopyPixels(struct gl_context *ctx, GLint srcX, GLint srcY,
d1542 1
a1542 1
      const GLfloat z = invert_z(ctx->Current.RasterPos[2]);
d1591 1
a1591 1
tiled_draw_pixels(struct gl_context *ctx,
d1627 1
a1627 1
init_draw_stencil_pixels(struct gl_context *ctx)
d1691 1
a1691 1
init_draw_depth_pixels(struct gl_context *ctx)
d1726 1
a1726 1
_mesa_meta_DrawPixels(struct gl_context *ctx,
d1831 1
a1831 1
      const GLfloat z = invert_z(ctx->Current.RasterPos[2]);
a1949 28
static GLboolean
alpha_test_raster_color(struct gl_context *ctx)
{
   GLfloat alpha = ctx->Current.RasterColor[ACOMP];
   GLfloat ref = ctx->Color.AlphaRef;

   switch (ctx->Color.AlphaFunc) {
      case GL_NEVER:
	 return GL_FALSE;
      case GL_LESS:
	 return alpha < ref;
      case GL_EQUAL:
	 return alpha == ref;
      case GL_LEQUAL:
	 return alpha <= ref;
      case GL_GREATER:
	 return alpha > ref;
      case GL_NOTEQUAL:
	 return alpha != ref;
      case GL_GEQUAL:
	 return alpha >= ref;
      case GL_ALWAYS:
	 return GL_TRUE;
      default:
	 assert(0);
	 return GL_FALSE;
   }
}
d1952 5
a1956 3
 * Do glBitmap with a alpha texture quad.  Use the alpha test to cull
 * the 'off' bits.  A bitmap cache as in the gallium/mesa state
 * tracker would improve performance a lot.
d1959 1
a1959 1
_mesa_meta_Bitmap(struct gl_context *ctx,
a1967 1
   GLubyte fg, bg;
d1979 1
a1979 1
       ctx->FragmentProgram._Enabled ||
a1987 3
   if (ctx->Color.AlphaEnabled && !alpha_test_raster_color(ctx))
      return;

d2034 1
a2034 1
      const GLfloat z = invert_z(ctx->Current.RasterPos[2]);
a2068 4
   /* choose different foreground/background alpha values */
   CLAMPED_FLOAT_TO_UBYTE(fg, ctx->Current.RasterColor[ACOMP]);
   bg = (fg > 127 ? 0 : 255);

d2070 1
a2070 2
   if (!bitmap1) {
      _mesa_meta_end(ctx);
a2071 1
   }
d2073 1
a2073 1
   bitmap8 = (GLubyte *) malloc(width * height);
a2074 1
      memset(bitmap8, bg, width * height);
d2076 1
a2076 1
                          bitmap8, width, fg);
d2081 1
a2081 1
      _mesa_AlphaFunc(GL_NOTEQUAL, UBYTE_TO_FLOAT(bg));
d2106 1
a2106 1
_mesa_meta_check_generate_mipmap_fallback(struct gl_context *ctx, GLenum target,
d2172 1
a2172 1
_mesa_meta_GenerateMipmap(struct gl_context *ctx, GLenum target,
a2380 3
      /* Set MaxLevel large enough to hold the new level when we allocate it  */
      _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, dstLevel);

d2486 1
a2486 1
get_temp_image_type(struct gl_context *ctx, GLenum baseFormat)
d2517 1
a2517 1
copy_tex_image(struct gl_context *ctx, GLuint dims, GLenum target, GLint level,
d2523 1
a2530 1
   /* Choose format/type for temporary image buffer */
d2548 6
d2564 10
d2578 3
a2580 2
   /* The texture's format was already chosen in _mesa_CopyTexImage() */
   ASSERT(texImage->TexFormat != MESA_FORMAT_NONE);
d2608 1
a2608 1
_mesa_meta_CopyTexImage1D(struct gl_context *ctx, GLenum target, GLint level,
d2618 1
a2618 1
_mesa_meta_CopyTexImage2D(struct gl_context *ctx, GLenum target, GLint level,
d2633 1
a2633 2
copy_tex_sub_image(struct gl_context *ctx,
                   GLuint dims, GLenum target, GLint level,
a2646 1
   /* Choose format/type for temporary image buffer */
d2704 1
a2704 1
_mesa_meta_CopyTexSubImage1D(struct gl_context *ctx, GLenum target, GLint level,
d2714 1
a2714 1
_mesa_meta_CopyTexSubImage2D(struct gl_context *ctx, GLenum target, GLint level,
d2725 1
a2725 1
_mesa_meta_CopyTexSubImage3D(struct gl_context *ctx, GLenum target, GLint level,
d2736 1
a2736 1
_mesa_meta_CopyColorTable(struct gl_context *ctx,
d2764 1
a2764 1
_mesa_meta_CopyColorSubTable(struct gl_context *ctx,GLenum target, GLsizei start,
d2783 61
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a42 1
#include "main/condrender.h"
a45 1
#include "main/feedback.h"
a46 1
#include "main/glformats.h"
a50 2
#include "main/pixel.h"
#include "main/pbo.h"
a51 1
#include "main/queryobj.h"
a59 1
#include "main/texgetimage.h"
a62 2
#include "main/transformfeedback.h"
#include "main/uniforms.h"
a64 1
#include "main/samplerobj.h"
d68 1
a68 3
#include "main/enums.h"
#include "main/glformats.h"
#include "../glsl/ralloc.h"
d73 24
d103 1
a103 1
   GLbitfield SavedState;  /**< bitmask of MESA_META_* flags */
d105 1
a105 4
   /** MESA_META_CLEAR (and others?) */
   struct gl_query_object *CurrentOcclusionObject;

   /** MESA_META_ALPHA_TEST */
d110 1
a110 1
   /** MESA_META_BLEND */
d114 1
a114 1
   /** MESA_META_COLOR_MASK */
d117 1
a117 1
   /** MESA_META_DEPTH_TEST */
d120 1
a120 1
   /** MESA_META_FOG */
d123 1
a123 1
   /** MESA_META_PIXEL_STORE */
d126 1
a126 1
   /** MESA_META_PIXEL_TRANSFER */
d134 1
a134 1
   /** MESA_META_RASTERIZATION */
d141 1
a141 1
   /** MESA_META_SCISSOR */
d144 1
a144 1
   /** MESA_META_SHADER */
a148 1
   GLboolean ATIFragmentShaderEnabled;
d154 1
a154 1
   /** MESA_META_STENCIL_TEST */
d157 1
a157 1
   /** MESA_META_TRANSFORM */
a161 2

   /** MESA_META_CLIP */
d164 1
a164 1
   /** MESA_META_TEXTURE */
d174 1
a174 1
   /** MESA_META_VERTEX */
d178 1
a178 1
   /** MESA_META_VIEWPORT */
a181 21
   /** MESA_META_CLAMP_FRAGMENT_COLOR */
   GLenum ClampFragmentColor;

   /** MESA_META_CLAMP_VERTEX_COLOR */
   GLenum ClampVertexColor;

   /** MESA_META_CONDITIONAL_RENDER */
   struct gl_query_object *CondRenderQuery;
   GLenum CondRenderMode;

   /** MESA_META_SELECT_FEEDBACK */
   GLenum RenderMode;
   struct gl_selection Select;
   struct gl_feedback Feedback;

   /** MESA_META_MULTISAMPLE */
   GLboolean MultisampleEnabled;

   /** MESA_META_FRAMEBUFFER_SRGB */
   GLboolean sRGBEnabled;

a183 2
   GLboolean RasterDiscard;
   GLboolean TransformFeedbackNeedsResume;
d186 1
a212 3
   GLuint ShaderProg;
   GLuint RectShaderProg;
   struct temp_texture depthTex;
a222 5
   GLuint ShaderProg;
   GLint ColorLocation;

   GLuint IntegerShaderProg;
   GLint IntegerColorLocation;
a257 10
/**
 * State for GLSL texture sampler which is used to generate fragment
 * shader in _mesa_meta_generate_mipmap().
 */
struct glsl_sampler {
   const char *type;
   const char *func;
   const char *texcoords;
   GLuint shader_prog;
};
a266 18
   GLuint Sampler;
   GLuint ShaderProg;
   struct glsl_sampler sampler_1d;
   struct glsl_sampler sampler_2d;
   struct glsl_sampler sampler_3d;
   struct glsl_sampler sampler_cubemap;
   struct glsl_sampler sampler_1d_array;
   struct glsl_sampler sampler_2d_array;
};

/**
 * State for texture decompression
 */
struct decompress_state
{
   GLuint ArrayObj;
   GLuint VBO, FBO, RBO, Sampler;
   GLint Width, Height;
d269 1
a269 10
/**
 * State for glDrawTex()
 */
struct drawtex_state
{
   GLuint ArrayObj;
   GLuint VBO;
};

#define MAX_META_OPS_DEPTH      8
a287 2
   struct decompress_state Decompress;  /**< For texture decompression */
   struct drawtex_state DrawTex;  /**< For _mesa_meta_DrawTex() */
a289 72
static void meta_glsl_blit_cleanup(struct gl_context *ctx, struct blit_state *blit);
static void cleanup_temp_texture(struct gl_context *ctx, struct temp_texture *tex);
static void meta_glsl_clear_cleanup(struct gl_context *ctx, struct clear_state *clear);
static void meta_glsl_generate_mipmap_cleanup(struct gl_context *ctx,
                                              struct gen_mipmap_state *mipmap);

static GLuint
compile_shader_with_debug(struct gl_context *ctx, GLenum target, const GLcharARB *source)
{
   GLuint shader;
   GLint ok, size;
   GLchar *info;

   shader = _mesa_CreateShaderObjectARB(target);
   _mesa_ShaderSource(shader, 1, &source, NULL);
   _mesa_CompileShader(shader);

   _mesa_GetShaderiv(shader, GL_COMPILE_STATUS, &ok);
   if (ok)
      return shader;

   _mesa_GetShaderiv(shader, GL_INFO_LOG_LENGTH, &size);
   if (size == 0) {
      _mesa_DeleteObjectARB(shader);
      return 0;
   }

   info = malloc(size);
   if (!info) {
      _mesa_DeleteObjectARB(shader);
      return 0;
   }

   _mesa_GetProgramInfoLog(shader, size, NULL, info);
   _mesa_problem(ctx,
		 "meta program compile failed:\n%s\n"
		 "source:\n%s\n",
		 info, source);

   free(info);
   _mesa_DeleteObjectARB(shader);

   return 0;
}

static GLuint
link_program_with_debug(struct gl_context *ctx, GLuint program)
{
   GLint ok, size;
   GLchar *info;

   _mesa_LinkProgram(program);

   _mesa_GetProgramiv(program, GL_LINK_STATUS, &ok);
   if (ok)
      return program;

   _mesa_GetProgramiv(program, GL_INFO_LOG_LENGTH, &size);
   if (size == 0)
      return 0;

   info = malloc(size);
   if (!info)
      return 0;

   _mesa_GetProgramInfoLog(program, size, NULL, info);
   _mesa_problem(ctx, "meta program link failed:\n%s", info);

   free(info);

   return 0;
}
d311 4
a314 10
   GET_CURRENT_CONTEXT(old_context);
   _mesa_make_current(ctx, NULL, NULL);
   meta_glsl_blit_cleanup(ctx, &ctx->Meta->Blit);
   meta_glsl_clear_cleanup(ctx, &ctx->Meta->Clear);
   meta_glsl_generate_mipmap_cleanup(ctx, &ctx->Meta->Mipmap);
   cleanup_temp_texture(ctx, &ctx->Meta->TempTex);
   if (old_context)
      _mesa_make_current(old_context, old_context->WinSysDrawBuffer, old_context->WinSysReadBuffer);
   else
      _mesa_make_current(NULL, NULL, NULL);
d324 1
a324 1
 * \param state  bitmask of MESA_META_* flags indicating which attribute groups
d327 1
a327 1
void
d339 1
a339 18
   /* Pausing transform feedback needs to be done early, or else we won't be
    * able to change other state.
    */
   save->TransformFeedbackNeedsResume =
      _mesa_is_xfb_active_and_unpaused(ctx);
   if (save->TransformFeedbackNeedsResume)
      _mesa_PauseTransformFeedback();

   /* After saving the current occlusion object, call EndQuery so that no
    * occlusion querying will be active during the meta-operation.
    */
   if (state & MESA_META_OCCLUSION_QUERY) {
      save->CurrentOcclusionObject = ctx->Query.CurrentOcclusionObject;
      if (save->CurrentOcclusionObject)
         _mesa_EndQuery(save->CurrentOcclusionObject->Target);
   }

   if (state & MESA_META_ALPHA_TEST) {
d347 1
a347 1
   if (state & MESA_META_BLEND) {
d365 1
a365 1
   if (state & MESA_META_COLOR_MASK) {
d375 1
a375 1
   if (state & MESA_META_DEPTH_TEST) {
d381 1
a381 3
   if ((state & MESA_META_FOG)
       && ctx->API != API_OPENGL_CORE
       && ctx->API != API_OPENGLES2) {
d387 1
a387 1
   if (state & MESA_META_PIXEL_STORE) {
d394 1
a394 1
   if (state & MESA_META_PIXEL_TRANSFER) {
d417 1
a417 1
   if (state & MESA_META_RASTERIZATION) {
d426 2
a427 4
      if (ctx->API == API_OPENGL_COMPAT) {
         _mesa_set_enable(ctx, GL_POLYGON_SMOOTH, GL_FALSE);
         _mesa_set_enable(ctx, GL_POLYGON_STIPPLE, GL_FALSE);
      }
d431 1
a431 1
   if (state & MESA_META_SCISSOR) {
d436 2
a437 2
   if (state & MESA_META_SHADER) {
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_vertex_program) {
d444 1
a444 1
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_fragment_program) {
d451 11
a461 3
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ATI_fragment_shader) {
         save->ATIFragmentShaderEnabled = ctx->ATIFragmentShader.Enabled;
         _mesa_set_enable(ctx, GL_FRAGMENT_SHADER_ATI, GL_FALSE);
a462 11

      _mesa_reference_shader_program(ctx, &save->VertexShader,
                                     ctx->Shader.CurrentVertexProgram);
      _mesa_reference_shader_program(ctx, &save->GeometryShader,
                                     ctx->Shader.CurrentGeometryProgram);
      _mesa_reference_shader_program(ctx, &save->FragmentShader,
                                     ctx->Shader.CurrentFragmentProgram);
      _mesa_reference_shader_program(ctx, &save->ActiveShader,
                                     ctx->Shader.ActiveProgram);

      _mesa_UseProgram(0);
d465 1
a465 1
   if (state & MESA_META_STENCIL_TEST) {
d472 1
a472 1
   if (state & MESA_META_TEXTURE) {
d480 16
a495 27
      if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES) {
         for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
            save->TexEnabled[u] = ctx->Texture.Unit[u].Enabled;
            save->TexGenEnabled[u] = ctx->Texture.Unit[u].TexGenEnabled;
            if (ctx->Texture.Unit[u].Enabled ||
                ctx->Texture.Unit[u].TexGenEnabled) {
               _mesa_ActiveTexture(GL_TEXTURE0 + u);
               _mesa_set_enable(ctx, GL_TEXTURE_2D, GL_FALSE);
               if (ctx->Extensions.ARB_texture_cube_map)
                  _mesa_set_enable(ctx, GL_TEXTURE_CUBE_MAP, GL_FALSE);
               if (_mesa_is_gles(ctx) &&
                   ctx->Extensions.OES_EGL_image_external)
                  _mesa_set_enable(ctx, GL_TEXTURE_EXTERNAL_OES, GL_FALSE);

               if (ctx->API == API_OPENGL_COMPAT) {
                  _mesa_set_enable(ctx, GL_TEXTURE_1D, GL_FALSE);
                  _mesa_set_enable(ctx, GL_TEXTURE_3D, GL_FALSE);
                  if (ctx->Extensions.NV_texture_rectangle)
                     _mesa_set_enable(ctx, GL_TEXTURE_RECTANGLE, GL_FALSE);
                  _mesa_set_enable(ctx, GL_TEXTURE_GEN_S, GL_FALSE);
                  _mesa_set_enable(ctx, GL_TEXTURE_GEN_T, GL_FALSE);
                  _mesa_set_enable(ctx, GL_TEXTURE_GEN_R, GL_FALSE);
                  _mesa_set_enable(ctx, GL_TEXTURE_GEN_Q, GL_FALSE);
               } else {
                  _mesa_set_enable(ctx, GL_TEXTURE_GEN_STR_OES, GL_FALSE);
               }
            }
d506 3
a508 5
      _mesa_ActiveTexture(GL_TEXTURE0);
      _mesa_ClientActiveTexture(GL_TEXTURE0);
      if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES) {
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
      }
d511 1
a511 1
   if (state & MESA_META_TRANSFORM) {
d521 1
a521 1
      _mesa_ActiveTexture(GL_TEXTURE0);
d524 1
a524 1
      _mesa_ActiveTexture(GL_TEXTURE0 + activeTexture);
d529 3
a531 11

      /* glOrtho with width = 0 or height = 0 generates GL_INVALID_VALUE.
       * This can occur when there is no draw buffer.
       */
      if (ctx->DrawBuffer->Width != 0 && ctx->DrawBuffer->Height != 0)
         _mesa_Ortho(0.0, ctx->DrawBuffer->Width,
                     0.0, ctx->DrawBuffer->Height,
                     -1.0, 1.0);
   }

   if (state & MESA_META_CLIP) {
d541 1
a541 1
   if (state & MESA_META_VERTEX) {
d550 1
a550 1
   if (state & MESA_META_VIEWPORT) {
a570 53
   if (state & MESA_META_CLAMP_FRAGMENT_COLOR) {
      save->ClampFragmentColor = ctx->Color.ClampFragmentColor;

      /* Generally in here we want to do clamping according to whether
       * it's for the pixel path (ClampFragmentColor is GL_TRUE),
       * regardless of the internal implementation of the metaops.
       */
      if (ctx->Color.ClampFragmentColor != GL_TRUE &&
          ctx->Extensions.ARB_color_buffer_float)
	 _mesa_ClampColor(GL_CLAMP_FRAGMENT_COLOR, GL_FALSE);
   }

   if (state & MESA_META_CLAMP_VERTEX_COLOR) {
      save->ClampVertexColor = ctx->Light.ClampVertexColor;

      /* Generally in here we never want vertex color clamping --
       * result clamping is only dependent on fragment clamping.
       */
      if (ctx->Extensions.ARB_color_buffer_float)
         _mesa_ClampColor(GL_CLAMP_VERTEX_COLOR, GL_FALSE);
   }

   if (state & MESA_META_CONDITIONAL_RENDER) {
      save->CondRenderQuery = ctx->Query.CondRenderQuery;
      save->CondRenderMode = ctx->Query.CondRenderMode;

      if (ctx->Query.CondRenderQuery)
	 _mesa_EndConditionalRender();
   }

   if (state & MESA_META_SELECT_FEEDBACK) {
      save->RenderMode = ctx->RenderMode;
      if (ctx->RenderMode == GL_SELECT) {
	 save->Select = ctx->Select; /* struct copy */
	 _mesa_RenderMode(GL_RENDER);
      } else if (ctx->RenderMode == GL_FEEDBACK) {
	 save->Feedback = ctx->Feedback; /* struct copy */
	 _mesa_RenderMode(GL_RENDER);
      }
   }

   if (state & MESA_META_MULTISAMPLE) {
      save->MultisampleEnabled = ctx->Multisample.Enabled;
      if (ctx->Multisample.Enabled)
         _mesa_set_multisample(ctx, GL_FALSE);
   }

   if (state & MESA_META_FRAMEBUFFER_SRGB) {
      save->sRGBEnabled = ctx->Color.sRGBEnabled;
      if (ctx->Color.sRGBEnabled)
         _mesa_set_framebuffer_srgb(ctx, GL_FALSE);
   }

a575 3
      save->RasterDiscard = ctx->RasterDiscard;
      if (ctx->RasterDiscard)
         _mesa_set_enable(ctx, GL_RASTERIZER_DISCARD, GL_FALSE);
d583 1
a583 1
void
d586 1
a586 1
   struct save_state *save = &ctx->Meta->Save[ctx->Meta->SaveStackDepth - 1];
d589 1
a589 13
   /* After starting a new occlusion query, initialize the results to the
    * values saved previously. The driver will then continue to increment
    * these values.
    */
   if (state & MESA_META_OCCLUSION_QUERY) {
      if (save->CurrentOcclusionObject) {
         _mesa_BeginQuery(save->CurrentOcclusionObject->Target,
                          save->CurrentOcclusionObject->Id);
         ctx->Query.CurrentOcclusionObject->Result = save->CurrentOcclusionObject->Result;
      }
   }

   if (state & MESA_META_ALPHA_TEST) {
d595 1
a595 1
   if (state & MESA_META_BLEND) {
d611 1
a611 1
   if (state & MESA_META_COLOR_MASK) {
d620 1
a620 1
               _mesa_ColorMaski(i,
d630 1
a630 1
   if (state & MESA_META_DEPTH_TEST) {
d637 1
a637 3
   if ((state & MESA_META_FOG)
       && ctx->API != API_OPENGL_CORE
       && ctx->API != API_OPENGLES2) {
d641 1
a641 1
   if (state & MESA_META_PIXEL_STORE) {
d646 1
a646 1
   if (state & MESA_META_PIXEL_TRANSFER) {
d660 4
a663 13
   if (state & MESA_META_RASTERIZATION) {
      /* Core context requires that front and back mode be the same.
       */
      if (ctx->API == API_OPENGL_CORE) {
         _mesa_PolygonMode(GL_FRONT_AND_BACK, save->FrontPolygonMode);
      } else {
         _mesa_PolygonMode(GL_FRONT, save->FrontPolygonMode);
         _mesa_PolygonMode(GL_BACK, save->BackPolygonMode);
      }
      if (ctx->API == API_OPENGL_COMPAT) {
         _mesa_set_enable(ctx, GL_POLYGON_STIPPLE, save->PolygonStipple);
         _mesa_set_enable(ctx, GL_POLYGON_SMOOTH, save->PolygonSmooth);
      }
d665 1
d669 1
a669 1
   if (state & MESA_META_SCISSOR) {
d675 2
a676 2
   if (state & MESA_META_SHADER) {
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_vertex_program) {
d684 1
a684 1
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ARB_fragment_program) {
a691 5
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.ATI_fragment_shader) {
         _mesa_set_enable(ctx, GL_FRAGMENT_SHADER_ATI,
                          save->ATIFragmentShaderEnabled);
      }

a704 5

      _mesa_reference_shader_program(ctx, &save->VertexShader, NULL);
      _mesa_reference_shader_program(ctx, &save->GeometryShader, NULL);
      _mesa_reference_shader_program(ctx, &save->FragmentShader, NULL);
      _mesa_reference_shader_program(ctx, &save->ActiveShader, NULL);
d707 1
a707 1
   if (state & MESA_META_STENCIL_TEST) {
d712 1
a712 1
      if (ctx->API == API_OPENGL_COMPAT && ctx->Extensions.EXT_stencil_two_side) {
d738 1
a738 1
   if (state & MESA_META_TEXTURE) {
d744 1
a744 3
      if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES) {
         _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, save->EnvMode);
      }
d748 2
a749 5
	 if (ctx->Texture.Unit[0].CurrentTex[tgt] != save->CurrentTexture[tgt]) {
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    _mesa_reference_texobj(&ctx->Texture.Unit[0].CurrentTex[tgt],
				   save->CurrentTexture[tgt]);
	 }
d753 28
a780 12
      /* Restore fixed function texture enables, texgen */
      if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES) {
         for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
            if (ctx->Texture.Unit[u].Enabled != save->TexEnabled[u]) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               ctx->Texture.Unit[u].Enabled = save->TexEnabled[u];
            }

            if (ctx->Texture.Unit[u].TexGenEnabled != save->TexGenEnabled[u]) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               ctx->Texture.Unit[u].TexGenEnabled = save->TexGenEnabled[u];
            }
d785 2
a786 2
      _mesa_ActiveTexture(GL_TEXTURE0 + save->ActiveUnit);
      _mesa_ClientActiveTexture(GL_TEXTURE0 + save->ClientActiveUnit);
d789 1
a789 1
   if (state & MESA_META_TRANSFORM) {
d791 1
a791 1
      _mesa_ActiveTexture(GL_TEXTURE0);
d794 1
a794 1
      _mesa_ActiveTexture(GL_TEXTURE0 + activeTexture);
a802 1
   }
a803 1
   if (state & MESA_META_CLIP) {
d814 1
a814 1
   if (state & MESA_META_VERTEX) {
d816 1
a816 1
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, save->ArrayBufferObj->Name);
d824 1
a824 1
   if (state & MESA_META_VIEWPORT) {
a834 36
   if (state & MESA_META_CLAMP_FRAGMENT_COLOR &&
       ctx->Extensions.ARB_color_buffer_float) {
      _mesa_ClampColor(GL_CLAMP_FRAGMENT_COLOR, save->ClampFragmentColor);
   }

   if (state & MESA_META_CLAMP_VERTEX_COLOR &&
       ctx->Extensions.ARB_color_buffer_float) {
      _mesa_ClampColor(GL_CLAMP_VERTEX_COLOR, save->ClampVertexColor);
   }

   if (state & MESA_META_CONDITIONAL_RENDER) {
      if (save->CondRenderQuery)
	 _mesa_BeginConditionalRender(save->CondRenderQuery->Id,
				      save->CondRenderMode);
   }

   if (state & MESA_META_SELECT_FEEDBACK) {
      if (save->RenderMode == GL_SELECT) {
	 _mesa_RenderMode(GL_SELECT);
	 ctx->Select = save->Select;
      } else if (save->RenderMode == GL_FEEDBACK) {
	 _mesa_RenderMode(GL_FEEDBACK);
	 ctx->Feedback = save->Feedback;
      }
   }

   if (state & MESA_META_MULTISAMPLE) {
      if (ctx->Multisample.Enabled != save->MultisampleEnabled)
         _mesa_set_multisample(ctx, save->MultisampleEnabled);
   }

   if (state & MESA_META_FRAMEBUFFER_SRGB) {
      if (ctx->Color.sRGBEnabled != save->sRGBEnabled)
         _mesa_set_framebuffer_srgb(ctx, save->sRGBEnabled);
   }

a838 17
   if (save->RasterDiscard) {
      _mesa_set_enable(ctx, GL_RASTERIZER_DISCARD, GL_TRUE);
   }
   if (save->TransformFeedbackNeedsResume)
      _mesa_ResumeTransformFeedback();

   ctx->Meta->SaveStackDepth--;
}


/**
 * Determine whether Mesa is currently in a meta state.
 */
GLboolean
_mesa_meta_in_progress(struct gl_context *ctx)
{
   return ctx->Meta->SaveStackDepth != 0;
d852 1
a852 1
   GLfloat objZ = 1.0f - 2.0f * normZ;
d865 1
a865 1
   if (_mesa_is_desktop_gl(ctx) && ctx->Extensions.NV_texture_rectangle) {
a881 9
static void
cleanup_temp_texture(struct gl_context *ctx, struct temp_texture *tex)
{
   if (!tex->TexObj)
     return;
   _mesa_DeleteTextures(1, &tex->TexObj);
   tex->TexObj = 0;
}

a916 15
/**
 * Return pointer to depth temp_texture.
 * This does some one-time init if needed.
 */
static struct temp_texture *
get_temp_depth_texture(struct gl_context *ctx)
{
   struct temp_texture *tex = &ctx->Meta->Blit.depthTex;

   if (!tex->TexObj) {
      init_temp_texture(ctx, tex);
   }

   return tex;
}
d981 1
a981 2
setup_copypix_texture(struct gl_context *ctx,
                      struct temp_texture *tex,
d990 1
a990 2
   if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES)
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
d1033 1
a1033 2
   if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES)
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
d1048 1
a1048 1
	 _mesa_BindBuffer(GL_PIXEL_UNPACK_BUFFER_ARB, 0);
d1053 1
a1053 1
	    _mesa_BindBuffer(GL_PIXEL_UNPACK_BUFFER_ARB,
d1094 2
a1095 2
   _mesa_GenProgramsARB(1, &blit->DepthFP);
   _mesa_BindProgramARB(GL_FRAGMENT_PROGRAM_ARB, blit->DepthFP);
a1099 158
static void
setup_ff_blit_framebuffer(struct gl_context *ctx,
                          struct blit_state *blit)
{
   struct vertex {
      GLfloat x, y, s, t;
   };
   struct vertex verts[4];

   if (blit->ArrayObj == 0) {
      /* one-time setup */

      /* create vertex array object */
      _mesa_GenVertexArrays(1, &blit->ArrayObj);
      _mesa_BindVertexArray(blit->ArrayObj);

      /* create vertex array buffer */
      _mesa_GenBuffers(1, &blit->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, blit->VBO);
      _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
                          NULL, GL_DYNAMIC_DRAW_ARB);

      /* setup vertex arrays */
      _mesa_VertexPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(x));
      _mesa_TexCoordPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(s));
      _mesa_EnableClientState(GL_VERTEX_ARRAY);
      _mesa_EnableClientState(GL_TEXTURE_COORD_ARRAY);
   }

   /* setup projection matrix */
   _mesa_MatrixMode(GL_PROJECTION);
   _mesa_LoadIdentity();
   _mesa_Ortho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);

}

static void
setup_glsl_blit_framebuffer(struct gl_context *ctx,
                            struct blit_state *blit,
                            GLenum target)
{
   struct vertex {
      GLfloat x, y, s, t;
   };
   struct vertex verts[4];
   const char *vs_source;
   char *fs_source;
   GLuint vs, fs;
   void *mem_ctx;
   GLuint ShaderProg;
   GLboolean texture_2d = (target == GL_TEXTURE_2D);

   /* target = GL_TEXTURE_RECTANGLE is not supported in GLES 3.0 */
   assert(_mesa_is_desktop_gl(ctx) || texture_2d);

   /* Check if already initialized */
   if (blit->ArrayObj == 0) {

      /* create vertex array object */
      _mesa_GenVertexArrays(1, &blit->ArrayObj);
      _mesa_BindVertexArray(blit->ArrayObj);

      /* create vertex array buffer */
      _mesa_GenBuffers(1, &blit->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, blit->VBO);
      _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
                          NULL, GL_DYNAMIC_DRAW_ARB);

      /* setup vertex arrays */
      _mesa_VertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE,
                                   sizeof(struct vertex), OFFSET(x));
      _mesa_VertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE,
                                   sizeof(struct vertex), OFFSET(s));
   }

   /* Generate a relevant fragment shader program for the texture target */
   if ((target == GL_TEXTURE_2D && blit->ShaderProg != 0) ||
       (target == GL_TEXTURE_RECTANGLE && blit->RectShaderProg != 0)) {
      return;
   }

   mem_ctx = ralloc_context(NULL);

   if (ctx->Const.GLSLVersion < 130) {
      vs_source =
         "attribute vec2 position;\n"
         "attribute vec2 textureCoords;\n"
         "varying vec2 texCoords;\n"
         "void main()\n"
         "{\n"
         "   texCoords = textureCoords;\n"
         "   gl_Position = vec4(position, 0.0, 1.0);\n"
         "}\n";

      fs_source = ralloc_asprintf(mem_ctx,
                                  "#ifdef GL_ES\n"
                                  "precision highp float;\n"
                                  "#endif\n"
                                  "uniform %s texSampler;\n"
                                  "varying vec2 texCoords;\n"
                                  "void main()\n"
                                  "{\n"
                                  "   gl_FragColor = %s(texSampler, texCoords);\n"
                                  "   gl_FragDepth = gl_FragColor.r;\n"
                                  "}\n",
                                  texture_2d ? "sampler2D" : "sampler2DRect",
                                  texture_2d ? "texture2D" : "texture2DRect");
   }
   else {
      vs_source = ralloc_asprintf(mem_ctx,
                                  "#version %s\n"
                                  "in vec2 position;\n"
                                  "in vec2 textureCoords;\n"
                                  "out vec2 texCoords;\n"
                                  "void main()\n"
                                  "{\n"
                                  "   texCoords = textureCoords;\n"
                                  "   gl_Position = vec4(position, 0.0, 1.0);\n"
                                  "}\n",
                                  _mesa_is_desktop_gl(ctx) ? "130" : "300 es");
      fs_source = ralloc_asprintf(mem_ctx,
                                  "#version %s\n"
                                  "#ifdef GL_ES\n"
                                  "precision highp float;\n"
                                  "#endif\n"
                                  "uniform %s texSampler;\n"
                                  "in vec2 texCoords;\n"
                                  "out vec4 out_color;\n"
                                  "\n"
                                  "void main()\n"
                                  "{\n"
                                  "   out_color = %s(texSampler, texCoords);\n"
                                  "   gl_FragDepth = out_color.r;\n"
                                  "}\n",
                                  _mesa_is_desktop_gl(ctx) ? "130" : "300 es",
                                  texture_2d ? "sampler2D" : "sampler2DRect",
                                  texture_2d ? "texture" : "texture2DRect");
   }

   vs = compile_shader_with_debug(ctx, GL_VERTEX_SHADER, vs_source);
   fs = compile_shader_with_debug(ctx, GL_FRAGMENT_SHADER, fs_source);

   ShaderProg = _mesa_CreateProgramObjectARB();
   _mesa_AttachShader(ShaderProg, fs);
   _mesa_DeleteObjectARB(fs);
   _mesa_AttachShader(ShaderProg, vs);
   _mesa_DeleteObjectARB(vs);
   _mesa_BindAttribLocation(ShaderProg, 0, "position");
   _mesa_BindAttribLocation(ShaderProg, 1, "texcoords");
   _mesa_EnableVertexAttribArray(0);
   _mesa_EnableVertexAttribArray(1);
   link_program_with_debug(ctx, ShaderProg);
   ralloc_free(mem_ctx);
   if (texture_2d)
      blit->ShaderProg = ShaderProg;
   else
      blit->RectShaderProg = ShaderProg;
}
d1113 1
a1113 2
                        GLbitfield mask, GLenum filter, GLint flipX,
                        GLint flipY, GLboolean glsl_version)
d1118 2
a1119 1
      const struct gl_renderbuffer_attachment *drawAtt;
a1123 5
         struct blit_state *blit = &ctx->Meta->Blit;
         const GLint dstX = MIN2(dstX0, dstX1);
         const GLint dstY = MIN2(dstY0, dstY1);
         const GLint dstW = abs(dstX1 - dstX0);
         const GLint dstH = abs(dstY1 - dstY0);
d1126 2
d1130 2
d1133 7
a1139 19
         GLuint sampler, samplerSave =
            ctx->Texture.Unit[ctx->Texture.CurrentUnit].Sampler ?
            ctx->Texture.Unit[ctx->Texture.CurrentUnit].Sampler->Name : 0;
         int i;

         /* Iterate through all draw buffers */
         for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++) {
            int idx = ctx->DrawBuffer->_ColorDrawBufferIndexes[i];
            if (idx == -1)
               continue;
            drawAtt = &drawFb->Attachment[idx];

            if (drawAtt->Texture == readAtt->Texture) {
               /* Can't use same texture as both the source and dest.  We need
                * to handle overlapping blits and besides, some hw may not
                * support this.
                */
               return mask;
            }
a1146 20
         /* Choose between glsl version and fixed function version of
          * BlitFramebuffer function.
          */
         if (glsl_version) {
            setup_glsl_blit_framebuffer(ctx, blit, target);
            if (target == GL_TEXTURE_2D)
               _mesa_UseProgram(blit->ShaderProg);
            else
               _mesa_UseProgram(blit->RectShaderProg);
         }
         else {
            setup_ff_blit_framebuffer(ctx, &ctx->Meta->Blit);
         }

         _mesa_BindVertexArray(blit->ArrayObj);
         _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, blit->VBO);

         _mesa_GenSamplers(1, &sampler);
         _mesa_BindSampler(ctx->Texture.CurrentUnit, sampler);

d1155 2
a1156 2
         _mesa_SamplerParameteri(sampler, GL_TEXTURE_MIN_FILTER, filter);
         _mesa_SamplerParameteri(sampler, GL_TEXTURE_MAG_FILTER, filter);
d1161 4
a1164 16
         _mesa_SamplerParameteri(sampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
         _mesa_SamplerParameteri(sampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	 /* Always do our blits with no sRGB decode or encode.  Note that
          * GL_FRAMEBUFFER_SRGB has already been disabled by
          * _mesa_meta_begin().
          */
	 if (ctx->Extensions.EXT_texture_sRGB_decode) {
	    _mesa_SamplerParameteri(sampler, GL_TEXTURE_SRGB_DECODE_EXT,
				GL_SKIP_DECODE_EXT);
	 }

         if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES) {
            _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
            _mesa_set_enable(ctx, target, GL_TRUE);
	 }
d1190 8
a1197 9
            /* setup vertex positions */
            verts[0].x = -1.0F * flipX;
            verts[0].y = -1.0F * flipY;
            verts[1].x =  1.0F * flipX;
            verts[1].y = -1.0F * flipY;
            verts[2].x =  1.0F * flipX;
            verts[2].y =  1.0F * flipY;
            verts[3].x = -1.0F * flipX;
            verts[3].y =  1.0F * flipY;
d1208 1
a1208 1
            _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
a1210 4
         /* setup viewport */
         _mesa_set_viewport(ctx, dstX, dstY, dstW, dstH);
         _mesa_ColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
         _mesa_DepthMask(GL_FALSE);
d1216 2
d1222 2
a1223 3

         _mesa_BindSampler(ctx->Texture.CurrentUnit, samplerSave);
         _mesa_DeleteSamplers(1, &sampler);
a1245 1
   struct temp_texture *depthTex = get_temp_depth_texture(ctx);
d1251 2
a1252 11
   const GLint dstX = MIN2(dstX0, dstX1);
   const GLint dstY = MIN2(dstY0, dstY1);
   const GLint dstW = abs(dstX1 - dstX0);
   const GLint dstH = abs(dstY1 - dstY0);
   const GLint srcFlipX = (srcX1 - srcX0) / srcW;
   const GLint srcFlipY = (srcY1 - srcY0) / srcH;
   const GLint dstFlipX = (dstX1 - dstX0) / dstW;
   const GLint dstFlipY = (dstY1 - dstY0) / dstH;
   const GLint flipX = srcFlipX * dstFlipX;
   const GLint flipY = srcFlipY * dstFlipY;

d1258 2
a1259 10
   const GLboolean use_glsl_version = ctx->Extensions.ARB_vertex_shader &&
                                      ctx->Extensions.ARB_fragment_shader &&
                                      (ctx->API != API_OPENGLES);

   /* In addition to falling back if the blit size is larger than the maximum
    * texture size, fallback if the source is multisampled.  This fallback can
    * be removed once Mesa gets support ARB_texture_multisample.
    */
   if (srcW > maxTexSize || srcH > maxTexSize
       || ctx->ReadBuffer->Visual.samples > 0) {
d1266 12
d1279 25
a1303 1
   _mesa_meta_begin(ctx, ~MESA_META_SCISSOR);
d1307 1
a1307 2
                                  dstX0, dstY0, dstX1, dstY1, mask, filter,
                                  dstFlipX, dstFlipY, use_glsl_version);
d1313 2
a1314 2
   /* Choose between glsl version and fixed function version of
    * BlitFramebuffer function.
a1315 10
   if (use_glsl_version) {
      setup_glsl_blit_framebuffer(ctx, blit, tex->Target);
      if (tex->Target == GL_TEXTURE_2D)
         _mesa_UseProgram(blit->ShaderProg);
      else
         _mesa_UseProgram(blit->RectShaderProg);
   }
   else {
      setup_ff_blit_framebuffer(ctx, blit);
   }
d1317 1
a1317 2
   _mesa_BindVertexArray(blit->ArrayObj);
   _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, blit->VBO);
d1319 19
a1337 13
   /* Continue with "normal" approach which involves copying the src rect
    * into a temporary texture and is "blitted" by drawing a textured quad.
    */
   {
      /* setup vertex positions */
      verts[0].x = -1.0F * flipX;
      verts[0].y = -1.0F * flipY;
      verts[1].x =  1.0F * flipX;
      verts[1].y = -1.0F * flipY;
      verts[2].x =  1.0F * flipX;
      verts[2].y =  1.0F * flipY;
      verts[3].x = -1.0F * flipX;
      verts[3].y =  1.0F * flipY;
d1339 2
d1343 1
a1343 5
   /* glEnable() in gles2 and gles3 doesn't allow GL_TEXTURE_{1D, 2D, etc.}
    * tokens.
    */
   if (_mesa_is_desktop_gl(ctx) || ctx->API == API_OPENGLES)
      _mesa_set_enable(ctx, tex->Target, GL_TRUE);
d1346 2
a1347 32
      const struct gl_framebuffer *readFb = ctx->ReadBuffer;
      const struct gl_renderbuffer *colorReadRb = readFb->_ColorReadBuffer;
      const GLenum rb_base_format =
         _mesa_base_tex_format(ctx, colorReadRb->InternalFormat);

      /* Using  the exact source rectangle to create the texture does incorrect
       * linear filtering along the edges. So, allocate the texture extended along
       * edges by one pixel in x, y directions.
       */
      newTex = alloc_texture(tex, srcW + 2, srcH + 2, rb_base_format);
      setup_copypix_texture(ctx, tex, newTex,
                            srcX - 1, srcY - 1, srcW + 2, srcH + 2,
                            rb_base_format, filter);
      /* texcoords (after texture allocation!) */
      {
         verts[0].s = 1.0F;
         verts[0].t = 1.0F;
         verts[1].s = tex->Sright - 1.0F;
         verts[1].t = 1.0F;
         verts[2].s = tex->Sright - 1.0F;
         verts[2].t = tex->Ttop - 1.0F;
         verts[3].s = 1.0F;
         verts[3].t = tex->Ttop - 1.0F;

         /* upload new vertex data */
         _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
      }

      _mesa_set_viewport(ctx, dstX, dstY, dstW, dstH);
      _mesa_ColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
      _mesa_set_enable(ctx, GL_DEPTH_TEST, GL_FALSE);
      _mesa_DepthMask(GL_FALSE);
d1352 2
a1353 7
   if ((mask & GL_DEPTH_BUFFER_BIT) &&
       _mesa_is_desktop_gl(ctx) &&
       ctx->Extensions.ARB_depth_texture &&
       ctx->Extensions.ARB_fragment_program) {

      GLuint *tmp = malloc(srcW * srcH * sizeof(GLuint));

d1355 2
d1358 2
a1359 6
         newTex = alloc_texture(depthTex, srcW, srcH, GL_DEPTH_COMPONENT);
         _mesa_ReadPixels(srcX, srcY, srcW, srcH, GL_DEPTH_COMPONENT,
                          GL_UNSIGNED_INT, tmp);
         setup_drawpix_texture(ctx, depthTex, newTex, GL_DEPTH_COMPONENT,
                               srcW, srcH, GL_DEPTH_COMPONENT,
                               GL_UNSIGNED_INT, tmp);
d1361 2
a1362 10
         /* texcoords (after texture allocation!) */
         {
            verts[0].s = 0.0F;
            verts[0].t = 0.0F;
            verts[1].s = depthTex->Sright;
            verts[1].t = 0.0F;
            verts[2].s = depthTex->Sright;
            verts[2].t = depthTex->Ttop;
            verts[3].s = 0.0F;
            verts[3].t = depthTex->Ttop;
d1364 2
a1365 3
            /* upload new vertex data */
            _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
         }
d1367 1
a1367 4
         if (!blit->DepthFP)
            init_blit_depth_pixels(ctx);

         _mesa_BindProgramARB(GL_FRAGMENT_PROGRAM_ARB, blit->DepthFP);
a1373 2
         _mesa_set_viewport(ctx, dstX, dstY, dstW, dstH);
         _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
d1385 1
a1385 2
   if (_mesa_is_desktop_gl(ctx) || ctx->API == API_OPENGLES)
      _mesa_set_enable(ctx, tex->Target, GL_FALSE);
a1394 23
static void
meta_glsl_blit_cleanup(struct gl_context *ctx, struct blit_state *blit)
{
   if (blit->ArrayObj) {
      _mesa_DeleteVertexArrays(1, &blit->ArrayObj);
      blit->ArrayObj = 0;
      _mesa_DeleteBuffers(1, &blit->VBO);
      blit->VBO = 0;
   }
   if (blit->DepthFP) {
      _mesa_DeleteProgramsARB(1, &blit->DepthFP);
      blit->DepthFP = 0;
   }

   _mesa_DeleteObjectARB(blit->ShaderProg);
   blit->ShaderProg = 0;
   _mesa_DeleteObjectARB(blit->RectShaderProg);
   blit->RectShaderProg = 0;

   _mesa_DeleteTextures(1, &blit->depthTex.TexObj);
   blit->depthTex.TexObj = 0;
}

d1408 1
a1408 5
   GLbitfield metaSave = (MESA_META_ALL -
			  MESA_META_SCISSOR -
			  MESA_META_PIXEL_STORE -
			  MESA_META_CONDITIONAL_RENDER -
                          MESA_META_FRAMEBUFFER_SRGB);
d1413 1
a1413 1
      metaSave -= MESA_META_COLOR_MASK;
d1426 2
a1427 2
      _mesa_GenBuffers(1, &clear->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, clear->VBO);
d1437 1
a1437 1
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, clear->VBO);
a1442 4

      /* Clears never have the color clamped. */
      if (ctx->Extensions.ARB_color_buffer_float)
         _mesa_ClampColor(GL_CLAMP_FRAGMENT_COLOR, GL_FALSE);
d1445 1
a1445 1
      ASSERT(metaSave & MESA_META_COLOR_MASK);
d1496 4
a1499 4
         verts[i].r = ctx->Color.ClearColor.f[0];
         verts[i].g = ctx->Color.ClearColor.f[1];
         verts[i].b = ctx->Color.ClearColor.f[2];
         verts[i].a = ctx->Color.ClearColor.f[3];
d1503 1
a1503 1
      _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts), verts,
a1512 240
static void
meta_glsl_clear_init(struct gl_context *ctx, struct clear_state *clear)
{
   const char *vs_source =
      "attribute vec4 position;\n"
      "void main()\n"
      "{\n"
      "   gl_Position = position;\n"
      "}\n";
   const char *fs_source =
      "#ifdef GL_ES\n"
      "precision highp float;\n"
      "#endif\n"
      "uniform vec4 color;\n"
      "void main()\n"
      "{\n"
      "   gl_FragColor = color;\n"
      "}\n";
   GLuint vs, fs;
   bool has_integer_textures;

   if (clear->ArrayObj != 0)
      return;

   /* create vertex array object */
   _mesa_GenVertexArrays(1, &clear->ArrayObj);
   _mesa_BindVertexArray(clear->ArrayObj);

   /* create vertex array buffer */
   _mesa_GenBuffers(1, &clear->VBO);
   _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, clear->VBO);

   /* setup vertex arrays */
   _mesa_VertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *)0);
   _mesa_EnableVertexAttribArray(0);

   vs = _mesa_CreateShaderObjectARB(GL_VERTEX_SHADER);
   _mesa_ShaderSource(vs, 1, &vs_source, NULL);
   _mesa_CompileShader(vs);

   fs = _mesa_CreateShaderObjectARB(GL_FRAGMENT_SHADER);
   _mesa_ShaderSource(fs, 1, &fs_source, NULL);
   _mesa_CompileShader(fs);

   clear->ShaderProg = _mesa_CreateProgramObjectARB();
   _mesa_AttachShader(clear->ShaderProg, fs);
   _mesa_DeleteObjectARB(fs);
   _mesa_AttachShader(clear->ShaderProg, vs);
   _mesa_DeleteObjectARB(vs);
   _mesa_BindAttribLocation(clear->ShaderProg, 0, "position");
   _mesa_LinkProgram(clear->ShaderProg);

   clear->ColorLocation = _mesa_GetUniformLocation(clear->ShaderProg,
						      "color");

   has_integer_textures = _mesa_is_gles3(ctx) ||
      (_mesa_is_desktop_gl(ctx) && ctx->Const.GLSLVersion >= 130);

   if (has_integer_textures) {
      void *shader_source_mem_ctx = ralloc_context(NULL);
      const char *vs_int_source =
         ralloc_asprintf(shader_source_mem_ctx,
                         "#version %s\n"
                         "in vec4 position;\n"
                         "void main()\n"
                         "{\n"
                         "   gl_Position = position;\n"
                         "}\n",
                         _mesa_is_desktop_gl(ctx) ? "130" : "300 es");
      const char *fs_int_source =
         ralloc_asprintf(shader_source_mem_ctx,
                         "#version %s\n"
                         "#ifdef GL_ES\n"
                         "precision highp float;\n"
                         "#endif\n"
                         "uniform ivec4 color;\n"
                         "out ivec4 out_color;\n"
                         "\n"
                         "void main()\n"
                         "{\n"
                         "   out_color = color;\n"
                         "}\n",
                         _mesa_is_desktop_gl(ctx) ? "130" : "300 es");

      vs = compile_shader_with_debug(ctx, GL_VERTEX_SHADER, vs_int_source);
      fs = compile_shader_with_debug(ctx, GL_FRAGMENT_SHADER, fs_int_source);
      ralloc_free(shader_source_mem_ctx);

      clear->IntegerShaderProg = _mesa_CreateProgramObjectARB();
      _mesa_AttachShader(clear->IntegerShaderProg, fs);
      _mesa_DeleteObjectARB(fs);
      _mesa_AttachShader(clear->IntegerShaderProg, vs);
      _mesa_DeleteObjectARB(vs);
      _mesa_BindAttribLocation(clear->IntegerShaderProg, 0, "position");

      /* Note that user-defined out attributes get automatically assigned
       * locations starting from 0, so we don't need to explicitly
       * BindFragDataLocation to 0.
       */

      link_program_with_debug(ctx, clear->IntegerShaderProg);

      clear->IntegerColorLocation =
	 _mesa_GetUniformLocation(clear->IntegerShaderProg, "color");
   }
}

static void
meta_glsl_clear_cleanup(struct gl_context *ctx, struct clear_state *clear)
{
   if (clear->ArrayObj == 0)
      return;
   _mesa_DeleteVertexArrays(1, &clear->ArrayObj);
   clear->ArrayObj = 0;
   _mesa_DeleteBuffers(1, &clear->VBO);
   clear->VBO = 0;
   _mesa_DeleteObjectARB(clear->ShaderProg);
   clear->ShaderProg = 0;

   if (clear->IntegerShaderProg) {
      _mesa_DeleteObjectARB(clear->IntegerShaderProg);
      clear->IntegerShaderProg = 0;
   }
}

/**
 * Meta implementation of ctx->Driver.Clear() in terms of polygon rendering.
 */
void
_mesa_meta_glsl_Clear(struct gl_context *ctx, GLbitfield buffers)
{
   struct clear_state *clear = &ctx->Meta->Clear;
   GLbitfield metaSave;
   const GLuint stencilMax = (1 << ctx->DrawBuffer->Visual.stencilBits) - 1;
   struct gl_framebuffer *fb = ctx->DrawBuffer;
   const float x0 = ((float)fb->_Xmin / fb->Width)  * 2.0f - 1.0f;
   const float y0 = ((float)fb->_Ymin / fb->Height) * 2.0f - 1.0f;
   const float x1 = ((float)fb->_Xmax / fb->Width)  * 2.0f - 1.0f;
   const float y1 = ((float)fb->_Ymax / fb->Height) * 2.0f - 1.0f;
   const float z = -invert_z(ctx->Depth.Clear);
   struct vertex {
      GLfloat x, y, z;
   } verts[4];

   metaSave = (MESA_META_ALPHA_TEST |
	       MESA_META_BLEND |
	       MESA_META_DEPTH_TEST |
	       MESA_META_RASTERIZATION |
	       MESA_META_SHADER |
	       MESA_META_STENCIL_TEST |
	       MESA_META_VERTEX |
	       MESA_META_VIEWPORT |
	       MESA_META_CLIP |
	       MESA_META_CLAMP_FRAGMENT_COLOR |
               MESA_META_MULTISAMPLE |
               MESA_META_OCCLUSION_QUERY);

   if (!(buffers & BUFFER_BITS_COLOR)) {
      /* We'll use colormask to disable color writes.  Otherwise,
       * respect color mask
       */
      metaSave |= MESA_META_COLOR_MASK;
   }

   _mesa_meta_begin(ctx, metaSave);

   meta_glsl_clear_init(ctx, clear);

   if (fb->_IntegerColor) {
      _mesa_UseProgram(clear->IntegerShaderProg);
      _mesa_Uniform4iv(clear->IntegerColorLocation, 1,
			  ctx->Color.ClearColor.i);
   } else {
      _mesa_UseProgram(clear->ShaderProg);
      _mesa_Uniform4fv(clear->ColorLocation, 1,
			  ctx->Color.ClearColor.f);
   }

   _mesa_BindVertexArray(clear->ArrayObj);
   _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, clear->VBO);

   /* GL_COLOR_BUFFER_BIT */
   if (buffers & BUFFER_BITS_COLOR) {
      /* leave colormask, glDrawBuffer state as-is */

      /* Clears never have the color clamped. */
      if (ctx->Extensions.ARB_color_buffer_float)
         _mesa_ClampColor(GL_CLAMP_FRAGMENT_COLOR, GL_FALSE);
   }
   else {
      ASSERT(metaSave & MESA_META_COLOR_MASK);
      _mesa_ColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
   }

   /* GL_DEPTH_BUFFER_BIT */
   if (buffers & BUFFER_BIT_DEPTH) {
      _mesa_set_enable(ctx, GL_DEPTH_TEST, GL_TRUE);
      _mesa_DepthFunc(GL_ALWAYS);
      _mesa_DepthMask(GL_TRUE);
   }
   else {
      assert(!ctx->Depth.Test);
   }

   /* GL_STENCIL_BUFFER_BIT */
   if (buffers & BUFFER_BIT_STENCIL) {
      _mesa_set_enable(ctx, GL_STENCIL_TEST, GL_TRUE);
      _mesa_StencilOpSeparate(GL_FRONT_AND_BACK,
                              GL_REPLACE, GL_REPLACE, GL_REPLACE);
      _mesa_StencilFuncSeparate(GL_FRONT_AND_BACK, GL_ALWAYS,
                                ctx->Stencil.Clear & stencilMax,
                                ctx->Stencil.WriteMask[0]);
   }
   else {
      assert(!ctx->Stencil.Enabled);
   }

   /* vertex positions */
   verts[0].x = x0;
   verts[0].y = y0;
   verts[0].z = z;
   verts[1].x = x1;
   verts[1].y = y0;
   verts[1].z = z;
   verts[2].x = x1;
   verts[2].y = y1;
   verts[2].z = z;
   verts[3].x = x0;
   verts[3].y = y1;
   verts[3].z = z;

   /* upload new vertex data */
   _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts), verts,
		       GL_DYNAMIC_DRAW_ARB);

   /* draw quad */
   _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);

   _mesa_meta_end(ctx);
}
d1516 1
a1516 1
 * of texture mapping and polygon rendering and GLSL shaders.
d1545 6
a1550 7
   _mesa_meta_begin(ctx, (MESA_META_RASTERIZATION |
                          MESA_META_SHADER |
                          MESA_META_TEXTURE |
                          MESA_META_TRANSFORM |
                          MESA_META_CLIP |
                          MESA_META_VERTEX |
                          MESA_META_VIEWPORT));
d1560 3
a1562 3
      _mesa_GenBuffers(1, &copypix->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, copypix->VBO);
      _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
d1573 1
a1573 1
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, copypix->VBO);
d1608 1
a1608 1
      _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
d1612 1
a1612 1
   setup_copypix_texture(ctx, tex, newTex, srcX, srcY, width, height,
d1722 2
a1723 2
   _mesa_GenProgramsARB(1, &drawpix->StencilFP);
   _mesa_BindProgramARB(GL_FRAGMENT_PROGRAM_ARB, drawpix->StencilFP);
d1756 2
a1757 2
   _mesa_GenProgramsARB(1, &drawpix->DepthFP);
   _mesa_BindProgramARB(GL_FRAGMENT_PROGRAM_ARB, drawpix->DepthFP);
d1791 2
a1792 1
   if (ctx->Fog.Enabled) {
a1804 9

      /* If we're not supposed to clamp the resulting color, then just
       * promote our texture to fully float.  We could do better by
       * just going for the matching set of channels, in floating
       * point.
       */
      if (ctx->Color.ClampFragmentColor != GL_TRUE &&
	  ctx->Extensions.ARB_texture_float)
	 texIntFormat = GL_RGBA32F;
d1816 4
a1819 5
         metaExtraSave = (MESA_META_COLOR_MASK |
                          MESA_META_DEPTH_TEST |
                          MESA_META_PIXEL_TRANSFER |
                          MESA_META_SHADER |
                          MESA_META_STENCIL_TEST);
d1829 1
a1829 1
         metaExtraSave = (MESA_META_SHADER);
d1857 6
a1862 7
   _mesa_meta_begin(ctx, (MESA_META_RASTERIZATION |
                          MESA_META_SHADER |
                          MESA_META_TEXTURE |
                          MESA_META_TRANSFORM |
                          MESA_META_CLIP |
                          MESA_META_VERTEX |
                          MESA_META_VIEWPORT |
d1904 3
a1906 3
   _mesa_GenBuffers(1, &vbo);
   _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, vbo);
   _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
d1942 1
a1942 1
      _mesa_BindProgramARB(GL_FRAGMENT_PROGRAM_ARB, drawpix->StencilFP);
d1963 1
a1963 1
      _mesa_BindProgramARB(GL_FRAGMENT_PROGRAM_ARB, drawpix->DepthFP);
d1984 1
a1984 1
   _mesa_DeleteBuffers(1, &vbo);
d2063 8
a2070 9
   _mesa_meta_begin(ctx, (MESA_META_ALPHA_TEST |
                          MESA_META_PIXEL_STORE |
                          MESA_META_RASTERIZATION |
                          MESA_META_SHADER |
                          MESA_META_TEXTURE |
                          MESA_META_TRANSFORM |
                          MESA_META_CLIP |
                          MESA_META_VERTEX |
                          MESA_META_VIEWPORT));
d2080 3
a2082 3
      _mesa_GenBuffers(1, &bitmap->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, bitmap->VBO);
      _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
d2095 1
a2095 1
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, bitmap->VBO);
d2138 1
a2138 1
      _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
d2151 1
a2151 1
   bitmap8 = malloc(width * height);
d2195 2
a2196 6
   if (target == GL_TEXTURE_3D ||
       target == GL_TEXTURE_1D_ARRAY ||
       target == GL_TEXTURE_2D_ARRAY) {
      _mesa_perf_debug(ctx, MESA_DEBUG_SEVERITY_HIGH,
                       "glGenerateMipmap() to %s target\n",
                       _mesa_lookup_enum_by_nr(target));
d2202 1
a2202 22
   if (!baseImage) {
      _mesa_perf_debug(ctx, MESA_DEBUG_SEVERITY_HIGH,
                       "glGenerateMipmap() couldn't find base teximage\n");
      return GL_TRUE;
   }

   if (_mesa_is_format_compressed(baseImage->TexFormat)) {
      _mesa_perf_debug(ctx, MESA_DEBUG_SEVERITY_HIGH,
                       "glGenerateMipmap() with %s format\n",
                       _mesa_get_format_name(baseImage->TexFormat));
      return GL_TRUE;
   }

   if (_mesa_get_format_color_encoding(baseImage->TexFormat) == GL_SRGB &&
       !ctx->Extensions.EXT_texture_sRGB_decode) {
      /* The texture format is sRGB but we can't turn off sRGB->linear
       * texture sample conversion.  So we won't be able to generate the
       * right colors when rendering.  Need to use a fallback.
       */
      _mesa_perf_debug(ctx, MESA_DEBUG_SEVERITY_HIGH,
                       "glGenerateMipmap() of sRGB texture without "
                       "sRGB decode\n");
d2210 2
a2211 2
      _mesa_GenFramebuffers(1, &mipmap->FBO);
   _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, mipmap->FBO);
d2214 1
a2214 1
      _mesa_FramebufferTexture1D(GL_FRAMEBUFFER_EXT,
d2222 1
a2222 1
      _mesa_FramebufferTexture3D(GL_FRAMEBUFFER_EXT,
d2229 1
a2229 1
      _mesa_FramebufferTexture2D(GL_FRAMEBUFFER_EXT,
d2234 1
a2234 1
   status = _mesa_CheckFramebufferStatus(GL_FRAMEBUFFER_EXT);
d2236 1
a2236 1
   _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, fboSave);
a2238 2
      _mesa_perf_debug(ctx, MESA_DEBUG_SEVERITY_HIGH,
                       "glGenerateMipmap() got incomplete FBO\n");
a2246 376
 * Compute the texture coordinates for the four vertices of a quad for
 * drawing a 2D texture image or slice of a cube/3D texture.
 * \param faceTarget  GL_TEXTURE_1D/2D/3D or cube face name
 * \param slice  slice of a 1D/2D array texture or 3D texture
 * \param width  width of the texture image
 * \param height  height of the texture image
 * \param coords0/1/2/3  returns the computed texcoords
 */
static void
setup_texture_coords(GLenum faceTarget,
                     GLint slice,
                     GLint width,
                     GLint height,
                     GLint depth,
                     GLfloat coords0[3],
                     GLfloat coords1[3],
                     GLfloat coords2[3],
                     GLfloat coords3[3])
{
   static const GLfloat st[4][2] = {
      {0.0f, 0.0f}, {1.0f, 0.0f}, {1.0f, 1.0f}, {0.0f, 1.0f}
   };
   GLuint i;
   GLfloat r;

   switch (faceTarget) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_TEXTURE_3D:
   case GL_TEXTURE_2D_ARRAY:
      if (faceTarget == GL_TEXTURE_3D) {
         assert(slice < depth);
         assert(depth >= 1);
         r = (slice + 0.5f) / depth;
      }
      else if (faceTarget == GL_TEXTURE_2D_ARRAY)
         r = slice;
      else
         r = 0.0F;
      coords0[0] = 0.0F; /* s */
      coords0[1] = 0.0F; /* t */
      coords0[2] = r; /* r */
      coords1[0] = 1.0F;
      coords1[1] = 0.0F;
      coords1[2] = r;
      coords2[0] = 1.0F;
      coords2[1] = 1.0F;
      coords2[2] = r;
      coords3[0] = 0.0F;
      coords3[1] = 1.0F;
      coords3[2] = r;
      break;
   case GL_TEXTURE_RECTANGLE_ARB:
      coords0[0] = 0.0F; /* s */
      coords0[1] = 0.0F; /* t */
      coords0[2] = 0.0F; /* r */
      coords1[0] = width;
      coords1[1] = 0.0F;
      coords1[2] = 0.0F;
      coords2[0] = width;
      coords2[1] = height;
      coords2[2] = 0.0F;
      coords3[0] = 0.0F;
      coords3[1] = height;
      coords3[2] = 0.0F;
      break;
   case GL_TEXTURE_1D_ARRAY:
      coords0[0] = 0.0F; /* s */
      coords0[1] = slice; /* t */
      coords0[2] = 0.0F; /* r */
      coords1[0] = 1.0f;
      coords1[1] = slice;
      coords1[2] = 0.0F;
      coords2[0] = 1.0F;
      coords2[1] = slice;
      coords2[2] = 0.0F;
      coords3[0] = 0.0F;
      coords3[1] = slice;
      coords3[2] = 0.0F;
      break;

   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
      /* loop over quad verts */
      for (i = 0; i < 4; i++) {
         /* Compute sc = +/-scale and tc = +/-scale.
          * Not +/-1 to avoid cube face selection ambiguity near the edges,
          * though that can still sometimes happen with this scale factor...
          */
         const GLfloat scale = 0.9999f;
         const GLfloat sc = (2.0f * st[i][0] - 1.0f) * scale;
         const GLfloat tc = (2.0f * st[i][1] - 1.0f) * scale;
         GLfloat *coord;

         switch (i) {
         case 0:
            coord = coords0;
            break;
         case 1:
            coord = coords1;
            break;
         case 2:
            coord = coords2;
            break;
         case 3:
            coord = coords3;
            break;
         default:
            assert(0);
         }

         switch (faceTarget) {
         case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
            coord[0] = 1.0f;
            coord[1] = -tc;
            coord[2] = -sc;
            break;
         case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
            coord[0] = -1.0f;
            coord[1] = -tc;
            coord[2] = sc;
            break;
         case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
            coord[0] = sc;
            coord[1] = 1.0f;
            coord[2] = tc;
            break;
         case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
            coord[0] = sc;
            coord[1] = -1.0f;
            coord[2] = -tc;
            break;
         case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
            coord[0] = sc;
            coord[1] = -tc;
            coord[2] = 1.0f;
            break;
         case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
            coord[0] = -sc;
            coord[1] = -tc;
            coord[2] = -1.0f;
            break;
         default:
            assert(0);
         }
      }
      break;
   default:
      assert(0 && "unexpected target in meta setup_texture_coords()");
   }
}


static void
setup_ff_generate_mipmap(struct gl_context *ctx,
                         struct gen_mipmap_state *mipmap)
{
   struct vertex {
      GLfloat x, y, tex[3];
   };

   if (mipmap->ArrayObj == 0) {
      /* one-time setup */
      /* create vertex array object */
      _mesa_GenVertexArraysAPPLE(1, &mipmap->ArrayObj);
      _mesa_BindVertexArrayAPPLE(mipmap->ArrayObj);

      /* create vertex array buffer */
      _mesa_GenBuffers(1, &mipmap->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, mipmap->VBO);
      /* setup vertex arrays */
      _mesa_VertexPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(x));
      _mesa_TexCoordPointer(3, GL_FLOAT, sizeof(struct vertex), OFFSET(tex));
      _mesa_EnableClientState(GL_VERTEX_ARRAY);
      _mesa_EnableClientState(GL_TEXTURE_COORD_ARRAY);
   }

   /* setup projection matrix */
   _mesa_MatrixMode(GL_PROJECTION);
   _mesa_LoadIdentity();
   _mesa_Ortho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);
}


static struct glsl_sampler *
setup_texture_sampler(GLenum target, struct gen_mipmap_state *mipmap)
{
   switch(target) {
   case GL_TEXTURE_1D:
      mipmap->sampler_1d.type = "sampler1D";
      mipmap->sampler_1d.func = "texture1D";
      mipmap->sampler_1d.texcoords = "texCoords.x";
      return &mipmap->sampler_1d;
   case GL_TEXTURE_2D:
      mipmap->sampler_2d.type = "sampler2D";
      mipmap->sampler_2d.func = "texture2D";
      mipmap->sampler_2d.texcoords = "texCoords.xy";
      return &mipmap->sampler_2d;
   case GL_TEXTURE_3D:
      /* Code for mipmap generation with 3D textures is not used yet.
       * It's a sw fallback.
       */
      mipmap->sampler_3d.type = "sampler3D";
      mipmap->sampler_3d.func = "texture3D";
      mipmap->sampler_3d.texcoords = "texCoords";
      return &mipmap->sampler_3d;
   case GL_TEXTURE_CUBE_MAP:
      mipmap->sampler_cubemap.type = "samplerCube";
      mipmap->sampler_cubemap.func = "textureCube";
      mipmap->sampler_cubemap.texcoords = "texCoords";
      return &mipmap->sampler_cubemap;
   case GL_TEXTURE_1D_ARRAY:
      mipmap->sampler_1d_array.type = "sampler1DArray";
      mipmap->sampler_1d_array.func = "texture1DArray";
      mipmap->sampler_1d_array.texcoords = "texCoords.xy";
      return &mipmap->sampler_1d_array;
   case GL_TEXTURE_2D_ARRAY:
      mipmap->sampler_2d_array.type = "sampler2DArray";
      mipmap->sampler_2d_array.func = "texture2DArray";
      mipmap->sampler_2d_array.texcoords = "texCoords";
      return &mipmap->sampler_2d_array;
   default:
      _mesa_problem(NULL, "Unexpected texture target 0x%x in"
                    " setup_texture_sampler()\n", target);
      return NULL;
   }
}


static void
setup_glsl_generate_mipmap(struct gl_context *ctx,
                           struct gen_mipmap_state *mipmap,
                           GLenum target)
{
   struct vertex {
      GLfloat x, y, tex[3];
   };
   struct glsl_sampler *sampler;
   const char *vs_source;
   char *fs_source;
   GLuint vs, fs;
   void *mem_ctx;

   /* Check if already initialized */
   if (mipmap->ArrayObj == 0) {

      /* create vertex array object */
      _mesa_GenVertexArrays(1, &mipmap->ArrayObj);
      _mesa_BindVertexArray(mipmap->ArrayObj);

      /* create vertex array buffer */
      _mesa_GenBuffers(1, &mipmap->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, mipmap->VBO);

      /* setup vertex arrays */
      _mesa_VertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE,
                                   sizeof(struct vertex), OFFSET(x));
      _mesa_VertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE,
                                   sizeof(struct vertex), OFFSET(tex));
      _mesa_EnableVertexAttribArray(0);
      _mesa_EnableVertexAttribArray(1);
   }

   /* Generate a fragment shader program appropriate for the texture target */
   sampler = setup_texture_sampler(target, mipmap);
   assert(sampler != NULL);
   if (sampler->shader_prog != 0) {
      mipmap->ShaderProg = sampler->shader_prog;
      return;
   }

   mem_ctx = ralloc_context(NULL);

   if (ctx->API == API_OPENGLES2 || ctx->Const.GLSLVersion < 130) {
      vs_source =
         "attribute vec2 position;\n"
         "attribute vec3 textureCoords;\n"
         "varying vec3 texCoords;\n"
         "void main()\n"
         "{\n"
         "   texCoords = textureCoords;\n"
         "   gl_Position = vec4(position, 0.0, 1.0);\n"
         "}\n";

      fs_source = ralloc_asprintf(mem_ctx,
                                  "#extension GL_EXT_texture_array : enable\n"
                                  "#ifdef GL_ES\n"
                                  "precision highp float;\n"
                                  "#endif\n"
                                  "uniform %s texSampler;\n"
                                  "varying vec3 texCoords;\n"
                                  "void main()\n"
                                  "{\n"
                                  "   gl_FragColor = %s(texSampler, %s);\n"
                                  "}\n",
                                  sampler->type,
                                  sampler->func, sampler->texcoords);
   }
   else {
      vs_source = ralloc_asprintf(mem_ctx,
                                  "#version %s\n"
                                  "in vec2 position;\n"
                                  "in vec3 textureCoords;\n"
                                  "out vec3 texCoords;\n"
                                  "void main()\n"
                                  "{\n"
                                  "   texCoords = textureCoords;\n"
                                  "   gl_Position = vec4(position, 0.0, 1.0);\n"
                                  "}\n",
                                  _mesa_is_desktop_gl(ctx) ? "130" : "300 es");
      fs_source = ralloc_asprintf(mem_ctx,
                                  "#version %s\n"
                                  "#ifdef GL_ES\n"
                                  "precision highp float;\n"
                                  "#endif\n"
                                  "uniform %s texSampler;\n"
                                  "in vec3 texCoords;\n"
                                  "out vec4 out_color;\n"
                                  "\n"
                                  "void main()\n"
                                  "{\n"
                                  "   out_color = texture(texSampler, %s);\n"
                                  "}\n",
                                  _mesa_is_desktop_gl(ctx) ? "130" : "300 es",
                                  sampler->type,
                                  sampler->texcoords);
   }

   vs = compile_shader_with_debug(ctx, GL_VERTEX_SHADER, vs_source);
   fs = compile_shader_with_debug(ctx, GL_FRAGMENT_SHADER, fs_source);

   mipmap->ShaderProg = _mesa_CreateProgramObjectARB();
   _mesa_AttachShader(mipmap->ShaderProg, fs);
   _mesa_DeleteObjectARB(fs);
   _mesa_AttachShader(mipmap->ShaderProg, vs);
   _mesa_DeleteObjectARB(vs);
   _mesa_BindAttribLocation(mipmap->ShaderProg, 0, "position");
   _mesa_BindAttribLocation(mipmap->ShaderProg, 1, "texcoords");
   link_program_with_debug(ctx, mipmap->ShaderProg);
   sampler->shader_prog = mipmap->ShaderProg;
   ralloc_free(mem_ctx);
}


static void
meta_glsl_generate_mipmap_cleanup(struct gl_context *ctx,
                                 struct gen_mipmap_state *mipmap)
{
   if (mipmap->ArrayObj == 0)
      return;
   _mesa_DeleteVertexArrays(1, &mipmap->ArrayObj);
   mipmap->ArrayObj = 0;
   _mesa_DeleteBuffers(1, &mipmap->VBO);
   mipmap->VBO = 0;

   _mesa_DeleteObjectARB(mipmap->sampler_1d.shader_prog);
   _mesa_DeleteObjectARB(mipmap->sampler_2d.shader_prog);
   _mesa_DeleteObjectARB(mipmap->sampler_3d.shader_prog);
   _mesa_DeleteObjectARB(mipmap->sampler_cubemap.shader_prog);
   _mesa_DeleteObjectARB(mipmap->sampler_1d_array.shader_prog);
   _mesa_DeleteObjectARB(mipmap->sampler_2d_array.shader_prog);

   mipmap->sampler_1d.shader_prog = 0;
   mipmap->sampler_2d.shader_prog = 0;
   mipmap->sampler_3d.shader_prog = 0;
   mipmap->sampler_cubemap.shader_prog = 0;
   mipmap->sampler_1d_array.shader_prog = 0;
   mipmap->sampler_2d_array.shader_prog = 0;
}


/**
d2248 1
a2248 2
 * Note: We don't yet support 3D textures, 1D/2D array textures or texture
 * borders.
d2256 1
a2256 1
      GLfloat x, y, tex[3];
d2261 3
d2266 3
d2270 1
a2270 4
   const GLuint currentTexUnitSave = ctx->Texture.CurrentUnit;
   const GLboolean use_glsl_version = ctx->Extensions.ARB_vertex_shader &&
                                      ctx->Extensions.ARB_fragment_shader &&
				      (ctx->API != API_OPENGLES);
d2273 1
a2273 2
   const GLint slice = 0;
   GLuint samplerSave;
d2289 17
a2305 1
   _mesa_meta_begin(ctx, MESA_META_ALL);
d2307 5
a2311 6
   /* Choose between glsl version and fixed function version of
    * GenerateMipmap function.
    */
   if (use_glsl_version) {
      setup_glsl_generate_mipmap(ctx, mipmap, target);
      _mesa_UseProgram(mipmap->ShaderProg);
d2314 2
a2315 2
      setup_ff_generate_mipmap(ctx, mipmap);
      _mesa_set_enable(ctx, target, GL_TRUE);
d2318 4
a2321 2
   _mesa_BindVertexArray(mipmap->ArrayObj);
   _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, mipmap->VBO);
d2323 6
a2328 2
   samplerSave = ctx->Texture.Unit[ctx->Texture.CurrentUnit].Sampler ?
      ctx->Texture.Unit[ctx->Texture.CurrentUnit].Sampler->Name : 0;
d2330 1
a2330 2
   if (currentTexUnitSave != 0)
      _mesa_BindTexture(target, texObj->Name);
d2332 27
a2358 3
   if (!mipmap->FBO) {
      _mesa_GenFramebuffers(1, &mipmap->FBO);
   }
d2360 45
a2404 19
   if (!mipmap->Sampler) {
      _mesa_GenSamplers(1, &mipmap->Sampler);
      _mesa_BindSampler(ctx->Texture.CurrentUnit, mipmap->Sampler);

      _mesa_SamplerParameteri(mipmap->Sampler,
                              GL_TEXTURE_MIN_FILTER,
                              GL_LINEAR_MIPMAP_LINEAR);
      _mesa_SamplerParameteri(mipmap->Sampler, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
      _mesa_SamplerParameteri(mipmap->Sampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
      _mesa_SamplerParameteri(mipmap->Sampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
      _mesa_SamplerParameteri(mipmap->Sampler, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

      /* We don't want to encode or decode sRGB values; treat them as linear.
       * This is not technically correct for GLES3 but we don't get any API
       * error at the moment.
       */
      if (ctx->Extensions.EXT_texture_sRGB_decode) {
         _mesa_SamplerParameteri(mipmap->Sampler, GL_TEXTURE_SRGB_DECODE_EXT,
               GL_SKIP_DECODE_EXT);
a2405 3

   } else {
      _mesa_BindSampler(ctx->Texture.CurrentUnit, mipmap->Sampler);
d2408 1
a2408 15
   _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, mipmap->FBO);

   if (ctx->API == API_OPENGL_COMPAT || ctx->API == API_OPENGLES)
      _mesa_TexParameteri(target, GL_GENERATE_MIPMAP, GL_FALSE);
   else
      assert(!genMipmapSave);

   /* Setup texture coordinates */
   setup_texture_coords(faceTarget,
                        slice,
                        0, 0, 1, /* width, height never used here */
                        verts[0].tex,
                        verts[1].tex,
                        verts[2].tex,
                        verts[3].tex);
d2411 13
a2423 8
   verts[0].x = -1.0F;
   verts[0].y = -1.0F;
   verts[1].x =  1.0F;
   verts[1].y = -1.0F;
   verts[2].x =  1.0F;
   verts[2].y =  1.0F;
   verts[3].x = -1.0F;
   verts[3].y =  1.0F;
d2425 4
a2428 3
   /* upload vertex data */
   _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
                       verts, GL_DYNAMIC_DRAW_ARB);
d2441 1
a2441 1
      assert(srcImage->Border == 0);
d2443 9
a2451 9
      /* src size */
      srcWidth = srcImage->Width;
      srcHeight = srcImage->Height;
      srcDepth = srcImage->Depth;

      /* new dst size */
      dstWidth = MAX2(1, srcWidth / 2);
      dstHeight = MAX2(1, srcHeight / 2);
      dstDepth = MAX2(1, srcDepth / 2);
d2460 1
a2460 3
      /* Allocate storage for the destination mipmap image(s) */

      /* Set MaxLevel large enough to hold the new level when we allocate it */
d2463 34
a2496 9
      if (!_mesa_prepare_mipmap_level(ctx, texObj, dstLevel,
                                      dstWidth, dstHeight, dstDepth,
                                      srcImage->Border,
                                      srcImage->InternalFormat,
                                      srcImage->TexFormat)) {
         /* All done.  We either ran out of memory or we would go beyond the
          * last valid level of an immutable texture if we continued.
          */
         break;
d2499 2
a2500 1
      /* limit minification to src level */
d2505 1
a2505 1
         _mesa_FramebufferTexture1D(GL_FRAMEBUFFER_EXT,
d2513 1
a2513 1
         _mesa_FramebufferTexture3D(GL_FRAMEBUFFER_EXT,
d2521 1
a2521 1
         _mesa_FramebufferTexture2D(GL_FRAMEBUFFER_EXT,
d2531 1
a2531 1
      status = _mesa_CheckFramebufferStatus(GL_FRAMEBUFFER_EXT);
d2533 1
a2533 2
         _mesa_problem(ctx, "Unexpected incomplete framebuffer in "
                       "_mesa_meta_GenerateMipmap()");
a2547 2
   _mesa_BindSampler(ctx->Texture.CurrentUnit, samplerSave);

d2550 3
d2554 4
a2557 2
   if (genMipmapSave)
      _mesa_TexParameteri(target, GL_GENERATE_MIPMAP, genMipmapSave);
d2559 1
a2559 1
   _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, fboSave);
d2568 1
a2568 1
get_temp_image_type(struct gl_context *ctx, gl_format format)
a2569 4
   GLenum baseFormat;

   baseFormat = _mesa_get_format_base_format(format);

a2572 2
   case GL_RG:
   case GL_RED:
d2577 1
a2577 1
      if (ctx->DrawBuffer->Visual.redBits <= 8) {
d2579 1
a2579 1
      } else if (ctx->DrawBuffer->Visual.redBits <= 16) {
d2581 1
a2581 9
      } else {
         GLenum datatype = _mesa_get_format_datatype(format);
         if (datatype == GL_INT || datatype == GL_UNSIGNED_INT)
            return datatype;
         return GL_FLOAT;
      }
   case GL_DEPTH_COMPONENT: {
      GLenum datatype = _mesa_get_format_datatype(format);
      if (datatype == GL_FLOAT)
d2583 4
a2586 10
      else
         return GL_UNSIGNED_INT;
   }
   case GL_DEPTH_STENCIL: {
      GLenum datatype = _mesa_get_format_datatype(format);
      if (datatype == GL_FLOAT)
         return GL_FLOAT_32_UNSIGNED_INT_24_8_REV;
      else
         return GL_UNSIGNED_INT_24_8;
   }
d2588 1
a2588 2
      _mesa_problem(ctx, "Unexpected format %d in get_temp_image_type()",
		    baseFormat);
d2595 1
a2595 1
 * Helper for _mesa_meta_CopyTexSubImage1/2/3D() functions.
d2598 4
a2601 7
void
_mesa_meta_CopyTexSubImage(struct gl_context *ctx, GLuint dims,
                           struct gl_texture_image *texImage,
                           GLint xoffset, GLint yoffset, GLint zoffset,
                           struct gl_renderbuffer *rb,
                           GLint x, GLint y,
                           GLsizei width, GLsizei height)
d2603 2
a2604 1
   struct gl_texture_object *texObj = texImage->TexObject;
d2609 3
d2613 2
a2614 15
   format = _mesa_get_format_base_format(texImage->TexFormat);
   if (format == GL_LUMINANCE ||
       format == GL_LUMINANCE_ALPHA ||
       format == GL_INTENSITY) {
      /* We don't want to use GL_LUMINANCE, GL_INTENSITY, etc. for the
       * temp image buffer because glReadPixels will do L=R+G+B which is
       * not what we want (should be L=R).
       */
      format = GL_RGBA;
   }

   type = get_temp_image_type(ctx, texImage->TexFormat);
   if (_mesa_is_format_integer_color(texImage->TexFormat)) {
      format = _mesa_base_format_to_integer_format(format);
   }
d2617 1
a2617 1
      _mesa_problem(ctx, "Bad bpp in _mesa_meta_CopyTexSubImage()");
d2626 1
a2626 1
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyTexSubImage%uD", dims);
d2635 1
a2635 1
   _mesa_meta_begin(ctx, MESA_META_PIXEL_STORE | MESA_META_PIXEL_TRANSFER);
d2640 6
a2645 1
   _mesa_update_state(ctx); /* to update pixel transfer state */
d2650 3
a2652 1
   _mesa_meta_begin(ctx, MESA_META_PIXEL_STORE);
d2654 9
a2662 9
   if (texImage->TexObject->Target == GL_TEXTURE_1D_ARRAY) {
      assert(yoffset == 0);
      ctx->Driver.TexSubImage(ctx, dims, texImage,
                              xoffset, zoffset, 0, width, 1, 1,
                              format, type, buf, &ctx->Unpack);
   } else {
      ctx->Driver.TexSubImage(ctx, dims, texImage,
                              xoffset, yoffset, zoffset, width, height, 1,
                              format, type, buf, &ctx->Unpack);
a2663 1

d2672 21
d2694 2
a2695 7
 * Decompress a texture image by drawing a quad with the compressed
 * texture and reading the pixels out of the color buffer.
 * \param slice  which slice of a 3D texture or layer of a 1D/2D texture
 * \param destFormat  format, ala glReadPixels
 * \param destType  type, ala glReadPixels
 * \param dest  destination buffer
 * \param destRowLength  dest image rowLength (ala GL_PACK_ROW_LENGTH)
d2698 11
a2708 20
decompress_texture_image(struct gl_context *ctx,
                         struct gl_texture_image *texImage,
                         GLuint slice,
                         GLenum destFormat, GLenum destType,
                         GLvoid *dest)
{
   struct decompress_state *decompress = &ctx->Meta->Decompress;
   struct gl_texture_object *texObj = texImage->TexObject;
   const GLint width = texImage->Width;
   const GLint height = texImage->Height;
   const GLint depth = texImage->Height;
   const GLenum target = texObj->Target;
   GLenum faceTarget;
   struct vertex {
      GLfloat x, y, tex[3];
   };
   struct vertex verts[4];
   GLuint fboDrawSave, fboReadSave;
   GLuint rbSave;
   GLuint samplerSave;
d2710 2
a2711 4
   if (slice > 0) {
      assert(target == GL_TEXTURE_3D ||
             target == GL_TEXTURE_2D_ARRAY);
   }
d2713 7
a2719 5
   if (target == GL_TEXTURE_CUBE_MAP) {
      faceTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + texImage->Face;
   }
   else {
      faceTarget = target;
d2722 7
a2728 23
   /* save fbo bindings (not saved by _mesa_meta_begin()) */
   fboDrawSave = ctx->DrawBuffer->Name;
   fboReadSave = ctx->ReadBuffer->Name;
   rbSave = ctx->CurrentRenderbuffer ? ctx->CurrentRenderbuffer->Name : 0;

   _mesa_meta_begin(ctx, MESA_META_ALL & ~MESA_META_PIXEL_STORE);

   samplerSave = ctx->Texture.Unit[ctx->Texture.CurrentUnit].Sampler ?
         ctx->Texture.Unit[ctx->Texture.CurrentUnit].Sampler->Name : 0;

   /* Create/bind FBO/renderbuffer */
   if (decompress->FBO == 0) {
      _mesa_GenFramebuffers(1, &decompress->FBO);
      _mesa_GenRenderbuffers(1, &decompress->RBO);
      _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, decompress->FBO);
      _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, decompress->RBO);
      _mesa_FramebufferRenderbuffer(GL_FRAMEBUFFER_EXT,
                                       GL_COLOR_ATTACHMENT0_EXT,
                                       GL_RENDERBUFFER_EXT,
                                       decompress->RBO);
   }
   else {
      _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, decompress->FBO);
d2731 1
a2731 8
   /* alloc dest surface */
   if (width > decompress->Width || height > decompress->Height) {
      _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, decompress->RBO);
      _mesa_RenderbufferStorage(GL_RENDERBUFFER_EXT, GL_RGBA,
                                   width, height);
      decompress->Width = width;
      decompress->Height = height;
   }
d2733 7
a2739 5
   /* setup VBO data */
   if (decompress->ArrayObj == 0) {
      /* create vertex array object */
      _mesa_GenVertexArrays(1, &decompress->ArrayObj);
      _mesa_BindVertexArray(decompress->ArrayObj);
d2741 1
a2741 5
      /* create vertex array buffer */
      _mesa_GenBuffers(1, &decompress->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, decompress->VBO);
      _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
                          NULL, GL_DYNAMIC_DRAW_ARB);
d2743 13
a2755 5
      /* setup vertex arrays */
      _mesa_VertexPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(x));
      _mesa_TexCoordPointer(3, GL_FLOAT, sizeof(struct vertex), OFFSET(tex));
      _mesa_EnableClientState(GL_VERTEX_ARRAY);
      _mesa_EnableClientState(GL_TEXTURE_COORD_ARRAY);
d2758 3
a2760 2
      _mesa_BindVertexArray(decompress->ArrayObj);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, decompress->VBO);
d2762 1
d2764 1
a2764 21
   if (!decompress->Sampler) {
      _mesa_GenSamplers(1, &decompress->Sampler);
      _mesa_BindSampler(ctx->Texture.CurrentUnit, decompress->Sampler);
      /* nearest filtering */
      _mesa_SamplerParameteri(decompress->Sampler, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
      _mesa_SamplerParameteri(decompress->Sampler, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
      /* No sRGB decode or encode.*/
      if (ctx->Extensions.EXT_texture_sRGB_decode) {
         _mesa_SamplerParameteri(decompress->Sampler, GL_TEXTURE_SRGB_DECODE_EXT,
                             GL_SKIP_DECODE_EXT);
      }

   } else {
      _mesa_BindSampler(ctx->Texture.CurrentUnit, decompress->Sampler);
   }

   setup_texture_coords(faceTarget, slice, width, height, depth,
                        verts[0].tex,
                        verts[1].tex,
                        verts[2].tex,
                        verts[3].tex);
d2766 2
a2767 9
   /* setup vertex positions */
   verts[0].x = 0.0F;
   verts[0].y = 0.0F;
   verts[1].x = width;
   verts[1].y = 0.0F;
   verts[2].x = width;
   verts[2].y = height;
   verts[3].x = 0.0F;
   verts[3].y = height;
a2768 2
   /* upload new vertex data */
   _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
d2770 8
a2777 3
   /* setup texture state */
   _mesa_BindTexture(target, texObj->Name);
   _mesa_set_enable(ctx, target, GL_TRUE);
a2778 4
   {
      /* save texture object state */
      const GLint baseLevelSave = texObj->BaseLevel;
      const GLint maxLevelSave = texObj->MaxLevel;
d2780 9
a2788 5
      /* restrict sampling to the texture level of interest */
      if (target != GL_TEXTURE_RECTANGLE_ARB) {
         _mesa_TexParameteri(target, GL_TEXTURE_BASE_LEVEL, texImage->Level);
         _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, texImage->Level);
      }
a2789 10
      /* render quad w/ texture into renderbuffer */
      _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
      
      /* Restore texture object state, the texture binding will
       * be restored by _mesa_meta_end().
       */
      if (target != GL_TEXTURE_RECTANGLE_ARB) {
         _mesa_TexParameteri(target, GL_TEXTURE_BASE_LEVEL, baseLevelSave);
         _mesa_TexParameteri(target, GL_TEXTURE_MAX_LEVEL, maxLevelSave);
      }
d2791 9
a2799 1
   }
a2800 4
   /* read pixels from renderbuffer */
   {
      GLenum baseTexFormat = texImage->_BaseFormat;
      GLenum destBaseFormat = _mesa_base_tex_format(ctx, destFormat);
d2802 6
a2807 24
      /* The pixel transfer state will be set to default values at this point
       * (see MESA_META_PIXEL_TRANSFER) so pixel transfer ops are effectively
       * turned off (as required by glGetTexImage) but we need to handle some
       * special cases.  In particular, single-channel texture values are
       * returned as red and two-channel texture values are returned as
       * red/alpha.
       */
      if ((baseTexFormat == GL_LUMINANCE ||
           baseTexFormat == GL_LUMINANCE_ALPHA ||
           baseTexFormat == GL_INTENSITY) ||
          /* If we're reading back an RGB(A) texture (using glGetTexImage) as
	   * luminance then we need to return L=tex(R).
	   */
          ((baseTexFormat == GL_RGBA ||
            baseTexFormat == GL_RGB  ||
            baseTexFormat == GL_RG) &&
          (destBaseFormat == GL_LUMINANCE ||
           destBaseFormat == GL_LUMINANCE_ALPHA ||
           destBaseFormat == GL_LUMINANCE_INTEGER_EXT ||
           destBaseFormat == GL_LUMINANCE_ALPHA_INTEGER_EXT))) {
         /* Green and blue must be zero */
         _mesa_PixelTransferf(GL_GREEN_SCALE, 0.0f);
         _mesa_PixelTransferf(GL_BLUE_SCALE, 0.0f);
      }
d2809 4
a2812 1
      _mesa_ReadPixels(0, 0, width, height, destFormat, destType, dest);
d2815 6
a2820 2
   /* disable texture unit */
   _mesa_set_enable(ctx, target, GL_FALSE);
d2822 1
a2822 1
   _mesa_BindSampler(ctx->Texture.CurrentUnit, samplerSave);
d2826 1
a2826 59
   /* restore fbo bindings */
   if (fboDrawSave == fboReadSave) {
      _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, fboDrawSave);
   }
   else {
      _mesa_BindFramebuffer(GL_DRAW_FRAMEBUFFER_EXT, fboDrawSave);
      _mesa_BindFramebuffer(GL_READ_FRAMEBUFFER_EXT, fboReadSave);
   }
   _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, rbSave);
}


/**
 * This is just a wrapper around _mesa_get_tex_image() and
 * decompress_texture_image().  Meta functions should not be directly called
 * from core Mesa.
 */
void
_mesa_meta_GetTexImage(struct gl_context *ctx,
                       GLenum format, GLenum type, GLvoid *pixels,
                       struct gl_texture_image *texImage)
{
   /* We can only use the decompress-with-blit method here if the texels are
    * unsigned, normalized values.  We could handle signed and unnormalized 
    * with floating point renderbuffers...
    */
   if (_mesa_is_format_compressed(texImage->TexFormat) &&
       _mesa_get_format_datatype(texImage->TexFormat)
       == GL_UNSIGNED_NORMALIZED) {
      struct gl_texture_object *texObj = texImage->TexObject;
      GLuint slice;
      /* Need to unlock the texture here to prevent deadlock... */
      _mesa_unlock_texture(ctx, texObj);
      for (slice = 0; slice < texImage->Depth; slice++) {
         void *dst;
         if (texImage->TexObject->Target == GL_TEXTURE_2D_ARRAY) {
            /* Setup pixel packing.  SkipPixels and SkipRows will be applied
             * in the decompress_texture_image() function's call to
             * glReadPixels but we need to compute the dest slice's address
             * here (according to SkipImages and ImageHeight).
             */
            struct gl_pixelstore_attrib packing = ctx->Pack;
            packing.SkipPixels = 0;
            packing.SkipRows = 0;
            dst = _mesa_image_address3d(&packing, pixels, texImage->Width,
                                        texImage->Height, format, type,
                                        slice, 0, 0);
         }
         else {
            dst = pixels;
         }
         decompress_texture_image(ctx, texImage, slice, format, type, dst);
      }
      /* ... and relock it */
      _mesa_lock_texture(ctx, texObj);
   }
   else {
      _mesa_get_teximage(ctx, format, type, pixels, texImage);
   }
a2829 4
/**
 * Meta implementation of ctx->Driver.DrawTex() in terms
 * of polygon rendering.
 */
d2831 2
a2832 2
_mesa_meta_DrawTex(struct gl_context *ctx, GLfloat x, GLfloat y, GLfloat z,
                   GLfloat width, GLfloat height)
d2834 1
a2834 6
   struct drawtex_state *drawtex = &ctx->Meta->DrawTex;
   struct vertex {
      GLfloat x, y, z, st[MAX_TEXTURE_UNITS][2];
   };
   struct vertex verts[4];
   GLuint i;
d2836 4
a2839 38
   _mesa_meta_begin(ctx, (MESA_META_RASTERIZATION |
                          MESA_META_SHADER |
                          MESA_META_TRANSFORM |
                          MESA_META_VERTEX |
                          MESA_META_VIEWPORT));

   if (drawtex->ArrayObj == 0) {
      /* one-time setup */
      GLint active_texture;

      /* create vertex array object */
      _mesa_GenVertexArrays(1, &drawtex->ArrayObj);
      _mesa_BindVertexArray(drawtex->ArrayObj);

      /* create vertex array buffer */
      _mesa_GenBuffers(1, &drawtex->VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, drawtex->VBO);
      _mesa_BufferData(GL_ARRAY_BUFFER_ARB, sizeof(verts),
                          NULL, GL_DYNAMIC_DRAW_ARB);

      /* client active texture is not part of the array object */
      active_texture = ctx->Array.ActiveTexture;

      /* setup vertex arrays */
      _mesa_VertexPointer(3, GL_FLOAT, sizeof(struct vertex), OFFSET(x));
      _mesa_EnableClientState(GL_VERTEX_ARRAY);
      for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
         _mesa_ClientActiveTexture(GL_TEXTURE0 + i);
         _mesa_TexCoordPointer(2, GL_FLOAT, sizeof(struct vertex), OFFSET(st[i]));
         _mesa_EnableClientState(GL_TEXTURE_COORD_ARRAY);
      }

      /* restore client active texture */
      _mesa_ClientActiveTexture(GL_TEXTURE0 + active_texture);
   }
   else {
      _mesa_BindVertexArray(drawtex->ArrayObj);
      _mesa_BindBuffer(GL_ARRAY_BUFFER_ARB, drawtex->VBO);
d2842 6
a2847 4
   /* vertex positions, texcoords */
   {
      const GLfloat x1 = x + width;
      const GLfloat y1 = y + height;
d2849 1
a2849 2
      z = CLAMP(z, 0.0f, 1.0f);
      z = invert_z(z);
d2851 1
a2851 3
      verts[0].x = x;
      verts[0].y = y;
      verts[0].z = z;
d2853 1
a2853 56
      verts[1].x = x1;
      verts[1].y = y;
      verts[1].z = z;

      verts[2].x = x1;
      verts[2].y = y1;
      verts[2].z = z;

      verts[3].x = x;
      verts[3].y = y1;
      verts[3].z = z;

      for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
         const struct gl_texture_object *texObj;
         const struct gl_texture_image *texImage;
         GLfloat s, t, s1, t1;
         GLuint tw, th;

         if (!ctx->Texture.Unit[i]._ReallyEnabled) {
            GLuint j;
            for (j = 0; j < 4; j++) {
               verts[j].st[i][0] = 0.0f;
               verts[j].st[i][1] = 0.0f;
            }
            continue;
         }

         texObj = ctx->Texture.Unit[i]._Current;
         texImage = texObj->Image[0][texObj->BaseLevel];
         tw = texImage->Width2;
         th = texImage->Height2;

         s = (GLfloat) texObj->CropRect[0] / tw;
         t = (GLfloat) texObj->CropRect[1] / th;
         s1 = (GLfloat) (texObj->CropRect[0] + texObj->CropRect[2]) / tw;
         t1 = (GLfloat) (texObj->CropRect[1] + texObj->CropRect[3]) / th;

         verts[0].st[i][0] = s;
         verts[0].st[i][1] = t;

         verts[1].st[i][0] = s1;
         verts[1].st[i][1] = t;

         verts[2].st[i][0] = s1;
         verts[2].st[i][1] = t1;

         verts[3].st[i][0] = s;
         verts[3].st[i][1] = t1;
      }

      _mesa_BufferSubData(GL_ARRAY_BUFFER_ARB, 0, sizeof(verts), verts);
   }

   _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);

   _mesa_meta_end(ctx);
@


1.1.1.3
log
@Import Mesa 9.2.1
@
text
@a4024 5
   _mesa_MatrixMode(GL_PROJECTION);
   _mesa_LoadIdentity();
   _mesa_Ortho(0.0, width, 0.0, height, -1.0, 1.0);
   _mesa_set_viewport(ctx, 0, 0, width, height);

@


1.1.1.4
log
@Import Mesa 9.2.3
@
text
@a1517 3

      _mesa_EnableVertexAttribArray(0);
      _mesa_EnableVertexAttribArray(1);
d1594 2
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@a39 1
#include "main/blit.h"
a53 3
#include "main/multisample.h"
#include "main/objectlabel.h"
#include "main/pipelineobj.h"
d85 196
a280 2
static void
meta_clear(struct gl_context *ctx, GLbitfield buffers, bool glsl);
d282 10
a291 2
static struct blit_shader *
choose_blit_shader(GLenum target, struct blit_shader_table *table);
d293 17
a309 4
static void cleanup_temp_texture(struct temp_texture *tex);
static void meta_glsl_clear_cleanup(struct clear_state *clear);
static void meta_decompress_cleanup(struct decompress_state *decompress);
static void meta_drawpix_cleanup(struct drawpix_state *drawpix);
d311 4
a314 3
void
_mesa_meta_bind_fbo_image(GLenum attachment,
                          struct gl_texture_image *texImage, GLuint layer)
d316 4
a319 3
   struct gl_texture_object *texObj = texImage->TexObject;
   int level = texImage->Level;
   GLenum target = texObj->Target;
d321 8
a328 22
   switch (target) {
   case GL_TEXTURE_1D:
      _mesa_FramebufferTexture1D(GL_FRAMEBUFFER,
                                 attachment,
                                 target,
                                 texObj->Name,
                                 level);
      break;
   case GL_TEXTURE_1D_ARRAY:
   case GL_TEXTURE_2D_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
   case GL_TEXTURE_3D:
      _mesa_FramebufferTextureLayer(GL_FRAMEBUFFER,
                                    attachment,
                                    texObj->Name,
                                    level,
                                    layer);
      break;
   default: /* 2D / cube */
      if (target == GL_TEXTURE_CUBE_MAP)
         target = GL_TEXTURE_CUBE_MAP_POSITIVE_X + texImage->Face;
d330 28
a357 7
      _mesa_FramebufferTexture2D(GL_FRAMEBUFFER,
                                 attachment,
                                 target,
                                 texObj->Name,
                                 level);
   }
}
d359 2
a360 3
GLuint
_mesa_meta_compile_shader_with_debug(struct gl_context *ctx, GLenum target,
                                     const GLcharARB *source)
d366 1
a366 1
   shader = _mesa_CreateShader(target);
d376 1
a376 1
      _mesa_DeleteShader(shader);
d382 1
a382 1
      _mesa_DeleteShader(shader);
d386 1
a386 1
   _mesa_GetShaderInfoLog(shader, size, NULL, info);
d393 1
a393 1
   _mesa_DeleteShader(shader);
d398 2
a399 2
GLuint
_mesa_meta_link_program_with_debug(struct gl_context *ctx, GLuint program)
a425 177
void
_mesa_meta_compile_and_link_program(struct gl_context *ctx,
                                    const char *vs_source,
                                    const char *fs_source,
                                    const char *name,
                                    GLuint *program)
{
   GLuint vs = _mesa_meta_compile_shader_with_debug(ctx, GL_VERTEX_SHADER,
                                                    vs_source);
   GLuint fs = _mesa_meta_compile_shader_with_debug(ctx, GL_FRAGMENT_SHADER,
                                                    fs_source);

   *program = _mesa_CreateProgram();
   _mesa_AttachShader(*program, fs);
   _mesa_DeleteShader(fs);
   _mesa_AttachShader(*program, vs);
   _mesa_DeleteShader(vs);
   _mesa_BindAttribLocation(*program, 0, "position");
   _mesa_BindAttribLocation(*program, 1, "texcoords");
   _mesa_meta_link_program_with_debug(ctx, *program);
   _mesa_ObjectLabel(GL_PROGRAM, *program, -1, name);

   _mesa_UseProgram(*program);
}

/**
 * Generate a generic shader to blit from a texture to a framebuffer
 *
 * \param ctx       Current GL context
 * \param texTarget Texture target that will be the source of the blit
 *
 * \returns a handle to a shader program on success or zero on failure.
 */
void
_mesa_meta_setup_blit_shader(struct gl_context *ctx,
                             GLenum target,
                             struct blit_shader_table *table)
{
   char *vs_source, *fs_source;
   void *const mem_ctx = ralloc_context(NULL);
   struct blit_shader *shader = choose_blit_shader(target, table);
   const char *vs_input, *vs_output, *fs_input, *vs_preprocess, *fs_preprocess;

   if (ctx->Const.GLSLVersion < 130) {
      vs_preprocess = "";
      vs_input = "attribute";
      vs_output = "varying";
      fs_preprocess = "#extension GL_EXT_texture_array : enable";
      fs_input = "varying";
   } else {
      vs_preprocess = "#version 130";
      vs_input = "in";
      vs_output = "out";
      fs_preprocess = "#version 130";
      fs_input = "in";
      shader->func = "texture";
   }

   assert(shader != NULL);

   if (shader->shader_prog != 0) {
      _mesa_UseProgram(shader->shader_prog);
      return;
   }

   vs_source = ralloc_asprintf(mem_ctx,
                "%s\n"
                "%s vec2 position;\n"
                "%s vec4 textureCoords;\n"
                "%s vec4 texCoords;\n"
                "void main()\n"
                "{\n"
                "   texCoords = textureCoords;\n"
                "   gl_Position = vec4(position, 0.0, 1.0);\n"
                "}\n",
                vs_preprocess, vs_input, vs_input, vs_output);

   fs_source = ralloc_asprintf(mem_ctx,
                "%s\n"
                "#extension GL_ARB_texture_cube_map_array: enable\n"
                "uniform %s texSampler;\n"
                "%s vec4 texCoords;\n"
                "void main()\n"
                "{\n"
                "   gl_FragColor = %s(texSampler, %s);\n"
                "   gl_FragDepth = gl_FragColor.x;\n"
                "}\n",
                fs_preprocess, shader->type, fs_input,
                shader->func, shader->texcoords);

   _mesa_meta_compile_and_link_program(ctx, vs_source, fs_source,
                                       ralloc_asprintf(mem_ctx, "%s blit",
                                                       shader->type),
                                       &shader->shader_prog);
   ralloc_free(mem_ctx);
}

/**
 * Configure vertex buffer and vertex array objects for tests
 *
 * Regardless of whether a new VAO and new VBO are created, the objects
 * referenced by \c VAO and \c VBO will be bound into the GL state vector
 * when this function terminates.
 *
 * \param VAO       Storage for vertex array object handle.  If 0, a new VAO
 *                  will be created.
 * \param VBO       Storage for vertex buffer object handle.  If 0, a new VBO
 *                  will be created.  The new VBO will have storage for 4
 *                  \c vertex structures.
 * \param use_generic_attributes  Should generic attributes 0 and 1 be used,
 *                  or should traditional, fixed-function color and texture
 *                  coordinate be used?
 * \param vertex_size  Number of components for attribute 0 / vertex.
 * \param texcoord_size  Number of components for attribute 1 / texture
 *                  coordinate.  If this is 0, attribute 1 will not be set or
 *                  enabled.
 * \param color_size  Number of components for attribute 1 / primary color.
 *                  If this is 0, attribute 1 will not be set or enabled.
 *
 * \note If \c use_generic_attributes is \c true, \c color_size must be zero.
 * Use \c texcoord_size instead.
 */
void
_mesa_meta_setup_vertex_objects(GLuint *VAO, GLuint *VBO,
                                bool use_generic_attributes,
                                unsigned vertex_size, unsigned texcoord_size,
                                unsigned color_size)
{
   if (*VAO == 0) {
      assert(*VBO == 0);

      /* create vertex array object */
      _mesa_GenVertexArrays(1, VAO);
      _mesa_BindVertexArray(*VAO);

      /* create vertex array buffer */
      _mesa_GenBuffers(1, VBO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER, *VBO);
      _mesa_BufferData(GL_ARRAY_BUFFER, 4 * sizeof(struct vertex), NULL,
                       GL_DYNAMIC_DRAW);

      /* setup vertex arrays */
      if (use_generic_attributes) {
         assert(color_size == 0);

         _mesa_VertexAttribPointer(0, vertex_size, GL_FLOAT, GL_FALSE,
                                   sizeof(struct vertex), OFFSET(x));
         _mesa_EnableVertexAttribArray(0);

         if (texcoord_size > 0) {
            _mesa_VertexAttribPointer(1, texcoord_size, GL_FLOAT, GL_FALSE,
                                      sizeof(struct vertex), OFFSET(tex));
            _mesa_EnableVertexAttribArray(1);
         }
      } else {
         _mesa_VertexPointer(vertex_size, GL_FLOAT, sizeof(struct vertex),
                             OFFSET(x));
         _mesa_EnableClientState(GL_VERTEX_ARRAY);

         if (texcoord_size > 0) {
            _mesa_TexCoordPointer(texcoord_size, GL_FLOAT,
                                  sizeof(struct vertex), OFFSET(tex));
            _mesa_EnableClientState(GL_TEXTURE_COORD_ARRAY);
         }

         if (color_size > 0) {
            _mesa_ColorPointer(color_size, GL_FLOAT,
                               sizeof(struct vertex), OFFSET(r));
            _mesa_EnableClientState(GL_COLOR_ARRAY);
         }
      }
   } else {
      _mesa_BindVertexArray(*VAO);
      _mesa_BindBuffer(GL_ARRAY_BUFFER, *VBO);
   }
}

a437 18
static GLenum
gl_buffer_index_to_drawbuffers_enum(gl_buffer_index bufindex)
{
   assert(bufindex < BUFFER_COUNT);

   if (bufindex >= BUFFER_COLOR0)
      return GL_COLOR_ATTACHMENT0 + bufindex - BUFFER_COLOR0;
   else if (bufindex == BUFFER_FRONT_LEFT)
      return GL_FRONT_LEFT;
   else if (bufindex == BUFFER_FRONT_RIGHT)
      return GL_FRONT_RIGHT;
   else if (bufindex == BUFFER_BACK_LEFT)
      return GL_BACK_LEFT;
   else if (bufindex == BUFFER_BACK_RIGHT)
      return GL_BACK_RIGHT;

   return GL_NONE;
}
d448 4
a451 6
   _mesa_meta_glsl_blit_cleanup(&ctx->Meta->Blit);
   meta_glsl_clear_cleanup(&ctx->Meta->Clear);
   _mesa_meta_glsl_generate_mipmap_cleanup(&ctx->Meta->Mipmap);
   cleanup_temp_texture(&ctx->Meta->TempTex);
   meta_decompress_cleanup(&ctx->Meta->Decompress);
   meta_drawpix_cleanup(&ctx->Meta->DrawPix);
a479 7
   /* We always push into desktop GL mode and pop out at the end.  No sense in
    * writing our shaders varying based on the user's context choice, when
    * Mesa can handle either.
    */
   save->API = ctx->API;
   ctx->API = API_OPENGL_COMPAT;

d539 3
a541 1
   if (state & MESA_META_FOG) {
d586 4
a589 2
      _mesa_set_enable(ctx, GL_POLYGON_SMOOTH, GL_FALSE);
      _mesa_set_enable(ctx, GL_POLYGON_STIPPLE, GL_FALSE);
d599 1
a599 3
      int i;

      if (ctx->Extensions.ARB_vertex_program) {
d606 1
a606 1
      if (ctx->Extensions.ARB_fragment_program) {
d613 1
a613 1
      if (ctx->Extensions.ATI_fragment_shader) {
d618 6
a623 13
      if (ctx->Pipeline.Current) {
         _mesa_reference_pipeline_object(ctx, &save->Pipeline,
                                         ctx->Pipeline.Current);
         _mesa_BindProgramPipeline(0);
      }

      /* Save the shader state from ctx->Shader (instead of ctx->_Shader) so
       * that we don't have to worry about the current pipeline state.
       */
      for (i = 0; i <= MESA_SHADER_FRAGMENT; i++) {
         _mesa_reference_shader_program(ctx, &save->Shader[i],
                                        ctx->Shader.CurrentProgram[i]);
      }
d645 27
a671 18
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
         save->TexEnabled[u] = ctx->Texture.Unit[u].Enabled;
         save->TexGenEnabled[u] = ctx->Texture.Unit[u].TexGenEnabled;
         if (ctx->Texture.Unit[u].Enabled ||
             ctx->Texture.Unit[u].TexGenEnabled) {
            _mesa_ActiveTexture(GL_TEXTURE0 + u);
            _mesa_set_enable(ctx, GL_TEXTURE_2D, GL_FALSE);
            if (ctx->Extensions.ARB_texture_cube_map)
               _mesa_set_enable(ctx, GL_TEXTURE_CUBE_MAP, GL_FALSE);

            _mesa_set_enable(ctx, GL_TEXTURE_1D, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_3D, GL_FALSE);
            if (ctx->Extensions.NV_texture_rectangle)
               _mesa_set_enable(ctx, GL_TEXTURE_RECTANGLE, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_GEN_S, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_GEN_T, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_GEN_R, GL_FALSE);
            _mesa_set_enable(ctx, GL_TEXTURE_GEN_Q, GL_FALSE);
d684 3
a686 1
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
d729 2
a730 2
      _mesa_reference_vao(ctx, &save->VAO,
                                   ctx->Array.VAO);
d738 4
a741 4
      save->ViewportX = ctx->ViewportArray[0].X;
      save->ViewportY = ctx->ViewportArray[0].Y;
      save->ViewportW = ctx->ViewportArray[0].Width;
      save->ViewportH = ctx->ViewportArray[0].Height;
d743 5
a747 5
      if (ctx->ViewportArray[0].X != 0 ||
          ctx->ViewportArray[0].Y != 0 ||
          ctx->ViewportArray[0].Width != (float) ctx->DrawBuffer->Width ||
          ctx->ViewportArray[0].Height != (float) ctx->DrawBuffer->Height) {
         _mesa_set_viewport(ctx, 0, 0, 0,
d751 2
a752 2
      save->DepthNear = ctx->ViewportArray[0].Near;
      save->DepthFar = ctx->ViewportArray[0].Far;
d799 1
a799 2
      save->Multisample = ctx->Multisample; /* struct copy */

a801 10
      if (ctx->Multisample.SampleCoverage)
         _mesa_set_enable(ctx, GL_SAMPLE_COVERAGE, GL_FALSE);
      if (ctx->Multisample.SampleAlphaToCoverage)
         _mesa_set_enable(ctx, GL_SAMPLE_ALPHA_TO_COVERAGE, GL_FALSE);
      if (ctx->Multisample.SampleAlphaToOne)
         _mesa_set_enable(ctx, GL_SAMPLE_ALPHA_TO_ONE, GL_FALSE);
      if (ctx->Multisample.SampleShading)
         _mesa_set_enable(ctx, GL_SAMPLE_SHADING, GL_FALSE);
      if (ctx->Multisample.SampleMask)
         _mesa_set_enable(ctx, GL_SAMPLE_MASK, GL_FALSE);
a809 17
   if (state & MESA_META_DRAW_BUFFERS) {
      int buf, real_color_buffers = 0;
      memset(save->ColorDrawBuffers, 0, sizeof(save->ColorDrawBuffers));

      for (buf = 0; buf < ctx->Const.MaxDrawBuffers; buf++) {
         int buf_index = ctx->DrawBuffer->_ColorDrawBufferIndexes[buf];
         if (buf_index == -1)
            continue;

         save->ColorDrawBuffers[buf] =
            gl_buffer_index_to_drawbuffers_enum(buf_index);

         if (++real_color_buffers >= ctx->DrawBuffer->_NumColorDrawBuffers)
            break;
      }
   }

a817 5

      save->DrawBufferName = ctx->DrawBuffer->Name;
      save->ReadBufferName = ctx->ReadBuffer->Name;
      save->RenderbufferName = (ctx->CurrentRenderbuffer ?
                                ctx->CurrentRenderbuffer->Name : 0);
a829 1
   int i;
d891 3
a893 1
   if (state & MESA_META_FOG) {
d917 12
a928 4
      _mesa_PolygonMode(GL_FRONT, save->FrontPolygonMode);
      _mesa_PolygonMode(GL_BACK, save->BackPolygonMode);
      _mesa_set_enable(ctx, GL_POLYGON_STIPPLE, save->PolygonStipple);
      _mesa_set_enable(ctx, GL_POLYGON_SMOOTH, save->PolygonSmooth);
d934 3
a936 11
      unsigned i;

      for (i = 0; i < ctx->Const.MaxViewports; i++) {
         _mesa_set_scissor(ctx, i,
                           save->Scissor.ScissorArray[i].X,
                           save->Scissor.ScissorArray[i].Y,
                           save->Scissor.ScissorArray[i].Width,
                           save->Scissor.ScissorArray[i].Height);
         _mesa_set_enablei(ctx, GL_SCISSOR_TEST, i,
                           (save->Scissor.EnableFlags >> i) & 1);
      }
d940 1
a940 9
      static const GLenum targets[] = {
         GL_VERTEX_SHADER,
         GL_GEOMETRY_SHADER,
         GL_FRAGMENT_SHADER,
      };

      bool any_shader;

      if (ctx->Extensions.ARB_vertex_program) {
d948 1
a948 1
      if (ctx->Extensions.ARB_fragment_program) {
d956 1
a956 1
      if (ctx->Extensions.ATI_fragment_shader) {
d961 2
a962 16
      any_shader = false;
      for (i = 0; i <= MESA_SHADER_FRAGMENT; i++) {
         /* It is safe to call _mesa_use_shader_program even if the extension
          * necessary for that program state is not supported.  In that case,
          * the saved program object must be NULL and the currently bound
          * program object must be NULL.  _mesa_use_shader_program is a no-op
          * in that case.
          */
         _mesa_use_shader_program(ctx, targets[i],
                                  save->Shader[i],
                                  &ctx->Shader);

         /* Do this *before* killing the reference. :)
          */
         if (save->Shader[i] != NULL)
            any_shader = true;
d964 7
a970 2
         _mesa_reference_shader_program(ctx, &save->Shader[i], NULL);
      }
d973 5
a977 1
                                     save->ActiveShader);
a978 17

      /* If there were any stages set with programs, use ctx->Shader as the
       * current shader state.  Otherwise, use Pipeline.Default.  The pipeline
       * hasn't been restored yet, and that may modify ctx->_Shader further.
       */
      if (any_shader)
         _mesa_reference_pipeline_object(ctx, &ctx->_Shader,
                                         &ctx->Shader);
      else
         _mesa_reference_pipeline_object(ctx, &ctx->_Shader,
                                         ctx->Pipeline.Default);

      if (save->Pipeline) {
         _mesa_bind_pipeline(ctx, save->Pipeline);

         _mesa_reference_pipeline_object(ctx, &save->Pipeline, NULL);
      }
d986 1
a986 1
      if (ctx->Extensions.EXT_stencil_two_side) {
d1018 3
a1020 1
      _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, save->EnvMode);
d1033 6
a1038 5
      for (u = 0; u < ctx->Const.MaxTextureUnits; u++) {
         if (ctx->Texture.Unit[u].Enabled != save->TexEnabled[u]) {
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            ctx->Texture.Unit[u].Enabled = save->TexEnabled[u];
         }
d1040 4
a1043 3
         if (ctx->Texture.Unit[u].TexGenEnabled != save->TexGenEnabled[u]) {
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            ctx->Texture.Unit[u].TexGenEnabled = save->TexGenEnabled[u];
d1085 2
a1086 2
      _mesa_BindVertexArray(save->VAO->Name);
      _mesa_reference_vao(ctx, &save->VAO, NULL);
d1090 5
a1094 5
      if (save->ViewportX != ctx->ViewportArray[0].X ||
          save->ViewportY != ctx->ViewportArray[0].Y ||
          save->ViewportW != ctx->ViewportArray[0].Width ||
          save->ViewportH != ctx->ViewportArray[0].Height) {
         _mesa_set_viewport(ctx, 0, save->ViewportX, save->ViewportY,
d1127 2
a1128 24
      struct gl_multisample_attrib *ctx_ms = &ctx->Multisample;
      struct gl_multisample_attrib *save_ms = &save->Multisample;

      if (ctx_ms->Enabled != save_ms->Enabled)
         _mesa_set_multisample(ctx, save_ms->Enabled);
      if (ctx_ms->SampleCoverage != save_ms->SampleCoverage)
         _mesa_set_enable(ctx, GL_SAMPLE_COVERAGE, save_ms->SampleCoverage);
      if (ctx_ms->SampleAlphaToCoverage != save_ms->SampleAlphaToCoverage)
         _mesa_set_enable(ctx, GL_SAMPLE_ALPHA_TO_COVERAGE, save_ms->SampleAlphaToCoverage);
      if (ctx_ms->SampleAlphaToOne != save_ms->SampleAlphaToOne)
         _mesa_set_enable(ctx, GL_SAMPLE_ALPHA_TO_ONE, save_ms->SampleAlphaToOne);
      if (ctx_ms->SampleCoverageValue != save_ms->SampleCoverageValue ||
          ctx_ms->SampleCoverageInvert != save_ms->SampleCoverageInvert) {
         _mesa_SampleCoverage(save_ms->SampleCoverageValue,
                              save_ms->SampleCoverageInvert);
      }
      if (ctx_ms->SampleShading != save_ms->SampleShading)
         _mesa_set_enable(ctx, GL_SAMPLE_SHADING, save_ms->SampleShading);
      if (ctx_ms->SampleMask != save_ms->SampleMask)
         _mesa_set_enable(ctx, GL_SAMPLE_MASK, save_ms->SampleMask);
      if (ctx_ms->SampleMaskValue != save_ms->SampleMaskValue)
         _mesa_SampleMaski(0, save_ms->SampleMaskValue);
      if (ctx_ms->MinSampleShadingValue != save_ms->MinSampleShadingValue)
         _mesa_MinSampleShading(save_ms->MinSampleShadingValue);
a1145 14
   if (ctx->DrawBuffer->Name != save->DrawBufferName)
      _mesa_BindFramebuffer(GL_DRAW_FRAMEBUFFER, save->DrawBufferName);

   if (ctx->ReadBuffer->Name != save->ReadBufferName)
      _mesa_BindFramebuffer(GL_READ_FRAMEBUFFER, save->ReadBufferName);

   if (!ctx->CurrentRenderbuffer ||
       ctx->CurrentRenderbuffer->Name != save->RenderbufferName)
      _mesa_BindRenderbuffer(GL_RENDERBUFFER, save->RenderbufferName);

   if (state & MESA_META_DRAW_BUFFERS) {
      _mesa_DrawBuffers(ctx->Const.MaxDrawBuffers, save->ColorDrawBuffers);
   }

a1146 2

   ctx->API = save->API;
d1201 1
a1201 1
cleanup_temp_texture(struct temp_texture *tex)
d1214 2
a1215 2
struct temp_texture *
_mesa_meta_get_temp_texture(struct gl_context *ctx)
d1248 2
a1249 2
struct temp_texture *
_mesa_meta_get_temp_depth_texture(struct gl_context *ctx)
d1269 3
a1271 3
GLboolean
_mesa_meta_alloc_texture(struct temp_texture *tex,
                         GLsizei width, GLsizei height, GLenum intFormat)
d1322 7
a1328 7
void
_mesa_meta_setup_copypix_texture(struct gl_context *ctx,
                                 struct temp_texture *tex,
                                 GLint srcX, GLint srcY,
                                 GLsizei width, GLsizei height,
                                 GLenum intFormat,
                                 GLenum filter)
a1329 2
   bool newTex;

d1333 2
a1334 3
   _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

   newTex = _mesa_meta_alloc_texture(tex, width, height, intFormat);
d1365 8
a1372 7
void
_mesa_meta_setup_drawpix_texture(struct gl_context *ctx,
                                 struct temp_texture *tex,
                                 GLboolean newTex,
                                 GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels)
d1377 2
a1378 1
   _mesa_TexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
a1411 5
void
_mesa_meta_setup_ff_tnl_for_blit(GLuint *VAO, GLuint *VBO,
                                 unsigned texcoord_size)
{
   _mesa_meta_setup_vertex_objects(VAO, VBO, false, 2, texcoord_size, 0);
a1412 4
   /* setup projection matrix */
   _mesa_MatrixMode(GL_PROJECTION);
   _mesa_LoadIdentity();
}
d1415 1
a1415 1
 * Meta implementation of ctx->Driver.Clear() in terms of polygon rendering.
d1417 2
a1418 2
void
_mesa_meta_Clear(struct gl_context *ctx, GLbitfield buffers)
d1420 18
a1437 2
   meta_clear(ctx, buffers, false);
}
d1439 4
a1442 4
void
_mesa_meta_glsl_Clear(struct gl_context *ctx, GLbitfield buffers)
{
   meta_clear(ctx, buffers, true);
d1446 2
a1447 1
meta_glsl_clear_init(struct gl_context *ctx, struct clear_state *clear)
d1449 4
a1452 27
   const char *vs_source =
      "attribute vec4 position;\n"
      "void main()\n"
      "{\n"
      "   gl_Position = position;\n"
      "}\n";
   const char *gs_source =
      "#version 150\n"
      "layout(triangles) in;\n"
      "layout(triangle_strip, max_vertices = 4) out;\n"
      "uniform int layer;\n"
      "void main()\n"
      "{\n"
      "  for (int i = 0; i < 3; i++) {\n"
      "    gl_Layer = layer;\n"
      "    gl_Position = gl_in[i].gl_Position;\n"
      "    EmitVertex();\n"
      "  }\n"
      "}\n";
   const char *fs_source =
      "uniform vec4 color;\n"
      "void main()\n"
      "{\n"
      "   gl_FragColor = color;\n"
      "}\n";
   GLuint vs, gs = 0, fs;
   bool has_integer_textures;
d1454 2
a1455 1
   _mesa_meta_setup_vertex_objects(&clear->VAO, &clear->VBO, true, 3, 0, 0);
d1457 3
a1459 2
   if (clear->ShaderProg != 0)
      return;
d1461 5
a1465 3
   vs = _mesa_CreateShader(GL_VERTEX_SHADER);
   _mesa_ShaderSource(vs, 1, &vs_source, NULL);
   _mesa_CompileShader(vs);
d1467 5
a1471 4
   if (_mesa_has_geometry_shaders(ctx)) {
      gs = _mesa_CreateShader(GL_GEOMETRY_SHADER);
      _mesa_ShaderSource(gs, 1, &gs_source, NULL);
      _mesa_CompileShader(gs);
d1474 6
a1479 3
   fs = _mesa_CreateShader(GL_FRAGMENT_SHADER);
   _mesa_ShaderSource(fs, 1, &fs_source, NULL);
   _mesa_CompileShader(fs);
d1481 15
a1495 9
   clear->ShaderProg = _mesa_CreateProgram();
   _mesa_AttachShader(clear->ShaderProg, fs);
   _mesa_DeleteShader(fs);
   if (gs != 0)
      _mesa_AttachShader(clear->ShaderProg, gs);
   _mesa_AttachShader(clear->ShaderProg, vs);
   _mesa_DeleteShader(vs);
   _mesa_BindAttribLocation(clear->ShaderProg, 0, "position");
   _mesa_LinkProgram(clear->ShaderProg);
d1497 696
a2192 6
   clear->ColorLocation = _mesa_GetUniformLocation(clear->ShaderProg,
						      "color");
   if (gs != 0) {
      clear->LayerLocation = _mesa_GetUniformLocation(clear->ShaderProg,
						      "layer");
   }
d2201 1
a2201 1
                         "#version 130\n"
d2206 2
a2207 1
                         "}\n");
d2210 4
a2213 1
                         "#version 130\n"
d2220 2
a2221 1
                         "}\n");
d2223 2
a2224 4
      vs = _mesa_meta_compile_shader_with_debug(ctx, GL_VERTEX_SHADER,
                                                vs_int_source);
      fs = _mesa_meta_compile_shader_with_debug(ctx, GL_FRAGMENT_SHADER,
                                                fs_int_source);
d2227 1
a2227 1
      clear->IntegerShaderProg = _mesa_CreateProgram();
d2229 1
a2229 3
      _mesa_DeleteShader(fs);
      if (gs != 0)
         _mesa_AttachShader(clear->IntegerShaderProg, gs);
d2231 1
a2231 1
      _mesa_DeleteShader(vs);
d2239 1
a2239 3
      _mesa_ObjectLabel(GL_PROGRAM, clear->IntegerShaderProg, -1,
                        "integer clear");
      _mesa_meta_link_program_with_debug(ctx, clear->IntegerShaderProg);
a2242 4
      if (gs != 0) {
         clear->IntegerLayerLocation =
            _mesa_GetUniformLocation(clear->IntegerShaderProg, "layer");
      }
a2243 2
   if (gs != 0)
      _mesa_DeleteShader(gs);
d2247 1
a2247 1
meta_glsl_clear_cleanup(struct clear_state *clear)
d2249 1
a2249 1
   if (clear->VAO == 0)
d2251 2
a2252 2
   _mesa_DeleteVertexArrays(1, &clear->VAO);
   clear->VAO = 0;
d2255 1
a2255 1
   _mesa_DeleteProgram(clear->ShaderProg);
d2259 1
a2259 1
      _mesa_DeleteProgram(clear->IntegerShaderProg);
a2264 42
 * Given a bitfield of BUFFER_BIT_x draw buffers, call glDrawBuffers to
 * set GL to only draw to those buffers.
 *
 * Since the bitfield has no associated order, the assignment of draw buffer
 * indices to color attachment indices is rather arbitrary.
 */
static void
drawbuffers_from_bitfield(GLbitfield bits)
{
   GLenum enums[MAX_DRAW_BUFFERS];
   int i = 0;
   int n;

   /* This function is only legal for color buffer bitfields. */
   assert((bits & ~BUFFER_BITS_COLOR) == 0);

   /* Make sure we don't overflow any arrays. */
   assert(_mesa_bitcount(bits) <= MAX_DRAW_BUFFERS);

   enums[0] = GL_NONE;

   if (bits & BUFFER_BIT_FRONT_LEFT)
      enums[i++] = GL_FRONT_LEFT;

   if (bits & BUFFER_BIT_FRONT_RIGHT)
      enums[i++] = GL_FRONT_RIGHT;

   if (bits & BUFFER_BIT_BACK_LEFT)
      enums[i++] = GL_BACK_LEFT;

   if (bits & BUFFER_BIT_BACK_RIGHT)
      enums[i++] = GL_BACK_RIGHT;

   for (n = 0; n < MAX_COLOR_ATTACHMENTS; n++) {
      if (bits & (1 << (BUFFER_COLOR0 + n)))
         enums[i++] = GL_COLOR_ATTACHMENT0 + n;
   }

   _mesa_DrawBuffers(i, enums);
}

/**
d2267 2
a2268 2
static void
meta_clear(struct gl_context *ctx, GLbitfield buffers, bool glsl)
d2274 8
a2281 3
   float x0, y0, x1, y1, z;
   struct vertex verts[4];
   int i;
d2296 1
a2296 12
   if (!glsl) {
      metaSave |= MESA_META_FOG |
                  MESA_META_PIXEL_TRANSFER |
                  MESA_META_TRANSFORM |
                  MESA_META_TEXTURE |
                  MESA_META_CLAMP_VERTEX_COLOR |
                  MESA_META_SELECT_FEEDBACK;
   }

   if (buffers & BUFFER_BITS_COLOR) {
      metaSave |= MESA_META_DRAW_BUFFERS;
   } else {
d2305 1
a2305 17
   if (glsl) {
      meta_glsl_clear_init(ctx, clear);

      x0 = ((float) fb->_Xmin / fb->Width)  * 2.0f - 1.0f;
      y0 = ((float) fb->_Ymin / fb->Height) * 2.0f - 1.0f;
      x1 = ((float) fb->_Xmax / fb->Width)  * 2.0f - 1.0f;
      y1 = ((float) fb->_Ymax / fb->Height) * 2.0f - 1.0f;
      z = -invert_z(ctx->Depth.Clear);
   } else {
      _mesa_meta_setup_vertex_objects(&clear->VAO, &clear->VBO, false, 3, 0, 4);

      x0 = (float) fb->_Xmin;
      y0 = (float) fb->_Ymin;
      x1 = (float) fb->_Xmax;
      y1 = (float) fb->_Ymax;
      z = invert_z(ctx->Depth.Clear);
   }
a2307 1
      assert(glsl);
d2311 1
a2311 1
   } else if (glsl) {
d2317 3
d2322 1
a2322 4
      /* Only draw to the buffers we were asked to clear. */
      drawbuffers_from_bitfield(buffers & BUFFER_BITS_COLOR);

      /* leave colormask state as-is */
a2369 9
   if (!glsl) {
      for (i = 0; i < 4; i++) {
         verts[i].r = ctx->Color.ClearColor.f[0];
         verts[i].g = ctx->Color.ClearColor.f[1];
         verts[i].b = ctx->Color.ClearColor.f[2];
         verts[i].a = ctx->Color.ClearColor.f[3];
      }
   }

d2374 2
a2375 14
   /* draw quad(s) */
   if (fb->MaxNumLayers > 0) {
      unsigned layer;
      assert(glsl);
      for (layer = 0; layer < fb->MaxNumLayers; layer++) {
         if (fb->_IntegerColor)
            _mesa_Uniform1i(clear->IntegerLayerLocation, layer);
         else
            _mesa_Uniform1i(clear->LayerLocation, layer);
         _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
      }
   } else {
      _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
   }
d2390 4
a2393 1
   struct temp_texture *tex = _mesa_meta_get_temp_texture(ctx);
d2395 2
d2419 6
a2424 2
   _mesa_meta_setup_vertex_objects(&copypix->VAO, &copypix->VBO, false,
                                   3, 2, 0);
d2426 16
a2441 2
   /* Silence valgrind warnings about reading uninitialized stack. */
   memset(verts, 0, sizeof(verts));
d2443 1
a2443 3
   /* Alloc/setup texture */
   _mesa_meta_setup_copypix_texture(ctx, tex, srcX, srcY, width, height,
                                    GL_RGBA, GL_NEAREST);
d2456 2
a2457 2
      verts[0].tex[0] = 0.0F;
      verts[0].tex[1] = 0.0F;
d2461 2
a2462 2
      verts[1].tex[0] = tex->Sright;
      verts[1].tex[1] = 0.0F;
d2466 2
a2467 2
      verts[2].tex[0] = tex->Sright;
      verts[2].tex[1] = tex->Ttop;
d2471 2
a2472 2
      verts[3].tex[0] = 0.0F;
      verts[3].tex[1] = tex->Ttop;
d2478 4
a2491 15
static void
meta_drawpix_cleanup(struct drawpix_state *drawpix)
{
   if (drawpix->VAO != 0) {
      _mesa_DeleteVertexArrays(1, &drawpix->VAO);
      drawpix->VAO = 0;

      _mesa_DeleteBuffers(1, &drawpix->VBO);
      drawpix->VBO = 0;
   }

   if (drawpix->StencilFP != 0) {
      _mesa_DeleteProgramsARB(1, &drawpix->StencilFP);
      drawpix->StencilFP = 0;
   }
a2492 5
   if (drawpix->DepthFP != 0) {
      _mesa_DeleteProgramsARB(1, &drawpix->DepthFP);
      drawpix->DepthFP = 0;
   }
}
d2576 1
a2576 1
   struct temp_texture *tex = _mesa_meta_get_temp_texture(ctx);
d2610 1
a2610 1
   struct temp_texture *tex = _mesa_meta_get_temp_texture(ctx);
d2642 1
a2642 1
   struct temp_texture *tex = _mesa_meta_get_temp_texture(ctx);
d2645 3
d2652 1
d2742 1
a2742 7
   newTex = _mesa_meta_alloc_texture(tex, width, height, texIntFormat);

   _mesa_meta_setup_vertex_objects(&drawpix->VAO, &drawpix->VBO, false,
                                   3, 2, 0);

   /* Silence valgrind warnings about reading uninitialized stack. */
   memset(verts, 0, sizeof(verts));
d2755 2
a2756 2
      verts[0].tex[0] = 0.0F;
      verts[0].tex[1] = 0.0F;
d2760 2
a2761 2
      verts[1].tex[0] = tex->Sright;
      verts[1].tex[1] = 0.0F;
d2765 2
a2766 2
      verts[2].tex[0] = tex->Sright;
      verts[2].tex[1] = tex->Ttop;
d2770 2
a2771 2
      verts[3].tex[0] = 0.0F;
      verts[3].tex[1] = tex->Ttop;
d2774 9
a2782 1
   /* upload new vertex data */
d2786 6
d2804 2
a2805 2
      _mesa_meta_setup_drawpix_texture(ctx, tex, newTex, width, height,
                                       GL_ALPHA, type, pixels);
d2829 1
a2829 1
                                             255.0f / mask, 0.5f, 0.0f, 0.0f);
d2847 2
a2848 2
      _mesa_meta_setup_drawpix_texture(ctx, tex, newTex, width, height,
                                       format, type, pixels);
d2854 2
a2855 2
      _mesa_meta_setup_drawpix_texture(ctx, tex, newTex, width, height,
                                       format, type, pixels);
d2861 2
d2914 3
d2927 1
a2927 1
       ctx->Texture._MaxEnabledTexImageUnit != -1 ||
d2946 10
a2955 3
                          MESA_META_CLIP |
                          MESA_META_VERTEX |
                          MESA_META_VIEWPORT));
d2957 5
a2961 1
   _mesa_meta_setup_vertex_objects(&bitmap->VAO, &bitmap->VBO, false, 3, 2, 4);
d2963 12
a2974 1
   newTex = _mesa_meta_alloc_texture(tex, width, height, texIntFormat);
d2976 1
a2976 2
   /* Silence valgrind warnings about reading uninitialized stack. */
   memset(verts, 0, sizeof(verts));
d2990 2
a2991 2
      verts[0].tex[0] = 0.0F;
      verts[0].tex[1] = 0.0F;
d2995 2
a2996 2
      verts[1].tex[0] = tex->Sright;
      verts[1].tex[1] = 0.0F;
d3000 2
a3001 2
      verts[2].tex[0] = tex->Sright;
      verts[2].tex[1] = tex->Ttop;
d3005 2
a3006 2
      verts[3].tex[0] = 0.0F;
      verts[3].tex[1] = tex->Ttop;
d3040 2
a3041 2
      _mesa_meta_setup_drawpix_texture(ctx, tex, newTex, width, height,
                                       GL_ALPHA, GL_UNSIGNED_BYTE, bitmap8);
d3055 96
d3160 10
a3169 10
void
_mesa_meta_setup_texture_coords(GLenum faceTarget,
                                GLint slice,
                                GLint width,
                                GLint height,
                                GLint depth,
                                GLfloat coords0[4],
                                GLfloat coords1[4],
                                GLfloat coords2[4],
                                GLfloat coords3[4])
a3176 10
   if (faceTarget == GL_TEXTURE_CUBE_MAP_ARRAY)
      faceTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + slice % 6;

   /* Currently all texture targets want the W component to be 1.0.
    */
   coords0[3] = 1.0F;
   coords1[3] = 1.0F;
   coords2[3] = 1.0F;
   coords3[3] = 1.0F;

d3188 1
a3188 1
         r = (float) slice;
d3208 1
a3208 1
      coords1[0] = (float) width;
d3211 2
a3212 2
      coords2[0] = (float) width;
      coords2[1] = (float) height;
d3215 1
a3215 1
      coords3[1] = (float) height;
d3220 1
a3220 1
      coords0[1] = (float) slice; /* t */
d3223 1
a3223 1
      coords1[1] = (float) slice;
d3226 1
a3226 1
      coords2[1] = (float) slice;
d3229 1
a3229 1
      coords3[1] = (float) slice;
a3266 2
         coord[3] = (float) (slice / 6);

d3304 27
a3330 1
      assert(!"unexpected target in _mesa_meta_setup_texture_coords()");
d3332 5
d3339 3
a3341 2
static struct blit_shader *
choose_blit_shader(GLenum target, struct blit_shader_table *table)
d3345 4
a3348 4
      table->sampler_1d.type = "sampler1D";
      table->sampler_1d.func = "texture1D";
      table->sampler_1d.texcoords = "texCoords.x";
      return &table->sampler_1d;
d3350 4
a3353 9
      table->sampler_2d.type = "sampler2D";
      table->sampler_2d.func = "texture2D";
      table->sampler_2d.texcoords = "texCoords.xy";
      return &table->sampler_2d;
   case GL_TEXTURE_RECTANGLE:
      table->sampler_rect.type = "sampler2DRect";
      table->sampler_rect.func = "texture2DRect";
      table->sampler_rect.texcoords = "texCoords.xy";
      return &table->sampler_rect;
d3358 4
a3361 4
      table->sampler_3d.type = "sampler3D";
      table->sampler_3d.func = "texture3D";
      table->sampler_3d.texcoords = "texCoords.xyz";
      return &table->sampler_3d;
d3363 4
a3366 4
      table->sampler_cubemap.type = "samplerCube";
      table->sampler_cubemap.func = "textureCube";
      table->sampler_cubemap.texcoords = "texCoords.xyz";
      return &table->sampler_cubemap;
d3368 4
a3371 4
      table->sampler_1d_array.type = "sampler1DArray";
      table->sampler_1d_array.func = "texture1DArray";
      table->sampler_1d_array.texcoords = "texCoords.xy";
      return &table->sampler_1d_array;
d3373 4
a3376 9
      table->sampler_2d_array.type = "sampler2DArray";
      table->sampler_2d_array.func = "texture2DArray";
      table->sampler_2d_array.texcoords = "texCoords.xyz";
      return &table->sampler_2d_array;
   case GL_TEXTURE_CUBE_MAP_ARRAY:
      table->sampler_cubemap_array.type = "samplerCubeArray";
      table->sampler_cubemap_array.func = "textureCubeArray";
      table->sampler_cubemap_array.texcoords = "texCoords.xyzw";
      return &table->sampler_cubemap_array;
d3384 148
d3533 2
a3534 1
_mesa_meta_blit_shader_table_cleanup(struct blit_shader_table *table)
d3536 219
a3754 17
   _mesa_DeleteProgram(table->sampler_1d.shader_prog);
   _mesa_DeleteProgram(table->sampler_2d.shader_prog);
   _mesa_DeleteProgram(table->sampler_3d.shader_prog);
   _mesa_DeleteProgram(table->sampler_rect.shader_prog);
   _mesa_DeleteProgram(table->sampler_cubemap.shader_prog);
   _mesa_DeleteProgram(table->sampler_1d_array.shader_prog);
   _mesa_DeleteProgram(table->sampler_2d_array.shader_prog);
   _mesa_DeleteProgram(table->sampler_cubemap_array.shader_prog);

   table->sampler_1d.shader_prog = 0;
   table->sampler_2d.shader_prog = 0;
   table->sampler_3d.shader_prog = 0;
   table->sampler_rect.shader_prog = 0;
   table->sampler_cubemap.shader_prog = 0;
   table->sampler_1d_array.shader_prog = 0;
   table->sampler_2d_array.shader_prog = 0;
   table->sampler_cubemap_array.shader_prog = 0;
d3757 1
d3763 1
a3763 1
get_temp_image_type(struct gl_context *ctx, mesa_format format)
a3808 77
/**
 * Attempts to wrap the destination texture in an FBO and use
 * glBlitFramebuffer() to implement glCopyTexSubImage().
 */
static bool
copytexsubimage_using_blit_framebuffer(struct gl_context *ctx, GLuint dims,
                                       struct gl_texture_image *texImage,
                                       GLint xoffset,
                                       GLint yoffset,
                                       GLint zoffset,
                                       struct gl_renderbuffer *rb,
                                       GLint x, GLint y,
                                       GLsizei width, GLsizei height)
{
   struct gl_texture_object *texObj = texImage->TexObject;
   GLuint fbo;
   bool success = false;
   GLbitfield mask;
   GLenum status;

   if (!ctx->Extensions.ARB_framebuffer_object)
      return false;

   _mesa_unlock_texture(ctx, texObj);

   _mesa_meta_begin(ctx, MESA_META_ALL & ~MESA_META_DRAW_BUFFERS);

   _mesa_GenFramebuffers(1, &fbo);
   _mesa_BindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo);

   if (rb->_BaseFormat == GL_DEPTH_STENCIL ||
       rb->_BaseFormat == GL_DEPTH_COMPONENT) {
      _mesa_meta_bind_fbo_image(GL_DEPTH_ATTACHMENT, texImage, zoffset);
      mask = GL_DEPTH_BUFFER_BIT;

      if (rb->_BaseFormat == GL_DEPTH_STENCIL &&
          texImage->_BaseFormat == GL_DEPTH_STENCIL) {
         _mesa_meta_bind_fbo_image(GL_STENCIL_ATTACHMENT, texImage, zoffset);
         mask |= GL_STENCIL_BUFFER_BIT;
      }
      _mesa_DrawBuffer(GL_NONE);
   } else {
      _mesa_meta_bind_fbo_image(GL_COLOR_ATTACHMENT0, texImage, zoffset);
      mask = GL_COLOR_BUFFER_BIT;
      _mesa_DrawBuffer(GL_COLOR_ATTACHMENT0);
   }

   status = _mesa_CheckFramebufferStatus(GL_DRAW_FRAMEBUFFER);
   if (status != GL_FRAMEBUFFER_COMPLETE)
      goto out;

   ctx->Meta->Blit.no_ctsi_fallback = true;

   /* Since we've bound a new draw framebuffer, we need to update
    * its derived state -- _Xmin, etc -- for BlitFramebuffer's clipping to
    * be correct.
    */
   _mesa_update_state(ctx);

   /* We skip the core BlitFramebuffer checks for format consistency, which
    * are too strict for CopyTexImage.  We know meta will be fine with format
    * changes.
    */
   mask = _mesa_meta_BlitFramebuffer(ctx, x, y,
                                     x + width, y + height,
                                     xoffset, yoffset,
                                     xoffset + width, yoffset + height,
                                     mask, GL_NEAREST);
   ctx->Meta->Blit.no_ctsi_fallback = false;
   success = mask == 0x0;

 out:
   _mesa_lock_texture(ctx, texObj);
   _mesa_DeleteFramebuffers(1, &fbo);
   _mesa_meta_end(ctx);
   return success;
}
a3826 9
   if (copytexsubimage_using_blit_framebuffer(ctx, dims,
                                              texImage,
                                              xoffset, yoffset, zoffset,
                                              rb,
                                              x, y,
                                              width, height)) {
      return;
   }

a3893 19
static void
meta_decompress_cleanup(struct decompress_state *decompress)
{
   if (decompress->FBO != 0) {
      _mesa_DeleteFramebuffers(1, &decompress->FBO);
      _mesa_DeleteRenderbuffers(1, &decompress->RBO);
   }

   if (decompress->VAO != 0) {
      _mesa_DeleteVertexArrays(1, &decompress->VAO);
      _mesa_DeleteBuffers(1, &decompress->VBO);
   }

   if (decompress->Sampler != 0)
      _mesa_DeleteSamplers(1, &decompress->Sampler);

   memset(decompress, 0, sizeof(*decompress));
}

d3917 3
d3921 2
a3923 2
   const bool use_glsl_version = ctx->Extensions.ARB_vertex_shader &&
                                      ctx->Extensions.ARB_fragment_shader;
d3927 1
a3927 2
             target == GL_TEXTURE_2D_ARRAY ||
             target == GL_TEXTURE_CUBE_MAP_ARRAY);
d3930 1
a3930 15
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_1D_ARRAY:
      assert(!"No compressed 1D textures.");
      return;

   case GL_TEXTURE_3D:
      assert(!"No compressed 3D textures.");
      return;

   case GL_TEXTURE_CUBE_MAP_ARRAY:
      faceTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + (slice % 6);
      break;

   case GL_TEXTURE_CUBE_MAP:
d3932 2
a3933 3
      break;

   default:
a3934 1
      break;
d3937 6
a3942 2
   _mesa_meta_begin(ctx, MESA_META_ALL & ~(MESA_META_PIXEL_STORE |
                                           MESA_META_DRAW_BUFFERS));
d3971 11
a3981 3
   if (use_glsl_version) {
      _mesa_meta_setup_vertex_objects(&decompress->VAO, &decompress->VBO, true,
                                      2, 4, 0);
d3983 9
a3991 3
      _mesa_meta_setup_blit_shader(ctx, target, &decompress->shaders);
   } else {
      _mesa_meta_setup_ff_tnl_for_blit(&decompress->VAO, &decompress->VBO, 3);
d4010 5
a4014 8
   /* Silence valgrind warnings about reading uninitialized stack. */
   memset(verts, 0, sizeof(verts));

   _mesa_meta_setup_texture_coords(faceTarget, slice, width, height, depth,
                                   verts[0].tex,
                                   verts[1].tex,
                                   verts[2].tex,
                                   verts[3].tex);
d4017 8
a4024 8
   verts[0].x = -1.0F;
   verts[0].y = -1.0F;
   verts[1].x =  1.0F;
   verts[1].y = -1.0F;
   verts[2].x =  1.0F;
   verts[2].y =  1.0F;
   verts[3].x = -1.0F;
   verts[3].y =  1.0F;
d4026 4
a4029 1
   _mesa_set_viewport(ctx, 0, 0, 0, width, height);
d4036 1
a4036 3

   if (!use_glsl_version)
      _mesa_set_enable(ctx, target, GL_TRUE);
d4096 1
a4096 2
   if (!use_glsl_version)
      _mesa_set_enable(ctx, target, GL_FALSE);
d4101 10
d4137 1
a4137 2
         if (texImage->TexObject->Target == GL_TEXTURE_2D_ARRAY
             || texImage->TexObject->Target == GL_TEXTURE_CUBE_MAP_ARRAY) {
d4185 1
a4185 1
   if (drawtex->VAO == 0) {
d4190 2
a4191 2
      _mesa_GenVertexArrays(1, &drawtex->VAO);
      _mesa_BindVertexArray(drawtex->VAO);
d4215 1
a4215 1
      _mesa_BindVertexArray(drawtex->VAO);
d4249 1
a4249 1
         if (!ctx->Texture.Unit[i]._Current) {
@


1.1.1.6
log
@Import Mesa 10.2.7
@
text
@d2744 3
a2746 3
   const GLenum baseFormat = _mesa_get_format_base_format(format);
   const GLint format_red_bits = _mesa_get_format_bits(format, GL_RED_BITS);
   GLenum datatype = _mesa_get_format_datatype(format);
d2757 1
a2757 3
      if (datatype == GL_INT || datatype == GL_UNSIGNED_INT) {
         return datatype;
      } else if (format_red_bits <= 8) {
d2759 1
a2759 1
      } else if (format_red_bits <= 16) {
d2761 5
a2766 1
      return GL_FLOAT;
d2768 1
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@a42 1
#include "main/clear.h"
a49 1
#include "main/format_unpack.h"
a73 1
#include "main/texstore.h"
d84 1
a84 1
#include "util/ralloc.h"
d101 1
a101 1
_mesa_meta_bind_fbo_image(GLenum fboTarget, GLenum attachment,
d106 1
a106 1
   GLenum texTarget = texObj->Target;
d108 1
a108 1
   switch (texTarget) {
d110 1
a110 1
      _mesa_FramebufferTexture1D(fboTarget,
d112 1
a112 1
                                 texTarget,
d121 1
a121 1
      _mesa_FramebufferTextureLayer(fboTarget,
d128 2
a129 2
      if (texTarget == GL_TEXTURE_CUBE_MAP)
         texTarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + texImage->Face;
d131 1
a131 1
      _mesa_FramebufferTexture2D(fboTarget,
d133 1
a133 1
                                 texTarget,
a219 1
   _mesa_ObjectLabel(GL_PROGRAM, *program, -1, name);
d227 1
d396 19
a507 5
   if (state & MESA_META_DITHER) {
      save->DitherFlag = ctx->Color.DitherFlag;
      _mesa_set_enable(ctx, GL_DITHER, GL_TRUE);
   }

a693 6

      if (ctx->Extensions.ARB_clip_control) {
         save->ClipOrigin = ctx->Transform.ClipOrigin;
         save->ClipDepthMode = ctx->Transform.ClipDepthMode;
         _mesa_ClipControl(GL_LOWER_LEFT, GL_NEGATIVE_ONE_TO_ONE);
      }
d801 14
a814 3
      struct gl_framebuffer *fb = ctx->DrawBuffer;
      memcpy(save->ColorDrawBuffers, fb->ColorDrawBuffer,
             sizeof(save->ColorDrawBuffers));
a877 3
   if (state & MESA_META_DITHER)
      _mesa_set_enable(ctx, GL_DITHER, save->DitherFlag);

a1102 3

      if (ctx->Extensions.ARB_clip_control)
         _mesa_ClipControl(save->ClipOrigin, save->ClipDepthMode);
d1216 1
a1216 1
      _mesa_drawbuffers(ctx, ctx->Const.MaxDrawBuffers, save->ColorDrawBuffers, NULL);
d1242 1
a1242 1
static inline GLfloat
a1517 2
      "#extension GL_AMD_vertex_shader_layer : enable\n"
      "#extension GL_ARB_draw_instanced : enable\n"
a1520 3
      "#ifdef GL_AMD_vertex_shader_layer\n"
      "   gl_Layer = gl_InstanceID;\n"
      "#endif\n"
d1523 13
d1542 1
a1542 1
   GLuint vs, fs;
d1554 6
d1567 2
a1571 1
   _mesa_ObjectLabel(GL_PROGRAM, clear->ShaderProg, -1, "meta clear");
d1574 6
a1579 1
   clear->ColorLocation = _mesa_GetUniformLocation(clear->ShaderProg, "color");
a1588 2
                         "#extension GL_AMD_vertex_shader_layer : enable\n"
                         "#extension GL_ARB_draw_instanced : enable\n"
a1591 3
                         "#ifdef GL_AMD_vertex_shader_layer\n"
                         "   gl_Layer = gl_InstanceID;\n"
                         "#endif\n"
d1614 2
d1631 4
d1636 2
d1665 2
a1666 2
void
_mesa_meta_drawbuffers_from_bitfield(GLbitfield bits)
d1779 1
a1779 1
      _mesa_meta_drawbuffers_from_bitfield(buffers & BUFFER_BITS_COLOR);
d1844 9
a1852 1
      _mesa_DrawArraysInstanced(GL_TRIANGLE_FAN, 0, 4, fb->MaxNumLayers);
d2615 1
a2615 1
            unreachable("not reached");
a2744 1
   const GLenum datatype = _mesa_get_format_datatype(format);
d2746 1
d2765 1
a2765 1
   case GL_DEPTH_COMPONENT:
d2770 3
a2772 1
   case GL_DEPTH_STENCIL:
d2777 1
d2799 1
d2808 2
d2817 1
a2817 2
      _mesa_meta_bind_fbo_image(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
                                texImage, zoffset);
d2822 1
a2822 2
         _mesa_meta_bind_fbo_image(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT,
                                   texImage, zoffset);
d2827 1
a2827 2
      _mesa_meta_bind_fbo_image(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                                texImage, zoffset);
d2857 1
d2875 1
d2920 2
d2950 2
a2954 10
static void
meta_decompress_fbo_cleanup(struct decompress_fbo_state *decompress_fbo)
{
   if (decompress_fbo->FBO != 0) {
      _mesa_DeleteFramebuffers(1, &decompress_fbo->FBO);
      _mesa_DeleteRenderbuffers(1, &decompress_fbo->RBO);
   }

   memset(decompress_fbo, 0, sizeof(*decompress_fbo));
}
d2959 4
a2962 2
   meta_decompress_fbo_cleanup(&decompress->byteFBO);
   meta_decompress_fbo_cleanup(&decompress->floatFBO);
d2984 1
a2984 1
static bool
a2991 1
   struct decompress_fbo_state *decompress_fbo;
a2996 1
   GLenum rbFormat;
a2999 1
   GLenum status;
a3002 13
   switch (_mesa_get_format_datatype(texImage->TexFormat)) {
   case GL_FLOAT:
      decompress_fbo = &decompress->floatFBO;
      rbFormat = GL_RGBA32F;
      break;
   case GL_UNSIGNED_NORMALIZED:
      decompress_fbo = &decompress->byteFBO;
      rbFormat = GL_RGBA;
      break;
   default:
      return false;
   }

d3013 1
a3013 1
      return false;
d3017 1
a3017 1
      return false;
d3039 5
a3043 5
   if (decompress_fbo->FBO == 0) {
      _mesa_GenFramebuffers(1, &decompress_fbo->FBO);
      _mesa_GenRenderbuffers(1, &decompress_fbo->RBO);
      _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, decompress_fbo->FBO);
      _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, decompress_fbo->RBO);
d3047 1
a3047 1
                                       decompress_fbo->RBO);
d3050 1
a3050 1
      _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, decompress_fbo->FBO);
d3054 6
a3059 14
   if (width > decompress_fbo->Width || height > decompress_fbo->Height) {
      _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, decompress_fbo->RBO);
      _mesa_RenderbufferStorage(GL_RENDERBUFFER_EXT, rbFormat,
                                width, height);
      status = _mesa_CheckFramebufferStatus(GL_DRAW_FRAMEBUFFER);
      if (status != GL_FRAMEBUFFER_COMPLETE) {
         /* If the framebuffer isn't complete then we'll leave
          * decompress_fbo->Width as zero so that it will fail again next time
          * too */
         _mesa_meta_end(ctx);
         return false;
      }
      decompress_fbo->Width = width;
      decompress_fbo->Height = height;
a3180 2

   return true;
d3194 8
a3201 1
   if (_mesa_is_format_compressed(texImage->TexFormat)) {
d3203 2
a3204 2
      bool result;

d3224 1
a3224 4
         result = decompress_texture_image(ctx, texImage, slice,
                                           format, type, dst);
         if (!result)
            break;
d3226 5
a3230 3

      if (result)
         return;
a3231 2

   _mesa_get_teximage(ctx, format, type, pixels, texImage);
a3357 185
}

static bool
cleartexsubimage_color(struct gl_context *ctx,
                       struct gl_texture_image *texImage,
                       const GLvoid *clearValue,
                       GLint zoffset)
{
   mesa_format format;
   union gl_color_union colorValue;
   GLenum datatype;
   GLenum status;

   _mesa_meta_bind_fbo_image(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                             texImage, zoffset);

   status = _mesa_CheckFramebufferStatus(GL_DRAW_FRAMEBUFFER);
   if (status != GL_FRAMEBUFFER_COMPLETE)
      return false;

   /* We don't want to apply an sRGB conversion so override the format */
   format = _mesa_get_srgb_format_linear(texImage->TexFormat);
   datatype = _mesa_get_format_datatype(format);

   switch (datatype) {
   case GL_UNSIGNED_INT:
   case GL_INT:
      if (clearValue)
         _mesa_unpack_uint_rgba_row(format, 1, clearValue,
                                    (GLuint (*)[4]) colorValue.ui);
      else
         memset(&colorValue, 0, sizeof colorValue);
      if (datatype == GL_INT)
         _mesa_ClearBufferiv(GL_COLOR, 0, colorValue.i);
      else
         _mesa_ClearBufferuiv(GL_COLOR, 0, colorValue.ui);
      break;
   default:
      if (clearValue)
         _mesa_unpack_rgba_row(format, 1, clearValue,
                               (GLfloat (*)[4]) colorValue.f);
      else
         memset(&colorValue, 0, sizeof colorValue);
      _mesa_ClearBufferfv(GL_COLOR, 0, colorValue.f);
      break;
   }

   return true;
}

static bool
cleartexsubimage_depth_stencil(struct gl_context *ctx,
                               struct gl_texture_image *texImage,
                               const GLvoid *clearValue,
                               GLint zoffset)
{
   GLint stencilValue;
   GLfloat depthValue;
   GLenum status;

   _mesa_meta_bind_fbo_image(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
                             texImage, zoffset);

   if (texImage->_BaseFormat == GL_DEPTH_STENCIL)
      _mesa_meta_bind_fbo_image(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT,
                                texImage, zoffset);

   status = _mesa_CheckFramebufferStatus(GL_DRAW_FRAMEBUFFER);
   if (status != GL_FRAMEBUFFER_COMPLETE)
      return false;

   if (clearValue) {
      GLuint depthStencilValue[2];

      /* Convert the clearValue from whatever format it's in to a floating
       * point value for the depth and an integer value for the stencil index
       */
      _mesa_unpack_float_32_uint_24_8_depth_stencil_row(texImage->TexFormat,
                                                        1, /* n */
                                                        clearValue,
                                                        depthStencilValue);
      /* We need a memcpy here instead of a cast because we need to
       * reinterpret the bytes as a float rather than converting it
       */
      memcpy(&depthValue, depthStencilValue, sizeof depthValue);
      stencilValue = depthStencilValue[1] & 0xff;
   } else {
      depthValue = 0.0f;
      stencilValue = 0;
   }

   if (texImage->_BaseFormat == GL_DEPTH_STENCIL)
      _mesa_ClearBufferfi(GL_DEPTH_STENCIL, 0, depthValue, stencilValue);
   else
      _mesa_ClearBufferfv(GL_DEPTH, 0, &depthValue);

   return true;
}

static bool
cleartexsubimage_for_zoffset(struct gl_context *ctx,
                             struct gl_texture_image *texImage,
                             GLint zoffset,
                             const GLvoid *clearValue)
{
   GLuint fbo;
   bool success;

   _mesa_GenFramebuffers(1, &fbo);
   _mesa_BindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo);

   switch(texImage->_BaseFormat) {
   case GL_DEPTH_STENCIL:
   case GL_DEPTH_COMPONENT:
      success = cleartexsubimage_depth_stencil(ctx, texImage,
                                               clearValue, zoffset);
      break;
   default:
      success = cleartexsubimage_color(ctx, texImage, clearValue, zoffset);
      break;
   }

   _mesa_DeleteFramebuffers(1, &fbo);

   return success;
}

static bool
cleartexsubimage_using_fbo(struct gl_context *ctx,
                           struct gl_texture_image *texImage,
                           GLint xoffset, GLint yoffset, GLint zoffset,
                           GLsizei width, GLsizei height, GLsizei depth,
                           const GLvoid *clearValue)
{
   bool success = true;
   GLint z;

   _mesa_meta_begin(ctx,
                    MESA_META_SCISSOR |
                    MESA_META_COLOR_MASK |
                    MESA_META_DITHER |
                    MESA_META_FRAMEBUFFER_SRGB);

   _mesa_set_enable(ctx, GL_DITHER, GL_FALSE);

   _mesa_set_enable(ctx, GL_SCISSOR_TEST, GL_TRUE);
   _mesa_Scissor(xoffset, yoffset, width, height);

   for (z = zoffset; z < zoffset + depth; z++) {
      if (!cleartexsubimage_for_zoffset(ctx, texImage, z, clearValue)) {
         success = false;
         break;
      }
   }

   _mesa_meta_end(ctx);

   return success;
}

extern void
_mesa_meta_ClearTexSubImage(struct gl_context *ctx,
                            struct gl_texture_image *texImage,
                            GLint xoffset, GLint yoffset, GLint zoffset,
                            GLsizei width, GLsizei height, GLsizei depth,
                            const GLvoid *clearValue)
{
   bool res;

   res = cleartexsubimage_using_fbo(ctx, texImage,
                                    xoffset, yoffset, zoffset,
                                    width, height, depth,
                                    clearValue);

   if (res)
      return;

   _mesa_warning(ctx,
                 "Falling back to mapping the texture in "
                 "glClearTexSubImage\n");

   _mesa_store_cleartexsubimage(ctx, texImage,
                                xoffset, yoffset, zoffset,
                                width, height, depth,
                                clearValue);
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d43 1
d51 1
d76 1
d87 1
a87 1
#include "../glsl/ralloc.h"
d104 1
a104 1
_mesa_meta_bind_fbo_image(GLenum attachment,
d109 1
a109 1
   GLenum target = texObj->Target;
d111 1
a111 1
   switch (target) {
d113 1
a113 1
      _mesa_FramebufferTexture1D(GL_FRAMEBUFFER,
d115 1
a115 1
                                 target,
d124 1
a124 1
      _mesa_FramebufferTextureLayer(GL_FRAMEBUFFER,
d131 2
a132 2
      if (target == GL_TEXTURE_CUBE_MAP)
         target = GL_TEXTURE_CUBE_MAP_POSITIVE_X + texImage->Face;
d134 1
a134 1
      _mesa_FramebufferTexture2D(GL_FRAMEBUFFER,
d136 1
a136 1
                                 target,
d223 1
a230 1
   _mesa_ObjectLabel(GL_PROGRAM, *program, -1, name);
a398 19
static GLenum
gl_buffer_index_to_drawbuffers_enum(gl_buffer_index bufindex)
{
   assert(bufindex < BUFFER_COUNT);

   if (bufindex >= BUFFER_COLOR0)
      return GL_COLOR_ATTACHMENT0 + bufindex - BUFFER_COLOR0;
   else if (bufindex == BUFFER_FRONT_LEFT)
      return GL_FRONT_LEFT;
   else if (bufindex == BUFFER_FRONT_RIGHT)
      return GL_FRONT_RIGHT;
   else if (bufindex == BUFFER_BACK_LEFT)
      return GL_BACK_LEFT;
   else if (bufindex == BUFFER_BACK_RIGHT)
      return GL_BACK_RIGHT;

   return GL_NONE;
}

d492 5
d683 6
d796 3
a798 14
      int buf, real_color_buffers = 0;
      memset(save->ColorDrawBuffers, 0, sizeof(save->ColorDrawBuffers));

      for (buf = 0; buf < ctx->Const.MaxDrawBuffers; buf++) {
         int buf_index = ctx->DrawBuffer->_ColorDrawBufferIndexes[buf];
         if (buf_index == -1)
            continue;

         save->ColorDrawBuffers[buf] =
            gl_buffer_index_to_drawbuffers_enum(buf_index);

         if (++real_color_buffers >= ctx->DrawBuffer->_NumColorDrawBuffers)
            break;
      }
d862 3
d1090 3
d1206 1
a1206 1
      _mesa_DrawBuffers(ctx->Const.MaxDrawBuffers, save->ColorDrawBuffers);
d1232 1
a1232 1
static INLINE GLfloat
d1508 2
d1513 3
a1517 13
   const char *gs_source =
      "#version 150\n"
      "layout(triangles) in;\n"
      "layout(triangle_strip, max_vertices = 4) out;\n"
      "uniform int layer;\n"
      "void main()\n"
      "{\n"
      "  for (int i = 0; i < 3; i++) {\n"
      "    gl_Layer = layer;\n"
      "    gl_Position = gl_in[i].gl_Position;\n"
      "    EmitVertex();\n"
      "  }\n"
      "}\n";
d1524 1
a1524 1
   GLuint vs, gs = 0, fs;
a1535 6
   if (_mesa_has_geometry_shaders(ctx)) {
      gs = _mesa_CreateShader(GL_GEOMETRY_SHADER);
      _mesa_ShaderSource(gs, 1, &gs_source, NULL);
      _mesa_CompileShader(gs);
   }

a1542 2
   if (gs != 0)
      _mesa_AttachShader(clear->ShaderProg, gs);
d1546 1
d1549 1
a1549 6
   clear->ColorLocation = _mesa_GetUniformLocation(clear->ShaderProg,
						      "color");
   if (gs != 0) {
      clear->LayerLocation = _mesa_GetUniformLocation(clear->ShaderProg,
						      "layer");
   }
d1559 2
d1564 3
a1588 2
      if (gs != 0)
         _mesa_AttachShader(clear->IntegerShaderProg, gs);
a1603 4
      if (gs != 0) {
         clear->IntegerLayerLocation =
            _mesa_GetUniformLocation(clear->IntegerShaderProg, "layer");
      }
a1604 2
   if (gs != 0)
      _mesa_DeleteShader(gs);
d1632 2
a1633 2
static void
drawbuffers_from_bitfield(GLbitfield bits)
d1746 1
a1746 1
      drawbuffers_from_bitfield(buffers & BUFFER_BITS_COLOR);
d1811 1
a1811 9
      unsigned layer;
      assert(glsl);
      for (layer = 0; layer < fb->MaxNumLayers; layer++) {
         if (fb->_IntegerColor)
            _mesa_Uniform1i(clear->IntegerLayerLocation, layer);
         else
            _mesa_Uniform1i(clear->LayerLocation, layer);
         _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);
      }
d2574 1
a2574 1
            assert(0);
d2704 1
a2705 1
   GLenum datatype = _mesa_get_format_datatype(format);
d2724 1
a2724 1
   case GL_DEPTH_COMPONENT: {
d2729 1
a2729 3
   }
   case GL_DEPTH_STENCIL: {
      GLenum datatype = _mesa_get_format_datatype(format);
a2733 1
   }
a2754 1
   struct gl_texture_object *texObj = texImage->TexObject;
a2762 2
   _mesa_unlock_texture(ctx, texObj);

d2770 2
a2771 1
      _mesa_meta_bind_fbo_image(GL_DEPTH_ATTACHMENT, texImage, zoffset);
d2776 2
a2777 1
         _mesa_meta_bind_fbo_image(GL_STENCIL_ATTACHMENT, texImage, zoffset);
d2782 2
a2783 1
      _mesa_meta_bind_fbo_image(GL_COLOR_ATTACHMENT0, texImage, zoffset);
a2812 1
   _mesa_lock_texture(ctx, texObj);
a2829 1
   struct gl_texture_object *texObj = texImage->TexObject;
a2873 2
   _mesa_unlock_texture(ctx, texObj); /* need to unlock first */

a2901 2
   _mesa_lock_texture(ctx, texObj); /* re-lock */

d2905 10
d2919 2
a2920 4
   if (decompress->FBO != 0) {
      _mesa_DeleteFramebuffers(1, &decompress->FBO);
      _mesa_DeleteRenderbuffers(1, &decompress->RBO);
   }
d2942 1
a2942 1
static void
d2950 1
d2956 1
d2960 1
d2964 13
d2987 1
a2987 1
      return;
d2991 1
a2991 1
      return;
d3013 5
a3017 5
   if (decompress->FBO == 0) {
      _mesa_GenFramebuffers(1, &decompress->FBO);
      _mesa_GenRenderbuffers(1, &decompress->RBO);
      _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, decompress->FBO);
      _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, decompress->RBO);
d3021 1
a3021 1
                                       decompress->RBO);
d3024 1
a3024 1
      _mesa_BindFramebuffer(GL_FRAMEBUFFER_EXT, decompress->FBO);
d3028 14
a3041 6
   if (width > decompress->Width || height > decompress->Height) {
      _mesa_BindRenderbuffer(GL_RENDERBUFFER_EXT, decompress->RBO);
      _mesa_RenderbufferStorage(GL_RENDERBUFFER_EXT, GL_RGBA,
                                   width, height);
      decompress->Width = width;
      decompress->Height = height;
d3163 2
d3178 1
a3178 8
   /* We can only use the decompress-with-blit method here if the texels are
    * unsigned, normalized values.  We could handle signed and unnormalized 
    * with floating point renderbuffers...
    */
   if (_mesa_is_format_compressed(texImage->TexFormat) &&
       _mesa_get_format_datatype(texImage->TexFormat)
       == GL_UNSIGNED_NORMALIZED) {
      struct gl_texture_object *texObj = texImage->TexObject;
d3180 2
a3181 2
      /* Need to unlock the texture here to prevent deadlock... */
      _mesa_unlock_texture(ctx, texObj);
d3201 4
a3204 1
         decompress_texture_image(ctx, texImage, slice, format, type, dst);
d3206 3
a3208 5
      /* ... and relock it */
      _mesa_lock_texture(ctx, texObj);
   }
   else {
      _mesa_get_teximage(ctx, format, type, pixels, texImage);
d3210 2
d3338 185
@


