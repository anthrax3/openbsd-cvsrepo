head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.04.03;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.35;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.16.16;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.58;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.12.22;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.49.29;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#ifndef META_H
#define META_H

#include "main/mtypes.h"

/**
 * \name Flags for meta operations
 * \{
 *
 * These flags are passed to _mesa_meta_begin().
 */
#define MESA_META_ALL                      ~0x0
#define MESA_META_ALPHA_TEST                0x1
#define MESA_META_BLEND                     0x2  /**< includes logicop */
#define MESA_META_COLOR_MASK                0x4
#define MESA_META_DEPTH_TEST                0x8
#define MESA_META_FOG                      0x10
#define MESA_META_PIXEL_STORE              0x20
#define MESA_META_PIXEL_TRANSFER           0x40
#define MESA_META_RASTERIZATION            0x80
#define MESA_META_SCISSOR                 0x100
#define MESA_META_SHADER                  0x200
#define MESA_META_STENCIL_TEST            0x400
#define MESA_META_TRANSFORM               0x800 /**< modelview/projection matrix state */
#define MESA_META_TEXTURE                0x1000
#define MESA_META_VERTEX                 0x2000
#define MESA_META_VIEWPORT               0x4000
#define MESA_META_CLAMP_FRAGMENT_COLOR   0x8000
#define MESA_META_CLAMP_VERTEX_COLOR    0x10000
#define MESA_META_CONDITIONAL_RENDER    0x20000
#define MESA_META_CLIP                  0x40000
#define MESA_META_SELECT_FEEDBACK       0x80000
#define MESA_META_MULTISAMPLE          0x100000
#define MESA_META_FRAMEBUFFER_SRGB     0x200000
#define MESA_META_OCCLUSION_QUERY      0x400000
#define MESA_META_DRAW_BUFFERS         0x800000
/**\}*/

/**
 * State which we may save/restore across meta ops.
 * XXX this may be incomplete...
 */
struct save_state
{
   GLbitfield SavedState;  /**< bitmask of MESA_META_* flags */

   /* Always saved/restored with meta. */
   gl_api API;

   /** MESA_META_CLEAR (and others?) */
   struct gl_query_object *CurrentOcclusionObject;

   /** MESA_META_ALPHA_TEST */
   GLboolean AlphaEnabled;
   GLenum AlphaFunc;
   GLclampf AlphaRef;

   /** MESA_META_BLEND */
   GLbitfield BlendEnabled;
   GLboolean ColorLogicOpEnabled;

   /** MESA_META_COLOR_MASK */
   GLubyte ColorMask[MAX_DRAW_BUFFERS][4];

   /** MESA_META_DEPTH_TEST */
   struct gl_depthbuffer_attrib Depth;

   /** MESA_META_FOG */
   GLboolean Fog;

   /** MESA_META_PIXEL_STORE */
   struct gl_pixelstore_attrib Pack, Unpack;

   /** MESA_META_PIXEL_TRANSFER */
   GLfloat RedBias, RedScale;
   GLfloat GreenBias, GreenScale;
   GLfloat BlueBias, BlueScale;
   GLfloat AlphaBias, AlphaScale;
   GLfloat DepthBias, DepthScale;
   GLboolean MapColorFlag;

   /** MESA_META_RASTERIZATION */
   GLenum FrontPolygonMode, BackPolygonMode;
   GLboolean PolygonOffset;
   GLboolean PolygonSmooth;
   GLboolean PolygonStipple;
   GLboolean PolygonCull;

   /** MESA_META_SCISSOR */
   struct gl_scissor_attrib Scissor;

   /** MESA_META_SHADER */
   GLboolean VertexProgramEnabled;
   struct gl_vertex_program *VertexProgram;
   GLboolean FragmentProgramEnabled;
   struct gl_fragment_program *FragmentProgram;
   GLboolean ATIFragmentShaderEnabled;
   struct gl_shader_program *Shader[MESA_SHADER_STAGES];
   struct gl_shader_program *ActiveShader;
   struct gl_pipeline_object   *Pipeline;

   /** MESA_META_STENCIL_TEST */
   struct gl_stencil_attrib Stencil;

   /** MESA_META_TRANSFORM */
   GLenum MatrixMode;
   GLfloat ModelviewMatrix[16];
   GLfloat ProjectionMatrix[16];
   GLfloat TextureMatrix[16];

   /** MESA_META_CLIP */
   GLbitfield ClipPlanesEnabled;

   /** MESA_META_TEXTURE */
   GLuint ActiveUnit;
   GLuint ClientActiveUnit;
   /** for unit[0] only */
   struct gl_texture_object *CurrentTexture[NUM_TEXTURE_TARGETS];
   /** mask of TEXTURE_2D_BIT, etc */
   GLbitfield TexEnabled[MAX_TEXTURE_UNITS];
   GLbitfield TexGenEnabled[MAX_TEXTURE_UNITS];
   GLuint EnvMode;  /* unit[0] only */

   /** MESA_META_VERTEX */
   struct gl_vertex_array_object *VAO;
   struct gl_buffer_object *ArrayBufferObj;

   /** MESA_META_VIEWPORT */
   GLfloat ViewportX, ViewportY, ViewportW, ViewportH;
   GLclampd DepthNear, DepthFar;

   /** MESA_META_CLAMP_FRAGMENT_COLOR */
   GLenum ClampFragmentColor;

   /** MESA_META_CLAMP_VERTEX_COLOR */
   GLenum ClampVertexColor;

   /** MESA_META_CONDITIONAL_RENDER */
   struct gl_query_object *CondRenderQuery;
   GLenum CondRenderMode;

   /** MESA_META_SELECT_FEEDBACK */
   GLenum RenderMode;
   struct gl_selection Select;
   struct gl_feedback Feedback;

   /** MESA_META_MULTISAMPLE */
   struct gl_multisample_attrib Multisample;

   /** MESA_META_FRAMEBUFFER_SRGB */
   GLboolean sRGBEnabled;

   /** Miscellaneous (always disabled) */
   GLboolean Lighting;
   GLboolean RasterDiscard;
   GLboolean TransformFeedbackNeedsResume;

   GLuint DrawBufferName, ReadBufferName, RenderbufferName;

   /** MESA_META_DRAW_BUFFERS */
   GLenum ColorDrawBuffers[MAX_DRAW_BUFFERS];
};

/**
 * Temporary texture used for glBlitFramebuffer, glDrawPixels, etc.
 * This is currently shared by all the meta ops.  But we could create a
 * separate one for each of glDrawPixel, glBlitFramebuffer, glCopyPixels, etc.
 */
struct temp_texture
{
   GLuint TexObj;
   GLenum Target;         /**< GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE */
   GLsizei MinSize;       /**< Min texture size to allocate */
   GLsizei MaxSize;       /**< Max possible texture size */
   GLboolean NPOT;        /**< Non-power of two size OK? */
   GLsizei Width, Height; /**< Current texture size */
   GLenum IntFormat;
   GLfloat Sright, Ttop;  /**< right, top texcoords */
};

/**
 * State for GLSL texture sampler which is used to generate fragment
 * shader in _mesa_meta_generate_mipmap().
 */
struct blit_shader {
   const char *type;
   const char *func;
   const char *texcoords;
   GLuint shader_prog;
};

/**
 * Table of all sampler types and shaders for accessing them.
 */
struct blit_shader_table {
   struct blit_shader sampler_1d;
   struct blit_shader sampler_2d;
   struct blit_shader sampler_3d;
   struct blit_shader sampler_rect;
   struct blit_shader sampler_cubemap;
   struct blit_shader sampler_1d_array;
   struct blit_shader sampler_2d_array;
   struct blit_shader sampler_cubemap_array;
};

/**
 * Indices in the blit_state->msaa_shaders[] array
 *
 * Note that setup_glsl_msaa_blit_shader() assumes that the _INT enums are one
 * more than the non-_INT version and _UINT is one beyond that.
 */
enum blit_msaa_shader {
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_INT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_UINT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_COPY,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_COPY_INT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_COPY_UINT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_DEPTH_RESOLVE,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_DEPTH_COPY,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_INT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_UINT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_COPY,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_COPY_INT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_COPY_UINT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_DEPTH_RESOLVE,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_DEPTH_COPY,
   BLIT_MSAA_SHADER_COUNT,
};

/**
 * State for glBlitFramebufer()
 */
struct blit_state
{
   GLuint VAO;
   GLuint VBO;
   struct blit_shader_table shaders;
   GLuint msaa_shaders[BLIT_MSAA_SHADER_COUNT];
   struct temp_texture depthTex;
   bool no_ctsi_fallback;
};

struct fb_tex_blit_state
{
   GLint baseLevelSave, maxLevelSave;
   GLuint sampler, samplerSave, stencilSamplingSave;
   GLuint tempTex;
};


/**
 * State for glClear()
 */
struct clear_state
{
   GLuint VAO;
   GLuint VBO;
   GLuint ShaderProg;
   GLint ColorLocation;
   GLint LayerLocation;

   GLuint IntegerShaderProg;
   GLint IntegerColorLocation;
   GLint IntegerLayerLocation;
};


/**
 * State for glCopyPixels()
 */
struct copypix_state
{
   GLuint VAO;
   GLuint VBO;
};


/**
 * State for glDrawPixels()
 */
struct drawpix_state
{
   GLuint VAO;
   GLuint VBO;

   GLuint StencilFP;  /**< Fragment program for drawing stencil images */
   GLuint DepthFP;  /**< Fragment program for drawing depth images */
};


/**
 * State for glBitmap()
 */
struct bitmap_state
{
   GLuint VAO;
   GLuint VBO;
   struct temp_texture Tex;  /**< separate texture from other meta ops */
};

/**
 * State for _mesa_meta_generate_mipmap()
 */
struct gen_mipmap_state
{
   GLuint VAO;
   GLuint VBO;
   GLuint FBO;
   GLuint Sampler;

   struct blit_shader_table shaders;
};

/**
 * State for texture decompression
 */
struct decompress_state
{
   GLuint VAO;
   GLuint VBO, FBO, RBO, Sampler;
   GLint Width, Height;

   struct blit_shader_table shaders;
};

/**
 * State for glDrawTex()
 */
struct drawtex_state
{
   GLuint VAO;
   GLuint VBO;
};

#define MAX_META_OPS_DEPTH      8
/**
 * All per-context meta state.
 */
struct gl_meta_state
{
   /** Stack of state saved during meta-ops */
   struct save_state Save[MAX_META_OPS_DEPTH];
   /** Save stack depth */
   GLuint SaveStackDepth;

   struct temp_texture TempTex;

   struct blit_state Blit;    /**< For _mesa_meta_BlitFramebuffer() */
   struct clear_state Clear;  /**< For _mesa_meta_Clear() */
   struct copypix_state CopyPix;  /**< For _mesa_meta_CopyPixels() */
   struct drawpix_state DrawPix;  /**< For _mesa_meta_DrawPixels() */
   struct bitmap_state Bitmap;    /**< For _mesa_meta_Bitmap() */
   struct gen_mipmap_state Mipmap;    /**< For _mesa_meta_GenerateMipmap() */
   struct decompress_state Decompress;  /**< For texture decompression */
   struct drawtex_state DrawTex;  /**< For _mesa_meta_DrawTex() */
};

struct vertex {
   GLfloat x, y, z, tex[4];
   GLfloat r, g, b, a;
};

extern void
_mesa_meta_init(struct gl_context *ctx);

extern void
_mesa_meta_free(struct gl_context *ctx);

extern void
_mesa_meta_begin(struct gl_context *ctx, GLbitfield state);

extern void
_mesa_meta_end(struct gl_context *ctx);

extern GLboolean
_mesa_meta_in_progress(struct gl_context *ctx);

extern void
_mesa_meta_fb_tex_blit_begin(const struct gl_context *ctx,
                             struct fb_tex_blit_state *blit);

extern void
_mesa_meta_fb_tex_blit_end(struct gl_context *ctx, GLenum target,
                           struct fb_tex_blit_state *blit);

extern GLboolean
_mesa_meta_bind_rb_as_tex_image(struct gl_context *ctx,
                                struct gl_renderbuffer *rb,
                                GLuint *tex,
                                struct gl_texture_object **texObj,
                                GLenum *target);

GLuint
_mesa_meta_setup_sampler(struct gl_context *ctx,
                         const struct gl_texture_object *texObj,
                         GLenum target, GLenum filter, GLuint srcLevel);

extern GLbitfield
_mesa_meta_BlitFramebuffer(struct gl_context *ctx,
                           GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
                           GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
                           GLbitfield mask, GLenum filter);

extern void
_mesa_meta_and_swrast_BlitFramebuffer(struct gl_context *ctx,
                                      GLint srcX0, GLint srcY0,
                                      GLint srcX1, GLint srcY1,
                                      GLint dstX0, GLint dstY0,
                                      GLint dstX1, GLint dstY1,
                                      GLbitfield mask, GLenum filter);

extern void
_mesa_meta_Clear(struct gl_context *ctx, GLbitfield buffers);

extern void
_mesa_meta_glsl_Clear(struct gl_context *ctx, GLbitfield buffers);

extern void
_mesa_meta_CopyPixels(struct gl_context *ctx, GLint srcx, GLint srcy,
                      GLsizei width, GLsizei height,
                      GLint dstx, GLint dsty, GLenum type);

extern void
_mesa_meta_DrawPixels(struct gl_context *ctx,
                      GLint x, GLint y, GLsizei width, GLsizei height,
                      GLenum format, GLenum type,
                      const struct gl_pixelstore_attrib *unpack,
                      const GLvoid *pixels);

extern void
_mesa_meta_Bitmap(struct gl_context *ctx,
                  GLint x, GLint y, GLsizei width, GLsizei height,
                  const struct gl_pixelstore_attrib *unpack,
                  const GLubyte *bitmap);

extern void
_mesa_meta_GenerateMipmap(struct gl_context *ctx, GLenum target,
                          struct gl_texture_object *texObj);

extern void
_mesa_meta_CopyTexSubImage(struct gl_context *ctx, GLuint dims,
                           struct gl_texture_image *texImage,
                           GLint xoffset, GLint yoffset, GLint slice,
                           struct gl_renderbuffer *rb,
                           GLint x, GLint y,
                           GLsizei width, GLsizei height);

extern void
_mesa_meta_GetTexImage(struct gl_context *ctx,
                       GLenum format, GLenum type, GLvoid *pixels,
                       struct gl_texture_image *texImage);

extern void
_mesa_meta_DrawTex(struct gl_context *ctx, GLfloat x, GLfloat y, GLfloat z,
                   GLfloat width, GLfloat height);

/* meta-internal functions */
GLuint
_mesa_meta_compile_shader_with_debug(struct gl_context *ctx, GLenum target,
                                     const GLcharARB *source);


GLuint
_mesa_meta_link_program_with_debug(struct gl_context *ctx, GLuint program);

void
_mesa_meta_compile_and_link_program(struct gl_context *ctx,
                                    const char *vs_source,
                                    const char *fs_source,
                                    const char *name,
                                    GLuint *program);

GLboolean
_mesa_meta_alloc_texture(struct temp_texture *tex,
                         GLsizei width, GLsizei height, GLenum intFormat);

void
_mesa_meta_setup_texture_coords(GLenum faceTarget,
                                GLint slice,
                                GLint width,
                                GLint height,
                                GLint depth,
                                GLfloat coords0[4],
                                GLfloat coords1[4],
                                GLfloat coords2[4],
                                GLfloat coords3[4]);

struct temp_texture *
_mesa_meta_get_temp_texture(struct gl_context *ctx);

struct temp_texture *
_mesa_meta_get_temp_depth_texture(struct gl_context *ctx);

void
_mesa_meta_setup_vertex_objects(GLuint *VAO, GLuint *VBO,
                                bool use_generic_attributes,
                                unsigned vertex_size, unsigned texcoord_size,
                                unsigned color_size);

void
_mesa_meta_setup_ff_tnl_for_blit(GLuint *VAO, GLuint *VBO,
                                 unsigned texcoord_size);

void
_mesa_meta_setup_drawpix_texture(struct gl_context *ctx,
                                 struct temp_texture *tex,
                                 GLboolean newTex,
                                 GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels);

void
_mesa_meta_setup_copypix_texture(struct gl_context *ctx,
                                 struct temp_texture *tex,
                                 GLint srcX, GLint srcY,
                                 GLsizei width, GLsizei height,
                                 GLenum intFormat,
                                 GLenum filter);

void
_mesa_meta_setup_blit_shader(struct gl_context *ctx,
                             GLenum target,
                             struct blit_shader_table *table);

void
_mesa_meta_glsl_blit_cleanup(struct blit_state *blit);

void
_mesa_meta_blit_shader_table_cleanup(struct blit_shader_table *table);

void
_mesa_meta_glsl_generate_mipmap_cleanup(struct gen_mipmap_state *mipmap);

void
_mesa_meta_bind_fbo_image(GLenum attachment,
                          struct gl_texture_image *texImage, GLuint layer);

#endif /* META_H */
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a61 1
#define MESA_META_DITHER              0x1000000
a86 3
   /** MESA_META_DITHER */
   GLboolean DitherFlag;

a134 3
   /** GL_ARB_clip_control */
   GLenum ClipOrigin;     /**< GL_LOWER_LEFT or GL_UPPER_LEFT */
   GLenum ClipDepthMode;  /**< GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE */
d234 2
a235 2
 * Note that setup_glsl_msaa_blit_shader() assumes that the _INT enums are five
 * more than the corresponding non-_INT versions and _UINT are five beyond that.
d238 3
a240 15
   BLIT_1X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE,
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE,
   BLIT_16X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE,
   BLIT_1X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_INT,
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_INT,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_INT,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_INT,
   BLIT_16X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_INT,
   BLIT_1X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_UINT,
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_UINT,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_UINT,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_UINT,
   BLIT_16X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_UINT,
d246 3
a248 15
   BLIT_1X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE,
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE,
   BLIT_16X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE,
   BLIT_1X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_INT,
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_INT,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_INT,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_INT,
   BLIT_16X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_INT,
   BLIT_1X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_UINT,
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_UINT,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_UINT,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_UINT,
   BLIT_16X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_UINT,
a253 6
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_SCALED_RESOLVE,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_SCALED_RESOLVE,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_SCALED_RESOLVE,
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_SCALED_RESOLVE,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_SCALED_RESOLVE,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_SCALED_RESOLVE,
a341 10
 * One of the FBO states for decompress_state. There will be one for each
 * required renderbuffer format.
 */
struct decompress_fbo_state
{
   GLuint FBO, RBO;
   GLint Width, Height;
};

/**
d347 2
a348 2
   struct decompress_fbo_state byteFBO, floatFBO;
   GLuint VBO, Sampler;
a438 8
bool
_mesa_meta_CopyImageSubData_uncompressed(struct gl_context *ctx,
                                         struct gl_texture_image *src_tex_image,
                                         int src_x, int src_y, int src_z,
                                         struct gl_texture_image *dst_tex_image,
                                         int dst_x, int dst_y, int dst_z,
                                         int src_width, int src_height);

a475 7
_mesa_meta_ClearTexSubImage(struct gl_context *ctx,
                            struct gl_texture_image *texImage,
                            GLint xoffset, GLint yoffset, GLint zoffset,
                            GLsizei width, GLsizei height, GLsizei depth,
                            const GLvoid *clearValue);

extern void
a484 3
void
_mesa_meta_drawbuffers_from_bitfield(GLbitfield bits);

d562 1
a562 1
_mesa_meta_bind_fbo_image(GLenum target, GLenum attachment,
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d62 1
d88 3
d139 3
d241 2
a242 2
 * Note that setup_glsl_msaa_blit_shader() assumes that the _INT enums are one
 * more than the non-_INT version and _UINT is one beyond that.
d245 15
a259 3
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_INT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_UINT,
d265 15
a279 3
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_INT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_UINT,
d285 6
d379 10
d394 2
a395 2
   GLuint VBO, FBO, RBO, Sampler;
   GLint Width, Height;
d486 8
d531 7
d547 3
d627 1
a627 1
_mesa_meta_bind_fbo_image(GLenum attachment,
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d61 1
d64 326
d406 20
d432 8
a462 4
extern GLboolean
_mesa_meta_check_generate_mipmap_fallback(struct gl_context *ctx, GLenum target,
                                          struct gl_texture_object *texObj);

d483 81
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a2 1
 * Version:  7.6
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d29 33
d70 9
d88 3
d117 6
a122 30
_mesa_meta_CopyTexImage1D(struct gl_context *ctx, GLenum target, GLint level,
                          GLenum internalFormat, GLint x, GLint y,
                          GLsizei width, GLint border);

extern void
_mesa_meta_CopyTexImage2D(struct gl_context *ctx, GLenum target, GLint level,
                          GLenum internalFormat, GLint x, GLint y,
                          GLsizei width, GLsizei height, GLint border);

extern void
_mesa_meta_CopyTexSubImage1D(struct gl_context *ctx, GLenum target, GLint level,
                             GLint xoffset,
                             GLint x, GLint y, GLsizei width);

extern void
_mesa_meta_CopyTexSubImage2D(struct gl_context *ctx, GLenum target, GLint level,
                             GLint xoffset, GLint yoffset,
                             GLint x, GLint y,
                             GLsizei width, GLsizei height);

extern void
_mesa_meta_CopyTexSubImage3D(struct gl_context *ctx, GLenum target, GLint level,
                             GLint xoffset, GLint yoffset, GLint zoffset,
                             GLint x, GLint y,
                             GLsizei width, GLsizei height);

extern void
_mesa_meta_CopyColorTable(struct gl_context *ctx,
                          GLenum target, GLenum internalformat,
                          GLint x, GLint y, GLsizei width);
d125 3
a127 2
_mesa_meta_CopyColorSubTable(struct gl_context *ctx,GLenum target, GLsizei start,
                             GLint x, GLint y, GLsizei width);
d130 2
a131 9
_mesa_meta_CopyConvolutionFilter1D(struct gl_context *ctx, GLenum target,
                                   GLenum internalFormat,
                                   GLint x, GLint y, GLsizei width);

extern void
_mesa_meta_CopyConvolutionFilter2D(struct gl_context *ctx, GLenum target,
                                   GLenum internalFormat, GLint x, GLint y,
                                   GLsizei width, GLsizei height);

@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d31 1
a31 1
_mesa_meta_init(GLcontext *ctx);
d34 1
a34 1
_mesa_meta_free(GLcontext *ctx);
d37 1
a37 1
_mesa_meta_BlitFramebuffer(GLcontext *ctx,
d43 1
a43 1
_mesa_meta_Clear(GLcontext *ctx, GLbitfield buffers);
d46 1
a46 1
_mesa_meta_CopyPixels(GLcontext *ctx, GLint srcx, GLint srcy,
d51 1
a51 1
_mesa_meta_DrawPixels(GLcontext *ctx,
d58 1
a58 1
_mesa_meta_Bitmap(GLcontext *ctx,
d64 1
a64 1
_mesa_meta_check_generate_mipmap_fallback(GLcontext *ctx, GLenum target,
d68 1
a68 1
_mesa_meta_GenerateMipmap(GLcontext *ctx, GLenum target,
d72 1
a72 1
_mesa_meta_CopyTexImage1D(GLcontext *ctx, GLenum target, GLint level,
d77 1
a77 1
_mesa_meta_CopyTexImage2D(GLcontext *ctx, GLenum target, GLint level,
d82 1
a82 1
_mesa_meta_CopyTexSubImage1D(GLcontext *ctx, GLenum target, GLint level,
d87 1
a87 1
_mesa_meta_CopyTexSubImage2D(GLcontext *ctx, GLenum target, GLint level,
d93 1
a93 1
_mesa_meta_CopyTexSubImage3D(GLcontext *ctx, GLenum target, GLint level,
d99 1
a99 1
_mesa_meta_CopyColorTable(GLcontext *ctx,
d104 1
a104 1
_mesa_meta_CopyColorSubTable(GLcontext *ctx,GLenum target, GLsizei start,
d108 1
a108 1
_mesa_meta_CopyConvolutionFilter1D(GLcontext *ctx, GLenum target,
d113 1
a113 1
_mesa_meta_CopyConvolutionFilter2D(GLcontext *ctx, GLenum target,
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d31 1
a31 1
_mesa_meta_init(struct gl_context *ctx);
d34 1
a34 1
_mesa_meta_free(struct gl_context *ctx);
d37 1
a37 1
_mesa_meta_BlitFramebuffer(struct gl_context *ctx,
d43 1
a43 1
_mesa_meta_Clear(struct gl_context *ctx, GLbitfield buffers);
d46 1
a46 1
_mesa_meta_CopyPixels(struct gl_context *ctx, GLint srcx, GLint srcy,
d51 1
a51 1
_mesa_meta_DrawPixels(struct gl_context *ctx,
d58 1
a58 1
_mesa_meta_Bitmap(struct gl_context *ctx,
d64 1
a64 1
_mesa_meta_check_generate_mipmap_fallback(struct gl_context *ctx, GLenum target,
d68 1
a68 1
_mesa_meta_GenerateMipmap(struct gl_context *ctx, GLenum target,
d72 1
a72 1
_mesa_meta_CopyTexImage1D(struct gl_context *ctx, GLenum target, GLint level,
d77 1
a77 1
_mesa_meta_CopyTexImage2D(struct gl_context *ctx, GLenum target, GLint level,
d82 1
a82 1
_mesa_meta_CopyTexSubImage1D(struct gl_context *ctx, GLenum target, GLint level,
d87 1
a87 1
_mesa_meta_CopyTexSubImage2D(struct gl_context *ctx, GLenum target, GLint level,
d93 1
a93 1
_mesa_meta_CopyTexSubImage3D(struct gl_context *ctx, GLenum target, GLint level,
d99 1
a99 1
_mesa_meta_CopyColorTable(struct gl_context *ctx,
d104 1
a104 1
_mesa_meta_CopyColorSubTable(struct gl_context *ctx,GLenum target, GLsizei start,
d108 1
a108 1
_mesa_meta_CopyConvolutionFilter1D(struct gl_context *ctx, GLenum target,
d113 1
a113 1
_mesa_meta_CopyConvolutionFilter2D(struct gl_context *ctx, GLenum target,
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a28 33
#include "main/mtypes.h"

/**
 * \name Flags for meta operations
 * \{
 *
 * These flags are passed to _mesa_meta_begin().
 */
#define MESA_META_ALL                      ~0x0
#define MESA_META_ALPHA_TEST                0x1
#define MESA_META_BLEND                     0x2  /**< includes logicop */
#define MESA_META_COLOR_MASK                0x4
#define MESA_META_DEPTH_TEST                0x8
#define MESA_META_FOG                      0x10
#define MESA_META_PIXEL_STORE              0x20
#define MESA_META_PIXEL_TRANSFER           0x40
#define MESA_META_RASTERIZATION            0x80
#define MESA_META_SCISSOR                 0x100
#define MESA_META_SHADER                  0x200
#define MESA_META_STENCIL_TEST            0x400
#define MESA_META_TRANSFORM               0x800 /**< modelview/projection matrix state */
#define MESA_META_TEXTURE                0x1000
#define MESA_META_VERTEX                 0x2000
#define MESA_META_VIEWPORT               0x4000
#define MESA_META_CLAMP_FRAGMENT_COLOR   0x8000
#define MESA_META_CLAMP_VERTEX_COLOR    0x10000
#define MESA_META_CONDITIONAL_RENDER    0x20000
#define MESA_META_CLIP                  0x40000
#define MESA_META_SELECT_FEEDBACK       0x80000
#define MESA_META_MULTISAMPLE          0x100000
#define MESA_META_FRAMEBUFFER_SRGB     0x200000
#define MESA_META_OCCLUSION_QUERY      0x400000
/**\}*/
a36 9
_mesa_meta_begin(struct gl_context *ctx, GLbitfield state);

extern void
_mesa_meta_end(struct gl_context *ctx);

extern GLboolean
_mesa_meta_in_progress(struct gl_context *ctx);

extern void
a45 3
_mesa_meta_glsl_Clear(struct gl_context *ctx, GLbitfield buffers);

extern void
d72 30
a101 6
_mesa_meta_CopyTexSubImage(struct gl_context *ctx, GLuint dims,
                           struct gl_texture_image *texImage,
                           GLint xoffset, GLint yoffset, GLint slice,
                           struct gl_renderbuffer *rb,
                           GLint x, GLint y,
                           GLsizei width, GLsizei height);
d104 2
a105 3
_mesa_meta_GetTexImage(struct gl_context *ctx,
                       GLenum format, GLenum type, GLvoid *pixels,
                       struct gl_texture_image *texImage);
d108 9
a116 2
_mesa_meta_DrawTex(struct gl_context *ctx, GLfloat x, GLfloat y, GLfloat z,
                   GLfloat width, GLfloat height);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a60 1
#define MESA_META_DRAW_BUFFERS         0x800000
a62 326
/**
 * State which we may save/restore across meta ops.
 * XXX this may be incomplete...
 */
struct save_state
{
   GLbitfield SavedState;  /**< bitmask of MESA_META_* flags */

   /* Always saved/restored with meta. */
   gl_api API;

   /** MESA_META_CLEAR (and others?) */
   struct gl_query_object *CurrentOcclusionObject;

   /** MESA_META_ALPHA_TEST */
   GLboolean AlphaEnabled;
   GLenum AlphaFunc;
   GLclampf AlphaRef;

   /** MESA_META_BLEND */
   GLbitfield BlendEnabled;
   GLboolean ColorLogicOpEnabled;

   /** MESA_META_COLOR_MASK */
   GLubyte ColorMask[MAX_DRAW_BUFFERS][4];

   /** MESA_META_DEPTH_TEST */
   struct gl_depthbuffer_attrib Depth;

   /** MESA_META_FOG */
   GLboolean Fog;

   /** MESA_META_PIXEL_STORE */
   struct gl_pixelstore_attrib Pack, Unpack;

   /** MESA_META_PIXEL_TRANSFER */
   GLfloat RedBias, RedScale;
   GLfloat GreenBias, GreenScale;
   GLfloat BlueBias, BlueScale;
   GLfloat AlphaBias, AlphaScale;
   GLfloat DepthBias, DepthScale;
   GLboolean MapColorFlag;

   /** MESA_META_RASTERIZATION */
   GLenum FrontPolygonMode, BackPolygonMode;
   GLboolean PolygonOffset;
   GLboolean PolygonSmooth;
   GLboolean PolygonStipple;
   GLboolean PolygonCull;

   /** MESA_META_SCISSOR */
   struct gl_scissor_attrib Scissor;

   /** MESA_META_SHADER */
   GLboolean VertexProgramEnabled;
   struct gl_vertex_program *VertexProgram;
   GLboolean FragmentProgramEnabled;
   struct gl_fragment_program *FragmentProgram;
   GLboolean ATIFragmentShaderEnabled;
   struct gl_shader_program *Shader[MESA_SHADER_STAGES];
   struct gl_shader_program *ActiveShader;
   struct gl_pipeline_object   *Pipeline;

   /** MESA_META_STENCIL_TEST */
   struct gl_stencil_attrib Stencil;

   /** MESA_META_TRANSFORM */
   GLenum MatrixMode;
   GLfloat ModelviewMatrix[16];
   GLfloat ProjectionMatrix[16];
   GLfloat TextureMatrix[16];

   /** MESA_META_CLIP */
   GLbitfield ClipPlanesEnabled;

   /** MESA_META_TEXTURE */
   GLuint ActiveUnit;
   GLuint ClientActiveUnit;
   /** for unit[0] only */
   struct gl_texture_object *CurrentTexture[NUM_TEXTURE_TARGETS];
   /** mask of TEXTURE_2D_BIT, etc */
   GLbitfield TexEnabled[MAX_TEXTURE_UNITS];
   GLbitfield TexGenEnabled[MAX_TEXTURE_UNITS];
   GLuint EnvMode;  /* unit[0] only */

   /** MESA_META_VERTEX */
   struct gl_vertex_array_object *VAO;
   struct gl_buffer_object *ArrayBufferObj;

   /** MESA_META_VIEWPORT */
   GLfloat ViewportX, ViewportY, ViewportW, ViewportH;
   GLclampd DepthNear, DepthFar;

   /** MESA_META_CLAMP_FRAGMENT_COLOR */
   GLenum ClampFragmentColor;

   /** MESA_META_CLAMP_VERTEX_COLOR */
   GLenum ClampVertexColor;

   /** MESA_META_CONDITIONAL_RENDER */
   struct gl_query_object *CondRenderQuery;
   GLenum CondRenderMode;

   /** MESA_META_SELECT_FEEDBACK */
   GLenum RenderMode;
   struct gl_selection Select;
   struct gl_feedback Feedback;

   /** MESA_META_MULTISAMPLE */
   struct gl_multisample_attrib Multisample;

   /** MESA_META_FRAMEBUFFER_SRGB */
   GLboolean sRGBEnabled;

   /** Miscellaneous (always disabled) */
   GLboolean Lighting;
   GLboolean RasterDiscard;
   GLboolean TransformFeedbackNeedsResume;

   GLuint DrawBufferName, ReadBufferName, RenderbufferName;

   /** MESA_META_DRAW_BUFFERS */
   GLenum ColorDrawBuffers[MAX_DRAW_BUFFERS];
};

/**
 * Temporary texture used for glBlitFramebuffer, glDrawPixels, etc.
 * This is currently shared by all the meta ops.  But we could create a
 * separate one for each of glDrawPixel, glBlitFramebuffer, glCopyPixels, etc.
 */
struct temp_texture
{
   GLuint TexObj;
   GLenum Target;         /**< GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE */
   GLsizei MinSize;       /**< Min texture size to allocate */
   GLsizei MaxSize;       /**< Max possible texture size */
   GLboolean NPOT;        /**< Non-power of two size OK? */
   GLsizei Width, Height; /**< Current texture size */
   GLenum IntFormat;
   GLfloat Sright, Ttop;  /**< right, top texcoords */
};

/**
 * State for GLSL texture sampler which is used to generate fragment
 * shader in _mesa_meta_generate_mipmap().
 */
struct blit_shader {
   const char *type;
   const char *func;
   const char *texcoords;
   GLuint shader_prog;
};

/**
 * Table of all sampler types and shaders for accessing them.
 */
struct blit_shader_table {
   struct blit_shader sampler_1d;
   struct blit_shader sampler_2d;
   struct blit_shader sampler_3d;
   struct blit_shader sampler_rect;
   struct blit_shader sampler_cubemap;
   struct blit_shader sampler_1d_array;
   struct blit_shader sampler_2d_array;
   struct blit_shader sampler_cubemap_array;
};

/**
 * Indices in the blit_state->msaa_shaders[] array
 *
 * Note that setup_glsl_msaa_blit_shader() assumes that the _INT enums are one
 * more than the non-_INT version and _UINT is one beyond that.
 */
enum blit_msaa_shader {
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_INT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_UINT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_COPY,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_COPY_INT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_COPY_UINT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_DEPTH_RESOLVE,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_DEPTH_COPY,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_INT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_UINT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_COPY,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_COPY_INT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_COPY_UINT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_DEPTH_RESOLVE,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_DEPTH_COPY,
   BLIT_MSAA_SHADER_COUNT,
};

/**
 * State for glBlitFramebufer()
 */
struct blit_state
{
   GLuint VAO;
   GLuint VBO;
   struct blit_shader_table shaders;
   GLuint msaa_shaders[BLIT_MSAA_SHADER_COUNT];
   struct temp_texture depthTex;
   bool no_ctsi_fallback;
};

struct fb_tex_blit_state
{
   GLint baseLevelSave, maxLevelSave;
   GLuint sampler, samplerSave, stencilSamplingSave;
   GLuint tempTex;
};


/**
 * State for glClear()
 */
struct clear_state
{
   GLuint VAO;
   GLuint VBO;
   GLuint ShaderProg;
   GLint ColorLocation;
   GLint LayerLocation;

   GLuint IntegerShaderProg;
   GLint IntegerColorLocation;
   GLint IntegerLayerLocation;
};


/**
 * State for glCopyPixels()
 */
struct copypix_state
{
   GLuint VAO;
   GLuint VBO;
};


/**
 * State for glDrawPixels()
 */
struct drawpix_state
{
   GLuint VAO;
   GLuint VBO;

   GLuint StencilFP;  /**< Fragment program for drawing stencil images */
   GLuint DepthFP;  /**< Fragment program for drawing depth images */
};


/**
 * State for glBitmap()
 */
struct bitmap_state
{
   GLuint VAO;
   GLuint VBO;
   struct temp_texture Tex;  /**< separate texture from other meta ops */
};

/**
 * State for _mesa_meta_generate_mipmap()
 */
struct gen_mipmap_state
{
   GLuint VAO;
   GLuint VBO;
   GLuint FBO;
   GLuint Sampler;

   struct blit_shader_table shaders;
};

/**
 * State for texture decompression
 */
struct decompress_state
{
   GLuint VAO;
   GLuint VBO, FBO, RBO, Sampler;
   GLint Width, Height;

   struct blit_shader_table shaders;
};

/**
 * State for glDrawTex()
 */
struct drawtex_state
{
   GLuint VAO;
   GLuint VBO;
};

#define MAX_META_OPS_DEPTH      8
/**
 * All per-context meta state.
 */
struct gl_meta_state
{
   /** Stack of state saved during meta-ops */
   struct save_state Save[MAX_META_OPS_DEPTH];
   /** Save stack depth */
   GLuint SaveStackDepth;

   struct temp_texture TempTex;

   struct blit_state Blit;    /**< For _mesa_meta_BlitFramebuffer() */
   struct clear_state Clear;  /**< For _mesa_meta_Clear() */
   struct copypix_state CopyPix;  /**< For _mesa_meta_CopyPixels() */
   struct drawpix_state DrawPix;  /**< For _mesa_meta_DrawPixels() */
   struct bitmap_state Bitmap;    /**< For _mesa_meta_Bitmap() */
   struct gen_mipmap_state Mipmap;    /**< For _mesa_meta_GenerateMipmap() */
   struct decompress_state Decompress;  /**< For texture decompression */
   struct drawtex_state DrawTex;  /**< For _mesa_meta_DrawTex() */
};

struct vertex {
   GLfloat x, y, z, tex[4];
   GLfloat r, g, b, a;
};

a78 20
_mesa_meta_fb_tex_blit_begin(const struct gl_context *ctx,
                             struct fb_tex_blit_state *blit);

extern void
_mesa_meta_fb_tex_blit_end(struct gl_context *ctx, GLenum target,
                           struct fb_tex_blit_state *blit);

extern GLboolean
_mesa_meta_bind_rb_as_tex_image(struct gl_context *ctx,
                                struct gl_renderbuffer *rb,
                                GLuint *tex,
                                struct gl_texture_object **texObj,
                                GLenum *target);

GLuint
_mesa_meta_setup_sampler(struct gl_context *ctx,
                         const struct gl_texture_object *texObj,
                         GLenum target, GLenum filter, GLuint srcLevel);

extern GLbitfield
a84 8
_mesa_meta_and_swrast_BlitFramebuffer(struct gl_context *ctx,
                                      GLint srcX0, GLint srcY0,
                                      GLint srcX1, GLint srcY1,
                                      GLint dstX0, GLint dstY0,
                                      GLint dstX1, GLint dstY1,
                                      GLbitfield mask, GLenum filter);

extern void
d108 4
a131 81

/* meta-internal functions */
GLuint
_mesa_meta_compile_shader_with_debug(struct gl_context *ctx, GLenum target,
                                     const GLcharARB *source);


GLuint
_mesa_meta_link_program_with_debug(struct gl_context *ctx, GLuint program);

void
_mesa_meta_compile_and_link_program(struct gl_context *ctx,
                                    const char *vs_source,
                                    const char *fs_source,
                                    const char *name,
                                    GLuint *program);

GLboolean
_mesa_meta_alloc_texture(struct temp_texture *tex,
                         GLsizei width, GLsizei height, GLenum intFormat);

void
_mesa_meta_setup_texture_coords(GLenum faceTarget,
                                GLint slice,
                                GLint width,
                                GLint height,
                                GLint depth,
                                GLfloat coords0[4],
                                GLfloat coords1[4],
                                GLfloat coords2[4],
                                GLfloat coords3[4]);

struct temp_texture *
_mesa_meta_get_temp_texture(struct gl_context *ctx);

struct temp_texture *
_mesa_meta_get_temp_depth_texture(struct gl_context *ctx);

void
_mesa_meta_setup_vertex_objects(GLuint *VAO, GLuint *VBO,
                                bool use_generic_attributes,
                                unsigned vertex_size, unsigned texcoord_size,
                                unsigned color_size);

void
_mesa_meta_setup_ff_tnl_for_blit(GLuint *VAO, GLuint *VBO,
                                 unsigned texcoord_size);

void
_mesa_meta_setup_drawpix_texture(struct gl_context *ctx,
                                 struct temp_texture *tex,
                                 GLboolean newTex,
                                 GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels);

void
_mesa_meta_setup_copypix_texture(struct gl_context *ctx,
                                 struct temp_texture *tex,
                                 GLint srcX, GLint srcY,
                                 GLsizei width, GLsizei height,
                                 GLenum intFormat,
                                 GLenum filter);

void
_mesa_meta_setup_blit_shader(struct gl_context *ctx,
                             GLenum target,
                             struct blit_shader_table *table);

void
_mesa_meta_glsl_blit_cleanup(struct blit_state *blit);

void
_mesa_meta_blit_shader_table_cleanup(struct blit_shader_table *table);

void
_mesa_meta_glsl_generate_mipmap_cleanup(struct gen_mipmap_state *mipmap);

void
_mesa_meta_bind_fbo_image(GLenum attachment,
                          struct gl_texture_image *texImage, GLuint layer);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a61 1
#define MESA_META_DITHER              0x1000000
a86 3
   /** MESA_META_DITHER */
   GLboolean DitherFlag;

a134 3
   /** GL_ARB_clip_control */
   GLenum ClipOrigin;     /**< GL_LOWER_LEFT or GL_UPPER_LEFT */
   GLenum ClipDepthMode;  /**< GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE */
d234 2
a235 2
 * Note that setup_glsl_msaa_blit_shader() assumes that the _INT enums are five
 * more than the corresponding non-_INT versions and _UINT are five beyond that.
d238 3
a240 15
   BLIT_1X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE,
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE,
   BLIT_16X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE,
   BLIT_1X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_INT,
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_INT,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_INT,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_INT,
   BLIT_16X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_INT,
   BLIT_1X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_UINT,
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_UINT,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_UINT,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_UINT,
   BLIT_16X_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_UINT,
d246 3
a248 15
   BLIT_1X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE,
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE,
   BLIT_16X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE,
   BLIT_1X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_INT,
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_INT,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_INT,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_INT,
   BLIT_16X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_INT,
   BLIT_1X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_UINT,
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_UINT,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_UINT,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_UINT,
   BLIT_16X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_UINT,
a253 6
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_SCALED_RESOLVE,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_SCALED_RESOLVE,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_SCALED_RESOLVE,
   BLIT_2X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_SCALED_RESOLVE,
   BLIT_4X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_SCALED_RESOLVE,
   BLIT_8X_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_SCALED_RESOLVE,
a341 10
 * One of the FBO states for decompress_state. There will be one for each
 * required renderbuffer format.
 */
struct decompress_fbo_state
{
   GLuint FBO, RBO;
   GLint Width, Height;
};

/**
d347 2
a348 2
   struct decompress_fbo_state byteFBO, floatFBO;
   GLuint VBO, Sampler;
a438 8
bool
_mesa_meta_CopyImageSubData_uncompressed(struct gl_context *ctx,
                                         struct gl_texture_image *src_tex_image,
                                         int src_x, int src_y, int src_z,
                                         struct gl_texture_image *dst_tex_image,
                                         int dst_x, int dst_y, int dst_z,
                                         int src_width, int src_height);

a475 7
_mesa_meta_ClearTexSubImage(struct gl_context *ctx,
                            struct gl_texture_image *texImage,
                            GLint xoffset, GLint yoffset, GLint zoffset,
                            GLsizei width, GLsizei height, GLsizei depth,
                            const GLvoid *clearValue);

extern void
a484 3
void
_mesa_meta_drawbuffers_from_bitfield(GLbitfield bits);

d562 1
a562 1
_mesa_meta_bind_fbo_image(GLenum target, GLenum attachment,
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d62 1
d88 3
d139 3
d241 2
a242 2
 * Note that setup_glsl_msaa_blit_shader() assumes that the _INT enums are one
 * more than the non-_INT version and _UINT is one beyond that.
d245 15
a259 3
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_INT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_RESOLVE_UINT,
d265 15
a279 3
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_INT,
   BLIT_MSAA_SHADER_2D_MULTISAMPLE_ARRAY_RESOLVE_UINT,
d285 6
d379 10
d394 2
a395 2
   GLuint VBO, FBO, RBO, Sampler;
   GLint Width, Height;
d486 8
d531 7
d547 3
d627 1
a627 1
_mesa_meta_bind_fbo_image(GLenum attachment,
@


