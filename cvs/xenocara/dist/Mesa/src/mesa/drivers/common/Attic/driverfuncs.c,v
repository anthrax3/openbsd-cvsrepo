head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.04.02;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.16;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.47;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.51.40;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.51.40;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.56.55;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.27.42;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.35;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.14;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.57;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.12.21;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.49.28;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "main/glheader.h"
#include "main/imports.h"
#include "main/accum.h"
#include "main/arrayobj.h"
#include "main/context.h"
#include "main/formatquery.h"
#include "main/framebuffer.h"
#include "main/mipmap.h"
#include "main/queryobj.h"
#include "main/readpix.h"
#include "main/renderbuffer.h"
#include "main/shaderobj.h"
#include "main/texcompress.h"
#include "main/texformat.h"
#include "main/texgetimage.h"
#include "main/teximage.h"
#include "main/texobj.h"
#include "main/texstorage.h"
#include "main/texstore.h"
#include "main/bufferobj.h"
#include "main/fbobject.h"
#include "main/samplerobj.h"
#include "main/syncobj.h"
#include "main/texturebarrier.h"
#include "main/transformfeedback.h"

#include "program/program.h"
#include "tnl/tnl.h"
#include "swrast/swrast.h"
#include "swrast/s_renderbuffer.h"

#include "driverfuncs.h"
#include "meta.h"



/**
 * Plug in default functions for all pointers in the dd_function_table
 * structure.
 * Device drivers should call this function and then plug in any
 * functions which it wants to override.
 * Some functions (pointers) MUST be implemented by all drivers (REQUIRED).
 *
 * \param table the dd_function_table to initialize
 */
void
_mesa_init_driver_functions(struct dd_function_table *driver)
{
   memset(driver, 0, sizeof(*driver));

   driver->GetString = NULL;  /* REQUIRED! */
   driver->UpdateState = NULL;  /* REQUIRED! */
   driver->ResizeBuffers = _mesa_resize_framebuffer;

   driver->Finish = NULL;
   driver->Flush = NULL;

   /* framebuffer/image functions */
   driver->Clear = _swrast_Clear;
   driver->Accum = _mesa_accum;
   driver->RasterPos = _tnl_RasterPos;
   driver->DrawPixels = _swrast_DrawPixels;
   driver->ReadPixels = _mesa_readpixels;
   driver->CopyPixels = _swrast_CopyPixels;
   driver->Bitmap = _swrast_Bitmap;

   /* Texture functions */
   driver->ChooseTextureFormat = _mesa_choose_tex_format;
   driver->QuerySamplesForFormat = _mesa_query_samples_for_format;
   driver->TexImage = _mesa_store_teximage;
   driver->TexSubImage = _mesa_store_texsubimage;
   driver->GetTexImage = _mesa_meta_GetTexImage;
   driver->CopyTexSubImage = _mesa_meta_CopyTexSubImage;
   driver->GenerateMipmap = _mesa_meta_GenerateMipmap;
   driver->TestProxyTexImage = _mesa_test_proxy_teximage;
   driver->CompressedTexImage = _mesa_store_compressed_teximage;
   driver->CompressedTexSubImage = _mesa_store_compressed_texsubimage;
   driver->GetCompressedTexImage = _mesa_get_compressed_teximage;
   driver->BindTexture = NULL;
   driver->NewTextureObject = _mesa_new_texture_object;
   driver->DeleteTexture = _mesa_delete_texture_object;
   driver->NewTextureImage = _swrast_new_texture_image;
   driver->DeleteTextureImage = _swrast_delete_texture_image;
   driver->AllocTextureImageBuffer = _swrast_alloc_texture_image_buffer;
   driver->FreeTextureImageBuffer = _swrast_free_texture_image_buffer;
   driver->MapTextureImage = _swrast_map_teximage;
   driver->UnmapTextureImage = _swrast_unmap_teximage;
   driver->DrawTex = _mesa_meta_DrawTex;

   /* Vertex/fragment programs */
   driver->BindProgram = NULL;
   driver->NewProgram = _mesa_new_program;
   driver->DeleteProgram = _mesa_delete_program;

   /* simple state commands */
   driver->AlphaFunc = NULL;
   driver->BlendColor = NULL;
   driver->BlendEquationSeparate = NULL;
   driver->BlendFuncSeparate = NULL;
   driver->ClipPlane = NULL;
   driver->ColorMask = NULL;
   driver->ColorMaterial = NULL;
   driver->CullFace = NULL;
   driver->DrawBuffer = NULL;
   driver->DrawBuffers = NULL;
   driver->FrontFace = NULL;
   driver->DepthFunc = NULL;
   driver->DepthMask = NULL;
   driver->DepthRange = NULL;
   driver->Enable = NULL;
   driver->Fogfv = NULL;
   driver->Hint = NULL;
   driver->Lightfv = NULL;
   driver->LightModelfv = NULL;
   driver->LineStipple = NULL;
   driver->LineWidth = NULL;
   driver->LogicOpcode = NULL;
   driver->PointParameterfv = NULL;
   driver->PointSize = NULL;
   driver->PolygonMode = NULL;
   driver->PolygonOffset = NULL;
   driver->PolygonStipple = NULL;
   driver->ReadBuffer = NULL;
   driver->RenderMode = NULL;
   driver->Scissor = NULL;
   driver->ShadeModel = NULL;
   driver->StencilFuncSeparate = NULL;
   driver->StencilOpSeparate = NULL;
   driver->StencilMaskSeparate = NULL;
   driver->TexGen = NULL;
   driver->TexEnv = NULL;
   driver->TexParameter = NULL;
   driver->Viewport = NULL;

   /* buffer objects */
   _mesa_init_buffer_object_functions(driver);

   /* query objects */
   _mesa_init_query_object_functions(driver);

   _mesa_init_sync_object_functions(driver);

   driver->NewFramebuffer = _mesa_new_framebuffer;
   driver->NewRenderbuffer = _swrast_new_soft_renderbuffer;
   driver->MapRenderbuffer = _swrast_map_soft_renderbuffer;
   driver->UnmapRenderbuffer = _swrast_unmap_soft_renderbuffer;
   driver->RenderTexture = _swrast_render_texture;
   driver->FinishRenderTexture = _swrast_finish_render_texture;
   driver->FramebufferRenderbuffer = _mesa_framebuffer_renderbuffer;
   driver->ValidateFramebuffer = _mesa_validate_framebuffer;

   driver->BlitFramebuffer = _swrast_BlitFramebuffer;
   driver->DiscardFramebuffer = NULL;

   _mesa_init_texture_barrier_functions(driver);

   /* APPLE_vertex_array_object */
   driver->NewArrayObject = _mesa_new_vao;
   driver->DeleteArrayObject = _mesa_delete_vao;
   driver->BindArrayObject = NULL;

   _mesa_init_shader_object_functions(driver);

   _mesa_init_transform_feedback_functions(driver);

   _mesa_init_sampler_object_functions(driver);

   /* T&L stuff */
   driver->CurrentExecPrimitive = 0;
   driver->CurrentSavePrimitive = 0;
   driver->NeedFlush = 0;
   driver->SaveNeedFlush = 0;

   driver->ProgramStringNotify = _tnl_program_string;
   driver->FlushVertices = NULL;
   driver->SaveFlushVertices = NULL;
   driver->NotifySaveBegin = NULL;
   driver->LightingSpaceChange = NULL;

   /* display list */
   driver->NewList = NULL;
   driver->EndList = NULL;
   driver->BeginCallList = NULL;
   driver->EndCallList = NULL;

   /* GL_ARB_texture_storage */
   driver->AllocTextureStorage = _mesa_alloc_texture_storage;

   /* GL_ARB_texture_view */
   driver->TextureView = NULL;

   /* GL_ARB_texture_multisample */
   driver->GetSamplePosition = NULL;
}


/**
 * Call the ctx->Driver.* state functions with current values to initialize
 * driver state.
 * Only the Intel drivers use this so far.
 */
void
_mesa_init_driver_state(struct gl_context *ctx)
{
   ctx->Driver.AlphaFunc(ctx, ctx->Color.AlphaFunc, ctx->Color.AlphaRef);

   ctx->Driver.BlendColor(ctx, ctx->Color.BlendColor);

   ctx->Driver.BlendEquationSeparate(ctx,
                                     ctx->Color.Blend[0].EquationRGB,
                                     ctx->Color.Blend[0].EquationA);

   ctx->Driver.BlendFuncSeparate(ctx,
                                 ctx->Color.Blend[0].SrcRGB,
                                 ctx->Color.Blend[0].DstRGB,
                                 ctx->Color.Blend[0].SrcA,
                                 ctx->Color.Blend[0].DstA);

   if (ctx->Driver.ColorMaskIndexed) {
      GLuint i;
      for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
         ctx->Driver.ColorMaskIndexed(ctx, i,
                                      ctx->Color.ColorMask[i][RCOMP],
                                      ctx->Color.ColorMask[i][GCOMP],
                                      ctx->Color.ColorMask[i][BCOMP],
                                      ctx->Color.ColorMask[i][ACOMP]);
      }
   }
   else {
      ctx->Driver.ColorMask(ctx,
                            ctx->Color.ColorMask[0][RCOMP],
                            ctx->Color.ColorMask[0][GCOMP],
                            ctx->Color.ColorMask[0][BCOMP],
                            ctx->Color.ColorMask[0][ACOMP]);
   }

   ctx->Driver.CullFace(ctx, ctx->Polygon.CullFaceMode);
   ctx->Driver.DepthFunc(ctx, ctx->Depth.Func);
   ctx->Driver.DepthMask(ctx, ctx->Depth.Mask);

   ctx->Driver.Enable(ctx, GL_ALPHA_TEST, ctx->Color.AlphaEnabled);
   ctx->Driver.Enable(ctx, GL_BLEND, ctx->Color.BlendEnabled);
   ctx->Driver.Enable(ctx, GL_COLOR_LOGIC_OP, ctx->Color.ColorLogicOpEnabled);
   ctx->Driver.Enable(ctx, GL_COLOR_SUM, ctx->Fog.ColorSumEnabled);
   ctx->Driver.Enable(ctx, GL_CULL_FACE, ctx->Polygon.CullFlag);
   ctx->Driver.Enable(ctx, GL_DEPTH_TEST, ctx->Depth.Test);
   ctx->Driver.Enable(ctx, GL_DITHER, ctx->Color.DitherFlag);
   ctx->Driver.Enable(ctx, GL_FOG, ctx->Fog.Enabled);
   ctx->Driver.Enable(ctx, GL_LIGHTING, ctx->Light.Enabled);
   ctx->Driver.Enable(ctx, GL_LINE_SMOOTH, ctx->Line.SmoothFlag);
   ctx->Driver.Enable(ctx, GL_POLYGON_STIPPLE, ctx->Polygon.StippleFlag);
   ctx->Driver.Enable(ctx, GL_SCISSOR_TEST, ctx->Scissor.EnableFlags);
   ctx->Driver.Enable(ctx, GL_STENCIL_TEST, ctx->Stencil._Enabled);
   ctx->Driver.Enable(ctx, GL_TEXTURE_1D, GL_FALSE);
   ctx->Driver.Enable(ctx, GL_TEXTURE_2D, GL_FALSE);
   ctx->Driver.Enable(ctx, GL_TEXTURE_RECTANGLE_NV, GL_FALSE);
   ctx->Driver.Enable(ctx, GL_TEXTURE_3D, GL_FALSE);
   ctx->Driver.Enable(ctx, GL_TEXTURE_CUBE_MAP, GL_FALSE);

   ctx->Driver.Fogfv(ctx, GL_FOG_COLOR, ctx->Fog.Color);
   {
      GLfloat mode = (GLfloat) ctx->Fog.Mode;
      ctx->Driver.Fogfv(ctx, GL_FOG_MODE, &mode);
   }
   ctx->Driver.Fogfv(ctx, GL_FOG_DENSITY, &ctx->Fog.Density);
   ctx->Driver.Fogfv(ctx, GL_FOG_START, &ctx->Fog.Start);
   ctx->Driver.Fogfv(ctx, GL_FOG_END, &ctx->Fog.End);

   ctx->Driver.FrontFace(ctx, ctx->Polygon.FrontFace);

   {
      GLfloat f = (GLfloat) ctx->Light.Model.ColorControl;
      ctx->Driver.LightModelfv(ctx, GL_LIGHT_MODEL_COLOR_CONTROL, &f);
   }

   ctx->Driver.LineWidth(ctx, ctx->Line.Width);
   ctx->Driver.LogicOpcode(ctx, ctx->Color.LogicOp);
   ctx->Driver.PointSize(ctx, ctx->Point.Size);
   ctx->Driver.PolygonStipple(ctx, (const GLubyte *) ctx->PolygonStipple);
   ctx->Driver.Scissor(ctx);
   ctx->Driver.ShadeModel(ctx, ctx->Light.ShadeModel);
   ctx->Driver.StencilFuncSeparate(ctx, GL_FRONT,
                                   ctx->Stencil.Function[0],
                                   ctx->Stencil.Ref[0],
                                   ctx->Stencil.ValueMask[0]);
   ctx->Driver.StencilFuncSeparate(ctx, GL_BACK,
                                   ctx->Stencil.Function[1],
                                   ctx->Stencil.Ref[1],
                                   ctx->Stencil.ValueMask[1]);
   ctx->Driver.StencilMaskSeparate(ctx, GL_FRONT, ctx->Stencil.WriteMask[0]);
   ctx->Driver.StencilMaskSeparate(ctx, GL_BACK, ctx->Stencil.WriteMask[1]);
   ctx->Driver.StencilOpSeparate(ctx, GL_FRONT,
                                 ctx->Stencil.FailFunc[0],
                                 ctx->Stencil.ZFailFunc[0],
                                 ctx->Stencil.ZPassFunc[0]);
   ctx->Driver.StencilOpSeparate(ctx, GL_BACK,
                                 ctx->Stencil.FailFunc[1],
                                 ctx->Stencil.ZFailFunc[1],
                                 ctx->Stencil.ZPassFunc[1]);


   ctx->Driver.DrawBuffer(ctx, ctx->Color.DrawBuffer[0]);
}
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a97 1
   driver->ClearTexSubImage = _mesa_meta_ClearTexSubImage;
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d98 1
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d183 2
a184 2
   driver->NewArrayObject = _mesa_new_array_object;
   driver->DeleteArrayObject = _mesa_delete_array_object;
d214 3
d277 1
a277 1
   ctx->Driver.Enable(ctx, GL_SCISSOR_TEST, ctx->Scissor.Enabled);
d305 1
a305 2
   ctx->Driver.Scissor(ctx, ctx->Scissor.X, ctx->Scissor.Y,
                       ctx->Scissor.Width, ctx->Scissor.Height);
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a2 1
 * Version:  7.1
d19 4
a22 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d28 1
d31 1
d35 1
d43 1
d55 1
a77 1
   driver->GetBufferSize = NULL;  /* REQUIRED! */
a78 1
   driver->Error = NULL;
d85 1
a85 1
   driver->Accum = _swrast_Accum;
d88 1
a88 1
   driver->ReadPixels = _swrast_ReadPixels;
d94 5
a98 12
   driver->TexImage1D = _mesa_store_teximage1d;
   driver->TexImage2D = _mesa_store_teximage2d;
   driver->TexImage3D = _mesa_store_teximage3d;
   driver->TexSubImage1D = _mesa_store_texsubimage1d;
   driver->TexSubImage2D = _mesa_store_texsubimage2d;
   driver->TexSubImage3D = _mesa_store_texsubimage3d;
   driver->GetTexImage = _mesa_get_teximage;
   driver->CopyTexImage1D = _mesa_meta_CopyTexImage1D;
   driver->CopyTexImage2D = _mesa_meta_CopyTexImage2D;
   driver->CopyTexSubImage1D = _mesa_meta_CopyTexSubImage1D;
   driver->CopyTexSubImage2D = _mesa_meta_CopyTexSubImage2D;
   driver->CopyTexSubImage3D = _mesa_meta_CopyTexSubImage3D;
d101 2
a102 6
   driver->CompressedTexImage1D = _mesa_store_compressed_teximage1d;
   driver->CompressedTexImage2D = _mesa_store_compressed_teximage2d;
   driver->CompressedTexImage3D = _mesa_store_compressed_teximage3d;
   driver->CompressedTexSubImage1D = _mesa_store_compressed_texsubimage1d;
   driver->CompressedTexSubImage2D = _mesa_store_compressed_texsubimage2d;
   driver->CompressedTexSubImage3D = _mesa_store_compressed_texsubimage3d;
d107 7
a113 11
   driver->NewTextureImage = _mesa_new_texture_image;
   driver->FreeTexImageData = _mesa_free_texture_image_data; 
   driver->MapTexture = NULL;
   driver->UnmapTexture = NULL;
   driver->TextureMemCpy = memcpy;
   driver->IsTextureResident = NULL;
   driver->UpdateTexturePalette = NULL;

   /* imaging */
   driver->CopyColorTable = _mesa_meta_CopyColorTable;
   driver->CopyColorSubTable = _mesa_meta_CopyColorSubTable;
a124 3
   driver->ClearColor = NULL;
   driver->ClearDepth = NULL;
   driver->ClearStencil = NULL;
d169 3
a171 1
   driver->NewRenderbuffer = _mesa_new_soft_renderbuffer;
d178 1
a193 2
   driver->NeedValidate = GL_FALSE;
   driver->ValidateTnlModule = NULL;
d210 6
d245 4
a248 4
                                      ctx->Color.ColorMask[0][RCOMP],
                                      ctx->Color.ColorMask[0][GCOMP],
                                      ctx->Color.ColorMask[0][BCOMP],
                                      ctx->Color.ColorMask[0][ACOMP]);
d283 4
a286 1
   ctx->Driver.Fogfv(ctx, GL_FOG_MODE, 0);
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d43 1
a43 1
#include "main/texrender.h"
d45 1
d185 2
a186 2
   driver->RenderTexture = _mesa_render_texture;
   driver->FinishRenderTexture = _mesa_finish_render_texture;
d188 1
d192 2
d203 2
d240 2
a241 2
                                     ctx->Color.BlendEquationRGB,
                                     ctx->Color.BlendEquationA);
d244 4
a247 3
                                 ctx->Color.BlendSrcRGB,
                                 ctx->Color.BlendDstRGB,
                                 ctx->Color.BlendSrcA, ctx->Color.BlendDstA);
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d34 1
a40 1
#if FEATURE_ARB_vertex_buffer_object
a41 2
#endif
#if FEATURE_EXT_framebuffer_object
a43 2
#endif
#if FEATURE_ARB_sync
d45 1
a45 1
#endif
d47 1
a47 2
#include "shader/program.h"
#include "shader/shader_api.h"
a124 2
   driver->CopyConvolutionFilter1D = _mesa_meta_CopyConvolutionFilter1D;
   driver->CopyConvolutionFilter2D = _mesa_meta_CopyConvolutionFilter2D;
a173 8
   /* state queries */
   driver->GetBooleanv = NULL;
   driver->GetDoublev = NULL;
   driver->GetFloatv = NULL;
   driver->GetIntegerv = NULL;
   driver->GetInteger64v = NULL;
   driver->GetPointerv = NULL;
   
a179 1
#if FEATURE_ARB_sync
a180 1
#endif
a181 1
#if FEATURE_EXT_framebuffer_object
a186 1
#endif
a187 1
#if FEATURE_EXT_framebuffer_blit
a188 1
#endif
d195 4
a217 4


   /* XXX temporary here */
   _mesa_init_glsl_driver_functions(driver);
d227 1
a227 1
_mesa_init_driver_state(GLcontext *ctx)
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a28 1
#include "main/buffers.h"
d36 1
d47 3
a51 1
#include "shader/prog_execute.h"
d57 1
d73 1
a73 1
   _mesa_bzero(driver, sizeof(*driver));
d102 6
a107 6
   driver->CopyTexImage1D = _swrast_copy_teximage1d;
   driver->CopyTexImage2D = _swrast_copy_teximage2d;
   driver->CopyTexSubImage1D = _swrast_copy_texsubimage1d;
   driver->CopyTexSubImage2D = _swrast_copy_texsubimage2d;
   driver->CopyTexSubImage3D = _swrast_copy_texsubimage3d;
   driver->GenerateMipmap = _mesa_generate_mipmap;
a115 1
   driver->CompressedTextureSize = _mesa_compressed_texture_size;
d123 1
a123 1
   driver->TextureMemCpy = _mesa_memcpy; 
a124 2
   driver->PrioritizeTexture = NULL;
   driver->ActiveTexture = NULL;
d128 4
a131 4
   driver->CopyColorTable = _swrast_CopyColorTable;
   driver->CopyColorSubTable = _swrast_CopyColorSubTable;
   driver->CopyConvolutionFilter1D = _swrast_CopyConvolutionFilter1D;
   driver->CopyConvolutionFilter2D = _swrast_CopyConvolutionFilter2D;
a136 3
#if FEATURE_MESA_program_debug
   driver->GetProgramRegister = _mesa_get_program_register;
#endif /* FEATURE_MESA_program_debug */
a144 1
   driver->ClearIndex = NULL;
a158 1
   driver->IndexMask = NULL;
a178 1
   driver->TextureMatrix = NULL;
a180 13
   /* vertex arrays */
   driver->VertexPointer = NULL;
   driver->NormalPointer = NULL;
   driver->ColorPointer = NULL;
   driver->FogCoordPointer = NULL;
   driver->IndexPointer = NULL;
   driver->SecondaryColorPointer = NULL;
   driver->TexCoordPointer = NULL;
   driver->EdgeFlagPointer = NULL;
   driver->VertexAttribPointer = NULL;
   driver->LockArraysEXT = NULL;
   driver->UnlockArraysEXT = NULL;

d186 1
d189 8
a196 9
#if FEATURE_ARB_vertex_buffer_object
   driver->NewBufferObject = _mesa_new_buffer_object;
   driver->DeleteBuffer = _mesa_delete_buffer_object;
   driver->BindBuffer = NULL;
   driver->BufferData = _mesa_buffer_data;
   driver->BufferSubData = _mesa_buffer_subdata;
   driver->GetBufferSubData = _mesa_buffer_get_subdata;
   driver->MapBuffer = _mesa_buffer_map;
   driver->UnmapBuffer = _mesa_buffer_unmap;
a210 7
   /* query objects */
   driver->NewQueryObject = _mesa_new_query_object;
   driver->DeleteQuery = _mesa_delete_query;
   driver->BeginQuery = _mesa_begin_query;
   driver->EndQuery = _mesa_end_query;
   driver->WaitQuery = _mesa_wait_query;

d263 17
a279 5
   ctx->Driver.ColorMask(ctx,
                         ctx->Color.ColorMask[RCOMP],
                         ctx->Color.ColorMask[GCOMP],
                         ctx->Color.ColorMask[BCOMP],
                         ctx->Color.ColorMask[ACOMP]);
d297 1
a297 1
   ctx->Driver.Enable(ctx, GL_STENCIL_TEST, ctx->Stencil.Enabled);
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d26 14
a39 14
#include "glheader.h"
#include "imports.h"
#include "arrayobj.h"
#include "buffers.h"
#include "context.h"
#include "framebuffer.h"
#include "mipmap.h"
#include "queryobj.h"
#include "renderbuffer.h"
#include "texcompress.h"
#include "texformat.h"
#include "teximage.h"
#include "texobj.h"
#include "texstore.h"
d41 1
a41 1
#include "bufferobj.h"
d44 2
a45 2
#include "fbobject.h"
#include "texrender.h"
a50 1
#include "driverfuncs.h"
d54 2
d84 1
d232 4
a235 2
   driver->BeginQuery = NULL;
   driver->EndQuery = NULL;
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d3 1
a3 1
 * Version:  6.5.3
d28 1
d32 1
a32 2
#include "program.h"
#include "prog_execute.h"
a46 2
#include "shader_api.h"
#include "arrayobj.h"
d48 3
d102 1
d265 3
a267 1
 * Plug in Mesa's GLSL functions.
d270 1
a270 1
_mesa_init_glsl_driver_functions(struct dd_function_table *driver)
d272 83
a354 28
   driver->AttachShader = _mesa_attach_shader;
   driver->BindAttribLocation = _mesa_bind_attrib_location;
   driver->CompileShader = _mesa_compile_shader;
   driver->CreateProgram = _mesa_create_program;
   driver->CreateShader = _mesa_create_shader;
   driver->DeleteProgram2 = _mesa_delete_program2;
   driver->DeleteShader = _mesa_delete_shader;
   driver->DetachShader = _mesa_detach_shader;
   driver->GetActiveAttrib = _mesa_get_active_attrib;
   driver->GetActiveUniform = _mesa_get_active_uniform;
   driver->GetAttachedShaders = _mesa_get_attached_shaders;
   driver->GetAttribLocation = _mesa_get_attrib_location;
   driver->GetHandle = _mesa_get_handle;
   driver->GetProgramiv = _mesa_get_programiv;
   driver->GetProgramInfoLog = _mesa_get_program_info_log;
   driver->GetShaderiv = _mesa_get_shaderiv;
   driver->GetShaderInfoLog = _mesa_get_shader_info_log;
   driver->GetShaderSource = _mesa_get_shader_source;
   driver->GetUniformfv = _mesa_get_uniformfv;
   driver->GetUniformLocation = _mesa_get_uniform_location;
   driver->IsProgram = _mesa_is_program;
   driver->IsShader = _mesa_is_shader;
   driver->LinkProgram = _mesa_link_program;
   driver->ShaderSource = _mesa_shader_source;
   driver->Uniform = _mesa_uniform;
   driver->UniformMatrix = _mesa_uniform_matrix;
   driver->UseProgram = _mesa_use_program;
   driver->ValidateProgram = _mesa_validate_program;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Version:  6.5
d5 1
a5 1
 * Copyright (C) 1999-2005  Brian Paul   All Rights Reserved.
a30 1
#include "occlude.h"
d32 2
d47 1
d115 2
d133 3
d255 41
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a128 3
#if FEATURE_MESA_program_debug
   driver->GetFragmentProgramRegister = _swrast_get_program_register;
#endif /* FEATURE_MESA_program_debug */
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d3 1
a3 1
 * Version:  6.5.3
d5 1
a5 1
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
d31 1
a32 2
#include "prog_execute.h"
#include "queryobj.h"
a45 1
#include "shader_api.h"
d130 1
a130 1
   driver->GetProgramRegister = _mesa_get_program_register;
a250 41


   /* XXX temporary here */
   _mesa_init_glsl_driver_functions(driver);
}


/**
 * Plug in Mesa's GLSL functions.
 */
void
_mesa_init_glsl_driver_functions(struct dd_function_table *driver)
{
   driver->AttachShader = _mesa_attach_shader;
   driver->BindAttribLocation = _mesa_bind_attrib_location;
   driver->CompileShader = _mesa_compile_shader;
   driver->CreateProgram = _mesa_create_program;
   driver->CreateShader = _mesa_create_shader;
   driver->DeleteProgram2 = _mesa_delete_program2;
   driver->DeleteShader = _mesa_delete_shader;
   driver->DetachShader = _mesa_detach_shader;
   driver->GetActiveAttrib = _mesa_get_active_attrib;
   driver->GetActiveUniform = _mesa_get_active_uniform;
   driver->GetAttachedShaders = _mesa_get_attached_shaders;
   driver->GetAttribLocation = _mesa_get_attrib_location;
   driver->GetHandle = _mesa_get_handle;
   driver->GetProgramiv = _mesa_get_programiv;
   driver->GetProgramInfoLog = _mesa_get_program_info_log;
   driver->GetShaderiv = _mesa_get_shaderiv;
   driver->GetShaderInfoLog = _mesa_get_shader_info_log;
   driver->GetShaderSource = _mesa_get_shader_source;
   driver->GetUniformfv = _mesa_get_uniformfv;
   driver->GetUniformLocation = _mesa_get_uniform_location;
   driver->IsProgram = _mesa_is_program;
   driver->IsShader = _mesa_is_shader;
   driver->LinkProgram = _mesa_link_program;
   driver->ShaderSource = _mesa_shader_source;
   driver->Uniform = _mesa_uniform;
   driver->UniformMatrix = _mesa_uniform_matrix;
   driver->UseProgram = _mesa_use_program;
   driver->ValidateProgram = _mesa_validate_program;
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 1
 * Version:  7.1
d26 23
a48 20
#include "main/glheader.h"
#include "main/imports.h"
#include "main/arrayobj.h"
#include "main/context.h"
#include "main/framebuffer.h"
#include "main/mipmap.h"
#include "main/queryobj.h"
#include "main/renderbuffer.h"
#include "main/shaderobj.h"
#include "main/texcompress.h"
#include "main/texformat.h"
#include "main/texgetimage.h"
#include "main/teximage.h"
#include "main/texobj.h"
#include "main/texstore.h"
#include "main/bufferobj.h"
#include "main/fbobject.h"
#include "main/texrender.h"
#include "main/syncobj.h"
#include "main/transformfeedback.h"
d50 1
a50 1
#include "program/program.h"
a53 3
#include "driverfuncs.h"
#include "meta.h"

d68 1
a68 1
   memset(driver, 0, sizeof(*driver));
a81 1
   driver->RasterPos = _tnl_RasterPos;
d96 5
a100 6
   driver->CopyTexImage1D = _mesa_meta_CopyTexImage1D;
   driver->CopyTexImage2D = _mesa_meta_CopyTexImage2D;
   driver->CopyTexSubImage1D = _mesa_meta_CopyTexSubImage1D;
   driver->CopyTexSubImage2D = _mesa_meta_CopyTexSubImage2D;
   driver->CopyTexSubImage3D = _mesa_meta_CopyTexSubImage3D;
   driver->GenerateMipmap = _mesa_meta_GenerateMipmap;
d109 1
d115 1
a115 3
   driver->MapTexture = NULL;
   driver->UnmapTexture = NULL;
   driver->TextureMemCpy = memcpy;
d117 2
d122 4
a125 2
   driver->CopyColorTable = _mesa_meta_CopyColorTable;
   driver->CopyColorSubTable = _mesa_meta_CopyColorSubTable;
d131 3
d142 1
d157 1
d178 1
d181 30
a210 7
   /* buffer objects */
   _mesa_init_buffer_object_functions(driver);

   /* query objects */
   _mesa_init_query_object_functions(driver);

   _mesa_init_sync_object_functions(driver);
d212 1
d218 1
d220 1
d222 6
a233 4
   _mesa_init_shader_object_functions(driver);

   _mesa_init_transform_feedback_functions(driver);

d253 4
d261 1
a261 3
 * Call the ctx->Driver.* state functions with current values to initialize
 * driver state.
 * Only the Intel drivers use this so far.
d264 1
a264 1
_mesa_init_driver_state(struct gl_context *ctx)
d266 28
a293 95
   ctx->Driver.AlphaFunc(ctx, ctx->Color.AlphaFunc, ctx->Color.AlphaRef);

   ctx->Driver.BlendColor(ctx, ctx->Color.BlendColor);

   ctx->Driver.BlendEquationSeparate(ctx,
                                     ctx->Color.BlendEquationRGB,
                                     ctx->Color.BlendEquationA);

   ctx->Driver.BlendFuncSeparate(ctx,
                                 ctx->Color.BlendSrcRGB,
                                 ctx->Color.BlendDstRGB,
                                 ctx->Color.BlendSrcA, ctx->Color.BlendDstA);

   if (ctx->Driver.ColorMaskIndexed) {
      GLuint i;
      for (i = 0; i < ctx->Const.MaxDrawBuffers; i++) {
         ctx->Driver.ColorMaskIndexed(ctx, i,
                                      ctx->Color.ColorMask[0][RCOMP],
                                      ctx->Color.ColorMask[0][GCOMP],
                                      ctx->Color.ColorMask[0][BCOMP],
                                      ctx->Color.ColorMask[0][ACOMP]);
      }
   }
   else {
      ctx->Driver.ColorMask(ctx,
                            ctx->Color.ColorMask[0][RCOMP],
                            ctx->Color.ColorMask[0][GCOMP],
                            ctx->Color.ColorMask[0][BCOMP],
                            ctx->Color.ColorMask[0][ACOMP]);
   }

   ctx->Driver.CullFace(ctx, ctx->Polygon.CullFaceMode);
   ctx->Driver.DepthFunc(ctx, ctx->Depth.Func);
   ctx->Driver.DepthMask(ctx, ctx->Depth.Mask);

   ctx->Driver.Enable(ctx, GL_ALPHA_TEST, ctx->Color.AlphaEnabled);
   ctx->Driver.Enable(ctx, GL_BLEND, ctx->Color.BlendEnabled);
   ctx->Driver.Enable(ctx, GL_COLOR_LOGIC_OP, ctx->Color.ColorLogicOpEnabled);
   ctx->Driver.Enable(ctx, GL_COLOR_SUM, ctx->Fog.ColorSumEnabled);
   ctx->Driver.Enable(ctx, GL_CULL_FACE, ctx->Polygon.CullFlag);
   ctx->Driver.Enable(ctx, GL_DEPTH_TEST, ctx->Depth.Test);
   ctx->Driver.Enable(ctx, GL_DITHER, ctx->Color.DitherFlag);
   ctx->Driver.Enable(ctx, GL_FOG, ctx->Fog.Enabled);
   ctx->Driver.Enable(ctx, GL_LIGHTING, ctx->Light.Enabled);
   ctx->Driver.Enable(ctx, GL_LINE_SMOOTH, ctx->Line.SmoothFlag);
   ctx->Driver.Enable(ctx, GL_POLYGON_STIPPLE, ctx->Polygon.StippleFlag);
   ctx->Driver.Enable(ctx, GL_SCISSOR_TEST, ctx->Scissor.Enabled);
   ctx->Driver.Enable(ctx, GL_STENCIL_TEST, ctx->Stencil._Enabled);
   ctx->Driver.Enable(ctx, GL_TEXTURE_1D, GL_FALSE);
   ctx->Driver.Enable(ctx, GL_TEXTURE_2D, GL_FALSE);
   ctx->Driver.Enable(ctx, GL_TEXTURE_RECTANGLE_NV, GL_FALSE);
   ctx->Driver.Enable(ctx, GL_TEXTURE_3D, GL_FALSE);
   ctx->Driver.Enable(ctx, GL_TEXTURE_CUBE_MAP, GL_FALSE);

   ctx->Driver.Fogfv(ctx, GL_FOG_COLOR, ctx->Fog.Color);
   ctx->Driver.Fogfv(ctx, GL_FOG_MODE, 0);
   ctx->Driver.Fogfv(ctx, GL_FOG_DENSITY, &ctx->Fog.Density);
   ctx->Driver.Fogfv(ctx, GL_FOG_START, &ctx->Fog.Start);
   ctx->Driver.Fogfv(ctx, GL_FOG_END, &ctx->Fog.End);

   ctx->Driver.FrontFace(ctx, ctx->Polygon.FrontFace);

   {
      GLfloat f = (GLfloat) ctx->Light.Model.ColorControl;
      ctx->Driver.LightModelfv(ctx, GL_LIGHT_MODEL_COLOR_CONTROL, &f);
   }

   ctx->Driver.LineWidth(ctx, ctx->Line.Width);
   ctx->Driver.LogicOpcode(ctx, ctx->Color.LogicOp);
   ctx->Driver.PointSize(ctx, ctx->Point.Size);
   ctx->Driver.PolygonStipple(ctx, (const GLubyte *) ctx->PolygonStipple);
   ctx->Driver.Scissor(ctx, ctx->Scissor.X, ctx->Scissor.Y,
                       ctx->Scissor.Width, ctx->Scissor.Height);
   ctx->Driver.ShadeModel(ctx, ctx->Light.ShadeModel);
   ctx->Driver.StencilFuncSeparate(ctx, GL_FRONT,
                                   ctx->Stencil.Function[0],
                                   ctx->Stencil.Ref[0],
                                   ctx->Stencil.ValueMask[0]);
   ctx->Driver.StencilFuncSeparate(ctx, GL_BACK,
                                   ctx->Stencil.Function[1],
                                   ctx->Stencil.Ref[1],
                                   ctx->Stencil.ValueMask[1]);
   ctx->Driver.StencilMaskSeparate(ctx, GL_FRONT, ctx->Stencil.WriteMask[0]);
   ctx->Driver.StencilMaskSeparate(ctx, GL_BACK, ctx->Stencil.WriteMask[1]);
   ctx->Driver.StencilOpSeparate(ctx, GL_FRONT,
                                 ctx->Stencil.FailFunc[0],
                                 ctx->Stencil.ZFailFunc[0],
                                 ctx->Stencil.ZPassFunc[0]);
   ctx->Driver.StencilOpSeparate(ctx, GL_BACK,
                                 ctx->Stencil.FailFunc[1],
                                 ctx->Stencil.ZFailFunc[1],
                                 ctx->Stencil.ZPassFunc[1]);


   ctx->Driver.DrawBuffer(ctx, ctx->Color.DrawBuffer[0]);
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d3 1
d20 3
a22 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a27 1
#include "main/accum.h"
a29 1
#include "main/formatquery.h"
a32 1
#include "main/readpix.h"
a39 1
#include "main/texstorage.h"
d43 1
a43 1
#include "main/samplerobj.h"
a44 1
#include "main/texturebarrier.h"
a49 1
#include "swrast/s_renderbuffer.h"
d72 1
d74 1
d81 1
a81 1
   driver->Accum = _mesa_accum;
d84 1
a84 1
   driver->ReadPixels = _mesa_readpixels;
d90 12
a101 5
   driver->QuerySamplesForFormat = _mesa_query_samples_for_format;
   driver->TexImage = _mesa_store_teximage;
   driver->TexSubImage = _mesa_store_texsubimage;
   driver->GetTexImage = _mesa_meta_GetTexImage;
   driver->CopyTexSubImage = _mesa_meta_CopyTexSubImage;
d104 6
a109 2
   driver->CompressedTexImage = _mesa_store_compressed_teximage;
   driver->CompressedTexSubImage = _mesa_store_compressed_texsubimage;
d114 11
a124 7
   driver->NewTextureImage = _swrast_new_texture_image;
   driver->DeleteTextureImage = _swrast_delete_texture_image;
   driver->AllocTextureImageBuffer = _swrast_alloc_texture_image_buffer;
   driver->FreeTextureImageBuffer = _swrast_free_texture_image_buffer;
   driver->MapTextureImage = _swrast_map_teximage;
   driver->UnmapTextureImage = _swrast_unmap_teximage;
   driver->DrawTex = _mesa_meta_DrawTex;
d136 3
d183 3
a185 5
   driver->NewRenderbuffer = _swrast_new_soft_renderbuffer;
   driver->MapRenderbuffer = _swrast_map_soft_renderbuffer;
   driver->UnmapRenderbuffer = _swrast_unmap_soft_renderbuffer;
   driver->RenderTexture = _swrast_render_texture;
   driver->FinishRenderTexture = _swrast_finish_render_texture;
a186 1
   driver->ValidateFramebuffer = _mesa_validate_framebuffer;
a188 3
   driver->DiscardFramebuffer = NULL;

   _mesa_init_texture_barrier_functions(driver);
a198 2
   _mesa_init_sampler_object_functions(driver);

d200 2
a217 6

   /* GL_ARB_texture_storage */
   driver->AllocTextureStorage = _mesa_alloc_texture_storage;

   /* GL_ARB_texture_multisample */
   driver->GetSamplePosition = NULL;
d234 2
a235 2
                                     ctx->Color.Blend[0].EquationRGB,
                                     ctx->Color.Blend[0].EquationA);
d238 3
a240 4
                                 ctx->Color.Blend[0].SrcRGB,
                                 ctx->Color.Blend[0].DstRGB,
                                 ctx->Color.Blend[0].SrcA,
                                 ctx->Color.Blend[0].DstA);
d246 4
a249 4
                                      ctx->Color.ColorMask[i][RCOMP],
                                      ctx->Color.ColorMask[i][GCOMP],
                                      ctx->Color.ColorMask[i][BCOMP],
                                      ctx->Color.ColorMask[i][ACOMP]);
d284 1
a284 4
   {
      GLfloat mode = (GLfloat) ctx->Fog.Mode;
      ctx->Driver.Fogfv(ctx, GL_FOG_MODE, &mode);
   }
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d183 2
a184 2
   driver->NewArrayObject = _mesa_new_vao;
   driver->DeleteArrayObject = _mesa_delete_vao;
a213 3
   /* GL_ARB_texture_view */
   driver->TextureView = NULL;

d274 1
a274 1
   ctx->Driver.Enable(ctx, GL_SCISSOR_TEST, ctx->Scissor.EnableFlags);
d302 2
a303 1
   ctx->Driver.Scissor(ctx);
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@a97 1
   driver->ClearTexSubImage = _mesa_meta_ClearTexSubImage;
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d98 1
@


