head	1.5;
access;
symbols
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.10
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.09.05.14.04.32;	author jsg;	state dead;
branches;
next	1.4;

1.4
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.38;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge Mesa 9.2.0
@
text
@/**************************************************************************
 * 
 * Copyright 2006 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#ifndef INTEL_FBO_H
#define INTEL_FBO_H

#include <stdbool.h>
#include "main/formats.h"
#include "intel_screen.h"

struct intel_context;
struct intel_texture_image;

/**
 * Intel renderbuffer, derived from gl_renderbuffer.
 */
struct intel_renderbuffer
{
   struct gl_renderbuffer Base;
   struct intel_region *region;

   /** Only used by depth renderbuffers for which HiZ is enabled. */
   struct intel_region *hiz_region;

   /**
    * \name Packed depth/stencil unwrappers
    *
    * If the intel_context is using separate stencil and this renderbuffer has
    * a a packed depth/stencil format, then wrapped_depth and wrapped_stencil
    * are the real renderbuffers.
    */
   struct gl_renderbuffer *wrapped_depth;
   struct gl_renderbuffer *wrapped_stencil;

   /** \} */

   GLuint draw_x, draw_y; /**< Offset of drawing within the region */
};


/**
 * gl_renderbuffer is a base class which we subclass.  The Class field
 * is used for simple run-time type checking.
 */
#define INTEL_RB_CLASS 0x12345678


/**
 * Return a gl_renderbuffer ptr casted to intel_renderbuffer.
 * NULL will be returned if the rb isn't really an intel_renderbuffer.
 * This is determined by checking the ClassID.
 */
static INLINE struct intel_renderbuffer *
intel_renderbuffer(struct gl_renderbuffer *rb)
{
   struct intel_renderbuffer *irb = (struct intel_renderbuffer *) rb;
   if (irb && irb->Base.ClassID == INTEL_RB_CLASS) {
      /*_mesa_warning(NULL, "Returning non-intel Rb\n");*/
      return irb;
   }
   else
      return NULL;
}


/**
 * \brief Return the framebuffer attachment specified by attIndex.
 *
 * If the framebuffer lacks the specified attachment, then return null.
 *
 * If the attached renderbuffer is a wrapper, then return wrapped
 * renderbuffer.
 */
static INLINE struct intel_renderbuffer *
intel_get_renderbuffer(struct gl_framebuffer *fb, gl_buffer_index attIndex)
{
   struct gl_renderbuffer *rb;
   struct intel_renderbuffer *irb;

   /* XXX: Who passes -1 to intel_get_renderbuffer? */
   if (attIndex < 0)
      return NULL;

   rb = fb->Attachment[attIndex].Renderbuffer;
   if (!rb)
      return NULL;

   irb = intel_renderbuffer(rb);
   if (!irb)
      return NULL;

   switch (attIndex) {
   case BUFFER_DEPTH:
      if (irb->wrapped_depth) {
	 irb = intel_renderbuffer(irb->wrapped_depth);
      }
      break;
   case BUFFER_STENCIL:
      if (irb->wrapped_stencil) {
	 irb = intel_renderbuffer(irb->wrapped_stencil);
      }
      break;
   default:
      break;
   }

   return irb;
}

/**
 * If the framebuffer has a depth buffer attached, then return its HiZ region.
 * The HiZ region may be null.
 */
static INLINE struct intel_region*
intel_framebuffer_get_hiz_region(struct gl_framebuffer *fb)
{
   struct intel_renderbuffer *rb = NULL;
   if (fb)
      rb = intel_get_renderbuffer(fb, BUFFER_DEPTH);

   if (rb)
      return rb->hiz_region;
   else
      return NULL;
}

static INLINE bool
intel_framebuffer_has_hiz(struct gl_framebuffer *fb)
{
   return intel_framebuffer_get_hiz_region(fb) != NULL;
}


extern void
intel_renderbuffer_set_region(struct intel_context *intel,
			      struct intel_renderbuffer *irb,
			      struct intel_region *region);

extern void
intel_renderbuffer_set_hiz_region(struct intel_context *intel,
				  struct intel_renderbuffer *rb,
				  struct intel_region *region);


extern struct intel_renderbuffer *
intel_create_renderbuffer(gl_format format);

struct gl_renderbuffer*
intel_create_wrapped_renderbuffer(struct gl_context * ctx,
				  int width, int height,
				  gl_format format);

GLboolean
intel_alloc_renderbuffer_storage(struct gl_context * ctx,
				 struct gl_renderbuffer *rb,
                                 GLenum internalFormat,
                                 GLuint width, GLuint height);

extern void
intel_fbo_init(struct intel_context *intel);


extern void
intel_flip_renderbuffers(struct gl_framebuffer *fb);

void
intel_renderbuffer_set_draw_offset(struct intel_renderbuffer *irb,
				   struct intel_texture_image *intel_image,
				   int zoffset);

uint32_t
intel_renderbuffer_tile_offsets(struct intel_renderbuffer *irb,
				uint32_t *tile_x,
				uint32_t *tile_y);

static INLINE struct intel_region *
intel_get_rb_region(struct gl_framebuffer *fb, GLuint attIndex)
{
   struct intel_renderbuffer *irb = intel_get_renderbuffer(fb, attIndex);
   if (irb)
      return irb->region;
   else
      return NULL;
}

#endif /* INTEL_FBO_H */
@


1.4
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d31 1
d36 1
d45 17
d91 6
a96 1
 * Return a framebuffer's renderbuffer, named by a BUFFER_x index.
d99 1
a99 1
intel_get_renderbuffer(struct gl_framebuffer *fb, int attIndex)
d101 46
a146 2
   if (attIndex >= 0)
      return intel_renderbuffer(fb->Attachment[attIndex].Renderbuffer);
d151 6
d163 5
d172 10
d190 9
a208 1

@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d31 1
d37 1
a37 1
 * Intel framebuffer, derived from gl_framebuffer.
d39 1
a39 1
struct intel_framebuffer
d41 3
a43 1
   struct gl_framebuffer Base;
a44 1
   struct intel_renderbuffer *color_rb[2];
d46 5
a50 3
   /* VBI
    */
   GLuint vbl_waited;
a51 2
   int64_t swap_ust;
   int64_t swap_missed_ust;
d53 16
a68 3
   GLuint swap_count;
   GLuint swap_missed_count;
};
d72 1
a72 4
 * Intel renderbuffer, derived from gl_renderbuffer.
 * Note: The PairedDepth and PairedStencil fields use renderbuffer IDs,
 * not pointers because in some circumstances a deleted renderbuffer could
 * result in a dangling pointer here.
d74 2
a75 1
struct intel_renderbuffer
d77 5
a81 13
   struct gl_renderbuffer Base;
   struct intel_region *region;
   GLuint pfPitch;              /* possibly paged flipped pitch */
   GLboolean RenderToTexture;   /* RTT? */

   GLuint PairedDepth;   /**< only used if this is a depth renderbuffer */
   GLuint PairedStencil; /**< only used if this is a stencil renderbuffer */

   GLuint vbl_pending;   /**< vblank sequence number of pending flip */

   uint8_t *span_cache;
   unsigned long span_cache_offset;
};
a82 2
extern struct intel_renderbuffer *intel_renderbuffer(struct gl_renderbuffer
                                                     *rb);
d85 2
a86 1
intel_renderbuffer_set_region(struct intel_renderbuffer *irb,
d89 1
d91 1
a91 1
intel_create_renderbuffer(GLenum intFormat);
a92 1
extern void intel_fbo_init(struct intel_context *intel);
d94 2
a96 4
/* XXX make inline or macro */
extern struct intel_renderbuffer *intel_get_renderbuffer(struct gl_framebuffer
                                                         *fb,
                                                         int attIndex);
d98 2
a99 1
extern void intel_flip_renderbuffers(struct intel_framebuffer *intel_fb);
d102 2
a103 11
/* XXX make inline or macro */
extern struct intel_region *intel_get_rb_region(struct gl_framebuffer *fb,
                                                GLuint attIndex);



/**
 * Are we currently rendering into a texture?
 */
static INLINE GLboolean
intel_rendering_to_texture(const GLcontext *ctx)
d105 5
a109 9
   if (ctx->DrawBuffer->Name) {
      /* User-created FBO */
      const struct intel_renderbuffer *irb =
         intel_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0]);
      return irb && irb->RenderToTexture;
   }
   else {
      return GL_FALSE;
   }
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d31 1
a33 1
struct intel_region;
d42 1
a42 8
   struct intel_renderbuffer *color_rb[3];

   /* Drawable page flipping state */
   GLboolean pf_active;
   GLuint pf_seq;
   GLint pf_planes;
   GLint pf_current_page;
   GLint pf_num_pages;
a65 1
   void *pfMap;                 /* possibly paged flipped map pointer */
d72 1
a72 1
   GLuint pf_pending;  /**< sequence number of pending flip */
d74 2
a75 1
   GLuint vbl_pending;   /**< vblank sequence number of pending flip */
d104 17
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a30 2
#include "main/formats.h"
#include "intel_screen.h"
d33 1
d36 1
a36 1
 * Intel renderbuffer, derived from gl_renderbuffer.
d38 1
a38 1
struct intel_renderbuffer
d40 14
a53 3
   struct gl_renderbuffer Base;
   struct intel_region *region;
};
d55 2
d58 3
a60 5
/**
 * gl_renderbuffer is a base class which we subclass.  The Class field
 * is used for simple run-time type checking.
 */
#define INTEL_RB_CLASS 0x12345678
d64 4
a67 3
 * Return a gl_renderbuffer ptr casted to intel_renderbuffer.
 * NULL will be returned if the rb isn't really an intel_renderbuffer.
 * This is determined by checking the ClassID.
d69 1
a69 2
static INLINE struct intel_renderbuffer *
intel_renderbuffer(struct gl_renderbuffer *rb)
d71 8
a78 8
   struct intel_renderbuffer *irb = (struct intel_renderbuffer *) rb;
   if (irb && irb->Base.ClassID == INTEL_RB_CLASS) {
      /*_mesa_warning(NULL, "Returning non-intel Rb\n");*/
      return irb;
   }
   else
      return NULL;
}
d80 1
d82 2
a83 11
/**
 * Return a framebuffer's renderbuffer, named by a BUFFER_x index.
 */
static INLINE struct intel_renderbuffer *
intel_get_renderbuffer(struct gl_framebuffer *fb, int attIndex)
{
   if (attIndex >= 0)
      return intel_renderbuffer(fb->Attachment[attIndex].Renderbuffer);
   else
      return NULL;
}
d85 2
d89 1
a89 2
intel_renderbuffer_set_region(struct intel_context *intel,
			      struct intel_renderbuffer *irb,
d92 4
a96 2
extern struct intel_renderbuffer *
intel_create_renderbuffer(gl_format format);
d98 4
d103 1
a103 2
extern void
intel_fbo_init(struct intel_context *intel);
d106 3
a108 2
extern void
intel_flip_renderbuffers(struct gl_framebuffer *fb);
a110 9
static INLINE struct intel_region *
intel_get_rb_region(struct gl_framebuffer *fb, GLuint attIndex)
{
   struct intel_renderbuffer *irb = intel_get_renderbuffer(fb, attIndex);
   if (irb)
      return irb->region;
   else
      return NULL;
}
@


