head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.9
	v10_4_3:1.1.1.8
	v10_2_7:1.1.1.7
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.09.07.15.20.07;	author jsg;	state Exp;
branches;
next	1.8;
commitid	7kimTMT4YlQauAIU;

1.8
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.05.34;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.18;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.53.40;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.53.40;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.30;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.29.34;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.42;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.07;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.56;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2014.09.07.15.06.43;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	dm8VnQHhowGHmemJ;

1.1.1.8
date	2015.01.25.14.12.14;	author jsg;	state Exp;
branches;
next	1.1.1.9;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.9
date	2015.02.20.22.49.21;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************

Copyright 2000, 2001 VA Linux Systems Inc., Fremont, California.

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial
portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Gareth Hughes <gareth@@valinux.com>
 *   Keith Whitwell <keithw@@vmware.com>
 */

#include "main/glheader.h"
#include "main/imports.h"
#include "main/api_arrayelt.h"
#include "main/enums.h"
#include "main/light.h"
#include "main/context.h"
#include "main/framebuffer.h"
#include "main/fbobject.h"
#include "main/simple_list.h"
#include "main/state.h"
#include "main/core.h"
#include "main/stencil.h"

#include "vbo/vbo.h"
#include "tnl/tnl.h"
#include "tnl/t_pipeline.h"
#include "swrast_setup/swrast_setup.h"
#include "drivers/common/meta.h"

#include "radeon_context.h"
#include "radeon_mipmap_tree.h"
#include "radeon_ioctl.h"
#include "radeon_state.h"
#include "radeon_tcl.h"
#include "radeon_tex.h"
#include "radeon_swtcl.h"

static void radeonUpdateSpecular( struct gl_context *ctx );

/* =============================================================
 * Alpha blending
 */

static void radeonAlphaFunc( struct gl_context *ctx, GLenum func, GLfloat ref )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   int pp_misc = rmesa->hw.ctx.cmd[CTX_PP_MISC];
   GLubyte refByte;

   CLAMPED_FLOAT_TO_UBYTE(refByte, ref);

   RADEON_STATECHANGE( rmesa, ctx );

   pp_misc &= ~(RADEON_ALPHA_TEST_OP_MASK | RADEON_REF_ALPHA_MASK);
   pp_misc |= (refByte & RADEON_REF_ALPHA_MASK);

   switch ( func ) {
   case GL_NEVER:
      pp_misc |= RADEON_ALPHA_TEST_FAIL;
      break;
   case GL_LESS:
      pp_misc |= RADEON_ALPHA_TEST_LESS;
      break;
   case GL_EQUAL:
      pp_misc |= RADEON_ALPHA_TEST_EQUAL;
      break;
   case GL_LEQUAL:
      pp_misc |= RADEON_ALPHA_TEST_LEQUAL;
      break;
   case GL_GREATER:
      pp_misc |= RADEON_ALPHA_TEST_GREATER;
      break;
   case GL_NOTEQUAL:
      pp_misc |= RADEON_ALPHA_TEST_NEQUAL;
      break;
   case GL_GEQUAL:
      pp_misc |= RADEON_ALPHA_TEST_GEQUAL;
      break;
   case GL_ALWAYS:
      pp_misc |= RADEON_ALPHA_TEST_PASS;
      break;
   }

   rmesa->hw.ctx.cmd[CTX_PP_MISC] = pp_misc;
}

static void radeonBlendEquationSeparate( struct gl_context *ctx,
					 GLenum modeRGB, GLenum modeA )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLuint b = rmesa->hw.ctx.cmd[CTX_RB3D_BLENDCNTL] & ~RADEON_COMB_FCN_MASK;
   GLboolean fallback = GL_FALSE;

   assert( modeRGB == modeA );

   switch ( modeRGB ) {
   case GL_FUNC_ADD:
   case GL_LOGIC_OP:
      b |= RADEON_COMB_FCN_ADD_CLAMP;
      break;

   case GL_FUNC_SUBTRACT:
      b |= RADEON_COMB_FCN_SUB_CLAMP;
      break;

   default:
      if (ctx->Color.BlendEnabled)
	 fallback = GL_TRUE;
      else
	 b |= RADEON_COMB_FCN_ADD_CLAMP;
      break;
   }

   FALLBACK( rmesa, RADEON_FALLBACK_BLEND_EQ, fallback );
   if ( !fallback ) {
      RADEON_STATECHANGE( rmesa, ctx );
      rmesa->hw.ctx.cmd[CTX_RB3D_BLENDCNTL] = b;
      if ( (ctx->Color.ColorLogicOpEnabled || (ctx->Color.BlendEnabled
	    && ctx->Color.Blend[0].EquationRGB == GL_LOGIC_OP)) ) {
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] |=  RADEON_ROP_ENABLE;
      } else {
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] &= ~RADEON_ROP_ENABLE;
      }
   }
}

static void radeonBlendFuncSeparate( struct gl_context *ctx,
				     GLenum sfactorRGB, GLenum dfactorRGB,
				     GLenum sfactorA, GLenum dfactorA )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLuint b = rmesa->hw.ctx.cmd[CTX_RB3D_BLENDCNTL] &
      ~(RADEON_SRC_BLEND_MASK | RADEON_DST_BLEND_MASK);
   GLboolean fallback = GL_FALSE;

   switch ( ctx->Color.Blend[0].SrcRGB ) {
   case GL_ZERO:
      b |= RADEON_SRC_BLEND_GL_ZERO;
      break;
   case GL_ONE:
      b |= RADEON_SRC_BLEND_GL_ONE;
      break;
   case GL_DST_COLOR:
      b |= RADEON_SRC_BLEND_GL_DST_COLOR;
      break;
   case GL_ONE_MINUS_DST_COLOR:
      b |= RADEON_SRC_BLEND_GL_ONE_MINUS_DST_COLOR;
      break;
   case GL_SRC_COLOR:
      b |= RADEON_SRC_BLEND_GL_SRC_COLOR;
      break;
   case GL_ONE_MINUS_SRC_COLOR:
      b |= RADEON_SRC_BLEND_GL_ONE_MINUS_SRC_COLOR;
      break;
   case GL_SRC_ALPHA:
      b |= RADEON_SRC_BLEND_GL_SRC_ALPHA;
      break;
   case GL_ONE_MINUS_SRC_ALPHA:
      b |= RADEON_SRC_BLEND_GL_ONE_MINUS_SRC_ALPHA;
      break;
   case GL_DST_ALPHA:
      b |= RADEON_SRC_BLEND_GL_DST_ALPHA;
      break;
   case GL_ONE_MINUS_DST_ALPHA:
      b |= RADEON_SRC_BLEND_GL_ONE_MINUS_DST_ALPHA;
      break;
   case GL_SRC_ALPHA_SATURATE:
      b |= RADEON_SRC_BLEND_GL_SRC_ALPHA_SATURATE;
      break;
   case GL_CONSTANT_COLOR:
   case GL_ONE_MINUS_CONSTANT_COLOR:
   case GL_CONSTANT_ALPHA:
   case GL_ONE_MINUS_CONSTANT_ALPHA:
      if (ctx->Color.BlendEnabled)
	 fallback = GL_TRUE;
      else
	 b |= RADEON_SRC_BLEND_GL_ONE;
      break;
   default:
      break;
   }

   switch ( ctx->Color.Blend[0].DstRGB ) {
   case GL_ZERO:
      b |= RADEON_DST_BLEND_GL_ZERO;
      break;
   case GL_ONE:
      b |= RADEON_DST_BLEND_GL_ONE;
      break;
   case GL_SRC_COLOR:
      b |= RADEON_DST_BLEND_GL_SRC_COLOR;
      break;
   case GL_ONE_MINUS_SRC_COLOR:
      b |= RADEON_DST_BLEND_GL_ONE_MINUS_SRC_COLOR;
      break;
   case GL_SRC_ALPHA:
      b |= RADEON_DST_BLEND_GL_SRC_ALPHA;
      break;
   case GL_ONE_MINUS_SRC_ALPHA:
      b |= RADEON_DST_BLEND_GL_ONE_MINUS_SRC_ALPHA;
      break;
   case GL_DST_COLOR:
      b |= RADEON_DST_BLEND_GL_DST_COLOR;
      break;
   case GL_ONE_MINUS_DST_COLOR:
      b |= RADEON_DST_BLEND_GL_ONE_MINUS_DST_COLOR;
      break;
   case GL_DST_ALPHA:
      b |= RADEON_DST_BLEND_GL_DST_ALPHA;
      break;
   case GL_ONE_MINUS_DST_ALPHA:
      b |= RADEON_DST_BLEND_GL_ONE_MINUS_DST_ALPHA;
      break;
   case GL_CONSTANT_COLOR:
   case GL_ONE_MINUS_CONSTANT_COLOR:
   case GL_CONSTANT_ALPHA:
   case GL_ONE_MINUS_CONSTANT_ALPHA:
      if (ctx->Color.BlendEnabled)
	 fallback = GL_TRUE;
      else
	 b |= RADEON_DST_BLEND_GL_ZERO;
      break;
   default:
      break;
   }

   FALLBACK( rmesa, RADEON_FALLBACK_BLEND_FUNC, fallback );
   if ( !fallback ) {
      RADEON_STATECHANGE( rmesa, ctx );
      rmesa->hw.ctx.cmd[CTX_RB3D_BLENDCNTL] = b;
   }
}


/* =============================================================
 * Depth testing
 */

static void radeonDepthFunc( struct gl_context *ctx, GLenum func )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);

   RADEON_STATECHANGE( rmesa, ctx );
   rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] &= ~RADEON_Z_TEST_MASK;

   switch ( ctx->Depth.Func ) {
   case GL_NEVER:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_Z_TEST_NEVER;
      break;
   case GL_LESS:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_Z_TEST_LESS;
      break;
   case GL_EQUAL:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_Z_TEST_EQUAL;
      break;
   case GL_LEQUAL:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_Z_TEST_LEQUAL;
      break;
   case GL_GREATER:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_Z_TEST_GREATER;
      break;
   case GL_NOTEQUAL:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_Z_TEST_NEQUAL;
      break;
   case GL_GEQUAL:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_Z_TEST_GEQUAL;
      break;
   case GL_ALWAYS:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_Z_TEST_ALWAYS;
      break;
   }
}


static void radeonDepthMask( struct gl_context *ctx, GLboolean flag )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   RADEON_STATECHANGE( rmesa, ctx );

   if ( ctx->Depth.Mask ) {
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |=  RADEON_Z_WRITE_ENABLE;
   } else {
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] &= ~RADEON_Z_WRITE_ENABLE;
   }
}


/* =============================================================
 * Fog
 */


static void radeonFogfv( struct gl_context *ctx, GLenum pname, const GLfloat *param )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   union { int i; float f; } c, d;
   GLubyte col[4];

   switch (pname) {
   case GL_FOG_MODE:
      if (!ctx->Fog.Enabled)
	 return;
      RADEON_STATECHANGE(rmesa, tcl);
      rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] &= ~RADEON_TCL_FOG_MASK;
      switch (ctx->Fog.Mode) {
      case GL_LINEAR:
	 rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] |= RADEON_TCL_FOG_LINEAR;
	 break;
      case GL_EXP:
	 rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] |= RADEON_TCL_FOG_EXP;
	 break;
      case GL_EXP2:
	 rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] |= RADEON_TCL_FOG_EXP2;
	 break;
      default:
	 return;
      }
   /* fallthrough */
   case GL_FOG_DENSITY:
   case GL_FOG_START:
   case GL_FOG_END:
      if (!ctx->Fog.Enabled)
	 return;
      c.i = rmesa->hw.fog.cmd[FOG_C];
      d.i = rmesa->hw.fog.cmd[FOG_D];
      switch (ctx->Fog.Mode) {
      case GL_EXP:
	 c.f = 0.0;
	 /* While this is the opposite sign from the DDK, it makes the fog test
	  * pass, and matches r200.
	  */
	 d.f = -ctx->Fog.Density;
	 break;
      case GL_EXP2:
	 c.f = 0.0;
	 d.f = -(ctx->Fog.Density * ctx->Fog.Density);
	 break;
      case GL_LINEAR:
	 if (ctx->Fog.Start == ctx->Fog.End) {
	    c.f = 1.0F;
	    d.f = 1.0F;
	 } else {
	    c.f = ctx->Fog.End/(ctx->Fog.End-ctx->Fog.Start);
	    /* While this is the opposite sign from the DDK, it makes the fog
	     * test pass, and matches r200.
	     */
	    d.f = -1.0/(ctx->Fog.End-ctx->Fog.Start);
	 }
	 break;
      default:
	 break;
      }
      if (c.i != rmesa->hw.fog.cmd[FOG_C] || d.i != rmesa->hw.fog.cmd[FOG_D]) {
	 RADEON_STATECHANGE( rmesa, fog );
	 rmesa->hw.fog.cmd[FOG_C] = c.i;
	 rmesa->hw.fog.cmd[FOG_D] = d.i;
      }
      break;
   case GL_FOG_COLOR:
      RADEON_STATECHANGE( rmesa, ctx );
      _mesa_unclamped_float_rgba_to_ubyte(col, ctx->Fog.Color );
      rmesa->hw.ctx.cmd[CTX_PP_FOG_COLOR] &= ~RADEON_FOG_COLOR_MASK;
      rmesa->hw.ctx.cmd[CTX_PP_FOG_COLOR] |=
	 radeonPackColor( 4, col[0], col[1], col[2], 0 );
      break;
   case GL_FOG_COORD_SRC:
      radeonUpdateSpecular( ctx );
      break;
   default:
      return;
   }
}

/* =============================================================
 * Culling
 */

static void radeonCullFace( struct gl_context *ctx, GLenum unused )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLuint s = rmesa->hw.set.cmd[SET_SE_CNTL];
   GLuint t = rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL];

   s |= RADEON_FFACE_SOLID | RADEON_BFACE_SOLID;
   t &= ~(RADEON_CULL_FRONT | RADEON_CULL_BACK);

   if ( ctx->Polygon.CullFlag ) {
      switch ( ctx->Polygon.CullFaceMode ) {
      case GL_FRONT:
	 s &= ~RADEON_FFACE_SOLID;
	 t |= RADEON_CULL_FRONT;
	 break;
      case GL_BACK:
	 s &= ~RADEON_BFACE_SOLID;
	 t |= RADEON_CULL_BACK;
	 break;
      case GL_FRONT_AND_BACK:
	 s &= ~(RADEON_FFACE_SOLID | RADEON_BFACE_SOLID);
	 t |= (RADEON_CULL_FRONT | RADEON_CULL_BACK);
	 break;
      }
   }

   if ( rmesa->hw.set.cmd[SET_SE_CNTL] != s ) {
      RADEON_STATECHANGE(rmesa, set );
      rmesa->hw.set.cmd[SET_SE_CNTL] = s;
   }

   if ( rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] != t ) {
      RADEON_STATECHANGE(rmesa, tcl );
      rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] = t;
   }
}

static void radeonFrontFace( struct gl_context *ctx, GLenum mode )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   int cull_face = (mode == GL_CW) ? RADEON_FFACE_CULL_CW : RADEON_FFACE_CULL_CCW;

   RADEON_STATECHANGE( rmesa, set );
   rmesa->hw.set.cmd[SET_SE_CNTL] &= ~RADEON_FFACE_CULL_DIR_MASK;

   RADEON_STATECHANGE( rmesa, tcl );
   rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] &= ~RADEON_CULL_FRONT_IS_CCW;

   /* Winding is inverted when rendering to FBO */
   if (ctx->DrawBuffer && _mesa_is_user_fbo(ctx->DrawBuffer))
      cull_face = (mode == GL_CCW) ? RADEON_FFACE_CULL_CW : RADEON_FFACE_CULL_CCW;
   rmesa->hw.set.cmd[SET_SE_CNTL] |= cull_face;

   if ( mode == GL_CCW )
      rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] |= RADEON_CULL_FRONT_IS_CCW;
}


/* =============================================================
 * Line state
 */
static void radeonLineWidth( struct gl_context *ctx, GLfloat widthf )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);

   RADEON_STATECHANGE( rmesa, lin );
   RADEON_STATECHANGE( rmesa, set );

   /* Line width is stored in U6.4 format.
    */
   rmesa->hw.lin.cmd[LIN_SE_LINE_WIDTH] = (GLuint)(widthf * 16.0);
   if ( widthf > 1.0 ) {
      rmesa->hw.set.cmd[SET_SE_CNTL] |=  RADEON_WIDELINE_ENABLE;
   } else {
      rmesa->hw.set.cmd[SET_SE_CNTL] &= ~RADEON_WIDELINE_ENABLE;
   }
}

static void radeonLineStipple( struct gl_context *ctx, GLint factor, GLushort pattern )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);

   RADEON_STATECHANGE( rmesa, lin );
   rmesa->hw.lin.cmd[LIN_RE_LINE_PATTERN] =
      ((((GLuint)factor & 0xff) << 16) | ((GLuint)pattern));
}


/* =============================================================
 * Masks
 */
static void radeonColorMask( struct gl_context *ctx,
			     GLboolean r, GLboolean g,
			     GLboolean b, GLboolean a )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   struct radeon_renderbuffer *rrb;
   GLuint mask;

   rrb = radeon_get_colorbuffer(&rmesa->radeon);
   if (!rrb)
     return;

   mask = radeonPackColor( rrb->cpp,
			   ctx->Color.ColorMask[0][RCOMP],
			   ctx->Color.ColorMask[0][GCOMP],
			   ctx->Color.ColorMask[0][BCOMP],
			   ctx->Color.ColorMask[0][ACOMP] );

   if ( rmesa->hw.msk.cmd[MSK_RB3D_PLANEMASK] != mask ) {
      RADEON_STATECHANGE( rmesa, msk );
      rmesa->hw.msk.cmd[MSK_RB3D_PLANEMASK] = mask;
   }
}


/* =============================================================
 * Polygon state
 */

static void radeonPolygonOffset( struct gl_context *ctx,
				 GLfloat factor, GLfloat units )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   const GLfloat depthScale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
   float_ui32_type constant =  { units * depthScale };
   float_ui32_type factoru = { factor };

   RADEON_STATECHANGE( rmesa, zbs );
   rmesa->hw.zbs.cmd[ZBS_SE_ZBIAS_FACTOR]   = factoru.ui32;
   rmesa->hw.zbs.cmd[ZBS_SE_ZBIAS_CONSTANT] = constant.ui32;
}

static void radeonPolygonMode( struct gl_context *ctx, GLenum face, GLenum mode )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLboolean unfilled = (ctx->Polygon.FrontMode != GL_FILL ||
                         ctx->Polygon.BackMode != GL_FILL);

   /* Can't generally do unfilled via tcl, but some good special
    * cases work.
    */
   TCL_FALLBACK( ctx, RADEON_TCL_FALLBACK_UNFILLED, unfilled);
   if (rmesa->radeon.TclFallback) {
      radeonChooseRenderState( ctx );
      radeonChooseVertexState( ctx );
   }
}


/* =============================================================
 * Rendering attributes
 *
 * We really don't want to recalculate all this every time we bind a
 * texture.  These things shouldn't change all that often, so it makes
 * sense to break them out of the core texture state update routines.
 */

/* Examine lighting and texture state to determine if separate specular
 * should be enabled.
 */
static void radeonUpdateSpecular( struct gl_context *ctx )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   uint32_t p = rmesa->hw.ctx.cmd[CTX_PP_CNTL];
   GLuint flag = 0;

   RADEON_STATECHANGE( rmesa, tcl );

   rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] &= ~RADEON_TCL_COMPUTE_SPECULAR;
   rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] &= ~RADEON_TCL_COMPUTE_DIFFUSE;
   rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] &= ~RADEON_TCL_VTX_PK_SPEC;
   rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] &= ~RADEON_TCL_VTX_PK_DIFFUSE;
   rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] &= ~RADEON_LIGHTING_ENABLE;

   p &= ~RADEON_SPECULAR_ENABLE;

   rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] |= RADEON_DIFFUSE_SPECULAR_COMBINE;


   if (ctx->Light.Enabled &&
       ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR) {
      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] |= RADEON_TCL_COMPUTE_SPECULAR;
      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] |= RADEON_TCL_COMPUTE_DIFFUSE;
      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_SPEC;
      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_DIFFUSE;
      rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] |= RADEON_LIGHTING_ENABLE;
      p |=  RADEON_SPECULAR_ENABLE;
      rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] &=
	 ~RADEON_DIFFUSE_SPECULAR_COMBINE;
   }
   else if (ctx->Light.Enabled) {
      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] |= RADEON_TCL_COMPUTE_DIFFUSE;
      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_DIFFUSE;
      rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] |= RADEON_LIGHTING_ENABLE;
   } else if (ctx->Fog.ColorSumEnabled ) {
      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_SPEC;
      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_DIFFUSE;
      p |= RADEON_SPECULAR_ENABLE;
   } else {
      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_DIFFUSE;
   }

   if (ctx->Fog.Enabled) {
      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_TCL_VTX_PK_SPEC;
      if (ctx->Fog.FogCoordinateSource == GL_FRAGMENT_DEPTH) {
	 rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] |= RADEON_TCL_COMPUTE_SPECULAR;
      /* Bizzare: have to leave lighting enabled to get fog. */
	 rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] |= RADEON_LIGHTING_ENABLE;
      }
      else {
      /* cannot do tcl fog factor calculation with fog coord source
       * (send precomputed factors). Cannot use precomputed fog
       * factors together with tcl spec light (need tcl fallback) */
	 flag = (rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] &
	    RADEON_TCL_COMPUTE_SPECULAR) != 0;
      }
   }

   TCL_FALLBACK( ctx, RADEON_TCL_FALLBACK_FOGCOORDSPEC, flag);

   if (_mesa_need_secondary_color(ctx)) {
      assert( (p & RADEON_SPECULAR_ENABLE) != 0 );
   } else {
      assert( (p & RADEON_SPECULAR_ENABLE) == 0 );
   }

   if ( rmesa->hw.ctx.cmd[CTX_PP_CNTL] != p ) {
      RADEON_STATECHANGE( rmesa, ctx );
      rmesa->hw.ctx.cmd[CTX_PP_CNTL] = p;
   }

   /* Update vertex/render formats
    */
   if (rmesa->radeon.TclFallback) {
      radeonChooseRenderState( ctx );
      radeonChooseVertexState( ctx );
   }
}


/* =============================================================
 * Materials
 */


/* Update on colormaterial, material emmissive/ambient,
 * lightmodel.globalambient
 */
static void update_global_ambient( struct gl_context *ctx )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   float *fcmd = (float *)RADEON_DB_STATE( glt );

   /* Need to do more if both emmissive & ambient are PREMULT:
    * Hope this is not needed for MULT
    */
   if ((rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] &
       ((3 << RADEON_EMISSIVE_SOURCE_SHIFT) |
	(3 << RADEON_AMBIENT_SOURCE_SHIFT))) == 0)
   {
      COPY_3V( &fcmd[GLT_RED],
	       ctx->Light.Material.Attrib[MAT_ATTRIB_FRONT_EMISSION]);
      ACC_SCALE_3V( &fcmd[GLT_RED],
		   ctx->Light.Model.Ambient,
		   ctx->Light.Material.Attrib[MAT_ATTRIB_FRONT_AMBIENT]);
   }
   else
   {
      COPY_3V( &fcmd[GLT_RED], ctx->Light.Model.Ambient );
   }

   RADEON_DB_STATECHANGE(rmesa, &rmesa->hw.glt);
}

/* Update on change to
 *    - light[p].colors
 *    - light[p].enabled
 */
static void update_light_colors( struct gl_context *ctx, GLuint p )
{
   struct gl_light *l = &ctx->Light.Light[p];

/*     fprintf(stderr, "%s\n", __FUNCTION__); */

   if (l->Enabled) {
      r100ContextPtr rmesa = R100_CONTEXT(ctx);
      float *fcmd = (float *)RADEON_DB_STATE( lit[p] );

      COPY_4V( &fcmd[LIT_AMBIENT_RED], l->Ambient );
      COPY_4V( &fcmd[LIT_DIFFUSE_RED], l->Diffuse );
      COPY_4V( &fcmd[LIT_SPECULAR_RED], l->Specular );

      RADEON_DB_STATECHANGE( rmesa, &rmesa->hw.lit[p] );
   }
}

/* Also fallback for asym colormaterial mode in twoside lighting...
 */
static void check_twoside_fallback( struct gl_context *ctx )
{
   GLboolean fallback = GL_FALSE;
   GLint i;

   if (ctx->Light.Enabled && ctx->Light.Model.TwoSide) {
      if (ctx->Light.ColorMaterialEnabled &&
	  (ctx->Light._ColorMaterialBitmask & BACK_MATERIAL_BITS) !=
	  ((ctx->Light._ColorMaterialBitmask & FRONT_MATERIAL_BITS)<<1))
	 fallback = GL_TRUE;
      else {
	 for (i = MAT_ATTRIB_FRONT_AMBIENT; i < MAT_ATTRIB_FRONT_INDEXES; i+=2)
	    if (memcmp( ctx->Light.Material.Attrib[i],
			ctx->Light.Material.Attrib[i+1],
			sizeof(GLfloat)*4) != 0) {
	       fallback = GL_TRUE;
	       break;
	    }
      }
   }

   TCL_FALLBACK( ctx, RADEON_TCL_FALLBACK_LIGHT_TWOSIDE, fallback );
}


static void radeonColorMaterial( struct gl_context *ctx, GLenum face, GLenum mode )
{
      r100ContextPtr rmesa = R100_CONTEXT(ctx);
      GLuint light_model_ctl1 = rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL];

      light_model_ctl1 &= ~((3 << RADEON_EMISSIVE_SOURCE_SHIFT) |
			   (3 << RADEON_AMBIENT_SOURCE_SHIFT) |
			   (3 << RADEON_DIFFUSE_SOURCE_SHIFT) |
			   (3 << RADEON_SPECULAR_SOURCE_SHIFT));

   if (ctx->Light.ColorMaterialEnabled) {
      GLuint mask = ctx->Light._ColorMaterialBitmask;

      if (mask & MAT_BIT_FRONT_EMISSION) {
	 light_model_ctl1 |= (RADEON_LM_SOURCE_VERTEX_DIFFUSE <<
			     RADEON_EMISSIVE_SOURCE_SHIFT);
      }
      else {
	 light_model_ctl1 |= (RADEON_LM_SOURCE_STATE_MULT <<
			     RADEON_EMISSIVE_SOURCE_SHIFT);
      }

      if (mask & MAT_BIT_FRONT_AMBIENT) {
	 light_model_ctl1 |= (RADEON_LM_SOURCE_VERTEX_DIFFUSE <<
			     RADEON_AMBIENT_SOURCE_SHIFT);
      }
      else {
	 light_model_ctl1 |= (RADEON_LM_SOURCE_STATE_MULT <<
			     RADEON_AMBIENT_SOURCE_SHIFT);
      }

      if (mask & MAT_BIT_FRONT_DIFFUSE) {
	 light_model_ctl1 |= (RADEON_LM_SOURCE_VERTEX_DIFFUSE <<
			     RADEON_DIFFUSE_SOURCE_SHIFT);
      }
      else {
	 light_model_ctl1 |= (RADEON_LM_SOURCE_STATE_MULT <<
			     RADEON_DIFFUSE_SOURCE_SHIFT);
      }

      if (mask & MAT_BIT_FRONT_SPECULAR) {
	 light_model_ctl1 |= (RADEON_LM_SOURCE_VERTEX_DIFFUSE <<
			     RADEON_SPECULAR_SOURCE_SHIFT);
      }
      else {
	 light_model_ctl1 |= (RADEON_LM_SOURCE_STATE_MULT <<
			     RADEON_SPECULAR_SOURCE_SHIFT);
      }
   }
   else {
   /* Default to MULT:
    */
      light_model_ctl1 |= (RADEON_LM_SOURCE_STATE_MULT << RADEON_EMISSIVE_SOURCE_SHIFT) |
		   (RADEON_LM_SOURCE_STATE_MULT << RADEON_AMBIENT_SOURCE_SHIFT) |
		   (RADEON_LM_SOURCE_STATE_MULT << RADEON_DIFFUSE_SOURCE_SHIFT) |
		   (RADEON_LM_SOURCE_STATE_MULT << RADEON_SPECULAR_SOURCE_SHIFT);
   }

      if (light_model_ctl1 != rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL]) {
	 RADEON_STATECHANGE( rmesa, tcl );
	 rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] = light_model_ctl1;
   }
}

void radeonUpdateMaterial( struct gl_context *ctx )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLfloat (*mat)[4] = ctx->Light.Material.Attrib;
   GLfloat *fcmd = (GLfloat *)RADEON_DB_STATE( mtl );
   GLuint mask = ~0;

   if (ctx->Light.ColorMaterialEnabled)
      mask &= ~ctx->Light._ColorMaterialBitmask;

   if (RADEON_DEBUG & RADEON_STATE)
      fprintf(stderr, "%s\n", __FUNCTION__);


   if (mask & MAT_BIT_FRONT_EMISSION) {
      fcmd[MTL_EMMISSIVE_RED]   = mat[MAT_ATTRIB_FRONT_EMISSION][0];
      fcmd[MTL_EMMISSIVE_GREEN] = mat[MAT_ATTRIB_FRONT_EMISSION][1];
      fcmd[MTL_EMMISSIVE_BLUE]  = mat[MAT_ATTRIB_FRONT_EMISSION][2];
      fcmd[MTL_EMMISSIVE_ALPHA] = mat[MAT_ATTRIB_FRONT_EMISSION][3];
   }
   if (mask & MAT_BIT_FRONT_AMBIENT) {
      fcmd[MTL_AMBIENT_RED]     = mat[MAT_ATTRIB_FRONT_AMBIENT][0];
      fcmd[MTL_AMBIENT_GREEN]   = mat[MAT_ATTRIB_FRONT_AMBIENT][1];
      fcmd[MTL_AMBIENT_BLUE]    = mat[MAT_ATTRIB_FRONT_AMBIENT][2];
      fcmd[MTL_AMBIENT_ALPHA]   = mat[MAT_ATTRIB_FRONT_AMBIENT][3];
   }
   if (mask & MAT_BIT_FRONT_DIFFUSE) {
      fcmd[MTL_DIFFUSE_RED]     = mat[MAT_ATTRIB_FRONT_DIFFUSE][0];
      fcmd[MTL_DIFFUSE_GREEN]   = mat[MAT_ATTRIB_FRONT_DIFFUSE][1];
      fcmd[MTL_DIFFUSE_BLUE]    = mat[MAT_ATTRIB_FRONT_DIFFUSE][2];
      fcmd[MTL_DIFFUSE_ALPHA]   = mat[MAT_ATTRIB_FRONT_DIFFUSE][3];
   }
   if (mask & MAT_BIT_FRONT_SPECULAR) {
      fcmd[MTL_SPECULAR_RED]    = mat[MAT_ATTRIB_FRONT_SPECULAR][0];
      fcmd[MTL_SPECULAR_GREEN]  = mat[MAT_ATTRIB_FRONT_SPECULAR][1];
      fcmd[MTL_SPECULAR_BLUE]   = mat[MAT_ATTRIB_FRONT_SPECULAR][2];
      fcmd[MTL_SPECULAR_ALPHA]  = mat[MAT_ATTRIB_FRONT_SPECULAR][3];
   }
   if (mask & MAT_BIT_FRONT_SHININESS) {
      fcmd[MTL_SHININESS]       = mat[MAT_ATTRIB_FRONT_SHININESS][0];
   }

   RADEON_DB_STATECHANGE( rmesa, &rmesa->hw.mtl );

   check_twoside_fallback( ctx );
/*   update_global_ambient( ctx );*/
}

/* _NEW_LIGHT
 * _NEW_MODELVIEW
 * _MESA_NEW_NEED_EYE_COORDS
 *
 * Uses derived state from mesa:
 *       _VP_inf_norm
 *       _h_inf_norm
 *       _Position
 *       _NormSpotDirection
 *       _ModelViewInvScale
 *       _NeedEyeCoords
 *       _EyeZDir
 *
 * which are calculated in light.c and are correct for the current
 * lighting space (model or eye), hence dependencies on _NEW_MODELVIEW
 * and _MESA_NEW_NEED_EYE_COORDS.
 */
static void update_light( struct gl_context *ctx )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);

   /* Have to check these, or have an automatic shortcircuit mechanism
    * to remove noop statechanges. (Or just do a better job on the
    * front end).
    */
   {
      GLuint tmp = rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL];

      if (ctx->_NeedEyeCoords)
	 tmp &= ~RADEON_LIGHT_IN_MODELSPACE;
      else
	 tmp |= RADEON_LIGHT_IN_MODELSPACE;


      /* Leave this test disabled: (unexplained q3 lockup) (even with
         new packets)
      */
      if (tmp != rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL])
      {
	 RADEON_STATECHANGE( rmesa, tcl );
	 rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] = tmp;
      }
   }

   {
      GLfloat *fcmd = (GLfloat *)RADEON_DB_STATE( eye );
      fcmd[EYE_X] = ctx->_EyeZDir[0];
      fcmd[EYE_Y] = ctx->_EyeZDir[1];
      fcmd[EYE_Z] = - ctx->_EyeZDir[2];
      fcmd[EYE_RESCALE_FACTOR] = ctx->_ModelViewInvScale;
      RADEON_DB_STATECHANGE( rmesa, &rmesa->hw.eye );
   }



   if (ctx->Light.Enabled) {
      GLint p;
      for (p = 0 ; p < MAX_LIGHTS; p++) {
	 if (ctx->Light.Light[p].Enabled) {
	    struct gl_light *l = &ctx->Light.Light[p];
	    GLfloat *fcmd = (GLfloat *)RADEON_DB_STATE( lit[p] );

	    if (l->EyePosition[3] == 0.0) {
	       COPY_3FV( &fcmd[LIT_POSITION_X], l->_VP_inf_norm );
	       COPY_3FV( &fcmd[LIT_DIRECTION_X], l->_h_inf_norm );
	       fcmd[LIT_POSITION_W] = 0;
	       fcmd[LIT_DIRECTION_W] = 0;
	    } else {
	       COPY_4V( &fcmd[LIT_POSITION_X], l->_Position );
	       fcmd[LIT_DIRECTION_X] = -l->_NormSpotDirection[0];
	       fcmd[LIT_DIRECTION_Y] = -l->_NormSpotDirection[1];
	       fcmd[LIT_DIRECTION_Z] = -l->_NormSpotDirection[2];
	       fcmd[LIT_DIRECTION_W] = 0;
	    }

	    RADEON_DB_STATECHANGE( rmesa, &rmesa->hw.lit[p] );
	 }
      }
   }
}

static void radeonLightfv( struct gl_context *ctx, GLenum light,
			   GLenum pname, const GLfloat *params )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLint p = light - GL_LIGHT0;
   struct gl_light *l = &ctx->Light.Light[p];
   GLfloat *fcmd = (GLfloat *)rmesa->hw.lit[p].cmd;


   switch (pname) {
   case GL_AMBIENT:
   case GL_DIFFUSE:
   case GL_SPECULAR:
      update_light_colors( ctx, p );
      break;

   case GL_SPOT_DIRECTION:
      /* picked up in update_light */
      break;

   case GL_POSITION: {
      /* positions picked up in update_light, but can do flag here */
      GLuint flag;
      GLuint idx = TCL_PER_LIGHT_CTL_0 + p/2;

      /* FIXME: Set RANGE_ATTEN only when needed */
      if (p&1)
	 flag = RADEON_LIGHT_1_IS_LOCAL;
      else
	 flag = RADEON_LIGHT_0_IS_LOCAL;

      RADEON_STATECHANGE(rmesa, tcl);
      if (l->EyePosition[3] != 0.0F)
	 rmesa->hw.tcl.cmd[idx] |= flag;
      else
	 rmesa->hw.tcl.cmd[idx] &= ~flag;
      break;
   }

   case GL_SPOT_EXPONENT:
      RADEON_STATECHANGE(rmesa, lit[p]);
      fcmd[LIT_SPOT_EXPONENT] = params[0];
      break;

   case GL_SPOT_CUTOFF: {
      GLuint flag = (p&1) ? RADEON_LIGHT_1_IS_SPOT : RADEON_LIGHT_0_IS_SPOT;
      GLuint idx = TCL_PER_LIGHT_CTL_0 + p/2;

      RADEON_STATECHANGE(rmesa, lit[p]);
      fcmd[LIT_SPOT_CUTOFF] = l->_CosCutoff;

      RADEON_STATECHANGE(rmesa, tcl);
      if (l->SpotCutoff != 180.0F)
	 rmesa->hw.tcl.cmd[idx] |= flag;
      else
	 rmesa->hw.tcl.cmd[idx] &= ~flag;

      break;
   }

   case GL_CONSTANT_ATTENUATION:
      RADEON_STATECHANGE(rmesa, lit[p]);
      fcmd[LIT_ATTEN_CONST] = params[0];
      if ( params[0] == 0.0 )
	 fcmd[LIT_ATTEN_CONST_INV] = FLT_MAX;
      else
	 fcmd[LIT_ATTEN_CONST_INV] = 1.0 / params[0];
      break;
   case GL_LINEAR_ATTENUATION:
      RADEON_STATECHANGE(rmesa, lit[p]);
      fcmd[LIT_ATTEN_LINEAR] = params[0];
      break;
   case GL_QUADRATIC_ATTENUATION:
      RADEON_STATECHANGE(rmesa, lit[p]);
      fcmd[LIT_ATTEN_QUADRATIC] = params[0];
      break;
   default:
      return;
   }

   /* Set RANGE_ATTEN only when needed */
   switch (pname) {
   case GL_POSITION:
   case GL_CONSTANT_ATTENUATION:
   case GL_LINEAR_ATTENUATION:
   case GL_QUADRATIC_ATTENUATION:
   {
      GLuint *icmd = (GLuint *)RADEON_DB_STATE( tcl );
      GLuint idx = TCL_PER_LIGHT_CTL_0 + p/2;
      GLuint atten_flag = ( p&1 ) ? RADEON_LIGHT_1_ENABLE_RANGE_ATTEN
				  : RADEON_LIGHT_0_ENABLE_RANGE_ATTEN;
      GLuint atten_const_flag = ( p&1 ) ? RADEON_LIGHT_1_CONSTANT_RANGE_ATTEN
				  : RADEON_LIGHT_0_CONSTANT_RANGE_ATTEN;

      if ( l->EyePosition[3] == 0.0F ||
	   ( ( fcmd[LIT_ATTEN_CONST] == 0.0 || fcmd[LIT_ATTEN_CONST] == 1.0 ) &&
	     fcmd[LIT_ATTEN_QUADRATIC] == 0.0 && fcmd[LIT_ATTEN_LINEAR] == 0.0 ) ) {
	 /* Disable attenuation */
	 icmd[idx] &= ~atten_flag;
      } else {
	 if ( fcmd[LIT_ATTEN_QUADRATIC] == 0.0 && fcmd[LIT_ATTEN_LINEAR] == 0.0 ) {
	    /* Enable only constant portion of attenuation calculation */
	    icmd[idx] |= ( atten_flag | atten_const_flag );
	 } else {
	    /* Enable full attenuation calculation */
	    icmd[idx] &= ~atten_const_flag;
	    icmd[idx] |= atten_flag;
	 }
      }

      RADEON_DB_STATECHANGE( rmesa, &rmesa->hw.tcl );
      break;
   }
   default:
      break;
   }
}




static void radeonLightModelfv( struct gl_context *ctx, GLenum pname,
				const GLfloat *param )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);

   switch (pname) {
      case GL_LIGHT_MODEL_AMBIENT:
	 update_global_ambient( ctx );
	 break;

      case GL_LIGHT_MODEL_LOCAL_VIEWER:
	 RADEON_STATECHANGE( rmesa, tcl );
	 if (ctx->Light.Model.LocalViewer)
	    rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] |= RADEON_LOCAL_VIEWER;
	 else
	    rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] &= ~RADEON_LOCAL_VIEWER;
         break;

      case GL_LIGHT_MODEL_TWO_SIDE:
	 RADEON_STATECHANGE( rmesa, tcl );
	 if (ctx->Light.Model.TwoSide)
	    rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] |= RADEON_LIGHT_TWOSIDE;
	 else
	    rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] &= ~RADEON_LIGHT_TWOSIDE;

	 check_twoside_fallback( ctx );

	 if (rmesa->radeon.TclFallback) {
	    radeonChooseRenderState( ctx );
	    radeonChooseVertexState( ctx );
	 }
         break;

      case GL_LIGHT_MODEL_COLOR_CONTROL:
	 radeonUpdateSpecular(ctx);
         break;

      default:
         break;
   }
}

static void radeonShadeModel( struct gl_context *ctx, GLenum mode )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLuint s = rmesa->hw.set.cmd[SET_SE_CNTL];

   s &= ~(RADEON_DIFFUSE_SHADE_MASK |
	  RADEON_ALPHA_SHADE_MASK |
	  RADEON_SPECULAR_SHADE_MASK |
	  RADEON_FOG_SHADE_MASK);

   switch ( mode ) {
   case GL_FLAT:
      s |= (RADEON_DIFFUSE_SHADE_FLAT |
	    RADEON_ALPHA_SHADE_FLAT |
	    RADEON_SPECULAR_SHADE_FLAT |
	    RADEON_FOG_SHADE_FLAT);
      break;
   case GL_SMOOTH:
      s |= (RADEON_DIFFUSE_SHADE_GOURAUD |
	    RADEON_ALPHA_SHADE_GOURAUD |
	    RADEON_SPECULAR_SHADE_GOURAUD |
	    RADEON_FOG_SHADE_GOURAUD);
      break;
   default:
      return;
   }

   if ( rmesa->hw.set.cmd[SET_SE_CNTL] != s ) {
      RADEON_STATECHANGE( rmesa, set );
      rmesa->hw.set.cmd[SET_SE_CNTL] = s;
   }
}


/* =============================================================
 * User clip planes
 */

static void radeonClipPlane( struct gl_context *ctx, GLenum plane, const GLfloat *eq )
{
   GLint p = (GLint) plane - (GLint) GL_CLIP_PLANE0;
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLint *ip = (GLint *)ctx->Transform._ClipUserPlane[p];

   RADEON_STATECHANGE( rmesa, ucp[p] );
   rmesa->hw.ucp[p].cmd[UCP_X] = ip[0];
   rmesa->hw.ucp[p].cmd[UCP_Y] = ip[1];
   rmesa->hw.ucp[p].cmd[UCP_Z] = ip[2];
   rmesa->hw.ucp[p].cmd[UCP_W] = ip[3];
}

static void radeonUpdateClipPlanes( struct gl_context *ctx )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLuint p;

   for (p = 0; p < ctx->Const.MaxClipPlanes; p++) {
      if (ctx->Transform.ClipPlanesEnabled & (1 << p)) {
	 GLint *ip = (GLint *)ctx->Transform._ClipUserPlane[p];

	 RADEON_STATECHANGE( rmesa, ucp[p] );
	 rmesa->hw.ucp[p].cmd[UCP_X] = ip[0];
	 rmesa->hw.ucp[p].cmd[UCP_Y] = ip[1];
	 rmesa->hw.ucp[p].cmd[UCP_Z] = ip[2];
	 rmesa->hw.ucp[p].cmd[UCP_W] = ip[3];
      }
   }
}


/* =============================================================
 * Stencil
 */

static void
radeonStencilFuncSeparate( struct gl_context *ctx, GLenum face, GLenum func,
                           GLint ref, GLuint mask )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLuint refmask = ((_mesa_get_stencil_ref(ctx, 0) << RADEON_STENCIL_REF_SHIFT) |
		     ((ctx->Stencil.ValueMask[0] & 0xff) << RADEON_STENCIL_MASK_SHIFT));

   RADEON_STATECHANGE( rmesa, ctx );
   RADEON_STATECHANGE( rmesa, msk );

   rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] &= ~RADEON_STENCIL_TEST_MASK;
   rmesa->hw.msk.cmd[MSK_RB3D_STENCILREFMASK] &= ~(RADEON_STENCIL_REF_MASK|
						   RADEON_STENCIL_VALUE_MASK);

   switch ( ctx->Stencil.Function[0] ) {
   case GL_NEVER:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_TEST_NEVER;
      break;
   case GL_LESS:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_TEST_LESS;
      break;
   case GL_EQUAL:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_TEST_EQUAL;
      break;
   case GL_LEQUAL:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_TEST_LEQUAL;
      break;
   case GL_GREATER:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_TEST_GREATER;
      break;
   case GL_NOTEQUAL:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_TEST_NEQUAL;
      break;
   case GL_GEQUAL:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_TEST_GEQUAL;
      break;
   case GL_ALWAYS:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_TEST_ALWAYS;
      break;
   }

   rmesa->hw.msk.cmd[MSK_RB3D_STENCILREFMASK] |= refmask;
}

static void
radeonStencilMaskSeparate( struct gl_context *ctx, GLenum face, GLuint mask )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);

   RADEON_STATECHANGE( rmesa, msk );
   rmesa->hw.msk.cmd[MSK_RB3D_STENCILREFMASK] &= ~RADEON_STENCIL_WRITE_MASK;
   rmesa->hw.msk.cmd[MSK_RB3D_STENCILREFMASK] |=
      ((ctx->Stencil.WriteMask[0] & 0xff) << RADEON_STENCIL_WRITEMASK_SHIFT);
}

static void radeonStencilOpSeparate( struct gl_context *ctx, GLenum face, GLenum fail,
                                     GLenum zfail, GLenum zpass )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);

   /* radeon 7200 have stencil bug, DEC and INC_WRAP will actually both do DEC_WRAP,
      and DEC_WRAP (and INVERT) will do INVERT. No way to get correct INC_WRAP and DEC,
      but DEC_WRAP can be fixed by using DEC and INC_WRAP at least use INC. */

   GLuint tempRADEON_STENCIL_FAIL_DEC_WRAP;
   GLuint tempRADEON_STENCIL_FAIL_INC_WRAP;
   GLuint tempRADEON_STENCIL_ZFAIL_DEC_WRAP;
   GLuint tempRADEON_STENCIL_ZFAIL_INC_WRAP;
   GLuint tempRADEON_STENCIL_ZPASS_DEC_WRAP;
   GLuint tempRADEON_STENCIL_ZPASS_INC_WRAP;

   if (rmesa->radeon.radeonScreen->chip_flags & RADEON_CHIPSET_BROKEN_STENCIL) {
      tempRADEON_STENCIL_FAIL_DEC_WRAP = RADEON_STENCIL_FAIL_DEC;
      tempRADEON_STENCIL_FAIL_INC_WRAP = RADEON_STENCIL_FAIL_INC;
      tempRADEON_STENCIL_ZFAIL_DEC_WRAP = RADEON_STENCIL_ZFAIL_DEC;
      tempRADEON_STENCIL_ZFAIL_INC_WRAP = RADEON_STENCIL_ZFAIL_INC;
      tempRADEON_STENCIL_ZPASS_DEC_WRAP = RADEON_STENCIL_ZPASS_DEC;
      tempRADEON_STENCIL_ZPASS_INC_WRAP = RADEON_STENCIL_ZPASS_INC;
   }
   else {
      tempRADEON_STENCIL_FAIL_DEC_WRAP = RADEON_STENCIL_FAIL_DEC_WRAP;
      tempRADEON_STENCIL_FAIL_INC_WRAP = RADEON_STENCIL_FAIL_INC_WRAP;
      tempRADEON_STENCIL_ZFAIL_DEC_WRAP = RADEON_STENCIL_ZFAIL_DEC_WRAP;
      tempRADEON_STENCIL_ZFAIL_INC_WRAP = RADEON_STENCIL_ZFAIL_INC_WRAP;
      tempRADEON_STENCIL_ZPASS_DEC_WRAP = RADEON_STENCIL_ZPASS_DEC_WRAP;
      tempRADEON_STENCIL_ZPASS_INC_WRAP = RADEON_STENCIL_ZPASS_INC_WRAP;
   }

   RADEON_STATECHANGE( rmesa, ctx );
   rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] &= ~(RADEON_STENCIL_FAIL_MASK |
					       RADEON_STENCIL_ZFAIL_MASK |
					       RADEON_STENCIL_ZPASS_MASK);

   switch ( ctx->Stencil.FailFunc[0] ) {
   case GL_KEEP:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_FAIL_KEEP;
      break;
   case GL_ZERO:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_FAIL_ZERO;
      break;
   case GL_REPLACE:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_FAIL_REPLACE;
      break;
   case GL_INCR:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_FAIL_INC;
      break;
   case GL_DECR:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_FAIL_DEC;
      break;
   case GL_INCR_WRAP:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= tempRADEON_STENCIL_FAIL_INC_WRAP;
      break;
   case GL_DECR_WRAP:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= tempRADEON_STENCIL_FAIL_DEC_WRAP;
      break;
   case GL_INVERT:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_FAIL_INVERT;
      break;
   }

   switch ( ctx->Stencil.ZFailFunc[0] ) {
   case GL_KEEP:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_ZFAIL_KEEP;
      break;
   case GL_ZERO:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_ZFAIL_ZERO;
      break;
   case GL_REPLACE:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_ZFAIL_REPLACE;
      break;
   case GL_INCR:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_ZFAIL_INC;
      break;
   case GL_DECR:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_ZFAIL_DEC;
      break;
   case GL_INCR_WRAP:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= tempRADEON_STENCIL_ZFAIL_INC_WRAP;
      break;
   case GL_DECR_WRAP:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= tempRADEON_STENCIL_ZFAIL_DEC_WRAP;
      break;
   case GL_INVERT:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_ZFAIL_INVERT;
      break;
   }

   switch ( ctx->Stencil.ZPassFunc[0] ) {
   case GL_KEEP:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_ZPASS_KEEP;
      break;
   case GL_ZERO:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_ZPASS_ZERO;
      break;
   case GL_REPLACE:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_ZPASS_REPLACE;
      break;
   case GL_INCR:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_ZPASS_INC;
      break;
   case GL_DECR:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_ZPASS_DEC;
      break;
   case GL_INCR_WRAP:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= tempRADEON_STENCIL_ZPASS_INC_WRAP;
      break;
   case GL_DECR_WRAP:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= tempRADEON_STENCIL_ZPASS_DEC_WRAP;
      break;
   case GL_INVERT:
      rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] |= RADEON_STENCIL_ZPASS_INVERT;
      break;
   }
}



/* =============================================================
 * Window position and viewport transformation
 */

/*
 * To correctly position primitives:
 */
#define SUBPIXEL_X 0.125
#define SUBPIXEL_Y 0.125


/**
 * Called when window size or position changes or viewport or depth range
 * state is changed.  We update the hardware viewport state here.
 */
void radeonUpdateWindow( struct gl_context *ctx )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   __DRIdrawable *dPriv = radeon_get_drawable(&rmesa->radeon);
   GLfloat xoffset = 0.0;
   GLfloat yoffset = dPriv ? (GLfloat) dPriv->h : 0;
   const GLfloat *v = ctx->ViewportArray[0]._WindowMap.m;
   const GLboolean render_to_fbo = (ctx->DrawBuffer ? _mesa_is_user_fbo(ctx->DrawBuffer) : 0);
   const GLfloat depthScale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
   GLfloat y_scale, y_bias;

   if (render_to_fbo) {
      y_scale = 1.0;
      y_bias = 0;
   } else {
      y_scale = -1.0;
      y_bias = yoffset;
   }

   float_ui32_type sx = { v[MAT_SX] };
   float_ui32_type tx = { v[MAT_TX] + xoffset + SUBPIXEL_X };
   float_ui32_type sy = { v[MAT_SY] * y_scale };
   float_ui32_type ty = { (v[MAT_TY] * y_scale) + y_bias + SUBPIXEL_Y };
   float_ui32_type sz = { v[MAT_SZ] * depthScale };
   float_ui32_type tz = { v[MAT_TZ] * depthScale };

   RADEON_STATECHANGE( rmesa, vpt );

   rmesa->hw.vpt.cmd[VPT_SE_VPORT_XSCALE]  = sx.ui32;
   rmesa->hw.vpt.cmd[VPT_SE_VPORT_XOFFSET] = tx.ui32;
   rmesa->hw.vpt.cmd[VPT_SE_VPORT_YSCALE]  = sy.ui32;
   rmesa->hw.vpt.cmd[VPT_SE_VPORT_YOFFSET] = ty.ui32;
   rmesa->hw.vpt.cmd[VPT_SE_VPORT_ZSCALE]  = sz.ui32;
   rmesa->hw.vpt.cmd[VPT_SE_VPORT_ZOFFSET] = tz.ui32;
}


static void radeonViewport(struct gl_context *ctx)
{
   /* Don't pipeline viewport changes, conflict with window offset
    * setting below.  Could apply deltas to rescue pipelined viewport
    * values, or keep the originals hanging around.
    */
   radeonUpdateWindow( ctx );

   radeon_viewport(ctx);
}

static void radeonDepthRange(struct gl_context *ctx)
{
   radeonUpdateWindow( ctx );
}

void radeonUpdateViewportOffset( struct gl_context *ctx )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   __DRIdrawable *dPriv = radeon_get_drawable(&rmesa->radeon);
   GLfloat xoffset = 0.0;
   GLfloat yoffset = (GLfloat)dPriv->h;
   const GLfloat *v = ctx->ViewportArray[0]._WindowMap.m;

   float_ui32_type tx;
   float_ui32_type ty;

   tx.f = v[MAT_TX] + xoffset + SUBPIXEL_X;
   ty.f = (- v[MAT_TY]) + yoffset + SUBPIXEL_Y;

   if ( rmesa->hw.vpt.cmd[VPT_SE_VPORT_XOFFSET] != tx.ui32 ||
	rmesa->hw.vpt.cmd[VPT_SE_VPORT_YOFFSET] != ty.ui32 )
   {
      /* Note: this should also modify whatever data the context reset
       * code uses...
       */
      RADEON_STATECHANGE( rmesa, vpt );
      rmesa->hw.vpt.cmd[VPT_SE_VPORT_XOFFSET] = tx.ui32;
      rmesa->hw.vpt.cmd[VPT_SE_VPORT_YOFFSET] = ty.ui32;

      /* update polygon stipple x/y screen offset */
      {
         GLuint stx, sty;
         GLuint m = rmesa->hw.msc.cmd[MSC_RE_MISC];

         m &= ~(RADEON_STIPPLE_X_OFFSET_MASK |
                RADEON_STIPPLE_Y_OFFSET_MASK);

         /* add magic offsets, then invert */
         stx = 31 - ((-1) & RADEON_STIPPLE_COORD_MASK);
         sty = 31 - ((dPriv->h - 1)
                     & RADEON_STIPPLE_COORD_MASK);

         m |= ((stx << RADEON_STIPPLE_X_OFFSET_SHIFT) |
               (sty << RADEON_STIPPLE_Y_OFFSET_SHIFT));

         if ( rmesa->hw.msc.cmd[MSC_RE_MISC] != m ) {
            RADEON_STATECHANGE( rmesa, msc );
	    rmesa->hw.msc.cmd[MSC_RE_MISC] = m;
         }
      }
   }

   radeonUpdateScissor( ctx );
}



/* =============================================================
 * Miscellaneous
 */

static void radeonRenderMode( struct gl_context *ctx, GLenum mode )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   FALLBACK( rmesa, RADEON_FALLBACK_RENDER_MODE, (mode != GL_RENDER) );
}


static GLuint radeon_rop_tab[] = {
   RADEON_ROP_CLEAR,
   RADEON_ROP_AND,
   RADEON_ROP_AND_REVERSE,
   RADEON_ROP_COPY,
   RADEON_ROP_AND_INVERTED,
   RADEON_ROP_NOOP,
   RADEON_ROP_XOR,
   RADEON_ROP_OR,
   RADEON_ROP_NOR,
   RADEON_ROP_EQUIV,
   RADEON_ROP_INVERT,
   RADEON_ROP_OR_REVERSE,
   RADEON_ROP_COPY_INVERTED,
   RADEON_ROP_OR_INVERTED,
   RADEON_ROP_NAND,
   RADEON_ROP_SET,
};

static void radeonLogicOpCode( struct gl_context *ctx, GLenum opcode )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLuint rop = (GLuint)opcode - GL_CLEAR;

   ASSERT( rop < 16 );

   RADEON_STATECHANGE( rmesa, msk );
   rmesa->hw.msk.cmd[MSK_RB3D_ROPCNTL] = radeon_rop_tab[rop];
}

/* =============================================================
 * State enable/disable
 */

static void radeonEnable( struct gl_context *ctx, GLenum cap, GLboolean state )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLuint p, flag;

   if ( RADEON_DEBUG & RADEON_STATE )
      fprintf( stderr, "%s( %s = %s )\n", __FUNCTION__,
	       _mesa_lookup_enum_by_nr( cap ),
	       state ? "GL_TRUE" : "GL_FALSE" );

   switch ( cap ) {
      /* Fast track this one...
       */
   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_TEXTURE_3D:
      break;

   case GL_ALPHA_TEST:
      RADEON_STATECHANGE( rmesa, ctx );
      if (state) {
	 rmesa->hw.ctx.cmd[CTX_PP_CNTL] |= RADEON_ALPHA_TEST_ENABLE;
      } else {
	 rmesa->hw.ctx.cmd[CTX_PP_CNTL] &= ~RADEON_ALPHA_TEST_ENABLE;
      }
      break;

   case GL_BLEND:
      RADEON_STATECHANGE( rmesa, ctx );
      if (state) {
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] |=  RADEON_ALPHA_BLEND_ENABLE;
      } else {
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] &= ~RADEON_ALPHA_BLEND_ENABLE;
      }
      if ( (ctx->Color.ColorLogicOpEnabled || (ctx->Color.BlendEnabled
	    && ctx->Color.Blend[0].EquationRGB == GL_LOGIC_OP)) ) {
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] |=  RADEON_ROP_ENABLE;
      } else {
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] &= ~RADEON_ROP_ENABLE;
      }

      /* Catch a possible fallback:
       */
      if (state) {
	 ctx->Driver.BlendEquationSeparate( ctx,
					    ctx->Color.Blend[0].EquationRGB,
					    ctx->Color.Blend[0].EquationA );
	 ctx->Driver.BlendFuncSeparate( ctx, ctx->Color.Blend[0].SrcRGB,
					ctx->Color.Blend[0].DstRGB,
					ctx->Color.Blend[0].SrcA,
					ctx->Color.Blend[0].DstA );
      }
      else {
	 FALLBACK( rmesa, RADEON_FALLBACK_BLEND_FUNC, GL_FALSE );
	 FALLBACK( rmesa, RADEON_FALLBACK_BLEND_EQ, GL_FALSE );
      }
      break;

   case GL_CLIP_PLANE0:
   case GL_CLIP_PLANE1:
   case GL_CLIP_PLANE2:
   case GL_CLIP_PLANE3:
   case GL_CLIP_PLANE4:
   case GL_CLIP_PLANE5:
      p = cap-GL_CLIP_PLANE0;
      RADEON_STATECHANGE( rmesa, tcl );
      if (state) {
	 rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] |= (RADEON_UCP_ENABLE_0<<p);
	 radeonClipPlane( ctx, cap, NULL );
      }
      else {
	 rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] &= ~(RADEON_UCP_ENABLE_0<<p);
      }
      break;

   case GL_COLOR_MATERIAL:
      radeonColorMaterial( ctx, 0, 0 );
      radeonUpdateMaterial( ctx );
      break;

   case GL_CULL_FACE:
      radeonCullFace( ctx, 0 );
      break;

   case GL_DEPTH_TEST:
      RADEON_STATECHANGE(rmesa, ctx );
      if ( state ) {
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] |=  RADEON_Z_ENABLE;
      } else {
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] &= ~RADEON_Z_ENABLE;
      }
      break;

   case GL_DITHER:
      RADEON_STATECHANGE(rmesa, ctx );
      if ( state ) {
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] |=  RADEON_DITHER_ENABLE;
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] &= ~rmesa->radeon.state.color.roundEnable;
      } else {
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] &= ~RADEON_DITHER_ENABLE;
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] |=  rmesa->radeon.state.color.roundEnable;
      }
      break;

   case GL_FOG:
      RADEON_STATECHANGE(rmesa, ctx );
      if ( state ) {
	 rmesa->hw.ctx.cmd[CTX_PP_CNTL] |= RADEON_FOG_ENABLE;
	 radeonFogfv( ctx, GL_FOG_MODE, NULL );
      } else {
	 rmesa->hw.ctx.cmd[CTX_PP_CNTL] &= ~RADEON_FOG_ENABLE;
	 RADEON_STATECHANGE(rmesa, tcl);
	 rmesa->hw.tcl.cmd[TCL_UCP_VERT_BLEND_CTL] &= ~RADEON_TCL_FOG_MASK;
      }
      radeonUpdateSpecular( ctx ); /* for PK_SPEC */
      _mesa_allow_light_in_model( ctx, !state );
      break;

   case GL_LIGHT0:
   case GL_LIGHT1:
   case GL_LIGHT2:
   case GL_LIGHT3:
   case GL_LIGHT4:
   case GL_LIGHT5:
   case GL_LIGHT6:
   case GL_LIGHT7:
      RADEON_STATECHANGE(rmesa, tcl);
      p = cap - GL_LIGHT0;
      if (p&1)
	 flag = (RADEON_LIGHT_1_ENABLE |
		 RADEON_LIGHT_1_ENABLE_AMBIENT |
		 RADEON_LIGHT_1_ENABLE_SPECULAR);
      else
	 flag = (RADEON_LIGHT_0_ENABLE |
		 RADEON_LIGHT_0_ENABLE_AMBIENT |
		 RADEON_LIGHT_0_ENABLE_SPECULAR);

      if (state)
	 rmesa->hw.tcl.cmd[p/2 + TCL_PER_LIGHT_CTL_0] |= flag;
      else
	 rmesa->hw.tcl.cmd[p/2 + TCL_PER_LIGHT_CTL_0] &= ~flag;

      /*
       */
      update_light_colors( ctx, p );
      break;

   case GL_LIGHTING:
      RADEON_STATECHANGE(rmesa, tcl);
      radeonUpdateSpecular(ctx);
      check_twoside_fallback( ctx );
      break;

   case GL_LINE_SMOOTH:
      RADEON_STATECHANGE( rmesa, ctx );
      if ( state ) {
	 rmesa->hw.ctx.cmd[CTX_PP_CNTL] |=  RADEON_ANTI_ALIAS_LINE;
      } else {
	 rmesa->hw.ctx.cmd[CTX_PP_CNTL] &= ~RADEON_ANTI_ALIAS_LINE;
      }
      break;

   case GL_LINE_STIPPLE:
      RADEON_STATECHANGE( rmesa, ctx );
      if ( state ) {
	 rmesa->hw.ctx.cmd[CTX_PP_CNTL] |=  RADEON_PATTERN_ENABLE;
      } else {
	 rmesa->hw.ctx.cmd[CTX_PP_CNTL] &= ~RADEON_PATTERN_ENABLE;
      }
      break;

   case GL_COLOR_LOGIC_OP:
      RADEON_STATECHANGE( rmesa, ctx );
      if ( (ctx->Color.ColorLogicOpEnabled || (ctx->Color.BlendEnabled
	    && ctx->Color.Blend[0].EquationRGB == GL_LOGIC_OP)) ) {
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] |=  RADEON_ROP_ENABLE;
      } else {
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] &= ~RADEON_ROP_ENABLE;
      }
      break;

   case GL_NORMALIZE:
      RADEON_STATECHANGE( rmesa, tcl );
      if ( state ) {
	 rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] |=  RADEON_NORMALIZE_NORMALS;
      } else {
	 rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] &= ~RADEON_NORMALIZE_NORMALS;
      }
      break;

   case GL_POLYGON_OFFSET_POINT:
      RADEON_STATECHANGE( rmesa, set );
      if ( state ) {
	 rmesa->hw.set.cmd[SET_SE_CNTL] |=  RADEON_ZBIAS_ENABLE_POINT;
      } else {
	 rmesa->hw.set.cmd[SET_SE_CNTL] &= ~RADEON_ZBIAS_ENABLE_POINT;
      }
      break;

   case GL_POLYGON_OFFSET_LINE:
      RADEON_STATECHANGE( rmesa, set );
      if ( state ) {
	 rmesa->hw.set.cmd[SET_SE_CNTL] |=  RADEON_ZBIAS_ENABLE_LINE;
      } else {
	 rmesa->hw.set.cmd[SET_SE_CNTL] &= ~RADEON_ZBIAS_ENABLE_LINE;
      }
      break;

   case GL_POLYGON_OFFSET_FILL:
      RADEON_STATECHANGE( rmesa, set );
      if ( state ) {
	 rmesa->hw.set.cmd[SET_SE_CNTL] |=  RADEON_ZBIAS_ENABLE_TRI;
      } else {
	 rmesa->hw.set.cmd[SET_SE_CNTL] &= ~RADEON_ZBIAS_ENABLE_TRI;
      }
      break;

   case GL_POLYGON_SMOOTH:
      RADEON_STATECHANGE( rmesa, ctx );
      if ( state ) {
	 rmesa->hw.ctx.cmd[CTX_PP_CNTL] |=  RADEON_ANTI_ALIAS_POLY;
      } else {
	 rmesa->hw.ctx.cmd[CTX_PP_CNTL] &= ~RADEON_ANTI_ALIAS_POLY;
      }
      break;

   case GL_POLYGON_STIPPLE:
      RADEON_STATECHANGE(rmesa, ctx );
      if ( state ) {
	 rmesa->hw.ctx.cmd[CTX_PP_CNTL] |=  RADEON_STIPPLE_ENABLE;
      } else {
	 rmesa->hw.ctx.cmd[CTX_PP_CNTL] &= ~RADEON_STIPPLE_ENABLE;
      }
      break;

   case GL_RESCALE_NORMAL_EXT: {
      GLboolean tmp = ctx->_NeedEyeCoords ? state : !state;
      RADEON_STATECHANGE( rmesa, tcl );
      if ( tmp ) {
	 rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] |=  RADEON_RESCALE_NORMALS;
      } else {
	 rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] &= ~RADEON_RESCALE_NORMALS;
      }
      break;
   }

   case GL_SCISSOR_TEST:
      radeon_firevertices(&rmesa->radeon);
      rmesa->radeon.state.scissor.enabled = state;
      radeonUpdateScissor( ctx );
      break;

   case GL_STENCIL_TEST:
      {
	 GLboolean hw_stencil = GL_FALSE;
	 if (ctx->DrawBuffer) {
	    struct radeon_renderbuffer *rrbStencil
	       = radeon_get_renderbuffer(ctx->DrawBuffer, BUFFER_STENCIL);
	    hw_stencil = (rrbStencil && rrbStencil->bo);
	 }

	 if (hw_stencil) {
	    RADEON_STATECHANGE( rmesa, ctx );
	    if ( state ) {
	       rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] |=  RADEON_STENCIL_ENABLE;
	    } else {
	       rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] &= ~RADEON_STENCIL_ENABLE;
	    }
	 } else {
	    FALLBACK( rmesa, RADEON_FALLBACK_STENCIL, state );
	 }
      }
      break;

   case GL_TEXTURE_GEN_Q:
   case GL_TEXTURE_GEN_R:
   case GL_TEXTURE_GEN_S:
   case GL_TEXTURE_GEN_T:
      /* Picked up in radeonUpdateTextureState.
       */
      rmesa->recheck_texgen[ctx->Texture.CurrentUnit] = GL_TRUE;
      break;

   case GL_COLOR_SUM_EXT:
      radeonUpdateSpecular ( ctx );
      break;

   default:
      return;
   }
}


static void radeonLightingSpaceChange( struct gl_context *ctx )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLboolean tmp;
   RADEON_STATECHANGE( rmesa, tcl );

   if (RADEON_DEBUG & RADEON_STATE)
      fprintf(stderr, "%s %d BEFORE %x\n", __FUNCTION__, ctx->_NeedEyeCoords,
	      rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL]);

   if (ctx->_NeedEyeCoords)
      tmp = ctx->Transform.RescaleNormals;
   else
      tmp = !ctx->Transform.RescaleNormals;

   if ( tmp ) {
      rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] |=  RADEON_RESCALE_NORMALS;
   } else {
      rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] &= ~RADEON_RESCALE_NORMALS;
   }

   if (RADEON_DEBUG & RADEON_STATE)
      fprintf(stderr, "%s %d AFTER %x\n", __FUNCTION__, ctx->_NeedEyeCoords,
	      rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL]);
}

/* =============================================================
 * Deferred state management - matrices, textures, other?
 */


void radeonUploadTexMatrix( r100ContextPtr rmesa,
			    int unit, GLboolean swapcols )
{
/* Here's how this works: on r100, only 3 tex coords can be submitted, so the
   vector looks like this probably: (s t r|q 0) (not sure if the last coord
   is hardwired to 0, could be 1 too). Interestingly, it actually looks like
   texgen generates all 4 coords, at least tests with projtex indicated that.
   So: if we need the q coord in the end (solely determined by the texture
   target, i.e. 2d / 1d / texrect targets) we swap the third and 4th row.
   Additionally, if we don't have texgen but 4 tex coords submitted, we swap
   column 3 and 4 (for the 2d / 1d / texrect targets) since the q coord
   will get submitted in the "wrong", i.e. 3rd, slot.
   If an app submits 3 coords for 2d targets, we assume it is saving on vertex
   size and using the texture matrix to swap the r and q coords around (ut2k3
   does exactly that), so we don't need the 3rd / 4th column swap - still need
   the 3rd / 4th row swap of course. This will potentially break for apps which
   use TexCoord3x just for fun. Additionally, it will never work if an app uses
   an "advanced" texture matrix and relies on all 4 texcoord inputs to generate
   the maximum needed 3. This seems impossible to do with hw tcl on r100, and
   incredibly hard to detect so we can't just fallback in such a case. Assume
   it never happens... - rs
*/

   int idx = TEXMAT_0 + unit;
   float *dest = ((float *)RADEON_DB_STATE( mat[idx] )) + MAT_ELT_0;
   int i;
   struct gl_texture_unit tUnit = rmesa->radeon.glCtx.Texture.Unit[unit];
   GLfloat *src = rmesa->tmpmat[unit].m;

   rmesa->TexMatColSwap &= ~(1 << unit);
   if (!tUnit._Current ||
       (tUnit._Current->Target != GL_TEXTURE_3D &&
        tUnit._Current->Target != GL_TEXTURE_CUBE_MAP)) {
      if (swapcols) {
	 rmesa->TexMatColSwap |= 1 << unit;
	 /* attention some elems are swapped 2 times! */
	 *dest++ = src[0];
	 *dest++ = src[4];
	 *dest++ = src[12];
	 *dest++ = src[8];
	 *dest++ = src[1];
	 *dest++ = src[5];
	 *dest++ = src[13];
	 *dest++ = src[9];
	 *dest++ = src[2];
	 *dest++ = src[6];
	 *dest++ = src[15];
	 *dest++ = src[11];
	 /* those last 4 are probably never used */
	 *dest++ = src[3];
	 *dest++ = src[7];
	 *dest++ = src[14];
	 *dest++ = src[10];
      }
      else {
	 for (i = 0; i < 2; i++) {
	    *dest++ = src[i];
	    *dest++ = src[i+4];
	    *dest++ = src[i+8];
	    *dest++ = src[i+12];
	 }
	 for (i = 3; i >= 2; i--) {
	    *dest++ = src[i];
	    *dest++ = src[i+4];
	    *dest++ = src[i+8];
	    *dest++ = src[i+12];
	 }
      }
   }
   else {
      for (i = 0 ; i < 4 ; i++) {
	 *dest++ = src[i];
	 *dest++ = src[i+4];
	 *dest++ = src[i+8];
	 *dest++ = src[i+12];
      }
   }

   RADEON_DB_STATECHANGE( rmesa, &rmesa->hw.mat[idx] );
}


static void upload_matrix( r100ContextPtr rmesa, GLfloat *src, int idx )
{
   float *dest = ((float *)RADEON_DB_STATE( mat[idx] ))+MAT_ELT_0;
   int i;


   for (i = 0 ; i < 4 ; i++) {
      *dest++ = src[i];
      *dest++ = src[i+4];
      *dest++ = src[i+8];
      *dest++ = src[i+12];
   }

   RADEON_DB_STATECHANGE( rmesa, &rmesa->hw.mat[idx] );
}

static void upload_matrix_t( r100ContextPtr rmesa, GLfloat *src, int idx )
{
   float *dest = ((float *)RADEON_DB_STATE( mat[idx] ))+MAT_ELT_0;
   memcpy(dest, src, 16*sizeof(float));
   RADEON_DB_STATECHANGE( rmesa, &rmesa->hw.mat[idx] );
}


static void update_texturematrix( struct gl_context *ctx )
{
   r100ContextPtr rmesa = R100_CONTEXT( ctx );
   GLuint tpc = rmesa->hw.tcl.cmd[TCL_TEXTURE_PROC_CTL];
   GLuint vs = rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL];
   int unit;
   GLuint texMatEnabled = 0;
   rmesa->NeedTexMatrix = 0;
   rmesa->TexMatColSwap = 0;

   for (unit = 0 ; unit < ctx->Const.MaxTextureUnits; unit++) {
      if (ctx->Texture.Unit[unit]._Current) {
	 GLboolean needMatrix = GL_FALSE;
	 if (ctx->TextureMatrixStack[unit].Top->type != MATRIX_IDENTITY) {
	    needMatrix = GL_TRUE;
	    texMatEnabled |= (RADEON_TEXGEN_TEXMAT_0_ENABLE |
			      RADEON_TEXMAT_0_ENABLE) << unit;

	    if (rmesa->TexGenEnabled & (RADEON_TEXMAT_0_ENABLE << unit)) {
	       /* Need to preconcatenate any active texgen
	        * obj/eyeplane matrices:
	        */
	       _math_matrix_mul_matrix( &rmesa->tmpmat[unit],
				     ctx->TextureMatrixStack[unit].Top,
				     &rmesa->TexGenMatrix[unit] );
	    }
	    else {
	       _math_matrix_copy( &rmesa->tmpmat[unit],
		  ctx->TextureMatrixStack[unit].Top );
	    }
	 }
	 else if (rmesa->TexGenEnabled & (RADEON_TEXMAT_0_ENABLE << unit)) {
	    _math_matrix_copy( &rmesa->tmpmat[unit], &rmesa->TexGenMatrix[unit] );
	    needMatrix = GL_TRUE;
	 }
	 if (needMatrix) {
	    rmesa->NeedTexMatrix |= 1 << unit;
	    radeonUploadTexMatrix( rmesa, unit,
			!ctx->Texture.Unit[unit].TexGenEnabled );
	 }
      }
   }

   tpc = (texMatEnabled | rmesa->TexGenEnabled);

   /* TCL_TEX_COMPUTED_x is TCL_TEX_INPUT_x | 0x8 */
   vs &= ~((RADEON_TCL_TEX_COMPUTED_TEX_0 << RADEON_TCL_TEX_0_OUTPUT_SHIFT) |
	   (RADEON_TCL_TEX_COMPUTED_TEX_0 << RADEON_TCL_TEX_1_OUTPUT_SHIFT) |
	   (RADEON_TCL_TEX_COMPUTED_TEX_0 << RADEON_TCL_TEX_2_OUTPUT_SHIFT));

   vs |= (((tpc & RADEON_TEXGEN_TEXMAT_0_ENABLE) <<
	 (RADEON_TCL_TEX_0_OUTPUT_SHIFT + 3)) |
      ((tpc & RADEON_TEXGEN_TEXMAT_1_ENABLE) <<
	 (RADEON_TCL_TEX_1_OUTPUT_SHIFT + 2)) |
      ((tpc & RADEON_TEXGEN_TEXMAT_2_ENABLE) <<
	 (RADEON_TCL_TEX_2_OUTPUT_SHIFT + 1)));

   if (tpc != rmesa->hw.tcl.cmd[TCL_TEXTURE_PROC_CTL] ||
       vs != rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL]) {

      RADEON_STATECHANGE(rmesa, tcl);
      rmesa->hw.tcl.cmd[TCL_TEXTURE_PROC_CTL] = tpc;
      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXSEL] = vs;
   }
}

GLboolean r100ValidateBuffers(struct gl_context *ctx)
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   struct radeon_renderbuffer *rrb;
   int i, ret;

   radeon_cs_space_reset_bos(rmesa->radeon.cmdbuf.cs);

   rrb = radeon_get_colorbuffer(&rmesa->radeon);
   /* color buffer */
   if (rrb && rrb->bo) {
     radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs, rrb->bo,
				       0, RADEON_GEM_DOMAIN_VRAM);
   }

   /* depth buffer */
   rrb = radeon_get_depthbuffer(&rmesa->radeon);
   /* color buffer */
   if (rrb && rrb->bo) {
     radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs, rrb->bo,
				       0, RADEON_GEM_DOMAIN_VRAM);
   }

   for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; ++i) {
      radeonTexObj *t;

      if (!ctx->Texture.Unit[i]._Current)
	 continue;

      t = rmesa->state.texture.unit[i].texobj;

      if (!t)
	 continue;
      if (t->image_override && t->bo)
	radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs, t->bo,
			   RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0);
      else if (t->mt->bo)
	radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs, t->mt->bo,
			   RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0);
   }

   ret = radeon_cs_space_check_with_bo(rmesa->radeon.cmdbuf.cs, first_elem(&rmesa->radeon.dma.reserved)->bo, RADEON_GEM_DOMAIN_GTT, 0);
   if (ret)
       return GL_FALSE;
   return GL_TRUE;
}

GLboolean radeonValidateState( struct gl_context *ctx )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLuint new_state = rmesa->radeon.NewGLState;

   if (new_state & _NEW_BUFFERS) {
     _mesa_update_framebuffer(ctx);
     /* this updates the DrawBuffer's Width/Height if it's a FBO */
     _mesa_update_draw_buffer_bounds(ctx);
     RADEON_STATECHANGE(rmesa, ctx);
   }

   if (new_state & _NEW_TEXTURE) {
      radeonUpdateTextureState( ctx );
      new_state |= rmesa->radeon.NewGLState; /* may add TEXTURE_MATRIX */
   }

   /* we need to do a space check here */
   if (!r100ValidateBuffers(ctx))
     return GL_FALSE;

   /* Need an event driven matrix update?
    */
   if (new_state & (_NEW_MODELVIEW|_NEW_PROJECTION))
      upload_matrix( rmesa, ctx->_ModelProjectMatrix.m, MODEL_PROJ );

   /* Need these for lighting (shouldn't upload otherwise)
    */
   if (new_state & (_NEW_MODELVIEW)) {
      upload_matrix( rmesa, ctx->ModelviewMatrixStack.Top->m, MODEL );
      upload_matrix_t( rmesa, ctx->ModelviewMatrixStack.Top->inv, MODEL_IT );
   }

   /* Does this need to be triggered on eg. modelview for
    * texgen-derived objplane/eyeplane matrices?
    */
   if (new_state & _NEW_TEXTURE_MATRIX) {
      update_texturematrix( ctx );
   }

   if (new_state & (_NEW_LIGHT|_NEW_MODELVIEW|_MESA_NEW_NEED_EYE_COORDS)) {
      update_light( ctx );
   }

   /* emit all active clip planes if projection matrix changes.
    */
   if (new_state & (_NEW_PROJECTION)) {
      if (ctx->Transform.ClipPlanesEnabled)
	 radeonUpdateClipPlanes( ctx );
   }


   rmesa->radeon.NewGLState = 0;

   return GL_TRUE;
}


static void radeonInvalidateState( struct gl_context *ctx, GLuint new_state )
{
   _swrast_InvalidateState( ctx, new_state );
   _swsetup_InvalidateState( ctx, new_state );
   _vbo_InvalidateState( ctx, new_state );
   _tnl_InvalidateState( ctx, new_state );
   _ae_invalidate_state( ctx, new_state );
   R100_CONTEXT(ctx)->radeon.NewGLState |= new_state;
}


/* A hack.  Need a faster way to find this out.
 */
static GLboolean check_material( struct gl_context *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   GLint i;

   for (i = _TNL_ATTRIB_MAT_FRONT_AMBIENT;
	i < _TNL_ATTRIB_MAT_BACK_INDEXES;
	i++)
      if (tnl->vb.AttribPtr[i] &&
	  tnl->vb.AttribPtr[i]->stride)
	 return GL_TRUE;

   return GL_FALSE;
}


static void radeonWrapRunPipeline( struct gl_context *ctx )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLboolean has_material;

   if (0)
      fprintf(stderr, "%s, newstate: %x\n", __FUNCTION__, rmesa->radeon.NewGLState);

   /* Validate state:
    */
   if (rmesa->radeon.NewGLState)
      if (!radeonValidateState( ctx ))
	 FALLBACK(rmesa, RADEON_FALLBACK_TEXTURE, GL_TRUE);

   has_material = (ctx->Light.Enabled && check_material( ctx ));

   if (has_material) {
      TCL_FALLBACK( ctx, RADEON_TCL_FALLBACK_MATERIAL, GL_TRUE );
   }

   /* Run the pipeline.
    */
   _tnl_run_pipeline( ctx );

   if (has_material) {
      TCL_FALLBACK( ctx, RADEON_TCL_FALLBACK_MATERIAL, GL_FALSE );
   }
}

static void radeonPolygonStipple( struct gl_context *ctx, const GLubyte *mask )
{
   r100ContextPtr r100 = R100_CONTEXT(ctx);
   GLint i;

   radeon_firevertices(&r100->radeon);

   RADEON_STATECHANGE(r100, stp);

   /* Must flip pattern upside down.
    */
   for ( i = 31 ; i >= 0; i--) {
     r100->hw.stp.cmd[3 + i] = ((GLuint *) mask)[i];
   }
}


/* Initialize the driver's state functions.
 * Many of the ctx->Driver functions might have been initialized to
 * software defaults in the earlier _mesa_init_driver_functions() call.
 */
void radeonInitStateFuncs( struct gl_context *ctx )
{
   ctx->Driver.UpdateState		= radeonInvalidateState;
   ctx->Driver.LightingSpaceChange      = radeonLightingSpaceChange;

   ctx->Driver.DrawBuffer		= radeonDrawBuffer;
   ctx->Driver.ReadBuffer		= radeonReadBuffer;
   ctx->Driver.CopyPixels               = _mesa_meta_CopyPixels;
   ctx->Driver.DrawPixels               = _mesa_meta_DrawPixels;
   ctx->Driver.ReadPixels               = radeonReadPixels;

   ctx->Driver.AlphaFunc		= radeonAlphaFunc;
   ctx->Driver.BlendEquationSeparate	= radeonBlendEquationSeparate;
   ctx->Driver.BlendFuncSeparate	= radeonBlendFuncSeparate;
   ctx->Driver.ClipPlane		= radeonClipPlane;
   ctx->Driver.ColorMask		= radeonColorMask;
   ctx->Driver.CullFace			= radeonCullFace;
   ctx->Driver.DepthFunc		= radeonDepthFunc;
   ctx->Driver.DepthMask		= radeonDepthMask;
   ctx->Driver.DepthRange		= radeonDepthRange;
   ctx->Driver.Enable			= radeonEnable;
   ctx->Driver.Fogfv			= radeonFogfv;
   ctx->Driver.FrontFace		= radeonFrontFace;
   ctx->Driver.Hint			= NULL;
   ctx->Driver.LightModelfv		= radeonLightModelfv;
   ctx->Driver.Lightfv			= radeonLightfv;
   ctx->Driver.LineStipple              = radeonLineStipple;
   ctx->Driver.LineWidth                = radeonLineWidth;
   ctx->Driver.LogicOpcode		= radeonLogicOpCode;
   ctx->Driver.PolygonMode		= radeonPolygonMode;
   ctx->Driver.PolygonOffset		= radeonPolygonOffset;
   ctx->Driver.PolygonStipple		= radeonPolygonStipple;
   ctx->Driver.RenderMode		= radeonRenderMode;
   ctx->Driver.Scissor			= radeonScissor;
   ctx->Driver.ShadeModel		= radeonShadeModel;
   ctx->Driver.StencilFuncSeparate	= radeonStencilFuncSeparate;
   ctx->Driver.StencilMaskSeparate	= radeonStencilMaskSeparate;
   ctx->Driver.StencilOpSeparate	= radeonStencilOpSeparate;
   ctx->Driver.Viewport			= radeonViewport;

   TNL_CONTEXT(ctx)->Driver.NotifyMaterialChange = radeonUpdateMaterial;
   TNL_CONTEXT(ctx)->Driver.RunPipeline = radeonWrapRunPipeline;
}
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d1402 52
@


1.9
log
@Merge Mesa 10.2.7
@
text
@a1401 52
void radeonUpdateViewportOffset( struct gl_context *ctx )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   __DRIdrawable *dPriv = radeon_get_drawable(&rmesa->radeon);
   GLfloat xoffset = 0.0;
   GLfloat yoffset = (GLfloat)dPriv->h;
   const GLfloat *v = ctx->ViewportArray[0]._WindowMap.m;

   float_ui32_type tx;
   float_ui32_type ty;

   tx.f = v[MAT_TX] + xoffset + SUBPIXEL_X;
   ty.f = (- v[MAT_TY]) + yoffset + SUBPIXEL_Y;

   if ( rmesa->hw.vpt.cmd[VPT_SE_VPORT_XOFFSET] != tx.ui32 ||
	rmesa->hw.vpt.cmd[VPT_SE_VPORT_YOFFSET] != ty.ui32 )
   {
      /* Note: this should also modify whatever data the context reset
       * code uses...
       */
      RADEON_STATECHANGE( rmesa, vpt );
      rmesa->hw.vpt.cmd[VPT_SE_VPORT_XOFFSET] = tx.ui32;
      rmesa->hw.vpt.cmd[VPT_SE_VPORT_YOFFSET] = ty.ui32;

      /* update polygon stipple x/y screen offset */
      {
         GLuint stx, sty;
         GLuint m = rmesa->hw.msc.cmd[MSC_RE_MISC];

         m &= ~(RADEON_STIPPLE_X_OFFSET_MASK |
                RADEON_STIPPLE_Y_OFFSET_MASK);

         /* add magic offsets, then invert */
         stx = 31 - ((-1) & RADEON_STIPPLE_COORD_MASK);
         sty = 31 - ((dPriv->h - 1)
                     & RADEON_STIPPLE_COORD_MASK);

         m |= ((stx << RADEON_STIPPLE_X_OFFSET_SHIFT) |
               (sty << RADEON_STIPPLE_Y_OFFSET_SHIFT));

         if ( rmesa->hw.msc.cmd[MSC_RE_MISC] != m ) {
            RADEON_STATECHANGE( rmesa, msc );
	    rmesa->hw.msc.cmd[MSC_RE_MISC] = m;
         }
      }
   }

   radeonUpdateScissor( ctx );
}



@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d1995 1
a1995 1
static GLboolean r100ValidateBuffers(struct gl_context *ctx)
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d32 1
a32 1
 *   Keith Whitwell <keith@@tungstengraphics.com>
d1355 1
a1355 1
   const GLfloat *v = ctx->Viewport._WindowMap.m;
d1386 1
a1386 2
static void radeonViewport( struct gl_context *ctx, GLint x, GLint y,
			    GLsizei width, GLsizei height )
d1394 1
a1394 1
   radeon_viewport(ctx, x, y, width, height);
d1397 1
a1397 2
static void radeonDepthRange( struct gl_context *ctx, GLclampd nearval,
			      GLclampd farval )
d1408 1
a1408 1
   const GLfloat *v = ctx->Viewport._WindowMap.m;
d1853 3
a1855 1
   if ((tUnit._ReallyEnabled & (TEXTURE_3D_BIT | TEXTURE_CUBE_BIT)) == 0) {
d1940 1
a1940 1
      if (ctx->Texture.Unit[unit]._ReallyEnabled) {
d2018 1
a2018 1
   for (i = 0; i < ctx->Const.FragmentProgram.MaxTextureImageUnits; ++i) {
d2021 1
a2021 1
      if (!ctx->Texture.Unit[i]._ReallyEnabled)
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d42 1
d45 2
a310 16
static void radeonClearDepth( struct gl_context *ctx, GLclampd d )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLuint format = (rmesa->hw.ctx.cmd[CTX_RB3D_ZSTENCILCNTL] &
		    RADEON_DEPTH_FORMAT_MASK);

   switch ( format ) {
   case RADEON_DEPTH_FORMAT_16BIT_INT_Z:
      rmesa->radeon.state.depth.clear = d * 0x0000ffff;
      break;
   case RADEON_DEPTH_FORMAT_24BIT_INT_Z:
      rmesa->radeon.state.depth.clear = d * 0x00ffffff;
      break;
   }
}

d321 1
a321 1
   GLchan col[4];
d385 1
a385 1
      UNCLAMPED_FLOAT_TO_RGB_CHAN( col, ctx->Fog.Color );
d442 1
d451 3
a453 2
   if (ctx->DrawBuffer && ctx->DrawBuffer->Name)
      mode = (mode == GL_CW) ? GL_CCW : GL_CW;
d455 1
a455 6
   switch ( mode ) {
   case GL_CW:
      rmesa->hw.set.cmd[SET_SE_CNTL] |= RADEON_FFACE_CULL_CW;
      break;
   case GL_CCW:
      rmesa->hw.set.cmd[SET_SE_CNTL] |= RADEON_FFACE_CULL_CCW;
a456 2
      break;
   }
a534 25
static void radeonPolygonStipplePreKMS( struct gl_context *ctx, const GLubyte *mask )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLuint i;
   drm_radeon_stipple_t stipple;

   /* Must flip pattern upside down.
    */
   for ( i = 0 ; i < 32 ; i++ ) {
      rmesa->state.stipple.mask[31 - i] = ((GLuint *) mask)[i];
   }

   /* TODO: push this into cmd mechanism
    */
   radeon_firevertices(&rmesa->radeon);
   LOCK_HARDWARE( &rmesa->radeon );

   /* FIXME: Use window x,y offsets into stipple RAM.
    */
   stipple.mask = rmesa->state.stipple.mask;
   drmCommandWrite( rmesa->radeon.dri.fd, DRM_RADEON_STIPPLE,
		    &stipple, sizeof(drm_radeon_stipple_t) );
   UNLOCK_HARDWARE( &rmesa->radeon );
}

d538 2
a539 1
   GLboolean flag = (ctx->_TriangleCaps & DD_TRI_UNFILLED) != 0;
d544 1
a544 1
   TCL_FALLBACK( ctx, RADEON_TCL_FALLBACK_UNFILLED, flag);
d708 2
a709 2
	  (ctx->Light.ColorMaterialBitmask & BACK_MATERIAL_BITS) !=
	  ((ctx->Light.ColorMaterialBitmask & FRONT_MATERIAL_BITS)<<1))
d737 1
a737 1
      GLuint mask = ctx->Light.ColorMaterialBitmask;
d798 1
a798 1
      mask &= ~ctx->Light.ColorMaterialBitmask;
d1161 1
a1161 1
   GLuint refmask = (((ctx->Stencil.Ref[0] & 0xff) << RADEON_STENCIL_REF_SHIFT) |
a1331 9
static void radeonClearStencil( struct gl_context *ctx, GLint s )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);

   rmesa->radeon.state.stencil.clear =
      ((GLuint) (ctx->Stencil.Clear & 0xff) |
       (0xff << RADEON_STENCIL_MASK_SHIFT) |
       ((ctx->Stencil.WriteMask[0] & 0xff) << RADEON_STENCIL_WRITEMASK_SHIFT));
}
d1353 2
a1354 2
   GLfloat xoffset = dPriv ? (GLfloat) dPriv->x : 0;
   GLfloat yoffset = dPriv ? (GLfloat) dPriv->y + dPriv->h : 0;
d1356 1
a1356 1
   const GLboolean render_to_fbo = (ctx->DrawBuffer ? (ctx->DrawBuffer->Name != 0) : 0);
d1408 2
a1409 2
   GLfloat xoffset = (GLfloat)dPriv->x;
   GLfloat yoffset = (GLfloat)dPriv->y + dPriv->h;
d1437 2
a1438 2
         stx = 31 - ((dPriv->x - 1) & RADEON_STIPPLE_COORD_MASK);
         sty = 31 - ((dPriv->y + dPriv->h - 1)
a1459 19
static void radeonClearColor( struct gl_context *ctx, const GLfloat color[4] )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLubyte c[4];
   struct radeon_renderbuffer *rrb;

   rrb = radeon_get_colorbuffer(&rmesa->radeon);
   if (!rrb)
     return;
     
   CLAMPED_FLOAT_TO_UBYTE(c[0], color[0]);
   CLAMPED_FLOAT_TO_UBYTE(c[1], color[1]);
   CLAMPED_FLOAT_TO_UBYTE(c[2], color[2]);
   CLAMPED_FLOAT_TO_UBYTE(c[3], color[3]);
   rmesa->radeon.state.color.clear = radeonPackColor( rrb->cpp,
					       c[0], c[1], c[2], c[3] );
}


d1851 1
a1851 1
   struct gl_texture_unit tUnit = rmesa->radeon.glCtx->Texture.Unit[unit];
d2018 1
a2018 1
   for (i = 0; i < ctx->Const.MaxTextureImageUnits; ++i) {
d2179 1
a2179 1
void radeonInitStateFuncs( struct gl_context *ctx , GLboolean dri2 )
d2188 1
a2188 2
   if (dri2)
	   ctx->Driver.ReadPixels               = radeonReadPixels;
a2192 3
   ctx->Driver.ClearColor		= radeonClearColor;
   ctx->Driver.ClearDepth		= radeonClearDepth;
   ctx->Driver.ClearStencil		= radeonClearStencil;
d2210 1
a2210 4
   if (dri2)
      ctx->Driver.PolygonStipple		= radeonPolygonStipple;
   else
      ctx->Driver.PolygonStipple		= radeonPolygonStipplePreKMS;
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d43 1
d140 1
a140 1
	    && ctx->Color.BlendEquationRGB == GL_LOGIC_OP)) ) {
d157 1
a157 1
   switch ( ctx->Color.BlendSrcRGB ) {
d204 1
a204 1
   switch ( ctx->Color.BlendDstRGB ) {
d665 1
a665 1
   if (NEED_SECONDARY_COLOR(ctx)) {
d1606 1
a1606 1
	    && ctx->Color.BlendEquationRGB == GL_LOGIC_OP)) ) {
d1616 6
a1621 6
					    ctx->Color.BlendEquationRGB,
					    ctx->Color.BlendEquationA );
	 ctx->Driver.BlendFuncSeparate( ctx, ctx->Color.BlendSrcRGB,
					ctx->Color.BlendDstRGB,
					ctx->Color.BlendSrcA,
					ctx->Color.BlendDstA );
d1745 1
a1745 1
	    && ctx->Color.BlendEquationRGB == GL_LOGIC_OP)) ) {
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d48 1
d58 1
a58 1
static void radeonUpdateSpecular( GLcontext *ctx );
d64 1
a64 1
static void radeonAlphaFunc( GLcontext *ctx, GLenum func, GLfloat ref )
d107 1
a107 1
static void radeonBlendEquationSeparate( GLcontext *ctx,
d147 1
a147 1
static void radeonBlendFuncSeparate( GLcontext *ctx,
d259 1
a259 1
static void radeonDepthFunc( GLcontext *ctx, GLenum func )
d295 1
a295 1
static void radeonDepthMask( GLcontext *ctx, GLboolean flag )
d307 1
a307 1
static void radeonClearDepth( GLcontext *ctx, GLclampd d )
d329 1
a329 1
static void radeonFogfv( GLcontext *ctx, GLenum pname, const GLfloat *param )
d414 1
a414 1
static void radeonCullFace( GLcontext *ctx, GLenum unused )
d451 1
a451 1
static void radeonFrontFace( GLcontext *ctx, GLenum mode )
d480 1
a480 1
static void radeonLineWidth( GLcontext *ctx, GLfloat widthf )
d497 1
a497 1
static void radeonLineStipple( GLcontext *ctx, GLint factor, GLushort pattern )
d510 1
a510 1
static void radeonColorMask( GLcontext *ctx,
d539 1
a539 1
static void radeonPolygonOffset( GLcontext *ctx,
d552 1
a552 1
static void radeonPolygonStipplePreKMS( GLcontext *ctx, const GLubyte *mask )
d577 1
a577 1
static void radeonPolygonMode( GLcontext *ctx, GLenum face, GLenum mode )
d604 1
a604 1
static void radeonUpdateSpecular( GLcontext *ctx )
d692 1
a692 1
static void update_global_ambient( GLcontext *ctx )
d722 1
a722 1
static void update_light_colors( GLcontext *ctx, GLuint p )
d742 1
a742 1
static void check_twoside_fallback( GLcontext *ctx )
d767 1
a767 1
static void radeonColorMaterial( GLcontext *ctx, GLenum face, GLenum mode )
d831 1
a831 1
void radeonUpdateMaterial( GLcontext *ctx )
d896 1
a896 1
static void update_light( GLcontext *ctx )
d960 1
a960 1
static void radeonLightfv( GLcontext *ctx, GLenum light,
d1081 1
a1081 1
static void radeonLightModelfv( GLcontext *ctx, GLenum pname,
d1123 1
a1123 1
static void radeonShadeModel( GLcontext *ctx, GLenum mode )
d1161 1
a1161 1
static void radeonClipPlane( GLcontext *ctx, GLenum plane, const GLfloat *eq )
d1174 1
a1174 1
static void radeonUpdateClipPlanes( GLcontext *ctx )
d1198 1
a1198 1
radeonStencilFuncSeparate( GLcontext *ctx, GLenum face, GLenum func,
d1243 1
a1243 1
radeonStencilMaskSeparate( GLcontext *ctx, GLenum face, GLuint mask )
d1253 1
a1253 1
static void radeonStencilOpSeparate( GLcontext *ctx, GLenum face, GLenum fail,
d1373 1
a1373 1
static void radeonClearStencil( GLcontext *ctx, GLint s )
d1399 1
a1399 1
void radeonUpdateWindow( GLcontext *ctx )
d1436 1
a1436 1
static void radeonViewport( GLcontext *ctx, GLint x, GLint y,
d1448 1
a1448 1
static void radeonDepthRange( GLcontext *ctx, GLclampd nearval,
d1454 1
a1454 1
void radeonUpdateViewportOffset( GLcontext *ctx )
d1510 1
a1510 1
static void radeonClearColor( GLcontext *ctx, const GLfloat color[4] )
d1529 1
a1529 1
static void radeonRenderMode( GLcontext *ctx, GLenum mode )
d1555 1
a1555 1
static void radeonLogicOpCode( GLcontext *ctx, GLenum opcode )
d1570 1
a1570 1
static void radeonEnable( GLcontext *ctx, GLenum cap, GLboolean state )
d1863 1
a1863 1
static void radeonLightingSpaceChange( GLcontext *ctx )
d1998 1
a1998 1
static void update_texturematrix( GLcontext *ctx )
d2064 1
a2064 1
static GLboolean r100ValidateBuffers(GLcontext *ctx)
d2094 3
d2111 1
a2111 1
GLboolean radeonValidateState( GLcontext *ctx )
d2169 1
a2169 1
static void radeonInvalidateState( GLcontext *ctx, GLuint new_state )
d2182 1
a2182 1
static GLboolean check_material( GLcontext *ctx )
d2198 1
a2198 1
static void radeonWrapRunPipeline( GLcontext *ctx )
d2227 1
a2227 1
static void radeonPolygonStipple( GLcontext *ctx, const GLubyte *mask )
d2248 1
a2248 1
void radeonInitStateFuncs( GLcontext *ctx , GLboolean dri2 )
d2255 4
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a39 1
#include "main/state.h"
d42 1
d50 1
a55 1
#include "drirenderbuffer.h"
d65 1
a65 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d109 1
a109 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d150 2
a151 2
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
   GLuint b = rmesa->hw.ctx.cmd[CTX_RB3D_BLENDCNTL] & 
d260 1
a260 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d296 1
a296 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d308 1
a308 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d314 1
a314 1
      rmesa->state.depth.clear = d * 0x0000ffff;
d317 1
a317 1
      rmesa->state.depth.clear = d * 0x00ffffff;
d330 1
a330 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d394 1
a394 1
   case GL_FOG_COLOR: 
a408 96

/* =============================================================
 * Scissoring
 */


static GLboolean intersect_rect( drm_clip_rect_t *out,
				 drm_clip_rect_t *a,
				 drm_clip_rect_t *b )
{
   *out = *a;
   if ( b->x1 > out->x1 ) out->x1 = b->x1;
   if ( b->y1 > out->y1 ) out->y1 = b->y1;
   if ( b->x2 < out->x2 ) out->x2 = b->x2;
   if ( b->y2 < out->y2 ) out->y2 = b->y2;
   if ( out->x1 >= out->x2 ) return GL_FALSE;
   if ( out->y1 >= out->y2 ) return GL_FALSE;
   return GL_TRUE;
}


void radeonRecalcScissorRects( radeonContextPtr rmesa )
{
   drm_clip_rect_t *out;
   int i;

   /* Grow cliprect store?
    */
   if (rmesa->state.scissor.numAllocedClipRects < rmesa->numClipRects) {
      while (rmesa->state.scissor.numAllocedClipRects < rmesa->numClipRects) {
	 rmesa->state.scissor.numAllocedClipRects += 1;	/* zero case */
	 rmesa->state.scissor.numAllocedClipRects *= 2;
      }

      if (rmesa->state.scissor.pClipRects)
	 FREE(rmesa->state.scissor.pClipRects);

      rmesa->state.scissor.pClipRects = 
	 MALLOC( rmesa->state.scissor.numAllocedClipRects * 
		 sizeof(drm_clip_rect_t) );

      if ( rmesa->state.scissor.pClipRects == NULL ) {
	 rmesa->state.scissor.numAllocedClipRects = 0;
	 return;
      }
   }
   
   out = rmesa->state.scissor.pClipRects;
   rmesa->state.scissor.numClipRects = 0;

   for ( i = 0 ; i < rmesa->numClipRects ;  i++ ) {
      if ( intersect_rect( out, 
			   &rmesa->pClipRects[i], 
			   &rmesa->state.scissor.rect ) ) {
	 rmesa->state.scissor.numClipRects++;
	 out++;
      }
   }
}


static void radeonUpdateScissor( GLcontext *ctx )
{
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);

   if ( rmesa->dri.drawable ) {
      __DRIdrawablePrivate *dPriv = rmesa->dri.drawable;

      int x = ctx->Scissor.X;
      int y = dPriv->h - ctx->Scissor.Y - ctx->Scissor.Height;
      int w = ctx->Scissor.X + ctx->Scissor.Width - 1;
      int h = dPriv->h - ctx->Scissor.Y - 1;

      rmesa->state.scissor.rect.x1 = x + dPriv->x;
      rmesa->state.scissor.rect.y1 = y + dPriv->y;
      rmesa->state.scissor.rect.x2 = w + dPriv->x + 1;
      rmesa->state.scissor.rect.y2 = h + dPriv->y + 1;

      radeonRecalcScissorRects( rmesa );
   }
}


static void radeonScissor( GLcontext *ctx,
			   GLint x, GLint y, GLsizei w, GLsizei h )
{
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);

   if ( ctx->Scissor.Enabled ) {
      RADEON_FIREVERTICES( rmesa );	/* don't pipeline cliprect changes */
      radeonUpdateScissor( ctx );
   }

}


d415 1
a415 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d452 1
a452 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d460 4
d481 1
a481 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d498 1
a498 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d501 1
a501 1
   rmesa->hw.lin.cmd[LIN_RE_LINE_PATTERN] = 
d513 13
a525 6
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
   GLuint mask = radeonPackColor( rmesa->radeonScreen->cpp,
				  ctx->Color.ColorMask[RCOMP],
				  ctx->Color.ColorMask[GCOMP],
				  ctx->Color.ColorMask[BCOMP],
				  ctx->Color.ColorMask[ACOMP] );
d541 3
a543 2
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
   float_ui32_type constant =  { units * rmesa->state.depth.scale };
d551 1
a551 1
static void radeonPolygonStipple( GLcontext *ctx, const GLubyte *mask )
d553 1
a553 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d565 2
a566 2
   RADEON_FIREVERTICES( rmesa );
   LOCK_HARDWARE( rmesa );
d571 3
a573 3
   drmCommandWrite( rmesa->dri.fd, DRM_RADEON_STIPPLE, 
                    &stipple, sizeof(drm_radeon_stipple_t) );
   UNLOCK_HARDWARE( rmesa );
d578 1
a578 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d582 1
a582 1
    * cases work. 
d585 1
a585 1
   if (rmesa->TclFallback) {
d605 1
a605 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d630 1
a630 1
      rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] &= 
d660 1
a660 1
 
d676 1
a676 1
   if (rmesa->TclFallback) { 
d688 1
a688 1
/* Update on colormaterial, material emmissive/ambient, 
d693 1
a693 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d701 1
a701 1
	(3 << RADEON_AMBIENT_SOURCE_SHIFT))) == 0) 
d703 1
a703 1
      COPY_3V( &fcmd[GLT_RED], 
d708 1
a708 1
   } 
d713 1
a713 1
   
d717 1
a717 1
/* Update on change to 
d728 1
a728 1
      radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d731 1
a731 1
      COPY_4V( &fcmd[LIT_AMBIENT_RED], l->Ambient );	 
d734 1
a734 1
      
d748 1
a748 1
	  (ctx->Light.ColorMaterialBitmask & BACK_MATERIAL_BITS) != 
d756 1
a756 1
	       fallback = GL_TRUE;  
d768 1
a768 1
      radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d774 2
a775 2
			   (3 << RADEON_SPECULAR_SOURCE_SHIFT)); 
   
d796 1
a796 1
	 
d805 1
a805 1
   
d823 1
a823 1
   
d826 1
a826 1
	 rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] = light_model_ctl1;      
d832 1
a832 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d836 1
a836 1
   
d840 1
a840 1
   if (RADEON_DEBUG & DEBUG_STATE)
d843 1
a843 1
      
d886 1
a886 1
 *       _NormDirection
d893 1
a893 1
 * and _MESA_NEW_NEED_EYE_COORDS.  
d897 1
a897 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d910 1
a910 1
      
d915 1
a915 1
      if (tmp != rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL]) 
d939 1
a939 1
	    
d941 2
a942 2
	       COPY_3FV( &fcmd[LIT_POSITION_X], l->_VP_inf_norm ); 
	       COPY_3FV( &fcmd[LIT_DIRECTION_X], l->_h_inf_norm ); 
d947 3
a949 3
	       fcmd[LIT_DIRECTION_X] = -l->_NormDirection[0];
	       fcmd[LIT_DIRECTION_Y] = -l->_NormDirection[1];
	       fcmd[LIT_DIRECTION_Z] = -l->_NormDirection[2];
d962 1
a962 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d966 1
a966 1
   
d969 1
a969 1
   case GL_AMBIENT:		
d975 2
a976 2
   case GL_SPOT_DIRECTION: 
      /* picked up in update_light */	
d980 1
a980 1
      /* positions picked up in update_light, but can do flag here */	
d985 1
a985 1
      if (p&1) 
d1077 1
a1077 1
		  
d1083 1
a1083 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d1086 1
a1086 1
      case GL_LIGHT_MODEL_AMBIENT: 
d1107 1
a1107 1
	 if (rmesa->TclFallback) {
d1124 1
a1124 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d1163 1
a1163 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d1175 1
a1175 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d1200 1
a1200 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d1244 1
a1244 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d1255 1
a1255 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d1260 1
a1260 1
   
d1267 2
a1268 2
   
   if (rmesa->radeonScreen->chip_flags & RADEON_CHIPSET_BROKEN_STENCIL) {
d1284 1
a1284 1
   
d1374 1
a1374 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d1376 1
a1376 1
   rmesa->state.stencil.clear = 
d1400 4
a1403 4
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
   __DRIdrawablePrivate *dPriv = rmesa->dri.drawable;
   GLfloat xoffset = (GLfloat)dPriv->x;
   GLfloat yoffset = (GLfloat)dPriv->y + dPriv->h;
d1405 11
d1419 4
a1422 4
   float_ui32_type sy = { - v[MAT_SY] };
   float_ui32_type ty = { (- v[MAT_TY]) + yoffset + SUBPIXEL_Y };
   float_ui32_type sz = { v[MAT_SZ] * rmesa->state.depth.scale };
   float_ui32_type tz = { v[MAT_TZ] * rmesa->state.depth.scale };
a1423 1
   RADEON_FIREVERTICES( rmesa );
d1443 2
d1455 2
a1456 2
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
   __DRIdrawablePrivate *dPriv = rmesa->dri.drawable;
d1486 2
a1487 2
         stx = 31 - ((rmesa->dri.drawable->x - 1) & RADEON_STIPPLE_COORD_MASK);
         sty = 31 - ((rmesa->dri.drawable->y + rmesa->dri.drawable->h - 1)
d1511 1
a1511 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d1513 6
d1523 1
a1523 1
   rmesa->state.color.clear = radeonPackColor( rmesa->radeonScreen->cpp,
d1530 1
a1530 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d1556 1
a1556 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
a1564 92

/**
 * Set up the cliprects for either front or back-buffer drawing.
 */
void radeonSetCliprects( radeonContextPtr rmesa )
{
   __DRIdrawablePrivate *const drawable = rmesa->dri.drawable;
   __DRIdrawablePrivate *const readable = rmesa->dri.readable;
   GLframebuffer *const draw_fb = (GLframebuffer*) drawable->driverPrivate;
   GLframebuffer *const read_fb = (GLframebuffer*) readable->driverPrivate;

   if (draw_fb->_ColorDrawBufferIndexes[0] == BUFFER_BACK_LEFT) {
      /* Can't ignore 2d windows if we are page flipping.
       */
      if ( drawable->numBackClipRects == 0 || rmesa->doPageFlip ) {
	 rmesa->numClipRects = drawable->numClipRects;
	 rmesa->pClipRects = drawable->pClipRects;
      }
      else {
	 rmesa->numClipRects = drawable->numBackClipRects;
	 rmesa->pClipRects = drawable->pBackClipRects;
      }
   }
   else {
      /* front buffer (or none, or multiple buffers */
      rmesa->numClipRects = drawable->numClipRects;
      rmesa->pClipRects = drawable->pClipRects;
   }

   if ((draw_fb->Width != drawable->w) || (draw_fb->Height != drawable->h)) {
      _mesa_resize_framebuffer(rmesa->glCtx, draw_fb,
			       drawable->w, drawable->h);
      draw_fb->Initialized = GL_TRUE;
   }

   if (drawable != readable) {
      if ((read_fb->Width != readable->w) || (read_fb->Height != readable->h)) {
	 _mesa_resize_framebuffer(rmesa->glCtx, read_fb,
				  readable->w, readable->h);
	 read_fb->Initialized = GL_TRUE;
      }
   }

   if (rmesa->state.scissor.enabled)
      radeonRecalcScissorRects( rmesa );

   rmesa->lastStamp = drawable->lastStamp;
}


/**
 * Called via glDrawBuffer.
 */
static void radeonDrawBuffer( GLcontext *ctx, GLenum mode )
{
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);

   if (RADEON_DEBUG & DEBUG_DRI)
      fprintf(stderr, "%s %s\n", __FUNCTION__,
	      _mesa_lookup_enum_by_nr( mode ));

   RADEON_FIREVERTICES(rmesa);	/* don't pipeline cliprect changes */

   if (ctx->DrawBuffer->_NumColorDrawBuffers != 1) {
      /* 0 (GL_NONE) buffers or multiple color drawing buffers */
      FALLBACK( rmesa, RADEON_FALLBACK_DRAW_BUFFER, GL_TRUE );
      return;
   }

   switch ( ctx->DrawBuffer->_ColorDrawBufferIndexes[0] ) {
   case BUFFER_FRONT_LEFT:
   case BUFFER_BACK_LEFT:
      FALLBACK( rmesa, RADEON_FALLBACK_DRAW_BUFFER, GL_FALSE );
      break;
   default:
      FALLBACK( rmesa, RADEON_FALLBACK_DRAW_BUFFER, GL_TRUE );
      return;
   }

   radeonSetCliprects( rmesa );

   /* We'll set the drawing engine's offset/pitch parameters later
    * when we update other state.
    */
}

static void radeonReadBuffer( GLcontext *ctx, GLenum mode )
{
   /* nothing, until we implement h/w glRead/CopyPixels or CopyTexImage */
}


d1571 1
a1571 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d1574 1
a1574 1
   if ( RADEON_DEBUG & DEBUG_STATE )
d1632 1
a1632 1
   case GL_CLIP_PLANE5: 
d1666 1
a1666 1
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] &= ~rmesa->state.color.roundEnable;
d1669 1
a1669 1
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] |=  rmesa->state.color.roundEnable;
d1697 1
a1697 1
      if (p&1) 
d1699 1
a1699 1
		 RADEON_LIGHT_1_ENABLE_AMBIENT | 
d1703 1
a1703 1
		 RADEON_LIGHT_0_ENABLE_AMBIENT | 
d1711 1
a1711 1
      /* 
d1749 1
a1749 1
      
d1816 2
a1817 2
      RADEON_FIREVERTICES( rmesa );
      rmesa->state.scissor.enabled = state;
d1822 15
a1836 4
      if ( rmesa->state.stencil.hwBuffer ) {
	 RADEON_STATECHANGE( rmesa, ctx );
	 if ( state ) {
	    rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] |=  RADEON_STENCIL_ENABLE;
d1838 1
a1838 1
	    rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] &= ~RADEON_STENCIL_ENABLE;
a1839 2
      } else {
	 FALLBACK( rmesa, RADEON_FALLBACK_STENCIL, state );
d1849 1
a1849 1
      rmesa->recheck_texgen[ctx->Texture.CurrentUnit] = GL_TRUE; 
d1864 1
a1864 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d1868 1
a1868 1
   if (RADEON_DEBUG & DEBUG_STATE)
d1883 1
a1883 1
   if (RADEON_DEBUG & DEBUG_STATE) 
d1893 1
a1893 1
void radeonUploadTexMatrix( radeonContextPtr rmesa,
d1903 1
a1903 1
   column 3 and 4 (for the 2d / 1d / texrect targets) since the the q coord
d1919 1
a1919 1
   struct gl_texture_unit tUnit = rmesa->glCtx->Texture.Unit[unit];
d1973 1
a1973 1
static void upload_matrix( radeonContextPtr rmesa, GLfloat *src, int idx )
d1989 1
a1989 1
static void upload_matrix_t( radeonContextPtr rmesa, GLfloat *src, int idx )
d1999 1
a1999 1
   radeonContextPtr rmesa = RADEON_CONTEXT( ctx );
d2063 7
d2071 5
a2075 18
/**
 * Tell the card where to render (offset, pitch).
 * Effected by glDrawBuffer, etc
 */
void
radeonUpdateDrawBuffer(GLcontext *ctx)
{
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
   struct gl_framebuffer *fb = ctx->DrawBuffer;
   driRenderbuffer *drb;

   if (fb->_ColorDrawBufferIndexes[0] == BUFFER_FRONT_LEFT) {
      /* draw to front */
      drb = (driRenderbuffer *) fb->Attachment[BUFFER_FRONT_LEFT].Renderbuffer;
   }
   else if (fb->_ColorDrawBufferIndexes[0] == BUFFER_BACK_LEFT) {
      /* draw to back */
      drb = (driRenderbuffer *) fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer;
d2077 7
a2083 3
   else {
      /* drawing to multiple buffers, or none */
      return;
d2086 2
a2087 2
   assert(drb);
   assert(drb->flippedPitch);
d2089 2
a2090 1
   RADEON_STATECHANGE( rmesa, ctx );
d2092 7
a2098 7
   /* Note: we used the (possibly) page-flipped values */
   rmesa->hw.ctx.cmd[CTX_RB3D_COLOROFFSET]
     = ((drb->flippedOffset + rmesa->radeonScreen->fbLocation)
	& RADEON_COLOROFFSET_MASK);
   rmesa->hw.ctx.cmd[CTX_RB3D_COLORPITCH] = drb->flippedPitch;
   if (rmesa->sarea->tiling_enabled) {
      rmesa->hw.ctx.cmd[CTX_RB3D_COLORPITCH] |= RADEON_COLOR_TILE_ENABLE;
d2100 5
d2107 1
a2107 2

void radeonValidateState( GLcontext *ctx )
d2109 2
a2110 2
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
   GLuint new_state = rmesa->NewGLState;
d2112 5
a2116 2
   if (new_state & (_NEW_BUFFERS | _NEW_COLOR | _NEW_PIXEL)) {
     radeonUpdateDrawBuffer(ctx);
d2121 1
a2121 1
      new_state |= rmesa->NewGLState; /* may add TEXTURE_MATRIX */
d2124 4
d2130 1
a2130 1
   if (new_state & (_NEW_MODELVIEW|_NEW_PROJECTION)) 
d2154 1
a2154 1
      if (ctx->Transform.ClipPlanesEnabled) 
d2159 3
a2161 1
   rmesa->NewGLState = 0;
d2172 1
a2172 1
   RADEON_CONTEXT(ctx)->NewGLState |= new_state;
d2183 2
a2184 2
   for (i = _TNL_ATTRIB_MAT_FRONT_AMBIENT; 
	i < _TNL_ATTRIB_MAT_BACK_INDEXES; 
d2192 1
a2192 1
      
d2196 1
a2196 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d2200 1
a2200 1
      fprintf(stderr, "%s, newstate: %x\n", __FUNCTION__, rmesa->NewGLState);
d2204 3
a2206 2
   if (rmesa->NewGLState)
      radeonValidateState( ctx );
d2215 1
a2215 1
    */ 
d2223 16
d2244 1
a2244 1
void radeonInitStateFuncs( GLcontext *ctx )
a2256 1
   ctx->Driver.ClearIndex		= NULL;
a2267 1
   ctx->Driver.IndexMask		= NULL;
d2275 4
a2278 1
   ctx->Driver.PolygonStipple		= radeonPolygonStipple;
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a0 1
/* $XFree86: xc/lib/GL/mesa/src/drv/radeon/radeon_state.c,v 1.8 2002/12/16 16:18:58 dawes Exp $ */
d35 8
a42 8
#include "glheader.h"
#include "imports.h"
#include "api_arrayelt.h"
#include "enums.h"
#include "light.h"
#include "state.h"
#include "context.h"
#include "framebuffer.h"
d690 1
a690 1
   u_int32_t p = rmesa->hw.ctx.cmd[CTX_PP_CNTL];
@


1.1
log
@Initial revision
@
text
@d43 1
d45 1
a45 1
#include "array_cache/acache.h"
a55 1
#include "radeon_vtxfmt.h"
d1638 4
a1641 1
   __DRIdrawablePrivate *dPriv = rmesa->dri.drawable;
d1643 1
a1643 2
   if (rmesa->glCtx->DrawBuffer->_ColorDrawBufferMask[0]
       == BUFFER_BIT_BACK_LEFT) {
d1646 3
a1648 3
      if ( dPriv->numBackClipRects == 0 || rmesa->doPageFlip ) {
	 rmesa->numClipRects = dPriv->numClipRects;
	 rmesa->pClipRects = dPriv->pClipRects;
d1651 2
a1652 2
	 rmesa->numClipRects = dPriv->numBackClipRects;
	 rmesa->pClipRects = dPriv->pBackClipRects;
d1657 16
a1672 2
      rmesa->numClipRects = dPriv->numClipRects;
      rmesa->pClipRects = dPriv->pClipRects;
d1677 2
d1695 9
a1703 7
   /*
    * _ColorDrawBufferMask is easier to cope with than <mode>.
    * Check for software fallback, update cliprects.
    */
   switch ( ctx->DrawBuffer->_ColorDrawBufferMask[0] ) {
   case BUFFER_BIT_FRONT_LEFT:
   case BUFFER_BIT_BACK_LEFT:
a1706 1
      /* 0 (GL_NONE) buffers or multiple color drawing buffers */
d2225 1
a2225 1
   if (fb->_ColorDrawBufferMask[0] == BUFFER_BIT_FRONT_LEFT) {
d2229 1
a2229 1
   else if (fb->_ColorDrawBufferMask[0] == BUFFER_BIT_BACK_LEFT) {
d2307 1
a2307 1
   _ac_InvalidateState( ctx, new_state );
a2310 1
   radeonVtxfmtInvalidate( ctx );
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a42 1
#include "framebuffer.h"
d1638 1
a1638 4
   __DRIdrawablePrivate *const drawable = rmesa->dri.drawable;
   __DRIdrawablePrivate *const readable = rmesa->dri.readable;
   GLframebuffer *const draw_fb = (GLframebuffer*) drawable->driverPrivate;
   GLframebuffer *const read_fb = (GLframebuffer*) readable->driverPrivate;
d1640 1
a1640 1
   if (draw_fb->_ColorDrawBufferMask[0]
d1644 3
a1646 3
      if ( drawable->numBackClipRects == 0 || rmesa->doPageFlip ) {
	 rmesa->numClipRects = drawable->numClipRects;
	 rmesa->pClipRects = drawable->pClipRects;
d1649 2
a1650 2
	 rmesa->numClipRects = drawable->numBackClipRects;
	 rmesa->pClipRects = drawable->pBackClipRects;
d1655 2
a1656 16
      rmesa->numClipRects = drawable->numClipRects;
      rmesa->pClipRects = drawable->pClipRects;
   }

   if ((draw_fb->Width != drawable->w) || (draw_fb->Height != drawable->h)) {
      _mesa_resize_framebuffer(rmesa->glCtx, draw_fb,
			       drawable->w, drawable->h);
      draw_fb->Initialized = GL_TRUE;
   }

   if (drawable != readable) {
      if ((read_fb->Width != readable->w) || (read_fb->Height != readable->h)) {
	 _mesa_resize_framebuffer(rmesa->glCtx, read_fb,
				  readable->w, readable->h);
	 read_fb->Initialized = GL_TRUE;
      }
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d45 1
a45 1
#include "vbo/vbo.h"
d56 1
a1678 2

   rmesa->lastStamp = drawable->lastStamp;
d2306 1
a2306 1
   _vbo_InvalidateState( ctx, new_state );
d2310 1
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d1 1
d36 8
a43 8
#include "main/glheader.h"
#include "main/imports.h"
#include "main/api_arrayelt.h"
#include "main/enums.h"
#include "main/light.h"
#include "main/context.h"
#include "main/framebuffer.h"
#include "main/simple_list.h"
a48 1
#include "drivers/common/meta.h"
a50 1
#include "radeon_mipmap_tree.h"
d56 1
d58 1
a58 1
static void radeonUpdateSpecular( struct gl_context *ctx );
d64 1
a64 1
static void radeonAlphaFunc( struct gl_context *ctx, GLenum func, GLfloat ref )
d66 1
a66 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d107 1
a107 1
static void radeonBlendEquationSeparate( struct gl_context *ctx,
d110 1
a110 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d147 1
a147 1
static void radeonBlendFuncSeparate( struct gl_context *ctx,
d151 2
a152 2
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLuint b = rmesa->hw.ctx.cmd[CTX_RB3D_BLENDCNTL] &
d259 1
a259 1
static void radeonDepthFunc( struct gl_context *ctx, GLenum func )
d261 1
a261 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d295 1
a295 1
static void radeonDepthMask( struct gl_context *ctx, GLboolean flag )
d297 1
a297 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d307 1
a307 1
static void radeonClearDepth( struct gl_context *ctx, GLclampd d )
d309 1
a309 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d315 1
a315 1
      rmesa->radeon.state.depth.clear = d * 0x0000ffff;
d318 1
a318 1
      rmesa->radeon.state.depth.clear = d * 0x00ffffff;
d329 1
a329 1
static void radeonFogfv( struct gl_context *ctx, GLenum pname, const GLfloat *param )
d331 1
a331 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d395 1
a395 1
   case GL_FOG_COLOR:
d410 96
d510 1
a510 1
static void radeonCullFace( struct gl_context *ctx, GLenum unused )
d512 1
a512 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d547 1
a547 1
static void radeonFrontFace( struct gl_context *ctx, GLenum mode )
d549 1
a549 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
a556 4
   /* Winding is inverted when rendering to FBO */
   if (ctx->DrawBuffer && ctx->DrawBuffer->Name)
      mode = (mode == GL_CW) ? GL_CCW : GL_CW;

d572 1
a572 1
static void radeonLineWidth( struct gl_context *ctx, GLfloat widthf )
d574 1
a574 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d589 1
a589 1
static void radeonLineStipple( struct gl_context *ctx, GLint factor, GLushort pattern )
d591 1
a591 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d594 1
a594 1
   rmesa->hw.lin.cmd[LIN_RE_LINE_PATTERN] =
d602 1
a602 1
static void radeonColorMask( struct gl_context *ctx,
d606 6
a611 13
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   struct radeon_renderbuffer *rrb;
   GLuint mask;

   rrb = radeon_get_colorbuffer(&rmesa->radeon);
   if (!rrb)
     return;

   mask = radeonPackColor( rrb->cpp,
			   ctx->Color.ColorMask[0][RCOMP],
			   ctx->Color.ColorMask[0][GCOMP],
			   ctx->Color.ColorMask[0][BCOMP],
			   ctx->Color.ColorMask[0][ACOMP] );
d624 1
a624 1
static void radeonPolygonOffset( struct gl_context *ctx,
d627 2
a628 3
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   const GLfloat depthScale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
   float_ui32_type constant =  { units * depthScale };
d636 1
a636 1
static void radeonPolygonStipplePreKMS( struct gl_context *ctx, const GLubyte *mask )
d638 1
a638 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d650 2
a651 2
   radeon_firevertices(&rmesa->radeon);
   LOCK_HARDWARE( &rmesa->radeon );
d656 3
a658 3
   drmCommandWrite( rmesa->radeon.dri.fd, DRM_RADEON_STIPPLE,
		    &stipple, sizeof(drm_radeon_stipple_t) );
   UNLOCK_HARDWARE( &rmesa->radeon );
d661 1
a661 1
static void radeonPolygonMode( struct gl_context *ctx, GLenum face, GLenum mode )
d663 1
a663 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d667 1
a667 1
    * cases work.
d670 1
a670 1
   if (rmesa->radeon.TclFallback) {
d688 1
a688 1
static void radeonUpdateSpecular( struct gl_context *ctx )
d690 2
a691 2
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   uint32_t p = rmesa->hw.ctx.cmd[CTX_PP_CNTL];
d715 1
a715 1
      rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] &=
d745 1
a745 1

d761 1
a761 1
   if (rmesa->radeon.TclFallback) {
d773 1
a773 1
/* Update on colormaterial, material emmissive/ambient,
d776 1
a776 1
static void update_global_ambient( struct gl_context *ctx )
d778 1
a778 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d786 1
a786 1
	(3 << RADEON_AMBIENT_SOURCE_SHIFT))) == 0)
d788 1
a788 1
      COPY_3V( &fcmd[GLT_RED],
d793 1
a793 1
   }
d798 1
a798 1

d802 1
a802 1
/* Update on change to
d806 1
a806 1
static void update_light_colors( struct gl_context *ctx, GLuint p )
d813 1
a813 1
      r100ContextPtr rmesa = R100_CONTEXT(ctx);
d816 1
a816 1
      COPY_4V( &fcmd[LIT_AMBIENT_RED], l->Ambient );
d819 1
a819 1

d826 1
a826 1
static void check_twoside_fallback( struct gl_context *ctx )
d833 1
a833 1
	  (ctx->Light.ColorMaterialBitmask & BACK_MATERIAL_BITS) !=
d841 1
a841 1
	       fallback = GL_TRUE;
d851 1
a851 1
static void radeonColorMaterial( struct gl_context *ctx, GLenum face, GLenum mode )
d853 1
a853 1
      r100ContextPtr rmesa = R100_CONTEXT(ctx);
d859 2
a860 2
			   (3 << RADEON_SPECULAR_SOURCE_SHIFT));

d881 1
a881 1

d890 1
a890 1

d908 1
a908 1

d911 1
a911 1
	 rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL] = light_model_ctl1;
d915 1
a915 1
void radeonUpdateMaterial( struct gl_context *ctx )
d917 1
a917 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d921 1
a921 1

d925 1
a925 1
   if (RADEON_DEBUG & RADEON_STATE)
d928 1
a928 1

d971 1
a971 1
 *       _NormSpotDirection
d978 1
a978 1
 * and _MESA_NEW_NEED_EYE_COORDS.
d980 1
a980 1
static void update_light( struct gl_context *ctx )
d982 1
a982 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d995 1
a995 1

d1000 1
a1000 1
      if (tmp != rmesa->hw.tcl.cmd[TCL_LIGHT_MODEL_CTL])
d1024 1
a1024 1

d1026 2
a1027 2
	       COPY_3FV( &fcmd[LIT_POSITION_X], l->_VP_inf_norm );
	       COPY_3FV( &fcmd[LIT_DIRECTION_X], l->_h_inf_norm );
d1032 3
a1034 3
	       fcmd[LIT_DIRECTION_X] = -l->_NormSpotDirection[0];
	       fcmd[LIT_DIRECTION_Y] = -l->_NormSpotDirection[1];
	       fcmd[LIT_DIRECTION_Z] = -l->_NormSpotDirection[2];
d1044 1
a1044 1
static void radeonLightfv( struct gl_context *ctx, GLenum light,
d1047 1
a1047 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d1051 1
a1051 1

d1054 1
a1054 1
   case GL_AMBIENT:
d1060 2
a1061 2
   case GL_SPOT_DIRECTION:
      /* picked up in update_light */
d1065 1
a1065 1
      /* positions picked up in update_light, but can do flag here */
d1070 1
a1070 1
      if (p&1)
d1162 1
d1165 1
a1165 2

static void radeonLightModelfv( struct gl_context *ctx, GLenum pname,
d1168 1
a1168 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d1171 1
a1171 1
      case GL_LIGHT_MODEL_AMBIENT:
d1192 1
a1192 1
	 if (rmesa->radeon.TclFallback) {
d1207 1
a1207 1
static void radeonShadeModel( struct gl_context *ctx, GLenum mode )
d1209 1
a1209 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d1245 1
a1245 1
static void radeonClipPlane( struct gl_context *ctx, GLenum plane, const GLfloat *eq )
d1248 1
a1248 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d1258 1
a1258 1
static void radeonUpdateClipPlanes( struct gl_context *ctx )
d1260 1
a1260 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d1282 1
a1282 1
radeonStencilFuncSeparate( struct gl_context *ctx, GLenum face, GLenum func,
d1285 1
a1285 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d1327 1
a1327 1
radeonStencilMaskSeparate( struct gl_context *ctx, GLenum face, GLuint mask )
d1329 1
a1329 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d1337 1
a1337 1
static void radeonStencilOpSeparate( struct gl_context *ctx, GLenum face, GLenum fail,
d1340 1
a1340 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d1345 1
a1345 1

d1352 2
a1353 2

   if (rmesa->radeon.radeonScreen->chip_flags & RADEON_CHIPSET_BROKEN_STENCIL) {
d1369 1
a1369 1

d1457 1
a1457 1
static void radeonClearStencil( struct gl_context *ctx, GLint s )
d1459 1
a1459 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d1461 1
a1461 1
   rmesa->radeon.state.stencil.clear =
d1483 1
a1483 1
void radeonUpdateWindow( struct gl_context *ctx )
d1485 4
a1488 4
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   __DRIdrawable *dPriv = radeon_get_drawable(&rmesa->radeon);
   GLfloat xoffset = dPriv ? (GLfloat) dPriv->x : 0;
   GLfloat yoffset = dPriv ? (GLfloat) dPriv->y + dPriv->h : 0;
a1489 11
   const GLboolean render_to_fbo = (ctx->DrawBuffer ? (ctx->DrawBuffer->Name != 0) : 0);
   const GLfloat depthScale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
   GLfloat y_scale, y_bias;

   if (render_to_fbo) {
      y_scale = 1.0;
      y_bias = 0;
   } else {
      y_scale = -1.0;
      y_bias = yoffset;
   }
d1493 4
a1496 4
   float_ui32_type sy = { v[MAT_SY] * y_scale };
   float_ui32_type ty = { (v[MAT_TY] * y_scale) + y_bias + SUBPIXEL_Y };
   float_ui32_type sz = { v[MAT_SZ] * depthScale };
   float_ui32_type tz = { v[MAT_TZ] * depthScale };
d1498 1
d1510 1
a1510 1
static void radeonViewport( struct gl_context *ctx, GLint x, GLint y,
a1517 2

   radeon_viewport(ctx, x, y, width, height);
d1520 1
a1520 1
static void radeonDepthRange( struct gl_context *ctx, GLclampd nearval,
d1526 1
a1526 1
void radeonUpdateViewportOffset( struct gl_context *ctx )
d1528 2
a1529 2
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   __DRIdrawable *dPriv = radeon_get_drawable(&rmesa->radeon);
d1559 2
a1560 2
         stx = 31 - ((dPriv->x - 1) & RADEON_STIPPLE_COORD_MASK);
         sty = 31 - ((dPriv->y + dPriv->h - 1)
d1582 1
a1582 1
static void radeonClearColor( struct gl_context *ctx, const GLfloat color[4] )
d1584 1
a1584 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
a1585 6
   struct radeon_renderbuffer *rrb;

   rrb = radeon_get_colorbuffer(&rmesa->radeon);
   if (!rrb)
     return;
     
d1590 1
a1590 1
   rmesa->radeon.state.color.clear = radeonPackColor( rrb->cpp,
d1595 1
a1595 1
static void radeonRenderMode( struct gl_context *ctx, GLenum mode )
d1597 1
a1597 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d1621 1
a1621 1
static void radeonLogicOpCode( struct gl_context *ctx, GLenum opcode )
d1623 1
a1623 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d1632 92
d1728 1
a1728 1
static void radeonEnable( struct gl_context *ctx, GLenum cap, GLboolean state )
d1730 1
a1730 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d1733 1
a1733 1
   if ( RADEON_DEBUG & RADEON_STATE )
d1791 1
a1791 1
   case GL_CLIP_PLANE5:
d1825 1
a1825 1
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] &= ~rmesa->radeon.state.color.roundEnable;
d1828 1
a1828 1
	 rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] |=  rmesa->radeon.state.color.roundEnable;
d1856 1
a1856 1
      if (p&1)
d1858 1
a1858 1
		 RADEON_LIGHT_1_ENABLE_AMBIENT |
d1862 1
a1862 1
		 RADEON_LIGHT_0_ENABLE_AMBIENT |
d1870 1
a1870 1
      /*
d1908 1
a1908 1

d1975 2
a1976 2
      radeon_firevertices(&rmesa->radeon);
      rmesa->radeon.state.scissor.enabled = state;
d1981 4
a1984 15
      {
	 GLboolean hw_stencil = GL_FALSE;
	 if (ctx->DrawBuffer) {
	    struct radeon_renderbuffer *rrbStencil
	       = radeon_get_renderbuffer(ctx->DrawBuffer, BUFFER_STENCIL);
	    hw_stencil = (rrbStencil && rrbStencil->bo);
	 }

	 if (hw_stencil) {
	    RADEON_STATECHANGE( rmesa, ctx );
	    if ( state ) {
	       rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] |=  RADEON_STENCIL_ENABLE;
	    } else {
	       rmesa->hw.ctx.cmd[CTX_RB3D_CNTL] &= ~RADEON_STENCIL_ENABLE;
	    }
d1986 1
a1986 1
	    FALLBACK( rmesa, RADEON_FALLBACK_STENCIL, state );
d1988 2
d1999 1
a1999 1
      rmesa->recheck_texgen[ctx->Texture.CurrentUnit] = GL_TRUE;
d2012 1
a2012 1
static void radeonLightingSpaceChange( struct gl_context *ctx )
d2014 1
a2014 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d2018 1
a2018 1
   if (RADEON_DEBUG & RADEON_STATE)
d2033 1
a2033 1
   if (RADEON_DEBUG & RADEON_STATE)
d2043 1
a2043 1
void radeonUploadTexMatrix( r100ContextPtr rmesa,
d2053 1
a2053 1
   column 3 and 4 (for the 2d / 1d / texrect targets) since the q coord
d2069 1
a2069 1
   struct gl_texture_unit tUnit = rmesa->radeon.glCtx->Texture.Unit[unit];
d2123 1
a2123 1
static void upload_matrix( r100ContextPtr rmesa, GLfloat *src, int idx )
d2139 1
a2139 1
static void upload_matrix_t( r100ContextPtr rmesa, GLfloat *src, int idx )
d2147 1
a2147 1
static void update_texturematrix( struct gl_context *ctx )
d2149 1
a2149 1
   r100ContextPtr rmesa = R100_CONTEXT( ctx );
d2213 7
a2219 1
static GLboolean r100ValidateBuffers(struct gl_context *ctx)
d2221 11
a2231 11
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   struct radeon_renderbuffer *rrb;
   int i, ret;

   radeon_cs_space_reset_bos(rmesa->radeon.cmdbuf.cs);

   rrb = radeon_get_colorbuffer(&rmesa->radeon);
   /* color buffer */
   if (rrb && rrb->bo) {
     radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs, rrb->bo,
				       0, RADEON_GEM_DOMAIN_VRAM);
d2233 3
a2235 7

   /* depth buffer */
   rrb = radeon_get_depthbuffer(&rmesa->radeon);
   /* color buffer */
   if (rrb && rrb->bo) {
     radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs, rrb->bo,
				       0, RADEON_GEM_DOMAIN_VRAM);
d2238 2
a2239 2
   for (i = 0; i < ctx->Const.MaxTextureImageUnits; ++i) {
      radeonTexObj *t;
d2241 1
a2241 2
      if (!ctx->Texture.Unit[i]._ReallyEnabled)
	 continue;
d2243 7
a2249 10
      t = rmesa->state.texture.unit[i].texobj;

      if (!t)
	 continue;
      if (t->image_override && t->bo)
	radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs, t->bo,
			   RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0);
      else if (t->mt->bo)
	radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs, t->mt->bo,
			   RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0);
d2251 1
a2252 5
   ret = radeon_cs_space_check_with_bo(rmesa->radeon.cmdbuf.cs, first_elem(&rmesa->radeon.dma.reserved)->bo, RADEON_GEM_DOMAIN_GTT, 0);
   if (ret)
       return GL_FALSE;
   return GL_TRUE;
}
d2254 1
a2254 1
GLboolean radeonValidateState( struct gl_context *ctx )
d2256 2
a2257 2
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLuint new_state = rmesa->radeon.NewGLState;
d2259 2
a2260 5
   if (new_state & _NEW_BUFFERS) {
     _mesa_update_framebuffer(ctx);
     /* this updates the DrawBuffer's Width/Height if it's a FBO */
     _mesa_update_draw_buffer_bounds(ctx);
     RADEON_STATECHANGE(rmesa, ctx);
d2265 1
a2265 1
      new_state |= rmesa->radeon.NewGLState; /* may add TEXTURE_MATRIX */
a2267 4
   /* we need to do a space check here */
   if (!r100ValidateBuffers(ctx))
     return GL_FALSE;

d2270 1
a2270 1
   if (new_state & (_NEW_MODELVIEW|_NEW_PROJECTION))
d2294 1
a2294 1
      if (ctx->Transform.ClipPlanesEnabled)
d2299 1
a2299 3
   rmesa->radeon.NewGLState = 0;

   return GL_TRUE;
d2303 1
a2303 1
static void radeonInvalidateState( struct gl_context *ctx, GLuint new_state )
d2310 1
a2310 1
   R100_CONTEXT(ctx)->radeon.NewGLState |= new_state;
d2316 1
a2316 1
static GLboolean check_material( struct gl_context *ctx )
d2321 2
a2322 2
   for (i = _TNL_ATTRIB_MAT_FRONT_AMBIENT;
	i < _TNL_ATTRIB_MAT_BACK_INDEXES;
d2330 1
d2332 1
a2332 2

static void radeonWrapRunPipeline( struct gl_context *ctx )
d2334 1
a2334 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d2338 1
a2338 1
      fprintf(stderr, "%s, newstate: %x\n", __FUNCTION__, rmesa->radeon.NewGLState);
d2342 2
a2343 3
   if (rmesa->radeon.NewGLState)
      if (!radeonValidateState( ctx ))
	 FALLBACK(rmesa, RADEON_FALLBACK_TEXTURE, GL_TRUE);
d2352 1
a2352 1
    */
a2359 16
static void radeonPolygonStipple( struct gl_context *ctx, const GLubyte *mask )
{
   r100ContextPtr r100 = R100_CONTEXT(ctx);
   GLint i;

   radeon_firevertices(&r100->radeon);

   RADEON_STATECHANGE(r100, stp);

   /* Must flip pattern upside down.
    */
   for ( i = 31 ; i >= 0; i--) {
     r100->hw.stp.cmd[3 + i] = ((GLuint *) mask)[i];
   }
}

d2365 1
a2365 1
void radeonInitStateFuncs( struct gl_context *ctx , GLboolean dri2 )
a2371 4
   ctx->Driver.CopyPixels               = _mesa_meta_CopyPixels;
   ctx->Driver.DrawPixels               = _mesa_meta_DrawPixels;
   if (dri2)
	   ctx->Driver.ReadPixels               = radeonReadPixels;
d2378 1
d2390 1
d2398 1
a2398 4
   if (dri2)
      ctx->Driver.PolygonStipple		= radeonPolygonStipple;
   else
      ctx->Driver.PolygonStipple		= radeonPolygonStipplePreKMS;
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@a41 1
#include "main/fbobject.h"
a42 3
#include "main/state.h"
#include "main/core.h"
#include "main/stencil.h"
d139 1
a139 1
	    && ctx->Color.Blend[0].EquationRGB == GL_LOGIC_OP)) ) {
d156 1
a156 1
   switch ( ctx->Color.Blend[0].SrcRGB ) {
d203 1
a203 1
   switch ( ctx->Color.Blend[0].DstRGB ) {
d307 16
d333 1
a333 1
   GLubyte col[4];
d397 1
a397 1
      _mesa_unclamped_float_rgba_to_ubyte(col, ctx->Fog.Color );
a453 1
   int cull_face = (mode == GL_CW) ? RADEON_FFACE_CULL_CW : RADEON_FFACE_CULL_CCW;
d462 2
a463 3
   if (ctx->DrawBuffer && _mesa_is_user_fbo(ctx->DrawBuffer))
      cull_face = (mode == GL_CCW) ? RADEON_FFACE_CULL_CW : RADEON_FFACE_CULL_CCW;
   rmesa->hw.set.cmd[SET_SE_CNTL] |= cull_face;
d465 6
a470 1
   if ( mode == GL_CCW )
d472 2
d552 25
d580 1
a580 2
   GLboolean unfilled = (ctx->Polygon.FrontMode != GL_FILL ||
                         ctx->Polygon.BackMode != GL_FILL);
d585 1
a585 1
   TCL_FALLBACK( ctx, RADEON_TCL_FALLBACK_UNFILLED, unfilled);
d664 1
a664 1
   if (_mesa_need_secondary_color(ctx)) {
d749 2
a750 2
	  (ctx->Light._ColorMaterialBitmask & BACK_MATERIAL_BITS) !=
	  ((ctx->Light._ColorMaterialBitmask & FRONT_MATERIAL_BITS)<<1))
d778 1
a778 1
      GLuint mask = ctx->Light._ColorMaterialBitmask;
d839 1
a839 1
      mask &= ~ctx->Light._ColorMaterialBitmask;
d1202 1
a1202 1
   GLuint refmask = ((_mesa_get_stencil_ref(ctx, 0) << RADEON_STENCIL_REF_SHIFT) |
d1373 9
d1403 2
a1404 2
   GLfloat xoffset = 0.0;
   GLfloat yoffset = dPriv ? (GLfloat) dPriv->h : 0;
d1406 1
a1406 1
   const GLboolean render_to_fbo = (ctx->DrawBuffer ? _mesa_is_user_fbo(ctx->DrawBuffer) : 0);
d1458 2
a1459 2
   GLfloat xoffset = 0.0;
   GLfloat yoffset = (GLfloat)dPriv->h;
d1487 2
a1488 2
         stx = 31 - ((-1) & RADEON_STIPPLE_COORD_MASK);
         sty = 31 - ((dPriv->h - 1)
d1510 19
d1605 1
a1605 1
	    && ctx->Color.Blend[0].EquationRGB == GL_LOGIC_OP)) ) {
d1615 6
a1620 6
					    ctx->Color.Blend[0].EquationRGB,
					    ctx->Color.Blend[0].EquationA );
	 ctx->Driver.BlendFuncSeparate( ctx, ctx->Color.Blend[0].SrcRGB,
					ctx->Color.Blend[0].DstRGB,
					ctx->Color.Blend[0].SrcA,
					ctx->Color.Blend[0].DstA );
d1744 1
a1744 1
	    && ctx->Color.Blend[0].EquationRGB == GL_LOGIC_OP)) ) {
d1920 1
a1920 1
   struct gl_texture_unit tUnit = rmesa->radeon.glCtx.Texture.Unit[unit];
d2087 1
a2087 1
   for (i = 0; i < ctx->Const.FragmentProgram.MaxTextureImageUnits; ++i) {
d2248 1
a2248 1
void radeonInitStateFuncs( struct gl_context *ctx )
d2257 2
a2258 1
   ctx->Driver.ReadPixels               = radeonReadPixels;
d2263 3
d2283 4
a2286 1
   ctx->Driver.PolygonStipple		= radeonPolygonStipple;
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d32 1
a32 1
 *   Keith Whitwell <keithw@@vmware.com>
d1355 1
a1355 1
   const GLfloat *v = ctx->ViewportArray[0]._WindowMap.m;
d1386 2
a1387 1
static void radeonViewport(struct gl_context *ctx)
d1395 1
a1395 1
   radeon_viewport(ctx);
d1398 2
a1399 1
static void radeonDepthRange(struct gl_context *ctx)
d1410 1
a1410 1
   const GLfloat *v = ctx->ViewportArray[0]._WindowMap.m;
d1855 1
a1855 3
   if (!tUnit._Current ||
       (tUnit._Current->Target != GL_TEXTURE_3D &&
        tUnit._Current->Target != GL_TEXTURE_CUBE_MAP)) {
d1940 1
a1940 1
      if (ctx->Texture.Unit[unit]._Current) {
d2018 1
a2018 1
   for (i = 0; i < ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits; ++i) {
d2021 1
a2021 1
      if (!ctx->Texture.Unit[i]._Current)
@


1.1.1.7
log
@Import Mesa 10.2.7
@
text
@d1995 1
a1995 1
GLboolean r100ValidateBuffers(struct gl_context *ctx)
@


1.1.1.8
log
@Import Mesa 10.4.3
@
text
@d1402 52
@


1.1.1.9
log
@Import Mesa 10.2.9
@
text
@a1401 52
void radeonUpdateViewportOffset( struct gl_context *ctx )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   __DRIdrawable *dPriv = radeon_get_drawable(&rmesa->radeon);
   GLfloat xoffset = 0.0;
   GLfloat yoffset = (GLfloat)dPriv->h;
   const GLfloat *v = ctx->ViewportArray[0]._WindowMap.m;

   float_ui32_type tx;
   float_ui32_type ty;

   tx.f = v[MAT_TX] + xoffset + SUBPIXEL_X;
   ty.f = (- v[MAT_TY]) + yoffset + SUBPIXEL_Y;

   if ( rmesa->hw.vpt.cmd[VPT_SE_VPORT_XOFFSET] != tx.ui32 ||
	rmesa->hw.vpt.cmd[VPT_SE_VPORT_YOFFSET] != ty.ui32 )
   {
      /* Note: this should also modify whatever data the context reset
       * code uses...
       */
      RADEON_STATECHANGE( rmesa, vpt );
      rmesa->hw.vpt.cmd[VPT_SE_VPORT_XOFFSET] = tx.ui32;
      rmesa->hw.vpt.cmd[VPT_SE_VPORT_YOFFSET] = ty.ui32;

      /* update polygon stipple x/y screen offset */
      {
         GLuint stx, sty;
         GLuint m = rmesa->hw.msc.cmd[MSC_RE_MISC];

         m &= ~(RADEON_STIPPLE_X_OFFSET_MASK |
                RADEON_STIPPLE_Y_OFFSET_MASK);

         /* add magic offsets, then invert */
         stx = 31 - ((-1) & RADEON_STIPPLE_COORD_MASK);
         sty = 31 - ((dPriv->h - 1)
                     & RADEON_STIPPLE_COORD_MASK);

         m |= ((stx << RADEON_STIPPLE_X_OFFSET_SHIFT) |
               (sty << RADEON_STIPPLE_Y_OFFSET_SHIFT));

         if ( rmesa->hw.msc.cmd[MSC_RE_MISC] != m ) {
            RADEON_STATECHANGE( rmesa, msc );
	    rmesa->hw.msc.cmd[MSC_RE_MISC] = m;
         }
      }
   }

   radeonUpdateScissor( ctx );
}



@


