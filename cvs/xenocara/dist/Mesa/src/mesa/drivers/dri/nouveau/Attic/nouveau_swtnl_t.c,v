head	1.4;
access;
symbols
	OPENBSD_5_8:1.3.0.8
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.6
	OPENBSD_5_7_BASE:1.3
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.3;
commitid	TnlogFl9nOv2eaRf;

1.3
date	2013.09.05.14.04.49;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.39;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.51;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright (C) 2009-2010 Francisco Jerez.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "tnl/t_context.h"
#include "tnl/t_pipeline.h"
#include "tnl/t_vertex.h"

#define SWTNL_VBO_SIZE 65536

static enum tnl_attr_format
swtnl_get_format(int type, int fields) {
	switch (type) {
	case GL_FLOAT:
		switch (fields){
		case 1:
			return EMIT_1F;
		case 2:
			return EMIT_2F;
		case 3:
			return EMIT_3F;
		case 4:
			return EMIT_4F;
		default:
			assert(0);
		}
	case GL_UNSIGNED_BYTE:
		switch (fields) {
		case 4:
			return EMIT_4UB_4F_RGBA;
		default:
			assert(0);
		}
	default:
		assert(0);
	}
}

static struct swtnl_attr_info {
	int type;
	int fields;
} swtnl_attrs[VERT_ATTRIB_MAX] = {
	[VERT_ATTRIB_POS] = {
		.type = GL_FLOAT,
		.fields = 4,
	},
	[VERT_ATTRIB_NORMAL] = {
		.type = GL_FLOAT,
		.fields = -1,
	},
	[VERT_ATTRIB_COLOR0] = {
		.type = GL_UNSIGNED_BYTE,
		.fields = 4,
	},
	[VERT_ATTRIB_COLOR1] = {
		.type = GL_UNSIGNED_BYTE,
		.fields = 4,
	},
	[VERT_ATTRIB_FOG] = {
		.type = GL_FLOAT,
		.fields = 1,
	},
	[VERT_ATTRIB_TEX0] = {
		.type = GL_FLOAT,
		.fields = -1,
	},
	[VERT_ATTRIB_TEX1] = {
		.type = GL_FLOAT,
		.fields = -1,
	},
	[VERT_ATTRIB_TEX2] = {
		.type = GL_FLOAT,
		.fields = -1,
	},
	[VERT_ATTRIB_TEX3] = {
		.type = GL_FLOAT,
		.fields = -1,
	},
};

static void
swtnl_choose_attrs(struct gl_context *ctx)
{
	struct nouveau_render_state *render = to_render_state(ctx);
	TNLcontext *tnl = TNL_CONTEXT(ctx);
	struct tnl_clipspace *vtx = &tnl->clipspace;
	static struct tnl_attr_map map[NUM_VERTEX_ATTRS];
	int fields, attr, i, n = 0;

	render->mode = VBO;
	render->attr_count = NUM_VERTEX_ATTRS;

	/* We always want non Ndc coords format */
	tnl->vb.AttribPtr[VERT_ATTRIB_POS] = tnl->vb.ClipPtr;

	for (i = 0; i < VERT_ATTRIB_MAX; i++) {
		struct nouveau_attr_info *ha = &TAG(vertex_attrs)[i];
		struct swtnl_attr_info *sa = &swtnl_attrs[i];
		struct nouveau_array *a = &render->attrs[i];

		if (!sa->fields)
			continue; /* Unsupported attribute. */

		if (tnl->render_inputs_bitset & BITFIELD64_BIT(i)) {
			if (sa->fields > 0)
				fields = sa->fields;
			else
				fields = tnl->vb.AttribPtr[i]->size;

			map[n++] = (struct tnl_attr_map) {
				.attrib = i,
				.format = swtnl_get_format(sa->type, fields),
			};

			render->map[ha->vbo_index] = i;
			a->attr = i;
			a->fields = fields;
			a->type = sa->type;
		}
	}

	_tnl_install_attrs(ctx, map, n, NULL, 0);

	FOR_EACH_BOUND_ATTR(render, i, attr)
		render->attrs[attr].stride = vtx->vertex_size;

	TAG(render_set_format)(ctx);
}

static void
swtnl_alloc_vertices(struct gl_context *ctx)
{
	struct nouveau_swtnl_state *swtnl = &to_render_state(ctx)->swtnl;

	nouveau_bo_ref(NULL, &swtnl->vbo);
	swtnl->buf = nouveau_get_scratch(ctx, SWTNL_VBO_SIZE, &swtnl->vbo,
					 &swtnl->offset);
	swtnl->vertex_count = 0;
}

static void
swtnl_bind_vertices(struct gl_context *ctx)
{
	struct nouveau_render_state *render = to_render_state(ctx);
	struct nouveau_swtnl_state *swtnl = &render->swtnl;
	struct tnl_clipspace *vtx = &TNL_CONTEXT(ctx)->clipspace;
	int i;

	for (i = 0; i < vtx->attr_count; i++) {
		struct tnl_clipspace_attr *ta = &vtx->attr[i];
		struct nouveau_array *a = &render->attrs[ta->attrib];

		nouveau_bo_ref(swtnl->vbo, &a->bo);
		a->offset = swtnl->offset + ta->vertoffset;
	}

	TAG(render_bind_vertices)(ctx);
}

static void
swtnl_unbind_vertices(struct gl_context *ctx)
{
	struct nouveau_render_state *render = to_render_state(ctx);
	int i, attr;

	TAG(render_release_vertices)(ctx);

	FOR_EACH_BOUND_ATTR(render, i, attr) {
		nouveau_bo_ref(NULL, &render->attrs[attr].bo);
		render->map[i] = -1;
	}

	render->attr_count = 0;
}

static void
swtnl_flush_vertices(struct gl_context *ctx)
{
	struct nouveau_pushbuf *push = context_push(ctx);
	struct nouveau_swtnl_state *swtnl = &to_render_state(ctx)->swtnl;
	unsigned npush, start = 0, count = swtnl->vertex_count;
	RENDER_LOCALS(ctx);

	swtnl_bind_vertices(ctx);

	while (count) {
		npush = get_max_vertices(ctx, NULL, PUSH_AVAIL(push));
		npush = MIN2(npush / 12 * 12, count);
		count -= npush;

		if (!npush) {
			PUSH_KICK(push);
			continue;
		}

		BATCH_BEGIN(nvgl_primitive(swtnl->primitive));
		EMIT_VBO(L, ctx, start, 0, npush);
		BATCH_END();

		PUSH_KICK(push);
	}

	swtnl_alloc_vertices(ctx);
}

/* TnL renderer entry points */

static void
swtnl_start(struct gl_context *ctx)
{
	swtnl_choose_attrs(ctx);
}

static void
swtnl_finish(struct gl_context *ctx)
{
	swtnl_flush_vertices(ctx);
	swtnl_unbind_vertices(ctx);
}

static void
swtnl_primitive(struct gl_context *ctx, GLenum mode)
{
}

static void
swtnl_reset_stipple(struct gl_context *ctx)
{
}

/* Primitive rendering */

#define BEGIN_PRIMITIVE(p, n)						\
	struct nouveau_swtnl_state *swtnl = &to_render_state(ctx)->swtnl; \
	int vertex_len = TNL_CONTEXT(ctx)->clipspace.vertex_size;	\
									\
	if (swtnl->vertex_count + (n) > SWTNL_VBO_SIZE/vertex_len	\
	    || (swtnl->vertex_count && swtnl->primitive != p))		\
		swtnl_flush_vertices(ctx);				\
									\
	swtnl->primitive = p;

#define OUT_VERTEX(i) do {						\
		memcpy(swtnl->buf + swtnl->vertex_count * vertex_len,	\
		       _tnl_get_vertex(ctx, (i)), vertex_len);		\
		swtnl->vertex_count++;					\
	} while (0)

static void
swtnl_points(struct gl_context *ctx, GLuint first, GLuint last)
{
	int i, count;

	while (first < last) {
		BEGIN_PRIMITIVE(GL_POINTS, last - first);

		count = MIN2(SWTNL_VBO_SIZE / vertex_len, last - first);
		for (i = 0; i < count; i++)
			OUT_VERTEX(first + i);

		first += count;
	}
}

static void
swtnl_line(struct gl_context *ctx, GLuint v1, GLuint v2)
{
	BEGIN_PRIMITIVE(GL_LINES, 2);
	OUT_VERTEX(v1);
	OUT_VERTEX(v2);
}

static void
swtnl_triangle(struct gl_context *ctx, GLuint v1, GLuint v2, GLuint v3)
{
	BEGIN_PRIMITIVE(GL_TRIANGLES, 3);
	OUT_VERTEX(v1);
	OUT_VERTEX(v2);
	OUT_VERTEX(v3);
}

static void
swtnl_quad(struct gl_context *ctx, GLuint v1, GLuint v2, GLuint v3, GLuint v4)
{
	BEGIN_PRIMITIVE(GL_QUADS, 4);
	OUT_VERTEX(v1);
	OUT_VERTEX(v2);
	OUT_VERTEX(v3);
	OUT_VERTEX(v4);
}

/* TnL initialization. */
void
TAG(swtnl_init)(struct gl_context *ctx)
{
	TNLcontext *tnl = TNL_CONTEXT(ctx);

	tnl->Driver.RunPipeline = _tnl_run_pipeline;
	tnl->Driver.Render.Interp = _tnl_interp;
	tnl->Driver.Render.CopyPV = _tnl_copy_pv;
	tnl->Driver.Render.ClippedPolygon = _tnl_RenderClippedPolygon;
	tnl->Driver.Render.ClippedLine = _tnl_RenderClippedLine;
	tnl->Driver.Render.BuildVertices = _tnl_build_vertices;

	tnl->Driver.Render.Start = swtnl_start;
	tnl->Driver.Render.Finish = swtnl_finish;
	tnl->Driver.Render.PrimitiveNotify = swtnl_primitive;
	tnl->Driver.Render.ResetLineStipple = swtnl_reset_stipple;

	tnl->Driver.Render.Points = swtnl_points;
	tnl->Driver.Render.Line = swtnl_line;
	tnl->Driver.Render.Triangle = swtnl_triangle;
	tnl->Driver.Render.Quad = swtnl_quad;

	_tnl_init_vertices(ctx, tnl->vb.Size,
			   NUM_VERTEX_ATTRS * 4 * sizeof(GLfloat));
	_tnl_need_projected_coords(ctx, GL_FALSE);
	_tnl_allow_vertex_fog(ctx, GL_FALSE);
	_tnl_wakeup(ctx);

	swtnl_alloc_vertices(ctx);
}

void
TAG(swtnl_destroy)(struct gl_context *ctx)
{
	nouveau_bo_ref(NULL, &to_render_state(ctx)->swtnl.vbo);
}
@


1.3
log
@Merge Mesa 9.2.0
@
text
@@


1.2
log
@Merge Mesa 7.10.3
@
text
@d126 1
a126 1
		if (RENDERINPUTS_TEST(tnl->render_inputs_bitset, i)) {
d188 2
d201 1
a201 1
	struct nouveau_channel *chan = context_chan(ctx);
d203 1
a203 1
	unsigned push, start = 0, count = swtnl->vertex_count;
d209 3
a211 3
		push = get_max_vertices(ctx, NULL, AVAIL_RING(chan));
		push = MIN2(push / 12 * 12, count);
		count -= push;
d213 2
a214 2
		if (!push) {
			FIRE_RING(chan);
d219 1
a219 1
		EMIT_VBO(L, ctx, start, 0, push);
d222 1
a222 1
		FIRE_RING(chan);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d31 2
d104 1
a104 1
swtnl_choose_attrs(GLcontext *ctx)
d110 1
a110 1
	int fields, i, n = 0;
d121 1
a121 1
		struct nouveau_array_state *a = &render->attrs[i];
d146 2
a147 7
	for (i = 0; i < vtx->attr_count; i++) {
		struct tnl_clipspace_attr *ta = &vtx->attr[i];
		struct nouveau_array_state *a = &render->attrs[ta->attrib];

		a->stride = vtx->vertex_size;
		a->offset = ta->vertoffset;
	}
d153 1
a153 1
swtnl_alloc_vertices(GLcontext *ctx)
d158 2
a159 2
	swtnl->buf = get_scratch_vbo(ctx, RENDER_SCRATCH_SIZE,
				     &swtnl->vbo, NULL);
d164 1
a164 1
swtnl_bind_vertices(GLcontext *ctx)
d168 1
d171 3
a173 2
	for (i = 0; i < render->attr_count; i++) {
		int attr = render->map[i];
d175 2
a176 3
		if (attr >= 0)
			nouveau_bo_ref(swtnl->vbo,
				       &render->attrs[attr].bo);
d183 1
a183 1
swtnl_unbind_vertices(GLcontext *ctx)
d186 1
a186 4
	int i;

	for (i = 0; i < render->attr_count; i++) {
		int *attr = &render->map[i];
d188 3
a190 4
		if (*attr >= 0) {
			nouveau_bo_ref(NULL, &render->attrs[*attr].bo);
			*attr = -1;
		}
d197 1
a197 1
swtnl_flush_vertices(GLcontext *ctx)
d229 1
a229 1
swtnl_start(GLcontext *ctx)
d235 1
a235 1
swtnl_finish(GLcontext *ctx)
d242 1
a242 1
swtnl_primitive(GLcontext *ctx, GLenum mode)
d247 1
a247 1
swtnl_reset_stipple(GLcontext *ctx)
d257 1
a257 1
	if (swtnl->vertex_count + (n) > swtnl->vbo->size/vertex_len	\
d270 1
a270 1
swtnl_points(GLcontext *ctx, GLuint first, GLuint last)
d277 1
a277 1
		count = MIN2(swtnl->vbo->size / vertex_len, last - first);
d286 1
a286 1
swtnl_line(GLcontext *ctx, GLuint v1, GLuint v2)
d294 1
a294 1
swtnl_triangle(GLcontext *ctx, GLuint v1, GLuint v2, GLuint v3)
d303 1
a303 1
swtnl_quad(GLcontext *ctx, GLuint v1, GLuint v2, GLuint v3, GLuint v4)
d313 2
a314 2
static void
TAG(swtnl_init)(GLcontext *ctx)
d344 2
a345 2
static void
TAG(swtnl_destroy)(GLcontext *ctx)
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a30 2
#define SWTNL_VBO_SIZE 65536

d102 1
a102 1
swtnl_choose_attrs(struct gl_context *ctx)
d108 1
a108 1
	int fields, attr, i, n = 0;
d119 1
a119 1
		struct nouveau_array *a = &render->attrs[i];
d144 7
a150 2
	FOR_EACH_BOUND_ATTR(render, i, attr)
		render->attrs[attr].stride = vtx->vertex_size;
d156 1
a156 1
swtnl_alloc_vertices(struct gl_context *ctx)
d161 2
a162 2
	swtnl->buf = nouveau_get_scratch(ctx, SWTNL_VBO_SIZE, &swtnl->vbo,
					 &swtnl->offset);
d167 1
a167 1
swtnl_bind_vertices(struct gl_context *ctx)
a170 1
	struct tnl_clipspace *vtx = &TNL_CONTEXT(ctx)->clipspace;
d173 2
a174 3
	for (i = 0; i < vtx->attr_count; i++) {
		struct tnl_clipspace_attr *ta = &vtx->attr[i];
		struct nouveau_array *a = &render->attrs[ta->attrib];
d176 3
a178 2
		nouveau_bo_ref(swtnl->vbo, &a->bo);
		a->offset = swtnl->offset + ta->vertoffset;
d185 1
a185 1
swtnl_unbind_vertices(struct gl_context *ctx)
d188 4
a191 1
	int i, attr;
d193 4
a196 3
	FOR_EACH_BOUND_ATTR(render, i, attr) {
		nouveau_bo_ref(NULL, &render->attrs[attr].bo);
		render->map[i] = -1;
d203 1
a203 1
swtnl_flush_vertices(struct gl_context *ctx)
d235 1
a235 1
swtnl_start(struct gl_context *ctx)
d241 1
a241 1
swtnl_finish(struct gl_context *ctx)
d248 1
a248 1
swtnl_primitive(struct gl_context *ctx, GLenum mode)
d253 1
a253 1
swtnl_reset_stipple(struct gl_context *ctx)
d263 1
a263 1
	if (swtnl->vertex_count + (n) > SWTNL_VBO_SIZE/vertex_len	\
d276 1
a276 1
swtnl_points(struct gl_context *ctx, GLuint first, GLuint last)
d283 1
a283 1
		count = MIN2(SWTNL_VBO_SIZE / vertex_len, last - first);
d292 1
a292 1
swtnl_line(struct gl_context *ctx, GLuint v1, GLuint v2)
d300 1
a300 1
swtnl_triangle(struct gl_context *ctx, GLuint v1, GLuint v2, GLuint v3)
d309 1
a309 1
swtnl_quad(struct gl_context *ctx, GLuint v1, GLuint v2, GLuint v3, GLuint v4)
d319 2
a320 2
void
TAG(swtnl_init)(struct gl_context *ctx)
d350 2
a351 2
void
TAG(swtnl_destroy)(struct gl_context *ctx)
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d126 1
a126 1
		if (tnl->render_inputs_bitset & BITFIELD64_BIT(i)) {
a187 2
	TAG(render_release_vertices)(ctx);

d199 1
a199 1
	struct nouveau_pushbuf *push = context_push(ctx);
d201 1
a201 1
	unsigned npush, start = 0, count = swtnl->vertex_count;
d207 3
a209 3
		npush = get_max_vertices(ctx, NULL, PUSH_AVAIL(push));
		npush = MIN2(npush / 12 * 12, count);
		count -= npush;
d211 2
a212 2
		if (!npush) {
			PUSH_KICK(push);
d217 1
a217 1
		EMIT_VBO(L, ctx, start, 0, npush);
d220 1
a220 1
		PUSH_KICK(push);
@


