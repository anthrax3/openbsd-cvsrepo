head	1.7;
access;
symbols
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.09.05.14.04.34;	author jsg;	state dead;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.06.15.50.02;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.38;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@/**************************************************************************
 * 
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
 * Copyright 2011 Intel Corporation
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 * Authors:
 *     Chad Versace <chad@@chad-versace.us>
 *
 **************************************************************************/

#include <stdbool.h>
#include <stdint.h>
#include "main/glheader.h"
#include "main/macros.h"
#include "main/mtypes.h"
#include "main/colormac.h"
#include "main/renderbuffer.h"

#include "intel_buffers.h"
#include "intel_fbo.h"
#include "intel_screen.h"
#include "intel_span.h"
#include "intel_regions.h"
#include "intel_tex.h"

#include "swrast/swrast.h"

static void
intel_set_span_functions(struct intel_context *intel,
			 struct gl_renderbuffer *rb);

#undef DBG
#define DBG 0

#define LOCAL_VARS							\
   struct intel_renderbuffer *irb = intel_renderbuffer(rb);		\
   int minx = 0, miny = 0;						\
   int maxx = rb->Width;						\
   int maxy = rb->Height;						\
   int pitch = rb->RowStride * irb->region->cpp;			\
   void *buf = rb->Data;						\
   GLuint p;								\
   (void) p;

#define HW_CLIPLOOP()
#define HW_ENDCLIPLOOP()

#define Y_FLIP(_y) (_y)

#define HW_LOCK()

#define HW_UNLOCK()

/* r5g6b5 color span and pixel functions */
#define SPANTMP_PIXEL_FMT GL_RGB
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_5_6_5
#define TAG(x) intel_##x##_RGB565
#define TAG2(x,y) intel_##x##y_RGB565
#include "spantmp2.h"

/* a4r4g4b4 color span and pixel functions */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_4_4_4_4_REV
#define TAG(x) intel_##x##_ARGB4444
#define TAG2(x,y) intel_##x##y_ARGB4444
#include "spantmp2.h"

/* a1r5g5b5 color span and pixel functions */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_1_5_5_5_REV
#define TAG(x) intel_##x##_ARGB1555
#define TAG2(x,y) intel_##x##y##_ARGB1555
#include "spantmp2.h"

/* a8r8g8b8 color span and pixel functions */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV
#define TAG(x) intel_##x##_ARGB8888
#define TAG2(x,y) intel_##x##y##_ARGB8888
#include "spantmp2.h"

/* x8r8g8b8 color span and pixel functions */
#define SPANTMP_PIXEL_FMT GL_BGR
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV
#define TAG(x) intel_##x##_xRGB8888
#define TAG2(x,y) intel_##x##y##_xRGB8888
#include "spantmp2.h"

/* a8 color span and pixel functions */
#define SPANTMP_PIXEL_FMT GL_ALPHA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_BYTE
#define TAG(x) intel_##x##_A8
#define TAG2(x,y) intel_##x##y##_A8
#include "spantmp2.h"

/* ------------------------------------------------------------------------- */
/* s8 stencil span and pixel functions                                       */
/* ------------------------------------------------------------------------- */

/*
 * HAVE_HW_STENCIL_SPANS determines if stencil buffer read/writes are done with
 * memcpy or for loops. Since the stencil buffer is interleaved, memcpy won't
 * work.
 */
#define HAVE_HW_STENCIL_SPANS 0

#define LOCAL_STENCIL_VARS						\
   (void) ctx;								\
   int minx = 0;							\
   int miny = 0;							\
   int maxx = rb->Width;						\
   int maxy = rb->Height;						\
									\
   /*									\
    * Here we ignore rb->Data and rb->RowStride as set by		\
    * intelSpanRenderStart. Since intel_offset_S8 decodes the W tile	\
    * manually, the region's *real* base address and stride is		\
    * required.								\
    */									\
   struct intel_renderbuffer *irb = intel_renderbuffer(rb);		\
   uint8_t *buf = irb->region->buffer->virtual;				\
   unsigned stride = irb->region->pitch;				\
   bool flip = rb->Name == 0;						\
   int y_scale = flip ? -1 : 1;						\
   int y_bias = flip ? (rb->Height - 1) : 0;				\

#undef Y_FLIP
#define Y_FLIP(y) (y_scale * (y) + y_bias)

/**
 * \brief Get pointer offset into stencil buffer.
 *
 * The stencil buffer is W tiled. Since the GTT is incapable of W fencing, we
 * must decode the tile's layout in software.
 *
 * See
 *   - PRM, 2011 Sandy Bridge, Volume 1, Part 2, Section 4.5.2.1 W-Major Tile
 *     Format.
 *   - PRM, 2011 Sandy Bridge, Volume 1, Part 2, Section 4.5.3 Tiling Algorithm
 *
 * Even though the returned offset is always positive, the return type is
 * signed due to
 *    commit e8b1c6d6f55f5be3bef25084fdd8b6127517e137
 *    mesa: Fix return type of  _mesa_get_format_bytes() (#37351)
 */
static inline intptr_t
intel_offset_S8(uint32_t stride, uint32_t x, uint32_t y)
{
   uint32_t tile_size = 4096;
   uint32_t tile_width = 64;
   uint32_t tile_height = 64;
   uint32_t row_size = 64 * stride;

   uint32_t tile_x = x / tile_width;
   uint32_t tile_y = y / tile_height;

   /* The byte's address relative to the tile's base addres. */
   uint32_t byte_x = x % tile_width;
   uint32_t byte_y = y % tile_height;

   uintptr_t u = tile_y * row_size
               + tile_x * tile_size
               + 512 * (byte_x / 8)
               +  64 * (byte_y / 8)
               +  32 * ((byte_y / 4) % 2)
               +  16 * ((byte_x / 4) % 2)
               +   8 * ((byte_y / 2) % 2)
               +   4 * ((byte_x / 2) % 2)
               +   2 * (byte_y % 2)
               +   1 * (byte_x % 2);

   /*
    * Errata for Gen5:
    *
    * An additional offset is needed which is not documented in the PRM.
    *
    * if ((byte_x / 8) % 2 == 1) {
    *    if ((byte_y / 8) % 2) == 0) {
    *       u += 64;
    *    } else {
    *       u -= 64;
    *    }
    * }
    *
    * The offset is expressed more tersely as
    * u += ((int) x & 0x8) * (8 - (((int) y & 0x8) << 1));
    */

   return u;
}

#define WRITE_STENCIL(x, y, src)  buf[intel_offset_S8(stride, x, y)] = src;
#define READ_STENCIL(dest, x, y) dest = buf[intel_offset_S8(stride, x, y)]
#define TAG(x) intel_##x##_S8
#include "stenciltmp.h"

/* ------------------------------------------------------------------------- */

void
intel_renderbuffer_map(struct intel_context *intel, struct gl_renderbuffer *rb)
{
   struct intel_renderbuffer *irb = intel_renderbuffer(rb);

   if (!irb)
      return;

   if (irb->wrapped_depth)
      intel_renderbuffer_map(intel, irb->wrapped_depth);
   if (irb->wrapped_stencil)
      intel_renderbuffer_map(intel, irb->wrapped_stencil);

   if (!irb->region)
      return;

   drm_intel_gem_bo_map_gtt(irb->region->buffer);

   rb->Data = irb->region->buffer->virtual;
   rb->RowStride = irb->region->pitch;

   if (!rb->Name) {
      /* Flip orientation of the window system buffer */
      rb->Data += rb->RowStride * (irb->region->height - 1) * irb->region->cpp;
      rb->RowStride = -rb->RowStride;
   } else {
      /* Adjust the base pointer of a texture image drawbuffer to the image
       * within the miptree region (all else has draw_x/y = 0).
       */
      rb->Data += irb->draw_x * irb->region->cpp;
      rb->Data += irb->draw_y * rb->RowStride * irb->region->cpp;
   }

   intel_set_span_functions(intel, rb);
}

void
intel_renderbuffer_unmap(struct intel_context *intel,
			 struct gl_renderbuffer *rb)
{
   struct intel_renderbuffer *irb = intel_renderbuffer(rb);

   if (!irb)
      return;

   if (irb->wrapped_depth)
      intel_renderbuffer_unmap(intel, irb->wrapped_depth);
   if (irb->wrapped_stencil)
      intel_renderbuffer_unmap(intel, irb->wrapped_stencil);

   if (!irb->region)
      return;

   drm_intel_gem_bo_unmap_gtt(irb->region->buffer);

   rb->GetRow = NULL;
   rb->PutRow = NULL;
   rb->Data = NULL;
   rb->RowStride = 0;
}

static void
intel_framebuffer_map(struct intel_context *intel, struct gl_framebuffer *fb)
{
   int i;

   for (i = 0; i < BUFFER_COUNT; i++) {
      intel_renderbuffer_map(intel, fb->Attachment[i].Renderbuffer);
   }

   intel_check_front_buffer_rendering(intel);
}

static void
intel_framebuffer_unmap(struct intel_context *intel, struct gl_framebuffer *fb)
{
   int i;

   for (i = 0; i < BUFFER_COUNT; i++) {
      intel_renderbuffer_unmap(intel, fb->Attachment[i].Renderbuffer);
   }
}

/**
 * Prepare for software rendering.  Map current read/draw framebuffers'
 * renderbuffes and all currently bound texture objects.
 *
 * Old note: Moved locking out to get reasonable span performance.
 */
void
intelSpanRenderStart(struct gl_context * ctx)
{
   struct intel_context *intel = intel_context(ctx);
   GLuint i;

   intel_flush(&intel->ctx);
   intel_prepare_render(intel);

   for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
      if (ctx->Texture.Unit[i]._ReallyEnabled) {
         struct gl_texture_object *texObj = ctx->Texture.Unit[i]._Current;

         intel_finalize_mipmap_tree(intel, i);
         intel_tex_map_images(intel, intel_texture_object(texObj));
      }
   }

   intel_framebuffer_map(intel, ctx->DrawBuffer);
   if (ctx->ReadBuffer != ctx->DrawBuffer) {
      intel_framebuffer_map(intel, ctx->ReadBuffer);
   }
}

/**
 * Called when done software rendering.  Unmap the buffers we mapped in
 * the above function.
 */
void
intelSpanRenderFinish(struct gl_context * ctx)
{
   struct intel_context *intel = intel_context(ctx);
   GLuint i;

   _swrast_flush(ctx);

   for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
      if (ctx->Texture.Unit[i]._ReallyEnabled) {
         struct gl_texture_object *texObj = ctx->Texture.Unit[i]._Current;
         intel_tex_unmap_images(intel, intel_texture_object(texObj));
      }
   }

   intel_framebuffer_unmap(intel, ctx->DrawBuffer);
   if (ctx->ReadBuffer != ctx->DrawBuffer) {
      intel_framebuffer_unmap(intel, ctx->ReadBuffer);
   }
}


void
intelInitSpanFuncs(struct gl_context * ctx)
{
   struct swrast_device_driver *swdd = _swrast_GetDeviceDriverReference(ctx);
   swdd->SpanRenderStart = intelSpanRenderStart;
   swdd->SpanRenderFinish = intelSpanRenderFinish;
}

void
intel_map_vertex_shader_textures(struct gl_context *ctx)
{
   struct intel_context *intel = intel_context(ctx);
   int i;

   if (ctx->VertexProgram._Current == NULL)
      return;

   for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
      if (ctx->Texture.Unit[i]._ReallyEnabled &&
	  ctx->VertexProgram._Current->Base.TexturesUsed[i] != 0) {
         struct gl_texture_object *texObj = ctx->Texture.Unit[i]._Current;

         intel_tex_map_images(intel, intel_texture_object(texObj));
      }
   }
}

void
intel_unmap_vertex_shader_textures(struct gl_context *ctx)
{
   struct intel_context *intel = intel_context(ctx);
   int i;

   if (ctx->VertexProgram._Current == NULL)
      return;

   for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
      if (ctx->Texture.Unit[i]._ReallyEnabled &&
	  ctx->VertexProgram._Current->Base.TexturesUsed[i] != 0) {
         struct gl_texture_object *texObj = ctx->Texture.Unit[i]._Current;

         intel_tex_unmap_images(intel, intel_texture_object(texObj));
      }
   }
}

typedef void (*span_init_func)(struct gl_renderbuffer *rb);

static span_init_func intel_span_init_funcs[MESA_FORMAT_COUNT] =
{
   [MESA_FORMAT_A8] = intel_InitPointers_A8,
   [MESA_FORMAT_RGB565] = intel_InitPointers_RGB565,
   [MESA_FORMAT_ARGB4444] = intel_InitPointers_ARGB4444,
   [MESA_FORMAT_ARGB1555] = intel_InitPointers_ARGB1555,
   [MESA_FORMAT_XRGB8888] = intel_InitPointers_xRGB8888,
   [MESA_FORMAT_ARGB8888] = intel_InitPointers_ARGB8888,
   [MESA_FORMAT_SARGB8] = intel_InitPointers_ARGB8888,
   [MESA_FORMAT_Z16] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_X8_Z24] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_S8_Z24] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_S8] = intel_InitStencilPointers_S8,
   [MESA_FORMAT_R8] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_RG88] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_R16] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_RG1616] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_RGBA_FLOAT32] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_RG_FLOAT32] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_R_FLOAT32] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_INTENSITY_FLOAT32] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_LUMINANCE_FLOAT32] = _mesa_set_renderbuffer_accessors,
};

bool
intel_span_supports_format(gl_format format)
{
   return intel_span_init_funcs[format] != NULL;
}

/**
 * Plug in appropriate span read/write functions for the given renderbuffer.
 * These are used for the software fallbacks.
 */
static void
intel_set_span_functions(struct intel_context *intel,
			 struct gl_renderbuffer *rb)
{
   struct intel_renderbuffer *irb = (struct intel_renderbuffer *) rb;

   assert(intel_span_init_funcs[irb->Base.Format]);
   intel_span_init_funcs[irb->Base.Format](rb);
}
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.5
log
@Merge Mesa 7.10.3
@
text
@d4 1
d27 3
d33 1
a57 2
   const GLint yScale = rb->Name ? 1 : -1;				\
   const GLint yBias = rb->Name ? 0 : rb->Height - 1;			\
d61 2
a62 2
   int pitch = irb->region->pitch * irb->region->cpp;			\
   void *buf = irb->region->buffer->virtual;				\
d64 1
a64 2
   (void) p;								\
   (void)buf; (void)pitch; /* unused for non-gttmap. */			\
d69 1
a69 1
#define Y_FLIP(_y) ((_y) * yScale + yBias)
a74 3
/* Convenience macros to avoid typing the address argument over and over */
#define NO_TILE(_X, _Y) (((_Y) * irb->region->pitch + (_X)) * irb->region->cpp)

d117 103
d225 9
a233 1
   if (irb == NULL || irb->region == NULL)
a240 1
   /* Flip orientation if it's the window system buffer */
d242 1
d245 6
d262 9
a270 1
   if (irb == NULL || irb->region == NULL)
a280 12
/**
 * Map or unmap all the renderbuffers which we may need during
 * software rendering.
 * XXX in the future, we could probably convey extra information to
 * reduce the number of mappings needed.  I.e. if doing a glReadPixels
 * from the depth buffer, we really only need one mapping.
 *
 * XXX Rewrite this function someday.
 * We can probably just loop over all the renderbuffer attachments,
 * map/unmap all of them, and not worry about the _ColorDrawBuffers
 * _ColorReadBuffer, _DepthBuffer or _StencilBuffer fields.
 */
d282 1
a282 3
intel_map_unmap_framebuffer(struct intel_context *intel,
			    struct gl_framebuffer *fb,
			    GLboolean map)
d284 1
a284 1
   GLuint i;
d286 2
a287 6
   /* color draw buffers */
   for (i = 0; i < fb->_NumColorDrawBuffers; i++) {
      if (map)
         intel_renderbuffer_map(intel, fb->_ColorDrawBuffers[i]);
      else
         intel_renderbuffer_unmap(intel, fb->_ColorDrawBuffers[i]);
d290 7
a296 5
   /* color read buffer */
   if (map)
      intel_renderbuffer_map(intel, fb->_ColorReadBuffer);
   else
      intel_renderbuffer_unmap(intel, fb->_ColorReadBuffer);
a297 1
   /* check for render to textures */
d299 1
a299 11
      struct gl_renderbuffer_attachment *att =
         fb->Attachment + i;
      struct gl_texture_object *tex = att->Texture;
      if (tex) {
         /* render to texture */
         ASSERT(att->Renderbuffer);
         if (map)
            intel_tex_map_images(intel, intel_texture_object(tex));
         else
            intel_tex_unmap_images(intel, intel_texture_object(tex));
      }
a300 18

   /* depth buffer (Note wrapper!) */
   if (fb->_DepthBuffer) {
      if (map)
         intel_renderbuffer_map(intel, fb->_DepthBuffer->Wrapped);
      else
         intel_renderbuffer_unmap(intel, fb->_DepthBuffer->Wrapped);
   }

   /* stencil buffer (Note wrapper!) */
   if (fb->_StencilBuffer) {
      if (map)
         intel_renderbuffer_map(intel, fb->_StencilBuffer->Wrapped);
      else
         intel_renderbuffer_unmap(intel, fb->_StencilBuffer->Wrapped);
   }

   intel_check_front_buffer_rendering(intel);
d327 4
a330 3
   intel_map_unmap_framebuffer(intel, ctx->DrawBuffer, GL_TRUE);
   if (ctx->ReadBuffer != ctx->DrawBuffer)
      intel_map_unmap_framebuffer(intel, ctx->ReadBuffer, GL_TRUE);
d352 4
a355 3
   intel_map_unmap_framebuffer(intel, ctx->DrawBuffer, GL_FALSE);
   if (ctx->ReadBuffer != ctx->DrawBuffer)
      intel_map_unmap_framebuffer(intel, ctx->ReadBuffer, GL_FALSE);
d419 1
d424 5
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d28 1
d33 1
d111 6
a116 30
#define LOCAL_DEPTH_VARS						\
   struct intel_renderbuffer *irb = intel_renderbuffer(rb);		\
   const GLint yScale = rb->Name ? 1 : -1;				\
   const GLint yBias = rb->Name ? 0 : rb->Height - 1;			\
   int minx = 0, miny = 0;						\
   int maxx = rb->Width;						\
   int maxy = rb->Height;						\
   int pitch = irb->region->pitch * irb->region->cpp;			\
   void *buf = irb->region->buffer->virtual;				\
   (void)buf; (void)pitch; /* unused for non-gttmap. */			\

#define LOCAL_STENCIL_VARS LOCAL_DEPTH_VARS

/* z16 depthbuffer functions. */
#define VALUE_TYPE GLushort
#define WRITE_DEPTH(_x, _y, d) \
   (*(uint16_t *)(irb->region->buffer->virtual + NO_TILE(_x, _y)) = d)
#define READ_DEPTH(d, _x, _y) \
   d = *(uint16_t *)(irb->region->buffer->virtual + NO_TILE(_x, _y))
#define TAG(x) intel_##x##_z16
#include "depthtmp.h"

/* z24_s8 and z24_x8 depthbuffer functions. */
#define VALUE_TYPE GLuint
#define WRITE_DEPTH(_x, _y, d) \
   (*(uint32_t *)(irb->region->buffer->virtual + NO_TILE(_x, _y)) = d)
#define READ_DEPTH(d, _x, _y) \
   d = *(uint32_t *)(irb->region->buffer->virtual + NO_TILE(_x, _y))
#define TAG(x) intel_##x##_z24_x8
#include "depthtmp.h"
d128 9
d153 2
d231 1
a231 1
intelSpanRenderStart(GLcontext * ctx)
d236 1
a236 1
   intelFlush(&intel->ctx);
d242 2
d258 1
a258 1
intelSpanRenderFinish(GLcontext * ctx)
d279 1
a279 1
intelInitSpanFuncs(GLcontext * ctx)
d287 1
a287 1
intel_map_vertex_shader_textures(GLcontext *ctx)
d306 1
a306 1
intel_unmap_vertex_shader_textures(GLcontext *ctx)
d324 26
d360 2
a361 29
   switch (irb->Base.Format) {
   case MESA_FORMAT_RGB565:
      intel_InitPointers_RGB565(rb);
      break;
   case MESA_FORMAT_ARGB4444:
      intel_InitPointers_ARGB4444(rb);
      break;
   case MESA_FORMAT_ARGB1555:
      intel_InitPointers_ARGB1555(rb);
      break;
   case MESA_FORMAT_XRGB8888:
      intel_InitPointers_xRGB8888(rb);
      break;
   case MESA_FORMAT_ARGB8888:
      intel_InitPointers_ARGB8888(rb);
      break;
   case MESA_FORMAT_Z16:
      intel_InitDepthPointers_z16(rb);
      break;
   case MESA_FORMAT_X8_Z24:
   case MESA_FORMAT_S8_Z24:
      intel_InitDepthPointers_z24_x8(rb);
      break;
   default:
      _mesa_problem(NULL,
		    "Unexpected MesaFormat %d in intelSetSpanFunctions",
		    irb->Base.Format);
      break;
   }
@


1.3
log
@backport some code from mesa current (and 7.5) so that the dri2 protocol
is correctly handled. without fixes to mesa and the ddx, the so-called
backwards compat goop that was added just plain does not work and ends
up with rendering bullshit.
@
text
@a45 206
#define SPAN_CACHE_SIZE		4096

static void
get_span_cache(struct intel_renderbuffer *irb, uint32_t offset)
{
   if (irb->span_cache == NULL) {
      irb->span_cache = _mesa_malloc(SPAN_CACHE_SIZE);
      irb->span_cache_offset = -1;
   }

   if ((offset & ~(SPAN_CACHE_SIZE - 1)) != irb->span_cache_offset) {
      irb->span_cache_offset = offset & ~(SPAN_CACHE_SIZE - 1);
      dri_bo_get_subdata(irb->region->buffer, irb->span_cache_offset,
			 SPAN_CACHE_SIZE, irb->span_cache);
   }
}

static void
clear_span_cache(struct intel_renderbuffer *irb)
{
   irb->span_cache_offset = -1;
}

static uint32_t
pread_32(struct intel_renderbuffer *irb, uint32_t offset)
{
   get_span_cache(irb, offset);

   return *(uint32_t *)(irb->span_cache + (offset & (SPAN_CACHE_SIZE - 1)));
}

static uint32_t
pread_xrgb8888(struct intel_renderbuffer *irb, uint32_t offset)
{
   get_span_cache(irb, offset);

   return *(uint32_t *)(irb->span_cache + (offset & (SPAN_CACHE_SIZE - 1))) |
      0xff000000;
}

static uint16_t
pread_16(struct intel_renderbuffer *irb, uint32_t offset)
{
   get_span_cache(irb, offset);

   return *(uint16_t *)(irb->span_cache + (offset & (SPAN_CACHE_SIZE - 1)));
}

static uint8_t
pread_8(struct intel_renderbuffer *irb, uint32_t offset)
{
   get_span_cache(irb, offset);

   return *(uint8_t *)(irb->span_cache + (offset & (SPAN_CACHE_SIZE - 1)));
}

static void
pwrite_32(struct intel_renderbuffer *irb, uint32_t offset, uint32_t val)
{
   clear_span_cache(irb);

   dri_bo_subdata(irb->region->buffer, offset, 4, &val);
}

static void
pwrite_xrgb8888(struct intel_renderbuffer *irb, uint32_t offset, uint32_t val)
{
   clear_span_cache(irb);

   dri_bo_subdata(irb->region->buffer, offset, 3, &val);
}

static void
pwrite_16(struct intel_renderbuffer *irb, uint32_t offset, uint16_t val)
{
   clear_span_cache(irb);

   dri_bo_subdata(irb->region->buffer, offset, 2, &val);
}

static void
pwrite_8(struct intel_renderbuffer *irb, uint32_t offset, uint8_t val)
{
   clear_span_cache(irb);

   dri_bo_subdata(irb->region->buffer, offset, 1, &val);
}

static uint32_t no_tile_swizzle(struct intel_renderbuffer *irb,
				int x, int y)
{
	return (y * irb->region->pitch + x) * irb->region->cpp;
}

/*
 * Deal with tiled surfaces
 */

static uint32_t x_tile_swizzle(struct intel_renderbuffer *irb,
			       int x, int y)
{
	int	tile_stride;
	int	xbyte;
	int	x_tile_off, y_tile_off;
	int	x_tile_number, y_tile_number;
	int	tile_off, tile_base;
	
	tile_stride = (irb->pfPitch * irb->region->cpp) << 3;

	xbyte = x * irb->region->cpp;

	x_tile_off = xbyte & 0x1ff;
	y_tile_off = y & 7;

	x_tile_number = xbyte >> 9;
	y_tile_number = y >> 3;

	tile_off = (y_tile_off << 9) + x_tile_off;

	switch (irb->region->bit_6_swizzle) {
	case I915_BIT_6_SWIZZLE_NONE:
	   break;
	case I915_BIT_6_SWIZZLE_9:
	   tile_off ^= ((tile_off >> 3) & 64);
	   break;
	case I915_BIT_6_SWIZZLE_9_10:
	   tile_off ^= ((tile_off >> 3) & 64) ^ ((tile_off >> 4) & 64);
	   break;
	case I915_BIT_6_SWIZZLE_9_11:
	   tile_off ^= ((tile_off >> 3) & 64) ^ ((tile_off >> 5) & 64);
	   break;
	case I915_BIT_6_SWIZZLE_9_10_11:
	   tile_off ^= ((tile_off >> 3) & 64) ^ ((tile_off >> 4) & 64) ^
	      ((tile_off >> 5) & 64);
	   break;
	default:
	   fprintf(stderr, "Unknown tile swizzling mode %d\n",
		   irb->region->bit_6_swizzle);
	   exit(1);
	}

	tile_base = (x_tile_number << 12) + y_tile_number * tile_stride;

#if 0
	printf("(%d,%d) -> %d + %d = %d (pitch = %d, tstride = %d)\n",
	       x, y, tile_off, tile_base,
	       tile_off + tile_base,
	       irb->pfPitch, tile_stride);
#endif

	return tile_base + tile_off;
}

static uint32_t y_tile_swizzle(struct intel_renderbuffer *irb,
			       int x, int y)
{
	int	tile_stride;
	int	xbyte;
	int	x_tile_off, y_tile_off;
	int	x_tile_number, y_tile_number;
	int	tile_off, tile_base;
	
	tile_stride = (irb->pfPitch * irb->region->cpp) << 5;

	xbyte = x * irb->region->cpp;

	x_tile_off = xbyte & 0x7f;
	y_tile_off = y & 0x1f;

	x_tile_number = xbyte >> 7;
	y_tile_number = y >> 5;

	tile_off = ((x_tile_off & ~0xf) << 5) + (y_tile_off << 4) +
	   (x_tile_off & 0xf);

	switch (irb->region->bit_6_swizzle) {
	case I915_BIT_6_SWIZZLE_NONE:
	   break;
	case I915_BIT_6_SWIZZLE_9:
	   tile_off ^= ((tile_off >> 3) & 64);
	   break;
	case I915_BIT_6_SWIZZLE_9_10:
	   tile_off ^= ((tile_off >> 3) & 64) ^ ((tile_off >> 4) & 64);
	   break;
	case I915_BIT_6_SWIZZLE_9_11:
	   tile_off ^= ((tile_off >> 3) & 64) ^ ((tile_off >> 5) & 64);
	   break;
	case I915_BIT_6_SWIZZLE_9_10_11:
	   tile_off ^= ((tile_off >> 3) & 64) ^ ((tile_off >> 4) & 64) ^
	      ((tile_off >> 5) & 64);
	   break;
	default:
	   fprintf(stderr, "Unknown tile swizzling mode %d\n",
		   irb->region->bit_6_swizzle);
	   exit(1);
	}

	tile_base = (x_tile_number << 12) + y_tile_number * tile_stride;

	return tile_base + tile_off;
}

/*
  break intelWriteRGBASpan_ARGB8888
*/

a49 1
   struct intel_context *intel = intel_context(ctx);			\
d51 7
a57 5
   const GLint yScale = irb->RenderToTexture ? 1 : -1;			\
   const GLint yBias = irb->RenderToTexture ? 0 : irb->Base.Height - 1;	\
   unsigned int num_cliprects;						\
   struct drm_clip_rect *cliprects;					\
   int x_off, y_off;							\
d60 1
a60 1
   intel_get_cliprects(intel, &cliprects, &num_cliprects, &x_off, &y_off);
d62 2
a63 16
/* XXX FBO: this is identical to the macro in spantmp2.h except we get
 * the cliprect info from the context, not the driDrawable.
 * Move this into spantmp2.h someday.
 */
#define HW_CLIPLOOP()							\
   do {									\
      int _nc = num_cliprects;						\
      while ( _nc-- ) {							\
	 int minx = cliprects[_nc].x1 - x_off;				\
	 int miny = cliprects[_nc].y1 - y_off;				\
	 int maxx = cliprects[_nc].x2 - x_off;				\
	 int maxy = cliprects[_nc].y2 - y_off;
	
#if 0
      }}
#endif
a66 1
/* XXX with GEM, these need to tell the kernel */
d71 2
a72 49
/* Convenience macros to avoid typing the swizzle argument over and over */
#define NO_TILE(_X, _Y) no_tile_swizzle(irb, (_X) + x_off, (_Y) + y_off)
#define X_TILE(_X, _Y) x_tile_swizzle(irb, (_X) + x_off, (_Y) + y_off)
#define Y_TILE(_X, _Y) y_tile_swizzle(irb, (_X) + x_off, (_Y) + y_off)

/* 16 bit, RGB565 color spanline and pixel functions
 */
#define SPANTMP_PIXEL_FMT GL_RGB
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_5_6_5

#define TAG(x)    intel##x##_RGB565
#define TAG2(x,y) intel##x##_RGB565##y
#define GET_VALUE(X, Y) pread_16(irb, NO_TILE(X, Y))
#define PUT_VALUE(X, Y, V) pwrite_16(irb, NO_TILE(X, Y), V)
#include "spantmp2.h"

/* 32 bit, ARGB8888 color spanline and pixel functions
 */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV

#define TAG(x)    intel##x##_ARGB8888
#define TAG2(x,y) intel##x##_ARGB8888##y
#define GET_VALUE(X, Y) pread_32(irb, NO_TILE(X, Y))
#define PUT_VALUE(X, Y, V) pwrite_32(irb, NO_TILE(X, Y), V)
#include "spantmp2.h"

/* 32 bit, xRGB8888 color spanline and pixel functions
 */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV

#define TAG(x)    intel##x##_xRGB8888
#define TAG2(x,y) intel##x##_xRGB8888##y
#define GET_VALUE(X, Y) pread_xrgb8888(irb, NO_TILE(X, Y))
#define PUT_VALUE(X, Y, V) pwrite_xrgb8888(irb, NO_TILE(X, Y), V)
#include "spantmp2.h"

/* 16 bit RGB565 color tile spanline and pixel functions
 */

#define SPANTMP_PIXEL_FMT GL_RGB
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_5_6_5

#define TAG(x)    intel_XTile_##x##_RGB565
#define TAG2(x,y) intel_XTile_##x##_RGB565##y
#define GET_VALUE(X, Y) pread_16(irb, X_TILE(X, Y))
#define PUT_VALUE(X, Y, V) pwrite_16(irb, X_TILE(X, Y), V)
#include "spantmp2.h"
d74 1
d77 2
a78 5

#define TAG(x)    intel_YTile_##x##_RGB565
#define TAG2(x,y) intel_YTile_##x##_RGB565##y
#define GET_VALUE(X, Y) pread_16(irb, Y_TILE(X, Y))
#define PUT_VALUE(X, Y, V) pwrite_16(irb, Y_TILE(X, Y), V)
d81 1
a81 3
/* 32 bit ARGB888 color tile spanline and pixel functions
 */

d83 3
a85 6
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV

#define TAG(x)    intel_XTile_##x##_ARGB8888
#define TAG2(x,y) intel_XTile_##x##_ARGB8888##y
#define GET_VALUE(X, Y) pread_32(irb, X_TILE(X, Y))
#define PUT_VALUE(X, Y, V) pwrite_32(irb, X_TILE(X, Y), V)
d88 1
d90 3
a92 6
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV

#define TAG(x)    intel_YTile_##x##_ARGB8888
#define TAG2(x,y) intel_YTile_##x##_ARGB8888##y
#define GET_VALUE(X, Y) pread_32(irb, Y_TILE(X, Y))
#define PUT_VALUE(X, Y, V) pwrite_32(irb, Y_TILE(X, Y), V)
d95 1
a95 3
/* 32 bit xRGB888 color tile spanline and pixel functions
 */

d98 2
a99 5

#define TAG(x)    intel_XTile_##x##_xRGB8888
#define TAG2(x,y) intel_XTile_##x##_xRGB8888##y
#define GET_VALUE(X, Y) pread_xrgb8888(irb, X_TILE(X, Y))
#define PUT_VALUE(X, Y, V) pwrite_xrgb8888(irb, X_TILE(X, Y), V)
d102 2
a103 1
#define SPANTMP_PIXEL_FMT GL_BGRA
d105 2
a106 5

#define TAG(x)    intel_YTile_##x##_xRGB8888
#define TAG2(x,y) intel_YTile_##x##_xRGB8888##y
#define GET_VALUE(X, Y) pread_xrgb8888(irb, Y_TILE(X, Y))
#define PUT_VALUE(X, Y, V) pwrite_xrgb8888(irb, Y_TILE(X, Y), V)
a109 1
   struct intel_context *intel = intel_context(ctx);			\
d111 8
a118 7
   const GLint yScale = irb->RenderToTexture ? 1 : -1;			\
   const GLint yBias = irb->RenderToTexture ? 0 : irb->Base.Height - 1; \
   unsigned int num_cliprects;						\
   struct drm_clip_rect *cliprects;					\
   int x_off, y_off;							\
   intel_get_cliprects(intel, &cliprects, &num_cliprects, &x_off, &y_off);

d122 1
a122 22
/**
 ** 16-bit depthbuffer functions.
 **/
#define VALUE_TYPE GLushort
#define WRITE_DEPTH(_x, _y, d) pwrite_16(irb, NO_TILE(_x, _y), d)
#define READ_DEPTH(d, _x, _y) d = pread_16(irb, NO_TILE(_x, _y))
#define TAG(x) intel##x##_z16
#include "depthtmp.h"


/**
 ** 16-bit x tile depthbuffer functions.
 **/
#define VALUE_TYPE GLushort
#define WRITE_DEPTH(_x, _y, d) pwrite_16(irb, X_TILE(_x, _y), d)
#define READ_DEPTH(d, _x, _y) d = pread_16(irb, X_TILE(_x, _y))
#define TAG(x) intel_XTile_##x##_z16
#include "depthtmp.h"

/**
 ** 16-bit y tile depthbuffer functions.
 **/
d124 5
a128 25
#define WRITE_DEPTH(_x, _y, d) pwrite_16(irb, Y_TILE(_x, _y), d)
#define READ_DEPTH(d, _x, _y) d = pread_16(irb, Y_TILE(_x, _y))
#define TAG(x) intel_YTile_##x##_z16
#include "depthtmp.h"


/**
 ** 24/8-bit interleaved depth/stencil functions
 ** Note: we're actually reading back combined depth+stencil values.
 ** The wrappers in main/depthstencil.c are used to extract the depth
 ** and stencil values.
 **/
#define VALUE_TYPE GLuint

/* Change ZZZS -> SZZZ */
#define WRITE_DEPTH(_x, _y, d)					\
   pwrite_32(irb, NO_TILE(_x, _y), ((d) >> 8) | ((d) << 24))

/* Change SZZZ -> ZZZS */
#define READ_DEPTH( d, _x, _y ) {				\
   GLuint tmp = pread_32(irb, NO_TILE(_x, _y));			\
   d = (tmp << 8) | (tmp >> 24);				\
}

#define TAG(x) intel##x##_z24_s8
d131 1
a131 28

/**
 ** 24/8-bit x-tile interleaved depth/stencil functions
 ** Note: we're actually reading back combined depth+stencil values.
 ** The wrappers in main/depthstencil.c are used to extract the depth
 ** and stencil values.
 **/
#define VALUE_TYPE GLuint

/* Change ZZZS -> SZZZ */
#define WRITE_DEPTH(_x, _y, d)					\
   pwrite_32(irb, X_TILE(_x, _y), ((d) >> 8) | ((d) << 24))

/* Change SZZZ -> ZZZS */
#define READ_DEPTH( d, _x, _y ) {				\
   GLuint tmp = pread_32(irb, X_TILE(_x, _y));		\
   d = (tmp << 8) | (tmp >> 24);				\
}

#define TAG(x) intel_XTile_##x##_z24_s8
#include "depthtmp.h"

/**
 ** 24/8-bit y-tile interleaved depth/stencil functions
 ** Note: we're actually reading back combined depth+stencil values.
 ** The wrappers in main/depthstencil.c are used to extract the depth
 ** and stencil values.
 **/
d133 5
a137 12

/* Change ZZZS -> SZZZ */
#define WRITE_DEPTH(_x, _y, d)					\
   pwrite_32(irb, Y_TILE(_x, _y), ((d) >> 8) | ((d) << 24))

/* Change SZZZ -> ZZZS */
#define READ_DEPTH( d, _x, _y ) {				\
   GLuint tmp = pread_32(irb, Y_TILE(_x, _y));			\
   d = (tmp << 8) | (tmp >> 24);				\
}

#define TAG(x) intel_YTile_##x##_z24_s8
a139 25

/**
 ** 8-bit stencil function (XXX FBO: This is obsolete)
 **/
#define WRITE_STENCIL(_x, _y, d) pwrite_8(irb, NO_TILE(_x, _y) + 3, d)
#define READ_STENCIL(d, _x, _y) d = pread_8(irb, NO_TILE(_x, _y) + 3);
#define TAG(x) intel##x##_z24_s8
#include "stenciltmp.h"

/**
 ** 8-bit x-tile stencil function (XXX FBO: This is obsolete)
 **/
#define WRITE_STENCIL(_x, _y, d) pwrite_8(irb, X_TILE(_x, _y) + 3, d)
#define READ_STENCIL(d, _x, _y) d = pread_8(irb, X_TILE(_x, _y) + 3);
#define TAG(x) intel_XTile_##x##_z24_s8
#include "stenciltmp.h"

/**
 ** 8-bit y-tile stencil function (XXX FBO: This is obsolete)
 **/
#define WRITE_STENCIL(_x, _y, d) pwrite_8(irb, Y_TILE(_x, _y) + 3, d)
#define READ_STENCIL(d, _x, _y) d = pread_8(irb, Y_TILE(_x, _y) + 3)
#define TAG(x) intel_YTile_##x##_z24_s8
#include "stenciltmp.h"

d148 1
a148 1
   irb->pfPitch = irb->region->pitch;
d162 1
a162 2
   clear_span_cache(irb);
   irb->pfPitch = 0;
d181 3
a183 1
intel_map_unmap_buffers(struct intel_context *intel, GLboolean map)
d185 1
a185 2
   GLcontext *ctx = &intel->ctx;
   GLuint i, j;
d188 1
a188 1
   for (j = 0; j < ctx->DrawBuffer->_NumColorDrawBuffers; j++) {
d190 1
a190 1
	 intel_renderbuffer_map(intel, ctx->DrawBuffer->_ColorDrawBuffers[j]);
d192 1
a192 1
	 intel_renderbuffer_unmap(intel, ctx->DrawBuffer->_ColorDrawBuffers[j]);
d195 6
d204 1
a204 1
         ctx->DrawBuffer->Attachment + i;
a215 6
   /* color read buffers */
   if (map)
      intel_renderbuffer_map(intel, ctx->ReadBuffer->_ColorReadBuffer);
   else
      intel_renderbuffer_unmap(intel, ctx->ReadBuffer->_ColorReadBuffer);

d217 1
a217 1
   if (ctx->DrawBuffer->_DepthBuffer) {
d219 1
a219 1
	 intel_renderbuffer_map(intel, ctx->DrawBuffer->_DepthBuffer->Wrapped);
d221 1
a221 2
	 intel_renderbuffer_unmap(intel,
				  ctx->DrawBuffer->_DepthBuffer->Wrapped);
d225 1
a225 1
   if (ctx->DrawBuffer->_StencilBuffer) {
d227 1
a227 2
	 intel_renderbuffer_map(intel,
				ctx->DrawBuffer->_StencilBuffer->Wrapped);
d229 1
a229 2
	 intel_renderbuffer_unmap(intel,
				  ctx->DrawBuffer->_StencilBuffer->Wrapped);
d231 2
a234 2


d236 1
a236 1
 * Prepare for softare rendering.  Map current read/draw framebuffers'
d248 1
a248 1
   LOCK_HARDWARE(intel);
d257 3
a259 1
   intel_map_unmap_buffers(intel, GL_TRUE);
d263 1
a263 1
 * Called when done softare rendering.  Unmap the buffers we mapped in
d281 3
a283 3
   intel_map_unmap_buffers(intel, GL_FALSE);

   UNLOCK_HARDWARE(intel);
d295 37
a341 12
   uint32_t tiling;

#ifndef __OpenBSD__ /* openbsd uses fenced gtt writes for tiles p{read,write} */
   /* If in GEM mode, we need to do the tile address swizzling ourselves,
    * instead of the fence registers handling it.
    */

   if (intel->ttm)
      tiling = irb->region->tiling;
   else
#endif
      tiling = I915_TILING_NONE;
d343 24
a366 89
   if (rb->_ActualFormat == GL_RGB5) {
      /* 565 RGB */
      switch (tiling) {
      case I915_TILING_NONE:
      default:
	 intelInitPointers_RGB565(rb);
	 break;
      case I915_TILING_X:
	 intel_XTile_InitPointers_RGB565(rb);
	 break;
      case I915_TILING_Y:
	 intel_YTile_InitPointers_RGB565(rb);
	 break;
      }
   }
   else if (rb->_ActualFormat == GL_RGB8) {
      /* 8888 RGBx */
      switch (tiling) {
      case I915_TILING_NONE:
      default:
	 intelInitPointers_xRGB8888(rb);
	 break;
      case I915_TILING_X:
	 intel_XTile_InitPointers_xRGB8888(rb);
	 break;
      case I915_TILING_Y:
	 intel_YTile_InitPointers_xRGB8888(rb);
	 break;
      }
   }
   else if (rb->_ActualFormat == GL_RGBA8) {
      /* 8888 RGBA */
      switch (tiling) {
      case I915_TILING_NONE:
      default:
	 intelInitPointers_ARGB8888(rb);
	 break;
      case I915_TILING_X:
	 intel_XTile_InitPointers_ARGB8888(rb);
	 break;
      case I915_TILING_Y:
	 intel_YTile_InitPointers_ARGB8888(rb);
	 break;
      }
   }
   else if (rb->_ActualFormat == GL_DEPTH_COMPONENT16) {
      switch (tiling) {
      case I915_TILING_NONE:
      default:
	 intelInitDepthPointers_z16(rb);
	 break;
      case I915_TILING_X:
	 intel_XTile_InitDepthPointers_z16(rb);
	 break;
      case I915_TILING_Y:
	 intel_YTile_InitDepthPointers_z16(rb);
	 break;
      }
   }
   else if (rb->_ActualFormat == GL_DEPTH_COMPONENT24 ||        /* XXX FBO remove */
            rb->_ActualFormat == GL_DEPTH24_STENCIL8_EXT) {
      switch (tiling) {
      case I915_TILING_NONE:
      default:
	 intelInitDepthPointers_z24_s8(rb);
	 break;
      case I915_TILING_X:
	 intel_XTile_InitDepthPointers_z24_s8(rb);
	 break;
      case I915_TILING_Y:
	 intel_YTile_InitDepthPointers_z24_s8(rb);
	 break;
      }
   }
   else if (rb->_ActualFormat == GL_STENCIL_INDEX8_EXT) {
      switch (tiling) {
      case I915_TILING_NONE:
      default:
	 intelInitStencilPointers_z24_s8(rb);
	 break;
      case I915_TILING_X:
	 intel_XTile_InitStencilPointers_z24_s8(rb);
	 break;
      case I915_TILING_Y:
	 intel_YTile_InitStencilPointers_z24_s8(rb);
	 break;
      }
   }
   else {
d368 3
a370 1
                    "Unexpected _ActualFormat in intelSetSpanFunctions");
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d691 1
d695 1
d699 1
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d28 4
a31 4
#include "glheader.h"
#include "macros.h"
#include "mtypes.h"
#include "colormac.h"
d33 1
a37 1
#include "intel_ioctl.h"
d42 206
d260 3
a262 2
   GLubyte *buf = (GLubyte *) irb->pfMap				\
      + (intel->drawY * irb->pfPitch + intel->drawX) * irb->region->cpp;\
d264 2
a265 2
   assert(irb->pfMap);\
   (void) p;
d273 1
a273 1
      int _nc = intel->numClipRects;					\
d275 8
a282 7
	 int minx = intel->pClipRects[_nc].x1 - intel->drawX;		\
	 int miny = intel->pClipRects[_nc].y1 - intel->drawY;		\
	 int maxx = intel->pClipRects[_nc].x2 - intel->drawX;		\
	 int maxy = intel->pClipRects[_nc].y2 - intel->drawY;



d286 1
d291 5
d303 2
a304 1
#define GET_PTR(X,Y) (buf + ((Y) * irb->pfPitch + (X)) * 2)
d314 76
a389 1
#define GET_PTR(X,Y) (buf + ((Y) * irb->pfPitch + (X)) * 4)
a394 1
   const GLuint pitch = irb->pfPitch/***XXX region->pitch*/; /* in pixels */ \
d396 5
a400 3
   const GLint yBias = irb->RenderToTexture ? 0 : irb->Base.Height - 1;	\
   char *buf = (char *) irb->pfMap/*XXX use region->map*/ +             \
      (intel->drawY * pitch + intel->drawX) * irb->region->cpp;
d409 4
a413 2
#define WRITE_DEPTH( _x, _y, d ) \
   ((GLushort *)buf)[(_x) + (_y) * pitch] = d;
d415 8
a422 2
#define READ_DEPTH( d, _x, _y )	\
   d = ((GLushort *)buf)[(_x) + (_y) * pitch];
d424 7
a430 2

#define TAG(x) intel##x##_z16
d443 2
a444 4
#define WRITE_DEPTH( _x, _y, d ) {				\
   GLuint tmp = ((d) >> 8) | ((d) << 24);			\
   ((GLuint *)buf)[(_x) + (_y) * pitch] = tmp;			\
}
d448 1
a448 1
   GLuint tmp = ((GLuint *)buf)[(_x) + (_y) * pitch];		\
d457 25
a481 1
 ** 8-bit stencil function (XXX FBO: This is obsolete)
d483 10
a492 5
#define WRITE_STENCIL( _x, _y, d ) {				\
   GLuint tmp = ((GLuint *)buf)[(_x) + (_y) * pitch];		\
   tmp &= 0xffffff;						\
   tmp |= ((d) << 24);						\
   ((GLuint *) buf)[(_x) + (_y) * pitch] = tmp;			\
d495 3
a497 2
#define READ_STENCIL( d, _x, _y )				\
   d = ((GLuint *)buf)[(_x) + (_y) * pitch] >> 24;
d499 5
d507 40
d548 3
a568 1
   struct intel_renderbuffer *irb;
d572 4
a575 13
      struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[j];
      irb = intel_renderbuffer(rb);
      if (irb) {
         /* this is a user-created intel_renderbuffer */
         if (irb->region) {
            if (map)
               intel_region_map(intel, irb->region);
            else
               intel_region_unmap(intel, irb->region);
            irb->pfMap = irb->region->map;
            irb->pfPitch = irb->region->pitch;
         }
      }
d586 1
a586 3
         if (map) {
            struct gl_texture_image *texImg;
            texImg = tex->Image[att->CubeMapFace][att->TextureLevel];
d588 1
a588 2
         }
         else {
a589 1
         }
d594 4
a597 38
   irb = intel_renderbuffer(ctx->ReadBuffer->_ColorReadBuffer);
   if (irb && irb->region) {
      if (map)
         intel_region_map(intel, irb->region);
      else
         intel_region_unmap(intel, irb->region);
      irb->pfMap = irb->region->map;
      irb->pfPitch = irb->region->pitch;
   }

   /* Account for front/back color page flipping.
    * The span routines use the pfMap and pfPitch fields which will
    * swap the front/back region map/pitch if we're page flipped.
    * Do this after mapping, above, so the map field is valid.
    */
#if 0
   if (map && ctx->DrawBuffer->Name == 0) {
      struct intel_renderbuffer *irbFront
         = intel_get_renderbuffer(ctx->DrawBuffer, BUFFER_FRONT_LEFT);
      struct intel_renderbuffer *irbBack
         = intel_get_renderbuffer(ctx->DrawBuffer, BUFFER_BACK_LEFT);
      if (irbBack) {
         /* double buffered */
         if (intel->sarea->pf_current_page == 0) {
            irbFront->pfMap = irbFront->region->map;
            irbFront->pfPitch = irbFront->region->pitch;
            irbBack->pfMap = irbBack->region->map;
            irbBack->pfPitch = irbBack->region->pitch;
         }
         else {
            irbFront->pfMap = irbBack->region->map;
            irbFront->pfPitch = irbBack->region->pitch;
            irbBack->pfMap = irbFront->region->map;
            irbBack->pfPitch = irbFront->region->pitch;
         }
      }
   }
#endif
d601 5
a605 13
      irb = intel_renderbuffer(ctx->DrawBuffer->_DepthBuffer->Wrapped);
      if (irb && irb->region) {
         if (map) {
            intel_region_map(intel, irb->region);
            irb->pfMap = irb->region->map;
            irb->pfPitch = irb->region->pitch;
         }
         else {
            intel_region_unmap(intel, irb->region);
            irb->pfMap = irb->region->map;
            irb->pfPitch = irb->region->pitch;
         }
      }
d610 6
a615 13
      irb = intel_renderbuffer(ctx->DrawBuffer->_StencilBuffer->Wrapped);
      if (irb && irb->region) {
         if (map) {
            intel_region_map(intel, irb->region);
            irb->pfMap = irb->region->map;
            irb->pfPitch = irb->region->pitch;
         }
         else {
            intel_region_unmap(intel, irb->region);
            irb->pfMap = irb->region->map;
            irb->pfPitch = irb->region->pitch;
         }
      }
d633 1
a633 1
   intelFinish(&intel->ctx);
d636 1
a636 10
#if 0
   /* Just map the framebuffer and all textures.  Bufmgr code will
    * take care of waiting on the necessary fences:
    */
   intel_region_map(intel, intel->front_region);
   intel_region_map(intel, intel->back_region);
   intel_region_map(intel, intel->depth_region);
#endif

   for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++) {
d658 1
a658 9
   /* Now unmap the framebuffer:
    */
#if 0
   intel_region_unmap(intel, intel->front_region);
   intel_region_unmap(intel, intel->back_region);
   intel_region_unmap(intel, intel->depth_region);
#endif

   for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++) {
d684 3
a686 2
void
intel_set_span_functions(struct gl_renderbuffer *rb)
d688 11
d701 27
a727 1
      intelInitPointers_RGB565(rb);
d731 12
a742 1
      intelInitPointers_ARGB8888(rb);
d745 12
a756 1
      intelInitDepthPointers_z16(rb);
d760 12
a771 1
      intelInitDepthPointers_z24_s8(rb);
d773 13
a785 2
   else if (rb->_ActualFormat == GL_STENCIL_INDEX8_EXT) {       /* XXX FBO remove */
      intelInitStencilPointers_z24_s8(rb);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d28 4
a31 6
#include <stdbool.h>
#include "main/glheader.h"
#include "main/macros.h"
#include "main/mtypes.h"
#include "main/colormac.h"
#include "main/renderbuffer.h"
a32 1
#include "intel_buffers.h"
d37 1
d42 3
a44 3
static void
intel_set_span_functions(struct intel_context *intel,
			 struct gl_renderbuffer *rb);
d50 1
d52 4
a55 7
   const GLint yScale = rb->Name ? 1 : -1;				\
   const GLint yBias = rb->Name ? 0 : rb->Height - 1;			\
   int minx = 0, miny = 0;						\
   int maxx = rb->Width;						\
   int maxy = rb->Height;						\
   int pitch = irb->region->pitch * irb->region->cpp;			\
   void *buf = irb->region->buffer->virtual;				\
d57 17
a73 2
   (void) p;								\
   (void)buf; (void)pitch; /* unused for non-gttmap. */			\
a74 2
#define HW_CLIPLOOP()
#define HW_ENDCLIPLOOP()
d82 2
a83 4
/* Convenience macros to avoid typing the address argument over and over */
#define NO_TILE(_X, _Y) (((_Y) * irb->region->pitch + (_X)) * irb->region->cpp)

/* r5g6b5 color span and pixel functions */
d86 4
a89 2
#define TAG(x) intel_##x##_RGB565
#define TAG2(x,y) intel_##x##y_RGB565
d92 2
a93 1
/* a4r4g4b4 color span and pixel functions */
d95 5
a99 3
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_4_4_4_4_REV
#define TAG(x) intel_##x##_ARGB4444
#define TAG2(x,y) intel_##x##y_ARGB4444
d102 8
a109 6
/* a1r5g5b5 color span and pixel functions */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_1_5_5_5_REV
#define TAG(x) intel_##x##_ARGB1555
#define TAG2(x,y) intel_##x##y##_ARGB1555
#include "spantmp2.h"
a110 6
/* a8r8g8b8 color span and pixel functions */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV
#define TAG(x) intel_##x##_ARGB8888
#define TAG2(x,y) intel_##x##y##_ARGB8888
#include "spantmp2.h"
d112 1
a112 6
/* x8r8g8b8 color span and pixel functions */
#define SPANTMP_PIXEL_FMT GL_BGR
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV
#define TAG(x) intel_##x##_xRGB8888
#define TAG2(x,y) intel_##x##y##_xRGB8888
#include "spantmp2.h"
d114 4
a117 6
/* a8 color span and pixel functions */
#define SPANTMP_PIXEL_FMT GL_ALPHA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_BYTE
#define TAG(x) intel_##x##_A8
#define TAG2(x,y) intel_##x##y##_A8
#include "spantmp2.h"
d119 2
a120 4
void
intel_renderbuffer_map(struct intel_context *intel, struct gl_renderbuffer *rb)
{
   struct intel_renderbuffer *irb = intel_renderbuffer(rb);
d122 2
a123 2
   if (irb == NULL || irb->region == NULL)
      return;
a124 1
   drm_intel_gem_bo_map_gtt(irb->region->buffer);
d126 2
a127 2
   rb->Data = irb->region->buffer->virtual;
   rb->RowStride = irb->region->pitch;
a128 5
   /* Flip orientation if it's the window system buffer */
   if (!rb->Name) {
      rb->Data += rb->RowStride * (irb->region->height - 1) * irb->region->cpp;
      rb->RowStride = -rb->RowStride;
   }
d130 12
a141 1
   intel_set_span_functions(intel, rb);
d144 5
a148 5
void
intel_renderbuffer_unmap(struct intel_context *intel,
			 struct gl_renderbuffer *rb)
{
   struct intel_renderbuffer *irb = intel_renderbuffer(rb);
d150 2
a151 2
   if (irb == NULL || irb->region == NULL)
      return;
a152 1
   drm_intel_gem_bo_unmap_gtt(irb->region->buffer);
d154 8
a161 4
   rb->GetRow = NULL;
   rb->PutRow = NULL;
   rb->Data = NULL;
   rb->RowStride = 0;
d164 8
d185 1
a185 3
intel_map_unmap_framebuffer(struct intel_context *intel,
			    struct gl_framebuffer *fb,
			    GLboolean map)
d187 3
a189 1
   GLuint i;
d192 14
a205 5
   for (i = 0; i < fb->_NumColorDrawBuffers; i++) {
      if (map)
         intel_renderbuffer_map(intel, fb->_ColorDrawBuffers[i]);
      else
         intel_renderbuffer_unmap(intel, fb->_ColorDrawBuffers[i]);
a207 6
   /* color read buffer */
   if (map)
      intel_renderbuffer_map(intel, fb->_ColorReadBuffer);
   else
      intel_renderbuffer_unmap(intel, fb->_ColorReadBuffer);

d211 1
a211 1
         fb->Attachment + i;
d216 3
a218 1
         if (map)
d220 2
a221 1
         else
d223 1
d227 3
a229 2
   /* depth buffer (Note wrapper!) */
   if (fb->_DepthBuffer) {
d231 1
a231 1
         intel_renderbuffer_map(intel, fb->_DepthBuffer->Wrapped);
d233 49
a281 1
         intel_renderbuffer_unmap(intel, fb->_DepthBuffer->Wrapped);
d285 14
a298 5
   if (fb->_StencilBuffer) {
      if (map)
         intel_renderbuffer_map(intel, fb->_StencilBuffer->Wrapped);
      else
         intel_renderbuffer_unmap(intel, fb->_StencilBuffer->Wrapped);
d300 2
a302 2
   intel_check_front_buffer_rendering(intel);
}
d305 1
a305 1
 * Prepare for software rendering.  Map current read/draw framebuffers'
d311 1
a311 1
intelSpanRenderStart(struct gl_context * ctx)
d316 11
a326 2
   intel_flush(&intel->ctx);
   intel_prepare_render(intel);
d328 1
a328 1
   for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
a330 2

         intel_finalize_mipmap_tree(intel, i);
d335 1
a335 3
   intel_map_unmap_framebuffer(intel, ctx->DrawBuffer, GL_TRUE);
   if (ctx->ReadBuffer != ctx->DrawBuffer)
      intel_map_unmap_framebuffer(intel, ctx->ReadBuffer, GL_TRUE);
d339 1
a339 1
 * Called when done software rendering.  Unmap the buffers we mapped in
d343 1
a343 1
intelSpanRenderFinish(struct gl_context * ctx)
d350 9
a358 1
   for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
d365 3
a367 3
   intel_map_unmap_framebuffer(intel, ctx->DrawBuffer, GL_FALSE);
   if (ctx->ReadBuffer != ctx->DrawBuffer)
      intel_map_unmap_framebuffer(intel, ctx->ReadBuffer, GL_FALSE);
d372 1
a372 1
intelInitSpanFuncs(struct gl_context * ctx)
a378 63
void
intel_map_vertex_shader_textures(struct gl_context *ctx)
{
   struct intel_context *intel = intel_context(ctx);
   int i;

   if (ctx->VertexProgram._Current == NULL)
      return;

   for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
      if (ctx->Texture.Unit[i]._ReallyEnabled &&
	  ctx->VertexProgram._Current->Base.TexturesUsed[i] != 0) {
         struct gl_texture_object *texObj = ctx->Texture.Unit[i]._Current;

         intel_tex_map_images(intel, intel_texture_object(texObj));
      }
   }
}

void
intel_unmap_vertex_shader_textures(struct gl_context *ctx)
{
   struct intel_context *intel = intel_context(ctx);
   int i;

   if (ctx->VertexProgram._Current == NULL)
      return;

   for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
      if (ctx->Texture.Unit[i]._ReallyEnabled &&
	  ctx->VertexProgram._Current->Base.TexturesUsed[i] != 0) {
         struct gl_texture_object *texObj = ctx->Texture.Unit[i]._Current;

         intel_tex_unmap_images(intel, intel_texture_object(texObj));
      }
   }
}

typedef void (*span_init_func)(struct gl_renderbuffer *rb);

static span_init_func intel_span_init_funcs[MESA_FORMAT_COUNT] =
{
   [MESA_FORMAT_A8] = intel_InitPointers_A8,
   [MESA_FORMAT_RGB565] = intel_InitPointers_RGB565,
   [MESA_FORMAT_ARGB4444] = intel_InitPointers_ARGB4444,
   [MESA_FORMAT_ARGB1555] = intel_InitPointers_ARGB1555,
   [MESA_FORMAT_XRGB8888] = intel_InitPointers_xRGB8888,
   [MESA_FORMAT_ARGB8888] = intel_InitPointers_ARGB8888,
   [MESA_FORMAT_SARGB8] = intel_InitPointers_ARGB8888,
   [MESA_FORMAT_Z16] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_X8_Z24] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_S8_Z24] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_R8] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_RG88] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_R16] = _mesa_set_renderbuffer_accessors,
   [MESA_FORMAT_RG1616] = _mesa_set_renderbuffer_accessors,
};

bool
intel_span_supports_format(gl_format format)
{
   return intel_span_init_funcs[format] != NULL;
}
d384 2
a385 3
static void
intel_set_span_functions(struct intel_context *intel,
			 struct gl_renderbuffer *rb)
d387 22
a408 4
   struct intel_renderbuffer *irb = (struct intel_renderbuffer *) rb;

   assert(intel_span_init_funcs[irb->Base.Format]);
   intel_span_init_funcs[irb->Base.Format](rb);
@


