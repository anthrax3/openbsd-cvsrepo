head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.22.09.30.34;	author jsg;	state Exp;
branches;
next	1.10;
commitid	yhStanAcs6cSYmBc;

1.10
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.04.06;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.17;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.12;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.12;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.03;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.35;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.15.17;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.46;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.11.19;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.48.26;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * (C) Copyright IBM Corporation 2002, 2004
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEM, IBM AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file utils.c
 * Utility functions for DRI drivers.
 *
 * \author Ian Romanick <idr@@us.ibm.com>
 */

#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include "main/macros.h"
#include "main/mtypes.h"
#include "main/cpuinfo.h"
#include "main/extensions.h"
#include "utils.h"
#include "dri_util.h"


uint64_t
driParseDebugString( const char * debug, 
		     const struct dri_debug_control * control  )
{
   uint64_t flag = 0;

   if ( debug != NULL ) {
      while( control->string != NULL ) {
	 if ( !strcmp( debug, "all" ) ||
	      strstr( debug, control->string ) != NULL ) {
	    flag |= control->flag;
	 }

	 control++;
      }
   }

   return flag;
}



/**
 * Create the \c GL_RENDERER string for DRI drivers.
 * 
 * Almost all DRI drivers use a \c GL_RENDERER string of the form:
 *
 *    "Mesa DRI <chip> <driver date> <AGP speed) <CPU information>"
 *
 * Using the supplied chip name, driver data, and AGP speed, this function
 * creates the string.
 * 
 * \param buffer         Buffer to hold the \c GL_RENDERER string.
 * \param hardware_name  Name of the hardware.
 * \param agp_mode       AGP mode (speed).
 * 
 * \returns
 * The length of the string stored in \c buffer.  This does \b not include
 * the terminating \c NUL character.
 */
unsigned
driGetRendererString( char * buffer, const char * hardware_name,
		      GLuint agp_mode )
{
   unsigned offset;
   char *cpu;

   offset = sprintf( buffer, "Mesa DRI %s", hardware_name );

   /* Append any AGP-specific information.
    */
   switch ( agp_mode ) {
   case 1:
   case 2:
   case 4:
   case 8:
      offset += sprintf( & buffer[ offset ], " AGP %ux", agp_mode );
      break;
	
   default:
      break;
   }

   /* Append any CPU-specific information.
    */
   cpu = _mesa_get_cpu_string();
   if (cpu) {
      offset += sprintf(buffer + offset, " %s", cpu);
      free(cpu);
   }

   return offset;
}


/**
 * Creates a set of \c struct gl_config that a driver will expose.
 * 
 * A set of \c struct gl_config will be created based on the supplied
 * parameters.  The number of modes processed will be 2 *
 * \c num_depth_stencil_bits * \c num_db_modes.
 * 
 * For the most part, data is just copied from \c depth_bits, \c stencil_bits,
 * \c db_modes, and \c visType into each \c struct gl_config element.
 * However, the meanings of \c fb_format and \c fb_type require further
 * explanation.  The \c fb_format specifies which color components are in
 * each pixel and what the default order is.  For example, \c GL_RGB specifies
 * that red, green, blue are available and red is in the "most significant"
 * position and blue is in the "least significant".  The \c fb_type specifies
 * the bit sizes of each component and the actual ordering.  For example, if
 * \c GL_UNSIGNED_SHORT_5_6_5_REV is specified with \c GL_RGB, bits [15:11]
 * are the blue value, bits [10:5] are the green value, and bits [4:0] are
 * the red value.
 * 
 * One sublte issue is the combination of \c GL_RGB  or \c GL_BGR and either
 * of the \c GL_UNSIGNED_INT_8_8_8_8 modes.  The resulting mask values in the
 * \c struct gl_config structure is \b identical to the \c GL_RGBA or
 * \c GL_BGRA case, except the \c alphaMask is zero.  This means that, as
 * far as this routine is concerned, \c GL_RGB with \c GL_UNSIGNED_INT_8_8_8_8
 * still uses 32-bits.
 *
 * If in doubt, look at the tables used in the function.
 * 
 * \param ptr_to_modes  Pointer to a pointer to a linked list of
 *                      \c struct gl_config.  Upon completion, a pointer to
 *                      the next element to be process will be stored here.
 *                      If the function fails and returns \c GL_FALSE, this
 *                      value will be unmodified, but some elements in the
 *                      linked list may be modified.
 * \param format        Mesa mesa_format enum describing the pixel format
 * \param depth_bits    Array of depth buffer sizes to be exposed.
 * \param stencil_bits  Array of stencil buffer sizes to be exposed.
 * \param num_depth_stencil_bits  Number of entries in both \c depth_bits and
 *                      \c stencil_bits.
 * \param db_modes      Array of buffer swap modes.  If an element has a
 *                      value of \c GLX_NONE, then it represents a
 *                      single-buffered mode.  Other valid values are
 *                      \c GLX_SWAP_EXCHANGE_OML, \c GLX_SWAP_COPY_OML, and
 *                      \c GLX_SWAP_UNDEFINED_OML.  See the
 *                      GLX_OML_swap_method extension spec for more details.
 * \param num_db_modes  Number of entries in \c db_modes.
 * \param msaa_samples  Array of msaa sample count. 0 represents a visual
 *                      without a multisample buffer.
 * \param num_msaa_modes Number of entries in \c msaa_samples.
 * \param visType       GLX visual type.  Usually either \c GLX_TRUE_COLOR or
 *                      \c GLX_DIRECT_COLOR.
 * 
 * \returns
 * Pointer to any array of pointers to the \c __DRIconfig structures created
 * for the specified formats.  If there is an error, \c NULL is returned.
 * Currently the only cause of failure is a bad parameter (i.e., unsupported
 * \c format).
 */
__DRIconfig **
driCreateConfigs(mesa_format format,
		 const uint8_t * depth_bits, const uint8_t * stencil_bits,
		 unsigned num_depth_stencil_bits,
		 const GLenum * db_modes, unsigned num_db_modes,
		 const uint8_t * msaa_samples, unsigned num_msaa_modes,
		 GLboolean enable_accum)
{
   static const uint32_t masks_table[][4] = {
      /* MESA_FORMAT_B5G6R5_UNORM */
      { 0x0000F800, 0x000007E0, 0x0000001F, 0x00000000 },
      /* MESA_FORMAT_B8G8R8X8_UNORM */
      { 0x00FF0000, 0x0000FF00, 0x000000FF, 0x00000000 },
      /* MESA_FORMAT_B8G8R8A8_UNORM */
      { 0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000 },
      /* MESA_FORMAT_B10G10R10X2_UNORM */
      { 0x3FF00000, 0x000FFC00, 0x000003FF, 0x00000000 },
      /* MESA_FORMAT_B10G10R10A2_UNORM */
      { 0x3FF00000, 0x000FFC00, 0x000003FF, 0xC0000000 },
   };

   const uint32_t * masks;
   __DRIconfig **configs, **c;
   struct gl_config *modes;
   unsigned i, j, k, h;
   unsigned num_modes;
   unsigned num_accum_bits = (enable_accum) ? 2 : 1;
   int red_bits;
   int green_bits;
   int blue_bits;
   int alpha_bits;
   bool is_srgb;

   switch (format) {
   case MESA_FORMAT_B5G6R5_UNORM:
      masks = masks_table[0];
      break;
   case MESA_FORMAT_B8G8R8X8_UNORM:
      masks = masks_table[1];
      break;
   case MESA_FORMAT_B8G8R8A8_UNORM:
   case MESA_FORMAT_B8G8R8A8_SRGB:
      masks = masks_table[2];
      break;
   case MESA_FORMAT_B10G10R10X2_UNORM:
      masks = masks_table[3];
      break;
   case MESA_FORMAT_B10G10R10A2_UNORM:
      masks = masks_table[4];
      break;
   default:
      fprintf(stderr, "[%s:%u] Unknown framebuffer type %s (%d).\n",
              __FUNCTION__, __LINE__,
              _mesa_get_format_name(format), format);
      return NULL;
   }

   red_bits = _mesa_get_format_bits(format, GL_RED_BITS);
   green_bits = _mesa_get_format_bits(format, GL_GREEN_BITS);
   blue_bits = _mesa_get_format_bits(format, GL_BLUE_BITS);
   alpha_bits = _mesa_get_format_bits(format, GL_ALPHA_BITS);
   is_srgb = _mesa_get_format_color_encoding(format) == GL_SRGB;

   num_modes = num_depth_stencil_bits * num_db_modes * num_accum_bits * num_msaa_modes;
   configs = calloc(1, (num_modes + 1) * sizeof *configs);
   if (configs == NULL)
       return NULL;

    c = configs;
    for ( k = 0 ; k < num_depth_stencil_bits ; k++ ) {
	for ( i = 0 ; i < num_db_modes ; i++ ) {
	    for ( h = 0 ; h < num_msaa_modes; h++ ) {
	    	for ( j = 0 ; j < num_accum_bits ; j++ ) {
		    *c = malloc (sizeof **c);
		    modes = &(*c)->modes;
		    c++;

		    memset(modes, 0, sizeof *modes);
		    modes->redBits   = red_bits;
		    modes->greenBits = green_bits;
		    modes->blueBits  = blue_bits;
		    modes->alphaBits = alpha_bits;
		    modes->redMask   = masks[0];
		    modes->greenMask = masks[1];
		    modes->blueMask  = masks[2];
		    modes->alphaMask = masks[3];
		    modes->rgbBits   = modes->redBits + modes->greenBits
		    	+ modes->blueBits + modes->alphaBits;

		    modes->accumRedBits   = 16 * j;
		    modes->accumGreenBits = 16 * j;
		    modes->accumBlueBits  = 16 * j;
		    modes->accumAlphaBits = (masks[3] != 0) ? 16 * j : 0;
		    modes->visualRating = (j == 0) ? GLX_NONE : GLX_SLOW_CONFIG;

		    modes->stencilBits = stencil_bits[k];
		    modes->depthBits = depth_bits[k];

		    modes->transparentPixel = GLX_NONE;
		    modes->transparentRed = GLX_DONT_CARE;
		    modes->transparentGreen = GLX_DONT_CARE;
		    modes->transparentBlue = GLX_DONT_CARE;
		    modes->transparentAlpha = GLX_DONT_CARE;
		    modes->transparentIndex = GLX_DONT_CARE;
		    modes->rgbMode = GL_TRUE;

		    if ( db_modes[i] == GLX_NONE ) {
		    	modes->doubleBufferMode = GL_FALSE;
		    }
		    else {
		    	modes->doubleBufferMode = GL_TRUE;
		    	modes->swapMethod = db_modes[i];
		    }

		    modes->samples = msaa_samples[h];
		    modes->sampleBuffers = modes->samples ? 1 : 0;


		    modes->haveAccumBuffer = ((modes->accumRedBits +
					   modes->accumGreenBits +
					   modes->accumBlueBits +
					   modes->accumAlphaBits) > 0);
		    modes->haveDepthBuffer = (modes->depthBits > 0);
		    modes->haveStencilBuffer = (modes->stencilBits > 0);

		    modes->bindToTextureRgb = GL_TRUE;
		    modes->bindToTextureRgba = GL_TRUE;
		    modes->bindToMipmapTexture = GL_FALSE;
		    modes->bindToTextureTargets =
			__DRI_ATTRIB_TEXTURE_1D_BIT |
			__DRI_ATTRIB_TEXTURE_2D_BIT |
			__DRI_ATTRIB_TEXTURE_RECTANGLE_BIT;

		    modes->yInverted = GL_TRUE;
		    modes->sRGBCapable = is_srgb;
		}
	    }
	}
    }
    *c = NULL;

    return configs;
}

__DRIconfig **driConcatConfigs(__DRIconfig **a,
			       __DRIconfig **b)
{
    __DRIconfig **all;
    int i, j, index;

    if (a == NULL || a[0] == NULL)
       return b;
    else if (b == NULL || b[0] == NULL)
       return a;

    i = 0;
    while (a[i] != NULL)
	i++;
    j = 0;
    while (b[j] != NULL)
	j++;
   
    all = malloc((i + j + 1) * sizeof *all);
    index = 0;
    for (i = 0; a[i] != NULL; i++)
	all[index++] = a[i];
    for (j = 0; b[j] != NULL; j++)
	all[index++] = b[j];
    all[index++] = NULL;

    free(a);
    free(b);

    return all;
}

#define __ATTRIB(attrib, field) \
    { attrib, offsetof(struct gl_config, field) }

static const struct { unsigned int attrib, offset; } attribMap[] = {
    __ATTRIB(__DRI_ATTRIB_BUFFER_SIZE,			rgbBits),
    __ATTRIB(__DRI_ATTRIB_LEVEL,			level),
    __ATTRIB(__DRI_ATTRIB_RED_SIZE,			redBits),
    __ATTRIB(__DRI_ATTRIB_GREEN_SIZE,			greenBits),
    __ATTRIB(__DRI_ATTRIB_BLUE_SIZE,			blueBits),
    __ATTRIB(__DRI_ATTRIB_ALPHA_SIZE,			alphaBits),
    __ATTRIB(__DRI_ATTRIB_DEPTH_SIZE,			depthBits),
    __ATTRIB(__DRI_ATTRIB_STENCIL_SIZE,			stencilBits),
    __ATTRIB(__DRI_ATTRIB_ACCUM_RED_SIZE,		accumRedBits),
    __ATTRIB(__DRI_ATTRIB_ACCUM_GREEN_SIZE,		accumGreenBits),
    __ATTRIB(__DRI_ATTRIB_ACCUM_BLUE_SIZE,		accumBlueBits),
    __ATTRIB(__DRI_ATTRIB_ACCUM_ALPHA_SIZE,		accumAlphaBits),
    __ATTRIB(__DRI_ATTRIB_SAMPLE_BUFFERS,		sampleBuffers),
    __ATTRIB(__DRI_ATTRIB_SAMPLES,			samples),
    __ATTRIB(__DRI_ATTRIB_DOUBLE_BUFFER,		doubleBufferMode),
    __ATTRIB(__DRI_ATTRIB_STEREO,			stereoMode),
    __ATTRIB(__DRI_ATTRIB_AUX_BUFFERS,			numAuxBuffers),
    __ATTRIB(__DRI_ATTRIB_TRANSPARENT_TYPE,		transparentPixel),
    __ATTRIB(__DRI_ATTRIB_TRANSPARENT_INDEX_VALUE,	transparentPixel),
    __ATTRIB(__DRI_ATTRIB_TRANSPARENT_RED_VALUE,	transparentRed),
    __ATTRIB(__DRI_ATTRIB_TRANSPARENT_GREEN_VALUE,	transparentGreen),
    __ATTRIB(__DRI_ATTRIB_TRANSPARENT_BLUE_VALUE,	transparentBlue),
    __ATTRIB(__DRI_ATTRIB_TRANSPARENT_ALPHA_VALUE,	transparentAlpha),
    __ATTRIB(__DRI_ATTRIB_RED_MASK,			redMask),
    __ATTRIB(__DRI_ATTRIB_GREEN_MASK,			greenMask),
    __ATTRIB(__DRI_ATTRIB_BLUE_MASK,			blueMask),
    __ATTRIB(__DRI_ATTRIB_ALPHA_MASK,			alphaMask),
    __ATTRIB(__DRI_ATTRIB_MAX_PBUFFER_WIDTH,		maxPbufferWidth),
    __ATTRIB(__DRI_ATTRIB_MAX_PBUFFER_HEIGHT,		maxPbufferHeight),
    __ATTRIB(__DRI_ATTRIB_MAX_PBUFFER_PIXELS,		maxPbufferPixels),
    __ATTRIB(__DRI_ATTRIB_OPTIMAL_PBUFFER_WIDTH,	optimalPbufferWidth),
    __ATTRIB(__DRI_ATTRIB_OPTIMAL_PBUFFER_HEIGHT,	optimalPbufferHeight),
    __ATTRIB(__DRI_ATTRIB_SWAP_METHOD,			swapMethod),
    __ATTRIB(__DRI_ATTRIB_BIND_TO_TEXTURE_RGB,		bindToTextureRgb),
    __ATTRIB(__DRI_ATTRIB_BIND_TO_TEXTURE_RGBA,		bindToTextureRgba),
    __ATTRIB(__DRI_ATTRIB_BIND_TO_MIPMAP_TEXTURE,	bindToMipmapTexture),
    __ATTRIB(__DRI_ATTRIB_BIND_TO_TEXTURE_TARGETS,	bindToTextureTargets),
    __ATTRIB(__DRI_ATTRIB_YINVERTED,			yInverted),
    __ATTRIB(__DRI_ATTRIB_FRAMEBUFFER_SRGB_CAPABLE,	sRGBCapable),

    /* The struct field doesn't matter here, these are handled by the
     * switch in driGetConfigAttribIndex.  We need them in the array
     * so the iterator includes them though.*/
    __ATTRIB(__DRI_ATTRIB_RENDER_TYPE,			level),
    __ATTRIB(__DRI_ATTRIB_CONFIG_CAVEAT,		level),
    __ATTRIB(__DRI_ATTRIB_SWAP_METHOD,			level)
};


/**
 * Return the value of a configuration attribute.  The attribute is
 * indicated by the index.
 */
static int
driGetConfigAttribIndex(const __DRIconfig *config,
			unsigned int index, unsigned int *value)
{
    switch (attribMap[index].attrib) {
    case __DRI_ATTRIB_RENDER_TYPE:
        /* no support for color index mode */
	*value = __DRI_ATTRIB_RGBA_BIT;
	break;
    case __DRI_ATTRIB_CONFIG_CAVEAT:
	if (config->modes.visualRating == GLX_NON_CONFORMANT_CONFIG)
	    *value = __DRI_ATTRIB_NON_CONFORMANT_CONFIG;
	else if (config->modes.visualRating == GLX_SLOW_CONFIG)
	    *value = __DRI_ATTRIB_SLOW_BIT;
	else
	    *value = 0;
	break;
    case __DRI_ATTRIB_SWAP_METHOD:
        /* XXX no return value??? */
	break;

    default:
        /* any other int-sized field */
	*value = *(unsigned int *)
	    ((char *) &config->modes + attribMap[index].offset);
	
	break;
    }

    return GL_TRUE;
}


/**
 * Get the value of a configuration attribute.
 * \param attrib  the attribute (one of the _DRI_ATTRIB_x tokens)
 * \param value  returns the attribute's value
 * \return 1 for success, 0 for failure
 */
int
driGetConfigAttrib(const __DRIconfig *config,
		   unsigned int attrib, unsigned int *value)
{
    int i;

    for (i = 0; i < ARRAY_SIZE(attribMap); i++)
	if (attribMap[i].attrib == attrib)
	    return driGetConfigAttribIndex(config, i, value);

    return GL_FALSE;
}


/**
 * Get a configuration attribute name and value, given an index.
 * \param index  which field of the __DRIconfig to query
 * \param attrib  returns the attribute name (one of the _DRI_ATTRIB_x tokens)
 * \param value  returns the attribute's value
 * \return 1 for success, 0 for failure
 */
int
driIndexConfigAttrib(const __DRIconfig *config, int index,
		     unsigned int *attrib, unsigned int *value)
{
    if (index >= 0 && index < ARRAY_SIZE(attribMap)) {
	*attrib = attribMap[index].attrib;
	return driGetConfigAttribIndex(config, index, value);
    }

    return GL_FALSE;
}

/**
 * Implement queries for values that are common across all Mesa drivers
 *
 * Currently only the following queries are supported by this function:
 *
 *     - \c __DRI2_RENDERER_VERSION
 *     - \c __DRI2_RENDERER_OPENGL_CORE_PROFILE_VERSION
 *     - \c __DRI2_RENDERER_OPENGL_COMPATIBLITY_PROFILE_VERSION
 *     - \c __DRI2_RENDERER_ES_PROFILE_VERSION
 *     - \c __DRI2_RENDERER_ES2_PROFILE_VERSION
 *
 * \returns
 * Zero if a recognized value of \c param is supplied, -1 otherwise.
 */
int
driQueryRendererIntegerCommon(__DRIscreen *psp, int param, unsigned int *value)
{
   switch (param) {
   case __DRI2_RENDERER_VERSION: {
      static const char *const ver = PACKAGE_VERSION;
      char *endptr;
      int v[3];

      v[0] = strtol(ver, &endptr, 10);
      assert(endptr[0] == '.');
      if (endptr[0] != '.')
         return -1;

      v[1] = strtol(endptr + 1, &endptr, 10);
      assert(endptr[0] == '.');
      if (endptr[0] != '.')
         return -1;

      v[2] = strtol(endptr + 1, &endptr, 10);

      value[0] = v[0];
      value[1] = v[1];
      value[2] = v[2];
      return 0;
   }
   case __DRI2_RENDERER_PREFERRED_PROFILE:
      value[0] = (psp->max_gl_core_version != 0)
         ? (1U << __DRI_API_OPENGL_CORE) : (1U << __DRI_API_OPENGL);
      return 0;
   case __DRI2_RENDERER_OPENGL_CORE_PROFILE_VERSION:
      value[0] = psp->max_gl_core_version / 10;
      value[1] = psp->max_gl_core_version % 10;
      return 0;
   case __DRI2_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION:
      value[0] = psp->max_gl_compat_version / 10;
      value[1] = psp->max_gl_compat_version % 10;
      return 0;
   case __DRI2_RENDERER_OPENGL_ES_PROFILE_VERSION:
      value[0] = psp->max_gl_es1_version / 10;
      value[1] = psp->max_gl_es1_version % 10;
      return 0;
   case __DRI2_RENDERER_OPENGL_ES2_PROFILE_VERSION:
      value[0] = psp->max_gl_es2_version / 10;
      value[1] = psp->max_gl_es2_version % 10;
      return 0;
   default:
      break;
   }

   return -1;
}
@


1.11
log
@Backport support for GLX_MESA_query_renderer for non Intel drivers.
This is desirable as the chromium port now uses this extension to
obtain pci vendor/device ids for use in feature/extension blacklists.

Prompted by a mail from byrnet@@, tested on r600g by krw@@

The newly added os_get_total_physical_memory() was passing the length of
a pointer rather than the type which made the sysctl call fail on
non 64 bit archs.  And it was passing the wrong pointer for the result.
Fixes for these problems have been submitted back upstream.
@
text
@@


1.10
log
@Merge Mesa 10.2.9
@
text
@d522 4
@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d241 1
a241 1
   configs = calloc(num_modes + 1, sizeof *configs);
a521 4
   case __DRI2_RENDERER_PREFERRED_PROFILE:
      value[0] = (psp->max_gl_core_version != 0)
         ? (1U << __DRI_API_OPENGL_CORE) : (1U << __DRI_API_OPENGL);
      return 0;
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d241 1
a241 1
   configs = calloc(1, (num_modes + 1) * sizeof *configs);
d522 4
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d35 1
d41 1
d44 1
a44 1
unsigned
d48 1
a48 2
   unsigned   flag;

a49 1
   flag = 0;
d153 1
a153 1
 * \param format        Mesa gl_format enum describing the pixel format
d178 1
a178 1
driCreateConfigs(gl_format format,
d186 1
a186 1
      /* MESA_FORMAT_RGB565 */
d188 1
a188 1
      /* MESA_FORMAT_XRGB8888 */
d190 1
a190 1
      /* MESA_FORMAT_ARGB8888 */
d192 4
d211 1
a211 1
   case MESA_FORMAT_RGB565:
d214 1
a214 1
   case MESA_FORMAT_XRGB8888:
d217 2
a218 2
   case MESA_FORMAT_ARGB8888:
   case MESA_FORMAT_SARGB8:
d221 6
d310 1
d480 63
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d34 2
a41 23
/**
 * Print message to \c stderr if the \c LIBGL_DEBUG environment variable
 * is set. 
 * 
 * Is called from the drivers.
 * 
 * \param f \c printf like format string.
 */
void
__driUtilMessage(const char *f, ...)
{
    va_list args;

    if (getenv("LIBGL_DEBUG")) {
        fprintf(stderr, "libGL: ");
        va_start(args, f);
        vfprintf(stderr, f, args);
        va_end(args);
        fprintf(stderr, "\n");
    }
}


a118 232


#define need_GL_ARB_copy_buffer
#define need_GL_ARB_draw_buffers
#define need_GL_ARB_multisample
#define need_GL_ARB_texture_compression
#define need_GL_ARB_transpose_matrix
#define need_GL_ARB_vertex_buffer_object
#define need_GL_ARB_window_pos
#define need_GL_EXT_compiled_vertex_array
#define need_GL_EXT_multi_draw_arrays
#define need_GL_EXT_polygon_offset
#define need_GL_EXT_texture_object
#define need_GL_EXT_vertex_array
#define need_GL_IBM_multimode_draw_arrays
#define need_GL_MESA_window_pos

/* These are needed in *all* drivers because Mesa internally implements
 * certain functionality in terms of functions provided by these extensions.
 * For example, glBlendFunc is implemented by calling glBlendFuncSeparateEXT.
 */
#define need_GL_EXT_blend_func_separate
#define need_GL_NV_vertex_program

#include "main/remap_helper.h"

static const struct dri_extension all_mesa_extensions[] = {
   { "GL_ARB_copy_buffer",           GL_ARB_copy_buffer_functions },
   { "GL_ARB_draw_buffers",          GL_ARB_draw_buffers_functions },
   { "GL_ARB_multisample",           GL_ARB_multisample_functions },
   { "GL_ARB_texture_compression",   GL_ARB_texture_compression_functions },
   { "GL_ARB_transpose_matrix",      GL_ARB_transpose_matrix_functions },
   { "GL_ARB_vertex_buffer_object",  GL_ARB_vertex_buffer_object_functions},
   { "GL_ARB_window_pos",            GL_ARB_window_pos_functions },
   { "GL_EXT_blend_func_separate",   GL_EXT_blend_func_separate_functions },
   { "GL_EXT_compiled_vertex_array", GL_EXT_compiled_vertex_array_functions },
   { "GL_EXT_multi_draw_arrays",     GL_EXT_multi_draw_arrays_functions },
   { "GL_EXT_polygon_offset",        GL_EXT_polygon_offset_functions },
   { "GL_EXT_texture_object",        GL_EXT_texture_object_functions },
   { "GL_EXT_vertex_array",          GL_EXT_vertex_array_functions },
   { "GL_IBM_multimode_draw_arrays", GL_IBM_multimode_draw_arrays_functions },
   { "GL_MESA_window_pos",           GL_MESA_window_pos_functions },
   { "GL_NV_vertex_program",         GL_NV_vertex_program_functions },
   { NULL,                           NULL }
};


/**
 * Enable and map extensions supported by the driver.
 * 
 * When ctx is NULL, extensions are not enabled, but their functions
 * are still mapped.  When extensions_to_enable is NULL, all static
 * functions known to mesa core are mapped.
 *
 * \bug
 * ARB_imaging isn't handled properly.  In Mesa, enabling ARB_imaging also
 * enables all the sub-extensions that are folded into it.  This means that
 * we need to add entry-points (via \c driInitSingleExtension) for those
 * new functions here.
 */
void driInitExtensions( struct gl_context * ctx,
			const struct dri_extension * extensions_to_enable,
			GLboolean enable_imaging )
{
   static int first_time = 1;
   unsigned   i;

   if ( first_time ) {
      first_time = 0;
      driInitExtensions( NULL, all_mesa_extensions, GL_FALSE );
   }

   if ( (ctx != NULL) && enable_imaging ) {
      _mesa_enable_imaging_extensions( ctx );
   }

   /* The caller is too lazy to list any extension */
   if ( extensions_to_enable == NULL ) {
      /* Map the static functions.  Together with those mapped by remap
       * table, this should cover everything mesa core knows.
       */
      _mesa_map_static_functions();
      return;
   }

   for ( i = 0 ; extensions_to_enable[i].name != NULL ; i++ ) {
       driInitSingleExtension( ctx, & extensions_to_enable[i] );
   }
}




/**
 * Enable and map functions for a single extension
 * 
 * \param ctx  Context where extension is to be enabled.
 * \param ext  Extension that is to be enabled.
 * 
 * \sa driInitExtensions, _mesa_enable_extension, _mesa_map_function_array
 */
void driInitSingleExtension( struct gl_context * ctx,
			     const struct dri_extension * ext )
{
    if ( ext->functions != NULL ) {
       _mesa_map_function_array(ext->functions);
    }

    if ( ctx != NULL ) {
	_mesa_enable_extension( ctx, ext->name );
    }
}


/**
 * Utility function used by drivers to test the verions of other components.
 *
 * \param driver_name  Name of the driver.  Used in error messages.
 * \param driActual    Actual DRI version supplied __driCreateNewScreen.
 * \param driExpected  Minimum DRI version required by the driver.
 * \param ddxActual    Actual DDX version supplied __driCreateNewScreen.
 * \param ddxExpected  Minimum DDX minor and range of DDX major version required by the driver.
 * \param drmActual    Actual DRM version supplied __driCreateNewScreen.
 * \param drmExpected  Minimum DRM version required by the driver.
 * 
 * \returns \c GL_TRUE if all version requirements are met.  Otherwise,
 *          \c GL_FALSE is returned.
 * 
 * \sa __driCreateNewScreen, driCheckDriDdxDrmVersions2
 *
 * \todo
 * Now that the old \c driCheckDriDdxDrmVersions function is gone, this
 * function and \c driCheckDriDdxDrmVersions2 should be renamed.
 */
GLboolean
driCheckDriDdxDrmVersions3(const char * driver_name,
			   const __DRIversion * driActual,
			   const __DRIversion * driExpected,
			   const __DRIversion * ddxActual,
			   const __DRIutilversion2 * ddxExpected,
			   const __DRIversion * drmActual,
			   const __DRIversion * drmExpected)
{
   static const char format[] = "%s DRI driver expected %s version %d.%d.x "
       "but got version %d.%d.%d\n";
   static const char format2[] = "%s DRI driver expected %s version %d-%d.%d.x "
       "but got version %d.%d.%d\n";


   /* Check the DRI version */
   if ( (driActual->major != driExpected->major)
	|| (driActual->minor < driExpected->minor) ) {
      fprintf(stderr, format, driver_name, "DRI",
		       driExpected->major, driExpected->minor,
		       driActual->major, driActual->minor, driActual->patch);
      return GL_FALSE;
   }

   /* Check that the DDX driver version is compatible */
   if ( (ddxActual->major < ddxExpected->major_min)
	|| (ddxActual->major > ddxExpected->major_max)
	|| (ddxActual->minor < ddxExpected->minor) ) {
      fprintf(stderr, format2, driver_name, "DDX",
		       ddxExpected->major_min, ddxExpected->major_max, ddxExpected->minor,
		       ddxActual->major, ddxActual->minor, ddxActual->patch);
      return GL_FALSE;
   }
   
   /* Check that the DRM driver version is compatible */
   if ( (drmActual->major != drmExpected->major)
	|| (drmActual->minor < drmExpected->minor) ) {
      fprintf(stderr, format, driver_name, "DRM",
		       drmExpected->major, drmExpected->minor,
		       drmActual->major, drmActual->minor, drmActual->patch);
      return GL_FALSE;
   }

   return GL_TRUE;
}

GLboolean
driCheckDriDdxDrmVersions2(const char * driver_name,
			   const __DRIversion * driActual,
			   const __DRIversion * driExpected,
			   const __DRIversion * ddxActual,
			   const __DRIversion * ddxExpected,
			   const __DRIversion * drmActual,
			   const __DRIversion * drmExpected)
{
   __DRIutilversion2 ddx_expected;
   ddx_expected.major_min = ddxExpected->major;
   ddx_expected.major_max = ddxExpected->major;
   ddx_expected.minor = ddxExpected->minor;
   ddx_expected.patch = ddxExpected->patch;
   return driCheckDriDdxDrmVersions3(driver_name, driActual,
				driExpected, ddxActual, & ddx_expected,
				drmActual, drmExpected);
}

GLboolean driClipRectToFramebuffer( const struct gl_framebuffer *buffer,
				    GLint *x, GLint *y,
				    GLsizei *width, GLsizei *height )
{
   /* left clipping */
   if (*x < buffer->_Xmin) {
      *width -= (buffer->_Xmin - *x);
      *x = buffer->_Xmin;
   }

   /* right clipping */
   if (*x + *width > buffer->_Xmax)
      *width -= (*x + *width - buffer->_Xmax - 1);

   if (*width <= 0)
      return GL_FALSE;

   /* bottom clipping */
   if (*y < buffer->_Ymin) {
      *height -= (buffer->_Ymin - *y);
      *y = buffer->_Ymin;
   }

   /* top clipping */
   if (*y + *height > buffer->_Ymax)
      *height -= (*y + *height - buffer->_Ymax - 1);

   if (*height <= 0)
      return GL_FALSE;

   return GL_TRUE;
}

d153 1
a153 7
 * \param fb_format     Format of the framebuffer.  Currently only \c GL_RGB,
 *                      \c GL_RGBA, \c GL_BGR, and \c GL_BGRA are supported.
 * \param fb_type       Type of the pixels in the framebuffer.  Currently only
 *                      \c GL_UNSIGNED_SHORT_5_6_5, 
 *                      \c GL_UNSIGNED_SHORT_5_6_5_REV,
 *                      \c GL_UNSIGNED_INT_8_8_8_8, and
 *                      \c GL_UNSIGNED_INT_8_8_8_8_REV are supported.
d172 4
a175 10
 * \c GL_TRUE on success or \c GL_FALSE on failure.  Currently the only
 * cause of failure is a bad parameter (i.e., unsupported \c fb_format or
 * \c fb_type).
 * 
 * \todo
 * There is currently no way to support packed RGB modes (i.e., modes with
 * exactly 3 bytes per pixel) or floating-point modes.  This could probably
 * be done by creating some new, private enums with clever names likes
 * \c GL_UNSIGNED_3BYTE_8_8_8, \c GL_4FLOAT_32_32_32_32, 
 * \c GL_4HALF_16_16_16_16, etc.  We can cross that bridge when we come to it.
d178 1
a178 1
driCreateConfigs(GLenum fb_format, GLenum fb_type,
d185 7
a191 33
   static const uint8_t bits_table[4][4] = {
     /* R  G  B  A */
      { 3, 3, 2, 0 }, /* Any GL_UNSIGNED_BYTE_3_3_2 */
      { 5, 6, 5, 0 }, /* Any GL_UNSIGNED_SHORT_5_6_5 */
      { 8, 8, 8, 0 }, /* Any RGB with any GL_UNSIGNED_INT_8_8_8_8 */
      { 8, 8, 8, 8 }  /* Any RGBA with any GL_UNSIGNED_INT_8_8_8_8 */
   };

   static const uint32_t masks_table_rgb[6][4] = {
      { 0x000000E0, 0x0000001C, 0x00000003, 0x00000000 }, /* 3_3_2       */
      { 0x00000007, 0x00000038, 0x000000C0, 0x00000000 }, /* 2_3_3_REV   */
      { 0x0000F800, 0x000007E0, 0x0000001F, 0x00000000 }, /* 5_6_5       */
      { 0x0000001F, 0x000007E0, 0x0000F800, 0x00000000 }, /* 5_6_5_REV   */
      { 0xFF000000, 0x00FF0000, 0x0000FF00, 0x00000000 }, /* 8_8_8_8     */
      { 0x000000FF, 0x0000FF00, 0x00FF0000, 0x00000000 }  /* 8_8_8_8_REV */
   };

   static const uint32_t masks_table_rgba[6][4] = {
      { 0x000000E0, 0x0000001C, 0x00000003, 0x00000000 }, /* 3_3_2       */
      { 0x00000007, 0x00000038, 0x000000C0, 0x00000000 }, /* 2_3_3_REV   */
      { 0x0000F800, 0x000007E0, 0x0000001F, 0x00000000 }, /* 5_6_5       */
      { 0x0000001F, 0x000007E0, 0x0000F800, 0x00000000 }, /* 5_6_5_REV   */
      { 0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF }, /* 8_8_8_8     */
      { 0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000 }, /* 8_8_8_8_REV */
   };

   static const uint32_t masks_table_bgr[6][4] = {
      { 0x00000007, 0x00000038, 0x000000C0, 0x00000000 }, /* 3_3_2       */
      { 0x000000E0, 0x0000001C, 0x00000003, 0x00000000 }, /* 2_3_3_REV   */
      { 0x0000001F, 0x000007E0, 0x0000F800, 0x00000000 }, /* 5_6_5       */
      { 0x0000F800, 0x000007E0, 0x0000001F, 0x00000000 }, /* 5_6_5_REV   */
      { 0x0000FF00, 0x00FF0000, 0xFF000000, 0x00000000 }, /* 8_8_8_8     */
      { 0x00FF0000, 0x0000FF00, 0x000000FF, 0x00000000 }, /* 8_8_8_8_REV */
a193 19
   static const uint32_t masks_table_bgra[6][4] = {
      { 0x00000007, 0x00000038, 0x000000C0, 0x00000000 }, /* 3_3_2       */
      { 0x000000E0, 0x0000001C, 0x00000003, 0x00000000 }, /* 2_3_3_REV   */
      { 0x0000001F, 0x000007E0, 0x0000F800, 0x00000000 }, /* 5_6_5       */
      { 0x0000F800, 0x000007E0, 0x0000001F, 0x00000000 }, /* 5_6_5_REV   */
      { 0x0000FF00, 0x00FF0000, 0xFF000000, 0x000000FF }, /* 8_8_8_8     */
      { 0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000 }, /* 8_8_8_8_REV */
   };

   static const uint8_t bytes_per_pixel[6] = {
      1, /* 3_3_2       */
      1, /* 2_3_3_REV   */
      2, /* 5_6_5       */
      2, /* 5_6_5_REV   */
      4, /* 8_8_8_8     */
      4  /* 8_8_8_8_REV */
   };

   const uint8_t  * bits;
a194 1
   int index;
d200 22
a221 54

   switch ( fb_type ) {
      case GL_UNSIGNED_BYTE_3_3_2:
	 index = 0;
	 break;
      case GL_UNSIGNED_BYTE_2_3_3_REV:
	 index = 1;
	 break;
      case GL_UNSIGNED_SHORT_5_6_5:
	 index = 2;
	 break;
      case GL_UNSIGNED_SHORT_5_6_5_REV:
	 index = 3;
	 break;
      case GL_UNSIGNED_INT_8_8_8_8:
	 index = 4;
	 break;
      case GL_UNSIGNED_INT_8_8_8_8_REV:
	 index = 5;
	 break;
      default:
	 fprintf( stderr, "[%s:%u] Unknown framebuffer type 0x%04x.\n",
               __FUNCTION__, __LINE__, fb_type );
	 return NULL;
   }


   /* Valid types are GL_UNSIGNED_SHORT_5_6_5 and GL_UNSIGNED_INT_8_8_8_8 and
    * the _REV versions.
    *
    * Valid formats are GL_RGBA, GL_RGB, and GL_BGRA.
    */

   switch ( fb_format ) {
      case GL_RGB:
         masks = masks_table_rgb[ index ];
         break;

      case GL_RGBA:
         masks = masks_table_rgba[ index ];
         break;

      case GL_BGR:
         masks = masks_table_bgr[ index ];
         break;

      case GL_BGRA:
         masks = masks_table_bgra[ index ];
         break;

      default:
         fprintf( stderr, "[%s:%u] Unknown framebuffer format 0x%04x.\n",
               __FUNCTION__, __LINE__, fb_format );
         return NULL;
d224 5
a228 13
   switch ( bytes_per_pixel[ index ] ) {
      case 1:
	 bits = bits_table[0];
	 break;
      case 2:
	 bits = bits_table[1];
	 break;
      default:
	 bits = ((fb_format == GL_RGB) || (fb_format == GL_BGR))
	    ? bits_table[2]
	    : bits_table[3];
	 break;
   }
d245 4
a248 4
		    modes->redBits   = bits[0];
		    modes->greenBits = bits[1];
		    modes->blueBits  = bits[2];
		    modes->alphaBits = bits[3];
d300 1
a300 1
		    modes->sRGBCapable = GL_FALSE;
d316 5
a368 1
    __ATTRIB(__DRI_ATTRIB_FLOAT_MODE,			floatMode),
a393 2
#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))

a418 5

    case __DRI_ATTRIB_FLOAT_MODE:
        /* this field is not int-sized */
        *value = config->modes.floatMode;
        break;
@


1.5
log
@Merge Mesa 7.10.3
@
text
@a98 1
 * \param driver_date    Driver date.
d107 1
a107 1
		      const char * driver_date, GLuint agp_mode )
d112 1
a112 1
   offset = sprintf( buffer, "Mesa DRI %s %s", hardware_name, driver_date );
d650 2
d731 1
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d40 23
d143 1
d168 1
d201 1
a201 1
void driInitExtensions( GLcontext * ctx,
d242 1
a242 1
void driInitSingleExtension( GLcontext * ctx,
a257 3
 * If one of the version requirements is not met, a message is logged using
 * \c __driUtilMessage.
 *
d269 1
a269 1
 * \sa __driCreateNewScreen, driCheckDriDdxDrmVersions2, __driUtilMessage
d340 1
a340 1
GLboolean driClipRectToFramebuffer( const GLframebuffer *buffer,
d374 1
a374 1
 * Creates a set of \c __GLcontextModes that a driver will expose.
d376 1
a376 1
 * A set of \c __GLcontextModes will be created based on the supplied
d381 1
a381 1
 * \c db_modes, and \c visType into each \c __GLcontextModes element.
d394 1
a394 1
 * \c __GLcontextModes structure is \b identical to the \c GL_RGBA or
d402 1
a402 1
 *                      \c __GLcontextModes.  Upon completion, a pointer to
d508 1
a508 1
   __GLcontextModes *modes;
a622 3
		    modes->visualType = GLX_DONT_CARE;
		    modes->renderType = GLX_RGBA_BIT;
		    modes->drawableType = GLX_WINDOW_BIT;
d688 1
a688 1
    { attrib, offsetof(__GLcontextModes, field) }
d741 5
d752 1
d764 1
d768 1
d773 1
d783 7
d803 8
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d35 1
a36 1
#include "glapi/dispatch.h"
a38 9
int driDispatchRemapTable[ driDispatchRemapTable_size ];

#if defined(USE_X86_ASM)
#include "x86/common_x86_asm.h"
#endif

#if defined(USE_PPC_ASM)
#include "ppc/common_ppc_features.h"
#endif
d87 2
a88 6
#define MAX_INFO   4
   const char * cpu[MAX_INFO];
   unsigned   next = 0;
   unsigned   i;
   unsigned   offset;

d108 4
a111 53
#ifdef USE_X86_ASM
   if ( _mesa_x86_cpu_features ) {
      cpu[next] = " x86";
      next++;
   }
# ifdef USE_MMX_ASM
   if ( cpu_has_mmx ) {
      cpu[next] = (cpu_has_mmxext) ? "/MMX+" : "/MMX";
      next++;
   }
# endif
# ifdef USE_3DNOW_ASM
   if ( cpu_has_3dnow ) {
      cpu[next] = (cpu_has_3dnowext) ? "/3DNow!+" : "/3DNow!";
      next++;
   }
# endif
# ifdef USE_SSE_ASM
   if ( cpu_has_xmm ) {
      cpu[next] = (cpu_has_xmm2) ? "/SSE2" : "/SSE";
      next++;
   }
# endif

#elif defined(USE_SPARC_ASM)

   cpu[0] = " SPARC";
   next = 1;

#elif defined(USE_PPC_ASM)
   if ( _mesa_ppc_cpu_features ) {
      cpu[next] = (cpu_has_64) ? " PowerPC 64" : " PowerPC";
      next++;
   }

# ifdef USE_VMX_ASM
   if ( cpu_has_vmx ) {
      cpu[next] = "/Altivec";
      next++;
   }
# endif

   if ( ! cpu_has_fpu ) {
      cpu[next] = "/No FPU";
      next++;
   }
#endif

   for ( i = 0 ; i < next ; i++ ) {
      const size_t len = strlen( cpu[i] );

      strncpy( & buffer[ offset ], cpu[i], len );
      offset += len;
d120 1
d122 1
d124 1
d127 1
d131 1
d141 1
a141 1
#include "extension_helper.h"
d144 1
d146 1
d148 1
d152 1
d156 1
d164 1
a164 1
 * Enable extensions supported by the driver.
d166 4
a183 4
      for ( i = 0 ; i < driDispatchRemapTable_size ; i++ ) {
	 driDispatchRemapTable[i] = -1;
      }

d185 1
a185 1
      driInitExtensions( ctx, all_mesa_extensions, GL_FALSE );
d192 9
d210 1
a210 1
 * Enable and add dispatch functions for a single extension
d215 1
a215 5
 * \sa driInitExtensions, _mesa_enable_extension, _glapi_add_entrypoint
 *
 * \todo
 * Determine if it would be better to use \c strlen instead of the hardcoded
 * for-loops.
a219 3
    unsigned i;


d221 1
a221 54
	for ( i = 0 ; ext->functions[i].strings != NULL ; i++ ) {
	    const char * functions[16];
	    const char * parameter_signature;
	    const char * str = ext->functions[i].strings;
	    unsigned j;
	    unsigned offset;


	    /* Separate the parameter signature from the rest of the string.
	     * If the parameter signature is empty (i.e., the string starts
	     * with a NUL character), then the function has a void parameter
	     * list.
	     */
	    parameter_signature = str;
	    while ( str[0] != '\0' ) {
		str++;
	    }
	    str++;


	    /* Divide the string into the substrings that name each
	     * entry-point for the function.
	     */
	    for ( j = 0 ; j < 16 ; j++ ) {
		if ( str[0] == '\0' ) {
		    functions[j] = NULL;
		    break;
		}

		functions[j] = str;

		while ( str[0] != '\0' ) {
		    str++;
		}
		str++;
	    }


	    /* Add each entry-point to the dispatch table.
	     */
	    offset = _glapi_add_dispatch( functions, parameter_signature );
	    if (offset == -1) {
		fprintf(stderr, "DISPATCH ERROR! _glapi_add_dispatch failed "
			"to add %s!\n", functions[0]);
	    }
	    else if (ext->functions[i].remap_index != -1) {
		driDispatchRemapTable[ ext->functions[i].remap_index ] = 
		  offset;
	    }
	    else if (ext->functions[i].offset != offset) {
		fprintf(stderr, "DISPATCH ERROR! %s -> %u != %u\n",
			functions[0], offset, ext->functions[i].offset);
	    }
	}
d278 1
a278 2
   /* for miniglx we pass in -1 so we can ignore the DDX version */
   if ( (ddxActual->major != -1) && ((ddxActual->major < ddxExpected->major_min)
d280 1
a280 1
	|| (ddxActual->minor < ddxExpected->minor)) ) {
d403 3
d425 3
a427 1
		 const GLenum * db_modes, unsigned num_db_modes)
d487 1
a487 3
   unsigned i;
   unsigned j;
   unsigned k;
d489 1
a489 1
   unsigned num_accum_bits = 2;
d560 2
a561 2
   num_modes = num_depth_stencil_bits * num_db_modes * num_accum_bits;
   configs = _mesa_calloc((num_modes + 1) * sizeof *configs);
d568 48
a615 36
	    for ( j = 0 ; j < num_accum_bits ; j++ ) {
		*c = _mesa_malloc (sizeof **c);
		modes = &(*c)->modes;
		c++;

		memset(modes, 0, sizeof *modes);
		modes->redBits   = bits[0];
		modes->greenBits = bits[1];
		modes->blueBits  = bits[2];
		modes->alphaBits = bits[3];
		modes->redMask   = masks[0];
		modes->greenMask = masks[1];
		modes->blueMask  = masks[2];
		modes->alphaMask = masks[3];
		modes->rgbBits   = modes->redBits + modes->greenBits
		    + modes->blueBits + modes->alphaBits;

		modes->accumRedBits   = 16 * j;
		modes->accumGreenBits = 16 * j;
		modes->accumBlueBits  = 16 * j;
		modes->accumAlphaBits = (masks[3] != 0) ? 16 * j : 0;
		modes->visualRating = (j == 0) ? GLX_NONE : GLX_SLOW_CONFIG;

		modes->stencilBits = stencil_bits[k];
		modes->depthBits = depth_bits[k];

		modes->transparentPixel = GLX_NONE;
		modes->transparentRed = GLX_DONT_CARE;
		modes->transparentGreen = GLX_DONT_CARE;
		modes->transparentBlue = GLX_DONT_CARE;
		modes->transparentAlpha = GLX_DONT_CARE;
		modes->transparentIndex = GLX_DONT_CARE;
		modes->visualType = GLX_DONT_CARE;
		modes->renderType = GLX_RGBA_BIT;
		modes->drawableType = GLX_WINDOW_BIT;
		modes->rgbMode = GL_TRUE;
a616 7
		if ( db_modes[i] == GLX_NONE ) {
		    modes->doubleBufferMode = GL_FALSE;
		}
		else {
		    modes->doubleBufferMode = GL_TRUE;
		    modes->swapMethod = db_modes[i];
		}
d618 1
a618 1
		modes->haveAccumBuffer = ((modes->accumRedBits +
d622 2
a623 2
		modes->haveDepthBuffer = (modes->depthBits > 0);
		modes->haveStencilBuffer = (modes->stencilBits > 0);
d625 8
a632 8
		modes->bindToTextureRgb = GL_TRUE;
		modes->bindToTextureRgba = GL_TRUE;
		modes->bindToMipmapTexture = GL_FALSE;
		modes->bindToTextureTargets = modes->rgbMode ?
		    __DRI_ATTRIB_TEXTURE_1D_BIT |
		    __DRI_ATTRIB_TEXTURE_2D_BIT |
		    __DRI_ATTRIB_TEXTURE_RECTANGLE_BIT :
		    0;
d641 2
a642 1
const __DRIconfig **driConcatConfigs(__DRIconfig **a, __DRIconfig **b)
d644 1
a644 1
    const __DRIconfig **all;
d654 1
a654 1
    all = _mesa_malloc((i + j + 1) * sizeof *all);
d662 2
a663 2
    _mesa_free(a);
    _mesa_free(b);
d728 1
a728 4
	if (config->modes.rgbMode)
	    *value = __DRI_ATTRIB_RGBA_BIT;
	else
	    *value = __DRI_ATTRIB_COLOR_INDEX_BIT;
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d34 3
a36 2
#include "mtypes.h"
#include "extensions.h"
a37 1
#include "dispatch.h"
d524 1
a524 1
		 const u_int8_t * depth_bits, const u_int8_t * stencil_bits,
d528 1
a528 1
   static const u_int8_t bits_table[4][4] = {
d536 1
a536 1
   static const u_int32_t masks_table_rgb[6][4] = {
d545 1
a545 1
   static const u_int32_t masks_table_rgba[6][4] = {
d554 1
a554 1
   static const u_int32_t masks_table_bgr[6][4] = {
d563 1
a563 1
   static const u_int32_t masks_table_bgra[6][4] = {
d572 1
a572 1
   static const u_int8_t bytes_per_pixel[6] = {
d581 2
a582 2
   const u_int8_t  * bits;
   const u_int32_t * masks;
@


1.1
log
@Initial revision
@
text
@a421 2


a454 2


d522 5
a526 7
GLboolean
driFillInModes( __GLcontextModes ** ptr_to_modes,
		GLenum fb_format, GLenum fb_type,
		const u_int8_t * depth_bits, const u_int8_t * stencil_bits,
		unsigned num_depth_stencil_bits,
		const GLenum * db_modes, unsigned num_db_modes,
		int visType )
d528 1
a528 1
   static const u_int8_t bits_table[3][4] = {
d530 1
d536 3
a538 8
   /* The following arrays are all indexed by the fb_type masked with 0x07.
    * Given the four supported fb_type values, this results in valid array
    * indices of 3, 4, 5, and 7.
    */
   static const u_int32_t masks_table_rgb[8][4] = {
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
a541 1
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
d545 3
a547 4
   static const u_int32_t masks_table_rgba[8][4] = {
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
a550 1
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
d554 3
a556 4
   static const u_int32_t masks_table_bgr[8][4] = {
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
a559 1
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
d563 3
a565 4
   static const u_int32_t masks_table_bgra[8][4] = {
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
a568 1
      { 0x00000000, 0x00000000, 0x00000000, 0x00000000 },
d572 7
a578 2
   static const u_int8_t bytes_per_pixel[8] = {
      0, 0, 0, 2, 2, 4, 0, 4
d583 3
a585 2
   const int index = fb_type & 0x07;
   __GLcontextModes * modes = *ptr_to_modes;
d589 2
d592 23
a614 5

   if ( bytes_per_pixel[ index ] == 0 ) {
      fprintf( stderr, "[%s:%u] Framebuffer type 0x%04x has 0 bytes per pixel.\n",
	       __FUNCTION__, __LINE__, fb_type );
      return GL_FALSE;
a625 2
         bits = (bytes_per_pixel[ index ] == 2)
	     ? bits_table[0] : bits_table[1];
a629 2
         bits = (bytes_per_pixel[ index ] == 2)
	     ? bits_table[0] : bits_table[2];
a633 2
         bits = (bytes_per_pixel[ index ] == 2)
	     ? bits_table[0] : bits_table[1];
a637 2
         bits = (bytes_per_pixel[ index ] == 2)
	     ? bits_table[0] : bits_table[2];
d642 3
a644 3
         fprintf( stderr, "[%s:%u] Framebuffer format 0x%04x is not GL_RGB, GL_RGBA, GL_BGR, or GL_BGRA.\n",
	       __FUNCTION__, __LINE__, fb_format );
         return GL_FALSE;
d647 18
d666 1
d669 4
a672 1
	    for ( j = 0 ; j < 2 ; j++ ) {
d674 1
d695 7
a701 1
		modes->visualType = visType;
d721 8
a728 1
		modes = modes->next;
d732 117
a849 1
    *ptr_to_modes = modes;
d851 25
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a423 13
GLint
driIntersectArea( drm_clip_rect_t rect1, drm_clip_rect_t rect2 )
{
   if (rect2.x1 > rect1.x1) rect1.x1 = rect2.x1;
   if (rect2.x2 < rect1.x2) rect1.x2 = rect2.x2;
   if (rect2.y1 > rect1.y1) rect1.y1 = rect2.y1;
   if (rect2.y2 < rect1.y2) rect1.y2 = rect2.y2;

   if (rect1.x1 > rect1.x2 || rect1.y1 > rect1.y2) return 0;

   return (rect1.x2 - rect1.x1) * (rect1.y2 - rect1.y1);
}

@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d34 2
a35 3
#include "main/mtypes.h"
#include "main/cpuinfo.h"
#include "main/extensions.h"
d37 1
d39 1
d41 3
a43 21
/**
 * Print message to \c stderr if the \c LIBGL_DEBUG environment variable
 * is set. 
 * 
 * Is called from the drivers.
 * 
 * \param f \c printf like format string.
 */
void
__driUtilMessage(const char *f, ...)
{
    va_list args;

    if (getenv("LIBGL_DEBUG")) {
        fprintf(stderr, "libGL: ");
        va_start(args, f);
        vfprintf(stderr, f, args);
        va_end(args);
        fprintf(stderr, "\n");
    }
}
d45 3
d96 6
a101 2
   unsigned offset;
   char *cpu;
d121 53
a173 4
   cpu = _mesa_get_cpu_string();
   if (cpu) {
      offset += sprintf(buffer + offset, " %s", cpu);
      free(cpu);
a181 2
#define need_GL_ARB_copy_buffer
#define need_GL_ARB_draw_buffers
a182 1
#define need_GL_ARB_texture_compression
a183 1
#define need_GL_ARB_vertex_buffer_object
a185 1
#define need_GL_EXT_multi_draw_arrays
a188 1
#define need_GL_IBM_multimode_draw_arrays
d198 1
a198 1
#include "main/remap_helper.h"
a200 2
   { "GL_ARB_copy_buffer",           GL_ARB_copy_buffer_functions },
   { "GL_ARB_draw_buffers",          GL_ARB_draw_buffers_functions },
a201 1
   { "GL_ARB_texture_compression",   GL_ARB_texture_compression_functions },
a202 1
   { "GL_ARB_vertex_buffer_object",  GL_ARB_vertex_buffer_object_functions},
a205 1
   { "GL_EXT_multi_draw_arrays",     GL_EXT_multi_draw_arrays_functions },
a208 1
   { "GL_IBM_multimode_draw_arrays", GL_IBM_multimode_draw_arrays_functions },
d216 1
a216 1
 * Enable and map extensions supported by the driver.
a217 4
 * When ctx is NULL, extensions are not enabled, but their functions
 * are still mapped.  When extensions_to_enable is NULL, all static
 * functions known to mesa core are mapped.
 *
d224 1
a224 1
void driInitExtensions( struct gl_context * ctx,
d232 4
d237 1
a237 1
      driInitExtensions( NULL, all_mesa_extensions, GL_FALSE );
a243 9
   /* The caller is too lazy to list any extension */
   if ( extensions_to_enable == NULL ) {
      /* Map the static functions.  Together with those mapped by remap
       * table, this should cover everything mesa core knows.
       */
      _mesa_map_static_functions();
      return;
   }

d253 1
a253 1
 * Enable and map functions for a single extension
d258 5
a262 1
 * \sa driInitExtensions, _mesa_enable_extension, _mesa_map_function_array
d264 1
a264 1
void driInitSingleExtension( struct gl_context * ctx,
d267 3
d271 54
a324 1
       _mesa_map_function_array(ext->functions);
d336 3
d350 1
a350 1
 * \sa __driCreateNewScreen, driCheckDriDdxDrmVersions2
d381 2
a382 1
   if ( (ddxActual->major < ddxExpected->major_min)
d384 1
a384 1
	|| (ddxActual->minor < ddxExpected->minor) ) {
d422 16
a437 1
GLboolean driClipRectToFramebuffer( const struct gl_framebuffer *buffer,
d470 2
d473 1
a473 1
 * Creates a set of \c struct gl_config that a driver will expose.
d475 1
a475 1
 * A set of \c struct gl_config will be created based on the supplied
d480 1
a480 1
 * \c db_modes, and \c visType into each \c struct gl_config element.
d493 1
a493 1
 * \c struct gl_config structure is \b identical to the \c GL_RGBA or
d501 1
a501 1
 *                      \c struct gl_config.  Upon completion, a pointer to
a523 3
 * \param msaa_samples  Array of msaa sample count. 0 represents a visual
 *                      without a multisample buffer.
 * \param num_msaa_modes Number of entries in \c msaa_samples.
d539 7
a545 7
__DRIconfig **
driCreateConfigs(GLenum fb_format, GLenum fb_type,
		 const uint8_t * depth_bits, const uint8_t * stencil_bits,
		 unsigned num_depth_stencil_bits,
		 const GLenum * db_modes, unsigned num_db_modes,
		 const uint8_t * msaa_samples, unsigned num_msaa_modes,
		 GLboolean enable_accum)
d547 1
a547 1
   static const uint8_t bits_table[4][4] = {
a548 1
      { 3, 3, 2, 0 }, /* Any GL_UNSIGNED_BYTE_3_3_2 */
d554 8
a561 3
   static const uint32_t masks_table_rgb[6][4] = {
      { 0x000000E0, 0x0000001C, 0x00000003, 0x00000000 }, /* 3_3_2       */
      { 0x00000007, 0x00000038, 0x000000C0, 0x00000000 }, /* 2_3_3_REV   */
d565 1
d569 4
a572 3
   static const uint32_t masks_table_rgba[6][4] = {
      { 0x000000E0, 0x0000001C, 0x00000003, 0x00000000 }, /* 3_3_2       */
      { 0x00000007, 0x00000038, 0x000000C0, 0x00000000 }, /* 2_3_3_REV   */
d576 1
d580 4
a583 3
   static const uint32_t masks_table_bgr[6][4] = {
      { 0x00000007, 0x00000038, 0x000000C0, 0x00000000 }, /* 3_3_2       */
      { 0x000000E0, 0x0000001C, 0x00000003, 0x00000000 }, /* 2_3_3_REV   */
d587 1
d591 4
a594 3
   static const uint32_t masks_table_bgra[6][4] = {
      { 0x00000007, 0x00000038, 0x000000C0, 0x00000000 }, /* 3_3_2       */
      { 0x000000E0, 0x0000001C, 0x00000003, 0x00000000 }, /* 2_3_3_REV   */
d598 1
d602 2
a603 7
   static const uint8_t bytes_per_pixel[6] = {
      1, /* 3_3_2       */
      1, /* 2_3_3_REV   */
      2, /* 5_6_5       */
      2, /* 5_6_5_REV   */
      4, /* 8_8_8_8     */
      4  /* 8_8_8_8_REV */
d606 13
a618 32
   const uint8_t  * bits;
   const uint32_t * masks;
   int index;
   __DRIconfig **configs, **c;
   struct gl_config *modes;
   unsigned i, j, k, h;
   unsigned num_modes;
   unsigned num_accum_bits = (enable_accum) ? 2 : 1;

   switch ( fb_type ) {
      case GL_UNSIGNED_BYTE_3_3_2:
	 index = 0;
	 break;
      case GL_UNSIGNED_BYTE_2_3_3_REV:
	 index = 1;
	 break;
      case GL_UNSIGNED_SHORT_5_6_5:
	 index = 2;
	 break;
      case GL_UNSIGNED_SHORT_5_6_5_REV:
	 index = 3;
	 break;
      case GL_UNSIGNED_INT_8_8_8_8:
	 index = 4;
	 break;
      case GL_UNSIGNED_INT_8_8_8_8_REV:
	 index = 5;
	 break;
      default:
	 fprintf( stderr, "[%s:%u] Unknown framebuffer type 0x%04x.\n",
               __FUNCTION__, __LINE__, fb_type );
	 return NULL;
d630 2
d636 2
d642 2
d648 2
d654 3
a656 17
         fprintf( stderr, "[%s:%u] Unknown framebuffer format 0x%04x.\n",
               __FUNCTION__, __LINE__, fb_format );
         return NULL;
   }

   switch ( bytes_per_pixel[ index ] ) {
      case 1:
	 bits = bits_table[0];
	 break;
      case 2:
	 bits = bits_table[1];
	 break;
      default:
	 bits = ((fb_format == GL_RGB) || (fb_format == GL_BGR))
	    ? bits_table[2]
	    : bits_table[3];
	 break;
a658 4
   num_modes = num_depth_stencil_bits * num_db_modes * num_accum_bits * num_msaa_modes;
   configs = calloc(1, (num_modes + 1) * sizeof *configs);
   if (configs == NULL)
       return NULL;
a659 1
    c = configs;
d662 1
a662 42
	    for ( h = 0 ; h < num_msaa_modes; h++ ) {
	    	for ( j = 0 ; j < num_accum_bits ; j++ ) {
		    *c = malloc (sizeof **c);
		    modes = &(*c)->modes;
		    c++;

		    memset(modes, 0, sizeof *modes);
		    modes->redBits   = bits[0];
		    modes->greenBits = bits[1];
		    modes->blueBits  = bits[2];
		    modes->alphaBits = bits[3];
		    modes->redMask   = masks[0];
		    modes->greenMask = masks[1];
		    modes->blueMask  = masks[2];
		    modes->alphaMask = masks[3];
		    modes->rgbBits   = modes->redBits + modes->greenBits
		    	+ modes->blueBits + modes->alphaBits;

		    modes->accumRedBits   = 16 * j;
		    modes->accumGreenBits = 16 * j;
		    modes->accumBlueBits  = 16 * j;
		    modes->accumAlphaBits = (masks[3] != 0) ? 16 * j : 0;
		    modes->visualRating = (j == 0) ? GLX_NONE : GLX_SLOW_CONFIG;

		    modes->stencilBits = stencil_bits[k];
		    modes->depthBits = depth_bits[k];

		    modes->transparentPixel = GLX_NONE;
		    modes->transparentRed = GLX_DONT_CARE;
		    modes->transparentGreen = GLX_DONT_CARE;
		    modes->transparentBlue = GLX_DONT_CARE;
		    modes->transparentAlpha = GLX_DONT_CARE;
		    modes->transparentIndex = GLX_DONT_CARE;
		    modes->rgbMode = GL_TRUE;

		    if ( db_modes[i] == GLX_NONE ) {
		    	modes->doubleBufferMode = GL_FALSE;
		    }
		    else {
		    	modes->doubleBufferMode = GL_TRUE;
		    	modes->swapMethod = db_modes[i];
		    }
d664 24
a687 2
		    modes->samples = msaa_samples[h];
		    modes->sampleBuffers = modes->samples ? 1 : 0;
d689 7
d697 1
a697 1
		    modes->haveAccumBuffer = ((modes->accumRedBits +
d701 2
a702 2
		    modes->haveDepthBuffer = (modes->depthBits > 0);
		    modes->haveStencilBuffer = (modes->stencilBits > 0);
d704 1
a704 8
		    modes->bindToTextureRgb = GL_TRUE;
		    modes->bindToTextureRgba = GL_TRUE;
		    modes->bindToMipmapTexture = GL_FALSE;
		    modes->bindToTextureTargets =
			__DRI_ATTRIB_TEXTURE_1D_BIT |
			__DRI_ATTRIB_TEXTURE_2D_BIT |
			__DRI_ATTRIB_TEXTURE_RECTANGLE_BIT;
		}
a707 124
    *c = NULL;

    return configs;
}

__DRIconfig **driConcatConfigs(__DRIconfig **a,
			       __DRIconfig **b)
{
    __DRIconfig **all;
    int i, j, index;

    i = 0;
    while (a[i] != NULL)
	i++;
    j = 0;
    while (b[j] != NULL)
	j++;
   
    all = malloc((i + j + 1) * sizeof *all);
    index = 0;
    for (i = 0; a[i] != NULL; i++)
	all[index++] = a[i];
    for (j = 0; b[j] != NULL; j++)
	all[index++] = b[j];
    all[index++] = NULL;

    free(a);
    free(b);

    return all;
}

#define __ATTRIB(attrib, field) \
    { attrib, offsetof(struct gl_config, field) }

static const struct { unsigned int attrib, offset; } attribMap[] = {
    __ATTRIB(__DRI_ATTRIB_BUFFER_SIZE,			rgbBits),
    __ATTRIB(__DRI_ATTRIB_LEVEL,			level),
    __ATTRIB(__DRI_ATTRIB_RED_SIZE,			redBits),
    __ATTRIB(__DRI_ATTRIB_GREEN_SIZE,			greenBits),
    __ATTRIB(__DRI_ATTRIB_BLUE_SIZE,			blueBits),
    __ATTRIB(__DRI_ATTRIB_ALPHA_SIZE,			alphaBits),
    __ATTRIB(__DRI_ATTRIB_DEPTH_SIZE,			depthBits),
    __ATTRIB(__DRI_ATTRIB_STENCIL_SIZE,			stencilBits),
    __ATTRIB(__DRI_ATTRIB_ACCUM_RED_SIZE,		accumRedBits),
    __ATTRIB(__DRI_ATTRIB_ACCUM_GREEN_SIZE,		accumGreenBits),
    __ATTRIB(__DRI_ATTRIB_ACCUM_BLUE_SIZE,		accumBlueBits),
    __ATTRIB(__DRI_ATTRIB_ACCUM_ALPHA_SIZE,		accumAlphaBits),
    __ATTRIB(__DRI_ATTRIB_SAMPLE_BUFFERS,		sampleBuffers),
    __ATTRIB(__DRI_ATTRIB_SAMPLES,			samples),
    __ATTRIB(__DRI_ATTRIB_DOUBLE_BUFFER,		doubleBufferMode),
    __ATTRIB(__DRI_ATTRIB_STEREO,			stereoMode),
    __ATTRIB(__DRI_ATTRIB_AUX_BUFFERS,			numAuxBuffers),
    __ATTRIB(__DRI_ATTRIB_TRANSPARENT_TYPE,		transparentPixel),
    __ATTRIB(__DRI_ATTRIB_TRANSPARENT_INDEX_VALUE,	transparentPixel),
    __ATTRIB(__DRI_ATTRIB_TRANSPARENT_RED_VALUE,	transparentRed),
    __ATTRIB(__DRI_ATTRIB_TRANSPARENT_GREEN_VALUE,	transparentGreen),
    __ATTRIB(__DRI_ATTRIB_TRANSPARENT_BLUE_VALUE,	transparentBlue),
    __ATTRIB(__DRI_ATTRIB_TRANSPARENT_ALPHA_VALUE,	transparentAlpha),
    __ATTRIB(__DRI_ATTRIB_FLOAT_MODE,			floatMode),
    __ATTRIB(__DRI_ATTRIB_RED_MASK,			redMask),
    __ATTRIB(__DRI_ATTRIB_GREEN_MASK,			greenMask),
    __ATTRIB(__DRI_ATTRIB_BLUE_MASK,			blueMask),
    __ATTRIB(__DRI_ATTRIB_ALPHA_MASK,			alphaMask),
    __ATTRIB(__DRI_ATTRIB_MAX_PBUFFER_WIDTH,		maxPbufferWidth),
    __ATTRIB(__DRI_ATTRIB_MAX_PBUFFER_HEIGHT,		maxPbufferHeight),
    __ATTRIB(__DRI_ATTRIB_MAX_PBUFFER_PIXELS,		maxPbufferPixels),
    __ATTRIB(__DRI_ATTRIB_OPTIMAL_PBUFFER_WIDTH,	optimalPbufferWidth),
    __ATTRIB(__DRI_ATTRIB_OPTIMAL_PBUFFER_HEIGHT,	optimalPbufferHeight),
    __ATTRIB(__DRI_ATTRIB_SWAP_METHOD,			swapMethod),
    __ATTRIB(__DRI_ATTRIB_BIND_TO_TEXTURE_RGB,		bindToTextureRgb),
    __ATTRIB(__DRI_ATTRIB_BIND_TO_TEXTURE_RGBA,		bindToTextureRgba),
    __ATTRIB(__DRI_ATTRIB_BIND_TO_MIPMAP_TEXTURE,	bindToMipmapTexture),
    __ATTRIB(__DRI_ATTRIB_BIND_TO_TEXTURE_TARGETS,	bindToTextureTargets),
    __ATTRIB(__DRI_ATTRIB_YINVERTED,			yInverted),

    /* The struct field doesn't matter here, these are handled by the
     * switch in driGetConfigAttribIndex.  We need them in the array
     * so the iterator includes them though.*/
    __ATTRIB(__DRI_ATTRIB_RENDER_TYPE,			level),
    __ATTRIB(__DRI_ATTRIB_CONFIG_CAVEAT,		level),
    __ATTRIB(__DRI_ATTRIB_SWAP_METHOD,			level)
};

#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))


/**
 * Return the value of a configuration attribute.  The attribute is
 * indicated by the index.
 */
static int
driGetConfigAttribIndex(const __DRIconfig *config,
			unsigned int index, unsigned int *value)
{
    switch (attribMap[index].attrib) {
    case __DRI_ATTRIB_RENDER_TYPE:
        /* no support for color index mode */
	*value = __DRI_ATTRIB_RGBA_BIT;
	break;
    case __DRI_ATTRIB_CONFIG_CAVEAT:
	if (config->modes.visualRating == GLX_NON_CONFORMANT_CONFIG)
	    *value = __DRI_ATTRIB_NON_CONFORMANT_CONFIG;
	else if (config->modes.visualRating == GLX_SLOW_CONFIG)
	    *value = __DRI_ATTRIB_SLOW_BIT;
	else
	    *value = 0;
	break;
    case __DRI_ATTRIB_SWAP_METHOD:
        /* XXX no return value??? */
	break;

    case __DRI_ATTRIB_FLOAT_MODE:
        /* this field is not int-sized */
        *value = config->modes.floatMode;
        break;

    default:
        /* any other int-sized field */
	*value = *(unsigned int *)
	    ((char *) &config->modes + attribMap[index].offset);
	
	break;
    }
d709 1
a710 40
}


/**
 * Get the value of a configuration attribute.
 * \param attrib  the attribute (one of the _DRI_ATTRIB_x tokens)
 * \param value  returns the attribute's value
 * \return 1 for success, 0 for failure
 */
int
driGetConfigAttrib(const __DRIconfig *config,
		   unsigned int attrib, unsigned int *value)
{
    int i;

    for (i = 0; i < ARRAY_SIZE(attribMap); i++)
	if (attribMap[i].attrib == attrib)
	    return driGetConfigAttribIndex(config, i, value);

    return GL_FALSE;
}


/**
 * Get a configuration attribute name and value, given an index.
 * \param index  which field of the __DRIconfig to query
 * \param attrib  returns the attribute name (one of the _DRI_ATTRIB_x tokens)
 * \param value  returns the attribute's value
 * \return 1 for success, 0 for failure
 */
int
driIndexConfigAttrib(const __DRIconfig *config, int index,
		     unsigned int *attrib, unsigned int *value)
{
    if (index >= 0 && index < ARRAY_SIZE(attribMap)) {
	*attrib = attribMap[index].attrib;
	return driGetConfigAttribIndex(config, index, value);
    }

    return GL_FALSE;
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@a33 2
#include <stdbool.h>
#include "main/macros.h"
d40 23
d99 1
d108 1
a108 1
		      GLuint agp_mode )
d113 1
a113 1
   offset = sprintf( buffer, "Mesa DRI %s", hardware_name );
d141 232
d407 7
a413 1
 * \param format        Mesa gl_format enum describing the pixel format
d432 10
a441 4
 * Pointer to any array of pointers to the \c __DRIconfig structures created
 * for the specified formats.  If there is an error, \c NULL is returned.
 * Currently the only cause of failure is a bad parameter (i.e., unsupported
 * \c format).
d444 1
a444 1
driCreateConfigs(gl_format format,
d451 6
a456 7
   static const uint32_t masks_table[][4] = {
      /* MESA_FORMAT_RGB565 */
      { 0x0000F800, 0x000007E0, 0x0000001F, 0x00000000 },
      /* MESA_FORMAT_XRGB8888 */
      { 0x00FF0000, 0x0000FF00, 0x000000FF, 0x00000000 },
      /* MESA_FORMAT_ARGB8888 */
      { 0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000 },
d459 46
d506 1
d512 54
a565 22
   int red_bits;
   int green_bits;
   int blue_bits;
   int alpha_bits;
   bool is_srgb;

   switch (format) {
   case MESA_FORMAT_RGB565:
      masks = masks_table[0];
      break;
   case MESA_FORMAT_XRGB8888:
      masks = masks_table[1];
      break;
   case MESA_FORMAT_ARGB8888:
   case MESA_FORMAT_SARGB8:
      masks = masks_table[2];
      break;
   default:
      fprintf(stderr, "[%s:%u] Unknown framebuffer type %s (%d).\n",
              __FUNCTION__, __LINE__,
              _mesa_get_format_name(format), format);
      return NULL;
d568 13
a580 5
   red_bits = _mesa_get_format_bits(format, GL_RED_BITS);
   green_bits = _mesa_get_format_bits(format, GL_GREEN_BITS);
   blue_bits = _mesa_get_format_bits(format, GL_BLUE_BITS);
   alpha_bits = _mesa_get_format_bits(format, GL_ALPHA_BITS);
   is_srgb = _mesa_get_format_color_encoding(format) == GL_SRGB;
d597 4
a600 4
		    modes->redBits   = red_bits;
		    modes->greenBits = green_bits;
		    modes->blueBits  = blue_bits;
		    modes->alphaBits = alpha_bits;
a650 2

		    modes->sRGBCapable = is_srgb;
a665 5
    if (a == NULL || a[0] == NULL)
       return b;
    else if (b == NULL || b[0] == NULL)
       return a;

d714 1
a729 1
    __ATTRIB(__DRI_ATTRIB_FRAMEBUFFER_SRGB_CAPABLE,	sRGBCapable),
d739 2
d766 5
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@a34 1
#include <stdint.h>
a39 1
#include "dri_util.h"
d42 1
a42 1
uint64_t
d46 2
a47 1
   uint64_t flag = 0;
d49 1
d153 1
a153 1
 * \param format        Mesa mesa_format enum describing the pixel format
d178 1
a178 1
driCreateConfigs(mesa_format format,
d186 1
a186 1
      /* MESA_FORMAT_B5G6R5_UNORM */
d188 1
a188 1
      /* MESA_FORMAT_B8G8R8X8_UNORM */
d190 1
a190 1
      /* MESA_FORMAT_B8G8R8A8_UNORM */
a191 4
      /* MESA_FORMAT_B10G10R10X2_UNORM */
      { 0x3FF00000, 0x000FFC00, 0x000003FF, 0x00000000 },
      /* MESA_FORMAT_B10G10R10A2_UNORM */
      { 0x3FF00000, 0x000FFC00, 0x000003FF, 0xC0000000 },
d207 1
a207 1
   case MESA_FORMAT_B5G6R5_UNORM:
d210 1
a210 1
   case MESA_FORMAT_B8G8R8X8_UNORM:
d213 2
a214 2
   case MESA_FORMAT_B8G8R8A8_UNORM:
   case MESA_FORMAT_B8G8R8A8_SRGB:
a216 6
   case MESA_FORMAT_B10G10R10X2_UNORM:
      masks = masks_table[3];
      break;
   case MESA_FORMAT_B10G10R10A2_UNORM:
      masks = masks_table[4];
      break;
a299 1
		    modes->yInverted = GL_TRUE;
a468 63
}

/**
 * Implement queries for values that are common across all Mesa drivers
 *
 * Currently only the following queries are supported by this function:
 *
 *     - \c __DRI2_RENDERER_VERSION
 *     - \c __DRI2_RENDERER_OPENGL_CORE_PROFILE_VERSION
 *     - \c __DRI2_RENDERER_OPENGL_COMPATIBLITY_PROFILE_VERSION
 *     - \c __DRI2_RENDERER_ES_PROFILE_VERSION
 *     - \c __DRI2_RENDERER_ES2_PROFILE_VERSION
 *
 * \returns
 * Zero if a recognized value of \c param is supplied, -1 otherwise.
 */
int
driQueryRendererIntegerCommon(__DRIscreen *psp, int param, unsigned int *value)
{
   switch (param) {
   case __DRI2_RENDERER_VERSION: {
      static const char *const ver = PACKAGE_VERSION;
      char *endptr;
      int v[3];

      v[0] = strtol(ver, &endptr, 10);
      assert(endptr[0] == '.');
      if (endptr[0] != '.')
         return -1;

      v[1] = strtol(endptr + 1, &endptr, 10);
      assert(endptr[0] == '.');
      if (endptr[0] != '.')
         return -1;

      v[2] = strtol(endptr + 1, &endptr, 10);

      value[0] = v[0];
      value[1] = v[1];
      value[2] = v[2];
      return 0;
   }
   case __DRI2_RENDERER_OPENGL_CORE_PROFILE_VERSION:
      value[0] = psp->max_gl_core_version / 10;
      value[1] = psp->max_gl_core_version % 10;
      return 0;
   case __DRI2_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION:
      value[0] = psp->max_gl_compat_version / 10;
      value[1] = psp->max_gl_compat_version % 10;
      return 0;
   case __DRI2_RENDERER_OPENGL_ES_PROFILE_VERSION:
      value[0] = psp->max_gl_es1_version / 10;
      value[1] = psp->max_gl_es1_version % 10;
      return 0;
   case __DRI2_RENDERER_OPENGL_ES2_PROFILE_VERSION:
      value[0] = psp->max_gl_es2_version / 10;
      value[1] = psp->max_gl_es2_version % 10;
      return 0;
   default:
      break;
   }

   return -1;
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@d241 1
a241 1
   configs = calloc(num_modes + 1, sizeof *configs);
a521 4
   case __DRI2_RENDERER_PREFERRED_PROFILE:
      value[0] = (psp->max_gl_core_version != 0)
         ? (1U << __DRI_API_OPENGL_CORE) : (1U << __DRI_API_OPENGL);
      return 0;
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d241 1
a241 1
   configs = calloc(1, (num_modes + 1) * sizeof *configs);
d522 4
@


