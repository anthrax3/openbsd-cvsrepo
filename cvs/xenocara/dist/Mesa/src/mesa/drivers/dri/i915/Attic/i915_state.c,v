head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.04.13;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.34;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.09;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.28.13;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.15.21;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.47;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.11.23;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.48.30;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/


#include "main/glheader.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/enums.h"
#include "main/fbobject.h"
#include "main/dd.h"
#include "main/state.h"
#include "main/stencil.h"
#include "tnl/tnl.h"
#include "tnl/t_context.h"

#include "drivers/common/driverfuncs.h"

#include "intel_fbo.h"
#include "intel_screen.h"
#include "intel_batchbuffer.h"
#include "intel_buffers.h"

#include "i915_context.h"
#include "i915_reg.h"

#define FILE_DEBUG_FLAG DEBUG_STATE

void
i915_update_stencil(struct gl_context * ctx)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   GLuint front_ref, front_writemask, front_mask;
   GLenum front_func, front_fail, front_pass_z_fail, front_pass_z_pass;
   GLuint back_ref, back_writemask, back_mask;
   GLenum back_func, back_fail, back_pass_z_fail, back_pass_z_pass;
   GLuint dirty = 0;

   /* The 915 considers CW to be "front" for two-sided stencil, so choose
    * appropriately.
    */
   /* _NEW_POLYGON | _NEW_STENCIL */
   if (ctx->Polygon.FrontFace == GL_CW) {
      front_ref = _mesa_get_stencil_ref(ctx, 0);
      front_mask = ctx->Stencil.ValueMask[0];
      front_writemask = ctx->Stencil.WriteMask[0];
      front_func = ctx->Stencil.Function[0];
      front_fail = ctx->Stencil.FailFunc[0];
      front_pass_z_fail = ctx->Stencil.ZFailFunc[0];
      front_pass_z_pass = ctx->Stencil.ZPassFunc[0];
      back_ref = _mesa_get_stencil_ref(ctx, ctx->Stencil._BackFace);
      back_mask = ctx->Stencil.ValueMask[ctx->Stencil._BackFace];
      back_writemask = ctx->Stencil.WriteMask[ctx->Stencil._BackFace];
      back_func = ctx->Stencil.Function[ctx->Stencil._BackFace];
      back_fail = ctx->Stencil.FailFunc[ctx->Stencil._BackFace];
      back_pass_z_fail = ctx->Stencil.ZFailFunc[ctx->Stencil._BackFace];
      back_pass_z_pass = ctx->Stencil.ZPassFunc[ctx->Stencil._BackFace];
   } else {
      front_ref = _mesa_get_stencil_ref(ctx, ctx->Stencil._BackFace);
      front_mask = ctx->Stencil.ValueMask[ctx->Stencil._BackFace];
      front_writemask = ctx->Stencil.WriteMask[ctx->Stencil._BackFace];
      front_func = ctx->Stencil.Function[ctx->Stencil._BackFace];
      front_fail = ctx->Stencil.FailFunc[ctx->Stencil._BackFace];
      front_pass_z_fail = ctx->Stencil.ZFailFunc[ctx->Stencil._BackFace];
      front_pass_z_pass = ctx->Stencil.ZPassFunc[ctx->Stencil._BackFace];
      back_ref = _mesa_get_stencil_ref(ctx, 0);
      back_mask = ctx->Stencil.ValueMask[0];
      back_writemask = ctx->Stencil.WriteMask[0];
      back_func = ctx->Stencil.Function[0];
      back_fail = ctx->Stencil.FailFunc[0];
      back_pass_z_fail = ctx->Stencil.ZFailFunc[0];
      back_pass_z_pass = ctx->Stencil.ZPassFunc[0];
   }
#define set_ctx_bits(reg, mask, set) do{ \
   GLuint dw = i915->state.Ctx[reg]; \
   dw &= ~(mask); \
   dw |= (set); \
   dirty |= dw != i915->state.Ctx[reg]; \
   i915->state.Ctx[reg] = dw; \
} while(0)

   /* Set front state. */
   set_ctx_bits(I915_CTXREG_STATE4,
                MODE4_ENABLE_STENCIL_TEST_MASK |
                MODE4_ENABLE_STENCIL_WRITE_MASK,
                ENABLE_STENCIL_TEST_MASK |
                ENABLE_STENCIL_WRITE_MASK |
                STENCIL_TEST_MASK(front_mask) |
                STENCIL_WRITE_MASK(front_writemask));

   set_ctx_bits(I915_CTXREG_LIS5,
                S5_STENCIL_REF_MASK |
                S5_STENCIL_TEST_FUNC_MASK |
                S5_STENCIL_FAIL_MASK |
                S5_STENCIL_PASS_Z_FAIL_MASK |
                S5_STENCIL_PASS_Z_PASS_MASK,
                (front_ref << S5_STENCIL_REF_SHIFT) |
                (intel_translate_compare_func(front_func) << S5_STENCIL_TEST_FUNC_SHIFT) |
                (intel_translate_stencil_op(front_fail) << S5_STENCIL_FAIL_SHIFT) |
                (intel_translate_stencil_op(front_pass_z_fail) <<
                 S5_STENCIL_PASS_Z_FAIL_SHIFT) |
                (intel_translate_stencil_op(front_pass_z_pass) <<
                 S5_STENCIL_PASS_Z_PASS_SHIFT));

   /* Set back state if different from front. */
   if (ctx->Stencil._TestTwoSide) {
      set_ctx_bits(I915_CTXREG_BF_STENCIL_OPS,
                   BFO_STENCIL_REF_MASK |
                   BFO_STENCIL_TEST_MASK |
                   BFO_STENCIL_FAIL_MASK |
                   BFO_STENCIL_PASS_Z_FAIL_MASK |
                   BFO_STENCIL_PASS_Z_PASS_MASK,
                   BFO_STENCIL_TWO_SIDE |
                   (back_ref << BFO_STENCIL_REF_SHIFT) |
                   (intel_translate_compare_func(back_func) << BFO_STENCIL_TEST_SHIFT) |
                   (intel_translate_stencil_op(back_fail) << BFO_STENCIL_FAIL_SHIFT) |
                   (intel_translate_stencil_op(back_pass_z_fail) <<
                    BFO_STENCIL_PASS_Z_FAIL_SHIFT) |
                   (intel_translate_stencil_op(back_pass_z_pass) <<
                    BFO_STENCIL_PASS_Z_PASS_SHIFT));

      set_ctx_bits(I915_CTXREG_BF_STENCIL_MASKS,
                   BFM_STENCIL_TEST_MASK_MASK |
                   BFM_STENCIL_WRITE_MASK_MASK,
                   BFM_STENCIL_TEST_MASK(back_mask) |
                   BFM_STENCIL_WRITE_MASK(back_writemask));
   } else {
      set_ctx_bits(I915_CTXREG_BF_STENCIL_OPS,
                   BFO_STENCIL_TWO_SIDE, 0);
   }

#undef set_ctx_bits

   if (dirty)
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
}

static void
i915StencilFuncSeparate(struct gl_context * ctx, GLenum face, GLenum func, GLint ref,
                        GLuint mask)
{
}

static void
i915StencilMaskSeparate(struct gl_context * ctx, GLenum face, GLuint mask)
{
}

static void
i915StencilOpSeparate(struct gl_context * ctx, GLenum face, GLenum fail, GLenum zfail,
                      GLenum zpass)
{
}

static void
i915AlphaFunc(struct gl_context * ctx, GLenum func, GLfloat ref)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   int test = intel_translate_compare_func(func);
   GLubyte refByte;
   GLuint dw;

   UNCLAMPED_FLOAT_TO_UBYTE(refByte, ref);

   dw = i915->state.Ctx[I915_CTXREG_LIS6];
   dw &= ~(S6_ALPHA_TEST_FUNC_MASK | S6_ALPHA_REF_MASK);
   dw |= ((test << S6_ALPHA_TEST_FUNC_SHIFT) |
	  (((GLuint) refByte) << S6_ALPHA_REF_SHIFT));
   if (dw != i915->state.Ctx[I915_CTXREG_LIS6]) {
      i915->state.Ctx[I915_CTXREG_LIS6] = dw;
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   }
}

/* This function makes sure that the proper enables are
 * set for LogicOp, Independant Alpha Blend, and Blending.
 * It needs to be called from numerous places where we
 * could change the LogicOp or Independant Alpha Blend without subsequent
 * calls to glEnable.
 */
static void
i915EvalLogicOpBlendState(struct gl_context * ctx)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   GLuint dw0, dw1;

   dw0 = i915->state.Ctx[I915_CTXREG_LIS5];
   dw1 = i915->state.Ctx[I915_CTXREG_LIS6];

   if (ctx->Color.ColorLogicOpEnabled) {
      dw0 |= S5_LOGICOP_ENABLE;
      dw1 &= ~S6_CBUF_BLEND_ENABLE;
   }
   else {
      dw0 &= ~S5_LOGICOP_ENABLE;

      if (ctx->Color.BlendEnabled) {
         dw1 |= S6_CBUF_BLEND_ENABLE;
      }
      else {
         dw1 &= ~S6_CBUF_BLEND_ENABLE;
      }
   }
   if (dw0 != i915->state.Ctx[I915_CTXREG_LIS5] ||
       dw1 != i915->state.Ctx[I915_CTXREG_LIS6]) {
      i915->state.Ctx[I915_CTXREG_LIS5] = dw0;
      i915->state.Ctx[I915_CTXREG_LIS6] = dw1;

      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   }
}

static void
i915BlendColor(struct gl_context * ctx, const GLfloat color[4])
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   GLubyte r, g, b, a;
   GLuint dw;

   DBG("%s\n", __FUNCTION__);
   
   UNCLAMPED_FLOAT_TO_UBYTE(r, color[RCOMP]);
   UNCLAMPED_FLOAT_TO_UBYTE(g, color[GCOMP]);
   UNCLAMPED_FLOAT_TO_UBYTE(b, color[BCOMP]);
   UNCLAMPED_FLOAT_TO_UBYTE(a, color[ACOMP]);

   dw = (a << 24) | (r << 16) | (g << 8) | b;
   if (dw != i915->state.Blend[I915_BLENDREG_BLENDCOLOR1]) {
      i915->state.Blend[I915_BLENDREG_BLENDCOLOR1] = dw;
      I915_STATECHANGE(i915, I915_UPLOAD_BLEND);
   }
}


#define DST_BLND_FACT(f) ((f)<<S6_CBUF_DST_BLEND_FACT_SHIFT)
#define SRC_BLND_FACT(f) ((f)<<S6_CBUF_SRC_BLEND_FACT_SHIFT)
#define DST_ABLND_FACT(f) ((f)<<IAB_DST_FACTOR_SHIFT)
#define SRC_ABLND_FACT(f) ((f)<<IAB_SRC_FACTOR_SHIFT)



static GLuint
translate_blend_equation(GLenum mode)
{
   switch (mode) {
   case GL_FUNC_ADD:
      return BLENDFUNC_ADD;
   case GL_MIN:
      return BLENDFUNC_MIN;
   case GL_MAX:
      return BLENDFUNC_MAX;
   case GL_FUNC_SUBTRACT:
      return BLENDFUNC_SUBTRACT;
   case GL_FUNC_REVERSE_SUBTRACT:
      return BLENDFUNC_REVERSE_SUBTRACT;
   default:
      return 0;
   }
}

static void
i915UpdateBlendState(struct gl_context * ctx)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   GLuint iab = (i915->state.Blend[I915_BLENDREG_IAB] &
                 ~(IAB_SRC_FACTOR_MASK |
                   IAB_DST_FACTOR_MASK |
                   (BLENDFUNC_MASK << IAB_FUNC_SHIFT) | IAB_ENABLE));

   GLuint lis6 = (i915->state.Ctx[I915_CTXREG_LIS6] &
                  ~(S6_CBUF_SRC_BLEND_FACT_MASK |
                    S6_CBUF_DST_BLEND_FACT_MASK | S6_CBUF_BLEND_FUNC_MASK));

   GLuint eqRGB = ctx->Color.Blend[0].EquationRGB;
   GLuint eqA = ctx->Color.Blend[0].EquationA;
   GLuint srcRGB = ctx->Color.Blend[0].SrcRGB;
   GLuint dstRGB = ctx->Color.Blend[0].DstRGB;
   GLuint srcA = ctx->Color.Blend[0].SrcA;
   GLuint dstA = ctx->Color.Blend[0].DstA;

   if (eqRGB == GL_MIN || eqRGB == GL_MAX) {
      srcRGB = dstRGB = GL_ONE;
   }

   if (eqA == GL_MIN || eqA == GL_MAX) {
      srcA = dstA = GL_ONE;
   }

   lis6 |= SRC_BLND_FACT(intel_translate_blend_factor(srcRGB));
   lis6 |= DST_BLND_FACT(intel_translate_blend_factor(dstRGB));
   lis6 |= translate_blend_equation(eqRGB) << S6_CBUF_BLEND_FUNC_SHIFT;

   iab |= SRC_ABLND_FACT(intel_translate_blend_factor(srcA));
   iab |= DST_ABLND_FACT(intel_translate_blend_factor(dstA));
   iab |= translate_blend_equation(eqA) << IAB_FUNC_SHIFT;

   if (srcA != srcRGB || dstA != dstRGB || eqA != eqRGB)
      iab |= IAB_ENABLE;

   if (iab != i915->state.Blend[I915_BLENDREG_IAB]) {
      i915->state.Blend[I915_BLENDREG_IAB] = iab;
      I915_STATECHANGE(i915, I915_UPLOAD_BLEND);
   }
   if (lis6 != i915->state.Ctx[I915_CTXREG_LIS6]) {
      i915->state.Ctx[I915_CTXREG_LIS6] = lis6;
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   }

   /* This will catch a logicop blend equation */
   i915EvalLogicOpBlendState(ctx);
}


static void
i915BlendFuncSeparate(struct gl_context * ctx, GLenum srcRGB,
                      GLenum dstRGB, GLenum srcA, GLenum dstA)
{
   i915UpdateBlendState(ctx);
}


static void
i915BlendEquationSeparate(struct gl_context * ctx, GLenum eqRGB, GLenum eqA)
{
   i915UpdateBlendState(ctx);
}


static void
i915DepthFunc(struct gl_context * ctx, GLenum func)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   int test = intel_translate_compare_func(func);
   GLuint dw;

   DBG("%s\n", __FUNCTION__);
   
   dw = i915->state.Ctx[I915_CTXREG_LIS6];
   dw &= ~S6_DEPTH_TEST_FUNC_MASK;
   dw |= test << S6_DEPTH_TEST_FUNC_SHIFT;
   if (dw != i915->state.Ctx[I915_CTXREG_LIS6]) {
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      i915->state.Ctx[I915_CTXREG_LIS6] = dw;
   }
}

static void
i915DepthMask(struct gl_context * ctx, GLboolean flag)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   GLuint dw;

   DBG("%s flag (%d)\n", __FUNCTION__, flag);

   if (!ctx->DrawBuffer || !ctx->DrawBuffer->Visual.depthBits)
      flag = false;

   dw = i915->state.Ctx[I915_CTXREG_LIS6];
   if (flag && ctx->Depth.Test)
      dw |= S6_DEPTH_WRITE_ENABLE;
   else
      dw &= ~S6_DEPTH_WRITE_ENABLE;
   if (dw != i915->state.Ctx[I915_CTXREG_LIS6]) {
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      i915->state.Ctx[I915_CTXREG_LIS6] = dw;
   }
}



/**
 * Update the viewport transformation matrix.  Depends on:
 *  - viewport pos/size
 *  - depthrange
 *  - window pos/size or FBO size
 */
void
intelCalcViewport(struct gl_context * ctx)
{
   struct intel_context *intel = intel_context(ctx);

   if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
      _math_matrix_viewport(&intel->ViewportMatrix,
			    ctx->ViewportArray[0].X,
			    ctx->DrawBuffer->Height - ctx->ViewportArray[0].Y,
			    ctx->ViewportArray[0].Width,
			    -ctx->ViewportArray[0].Height,
			    ctx->ViewportArray[0].Near,
			    ctx->ViewportArray[0].Far,
			    1.0);
   } else {
      _math_matrix_viewport(&intel->ViewportMatrix,
			    ctx->ViewportArray[0].X,
			    ctx->ViewportArray[0].Y,
			    ctx->ViewportArray[0].Width,
			    ctx->ViewportArray[0].Height,
			    ctx->ViewportArray[0].Near,
			    ctx->ViewportArray[0].Far,
			    1.0);
   }
}


/** Called from ctx->Driver.DepthRange() */
static void
i915DepthRange(struct gl_context *ctx)
{
   intelCalcViewport(ctx);
}


/* =============================================================
 * Polygon stipple
 *
 * The i915 supports a 4x4 stipple natively, GL wants 32x32.
 * Fortunately stipple is usually a repeating pattern.
 */
static void
i915PolygonStipple(struct gl_context * ctx, const GLubyte * mask)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   const GLubyte *m;
   GLubyte p[4];
   int i, j, k;
   int active = (ctx->Polygon.StippleFlag &&
                 i915->intel.reduced_primitive == GL_TRIANGLES);
   GLuint newMask;

   if (active) {
      I915_STATECHANGE(i915, I915_UPLOAD_STIPPLE);
      i915->state.Stipple[I915_STPREG_ST1] &= ~ST1_ENABLE;
   }

   /* Use the already unpacked stipple data from the context rather than the
    * uninterpreted mask passed in.
    */
   mask = (const GLubyte *)ctx->PolygonStipple;
   m = mask;

   p[0] = mask[12] & 0xf;
   p[0] |= p[0] << 4;
   p[1] = mask[8] & 0xf;
   p[1] |= p[1] << 4;
   p[2] = mask[4] & 0xf;
   p[2] |= p[2] << 4;
   p[3] = mask[0] & 0xf;
   p[3] |= p[3] << 4;

   for (k = 0; k < 8; k++)
      for (j = 3; j >= 0; j--)
         for (i = 0; i < 4; i++, m++)
            if (*m != p[j]) {
               i915->intel.hw_stipple = 0;
               return;
            }

   newMask = (((p[0] & 0xf) << 0) |
              ((p[1] & 0xf) << 4) |
              ((p[2] & 0xf) << 8) | ((p[3] & 0xf) << 12));


   if (newMask == 0xffff || newMask == 0x0) {
      /* this is needed to make conform pass */
      i915->intel.hw_stipple = 0;
      return;
   }

   i915->state.Stipple[I915_STPREG_ST1] &= ~0xffff;
   i915->state.Stipple[I915_STPREG_ST1] |= newMask;
   i915->intel.hw_stipple = 1;

   if (active)
      i915->state.Stipple[I915_STPREG_ST1] |= ST1_ENABLE;
}


/* =============================================================
 * Hardware clipping
 */
static void
i915Scissor(struct gl_context * ctx)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   int x1, y1, x2, y2;

   if (!ctx->DrawBuffer)
      return;

   DBG("%s %d,%d %dx%d\n", __FUNCTION__,
       ctx->Scissor.ScissorArray[0].X,     ctx->Scissor.ScissorArray[0].Y,
       ctx->Scissor.ScissorArray[0].Width, ctx->Scissor.ScissorArray[0].Height);

   if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
      x1 = ctx->Scissor.ScissorArray[0].X;
      y1 = ctx->DrawBuffer->Height - (ctx->Scissor.ScissorArray[0].Y
                                      + ctx->Scissor.ScissorArray[0].Height);
      x2 = ctx->Scissor.ScissorArray[0].X
         + ctx->Scissor.ScissorArray[0].Width - 1;
      y2 = y1 + ctx->Scissor.ScissorArray[0].Height - 1;
      DBG("%s %d..%d,%d..%d (inverted)\n", __FUNCTION__, x1, x2, y1, y2);
   }
   else {
      /* FBO - not inverted
       */
      x1 = ctx->Scissor.ScissorArray[0].X;
      y1 = ctx->Scissor.ScissorArray[0].Y;
      x2 = ctx->Scissor.ScissorArray[0].X
         + ctx->Scissor.ScissorArray[0].Width - 1;
      y2 = ctx->Scissor.ScissorArray[0].Y
         + ctx->Scissor.ScissorArray[0].Height - 1;
      DBG("%s %d..%d,%d..%d (not inverted)\n", __FUNCTION__, x1, x2, y1, y2);
   }
   
   x1 = CLAMP(x1, 0, ctx->DrawBuffer->Width - 1);
   y1 = CLAMP(y1, 0, ctx->DrawBuffer->Height - 1);
   x2 = CLAMP(x2, 0, ctx->DrawBuffer->Width - 1);
   y2 = CLAMP(y2, 0, ctx->DrawBuffer->Height - 1);
   
   DBG("%s %d..%d,%d..%d (clamped)\n", __FUNCTION__, x1, x2, y1, y2);

   I915_STATECHANGE(i915, I915_UPLOAD_BUFFERS);
   i915->state.Buffer[I915_DESTREG_SR1] = (y1 << 16) | (x1 & 0xffff);
   i915->state.Buffer[I915_DESTREG_SR2] = (y2 << 16) | (x2 & 0xffff);
}

static void
i915LogicOp(struct gl_context * ctx, GLenum opcode)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   int tmp = intel_translate_logic_op(opcode);

   DBG("%s\n", __FUNCTION__);
   
   I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   i915->state.Ctx[I915_CTXREG_STATE4] &= ~LOGICOP_MASK;
   i915->state.Ctx[I915_CTXREG_STATE4] |= LOGIC_OP_FUNC(tmp);
}



static void
i915CullFaceFrontFace(struct gl_context * ctx, GLenum unused)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   GLuint mode, dw;

   DBG("%s %d\n", __FUNCTION__,
       ctx->DrawBuffer ? ctx->DrawBuffer->Name : 0);

   if (!ctx->Polygon.CullFlag) {
      mode = S4_CULLMODE_NONE;
   }
   else if (ctx->Polygon.CullFaceMode != GL_FRONT_AND_BACK) {
      mode = S4_CULLMODE_CW;

      if (ctx->DrawBuffer && _mesa_is_user_fbo(ctx->DrawBuffer))
         mode ^= (S4_CULLMODE_CW ^ S4_CULLMODE_CCW);
      if (ctx->Polygon.CullFaceMode == GL_FRONT)
         mode ^= (S4_CULLMODE_CW ^ S4_CULLMODE_CCW);
      if (ctx->Polygon.FrontFace != GL_CCW)
         mode ^= (S4_CULLMODE_CW ^ S4_CULLMODE_CCW);
   }
   else {
      mode = S4_CULLMODE_BOTH;
   }

   dw = i915->state.Ctx[I915_CTXREG_LIS4];
   dw &= ~S4_CULLMODE_MASK;
   dw |= mode;
   if (dw != i915->state.Ctx[I915_CTXREG_LIS4]) {
      i915->state.Ctx[I915_CTXREG_LIS4] = dw;
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   }
}

static void
i915LineWidth(struct gl_context * ctx, GLfloat widthf)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   int lis4 = i915->state.Ctx[I915_CTXREG_LIS4] & ~S4_LINE_WIDTH_MASK;
   int width;

   DBG("%s\n", __FUNCTION__);
   
   width = (int) (widthf * 2);
   width = CLAMP(width, 1, 0xf);
   lis4 |= width << S4_LINE_WIDTH_SHIFT;

   if (lis4 != i915->state.Ctx[I915_CTXREG_LIS4]) {
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      i915->state.Ctx[I915_CTXREG_LIS4] = lis4;
   }
}

static void
i915PointSize(struct gl_context * ctx, GLfloat size)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   int lis4 = i915->state.Ctx[I915_CTXREG_LIS4] & ~S4_POINT_WIDTH_MASK;
   GLint point_size = (int) round(size);

   DBG("%s\n", __FUNCTION__);
   
   point_size = CLAMP(point_size, 1, 255);
   lis4 |= point_size << S4_POINT_WIDTH_SHIFT;

   if (lis4 != i915->state.Ctx[I915_CTXREG_LIS4]) {
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      i915->state.Ctx[I915_CTXREG_LIS4] = lis4;
   }
}


static void
i915PointParameterfv(struct gl_context * ctx, GLenum pname, const GLfloat *params)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);

   switch (pname) {
   case GL_POINT_SPRITE_COORD_ORIGIN:
      /* This could be supported, but it would require modifying the fragment
       * program to invert the y component of the texture coordinate by
       * inserting a 'SUB tc.y, {1.0}.xxxx, tc' instruction.
       */
      FALLBACK(&i915->intel, I915_FALLBACK_POINT_SPRITE_COORD_ORIGIN,
	       (params[0] != GL_UPPER_LEFT));
      break;
   }
}

void
i915_update_sprite_point_enable(struct gl_context *ctx)
{
   struct intel_context *intel = intel_context(ctx);
   /* _NEW_PROGRAM */
   struct i915_fragment_program *p =
      (struct i915_fragment_program *) ctx->FragmentProgram._Current;
   const GLbitfield64 inputsRead = p->FragProg.Base.InputsRead;
   struct i915_context *i915 = i915_context(ctx);
   GLuint s4 = i915->state.Ctx[I915_CTXREG_LIS4] & ~S4_VFMT_MASK;
   int i;
   GLuint coord_replace_bits = 0x0;
   GLuint tex_coord_unit_bits = 0x0;

   for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++) {
      /* _NEW_POINT */
      if (ctx->Point.CoordReplace[i] && ctx->Point.PointSprite)
         coord_replace_bits |= (1 << i);
      if (inputsRead & VARYING_BIT_TEX(i))
         tex_coord_unit_bits |= (1 << i);
   }

   /*
    * Here we can't enable the SPRITE_POINT_ENABLE bit when the mis-match
    * of tex_coord_unit_bits and coord_replace_bits, or this will make all
    * the other non-point-sprite coords(like varying inputs, as we now use
    * tex coord to implement varying inputs) be replaced to value (0, 0)-(1, 1).
    *
    * Thus, do fallback when needed.
    */
   FALLBACK(intel, I915_FALLBACK_COORD_REPLACE,
            coord_replace_bits && coord_replace_bits != tex_coord_unit_bits);

   s4 &= ~S4_SPRITE_POINT_ENABLE;
   s4 |= (coord_replace_bits && coord_replace_bits == tex_coord_unit_bits) ?
         S4_SPRITE_POINT_ENABLE : 0;
   if (s4 != i915->state.Ctx[I915_CTXREG_LIS4]) {
      i915->state.Ctx[I915_CTXREG_LIS4] = s4;
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   }
}


/* =============================================================
 * Color masks
 */

static void
i915ColorMask(struct gl_context * ctx,
              GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   GLuint tmp = i915->state.Ctx[I915_CTXREG_LIS5] & ~S5_WRITEDISABLE_MASK;

   DBG("%s r(%d) g(%d) b(%d) a(%d)\n", __FUNCTION__, r, g, b,
       a);

   if (!r)
      tmp |= S5_WRITEDISABLE_RED;
   if (!g)
      tmp |= S5_WRITEDISABLE_GREEN;
   if (!b)
      tmp |= S5_WRITEDISABLE_BLUE;
   if (!a)
      tmp |= S5_WRITEDISABLE_ALPHA;

   if (tmp != i915->state.Ctx[I915_CTXREG_LIS5]) {
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      i915->state.Ctx[I915_CTXREG_LIS5] = tmp;
   }
}

static void
update_specular(struct gl_context * ctx)
{
   /* A hack to trigger the rebuild of the fragment program.
    */
   intel_context(ctx)->NewGLState |= _NEW_TEXTURE;
}

static void
i915LightModelfv(struct gl_context * ctx, GLenum pname, const GLfloat * param)
{
   DBG("%s\n", __FUNCTION__);
   
   if (pname == GL_LIGHT_MODEL_COLOR_CONTROL) {
      update_specular(ctx);
   }
}

static void
i915ShadeModel(struct gl_context * ctx, GLenum mode)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   I915_STATECHANGE(i915, I915_UPLOAD_CTX);

   if (mode == GL_SMOOTH) {
      i915->state.Ctx[I915_CTXREG_LIS4] &= ~(S4_FLATSHADE_ALPHA |
                                             S4_FLATSHADE_COLOR |
                                             S4_FLATSHADE_SPECULAR);
   }
   else {
      i915->state.Ctx[I915_CTXREG_LIS4] |= (S4_FLATSHADE_ALPHA |
                                            S4_FLATSHADE_COLOR |
                                            S4_FLATSHADE_SPECULAR);
   }
}

/* =============================================================
 * Fog
 *
 * This empty function remains because _mesa_init_driver_state calls
 * dd_function_table::Fogfv unconditionally.  We have to have some function
 * there so that it doesn't try to call a NULL pointer.
 */
static void
i915Fogfv(struct gl_context * ctx, GLenum pname, const GLfloat * param)
{
   (void) ctx;
   (void) pname;
   (void) param;
}

/* =============================================================
 */

static void
i915Enable(struct gl_context * ctx, GLenum cap, GLboolean state)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   GLuint dw;

   switch (cap) {
   case GL_TEXTURE_2D:
      break;

   case GL_LIGHTING:
   case GL_COLOR_SUM:
      update_specular(ctx);
      break;

   case GL_ALPHA_TEST:
      dw = i915->state.Ctx[I915_CTXREG_LIS6];
      if (state)
         dw |= S6_ALPHA_TEST_ENABLE;
      else
         dw &= ~S6_ALPHA_TEST_ENABLE;
      if (dw != i915->state.Ctx[I915_CTXREG_LIS6]) {
	 i915->state.Ctx[I915_CTXREG_LIS6] = dw;
	 I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      }
      break;

   case GL_BLEND:
      i915EvalLogicOpBlendState(ctx);
      break;

   case GL_COLOR_LOGIC_OP:
      i915EvalLogicOpBlendState(ctx);

      /* Logicop doesn't seem to work at 16bpp:
       */
      if (ctx->Visual.rgbBits == 16)
         FALLBACK(&i915->intel, I915_FALLBACK_LOGICOP, state);
      break;

   case GL_FRAGMENT_PROGRAM_ARB:
      break;

   case GL_DITHER:
      dw = i915->state.Ctx[I915_CTXREG_LIS5];
      if (state)
         dw |= S5_COLOR_DITHER_ENABLE;
      else
         dw &= ~S5_COLOR_DITHER_ENABLE;
      if (dw != i915->state.Ctx[I915_CTXREG_LIS5]) {
	 i915->state.Ctx[I915_CTXREG_LIS5] = dw;
	 I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      }
      break;

   case GL_DEPTH_TEST:
      dw = i915->state.Ctx[I915_CTXREG_LIS6];

      if (!ctx->DrawBuffer || !ctx->DrawBuffer->Visual.depthBits)
	 state = false;

      if (state)
         dw |= S6_DEPTH_TEST_ENABLE;
      else
         dw &= ~S6_DEPTH_TEST_ENABLE;
      if (dw != i915->state.Ctx[I915_CTXREG_LIS6]) {
	 i915->state.Ctx[I915_CTXREG_LIS6] = dw;
	 I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      }

      i915DepthMask(ctx, ctx->Depth.Mask);
      break;

   case GL_SCISSOR_TEST:
      I915_STATECHANGE(i915, I915_UPLOAD_BUFFERS);
      if (state)
         i915->state.Buffer[I915_DESTREG_SENABLE] =
            (_3DSTATE_SCISSOR_ENABLE_CMD | ENABLE_SCISSOR_RECT);
      else
         i915->state.Buffer[I915_DESTREG_SENABLE] =
            (_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);
      break;

   case GL_LINE_SMOOTH:
      dw = i915->state.Ctx[I915_CTXREG_LIS4];
      if (state)
         dw |= S4_LINE_ANTIALIAS_ENABLE;
      else
         dw &= ~S4_LINE_ANTIALIAS_ENABLE;
      if (dw != i915->state.Ctx[I915_CTXREG_LIS4]) {
	 i915->state.Ctx[I915_CTXREG_LIS4] = dw;
	 I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      }
      break;

   case GL_CULL_FACE:
      i915CullFaceFrontFace(ctx, 0);
      break;

   case GL_STENCIL_TEST:
      if (!ctx->DrawBuffer || !ctx->DrawBuffer->Visual.stencilBits)
	 state = false;

      dw = i915->state.Ctx[I915_CTXREG_LIS5];
      if (state)
	 dw |= (S5_STENCIL_TEST_ENABLE | S5_STENCIL_WRITE_ENABLE);
      else
	 dw &= ~(S5_STENCIL_TEST_ENABLE | S5_STENCIL_WRITE_ENABLE);
      if (dw != i915->state.Ctx[I915_CTXREG_LIS5]) {
	 i915->state.Ctx[I915_CTXREG_LIS5] = dw;
	 I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      }
      break;

   case GL_POLYGON_STIPPLE:
      /* The stipple command worked on my 855GM box, but not my 845G.
       * I'll do more testing later to find out exactly which hardware
       * supports it.  Disabled for now.
       */
      if (i915->intel.hw_stipple &&
          i915->intel.reduced_primitive == GL_TRIANGLES) {
         I915_STATECHANGE(i915, I915_UPLOAD_STIPPLE);
         if (state)
            i915->state.Stipple[I915_STPREG_ST1] |= ST1_ENABLE;
         else
            i915->state.Stipple[I915_STPREG_ST1] &= ~ST1_ENABLE;
      }
      break;

   case GL_POLYGON_SMOOTH:
      break;

   case GL_POINT_SPRITE:
      /* Handle it at i915_update_sprite_point_enable () */
      break;

   case GL_POINT_SMOOTH:
      break;

   default:
      ;
   }
}


static void
i915_init_packets(struct i915_context *i915)
{
   /* Zero all state */
   memset(&i915->state, 0, sizeof(i915->state));


   {
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      I915_STATECHANGE(i915, I915_UPLOAD_BLEND);
      /* Probably don't want to upload all this stuff every time one 
       * piece changes.
       */
      i915->state.Ctx[I915_CTXREG_LI] = (_3DSTATE_LOAD_STATE_IMMEDIATE_1 |
                                         I1_LOAD_S(2) |
                                         I1_LOAD_S(4) |
                                         I1_LOAD_S(5) | I1_LOAD_S(6) | (3));
      i915->state.Ctx[I915_CTXREG_LIS2] = 0;
      i915->state.Ctx[I915_CTXREG_LIS4] = 0;
      i915->state.Ctx[I915_CTXREG_LIS5] = 0;

      if (i915->intel.ctx.Visual.rgbBits == 16)
         i915->state.Ctx[I915_CTXREG_LIS5] |= S5_COLOR_DITHER_ENABLE;


      i915->state.Ctx[I915_CTXREG_LIS6] = (S6_COLOR_WRITE_ENABLE |
                                           (2 << S6_TRISTRIP_PV_SHIFT));

      i915->state.Ctx[I915_CTXREG_STATE4] = (_3DSTATE_MODES_4_CMD |
                                             ENABLE_LOGIC_OP_FUNC |
                                             LOGIC_OP_FUNC(LOGICOP_COPY) |
                                             ENABLE_STENCIL_TEST_MASK |
                                             STENCIL_TEST_MASK(0xff) |
                                             ENABLE_STENCIL_WRITE_MASK |
                                             STENCIL_WRITE_MASK(0xff));

      i915->state.Blend[I915_BLENDREG_IAB] =
         (_3DSTATE_INDEPENDENT_ALPHA_BLEND_CMD | IAB_MODIFY_ENABLE |
          IAB_MODIFY_FUNC | IAB_MODIFY_SRC_FACTOR | IAB_MODIFY_DST_FACTOR);

      i915->state.Blend[I915_BLENDREG_BLENDCOLOR0] =
         _3DSTATE_CONST_BLEND_COLOR_CMD;
      i915->state.Blend[I915_BLENDREG_BLENDCOLOR1] = 0;

      i915->state.Ctx[I915_CTXREG_BF_STENCIL_MASKS] =
	 _3DSTATE_BACKFACE_STENCIL_MASKS |
	 BFM_ENABLE_STENCIL_TEST_MASK |
	 BFM_ENABLE_STENCIL_WRITE_MASK |
	 (0xff << BFM_STENCIL_WRITE_MASK_SHIFT) |
	 (0xff << BFM_STENCIL_TEST_MASK_SHIFT);
      i915->state.Ctx[I915_CTXREG_BF_STENCIL_OPS] =
	 _3DSTATE_BACKFACE_STENCIL_OPS |
	 BFO_ENABLE_STENCIL_REF |
	 BFO_ENABLE_STENCIL_FUNCS |
	 BFO_ENABLE_STENCIL_TWO_SIDE;
   }

   {
      I915_STATECHANGE(i915, I915_UPLOAD_STIPPLE);
      i915->state.Stipple[I915_STPREG_ST0] = _3DSTATE_STIPPLE;
   }

   {
      i915->state.Buffer[I915_DESTREG_DV0] = _3DSTATE_DST_BUF_VARS_CMD;

      /* scissor */
      i915->state.Buffer[I915_DESTREG_SENABLE] =
         (_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);
      i915->state.Buffer[I915_DESTREG_SR0] = _3DSTATE_SCISSOR_RECT_0_CMD;
      i915->state.Buffer[I915_DESTREG_SR1] = 0;
      i915->state.Buffer[I915_DESTREG_SR2] = 0;
   }

   i915->state.RasterRules[I915_RASTER_RULES] = _3DSTATE_RASTER_RULES_CMD |
      ENABLE_POINT_RASTER_RULE |
      OGL_POINT_RASTER_RULE |
      ENABLE_LINE_STRIP_PROVOKE_VRTX |
      ENABLE_TRI_FAN_PROVOKE_VRTX |
      LINE_STRIP_PROVOKE_VRTX(1) |
      TRI_FAN_PROVOKE_VRTX(2) | ENABLE_TEXKILL_3D_4D | TEXKILL_4D;

#if 0
   {
      I915_STATECHANGE(i915, I915_UPLOAD_DEFAULTS);
      i915->state.Default[I915_DEFREG_C0] = _3DSTATE_DEFAULT_DIFFUSE;
      i915->state.Default[I915_DEFREG_C1] = 0;
      i915->state.Default[I915_DEFREG_S0] = _3DSTATE_DEFAULT_SPECULAR;
      i915->state.Default[I915_DEFREG_S1] = 0;
      i915->state.Default[I915_DEFREG_Z0] = _3DSTATE_DEFAULT_Z;
      i915->state.Default[I915_DEFREG_Z1] = 0;
   }
#endif


   /* These will be emitted every at the head of every buffer, unless
    * we get hardware contexts working.
    */
   i915->state.active = (I915_UPLOAD_PROGRAM |
                         I915_UPLOAD_STIPPLE |
                         I915_UPLOAD_CTX |
                         I915_UPLOAD_BLEND |
                         I915_UPLOAD_BUFFERS |
			 I915_UPLOAD_INVARIENT |
			 I915_UPLOAD_RASTER_RULES);
}

void
i915_update_provoking_vertex(struct gl_context * ctx)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);

   I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   i915->state.Ctx[I915_CTXREG_LIS6] &= ~(S6_TRISTRIP_PV_MASK);

   I915_STATECHANGE(i915, I915_UPLOAD_RASTER_RULES);
   i915->state.RasterRules[I915_RASTER_RULES] &= ~(LINE_STRIP_PROVOKE_VRTX_MASK |
						   TRI_FAN_PROVOKE_VRTX_MASK);

   /* _NEW_LIGHT */
   if (ctx->Light.ProvokingVertex == GL_LAST_VERTEX_CONVENTION) {
      i915->state.RasterRules[I915_RASTER_RULES] |= (LINE_STRIP_PROVOKE_VRTX(1) |
						     TRI_FAN_PROVOKE_VRTX(2));
      i915->state.Ctx[I915_CTXREG_LIS6] |= (2 << S6_TRISTRIP_PV_SHIFT);
   } else {
      i915->state.RasterRules[I915_RASTER_RULES] |= (LINE_STRIP_PROVOKE_VRTX(0) |
						     TRI_FAN_PROVOKE_VRTX(1));
      i915->state.Ctx[I915_CTXREG_LIS6] |= (0 << S6_TRISTRIP_PV_SHIFT);
    }
}

/* Fallback to swrast for select and feedback.
 */
static void
i915RenderMode(struct gl_context *ctx, GLenum mode)
{
   struct intel_context *intel = intel_context(ctx);
   FALLBACK(intel, INTEL_FALLBACK_RENDERMODE, (mode != GL_RENDER));
}

void
i915InitStateFunctions(struct dd_function_table *functions)
{
   functions->AlphaFunc = i915AlphaFunc;
   functions->BlendColor = i915BlendColor;
   functions->BlendEquationSeparate = i915BlendEquationSeparate;
   functions->BlendFuncSeparate = i915BlendFuncSeparate;
   functions->ColorMask = i915ColorMask;
   functions->CullFace = i915CullFaceFrontFace;
   functions->DepthFunc = i915DepthFunc;
   functions->DepthMask = i915DepthMask;
   functions->Enable = i915Enable;
   functions->Fogfv = i915Fogfv;
   functions->FrontFace = i915CullFaceFrontFace;
   functions->LightModelfv = i915LightModelfv;
   functions->LineWidth = i915LineWidth;
   functions->LogicOpcode = i915LogicOp;
   functions->PointSize = i915PointSize;
   functions->PointParameterfv = i915PointParameterfv;
   functions->PolygonStipple = i915PolygonStipple;
   functions->RenderMode = i915RenderMode;
   functions->Scissor = i915Scissor;
   functions->ShadeModel = i915ShadeModel;
   functions->StencilFuncSeparate = i915StencilFuncSeparate;
   functions->StencilMaskSeparate = i915StencilMaskSeparate;
   functions->StencilOpSeparate = i915StencilOpSeparate;
   functions->DepthRange = i915DepthRange;
}


void
i915InitState(struct i915_context *i915)
{
   struct gl_context *ctx = &i915->intel.ctx;

   i915_init_packets(i915);

   _mesa_init_driver_state(ctx);
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a36 1
#include "main/viewport.h"
a403 3
   double scale[3], translate[3];

   _mesa_get_viewport_xform(ctx, 0, scale, translate);
d406 17
a422 2
      scale[1] = -scale[1];
      translate[1] = ctx->DrawBuffer->Height - translate[1];
a423 3

   _math_matrix_viewport(&intel->ViewportMatrix,
                         scale, translate, 1.0);
d991 2
a995 2
      i915->state.Buffer[I915_DESTREG_SENABLE] =
         (_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d37 1
d405 3
d410 2
a411 17
      _math_matrix_viewport(&intel->ViewportMatrix,
			    ctx->ViewportArray[0].X,
			    ctx->DrawBuffer->Height - ctx->ViewportArray[0].Y,
			    ctx->ViewportArray[0].Width,
			    -ctx->ViewportArray[0].Height,
			    ctx->ViewportArray[0].Near,
			    ctx->ViewportArray[0].Far,
			    1.0);
   } else {
      _math_matrix_viewport(&intel->ViewportMatrix,
			    ctx->ViewportArray[0].X,
			    ctx->ViewportArray[0].Y,
			    ctx->ViewportArray[0].Width,
			    ctx->ViewportArray[0].Height,
			    ctx->ViewportArray[0].Near,
			    ctx->ViewportArray[0].Far,
			    1.0);
d413 3
a982 2
      i915->state.Buffer[I915_DESTREG_SENABLE] =
         (_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);
d986 2
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d407 6
a412 6
			    ctx->Viewport.X,
			    ctx->DrawBuffer->Height - ctx->Viewport.Y,
			    ctx->Viewport.Width,
			    -ctx->Viewport.Height,
			    ctx->Viewport.Near,
			    ctx->Viewport.Far,
d416 6
a421 6
			    ctx->Viewport.X,
			    ctx->Viewport.Y,
			    ctx->Viewport.Width,
			    ctx->Viewport.Height,
			    ctx->Viewport.Near,
			    ctx->Viewport.Far,
a426 9
/** Called from ctx->Driver.Viewport() */
static void
i915Viewport(struct gl_context * ctx,
              GLint x, GLint y, GLsizei width, GLsizei height)
{
   intelCalcViewport(ctx);
}


d429 1
a429 1
i915DepthRange(struct gl_context * ctx, GLclampd nearval, GLclampd farval)
d504 1
a504 1
i915Scissor(struct gl_context * ctx, GLint x, GLint y, GLsizei w, GLsizei h)
d512 3
a514 1
   DBG("%s %d,%d %dx%d\n", __FUNCTION__, x, y, w, h);
d517 6
a522 4
      x1 = x;
      y1 = ctx->DrawBuffer->Height - (y + h);
      x2 = x + w - 1;
      y2 = y1 + h - 1;
d528 6
a533 4
      x1 = x;
      y1 = y;
      x2 = x + w - 1;
      y2 = y + h - 1;
a1090 1
   functions->Viewport = i915Viewport;
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d33 1
d36 1
a39 2
#include "texmem.h"

d67 1
a67 1
      front_ref = ctx->Stencil.Ref[0];
d74 1
a74 1
      back_ref = ctx->Stencil.Ref[ctx->Stencil._BackFace];
d82 1
a82 1
      front_ref = ctx->Stencil.Ref[ctx->Stencil._BackFace];
d89 1
a89 1
      back_ref = ctx->Stencil.Ref[0];
d213 1
a213 1
   if (_mesa_rgba_logicop_enabled(ctx)) {
d405 1
a405 1
   if (ctx->DrawBuffer->Name == 0) {
d523 1
a523 1
   if (ctx->DrawBuffer->Name == 0) {
d582 1
a582 1
      if (ctx->DrawBuffer && ctx->DrawBuffer->Name != 0)
d657 42
d916 1
a916 12
      /* This state change is handled in i915_reduced_primitive_state because
       * the hardware bit should only be set when rendering points.
       */
	 dw = i915->state.Ctx[I915_CTXREG_LIS4];
      if (state)
	 dw |= S4_SPRITE_POINT_ENABLE;
      else
	 dw &= ~S4_SPRITE_POINT_ENABLE;
      if (dw != i915->state.Ctx[I915_CTXREG_LIS4]) {
	 i915->state.Ctx[I915_CTXREG_LIS4] = dw;
	 I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      }
d1058 9
d1087 1
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d34 1
d60 1
a60 2

   I915_STATECHANGE(i915, I915_UPLOAD_CTX);
d97 7
d106 21
a126 21
   i915->state.Ctx[I915_CTXREG_STATE4] &= ~(MODE4_ENABLE_STENCIL_TEST_MASK |
					    MODE4_ENABLE_STENCIL_WRITE_MASK);
   i915->state.Ctx[I915_CTXREG_STATE4] |= (ENABLE_STENCIL_TEST_MASK |
					   ENABLE_STENCIL_WRITE_MASK |
					   STENCIL_TEST_MASK(front_mask) |
					   STENCIL_WRITE_MASK(front_writemask));

   i915->state.Ctx[I915_CTXREG_LIS5] &= ~(S5_STENCIL_REF_MASK |
					  S5_STENCIL_TEST_FUNC_MASK |
					  S5_STENCIL_FAIL_MASK |
					  S5_STENCIL_PASS_Z_FAIL_MASK |
					  S5_STENCIL_PASS_Z_PASS_MASK);

   i915->state.Ctx[I915_CTXREG_LIS5] |=
      (front_ref << S5_STENCIL_REF_SHIFT) |
      (intel_translate_compare_func(front_func) << S5_STENCIL_TEST_FUNC_SHIFT) |
      (intel_translate_stencil_op(front_fail) << S5_STENCIL_FAIL_SHIFT) |
      (intel_translate_stencil_op(front_pass_z_fail) <<
       S5_STENCIL_PASS_Z_FAIL_SHIFT) |
      (intel_translate_stencil_op(front_pass_z_pass) <<
       S5_STENCIL_PASS_Z_PASS_SHIFT);
d130 20
a149 21
      i915->state.Ctx[I915_CTXREG_BF_STENCIL_OPS] &=
	 ~(BFO_STENCIL_REF_MASK |
	   BFO_STENCIL_TEST_MASK |
	   BFO_STENCIL_FAIL_MASK |
	   BFO_STENCIL_PASS_Z_FAIL_MASK |
	   BFO_STENCIL_PASS_Z_PASS_MASK);
      i915->state.Ctx[I915_CTXREG_BF_STENCIL_OPS] |= BFO_STENCIL_TWO_SIDE |
	 (back_ref << BFO_STENCIL_REF_SHIFT) |
	 (intel_translate_compare_func(back_func) << BFO_STENCIL_TEST_SHIFT) |
	 (intel_translate_stencil_op(back_fail) << BFO_STENCIL_FAIL_SHIFT) |
	 (intel_translate_stencil_op(back_pass_z_fail) <<
	  BFO_STENCIL_PASS_Z_FAIL_SHIFT) |
	 (intel_translate_stencil_op(back_pass_z_pass) <<
	  BFO_STENCIL_PASS_Z_PASS_SHIFT);

      i915->state.Ctx[I915_CTXREG_BF_STENCIL_MASKS] &=
	 ~(BFM_STENCIL_TEST_MASK_MASK |
	   BFM_STENCIL_WRITE_MASK_MASK);
      i915->state.Ctx[I915_CTXREG_BF_STENCIL_MASKS] |=
	 BFM_STENCIL_TEST_MASK(back_mask) |
	 BFM_STENCIL_WRITE_MASK(back_writemask);
d151 2
a152 1
      i915->state.Ctx[I915_CTXREG_BF_STENCIL_OPS] &= ~BFO_STENCIL_TWO_SIDE;
d154 5
d184 1
d188 8
a195 6
   I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   i915->state.Ctx[I915_CTXREG_LIS6] &= ~(S6_ALPHA_TEST_FUNC_MASK |
                                          S6_ALPHA_REF_MASK);
   i915->state.Ctx[I915_CTXREG_LIS6] |= ((test << S6_ALPHA_TEST_FUNC_SHIFT) |
                                         (((GLuint) refByte) <<
                                          S6_ALPHA_REF_SHIFT));
d208 1
d210 2
a211 1
   I915_STATECHANGE(i915, I915_UPLOAD_CTX);
d213 3
a215 3
   if (RGBA_LOGICOP_ENABLED(ctx)) {
      i915->state.Ctx[I915_CTXREG_LIS5] |= S5_LOGICOP_ENABLE;
      i915->state.Ctx[I915_CTXREG_LIS6] &= ~S6_CBUF_BLEND_ENABLE;
d218 1
a218 1
      i915->state.Ctx[I915_CTXREG_LIS5] &= ~S5_LOGICOP_ENABLE;
d221 1
a221 1
         i915->state.Ctx[I915_CTXREG_LIS6] |= S6_CBUF_BLEND_ENABLE;
d224 1
a224 1
         i915->state.Ctx[I915_CTXREG_LIS6] &= ~S6_CBUF_BLEND_ENABLE;
d227 7
d241 1
d250 5
a254 3
   I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   i915->state.Ctx[I915_CTXREG_BLENDCOLOR1] =
      (a << 24) | (r << 16) | (g << 8) | b;
d288 1
a288 1
   GLuint iab = (i915->state.Ctx[I915_CTXREG_IAB] &
d297 6
a302 6
   GLuint eqRGB = ctx->Color.BlendEquationRGB;
   GLuint eqA = ctx->Color.BlendEquationA;
   GLuint srcRGB = ctx->Color.BlendSrcRGB;
   GLuint dstRGB = ctx->Color.BlendDstRGB;
   GLuint srcA = ctx->Color.BlendSrcA;
   GLuint dstA = ctx->Color.BlendDstA;
d323 6
a328 2
   if (iab != i915->state.Ctx[I915_CTXREG_IAB] ||
       lis6 != i915->state.Ctx[I915_CTXREG_LIS6]) {
a329 2
      i915->state.Ctx[I915_CTXREG_IAB] = iab;
      i915->state.Ctx[I915_CTXREG_LIS6] = lis6;
d357 1
d361 7
a367 3
   I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   i915->state.Ctx[I915_CTXREG_LIS6] &= ~S6_DEPTH_TEST_FUNC_MASK;
   i915->state.Ctx[I915_CTXREG_LIS6] |= test << S6_DEPTH_TEST_FUNC_SHIFT;
d374 1
a376 2
   
   I915_STATECHANGE(i915, I915_UPLOAD_CTX);
d378 4
d383 1
a383 1
      i915->state.Ctx[I915_CTXREG_LIS6] |= S6_DEPTH_WRITE_ENABLE;
d385 5
a389 1
      i915->state.Ctx[I915_CTXREG_LIS6] &= ~S6_DEPTH_WRITE_ENABLE;
d404 19
a422 15
   const GLfloat *v = ctx->Viewport._WindowMap.m;
   const GLfloat depthScale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
   GLfloat *m = intel->ViewportMatrix.m;
   GLfloat yScale, yBias;

   if (ctx->DrawBuffer->Name) {
      /* User created FBO */
      /* y=0=bottom */
      yScale = 1.0;
      yBias = 0.0;
   }
   else {
      /* window buffer, y=0=top */
      yScale = -1.0;
      yBias = ctx->DrawBuffer->Height;
a423 9

   m[MAT_SX] = v[MAT_SX];
   m[MAT_TX] = v[MAT_TX];

   m[MAT_SY] = v[MAT_SY] * yScale;
   m[MAT_TY] = v[MAT_TY] * yScale + yBias;

   m[MAT_SZ] = v[MAT_SZ] * depthScale;
   m[MAT_TZ] = v[MAT_TZ] * depthScale;
d571 1
a571 1
   GLuint mode;
d593 7
a599 3
   I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   i915->state.Ctx[I915_CTXREG_LIS4] &= ~S4_CULLMODE_MASK;
   i915->state.Ctx[I915_CTXREG_LIS4] |= mode;
d725 4
a729 96
void
i915_update_fog(struct gl_context * ctx)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   GLenum mode;
   GLboolean enabled;
   GLboolean try_pixel_fog;

   if (ctx->FragmentProgram._Current) {
      /* Pull in static fog state from program */
      mode = ctx->FragmentProgram._Current->FogOption;
      enabled = (mode != GL_NONE);
      try_pixel_fog = 0;
   }
   else {
      enabled = ctx->Fog.Enabled;
      mode = ctx->Fog.Mode;
#if 0
      /* XXX - DISABLED -- Need ortho fallback */
      try_pixel_fog = (ctx->Fog.FogCoordinateSource == GL_FRAGMENT_DEPTH_EXT
                       && ctx->Hint.Fog == GL_NICEST);
#else
      try_pixel_fog = 0;
#endif
   }

   if (!enabled) {
      i915->vertex_fog = I915_FOG_NONE;
   }
   else if (try_pixel_fog) {
      I915_STATECHANGE(i915, I915_UPLOAD_FOG);
      i915->state.Fog[I915_FOGREG_MODE1] &= ~FMC1_FOGFUNC_MASK;
      i915->vertex_fog = I915_FOG_PIXEL;

      switch (mode) {
      case GL_LINEAR:
         if (ctx->Fog.End <= ctx->Fog.Start) {
            /* XXX - this won't work with fragment programs.  Need to
             * either fallback or append fog instructions to end of
             * program in the case of linear fog.
             */
            printf("vertex fog!\n");
            i915->state.Fog[I915_FOGREG_MODE1] |= FMC1_FOGFUNC_VERTEX;
            i915->vertex_fog = I915_FOG_VERTEX;
         }
         else {
            GLfloat c2 = 1.0 / (ctx->Fog.End - ctx->Fog.Start);
            GLfloat c1 = ctx->Fog.End * c2;

            i915->state.Fog[I915_FOGREG_MODE1] &= ~FMC1_C1_MASK;
            i915->state.Fog[I915_FOGREG_MODE1] |= FMC1_FOGFUNC_PIXEL_LINEAR;
            i915->state.Fog[I915_FOGREG_MODE1] |=
               ((GLuint) (c1 * FMC1_C1_ONE)) & FMC1_C1_MASK;

            if (i915->state.Fog[I915_FOGREG_MODE1] & FMC1_FOGINDEX_Z) {
               i915->state.Fog[I915_FOGREG_MODE2]
                  = (GLuint) (c2 * FMC2_C2_ONE);
            }
            else {
               fi_type fi;
               fi.f = c2;
               i915->state.Fog[I915_FOGREG_MODE2] = fi.i;
            }
         }
         break;
      case GL_EXP:
         i915->state.Fog[I915_FOGREG_MODE1] |= FMC1_FOGFUNC_PIXEL_EXP;
         break;
      case GL_EXP2:
         i915->state.Fog[I915_FOGREG_MODE1] |= FMC1_FOGFUNC_PIXEL_EXP2;
         break;
      default:
         break;
      }
   }
   else { /* if (i915->vertex_fog != I915_FOG_VERTEX) */
      I915_STATECHANGE(i915, I915_UPLOAD_FOG);
      i915->state.Fog[I915_FOGREG_MODE1] &= ~FMC1_FOGFUNC_MASK;
      i915->state.Fog[I915_FOGREG_MODE1] |= FMC1_FOGFUNC_VERTEX;
      i915->vertex_fog = I915_FOG_VERTEX;
   }

   I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   I915_ACTIVESTATE(i915, I915_UPLOAD_FOG, enabled);
   if (enabled)
      i915->state.Ctx[I915_CTXREG_LIS5] |= S5_FOG_ENABLE;
   else
      i915->state.Ctx[I915_CTXREG_LIS5] &= ~S5_FOG_ENABLE;

   /* Always enable pixel fog.  Vertex fog using fog coord will conflict
    * with fog code appended onto fragment program.
    */
    _tnl_allow_vertex_fog( ctx, 0 );
    _tnl_allow_pixel_fog( ctx, 1 );
}

d733 3
a735 46
   struct i915_context *i915 = I915_CONTEXT(ctx);

   switch (pname) {
   case GL_FOG_COORDINATE_SOURCE_EXT:
   case GL_FOG_MODE:
   case GL_FOG_START:
   case GL_FOG_END:
      break;

   case GL_FOG_DENSITY:
      I915_STATECHANGE(i915, I915_UPLOAD_FOG);

      if (i915->state.Fog[I915_FOGREG_MODE1] & FMC1_FOGINDEX_Z) {
         i915->state.Fog[I915_FOGREG_MODE3] =
            (GLuint) (ctx->Fog.Density * FMC3_D_ONE);
      }
      else {
         fi_type fi;
         fi.f = ctx->Fog.Density;
         i915->state.Fog[I915_FOGREG_MODE3] = fi.i;
      }
      break;

   case GL_FOG_COLOR:
      I915_STATECHANGE(i915, I915_UPLOAD_FOG);
      i915->state.Fog[I915_FOGREG_COLOR] =
         (_3DSTATE_FOG_COLOR_CMD |
          ((GLubyte) (ctx->Fog.Color[0] * 255.0F) << 16) |
          ((GLubyte) (ctx->Fog.Color[1] * 255.0F) << 8) |
          ((GLubyte) (ctx->Fog.Color[2] * 255.0F) << 0));
      break;

   default:
      break;
   }
}

static void
i915Hint(struct gl_context * ctx, GLenum target, GLenum state)
{
   switch (target) {
   case GL_FOG_HINT:
      break;
   default:
      break;
   }
d745 1
d757 1
a757 1
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
d759 1
a759 1
         i915->state.Ctx[I915_CTXREG_LIS6] |= S6_ALPHA_TEST_ENABLE;
d761 5
a765 1
         i915->state.Ctx[I915_CTXREG_LIS6] &= ~S6_ALPHA_TEST_ENABLE;
d785 1
a785 1
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
d787 1
a787 1
         i915->state.Ctx[I915_CTXREG_LIS5] |= S5_COLOR_DITHER_ENABLE;
d789 5
a793 1
         i915->state.Ctx[I915_CTXREG_LIS5] &= ~S5_COLOR_DITHER_ENABLE;
d797 5
a801 1
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
d803 1
a803 1
         i915->state.Ctx[I915_CTXREG_LIS6] |= S6_DEPTH_TEST_ENABLE;
d805 5
a809 1
         i915->state.Ctx[I915_CTXREG_LIS6] &= ~S6_DEPTH_TEST_ENABLE;
d825 1
a825 1
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
d827 1
a827 1
         i915->state.Ctx[I915_CTXREG_LIS4] |= S4_LINE_ANTIALIAS_ENABLE;
d829 5
a833 4
         i915->state.Ctx[I915_CTXREG_LIS4] &= ~S4_LINE_ANTIALIAS_ENABLE;
      break;

   case GL_FOG:
d841 11
a851 19
      {
         GLboolean hw_stencil = GL_FALSE;
         if (ctx->DrawBuffer) {
            struct intel_renderbuffer *irbStencil
               = intel_get_renderbuffer(ctx->DrawBuffer, BUFFER_STENCIL);
            hw_stencil = (irbStencil && irbStencil->region);
         }
         if (hw_stencil) {
            I915_STATECHANGE(i915, I915_UPLOAD_CTX);
            if (state)
               i915->state.Ctx[I915_CTXREG_LIS5] |= (S5_STENCIL_TEST_ENABLE |
                                                     S5_STENCIL_WRITE_ENABLE);
            else
               i915->state.Ctx[I915_CTXREG_LIS5] &= ~(S5_STENCIL_TEST_ENABLE |
                                                      S5_STENCIL_WRITE_ENABLE);
         }
         else {
            FALLBACK(&i915->intel, I915_FALLBACK_STENCIL, state);
         }
d877 1
a877 1
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
d879 1
a879 1
	 i915->state.Ctx[I915_CTXREG_LIS4] |= S4_SPRITE_POINT_ENABLE;
d881 5
a885 1
	 i915->state.Ctx[I915_CTXREG_LIS4] &= ~S4_SPRITE_POINT_ENABLE;
d906 1
d933 1
a933 1
      i915->state.Ctx[I915_CTXREG_IAB] =
d937 1
a937 1
      i915->state.Ctx[I915_CTXREG_BLENDCOLOR0] =
d939 1
a939 1
      i915->state.Ctx[I915_CTXREG_BLENDCOLOR1] = 0;
a958 13

   {
      I915_STATECHANGE(i915, I915_UPLOAD_FOG);
      i915->state.Fog[I915_FOGREG_MODE0] = _3DSTATE_FOG_MODE_CMD;
      i915->state.Fog[I915_FOGREG_MODE1] = (FMC1_FOGFUNC_MODIFY_ENABLE |
                                            FMC1_FOGFUNC_VERTEX |
                                            FMC1_FOGINDEX_MODIFY_ENABLE |
                                            FMC1_FOGINDEX_W |
                                            FMC1_C1_C2_MODIFY_ENABLE |
                                            FMC1_DENSITY_MODIFY_ENABLE);
      i915->state.Fog[I915_FOGREG_COLOR] = _3DSTATE_FOG_COLOR_CMD;
   }

d997 1
a1040 1
   functions->Hint = i915Hint;
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d52 1
a52 1
i915_update_stencil(GLcontext * ctx)
d150 1
a150 1
i915StencilFuncSeparate(GLcontext * ctx, GLenum face, GLenum func, GLint ref,
d156 1
a156 1
i915StencilMaskSeparate(GLcontext * ctx, GLenum face, GLuint mask)
d161 1
a161 1
i915StencilOpSeparate(GLcontext * ctx, GLenum face, GLenum fail, GLenum zfail,
d167 1
a167 1
i915AlphaFunc(GLcontext * ctx, GLenum func, GLfloat ref)
d190 1
a190 1
i915EvalLogicOpBlendState(GLcontext * ctx)
d213 1
a213 1
i915BlendColor(GLcontext * ctx, const GLfloat color[4])
d258 1
a258 1
i915UpdateBlendState(GLcontext * ctx)
d309 1
a309 1
i915BlendFuncSeparate(GLcontext * ctx, GLenum srcRGB,
d317 1
a317 1
i915BlendEquationSeparate(GLcontext * ctx, GLenum eqRGB, GLenum eqA)
d324 1
a324 1
i915DepthFunc(GLcontext * ctx, GLenum func)
d337 1
a337 1
i915DepthMask(GLcontext * ctx, GLboolean flag)
d360 1
a360 1
intelCalcViewport(GLcontext * ctx)
d377 1
a377 1
      yBias = (intel->driDrawable) ? intel->driDrawable->h : 0.0F;
d393 1
a393 1
i915Viewport(GLcontext * ctx,
a396 2

   intel_viewport(ctx, x, y, width, height);
d402 1
a402 1
i915DepthRange(GLcontext * ctx, GLclampd nearval, GLclampd farval)
d415 1
a415 1
i915PolygonStipple(GLcontext * ctx, const GLubyte * mask)
d477 1
a477 1
i915Scissor(GLcontext * ctx, GLint x, GLint y, GLsizei w, GLsizei h)
d517 1
a517 1
i915LogicOp(GLcontext * ctx, GLenum opcode)
d532 1
a532 1
i915CullFaceFrontFace(GLcontext * ctx, GLenum unused)
d563 1
a563 1
i915LineWidth(GLcontext * ctx, GLfloat widthf)
d582 1
a582 1
i915PointSize(GLcontext * ctx, GLfloat size)
d601 1
a601 1
i915PointParameterfv(GLcontext * ctx, GLenum pname, const GLfloat *params)
d623 1
a623 1
i915ColorMask(GLcontext * ctx,
d648 1
a648 1
update_specular(GLcontext * ctx)
d656 1
a656 1
i915LightModelfv(GLcontext * ctx, GLenum pname, const GLfloat * param)
d666 1
a666 1
i915ShadeModel(GLcontext * ctx, GLenum mode)
d687 1
a687 1
i915_update_fog(GLcontext * ctx)
d783 1
a783 1
i915Fogfv(GLcontext * ctx, GLenum pname, const GLfloat * param)
d823 1
a823 1
i915Hint(GLcontext * ctx, GLenum target, GLenum state)
d837 1
a837 1
i915Enable(GLcontext * ctx, GLenum cap, GLboolean state)
d1096 1
a1096 1
i915_update_provoking_vertex(GLcontext * ctx)
d1153 1
a1153 1
   GLcontext *ctx = &i915->intel.ctx;
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d51 2
a52 3
static void
i915StencilFuncSeparate(GLcontext * ctx, GLenum face, GLenum func, GLint ref,
                        GLuint mask)
d55 4
a58 1
   int test = intel_translate_compare_func(func);
d60 1
a60 1
   mask = mask & 0xff;
d62 39
a100 6
   DBG("%s : func: %s, ref : 0x%x, mask: 0x%x\n", __FUNCTION__,
       _mesa_lookup_enum_by_nr(func), ref, mask);


   I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   i915->state.Ctx[I915_CTXREG_STATE4] &= ~MODE4_ENABLE_STENCIL_TEST_MASK;
d102 3
a104 1
                                           STENCIL_TEST_MASK(mask));
d107 41
a147 1
                                          S5_STENCIL_TEST_FUNC_MASK);
d149 4
a152 3
   i915->state.Ctx[I915_CTXREG_LIS5] |= ((ref << S5_STENCIL_REF_SHIFT) |
                                         (test <<
                                          S5_STENCIL_TEST_FUNC_SHIFT));
a157 10
   struct i915_context *i915 = I915_CONTEXT(ctx);

   DBG("%s : mask 0x%x\n", __FUNCTION__, mask);
   
   mask = mask & 0xff;

   I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   i915->state.Ctx[I915_CTXREG_STATE4] &= ~MODE4_ENABLE_STENCIL_WRITE_MASK;
   i915->state.Ctx[I915_CTXREG_STATE4] |= (ENABLE_STENCIL_WRITE_MASK |
                                           STENCIL_WRITE_MASK(mask));
a159 1

a163 21
   struct i915_context *i915 = I915_CONTEXT(ctx);
   int fop = intel_translate_stencil_op(fail);
   int dfop = intel_translate_stencil_op(zfail);
   int dpop = intel_translate_stencil_op(zpass);


   DBG("%s: fail : %s, zfail: %s, zpass : %s\n", __FUNCTION__,
       _mesa_lookup_enum_by_nr(fail),
       _mesa_lookup_enum_by_nr(zfail), _mesa_lookup_enum_by_nr(zpass));

   I915_STATECHANGE(i915, I915_UPLOAD_CTX);

   i915->state.Ctx[I915_CTXREG_LIS5] &= ~(S5_STENCIL_FAIL_MASK |
                                          S5_STENCIL_PASS_Z_FAIL_MASK |
                                          S5_STENCIL_PASS_Z_PASS_MASK);

   i915->state.Ctx[I915_CTXREG_LIS5] |= ((fop << S5_STENCIL_FAIL_SHIFT) |
                                         (dfop <<
                                          S5_STENCIL_PASS_Z_FAIL_SHIFT) |
                                         (dpop <<
                                          S5_STENCIL_PASS_Z_PASS_SHIFT));
d370 3
a372 12
      struct intel_renderbuffer *irb
         = intel_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[0]);
      if (irb && !irb->RenderToTexture) {
         /* y=0=top */
         yScale = -1.0;
         yBias = irb->Base.Height;
      }
      else {
         /* y=0=bottom */
         yScale = 1.0;
         yBias = 0.0;
      }
d393 1
a393 1
intelViewport(GLcontext * ctx,
d404 1
a404 1
intelDepthRange(GLcontext * ctx, GLclampd nearval, GLclampd farval)
d574 1
a574 1
   CLAMP_SELF(width, 1, 0xf);
d588 1
a588 1
   GLint point_size = (int) size;
d592 1
a592 1
   CLAMP_SELF(point_size, 1, 255);
d602 18
d960 11
d1023 11
d1065 7
d1092 27
a1118 1
                         I915_UPLOAD_BUFFERS | I915_UPLOAD_INVARIENT);
d1140 1
d1147 2
a1148 2
   functions->DepthRange = intelDepthRange;
   functions->Viewport = intelViewport;
a1159 3

   memcpy(&i915->initial, &i915->state, sizeof(i915->state));
   i915->current = &i915->state;
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d29 5
a33 5
#include "glheader.h"
#include "context.h"
#include "macros.h"
#include "enums.h"
#include "dd.h"
d44 1
d305 68
d641 1
a641 1
   if (ctx->FragmentProgram._Active) {
d1036 2
@


1.1
log
@Initial revision
@
text
@d39 3
d48 1
a48 1

d51 1
a51 1
i915StencilFuncSeparate(GLcontext *ctx, GLenum face, GLenum func, GLint ref,
d54 2
a55 2
   i915ContextPtr i915 = I915_CONTEXT(ctx);
   int test = intel_translate_compare_func( func );
d59 2
a60 3
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s : func: %s, ref : 0x%x, mask: 0x%x\n", __FUNCTION__,
	      _mesa_lookup_enum_by_nr(func), ref, mask);
d66 1
a66 1
					 STENCIL_TEST_MASK(mask));
d69 5
a73 4
					S5_STENCIL_TEST_FUNC_MASK);
					
   i915->state.Ctx[I915_CTXREG_LIS5] |= ((ref << S5_STENCIL_REF_SHIFT) |  
 				       (test << S5_STENCIL_TEST_FUNC_SHIFT)); 
d77 1
a77 1
i915StencilMaskSeparate(GLcontext *ctx, GLenum face, GLuint mask)
d79 1
a79 4
   i915ContextPtr i915 = I915_CONTEXT(ctx);

   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s : mask 0x%x\n", __FUNCTION__, mask);
d81 2
d88 1
a88 1
					STENCIL_WRITE_MASK(mask));
d93 1
a93 1
i915StencilOpSeparate(GLcontext *ctx, GLenum face, GLenum fail, GLenum zfail,
d96 3
a98 3
   i915ContextPtr i915 = I915_CONTEXT(ctx);
   int fop = intel_translate_stencil_op(fail); 
   int dfop = intel_translate_stencil_op(zfail); 
d102 3
a104 5
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s: fail : %s, zfail: %s, zpass : %s\n", __FUNCTION__,
	      _mesa_lookup_enum_by_nr(fail),
	      _mesa_lookup_enum_by_nr(zfail),
	      _mesa_lookup_enum_by_nr(zpass));
d109 2
a110 2
					S5_STENCIL_PASS_Z_FAIL_MASK |
					S5_STENCIL_PASS_Z_PASS_MASK);
d113 4
a116 2
				       (dfop << S5_STENCIL_PASS_Z_FAIL_SHIFT) |
				       (dpop << S5_STENCIL_PASS_Z_PASS_SHIFT));
d119 2
a120 1
static void i915AlphaFunc(GLcontext *ctx, GLenum func, GLfloat ref)
d122 2
a123 2
   i915ContextPtr i915 = I915_CONTEXT(ctx);
   int test = intel_translate_compare_func( func );
d130 1
a130 1
					S6_ALPHA_REF_MASK);
d132 2
a133 1
				       (((GLuint)refByte) << S6_ALPHA_REF_SHIFT));
d142 2
a143 1
static void i915EvalLogicOpBlendState(GLcontext *ctx)
d145 1
a145 1
   i915ContextPtr i915 = I915_CONTEXT(ctx);
d149 1
a149 1
   if (ctx->Color._LogicOpEnabled) {
d152 2
a153 1
   } else {
d157 4
a160 3
	 i915->state.Ctx[I915_CTXREG_LIS6] |= S6_CBUF_BLEND_ENABLE;
      } else {
	 i915->state.Ctx[I915_CTXREG_LIS6] &= ~S6_CBUF_BLEND_ENABLE;
d165 2
a166 1
static void i915BlendColor(GLcontext *ctx, const GLfloat color[4])
d168 1
a168 1
   i915ContextPtr i915 = I915_CONTEXT(ctx);
d171 2
a172 3
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s\n", __FUNCTION__);

d179 2
a180 1
   i915->state.Ctx[I915_CTXREG_BLENDCOLOR1] = (a<<24) | (r<<16) | (g<<8) | b;
d191 2
a192 1
static GLuint translate_blend_equation( GLenum mode )
d195 12
a206 6
   case GL_FUNC_ADD: return BLENDFUNC_ADD; 
   case GL_MIN: return BLENDFUNC_MIN; 
   case GL_MAX: return BLENDFUNC_MAX; 
   case GL_FUNC_SUBTRACT: return BLENDFUNC_SUBTRACT; 
   case GL_FUNC_REVERSE_SUBTRACT: return BLENDFUNC_REVERSE_SUBTRACT; 
   default: return 0;
d210 12
a221 13
static void i915UpdateBlendState( GLcontext *ctx )
{
   i915ContextPtr i915 = I915_CONTEXT(ctx);
   GLuint iab = (i915->state.Ctx[I915_CTXREG_IAB] & 
		 ~(IAB_SRC_FACTOR_MASK |
		   IAB_DST_FACTOR_MASK |
		   (BLENDFUNC_MASK << IAB_FUNC_SHIFT) |
		   IAB_ENABLE));

   GLuint lis6 = (i915->state.Ctx[I915_CTXREG_LIS6] & 
		  ~(S6_CBUF_SRC_BLEND_FACT_MASK |
		    S6_CBUF_DST_BLEND_FACT_MASK |
		    S6_CBUF_BLEND_FUNC_MASK));
d238 7
a244 7
   lis6 |= SRC_BLND_FACT(intel_translate_blend_factor(srcRGB)); 
   lis6 |= DST_BLND_FACT(intel_translate_blend_factor(dstRGB)); 
   lis6 |= translate_blend_equation( eqRGB ) << S6_CBUF_BLEND_FUNC_SHIFT;

   iab |= SRC_ABLND_FACT(intel_translate_blend_factor(srcA)); 
   iab |= DST_ABLND_FACT(intel_translate_blend_factor(dstA)); 
   iab |= translate_blend_equation( eqA ) << IAB_FUNC_SHIFT;
d246 1
a246 1
   if (srcA != srcRGB || dstA != dstRGB || eqA != eqRGB) 
d261 5
a265 5
static void i915BlendFuncSeparate(GLcontext *ctx, GLenum srcRGB, 
				 GLenum dstRGB, GLenum srcA,
				 GLenum dstA )
{  
   i915UpdateBlendState( ctx );
d269 2
a270 2
static void i915BlendEquationSeparate(GLcontext *ctx, GLenum eqRGB,
				     GLenum eqA) 
d272 1
a272 1
   i915UpdateBlendState( ctx );
d276 2
a277 1
static void i915DepthFunc(GLcontext *ctx, GLenum func)
d279 2
a280 5
   i915ContextPtr i915 = I915_CONTEXT(ctx);
   int test = intel_translate_compare_func( func );

   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s\n", __FUNCTION__);
d282 2
d289 2
a290 1
static void i915DepthMask(GLcontext *ctx, GLboolean flag)
d292 1
a292 4
   i915ContextPtr i915 = I915_CONTEXT(ctx);

   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s flag (%d)\n", __FUNCTION__, flag);
d294 2
d310 2
a311 1
static void i915PolygonStipple( GLcontext *ctx, const GLubyte *mask )
d313 2
a314 2
   i915ContextPtr i915 = I915_CONTEXT(ctx);
   const GLubyte *m = mask;
d316 1
a316 1
   int i,j,k;
d318 1
a318 1
		 i915->intel.reduced_primitive == GL_TRIANGLES);
d326 22
a347 12
   p[0] = mask[12] & 0xf; p[0] |= p[0] << 4;
   p[1] = mask[8] & 0xf; p[1] |= p[1] << 4;
   p[2] = mask[4] & 0xf; p[2] |= p[2] << 4;
   p[3] = mask[0] & 0xf; p[3] |= p[3] << 4;

   for (k = 0 ; k < 8 ; k++)
      for (j = 3 ; j >= 0; j--)
	 for (i = 0 ; i < 4 ; i++, m++)
	    if (*m != p[j]) {
	       i915->intel.hw_stipple = 0;
	       return;
	    }
d350 2
a351 3
	      ((p[1] & 0xf) << 4) |
	      ((p[2] & 0xf) << 8) |
	      ((p[3] & 0xf) << 12));
d372 2
a373 2
static void i915Scissor(GLcontext *ctx, GLint x, GLint y, 
			GLsizei w, GLsizei h)
d375 1
a375 2
   i915ContextPtr i915 = I915_CONTEXT(ctx);
   intelScreenPrivate *screen = i915->intel.intelScreen;
d378 1
a378 1
   if (!i915->intel.driDrawable)
d381 1
a381 18
   x1 = x;
   y1 = i915->intel.driDrawable->h - (y + h);
   x2 = x + w - 1;
   y2 = y1 + h - 1;

   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "[%s] x(%d) y(%d) w(%d) h(%d)\n", __FUNCTION__,
	      x, y, w, h);

   if (x1 < 0) x1 = 0;
   if (y1 < 0) y1 = 0;
   if (x2 < 0) x2 = 0;
   if (y2 < 0) y2 = 0;

   if (x2 >= screen->width) x2 = screen->width-1;
   if (y2 >= screen->height) y2 = screen->height-1;
   if (x1 >= screen->width) x1 = screen->width-1;
   if (y1 >= screen->height) y1 = screen->height-1;
d383 23
d412 2
a413 1
static void i915LogicOp(GLcontext *ctx, GLenum opcode)
d415 1
a415 1
   i915ContextPtr i915 = I915_CONTEXT(ctx);
d418 2
a419 3
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s\n", __FUNCTION__);

d427 2
a428 1
static void i915CullFaceFrontFace(GLcontext *ctx, GLenum unused)
d430 1
a430 1
   i915ContextPtr i915 = I915_CONTEXT(ctx);
d433 2
a434 2
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s\n", __FUNCTION__);
d442 2
d445 1
a445 1
	 mode ^= (S4_CULLMODE_CW ^ S4_CULLMODE_CCW);
d447 1
a447 1
	 mode ^= (S4_CULLMODE_CW ^ S4_CULLMODE_CCW);
d458 2
a459 1
static void i915LineWidth( GLcontext *ctx, GLfloat widthf )
d461 1
a461 1
   i915ContextPtr i915 = I915_CONTEXT( ctx );
d465 3
a467 4
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s\n", __FUNCTION__);

   width = (int)(widthf * 2);
d477 2
a478 1
static void i915PointSize(GLcontext *ctx, GLfloat size)
d480 1
a480 1
   i915ContextPtr i915 = I915_CONTEXT(ctx);
d482 1
a482 4
   GLint point_size = (int)size;

   if (INTEL_DEBUG&DEBUG_DRI)
     fprintf(stderr, "%s\n", __FUNCTION__);
d484 2
d500 3
a502 3
static void i915ColorMask(GLcontext *ctx,
			 GLboolean r, GLboolean g,
			 GLboolean b, GLboolean a)
d504 1
a504 1
   i915ContextPtr i915 = I915_CONTEXT( ctx );
d507 2
a508 2
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s r(%d) g(%d) b(%d) a(%d)\n", __FUNCTION__, r, g, b, a);
d510 8
a517 4
   if (!r) tmp |= S5_WRITEDISABLE_RED;
   if (!g) tmp |= S5_WRITEDISABLE_GREEN;
   if (!b) tmp |= S5_WRITEDISABLE_BLUE;
   if (!a) tmp |= S5_WRITEDISABLE_ALPHA;
d525 2
a526 1
static void update_specular( GLcontext *ctx )
d530 1
a530 2
   INTEL_CONTEXT(ctx)->NewGLState |= _NEW_TEXTURE;
   I915_CONTEXT(ctx)->tex_program.translated = 0; 
d533 2
a534 2
static void i915LightModelfv(GLcontext *ctx, GLenum pname, 
			     const GLfloat *param)
d536 2
a537 3
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s\n", __FUNCTION__);

d539 1
a539 1
      update_specular( ctx );
d543 2
a544 1
static void i915ShadeModel(GLcontext *ctx, GLenum mode)
d546 1
a546 1
   i915ContextPtr i915 = I915_CONTEXT(ctx);
d550 8
a557 7
     i915->state.Ctx[I915_CTXREG_LIS4] &= ~(S4_FLATSHADE_ALPHA | 
					  S4_FLATSHADE_COLOR | 
					  S4_FLATSHADE_SPECULAR);
   } else {
     i915->state.Ctx[I915_CTXREG_LIS4] |= (S4_FLATSHADE_ALPHA | 
					 S4_FLATSHADE_COLOR | 
					 S4_FLATSHADE_SPECULAR);
d564 2
a565 1
void i915_update_fog( GLcontext *ctx )
d567 1
a567 1
   i915ContextPtr i915 = I915_CONTEXT(ctx);
d571 1
a571 1
   
a573 1
      
d581 7
a587 4

      try_pixel_fog = (ctx->Fog.FogCoordinateSource == GL_FRAGMENT_DEPTH_EXT &&
		       ctx->Hint.Fog == GL_NICEST && 
		       0);	/* XXX - DISABLE -- Need ortho fallback */
a593 1

d597 1
a597 1
	 
d600 29
a628 27
	 if (ctx->Fog.End <= ctx->Fog.Start) {
	    /* XXX - this won't work with fragment programs.  Need to
	     * either fallback or append fog instructions to end of
	     * program in the case of linear fog.
	     */
	    i915->state.Fog[I915_FOGREG_MODE1] |= FMC1_FOGFUNC_VERTEX;
	    i915->vertex_fog = I915_FOG_VERTEX;
	 }
	 else {
	    GLfloat c1 = ctx->Fog.End/(ctx->Fog.End-ctx->Fog.Start);
	    GLfloat c2 = 1.0/(ctx->Fog.End-ctx->Fog.Start);

	    i915->state.Fog[I915_FOGREG_MODE1] &= ~FMC1_C1_MASK;
	    i915->state.Fog[I915_FOGREG_MODE1] |= FMC1_FOGFUNC_PIXEL_LINEAR;
	    i915->state.Fog[I915_FOGREG_MODE1] |= 
	       ((GLuint)(c1 * FMC1_C1_ONE)) & FMC1_C1_MASK;

	    if (i915->state.Fog[I915_FOGREG_MODE1] & FMC1_FOGINDEX_Z) {
	       i915->state.Fog[I915_FOGREG_MODE2] = (GLuint)(c2 * FMC2_C2_ONE);
	    }
	    else {
	       union { float f; int i; } fi;
	       fi.f = c2; 
	       i915->state.Fog[I915_FOGREG_MODE2] = fi.i; 
	    }
	 }
	 break;
d630 2
a631 2
	 i915->state.Fog[I915_FOGREG_MODE1] |= FMC1_FOGFUNC_PIXEL_EXP;
	 break;
d633 2
a634 2
	 i915->state.Fog[I915_FOGREG_MODE1] |= FMC1_FOGFUNC_PIXEL_EXP2;
	 break;
d636 1
a636 1
	 break;
d639 1
a639 1
   else /* if (i915->vertex_fog != I915_FOG_VERTEX) */ {      
d646 6
a651 8
   {
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      I915_ACTIVESTATE(i915, I915_UPLOAD_FOG, enabled);
      if (enabled)
	 i915->state.Ctx[I915_CTXREG_LIS5] |= S5_FOG_ENABLE;
      else
	 i915->state.Ctx[I915_CTXREG_LIS5] &= ~S5_FOG_ENABLE;
   }
d653 5
a657 4
   if (enabled) {
      _tnl_allow_vertex_fog( ctx, (i915->vertex_fog == I915_FOG_VERTEX) ); 
      _tnl_allow_pixel_fog( ctx, (i915->vertex_fog != I915_FOG_VERTEX) ); 
   }
d660 2
a661 1
static void i915Fogfv(GLcontext *ctx, GLenum pname, const GLfloat *param)
d663 1
a663 1
   i915ContextPtr i915 = I915_CONTEXT(ctx);
d666 1
a666 1
   case GL_FOG_COORDINATE_SOURCE_EXT: 
d669 1
a669 1
   case GL_FOG_END: 
d676 2
a677 2
	 i915->state.Fog[I915_FOGREG_MODE3] = (GLuint)(ctx->Fog.Density *
						     FMC3_D_ONE);
d680 3
a682 3
	 union { float f; int i; } fi;
	 fi.f = ctx->Fog.Density; 
	 i915->state.Fog[I915_FOGREG_MODE3] = fi.i; 
d686 1
a686 1
   case GL_FOG_COLOR: 
d688 5
a692 5
      i915->state.Fog[I915_FOGREG_COLOR] = 
	 (_3DSTATE_FOG_COLOR_CMD | 
	  ((GLubyte)(ctx->Fog.Color[0]*255.0F) << 16) |
	  ((GLubyte)(ctx->Fog.Color[1]*255.0F) << 8) |
	  ((GLubyte)(ctx->Fog.Color[2]*255.0F) << 0));
d700 2
a701 1
static void i915Hint(GLcontext *ctx, GLenum target, GLenum state)
d714 2
a715 1
static void i915Enable(GLcontext *ctx, GLenum cap, GLboolean state)
d717 1
a717 1
   i915ContextPtr i915 = I915_CONTEXT(ctx);
d719 1
a719 1
   switch(cap) {
d725 1
a725 1
      update_specular( ctx );
d731 1
a731 1
	 i915->state.Ctx[I915_CTXREG_LIS6] |= S6_ALPHA_TEST_ENABLE;
d733 1
a733 1
	 i915->state.Ctx[I915_CTXREG_LIS6] &= ~S6_ALPHA_TEST_ENABLE;
d745 2
a746 2
      if (i915->intel.intelScreen->cpp == 2)
	 FALLBACK( &i915->intel, I915_FALLBACK_LOGICOP, state );
d755 1
a755 1
	 i915->state.Ctx[I915_CTXREG_LIS5] |= S5_COLOR_DITHER_ENABLE;
d757 1
a757 1
	 i915->state.Ctx[I915_CTXREG_LIS5] &= ~S5_COLOR_DITHER_ENABLE;
d763 1
a763 1
	 i915->state.Ctx[I915_CTXREG_LIS6] |= S6_DEPTH_TEST_ENABLE;
d765 1
a765 1
	 i915->state.Ctx[I915_CTXREG_LIS6] &= ~S6_DEPTH_TEST_ENABLE;
d767 1
a767 1
      i915DepthMask( ctx, ctx->Depth.Mask );
d773 2
a774 2
	 i915->state.Buffer[I915_DESTREG_SENABLE] = (_3DSTATE_SCISSOR_ENABLE_CMD |
						   ENABLE_SCISSOR_RECT);
d776 2
a777 2
	 i915->state.Buffer[I915_DESTREG_SENABLE] = (_3DSTATE_SCISSOR_ENABLE_CMD |
						   DISABLE_SCISSOR_RECT);
d783 1
a783 1
	 i915->state.Ctx[I915_CTXREG_LIS4] |= S4_LINE_ANTIALIAS_ENABLE;
d785 1
a785 1
	 i915->state.Ctx[I915_CTXREG_LIS4] &= ~S4_LINE_ANTIALIAS_ENABLE;
d796 19
a814 10
      if (i915->intel.hw_stencil) {
	 I915_STATECHANGE(i915, I915_UPLOAD_CTX);
	 if (state)
	    i915->state.Ctx[I915_CTXREG_LIS5] |= (S5_STENCIL_TEST_ENABLE |
						S5_STENCIL_WRITE_ENABLE);
	 else
	    i915->state.Ctx[I915_CTXREG_LIS5] &= ~(S5_STENCIL_TEST_ENABLE | 
						 S5_STENCIL_WRITE_ENABLE);
      } else {
	 FALLBACK( &i915->intel, I915_FALLBACK_STENCIL, state );
d823 7
a829 8
      if (i915->intel.hw_stipple && 
	  i915->intel.reduced_primitive == GL_TRIANGLES)
      {
	 I915_STATECHANGE(i915, I915_UPLOAD_STIPPLE);
	 if (state)
	    i915->state.Stipple[I915_STPREG_ST1] |= ST1_ENABLE;
	 else
	    i915->state.Stipple[I915_STPREG_ST1] &= ~ST1_ENABLE;
a833 1
      FALLBACK( &i915->intel, I915_FALLBACK_POLYGON_SMOOTH, state );
a836 1
      FALLBACK( &i915->intel, I915_FALLBACK_POINT_SMOOTH, state );
d845 2
a846 1
static void i915_init_packets( i915ContextPtr i915 )
a847 2
   intelScreenPrivate *screen = i915->intel.intelScreen;

d857 4
a860 6
      i915->state.Ctx[I915_CTXREG_LI] = (_3DSTATE_LOAD_STATE_IMMEDIATE_1 | 
				       I1_LOAD_S(2) |
				       I1_LOAD_S(4) |
				       I1_LOAD_S(5) |
				       I1_LOAD_S(6) | 
				       (4));
d865 2
a866 2
      if (screen->cpp == 2)
	 i915->state.Ctx[I915_CTXREG_LIS5] |= S5_COLOR_DITHER_ENABLE;
d870 1
a870 1
					 (2 << S6_TRISTRIP_PV_SHIFT));
d873 10
a882 13
					   ENABLE_LOGIC_OP_FUNC |
					   LOGIC_OP_FUNC(LOGICOP_COPY) |
					   ENABLE_STENCIL_TEST_MASK |
					   STENCIL_TEST_MASK(0xff) |
					   ENABLE_STENCIL_WRITE_MASK |
					   STENCIL_WRITE_MASK(0xff));


      i915->state.Ctx[I915_CTXREG_IAB] = (_3DSTATE_INDEPENDENT_ALPHA_BLEND_CMD |
					IAB_MODIFY_ENABLE |
					IAB_MODIFY_FUNC |
					IAB_MODIFY_SRC_FACTOR |
					IAB_MODIFY_DST_FACTOR);
d884 2
a885 1
      i915->state.Ctx[I915_CTXREG_BLENDCOLOR0] = _3DSTATE_CONST_BLEND_COLOR_CMD;
d900 5
a904 5
					  FMC1_FOGFUNC_VERTEX |
					  FMC1_FOGINDEX_MODIFY_ENABLE |
					  FMC1_FOGINDEX_W |
					  FMC1_C1_C2_MODIFY_ENABLE |
					  FMC1_DENSITY_MODIFY_ENABLE);
a907 1

a908 19
      I915_STATECHANGE(i915, I915_UPLOAD_BUFFERS);
      /* color buffer offset/stride */
      i915->state.Buffer[I915_DESTREG_CBUFADDR0] = _3DSTATE_BUF_INFO_CMD;
      i915->state.Buffer[I915_DESTREG_CBUFADDR1] = 
	 (BUF_3D_ID_COLOR_BACK | 
	  BUF_3D_PITCH(screen->front.pitch) |  /* pitch in bytes */
	  BUF_3D_USE_FENCE);
      /*i915->state.Buffer[I915_DESTREG_CBUFADDR2] is the offset */


      /* depth/Z buffer offset/stride */
      i915->state.Buffer[I915_DESTREG_DBUFADDR0] = _3DSTATE_BUF_INFO_CMD;
      i915->state.Buffer[I915_DESTREG_DBUFADDR1] = 
	 (BUF_3D_ID_DEPTH |
	  BUF_3D_PITCH(screen->depth.pitch) |  /* pitch in bytes */
	  BUF_3D_USE_FENCE);
      i915->state.Buffer[I915_DESTREG_DBUFADDR2] = screen->depth.offset;


a910 22
      /* color/depth pixel format */
      switch (screen->fbFormat) {
      case DV_PF_555:
      case DV_PF_565:
	 i915->state.Buffer[I915_DESTREG_DV1] = (DSTORG_HORT_BIAS(0x8) | /* .5 */
					       DSTORG_VERT_BIAS(0x8) | /* .5 */
					       LOD_PRECLAMP_OGL |
					       TEX_DEFAULT_COLOR_OGL |
					       DITHER_FULL_ALWAYS |
					       screen->fbFormat |
					       DEPTH_FRMT_16_FIXED);
	 break;
      case DV_PF_8888:
	 i915->state.Buffer[I915_DESTREG_DV1] = (DSTORG_HORT_BIAS(0x8) | /* .5 */
					       DSTORG_VERT_BIAS(0x8) | /* .5 */
					       LOD_PRECLAMP_OGL |
					       TEX_DEFAULT_COLOR_OGL |
					       screen->fbFormat |
					       DEPTH_FRMT_24_FIXED_8_OTHER);
	 break;
      }

d912 2
a913 2
      i915->state.Buffer[I915_DESTREG_SENABLE] = (_3DSTATE_SCISSOR_ENABLE_CMD |
						DISABLE_SCISSOR_RECT);
d920 13
d936 4
a939 5
   i915->state.active = (I915_UPLOAD_PROGRAM | 
			 I915_UPLOAD_STIPPLE | 
			 I915_UPLOAD_CTX | 
			 I915_UPLOAD_BUFFERS | 
			 I915_UPLOAD_INVARIENT);
d942 2
a943 1
void i915InitStateFunctions( struct dd_function_table *functions )
d970 2
a971 1
void i915InitState( i915ContextPtr i915 )
d975 1
a975 1
   i915_init_packets( i915 );
d977 1
a977 1
   intelInitState( ctx );
d979 1
a979 1
   memcpy( &i915->initial, &i915->state, sizeof(i915->state) );
a981 7







@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d144 1
a144 1
   if (RGBA_LOGICOP_ENABLED(ctx)) {
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d544 4
a547 7
#if 0
      /* XXX - DISABLED -- Need ortho fallback */
      try_pixel_fog = (ctx->Fog.FogCoordinateSource == GL_FRAGMENT_DEPTH_EXT
                       &&ctx->Hint.Fog == GL_NICEST);
#else
      try_pixel_fog = 0;
#endif
d554 1
d570 2
a571 2
            GLfloat c2 = 1.0 / (ctx->Fog.End - ctx->Fog.Start);
            GLfloat c1 = ctx->Fog.End * c2;
d579 1
a579 2
	       i915->state.Fog[I915_FOGREG_MODE2]
                  = (GLuint)(c2 * FMC2_C2_ONE);
d582 1
a582 1
	       fi_type fi;
d605 13
a617 12
   I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   I915_ACTIVESTATE(i915, I915_UPLOAD_FOG, enabled);
   if (enabled)
      i915->state.Ctx[I915_CTXREG_LIS5] |= S5_FOG_ENABLE;
   else
      i915->state.Ctx[I915_CTXREG_LIS5] &= ~S5_FOG_ENABLE;

   /* Always enable pixel fog.  Vertex fog using fog coord will conflict
    * with fog code appended onto fragment program.
    */
    _tnl_allow_vertex_fog( ctx, 0 );
    _tnl_allow_pixel_fog( ctx, 1 );
d620 1
a620 2
static void
i915Fogfv(GLcontext *ctx, GLenum pname, const GLfloat *param)
d635 2
a636 2
	 i915->state.Fog[I915_FOGREG_MODE3]
            = (GLuint)(ctx->Fog.Density * FMC3_D_ONE);
d814 1
a814 1
				       (3));
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d29 5
a33 5
#include "main/glheader.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/enums.h"
#include "main/dd.h"
a38 3
#include "drivers/common/driverfuncs.h"

#include "intel_fbo.h"
a40 1
#include "intel_buffers.h"
a44 1
#define FILE_DEBUG_FLAG DEBUG_STATE
d46 4
a49 2
void
i915_update_stencil(struct gl_context * ctx)
d51 9
a59 5
   struct i915_context *i915 = I915_CONTEXT(ctx);
   GLuint front_ref, front_writemask, front_mask;
   GLenum front_func, front_fail, front_pass_z_fail, front_pass_z_pass;
   GLuint back_ref, back_writemask, back_mask;
   GLenum back_func, back_fail, back_pass_z_fail, back_pass_z_pass;
d62 1
a62 40

   /* The 915 considers CW to be "front" for two-sided stencil, so choose
    * appropriately.
    */
   /* _NEW_POLYGON | _NEW_STENCIL */
   if (ctx->Polygon.FrontFace == GL_CW) {
      front_ref = ctx->Stencil.Ref[0];
      front_mask = ctx->Stencil.ValueMask[0];
      front_writemask = ctx->Stencil.WriteMask[0];
      front_func = ctx->Stencil.Function[0];
      front_fail = ctx->Stencil.FailFunc[0];
      front_pass_z_fail = ctx->Stencil.ZFailFunc[0];
      front_pass_z_pass = ctx->Stencil.ZPassFunc[0];
      back_ref = ctx->Stencil.Ref[ctx->Stencil._BackFace];
      back_mask = ctx->Stencil.ValueMask[ctx->Stencil._BackFace];
      back_writemask = ctx->Stencil.WriteMask[ctx->Stencil._BackFace];
      back_func = ctx->Stencil.Function[ctx->Stencil._BackFace];
      back_fail = ctx->Stencil.FailFunc[ctx->Stencil._BackFace];
      back_pass_z_fail = ctx->Stencil.ZFailFunc[ctx->Stencil._BackFace];
      back_pass_z_pass = ctx->Stencil.ZPassFunc[ctx->Stencil._BackFace];
   } else {
      front_ref = ctx->Stencil.Ref[ctx->Stencil._BackFace];
      front_mask = ctx->Stencil.ValueMask[ctx->Stencil._BackFace];
      front_writemask = ctx->Stencil.WriteMask[ctx->Stencil._BackFace];
      front_func = ctx->Stencil.Function[ctx->Stencil._BackFace];
      front_fail = ctx->Stencil.FailFunc[ctx->Stencil._BackFace];
      front_pass_z_fail = ctx->Stencil.ZFailFunc[ctx->Stencil._BackFace];
      front_pass_z_pass = ctx->Stencil.ZPassFunc[ctx->Stencil._BackFace];
      back_ref = ctx->Stencil.Ref[0];
      back_mask = ctx->Stencil.ValueMask[0];
      back_writemask = ctx->Stencil.WriteMask[0];
      back_func = ctx->Stencil.Function[0];
      back_fail = ctx->Stencil.FailFunc[0];
      back_pass_z_fail = ctx->Stencil.ZFailFunc[0];
      back_pass_z_pass = ctx->Stencil.ZPassFunc[0];
   }

   /* Set front state. */
   i915->state.Ctx[I915_CTXREG_STATE4] &= ~(MODE4_ENABLE_STENCIL_TEST_MASK |
					    MODE4_ENABLE_STENCIL_WRITE_MASK);
d64 1
a64 3
					   ENABLE_STENCIL_WRITE_MASK |
					   STENCIL_TEST_MASK(front_mask) |
					   STENCIL_WRITE_MASK(front_writemask));
d67 4
a70 40
					  S5_STENCIL_TEST_FUNC_MASK |
					  S5_STENCIL_FAIL_MASK |
					  S5_STENCIL_PASS_Z_FAIL_MASK |
					  S5_STENCIL_PASS_Z_PASS_MASK);

   i915->state.Ctx[I915_CTXREG_LIS5] |=
      (front_ref << S5_STENCIL_REF_SHIFT) |
      (intel_translate_compare_func(front_func) << S5_STENCIL_TEST_FUNC_SHIFT) |
      (intel_translate_stencil_op(front_fail) << S5_STENCIL_FAIL_SHIFT) |
      (intel_translate_stencil_op(front_pass_z_fail) <<
       S5_STENCIL_PASS_Z_FAIL_SHIFT) |
      (intel_translate_stencil_op(front_pass_z_pass) <<
       S5_STENCIL_PASS_Z_PASS_SHIFT);

   /* Set back state if different from front. */
   if (ctx->Stencil._TestTwoSide) {
      i915->state.Ctx[I915_CTXREG_BF_STENCIL_OPS] &=
	 ~(BFO_STENCIL_REF_MASK |
	   BFO_STENCIL_TEST_MASK |
	   BFO_STENCIL_FAIL_MASK |
	   BFO_STENCIL_PASS_Z_FAIL_MASK |
	   BFO_STENCIL_PASS_Z_PASS_MASK);
      i915->state.Ctx[I915_CTXREG_BF_STENCIL_OPS] |= BFO_STENCIL_TWO_SIDE |
	 (back_ref << BFO_STENCIL_REF_SHIFT) |
	 (intel_translate_compare_func(back_func) << BFO_STENCIL_TEST_SHIFT) |
	 (intel_translate_stencil_op(back_fail) << BFO_STENCIL_FAIL_SHIFT) |
	 (intel_translate_stencil_op(back_pass_z_fail) <<
	  BFO_STENCIL_PASS_Z_FAIL_SHIFT) |
	 (intel_translate_stencil_op(back_pass_z_pass) <<
	  BFO_STENCIL_PASS_Z_PASS_SHIFT);

      i915->state.Ctx[I915_CTXREG_BF_STENCIL_MASKS] &=
	 ~(BFM_STENCIL_TEST_MASK_MASK |
	   BFM_STENCIL_WRITE_MASK_MASK);
      i915->state.Ctx[I915_CTXREG_BF_STENCIL_MASKS] |=
	 BFM_STENCIL_TEST_MASK(back_mask) |
	 BFM_STENCIL_WRITE_MASK(back_writemask);
   } else {
      i915->state.Ctx[I915_CTXREG_BF_STENCIL_OPS] &= ~BFO_STENCIL_TWO_SIDE;
   }
d74 1
a74 2
i915StencilFuncSeparate(struct gl_context * ctx, GLenum face, GLenum func, GLint ref,
                        GLuint mask)
d76 11
a88 4
static void
i915StencilMaskSeparate(struct gl_context * ctx, GLenum face, GLuint mask)
{
}
d91 1
a91 1
i915StencilOpSeparate(struct gl_context * ctx, GLenum face, GLenum fail, GLenum zfail,
d94 21
d117 1
a117 2
static void
i915AlphaFunc(struct gl_context * ctx, GLenum func, GLfloat ref)
d119 2
a120 2
   struct i915_context *i915 = I915_CONTEXT(ctx);
   int test = intel_translate_compare_func(func);
d127 1
a127 1
                                          S6_ALPHA_REF_MASK);
d129 1
a129 2
                                         (((GLuint) refByte) <<
                                          S6_ALPHA_REF_SHIFT));
d138 1
a138 2
static void
i915EvalLogicOpBlendState(struct gl_context * ctx)
d140 1
a140 1
   struct i915_context *i915 = I915_CONTEXT(ctx);
d147 1
a147 2
   }
   else {
d151 3
a153 4
         i915->state.Ctx[I915_CTXREG_LIS6] |= S6_CBUF_BLEND_ENABLE;
      }
      else {
         i915->state.Ctx[I915_CTXREG_LIS6] &= ~S6_CBUF_BLEND_ENABLE;
d158 1
a158 2
static void
i915BlendColor(struct gl_context * ctx, const GLfloat color[4])
d160 1
a160 1
   struct i915_context *i915 = I915_CONTEXT(ctx);
d163 3
a165 2
   DBG("%s\n", __FUNCTION__);
   
d172 1
a172 2
   i915->state.Ctx[I915_CTXREG_BLENDCOLOR1] =
      (a << 24) | (r << 16) | (g << 8) | b;
d183 1
a183 2
static GLuint
translate_blend_equation(GLenum mode)
d186 6
a191 12
   case GL_FUNC_ADD:
      return BLENDFUNC_ADD;
   case GL_MIN:
      return BLENDFUNC_MIN;
   case GL_MAX:
      return BLENDFUNC_MAX;
   case GL_FUNC_SUBTRACT:
      return BLENDFUNC_SUBTRACT;
   case GL_FUNC_REVERSE_SUBTRACT:
      return BLENDFUNC_REVERSE_SUBTRACT;
   default:
      return 0;
d195 13
a207 12
static void
i915UpdateBlendState(struct gl_context * ctx)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);
   GLuint iab = (i915->state.Ctx[I915_CTXREG_IAB] &
                 ~(IAB_SRC_FACTOR_MASK |
                   IAB_DST_FACTOR_MASK |
                   (BLENDFUNC_MASK << IAB_FUNC_SHIFT) | IAB_ENABLE));

   GLuint lis6 = (i915->state.Ctx[I915_CTXREG_LIS6] &
                  ~(S6_CBUF_SRC_BLEND_FACT_MASK |
                    S6_CBUF_DST_BLEND_FACT_MASK | S6_CBUF_BLEND_FUNC_MASK));
d224 7
a230 7
   lis6 |= SRC_BLND_FACT(intel_translate_blend_factor(srcRGB));
   lis6 |= DST_BLND_FACT(intel_translate_blend_factor(dstRGB));
   lis6 |= translate_blend_equation(eqRGB) << S6_CBUF_BLEND_FUNC_SHIFT;

   iab |= SRC_ABLND_FACT(intel_translate_blend_factor(srcA));
   iab |= DST_ABLND_FACT(intel_translate_blend_factor(dstA));
   iab |= translate_blend_equation(eqA) << IAB_FUNC_SHIFT;
d232 1
a232 1
   if (srcA != srcRGB || dstA != dstRGB || eqA != eqRGB)
d247 5
a251 5
static void
i915BlendFuncSeparate(struct gl_context * ctx, GLenum srcRGB,
                      GLenum dstRGB, GLenum srcA, GLenum dstA)
{
   i915UpdateBlendState(ctx);
d255 2
a256 2
static void
i915BlendEquationSeparate(struct gl_context * ctx, GLenum eqRGB, GLenum eqA)
d258 1
a258 1
   i915UpdateBlendState(ctx);
d262 1
a262 2
static void
i915DepthFunc(struct gl_context * ctx, GLenum func)
d264 5
a268 2
   struct i915_context *i915 = I915_CONTEXT(ctx);
   int test = intel_translate_compare_func(func);
a269 2
   DBG("%s\n", __FUNCTION__);
   
d275 1
a275 2
static void
i915DepthMask(struct gl_context * ctx, GLboolean flag)
d277 4
a280 1
   struct i915_context *i915 = I915_CONTEXT(ctx);
a281 2
   DBG("%s flag (%d)\n", __FUNCTION__, flag);
   
a289 57


/**
 * Update the viewport transformation matrix.  Depends on:
 *  - viewport pos/size
 *  - depthrange
 *  - window pos/size or FBO size
 */
void
intelCalcViewport(struct gl_context * ctx)
{
   struct intel_context *intel = intel_context(ctx);
   const GLfloat *v = ctx->Viewport._WindowMap.m;
   const GLfloat depthScale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
   GLfloat *m = intel->ViewportMatrix.m;
   GLfloat yScale, yBias;

   if (ctx->DrawBuffer->Name) {
      /* User created FBO */
      /* y=0=bottom */
      yScale = 1.0;
      yBias = 0.0;
   }
   else {
      /* window buffer, y=0=top */
      yScale = -1.0;
      yBias = ctx->DrawBuffer->Height;
   }

   m[MAT_SX] = v[MAT_SX];
   m[MAT_TX] = v[MAT_TX];

   m[MAT_SY] = v[MAT_SY] * yScale;
   m[MAT_TY] = v[MAT_TY] * yScale + yBias;

   m[MAT_SZ] = v[MAT_SZ] * depthScale;
   m[MAT_TZ] = v[MAT_TZ] * depthScale;
}


/** Called from ctx->Driver.Viewport() */
static void
i915Viewport(struct gl_context * ctx,
              GLint x, GLint y, GLsizei width, GLsizei height)
{
   intelCalcViewport(ctx);
}


/** Called from ctx->Driver.DepthRange() */
static void
i915DepthRange(struct gl_context * ctx, GLclampd nearval, GLclampd farval)
{
   intelCalcViewport(ctx);
}


d296 1
a296 2
static void
i915PolygonStipple(struct gl_context * ctx, const GLubyte * mask)
d298 2
a299 2
   struct i915_context *i915 = I915_CONTEXT(ctx);
   const GLubyte *m;
d301 1
a301 1
   int i, j, k;
d303 1
a303 1
                 i915->intel.reduced_primitive == GL_TRIANGLES);
d311 12
a322 22
   /* Use the already unpacked stipple data from the context rather than the
    * uninterpreted mask passed in.
    */
   mask = (const GLubyte *)ctx->PolygonStipple;
   m = mask;

   p[0] = mask[12] & 0xf;
   p[0] |= p[0] << 4;
   p[1] = mask[8] & 0xf;
   p[1] |= p[1] << 4;
   p[2] = mask[4] & 0xf;
   p[2] |= p[2] << 4;
   p[3] = mask[0] & 0xf;
   p[3] |= p[3] << 4;

   for (k = 0; k < 8; k++)
      for (j = 3; j >= 0; j--)
         for (i = 0; i < 4; i++, m++)
            if (*m != p[j]) {
               i915->intel.hw_stipple = 0;
               return;
            }
d325 3
a327 2
              ((p[1] & 0xf) << 4) |
              ((p[2] & 0xf) << 8) | ((p[3] & 0xf) << 12));
d348 2
a349 2
static void
i915Scissor(struct gl_context * ctx, GLint x, GLint y, GLsizei w, GLsizei h)
d351 2
a352 1
   struct i915_context *i915 = I915_CONTEXT(ctx);
d355 1
a355 1
   if (!ctx->DrawBuffer)
d358 18
a375 1
   DBG("%s %d,%d %dx%d\n", __FUNCTION__, x, y, w, h);
a376 23
   if (ctx->DrawBuffer->Name == 0) {
      x1 = x;
      y1 = ctx->DrawBuffer->Height - (y + h);
      x2 = x + w - 1;
      y2 = y1 + h - 1;
      DBG("%s %d..%d,%d..%d (inverted)\n", __FUNCTION__, x1, x2, y1, y2);
   }
   else {
      /* FBO - not inverted
       */
      x1 = x;
      y1 = y;
      x2 = x + w - 1;
      y2 = y + h - 1;
      DBG("%s %d..%d,%d..%d (not inverted)\n", __FUNCTION__, x1, x2, y1, y2);
   }
   
   x1 = CLAMP(x1, 0, ctx->DrawBuffer->Width - 1);
   y1 = CLAMP(y1, 0, ctx->DrawBuffer->Height - 1);
   x2 = CLAMP(x2, 0, ctx->DrawBuffer->Width - 1);
   y2 = CLAMP(y2, 0, ctx->DrawBuffer->Height - 1);
   
   DBG("%s %d..%d,%d..%d (clamped)\n", __FUNCTION__, x1, x2, y1, y2);
d383 1
a383 2
static void
i915LogicOp(struct gl_context * ctx, GLenum opcode)
d385 1
a385 1
   struct i915_context *i915 = I915_CONTEXT(ctx);
d388 3
a390 2
   DBG("%s\n", __FUNCTION__);
   
d398 1
a398 2
static void
i915CullFaceFrontFace(struct gl_context * ctx, GLenum unused)
d400 1
a400 1
   struct i915_context *i915 = I915_CONTEXT(ctx);
d403 2
a404 2
   DBG("%s %d\n", __FUNCTION__,
       ctx->DrawBuffer ? ctx->DrawBuffer->Name : 0);
a411 2
      if (ctx->DrawBuffer && ctx->DrawBuffer->Name != 0)
         mode ^= (S4_CULLMODE_CW ^ S4_CULLMODE_CCW);
d413 1
a413 1
         mode ^= (S4_CULLMODE_CW ^ S4_CULLMODE_CCW);
d415 1
a415 1
         mode ^= (S4_CULLMODE_CW ^ S4_CULLMODE_CCW);
d426 1
a426 2
static void
i915LineWidth(struct gl_context * ctx, GLfloat widthf)
d428 1
a428 1
   struct i915_context *i915 = I915_CONTEXT(ctx);
d432 5
a436 4
   DBG("%s\n", __FUNCTION__);
   
   width = (int) (widthf * 2);
   width = CLAMP(width, 1, 0xf);
d445 1
a445 2
static void
i915PointSize(struct gl_context * ctx, GLfloat size)
d447 1
a447 1
   struct i915_context *i915 = I915_CONTEXT(ctx);
d449 4
a452 1
   GLint point_size = (int) round(size);
d454 1
a454 3
   DBG("%s\n", __FUNCTION__);
   
   point_size = CLAMP(point_size, 1, 255);
a463 18
static void
i915PointParameterfv(struct gl_context * ctx, GLenum pname, const GLfloat *params)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);

   switch (pname) {
   case GL_POINT_SPRITE_COORD_ORIGIN:
      /* This could be supported, but it would require modifying the fragment
       * program to invert the y component of the texture coordinate by
       * inserting a 'SUB tc.y, {1.0}.xxxx, tc' instruction.
       */
      FALLBACK(&i915->intel, I915_FALLBACK_POINT_SPRITE_COORD_ORIGIN,
	       (params[0] != GL_UPPER_LEFT));
      break;
   }
}


d468 3
a470 3
static void
i915ColorMask(struct gl_context * ctx,
              GLboolean r, GLboolean g, GLboolean b, GLboolean a)
d472 1
a472 1
   struct i915_context *i915 = I915_CONTEXT(ctx);
d475 2
a476 2
   DBG("%s r(%d) g(%d) b(%d) a(%d)\n", __FUNCTION__, r, g, b,
       a);
d478 4
a481 8
   if (!r)
      tmp |= S5_WRITEDISABLE_RED;
   if (!g)
      tmp |= S5_WRITEDISABLE_GREEN;
   if (!b)
      tmp |= S5_WRITEDISABLE_BLUE;
   if (!a)
      tmp |= S5_WRITEDISABLE_ALPHA;
d489 1
a489 2
static void
update_specular(struct gl_context * ctx)
d493 2
a494 1
   intel_context(ctx)->NewGLState |= _NEW_TEXTURE;
d497 2
a498 2
static void
i915LightModelfv(struct gl_context * ctx, GLenum pname, const GLfloat * param)
d500 3
a502 2
   DBG("%s\n", __FUNCTION__);
   
d504 1
a504 1
      update_specular(ctx);
d508 1
a508 2
static void
i915ShadeModel(struct gl_context * ctx, GLenum mode)
d510 1
a510 1
   struct i915_context *i915 = I915_CONTEXT(ctx);
d514 7
a520 8
      i915->state.Ctx[I915_CTXREG_LIS4] &= ~(S4_FLATSHADE_ALPHA |
                                             S4_FLATSHADE_COLOR |
                                             S4_FLATSHADE_SPECULAR);
   }
   else {
      i915->state.Ctx[I915_CTXREG_LIS4] |= (S4_FLATSHADE_ALPHA |
                                            S4_FLATSHADE_COLOR |
                                            S4_FLATSHADE_SPECULAR);
d527 1
a527 2
void
i915_update_fog(struct gl_context * ctx)
d529 1
a529 1
   struct i915_context *i915 = I915_CONTEXT(ctx);
d533 2
a534 2

   if (ctx->FragmentProgram._Current) {
d536 1
d547 1
a547 1
                       && ctx->Hint.Fog == GL_NICEST);
d560 1
a560 1

d563 9
a571 10
         if (ctx->Fog.End <= ctx->Fog.Start) {
            /* XXX - this won't work with fragment programs.  Need to
             * either fallback or append fog instructions to end of
             * program in the case of linear fog.
             */
            printf("vertex fog!\n");
            i915->state.Fog[I915_FOGREG_MODE1] |= FMC1_FOGFUNC_VERTEX;
            i915->vertex_fog = I915_FOG_VERTEX;
         }
         else {
d575 16
a590 16
            i915->state.Fog[I915_FOGREG_MODE1] &= ~FMC1_C1_MASK;
            i915->state.Fog[I915_FOGREG_MODE1] |= FMC1_FOGFUNC_PIXEL_LINEAR;
            i915->state.Fog[I915_FOGREG_MODE1] |=
               ((GLuint) (c1 * FMC1_C1_ONE)) & FMC1_C1_MASK;

            if (i915->state.Fog[I915_FOGREG_MODE1] & FMC1_FOGINDEX_Z) {
               i915->state.Fog[I915_FOGREG_MODE2]
                  = (GLuint) (c2 * FMC2_C2_ONE);
            }
            else {
               fi_type fi;
               fi.f = c2;
               i915->state.Fog[I915_FOGREG_MODE2] = fi.i;
            }
         }
         break;
d592 2
a593 2
         i915->state.Fog[I915_FOGREG_MODE1] |= FMC1_FOGFUNC_PIXEL_EXP;
         break;
d595 2
a596 2
         i915->state.Fog[I915_FOGREG_MODE1] |= FMC1_FOGFUNC_PIXEL_EXP2;
         break;
d598 1
a598 1
         break;
d601 1
a601 1
   else { /* if (i915->vertex_fog != I915_FOG_VERTEX) */
d623 1
a623 1
i915Fogfv(struct gl_context * ctx, GLenum pname, const GLfloat * param)
d625 1
a625 1
   struct i915_context *i915 = I915_CONTEXT(ctx);
d628 1
a628 1
   case GL_FOG_COORDINATE_SOURCE_EXT:
d631 1
a631 1
   case GL_FOG_END:
d638 2
a639 2
         i915->state.Fog[I915_FOGREG_MODE3] =
            (GLuint) (ctx->Fog.Density * FMC3_D_ONE);
d642 3
a644 3
         fi_type fi;
         fi.f = ctx->Fog.Density;
         i915->state.Fog[I915_FOGREG_MODE3] = fi.i;
d648 1
a648 1
   case GL_FOG_COLOR:
d650 5
a654 5
      i915->state.Fog[I915_FOGREG_COLOR] =
         (_3DSTATE_FOG_COLOR_CMD |
          ((GLubyte) (ctx->Fog.Color[0] * 255.0F) << 16) |
          ((GLubyte) (ctx->Fog.Color[1] * 255.0F) << 8) |
          ((GLubyte) (ctx->Fog.Color[2] * 255.0F) << 0));
d662 1
a662 2
static void
i915Hint(struct gl_context * ctx, GLenum target, GLenum state)
d675 1
a675 2
static void
i915Enable(struct gl_context * ctx, GLenum cap, GLboolean state)
d677 1
a677 1
   struct i915_context *i915 = I915_CONTEXT(ctx);
d679 1
a679 1
   switch (cap) {
d685 1
a685 1
      update_specular(ctx);
d691 1
a691 1
         i915->state.Ctx[I915_CTXREG_LIS6] |= S6_ALPHA_TEST_ENABLE;
d693 1
a693 1
         i915->state.Ctx[I915_CTXREG_LIS6] &= ~S6_ALPHA_TEST_ENABLE;
d705 2
a706 2
      if (ctx->Visual.rgbBits == 16)
         FALLBACK(&i915->intel, I915_FALLBACK_LOGICOP, state);
d715 1
a715 1
         i915->state.Ctx[I915_CTXREG_LIS5] |= S5_COLOR_DITHER_ENABLE;
d717 1
a717 1
         i915->state.Ctx[I915_CTXREG_LIS5] &= ~S5_COLOR_DITHER_ENABLE;
d723 1
a723 1
         i915->state.Ctx[I915_CTXREG_LIS6] |= S6_DEPTH_TEST_ENABLE;
d725 1
a725 1
         i915->state.Ctx[I915_CTXREG_LIS6] &= ~S6_DEPTH_TEST_ENABLE;
d727 1
a727 1
      i915DepthMask(ctx, ctx->Depth.Mask);
d733 2
a734 2
         i915->state.Buffer[I915_DESTREG_SENABLE] =
            (_3DSTATE_SCISSOR_ENABLE_CMD | ENABLE_SCISSOR_RECT);
d736 2
a737 2
         i915->state.Buffer[I915_DESTREG_SENABLE] =
            (_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);
d743 1
a743 1
         i915->state.Ctx[I915_CTXREG_LIS4] |= S4_LINE_ANTIALIAS_ENABLE;
d745 1
a745 1
         i915->state.Ctx[I915_CTXREG_LIS4] &= ~S4_LINE_ANTIALIAS_ENABLE;
d756 10
a765 19
      {
         GLboolean hw_stencil = GL_FALSE;
         if (ctx->DrawBuffer) {
            struct intel_renderbuffer *irbStencil
               = intel_get_renderbuffer(ctx->DrawBuffer, BUFFER_STENCIL);
            hw_stencil = (irbStencil && irbStencil->region);
         }
         if (hw_stencil) {
            I915_STATECHANGE(i915, I915_UPLOAD_CTX);
            if (state)
               i915->state.Ctx[I915_CTXREG_LIS5] |= (S5_STENCIL_TEST_ENABLE |
                                                     S5_STENCIL_WRITE_ENABLE);
            else
               i915->state.Ctx[I915_CTXREG_LIS5] &= ~(S5_STENCIL_TEST_ENABLE |
                                                      S5_STENCIL_WRITE_ENABLE);
         }
         else {
            FALLBACK(&i915->intel, I915_FALLBACK_STENCIL, state);
         }
d774 8
a781 7
      if (i915->intel.hw_stipple &&
          i915->intel.reduced_primitive == GL_TRIANGLES) {
         I915_STATECHANGE(i915, I915_UPLOAD_STIPPLE);
         if (state)
            i915->state.Stipple[I915_STPREG_ST1] |= ST1_ENABLE;
         else
            i915->state.Stipple[I915_STPREG_ST1] &= ~ST1_ENABLE;
d786 1
a786 11
      break;

   case GL_POINT_SPRITE:
      /* This state change is handled in i915_reduced_primitive_state because
       * the hardware bit should only be set when rendering points.
       */
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      if (state)
	 i915->state.Ctx[I915_CTXREG_LIS4] |= S4_SPRITE_POINT_ENABLE;
      else
	 i915->state.Ctx[I915_CTXREG_LIS4] &= ~S4_SPRITE_POINT_ENABLE;
d790 1
d799 1
a799 2
static void
i915_init_packets(struct i915_context *i915)
d801 2
d812 6
a817 4
      i915->state.Ctx[I915_CTXREG_LI] = (_3DSTATE_LOAD_STATE_IMMEDIATE_1 |
                                         I1_LOAD_S(2) |
                                         I1_LOAD_S(4) |
                                         I1_LOAD_S(5) | I1_LOAD_S(6) | (3));
d822 2
a823 2
      if (i915->intel.ctx.Visual.rgbBits == 16)
         i915->state.Ctx[I915_CTXREG_LIS5] |= S5_COLOR_DITHER_ENABLE;
d827 1
a827 1
                                           (2 << S6_TRISTRIP_PV_SHIFT));
d830 6
a835 10
                                             ENABLE_LOGIC_OP_FUNC |
                                             LOGIC_OP_FUNC(LOGICOP_COPY) |
                                             ENABLE_STENCIL_TEST_MASK |
                                             STENCIL_TEST_MASK(0xff) |
                                             ENABLE_STENCIL_WRITE_MASK |
                                             STENCIL_WRITE_MASK(0xff));

      i915->state.Ctx[I915_CTXREG_IAB] =
         (_3DSTATE_INDEPENDENT_ALPHA_BLEND_CMD | IAB_MODIFY_ENABLE |
          IAB_MODIFY_FUNC | IAB_MODIFY_SRC_FACTOR | IAB_MODIFY_DST_FACTOR);
d837 8
a844 2
      i915->state.Ctx[I915_CTXREG_BLENDCOLOR0] =
         _3DSTATE_CONST_BLEND_COLOR_CMD;
a846 11
      i915->state.Ctx[I915_CTXREG_BF_STENCIL_MASKS] =
	 _3DSTATE_BACKFACE_STENCIL_MASKS |
	 BFM_ENABLE_STENCIL_TEST_MASK |
	 BFM_ENABLE_STENCIL_WRITE_MASK |
	 (0xff << BFM_STENCIL_WRITE_MASK_SHIFT) |
	 (0xff << BFM_STENCIL_TEST_MASK_SHIFT);
      i915->state.Ctx[I915_CTXREG_BF_STENCIL_OPS] =
	 _3DSTATE_BACKFACE_STENCIL_OPS |
	 BFO_ENABLE_STENCIL_REF |
	 BFO_ENABLE_STENCIL_FUNCS |
	 BFO_ENABLE_STENCIL_TWO_SIDE;
d859 5
a863 5
                                            FMC1_FOGFUNC_VERTEX |
                                            FMC1_FOGINDEX_MODIFY_ENABLE |
                                            FMC1_FOGINDEX_W |
                                            FMC1_C1_C2_MODIFY_ENABLE |
                                            FMC1_DENSITY_MODIFY_ENABLE);
d867 1
d869 19
d890 22
d913 2
a914 2
      i915->state.Buffer[I915_DESTREG_SENABLE] =
         (_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);
a919 20
   i915->state.RasterRules[I915_RASTER_RULES] = _3DSTATE_RASTER_RULES_CMD |
      ENABLE_POINT_RASTER_RULE |
      OGL_POINT_RASTER_RULE |
      ENABLE_LINE_STRIP_PROVOKE_VRTX |
      ENABLE_TRI_FAN_PROVOKE_VRTX |
      LINE_STRIP_PROVOKE_VRTX(1) |
      TRI_FAN_PROVOKE_VRTX(2) | ENABLE_TEXKILL_3D_4D | TEXKILL_4D;

#if 0
   {
      I915_STATECHANGE(i915, I915_UPLOAD_DEFAULTS);
      i915->state.Default[I915_DEFREG_C0] = _3DSTATE_DEFAULT_DIFFUSE;
      i915->state.Default[I915_DEFREG_C1] = 0;
      i915->state.Default[I915_DEFREG_S0] = _3DSTATE_DEFAULT_SPECULAR;
      i915->state.Default[I915_DEFREG_S1] = 0;
      i915->state.Default[I915_DEFREG_Z0] = _3DSTATE_DEFAULT_Z;
      i915->state.Default[I915_DEFREG_Z1] = 0;
   }
#endif

d924 5
a928 6
   i915->state.active = (I915_UPLOAD_PROGRAM |
                         I915_UPLOAD_STIPPLE |
                         I915_UPLOAD_CTX |
                         I915_UPLOAD_BUFFERS |
			 I915_UPLOAD_INVARIENT |
			 I915_UPLOAD_RASTER_RULES);
d931 1
a931 26
void
i915_update_provoking_vertex(struct gl_context * ctx)
{
   struct i915_context *i915 = I915_CONTEXT(ctx);

   I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   i915->state.Ctx[I915_CTXREG_LIS6] &= ~(S6_TRISTRIP_PV_MASK);

   I915_STATECHANGE(i915, I915_UPLOAD_RASTER_RULES);
   i915->state.RasterRules[I915_RASTER_RULES] &= ~(LINE_STRIP_PROVOKE_VRTX_MASK |
						   TRI_FAN_PROVOKE_VRTX_MASK);

   /* _NEW_LIGHT */
   if (ctx->Light.ProvokingVertex == GL_LAST_VERTEX_CONVENTION) {
      i915->state.RasterRules[I915_RASTER_RULES] |= (LINE_STRIP_PROVOKE_VRTX(1) |
						     TRI_FAN_PROVOKE_VRTX(2));
      i915->state.Ctx[I915_CTXREG_LIS6] |= (2 << S6_TRISTRIP_PV_SHIFT);
   } else {
      i915->state.RasterRules[I915_RASTER_RULES] |= (LINE_STRIP_PROVOKE_VRTX(0) |
						     TRI_FAN_PROVOKE_VRTX(1));
      i915->state.Ctx[I915_CTXREG_LIS6] |= (0 << S6_TRISTRIP_PV_SHIFT);
    }
}

void
i915InitStateFunctions(struct dd_function_table *functions)
a948 1
   functions->PointParameterfv = i915PointParameterfv;
a954 2
   functions->DepthRange = i915DepthRange;
   functions->Viewport = i915Viewport;
d958 1
a958 2
void
i915InitState(struct i915_context *i915)
d960 3
a962 1
   struct gl_context *ctx = &i915->intel.ctx;
d964 1
a964 1
   i915_init_packets(i915);
d966 2
a967 1
   _mesa_init_driver_state(ctx);
d969 7
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@a32 1
#include "main/fbobject.h"
a33 2
#include "main/state.h"
#include "main/stencil.h"
d37 2
d59 2
a60 1
   GLuint dirty = 0;
d67 1
a67 1
      front_ref = _mesa_get_stencil_ref(ctx, 0);
d74 1
a74 1
      back_ref = _mesa_get_stencil_ref(ctx, ctx->Stencil._BackFace);
d82 1
a82 1
      front_ref = _mesa_get_stencil_ref(ctx, ctx->Stencil._BackFace);
d89 1
a89 1
      back_ref = _mesa_get_stencil_ref(ctx, 0);
a96 7
#define set_ctx_bits(reg, mask, set) do{ \
   GLuint dw = i915->state.Ctx[reg]; \
   dw &= ~(mask); \
   dw |= (set); \
   dirty |= dw != i915->state.Ctx[reg]; \
   i915->state.Ctx[reg] = dw; \
} while(0)
d99 21
a119 21
   set_ctx_bits(I915_CTXREG_STATE4,
                MODE4_ENABLE_STENCIL_TEST_MASK |
                MODE4_ENABLE_STENCIL_WRITE_MASK,
                ENABLE_STENCIL_TEST_MASK |
                ENABLE_STENCIL_WRITE_MASK |
                STENCIL_TEST_MASK(front_mask) |
                STENCIL_WRITE_MASK(front_writemask));

   set_ctx_bits(I915_CTXREG_LIS5,
                S5_STENCIL_REF_MASK |
                S5_STENCIL_TEST_FUNC_MASK |
                S5_STENCIL_FAIL_MASK |
                S5_STENCIL_PASS_Z_FAIL_MASK |
                S5_STENCIL_PASS_Z_PASS_MASK,
                (front_ref << S5_STENCIL_REF_SHIFT) |
                (intel_translate_compare_func(front_func) << S5_STENCIL_TEST_FUNC_SHIFT) |
                (intel_translate_stencil_op(front_fail) << S5_STENCIL_FAIL_SHIFT) |
                (intel_translate_stencil_op(front_pass_z_fail) <<
                 S5_STENCIL_PASS_Z_FAIL_SHIFT) |
                (intel_translate_stencil_op(front_pass_z_pass) <<
                 S5_STENCIL_PASS_Z_PASS_SHIFT));
d123 21
a143 20
      set_ctx_bits(I915_CTXREG_BF_STENCIL_OPS,
                   BFO_STENCIL_REF_MASK |
                   BFO_STENCIL_TEST_MASK |
                   BFO_STENCIL_FAIL_MASK |
                   BFO_STENCIL_PASS_Z_FAIL_MASK |
                   BFO_STENCIL_PASS_Z_PASS_MASK,
                   BFO_STENCIL_TWO_SIDE |
                   (back_ref << BFO_STENCIL_REF_SHIFT) |
                   (intel_translate_compare_func(back_func) << BFO_STENCIL_TEST_SHIFT) |
                   (intel_translate_stencil_op(back_fail) << BFO_STENCIL_FAIL_SHIFT) |
                   (intel_translate_stencil_op(back_pass_z_fail) <<
                    BFO_STENCIL_PASS_Z_FAIL_SHIFT) |
                   (intel_translate_stencil_op(back_pass_z_pass) <<
                    BFO_STENCIL_PASS_Z_PASS_SHIFT));

      set_ctx_bits(I915_CTXREG_BF_STENCIL_MASKS,
                   BFM_STENCIL_TEST_MASK_MASK |
                   BFM_STENCIL_WRITE_MASK_MASK,
                   BFM_STENCIL_TEST_MASK(back_mask) |
                   BFM_STENCIL_WRITE_MASK(back_writemask));
d145 1
a145 2
      set_ctx_bits(I915_CTXREG_BF_STENCIL_OPS,
                   BFO_STENCIL_TWO_SIDE, 0);
a146 5

#undef set_ctx_bits

   if (dirty)
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
a171 1
   GLuint dw;
d175 6
a180 8
   dw = i915->state.Ctx[I915_CTXREG_LIS6];
   dw &= ~(S6_ALPHA_TEST_FUNC_MASK | S6_ALPHA_REF_MASK);
   dw |= ((test << S6_ALPHA_TEST_FUNC_SHIFT) |
	  (((GLuint) refByte) << S6_ALPHA_REF_SHIFT));
   if (dw != i915->state.Ctx[I915_CTXREG_LIS6]) {
      i915->state.Ctx[I915_CTXREG_LIS6] = dw;
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   }
a192 1
   GLuint dw0, dw1;
d194 1
a194 2
   dw0 = i915->state.Ctx[I915_CTXREG_LIS5];
   dw1 = i915->state.Ctx[I915_CTXREG_LIS6];
d196 3
a198 3
   if (ctx->Color.ColorLogicOpEnabled) {
      dw0 |= S5_LOGICOP_ENABLE;
      dw1 &= ~S6_CBUF_BLEND_ENABLE;
d201 1
a201 1
      dw0 &= ~S5_LOGICOP_ENABLE;
d204 1
a204 1
         dw1 |= S6_CBUF_BLEND_ENABLE;
d207 1
a207 1
         dw1 &= ~S6_CBUF_BLEND_ENABLE;
a209 7
   if (dw0 != i915->state.Ctx[I915_CTXREG_LIS5] ||
       dw1 != i915->state.Ctx[I915_CTXREG_LIS6]) {
      i915->state.Ctx[I915_CTXREG_LIS5] = dw0;
      i915->state.Ctx[I915_CTXREG_LIS6] = dw1;

      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   }
a216 1
   GLuint dw;
d225 3
a227 5
   dw = (a << 24) | (r << 16) | (g << 8) | b;
   if (dw != i915->state.Blend[I915_BLENDREG_BLENDCOLOR1]) {
      i915->state.Blend[I915_BLENDREG_BLENDCOLOR1] = dw;
      I915_STATECHANGE(i915, I915_UPLOAD_BLEND);
   }
d261 1
a261 1
   GLuint iab = (i915->state.Blend[I915_BLENDREG_IAB] &
d270 6
a275 6
   GLuint eqRGB = ctx->Color.Blend[0].EquationRGB;
   GLuint eqA = ctx->Color.Blend[0].EquationA;
   GLuint srcRGB = ctx->Color.Blend[0].SrcRGB;
   GLuint dstRGB = ctx->Color.Blend[0].DstRGB;
   GLuint srcA = ctx->Color.Blend[0].SrcA;
   GLuint dstA = ctx->Color.Blend[0].DstA;
d296 4
a299 5
   if (iab != i915->state.Blend[I915_BLENDREG_IAB]) {
      i915->state.Blend[I915_BLENDREG_IAB] = iab;
      I915_STATECHANGE(i915, I915_UPLOAD_BLEND);
   }
   if (lis6 != i915->state.Ctx[I915_CTXREG_LIS6]) {
a300 1
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
a327 1
   GLuint dw;
d331 3
a333 7
   dw = i915->state.Ctx[I915_CTXREG_LIS6];
   dw &= ~S6_DEPTH_TEST_FUNC_MASK;
   dw |= test << S6_DEPTH_TEST_FUNC_SHIFT;
   if (dw != i915->state.Ctx[I915_CTXREG_LIS6]) {
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      i915->state.Ctx[I915_CTXREG_LIS6] = dw;
   }
a339 1
   GLuint dw;
d342 2
a344 4
   if (!ctx->DrawBuffer || !ctx->DrawBuffer->Visual.depthBits)
      flag = false;

   dw = i915->state.Ctx[I915_CTXREG_LIS6];
d346 1
a346 1
      dw |= S6_DEPTH_WRITE_ENABLE;
d348 1
a348 5
      dw &= ~S6_DEPTH_WRITE_ENABLE;
   if (dw != i915->state.Ctx[I915_CTXREG_LIS6]) {
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      i915->state.Ctx[I915_CTXREG_LIS6] = dw;
   }
d363 22
d386 2
a387 19
   if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
      _math_matrix_viewport(&intel->ViewportMatrix,
			    ctx->Viewport.X,
			    ctx->DrawBuffer->Height - ctx->Viewport.Y,
			    ctx->Viewport.Width,
			    -ctx->Viewport.Height,
			    ctx->Viewport.Near,
			    ctx->Viewport.Far,
			    1.0);
   } else {
      _math_matrix_viewport(&intel->ViewportMatrix,
			    ctx->Viewport.X,
			    ctx->Viewport.Y,
			    ctx->Viewport.Width,
			    ctx->Viewport.Height,
			    ctx->Viewport.Near,
			    ctx->Viewport.Far,
			    1.0);
   }
d487 1
a487 1
   if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
d535 1
a535 1
   GLuint mode, dw;
d546 1
a546 1
      if (ctx->DrawBuffer && _mesa_is_user_fbo(ctx->DrawBuffer))
d557 3
a559 7
   dw = i915->state.Ctx[I915_CTXREG_LIS4];
   dw &= ~S4_CULLMODE_MASK;
   dw |= mode;
   if (dw != i915->state.Ctx[I915_CTXREG_LIS4]) {
      i915->state.Ctx[I915_CTXREG_LIS4] = dw;
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   }
a616 42
void
i915_update_sprite_point_enable(struct gl_context *ctx)
{
   struct intel_context *intel = intel_context(ctx);
   /* _NEW_PROGRAM */
   struct i915_fragment_program *p =
      (struct i915_fragment_program *) ctx->FragmentProgram._Current;
   const GLbitfield64 inputsRead = p->FragProg.Base.InputsRead;
   struct i915_context *i915 = i915_context(ctx);
   GLuint s4 = i915->state.Ctx[I915_CTXREG_LIS4] & ~S4_VFMT_MASK;
   int i;
   GLuint coord_replace_bits = 0x0;
   GLuint tex_coord_unit_bits = 0x0;

   for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++) {
      /* _NEW_POINT */
      if (ctx->Point.CoordReplace[i] && ctx->Point.PointSprite)
         coord_replace_bits |= (1 << i);
      if (inputsRead & VARYING_BIT_TEX(i))
         tex_coord_unit_bits |= (1 << i);
   }

   /*
    * Here we can't enable the SPRITE_POINT_ENABLE bit when the mis-match
    * of tex_coord_unit_bits and coord_replace_bits, or this will make all
    * the other non-point-sprite coords(like varying inputs, as we now use
    * tex coord to implement varying inputs) be replaced to value (0, 0)-(1, 1).
    *
    * Thus, do fallback when needed.
    */
   FALLBACK(intel, I915_FALLBACK_COORD_REPLACE,
            coord_replace_bits && coord_replace_bits != tex_coord_unit_bits);

   s4 &= ~S4_SPRITE_POINT_ENABLE;
   s4 |= (coord_replace_bits && coord_replace_bits == tex_coord_unit_bits) ?
         S4_SPRITE_POINT_ENABLE : 0;
   if (s4 != i915->state.Ctx[I915_CTXREG_LIS4]) {
      i915->state.Ctx[I915_CTXREG_LIS4] = s4;
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
   }
}

a684 4
 *
 * This empty function remains because _mesa_init_driver_state calls
 * dd_function_table::Fogfv unconditionally.  We have to have some function
 * there so that it doesn't try to call a NULL pointer.
d686 96
d785 46
a830 3
   (void) ctx;
   (void) pname;
   (void) param;
a839 1
   GLuint dw;
d851 1
a851 1
      dw = i915->state.Ctx[I915_CTXREG_LIS6];
d853 1
a853 1
         dw |= S6_ALPHA_TEST_ENABLE;
d855 1
a855 5
         dw &= ~S6_ALPHA_TEST_ENABLE;
      if (dw != i915->state.Ctx[I915_CTXREG_LIS6]) {
	 i915->state.Ctx[I915_CTXREG_LIS6] = dw;
	 I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      }
d875 1
a875 1
      dw = i915->state.Ctx[I915_CTXREG_LIS5];
d877 1
a877 1
         dw |= S5_COLOR_DITHER_ENABLE;
d879 1
a879 5
         dw &= ~S5_COLOR_DITHER_ENABLE;
      if (dw != i915->state.Ctx[I915_CTXREG_LIS5]) {
	 i915->state.Ctx[I915_CTXREG_LIS5] = dw;
	 I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      }
d883 1
a883 5
      dw = i915->state.Ctx[I915_CTXREG_LIS6];

      if (!ctx->DrawBuffer || !ctx->DrawBuffer->Visual.depthBits)
	 state = false;

d885 1
a885 1
         dw |= S6_DEPTH_TEST_ENABLE;
d887 1
a887 5
         dw &= ~S6_DEPTH_TEST_ENABLE;
      if (dw != i915->state.Ctx[I915_CTXREG_LIS6]) {
	 i915->state.Ctx[I915_CTXREG_LIS6] = dw;
	 I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      }
d903 1
a903 1
      dw = i915->state.Ctx[I915_CTXREG_LIS4];
d905 1
a905 1
         dw |= S4_LINE_ANTIALIAS_ENABLE;
d907 4
a910 5
         dw &= ~S4_LINE_ANTIALIAS_ENABLE;
      if (dw != i915->state.Ctx[I915_CTXREG_LIS4]) {
	 i915->state.Ctx[I915_CTXREG_LIS4] = dw;
	 I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      }
d918 19
a936 11
      if (!ctx->DrawBuffer || !ctx->DrawBuffer->Visual.stencilBits)
	 state = false;

      dw = i915->state.Ctx[I915_CTXREG_LIS5];
      if (state)
	 dw |= (S5_STENCIL_TEST_ENABLE | S5_STENCIL_WRITE_ENABLE);
      else
	 dw &= ~(S5_STENCIL_TEST_ENABLE | S5_STENCIL_WRITE_ENABLE);
      if (dw != i915->state.Ctx[I915_CTXREG_LIS5]) {
	 i915->state.Ctx[I915_CTXREG_LIS5] = dw;
	 I915_STATECHANGE(i915, I915_UPLOAD_CTX);
d959 8
a966 1
      /* Handle it at i915_update_sprite_point_enable () */
a986 1
      I915_STATECHANGE(i915, I915_UPLOAD_BLEND);
d1013 1
a1013 1
      i915->state.Blend[I915_BLENDREG_IAB] =
d1017 1
a1017 1
      i915->state.Blend[I915_BLENDREG_BLENDCOLOR0] =
d1019 1
a1019 1
      i915->state.Blend[I915_BLENDREG_BLENDCOLOR1] = 0;
d1039 13
a1089 1
                         I915_UPLOAD_BLEND |
a1118 9
/* Fallback to swrast for select and feedback.
 */
static void
i915RenderMode(struct gl_context *ctx, GLenum mode)
{
   struct intel_context *intel = intel_context(ctx);
   FALLBACK(intel, INTEL_FALLBACK_RENDERMODE, (mode != GL_RENDER));
}

d1133 1
a1139 1
   functions->RenderMode = i915RenderMode;
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d407 6
a412 6
			    ctx->ViewportArray[0].X,
			    ctx->DrawBuffer->Height - ctx->ViewportArray[0].Y,
			    ctx->ViewportArray[0].Width,
			    -ctx->ViewportArray[0].Height,
			    ctx->ViewportArray[0].Near,
			    ctx->ViewportArray[0].Far,
d416 6
a421 6
			    ctx->ViewportArray[0].X,
			    ctx->ViewportArray[0].Y,
			    ctx->ViewportArray[0].Width,
			    ctx->ViewportArray[0].Height,
			    ctx->ViewportArray[0].Near,
			    ctx->ViewportArray[0].Far,
d427 9
d438 1
a438 1
i915DepthRange(struct gl_context *ctx)
d513 1
a513 1
i915Scissor(struct gl_context * ctx)
d521 1
a521 3
   DBG("%s %d,%d %dx%d\n", __FUNCTION__,
       ctx->Scissor.ScissorArray[0].X,     ctx->Scissor.ScissorArray[0].Y,
       ctx->Scissor.ScissorArray[0].Width, ctx->Scissor.ScissorArray[0].Height);
d524 4
a527 6
      x1 = ctx->Scissor.ScissorArray[0].X;
      y1 = ctx->DrawBuffer->Height - (ctx->Scissor.ScissorArray[0].Y
                                      + ctx->Scissor.ScissorArray[0].Height);
      x2 = ctx->Scissor.ScissorArray[0].X
         + ctx->Scissor.ScissorArray[0].Width - 1;
      y2 = y1 + ctx->Scissor.ScissorArray[0].Height - 1;
d533 4
a536 6
      x1 = ctx->Scissor.ScissorArray[0].X;
      y1 = ctx->Scissor.ScissorArray[0].Y;
      x2 = ctx->Scissor.ScissorArray[0].X
         + ctx->Scissor.ScissorArray[0].Width - 1;
      y2 = ctx->Scissor.ScissorArray[0].Y
         + ctx->Scissor.ScissorArray[0].Height - 1;
d1094 1
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@a36 1
#include "main/viewport.h"
a403 3
   double scale[3], translate[3];

   _mesa_get_viewport_xform(ctx, 0, scale, translate);
d406 17
a422 2
      scale[1] = -scale[1];
      translate[1] = ctx->DrawBuffer->Height - translate[1];
a423 3

   _math_matrix_viewport(&intel->ViewportMatrix,
                         scale, translate, 1.0);
d991 2
a995 2
      i915->state.Buffer[I915_DESTREG_SENABLE] =
         (_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d37 1
d405 3
d410 2
a411 17
      _math_matrix_viewport(&intel->ViewportMatrix,
			    ctx->ViewportArray[0].X,
			    ctx->DrawBuffer->Height - ctx->ViewportArray[0].Y,
			    ctx->ViewportArray[0].Width,
			    -ctx->ViewportArray[0].Height,
			    ctx->ViewportArray[0].Near,
			    ctx->ViewportArray[0].Far,
			    1.0);
   } else {
      _math_matrix_viewport(&intel->ViewportMatrix,
			    ctx->ViewportArray[0].X,
			    ctx->ViewportArray[0].Y,
			    ctx->ViewportArray[0].Width,
			    ctx->ViewportArray[0].Height,
			    ctx->ViewportArray[0].Near,
			    ctx->ViewportArray[0].Far,
			    1.0);
d413 3
a982 2
      i915->state.Buffer[I915_DESTREG_SENABLE] =
         (_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);
d986 2
@


