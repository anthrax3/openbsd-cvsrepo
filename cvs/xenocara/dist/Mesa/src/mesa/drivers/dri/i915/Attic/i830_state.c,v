head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.04.12;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.08;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.15.19;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.46;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.11.21;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.48.28;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/


#include "main/glheader.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/enums.h"
#include "main/fbobject.h"
#include "main/dd.h"
#include "main/state.h"

#include "drivers/common/driverfuncs.h"

#include "intel_screen.h"
#include "intel_batchbuffer.h"
#include "intel_mipmap_tree.h"
#include "intel_fbo.h"
#include "intel_buffers.h"

#include "i830_context.h"
#include "i830_reg.h"

#define FILE_DEBUG_FLAG DEBUG_STATE

static void
i830StencilFuncSeparate(struct gl_context * ctx, GLenum face, GLenum func, GLint ref,
                        GLuint mask)
{
   struct i830_context *i830 = i830_context(ctx);
   int test = intel_translate_compare_func(func);

   mask = mask & 0xff;

   DBG("%s : func: %s, ref : 0x%x, mask: 0x%x\n", __FUNCTION__,
       _mesa_lookup_enum_by_nr(func), ref, mask);


   I830_STATECHANGE(i830, I830_UPLOAD_CTX);
   i830->state.Ctx[I830_CTXREG_STATE4] &= ~MODE4_ENABLE_STENCIL_TEST_MASK;
   i830->state.Ctx[I830_CTXREG_STATE4] |= (ENABLE_STENCIL_TEST_MASK |
                                           STENCIL_TEST_MASK(mask));
   i830->state.Ctx[I830_CTXREG_STENCILTST] &= ~(STENCIL_REF_VALUE_MASK |
                                                ENABLE_STENCIL_TEST_FUNC_MASK);
   i830->state.Ctx[I830_CTXREG_STENCILTST] |= (ENABLE_STENCIL_REF_VALUE |
                                               ENABLE_STENCIL_TEST_FUNC |
                                               STENCIL_REF_VALUE(ref) |
                                               STENCIL_TEST_FUNC(test));
}

static void
i830StencilMaskSeparate(struct gl_context * ctx, GLenum face, GLuint mask)
{
   struct i830_context *i830 = i830_context(ctx);

   DBG("%s : mask 0x%x\n", __FUNCTION__, mask);
   
   mask = mask & 0xff;

   I830_STATECHANGE(i830, I830_UPLOAD_CTX);
   i830->state.Ctx[I830_CTXREG_STATE4] &= ~MODE4_ENABLE_STENCIL_WRITE_MASK;
   i830->state.Ctx[I830_CTXREG_STATE4] |= (ENABLE_STENCIL_WRITE_MASK |
                                           STENCIL_WRITE_MASK(mask));
}

static void
i830StencilOpSeparate(struct gl_context * ctx, GLenum face, GLenum fail, GLenum zfail,
                      GLenum zpass)
{
   struct i830_context *i830 = i830_context(ctx);
   int fop, dfop, dpop;

   DBG("%s: fail : %s, zfail: %s, zpass : %s\n", __FUNCTION__,
       _mesa_lookup_enum_by_nr(fail),
       _mesa_lookup_enum_by_nr(zfail), 
       _mesa_lookup_enum_by_nr(zpass));

   fop = 0;
   dfop = 0;
   dpop = 0;

   switch (fail) {
   case GL_KEEP:
      fop = STENCILOP_KEEP;
      break;
   case GL_ZERO:
      fop = STENCILOP_ZERO;
      break;
   case GL_REPLACE:
      fop = STENCILOP_REPLACE;
      break;
   case GL_INCR:
      fop = STENCILOP_INCRSAT;
      break;
   case GL_DECR:
      fop = STENCILOP_DECRSAT;
      break;
   case GL_INCR_WRAP:
      fop = STENCILOP_INCR;
      break;
   case GL_DECR_WRAP:
      fop = STENCILOP_DECR;
      break;
   case GL_INVERT:
      fop = STENCILOP_INVERT;
      break;
   default:
      break;
   }
   switch (zfail) {
   case GL_KEEP:
      dfop = STENCILOP_KEEP;
      break;
   case GL_ZERO:
      dfop = STENCILOP_ZERO;
      break;
   case GL_REPLACE:
      dfop = STENCILOP_REPLACE;
      break;
   case GL_INCR:
      dfop = STENCILOP_INCRSAT;
      break;
   case GL_DECR:
      dfop = STENCILOP_DECRSAT;
      break;
   case GL_INCR_WRAP:
      dfop = STENCILOP_INCR;
      break;
   case GL_DECR_WRAP:
      dfop = STENCILOP_DECR;
      break;
   case GL_INVERT:
      dfop = STENCILOP_INVERT;
      break;
   default:
      break;
   }
   switch (zpass) {
   case GL_KEEP:
      dpop = STENCILOP_KEEP;
      break;
   case GL_ZERO:
      dpop = STENCILOP_ZERO;
      break;
   case GL_REPLACE:
      dpop = STENCILOP_REPLACE;
      break;
   case GL_INCR:
      dpop = STENCILOP_INCRSAT;
      break;
   case GL_DECR:
      dpop = STENCILOP_DECRSAT;
      break;
   case GL_INCR_WRAP:
      dpop = STENCILOP_INCR;
      break;
   case GL_DECR_WRAP:
      dpop = STENCILOP_DECR;
      break;
   case GL_INVERT:
      dpop = STENCILOP_INVERT;
      break;
   default:
      break;
   }


   I830_STATECHANGE(i830, I830_UPLOAD_CTX);
   i830->state.Ctx[I830_CTXREG_STENCILTST] &= ~(STENCIL_OPS_MASK);
   i830->state.Ctx[I830_CTXREG_STENCILTST] |= (ENABLE_STENCIL_PARMS |
                                               STENCIL_FAIL_OP(fop) |
                                               STENCIL_PASS_DEPTH_FAIL_OP
                                               (dfop) |
                                               STENCIL_PASS_DEPTH_PASS_OP
                                               (dpop));
}

static void
i830AlphaFunc(struct gl_context * ctx, GLenum func, GLfloat ref)
{
   struct i830_context *i830 = i830_context(ctx);
   int test = intel_translate_compare_func(func);
   GLubyte refByte;
   GLuint refInt;

   UNCLAMPED_FLOAT_TO_UBYTE(refByte, ref);
   refInt = (GLuint) refByte;

   I830_STATECHANGE(i830, I830_UPLOAD_CTX);
   i830->state.Ctx[I830_CTXREG_STATE2] &= ~ALPHA_TEST_REF_MASK;
   i830->state.Ctx[I830_CTXREG_STATE2] |= (ENABLE_ALPHA_TEST_FUNC |
                                           ENABLE_ALPHA_REF_VALUE |
                                           ALPHA_TEST_FUNC(test) |
                                           ALPHA_REF_VALUE(refInt));
}

/**
 * Makes sure that the proper enables are set for LogicOp, Independant Alpha
 * Blend, and Blending.  It needs to be called from numerous places where we
 * could change the LogicOp or Independant Alpha Blend without subsequent
 * calls to glEnable.
 * 
 * \todo
 * This function is substantially different from the old i830-specific driver.
 * I'm not sure which is correct.
 */
static void
i830EvalLogicOpBlendState(struct gl_context * ctx)
{
   struct i830_context *i830 = i830_context(ctx);

   I830_STATECHANGE(i830, I830_UPLOAD_CTX);

   if (ctx->Color.ColorLogicOpEnabled) {
      i830->state.Ctx[I830_CTXREG_ENABLES_1] &= ~(ENABLE_COLOR_BLEND |
                                                  ENABLE_LOGIC_OP_MASK);
      i830->state.Ctx[I830_CTXREG_ENABLES_1] |= (DISABLE_COLOR_BLEND |
                                                 ENABLE_LOGIC_OP);
   }
   else if (ctx->Color.BlendEnabled) {
      i830->state.Ctx[I830_CTXREG_ENABLES_1] &= ~(ENABLE_COLOR_BLEND |
                                                  ENABLE_LOGIC_OP_MASK);
      i830->state.Ctx[I830_CTXREG_ENABLES_1] |= (ENABLE_COLOR_BLEND |
                                                 DISABLE_LOGIC_OP);
   }
   else {
      i830->state.Ctx[I830_CTXREG_ENABLES_1] &= ~(ENABLE_COLOR_BLEND |
                                                  ENABLE_LOGIC_OP_MASK);
      i830->state.Ctx[I830_CTXREG_ENABLES_1] |= (DISABLE_COLOR_BLEND |
                                                 DISABLE_LOGIC_OP);
   }
}

static void
i830BlendColor(struct gl_context * ctx, const GLfloat color[4])
{
   struct i830_context *i830 = i830_context(ctx);
   GLubyte r, g, b, a;

   DBG("%s\n", __FUNCTION__);
   
   UNCLAMPED_FLOAT_TO_UBYTE(r, color[RCOMP]);
   UNCLAMPED_FLOAT_TO_UBYTE(g, color[GCOMP]);
   UNCLAMPED_FLOAT_TO_UBYTE(b, color[BCOMP]);
   UNCLAMPED_FLOAT_TO_UBYTE(a, color[ACOMP]);

   I830_STATECHANGE(i830, I830_UPLOAD_CTX);
   i830->state.Ctx[I830_CTXREG_BLENDCOLOR1] =
      (a << 24) | (r << 16) | (g << 8) | b;
}

/**
 * Sets both the blend equation (called "function" in i830 docs) and the
 * blend function (called "factor" in i830 docs).  This is done in a single
 * function because some blend equations (i.e., \c GL_MIN and \c GL_MAX)
 * change the interpretation of the blend function.
 */
static void
i830_set_blend_state(struct gl_context * ctx)
{
   struct i830_context *i830 = i830_context(ctx);
   int funcA;
   int funcRGB;
   int eqnA;
   int eqnRGB;
   int iab;
   int s1;


   funcRGB =
      SRC_BLND_FACT(intel_translate_blend_factor(ctx->Color.Blend[0].SrcRGB))
      | DST_BLND_FACT(intel_translate_blend_factor(ctx->Color.Blend[0].DstRGB));

   switch (ctx->Color.Blend[0].EquationRGB) {
   case GL_FUNC_ADD:
      eqnRGB = BLENDFUNC_ADD;
      break;
   case GL_MIN:
      eqnRGB = BLENDFUNC_MIN;
      funcRGB = SRC_BLND_FACT(BLENDFACT_ONE) | DST_BLND_FACT(BLENDFACT_ONE);
      break;
   case GL_MAX:
      eqnRGB = BLENDFUNC_MAX;
      funcRGB = SRC_BLND_FACT(BLENDFACT_ONE) | DST_BLND_FACT(BLENDFACT_ONE);
      break;
   case GL_FUNC_SUBTRACT:
      eqnRGB = BLENDFUNC_SUB;
      break;
   case GL_FUNC_REVERSE_SUBTRACT:
      eqnRGB = BLENDFUNC_RVRSE_SUB;
      break;
   default:
      fprintf(stderr, "[%s:%u] Invalid RGB blend equation (0x%04x).\n",
              __FUNCTION__, __LINE__, ctx->Color.Blend[0].EquationRGB);
      return;
   }


   funcA = SRC_ABLEND_FACT(intel_translate_blend_factor(ctx->Color.Blend[0].SrcA))
      | DST_ABLEND_FACT(intel_translate_blend_factor(ctx->Color.Blend[0].DstA));

   switch (ctx->Color.Blend[0].EquationA) {
   case GL_FUNC_ADD:
      eqnA = BLENDFUNC_ADD;
      break;
   case GL_MIN:
      eqnA = BLENDFUNC_MIN;
      funcA = SRC_BLND_FACT(BLENDFACT_ONE) | DST_BLND_FACT(BLENDFACT_ONE);
      break;
   case GL_MAX:
      eqnA = BLENDFUNC_MAX;
      funcA = SRC_BLND_FACT(BLENDFACT_ONE) | DST_BLND_FACT(BLENDFACT_ONE);
      break;
   case GL_FUNC_SUBTRACT:
      eqnA = BLENDFUNC_SUB;
      break;
   case GL_FUNC_REVERSE_SUBTRACT:
      eqnA = BLENDFUNC_RVRSE_SUB;
      break;
   default:
      fprintf(stderr, "[%s:%u] Invalid alpha blend equation (0x%04x).\n",
              __FUNCTION__, __LINE__, ctx->Color.Blend[0].EquationA);
      return;
   }

   iab = eqnA | funcA
      | _3DSTATE_INDPT_ALPHA_BLEND_CMD
      | ENABLE_SRC_ABLEND_FACTOR | ENABLE_DST_ABLEND_FACTOR
      | ENABLE_ALPHA_BLENDFUNC;
   s1 = eqnRGB | funcRGB
      | _3DSTATE_MODES_1_CMD
      | ENABLE_SRC_BLND_FACTOR | ENABLE_DST_BLND_FACTOR
      | ENABLE_COLR_BLND_FUNC;

   if ((eqnA | funcA) != (eqnRGB | funcRGB))
      iab |= ENABLE_INDPT_ALPHA_BLEND;
   else
      iab |= DISABLE_INDPT_ALPHA_BLEND;

   if (iab != i830->state.Ctx[I830_CTXREG_IALPHAB] ||
       s1 != i830->state.Ctx[I830_CTXREG_STATE1]) {
      I830_STATECHANGE(i830, I830_UPLOAD_CTX);
      i830->state.Ctx[I830_CTXREG_IALPHAB] = iab;
      i830->state.Ctx[I830_CTXREG_STATE1] = s1;
   }

   /* This will catch a logicop blend equation.  It will also ensure
    * independant alpha blend is really in the correct state (either enabled
    * or disabled) if blending is already enabled.
    */

   i830EvalLogicOpBlendState(ctx);

   if (0) {
      fprintf(stderr,
              "[%s:%u] STATE1: 0x%08x IALPHAB: 0x%08x blend is %sabled\n",
              __FUNCTION__, __LINE__, i830->state.Ctx[I830_CTXREG_STATE1],
              i830->state.Ctx[I830_CTXREG_IALPHAB],
              (ctx->Color.BlendEnabled) ? "en" : "dis");
   }
}


static void
i830BlendEquationSeparate(struct gl_context * ctx, GLenum modeRGB, GLenum modeA)
{
   DBG("%s -> %s, %s\n", __FUNCTION__,
       _mesa_lookup_enum_by_nr(modeRGB),
       _mesa_lookup_enum_by_nr(modeA));

   (void) modeRGB;
   (void) modeA;
   i830_set_blend_state(ctx);
}


static void
i830BlendFuncSeparate(struct gl_context * ctx, GLenum sfactorRGB,
                      GLenum dfactorRGB, GLenum sfactorA, GLenum dfactorA)
{
   DBG("%s -> RGB(%s, %s) A(%s, %s)\n", __FUNCTION__,
       _mesa_lookup_enum_by_nr(sfactorRGB),
       _mesa_lookup_enum_by_nr(dfactorRGB),
       _mesa_lookup_enum_by_nr(sfactorA),
       _mesa_lookup_enum_by_nr(dfactorA));

   (void) sfactorRGB;
   (void) dfactorRGB;
   (void) sfactorA;
   (void) dfactorA;
   i830_set_blend_state(ctx);
}



static void
i830DepthFunc(struct gl_context * ctx, GLenum func)
{
   struct i830_context *i830 = i830_context(ctx);
   int test = intel_translate_compare_func(func);

   DBG("%s\n", __FUNCTION__);
   
   I830_STATECHANGE(i830, I830_UPLOAD_CTX);
   i830->state.Ctx[I830_CTXREG_STATE3] &= ~DEPTH_TEST_FUNC_MASK;
   i830->state.Ctx[I830_CTXREG_STATE3] |= (ENABLE_DEPTH_TEST_FUNC |
                                           DEPTH_TEST_FUNC(test));
}

static void
i830DepthMask(struct gl_context * ctx, GLboolean flag)
{
   struct i830_context *i830 = i830_context(ctx);

   DBG("%s flag (%d)\n", __FUNCTION__, flag);

   if (!ctx->DrawBuffer || !ctx->DrawBuffer->Visual.depthBits)
      flag = false;

   I830_STATECHANGE(i830, I830_UPLOAD_CTX);

   i830->state.Ctx[I830_CTXREG_ENABLES_2] &= ~ENABLE_DIS_DEPTH_WRITE_MASK;

   if (flag && ctx->Depth.Test)
      i830->state.Ctx[I830_CTXREG_ENABLES_2] |= ENABLE_DEPTH_WRITE;
   else
      i830->state.Ctx[I830_CTXREG_ENABLES_2] |= DISABLE_DEPTH_WRITE;
}

/** Called from ctx->Driver.DepthRange() */
static void
i830DepthRange(struct gl_context *ctx)
{
   intelCalcViewport(ctx);
}

/* =============================================================
 * Polygon stipple
 *
 * The i830 supports a 4x4 stipple natively, GL wants 32x32.
 * Fortunately stipple is usually a repeating pattern.
 */
static void
i830PolygonStipple(struct gl_context * ctx, const GLubyte * mask)
{
   struct i830_context *i830 = i830_context(ctx);
   const GLubyte *m;
   GLubyte p[4];
   int i, j, k;
   int active = (ctx->Polygon.StippleFlag &&
                 i830->intel.reduced_primitive == GL_TRIANGLES);
   GLuint newMask;

   if (active) {
      I830_STATECHANGE(i830, I830_UPLOAD_STIPPLE);
      i830->state.Stipple[I830_STPREG_ST1] &= ~ST1_ENABLE;
   }

   /* Use the already unpacked stipple data from the context rather than the
    * uninterpreted mask passed in.
    */
   mask = (const GLubyte *)ctx->PolygonStipple;
   m = mask;

   p[0] = mask[12] & 0xf;
   p[0] |= p[0] << 4;
   p[1] = mask[8] & 0xf;
   p[1] |= p[1] << 4;
   p[2] = mask[4] & 0xf;
   p[2] |= p[2] << 4;
   p[3] = mask[0] & 0xf;
   p[3] |= p[3] << 4;

   for (k = 0; k < 8; k++)
      for (j = 3; j >= 0; j--)
         for (i = 0; i < 4; i++, m++)
            if (*m != p[j]) {
               i830->intel.hw_stipple = 0;
               return;
            }

   newMask = (((p[0] & 0xf) << 0) |
              ((p[1] & 0xf) << 4) |
              ((p[2] & 0xf) << 8) | ((p[3] & 0xf) << 12));


   if (newMask == 0xffff || newMask == 0x0) {
      /* this is needed to make conform pass */
      i830->intel.hw_stipple = 0;
      return;
   }

   i830->state.Stipple[I830_STPREG_ST1] &= ~0xffff;
   i830->state.Stipple[I830_STPREG_ST1] |= newMask;
   i830->intel.hw_stipple = 1;

   if (active)
      i830->state.Stipple[I830_STPREG_ST1] |= ST1_ENABLE;
}


/* =============================================================
 * Hardware clipping
 */
static void
i830Scissor(struct gl_context * ctx)
{
   struct i830_context *i830 = i830_context(ctx);
   int x1, y1, x2, y2;

   if (!ctx->DrawBuffer)
      return;

   DBG("%s %d,%d %dx%d\n", __FUNCTION__,
       ctx->Scissor.ScissorArray[0].X,     ctx->Scissor.ScissorArray[0].Y,
       ctx->Scissor.ScissorArray[0].Width, ctx->Scissor.ScissorArray[0].Height);

   if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
      x1 = ctx->Scissor.ScissorArray[0].X;
      y1 = ctx->DrawBuffer->Height - (ctx->Scissor.ScissorArray[0].Y
                                      + ctx->Scissor.ScissorArray[0].Height);
      x2 = ctx->Scissor.ScissorArray[0].X
         + ctx->Scissor.ScissorArray[0].Width - 1;
      y2 = y1 + ctx->Scissor.ScissorArray[0].Height - 1;
      DBG("%s %d..%d,%d..%d (inverted)\n", __FUNCTION__, x1, x2, y1, y2);
   }
   else {
      /* FBO - not inverted
       */
      x1 = ctx->Scissor.ScissorArray[0].X;
      y1 = ctx->Scissor.ScissorArray[0].Y;
      x2 = ctx->Scissor.ScissorArray[0].X
         + ctx->Scissor.ScissorArray[0].Width - 1;
      y2 = ctx->Scissor.ScissorArray[0].Y
         + ctx->Scissor.ScissorArray[0].Height - 1;
      DBG("%s %d..%d,%d..%d (not inverted)\n", __FUNCTION__, x1, x2, y1, y2);
   }

   x1 = CLAMP(x1, 0, ctx->DrawBuffer->Width - 1);
   y1 = CLAMP(y1, 0, ctx->DrawBuffer->Height - 1);
   x2 = CLAMP(x2, 0, ctx->DrawBuffer->Width - 1);
   y2 = CLAMP(y2, 0, ctx->DrawBuffer->Height - 1);
   
   DBG("%s %d..%d,%d..%d (clamped)\n", __FUNCTION__, x1, x2, y1, y2);

   I830_STATECHANGE(i830, I830_UPLOAD_BUFFERS);
   i830->state.Buffer[I830_DESTREG_SR1] = (y1 << 16) | (x1 & 0xffff);
   i830->state.Buffer[I830_DESTREG_SR2] = (y2 << 16) | (x2 & 0xffff);
}

static void
i830LogicOp(struct gl_context * ctx, GLenum opcode)
{
   struct i830_context *i830 = i830_context(ctx);
   int tmp = intel_translate_logic_op(opcode);

   DBG("%s\n", __FUNCTION__);
   
   I830_STATECHANGE(i830, I830_UPLOAD_CTX);
   i830->state.Ctx[I830_CTXREG_STATE4] &= ~LOGICOP_MASK;
   i830->state.Ctx[I830_CTXREG_STATE4] |= LOGIC_OP_FUNC(tmp);
}



static void
i830CullFaceFrontFace(struct gl_context * ctx, GLenum unused)
{
   struct i830_context *i830 = i830_context(ctx);
   GLuint mode;

   DBG("%s\n", __FUNCTION__);
   
   if (!ctx->Polygon.CullFlag) {
      mode = CULLMODE_NONE;
   }
   else if (ctx->Polygon.CullFaceMode != GL_FRONT_AND_BACK) {
      mode = CULLMODE_CW;

      if (ctx->Polygon.CullFaceMode == GL_FRONT)
         mode ^= (CULLMODE_CW ^ CULLMODE_CCW);
      if (ctx->Polygon.FrontFace != GL_CCW)
         mode ^= (CULLMODE_CW ^ CULLMODE_CCW);
   }
   else {
      mode = CULLMODE_BOTH;
   }

   I830_STATECHANGE(i830, I830_UPLOAD_CTX);
   i830->state.Ctx[I830_CTXREG_STATE3] &= ~CULLMODE_MASK;
   i830->state.Ctx[I830_CTXREG_STATE3] |= ENABLE_CULL_MODE | mode;
}

static void
i830LineWidth(struct gl_context * ctx, GLfloat widthf)
{
   struct i830_context *i830 = i830_context(ctx);
   int width;
   int state5;

   DBG("%s\n", __FUNCTION__);
   
   width = (int) (widthf * 2);
   width = CLAMP(width, 1, 15);

   state5 = i830->state.Ctx[I830_CTXREG_STATE5] & ~FIXED_LINE_WIDTH_MASK;
   state5 |= (ENABLE_FIXED_LINE_WIDTH | FIXED_LINE_WIDTH(width));

   if (state5 != i830->state.Ctx[I830_CTXREG_STATE5]) {
      I830_STATECHANGE(i830, I830_UPLOAD_CTX);
      i830->state.Ctx[I830_CTXREG_STATE5] = state5;
   }
}

static void
i830PointSize(struct gl_context * ctx, GLfloat size)
{
   struct i830_context *i830 = i830_context(ctx);
   GLint point_size = (int) size;

   DBG("%s\n", __FUNCTION__);
   
   point_size = CLAMP(point_size, 1, 256);
   I830_STATECHANGE(i830, I830_UPLOAD_CTX);
   i830->state.Ctx[I830_CTXREG_STATE5] &= ~FIXED_POINT_WIDTH_MASK;
   i830->state.Ctx[I830_CTXREG_STATE5] |= (ENABLE_FIXED_POINT_WIDTH |
                                           FIXED_POINT_WIDTH(point_size));
}


/* =============================================================
 * Color masks
 */

static void
i830ColorMask(struct gl_context * ctx,
              GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
   struct i830_context *i830 = i830_context(ctx);
   GLuint tmp = 0;

   DBG("%s r(%d) g(%d) b(%d) a(%d)\n", __FUNCTION__, r, g, b, a);

   tmp = ((i830->state.Ctx[I830_CTXREG_ENABLES_2] & ~WRITEMASK_MASK) |
          ENABLE_COLOR_MASK |
          ENABLE_COLOR_WRITE |
          ((!r) << WRITEMASK_RED_SHIFT) |
          ((!g) << WRITEMASK_GREEN_SHIFT) |
          ((!b) << WRITEMASK_BLUE_SHIFT) | ((!a) << WRITEMASK_ALPHA_SHIFT));

   if (tmp != i830->state.Ctx[I830_CTXREG_ENABLES_2]) {
      I830_STATECHANGE(i830, I830_UPLOAD_CTX);
      i830->state.Ctx[I830_CTXREG_ENABLES_2] = tmp;
   }
}

static void
update_specular(struct gl_context * ctx)
{
   struct i830_context *i830 = i830_context(ctx);

   I830_STATECHANGE(i830, I830_UPLOAD_CTX);
   i830->state.Ctx[I830_CTXREG_ENABLES_1] &= ~ENABLE_SPEC_ADD_MASK;

   if (_mesa_need_secondary_color(ctx))
      i830->state.Ctx[I830_CTXREG_ENABLES_1] |= ENABLE_SPEC_ADD;
   else
      i830->state.Ctx[I830_CTXREG_ENABLES_1] |= DISABLE_SPEC_ADD;
}

static void
i830LightModelfv(struct gl_context * ctx, GLenum pname, const GLfloat * param)
{
   DBG("%s\n", __FUNCTION__);
   
   if (pname == GL_LIGHT_MODEL_COLOR_CONTROL) {
      update_specular(ctx);
   }
}

/* In Mesa 3.5 we can reliably do native flatshading.
 */
static void
i830ShadeModel(struct gl_context * ctx, GLenum mode)
{
   struct i830_context *i830 = i830_context(ctx);
   I830_STATECHANGE(i830, I830_UPLOAD_CTX);


#define SHADE_MODE_MASK ((1<<10)|(1<<8)|(1<<6)|(1<<4))

   i830->state.Ctx[I830_CTXREG_STATE3] &= ~SHADE_MODE_MASK;

   if (mode == GL_FLAT) {
      i830->state.Ctx[I830_CTXREG_STATE3] |=
         (ALPHA_SHADE_MODE(SHADE_MODE_FLAT) | FOG_SHADE_MODE(SHADE_MODE_FLAT)
          | SPEC_SHADE_MODE(SHADE_MODE_FLAT) |
          COLOR_SHADE_MODE(SHADE_MODE_FLAT));
   }
   else {
      i830->state.Ctx[I830_CTXREG_STATE3] |=
         (ALPHA_SHADE_MODE(SHADE_MODE_LINEAR) |
          FOG_SHADE_MODE(SHADE_MODE_LINEAR) |
          SPEC_SHADE_MODE(SHADE_MODE_LINEAR) |
          COLOR_SHADE_MODE(SHADE_MODE_LINEAR));
   }
}

/* =============================================================
 * Fog
 */
static void
i830Fogfv(struct gl_context * ctx, GLenum pname, const GLfloat * param)
{
   struct i830_context *i830 = i830_context(ctx);

   DBG("%s\n", __FUNCTION__);
   
   if (pname == GL_FOG_COLOR) {
      GLuint color = (((GLubyte) (ctx->Fog.Color[0] * 255.0F) << 16) |
                      ((GLubyte) (ctx->Fog.Color[1] * 255.0F) << 8) |
                      ((GLubyte) (ctx->Fog.Color[2] * 255.0F) << 0));

      I830_STATECHANGE(i830, I830_UPLOAD_CTX);
      i830->state.Ctx[I830_CTXREG_FOGCOLOR] =
         (_3DSTATE_FOG_COLOR_CMD | color);
   }
}

/* =============================================================
 */

static void
i830Enable(struct gl_context * ctx, GLenum cap, GLboolean state)
{
   struct i830_context *i830 = i830_context(ctx);

   switch (cap) {
   case GL_LIGHTING:
   case GL_COLOR_SUM:
      update_specular(ctx);
      break;

   case GL_ALPHA_TEST:
      I830_STATECHANGE(i830, I830_UPLOAD_CTX);
      i830->state.Ctx[I830_CTXREG_ENABLES_1] &= ~ENABLE_DIS_ALPHA_TEST_MASK;
      if (state)
         i830->state.Ctx[I830_CTXREG_ENABLES_1] |= ENABLE_ALPHA_TEST;
      else
         i830->state.Ctx[I830_CTXREG_ENABLES_1] |= DISABLE_ALPHA_TEST;

      break;

   case GL_BLEND:
      i830EvalLogicOpBlendState(ctx);
      break;

   case GL_COLOR_LOGIC_OP:
      i830EvalLogicOpBlendState(ctx);

      /* Logicop doesn't seem to work at 16bpp:
       */
      if (i830->intel.ctx.Visual.rgbBits == 16)
         FALLBACK(&i830->intel, I830_FALLBACK_LOGICOP, state);
      break;

   case GL_DITHER:
      I830_STATECHANGE(i830, I830_UPLOAD_CTX);
      i830->state.Ctx[I830_CTXREG_ENABLES_2] &= ~ENABLE_DITHER;

      if (state)
         i830->state.Ctx[I830_CTXREG_ENABLES_2] |= ENABLE_DITHER;
      else
         i830->state.Ctx[I830_CTXREG_ENABLES_2] |= DISABLE_DITHER;
      break;

   case GL_DEPTH_TEST:
      I830_STATECHANGE(i830, I830_UPLOAD_CTX);
      i830->state.Ctx[I830_CTXREG_ENABLES_1] &= ~ENABLE_DIS_DEPTH_TEST_MASK;

      if (!ctx->DrawBuffer || !ctx->DrawBuffer->Visual.depthBits)
	 state = false;

      if (state)
         i830->state.Ctx[I830_CTXREG_ENABLES_1] |= ENABLE_DEPTH_TEST;
      else
         i830->state.Ctx[I830_CTXREG_ENABLES_1] |= DISABLE_DEPTH_TEST;

      /* Also turn off depth writes when GL_DEPTH_TEST is disabled:
       */
      i830DepthMask(ctx, ctx->Depth.Mask);
      break;

   case GL_SCISSOR_TEST:
      I830_STATECHANGE(i830, I830_UPLOAD_BUFFERS);

      if (state)
         i830->state.Buffer[I830_DESTREG_SENABLE] =
            (_3DSTATE_SCISSOR_ENABLE_CMD | ENABLE_SCISSOR_RECT);
      else
         i830->state.Buffer[I830_DESTREG_SENABLE] =
            (_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);

      break;

   case GL_LINE_SMOOTH:
      I830_STATECHANGE(i830, I830_UPLOAD_CTX);

      i830->state.Ctx[I830_CTXREG_AA] &= ~AA_LINE_ENABLE;
      if (state)
         i830->state.Ctx[I830_CTXREG_AA] |= AA_LINE_ENABLE;
      else
         i830->state.Ctx[I830_CTXREG_AA] |= AA_LINE_DISABLE;
      break;

   case GL_FOG:
      I830_STATECHANGE(i830, I830_UPLOAD_CTX);
      i830->state.Ctx[I830_CTXREG_ENABLES_1] &= ~ENABLE_DIS_FOG_MASK;
      if (state)
         i830->state.Ctx[I830_CTXREG_ENABLES_1] |= ENABLE_FOG;
      else
         i830->state.Ctx[I830_CTXREG_ENABLES_1] |= DISABLE_FOG;
      break;

   case GL_CULL_FACE:
      i830CullFaceFrontFace(ctx, 0);
      break;

   case GL_TEXTURE_2D:
      break;

   case GL_STENCIL_TEST:
      {
         bool hw_stencil = false;
         if (ctx->DrawBuffer) {
            struct intel_renderbuffer *irbStencil
               = intel_get_renderbuffer(ctx->DrawBuffer, BUFFER_STENCIL);
            hw_stencil = (irbStencil && irbStencil->mt);
         }
         if (hw_stencil) {
            I830_STATECHANGE(i830, I830_UPLOAD_CTX);

            if (state) {
               i830->state.Ctx[I830_CTXREG_ENABLES_1] |= ENABLE_STENCIL_TEST;
               i830->state.Ctx[I830_CTXREG_ENABLES_2] |= ENABLE_STENCIL_WRITE;
            }
            else {
               i830->state.Ctx[I830_CTXREG_ENABLES_1] &= ~ENABLE_STENCIL_TEST;
               i830->state.Ctx[I830_CTXREG_ENABLES_2] &=
                  ~ENABLE_STENCIL_WRITE;
               i830->state.Ctx[I830_CTXREG_ENABLES_1] |= DISABLE_STENCIL_TEST;
               i830->state.Ctx[I830_CTXREG_ENABLES_2] |=
                  DISABLE_STENCIL_WRITE;
            }
         }
         else {
            FALLBACK(&i830->intel, I830_FALLBACK_STENCIL, state);
         }
      }
      break;

   case GL_POLYGON_STIPPLE:
      /* The stipple command worked on my 855GM box, but not my 845G.
       * I'll do more testing later to find out exactly which hardware
       * supports it.  Disabled for now.
       */
      if (i830->intel.hw_stipple &&
          i830->intel.reduced_primitive == GL_TRIANGLES) {
         I830_STATECHANGE(i830, I830_UPLOAD_STIPPLE);
         i830->state.Stipple[I830_STPREG_ST1] &= ~ST1_ENABLE;
         if (state)
            i830->state.Stipple[I830_STPREG_ST1] |= ST1_ENABLE;
      }
      break;

   default:
      ;
   }
}


static void
i830_init_packets(struct i830_context *i830)
{
   /* Zero all state */
   memset(&i830->state, 0, sizeof(i830->state));

   /* Set default blend state */
   i830->state.TexBlend[0][0] = (_3DSTATE_MAP_BLEND_OP_CMD(0) |
                                 TEXPIPE_COLOR |
                                 ENABLE_TEXOUTPUT_WRT_SEL |
                                 TEXOP_OUTPUT_CURRENT |
                                 DISABLE_TEX_CNTRL_STAGE |
                                 TEXOP_SCALE_1X |
                                 TEXOP_MODIFY_PARMS |
                                 TEXOP_LAST_STAGE | TEXBLENDOP_ARG1);
   i830->state.TexBlend[0][1] = (_3DSTATE_MAP_BLEND_OP_CMD(0) |
                                 TEXPIPE_ALPHA |
                                 ENABLE_TEXOUTPUT_WRT_SEL |
                                 TEXOP_OUTPUT_CURRENT |
                                 TEXOP_SCALE_1X |
                                 TEXOP_MODIFY_PARMS | TEXBLENDOP_ARG1);
   i830->state.TexBlend[0][2] = (_3DSTATE_MAP_BLEND_ARG_CMD(0) |
                                 TEXPIPE_COLOR |
                                 TEXBLEND_ARG1 |
                                 TEXBLENDARG_MODIFY_PARMS |
                                 TEXBLENDARG_DIFFUSE);
   i830->state.TexBlend[0][3] = (_3DSTATE_MAP_BLEND_ARG_CMD(0) |
                                 TEXPIPE_ALPHA |
                                 TEXBLEND_ARG1 |
                                 TEXBLENDARG_MODIFY_PARMS |
                                 TEXBLENDARG_DIFFUSE);

   i830->state.TexBlendWordsUsed[0] = 4;


   i830->state.Ctx[I830_CTXREG_VF] = 0;
   i830->state.Ctx[I830_CTXREG_VF2] = 0;

   i830->state.Ctx[I830_CTXREG_AA] = (_3DSTATE_AA_CMD |
                                      AA_LINE_ECAAR_WIDTH_ENABLE |
                                      AA_LINE_ECAAR_WIDTH_1_0 |
                                      AA_LINE_REGION_WIDTH_ENABLE |
                                      AA_LINE_REGION_WIDTH_1_0 |
                                      AA_LINE_DISABLE);

   i830->state.Ctx[I830_CTXREG_ENABLES_1] = (_3DSTATE_ENABLES_1_CMD |
                                             DISABLE_LOGIC_OP |
                                             DISABLE_STENCIL_TEST |
                                             DISABLE_DEPTH_BIAS |
                                             DISABLE_SPEC_ADD |
                                             DISABLE_FOG |
                                             DISABLE_ALPHA_TEST |
                                             DISABLE_COLOR_BLEND |
                                             DISABLE_DEPTH_TEST);

#if 000                         /* XXX all the stencil enable state is set in i830Enable(), right? */
   if (i830->intel.hw_stencil) {
      i830->state.Ctx[I830_CTXREG_ENABLES_2] = (_3DSTATE_ENABLES_2_CMD |
                                                ENABLE_STENCIL_WRITE |
                                                ENABLE_TEX_CACHE |
                                                ENABLE_DITHER |
                                                ENABLE_COLOR_MASK |
                                                /* set no color comps disabled */
                                                ENABLE_COLOR_WRITE |
                                                ENABLE_DEPTH_WRITE);
   }
   else
#endif
   {
      i830->state.Ctx[I830_CTXREG_ENABLES_2] = (_3DSTATE_ENABLES_2_CMD |
                                                DISABLE_STENCIL_WRITE |
                                                ENABLE_TEX_CACHE |
                                                ENABLE_DITHER |
                                                ENABLE_COLOR_MASK |
                                                /* set no color comps disabled */
                                                ENABLE_COLOR_WRITE |
                                                ENABLE_DEPTH_WRITE);
   }

   i830->state.Ctx[I830_CTXREG_STATE1] = (_3DSTATE_MODES_1_CMD |
                                          ENABLE_COLR_BLND_FUNC |
                                          BLENDFUNC_ADD |
                                          ENABLE_SRC_BLND_FACTOR |
                                          SRC_BLND_FACT(BLENDFACT_ONE) |
                                          ENABLE_DST_BLND_FACTOR |
                                          DST_BLND_FACT(BLENDFACT_ZERO));

   i830->state.Ctx[I830_CTXREG_STATE2] = (_3DSTATE_MODES_2_CMD |
                                          ENABLE_GLOBAL_DEPTH_BIAS |
                                          GLOBAL_DEPTH_BIAS(0) |
                                          ENABLE_ALPHA_TEST_FUNC |
                                          ALPHA_TEST_FUNC(COMPAREFUNC_ALWAYS)
                                          | ALPHA_REF_VALUE(0));

   i830->state.Ctx[I830_CTXREG_STATE3] = (_3DSTATE_MODES_3_CMD |
                                          ENABLE_DEPTH_TEST_FUNC |
                                          DEPTH_TEST_FUNC(COMPAREFUNC_LESS) |
                                          ENABLE_ALPHA_SHADE_MODE |
                                          ALPHA_SHADE_MODE(SHADE_MODE_LINEAR)
                                          | ENABLE_FOG_SHADE_MODE |
                                          FOG_SHADE_MODE(SHADE_MODE_LINEAR) |
                                          ENABLE_SPEC_SHADE_MODE |
                                          SPEC_SHADE_MODE(SHADE_MODE_LINEAR) |
                                          ENABLE_COLOR_SHADE_MODE |
                                          COLOR_SHADE_MODE(SHADE_MODE_LINEAR)
                                          | ENABLE_CULL_MODE | CULLMODE_NONE);

   i830->state.Ctx[I830_CTXREG_STATE4] = (_3DSTATE_MODES_4_CMD |
                                          ENABLE_LOGIC_OP_FUNC |
                                          LOGIC_OP_FUNC(LOGICOP_COPY) |
                                          ENABLE_STENCIL_TEST_MASK |
                                          STENCIL_TEST_MASK(0xff) |
                                          ENABLE_STENCIL_WRITE_MASK |
                                          STENCIL_WRITE_MASK(0xff));

   i830->state.Ctx[I830_CTXREG_STENCILTST] = (_3DSTATE_STENCIL_TEST_CMD |
                                              ENABLE_STENCIL_PARMS |
                                              STENCIL_FAIL_OP(STENCILOP_KEEP)
                                              |
                                              STENCIL_PASS_DEPTH_FAIL_OP
                                              (STENCILOP_KEEP) |
                                              STENCIL_PASS_DEPTH_PASS_OP
                                              (STENCILOP_KEEP) |
                                              ENABLE_STENCIL_TEST_FUNC |
                                              STENCIL_TEST_FUNC
                                              (COMPAREFUNC_ALWAYS) |
                                              ENABLE_STENCIL_REF_VALUE |
                                              STENCIL_REF_VALUE(0));

   i830->state.Ctx[I830_CTXREG_STATE5] = (_3DSTATE_MODES_5_CMD | FLUSH_TEXTURE_CACHE | ENABLE_SPRITE_POINT_TEX | SPRITE_POINT_TEX_OFF | ENABLE_FIXED_LINE_WIDTH | FIXED_LINE_WIDTH(0x2) |       /* 1.0 */
                                          ENABLE_FIXED_POINT_WIDTH |
                                          FIXED_POINT_WIDTH(1));

   i830->state.Ctx[I830_CTXREG_IALPHAB] = (_3DSTATE_INDPT_ALPHA_BLEND_CMD |
                                           DISABLE_INDPT_ALPHA_BLEND |
                                           ENABLE_ALPHA_BLENDFUNC |
                                           ABLENDFUNC_ADD);

   i830->state.Ctx[I830_CTXREG_FOGCOLOR] = (_3DSTATE_FOG_COLOR_CMD |
                                            FOG_COLOR_RED(0) |
                                            FOG_COLOR_GREEN(0) |
                                            FOG_COLOR_BLUE(0));

   i830->state.Ctx[I830_CTXREG_BLENDCOLOR0] = _3DSTATE_CONST_BLEND_COLOR_CMD;
   i830->state.Ctx[I830_CTXREG_BLENDCOLOR1] = 0;

   i830->state.Ctx[I830_CTXREG_MCSB0] = _3DSTATE_MAP_COORD_SETBIND_CMD;
   i830->state.Ctx[I830_CTXREG_MCSB1] = (TEXBIND_SET3(TEXCOORDSRC_VTXSET_3) |
                                         TEXBIND_SET2(TEXCOORDSRC_VTXSET_2) |
                                         TEXBIND_SET1(TEXCOORDSRC_VTXSET_1) |
                                         TEXBIND_SET0(TEXCOORDSRC_VTXSET_0));

   i830->state.RasterRules[I830_RASTER_RULES] = (_3DSTATE_RASTER_RULES_CMD |
						 ENABLE_POINT_RASTER_RULE |
						 OGL_POINT_RASTER_RULE |
						 ENABLE_LINE_STRIP_PROVOKE_VRTX |
						 ENABLE_TRI_FAN_PROVOKE_VRTX |
						 ENABLE_TRI_STRIP_PROVOKE_VRTX |
						 LINE_STRIP_PROVOKE_VRTX(1) |
						 TRI_FAN_PROVOKE_VRTX(2) |
						 TRI_STRIP_PROVOKE_VRTX(2));


   i830->state.Stipple[I830_STPREG_ST0] = _3DSTATE_STIPPLE;

   i830->state.Buffer[I830_DESTREG_DV0] = _3DSTATE_DST_BUF_VARS_CMD;
   i830->state.Buffer[I830_DESTREG_SENABLE] = (_3DSTATE_SCISSOR_ENABLE_CMD |
                                               DISABLE_SCISSOR_RECT);
   i830->state.Buffer[I830_DESTREG_SR0] = _3DSTATE_SCISSOR_RECT_0_CMD;
   i830->state.Buffer[I830_DESTREG_SR1] = 0;
   i830->state.Buffer[I830_DESTREG_SR2] = 0;
}

void
i830_update_provoking_vertex(struct gl_context * ctx)
{
   struct i830_context *i830 = i830_context(ctx);

   I830_STATECHANGE(i830, I830_UPLOAD_RASTER_RULES);
   i830->state.RasterRules[I830_RASTER_RULES] &= ~(LINE_STRIP_PROVOKE_VRTX_MASK |
						   TRI_FAN_PROVOKE_VRTX_MASK |
						   TRI_STRIP_PROVOKE_VRTX_MASK);

   /* _NEW_LIGHT */
   if (ctx->Light.ProvokingVertex == GL_LAST_VERTEX_CONVENTION) {
      i830->state.RasterRules[I830_RASTER_RULES] |= (LINE_STRIP_PROVOKE_VRTX(1) |
						     TRI_FAN_PROVOKE_VRTX(2) |
						     TRI_STRIP_PROVOKE_VRTX(2));
   } else {
      i830->state.RasterRules[I830_RASTER_RULES] |= (LINE_STRIP_PROVOKE_VRTX(0) |
						     TRI_FAN_PROVOKE_VRTX(1) |
						     TRI_STRIP_PROVOKE_VRTX(0));
    }
}

/* Fallback to swrast for select and feedback.
 */
static void
i830RenderMode(struct gl_context *ctx, GLenum mode)
{
   struct intel_context *intel = intel_context(ctx);
   FALLBACK(intel, INTEL_FALLBACK_RENDERMODE, (mode != GL_RENDER));
}

void
i830InitStateFuncs(struct dd_function_table *functions)
{
   functions->AlphaFunc = i830AlphaFunc;
   functions->BlendColor = i830BlendColor;
   functions->BlendEquationSeparate = i830BlendEquationSeparate;
   functions->BlendFuncSeparate = i830BlendFuncSeparate;
   functions->ColorMask = i830ColorMask;
   functions->CullFace = i830CullFaceFrontFace;
   functions->DepthFunc = i830DepthFunc;
   functions->DepthMask = i830DepthMask;
   functions->Enable = i830Enable;
   functions->Fogfv = i830Fogfv;
   functions->FrontFace = i830CullFaceFrontFace;
   functions->LightModelfv = i830LightModelfv;
   functions->LineWidth = i830LineWidth;
   functions->LogicOpcode = i830LogicOp;
   functions->PointSize = i830PointSize;
   functions->PolygonStipple = i830PolygonStipple;
   functions->RenderMode = i830RenderMode;
   functions->Scissor = i830Scissor;
   functions->ShadeModel = i830ShadeModel;
   functions->StencilFuncSeparate = i830StencilFuncSeparate;
   functions->StencilMaskSeparate = i830StencilMaskSeparate;
   functions->StencilOpSeparate = i830StencilOpSeparate;
   functions->DepthRange = i830DepthRange;
}

void
i830InitState(struct i830_context *i830)
{
   struct gl_context *ctx = &i830->intel.ctx;

   i830_init_packets(i830);

   _mesa_init_driver_state(ctx);

   i830->state.emitted = 0;
   i830->state.active = (I830_UPLOAD_INVARIENT |
                         I830_UPLOAD_RASTER_RULES |
                         I830_UPLOAD_TEXBLEND(0) |
                         I830_UPLOAD_STIPPLE |
                         I830_UPLOAD_CTX | I830_UPLOAD_BUFFERS);
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d1072 2
a1076 2
   i830->state.Buffer[I830_DESTREG_SENABLE] = (_3DSTATE_SCISSOR_ENABLE_CMD |
                                               DISABLE_SCISSOR_RECT);
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a1071 2
   i830->state.Buffer[I830_DESTREG_SENABLE] = (_3DSTATE_SCISSOR_ENABLE_CMD |
                                               DISABLE_SCISSOR_RECT);
d1075 2
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
a453 9
/** Called from ctx->Driver.Viewport() */
static void
i830Viewport(struct gl_context * ctx,
              GLint x, GLint y, GLsizei width, GLsizei height)
{
   intelCalcViewport(ctx);
}


d456 1
a456 1
i830DepthRange(struct gl_context * ctx, GLclampd nearval, GLclampd farval)
d530 1
a530 1
i830Scissor(struct gl_context * ctx, GLint x, GLint y, GLsizei w, GLsizei h)
d538 3
a540 1
   DBG("%s %d,%d %dx%d\n", __FUNCTION__, x, y, w, h);
d543 6
a548 4
      x1 = x;
      y1 = ctx->DrawBuffer->Height - (y + h);
      x2 = x + w - 1;
      y2 = y1 + h - 1;
d554 6
a559 4
      x1 = x;
      y1 = y;
      x2 = x + w - 1;
      y2 = y + h - 1;
a1135 1
   functions->Viewport = i830Viewport;
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d33 1
a36 2
#include "texmem.h"

d41 1
d238 1
a238 1
   if (_mesa_rgba_logicop_enabled(ctx)) {
d440 4
a443 1
   
d480 1
a480 1
   const GLubyte *m = mask;
d492 6
d549 1
a549 1
   if (ctx->DrawBuffer->Name == 0) {
d808 3
d861 1
a861 1
         GLboolean hw_stencil = GL_FALSE;
d865 1
a865 1
            hw_stencil = (irbStencil && irbStencil->region);
d1104 9
d1132 1
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d34 1
d238 1
a238 1
   if (RGBA_LOGICOP_ENABLED(ctx)) {
d295 2
a296 2
      SRC_BLND_FACT(intel_translate_blend_factor(ctx->Color.BlendSrcRGB))
      | DST_BLND_FACT(intel_translate_blend_factor(ctx->Color.BlendDstRGB));
d298 1
a298 1
   switch (ctx->Color.BlendEquationRGB) {
d318 1
a318 1
              __FUNCTION__, __LINE__, ctx->Color.BlendEquationRGB);
d323 2
a324 2
   funcA = SRC_ABLEND_FACT(intel_translate_blend_factor(ctx->Color.BlendSrcA))
      | DST_ABLEND_FACT(intel_translate_blend_factor(ctx->Color.BlendDstA));
d326 1
a326 1
   switch (ctx->Color.BlendEquationA) {
d346 1
a346 1
              __FUNCTION__, __LINE__, ctx->Color.BlendEquationA);
d683 1
a683 1
   if (NEED_SECONDARY_COLOR(ctx))
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d50 1
a50 1
i830StencilFuncSeparate(GLcontext * ctx, GLenum face, GLenum func, GLint ref,
d75 1
a75 1
i830StencilMaskSeparate(GLcontext * ctx, GLenum face, GLuint mask)
d90 1
a90 1
i830StencilOpSeparate(GLcontext * ctx, GLenum face, GLenum fail, GLenum zfail,
d202 1
a202 1
i830AlphaFunc(GLcontext * ctx, GLenum func, GLfloat ref)
d231 1
a231 1
i830EvalLogicOpBlendState(GLcontext * ctx)
d258 1
a258 1
i830BlendColor(GLcontext * ctx, const GLfloat color[4])
d282 1
a282 1
i830_set_blend_state(GLcontext * ctx)
d388 1
a388 1
i830BlendEquationSeparate(GLcontext * ctx, GLenum modeRGB, GLenum modeA)
d401 1
a401 1
i830BlendFuncSeparate(GLcontext * ctx, GLenum sfactorRGB,
d420 1
a420 1
i830DepthFunc(GLcontext * ctx, GLenum func)
d434 1
a434 1
i830DepthMask(GLcontext * ctx, GLboolean flag)
d452 1
a452 1
i830Viewport(GLcontext * ctx,
a455 2

   intel_viewport(ctx, x, y, width, height);
d461 1
a461 1
i830DepthRange(GLcontext * ctx, GLclampd nearval, GLclampd farval)
d473 1
a473 1
i830PolygonStipple(GLcontext * ctx, const GLubyte * mask)
d529 1
a529 1
i830Scissor(GLcontext * ctx, GLint x, GLint y, GLsizei w, GLsizei h)
d569 1
a569 1
i830LogicOp(GLcontext * ctx, GLenum opcode)
d584 1
a584 1
i830CullFaceFrontFace(GLcontext * ctx, GLenum unused)
d612 1
a612 1
i830LineWidth(GLcontext * ctx, GLfloat widthf)
d633 1
a633 1
i830PointSize(GLcontext * ctx, GLfloat size)
d653 1
a653 1
i830ColorMask(GLcontext * ctx,
d675 1
a675 1
update_specular(GLcontext * ctx)
d689 1
a689 1
i830LightModelfv(GLcontext * ctx, GLenum pname, const GLfloat * param)
d701 1
a701 1
i830ShadeModel(GLcontext * ctx, GLenum mode)
d730 1
a730 1
i830Fogfv(GLcontext * ctx, GLenum pname, const GLfloat * param)
d751 1
a751 1
i830Enable(GLcontext * ctx, GLenum cap, GLboolean state)
d1070 1
a1070 1
i830_update_provoking_vertex(GLcontext * ctx)
d1122 1
a1122 1
   GLcontext *ctx = &i830->intel.ctx;
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d42 1
d450 18
d623 1
a623 1
   CLAMP_SELF(width, 1, 15);
d642 1
a642 1
   CLAMP_SELF(point_size, 1, 256);
d1050 10
d1071 21
d1117 2
a1129 3
   memcpy(&i830->initial, &i830->state, sizeof(i830->state));

   i830->current = &i830->state;
d1132 1
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d29 5
a33 5
#include "glheader.h"
#include "context.h"
#include "macros.h"
#include "enums.h"
#include "dd.h"
@


1.1
log
@Initial revision
@
text
@d37 2
d41 1
d46 2
d49 1
a49 1
i830StencilFuncSeparate(GLcontext *ctx, GLenum face, GLenum func, GLint ref,
d52 1
a52 1
   i830ContextPtr i830 = I830_CONTEXT(ctx);
d57 2
a58 3
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s : func: %s, ref : 0x%x, mask: 0x%x\n", __FUNCTION__,
	      _mesa_lookup_enum_by_nr(func), ref, mask);
d64 1
a64 1
					STENCIL_TEST_MASK(mask));
d66 1
a66 1
					     ENABLE_STENCIL_TEST_FUNC_MASK);
d68 3
a70 3
					    ENABLE_STENCIL_TEST_FUNC |
					    STENCIL_REF_VALUE(ref) |
					    STENCIL_TEST_FUNC(test));
d74 1
a74 1
i830StencilMaskSeparate(GLcontext *ctx, GLenum face, GLuint mask)
d76 1
a76 4
   i830ContextPtr i830 = I830_CONTEXT(ctx);

   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s : mask 0x%x\n", __FUNCTION__, mask);
d78 2
d85 1
a85 1
					STENCIL_WRITE_MASK(mask));
d89 1
a89 1
i830StencilOpSeparate(GLcontext *ctx, GLenum face, GLenum fail, GLenum zfail,
d92 1
a92 1
   i830ContextPtr i830 = I830_CONTEXT(ctx);
d95 12
a106 11
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s: fail : %s, zfail: %s, zpass : %s\n", __FUNCTION__,
	      _mesa_lookup_enum_by_nr(fail),
	      _mesa_lookup_enum_by_nr(zfail),
	      _mesa_lookup_enum_by_nr(zpass));

   fop = 0; dfop = 0; dpop = 0;

   switch(fail) {
   case GL_KEEP: 
      fop = STENCILOP_KEEP; 
d108 2
a109 2
   case GL_ZERO: 
      fop = STENCILOP_ZERO; 
d111 2
a112 2
   case GL_REPLACE: 
      fop = STENCILOP_REPLACE; 
d114 1
a114 1
   case GL_INCR: 
d117 1
a117 1
   case GL_DECR: 
d121 1
a121 1
      fop = STENCILOP_INCR; 
d124 1
a124 1
      fop = STENCILOP_DECR; 
d126 2
a127 2
   case GL_INVERT: 
      fop = STENCILOP_INVERT; 
d129 1
a129 1
   default: 
d132 3
a134 3
   switch(zfail) {
   case GL_KEEP: 
      dfop = STENCILOP_KEEP; 
d136 2
a137 2
   case GL_ZERO: 
      dfop = STENCILOP_ZERO; 
d139 2
a140 2
   case GL_REPLACE: 
      dfop = STENCILOP_REPLACE; 
d142 1
a142 1
   case GL_INCR: 
d145 1
a145 1
   case GL_DECR: 
d149 1
a149 1
      dfop = STENCILOP_INCR; 
d152 1
a152 1
      dfop = STENCILOP_DECR; 
d154 2
a155 2
   case GL_INVERT: 
      dfop = STENCILOP_INVERT; 
d157 1
a157 1
   default: 
d160 3
a162 3
   switch(zpass) {
   case GL_KEEP: 
      dpop = STENCILOP_KEEP; 
d164 2
a165 2
   case GL_ZERO: 
      dpop = STENCILOP_ZERO; 
d167 2
a168 2
   case GL_REPLACE: 
      dpop = STENCILOP_REPLACE; 
d170 1
a170 1
   case GL_INCR: 
d173 1
a173 1
   case GL_DECR: 
d177 1
a177 1
      dpop = STENCILOP_INCR; 
d180 1
a180 1
      dpop = STENCILOP_DECR; 
d182 2
a183 2
   case GL_INVERT: 
      dpop = STENCILOP_INVERT; 
d185 1
a185 1
   default: 
d193 5
a197 3
					    STENCIL_FAIL_OP(fop) |
					    STENCIL_PASS_DEPTH_FAIL_OP(dfop) |
					    STENCIL_PASS_DEPTH_PASS_OP(dpop));
d200 2
a201 1
static void i830AlphaFunc(GLcontext *ctx, GLenum func, GLfloat ref)
d203 1
a203 1
   i830ContextPtr i830 = I830_CONTEXT(ctx);
d209 1
a209 1
   refInt = (GLuint)refByte;
d214 3
a216 3
					ENABLE_ALPHA_REF_VALUE |
					ALPHA_TEST_FUNC(test) |
					ALPHA_REF_VALUE(refInt));
d229 2
a230 1
static void i830EvalLogicOpBlendState(GLcontext *ctx)
d232 1
a232 1
   i830ContextPtr i830 = I830_CONTEXT(ctx);
d236 1
a236 1
   if (ctx->Color._LogicOpEnabled) {
d238 1
a238 1
					       ENABLE_LOGIC_OP_MASK);
d240 3
a242 2
					      ENABLE_LOGIC_OP);
   } else if (ctx->Color.BlendEnabled) {
d244 1
a244 1
					       ENABLE_LOGIC_OP_MASK);
d246 3
a248 2
					      DISABLE_LOGIC_OP);
   } else {
d250 1
a250 1
					       ENABLE_LOGIC_OP_MASK);
d252 1
a252 1
					      DISABLE_LOGIC_OP);
d256 2
a257 1
static void i830BlendColor(GLcontext *ctx, const GLfloat color[4])
d259 1
a259 1
   i830ContextPtr i830 = I830_CONTEXT(ctx);
d262 2
a263 3
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s\n", __FUNCTION__);

d270 2
a271 1
   i830->state.Ctx[I830_CTXREG_BLENDCOLOR1] = (a<<24) | (r<<16) | (g<<8) | b;
d280 2
a281 1
static void i830_set_blend_state( GLcontext * ctx )
d283 1
a283 1
   i830ContextPtr i830 = I830_CONTEXT(ctx);
d292 3
a294 2
   funcRGB = SRC_BLND_FACT( intel_translate_blend_factor( ctx->Color.BlendSrcRGB ) )
       | DST_BLND_FACT( intel_translate_blend_factor( ctx->Color.BlendDstRGB ) );
d296 1
a296 1
   switch(ctx->Color.BlendEquationRGB) {
d298 1
a298 1
      eqnRGB = BLENDFUNC_ADD; 
d304 1
a304 1
   case GL_MAX: 
d308 2
a309 2
   case GL_FUNC_SUBTRACT: 
      eqnRGB = BLENDFUNC_SUB; 
d312 1
a312 1
      eqnRGB = BLENDFUNC_RVRSE_SUB; 
d315 2
a316 2
      fprintf( stderr, "[%s:%u] Invalid RGB blend equation (0x%04x).\n",
	       __FUNCTION__, __LINE__, ctx->Color.BlendEquationRGB );
d321 2
a322 2
   funcA = SRC_ABLEND_FACT( intel_translate_blend_factor( ctx->Color.BlendSrcA ) )
       | DST_ABLEND_FACT( intel_translate_blend_factor( ctx->Color.BlendDstA ) );
d324 1
a324 1
   switch(ctx->Color.BlendEquationA) {
d326 1
a326 1
      eqnA = BLENDFUNC_ADD; 
d328 1
a328 1
   case GL_MIN: 
d332 1
a332 1
   case GL_MAX: 
d336 2
a337 2
   case GL_FUNC_SUBTRACT: 
      eqnA = BLENDFUNC_SUB; 
d340 1
a340 1
      eqnA = BLENDFUNC_RVRSE_SUB; 
d343 2
a344 2
      fprintf( stderr, "[%s:%u] Invalid alpha blend equation (0x%04x).\n",
	       __FUNCTION__, __LINE__, ctx->Color.BlendEquationA );
d349 3
a351 3
       | _3DSTATE_INDPT_ALPHA_BLEND_CMD
       | ENABLE_SRC_ABLEND_FACTOR | ENABLE_DST_ABLEND_FACTOR
       | ENABLE_ALPHA_BLENDFUNC;
d353 3
a355 3
       | _3DSTATE_MODES_1_CMD
       | ENABLE_SRC_BLND_FACTOR | ENABLE_DST_BLND_FACTOR
       | ENABLE_COLR_BLND_FUNC;
d357 1
a357 1
   if ( (eqnA | funcA) != (eqnRGB | funcRGB) )
d377 5
a381 5
      fprintf(stderr, "[%s:%u] STATE1: 0x%08x IALPHAB: 0x%08x blend is %sabled\n",
	      __FUNCTION__, __LINE__,
	      i830->state.Ctx[I830_CTXREG_STATE1],
	      i830->state.Ctx[I830_CTXREG_IALPHAB],
	      (ctx->Color.BlendEnabled) ? "en" : "dis");
d386 2
a387 2
static void i830BlendEquationSeparate(GLcontext *ctx, GLenum modeRGB,
				      GLenum modeA) 
d389 3
a391 4
   if (INTEL_DEBUG&DEBUG_DRI)
     fprintf(stderr, "%s -> %s, %s\n", __FUNCTION__,
	     _mesa_lookup_enum_by_nr(modeRGB),
	     _mesa_lookup_enum_by_nr(modeA));
d395 1
a395 1
   i830_set_blend_state( ctx );
d399 3
a401 3
static void i830BlendFuncSeparate(GLcontext *ctx, GLenum sfactorRGB, 
				  GLenum dfactorRGB, GLenum sfactorA,
				  GLenum dfactorA )
d403 5
a407 6
   if (INTEL_DEBUG&DEBUG_DRI)
     fprintf(stderr, "%s -> RGB(%s, %s) A(%s, %s)\n", __FUNCTION__,
	     _mesa_lookup_enum_by_nr(sfactorRGB),
	     _mesa_lookup_enum_by_nr(dfactorRGB),
	     _mesa_lookup_enum_by_nr(sfactorA),
	     _mesa_lookup_enum_by_nr(dfactorA));
d413 1
a413 1
   i830_set_blend_state( ctx );
d418 2
a419 1
static void i830DepthFunc(GLcontext *ctx, GLenum func)
d421 1
a421 1
   i830ContextPtr i830 = I830_CONTEXT(ctx);
d424 2
a425 3
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s\n", __FUNCTION__);

d429 1
a429 1
				       DEPTH_TEST_FUNC(test));
d432 2
a433 1
static void i830DepthMask(GLcontext *ctx, GLboolean flag)
d435 1
a435 4
   i830ContextPtr i830 = I830_CONTEXT(ctx);

   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s flag (%d)\n", __FUNCTION__, flag);
d437 2
d455 2
a456 1
static void i830PolygonStipple( GLcontext *ctx, const GLubyte *mask )
d458 1
a458 1
   i830ContextPtr i830 = I830_CONTEXT(ctx);
d461 1
a461 1
   int i,j,k;
d463 1
a463 1
		 i830->intel.reduced_primitive == GL_TRIANGLES);
d471 16
a486 12
   p[0] = mask[12] & 0xf; p[0] |= p[0] << 4;
   p[1] = mask[8] & 0xf; p[1] |= p[1] << 4;
   p[2] = mask[4] & 0xf; p[2] |= p[2] << 4;
   p[3] = mask[0] & 0xf; p[3] |= p[3] << 4;

   for (k = 0 ; k < 8 ; k++)
      for (j = 3 ; j >= 0; j--)
	 for (i = 0 ; i < 4 ; i++, m++)
	    if (*m != p[j]) {
	       i830->intel.hw_stipple = 0;
	       return;
	    }
d489 2
a490 3
	      ((p[1] & 0xf) << 4) |
	      ((p[2] & 0xf) << 8) |
	      ((p[3] & 0xf) << 12));
d511 2
a512 2
static void i830Scissor(GLcontext *ctx, GLint x, GLint y, 
			GLsizei w, GLsizei h)
d514 1
a514 2
   i830ContextPtr i830 = I830_CONTEXT(ctx);
   intelScreenPrivate *screen = i830->intel.intelScreen;
d517 1
a517 1
   if (!i830->intel.driDrawable)
d520 1
a520 18
   x1 = x;
   y1 = i830->intel.driDrawable->h - (y + h);
   x2 = x + w - 1;
   y2 = y1 + h - 1;

   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "[%s] x(%d) y(%d) w(%d) h(%d)\n", __FUNCTION__,
	      x, y, w, h);

   if (x1 < 0) x1 = 0;
   if (y1 < 0) y1 = 0;
   if (x2 < 0) x2 = 0;
   if (y2 < 0) y2 = 0;

   if (x2 >= screen->width) x2 = screen->width-1;
   if (y2 >= screen->height) y2 = screen->height-1;
   if (x1 >= screen->width) x1 = screen->width-1;
   if (y1 >= screen->height) y1 = screen->height-1;
d522 23
d551 2
a552 1
static void i830LogicOp(GLcontext *ctx, GLenum opcode)
d554 2
a555 5
   i830ContextPtr i830 = I830_CONTEXT(ctx);
   int tmp = intel_translate_logic_op( opcode );

   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s\n", __FUNCTION__);
d557 2
d566 2
a567 1
static void i830CullFaceFrontFace(GLcontext *ctx, GLenum unused)
d569 1
a569 1
   i830ContextPtr i830 = I830_CONTEXT(ctx);
d572 2
a573 3
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s\n", __FUNCTION__);

d581 1
a581 1
	 mode ^= (CULLMODE_CW ^ CULLMODE_CCW);
d583 1
a583 1
	 mode ^= (CULLMODE_CW ^ CULLMODE_CCW);
d594 2
a595 1
static void i830LineWidth( GLcontext *ctx, GLfloat widthf )
d597 1
a597 1
   i830ContextPtr i830 = I830_CONTEXT( ctx );
d601 4
a604 2
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s\n", __FUNCTION__);
a605 3
   width = (int)(widthf * 2);
   CLAMP_SELF(width, 1, 15);
   
d615 2
a616 1
static void i830PointSize(GLcontext *ctx, GLfloat size)
d618 2
a619 5
   i830ContextPtr i830 = I830_CONTEXT(ctx);
   GLint point_size = (int)size;

   if (INTEL_DEBUG&DEBUG_DRI)
     fprintf(stderr, "%s\n", __FUNCTION__);
d621 2
d627 1
a627 1
				       FIXED_POINT_WIDTH(point_size));
d635 3
a637 3
static void i830ColorMask(GLcontext *ctx,
			  GLboolean r, GLboolean g,
			  GLboolean b, GLboolean a)
d639 1
a639 1
   i830ContextPtr i830 = I830_CONTEXT( ctx );
d642 1
a642 2
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s r(%d) g(%d) b(%d) a(%d)\n", __FUNCTION__, r, g, b, a);
d645 5
a649 6
	  ENABLE_COLOR_MASK |
	  ENABLE_COLOR_WRITE |
	  ((!r) << WRITEMASK_RED_SHIFT) |
	  ((!g) << WRITEMASK_GREEN_SHIFT) |
	  ((!b) << WRITEMASK_BLUE_SHIFT) |
	  ((!a) << WRITEMASK_ALPHA_SHIFT));
d657 2
a658 1
static void update_specular( GLcontext *ctx )
d660 1
a660 1
   i830ContextPtr i830 = I830_CONTEXT( ctx );
d671 2
a672 2
static void i830LightModelfv(GLcontext *ctx, GLenum pname, 
			     const GLfloat *param)
d674 2
a675 3
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s\n", __FUNCTION__);

d677 1
a677 1
      update_specular( ctx );
d683 2
a684 1
static void i830ShadeModel(GLcontext *ctx, GLenum mode)
d686 1
a686 1
   i830ContextPtr i830 = I830_CONTEXT(ctx);
d695 11
a705 9
     i830->state.Ctx[I830_CTXREG_STATE3] |= (ALPHA_SHADE_MODE(SHADE_MODE_FLAT) |
					  FOG_SHADE_MODE(SHADE_MODE_FLAT) |
					  SPEC_SHADE_MODE(SHADE_MODE_FLAT) |
					  COLOR_SHADE_MODE(SHADE_MODE_FLAT));
   } else {
     i830->state.Ctx[I830_CTXREG_STATE3] |= (ALPHA_SHADE_MODE(SHADE_MODE_LINEAR) |
					  FOG_SHADE_MODE(SHADE_MODE_LINEAR) |
					  SPEC_SHADE_MODE(SHADE_MODE_LINEAR) |
					  COLOR_SHADE_MODE(SHADE_MODE_LINEAR));
d712 2
a713 1
static void i830Fogfv(GLcontext *ctx, GLenum pname, const GLfloat *param)
d715 1
a715 1
   i830ContextPtr i830 = I830_CONTEXT(ctx);
d717 6
a722 7
   if (INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s\n", __FUNCTION__);

   if (pname == GL_FOG_COLOR) {      
      GLuint color = (((GLubyte)(ctx->Fog.Color[0]*255.0F) << 16) |
		      ((GLubyte)(ctx->Fog.Color[1]*255.0F) << 8) |
		      ((GLubyte)(ctx->Fog.Color[2]*255.0F) << 0));
d725 2
a726 1
      i830->state.Ctx[I830_CTXREG_FOGCOLOR] = (_3DSTATE_FOG_COLOR_CMD | color);
d733 2
a734 1
static void i830Enable(GLcontext *ctx, GLenum cap, GLboolean state)
d736 1
a736 1
   i830ContextPtr i830 = I830_CONTEXT(ctx);
d738 1
a738 1
   switch(cap) {
d741 1
a741 1
      update_specular( ctx );
d748 1
a748 1
	 i830->state.Ctx[I830_CTXREG_ENABLES_1] |= ENABLE_ALPHA_TEST;
d750 1
a750 1
	 i830->state.Ctx[I830_CTXREG_ENABLES_1] |= DISABLE_ALPHA_TEST;
d763 2
a764 2
      if (i830->intel.intelScreen->cpp == 2)
	 FALLBACK( &i830->intel, I830_FALLBACK_LOGICOP, state );
d766 1
a766 1
 
d772 1
a772 1
	 i830->state.Ctx[I830_CTXREG_ENABLES_2] |= ENABLE_DITHER;
d774 1
a774 1
	 i830->state.Ctx[I830_CTXREG_ENABLES_2] |= DISABLE_DITHER;
d782 1
a782 1
	 i830->state.Ctx[I830_CTXREG_ENABLES_1] |= ENABLE_DEPTH_TEST;
d784 1
a784 1
	 i830->state.Ctx[I830_CTXREG_ENABLES_1] |= DISABLE_DEPTH_TEST;
d788 1
a788 1
      i830DepthMask( ctx, ctx->Depth.Mask );
d793 1
a793 1
      
d795 2
a796 3
	 i830->state.Buffer[I830_DESTREG_SENABLE] = 
	    (_3DSTATE_SCISSOR_ENABLE_CMD |
	     ENABLE_SCISSOR_RECT);
d798 2
a799 3
	 i830->state.Buffer[I830_DESTREG_SENABLE] = 
	    (_3DSTATE_SCISSOR_ENABLE_CMD |
	     DISABLE_SCISSOR_RECT);
d805 1
a805 1
      
d808 1
a808 1
	 i830->state.Ctx[I830_CTXREG_AA] |= AA_LINE_ENABLE;
d810 1
a810 1
	 i830->state.Ctx[I830_CTXREG_AA] |= AA_LINE_DISABLE;
d817 1
a817 1
	 i830->state.Ctx[I830_CTXREG_ENABLES_1] |= ENABLE_FOG;
d819 1
a819 1
	 i830->state.Ctx[I830_CTXREG_ENABLES_1] |= DISABLE_FOG;
d830 26
a855 14
      if (i830->intel.hw_stencil) {
	 I830_STATECHANGE(i830, I830_UPLOAD_CTX);

	 if (state) {
	    i830->state.Ctx[I830_CTXREG_ENABLES_1] |= ENABLE_STENCIL_TEST;
	    i830->state.Ctx[I830_CTXREG_ENABLES_2] |= ENABLE_STENCIL_WRITE;
	 } else {
	    i830->state.Ctx[I830_CTXREG_ENABLES_1] &= ~ENABLE_STENCIL_TEST;
	    i830->state.Ctx[I830_CTXREG_ENABLES_2] &= ~ENABLE_STENCIL_WRITE;
	    i830->state.Ctx[I830_CTXREG_ENABLES_1] |= DISABLE_STENCIL_TEST;
	    i830->state.Ctx[I830_CTXREG_ENABLES_2] |= DISABLE_STENCIL_WRITE;
	 }
      } else {
	 FALLBACK( &i830->intel, I830_FALLBACK_STENCIL, state );
d864 6
a869 7
      if (i830->intel.hw_stipple && 
	  i830->intel.reduced_primitive == GL_TRIANGLES)
      {
	 I830_STATECHANGE(i830, I830_UPLOAD_STIPPLE);
	 i830->state.Stipple[I830_STPREG_ST1] &= ~ST1_ENABLE;
	 if (state)
	    i830->state.Stipple[I830_STPREG_ST1] |= ST1_ENABLE;
d879 2
a880 1
static void i830_init_packets( i830ContextPtr i830 )
a881 2
   intelScreenPrivate *screen = i830->intel.intelScreen;

d887 7
a893 8
				  TEXPIPE_COLOR |
				  ENABLE_TEXOUTPUT_WRT_SEL |
				  TEXOP_OUTPUT_CURRENT |
				  DISABLE_TEX_CNTRL_STAGE |
				  TEXOP_SCALE_1X |
				  TEXOP_MODIFY_PARMS |
				  TEXOP_LAST_STAGE |
				  TEXBLENDOP_ARG1);
d895 5
a899 6
				  TEXPIPE_ALPHA |
				  ENABLE_TEXOUTPUT_WRT_SEL |
				  TEXOP_OUTPUT_CURRENT |
				  TEXOP_SCALE_1X |
				  TEXOP_MODIFY_PARMS |
				  TEXBLENDOP_ARG1);
d901 4
a904 4
				  TEXPIPE_COLOR |
				  TEXBLEND_ARG1 |
				  TEXBLENDARG_MODIFY_PARMS |
				  TEXBLENDARG_DIFFUSE);
d906 4
a909 4
				  TEXPIPE_ALPHA |
				  TEXBLEND_ARG1 |
				  TEXBLENDARG_MODIFY_PARMS |
				  TEXBLENDARG_DIFFUSE);
d914 1
a914 1
   i830->state.Ctx[I830_CTXREG_VF] =  0;
d918 5
a922 5
				      AA_LINE_ECAAR_WIDTH_ENABLE |
				      AA_LINE_ECAAR_WIDTH_1_0 |
				      AA_LINE_REGION_WIDTH_ENABLE |
				      AA_LINE_REGION_WIDTH_1_0 | 
				      AA_LINE_DISABLE);
d925 8
a932 8
					     DISABLE_LOGIC_OP |
					     DISABLE_STENCIL_TEST |
					     DISABLE_DEPTH_BIAS |
					     DISABLE_SPEC_ADD |
					     DISABLE_FOG |
					     DISABLE_ALPHA_TEST |
					     DISABLE_COLOR_BLEND |
					     DISABLE_DEPTH_TEST);
d934 1
d937 11
a947 8
						ENABLE_STENCIL_WRITE |
						ENABLE_TEX_CACHE |
						ENABLE_DITHER |
						ENABLE_COLOR_MASK |
						/* set no color comps disabled */
						ENABLE_COLOR_WRITE |
						ENABLE_DEPTH_WRITE);
   } else {
d949 7
a955 7
						DISABLE_STENCIL_WRITE |
						ENABLE_TEX_CACHE |
						ENABLE_DITHER |
						ENABLE_COLOR_MASK |
						/* set no color comps disabled */
						ENABLE_COLOR_WRITE |
						ENABLE_DEPTH_WRITE);
d959 6
a964 6
					  ENABLE_COLR_BLND_FUNC |
					  BLENDFUNC_ADD |
					  ENABLE_SRC_BLND_FACTOR |
					  SRC_BLND_FACT(BLENDFACT_ONE) | 
					  ENABLE_DST_BLND_FACTOR |
					  DST_BLND_FACT(BLENDFACT_ZERO) );
d967 5
a971 5
					  ENABLE_GLOBAL_DEPTH_BIAS | 
					  GLOBAL_DEPTH_BIAS(0) |
					  ENABLE_ALPHA_TEST_FUNC | 
					  ALPHA_TEST_FUNC(COMPAREFUNC_ALWAYS) |
					  ALPHA_REF_VALUE(0) );
d974 11
a984 12
					  ENABLE_DEPTH_TEST_FUNC |
					  DEPTH_TEST_FUNC(COMPAREFUNC_LESS) |
					  ENABLE_ALPHA_SHADE_MODE |
					  ALPHA_SHADE_MODE(SHADE_MODE_LINEAR) |
					  ENABLE_FOG_SHADE_MODE |
					  FOG_SHADE_MODE(SHADE_MODE_LINEAR) |
					  ENABLE_SPEC_SHADE_MODE |
					  SPEC_SHADE_MODE(SHADE_MODE_LINEAR) |
					  ENABLE_COLOR_SHADE_MODE |
					  COLOR_SHADE_MODE(SHADE_MODE_LINEAR) |
					  ENABLE_CULL_MODE |
					  CULLMODE_NONE);
d987 6
a992 6
					  ENABLE_LOGIC_OP_FUNC |
					  LOGIC_OP_FUNC(LOGICOP_COPY) |
					  ENABLE_STENCIL_TEST_MASK |
					  STENCIL_TEST_MASK(0xff) |
					  ENABLE_STENCIL_WRITE_MASK |
					  STENCIL_WRITE_MASK(0xff));
d995 16
a1010 17
					      ENABLE_STENCIL_PARMS |
					      STENCIL_FAIL_OP(STENCILOP_KEEP) |
					      STENCIL_PASS_DEPTH_FAIL_OP(STENCILOP_KEEP) |
					      STENCIL_PASS_DEPTH_PASS_OP(STENCILOP_KEEP) |
					      ENABLE_STENCIL_TEST_FUNC |
					      STENCIL_TEST_FUNC(COMPAREFUNC_ALWAYS) |
					      ENABLE_STENCIL_REF_VALUE |
					      STENCIL_REF_VALUE(0) );

   i830->state.Ctx[I830_CTXREG_STATE5] = (_3DSTATE_MODES_5_CMD |
					  FLUSH_TEXTURE_CACHE |
					  ENABLE_SPRITE_POINT_TEX |
					  SPRITE_POINT_TEX_OFF |
					  ENABLE_FIXED_LINE_WIDTH |
					  FIXED_LINE_WIDTH(0x2) | /* 1.0 */
					  ENABLE_FIXED_POINT_WIDTH |
					  FIXED_POINT_WIDTH(1) );
d1013 3
a1015 3
					   DISABLE_INDPT_ALPHA_BLEND |
					   ENABLE_ALPHA_BLENDFUNC |
					   ABLENDFUNC_ADD);
d1018 3
a1020 3
					    FOG_COLOR_RED(0) |
					    FOG_COLOR_GREEN(0) |
					    FOG_COLOR_BLUE(0));
d1027 4
a1030 4
					 TEXBIND_SET2(TEXCOORDSRC_VTXSET_2) |
					 TEXBIND_SET1(TEXCOORDSRC_VTXSET_1) |
					 TEXBIND_SET0(TEXCOORDSRC_VTXSET_0));
					 
a1033 15
   i830->state.Buffer[I830_DESTREG_CBUFADDR0] = _3DSTATE_BUF_INFO_CMD;
   i830->state.Buffer[I830_DESTREG_CBUFADDR1] = 
      (BUF_3D_ID_COLOR_BACK | 
       BUF_3D_PITCH(screen->front.pitch) |  /* pitch in bytes */
       BUF_3D_USE_FENCE);


   i830->state.Buffer[I830_DESTREG_DBUFADDR0] = _3DSTATE_BUF_INFO_CMD;
   i830->state.Buffer[I830_DESTREG_DBUFADDR1] = 
      (BUF_3D_ID_DEPTH |
       BUF_3D_PITCH(screen->depth.pitch) |  /* pitch in bytes */
       BUF_3D_USE_FENCE);
   i830->state.Buffer[I830_DESTREG_DBUFADDR2] = screen->depth.offset;


a1034 19

   switch (screen->fbFormat) {
   case DV_PF_555:
   case DV_PF_565:
      i830->state.Buffer[I830_DESTREG_DV1] = (DSTORG_HORT_BIAS(0x8) | /* .5 */
					      DSTORG_VERT_BIAS(0x8) | /* .5 */
					      screen->fbFormat |
					      DEPTH_IS_Z |
					      DEPTH_FRMT_16_FIXED);
      break;
   case DV_PF_8888:
      i830->state.Buffer[I830_DESTREG_DV1] = (DSTORG_HORT_BIAS(0x8) | /* .5 */
					      DSTORG_VERT_BIAS(0x8) | /* .5 */
					      screen->fbFormat |
					      DEPTH_IS_Z |
					      DEPTH_FRMT_24_FIXED_8_OTHER);
      break;
   }

d1036 1
a1036 1
					       DISABLE_SCISSOR_RECT);
d1043 2
a1044 1
void i830InitStateFuncs( struct dd_function_table *functions )
d1069 2
a1070 1
void i830InitState( i830ContextPtr i830 )
d1074 1
a1074 1
   i830_init_packets( i830 );
d1076 1
a1076 1
   intelInitState( ctx );
d1078 1
a1078 1
   memcpy( &i830->initial, &i830->state, sizeof(i830->state) );
d1082 4
a1085 4
   i830->state.active = (I830_UPLOAD_TEXBLEND(0) |
			 I830_UPLOAD_STIPPLE |
			 I830_UPLOAD_CTX |
			 I830_UPLOAD_BUFFERS);
a1086 5





@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d228 1
a228 1
   if (RGBA_LOGICOP_ENABLED(ctx)) {
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d29 5
a33 5
#include "main/glheader.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/enums.h"
#include "main/dd.h"
a36 2
#include "drivers/common/driverfuncs.h"

a38 2
#include "intel_fbo.h"
#include "intel_buffers.h"
a42 2
#define FILE_DEBUG_FLAG DEBUG_STATE

d44 1
a44 1
i830StencilFuncSeparate(struct gl_context * ctx, GLenum face, GLenum func, GLint ref,
d47 1
a47 1
   struct i830_context *i830 = i830_context(ctx);
d52 3
a54 2
   DBG("%s : func: %s, ref : 0x%x, mask: 0x%x\n", __FUNCTION__,
       _mesa_lookup_enum_by_nr(func), ref, mask);
d60 1
a60 1
                                           STENCIL_TEST_MASK(mask));
d62 1
a62 1
                                                ENABLE_STENCIL_TEST_FUNC_MASK);
d64 3
a66 3
                                               ENABLE_STENCIL_TEST_FUNC |
                                               STENCIL_REF_VALUE(ref) |
                                               STENCIL_TEST_FUNC(test));
d70 1
a70 1
i830StencilMaskSeparate(struct gl_context * ctx, GLenum face, GLuint mask)
d72 4
a75 1
   struct i830_context *i830 = i830_context(ctx);
a76 2
   DBG("%s : mask 0x%x\n", __FUNCTION__, mask);
   
d82 1
a82 1
                                           STENCIL_WRITE_MASK(mask));
d86 1
a86 1
i830StencilOpSeparate(struct gl_context * ctx, GLenum face, GLenum fail, GLenum zfail,
d89 1
a89 1
   struct i830_context *i830 = i830_context(ctx);
d92 11
a102 12
   DBG("%s: fail : %s, zfail: %s, zpass : %s\n", __FUNCTION__,
       _mesa_lookup_enum_by_nr(fail),
       _mesa_lookup_enum_by_nr(zfail), 
       _mesa_lookup_enum_by_nr(zpass));

   fop = 0;
   dfop = 0;
   dpop = 0;

   switch (fail) {
   case GL_KEEP:
      fop = STENCILOP_KEEP;
d104 2
a105 2
   case GL_ZERO:
      fop = STENCILOP_ZERO;
d107 2
a108 2
   case GL_REPLACE:
      fop = STENCILOP_REPLACE;
d110 1
a110 1
   case GL_INCR:
d113 1
a113 1
   case GL_DECR:
d117 1
a117 1
      fop = STENCILOP_INCR;
d120 1
a120 1
      fop = STENCILOP_DECR;
d122 2
a123 2
   case GL_INVERT:
      fop = STENCILOP_INVERT;
d125 1
a125 1
   default:
d128 3
a130 3
   switch (zfail) {
   case GL_KEEP:
      dfop = STENCILOP_KEEP;
d132 2
a133 2
   case GL_ZERO:
      dfop = STENCILOP_ZERO;
d135 2
a136 2
   case GL_REPLACE:
      dfop = STENCILOP_REPLACE;
d138 1
a138 1
   case GL_INCR:
d141 1
a141 1
   case GL_DECR:
d145 1
a145 1
      dfop = STENCILOP_INCR;
d148 1
a148 1
      dfop = STENCILOP_DECR;
d150 2
a151 2
   case GL_INVERT:
      dfop = STENCILOP_INVERT;
d153 1
a153 1
   default:
d156 3
a158 3
   switch (zpass) {
   case GL_KEEP:
      dpop = STENCILOP_KEEP;
d160 2
a161 2
   case GL_ZERO:
      dpop = STENCILOP_ZERO;
d163 2
a164 2
   case GL_REPLACE:
      dpop = STENCILOP_REPLACE;
d166 1
a166 1
   case GL_INCR:
d169 1
a169 1
   case GL_DECR:
d173 1
a173 1
      dpop = STENCILOP_INCR;
d176 1
a176 1
      dpop = STENCILOP_DECR;
d178 2
a179 2
   case GL_INVERT:
      dpop = STENCILOP_INVERT;
d181 1
a181 1
   default:
d189 3
a191 5
                                               STENCIL_FAIL_OP(fop) |
                                               STENCIL_PASS_DEPTH_FAIL_OP
                                               (dfop) |
                                               STENCIL_PASS_DEPTH_PASS_OP
                                               (dpop));
d194 1
a194 2
static void
i830AlphaFunc(struct gl_context * ctx, GLenum func, GLfloat ref)
d196 1
a196 1
   struct i830_context *i830 = i830_context(ctx);
d202 1
a202 1
   refInt = (GLuint) refByte;
d207 3
a209 3
                                           ENABLE_ALPHA_REF_VALUE |
                                           ALPHA_TEST_FUNC(test) |
                                           ALPHA_REF_VALUE(refInt));
d222 1
a222 2
static void
i830EvalLogicOpBlendState(struct gl_context * ctx)
d224 1
a224 1
   struct i830_context *i830 = i830_context(ctx);
d230 1
a230 1
                                                  ENABLE_LOGIC_OP_MASK);
d232 2
a233 3
                                                 ENABLE_LOGIC_OP);
   }
   else if (ctx->Color.BlendEnabled) {
d235 1
a235 1
                                                  ENABLE_LOGIC_OP_MASK);
d237 2
a238 3
                                                 DISABLE_LOGIC_OP);
   }
   else {
d240 1
a240 1
                                                  ENABLE_LOGIC_OP_MASK);
d242 1
a242 1
                                                 DISABLE_LOGIC_OP);
d246 1
a246 2
static void
i830BlendColor(struct gl_context * ctx, const GLfloat color[4])
d248 1
a248 1
   struct i830_context *i830 = i830_context(ctx);
d251 3
a253 2
   DBG("%s\n", __FUNCTION__);
   
d260 1
a260 2
   i830->state.Ctx[I830_CTXREG_BLENDCOLOR1] =
      (a << 24) | (r << 16) | (g << 8) | b;
d269 1
a269 2
static void
i830_set_blend_state(struct gl_context * ctx)
d271 1
a271 1
   struct i830_context *i830 = i830_context(ctx);
d280 2
a281 3
   funcRGB =
      SRC_BLND_FACT(intel_translate_blend_factor(ctx->Color.BlendSrcRGB))
      | DST_BLND_FACT(intel_translate_blend_factor(ctx->Color.BlendDstRGB));
d283 1
a283 1
   switch (ctx->Color.BlendEquationRGB) {
d285 1
a285 1
      eqnRGB = BLENDFUNC_ADD;
d291 1
a291 1
   case GL_MAX:
d295 2
a296 2
   case GL_FUNC_SUBTRACT:
      eqnRGB = BLENDFUNC_SUB;
d299 1
a299 1
      eqnRGB = BLENDFUNC_RVRSE_SUB;
d302 2
a303 2
      fprintf(stderr, "[%s:%u] Invalid RGB blend equation (0x%04x).\n",
              __FUNCTION__, __LINE__, ctx->Color.BlendEquationRGB);
d308 2
a309 2
   funcA = SRC_ABLEND_FACT(intel_translate_blend_factor(ctx->Color.BlendSrcA))
      | DST_ABLEND_FACT(intel_translate_blend_factor(ctx->Color.BlendDstA));
d311 1
a311 1
   switch (ctx->Color.BlendEquationA) {
d313 1
a313 1
      eqnA = BLENDFUNC_ADD;
d315 1
a315 1
   case GL_MIN:
d319 1
a319 1
   case GL_MAX:
d323 2
a324 2
   case GL_FUNC_SUBTRACT:
      eqnA = BLENDFUNC_SUB;
d327 1
a327 1
      eqnA = BLENDFUNC_RVRSE_SUB;
d330 2
a331 2
      fprintf(stderr, "[%s:%u] Invalid alpha blend equation (0x%04x).\n",
              __FUNCTION__, __LINE__, ctx->Color.BlendEquationA);
d336 3
a338 3
      | _3DSTATE_INDPT_ALPHA_BLEND_CMD
      | ENABLE_SRC_ABLEND_FACTOR | ENABLE_DST_ABLEND_FACTOR
      | ENABLE_ALPHA_BLENDFUNC;
d340 3
a342 3
      | _3DSTATE_MODES_1_CMD
      | ENABLE_SRC_BLND_FACTOR | ENABLE_DST_BLND_FACTOR
      | ENABLE_COLR_BLND_FUNC;
d344 1
a344 1
   if ((eqnA | funcA) != (eqnRGB | funcRGB))
d364 5
a368 5
      fprintf(stderr,
              "[%s:%u] STATE1: 0x%08x IALPHAB: 0x%08x blend is %sabled\n",
              __FUNCTION__, __LINE__, i830->state.Ctx[I830_CTXREG_STATE1],
              i830->state.Ctx[I830_CTXREG_IALPHAB],
              (ctx->Color.BlendEnabled) ? "en" : "dis");
d373 2
a374 2
static void
i830BlendEquationSeparate(struct gl_context * ctx, GLenum modeRGB, GLenum modeA)
d376 4
a379 3
   DBG("%s -> %s, %s\n", __FUNCTION__,
       _mesa_lookup_enum_by_nr(modeRGB),
       _mesa_lookup_enum_by_nr(modeA));
d383 1
a383 1
   i830_set_blend_state(ctx);
d387 3
a389 3
static void
i830BlendFuncSeparate(struct gl_context * ctx, GLenum sfactorRGB,
                      GLenum dfactorRGB, GLenum sfactorA, GLenum dfactorA)
d391 6
a396 5
   DBG("%s -> RGB(%s, %s) A(%s, %s)\n", __FUNCTION__,
       _mesa_lookup_enum_by_nr(sfactorRGB),
       _mesa_lookup_enum_by_nr(dfactorRGB),
       _mesa_lookup_enum_by_nr(sfactorA),
       _mesa_lookup_enum_by_nr(dfactorA));
d402 1
a402 1
   i830_set_blend_state(ctx);
d407 1
a407 2
static void
i830DepthFunc(struct gl_context * ctx, GLenum func)
d409 1
a409 1
   struct i830_context *i830 = i830_context(ctx);
d412 3
a414 2
   DBG("%s\n", __FUNCTION__);
   
d418 1
a418 1
                                           DEPTH_TEST_FUNC(test));
d421 1
a421 2
static void
i830DepthMask(struct gl_context * ctx, GLboolean flag)
d423 4
a426 1
   struct i830_context *i830 = i830_context(ctx);
a427 2
   DBG("%s flag (%d)\n", __FUNCTION__, flag);
   
a437 16
/** Called from ctx->Driver.Viewport() */
static void
i830Viewport(struct gl_context * ctx,
              GLint x, GLint y, GLsizei width, GLsizei height)
{
   intelCalcViewport(ctx);
}


/** Called from ctx->Driver.DepthRange() */
static void
i830DepthRange(struct gl_context * ctx, GLclampd nearval, GLclampd farval)
{
   intelCalcViewport(ctx);
}

d444 1
a444 2
static void
i830PolygonStipple(struct gl_context * ctx, const GLubyte * mask)
d446 1
a446 1
   struct i830_context *i830 = i830_context(ctx);
d449 1
a449 1
   int i, j, k;
d451 1
a451 1
                 i830->intel.reduced_primitive == GL_TRIANGLES);
d459 12
a470 16
   p[0] = mask[12] & 0xf;
   p[0] |= p[0] << 4;
   p[1] = mask[8] & 0xf;
   p[1] |= p[1] << 4;
   p[2] = mask[4] & 0xf;
   p[2] |= p[2] << 4;
   p[3] = mask[0] & 0xf;
   p[3] |= p[3] << 4;

   for (k = 0; k < 8; k++)
      for (j = 3; j >= 0; j--)
         for (i = 0; i < 4; i++, m++)
            if (*m != p[j]) {
               i830->intel.hw_stipple = 0;
               return;
            }
d473 3
a475 2
              ((p[1] & 0xf) << 4) |
              ((p[2] & 0xf) << 8) | ((p[3] & 0xf) << 12));
d496 2
a497 2
static void
i830Scissor(struct gl_context * ctx, GLint x, GLint y, GLsizei w, GLsizei h)
d499 2
a500 1
   struct i830_context *i830 = i830_context(ctx);
d503 1
a503 1
   if (!ctx->DrawBuffer)
d506 18
a523 18
   DBG("%s %d,%d %dx%d\n", __FUNCTION__, x, y, w, h);

   if (ctx->DrawBuffer->Name == 0) {
      x1 = x;
      y1 = ctx->DrawBuffer->Height - (y + h);
      x2 = x + w - 1;
      y2 = y1 + h - 1;
      DBG("%s %d..%d,%d..%d (inverted)\n", __FUNCTION__, x1, x2, y1, y2);
   }
   else {
      /* FBO - not inverted
       */
      x1 = x;
      y1 = y;
      x2 = x + w - 1;
      y2 = y + h - 1;
      DBG("%s %d..%d,%d..%d (not inverted)\n", __FUNCTION__, x1, x2, y1, y2);
   }
a524 6
   x1 = CLAMP(x1, 0, ctx->DrawBuffer->Width - 1);
   y1 = CLAMP(y1, 0, ctx->DrawBuffer->Height - 1);
   x2 = CLAMP(x2, 0, ctx->DrawBuffer->Width - 1);
   y2 = CLAMP(y2, 0, ctx->DrawBuffer->Height - 1);
   
   DBG("%s %d..%d,%d..%d (clamped)\n", __FUNCTION__, x1, x2, y1, y2);
d531 1
a531 2
static void
i830LogicOp(struct gl_context * ctx, GLenum opcode)
d533 5
a537 2
   struct i830_context *i830 = i830_context(ctx);
   int tmp = intel_translate_logic_op(opcode);
a538 2
   DBG("%s\n", __FUNCTION__);
   
d546 1
a546 2
static void
i830CullFaceFrontFace(struct gl_context * ctx, GLenum unused)
d548 1
a548 1
   struct i830_context *i830 = i830_context(ctx);
d551 3
a553 2
   DBG("%s\n", __FUNCTION__);
   
d561 1
a561 1
         mode ^= (CULLMODE_CW ^ CULLMODE_CCW);
d563 1
a563 1
         mode ^= (CULLMODE_CW ^ CULLMODE_CCW);
d574 1
a574 2
static void
i830LineWidth(struct gl_context * ctx, GLfloat widthf)
d576 1
a576 1
   struct i830_context *i830 = i830_context(ctx);
d580 5
a584 1
   DBG("%s\n", __FUNCTION__);
a585 3
   width = (int) (widthf * 2);
   width = CLAMP(width, 1, 15);

d595 1
a595 2
static void
i830PointSize(struct gl_context * ctx, GLfloat size)
d597 5
a601 2
   struct i830_context *i830 = i830_context(ctx);
   GLint point_size = (int) size;
d603 1
a603 3
   DBG("%s\n", __FUNCTION__);
   
   point_size = CLAMP(point_size, 1, 256);
d607 1
a607 1
                                           FIXED_POINT_WIDTH(point_size));
d615 3
a617 3
static void
i830ColorMask(struct gl_context * ctx,
              GLboolean r, GLboolean g, GLboolean b, GLboolean a)
d619 1
a619 1
   struct i830_context *i830 = i830_context(ctx);
d622 2
a623 1
   DBG("%s r(%d) g(%d) b(%d) a(%d)\n", __FUNCTION__, r, g, b, a);
d626 6
a631 5
          ENABLE_COLOR_MASK |
          ENABLE_COLOR_WRITE |
          ((!r) << WRITEMASK_RED_SHIFT) |
          ((!g) << WRITEMASK_GREEN_SHIFT) |
          ((!b) << WRITEMASK_BLUE_SHIFT) | ((!a) << WRITEMASK_ALPHA_SHIFT));
d639 1
a639 2
static void
update_specular(struct gl_context * ctx)
d641 1
a641 1
   struct i830_context *i830 = i830_context(ctx);
d652 2
a653 2
static void
i830LightModelfv(struct gl_context * ctx, GLenum pname, const GLfloat * param)
d655 3
a657 2
   DBG("%s\n", __FUNCTION__);
   
d659 1
a659 1
      update_specular(ctx);
d665 1
a665 2
static void
i830ShadeModel(struct gl_context * ctx, GLenum mode)
d667 1
a667 1
   struct i830_context *i830 = i830_context(ctx);
d676 9
a684 11
      i830->state.Ctx[I830_CTXREG_STATE3] |=
         (ALPHA_SHADE_MODE(SHADE_MODE_FLAT) | FOG_SHADE_MODE(SHADE_MODE_FLAT)
          | SPEC_SHADE_MODE(SHADE_MODE_FLAT) |
          COLOR_SHADE_MODE(SHADE_MODE_FLAT));
   }
   else {
      i830->state.Ctx[I830_CTXREG_STATE3] |=
         (ALPHA_SHADE_MODE(SHADE_MODE_LINEAR) |
          FOG_SHADE_MODE(SHADE_MODE_LINEAR) |
          SPEC_SHADE_MODE(SHADE_MODE_LINEAR) |
          COLOR_SHADE_MODE(SHADE_MODE_LINEAR));
d691 1
a691 2
static void
i830Fogfv(struct gl_context * ctx, GLenum pname, const GLfloat * param)
d693 4
a696 1
   struct i830_context *i830 = i830_context(ctx);
d698 4
a701 6
   DBG("%s\n", __FUNCTION__);
   
   if (pname == GL_FOG_COLOR) {
      GLuint color = (((GLubyte) (ctx->Fog.Color[0] * 255.0F) << 16) |
                      ((GLubyte) (ctx->Fog.Color[1] * 255.0F) << 8) |
                      ((GLubyte) (ctx->Fog.Color[2] * 255.0F) << 0));
d704 1
a704 2
      i830->state.Ctx[I830_CTXREG_FOGCOLOR] =
         (_3DSTATE_FOG_COLOR_CMD | color);
d711 1
a711 2
static void
i830Enable(struct gl_context * ctx, GLenum cap, GLboolean state)
d713 1
a713 1
   struct i830_context *i830 = i830_context(ctx);
d715 1
a715 1
   switch (cap) {
d718 1
a718 1
      update_specular(ctx);
d725 1
a725 1
         i830->state.Ctx[I830_CTXREG_ENABLES_1] |= ENABLE_ALPHA_TEST;
d727 1
a727 1
         i830->state.Ctx[I830_CTXREG_ENABLES_1] |= DISABLE_ALPHA_TEST;
d740 2
a741 2
      if (i830->intel.ctx.Visual.rgbBits == 16)
         FALLBACK(&i830->intel, I830_FALLBACK_LOGICOP, state);
d743 1
a743 1

d749 1
a749 1
         i830->state.Ctx[I830_CTXREG_ENABLES_2] |= ENABLE_DITHER;
d751 1
a751 1
         i830->state.Ctx[I830_CTXREG_ENABLES_2] |= DISABLE_DITHER;
d759 1
a759 1
         i830->state.Ctx[I830_CTXREG_ENABLES_1] |= ENABLE_DEPTH_TEST;
d761 1
a761 1
         i830->state.Ctx[I830_CTXREG_ENABLES_1] |= DISABLE_DEPTH_TEST;
d765 1
a765 1
      i830DepthMask(ctx, ctx->Depth.Mask);
d770 1
a770 1

d772 3
a774 2
         i830->state.Buffer[I830_DESTREG_SENABLE] =
            (_3DSTATE_SCISSOR_ENABLE_CMD | ENABLE_SCISSOR_RECT);
d776 3
a778 2
         i830->state.Buffer[I830_DESTREG_SENABLE] =
            (_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);
d784 1
a784 1

d787 1
a787 1
         i830->state.Ctx[I830_CTXREG_AA] |= AA_LINE_ENABLE;
d789 1
a789 1
         i830->state.Ctx[I830_CTXREG_AA] |= AA_LINE_DISABLE;
d796 1
a796 1
         i830->state.Ctx[I830_CTXREG_ENABLES_1] |= ENABLE_FOG;
d798 1
a798 1
         i830->state.Ctx[I830_CTXREG_ENABLES_1] |= DISABLE_FOG;
d809 14
a822 26
      {
         GLboolean hw_stencil = GL_FALSE;
         if (ctx->DrawBuffer) {
            struct intel_renderbuffer *irbStencil
               = intel_get_renderbuffer(ctx->DrawBuffer, BUFFER_STENCIL);
            hw_stencil = (irbStencil && irbStencil->region);
         }
         if (hw_stencil) {
            I830_STATECHANGE(i830, I830_UPLOAD_CTX);

            if (state) {
               i830->state.Ctx[I830_CTXREG_ENABLES_1] |= ENABLE_STENCIL_TEST;
               i830->state.Ctx[I830_CTXREG_ENABLES_2] |= ENABLE_STENCIL_WRITE;
            }
            else {
               i830->state.Ctx[I830_CTXREG_ENABLES_1] &= ~ENABLE_STENCIL_TEST;
               i830->state.Ctx[I830_CTXREG_ENABLES_2] &=
                  ~ENABLE_STENCIL_WRITE;
               i830->state.Ctx[I830_CTXREG_ENABLES_1] |= DISABLE_STENCIL_TEST;
               i830->state.Ctx[I830_CTXREG_ENABLES_2] |=
                  DISABLE_STENCIL_WRITE;
            }
         }
         else {
            FALLBACK(&i830->intel, I830_FALLBACK_STENCIL, state);
         }
d831 7
a837 6
      if (i830->intel.hw_stipple &&
          i830->intel.reduced_primitive == GL_TRIANGLES) {
         I830_STATECHANGE(i830, I830_UPLOAD_STIPPLE);
         i830->state.Stipple[I830_STPREG_ST1] &= ~ST1_ENABLE;
         if (state)
            i830->state.Stipple[I830_STPREG_ST1] |= ST1_ENABLE;
d847 1
a847 2
static void
i830_init_packets(struct i830_context *i830)
d849 2
d856 8
a863 7
                                 TEXPIPE_COLOR |
                                 ENABLE_TEXOUTPUT_WRT_SEL |
                                 TEXOP_OUTPUT_CURRENT |
                                 DISABLE_TEX_CNTRL_STAGE |
                                 TEXOP_SCALE_1X |
                                 TEXOP_MODIFY_PARMS |
                                 TEXOP_LAST_STAGE | TEXBLENDOP_ARG1);
d865 6
a870 5
                                 TEXPIPE_ALPHA |
                                 ENABLE_TEXOUTPUT_WRT_SEL |
                                 TEXOP_OUTPUT_CURRENT |
                                 TEXOP_SCALE_1X |
                                 TEXOP_MODIFY_PARMS | TEXBLENDOP_ARG1);
d872 4
a875 4
                                 TEXPIPE_COLOR |
                                 TEXBLEND_ARG1 |
                                 TEXBLENDARG_MODIFY_PARMS |
                                 TEXBLENDARG_DIFFUSE);
d877 4
a880 4
                                 TEXPIPE_ALPHA |
                                 TEXBLEND_ARG1 |
                                 TEXBLENDARG_MODIFY_PARMS |
                                 TEXBLENDARG_DIFFUSE);
d885 1
a885 1
   i830->state.Ctx[I830_CTXREG_VF] = 0;
d889 5
a893 5
                                      AA_LINE_ECAAR_WIDTH_ENABLE |
                                      AA_LINE_ECAAR_WIDTH_1_0 |
                                      AA_LINE_REGION_WIDTH_ENABLE |
                                      AA_LINE_REGION_WIDTH_1_0 |
                                      AA_LINE_DISABLE);
d896 8
a903 8
                                             DISABLE_LOGIC_OP |
                                             DISABLE_STENCIL_TEST |
                                             DISABLE_DEPTH_BIAS |
                                             DISABLE_SPEC_ADD |
                                             DISABLE_FOG |
                                             DISABLE_ALPHA_TEST |
                                             DISABLE_COLOR_BLEND |
                                             DISABLE_DEPTH_TEST);
a904 1
#if 000                         /* XXX all the stencil enable state is set in i830Enable(), right? */
d907 8
a914 11
                                                ENABLE_STENCIL_WRITE |
                                                ENABLE_TEX_CACHE |
                                                ENABLE_DITHER |
                                                ENABLE_COLOR_MASK |
                                                /* set no color comps disabled */
                                                ENABLE_COLOR_WRITE |
                                                ENABLE_DEPTH_WRITE);
   }
   else
#endif
   {
d916 7
a922 7
                                                DISABLE_STENCIL_WRITE |
                                                ENABLE_TEX_CACHE |
                                                ENABLE_DITHER |
                                                ENABLE_COLOR_MASK |
                                                /* set no color comps disabled */
                                                ENABLE_COLOR_WRITE |
                                                ENABLE_DEPTH_WRITE);
d926 6
a931 6
                                          ENABLE_COLR_BLND_FUNC |
                                          BLENDFUNC_ADD |
                                          ENABLE_SRC_BLND_FACTOR |
                                          SRC_BLND_FACT(BLENDFACT_ONE) |
                                          ENABLE_DST_BLND_FACTOR |
                                          DST_BLND_FACT(BLENDFACT_ZERO));
d934 5
a938 5
                                          ENABLE_GLOBAL_DEPTH_BIAS |
                                          GLOBAL_DEPTH_BIAS(0) |
                                          ENABLE_ALPHA_TEST_FUNC |
                                          ALPHA_TEST_FUNC(COMPAREFUNC_ALWAYS)
                                          | ALPHA_REF_VALUE(0));
d941 12
a952 11
                                          ENABLE_DEPTH_TEST_FUNC |
                                          DEPTH_TEST_FUNC(COMPAREFUNC_LESS) |
                                          ENABLE_ALPHA_SHADE_MODE |
                                          ALPHA_SHADE_MODE(SHADE_MODE_LINEAR)
                                          | ENABLE_FOG_SHADE_MODE |
                                          FOG_SHADE_MODE(SHADE_MODE_LINEAR) |
                                          ENABLE_SPEC_SHADE_MODE |
                                          SPEC_SHADE_MODE(SHADE_MODE_LINEAR) |
                                          ENABLE_COLOR_SHADE_MODE |
                                          COLOR_SHADE_MODE(SHADE_MODE_LINEAR)
                                          | ENABLE_CULL_MODE | CULLMODE_NONE);
d955 6
a960 6
                                          ENABLE_LOGIC_OP_FUNC |
                                          LOGIC_OP_FUNC(LOGICOP_COPY) |
                                          ENABLE_STENCIL_TEST_MASK |
                                          STENCIL_TEST_MASK(0xff) |
                                          ENABLE_STENCIL_WRITE_MASK |
                                          STENCIL_WRITE_MASK(0xff));
d963 17
a979 16
                                              ENABLE_STENCIL_PARMS |
                                              STENCIL_FAIL_OP(STENCILOP_KEEP)
                                              |
                                              STENCIL_PASS_DEPTH_FAIL_OP
                                              (STENCILOP_KEEP) |
                                              STENCIL_PASS_DEPTH_PASS_OP
                                              (STENCILOP_KEEP) |
                                              ENABLE_STENCIL_TEST_FUNC |
                                              STENCIL_TEST_FUNC
                                              (COMPAREFUNC_ALWAYS) |
                                              ENABLE_STENCIL_REF_VALUE |
                                              STENCIL_REF_VALUE(0));

   i830->state.Ctx[I830_CTXREG_STATE5] = (_3DSTATE_MODES_5_CMD | FLUSH_TEXTURE_CACHE | ENABLE_SPRITE_POINT_TEX | SPRITE_POINT_TEX_OFF | ENABLE_FIXED_LINE_WIDTH | FIXED_LINE_WIDTH(0x2) |       /* 1.0 */
                                          ENABLE_FIXED_POINT_WIDTH |
                                          FIXED_POINT_WIDTH(1));
d982 3
a984 3
                                           DISABLE_INDPT_ALPHA_BLEND |
                                           ENABLE_ALPHA_BLENDFUNC |
                                           ABLENDFUNC_ADD);
d987 3
a989 3
                                            FOG_COLOR_RED(0) |
                                            FOG_COLOR_GREEN(0) |
                                            FOG_COLOR_BLUE(0));
d996 4
a999 13
                                         TEXBIND_SET2(TEXCOORDSRC_VTXSET_2) |
                                         TEXBIND_SET1(TEXCOORDSRC_VTXSET_1) |
                                         TEXBIND_SET0(TEXCOORDSRC_VTXSET_0));

   i830->state.RasterRules[I830_RASTER_RULES] = (_3DSTATE_RASTER_RULES_CMD |
						 ENABLE_POINT_RASTER_RULE |
						 OGL_POINT_RASTER_RULE |
						 ENABLE_LINE_STRIP_PROVOKE_VRTX |
						 ENABLE_TRI_FAN_PROVOKE_VRTX |
						 ENABLE_TRI_STRIP_PROVOKE_VRTX |
						 LINE_STRIP_PROVOKE_VRTX(1) |
						 TRI_FAN_PROVOKE_VRTX(2) |
						 TRI_STRIP_PROVOKE_VRTX(2));
d1001 15
a1016 1
   i830->state.Stipple[I830_STPREG_ST0] = _3DSTATE_STIPPLE;
d1019 19
d1039 1
a1039 1
                                               DISABLE_SCISSOR_RECT);
a1044 21
void
i830_update_provoking_vertex(struct gl_context * ctx)
{
   struct i830_context *i830 = i830_context(ctx);

   I830_STATECHANGE(i830, I830_UPLOAD_RASTER_RULES);
   i830->state.RasterRules[I830_RASTER_RULES] &= ~(LINE_STRIP_PROVOKE_VRTX_MASK |
						   TRI_FAN_PROVOKE_VRTX_MASK |
						   TRI_STRIP_PROVOKE_VRTX_MASK);

   /* _NEW_LIGHT */
   if (ctx->Light.ProvokingVertex == GL_LAST_VERTEX_CONVENTION) {
      i830->state.RasterRules[I830_RASTER_RULES] |= (LINE_STRIP_PROVOKE_VRTX(1) |
						     TRI_FAN_PROVOKE_VRTX(2) |
						     TRI_STRIP_PROVOKE_VRTX(2));
   } else {
      i830->state.RasterRules[I830_RASTER_RULES] |= (LINE_STRIP_PROVOKE_VRTX(0) |
						     TRI_FAN_PROVOKE_VRTX(1) |
						     TRI_STRIP_PROVOKE_VRTX(0));
    }
}
d1046 1
a1046 2
void
i830InitStateFuncs(struct dd_function_table *functions)
a1068 2
   functions->DepthRange = i830DepthRange;
   functions->Viewport = i830Viewport;
d1071 1
a1071 2
void
i830InitState(struct i830_context *i830)
d1073 1
a1073 1
   struct gl_context *ctx = &i830->intel.ctx;
d1075 1
a1075 1
   i830_init_packets(i830);
d1077 1
a1077 1
   _mesa_init_driver_state(ctx);
d1079 3
d1083 4
a1086 5
   i830->state.active = (I830_UPLOAD_INVARIENT |
                         I830_UPLOAD_RASTER_RULES |
                         I830_UPLOAD_TEXBLEND(0) |
                         I830_UPLOAD_STIPPLE |
                         I830_UPLOAD_CTX | I830_UPLOAD_BUFFERS);
d1088 5
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@a32 1
#include "main/fbobject.h"
d34 2
a35 1
#include "main/state.h"
a40 1
#include "intel_mipmap_tree.h"
d237 1
a237 1
   if (ctx->Color.ColorLogicOpEnabled) {
d294 2
a295 2
      SRC_BLND_FACT(intel_translate_blend_factor(ctx->Color.Blend[0].SrcRGB))
      | DST_BLND_FACT(intel_translate_blend_factor(ctx->Color.Blend[0].DstRGB));
d297 1
a297 1
   switch (ctx->Color.Blend[0].EquationRGB) {
d317 1
a317 1
              __FUNCTION__, __LINE__, ctx->Color.Blend[0].EquationRGB);
d322 2
a323 2
   funcA = SRC_ABLEND_FACT(intel_translate_blend_factor(ctx->Color.Blend[0].SrcA))
      | DST_ABLEND_FACT(intel_translate_blend_factor(ctx->Color.Blend[0].DstA));
d325 1
a325 1
   switch (ctx->Color.Blend[0].EquationA) {
d345 1
a345 1
              __FUNCTION__, __LINE__, ctx->Color.Blend[0].EquationA);
d439 1
a439 4

   if (!ctx->DrawBuffer || !ctx->DrawBuffer->Visual.depthBits)
      flag = false;

d476 1
a476 1
   const GLubyte *m;
a487 6
   /* Use the already unpacked stipple data from the context rather than the
    * uninterpreted mask passed in.
    */
   mask = (const GLubyte *)ctx->PolygonStipple;
   m = mask;

d539 1
a539 1
   if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
d682 1
a682 1
   if (_mesa_need_secondary_color(ctx))
a797 3
      if (!ctx->DrawBuffer || !ctx->DrawBuffer->Visual.depthBits)
	 state = false;

d848 1
a848 1
         bool hw_stencil = false;
d852 1
a852 1
            hw_stencil = (irbStencil && irbStencil->mt);
a1090 9
/* Fallback to swrast for select and feedback.
 */
static void
i830RenderMode(struct gl_context *ctx, GLenum mode)
{
   struct intel_context *intel = intel_context(ctx);
   FALLBACK(intel, INTEL_FALLBACK_RENDERMODE, (mode != GL_RENDER));
}

a1109 1
   functions->RenderMode = i830RenderMode;
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d454 9
d465 1
a465 1
i830DepthRange(struct gl_context *ctx)
d539 1
a539 1
i830Scissor(struct gl_context * ctx)
d547 1
a547 3
   DBG("%s %d,%d %dx%d\n", __FUNCTION__,
       ctx->Scissor.ScissorArray[0].X,     ctx->Scissor.ScissorArray[0].Y,
       ctx->Scissor.ScissorArray[0].Width, ctx->Scissor.ScissorArray[0].Height);
d550 4
a553 6
      x1 = ctx->Scissor.ScissorArray[0].X;
      y1 = ctx->DrawBuffer->Height - (ctx->Scissor.ScissorArray[0].Y
                                      + ctx->Scissor.ScissorArray[0].Height);
      x2 = ctx->Scissor.ScissorArray[0].X
         + ctx->Scissor.ScissorArray[0].Width - 1;
      y2 = y1 + ctx->Scissor.ScissorArray[0].Height - 1;
d559 4
a562 6
      x1 = ctx->Scissor.ScissorArray[0].X;
      y1 = ctx->Scissor.ScissorArray[0].Y;
      x2 = ctx->Scissor.ScissorArray[0].X
         + ctx->Scissor.ScissorArray[0].Width - 1;
      y2 = ctx->Scissor.ScissorArray[0].Y
         + ctx->Scissor.ScissorArray[0].Height - 1;
d1139 1
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@d1072 2
a1076 2
   i830->state.Buffer[I830_DESTREG_SENABLE] = (_3DSTATE_SCISSOR_ENABLE_CMD |
                                               DISABLE_SCISSOR_RECT);
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@a1071 2
   i830->state.Buffer[I830_DESTREG_SENABLE] = (_3DSTATE_SCISSOR_ENABLE_CMD |
                                               DISABLE_SCISSOR_RECT);
d1075 2
@


