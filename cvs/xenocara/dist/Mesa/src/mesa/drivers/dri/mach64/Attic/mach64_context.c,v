head	1.7;
access;
symbols
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.09.05.14.04.37;	author jsg;	state dead;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.16;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.54;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.54;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.19;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.28.45;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.38;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@/* -*- mode: c; c-basic-offset: 3 -*- */
/*
 * Copyright 2000 Gareth Hughes
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * GARETH HUGHES BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * Authors:
 *	Gareth Hughes <gareth@@valinux.com>
 *	Leif Delgass <ldelgass@@retinalburn.net>
 *	Josï¿½Fonseca <j_r_fonseca@@yahoo.co.uk>
 */

#include "main/glheader.h"
#include "main/context.h"
#include "main/simple_list.h"
#include "main/imports.h"

#include "swrast/swrast.h"
#include "swrast_setup/swrast_setup.h"
#include "vbo/vbo.h"

#include "tnl/tnl.h"
#include "tnl/t_pipeline.h"

#include "drivers/common/driverfuncs.h"

#include "mach64_context.h"
#include "mach64_ioctl.h"
#include "mach64_dd.h"
#include "mach64_span.h"
#include "mach64_state.h"
#include "mach64_tex.h"
#include "mach64_tris.h"
#include "mach64_vb.h"

#include "utils.h"
#include "vblank.h"

#ifndef MACH64_DEBUG
int MACH64_DEBUG = (0);
#endif

static const struct dri_debug_control debug_control[] =
{
    { "sync",   DEBUG_ALWAYS_SYNC },
    { "api",    DEBUG_VERBOSE_API },
    { "msg",    DEBUG_VERBOSE_MSG },
    { "lru",    DEBUG_VERBOSE_LRU },
    { "dri",    DEBUG_VERBOSE_DRI },
    { "ioctl",  DEBUG_VERBOSE_IOCTL },
    { "prims",  DEBUG_VERBOSE_PRIMS },
    { "count",  DEBUG_VERBOSE_COUNT },
    { "nowait", DEBUG_NOWAIT },
    { "fall",   DEBUG_VERBOSE_FALLBACK },
    { NULL,    0 }
};

static const struct dri_extension card_extensions[] =
{
    { "GL_ARB_multitexture",               NULL },
    { "GL_EXT_texture_edge_clamp",         NULL },
    { "GL_MESA_ycbcr_texture",             NULL },
    { NULL,                                NULL }
};


/* Create the device specific context.
  */
GLboolean mach64CreateContext( gl_api api,
			       const struct gl_config *glVisual,
			       __DRIcontext *driContextPriv,
                               void *sharedContextPrivate )
{
   struct gl_context *ctx, *shareCtx;
   __DRIscreen *driScreen = driContextPriv->driScreenPriv;
   struct dd_function_table functions;
   mach64ContextPtr mmesa;
   mach64ScreenPtr mach64Screen;
   int i, heap;
   GLuint *c_textureSwapsPtr = NULL;

#if DO_DEBUG
   MACH64_DEBUG = driParseDebugString(getenv("MACH64_DEBUG"), debug_control);
#endif

   /* Allocate the mach64 context */
   mmesa = (mach64ContextPtr) CALLOC( sizeof(*mmesa) );
   if ( !mmesa ) 
      return GL_FALSE;

   /* Init default driver functions then plug in our Mach64-specific functions
    * (the texture functions are especially important)
    */
   _mesa_init_driver_functions( &functions );
   mach64InitDriverFuncs( &functions );
   mach64InitIoctlFuncs( &functions );
   mach64InitTextureFuncs( &functions );

   /* Allocate the Mesa context */
   if (sharedContextPrivate)
      shareCtx = ((mach64ContextPtr) sharedContextPrivate)->glCtx;
   else 
      shareCtx = NULL;
   mmesa->glCtx = _mesa_create_context(API_OPENGL, glVisual, shareCtx, 
					&functions, (void *)mmesa);
   if (!mmesa->glCtx) {
      FREE(mmesa);
      return GL_FALSE;
   }
   driContextPriv->driverPrivate = mmesa;
   ctx = mmesa->glCtx;

   mmesa->driContext = driContextPriv;
   mmesa->driScreen = driScreen;
   mmesa->driDrawable = NULL;
   mmesa->hHWContext = driContextPriv->hHWContext;
   mmesa->driHwLock = &driScreen->pSAREA->lock;
   mmesa->driFd = driScreen->fd;

   mach64Screen = mmesa->mach64Screen = (mach64ScreenPtr)driScreen->private;

   /* Parse configuration files */
   driParseConfigFiles (&mmesa->optionCache, &mach64Screen->optionCache,
                        mach64Screen->driScreen->myNum, "mach64");

   mmesa->sarea = (drm_mach64_sarea_t *)((char *)driScreen->pSAREA +
				    sizeof(drm_sarea_t));

   mmesa->CurrentTexObj[0] = NULL;
   mmesa->CurrentTexObj[1] = NULL;

   (void) memset( mmesa->texture_heaps, 0, sizeof( mmesa->texture_heaps ) );
   make_empty_list( &mmesa->swapped );

   mmesa->firstTexHeap = mach64Screen->firstTexHeap;
   mmesa->lastTexHeap = mach64Screen->firstTexHeap + mach64Screen->numTexHeaps;

   for ( i = mmesa->firstTexHeap ; i < mmesa->lastTexHeap ; i++ ) {
      mmesa->texture_heaps[i] = driCreateTextureHeap( i, mmesa,
	    mach64Screen->texSize[i],
	    6, /* align to 64-byte boundary, use 12 for page-size boundary */
	    MACH64_NR_TEX_REGIONS,
	    (drmTextureRegionPtr)mmesa->sarea->tex_list[i],
	    &mmesa->sarea->tex_age[i],
	    &mmesa->swapped,
	    sizeof( mach64TexObj ),
	    (destroy_texture_object_t *) mach64DestroyTexObj );

#if ENABLE_PERF_BOXES
      c_textureSwapsPtr = & mmesa->c_textureSwaps;
#endif
      driSetTextureSwapCounterLocation( mmesa->texture_heaps[i],
					c_textureSwapsPtr );
   }

   mmesa->RenderIndex = -1;		/* Impossible value */
   mmesa->vert_buf = NULL;
   mmesa->num_verts = 0;
   mmesa->new_state = MACH64_NEW_ALL;
   mmesa->dirty = MACH64_UPLOAD_ALL;

   /* Set the maximum texture size small enough that we can
    * guarentee that both texture units can bind a maximal texture
    * and have them both in memory (on-card or AGP) at once.
    * Test for 2 textures * bytes/texel * size * size.  There's no
    * need to account for mipmaps since we only upload one level.
    */

   ctx->Const.MaxTextureUnits = 2;
   ctx->Const.MaxTextureImageUnits = 2;
   ctx->Const.MaxTextureCoordUnits = 2;
   ctx->Const.MaxDrawBuffers = 1;

   heap = mach64Screen->IsPCI ? MACH64_CARD_HEAP : MACH64_AGP_HEAP;

   driCalculateMaxTextureLevels( & mmesa->texture_heaps[heap],
				 1,
				 & ctx->Const,
				 mach64Screen->cpp,
				 10, /* max 2D texture size is 1024x1024 */
				 0,  /* 3D textures unsupported. */
				 0,  /* cube textures unsupported. */
				 0,  /* texture rectangles unsupported. */
				 1,  /* mipmapping unsupported. */
				 GL_TRUE, /* need to have both textures in
					     either local or AGP memory */
				 0 );

#if ENABLE_PERF_BOXES
   mmesa->boxes = ( getenv( "LIBGL_PERFORMANCE_BOXES" ) != NULL );
#endif

   /* Allocate the vertex buffer
    */
   mmesa->vert_buf = _mesa_align_malloc(MACH64_BUFFER_SIZE, 32);
   if ( !mmesa->vert_buf )
      return GL_FALSE;
   mmesa->vert_used = 0;
   mmesa->vert_total = MACH64_BUFFER_SIZE;
   
   /* Initialize the software rasterizer and helper modules.
    */
   _swrast_CreateContext( ctx );
   _vbo_CreateContext( ctx );
   _tnl_CreateContext( ctx );
   _swsetup_CreateContext( ctx );

   /* Install the customized pipeline:
    */
/*     _tnl_destroy_pipeline( ctx ); */
/*     _tnl_install_pipeline( ctx, mach64_pipeline ); */

   /* Configure swrast and T&L to match hardware characteristics:
    */
   _swrast_allow_pixel_fog( ctx, GL_FALSE );
   _swrast_allow_vertex_fog( ctx, GL_TRUE );
   _tnl_allow_pixel_fog( ctx, GL_FALSE );
   _tnl_allow_vertex_fog( ctx, GL_TRUE );

   driInitExtensions( ctx, card_extensions, GL_TRUE );

   mach64InitVB( ctx );
   mach64InitTriFuncs( ctx );
   mach64DDInitStateFuncs( ctx );
   mach64DDInitSpanFuncs( ctx );
   mach64DDInitState( mmesa );

   mmesa->do_irqs = (mmesa->mach64Screen->irq && !getenv("MACH64_NO_IRQS"));

   driContextPriv->driverPrivate = (void *)mmesa;

   if (driQueryOptionb(&mmesa->optionCache, "no_rast")) {
      fprintf(stderr, "disabling 3D acceleration\n");
      FALLBACK(mmesa, MACH64_FALLBACK_DISABLE, 1);
   }

   return GL_TRUE;
}

/* Destroy the device specific context.
 */
void mach64DestroyContext( __DRIcontext *driContextPriv  )
{
   mach64ContextPtr mmesa = (mach64ContextPtr) driContextPriv->driverPrivate;

   assert(mmesa);  /* should never be null */
   if ( mmesa ) {
      GLboolean   release_texture_heaps;

      release_texture_heaps = (mmesa->glCtx->Shared->RefCount == 1);

      _swsetup_DestroyContext( mmesa->glCtx );
      _tnl_DestroyContext( mmesa->glCtx );
      _vbo_DestroyContext( mmesa->glCtx );
      _swrast_DestroyContext( mmesa->glCtx );

      if (release_texture_heaps) {
         /* This share group is about to go away, free our private
          * texture object data.
          */
         int i;

         for ( i = mmesa->firstTexHeap ; i < mmesa->lastTexHeap ; i++ ) {
	    driDestroyTextureHeap( mmesa->texture_heaps[i] );
	    mmesa->texture_heaps[i] = NULL;
         }

	 assert( is_empty_list( & mmesa->swapped ) );
      }

      mach64FreeVB( mmesa->glCtx );

      /* Free the vertex buffer */
      if ( mmesa->vert_buf )
	 _mesa_align_free( mmesa->vert_buf );
      
      /* free the Mesa context */
      mmesa->glCtx->DriverCtx = NULL;
      _mesa_destroy_context(mmesa->glCtx);

      FREE( mmesa );
   }
}

/* Force the context `c' to be the current context and associate with it
 * buffer `b'.
 */
GLboolean
mach64MakeCurrent( __DRIcontext *driContextPriv,
                 __DRIdrawable *driDrawPriv,
                 __DRIdrawable *driReadPriv )
{
   if ( driContextPriv ) {
      GET_CURRENT_CONTEXT(ctx);
      mach64ContextPtr oldMach64Ctx = ctx ? MACH64_CONTEXT(ctx) : NULL;
      mach64ContextPtr newMach64Ctx = (mach64ContextPtr) driContextPriv->driverPrivate;

      if ( newMach64Ctx != oldMach64Ctx ) {
	 newMach64Ctx->new_state |= MACH64_NEW_CONTEXT;
	 newMach64Ctx->dirty = MACH64_UPLOAD_ALL;
      }

      
      if ( newMach64Ctx->driDrawable != driDrawPriv ) {
	 if (driDrawPriv->swap_interval == (unsigned)-1) {
	    driDrawPriv->vblFlags = (newMach64Ctx->do_irqs)
	       ? driGetDefaultVBlankFlags(&newMach64Ctx->optionCache)
	       : VBLANK_FLAG_NO_IRQ;

	    driDrawableInitVBlank( driDrawPriv );
	 }

	 newMach64Ctx->driDrawable = driDrawPriv;
	 mach64CalcViewport( newMach64Ctx->glCtx );
      }

      _mesa_make_current( newMach64Ctx->glCtx,
                          (struct gl_framebuffer *) driDrawPriv->driverPrivate,
                          (struct gl_framebuffer *) driReadPriv->driverPrivate );


      newMach64Ctx->new_state |=  MACH64_NEW_CLIP;
   } else {
      _mesa_make_current( NULL, NULL, NULL );
   }

   return GL_TRUE;
}


/* Force the context `c' to be unbound from its buffer.
 */
GLboolean
mach64UnbindContext( __DRIcontext *driContextPriv )
{
   return GL_TRUE;
}
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.5
log
@Merge Mesa 7.10.3
@
text
@d123 1
a123 1
   mmesa->glCtx = _mesa_create_context(glVisual, shareCtx, 
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a81 1
    { "GL_SGIS_generate_mipmap",           NULL },
d88 2
a89 1
GLboolean mach64CreateContext( const __GLcontextModes *glVisual,
d93 1
a93 1
   GLcontext *ctx, *shareCtx;
d337 2
a338 2
                          (GLframebuffer *) driDrawPriv->driverPrivate,
                          (GLframebuffer *) driReadPriv->driverPrivate );
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a35 2
#include "main/matrix.h"
#include "main/extensions.h"
a57 4
#define need_GL_ARB_multisample
#define need_GL_ARB_vertex_buffer_object
#include "extension_helper.h"

d77 1
a77 1
const struct dri_extension card_extensions[] =
a78 1
    { "GL_ARB_multisample",                GL_ARB_multisample_functions },
a79 1
    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
d90 1
a90 1
			       __DRIcontextPrivate *driContextPriv,
d94 1
a94 1
   __DRIscreenPrivate *driScreen = driContextPriv->driScreenPriv;
d191 1
d214 1
a214 1
   mmesa->vert_buf = ALIGN_MALLOC(MACH64_BUFFER_SIZE, 32);
d261 1
a261 1
void mach64DestroyContext( __DRIcontextPrivate *driContextPriv  )
d294 1
a294 1
	 ALIGN_FREE( mmesa->vert_buf );
d308 3
a310 3
mach64MakeCurrent( __DRIcontextPrivate *driContextPriv,
                 __DRIdrawablePrivate *driDrawPriv,
                 __DRIdrawablePrivate *driReadPriv )
d353 1
a353 1
mach64UnbindContext( __DRIcontextPrivate *driContextPriv )
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d1 1
a1 1
/* $XFree86$ */ /* -*- mode: c; c-basic-offset: 3 -*- */
d32 6
a37 6
#include "glheader.h"
#include "context.h"
#include "simple_list.h"
#include "imports.h"
#include "matrix.h"
#include "extensions.h"
@


1.1
log
@Initial revision
@
text
@d41 1
a41 1
#include "array_cache/acache.h"
d61 1
d87 1
d107 1
d159 2
a160 1
   make_empty_list( &mmesa->SwappedOut );
d166 15
a180 3
      make_empty_list( &mmesa->TexObjList[i] );
      mmesa->texHeap[i] = mmInit( 0, mach64Screen->texSize[i] );
      mmesa->lastTexAge[i] = -1;
d195 5
d202 12
a213 9
   if ( mach64Screen->texSize[heap] >= 2 * mach64Screen->cpp * 1024*1024 ) {
      ctx->Const.MaxTextureLevels = 11; /* 1024x1024 */
   } else if ( mach64Screen->texSize[heap] >= 2 * mach64Screen->cpp * 512*512 ) {
      ctx->Const.MaxTextureLevels = 10; /* 512x512 */
   } else {
      ctx->Const.MaxTextureLevels = 9;  /* 256x256 */
   }

   ctx->Const.MaxTextureUnits = 2;
d230 1
a230 1
   _ac_CreateContext( ctx );
a255 3
   mmesa->vblank_flags = (mmesa->do_irqs)
      ? driGetDefaultVBlankFlags(&mmesa->optionCache) : VBLANK_FLAG_NO_IRQ;

d274 10
a283 1
      if (mmesa->glCtx->Shared->RefCount == 1) {
a286 1
         mach64TexObjPtr t, next_t;
d290 2
a291 5
            foreach_s ( t, next_t, &mmesa->TexObjList[i] ) {
               mach64DestroyTexObj( mmesa, t );
            }
            mmDestroy( mmesa->texHeap[i] );
            mmesa->texHeap[i] = NULL;
d294 1
a294 3
         foreach_s ( t, next_t, &mmesa->SwappedOut ) {
            mach64DestroyTexObj( mmesa, t );
         }
a296 5
      _swsetup_DestroyContext( mmesa->glCtx );
      _tnl_DestroyContext( mmesa->glCtx );
      _ac_DestroyContext( mmesa->glCtx );
      _swrast_DestroyContext( mmesa->glCtx );

d330 8
a337 1
      driDrawableInitVBlank( driDrawPriv, newMach64Ctx->vblank_flags );
a338 1
      if ( newMach64Ctx->driDrawable != driDrawPriv ) {
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d311 1
a311 2
      driDrawableInitVBlank( driDrawPriv, newMach64Ctx->vblank_flags,
			     &newMach64Ctx->vbl_seq );
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d41 1
a41 1
#include "vbo/vbo.h"
a60 1
#define need_GL_ARB_vertex_buffer_object
a85 1
    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
a104 1
   GLuint *c_textureSwapsPtr = NULL;
d156 1
a156 2
   (void) memset( mmesa->texture_heaps, 0, sizeof( mmesa->texture_heaps ) );
   make_empty_list( &mmesa->swapped );
d162 3
a164 15
      mmesa->texture_heaps[i] = driCreateTextureHeap( i, mmesa,
	    mach64Screen->texSize[i],
	    6, /* align to 64-byte boundary, use 12 for page-size boundary */
	    MACH64_NR_TEX_REGIONS,
	    (drmTextureRegionPtr)mmesa->sarea->tex_list[i],
	    &mmesa->sarea->tex_age[i],
	    &mmesa->swapped,
	    sizeof( mach64TexObj ),
	    (destroy_texture_object_t *) mach64DestroyTexObj );

#if ENABLE_PERF_BOXES
      c_textureSwapsPtr = & mmesa->c_textureSwaps;
#endif
      driSetTextureSwapCounterLocation( mmesa->texture_heaps[i],
					c_textureSwapsPtr );
d179 9
a189 17
   ctx->Const.MaxTextureImageUnits = 2;
   ctx->Const.MaxTextureCoordUnits = 2;

   heap = mach64Screen->IsPCI ? MACH64_CARD_HEAP : MACH64_AGP_HEAP;

   driCalculateMaxTextureLevels( & mmesa->texture_heaps[heap],
				 1,
				 & ctx->Const,
				 mach64Screen->cpp,
				 10, /* max 2D texture size is 1024x1024 */
				 0,  /* 3D textures unsupported. */
				 0,  /* cube textures unsupported. */
				 0,  /* texture rectangles unsupported. */
				 1,  /* mipmapping unsupported. */
				 GL_TRUE, /* need to have both textures in
					     either local or AGP memory */
				 0 );
d206 1
a206 1
   _vbo_CreateContext( ctx );
d253 1
a253 10
      GLboolean   release_texture_heaps;

      release_texture_heaps = (mmesa->glCtx->Shared->RefCount == 1);

      _swsetup_DestroyContext( mmesa->glCtx );
      _tnl_DestroyContext( mmesa->glCtx );
      _vbo_DestroyContext( mmesa->glCtx );
      _swrast_DestroyContext( mmesa->glCtx );

      if (release_texture_heaps) {
d257 1
d261 5
a265 2
	    driDestroyTextureHeap( mmesa->texture_heaps[i] );
	    mmesa->texture_heaps[i] = NULL;
d268 3
a270 1
	 assert( is_empty_list( & mmesa->swapped ) );
d272 5
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d1 1
a1 1
/* -*- mode: c; c-basic-offset: 3 -*- */
d32 6
a37 4
#include "main/glheader.h"
#include "main/context.h"
#include "main/simple_list.h"
#include "main/imports.h"
d60 4
d83 1
a83 1
static const struct dri_extension card_extensions[] =
d85 1
d87 1
d90 1
d97 2
a98 3
GLboolean mach64CreateContext( gl_api api,
			       const struct gl_config *glVisual,
			       __DRIcontext *driContextPriv,
d101 2
a102 2
   struct gl_context *ctx, *shareCtx;
   __DRIscreen *driScreen = driContextPriv->driScreenPriv;
a198 1
   ctx->Const.MaxDrawBuffers = 1;
d221 1
a221 1
   mmesa->vert_buf = _mesa_align_malloc(MACH64_BUFFER_SIZE, 32);
d256 3
d271 1
a271 1
void mach64DestroyContext( __DRIcontext *driContextPriv  )
d304 1
a304 1
	 _mesa_align_free( mmesa->vert_buf );
d318 3
a320 3
mach64MakeCurrent( __DRIcontext *driContextPriv,
                 __DRIdrawable *driDrawPriv,
                 __DRIdrawable *driReadPriv )
d333 3
a336 8
	 if (driDrawPriv->swap_interval == (unsigned)-1) {
	    driDrawPriv->vblFlags = (newMach64Ctx->do_irqs)
	       ? driGetDefaultVBlankFlags(&newMach64Ctx->optionCache)
	       : VBLANK_FLAG_NO_IRQ;

	    driDrawableInitVBlank( driDrawPriv );
	 }

d342 2
a343 2
                          (struct gl_framebuffer *) driDrawPriv->driverPrivate,
                          (struct gl_framebuffer *) driReadPriv->driverPrivate );
d358 1
a358 1
mach64UnbindContext( __DRIcontext *driContextPriv )
@


