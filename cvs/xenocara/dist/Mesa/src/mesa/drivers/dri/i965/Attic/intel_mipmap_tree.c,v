head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.09.07.15.20.07;	author jsg;	state Exp;
branches;
next	1.5;
commitid	7kimTMT4YlQauAIU;

1.5
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.04.27;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.15;	author matthieu;	state dead;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.51;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.51;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.48;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.53;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2014.09.07.15.06.25;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	dm8VnQHhowGHmemJ;

1.1.1.5
date	2015.01.25.14.11.56;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.49.02;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2006 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include <GL/gl.h>
#include <GL/internal/dri_interface.h>

#include "intel_batchbuffer.h"
#include "intel_chipset.h"
#include "intel_mipmap_tree.h"
#include "intel_resolve_map.h"
#include "intel_tex.h"
#include "intel_blit.h"
#include "intel_fbo.h"

#include "brw_blorp.h"
#include "brw_context.h"

#include "main/enums.h"
#include "main/fbobject.h"
#include "main/formats.h"
#include "main/glformats.h"
#include "main/texcompress_etc.h"
#include "main/teximage.h"
#include "main/streaming-load-memcpy.h"

#define FILE_DEBUG_FLAG DEBUG_MIPTREE

/**
 * Determine which MSAA layout should be used by the MSAA surface being
 * created, based on the chip generation and the surface type.
 */
static enum intel_msaa_layout
compute_msaa_layout(struct brw_context *brw, mesa_format format, GLenum target)
{
   /* Prior to Gen7, all MSAA surfaces used IMS layout. */
   if (brw->gen < 7)
      return INTEL_MSAA_LAYOUT_IMS;

   /* In Gen7, IMS layout is only used for depth and stencil buffers. */
   switch (_mesa_get_format_base_format(format)) {
   case GL_DEPTH_COMPONENT:
   case GL_STENCIL_INDEX:
   case GL_DEPTH_STENCIL:
      return INTEL_MSAA_LAYOUT_IMS;
   default:
      /* From the Ivy Bridge PRM, Vol4 Part1 p77 ("MCS Enable"):
       *
       *   This field must be set to 0 for all SINT MSRTs when all RT channels
       *   are not written
       *
       * In practice this means that we have to disable MCS for all signed
       * integer MSAA buffers.  The alternative, to disable MCS only when one
       * of the render target channels is disabled, is impractical because it
       * would require converting between CMS and UMS MSAA layouts on the fly,
       * which is expensive.
       */
      if (brw->gen == 7 && _mesa_get_format_datatype(format) == GL_INT) {
         return INTEL_MSAA_LAYOUT_UMS;
      } else {
         return INTEL_MSAA_LAYOUT_CMS;
      }
   }
}


/**
 * For single-sampled render targets ("non-MSRT"), the MCS buffer is a
 * scaled-down bitfield representation of the color buffer which is capable of
 * recording when blocks of the color buffer are equal to the clear value.
 * This function returns the block size that will be used by the MCS buffer
 * corresponding to a certain color miptree.
 *
 * From the Ivy Bridge PRM, Vol2 Part1 11.7 "MCS Buffer for Render Target(s)",
 * beneath the "Fast Color Clear" bullet (p327):
 *
 *     The following table describes the RT alignment
 *
 *                       Pixels  Lines
 *         TiledY RT CL
 *             bpp
 *              32          8      4
 *              64          4      4
 *             128          2      4
 *         TiledX RT CL
 *             bpp
 *              32         16      2
 *              64          8      2
 *             128          4      2
 *
 * This alignment has the following uses:
 *
 * - For figuring out the size of the MCS buffer.  Each 4k tile in the MCS
 *   buffer contains 128 blocks horizontally and 256 blocks vertically.
 *
 * - For figuring out alignment restrictions for a fast clear operation.  Fast
 *   clear operations must always clear aligned multiples of 16 blocks
 *   horizontally and 32 blocks vertically.
 *
 * - For scaling down the coordinates sent through the render pipeline during
 *   a fast clear.  X coordinates must be scaled down by 8 times the block
 *   width, and Y coordinates by 16 times the block height.
 *
 * - For scaling down the coordinates sent through the render pipeline during
 *   a "Render Target Resolve" operation.  X coordinates must be scaled down
 *   by half the block width, and Y coordinates by half the block height.
 */
void
intel_get_non_msrt_mcs_alignment(struct brw_context *brw,
                                 struct intel_mipmap_tree *mt,
                                 unsigned *width_px, unsigned *height)
{
   switch (mt->tiling) {
   default:
      assert(!"Non-MSRT MCS requires X or Y tiling");
      /* In release builds, fall through */
   case I915_TILING_Y:
      *width_px = 32 / mt->cpp;
      *height = 4;
      break;
   case I915_TILING_X:
      *width_px = 64 / mt->cpp;
      *height = 2;
   }
}


/**
 * For a single-sampled render target ("non-MSRT"), determine if an MCS buffer
 * can be used.
 *
 * From the Ivy Bridge PRM, Vol2 Part1 11.7 "MCS Buffer for Render Target(s)",
 * beneath the "Fast Color Clear" bullet (p326):
 *
 *     - Support is limited to tiled render targets.
 *     - Support is for non-mip-mapped and non-array surface types only.
 *
 * And then later, on p327:
 *
 *     - MCS buffer for non-MSRT is supported only for RT formats 32bpp,
 *       64bpp, and 128bpp.
 */
bool
intel_is_non_msrt_mcs_buffer_supported(struct brw_context *brw,
                                       struct intel_mipmap_tree *mt)
{
   /* MCS support does not exist prior to Gen7 */
   if (brw->gen < 7 || brw->gen >= 8)
      return false;

   /* MCS is only supported for color buffers */
   switch (_mesa_get_format_base_format(mt->format)) {
   case GL_DEPTH_COMPONENT:
   case GL_DEPTH_STENCIL:
   case GL_STENCIL_INDEX:
      return false;
   }

   if (mt->tiling != I915_TILING_X &&
       mt->tiling != I915_TILING_Y)
      return false;
   if (mt->cpp != 4 && mt->cpp != 8 && mt->cpp != 16)
      return false;
   if (mt->first_level != 0 || mt->last_level != 0)
      return false;
   if (mt->physical_depth0 != 1)
      return false;

   /* There's no point in using an MCS buffer if the surface isn't in a
    * renderable format.
    */
   if (!brw->format_supported_as_render_target[mt->format])
      return false;

   return true;
}


/**
 * Determine depth format corresponding to a depth+stencil format,
 * for separate stencil.
 */
mesa_format
intel_depth_format_for_depthstencil_format(mesa_format format) {
   switch (format) {
   case MESA_FORMAT_Z24_UNORM_S8_UINT:
      return MESA_FORMAT_Z24_UNORM_X8_UINT;
   case MESA_FORMAT_Z32_FLOAT_S8X24_UINT:
      return MESA_FORMAT_Z_FLOAT32;
   default:
      return format;
   }
}


/**
 * @@param for_bo Indicates that the caller is
 *        intel_miptree_create_for_bo(). If true, then do not create
 *        \c stencil_mt.
 */
struct intel_mipmap_tree *
intel_miptree_create_layout(struct brw_context *brw,
                            GLenum target,
                            mesa_format format,
                            GLuint first_level,
                            GLuint last_level,
                            GLuint width0,
                            GLuint height0,
                            GLuint depth0,
                            bool for_bo,
                            GLuint num_samples)
{
   struct intel_mipmap_tree *mt = calloc(sizeof(*mt), 1);
   if (!mt)
      return NULL;

   DBG("%s target %s format %s level %d..%d slices %d <-- %p\n", __FUNCTION__,
       _mesa_lookup_enum_by_nr(target),
       _mesa_get_format_name(format),
       first_level, last_level, depth0, mt);

   if (target == GL_TEXTURE_1D_ARRAY) {
      /* For a 1D Array texture the OpenGL API will treat the height0
       * parameter as the number of array slices. For Intel hardware, we treat
       * the 1D array as a 2D Array with a height of 1.
       *
       * So, when we first come through this path to create a 1D Array
       * texture, height0 stores the number of slices, and depth0 is 1. In
       * this case, we want to swap height0 and depth0.
       *
       * Since some miptrees will be created based on the base miptree, we may
       * come through this path and see height0 as 1 and depth0 being the
       * number of slices. In this case we don't need to do the swap.
       */
      assert(height0 == 1 || depth0 == 1);
      if (height0 > 1) {
         depth0 = height0;
         height0 = 1;
      }
   }

   mt->target = target;
   mt->format = format;
   mt->first_level = first_level;
   mt->last_level = last_level;
   mt->logical_width0 = width0;
   mt->logical_height0 = height0;
   mt->logical_depth0 = depth0;
   mt->fast_clear_state = INTEL_FAST_CLEAR_STATE_NO_MCS;

   /* The cpp is bytes per (1, blockheight)-sized block for compressed
    * textures.  This is why you'll see divides by blockheight all over
    */
   unsigned bw, bh;
   _mesa_get_format_block_size(format, &bw, &bh);
   assert(_mesa_get_format_bytes(mt->format) % bw == 0);
   mt->cpp = _mesa_get_format_bytes(mt->format) / bw;

   mt->num_samples = num_samples;
   mt->compressed = _mesa_is_format_compressed(format);
   mt->msaa_layout = INTEL_MSAA_LAYOUT_NONE;
   mt->refcount = 1;

   if (num_samples > 1) {
      /* Adjust width/height/depth for MSAA */
      mt->msaa_layout = compute_msaa_layout(brw, format, mt->target);
      if (mt->msaa_layout == INTEL_MSAA_LAYOUT_IMS) {
         /* In the Sandy Bridge PRM, volume 4, part 1, page 31, it says:
          *
          *     "Any of the other messages (sample*, LOD, load4) used with a
          *      (4x) multisampled surface will in-effect sample a surface with
          *      double the height and width as that indicated in the surface
          *      state. Each pixel position on the original-sized surface is
          *      replaced with a 2x2 of samples with the following arrangement:
          *
          *         sample 0 sample 2
          *         sample 1 sample 3"
          *
          * Thus, when sampling from a multisampled texture, it behaves as
          * though the layout in memory for (x,y,sample) is:
          *
          *      (0,0,0) (0,0,2)   (1,0,0) (1,0,2)
          *      (0,0,1) (0,0,3)   (1,0,1) (1,0,3)
          *
          *      (0,1,0) (0,1,2)   (1,1,0) (1,1,2)
          *      (0,1,1) (0,1,3)   (1,1,1) (1,1,3)
          *
          * However, the actual layout of multisampled data in memory is:
          *
          *      (0,0,0) (1,0,0)   (0,0,1) (1,0,1)
          *      (0,1,0) (1,1,0)   (0,1,1) (1,1,1)
          *
          *      (0,0,2) (1,0,2)   (0,0,3) (1,0,3)
          *      (0,1,2) (1,1,2)   (0,1,3) (1,1,3)
          *
          * This pattern repeats for each 2x2 pixel block.
          *
          * As a result, when calculating the size of our 4-sample buffer for
          * an odd width or height, we have to align before scaling up because
          * sample 3 is in that bottom right 2x2 block.
          */
         switch (num_samples) {
         case 2:
            assert(brw->gen >= 8);
            width0 = ALIGN(width0, 2) * 2;
            height0 = ALIGN(height0, 2);
            break;
         case 4:
            width0 = ALIGN(width0, 2) * 2;
            height0 = ALIGN(height0, 2) * 2;
            break;
         case 8:
            width0 = ALIGN(width0, 2) * 4;
            height0 = ALIGN(height0, 2) * 2;
            break;
         default:
            /* num_samples should already have been quantized to 0, 1, 2, 4, or
             * 8.
             */
            assert(false);
         }
      } else {
         /* Non-interleaved */
         depth0 *= num_samples;
      }
   }

   /* array_spacing_lod0 is only used for non-IMS MSAA surfaces.  TODO: can we
    * use it elsewhere?
    */
   switch (mt->msaa_layout) {
   case INTEL_MSAA_LAYOUT_NONE:
   case INTEL_MSAA_LAYOUT_IMS:
      mt->array_spacing_lod0 = false;
      break;
   case INTEL_MSAA_LAYOUT_UMS:
   case INTEL_MSAA_LAYOUT_CMS:
      mt->array_spacing_lod0 = true;
      break;
   }

   if (target == GL_TEXTURE_CUBE_MAP) {
      assert(depth0 == 1);
      depth0 = 6;
   }

   mt->physical_width0 = width0;
   mt->physical_height0 = height0;
   mt->physical_depth0 = depth0;

   if (!for_bo &&
       _mesa_get_format_base_format(format) == GL_DEPTH_STENCIL &&
       (brw->must_use_separate_stencil ||
	(brw->has_separate_stencil && brw_is_hiz_depth_format(brw, format)))) {
      mt->stencil_mt = intel_miptree_create(brw,
                                            mt->target,
                                            MESA_FORMAT_S_UINT8,
                                            mt->first_level,
                                            mt->last_level,
                                            mt->logical_width0,
                                            mt->logical_height0,
                                            mt->logical_depth0,
                                            true,
                                            num_samples,
                                            INTEL_MIPTREE_TILING_ANY);
      if (!mt->stencil_mt) {
	 intel_miptree_release(&mt);
	 return NULL;
      }

      /* Fix up the Z miptree format for how we're splitting out separate
       * stencil.  Gen7 expects there to be no stencil bits in its depth buffer.
       */
      mt->format = intel_depth_format_for_depthstencil_format(mt->format);
      mt->cpp = 4;

      if (format == mt->format) {
         _mesa_problem(NULL, "Unknown format %s in separate stencil mt\n",
                       _mesa_get_format_name(mt->format));
      }
   }

   brw_miptree_layout(brw, mt);

   return mt;
}

/**
 * \brief Helper function for intel_miptree_create().
 */
static uint32_t
intel_miptree_choose_tiling(struct brw_context *brw,
                            mesa_format format,
                            uint32_t width0,
                            uint32_t num_samples,
                            enum intel_miptree_tiling_mode requested,
                            struct intel_mipmap_tree *mt)
{
   if (format == MESA_FORMAT_S_UINT8) {
      /* The stencil buffer is W tiled. However, we request from the kernel a
       * non-tiled buffer because the GTT is incapable of W fencing.
       */
      return I915_TILING_NONE;
   }

   /* Some usages may want only one type of tiling, like depth miptrees (Y
    * tiled), or temporary BOs for uploading data once (linear).
    */
   switch (requested) {
   case INTEL_MIPTREE_TILING_ANY:
      break;
   case INTEL_MIPTREE_TILING_Y:
      return I915_TILING_Y;
   case INTEL_MIPTREE_TILING_NONE:
      return I915_TILING_NONE;
   }

   if (num_samples > 1) {
      /* From p82 of the Sandy Bridge PRM, dw3[1] of SURFACE_STATE ("Tiled
       * Surface"):
       *
       *   [DevSNB+]: For multi-sample render targets, this field must be
       *   1. MSRTs can only be tiled.
       *
       * Our usual reason for preferring X tiling (fast blits using the
       * blitting engine) doesn't apply to MSAA, since we'll generally be
       * downsampling or upsampling when blitting between the MSAA buffer
       * and another buffer, and the blitting engine doesn't support that.
       * So use Y tiling, since it makes better use of the cache.
       */
      return I915_TILING_Y;
   }

   GLenum base_format = _mesa_get_format_base_format(format);
   if (base_format == GL_DEPTH_COMPONENT ||
       base_format == GL_DEPTH_STENCIL_EXT)
      return I915_TILING_Y;

   int minimum_pitch = mt->total_width * mt->cpp;

   /* If the width is much smaller than a tile, don't bother tiling. */
   if (minimum_pitch < 64)
      return I915_TILING_NONE;

   if (ALIGN(minimum_pitch, 512) >= 32768 ||
       mt->total_width >= 32768 || mt->total_height >= 32768) {
      perf_debug("%dx%d miptree too large to blit, falling back to untiled",
                 mt->total_width, mt->total_height);
      return I915_TILING_NONE;
   }

   /* Pre-gen6 doesn't have BLORP to handle Y-tiling, so use X-tiling. */
   if (brw->gen < 6)
      return I915_TILING_X;

   /* From the Sandybridge PRM, Volume 1, Part 2, page 32:
    * "NOTE: 128BPE Format Color Buffer ( render target ) MUST be either TileX
    *  or Linear."
    * 128 bits per pixel translates to 16 bytes per pixel.  This is necessary
    * all the way back to 965, but is explicitly permitted on Gen7.
    */
   if (brw->gen != 7 && mt->cpp >= 16)
      return I915_TILING_X;

   /* From the Ivy Bridge PRM, Vol4 Part1 2.12.2.1 (SURFACE_STATE for most
    * messages), on p64, under the heading "Surface Vertical Alignment":
    *
    *     This field must be set to VALIGN_4 for all tiled Y Render Target
    *     surfaces.
    *
    * So if the surface is renderable and uses a vertical alignment of 2,
    * force it to be X tiled.  This is somewhat conservative (it's possible
    * that the client won't ever render to this surface), but it's difficult
    * to know that ahead of time.  And besides, since we use a vertical
    * alignment of 4 as often as we can, this shouldn't happen very often.
    */
   if (brw->gen == 7 && mt->align_h == 2 &&
       brw->format_supported_as_render_target[format]) {
      return I915_TILING_X;
   }

   return I915_TILING_Y | I915_TILING_X;
}


/**
 * Choose an appropriate uncompressed format for a requested
 * compressed format, if unsupported.
 */
mesa_format
intel_lower_compressed_format(struct brw_context *brw, mesa_format format)
{
   /* No need to lower ETC formats on these platforms,
    * they are supported natively.
    */
   if (brw->gen >= 8 || brw->is_baytrail)
      return format;

   switch (format) {
   case MESA_FORMAT_ETC1_RGB8:
      return MESA_FORMAT_R8G8B8X8_UNORM;
   case MESA_FORMAT_ETC2_RGB8:
      return MESA_FORMAT_R8G8B8X8_UNORM;
   case MESA_FORMAT_ETC2_SRGB8:
   case MESA_FORMAT_ETC2_SRGB8_ALPHA8_EAC:
   case MESA_FORMAT_ETC2_SRGB8_PUNCHTHROUGH_ALPHA1:
      return MESA_FORMAT_B8G8R8A8_SRGB;
   case MESA_FORMAT_ETC2_RGBA8_EAC:
   case MESA_FORMAT_ETC2_RGB8_PUNCHTHROUGH_ALPHA1:
      return MESA_FORMAT_R8G8B8A8_UNORM;
   case MESA_FORMAT_ETC2_R11_EAC:
      return MESA_FORMAT_R_UNORM16;
   case MESA_FORMAT_ETC2_SIGNED_R11_EAC:
      return MESA_FORMAT_R_SNORM16;
   case MESA_FORMAT_ETC2_RG11_EAC:
      return MESA_FORMAT_R16G16_UNORM;
   case MESA_FORMAT_ETC2_SIGNED_RG11_EAC:
      return MESA_FORMAT_R16G16_SNORM;
   default:
      /* Non ETC1 / ETC2 format */
      return format;
   }
}


struct intel_mipmap_tree *
intel_miptree_create(struct brw_context *brw,
		     GLenum target,
		     mesa_format format,
		     GLuint first_level,
		     GLuint last_level,
		     GLuint width0,
		     GLuint height0,
		     GLuint depth0,
		     bool expect_accelerated_upload,
                     GLuint num_samples,
                     enum intel_miptree_tiling_mode requested_tiling)
{
   struct intel_mipmap_tree *mt;
   mesa_format tex_format = format;
   mesa_format etc_format = MESA_FORMAT_NONE;
   GLuint total_width, total_height;

   format = intel_lower_compressed_format(brw, format);

   etc_format = (format != tex_format) ? tex_format : MESA_FORMAT_NONE;

   mt = intel_miptree_create_layout(brw, target, format,
				      first_level, last_level, width0,
				      height0, depth0,
				      false, num_samples);
   /*
    * pitch == 0 || height == 0  indicates the null texture
    */
   if (!mt || !mt->total_width || !mt->total_height) {
      intel_miptree_release(&mt);
      return NULL;
   }

   total_width = mt->total_width;
   total_height = mt->total_height;

   if (format == MESA_FORMAT_S_UINT8) {
      /* Align to size of W tile, 64x64. */
      total_width = ALIGN(total_width, 64);
      total_height = ALIGN(total_height, 64);
   }

   uint32_t tiling = intel_miptree_choose_tiling(brw, format, width0,
                                                 num_samples, requested_tiling,
                                                 mt);
   bool y_or_x = false;

   if (tiling == (I915_TILING_Y | I915_TILING_X)) {
      y_or_x = true;
      mt->tiling = I915_TILING_Y;
   } else {
      mt->tiling = tiling;
   }

   unsigned long pitch;
   mt->etc_format = etc_format;
   mt->bo = drm_intel_bo_alloc_tiled(brw->bufmgr, "miptree",
                                     total_width, total_height, mt->cpp,
                                     &mt->tiling, &pitch,
                                     (expect_accelerated_upload ?
                                      BO_ALLOC_FOR_RENDER : 0));
   mt->pitch = pitch;

   /* If the BO is too large to fit in the aperture, we need to use the
    * BLT engine to support it.  The BLT paths can't currently handle Y-tiling,
    * so we need to fall back to X.
    */
   if (y_or_x && mt->bo->size >= brw->max_gtt_map_object_size) {
      perf_debug("%dx%d miptree larger than aperture; falling back to X-tiled\n",
                 mt->total_width, mt->total_height);

      mt->tiling = I915_TILING_X;
      drm_intel_bo_unreference(mt->bo);
      mt->bo = drm_intel_bo_alloc_tiled(brw->bufmgr, "miptree",
                                        total_width, total_height, mt->cpp,
                                        &mt->tiling, &pitch,
                                        (expect_accelerated_upload ?
                                         BO_ALLOC_FOR_RENDER : 0));
      mt->pitch = pitch;
   }

   mt->offset = 0;

   if (!mt->bo) {
       intel_miptree_release(&mt);
       return NULL;
   }


   if (mt->msaa_layout == INTEL_MSAA_LAYOUT_CMS) {
      if (!intel_miptree_alloc_mcs(brw, mt, num_samples)) {
         intel_miptree_release(&mt);
         return NULL;
      }
   }

   /* If this miptree is capable of supporting fast color clears, set
    * fast_clear_state appropriately to ensure that fast clears will occur.
    * Allocation of the MCS miptree will be deferred until the first fast
    * clear actually occurs.
    */
   if (intel_is_non_msrt_mcs_buffer_supported(brw, mt))
      mt->fast_clear_state = INTEL_FAST_CLEAR_STATE_RESOLVED;

   return mt;
}

struct intel_mipmap_tree *
intel_miptree_create_for_bo(struct brw_context *brw,
                            drm_intel_bo *bo,
                            mesa_format format,
                            uint32_t offset,
                            uint32_t width,
                            uint32_t height,
                            int pitch)
{
   struct intel_mipmap_tree *mt;
   uint32_t tiling, swizzle;

   drm_intel_bo_get_tiling(bo, &tiling, &swizzle);

   /* Nothing will be able to use this miptree with the BO if the offset isn't
    * aligned.
    */
   if (tiling != I915_TILING_NONE)
      assert(offset % 4096 == 0);

   /* miptrees can't handle negative pitch.  If you need flipping of images,
    * that's outside of the scope of the mt.
    */
   assert(pitch >= 0);

   mt = intel_miptree_create_layout(brw, GL_TEXTURE_2D, format,
                                    0, 0,
                                    width, height, 1,
                                    true, 0 /* num_samples */);
   if (!mt) {
      free(mt);
      return mt;
   }

   drm_intel_bo_reference(bo);
   mt->bo = bo;
   mt->pitch = pitch;
   mt->offset = offset;
   mt->tiling = tiling;

   return mt;
}

/**
 * For a singlesample renderbuffer, this simply wraps the given BO with a
 * miptree.
 *
 * For a multisample renderbuffer, this wraps the window system's
 * (singlesample) BO with a singlesample miptree attached to the
 * intel_renderbuffer, then creates a multisample miptree attached to irb->mt
 * that will contain the actual rendering (which is lazily resolved to
 * irb->singlesample_mt).
 */
void
intel_update_winsys_renderbuffer_miptree(struct brw_context *intel,
                                         struct intel_renderbuffer *irb,
                                         drm_intel_bo *bo,
                                         uint32_t width, uint32_t height,
                                         uint32_t pitch)
{
   struct intel_mipmap_tree *singlesample_mt = NULL;
   struct intel_mipmap_tree *multisample_mt = NULL;
   struct gl_renderbuffer *rb = &irb->Base.Base;
   mesa_format format = rb->Format;
   int num_samples = rb->NumSamples;

   /* Only the front and back buffers, which are color buffers, are allocated
    * through the image loader.
    */
   assert(_mesa_get_format_base_format(format) == GL_RGB ||
          _mesa_get_format_base_format(format) == GL_RGBA);

   singlesample_mt = intel_miptree_create_for_bo(intel,
                                                 bo,
                                                 format,
                                                 0,
                                                 width,
                                                 height,
                                                 pitch);
   if (!singlesample_mt)
      goto fail;

   /* If this miptree is capable of supporting fast color clears, set
    * mcs_state appropriately to ensure that fast clears will occur.
    * Allocation of the MCS miptree will be deferred until the first fast
    * clear actually occurs.
    */
   if (intel_is_non_msrt_mcs_buffer_supported(intel, singlesample_mt))
      singlesample_mt->fast_clear_state = INTEL_FAST_CLEAR_STATE_RESOLVED;

   if (num_samples == 0) {
      intel_miptree_release(&irb->mt);
      irb->mt = singlesample_mt;

      assert(!irb->singlesample_mt);
   } else {
      intel_miptree_release(&irb->singlesample_mt);
      irb->singlesample_mt = singlesample_mt;

      if (!irb->mt ||
          irb->mt->logical_width0 != width ||
          irb->mt->logical_height0 != height) {
         multisample_mt = intel_miptree_create_for_renderbuffer(intel,
                                                                format,
                                                                width,
                                                                height,
                                                                num_samples);
         if (!multisample_mt)
            goto fail;

         irb->need_downsample = false;
         intel_miptree_release(&irb->mt);
         irb->mt = multisample_mt;
      }
   }
   return;

fail:
   intel_miptree_release(&irb->singlesample_mt);
   intel_miptree_release(&irb->mt);
   return;
}

struct intel_mipmap_tree*
intel_miptree_create_for_renderbuffer(struct brw_context *brw,
                                      mesa_format format,
                                      uint32_t width,
                                      uint32_t height,
                                      uint32_t num_samples)
{
   struct intel_mipmap_tree *mt;
   uint32_t depth = 1;
   bool ok;
   GLenum target = num_samples > 1 ? GL_TEXTURE_2D_MULTISAMPLE : GL_TEXTURE_2D;

   mt = intel_miptree_create(brw, target, format, 0, 0,
			     width, height, depth, true, num_samples,
                             INTEL_MIPTREE_TILING_ANY);
   if (!mt)
      goto fail;

   if (brw_is_hiz_depth_format(brw, format)) {
      ok = intel_miptree_alloc_hiz(brw, mt);
      if (!ok)
         goto fail;
   }

   return mt;

fail:
   intel_miptree_release(&mt);
   return NULL;
}

void
intel_miptree_reference(struct intel_mipmap_tree **dst,
                        struct intel_mipmap_tree *src)
{
   if (*dst == src)
      return;

   intel_miptree_release(dst);

   if (src) {
      src->refcount++;
      DBG("%s %p refcount now %d\n", __FUNCTION__, src, src->refcount);
   }

   *dst = src;
}


void
intel_miptree_release(struct intel_mipmap_tree **mt)
{
   if (!*mt)
      return;

   DBG("%s %p refcount will be %d\n", __FUNCTION__, *mt, (*mt)->refcount - 1);
   if (--(*mt)->refcount <= 0) {
      GLuint i;

      DBG("%s deleting %p\n", __FUNCTION__, *mt);

      drm_intel_bo_unreference((*mt)->bo);
      intel_miptree_release(&(*mt)->stencil_mt);
      intel_miptree_release(&(*mt)->hiz_mt);
      intel_miptree_release(&(*mt)->mcs_mt);
      intel_resolve_map_clear(&(*mt)->hiz_map);

      for (i = 0; i < MAX_TEXTURE_LEVELS; i++) {
	 free((*mt)->level[i].slice);
      }

      free(*mt);
   }
   *mt = NULL;
}

void
intel_miptree_get_dimensions_for_image(struct gl_texture_image *image,
                                       int *width, int *height, int *depth)
{
   switch (image->TexObject->Target) {
   case GL_TEXTURE_1D_ARRAY:
      *width = image->Width;
      *height = 1;
      *depth = image->Height;
      break;
   default:
      *width = image->Width;
      *height = image->Height;
      *depth = image->Depth;
      break;
   }
}

/**
 * Can the image be pulled into a unified mipmap tree?  This mirrors
 * the completeness test in a lot of ways.
 *
 * Not sure whether I want to pass gl_texture_image here.
 */
bool
intel_miptree_match_image(struct intel_mipmap_tree *mt,
                          struct gl_texture_image *image)
{
   struct intel_texture_image *intelImage = intel_texture_image(image);
   GLuint level = intelImage->base.Base.Level;
   int width, height, depth;

   /* glTexImage* choose the texture object based on the target passed in, and
    * objects can't change targets over their lifetimes, so this should be
    * true.
    */
   assert(image->TexObject->Target == mt->target);

   mesa_format mt_format = mt->format;
   if (mt->format == MESA_FORMAT_Z24_UNORM_X8_UINT && mt->stencil_mt)
      mt_format = MESA_FORMAT_Z24_UNORM_S8_UINT;
   if (mt->format == MESA_FORMAT_Z_FLOAT32 && mt->stencil_mt)
      mt_format = MESA_FORMAT_Z32_FLOAT_S8X24_UINT;
   if (mt->etc_format != MESA_FORMAT_NONE)
      mt_format = mt->etc_format;

   if (image->TexFormat != mt_format)
      return false;

   intel_miptree_get_dimensions_for_image(image, &width, &height, &depth);

   if (mt->target == GL_TEXTURE_CUBE_MAP)
      depth = 6;

   int level_depth = mt->level[level].depth;
   if (mt->num_samples > 1) {
      switch (mt->msaa_layout) {
      case INTEL_MSAA_LAYOUT_NONE:
      case INTEL_MSAA_LAYOUT_IMS:
         break;
      case INTEL_MSAA_LAYOUT_UMS:
      case INTEL_MSAA_LAYOUT_CMS:
         level_depth /= mt->num_samples;
         break;
      }
   }

   /* Test image dimensions against the base level image adjusted for
    * minification.  This will also catch images not present in the
    * tree, changed targets, etc.
    */
   if (width != minify(mt->logical_width0, level - mt->first_level) ||
       height != minify(mt->logical_height0, level - mt->first_level) ||
       depth != level_depth) {
      return false;
   }

   if (image->NumSamples != mt->num_samples)
      return false;

   return true;
}


void
intel_miptree_set_level_info(struct intel_mipmap_tree *mt,
			     GLuint level,
			     GLuint x, GLuint y, GLuint d)
{
   mt->level[level].depth = d;
   mt->level[level].level_x = x;
   mt->level[level].level_y = y;

   DBG("%s level %d, depth %d, offset %d,%d\n", __FUNCTION__,
       level, d, x, y);

   assert(mt->level[level].slice == NULL);

   mt->level[level].slice = calloc(d, sizeof(*mt->level[0].slice));
   mt->level[level].slice[0].x_offset = mt->level[level].level_x;
   mt->level[level].slice[0].y_offset = mt->level[level].level_y;
}


void
intel_miptree_set_image_offset(struct intel_mipmap_tree *mt,
			       GLuint level, GLuint img,
			       GLuint x, GLuint y)
{
   if (img == 0 && level == 0)
      assert(x == 0 && y == 0);

   assert(img < mt->level[level].depth);

   mt->level[level].slice[img].x_offset = mt->level[level].level_x + x;
   mt->level[level].slice[img].y_offset = mt->level[level].level_y + y;

   DBG("%s level %d img %d pos %d,%d\n",
       __FUNCTION__, level, img,
       mt->level[level].slice[img].x_offset,
       mt->level[level].slice[img].y_offset);
}

void
intel_miptree_get_image_offset(const struct intel_mipmap_tree *mt,
			       GLuint level, GLuint slice,
			       GLuint *x, GLuint *y)
{
   assert(slice < mt->level[level].depth);

   *x = mt->level[level].slice[slice].x_offset;
   *y = mt->level[level].slice[slice].y_offset;
}

/**
 * This function computes masks that may be used to select the bits of the X
 * and Y coordinates that indicate the offset within a tile.  If the BO is
 * untiled, the masks are set to 0.
 */
void
intel_miptree_get_tile_masks(const struct intel_mipmap_tree *mt,
                             uint32_t *mask_x, uint32_t *mask_y,
                             bool map_stencil_as_y_tiled)
{
   int cpp = mt->cpp;
   uint32_t tiling = mt->tiling;

   if (map_stencil_as_y_tiled)
      tiling = I915_TILING_Y;

   switch (tiling) {
   default:
      assert(false);
   case I915_TILING_NONE:
      *mask_x = *mask_y = 0;
      break;
   case I915_TILING_X:
      *mask_x = 512 / cpp - 1;
      *mask_y = 7;
      break;
   case I915_TILING_Y:
      *mask_x = 128 / cpp - 1;
      *mask_y = 31;
      break;
   }
}

/**
 * Compute the offset (in bytes) from the start of the BO to the given x
 * and y coordinate.  For tiled BOs, caller must ensure that x and y are
 * multiples of the tile size.
 */
uint32_t
intel_miptree_get_aligned_offset(const struct intel_mipmap_tree *mt,
                                 uint32_t x, uint32_t y,
                                 bool map_stencil_as_y_tiled)
{
   int cpp = mt->cpp;
   uint32_t pitch = mt->pitch;
   uint32_t tiling = mt->tiling;

   if (map_stencil_as_y_tiled) {
      tiling = I915_TILING_Y;

      /* When mapping a W-tiled stencil buffer as Y-tiled, each 64-high W-tile
       * gets transformed into a 32-high Y-tile.  Accordingly, the pitch of
       * the resulting surface is twice the pitch of the original miptree,
       * since each row in the Y-tiled view corresponds to two rows in the
       * actual W-tiled surface.  So we need to correct the pitch before
       * computing the offsets.
       */
      pitch *= 2;
   }

   switch (tiling) {
   default:
      assert(false);
   case I915_TILING_NONE:
      return y * pitch + x * cpp;
   case I915_TILING_X:
      assert((x % (512 / cpp)) == 0);
      assert((y % 8) == 0);
      return y * pitch + x / (512 / cpp) * 4096;
   case I915_TILING_Y:
      assert((x % (128 / cpp)) == 0);
      assert((y % 32) == 0);
      return y * pitch + x / (128 / cpp) * 4096;
   }
}

/**
 * Rendering with tiled buffers requires that the base address of the buffer
 * be aligned to a page boundary.  For renderbuffers, and sometimes with
 * textures, we may want the surface to point at a texture image level that
 * isn't at a page boundary.
 *
 * This function returns an appropriately-aligned base offset
 * according to the tiling restrictions, plus any required x/y offset
 * from there.
 */
uint32_t
intel_miptree_get_tile_offsets(const struct intel_mipmap_tree *mt,
                               GLuint level, GLuint slice,
                               uint32_t *tile_x,
                               uint32_t *tile_y)
{
   uint32_t x, y;
   uint32_t mask_x, mask_y;

   intel_miptree_get_tile_masks(mt, &mask_x, &mask_y, false);
   intel_miptree_get_image_offset(mt, level, slice, &x, &y);

   *tile_x = x & mask_x;
   *tile_y = y & mask_y;

   return intel_miptree_get_aligned_offset(mt, x & ~mask_x, y & ~mask_y, false);
}

static void
intel_miptree_copy_slice_sw(struct brw_context *brw,
                            struct intel_mipmap_tree *dst_mt,
                            struct intel_mipmap_tree *src_mt,
                            int level,
                            int slice,
                            int width,
                            int height)
{
   void *src, *dst;
   int src_stride, dst_stride;
   int cpp = dst_mt->cpp;

   intel_miptree_map(brw, src_mt,
                     level, slice,
                     0, 0,
                     width, height,
                     GL_MAP_READ_BIT | BRW_MAP_DIRECT_BIT,
                     &src, &src_stride);

   intel_miptree_map(brw, dst_mt,
                     level, slice,
                     0, 0,
                     width, height,
                     GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_RANGE_BIT |
                     BRW_MAP_DIRECT_BIT,
                     &dst, &dst_stride);

   DBG("sw blit %s mt %p %p/%d -> %s mt %p %p/%d (%dx%d)\n",
       _mesa_get_format_name(src_mt->format),
       src_mt, src, src_stride,
       _mesa_get_format_name(dst_mt->format),
       dst_mt, dst, dst_stride,
       width, height);

   int row_size = cpp * width;
   if (src_stride == row_size &&
       dst_stride == row_size) {
      memcpy(dst, src, row_size * height);
   } else {
      for (int i = 0; i < height; i++) {
         memcpy(dst, src, row_size);
         dst += dst_stride;
         src += src_stride;
      }
   }

   intel_miptree_unmap(brw, dst_mt, level, slice);
   intel_miptree_unmap(brw, src_mt, level, slice);

   /* Don't forget to copy the stencil data over, too.  We could have skipped
    * passing BRW_MAP_DIRECT_BIT, but that would have meant intel_miptree_map
    * shuffling the two data sources in/out of temporary storage instead of
    * the direct mapping we get this way.
    */
   if (dst_mt->stencil_mt) {
      assert(src_mt->stencil_mt);
      intel_miptree_copy_slice_sw(brw, dst_mt->stencil_mt, src_mt->stencil_mt,
                                  level, slice, width, height);
   }
}

static void
intel_miptree_copy_slice(struct brw_context *brw,
			 struct intel_mipmap_tree *dst_mt,
			 struct intel_mipmap_tree *src_mt,
			 int level,
			 int face,
			 int depth)

{
   mesa_format format = src_mt->format;
   uint32_t width = minify(src_mt->physical_width0, level - src_mt->first_level);
   uint32_t height = minify(src_mt->physical_height0, level - src_mt->first_level);
   int slice;

   if (face > 0)
      slice = face;
   else
      slice = depth;

   assert(depth < src_mt->level[level].depth);
   assert(src_mt->format == dst_mt->format);

   if (dst_mt->compressed) {
      height = ALIGN(height, dst_mt->align_h) / dst_mt->align_h;
      width = ALIGN(width, dst_mt->align_w);
   }

   /* If it's a packed depth/stencil buffer with separate stencil, the blit
    * below won't apply since we can't do the depth's Y tiling or the
    * stencil's W tiling in the blitter.
    */
   if (src_mt->stencil_mt) {
      intel_miptree_copy_slice_sw(brw,
                                  dst_mt, src_mt,
                                  level, slice,
                                  width, height);
      return;
   }

   uint32_t dst_x, dst_y, src_x, src_y;
   intel_miptree_get_image_offset(dst_mt, level, slice, &dst_x, &dst_y);
   intel_miptree_get_image_offset(src_mt, level, slice, &src_x, &src_y);

   DBG("validate blit mt %s %p %d,%d/%d -> mt %s %p %d,%d/%d (%dx%d)\n",
       _mesa_get_format_name(src_mt->format),
       src_mt, src_x, src_y, src_mt->pitch,
       _mesa_get_format_name(dst_mt->format),
       dst_mt, dst_x, dst_y, dst_mt->pitch,
       width, height);

   if (!intel_miptree_blit(brw,
                           src_mt, level, slice, 0, 0, false,
                           dst_mt, level, slice, 0, 0, false,
                           width, height, GL_COPY)) {
      perf_debug("miptree validate blit for %s failed\n",
                 _mesa_get_format_name(format));

      intel_miptree_copy_slice_sw(brw, dst_mt, src_mt, level, slice,
                                  width, height);
   }
}

/**
 * Copies the image's current data to the given miptree, and associates that
 * miptree with the image.
 *
 * If \c invalidate is true, then the actual image data does not need to be
 * copied, but the image still needs to be associated to the new miptree (this
 * is set to true if we're about to clear the image).
 */
void
intel_miptree_copy_teximage(struct brw_context *brw,
			    struct intel_texture_image *intelImage,
			    struct intel_mipmap_tree *dst_mt,
                            bool invalidate)
{
   struct intel_mipmap_tree *src_mt = intelImage->mt;
   struct intel_texture_object *intel_obj =
      intel_texture_object(intelImage->base.Base.TexObject);
   int level = intelImage->base.Base.Level;
   int face = intelImage->base.Base.Face;
   GLuint depth = intelImage->base.Base.Depth;

   if (!invalidate) {
      for (int slice = 0; slice < depth; slice++) {
         intel_miptree_copy_slice(brw, dst_mt, src_mt, level, face, slice);
      }
   }

   intel_miptree_reference(&intelImage->mt, dst_mt);
   intel_obj->needs_validate = true;
}

bool
intel_miptree_alloc_mcs(struct brw_context *brw,
                        struct intel_mipmap_tree *mt,
                        GLuint num_samples)
{
   assert(brw->gen >= 7); /* MCS only used on Gen7+ */
   assert(mt->mcs_mt == NULL);

   /* Choose the correct format for the MCS buffer.  All that really matters
    * is that we allocate the right buffer size, since we'll always be
    * accessing this miptree using MCS-specific hardware mechanisms, which
    * infer the correct format based on num_samples.
    */
   mesa_format format;
   switch (num_samples) {
   case 2:
   case 4:
      /* 8 bits/pixel are required for MCS data when using 4x MSAA (2 bits for
       * each sample).
       */
      format = MESA_FORMAT_R_UNORM8;
      break;
   case 8:
      /* 32 bits/pixel are required for MCS data when using 8x MSAA (3 bits
       * for each sample, plus 8 padding bits).
       */
      format = MESA_FORMAT_R_UINT32;
      break;
   default:
      assert(!"Unrecognized sample count in intel_miptree_alloc_mcs");
      return false;
   };

   /* From the Ivy Bridge PRM, Vol4 Part1 p76, "MCS Base Address":
    *
    *     "The MCS surface must be stored as Tile Y."
    */
   mt->mcs_mt = intel_miptree_create(brw,
                                     mt->target,
                                     format,
                                     mt->first_level,
                                     mt->last_level,
                                     mt->logical_width0,
                                     mt->logical_height0,
                                     mt->logical_depth0,
                                     true,
                                     0 /* num_samples */,
                                     INTEL_MIPTREE_TILING_Y);

   /* From the Ivy Bridge PRM, Vol 2 Part 1 p326:
    *
    *     When MCS buffer is enabled and bound to MSRT, it is required that it
    *     is cleared prior to any rendering.
    *
    * Since we don't use the MCS buffer for any purpose other than rendering,
    * it makes sense to just clear it immediately upon allocation.
    *
    * Note: the clear value for MCS buffers is all 1's, so we memset to 0xff.
    */
   void *data = intel_miptree_map_raw(brw, mt->mcs_mt);
   memset(data, 0xff, mt->mcs_mt->total_height * mt->mcs_mt->pitch);
   intel_miptree_unmap_raw(brw, mt->mcs_mt);
   mt->fast_clear_state = INTEL_FAST_CLEAR_STATE_CLEAR;

   return mt->mcs_mt;
}


bool
intel_miptree_alloc_non_msrt_mcs(struct brw_context *brw,
                                 struct intel_mipmap_tree *mt)
{
   assert(mt->mcs_mt == NULL);

   /* The format of the MCS buffer is opaque to the driver; all that matters
    * is that we get its size and pitch right.  We'll pretend that the format
    * is R32.  Since an MCS tile covers 128 blocks horizontally, and a Y-tiled
    * R32 buffer is 32 pixels across, we'll need to scale the width down by
    * the block width and then a further factor of 4.  Since an MCS tile
    * covers 256 blocks vertically, and a Y-tiled R32 buffer is 32 rows high,
    * we'll need to scale the height down by the block height and then a
    * further factor of 8.
    */
   const mesa_format format = MESA_FORMAT_R_UINT32;
   unsigned block_width_px;
   unsigned block_height;
   intel_get_non_msrt_mcs_alignment(brw, mt, &block_width_px, &block_height);
   unsigned width_divisor = block_width_px * 4;
   unsigned height_divisor = block_height * 8;
   unsigned mcs_width =
      ALIGN(mt->logical_width0, width_divisor) / width_divisor;
   unsigned mcs_height =
      ALIGN(mt->logical_height0, height_divisor) / height_divisor;
   assert(mt->logical_depth0 == 1);
   mt->mcs_mt = intel_miptree_create(brw,
                                     mt->target,
                                     format,
                                     mt->first_level,
                                     mt->last_level,
                                     mcs_width,
                                     mcs_height,
                                     mt->logical_depth0,
                                     true,
                                     0 /* num_samples */,
                                     INTEL_MIPTREE_TILING_Y);

   return mt->mcs_mt;
}


/**
 * Helper for intel_miptree_alloc_hiz() that sets
 * \c mt->level[level].slice[layer].has_hiz. Return true if and only if
 * \c has_hiz was set.
 */
static bool
intel_miptree_slice_enable_hiz(struct brw_context *brw,
                               struct intel_mipmap_tree *mt,
                               uint32_t level,
                               uint32_t layer)
{
   assert(mt->hiz_mt);

   if (brw->gen >= 8 || brw->is_haswell) {
      uint32_t width = minify(mt->physical_width0, level);
      uint32_t height = minify(mt->physical_height0, level);

      /* Disable HiZ for LOD > 0 unless the width is 8 aligned
       * and the height is 4 aligned. This allows our HiZ support
       * to fulfill Haswell restrictions for HiZ ops. For LOD == 0,
       * we can grow the width & height to allow the HiZ op to
       * force the proper size alignments.
       */
      if (level > 0 && ((width & 7) || (height & 3))) {
         return false;
      }
   }

   mt->level[level].slice[layer].has_hiz = true;
   return true;
}



bool
intel_miptree_alloc_hiz(struct brw_context *brw,
			struct intel_mipmap_tree *mt)
{
   assert(mt->hiz_mt == NULL);
   mt->hiz_mt = intel_miptree_create(brw,
                                     mt->target,
                                     mt->format,
                                     mt->first_level,
                                     mt->last_level,
                                     mt->logical_width0,
                                     mt->logical_height0,
                                     mt->logical_depth0,
                                     true,
                                     mt->num_samples,
                                     INTEL_MIPTREE_TILING_ANY);

   if (!mt->hiz_mt)
      return false;

   /* Mark that all slices need a HiZ resolve. */
   struct intel_resolve_map *head = &mt->hiz_map;
   for (int level = mt->first_level; level <= mt->last_level; ++level) {
      for (int layer = 0; layer < mt->level[level].depth; ++layer) {
         if (!intel_miptree_slice_enable_hiz(brw, mt, level, layer))
            continue;

	 head->next = malloc(sizeof(*head->next));
	 head->next->prev = head;
	 head->next->next = NULL;
	 head = head->next;

	 head->level = level;
	 head->layer = layer;
	 head->need = GEN6_HIZ_OP_HIZ_RESOLVE;
      }
   }

   return true;
}

/**
 * Does the miptree slice have hiz enabled?
 */
bool
intel_miptree_slice_has_hiz(struct intel_mipmap_tree *mt,
                            uint32_t level,
                            uint32_t layer)
{
   intel_miptree_check_level_layer(mt, level, layer);
   return mt->level[level].slice[layer].has_hiz;
}

void
intel_miptree_slice_set_needs_hiz_resolve(struct intel_mipmap_tree *mt,
					  uint32_t level,
					  uint32_t layer)
{
   if (!intel_miptree_slice_has_hiz(mt, level, layer))
      return;

   intel_resolve_map_set(&mt->hiz_map,
			 level, layer, GEN6_HIZ_OP_HIZ_RESOLVE);
}


void
intel_miptree_slice_set_needs_depth_resolve(struct intel_mipmap_tree *mt,
                                            uint32_t level,
                                            uint32_t layer)
{
   if (!intel_miptree_slice_has_hiz(mt, level, layer))
      return;

   intel_resolve_map_set(&mt->hiz_map,
			 level, layer, GEN6_HIZ_OP_DEPTH_RESOLVE);
}

void
intel_miptree_set_all_slices_need_depth_resolve(struct intel_mipmap_tree *mt,
                                                uint32_t level)
{
   uint32_t layer;
   uint32_t end_layer = mt->level[level].depth;

   for (layer = 0; layer < end_layer; layer++) {
      intel_miptree_slice_set_needs_depth_resolve(mt, level, layer);
   }
}

static bool
intel_miptree_slice_resolve(struct brw_context *brw,
			    struct intel_mipmap_tree *mt,
			    uint32_t level,
			    uint32_t layer,
			    enum gen6_hiz_op need)
{
   intel_miptree_check_level_layer(mt, level, layer);

   struct intel_resolve_map *item =
	 intel_resolve_map_get(&mt->hiz_map, level, layer);

   if (!item || item->need != need)
      return false;

   intel_hiz_exec(brw, mt, level, layer, need);
   intel_resolve_map_remove(item);
   return true;
}

bool
intel_miptree_slice_resolve_hiz(struct brw_context *brw,
				struct intel_mipmap_tree *mt,
				uint32_t level,
				uint32_t layer)
{
   return intel_miptree_slice_resolve(brw, mt, level, layer,
				      GEN6_HIZ_OP_HIZ_RESOLVE);
}

bool
intel_miptree_slice_resolve_depth(struct brw_context *brw,
				  struct intel_mipmap_tree *mt,
				  uint32_t level,
				  uint32_t layer)
{
   return intel_miptree_slice_resolve(brw, mt, level, layer,
				      GEN6_HIZ_OP_DEPTH_RESOLVE);
}

static bool
intel_miptree_all_slices_resolve(struct brw_context *brw,
				 struct intel_mipmap_tree *mt,
				 enum gen6_hiz_op need)
{
   bool did_resolve = false;
   struct intel_resolve_map *i, *next;

   for (i = mt->hiz_map.next; i; i = next) {
      next = i->next;
      if (i->need != need)
	 continue;

      intel_hiz_exec(brw, mt, i->level, i->layer, need);
      intel_resolve_map_remove(i);
      did_resolve = true;
   }

   return did_resolve;
}

bool
intel_miptree_all_slices_resolve_hiz(struct brw_context *brw,
				     struct intel_mipmap_tree *mt)
{
   return intel_miptree_all_slices_resolve(brw, mt,
					   GEN6_HIZ_OP_HIZ_RESOLVE);
}

bool
intel_miptree_all_slices_resolve_depth(struct brw_context *brw,
				       struct intel_mipmap_tree *mt)
{
   return intel_miptree_all_slices_resolve(brw, mt,
					   GEN6_HIZ_OP_DEPTH_RESOLVE);
}


void
intel_miptree_resolve_color(struct brw_context *brw,
                            struct intel_mipmap_tree *mt)
{
   switch (mt->fast_clear_state) {
   case INTEL_FAST_CLEAR_STATE_NO_MCS:
   case INTEL_FAST_CLEAR_STATE_RESOLVED:
      /* No resolve needed */
      break;
   case INTEL_FAST_CLEAR_STATE_UNRESOLVED:
   case INTEL_FAST_CLEAR_STATE_CLEAR:
      /* Fast color clear resolves only make sense for non-MSAA buffers. */
      if (mt->msaa_layout == INTEL_MSAA_LAYOUT_NONE)
         brw_blorp_resolve_color(brw, mt);
      break;
   }
}


/**
 * Make it possible to share the BO backing the given miptree with another
 * process or another miptree.
 *
 * Fast color clears are unsafe with shared buffers, so we need to resolve and
 * then discard the MCS buffer, if present.  We also set the fast_clear_state
 * to INTEL_FAST_CLEAR_STATE_NO_MCS to ensure that no MCS buffer gets
 * allocated in the future.
 */
void
intel_miptree_make_shareable(struct brw_context *brw,
                             struct intel_mipmap_tree *mt)
{
   /* MCS buffers are also used for multisample buffers, but we can't resolve
    * away a multisample MCS buffer because it's an integral part of how the
    * pixel data is stored.  Fortunately this code path should never be
    * reached for multisample buffers.
    */
   assert(mt->msaa_layout == INTEL_MSAA_LAYOUT_NONE);

   if (mt->mcs_mt) {
      intel_miptree_resolve_color(brw, mt);
      intel_miptree_release(&mt->mcs_mt);
      mt->fast_clear_state = INTEL_FAST_CLEAR_STATE_NO_MCS;
   }
}


/**
 * \brief Get pointer offset into stencil buffer.
 *
 * The stencil buffer is W tiled. Since the GTT is incapable of W fencing, we
 * must decode the tile's layout in software.
 *
 * See
 *   - PRM, 2011 Sandy Bridge, Volume 1, Part 2, Section 4.5.2.1 W-Major Tile
 *     Format.
 *   - PRM, 2011 Sandy Bridge, Volume 1, Part 2, Section 4.5.3 Tiling Algorithm
 *
 * Even though the returned offset is always positive, the return type is
 * signed due to
 *    commit e8b1c6d6f55f5be3bef25084fdd8b6127517e137
 *    mesa: Fix return type of  _mesa_get_format_bytes() (#37351)
 */
static intptr_t
intel_offset_S8(uint32_t stride, uint32_t x, uint32_t y, bool swizzled)
{
   uint32_t tile_size = 4096;
   uint32_t tile_width = 64;
   uint32_t tile_height = 64;
   uint32_t row_size = 64 * stride;

   uint32_t tile_x = x / tile_width;
   uint32_t tile_y = y / tile_height;

   /* The byte's address relative to the tile's base addres. */
   uint32_t byte_x = x % tile_width;
   uint32_t byte_y = y % tile_height;

   uintptr_t u = tile_y * row_size
               + tile_x * tile_size
               + 512 * (byte_x / 8)
               +  64 * (byte_y / 8)
               +  32 * ((byte_y / 4) % 2)
               +  16 * ((byte_x / 4) % 2)
               +   8 * ((byte_y / 2) % 2)
               +   4 * ((byte_x / 2) % 2)
               +   2 * (byte_y % 2)
               +   1 * (byte_x % 2);

   if (swizzled) {
      /* adjust for bit6 swizzling */
      if (((byte_x / 8) % 2) == 1) {
	 if (((byte_y / 8) % 2) == 0) {
	    u += 64;
	 } else {
	    u -= 64;
	 }
      }
   }

   return u;
}

void
intel_miptree_updownsample(struct brw_context *brw,
                           struct intel_mipmap_tree *src,
                           struct intel_mipmap_tree *dst)
{
   if (brw->gen < 8) {
      brw_blorp_blit_miptrees(brw,
                              src, 0 /* level */, 0 /* layer */,
                              dst, 0 /* level */, 0 /* layer */,
                              0, 0,
                              src->logical_width0, src->logical_height0,
                              0, 0,
                              dst->logical_width0, dst->logical_height0,
                              GL_NEAREST, false, false /*mirror x, y*/);
   } else if (src->format == MESA_FORMAT_S_UINT8) {
      brw_meta_stencil_updownsample(brw, src, dst);
   } else {
      brw_meta_updownsample(brw, src, dst);
   }

   if (src->stencil_mt) {
      if (brw->gen >= 8) {
         brw_meta_stencil_updownsample(brw, src->stencil_mt, dst);
         return;
      }

      brw_blorp_blit_miptrees(brw,
                              src->stencil_mt, 0 /* level */, 0 /* layer */,
                              dst->stencil_mt, 0 /* level */, 0 /* layer */,
                              0, 0,
                              src->logical_width0, src->logical_height0,
                              0, 0,
                              dst->logical_width0, dst->logical_height0,
                              GL_NEAREST, false, false /*mirror x, y*/);
   }
}

void *
intel_miptree_map_raw(struct brw_context *brw, struct intel_mipmap_tree *mt)
{
   /* CPU accesses to color buffers don't understand fast color clears, so
    * resolve any pending fast color clears before we map.
    */
   intel_miptree_resolve_color(brw, mt);

   drm_intel_bo *bo = mt->bo;

   if (drm_intel_bo_references(brw->batch.bo, bo))
      intel_batchbuffer_flush(brw);

   if (mt->tiling != I915_TILING_NONE)
      brw_bo_map_gtt(brw, bo, "miptree");
   else
      brw_bo_map(brw, bo, true, "miptree");

   return bo->virtual;
}

void
intel_miptree_unmap_raw(struct brw_context *brw,
                        struct intel_mipmap_tree *mt)
{
   drm_intel_bo_unmap(mt->bo);
}

static void
intel_miptree_map_gtt(struct brw_context *brw,
		      struct intel_mipmap_tree *mt,
		      struct intel_miptree_map *map,
		      unsigned int level, unsigned int slice)
{
   unsigned int bw, bh;
   void *base;
   unsigned int image_x, image_y;
   int x = map->x;
   int y = map->y;

   /* For compressed formats, the stride is the number of bytes per
    * row of blocks.  intel_miptree_get_image_offset() already does
    * the divide.
    */
   _mesa_get_format_block_size(mt->format, &bw, &bh);
   assert(y % bh == 0);
   y /= bh;

   base = intel_miptree_map_raw(brw, mt) + mt->offset;

   if (base == NULL)
      map->ptr = NULL;
   else {
      /* Note that in the case of cube maps, the caller must have passed the
       * slice number referencing the face.
      */
      intel_miptree_get_image_offset(mt, level, slice, &image_x, &image_y);
      x += image_x;
      y += image_y;

      map->stride = mt->pitch;
      map->ptr = base + y * map->stride + x * mt->cpp;
   }

   DBG("%s: %d,%d %dx%d from mt %p (%s) %d,%d = %p/%d\n", __FUNCTION__,
       map->x, map->y, map->w, map->h,
       mt, _mesa_get_format_name(mt->format),
       x, y, map->ptr, map->stride);
}

static void
intel_miptree_unmap_gtt(struct brw_context *brw,
			struct intel_mipmap_tree *mt,
			struct intel_miptree_map *map,
			unsigned int level,
			unsigned int slice)
{
   intel_miptree_unmap_raw(brw, mt);
}

static void
intel_miptree_map_blit(struct brw_context *brw,
		       struct intel_mipmap_tree *mt,
		       struct intel_miptree_map *map,
		       unsigned int level, unsigned int slice)
{
   map->mt = intel_miptree_create(brw, GL_TEXTURE_2D, mt->format,
                                  0, 0,
                                  map->w, map->h, 1,
                                  false, 0,
                                  INTEL_MIPTREE_TILING_NONE);
   if (!map->mt) {
      fprintf(stderr, "Failed to allocate blit temporary\n");
      goto fail;
   }
   map->stride = map->mt->pitch;

   if (!intel_miptree_blit(brw,
                           mt, level, slice,
                           map->x, map->y, false,
                           map->mt, 0, 0,
                           0, 0, false,
                           map->w, map->h, GL_COPY)) {
      fprintf(stderr, "Failed to blit\n");
      goto fail;
   }

   map->ptr = intel_miptree_map_raw(brw, map->mt);

   DBG("%s: %d,%d %dx%d from mt %p (%s) %d,%d = %p/%d\n", __FUNCTION__,
       map->x, map->y, map->w, map->h,
       mt, _mesa_get_format_name(mt->format),
       level, slice, map->ptr, map->stride);

   return;

fail:
   intel_miptree_release(&map->mt);
   map->ptr = NULL;
   map->stride = 0;
}

static void
intel_miptree_unmap_blit(struct brw_context *brw,
			 struct intel_mipmap_tree *mt,
			 struct intel_miptree_map *map,
			 unsigned int level,
			 unsigned int slice)
{
   struct gl_context *ctx = &brw->ctx;

   intel_miptree_unmap_raw(brw, map->mt);

   if (map->mode & GL_MAP_WRITE_BIT) {
      bool ok = intel_miptree_blit(brw,
                                   map->mt, 0, 0,
                                   0, 0, false,
                                   mt, level, slice,
                                   map->x, map->y, false,
                                   map->w, map->h, GL_COPY);
      WARN_ONCE(!ok, "Failed to blit from linear temporary mapping");
   }

   intel_miptree_release(&map->mt);
}

#ifdef __SSE4_1__
/**
 * "Map" a buffer by copying it to an untiled temporary using MOVNTDQA.
 */
static void
intel_miptree_map_movntdqa(struct brw_context *brw,
                           struct intel_mipmap_tree *mt,
                           struct intel_miptree_map *map,
                           unsigned int level, unsigned int slice)
{
   assert(map->mode & GL_MAP_READ_BIT);
   assert(!(map->mode & GL_MAP_WRITE_BIT));

   DBG("%s: %d,%d %dx%d from mt %p (%s) %d,%d = %p/%d\n", __FUNCTION__,
       map->x, map->y, map->w, map->h,
       mt, _mesa_get_format_name(mt->format),
       level, slice, map->ptr, map->stride);

   /* Map the original image */
   uint32_t image_x;
   uint32_t image_y;
   intel_miptree_get_image_offset(mt, level, slice, &image_x, &image_y);
   image_x += map->x;
   image_y += map->y;

   void *src = intel_miptree_map_raw(brw, mt);
   if (!src)
      return;
   src += image_y * mt->pitch;
   src += image_x * mt->cpp;

   /* Due to the pixel offsets for the particular image being mapped, our
    * src pointer may not be 16-byte aligned.  However, if the pitch is
    * divisible by 16, then the amount by which it's misaligned will remain
    * consistent from row to row.
    */
   assert((mt->pitch % 16) == 0);
   const int misalignment = ((uintptr_t) src) & 15;

   /* Create an untiled temporary buffer for the mapping. */
   const unsigned width_bytes = _mesa_format_row_stride(mt->format, map->w);

   map->stride = ALIGN(misalignment + width_bytes, 16);

   map->buffer = malloc(map->stride * map->h);
   /* Offset the destination so it has the same misalignment as src. */
   map->ptr = map->buffer + misalignment;

   assert((((uintptr_t) map->ptr) & 15) == misalignment);

   for (uint32_t y = 0; y < map->h; y++) {
      void *dst_ptr = map->ptr + y * map->stride;
      void *src_ptr = src + y * mt->pitch;

      _mesa_streaming_load_memcpy(dst_ptr, src_ptr, width_bytes);
   }

   intel_miptree_unmap_raw(brw, mt);
}

static void
intel_miptree_unmap_movntdqa(struct brw_context *brw,
                             struct intel_mipmap_tree *mt,
                             struct intel_miptree_map *map,
                             unsigned int level,
                             unsigned int slice)
{
   free(map->buffer);
   map->buffer = NULL;
   map->ptr = NULL;
}
#endif

static void
intel_miptree_map_s8(struct brw_context *brw,
		     struct intel_mipmap_tree *mt,
		     struct intel_miptree_map *map,
		     unsigned int level, unsigned int slice)
{
   map->stride = map->w;
   map->buffer = map->ptr = malloc(map->stride * map->h);
   if (!map->buffer)
      return;

   /* One of either READ_BIT or WRITE_BIT or both is set.  READ_BIT implies no
    * INVALIDATE_RANGE_BIT.  WRITE_BIT needs the original values read in unless
    * invalidate is set, since we'll be writing the whole rectangle from our
    * temporary buffer back out.
    */
   if (!(map->mode & GL_MAP_INVALIDATE_RANGE_BIT)) {
      uint8_t *untiled_s8_map = map->ptr;
      uint8_t *tiled_s8_map = intel_miptree_map_raw(brw, mt);
      unsigned int image_x, image_y;

      intel_miptree_get_image_offset(mt, level, slice, &image_x, &image_y);

      for (uint32_t y = 0; y < map->h; y++) {
	 for (uint32_t x = 0; x < map->w; x++) {
	    ptrdiff_t offset = intel_offset_S8(mt->pitch,
	                                       x + image_x + map->x,
	                                       y + image_y + map->y,
					       brw->has_swizzling);
	    untiled_s8_map[y * map->w + x] = tiled_s8_map[offset];
	 }
      }

      intel_miptree_unmap_raw(brw, mt);

      DBG("%s: %d,%d %dx%d from mt %p %d,%d = %p/%d\n", __FUNCTION__,
	  map->x, map->y, map->w, map->h,
	  mt, map->x + image_x, map->y + image_y, map->ptr, map->stride);
   } else {
      DBG("%s: %d,%d %dx%d from mt %p = %p/%d\n", __FUNCTION__,
	  map->x, map->y, map->w, map->h,
	  mt, map->ptr, map->stride);
   }
}

static void
intel_miptree_unmap_s8(struct brw_context *brw,
		       struct intel_mipmap_tree *mt,
		       struct intel_miptree_map *map,
		       unsigned int level,
		       unsigned int slice)
{
   if (map->mode & GL_MAP_WRITE_BIT) {
      unsigned int image_x, image_y;
      uint8_t *untiled_s8_map = map->ptr;
      uint8_t *tiled_s8_map = intel_miptree_map_raw(brw, mt);

      intel_miptree_get_image_offset(mt, level, slice, &image_x, &image_y);

      for (uint32_t y = 0; y < map->h; y++) {
	 for (uint32_t x = 0; x < map->w; x++) {
	    ptrdiff_t offset = intel_offset_S8(mt->pitch,
	                                       x + map->x,
	                                       y + map->y,
					       brw->has_swizzling);
	    tiled_s8_map[offset] = untiled_s8_map[y * map->w + x];
	 }
      }

      intel_miptree_unmap_raw(brw, mt);
   }

   free(map->buffer);
}

static void
intel_miptree_map_etc(struct brw_context *brw,
                      struct intel_mipmap_tree *mt,
                      struct intel_miptree_map *map,
                      unsigned int level,
                      unsigned int slice)
{
   assert(mt->etc_format != MESA_FORMAT_NONE);
   if (mt->etc_format == MESA_FORMAT_ETC1_RGB8) {
      assert(mt->format == MESA_FORMAT_R8G8B8X8_UNORM);
   }

   assert(map->mode & GL_MAP_WRITE_BIT);
   assert(map->mode & GL_MAP_INVALIDATE_RANGE_BIT);

   map->stride = _mesa_format_row_stride(mt->etc_format, map->w);
   map->buffer = malloc(_mesa_format_image_size(mt->etc_format,
                                                map->w, map->h, 1));
   map->ptr = map->buffer;
}

static void
intel_miptree_unmap_etc(struct brw_context *brw,
                        struct intel_mipmap_tree *mt,
                        struct intel_miptree_map *map,
                        unsigned int level,
                        unsigned int slice)
{
   uint32_t image_x;
   uint32_t image_y;
   intel_miptree_get_image_offset(mt, level, slice, &image_x, &image_y);

   image_x += map->x;
   image_y += map->y;

   uint8_t *dst = intel_miptree_map_raw(brw, mt)
                + image_y * mt->pitch
                + image_x * mt->cpp;

   if (mt->etc_format == MESA_FORMAT_ETC1_RGB8)
      _mesa_etc1_unpack_rgba8888(dst, mt->pitch,
                                 map->ptr, map->stride,
                                 map->w, map->h);
   else
      _mesa_unpack_etc2_format(dst, mt->pitch,
                               map->ptr, map->stride,
                               map->w, map->h, mt->etc_format);

   intel_miptree_unmap_raw(brw, mt);
   free(map->buffer);
}

/**
 * Mapping function for packed depth/stencil miptrees backed by real separate
 * miptrees for depth and stencil.
 *
 * On gen7, and to support HiZ pre-gen7, we have to have the stencil buffer
 * separate from the depth buffer.  Yet at the GL API level, we have to expose
 * packed depth/stencil textures and FBO attachments, and Mesa core expects to
 * be able to map that memory for texture storage and glReadPixels-type
 * operations.  We give Mesa core that access by mallocing a temporary and
 * copying the data between the actual backing store and the temporary.
 */
static void
intel_miptree_map_depthstencil(struct brw_context *brw,
			       struct intel_mipmap_tree *mt,
			       struct intel_miptree_map *map,
			       unsigned int level, unsigned int slice)
{
   struct intel_mipmap_tree *z_mt = mt;
   struct intel_mipmap_tree *s_mt = mt->stencil_mt;
   bool map_z32f_x24s8 = mt->format == MESA_FORMAT_Z_FLOAT32;
   int packed_bpp = map_z32f_x24s8 ? 8 : 4;

   map->stride = map->w * packed_bpp;
   map->buffer = map->ptr = malloc(map->stride * map->h);
   if (!map->buffer)
      return;

   /* One of either READ_BIT or WRITE_BIT or both is set.  READ_BIT implies no
    * INVALIDATE_RANGE_BIT.  WRITE_BIT needs the original values read in unless
    * invalidate is set, since we'll be writing the whole rectangle from our
    * temporary buffer back out.
    */
   if (!(map->mode & GL_MAP_INVALIDATE_RANGE_BIT)) {
      uint32_t *packed_map = map->ptr;
      uint8_t *s_map = intel_miptree_map_raw(brw, s_mt);
      uint32_t *z_map = intel_miptree_map_raw(brw, z_mt);
      unsigned int s_image_x, s_image_y;
      unsigned int z_image_x, z_image_y;

      intel_miptree_get_image_offset(s_mt, level, slice,
				     &s_image_x, &s_image_y);
      intel_miptree_get_image_offset(z_mt, level, slice,
				     &z_image_x, &z_image_y);

      for (uint32_t y = 0; y < map->h; y++) {
	 for (uint32_t x = 0; x < map->w; x++) {
	    int map_x = map->x + x, map_y = map->y + y;
	    ptrdiff_t s_offset = intel_offset_S8(s_mt->pitch,
						 map_x + s_image_x,
						 map_y + s_image_y,
						 brw->has_swizzling);
	    ptrdiff_t z_offset = ((map_y + z_image_y) *
                                  (z_mt->pitch / 4) +
				  (map_x + z_image_x));
	    uint8_t s = s_map[s_offset];
	    uint32_t z = z_map[z_offset];

	    if (map_z32f_x24s8) {
	       packed_map[(y * map->w + x) * 2 + 0] = z;
	       packed_map[(y * map->w + x) * 2 + 1] = s;
	    } else {
	       packed_map[y * map->w + x] = (s << 24) | (z & 0x00ffffff);
	    }
	 }
      }

      intel_miptree_unmap_raw(brw, s_mt);
      intel_miptree_unmap_raw(brw, z_mt);

      DBG("%s: %d,%d %dx%d from z mt %p %d,%d, s mt %p %d,%d = %p/%d\n",
	  __FUNCTION__,
	  map->x, map->y, map->w, map->h,
	  z_mt, map->x + z_image_x, map->y + z_image_y,
	  s_mt, map->x + s_image_x, map->y + s_image_y,
	  map->ptr, map->stride);
   } else {
      DBG("%s: %d,%d %dx%d from mt %p = %p/%d\n", __FUNCTION__,
	  map->x, map->y, map->w, map->h,
	  mt, map->ptr, map->stride);
   }
}

static void
intel_miptree_unmap_depthstencil(struct brw_context *brw,
				 struct intel_mipmap_tree *mt,
				 struct intel_miptree_map *map,
				 unsigned int level,
				 unsigned int slice)
{
   struct intel_mipmap_tree *z_mt = mt;
   struct intel_mipmap_tree *s_mt = mt->stencil_mt;
   bool map_z32f_x24s8 = mt->format == MESA_FORMAT_Z_FLOAT32;

   if (map->mode & GL_MAP_WRITE_BIT) {
      uint32_t *packed_map = map->ptr;
      uint8_t *s_map = intel_miptree_map_raw(brw, s_mt);
      uint32_t *z_map = intel_miptree_map_raw(brw, z_mt);
      unsigned int s_image_x, s_image_y;
      unsigned int z_image_x, z_image_y;

      intel_miptree_get_image_offset(s_mt, level, slice,
				     &s_image_x, &s_image_y);
      intel_miptree_get_image_offset(z_mt, level, slice,
				     &z_image_x, &z_image_y);

      for (uint32_t y = 0; y < map->h; y++) {
	 for (uint32_t x = 0; x < map->w; x++) {
	    ptrdiff_t s_offset = intel_offset_S8(s_mt->pitch,
						 x + s_image_x + map->x,
						 y + s_image_y + map->y,
						 brw->has_swizzling);
	    ptrdiff_t z_offset = ((y + z_image_y + map->y) *
                                  (z_mt->pitch / 4) +
				  (x + z_image_x + map->x));

	    if (map_z32f_x24s8) {
	       z_map[z_offset] = packed_map[(y * map->w + x) * 2 + 0];
	       s_map[s_offset] = packed_map[(y * map->w + x) * 2 + 1];
	    } else {
	       uint32_t packed = packed_map[y * map->w + x];
	       s_map[s_offset] = packed >> 24;
	       z_map[z_offset] = packed;
	    }
	 }
      }

      intel_miptree_unmap_raw(brw, s_mt);
      intel_miptree_unmap_raw(brw, z_mt);

      DBG("%s: %d,%d %dx%d from z mt %p (%s) %d,%d, s mt %p %d,%d = %p/%d\n",
	  __FUNCTION__,
	  map->x, map->y, map->w, map->h,
	  z_mt, _mesa_get_format_name(z_mt->format),
	  map->x + z_image_x, map->y + z_image_y,
	  s_mt, map->x + s_image_x, map->y + s_image_y,
	  map->ptr, map->stride);
   }

   free(map->buffer);
}

/**
 * Create and attach a map to the miptree at (level, slice). Return the
 * attached map.
 */
static struct intel_miptree_map*
intel_miptree_attach_map(struct intel_mipmap_tree *mt,
                         unsigned int level,
                         unsigned int slice,
                         unsigned int x,
                         unsigned int y,
                         unsigned int w,
                         unsigned int h,
                         GLbitfield mode)
{
   struct intel_miptree_map *map = calloc(1, sizeof(*map));

   if (!map)
      return NULL;

   assert(mt->level[level].slice[slice].map == NULL);
   mt->level[level].slice[slice].map = map;

   map->mode = mode;
   map->x = x;
   map->y = y;
   map->w = w;
   map->h = h;

   return map;
}

/**
 * Release the map at (level, slice).
 */
static void
intel_miptree_release_map(struct intel_mipmap_tree *mt,
                         unsigned int level,
                         unsigned int slice)
{
   struct intel_miptree_map **map;

   map = &mt->level[level].slice[slice].map;
   free(*map);
   *map = NULL;
}

static bool
can_blit_slice(struct intel_mipmap_tree *mt,
               unsigned int level, unsigned int slice)
{
   uint32_t image_x;
   uint32_t image_y;
   intel_miptree_get_image_offset(mt, level, slice, &image_x, &image_y);
   if (image_x >= 32768 || image_y >= 32768)
      return false;

   if (mt->pitch >= 32768)
      return false;

   return true;
}

void
intel_miptree_map(struct brw_context *brw,
                  struct intel_mipmap_tree *mt,
                  unsigned int level,
                  unsigned int slice,
                  unsigned int x,
                  unsigned int y,
                  unsigned int w,
                  unsigned int h,
                  GLbitfield mode,
                  void **out_ptr,
                  int *out_stride)
{
   struct intel_miptree_map *map;

   assert(mt->num_samples <= 1);

   map = intel_miptree_attach_map(mt, level, slice, x, y, w, h, mode);
   if (!map){
      *out_ptr = NULL;
      *out_stride = 0;
      return;
   }

   intel_miptree_slice_resolve_depth(brw, mt, level, slice);
   if (map->mode & GL_MAP_WRITE_BIT) {
      intel_miptree_slice_set_needs_hiz_resolve(mt, level, slice);
   }

   if (mt->format == MESA_FORMAT_S_UINT8) {
      intel_miptree_map_s8(brw, mt, map, level, slice);
   } else if (mt->etc_format != MESA_FORMAT_NONE &&
              !(mode & BRW_MAP_DIRECT_BIT)) {
      intel_miptree_map_etc(brw, mt, map, level, slice);
   } else if (mt->stencil_mt && !(mode & BRW_MAP_DIRECT_BIT)) {
      intel_miptree_map_depthstencil(brw, mt, map, level, slice);
   }
   /* See intel_miptree_blit() for details on the 32k pitch limit. */
   else if (brw->has_llc &&
            !(mode & GL_MAP_WRITE_BIT) &&
            !mt->compressed &&
            (mt->tiling == I915_TILING_X ||
             (brw->gen >= 6 && mt->tiling == I915_TILING_Y)) &&
            can_blit_slice(mt, level, slice)) {
      intel_miptree_map_blit(brw, mt, map, level, slice);
   } else if (mt->tiling != I915_TILING_NONE &&
              mt->bo->size >= brw->max_gtt_map_object_size) {
      assert(can_blit_slice(mt, level, slice));
      intel_miptree_map_blit(brw, mt, map, level, slice);
#ifdef __SSE4_1__
   } else if (!(mode & GL_MAP_WRITE_BIT) && !mt->compressed) {
      intel_miptree_map_movntdqa(brw, mt, map, level, slice);
#endif
   } else {
      intel_miptree_map_gtt(brw, mt, map, level, slice);
   }

   *out_ptr = map->ptr;
   *out_stride = map->stride;

   if (map->ptr == NULL)
      intel_miptree_release_map(mt, level, slice);
}

void
intel_miptree_unmap(struct brw_context *brw,
                    struct intel_mipmap_tree *mt,
                    unsigned int level,
                    unsigned int slice)
{
   struct intel_miptree_map *map = mt->level[level].slice[slice].map;

   assert(mt->num_samples <= 1);

   if (!map)
      return;

   DBG("%s: mt %p (%s) level %d slice %d\n", __FUNCTION__,
       mt, _mesa_get_format_name(mt->format), level, slice);

   if (mt->format == MESA_FORMAT_S_UINT8) {
      intel_miptree_unmap_s8(brw, mt, map, level, slice);
   } else if (mt->etc_format != MESA_FORMAT_NONE &&
              !(map->mode & BRW_MAP_DIRECT_BIT)) {
      intel_miptree_unmap_etc(brw, mt, map, level, slice);
   } else if (mt->stencil_mt && !(map->mode & BRW_MAP_DIRECT_BIT)) {
      intel_miptree_unmap_depthstencil(brw, mt, map, level, slice);
   } else if (map->mt) {
      intel_miptree_unmap_blit(brw, mt, map, level, slice);
#ifdef __SSE4_1__
   } else if (map->buffer) {
      intel_miptree_unmap_movntdqa(brw, mt, map, level, slice);
#endif
   } else {
      intel_miptree_unmap_gtt(brw, mt, map, level, slice);
   }

   intel_miptree_release_map(mt, level, slice);
}
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d32 1
a48 1
#include "x86/common_x86_asm.h"
d138 1
a138 1
      unreachable("Non-MSRT MCS requires X or Y tiling");
d171 1
a171 1
   if (brw->gen < 7)
d234 1
a234 2
                            GLuint num_samples,
                            bool force_all_slices_at_each_lod)
a272 1
   exec_list_make_empty(&mt->hiz_map);
d343 1
a343 1
            unreachable("not reached");
d351 2
a352 3
   /* Set array_layout to ALL_SLICES_AT_EACH_LOD when gen7+ array_spacing_lod0
    * can be used. array_spacing_lod0 is only used for non-IMS MSAA surfaces.
    * TODO: can we use it elsewhere?
d357 1
a357 1
      mt->array_layout = ALL_LOD_IN_EACH_SLICE;
d361 1
a361 1
      mt->array_layout = ALL_SLICES_AT_EACH_LOD;
a377 1
      const bool force_all_slices_at_each_lod = brw->gen == 6;
d388 1
a388 2
                                            INTEL_MIPTREE_TILING_ANY,
                                            force_all_slices_at_each_lod);
a405 3
   if (force_all_slices_at_each_lod)
      mt->array_layout = ALL_SLICES_AT_EACH_LOD;

d560 1
a560 2
                     enum intel_miptree_tiling_mode requested_tiling,
                     bool force_all_slices_at_each_lod)
d574 1
a574 2
                                    false, num_samples,
                                    force_all_slices_at_each_lod);
d685 1
a685 1
                                    true, 0, false);
d794 1
a794 1
                             INTEL_MIPTREE_TILING_ANY, false);
d1008 1
a1008 1
      unreachable("not reached");
d1052 1
a1052 1
      unreachable("not reached");
d1278 2
a1279 1
      unreachable("Unrecognized sample count in intel_miptree_alloc_mcs");
d1296 1
a1296 2
                                     INTEL_MIPTREE_TILING_Y,
                                     false);
d1353 1
a1353 2
                                     INTEL_MIPTREE_TILING_Y,
                                     false);
d1361 1
a1361 1
 * \c mt->level[level].has_hiz. Return true if and only if
d1365 1
a1365 1
intel_miptree_level_enable_hiz(struct brw_context *brw,
d1367 2
a1368 1
                               uint32_t level)
a1382 1
         DBG("mt %p level %d: HiZ DISABLED\n", mt, level);
d1387 1
a1387 2
   DBG("mt %p level %d: HiZ enabled\n", mt, level);
   mt->level[level].has_hiz = true;
a1397 1
   const bool force_all_slices_at_each_lod = brw->gen == 6;
d1408 1
a1408 2
                                     INTEL_MIPTREE_TILING_ANY,
                                     force_all_slices_at_each_lod);
d1414 1
a1415 3
      if (!intel_miptree_level_enable_hiz(brw, mt, level))
         continue;

d1417 2
a1418 5
         struct intel_resolve_map *m = malloc(sizeof(struct intel_resolve_map));
         exec_node_init(&m->link);
         m->level = level;
         m->layer = layer;
         m->need = GEN6_HIZ_OP_HIZ_RESOLVE;
d1420 8
a1427 1
         exec_list_push_tail(&mt->hiz_map, &m->link);
d1438 3
a1440 1
intel_miptree_level_has_hiz(struct intel_mipmap_tree *mt, uint32_t level)
d1442 2
a1443 2
   intel_miptree_check_level_layer(mt, level, 0);
   return mt->level[level].has_hiz;
d1451 1
a1451 1
   if (!intel_miptree_level_has_hiz(mt, level))
d1464 1
a1464 1
   if (!intel_miptree_level_has_hiz(mt, level))
d1529 1
d1531 3
a1533 2
   foreach_list_typed_safe(struct intel_resolve_map, map, link, &mt->hiz_map) {
      if (map->need != need)
d1536 2
a1537 2
      intel_hiz_exec(brw, mt, map->level, map->layer, need);
      intel_resolve_map_remove(map);
d1574 1
a1574 1
         brw_meta_resolve_color(brw, mt);
d1671 2
a1672 2
                              src, 0 /* level */, 0 /* layer */, src->format,
                              dst, 0 /* level */, 0 /* layer */, dst->format,
a1691 1
                              src->stencil_mt->format,
a1692 1
                              dst->stencil_mt->format,
d1738 2
a1739 2
   intptr_t x = map->x;
   intptr_t y = map->y;
d1765 1
a1765 2
   DBG("%s: %d,%d %dx%d from mt %p (%s) "
       "%"PRIiPTR",%"PRIiPTR" = %p/%d\n", __FUNCTION__,
d1791 1
a1791 2
                                  INTEL_MIPTREE_TILING_NONE,
                                  false);
d1847 1
a1850 1
#if defined(USE_SSE41)
d1891 1
a1891 1
   map->buffer = _mesa_align_malloc(map->stride * map->h, 16);
d1914 1
a1914 1
   _mesa_align_free(map->buffer);
d2299 2
a2300 2
#if defined(USE_SSE41)
   } else if (!(mode & GL_MAP_WRITE_BIT) && !mt->compressed && cpu_has_sse4_1) {
d2339 2
a2340 2
#if defined(USE_SSE41)
   } else if (map->buffer && cpu_has_sse4_1) {
@


1.6
log
@Merge Mesa 10.2.7
@
text
@a31 1
#include "intel_chipset.h"
d48 1
d138 1
a138 1
      assert(!"Non-MSRT MCS requires X or Y tiling");
d171 1
a171 1
   if (brw->gen < 7 || brw->gen >= 8)
d234 2
a235 1
                            GLuint num_samples)
d274 1
d345 1
a345 1
            assert(false);
d353 3
a355 2
   /* array_spacing_lod0 is only used for non-IMS MSAA surfaces.  TODO: can we
    * use it elsewhere?
d360 1
a360 1
      mt->array_spacing_lod0 = false;
d364 1
a364 1
      mt->array_spacing_lod0 = true;
d381 1
d392 2
a393 1
                                            INTEL_MIPTREE_TILING_ANY);
d411 3
d568 2
a569 1
                     enum intel_miptree_tiling_mode requested_tiling)
d583 2
a584 1
				      false, num_samples);
d695 1
a695 1
                                    true, 0 /* num_samples */);
d804 1
a804 1
                             INTEL_MIPTREE_TILING_ANY);
d1018 1
a1018 1
      assert(false);
d1062 1
a1062 1
      assert(false);
d1288 1
a1288 2
      assert(!"Unrecognized sample count in intel_miptree_alloc_mcs");
      return false;
d1305 2
a1306 1
                                     INTEL_MIPTREE_TILING_Y);
d1363 2
a1364 1
                                     INTEL_MIPTREE_TILING_Y);
d1372 1
a1372 1
 * \c mt->level[level].slice[layer].has_hiz. Return true if and only if
d1376 1
a1376 1
intel_miptree_slice_enable_hiz(struct brw_context *brw,
d1378 1
a1378 2
                               uint32_t level,
                               uint32_t layer)
d1393 1
d1398 2
a1399 1
   mt->level[level].slice[layer].has_hiz = true;
d1410 1
d1421 2
a1422 1
                                     INTEL_MIPTREE_TILING_ANY);
a1427 1
   struct intel_resolve_map *head = &mt->hiz_map;
d1429 3
d1433 5
a1437 2
         if (!intel_miptree_slice_enable_hiz(brw, mt, level, layer))
            continue;
d1439 1
a1439 8
	 head->next = malloc(sizeof(*head->next));
	 head->next->prev = head;
	 head->next->next = NULL;
	 head = head->next;

	 head->level = level;
	 head->layer = layer;
	 head->need = GEN6_HIZ_OP_HIZ_RESOLVE;
d1450 1
a1450 3
intel_miptree_slice_has_hiz(struct intel_mipmap_tree *mt,
                            uint32_t level,
                            uint32_t layer)
d1452 2
a1453 2
   intel_miptree_check_level_layer(mt, level, layer);
   return mt->level[level].slice[layer].has_hiz;
d1461 1
a1461 1
   if (!intel_miptree_slice_has_hiz(mt, level, layer))
d1474 1
a1474 1
   if (!intel_miptree_slice_has_hiz(mt, level, layer))
a1538 1
   struct intel_resolve_map *i, *next;
d1540 2
a1541 3
   for (i = mt->hiz_map.next; i; i = next) {
      next = i->next;
      if (i->need != need)
d1544 2
a1545 2
      intel_hiz_exec(brw, mt, i->level, i->layer, need);
      intel_resolve_map_remove(i);
d1582 1
a1582 1
         brw_blorp_resolve_color(brw, mt);
d1679 2
a1680 2
                              src, 0 /* level */, 0 /* layer */,
                              dst, 0 /* level */, 0 /* layer */,
d1700 1
d1702 1
d1748 2
a1749 2
   int x = map->x;
   int y = map->y;
d1775 2
a1776 1
   DBG("%s: %d,%d %dx%d from mt %p (%s) %d,%d = %p/%d\n", __FUNCTION__,
d1802 2
a1803 1
                                  INTEL_MIPTREE_TILING_NONE);
a1858 1
#ifdef __SSE4_1__
d1862 1
d1903 1
a1903 1
   map->buffer = malloc(map->stride * map->h);
d1926 1
a1926 1
   free(map->buffer);
d2311 2
a2312 2
#ifdef __SSE4_1__
   } else if (!(mode & GL_MAP_WRITE_BIT) && !mt->compressed) {
d2351 2
a2352 2
#ifdef __SSE4_1__
   } else if (map->buffer) {
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a69 8
      /* Disable MCS on Broadwell for now.  We can enable it once things
       * are working without it.
       */
      if (brw->gen >= 8) {
         perf_debug("Missing CMS support on Broadwell.\n");
         return INTEL_MSAA_LAYOUT_UMS;
      }

d81 1
a81 3
      if (_mesa_get_format_datatype(format) == GL_INT) {
         /* TODO: is this workaround needed for future chipsets? */
         assert(brw->gen == 7);
d245 20
d1264 1
d2158 1
a2158 1
	    ptrdiff_t z_offset = ((y + z_image_y) *
d2160 1
a2160 1
				  (x + z_image_x));
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d2 2
a3 2
 * 
 * Copyright 2006 Tungsten Graphics, Inc., Cedar Park, Texas.
d5 1
a5 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
 * 
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d25 1
a25 1
 * 
a33 1
#include "intel_regions.h"
d37 1
d43 1
d48 1
a51 17
static GLenum
target_to_target(GLenum target)
{
   switch (target) {
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
      return GL_TEXTURE_CUBE_MAP_ARB;
   default:
      return target;
   }
}


d57 1
a57 1
compute_msaa_layout(struct brw_context *brw, gl_format format, GLenum target)
d70 8
d94 1
a94 17
         /* For now, if we're going to be texturing from this surface,
          * force UMS, so that the shader doesn't have to do different things
          * based on whether there's a multisample control surface needing sampled first.
          * We can't just blindly read the MCS surface in all cases because:
          *
          * From the Ivy Bridge PRM, Vol4 Part1 p77 ("MCS Enable"):
          *
          *    If this field is disabled and the sampling engine <ld_mcs> message
          *    is issued on this surface, the MCS surface may be accessed. Software
          *    must ensure that the surface is defined to avoid GTT errors.
          */
         if (target == GL_TEXTURE_2D_MULTISAMPLE ||
             target == GL_TEXTURE_2D_MULTISAMPLE_ARRAY) {
            return INTEL_MSAA_LAYOUT_UMS;
         } else {
            return INTEL_MSAA_LAYOUT_CMS;
         }
d146 1
a146 1
   switch (mt->region->tiling) {
d181 1
a181 1
   if (brw->gen < 7)
d192 2
a193 2
   if (mt->region->tiling != I915_TILING_X &&
       mt->region->tiling != I915_TILING_Y)
d213 17
d237 1
a237 1
                            gl_format format,
d250 1
a250 1
   DBG("%s target %s format %s level %d..%d <-- %p\n", __FUNCTION__,
d253 1
a253 1
       first_level, last_level, mt);
d255 1
a255 1
   mt->target = target_to_target(target);
d262 1
a262 1
   mt->mcs_state = INTEL_MCS_STATE_NONE;
d275 1
a275 1
   mt->refcount = 1; 
d316 5
d330 1
a330 1
            /* num_samples should already have been quantized to 0, 1, 4, or
d370 1
a370 1
                                            MESA_FORMAT_S8,
d387 6
a392 8
      if (mt->format == MESA_FORMAT_S8_Z24) {
	 mt->format = MESA_FORMAT_X8_Z24;
      } else if (mt->format == MESA_FORMAT_Z32_FLOAT_X24S8) {
	 mt->format = MESA_FORMAT_Z32_FLOAT;
	 mt->cpp = 4;
      } else {
	 _mesa_problem(NULL, "Unknown format %s in separate stencil mt\n",
		       _mesa_get_format_name(mt->format));
d406 1
a406 1
                            gl_format format,
d412 1
a412 1
   if (format == MESA_FORMAT_S8) {
d458 2
a459 1
   if (ALIGN(minimum_pitch, 512) >= 32768) {
d478 17
d498 41
d542 1
a542 1
		     gl_format format,
d553 2
a554 2
   gl_format tex_format = format;
   gl_format etc_format = MESA_FORMAT_NONE;
d557 1
a557 34
   if (!brw->is_baytrail) {
      switch (format) {
      case MESA_FORMAT_ETC1_RGB8:
         format = MESA_FORMAT_RGBX8888_REV;
         break;
      case MESA_FORMAT_ETC2_RGB8:
         format = MESA_FORMAT_RGBX8888_REV;
         break;
      case MESA_FORMAT_ETC2_SRGB8:
      case MESA_FORMAT_ETC2_SRGB8_ALPHA8_EAC:
      case MESA_FORMAT_ETC2_SRGB8_PUNCHTHROUGH_ALPHA1:
         format = MESA_FORMAT_SARGB8;
         break;
      case MESA_FORMAT_ETC2_RGBA8_EAC:
      case MESA_FORMAT_ETC2_RGB8_PUNCHTHROUGH_ALPHA1:
         format = MESA_FORMAT_RGBA8888_REV;
         break;
      case MESA_FORMAT_ETC2_R11_EAC:
         format = MESA_FORMAT_R16;
         break;
      case MESA_FORMAT_ETC2_SIGNED_R11_EAC:
         format = MESA_FORMAT_SIGNED_R16;
         break;
      case MESA_FORMAT_ETC2_RG11_EAC:
         format = MESA_FORMAT_GR1616;
         break;
      case MESA_FORMAT_ETC2_SIGNED_RG11_EAC:
         format = MESA_FORMAT_SIGNED_GR1616;
         break;
      default:
         /* Non ETC1 / ETC2 format */
         break;
      }
   }
d576 1
a576 1
   if (format == MESA_FORMAT_S8) {
d585 1
a585 1
   bool y_or_x = tiling == (I915_TILING_Y | I915_TILING_X);
d587 8
d596 6
a601 6
   mt->region = intel_region_alloc(brw->intelScreen,
				   y_or_x ? I915_TILING_Y : tiling,
				   mt->cpp,
				   total_width,
				   total_height,
				   expect_accelerated_upload);
d603 1
a603 1
   /* If the region is too large to fit in the aperture, we need to use the
d607 1
a607 1
   if (y_or_x && mt->region->bo->size >= brw->max_gtt_map_object_size) {
a609 1
      intel_region_release(&mt->region);
d611 8
a618 6
      mt->region = intel_region_alloc(brw->intelScreen,
                                      I915_TILING_X,
                                      mt->cpp,
                                      total_width,
                                      total_height,
                                      expect_accelerated_upload);
d623 1
a623 1
   if (!mt->region) {
d628 8
d637 1
a637 1
    * mcs_state appropriately to ensure that fast clears will occur.
d642 1
a642 1
      mt->mcs_state = INTEL_MCS_STATE_RESOLVED;
d650 1
a650 1
                            gl_format format,
d654 1
a654 2
                            int pitch,
                            uint32_t tiling)
d657 1
d659 1
a659 3
   struct intel_region *region = calloc(1, sizeof(*region));
   if (!region)
      return NULL;
d676 2
a677 1
   if (!mt)
d679 1
a680 5
   region->cpp = mt->cpp;
   region->width = width;
   region->height = height;
   region->pitch = pitch;
   region->refcount = 1;
d682 2
a683 4
   region->bo = bo;
   region->tiling = tiling;

   mt->region = region;
d685 1
a689 1

d691 2
a692 1
 * For a singlesample DRI2 buffer, this simply wraps the given region with a miptree.
d694 5
a698 3
 * For a multisample DRI2 buffer, this wraps the given region with
 * a singlesample miptree, then creates a multisample miptree into which the
 * singlesample miptree is embedded as a child.
d700 6
a705 6
struct intel_mipmap_tree*
intel_miptree_create_for_dri2_buffer(struct brw_context *brw,
                                     unsigned dri_attachment,
                                     gl_format format,
                                     uint32_t num_samples,
                                     struct intel_region *region)
d709 3
d713 2
a714 2
   /* Only the front and back buffers, which are color buffers, are shared
    * through DRI2.
a715 3
   assert(dri_attachment == __DRI_BUFFER_BACK_LEFT ||
          dri_attachment == __DRI_BUFFER_FRONT_LEFT ||
          dri_attachment == __DRI_BUFFER_FAKE_FRONT_LEFT);
d719 2
a720 2
   singlesample_mt = intel_miptree_create_for_bo(brw,
                                                 region->bo,
d723 3
a725 4
                                                 region->width,
                                                 region->height,
                                                 region->pitch,
                                                 region->tiling);
d727 1
a727 2
      return NULL;
   singlesample_mt->region->name = region->name;
d734 2
a735 2
   if (intel_is_non_msrt_mcs_buffer_supported(brw, singlesample_mt))
      singlesample_mt->mcs_state = INTEL_MCS_STATE_RESOLVED;
d737 3
a739 2
   if (num_samples == 0)
      return singlesample_mt;
d741 4
a744 9
   multisample_mt = intel_miptree_create_for_renderbuffer(brw,
                                                          format,
                                                          region->width,
                                                          region->height,
                                                          num_samples);
   if (!multisample_mt) {
      intel_miptree_release(&singlesample_mt);
      return NULL;
   }
d746 15
a760 7
   multisample_mt->singlesample_mt = singlesample_mt;
   multisample_mt->need_downsample = false;

   if (brw->is_front_buffer_rendering &&
       (dri_attachment == __DRI_BUFFER_FRONT_LEFT ||
        dri_attachment == __DRI_BUFFER_FAKE_FRONT_LEFT)) {
      intel_miptree_upsample(brw, multisample_mt);
d762 1
d764 4
a767 1
   return multisample_mt;
d772 1
a772 1
                                      gl_format format,
d780 1
d782 1
a782 1
   mt = intel_miptree_create(brw, GL_TEXTURE_2D, format, 0, 0,
a793 6
   if (mt->msaa_layout == INTEL_MSAA_LAYOUT_CMS) {
      ok = intel_miptree_alloc_mcs(brw, mt, num_samples);
      if (!ok)
         goto fail;
   }

d831 1
a831 1
      intel_region_release(&((*mt)->region));
a834 1
      intel_miptree_release(&(*mt)->singlesample_mt);
d882 1
a882 1
   assert(target_to_target(image->TexObject->Target) == mt->target);
d884 5
a888 5
   gl_format mt_format = mt->format;
   if (mt->format == MESA_FORMAT_X8_Z24 && mt->stencil_mt)
      mt_format = MESA_FORMAT_S8_Z24;
   if (mt->format == MESA_FORMAT_Z32_FLOAT && mt->stencil_mt)
      mt_format = MESA_FORMAT_Z32_FLOAT_X24S8;
d900 13
d917 4
a920 18
   if (mt->target == GL_TEXTURE_2D_MULTISAMPLE ||
         mt->target == GL_TEXTURE_2D_MULTISAMPLE_ARRAY) {
      /* nonzero level here is always bogus */
      assert(level == 0);

      if (width != mt->logical_width0 ||
            height != mt->logical_height0 ||
            depth != mt->logical_depth0) {
         return false;
      }
   }
   else {
      /* all normal textures, renderbuffers, etc */
      if (width != mt->level[level].width ||
          height != mt->level[level].height ||
          depth != mt->level[level].depth) {
         return false;
      }
d933 1
a933 2
			     GLuint x, GLuint y,
			     GLuint w, GLuint h, GLuint d)
a934 2
   mt->level[level].width = w;
   mt->level[level].height = h;
d939 2
a940 2
   DBG("%s level %d size: %d,%d,%d offset %d,%d\n", __FUNCTION__,
       level, w, h, d, x, y);
d970 1
a970 1
intel_miptree_get_image_offset(struct intel_mipmap_tree *mt,
d981 76
d1067 1
a1067 1
intel_miptree_get_tile_offsets(struct intel_mipmap_tree *mt,
a1071 1
   struct intel_region *region = mt->region;
d1075 1
a1075 1
   intel_region_get_tile_masks(region, &mask_x, &mask_y, false);
d1081 1
a1081 2
   return intel_region_get_aligned_offset(region, x & ~mask_x, y & ~mask_y,
                                          false);
d1155 3
a1157 3
   gl_format format = src_mt->format;
   uint32_t width = src_mt->level[level].width;
   uint32_t height = src_mt->level[level].height;
d1191 1
a1191 1
       src_mt, src_x, src_y, src_mt->region->pitch,
d1193 1
a1193 1
       dst_mt, dst_x, dst_y, dst_mt->region->pitch,
d1252 1
a1252 1
   gl_format format;
d1258 1
a1258 1
      format = MESA_FORMAT_R8;
a1274 1
   mt->mcs_state = INTEL_MCS_STATE_MSAA;
d1298 1
a1298 1
   memset(data, 0xff, mt->mcs_mt->region->bo->size);
d1300 1
d1321 1
a1321 1
   const gl_format format = MESA_FORMAT_R_UINT32;
d1361 9
a1369 20
   if (brw->is_haswell) {
      /* Disable HiZ for some slices to work around a hardware bug.
       *
       * Haswell hardware fails to respect
       * 3DSTATE_DEPTH_BUFFER.Depth_Coordinate_Offset_X/Y when during HiZ
       * ambiguate operations.  The failure is inconsistent and affected by
       * other GPU contexts. Running a heavy GPU workload in a separate
       * process causes the failure rate to drop to nearly 0.
       *
       * To workaround the bug, we enable HiZ only when we can guarantee that
       * the Depth Coordinate Offset fields will be set to 0. The function
       * brw_get_depthstencil_tile_masks() is used to calculate the fields,
       * and the function is sometimes called in such a way that the presence
       * of an attached stencil buffer changes the fuction's return value.
       *
       * The largest tile size considered by brw_get_depthstencil_tile_masks()
       * is that of the stencil buffer. Therefore, if this hiz slice's
       * corresponding depth slice has an offset that is aligned to the
       * stencil buffer tile size, 64x64 pixels, then
       * 3DSTATE_DEPTH_BUFFER.Depth_Coordinate_Offset_X/Y is set to 0.
d1371 1
a1371 3
      uint32_t depth_x_offset = mt->level[level].slice[layer].x_offset;
      uint32_t depth_y_offset = mt->level[level].slice[layer].y_offset;
      if ((depth_x_offset & 63) || (depth_y_offset & 63)) {
d1460 12
d1554 3
a1556 4
   switch (mt->mcs_state) {
   case INTEL_MCS_STATE_NONE:
   case INTEL_MCS_STATE_MSAA:
   case INTEL_MCS_STATE_RESOLVED:
d1559 5
a1563 3
   case INTEL_MCS_STATE_UNRESOLVED:
   case INTEL_MCS_STATE_CLEAR:
      brw_blorp_resolve_color(brw, mt);
d1570 1
a1570 1
 * Make it possible to share the region backing the given miptree with another
d1574 3
a1576 3
 * then discard the MCS buffer, if present.  We also set the mcs_state to
 * INTEL_MCS_STATE_NONE to ensure that no MCS buffer gets allocated in the
 * future.
d1592 1
a1592 1
      mt->mcs_state = INTEL_MCS_STATE_NONE;
d1653 1
a1653 1
static void
d1656 16
a1671 17
                           struct intel_mipmap_tree *dst,
                           unsigned width,
                           unsigned height)
{
   int src_x0 = 0;
   int src_y0 = 0;
   int dst_x0 = 0;
   int dst_y0 = 0;

   brw_blorp_blit_miptrees(brw,
                           src, 0 /* level */, 0 /* layer */,
                           dst, 0 /* level */, 0 /* layer */,
                           src_x0, src_y0,
                           width, height,
                           dst_x0, dst_y0,
                           width, height,
                           false, false /*mirror x, y*/);
d1674 5
d1682 5
a1686 5
                              src_x0, src_y0,
                              width, height,
                              dst_x0, dst_y0,
                              width, height,
                              false, false /*mirror x, y*/);
a1689 48
static void
assert_is_flat(struct intel_mipmap_tree *mt)
{
   assert(mt->target == GL_TEXTURE_2D);
   assert(mt->first_level == 0);
   assert(mt->last_level == 0);
}

/**
 * \brief Downsample from mt to mt->singlesample_mt.
 *
 * If the miptree needs no downsample, then skip.
 */
void
intel_miptree_downsample(struct brw_context *brw,
                         struct intel_mipmap_tree *mt)
{
   /* Only flat, renderbuffer-like miptrees are supported. */
   assert_is_flat(mt);

   if (!mt->need_downsample)
      return;
   intel_miptree_updownsample(brw,
                              mt, mt->singlesample_mt,
                              mt->logical_width0,
                              mt->logical_height0);
   mt->need_downsample = false;
}

/**
 * \brief Upsample from mt->singlesample_mt to mt.
 *
 * The upsample is done unconditionally.
 */
void
intel_miptree_upsample(struct brw_context *brw,
                       struct intel_mipmap_tree *mt)
{
   /* Only flat, renderbuffer-like miptrees are supported. */
   assert_is_flat(mt);
   assert(!mt->need_downsample);

   intel_miptree_updownsample(brw,
                              mt->singlesample_mt, mt,
                              mt->logical_width0,
                              mt->logical_height0);
}

a1692 1
   struct gl_context *ctx = &brw->ctx;
d1698 1
a1698 7
   drm_intel_bo *bo = mt->region->bo;

   if (unlikely(INTEL_DEBUG & DEBUG_PERF)) {
      if (drm_intel_bo_busy(bo)) {
         perf_debug("Mapping a busy BO, causing a stall on the GPU.\n");
      }
   }
d1700 2
a1701 1
   intel_flush(ctx);
d1703 2
a1704 2
   if (mt->region->tiling != I915_TILING_NONE)
      drm_intel_gem_bo_map_gtt(bo);
d1706 1
a1706 1
      drm_intel_bo_map(bo, true);
d1715 1
a1715 1
   drm_intel_bo_unmap(mt->region->bo);
d1750 1
a1750 1
      map->stride = mt->region->pitch;
d1785 1
a1785 1
   map->stride = map->mt->region->pitch;
a1796 1
   intel_batchbuffer_flush(brw);
d1836 73
d1934 1
a1934 1
	    ptrdiff_t offset = intel_offset_S8(mt->region->pitch,
d1970 1
a1970 1
	    ptrdiff_t offset = intel_offset_S8(mt->region->pitch,
d1993 1
a1993 1
      assert(mt->format == MESA_FORMAT_RGBX8888_REV);
d2020 2
a2021 2
                + image_y * mt->region->pitch
                + image_x * mt->region->cpp;
d2024 1
a2024 1
      _mesa_etc1_unpack_rgba8888(dst, mt->region->pitch,
d2028 1
a2028 1
      _mesa_unpack_etc2_format(dst, mt->region->pitch,
d2055 1
a2055 1
   bool map_z32f_x24s8 = mt->format == MESA_FORMAT_Z32_FLOAT;
d2083 1
a2083 1
	    ptrdiff_t s_offset = intel_offset_S8(s_mt->region->pitch,
d2088 1
a2088 1
                                  (z_mt->region->pitch / 4) +
d2127 1
a2127 1
   bool map_z32f_x24s8 = mt->format == MESA_FORMAT_Z32_FLOAT;
d2143 1
a2143 1
	    ptrdiff_t s_offset = intel_offset_S8(s_mt->region->pitch,
d2148 1
a2148 1
                                  (z_mt->region->pitch / 4) +
d2223 28
a2250 12
static void
intel_miptree_map_singlesample(struct brw_context *brw,
                               struct intel_mipmap_tree *mt,
                               unsigned int level,
                               unsigned int slice,
                               unsigned int x,
                               unsigned int y,
                               unsigned int w,
                               unsigned int h,
                               GLbitfield mode,
                               void **out_ptr,
                               int *out_stride)
d2268 1
a2268 1
   if (mt->format == MESA_FORMAT_S8) {
d2280 3
a2282 3
            (mt->region->tiling == I915_TILING_X ||
             (brw->gen >= 6 && mt->region->tiling == I915_TILING_Y)) &&
            mt->region->pitch < 32768) {
d2284 3
a2286 3
   } else if (mt->region->tiling != I915_TILING_NONE &&
              mt->region->bo->size >= brw->max_gtt_map_object_size) {
      assert(mt->region->pitch < 32768);
d2288 4
d2303 5
a2307 5
static void
intel_miptree_unmap_singlesample(struct brw_context *brw,
                                 struct intel_mipmap_tree *mt,
                                 unsigned int level,
                                 unsigned int slice)
d2319 1
a2319 1
   if (mt->format == MESA_FORMAT_S8) {
d2328 4
a2336 124
}

static void
intel_miptree_map_multisample(struct brw_context *brw,
                              struct intel_mipmap_tree *mt,
                              unsigned int level,
                              unsigned int slice,
                              unsigned int x,
                              unsigned int y,
                              unsigned int w,
                              unsigned int h,
                              GLbitfield mode,
                              void **out_ptr,
                              int *out_stride)
{
   struct gl_context *ctx = &brw->ctx;
   struct intel_miptree_map *map;

   assert(mt->num_samples > 1);

   /* Only flat, renderbuffer-like miptrees are supported. */
   if (mt->target != GL_TEXTURE_2D ||
       mt->first_level != 0 ||
       mt->last_level != 0) {
      _mesa_problem(ctx, "attempt to map a multisample miptree for "
                    "which (target, first_level, last_level != "
                    "(GL_TEXTURE_2D, 0, 0)");
      goto fail;
   }

   map = intel_miptree_attach_map(mt, level, slice, x, y, w, h, mode);
   if (!map)
      goto fail;

   if (!mt->singlesample_mt) {
      mt->singlesample_mt =
         intel_miptree_create_for_renderbuffer(brw,
                                               mt->format,
                                               mt->logical_width0,
                                               mt->logical_height0,
                                               0 /*num_samples*/);
      if (!mt->singlesample_mt)
         goto fail;

      map->singlesample_mt_is_tmp = true;
      mt->need_downsample = true;
   }

   intel_miptree_downsample(brw, mt);
   intel_miptree_map_singlesample(brw, mt->singlesample_mt,
                                  level, slice,
                                  x, y, w, h,
                                  mode,
                                  out_ptr, out_stride);
   return;

fail:
   intel_miptree_release_map(mt, level, slice);
   *out_ptr = NULL;
   *out_stride = 0;
}

static void
intel_miptree_unmap_multisample(struct brw_context *brw,
                                struct intel_mipmap_tree *mt,
                                unsigned int level,
                                unsigned int slice)
{
   struct intel_miptree_map *map = mt->level[level].slice[slice].map;

   assert(mt->num_samples > 1);

   if (!map)
      return;

   intel_miptree_unmap_singlesample(brw, mt->singlesample_mt, level, slice);

   mt->need_downsample = false;
   if (map->mode & GL_MAP_WRITE_BIT)
      intel_miptree_upsample(brw, mt);

   if (map->singlesample_mt_is_tmp)
      intel_miptree_release(&mt->singlesample_mt);

   intel_miptree_release_map(mt, level, slice);
}

void
intel_miptree_map(struct brw_context *brw,
		  struct intel_mipmap_tree *mt,
		  unsigned int level,
		  unsigned int slice,
		  unsigned int x,
		  unsigned int y,
		  unsigned int w,
		  unsigned int h,
		  GLbitfield mode,
		  void **out_ptr,
		  int *out_stride)
{
   if (mt->num_samples <= 1)
      intel_miptree_map_singlesample(brw, mt,
                                     level, slice,
                                     x, y, w, h,
                                     mode,
                                     out_ptr, out_stride);
   else
      intel_miptree_map_multisample(brw, mt,
                                    level, slice,
                                    x, y, w, h,
                                    mode,
                                    out_ptr, out_stride);
}

void
intel_miptree_unmap(struct brw_context *brw,
		    struct intel_mipmap_tree *mt,
		    unsigned int level,
		    unsigned int slice)
{
   if (mt->num_samples <= 1)
      intel_miptree_unmap_singlesample(brw, mt, level, slice);
   else
      intel_miptree_unmap_multisample(brw, mt, level, slice);
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d28 5
a32 1
#include "intel_context.h"
d35 14
a48 3
#include "bufmgr.h"
#include "enums.h"
#include "imports.h"
d50 2
a51 1
static GLenum target_to_target( GLenum target )
d66 185
a250 10
struct intel_mipmap_tree *intel_miptree_create( struct intel_context *intel,
						GLenum target,
						GLenum internal_format,
						GLuint first_level,
						GLuint last_level,
						GLuint width0,
						GLuint height0,
						GLuint depth0,
						GLuint cpp,
						GLboolean compressed)
a251 1
   GLboolean ok;
d253 2
d256 4
a259 6
   if (INTEL_DEBUG & DEBUG_TEXTURE)
      _mesa_printf("%s target %s format %s level %d..%d\n", __FUNCTION__,
		   _mesa_lookup_enum_by_nr(target),
		   _mesa_lookup_enum_by_nr(internal_format),
		   first_level,
		   last_level);
d262 1
a262 1
   mt->internal_format = internal_format;
d265 88
a352 14
   mt->width0 = width0;
   mt->height0 = height0;
   mt->depth0 = depth0;
   mt->cpp = compressed ? 2 : cpp;
   mt->compressed = compressed;

   switch (intel->intelScreen->deviceID) {
#if 0
   case PCI_CHIP_I945_G:
      ok = i945_miptree_layout( mt );
      break;
   case PCI_CHIP_I915_G:
   case PCI_CHIP_I915_GM:
      ok = i915_miptree_layout( mt );
d354 73
a426 5
#endif
   default:
      if (INTEL_DEBUG & DEBUG_TEXTURE)
	 _mesa_printf("assuming BRW texture layouts\n");
      ok = brw_miptree_layout( intel, mt );
d428 159
d589 1
a589 5
   if (ok)
      mt->region = intel_region_alloc( intel, 
				       mt->cpp,
				       mt->pitch, 
				       mt->total_height );
d592 29
a620 1
      free(mt);
d622 30
a651 1
   }
d658 1
a658 5
 * intel_miptree_pitch_align:
 *
 * @@intel: intel context pointer
 *
 * @@mt: the miptree to compute pitch alignment for
d660 3
a662 4
 * @@pitch: the natural pitch value
 *
 * Given @@pitch, compute a larger value which accounts for
 * any necessary alignment required by the device
d664 60
d725 42
a766 3
int intel_miptree_pitch_align (struct intel_context *intel,
			       struct intel_mipmap_tree *mt,
			       int pitch)
d768 4
a771 2
   if (!mt->compressed)
      pitch = ((pitch * mt->cpp + 3) & ~3) / mt->cpp;
d773 6
a778 1
   return pitch;
d782 2
a783 2
void intel_miptree_destroy( struct intel_context *intel,
			    struct intel_mipmap_tree *mt )
d785 5
a789 1
   if (mt) {
d792 1
a792 1
      intel_region_release(intel, &(mt->region));
d794 10
a803 3
      for (i = 0; i < MAX_TEXTURE_LEVELS; i++)
	 if (mt->level[i].image_offset)
	    free(mt->level[i].image_offset);
d805 1
a805 1
      free(mt);
d807 1
d810 17
d828 65
d895 5
a899 5
void intel_miptree_set_level_info(struct intel_mipmap_tree *mt,
				  GLuint level,
				  GLuint nr_images,
				  GLuint x, GLuint y,
				  GLuint w, GLuint h, GLuint d)
d904 294
a1197 2
   mt->level[level].level_offset = (x + y * mt->pitch) * mt->cpp;
   mt->level[level].nr_images = nr_images;
a1198 3
   if (INTEL_DEBUG & DEBUG_TEXTURE)
      _mesa_printf("%s level %d img size: %d,%d level_offset 0x%x\n", __FUNCTION__, level, w, h, 
		   mt->level[level].level_offset);
d1200 14
a1213 1
   /* Not sure when this would happen, but anyway: 
d1215 66
a1280 3
   if (mt->level[level].image_offset) {
      free(mt->level[level].image_offset);
      mt->level[level].image_offset = NULL;
d1283 42
a1324 3
   if (nr_images > 1) {
      mt->level[level].image_offset = malloc(nr_images * sizeof(GLuint));
      mt->level[level].image_offset[0] = 0;
d1326 2
d1330 11
d1342 7
d1350 23
a1372 4
void intel_miptree_set_image_offset(struct intel_mipmap_tree *mt,
				    GLuint level,
				    GLuint img,
				    GLuint x, GLuint y)
d1374 22
a1395 2
   if (INTEL_DEBUG & DEBUG_TEXTURE)
      _mesa_printf("%s level %d img %d pos %d,%d\n", __FUNCTION__, level, img, x, y);
d1397 146
a1542 2
   if (img == 0)
      assert(x == 0 && y == 0);
d1544 1
a1544 2
   if (img > 0)
      mt->level[level].image_offset[img] = (x + y * mt->pitch) * mt->cpp;
d1547 40
d1588 2
a1589 3
/* Although we use the image_offset[] array to store relative offsets
 * to cube faces, Mesa doesn't know anything about this and expects
 * each cube face to be treated as a separate image.
d1591 1
a1591 1
 * These functions present that view to mesa:
d1593 3
a1595 2
const GLuint *intel_miptree_depth_offsets(struct intel_mipmap_tree *mt,
					  GLuint level)
d1597 11
a1607 1
   static const GLuint zero = 0;
d1609 40
a1648 3
   if (mt->target != GL_TEXTURE_3D ||
       mt->level[level].nr_images == 1)
      return &zero;
d1650 3
a1652 1
      return mt->level[level].image_offset;
d1655 6
d1662 5
a1666 3
GLuint intel_miptree_image_offset(struct intel_mipmap_tree *mt,
				  GLuint face,
				  GLuint level)
d1668 231
a1898 3
   if (mt->target == GL_TEXTURE_CUBE_MAP_ARB)
      return (mt->level[level].level_offset +
	      mt->level[level].image_offset[face]);
d1900 147
a2046 1
      return mt->level[level].level_offset;
d2049 15
d2065 2
d2068 2
d2071 5
d2077 2
d2080 2
a2081 1
/* Upload data for a particular image.
d2083 116
a2198 7
GLboolean intel_miptree_image_data(struct intel_context *intel, 
				   struct intel_mipmap_tree *dst,
				   GLuint face,
				   GLuint level,
				   const void *src, 
				   GLuint src_row_pitch,
				   GLuint src_image_pitch)
d2200 4
a2203 4
   GLuint depth = dst->level[level].depth;
   GLuint dst_offset = intel_miptree_image_offset(dst, face, level);
   const GLuint *dst_depth_offset = intel_miptree_depth_offsets(dst, level);
   GLuint i;
d2205 8
a2212 14
   DBG("%s\n", __FUNCTION__);
   for (i = 0; i < depth; i++) {
      if (!intel_region_data(intel,
			     dst->region, 
			     dst_offset + dst_depth_offset[i],
			     0,
			     0,
			     src,
			     src_row_pitch,
			     0, 0,	/* source x,y */
			     dst->level[level].width,
			     dst->level[level].height))
	 return GL_FALSE;
      src += src_image_pitch;
d2214 31
a2244 1
   return GL_TRUE;
d2247 63
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@@


1.1
log
@Initial revision
@
text
@d94 1
a94 1
      ok = brw_miptree_layout( mt );
d112 23
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d28 1
a28 5
#include <GL/gl.h>
#include <GL/internal/dri_interface.h>

#include "intel_batchbuffer.h"
#include "intel_chipset.h"
d31 3
a33 14
#include "intel_resolve_map.h"
#include "intel_tex.h"
#include "intel_blit.h"

#include "brw_blorp.h"
#include "brw_context.h"

#include "main/enums.h"
#include "main/formats.h"
#include "main/glformats.h"
#include "main/texcompress_etc.h"
#include "main/teximage.h"

#define FILE_DEBUG_FLAG DEBUG_MIPTREE
d35 1
a35 2
static GLenum
target_to_target(GLenum target)
d50 10
a59 185

/**
 * Determine which MSAA layout should be used by the MSAA surface being
 * created, based on the chip generation and the surface type.
 */
static enum intel_msaa_layout
compute_msaa_layout(struct brw_context *brw, gl_format format, GLenum target)
{
   /* Prior to Gen7, all MSAA surfaces used IMS layout. */
   if (brw->gen < 7)
      return INTEL_MSAA_LAYOUT_IMS;

   /* In Gen7, IMS layout is only used for depth and stencil buffers. */
   switch (_mesa_get_format_base_format(format)) {
   case GL_DEPTH_COMPONENT:
   case GL_STENCIL_INDEX:
   case GL_DEPTH_STENCIL:
      return INTEL_MSAA_LAYOUT_IMS;
   default:
      /* From the Ivy Bridge PRM, Vol4 Part1 p77 ("MCS Enable"):
       *
       *   This field must be set to 0 for all SINT MSRTs when all RT channels
       *   are not written
       *
       * In practice this means that we have to disable MCS for all signed
       * integer MSAA buffers.  The alternative, to disable MCS only when one
       * of the render target channels is disabled, is impractical because it
       * would require converting between CMS and UMS MSAA layouts on the fly,
       * which is expensive.
       */
      if (_mesa_get_format_datatype(format) == GL_INT) {
         /* TODO: is this workaround needed for future chipsets? */
         assert(brw->gen == 7);
         return INTEL_MSAA_LAYOUT_UMS;
      } else {
         /* For now, if we're going to be texturing from this surface,
          * force UMS, so that the shader doesn't have to do different things
          * based on whether there's a multisample control surface needing sampled first.
          * We can't just blindly read the MCS surface in all cases because:
          *
          * From the Ivy Bridge PRM, Vol4 Part1 p77 ("MCS Enable"):
          *
          *    If this field is disabled and the sampling engine <ld_mcs> message
          *    is issued on this surface, the MCS surface may be accessed. Software
          *    must ensure that the surface is defined to avoid GTT errors.
          */
         if (target == GL_TEXTURE_2D_MULTISAMPLE ||
             target == GL_TEXTURE_2D_MULTISAMPLE_ARRAY) {
            return INTEL_MSAA_LAYOUT_UMS;
         } else {
            return INTEL_MSAA_LAYOUT_CMS;
         }
      }
   }
}


/**
 * For single-sampled render targets ("non-MSRT"), the MCS buffer is a
 * scaled-down bitfield representation of the color buffer which is capable of
 * recording when blocks of the color buffer are equal to the clear value.
 * This function returns the block size that will be used by the MCS buffer
 * corresponding to a certain color miptree.
 *
 * From the Ivy Bridge PRM, Vol2 Part1 11.7 "MCS Buffer for Render Target(s)",
 * beneath the "Fast Color Clear" bullet (p327):
 *
 *     The following table describes the RT alignment
 *
 *                       Pixels  Lines
 *         TiledY RT CL
 *             bpp
 *              32          8      4
 *              64          4      4
 *             128          2      4
 *         TiledX RT CL
 *             bpp
 *              32         16      2
 *              64          8      2
 *             128          4      2
 *
 * This alignment has the following uses:
 *
 * - For figuring out the size of the MCS buffer.  Each 4k tile in the MCS
 *   buffer contains 128 blocks horizontally and 256 blocks vertically.
 *
 * - For figuring out alignment restrictions for a fast clear operation.  Fast
 *   clear operations must always clear aligned multiples of 16 blocks
 *   horizontally and 32 blocks vertically.
 *
 * - For scaling down the coordinates sent through the render pipeline during
 *   a fast clear.  X coordinates must be scaled down by 8 times the block
 *   width, and Y coordinates by 16 times the block height.
 *
 * - For scaling down the coordinates sent through the render pipeline during
 *   a "Render Target Resolve" operation.  X coordinates must be scaled down
 *   by half the block width, and Y coordinates by half the block height.
 */
void
intel_get_non_msrt_mcs_alignment(struct brw_context *brw,
                                 struct intel_mipmap_tree *mt,
                                 unsigned *width_px, unsigned *height)
{
   switch (mt->region->tiling) {
   default:
      assert(!"Non-MSRT MCS requires X or Y tiling");
      /* In release builds, fall through */
   case I915_TILING_Y:
      *width_px = 32 / mt->cpp;
      *height = 4;
      break;
   case I915_TILING_X:
      *width_px = 64 / mt->cpp;
      *height = 2;
   }
}


/**
 * For a single-sampled render target ("non-MSRT"), determine if an MCS buffer
 * can be used.
 *
 * From the Ivy Bridge PRM, Vol2 Part1 11.7 "MCS Buffer for Render Target(s)",
 * beneath the "Fast Color Clear" bullet (p326):
 *
 *     - Support is limited to tiled render targets.
 *     - Support is for non-mip-mapped and non-array surface types only.
 *
 * And then later, on p327:
 *
 *     - MCS buffer for non-MSRT is supported only for RT formats 32bpp,
 *       64bpp, and 128bpp.
 */
bool
intel_is_non_msrt_mcs_buffer_supported(struct brw_context *brw,
                                       struct intel_mipmap_tree *mt)
{
   /* MCS support does not exist prior to Gen7 */
   if (brw->gen < 7)
      return false;

   /* MCS is only supported for color buffers */
   switch (_mesa_get_format_base_format(mt->format)) {
   case GL_DEPTH_COMPONENT:
   case GL_DEPTH_STENCIL:
   case GL_STENCIL_INDEX:
      return false;
   }

   if (mt->region->tiling != I915_TILING_X &&
       mt->region->tiling != I915_TILING_Y)
      return false;
   if (mt->cpp != 4 && mt->cpp != 8 && mt->cpp != 16)
      return false;
   if (mt->first_level != 0 || mt->last_level != 0)
      return false;
   if (mt->physical_depth0 != 1)
      return false;

   /* There's no point in using an MCS buffer if the surface isn't in a
    * renderable format.
    */
   if (!brw->format_supported_as_render_target[mt->format])
      return false;

   return true;
}


/**
 * @@param for_bo Indicates that the caller is
 *        intel_miptree_create_for_bo(). If true, then do not create
 *        \c stencil_mt.
 */
struct intel_mipmap_tree *
intel_miptree_create_layout(struct brw_context *brw,
                            GLenum target,
                            gl_format format,
                            GLuint first_level,
                            GLuint last_level,
                            GLuint width0,
                            GLuint height0,
                            GLuint depth0,
                            bool for_bo,
                            GLuint num_samples)
d61 1
a62 2
   if (!mt)
      return NULL;
d64 6
a69 4
   DBG("%s target %s format %s level %d..%d <-- %p\n", __FUNCTION__,
       _mesa_lookup_enum_by_nr(target),
       _mesa_get_format_name(format),
       first_level, last_level, mt);
d72 1
a72 1
   mt->format = format;
d75 14
a88 84
   mt->logical_width0 = width0;
   mt->logical_height0 = height0;
   mt->logical_depth0 = depth0;
   mt->mcs_state = INTEL_MCS_STATE_NONE;

   /* The cpp is bytes per (1, blockheight)-sized block for compressed
    * textures.  This is why you'll see divides by blockheight all over
    */
   unsigned bw, bh;
   _mesa_get_format_block_size(format, &bw, &bh);
   assert(_mesa_get_format_bytes(mt->format) % bw == 0);
   mt->cpp = _mesa_get_format_bytes(mt->format) / bw;

   mt->num_samples = num_samples;
   mt->compressed = _mesa_is_format_compressed(format);
   mt->msaa_layout = INTEL_MSAA_LAYOUT_NONE;
   mt->refcount = 1; 

   if (num_samples > 1) {
      /* Adjust width/height/depth for MSAA */
      mt->msaa_layout = compute_msaa_layout(brw, format, mt->target);
      if (mt->msaa_layout == INTEL_MSAA_LAYOUT_IMS) {
         /* In the Sandy Bridge PRM, volume 4, part 1, page 31, it says:
          *
          *     "Any of the other messages (sample*, LOD, load4) used with a
          *      (4x) multisampled surface will in-effect sample a surface with
          *      double the height and width as that indicated in the surface
          *      state. Each pixel position on the original-sized surface is
          *      replaced with a 2x2 of samples with the following arrangement:
          *
          *         sample 0 sample 2
          *         sample 1 sample 3"
          *
          * Thus, when sampling from a multisampled texture, it behaves as
          * though the layout in memory for (x,y,sample) is:
          *
          *      (0,0,0) (0,0,2)   (1,0,0) (1,0,2)
          *      (0,0,1) (0,0,3)   (1,0,1) (1,0,3)
          *
          *      (0,1,0) (0,1,2)   (1,1,0) (1,1,2)
          *      (0,1,1) (0,1,3)   (1,1,1) (1,1,3)
          *
          * However, the actual layout of multisampled data in memory is:
          *
          *      (0,0,0) (1,0,0)   (0,0,1) (1,0,1)
          *      (0,1,0) (1,1,0)   (0,1,1) (1,1,1)
          *
          *      (0,0,2) (1,0,2)   (0,0,3) (1,0,3)
          *      (0,1,2) (1,1,2)   (0,1,3) (1,1,3)
          *
          * This pattern repeats for each 2x2 pixel block.
          *
          * As a result, when calculating the size of our 4-sample buffer for
          * an odd width or height, we have to align before scaling up because
          * sample 3 is in that bottom right 2x2 block.
          */
         switch (num_samples) {
         case 4:
            width0 = ALIGN(width0, 2) * 2;
            height0 = ALIGN(height0, 2) * 2;
            break;
         case 8:
            width0 = ALIGN(width0, 2) * 4;
            height0 = ALIGN(height0, 2) * 2;
            break;
         default:
            /* num_samples should already have been quantized to 0, 1, 4, or
             * 8.
             */
            assert(false);
         }
      } else {
         /* Non-interleaved */
         depth0 *= num_samples;
      }
   }

   /* array_spacing_lod0 is only used for non-IMS MSAA surfaces.  TODO: can we
    * use it elsewhere?
    */
   switch (mt->msaa_layout) {
   case INTEL_MSAA_LAYOUT_NONE:
   case INTEL_MSAA_LAYOUT_IMS:
      mt->array_spacing_lod0 = false;
d90 5
a94 3
   case INTEL_MSAA_LAYOUT_UMS:
   case INTEL_MSAA_LAYOUT_CMS:
      mt->array_spacing_lod0 = true;
d98 5
a102 234
   if (target == GL_TEXTURE_CUBE_MAP) {
      assert(depth0 == 1);
      depth0 = 6;
   }

   mt->physical_width0 = width0;
   mt->physical_height0 = height0;
   mt->physical_depth0 = depth0;

   if (!for_bo &&
       _mesa_get_format_base_format(format) == GL_DEPTH_STENCIL &&
       (brw->must_use_separate_stencil ||
	(brw->has_separate_stencil && brw_is_hiz_depth_format(brw, format)))) {
      mt->stencil_mt = intel_miptree_create(brw,
                                            mt->target,
                                            MESA_FORMAT_S8,
                                            mt->first_level,
                                            mt->last_level,
                                            mt->logical_width0,
                                            mt->logical_height0,
                                            mt->logical_depth0,
                                            true,
                                            num_samples,
                                            INTEL_MIPTREE_TILING_ANY);
      if (!mt->stencil_mt) {
	 intel_miptree_release(&mt);
	 return NULL;
      }

      /* Fix up the Z miptree format for how we're splitting out separate
       * stencil.  Gen7 expects there to be no stencil bits in its depth buffer.
       */
      if (mt->format == MESA_FORMAT_S8_Z24) {
	 mt->format = MESA_FORMAT_X8_Z24;
      } else if (mt->format == MESA_FORMAT_Z32_FLOAT_X24S8) {
	 mt->format = MESA_FORMAT_Z32_FLOAT;
	 mt->cpp = 4;
      } else {
	 _mesa_problem(NULL, "Unknown format %s in separate stencil mt\n",
		       _mesa_get_format_name(mt->format));
      }
   }

   brw_miptree_layout(brw, mt);

   return mt;
}

/**
 * \brief Helper function for intel_miptree_create().
 */
static uint32_t
intel_miptree_choose_tiling(struct brw_context *brw,
                            gl_format format,
                            uint32_t width0,
                            uint32_t num_samples,
                            enum intel_miptree_tiling_mode requested,
                            struct intel_mipmap_tree *mt)
{
   if (format == MESA_FORMAT_S8) {
      /* The stencil buffer is W tiled. However, we request from the kernel a
       * non-tiled buffer because the GTT is incapable of W fencing.
       */
      return I915_TILING_NONE;
   }

   /* Some usages may want only one type of tiling, like depth miptrees (Y
    * tiled), or temporary BOs for uploading data once (linear).
    */
   switch (requested) {
   case INTEL_MIPTREE_TILING_ANY:
      break;
   case INTEL_MIPTREE_TILING_Y:
      return I915_TILING_Y;
   case INTEL_MIPTREE_TILING_NONE:
      return I915_TILING_NONE;
   }

   if (num_samples > 1) {
      /* From p82 of the Sandy Bridge PRM, dw3[1] of SURFACE_STATE ("Tiled
       * Surface"):
       *
       *   [DevSNB+]: For multi-sample render targets, this field must be
       *   1. MSRTs can only be tiled.
       *
       * Our usual reason for preferring X tiling (fast blits using the
       * blitting engine) doesn't apply to MSAA, since we'll generally be
       * downsampling or upsampling when blitting between the MSAA buffer
       * and another buffer, and the blitting engine doesn't support that.
       * So use Y tiling, since it makes better use of the cache.
       */
      return I915_TILING_Y;
   }

   GLenum base_format = _mesa_get_format_base_format(format);
   if (base_format == GL_DEPTH_COMPONENT ||
       base_format == GL_DEPTH_STENCIL_EXT)
      return I915_TILING_Y;

   int minimum_pitch = mt->total_width * mt->cpp;

   /* If the width is much smaller than a tile, don't bother tiling. */
   if (minimum_pitch < 64)
      return I915_TILING_NONE;

   if (ALIGN(minimum_pitch, 512) >= 32768) {
      perf_debug("%dx%d miptree too large to blit, falling back to untiled",
                 mt->total_width, mt->total_height);
      return I915_TILING_NONE;
   }

   /* Pre-gen6 doesn't have BLORP to handle Y-tiling, so use X-tiling. */
   if (brw->gen < 6)
      return I915_TILING_X;

   /* From the Sandybridge PRM, Volume 1, Part 2, page 32:
    * "NOTE: 128BPE Format Color Buffer ( render target ) MUST be either TileX
    *  or Linear."
    * 128 bits per pixel translates to 16 bytes per pixel.  This is necessary
    * all the way back to 965, but is explicitly permitted on Gen7.
    */
   if (brw->gen != 7 && mt->cpp >= 16)
      return I915_TILING_X;

   return I915_TILING_Y | I915_TILING_X;
}

struct intel_mipmap_tree *
intel_miptree_create(struct brw_context *brw,
		     GLenum target,
		     gl_format format,
		     GLuint first_level,
		     GLuint last_level,
		     GLuint width0,
		     GLuint height0,
		     GLuint depth0,
		     bool expect_accelerated_upload,
                     GLuint num_samples,
                     enum intel_miptree_tiling_mode requested_tiling)
{
   struct intel_mipmap_tree *mt;
   gl_format tex_format = format;
   gl_format etc_format = MESA_FORMAT_NONE;
   GLuint total_width, total_height;

   if (!brw->is_baytrail) {
      switch (format) {
      case MESA_FORMAT_ETC1_RGB8:
         format = MESA_FORMAT_RGBX8888_REV;
         break;
      case MESA_FORMAT_ETC2_RGB8:
         format = MESA_FORMAT_RGBX8888_REV;
         break;
      case MESA_FORMAT_ETC2_SRGB8:
      case MESA_FORMAT_ETC2_SRGB8_ALPHA8_EAC:
      case MESA_FORMAT_ETC2_SRGB8_PUNCHTHROUGH_ALPHA1:
         format = MESA_FORMAT_SARGB8;
         break;
      case MESA_FORMAT_ETC2_RGBA8_EAC:
      case MESA_FORMAT_ETC2_RGB8_PUNCHTHROUGH_ALPHA1:
         format = MESA_FORMAT_RGBA8888_REV;
         break;
      case MESA_FORMAT_ETC2_R11_EAC:
         format = MESA_FORMAT_R16;
         break;
      case MESA_FORMAT_ETC2_SIGNED_R11_EAC:
         format = MESA_FORMAT_SIGNED_R16;
         break;
      case MESA_FORMAT_ETC2_RG11_EAC:
         format = MESA_FORMAT_GR1616;
         break;
      case MESA_FORMAT_ETC2_SIGNED_RG11_EAC:
         format = MESA_FORMAT_SIGNED_GR1616;
         break;
      default:
         /* Non ETC1 / ETC2 format */
         break;
      }
   }

   etc_format = (format != tex_format) ? tex_format : MESA_FORMAT_NONE;

   mt = intel_miptree_create_layout(brw, target, format,
				      first_level, last_level, width0,
				      height0, depth0,
				      false, num_samples);
   /*
    * pitch == 0 || height == 0  indicates the null texture
    */
   if (!mt || !mt->total_width || !mt->total_height) {
      intel_miptree_release(&mt);
      return NULL;
   }

   total_width = mt->total_width;
   total_height = mt->total_height;

   if (format == MESA_FORMAT_S8) {
      /* Align to size of W tile, 64x64. */
      total_width = ALIGN(total_width, 64);
      total_height = ALIGN(total_height, 64);
   }

   uint32_t tiling = intel_miptree_choose_tiling(brw, format, width0,
                                                 num_samples, requested_tiling,
                                                 mt);
   bool y_or_x = tiling == (I915_TILING_Y | I915_TILING_X);

   mt->etc_format = etc_format;
   mt->region = intel_region_alloc(brw->intelScreen,
				   y_or_x ? I915_TILING_Y : tiling,
				   mt->cpp,
				   total_width,
				   total_height,
				   expect_accelerated_upload);

   /* If the region is too large to fit in the aperture, we need to use the
    * BLT engine to support it.  The BLT paths can't currently handle Y-tiling,
    * so we need to fall back to X.
    */
   if (y_or_x && mt->region->bo->size >= brw->max_gtt_map_object_size) {
      perf_debug("%dx%d miptree larger than aperture; falling back to X-tiled\n",
                 mt->total_width, mt->total_height);
      intel_region_release(&mt->region);

      mt->region = intel_region_alloc(brw->intelScreen,
                                      I915_TILING_X,
                                      mt->cpp,
                                      total_width,
                                      total_height,
                                      expect_accelerated_upload);
   }

   mt->offset = 0;
d105 1
a105 29
       intel_miptree_release(&mt);
       return NULL;
   }

   /* If this miptree is capable of supporting fast color clears, set
    * mcs_state appropriately to ensure that fast clears will occur.
    * Allocation of the MCS miptree will be deferred until the first fast
    * clear actually occurs.
    */
   if (intel_is_non_msrt_mcs_buffer_supported(brw, mt))
      mt->mcs_state = INTEL_MCS_STATE_RESOLVED;

   return mt;
}

struct intel_mipmap_tree *
intel_miptree_create_for_bo(struct brw_context *brw,
                            drm_intel_bo *bo,
                            gl_format format,
                            uint32_t offset,
                            uint32_t width,
                            uint32_t height,
                            int pitch,
                            uint32_t tiling)
{
   struct intel_mipmap_tree *mt;

   struct intel_region *region = calloc(1, sizeof(*region));
   if (!region)
a106 133

   /* Nothing will be able to use this miptree with the BO if the offset isn't
    * aligned.
    */
   if (tiling != I915_TILING_NONE)
      assert(offset % 4096 == 0);

   /* miptrees can't handle negative pitch.  If you need flipping of images,
    * that's outside of the scope of the mt.
    */
   assert(pitch >= 0);

   mt = intel_miptree_create_layout(brw, GL_TEXTURE_2D, format,
                                    0, 0,
                                    width, height, 1,
                                    true, 0 /* num_samples */);
   if (!mt)
      return mt;

   region->cpp = mt->cpp;
   region->width = width;
   region->height = height;
   region->pitch = pitch;
   region->refcount = 1;
   drm_intel_bo_reference(bo);
   region->bo = bo;
   region->tiling = tiling;

   mt->region = region;
   mt->offset = offset;

   return mt;
}


/**
 * For a singlesample DRI2 buffer, this simply wraps the given region with a miptree.
 *
 * For a multisample DRI2 buffer, this wraps the given region with
 * a singlesample miptree, then creates a multisample miptree into which the
 * singlesample miptree is embedded as a child.
 */
struct intel_mipmap_tree*
intel_miptree_create_for_dri2_buffer(struct brw_context *brw,
                                     unsigned dri_attachment,
                                     gl_format format,
                                     uint32_t num_samples,
                                     struct intel_region *region)
{
   struct intel_mipmap_tree *singlesample_mt = NULL;
   struct intel_mipmap_tree *multisample_mt = NULL;

   /* Only the front and back buffers, which are color buffers, are shared
    * through DRI2.
    */
   assert(dri_attachment == __DRI_BUFFER_BACK_LEFT ||
          dri_attachment == __DRI_BUFFER_FRONT_LEFT ||
          dri_attachment == __DRI_BUFFER_FAKE_FRONT_LEFT);
   assert(_mesa_get_format_base_format(format) == GL_RGB ||
          _mesa_get_format_base_format(format) == GL_RGBA);

   singlesample_mt = intel_miptree_create_for_bo(brw,
                                                 region->bo,
                                                 format,
                                                 0,
                                                 region->width,
                                                 region->height,
                                                 region->pitch,
                                                 region->tiling);
   if (!singlesample_mt)
      return NULL;
   singlesample_mt->region->name = region->name;

   /* If this miptree is capable of supporting fast color clears, set
    * mcs_state appropriately to ensure that fast clears will occur.
    * Allocation of the MCS miptree will be deferred until the first fast
    * clear actually occurs.
    */
   if (intel_is_non_msrt_mcs_buffer_supported(brw, singlesample_mt))
      singlesample_mt->mcs_state = INTEL_MCS_STATE_RESOLVED;

   if (num_samples == 0)
      return singlesample_mt;

   multisample_mt = intel_miptree_create_for_renderbuffer(brw,
                                                          format,
                                                          region->width,
                                                          region->height,
                                                          num_samples);
   if (!multisample_mt) {
      intel_miptree_release(&singlesample_mt);
      return NULL;
   }

   multisample_mt->singlesample_mt = singlesample_mt;
   multisample_mt->need_downsample = false;

   if (brw->is_front_buffer_rendering &&
       (dri_attachment == __DRI_BUFFER_FRONT_LEFT ||
        dri_attachment == __DRI_BUFFER_FAKE_FRONT_LEFT)) {
      intel_miptree_upsample(brw, multisample_mt);
   }

   return multisample_mt;
}

struct intel_mipmap_tree*
intel_miptree_create_for_renderbuffer(struct brw_context *brw,
                                      gl_format format,
                                      uint32_t width,
                                      uint32_t height,
                                      uint32_t num_samples)
{
   struct intel_mipmap_tree *mt;
   uint32_t depth = 1;
   bool ok;

   mt = intel_miptree_create(brw, GL_TEXTURE_2D, format, 0, 0,
			     width, height, depth, true, num_samples,
                             INTEL_MIPTREE_TILING_ANY);
   if (!mt)
      goto fail;

   if (brw_is_hiz_depth_format(brw, format)) {
      ok = intel_miptree_alloc_hiz(brw, mt);
      if (!ok)
         goto fail;
   }

   if (mt->msaa_layout == INTEL_MSAA_LAYOUT_CMS) {
      ok = intel_miptree_alloc_mcs(brw, mt, num_samples);
      if (!ok)
         goto fail;
a109 4

fail:
   intel_miptree_release(&mt);
   return NULL;
a111 16
void
intel_miptree_reference(struct intel_mipmap_tree **dst,
                        struct intel_mipmap_tree *src)
{
   if (*dst == src)
      return;

   intel_miptree_release(dst);

   if (src) {
      src->refcount++;
      DBG("%s %p refcount now %d\n", __FUNCTION__, src, src->refcount);
   }

   *dst = src;
}
d114 2
a115 2
void
intel_miptree_release(struct intel_mipmap_tree **mt)
d117 1
a117 5
   if (!*mt)
      return;

   DBG("%s %p refcount will be %d\n", __FUNCTION__, *mt, (*mt)->refcount - 1);
   if (--(*mt)->refcount <= 0) {
d120 1
a120 1
      DBG("%s deleting %p\n", __FUNCTION__, *mt);
d122 3
a124 10
      intel_region_release(&((*mt)->region));
      intel_miptree_release(&(*mt)->stencil_mt);
      intel_miptree_release(&(*mt)->hiz_mt);
      intel_miptree_release(&(*mt)->mcs_mt);
      intel_miptree_release(&(*mt)->singlesample_mt);
      intel_resolve_map_clear(&(*mt)->hiz_map);

      for (i = 0; i < MAX_TEXTURE_LEVELS; i++) {
	 free((*mt)->level[i].slice);
      }
d126 1
a126 1
      free(*mt);
a127 1
   *mt = NULL;
a129 77
void
intel_miptree_get_dimensions_for_image(struct gl_texture_image *image,
                                       int *width, int *height, int *depth)
{
   switch (image->TexObject->Target) {
   case GL_TEXTURE_1D_ARRAY:
      *width = image->Width;
      *height = 1;
      *depth = image->Height;
      break;
   default:
      *width = image->Width;
      *height = image->Height;
      *depth = image->Depth;
      break;
   }
}

/**
 * Can the image be pulled into a unified mipmap tree?  This mirrors
 * the completeness test in a lot of ways.
 *
 * Not sure whether I want to pass gl_texture_image here.
 */
bool
intel_miptree_match_image(struct intel_mipmap_tree *mt,
                          struct gl_texture_image *image)
{
   struct intel_texture_image *intelImage = intel_texture_image(image);
   GLuint level = intelImage->base.Base.Level;
   int width, height, depth;

   /* glTexImage* choose the texture object based on the target passed in, and
    * objects can't change targets over their lifetimes, so this should be
    * true.
    */
   assert(target_to_target(image->TexObject->Target) == mt->target);

   gl_format mt_format = mt->format;
   if (mt->format == MESA_FORMAT_X8_Z24 && mt->stencil_mt)
      mt_format = MESA_FORMAT_S8_Z24;
   if (mt->format == MESA_FORMAT_Z32_FLOAT && mt->stencil_mt)
      mt_format = MESA_FORMAT_Z32_FLOAT_X24S8;
   if (mt->etc_format != MESA_FORMAT_NONE)
      mt_format = mt->etc_format;

   if (image->TexFormat != mt_format)
      return false;

   intel_miptree_get_dimensions_for_image(image, &width, &height, &depth);

   if (mt->target == GL_TEXTURE_CUBE_MAP)
      depth = 6;

   /* Test image dimensions against the base level image adjusted for
    * minification.  This will also catch images not present in the
    * tree, changed targets, etc.
    */
   if (mt->target == GL_TEXTURE_2D_MULTISAMPLE ||
         mt->target == GL_TEXTURE_2D_MULTISAMPLE_ARRAY) {
      /* nonzero level here is always bogus */
      assert(level == 0);

      if (width != mt->logical_width0 ||
            height != mt->logical_height0 ||
            depth != mt->logical_depth0) {
         return false;
      }
   }
   else {
      /* all normal textures, renderbuffers, etc */
      if (width != mt->level[level].width ||
          height != mt->level[level].height ||
          depth != mt->level[level].depth) {
         return false;
      }
   }
a130 2
   if (image->NumSamples != mt->num_samples)
      return false;
a131 2
   return true;
}
d133 5
a137 6

void
intel_miptree_set_level_info(struct intel_mipmap_tree *mt,
			     GLuint level,
			     GLuint x, GLuint y,
			     GLuint w, GLuint h, GLuint d)
d142 2
a143 13
   mt->level[level].level_x = x;
   mt->level[level].level_y = y;

   DBG("%s level %d size: %d,%d,%d offset %d,%d\n", __FUNCTION__,
       level, w, h, d, x, y);

   assert(mt->level[level].slice == NULL);

   mt->level[level].slice = calloc(d, sizeof(*mt->level[0].slice));
   mt->level[level].slice[0].x_offset = mt->level[level].level_x;
   mt->level[level].slice[0].y_offset = mt->level[level].level_y;
}

d145 3
a147 121
void
intel_miptree_set_image_offset(struct intel_mipmap_tree *mt,
			       GLuint level, GLuint img,
			       GLuint x, GLuint y)
{
   if (img == 0 && level == 0)
      assert(x == 0 && y == 0);

   assert(img < mt->level[level].depth);

   mt->level[level].slice[img].x_offset = mt->level[level].level_x + x;
   mt->level[level].slice[img].y_offset = mt->level[level].level_y + y;

   DBG("%s level %d img %d pos %d,%d\n",
       __FUNCTION__, level, img,
       mt->level[level].slice[img].x_offset,
       mt->level[level].slice[img].y_offset);
}

void
intel_miptree_get_image_offset(struct intel_mipmap_tree *mt,
			       GLuint level, GLuint slice,
			       GLuint *x, GLuint *y)
{
   assert(slice < mt->level[level].depth);

   *x = mt->level[level].slice[slice].x_offset;
   *y = mt->level[level].slice[slice].y_offset;
}

/**
 * Rendering with tiled buffers requires that the base address of the buffer
 * be aligned to a page boundary.  For renderbuffers, and sometimes with
 * textures, we may want the surface to point at a texture image level that
 * isn't at a page boundary.
 *
 * This function returns an appropriately-aligned base offset
 * according to the tiling restrictions, plus any required x/y offset
 * from there.
 */
uint32_t
intel_miptree_get_tile_offsets(struct intel_mipmap_tree *mt,
                               GLuint level, GLuint slice,
                               uint32_t *tile_x,
                               uint32_t *tile_y)
{
   struct intel_region *region = mt->region;
   uint32_t x, y;
   uint32_t mask_x, mask_y;

   intel_region_get_tile_masks(region, &mask_x, &mask_y, false);
   intel_miptree_get_image_offset(mt, level, slice, &x, &y);

   *tile_x = x & mask_x;
   *tile_y = y & mask_y;

   return intel_region_get_aligned_offset(region, x & ~mask_x, y & ~mask_y,
                                          false);
}

static void
intel_miptree_copy_slice_sw(struct brw_context *brw,
                            struct intel_mipmap_tree *dst_mt,
                            struct intel_mipmap_tree *src_mt,
                            int level,
                            int slice,
                            int width,
                            int height)
{
   void *src, *dst;
   int src_stride, dst_stride;
   int cpp = dst_mt->cpp;

   intel_miptree_map(brw, src_mt,
                     level, slice,
                     0, 0,
                     width, height,
                     GL_MAP_READ_BIT | BRW_MAP_DIRECT_BIT,
                     &src, &src_stride);

   intel_miptree_map(brw, dst_mt,
                     level, slice,
                     0, 0,
                     width, height,
                     GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_RANGE_BIT |
                     BRW_MAP_DIRECT_BIT,
                     &dst, &dst_stride);

   DBG("sw blit %s mt %p %p/%d -> %s mt %p %p/%d (%dx%d)\n",
       _mesa_get_format_name(src_mt->format),
       src_mt, src, src_stride,
       _mesa_get_format_name(dst_mt->format),
       dst_mt, dst, dst_stride,
       width, height);

   int row_size = cpp * width;
   if (src_stride == row_size &&
       dst_stride == row_size) {
      memcpy(dst, src, row_size * height);
   } else {
      for (int i = 0; i < height; i++) {
         memcpy(dst, src, row_size);
         dst += dst_stride;
         src += src_stride;
      }
   }

   intel_miptree_unmap(brw, dst_mt, level, slice);
   intel_miptree_unmap(brw, src_mt, level, slice);

   /* Don't forget to copy the stencil data over, too.  We could have skipped
    * passing BRW_MAP_DIRECT_BIT, but that would have meant intel_miptree_map
    * shuffling the two data sources in/out of temporary storage instead of
    * the direct mapping we get this way.
    */
   if (dst_mt->stencil_mt) {
      assert(src_mt->stencil_mt);
      intel_miptree_copy_slice_sw(brw, dst_mt->stencil_mt, src_mt->stencil_mt,
                                  level, slice, width, height);
   }
}
d149 1
a149 30
static void
intel_miptree_copy_slice(struct brw_context *brw,
			 struct intel_mipmap_tree *dst_mt,
			 struct intel_mipmap_tree *src_mt,
			 int level,
			 int face,
			 int depth)

{
   gl_format format = src_mt->format;
   uint32_t width = src_mt->level[level].width;
   uint32_t height = src_mt->level[level].height;
   int slice;

   if (face > 0)
      slice = face;
   else
      slice = depth;

   assert(depth < src_mt->level[level].depth);
   assert(src_mt->format == dst_mt->format);

   if (dst_mt->compressed) {
      height = ALIGN(height, dst_mt->align_h) / dst_mt->align_h;
      width = ALIGN(width, dst_mt->align_w);
   }

   /* If it's a packed depth/stencil buffer with separate stencil, the blit
    * below won't apply since we can't do the depth's Y tiling or the
    * stencil's W tiling in the blitter.
d151 3
a153 6
   if (src_mt->stencil_mt) {
      intel_miptree_copy_slice_sw(brw,
                                  dst_mt, src_mt,
                                  level, slice,
                                  width, height);
      return;
d156 3
a158 20
   uint32_t dst_x, dst_y, src_x, src_y;
   intel_miptree_get_image_offset(dst_mt, level, slice, &dst_x, &dst_y);
   intel_miptree_get_image_offset(src_mt, level, slice, &src_x, &src_y);

   DBG("validate blit mt %s %p %d,%d/%d -> mt %s %p %d,%d/%d (%dx%d)\n",
       _mesa_get_format_name(src_mt->format),
       src_mt, src_x, src_y, src_mt->region->pitch,
       _mesa_get_format_name(dst_mt->format),
       dst_mt, dst_x, dst_y, dst_mt->region->pitch,
       width, height);

   if (!intel_miptree_blit(brw,
                           src_mt, level, slice, 0, 0, false,
                           dst_mt, level, slice, 0, 0, false,
                           width, height, GL_COPY)) {
      perf_debug("miptree validate blit for %s failed\n",
                 _mesa_get_format_name(format));

      intel_miptree_copy_slice_sw(brw, dst_mt, src_mt, level, slice,
                                  width, height);
a161 26
/**
 * Copies the image's current data to the given miptree, and associates that
 * miptree with the image.
 *
 * If \c invalidate is true, then the actual image data does not need to be
 * copied, but the image still needs to be associated to the new miptree (this
 * is set to true if we're about to clear the image).
 */
void
intel_miptree_copy_teximage(struct brw_context *brw,
			    struct intel_texture_image *intelImage,
			    struct intel_mipmap_tree *dst_mt,
                            bool invalidate)
{
   struct intel_mipmap_tree *src_mt = intelImage->mt;
   struct intel_texture_object *intel_obj =
      intel_texture_object(intelImage->base.Base.TexObject);
   int level = intelImage->base.Base.Level;
   int face = intelImage->base.Base.Face;
   GLuint depth = intelImage->base.Base.Depth;

   if (!invalidate) {
      for (int slice = 0; slice < depth; slice++) {
         intel_miptree_copy_slice(brw, dst_mt, src_mt, level, face, slice);
      }
   }
a162 3
   intel_miptree_reference(&intelImage->mt, dst_mt);
   intel_obj->needs_validate = true;
}
d164 4
a167 4
bool
intel_miptree_alloc_mcs(struct brw_context *brw,
                        struct intel_mipmap_tree *mt,
                        GLuint num_samples)
d169 2
a170 2
   assert(brw->gen >= 7); /* MCS only used on Gen7+ */
   assert(mt->mcs_mt == NULL);
d172 2
a173 54
   /* Choose the correct format for the MCS buffer.  All that really matters
    * is that we allocate the right buffer size, since we'll always be
    * accessing this miptree using MCS-specific hardware mechanisms, which
    * infer the correct format based on num_samples.
    */
   gl_format format;
   switch (num_samples) {
   case 4:
      /* 8 bits/pixel are required for MCS data when using 4x MSAA (2 bits for
       * each sample).
       */
      format = MESA_FORMAT_R8;
      break;
   case 8:
      /* 32 bits/pixel are required for MCS data when using 8x MSAA (3 bits
       * for each sample, plus 8 padding bits).
       */
      format = MESA_FORMAT_R_UINT32;
      break;
   default:
      assert(!"Unrecognized sample count in intel_miptree_alloc_mcs");
      return false;
   };

   /* From the Ivy Bridge PRM, Vol4 Part1 p76, "MCS Base Address":
    *
    *     "The MCS surface must be stored as Tile Y."
    */
   mt->mcs_state = INTEL_MCS_STATE_MSAA;
   mt->mcs_mt = intel_miptree_create(brw,
                                     mt->target,
                                     format,
                                     mt->first_level,
                                     mt->last_level,
                                     mt->logical_width0,
                                     mt->logical_height0,
                                     mt->logical_depth0,
                                     true,
                                     0 /* num_samples */,
                                     INTEL_MIPTREE_TILING_Y);

   /* From the Ivy Bridge PRM, Vol 2 Part 1 p326:
    *
    *     When MCS buffer is enabled and bound to MSRT, it is required that it
    *     is cleared prior to any rendering.
    *
    * Since we don't use the MCS buffer for any purpose other than rendering,
    * it makes sense to just clear it immediately upon allocation.
    *
    * Note: the clear value for MCS buffers is all 1's, so we memset to 0xff.
    */
   void *data = intel_miptree_map_raw(brw, mt->mcs_mt);
   memset(data, 0xff, mt->mcs_mt->region->bo->size);
   intel_miptree_unmap_raw(brw, mt->mcs_mt);
d175 2
a176 1
   return mt->mcs_mt;
d180 3
a182 411
bool
intel_miptree_alloc_non_msrt_mcs(struct brw_context *brw,
                                 struct intel_mipmap_tree *mt)
{
   assert(mt->mcs_mt == NULL);

   /* The format of the MCS buffer is opaque to the driver; all that matters
    * is that we get its size and pitch right.  We'll pretend that the format
    * is R32.  Since an MCS tile covers 128 blocks horizontally, and a Y-tiled
    * R32 buffer is 32 pixels across, we'll need to scale the width down by
    * the block width and then a further factor of 4.  Since an MCS tile
    * covers 256 blocks vertically, and a Y-tiled R32 buffer is 32 rows high,
    * we'll need to scale the height down by the block height and then a
    * further factor of 8.
    */
   const gl_format format = MESA_FORMAT_R_UINT32;
   unsigned block_width_px;
   unsigned block_height;
   intel_get_non_msrt_mcs_alignment(brw, mt, &block_width_px, &block_height);
   unsigned width_divisor = block_width_px * 4;
   unsigned height_divisor = block_height * 8;
   unsigned mcs_width =
      ALIGN(mt->logical_width0, width_divisor) / width_divisor;
   unsigned mcs_height =
      ALIGN(mt->logical_height0, height_divisor) / height_divisor;
   assert(mt->logical_depth0 == 1);
   mt->mcs_mt = intel_miptree_create(brw,
                                     mt->target,
                                     format,
                                     mt->first_level,
                                     mt->last_level,
                                     mcs_width,
                                     mcs_height,
                                     mt->logical_depth0,
                                     true,
                                     0 /* num_samples */,
                                     INTEL_MIPTREE_TILING_Y);

   return mt->mcs_mt;
}


/**
 * Helper for intel_miptree_alloc_hiz() that sets
 * \c mt->level[level].slice[layer].has_hiz. Return true if and only if
 * \c has_hiz was set.
 */
static bool
intel_miptree_slice_enable_hiz(struct brw_context *brw,
                               struct intel_mipmap_tree *mt,
                               uint32_t level,
                               uint32_t layer)
{
   assert(mt->hiz_mt);

   if (brw->is_haswell) {
      /* Disable HiZ for some slices to work around a hardware bug.
       *
       * Haswell hardware fails to respect
       * 3DSTATE_DEPTH_BUFFER.Depth_Coordinate_Offset_X/Y when during HiZ
       * ambiguate operations.  The failure is inconsistent and affected by
       * other GPU contexts. Running a heavy GPU workload in a separate
       * process causes the failure rate to drop to nearly 0.
       *
       * To workaround the bug, we enable HiZ only when we can guarantee that
       * the Depth Coordinate Offset fields will be set to 0. The function
       * brw_get_depthstencil_tile_masks() is used to calculate the fields,
       * and the function is sometimes called in such a way that the presence
       * of an attached stencil buffer changes the fuction's return value.
       *
       * The largest tile size considered by brw_get_depthstencil_tile_masks()
       * is that of the stencil buffer. Therefore, if this hiz slice's
       * corresponding depth slice has an offset that is aligned to the
       * stencil buffer tile size, 64x64 pixels, then
       * 3DSTATE_DEPTH_BUFFER.Depth_Coordinate_Offset_X/Y is set to 0.
       */
      uint32_t depth_x_offset = mt->level[level].slice[layer].x_offset;
      uint32_t depth_y_offset = mt->level[level].slice[layer].y_offset;
      if ((depth_x_offset & 63) || (depth_y_offset & 63)) {
         return false;
      }
   }

   mt->level[level].slice[layer].has_hiz = true;
   return true;
}



bool
intel_miptree_alloc_hiz(struct brw_context *brw,
			struct intel_mipmap_tree *mt)
{
   assert(mt->hiz_mt == NULL);
   mt->hiz_mt = intel_miptree_create(brw,
                                     mt->target,
                                     mt->format,
                                     mt->first_level,
                                     mt->last_level,
                                     mt->logical_width0,
                                     mt->logical_height0,
                                     mt->logical_depth0,
                                     true,
                                     mt->num_samples,
                                     INTEL_MIPTREE_TILING_ANY);

   if (!mt->hiz_mt)
      return false;

   /* Mark that all slices need a HiZ resolve. */
   struct intel_resolve_map *head = &mt->hiz_map;
   for (int level = mt->first_level; level <= mt->last_level; ++level) {
      for (int layer = 0; layer < mt->level[level].depth; ++layer) {
         if (!intel_miptree_slice_enable_hiz(brw, mt, level, layer))
            continue;

	 head->next = malloc(sizeof(*head->next));
	 head->next->prev = head;
	 head->next->next = NULL;
	 head = head->next;

	 head->level = level;
	 head->layer = layer;
	 head->need = GEN6_HIZ_OP_HIZ_RESOLVE;
      }
   }

   return true;
}

/**
 * Does the miptree slice have hiz enabled?
 */
bool
intel_miptree_slice_has_hiz(struct intel_mipmap_tree *mt,
                            uint32_t level,
                            uint32_t layer)
{
   intel_miptree_check_level_layer(mt, level, layer);
   return mt->level[level].slice[layer].has_hiz;
}

void
intel_miptree_slice_set_needs_hiz_resolve(struct intel_mipmap_tree *mt,
					  uint32_t level,
					  uint32_t layer)
{
   if (!intel_miptree_slice_has_hiz(mt, level, layer))
      return;

   intel_resolve_map_set(&mt->hiz_map,
			 level, layer, GEN6_HIZ_OP_HIZ_RESOLVE);
}


void
intel_miptree_slice_set_needs_depth_resolve(struct intel_mipmap_tree *mt,
                                            uint32_t level,
                                            uint32_t layer)
{
   if (!intel_miptree_slice_has_hiz(mt, level, layer))
      return;

   intel_resolve_map_set(&mt->hiz_map,
			 level, layer, GEN6_HIZ_OP_DEPTH_RESOLVE);
}

static bool
intel_miptree_slice_resolve(struct brw_context *brw,
			    struct intel_mipmap_tree *mt,
			    uint32_t level,
			    uint32_t layer,
			    enum gen6_hiz_op need)
{
   intel_miptree_check_level_layer(mt, level, layer);

   struct intel_resolve_map *item =
	 intel_resolve_map_get(&mt->hiz_map, level, layer);

   if (!item || item->need != need)
      return false;

   intel_hiz_exec(brw, mt, level, layer, need);
   intel_resolve_map_remove(item);
   return true;
}

bool
intel_miptree_slice_resolve_hiz(struct brw_context *brw,
				struct intel_mipmap_tree *mt,
				uint32_t level,
				uint32_t layer)
{
   return intel_miptree_slice_resolve(brw, mt, level, layer,
				      GEN6_HIZ_OP_HIZ_RESOLVE);
}

bool
intel_miptree_slice_resolve_depth(struct brw_context *brw,
				  struct intel_mipmap_tree *mt,
				  uint32_t level,
				  uint32_t layer)
{
   return intel_miptree_slice_resolve(brw, mt, level, layer,
				      GEN6_HIZ_OP_DEPTH_RESOLVE);
}

static bool
intel_miptree_all_slices_resolve(struct brw_context *brw,
				 struct intel_mipmap_tree *mt,
				 enum gen6_hiz_op need)
{
   bool did_resolve = false;
   struct intel_resolve_map *i, *next;

   for (i = mt->hiz_map.next; i; i = next) {
      next = i->next;
      if (i->need != need)
	 continue;

      intel_hiz_exec(brw, mt, i->level, i->layer, need);
      intel_resolve_map_remove(i);
      did_resolve = true;
   }

   return did_resolve;
}

bool
intel_miptree_all_slices_resolve_hiz(struct brw_context *brw,
				     struct intel_mipmap_tree *mt)
{
   return intel_miptree_all_slices_resolve(brw, mt,
					   GEN6_HIZ_OP_HIZ_RESOLVE);
}

bool
intel_miptree_all_slices_resolve_depth(struct brw_context *brw,
				       struct intel_mipmap_tree *mt)
{
   return intel_miptree_all_slices_resolve(brw, mt,
					   GEN6_HIZ_OP_DEPTH_RESOLVE);
}


void
intel_miptree_resolve_color(struct brw_context *brw,
                            struct intel_mipmap_tree *mt)
{
   switch (mt->mcs_state) {
   case INTEL_MCS_STATE_NONE:
   case INTEL_MCS_STATE_MSAA:
   case INTEL_MCS_STATE_RESOLVED:
      /* No resolve needed */
      break;
   case INTEL_MCS_STATE_UNRESOLVED:
   case INTEL_MCS_STATE_CLEAR:
      brw_blorp_resolve_color(brw, mt);
      break;
   }
}


/**
 * Make it possible to share the region backing the given miptree with another
 * process or another miptree.
 *
 * Fast color clears are unsafe with shared buffers, so we need to resolve and
 * then discard the MCS buffer, if present.  We also set the mcs_state to
 * INTEL_MCS_STATE_NONE to ensure that no MCS buffer gets allocated in the
 * future.
 */
void
intel_miptree_make_shareable(struct brw_context *brw,
                             struct intel_mipmap_tree *mt)
{
   /* MCS buffers are also used for multisample buffers, but we can't resolve
    * away a multisample MCS buffer because it's an integral part of how the
    * pixel data is stored.  Fortunately this code path should never be
    * reached for multisample buffers.
    */
   assert(mt->msaa_layout == INTEL_MSAA_LAYOUT_NONE);

   if (mt->mcs_mt) {
      intel_miptree_resolve_color(brw, mt);
      intel_miptree_release(&mt->mcs_mt);
      mt->mcs_state = INTEL_MCS_STATE_NONE;
   }
}


/**
 * \brief Get pointer offset into stencil buffer.
 *
 * The stencil buffer is W tiled. Since the GTT is incapable of W fencing, we
 * must decode the tile's layout in software.
 *
 * See
 *   - PRM, 2011 Sandy Bridge, Volume 1, Part 2, Section 4.5.2.1 W-Major Tile
 *     Format.
 *   - PRM, 2011 Sandy Bridge, Volume 1, Part 2, Section 4.5.3 Tiling Algorithm
 *
 * Even though the returned offset is always positive, the return type is
 * signed due to
 *    commit e8b1c6d6f55f5be3bef25084fdd8b6127517e137
 *    mesa: Fix return type of  _mesa_get_format_bytes() (#37351)
 */
static intptr_t
intel_offset_S8(uint32_t stride, uint32_t x, uint32_t y, bool swizzled)
{
   uint32_t tile_size = 4096;
   uint32_t tile_width = 64;
   uint32_t tile_height = 64;
   uint32_t row_size = 64 * stride;

   uint32_t tile_x = x / tile_width;
   uint32_t tile_y = y / tile_height;

   /* The byte's address relative to the tile's base addres. */
   uint32_t byte_x = x % tile_width;
   uint32_t byte_y = y % tile_height;

   uintptr_t u = tile_y * row_size
               + tile_x * tile_size
               + 512 * (byte_x / 8)
               +  64 * (byte_y / 8)
               +  32 * ((byte_y / 4) % 2)
               +  16 * ((byte_x / 4) % 2)
               +   8 * ((byte_y / 2) % 2)
               +   4 * ((byte_x / 2) % 2)
               +   2 * (byte_y % 2)
               +   1 * (byte_x % 2);

   if (swizzled) {
      /* adjust for bit6 swizzling */
      if (((byte_x / 8) % 2) == 1) {
	 if (((byte_y / 8) % 2) == 0) {
	    u += 64;
	 } else {
	    u -= 64;
	 }
      }
   }

   return u;
}

static void
intel_miptree_updownsample(struct brw_context *brw,
                           struct intel_mipmap_tree *src,
                           struct intel_mipmap_tree *dst,
                           unsigned width,
                           unsigned height)
{
   int src_x0 = 0;
   int src_y0 = 0;
   int dst_x0 = 0;
   int dst_y0 = 0;

   brw_blorp_blit_miptrees(brw,
                           src, 0 /* level */, 0 /* layer */,
                           dst, 0 /* level */, 0 /* layer */,
                           src_x0, src_y0,
                           width, height,
                           dst_x0, dst_y0,
                           width, height,
                           false, false /*mirror x, y*/);

   if (src->stencil_mt) {
      brw_blorp_blit_miptrees(brw,
                              src->stencil_mt, 0 /* level */, 0 /* layer */,
                              dst->stencil_mt, 0 /* level */, 0 /* layer */,
                              src_x0, src_y0,
                              width, height,
                              dst_x0, dst_y0,
                              width, height,
                              false, false /*mirror x, y*/);
   }
}

static void
assert_is_flat(struct intel_mipmap_tree *mt)
{
   assert(mt->target == GL_TEXTURE_2D);
   assert(mt->first_level == 0);
   assert(mt->last_level == 0);
}

/**
 * \brief Downsample from mt to mt->singlesample_mt.
 *
 * If the miptree needs no downsample, then skip.
 */
void
intel_miptree_downsample(struct brw_context *brw,
                         struct intel_mipmap_tree *mt)
{
   /* Only flat, renderbuffer-like miptrees are supported. */
   assert_is_flat(mt);

   if (!mt->need_downsample)
      return;
   intel_miptree_updownsample(brw,
                              mt, mt->singlesample_mt,
                              mt->logical_width0,
                              mt->logical_height0);
   mt->need_downsample = false;
}

/**
 * \brief Upsample from mt->singlesample_mt to mt.
d184 1
a184 1
 * The upsample is done unconditionally.
d186 2
a187 3
void
intel_miptree_upsample(struct brw_context *brw,
                       struct intel_mipmap_tree *mt)
d189 1
a189 9
   /* Only flat, renderbuffer-like miptrees are supported. */
   assert_is_flat(mt);
   assert(!mt->need_downsample);

   intel_miptree_updownsample(brw,
                              mt->singlesample_mt, mt,
                              mt->logical_width0,
                              mt->logical_height0);
}
d191 3
a193 21
void *
intel_miptree_map_raw(struct brw_context *brw, struct intel_mipmap_tree *mt)
{
   struct gl_context *ctx = &brw->ctx;
   /* CPU accesses to color buffers don't understand fast color clears, so
    * resolve any pending fast color clears before we map.
    */
   intel_miptree_resolve_color(brw, mt);

   drm_intel_bo *bo = mt->region->bo;

   if (unlikely(INTEL_DEBUG & DEBUG_PERF)) {
      if (drm_intel_bo_busy(bo)) {
         perf_debug("Mapping a busy BO, causing a stall on the GPU.\n");
      }
   }

   intel_flush(ctx);

   if (mt->region->tiling != I915_TILING_NONE)
      drm_intel_gem_bo_map_gtt(bo);
d195 1
a195 10
      drm_intel_bo_map(bo, true);

   return bo->virtual;
}

void
intel_miptree_unmap_raw(struct brw_context *brw,
                        struct intel_mipmap_tree *mt)
{
   drm_intel_bo_unmap(mt->region->bo);
a197 208
static void
intel_miptree_map_gtt(struct brw_context *brw,
		      struct intel_mipmap_tree *mt,
		      struct intel_miptree_map *map,
		      unsigned int level, unsigned int slice)
{
   unsigned int bw, bh;
   void *base;
   unsigned int image_x, image_y;
   int x = map->x;
   int y = map->y;

   /* For compressed formats, the stride is the number of bytes per
    * row of blocks.  intel_miptree_get_image_offset() already does
    * the divide.
    */
   _mesa_get_format_block_size(mt->format, &bw, &bh);
   assert(y % bh == 0);
   y /= bh;

   base = intel_miptree_map_raw(brw, mt) + mt->offset;

   if (base == NULL)
      map->ptr = NULL;
   else {
      /* Note that in the case of cube maps, the caller must have passed the
       * slice number referencing the face.
      */
      intel_miptree_get_image_offset(mt, level, slice, &image_x, &image_y);
      x += image_x;
      y += image_y;

      map->stride = mt->region->pitch;
      map->ptr = base + y * map->stride + x * mt->cpp;
   }

   DBG("%s: %d,%d %dx%d from mt %p (%s) %d,%d = %p/%d\n", __FUNCTION__,
       map->x, map->y, map->w, map->h,
       mt, _mesa_get_format_name(mt->format),
       x, y, map->ptr, map->stride);
}

static void
intel_miptree_unmap_gtt(struct brw_context *brw,
			struct intel_mipmap_tree *mt,
			struct intel_miptree_map *map,
			unsigned int level,
			unsigned int slice)
{
   intel_miptree_unmap_raw(brw, mt);
}

static void
intel_miptree_map_blit(struct brw_context *brw,
		       struct intel_mipmap_tree *mt,
		       struct intel_miptree_map *map,
		       unsigned int level, unsigned int slice)
{
   map->mt = intel_miptree_create(brw, GL_TEXTURE_2D, mt->format,
                                  0, 0,
                                  map->w, map->h, 1,
                                  false, 0,
                                  INTEL_MIPTREE_TILING_NONE);
   if (!map->mt) {
      fprintf(stderr, "Failed to allocate blit temporary\n");
      goto fail;
   }
   map->stride = map->mt->region->pitch;

   if (!intel_miptree_blit(brw,
                           mt, level, slice,
                           map->x, map->y, false,
                           map->mt, 0, 0,
                           0, 0, false,
                           map->w, map->h, GL_COPY)) {
      fprintf(stderr, "Failed to blit\n");
      goto fail;
   }

   intel_batchbuffer_flush(brw);
   map->ptr = intel_miptree_map_raw(brw, map->mt);

   DBG("%s: %d,%d %dx%d from mt %p (%s) %d,%d = %p/%d\n", __FUNCTION__,
       map->x, map->y, map->w, map->h,
       mt, _mesa_get_format_name(mt->format),
       level, slice, map->ptr, map->stride);

   return;

fail:
   intel_miptree_release(&map->mt);
   map->ptr = NULL;
   map->stride = 0;
}

static void
intel_miptree_unmap_blit(struct brw_context *brw,
			 struct intel_mipmap_tree *mt,
			 struct intel_miptree_map *map,
			 unsigned int level,
			 unsigned int slice)
{
   struct gl_context *ctx = &brw->ctx;

   intel_miptree_unmap_raw(brw, map->mt);

   if (map->mode & GL_MAP_WRITE_BIT) {
      bool ok = intel_miptree_blit(brw,
                                   map->mt, 0, 0,
                                   0, 0, false,
                                   mt, level, slice,
                                   map->x, map->y, false,
                                   map->w, map->h, GL_COPY);
      WARN_ONCE(!ok, "Failed to blit from linear temporary mapping");
   }

   intel_miptree_release(&map->mt);
}

static void
intel_miptree_map_s8(struct brw_context *brw,
		     struct intel_mipmap_tree *mt,
		     struct intel_miptree_map *map,
		     unsigned int level, unsigned int slice)
{
   map->stride = map->w;
   map->buffer = map->ptr = malloc(map->stride * map->h);
   if (!map->buffer)
      return;

   /* One of either READ_BIT or WRITE_BIT or both is set.  READ_BIT implies no
    * INVALIDATE_RANGE_BIT.  WRITE_BIT needs the original values read in unless
    * invalidate is set, since we'll be writing the whole rectangle from our
    * temporary buffer back out.
    */
   if (!(map->mode & GL_MAP_INVALIDATE_RANGE_BIT)) {
      uint8_t *untiled_s8_map = map->ptr;
      uint8_t *tiled_s8_map = intel_miptree_map_raw(brw, mt);
      unsigned int image_x, image_y;

      intel_miptree_get_image_offset(mt, level, slice, &image_x, &image_y);

      for (uint32_t y = 0; y < map->h; y++) {
	 for (uint32_t x = 0; x < map->w; x++) {
	    ptrdiff_t offset = intel_offset_S8(mt->region->pitch,
	                                       x + image_x + map->x,
	                                       y + image_y + map->y,
					       brw->has_swizzling);
	    untiled_s8_map[y * map->w + x] = tiled_s8_map[offset];
	 }
      }

      intel_miptree_unmap_raw(brw, mt);

      DBG("%s: %d,%d %dx%d from mt %p %d,%d = %p/%d\n", __FUNCTION__,
	  map->x, map->y, map->w, map->h,
	  mt, map->x + image_x, map->y + image_y, map->ptr, map->stride);
   } else {
      DBG("%s: %d,%d %dx%d from mt %p = %p/%d\n", __FUNCTION__,
	  map->x, map->y, map->w, map->h,
	  mt, map->ptr, map->stride);
   }
}

static void
intel_miptree_unmap_s8(struct brw_context *brw,
		       struct intel_mipmap_tree *mt,
		       struct intel_miptree_map *map,
		       unsigned int level,
		       unsigned int slice)
{
   if (map->mode & GL_MAP_WRITE_BIT) {
      unsigned int image_x, image_y;
      uint8_t *untiled_s8_map = map->ptr;
      uint8_t *tiled_s8_map = intel_miptree_map_raw(brw, mt);

      intel_miptree_get_image_offset(mt, level, slice, &image_x, &image_y);

      for (uint32_t y = 0; y < map->h; y++) {
	 for (uint32_t x = 0; x < map->w; x++) {
	    ptrdiff_t offset = intel_offset_S8(mt->region->pitch,
	                                       x + map->x,
	                                       y + map->y,
					       brw->has_swizzling);
	    tiled_s8_map[offset] = untiled_s8_map[y * map->w + x];
	 }
      }

      intel_miptree_unmap_raw(brw, mt);
   }

   free(map->buffer);
}

static void
intel_miptree_map_etc(struct brw_context *brw,
                      struct intel_mipmap_tree *mt,
                      struct intel_miptree_map *map,
                      unsigned int level,
                      unsigned int slice)
{
   assert(mt->etc_format != MESA_FORMAT_NONE);
   if (mt->etc_format == MESA_FORMAT_ETC1_RGB8) {
      assert(mt->format == MESA_FORMAT_RGBX8888_REV);
   }

   assert(map->mode & GL_MAP_WRITE_BIT);
   assert(map->mode & GL_MAP_INVALIDATE_RANGE_BIT);
d199 3
a201 12
   map->stride = _mesa_format_row_stride(mt->etc_format, map->w);
   map->buffer = malloc(_mesa_format_image_size(mt->etc_format,
                                                map->w, map->h, 1));
   map->ptr = map->buffer;
}

static void
intel_miptree_unmap_etc(struct brw_context *brw,
                        struct intel_mipmap_tree *mt,
                        struct intel_miptree_map *map,
                        unsigned int level,
                        unsigned int slice)
d203 3
a205 15
   uint32_t image_x;
   uint32_t image_y;
   intel_miptree_get_image_offset(mt, level, slice, &image_x, &image_y);

   image_x += map->x;
   image_y += map->y;

   uint8_t *dst = intel_miptree_map_raw(brw, mt)
                + image_y * mt->region->pitch
                + image_x * mt->region->cpp;

   if (mt->etc_format == MESA_FORMAT_ETC1_RGB8)
      _mesa_etc1_unpack_rgba8888(dst, mt->region->pitch,
                                 map->ptr, map->stride,
                                 map->w, map->h);
d207 1
a207 147
      _mesa_unpack_etc2_format(dst, mt->region->pitch,
                               map->ptr, map->stride,
                               map->w, map->h, mt->etc_format);

   intel_miptree_unmap_raw(brw, mt);
   free(map->buffer);
}

/**
 * Mapping function for packed depth/stencil miptrees backed by real separate
 * miptrees for depth and stencil.
 *
 * On gen7, and to support HiZ pre-gen7, we have to have the stencil buffer
 * separate from the depth buffer.  Yet at the GL API level, we have to expose
 * packed depth/stencil textures and FBO attachments, and Mesa core expects to
 * be able to map that memory for texture storage and glReadPixels-type
 * operations.  We give Mesa core that access by mallocing a temporary and
 * copying the data between the actual backing store and the temporary.
 */
static void
intel_miptree_map_depthstencil(struct brw_context *brw,
			       struct intel_mipmap_tree *mt,
			       struct intel_miptree_map *map,
			       unsigned int level, unsigned int slice)
{
   struct intel_mipmap_tree *z_mt = mt;
   struct intel_mipmap_tree *s_mt = mt->stencil_mt;
   bool map_z32f_x24s8 = mt->format == MESA_FORMAT_Z32_FLOAT;
   int packed_bpp = map_z32f_x24s8 ? 8 : 4;

   map->stride = map->w * packed_bpp;
   map->buffer = map->ptr = malloc(map->stride * map->h);
   if (!map->buffer)
      return;

   /* One of either READ_BIT or WRITE_BIT or both is set.  READ_BIT implies no
    * INVALIDATE_RANGE_BIT.  WRITE_BIT needs the original values read in unless
    * invalidate is set, since we'll be writing the whole rectangle from our
    * temporary buffer back out.
    */
   if (!(map->mode & GL_MAP_INVALIDATE_RANGE_BIT)) {
      uint32_t *packed_map = map->ptr;
      uint8_t *s_map = intel_miptree_map_raw(brw, s_mt);
      uint32_t *z_map = intel_miptree_map_raw(brw, z_mt);
      unsigned int s_image_x, s_image_y;
      unsigned int z_image_x, z_image_y;

      intel_miptree_get_image_offset(s_mt, level, slice,
				     &s_image_x, &s_image_y);
      intel_miptree_get_image_offset(z_mt, level, slice,
				     &z_image_x, &z_image_y);

      for (uint32_t y = 0; y < map->h; y++) {
	 for (uint32_t x = 0; x < map->w; x++) {
	    int map_x = map->x + x, map_y = map->y + y;
	    ptrdiff_t s_offset = intel_offset_S8(s_mt->region->pitch,
						 map_x + s_image_x,
						 map_y + s_image_y,
						 brw->has_swizzling);
	    ptrdiff_t z_offset = ((map_y + z_image_y) *
                                  (z_mt->region->pitch / 4) +
				  (map_x + z_image_x));
	    uint8_t s = s_map[s_offset];
	    uint32_t z = z_map[z_offset];

	    if (map_z32f_x24s8) {
	       packed_map[(y * map->w + x) * 2 + 0] = z;
	       packed_map[(y * map->w + x) * 2 + 1] = s;
	    } else {
	       packed_map[y * map->w + x] = (s << 24) | (z & 0x00ffffff);
	    }
	 }
      }

      intel_miptree_unmap_raw(brw, s_mt);
      intel_miptree_unmap_raw(brw, z_mt);

      DBG("%s: %d,%d %dx%d from z mt %p %d,%d, s mt %p %d,%d = %p/%d\n",
	  __FUNCTION__,
	  map->x, map->y, map->w, map->h,
	  z_mt, map->x + z_image_x, map->y + z_image_y,
	  s_mt, map->x + s_image_x, map->y + s_image_y,
	  map->ptr, map->stride);
   } else {
      DBG("%s: %d,%d %dx%d from mt %p = %p/%d\n", __FUNCTION__,
	  map->x, map->y, map->w, map->h,
	  mt, map->ptr, map->stride);
   }
}

static void
intel_miptree_unmap_depthstencil(struct brw_context *brw,
				 struct intel_mipmap_tree *mt,
				 struct intel_miptree_map *map,
				 unsigned int level,
				 unsigned int slice)
{
   struct intel_mipmap_tree *z_mt = mt;
   struct intel_mipmap_tree *s_mt = mt->stencil_mt;
   bool map_z32f_x24s8 = mt->format == MESA_FORMAT_Z32_FLOAT;

   if (map->mode & GL_MAP_WRITE_BIT) {
      uint32_t *packed_map = map->ptr;
      uint8_t *s_map = intel_miptree_map_raw(brw, s_mt);
      uint32_t *z_map = intel_miptree_map_raw(brw, z_mt);
      unsigned int s_image_x, s_image_y;
      unsigned int z_image_x, z_image_y;

      intel_miptree_get_image_offset(s_mt, level, slice,
				     &s_image_x, &s_image_y);
      intel_miptree_get_image_offset(z_mt, level, slice,
				     &z_image_x, &z_image_y);

      for (uint32_t y = 0; y < map->h; y++) {
	 for (uint32_t x = 0; x < map->w; x++) {
	    ptrdiff_t s_offset = intel_offset_S8(s_mt->region->pitch,
						 x + s_image_x + map->x,
						 y + s_image_y + map->y,
						 brw->has_swizzling);
	    ptrdiff_t z_offset = ((y + z_image_y) *
                                  (z_mt->region->pitch / 4) +
				  (x + z_image_x));

	    if (map_z32f_x24s8) {
	       z_map[z_offset] = packed_map[(y * map->w + x) * 2 + 0];
	       s_map[s_offset] = packed_map[(y * map->w + x) * 2 + 1];
	    } else {
	       uint32_t packed = packed_map[y * map->w + x];
	       s_map[s_offset] = packed >> 24;
	       z_map[z_offset] = packed;
	    }
	 }
      }

      intel_miptree_unmap_raw(brw, s_mt);
      intel_miptree_unmap_raw(brw, z_mt);

      DBG("%s: %d,%d %dx%d from z mt %p (%s) %d,%d, s mt %p %d,%d = %p/%d\n",
	  __FUNCTION__,
	  map->x, map->y, map->w, map->h,
	  z_mt, _mesa_get_format_name(z_mt->format),
	  map->x + z_image_x, map->y + z_image_y,
	  s_mt, map->x + s_image_x, map->y + s_image_y,
	  map->ptr, map->stride);
   }

   free(map->buffer);
a209 15
/**
 * Create and attach a map to the miptree at (level, slice). Return the
 * attached map.
 */
static struct intel_miptree_map*
intel_miptree_attach_map(struct intel_mipmap_tree *mt,
                         unsigned int level,
                         unsigned int slice,
                         unsigned int x,
                         unsigned int y,
                         unsigned int w,
                         unsigned int h,
                         GLbitfield mode)
{
   struct intel_miptree_map *map = calloc(1, sizeof(*map));
a210 2
   if (!map)
      return NULL;
a211 2
   assert(mt->level[level].slice[slice].map == NULL);
   mt->level[level].slice[slice].map = map;
a212 5
   map->mode = mode;
   map->x = x;
   map->y = y;
   map->w = w;
   map->h = h;
a213 2
   return map;
}
d215 1
a215 2
/**
 * Release the map at (level, slice).
d217 7
a223 116
static void
intel_miptree_release_map(struct intel_mipmap_tree *mt,
                         unsigned int level,
                         unsigned int slice)
{
   struct intel_miptree_map **map;

   map = &mt->level[level].slice[slice].map;
   free(*map);
   *map = NULL;
}

static void
intel_miptree_map_singlesample(struct brw_context *brw,
                               struct intel_mipmap_tree *mt,
                               unsigned int level,
                               unsigned int slice,
                               unsigned int x,
                               unsigned int y,
                               unsigned int w,
                               unsigned int h,
                               GLbitfield mode,
                               void **out_ptr,
                               int *out_stride)
{
   struct intel_miptree_map *map;

   assert(mt->num_samples <= 1);

   map = intel_miptree_attach_map(mt, level, slice, x, y, w, h, mode);
   if (!map){
      *out_ptr = NULL;
      *out_stride = 0;
      return;
   }

   intel_miptree_slice_resolve_depth(brw, mt, level, slice);
   if (map->mode & GL_MAP_WRITE_BIT) {
      intel_miptree_slice_set_needs_hiz_resolve(mt, level, slice);
   }

   if (mt->format == MESA_FORMAT_S8) {
      intel_miptree_map_s8(brw, mt, map, level, slice);
   } else if (mt->etc_format != MESA_FORMAT_NONE &&
              !(mode & BRW_MAP_DIRECT_BIT)) {
      intel_miptree_map_etc(brw, mt, map, level, slice);
   } else if (mt->stencil_mt && !(mode & BRW_MAP_DIRECT_BIT)) {
      intel_miptree_map_depthstencil(brw, mt, map, level, slice);
   }
   /* See intel_miptree_blit() for details on the 32k pitch limit. */
   else if (brw->has_llc &&
            !(mode & GL_MAP_WRITE_BIT) &&
            !mt->compressed &&
            (mt->region->tiling == I915_TILING_X ||
             (brw->gen >= 6 && mt->region->tiling == I915_TILING_Y)) &&
            mt->region->pitch < 32768) {
      intel_miptree_map_blit(brw, mt, map, level, slice);
   } else if (mt->region->tiling != I915_TILING_NONE &&
              mt->region->bo->size >= brw->max_gtt_map_object_size) {
      assert(mt->region->pitch < 32768);
      intel_miptree_map_blit(brw, mt, map, level, slice);
   } else {
      intel_miptree_map_gtt(brw, mt, map, level, slice);
   }

   *out_ptr = map->ptr;
   *out_stride = map->stride;

   if (map->ptr == NULL)
      intel_miptree_release_map(mt, level, slice);
}

static void
intel_miptree_unmap_singlesample(struct brw_context *brw,
                                 struct intel_mipmap_tree *mt,
                                 unsigned int level,
                                 unsigned int slice)
{
   struct intel_miptree_map *map = mt->level[level].slice[slice].map;

   assert(mt->num_samples <= 1);

   if (!map)
      return;

   DBG("%s: mt %p (%s) level %d slice %d\n", __FUNCTION__,
       mt, _mesa_get_format_name(mt->format), level, slice);

   if (mt->format == MESA_FORMAT_S8) {
      intel_miptree_unmap_s8(brw, mt, map, level, slice);
   } else if (mt->etc_format != MESA_FORMAT_NONE &&
              !(map->mode & BRW_MAP_DIRECT_BIT)) {
      intel_miptree_unmap_etc(brw, mt, map, level, slice);
   } else if (mt->stencil_mt && !(map->mode & BRW_MAP_DIRECT_BIT)) {
      intel_miptree_unmap_depthstencil(brw, mt, map, level, slice);
   } else if (map->mt) {
      intel_miptree_unmap_blit(brw, mt, map, level, slice);
   } else {
      intel_miptree_unmap_gtt(brw, mt, map, level, slice);
   }

   intel_miptree_release_map(mt, level, slice);
}

static void
intel_miptree_map_multisample(struct brw_context *brw,
                              struct intel_mipmap_tree *mt,
                              unsigned int level,
                              unsigned int slice,
                              unsigned int x,
                              unsigned int y,
                              unsigned int w,
                              unsigned int h,
                              GLbitfield mode,
                              void **out_ptr,
                              int *out_stride)
d225 4
a228 4
   struct gl_context *ctx = &brw->ctx;
   struct intel_miptree_map *map;

   assert(mt->num_samples > 1);
d230 14
a243 8
   /* Only flat, renderbuffer-like miptrees are supported. */
   if (mt->target != GL_TEXTURE_2D ||
       mt->first_level != 0 ||
       mt->last_level != 0) {
      _mesa_problem(ctx, "attempt to map a multisample miptree for "
                    "which (target, first_level, last_level != "
                    "(GL_TEXTURE_2D, 0, 0)");
      goto fail;
d245 1
a245 56

   map = intel_miptree_attach_map(mt, level, slice, x, y, w, h, mode);
   if (!map)
      goto fail;

   if (!mt->singlesample_mt) {
      mt->singlesample_mt =
         intel_miptree_create_for_renderbuffer(brw,
                                               mt->format,
                                               mt->logical_width0,
                                               mt->logical_height0,
                                               0 /*num_samples*/);
      if (!mt->singlesample_mt)
         goto fail;

      map->singlesample_mt_is_tmp = true;
      mt->need_downsample = true;
   }

   intel_miptree_downsample(brw, mt);
   intel_miptree_map_singlesample(brw, mt->singlesample_mt,
                                  level, slice,
                                  x, y, w, h,
                                  mode,
                                  out_ptr, out_stride);
   return;

fail:
   intel_miptree_release_map(mt, level, slice);
   *out_ptr = NULL;
   *out_stride = 0;
}

static void
intel_miptree_unmap_multisample(struct brw_context *brw,
                                struct intel_mipmap_tree *mt,
                                unsigned int level,
                                unsigned int slice)
{
   struct intel_miptree_map *map = mt->level[level].slice[slice].map;

   assert(mt->num_samples > 1);

   if (!map)
      return;

   intel_miptree_unmap_singlesample(brw, mt->singlesample_mt, level, slice);

   mt->need_downsample = false;
   if (map->mode & GL_MAP_WRITE_BIT)
      intel_miptree_upsample(brw, mt);

   if (map->singlesample_mt_is_tmp)
      intel_miptree_release(&mt->singlesample_mt);

   intel_miptree_release_map(mt, level, slice);
a247 38
void
intel_miptree_map(struct brw_context *brw,
		  struct intel_mipmap_tree *mt,
		  unsigned int level,
		  unsigned int slice,
		  unsigned int x,
		  unsigned int y,
		  unsigned int w,
		  unsigned int h,
		  GLbitfield mode,
		  void **out_ptr,
		  int *out_stride)
{
   if (mt->num_samples <= 1)
      intel_miptree_map_singlesample(brw, mt,
                                     level, slice,
                                     x, y, w, h,
                                     mode,
                                     out_ptr, out_stride);
   else
      intel_miptree_map_multisample(brw, mt,
                                    level, slice,
                                    x, y, w, h,
                                    mode,
                                    out_ptr, out_stride);
}

void
intel_miptree_unmap(struct brw_context *brw,
		    struct intel_mipmap_tree *mt,
		    unsigned int level,
		    unsigned int slice)
{
   if (mt->num_samples <= 1)
      intel_miptree_unmap_singlesample(brw, mt, level, slice);
   else
      intel_miptree_unmap_multisample(brw, mt, level, slice);
}
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d2 2
a3 2
 *
 * Copyright 2006 VMware, Inc.
d5 1
a5 1
 *
d13 1
a13 1
 *
d17 1
a17 1
 *
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d25 1
a25 1
 *
d34 1
a37 1
#include "intel_fbo.h"
a42 1
#include "main/fbobject.h"
a46 1
#include "main/streaming-load-memcpy.h"
d50 17
d72 1
a72 1
compute_msaa_layout(struct brw_context *brw, mesa_format format, GLenum target)
a84 8
      /* Disable MCS on Broadwell for now.  We can enable it once things
       * are working without it.
       */
      if (brw->gen >= 8) {
         perf_debug("Missing CMS support on Broadwell.\n");
         return INTEL_MSAA_LAYOUT_UMS;
      }

d101 17
a117 1
         return INTEL_MSAA_LAYOUT_CMS;
d169 1
a169 1
   switch (mt->tiling) {
d204 1
a204 1
   if (brw->gen < 7 || brw->gen >= 8)
d215 2
a216 2
   if (mt->tiling != I915_TILING_X &&
       mt->tiling != I915_TILING_Y)
a235 17
 * Determine depth format corresponding to a depth+stencil format,
 * for separate stencil.
 */
mesa_format
intel_depth_format_for_depthstencil_format(mesa_format format) {
   switch (format) {
   case MESA_FORMAT_Z24_UNORM_S8_UINT:
      return MESA_FORMAT_Z24_UNORM_X8_UINT;
   case MESA_FORMAT_Z32_FLOAT_S8X24_UINT:
      return MESA_FORMAT_Z_FLOAT32;
   default:
      return format;
   }
}


/**
d243 1
a243 1
                            mesa_format format,
d256 1
a256 1
   DBG("%s target %s format %s level %d..%d slices %d <-- %p\n", __FUNCTION__,
d259 1
a259 1
       first_level, last_level, depth0, mt);
d261 1
a261 1
   mt->target = target;
d268 1
a268 1
   mt->fast_clear_state = INTEL_FAST_CLEAR_STATE_NO_MCS;
d281 1
a281 1
   mt->refcount = 1;
a321 5
         case 2:
            assert(brw->gen >= 8);
            width0 = ALIGN(width0, 2) * 2;
            height0 = ALIGN(height0, 2);
            break;
d331 1
a331 1
            /* num_samples should already have been quantized to 0, 1, 2, 4, or
d371 1
a371 1
                                            MESA_FORMAT_S_UINT8,
d388 8
a395 6
      mt->format = intel_depth_format_for_depthstencil_format(mt->format);
      mt->cpp = 4;

      if (format == mt->format) {
         _mesa_problem(NULL, "Unknown format %s in separate stencil mt\n",
                       _mesa_get_format_name(mt->format));
d409 1
a409 1
                            mesa_format format,
d415 1
a415 1
   if (format == MESA_FORMAT_S_UINT8) {
d461 1
a461 2
   if (ALIGN(minimum_pitch, 512) >= 32768 ||
       mt->total_width >= 32768 || mt->total_height >= 32768) {
a479 17
   /* From the Ivy Bridge PRM, Vol4 Part1 2.12.2.1 (SURFACE_STATE for most
    * messages), on p64, under the heading "Surface Vertical Alignment":
    *
    *     This field must be set to VALIGN_4 for all tiled Y Render Target
    *     surfaces.
    *
    * So if the surface is renderable and uses a vertical alignment of 2,
    * force it to be X tiled.  This is somewhat conservative (it's possible
    * that the client won't ever render to this surface), but it's difficult
    * to know that ahead of time.  And besides, since we use a vertical
    * alignment of 4 as often as we can, this shouldn't happen very often.
    */
   if (brw->gen == 7 && mt->align_h == 2 &&
       brw->format_supported_as_render_target[format]) {
      return I915_TILING_X;
   }

a482 41

/**
 * Choose an appropriate uncompressed format for a requested
 * compressed format, if unsupported.
 */
mesa_format
intel_lower_compressed_format(struct brw_context *brw, mesa_format format)
{
   /* No need to lower ETC formats on these platforms,
    * they are supported natively.
    */
   if (brw->gen >= 8 || brw->is_baytrail)
      return format;

   switch (format) {
   case MESA_FORMAT_ETC1_RGB8:
      return MESA_FORMAT_R8G8B8X8_UNORM;
   case MESA_FORMAT_ETC2_RGB8:
      return MESA_FORMAT_R8G8B8X8_UNORM;
   case MESA_FORMAT_ETC2_SRGB8:
   case MESA_FORMAT_ETC2_SRGB8_ALPHA8_EAC:
   case MESA_FORMAT_ETC2_SRGB8_PUNCHTHROUGH_ALPHA1:
      return MESA_FORMAT_B8G8R8A8_SRGB;
   case MESA_FORMAT_ETC2_RGBA8_EAC:
   case MESA_FORMAT_ETC2_RGB8_PUNCHTHROUGH_ALPHA1:
      return MESA_FORMAT_R8G8B8A8_UNORM;
   case MESA_FORMAT_ETC2_R11_EAC:
      return MESA_FORMAT_R_UNORM16;
   case MESA_FORMAT_ETC2_SIGNED_R11_EAC:
      return MESA_FORMAT_R_SNORM16;
   case MESA_FORMAT_ETC2_RG11_EAC:
      return MESA_FORMAT_R16G16_UNORM;
   case MESA_FORMAT_ETC2_SIGNED_RG11_EAC:
      return MESA_FORMAT_R16G16_SNORM;
   default:
      /* Non ETC1 / ETC2 format */
      return format;
   }
}


d486 1
a486 1
		     mesa_format format,
d497 2
a498 2
   mesa_format tex_format = format;
   mesa_format etc_format = MESA_FORMAT_NONE;
d501 34
a534 1
   format = intel_lower_compressed_format(brw, format);
d553 1
a553 1
   if (format == MESA_FORMAT_S_UINT8) {
d562 1
a562 1
   bool y_or_x = false;
a563 8
   if (tiling == (I915_TILING_Y | I915_TILING_X)) {
      y_or_x = true;
      mt->tiling = I915_TILING_Y;
   } else {
      mt->tiling = tiling;
   }

   unsigned long pitch;
d565 6
a570 6
   mt->bo = drm_intel_bo_alloc_tiled(brw->bufmgr, "miptree",
                                     total_width, total_height, mt->cpp,
                                     &mt->tiling, &pitch,
                                     (expect_accelerated_upload ?
                                      BO_ALLOC_FOR_RENDER : 0));
   mt->pitch = pitch;
d572 1
a572 1
   /* If the BO is too large to fit in the aperture, we need to use the
d576 1
a576 1
   if (y_or_x && mt->bo->size >= brw->max_gtt_map_object_size) {
d579 1
d581 6
a586 8
      mt->tiling = I915_TILING_X;
      drm_intel_bo_unreference(mt->bo);
      mt->bo = drm_intel_bo_alloc_tiled(brw->bufmgr, "miptree",
                                        total_width, total_height, mt->cpp,
                                        &mt->tiling, &pitch,
                                        (expect_accelerated_upload ?
                                         BO_ALLOC_FOR_RENDER : 0));
      mt->pitch = pitch;
d591 1
a591 1
   if (!mt->bo) {
a595 8

   if (mt->msaa_layout == INTEL_MSAA_LAYOUT_CMS) {
      if (!intel_miptree_alloc_mcs(brw, mt, num_samples)) {
         intel_miptree_release(&mt);
         return NULL;
      }
   }

d597 1
a597 1
    * fast_clear_state appropriately to ensure that fast clears will occur.
d602 1
a602 1
      mt->fast_clear_state = INTEL_FAST_CLEAR_STATE_RESOLVED;
d610 1
a610 1
                            mesa_format format,
d614 2
a615 1
                            int pitch)
a617 1
   uint32_t tiling, swizzle;
d619 3
a621 1
   drm_intel_bo_get_tiling(bo, &tiling, &swizzle);
d638 1
a638 2
   if (!mt) {
      free(mt);
a639 1
   }
d641 5
d647 4
a650 2
   mt->bo = bo;
   mt->pitch = pitch;
a651 1
   mt->tiling = tiling;
d656 1
d658 1
a658 2
 * For a singlesample renderbuffer, this simply wraps the given BO with a
 * miptree.
d660 3
a662 5
 * For a multisample renderbuffer, this wraps the window system's
 * (singlesample) BO with a singlesample miptree attached to the
 * intel_renderbuffer, then creates a multisample miptree attached to irb->mt
 * that will contain the actual rendering (which is lazily resolved to
 * irb->singlesample_mt).
d664 6
a669 6
void
intel_update_winsys_renderbuffer_miptree(struct brw_context *intel,
                                         struct intel_renderbuffer *irb,
                                         drm_intel_bo *bo,
                                         uint32_t width, uint32_t height,
                                         uint32_t pitch)
a672 3
   struct gl_renderbuffer *rb = &irb->Base.Base;
   mesa_format format = rb->Format;
   int num_samples = rb->NumSamples;
d674 2
a675 2
   /* Only the front and back buffers, which are color buffers, are allocated
    * through the image loader.
d677 3
d683 2
a684 2
   singlesample_mt = intel_miptree_create_for_bo(intel,
                                                 bo,
d687 4
a690 3
                                                 width,
                                                 height,
                                                 pitch);
d692 2
a693 1
      goto fail;
d700 5
a704 2
   if (intel_is_non_msrt_mcs_buffer_supported(intel, singlesample_mt))
      singlesample_mt->fast_clear_state = INTEL_FAST_CLEAR_STATE_RESOLVED;
d706 9
a714 3
   if (num_samples == 0) {
      intel_miptree_release(&irb->mt);
      irb->mt = singlesample_mt;
d716 2
a717 4
      assert(!irb->singlesample_mt);
   } else {
      intel_miptree_release(&irb->singlesample_mt);
      irb->singlesample_mt = singlesample_mt;
d719 4
a722 15
      if (!irb->mt ||
          irb->mt->logical_width0 != width ||
          irb->mt->logical_height0 != height) {
         multisample_mt = intel_miptree_create_for_renderbuffer(intel,
                                                                format,
                                                                width,
                                                                height,
                                                                num_samples);
         if (!multisample_mt)
            goto fail;

         irb->need_downsample = false;
         intel_miptree_release(&irb->mt);
         irb->mt = multisample_mt;
      }
a723 1
   return;
d725 1
a725 4
fail:
   intel_miptree_release(&irb->singlesample_mt);
   intel_miptree_release(&irb->mt);
   return;
d730 1
a730 1
                                      mesa_format format,
a737 1
   GLenum target = num_samples > 1 ? GL_TEXTURE_2D_MULTISAMPLE : GL_TEXTURE_2D;
d739 1
a739 1
   mt = intel_miptree_create(brw, target, format, 0, 0,
d751 6
d794 1
a794 1
      drm_intel_bo_unreference((*mt)->bo);
d798 1
d846 1
a846 1
   assert(image->TexObject->Target == mt->target);
d848 5
a852 5
   mesa_format mt_format = mt->format;
   if (mt->format == MESA_FORMAT_Z24_UNORM_X8_UINT && mt->stencil_mt)
      mt_format = MESA_FORMAT_Z24_UNORM_S8_UINT;
   if (mt->format == MESA_FORMAT_Z_FLOAT32 && mt->stencil_mt)
      mt_format = MESA_FORMAT_Z32_FLOAT_S8X24_UINT;
a863 13
   int level_depth = mt->level[level].depth;
   if (mt->num_samples > 1) {
      switch (mt->msaa_layout) {
      case INTEL_MSAA_LAYOUT_NONE:
      case INTEL_MSAA_LAYOUT_IMS:
         break;
      case INTEL_MSAA_LAYOUT_UMS:
      case INTEL_MSAA_LAYOUT_CMS:
         level_depth /= mt->num_samples;
         break;
      }
   }

d868 18
a885 4
   if (width != minify(mt->logical_width0, level - mt->first_level) ||
       height != minify(mt->logical_height0, level - mt->first_level) ||
       depth != level_depth) {
      return false;
d898 2
a899 1
			     GLuint x, GLuint y, GLuint d)
d901 2
d907 2
a908 2
   DBG("%s level %d, depth %d, offset %d,%d\n", __FUNCTION__,
       level, d, x, y);
d938 1
a938 1
intel_miptree_get_image_offset(const struct intel_mipmap_tree *mt,
a948 76
 * This function computes masks that may be used to select the bits of the X
 * and Y coordinates that indicate the offset within a tile.  If the BO is
 * untiled, the masks are set to 0.
 */
void
intel_miptree_get_tile_masks(const struct intel_mipmap_tree *mt,
                             uint32_t *mask_x, uint32_t *mask_y,
                             bool map_stencil_as_y_tiled)
{
   int cpp = mt->cpp;
   uint32_t tiling = mt->tiling;

   if (map_stencil_as_y_tiled)
      tiling = I915_TILING_Y;

   switch (tiling) {
   default:
      assert(false);
   case I915_TILING_NONE:
      *mask_x = *mask_y = 0;
      break;
   case I915_TILING_X:
      *mask_x = 512 / cpp - 1;
      *mask_y = 7;
      break;
   case I915_TILING_Y:
      *mask_x = 128 / cpp - 1;
      *mask_y = 31;
      break;
   }
}

/**
 * Compute the offset (in bytes) from the start of the BO to the given x
 * and y coordinate.  For tiled BOs, caller must ensure that x and y are
 * multiples of the tile size.
 */
uint32_t
intel_miptree_get_aligned_offset(const struct intel_mipmap_tree *mt,
                                 uint32_t x, uint32_t y,
                                 bool map_stencil_as_y_tiled)
{
   int cpp = mt->cpp;
   uint32_t pitch = mt->pitch;
   uint32_t tiling = mt->tiling;

   if (map_stencil_as_y_tiled) {
      tiling = I915_TILING_Y;

      /* When mapping a W-tiled stencil buffer as Y-tiled, each 64-high W-tile
       * gets transformed into a 32-high Y-tile.  Accordingly, the pitch of
       * the resulting surface is twice the pitch of the original miptree,
       * since each row in the Y-tiled view corresponds to two rows in the
       * actual W-tiled surface.  So we need to correct the pitch before
       * computing the offsets.
       */
      pitch *= 2;
   }

   switch (tiling) {
   default:
      assert(false);
   case I915_TILING_NONE:
      return y * pitch + x * cpp;
   case I915_TILING_X:
      assert((x % (512 / cpp)) == 0);
      assert((y % 8) == 0);
      return y * pitch + x / (512 / cpp) * 4096;
   case I915_TILING_Y:
      assert((x % (128 / cpp)) == 0);
      assert((y % 32) == 0);
      return y * pitch + x / (128 / cpp) * 4096;
   }
}

/**
d959 1
a959 1
intel_miptree_get_tile_offsets(const struct intel_mipmap_tree *mt,
d964 1
d968 1
a968 1
   intel_miptree_get_tile_masks(mt, &mask_x, &mask_y, false);
d974 2
a975 1
   return intel_miptree_get_aligned_offset(mt, x & ~mask_x, y & ~mask_y, false);
d1049 3
a1051 3
   mesa_format format = src_mt->format;
   uint32_t width = minify(src_mt->physical_width0, level - src_mt->first_level);
   uint32_t height = minify(src_mt->physical_height0, level - src_mt->first_level);
d1085 1
a1085 1
       src_mt, src_x, src_y, src_mt->pitch,
d1087 1
a1087 1
       dst_mt, dst_x, dst_y, dst_mt->pitch,
d1146 1
a1146 1
   mesa_format format;
d1152 1
a1152 1
      format = MESA_FORMAT_R_UNORM8;
d1169 1
d1193 1
a1193 1
   memset(data, 0xff, mt->mcs_mt->total_height * mt->mcs_mt->pitch);
a1194 1
   mt->fast_clear_state = INTEL_FAST_CLEAR_STATE_CLEAR;
d1215 1
a1215 1
   const mesa_format format = MESA_FORMAT_R_UINT32;
d1255 20
a1274 9
   if (brw->gen >= 8 || brw->is_haswell) {
      uint32_t width = minify(mt->physical_width0, level);
      uint32_t height = minify(mt->physical_height0, level);

      /* Disable HiZ for LOD > 0 unless the width is 8 aligned
       * and the height is 4 aligned. This allows our HiZ support
       * to fulfill Haswell restrictions for HiZ ops. For LOD == 0,
       * we can grow the width & height to allow the HiZ op to
       * force the proper size alignments.
d1276 3
a1278 1
      if (level > 0 && ((width & 7) || (height & 3))) {
a1366 12
void
intel_miptree_set_all_slices_need_depth_resolve(struct intel_mipmap_tree *mt,
                                                uint32_t level)
{
   uint32_t layer;
   uint32_t end_layer = mt->level[level].depth;

   for (layer = 0; layer < end_layer; layer++) {
      intel_miptree_slice_set_needs_depth_resolve(mt, level, layer);
   }
}

d1449 4
a1452 3
   switch (mt->fast_clear_state) {
   case INTEL_FAST_CLEAR_STATE_NO_MCS:
   case INTEL_FAST_CLEAR_STATE_RESOLVED:
d1455 3
a1457 5
   case INTEL_FAST_CLEAR_STATE_UNRESOLVED:
   case INTEL_FAST_CLEAR_STATE_CLEAR:
      /* Fast color clear resolves only make sense for non-MSAA buffers. */
      if (mt->msaa_layout == INTEL_MSAA_LAYOUT_NONE)
         brw_blorp_resolve_color(brw, mt);
d1464 1
a1464 1
 * Make it possible to share the BO backing the given miptree with another
d1468 3
a1470 3
 * then discard the MCS buffer, if present.  We also set the fast_clear_state
 * to INTEL_FAST_CLEAR_STATE_NO_MCS to ensure that no MCS buffer gets
 * allocated in the future.
d1486 1
a1486 1
      mt->fast_clear_state = INTEL_FAST_CLEAR_STATE_NO_MCS;
d1547 1
a1547 1
void
d1550 17
a1566 16
                           struct intel_mipmap_tree *dst)
{
   if (brw->gen < 8) {
      brw_blorp_blit_miptrees(brw,
                              src, 0 /* level */, 0 /* layer */,
                              dst, 0 /* level */, 0 /* layer */,
                              0, 0,
                              src->logical_width0, src->logical_height0,
                              0, 0,
                              dst->logical_width0, dst->logical_height0,
                              GL_NEAREST, false, false /*mirror x, y*/);
   } else if (src->format == MESA_FORMAT_S_UINT8) {
      brw_meta_stencil_updownsample(brw, src, dst);
   } else {
      brw_meta_updownsample(brw, src, dst);
   }
a1568 5
      if (brw->gen >= 8) {
         brw_meta_stencil_updownsample(brw, src->stencil_mt, dst);
         return;
      }

d1572 5
a1576 5
                              0, 0,
                              src->logical_width0, src->logical_height0,
                              0, 0,
                              dst->logical_width0, dst->logical_height0,
                              GL_NEAREST, false, false /*mirror x, y*/);
d1580 48
d1631 1
d1637 7
a1643 1
   drm_intel_bo *bo = mt->bo;
d1645 1
a1645 2
   if (drm_intel_bo_references(brw->batch.bo, bo))
      intel_batchbuffer_flush(brw);
d1647 2
a1648 2
   if (mt->tiling != I915_TILING_NONE)
      brw_bo_map_gtt(brw, bo, "miptree");
d1650 1
a1650 1
      brw_bo_map(brw, bo, true, "miptree");
d1659 1
a1659 1
   drm_intel_bo_unmap(mt->bo);
d1694 1
a1694 1
      map->stride = mt->pitch;
d1729 1
a1729 1
   map->stride = map->mt->pitch;
d1741 1
a1780 73
#ifdef __SSE4_1__
/**
 * "Map" a buffer by copying it to an untiled temporary using MOVNTDQA.
 */
static void
intel_miptree_map_movntdqa(struct brw_context *brw,
                           struct intel_mipmap_tree *mt,
                           struct intel_miptree_map *map,
                           unsigned int level, unsigned int slice)
{
   assert(map->mode & GL_MAP_READ_BIT);
   assert(!(map->mode & GL_MAP_WRITE_BIT));

   DBG("%s: %d,%d %dx%d from mt %p (%s) %d,%d = %p/%d\n", __FUNCTION__,
       map->x, map->y, map->w, map->h,
       mt, _mesa_get_format_name(mt->format),
       level, slice, map->ptr, map->stride);

   /* Map the original image */
   uint32_t image_x;
   uint32_t image_y;
   intel_miptree_get_image_offset(mt, level, slice, &image_x, &image_y);
   image_x += map->x;
   image_y += map->y;

   void *src = intel_miptree_map_raw(brw, mt);
   if (!src)
      return;
   src += image_y * mt->pitch;
   src += image_x * mt->cpp;

   /* Due to the pixel offsets for the particular image being mapped, our
    * src pointer may not be 16-byte aligned.  However, if the pitch is
    * divisible by 16, then the amount by which it's misaligned will remain
    * consistent from row to row.
    */
   assert((mt->pitch % 16) == 0);
   const int misalignment = ((uintptr_t) src) & 15;

   /* Create an untiled temporary buffer for the mapping. */
   const unsigned width_bytes = _mesa_format_row_stride(mt->format, map->w);

   map->stride = ALIGN(misalignment + width_bytes, 16);

   map->buffer = malloc(map->stride * map->h);
   /* Offset the destination so it has the same misalignment as src. */
   map->ptr = map->buffer + misalignment;

   assert((((uintptr_t) map->ptr) & 15) == misalignment);

   for (uint32_t y = 0; y < map->h; y++) {
      void *dst_ptr = map->ptr + y * map->stride;
      void *src_ptr = src + y * mt->pitch;

      _mesa_streaming_load_memcpy(dst_ptr, src_ptr, width_bytes);
   }

   intel_miptree_unmap_raw(brw, mt);
}

static void
intel_miptree_unmap_movntdqa(struct brw_context *brw,
                             struct intel_mipmap_tree *mt,
                             struct intel_miptree_map *map,
                             unsigned int level,
                             unsigned int slice)
{
   free(map->buffer);
   map->buffer = NULL;
   map->ptr = NULL;
}
#endif

d1806 1
a1806 1
	    ptrdiff_t offset = intel_offset_S8(mt->pitch,
d1842 1
a1842 1
	    ptrdiff_t offset = intel_offset_S8(mt->pitch,
d1865 1
a1865 1
      assert(mt->format == MESA_FORMAT_R8G8B8X8_UNORM);
d1892 2
a1893 2
                + image_y * mt->pitch
                + image_x * mt->cpp;
d1896 1
a1896 1
      _mesa_etc1_unpack_rgba8888(dst, mt->pitch,
d1900 1
a1900 1
      _mesa_unpack_etc2_format(dst, mt->pitch,
d1927 1
a1927 1
   bool map_z32f_x24s8 = mt->format == MESA_FORMAT_Z_FLOAT32;
d1955 1
a1955 1
	    ptrdiff_t s_offset = intel_offset_S8(s_mt->pitch,
d1960 1
a1960 1
                                  (z_mt->pitch / 4) +
d1999 1
a1999 1
   bool map_z32f_x24s8 = mt->format == MESA_FORMAT_Z_FLOAT32;
d2015 1
a2015 1
	    ptrdiff_t s_offset = intel_offset_S8(s_mt->pitch,
d2020 1
a2020 1
                                  (z_mt->pitch / 4) +
d2095 12
a2106 28
static bool
can_blit_slice(struct intel_mipmap_tree *mt,
               unsigned int level, unsigned int slice)
{
   uint32_t image_x;
   uint32_t image_y;
   intel_miptree_get_image_offset(mt, level, slice, &image_x, &image_y);
   if (image_x >= 32768 || image_y >= 32768)
      return false;

   if (mt->pitch >= 32768)
      return false;

   return true;
}

void
intel_miptree_map(struct brw_context *brw,
                  struct intel_mipmap_tree *mt,
                  unsigned int level,
                  unsigned int slice,
                  unsigned int x,
                  unsigned int y,
                  unsigned int w,
                  unsigned int h,
                  GLbitfield mode,
                  void **out_ptr,
                  int *out_stride)
d2124 1
a2124 1
   if (mt->format == MESA_FORMAT_S_UINT8) {
d2136 3
a2138 3
            (mt->tiling == I915_TILING_X ||
             (brw->gen >= 6 && mt->tiling == I915_TILING_Y)) &&
            can_blit_slice(mt, level, slice)) {
d2140 3
a2142 3
   } else if (mt->tiling != I915_TILING_NONE &&
              mt->bo->size >= brw->max_gtt_map_object_size) {
      assert(can_blit_slice(mt, level, slice));
a2143 4
#ifdef __SSE4_1__
   } else if (!(mode & GL_MAP_WRITE_BIT) && !mt->compressed) {
      intel_miptree_map_movntdqa(brw, mt, map, level, slice);
#endif
d2155 5
a2159 5
void
intel_miptree_unmap(struct brw_context *brw,
                    struct intel_mipmap_tree *mt,
                    unsigned int level,
                    unsigned int slice)
d2171 1
a2171 1
   if (mt->format == MESA_FORMAT_S_UINT8) {
a2179 4
#ifdef __SSE4_1__
   } else if (map->buffer) {
      intel_miptree_unmap_movntdqa(brw, mt, map, level, slice);
#endif
d2185 124
@


1.1.1.4
log
@Import Mesa 10.2.7
@
text
@d70 8
d89 3
a91 1
      if (brw->gen == 7 && _mesa_get_format_datatype(format) == GL_INT) {
a254 20
   if (target == GL_TEXTURE_1D_ARRAY) {
      /* For a 1D Array texture the OpenGL API will treat the height0
       * parameter as the number of array slices. For Intel hardware, we treat
       * the 1D array as a 2D Array with a height of 1.
       *
       * So, when we first come through this path to create a 1D Array
       * texture, height0 stores the number of slices, and depth0 is 1. In
       * this case, we want to swap height0 and depth0.
       *
       * Since some miptrees will be created based on the base miptree, we may
       * come through this path and see height0 as 1 and depth0 being the
       * number of slices. In this case we don't need to do the swap.
       */
      assert(height0 == 1 || depth0 == 1);
      if (height0 > 1) {
         depth0 = height0;
         height0 = 1;
      }
   }

a1253 1
   case 2:
d2147 1
a2147 1
	    ptrdiff_t z_offset = ((y + z_image_y + map->y) *
d2149 1
a2149 1
				  (x + z_image_x + map->x));
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d32 1
a48 1
#include "x86/common_x86_asm.h"
d138 1
a138 1
      unreachable("Non-MSRT MCS requires X or Y tiling");
d171 1
a171 1
   if (brw->gen < 7)
d234 1
a234 2
                            GLuint num_samples,
                            bool force_all_slices_at_each_lod)
a272 1
   exec_list_make_empty(&mt->hiz_map);
d343 1
a343 1
            unreachable("not reached");
d351 2
a352 3
   /* Set array_layout to ALL_SLICES_AT_EACH_LOD when gen7+ array_spacing_lod0
    * can be used. array_spacing_lod0 is only used for non-IMS MSAA surfaces.
    * TODO: can we use it elsewhere?
d357 1
a357 1
      mt->array_layout = ALL_LOD_IN_EACH_SLICE;
d361 1
a361 1
      mt->array_layout = ALL_SLICES_AT_EACH_LOD;
a377 1
      const bool force_all_slices_at_each_lod = brw->gen == 6;
d388 1
a388 2
                                            INTEL_MIPTREE_TILING_ANY,
                                            force_all_slices_at_each_lod);
a405 3
   if (force_all_slices_at_each_lod)
      mt->array_layout = ALL_SLICES_AT_EACH_LOD;

d560 1
a560 2
                     enum intel_miptree_tiling_mode requested_tiling,
                     bool force_all_slices_at_each_lod)
d574 1
a574 2
                                    false, num_samples,
                                    force_all_slices_at_each_lod);
d685 1
a685 1
                                    true, 0, false);
d794 1
a794 1
                             INTEL_MIPTREE_TILING_ANY, false);
d1008 1
a1008 1
      unreachable("not reached");
d1052 1
a1052 1
      unreachable("not reached");
d1278 2
a1279 1
      unreachable("Unrecognized sample count in intel_miptree_alloc_mcs");
d1296 1
a1296 2
                                     INTEL_MIPTREE_TILING_Y,
                                     false);
d1353 1
a1353 2
                                     INTEL_MIPTREE_TILING_Y,
                                     false);
d1361 1
a1361 1
 * \c mt->level[level].has_hiz. Return true if and only if
d1365 1
a1365 1
intel_miptree_level_enable_hiz(struct brw_context *brw,
d1367 2
a1368 1
                               uint32_t level)
a1382 1
         DBG("mt %p level %d: HiZ DISABLED\n", mt, level);
d1387 1
a1387 2
   DBG("mt %p level %d: HiZ enabled\n", mt, level);
   mt->level[level].has_hiz = true;
a1397 1
   const bool force_all_slices_at_each_lod = brw->gen == 6;
d1408 1
a1408 2
                                     INTEL_MIPTREE_TILING_ANY,
                                     force_all_slices_at_each_lod);
d1414 1
a1415 3
      if (!intel_miptree_level_enable_hiz(brw, mt, level))
         continue;

d1417 2
a1418 5
         struct intel_resolve_map *m = malloc(sizeof(struct intel_resolve_map));
         exec_node_init(&m->link);
         m->level = level;
         m->layer = layer;
         m->need = GEN6_HIZ_OP_HIZ_RESOLVE;
d1420 8
a1427 1
         exec_list_push_tail(&mt->hiz_map, &m->link);
d1438 3
a1440 1
intel_miptree_level_has_hiz(struct intel_mipmap_tree *mt, uint32_t level)
d1442 2
a1443 2
   intel_miptree_check_level_layer(mt, level, 0);
   return mt->level[level].has_hiz;
d1451 1
a1451 1
   if (!intel_miptree_level_has_hiz(mt, level))
d1464 1
a1464 1
   if (!intel_miptree_level_has_hiz(mt, level))
d1529 1
d1531 3
a1533 2
   foreach_list_typed_safe(struct intel_resolve_map, map, link, &mt->hiz_map) {
      if (map->need != need)
d1536 2
a1537 2
      intel_hiz_exec(brw, mt, map->level, map->layer, need);
      intel_resolve_map_remove(map);
d1574 1
a1574 1
         brw_meta_resolve_color(brw, mt);
d1671 2
a1672 2
                              src, 0 /* level */, 0 /* layer */, src->format,
                              dst, 0 /* level */, 0 /* layer */, dst->format,
a1691 1
                              src->stencil_mt->format,
a1692 1
                              dst->stencil_mt->format,
d1738 2
a1739 2
   intptr_t x = map->x;
   intptr_t y = map->y;
d1765 1
a1765 2
   DBG("%s: %d,%d %dx%d from mt %p (%s) "
       "%"PRIiPTR",%"PRIiPTR" = %p/%d\n", __FUNCTION__,
d1791 1
a1791 2
                                  INTEL_MIPTREE_TILING_NONE,
                                  false);
d1847 1
a1850 1
#if defined(USE_SSE41)
d1891 1
a1891 1
   map->buffer = _mesa_align_malloc(map->stride * map->h, 16);
d1914 1
a1914 1
   _mesa_align_free(map->buffer);
d2299 2
a2300 2
#if defined(USE_SSE41)
   } else if (!(mode & GL_MAP_WRITE_BIT) && !mt->compressed && cpu_has_sse4_1) {
d2339 2
a2340 2
#if defined(USE_SSE41)
   } else if (map->buffer && cpu_has_sse4_1) {
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@a31 1
#include "intel_chipset.h"
d48 1
d138 1
a138 1
      assert(!"Non-MSRT MCS requires X or Y tiling");
d171 1
a171 1
   if (brw->gen < 7 || brw->gen >= 8)
d234 2
a235 1
                            GLuint num_samples)
d274 1
d345 1
a345 1
            assert(false);
d353 3
a355 2
   /* array_spacing_lod0 is only used for non-IMS MSAA surfaces.  TODO: can we
    * use it elsewhere?
d360 1
a360 1
      mt->array_spacing_lod0 = false;
d364 1
a364 1
      mt->array_spacing_lod0 = true;
d381 1
d392 2
a393 1
                                            INTEL_MIPTREE_TILING_ANY);
d411 3
d568 2
a569 1
                     enum intel_miptree_tiling_mode requested_tiling)
d583 2
a584 1
				      false, num_samples);
d695 1
a695 1
                                    true, 0 /* num_samples */);
d804 1
a804 1
                             INTEL_MIPTREE_TILING_ANY);
d1018 1
a1018 1
      assert(false);
d1062 1
a1062 1
      assert(false);
d1288 1
a1288 2
      assert(!"Unrecognized sample count in intel_miptree_alloc_mcs");
      return false;
d1305 2
a1306 1
                                     INTEL_MIPTREE_TILING_Y);
d1363 2
a1364 1
                                     INTEL_MIPTREE_TILING_Y);
d1372 1
a1372 1
 * \c mt->level[level].slice[layer].has_hiz. Return true if and only if
d1376 1
a1376 1
intel_miptree_slice_enable_hiz(struct brw_context *brw,
d1378 1
a1378 2
                               uint32_t level,
                               uint32_t layer)
d1393 1
d1398 2
a1399 1
   mt->level[level].slice[layer].has_hiz = true;
d1410 1
d1421 2
a1422 1
                                     INTEL_MIPTREE_TILING_ANY);
a1427 1
   struct intel_resolve_map *head = &mt->hiz_map;
d1429 3
d1433 5
a1437 2
         if (!intel_miptree_slice_enable_hiz(brw, mt, level, layer))
            continue;
d1439 1
a1439 8
	 head->next = malloc(sizeof(*head->next));
	 head->next->prev = head;
	 head->next->next = NULL;
	 head = head->next;

	 head->level = level;
	 head->layer = layer;
	 head->need = GEN6_HIZ_OP_HIZ_RESOLVE;
d1450 1
a1450 3
intel_miptree_slice_has_hiz(struct intel_mipmap_tree *mt,
                            uint32_t level,
                            uint32_t layer)
d1452 2
a1453 2
   intel_miptree_check_level_layer(mt, level, layer);
   return mt->level[level].slice[layer].has_hiz;
d1461 1
a1461 1
   if (!intel_miptree_slice_has_hiz(mt, level, layer))
d1474 1
a1474 1
   if (!intel_miptree_slice_has_hiz(mt, level, layer))
a1538 1
   struct intel_resolve_map *i, *next;
d1540 2
a1541 3
   for (i = mt->hiz_map.next; i; i = next) {
      next = i->next;
      if (i->need != need)
d1544 2
a1545 2
      intel_hiz_exec(brw, mt, i->level, i->layer, need);
      intel_resolve_map_remove(i);
d1582 1
a1582 1
         brw_blorp_resolve_color(brw, mt);
d1679 2
a1680 2
                              src, 0 /* level */, 0 /* layer */,
                              dst, 0 /* level */, 0 /* layer */,
d1700 1
d1702 1
d1748 2
a1749 2
   int x = map->x;
   int y = map->y;
d1775 2
a1776 1
   DBG("%s: %d,%d %dx%d from mt %p (%s) %d,%d = %p/%d\n", __FUNCTION__,
d1802 2
a1803 1
                                  INTEL_MIPTREE_TILING_NONE);
a1858 1
#ifdef __SSE4_1__
d1862 1
d1903 1
a1903 1
   map->buffer = malloc(map->stride * map->h);
d1926 1
a1926 1
   free(map->buffer);
d2311 2
a2312 2
#ifdef __SSE4_1__
   } else if (!(mode & GL_MAP_WRITE_BIT) && !mt->compressed) {
d2351 2
a2352 2
#ifdef __SSE4_1__
   } else if (map->buffer) {
@


