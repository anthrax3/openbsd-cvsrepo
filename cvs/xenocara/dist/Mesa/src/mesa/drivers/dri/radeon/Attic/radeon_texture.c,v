head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.05.35;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.25;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.42;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.16.08;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.57;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright (C) 2009 Maciej Cencora.
 * Copyright (C) 2008 Nicolai Haehnle.
 * Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.
 *
 * The Weather Channel (TM) funded Tungsten Graphics to develop the
 * initial release of the Radeon 8500 driver under the XFree86 license.
 * This notice must be preserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "main/glheader.h"
#include "main/imports.h"
#include "main/context.h"
#include "main/enums.h"
#include "main/mipmap.h"
#include "main/pbo.h"
#include "main/texcompress.h"
#include "main/texstore.h"
#include "main/teximage.h"
#include "main/texobj.h"
#include "drivers/common/meta.h"

#include "xmlpool.h"		/* for symbolic values of enum-type options */

#include "radeon_common.h"

#include "radeon_mipmap_tree.h"

static void teximage_assign_miptree(radeonContextPtr rmesa,
				    struct gl_texture_object *texObj,
				    struct gl_texture_image *texImage);

static radeon_mipmap_tree *radeon_miptree_create_for_teximage(radeonContextPtr rmesa,
							      struct gl_texture_object *texObj,
							      struct gl_texture_image *texImage);

void copy_rows(void* dst, GLuint dststride, const void* src, GLuint srcstride,
	GLuint numrows, GLuint rowsize)
{
	assert(rowsize <= dststride);
	assert(rowsize <= srcstride);

	radeon_print(RADEON_TEXTURE, RADEON_TRACE,
		"%s dst %p, stride %u, src %p, stride %u, "
		"numrows %u, rowsize %u.\n",
		__func__, dst, dststride,
		src, srcstride,
		numrows, rowsize);

	if (rowsize == srcstride && rowsize == dststride) {
		memcpy(dst, src, numrows*rowsize);
	} else {
		GLuint i;
		for(i = 0; i < numrows; ++i) {
			memcpy(dst, src, rowsize);
			dst += dststride;
			src += srcstride;
		}
	}
}

/* textures */
/**
 * Allocate an empty texture image object.
 */
struct gl_texture_image *radeonNewTextureImage(struct gl_context *ctx)
{
	return calloc(1, sizeof(radeon_texture_image));
}


/**
 * Delete a texture image object.
 */
static void
radeonDeleteTextureImage(struct gl_context *ctx, struct gl_texture_image *img)
{
	/* nothing special (yet) for radeon_texture_image */
	_mesa_delete_texture_image(ctx, img);
}

static GLboolean
radeonAllocTextureImageBuffer(struct gl_context *ctx,
			      struct gl_texture_image *timage)
{
	radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
	struct gl_texture_object *texobj = timage->TexObject;

	ctx->Driver.FreeTextureImageBuffer(ctx, timage);

	if (!_swrast_init_texture_image(timage))
		return GL_FALSE;

	teximage_assign_miptree(rmesa, texobj, timage);
				
	return GL_TRUE;
}


/**
 * Free memory associated with this texture image.
 */
void radeonFreeTextureImageBuffer(struct gl_context *ctx, struct gl_texture_image *timage)
{
	radeon_texture_image* image = get_radeon_texture_image(timage);

	if (image->mt) {
		radeon_miptree_unreference(&image->mt);
	}
	if (image->bo) {
		radeon_bo_unref(image->bo);
		image->bo = NULL;
	}

        _swrast_free_texture_image_buffer(ctx, timage);
}

/**
 * Map texture memory/buffer into user space.
 * Note: the region of interest parameters are ignored here.
 * \param mapOut  returns start of mapping of region of interest
 * \param rowStrideOut  returns row stride in bytes
 */
static void
radeon_map_texture_image(struct gl_context *ctx,
			 struct gl_texture_image *texImage,
			 GLuint slice,
			 GLuint x, GLuint y, GLuint w, GLuint h,
			 GLbitfield mode,
			 GLubyte **map,
			 GLint *stride)
{
	radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
	radeon_texture_image *image = get_radeon_texture_image(texImage);
	radeon_mipmap_tree *mt = image->mt;
	GLuint texel_size = _mesa_get_format_bytes(texImage->TexFormat);
	GLuint width = texImage->Width;
	GLuint height = texImage->Height;
	struct radeon_bo *bo = !image->mt ? image->bo : image->mt->bo;
	unsigned int bw, bh;
	GLboolean write = (mode & GL_MAP_WRITE_BIT) != 0;

	_mesa_get_format_block_size(texImage->TexFormat, &bw, &bh);
	assert(y % bh == 0);
	y /= bh;
	texel_size /= bw;

	if (bo && radeon_bo_is_referenced_by_cs(bo, rmesa->cmdbuf.cs)) {
		radeon_print(RADEON_TEXTURE, RADEON_VERBOSE,
			     "%s for texture that is "
			     "queued for GPU processing.\n",
			     __func__);
		radeon_firevertices(rmesa);
	}

	if (image->bo) {
		/* TFP case */
		radeon_bo_map(image->bo, write);
		*stride = get_texture_image_row_stride(rmesa, texImage->TexFormat, width, 0, texImage->TexObject->Target);
		*map = bo->ptr;
	} else if (likely(mt)) {
		void *base;
		radeon_mipmap_level *lvl = &image->mt->levels[texImage->Level];
		       
		radeon_bo_map(mt->bo, write);
		base = mt->bo->ptr + lvl->faces[image->base.Base.Face].offset;

		*stride = lvl->rowstride;
		*map = base + (slice * height) * *stride;
	} else {
		/* texture data is in malloc'd memory */

		assert(map);

		*stride = _mesa_format_row_stride(texImage->TexFormat, width);
		*map = image->base.Buffer + (slice * height) * *stride;
	}

	*map += y * *stride + x * texel_size;
}

static void
radeon_unmap_texture_image(struct gl_context *ctx,
			   struct gl_texture_image *texImage, GLuint slice)
{
	radeon_texture_image *image = get_radeon_texture_image(texImage);

	if (image->bo)
		radeon_bo_unmap(image->bo);
	else if (image->mt)
		radeon_bo_unmap(image->mt->bo);
}

/* try to find a format which will only need a memcopy */
static mesa_format radeonChoose8888TexFormat(radeonContextPtr rmesa,
					   GLenum srcFormat,
					   GLenum srcType, GLboolean fbo)
{
#if defined(RADEON_R100)
	/* r100 can only do this */
	return _radeon_texformat_argb8888;
#elif defined(RADEON_R200)
	const GLuint ui = 1;
	const GLubyte littleEndian = *((const GLubyte *)&ui);

	if (fbo)
		return _radeon_texformat_argb8888;

	if ((srcFormat == GL_RGBA && srcType == GL_UNSIGNED_INT_8_8_8_8) ||
	    (srcFormat == GL_RGBA && srcType == GL_UNSIGNED_BYTE && !littleEndian) ||
	    (srcFormat == GL_ABGR_EXT && srcType == GL_UNSIGNED_INT_8_8_8_8_REV) ||
	    (srcFormat == GL_ABGR_EXT && srcType == GL_UNSIGNED_BYTE && littleEndian)) {
		return MESA_FORMAT_A8B8G8R8_UNORM;
	} else if ((srcFormat == GL_RGBA && srcType == GL_UNSIGNED_INT_8_8_8_8_REV) ||
		   (srcFormat == GL_RGBA && srcType == GL_UNSIGNED_BYTE && littleEndian) ||
		   (srcFormat == GL_ABGR_EXT && srcType == GL_UNSIGNED_INT_8_8_8_8) ||
		   (srcFormat == GL_ABGR_EXT && srcType == GL_UNSIGNED_BYTE && !littleEndian)) {
		return MESA_FORMAT_R8G8B8A8_UNORM;
	} else
		return _radeon_texformat_argb8888;
#endif
}

mesa_format radeonChooseTextureFormat_mesa(struct gl_context * ctx,
					 GLenum target,
					 GLint internalFormat,
					 GLenum format,
					 GLenum type)
{
	return radeonChooseTextureFormat(ctx, internalFormat, format,
					 type, 0);
}

mesa_format radeonChooseTextureFormat(struct gl_context * ctx,
				    GLint internalFormat,
				    GLenum format,
				    GLenum type, GLboolean fbo)
{
	radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
	const GLboolean do32bpt =
	    (rmesa->texture_depth == DRI_CONF_TEXTURE_DEPTH_32);
	const GLboolean force16bpt =
	    (rmesa->texture_depth == DRI_CONF_TEXTURE_DEPTH_FORCE_16);
	(void)format;

	radeon_print(RADEON_TEXTURE, RADEON_TRACE,
		"%s InternalFormat=%s(%d) type=%s format=%s\n",
		__func__,
		_mesa_lookup_enum_by_nr(internalFormat), internalFormat,
		_mesa_lookup_enum_by_nr(type), _mesa_lookup_enum_by_nr(format));
	radeon_print(RADEON_TEXTURE, RADEON_TRACE,
			"%s do32bpt=%d force16bpt=%d\n",
			__func__, do32bpt, force16bpt);

	switch (internalFormat) {
	case 4:
	case GL_RGBA:
	case GL_COMPRESSED_RGBA:
		switch (type) {
		case GL_UNSIGNED_INT_10_10_10_2:
		case GL_UNSIGNED_INT_2_10_10_10_REV:
			return do32bpt ? _radeon_texformat_argb8888 :
			    _radeon_texformat_argb1555;
		case GL_UNSIGNED_SHORT_4_4_4_4:
		case GL_UNSIGNED_SHORT_4_4_4_4_REV:
			return _radeon_texformat_argb4444;
		case GL_UNSIGNED_SHORT_5_5_5_1:
		case GL_UNSIGNED_SHORT_1_5_5_5_REV:
			return _radeon_texformat_argb1555;
		default:
			return do32bpt ? radeonChoose8888TexFormat(rmesa, format, type, fbo) :
			    _radeon_texformat_argb4444;
		}

	case 3:
	case GL_RGB:
	case GL_COMPRESSED_RGB:
		switch (type) {
		case GL_UNSIGNED_SHORT_4_4_4_4:
		case GL_UNSIGNED_SHORT_4_4_4_4_REV:
			return _radeon_texformat_argb4444;
		case GL_UNSIGNED_SHORT_5_5_5_1:
		case GL_UNSIGNED_SHORT_1_5_5_5_REV:
			return _radeon_texformat_argb1555;
		case GL_UNSIGNED_SHORT_5_6_5:
		case GL_UNSIGNED_SHORT_5_6_5_REV:
			return _radeon_texformat_rgb565;
		default:
			return do32bpt ? _radeon_texformat_argb8888 :
			    _radeon_texformat_rgb565;
		}

	case GL_RGBA8:
	case GL_RGB10_A2:
	case GL_RGBA12:
	case GL_RGBA16:
		return !force16bpt ?
			radeonChoose8888TexFormat(rmesa, format, type, fbo) :
			_radeon_texformat_argb4444;

	case GL_RGBA4:
	case GL_RGBA2:
		return _radeon_texformat_argb4444;

	case GL_RGB5_A1:
		return _radeon_texformat_argb1555;

	case GL_RGB8:
	case GL_RGB10:
	case GL_RGB12:
	case GL_RGB16:
		return !force16bpt ? _radeon_texformat_argb8888 :
		    _radeon_texformat_rgb565;

	case GL_RGB5:
	case GL_RGB4:
	case GL_R3_G3_B2:
		return _radeon_texformat_rgb565;

	case GL_ALPHA:
	case GL_ALPHA4:
	case GL_ALPHA8:
	case GL_ALPHA12:
	case GL_ALPHA16:
	case GL_COMPRESSED_ALPHA:
#if defined(RADEON_R200)
		/* r200: can't use a8 format since interpreting hw I8 as a8 would result
		   in wrong rgb values (same as alpha value instead of 0). */
		return _radeon_texformat_al88;
#else
		return MESA_FORMAT_A_UNORM8;
#endif
	case 1:
	case GL_LUMINANCE:
	case GL_LUMINANCE4:
	case GL_LUMINANCE8:
	case GL_LUMINANCE12:
	case GL_LUMINANCE16:
	case GL_COMPRESSED_LUMINANCE:
		return MESA_FORMAT_L_UNORM8;

	case 2:
	case GL_LUMINANCE_ALPHA:
	case GL_LUMINANCE4_ALPHA4:
	case GL_LUMINANCE6_ALPHA2:
	case GL_LUMINANCE8_ALPHA8:
	case GL_LUMINANCE12_ALPHA4:
	case GL_LUMINANCE12_ALPHA12:
	case GL_LUMINANCE16_ALPHA16:
	case GL_COMPRESSED_LUMINANCE_ALPHA:
		return _radeon_texformat_al88;

	case GL_INTENSITY:
	case GL_INTENSITY4:
	case GL_INTENSITY8:
	case GL_INTENSITY12:
	case GL_INTENSITY16:
	case GL_COMPRESSED_INTENSITY:
		return MESA_FORMAT_I_UNORM8;

	case GL_YCBCR_MESA:
		if (type == GL_UNSIGNED_SHORT_8_8_APPLE ||
		    type == GL_UNSIGNED_BYTE)
			return MESA_FORMAT_YCBCR;
		else
			return MESA_FORMAT_YCBCR_REV;

	case GL_RGB_S3TC:
	case GL_RGB4_S3TC:
	case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
		return MESA_FORMAT_RGB_DXT1;

	case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
		return MESA_FORMAT_RGBA_DXT1;

	case GL_RGBA_S3TC:
	case GL_RGBA4_S3TC:
	case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
		return MESA_FORMAT_RGBA_DXT3;

	case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
		return MESA_FORMAT_RGBA_DXT5;

	case GL_ALPHA16F_ARB:
		return MESA_FORMAT_A_FLOAT16;
	case GL_ALPHA32F_ARB:
		return MESA_FORMAT_A_FLOAT32;
	case GL_LUMINANCE16F_ARB:
		return MESA_FORMAT_L_FLOAT16;
	case GL_LUMINANCE32F_ARB:
		return MESA_FORMAT_L_FLOAT32;
	case GL_LUMINANCE_ALPHA16F_ARB:
		return MESA_FORMAT_LA_FLOAT16;
	case GL_LUMINANCE_ALPHA32F_ARB:
		return MESA_FORMAT_LA_FLOAT32;
	case GL_INTENSITY16F_ARB:
		return MESA_FORMAT_I_FLOAT16;
	case GL_INTENSITY32F_ARB:
		return MESA_FORMAT_I_FLOAT32;
	case GL_RGB16F_ARB:
		return MESA_FORMAT_RGBA_FLOAT16;
	case GL_RGB32F_ARB:
		return MESA_FORMAT_RGBA_FLOAT32;
	case GL_RGBA16F_ARB:
		return MESA_FORMAT_RGBA_FLOAT16;
	case GL_RGBA32F_ARB:
		return MESA_FORMAT_RGBA_FLOAT32;

	case GL_DEPTH_COMPONENT:
	case GL_DEPTH_COMPONENT16:
	case GL_DEPTH_COMPONENT24:
	case GL_DEPTH_COMPONENT32:
	case GL_DEPTH_STENCIL_EXT:
	case GL_DEPTH24_STENCIL8_EXT:
		return MESA_FORMAT_Z24_UNORM_S8_UINT;

	/* EXT_texture_sRGB */
	case GL_SRGB:
	case GL_SRGB8:
	case GL_SRGB_ALPHA:
	case GL_SRGB8_ALPHA8:
	case GL_COMPRESSED_SRGB:
	case GL_COMPRESSED_SRGB_ALPHA:
		return MESA_FORMAT_B8G8R8A8_SRGB;

	case GL_SLUMINANCE:
	case GL_SLUMINANCE8:
	case GL_COMPRESSED_SLUMINANCE:
		return MESA_FORMAT_L_SRGB8;

	case GL_SLUMINANCE_ALPHA:
	case GL_SLUMINANCE8_ALPHA8:
	case GL_COMPRESSED_SLUMINANCE_ALPHA:
      return MESA_FORMAT_L8A8_SRGB;

	case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
		return MESA_FORMAT_SRGB_DXT1;
	case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
		return MESA_FORMAT_SRGBA_DXT1;
	case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
		return MESA_FORMAT_SRGBA_DXT3;
	case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
		return MESA_FORMAT_SRGBA_DXT5;

	default:
		_mesa_problem(ctx,
			      "unexpected internalFormat 0x%x in %s",
			      (int)internalFormat, __func__);
		return MESA_FORMAT_NONE;
	}

	return MESA_FORMAT_NONE;		/* never get here */
}

/** Check if given image is valid within current texture object.
 */
static void teximage_assign_miptree(radeonContextPtr rmesa,
				    struct gl_texture_object *texObj,
				    struct gl_texture_image *texImage)
{
	radeonTexObj *t = radeon_tex_obj(texObj);
	radeon_texture_image* image = get_radeon_texture_image(texImage);

	/* Try using current miptree, or create new if there isn't any */
	if (!t->mt || !radeon_miptree_matches_image(t->mt, texImage)) {
		radeon_miptree_unreference(&t->mt);
		t->mt = radeon_miptree_create_for_teximage(rmesa,
							   texObj,
							   texImage);

		radeon_print(RADEON_TEXTURE, RADEON_NORMAL,
			     "%s: texObj %p, texImage %p, "
				"texObj miptree doesn't match, allocated new miptree %p\n",
				__FUNCTION__, texObj, texImage, t->mt);
	}

	/* Miptree alocation may have failed,
	 * when there was no image for baselevel specified */
	if (t->mt) {
		radeon_miptree_reference(t->mt, &image->mt);
	} else
		radeon_print(RADEON_TEXTURE, RADEON_VERBOSE,
				"%s Failed to allocate miptree.\n", __func__);
}

unsigned radeonIsFormatRenderable(mesa_format mesa_format)
{
	if (mesa_format == _radeon_texformat_argb8888 || mesa_format == _radeon_texformat_rgb565 ||
		mesa_format == _radeon_texformat_argb1555 || mesa_format == _radeon_texformat_argb4444)
		return 1;

	switch (mesa_format)
	{
		case MESA_FORMAT_Z_UNORM16:
		case MESA_FORMAT_Z24_UNORM_S8_UINT:
			return 1;
		default:
			return 0;
	}
}

void radeon_image_target_texture_2d(struct gl_context *ctx, GLenum target,
				    struct gl_texture_object *texObj,
				    struct gl_texture_image *texImage,
				    GLeglImageOES image_handle)
{
	radeonContextPtr radeon = RADEON_CONTEXT(ctx);
	radeonTexObj *t = radeon_tex_obj(texObj);
	radeon_texture_image *radeonImage = get_radeon_texture_image(texImage);
	__DRIscreen *screen;
	__DRIimage *image;

	screen = radeon->dri.screen;
	image = screen->dri2.image->lookupEGLImage(screen, image_handle,
						   screen->loaderPrivate);
	if (image == NULL)
		return;

	radeonFreeTextureImageBuffer(ctx, texImage);

	texImage->Width = image->width;
	texImage->Height = image->height;
	texImage->Depth = 1;
	texImage->_BaseFormat = GL_RGBA;
	texImage->TexFormat = image->format;
	radeonImage->base.RowStride = image->pitch;
	texImage->InternalFormat = image->internal_format;

	if(t->mt)
	{
		radeon_miptree_unreference(&t->mt);
		t->mt = NULL;
	}

	/* NOTE: The following is *very* ugly and will probably break. But
	   I don't know how to deal with it, without creating a whole new
	   function like radeon_miptree_from_bo() so I'm going with the
	   easy but error-prone way. */

	radeon_try_alloc_miptree(radeon, t);

	radeon_miptree_reference(t->mt, &radeonImage->mt);

	if (t->mt == NULL)
	{
		radeon_print(RADEON_TEXTURE, RADEON_VERBOSE,
			     "%s Failed to allocate miptree.\n", __func__);
		return;
	}

	/* Particularly ugly: this is guaranteed to break, if image->bo is
	   not of the required size for a miptree. */
	radeon_bo_unref(t->mt->bo);
	radeon_bo_ref(image->bo);
	t->mt->bo = image->bo;

	if (!radeon_miptree_matches_image(t->mt, &radeonImage->base.Base))
		fprintf(stderr, "miptree doesn't match image\n");
}

mesa_format _radeon_texformat_rgba8888 = MESA_FORMAT_NONE;
mesa_format _radeon_texformat_argb8888 = MESA_FORMAT_NONE;
mesa_format _radeon_texformat_rgb565 = MESA_FORMAT_NONE;
mesa_format _radeon_texformat_argb4444 = MESA_FORMAT_NONE;
mesa_format _radeon_texformat_argb1555 = MESA_FORMAT_NONE;
mesa_format _radeon_texformat_al88 = MESA_FORMAT_NONE;
/*@@}*/


static void
radeonInitTextureFormats(void)
{
   if (_mesa_little_endian()) {
      _radeon_texformat_rgba8888	= MESA_FORMAT_A8B8G8R8_UNORM;
      _radeon_texformat_argb8888	= MESA_FORMAT_B8G8R8A8_UNORM;
      _radeon_texformat_rgb565		= MESA_FORMAT_B5G6R5_UNORM;
      _radeon_texformat_argb4444	= MESA_FORMAT_B4G4R4A4_UNORM;
      _radeon_texformat_argb1555	= MESA_FORMAT_B5G5R5A1_UNORM;
      _radeon_texformat_al88		= MESA_FORMAT_L8A8_UNORM;
   }
   else {
      _radeon_texformat_rgba8888	= MESA_FORMAT_R8G8B8A8_UNORM;
      _radeon_texformat_argb8888	= MESA_FORMAT_A8R8G8B8_UNORM;
      _radeon_texformat_rgb565		= MESA_FORMAT_R5G6B5_UNORM;
      _radeon_texformat_argb4444	= MESA_FORMAT_A4R4G4B4_UNORM;
      _radeon_texformat_argb1555	= MESA_FORMAT_A1R5G5B5_UNORM;
      _radeon_texformat_al88		= MESA_FORMAT_A8L8_UNORM;
   }
}

void
radeon_init_common_texture_funcs(radeonContextPtr radeon,
				 struct dd_function_table *functions)
{
	functions->NewTextureImage = radeonNewTextureImage;
	functions->DeleteTextureImage = radeonDeleteTextureImage;
	functions->AllocTextureImageBuffer = radeonAllocTextureImageBuffer;
	functions->FreeTextureImageBuffer = radeonFreeTextureImageBuffer;
	functions->MapTextureImage = radeon_map_texture_image;
	functions->UnmapTextureImage = radeon_unmap_texture_image;

	functions->ChooseTextureFormat	= radeonChooseTextureFormat_mesa;

	functions->CopyTexSubImage = radeonCopyTexSubImage;

	functions->Bitmap = _mesa_meta_Bitmap;
	functions->EGLImageTargetTexture2D = radeon_image_target_texture_2d;

	radeonInitTextureFormats();
}

static radeon_mipmap_tree *radeon_miptree_create_for_teximage(radeonContextPtr rmesa,
						       struct gl_texture_object *texObj,
						       struct gl_texture_image *texImage)
{
	radeonTexObj *t = radeon_tex_obj(texObj);
	GLuint firstLevel;
	GLuint lastLevel;
	int width, height, depth;
	int i;

	width = texImage->Width;
	height = texImage->Height;
	depth = texImage->Depth;

	if (texImage->Level > texObj->BaseLevel &&
	    (width == 1 ||
	     (texObj->Target != GL_TEXTURE_1D && height == 1) ||
	     (texObj->Target == GL_TEXTURE_3D && depth == 1))) {
		/* For this combination, we're at some lower mipmap level and
		 * some important dimension is 1.  We can't extrapolate up to a
		 * likely base level width/height/depth for a full mipmap stack
		 * from this info, so just allocate this one level.
		 */
		firstLevel = texImage->Level;
		lastLevel = texImage->Level;
	} else {
		if (texImage->Level < texObj->BaseLevel)
			firstLevel = 0;
		else
			firstLevel = texObj->BaseLevel;

		for (i = texImage->Level; i > firstLevel; i--) {
			width <<= 1;
			if (height != 1)
				height <<= 1;
			if (depth != 1)
				depth <<= 1;
		}
		if ((texObj->Sampler.MinFilter == GL_NEAREST ||
		     texObj->Sampler.MinFilter == GL_LINEAR) &&
		    texImage->Level == firstLevel) {
			lastLevel = firstLevel;
		} else {
			lastLevel = firstLevel + _mesa_logbase2(MAX2(MAX2(width, height), depth));
		}
	}

	return  radeon_miptree_create(rmesa, texObj->Target,
				      texImage->TexFormat, firstLevel, lastLevel - firstLevel + 1,
				      width, height, depth, 
				      t->tile_bits);
}				     
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d216 1
a216 1
static gl_format radeonChoose8888TexFormat(radeonContextPtr rmesa,
d234 1
a234 1
		return MESA_FORMAT_RGBA8888;
d239 1
a239 1
		return MESA_FORMAT_RGBA8888_REV;
d245 1
a245 1
gl_format radeonChooseTextureFormat_mesa(struct gl_context * ctx,
d255 1
a255 1
gl_format radeonChooseTextureFormat(struct gl_context * ctx,
d352 1
a352 1
		return MESA_FORMAT_A8;
d361 1
a361 1
		return MESA_FORMAT_L8;
d380 1
a380 1
		return MESA_FORMAT_I8;
d406 1
a406 1
		return MESA_FORMAT_ALPHA_FLOAT16;
d408 1
a408 1
		return MESA_FORMAT_ALPHA_FLOAT32;
d410 1
a410 1
		return MESA_FORMAT_LUMINANCE_FLOAT16;
d412 1
a412 1
		return MESA_FORMAT_LUMINANCE_FLOAT32;
d414 1
a414 1
		return MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16;
d416 1
a416 1
		return MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32;
d418 1
a418 1
		return MESA_FORMAT_INTENSITY_FLOAT16;
d420 1
a420 1
		return MESA_FORMAT_INTENSITY_FLOAT32;
d436 1
a436 1
		return MESA_FORMAT_S8_Z24;
d445 1
a445 1
		return MESA_FORMAT_SARGB8;
d450 1
a450 1
		return MESA_FORMAT_SL8;
d455 1
a455 1
		return MESA_FORMAT_SLA8;
d507 1
a507 1
unsigned radeonIsFormatRenderable(gl_format mesa_format)
d515 2
a516 2
		case MESA_FORMAT_Z16:
		case MESA_FORMAT_S8_Z24:
d582 6
a587 6
gl_format _radeon_texformat_rgba8888 = MESA_FORMAT_NONE;
gl_format _radeon_texformat_argb8888 = MESA_FORMAT_NONE;
gl_format _radeon_texformat_rgb565 = MESA_FORMAT_NONE;
gl_format _radeon_texformat_argb4444 = MESA_FORMAT_NONE;
gl_format _radeon_texformat_argb1555 = MESA_FORMAT_NONE;
gl_format _radeon_texformat_al88 = MESA_FORMAT_NONE;
d595 6
a600 6
      _radeon_texformat_rgba8888	= MESA_FORMAT_RGBA8888;
      _radeon_texformat_argb8888	= MESA_FORMAT_ARGB8888;
      _radeon_texformat_rgb565		= MESA_FORMAT_RGB565;
      _radeon_texformat_argb4444	= MESA_FORMAT_ARGB4444;
      _radeon_texformat_argb1555	= MESA_FORMAT_ARGB1555;
      _radeon_texformat_al88		= MESA_FORMAT_AL88;
d603 6
a608 6
      _radeon_texformat_rgba8888	= MESA_FORMAT_RGBA8888_REV;
      _radeon_texformat_argb8888	= MESA_FORMAT_ARGB8888_REV;
      _radeon_texformat_rgb565		= MESA_FORMAT_RGB565_REV;
      _radeon_texformat_argb4444	= MESA_FORMAT_ARGB4444_REV;
      _radeon_texformat_argb1555	= MESA_FORMAT_ARGB1555_REV;
      _radeon_texformat_al88		= MESA_FORMAT_AL88_REV;
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a35 1
#include "main/mfeatures.h"
d50 7
d89 1
a89 1
	return CALLOC(sizeof(radeon_texture_image));
d92 1
d94 1
a94 1
 * Free memory associated with this texture image.
d96 2
a97 1
void radeonFreeTexImageData(struct gl_context *ctx, struct gl_texture_image *timage)
d99 2
a100 16
	radeon_texture_image* image = get_radeon_texture_image(timage);

	if (image->mt) {
		radeon_miptree_unreference(&image->mt);
		assert(!image->base.Data);
	} else {
		_mesa_free_texture_image_data(ctx, timage);
	}
	if (image->bo) {
		radeon_bo_unref(image->bo);
		image->bo = NULL;
	}
	if (timage->Data) {
		_mesa_free_texmemory(timage->Data);
		timage->Data = NULL;
	}
d103 3
a105 2
/* Set Data pointer and additional data for mapped texture image */
static void teximage_set_map_data(radeon_texture_image *image)
d107 2
a108 1
	radeon_mipmap_level *lvl;
d110 1
a110 3
	if (!image->mt) {
		radeon_warning("%s(%p) Trying to set map data without miptree.\n",
				__func__, image);
d112 2
a113 2
		return;
	}
d115 3
a117 4
	lvl = &image->mt->levels[image->mtlevel];

	image->base.Data = image->mt->bo->ptr + lvl->faces[image->mtface].offset;
	image->base.RowStride = lvl->rowstride / _mesa_get_format_bytes(image->base.TexFormat);
d122 1
a122 1
 * Map a single texture image for glTexImage and friends.
d124 1
a124 1
void radeon_teximage_map(radeon_texture_image *image, GLboolean write_enable)
d126 2
a127 4
	radeon_print(RADEON_TEXTURE, RADEON_VERBOSE,
			"%s(img %p), write_enable %s.\n",
			__func__, image,
			write_enable ? "true": "false");
d129 1
a129 4
		assert(!image->base.Data);

		radeon_bo_map(image->mt->bo, write_enable);
		teximage_set_map_data(image);
d131 3
a133 13
}


void radeon_teximage_unmap(radeon_texture_image *image)
{
	radeon_print(RADEON_TEXTURE, RADEON_VERBOSE,
			"%s(img %p)\n",
			__func__, image);
	if (image->mt) {
		assert(image->base.Data);

		image->base.Data = 0;
		radeon_bo_unmap(image->mt->bo);
a134 14
}

static void map_override(struct gl_context *ctx, radeonTexObj *t)
{
	radeon_texture_image *img = get_radeon_texture_image(t->base.Image[0][0]);

	radeon_bo_map(t->bo, GL_FALSE);

	img->base.Data = t->bo->ptr;
}

static void unmap_override(struct gl_context *ctx, radeonTexObj *t)
{
	radeon_texture_image *img = get_radeon_texture_image(t->base.Image[0][0]);
d136 1
a136 3
	radeon_bo_unmap(t->bo);

	img->base.Data = NULL;
d140 4
a143 1
 * Map a validated texture for reading during software rendering.
d145 8
a152 1
void radeonMapTexture(struct gl_context *ctx, struct gl_texture_object *texObj)
d154 14
a167 2
	radeonTexObj* t = radeon_tex_obj(texObj);
	int face, level;
d169 1
a169 12
	radeon_print(RADEON_TEXTURE, RADEON_VERBOSE,
			"%s(%p, tex %p)\n",
			__func__, ctx, texObj);

	if (!radeon_validate_texture_miptree(ctx, texObj)) {
		radeon_error("%s(%p, tex %p) Failed to validate miptree for "
			"sw fallback.\n",
			__func__, ctx, texObj);
		return;
	}

	if (t->image_override && t->bo) {
d171 4
a174 4
			"%s(%p, tex %p) Work around for missing miptree in r100.\n",
			__func__, ctx, texObj);

		map_override(ctx, t);
d177 11
a187 6
	/* for r100 3D sw fallbacks don't have mt */
	if (!t->mt) {
		radeon_warning("%s(%p, tex %p) No miptree in texture.\n",
			__func__, ctx, texObj);
		return;
	}
d189 4
a192 6
	radeon_bo_map(t->mt->bo, GL_FALSE);
	for(face = 0; face < t->mt->faces; ++face) {
		for(level = t->minLod; level <= t->maxLod; ++level)
			teximage_set_map_data(get_radeon_texture_image(texObj->Image[face][level]));
	}
}
d194 1
a194 4
void radeonUnmapTexture(struct gl_context *ctx, struct gl_texture_object *texObj)
{
	radeonTexObj* t = radeon_tex_obj(texObj);
	int face, level;
d196 2
a197 13
	radeon_print(RADEON_TEXTURE, RADEON_VERBOSE,
			"%s(%p, tex %p)\n",
			__func__, ctx, texObj);

	if (t->image_override && t->bo)
		unmap_override(ctx, t);
	/* for r100 3D sw fallbacks don't have mt */
	if (!t->mt)
	  return;

	for(face = 0; face < t->mt->faces; ++face) {
		for(level = t->minLod; level <= t->maxLod; ++level)
			texObj->Image[face][level]->Data = 0;
a198 30
	radeon_bo_unmap(t->mt->bo);
}

/**
 * Wraps Mesa's implementation to ensure that the base level image is mapped.
 *
 * This relies on internal details of _mesa_generate_mipmap, in particular
 * the fact that the memory for recreated texture images is always freed.
 */
static void radeon_generate_mipmap(struct gl_context *ctx, GLenum target,
				   struct gl_texture_object *texObj)
{
	radeonTexObj* t = radeon_tex_obj(texObj);
	GLuint nr_faces = (t->base.Target == GL_TEXTURE_CUBE_MAP) ? 6 : 1;
	int i, face;
	struct gl_texture_image *first_image;

	radeon_print(RADEON_TEXTURE, RADEON_VERBOSE,
			"%s(%p, tex %p) Target type %s.\n",
			__func__, ctx, texObj,
			_mesa_lookup_enum_by_nr(target));

	_mesa_generate_mipmap(ctx, target, texObj);

	/* For the compressed case, we don't need to do the
	 * non-TexImage recovery path below.
	 */
	first_image = texObj->Image[0][texObj->BaseLevel];
	if (_mesa_is_format_compressed(first_image->TexFormat))
		return;
d200 1
a200 16
	for (face = 0; face < nr_faces; face++) {
		for (i = texObj->BaseLevel + 1; i < texObj->MaxLevel; i++) {
			radeon_texture_image *image;

			image = get_radeon_texture_image(texObj->Image[face][i]);

			if (image == NULL)
				break;

			image->mtlevel = i;
			image->mtface = face;

			radeon_miptree_unreference(&image->mt);
		}
	}
	
d203 3
a205 1
void radeonGenerateMipmap(struct gl_context* ctx, GLenum target, struct gl_texture_object *texObj)
d207 1
a207 5
	radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
	struct radeon_bo *bo;
	GLuint face = _mesa_tex_target_to_face(target);
	radeon_texture_image *baseimage = get_radeon_texture_image(texObj->Image[face][texObj->BaseLevel]);
	bo = !baseimage->mt ? baseimage->bo : baseimage->mt->bo;
d209 4
a212 20
	radeon_print(RADEON_TEXTURE, RADEON_TRACE,
		"%s(%p, target %s, tex %p)\n",
		__func__, ctx, _mesa_lookup_enum_by_nr(target),
		texObj);

	if (bo && radeon_bo_is_referenced_by_cs(bo, rmesa->cmdbuf.cs)) {
		radeon_print(RADEON_TEXTURE, RADEON_NORMAL,
			"%s(%p, tex %p) Trying to generate mipmap for texture "
			"in processing by GPU.\n",
			__func__, ctx, texObj);
		radeon_firevertices(rmesa);
	}

	if (_mesa_meta_check_generate_mipmap_fallback(ctx, target, texObj)) {
		radeon_teximage_map(baseimage, GL_FALSE);
		radeon_generate_mipmap(ctx, target, texObj);
		radeon_teximage_unmap(baseimage);
	} else {
		_mesa_meta_GenerateMipmap(ctx, target, texObj);
	}
a214 1

d220 4
d227 2
a228 3
	/* r100 can only do this */
	if (IS_R100_CLASS(rmesa->radeonScreen) || fbo)
	  return _dri_texformat_argb8888;
a239 8
	} else if (IS_R200_CLASS(rmesa->radeonScreen)) {
		return _dri_texformat_argb8888;
	} else if (srcFormat == GL_BGRA && ((srcType == GL_UNSIGNED_BYTE && !littleEndian) ||
					    srcType == GL_UNSIGNED_INT_8_8_8_8)) {
		return MESA_FORMAT_ARGB8888_REV;
	} else if (srcFormat == GL_BGRA && ((srcType == GL_UNSIGNED_BYTE && littleEndian) ||
					    srcType == GL_UNSIGNED_INT_8_8_8_8_REV)) {
		return MESA_FORMAT_ARGB8888;
d241 2
a242 1
		return _dri_texformat_argb8888;
d246 1
d283 2
a284 2
			return do32bpt ? _dri_texformat_argb8888 :
			    _dri_texformat_argb1555;
d287 1
a287 1
			return _dri_texformat_argb4444;
d290 1
a290 1
			return _dri_texformat_argb1555;
d293 1
a293 1
			    _dri_texformat_argb4444;
d302 1
a302 1
			return _dri_texformat_argb4444;
d305 1
a305 1
			return _dri_texformat_argb1555;
d308 1
a308 1
			return _dri_texformat_rgb565;
d310 2
a311 2
			return do32bpt ? _dri_texformat_argb8888 :
			    _dri_texformat_rgb565;
d320 1
a320 1
			_dri_texformat_argb4444;
d324 1
a324 1
		return _dri_texformat_argb4444;
d327 1
a327 1
		return _dri_texformat_argb1555;
d333 2
a334 2
		return !force16bpt ? _dri_texformat_argb8888 :
		    _dri_texformat_rgb565;
d339 1
a339 1
		return _dri_texformat_rgb565;
d347 1
d350 4
a353 4
		if (IS_R200_CLASS(rmesa->radeonScreen))
			return _dri_texformat_al88;
		else
			return _dri_texformat_a8;
d361 1
a361 1
		return _dri_texformat_l8;
d372 1
a372 1
		return _dri_texformat_al88;
d380 1
a380 1
		return _dri_texformat_i8;
a429 13
#ifdef RADEON_R300
	case GL_DEPTH_COMPONENT:
	case GL_DEPTH_COMPONENT16:
		return MESA_FORMAT_Z16;
	case GL_DEPTH_COMPONENT24:
	case GL_DEPTH_COMPONENT32:
	case GL_DEPTH_STENCIL_EXT:
	case GL_DEPTH24_STENCIL8_EXT:
		if (rmesa->radeonScreen->chip_family >= CHIP_FAMILY_RV515)
			return MESA_FORMAT_S8_Z24;
		else
			return MESA_FORMAT_Z16;
#else
a436 1
#endif
a477 22
static int image_matches_texture_obj(struct gl_texture_object *texObj,
	struct gl_texture_image *texImage,
	unsigned level)
{
	const struct gl_texture_image *baseImage = texObj->Image[0][texObj->BaseLevel];

	if (!baseImage)
		return 0;

	if (level < texObj->BaseLevel || level > texObj->MaxLevel)
		return 0;

	const unsigned levelDiff = level - texObj->BaseLevel;
	const unsigned refWidth = MAX2(baseImage->Width >> levelDiff, 1);
	const unsigned refHeight = MAX2(baseImage->Height >> levelDiff, 1);
	const unsigned refDepth = MAX2(baseImage->Depth >> levelDiff, 1);

	return (texImage->Width == refWidth &&
			texImage->Height == refHeight &&
			texImage->Depth == refDepth);
}

d479 2
a480 4
	struct gl_texture_object *texObj,
	struct gl_texture_image *texImage,
	unsigned face,
	unsigned level)
a484 6
	/* Since miptree holds only images for levels <BaseLevel..MaxLevel>
	 * don't allocate the miptree if the teximage won't fit.
	 */
	if (!image_matches_texture_obj(texObj, texImage, level))
		return;

d486 1
a486 1
	if (!t->mt || !radeon_miptree_matches_image(t->mt, texImage, face, level)) {
d488 4
a491 1
		radeon_try_alloc_miptree(rmesa, t);
d493 1
a493 1
				"%s: texObj %p, texImage %p, face %d, level %d, "
d495 1
a495 1
				__FUNCTION__, texObj, texImage, face, level, t->mt);
a500 2
		image->mtface = face;
		image->mtlevel = level;
a506 351
static GLuint * allocate_image_offsets(struct gl_context *ctx,
	unsigned alignedWidth,
	unsigned height,
	unsigned depth)
{
	int i;
	GLuint *offsets;

	offsets = malloc(depth * sizeof(GLuint)) ;
	if (!offsets) {
		_mesa_error(ctx, GL_OUT_OF_MEMORY, "glTex[Sub]Image");
		return NULL;
	}

	for (i = 0; i < depth; ++i) {
		offsets[i] = alignedWidth * height * i;
	}

	return offsets;
}

/**
 * Update a subregion of the given texture image.
 */
static void radeon_store_teximage(struct gl_context* ctx, int dims,
		GLint xoffset, GLint yoffset, GLint zoffset,
		GLsizei width, GLsizei height, GLsizei depth,
		GLsizei imageSize,
		GLenum format, GLenum type,
		const GLvoid * pixels,
		const struct gl_pixelstore_attrib *packing,
		struct gl_texture_object *texObj,
		struct gl_texture_image *texImage,
		int compressed)
{
	radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
	radeonTexObj *t = radeon_tex_obj(texObj);
	radeon_texture_image* image = get_radeon_texture_image(texImage);

	GLuint dstRowStride;
	GLuint *dstImageOffsets;

	radeon_print(RADEON_TEXTURE, RADEON_TRACE,
			"%s(%p, tex %p, image %p) compressed %d\n",
			__func__, ctx, texObj, texImage, compressed);

	if (image->mt) {
		dstRowStride = image->mt->levels[image->mtlevel].rowstride;
	} else if (t->bo) {
		/* TFP case */
		dstRowStride = get_texture_image_row_stride(rmesa, texImage->TexFormat, width, 0);
	} else {
		dstRowStride = _mesa_format_row_stride(texImage->TexFormat, texImage->Width);
	}

	assert(dstRowStride);

	if (dims == 3) {
		unsigned alignedWidth = dstRowStride/_mesa_get_format_bytes(texImage->TexFormat);
		dstImageOffsets = allocate_image_offsets(ctx, alignedWidth, texImage->Height, texImage->Depth);
		if (!dstImageOffsets) {
			radeon_warning("%s Failed to allocate dstImaeOffset.\n", __func__);
			return;
		}
	} else {
		dstImageOffsets = texImage->ImageOffsets;
	}

	radeon_teximage_map(image, GL_TRUE);

	if (compressed) {
		uint32_t srcRowStride, bytesPerRow, rows, block_width, block_height;
		GLubyte *img_start;

		_mesa_get_format_block_size(texImage->TexFormat, &block_width, &block_height);

		if (!image->mt) {
			dstRowStride = _mesa_format_row_stride(texImage->TexFormat, texImage->Width);
			img_start = _mesa_compressed_image_address(xoffset, yoffset, 0,
									texImage->TexFormat,
									texImage->Width, texImage->Data);
		}
		else {
			uint32_t offset;
			offset = dstRowStride / _mesa_get_format_bytes(texImage->TexFormat) * yoffset / block_height + xoffset / block_width;
			offset *= _mesa_get_format_bytes(texImage->TexFormat);
			img_start = texImage->Data + offset;
		}
		srcRowStride = _mesa_format_row_stride(texImage->TexFormat, width);
		bytesPerRow = srcRowStride;
		rows = (height + block_height - 1) / block_height;

		copy_rows(img_start, dstRowStride, pixels, srcRowStride, rows, bytesPerRow);
	}
	else {
		if (!_mesa_texstore(ctx, dims, texImage->_BaseFormat,
					texImage->TexFormat, texImage->Data,
					xoffset, yoffset, zoffset,
					dstRowStride,
					dstImageOffsets,
					width, height, depth,
					format, type, pixels, packing)) {
			_mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexSubImage");
		}
	}

	if (dims == 3) {
		free(dstImageOffsets);
	}

	radeon_teximage_unmap(image);
}

/**
 * All glTexImage calls go through this function.
 */
static void radeon_teximage(
	struct gl_context *ctx, int dims,
	GLenum target, GLint level,
	GLint internalFormat,
	GLint width, GLint height, GLint depth,
	GLsizei imageSize,
	GLenum format, GLenum type, const GLvoid * pixels,
	const struct gl_pixelstore_attrib *packing,
	struct gl_texture_object *texObj,
	struct gl_texture_image *texImage,
	int compressed)
{
	radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
	radeonTexObj* t = radeon_tex_obj(texObj);
	radeon_texture_image* image = get_radeon_texture_image(texImage);
	GLuint face = _mesa_tex_target_to_face(target);

	radeon_print(RADEON_TEXTURE, RADEON_NORMAL,
			"%s %dd: texObj %p, texImage %p, face %d, level %d\n",
			__func__, dims, texObj, texImage, face, level);
	{
		struct radeon_bo *bo;
		bo = !image->mt ? image->bo : image->mt->bo;
		if (bo && radeon_bo_is_referenced_by_cs(bo, rmesa->cmdbuf.cs)) {
			radeon_print(RADEON_TEXTURE, RADEON_VERBOSE,
				"%s Calling teximage for texture that is "
				"queued for GPU processing.\n",
				__func__);
			radeon_firevertices(rmesa);
		}
	}


	t->validated = GL_FALSE;

	/* Mesa core only clears texImage->Data but not image->mt */
	radeonFreeTexImageData(ctx, texImage);

	if (!t->bo) {
		teximage_assign_miptree(rmesa, texObj, texImage, face, level);
		if (!image->mt) {
			int size = _mesa_format_image_size(texImage->TexFormat,
								texImage->Width,
								texImage->Height,
								texImage->Depth);
			texImage->Data = _mesa_alloc_texmemory(size);
			radeon_print(RADEON_TEXTURE, RADEON_VERBOSE,
					"%s %dd: texObj %p, texImage %p, "
					" no miptree assigned, using local memory %p\n",
					__func__, dims, texObj, texImage, texImage->Data);
		}
	}

	/* Upload texture image; note that the spec allows pixels to be NULL */
	if (compressed) {
		pixels = _mesa_validate_pbo_compressed_teximage(
			ctx, imageSize, pixels, packing, "glCompressedTexImage");
	} else {
		pixels = _mesa_validate_pbo_teximage(
			ctx, dims, width, height, depth,
			format, type, pixels, packing, "glTexImage");
	}

	if (pixels) {
		radeon_store_teximage(ctx, dims,
			0, 0, 0,
			width, height, depth,
			imageSize, format, type,
			pixels, packing,
			texObj, texImage,
			compressed);
	}

	_mesa_unmap_teximage_pbo(ctx, packing);
}

void radeonTexImage1D(struct gl_context * ctx, GLenum target, GLint level,
		      GLint internalFormat,
		      GLint width, GLint border,
		      GLenum format, GLenum type, const GLvoid * pixels,
		      const struct gl_pixelstore_attrib *packing,
		      struct gl_texture_object *texObj,
		      struct gl_texture_image *texImage)
{
	radeon_teximage(ctx, 1, target, level, internalFormat, width, 1, 1,
		0, format, type, pixels, packing, texObj, texImage, 0);
}

void radeonTexImage2D(struct gl_context * ctx, GLenum target, GLint level,
			   GLint internalFormat,
			   GLint width, GLint height, GLint border,
			   GLenum format, GLenum type, const GLvoid * pixels,
			   const struct gl_pixelstore_attrib *packing,
			   struct gl_texture_object *texObj,
			   struct gl_texture_image *texImage)

{
	radeon_teximage(ctx, 2, target, level, internalFormat, width, height, 1,
		0, format, type, pixels, packing, texObj, texImage, 0);
}

void radeonCompressedTexImage2D(struct gl_context * ctx, GLenum target,
				     GLint level, GLint internalFormat,
				     GLint width, GLint height, GLint border,
				     GLsizei imageSize, const GLvoid * data,
				     struct gl_texture_object *texObj,
				     struct gl_texture_image *texImage)
{
	radeon_teximage(ctx, 2, target, level, internalFormat, width, height, 1,
		imageSize, 0, 0, data, &ctx->Unpack, texObj, texImage, 1);
}

void radeonTexImage3D(struct gl_context * ctx, GLenum target, GLint level,
		      GLint internalFormat,
		      GLint width, GLint height, GLint depth,
		      GLint border,
		      GLenum format, GLenum type, const GLvoid * pixels,
		      const struct gl_pixelstore_attrib *packing,
		      struct gl_texture_object *texObj,
		      struct gl_texture_image *texImage)
{
	radeon_teximage(ctx, 3, target, level, internalFormat, width, height, depth,
		0, format, type, pixels, packing, texObj, texImage, 0);
}

/**
 * All glTexSubImage calls go through this function.
 */
static void radeon_texsubimage(struct gl_context* ctx, int dims, GLenum target, int level,
		GLint xoffset, GLint yoffset, GLint zoffset,
		GLsizei width, GLsizei height, GLsizei depth,
		GLsizei imageSize,
		GLenum format, GLenum type,
		const GLvoid * pixels,
		const struct gl_pixelstore_attrib *packing,
		struct gl_texture_object *texObj,
		struct gl_texture_image *texImage,
		int compressed)
{
	radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
	radeonTexObj* t = radeon_tex_obj(texObj);
	radeon_texture_image* image = get_radeon_texture_image(texImage);

	radeon_print(RADEON_TEXTURE, RADEON_NORMAL,
			"%s %dd: texObj %p, texImage %p, face %d, level %d\n",
			__func__, dims, texObj, texImage,
			_mesa_tex_target_to_face(target), level);
	{
		struct radeon_bo *bo;
		bo = !image->mt ? image->bo : image->mt->bo;
		if (bo && radeon_bo_is_referenced_by_cs(bo, rmesa->cmdbuf.cs)) {
			radeon_print(RADEON_TEXTURE, RADEON_VERBOSE,
				"%s Calling texsubimage for texture that is "
				"queued for GPU processing.\n",
				__func__);
			radeon_firevertices(rmesa);
		}
	}


	t->validated = GL_FALSE;
	if (compressed) {
		pixels = _mesa_validate_pbo_compressed_teximage(
			ctx, imageSize, pixels, packing, "glCompressedTexSubImage");
	} else {
		pixels = _mesa_validate_pbo_teximage(ctx, dims,
			width, height, depth, format, type, pixels, packing, "glTexSubImage");
	}

	if (pixels) {
		radeon_store_teximage(ctx, dims,
			xoffset, yoffset, zoffset,
			width, height, depth,
			imageSize, format, type,
			pixels, packing,
			texObj, texImage,
			compressed);
	}

	_mesa_unmap_teximage_pbo(ctx, packing);
}

void radeonTexSubImage1D(struct gl_context * ctx, GLenum target, GLint level,
			 GLint xoffset,
			 GLsizei width,
			 GLenum format, GLenum type,
			 const GLvoid * pixels,
			 const struct gl_pixelstore_attrib *packing,
			 struct gl_texture_object *texObj,
			 struct gl_texture_image *texImage)
{
	radeon_texsubimage(ctx, 1, target, level, xoffset, 0, 0, width, 1, 1, 0,
		format, type, pixels, packing, texObj, texImage, 0);
}

void radeonTexSubImage2D(struct gl_context * ctx, GLenum target, GLint level,
			 GLint xoffset, GLint yoffset,
			 GLsizei width, GLsizei height,
			 GLenum format, GLenum type,
			 const GLvoid * pixels,
			 const struct gl_pixelstore_attrib *packing,
			 struct gl_texture_object *texObj,
			 struct gl_texture_image *texImage)
{
	radeon_texsubimage(ctx, 2, target, level, xoffset, yoffset, 0, width, height, 1,
			   0, format, type, pixels, packing, texObj, texImage,
			   0);
}

void radeonCompressedTexSubImage2D(struct gl_context * ctx, GLenum target,
				   GLint level, GLint xoffset,
				   GLint yoffset, GLsizei width,
				   GLsizei height, GLenum format,
				   GLsizei imageSize, const GLvoid * data,
				   struct gl_texture_object *texObj,
				   struct gl_texture_image *texImage)
{
	radeon_texsubimage(ctx, 2, target, level, xoffset, yoffset, 0, width, height, 1,
		imageSize, format, 0, data, &ctx->Unpack, texObj, texImage, 1);
}


void radeonTexSubImage3D(struct gl_context * ctx, GLenum target, GLint level,
			 GLint xoffset, GLint yoffset, GLint zoffset,
			 GLsizei width, GLsizei height, GLsizei depth,
			 GLenum format, GLenum type,
			 const GLvoid * pixels,
			 const struct gl_pixelstore_attrib *packing,
			 struct gl_texture_object *texObj,
			 struct gl_texture_image *texImage)
{
	radeon_texsubimage(ctx, 3, target, level, xoffset, yoffset, zoffset, width, height, depth, 0,
		format, type, pixels, packing, texObj, texImage, 0);
}

d509 2
a510 2
	if (mesa_format == _dri_texformat_argb8888 || mesa_format == _dri_texformat_rgb565 ||
		mesa_format == _dri_texformat_argb1555 || mesa_format == _dri_texformat_argb4444)
a522 1
#if FEATURE_OES_EGL_image
d540 1
a540 1
	radeonFreeTexImageData(ctx, texImage);
d547 1
a547 1
	texImage->RowStride = image->pitch;
a562 2
	radeonImage->mtface = _mesa_tex_target_to_face(target);
	radeonImage->mtlevel = 0;
d578 1
a578 2
	if (!radeon_miptree_matches_image(t->mt, &radeonImage->base,
					  radeonImage->mtface, 0))
d581 104
a684 1
#endif
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d36 1
d38 1
d252 1
d260 7
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a34 1
#include "main/convolve.h"
d41 1
a41 1
#include "main/texgetimage.h"
d79 1
a79 1
struct gl_texture_image *radeonNewTextureImage(GLcontext *ctx)
d87 1
a87 1
void radeonFreeTexImageData(GLcontext *ctx, struct gl_texture_image *timage)
d157 1
a157 1
static void map_override(GLcontext *ctx, radeonTexObj *t)
d166 1
a166 1
static void unmap_override(GLcontext *ctx, radeonTexObj *t)
d178 1
a178 1
void radeonMapTexture(GLcontext *ctx, struct gl_texture_object *texObj)
d216 1
a216 1
void radeonUnmapTexture(GLcontext *ctx, struct gl_texture_object *texObj)
d244 1
a244 1
static void radeon_generate_mipmap(GLcontext *ctx, GLenum target,
d276 1
a276 1
void radeonGenerateMipmap(GLcontext* ctx, GLenum target, struct gl_texture_object *texObj)
d297 7
a303 3
	radeon_teximage_map(baseimage, GL_FALSE);
	radeon_generate_mipmap(ctx, target, texObj);
	radeon_teximage_unmap(baseimage);
d341 1
a341 1
gl_format radeonChooseTextureFormat_mesa(GLcontext * ctx,
d350 1
a350 1
gl_format radeonChooseTextureFormat(GLcontext * ctx,
d553 1
a553 1
		return MESA_FORMAT_SRGBA8;
d565 9
d644 1
a644 1
static GLuint * allocate_image_offsets(GLcontext *ctx,
d668 1
a668 1
static void radeon_store_teximage(GLcontext* ctx, int dims,
d679 1
d694 1
a694 2
		/* TODO */
		assert(0);
d761 1
a761 1
	GLcontext *ctx, int dims,
a774 2
	GLint postConvWidth = width;
	GLint postConvHeight = height;
a794 17
	if (ctx->_ImageTransferState & IMAGE_CONVOLUTION_BIT) {
	       _mesa_adjust_image_for_convolution(ctx, dims, &postConvWidth,
						  &postConvHeight);
	}

	if (!_mesa_is_format_compressed(texImage->TexFormat)) {
		GLuint texelBytes = _mesa_get_format_bytes(texImage->TexFormat);
		/* Minimum pitch of 32 bytes */
		if (postConvWidth * texelBytes < 32) {
			postConvWidth = 32 / texelBytes;
			texImage->RowStride = postConvWidth;
		}
		if (!image->mt) {
			assert(texImage->RowStride == postConvWidth);
		}
	}

d836 1
a836 1
void radeonTexImage1D(GLcontext * ctx, GLenum target, GLint level,
d848 1
a848 1
void radeonTexImage2D(GLcontext * ctx, GLenum target, GLint level,
d861 1
a861 1
void radeonCompressedTexImage2D(GLcontext * ctx, GLenum target,
d872 1
a872 1
void radeonTexImage3D(GLcontext * ctx, GLenum target, GLint level,
d888 1
a888 1
static void radeon_texsubimage(GLcontext* ctx, int dims, GLenum target, int level,
d942 1
a942 1
void radeonTexSubImage1D(GLcontext * ctx, GLenum target, GLint level,
d955 1
a955 1
void radeonTexSubImage2D(GLcontext * ctx, GLenum target, GLint level,
d969 1
a969 1
void radeonCompressedTexSubImage2D(GLcontext * ctx, GLenum target,
d982 1
a982 1
void radeonTexSubImage3D(GLcontext * ctx, GLenum target, GLint level,
d995 21
a1015 9
/**
 * Need to map texture image into memory before copying image data,
 * then unmap it.
 */
static void
radeon_get_tex_image(GLcontext * ctx, GLenum target, GLint level,
		     GLenum format, GLenum type, GLvoid * pixels,
		     struct gl_texture_object *texObj,
		     struct gl_texture_image *texImage, int compressed)
d1017 13
a1029 1
	radeon_texture_image *image = get_radeon_texture_image(texImage);
d1031 7
a1037 3
	radeon_print(RADEON_TEXTURE, RADEON_NORMAL,
			"%s(%p, tex %p, image %p) compressed %d.\n",
			__func__, ctx, texObj, image, compressed);
d1039 4
a1042 6
	if (image->mt) {
		/* Map the texture image read-only */
		radeon_teximage_map(image, GL_FALSE);
	} else {
		/* Image hasn't been uploaded to a miptree yet */
		assert(image->base.Data);
d1045 16
a1060 8
	if (compressed) {
		/* FIXME: this can't work for small textures (mips) which
		         use different hw stride */
		_mesa_get_compressed_teximage(ctx, target, level, pixels,
					      texObj, texImage);
	} else {
		_mesa_get_teximage(ctx, target, level, format, type, pixels,
				   texObj, texImage);
a1061 5
     
	if (image->mt) {
		radeon_teximage_unmap(image);
	}
}
d1063 9
a1071 18
void
radeonGetTexImage(GLcontext * ctx, GLenum target, GLint level,
		  GLenum format, GLenum type, GLvoid * pixels,
		  struct gl_texture_object *texObj,
		  struct gl_texture_image *texImage)
{
	radeon_get_tex_image(ctx, target, level, format, type, pixels,
			     texObj, texImage, 0);
}

void
radeonGetCompressedTexImage(GLcontext *ctx, GLenum target, GLint level,
			    GLvoid *pixels,
			    struct gl_texture_object *texObj,
			    struct gl_texture_image *texImage)
{
	radeon_get_tex_image(ctx, target, level, 0, 0, pixels,
			     texObj, texImage, 1);
d1073 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d35 1
d42 1
a42 1
#include "drivers/common/meta.h"
d80 1
a80 1
struct gl_texture_image *radeonNewTextureImage(struct gl_context *ctx)
d88 1
a88 1
void radeonFreeTexImageData(struct gl_context *ctx, struct gl_texture_image *timage)
d158 1
a158 1
static void map_override(struct gl_context *ctx, radeonTexObj *t)
d167 1
a167 1
static void unmap_override(struct gl_context *ctx, radeonTexObj *t)
d179 1
a179 1
void radeonMapTexture(struct gl_context *ctx, struct gl_texture_object *texObj)
d217 1
a217 1
void radeonUnmapTexture(struct gl_context *ctx, struct gl_texture_object *texObj)
d245 1
a245 1
static void radeon_generate_mipmap(struct gl_context *ctx, GLenum target,
d277 1
a277 1
void radeonGenerateMipmap(struct gl_context* ctx, GLenum target, struct gl_texture_object *texObj)
d298 3
a300 7
	if (_mesa_meta_check_generate_mipmap_fallback(ctx, target, texObj)) {
		radeon_teximage_map(baseimage, GL_FALSE);
		radeon_generate_mipmap(ctx, target, texObj);
		radeon_teximage_unmap(baseimage);
	} else {
		_mesa_meta_GenerateMipmap(ctx, target, texObj);
	}
d338 1
a338 1
gl_format radeonChooseTextureFormat_mesa(struct gl_context * ctx,
d347 1
a347 1
gl_format radeonChooseTextureFormat(struct gl_context * ctx,
d550 1
a550 1
		return MESA_FORMAT_SARGB8;
a561 9
	case GL_COMPRESSED_SRGB_S3TC_DXT1_EXT:
		return MESA_FORMAT_SRGB_DXT1;
	case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:
		return MESA_FORMAT_SRGBA_DXT1;
	case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:
		return MESA_FORMAT_SRGBA_DXT3;
	case GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:
		return MESA_FORMAT_SRGBA_DXT5;

d632 1
a632 1
static GLuint * allocate_image_offsets(struct gl_context *ctx,
d656 1
a656 1
static void radeon_store_teximage(struct gl_context* ctx, int dims,
a666 1
	radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d681 2
a682 1
		dstRowStride = get_texture_image_row_stride(rmesa, texImage->TexFormat, width, 0);
d749 1
a749 1
	struct gl_context *ctx, int dims,
d763 2
d785 17
d843 1
a843 1
void radeonTexImage1D(struct gl_context * ctx, GLenum target, GLint level,
d855 1
a855 1
void radeonTexImage2D(struct gl_context * ctx, GLenum target, GLint level,
d868 1
a868 1
void radeonCompressedTexImage2D(struct gl_context * ctx, GLenum target,
d879 1
a879 1
void radeonTexImage3D(struct gl_context * ctx, GLenum target, GLint level,
d895 1
a895 1
static void radeon_texsubimage(struct gl_context* ctx, int dims, GLenum target, int level,
d949 1
a949 1
void radeonTexSubImage1D(struct gl_context * ctx, GLenum target, GLint level,
d962 1
a962 1
void radeonTexSubImage2D(struct gl_context * ctx, GLenum target, GLint level,
d976 1
a976 1
void radeonCompressedTexSubImage2D(struct gl_context * ctx, GLenum target,
d989 1
a989 1
void radeonTexSubImage3D(struct gl_context * ctx, GLenum target, GLint level,
d1002 9
a1010 1
unsigned radeonIsFormatRenderable(gl_format mesa_format)
d1012 5
a1016 3
	if (mesa_format == _dri_texformat_argb8888 || mesa_format == _dri_texformat_rgb565 ||
		mesa_format == _dri_texformat_argb1555 || mesa_format == _dri_texformat_argb4444)
		return 1;
d1018 20
a1037 7
	switch (mesa_format)
	{
		case MESA_FORMAT_Z16:
		case MESA_FORMAT_S8_Z24:
			return 1;
		default:
			return 0;
d1041 5
a1045 5
#if FEATURE_OES_EGL_image
void radeon_image_target_texture_2d(struct gl_context *ctx, GLenum target,
				    struct gl_texture_object *texObj,
				    struct gl_texture_image *texImage,
				    GLeglImageOES image_handle)
d1047 3
a1049 11
	radeonContextPtr radeon = RADEON_CONTEXT(ctx);
	radeonTexObj *t = radeon_tex_obj(texObj);
	radeon_texture_image *radeonImage = get_radeon_texture_image(texImage);
	__DRIscreen *screen;
	__DRIimage *image;

	screen = radeon->dri.screen;
	image = screen->dri2.image->lookupEGLImage(screen, image_handle,
						   screen->loaderPrivate);
	if (image == NULL)
		return;
d1051 8
a1058 43
	radeonFreeTexImageData(ctx, texImage);

	texImage->Width = image->width;
	texImage->Height = image->height;
	texImage->Depth = 1;
	texImage->_BaseFormat = GL_RGBA;
	texImage->TexFormat = image->format;
	texImage->RowStride = image->pitch;
	texImage->InternalFormat = image->internal_format;

	if(t->mt)
	{
		radeon_miptree_unreference(&t->mt);
		t->mt = NULL;
	}

	/* NOTE: The following is *very* ugly and will probably break. But
	   I don't know how to deal with it, without creating a whole new
	   function like radeon_miptree_from_bo() so I'm going with the
	   easy but error-prone way. */

	radeon_try_alloc_miptree(radeon, t);

	radeonImage->mtface = _mesa_tex_target_to_face(target);
	radeonImage->mtlevel = 0;
	radeon_miptree_reference(t->mt, &radeonImage->mt);

	if (t->mt == NULL)
	{
		radeon_print(RADEON_TEXTURE, RADEON_VERBOSE,
			     "%s Failed to allocate miptree.\n", __func__);
		return;
	}

	/* Particularly ugly: this is guaranteed to break, if image->bo is
	   not of the required size for a miptree. */
	radeon_bo_unref(t->mt->bo);
	radeon_bo_ref(image->bo);
	t->mt->bo = image->bo;

	if (!radeon_miptree_matches_image(t->mt, &radeonImage->base,
					  radeonImage->mtface, 0))
		fprintf(stderr, "miptree doesn't match image\n");
a1059 1
#endif
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a36 1
#include "main/pbo.h"
a48 7
static void teximage_assign_miptree(radeonContextPtr rmesa,
				    struct gl_texture_object *texObj,
				    struct gl_texture_image *texImage);

static radeon_mipmap_tree *radeon_miptree_create_for_teximage(radeonContextPtr rmesa,
							      struct gl_texture_object *texObj,
							      struct gl_texture_image *texImage);
d81 1
a81 1
	return calloc(1, sizeof(radeon_texture_image));
a83 1

d85 1
a85 1
 * Delete a texture image object.
d87 1
a87 2
static void
radeonDeleteTextureImage(struct gl_context *ctx, struct gl_texture_image *img)
d89 16
a104 2
	/* nothing special (yet) for radeon_texture_image */
	_mesa_delete_texture_image(ctx, img);
d107 2
a108 3
static GLboolean
radeonAllocTextureImageBuffer(struct gl_context *ctx,
			      struct gl_texture_image *timage)
d110 1
a110 2
	radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
	struct gl_texture_object *texobj = timage->TexObject;
d112 3
a114 1
	ctx->Driver.FreeTextureImageBuffer(ctx, timage);
d116 2
a117 2
	if (!_swrast_init_texture_image(timage))
		return GL_FALSE;
d119 4
a122 3
	teximage_assign_miptree(rmesa, texobj, timage);
				
	return GL_TRUE;
d127 1
a127 1
 * Free memory associated with this texture image.
d129 1
a129 1
void radeonFreeTextureImageBuffer(struct gl_context *ctx, struct gl_texture_image *timage)
d131 12
a142 1
	radeon_texture_image* image = get_radeon_texture_image(timage);
d144 5
d150 4
a153 5
		radeon_miptree_unreference(&image->mt);
	}
	if (image->bo) {
		radeon_bo_unref(image->bo);
		image->bo = NULL;
d155 16
d172 1
a172 1
        _swrast_free_texture_image_buffer(ctx, timage);
d176 1
a176 4
 * Map texture memory/buffer into user space.
 * Note: the region of interest parameters are ignored here.
 * \param mapOut  returns start of mapping of region of interest
 * \param rowStrideOut  returns row stride in bytes
d178 1
a178 8
static void
radeon_map_texture_image(struct gl_context *ctx,
			 struct gl_texture_image *texImage,
			 GLuint slice,
			 GLuint x, GLuint y, GLuint w, GLuint h,
			 GLbitfield mode,
			 GLubyte **map,
			 GLint *stride)
d180 13
a192 14
	radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
	radeon_texture_image *image = get_radeon_texture_image(texImage);
	radeon_mipmap_tree *mt = image->mt;
	GLuint texel_size = _mesa_get_format_bytes(texImage->TexFormat);
	GLuint width = texImage->Width;
	GLuint height = texImage->Height;
	struct radeon_bo *bo = !image->mt ? image->bo : image->mt->bo;
	unsigned int bw, bh;
	GLboolean write = (mode & GL_MAP_WRITE_BIT) != 0;

	_mesa_get_format_block_size(texImage->TexFormat, &bw, &bh);
	assert(y % bh == 0);
	y /= bh;
	texel_size /= bw;
d194 1
a194 1
	if (bo && radeon_bo_is_referenced_by_cs(bo, rmesa->cmdbuf.cs)) {
d196 4
a199 4
			     "%s for texture that is "
			     "queued for GPU processing.\n",
			     __func__);
		radeon_firevertices(rmesa);
d202 6
a207 11
	if (image->bo) {
		/* TFP case */
		radeon_bo_map(image->bo, write);
		*stride = get_texture_image_row_stride(rmesa, texImage->TexFormat, width, 0, texImage->TexObject->Target);
		*map = bo->ptr;
	} else if (likely(mt)) {
		void *base;
		radeon_mipmap_level *lvl = &image->mt->levels[texImage->Level];
		       
		radeon_bo_map(mt->bo, write);
		base = mt->bo->ptr + lvl->faces[image->base.Base.Face].offset;
d209 6
a214 4
		*stride = lvl->rowstride;
		*map = base + (slice * height) * *stride;
	} else {
		/* texture data is in malloc'd memory */
d216 4
a219 1
		assert(map);
d221 13
a233 2
		*stride = _mesa_format_row_stride(texImage->TexFormat, width);
		*map = image->base.Buffer + (slice * height) * *stride;
d235 22
d258 16
a273 1
	*map += y * *stride + x * texel_size;
d276 1
a276 3
static void
radeon_unmap_texture_image(struct gl_context *ctx,
			   struct gl_texture_image *texImage, GLuint slice)
d278 5
a282 1
	radeon_texture_image *image = get_radeon_texture_image(texImage);
d284 20
a303 4
	if (image->bo)
		radeon_bo_unmap(image->bo);
	else if (image->mt)
		radeon_bo_unmap(image->mt->bo);
d306 1
a311 4
#if defined(RADEON_R100)
	/* r100 can only do this */
	return _radeon_texformat_argb8888;
#elif defined(RADEON_R200)
d315 3
a317 2
	if (fbo)
		return _radeon_texformat_argb8888;
d329 8
d338 1
a338 2
		return _radeon_texformat_argb8888;
#endif
a341 1
					 GLenum target,
d378 2
a379 2
			return do32bpt ? _radeon_texformat_argb8888 :
			    _radeon_texformat_argb1555;
d382 1
a382 1
			return _radeon_texformat_argb4444;
d385 1
a385 1
			return _radeon_texformat_argb1555;
d388 1
a388 1
			    _radeon_texformat_argb4444;
d397 1
a397 1
			return _radeon_texformat_argb4444;
d400 1
a400 1
			return _radeon_texformat_argb1555;
d403 1
a403 1
			return _radeon_texformat_rgb565;
d405 2
a406 2
			return do32bpt ? _radeon_texformat_argb8888 :
			    _radeon_texformat_rgb565;
d415 1
a415 1
			_radeon_texformat_argb4444;
d419 1
a419 1
		return _radeon_texformat_argb4444;
d422 1
a422 1
		return _radeon_texformat_argb1555;
d428 2
a429 2
		return !force16bpt ? _radeon_texformat_argb8888 :
		    _radeon_texformat_rgb565;
d434 1
a434 1
		return _radeon_texformat_rgb565;
a441 1
#if defined(RADEON_R200)
d444 4
a447 4
		return _radeon_texformat_al88;
#else
		return MESA_FORMAT_A8;
#endif
d455 1
a455 1
		return MESA_FORMAT_L8;
d466 1
a466 1
		return _radeon_texformat_al88;
d474 1
a474 1
		return MESA_FORMAT_I8;
d524 13
d544 1
d586 22
d609 4
a612 2
				    struct gl_texture_object *texObj,
				    struct gl_texture_image *texImage)
d617 6
d624 1
a624 1
	if (!t->mt || !radeon_miptree_matches_image(t->mt, texImage)) {
d626 1
a626 4
		t->mt = radeon_miptree_create_for_teximage(rmesa,
							   texObj,
							   texImage);

d628 1
a628 1
			     "%s: texObj %p, texImage %p, "
d630 1
a630 1
				__FUNCTION__, texObj, texImage, t->mt);
d636 2
d644 351
d997 2
a998 2
	if (mesa_format == _radeon_texformat_argb8888 || mesa_format == _radeon_texformat_rgb565 ||
		mesa_format == _radeon_texformat_argb1555 || mesa_format == _radeon_texformat_argb4444)
d1011 1
d1029 1
a1029 1
	radeonFreeTextureImageBuffer(ctx, texImage);
d1036 1
a1036 1
	radeonImage->base.RowStride = image->pitch;
d1052 2
d1069 2
a1070 1
	if (!radeon_miptree_matches_image(t->mt, &radeonImage->base.Base))
d1073 1
a1073 104

gl_format _radeon_texformat_rgba8888 = MESA_FORMAT_NONE;
gl_format _radeon_texformat_argb8888 = MESA_FORMAT_NONE;
gl_format _radeon_texformat_rgb565 = MESA_FORMAT_NONE;
gl_format _radeon_texformat_argb4444 = MESA_FORMAT_NONE;
gl_format _radeon_texformat_argb1555 = MESA_FORMAT_NONE;
gl_format _radeon_texformat_al88 = MESA_FORMAT_NONE;
/*@@}*/


static void
radeonInitTextureFormats(void)
{
   if (_mesa_little_endian()) {
      _radeon_texformat_rgba8888	= MESA_FORMAT_RGBA8888;
      _radeon_texformat_argb8888	= MESA_FORMAT_ARGB8888;
      _radeon_texformat_rgb565		= MESA_FORMAT_RGB565;
      _radeon_texformat_argb4444	= MESA_FORMAT_ARGB4444;
      _radeon_texformat_argb1555	= MESA_FORMAT_ARGB1555;
      _radeon_texformat_al88		= MESA_FORMAT_AL88;
   }
   else {
      _radeon_texformat_rgba8888	= MESA_FORMAT_RGBA8888_REV;
      _radeon_texformat_argb8888	= MESA_FORMAT_ARGB8888_REV;
      _radeon_texformat_rgb565		= MESA_FORMAT_RGB565_REV;
      _radeon_texformat_argb4444	= MESA_FORMAT_ARGB4444_REV;
      _radeon_texformat_argb1555	= MESA_FORMAT_ARGB1555_REV;
      _radeon_texformat_al88		= MESA_FORMAT_AL88_REV;
   }
}

void
radeon_init_common_texture_funcs(radeonContextPtr radeon,
				 struct dd_function_table *functions)
{
	functions->NewTextureImage = radeonNewTextureImage;
	functions->DeleteTextureImage = radeonDeleteTextureImage;
	functions->AllocTextureImageBuffer = radeonAllocTextureImageBuffer;
	functions->FreeTextureImageBuffer = radeonFreeTextureImageBuffer;
	functions->MapTextureImage = radeon_map_texture_image;
	functions->UnmapTextureImage = radeon_unmap_texture_image;

	functions->ChooseTextureFormat	= radeonChooseTextureFormat_mesa;

	functions->CopyTexSubImage = radeonCopyTexSubImage;

	functions->Bitmap = _mesa_meta_Bitmap;
	functions->EGLImageTargetTexture2D = radeon_image_target_texture_2d;

	radeonInitTextureFormats();
}

static radeon_mipmap_tree *radeon_miptree_create_for_teximage(radeonContextPtr rmesa,
						       struct gl_texture_object *texObj,
						       struct gl_texture_image *texImage)
{
	radeonTexObj *t = radeon_tex_obj(texObj);
	GLuint firstLevel;
	GLuint lastLevel;
	int width, height, depth;
	int i;

	width = texImage->Width;
	height = texImage->Height;
	depth = texImage->Depth;

	if (texImage->Level > texObj->BaseLevel &&
	    (width == 1 ||
	     (texObj->Target != GL_TEXTURE_1D && height == 1) ||
	     (texObj->Target == GL_TEXTURE_3D && depth == 1))) {
		/* For this combination, we're at some lower mipmap level and
		 * some important dimension is 1.  We can't extrapolate up to a
		 * likely base level width/height/depth for a full mipmap stack
		 * from this info, so just allocate this one level.
		 */
		firstLevel = texImage->Level;
		lastLevel = texImage->Level;
	} else {
		if (texImage->Level < texObj->BaseLevel)
			firstLevel = 0;
		else
			firstLevel = texObj->BaseLevel;

		for (i = texImage->Level; i > firstLevel; i--) {
			width <<= 1;
			if (height != 1)
				height <<= 1;
			if (depth != 1)
				depth <<= 1;
		}
		if ((texObj->Sampler.MinFilter == GL_NEAREST ||
		     texObj->Sampler.MinFilter == GL_LINEAR) &&
		    texImage->Level == firstLevel) {
			lastLevel = firstLevel;
		} else {
			lastLevel = firstLevel + _mesa_logbase2(MAX2(MAX2(width, height), depth));
		}
	}

	return  radeon_miptree_create(rmesa, texObj->Target,
				      texImage->TexFormat, firstLevel, lastLevel - firstLevel + 1,
				      width, height, depth, 
				      t->tile_bits);
}				     
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d216 1
a216 1
static mesa_format radeonChoose8888TexFormat(radeonContextPtr rmesa,
d234 1
a234 1
		return MESA_FORMAT_A8B8G8R8_UNORM;
d239 1
a239 1
		return MESA_FORMAT_R8G8B8A8_UNORM;
d245 1
a245 1
mesa_format radeonChooseTextureFormat_mesa(struct gl_context * ctx,
d255 1
a255 1
mesa_format radeonChooseTextureFormat(struct gl_context * ctx,
d352 1
a352 1
		return MESA_FORMAT_A_UNORM8;
d361 1
a361 1
		return MESA_FORMAT_L_UNORM8;
d380 1
a380 1
		return MESA_FORMAT_I_UNORM8;
d406 1
a406 1
		return MESA_FORMAT_A_FLOAT16;
d408 1
a408 1
		return MESA_FORMAT_A_FLOAT32;
d410 1
a410 1
		return MESA_FORMAT_L_FLOAT16;
d412 1
a412 1
		return MESA_FORMAT_L_FLOAT32;
d414 1
a414 1
		return MESA_FORMAT_LA_FLOAT16;
d416 1
a416 1
		return MESA_FORMAT_LA_FLOAT32;
d418 1
a418 1
		return MESA_FORMAT_I_FLOAT16;
d420 1
a420 1
		return MESA_FORMAT_I_FLOAT32;
d436 1
a436 1
		return MESA_FORMAT_Z24_UNORM_S8_UINT;
d445 1
a445 1
		return MESA_FORMAT_B8G8R8A8_SRGB;
d450 1
a450 1
		return MESA_FORMAT_L_SRGB8;
d455 1
a455 1
      return MESA_FORMAT_L8A8_SRGB;
d507 1
a507 1
unsigned radeonIsFormatRenderable(mesa_format mesa_format)
d515 2
a516 2
		case MESA_FORMAT_Z_UNORM16:
		case MESA_FORMAT_Z24_UNORM_S8_UINT:
d582 6
a587 6
mesa_format _radeon_texformat_rgba8888 = MESA_FORMAT_NONE;
mesa_format _radeon_texformat_argb8888 = MESA_FORMAT_NONE;
mesa_format _radeon_texformat_rgb565 = MESA_FORMAT_NONE;
mesa_format _radeon_texformat_argb4444 = MESA_FORMAT_NONE;
mesa_format _radeon_texformat_argb1555 = MESA_FORMAT_NONE;
mesa_format _radeon_texformat_al88 = MESA_FORMAT_NONE;
d595 6
a600 6
      _radeon_texformat_rgba8888	= MESA_FORMAT_A8B8G8R8_UNORM;
      _radeon_texformat_argb8888	= MESA_FORMAT_B8G8R8A8_UNORM;
      _radeon_texformat_rgb565		= MESA_FORMAT_B5G6R5_UNORM;
      _radeon_texformat_argb4444	= MESA_FORMAT_B4G4R4A4_UNORM;
      _radeon_texformat_argb1555	= MESA_FORMAT_B5G5R5A1_UNORM;
      _radeon_texformat_al88		= MESA_FORMAT_L8A8_UNORM;
d603 6
a608 6
      _radeon_texformat_rgba8888	= MESA_FORMAT_R8G8B8A8_UNORM;
      _radeon_texformat_argb8888	= MESA_FORMAT_A8R8G8B8_UNORM;
      _radeon_texformat_rgb565		= MESA_FORMAT_R5G6B5_UNORM;
      _radeon_texformat_argb4444	= MESA_FORMAT_A4R4G4B4_UNORM;
      _radeon_texformat_argb1555	= MESA_FORMAT_A1R5G5B5_UNORM;
      _radeon_texformat_al88		= MESA_FORMAT_A8L8_UNORM;
@


