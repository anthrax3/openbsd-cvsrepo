head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@// @;


1.6
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.4;
commitid	4ry2gvZGMXkCUD2n;

1.4
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.3;
commitid	mcxB0JvoI9gTDYXU;

1.3
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.2;
commitid	WPD6rgPryPkvXOr9;

1.2
date	2013.09.05.14.04.20;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.15.37;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.51;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.11.44;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.48.49;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

extern "C" {
#include "main/macros.h"
#include "brw_context.h"
}
#include "brw_vs.h"
#include "brw_vec4_gs.h"
#include "brw_fs.h"
#include "glsl/ir_optimization.h"
#include "glsl/glsl_parser_extras.h"
#include "main/shaderapi.h"

struct gl_shader *
brw_new_shader(struct gl_context *ctx, GLuint name, GLuint type)
{
   struct brw_shader *shader;

   shader = rzalloc(NULL, struct brw_shader);
   if (shader) {
      shader->base.Type = type;
      shader->base.Stage = _mesa_shader_enum_to_shader_stage(type);
      shader->base.Name = name;
      _mesa_init_shader(ctx, &shader->base);
   }

   return &shader->base;
}

struct gl_shader_program *
brw_new_shader_program(struct gl_context *ctx, GLuint name)
{
   struct gl_shader_program *prog = rzalloc(NULL, struct gl_shader_program);
   if (prog) {
      prog->Name = name;
      _mesa_init_shader_program(ctx, prog);
   }
   return prog;
}

/**
 * Performs a compile of the shader stages even when we don't know
 * what non-orthogonal state will be set, in the hope that it reflects
 * the eventual NOS used, and thus allows us to produce link failures.
 */
static bool
brw_shader_precompile(struct gl_context *ctx, struct gl_shader_program *prog)
{
   struct brw_context *brw = brw_context(ctx);

   if (brw->precompile && !brw_fs_precompile(ctx, prog))
      return false;

   if (brw->precompile && !brw_gs_precompile(ctx, prog))
      return false;

   if (brw->precompile && !brw_vs_precompile(ctx, prog))
      return false;

   return true;
}

static void
brw_lower_packing_builtins(struct brw_context *brw,
                           gl_shader_stage shader_type,
                           exec_list *ir)
{
   int ops = LOWER_PACK_SNORM_2x16
           | LOWER_UNPACK_SNORM_2x16
           | LOWER_PACK_UNORM_2x16
           | LOWER_UNPACK_UNORM_2x16
           | LOWER_PACK_SNORM_4x8
           | LOWER_UNPACK_SNORM_4x8
           | LOWER_PACK_UNORM_4x8
           | LOWER_UNPACK_UNORM_4x8;

   if (brw->gen >= 7) {
      /* Gen7 introduced the f32to16 and f16to32 instructions, which can be
       * used to execute packHalf2x16 and unpackHalf2x16. For AOS code, no
       * lowering is needed. For SOA code, the Half2x16 ops must be
       * scalarized.
       */
      if (shader_type == MESA_SHADER_FRAGMENT) {
         ops |= LOWER_PACK_HALF_2x16_TO_SPLIT
             |  LOWER_UNPACK_HALF_2x16_TO_SPLIT;
      }
   } else {
      ops |= LOWER_PACK_HALF_2x16
          |  LOWER_UNPACK_HALF_2x16;
   }

   lower_packing_builtins(ir, ops);
}

GLboolean
brw_link_shader(struct gl_context *ctx, struct gl_shader_program *shProg)
{
   struct brw_context *brw = brw_context(ctx);
   unsigned int stage;

   for (stage = 0; stage < ARRAY_SIZE(shProg->_LinkedShaders); stage++) {
      const struct gl_shader_compiler_options *options =
         &ctx->ShaderCompilerOptions[stage];
      struct brw_shader *shader =
	 (struct brw_shader *)shProg->_LinkedShaders[stage];

      if (!shader)
	 continue;

      struct gl_program *prog =
	 ctx->Driver.NewProgram(ctx, _mesa_shader_stage_to_program(stage),
                                shader->base.Name);
      if (!prog)
	return false;
      prog->Parameters = _mesa_new_parameter_list();

      _mesa_copy_linked_program_data((gl_shader_stage) stage, shProg, prog);

      bool progress;

      /* lower_packing_builtins() inserts arithmetic instructions, so it
       * must precede lower_instructions().
       */
      brw_lower_packing_builtins(brw, (gl_shader_stage) stage, shader->base.ir);
      do_mat_op_to_vec(shader->base.ir);
      const int bitfield_insert = brw->gen >= 7
                                  ? BITFIELD_INSERT_TO_BFM_BFI
                                  : 0;
      lower_instructions(shader->base.ir,
			 MOD_TO_FRACT |
			 DIV_TO_MUL_RCP |
			 SUB_TO_ADD_NEG |
			 EXP_TO_EXP2 |
			 LOG_TO_LOG2 |
                         bitfield_insert |
                         LDEXP_TO_ARITH);

      /* Pre-gen6 HW can only nest if-statements 16 deep.  Beyond this,
       * if-statements need to be flattened.
       */
      if (brw->gen < 6)
	 lower_if_to_cond_assign(shader->base.ir, 16);

      do_lower_texture_projection(shader->base.ir);
      brw_lower_texture_gradients(brw, shader->base.ir);
      do_vec_index_to_cond_assign(shader->base.ir);
      lower_vector_insert(shader->base.ir, true);
      brw_do_cubemap_normalize(shader->base.ir);
      lower_offset_arrays(shader->base.ir);
      brw_do_lower_unnormalized_offset(shader->base.ir);
      lower_noise(shader->base.ir);
      lower_quadop_vector(shader->base.ir, false);

      bool lowered_variable_indexing =
         lower_variable_index_to_cond_assign(shader->base.ir,
                                             options->EmitNoIndirectInput,
                                             options->EmitNoIndirectOutput,
                                             options->EmitNoIndirectTemp,
                                             options->EmitNoIndirectUniform);

      if (unlikely(brw->perf_debug && lowered_variable_indexing)) {
         perf_debug("Unsupported form of variable indexing in FS; falling "
                    "back to very inefficient code generation\n");
      }

      lower_ubo_reference(&shader->base, shader->base.ir);

      do {
	 progress = false;

	 if (stage == MESA_SHADER_FRAGMENT) {
	    brw_do_channel_expressions(shader->base.ir);
	    brw_do_vector_splitting(shader->base.ir);
	 }

	 progress = do_lower_jumps(shader->base.ir, true, true,
				   true, /* main return */
				   false, /* continue */
				   false /* loops */
				   ) || progress;

	 progress = do_common_optimization(shader->base.ir, true, true,
                                           options, ctx->Const.NativeIntegers)
	   || progress;
      } while (progress);

      /* Make a pass over the IR to add state references for any built-in
       * uniforms that are used.  This has to be done now (during linking).
       * Code generation doesn't happen until the first time this shader is
       * used for rendering.  Waiting until then to generate the parameters is
       * too late.  At that point, the values for the built-in uniforms won't
       * get sent to the shader.
       */
      foreach_list(node, shader->base.ir) {
	 ir_variable *var = ((ir_instruction *) node)->as_variable();

	 if ((var == NULL) || (var->data.mode != ir_var_uniform)
	     || (strncmp(var->name, "gl_", 3) != 0))
	    continue;

	 const ir_state_slot *const slots = var->state_slots;
	 assert(var->state_slots != NULL);

	 for (unsigned int i = 0; i < var->num_state_slots; i++) {
	    _mesa_add_state_reference(prog->Parameters,
				      (gl_state_index *) slots[i].tokens);
	 }
      }

      validate_ir_tree(shader->base.ir);

      do_set_program_inouts(shader->base.ir, prog, shader->base.Stage);

      prog->SamplersUsed = shader->base.active_samplers;
      _mesa_update_shader_textures_used(shProg, prog);

      _mesa_reference_program(ctx, &shader->base.Program, prog);

      brw_add_texrect_params(prog);

      /* This has to be done last.  Any operation that can cause
       * prog->ParameterValues to get reallocated (e.g., anything that adds a
       * program constant) has to happen before creating this linkage.
       */
      _mesa_associate_uniform_storage(ctx, shProg, prog->Parameters);

      _mesa_reference_program(ctx, &prog, NULL);

      if (ctx->_Shader->Flags & GLSL_DUMP) {
         fprintf(stderr, "\n");
         fprintf(stderr, "GLSL IR for linked %s program %d:\n",
                 _mesa_shader_stage_to_string(shader->base.Stage),
                 shProg->Name);
         _mesa_print_ir(stderr, shader->base.ir, NULL);
         fprintf(stderr, "\n");
      }
   }

   if ((ctx->_Shader->Flags & GLSL_DUMP) && shProg->Name != 0) {
      for (unsigned i = 0; i < shProg->NumShaders; i++) {
         const struct gl_shader *sh = shProg->Shaders[i];
         if (!sh)
            continue;

         fprintf(stderr, "GLSL %s shader %d source for linked program %d:\n",
                 _mesa_shader_stage_to_string(sh->Stage),
                 i, shProg->Name);
         fprintf(stderr, "%s", sh->Source);
         fprintf(stderr, "\n");
      }
   }

   if (!brw_shader_precompile(ctx, shProg))
      return false;

   return true;
}


int
brw_type_for_base_type(const struct glsl_type *type)
{
   switch (type->base_type) {
   case GLSL_TYPE_FLOAT:
      return BRW_REGISTER_TYPE_F;
   case GLSL_TYPE_INT:
   case GLSL_TYPE_BOOL:
      return BRW_REGISTER_TYPE_D;
   case GLSL_TYPE_UINT:
      return BRW_REGISTER_TYPE_UD;
   case GLSL_TYPE_ARRAY:
      return brw_type_for_base_type(type->fields.array);
   case GLSL_TYPE_STRUCT:
   case GLSL_TYPE_SAMPLER:
   case GLSL_TYPE_ATOMIC_UINT:
      /* These should be overridden with the type of the member when
       * dereferenced into.  BRW_REGISTER_TYPE_UD seems like a likely
       * way to trip up if we don't.
       */
      return BRW_REGISTER_TYPE_UD;
   case GLSL_TYPE_IMAGE:
      return BRW_REGISTER_TYPE_UD;
   case GLSL_TYPE_VOID:
   case GLSL_TYPE_ERROR:
   case GLSL_TYPE_INTERFACE:
      assert(!"not reached");
      break;
   }

   return BRW_REGISTER_TYPE_F;
}

uint32_t
brw_conditional_for_comparison(unsigned int op)
{
   switch (op) {
   case ir_binop_less:
      return BRW_CONDITIONAL_L;
   case ir_binop_greater:
      return BRW_CONDITIONAL_G;
   case ir_binop_lequal:
      return BRW_CONDITIONAL_LE;
   case ir_binop_gequal:
      return BRW_CONDITIONAL_GE;
   case ir_binop_equal:
   case ir_binop_all_equal: /* same as equal for scalars */
      return BRW_CONDITIONAL_Z;
   case ir_binop_nequal:
   case ir_binop_any_nequal: /* same as nequal for scalars */
      return BRW_CONDITIONAL_NZ;
   default:
      assert(!"not reached: bad operation for comparison");
      return BRW_CONDITIONAL_NZ;
   }
}

uint32_t
brw_math_function(enum opcode op)
{
   switch (op) {
   case SHADER_OPCODE_RCP:
      return BRW_MATH_FUNCTION_INV;
   case SHADER_OPCODE_RSQ:
      return BRW_MATH_FUNCTION_RSQ;
   case SHADER_OPCODE_SQRT:
      return BRW_MATH_FUNCTION_SQRT;
   case SHADER_OPCODE_EXP2:
      return BRW_MATH_FUNCTION_EXP;
   case SHADER_OPCODE_LOG2:
      return BRW_MATH_FUNCTION_LOG;
   case SHADER_OPCODE_POW:
      return BRW_MATH_FUNCTION_POW;
   case SHADER_OPCODE_SIN:
      return BRW_MATH_FUNCTION_SIN;
   case SHADER_OPCODE_COS:
      return BRW_MATH_FUNCTION_COS;
   case SHADER_OPCODE_INT_QUOTIENT:
      return BRW_MATH_FUNCTION_INT_DIV_QUOTIENT;
   case SHADER_OPCODE_INT_REMAINDER:
      return BRW_MATH_FUNCTION_INT_DIV_REMAINDER;
   default:
      assert(!"not reached: unknown math function");
      return 0;
   }
}

uint32_t
brw_texture_offset(struct gl_context *ctx, ir_constant *offset)
{
   /* If the driver does not support GL_ARB_gpu_shader5, the offset
    * must be constant.
    */
   assert(offset != NULL || ctx->Extensions.ARB_gpu_shader5);

   if (!offset) return 0;  /* nonconstant offset; caller will handle it. */

   signed char offsets[3];
   for (unsigned i = 0; i < offset->type->vector_elements; i++)
      offsets[i] = (signed char) offset->value.i[i];

   /* Combine all three offsets into a single unsigned dword:
    *
    *    bits 11:8 - U Offset (X component)
    *    bits  7:4 - V Offset (Y component)
    *    bits  3:0 - R Offset (Z component)
    */
   unsigned offset_bits = 0;
   for (unsigned i = 0; i < offset->type->vector_elements; i++) {
      const unsigned shift = 4 * (2 - i);
      offset_bits |= (offsets[i] << shift) & (0xF << shift);
   }
   return offset_bits;
}

const char *
brw_instruction_name(enum opcode op)
{
   char *fallback;

   if (op < ARRAY_SIZE(opcode_descs) && opcode_descs[op].name)
      return opcode_descs[op].name;

   switch (op) {
   case FS_OPCODE_FB_WRITE:
      return "fb_write";
   case FS_OPCODE_BLORP_FB_WRITE:
      return "blorp_fb_write";

   case SHADER_OPCODE_RCP:
      return "rcp";
   case SHADER_OPCODE_RSQ:
      return "rsq";
   case SHADER_OPCODE_SQRT:
      return "sqrt";
   case SHADER_OPCODE_EXP2:
      return "exp2";
   case SHADER_OPCODE_LOG2:
      return "log2";
   case SHADER_OPCODE_POW:
      return "pow";
   case SHADER_OPCODE_INT_QUOTIENT:
      return "int_quot";
   case SHADER_OPCODE_INT_REMAINDER:
      return "int_rem";
   case SHADER_OPCODE_SIN:
      return "sin";
   case SHADER_OPCODE_COS:
      return "cos";

   case SHADER_OPCODE_TEX:
      return "tex";
   case SHADER_OPCODE_TXD:
      return "txd";
   case SHADER_OPCODE_TXF:
      return "txf";
   case SHADER_OPCODE_TXL:
      return "txl";
   case SHADER_OPCODE_TXS:
      return "txs";
   case FS_OPCODE_TXB:
      return "txb";
   case SHADER_OPCODE_TXF_CMS:
      return "txf_cms";
   case SHADER_OPCODE_TXF_UMS:
      return "txf_ums";
   case SHADER_OPCODE_TXF_MCS:
      return "txf_mcs";
   case SHADER_OPCODE_TG4:
      return "tg4";
   case SHADER_OPCODE_TG4_OFFSET:
      return "tg4_offset";

   case SHADER_OPCODE_GEN4_SCRATCH_READ:
      return "gen4_scratch_read";
   case SHADER_OPCODE_GEN4_SCRATCH_WRITE:
      return "gen4_scratch_write";
   case SHADER_OPCODE_GEN7_SCRATCH_READ:
      return "gen7_scratch_read";

   case FS_OPCODE_DDX:
      return "ddx";
   case FS_OPCODE_DDY:
      return "ddy";

   case FS_OPCODE_PIXEL_X:
      return "pixel_x";
   case FS_OPCODE_PIXEL_Y:
      return "pixel_y";

   case FS_OPCODE_CINTERP:
      return "cinterp";
   case FS_OPCODE_LINTERP:
      return "linterp";

   case FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD:
      return "uniform_pull_const";
   case FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD_GEN7:
      return "uniform_pull_const_gen7";
   case FS_OPCODE_VARYING_PULL_CONSTANT_LOAD:
      return "varying_pull_const";
   case FS_OPCODE_VARYING_PULL_CONSTANT_LOAD_GEN7:
      return "varying_pull_const_gen7";

   case FS_OPCODE_MOV_DISPATCH_TO_FLAGS:
      return "mov_dispatch_to_flags";
   case FS_OPCODE_DISCARD_JUMP:
      return "discard_jump";

   case FS_OPCODE_SET_SIMD4X2_OFFSET:
      return "set_simd4x2_offset";

   case FS_OPCODE_PACK_HALF_2x16_SPLIT:
      return "pack_half_2x16_split";
   case FS_OPCODE_UNPACK_HALF_2x16_SPLIT_X:
      return "unpack_half_2x16_split_x";
   case FS_OPCODE_UNPACK_HALF_2x16_SPLIT_Y:
      return "unpack_half_2x16_split_y";

   case FS_OPCODE_PLACEHOLDER_HALT:
      return "placeholder_halt";

   case VS_OPCODE_URB_WRITE:
      return "vs_urb_write";
   case VS_OPCODE_PULL_CONSTANT_LOAD:
      return "pull_constant_load";
   case VS_OPCODE_PULL_CONSTANT_LOAD_GEN7:
      return "pull_constant_load_gen7";
   case VS_OPCODE_UNPACK_FLAGS_SIMD4X2:
      return "unpack_flags_simd4x2";

   case GS_OPCODE_URB_WRITE:
      return "gs_urb_write";
   case GS_OPCODE_THREAD_END:
      return "gs_thread_end";
   case GS_OPCODE_SET_WRITE_OFFSET:
      return "set_write_offset";
   case GS_OPCODE_SET_VERTEX_COUNT:
      return "set_vertex_count";
   case GS_OPCODE_SET_DWORD_2_IMMED:
      return "set_dword_2_immed";
   case GS_OPCODE_PREPARE_CHANNEL_MASKS:
      return "prepare_channel_masks";
   case GS_OPCODE_SET_CHANNEL_MASKS:
      return "set_channel_masks";
   case GS_OPCODE_GET_INSTANCE_ID:
      return "get_instance_id";

   default:
      /* Yes, this leaks.  It's in debug code, it should never occur, and if
       * it does, you should just add the case to the list above.
       */
      asprintf(&fallback, "op%d", op);
      return fallback;
   }
}

backend_visitor::backend_visitor(struct brw_context *brw,
                                 struct gl_shader_program *shader_prog,
                                 struct gl_program *prog,
                                 struct brw_stage_prog_data *stage_prog_data,
                                 gl_shader_stage stage)
   : brw(brw),
     ctx(&brw->ctx),
     shader(shader_prog ?
        (struct brw_shader *)shader_prog->_LinkedShaders[stage] : NULL),
     shader_prog(shader_prog),
     prog(prog),
     stage_prog_data(stage_prog_data)
{
}

bool
backend_instruction::is_tex() const
{
   return (opcode == SHADER_OPCODE_TEX ||
           opcode == FS_OPCODE_TXB ||
           opcode == SHADER_OPCODE_TXD ||
           opcode == SHADER_OPCODE_TXF ||
           opcode == SHADER_OPCODE_TXF_CMS ||
           opcode == SHADER_OPCODE_TXF_UMS ||
           opcode == SHADER_OPCODE_TXF_MCS ||
           opcode == SHADER_OPCODE_TXL ||
           opcode == SHADER_OPCODE_TXS ||
           opcode == SHADER_OPCODE_LOD ||
           opcode == SHADER_OPCODE_TG4 ||
           opcode == SHADER_OPCODE_TG4_OFFSET);
}

bool
backend_instruction::is_math() const
{
   return (opcode == SHADER_OPCODE_RCP ||
           opcode == SHADER_OPCODE_RSQ ||
           opcode == SHADER_OPCODE_SQRT ||
           opcode == SHADER_OPCODE_EXP2 ||
           opcode == SHADER_OPCODE_LOG2 ||
           opcode == SHADER_OPCODE_SIN ||
           opcode == SHADER_OPCODE_COS ||
           opcode == SHADER_OPCODE_INT_QUOTIENT ||
           opcode == SHADER_OPCODE_INT_REMAINDER ||
           opcode == SHADER_OPCODE_POW);
}

bool
backend_instruction::is_control_flow() const
{
   switch (opcode) {
   case BRW_OPCODE_DO:
   case BRW_OPCODE_WHILE:
   case BRW_OPCODE_IF:
   case BRW_OPCODE_ELSE:
   case BRW_OPCODE_ENDIF:
   case BRW_OPCODE_BREAK:
   case BRW_OPCODE_CONTINUE:
      return true;
   default:
      return false;
   }
}

bool
backend_instruction::can_do_source_mods() const
{
   switch (opcode) {
   case BRW_OPCODE_ADDC:
   case BRW_OPCODE_BFE:
   case BRW_OPCODE_BFI1:
   case BRW_OPCODE_BFI2:
   case BRW_OPCODE_BFREV:
   case BRW_OPCODE_CBIT:
   case BRW_OPCODE_FBH:
   case BRW_OPCODE_FBL:
   case BRW_OPCODE_SUBB:
      return false;
   default:
      return true;
   }
}

bool
backend_instruction::can_do_saturate() const
{
   switch (opcode) {
   case BRW_OPCODE_ADD:
   case BRW_OPCODE_ASR:
   case BRW_OPCODE_AVG:
   case BRW_OPCODE_DP2:
   case BRW_OPCODE_DP3:
   case BRW_OPCODE_DP4:
   case BRW_OPCODE_DPH:
   case BRW_OPCODE_F16TO32:
   case BRW_OPCODE_F32TO16:
   case BRW_OPCODE_LINE:
   case BRW_OPCODE_LRP:
   case BRW_OPCODE_MAC:
   case BRW_OPCODE_MACH:
   case BRW_OPCODE_MAD:
   case BRW_OPCODE_MATH:
   case BRW_OPCODE_MOV:
   case BRW_OPCODE_MUL:
   case BRW_OPCODE_PLN:
   case BRW_OPCODE_RNDD:
   case BRW_OPCODE_RNDE:
   case BRW_OPCODE_RNDU:
   case BRW_OPCODE_RNDZ:
   case BRW_OPCODE_SEL:
   case BRW_OPCODE_SHL:
   case BRW_OPCODE_SHR:
   case FS_OPCODE_LINTERP:
   case SHADER_OPCODE_COS:
   case SHADER_OPCODE_EXP2:
   case SHADER_OPCODE_LOG2:
   case SHADER_OPCODE_POW:
   case SHADER_OPCODE_RCP:
   case SHADER_OPCODE_RSQ:
   case SHADER_OPCODE_SIN:
   case SHADER_OPCODE_SQRT:
      return true;
   default:
      return false;
   }
}

bool
backend_instruction::reads_accumulator_implicitly() const
{
   switch (opcode) {
   case BRW_OPCODE_MAC:
   case BRW_OPCODE_MACH:
   case BRW_OPCODE_SADA2:
      return true;
   default:
      return false;
   }
}

bool
backend_instruction::has_side_effects() const
{
   switch (opcode) {
   case SHADER_OPCODE_UNTYPED_ATOMIC:
      return true;
   default:
      return false;
   }
}

void
backend_visitor::dump_instructions()
{
   int ip = 0;
   foreach_list(node, &this->instructions) {
      backend_instruction *inst = (backend_instruction *)node;
      fprintf(stderr, "%d: ", ip++);
      dump_instruction(inst);
   }
}


/**
 * Sets up the starting offsets for the groups of binding table entries
 * commong to all pipeline stages.
 *
 * Unused groups are initialized to 0xd0d0d0d0 to make it obvious that they're
 * unused but also make sure that addition of small offsets to them will
 * trigger some of our asserts that surface indices are < BRW_MAX_SURFACES.
 */
void
backend_visitor::assign_common_binding_table_offsets(uint32_t next_binding_table_offset)
{
   int num_textures = _mesa_fls(prog->SamplersUsed);

   stage_prog_data->binding_table.texture_start = next_binding_table_offset;
   next_binding_table_offset += num_textures;

   if (shader) {
      stage_prog_data->binding_table.ubo_start = next_binding_table_offset;
      next_binding_table_offset += shader->base.NumUniformBlocks;
   } else {
      stage_prog_data->binding_table.ubo_start = 0xd0d0d0d0;
   }

   if (INTEL_DEBUG & DEBUG_SHADER_TIME) {
      stage_prog_data->binding_table.shader_time_start = next_binding_table_offset;
      next_binding_table_offset++;
   } else {
      stage_prog_data->binding_table.shader_time_start = 0xd0d0d0d0;
   }

   if (prog->UsesGather) {
      if (brw->gen >= 8) {
         stage_prog_data->binding_table.gather_texture_start =
            stage_prog_data->binding_table.texture_start;
      } else {
         stage_prog_data->binding_table.gather_texture_start = next_binding_table_offset;
         next_binding_table_offset += num_textures;
      }
   } else {
      stage_prog_data->binding_table.gather_texture_start = 0xd0d0d0d0;
   }

   if (shader_prog && shader_prog->NumAtomicBuffers) {
      stage_prog_data->binding_table.abo_start = next_binding_table_offset;
      next_binding_table_offset += shader_prog->NumAtomicBuffers;
   } else {
      stage_prog_data->binding_table.abo_start = 0xd0d0d0d0;
   }

   /* This may or may not be used depending on how the compile goes. */
   stage_prog_data->binding_table.pull_constants_start = next_binding_table_offset;
   next_binding_table_offset++;

   assert(next_binding_table_offset <= BRW_MAX_SURFACES);

   /* prog_data->base.binding_table.size will be set by brw_mark_surface_used. */
}
@


1.5
log
@Merge Mesa 10.2.9
@
text
@@


1.4
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d29 1
a29 1
#include "brw_gs.h"
a30 1
#include "brw_cfg.h"
d51 11
d124 1
a124 1
         &ctx->Const.ShaderCompilerOptions[stage];
d215 2
a216 2
      foreach_in_list(ir_instruction, node, shader->base.ir) {
	 ir_variable *var = node->as_variable();
d222 2
a223 2
	 const ir_state_slot *const slots = var->get_state_slots();
	 assert(slots != NULL);
d225 1
a225 1
	 for (unsigned int i = 0; i < var->get_num_state_slots(); i++) {
d242 6
d281 1
a281 1
enum brw_reg_type
d288 1
a289 1
   case GLSL_TYPE_BOOL:
d307 2
a308 1
      unreachable("not reached");
d314 1
a314 1
enum brw_conditional_mod
d333 2
a334 1
      unreachable("not reached: bad operation for comparison");
d363 2
a364 1
      unreachable("not reached: unknown math function");
d369 1
a369 2
brw_texture_offset(struct gl_context *ctx, int *offsets,
                   unsigned num_components)
d374 3
a376 1
   assert(offsets != NULL || ctx->Extensions.ARB_gpu_shader5);
d378 3
a380 1
   if (!offsets) return 0;  /* nonconstant offset; caller will handle it. */
d389 1
a389 1
   for (unsigned i = 0; i < num_components; i++) {
a452 5
   case SHADER_OPCODE_SHADER_TIME_ADD:
      return "shader_time_add";

   case SHADER_OPCODE_LOAD_PAYLOAD:
      return "load_payload";
a513 2
   case GS_OPCODE_URB_WRITE_ALLOCATE:
      return "gs_urb_write_allocate";
d520 2
a521 2
   case GS_OPCODE_SET_DWORD_2:
      return "set_dword_2";
a527 10
   case GS_OPCODE_FF_SYNC:
      return "ff_sync";
   case GS_OPCODE_SET_PRIMITIVE_ID:
      return "set_primitive_id";
   case GS_OPCODE_SVB_WRITE:
      return "gs_svb_write";
   case GS_OPCODE_SVB_SET_DST_INDEX:
      return "gs_svb_set_dst_index";
   case GS_OPCODE_FF_SYNC_SET_PRIMITIVES:
      return "gs_ff_sync_set_primitives";
d549 1
a549 37
     stage_prog_data(stage_prog_data),
     cfg(NULL),
     stage(stage)
{
}

bool
backend_reg::is_zero() const
{
   if (file != IMM)
      return false;

   return fixed_hw_reg.dw1.d == 0;
}

bool
backend_reg::is_one() const
{
   if (file != IMM)
      return false;

   return type == BRW_REGISTER_TYPE_F
          ? fixed_hw_reg.dw1.f == 1.0
          : fixed_hw_reg.dw1.d == 1;
}

bool
backend_reg::is_null() const
{
   return file == HW_REG &&
          fixed_hw_reg.file == BRW_ARCHITECTURE_REGISTER_FILE &&
          fixed_hw_reg.nr == BRW_ARF_NULL;
}


bool
backend_reg::is_accumulator() const
a550 3
   return file == HW_REG &&
          fixed_hw_reg.file == BRW_ARCHITECTURE_REGISTER_FILE &&
          fixed_hw_reg.nr == BRW_ARF_ACCUMULATOR;
a678 10
backend_instruction::writes_accumulator_implicitly(struct brw_context *brw) const
{
   return writes_accumulator ||
          (brw->gen < 6 &&
           ((opcode >= BRW_OPCODE_ADD && opcode < BRW_OPCODE_NOP) ||
            (opcode >= FS_OPCODE_DDX && opcode <= FS_OPCODE_LINTERP &&
             opcode != FS_OPCODE_CINTERP)));
}

bool
a682 1
   case FS_OPCODE_FB_WRITE:
a688 79
#ifndef NDEBUG
static bool
inst_is_in_block(const bblock_t *block, const backend_instruction *inst)
{
   bool found = false;
   foreach_inst_in_block (backend_instruction, i, block) {
      if (inst == i) {
         found = true;
      }
   }
   return found;
}
#endif

static void
adjust_later_block_ips(bblock_t *start_block, int ip_adjustment)
{
   for (bblock_t *block_iter = start_block->next();
        !block_iter->link.is_tail_sentinel();
        block_iter = block_iter->next()) {
      block_iter->start_ip += ip_adjustment;
      block_iter->end_ip += ip_adjustment;
   }
}

void
backend_instruction::insert_after(bblock_t *block, backend_instruction *inst)
{
   assert(inst_is_in_block(block, this) || !"Instruction not in block");

   block->end_ip++;

   adjust_later_block_ips(block, 1);

   exec_node::insert_after(inst);
}

void
backend_instruction::insert_before(bblock_t *block, backend_instruction *inst)
{
   assert(inst_is_in_block(block, this) || !"Instruction not in block");

   block->end_ip++;

   adjust_later_block_ips(block, 1);

   exec_node::insert_before(inst);
}

void
backend_instruction::insert_before(bblock_t *block, exec_list *list)
{
   assert(inst_is_in_block(block, this) || !"Instruction not in block");

   unsigned num_inst = list->length();

   block->end_ip += num_inst;

   adjust_later_block_ips(block, num_inst);

   exec_node::insert_before(list);
}

void
backend_instruction::remove(bblock_t *block)
{
   assert(inst_is_in_block(block, this) || !"Instruction not in block");

   adjust_later_block_ips(block, -1);

   if (block->start_ip == block->end_ip) {
      block->cfg->remove_block(block);
   } else {
      block->end_ip--;
   }

   exec_node::remove();
}

a691 13
   dump_instructions(NULL);
}

void
backend_visitor::dump_instructions(const char *name)
{
   FILE *file = stderr;
   if (name && geteuid() != 0) {
      file = fopen(name, "w");
      if (!file)
         file = stderr;
   }

d693 4
a696 8
   foreach_block_and_inst(block, backend_instruction, inst, cfg) {
      if (!name)
         fprintf(stderr, "%d: ", ip++);
      dump_instruction(inst, file);
   }

   if (file != stderr) {
      fclose(file);
a699 14
void
backend_visitor::calculate_cfg()
{
   if (this->cfg)
      return;
   cfg = new(mem_ctx) cfg_t(&this->instructions);
}

void
backend_visitor::invalidate_cfg()
{
   ralloc_free(this->cfg);
   this->cfg = NULL;
}
@


1.3
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d29 1
a29 1
#include "brw_vec4_gs.h"
d31 1
a51 11
struct gl_shader_program *
brw_new_shader_program(struct gl_context *ctx, GLuint name)
{
   struct gl_shader_program *prog = rzalloc(NULL, struct gl_shader_program);
   if (prog) {
      prog->Name = name;
      _mesa_init_shader_program(ctx, prog);
   }
   return prog;
}

d114 1
a114 1
         &ctx->ShaderCompilerOptions[stage];
d205 2
a206 2
      foreach_list(node, shader->base.ir) {
	 ir_variable *var = ((ir_instruction *) node)->as_variable();
d212 2
a213 2
	 const ir_state_slot *const slots = var->state_slots;
	 assert(var->state_slots != NULL);
d215 1
a215 1
	 for (unsigned int i = 0; i < var->num_state_slots; i++) {
a231 6
      /* This has to be done last.  Any operation that can cause
       * prog->ParameterValues to get reallocated (e.g., anything that adds a
       * program constant) has to happen before creating this linkage.
       */
      _mesa_associate_uniform_storage(ctx, shProg, prog->Parameters);

d265 1
a265 1
int
d272 1
a273 1
      return BRW_REGISTER_TYPE_D;
d291 1
a291 2
      assert(!"not reached");
      break;
d297 1
a297 1
uint32_t
d316 1
a316 2
      assert(!"not reached: bad operation for comparison");
      return BRW_CONDITIONAL_NZ;
d345 1
a345 2
      assert(!"not reached: unknown math function");
      return 0;
d350 2
a351 1
brw_texture_offset(struct gl_context *ctx, ir_constant *offset)
d356 1
a356 3
   assert(offset != NULL || ctx->Extensions.ARB_gpu_shader5);

   if (!offset) return 0;  /* nonconstant offset; caller will handle it. */
d358 1
a358 3
   signed char offsets[3];
   for (unsigned i = 0; i < offset->type->vector_elements; i++)
      offsets[i] = (signed char) offset->value.i[i];
d367 1
a367 1
   for (unsigned i = 0; i < offset->type->vector_elements; i++) {
d431 5
d497 2
d505 2
a506 2
   case GS_OPCODE_SET_DWORD_2_IMMED:
      return "set_dword_2_immed";
d513 10
d544 37
a580 1
     stage_prog_data(stage_prog_data)
d582 3
d713 10
d727 1
d734 79
d816 13
d830 8
a837 4
   foreach_list(node, &this->instructions) {
      backend_instruction *inst = (backend_instruction *)node;
      fprintf(stderr, "%d: ", ip++);
      dump_instruction(inst);
d841 14
@


1.2
log
@Merge Mesa 9.2.0
@
text
@d27 1
d29 1
a29 1
}
d33 1
d43 1
d75 3
d86 1
a86 1
                           gl_shader_type shader_type,
d123 2
d132 1
a132 1
	 ctx->Driver.NewProgram(ctx, _mesa_program_index_to_target(stage),
d138 1
a138 4
      if (stage == 0) {
	 struct gl_vertex_program *vp = (struct gl_vertex_program *) prog;
	 vp->UsesClipDistance = shProg->Vert.UsesClipDistance;
      }
a139 1
      void *mem_ctx = ralloc_context(NULL);
a141 5
      if (shader->ir)
	 ralloc_free(shader->ir);
      shader->ir = new(shader) exec_list;
      clone_ir_list(mem_ctx, shader->ir, shader->base.ir);

d145 2
a146 2
      brw_lower_packing_builtins(brw, (gl_shader_type) stage, shader->ir);
      do_mat_op_to_vec(shader->ir);
d150 1
a150 2
      const int lrp_to_arith = brw->gen < 6 ? LRP_TO_ARITH : 0;
      lower_instructions(shader->ir,
d157 1
a157 1
                         lrp_to_arith);
d163 1
a163 1
	 lower_if_to_cond_assign(shader->ir, 16);
d165 9
a173 12
      do_lower_texture_projection(shader->ir);
      brw_lower_texture_gradients(brw, shader->ir);
      do_vec_index_to_cond_assign(shader->ir);
      lower_vector_insert(shader->ir, true);
      brw_do_cubemap_normalize(shader->ir);
      lower_noise(shader->ir);
      lower_quadop_vector(shader->ir, false);

      bool input = true;
      bool output = stage == MESA_SHADER_FRAGMENT;
      bool temp = stage == MESA_SHADER_FRAGMENT;
      bool uniform = false;
d176 5
a180 2
         lower_variable_index_to_cond_assign(shader->ir,
                                             input, output, temp, uniform);
d187 1
a187 2
      /* FINISHME: Do this before the variable index lowering. */
      lower_ubo_reference(&shader->base, shader->ir);
d193 2
a194 2
	    brw_do_channel_expressions(shader->ir);
	    brw_do_vector_splitting(shader->ir);
d197 1
a197 1
	 progress = do_lower_jumps(shader->ir, true, true,
d203 2
a204 2
	 progress = do_common_optimization(shader->ir, true, true, 32,
                                           &ctx->ShaderCompilerOptions[stage])
d215 1
a215 1
      foreach_list(node, shader->ir) {
d218 1
a218 1
	 if ((var == NULL) || (var->mode != ir_var_uniform)
d231 1
a231 1
      validate_ir_tree(shader->ir);
d233 1
a233 5
      reparent_ir(shader->ir, shader->ir);
      ralloc_free(mem_ctx);

      do_set_program_inouts(shader->ir, prog,
			    shader->base.Type == GL_FRAGMENT_SHADER);
d250 7
a256 6
      if (ctx->Shader.Flags & GLSL_DUMP) {
         printf("\n");
         printf("GLSL IR for linked %s program %d:\n",
                _mesa_glsl_shader_target_name(shader->base.Type), shProg->Name);
         _mesa_print_ir(shader->base.ir, NULL);
         printf("\n");
d260 1
a260 1
   if (ctx->Shader.Flags & GLSL_DUMP) {
d266 5
a270 6
         printf("GLSL %s shader %d source for linked program %d:\n",
                _mesa_glsl_shader_target_name(sh->Type),
                i,
                shProg->Name);
         printf("%s", sh->Source);
         printf("\n");
d296 1
d302 2
d369 1
a369 1
brw_texture_offset(ir_constant *offset)
d371 6
a376 1
   assert(offset != NULL);
d407 2
d443 17
a459 2
   case SHADER_OPCODE_TXF_MS:
      return "txf_ms";
a475 5
   case FS_OPCODE_SPILL:
      return "spill";
   case FS_OPCODE_UNSPILL:
      return "unspill";

d504 1
a504 5
      return "urb_write";
   case VS_OPCODE_SCRATCH_READ:
      return "scratch_read";
   case VS_OPCODE_SCRATCH_WRITE:
      return "scratch_write";
d509 19
d538 15
d554 1
a554 1
backend_instruction::is_tex()
d560 3
a562 1
           opcode == SHADER_OPCODE_TXF_MS ||
d565 3
a567 1
           opcode == SHADER_OPCODE_LOD);
d571 1
a571 1
backend_instruction::is_math()
d586 1
a586 1
backend_instruction::is_control_flow()
d602 87
d695 1
a695 1
      printf("%d: ", ip++);
d698 59
@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d27 1
d30 2
a31 2
#include "../glsl/ir_optimization.h"
#include "../glsl/ir_print_visitor.h"
d51 1
a51 2
   struct brw_shader_program *prog;
   prog = rzalloc(NULL, struct brw_shader_program);
d53 2
a54 2
      prog->base.Name = name;
      _mesa_init_shader_program(ctx, &prog->base);
d56 1
a56 1
   return &prog->base;
d64 1
a64 1
bool
d67 6
a72 1
   if (!brw_fs_precompile(ctx, prog))
d78 32
d111 1
a111 1
brw_link_shader(struct gl_context *ctx, struct gl_shader_program *prog)
d114 20
a133 1
   struct intel_context *intel = &brw->intel;
a134 3
   struct brw_shader *shader =
      (struct brw_shader *)prog->_LinkedShaders[MESA_SHADER_FRAGMENT];
   if (shader != NULL) {
d143 4
d148 4
d157 3
a159 1
			 LOG_TO_LOG2);
d164 1
a164 1
      if (intel->gen < 6)
d168 1
d170 1
d174 17
a190 6
      lower_variable_index_to_cond_assign(shader->ir,
					  GL_TRUE, /* input */
					  GL_TRUE, /* output */
					  GL_TRUE, /* temp */
					  GL_TRUE /* uniform */
					  );
d195 4
a198 2
	 brw_do_channel_expressions(shader->ir);
	 brw_do_vector_splitting(shader->ir);
d206 3
a208 1
	 progress = do_common_optimization(shader->ir, true, 32) || progress;
d211 23
d238 26
d266 14
a279 2
   if (!_mesa_ir_link_shader(ctx, prog))
      return GL_FALSE;
d281 2
a282 2
   if (!brw_shader_precompile(ctx, prog))
      return GL_FALSE;
d284 1
a284 1
   return GL_TRUE;
d300 1
d308 3
a310 1
   default:
d312 1
a312 1
      return BRW_REGISTER_TYPE_F;
d314 2
d339 224
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@a26 1
#include "brw_vs.h"
d29 2
a30 2
#include "glsl/ir_optimization.h"
#include "glsl/glsl_parser_extras.h"
d50 2
a51 1
   struct gl_shader_program *prog = rzalloc(NULL, struct gl_shader_program);
d53 2
a54 2
      prog->Name = name;
      _mesa_init_shader_program(ctx, prog);
d56 1
a56 1
   return prog;
d64 1
a64 1
static bool
d67 1
a67 6
   struct brw_context *brw = brw_context(ctx);

   if (brw->precompile && !brw_fs_precompile(ctx, prog))
      return false;

   if (brw->precompile && !brw_vs_precompile(ctx, prog))
a72 32
static void
brw_lower_packing_builtins(struct brw_context *brw,
                           gl_shader_type shader_type,
                           exec_list *ir)
{
   int ops = LOWER_PACK_SNORM_2x16
           | LOWER_UNPACK_SNORM_2x16
           | LOWER_PACK_UNORM_2x16
           | LOWER_UNPACK_UNORM_2x16
           | LOWER_PACK_SNORM_4x8
           | LOWER_UNPACK_SNORM_4x8
           | LOWER_PACK_UNORM_4x8
           | LOWER_UNPACK_UNORM_4x8;

   if (brw->gen >= 7) {
      /* Gen7 introduced the f32to16 and f16to32 instructions, which can be
       * used to execute packHalf2x16 and unpackHalf2x16. For AOS code, no
       * lowering is needed. For SOA code, the Half2x16 ops must be
       * scalarized.
       */
      if (shader_type == MESA_SHADER_FRAGMENT) {
         ops |= LOWER_PACK_HALF_2x16_TO_SPLIT
             |  LOWER_UNPACK_HALF_2x16_TO_SPLIT;
      }
   } else {
      ops |= LOWER_PACK_HALF_2x16
          |  LOWER_UNPACK_HALF_2x16;
   }

   lower_packing_builtins(ir, ops);
}

d74 1
a74 1
brw_link_shader(struct gl_context *ctx, struct gl_shader_program *shProg)
d77 1
a77 20
   unsigned int stage;

   for (stage = 0; stage < ARRAY_SIZE(shProg->_LinkedShaders); stage++) {
      struct brw_shader *shader =
	 (struct brw_shader *)shProg->_LinkedShaders[stage];

      if (!shader)
	 continue;

      struct gl_program *prog =
	 ctx->Driver.NewProgram(ctx, _mesa_program_index_to_target(stage),
                                shader->base.Name);
      if (!prog)
	return false;
      prog->Parameters = _mesa_new_parameter_list();

      if (stage == 0) {
	 struct gl_vertex_program *vp = (struct gl_vertex_program *) prog;
	 vp->UsesClipDistance = shProg->Vert.UsesClipDistance;
      }
d79 3
a89 4
      /* lower_packing_builtins() inserts arithmetic instructions, so it
       * must precede lower_instructions().
       */
      brw_lower_packing_builtins(brw, (gl_shader_type) stage, shader->ir);
a90 4
      const int bitfield_insert = brw->gen >= 7
                                  ? BITFIELD_INSERT_TO_BFM_BFI
                                  : 0;
      const int lrp_to_arith = brw->gen < 6 ? LRP_TO_ARITH : 0;
d96 1
a96 3
			 LOG_TO_LOG2 |
                         bitfield_insert |
                         lrp_to_arith);
d101 1
a101 1
      if (brw->gen < 6)
a104 1
      brw_lower_texture_gradients(brw, shader->ir);
a105 1
      lower_vector_insert(shader->ir, true);
d109 6
a114 17

      bool input = true;
      bool output = stage == MESA_SHADER_FRAGMENT;
      bool temp = stage == MESA_SHADER_FRAGMENT;
      bool uniform = false;

      bool lowered_variable_indexing =
         lower_variable_index_to_cond_assign(shader->ir,
                                             input, output, temp, uniform);

      if (unlikely(brw->perf_debug && lowered_variable_indexing)) {
         perf_debug("Unsupported form of variable indexing in FS; falling "
                    "back to very inefficient code generation\n");
      }

      /* FINISHME: Do this before the variable index lowering. */
      lower_ubo_reference(&shader->base, shader->ir);
d119 2
a120 4
	 if (stage == MESA_SHADER_FRAGMENT) {
	    brw_do_channel_expressions(shader->ir);
	    brw_do_vector_splitting(shader->ir);
	 }
d128 1
a128 3
	 progress = do_common_optimization(shader->ir, true, true, 32,
                                           &ctx->ShaderCompilerOptions[stage])
	   || progress;
a130 23
      /* Make a pass over the IR to add state references for any built-in
       * uniforms that are used.  This has to be done now (during linking).
       * Code generation doesn't happen until the first time this shader is
       * used for rendering.  Waiting until then to generate the parameters is
       * too late.  At that point, the values for the built-in uniforms won't
       * get sent to the shader.
       */
      foreach_list(node, shader->ir) {
	 ir_variable *var = ((ir_instruction *) node)->as_variable();

	 if ((var == NULL) || (var->mode != ir_var_uniform)
	     || (strncmp(var->name, "gl_", 3) != 0))
	    continue;

	 const ir_state_slot *const slots = var->state_slots;
	 assert(var->state_slots != NULL);

	 for (unsigned int i = 0; i < var->num_state_slots; i++) {
	    _mesa_add_state_reference(prog->Parameters,
				      (gl_state_index *) slots[i].tokens);
	 }
      }

a134 26

      do_set_program_inouts(shader->ir, prog,
			    shader->base.Type == GL_FRAGMENT_SHADER);

      prog->SamplersUsed = shader->base.active_samplers;
      _mesa_update_shader_textures_used(shProg, prog);

      _mesa_reference_program(ctx, &shader->base.Program, prog);

      brw_add_texrect_params(prog);

      /* This has to be done last.  Any operation that can cause
       * prog->ParameterValues to get reallocated (e.g., anything that adds a
       * program constant) has to happen before creating this linkage.
       */
      _mesa_associate_uniform_storage(ctx, shProg, prog->Parameters);

      _mesa_reference_program(ctx, &prog, NULL);

      if (ctx->Shader.Flags & GLSL_DUMP) {
         printf("\n");
         printf("GLSL IR for linked %s program %d:\n",
                _mesa_glsl_shader_target_name(shader->base.Type), shProg->Name);
         _mesa_print_ir(shader->base.ir, NULL);
         printf("\n");
      }
d137 2
a138 14
   if (ctx->Shader.Flags & GLSL_DUMP) {
      for (unsigned i = 0; i < shProg->NumShaders; i++) {
         const struct gl_shader *sh = shProg->Shaders[i];
         if (!sh)
            continue;

         printf("GLSL %s shader %d source for linked program %d:\n",
                _mesa_glsl_shader_target_name(sh->Type),
                i,
                shProg->Name);
         printf("%s", sh->Source);
         printf("\n");
      }
   }
d140 2
a141 2
   if (!brw_shader_precompile(ctx, shProg))
      return false;
d143 1
a143 1
   return true;
a158 1
      return brw_type_for_base_type(type->fields.array);
d166 1
a166 3
   case GLSL_TYPE_VOID:
   case GLSL_TYPE_ERROR:
   case GLSL_TYPE_INTERFACE:
d168 1
a168 1
      break;
a169 2

   return BRW_REGISTER_TYPE_F;
a192 224
   }
}

uint32_t
brw_math_function(enum opcode op)
{
   switch (op) {
   case SHADER_OPCODE_RCP:
      return BRW_MATH_FUNCTION_INV;
   case SHADER_OPCODE_RSQ:
      return BRW_MATH_FUNCTION_RSQ;
   case SHADER_OPCODE_SQRT:
      return BRW_MATH_FUNCTION_SQRT;
   case SHADER_OPCODE_EXP2:
      return BRW_MATH_FUNCTION_EXP;
   case SHADER_OPCODE_LOG2:
      return BRW_MATH_FUNCTION_LOG;
   case SHADER_OPCODE_POW:
      return BRW_MATH_FUNCTION_POW;
   case SHADER_OPCODE_SIN:
      return BRW_MATH_FUNCTION_SIN;
   case SHADER_OPCODE_COS:
      return BRW_MATH_FUNCTION_COS;
   case SHADER_OPCODE_INT_QUOTIENT:
      return BRW_MATH_FUNCTION_INT_DIV_QUOTIENT;
   case SHADER_OPCODE_INT_REMAINDER:
      return BRW_MATH_FUNCTION_INT_DIV_REMAINDER;
   default:
      assert(!"not reached: unknown math function");
      return 0;
   }
}

uint32_t
brw_texture_offset(ir_constant *offset)
{
   assert(offset != NULL);

   signed char offsets[3];
   for (unsigned i = 0; i < offset->type->vector_elements; i++)
      offsets[i] = (signed char) offset->value.i[i];

   /* Combine all three offsets into a single unsigned dword:
    *
    *    bits 11:8 - U Offset (X component)
    *    bits  7:4 - V Offset (Y component)
    *    bits  3:0 - R Offset (Z component)
    */
   unsigned offset_bits = 0;
   for (unsigned i = 0; i < offset->type->vector_elements; i++) {
      const unsigned shift = 4 * (2 - i);
      offset_bits |= (offsets[i] << shift) & (0xF << shift);
   }
   return offset_bits;
}

const char *
brw_instruction_name(enum opcode op)
{
   char *fallback;

   if (op < ARRAY_SIZE(opcode_descs) && opcode_descs[op].name)
      return opcode_descs[op].name;

   switch (op) {
   case FS_OPCODE_FB_WRITE:
      return "fb_write";

   case SHADER_OPCODE_RCP:
      return "rcp";
   case SHADER_OPCODE_RSQ:
      return "rsq";
   case SHADER_OPCODE_SQRT:
      return "sqrt";
   case SHADER_OPCODE_EXP2:
      return "exp2";
   case SHADER_OPCODE_LOG2:
      return "log2";
   case SHADER_OPCODE_POW:
      return "pow";
   case SHADER_OPCODE_INT_QUOTIENT:
      return "int_quot";
   case SHADER_OPCODE_INT_REMAINDER:
      return "int_rem";
   case SHADER_OPCODE_SIN:
      return "sin";
   case SHADER_OPCODE_COS:
      return "cos";

   case SHADER_OPCODE_TEX:
      return "tex";
   case SHADER_OPCODE_TXD:
      return "txd";
   case SHADER_OPCODE_TXF:
      return "txf";
   case SHADER_OPCODE_TXL:
      return "txl";
   case SHADER_OPCODE_TXS:
      return "txs";
   case FS_OPCODE_TXB:
      return "txb";
   case SHADER_OPCODE_TXF_MS:
      return "txf_ms";

   case FS_OPCODE_DDX:
      return "ddx";
   case FS_OPCODE_DDY:
      return "ddy";

   case FS_OPCODE_PIXEL_X:
      return "pixel_x";
   case FS_OPCODE_PIXEL_Y:
      return "pixel_y";

   case FS_OPCODE_CINTERP:
      return "cinterp";
   case FS_OPCODE_LINTERP:
      return "linterp";

   case FS_OPCODE_SPILL:
      return "spill";
   case FS_OPCODE_UNSPILL:
      return "unspill";

   case FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD:
      return "uniform_pull_const";
   case FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD_GEN7:
      return "uniform_pull_const_gen7";
   case FS_OPCODE_VARYING_PULL_CONSTANT_LOAD:
      return "varying_pull_const";
   case FS_OPCODE_VARYING_PULL_CONSTANT_LOAD_GEN7:
      return "varying_pull_const_gen7";

   case FS_OPCODE_MOV_DISPATCH_TO_FLAGS:
      return "mov_dispatch_to_flags";
   case FS_OPCODE_DISCARD_JUMP:
      return "discard_jump";

   case FS_OPCODE_SET_SIMD4X2_OFFSET:
      return "set_simd4x2_offset";

   case FS_OPCODE_PACK_HALF_2x16_SPLIT:
      return "pack_half_2x16_split";
   case FS_OPCODE_UNPACK_HALF_2x16_SPLIT_X:
      return "unpack_half_2x16_split_x";
   case FS_OPCODE_UNPACK_HALF_2x16_SPLIT_Y:
      return "unpack_half_2x16_split_y";

   case FS_OPCODE_PLACEHOLDER_HALT:
      return "placeholder_halt";

   case VS_OPCODE_URB_WRITE:
      return "urb_write";
   case VS_OPCODE_SCRATCH_READ:
      return "scratch_read";
   case VS_OPCODE_SCRATCH_WRITE:
      return "scratch_write";
   case VS_OPCODE_PULL_CONSTANT_LOAD:
      return "pull_constant_load";
   case VS_OPCODE_PULL_CONSTANT_LOAD_GEN7:
      return "pull_constant_load_gen7";

   default:
      /* Yes, this leaks.  It's in debug code, it should never occur, and if
       * it does, you should just add the case to the list above.
       */
      asprintf(&fallback, "op%d", op);
      return fallback;
   }
}

bool
backend_instruction::is_tex()
{
   return (opcode == SHADER_OPCODE_TEX ||
           opcode == FS_OPCODE_TXB ||
           opcode == SHADER_OPCODE_TXD ||
           opcode == SHADER_OPCODE_TXF ||
           opcode == SHADER_OPCODE_TXF_MS ||
           opcode == SHADER_OPCODE_TXL ||
           opcode == SHADER_OPCODE_TXS ||
           opcode == SHADER_OPCODE_LOD);
}

bool
backend_instruction::is_math()
{
   return (opcode == SHADER_OPCODE_RCP ||
           opcode == SHADER_OPCODE_RSQ ||
           opcode == SHADER_OPCODE_SQRT ||
           opcode == SHADER_OPCODE_EXP2 ||
           opcode == SHADER_OPCODE_LOG2 ||
           opcode == SHADER_OPCODE_SIN ||
           opcode == SHADER_OPCODE_COS ||
           opcode == SHADER_OPCODE_INT_QUOTIENT ||
           opcode == SHADER_OPCODE_INT_REMAINDER ||
           opcode == SHADER_OPCODE_POW);
}

bool
backend_instruction::is_control_flow()
{
   switch (opcode) {
   case BRW_OPCODE_DO:
   case BRW_OPCODE_WHILE:
   case BRW_OPCODE_IF:
   case BRW_OPCODE_ELSE:
   case BRW_OPCODE_ENDIF:
   case BRW_OPCODE_BREAK:
   case BRW_OPCODE_CONTINUE:
      return true;
   default:
      return false;
   }
}

void
backend_visitor::dump_instructions()
{
   int ip = 0;
   foreach_list(node, &this->instructions) {
      backend_instruction *inst = (backend_instruction *)node;
      printf("%d: ", ip++);
      dump_instruction(inst);
@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@d27 1
a28 2
#include "brw_vs.h"
#include "brw_vec4_gs.h"
a31 1
#include "main/shaderapi.h"
a40 1
      shader->base.Stage = _mesa_shader_enum_to_shader_stage(type);
a71 3
   if (brw->precompile && !brw_gs_precompile(ctx, prog))
      return false;

d80 1
a80 1
                           gl_shader_stage shader_type,
a116 2
      const struct gl_shader_compiler_options *options =
         &ctx->ShaderCompilerOptions[stage];
d124 1
a124 1
	 ctx->Driver.NewProgram(ctx, _mesa_shader_stage_to_program(stage),
d130 4
a133 1
      _mesa_copy_linked_program_data((gl_shader_stage) stage, shProg, prog);
d135 1
d138 5
d146 2
a147 2
      brw_lower_packing_builtins(brw, (gl_shader_stage) stage, shader->base.ir);
      do_mat_op_to_vec(shader->base.ir);
d151 2
a152 1
      lower_instructions(shader->base.ir,
d159 1
a159 1
                         LDEXP_TO_ARITH);
d165 1
a165 1
	 lower_if_to_cond_assign(shader->base.ir, 16);
d167 12
a178 9
      do_lower_texture_projection(shader->base.ir);
      brw_lower_texture_gradients(brw, shader->base.ir);
      do_vec_index_to_cond_assign(shader->base.ir);
      lower_vector_insert(shader->base.ir, true);
      brw_do_cubemap_normalize(shader->base.ir);
      lower_offset_arrays(shader->base.ir);
      brw_do_lower_unnormalized_offset(shader->base.ir);
      lower_noise(shader->base.ir);
      lower_quadop_vector(shader->base.ir, false);
d181 2
a182 5
         lower_variable_index_to_cond_assign(shader->base.ir,
                                             options->EmitNoIndirectInput,
                                             options->EmitNoIndirectOutput,
                                             options->EmitNoIndirectTemp,
                                             options->EmitNoIndirectUniform);
d189 2
a190 1
      lower_ubo_reference(&shader->base, shader->base.ir);
d196 2
a197 2
	    brw_do_channel_expressions(shader->base.ir);
	    brw_do_vector_splitting(shader->base.ir);
d200 1
a200 1
	 progress = do_lower_jumps(shader->base.ir, true, true,
d206 2
a207 2
	 progress = do_common_optimization(shader->base.ir, true, true,
                                           options, ctx->Const.NativeIntegers)
d218 1
a218 1
      foreach_list(node, shader->base.ir) {
d221 1
a221 1
	 if ((var == NULL) || (var->data.mode != ir_var_uniform)
d234 1
a234 1
      validate_ir_tree(shader->base.ir);
d236 5
a240 1
      do_set_program_inouts(shader->base.ir, prog, shader->base.Stage);
d257 6
a262 7
      if (ctx->_Shader->Flags & GLSL_DUMP) {
         fprintf(stderr, "\n");
         fprintf(stderr, "GLSL IR for linked %s program %d:\n",
                 _mesa_shader_stage_to_string(shader->base.Stage),
                 shProg->Name);
         _mesa_print_ir(stderr, shader->base.ir, NULL);
         fprintf(stderr, "\n");
d266 1
a266 1
   if ((ctx->_Shader->Flags & GLSL_DUMP) && shProg->Name != 0) {
d272 6
a277 5
         fprintf(stderr, "GLSL %s shader %d source for linked program %d:\n",
                 _mesa_shader_stage_to_string(sh->Stage),
                 i, shProg->Name);
         fprintf(stderr, "%s", sh->Source);
         fprintf(stderr, "\n");
a302 1
   case GLSL_TYPE_ATOMIC_UINT:
a307 2
   case GLSL_TYPE_IMAGE:
      return BRW_REGISTER_TYPE_UD;
d373 1
a373 1
brw_texture_offset(struct gl_context *ctx, ir_constant *offset)
d375 1
a375 6
   /* If the driver does not support GL_ARB_gpu_shader5, the offset
    * must be constant.
    */
   assert(offset != NULL || ctx->Extensions.ARB_gpu_shader5);

   if (!offset) return 0;  /* nonconstant offset; caller will handle it. */
a405 2
   case FS_OPCODE_BLORP_FB_WRITE:
      return "blorp_fb_write";
d440 2
a441 17
   case SHADER_OPCODE_TXF_CMS:
      return "txf_cms";
   case SHADER_OPCODE_TXF_UMS:
      return "txf_ums";
   case SHADER_OPCODE_TXF_MCS:
      return "txf_mcs";
   case SHADER_OPCODE_TG4:
      return "tg4";
   case SHADER_OPCODE_TG4_OFFSET:
      return "tg4_offset";

   case SHADER_OPCODE_GEN4_SCRATCH_READ:
      return "gen4_scratch_read";
   case SHADER_OPCODE_GEN4_SCRATCH_WRITE:
      return "gen4_scratch_write";
   case SHADER_OPCODE_GEN7_SCRATCH_READ:
      return "gen7_scratch_read";
d458 5
d491 5
a495 1
      return "vs_urb_write";
a499 19
   case VS_OPCODE_UNPACK_FLAGS_SIMD4X2:
      return "unpack_flags_simd4x2";

   case GS_OPCODE_URB_WRITE:
      return "gs_urb_write";
   case GS_OPCODE_THREAD_END:
      return "gs_thread_end";
   case GS_OPCODE_SET_WRITE_OFFSET:
      return "set_write_offset";
   case GS_OPCODE_SET_VERTEX_COUNT:
      return "set_vertex_count";
   case GS_OPCODE_SET_DWORD_2_IMMED:
      return "set_dword_2_immed";
   case GS_OPCODE_PREPARE_CHANNEL_MASKS:
      return "prepare_channel_masks";
   case GS_OPCODE_SET_CHANNEL_MASKS:
      return "set_channel_masks";
   case GS_OPCODE_GET_INSTANCE_ID:
      return "get_instance_id";
a509 15
backend_visitor::backend_visitor(struct brw_context *brw,
                                 struct gl_shader_program *shader_prog,
                                 struct gl_program *prog,
                                 struct brw_stage_prog_data *stage_prog_data,
                                 gl_shader_stage stage)
   : brw(brw),
     ctx(&brw->ctx),
     shader(shader_prog ?
        (struct brw_shader *)shader_prog->_LinkedShaders[stage] : NULL),
     shader_prog(shader_prog),
     prog(prog),
     stage_prog_data(stage_prog_data)
{
}

d511 1
a511 1
backend_instruction::is_tex() const
d517 1
a517 3
           opcode == SHADER_OPCODE_TXF_CMS ||
           opcode == SHADER_OPCODE_TXF_UMS ||
           opcode == SHADER_OPCODE_TXF_MCS ||
d520 1
a520 3
           opcode == SHADER_OPCODE_LOD ||
           opcode == SHADER_OPCODE_TG4 ||
           opcode == SHADER_OPCODE_TG4_OFFSET);
d524 1
a524 1
backend_instruction::is_math() const
d539 1
a539 1
backend_instruction::is_control_flow() const
a554 87
bool
backend_instruction::can_do_source_mods() const
{
   switch (opcode) {
   case BRW_OPCODE_ADDC:
   case BRW_OPCODE_BFE:
   case BRW_OPCODE_BFI1:
   case BRW_OPCODE_BFI2:
   case BRW_OPCODE_BFREV:
   case BRW_OPCODE_CBIT:
   case BRW_OPCODE_FBH:
   case BRW_OPCODE_FBL:
   case BRW_OPCODE_SUBB:
      return false;
   default:
      return true;
   }
}

bool
backend_instruction::can_do_saturate() const
{
   switch (opcode) {
   case BRW_OPCODE_ADD:
   case BRW_OPCODE_ASR:
   case BRW_OPCODE_AVG:
   case BRW_OPCODE_DP2:
   case BRW_OPCODE_DP3:
   case BRW_OPCODE_DP4:
   case BRW_OPCODE_DPH:
   case BRW_OPCODE_F16TO32:
   case BRW_OPCODE_F32TO16:
   case BRW_OPCODE_LINE:
   case BRW_OPCODE_LRP:
   case BRW_OPCODE_MAC:
   case BRW_OPCODE_MACH:
   case BRW_OPCODE_MAD:
   case BRW_OPCODE_MATH:
   case BRW_OPCODE_MOV:
   case BRW_OPCODE_MUL:
   case BRW_OPCODE_PLN:
   case BRW_OPCODE_RNDD:
   case BRW_OPCODE_RNDE:
   case BRW_OPCODE_RNDU:
   case BRW_OPCODE_RNDZ:
   case BRW_OPCODE_SEL:
   case BRW_OPCODE_SHL:
   case BRW_OPCODE_SHR:
   case FS_OPCODE_LINTERP:
   case SHADER_OPCODE_COS:
   case SHADER_OPCODE_EXP2:
   case SHADER_OPCODE_LOG2:
   case SHADER_OPCODE_POW:
   case SHADER_OPCODE_RCP:
   case SHADER_OPCODE_RSQ:
   case SHADER_OPCODE_SIN:
   case SHADER_OPCODE_SQRT:
      return true;
   default:
      return false;
   }
}

bool
backend_instruction::reads_accumulator_implicitly() const
{
   switch (opcode) {
   case BRW_OPCODE_MAC:
   case BRW_OPCODE_MACH:
   case BRW_OPCODE_SADA2:
      return true;
   default:
      return false;
   }
}

bool
backend_instruction::has_side_effects() const
{
   switch (opcode) {
   case SHADER_OPCODE_UNTYPED_ATOMIC:
      return true;
   default:
      return false;
   }
}

d561 1
a561 1
      fprintf(stderr, "%d: ", ip++);
a563 59
}


/**
 * Sets up the starting offsets for the groups of binding table entries
 * commong to all pipeline stages.
 *
 * Unused groups are initialized to 0xd0d0d0d0 to make it obvious that they're
 * unused but also make sure that addition of small offsets to them will
 * trigger some of our asserts that surface indices are < BRW_MAX_SURFACES.
 */
void
backend_visitor::assign_common_binding_table_offsets(uint32_t next_binding_table_offset)
{
   int num_textures = _mesa_fls(prog->SamplersUsed);

   stage_prog_data->binding_table.texture_start = next_binding_table_offset;
   next_binding_table_offset += num_textures;

   if (shader) {
      stage_prog_data->binding_table.ubo_start = next_binding_table_offset;
      next_binding_table_offset += shader->base.NumUniformBlocks;
   } else {
      stage_prog_data->binding_table.ubo_start = 0xd0d0d0d0;
   }

   if (INTEL_DEBUG & DEBUG_SHADER_TIME) {
      stage_prog_data->binding_table.shader_time_start = next_binding_table_offset;
      next_binding_table_offset++;
   } else {
      stage_prog_data->binding_table.shader_time_start = 0xd0d0d0d0;
   }

   if (prog->UsesGather) {
      if (brw->gen >= 8) {
         stage_prog_data->binding_table.gather_texture_start =
            stage_prog_data->binding_table.texture_start;
      } else {
         stage_prog_data->binding_table.gather_texture_start = next_binding_table_offset;
         next_binding_table_offset += num_textures;
      }
   } else {
      stage_prog_data->binding_table.gather_texture_start = 0xd0d0d0d0;
   }

   if (shader_prog && shader_prog->NumAtomicBuffers) {
      stage_prog_data->binding_table.abo_start = next_binding_table_offset;
      next_binding_table_offset += shader_prog->NumAtomicBuffers;
   } else {
      stage_prog_data->binding_table.abo_start = 0xd0d0d0d0;
   }

   /* This may or may not be used depending on how the compile goes. */
   stage_prog_data->binding_table.pull_constants_start = next_binding_table_offset;
   next_binding_table_offset++;

   assert(next_binding_table_offset <= BRW_MAX_SURFACES);

   /* prog_data->base.binding_table.size will be set by brw_mark_surface_used. */
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d29 1
a29 1
#include "brw_gs.h"
a30 1
#include "brw_cfg.h"
d51 11
d124 1
a124 1
         &ctx->Const.ShaderCompilerOptions[stage];
d215 2
a216 2
      foreach_in_list(ir_instruction, node, shader->base.ir) {
	 ir_variable *var = node->as_variable();
d222 2
a223 2
	 const ir_state_slot *const slots = var->get_state_slots();
	 assert(slots != NULL);
d225 1
a225 1
	 for (unsigned int i = 0; i < var->get_num_state_slots(); i++) {
d242 6
d281 1
a281 1
enum brw_reg_type
d288 1
a289 1
   case GLSL_TYPE_BOOL:
d307 2
a308 1
      unreachable("not reached");
d314 1
a314 1
enum brw_conditional_mod
d333 2
a334 1
      unreachable("not reached: bad operation for comparison");
d363 2
a364 1
      unreachable("not reached: unknown math function");
d369 1
a369 2
brw_texture_offset(struct gl_context *ctx, int *offsets,
                   unsigned num_components)
d374 3
a376 1
   assert(offsets != NULL || ctx->Extensions.ARB_gpu_shader5);
d378 3
a380 1
   if (!offsets) return 0;  /* nonconstant offset; caller will handle it. */
d389 1
a389 1
   for (unsigned i = 0; i < num_components; i++) {
a452 5
   case SHADER_OPCODE_SHADER_TIME_ADD:
      return "shader_time_add";

   case SHADER_OPCODE_LOAD_PAYLOAD:
      return "load_payload";
a513 2
   case GS_OPCODE_URB_WRITE_ALLOCATE:
      return "gs_urb_write_allocate";
d520 2
a521 2
   case GS_OPCODE_SET_DWORD_2:
      return "set_dword_2";
a527 10
   case GS_OPCODE_FF_SYNC:
      return "ff_sync";
   case GS_OPCODE_SET_PRIMITIVE_ID:
      return "set_primitive_id";
   case GS_OPCODE_SVB_WRITE:
      return "gs_svb_write";
   case GS_OPCODE_SVB_SET_DST_INDEX:
      return "gs_svb_set_dst_index";
   case GS_OPCODE_FF_SYNC_SET_PRIMITIVES:
      return "gs_ff_sync_set_primitives";
d549 1
a549 37
     stage_prog_data(stage_prog_data),
     cfg(NULL),
     stage(stage)
{
}

bool
backend_reg::is_zero() const
{
   if (file != IMM)
      return false;

   return fixed_hw_reg.dw1.d == 0;
}

bool
backend_reg::is_one() const
{
   if (file != IMM)
      return false;

   return type == BRW_REGISTER_TYPE_F
          ? fixed_hw_reg.dw1.f == 1.0
          : fixed_hw_reg.dw1.d == 1;
}

bool
backend_reg::is_null() const
{
   return file == HW_REG &&
          fixed_hw_reg.file == BRW_ARCHITECTURE_REGISTER_FILE &&
          fixed_hw_reg.nr == BRW_ARF_NULL;
}


bool
backend_reg::is_accumulator() const
a550 3
   return file == HW_REG &&
          fixed_hw_reg.file == BRW_ARCHITECTURE_REGISTER_FILE &&
          fixed_hw_reg.nr == BRW_ARF_ACCUMULATOR;
a678 10
backend_instruction::writes_accumulator_implicitly(struct brw_context *brw) const
{
   return writes_accumulator ||
          (brw->gen < 6 &&
           ((opcode >= BRW_OPCODE_ADD && opcode < BRW_OPCODE_NOP) ||
            (opcode >= FS_OPCODE_DDX && opcode <= FS_OPCODE_LINTERP &&
             opcode != FS_OPCODE_CINTERP)));
}

bool
a682 1
   case FS_OPCODE_FB_WRITE:
a688 79
#ifndef NDEBUG
static bool
inst_is_in_block(const bblock_t *block, const backend_instruction *inst)
{
   bool found = false;
   foreach_inst_in_block (backend_instruction, i, block) {
      if (inst == i) {
         found = true;
      }
   }
   return found;
}
#endif

static void
adjust_later_block_ips(bblock_t *start_block, int ip_adjustment)
{
   for (bblock_t *block_iter = start_block->next();
        !block_iter->link.is_tail_sentinel();
        block_iter = block_iter->next()) {
      block_iter->start_ip += ip_adjustment;
      block_iter->end_ip += ip_adjustment;
   }
}

void
backend_instruction::insert_after(bblock_t *block, backend_instruction *inst)
{
   assert(inst_is_in_block(block, this) || !"Instruction not in block");

   block->end_ip++;

   adjust_later_block_ips(block, 1);

   exec_node::insert_after(inst);
}

void
backend_instruction::insert_before(bblock_t *block, backend_instruction *inst)
{
   assert(inst_is_in_block(block, this) || !"Instruction not in block");

   block->end_ip++;

   adjust_later_block_ips(block, 1);

   exec_node::insert_before(inst);
}

void
backend_instruction::insert_before(bblock_t *block, exec_list *list)
{
   assert(inst_is_in_block(block, this) || !"Instruction not in block");

   unsigned num_inst = list->length();

   block->end_ip += num_inst;

   adjust_later_block_ips(block, num_inst);

   exec_node::insert_before(list);
}

void
backend_instruction::remove(bblock_t *block)
{
   assert(inst_is_in_block(block, this) || !"Instruction not in block");

   adjust_later_block_ips(block, -1);

   if (block->start_ip == block->end_ip) {
      block->cfg->remove_block(block);
   } else {
      block->end_ip--;
   }

   exec_node::remove();
}

a691 13
   dump_instructions(NULL);
}

void
backend_visitor::dump_instructions(const char *name)
{
   FILE *file = stderr;
   if (name && geteuid() != 0) {
      file = fopen(name, "w");
      if (!file)
         file = stderr;
   }

d693 4
a696 8
   foreach_block_and_inst(block, backend_instruction, inst, cfg) {
      if (!name)
         fprintf(stderr, "%d: ", ip++);
      dump_instruction(inst, file);
   }

   if (file != stderr) {
      fclose(file);
a699 14
void
backend_visitor::calculate_cfg()
{
   if (this->cfg)
      return;
   cfg = new(mem_ctx) cfg_t(&this->instructions);
}

void
backend_visitor::invalidate_cfg()
{
   ralloc_free(this->cfg);
   this->cfg = NULL;
}
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d29 1
a29 1
#include "brw_vec4_gs.h"
d31 1
a51 11
struct gl_shader_program *
brw_new_shader_program(struct gl_context *ctx, GLuint name)
{
   struct gl_shader_program *prog = rzalloc(NULL, struct gl_shader_program);
   if (prog) {
      prog->Name = name;
      _mesa_init_shader_program(ctx, prog);
   }
   return prog;
}

d114 1
a114 1
         &ctx->ShaderCompilerOptions[stage];
d205 2
a206 2
      foreach_list(node, shader->base.ir) {
	 ir_variable *var = ((ir_instruction *) node)->as_variable();
d212 2
a213 2
	 const ir_state_slot *const slots = var->state_slots;
	 assert(var->state_slots != NULL);
d215 1
a215 1
	 for (unsigned int i = 0; i < var->num_state_slots; i++) {
a231 6
      /* This has to be done last.  Any operation that can cause
       * prog->ParameterValues to get reallocated (e.g., anything that adds a
       * program constant) has to happen before creating this linkage.
       */
      _mesa_associate_uniform_storage(ctx, shProg, prog->Parameters);

d265 1
a265 1
int
d272 1
a273 1
      return BRW_REGISTER_TYPE_D;
d291 1
a291 2
      assert(!"not reached");
      break;
d297 1
a297 1
uint32_t
d316 1
a316 2
      assert(!"not reached: bad operation for comparison");
      return BRW_CONDITIONAL_NZ;
d345 1
a345 2
      assert(!"not reached: unknown math function");
      return 0;
d350 2
a351 1
brw_texture_offset(struct gl_context *ctx, ir_constant *offset)
d356 1
a356 3
   assert(offset != NULL || ctx->Extensions.ARB_gpu_shader5);

   if (!offset) return 0;  /* nonconstant offset; caller will handle it. */
d358 1
a358 3
   signed char offsets[3];
   for (unsigned i = 0; i < offset->type->vector_elements; i++)
      offsets[i] = (signed char) offset->value.i[i];
d367 1
a367 1
   for (unsigned i = 0; i < offset->type->vector_elements; i++) {
d431 5
d497 2
d505 2
a506 2
   case GS_OPCODE_SET_DWORD_2_IMMED:
      return "set_dword_2_immed";
d513 10
d544 37
a580 1
     stage_prog_data(stage_prog_data)
d582 3
d713 10
d727 1
d734 79
d816 13
d830 8
a837 4
   foreach_list(node, &this->instructions) {
      backend_instruction *inst = (backend_instruction *)node;
      fprintf(stderr, "%d: ", ip++);
      dump_instruction(inst);
d841 14
@


