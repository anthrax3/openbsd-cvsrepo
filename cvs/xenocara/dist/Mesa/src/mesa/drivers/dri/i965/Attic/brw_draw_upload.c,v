head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.04.17;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.22.20.04.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.15;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.42;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.42;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.15;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.28.31;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.15.30;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.49;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.11.34;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.48.41;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#include "main/glheader.h"
#include "main/bufferobj.h"
#include "main/context.h"
#include "main/enums.h"
#include "main/macros.h"
#include "main/glformats.h"

#include "brw_draw.h"
#include "brw_defines.h"
#include "brw_context.h"
#include "brw_state.h"

#include "intel_batchbuffer.h"
#include "intel_buffer_objects.h"

static GLuint double_types[5] = {
   0,
   BRW_SURFACEFORMAT_R64_FLOAT,
   BRW_SURFACEFORMAT_R64G64_FLOAT,
   BRW_SURFACEFORMAT_R64G64B64_FLOAT,
   BRW_SURFACEFORMAT_R64G64B64A64_FLOAT
};

static GLuint float_types[5] = {
   0,
   BRW_SURFACEFORMAT_R32_FLOAT,
   BRW_SURFACEFORMAT_R32G32_FLOAT,
   BRW_SURFACEFORMAT_R32G32B32_FLOAT,
   BRW_SURFACEFORMAT_R32G32B32A32_FLOAT
};

static GLuint half_float_types[5] = {
   0,
   BRW_SURFACEFORMAT_R16_FLOAT,
   BRW_SURFACEFORMAT_R16G16_FLOAT,
   BRW_SURFACEFORMAT_R16G16B16A16_FLOAT,
   BRW_SURFACEFORMAT_R16G16B16A16_FLOAT
};

static GLuint fixed_point_types[5] = {
   0,
   BRW_SURFACEFORMAT_R32_SFIXED,
   BRW_SURFACEFORMAT_R32G32_SFIXED,
   BRW_SURFACEFORMAT_R32G32B32_SFIXED,
   BRW_SURFACEFORMAT_R32G32B32A32_SFIXED,
};

static GLuint uint_types_direct[5] = {
   0,
   BRW_SURFACEFORMAT_R32_UINT,
   BRW_SURFACEFORMAT_R32G32_UINT,
   BRW_SURFACEFORMAT_R32G32B32_UINT,
   BRW_SURFACEFORMAT_R32G32B32A32_UINT
};

static GLuint uint_types_norm[5] = {
   0,
   BRW_SURFACEFORMAT_R32_UNORM,
   BRW_SURFACEFORMAT_R32G32_UNORM,
   BRW_SURFACEFORMAT_R32G32B32_UNORM,
   BRW_SURFACEFORMAT_R32G32B32A32_UNORM
};

static GLuint uint_types_scale[5] = {
   0,
   BRW_SURFACEFORMAT_R32_USCALED,
   BRW_SURFACEFORMAT_R32G32_USCALED,
   BRW_SURFACEFORMAT_R32G32B32_USCALED,
   BRW_SURFACEFORMAT_R32G32B32A32_USCALED
};

static GLuint int_types_direct[5] = {
   0,
   BRW_SURFACEFORMAT_R32_SINT,
   BRW_SURFACEFORMAT_R32G32_SINT,
   BRW_SURFACEFORMAT_R32G32B32_SINT,
   BRW_SURFACEFORMAT_R32G32B32A32_SINT
};

static GLuint int_types_norm[5] = {
   0,
   BRW_SURFACEFORMAT_R32_SNORM,
   BRW_SURFACEFORMAT_R32G32_SNORM,
   BRW_SURFACEFORMAT_R32G32B32_SNORM,
   BRW_SURFACEFORMAT_R32G32B32A32_SNORM
};

static GLuint int_types_scale[5] = {
   0,
   BRW_SURFACEFORMAT_R32_SSCALED,
   BRW_SURFACEFORMAT_R32G32_SSCALED,
   BRW_SURFACEFORMAT_R32G32B32_SSCALED,
   BRW_SURFACEFORMAT_R32G32B32A32_SSCALED
};

static GLuint ushort_types_direct[5] = {
   0,
   BRW_SURFACEFORMAT_R16_UINT,
   BRW_SURFACEFORMAT_R16G16_UINT,
   BRW_SURFACEFORMAT_R16G16B16A16_UINT,
   BRW_SURFACEFORMAT_R16G16B16A16_UINT
};

static GLuint ushort_types_norm[5] = {
   0,
   BRW_SURFACEFORMAT_R16_UNORM,
   BRW_SURFACEFORMAT_R16G16_UNORM,
   BRW_SURFACEFORMAT_R16G16B16_UNORM,
   BRW_SURFACEFORMAT_R16G16B16A16_UNORM
};

static GLuint ushort_types_scale[5] = {
   0,
   BRW_SURFACEFORMAT_R16_USCALED,
   BRW_SURFACEFORMAT_R16G16_USCALED,
   BRW_SURFACEFORMAT_R16G16B16_USCALED,
   BRW_SURFACEFORMAT_R16G16B16A16_USCALED
};

static GLuint short_types_direct[5] = {
   0,
   BRW_SURFACEFORMAT_R16_SINT,
   BRW_SURFACEFORMAT_R16G16_SINT,
   BRW_SURFACEFORMAT_R16G16B16A16_SINT,
   BRW_SURFACEFORMAT_R16G16B16A16_SINT
};

static GLuint short_types_norm[5] = {
   0,
   BRW_SURFACEFORMAT_R16_SNORM,
   BRW_SURFACEFORMAT_R16G16_SNORM,
   BRW_SURFACEFORMAT_R16G16B16_SNORM,
   BRW_SURFACEFORMAT_R16G16B16A16_SNORM
};

static GLuint short_types_scale[5] = {
   0,
   BRW_SURFACEFORMAT_R16_SSCALED,
   BRW_SURFACEFORMAT_R16G16_SSCALED,
   BRW_SURFACEFORMAT_R16G16B16_SSCALED,
   BRW_SURFACEFORMAT_R16G16B16A16_SSCALED
};

static GLuint ubyte_types_direct[5] = {
   0,
   BRW_SURFACEFORMAT_R8_UINT,
   BRW_SURFACEFORMAT_R8G8_UINT,
   BRW_SURFACEFORMAT_R8G8B8A8_UINT,
   BRW_SURFACEFORMAT_R8G8B8A8_UINT
};

static GLuint ubyte_types_norm[5] = {
   0,
   BRW_SURFACEFORMAT_R8_UNORM,
   BRW_SURFACEFORMAT_R8G8_UNORM,
   BRW_SURFACEFORMAT_R8G8B8_UNORM,
   BRW_SURFACEFORMAT_R8G8B8A8_UNORM
};

static GLuint ubyte_types_scale[5] = {
   0,
   BRW_SURFACEFORMAT_R8_USCALED,
   BRW_SURFACEFORMAT_R8G8_USCALED,
   BRW_SURFACEFORMAT_R8G8B8_USCALED,
   BRW_SURFACEFORMAT_R8G8B8A8_USCALED
};

static GLuint byte_types_direct[5] = {
   0,
   BRW_SURFACEFORMAT_R8_SINT,
   BRW_SURFACEFORMAT_R8G8_SINT,
   BRW_SURFACEFORMAT_R8G8B8A8_SINT,
   BRW_SURFACEFORMAT_R8G8B8A8_SINT
};

static GLuint byte_types_norm[5] = {
   0,
   BRW_SURFACEFORMAT_R8_SNORM,
   BRW_SURFACEFORMAT_R8G8_SNORM,
   BRW_SURFACEFORMAT_R8G8B8_SNORM,
   BRW_SURFACEFORMAT_R8G8B8A8_SNORM
};

static GLuint byte_types_scale[5] = {
   0,
   BRW_SURFACEFORMAT_R8_SSCALED,
   BRW_SURFACEFORMAT_R8G8_SSCALED,
   BRW_SURFACEFORMAT_R8G8B8_SSCALED,
   BRW_SURFACEFORMAT_R8G8B8A8_SSCALED
};


/**
 * Given vertex array type/size/format/normalized info, return
 * the appopriate hardware surface type.
 * Format will be GL_RGBA or possibly GL_BGRA for GLubyte[4] color arrays.
 */
unsigned
brw_get_vertex_surface_type(struct brw_context *brw,
                            const struct gl_client_array *glarray)
{
   int size = glarray->Size;

   if (unlikely(INTEL_DEBUG & DEBUG_VERTS))
      fprintf(stderr, "type %s size %d normalized %d\n",
              _mesa_lookup_enum_by_nr(glarray->Type),
              glarray->Size, glarray->Normalized);

   if (glarray->Integer) {
      assert(glarray->Format == GL_RGBA); /* sanity check */
      switch (glarray->Type) {
      case GL_INT: return int_types_direct[size];
      case GL_SHORT: return short_types_direct[size];
      case GL_BYTE: return byte_types_direct[size];
      case GL_UNSIGNED_INT: return uint_types_direct[size];
      case GL_UNSIGNED_SHORT: return ushort_types_direct[size];
      case GL_UNSIGNED_BYTE: return ubyte_types_direct[size];
      default: assert(0); return 0;
      }
   } else if (glarray->Type == GL_UNSIGNED_INT_10F_11F_11F_REV) {
      return BRW_SURFACEFORMAT_R11G11B10_FLOAT;
   } else if (glarray->Normalized) {
      switch (glarray->Type) {
      case GL_DOUBLE: return double_types[size];
      case GL_FLOAT: return float_types[size];
      case GL_HALF_FLOAT: return half_float_types[size];
      case GL_INT: return int_types_norm[size];
      case GL_SHORT: return short_types_norm[size];
      case GL_BYTE: return byte_types_norm[size];
      case GL_UNSIGNED_INT: return uint_types_norm[size];
      case GL_UNSIGNED_SHORT: return ushort_types_norm[size];
      case GL_UNSIGNED_BYTE:
         if (glarray->Format == GL_BGRA) {
            /* See GL_EXT_vertex_array_bgra */
            assert(size == 4);
            return BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
         }
         else {
            return ubyte_types_norm[size];
         }
      case GL_FIXED:
         if (brw->gen >= 8 || brw->is_haswell)
            return fixed_point_types[size];

         /* This produces GL_FIXED inputs as values between INT32_MIN and
          * INT32_MAX, which will be scaled down by 1/65536 by the VS.
          */
         return int_types_scale[size];
      /* See GL_ARB_vertex_type_2_10_10_10_rev.
       * W/A: Pre-Haswell, the hardware doesn't really support the formats we'd
       * like to use here, so upload everything as UINT and fix
       * it in the shader
       */
      case GL_INT_2_10_10_10_REV:
         assert(size == 4);
         if (brw->gen >= 8 || brw->is_haswell) {
            return glarray->Format == GL_BGRA
               ? BRW_SURFACEFORMAT_B10G10R10A2_SNORM
               : BRW_SURFACEFORMAT_R10G10B10A2_SNORM;
         }
         return BRW_SURFACEFORMAT_R10G10B10A2_UINT;
      case GL_UNSIGNED_INT_2_10_10_10_REV:
         assert(size == 4);
         if (brw->gen >= 8 || brw->is_haswell) {
            return glarray->Format == GL_BGRA
               ? BRW_SURFACEFORMAT_B10G10R10A2_UNORM
               : BRW_SURFACEFORMAT_R10G10B10A2_UNORM;
         }
         return BRW_SURFACEFORMAT_R10G10B10A2_UINT;
      default: assert(0); return 0;
      }
   }
   else {
      /* See GL_ARB_vertex_type_2_10_10_10_rev.
       * W/A: the hardware doesn't really support the formats we'd
       * like to use here, so upload everything as UINT and fix
       * it in the shader
       */
      if (glarray->Type == GL_INT_2_10_10_10_REV) {
         assert(size == 4);
         if (brw->gen >= 8 || brw->is_haswell) {
            return glarray->Format == GL_BGRA
               ? BRW_SURFACEFORMAT_B10G10R10A2_SSCALED
               : BRW_SURFACEFORMAT_R10G10B10A2_SSCALED;
         }
         return BRW_SURFACEFORMAT_R10G10B10A2_UINT;
      } else if (glarray->Type == GL_UNSIGNED_INT_2_10_10_10_REV) {
         assert(size == 4);
         if (brw->gen >= 8 || brw->is_haswell) {
            return glarray->Format == GL_BGRA
               ? BRW_SURFACEFORMAT_B10G10R10A2_USCALED
               : BRW_SURFACEFORMAT_R10G10B10A2_USCALED;
         }
         return BRW_SURFACEFORMAT_R10G10B10A2_UINT;
      }
      assert(glarray->Format == GL_RGBA); /* sanity check */
      switch (glarray->Type) {
      case GL_DOUBLE: return double_types[size];
      case GL_FLOAT: return float_types[size];
      case GL_HALF_FLOAT: return half_float_types[size];
      case GL_INT: return int_types_scale[size];
      case GL_SHORT: return short_types_scale[size];
      case GL_BYTE: return byte_types_scale[size];
      case GL_UNSIGNED_INT: return uint_types_scale[size];
      case GL_UNSIGNED_SHORT: return ushort_types_scale[size];
      case GL_UNSIGNED_BYTE: return ubyte_types_scale[size];
      case GL_FIXED:
         if (brw->gen >= 8 || brw->is_haswell)
            return fixed_point_types[size];

         /* This produces GL_FIXED inputs as values between INT32_MIN and
          * INT32_MAX, which will be scaled down by 1/65536 by the VS.
          */
         return int_types_scale[size];
      default: assert(0); return 0;
      }
   }
}

unsigned
brw_get_index_type(GLenum type)
{
   switch (type) {
   case GL_UNSIGNED_BYTE:  return BRW_INDEX_BYTE;
   case GL_UNSIGNED_SHORT: return BRW_INDEX_WORD;
   case GL_UNSIGNED_INT:   return BRW_INDEX_DWORD;
   default: assert(0); return 0;
   }
}

static void
copy_array_to_vbo_array(struct brw_context *brw,
			struct brw_vertex_element *element,
			int min, int max,
			struct brw_vertex_buffer *buffer,
			GLuint dst_stride)
{
   const int src_stride = element->glarray->StrideB;

   /* If the source stride is zero, we just want to upload the current
    * attribute once and set the buffer's stride to 0.  There's no need
    * to replicate it out.
    */
   if (src_stride == 0) {
      intel_upload_data(brw, element->glarray->Ptr,
                        element->glarray->_ElementSize,
                        element->glarray->_ElementSize,
			&buffer->bo, &buffer->offset);

      buffer->stride = 0;
      return;
   }

   const unsigned char *src = element->glarray->Ptr + min * src_stride;
   int count = max - min + 1;
   GLuint size = count * dst_stride;
   uint8_t *dst = intel_upload_space(brw, size, dst_stride,
                                     &buffer->bo, &buffer->offset);

   if (dst_stride == src_stride) {
      memcpy(dst, src, size);
   } else {
      while (count--) {
	 memcpy(dst, src, dst_stride);
	 src += src_stride;
	 dst += dst_stride;
      }
   }
   buffer->stride = dst_stride;
}

void
brw_prepare_vertices(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   /* CACHE_NEW_VS_PROG */
   GLbitfield64 vs_inputs = brw->vs.prog_data->inputs_read;
   const unsigned char *ptr = NULL;
   GLuint interleaved = 0;
   unsigned int min_index = brw->vb.min_index + brw->basevertex;
   unsigned int max_index = brw->vb.max_index + brw->basevertex;
   int delta, i, j;

   struct brw_vertex_element *upload[VERT_ATTRIB_MAX];
   GLuint nr_uploads = 0;

   /* _NEW_POLYGON
    *
    * On gen6+, edge flags don't end up in the VUE (either in or out of the
    * VS).  Instead, they're uploaded as the last vertex element, and the data
    * is passed sideband through the fixed function units.  So, we need to
    * prepare the vertex buffer for it, but it's not present in inputs_read.
    */
   if (brw->gen >= 6 && (ctx->Polygon.FrontMode != GL_FILL ||
                           ctx->Polygon.BackMode != GL_FILL)) {
      vs_inputs |= VERT_BIT_EDGEFLAG;
   }

   if (0)
      fprintf(stderr, "%s %d..%d\n", __FUNCTION__, min_index, max_index);

   /* Accumulate the list of enabled arrays. */
   brw->vb.nr_enabled = 0;
   while (vs_inputs) {
      GLuint i = ffsll(vs_inputs) - 1;
      struct brw_vertex_element *input = &brw->vb.inputs[i];

      vs_inputs &= ~BITFIELD64_BIT(i);
      brw->vb.enabled[brw->vb.nr_enabled++] = input;
   }

   if (brw->vb.nr_enabled == 0)
      return;

   if (brw->vb.nr_buffers)
      return;

   for (i = j = 0; i < brw->vb.nr_enabled; i++) {
      struct brw_vertex_element *input = brw->vb.enabled[i];
      const struct gl_client_array *glarray = input->glarray;

      if (_mesa_is_bufferobj(glarray->BufferObj)) {
	 struct intel_buffer_object *intel_buffer =
	    intel_buffer_object(glarray->BufferObj);
	 int k;

	 /* If we have a VB set to be uploaded for this buffer object
	  * already, reuse that VB state so that we emit fewer
	  * relocations.
	  */
	 for (k = 0; k < i; k++) {
	    const struct gl_client_array *other = brw->vb.enabled[k]->glarray;
	    if (glarray->BufferObj == other->BufferObj &&
		glarray->StrideB == other->StrideB &&
		glarray->InstanceDivisor == other->InstanceDivisor &&
		(uintptr_t)(glarray->Ptr - other->Ptr) < glarray->StrideB)
	    {
	       input->buffer = brw->vb.enabled[k]->buffer;
	       input->offset = glarray->Ptr - other->Ptr;
	       break;
	    }
	 }
	 if (k == i) {
	    struct brw_vertex_buffer *buffer = &brw->vb.buffers[j];

	    /* Named buffer object: Just reference its contents directly. */
	    buffer->offset = (uintptr_t)glarray->Ptr;
	    buffer->stride = glarray->StrideB;
	    buffer->step_rate = glarray->InstanceDivisor;

            uint32_t offset, size;
            if (glarray->InstanceDivisor) {
               offset = buffer->offset;
               size = (buffer->stride * ((brw->num_instances /
                                          glarray->InstanceDivisor) - 1) +
                       glarray->_ElementSize);
            } else {
               if (min_index == -1) {
                  offset = 0;
                  size = intel_buffer->Base.Size;
               } else {
                  offset = buffer->offset + min_index * buffer->stride;
                  size = (buffer->stride * (max_index - min_index) +
                          glarray->_ElementSize);
               }
            }
            buffer->bo = intel_bufferobj_buffer(brw, intel_buffer,
                                                offset, size);
            drm_intel_bo_reference(buffer->bo);

	    input->buffer = j++;
	    input->offset = 0;
	 }

	 /* This is a common place to reach if the user mistakenly supplies
	  * a pointer in place of a VBO offset.  If we just let it go through,
	  * we may end up dereferencing a pointer beyond the bounds of the
	  * GTT.  We would hope that the VBO's max_index would save us, but
	  * Mesa appears to hand us min/max values not clipped to the
	  * array object's _MaxElement, and _MaxElement frequently appears
	  * to be wrong anyway.
	  *
	  * The VBO spec allows application termination in this case, and it's
	  * probably a service to the poor programmer to do so rather than
	  * trying to just not render.
	  */
	 assert(input->offset < brw->vb.buffers[input->buffer].bo->size);
      } else {
	 /* Queue the buffer object up to be uploaded in the next pass,
	  * when we've decided if we're doing interleaved or not.
	  */
	 if (nr_uploads == 0) {
	    interleaved = glarray->StrideB;
	    ptr = glarray->Ptr;
	 }
	 else if (interleaved != glarray->StrideB ||
                  glarray->Ptr < ptr ||
                  (uintptr_t)(glarray->Ptr - ptr) + glarray->_ElementSize > interleaved)
	 {
            /* If our stride is different from the first attribute's stride,
             * or if the first attribute's stride didn't cover our element,
             * disable the interleaved upload optimization.  The second case
             * can most commonly occur in cases where there is a single vertex
             * and, for example, the data is stored on the application's
             * stack.
             *
             * NOTE: This will also disable the optimization in cases where
             * the data is in a different order than the array indices.
             * Something like:
             *
             *     float data[...];
             *     glVertexAttribPointer(0, 4, GL_FLOAT, 32, &data[4]);
             *     glVertexAttribPointer(1, 4, GL_FLOAT, 32, &data[0]);
             */
	    interleaved = 0;
	 }

	 upload[nr_uploads++] = input;
      }
   }

   /* If we need to upload all the arrays, then we can trim those arrays to
    * only the used elements [min_index, max_index] so long as we adjust all
    * the values used in the 3DPRIMITIVE i.e. by setting the vertex bias.
    */
   brw->vb.start_vertex_bias = 0;
   delta = min_index;
   if (nr_uploads == brw->vb.nr_enabled) {
      brw->vb.start_vertex_bias = -delta;
      delta = 0;
   }

   /* Handle any arrays to be uploaded. */
   if (nr_uploads > 1) {
      if (interleaved) {
	 struct brw_vertex_buffer *buffer = &brw->vb.buffers[j];
	 /* All uploads are interleaved, so upload the arrays together as
	  * interleaved.  First, upload the contents and set up upload[0].
	  */
	 copy_array_to_vbo_array(brw, upload[0], min_index, max_index,
				 buffer, interleaved);
	 buffer->offset -= delta * interleaved;

	 for (i = 0; i < nr_uploads; i++) {
	    /* Then, just point upload[i] at upload[0]'s buffer. */
	    upload[i]->offset =
	       ((const unsigned char *)upload[i]->glarray->Ptr - ptr);
	    upload[i]->buffer = j;
	 }
	 j++;

	 nr_uploads = 0;
      }
   }
   /* Upload non-interleaved arrays */
   for (i = 0; i < nr_uploads; i++) {
      struct brw_vertex_buffer *buffer = &brw->vb.buffers[j];
      if (upload[i]->glarray->InstanceDivisor == 0) {
         copy_array_to_vbo_array(brw, upload[i], min_index, max_index,
                                 buffer, upload[i]->glarray->_ElementSize);
      } else {
         /* This is an instanced attribute, since its InstanceDivisor
          * is not zero. Therefore, its data will be stepped after the
          * instanced draw has been run InstanceDivisor times.
          */
         uint32_t instanced_attr_max_index =
            (brw->num_instances - 1) / upload[i]->glarray->InstanceDivisor;
         copy_array_to_vbo_array(brw, upload[i], 0, instanced_attr_max_index,
                                 buffer, upload[i]->glarray->_ElementSize);
      }
      buffer->offset -= delta * buffer->stride;
      buffer->step_rate = upload[i]->glarray->InstanceDivisor;
      upload[i]->buffer = j++;
      upload[i]->offset = 0;
   }

   brw->vb.nr_buffers = j;
}

static void brw_emit_vertices(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   GLuint i, nr_elements;

   brw_prepare_vertices(brw);

   brw_emit_query_begin(brw);

   nr_elements = brw->vb.nr_enabled + brw->vs.prog_data->uses_vertexid;

   /* If the VS doesn't read any inputs (calculating vertex position from
    * a state variable for some reason, for example), emit a single pad
    * VERTEX_ELEMENT struct and bail.
    *
    * The stale VB state stays in place, but they don't do anything unless
    * a VE loads from them.
    */
   if (nr_elements == 0) {
      BEGIN_BATCH(3);
      OUT_BATCH((_3DSTATE_VERTEX_ELEMENTS << 16) | 1);
      if (brw->gen >= 6) {
	 OUT_BATCH((0 << GEN6_VE0_INDEX_SHIFT) |
		   GEN6_VE0_VALID |
		   (BRW_SURFACEFORMAT_R32G32B32A32_FLOAT << BRW_VE0_FORMAT_SHIFT) |
		   (0 << BRW_VE0_SRC_OFFSET_SHIFT));
      } else {
	 OUT_BATCH((0 << BRW_VE0_INDEX_SHIFT) |
		   BRW_VE0_VALID |
		   (BRW_SURFACEFORMAT_R32G32B32A32_FLOAT << BRW_VE0_FORMAT_SHIFT) |
		   (0 << BRW_VE0_SRC_OFFSET_SHIFT));
      }
      OUT_BATCH((BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_0_SHIFT) |
		(BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_1_SHIFT) |
		(BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_2_SHIFT) |
		(BRW_VE1_COMPONENT_STORE_1_FLT << BRW_VE1_COMPONENT_3_SHIFT));
      ADVANCE_BATCH();
      return;
   }

   /* Now emit VB and VEP state packets.
    */

   if (brw->vb.nr_buffers) {
      if (brw->gen >= 6) {
	 assert(brw->vb.nr_buffers <= 33);
      } else {
	 assert(brw->vb.nr_buffers <= 17);
      }

      BEGIN_BATCH(1 + 4*brw->vb.nr_buffers);
      OUT_BATCH((_3DSTATE_VERTEX_BUFFERS << 16) | (4*brw->vb.nr_buffers - 1));
      for (i = 0; i < brw->vb.nr_buffers; i++) {
	 struct brw_vertex_buffer *buffer = &brw->vb.buffers[i];
	 uint32_t dw0;

	 if (brw->gen >= 6) {
	    dw0 = buffer->step_rate
	             ? GEN6_VB0_ACCESS_INSTANCEDATA
	             : GEN6_VB0_ACCESS_VERTEXDATA;
	    dw0 |= i << GEN6_VB0_INDEX_SHIFT;
	 } else {
	    dw0 = buffer->step_rate
	             ? BRW_VB0_ACCESS_INSTANCEDATA
	             : BRW_VB0_ACCESS_VERTEXDATA;
	    dw0 |= i << BRW_VB0_INDEX_SHIFT;
	 }

	 if (brw->gen >= 7)
	    dw0 |= GEN7_VB0_ADDRESS_MODIFYENABLE;

         if (brw->gen == 7)
	    dw0 |= GEN7_MOCS_L3 << 16;

         WARN_ONCE(buffer->stride >= (brw->gen >= 5 ? 2048 : 2047),
                   "VBO stride %d too large, bad rendering may occur\n",
                   buffer->stride);
	 OUT_BATCH(dw0 | (buffer->stride << BRW_VB0_PITCH_SHIFT));
	 OUT_RELOC(buffer->bo, I915_GEM_DOMAIN_VERTEX, 0, buffer->offset);
	 if (brw->gen >= 5) {
	    OUT_RELOC(buffer->bo, I915_GEM_DOMAIN_VERTEX, 0, buffer->bo->size - 1);
	 } else
	    OUT_BATCH(0);
	 OUT_BATCH(buffer->step_rate);
      }
      ADVANCE_BATCH();
   }

   /* The hardware allows one more VERTEX_ELEMENTS than VERTEX_BUFFERS, presumably
    * for VertexID/InstanceID.
    */
   if (brw->gen >= 6) {
      assert(nr_elements <= 34);
   } else {
      assert(nr_elements <= 18);
   }

   struct brw_vertex_element *gen6_edgeflag_input = NULL;

   BEGIN_BATCH(1 + nr_elements * 2);
   OUT_BATCH((_3DSTATE_VERTEX_ELEMENTS << 16) | (2 * nr_elements - 1));
   for (i = 0; i < brw->vb.nr_enabled; i++) {
      struct brw_vertex_element *input = brw->vb.enabled[i];
      uint32_t format = brw_get_vertex_surface_type(brw, input->glarray);
      uint32_t comp0 = BRW_VE1_COMPONENT_STORE_SRC;
      uint32_t comp1 = BRW_VE1_COMPONENT_STORE_SRC;
      uint32_t comp2 = BRW_VE1_COMPONENT_STORE_SRC;
      uint32_t comp3 = BRW_VE1_COMPONENT_STORE_SRC;

      if (input == &brw->vb.inputs[VERT_ATTRIB_EDGEFLAG]) {
         /* Gen6+ passes edgeflag as sideband along with the vertex, instead
          * of in the VUE.  We have to upload it sideband as the last vertex
          * element according to the B-Spec.
          */
         if (brw->gen >= 6) {
            gen6_edgeflag_input = input;
            continue;
         }
      }

      switch (input->glarray->Size) {
      case 0: comp0 = BRW_VE1_COMPONENT_STORE_0;
      case 1: comp1 = BRW_VE1_COMPONENT_STORE_0;
      case 2: comp2 = BRW_VE1_COMPONENT_STORE_0;
      case 3: comp3 = input->glarray->Integer ? BRW_VE1_COMPONENT_STORE_1_INT
                                              : BRW_VE1_COMPONENT_STORE_1_FLT;
	 break;
      }

      if (brw->gen >= 6) {
	 OUT_BATCH((input->buffer << GEN6_VE0_INDEX_SHIFT) |
		   GEN6_VE0_VALID |
		   (format << BRW_VE0_FORMAT_SHIFT) |
		   (input->offset << BRW_VE0_SRC_OFFSET_SHIFT));
      } else {
	 OUT_BATCH((input->buffer << BRW_VE0_INDEX_SHIFT) |
		   BRW_VE0_VALID |
		   (format << BRW_VE0_FORMAT_SHIFT) |
		   (input->offset << BRW_VE0_SRC_OFFSET_SHIFT));
      }

      if (brw->gen >= 5)
          OUT_BATCH((comp0 << BRW_VE1_COMPONENT_0_SHIFT) |
                    (comp1 << BRW_VE1_COMPONENT_1_SHIFT) |
                    (comp2 << BRW_VE1_COMPONENT_2_SHIFT) |
                    (comp3 << BRW_VE1_COMPONENT_3_SHIFT));
      else
          OUT_BATCH((comp0 << BRW_VE1_COMPONENT_0_SHIFT) |
                    (comp1 << BRW_VE1_COMPONENT_1_SHIFT) |
                    (comp2 << BRW_VE1_COMPONENT_2_SHIFT) |
                    (comp3 << BRW_VE1_COMPONENT_3_SHIFT) |
                    ((i * 4) << BRW_VE1_DST_OFFSET_SHIFT));
   }

   if (brw->gen >= 6 && gen6_edgeflag_input) {
      uint32_t format =
         brw_get_vertex_surface_type(brw, gen6_edgeflag_input->glarray);

      OUT_BATCH((gen6_edgeflag_input->buffer << GEN6_VE0_INDEX_SHIFT) |
                GEN6_VE0_VALID |
                GEN6_VE0_EDGE_FLAG_ENABLE |
                (format << BRW_VE0_FORMAT_SHIFT) |
                (gen6_edgeflag_input->offset << BRW_VE0_SRC_OFFSET_SHIFT));
      OUT_BATCH((BRW_VE1_COMPONENT_STORE_SRC << BRW_VE1_COMPONENT_0_SHIFT) |
                (BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_1_SHIFT) |
                (BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_2_SHIFT) |
                (BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_3_SHIFT));
   }

   if (brw->vs.prog_data->uses_vertexid) {
      uint32_t dw0 = 0, dw1 = 0;

      dw1 = ((BRW_VE1_COMPONENT_STORE_VID << BRW_VE1_COMPONENT_0_SHIFT) |
	     (BRW_VE1_COMPONENT_STORE_IID << BRW_VE1_COMPONENT_1_SHIFT) |
	     (BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_2_SHIFT) |
	     (BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_3_SHIFT));

      if (brw->gen >= 6) {
	 dw0 |= GEN6_VE0_VALID;
      } else {
	 dw0 |= BRW_VE0_VALID;
	 dw1 |= (i * 4) << BRW_VE1_DST_OFFSET_SHIFT;
      }

      /* Note that for gl_VertexID, gl_InstanceID, and gl_PrimitiveID values,
       * the format is ignored and the value is always int.
       */

      OUT_BATCH(dw0);
      OUT_BATCH(dw1);
   }

   ADVANCE_BATCH();
}

const struct brw_tracked_state brw_vertices = {
   .dirty = {
      .mesa = _NEW_POLYGON,
      .brw = BRW_NEW_BATCH | BRW_NEW_VERTICES,
      .cache = CACHE_NEW_VS_PROG,
   },
   .emit = brw_emit_vertices,
};

static void brw_upload_indices(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   const struct _mesa_index_buffer *index_buffer = brw->ib.ib;
   GLuint ib_size;
   drm_intel_bo *old_bo = brw->ib.bo;
   struct gl_buffer_object *bufferobj;
   GLuint offset;
   GLuint ib_type_size;

   if (index_buffer == NULL)
      return;

   ib_type_size = _mesa_sizeof_type(index_buffer->type);
   ib_size = ib_type_size * index_buffer->count;
   bufferobj = index_buffer->obj;

   /* Turn into a proper VBO:
    */
   if (!_mesa_is_bufferobj(bufferobj)) {
      /* Get new bufferobj, offset:
       */
      intel_upload_data(brw, index_buffer->ptr, ib_size, ib_type_size,
			&brw->ib.bo, &offset);
   } else {
      offset = (GLuint) (unsigned long) index_buffer->ptr;

      /* If the index buffer isn't aligned to its element size, we have to
       * rebase it into a temporary.
       */
      if ((ib_type_size - 1) & offset) {
         perf_debug("copying index buffer to a temporary to work around "
                    "misaligned offset %d\n", offset);

         GLubyte *map = ctx->Driver.MapBufferRange(ctx,
                                                   offset,
                                                   ib_size,
                                                   GL_MAP_READ_BIT,
                                                   bufferobj,
                                                   MAP_INTERNAL);

         intel_upload_data(brw, map, ib_size, ib_type_size,
                           &brw->ib.bo, &offset);

         ctx->Driver.UnmapBuffer(ctx, bufferobj, MAP_INTERNAL);
      } else {
         drm_intel_bo *bo =
            intel_bufferobj_buffer(brw, intel_buffer_object(bufferobj),
                                   offset, ib_size);
         if (bo != brw->ib.bo) {
            drm_intel_bo_unreference(brw->ib.bo);
            brw->ib.bo = bo;
            drm_intel_bo_reference(bo);
         }
      }
   }

   /* Use 3DPRIMITIVE's start_vertex_offset to avoid re-uploading
    * the index buffer state when we're just moving the start index
    * of our drawing.
    */
   brw->ib.start_vertex_offset = offset / ib_type_size;

   if (brw->ib.bo != old_bo)
      brw->state.dirty.brw |= BRW_NEW_INDEX_BUFFER;

   if (index_buffer->type != brw->ib.type) {
      brw->ib.type = index_buffer->type;
      brw->state.dirty.brw |= BRW_NEW_INDEX_BUFFER;
   }
}

const struct brw_tracked_state brw_indices = {
   .dirty = {
      .mesa = 0,
      .brw = BRW_NEW_INDICES,
      .cache = 0,
   },
   .emit = brw_upload_indices,
};

static void brw_emit_index_buffer(struct brw_context *brw)
{
   const struct _mesa_index_buffer *index_buffer = brw->ib.ib;
   GLuint cut_index_setting;

   if (index_buffer == NULL)
      return;

   if (brw->prim_restart.enable_cut_index && !brw->is_haswell) {
      cut_index_setting = BRW_CUT_INDEX_ENABLE;
   } else {
      cut_index_setting = 0;
   }

   BEGIN_BATCH(3);
   OUT_BATCH(CMD_INDEX_BUFFER << 16 |
             cut_index_setting |
             brw_get_index_type(index_buffer->type) << 8 |
             1);
   OUT_RELOC(brw->ib.bo,
             I915_GEM_DOMAIN_VERTEX, 0,
             0);
   OUT_RELOC(brw->ib.bo,
             I915_GEM_DOMAIN_VERTEX, 0,
	     brw->ib.bo->size - 1);
   ADVANCE_BATCH();
}

const struct brw_tracked_state brw_index_buffer = {
   .dirty = {
      .mesa = 0,
      .brw = BRW_NEW_BATCH | BRW_NEW_INDEX_BUFFER,
      .cache = 0,
   },
   .emit = brw_emit_index_buffer,
};
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d245 1
a245 1
      default: unreachable("not reached");
d297 1
a297 1
      default: unreachable("not reached");
d342 1
a342 1
      default: unreachable("not reached");
d354 1
a354 1
   default: unreachable("not reached");
d505 4
a508 1
	  * GTT.
d607 1
a607 22
void
brw_prepare_shader_draw_parameters(struct brw_context *brw)
{
   /* For non-indirect draws, upload gl_BaseVertex. */
   if (brw->vs.prog_data->uses_vertexid && brw->draw.draw_params_bo == NULL) {
      intel_upload_data(brw, &brw->draw.gl_basevertex, 4, 4,
			&brw->draw.draw_params_bo,
                        &brw->draw.draw_params_offset);
   }
}

/**
 * Emit a VERTEX_BUFFER_STATE entry (part of 3DSTATE_VERTEX_BUFFERS).
 */
static void
emit_vertex_buffer_state(struct brw_context *brw,
                         unsigned buffer_nr,
                         drm_intel_bo *bo,
                         unsigned bo_ending_address,
                         unsigned bo_offset,
                         unsigned stride,
                         unsigned step_rate)
d610 1
a610 34
   uint32_t dw0;

   if (brw->gen >= 6) {
      dw0 = (buffer_nr << GEN6_VB0_INDEX_SHIFT) |
            (step_rate ? GEN6_VB0_ACCESS_INSTANCEDATA
                       : GEN6_VB0_ACCESS_VERTEXDATA);
   } else {
      dw0 = (buffer_nr << BRW_VB0_INDEX_SHIFT) |
            (step_rate ? BRW_VB0_ACCESS_INSTANCEDATA
                       : BRW_VB0_ACCESS_VERTEXDATA);
   }

   if (brw->gen >= 7)
      dw0 |= GEN7_VB0_ADDRESS_MODIFYENABLE;

   if (brw->gen == 7)
      dw0 |= GEN7_MOCS_L3 << 16;

   WARN_ONCE(stride >= (brw->gen >= 5 ? 2048 : 2047),
             "VBO stride %d too large, bad rendering may occur\n",
             stride);
   OUT_BATCH(dw0 | (stride << BRW_VB0_PITCH_SHIFT));
   OUT_RELOC(bo, I915_GEM_DOMAIN_VERTEX, 0, bo_offset);
   if (brw->gen >= 5) {
      OUT_RELOC(bo, I915_GEM_DOMAIN_VERTEX, 0, bo_ending_address);
   } else {
      OUT_BATCH(0);
   }
   OUT_BATCH(step_rate);
}

static void brw_emit_vertices(struct brw_context *brw)
{
   GLuint i;
a612 1
   brw_prepare_shader_draw_parameters(brw);
d616 1
a616 3
   unsigned nr_elements = brw->vb.nr_enabled;
   if (brw->vs.prog_data->uses_vertexid || brw->vs.prog_data->uses_instanceid)
      ++nr_elements;
d650 1
a650 4
   unsigned nr_buffers =
      brw->vb.nr_buffers + brw->vs.prog_data->uses_vertexid;

   if (nr_buffers) {
d652 1
a652 1
	 assert(nr_buffers <= 33);
d654 1
a654 1
	 assert(nr_buffers <= 17);
d657 2
a658 2
      BEGIN_BATCH(1 + 4 * nr_buffers);
      OUT_BATCH((_3DSTATE_VERTEX_BUFFERS << 16) | (4 * nr_buffers - 1));
d661 13
a673 3
         emit_vertex_buffer_state(brw, i, buffer->bo, buffer->bo->size - 1,
                                  buffer->offset, buffer->stride,
                                  buffer->step_rate);
d675 5
a679 1
      }
d681 10
a690 7
      if (brw->vs.prog_data->uses_vertexid) {
         emit_vertex_buffer_state(brw, brw->vb.nr_buffers,
                                  brw->draw.draw_params_bo,
                                  brw->draw.draw_params_bo->size - 1,
                                  brw->draw.draw_params_offset,
                                  0,  /* stride */
                                  0); /* step rate */
d776 1
a776 1
   if (brw->vs.prog_data->uses_vertexid || brw->vs.prog_data->uses_instanceid) {
a777 13
      uint32_t comp0 = BRW_VE1_COMPONENT_STORE_0;
      uint32_t comp1 = BRW_VE1_COMPONENT_STORE_0;
      uint32_t comp2 = BRW_VE1_COMPONENT_STORE_0;
      uint32_t comp3 = BRW_VE1_COMPONENT_STORE_0;

      if (brw->vs.prog_data->uses_vertexid) {
         comp0 = BRW_VE1_COMPONENT_STORE_SRC;
         comp2 = BRW_VE1_COMPONENT_STORE_VID;
      }

      if (brw->vs.prog_data->uses_instanceid) {
         comp3 = BRW_VE1_COMPONENT_STORE_IID;
      }
d779 4
a782 4
      dw1 = (comp0 << BRW_VE1_COMPONENT_0_SHIFT) |
            (comp1 << BRW_VE1_COMPONENT_1_SHIFT) |
            (comp2 << BRW_VE1_COMPONENT_2_SHIFT) |
            (comp3 << BRW_VE1_COMPONENT_3_SHIFT);
d785 1
a785 3
         dw0 |= GEN6_VE0_VALID |
                brw->vb.nr_buffers << GEN6_VE0_INDEX_SHIFT |
                BRW_SURFACEFORMAT_R32_UINT << BRW_VE0_FORMAT_SHIFT;
d787 1
a787 3
         dw0 |= BRW_VE0_VALID |
                brw->vb.nr_buffers << BRW_VE0_INDEX_SHIFT |
                BRW_SURFACEFORMAT_R32_UINT << BRW_VE0_FORMAT_SHIFT;
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d245 1
a245 1
      default: assert(0); return 0;
d297 1
a297 1
      default: assert(0); return 0;
d342 1
a342 1
      default: assert(0); return 0;
d354 1
a354 1
   default: assert(0); return 0;
d505 1
a505 4
	  * GTT.  We would hope that the VBO's max_index would save us, but
	  * Mesa appears to hand us min/max values not clipped to the
	  * array object's _MaxElement, and _MaxElement frequently appears
	  * to be wrong anyway.
d604 55
d661 1
a661 2
   struct gl_context *ctx = &brw->ctx;
   GLuint i, nr_elements;
d664 1
d668 3
a670 1
   nr_elements = brw->vb.nr_enabled + brw->vs.prog_data->uses_vertexid;
d704 4
a707 1
   if (brw->vb.nr_buffers) {
d709 1
a709 1
	 assert(brw->vb.nr_buffers <= 33);
d711 1
a711 1
	 assert(brw->vb.nr_buffers <= 17);
d714 2
a715 2
      BEGIN_BATCH(1 + 4*brw->vb.nr_buffers);
      OUT_BATCH((_3DSTATE_VERTEX_BUFFERS << 16) | (4*brw->vb.nr_buffers - 1));
d718 3
a720 1
	 uint32_t dw0;
d722 1
a722 11
	 if (brw->gen >= 6) {
	    dw0 = buffer->step_rate
	             ? GEN6_VB0_ACCESS_INSTANCEDATA
	             : GEN6_VB0_ACCESS_VERTEXDATA;
	    dw0 |= i << GEN6_VB0_INDEX_SHIFT;
	 } else {
	    dw0 = buffer->step_rate
	             ? BRW_VB0_ACCESS_INSTANCEDATA
	             : BRW_VB0_ACCESS_VERTEXDATA;
	    dw0 |= i << BRW_VB0_INDEX_SHIFT;
	 }
d724 7
a730 16
	 if (brw->gen >= 7)
	    dw0 |= GEN7_VB0_ADDRESS_MODIFYENABLE;

         if (brw->gen == 7)
	    dw0 |= GEN7_MOCS_L3 << 16;

         WARN_ONCE(buffer->stride >= (brw->gen >= 5 ? 2048 : 2047),
                   "VBO stride %d too large, bad rendering may occur\n",
                   buffer->stride);
	 OUT_BATCH(dw0 | (buffer->stride << BRW_VB0_PITCH_SHIFT));
	 OUT_RELOC(buffer->bo, I915_GEM_DOMAIN_VERTEX, 0, buffer->offset);
	 if (brw->gen >= 5) {
	    OUT_RELOC(buffer->bo, I915_GEM_DOMAIN_VERTEX, 0, buffer->bo->size - 1);
	 } else
	    OUT_BATCH(0);
	 OUT_BATCH(buffer->step_rate);
d816 1
a816 1
   if (brw->vs.prog_data->uses_vertexid) {
d818 13
d832 4
a835 4
      dw1 = ((BRW_VE1_COMPONENT_STORE_VID << BRW_VE1_COMPONENT_0_SHIFT) |
	     (BRW_VE1_COMPONENT_STORE_IID << BRW_VE1_COMPONENT_1_SHIFT) |
	     (BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_2_SHIFT) |
	     (BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_3_SHIFT));
d838 3
a840 1
	 dw0 |= GEN6_VE0_VALID;
d842 3
a844 1
	 dw0 |= BRW_VE0_VALID;
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d2 2
a3 2
 * 
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d5 1
a5 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
 * 
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d25 1
a25 1
 * 
d225 3
a227 3
static unsigned
get_surface_type(struct brw_context *brw,
                 const struct gl_client_array *glarray)
d232 3
a234 3
      printf("type %s size %d normalized %d\n", 
             _mesa_lookup_enum_by_nr(glarray->Type),
             glarray->Size, glarray->Normalized);
d247 2
d347 2
a348 1
static GLuint get_index_type(GLenum type)
d384 2
d388 1
a388 2
      intel_upload_data(brw, src, size, dst_stride,
			&buffer->bo, &buffer->offset);
a389 3
      char * const map = intel_upload_map(brw, size, dst_stride);
      char *dst = map;

a394 2
      intel_upload_unmap(brw, map, size, dst_stride,
			 &buffer->bo, &buffer->offset);
d399 2
a400 1
static void brw_prepare_vertices(struct brw_context *brw)
d427 1
a427 1
      printf("%s %d..%d\n", __FUNCTION__, min_index, max_index);
d474 1
a474 5
            buffer->bo = intel_bufferobj_source(brw,
                                                intel_buffer, 1,
						&buffer->offset);
	    drm_intel_bo_reference(buffer->bo);
	    buffer->offset += (uintptr_t)glarray->Ptr;
d478 20
d609 1
d643 1
a643 1
      CACHED_BATCH();
d678 1
a678 1
	 if (brw->is_haswell)
d681 3
d710 1
a710 1
      uint32_t format = get_surface_type(brw, input->glarray);
d716 1
a716 7
      /* The gen4 driver expects edgeflag to come in as a float, and passes
       * that float on to the tests in the clipper.  Mesa's current vertex
       * attribute value for EdgeFlag is stored as a float, which works out.
       * glEdgeFlagPointer, on the other hand, gives us an unnormalized
       * integer ubyte.  Just rewrite that to convert to a float.
       */
      if (input->attrib == VERT_ATTRIB_EDGEFLAG) {
a724 3

         if (format == BRW_SURFACEFORMAT_R8_UINT)
            format = BRW_SURFACEFORMAT_R8_SSCALED;
d762 2
a763 1
      uint32_t format = get_surface_type(brw, gen6_edgeflag_input->glarray);
d799 1
a799 1
   CACHED_BATCH();
d816 1
a816 1
   drm_intel_bo *bo = NULL;
a830 1

d834 1
a834 2
			&bo, &offset);
      brw->ib.start_vertex_offset = offset / ib_type_size;
d841 13
a853 34
       if ((ib_type_size - 1) & offset) {
          perf_debug("copying index buffer to a temporary to work around "
                     "misaligned offset %d\n", offset);

          GLubyte *map = ctx->Driver.MapBufferRange(ctx,
                                                    offset,
                                                    ib_size,
                                                    GL_MAP_READ_BIT,
                                                    bufferobj);

          intel_upload_data(brw, map, ib_size, ib_type_size, &bo, &offset);
          brw->ib.start_vertex_offset = offset / ib_type_size;

          ctx->Driver.UnmapBuffer(ctx, bufferobj);
       } else {
	  /* Use CMD_3D_PRIM's start_vertex_offset to avoid re-uploading
	   * the index buffer state when we're just moving the start index
	   * of our drawing.
	   */
	  brw->ib.start_vertex_offset = offset / ib_type_size;

	  bo = intel_bufferobj_source(brw,
				      intel_buffer_object(bufferobj),
				      ib_type_size,
				      &offset);
	  drm_intel_bo_reference(bo);

	  brw->ib.start_vertex_offset += offset / ib_type_size;
       }
   }

   if (brw->ib.bo != bo) {
      drm_intel_bo_unreference(brw->ib.bo);
      brw->ib.bo = bo;
d855 20
a875 3
   } else {
      drm_intel_bo_unreference(bo);
   }
d909 1
a909 1
             get_index_type(index_buffer->type) << 8 |
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a27 2
#undef NDEBUG

d32 2
d67 16
d99 8
d123 8
d147 8
d171 8
d195 8
d225 3
a227 2
static GLuint get_surface_type( GLenum type, GLuint size,
                                GLenum format, GLboolean normalized )
d229 2
d233 2
a234 1
		   _mesa_lookup_enum_by_nr(type), size, normalized);
d236 13
a248 2
   if (normalized) {
      switch (type) {
d258 1
a258 1
         if (format == GL_BGRA) {
d266 29
d296 1
a296 1
      }      
d299 24
a322 2
      assert(format == GL_RGBA); /* sanity check */
      switch (type) {
d332 8
a339 4
      /* This produces GL_FIXED inputs as values between INT32_MIN and
       * INT32_MAX, which will be scaled down by 1/65536 by the VS.
       */
      case GL_FIXED: return int_types_scale[size];
a344 18

static GLuint get_size( GLenum type )
{
   switch (type) {
   case GL_DOUBLE: return sizeof(GLdouble);
   case GL_FLOAT: return sizeof(GLfloat);
   case GL_HALF_FLOAT: return sizeof(GLhalfARB);
   case GL_INT: return sizeof(GLint);
   case GL_SHORT: return sizeof(GLshort);
   case GL_BYTE: return sizeof(GLbyte);
   case GL_UNSIGNED_INT: return sizeof(GLuint);
   case GL_UNSIGNED_SHORT: return sizeof(GLushort);
   case GL_UNSIGNED_BYTE: return sizeof(GLubyte);
   case GL_FIXED: return sizeof(GLuint);
   default: assert(0); return 0;
   }
}

d362 16
a377 1
   int src_stride = element->glarray->StrideB;
d383 1
a383 1
      intel_upload_data(&brw->intel, src, size, dst_stride,
d386 1
a386 1
      char * const map = intel_upload_map(&brw->intel, size, dst_stride);
d394 1
a394 1
      intel_upload_unmap(&brw->intel, map, size, dst_stride,
d402 1
a402 2
   struct gl_context *ctx = &brw->intel.ctx;
   struct intel_context *intel = intel_context(ctx);
d404 1
a404 1
   GLbitfield vs_inputs = brw->vs.prog_data->inputs_read;
d406 3
a408 3
   GLuint interleaved = 0, total_size = 0;
   unsigned int min_index = brw->vb.min_index;
   unsigned int max_index = brw->vb.max_index;
d414 6
a419 1
   /* First build an array of pointers to ve's in vb.inputs_read
d421 5
d432 1
a432 1
      GLuint i = ffs(vs_inputs) - 1;
d435 2
a436 3
      vs_inputs &= ~(1 << i);
      if (input->glarray->Size && get_size(input->glarray->Type))
         brw->vb.enabled[brw->vb.nr_enabled++] = input;
a442 10
      goto validate;

   /* XXX: In the rare cases where this happens we fallback all
    * the way to software rasterization, although a tnl fallback
    * would be sufficient.  I don't know of *any* real world
    * cases with > 17 vertex attributes enabled, so it probably
    * isn't an issue at this point.
    */
   if (brw->vb.nr_enabled >= BRW_VEP_MAX) {
      intel->Fallback = GL_TRUE; /* boolean, not bitfield */
a443 1
   }
a447 3
      int type_size = get_size(glarray->Type);

      input->element_size = type_size * glarray->Size;
d454 4
d462 1
d474 2
a475 2
            buffer->bo = intel_bufferobj_source(intel,
                                                intel_buffer, type_size,
d480 1
a503 7
	    /* Position array not properly enabled:
	     */
	    if (input->attrib == VERT_ATTRIB_POS && glarray->StrideB == 0) {
               intel->Fallback = GL_TRUE; /* boolean, not bitfield */
               return;
            }

d508 2
a509 1
		  (uintptr_t)(glarray->Ptr - ptr) > interleaved)
d511 15
a525 5
	    interleaved = 0;
	 }
	 else if ((uintptr_t)(glarray->Ptr - ptr) & (type_size -1))
	 {
	    /* enforce natural alignment (for doubles) */
a529 2
	 total_size = ALIGN(total_size, type_size);
	 total_size += input->element_size;
a542 2
   if (delta && !brw->intel.intelScreen->relaxed_relocations)
      min_index = delta = 0;
d546 1
a546 1
      if (interleaved && interleaved <= 2*total_size) {
a564 39
      else if (total_size < 2048) {
	 /* Upload non-interleaved arrays into a single interleaved array */
	 struct brw_vertex_buffer *buffer;
	 int count = max_index - min_index + 1;
	 int offset;
	 char *map;

	 map = intel_upload_map(&brw->intel, total_size * count, total_size);
	 for (i = offset = 0; i < nr_uploads; i++) {
	    const unsigned char *src = upload[i]->glarray->Ptr;
	    int size = upload[i]->element_size;
	    int stride = upload[i]->glarray->StrideB;
	    char *dst;
	    int n;

	    offset = ALIGN(offset, get_size(upload[i]->glarray->Type));
	    dst = map + offset;
	    src += min_index * stride;

	    for (n = 0; n < count; n++) {
	       memcpy(dst, src, size);
	       src += stride;
	       dst += total_size;
	    }

	    upload[i]->offset = offset;
	    upload[i]->buffer = j;

	    offset += size;
	 }
	 assert(offset == total_size);
	 buffer = &brw->vb.buffers[j++];
	 intel_upload_unmap(&brw->intel, map, offset * count, offset,
			    &buffer->bo, &buffer->offset);
	 buffer->stride = offset;
	 buffer->offset -= delta * offset;

	 nr_uploads = 0;
      }
d569 13
a581 2
      copy_array_to_vbo_array(brw, upload[i], min_index, max_index,
			      buffer, upload[i]->element_size);
d583 1
a587 27
   /* can we simply extend the current vb? */
   if (j == brw->vb.nr_current_buffers) {
      int delta = 0;
      for (i = 0; i < j; i++) {
	 int d;

	 if (brw->vb.current_buffers[i].handle != brw->vb.buffers[i].bo->handle ||
	     brw->vb.current_buffers[i].stride != brw->vb.buffers[i].stride)
	    break;

	 d = brw->vb.buffers[i].offset - brw->vb.current_buffers[i].offset;
	 if (d < 0)
	    break;
	 if (i == 0)
	    delta = d / brw->vb.current_buffers[i].stride;
	 if (delta * brw->vb.current_buffers[i].stride != d)
	    break;
      }

      if (i == j) {
	 brw->vb.start_vertex_bias += delta;
	 while (--j >= 0)
	    drm_intel_bo_unreference(brw->vb.buffers[j].bo);
	 j = 0;
      }
   }

a588 6

validate:
   brw_prepare_query_begin(brw);
   for (i = 0; i < brw->vb.nr_buffers; i++) {
      brw_add_validated_bo(brw, brw->vb.buffers[i].bo);
   }
d593 3
a595 3
   struct gl_context *ctx = &brw->intel.ctx;
   struct intel_context *intel = intel_context(ctx);
   GLuint i;
d599 2
d608 1
a608 1
   if (brw->vb.nr_enabled == 0) {
d610 2
a611 2
      OUT_BATCH((CMD_VERTEX_ELEMENT << 16) | 1);
      if (intel->gen >= 6) {
d634 6
d641 1
a641 1
      OUT_BATCH((CMD_VERTEX_BUFFER << 16) | (4*brw->vb.nr_buffers - 1));
d646 5
a650 2
	 if (intel->gen >= 6) {
	    dw0 = GEN6_VB0_ACCESS_VERTEXDATA | (i << GEN6_VB0_INDEX_SHIFT);
d652 4
a655 1
	    dw0 = BRW_VB0_ACCESS_VERTEXDATA | (i << BRW_VB0_INDEX_SHIFT);
d658 1
a658 1
	 if (intel->gen >= 7)
d661 3
d666 1
a666 1
	 if (intel->gen >= 5) {
d670 1
a670 5
	 OUT_BATCH(0); /* Instance data step rate */

	 brw->vb.current_buffers[i].handle = buffer->bo->handle;
	 brw->vb.current_buffers[i].offset = buffer->offset;
	 brw->vb.current_buffers[i].stride = buffer->stride;
a671 1
      brw->vb.nr_current_buffers = i;
d675 13
a687 2
   BEGIN_BATCH(1 + brw->vb.nr_enabled * 2);
   OUT_BATCH((CMD_VERTEX_ELEMENT << 16) | (2*brw->vb.nr_enabled - 1));
d690 1
a690 4
      uint32_t format = get_surface_type(input->glarray->Type,
					 input->glarray->Size,
					 input->glarray->Format,
					 input->glarray->Normalized);
d696 20
d720 2
a721 1
      case 3: comp3 = BRW_VE1_COMPONENT_STORE_1_FLT;
d725 1
a725 1
      if (intel->gen >= 6) {
d737 1
a737 1
      if (intel->gen >= 5)
d749 38
d792 1
a792 1
      .mesa = 0,
a795 1
   .prepare = brw_prepare_vertices,
d799 1
a799 1
static void brw_prepare_indices(struct brw_context *brw)
d801 1
a801 2
   struct gl_context *ctx = &brw->intel.ctx;
   struct intel_context *intel = &brw->intel;
d812 1
a812 1
   ib_type_size = get_size(index_buffer->type);
d822 1
a822 1
      intel_upload_data(&brw->intel, index_buffer->ptr, ib_size, ib_type_size,
d831 12
a842 10
       if ((get_size(index_buffer->type) - 1) & offset) {
           GLubyte *map = ctx->Driver.MapBuffer(ctx,
                                                GL_ELEMENT_ARRAY_BUFFER_ARB,
                                                GL_DYNAMIC_DRAW_ARB,
                                                bufferobj);
           map += offset;

	   intel_upload_data(&brw->intel, map, ib_size, ib_type_size,
			     &bo, &offset);
	   brw->ib.start_vertex_offset = offset / ib_type_size;
d844 1
a844 1
           ctx->Driver.UnmapBuffer(ctx, GL_ELEMENT_ARRAY_BUFFER_ARB, bufferobj);
d852 1
a852 1
	  bo = intel_bufferobj_source(intel,
a865 1
      brw_add_validated_bo(brw, brw->ib.bo);
d883 1
a883 1
   .prepare = brw_prepare_indices,
a887 1
   struct intel_context *intel = &brw->intel;
d889 1
d894 6
d902 1
a902 1
             /* cut index enable << 10 */
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d28 1
d210 4
d215 1
a215 1
      }      
d232 3
a234 2
   default: return 0;
   }      
d237 1
a237 1
static GLuint get_index_type(GLenum type) 
a246 33
static void wrap_buffers( struct brw_context *brw,
			  GLuint size )
{
   if (size < BRW_UPLOAD_INIT_SIZE)
      size = BRW_UPLOAD_INIT_SIZE;

   brw->vb.upload.offset = 0;

   if (brw->vb.upload.bo != NULL)
      drm_intel_bo_unreference(brw->vb.upload.bo);
   brw->vb.upload.bo = drm_intel_bo_alloc(brw->intel.bufmgr, "temporary VBO",
					  size, 1);
}

static void get_space( struct brw_context *brw,
		       GLuint size,
		       drm_intel_bo **bo_return,
		       GLuint *offset_return )
{
   size = ALIGN(size, 64);

   if (brw->vb.upload.bo == NULL ||
       brw->vb.upload.offset + size > brw->vb.upload.bo->size) {
      wrap_buffers(brw, size);
   }

   assert(*bo_return == NULL);
   drm_intel_bo_reference(brw->vb.upload.bo);
   *bo_return = brw->vb.upload.bo;
   *offset_return = brw->vb.upload.offset;
   brw->vb.upload.offset += size;
}

d248 5
a252 3
copy_array_to_vbo_array( struct brw_context *brw,
			 struct brw_vertex_element *element,
			 GLuint dst_stride)
d254 8
a261 7
   GLuint size = element->count * dst_stride;

   get_space(brw, size, &element->bo, &element->offset);

   if (element->glarray->StrideB == 0) {
      assert(element->count == 1);
      element->stride = 0;
d263 2
a264 16
      element->stride = dst_stride;
   }

   if (dst_stride == element->glarray->StrideB) {
      drm_intel_gem_bo_map_gtt(element->bo);
      memcpy((char *)element->bo->virtual + element->offset,
	     element->glarray->Ptr, size);
      drm_intel_gem_bo_unmap_gtt(element->bo);
   } else {
      char *dest;
      const unsigned char *src = element->glarray->Ptr;
      int i;

      drm_intel_gem_bo_map_gtt(element->bo);
      dest = element->bo->virtual;
      dest += element->offset;
d266 4
a269 4
      for (i = 0; i < element->count; i++) {
	 memcpy(dest, src, dst_stride);
	 src += element->glarray->StrideB;
	 dest += dst_stride;
d271 2
a272 2

      drm_intel_gem_bo_unmap_gtt(element->bo);
d274 1
d281 2
a282 2
   GLbitfield vs_inputs = brw->vs.prog_data->inputs_read; 
   GLuint i;
d284 1
a284 1
   GLuint interleave = 0;
d287 1
d300 1
a300 1
      GLuint i = _mesa_ffsll(vs_inputs) - 1;
d304 2
a305 1
      brw->vb.enabled[brw->vb.nr_enabled++] = input;
d308 6
d325 1
a325 1
   for (i = 0; i < brw->vb.nr_enabled; i++) {
d327 2
d330 1
a330 1
      input->element_size = get_size(input->glarray->Type) * input->glarray->Size;
d332 1
a332 1
      if (_mesa_is_bufferobj(input->glarray->BufferObj)) {
d334 2
a335 1
	    intel_buffer_object(input->glarray->BufferObj);
d337 25
a361 8
	 /* Named buffer object: Just reference its contents directly. */
	 drm_intel_bo_unreference(input->bo);
	 input->bo = intel_bufferobj_buffer(intel, intel_buffer,
					    INTEL_READ);
	 drm_intel_bo_reference(input->bo);
	 input->offset = (unsigned long)input->glarray->Ptr;
	 input->stride = input->glarray->StrideB;
	 input->count = input->glarray->_MaxElement;
d375 1
a375 1
	 assert(input->offset < input->bo->size);
a376 9
	 input->count = input->glarray->StrideB ? max_index + 1 : 1;
	 if (input->bo != NULL) {
	    /* Already-uploaded vertex data is present from a previous
	     * prepare_vertices, but we had to re-validate state due to
	     * check_aperture failing and a new batch being produced.
	     */
	    continue;
	 }

d380 1
a380 1
	 if (input->attrib == VERT_ATTRIB_POS) {
d383 1
a383 1
            if (input->glarray->StrideB == 0) {
d388 7
a394 2
	    interleave = input->glarray->StrideB;
	    ptr = input->glarray->Ptr;
d396 1
a396 3
	 else if (interleave != input->glarray->StrideB ||
		  (const unsigned char *)input->glarray->Ptr - ptr < 0 ||
		  (const unsigned char *)input->glarray->Ptr - ptr > interleave)
d398 2
a399 1
	    interleave = 0;
d403 2
d408 13
d422 56
a477 5
   if (nr_uploads > 1 && interleave && interleave <= 256) {
      /* All uploads are interleaved, so upload the arrays together as
       * interleaved.  First, upload the contents and set up upload[0].
       */
      copy_array_to_vbo_array(brw, upload[0], interleave);
d479 1
a479 7
      for (i = 1; i < nr_uploads; i++) {
	 /* Then, just point upload[i] at upload[0]'s buffer. */
	 upload[i]->stride = interleave;
	 upload[i]->offset = upload[0]->offset +
	    ((const unsigned char *)upload[i]->glarray->Ptr - ptr);
	 upload[i]->bo = upload[0]->bo;
	 drm_intel_bo_reference(upload[i]->bo);
d482 34
a515 4
   else {
      /* Upload non-interleaved arrays */
      for (i = 0; i < nr_uploads; i++) {
          copy_array_to_vbo_array(brw, upload[i], upload[i]->element_size);
d519 3
d523 2
a524 5

   for (i = 0; i < brw->vb.nr_enabled; i++) {
      struct brw_vertex_element *input = brw->vb.enabled[i];

      brw_add_validated_bo(brw, input->bo);
d561 1
a561 1
      ADVANCE_BATCH();
a565 4
    *
    * This still defines a hardware VB for each input, even if they
    * are interleaved or from the same VBO.  TBD if this makes a
    * performance difference.
a566 3
   BEGIN_BATCH(1 + brw->vb.nr_enabled * 4);
   OUT_BATCH((CMD_VERTEX_BUFFER << 16) |
	     ((1 + brw->vb.nr_enabled * 4) - 2));
d568 15
a582 3
   for (i = 0; i < brw->vb.nr_enabled; i++) {
      struct brw_vertex_element *input = brw->vb.enabled[i];
      uint32_t dw0;
d584 11
a594 6
      if (intel->gen >= 6) {
	 dw0 = GEN6_VB0_ACCESS_VERTEXDATA |
	    (i << GEN6_VB0_INDEX_SHIFT);
      } else {
	 dw0 = BRW_VB0_ACCESS_VERTEXDATA |
	    (i << BRW_VB0_INDEX_SHIFT);
d596 2
a597 13

      OUT_BATCH(dw0 |
		(input->stride << BRW_VB0_PITCH_SHIFT));
      OUT_RELOC(input->bo,
		I915_GEM_DOMAIN_VERTEX, 0,
		input->offset);
      if (intel->gen >= 5) {
	 OUT_RELOC(input->bo,
		   I915_GEM_DOMAIN_VERTEX, 0,
		   input->bo->size - 1);
      } else
          OUT_BATCH(input->stride ? input->count : 0);
      OUT_BATCH(0); /* Instance data step rate */
a598 1
   ADVANCE_BATCH();
d601 1
a601 1
   OUT_BATCH((CMD_VERTEX_ELEMENT << 16) | ((1 + brw->vb.nr_enabled * 2) - 2));
d622 1
a622 1
	 OUT_BATCH((i << GEN6_VE0_INDEX_SHIFT) |
d625 1
a625 1
		   (0 << BRW_VE0_SRC_OFFSET_SHIFT));
d627 1
a627 1
	 OUT_BATCH((i << BRW_VE0_INDEX_SHIFT) |
d630 1
a630 1
		   (0 << BRW_VE0_SRC_OFFSET_SHIFT));
d645 1
a645 1
   ADVANCE_BATCH();
d652 1
a652 1
      .cache = 0,
d674 1
a674 1
   bufferobj = index_buffer->obj;;
a678 1
      brw->ib.start_vertex_offset = 0;
d682 3
a684 7
      get_space(brw, ib_size, &bo, &offset);

      /* Straight upload
       */
      drm_intel_gem_bo_map_gtt(bo);
      memcpy((char *)bo->virtual + offset, index_buffer->ptr, ib_size);
      drm_intel_gem_bo_unmap_gtt(bo);
a686 1
      brw->ib.start_vertex_offset = 0;
d698 3
a700 3
	   get_space(brw, ib_size, &bo, &offset);

	   drm_intel_bo_subdata(bo, offset, ib_size, map);
a703 4
	  bo = intel_bufferobj_buffer(intel, intel_buffer_object(bufferobj),
				      INTEL_READ);
	  drm_intel_bo_reference(bo);

d709 8
a716 2
	  offset = 0;
	  ib_size = bo->size;
d720 1
a720 4
   if (brw->ib.bo != bo ||
       brw->ib.offset != offset ||
       brw->ib.size != ib_size)
   {
a722 2
      brw->ib.offset = offset;
      brw->ib.size = ib_size;
d724 1
d730 4
a733 1
   brw_add_validated_bo(brw, brw->ib.bo);
d753 12
a764 23
   /* Emit the indexbuffer packet:
    */
   {
      struct brw_indexbuffer ib;

      memset(&ib, 0, sizeof(ib));

      ib.header.bits.opcode = CMD_INDEX_BUFFER;
      ib.header.bits.length = sizeof(ib)/4 - 2;
      ib.header.bits.index_format = get_index_type(index_buffer->type);
      ib.header.bits.cut_index_enable = 0;

      BEGIN_BATCH(4);
      OUT_BATCH( ib.header.dword );
      OUT_RELOC(brw->ib.bo,
		I915_GEM_DOMAIN_VERTEX, 0,
		brw->ib.offset);
      OUT_RELOC(brw->ib.bo,
		I915_GEM_DOMAIN_VERTEX, 0,
		brw->ib.offset + brw->ib.size - 1);
      OUT_BATCH( 0 );
      ADVANCE_BATCH();
   }
@


1.5
log
@Update to Mesa 7.8.2. Tested by johan@@. Thanks.
@
text
@d171 1
a171 1
   if (INTEL_DEBUG & DEBUG_VERTS)
d250 3
a252 3
      dri_bo_unreference(brw->vb.upload.bo);
   brw->vb.upload.bo = dri_bo_alloc(brw->intel.bufmgr, "temporary VBO",
				    size, 1);
d257 1
a257 1
		       dri_bo **bo_return,
d268 1
a268 1
   dri_bo_reference(brw->vb.upload.bo);
d316 1
a316 1
   GLcontext *ctx = &brw->intel.ctx;
d364 1
a364 1
	 dri_bo_unreference(input->bo);
d367 1
a367 1
	 dri_bo_reference(input->bo);
d386 1
a386 1
	 input->count = input->glarray->StrideB ? max_index + 1 - min_index : 1;
a416 9
	 
	 /* We rebase drawing to start at element zero only when
	  * varyings are not in vbos, which means we can end up
	  * uploading non-varying arrays (stride != 0) when min_index
	  * is zero.  This doesn't matter as the amount to upload is
	  * the same for these arrays whether the draw call is rebased
	  * or not - we just have to upload the one element.
	  */
	 assert(min_index == 0 || input->glarray->StrideB == 0);
d433 1
a433 1
	 dri_bo_reference(upload[i]->bo);
d454 1
a454 1
   GLcontext *ctx = &brw->intel.ctx;
d470 1
a470 1
      if (IS_GEN6(intel->intelScreen->deviceID)) {
d547 1
a547 1
      if (IS_GEN6(intel->intelScreen->deviceID)) {
d586 1
a586 1
   GLcontext *ctx = &brw->intel.ctx;
d590 1
a590 1
   dri_bo *bo = NULL;
d632 1
a632 1
	   dri_bo_subdata(bo, offset, ib_size, map);
d638 1
a638 1
	  dri_bo_reference(bo);
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d62 1
a62 1
   0, /* can't seem to render this one */
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a27 1
#include <stdlib.h>
d30 1
a31 2
#include "main/state.h"
#include "main/api_validate.h"
a37 1
#include "brw_fallback.h"
a40 1
#include "intel_tex.h"
d58 8
d163 7
a169 1
static GLuint get_surface_type( GLenum type, GLuint size, GLboolean normalized )
d172 1
a172 1
      _mesa_printf("type %s size %d normalized %d\n", 
d179 1
d185 9
a193 1
      case GL_UNSIGNED_BYTE: return ubyte_types_norm[size];
d198 1
d202 1
d220 1
a252 8

   /* Set the internal VBO\ to no-backing-store.  We only use them as a
    * temporary within a brw_try_draw_prims while the lock is held.
    */
   /* DON'T DO THIS AS IF WE HAVE TO RE-ORG MEMORY WE NEED SOMEWHERE WITH
      FAKE TO PUSH THIS STUFF */
//   if (!brw->intel.ttm)
//      dri_bo_fake_disable_backing_store(brw->vb.upload.bo, NULL, NULL);
d291 4
a294 4
      dri_bo_subdata(element->bo,
		     element->offset,
		     size,
		     element->glarray->Ptr);
a295 1
      void *data;
d297 1
a297 1
      const char *src = element->glarray->Ptr;
d300 4
a303 2
      data = _mesa_malloc(dst_stride * element->count);
      dest = data;
d310 1
a310 5
      dri_bo_subdata(element->bo,
		     element->offset,
		     size,
		     data);
      _mesa_free(data);
d318 1
a318 1
   GLuint tmp = brw->vs.prog_data->inputs_read; 
a324 3
   struct brw_vertex_element *enabled[VERT_ATTRIB_MAX];
   GLuint nr_enabled = 0;

d331 1
a331 1
      _mesa_printf("%s %d..%d\n", __FUNCTION__, min_index, max_index);
d334 3
a336 2
   while (tmp) {
      GLuint i = _mesa_ffsll(tmp)-1;
d339 2
a340 2
      tmp &= ~(1<<i);
      enabled[nr_enabled++] = input;
d349 2
a350 2
   if (nr_enabled >= BRW_VEP_MAX) {
      intel->Fallback = 1;
d354 2
a355 2
   for (i = 0; i < nr_enabled; i++) {
      struct brw_vertex_element *input = enabled[i];
a357 1
      input->count = input->glarray->StrideB ? max_index + 1 - min_index : 1;
d359 1
a359 1
      if (input->glarray->BufferObj->Name != 0) {
d370 15
d386 1
d398 1
a398 1
	 if (i == 0) {
d402 1
a402 1
               intel->Fallback = 1;
d454 2
a455 2
   for (i = 0; i < nr_enabled; i++) {
      struct brw_vertex_element *input = enabled[i];
a464 2
   GLuint tmp = brw->vs.prog_data->inputs_read;
   struct brw_vertex_element *enabled[VERT_ATTRIB_MAX];
a465 1
   GLuint nr_enabled = 0;
d467 1
a467 4
  /* Accumulate the list of enabled arrays. */
   while (tmp) {
      i = _mesa_ffsll(tmp)-1;
      struct brw_vertex_element *input = &brw->vb.inputs[i];
d469 27
a495 2
      tmp &= ~(1<<i);
      enabled[nr_enabled++] = input;
a497 2
   brw_emit_query_begin(brw);

d504 1
a504 1
   BEGIN_BATCH(1 + nr_enabled * 4, IGNORE_CLIPRECTS);
d506 1
a506 1
	     ((1 + nr_enabled * 4) - 2));
d508 11
a518 2
   for (i = 0; i < nr_enabled; i++) {
      struct brw_vertex_element *input = enabled[i];
d520 1
a520 2
      OUT_BATCH((i << BRW_VB0_INDEX_SHIFT) |
		BRW_VB0_ACCESS_VERTEXDATA |
d525 6
a530 1
      OUT_BATCH(brw->vb.max_index);
d535 4
a538 4
   BEGIN_BATCH(1 + nr_enabled * 2, IGNORE_CLIPRECTS);
   OUT_BATCH((CMD_VERTEX_ELEMENT << 16) | ((1 + nr_enabled * 2) - 2));
   for (i = 0; i < nr_enabled; i++) {
      struct brw_vertex_element *input = enabled[i];
d541 1
d556 23
a578 9
      OUT_BATCH((i << BRW_VE0_INDEX_SHIFT) |
		BRW_VE0_VALID |
		(format << BRW_VE0_FORMAT_SHIFT) |
		(0 << BRW_VE0_SRC_OFFSET_SHIFT));
      OUT_BATCH((comp0 << BRW_VE1_COMPONENT_0_SHIFT) |
		(comp1 << BRW_VE1_COMPONENT_1_SHIFT) |
		(comp2 << BRW_VE1_COMPONENT_2_SHIFT) |
		(comp3 << BRW_VE1_COMPONENT_3_SHIFT) |
		((i * 4) << BRW_VE1_DST_OFFSET_SHIFT));
d602 1
d607 2
a608 1
   ib_size = get_size(index_buffer->type) * index_buffer->count;
d613 3
a615 2
   if (!bufferobj->Name) {
     
d622 3
a624 1
      dri_bo_subdata(bo, offset, ib_size, index_buffer->ptr);
d626 2
a627 1
      offset = (GLuint)index_buffer->ptr;
d648 8
d659 13
a671 3
   dri_bo_unreference(brw->ib.bo);
   brw->ib.bo = bo;
   brw->ib.offset = offset;
d676 10
a685 1
static void brw_emit_indices(struct brw_context *brw)
a688 1
   GLuint ib_size;
a692 2
   ib_size = get_size(index_buffer->type) * index_buffer->count;

d699 1
a699 1
   
a703 1
   
d705 1
a705 1
      BEGIN_BATCH(4, IGNORE_CLIPRECTS);
d712 1
a712 1
		brw->ib.offset + ib_size);
d718 1
a718 1
const struct brw_tracked_state brw_indices = {
d721 1
a721 1
      .brw = BRW_NEW_BATCH | BRW_NEW_INDICES,
d724 1
a724 2
   .prepare = brw_prepare_indices,
   .emit = brw_emit_indices,
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d30 5
a34 5
#include "glheader.h"
#include "context.h"
#include "state.h"
#include "api_validate.h"
#include "enums.h"
a41 1
#include "intel_ioctl.h"
d230 1
a230 4
				    size, 1,
				    DRM_BO_FLAG_MEM_LOCAL |
				    DRM_BO_FLAG_CACHED |
				    DRM_BO_FLAG_CACHED_MAPPED);
d253 1
a256 1

d303 1
a303 3
int brw_prepare_vertices( struct brw_context *brw,
			       GLuint min_index,
			       GLuint max_index )
d311 2
a312 1
   int ret = 0;
d340 4
a343 2
   if (nr_enabled >= BRW_VEP_MAX)
       return -1;
d356 1
d362 8
a370 2
	 ret |= dri_bufmgr_check_aperture_space(input->bo);
      } else {
d377 4
a380 2
	    if (input->glarray->StrideB == 0)
	      return -1;
a411 1
      ret |= dri_bufmgr_check_aperture_space(upload[0]->bo);
a424 3
          if (upload[i]->bo) {
              ret |= dri_bufmgr_check_aperture_space(upload[i]->bo);
          }
d428 1
d430 2
a431 2
   if (ret)
     return 1;
d433 2
a434 2

   return 0;
d437 1
a437 3
void brw_emit_vertices( struct brw_context *brw,
                        GLuint min_index,
                        GLuint max_index )
d455 1
d474 1
a474 1
		DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_READ,
d476 1
a476 1
      OUT_BATCH(max_index);
a477 6

      /* Unreference the buffer so it can get freed, now that we won't
       * touch it any more.
       */
      dri_bo_unreference(input->bo);
      input->bo = NULL;
d514 11
a524 4
int brw_prepare_indices( struct brw_context *brw,
			 const struct _mesa_index_buffer *index_buffer,
			 dri_bo **bo_return,
			 GLuint *offset_return)
d528 11
a538 5
   GLuint ib_size = get_size(index_buffer->type) * index_buffer->count;
   dri_bo *bo;
   struct gl_buffer_object *bufferobj = index_buffer->obj;
   GLuint offset = (GLuint)index_buffer->ptr;
   int ret;
d552 2
d576 5
a580 4
   *bo_return = bo;
   *offset_return = offset;
   ret = dri_bufmgr_check_aperture_space(bo);
   return ret;
d583 1
a583 4
void brw_emit_indices(struct brw_context *brw,
                      const struct _mesa_index_buffer *index_buffer,
                      dri_bo *bo,
                      GLuint offset)
d586 8
a593 1
   GLuint ib_size = get_size(index_buffer->type) * index_buffer->count;
d609 6
a614 3
      OUT_RELOC( bo, DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_READ, offset);
      OUT_RELOC( bo, DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_READ,
		 offset + ib_size);
a616 2

      dri_bo_unreference(bo);
d620 9
@


1.1
log
@Initial revision
@
text
@a37 1
#include "brw_attrib.h"
a38 1
#include "brw_aub.h"
d45 1
a45 30


struct brw_array_state {
   union header_union header;

   struct {
      union {
	 struct {
	    GLuint pitch:11; 
	    GLuint pad:15;
	    GLuint access_type:1; 
	    GLuint vb_index:5; 
	 } bits;
	 GLuint dword;
      } vb0;
   
      struct buffer *buffer;
      GLuint offset;

      GLuint max_index;   
      GLuint instance_data_step_rate;

   } vb[BRW_VBP_MAX];
};


static struct buffer *array_buffer( const struct gl_client_array *array )
{
   return intel_bufferobj_buffer(intel_buffer_object(array->BufferObj));
}
a219 19
static void copy_strided_array( GLubyte *dest, 
				const GLubyte *src, 
				GLuint size, 
				GLuint stride,
				GLuint count )
{
   if (size == stride) 
      do_memcpy(dest, src, count * size);
   else {
      GLuint i,j;
   
      for (i = 0; i < count; i++) {
	 for (j = 0; j < size; j++)
	    *dest++ = *src++;
	 src += (stride - size);
      }
   }
}

a222 2
   GLcontext *ctx = &brw->intel.ctx;

a225 2
   brw->vb.upload.buf++;
   brw->vb.upload.buf %= BRW_NR_UPLOAD_BUFS;
d228 15
a242 6
   ctx->Driver.BufferData(ctx,
			  GL_ARRAY_BUFFER_ARB,
			  size,
			  NULL,
			  GL_DYNAMIC_DRAW_ARB,
			  brw->vb.upload.vbo[brw->vb.upload.buf]);
d247 1
a247 1
		       struct gl_buffer_object **vbo_return,
d250 4
a253 3
   size = (size + 63) & ~63;
   
   if (brw->vb.upload.offset + size > BRW_UPLOAD_INIT_SIZE)
d255 1
d257 2
a258 1
   *vbo_return = brw->vb.upload.vbo[brw->vb.upload.buf];
d264 1
a264 3


static struct gl_client_array *
d266 2
a267 5
			 GLuint i,
			 const struct gl_client_array *array,
			 GLuint element_size,
			 GLuint min_index,
			 GLuint count)
d269 1
a269 26
   GLcontext *ctx = &brw->intel.ctx;
   struct gl_client_array *vbo_array = &brw->vb.vbo_array[i];
   GLuint size = count * element_size;
   struct gl_buffer_object *vbo;
   GLuint offset;
   GLuint new_stride;

   get_space(brw, size, &vbo, &offset);

   if (array->StrideB == 0) {
      assert(count == 1);
      new_stride = 0;
   }
   else 
      new_stride = element_size;

   vbo_array->Size = array->Size;
   vbo_array->Type = array->Type;
   vbo_array->Stride = new_stride;
   vbo_array->StrideB = new_stride;   
   vbo_array->Ptr = (const void *)offset;
   vbo_array->Enabled = 1;
   vbo_array->Normalized = array->Normalized;
   vbo_array->_MaxElement = array->_MaxElement;	/* ? */
   vbo_array->Flags = array->Flags; /* ? */
   vbo_array->BufferObj = vbo;
d271 1
a271 7
   {
      GLubyte *map = ctx->Driver.MapBuffer(ctx,
					   GL_ARRAY_BUFFER_ARB,
					   GL_DYNAMIC_DRAW_ARB,
					   vbo);
   
      map += offset;
d273 25
a297 5
      copy_strided_array( map, 
			  array->Ptr + min_index * array->StrideB,
			  element_size,
			  array->StrideB,
			  count);
d299 5
a303 1
      ctx->Driver.UnmapBuffer(ctx, GL_ARRAY_BUFFER_ARB, vbo_array->BufferObj);
a304 28

   return vbo_array;
}



static struct gl_client_array *
interleaved_vbo_array( struct brw_context *brw,
		       GLuint i,
		       const struct gl_client_array *uploaded_array,
		       const struct gl_client_array *array,
		       const char *ptr)
{
   struct gl_client_array *vbo_array = &brw->vb.vbo_array[i];

   vbo_array->Size = array->Size;
   vbo_array->Type = array->Type;
   vbo_array->Stride = array->Stride;
   vbo_array->StrideB = array->StrideB;   
   vbo_array->Ptr = (const void *)((const char *)uploaded_array->Ptr + 
				   ((const char *)array->Ptr - ptr));
   vbo_array->Enabled = 1;
   vbo_array->Normalized = array->Normalized;
   vbo_array->_MaxElement = array->_MaxElement;	
   vbo_array->Flags = array->Flags; /* ? */
   vbo_array->BufferObj = uploaded_array->BufferObj;

   return vbo_array;
d307 1
a307 2

GLboolean brw_upload_vertices( struct brw_context *brw,
a313 2
   struct brw_vertex_element_packet vep;
   struct brw_array_state vbp;
d315 1
a315 1
   const void *ptr = NULL;
d317 1
d319 1
a319 1
   struct brw_vertex_element *enabled[BRW_ATTRIB_MAX];
d322 1
a322 1
   struct brw_vertex_element *upload[BRW_ATTRIB_MAX];
a323 4
   

   memset(&vbp, 0, sizeof(vbp));
   memset(&vep, 0, sizeof(vep));
d327 4
a330 1
   
d332 1
a332 1
      GLuint i = ffs(tmp)-1;
d337 13
a350 1
      input->index = i;
d352 1
a352 1
      input->count = input->glarray->StrideB ? max_index - min_index : 1;
d354 16
a369 1
      if (!input->glarray->BufferObj->Name) {
d374 1
a374 1
	       return GL_FALSE;
d380 3
a382 1
		  (const char *)input->glarray->Ptr - (const char *)ptr > interleave) {
d387 9
a395 1
	 input->vbo_rebase_offset = 0;
a396 2
      else 
	 input->vbo_rebase_offset = min_index * input->glarray->StrideB;
d399 6
a404 12
   /* Upload interleaved arrays if all uploads are interleaved
    */
   if (nr_uploads > 1 && 
       interleave && 
       interleave <= 256) {
      struct brw_vertex_element *input0 = upload[0];

      input0->glarray = copy_array_to_vbo_array(brw, 0,
						input0->glarray, 
						interleave,
						min_index,
						input0->count);
d406 1
d408 6
a413 5
	 upload[i]->glarray = interleaved_vbo_array(brw,
						    i,
						    input0->glarray,
						    upload[i]->glarray,
						    ptr);
d417 1
d419 4
a422 8
	 struct brw_vertex_element *input = upload[i];

	 input->glarray = copy_array_to_vbo_array(brw, i, 
						  input->glarray,
						  input->element_size,
						  min_index,
						  input->count);

a425 8
   /* XXX: In the rare cases where this happens we fallback all
    * the way to software rasterization, although a tnl fallback
    * would be sufficient.  I don't know of *any* real world
    * cases with > 17 vertex attributes enabled, so it probably
    * isn't an issue at this point.
    */
   if (nr_enabled >= BRW_VEP_MAX)
	 return GL_FALSE;
d427 3
a429 6
   /* This still defines a hardware VB for each input, even if they
    * are interleaved or from the same VBO.  TBD if this makes a
    * performance difference.
    */
   for (i = 0; i < nr_enabled; i++) {
      struct brw_vertex_element *input = enabled[i];
d431 2
a432 10
      input->vep = &vep.ve[i];
      input->vep->ve0.src_format = get_surface_type(input->glarray->Type, 
						    input->glarray->Size,
						    input->glarray->Normalized);
      input->vep->ve0.valid = 1;
      input->vep->ve1.dst_offset = (i) * 4;
      input->vep->ve1.vfcomponent3 = BRW_VFCOMPONENT_STORE_SRC;
      input->vep->ve1.vfcomponent2 = BRW_VFCOMPONENT_STORE_SRC;
      input->vep->ve1.vfcomponent1 = BRW_VFCOMPONENT_STORE_SRC;
      input->vep->ve1.vfcomponent0 = BRW_VFCOMPONENT_STORE_SRC;
d434 10
a443 7
      switch (input->glarray->Size) {
      case 0: input->vep->ve1.vfcomponent0 = BRW_VFCOMPONENT_STORE_0;
      case 1: input->vep->ve1.vfcomponent1 = BRW_VFCOMPONENT_STORE_0;
      case 2: input->vep->ve1.vfcomponent2 = BRW_VFCOMPONENT_STORE_0;
      case 3: input->vep->ve1.vfcomponent3 = BRW_VFCOMPONENT_STORE_1_FLT;
	 break;
      }
d445 4
a448 2
      input->vep->ve0.vertex_buffer_index = i;
      input->vep->ve0.src_offset = 0;
d450 2
a451 7
      vbp.vb[i].vb0.bits.pitch = input->glarray->StrideB;
      vbp.vb[i].vb0.bits.pad = 0;
      vbp.vb[i].vb0.bits.access_type = BRW_VERTEXBUFFER_ACCESS_VERTEXDATA;
      vbp.vb[i].vb0.bits.vb_index = i;
      vbp.vb[i].offset = (GLuint)input->glarray->Ptr + input->vbo_rebase_offset;
      vbp.vb[i].buffer = array_buffer(input->glarray);
      vbp.vb[i].max_index = max_index - min_index;
d455 5
a459 2

   /* Now emit VB and VEP state packets:
d461 3
a463 2
   vbp.header.bits.length = (1 + nr_enabled * 4) - 2;
   vbp.header.bits.opcode = CMD_VERTEX_BUFFER;
a464 3
   BEGIN_BATCH(vbp.header.bits.length+2, 0);
   OUT_BATCH( vbp.header.dword );
   
d466 16
a481 4
      OUT_BATCH( vbp.vb[i].vb0.dword );
      OUT_BATCH( bmBufferOffset(&brw->intel, vbp.vb[i].buffer) + vbp.vb[i].offset);
      OUT_BATCH( vbp.vb[i].max_index );
      OUT_BATCH( vbp.vb[i].instance_data_step_rate );
d485 11
a495 6
   vep.header.length = (1 + nr_enabled * sizeof(vep.ve[0])/4) - 2;
   vep.header.opcode = CMD_VERTEX_ELEMENT;
   brw_cached_batch_struct(brw, &vep, 4 + nr_enabled * sizeof(vep.ve[0]));

   return GL_TRUE;
}
d497 7
d505 9
a513 7
static GLuint element_size( GLenum type )
{
   switch(type) {
   case GL_UNSIGNED_INT: return 4;
   case GL_UNSIGNED_SHORT: return 2;
   case GL_UNSIGNED_BYTE: return 1;
   default: assert(0); return 0;
d515 1
d518 4
a521 7



static void rebase_indices_to_vbo_indices( struct brw_context *brw, 
					   const struct brw_draw_index_buffer *index_buffer,
					   struct gl_buffer_object **vbo_return,
					   GLuint *offset_return )
d524 6
a529 8
   GLuint min_index = index_buffer->rebase;
   const void *indices = index_buffer->ptr;
   GLsizei count = index_buffer->count;
   GLenum type = index_buffer->type;
   GLuint size = element_size(type) * count;
   struct gl_buffer_object *bufferobj;
   GLuint offset;
   GLuint i;
d531 7
a537 4
   get_space(brw, size, &bufferobj, &offset);

   *vbo_return = bufferobj;
   *offset_return = offset;
a538 1
   if (min_index == 0) {
d541 22
a562 6
      ctx->Driver.BufferSubData( ctx,
				 GL_ELEMENT_ARRAY_BUFFER_ARB,
				 offset, 
				 size,
				 indices,
				 bufferobj);
a563 5
   else {
      void *map = ctx->Driver.MapBuffer(ctx,
					GL_ELEMENT_ARRAY_BUFFER_ARB,
					GL_DYNAMIC_DRAW_ARB,
					bufferobj);
d565 4
a568 34
      map += offset;

      switch (type) {
      case GL_UNSIGNED_INT: {
	 GLuint *ui_map = (GLuint *)map;
	 const GLuint *ui_indices = (const GLuint *)indices;

	 for (i = 0; i < count; i++)
	    ui_map[i] = ui_indices[i] - min_index;
	 break;
      }
      case GL_UNSIGNED_SHORT:  {
	 GLushort *us_map = (GLushort *)map;
	 const GLushort *us_indices = (const GLushort *)indices;

	 for (i = 0; i < count; i++)
	    us_map[i] = us_indices[i] - min_index;
	 break;
      }
      case GL_UNSIGNED_BYTE:  {
	 GLubyte *ub_map = (GLubyte *)map;
	 const GLubyte *ub_indices = (const GLubyte *)indices;

	 for (i = 0; i < count; i++)
	    ub_map[i] = ub_indices[i] - min_index;
	 break;
      }
      }

      ctx->Driver.UnmapBuffer(ctx, 
			      GL_ELEMENT_ARRAY_BUFFER_ARB, 
			      bufferobj);

   }
d571 4
a574 4


void brw_upload_indices( struct brw_context *brw,
			 const struct brw_draw_index_buffer *index_buffer)
a577 9
   struct gl_buffer_object *bufferobj = index_buffer->obj;
   GLuint offset = (GLuint)index_buffer->ptr;

   /* Already turned into a proper VBO:
    */
   if (!index_buffer->obj->Name) {
      rebase_indices_to_vbo_indices(brw, index_buffer, &bufferobj, &offset );
   }

a581 1
      struct buffer *buffer = intel_bufferobj_buffer(intel_buffer_object(bufferobj));
d591 1
a591 1
      BEGIN_BATCH(4, 0);
d593 3
a595 2
      OUT_BATCH( bmBufferOffset(intel, buffer) + offset );
      OUT_BATCH( bmBufferOffset(intel, buffer) + offset + ib_size );
d598 2
d602 1
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d396 1
a396 1
   GLuint64EXT tmp = brw->vs.prog_data->inputs_read; 
d417 1
a417 1
      GLuint i = ffsll(tmp)-1;
d420 1
a420 1
      tmp &= ~((GLuint64EXT)1<<i);
a437 1
		  (const char *)input->glarray->Ptr - (const char *)ptr < 0 ||
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d38 1
d313 1
d340 1
d352 1
a352 1
			  array->Ptr,
d383 1
d396 1
a396 1
   GLuint tmp = brw->vs.prog_data->inputs_read; 
d403 1
a403 1
   struct brw_vertex_element *enabled[VERT_ATTRIB_MAX];
d406 1
a406 1
   struct brw_vertex_element *upload[VERT_ATTRIB_MAX];
a414 2
   if (0)
      _mesa_printf("%s %d..%d\n", __FUNCTION__, min_index, max_index);
d417 1
a417 1
      GLuint i = _mesa_ffsll(tmp)-1;
d420 1
a420 1
      tmp &= ~(1<<i);
d425 1
a425 1
      input->count = input->glarray->StrideB ? max_index + 1 - min_index : 1;
d444 1
a444 9
	 
	 /* We rebase drawing to start at element zero only when
	  * varyings are not in vbos, which means we can end up
	  * uploading non-varying arrays (stride != 0) when min_index
	  * is zero.  This doesn't matter as the amount to upload is
	  * the same for these arrays whether the draw call is rebased
	  * or not - we just have to upload the one element.
	  */
	 assert(min_index == 0 || input->glarray->StrideB == 0);
d446 2
d460 1
d478 1
d526 1
a526 1
      vbp.vb[i].offset = (GLuint)input->glarray->Ptr;
d528 1
a528 1
      vbp.vb[i].max_index = max_index;
d569 5
a573 2
void brw_upload_indices( struct brw_context *brw,
			 const struct _mesa_index_buffer *index_buffer )
d576 10
a585 4
   struct intel_context *intel = &brw->intel;
   GLuint ib_size = get_size(index_buffer->type) * index_buffer->count;
   struct gl_buffer_object *bufferobj = index_buffer->obj;
   GLuint offset = (GLuint)index_buffer->ptr;
d587 2
a588 7
   /* Turn into a proper VBO:
    */
   if (!bufferobj->Name) {
     
      /* Get new bufferobj, offset:
       */
      get_space(brw, ib_size, &bufferobj, &offset);
d590 1
d596 2
a597 2
				 ib_size,
				 index_buffer->ptr,
d599 57
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d28 1
d30 5
a34 4
#include "main/glheader.h"
#include "main/bufferobj.h"
#include "main/context.h"
#include "main/enums.h"
d39 1
d41 1
d43 1
d47 30
a92 8
static GLuint half_float_types[5] = {
   0,
   BRW_SURFACEFORMAT_R16_FLOAT,
   BRW_SURFACEFORMAT_R16G16_FLOAT,
   BRW_SURFACEFORMAT_R16G16B16A16_FLOAT,
   BRW_SURFACEFORMAT_R16G16B16A16_FLOAT
};

d190 1
a190 7
/**
 * Given vertex array type/size/format/normalized info, return
 * the appopriate hardware surface type.
 * Format will be GL_RGBA or possibly GL_BGRA for GLubyte[4] color arrays.
 */
static GLuint get_surface_type( GLenum type, GLuint size,
                                GLenum format, GLboolean normalized )
d192 2
a193 2
   if (unlikely(INTEL_DEBUG & DEBUG_VERTS))
      printf("type %s size %d normalized %d\n", 
a199 1
      case GL_HALF_FLOAT: return half_float_types[size];
d205 1
a205 9
      case GL_UNSIGNED_BYTE:
         if (format == GL_BGRA) {
            /* See GL_EXT_vertex_array_bgra */
            assert(size == 4);
            return BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
         }
         else {
            return ubyte_types_norm[size];
         }
a209 1
      assert(format == GL_RGBA); /* sanity check */
a212 1
      case GL_HALF_FLOAT: return half_float_types[size];
a229 1
   case GL_HALF_FLOAT: return sizeof(GLhalfARB);
d250 19
d272 2
d277 2
d281 6
a286 4
   if (brw->vb.upload.bo != NULL)
      drm_intel_bo_unreference(brw->vb.upload.bo);
   brw->vb.upload.bo = drm_intel_bo_alloc(brw->intel.bufmgr, "temporary VBO",
					  size, 1);
d291 1
a291 1
		       drm_intel_bo **bo_return,
d294 3
a296 4
   size = ALIGN(size, 64);

   if (brw->vb.upload.bo == NULL ||
       brw->vb.upload.offset + size > brw->vb.upload.bo->size) {
a297 1
   }
d299 1
a299 3
   assert(*bo_return == NULL);
   drm_intel_bo_reference(brw->vb.upload.bo);
   *bo_return = brw->vb.upload.bo;
d301 1
d305 3
a307 1
static void
d309 4
a312 2
			 struct brw_vertex_element *element,
			 GLuint dst_stride)
d314 6
a319 1
   GLuint size = element->count * dst_stride;
d321 1
a321 1
   get_space(brw, size, &element->bo, &element->offset);
d323 30
a352 26
   if (element->glarray->StrideB == 0) {
      assert(element->count == 1);
      element->stride = 0;
   } else {
      element->stride = dst_stride;
   }

   if (dst_stride == element->glarray->StrideB) {
      drm_intel_gem_bo_map_gtt(element->bo);
      memcpy((char *)element->bo->virtual + element->offset,
	     element->glarray->Ptr, size);
      drm_intel_gem_bo_unmap_gtt(element->bo);
   } else {
      char *dest;
      const unsigned char *src = element->glarray->Ptr;
      int i;

      drm_intel_gem_bo_map_gtt(element->bo);
      dest = element->bo->virtual;
      dest += element->offset;

      for (i = 0; i < element->count; i++) {
	 memcpy(dest, src, dst_stride);
	 src += element->glarray->StrideB;
	 dest += dst_stride;
      }
d354 1
a354 1
      drm_intel_gem_bo_unmap_gtt(element->bo);
d356 2
d360 8
a367 1
static void brw_prepare_vertices(struct brw_context *brw)
d369 22
a390 1
   struct gl_context *ctx = &brw->intel.ctx;
d392 3
a394 1
   GLbitfield vs_inputs = brw->vs.prog_data->inputs_read; 
d396 1
a396 1
   const unsigned char *ptr = NULL;
d398 3
a400 2
   unsigned int min_index = brw->vb.min_index;
   unsigned int max_index = brw->vb.max_index;
d404 4
d412 4
a415 6
      printf("%s %d..%d\n", __FUNCTION__, min_index, max_index);

   /* Accumulate the list of enabled arrays. */
   brw->vb.nr_enabled = 0;
   while (vs_inputs) {
      GLuint i = _mesa_ffsll(vs_inputs) - 1;
d418 2
a419 17
      vs_inputs &= ~(1 << i);
      brw->vb.enabled[brw->vb.nr_enabled++] = input;
   }

   /* XXX: In the rare cases where this happens we fallback all
    * the way to software rasterization, although a tnl fallback
    * would be sufficient.  I don't know of *any* real world
    * cases with > 17 vertex attributes enabled, so it probably
    * isn't an issue at this point.
    */
   if (brw->vb.nr_enabled >= BRW_VEP_MAX) {
      intel->Fallback = GL_TRUE; /* boolean, not bitfield */
      return;
   }

   for (i = 0; i < brw->vb.nr_enabled; i++) {
      struct brw_vertex_element *input = brw->vb.enabled[i];
d421 1
d423 1
d425 2
a426 40
      if (_mesa_is_bufferobj(input->glarray->BufferObj)) {
	 struct intel_buffer_object *intel_buffer =
	    intel_buffer_object(input->glarray->BufferObj);

	 /* Named buffer object: Just reference its contents directly. */
	 drm_intel_bo_unreference(input->bo);
	 input->bo = intel_bufferobj_buffer(intel, intel_buffer,
					    INTEL_READ);
	 drm_intel_bo_reference(input->bo);
	 input->offset = (unsigned long)input->glarray->Ptr;
	 input->stride = input->glarray->StrideB;
	 input->count = input->glarray->_MaxElement;

	 /* This is a common place to reach if the user mistakenly supplies
	  * a pointer in place of a VBO offset.  If we just let it go through,
	  * we may end up dereferencing a pointer beyond the bounds of the
	  * GTT.  We would hope that the VBO's max_index would save us, but
	  * Mesa appears to hand us min/max values not clipped to the
	  * array object's _MaxElement, and _MaxElement frequently appears
	  * to be wrong anyway.
	  *
	  * The VBO spec allows application termination in this case, and it's
	  * probably a service to the poor programmer to do so rather than
	  * trying to just not render.
	  */
	 assert(input->offset < input->bo->size);
      } else {
	 input->count = input->glarray->StrideB ? max_index + 1 : 1;
	 if (input->bo != NULL) {
	    /* Already-uploaded vertex data is present from a previous
	     * prepare_vertices, but we had to re-validate state due to
	     * check_aperture failing and a new batch being produced.
	     */
	    continue;
	 }

	 /* Queue the buffer object up to be uploaded in the next pass,
	  * when we've decided if we're doing interleaved or not.
	  */
	 if (input->attrib == VERT_ATTRIB_POS) {
d429 2
a430 4
            if (input->glarray->StrideB == 0) {
               intel->Fallback = GL_TRUE; /* boolean, not bitfield */
               return;
            }
d436 2
a437 3
		  (const unsigned char *)input->glarray->Ptr - ptr < 0 ||
		  (const unsigned char *)input->glarray->Ptr - ptr > interleave)
	 {
d442 9
d454 11
a464 6
   /* Handle any arrays to be uploaded. */
   if (nr_uploads > 1 && interleave && interleave <= 256) {
      /* All uploads are interleaved, so upload the arrays together as
       * interleaved.  First, upload the contents and set up upload[0].
       */
      copy_array_to_vbo_array(brw, upload[0], interleave);
d467 5
a471 6
	 /* Then, just point upload[i] at upload[0]'s buffer. */
	 upload[i]->stride = interleave;
	 upload[i]->offset = upload[0]->offset +
	    ((const unsigned char *)upload[i]->glarray->Ptr - ptr);
	 upload[i]->bo = upload[0]->bo;
	 drm_intel_bo_reference(upload[i]->bo);
a474 1
      /* Upload non-interleaved arrays */
d476 7
a482 1
          copy_array_to_vbo_array(brw, upload[i], upload[i]->element_size);
d486 8
a493 1
   brw_prepare_query_begin(brw);
d495 6
a500 2
   for (i = 0; i < brw->vb.nr_enabled; i++) {
      struct brw_vertex_element *input = brw->vb.enabled[i];
d502 10
a511 3
      brw_add_validated_bo(brw, input->bo);
   }
}
d513 7
a519 5
static void brw_emit_vertices(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->intel.ctx;
   struct intel_context *intel = intel_context(ctx);
   GLuint i;
d521 2
a522 1
   brw_emit_query_begin(brw);
d524 7
a530 27
   /* If the VS doesn't read any inputs (calculating vertex position from
    * a state variable for some reason, for example), emit a single pad
    * VERTEX_ELEMENT struct and bail.
    *
    * The stale VB state stays in place, but they don't do anything unless
    * a VE loads from them.
    */
   if (brw->vb.nr_enabled == 0) {
      BEGIN_BATCH(3);
      OUT_BATCH((CMD_VERTEX_ELEMENT << 16) | 1);
      if (intel->gen >= 6) {
	 OUT_BATCH((0 << GEN6_VE0_INDEX_SHIFT) |
		   GEN6_VE0_VALID |
		   (BRW_SURFACEFORMAT_R32G32B32A32_FLOAT << BRW_VE0_FORMAT_SHIFT) |
		   (0 << BRW_VE0_SRC_OFFSET_SHIFT));
      } else {
	 OUT_BATCH((0 << BRW_VE0_INDEX_SHIFT) |
		   BRW_VE0_VALID |
		   (BRW_SURFACEFORMAT_R32G32B32A32_FLOAT << BRW_VE0_FORMAT_SHIFT) |
		   (0 << BRW_VE0_SRC_OFFSET_SHIFT));
      }
      OUT_BATCH((BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_0_SHIFT) |
		(BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_1_SHIFT) |
		(BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_2_SHIFT) |
		(BRW_VE1_COMPONENT_STORE_1_FLT << BRW_VE1_COMPONENT_3_SHIFT));
      ADVANCE_BATCH();
      return;
d533 3
a535 5
   /* Now emit VB and VEP state packets.
    *
    * This still defines a hardware VB for each input, even if they
    * are interleaved or from the same VBO.  TBD if this makes a
    * performance difference.
d537 2
a538 15
   BEGIN_BATCH(1 + brw->vb.nr_enabled * 4);
   OUT_BATCH((CMD_VERTEX_BUFFER << 16) |
	     ((1 + brw->vb.nr_enabled * 4) - 2));

   for (i = 0; i < brw->vb.nr_enabled; i++) {
      struct brw_vertex_element *input = brw->vb.enabled[i];
      uint32_t dw0;

      if (intel->gen >= 6) {
	 dw0 = GEN6_VB0_ACCESS_VERTEXDATA |
	    (i << GEN6_VB0_INDEX_SHIFT);
      } else {
	 dw0 = BRW_VB0_ACCESS_VERTEXDATA |
	    (i << BRW_VB0_INDEX_SHIFT);
      }
d540 8
a547 12
      OUT_BATCH(dw0 |
		(input->stride << BRW_VB0_PITCH_SHIFT));
      OUT_RELOC(input->bo,
		I915_GEM_DOMAIN_VERTEX, 0,
		input->offset);
      if (intel->gen >= 5) {
	 OUT_RELOC(input->bo,
		   I915_GEM_DOMAIN_VERTEX, 0,
		   input->bo->size - 1);
      } else
          OUT_BATCH(input->stride ? input->count : 0);
      OUT_BATCH(0); /* Instance data step rate */
d551 3
a553 12
   BEGIN_BATCH(1 + brw->vb.nr_enabled * 2);
   OUT_BATCH((CMD_VERTEX_ELEMENT << 16) | ((1 + brw->vb.nr_enabled * 2) - 2));
   for (i = 0; i < brw->vb.nr_enabled; i++) {
      struct brw_vertex_element *input = brw->vb.enabled[i];
      uint32_t format = get_surface_type(input->glarray->Type,
					 input->glarray->Size,
					 input->glarray->Format,
					 input->glarray->Normalized);
      uint32_t comp0 = BRW_VE1_COMPONENT_STORE_SRC;
      uint32_t comp1 = BRW_VE1_COMPONENT_STORE_SRC;
      uint32_t comp2 = BRW_VE1_COMPONENT_STORE_SRC;
      uint32_t comp3 = BRW_VE1_COMPONENT_STORE_SRC;
d555 2
a556 7
      switch (input->glarray->Size) {
      case 0: comp0 = BRW_VE1_COMPONENT_STORE_0;
      case 1: comp1 = BRW_VE1_COMPONENT_STORE_0;
      case 2: comp2 = BRW_VE1_COMPONENT_STORE_0;
      case 3: comp3 = BRW_VE1_COMPONENT_STORE_1_FLT;
	 break;
      }
a557 11
      if (intel->gen >= 6) {
	 OUT_BATCH((i << GEN6_VE0_INDEX_SHIFT) |
		   GEN6_VE0_VALID |
		   (format << BRW_VE0_FORMAT_SHIFT) |
		   (0 << BRW_VE0_SRC_OFFSET_SHIFT));
      } else {
	 OUT_BATCH((i << BRW_VE0_INDEX_SHIFT) |
		   BRW_VE0_VALID |
		   (format << BRW_VE0_FORMAT_SHIFT) |
		   (0 << BRW_VE0_SRC_OFFSET_SHIFT));
      }
d559 7
a565 11
      if (intel->gen >= 5)
          OUT_BATCH((comp0 << BRW_VE1_COMPONENT_0_SHIFT) |
                    (comp1 << BRW_VE1_COMPONENT_1_SHIFT) |
                    (comp2 << BRW_VE1_COMPONENT_2_SHIFT) |
                    (comp3 << BRW_VE1_COMPONENT_3_SHIFT));
      else
          OUT_BATCH((comp0 << BRW_VE1_COMPONENT_0_SHIFT) |
                    (comp1 << BRW_VE1_COMPONENT_1_SHIFT) |
                    (comp2 << BRW_VE1_COMPONENT_2_SHIFT) |
                    (comp3 << BRW_VE1_COMPONENT_3_SHIFT) |
                    ((i * 4) << BRW_VE1_DST_OFFSET_SHIFT));
a566 1
   ADVANCE_BATCH();
a568 9
const struct brw_tracked_state brw_vertices = {
   .dirty = {
      .mesa = 0,
      .brw = BRW_NEW_BATCH | BRW_NEW_VERTICES,
      .cache = 0,
   },
   .prepare = brw_prepare_vertices,
   .emit = brw_emit_vertices,
};
d570 3
a572 1
static void brw_prepare_indices(struct brw_context *brw)
d574 1
a574 1
   struct gl_context *ctx = &brw->intel.ctx;
d576 3
a578 13
   const struct _mesa_index_buffer *index_buffer = brw->ib.ib;
   GLuint ib_size;
   drm_intel_bo *bo = NULL;
   struct gl_buffer_object *bufferobj;
   GLuint offset;
   GLuint ib_type_size;

   if (index_buffer == NULL)
      return;

   ib_type_size = get_size(index_buffer->type);
   ib_size = ib_type_size * index_buffer->count;
   bufferobj = index_buffer->obj;;
d582 2
a583 3
   if (!_mesa_is_bufferobj(bufferobj)) {
      brw->ib.start_vertex_offset = 0;

d586 1
a586 1
      get_space(brw, ib_size, &bo, &offset);
d590 6
a595 49
      drm_intel_gem_bo_map_gtt(bo);
      memcpy((char *)bo->virtual + offset, index_buffer->ptr, ib_size);
      drm_intel_gem_bo_unmap_gtt(bo);
   } else {
      offset = (GLuint) (unsigned long) index_buffer->ptr;
      brw->ib.start_vertex_offset = 0;

      /* If the index buffer isn't aligned to its element size, we have to
       * rebase it into a temporary.
       */
       if ((get_size(index_buffer->type) - 1) & offset) {
           GLubyte *map = ctx->Driver.MapBuffer(ctx,
                                                GL_ELEMENT_ARRAY_BUFFER_ARB,
                                                GL_DYNAMIC_DRAW_ARB,
                                                bufferobj);
           map += offset;

	   get_space(brw, ib_size, &bo, &offset);

	   drm_intel_bo_subdata(bo, offset, ib_size, map);

           ctx->Driver.UnmapBuffer(ctx, GL_ELEMENT_ARRAY_BUFFER_ARB, bufferobj);
       } else {
	  bo = intel_bufferobj_buffer(intel, intel_buffer_object(bufferobj),
				      INTEL_READ);
	  drm_intel_bo_reference(bo);

	  /* Use CMD_3D_PRIM's start_vertex_offset to avoid re-uploading
	   * the index buffer state when we're just moving the start index
	   * of our drawing.
	   */
	  brw->ib.start_vertex_offset = offset / ib_type_size;
	  offset = 0;
	  ib_size = bo->size;
       }
   }

   if (brw->ib.bo != bo ||
       brw->ib.offset != offset ||
       brw->ib.size != ib_size)
   {
      drm_intel_bo_unreference(brw->ib.bo);
      brw->ib.bo = bo;
      brw->ib.offset = offset;
      brw->ib.size = ib_size;

      brw->state.dirty.brw |= BRW_NEW_INDEX_BUFFER;
   } else {
      drm_intel_bo_unreference(bo);
a597 20
   brw_add_validated_bo(brw, brw->ib.bo);
}

const struct brw_tracked_state brw_indices = {
   .dirty = {
      .mesa = 0,
      .brw = BRW_NEW_INDICES,
      .cache = 0,
   },
   .prepare = brw_prepare_indices,
};

static void brw_emit_index_buffer(struct brw_context *brw)
{
   struct intel_context *intel = &brw->intel;
   const struct _mesa_index_buffer *index_buffer = brw->ib.ib;

   if (index_buffer == NULL)
      return;

d602 1
d605 1
a605 1

d610 1
d612 1
a612 1
      BEGIN_BATCH(4);
d614 2
a615 6
      OUT_RELOC(brw->ib.bo,
		I915_GEM_DOMAIN_VERTEX, 0,
		brw->ib.offset);
      OUT_RELOC(brw->ib.bo,
		I915_GEM_DOMAIN_VERTEX, 0,
		brw->ib.offset + brw->ib.size - 1);
a619 9

const struct brw_tracked_state brw_index_buffer = {
   .dirty = {
      .mesa = 0,
      .brw = BRW_NEW_BATCH | BRW_NEW_INDEX_BUFFER,
      .cache = 0,
   },
   .emit = brw_emit_index_buffer,
};
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d28 1
a32 2
#include "main/macros.h"
#include "main/glformats.h"
a65 16
static GLuint fixed_point_types[5] = {
   0,
   BRW_SURFACEFORMAT_R32_SFIXED,
   BRW_SURFACEFORMAT_R32G32_SFIXED,
   BRW_SURFACEFORMAT_R32G32B32_SFIXED,
   BRW_SURFACEFORMAT_R32G32B32A32_SFIXED,
};

static GLuint uint_types_direct[5] = {
   0,
   BRW_SURFACEFORMAT_R32_UINT,
   BRW_SURFACEFORMAT_R32G32_UINT,
   BRW_SURFACEFORMAT_R32G32B32_UINT,
   BRW_SURFACEFORMAT_R32G32B32A32_UINT
};

a81 8
static GLuint int_types_direct[5] = {
   0,
   BRW_SURFACEFORMAT_R32_SINT,
   BRW_SURFACEFORMAT_R32G32_SINT,
   BRW_SURFACEFORMAT_R32G32B32_SINT,
   BRW_SURFACEFORMAT_R32G32B32A32_SINT
};

a97 8
static GLuint ushort_types_direct[5] = {
   0,
   BRW_SURFACEFORMAT_R16_UINT,
   BRW_SURFACEFORMAT_R16G16_UINT,
   BRW_SURFACEFORMAT_R16G16B16A16_UINT,
   BRW_SURFACEFORMAT_R16G16B16A16_UINT
};

a113 8
static GLuint short_types_direct[5] = {
   0,
   BRW_SURFACEFORMAT_R16_SINT,
   BRW_SURFACEFORMAT_R16G16_SINT,
   BRW_SURFACEFORMAT_R16G16B16A16_SINT,
   BRW_SURFACEFORMAT_R16G16B16A16_SINT
};

a129 8
static GLuint ubyte_types_direct[5] = {
   0,
   BRW_SURFACEFORMAT_R8_UINT,
   BRW_SURFACEFORMAT_R8G8_UINT,
   BRW_SURFACEFORMAT_R8G8B8A8_UINT,
   BRW_SURFACEFORMAT_R8G8B8A8_UINT
};

a145 8
static GLuint byte_types_direct[5] = {
   0,
   BRW_SURFACEFORMAT_R8_SINT,
   BRW_SURFACEFORMAT_R8G8_SINT,
   BRW_SURFACEFORMAT_R8G8B8A8_SINT,
   BRW_SURFACEFORMAT_R8G8B8A8_SINT
};

d168 2
a169 3
static unsigned
get_surface_type(struct brw_context *brw,
                 const struct gl_client_array *glarray)
a170 2
   int size = glarray->Size;

d173 1
a173 2
             _mesa_lookup_enum_by_nr(glarray->Type),
             glarray->Size, glarray->Normalized);
d175 2
a176 13
   if (glarray->Integer) {
      assert(glarray->Format == GL_RGBA); /* sanity check */
      switch (glarray->Type) {
      case GL_INT: return int_types_direct[size];
      case GL_SHORT: return short_types_direct[size];
      case GL_BYTE: return byte_types_direct[size];
      case GL_UNSIGNED_INT: return uint_types_direct[size];
      case GL_UNSIGNED_SHORT: return ushort_types_direct[size];
      case GL_UNSIGNED_BYTE: return ubyte_types_direct[size];
      default: assert(0); return 0;
      }
   } else if (glarray->Normalized) {
      switch (glarray->Type) {
d186 1
a186 1
         if (glarray->Format == GL_BGRA) {
a193 29
      case GL_FIXED:
         if (brw->gen >= 8 || brw->is_haswell)
            return fixed_point_types[size];

         /* This produces GL_FIXED inputs as values between INT32_MIN and
          * INT32_MAX, which will be scaled down by 1/65536 by the VS.
          */
         return int_types_scale[size];
      /* See GL_ARB_vertex_type_2_10_10_10_rev.
       * W/A: Pre-Haswell, the hardware doesn't really support the formats we'd
       * like to use here, so upload everything as UINT and fix
       * it in the shader
       */
      case GL_INT_2_10_10_10_REV:
         assert(size == 4);
         if (brw->gen >= 8 || brw->is_haswell) {
            return glarray->Format == GL_BGRA
               ? BRW_SURFACEFORMAT_B10G10R10A2_SNORM
               : BRW_SURFACEFORMAT_R10G10B10A2_SNORM;
         }
         return BRW_SURFACEFORMAT_R10G10B10A2_UINT;
      case GL_UNSIGNED_INT_2_10_10_10_REV:
         assert(size == 4);
         if (brw->gen >= 8 || brw->is_haswell) {
            return glarray->Format == GL_BGRA
               ? BRW_SURFACEFORMAT_B10G10R10A2_UNORM
               : BRW_SURFACEFORMAT_R10G10B10A2_UNORM;
         }
         return BRW_SURFACEFORMAT_R10G10B10A2_UINT;
d195 1
a195 1
      }
d198 2
a199 24
      /* See GL_ARB_vertex_type_2_10_10_10_rev.
       * W/A: the hardware doesn't really support the formats we'd
       * like to use here, so upload everything as UINT and fix
       * it in the shader
       */
      if (glarray->Type == GL_INT_2_10_10_10_REV) {
         assert(size == 4);
         if (brw->gen >= 8 || brw->is_haswell) {
            return glarray->Format == GL_BGRA
               ? BRW_SURFACEFORMAT_B10G10R10A2_SSCALED
               : BRW_SURFACEFORMAT_R10G10B10A2_SSCALED;
         }
         return BRW_SURFACEFORMAT_R10G10B10A2_UINT;
      } else if (glarray->Type == GL_UNSIGNED_INT_2_10_10_10_REV) {
         assert(size == 4);
         if (brw->gen >= 8 || brw->is_haswell) {
            return glarray->Format == GL_BGRA
               ? BRW_SURFACEFORMAT_B10G10R10A2_USCALED
               : BRW_SURFACEFORMAT_R10G10B10A2_USCALED;
         }
         return BRW_SURFACEFORMAT_R10G10B10A2_UINT;
      }
      assert(glarray->Format == GL_RGBA); /* sanity check */
      switch (glarray->Type) {
a208 8
      case GL_FIXED:
         if (brw->gen >= 8 || brw->is_haswell)
            return fixed_point_types[size];

         /* This produces GL_FIXED inputs as values between INT32_MIN and
          * INT32_MAX, which will be scaled down by 1/65536 by the VS.
          */
         return int_types_scale[size];
d210 1
a210 1
      }
d214 18
a231 1
static GLuint get_index_type(GLenum type)
d241 33
d275 3
a277 5
copy_array_to_vbo_array(struct brw_context *brw,
			struct brw_vertex_element *element,
			int min, int max,
			struct brw_vertex_buffer *buffer,
			GLuint dst_stride)
d279 1
a279 1
   const int src_stride = element->glarray->StrideB;
d281 1
a281 9
   /* If the source stride is zero, we just want to upload the current
    * attribute once and set the buffer's stride to 0.  There's no need
    * to replicate it out.
    */
   if (src_stride == 0) {
      intel_upload_data(brw, element->glarray->Ptr,
                        element->glarray->_ElementSize,
                        element->glarray->_ElementSize,
			&buffer->bo, &buffer->offset);
d283 5
a287 2
      buffer->stride = 0;
      return;
d290 5
a294 7
   const unsigned char *src = element->glarray->Ptr + min * src_stride;
   int count = max - min + 1;
   GLuint size = count * dst_stride;

   if (dst_stride == src_stride) {
      intel_upload_data(brw, src, size, dst_stride,
			&buffer->bo, &buffer->offset);
d296 7
a302 2
      char * const map = intel_upload_map(brw, size, dst_stride);
      char *dst = map;
d304 4
a307 4
      while (count--) {
	 memcpy(dst, src, dst_stride);
	 src += src_stride;
	 dst += dst_stride;
d309 2
a310 2
      intel_upload_unmap(brw, map, size, dst_stride,
			 &buffer->bo, &buffer->offset);
a311 1
   buffer->stride = dst_stride;
d316 4
a319 3
   struct gl_context *ctx = &brw->ctx;
   /* CACHE_NEW_VS_PROG */
   GLbitfield64 vs_inputs = brw->vs.prog_data->inputs_read;
d321 3
a323 4
   GLuint interleaved = 0;
   unsigned int min_index = brw->vb.min_index + brw->basevertex;
   unsigned int max_index = brw->vb.max_index + brw->basevertex;
   int delta, i, j;
d328 1
a328 6
   /* _NEW_POLYGON
    *
    * On gen6+, edge flags don't end up in the VUE (either in or out of the
    * VS).  Instead, they're uploaded as the last vertex element, and the data
    * is passed sideband through the fixed function units.  So, we need to
    * prepare the vertex buffer for it, but it's not present in inputs_read.
a329 5
   if (brw->gen >= 6 && (ctx->Polygon.FrontMode != GL_FILL ||
                           ctx->Polygon.BackMode != GL_FILL)) {
      vs_inputs |= VERT_BIT_EDGEFLAG;
   }

d336 1
a336 1
      GLuint i = ffsll(vs_inputs) - 1;
d339 1
a339 1
      vs_inputs &= ~BITFIELD64_BIT(i);
d343 8
a350 1
   if (brw->vb.nr_enabled == 0)
d352 1
d354 2
a355 2
   if (brw->vb.nr_buffers)
      return;
d357 1
a357 3
   for (i = j = 0; i < brw->vb.nr_enabled; i++) {
      struct brw_vertex_element *input = brw->vb.enabled[i];
      const struct gl_client_array *glarray = input->glarray;
d359 1
a359 1
      if (_mesa_is_bufferobj(glarray->BufferObj)) {
d361 1
a361 21
	    intel_buffer_object(glarray->BufferObj);
	 int k;

	 /* If we have a VB set to be uploaded for this buffer object
	  * already, reuse that VB state so that we emit fewer
	  * relocations.
	  */
	 for (k = 0; k < i; k++) {
	    const struct gl_client_array *other = brw->vb.enabled[k]->glarray;
	    if (glarray->BufferObj == other->BufferObj &&
		glarray->StrideB == other->StrideB &&
		glarray->InstanceDivisor == other->InstanceDivisor &&
		(uintptr_t)(glarray->Ptr - other->Ptr) < glarray->StrideB)
	    {
	       input->buffer = brw->vb.enabled[k]->buffer;
	       input->offset = glarray->Ptr - other->Ptr;
	       break;
	    }
	 }
	 if (k == i) {
	    struct brw_vertex_buffer *buffer = &brw->vb.buffers[j];
d363 8
a370 12
	    /* Named buffer object: Just reference its contents directly. */
            buffer->bo = intel_bufferobj_source(brw,
                                                intel_buffer, 1,
						&buffer->offset);
	    drm_intel_bo_reference(buffer->bo);
	    buffer->offset += (uintptr_t)glarray->Ptr;
	    buffer->stride = glarray->StrideB;
	    buffer->step_rate = glarray->InstanceDivisor;

	    input->buffer = j++;
	    input->offset = 0;
	 }
d384 1
a384 1
	 assert(input->offset < brw->vb.buffers[input->buffer].bo->size);
d386 9
d398 10
a407 3
	 if (nr_uploads == 0) {
	    interleaved = glarray->StrideB;
	    ptr = glarray->Ptr;
d409 3
a411 3
	 else if (interleaved != glarray->StrideB ||
                  glarray->Ptr < ptr ||
                  (uintptr_t)(glarray->Ptr - ptr) + glarray->_ElementSize > interleaved)
d413 1
a413 16
            /* If our stride is different from the first attribute's stride,
             * or if the first attribute's stride didn't cover our element,
             * disable the interleaved upload optimization.  The second case
             * can most commonly occur in cases where there is a single vertex
             * and, for example, the data is stored on the application's
             * stack.
             *
             * NOTE: This will also disable the optimization in cases where
             * the data is in a different order than the array indices.
             * Something like:
             *
             *     float data[...];
             *     glVertexAttribPointer(0, 4, GL_FLOAT, 32, &data[4]);
             *     glVertexAttribPointer(1, 4, GL_FLOAT, 32, &data[0]);
             */
	    interleaved = 0;
a419 11
   /* If we need to upload all the arrays, then we can trim those arrays to
    * only the used elements [min_index, max_index] so long as we adjust all
    * the values used in the 3DPRIMITIVE i.e. by setting the vertex bias.
    */
   brw->vb.start_vertex_bias = 0;
   delta = min_index;
   if (nr_uploads == brw->vb.nr_enabled) {
      brw->vb.start_vertex_bias = -delta;
      delta = 0;
   }

d421 5
a425 17
   if (nr_uploads > 1) {
      if (interleaved) {
	 struct brw_vertex_buffer *buffer = &brw->vb.buffers[j];
	 /* All uploads are interleaved, so upload the arrays together as
	  * interleaved.  First, upload the contents and set up upload[0].
	  */
	 copy_array_to_vbo_array(brw, upload[0], min_index, max_index,
				 buffer, interleaved);
	 buffer->offset -= delta * interleaved;

	 for (i = 0; i < nr_uploads; i++) {
	    /* Then, just point upload[i] at upload[0]'s buffer. */
	    upload[i]->offset =
	       ((const unsigned char *)upload[i]->glarray->Ptr - ptr);
	    upload[i]->buffer = j;
	 }
	 j++;
d427 7
a433 1
	 nr_uploads = 0;
d436 4
a439 15
   /* Upload non-interleaved arrays */
   for (i = 0; i < nr_uploads; i++) {
      struct brw_vertex_buffer *buffer = &brw->vb.buffers[j];
      if (upload[i]->glarray->InstanceDivisor == 0) {
         copy_array_to_vbo_array(brw, upload[i], min_index, max_index,
                                 buffer, upload[i]->glarray->_ElementSize);
      } else {
         /* This is an instanced attribute, since its InstanceDivisor
          * is not zero. Therefore, its data will be stepped after the
          * instanced draw has been run InstanceDivisor times.
          */
         uint32_t instanced_attr_max_index =
            (brw->num_instances - 1) / upload[i]->glarray->InstanceDivisor;
         copy_array_to_vbo_array(brw, upload[i], 0, instanced_attr_max_index,
                                 buffer, upload[i]->glarray->_ElementSize);
a440 4
      buffer->offset -= delta * buffer->stride;
      buffer->step_rate = upload[i]->glarray->InstanceDivisor;
      upload[i]->buffer = j++;
      upload[i]->offset = 0;
d443 7
a449 1
   brw->vb.nr_buffers = j;
d454 3
a456 3
   GLuint i, nr_elements;

   brw_prepare_vertices(brw);
a459 2
   nr_elements = brw->vb.nr_enabled + brw->vs.prog_data->uses_vertexid;

d467 1
a467 1
   if (nr_elements == 0) {
d469 2
a470 2
      OUT_BATCH((_3DSTATE_VERTEX_ELEMENTS << 16) | 1);
      if (brw->gen >= 6) {
d485 1
a485 1
      CACHED_BATCH();
d490 4
d495 3
d499 7
a505 3
   if (brw->vb.nr_buffers) {
      if (brw->gen >= 6) {
	 assert(brw->vb.nr_buffers <= 33);
d507 2
a508 1
	 assert(brw->vb.nr_buffers <= 17);
d511 12
a522 33
      BEGIN_BATCH(1 + 4*brw->vb.nr_buffers);
      OUT_BATCH((_3DSTATE_VERTEX_BUFFERS << 16) | (4*brw->vb.nr_buffers - 1));
      for (i = 0; i < brw->vb.nr_buffers; i++) {
	 struct brw_vertex_buffer *buffer = &brw->vb.buffers[i];
	 uint32_t dw0;

	 if (brw->gen >= 6) {
	    dw0 = buffer->step_rate
	             ? GEN6_VB0_ACCESS_INSTANCEDATA
	             : GEN6_VB0_ACCESS_VERTEXDATA;
	    dw0 |= i << GEN6_VB0_INDEX_SHIFT;
	 } else {
	    dw0 = buffer->step_rate
	             ? BRW_VB0_ACCESS_INSTANCEDATA
	             : BRW_VB0_ACCESS_VERTEXDATA;
	    dw0 |= i << BRW_VB0_INDEX_SHIFT;
	 }

	 if (brw->gen >= 7)
	    dw0 |= GEN7_VB0_ADDRESS_MODIFYENABLE;

	 if (brw->is_haswell)
	    dw0 |= GEN7_MOCS_L3 << 16;

	 OUT_BATCH(dw0 | (buffer->stride << BRW_VB0_PITCH_SHIFT));
	 OUT_RELOC(buffer->bo, I915_GEM_DOMAIN_VERTEX, 0, buffer->offset);
	 if (brw->gen >= 5) {
	    OUT_RELOC(buffer->bo, I915_GEM_DOMAIN_VERTEX, 0, buffer->bo->size - 1);
	 } else
	    OUT_BATCH(0);
	 OUT_BATCH(buffer->step_rate);
      }
      ADVANCE_BATCH();
d524 1
d526 2
a527 13
   /* The hardware allows one more VERTEX_ELEMENTS than VERTEX_BUFFERS, presumably
    * for VertexID/InstanceID.
    */
   if (brw->gen >= 6) {
      assert(nr_elements <= 34);
   } else {
      assert(nr_elements <= 18);
   }

   struct brw_vertex_element *gen6_edgeflag_input = NULL;

   BEGIN_BATCH(1 + nr_elements * 2);
   OUT_BATCH((_3DSTATE_VERTEX_ELEMENTS << 16) | (2 * nr_elements - 1));
d530 4
a533 1
      uint32_t format = get_surface_type(brw, input->glarray);
a538 20
      /* The gen4 driver expects edgeflag to come in as a float, and passes
       * that float on to the tests in the clipper.  Mesa's current vertex
       * attribute value for EdgeFlag is stored as a float, which works out.
       * glEdgeFlagPointer, on the other hand, gives us an unnormalized
       * integer ubyte.  Just rewrite that to convert to a float.
       */
      if (input->attrib == VERT_ATTRIB_EDGEFLAG) {
         /* Gen6+ passes edgeflag as sideband along with the vertex, instead
          * of in the VUE.  We have to upload it sideband as the last vertex
          * element according to the B-Spec.
          */
         if (brw->gen >= 6) {
            gen6_edgeflag_input = input;
            continue;
         }

         if (format == BRW_SURFACEFORMAT_R8_UINT)
            format = BRW_SURFACEFORMAT_R8_SSCALED;
      }

d543 1
a543 2
      case 3: comp3 = input->glarray->Integer ? BRW_VE1_COMPONENT_STORE_1_INT
                                              : BRW_VE1_COMPONENT_STORE_1_FLT;
d547 2
a548 2
      if (brw->gen >= 6) {
	 OUT_BATCH((input->buffer << GEN6_VE0_INDEX_SHIFT) |
d551 1
a551 1
		   (input->offset << BRW_VE0_SRC_OFFSET_SHIFT));
d553 1
a553 1
	 OUT_BATCH((input->buffer << BRW_VE0_INDEX_SHIFT) |
d556 1
a556 1
		   (input->offset << BRW_VE0_SRC_OFFSET_SHIFT));
d559 1
a559 1
      if (brw->gen >= 5)
d571 1
a571 39

   if (brw->gen >= 6 && gen6_edgeflag_input) {
      uint32_t format = get_surface_type(brw, gen6_edgeflag_input->glarray);

      OUT_BATCH((gen6_edgeflag_input->buffer << GEN6_VE0_INDEX_SHIFT) |
                GEN6_VE0_VALID |
                GEN6_VE0_EDGE_FLAG_ENABLE |
                (format << BRW_VE0_FORMAT_SHIFT) |
                (gen6_edgeflag_input->offset << BRW_VE0_SRC_OFFSET_SHIFT));
      OUT_BATCH((BRW_VE1_COMPONENT_STORE_SRC << BRW_VE1_COMPONENT_0_SHIFT) |
                (BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_1_SHIFT) |
                (BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_2_SHIFT) |
                (BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_3_SHIFT));
   }

   if (brw->vs.prog_data->uses_vertexid) {
      uint32_t dw0 = 0, dw1 = 0;

      dw1 = ((BRW_VE1_COMPONENT_STORE_VID << BRW_VE1_COMPONENT_0_SHIFT) |
	     (BRW_VE1_COMPONENT_STORE_IID << BRW_VE1_COMPONENT_1_SHIFT) |
	     (BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_2_SHIFT) |
	     (BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_3_SHIFT));

      if (brw->gen >= 6) {
	 dw0 |= GEN6_VE0_VALID;
      } else {
	 dw0 |= BRW_VE0_VALID;
	 dw1 |= (i * 4) << BRW_VE1_DST_OFFSET_SHIFT;
      }

      /* Note that for gl_VertexID, gl_InstanceID, and gl_PrimitiveID values,
       * the format is ignored and the value is always int.
       */

      OUT_BATCH(dw0);
      OUT_BATCH(dw1);
   }

   CACHED_BATCH();
d576 1
a576 1
      .mesa = _NEW_POLYGON,
d578 1
a578 1
      .cache = CACHE_NEW_VS_PROG,
d580 1
d584 1
a584 1
static void brw_upload_indices(struct brw_context *brw)
d586 2
a587 1
   struct gl_context *ctx = &brw->ctx;
d598 1
a598 1
   ib_type_size = _mesa_sizeof_type(index_buffer->type);
d600 1
a600 1
   bufferobj = index_buffer->obj;
d605 1
d609 7
a615 3
      intel_upload_data(brw, index_buffer->ptr, ib_size, ib_type_size,
			&bo, &offset);
      brw->ib.start_vertex_offset = offset / ib_type_size;
d618 1
d623 8
a630 9
       if ((ib_type_size - 1) & offset) {
          perf_debug("copying index buffer to a temporary to work around "
                     "misaligned offset %d\n", offset);

          GLubyte *map = ctx->Driver.MapBufferRange(ctx,
                                                    offset,
                                                    ib_size,
                                                    GL_MAP_READ_BIT,
                                                    bufferobj);
d632 1
a632 2
          intel_upload_data(brw, map, ib_size, ib_type_size, &bo, &offset);
          brw->ib.start_vertex_offset = offset / ib_type_size;
d634 1
a634 1
          ctx->Driver.UnmapBuffer(ctx, bufferobj);
d636 4
d645 2
a646 8

	  bo = intel_bufferobj_source(brw,
				      intel_buffer_object(bufferobj),
				      ib_type_size,
				      &offset);
	  drm_intel_bo_reference(bo);

	  brw->ib.start_vertex_offset += offset / ib_type_size;
d650 4
a653 1
   if (brw->ib.bo != bo) {
d656 2
d664 1
a664 4
   if (index_buffer->type != brw->ib.type) {
      brw->ib.type = index_buffer->type;
      brw->state.dirty.brw |= BRW_NEW_INDEX_BUFFER;
   }
d673 1
a673 1
   .emit = brw_upload_indices,
d678 1
a679 1
   GLuint cut_index_setting;
d684 22
a705 4
   if (brw->prim_restart.enable_cut_index && !brw->is_haswell) {
      cut_index_setting = BRW_CUT_INDEX_ENABLE;
   } else {
      cut_index_setting = 0;
a706 13

   BEGIN_BATCH(3);
   OUT_BATCH(CMD_INDEX_BUFFER << 16 |
             cut_index_setting |
             get_index_type(index_buffer->type) << 8 |
             1);
   OUT_RELOC(brw->ib.bo,
             I915_GEM_DOMAIN_VERTEX, 0,
             0);
   OUT_RELOC(brw->ib.bo,
             I915_GEM_DOMAIN_VERTEX, 0,
	     brw->ib.bo->size - 1);
   ADVANCE_BATCH();
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d2 2
a3 2
 *
 * Copyright 2003 VMware, Inc.
d5 1
a5 1
 *
d13 1
a13 1
 *
d17 1
a17 1
 *
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d25 1
a25 1
 *
d225 3
a227 3
unsigned
brw_get_vertex_surface_type(struct brw_context *brw,
                            const struct gl_client_array *glarray)
d232 3
a234 3
      fprintf(stderr, "type %s size %d normalized %d\n",
              _mesa_lookup_enum_by_nr(glarray->Type),
              glarray->Size, glarray->Normalized);
a246 2
   } else if (glarray->Type == GL_UNSIGNED_INT_10F_11F_11F_REV) {
      return BRW_SURFACEFORMAT_R11G11B10_FLOAT;
d345 1
a345 2
unsigned
brw_get_index_type(GLenum type)
a380 2
   uint8_t *dst = intel_upload_space(brw, size, dst_stride,
                                     &buffer->bo, &buffer->offset);
d383 2
a384 1
      memcpy(dst, src, size);
d386 3
d394 2
d400 1
a400 2
void
brw_prepare_vertices(struct brw_context *brw)
d427 1
a427 1
      fprintf(stderr, "%s %d..%d\n", __FUNCTION__, min_index, max_index);
d474 5
a478 1
	    buffer->offset = (uintptr_t)glarray->Ptr;
a481 20
            uint32_t offset, size;
            if (glarray->InstanceDivisor) {
               offset = buffer->offset;
               size = (buffer->stride * ((brw->num_instances /
                                          glarray->InstanceDivisor) - 1) +
                       glarray->_ElementSize);
            } else {
               if (min_index == -1) {
                  offset = 0;
                  size = intel_buffer->Base.Size;
               } else {
                  offset = buffer->offset + min_index * buffer->stride;
                  size = (buffer->stride * (max_index - min_index) +
                          glarray->_ElementSize);
               }
            }
            buffer->bo = intel_bufferobj_buffer(brw, intel_buffer,
                                                offset, size);
            drm_intel_bo_reference(buffer->bo);

a592 1
   struct gl_context *ctx = &brw->ctx;
d626 1
a626 1
      ADVANCE_BATCH();
d661 1
a661 1
         if (brw->gen == 7)
a663 3
         WARN_ONCE(buffer->stride >= (brw->gen >= 5 ? 2048 : 2047),
                   "VBO stride %d too large, bad rendering may occur\n",
                   buffer->stride);
d690 1
a690 1
      uint32_t format = brw_get_vertex_surface_type(brw, input->glarray);
d696 7
a702 1
      if (input == &brw->vb.inputs[VERT_ATTRIB_EDGEFLAG]) {
d711 3
d751 1
a751 2
      uint32_t format =
         brw_get_vertex_surface_type(brw, gen6_edgeflag_input->glarray);
d787 1
a787 1
   ADVANCE_BATCH();
d804 1
a804 1
   drm_intel_bo *old_bo = brw->ib.bo;
d819 1
d823 2
a824 1
			&brw->ib.bo, &offset);
d831 34
a864 10
      if ((ib_type_size - 1) & offset) {
         perf_debug("copying index buffer to a temporary to work around "
                    "misaligned offset %d\n", offset);

         GLubyte *map = ctx->Driver.MapBufferRange(ctx,
                                                   offset,
                                                   ib_size,
                                                   GL_MAP_READ_BIT,
                                                   bufferobj,
                                                   MAP_INTERNAL);
d866 3
a868 14
         intel_upload_data(brw, map, ib_size, ib_type_size,
                           &brw->ib.bo, &offset);

         ctx->Driver.UnmapBuffer(ctx, bufferobj, MAP_INTERNAL);
      } else {
         drm_intel_bo *bo =
            intel_bufferobj_buffer(brw, intel_buffer_object(bufferobj),
                                   offset, ib_size);
         if (bo != brw->ib.bo) {
            drm_intel_bo_unreference(brw->ib.bo);
            brw->ib.bo = bo;
            drm_intel_bo_reference(bo);
         }
      }
a870 9
   /* Use 3DPRIMITIVE's start_vertex_offset to avoid re-uploading
    * the index buffer state when we're just moving the start index
    * of our drawing.
    */
   brw->ib.start_vertex_offset = offset / ib_type_size;

   if (brw->ib.bo != old_bo)
      brw->state.dirty.brw |= BRW_NEW_INDEX_BUFFER;

d903 1
a903 1
             brw_get_index_type(index_buffer->type) << 8 |
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@d245 1
a245 1
      default: unreachable("not reached");
d297 1
a297 1
      default: unreachable("not reached");
d342 1
a342 1
      default: unreachable("not reached");
d354 1
a354 1
   default: unreachable("not reached");
d505 4
a508 1
	  * GTT.
d607 1
a607 22
void
brw_prepare_shader_draw_parameters(struct brw_context *brw)
{
   /* For non-indirect draws, upload gl_BaseVertex. */
   if (brw->vs.prog_data->uses_vertexid && brw->draw.draw_params_bo == NULL) {
      intel_upload_data(brw, &brw->draw.gl_basevertex, 4, 4,
			&brw->draw.draw_params_bo,
                        &brw->draw.draw_params_offset);
   }
}

/**
 * Emit a VERTEX_BUFFER_STATE entry (part of 3DSTATE_VERTEX_BUFFERS).
 */
static void
emit_vertex_buffer_state(struct brw_context *brw,
                         unsigned buffer_nr,
                         drm_intel_bo *bo,
                         unsigned bo_ending_address,
                         unsigned bo_offset,
                         unsigned stride,
                         unsigned step_rate)
d610 1
a610 34
   uint32_t dw0;

   if (brw->gen >= 6) {
      dw0 = (buffer_nr << GEN6_VB0_INDEX_SHIFT) |
            (step_rate ? GEN6_VB0_ACCESS_INSTANCEDATA
                       : GEN6_VB0_ACCESS_VERTEXDATA);
   } else {
      dw0 = (buffer_nr << BRW_VB0_INDEX_SHIFT) |
            (step_rate ? BRW_VB0_ACCESS_INSTANCEDATA
                       : BRW_VB0_ACCESS_VERTEXDATA);
   }

   if (brw->gen >= 7)
      dw0 |= GEN7_VB0_ADDRESS_MODIFYENABLE;

   if (brw->gen == 7)
      dw0 |= GEN7_MOCS_L3 << 16;

   WARN_ONCE(stride >= (brw->gen >= 5 ? 2048 : 2047),
             "VBO stride %d too large, bad rendering may occur\n",
             stride);
   OUT_BATCH(dw0 | (stride << BRW_VB0_PITCH_SHIFT));
   OUT_RELOC(bo, I915_GEM_DOMAIN_VERTEX, 0, bo_offset);
   if (brw->gen >= 5) {
      OUT_RELOC(bo, I915_GEM_DOMAIN_VERTEX, 0, bo_ending_address);
   } else {
      OUT_BATCH(0);
   }
   OUT_BATCH(step_rate);
}

static void brw_emit_vertices(struct brw_context *brw)
{
   GLuint i;
a612 1
   brw_prepare_shader_draw_parameters(brw);
d616 1
a616 3
   unsigned nr_elements = brw->vb.nr_enabled;
   if (brw->vs.prog_data->uses_vertexid || brw->vs.prog_data->uses_instanceid)
      ++nr_elements;
d650 1
a650 4
   unsigned nr_buffers =
      brw->vb.nr_buffers + brw->vs.prog_data->uses_vertexid;

   if (nr_buffers) {
d652 1
a652 1
	 assert(nr_buffers <= 33);
d654 1
a654 1
	 assert(nr_buffers <= 17);
d657 2
a658 2
      BEGIN_BATCH(1 + 4 * nr_buffers);
      OUT_BATCH((_3DSTATE_VERTEX_BUFFERS << 16) | (4 * nr_buffers - 1));
d661 13
a673 3
         emit_vertex_buffer_state(brw, i, buffer->bo, buffer->bo->size - 1,
                                  buffer->offset, buffer->stride,
                                  buffer->step_rate);
d675 5
a679 1
      }
d681 10
a690 7
      if (brw->vs.prog_data->uses_vertexid) {
         emit_vertex_buffer_state(brw, brw->vb.nr_buffers,
                                  brw->draw.draw_params_bo,
                                  brw->draw.draw_params_bo->size - 1,
                                  brw->draw.draw_params_offset,
                                  0,  /* stride */
                                  0); /* step rate */
d776 1
a776 1
   if (brw->vs.prog_data->uses_vertexid || brw->vs.prog_data->uses_instanceid) {
a777 13
      uint32_t comp0 = BRW_VE1_COMPONENT_STORE_0;
      uint32_t comp1 = BRW_VE1_COMPONENT_STORE_0;
      uint32_t comp2 = BRW_VE1_COMPONENT_STORE_0;
      uint32_t comp3 = BRW_VE1_COMPONENT_STORE_0;

      if (brw->vs.prog_data->uses_vertexid) {
         comp0 = BRW_VE1_COMPONENT_STORE_SRC;
         comp2 = BRW_VE1_COMPONENT_STORE_VID;
      }

      if (brw->vs.prog_data->uses_instanceid) {
         comp3 = BRW_VE1_COMPONENT_STORE_IID;
      }
d779 4
a782 4
      dw1 = (comp0 << BRW_VE1_COMPONENT_0_SHIFT) |
            (comp1 << BRW_VE1_COMPONENT_1_SHIFT) |
            (comp2 << BRW_VE1_COMPONENT_2_SHIFT) |
            (comp3 << BRW_VE1_COMPONENT_3_SHIFT);
d785 1
a785 3
         dw0 |= GEN6_VE0_VALID |
                brw->vb.nr_buffers << GEN6_VE0_INDEX_SHIFT |
                BRW_SURFACEFORMAT_R32_UINT << BRW_VE0_FORMAT_SHIFT;
d787 1
a787 3
         dw0 |= BRW_VE0_VALID |
                brw->vb.nr_buffers << BRW_VE0_INDEX_SHIFT |
                BRW_SURFACEFORMAT_R32_UINT << BRW_VE0_FORMAT_SHIFT;
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d245 1
a245 1
      default: assert(0); return 0;
d297 1
a297 1
      default: assert(0); return 0;
d342 1
a342 1
      default: assert(0); return 0;
d354 1
a354 1
   default: assert(0); return 0;
d505 1
a505 4
	  * GTT.  We would hope that the VBO's max_index would save us, but
	  * Mesa appears to hand us min/max values not clipped to the
	  * array object's _MaxElement, and _MaxElement frequently appears
	  * to be wrong anyway.
d604 55
d661 1
a661 2
   struct gl_context *ctx = &brw->ctx;
   GLuint i, nr_elements;
d664 1
d668 3
a670 1
   nr_elements = brw->vb.nr_enabled + brw->vs.prog_data->uses_vertexid;
d704 4
a707 1
   if (brw->vb.nr_buffers) {
d709 1
a709 1
	 assert(brw->vb.nr_buffers <= 33);
d711 1
a711 1
	 assert(brw->vb.nr_buffers <= 17);
d714 2
a715 2
      BEGIN_BATCH(1 + 4*brw->vb.nr_buffers);
      OUT_BATCH((_3DSTATE_VERTEX_BUFFERS << 16) | (4*brw->vb.nr_buffers - 1));
d718 3
a720 1
	 uint32_t dw0;
d722 1
a722 11
	 if (brw->gen >= 6) {
	    dw0 = buffer->step_rate
	             ? GEN6_VB0_ACCESS_INSTANCEDATA
	             : GEN6_VB0_ACCESS_VERTEXDATA;
	    dw0 |= i << GEN6_VB0_INDEX_SHIFT;
	 } else {
	    dw0 = buffer->step_rate
	             ? BRW_VB0_ACCESS_INSTANCEDATA
	             : BRW_VB0_ACCESS_VERTEXDATA;
	    dw0 |= i << BRW_VB0_INDEX_SHIFT;
	 }
d724 7
a730 16
	 if (brw->gen >= 7)
	    dw0 |= GEN7_VB0_ADDRESS_MODIFYENABLE;

         if (brw->gen == 7)
	    dw0 |= GEN7_MOCS_L3 << 16;

         WARN_ONCE(buffer->stride >= (brw->gen >= 5 ? 2048 : 2047),
                   "VBO stride %d too large, bad rendering may occur\n",
                   buffer->stride);
	 OUT_BATCH(dw0 | (buffer->stride << BRW_VB0_PITCH_SHIFT));
	 OUT_RELOC(buffer->bo, I915_GEM_DOMAIN_VERTEX, 0, buffer->offset);
	 if (brw->gen >= 5) {
	    OUT_RELOC(buffer->bo, I915_GEM_DOMAIN_VERTEX, 0, buffer->bo->size - 1);
	 } else
	    OUT_BATCH(0);
	 OUT_BATCH(buffer->step_rate);
d816 1
a816 1
   if (brw->vs.prog_data->uses_vertexid) {
d818 13
d832 4
a835 4
      dw1 = ((BRW_VE1_COMPONENT_STORE_VID << BRW_VE1_COMPONENT_0_SHIFT) |
	     (BRW_VE1_COMPONENT_STORE_IID << BRW_VE1_COMPONENT_1_SHIFT) |
	     (BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_2_SHIFT) |
	     (BRW_VE1_COMPONENT_STORE_0 << BRW_VE1_COMPONENT_3_SHIFT));
d838 3
a840 1
	 dw0 |= GEN6_VE0_VALID;
d842 3
a844 1
	 dw0 |= BRW_VE0_VALID;
@


