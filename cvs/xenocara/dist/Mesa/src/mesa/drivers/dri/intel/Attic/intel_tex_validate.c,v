head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.09.05.14.04.37;	author jsg;	state dead;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.38;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@#include "main/mtypes.h"
#include "main/macros.h"
#include "main/samplerobj.h"

#include "intel_context.h"
#include "intel_mipmap_tree.h"
#include "intel_tex.h"

#define FILE_DEBUG_FLAG DEBUG_TEXTURE

/**
 * When validating, we only care about the texture images that could
 * be seen, so for non-mipmapped modes we want to ignore everything
 * but BaseLevel.
 */
static void
intel_update_max_level(struct intel_context *intel,
		       struct intel_texture_object *intelObj,
		       struct gl_sampler_object *sampler)
{
   struct gl_texture_object *tObj = &intelObj->base;

   if (sampler->MinFilter == GL_NEAREST ||
       sampler->MinFilter == GL_LINEAR) {
      intelObj->_MaxLevel = tObj->BaseLevel;
   } else {
      intelObj->_MaxLevel = tObj->_MaxLevel;
   }
}

/**
 * Copies the image's contents at its level into the object's miptree,
 * and updates the image to point at the object's miptree.
 */
static void
copy_image_data_to_tree(struct intel_context *intel,
                        struct intel_texture_object *intelObj,
                        struct intel_texture_image *intelImage)
{
   if (intelImage->mt) {
      /* Copy potentially with the blitter:
       */
      intel_miptree_image_copy(intel,
                               intelObj->mt,
                               intelImage->face,
                               intelImage->level, intelImage->mt);

      intel_miptree_release(intel, &intelImage->mt);
   }
   else {
      assert(intelImage->base.Data != NULL);

      /* More straightforward upload.  
       */
      intel_miptree_image_data(intel,
                               intelObj->mt,
                               intelImage->face,
                               intelImage->level,
                               intelImage->base.Data,
                               intelImage->base.RowStride,
                               intelImage->base.RowStride *
                               intelImage->base.Height);
      _mesa_align_free(intelImage->base.Data);
      intelImage->base.Data = NULL;
   }

   intel_miptree_reference(&intelImage->mt, intelObj->mt);
}


/*  
 */
GLuint
intel_finalize_mipmap_tree(struct intel_context *intel, GLuint unit)
{
   struct gl_context *ctx = &intel->ctx;
   struct gl_texture_object *tObj = intel->ctx.Texture.Unit[unit]._Current;
   struct intel_texture_object *intelObj = intel_texture_object(tObj);
   struct gl_sampler_object *sampler = _mesa_get_samplerobj(ctx, unit);
   GLuint face, i;
   GLuint nr_faces = 0;
   struct intel_texture_image *firstImage;

   /* We know/require this is true by now: 
    */
   assert(intelObj->base._Complete);

   /* What levels must the tree include at a minimum?
    */
   intel_update_max_level(intel, intelObj, sampler);
   firstImage = intel_texture_image(tObj->Image[0][tObj->BaseLevel]);

   /* Fallback case:
    */
   if (firstImage->base.Border) {
      if (intelObj->mt) {
         intel_miptree_release(intel, &intelObj->mt);
      }
      return GL_FALSE;
   }

   /* Check tree can hold all active levels.  Check tree matches
    * target, imageFormat, etc.
    *
    * For pre-gen4, we have to match first_level == tObj->BaseLevel,
    * because we don't have the control that gen4 does to make min/mag
    * determination happen at a nonzero (hardware) baselevel.  Because
    * of that, we just always relayout on baselevel change.
    */
   if (intelObj->mt &&
       (intelObj->mt->target != intelObj->base.Target ||
	intelObj->mt->format != firstImage->base.TexFormat ||
	intelObj->mt->first_level != tObj->BaseLevel ||
	intelObj->mt->last_level < intelObj->_MaxLevel ||
	intelObj->mt->width0 != firstImage->base.Width ||
	intelObj->mt->height0 != firstImage->base.Height ||
	intelObj->mt->depth0 != firstImage->base.Depth)) {
      intel_miptree_release(intel, &intelObj->mt);
   }


   /* May need to create a new tree:
    */
   if (!intelObj->mt) {
      intelObj->mt = intel_miptree_create(intel,
                                          intelObj->base.Target,
					  firstImage->base.TexFormat,
                                          tObj->BaseLevel,
                                          intelObj->_MaxLevel,
                                          firstImage->base.Width,
                                          firstImage->base.Height,
                                          firstImage->base.Depth,
					  GL_TRUE);
      if (!intelObj->mt)
         return GL_FALSE;
   }

   /* Pull in any images not in the object's tree:
    */
   nr_faces = (intelObj->base.Target == GL_TEXTURE_CUBE_MAP) ? 6 : 1;
   for (face = 0; face < nr_faces; face++) {
      for (i = tObj->BaseLevel; i <= intelObj->_MaxLevel; i++) {
         struct intel_texture_image *intelImage =
            intel_texture_image(intelObj->base.Image[face][i]);
	 /* skip too small size mipmap */
 	 if (intelImage == NULL)
		 break;
	 /* Need to import images in main memory or held in other trees.
	  * If it's a render target, then its data isn't needed to be in
	  * the object tree (otherwise we'd be FBO incomplete), and we need
	  * to keep track of the image's MT as needing to be pulled in still,
	  * or we'll lose the rendering that's done to it.
          */
         if (intelObj->mt != intelImage->mt &&
	     !intelImage->used_as_render_target) {
            copy_image_data_to_tree(intel, intelObj, intelImage);
         }
      }
   }

   return GL_TRUE;
}

void
intel_tex_map_level_images(struct intel_context *intel,
			   struct intel_texture_object *intelObj,
			   int level)
{
   GLuint nr_faces = (intelObj->base.Target == GL_TEXTURE_CUBE_MAP) ? 6 : 1;
   GLuint face;

   for (face = 0; face < nr_faces; face++) {
      struct intel_texture_image *intelImage =
	 intel_texture_image(intelObj->base.Image[face][level]);

      if (intelImage && intelImage->mt) {
	 intelImage->base.Data =
	    intel_miptree_image_map(intel,
				    intelImage->mt,
				    intelImage->face,
				    intelImage->level,
				    &intelImage->base.RowStride,
				    intelImage->base.ImageOffsets);
	 /* convert stride to texels, not bytes */
	 intelImage->base.RowStride /= intelImage->mt->cpp;
	 /* intelImage->base.ImageStride /= intelImage->mt->cpp; */
      }
   }
}

void
intel_tex_unmap_level_images(struct intel_context *intel,
			     struct intel_texture_object *intelObj,
			     int level)
{
   GLuint nr_faces = (intelObj->base.Target == GL_TEXTURE_CUBE_MAP) ? 6 : 1;
   GLuint face;

   for (face = 0; face < nr_faces; face++) {
      struct intel_texture_image *intelImage =
	 intel_texture_image(intelObj->base.Image[face][level]);

      if (intelImage && intelImage->mt) {
	 intel_miptree_image_unmap(intel, intelImage->mt);
	 intelImage->base.Data = NULL;
      }
   }
}

void
intel_tex_map_images(struct intel_context *intel,
                     struct intel_texture_object *intelObj)
{
   int i;

   DBG("%s\n", __FUNCTION__);

   for (i = intelObj->base.BaseLevel; i <= intelObj->_MaxLevel; i++)
      intel_tex_map_level_images(intel, intelObj, i);
}

void
intel_tex_unmap_images(struct intel_context *intel,
                       struct intel_texture_object *intelObj)
{
   int i;

   for (i = intelObj->base.BaseLevel; i <= intelObj->_MaxLevel; i++)
      intel_tex_unmap_level_images(intel, intelObj, i);
}
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.4
log
@Merge Mesa 7.10.3
@
text
@d3 1
d12 3
a14 3
 * Compute which mipmap levels that really need to be sent to the hardware.
 * This depends on the base image size, GL_TEXTURE_MIN_LOD,
 * GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, and GL_TEXTURE_MAX_LEVEL.
d17 3
a19 2
intel_calculate_first_last_level(struct intel_context *intel,
				 struct intel_texture_object *intelObj)
a21 2
   const struct gl_texture_image *const baseImage =
      tObj->Image[0][tObj->BaseLevel];
d23 5
a27 49
   /* These must be signed values.  MinLod and MaxLod can be negative numbers,
    * and having firstLevel and lastLevel as signed prevents the need for
    * extra sign checks.
    */
   int firstLevel;
   int lastLevel;

   /* Yes, this looks overly complicated, but it's all needed.
    */
   switch (tObj->Target) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_TEXTURE_3D:
   case GL_TEXTURE_CUBE_MAP:
      if (tObj->MinFilter == GL_NEAREST || tObj->MinFilter == GL_LINEAR) {
         /* GL_NEAREST and GL_LINEAR only care about GL_TEXTURE_BASE_LEVEL.
          */
         firstLevel = lastLevel = tObj->BaseLevel;
      }
      else {
	 if (intel->gen == 2) {
	    firstLevel = tObj->BaseLevel + (GLint) (tObj->MinLod + 0.5);
	    firstLevel = MAX2(firstLevel, tObj->BaseLevel);
	    firstLevel = MIN2(firstLevel, tObj->BaseLevel + baseImage->MaxLog2);
	    lastLevel = tObj->BaseLevel + (GLint) (tObj->MaxLod + 0.5);
	    lastLevel = MAX2(lastLevel, tObj->BaseLevel);
	    lastLevel = MIN2(lastLevel, tObj->BaseLevel + baseImage->MaxLog2);
	    lastLevel = MIN2(lastLevel, tObj->MaxLevel);
	    lastLevel = MAX2(firstLevel, lastLevel);       /* need at least one level */
	 } else {
	    /* Min/max LOD are taken into account in sampler state.  We don't
	     * want to re-layout textures just because clamping has been applied
	     * since it means a bunch of blitting around and probably no memory
	     * savings (since we have to keep the other levels around anyway).
	     */
	    firstLevel = tObj->BaseLevel;
	    lastLevel = MIN2(tObj->BaseLevel + baseImage->MaxLog2,
			     tObj->MaxLevel);
	    /* need at least one level */
	    lastLevel = MAX2(firstLevel, lastLevel);
	 }
      }
      break;
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_TEXTURE_4D_SGIS:
      firstLevel = lastLevel = 0;
      break;
   default:
      return;
a28 4

   /* save these values */
   intelObj->firstLevel = firstLevel;
   intelObj->lastLevel = lastLevel;
d76 1
d79 1
a79 2
   int comp_byte = 0;
   int cpp;
d90 2
a91 2
   intel_calculate_first_last_level(intel, intelObj);
   firstImage = intel_texture_image(tObj->Image[0][intelObj->firstLevel]);
a101 24

   /* If both firstImage and intelObj have a tree which can contain
    * all active images, favour firstImage.  Note that because of the
    * completeness requirement, we know that the image dimensions
    * will match.
    */
   if (firstImage->mt &&
       firstImage->mt != intelObj->mt &&
       firstImage->mt->first_level <= intelObj->firstLevel &&
       firstImage->mt->last_level >= intelObj->lastLevel) {

      if (intelObj->mt)
         intel_miptree_release(intel, &intelObj->mt);

      intel_miptree_reference(&intelObj->mt, firstImage->mt);
   }

   if (_mesa_is_format_compressed(firstImage->base.TexFormat)) {
      comp_byte = intel_compressed_num_bytes(firstImage->base.TexFormat);
      cpp = comp_byte;
   }
   else
      cpp = _mesa_get_format_bytes(firstImage->base.TexFormat);

d104 5
a108 6
    * 
    * XXX: For some layouts (eg i945?), the test might have to be
    * first_level == firstLevel, as the tree isn't valid except at the
    * original start level.  Hope to get around this by
    * programming minLod, maxLod, baseLevel into the hardware and
    * leaving the tree alone.
d112 3
a114 3
	intelObj->mt->internal_format != firstImage->base.InternalFormat ||
	intelObj->mt->first_level != intelObj->firstLevel ||
	intelObj->mt->last_level != intelObj->lastLevel ||
d117 1
a117 3
	intelObj->mt->depth0 != firstImage->base.Depth ||
	intelObj->mt->cpp != cpp ||
	intelObj->mt->compressed != _mesa_is_format_compressed(firstImage->base.TexFormat))) {
d127 3
a129 4
                                          firstImage->base._BaseFormat,
                                          firstImage->base.InternalFormat,
                                          intelObj->firstLevel,
                                          intelObj->lastLevel,
a132 2
                                          cpp,
                                          comp_byte,
d134 2
d142 1
a142 1
      for (i = intelObj->firstLevel; i <= intelObj->lastLevel; i++) {
d218 1
a218 1
   for (i = intelObj->firstLevel; i <= intelObj->lastLevel; i++)
d228 1
a228 1
   for (i = intelObj->firstLevel; i <= intelObj->lastLevel; i++)
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d221 4
a224 2

         /* Need to import images in main memory or held in other trees.
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a4 1
#include "intel_batchbuffer.h"
d16 2
a17 1
intel_calculate_first_last_level(struct intel_texture_object *intelObj)
d43 21
a63 21
#ifdef I915
         firstLevel = tObj->BaseLevel + (GLint) (tObj->MinLod + 0.5);
         firstLevel = MAX2(firstLevel, tObj->BaseLevel);
         firstLevel = MIN2(firstLevel, tObj->BaseLevel + baseImage->MaxLog2);
         lastLevel = tObj->BaseLevel + (GLint) (tObj->MaxLod + 0.5);
         lastLevel = MAX2(lastLevel, tObj->BaseLevel);
         lastLevel = MIN2(lastLevel, tObj->BaseLevel + baseImage->MaxLog2);
         lastLevel = MIN2(lastLevel, tObj->MaxLevel);
         lastLevel = MAX2(firstLevel, lastLevel);       /* need at least one level */
#else
	 /* Currently not taking min/max lod into account here, those
	  * values are programmed as sampler state elsewhere and we
	  * upload the same mipmap levels regardless.  Not sure if
	  * this makes sense as it means it isn't possible for the app
	  * to use min/max lod to reduce texture memory pressure:
	  */
	 firstLevel = tObj->BaseLevel;
	 lastLevel = MIN2(tObj->BaseLevel + baseImage->MaxLog2,
			  tObj->MaxLevel);
	 lastLevel = MAX2(firstLevel, lastLevel); /* need at least one level */
#endif
d138 2
a139 3
   intel_calculate_first_last_level(intelObj);
   firstImage =
      intel_texture_image(intelObj->base.Image[0][intelObj->firstLevel]);
d167 2
a168 2
   if (firstImage->base.IsCompressed) {
      comp_byte = intel_compressed_num_bytes(firstImage->base.TexFormat->MesaFormat);
d171 2
a172 1
   else cpp = firstImage->base.TexFormat->TexelBytes;
d192 1
a192 1
	intelObj->mt->compressed != firstImage->base.IsCompressed)) {
d202 1
d223 4
d228 2
a229 1
         if (intelObj->mt != intelImage->mt) {
d250 1
a250 1
      if (intelImage->mt) {
d277 1
a277 1
      if (intelImage->mt) {
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d1 2
a2 2
#include "mtypes.h"
#include "macros.h"
a127 1

a131 2
   GLboolean need_flush = GL_FALSE;

d144 1
a144 4
   if (firstImage->base.Border ||
       ((firstImage->base._BaseFormat == GL_DEPTH_COMPONENT) &&
        ((tObj->WrapS == GL_CLAMP_TO_BORDER) ||
         (tObj->WrapT == GL_CLAMP_TO_BORDER)))) {
d209 2
a210 1
                                          comp_byte);
a224 1
	    need_flush = GL_TRUE;
a227 10

#ifdef I915
   /* XXX: what is this flush about?
    * On 965, it causes a batch flush in the middle of the state relocation
    * emits, which means that the eventual rendering doesn't have all of the
    * required relocations in place.
    */
   if (need_flush)
      intel_batchbuffer_flush(intel->batch);
#endif
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d1 2
a2 2
#include "main/mtypes.h"
#include "main/macros.h"
d5 1
d17 1
a17 2
intel_calculate_first_last_level(struct intel_context *intel,
				 struct intel_texture_object *intelObj)
d43 21
a63 21
	 if (intel->gen == 2) {
	    firstLevel = tObj->BaseLevel + (GLint) (tObj->MinLod + 0.5);
	    firstLevel = MAX2(firstLevel, tObj->BaseLevel);
	    firstLevel = MIN2(firstLevel, tObj->BaseLevel + baseImage->MaxLog2);
	    lastLevel = tObj->BaseLevel + (GLint) (tObj->MaxLod + 0.5);
	    lastLevel = MAX2(lastLevel, tObj->BaseLevel);
	    lastLevel = MIN2(lastLevel, tObj->BaseLevel + baseImage->MaxLog2);
	    lastLevel = MIN2(lastLevel, tObj->MaxLevel);
	    lastLevel = MAX2(firstLevel, lastLevel);       /* need at least one level */
	 } else {
	    /* Min/max LOD are taken into account in sampler state.  We don't
	     * want to re-layout textures just because clamping has been applied
	     * since it means a bunch of blitting around and probably no memory
	     * savings (since we have to keep the other levels around anyway).
	     */
	    firstLevel = tObj->BaseLevel;
	    lastLevel = MIN2(tObj->BaseLevel + baseImage->MaxLog2,
			     tObj->MaxLevel);
	    /* need at least one level */
	    lastLevel = MAX2(firstLevel, lastLevel);
	 }
d128 1
d133 2
d141 3
a143 2
   intel_calculate_first_last_level(intel, intelObj);
   firstImage = intel_texture_image(tObj->Image[0][intelObj->firstLevel]);
d147 4
a150 1
   if (firstImage->base.Border) {
d174 2
a175 2
   if (_mesa_is_format_compressed(firstImage->base.TexFormat)) {
      comp_byte = intel_compressed_num_bytes(firstImage->base.TexFormat);
d178 1
a178 2
   else
      cpp = _mesa_get_format_bytes(firstImage->base.TexFormat);
d198 1
a198 1
	intelObj->mt->compressed != _mesa_is_format_compressed(firstImage->base.TexFormat))) {
a207 1
                                          firstImage->base._BaseFormat,
d215 1
a215 2
                                          comp_byte,
					  GL_TRUE);
d225 2
a226 8
	 /* skip too small size mipmap */
 	 if (intelImage == NULL)
		 break;
	 /* Need to import images in main memory or held in other trees.
	  * If it's a render target, then its data isn't needed to be in
	  * the object tree (otherwise we'd be FBO incomplete), and we need
	  * to keep track of the image's MT as needing to be pulled in still,
	  * or we'll lose the rendering that's done to it.
d228 1
a228 2
         if (intelObj->mt != intelImage->mt &&
	     !intelImage->used_as_render_target) {
d230 1
d235 10
d260 1
a260 1
      if (intelImage && intelImage->mt) {
d287 1
a287 1
      if (intelImage && intelImage->mt) {
@


