head	1.7;
access;
symbols
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.09.05.14.05.04;	author jsg;	state dead;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.23;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.18;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.53.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.53.33;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.28;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.29.27;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.41;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@/*
Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.

The Weather Channel (TM) funded Tungsten Graphics to develop the
initial release of the Radeon 8500 driver under the XFree86 license.
This notice must be preserved.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial
portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/**
 * \file
 *
 * \author Keith Whitwell <keith@@tungstengraphics.com>
 *
 * \todo Enable R300 texture tiling code?
 */

#include "main/glheader.h"
#include "main/imports.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/teximage.h"
#include "main/texobj.h"
#include "main/enums.h"
#include "main/simple_list.h"

#include "r300_context.h"
#include "radeon_mipmap_tree.h"
#include "r300_tex.h"
#include "r300_reg.h"

/*
 * Note that the _REV formats are the same as the non-REV formats.  This is
 * because the REV and non-REV formats are identical as a byte string, but
 * differ when accessed as 16-bit or 32-bit words depending on the endianness of
 * the host.  Since the textures are transferred to the R300 as a byte string
 * (i.e. without any byte-swapping), the R300 sees the REV and non-REV formats
 * identically.  -- paulus
 */

int32_t r300TranslateTexFormat(gl_format mesaFormat)
{
	switch (mesaFormat)
	{
#ifdef MESA_LITTLE_ENDIAN
		case MESA_FORMAT_RGBA8888:
			return R300_EASY_TX_FORMAT(Y, Z, W, X, W8Z8Y8X8);
		case MESA_FORMAT_RGBA8888_REV:
			return R300_EASY_TX_FORMAT(Z, Y, X, W, W8Z8Y8X8);
		case MESA_FORMAT_ARGB8888:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8);
		case MESA_FORMAT_ARGB8888_REV:
			return R300_EASY_TX_FORMAT(W, Z, Y, X, W8Z8Y8X8);
#else
		case MESA_FORMAT_RGBA8888:
			return R300_EASY_TX_FORMAT(Z, Y, X, W, W8Z8Y8X8);
		case MESA_FORMAT_RGBA8888_REV:
			return R300_EASY_TX_FORMAT(Y, Z, W, X, W8Z8Y8X8);
		case MESA_FORMAT_ARGB8888:
			return R300_EASY_TX_FORMAT(W, Z, Y, X, W8Z8Y8X8);
		case MESA_FORMAT_ARGB8888_REV:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8);
#endif
		case MESA_FORMAT_XRGB8888:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, W8Z8Y8X8);
		case MESA_FORMAT_RGB888:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, W8Z8Y8X8);
		case MESA_FORMAT_RGB565:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5);
		case MESA_FORMAT_RGB565_REV:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5);
		case MESA_FORMAT_ARGB4444:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, W4Z4Y4X4);
		case MESA_FORMAT_ARGB4444_REV:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, W4Z4Y4X4);
		case MESA_FORMAT_ARGB1555:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, W1Z5Y5X5);
		case MESA_FORMAT_ARGB1555_REV:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, W1Z5Y5X5);
		case MESA_FORMAT_AL88:
			return R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8);
		case MESA_FORMAT_AL88_REV:
			return R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8);
		case MESA_FORMAT_RGB332:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z3Y3X2);
		case MESA_FORMAT_A8:
			return R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, X8);
		case MESA_FORMAT_L8:
			return R300_EASY_TX_FORMAT(X, X, X, ONE, X8);
		case MESA_FORMAT_I8:
			return R300_EASY_TX_FORMAT(X, X, X, X, X8);
		case MESA_FORMAT_CI8:
			return R300_EASY_TX_FORMAT(X, X, X, X, X8);
		case MESA_FORMAT_YCBCR:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, G8R8_G8B8) | R300_TX_FORMAT_YUV_MODE;
		case MESA_FORMAT_YCBCR_REV:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, G8R8_G8B8) | R300_TX_FORMAT_YUV_MODE;
		case MESA_FORMAT_RGB_DXT1:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, DXT1);
		case MESA_FORMAT_RGBA_DXT1:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, DXT1);
		case MESA_FORMAT_RGBA_DXT3:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, DXT3);
		case MESA_FORMAT_RGBA_DXT5:
			return R300_EASY_TX_FORMAT(Y, Z, W, X, DXT5);
		case MESA_FORMAT_RGBA_FLOAT32:
			return R300_EASY_TX_FORMAT(Z, Y, X, W, FL_R32G32B32A32);
		case MESA_FORMAT_RGBA_FLOAT16:
			return R300_EASY_TX_FORMAT(Z, Y, X, W, FL_R16G16B16A16);
		case MESA_FORMAT_ALPHA_FLOAT32:
			return R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, FL_I32);
		case MESA_FORMAT_ALPHA_FLOAT16:
			return R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, FL_I16);
		case MESA_FORMAT_LUMINANCE_FLOAT32:
			return R300_EASY_TX_FORMAT(X, X, X, ONE, FL_I32);
		case MESA_FORMAT_LUMINANCE_FLOAT16:
			return R300_EASY_TX_FORMAT(X, X, X, ONE, FL_I16);
		case MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32:
			return R300_EASY_TX_FORMAT(X, X, X, Y, FL_I32A32);
		case MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16:
			return R300_EASY_TX_FORMAT(X, X, X, Y, FL_I16A16);
		case MESA_FORMAT_INTENSITY_FLOAT32:
			return R300_EASY_TX_FORMAT(X, X, X, X, FL_I32);
		case MESA_FORMAT_INTENSITY_FLOAT16:
			return R300_EASY_TX_FORMAT(X, X, X, X, FL_I16);
		case MESA_FORMAT_Z16:
			return R300_EASY_TX_FORMAT(X, X, X, X, X16);
		case MESA_FORMAT_Z24_S8:
			return R300_EASY_TX_FORMAT(X, X, X, X, X24_Y8);
		case MESA_FORMAT_S8_Z24:
			return R300_EASY_TX_FORMAT(Y, Y, Y, Y, X24_Y8);
		case MESA_FORMAT_Z32:
			return R300_EASY_TX_FORMAT(X, X, X, X, X32);
		/* EXT_texture_sRGB */
		case MESA_FORMAT_SARGB8:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8) | R300_TX_FORMAT_GAMMA;
		case MESA_FORMAT_SLA8:
			return R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8) | R300_TX_FORMAT_GAMMA;
		case MESA_FORMAT_SL8:
			return R300_EASY_TX_FORMAT(X, X, X, ONE, X8) | R300_TX_FORMAT_GAMMA;
		case MESA_FORMAT_SRGB_DXT1:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, DXT1) | R300_TX_FORMAT_GAMMA;
		case MESA_FORMAT_SRGBA_DXT1:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, DXT1) | R300_TX_FORMAT_GAMMA;
		case MESA_FORMAT_SRGBA_DXT3:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, DXT3) | R300_TX_FORMAT_GAMMA;
		case MESA_FORMAT_SRGBA_DXT5:
			return R300_EASY_TX_FORMAT(Y, Z, W, X, DXT5) | R300_TX_FORMAT_GAMMA;
		default:
			return -1;
	}
};

void r300SetDepthTexMode(struct gl_texture_object *tObj)
{
	static const GLuint formats[3][3] = {
		{
			R300_EASY_TX_FORMAT(X, X, X, ONE, X16),
			R300_EASY_TX_FORMAT(X, X, X, X, X16),
			R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, X16),
		},
		{
			R300_EASY_TX_FORMAT(Y, Y, Y, ONE, X24_Y8),
			R300_EASY_TX_FORMAT(Y, Y, Y, Y, X24_Y8),
			R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, Y, X24_Y8),
		},
		{
			R300_EASY_TX_FORMAT(X, X, X, ONE, X32),
			R300_EASY_TX_FORMAT(X, X, X, X, X32),
			R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, X32),
		},
	};
	const GLuint *format;
	radeonTexObjPtr t;

	if (!tObj)
		return;

	t = radeon_tex_obj(tObj);

	switch (tObj->Image[0][tObj->BaseLevel]->TexFormat) {
	case MESA_FORMAT_Z16:
		format = formats[0];
		break;
	case MESA_FORMAT_S8_Z24:
		format = formats[1];
		break;
	case MESA_FORMAT_Z32:
		format = formats[2];
		break;
	default:
		/* Error...which should have already been caught by higher
		 * levels of Mesa.
		 */
		ASSERT(0);
		return;
	}

	switch (tObj->Sampler.DepthMode) {
	case GL_LUMINANCE:
		t->pp_txformat = format[0];
		break;
	case GL_INTENSITY:
		t->pp_txformat = format[1];
		break;
	case GL_ALPHA:
		t->pp_txformat = format[2];
		break;
	default:
		/* Error...which should have already been caught by higher
		 * levels of Mesa.
		 */
		ASSERT(0);
		return;
	}
}


/**
 * Compute the cached hardware register values for the given texture object.
 *
 * \param rmesa Context pointer
 * \param t the r300 texture object
 */
static void setup_hardware_state(r300ContextPtr rmesa, radeonTexObj *t)
{
	const struct gl_texture_image *firstImage;
	firstImage = t->base.Image[0][t->minLod];

	if (!t->image_override) {
		if (firstImage->_BaseFormat == GL_DEPTH_COMPONENT) {
			r300SetDepthTexMode(&t->base);
		} else {
			int32_t txformat = r300TranslateTexFormat(firstImage->TexFormat);
			if (txformat < 0) {
				_mesa_problem(rmesa->radeon.glCtx, "%s: Invalid format %s",
							  __FUNCTION__, _mesa_get_format_name(firstImage->TexFormat));
				exit(1);
			}
			t->pp_txformat = (uint32_t) txformat;
		}
	}

	if (t->image_override && t->bo)
		return;

	t->pp_txsize = (((R300_TX_WIDTHMASK_MASK & ((firstImage->Width - 1) << R300_TX_WIDTHMASK_SHIFT)))
			| ((R300_TX_HEIGHTMASK_MASK & ((firstImage->Height - 1) << R300_TX_HEIGHTMASK_SHIFT)))
			| ((R300_TX_DEPTHMASK_MASK & ((firstImage->DepthLog2) << R300_TX_DEPTHMASK_SHIFT)))
			| ((R300_TX_MAX_MIP_LEVEL_MASK & ((t->maxLod - t->minLod) << R300_TX_MAX_MIP_LEVEL_SHIFT))));

	t->tile_bits = 0;

	if (t->base.Target == GL_TEXTURE_CUBE_MAP)
		t->pp_txformat |= R300_TX_FORMAT_CUBIC_MAP;
	if (t->base.Target == GL_TEXTURE_3D)
		t->pp_txformat |= R300_TX_FORMAT_3D;


	if (t->base.Target == GL_TEXTURE_RECTANGLE_NV) {
		unsigned int align = (64 / _mesa_get_format_bytes(firstImage->TexFormat)) - 1;
		t->pp_txsize |= R300_TX_SIZE_TXPITCH_EN;
		if (!t->image_override)
			t->pp_txpitch = ((firstImage->Width + align) & ~align) - 1;
	}

	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
	    if (firstImage->Width > 2048)
		t->pp_txpitch |= R500_TXWIDTH_BIT11;
            else
		t->pp_txpitch &= ~R500_TXWIDTH_BIT11;
	    if (firstImage->Height > 2048)
		t->pp_txpitch |= R500_TXHEIGHT_BIT11;
            else
		t->pp_txpitch &= ~R500_TXHEIGHT_BIT11;
	}
}

/**
 * Ensure the given texture is ready for rendering.
 *
 * Mostly this means populating the texture object's mipmap tree.
 */
static GLboolean r300_validate_texture(struct gl_context * ctx, struct gl_texture_object *texObj)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	radeonTexObj *t = radeon_tex_obj(texObj);

	if (!radeon_validate_texture_miptree(ctx, texObj))
		return GL_FALSE;

	/* Configure the hardware registers (more precisely, the cached version
	 * of the hardware registers). */
	setup_hardware_state(rmesa, t);

	t->validated = GL_TRUE;
	return GL_TRUE;
}

/**
 * Ensure all enabled and complete textures are uploaded along with any buffers being used.
 */
GLboolean r300ValidateBuffers(struct gl_context * ctx)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	struct radeon_renderbuffer *rrb;
	int i;
	int ret;

	radeon_cs_space_reset_bos(rmesa->radeon.cmdbuf.cs);

	rrb = radeon_get_colorbuffer(&rmesa->radeon);
	/* color buffer */
	if (rrb && rrb->bo) {
		radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs,
						  rrb->bo, 0,
						  RADEON_GEM_DOMAIN_VRAM);
	}

	/* depth buffer */
	rrb = radeon_get_depthbuffer(&rmesa->radeon);
	if (rrb && rrb->bo) {
		radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs,
						  rrb->bo, 0,
						  RADEON_GEM_DOMAIN_VRAM);
	}
	
	for (i = 0; i < ctx->Const.MaxTextureImageUnits; ++i) {
		radeonTexObj *t;

		if (!ctx->Texture.Unit[i]._ReallyEnabled)
			continue;

		if (!r300_validate_texture(ctx, ctx->Texture.Unit[i]._Current)) {
			_mesa_warning(ctx,
				      "failed to validate texture for unit %d.\n",
				      i);
		}
		t = radeon_tex_obj(ctx->Texture.Unit[i]._Current);
		if (t->image_override && t->bo)
			radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs,
							  t->bo,
							  RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0);
		else if (t->mt->bo)
			radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs,
							  t->mt->bo,
							  RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0);
	}

	ret = radeon_cs_space_check_with_bo(rmesa->radeon.cmdbuf.cs, first_elem(&rmesa->radeon.dma.reserved)->bo, RADEON_GEM_DOMAIN_GTT, 0);
	if (ret)
		return GL_FALSE;
	return GL_TRUE;
}

void r300SetTexOffset(__DRIcontext * pDRICtx, GLint texname,
		      unsigned long long offset, GLint depth, GLuint pitch)
{
	r300ContextPtr rmesa = pDRICtx->driverPrivate;
	struct gl_texture_object *tObj =
	    _mesa_lookup_texture(rmesa->radeon.glCtx, texname);
	radeonTexObjPtr t = radeon_tex_obj(tObj);
	uint32_t pitch_val;

	if (!tObj)
		return;

	t->image_override = GL_TRUE;

	if (!offset)
		return;

	t->bo = NULL;
	t->override_offset = offset;
	t->pp_txpitch &= (1 << 13) -1;
	pitch_val = pitch;

	switch (depth) {
	case 32:
		t->pp_txformat = R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8);
		pitch_val /= 4;
		break;
	case 24:
	default:
		t->pp_txformat = R300_EASY_TX_FORMAT(X, Y, Z, ONE, W8Z8Y8X8);
		pitch_val /= 4;
		break;
	case 16:
		t->pp_txformat = R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5);
		pitch_val /= 2;
		break;
	}
	pitch_val--;

	t->pp_txpitch |= pitch_val;
}

void r300SetTexBuffer2(__DRIcontext *pDRICtx, GLint target, GLint texture_format, __DRIdrawable *dPriv)
{
	struct gl_texture_unit *texUnit;
	struct gl_texture_object *texObj;
	struct gl_texture_image *texImage;
	struct radeon_renderbuffer *rb;
	radeon_texture_image *rImage;
	radeonContextPtr radeon;
	r300ContextPtr rmesa;
	struct radeon_framebuffer *rfb;
	radeonTexObjPtr t;
	uint32_t pitch_val;
	uint32_t internalFormat, type, format;
	gl_format texFormat;

	type = GL_BGRA;
	format = GL_UNSIGNED_BYTE;
	internalFormat = (texture_format == __DRI_TEXTURE_FORMAT_RGB ? 3 : 4);

	radeon = pDRICtx->driverPrivate;
	rmesa = pDRICtx->driverPrivate;

	rfb = dPriv->driverPrivate;
        texUnit = &radeon->glCtx->Texture.Unit[radeon->glCtx->Texture.CurrentUnit];
	texObj = _mesa_select_tex_object(radeon->glCtx, texUnit, target);
        texImage = _mesa_get_tex_image(radeon->glCtx, texObj, target, 0);

	rImage = get_radeon_texture_image(texImage);
	t = radeon_tex_obj(texObj);
        if (t == NULL) {
    	    return;
    	}

	radeon_update_renderbuffers(pDRICtx, dPriv, GL_TRUE);
	rb = rfb->color_rb[0];
	if (rb->bo == NULL) {
		/* Failed to BO for the buffer */
		return;
	}
	
	_mesa_lock_texture(radeon->glCtx, texObj);
	if (t->bo) {
		radeon_bo_unref(t->bo);
		t->bo = NULL;
	}
	if (rImage->bo) {
		radeon_bo_unref(rImage->bo);
		rImage->bo = NULL;
	}

	radeon_miptree_unreference(&t->mt);
	radeon_miptree_unreference(&rImage->mt);

	rImage->bo = rb->bo;
	radeon_bo_ref(rImage->bo);
	t->bo = rb->bo;
	radeon_bo_ref(t->bo);
	t->tile_bits = 0;
	t->image_override = GL_TRUE;
	t->override_offset = 0;
	t->pp_txpitch &= (1 << 13) -1;
	pitch_val = rb->pitch;
	switch (rb->cpp) {
	case 4:
		if (texture_format == __DRI_TEXTURE_FORMAT_RGB) {
			texFormat = MESA_FORMAT_RGB888;
			t->pp_txformat = R300_EASY_TX_FORMAT(X, Y, Z, ONE, W8Z8Y8X8);
		}
		else {
			texFormat = MESA_FORMAT_ARGB8888;
			t->pp_txformat = R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8);
		}
		pitch_val /= 4;
		break;
	case 3:
	default:
		texFormat = MESA_FORMAT_RGB888;
		t->pp_txformat = R300_EASY_TX_FORMAT(X, Y, Z, ONE, W8Z8Y8X8);
		pitch_val /= 4;
		break;
	case 2:
		texFormat = MESA_FORMAT_RGB565;
		t->pp_txformat = R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5);
		pitch_val /= 2;
		break;
	}

	_mesa_init_teximage_fields(radeon->glCtx, target, texImage,
				   rb->base.Width, rb->base.Height, 1, 0,
				   rb->cpp, texFormat);
	texImage->RowStride = rb->pitch / rb->cpp;


	pitch_val--;
	t->pp_txsize = (((R300_TX_WIDTHMASK_MASK & ((rb->base.Width - 1) << R300_TX_WIDTHMASK_SHIFT)))
			| ((R300_TX_HEIGHTMASK_MASK & ((rb->base.Height - 1) << R300_TX_HEIGHTMASK_SHIFT))));
	t->pp_txsize |= R300_TX_SIZE_TXPITCH_EN;
	t->pp_txpitch |= pitch_val;

	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
	    if (rb->base.Width > 2048)
		t->pp_txpitch |= R500_TXWIDTH_BIT11;
            else
		t->pp_txpitch &= ~R500_TXWIDTH_BIT11;
	    if (rb->base.Height > 2048)
		t->pp_txpitch |= R500_TXHEIGHT_BIT11;
            else
		t->pp_txpitch &= ~R500_TXHEIGHT_BIT11;
	}
	t->validated = GL_TRUE;
	_mesa_unlock_texture(radeon->glCtx, texObj);
	return;
}

void r300SetTexBuffer(__DRIcontext *pDRICtx, GLint target, __DRIdrawable *dPriv)
{
        r300SetTexBuffer2(pDRICtx, target, __DRI_TEXTURE_FORMAT_RGBA, dPriv);
}
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.5
log
@Merge Mesa 7.10.3
@
text
@d219 1
a219 1
	switch (tObj->DepthMode) {
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d155 2
a156 2
		case MESA_FORMAT_SRGBA8:
			return R300_EASY_TX_FORMAT(Y, Z, W, X, W8Z8Y8X8) | R300_TX_FORMAT_GAMMA;
d304 1
a304 1
static GLboolean r300_validate_texture(GLcontext * ctx, struct gl_texture_object *texObj)
d323 1
a323 1
GLboolean r300ValidateBuffers(GLcontext * ctx)
d431 1
a470 3
	_mesa_init_teximage_fields(radeon->glCtx, target, texImage,
				   rb->base.Width, rb->base.Height, 1, 0, rb->cpp);
	texImage->RowStride = rb->pitch / rb->cpp;
d482 2
a483 1
		if (texture_format == __DRI_TEXTURE_FORMAT_RGB)
d485 3
a487 1
		else
d489 1
d494 1
d499 1
d504 7
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a41 1
#include "main/texformat.h"
d45 1
d48 1
a48 3
#include "r300_state.h"
#include "r300_ioctl.h"
#include "radeon_ioctl.h"
a51 8
#define VALID_FORMAT(f) ( ((f) <= MESA_FORMAT_RGBA_DXT5			\
			   || ((f) >= MESA_FORMAT_RGBA_FLOAT32 &&	\
			       (f) <= MESA_FORMAT_INTENSITY_FLOAT16))	\
			  && tx_table[f].flag )

#define _ASSIGN(entry, format)				\
	[ MESA_FORMAT_ ## entry ] = { format, 0, 1}

d61 4
a64 4
static const struct tx_table {
	GLuint format, filter, flag;
} tx_table[] = {
	/* *INDENT-OFF* */
d66 8
a73 4
	_ASSIGN(RGBA8888, R300_EASY_TX_FORMAT(Y, Z, W, X, W8Z8Y8X8)),
	_ASSIGN(RGBA8888_REV, R300_EASY_TX_FORMAT(Z, Y, X, W, W8Z8Y8X8)),
	_ASSIGN(ARGB8888, R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8)),
	_ASSIGN(ARGB8888_REV, R300_EASY_TX_FORMAT(W, Z, Y, X, W8Z8Y8X8)),
d75 8
a82 4
	_ASSIGN(RGBA8888, R300_EASY_TX_FORMAT(Z, Y, X, W, W8Z8Y8X8)),
	_ASSIGN(RGBA8888_REV, R300_EASY_TX_FORMAT(Y, Z, W, X, W8Z8Y8X8)),
	_ASSIGN(ARGB8888, R300_EASY_TX_FORMAT(W, Z, Y, X, W8Z8Y8X8)),
	_ASSIGN(ARGB8888_REV, R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8)),
d84 88
a171 36
	_ASSIGN(RGB888, R300_EASY_TX_FORMAT(X, Y, Z, ONE, W8Z8Y8X8)),
	_ASSIGN(RGB565, R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5)),
	_ASSIGN(RGB565_REV, R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5)),
	_ASSIGN(ARGB4444, R300_EASY_TX_FORMAT(X, Y, Z, W, W4Z4Y4X4)),
	_ASSIGN(ARGB4444_REV, R300_EASY_TX_FORMAT(X, Y, Z, W, W4Z4Y4X4)),
	_ASSIGN(ARGB1555, R300_EASY_TX_FORMAT(X, Y, Z, W, W1Z5Y5X5)),
	_ASSIGN(ARGB1555_REV, R300_EASY_TX_FORMAT(X, Y, Z, W, W1Z5Y5X5)),
	_ASSIGN(AL88, R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8)),
	_ASSIGN(AL88_REV, R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8)),
	_ASSIGN(RGB332, R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z3Y3X2)),
	_ASSIGN(A8, R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, X8)),
	_ASSIGN(L8, R300_EASY_TX_FORMAT(X, X, X, ONE, X8)),
	_ASSIGN(I8, R300_EASY_TX_FORMAT(X, X, X, X, X8)),
	_ASSIGN(CI8, R300_EASY_TX_FORMAT(X, X, X, X, X8)),
	_ASSIGN(YCBCR, R300_EASY_TX_FORMAT(X, Y, Z, ONE, G8R8_G8B8) | R300_TX_FORMAT_YUV_MODE),
	_ASSIGN(YCBCR_REV, R300_EASY_TX_FORMAT(X, Y, Z, ONE, G8R8_G8B8) | R300_TX_FORMAT_YUV_MODE),
	_ASSIGN(RGB_DXT1, R300_EASY_TX_FORMAT(X, Y, Z, ONE, DXT1)),
	_ASSIGN(RGBA_DXT1, R300_EASY_TX_FORMAT(X, Y, Z, W, DXT1)),
	_ASSIGN(RGBA_DXT3, R300_EASY_TX_FORMAT(X, Y, Z, W, DXT3)),
	_ASSIGN(RGBA_DXT5, R300_EASY_TX_FORMAT(Y, Z, W, X, DXT5)),
	_ASSIGN(RGBA_FLOAT32, R300_EASY_TX_FORMAT(Z, Y, X, W, FL_R32G32B32A32)),
	_ASSIGN(RGBA_FLOAT16, R300_EASY_TX_FORMAT(Z, Y, X, W, FL_R16G16B16A16)),
	_ASSIGN(RGB_FLOAT32, 0xffffffff),
	_ASSIGN(RGB_FLOAT16, 0xffffffff),
	_ASSIGN(ALPHA_FLOAT32, R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, FL_I32)),
	_ASSIGN(ALPHA_FLOAT16, R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, FL_I16)),
	_ASSIGN(LUMINANCE_FLOAT32, R300_EASY_TX_FORMAT(X, X, X, ONE, FL_I32)),
	_ASSIGN(LUMINANCE_FLOAT16, R300_EASY_TX_FORMAT(X, X, X, ONE, FL_I16)),
	_ASSIGN(LUMINANCE_ALPHA_FLOAT32, R300_EASY_TX_FORMAT(X, X, X, Y, FL_I32A32)),
	_ASSIGN(LUMINANCE_ALPHA_FLOAT16, R300_EASY_TX_FORMAT(X, X, X, Y, FL_I16A16)),
	_ASSIGN(INTENSITY_FLOAT32, R300_EASY_TX_FORMAT(X, X, X, X, FL_I32)),
	_ASSIGN(INTENSITY_FLOAT16, R300_EASY_TX_FORMAT(X, X, X, X, FL_I16)),
	_ASSIGN(Z16, R300_EASY_TX_FORMAT(X, X, X, X, X16)),
	_ASSIGN(Z24_S8, R300_EASY_TX_FORMAT(X, X, X, X, X24_Y8)),
	_ASSIGN(Z32, R300_EASY_TX_FORMAT(X, X, X, X, X32)),
	/* *INDENT-ON* */
a173 2
#undef _ASSIGN

d183 3
a185 3
			R300_EASY_TX_FORMAT(X, X, X, ONE, X24_Y8),
			R300_EASY_TX_FORMAT(X, X, X, X, X24_Y8),
			R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, X24_Y8),
d194 1
a194 1
	r300TexObjPtr t;
d199 1
a199 2
	t = (r300TexObjPtr) tObj->DriverData;

d201 1
a201 1
	switch (tObj->Image[0][tObj->BaseLevel]->TexFormat->MesaFormat) {
d205 1
a205 1
	case MESA_FORMAT_Z24_S8:
d221 1
a221 1
		t->format = format[0];
d224 1
a224 1
		t->format = format[1];
d227 1
a227 1
		t->format = format[2];
d240 1
a240 2
 * Compute sizes and fill in offset and blit information for the given
 * image (determined by \p face and \p level).
d242 2
a243 2
 * \param curOffset points to the offset at which the image is to be stored
 * and is updated by this function according to the size of the image.
d245 1
a245 5
static void compute_tex_image_offset(
	struct gl_texture_object *tObj,
	GLuint face,
	GLint level,
	GLint* curOffset)
d247 2
a248 9
	r300TexObjPtr t = (r300TexObjPtr) tObj->DriverData;
	const struct gl_texture_image* texImage;
	GLuint blitWidth = R300_BLIT_WIDTH_BYTES;
	GLuint texelBytes;
	GLuint size;

	texImage = tObj->Image[0][level + t->base.firstLevel];
	if (!texImage)
		return;
d250 3
a252 13
	texelBytes = texImage->TexFormat->TexelBytes;

	/* find image size in bytes */
	if (texImage->IsCompressed) {
		if ((t->format & R300_TX_FORMAT_DXT1) ==
			R300_TX_FORMAT_DXT1) {
			// fprintf(stderr,"DXT 1 %d %08X\n", texImage->Width, t->format);
			if ((texImage->Width + 3) < 8)	/* width one block */
				size = texImage->CompressedSize * 4;
			else if ((texImage->Width + 3) < 16)
				size = texImage->CompressedSize * 2;
			else
				size = texImage->CompressedSize;
d254 7
a260 99
			/* DXT3/5, 16 bytes per block */
			WARN_ONCE
				("DXT 3/5 suffers from multitexturing problems!\n");
			// fprintf(stderr,"DXT 3/5 %d\n", texImage->Width);
			if ((texImage->Width + 3) < 8)
				size = texImage->CompressedSize * 2;
			else
				size = texImage->CompressedSize;
		}
	} else if (tObj->Target == GL_TEXTURE_RECTANGLE_NV) {
		size =
			((texImage->Width * texelBytes +
			63) & ~63) * texImage->Height;
		blitWidth = 64 / texelBytes;
	} else if (t->tile_bits & R300_TXO_MICRO_TILE) {
		/* tile pattern is 16 bytes x2. mipmaps stay 32 byte aligned,
			though the actual offset may be different (if texture is less than
			32 bytes width) to the untiled case */
		int w = (texImage->Width * texelBytes * 2 + 31) & ~31;
		size =
			(w * ((texImage->Height + 1) / 2)) *
			texImage->Depth;
		blitWidth = MAX2(texImage->Width, 64 / texelBytes);
	} else {
		int w = (texImage->Width * texelBytes + 31) & ~31;
		size = w * texImage->Height * texImage->Depth;
		blitWidth = MAX2(texImage->Width, 64 / texelBytes);
	}
	assert(size > 0);

	if (RADEON_DEBUG & DEBUG_TEXTURE)
		fprintf(stderr, "w=%d h=%d d=%d tb=%d intFormat=%d\n",
			texImage->Width, texImage->Height,
			texImage->Depth,
			texImage->TexFormat->TexelBytes,
			texImage->InternalFormat);

	/* All images are aligned to a 32-byte offset */
	*curOffset = (*curOffset + 0x1f) & ~0x1f;

	if (texelBytes) {
		/* fix x and y coords up later together with offset */
		t->image[face][level].x = *curOffset;
		t->image[face][level].y = 0;
		t->image[face][level].width =
			MIN2(size / texelBytes, blitWidth);
		t->image[face][level].height =
			(size / texelBytes) / t->image[face][level].width;
	} else {
		t->image[face][level].x = *curOffset % R300_BLIT_WIDTH_BYTES;
		t->image[face][level].y = *curOffset / R300_BLIT_WIDTH_BYTES;
		t->image[face][level].width =
			MIN2(size, R300_BLIT_WIDTH_BYTES);
		t->image[face][level].height = size / t->image[face][level].width;
	}

	if (RADEON_DEBUG & DEBUG_TEXTURE)
		fprintf(stderr,
			"level %d, face %d: %dx%d x=%d y=%d w=%d h=%d size=%d at %d\n",
			level, face, texImage->Width, texImage->Height,
			t->image[face][level].x, t->image[face][level].y,
			t->image[face][level].width, t->image[face][level].height,
			size, *curOffset);

	*curOffset += size;
}



/**
 * This function computes the number of bytes of storage needed for
 * the given texture object (all mipmap levels, all cube faces).
 * The \c image[face][level].x/y/width/height parameters for upload/blitting
 * are computed here.  \c filter, \c format, etc. will be set here
 * too.
 *
 * \param rmesa Context pointer
 * \param tObj GL texture object whose images are to be posted to
 *                 hardware state.
 */
static void r300SetTexImages(r300ContextPtr rmesa,
			     struct gl_texture_object *tObj)
{
	r300TexObjPtr t = (r300TexObjPtr) tObj->DriverData;
	const struct gl_texture_image *baseImage =
	    tObj->Image[0][tObj->BaseLevel];
	GLint curOffset;
	GLint i, texelBytes;
	GLint numLevels;
	GLint log2Width, log2Height, log2Depth;

	/* Set the hardware texture format
	 */
	if (!t->image_override
	    && VALID_FORMAT(baseImage->TexFormat->MesaFormat)) {
		if (baseImage->TexFormat->BaseFormat == GL_DEPTH_COMPONENT) {
			r300SetDepthTexMode(tObj);
		} else {
			t->format = tx_table[baseImage->TexFormat->MesaFormat].format;
d262 1
d264 1
a264 4
		t->filter |= tx_table[baseImage->TexFormat->MesaFormat].filter;
	} else if (!t->image_override) {
		_mesa_problem(NULL, "unexpected texture format in %s",
			      __FUNCTION__);
a265 1
	}
d267 4
a270 1
	texelBytes = baseImage->TexFormat->TexelBytes;
a271 15
	/* Compute which mipmap levels we really want to send to the hardware.
	 */
	driCalculateTextureFirstLastLevel((driTextureObject *) t);
	log2Width = tObj->Image[0][t->base.firstLevel]->WidthLog2;
	log2Height = tObj->Image[0][t->base.firstLevel]->HeightLog2;
	log2Depth = tObj->Image[0][t->base.firstLevel]->DepthLog2;

	numLevels = t->base.lastLevel - t->base.firstLevel + 1;

	assert(numLevels <= RADEON_MAX_TEXTURE_LEVELS);

	/* Calculate mipmap offsets and dimensions for blitting (uploading)
	 * The idea is that we lay out the mipmap levels within a block of
	 * memory organized as a rectangle of width BLIT_WIDTH_BYTES.
	 */
d274 4
a277 26
	/* figure out if this texture is suitable for tiling. */
#if 0				/* Disabled for now */
	if (texelBytes) {
		if ((tObj->Target != GL_TEXTURE_RECTANGLE_NV) &&
		    /* texrect might be able to use micro tiling too in theory? */
		    (baseImage->Height > 1)) {

			/* allow 32 (bytes) x 1 mip (which will use two times the space
			   the non-tiled version would use) max if base texture is large enough */
			if ((numLevels == 1) ||
			    (((baseImage->Width * texelBytes /
			       baseImage->Height) <= 32)
			     && (baseImage->Width * texelBytes > 64))
			    ||
			    ((baseImage->Width * texelBytes /
			      baseImage->Height) <= 16)) {
				t->tile_bits |= R300_TXO_MICRO_TILE;
			}
		}

		if (tObj->Target != GL_TEXTURE_RECTANGLE_NV) {
			/* we can set macro tiling even for small textures, they will be untiled anyway */
			t->tile_bits |= R300_TXO_MACRO_TILE;
		}
	}
#endif
a278 1
	curOffset = 0;
d280 3
a282 45
	if (tObj->Target == GL_TEXTURE_CUBE_MAP) {
		ASSERT(log2Width == log2Height);
		t->format |= R300_TX_FORMAT_CUBIC_MAP;

		for(i = 0; i < numLevels; i++) {
			GLuint face;
			for(face = 0; face < 6; face++)
				compute_tex_image_offset(tObj, face, i, &curOffset);
		}
	} else {
		if (tObj->Target == GL_TEXTURE_3D)
                	t->format |= R300_TX_FORMAT_3D;

		for (i = 0; i < numLevels; i++)
			compute_tex_image_offset(tObj, 0, i, &curOffset);
	}

	/* Align the total size of texture memory block.
	 */
	t->base.totalSize =
	    (curOffset + RADEON_OFFSET_MASK) & ~RADEON_OFFSET_MASK;

	t->size =
	    (((tObj->Image[0][t->base.firstLevel]->Width -
	       1) << R300_TX_WIDTHMASK_SHIFT)
	     | ((tObj->Image[0][t->base.firstLevel]->Height - 1) <<
		R300_TX_HEIGHTMASK_SHIFT)
	     | ((tObj->Image[0][t->base.firstLevel]->DepthLog2) <<
		R300_TX_DEPTHMASK_SHIFT))
	    | ((numLevels - 1) << R300_TX_MAX_MIP_LEVEL_SHIFT);

	t->pitch = 0;

	/* Only need to round to nearest 32 for textures, but the blitter
	 * requires 64-byte aligned pitches, and we may/may not need the
	 * blitter.   NPOT only!
	 */
	if (baseImage->IsCompressed) {
		t->pitch |=
		    (tObj->Image[0][t->base.firstLevel]->Width + 63) & ~(63);
	} else if (tObj->Target == GL_TEXTURE_RECTANGLE_NV) {
		unsigned int align = (64 / texelBytes) - 1;
		t->pitch |= ((tObj->Image[0][t->base.firstLevel]->Width *
			     texelBytes) + 63) & ~(63);
		t->size |= R300_TX_SIZE_TXPITCH_EN;
d284 1
a284 7
			t->pitch_reg =
			    (((tObj->Image[0][t->base.firstLevel]->Width) +
			      align) & ~align) - 1;
	} else {
		t->pitch |=
		    ((tObj->Image[0][t->base.firstLevel]->Width *
		      texelBytes) + 63) & ~(63);
d288 8
a295 4
	    if (tObj->Image[0][t->base.firstLevel]->Width > 2048)
		t->pitch_reg |= R500_TXWIDTH_BIT11;
	    if (tObj->Image[0][t->base.firstLevel]->Height > 2048)
		t->pitch_reg |= R500_TXHEIGHT_BIT11;
d299 4
a302 2
/* ================================================================
 * Texture unit state management
d304 1
a304 2

static GLboolean r300EnableTexture2D(GLcontext * ctx, int unit)
d307 8
a314 14
	struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
	struct gl_texture_object *tObj = texUnit->_Current;
	r300TexObjPtr t = (r300TexObjPtr) tObj->DriverData;

	ASSERT(tObj->Target == GL_TEXTURE_2D || tObj->Target == GL_TEXTURE_1D);

	if (t->base.dirty_images[0]) {
		R300_FIREVERTICES(rmesa);

		r300SetTexImages(rmesa, tObj);
		r300UploadTexImages(rmesa, (r300TexObjPtr) tObj->DriverData, 0);
		if (!t->base.memBlock && !t->image_override)
			return GL_FALSE;
	}
d316 1
d320 4
a323 1
static GLboolean r300EnableTexture3D(GLcontext * ctx, int unit)
d326 3
a328 3
	struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
	struct gl_texture_object *tObj = texUnit->_Current;
	r300TexObjPtr t = (r300TexObjPtr) tObj->DriverData;
d330 1
a330 1
	ASSERT(tObj->Target == GL_TEXTURE_3D);
d332 6
a337 3
	/* r300 does not support mipmaps for 3D textures. */
	if ((tObj->MinFilter != GL_NEAREST) && (tObj->MinFilter != GL_LINEAR)) {
		return GL_FALSE;
d340 6
a345 6
	if (t->base.dirty_images[0]) {
		R300_FIREVERTICES(rmesa);
		r300SetTexImages(rmesa, tObj);
		r300UploadTexImages(rmesa, (r300TexObjPtr) tObj->DriverData, 0);
		if (!t->base.memBlock)
			return GL_FALSE;
d347 3
d351 2
a352 2
	return GL_TRUE;
}
d354 4
a357 25
static GLboolean r300EnableTextureCube(GLcontext * ctx, int unit)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
	struct gl_texture_object *tObj = texUnit->_Current;
	r300TexObjPtr t = (r300TexObjPtr) tObj->DriverData;
	GLuint face;

	ASSERT(tObj->Target == GL_TEXTURE_CUBE_MAP);

	if (t->base.dirty_images[0] || t->base.dirty_images[1] ||
	    t->base.dirty_images[2] || t->base.dirty_images[3] ||
	    t->base.dirty_images[4] || t->base.dirty_images[5]) {
		/* flush */
		R300_FIREVERTICES(rmesa);
		/* layout memory space, once for all faces */
		r300SetTexImages(rmesa, tObj);
	}

	/* upload (per face) */
	for (face = 0; face < 6; face++) {
		if (t->base.dirty_images[face]) {
			r300UploadTexImages(rmesa,
					    (r300TexObjPtr) tObj->DriverData,
					    face);
d359 9
d370 2
a371 2
	if (!t->base.memBlock) {
		/* texmem alloc failed, use s/w fallback */
a372 24
	}

	return GL_TRUE;
}

static GLboolean r300EnableTextureRect(GLcontext * ctx, int unit)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
	struct gl_texture_object *tObj = texUnit->_Current;
	r300TexObjPtr t = (r300TexObjPtr) tObj->DriverData;

	ASSERT(tObj->Target == GL_TEXTURE_RECTANGLE_NV);

	if (t->base.dirty_images[0]) {
		R300_FIREVERTICES(rmesa);

		r300SetTexImages(rmesa, tObj);
		r300UploadTexImages(rmesa, (r300TexObjPtr) tObj->DriverData, 0);
		if (!t->base.memBlock && !t->image_override &&
		    !rmesa->prefer_gart_client_texturing)
			return GL_FALSE;
	}

a375 33
static GLboolean r300UpdateTexture(GLcontext * ctx, int unit)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
	struct gl_texture_object *tObj = texUnit->_Current;
	r300TexObjPtr t = (r300TexObjPtr) tObj->DriverData;

	/* Fallback if there's a texture border */
	if (tObj->Image[0][tObj->BaseLevel]->Border > 0)
		return GL_FALSE;

	/* Update state if this is a different texture object to last
	 * time.
	 */
	if (rmesa->state.texture.unit[unit].texobj != tObj) {
		if (rmesa->state.texture.unit[unit].texobj != NULL) {
			r300TexObjPtr t_old = (r300TexObjPtr) rmesa->state.texture.unit[unit].texobj->DriverData;

			/* The old texture is no longer bound to this texture unit.
			 * Mark it as such.
			 */

			t_old->base.bound &= ~(1 << unit);
		}

		_mesa_reference_texobj(&rmesa->state.texture.unit[unit].texobj, tObj);
		t->base.bound |= (1 << unit);
		driUpdateTextureLRU(&t->base);	/* XXX: should be locked! */
	}

	return !t->border_fallback;
}

d382 1
a382 1
	r300TexObjPtr t;
a387 2
	t = (r300TexObjPtr) tObj->DriverData;

d393 3
a395 2
	t->offset = offset;
	t->pitch_reg &= (1 << 13) -1;
d400 1
a400 2
		t->format = R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8);
		t->filter |= tx_table[2].filter;
d405 1
a405 2
		t->format = R300_EASY_TX_FORMAT(X, Y, Z, ONE, W8Z8Y8X8);
		t->filter |= tx_table[4].filter;
d409 1
a409 2
		t->format = R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5);
		t->filter |= tx_table[5].filter;
d415 1
a415 1
	t->pitch_reg |= pitch_val;
d418 1
a418 1
static GLboolean r300UpdateTextureUnit(GLcontext * ctx, int unit)
d420 11
a430 1
	struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
d432 67
a498 16
	if (texUnit->_ReallyEnabled & (TEXTURE_RECT_BIT)) {
		return (r300EnableTextureRect(ctx, unit) &&
			r300UpdateTexture(ctx, unit));
	} else if (texUnit->_ReallyEnabled & (TEXTURE_1D_BIT | TEXTURE_2D_BIT)) {
		return (r300EnableTexture2D(ctx, unit) &&
			r300UpdateTexture(ctx, unit));
	} else if (texUnit->_ReallyEnabled & (TEXTURE_3D_BIT)) {
		return (r300EnableTexture3D(ctx, unit) &&
			r300UpdateTexture(ctx, unit));
	} else if (texUnit->_ReallyEnabled & (TEXTURE_CUBE_BIT)) {
		return (r300EnableTextureCube(ctx, unit) &&
			r300UpdateTexture(ctx, unit));
	} else if (texUnit->_ReallyEnabled) {
		return GL_FALSE;
	} else {
		return GL_TRUE;
d500 19
d521 1
a521 1
void r300UpdateTextureState(GLcontext * ctx)
d523 1
a523 9
	int i;

	for (i = 0; i < 8; i++) {
		if (!r300UpdateTextureUnit(ctx, i)) {
			_mesa_warning(ctx,
				      "failed to update texture state for unit %d.\n",
				      i);
		}
	}
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d38 8
a45 8
#include "glheader.h"
#include "imports.h"
#include "context.h"
#include "macros.h"
#include "texformat.h"
#include "teximage.h"
#include "texobj.h"
#include "enums.h"
d570 1
a570 1
	if (rmesa->state.texture.unit[unit].texobj != t) {
d572 2
d578 1
a578 2
			rmesa->state.texture.unit[unit].texobj->base.bound &=
			    ~(1 << unit);
d581 1
a581 1
		rmesa->state.texture.unit[unit].texobj = t;
d583 1
a583 1
		driUpdateTextureLRU((driTextureObject *) t);	/* XXX: should be locked! */
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86: xc/lib/GL/mesa/src/drv/r300/r300_texstate.c,v 1.3 2003/02/15 22:18:47 dawes Exp $ */
d30 6
a35 3
/*
 * Authors:
 *   Keith Whitwell <keith@@tungstengraphics.com>
d43 2
a53 1

d62 10
a71 1
static const struct {
d74 49
a122 46
	/*
	 * Note that the _REV formats are the same as the non-REV formats.
	 * This is because the REV and non-REV formats are identical as a
	 * byte string, but differ when accessed as 16-bit or 32-bit words
	 * depending on the endianness of the host.  Since the textures are
	 * transferred to the R300 as a byte string (i.e. without any
	 * byte-swapping), the R300 sees the REV and non-REV formats
	 * identically.  -- paulus
	 */
	    _ASSIGN(RGBA8888, R300_EASY_TX_FORMAT(Y, Z, W, X, W8Z8Y8X8)),
	    _ASSIGN(RGBA8888_REV, R300_EASY_TX_FORMAT(Y, Z, W, X, W8Z8Y8X8)),
	    _ASSIGN(ARGB8888, R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8)),
	    _ASSIGN(ARGB8888_REV, R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8)),
	    _ASSIGN(RGB888, 0xffffffff),
	    _ASSIGN(RGB565, R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5)),
	    _ASSIGN(RGB565_REV, R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5)),
	    _ASSIGN(ARGB4444, R300_EASY_TX_FORMAT(X, Y, Z, W, W4Z4Y4X4)),
	    _ASSIGN(ARGB4444_REV, R300_EASY_TX_FORMAT(X, Y, Z, W, W4Z4Y4X4)),
	    _ASSIGN(ARGB1555, R300_EASY_TX_FORMAT(X, Y, Z, W, W1Z5Y5X5)),
	    _ASSIGN(ARGB1555_REV, R300_EASY_TX_FORMAT(X, Y, Z, W, W1Z5Y5X5)),
	    _ASSIGN(AL88, R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8)),
	    _ASSIGN(AL88_REV, R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8)),
	    _ASSIGN(RGB332, R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z3Y3X2)),
	    _ASSIGN(A8, R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, X8)),
	    _ASSIGN(L8, R300_EASY_TX_FORMAT(X, X, X, ONE, X8)),
	    _ASSIGN(I8, R300_EASY_TX_FORMAT(X, X, X, X, X8)),
	    _ASSIGN(CI8, R300_EASY_TX_FORMAT(X, X, X, X, X8)),
	    _ASSIGN(YCBCR, R300_EASY_TX_FORMAT(X, Y, Z, ONE, G8R8_G8B8)|R300_TX_FORMAT_YUV_MODE ),
	    _ASSIGN(YCBCR_REV, R300_EASY_TX_FORMAT(X, Y, Z, ONE, G8R8_G8B8)|R300_TX_FORMAT_YUV_MODE),
	    _ASSIGN(RGB_DXT1, R300_EASY_TX_FORMAT(X, Y, Z, ONE, DXT1)),
	    _ASSIGN(RGBA_DXT1, R300_EASY_TX_FORMAT(X, Y, Z, W, DXT1)),
	    _ASSIGN(RGBA_DXT3, R300_EASY_TX_FORMAT(X, Y, Z, W, DXT3)),
	    _ASSIGN(RGBA_DXT5, R300_EASY_TX_FORMAT(Y, Z, W, X, DXT5)),
	    _ASSIGN(RGBA_FLOAT32, R300_EASY_TX_FORMAT(Z, Y, X, W, FL_R32G32B32A32)),
	    _ASSIGN(RGBA_FLOAT16, R300_EASY_TX_FORMAT(Z, Y, X, W, FL_R16G16B16A16)),
	    _ASSIGN(RGB_FLOAT32, 0xffffffff),
	    _ASSIGN(RGB_FLOAT16, 0xffffffff),
	    _ASSIGN(ALPHA_FLOAT32, R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, FL_I32)),
	    _ASSIGN(ALPHA_FLOAT16, R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, FL_I16)),
	    _ASSIGN(LUMINANCE_FLOAT32, R300_EASY_TX_FORMAT(X, X, X, ONE, FL_I32)),
	    _ASSIGN(LUMINANCE_FLOAT16, R300_EASY_TX_FORMAT(X, X, X, ONE, FL_I16)),
	    _ASSIGN(LUMINANCE_ALPHA_FLOAT32, R300_EASY_TX_FORMAT(X, X, X, Y, FL_I32A32)),
	    _ASSIGN(LUMINANCE_ALPHA_FLOAT16, R300_EASY_TX_FORMAT(X, X, X, Y, FL_I16A16)),
	    _ASSIGN(INTENSITY_FLOAT32, R300_EASY_TX_FORMAT(X, X, X, X, FL_I32)),
	    _ASSIGN(INTENSITY_FLOAT16, R300_EASY_TX_FORMAT(X, X, X, X, FL_I16)),
	    };
d126 171
d315 1
a315 1
	GLint curOffset, blitWidth;
d322 10
a331 7
	if (VALID_FORMAT(baseImage->TexFormat->MesaFormat) &&
	    tx_table[baseImage->TexFormat->MesaFormat].flag) {
		t->format =
		    tx_table[baseImage->TexFormat->MesaFormat].format;
		t->filter |=
		    tx_table[baseImage->TexFormat->MesaFormat].filter;
	} else {
a353 2
	curOffset = 0;
	blitWidth = R300_BLIT_WIDTH_BYTES;
d357 1
a357 1
#if 0 /* Disabled for now */
d359 4
a362 4
		if (rmesa->texmicrotile  && (tObj->Target != GL_TEXTURE_RECTANGLE_NV) &&
		   /* texrect might be able to use micro tiling too in theory? */
		   (baseImage->Height > 1)) {
			
d366 6
a371 3
				(((baseImage->Width * texelBytes / baseImage->Height) <= 32) &&
				(baseImage->Width * texelBytes > 64)) ||
				((baseImage->Width * texelBytes / baseImage->Height) <= 16)) {
d375 1
a375 1
		
d383 17
a399 84
	for (i = 0; i < numLevels; i++) {
	  const struct gl_texture_image *texImage;
	  GLuint size;
	  
	  texImage = tObj->Image[0][i + t->base.firstLevel];
	  if (!texImage)
	    break;
	  
	  /* find image size in bytes */
	  if (texImage->IsCompressed) {
	    if ((t->format & R300_TX_FORMAT_DXT1) == R300_TX_FORMAT_DXT1) {
	      // fprintf(stderr,"DXT 1 %d %08X\n", texImage->Width, t->format);
	      if ((texImage->Width + 3) < 8) /* width one block */
		size = texImage->CompressedSize * 4;
	      else if ((texImage->Width + 3) < 16)
		size = texImage->CompressedSize * 2;
	      else size = texImage->CompressedSize;
	    }
	    else /* DXT3/5, 16 bytes per block */
	    {
	      WARN_ONCE("DXT 3/5 suffers from multitexturing problems!\n");
	      // fprintf(stderr,"DXT 3/5 %d\n", texImage->Width);
	      if ((texImage->Width + 3) < 8)
		size = texImage->CompressedSize * 2;
	      else size = texImage->CompressedSize;
	    }
	    
	  } else if (tObj->Target == GL_TEXTURE_RECTANGLE_NV) {
	    size = ((texImage->Width * texelBytes + 63) & ~63) * texImage->Height;
	    blitWidth = 64 / texelBytes;
	  } else if (t->tile_bits & R300_TXO_MICRO_TILE) {
		/* tile pattern is 16 bytes x2. mipmaps stay 32 byte aligned,
		   though the actual offset may be different (if texture is less than
		   32 bytes width) to the untiled case */
		int w = (texImage->Width * texelBytes * 2 + 31) & ~31;
		size = (w * ((texImage->Height + 1) / 2)) * texImage->Depth;
		blitWidth = MAX2(texImage->Width, 64 / texelBytes);
	  } else {
	    int w = (texImage->Width * texelBytes + 31) & ~31;
	    size = w * texImage->Height * texImage->Depth;
	    blitWidth = MAX2(texImage->Width, 64 / texelBytes);
	  }
	  assert(size > 0);
	  
	  if(0)
	    fprintf(stderr, "w=%d h=%d d=%d tb=%d intFormat=%d\n", texImage->Width, texImage->Height,
		    texImage->Depth, texImage->TexFormat->TexelBytes,
		    texImage->InternalFormat);
	  
	  /* Align to 32-byte offset.  It is faster to do this unconditionally
	   * (no branch penalty).
	   */
	  
	  curOffset = (curOffset + 0x1f) & ~0x1f;
	  
	  if (texelBytes) {
	    t->image[0][i].x = curOffset; /* fix x and y coords up later together with offset */
	    t->image[0][i].y = 0;
	    t->image[0][i].width = MIN2(size / texelBytes, blitWidth);
	    t->image[0][i].height = (size / texelBytes) / t->image[0][i].width;
	  } else {
	    t->image[0][i].x = curOffset % R300_BLIT_WIDTH_BYTES;
	    t->image[0][i].y = curOffset / R300_BLIT_WIDTH_BYTES;
	    t->image[0][i].width = MIN2(size, R300_BLIT_WIDTH_BYTES);
	    t->image[0][i].height = size / t->image[0][i].width;
	  }
#if 0
	  /* for debugging only and only  applicable to non-rectangle targets */
	  assert(size % t->image[0][i].width == 0);
	  assert(t->image[0][i].x == 0
		 || (size < R300_BLIT_WIDTH_BYTES
		     && t->image[0][i].height == 1));
#endif
	  
	  if (0)
	    fprintf(stderr,
		    "level %d: %dx%d x=%d y=%d w=%d h=%d size=%d at %d\n",
		    i, texImage->Width, texImage->Height,
		    t->image[0][i].x, t->image[0][i].y,
		    t->image[0][i].width, t->image[0][i].height,
		    size, curOffset);
	  
	  curOffset += size;
	  
d401 1
a401 1
	
d407 8
a414 14
	/* Setup remaining cube face blits, if needed */
	if (tObj->Target == GL_TEXTURE_CUBE_MAP) {
		GLuint face;
		for (face = 1; face < 6; face++) {
			for (i = 0; i < numLevels; i++) {
				t->image[face][i].x = t->image[0][i].x;
				t->image[face][i].y = t->image[0][i].y;
				t->image[face][i].width = t->image[0][i].width;
				t->image[face][i].height =
				    t->image[0][i].height;
			}
		}
		t->base.totalSize *= 6;	/* total texmem needed */
	}
d416 1
a416 39
	/* Hardware state:
	 */
#if 0
	t->format &= ~(R200_TXFORMAT_WIDTH_MASK |
			    R200_TXFORMAT_HEIGHT_MASK |
			    R200_TXFORMAT_CUBIC_MAP_ENABLE |
			    R200_TXFORMAT_F5_WIDTH_MASK |
			    R200_TXFORMAT_F5_HEIGHT_MASK);
	t->format |= ((log2Width << R200_TXFORMAT_WIDTH_SHIFT) |
			   (log2Height << R200_TXFORMAT_HEIGHT_SHIFT));
#endif
#if 0
	t->format_x &= ~(R200_DEPTH_LOG2_MASK | R200_TEXCOORD_MASK);
	if (tObj->Target == GL_TEXTURE_3D) {
		t->format_x |= (log2Depth << R200_DEPTH_LOG2_SHIFT);
		t->format_x |= R200_TEXCOORD_VOLUME;
	} else if (tObj->Target == GL_TEXTURE_CUBE_MAP) {
		ASSERT(log2Width == log2Height);
		t->format |= R300_TX_FORMAT_CUBIC_MAP;
		
		t->format_x |= R200_TEXCOORD_CUBIC_ENV;
		t->pp_cubic_faces = ((log2Width << R200_FACE_WIDTH_1_SHIFT) |
				     (log2Height << R200_FACE_HEIGHT_1_SHIFT) |
				     (log2Width << R200_FACE_WIDTH_2_SHIFT) |
				     (log2Height << R200_FACE_HEIGHT_2_SHIFT) |
				     (log2Width << R200_FACE_WIDTH_3_SHIFT) |
				     (log2Height << R200_FACE_HEIGHT_3_SHIFT) |
				     (log2Width << R200_FACE_WIDTH_4_SHIFT) |
				     (log2Height << R200_FACE_HEIGHT_4_SHIFT));
	}
#endif
	if (tObj->Target == GL_TEXTURE_CUBE_MAP) {
		ASSERT(log2Width == log2Height);
		t->format |= R300_TX_FORMAT_CUBIC_MAP;
	}
	
	t->size = (((tObj->Image[0][t->base.firstLevel]->Width - 1) << R300_TX_WIDTHMASK_SHIFT)
			|((tObj->Image[0][t->base.firstLevel]->Height - 1) << R300_TX_HEIGHTMASK_SHIFT))
			|((numLevels - 1) << R300_TX_MAX_MIP_LEVEL_SHIFT);
d423 1
a423 1
		t->pitch =
d425 4
a428 5
	}
	else if (tObj->Target == GL_TEXTURE_RECTANGLE_NV) {
		unsigned int align = blitWidth - 1;
		t->pitch = ((tObj->Image[0][t->base.firstLevel]->Width *
		      texelBytes) + 63) & ~(63);
d430 6
a435 4
		t->pitch_reg = (((tObj->Image[0][t->base.firstLevel]->Width) + align) & ~align) - 1;
	}
	else {
		t->pitch =
d440 6
a445 3
	t->dirty_state = TEX_ALL;

	/* FYI: r300UploadTexImages( rmesa, t ) used to be called here */
a447 1

d452 1
a452 1
static GLboolean enable_tex_2d(GLcontext * ctx, int unit)
d463 1
d466 1
a466 1
		if (!t->base.memBlock)
d473 1
a473 2
#if ENABLE_HW_3D_TEXTURE
static GLboolean enable_tex_3d(GLcontext * ctx, int unit)
a479 8
	/* Need to load the 3d images associated with this unit.
	 */
#if 0
	if (t->format & R200_TXFORMAT_NON_POWER2) {
		t->format &= ~R200_TXFORMAT_NON_POWER2;
		t->base.dirty_images[0] = ~0;
	}
#endif
d482 1
a482 2
	/* R100 & R200 do not support mipmaps for 3D textures.
	 */
a496 1
#endif
d498 1
a498 1
static GLboolean enable_tex_cube(GLcontext * ctx, int unit)
a505 9
	/* Need to load the 2d images associated with this unit.
	 */
#if 0
	if (t->format & R200_TXFORMAT_NON_POWER2) {
		t->format &= ~R200_TXFORMAT_NON_POWER2;
		for (face = 0; face < 6; face++)
			t->base.dirty_images[face] = ~0;
	}
#endif
d534 1
a534 1
static GLboolean enable_tex_rect(GLcontext * ctx, int unit)
d545 1
d548 2
a549 1
		if (!t->base.memBlock && !rmesa->prefer_gart_client_texturing)
d556 1
a556 1
static GLboolean update_tex_common(GLcontext * ctx, int unit)
d577 1
a577 1
			    ~(1UL << unit);
d581 1
a581 2
		t->base.bound |= (1UL << unit);
		t->dirty_state |= 1 << unit;
d588 46
d639 2
a640 2
		return (enable_tex_rect(ctx, unit) &&
			update_tex_common(ctx, unit));
d642 8
a649 12
		return (enable_tex_2d(ctx, unit) &&
			update_tex_common(ctx, unit));
	}
#if ENABLE_HW_3D_TEXTURE
	else if (texUnit->_ReallyEnabled & (TEXTURE_3D_BIT)) {
		return (enable_tex_3d(ctx, unit) &&
			update_tex_common(ctx, unit));
	}
#endif
	else if (texUnit->_ReallyEnabled & (TEXTURE_CUBE_BIT)) {
		return (enable_tex_cube(ctx, unit) &&
			update_tex_common(ctx, unit));
d654 1
a654 1
 	}
d659 1
a659 1
	GLboolean ok;
d661 7
a667 9
	ok = (r300UpdateTextureUnit(ctx, 0) &&
	      r300UpdateTextureUnit(ctx, 1) &&
	      r300UpdateTextureUnit(ctx, 2) &&
	      r300UpdateTextureUnit(ctx, 3) &&
	      r300UpdateTextureUnit(ctx, 4) &&
	      r300UpdateTextureUnit(ctx, 5) &&
	      r300UpdateTextureUnit(ctx, 6) &&
	      r300UpdateTextureUnit(ctx, 7)
	      );
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d54 1
a54 1
			  && tx_table_le[f].flag )
d61 1
a61 1
} tx_table_be[] = {
d71 1
a71 1
	    _ASSIGN(RGBA8888, R300_EASY_TX_FORMAT(Z, Y, X, W, W8Z8Y8X8)),
d73 1
a73 1
	    _ASSIGN(ARGB8888, R300_EASY_TX_FORMAT(W, Z, Y, X, W8Z8Y8X8)),
a108 41
static const struct {
	GLuint format, filter, flag;
} tx_table_le[] = {
	    _ASSIGN(RGBA8888, R300_EASY_TX_FORMAT(Y, Z, W, X, W8Z8Y8X8)),
	    _ASSIGN(RGBA8888_REV, R300_EASY_TX_FORMAT(Z, Y, X, W, W8Z8Y8X8)),
	    _ASSIGN(ARGB8888, R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8)),
	    _ASSIGN(ARGB8888_REV, R300_EASY_TX_FORMAT(W, Z, Y, X, W8Z8Y8X8)),
	    _ASSIGN(RGB888, 0xffffffff),
	    _ASSIGN(RGB565, R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5)),
	    _ASSIGN(RGB565_REV, R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5)),
	    _ASSIGN(ARGB4444, R300_EASY_TX_FORMAT(X, Y, Z, W, W4Z4Y4X4)),
	    _ASSIGN(ARGB4444_REV, R300_EASY_TX_FORMAT(X, Y, Z, W, W4Z4Y4X4)),
	    _ASSIGN(ARGB1555, R300_EASY_TX_FORMAT(X, Y, Z, W, W1Z5Y5X5)),
	    _ASSIGN(ARGB1555_REV, R300_EASY_TX_FORMAT(X, Y, Z, W, W1Z5Y5X5)),
	    _ASSIGN(AL88, R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8)),
	    _ASSIGN(AL88_REV, R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8)),
	    _ASSIGN(RGB332, R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z3Y3X2)),
	    _ASSIGN(A8, R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, X8)),
	    _ASSIGN(L8, R300_EASY_TX_FORMAT(X, X, X, ONE, X8)),
	    _ASSIGN(I8, R300_EASY_TX_FORMAT(X, X, X, X, X8)),
	    _ASSIGN(CI8, R300_EASY_TX_FORMAT(X, X, X, X, X8)),
	    _ASSIGN(YCBCR, R300_EASY_TX_FORMAT(X, Y, Z, ONE, G8R8_G8B8)|R300_TX_FORMAT_YUV_MODE ),
	    _ASSIGN(YCBCR_REV, R300_EASY_TX_FORMAT(X, Y, Z, ONE, G8R8_G8B8)|R300_TX_FORMAT_YUV_MODE),
	    _ASSIGN(RGB_DXT1, R300_EASY_TX_FORMAT(X, Y, Z, ONE, DXT1)),
	    _ASSIGN(RGBA_DXT1, R300_EASY_TX_FORMAT(X, Y, Z, W, DXT1)),
	    _ASSIGN(RGBA_DXT3, R300_EASY_TX_FORMAT(X, Y, Z, W, DXT3)),
	    _ASSIGN(RGBA_DXT5, R300_EASY_TX_FORMAT(Y, Z, W, X, DXT5)),
	    _ASSIGN(RGBA_FLOAT32, R300_EASY_TX_FORMAT(Z, Y, X, W, FL_R32G32B32A32)),
	    _ASSIGN(RGBA_FLOAT16, R300_EASY_TX_FORMAT(Z, Y, X, W, FL_R16G16B16A16)),
	    _ASSIGN(RGB_FLOAT32, 0xffffffff),
	    _ASSIGN(RGB_FLOAT16, 0xffffffff),
	    _ASSIGN(ALPHA_FLOAT32, R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, FL_I32)),
	    _ASSIGN(ALPHA_FLOAT16, R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, FL_I16)),
	    _ASSIGN(LUMINANCE_FLOAT32, R300_EASY_TX_FORMAT(X, X, X, ONE, FL_I32)),
	    _ASSIGN(LUMINANCE_FLOAT16, R300_EASY_TX_FORMAT(X, X, X, ONE, FL_I16)),
	    _ASSIGN(LUMINANCE_ALPHA_FLOAT32, R300_EASY_TX_FORMAT(X, X, X, Y, FL_I32A32)),
	    _ASSIGN(LUMINANCE_ALPHA_FLOAT16, R300_EASY_TX_FORMAT(X, X, X, Y, FL_I16A16)),
	    _ASSIGN(INTENSITY_FLOAT32, R300_EASY_TX_FORMAT(X, X, X, X, FL_I32)),
	    _ASSIGN(INTENSITY_FLOAT16, R300_EASY_TX_FORMAT(X, X, X, X, FL_I16)),
	    };

d136 6
a141 12
	if (VALID_FORMAT(baseImage->TexFormat->MesaFormat)) {
		if (_mesa_little_endian()) {
			t->format =
			    tx_table_le[baseImage->TexFormat->MesaFormat].format;
			t->filter |=
			    tx_table_le[baseImage->TexFormat->MesaFormat].filter;
		} else {
			t->format =
			    tx_table_be[baseImage->TexFormat->MesaFormat].format;
			t->filter |=
			    tx_table_be[baseImage->TexFormat->MesaFormat].filter;
		}
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d1 1
d31 3
a33 6
/**
 * \file
 *
 * \author Keith Whitwell <keith@@tungstengraphics.com>
 *
 * \todo Enable R300 texture tiling code?
a40 2
#include "teximage.h"
#include "texobj.h"
d50 1
d59 49
a107 8
/*
 * Note that the _REV formats are the same as the non-REV formats.  This is
 * because the REV and non-REV formats are identical as a byte string, but
 * differ when accessed as 16-bit or 32-bit words depending on the endianness of
 * the host.  Since the textures are transferred to the R300 as a byte string
 * (i.e. without any byte-swapping), the R300 sees the REV and non-REV formats
 * identically.  -- paulus
 */
d109 1
a109 1
static const struct tx_table {
d111 38
a148 81
} tx_table_be[] = {
	/* *INDENT-OFF* */
	_ASSIGN(RGBA8888, R300_EASY_TX_FORMAT(Z, Y, X, W, W8Z8Y8X8)),
	_ASSIGN(RGBA8888_REV, R300_EASY_TX_FORMAT(Y, Z, W, X, W8Z8Y8X8)),
	_ASSIGN(ARGB8888, R300_EASY_TX_FORMAT(W, Z, Y, X, W8Z8Y8X8)),
	_ASSIGN(ARGB8888_REV, R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8)),
	_ASSIGN(RGB888, 0xffffffff),
	_ASSIGN(RGB565, R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5)),
	_ASSIGN(RGB565_REV, R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5)),
	_ASSIGN(ARGB4444, R300_EASY_TX_FORMAT(X, Y, Z, W, W4Z4Y4X4)),
	_ASSIGN(ARGB4444_REV, R300_EASY_TX_FORMAT(X, Y, Z, W, W4Z4Y4X4)),
	_ASSIGN(ARGB1555, R300_EASY_TX_FORMAT(X, Y, Z, W, W1Z5Y5X5)),
	_ASSIGN(ARGB1555_REV, R300_EASY_TX_FORMAT(X, Y, Z, W, W1Z5Y5X5)),
	_ASSIGN(AL88, R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8)),
	_ASSIGN(AL88_REV, R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8)),
	_ASSIGN(RGB332, R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z3Y3X2)),
	_ASSIGN(A8, R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, X8)),
	_ASSIGN(L8, R300_EASY_TX_FORMAT(X, X, X, ONE, X8)),
	_ASSIGN(I8, R300_EASY_TX_FORMAT(X, X, X, X, X8)),
	_ASSIGN(CI8, R300_EASY_TX_FORMAT(X, X, X, X, X8)),
	_ASSIGN(YCBCR, R300_EASY_TX_FORMAT(X, Y, Z, ONE, G8R8_G8B8)|R300_TX_FORMAT_YUV_MODE ),
	_ASSIGN(YCBCR_REV, R300_EASY_TX_FORMAT(X, Y, Z, ONE, G8R8_G8B8)|R300_TX_FORMAT_YUV_MODE),
	_ASSIGN(RGB_DXT1, R300_EASY_TX_FORMAT(X, Y, Z, ONE, DXT1)),
	_ASSIGN(RGBA_DXT1, R300_EASY_TX_FORMAT(X, Y, Z, W, DXT1)),
	_ASSIGN(RGBA_DXT3, R300_EASY_TX_FORMAT(X, Y, Z, W, DXT3)),
	_ASSIGN(RGBA_DXT5, R300_EASY_TX_FORMAT(Y, Z, W, X, DXT5)),
	_ASSIGN(RGBA_FLOAT32, R300_EASY_TX_FORMAT(Z, Y, X, W, FL_R32G32B32A32)),
	_ASSIGN(RGBA_FLOAT16, R300_EASY_TX_FORMAT(Z, Y, X, W, FL_R16G16B16A16)),
	_ASSIGN(RGB_FLOAT32, 0xffffffff),
	_ASSIGN(RGB_FLOAT16, 0xffffffff),
	_ASSIGN(ALPHA_FLOAT32, R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, FL_I32)),
	_ASSIGN(ALPHA_FLOAT16, R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, FL_I16)),
	_ASSIGN(LUMINANCE_FLOAT32, R300_EASY_TX_FORMAT(X, X, X, ONE, FL_I32)),
	_ASSIGN(LUMINANCE_FLOAT16, R300_EASY_TX_FORMAT(X, X, X, ONE, FL_I16)),
	_ASSIGN(LUMINANCE_ALPHA_FLOAT32, R300_EASY_TX_FORMAT(X, X, X, Y, FL_I32A32)),
	_ASSIGN(LUMINANCE_ALPHA_FLOAT16, R300_EASY_TX_FORMAT(X, X, X, Y, FL_I16A16)),
	_ASSIGN(INTENSITY_FLOAT32, R300_EASY_TX_FORMAT(X, X, X, X, FL_I32)),
	_ASSIGN(INTENSITY_FLOAT16, R300_EASY_TX_FORMAT(X, X, X, X, FL_I16)),
	/* *INDENT-ON* */
};

static const struct tx_table tx_table_le[] = {
	/* *INDENT-OFF* */
	_ASSIGN(RGBA8888, R300_EASY_TX_FORMAT(Y, Z, W, X, W8Z8Y8X8)),
	_ASSIGN(RGBA8888_REV, R300_EASY_TX_FORMAT(Z, Y, X, W, W8Z8Y8X8)),
	_ASSIGN(ARGB8888, R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8)),
	_ASSIGN(ARGB8888_REV, R300_EASY_TX_FORMAT(W, Z, Y, X, W8Z8Y8X8)),
	_ASSIGN(RGB888, R300_EASY_TX_FORMAT(X, Y, Z, ONE, W8Z8Y8X8)),
	_ASSIGN(RGB565, R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5)),
	_ASSIGN(RGB565_REV, R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5)),
	_ASSIGN(ARGB4444, R300_EASY_TX_FORMAT(X, Y, Z, W, W4Z4Y4X4)),
	_ASSIGN(ARGB4444_REV, R300_EASY_TX_FORMAT(X, Y, Z, W, W4Z4Y4X4)),
	_ASSIGN(ARGB1555, R300_EASY_TX_FORMAT(X, Y, Z, W, W1Z5Y5X5)),
	_ASSIGN(ARGB1555_REV, R300_EASY_TX_FORMAT(X, Y, Z, W, W1Z5Y5X5)),
	_ASSIGN(AL88, R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8)),
	_ASSIGN(AL88_REV, R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8)),
	_ASSIGN(RGB332, R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z3Y3X2)),
	_ASSIGN(A8, R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, X8)),
	_ASSIGN(L8, R300_EASY_TX_FORMAT(X, X, X, ONE, X8)),
	_ASSIGN(I8, R300_EASY_TX_FORMAT(X, X, X, X, X8)),
	_ASSIGN(CI8, R300_EASY_TX_FORMAT(X, X, X, X, X8)),
	_ASSIGN(YCBCR, R300_EASY_TX_FORMAT(X, Y, Z, ONE, G8R8_G8B8)|R300_TX_FORMAT_YUV_MODE ),
	_ASSIGN(YCBCR_REV, R300_EASY_TX_FORMAT(X, Y, Z, ONE, G8R8_G8B8)|R300_TX_FORMAT_YUV_MODE),
	_ASSIGN(RGB_DXT1, R300_EASY_TX_FORMAT(X, Y, Z, ONE, DXT1)),
	_ASSIGN(RGBA_DXT1, R300_EASY_TX_FORMAT(X, Y, Z, W, DXT1)),
	_ASSIGN(RGBA_DXT3, R300_EASY_TX_FORMAT(X, Y, Z, W, DXT3)),
	_ASSIGN(RGBA_DXT5, R300_EASY_TX_FORMAT(Y, Z, W, X, DXT5)),
	_ASSIGN(RGBA_FLOAT32, R300_EASY_TX_FORMAT(Z, Y, X, W, FL_R32G32B32A32)),
	_ASSIGN(RGBA_FLOAT16, R300_EASY_TX_FORMAT(Z, Y, X, W, FL_R16G16B16A16)),
	_ASSIGN(RGB_FLOAT32, 0xffffffff),
	_ASSIGN(RGB_FLOAT16, 0xffffffff),
	_ASSIGN(ALPHA_FLOAT32, R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, FL_I32)),
	_ASSIGN(ALPHA_FLOAT16, R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, FL_I16)),
	_ASSIGN(LUMINANCE_FLOAT32, R300_EASY_TX_FORMAT(X, X, X, ONE, FL_I32)),
	_ASSIGN(LUMINANCE_FLOAT16, R300_EASY_TX_FORMAT(X, X, X, ONE, FL_I16)),
	_ASSIGN(LUMINANCE_ALPHA_FLOAT32, R300_EASY_TX_FORMAT(X, X, X, Y, FL_I32A32)),
	_ASSIGN(LUMINANCE_ALPHA_FLOAT16, R300_EASY_TX_FORMAT(X, X, X, Y, FL_I16A16)),
	_ASSIGN(INTENSITY_FLOAT32, R300_EASY_TX_FORMAT(X, X, X, X, FL_I32)),
	_ASSIGN(INTENSITY_FLOAT16, R300_EASY_TX_FORMAT(X, X, X, X, FL_I16)),
	/* *INDENT-ON* */
};
d152 1
d177 1
a177 1
	if (!t->image_override && VALID_FORMAT(baseImage->TexFormat->MesaFormat)) {
d180 1
a180 2
			    tx_table_le[baseImage->TexFormat->MesaFormat].
			    format;
d182 1
a182 2
			    tx_table_le[baseImage->TexFormat->MesaFormat].
			    filter;
d185 1
a185 2
			    tx_table_be[baseImage->TexFormat->MesaFormat].
			    format;
d187 1
a187 2
			    tx_table_be[baseImage->TexFormat->MesaFormat].
			    filter;
d189 1
a189 1
	} else if (!t->image_override) {
d217 1
a217 1
#if 0				/* Disabled for now */
d219 4
a222 4
		if ((tObj->Target != GL_TEXTURE_RECTANGLE_NV) &&
		    /* texrect might be able to use micro tiling too in theory? */
		    (baseImage->Height > 1)) {

d226 3
a228 6
			    (((baseImage->Width * texelBytes /
			       baseImage->Height) <= 32)
			     && (baseImage->Width * texelBytes > 64))
			    ||
			    ((baseImage->Width * texelBytes /
			      baseImage->Height) <= 16)) {
d232 1
a232 1

d241 83
a323 87
		const struct gl_texture_image *texImage;
		GLuint size;

		texImage = tObj->Image[0][i + t->base.firstLevel];
		if (!texImage)
			break;

		/* find image size in bytes */
		if (texImage->IsCompressed) {
			if ((t->format & R300_TX_FORMAT_DXT1) ==
			    R300_TX_FORMAT_DXT1) {
				// fprintf(stderr,"DXT 1 %d %08X\n", texImage->Width, t->format);
				if ((texImage->Width + 3) < 8)	/* width one block */
					size = texImage->CompressedSize * 4;
				else if ((texImage->Width + 3) < 16)
					size = texImage->CompressedSize * 2;
				else
					size = texImage->CompressedSize;
			} else {
				/* DXT3/5, 16 bytes per block */
				WARN_ONCE
				    ("DXT 3/5 suffers from multitexturing problems!\n");
				// fprintf(stderr,"DXT 3/5 %d\n", texImage->Width);
				if ((texImage->Width + 3) < 8)
					size = texImage->CompressedSize * 2;
				else
					size = texImage->CompressedSize;
			}
		} else if (tObj->Target == GL_TEXTURE_RECTANGLE_NV) {
			size =
			    ((texImage->Width * texelBytes +
			      63) & ~63) * texImage->Height;
			blitWidth = 64 / texelBytes;
		} else if (t->tile_bits & R300_TXO_MICRO_TILE) {
			/* tile pattern is 16 bytes x2. mipmaps stay 32 byte aligned,
			   though the actual offset may be different (if texture is less than
			   32 bytes width) to the untiled case */
			int w = (texImage->Width * texelBytes * 2 + 31) & ~31;
			size =
			    (w * ((texImage->Height + 1) / 2)) *
			    texImage->Depth;
			blitWidth = MAX2(texImage->Width, 64 / texelBytes);
		} else {
			int w = (texImage->Width * texelBytes + 31) & ~31;
			size = w * texImage->Height * texImage->Depth;
			blitWidth = MAX2(texImage->Width, 64 / texelBytes);
		}
		assert(size > 0);

		if (RADEON_DEBUG & DEBUG_TEXTURE)
			fprintf(stderr, "w=%d h=%d d=%d tb=%d intFormat=%d\n",
				texImage->Width, texImage->Height,
				texImage->Depth,
				texImage->TexFormat->TexelBytes,
				texImage->InternalFormat);

		/* Align to 32-byte offset.  It is faster to do this unconditionally
		 * (no branch penalty).
		 */

		curOffset = (curOffset + 0x1f) & ~0x1f;

		if (texelBytes) {
			/* fix x and y coords up later together with offset */
			t->image[0][i].x = curOffset;
			t->image[0][i].y = 0;
			t->image[0][i].width =
			    MIN2(size / texelBytes, blitWidth);
			t->image[0][i].height =
			    (size / texelBytes) / t->image[0][i].width;
		} else {
			t->image[0][i].x = curOffset % R300_BLIT_WIDTH_BYTES;
			t->image[0][i].y = curOffset / R300_BLIT_WIDTH_BYTES;
			t->image[0][i].width =
			    MIN2(size, R300_BLIT_WIDTH_BYTES);
			t->image[0][i].height = size / t->image[0][i].width;
		}

		if (RADEON_DEBUG & DEBUG_TEXTURE)
			fprintf(stderr,
				"level %d: %dx%d x=%d y=%d w=%d h=%d size=%d at %d\n",
				i, texImage->Width, texImage->Height,
				t->image[0][i].x, t->image[0][i].y,
				t->image[0][i].width, t->image[0][i].height,
				size, curOffset);

		curOffset += size;
d325 1
a325 1

d346 31
d381 4
a384 7

	t->size =
	    (((tObj->Image[0][t->base.firstLevel]->Width -
	       1) << R300_TX_WIDTHMASK_SHIFT)
	     | ((tObj->Image[0][t->base.firstLevel]->Height - 1) <<
		R300_TX_HEIGHTMASK_SHIFT))
	    | ((numLevels - 1) << R300_TX_MAX_MIP_LEVEL_SHIFT);
d393 2
a394 1
	} else if (tObj->Target == GL_TEXTURE_RECTANGLE_NV) {
d397 1
a397 1
			     texelBytes) + 63) & ~(63);
d399 3
a401 5
		if (!t->image_override)
			t->pitch_reg =
			    (((tObj->Image[0][t->base.firstLevel]->Width) +
			      align) & ~align) - 1;
	} else {
d412 1
d417 1
a417 1
static GLboolean r300EnableTexture2D(GLcontext * ctx, int unit)
a427 1

d430 1
a430 1
		if (!t->base.memBlock && !t->image_override)
d437 2
a438 1
static GLboolean r300EnableTexture3D(GLcontext * ctx, int unit)
d445 8
d455 2
a456 1
	/* r300 does not support mipmaps for 3D textures. */
d471 1
d473 1
a473 1
static GLboolean r300EnableTextureCube(GLcontext * ctx, int unit)
d481 9
d518 1
a518 1
static GLboolean r300EnableTextureRect(GLcontext * ctx, int unit)
a528 1

d531 1
a531 2
		if (!t->base.memBlock && !t->image_override &&
		    !rmesa->prefer_gart_client_texturing)
d538 1
a538 1
static GLboolean r300UpdateTexture(GLcontext * ctx, int unit)
a570 45
void r300SetTexOffset(__DRIcontext *pDRICtx, GLint texname,
		      unsigned long long offset, GLint depth, GLuint pitch)
{
	r300ContextPtr rmesa =
		(r300ContextPtr)((__DRIcontextPrivate*)pDRICtx->private)->driverPrivate;
	struct gl_texture_object *tObj =
		_mesa_lookup_texture(rmesa->radeon.glCtx, texname);
	r300TexObjPtr t;
	int idx;

	if (!tObj)
		return;

	t = (r300TexObjPtr) tObj->DriverData;

	t->image_override = GL_TRUE;

	if (!offset)
		return;

	t->offset = offset;
	t->pitch_reg = pitch;

	switch (depth) {
	case 32:
		idx = 2;
		t->pitch_reg /= 4;
		break;
	case 24:
	default:
		idx = 4;
		t->pitch_reg /= 4;
		break;
	case 16:
		idx = 5;
		t->pitch_reg /= 2;
		break;
	}

	t->pitch_reg--;

	t->format = tx_table_le[idx].format;
	t->filter |= tx_table_le[idx].filter;
}

d576 2
a577 2
		return (r300EnableTextureRect(ctx, unit) &&
			r300UpdateTexture(ctx, unit));
d579 12
a590 8
		return (r300EnableTexture2D(ctx, unit) &&
			r300UpdateTexture(ctx, unit));
	} else if (texUnit->_ReallyEnabled & (TEXTURE_3D_BIT)) {
		return (r300EnableTexture3D(ctx, unit) &&
			r300UpdateTexture(ctx, unit));
	} else if (texUnit->_ReallyEnabled & (TEXTURE_CUBE_BIT)) {
		return (r300EnableTextureCube(ctx, unit) &&
			r300UpdateTexture(ctx, unit));
d595 1
a595 1
	}
d600 1
a600 1
	int i;
d602 9
a610 7
	for (i = 0; i < 8; i++) {
		if (!r300UpdateTextureUnit(ctx, i)) {
			_mesa_warning(ctx,
				      "failed to update texture state for unit %d.\n",
				      i);
		}
	}
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d38 8
a45 8
#include "main/glheader.h"
#include "main/imports.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/teximage.h"
#include "main/texobj.h"
#include "main/enums.h"
#include "main/simple_list.h"
d48 3
a50 1
#include "radeon_mipmap_tree.h"
d54 8
d71 41
a111 111
int32_t r300TranslateTexFormat(gl_format mesaFormat)
{
	switch (mesaFormat)
	{
#ifdef MESA_LITTLE_ENDIAN
		case MESA_FORMAT_RGBA8888:
			return R300_EASY_TX_FORMAT(Y, Z, W, X, W8Z8Y8X8);
		case MESA_FORMAT_RGBA8888_REV:
			return R300_EASY_TX_FORMAT(Z, Y, X, W, W8Z8Y8X8);
		case MESA_FORMAT_ARGB8888:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8);
		case MESA_FORMAT_ARGB8888_REV:
			return R300_EASY_TX_FORMAT(W, Z, Y, X, W8Z8Y8X8);
#else
		case MESA_FORMAT_RGBA8888:
			return R300_EASY_TX_FORMAT(Z, Y, X, W, W8Z8Y8X8);
		case MESA_FORMAT_RGBA8888_REV:
			return R300_EASY_TX_FORMAT(Y, Z, W, X, W8Z8Y8X8);
		case MESA_FORMAT_ARGB8888:
			return R300_EASY_TX_FORMAT(W, Z, Y, X, W8Z8Y8X8);
		case MESA_FORMAT_ARGB8888_REV:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8);
#endif
		case MESA_FORMAT_XRGB8888:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, W8Z8Y8X8);
		case MESA_FORMAT_RGB888:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, W8Z8Y8X8);
		case MESA_FORMAT_RGB565:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5);
		case MESA_FORMAT_RGB565_REV:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5);
		case MESA_FORMAT_ARGB4444:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, W4Z4Y4X4);
		case MESA_FORMAT_ARGB4444_REV:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, W4Z4Y4X4);
		case MESA_FORMAT_ARGB1555:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, W1Z5Y5X5);
		case MESA_FORMAT_ARGB1555_REV:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, W1Z5Y5X5);
		case MESA_FORMAT_AL88:
			return R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8);
		case MESA_FORMAT_AL88_REV:
			return R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8);
		case MESA_FORMAT_RGB332:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z3Y3X2);
		case MESA_FORMAT_A8:
			return R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, X8);
		case MESA_FORMAT_L8:
			return R300_EASY_TX_FORMAT(X, X, X, ONE, X8);
		case MESA_FORMAT_I8:
			return R300_EASY_TX_FORMAT(X, X, X, X, X8);
		case MESA_FORMAT_CI8:
			return R300_EASY_TX_FORMAT(X, X, X, X, X8);
		case MESA_FORMAT_YCBCR:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, G8R8_G8B8) | R300_TX_FORMAT_YUV_MODE;
		case MESA_FORMAT_YCBCR_REV:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, G8R8_G8B8) | R300_TX_FORMAT_YUV_MODE;
		case MESA_FORMAT_RGB_DXT1:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, DXT1);
		case MESA_FORMAT_RGBA_DXT1:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, DXT1);
		case MESA_FORMAT_RGBA_DXT3:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, DXT3);
		case MESA_FORMAT_RGBA_DXT5:
			return R300_EASY_TX_FORMAT(Y, Z, W, X, DXT5);
		case MESA_FORMAT_RGBA_FLOAT32:
			return R300_EASY_TX_FORMAT(Z, Y, X, W, FL_R32G32B32A32);
		case MESA_FORMAT_RGBA_FLOAT16:
			return R300_EASY_TX_FORMAT(Z, Y, X, W, FL_R16G16B16A16);
		case MESA_FORMAT_ALPHA_FLOAT32:
			return R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, FL_I32);
		case MESA_FORMAT_ALPHA_FLOAT16:
			return R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, FL_I16);
		case MESA_FORMAT_LUMINANCE_FLOAT32:
			return R300_EASY_TX_FORMAT(X, X, X, ONE, FL_I32);
		case MESA_FORMAT_LUMINANCE_FLOAT16:
			return R300_EASY_TX_FORMAT(X, X, X, ONE, FL_I16);
		case MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32:
			return R300_EASY_TX_FORMAT(X, X, X, Y, FL_I32A32);
		case MESA_FORMAT_LUMINANCE_ALPHA_FLOAT16:
			return R300_EASY_TX_FORMAT(X, X, X, Y, FL_I16A16);
		case MESA_FORMAT_INTENSITY_FLOAT32:
			return R300_EASY_TX_FORMAT(X, X, X, X, FL_I32);
		case MESA_FORMAT_INTENSITY_FLOAT16:
			return R300_EASY_TX_FORMAT(X, X, X, X, FL_I16);
		case MESA_FORMAT_Z16:
			return R300_EASY_TX_FORMAT(X, X, X, X, X16);
		case MESA_FORMAT_Z24_S8:
			return R300_EASY_TX_FORMAT(X, X, X, X, X24_Y8);
		case MESA_FORMAT_S8_Z24:
			return R300_EASY_TX_FORMAT(Y, Y, Y, Y, X24_Y8);
		case MESA_FORMAT_Z32:
			return R300_EASY_TX_FORMAT(X, X, X, X, X32);
		/* EXT_texture_sRGB */
		case MESA_FORMAT_SARGB8:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8) | R300_TX_FORMAT_GAMMA;
		case MESA_FORMAT_SLA8:
			return R300_EASY_TX_FORMAT(X, X, X, Y, Y8X8) | R300_TX_FORMAT_GAMMA;
		case MESA_FORMAT_SL8:
			return R300_EASY_TX_FORMAT(X, X, X, ONE, X8) | R300_TX_FORMAT_GAMMA;
		case MESA_FORMAT_SRGB_DXT1:
			return R300_EASY_TX_FORMAT(X, Y, Z, ONE, DXT1) | R300_TX_FORMAT_GAMMA;
		case MESA_FORMAT_SRGBA_DXT1:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, DXT1) | R300_TX_FORMAT_GAMMA;
		case MESA_FORMAT_SRGBA_DXT3:
			return R300_EASY_TX_FORMAT(X, Y, Z, W, DXT3) | R300_TX_FORMAT_GAMMA;
		case MESA_FORMAT_SRGBA_DXT5:
			return R300_EASY_TX_FORMAT(Y, Z, W, X, DXT5) | R300_TX_FORMAT_GAMMA;
		default:
			return -1;
	}
d114 40
a153 63
void r300SetDepthTexMode(struct gl_texture_object *tObj)
{
	static const GLuint formats[3][3] = {
		{
			R300_EASY_TX_FORMAT(X, X, X, ONE, X16),
			R300_EASY_TX_FORMAT(X, X, X, X, X16),
			R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, X16),
		},
		{
			R300_EASY_TX_FORMAT(Y, Y, Y, ONE, X24_Y8),
			R300_EASY_TX_FORMAT(Y, Y, Y, Y, X24_Y8),
			R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, Y, X24_Y8),
		},
		{
			R300_EASY_TX_FORMAT(X, X, X, ONE, X32),
			R300_EASY_TX_FORMAT(X, X, X, X, X32),
			R300_EASY_TX_FORMAT(ZERO, ZERO, ZERO, X, X32),
		},
	};
	const GLuint *format;
	radeonTexObjPtr t;

	if (!tObj)
		return;

	t = radeon_tex_obj(tObj);

	switch (tObj->Image[0][tObj->BaseLevel]->TexFormat) {
	case MESA_FORMAT_Z16:
		format = formats[0];
		break;
	case MESA_FORMAT_S8_Z24:
		format = formats[1];
		break;
	case MESA_FORMAT_Z32:
		format = formats[2];
		break;
	default:
		/* Error...which should have already been caught by higher
		 * levels of Mesa.
		 */
		ASSERT(0);
		return;
	}

	switch (tObj->DepthMode) {
	case GL_LUMINANCE:
		t->pp_txformat = format[0];
		break;
	case GL_INTENSITY:
		t->pp_txformat = format[1];
		break;
	case GL_ALPHA:
		t->pp_txformat = format[2];
		break;
	default:
		/* Error...which should have already been caught by higher
		 * levels of Mesa.
		 */
		ASSERT(0);
		return;
	}
}
d155 1
d158 5
a162 1
 * Compute the cached hardware register values for the given texture object.
d165 2
a166 1
 * \param t the r300 texture object
d168 2
a169 1
static void setup_hardware_state(r300ContextPtr rmesa, radeonTexObj *t)
d171 52
a222 2
	const struct gl_texture_image *firstImage;
	firstImage = t->base.Image[0][t->minLod];
d224 17
a240 9
	if (!t->image_override) {
		if (firstImage->_BaseFormat == GL_DEPTH_COMPONENT) {
			r300SetDepthTexMode(&t->base);
		} else {
			int32_t txformat = r300TranslateTexFormat(firstImage->TexFormat);
			if (txformat < 0) {
				_mesa_problem(rmesa->radeon.glCtx, "%s: Invalid format %s",
							  __FUNCTION__, _mesa_get_format_name(firstImage->TexFormat));
				exit(1);
d242 5
a246 1
			t->pp_txformat = (uint32_t) txformat;
d249 51
d301 6
a306 2
	if (t->image_override && t->bo)
		return;
d308 3
a310 4
	t->pp_txsize = (((R300_TX_WIDTHMASK_MASK & ((firstImage->Width - 1) << R300_TX_WIDTHMASK_SHIFT)))
			| ((R300_TX_HEIGHTMASK_MASK & ((firstImage->Height - 1) << R300_TX_HEIGHTMASK_SHIFT)))
			| ((R300_TX_DEPTHMASK_MASK & ((firstImage->DepthLog2) << R300_TX_DEPTHMASK_SHIFT)))
			| ((R300_TX_MAX_MIP_LEVEL_MASK & ((t->maxLod - t->minLod) << R300_TX_MAX_MIP_LEVEL_SHIFT))));
d312 1
a312 1
	t->tile_bits = 0;
d314 15
a328 4
	if (t->base.Target == GL_TEXTURE_CUBE_MAP)
		t->pp_txformat |= R300_TX_FORMAT_CUBIC_MAP;
	if (t->base.Target == GL_TEXTURE_3D)
		t->pp_txformat |= R300_TX_FORMAT_3D;
d330 30
d361 24
a384 3
	if (t->base.Target == GL_TEXTURE_RECTANGLE_NV) {
		unsigned int align = (64 / _mesa_get_format_bytes(firstImage->TexFormat)) - 1;
		t->pp_txsize |= R300_TX_SIZE_TXPITCH_EN;
d386 7
a392 1
			t->pp_txpitch = ((firstImage->Width + align) & ~align) - 1;
d395 25
a419 9
	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
	    if (firstImage->Width > 2048)
		t->pp_txpitch |= R500_TXWIDTH_BIT11;
            else
		t->pp_txpitch &= ~R500_TXWIDTH_BIT11;
	    if (firstImage->Height > 2048)
		t->pp_txpitch |= R500_TXHEIGHT_BIT11;
            else
		t->pp_txpitch &= ~R500_TXHEIGHT_BIT11;
d421 2
d425 1
a425 6
/**
 * Ensure the given texture is ready for rendering.
 *
 * Mostly this means populating the texture object's mipmap tree.
 */
static GLboolean r300_validate_texture(struct gl_context * ctx, struct gl_texture_object *texObj)
d428 3
a430 1
	radeonTexObj *t = radeon_tex_obj(texObj);
d432 4
a435 1
	if (!radeon_validate_texture_miptree(ctx, texObj))
d437 1
d439 7
a445 3
	/* Configure the hardware registers (more precisely, the cached version
	 * of the hardware registers). */
	setup_hardware_state(rmesa, t);
a446 1
	t->validated = GL_TRUE;
d450 1
a450 4
/**
 * Ensure all enabled and complete textures are uploaded along with any buffers being used.
 */
GLboolean r300ValidateBuffers(struct gl_context * ctx)
d453 24
a476 3
	struct radeon_renderbuffer *rrb;
	int i;
	int ret;
d478 4
a481 1
	radeon_cs_space_reset_bos(rmesa->radeon.cmdbuf.cs);
d483 20
a502 6
	rrb = radeon_get_colorbuffer(&rmesa->radeon);
	/* color buffer */
	if (rrb && rrb->bo) {
		radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs,
						  rrb->bo, 0,
						  RADEON_GEM_DOMAIN_VRAM);
d505 13
a517 10
	/* depth buffer */
	rrb = radeon_get_depthbuffer(&rmesa->radeon);
	if (rrb && rrb->bo) {
		radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs,
						  rrb->bo, 0,
						  RADEON_GEM_DOMAIN_VRAM);
	}
	
	for (i = 0; i < ctx->Const.MaxTextureImageUnits; ++i) {
		radeonTexObj *t;
d519 8
a526 2
		if (!ctx->Texture.Unit[i]._ReallyEnabled)
			continue;
d528 2
a529 4
		if (!r300_validate_texture(ctx, ctx->Texture.Unit[i]._Current)) {
			_mesa_warning(ctx,
				      "failed to validate texture for unit %d.\n",
				      i);
d531 5
a535 9
		t = radeon_tex_obj(ctx->Texture.Unit[i]._Current);
		if (t->image_override && t->bo)
			radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs,
							  t->bo,
							  RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0);
		else if (t->mt->bo)
			radeon_cs_space_add_persistent_bo(rmesa->radeon.cmdbuf.cs,
							  t->mt->bo,
							  RADEON_GEM_DOMAIN_GTT | RADEON_GEM_DOMAIN_VRAM, 0);
d538 1
a538 4
	ret = radeon_cs_space_check_with_bo(rmesa->radeon.cmdbuf.cs, first_elem(&rmesa->radeon.dma.reserved)->bo, RADEON_GEM_DOMAIN_GTT, 0);
	if (ret)
		return GL_FALSE;
	return GL_TRUE;
d541 1
a541 1
void r300SetTexOffset(__DRIcontext * pDRICtx, GLint texname,
d544 2
a545 1
	r300ContextPtr rmesa = pDRICtx->driverPrivate;
d547 3
a549 3
	    _mesa_lookup_texture(rmesa->radeon.glCtx, texname);
	radeonTexObjPtr t = radeon_tex_obj(tObj);
	uint32_t pitch_val;
d554 2
d561 2
a562 4
	t->bo = NULL;
	t->override_offset = offset;
	t->pp_txpitch &= (1 << 13) -1;
	pitch_val = pitch;
d566 2
a567 2
		t->pp_txformat = R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8);
		pitch_val /= 4;
d571 2
a572 2
		t->pp_txformat = R300_EASY_TX_FORMAT(X, Y, Z, ONE, W8Z8Y8X8);
		pitch_val /= 4;
d575 2
a576 2
		t->pp_txformat = R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5);
		pitch_val /= 2;
a578 1
	pitch_val--;
d580 4
a583 1
	t->pp_txpitch |= pitch_val;
d586 1
a586 1
void r300SetTexBuffer2(__DRIcontext *pDRICtx, GLint target, GLint texture_format, __DRIdrawable *dPriv)
d588 18
a605 83
	struct gl_texture_unit *texUnit;
	struct gl_texture_object *texObj;
	struct gl_texture_image *texImage;
	struct radeon_renderbuffer *rb;
	radeon_texture_image *rImage;
	radeonContextPtr radeon;
	r300ContextPtr rmesa;
	struct radeon_framebuffer *rfb;
	radeonTexObjPtr t;
	uint32_t pitch_val;
	uint32_t internalFormat, type, format;
	gl_format texFormat;

	type = GL_BGRA;
	format = GL_UNSIGNED_BYTE;
	internalFormat = (texture_format == __DRI_TEXTURE_FORMAT_RGB ? 3 : 4);

	radeon = pDRICtx->driverPrivate;
	rmesa = pDRICtx->driverPrivate;

	rfb = dPriv->driverPrivate;
        texUnit = &radeon->glCtx->Texture.Unit[radeon->glCtx->Texture.CurrentUnit];
	texObj = _mesa_select_tex_object(radeon->glCtx, texUnit, target);
        texImage = _mesa_get_tex_image(radeon->glCtx, texObj, target, 0);

	rImage = get_radeon_texture_image(texImage);
	t = radeon_tex_obj(texObj);
        if (t == NULL) {
    	    return;
    	}

	radeon_update_renderbuffers(pDRICtx, dPriv, GL_TRUE);
	rb = rfb->color_rb[0];
	if (rb->bo == NULL) {
		/* Failed to BO for the buffer */
		return;
	}
	
	_mesa_lock_texture(radeon->glCtx, texObj);
	if (t->bo) {
		radeon_bo_unref(t->bo);
		t->bo = NULL;
	}
	if (rImage->bo) {
		radeon_bo_unref(rImage->bo);
		rImage->bo = NULL;
	}

	radeon_miptree_unreference(&t->mt);
	radeon_miptree_unreference(&rImage->mt);

	rImage->bo = rb->bo;
	radeon_bo_ref(rImage->bo);
	t->bo = rb->bo;
	radeon_bo_ref(t->bo);
	t->tile_bits = 0;
	t->image_override = GL_TRUE;
	t->override_offset = 0;
	t->pp_txpitch &= (1 << 13) -1;
	pitch_val = rb->pitch;
	switch (rb->cpp) {
	case 4:
		if (texture_format == __DRI_TEXTURE_FORMAT_RGB) {
			texFormat = MESA_FORMAT_RGB888;
			t->pp_txformat = R300_EASY_TX_FORMAT(X, Y, Z, ONE, W8Z8Y8X8);
		}
		else {
			texFormat = MESA_FORMAT_ARGB8888;
			t->pp_txformat = R300_EASY_TX_FORMAT(X, Y, Z, W, W8Z8Y8X8);
		}
		pitch_val /= 4;
		break;
	case 3:
	default:
		texFormat = MESA_FORMAT_RGB888;
		t->pp_txformat = R300_EASY_TX_FORMAT(X, Y, Z, ONE, W8Z8Y8X8);
		pitch_val /= 4;
		break;
	case 2:
		texFormat = MESA_FORMAT_RGB565;
		t->pp_txformat = R300_EASY_TX_FORMAT(X, Y, Z, ONE, Z5Y6X5);
		pitch_val /= 2;
		break;
a606 26

	_mesa_init_teximage_fields(radeon->glCtx, target, texImage,
				   rb->base.Width, rb->base.Height, 1, 0,
				   rb->cpp, texFormat);
	texImage->RowStride = rb->pitch / rb->cpp;


	pitch_val--;
	t->pp_txsize = (((R300_TX_WIDTHMASK_MASK & ((rb->base.Width - 1) << R300_TX_WIDTHMASK_SHIFT)))
			| ((R300_TX_HEIGHTMASK_MASK & ((rb->base.Height - 1) << R300_TX_HEIGHTMASK_SHIFT))));
	t->pp_txsize |= R300_TX_SIZE_TXPITCH_EN;
	t->pp_txpitch |= pitch_val;

	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
	    if (rb->base.Width > 2048)
		t->pp_txpitch |= R500_TXWIDTH_BIT11;
            else
		t->pp_txpitch &= ~R500_TXWIDTH_BIT11;
	    if (rb->base.Height > 2048)
		t->pp_txpitch |= R500_TXHEIGHT_BIT11;
            else
		t->pp_txpitch &= ~R500_TXHEIGHT_BIT11;
	}
	t->validated = GL_TRUE;
	_mesa_unlock_texture(radeon->glCtx, texObj);
	return;
d609 1
a609 1
void r300SetTexBuffer(__DRIcontext *pDRICtx, GLint target, __DRIdrawable *dPriv)
d611 9
a619 1
        r300SetTexBuffer2(pDRICtx, target, __DRI_TEXTURE_FORMAT_RGBA, dPriv);
@


