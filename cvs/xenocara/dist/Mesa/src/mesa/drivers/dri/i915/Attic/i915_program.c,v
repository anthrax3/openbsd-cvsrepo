head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.04.13;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.33;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.09;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.28.12;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.15.20;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.47;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include <strings.h>

#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"

#include "tnl/t_context.h"
#include "intel_batchbuffer.h"

#include "i915_reg.h"
#include "i915_context.h"
#include "i915_program.h"


#define A0_DEST( reg ) (((reg)&UREG_TYPE_NR_MASK)>>UREG_A0_DEST_SHIFT_LEFT)
#define D0_DEST( reg ) (((reg)&UREG_TYPE_NR_MASK)>>UREG_A0_DEST_SHIFT_LEFT)
#define T0_DEST( reg ) (((reg)&UREG_TYPE_NR_MASK)>>UREG_A0_DEST_SHIFT_LEFT)
#define A0_SRC0( reg ) (((reg)&UREG_MASK)>>UREG_A0_SRC0_SHIFT_LEFT)
#define A1_SRC0( reg ) (((reg)&UREG_MASK)<<UREG_A1_SRC0_SHIFT_RIGHT)
#define A1_SRC1( reg ) (((reg)&UREG_MASK)>>UREG_A1_SRC1_SHIFT_LEFT)
#define A2_SRC1( reg ) (((reg)&UREG_MASK)<<UREG_A2_SRC1_SHIFT_RIGHT)
#define A2_SRC2( reg ) (((reg)&UREG_MASK)>>UREG_A2_SRC2_SHIFT_LEFT)

/* These are special, and don't have swizzle/negate bits.
 */
#define T0_SAMPLER( reg )     (GET_UREG_NR(reg)<<T0_SAMPLER_NR_SHIFT)
#define T1_ADDRESS_REG( reg ) ((GET_UREG_NR(reg)<<T1_ADDRESS_REG_NR_SHIFT) | \
			       (GET_UREG_TYPE(reg)<<T1_ADDRESS_REG_TYPE_SHIFT))


/* Macros for translating UREG's into the various register fields used
 * by the I915 programmable unit.
 */
#define UREG_A0_DEST_SHIFT_LEFT  (UREG_TYPE_SHIFT - A0_DEST_TYPE_SHIFT)
#define UREG_A0_SRC0_SHIFT_LEFT  (UREG_TYPE_SHIFT - A0_SRC0_TYPE_SHIFT)
#define UREG_A1_SRC0_SHIFT_RIGHT (A1_SRC0_CHANNEL_W_SHIFT - UREG_CHANNEL_W_SHIFT)
#define UREG_A1_SRC1_SHIFT_LEFT  (UREG_TYPE_SHIFT - A1_SRC1_TYPE_SHIFT)
#define UREG_A2_SRC1_SHIFT_RIGHT (A2_SRC1_CHANNEL_W_SHIFT - UREG_CHANNEL_W_SHIFT)
#define UREG_A2_SRC2_SHIFT_LEFT  (UREG_TYPE_SHIFT - A2_SRC2_TYPE_SHIFT)

#define UREG_MASK         0xffffff00
#define UREG_TYPE_NR_MASK ((REG_TYPE_MASK << UREG_TYPE_SHIFT) | \
  			   (REG_NR_MASK << UREG_NR_SHIFT))


#define I915_CONSTFLAG_PARAM 0x1f

GLuint
i915_get_temp(struct i915_fragment_program *p)
{
   int bit = ffs(~p->temp_flag);
   if (!bit) {
      fprintf(stderr, "%s: out of temporaries\n", __FILE__);
      exit(1);
   }

   p->temp_flag |= 1 << (bit - 1);
   return UREG(REG_TYPE_R, (bit - 1));
}


GLuint
i915_get_utemp(struct i915_fragment_program * p)
{
   int bit = ffs(~p->utemp_flag);
   if (!bit) {
      fprintf(stderr, "%s: out of temporaries\n", __FILE__);
      exit(1);
   }

   p->utemp_flag |= 1 << (bit - 1);
   return UREG(REG_TYPE_U, (bit - 1));
}

void
i915_release_utemps(struct i915_fragment_program *p)
{
   p->utemp_flag = ~0x7;
}


GLuint
i915_emit_decl(struct i915_fragment_program *p,
               GLuint type, GLuint nr, GLuint d0_flags)
{
   GLuint reg = UREG(type, nr);

   if (type == REG_TYPE_T) {
      if (p->decl_t & (1 << nr))
         return reg;

      p->decl_t |= (1 << nr);
   }
   else if (type == REG_TYPE_S) {
      if (p->decl_s & (1 << nr))
         return reg;

      p->decl_s |= (1 << nr);
   }
   else
      return reg;

   *(p->decl++) = (D0_DCL | D0_DEST(reg) | d0_flags);
   *(p->decl++) = D1_MBZ;
   *(p->decl++) = D2_MBZ;
   assert(p->decl <= p->declarations + ARRAY_SIZE(p->declarations));

   p->nr_decl_insn++;
   return reg;
}

GLuint
i915_emit_arith(struct i915_fragment_program * p,
                GLuint op,
                GLuint dest,
                GLuint mask,
                GLuint saturate, GLuint src0, GLuint src1, GLuint src2)
{
   GLuint c[3];
   GLuint nr_const = 0;

   assert(GET_UREG_TYPE(dest) != REG_TYPE_CONST);
   dest = UREG(GET_UREG_TYPE(dest), GET_UREG_NR(dest));
   assert(dest);

   if (GET_UREG_TYPE(src0) == REG_TYPE_CONST)
      c[nr_const++] = 0;
   if (GET_UREG_TYPE(src1) == REG_TYPE_CONST)
      c[nr_const++] = 1;
   if (GET_UREG_TYPE(src2) == REG_TYPE_CONST)
      c[nr_const++] = 2;

   /* Recursively call this function to MOV additional const values
    * into temporary registers.  Use utemp registers for this -
    * currently shouldn't be possible to run out, but keep an eye on
    * this.
    */
   if (nr_const > 1) {
      GLuint s[3], first, i, old_utemp_flag;

      s[0] = src0;
      s[1] = src1;
      s[2] = src2;
      old_utemp_flag = p->utemp_flag;

      first = GET_UREG_NR(s[c[0]]);
      for (i = 1; i < nr_const; i++) {
         if (GET_UREG_NR(s[c[i]]) != first) {
            GLuint tmp = i915_get_utemp(p);

            i915_emit_arith(p, A0_MOV, tmp, A0_DEST_CHANNEL_ALL, 0,
                            s[c[i]], 0, 0);
            s[c[i]] = tmp;
         }
      }

      src0 = s[0];
      src1 = s[1];
      src2 = s[2];
      p->utemp_flag = old_utemp_flag;   /* restore */
   }

   if (p->csr >= p->program + ARRAY_SIZE(p->program)) {
      i915_program_error(p, "Program contains too many instructions");
      return UREG_BAD;
   }

   *(p->csr++) = (op | A0_DEST(dest) | mask | saturate | A0_SRC0(src0));
   *(p->csr++) = (A1_SRC0(src0) | A1_SRC1(src1));
   *(p->csr++) = (A2_SRC1(src1) | A2_SRC2(src2));

   if (GET_UREG_TYPE(dest) == REG_TYPE_R)
      p->register_phases[GET_UREG_NR(dest)] = p->nr_tex_indirect;

   p->nr_alu_insn++;
   return dest;
}

static GLuint get_free_rreg (struct i915_fragment_program *p, 
                             GLuint live_regs)
{
    int bit = ffs(~live_regs);
    if (!bit) {
        i915_program_error(p, "Can't find free R reg");
        return UREG_BAD;
    }
    return UREG(REG_TYPE_R, bit - 1);
}

GLuint i915_emit_texld( struct i915_fragment_program *p,
			GLuint live_regs,               
			GLuint dest,
			GLuint destmask,
			GLuint sampler,
			GLuint coord,
			GLuint op )
{
    if (coord != UREG(GET_UREG_TYPE(coord), GET_UREG_NR(coord))) {
        /* With the help of the "needed registers" table created earlier, pick
         * a register we can MOV the swizzled TC to (since TEX doesn't support
         * swizzled sources) */
        GLuint swizCoord = get_free_rreg(p, live_regs);
        if (swizCoord == UREG_BAD) 
            return 0;

        i915_emit_arith( p, A0_MOV, swizCoord, A0_DEST_CHANNEL_ALL, 0, coord, 0, 0 );
        coord = swizCoord;
    }

   /* Don't worry about saturate as we only support texture formats
    * that are always in the 0..1 range.
    */
   if (destmask != A0_DEST_CHANNEL_ALL) {
      GLuint tmp = i915_get_utemp(p);
      i915_emit_texld( p, 0, tmp, A0_DEST_CHANNEL_ALL, sampler, coord, op );
      i915_emit_arith( p, A0_MOV, dest, destmask, 0, tmp, 0, 0 );
      return dest;
   }
   else {
      assert(GET_UREG_TYPE(dest) != REG_TYPE_CONST);
      assert(dest == UREG(GET_UREG_TYPE(dest), GET_UREG_NR(dest)));
      /* Can't use unsaved temps for coords, as the phase boundary would result
       * in the contents becoming undefined.
       */
      assert(GET_UREG_TYPE(coord) != REG_TYPE_U);

      if ((GET_UREG_TYPE(coord) != REG_TYPE_R) &&
          (GET_UREG_TYPE(coord) != REG_TYPE_OC) &&
          (GET_UREG_TYPE(coord) != REG_TYPE_OD) &&
          (GET_UREG_TYPE(coord) != REG_TYPE_T)) {
          GLuint  tmpCoord = get_free_rreg(p, live_regs);
          
          if (tmpCoord == UREG_BAD) 
              return 0;

          i915_emit_arith(p, A0_MOV, tmpCoord, A0_DEST_CHANNEL_ALL, 0, coord, 0, 0);
          coord = tmpCoord;
      }

      /* Output register being oC or oD defines a phase boundary */
      if (GET_UREG_TYPE(dest) == REG_TYPE_OC ||
	  GET_UREG_TYPE(dest) == REG_TYPE_OD)
	 p->nr_tex_indirect++;

      /* Reading from an r# register whose contents depend on output of the
       * current phase defines a phase boundary.
       */
      if (GET_UREG_TYPE(coord) == REG_TYPE_R &&
	  p->register_phases[GET_UREG_NR(coord)] == p->nr_tex_indirect)
	 p->nr_tex_indirect++;

      if (p->csr >= p->program + ARRAY_SIZE(p->program)) {
	 i915_program_error(p, "Program contains too many instructions");
	 return UREG_BAD;
      }

      *(p->csr++) = (op | 
		     T0_DEST( dest ) |
		     T0_SAMPLER( sampler ));

      *(p->csr++) = T1_ADDRESS_REG( coord );
      *(p->csr++) = T2_MBZ;

      if (GET_UREG_TYPE(dest) == REG_TYPE_R)
	 p->register_phases[GET_UREG_NR(dest)] = p->nr_tex_indirect;

      p->nr_tex_insn++;
      return dest;
   }
}


GLuint
i915_emit_const1f(struct i915_fragment_program * p, GLfloat c0)
{
   GLint reg, idx;

   if (c0 == 0.0)
      return swizzle(UREG(REG_TYPE_R, 0), ZERO, ZERO, ZERO, ZERO);
   if (c0 == 1.0)
      return swizzle(UREG(REG_TYPE_R, 0), ONE, ONE, ONE, ONE);

   for (reg = 0; reg < I915_MAX_CONSTANT; reg++) {
      if (p->constant_flags[reg] == I915_CONSTFLAG_PARAM)
         continue;
      for (idx = 0; idx < 4; idx++) {
         if (!(p->constant_flags[reg] & (1 << idx)) ||
             p->constant[reg][idx] == c0) {
            p->constant[reg][idx] = c0;
            p->constant_flags[reg] |= 1 << idx;
            if (reg + 1 > p->nr_constants)
               p->nr_constants = reg + 1;
            return swizzle(UREG(REG_TYPE_CONST, reg), idx, ZERO, ZERO, ONE);
         }
      }
   }

   fprintf(stderr, "%s: out of constants\n", __FUNCTION__);
   p->error = 1;
   return 0;
}

GLuint
i915_emit_const2f(struct i915_fragment_program * p, GLfloat c0, GLfloat c1)
{
   GLint reg, idx;

   if (c0 == 0.0)
      return swizzle(i915_emit_const1f(p, c1), ZERO, X, Z, W);
   if (c0 == 1.0)
      return swizzle(i915_emit_const1f(p, c1), ONE, X, Z, W);

   if (c1 == 0.0)
      return swizzle(i915_emit_const1f(p, c0), X, ZERO, Z, W);
   if (c1 == 1.0)
      return swizzle(i915_emit_const1f(p, c0), X, ONE, Z, W);

   for (reg = 0; reg < I915_MAX_CONSTANT; reg++) {
      if (p->constant_flags[reg] == 0xf ||
          p->constant_flags[reg] == I915_CONSTFLAG_PARAM)
         continue;
      for (idx = 0; idx < 3; idx++) {
         if (!(p->constant_flags[reg] & (3 << idx))) {
            p->constant[reg][idx] = c0;
            p->constant[reg][idx + 1] = c1;
            p->constant_flags[reg] |= 3 << idx;
            if (reg + 1 > p->nr_constants)
               p->nr_constants = reg + 1;
            return swizzle(UREG(REG_TYPE_CONST, reg), idx, idx + 1, ZERO,
                           ONE);
         }
      }
   }

   fprintf(stderr, "%s: out of constants\n", __FUNCTION__);
   p->error = 1;
   return 0;
}



GLuint
i915_emit_const4f(struct i915_fragment_program * p,
                  GLfloat c0, GLfloat c1, GLfloat c2, GLfloat c3)
{
   GLint reg;

   for (reg = 0; reg < I915_MAX_CONSTANT; reg++) {
      if (p->constant_flags[reg] == 0xf &&
          p->constant[reg][0] == c0 &&
          p->constant[reg][1] == c1 &&
          p->constant[reg][2] == c2 && p->constant[reg][3] == c3) {
         return UREG(REG_TYPE_CONST, reg);
      }
      else if (p->constant_flags[reg] == 0) {
         p->constant[reg][0] = c0;
         p->constant[reg][1] = c1;
         p->constant[reg][2] = c2;
         p->constant[reg][3] = c3;
         p->constant_flags[reg] = 0xf;
         if (reg + 1 > p->nr_constants)
            p->nr_constants = reg + 1;
         return UREG(REG_TYPE_CONST, reg);
      }
   }

   fprintf(stderr, "%s: out of constants\n", __FUNCTION__);
   p->error = 1;
   return 0;
}


GLuint
i915_emit_const4fv(struct i915_fragment_program * p, const GLfloat * c)
{
   return i915_emit_const4f(p, c[0], c[1], c[2], c[3]);
}


GLuint
i915_emit_param4fv(struct i915_fragment_program * p, const GLfloat * values)
{
   GLint reg, i;

   for (i = 0; i < p->nr_params; i++) {
      if (p->param[i].values == values)
         return UREG(REG_TYPE_CONST, p->param[i].reg);
   }


   for (reg = 0; reg < I915_MAX_CONSTANT; reg++) {
      if (p->constant_flags[reg] == 0) {
         p->constant_flags[reg] = I915_CONSTFLAG_PARAM;
         i = p->nr_params++;

         p->param[i].values = values;
         p->param[i].reg = reg;
         p->params_uptodate = 0;

         if (reg + 1 > p->nr_constants)
            p->nr_constants = reg + 1;
         return UREG(REG_TYPE_CONST, reg);
      }
   }

   fprintf(stderr, "%s: out of constants\n", __FUNCTION__);
   p->error = 1;
   return 0;
}

/* Warning the user about program errors seems to be quite valuable, from
 * our bug reports.  It unfortunately means piglit reporting errors
 * when we fall back to software due to an unsupportable program, though.
 */
void
i915_program_error(struct i915_fragment_program *p, const char *fmt, ...)
{
   if (unlikely((INTEL_DEBUG & (DEBUG_WM | DEBUG_PERF)) != 0)) {
      va_list args;

      fprintf(stderr, "i915_program_error: ");
      va_start(args, fmt);
      vfprintf(stderr, fmt, args);
      va_end(args);

      fprintf(stderr, "\n");
   }
   p->error = 1;
}


void
i915_init_program(struct i915_context *i915, struct i915_fragment_program *p)
{
   struct gl_context *ctx = &i915->intel.ctx;

   p->translated = 0;
   p->params_uptodate = 0;
   p->on_hardware = 0;
   p->error = 0;

   memset(&p->register_phases, 0, sizeof(p->register_phases));
   p->nr_tex_indirect = 1;
   p->nr_tex_insn = 0;
   p->nr_alu_insn = 0;
   p->nr_decl_insn = 0;

   p->ctx = ctx;
   memset(p->constant_flags, 0, sizeof(p->constant_flags));

   p->nr_constants = 0;
   p->csr = p->program;
   p->decl = p->declarations;
   p->decl_s = 0;
   p->decl_t = 0;
   p->temp_flag = 0xffff000;
   p->utemp_flag = ~0x7;
   p->wpos_tex = -1;
   p->depth_written = 0;
   p->nr_params = 0;

   *(p->decl++) = _3DSTATE_PIXEL_SHADER_PROGRAM;
}


void
i915_fini_program(struct i915_fragment_program *p)
{
   GLuint program_size = p->csr - p->program;
   GLuint decl_size = p->decl - p->declarations;

   if (p->nr_tex_indirect > I915_MAX_TEX_INDIRECT) {
      i915_program_error(p, "Exceeded max nr indirect texture lookups "
			 "(%d out of %d)",
			 p->nr_tex_indirect, I915_MAX_TEX_INDIRECT);
   }

   if (p->nr_tex_insn > I915_MAX_TEX_INSN) {
      i915_program_error(p, "Exceeded max TEX instructions (%d out of %d)",
			 p->nr_tex_insn, I915_MAX_TEX_INSN);
   }

   if (p->nr_alu_insn > I915_MAX_ALU_INSN)
      i915_program_error(p, "Exceeded max ALU instructions (%d out of %d)",
			 p->nr_alu_insn, I915_MAX_ALU_INSN);

   if (p->nr_decl_insn > I915_MAX_DECL_INSN) {
      i915_program_error(p, "Exceeded max DECL instructions (%d out of %d)",
			 p->nr_decl_insn, I915_MAX_DECL_INSN);
   }

   if (p->error) {
      p->FragProg.Base.NumNativeInstructions = 0;
      p->FragProg.Base.NumNativeAluInstructions = 0;
      p->FragProg.Base.NumNativeTexInstructions = 0;
      p->FragProg.Base.NumNativeTexIndirections = 0;
   }
   else {
      p->FragProg.Base.NumNativeInstructions = (p->nr_alu_insn +
                                                p->nr_tex_insn +
                                                p->nr_decl_insn);
      p->FragProg.Base.NumNativeAluInstructions = p->nr_alu_insn;
      p->FragProg.Base.NumNativeTexInstructions = p->nr_tex_insn;
      p->FragProg.Base.NumNativeTexIndirections = p->nr_tex_indirect;
   }

   p->declarations[0] |= program_size + decl_size - 2;
}

void
i915_upload_program(struct i915_context *i915,
                    struct i915_fragment_program *p)
{
   GLuint program_size = p->csr - p->program;
   GLuint decl_size = p->decl - p->declarations;

   if (p->error)
      return;

   /* Could just go straight to the batchbuffer from here:
    */
   if (i915->state.ProgramSize != (program_size + decl_size) ||
       memcmp(i915->state.Program + decl_size, p->program,
              program_size * sizeof(int)) != 0) {
      I915_STATECHANGE(i915, I915_UPLOAD_PROGRAM);
      memcpy(i915->state.Program, p->declarations, decl_size * sizeof(int));
      memcpy(i915->state.Program + decl_size, p->program,
             program_size * sizeof(int));
      i915->state.ProgramSize = decl_size + program_size;
   }

   /* Always seemed to get a failure if I used memcmp() to
    * shortcircuit this state upload.  Needs further investigation?
    */
   if (p->nr_constants) {
      GLuint nr = p->nr_constants;

      I915_ACTIVESTATE(i915, I915_UPLOAD_CONSTANTS, 1);
      I915_STATECHANGE(i915, I915_UPLOAD_CONSTANTS);

      i915->state.Constant[0] = _3DSTATE_PIXEL_SHADER_CONSTANTS | ((nr) * 4);
      i915->state.Constant[1] = (1 << (nr - 1)) | ((1 << (nr - 1)) - 1);

      memcpy(&i915->state.Constant[2], p->constant, 4 * sizeof(int) * (nr));
      i915->state.ConstantSize = 2 + (nr) * 4;

      if (0) {
         GLuint i;
         for (i = 0; i < nr; i++) {
            fprintf(stderr, "const[%d]: %f %f %f %f\n", i,
                    p->constant[i][0],
                    p->constant[i][1], p->constant[i][2], p->constant[i][3]);
         }
      }
   }
   else {
      I915_ACTIVESTATE(i915, I915_UPLOAD_CONSTANTS, 0);
   }

   p->on_hardware = 1;
}
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d445 1
a445 1
   if (unlikely((INTEL_DEBUG & (DEBUG_WM | DEBUG_FALLBACKS)) != 0)) {
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d445 2
a446 1
   va_list args;
d448 4
a451 4
   fprintf(stderr, "i915_program_error: ");
   va_start(args, fmt);
   vfprintf(stderr, fmt, args);
   va_end(args);
d453 2
a454 1
   fprintf(stderr, "\n");
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d460 1
a460 1
   GLcontext *ctx = &i915->intel.ctx;
d497 10
a506 5
   if (p->nr_tex_indirect > I915_MAX_TEX_INDIRECT)
      i915_program_error(p, "Exceeded max nr indirect texture lookups");

   if (p->nr_tex_insn > I915_MAX_TEX_INSN)
      i915_program_error(p, "Exceeded max TEX instructions");
d509 2
a510 1
      i915_program_error(p, "Exceeded max ALU instructions");
d512 4
a515 2
   if (p->nr_decl_insn > I915_MAX_DECL_INSN)
      i915_program_error(p, "Exceeded max DECL instructions");
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d133 1
d190 5
d248 1
a248 1
      assert(dest = UREG(GET_UREG_TYPE(dest), GET_UREG_NR(dest)));
d279 5
d438 8
d447 4
d452 1
a452 4
void
i915_program_error(struct i915_fragment_program *p, const char *msg)
{
   _mesa_problem(NULL, "i915_program_error: %s", msg);
d534 2
a535 1
   FALLBACK(&i915->intel, I915_FALLBACK_PROGRAM, p->error);
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d30 3
a32 3
#include "glheader.h"
#include "macros.h"
#include "enums.h"
d193 3
d243 17
d261 10
a270 1
      if (GET_UREG_TYPE(coord) != REG_TYPE_T) {
a271 1
      }
d280 3
d447 2
a448 1
   p->nr_tex_indirect = 1;      /* correct? */
@


1.1
log
@Initial revision
@
text
@d75 2
a76 1
GLuint i915_get_temp( struct i915_fragment_program *p )
d78 1
a78 1
   int bit = ffs( ~p->temp_flag );
d84 2
a85 2
   p->temp_flag |= 1<<(bit-1);
   return UREG(REG_TYPE_R, (bit-1));
d89 2
a90 1
GLuint i915_get_utemp( struct i915_fragment_program *p )
d92 1
a92 1
   int bit = ffs( ~p->utemp_flag );
d98 2
a99 2
   p->utemp_flag |= 1<<(bit-1);
   return UREG(REG_TYPE_U, (bit-1));
d102 2
a103 1
void i915_release_utemps( struct i915_fragment_program *p )
d109 3
a111 2
GLuint i915_emit_decl( struct i915_fragment_program *p,
		      GLuint type, GLuint nr, GLuint d0_flags )
d116 2
a117 2
      if (p->decl_t & (1<<nr))
	 return reg;
d119 1
a119 1
      p->decl_t |= (1<<nr);
d122 2
a123 2
      if (p->decl_s & (1<<nr))
	 return reg;
d125 1
a125 1
      p->decl_s |= (1<<nr);
d127 1
a127 1
   else 
d130 1
a130 1
   *(p->decl++) = (D0_DCL | D0_DEST( reg ) | d0_flags);
d138 6
a143 8
GLuint i915_emit_arith( struct i915_fragment_program *p,
		       GLuint op,
		       GLuint dest,
		       GLuint mask,
		       GLuint saturate,
		       GLuint src0,
		       GLuint src1,
		       GLuint src2 )
d149 2
a150 1
   assert(dest = UREG(GET_UREG_TYPE(dest), GET_UREG_NR(dest)));
d152 6
a157 3
   if (GET_UREG_TYPE(src0) == REG_TYPE_CONST) c[nr_const++] = 0;
   if (GET_UREG_TYPE(src1) == REG_TYPE_CONST) c[nr_const++] = 1;
   if (GET_UREG_TYPE(src2) == REG_TYPE_CONST) c[nr_const++] = 2;
d173 8
a180 8
      for (i = 1 ; i < nr_const ; i++) {
	 if (GET_UREG_NR(s[c[i]]) != first) {
	    GLuint tmp = i915_get_utemp(p);

	    i915_emit_arith( p, A0_MOV, tmp, A0_DEST_CHANNEL_ALL, 0,
			    s[c[i]], 0, 0 );
	    s[c[i]] = tmp;
	 }
d186 1
a186 1
      p->utemp_flag = old_utemp_flag; /* restore */
d189 3
a191 9
   *(p->csr++) = (op | 
		  A0_DEST( dest ) |
		  mask | 
		  saturate |
		  A0_SRC0( src0 ));
   *(p->csr++) = (A1_SRC0( src0 ) |
		  A1_SRC1( src1 ));
   *(p->csr++) = (A2_SRC1( src1 ) |
		  A2_SRC2( src2 ));
d197 11
d209 1
d216 11
a226 8
   if (coord != UREG(GET_UREG_TYPE(coord), GET_UREG_NR(coord))) {
      /* No real way to work around this in the general case - need to
       * allocate and declare a new temporary register (a utemp won't
       * do).  Will fallback for now.
       */
      i915_program_error(p, "Can't (yet) swizzle TEX arguments");
      return 0;
   }
d228 2
a229 1
   /* Don't worry about saturate as we only support  
d233 1
a233 1
      i915_emit_texld( p, tmp, A0_DEST_CHANNEL_ALL, sampler, coord, op );
d258 2
a259 1
GLuint i915_emit_const1f( struct i915_fragment_program *p, GLfloat c0 )
d263 4
a266 2
   if (c0 == 0.0) return swizzle(UREG(REG_TYPE_R, 0), ZERO, ZERO, ZERO, ZERO);
   if (c0 == 1.0) return swizzle(UREG(REG_TYPE_R, 0), ONE,  ONE,  ONE,  ONE );
d270 1
a270 1
	 continue;
d272 8
a279 7
	 if (!(p->constant_flags[reg] & (1<<idx)) ||
	     p->constant[reg][idx] == c0) {
	    p->constant[reg][idx] = c0;
	    p->constant_flags[reg] |= 1<<idx;
	    if (reg+1 > p->nr_constants) p->nr_constants = reg+1;
	    return swizzle(UREG(REG_TYPE_CONST, reg),idx,ZERO,ZERO,ONE);
	 }
d288 2
a289 2
GLuint i915_emit_const2f( struct i915_fragment_program *p, 
			 GLfloat c0, GLfloat c1 )
d293 9
a301 5
   if (c0 == 0.0) return swizzle(i915_emit_const1f(p, c1), ZERO, X, Z, W);
   if (c0 == 1.0) return swizzle(i915_emit_const1f(p, c1), ONE,  X, Z, W); 

   if (c1 == 0.0) return swizzle(i915_emit_const1f(p, c0), X, ZERO, Z, W);
   if (c1 == 1.0) return swizzle(i915_emit_const1f(p, c0), X, ONE,  Z, W);
d305 2
a306 2
	  p->constant_flags[reg] == I915_CONSTFLAG_PARAM)
	 continue;
d308 9
a316 7
	 if (!(p->constant_flags[reg] & (3<<idx))) {
	    p->constant[reg][idx] = c0;
	    p->constant[reg][idx+1] = c1;
	    p->constant_flags[reg] |= 3<<idx;
	    if (reg+1 > p->nr_constants) p->nr_constants = reg+1;
	    return swizzle(UREG(REG_TYPE_CONST, reg),idx,idx+1,ZERO,ONE);
	 }
d327 3
a329 2
GLuint i915_emit_const4f( struct i915_fragment_program *p, 
			 GLfloat c0, GLfloat c1, GLfloat c2, GLfloat c3 )
d335 4
a338 5
	  p->constant[reg][0] == c0 &&
	  p->constant[reg][1] == c1 &&
	  p->constant[reg][2] == c2 &&
	  p->constant[reg][3] == c3) {
	 return UREG(REG_TYPE_CONST, reg);
d341 8
a348 7
	 p->constant[reg][0] = c0;
	 p->constant[reg][1] = c1;
	 p->constant[reg][2] = c2;
	 p->constant[reg][3] = c3;
	 p->constant_flags[reg] = 0xf;
	 if (reg+1 > p->nr_constants) p->nr_constants = reg+1;
	 return UREG(REG_TYPE_CONST, reg);
d358 2
a359 1
GLuint i915_emit_const4fv( struct i915_fragment_program *p, const GLfloat *c )
d361 1
a361 1
   return i915_emit_const4f( p, c[0], c[1], c[2], c[3] );
d365 2
a366 2
GLuint i915_emit_param4fv( struct i915_fragment_program *p, 
			  const GLfloat *values )
d372 1
a372 1
	 return UREG(REG_TYPE_CONST, p->param[i].reg);
d378 2
a379 6
	 p->constant_flags[reg] = I915_CONSTFLAG_PARAM;
	 i = p->nr_params++;

	 p->param[i].values = values;
	 p->param[i].reg = reg;
	 p->params_uptodate = 0;
d381 7
a387 2
	 if (reg+1 > p->nr_constants) p->nr_constants = reg+1;
	 return UREG(REG_TYPE_CONST, reg);
d398 2
a399 2

void i915_program_error( struct i915_fragment_program *p, const char *msg )
d401 1
a401 4
   /* XXX we shouldn't print anything to stdout, record GL error or
    * call _mesa_problem()
    */
   fprintf(stderr, "%s\n", msg);
d405 3
a407 1
void i915_init_program( i915ContextPtr i915, struct i915_fragment_program *p )
d410 1
a410 2
   TNLcontext *tnl = TNL_CONTEXT( ctx );
   
d416 1
a416 1
   p->nr_tex_indirect = 1;	/* correct? */
d421 2
a422 2
   p->ctx = ctx;  
   memset( p->constant_flags, 0, sizeof(p->constant_flags) );
a434 5
   p->src_texture = UREG_BAD;
   p->src_previous = UREG(REG_TYPE_T, T_DIFFUSE);
   p->last_tex_stage = 0;
   p->VB = &tnl->vb;

d439 2
a440 1
void i915_fini_program( struct i915_fragment_program *p )
d444 2
a445 2
   
   if (p->nr_tex_indirect > I915_MAX_TEX_INDIRECT) 
d459 3
a461 3
      p->FragProg.NumNativeAluInstructions = 0;
      p->FragProg.NumNativeTexInstructions = 0;
      p->FragProg.NumNativeTexIndirections = 0;
d467 3
a469 3
      p->FragProg.NumNativeAluInstructions = p->nr_alu_insn;
      p->FragProg.NumNativeTexInstructions = p->nr_tex_insn;
      p->FragProg.NumNativeTexIndirections = p->nr_tex_indirect;
d475 3
a477 1
void i915_upload_program( i915ContextPtr i915, struct i915_fragment_program *p )
d482 1
a482 1
   FALLBACK( &i915->intel, I915_FALLBACK_PROGRAM, p->error );
d487 4
a490 4
       memcmp(i915->state.Program + decl_size, p->program, 
	      program_size*sizeof(int)) != 0) {
      I915_STATECHANGE( i915, I915_UPLOAD_PROGRAM );
      memcpy(i915->state.Program, p->declarations, decl_size*sizeof(int));
d492 1
a492 1
	     program_size*sizeof(int));
d501 3
a503 3
      
      I915_ACTIVESTATE( i915, I915_UPLOAD_CONSTANTS, 1 );
      I915_STATECHANGE( i915, I915_UPLOAD_CONSTANTS );
d506 3
a508 3
      i915->state.Constant[1] = (1<<(nr-1)) | ((1<<(nr-1))-1);
      
      memcpy(&i915->state.Constant[2], p->constant, 4*sizeof(int)*(nr));
d512 6
a517 8
	 GLuint i;
	 for (i = 0; i < nr; i++) {
	    fprintf(stderr, "const[%d]: %f %f %f %f\n", i, 
		    p->constant[i][0],
		    p->constant[i][1],
		    p->constant[i][2],
		    p->constant[i][3]);
	 }
d521 2
a522 2
      I915_ACTIVESTATE( i915, I915_UPLOAD_CONSTANTS, 0 );
   }  
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d372 4
a375 1
   _mesa_problem(NULL, "i915_program_error: %s", msg);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d433 3
a435 3
      p->FragProg.Base.NumNativeAluInstructions = 0;
      p->FragProg.Base.NumNativeTexInstructions = 0;
      p->FragProg.Base.NumNativeTexIndirections = 0;
d441 3
a443 3
      p->FragProg.Base.NumNativeAluInstructions = p->nr_alu_insn;
      p->FragProg.Base.NumNativeTexInstructions = p->nr_tex_insn;
      p->FragProg.Base.NumNativeTexIndirections = p->nr_tex_indirect;
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d30 3
a32 3
#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"
d75 1
a75 2
GLuint
i915_get_temp(struct i915_fragment_program *p)
d77 1
a77 1
   int bit = ffs(~p->temp_flag);
d83 2
a84 2
   p->temp_flag |= 1 << (bit - 1);
   return UREG(REG_TYPE_R, (bit - 1));
d88 1
a88 2
GLuint
i915_get_utemp(struct i915_fragment_program * p)
d90 1
a90 1
   int bit = ffs(~p->utemp_flag);
d96 2
a97 2
   p->utemp_flag |= 1 << (bit - 1);
   return UREG(REG_TYPE_U, (bit - 1));
d100 1
a100 2
void
i915_release_utemps(struct i915_fragment_program *p)
d106 2
a107 3
GLuint
i915_emit_decl(struct i915_fragment_program *p,
               GLuint type, GLuint nr, GLuint d0_flags)
d112 2
a113 2
      if (p->decl_t & (1 << nr))
         return reg;
d115 1
a115 1
      p->decl_t |= (1 << nr);
d118 2
a119 2
      if (p->decl_s & (1 << nr))
         return reg;
d121 1
a121 1
      p->decl_s |= (1 << nr);
d123 1
a123 1
   else
d126 1
a126 1
   *(p->decl++) = (D0_DCL | D0_DEST(reg) | d0_flags);
a128 1
   assert(p->decl <= p->declarations + ARRAY_SIZE(p->declarations));
d134 8
a141 6
GLuint
i915_emit_arith(struct i915_fragment_program * p,
                GLuint op,
                GLuint dest,
                GLuint mask,
                GLuint saturate, GLuint src0, GLuint src1, GLuint src2)
d147 1
a147 2
   dest = UREG(GET_UREG_TYPE(dest), GET_UREG_NR(dest));
   assert(dest);
d149 3
a151 6
   if (GET_UREG_TYPE(src0) == REG_TYPE_CONST)
      c[nr_const++] = 0;
   if (GET_UREG_TYPE(src1) == REG_TYPE_CONST)
      c[nr_const++] = 1;
   if (GET_UREG_TYPE(src2) == REG_TYPE_CONST)
      c[nr_const++] = 2;
d167 8
a174 8
      for (i = 1; i < nr_const; i++) {
         if (GET_UREG_NR(s[c[i]]) != first) {
            GLuint tmp = i915_get_utemp(p);

            i915_emit_arith(p, A0_MOV, tmp, A0_DEST_CHANNEL_ALL, 0,
                            s[c[i]], 0, 0);
            s[c[i]] = tmp;
         }
d180 1
a180 1
      p->utemp_flag = old_utemp_flag;   /* restore */
d183 9
a191 11
   if (p->csr >= p->program + ARRAY_SIZE(p->program)) {
      i915_program_error(p, "Program contains too many instructions");
      return UREG_BAD;
   }

   *(p->csr++) = (op | A0_DEST(dest) | mask | saturate | A0_SRC0(src0));
   *(p->csr++) = (A1_SRC0(src0) | A1_SRC1(src1));
   *(p->csr++) = (A2_SRC1(src1) | A2_SRC2(src2));

   if (GET_UREG_TYPE(dest) == REG_TYPE_R)
      p->register_phases[GET_UREG_NR(dest)] = p->nr_tex_indirect;
a196 11
static GLuint get_free_rreg (struct i915_fragment_program *p, 
                             GLuint live_regs)
{
    int bit = ffs(~live_regs);
    if (!bit) {
        i915_program_error(p, "Can't find free R reg");
        return UREG_BAD;
    }
    return UREG(REG_TYPE_R, bit - 1);
}

a197 1
			GLuint live_regs,               
d204 8
a211 11
    if (coord != UREG(GET_UREG_TYPE(coord), GET_UREG_NR(coord))) {
        /* With the help of the "needed registers" table created earlier, pick
         * a register we can MOV the swizzled TC to (since TEX doesn't support
         * swizzled sources) */
        GLuint swizCoord = get_free_rreg(p, live_regs);
        if (swizCoord == UREG_BAD) 
            return 0;

        i915_emit_arith( p, A0_MOV, swizCoord, A0_DEST_CHANNEL_ALL, 0, coord, 0, 0 );
        coord = swizCoord;
    }
d213 1
a213 2
   /* Don't worry about saturate as we only support texture formats
    * that are always in the 0..1 range.
d217 1
a217 1
      i915_emit_texld( p, 0, tmp, A0_DEST_CHANNEL_ALL, sampler, coord, op );
d223 1
a223 5
      assert(dest == UREG(GET_UREG_TYPE(dest), GET_UREG_NR(dest)));
      /* Can't use unsaved temps for coords, as the phase boundary would result
       * in the contents becoming undefined.
       */
      assert(GET_UREG_TYPE(coord) != REG_TYPE_U);
d225 1
a225 23
      if ((GET_UREG_TYPE(coord) != REG_TYPE_R) &&
          (GET_UREG_TYPE(coord) != REG_TYPE_OC) &&
          (GET_UREG_TYPE(coord) != REG_TYPE_OD) &&
          (GET_UREG_TYPE(coord) != REG_TYPE_T)) {
          GLuint  tmpCoord = get_free_rreg(p, live_regs);
          
          if (tmpCoord == UREG_BAD) 
              return 0;

          i915_emit_arith(p, A0_MOV, tmpCoord, A0_DEST_CHANNEL_ALL, 0, coord, 0, 0);
          coord = tmpCoord;
      }

      /* Output register being oC or oD defines a phase boundary */
      if (GET_UREG_TYPE(dest) == REG_TYPE_OC ||
	  GET_UREG_TYPE(dest) == REG_TYPE_OD)
	 p->nr_tex_indirect++;

      /* Reading from an r# register whose contents depend on output of the
       * current phase defines a phase boundary.
       */
      if (GET_UREG_TYPE(coord) == REG_TYPE_R &&
	  p->register_phases[GET_UREG_NR(coord)] == p->nr_tex_indirect)
a226 4

      if (p->csr >= p->program + ARRAY_SIZE(p->program)) {
	 i915_program_error(p, "Program contains too many instructions");
	 return UREG_BAD;
a235 3
      if (GET_UREG_TYPE(dest) == REG_TYPE_R)
	 p->register_phases[GET_UREG_NR(dest)] = p->nr_tex_indirect;

d242 1
a242 2
GLuint
i915_emit_const1f(struct i915_fragment_program * p, GLfloat c0)
d246 2
a247 4
   if (c0 == 0.0)
      return swizzle(UREG(REG_TYPE_R, 0), ZERO, ZERO, ZERO, ZERO);
   if (c0 == 1.0)
      return swizzle(UREG(REG_TYPE_R, 0), ONE, ONE, ONE, ONE);
d251 1
a251 1
         continue;
d253 7
a259 8
         if (!(p->constant_flags[reg] & (1 << idx)) ||
             p->constant[reg][idx] == c0) {
            p->constant[reg][idx] = c0;
            p->constant_flags[reg] |= 1 << idx;
            if (reg + 1 > p->nr_constants)
               p->nr_constants = reg + 1;
            return swizzle(UREG(REG_TYPE_CONST, reg), idx, ZERO, ZERO, ONE);
         }
d268 2
a269 2
GLuint
i915_emit_const2f(struct i915_fragment_program * p, GLfloat c0, GLfloat c1)
d273 5
a277 9
   if (c0 == 0.0)
      return swizzle(i915_emit_const1f(p, c1), ZERO, X, Z, W);
   if (c0 == 1.0)
      return swizzle(i915_emit_const1f(p, c1), ONE, X, Z, W);

   if (c1 == 0.0)
      return swizzle(i915_emit_const1f(p, c0), X, ZERO, Z, W);
   if (c1 == 1.0)
      return swizzle(i915_emit_const1f(p, c0), X, ONE, Z, W);
d281 2
a282 2
          p->constant_flags[reg] == I915_CONSTFLAG_PARAM)
         continue;
d284 7
a290 9
         if (!(p->constant_flags[reg] & (3 << idx))) {
            p->constant[reg][idx] = c0;
            p->constant[reg][idx + 1] = c1;
            p->constant_flags[reg] |= 3 << idx;
            if (reg + 1 > p->nr_constants)
               p->nr_constants = reg + 1;
            return swizzle(UREG(REG_TYPE_CONST, reg), idx, idx + 1, ZERO,
                           ONE);
         }
d301 2
a302 3
GLuint
i915_emit_const4f(struct i915_fragment_program * p,
                  GLfloat c0, GLfloat c1, GLfloat c2, GLfloat c3)
d308 5
a312 4
          p->constant[reg][0] == c0 &&
          p->constant[reg][1] == c1 &&
          p->constant[reg][2] == c2 && p->constant[reg][3] == c3) {
         return UREG(REG_TYPE_CONST, reg);
d315 7
a321 8
         p->constant[reg][0] = c0;
         p->constant[reg][1] = c1;
         p->constant[reg][2] = c2;
         p->constant[reg][3] = c3;
         p->constant_flags[reg] = 0xf;
         if (reg + 1 > p->nr_constants)
            p->nr_constants = reg + 1;
         return UREG(REG_TYPE_CONST, reg);
d331 1
a331 2
GLuint
i915_emit_const4fv(struct i915_fragment_program * p, const GLfloat * c)
d333 1
a333 1
   return i915_emit_const4f(p, c[0], c[1], c[2], c[3]);
d337 2
a338 2
GLuint
i915_emit_param4fv(struct i915_fragment_program * p, const GLfloat * values)
d344 1
a344 1
         return UREG(REG_TYPE_CONST, p->param[i].reg);
d350 6
a355 2
         p->constant_flags[reg] = I915_CONSTFLAG_PARAM;
         i = p->nr_params++;
d357 2
a358 7
         p->param[i].values = values;
         p->param[i].reg = reg;
         p->params_uptodate = 0;

         if (reg + 1 > p->nr_constants)
            p->nr_constants = reg + 1;
         return UREG(REG_TYPE_CONST, reg);
a366 8
/* Warning the user about program errors seems to be quite valuable, from
 * our bug reports.  It unfortunately means piglit reporting errors
 * when we fall back to software due to an unsupportable program, though.
 */
void
i915_program_error(struct i915_fragment_program *p, const char *fmt, ...)
{
   va_list args;
a367 4
   fprintf(stderr, "i915_program_error: ");
   va_start(args, fmt);
   vfprintf(stderr, fmt, args);
   va_end(args);
d369 4
a372 1
   fprintf(stderr, "\n");
d376 1
a376 3

void
i915_init_program(struct i915_context *i915, struct i915_fragment_program *p)
d378 3
a380 2
   struct gl_context *ctx = &i915->intel.ctx;

d386 1
a386 2
   memset(&p->register_phases, 0, sizeof(p->register_phases));
   p->nr_tex_indirect = 1;
d391 2
a392 2
   p->ctx = ctx;
   memset(p->constant_flags, 0, sizeof(p->constant_flags));
d405 5
d414 1
a414 2
void
i915_fini_program(struct i915_fragment_program *p)
d418 3
d422 2
a423 10
   if (p->nr_tex_indirect > I915_MAX_TEX_INDIRECT) {
      i915_program_error(p, "Exceeded max nr indirect texture lookups "
			 "(%d out of %d)",
			 p->nr_tex_indirect, I915_MAX_TEX_INDIRECT);
   }

   if (p->nr_tex_insn > I915_MAX_TEX_INSN) {
      i915_program_error(p, "Exceeded max TEX instructions (%d out of %d)",
			 p->nr_tex_insn, I915_MAX_TEX_INSN);
   }
d426 1
a426 2
      i915_program_error(p, "Exceeded max ALU instructions (%d out of %d)",
			 p->nr_alu_insn, I915_MAX_ALU_INSN);
d428 2
a429 4
   if (p->nr_decl_insn > I915_MAX_DECL_INSN) {
      i915_program_error(p, "Exceeded max DECL instructions (%d out of %d)",
			 p->nr_decl_insn, I915_MAX_DECL_INSN);
   }
d449 1
a449 3
void
i915_upload_program(struct i915_context *i915,
                    struct i915_fragment_program *p)
d454 1
a454 2
   if (p->error)
      return;
d459 4
a462 4
       memcmp(i915->state.Program + decl_size, p->program,
              program_size * sizeof(int)) != 0) {
      I915_STATECHANGE(i915, I915_UPLOAD_PROGRAM);
      memcpy(i915->state.Program, p->declarations, decl_size * sizeof(int));
d464 1
a464 1
             program_size * sizeof(int));
d473 3
a475 3

      I915_ACTIVESTATE(i915, I915_UPLOAD_CONSTANTS, 1);
      I915_STATECHANGE(i915, I915_UPLOAD_CONSTANTS);
d478 3
a480 3
      i915->state.Constant[1] = (1 << (nr - 1)) | ((1 << (nr - 1)) - 1);

      memcpy(&i915->state.Constant[2], p->constant, 4 * sizeof(int) * (nr));
d484 8
a491 6
         GLuint i;
         for (i = 0; i < nr; i++) {
            fprintf(stderr, "const[%d]: %f %f %f %f\n", i,
                    p->constant[i][0],
                    p->constant[i][1], p->constant[i][2], p->constant[i][3]);
         }
d495 2
a496 2
      I915_ACTIVESTATE(i915, I915_UPLOAD_CONSTANTS, 0);
   }
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d445 1
a445 2
   if (unlikely((INTEL_DEBUG & (DEBUG_WM | DEBUG_PERF)) != 0)) {
      va_list args;
d447 4
a450 4
      fprintf(stderr, "i915_program_error: ");
      va_start(args, fmt);
      vfprintf(stderr, fmt, args);
      va_end(args);
d452 1
a452 2
      fprintf(stderr, "\n");
   }
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
@


