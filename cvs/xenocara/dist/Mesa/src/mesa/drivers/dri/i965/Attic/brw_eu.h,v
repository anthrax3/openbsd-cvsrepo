head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.04.17;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.15;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.43;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.28.33;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.15.30;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.49;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.11.34;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.48.41;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics to
 develop this 3D driver.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */


#ifndef BRW_EU_H
#define BRW_EU_H

#include <stdbool.h>
#include "brw_structs.h"
#include "brw_defines.h"
#include "brw_reg.h"
#include "program/prog_instruction.h"

#ifdef __cplusplus
extern "C" {
#endif

#define BRW_EU_MAX_INSN_STACK 5

struct brw_compile {
   struct brw_instruction *store;
   int store_size;
   unsigned nr_insn;
   unsigned int next_insn_offset;

   void *mem_ctx;

   /* Allow clients to push/pop instruction state:
    */
   struct brw_instruction stack[BRW_EU_MAX_INSN_STACK];
   bool compressed_stack[BRW_EU_MAX_INSN_STACK];
   struct brw_instruction *current;

   unsigned flag_value;
   bool single_program_flow;
   bool compressed;
   struct brw_context *brw;

   /* Control flow stacks:
    * - if_stack contains IF and ELSE instructions which must be patched
    *   (and popped) once the matching ENDIF instruction is encountered.
    *
    *   Just store the instruction pointer(an index).
    */
   int *if_stack;
   int if_stack_depth;
   int if_stack_array_size;

   /**
    * loop_stack contains the instruction pointers of the starts of loops which
    * must be patched (and popped) once the matching WHILE instruction is
    * encountered.
    */
   int *loop_stack;
   /**
    * pre-gen6, the BREAK and CONT instructions had to tell how many IF/ENDIF
    * blocks they were popping out of, to fix up the mask stack.  This tracks
    * the IF/ENDIF nesting in each current nested loop level.
    */
   int *if_depth_in_loop;
   int loop_stack_depth;
   int loop_stack_array_size;
};

static inline struct brw_instruction *current_insn( struct brw_compile *p)
{
   return &p->store[p->nr_insn];
}

void brw_pop_insn_state( struct brw_compile *p );
void brw_push_insn_state( struct brw_compile *p );
void brw_set_mask_control( struct brw_compile *p, unsigned value );
void brw_set_saturate( struct brw_compile *p, bool enable );
void brw_set_access_mode( struct brw_compile *p, unsigned access_mode );
void brw_set_compression_control(struct brw_compile *p, enum brw_compression c);
void brw_set_predicate_control_flag_value( struct brw_compile *p, unsigned value );
void brw_set_predicate_control( struct brw_compile *p, unsigned pc );
void brw_set_predicate_inverse(struct brw_compile *p, bool predicate_inverse);
void brw_set_conditionalmod( struct brw_compile *p, unsigned conditional );
void brw_set_flag_reg(struct brw_compile *p, int reg, int subreg);
void brw_set_acc_write_control(struct brw_compile *p, unsigned value);

void brw_init_compile(struct brw_context *, struct brw_compile *p,
		      void *mem_ctx);
void brw_dump_compile(struct brw_compile *p, FILE *out, int start, int end);
const unsigned *brw_get_program( struct brw_compile *p, unsigned *sz );

struct brw_instruction *brw_next_insn(struct brw_compile *p, unsigned opcode);
void brw_set_dest(struct brw_compile *p, struct brw_instruction *insn,
		  struct brw_reg dest);
void brw_set_src0(struct brw_compile *p, struct brw_instruction *insn,
		  struct brw_reg reg);

void gen6_resolve_implied_move(struct brw_compile *p,
			       struct brw_reg *src,
			       unsigned msg_reg_nr);

/* Helpers for regular instructions:
 */
#define ALU1(OP)					\
struct brw_instruction *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,			\
	      struct brw_reg src0);

#define ALU2(OP)					\
struct brw_instruction *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,			\
	      struct brw_reg src0,			\
	      struct brw_reg src1);

#define ALU3(OP)					\
struct brw_instruction *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,			\
	      struct brw_reg src0,			\
	      struct brw_reg src1,			\
	      struct brw_reg src2);

#define ROUND(OP) \
void brw_##OP(struct brw_compile *p, struct brw_reg dest, struct brw_reg src0);

ALU1(MOV)
ALU2(SEL)
ALU1(NOT)
ALU2(AND)
ALU2(OR)
ALU2(XOR)
ALU2(SHR)
ALU2(SHL)
ALU2(ASR)
ALU1(F32TO16)
ALU1(F16TO32)
ALU2(JMPI)
ALU2(ADD)
ALU2(AVG)
ALU2(MUL)
ALU1(FRC)
ALU1(RNDD)
ALU2(MAC)
ALU2(MACH)
ALU1(LZD)
ALU2(DP4)
ALU2(DPH)
ALU2(DP3)
ALU2(DP2)
ALU2(LINE)
ALU2(PLN)
ALU3(MAD)
ALU3(LRP)
ALU1(BFREV)
ALU3(BFE)
ALU2(BFI1)
ALU3(BFI2)
ALU1(FBH)
ALU1(FBL)
ALU1(CBIT)
ALU2(ADDC)
ALU2(SUBB)
ALU2(MAC)

ROUND(RNDZ)
ROUND(RNDE)

#undef ALU1
#undef ALU2
#undef ALU3
#undef ROUND


/* Helpers for SEND instruction:
 */
void brw_set_sampler_message(struct brw_compile *p,
                             struct brw_instruction *insn,
                             unsigned binding_table_index,
                             unsigned sampler,
                             unsigned msg_type,
                             unsigned response_length,
                             unsigned msg_length,
                             unsigned header_present,
                             unsigned simd_mode,
                             unsigned return_format);

void brw_set_dp_read_message(struct brw_compile *p,
			     struct brw_instruction *insn,
			     unsigned binding_table_index,
			     unsigned msg_control,
			     unsigned msg_type,
			     unsigned target_cache,
			     unsigned msg_length,
                             bool header_present,
			     unsigned response_length);

void brw_set_dp_write_message(struct brw_compile *p,
			      struct brw_instruction *insn,
			      unsigned binding_table_index,
			      unsigned msg_control,
			      unsigned msg_type,
			      unsigned msg_length,
			      bool header_present,
			      unsigned last_render_target,
			      unsigned response_length,
			      unsigned end_of_thread,
			      unsigned send_commit_msg);

void brw_urb_WRITE(struct brw_compile *p,
		   struct brw_reg dest,
		   unsigned msg_reg_nr,
		   struct brw_reg src0,
                   enum brw_urb_write_flags flags,
		   unsigned msg_length,
		   unsigned response_length,
		   unsigned offset,
		   unsigned swizzle);

void brw_ff_sync(struct brw_compile *p,
		   struct brw_reg dest,
		   unsigned msg_reg_nr,
		   struct brw_reg src0,
		   bool allocate,
		   unsigned response_length,
		   bool eot);

void brw_svb_write(struct brw_compile *p,
                   struct brw_reg dest,
                   unsigned msg_reg_nr,
                   struct brw_reg src0,
                   unsigned binding_table_index,
                   bool   send_commit_msg);

void brw_fb_WRITE(struct brw_compile *p,
		  int dispatch_width,
		   unsigned msg_reg_nr,
		   struct brw_reg src0,
		   unsigned msg_control,
		   unsigned binding_table_index,
		   unsigned msg_length,
		   unsigned response_length,
		   bool eot,
		   bool header_present);

void brw_SAMPLE(struct brw_compile *p,
		struct brw_reg dest,
		unsigned msg_reg_nr,
		struct brw_reg src0,
		unsigned binding_table_index,
		unsigned sampler,
		unsigned msg_type,
		unsigned response_length,
		unsigned msg_length,
		unsigned header_present,
		unsigned simd_mode,
		unsigned return_format);

void brw_math( struct brw_compile *p,
	       struct brw_reg dest,
	       unsigned function,
	       unsigned msg_reg_nr,
	       struct brw_reg src,
	       unsigned data_type,
	       unsigned precision );

void brw_math2(struct brw_compile *p,
	       struct brw_reg dest,
	       unsigned function,
	       struct brw_reg src0,
	       struct brw_reg src1);

void brw_oword_block_read(struct brw_compile *p,
			  struct brw_reg dest,
			  struct brw_reg mrf,
			  uint32_t offset,
			  uint32_t bind_table_index);

void brw_oword_block_read_scratch(struct brw_compile *p,
				  struct brw_reg dest,
				  struct brw_reg mrf,
				  int num_regs,
				  unsigned offset);

void brw_oword_block_write_scratch(struct brw_compile *p,
				   struct brw_reg mrf,
				   int num_regs,
				   unsigned offset);

void gen7_block_read_scratch(struct brw_compile *p,
                             struct brw_reg dest,
                             int num_regs,
                             unsigned offset);

void brw_shader_time_add(struct brw_compile *p,
                         struct brw_reg payload,
                         uint32_t surf_index);

/* If/else/endif.  Works by manipulating the execution flags on each
 * channel.
 */
struct brw_instruction *brw_IF(struct brw_compile *p,
			       unsigned execute_size);
struct brw_instruction *gen6_IF(struct brw_compile *p, uint32_t conditional,
				struct brw_reg src0, struct brw_reg src1);

void brw_ELSE(struct brw_compile *p);
void brw_ENDIF(struct brw_compile *p);

/* DO/WHILE loops:
 */
struct brw_instruction *brw_DO(struct brw_compile *p,
			       unsigned execute_size);

struct brw_instruction *brw_WHILE(struct brw_compile *p);

struct brw_instruction *brw_BREAK(struct brw_compile *p);
struct brw_instruction *brw_CONT(struct brw_compile *p);
struct brw_instruction *gen6_CONT(struct brw_compile *p);
struct brw_instruction *gen6_HALT(struct brw_compile *p);
/* Forward jumps:
 */
void brw_land_fwd_jump(struct brw_compile *p, int jmp_insn_idx);



void brw_NOP(struct brw_compile *p);

void brw_WAIT(struct brw_compile *p);

/* Special case: there is never a destination, execution size will be
 * taken from src0:
 */
void brw_CMP(struct brw_compile *p,
	     struct brw_reg dest,
	     unsigned conditional,
	     struct brw_reg src0,
	     struct brw_reg src1);

void
brw_untyped_atomic(struct brw_compile *p,
                   struct brw_reg dest,
                   struct brw_reg mrf,
                   unsigned atomic_op,
                   unsigned bind_table_index,
                   unsigned msg_length,
                   unsigned response_length);

void
brw_untyped_surface_read(struct brw_compile *p,
                         struct brw_reg dest,
                         struct brw_reg mrf,
                         unsigned bind_table_index,
                         unsigned msg_length,
                         unsigned response_length);

/***********************************************************************
 * brw_eu_util.c:
 */

void brw_copy_indirect_to_indirect(struct brw_compile *p,
				   struct brw_indirect dst_ptr,
				   struct brw_indirect src_ptr,
				   unsigned count);

void brw_copy_from_indirect(struct brw_compile *p,
			    struct brw_reg dst,
			    struct brw_indirect ptr,
			    unsigned count);

void brw_copy4(struct brw_compile *p,
	       struct brw_reg dst,
	       struct brw_reg src,
	       unsigned count);

void brw_copy8(struct brw_compile *p,
	       struct brw_reg dst,
	       struct brw_reg src,
	       unsigned count);

void brw_math_invert( struct brw_compile *p,
		      struct brw_reg dst,
		      struct brw_reg src);

void brw_set_src1(struct brw_compile *p,
		  struct brw_instruction *insn,
		  struct brw_reg reg);

void brw_set_uip_jip(struct brw_compile *p);

uint32_t brw_swap_cmod(uint32_t cmod);

/* brw_eu_compact.c */
void brw_init_compaction_tables(struct brw_context *brw);
void brw_compact_instructions(struct brw_compile *p);
void brw_uncompact_instruction(struct brw_context *brw,
			       struct brw_instruction *dst,
			       struct brw_compact_instruction *src);
bool brw_try_compact_instruction(struct brw_compile *p,
                                 struct brw_compact_instruction *dst,
                                 struct brw_instruction *src);

void brw_debug_compact_uncompact(struct brw_context *brw,
				 struct brw_instruction *orig,
				 struct brw_instruction *uncompacted);

#ifdef __cplusplus
}
#endif

#endif
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a36 1
#include "brw_inst.h"
a39 1
#include "intel_asm_annotation.h"
a47 6
/* A helper for accessing the last instruction emitted.  This makes it easy
 * to set various bits on an instruction without having to create temporary
 * variable and assign the emitted instruction to those.
 */
#define brw_last_inst (&p->store[p->nr_insn - 1])

d49 1
a49 1
   brw_inst *store;
d58 1
a58 1
   brw_inst stack[BRW_EU_MAX_INSN_STACK];
d60 1
a60 1
   brw_inst *current;
d62 1
d93 5
d100 10
a109 8
void brw_set_default_mask_control( struct brw_compile *p, unsigned value );
void brw_set_default_saturate( struct brw_compile *p, bool enable );
void brw_set_default_access_mode( struct brw_compile *p, unsigned access_mode );
void brw_set_default_compression_control(struct brw_compile *p, enum brw_compression c);
void brw_set_default_predicate_control( struct brw_compile *p, unsigned pc );
void brw_set_default_predicate_inverse(struct brw_compile *p, bool predicate_inverse);
void brw_set_default_flag_reg(struct brw_compile *p, int reg, int subreg);
void brw_set_default_acc_write_control(struct brw_compile *p, unsigned value);
d113 1
a113 2
void brw_disassemble(struct brw_context *brw, void *assembly,
                     int start, int end, FILE *out);
d116 5
a120 3
brw_inst *brw_next_insn(struct brw_compile *p, unsigned opcode);
void brw_set_dest(struct brw_compile *p, brw_inst *insn, struct brw_reg dest);
void brw_set_src0(struct brw_compile *p, brw_inst *insn, struct brw_reg reg);
d128 3
a130 3
#define ALU1(OP)				\
brw_inst *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,		\
d133 4
a136 4
#define ALU2(OP)				\
brw_inst *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,		\
	      struct brw_reg src0,		\
d139 5
a143 5
#define ALU3(OP)				\
brw_inst *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,		\
	      struct brw_reg src0,		\
	      struct brw_reg src1,		\
d160 1
d200 1
a200 1
                             brw_inst *insn,
a209 5
void brw_set_indirect_send_descriptor(struct brw_compile *p,
                                      brw_inst *insn,
                                      unsigned sfid,
                                      struct brw_reg descriptor);

d211 1
a211 1
			     brw_inst *insn,
d221 1
a221 1
			      brw_inst *insn,
d259 2
a260 2
		   struct brw_reg payload,
		   struct brw_reg implied_header,
d281 1
a281 6
void brw_adjust_sampler_state_pointer(struct brw_compile *p,
                                      struct brw_reg header,
                                      struct brw_reg sampler_index,
                                      struct brw_reg scratch);

void gen4_math(struct brw_compile *p,
d286 1
d289 1
a289 1
void gen6_math(struct brw_compile *p,
a320 24
/**
 * Return the generation-specific jump distance scaling factor.
 *
 * Given the number of instructions to jump, we need to scale by
 * some number to obtain the actual jump distance to program in an
 * instruction.
 */
static inline unsigned
brw_jump_scale(const struct brw_context *brw)
{
   /* Broadwell measures jump targets in bytes. */
   if (brw->gen >= 8)
      return 16;

   /* Ironlake and later measure jump targets in 64-bit data chunks (in order
    * (to support compaction), so each 128-bit instruction requires 2 chunks.
    */
   if (brw->gen >= 5)
      return 2;

   /* Gen4 simply uses the number of 128-bit instructions. */
   return 1;
}

d324 4
a327 3
brw_inst *brw_IF(struct brw_compile *p, unsigned execute_size);
brw_inst *gen6_IF(struct brw_compile *p, enum brw_conditional_mod conditional,
                  struct brw_reg src0, struct brw_reg src1);
d334 2
a335 1
brw_inst *brw_DO(struct brw_compile *p, unsigned execute_size);
d337 1
a337 5
brw_inst *brw_WHILE(struct brw_compile *p);

brw_inst *brw_BREAK(struct brw_compile *p);
brw_inst *brw_CONT(struct brw_compile *p);
brw_inst *gen6_HALT(struct brw_compile *p);
d339 4
d347 1
a347 2
brw_inst *brw_JMPI(struct brw_compile *p, struct brw_reg index,
                   unsigned predicate_control);
d351 2
d365 1
a365 1
                   struct brw_reg payload,
a378 10
void
brw_pixel_interpolator_query(struct brw_compile *p,
                             struct brw_reg dest,
                             struct brw_reg mrf,
                             bool noperspective,
                             unsigned mode,
                             unsigned data,
                             unsigned msg_length,
                             unsigned response_length);

d407 3
a409 1
void brw_set_src1(struct brw_compile *p, brw_inst *insn, struct brw_reg reg);
d413 1
a413 1
enum brw_conditional_mod brw_swap_cmod(uint32_t cmod);
d417 11
a427 20
void brw_compact_instructions(struct brw_compile *p, int start_offset,
                              int num_annotations, struct annotation *annotation);
void brw_uncompact_instruction(struct brw_context *brw, brw_inst *dst,
                               brw_compact_inst *src);
bool brw_try_compact_instruction(struct brw_context *brw, brw_compact_inst *dst,
                                 brw_inst *src);

void brw_debug_compact_uncompact(struct brw_context *brw, brw_inst *orig,
                                 brw_inst *uncompacted);

static inline int
next_offset(const struct brw_context *brw, void *store, int offset)
{
   brw_inst *insn = (brw_inst *)((char *)store + offset);

   if (brw_inst_cmpt_control(brw, insn))
      return offset + 8;
   else
      return offset + 16;
}
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d37 1
d41 1
d50 6
d57 1
a57 1
   struct brw_instruction *store;
d66 1
a66 1
   struct brw_instruction stack[BRW_EU_MAX_INSN_STACK];
d68 1
a68 1
   struct brw_instruction *current;
a69 1
   unsigned flag_value;
a99 5
static inline struct brw_instruction *current_insn( struct brw_compile *p)
{
   return &p->store[p->nr_insn];
}

d102 8
a109 10
void brw_set_mask_control( struct brw_compile *p, unsigned value );
void brw_set_saturate( struct brw_compile *p, bool enable );
void brw_set_access_mode( struct brw_compile *p, unsigned access_mode );
void brw_set_compression_control(struct brw_compile *p, enum brw_compression c);
void brw_set_predicate_control_flag_value( struct brw_compile *p, unsigned value );
void brw_set_predicate_control( struct brw_compile *p, unsigned pc );
void brw_set_predicate_inverse(struct brw_compile *p, bool predicate_inverse);
void brw_set_conditionalmod( struct brw_compile *p, unsigned conditional );
void brw_set_flag_reg(struct brw_compile *p, int reg, int subreg);
void brw_set_acc_write_control(struct brw_compile *p, unsigned value);
d113 2
a114 1
void brw_dump_compile(struct brw_compile *p, FILE *out, int start, int end);
d117 3
a119 5
struct brw_instruction *brw_next_insn(struct brw_compile *p, unsigned opcode);
void brw_set_dest(struct brw_compile *p, struct brw_instruction *insn,
		  struct brw_reg dest);
void brw_set_src0(struct brw_compile *p, struct brw_instruction *insn,
		  struct brw_reg reg);
d127 3
a129 3
#define ALU1(OP)					\
struct brw_instruction *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,			\
d132 4
a135 4
#define ALU2(OP)					\
struct brw_instruction *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,			\
	      struct brw_reg src0,			\
d138 5
a142 5
#define ALU3(OP)					\
struct brw_instruction *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,			\
	      struct brw_reg src0,			\
	      struct brw_reg src1,			\
a158 1
ALU2(JMPI)
d198 1
a198 1
                             struct brw_instruction *insn,
d208 5
d214 1
a214 1
			     struct brw_instruction *insn,
d224 1
a224 1
			      struct brw_instruction *insn,
d262 2
a263 2
		   unsigned msg_reg_nr,
		   struct brw_reg src0,
d284 6
a289 1
void brw_math( struct brw_compile *p,
a293 1
	       unsigned data_type,
d296 1
a296 1
void brw_math2(struct brw_compile *p,
d328 24
d355 3
a357 4
struct brw_instruction *brw_IF(struct brw_compile *p,
			       unsigned execute_size);
struct brw_instruction *gen6_IF(struct brw_compile *p, uint32_t conditional,
				struct brw_reg src0, struct brw_reg src1);
d364 1
a364 2
struct brw_instruction *brw_DO(struct brw_compile *p,
			       unsigned execute_size);
d366 5
a370 1
struct brw_instruction *brw_WHILE(struct brw_compile *p);
a371 4
struct brw_instruction *brw_BREAK(struct brw_compile *p);
struct brw_instruction *brw_CONT(struct brw_compile *p);
struct brw_instruction *gen6_CONT(struct brw_compile *p);
struct brw_instruction *gen6_HALT(struct brw_compile *p);
d376 2
a377 1

a380 2
void brw_WAIT(struct brw_compile *p);

d393 1
a393 1
                   struct brw_reg mrf,
d407 10
d445 1
a445 3
void brw_set_src1(struct brw_compile *p,
		  struct brw_instruction *insn,
		  struct brw_reg reg);
d449 1
a449 1
uint32_t brw_swap_cmod(uint32_t cmod);
d453 20
a472 11
void brw_compact_instructions(struct brw_compile *p);
void brw_uncompact_instruction(struct brw_context *brw,
			       struct brw_instruction *dst,
			       struct brw_compact_instruction *src);
bool brw_try_compact_instruction(struct brw_compile *p,
                                 struct brw_compact_instruction *dst,
                                 struct brw_instruction *src);

void brw_debug_compact_uncompact(struct brw_context *brw,
				 struct brw_instruction *orig,
				 struct brw_instruction *uncompacted);
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
d5 1
a5 1
 
d13 1
a13 1
 
d17 1
a17 1
 
d25 1
a25 1
 
d29 1
a29 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d31 1
a31 1
   
d51 1
a51 1
   GLuint nr_insn;
d62 1
a62 1
   GLuint flag_value;
d93 1
a93 1
static INLINE struct brw_instruction *current_insn( struct brw_compile *p)
d100 1
a100 1
void brw_set_mask_control( struct brw_compile *p, GLuint value );
d102 1
a102 1
void brw_set_access_mode( struct brw_compile *p, GLuint access_mode );
d104 2
a105 2
void brw_set_predicate_control_flag_value( struct brw_compile *p, GLuint value );
void brw_set_predicate_control( struct brw_compile *p, GLuint pc );
d107 1
a107 1
void brw_set_conditionalmod( struct brw_compile *p, GLuint conditional );
d109 1
a109 1
void brw_set_acc_write_control(struct brw_compile *p, GLuint value);
d114 1
a114 1
const GLuint *brw_get_program( struct brw_compile *p, GLuint *sz );
d116 1
a116 1
struct brw_instruction *brw_next_insn(struct brw_compile *p, GLuint opcode);
d124 1
a124 1
			       GLuint msg_reg_nr);
a156 2
ALU2(RSR)
ALU2(RSL)
d184 3
d201 8
a208 8
                             GLuint binding_table_index,
                             GLuint sampler,
                             GLuint msg_type,
                             GLuint response_length,
                             GLuint msg_length,
                             GLuint header_present,
                             GLuint simd_mode,
                             GLuint return_format);
d212 5
a216 5
			     GLuint binding_table_index,
			     GLuint msg_control,
			     GLuint msg_type,
			     GLuint target_cache,
			     GLuint msg_length,
d218 1
a218 1
			     GLuint response_length);
d222 4
a225 4
			      GLuint binding_table_index,
			      GLuint msg_control,
			      GLuint msg_type,
			      GLuint msg_length,
d227 4
a230 4
			      GLuint last_render_target,
			      GLuint response_length,
			      GLuint end_of_thread,
			      GLuint send_commit_msg);
d234 1
a234 1
		   GLuint msg_reg_nr,
d236 5
a240 8
		   bool allocate,
		   bool used,
		   GLuint msg_length,
		   GLuint response_length,
		   bool eot,
		   bool writes_complete,
		   GLuint offset,
		   GLuint swizzle);
d244 1
a244 1
		   GLuint msg_reg_nr,
d247 1
a247 1
		   GLuint response_length,
d252 1
a252 1
                   GLuint msg_reg_nr,
d254 1
a254 1
                   GLuint binding_table_index,
d259 1
a259 1
		   GLuint msg_reg_nr,
d261 4
a264 4
		   GLuint msg_control,
		   GLuint binding_table_index,
		   GLuint msg_length,
		   GLuint response_length,
d270 1
a270 1
		GLuint msg_reg_nr,
d272 8
a279 8
		GLuint binding_table_index,
		GLuint sampler,
		GLuint msg_type,
		GLuint response_length,
		GLuint msg_length,
		GLuint header_present,
		GLuint simd_mode,
		GLuint return_format);
d283 2
a284 2
	       GLuint function,
	       GLuint msg_reg_nr,
d286 2
a287 2
	       GLuint data_type,
	       GLuint precision );
d291 1
a291 1
	       GLuint function,
d305 1
a305 1
				  GLuint offset);
d310 6
a315 1
				   GLuint offset);
d324 2
a325 2
struct brw_instruction *brw_IF(struct brw_compile *p, 
			       GLuint execute_size);
d335 1
a335 1
			       GLuint execute_size);
d358 1
a358 1
	     GLuint conditional,
d362 18
a379 1
/*********************************************************************** 
d386 1
a386 1
				   GLuint count);
d391 1
a391 1
			    GLuint count);
d396 1
a396 1
	       GLuint count);
d401 1
a401 1
	       GLuint count);
d403 1
a403 1
void brw_math_invert( struct brw_compile *p, 
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d39 1
d42 3
a44 58
#define BRW_SWIZZLE4(a,b,c,d) (((a)<<0) | ((b)<<2) | ((c)<<4) | ((d)<<6))
#define BRW_GET_SWZ(swz, idx) (((swz) >> ((idx)*2)) & 0x3)

#define BRW_SWIZZLE_NOOP      BRW_SWIZZLE4(0,1,2,3)
#define BRW_SWIZZLE_XYZW      BRW_SWIZZLE4(0,1,2,3)
#define BRW_SWIZZLE_XXXX      BRW_SWIZZLE4(0,0,0,0)
#define BRW_SWIZZLE_XYXY      BRW_SWIZZLE4(0,1,0,1)


#define REG_SIZE (8*4)


/* These aren't hardware structs, just something useful for us to pass around:
 *
 * Align1 operation has a lot of control over input ranges.  Used in
 * WM programs to implement shaders decomposed into "channel serial"
 * or "structure of array" form:
 */
struct brw_reg
{
   GLuint type:4;
   GLuint file:2;
   GLuint nr:8;
   GLuint subnr:5;		/* :1 in align16 */
   GLuint negate:1;		/* source only */
   GLuint abs:1;		/* source only */
   GLuint vstride:4;		/* source only */
   GLuint width:3;		/* src only, align1 only */
   GLuint hstride:2;   		/* align1 only */
   GLuint address_mode:1;	/* relative addressing, hopefully! */
   GLuint pad0:1;

   union {      
      struct {
	 GLuint swizzle:8;		/* src only, align16 only */
	 GLuint writemask:4;		/* dest only, align16 only */
	 GLint  indirect_offset:10;	/* relative addressing offset */
	 GLuint pad1:10;		/* two dwords total */
      } bits;

      GLfloat f;
      GLint   d;
      GLuint ud;
   } dw1;      
};


struct brw_indirect {
   GLuint addr_subnr:4;
   GLint addr_offset:10;
   GLuint pad:18;
};


struct brw_glsl_label;
struct brw_glsl_call;


a46 1
#define BRW_EU_MAX_INSN 10000
d49 2
a50 1
   struct brw_instruction store[BRW_EU_MAX_INSN];
d52 1
d63 1
a63 1
   GLboolean single_program_flow;
d70 2
d73 1
a73 1
   struct brw_instruction **if_stack;
d77 14
a90 2
   struct brw_glsl_label *first_label;  /**< linked list of labels */
   struct brw_glsl_call *first_call;    /**< linked list of CALs */
a92 648

void
brw_save_label(struct brw_compile *c, const char *name, GLuint position);

void
brw_save_call(struct brw_compile *c, const char *name, GLuint call_pos);

void
brw_resolve_cals(struct brw_compile *c);



static INLINE int type_sz( GLuint type )
{
   switch( type ) {
   case BRW_REGISTER_TYPE_UD:
   case BRW_REGISTER_TYPE_D:
   case BRW_REGISTER_TYPE_F:
      return 4;
   case BRW_REGISTER_TYPE_HF:
   case BRW_REGISTER_TYPE_UW:
   case BRW_REGISTER_TYPE_W:
      return 2;
   case BRW_REGISTER_TYPE_UB:
   case BRW_REGISTER_TYPE_B:
      return 1;
   default:
      return 0;
   }
}

/**
 * Construct a brw_reg.
 * \param file  one of the BRW_x_REGISTER_FILE values
 * \param nr  register number/index
 * \param subnr  register sub number
 * \param type  one of BRW_REGISTER_TYPE_x
 * \param vstride  one of BRW_VERTICAL_STRIDE_x
 * \param width  one of BRW_WIDTH_x
 * \param hstride  one of BRW_HORIZONTAL_STRIDE_x
 * \param swizzle  one of BRW_SWIZZLE_x
 * \param writemask  WRITEMASK_X/Y/Z/W bitfield
 */
static INLINE struct brw_reg brw_reg( GLuint file,
                                      GLuint nr,
                                      GLuint subnr,
                                      GLuint type,
                                      GLuint vstride,
                                      GLuint width,
                                      GLuint hstride,
                                      GLuint swizzle,
                                      GLuint writemask )
{
   struct brw_reg reg;
   if (file == BRW_GENERAL_REGISTER_FILE)
      assert(nr < BRW_MAX_GRF);
   else if (file == BRW_MESSAGE_REGISTER_FILE)
      assert((nr & ~(1 << 7)) < BRW_MAX_MRF);
   else if (file == BRW_ARCHITECTURE_REGISTER_FILE)
      assert(nr <= BRW_ARF_IP);

   reg.type = type;
   reg.file = file;
   reg.nr = nr;
   reg.subnr = subnr * type_sz(type);
   reg.negate = 0;
   reg.abs = 0;
   reg.vstride = vstride;
   reg.width = width;
   reg.hstride = hstride;
   reg.address_mode = BRW_ADDRESS_DIRECT;
   reg.pad0 = 0;

   /* Could do better: If the reg is r5.3<0;1,0>, we probably want to
    * set swizzle and writemask to W, as the lower bits of subnr will
    * be lost when converted to align16.  This is probably too much to
    * keep track of as you'd want it adjusted by suboffset(), etc.
    * Perhaps fix up when converting to align16?
    */
   reg.dw1.bits.swizzle = swizzle;
   reg.dw1.bits.writemask = writemask;
   reg.dw1.bits.indirect_offset = 0;
   reg.dw1.bits.pad1 = 0;
   return reg;
}

/** Construct float[16] register */
static INLINE struct brw_reg brw_vec16_reg( GLuint file,
					      GLuint nr,
					      GLuint subnr )
{
   return brw_reg(file,
		  nr,
		  subnr,
		  BRW_REGISTER_TYPE_F,
		  BRW_VERTICAL_STRIDE_16,
		  BRW_WIDTH_16,
		  BRW_HORIZONTAL_STRIDE_1,
		  BRW_SWIZZLE_XYZW,
		  WRITEMASK_XYZW);
}

/** Construct float[8] register */
static INLINE struct brw_reg brw_vec8_reg( GLuint file,
					     GLuint nr,
					     GLuint subnr )
{
   return brw_reg(file,
		  nr,
		  subnr,
		  BRW_REGISTER_TYPE_F,
		  BRW_VERTICAL_STRIDE_8,
		  BRW_WIDTH_8,
		  BRW_HORIZONTAL_STRIDE_1,
		  BRW_SWIZZLE_XYZW,
		  WRITEMASK_XYZW);
}

/** Construct float[4] register */
static INLINE struct brw_reg brw_vec4_reg( GLuint file,
					      GLuint nr,
					      GLuint subnr )
{
   return brw_reg(file,
		  nr,
		  subnr,
		  BRW_REGISTER_TYPE_F,
		  BRW_VERTICAL_STRIDE_4,
		  BRW_WIDTH_4,
		  BRW_HORIZONTAL_STRIDE_1,
		  BRW_SWIZZLE_XYZW,
		  WRITEMASK_XYZW);
}

/** Construct float[2] register */
static INLINE struct brw_reg brw_vec2_reg( GLuint file,
					      GLuint nr,
					      GLuint subnr )
{
   return brw_reg(file,
		  nr,
		  subnr,
		  BRW_REGISTER_TYPE_F,
		  BRW_VERTICAL_STRIDE_2,
		  BRW_WIDTH_2,
		  BRW_HORIZONTAL_STRIDE_1,
		  BRW_SWIZZLE_XYXY,
		  WRITEMASK_XY);
}

/** Construct float[1] register */
static INLINE struct brw_reg brw_vec1_reg( GLuint file,
					     GLuint nr,
					     GLuint subnr )
{
   return brw_reg(file,
		  nr,
		  subnr,
		  BRW_REGISTER_TYPE_F,
		  BRW_VERTICAL_STRIDE_0,
		  BRW_WIDTH_1,
		  BRW_HORIZONTAL_STRIDE_0,
		  BRW_SWIZZLE_XXXX,
		  WRITEMASK_X);
}


static INLINE struct brw_reg retype( struct brw_reg reg,
				       GLuint type )
{
   reg.type = type;
   return reg;
}

static inline struct brw_reg
sechalf(struct brw_reg reg)
{
   if (reg.vstride)
      reg.nr++;
   return reg;
}

static INLINE struct brw_reg suboffset( struct brw_reg reg,
					  GLuint delta )
{   
   reg.subnr += delta * type_sz(reg.type);
   return reg;
}


static INLINE struct brw_reg offset( struct brw_reg reg,
				       GLuint delta )
{
   reg.nr += delta;
   return reg;
}


static INLINE struct brw_reg byte_offset( struct brw_reg reg,
					    GLuint bytes )
{
   GLuint newoffset = reg.nr * REG_SIZE + reg.subnr + bytes;
   reg.nr = newoffset / REG_SIZE;
   reg.subnr = newoffset % REG_SIZE;
   return reg;
}
   

/** Construct unsigned word[16] register */
static INLINE struct brw_reg brw_uw16_reg( GLuint file,
					     GLuint nr,
					     GLuint subnr )
{
   return suboffset(retype(brw_vec16_reg(file, nr, 0), BRW_REGISTER_TYPE_UW), subnr);
}

/** Construct unsigned word[8] register */
static INLINE struct brw_reg brw_uw8_reg( GLuint file,
					    GLuint nr,
					    GLuint subnr )
{
   return suboffset(retype(brw_vec8_reg(file, nr, 0), BRW_REGISTER_TYPE_UW), subnr);
}

/** Construct unsigned word[1] register */
static INLINE struct brw_reg brw_uw1_reg( GLuint file,
					    GLuint nr,
					    GLuint subnr )
{
   return suboffset(retype(brw_vec1_reg(file, nr, 0), BRW_REGISTER_TYPE_UW), subnr);
}

static INLINE struct brw_reg brw_imm_reg( GLuint type )
{
   return brw_reg( BRW_IMMEDIATE_VALUE,
		   0,
		   0,
		   type,
		   BRW_VERTICAL_STRIDE_0,
		   BRW_WIDTH_1,
		   BRW_HORIZONTAL_STRIDE_0,
		   0,
		   0);      
}

/** Construct float immediate register */
static INLINE struct brw_reg brw_imm_f( GLfloat f )
{
   struct brw_reg imm = brw_imm_reg(BRW_REGISTER_TYPE_F);
   imm.dw1.f = f;
   return imm;
}

/** Construct integer immediate register */
static INLINE struct brw_reg brw_imm_d( GLint d )
{
   struct brw_reg imm = brw_imm_reg(BRW_REGISTER_TYPE_D);
   imm.dw1.d = d;
   return imm;
}

/** Construct uint immediate register */
static INLINE struct brw_reg brw_imm_ud( GLuint ud )
{
   struct brw_reg imm = brw_imm_reg(BRW_REGISTER_TYPE_UD);
   imm.dw1.ud = ud;
   return imm;
}

/** Construct ushort immediate register */
static INLINE struct brw_reg brw_imm_uw( GLushort uw )
{
   struct brw_reg imm = brw_imm_reg(BRW_REGISTER_TYPE_UW);
   imm.dw1.ud = uw | (uw << 16);
   return imm;
}

/** Construct short immediate register */
static INLINE struct brw_reg brw_imm_w( GLshort w )
{
   struct brw_reg imm = brw_imm_reg(BRW_REGISTER_TYPE_W);
   imm.dw1.d = w | (w << 16);
   return imm;
}

/* brw_imm_b and brw_imm_ub aren't supported by hardware - the type
 * numbers alias with _V and _VF below:
 */

/** Construct vector of eight signed half-byte values */
static INLINE struct brw_reg brw_imm_v( GLuint v )
{
   struct brw_reg imm = brw_imm_reg(BRW_REGISTER_TYPE_V);
   imm.vstride = BRW_VERTICAL_STRIDE_0;
   imm.width = BRW_WIDTH_8;
   imm.hstride = BRW_HORIZONTAL_STRIDE_1;
   imm.dw1.ud = v;
   return imm;
}

/** Construct vector of four 8-bit float values */
static INLINE struct brw_reg brw_imm_vf( GLuint v )
{
   struct brw_reg imm = brw_imm_reg(BRW_REGISTER_TYPE_VF);
   imm.vstride = BRW_VERTICAL_STRIDE_0;
   imm.width = BRW_WIDTH_4;
   imm.hstride = BRW_HORIZONTAL_STRIDE_1;
   imm.dw1.ud = v;
   return imm;
}

#define VF_ZERO 0x0
#define VF_ONE  0x30
#define VF_NEG  (1<<7)

static INLINE struct brw_reg brw_imm_vf4( GLuint v0, 
					    GLuint v1, 
					    GLuint v2,
					    GLuint v3)
{
   struct brw_reg imm = brw_imm_reg(BRW_REGISTER_TYPE_VF);
   imm.vstride = BRW_VERTICAL_STRIDE_0;
   imm.width = BRW_WIDTH_4;
   imm.hstride = BRW_HORIZONTAL_STRIDE_1;
   imm.dw1.ud = ((v0 << 0) |
		 (v1 << 8) |
		 (v2 << 16) |
		 (v3 << 24));
   return imm;
}


static INLINE struct brw_reg brw_address( struct brw_reg reg )
{
   return brw_imm_uw(reg.nr * REG_SIZE + reg.subnr);
}

/** Construct float[1] general-purpose register */
static INLINE struct brw_reg brw_vec1_grf( GLuint nr, GLuint subnr )
{
   return brw_vec1_reg(BRW_GENERAL_REGISTER_FILE, nr, subnr);
}

/** Construct float[2] general-purpose register */
static INLINE struct brw_reg brw_vec2_grf( GLuint nr, GLuint subnr )
{
   return brw_vec2_reg(BRW_GENERAL_REGISTER_FILE, nr, subnr);
}

/** Construct float[4] general-purpose register */
static INLINE struct brw_reg brw_vec4_grf( GLuint nr, GLuint subnr )
{
   return brw_vec4_reg(BRW_GENERAL_REGISTER_FILE, nr, subnr);
}

/** Construct float[8] general-purpose register */
static INLINE struct brw_reg brw_vec8_grf( GLuint nr, GLuint subnr )
{
   return brw_vec8_reg(BRW_GENERAL_REGISTER_FILE, nr, subnr);
}


static INLINE struct brw_reg brw_uw8_grf( GLuint nr, GLuint subnr )
{
   return brw_uw8_reg(BRW_GENERAL_REGISTER_FILE, nr, subnr);
}

static INLINE struct brw_reg brw_uw16_grf( GLuint nr, GLuint subnr )
{
   return brw_uw16_reg(BRW_GENERAL_REGISTER_FILE, nr, subnr);
}


/** Construct null register (usually used for setting condition codes) */
static INLINE struct brw_reg brw_null_reg( void )
{
   return brw_vec8_reg(BRW_ARCHITECTURE_REGISTER_FILE, 
		       BRW_ARF_NULL, 
		       0);
}

static INLINE struct brw_reg brw_address_reg( GLuint subnr )
{
   return brw_uw1_reg(BRW_ARCHITECTURE_REGISTER_FILE, 
		      BRW_ARF_ADDRESS, 
		      subnr);
}

/* If/else instructions break in align16 mode if writemask & swizzle
 * aren't xyzw.  This goes against the convention for other scalar
 * regs:
 */
static INLINE struct brw_reg brw_ip_reg( void )
{
   return brw_reg(BRW_ARCHITECTURE_REGISTER_FILE, 
		  BRW_ARF_IP, 
		  0,
		  BRW_REGISTER_TYPE_UD,
		  BRW_VERTICAL_STRIDE_4, /* ? */
		  BRW_WIDTH_1,
		  BRW_HORIZONTAL_STRIDE_0,
		  BRW_SWIZZLE_XYZW, /* NOTE! */
		  WRITEMASK_XYZW); /* NOTE! */
}

static INLINE struct brw_reg brw_acc_reg( void )
{
   return brw_vec8_reg(BRW_ARCHITECTURE_REGISTER_FILE, 
		       BRW_ARF_ACCUMULATOR, 
		       0);
}

static INLINE struct brw_reg brw_notification_1_reg(void)
{

   return brw_reg(BRW_ARCHITECTURE_REGISTER_FILE,
		  BRW_ARF_NOTIFICATION_COUNT,
		  1,
		  BRW_REGISTER_TYPE_UD,
		  BRW_VERTICAL_STRIDE_0,
		  BRW_WIDTH_1,
		  BRW_HORIZONTAL_STRIDE_0,
		  BRW_SWIZZLE_XXXX,
		  WRITEMASK_X);
}


static INLINE struct brw_reg brw_flag_reg( void )
{
   return brw_uw1_reg(BRW_ARCHITECTURE_REGISTER_FILE,
		      BRW_ARF_FLAG,
		      0);
}


static INLINE struct brw_reg brw_mask_reg( GLuint subnr )
{
   return brw_uw1_reg(BRW_ARCHITECTURE_REGISTER_FILE,
		      BRW_ARF_MASK,
		      subnr);
}

static INLINE struct brw_reg brw_message_reg( GLuint nr )
{
   assert((nr & ~(1 << 7)) < BRW_MAX_MRF);
   return brw_vec8_reg(BRW_MESSAGE_REGISTER_FILE,
		       nr,
		       0);
}




/* This is almost always called with a numeric constant argument, so
 * make things easy to evaluate at compile time:
 */
static INLINE GLuint cvt( GLuint val )
{
   switch (val) {
   case 0: return 0;
   case 1: return 1;
   case 2: return 2;
   case 4: return 3;
   case 8: return 4;
   case 16: return 5;
   case 32: return 6;
   }
   return 0;
}

static INLINE struct brw_reg stride( struct brw_reg reg,
				       GLuint vstride,
				       GLuint width,
				       GLuint hstride )
{
   reg.vstride = cvt(vstride);
   reg.width = cvt(width) - 1;
   reg.hstride = cvt(hstride);
   return reg;
}


static INLINE struct brw_reg vec16( struct brw_reg reg )
{
   return stride(reg, 16,16,1);
}

static INLINE struct brw_reg vec8( struct brw_reg reg )
{
   return stride(reg, 8,8,1);
}

static INLINE struct brw_reg vec4( struct brw_reg reg )
{
   return stride(reg, 4,4,1);
}

static INLINE struct brw_reg vec2( struct brw_reg reg )
{
   return stride(reg, 2,2,1);
}

static INLINE struct brw_reg vec1( struct brw_reg reg )
{
   return stride(reg, 0,1,0);
}


static INLINE struct brw_reg get_element( struct brw_reg reg, GLuint elt )
{
   return vec1(suboffset(reg, elt));
}

static INLINE struct brw_reg get_element_ud( struct brw_reg reg, GLuint elt )
{
   return vec1(suboffset(retype(reg, BRW_REGISTER_TYPE_UD), elt));
}


static INLINE struct brw_reg brw_swizzle( struct brw_reg reg,
					    GLuint x,
					    GLuint y, 
					    GLuint z,
					    GLuint w)
{
   assert(reg.file != BRW_IMMEDIATE_VALUE);

   reg.dw1.bits.swizzle = BRW_SWIZZLE4(BRW_GET_SWZ(reg.dw1.bits.swizzle, x),
				       BRW_GET_SWZ(reg.dw1.bits.swizzle, y),
				       BRW_GET_SWZ(reg.dw1.bits.swizzle, z),
				       BRW_GET_SWZ(reg.dw1.bits.swizzle, w));
   return reg;
}


static INLINE struct brw_reg brw_swizzle1( struct brw_reg reg,
					     GLuint x )
{
   return brw_swizzle(reg, x, x, x, x);
}

static INLINE struct brw_reg brw_writemask( struct brw_reg reg,
					      GLuint mask )
{
   assert(reg.file != BRW_IMMEDIATE_VALUE);
   reg.dw1.bits.writemask &= mask;
   return reg;
}

static INLINE struct brw_reg brw_set_writemask( struct brw_reg reg,
						  GLuint mask )
{
   assert(reg.file != BRW_IMMEDIATE_VALUE);
   reg.dw1.bits.writemask = mask;
   return reg;
}

static INLINE struct brw_reg negate( struct brw_reg reg )
{
   reg.negate ^= 1;
   return reg;
}

static INLINE struct brw_reg brw_abs( struct brw_reg reg )
{
   reg.abs = 1;
   return reg;
}

/***********************************************************************
 */
static INLINE struct brw_reg brw_vec4_indirect( GLuint subnr,
						  GLint offset )
{
   struct brw_reg reg =  brw_vec4_grf(0, 0);
   reg.subnr = subnr;
   reg.address_mode = BRW_ADDRESS_REGISTER_INDIRECT_REGISTER;
   reg.dw1.bits.indirect_offset = offset;
   return reg;
}

static INLINE struct brw_reg brw_vec1_indirect( GLuint subnr,
						  GLint offset )
{
   struct brw_reg reg =  brw_vec1_grf(0, 0);
   reg.subnr = subnr;
   reg.address_mode = BRW_ADDRESS_REGISTER_INDIRECT_REGISTER;
   reg.dw1.bits.indirect_offset = offset;
   return reg;
}

static INLINE struct brw_reg deref_4f(struct brw_indirect ptr, GLint offset)
{
   return brw_vec4_indirect(ptr.addr_subnr, ptr.addr_offset + offset);
}

static INLINE struct brw_reg deref_1f(struct brw_indirect ptr, GLint offset)
{
   return brw_vec1_indirect(ptr.addr_subnr, ptr.addr_offset + offset);
}

static INLINE struct brw_reg deref_4b(struct brw_indirect ptr, GLint offset)
{
   return retype(deref_4f(ptr, offset), BRW_REGISTER_TYPE_B);
}

static INLINE struct brw_reg deref_1uw(struct brw_indirect ptr, GLint offset)
{
   return retype(deref_1f(ptr, offset), BRW_REGISTER_TYPE_UW);
}

static INLINE struct brw_reg deref_1d(struct brw_indirect ptr, GLint offset)
{
   return retype(deref_1f(ptr, offset), BRW_REGISTER_TYPE_D);
}

static INLINE struct brw_reg deref_1ud(struct brw_indirect ptr, GLint offset)
{
   return retype(deref_1f(ptr, offset), BRW_REGISTER_TYPE_UD);
}

static INLINE struct brw_reg get_addr_reg(struct brw_indirect ptr)
{
   return brw_address_reg(ptr.addr_subnr);
}

static INLINE struct brw_indirect brw_indirect_offset( struct brw_indirect ptr, GLint offset )
{
   ptr.addr_offset += offset;
   return ptr;
}

static INLINE struct brw_indirect brw_indirect( GLuint addr_subnr, GLint offset )
{
   struct brw_indirect ptr;
   ptr.addr_subnr = addr_subnr;
   ptr.addr_offset = offset;
   ptr.pad = 0;
   return ptr;
}

/** Do two brw_regs refer to the same register? */
static INLINE GLboolean
brw_same_reg(struct brw_reg r1, struct brw_reg r2)
{
   return r1.file == r2.file && r1.nr == r2.nr;
}

d101 1
a101 1
void brw_set_saturate( struct brw_compile *p, GLuint value );
d103 1
a103 1
void brw_set_compression_control( struct brw_compile *p, GLboolean control );
d108 1
d113 1
d116 9
d139 7
a148 1

d160 2
d164 1
d177 9
d192 1
d198 33
d235 2
a236 2
		   GLboolean allocate,
		   GLboolean used,
d239 2
a240 2
		   GLboolean eot,
		   GLboolean writes_complete,
d248 1
a248 1
		   GLboolean allocate,
d250 8
a257 1
		   GLboolean eot);
d263 1
d267 2
a268 2
		   GLboolean eot,
		   GLboolean header_present);
a275 1
		GLuint writemask,
a278 1
		GLboolean eot,
d280 2
a281 9
		GLuint simd_mode);

void brw_math_16( struct brw_compile *p,
		  struct brw_reg dest,
		  GLuint function,
		  GLuint saturate,
		  GLuint msg_reg_nr,
		  struct brw_reg src,
		  GLuint precision );
a285 1
	       GLuint saturate,
d314 3
a316 15
void brw_dword_scattered_read(struct brw_compile *p,
			      struct brw_reg dest,
			      struct brw_reg mrf,
			      uint32_t bind_table_index);

void brw_dp_READ_4_vs( struct brw_compile *p,
                       struct brw_reg dest,
                       GLuint location,
                       GLuint bind_table_index );

void brw_dp_READ_4_vs_relative(struct brw_compile *p,
			       struct brw_reg dest,
			       struct brw_reg addrReg,
			       GLuint offset,
			       GLuint bind_table_index);
d334 1
a334 2
struct brw_instruction *brw_WHILE(struct brw_compile *p, 
	       struct brw_instruction *patch_insn);
d336 4
a339 4
struct brw_instruction *brw_BREAK(struct brw_compile *p, int pop_count);
struct brw_instruction *brw_CONT(struct brw_compile *p, int pop_count);
struct brw_instruction *gen6_CONT(struct brw_compile *p,
				  struct brw_instruction *do_insn);
d342 1
a342 2
void brw_land_fwd_jump(struct brw_compile *p, 
		       struct brw_instruction *jmp_insn);
a358 3
void brw_print_reg( struct brw_reg reg );


d395 17
a411 4
/* brw_optimize.c */
void brw_optimize(struct brw_compile *p);
void brw_remove_duplicate_mrf_moves(struct brw_compile *p);
void brw_remove_grf_to_mrf_moves(struct brw_compile *p);
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d107 2
d120 8
d306 8
d793 1
d797 2
a798 1
void brw_init_compile( struct brw_context *, struct brw_compile *p );
a877 1
		   struct brw_reg dest,
d961 2
a962 8
struct brw_instruction *brw_IF_gen6(struct brw_compile *p, uint32_t conditional,
				    struct brw_reg src0, struct brw_reg src1);

struct brw_instruction *brw_ELSE(struct brw_compile *p, 
				 struct brw_instruction *if_insn);

void brw_ENDIF(struct brw_compile *p, 
	       struct brw_instruction *if_or_else_insn);
d964 2
a975 2
struct brw_instruction *brw_CONT_gen6(struct brw_compile *p,
				      struct brw_instruction *do_insn);
d977 2
d1030 3
a1032 2
void brw_set_src1( struct brw_instruction *insn,
                          struct brw_reg reg );
d1035 2
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d36 1
d39 1
a39 1
#include "shader/prog_instruction.h"
d110 1
d115 1
d526 14
d639 2
d658 1
d666 1
d776 1
d795 4
a814 1
ALU1(RNDZ)
d823 4
d830 1
a830 1

a852 2
		   GLboolean used,
		   GLuint msg_length,
d854 1
a854 4
		   GLboolean eot,
		   GLboolean writes_complete,
		   GLuint offset,
		   GLuint swizzle);
d857 1
d864 2
a865 1
		   GLboolean eot);
d898 27
a924 9
void brw_dp_READ_16( struct brw_compile *p,
		     struct brw_reg dest,
		     GLuint scratch_offset );

void brw_dp_READ_4( struct brw_compile *p,
                    struct brw_reg dest,
                    GLboolean relAddr,
                    GLuint location,
                    GLuint bind_table_index );
a927 3
                       GLuint oword,
                       GLboolean relAddr,
                       struct brw_reg addrReg,
d931 5
a935 3
void brw_dp_WRITE_16( struct brw_compile *p,
		      struct brw_reg src,
		      GLuint scratch_offset );
d942 2
d960 4
a963 2
struct brw_instruction *brw_BREAK(struct brw_compile *p);
struct brw_instruction *brw_CONT(struct brw_compile *p);
d973 2
d1017 8
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d100 1
a100 1
#define BRW_EU_MAX_INSN 1200
d173 7
d541 1
d734 7
d819 13
d851 3
a853 1
		GLboolean eot);
a873 1
		     GLuint msg_reg_nr,
d876 14
a891 1
		      GLuint msg_reg_nr,
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d68 1
a68 1
   GLuint hstride:2;   		/* src only, align1 only */
d94 5
d114 3
d120 10
d150 12
d163 8
a170 8
					GLuint nr,
					GLuint subnr,
					GLuint type,
					GLuint vstride,
					GLuint width,
					GLuint hstride,
					GLuint swizzle,
					GLuint writemask)
a171 1
      
d198 1
d214 1
d230 1
a230 1

d246 1
a246 1

d262 1
d312 1
d320 1
d328 1
d349 1
d357 1
d365 1
d373 1
d381 1
d393 1
a393 2
/* Vector of eight signed half-byte values: 
 */
d404 1
a404 2
/* Vector of four 8-bit float values:
 */
d441 2
a442 3

static INLINE struct brw_reg brw_vec1_grf( GLuint nr,
					       GLuint subnr )
d447 2
a448 2
static INLINE struct brw_reg brw_vec8_grf( GLuint nr,
					     GLuint subnr )
d450 1
a450 1
   return brw_vec8_reg(BRW_GENERAL_REGISTER_FILE, nr, subnr);
d453 2
a454 2
static INLINE struct brw_reg brw_vec4_grf( GLuint nr,
					     GLuint subnr )
d459 6
d466 1
a466 2
static INLINE struct brw_reg brw_vec2_grf( GLuint nr,
					     GLuint subnr )
d468 1
a468 1
   return brw_vec2_reg(BRW_GENERAL_REGISTER_FILE, nr, subnr);
d471 1
a471 2
static INLINE struct brw_reg brw_uw8_grf( GLuint nr,
					    GLuint subnr )
d473 1
a473 1
   return brw_uw8_reg(BRW_GENERAL_REGISTER_FILE, nr, subnr);
d476 2
a563 1
   
d570 1
d596 1
d728 1
a728 1
	return &p->store[p->nr_insn];
d774 1
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d113 1
a113 1
static __inline int type_sz( GLuint type )
d132 1
a132 1
static __inline struct brw_reg brw_reg( GLuint file,
d169 1
a169 1
static __inline struct brw_reg brw_vec16_reg( GLuint file,
d184 1
a184 1
static __inline struct brw_reg brw_vec8_reg( GLuint file,
d200 1
a200 1
static __inline struct brw_reg brw_vec4_reg( GLuint file,
d216 1
a216 1
static __inline struct brw_reg brw_vec2_reg( GLuint file,
d231 1
a231 1
static __inline struct brw_reg brw_vec1_reg( GLuint file,
d247 1
a247 1
static __inline struct brw_reg retype( struct brw_reg reg,
d254 1
a254 1
static __inline struct brw_reg suboffset( struct brw_reg reg,
d262 1
a262 1
static __inline struct brw_reg offset( struct brw_reg reg,
d270 1
a270 1
static __inline struct brw_reg byte_offset( struct brw_reg reg,
d280 1
a280 1
static __inline struct brw_reg brw_uw16_reg( GLuint file,
d287 1
a287 1
static __inline struct brw_reg brw_uw8_reg( GLuint file,
d294 1
a294 1
static __inline struct brw_reg brw_uw1_reg( GLuint file,
d301 1
a301 1
static __inline struct brw_reg brw_imm_reg( GLuint type )
d314 1
a314 1
static __inline struct brw_reg brw_imm_f( GLfloat f )
d321 1
a321 1
static __inline struct brw_reg brw_imm_d( GLint d )
d328 1
a328 1
static __inline struct brw_reg brw_imm_ud( GLuint ud )
d335 1
a335 1
static __inline struct brw_reg brw_imm_uw( GLushort uw )
d338 1
a338 1
   imm.dw1.ud = uw;
d342 1
a342 1
static __inline struct brw_reg brw_imm_w( GLshort w )
d345 1
a345 1
   imm.dw1.d = w;
d355 1
a355 1
static __inline struct brw_reg brw_imm_v( GLuint v )
d367 1
a367 1
static __inline struct brw_reg brw_imm_vf( GLuint v )
d381 1
a381 1
static __inline struct brw_reg brw_imm_vf4( GLuint v0, 
d398 1
a398 1
static __inline struct brw_reg brw_address( struct brw_reg reg )
d404 1
a404 1
static __inline struct brw_reg brw_vec1_grf( GLuint nr,
d410 1
a410 1
static __inline struct brw_reg brw_vec8_grf( GLuint nr,
d416 1
a416 1
static __inline struct brw_reg brw_vec4_grf( GLuint nr,
d423 1
a423 1
static __inline struct brw_reg brw_vec2_grf( GLuint nr,
d429 1
a429 1
static __inline struct brw_reg brw_uw8_grf( GLuint nr,
d435 1
a435 1
static __inline struct brw_reg brw_null_reg( void )
d442 1
a442 1
static __inline struct brw_reg brw_address_reg( GLuint subnr )
d453 1
a453 1
static __inline struct brw_reg brw_ip_reg( void )
d466 1
a466 1
static __inline struct brw_reg brw_acc_reg( void )
d474 1
a474 1
static __inline struct brw_reg brw_flag_reg( void )
d482 1
a482 1
static __inline struct brw_reg brw_mask_reg( GLuint subnr )
d489 1
a489 1
static __inline struct brw_reg brw_message_reg( GLuint nr )
d502 1
a502 1
static __inline GLuint cvt( GLuint val )
d516 1
a516 1
static __inline struct brw_reg stride( struct brw_reg reg,
d528 1
a528 1
static __inline struct brw_reg vec16( struct brw_reg reg )
d533 1
a533 1
static __inline struct brw_reg vec8( struct brw_reg reg )
d538 1
a538 1
static __inline struct brw_reg vec4( struct brw_reg reg )
d543 1
a543 1
static __inline struct brw_reg vec2( struct brw_reg reg )
d548 1
a548 1
static __inline struct brw_reg vec1( struct brw_reg reg )
d553 1
a553 1
static __inline struct brw_reg get_element( struct brw_reg reg, GLuint elt )
d558 1
a558 1
static __inline struct brw_reg get_element_ud( struct brw_reg reg, GLuint elt )
d564 1
a564 1
static __inline struct brw_reg brw_swizzle( struct brw_reg reg,
d578 1
a578 1
static __inline struct brw_reg brw_swizzle1( struct brw_reg reg,
d584 1
a584 1
static __inline struct brw_reg brw_writemask( struct brw_reg reg,
d591 1
a591 1
static __inline struct brw_reg brw_set_writemask( struct brw_reg reg,
d598 1
a598 1
static __inline struct brw_reg negate( struct brw_reg reg )
d604 1
a604 1
static __inline struct brw_reg brw_abs( struct brw_reg reg )
d612 1
a612 1
static __inline struct brw_reg brw_vec4_indirect( GLuint subnr,
d622 1
a622 1
static __inline struct brw_reg brw_vec1_indirect( GLuint subnr,
d632 1
a632 1
static __inline struct brw_reg deref_4f(struct brw_indirect ptr, GLint offset)
d637 1
a637 1
static __inline struct brw_reg deref_1f(struct brw_indirect ptr, GLint offset)
d642 1
a642 1
static __inline struct brw_reg deref_4b(struct brw_indirect ptr, GLint offset)
d647 1
a647 1
static __inline struct brw_reg deref_1uw(struct brw_indirect ptr, GLint offset)
d652 11
a662 1
static __inline struct brw_reg get_addr_reg(struct brw_indirect ptr)
d667 1
a667 1
static __inline struct brw_indirect brw_indirect_offset( struct brw_indirect ptr, GLint offset )
d673 1
a673 1
static __inline struct brw_indirect brw_indirect( GLuint addr_subnr, GLint offset )
d682 4
a685 1

d825 1
a825 1
void brw_WHILE(struct brw_compile *p, 
d828 2
d879 2
a880 1

@


1.1
log
@Initial revision
@
text
@d38 1
a38 1
#include "shader/program.h"
d107 2
d684 1
a684 1
void brw_init_compile( struct brw_compile *p );
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d38 1
a38 1
#include "shader/prog_instruction.h"
a106 1
   GLboolean single_program_flow;
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@a35 1
#include <stdbool.h>
d38 1
a38 1
#include "program/prog_instruction.h"
d68 1
a68 1
   GLuint hstride:2;   		/* align1 only */
a93 5
struct brw_glsl_label;
struct brw_glsl_call;



d95 1
a95 1
#define BRW_EU_MAX_INSN 10000
a103 1
   bool compressed_stack[BRW_EU_MAX_INSN_STACK];
a107 5
   bool compressed;
   struct brw_context *brw;

   struct brw_glsl_label *first_label;  /**< linked list of labels */
   struct brw_glsl_call *first_call;    /**< linked list of CALs */
a110 5
void
brw_save_label(struct brw_compile *c, const char *name, GLuint position);

void
brw_save_call(struct brw_compile *c, const char *name, GLuint call_pos);
d112 1
a112 6
void
brw_resolve_cals(struct brw_compile *c);



static INLINE int type_sz( GLuint type )
d131 9
a139 21
/**
 * Construct a brw_reg.
 * \param file  one of the BRW_x_REGISTER_FILE values
 * \param nr  register number/index
 * \param subnr  register sub number
 * \param type  one of BRW_REGISTER_TYPE_x
 * \param vstride  one of BRW_VERTICAL_STRIDE_x
 * \param width  one of BRW_WIDTH_x
 * \param hstride  one of BRW_HORIZONTAL_STRIDE_x
 * \param swizzle  one of BRW_SWIZZLE_x
 * \param writemask  WRITEMASK_X/Y/Z/W bitfield
 */
static INLINE struct brw_reg brw_reg( GLuint file,
                                      GLuint nr,
                                      GLuint subnr,
                                      GLuint type,
                                      GLuint vstride,
                                      GLuint width,
                                      GLuint hstride,
                                      GLuint swizzle,
                                      GLuint writemask )
d141 1
a142 7
   if (file == BRW_GENERAL_REGISTER_FILE)
      assert(nr < BRW_MAX_GRF);
   else if (file == BRW_MESSAGE_REGISTER_FILE)
      assert((nr & ~(1 << 7)) < BRW_MAX_MRF);
   else if (file == BRW_ARCHITECTURE_REGISTER_FILE)
      assert(nr <= BRW_ARF_IP);

d168 1
a168 2
/** Construct float[16] register */
static INLINE struct brw_reg brw_vec16_reg( GLuint file,
d183 1
a183 2
/** Construct float[8] register */
static INLINE struct brw_reg brw_vec8_reg( GLuint file,
d198 2
a199 2
/** Construct float[4] register */
static INLINE struct brw_reg brw_vec4_reg( GLuint file,
d214 2
a215 2
/** Construct float[2] register */
static INLINE struct brw_reg brw_vec2_reg( GLuint file,
d230 1
a230 2
/** Construct float[1] register */
static INLINE struct brw_reg brw_vec1_reg( GLuint file,
d246 1
a246 1
static INLINE struct brw_reg retype( struct brw_reg reg,
d253 1
a253 1
static INLINE struct brw_reg suboffset( struct brw_reg reg,
d261 1
a261 1
static INLINE struct brw_reg offset( struct brw_reg reg,
d269 1
a269 1
static INLINE struct brw_reg byte_offset( struct brw_reg reg,
d279 1
a279 2
/** Construct unsigned word[16] register */
static INLINE struct brw_reg brw_uw16_reg( GLuint file,
d286 1
a286 2
/** Construct unsigned word[8] register */
static INLINE struct brw_reg brw_uw8_reg( GLuint file,
d293 1
a293 2
/** Construct unsigned word[1] register */
static INLINE struct brw_reg brw_uw1_reg( GLuint file,
d300 1
a300 1
static INLINE struct brw_reg brw_imm_reg( GLuint type )
d313 1
a313 2
/** Construct float immediate register */
static INLINE struct brw_reg brw_imm_f( GLfloat f )
d320 1
a320 2
/** Construct integer immediate register */
static INLINE struct brw_reg brw_imm_d( GLint d )
d327 1
a327 2
/** Construct uint immediate register */
static INLINE struct brw_reg brw_imm_ud( GLuint ud )
d334 1
a334 2
/** Construct ushort immediate register */
static INLINE struct brw_reg brw_imm_uw( GLushort uw )
d337 1
a337 1
   imm.dw1.ud = uw | (uw << 16);
d341 1
a341 2
/** Construct short immediate register */
static INLINE struct brw_reg brw_imm_w( GLshort w )
d344 1
a344 1
   imm.dw1.d = w | (w << 16);
d352 3
a354 2
/** Construct vector of eight signed half-byte values */
static INLINE struct brw_reg brw_imm_v( GLuint v )
d364 3
a366 2
/** Construct vector of four 8-bit float values */
static INLINE struct brw_reg brw_imm_vf( GLuint v )
d380 1
a380 1
static INLINE struct brw_reg brw_imm_vf4( GLuint v0, 
d397 1
a397 1
static INLINE struct brw_reg brw_address( struct brw_reg reg )
d402 3
a404 2
/** Construct float[1] general-purpose register */
static INLINE struct brw_reg brw_vec1_grf( GLuint nr, GLuint subnr )
d409 2
a410 2
/** Construct float[2] general-purpose register */
static INLINE struct brw_reg brw_vec2_grf( GLuint nr, GLuint subnr )
d412 1
a412 1
   return brw_vec2_reg(BRW_GENERAL_REGISTER_FILE, nr, subnr);
d415 2
a416 2
/** Construct float[4] general-purpose register */
static INLINE struct brw_reg brw_vec4_grf( GLuint nr, GLuint subnr )
d421 3
a423 2
/** Construct float[8] general-purpose register */
static INLINE struct brw_reg brw_vec8_grf( GLuint nr, GLuint subnr )
d425 1
a425 1
   return brw_vec8_reg(BRW_GENERAL_REGISTER_FILE, nr, subnr);
d428 2
a429 2

static INLINE struct brw_reg brw_uw8_grf( GLuint nr, GLuint subnr )
d434 1
a434 8
static INLINE struct brw_reg brw_uw16_grf( GLuint nr, GLuint subnr )
{
   return brw_uw16_reg(BRW_GENERAL_REGISTER_FILE, nr, subnr);
}


/** Construct null register (usually used for setting condition codes) */
static INLINE struct brw_reg brw_null_reg( void )
d441 1
a441 1
static INLINE struct brw_reg brw_address_reg( GLuint subnr )
d452 1
a452 1
static INLINE struct brw_reg brw_ip_reg( void )
d465 1
a465 1
static INLINE struct brw_reg brw_acc_reg( void )
a471 2
static INLINE struct brw_reg brw_notification_1_reg(void)
{
d473 1
a473 13
   return brw_reg(BRW_ARCHITECTURE_REGISTER_FILE,
		  BRW_ARF_NOTIFICATION_COUNT,
		  1,
		  BRW_REGISTER_TYPE_UD,
		  BRW_VERTICAL_STRIDE_0,
		  BRW_WIDTH_1,
		  BRW_HORIZONTAL_STRIDE_0,
		  BRW_SWIZZLE_XXXX,
		  WRITEMASK_X);
}


static INLINE struct brw_reg brw_flag_reg( void )
d481 1
a481 1
static INLINE struct brw_reg brw_mask_reg( GLuint subnr )
d488 1
a488 1
static INLINE struct brw_reg brw_message_reg( GLuint nr )
a489 1
   assert((nr & ~(1 << 7)) < BRW_MAX_MRF);
d501 1
a501 1
static INLINE GLuint cvt( GLuint val )
d515 1
a515 1
static INLINE struct brw_reg stride( struct brw_reg reg,
d520 1
d527 1
a527 2

static INLINE struct brw_reg vec16( struct brw_reg reg )
d532 1
a532 1
static INLINE struct brw_reg vec8( struct brw_reg reg )
d537 1
a537 1
static INLINE struct brw_reg vec4( struct brw_reg reg )
d542 1
a542 1
static INLINE struct brw_reg vec2( struct brw_reg reg )
d547 1
a547 1
static INLINE struct brw_reg vec1( struct brw_reg reg )
d552 1
a552 2

static INLINE struct brw_reg get_element( struct brw_reg reg, GLuint elt )
d557 1
a557 1
static INLINE struct brw_reg get_element_ud( struct brw_reg reg, GLuint elt )
d563 1
a563 1
static INLINE struct brw_reg brw_swizzle( struct brw_reg reg,
a568 2
   assert(reg.file != BRW_IMMEDIATE_VALUE);

d577 1
a577 1
static INLINE struct brw_reg brw_swizzle1( struct brw_reg reg,
d583 1
a583 1
static INLINE struct brw_reg brw_writemask( struct brw_reg reg,
a585 1
   assert(reg.file != BRW_IMMEDIATE_VALUE);
d590 1
a590 1
static INLINE struct brw_reg brw_set_writemask( struct brw_reg reg,
a592 1
   assert(reg.file != BRW_IMMEDIATE_VALUE);
d597 1
a597 1
static INLINE struct brw_reg negate( struct brw_reg reg )
d603 1
a603 1
static INLINE struct brw_reg brw_abs( struct brw_reg reg )
d611 1
a611 1
static INLINE struct brw_reg brw_vec4_indirect( GLuint subnr,
d621 1
a621 1
static INLINE struct brw_reg brw_vec1_indirect( GLuint subnr,
d631 1
a631 1
static INLINE struct brw_reg deref_4f(struct brw_indirect ptr, GLint offset)
d636 1
a636 1
static INLINE struct brw_reg deref_1f(struct brw_indirect ptr, GLint offset)
d641 1
a641 1
static INLINE struct brw_reg deref_4b(struct brw_indirect ptr, GLint offset)
d646 1
a646 1
static INLINE struct brw_reg deref_1uw(struct brw_indirect ptr, GLint offset)
d651 1
a651 11
static INLINE struct brw_reg deref_1d(struct brw_indirect ptr, GLint offset)
{
   return retype(deref_1f(ptr, offset), BRW_REGISTER_TYPE_D);
}

static INLINE struct brw_reg deref_1ud(struct brw_indirect ptr, GLint offset)
{
   return retype(deref_1f(ptr, offset), BRW_REGISTER_TYPE_UD);
}

static INLINE struct brw_reg get_addr_reg(struct brw_indirect ptr)
d656 1
a656 1
static INLINE struct brw_indirect brw_indirect_offset( struct brw_indirect ptr, GLint offset )
d662 1
a662 1
static INLINE struct brw_indirect brw_indirect( GLuint addr_subnr, GLint offset )
a670 6
/** Do two brw_regs refer to the same register? */
static INLINE GLboolean
brw_same_reg(struct brw_reg r1, struct brw_reg r2)
{
   return r1.file == r2.file && r1.nr == r2.nr;
}
a671 4
static INLINE struct brw_instruction *current_insn( struct brw_compile *p)
{
   return &p->store[p->nr_insn];
}
a681 1
void brw_set_acc_write_control(struct brw_compile *p, GLuint value);
d683 1
a683 1
void brw_init_compile( struct brw_context *, struct brw_compile *p );
a699 4
#define ROUND(OP) \
void brw_##OP(struct brw_compile *p, struct brw_reg dest, struct brw_reg src0);


a723 4
ALU2(PLN)

ROUND(RNDZ)
ROUND(RNDE)
d727 1
a727 1
#undef ROUND
a744 8
void brw_ff_sync(struct brw_compile *p,
		   struct brw_reg dest,
		   GLuint msg_reg_nr,
		   struct brw_reg src0,
		   GLboolean allocate,
		   GLuint response_length,
		   GLboolean eot);

a745 1
		  int dispatch_width,
d752 1
a752 2
		   GLboolean eot,
		   GLboolean header_present);
d764 1
a764 3
		GLboolean eot,
		GLuint header_present,
		GLuint simd_mode);
d783 9
a791 38
void brw_math2(struct brw_compile *p,
	       struct brw_reg dest,
	       GLuint function,
	       struct brw_reg src0,
	       struct brw_reg src1);

void brw_oword_block_read(struct brw_compile *p,
			  struct brw_reg dest,
			  struct brw_reg mrf,
			  uint32_t offset,
			  uint32_t bind_table_index);

void brw_oword_block_read_scratch(struct brw_compile *p,
				  struct brw_reg dest,
				  struct brw_reg mrf,
				  int num_regs,
				  GLuint offset);

void brw_oword_block_write_scratch(struct brw_compile *p,
				   struct brw_reg mrf,
				   int num_regs,
				   GLuint offset);

void brw_dword_scattered_read(struct brw_compile *p,
			      struct brw_reg dest,
			      struct brw_reg mrf,
			      uint32_t bind_table_index);

void brw_dp_READ_4_vs( struct brw_compile *p,
                       struct brw_reg dest,
                       GLuint location,
                       GLuint bind_table_index );

void brw_dp_READ_4_vs_relative(struct brw_compile *p,
			       struct brw_reg dest,
			       struct brw_reg addrReg,
			       GLuint offset,
			       GLuint bind_table_index);
a797 2
struct brw_instruction *brw_IF_gen6(struct brw_compile *p, uint32_t conditional,
				    struct brw_reg src0, struct brw_reg src1);
d811 1
a811 1
struct brw_instruction *brw_WHILE(struct brw_compile *p, 
a813 4
struct brw_instruction *brw_BREAK(struct brw_compile *p, int pop_count);
struct brw_instruction *brw_CONT_gen6(struct brw_compile *p,
				      struct brw_instruction *do_insn);
struct brw_instruction *brw_CONT(struct brw_compile *p, int pop_count);
a822 2
void brw_WAIT(struct brw_compile *p);

a862 9
void brw_set_src1( struct brw_instruction *insn,
                          struct brw_reg reg );

void brw_set_uip_jip(struct brw_compile *p);

/* brw_optimize.c */
void brw_optimize(struct brw_compile *p);
void brw_remove_duplicate_mrf_moves(struct brw_compile *p);
void brw_remove_grf_to_mrf_moves(struct brw_compile *p);
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@a38 1
#include "brw_reg.h"
d41 58
a98 3
#ifdef __cplusplus
extern "C" {
#endif
d101 1
d104 1
a104 2
   struct brw_instruction *store;
   int store_size;
a105 3
   unsigned int next_insn_offset;

   void *mem_ctx;
d114 1
a114 1
   bool single_program_flow;
d118 82
a199 5
   /* Control flow stacks:
    * - if_stack contains IF and ELSE instructions which must be patched
    *   (and popped) once the matching ENDIF instruction is encountered.
    *
    *   Just store the instruction pointer(an index).
d201 560
a760 19
   int *if_stack;
   int if_stack_depth;
   int if_stack_array_size;

   /**
    * loop_stack contains the instruction pointers of the starts of loops which
    * must be patched (and popped) once the matching WHILE instruction is
    * encountered.
    */
   int *loop_stack;
   /**
    * pre-gen6, the BREAK and CONT instructions had to tell how many IF/ENDIF
    * blocks they were popping out of, to fix up the mask stack.  This tracks
    * the IF/ENDIF nesting in each current nested loop level.
    */
   int *if_depth_in_loop;
   int loop_stack_depth;
   int loop_stack_array_size;
};
d770 1
a770 1
void brw_set_saturate( struct brw_compile *p, bool enable );
d772 1
a772 1
void brw_set_compression_control(struct brw_compile *p, enum brw_compression c);
a774 1
void brw_set_predicate_inverse(struct brw_compile *p, bool predicate_inverse);
a775 1
void brw_set_flag_reg(struct brw_compile *p, int reg, int subreg);
d778 1
a778 3
void brw_init_compile(struct brw_context *, struct brw_compile *p,
		      void *mem_ctx);
void brw_dump_compile(struct brw_compile *p, FILE *out, int start, int end);
a780 9
struct brw_instruction *brw_next_insn(struct brw_compile *p, GLuint opcode);
void brw_set_dest(struct brw_compile *p, struct brw_instruction *insn,
		  struct brw_reg dest);
void brw_set_src0(struct brw_compile *p, struct brw_instruction *insn,
		  struct brw_reg reg);

void gen6_resolve_implied_move(struct brw_compile *p,
			       struct brw_reg *src,
			       GLuint msg_reg_nr);
a794 7
#define ALU3(OP)					\
struct brw_instruction *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,			\
	      struct brw_reg src0,			\
	      struct brw_reg src1,			\
	      struct brw_reg src2);

d798 1
a809 2
ALU1(F32TO16)
ALU1(F16TO32)
a811 1
ALU2(AVG)
a823 9
ALU3(MAD)
ALU3(LRP)
ALU1(BFREV)
ALU3(BFE)
ALU2(BFI1)
ALU3(BFI2)
ALU1(FBH)
ALU1(FBL)
ALU1(CBIT)
a829 1
#undef ALU3
a834 33
void brw_set_sampler_message(struct brw_compile *p,
                             struct brw_instruction *insn,
                             GLuint binding_table_index,
                             GLuint sampler,
                             GLuint msg_type,
                             GLuint response_length,
                             GLuint msg_length,
                             GLuint header_present,
                             GLuint simd_mode,
                             GLuint return_format);

void brw_set_dp_read_message(struct brw_compile *p,
			     struct brw_instruction *insn,
			     GLuint binding_table_index,
			     GLuint msg_control,
			     GLuint msg_type,
			     GLuint target_cache,
			     GLuint msg_length,
                             bool header_present,
			     GLuint response_length);

void brw_set_dp_write_message(struct brw_compile *p,
			      struct brw_instruction *insn,
			      GLuint binding_table_index,
			      GLuint msg_control,
			      GLuint msg_type,
			      GLuint msg_length,
			      bool header_present,
			      GLuint last_render_target,
			      GLuint response_length,
			      GLuint end_of_thread,
			      GLuint send_commit_msg);

d839 2
a840 2
		   bool allocate,
		   bool used,
d843 2
a844 2
		   bool eot,
		   bool writes_complete,
d852 1
a852 1
		   bool allocate,
d854 1
a854 8
		   bool eot);

void brw_svb_write(struct brw_compile *p,
                   struct brw_reg dest,
                   GLuint msg_reg_nr,
                   struct brw_reg src0,
                   GLuint binding_table_index,
                   bool   send_commit_msg);
d858 1
a860 1
		   GLuint msg_control,
d864 2
a865 2
		   bool eot,
		   bool header_present);
d873 1
d877 1
d879 9
a887 2
		GLuint simd_mode,
		GLuint return_format);
d892 1
d921 15
a935 3
void brw_shader_time_add(struct brw_compile *p,
                         struct brw_reg payload,
                         uint32_t surf_index);
d942 8
a949 2
struct brw_instruction *gen6_IF(struct brw_compile *p, uint32_t conditional,
				struct brw_reg src0, struct brw_reg src1);
a950 2
void brw_ELSE(struct brw_compile *p);
void brw_ENDIF(struct brw_compile *p);
d957 2
a958 1
struct brw_instruction *brw_WHILE(struct brw_compile *p);
d960 4
a963 4
struct brw_instruction *brw_BREAK(struct brw_compile *p);
struct brw_instruction *brw_CONT(struct brw_compile *p);
struct brw_instruction *gen6_CONT(struct brw_compile *p);
struct brw_instruction *gen6_HALT(struct brw_compile *p);
d966 2
a967 1
void brw_land_fwd_jump(struct brw_compile *p, int jmp_insn_idx);
d984 3
d1015 2
a1016 3
void brw_set_src1(struct brw_compile *p,
		  struct brw_instruction *insn,
		  struct brw_reg reg);
d1020 4
a1023 19
uint32_t brw_swap_cmod(uint32_t cmod);

/* brw_eu_compact.c */
void brw_init_compaction_tables(struct brw_context *brw);
void brw_compact_instructions(struct brw_compile *p);
void brw_uncompact_instruction(struct brw_context *brw,
			       struct brw_instruction *dst,
			       struct brw_compact_instruction *src);
bool brw_try_compact_instruction(struct brw_compile *p,
                                 struct brw_compact_instruction *dst,
                                 struct brw_instruction *src);

void brw_debug_compact_uncompact(struct brw_context *brw,
				 struct brw_instruction *orig,
				 struct brw_instruction *uncompacted);

#ifdef __cplusplus
}
#endif
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics to
d5 1
a5 1

d13 1
a13 1

d17 1
a17 1

d25 1
a25 1

d29 1
a29 1
  *   Keith Whitwell <keithw@@vmware.com>
d31 1
a31 1

d51 1
a51 1
   unsigned nr_insn;
d62 1
a62 1
   unsigned flag_value;
d93 1
a93 1
static inline struct brw_instruction *current_insn( struct brw_compile *p)
d100 1
a100 1
void brw_set_mask_control( struct brw_compile *p, unsigned value );
d102 1
a102 1
void brw_set_access_mode( struct brw_compile *p, unsigned access_mode );
d104 2
a105 2
void brw_set_predicate_control_flag_value( struct brw_compile *p, unsigned value );
void brw_set_predicate_control( struct brw_compile *p, unsigned pc );
d107 1
a107 1
void brw_set_conditionalmod( struct brw_compile *p, unsigned conditional );
d109 1
a109 1
void brw_set_acc_write_control(struct brw_compile *p, unsigned value);
d114 1
a114 1
const unsigned *brw_get_program( struct brw_compile *p, unsigned *sz );
d116 1
a116 1
struct brw_instruction *brw_next_insn(struct brw_compile *p, unsigned opcode);
d124 1
a124 1
			       unsigned msg_reg_nr);
d157 2
a185 3
ALU2(ADDC)
ALU2(SUBB)
ALU2(MAC)
d200 8
a207 8
                             unsigned binding_table_index,
                             unsigned sampler,
                             unsigned msg_type,
                             unsigned response_length,
                             unsigned msg_length,
                             unsigned header_present,
                             unsigned simd_mode,
                             unsigned return_format);
d211 5
a215 5
			     unsigned binding_table_index,
			     unsigned msg_control,
			     unsigned msg_type,
			     unsigned target_cache,
			     unsigned msg_length,
d217 1
a217 1
			     unsigned response_length);
d221 4
a224 4
			      unsigned binding_table_index,
			      unsigned msg_control,
			      unsigned msg_type,
			      unsigned msg_length,
d226 4
a229 4
			      unsigned last_render_target,
			      unsigned response_length,
			      unsigned end_of_thread,
			      unsigned send_commit_msg);
d233 1
a233 1
		   unsigned msg_reg_nr,
d235 8
a242 5
                   enum brw_urb_write_flags flags,
		   unsigned msg_length,
		   unsigned response_length,
		   unsigned offset,
		   unsigned swizzle);
d246 1
a246 1
		   unsigned msg_reg_nr,
d249 1
a249 1
		   unsigned response_length,
d254 1
a254 1
                   unsigned msg_reg_nr,
d256 1
a256 1
                   unsigned binding_table_index,
d261 1
a261 1
		   unsigned msg_reg_nr,
d263 4
a266 4
		   unsigned msg_control,
		   unsigned binding_table_index,
		   unsigned msg_length,
		   unsigned response_length,
d272 1
a272 1
		unsigned msg_reg_nr,
d274 8
a281 8
		unsigned binding_table_index,
		unsigned sampler,
		unsigned msg_type,
		unsigned response_length,
		unsigned msg_length,
		unsigned header_present,
		unsigned simd_mode,
		unsigned return_format);
d285 2
a286 2
	       unsigned function,
	       unsigned msg_reg_nr,
d288 2
a289 2
	       unsigned data_type,
	       unsigned precision );
d293 1
a293 1
	       unsigned function,
d307 1
a307 1
				  unsigned offset);
d312 1
a312 6
				   unsigned offset);

void gen7_block_read_scratch(struct brw_compile *p,
                             struct brw_reg dest,
                             int num_regs,
                             unsigned offset);
d321 2
a322 2
struct brw_instruction *brw_IF(struct brw_compile *p,
			       unsigned execute_size);
d332 1
a332 1
			       unsigned execute_size);
d355 1
a355 1
	     unsigned conditional,
d359 1
a359 18
void
brw_untyped_atomic(struct brw_compile *p,
                   struct brw_reg dest,
                   struct brw_reg mrf,
                   unsigned atomic_op,
                   unsigned bind_table_index,
                   unsigned msg_length,
                   unsigned response_length);

void
brw_untyped_surface_read(struct brw_compile *p,
                         struct brw_reg dest,
                         struct brw_reg mrf,
                         unsigned bind_table_index,
                         unsigned msg_length,
                         unsigned response_length);

/***********************************************************************
d366 1
a366 1
				   unsigned count);
d371 1
a371 1
			    unsigned count);
d376 1
a376 1
	       unsigned count);
d381 1
a381 1
	       unsigned count);
d383 1
a383 1
void brw_math_invert( struct brw_compile *p,
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@a36 1
#include "brw_inst.h"
a39 1
#include "intel_asm_annotation.h"
a47 6
/* A helper for accessing the last instruction emitted.  This makes it easy
 * to set various bits on an instruction without having to create temporary
 * variable and assign the emitted instruction to those.
 */
#define brw_last_inst (&p->store[p->nr_insn - 1])

d49 1
a49 1
   brw_inst *store;
d58 1
a58 1
   brw_inst stack[BRW_EU_MAX_INSN_STACK];
d60 1
a60 1
   brw_inst *current;
d62 1
d93 5
d100 10
a109 8
void brw_set_default_mask_control( struct brw_compile *p, unsigned value );
void brw_set_default_saturate( struct brw_compile *p, bool enable );
void brw_set_default_access_mode( struct brw_compile *p, unsigned access_mode );
void brw_set_default_compression_control(struct brw_compile *p, enum brw_compression c);
void brw_set_default_predicate_control( struct brw_compile *p, unsigned pc );
void brw_set_default_predicate_inverse(struct brw_compile *p, bool predicate_inverse);
void brw_set_default_flag_reg(struct brw_compile *p, int reg, int subreg);
void brw_set_default_acc_write_control(struct brw_compile *p, unsigned value);
d113 1
a113 2
void brw_disassemble(struct brw_context *brw, void *assembly,
                     int start, int end, FILE *out);
d116 5
a120 3
brw_inst *brw_next_insn(struct brw_compile *p, unsigned opcode);
void brw_set_dest(struct brw_compile *p, brw_inst *insn, struct brw_reg dest);
void brw_set_src0(struct brw_compile *p, brw_inst *insn, struct brw_reg reg);
d128 3
a130 3
#define ALU1(OP)				\
brw_inst *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,		\
d133 4
a136 4
#define ALU2(OP)				\
brw_inst *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,		\
	      struct brw_reg src0,		\
d139 5
a143 5
#define ALU3(OP)				\
brw_inst *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,		\
	      struct brw_reg src0,		\
	      struct brw_reg src1,		\
d160 1
d200 1
a200 1
                             brw_inst *insn,
a209 5
void brw_set_indirect_send_descriptor(struct brw_compile *p,
                                      brw_inst *insn,
                                      unsigned sfid,
                                      struct brw_reg descriptor);

d211 1
a211 1
			     brw_inst *insn,
d221 1
a221 1
			      brw_inst *insn,
d259 2
a260 2
		   struct brw_reg payload,
		   struct brw_reg implied_header,
d281 1
a281 6
void brw_adjust_sampler_state_pointer(struct brw_compile *p,
                                      struct brw_reg header,
                                      struct brw_reg sampler_index,
                                      struct brw_reg scratch);

void gen4_math(struct brw_compile *p,
d286 1
d289 1
a289 1
void gen6_math(struct brw_compile *p,
a320 24
/**
 * Return the generation-specific jump distance scaling factor.
 *
 * Given the number of instructions to jump, we need to scale by
 * some number to obtain the actual jump distance to program in an
 * instruction.
 */
static inline unsigned
brw_jump_scale(const struct brw_context *brw)
{
   /* Broadwell measures jump targets in bytes. */
   if (brw->gen >= 8)
      return 16;

   /* Ironlake and later measure jump targets in 64-bit data chunks (in order
    * (to support compaction), so each 128-bit instruction requires 2 chunks.
    */
   if (brw->gen >= 5)
      return 2;

   /* Gen4 simply uses the number of 128-bit instructions. */
   return 1;
}

d324 4
a327 3
brw_inst *brw_IF(struct brw_compile *p, unsigned execute_size);
brw_inst *gen6_IF(struct brw_compile *p, enum brw_conditional_mod conditional,
                  struct brw_reg src0, struct brw_reg src1);
d334 2
a335 1
brw_inst *brw_DO(struct brw_compile *p, unsigned execute_size);
d337 1
a337 5
brw_inst *brw_WHILE(struct brw_compile *p);

brw_inst *brw_BREAK(struct brw_compile *p);
brw_inst *brw_CONT(struct brw_compile *p);
brw_inst *gen6_HALT(struct brw_compile *p);
d339 4
d347 1
a347 2
brw_inst *brw_JMPI(struct brw_compile *p, struct brw_reg index,
                   unsigned predicate_control);
d351 2
d365 1
a365 1
                   struct brw_reg payload,
a378 10
void
brw_pixel_interpolator_query(struct brw_compile *p,
                             struct brw_reg dest,
                             struct brw_reg mrf,
                             bool noperspective,
                             unsigned mode,
                             unsigned data,
                             unsigned msg_length,
                             unsigned response_length);

d407 3
a409 1
void brw_set_src1(struct brw_compile *p, brw_inst *insn, struct brw_reg reg);
d413 1
a413 1
enum brw_conditional_mod brw_swap_cmod(uint32_t cmod);
d417 11
a427 20
void brw_compact_instructions(struct brw_compile *p, int start_offset,
                              int num_annotations, struct annotation *annotation);
void brw_uncompact_instruction(struct brw_context *brw, brw_inst *dst,
                               brw_compact_inst *src);
bool brw_try_compact_instruction(struct brw_context *brw, brw_compact_inst *dst,
                                 brw_inst *src);

void brw_debug_compact_uncompact(struct brw_context *brw, brw_inst *orig,
                                 brw_inst *uncompacted);

static inline int
next_offset(const struct brw_context *brw, void *store, int offset)
{
   brw_inst *insn = (brw_inst *)((char *)store + offset);

   if (brw_inst_cmpt_control(brw, insn))
      return offset + 8;
   else
      return offset + 16;
}
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d37 1
d41 1
d50 6
d57 1
a57 1
   struct brw_instruction *store;
d66 1
a66 1
   struct brw_instruction stack[BRW_EU_MAX_INSN_STACK];
d68 1
a68 1
   struct brw_instruction *current;
a69 1
   unsigned flag_value;
a99 5
static inline struct brw_instruction *current_insn( struct brw_compile *p)
{
   return &p->store[p->nr_insn];
}

d102 8
a109 10
void brw_set_mask_control( struct brw_compile *p, unsigned value );
void brw_set_saturate( struct brw_compile *p, bool enable );
void brw_set_access_mode( struct brw_compile *p, unsigned access_mode );
void brw_set_compression_control(struct brw_compile *p, enum brw_compression c);
void brw_set_predicate_control_flag_value( struct brw_compile *p, unsigned value );
void brw_set_predicate_control( struct brw_compile *p, unsigned pc );
void brw_set_predicate_inverse(struct brw_compile *p, bool predicate_inverse);
void brw_set_conditionalmod( struct brw_compile *p, unsigned conditional );
void brw_set_flag_reg(struct brw_compile *p, int reg, int subreg);
void brw_set_acc_write_control(struct brw_compile *p, unsigned value);
d113 2
a114 1
void brw_dump_compile(struct brw_compile *p, FILE *out, int start, int end);
d117 3
a119 5
struct brw_instruction *brw_next_insn(struct brw_compile *p, unsigned opcode);
void brw_set_dest(struct brw_compile *p, struct brw_instruction *insn,
		  struct brw_reg dest);
void brw_set_src0(struct brw_compile *p, struct brw_instruction *insn,
		  struct brw_reg reg);
d127 3
a129 3
#define ALU1(OP)					\
struct brw_instruction *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,			\
d132 4
a135 4
#define ALU2(OP)					\
struct brw_instruction *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,			\
	      struct brw_reg src0,			\
d138 5
a142 5
#define ALU3(OP)					\
struct brw_instruction *brw_##OP(struct brw_compile *p,	\
	      struct brw_reg dest,			\
	      struct brw_reg src0,			\
	      struct brw_reg src1,			\
a158 1
ALU2(JMPI)
d198 1
a198 1
                             struct brw_instruction *insn,
d208 5
d214 1
a214 1
			     struct brw_instruction *insn,
d224 1
a224 1
			      struct brw_instruction *insn,
d262 2
a263 2
		   unsigned msg_reg_nr,
		   struct brw_reg src0,
d284 6
a289 1
void brw_math( struct brw_compile *p,
a293 1
	       unsigned data_type,
d296 1
a296 1
void brw_math2(struct brw_compile *p,
d328 24
d355 3
a357 4
struct brw_instruction *brw_IF(struct brw_compile *p,
			       unsigned execute_size);
struct brw_instruction *gen6_IF(struct brw_compile *p, uint32_t conditional,
				struct brw_reg src0, struct brw_reg src1);
d364 1
a364 2
struct brw_instruction *brw_DO(struct brw_compile *p,
			       unsigned execute_size);
d366 5
a370 1
struct brw_instruction *brw_WHILE(struct brw_compile *p);
a371 4
struct brw_instruction *brw_BREAK(struct brw_compile *p);
struct brw_instruction *brw_CONT(struct brw_compile *p);
struct brw_instruction *gen6_CONT(struct brw_compile *p);
struct brw_instruction *gen6_HALT(struct brw_compile *p);
d376 2
a377 1

a380 2
void brw_WAIT(struct brw_compile *p);

d393 1
a393 1
                   struct brw_reg mrf,
d407 10
d445 1
a445 3
void brw_set_src1(struct brw_compile *p,
		  struct brw_instruction *insn,
		  struct brw_reg reg);
d449 1
a449 1
uint32_t brw_swap_cmod(uint32_t cmod);
d453 20
a472 11
void brw_compact_instructions(struct brw_compile *p);
void brw_uncompact_instruction(struct brw_context *brw,
			       struct brw_instruction *dst,
			       struct brw_compact_instruction *src);
bool brw_try_compact_instruction(struct brw_compile *p,
                                 struct brw_compact_instruction *dst,
                                 struct brw_instruction *src);

void brw_debug_compact_uncompact(struct brw_context *brw,
				 struct brw_instruction *orig,
				 struct brw_instruction *uncompacted);
@


