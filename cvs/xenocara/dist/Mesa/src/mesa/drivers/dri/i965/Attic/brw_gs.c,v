head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.04.19;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.15;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.43;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.28.34;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.15.35;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.50;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.11.39;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.48.45;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics to
 develop this 3D driver.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */

#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"
#include "main/transformfeedback.h"

#include "intel_batchbuffer.h"

#include "brw_defines.h"
#include "brw_context.h"
#include "brw_eu.h"
#include "brw_util.h"
#include "brw_state.h"
#include "brw_gs.h"

#include "glsl/ralloc.h"

static void compile_ff_gs_prog(struct brw_context *brw,
                               struct brw_ff_gs_prog_key *key)
{
   struct brw_ff_gs_compile c;
   const GLuint *program;
   void *mem_ctx;
   GLuint program_size;

   memset(&c, 0, sizeof(c));

   c.key = *key;
   c.vue_map = brw->vs.prog_data->base.vue_map;
   c.nr_regs = (c.vue_map.num_slots + 1)/2;

   mem_ctx = ralloc_context(NULL);

   /* Begin the compilation:
    */
   brw_init_compile(brw, &c.func, mem_ctx);

   c.func.single_program_flow = 1;

   /* For some reason the thread is spawned with only 4 channels
    * unmasked.
    */
   brw_set_mask_control(&c.func, BRW_MASK_DISABLE);

   if (brw->gen >= 6) {
      unsigned num_verts;
      bool check_edge_flag;
      /* On Sandybridge, we use the GS for implementing transform feedback
       * (called "Stream Out" in the PRM).
       */
      switch (key->primitive) {
      case _3DPRIM_POINTLIST:
         num_verts = 1;
         check_edge_flag = false;
	 break;
      case _3DPRIM_LINELIST:
      case _3DPRIM_LINESTRIP:
      case _3DPRIM_LINELOOP:
         num_verts = 2;
         check_edge_flag = false;
	 break;
      case _3DPRIM_TRILIST:
      case _3DPRIM_TRIFAN:
      case _3DPRIM_TRISTRIP:
      case _3DPRIM_RECTLIST:
	 num_verts = 3;
         check_edge_flag = false;
         break;
      case _3DPRIM_QUADLIST:
      case _3DPRIM_QUADSTRIP:
      case _3DPRIM_POLYGON:
         num_verts = 3;
         check_edge_flag = true;
         break;
      default:
	 assert(!"Unexpected primitive type in Gen6 SOL program.");
	 return;
      }
      gen6_sol_program(&c, key, num_verts, check_edge_flag);
   } else {
      /* On Gen4-5, we use the GS to decompose certain types of primitives.
       * Note that primitives which don't require a GS program have already
       * been weeded out by now.
       */
      switch (key->primitive) {
      case _3DPRIM_QUADLIST:
	 brw_ff_gs_quads( &c, key );
	 break;
      case _3DPRIM_QUADSTRIP:
	 brw_ff_gs_quad_strip( &c, key );
	 break;
      case _3DPRIM_LINELOOP:
	 brw_ff_gs_lines( &c );
	 break;
      default:
	 ralloc_free(mem_ctx);
	 return;
      }
   }

   /* get the program
    */
   program = brw_get_program(&c.func, &program_size);

   if (unlikely(INTEL_DEBUG & DEBUG_GS)) {
      int i;

      fprintf(stderr, "gs:\n");
      for (i = 0; i < program_size / sizeof(struct brw_instruction); i++)
	 brw_disasm(stderr, &((struct brw_instruction *)program)[i],
		    brw->gen);
      fprintf(stderr, "\n");
    }

   brw_upload_cache(&brw->cache, BRW_FF_GS_PROG,
		    &c.key, sizeof(c.key),
		    program, program_size,
		    &c.prog_data, sizeof(c.prog_data),
		    &brw->ff_gs.prog_offset, &brw->ff_gs.prog_data);
   ralloc_free(mem_ctx);
}

static void populate_key(struct brw_context *brw,
                         struct brw_ff_gs_prog_key *key)
{
   static const unsigned swizzle_for_offset[4] = {
      BRW_SWIZZLE4(0, 1, 2, 3),
      BRW_SWIZZLE4(1, 2, 3, 3),
      BRW_SWIZZLE4(2, 3, 3, 3),
      BRW_SWIZZLE4(3, 3, 3, 3)
   };

   struct gl_context *ctx = &brw->ctx;

   memset(key, 0, sizeof(*key));

   /* CACHE_NEW_VS_PROG (part of VUE map) */
   key->attrs = brw->vs.prog_data->base.vue_map.slots_valid;

   /* BRW_NEW_PRIMITIVE */
   key->primitive = brw->primitive;

   /* _NEW_LIGHT */
   key->pv_first = (ctx->Light.ProvokingVertex == GL_FIRST_VERTEX_CONVENTION);
   if (key->primitive == _3DPRIM_QUADLIST && ctx->Light.ShadeModel != GL_FLAT) {
      /* Provide consistent primitive order with brw_set_prim's
       * optimization of single quads to trifans.
       */
      key->pv_first = true;
   }

   if (brw->gen >= 7) {
      /* On Gen7 and later, we don't use GS (yet). */
      key->need_gs_prog = false;
   } else if (brw->gen == 6) {
      /* On Gen6, GS is used for transform feedback. */
      /* BRW_NEW_TRANSFORM_FEEDBACK */
      if (_mesa_is_xfb_active_and_unpaused(ctx)) {
         const struct gl_shader_program *shaderprog =
            ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX];
         const struct gl_transform_feedback_info *linked_xfb_info =
            &shaderprog->LinkedTransformFeedback;
         int i;

         /* Make sure that the VUE slots won't overflow the unsigned chars in
          * key->transform_feedback_bindings[].
          */
         STATIC_ASSERT(BRW_VARYING_SLOT_COUNT <= 256);

         /* Make sure that we don't need more binding table entries than we've
          * set aside for use in transform feedback.  (We shouldn't, since we
          * set aside enough binding table entries to have one per component).
          */
         assert(linked_xfb_info->NumOutputs <= BRW_MAX_SOL_BINDINGS);

         key->need_gs_prog = true;
         key->num_transform_feedback_bindings = linked_xfb_info->NumOutputs;
         for (i = 0; i < key->num_transform_feedback_bindings; ++i) {
            key->transform_feedback_bindings[i] =
               linked_xfb_info->Outputs[i].OutputRegister;
            key->transform_feedback_swizzles[i] =
               swizzle_for_offset[linked_xfb_info->Outputs[i].ComponentOffset];
         }
      }
   } else {
      /* Pre-gen6, GS is used to transform QUADLIST, QUADSTRIP, and LINELOOP
       * into simpler primitives.
       */
      key->need_gs_prog = (brw->primitive == _3DPRIM_QUADLIST ||
                           brw->primitive == _3DPRIM_QUADSTRIP ||
                           brw->primitive == _3DPRIM_LINELOOP);
   }
}

/* Calculate interpolants for triangle and line rasterization.
 */
static void
brw_upload_ff_gs_prog(struct brw_context *brw)
{
   struct brw_ff_gs_prog_key key;
   /* Populate the key:
    */
   populate_key(brw, &key);

   if (brw->ff_gs.prog_active != key.need_gs_prog) {
      brw->state.dirty.cache |= CACHE_NEW_FF_GS_PROG;
      brw->ff_gs.prog_active = key.need_gs_prog;
   }

   if (brw->ff_gs.prog_active) {
      if (!brw_search_cache(&brw->cache, BRW_FF_GS_PROG,
			    &key, sizeof(key),
			    &brw->ff_gs.prog_offset, &brw->ff_gs.prog_data)) {
	 compile_ff_gs_prog( brw, &key );
      }
   }
}


const struct brw_tracked_state brw_ff_gs_prog = {
   .dirty = {
      .mesa  = (_NEW_LIGHT),
      .brw   = (BRW_NEW_PRIMITIVE |
                BRW_NEW_TRANSFORM_FEEDBACK),
      .cache = CACHE_NEW_VS_PROG
   },
   .emit = brw_upload_ff_gs_prog
};
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d2 34
a35 21
 * Copyright © 2013 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
d37 1
a37 5
/**
 * \file brw_vec4_gs.c
 *
 * State atom for client-programmable geometry shaders, and support code.
 */
d39 1
a39 1
#include "brw_gs.h"
d41 2
a42 1
#include "brw_vec4_gs_visitor.h"
d44 1
a44 1
#include "brw_ff_gs.h"
d46 1
d48 2
a49 5
static bool
do_gs_prog(struct brw_context *brw,
           struct gl_shader_program *prog,
           struct brw_geometry_program *gp,
           struct brw_gs_prog_key *key)
d51 5
a55 2
   struct brw_stage_state *stage_state = &brw->gs.base;
   struct brw_gs_compile c;
d57 1
d59 2
a60 4
   c.gp = gp;

   c.prog_data.include_primitive_id =
      (gp->program.Base.InputsRead & VARYING_BIT_PRIMITIVE_ID) != 0;
d62 1
a62 1
   c.prog_data.invocations = gp->program.Invocations;
d64 1
a64 7
   /* Allocate the references to the uniforms that will end up in the
    * prog_data associated with the compiled program, and which will be freed
    * by the state cache.
    *
    * Note: param_count needs to be num_uniform_components * 4, since we add
    * padding around uniform values below vec4 size, so the worst case is that
    * every uniform is a float which gets padded to the size of a vec4.
d66 1
a66 2
   struct gl_shader *gs = prog->_LinkedShaders[MESA_SHADER_GEOMETRY];
   int param_count = gs->num_uniform_components * 4;
d68 1
a68 2
   /* We also upload clip plane data as uniforms */
   param_count += MAX_CLIP_PLANES * 4;
d70 2
a71 7
   c.prog_data.base.base.param =
      rzalloc_array(NULL, const gl_constant_value *, param_count);
   c.prog_data.base.base.pull_param =
      rzalloc_array(NULL, const gl_constant_value *, param_count);
   /* Setting nr_params here NOT to the size of the param and pull_param
    * arrays, but to the number of uniform components vec4_visitor
    * needs. vec4_visitor::setup_uniforms() will set it back to a proper value.
d73 1
a73 1
   c.prog_data.base.base.nr_params = ALIGN(param_count, 4) / 4 + gs->num_samplers;
d75 33
a107 26
   if (brw->gen >= 7) {
      if (gp->program.OutputType == GL_POINTS) {
         /* When the output type is points, the geometry shader may output data
          * to multiple streams, and EndPrimitive() has no effect.  So we
          * configure the hardware to interpret the control data as stream ID.
          */
         c.prog_data.control_data_format = GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_SID;

         /* We only have to emit control bits if we are using streams */
         if (prog->Geom.UsesStreams)
            c.control_data_bits_per_vertex = 2;
         else
            c.control_data_bits_per_vertex = 0;
      } else {
         /* When the output type is triangle_strip or line_strip, EndPrimitive()
          * may be used to terminate the current strip and start a new one
          * (similar to primitive restart), and outputting data to multiple
          * streams is not supported.  So we configure the hardware to interpret
          * the control data as EndPrimitive information (a.k.a. "cut bits").
          */
         c.prog_data.control_data_format = GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_CUT;

         /* We only need to output control data if the shader actually calls
          * EndPrimitive().
          */
         c.control_data_bits_per_vertex = gp->program.UsesEndPrimitive ? 1 : 0;
d109 1
d111 18
a128 8
      /* There are no control data bits in gen6. */
      c.control_data_bits_per_vertex = 0;

      /* If it is using transform feedback, enable it */
      if (prog->TransformFeedback.NumVarying)
         c.prog_data.gen6_xfb_enabled = true;
      else
         c.prog_data.gen6_xfb_enabled = false;
a129 2
   c.control_data_header_size_bits =
      gp->program.VerticesOut * c.control_data_bits_per_vertex;
d131 1
a131 9
   /* 1 HWORD = 32 bytes = 256 bits */
   c.prog_data.control_data_header_size_hwords =
      ALIGN(c.control_data_header_size_bits, 256) / 256;

   GLbitfield64 outputs_written = gp->program.Base.OutputsWritten;

   /* In order for legacy clipping to work, we need to populate the clip
    * distance varying slots whenever clipping is enabled, even if the vertex
    * shader doesn't write to gl_ClipDistance.
d133 1
a133 4
   if (c.key.base.userclip_active) {
      outputs_written |= BITFIELD64_BIT(VARYING_SLOT_CLIP_DIST0);
      outputs_written |= BITFIELD64_BIT(VARYING_SLOT_CLIP_DIST1);
   }
d135 2
a136 1
   brw_compute_vue_map(brw, &c.prog_data.base.vue_map, outputs_written);
d138 14
a151 94
   /* Compute the output vertex size.
    *
    * From the Ivy Bridge PRM, Vol2 Part1 7.2.1.1 STATE_GS - Output Vertex
    * Size (p168):
    *
    *     [0,62] indicating [1,63] 16B units
    *
    *     Specifies the size of each vertex stored in the GS output entry
    *     (following any Control Header data) as a number of 128-bit units
    *     (minus one).
    *
    *     Programming Restrictions: The vertex size must be programmed as a
    *     multiple of 32B units with the following exception: Rendering is
    *     disabled (as per SOL stage state) and the vertex size output by the
    *     GS thread is 16B.
    *
    *     If rendering is enabled (as per SOL state) the vertex size must be
    *     programmed as a multiple of 32B units. In other words, the only time
    *     software can program a vertex size with an odd number of 16B units
    *     is when rendering is disabled.
    *
    * Note: B=bytes in the above text.
    *
    * It doesn't seem worth the extra trouble to optimize the case where the
    * vertex size is 16B (especially since this would require special-casing
    * the GEN assembly that writes to the URB).  So we just set the vertex
    * size to a multiple of 32B (2 vec4's) in all cases.
    *
    * The maximum output vertex size is 62*16 = 992 bytes (31 hwords).  We
    * budget that as follows:
    *
    *   512 bytes for varyings (a varying component is 4 bytes and
    *             gl_MaxGeometryOutputComponents = 128)
    *    16 bytes overhead for VARYING_SLOT_PSIZ (each varying slot is 16
    *             bytes)
    *    16 bytes overhead for gl_Position (we allocate it a slot in the VUE
    *             even if it's not used)
    *    32 bytes overhead for gl_ClipDistance (we allocate it 2 VUE slots
    *             whenever clip planes are enabled, even if the shader doesn't
    *             write to gl_ClipDistance)
    *    16 bytes overhead since the VUE size must be a multiple of 32 bytes
    *             (see below)--this causes up to 1 VUE slot to be wasted
    *   400 bytes available for varying packing overhead
    *
    * Worst-case varying packing overhead is 3/4 of a varying slot (12 bytes)
    * per interpolation type, so this is plenty.
    *
    */
   unsigned output_vertex_size_bytes = c.prog_data.base.vue_map.num_slots * 16;
   assert(brw->gen == 6 ||
          output_vertex_size_bytes <= GEN7_MAX_GS_OUTPUT_VERTEX_SIZE_BYTES);
   c.prog_data.output_vertex_size_hwords =
      ALIGN(output_vertex_size_bytes, 32) / 32;

   /* Compute URB entry size.  The maximum allowed URB entry size is 32k.
    * That divides up as follows:
    *
    *     64 bytes for the control data header (cut indices or StreamID bits)
    *   4096 bytes for varyings (a varying component is 4 bytes and
    *              gl_MaxGeometryTotalOutputComponents = 1024)
    *   4096 bytes overhead for VARYING_SLOT_PSIZ (each varying slot is 16
    *              bytes/vertex and gl_MaxGeometryOutputVertices is 256)
    *   4096 bytes overhead for gl_Position (we allocate it a slot in the VUE
    *              even if it's not used)
    *   8192 bytes overhead for gl_ClipDistance (we allocate it 2 VUE slots
    *              whenever clip planes are enabled, even if the shader doesn't
    *              write to gl_ClipDistance)
    *   4096 bytes overhead since the VUE size must be a multiple of 32
    *              bytes (see above)--this causes up to 1 VUE slot to be wasted
    *   8128 bytes available for varying packing overhead
    *
    * Worst-case varying packing overhead is 3/4 of a varying slot per
    * interpolation type, which works out to 3072 bytes, so this would allow
    * us to accommodate 2 interpolation types without any danger of running
    * out of URB space.
    *
    * In practice, the risk of running out of URB space is very small, since
    * the above figures are all worst-case, and most of them scale with the
    * number of output vertices.  So we'll just calculate the amount of space
    * we need, and if it's too large, fail to compile.
    *
    * The above is for gen7+ where we have a single URB entry that will hold
    * all the output. In gen6, we will have to allocate URB entries for every
    * vertex we emit, so our URB entries only need to be large enough to hold
    * a single vertex. Also, gen6 does not have a control data header.
    */
   unsigned output_size_bytes;
   if (brw->gen >= 7) {
      output_size_bytes =
         c.prog_data.output_vertex_size_hwords * 32 * gp->program.VerticesOut;
      output_size_bytes += 32 * c.prog_data.control_data_header_size_hwords;
   } else {
      output_size_bytes = c.prog_data.output_vertex_size_hwords * 32;
   }
d153 9
a161 5
   /* Broadwell stores "Vertex Count" as a full 8 DWord (32 byte) URB output,
    * which comes before the control header.
    */
   if (brw->gen >= 8)
      output_size_bytes += 32;
d163 1
a163 6
   assert(output_size_bytes >= 1);
   int max_output_size_bytes = GEN7_MAX_GS_URB_ENTRY_SIZE_BYTES;
   if (brw->gen == 6)
      max_output_size_bytes = GEN6_MAX_GS_URB_ENTRY_SIZE_BYTES;
   if (output_size_bytes > max_output_size_bytes)
      return false;
d165 1
d167 2
a168 7
   /* URB entry sizes are stored as a multiple of 64 bytes in gen7+ and
    * a multiple of 128 bytes in gen6.
    */
   if (brw->gen >= 7)
      c.prog_data.base.urb_entry_size = ALIGN(output_size_bytes, 64) / 64;
   else
      c.prog_data.base.urb_entry_size = ALIGN(output_size_bytes, 128) / 128;
d170 2
a171 2
   c.prog_data.output_topology =
      get_hw_prim_for_gl_prim(gp->program.OutputType);
d173 7
a179 14
   brw_compute_vue_map(brw, &c.input_vue_map, c.key.input_varyings);

   /* GS inputs are read from the VUE 256 bits (2 vec4's) at a time, so we
    * need to program a URB read length of ceiling(num_slots / 2).
    */
   c.prog_data.base.urb_read_length = (c.input_vue_map.num_slots + 1) / 2;

   void *mem_ctx = ralloc_context(NULL);
   unsigned program_size;
   const unsigned *program =
      brw_gs_emit(brw, prog, &c, mem_ctx, &program_size);
   if (program == NULL) {
      ralloc_free(mem_ctx);
      return false;
d182 12
a193 13
   /* Scratch space is used for register spilling */
   if (c.base.last_scratch) {
      perf_debug("Geometry shader triggered register spilling.  "
                 "Try reducing the number of live vec4 values to "
                 "improve performance.\n");

      c.prog_data.base.base.total_scratch
         = brw_get_scratch_size(c.base.last_scratch*REG_SIZE);

      brw_get_scratch_bo(brw, &stage_state->scratch_bo,
			 c.prog_data.base.base.total_scratch *
                         brw->max_gs_threads);
   }
d195 4
a198 6
   brw_upload_cache(&brw->cache, BRW_GS_PROG,
                    &c.key, sizeof(c.key),
                    program, program_size,
                    &c.prog_data, sizeof(c.prog_data),
                    &stage_state->prog_offset, &brw->gs.prog_data);
   ralloc_free(mem_ctx);
d200 5
a204 20
   return true;
}


static void
brw_upload_gs_prog(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   struct brw_stage_state *stage_state = &brw->gs.base;
   struct brw_gs_prog_key key;
   /* BRW_NEW_GEOMETRY_PROGRAM */
   struct brw_geometry_program *gp =
      (struct brw_geometry_program *) brw->geometry_program;

   if (gp == NULL) {
      /* No geometry shader.  Vertex data just passes straight through. */
      if (brw->state.dirty.brw & BRW_NEW_VUE_MAP_VS) {
         brw->vue_map_geom_out = brw->vue_map_vs;
         brw->state.dirty.brw |= BRW_NEW_VUE_MAP_GEOM_OUT;
      }
d206 8
a213 4
      if (brw->gen == 6 &&
          (brw->state.dirty.brw & BRW_NEW_TRANSFORM_FEEDBACK)) {
         gen6_brw_upload_ff_gs_prog(brw);
         return;
d215 3
a217 3

      /* Other state atoms had better not try to access prog_data, since
       * there's no GS program.
d219 3
a221 4
      brw->gs.prog_data = NULL;
      brw->gs.base.prog_data = NULL;

      return;
d223 1
d225 9
a233 1
   struct gl_program *prog = &gp->program.Base;
d235 3
a237 24
   memset(&key, 0, sizeof(key));

   key.base.program_string_id = gp->id;
   brw_setup_vec4_key_clip_info(brw, &key.base,
                                gp->program.Base.UsesClipDistanceOut);

   /* _NEW_LIGHT | _NEW_BUFFERS */
   key.base.clamp_vertex_color = ctx->Light._ClampVertexColor;

   /* _NEW_TEXTURE */
   brw_populate_sampler_prog_key_data(ctx, prog, stage_state->sampler_count,
                                      &key.base.tex);

   /* BRW_NEW_VUE_MAP_VS */
   key.input_varyings = brw->vue_map_vs.slots_valid;

   if (!brw_search_cache(&brw->cache, BRW_GS_PROG,
                         &key, sizeof(key),
                         &stage_state->prog_offset, &brw->gs.prog_data)) {
      bool success =
         do_gs_prog(brw, ctx->_Shader->CurrentProgram[MESA_SHADER_GEOMETRY], gp,
                    &key);
      assert(success);
      (void)success;
a238 1
   brw->gs.base.prog_data = &brw->gs.prog_data->base.base;
d240 6
a245 4
   if (memcmp(&brw->vs.prog_data->base.vue_map, &brw->vue_map_geom_out,
              sizeof(brw->vue_map_geom_out)) != 0) {
      brw->vue_map_geom_out = brw->gs.prog_data->base.vue_map;
      brw->state.dirty.brw |= BRW_NEW_VUE_MAP_GEOM_OUT;
d250 1
a250 1
const struct brw_tracked_state brw_gs_prog = {
d252 2
a253 3
      .mesa  = (_NEW_LIGHT | _NEW_BUFFERS | _NEW_TEXTURE),
      .brw   = (BRW_NEW_GEOMETRY_PROGRAM |
                BRW_NEW_VUE_MAP_VS |
d255 1
d257 1
a257 1
   .emit = brw_upload_gs_prog
a258 55


bool
brw_gs_precompile(struct gl_context *ctx, struct gl_shader_program *prog)
{
   struct brw_context *brw = brw_context(ctx);
   struct brw_gs_prog_key key;
   uint32_t old_prog_offset = brw->gs.base.prog_offset;
   struct brw_gs_prog_data *old_prog_data = brw->gs.prog_data;
   bool success;

   if (!prog->_LinkedShaders[MESA_SHADER_GEOMETRY])
      return true;

   struct gl_geometry_program *gp = (struct gl_geometry_program *)
      prog->_LinkedShaders[MESA_SHADER_GEOMETRY]->Program;
   struct brw_geometry_program *bgp = brw_geometry_program(gp);

   memset(&key, 0, sizeof(key));

   brw_vec4_setup_prog_key_for_precompile(ctx, &key.base, bgp->id, &gp->Base);

   /* Assume that the set of varyings coming in from the vertex shader exactly
    * matches what the geometry shader requires.
    */
   key.input_varyings = gp->Base.InputsRead;

   success = do_gs_prog(brw, prog, bgp, &key);

   brw->gs.base.prog_offset = old_prog_offset;
   brw->gs.prog_data = old_prog_data;

   return success;
}


bool
brw_gs_prog_data_compare(const void *in_a, const void *in_b)
{
   const struct brw_gs_prog_data *a = in_a;
   const struct brw_gs_prog_data *b = in_b;

   /* Compare the base structure. */
   if (!brw_stage_prog_data_compare(&a->base.base, &b->base.base))
      return false;

   /* Compare the rest of the struct. */
   const unsigned offset = sizeof(struct brw_stage_prog_data);
   if (memcmp(((char *) a) + offset, ((char *) b) + offset,
              sizeof(struct brw_gs_prog_data) - offset)) {
      return false;
   }

   return true;
}
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d2 21
a22 34
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics to
 develop this 3D driver.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */

#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"
#include "main/transformfeedback.h"
d24 5
a28 1
#include "intel_batchbuffer.h"
d30 1
a30 1
#include "brw_defines.h"
d32 1
a32 2
#include "brw_eu.h"
#include "brw_util.h"
d34 1
a34 1
#include "brw_gs.h"
a35 1
#include "glsl/ralloc.h"
d37 5
a41 2
static void compile_ff_gs_prog(struct brw_context *brw,
                               struct brw_ff_gs_prog_key *key)
d43 2
a44 5
   struct brw_ff_gs_compile c;
   const GLuint *program;
   void *mem_ctx;
   GLuint program_size;

d46 2
d49 2
a50 3
   c.key = *key;
   c.vue_map = brw->vs.prog_data->base.vue_map;
   c.nr_regs = (c.vue_map.num_slots + 1)/2;
d52 1
a52 1
   mem_ctx = ralloc_context(NULL);
d54 7
a60 1
   /* Begin the compilation:
d62 2
a63 1
   brw_init_compile(brw, &c.func, mem_ctx);
d65 2
a66 1
   c.func.single_program_flow = 1;
d68 7
a74 2
   /* For some reason the thread is spawned with only 4 channels
    * unmasked.
d76 9
a84 1
   brw_set_mask_control(&c.func, BRW_MASK_DISABLE);
d86 18
a103 33
   if (brw->gen >= 6) {
      unsigned num_verts;
      bool check_edge_flag;
      /* On Sandybridge, we use the GS for implementing transform feedback
       * (called "Stream Out" in the PRM).
       */
      switch (key->primitive) {
      case _3DPRIM_POINTLIST:
         num_verts = 1;
         check_edge_flag = false;
	 break;
      case _3DPRIM_LINELIST:
      case _3DPRIM_LINESTRIP:
      case _3DPRIM_LINELOOP:
         num_verts = 2;
         check_edge_flag = false;
	 break;
      case _3DPRIM_TRILIST:
      case _3DPRIM_TRIFAN:
      case _3DPRIM_TRISTRIP:
      case _3DPRIM_RECTLIST:
	 num_verts = 3;
         check_edge_flag = false;
         break;
      case _3DPRIM_QUADLIST:
      case _3DPRIM_QUADSTRIP:
      case _3DPRIM_POLYGON:
         num_verts = 3;
         check_edge_flag = true;
         break;
      default:
	 assert(!"Unexpected primitive type in Gen6 SOL program.");
	 return;
a104 1
      gen6_sol_program(&c, key, num_verts, check_edge_flag);
d106 122
a227 18
      /* On Gen4-5, we use the GS to decompose certain types of primitives.
       * Note that primitives which don't require a GS program have already
       * been weeded out by now.
       */
      switch (key->primitive) {
      case _3DPRIM_QUADLIST:
	 brw_ff_gs_quads( &c, key );
	 break;
      case _3DPRIM_QUADSTRIP:
	 brw_ff_gs_quad_strip( &c, key );
	 break;
      case _3DPRIM_LINELOOP:
	 brw_ff_gs_lines( &c );
	 break;
      default:
	 ralloc_free(mem_ctx);
	 return;
      }
d230 2
a231 1
   /* get the program
d233 2
a234 1
   program = brw_get_program(&c.func, &program_size);
d236 6
a241 2
   if (unlikely(INTEL_DEBUG & DEBUG_GS)) {
      int i;
a242 14
      fprintf(stderr, "gs:\n");
      for (i = 0; i < program_size / sizeof(struct brw_instruction); i++)
	 brw_disasm(stderr, &((struct brw_instruction *)program)[i],
		    brw->gen);
      fprintf(stderr, "\n");
    }

   brw_upload_cache(&brw->cache, BRW_FF_GS_PROG,
		    &c.key, sizeof(c.key),
		    program, program_size,
		    &c.prog_data, sizeof(c.prog_data),
		    &brw->ff_gs.prog_offset, &brw->ff_gs.prog_data);
   ralloc_free(mem_ctx);
}
d244 7
a250 9
static void populate_key(struct brw_context *brw,
                         struct brw_ff_gs_prog_key *key)
{
   static const unsigned swizzle_for_offset[4] = {
      BRW_SWIZZLE4(0, 1, 2, 3),
      BRW_SWIZZLE4(1, 2, 3, 3),
      BRW_SWIZZLE4(2, 3, 3, 3),
      BRW_SWIZZLE4(3, 3, 3, 3)
   };
d252 2
a253 1
   struct gl_context *ctx = &brw->ctx;
d255 1
a255 1
   memset(key, 0, sizeof(*key));
d257 4
a260 2
   /* CACHE_NEW_VS_PROG (part of VUE map) */
   key->attrs = brw->vs.prog_data->base.vue_map.slots_valid;
d262 8
a269 2
   /* BRW_NEW_PRIMITIVE */
   key->primitive = brw->primitive;
d271 12
a282 7
   /* _NEW_LIGHT */
   key->pv_first = (ctx->Light.ProvokingVertex == GL_FIRST_VERTEX_CONVENTION);
   if (key->primitive == _3DPRIM_QUADLIST && ctx->Light.ShadeModel != GL_FLAT) {
      /* Provide consistent primitive order with brw_set_prim's
       * optimization of single quads to trifans.
       */
      key->pv_first = true;
d285 9
a293 12
   if (brw->gen >= 7) {
      /* On Gen7 and later, we don't use GS (yet). */
      key->need_gs_prog = false;
   } else if (brw->gen == 6) {
      /* On Gen6, GS is used for transform feedback. */
      /* BRW_NEW_TRANSFORM_FEEDBACK */
      if (_mesa_is_xfb_active_and_unpaused(ctx)) {
         const struct gl_shader_program *shaderprog =
            ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX];
         const struct gl_transform_feedback_info *linked_xfb_info =
            &shaderprog->LinkedTransformFeedback;
         int i;
a294 4
         /* Make sure that the VUE slots won't overflow the unsigned chars in
          * key->transform_feedback_bindings[].
          */
         STATIC_ASSERT(BRW_VARYING_SLOT_COUNT <= 256);
d296 16
a311 5
         /* Make sure that we don't need more binding table entries than we've
          * set aside for use in transform feedback.  (We shouldn't, since we
          * set aside enough binding table entries to have one per component).
          */
         assert(linked_xfb_info->NumOutputs <= BRW_MAX_SOL_BINDINGS);
d313 4
a316 8
         key->need_gs_prog = true;
         key->num_transform_feedback_bindings = linked_xfb_info->NumOutputs;
         for (i = 0; i < key->num_transform_feedback_bindings; ++i) {
            key->transform_feedback_bindings[i] =
               linked_xfb_info->Outputs[i].OutputRegister;
            key->transform_feedback_swizzles[i] =
               swizzle_for_offset[linked_xfb_info->Outputs[i].ComponentOffset];
         }
d318 3
a320 3
   } else {
      /* Pre-gen6, GS is used to transform QUADLIST, QUADSTRIP, and LINELOOP
       * into simpler primitives.
d322 4
a325 3
      key->need_gs_prog = (brw->primitive == _3DPRIM_QUADLIST ||
                           brw->primitive == _3DPRIM_QUADSTRIP ||
                           brw->primitive == _3DPRIM_LINELOOP);
a326 1
}
d328 3
a330 9
/* Calculate interpolants for triangle and line rasterization.
 */
static void
brw_upload_ff_gs_prog(struct brw_context *brw)
{
   struct brw_ff_gs_prog_key key;
   /* Populate the key:
    */
   populate_key(brw, &key);
d332 22
a353 3
   if (brw->ff_gs.prog_active != key.need_gs_prog) {
      brw->state.dirty.cache |= CACHE_NEW_FF_GS_PROG;
      brw->ff_gs.prog_active = key.need_gs_prog;
d355 1
d357 4
a360 6
   if (brw->ff_gs.prog_active) {
      if (!brw_search_cache(&brw->cache, BRW_FF_GS_PROG,
			    &key, sizeof(key),
			    &brw->ff_gs.prog_offset, &brw->ff_gs.prog_data)) {
	 compile_ff_gs_prog( brw, &key );
      }
d365 1
a365 1
const struct brw_tracked_state brw_ff_gs_prog = {
d367 3
a369 2
      .mesa  = (_NEW_LIGHT),
      .brw   = (BRW_NEW_PRIMITIVE |
a370 1
      .cache = CACHE_NEW_VS_PROG
d372 1
a372 1
   .emit = brw_upload_ff_gs_prog
d374 55
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
d5 1
a5 1
 
d13 1
a13 1
 
d17 1
a17 1
 
d25 1
a25 1
 
d29 1
a29 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d31 1
a31 1
      
d48 2
a49 2
static void compile_gs_prog( struct brw_context *brw,
			     struct brw_gs_prog_key *key )
d51 1
a51 1
   struct brw_gs_compile c;
d57 1
a57 1
   
d63 1
a63 1
   
d71 1
a71 1
    * unmasked.  
d117 1
a117 1
	 brw_gs_quads( &c, key );
d120 1
a120 1
	 brw_gs_quad_strip( &c, key );
d123 1
a123 1
	 brw_gs_lines( &c );
d138 1
a138 1
      printf("gs:\n");
d140 1
a140 1
	 brw_disasm(stdout, &((struct brw_instruction *)program)[i],
d142 1
a142 1
      printf("\n");
d145 1
a145 1
   brw_upload_cache(&brw->cache, BRW_GS_PROG,
d149 1
a149 1
		    &brw->gs.prog_offset, &brw->gs.prog_data);
d153 2
a154 2
static void populate_key( struct brw_context *brw,
			  struct brw_gs_prog_key *key )
d190 1
a190 1
            ctx->Shader.CurrentVertexProgram;
d228 1
a228 1
brw_upload_gs_prog(struct brw_context *brw)
d230 1
a230 1
   struct brw_gs_prog_key key;
d235 3
a237 3
   if (brw->gs.prog_active != key.need_gs_prog) {
      brw->state.dirty.cache |= CACHE_NEW_GS_PROG;
      brw->gs.prog_active = key.need_gs_prog;
d240 2
a241 2
   if (brw->gs.prog_active) {
      if (!brw_search_cache(&brw->cache, BRW_GS_PROG,
d243 2
a244 2
			    &brw->gs.prog_offset, &brw->gs.prog_data)) {
	 compile_gs_prog( brw, &key );
d250 1
a250 1
const struct brw_tracked_state brw_gs_prog = {
d257 1
a257 1
   .emit = brw_upload_gs_prog
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d35 1
d46 1
a46 1
#include "../glsl/ralloc.h"
a50 1
   struct intel_context *intel = &brw->intel;
a55 6
   /* Gen6: VF has already converted into polygon, and LINELOOP is
    * converted to LINESTRIP at the beginning of the 3D pipeline.
    */
   if (intel->gen >= 6)
      return;

d59 2
a60 11
   /* Need to locate the two positions present in vertex + header.
    * These are currently hardcoded:
    */
   c.nr_attrs = brw_count_bits(c.key.attrs);

   if (intel->gen >= 5)
       c.nr_regs = (c.nr_attrs + 1) / 2 + 3;  /* are vertices packed, or reg-aligned? */
   else
       c.nr_regs = (c.nr_attrs + 1) / 2 + 1;  /* are vertices packed, or reg-aligned? */

   c.nr_bytes = c.nr_regs * REG_SIZE;
d62 1
a62 1
   mem_ctx = NULL;
d75 54
a128 18

   /* Note that primitives which don't require a GS program have
    * already been weeded out by this stage:
    */

   switch (key->primitive) {
   case GL_QUADS:
      brw_gs_quads( &c, key );
      break;
   case GL_QUAD_STRIP:
      brw_gs_quad_strip( &c, key );
      break;
   case GL_LINE_LOOP:
      brw_gs_lines( &c );
      break;
   default:
      ralloc_free(mem_ctx);
      return;
d141 1
a141 1
		    intel->gen);
a152 13
static const GLenum gs_prim[GL_POLYGON+1] = {  
   GL_POINTS,
   GL_LINES,
   GL_LINE_LOOP,
   GL_LINES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_QUADS,
   GL_QUAD_STRIP,
   GL_TRIANGLES
};

d156 8
a163 2
   struct gl_context *ctx = &brw->intel.ctx;
   struct intel_context *intel = &brw->intel;
d167 2
a168 2
   /* CACHE_NEW_VS_PROG */
   key->attrs = brw->vs.prog_data->outputs_written;
d171 1
a171 1
   key->primitive = gs_prim[brw->primitive];
d175 1
a175 1
   if (key->primitive == GL_QUADS && ctx->Light.ShadeModel != GL_FLAT) {
d179 1
a179 1
      key->pv_first = GL_TRUE;
d182 41
a222 5
   key->need_gs_prog = (intel->gen >= 6)
      ? 0
      : (brw->primitive == GL_QUADS ||
	 brw->primitive == GL_QUAD_STRIP ||
	 brw->primitive == GL_LINE_LOOP);
d227 2
a228 1
static void prepare_gs_prog(struct brw_context *brw)
d252 3
a254 2
      .mesa  = _NEW_LIGHT,
      .brw   = BRW_NEW_PRIMITIVE,
d257 1
a257 1
   .prepare = prepare_gs_prog
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d45 1
a45 1

d53 1
d56 6
d77 1
d81 1
a81 1
   brw_init_compile(brw, &c.func);
a94 6
   /* Gen6: VF has already converted into polygon, and LINELOOP is
    * converted to LINESTRIP at the beginning of the 3D pipeline.
    */
   if (intel->gen == 6)
      return;

d106 1
d124 6
a129 10
   /* Upload
    */
   drm_intel_bo_unreference(brw->gs.prog_bo);
   brw->gs.prog_bo = brw_upload_cache_with_auxdata(&brw->cache, BRW_GS_PROG,
						   &c.key, sizeof(c.key),
						   NULL, 0,
						   program, program_size,
						   &c.prog_data,
						   sizeof(c.prog_data),
						   &brw->gs.prog_data);
d168 1
a168 1
   key->need_gs_prog = (intel->gen == 6)
a188 3
   drm_intel_bo_unreference(brw->gs.prog_bo);
   brw->gs.prog_bo = NULL;

d190 3
a192 5
      brw->gs.prog_bo = brw_search_cache(&brw->cache, BRW_GS_PROG,
					 &key, sizeof(key),
					 NULL, 0,
					 &brw->gs.prog_data);
      if (brw->gs.prog_bo == NULL)
d194 1
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d63 1
a63 1
   if (intel->gen == 5)
d86 7
a102 21
   case GL_LINES:
      if (key->hint_gs_always)
	 brw_gs_lines( &c );
      else {
	 return;
      }
      break;
   case GL_TRIANGLES:
      if (key->hint_gs_always)
	 brw_gs_tris( &c );
      else {
	 return;
      }
      break;
   case GL_POINTS:
      if (key->hint_gs_always)
	 brw_gs_points( &c );
      else {
	 return;
      }
      break;      
d111 10
d123 1
a123 1
   dri_bo_unreference(brw->gs.prog_bo);
d149 3
a151 1
   GLcontext *ctx = &brw->intel.ctx;
a159 2
   key->hint_gs_always = 0;	/* debug code? */
   
d162 6
d169 5
a173 4
   key->need_gs_prog = (key->hint_gs_always ||
			brw->primitive == GL_QUADS ||
			brw->primitive == GL_QUAD_STRIP ||
			brw->primitive == GL_LINE_LOOP);
d190 3
a193 1
      dri_bo_unreference(brw->gs.prog_bo);
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d50 1
a57 1

d62 6
a67 1
   c.nr_regs = (c.nr_attrs + 1) / 2 + 1;  /* are vertices packed, or reg-aligned? */
d88 1
a88 1
      brw_gs_quads( &c ); 
d91 1
a91 1
      brw_gs_quad_strip( &c );
d128 7
a134 6
   brw->gs.prog_bo = brw_upload_cache( &brw->cache, BRW_GS_PROG,
				       &c.key, sizeof(c.key),
				       NULL, 0,
				       program, program_size,
				       &c.prog_data,
				       &brw->gs.prog_data );
d153 1
d163 3
d201 1
a201 1
      .mesa  = 0,
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d32 3
a34 3
#include "glheader.h"
#include "macros.h"
#include "enums.h"
d165 1
a165 1
static int prepare_gs_prog( struct brw_context *brw )
a167 1
   int ret = 0;
a184 2

      ret |= dri_bufmgr_check_aperture_space(brw->gs.prog_bo);
a185 2

   return ret;
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d122 7
a128 7
   brw->gs.prog_gs_offset = brw_upload_cache( &brw->cache[BRW_GS_PROG],
					      &c.key,
					      sizeof(c.key),
					      program,
					      program_size,
					      &c.prog_data,
					      &brw->gs.prog_data );
a130 11

static GLboolean search_cache( struct brw_context *brw, 
			       struct brw_gs_prog_key *key )
{
   return brw_search_cache(&brw->cache[BRW_GS_PROG], 
			   key, sizeof(*key),
			   &brw->gs.prog_data,
			   &brw->gs.prog_gs_offset);
}


d165 1
a165 1
static void upload_gs_prog( struct brw_context *brw )
d168 1
a168 1

d179 6
a184 1
      if (!search_cache(brw, &key))
d186 2
d189 2
d200 1
a200 1
   .update = upload_gs_prog
@


1.1
log
@Initial revision
@
text
@d68 4
a71 2
   brw_init_compile(&c.func);
	
d85 3
d151 1
a151 1
   GL_QUADS,
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d69 1
a69 3

   c.func.single_program_flow = 1;

a82 3
   case GL_QUAD_STRIP:
      brw_gs_quad_strip( &c );
      break;
d146 1
a146 1
   GL_QUAD_STRIP,
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d32 3
a34 3
#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"
a49 1
   struct intel_context *intel = &brw->intel;
d57 1
d62 1
a62 6

   if (intel->gen >= 5)
       c.nr_regs = (c.nr_attrs + 1) / 2 + 3;  /* are vertices packed, or reg-aligned? */
   else
       c.nr_regs = (c.nr_attrs + 1) / 2 + 1;  /* are vertices packed, or reg-aligned? */

d68 1
a68 1
   brw_init_compile(brw, &c.func);
a80 7

   /* Gen6: VF has already converted into polygon, and LINELOOP is
    * converted to LINESTRIP at the beginning of the 3D pipeline.
    */
   if (intel->gen == 6)
      return;

d83 1
a83 1
      brw_gs_quads( &c, key );
d86 1
a86 1
      brw_gs_quad_strip( &c, key );
d91 21
d120 10
a129 2
   if (unlikely(INTEL_DEBUG & DEBUG_GS)) {
      int i;
a130 6
      printf("gs:\n");
      for (i = 0; i < program_size / sizeof(struct brw_instruction); i++)
	 brw_disasm(stdout, &((struct brw_instruction *)program)[i],
		    intel->gen);
      printf("\n");
    }
d132 7
a138 10
   /* Upload
    */
   drm_intel_bo_unreference(brw->gs.prog_bo);
   brw->gs.prog_bo = brw_upload_cache_with_auxdata(&brw->cache, BRW_GS_PROG,
						   &c.key, sizeof(c.key),
						   NULL, 0,
						   program, program_size,
						   &c.prog_data,
						   sizeof(c.prog_data),
						   &brw->gs.prog_data);
d141 1
a157 3
   struct gl_context *ctx = &brw->intel.ctx;
   struct intel_context *intel = &brw->intel;

d166 1
a166 8
   /* _NEW_LIGHT */
   key->pv_first = (ctx->Light.ProvokingVertex == GL_FIRST_VERTEX_CONVENTION);
   if (key->primitive == GL_QUADS && ctx->Light.ShadeModel != GL_FLAT) {
      /* Provide consistent primitive order with brw_set_prim's
       * optimization of single quads to trifans.
       */
      key->pv_first = GL_TRUE;
   }
d168 4
a171 5
   key->need_gs_prog = (intel->gen == 6)
      ? 0
      : (brw->primitive == GL_QUADS ||
	 brw->primitive == GL_QUAD_STRIP ||
	 brw->primitive == GL_LINE_LOOP);
d176 1
a176 1
static void prepare_gs_prog(struct brw_context *brw)
d179 1
a188 3
   drm_intel_bo_unreference(brw->gs.prog_bo);
   brw->gs.prog_bo = NULL;

d190 1
a190 5
      brw->gs.prog_bo = brw_search_cache(&brw->cache, BRW_GS_PROG,
					 &key, sizeof(key),
					 NULL, 0,
					 &brw->gs.prog_data);
      if (brw->gs.prog_bo == NULL)
d198 1
a198 1
      .mesa  = _NEW_LIGHT,
d202 1
a202 1
   .prepare = prepare_gs_prog
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@a34 1
#include "main/transformfeedback.h"
d45 1
a45 1
#include "glsl/ralloc.h"
d50 1
a52 1
   void *mem_ctx;
d58 11
a68 2
   c.vue_map = brw->vs.prog_data->base.vue_map;
   c.nr_regs = (c.vue_map.num_slots + 1)/2;
a69 1
   mem_ctx = ralloc_context(NULL);
d73 1
a73 1
   brw_init_compile(brw, &c.func, mem_ctx);
d82 23
a104 54
   if (brw->gen >= 6) {
      unsigned num_verts;
      bool check_edge_flag;
      /* On Sandybridge, we use the GS for implementing transform feedback
       * (called "Stream Out" in the PRM).
       */
      switch (key->primitive) {
      case _3DPRIM_POINTLIST:
         num_verts = 1;
         check_edge_flag = false;
	 break;
      case _3DPRIM_LINELIST:
      case _3DPRIM_LINESTRIP:
      case _3DPRIM_LINELOOP:
         num_verts = 2;
         check_edge_flag = false;
	 break;
      case _3DPRIM_TRILIST:
      case _3DPRIM_TRIFAN:
      case _3DPRIM_TRISTRIP:
      case _3DPRIM_RECTLIST:
	 num_verts = 3;
         check_edge_flag = false;
         break;
      case _3DPRIM_QUADLIST:
      case _3DPRIM_QUADSTRIP:
      case _3DPRIM_POLYGON:
         num_verts = 3;
         check_edge_flag = true;
         break;
      default:
	 assert(!"Unexpected primitive type in Gen6 SOL program.");
	 return;
      }
      gen6_sol_program(&c, key, num_verts, check_edge_flag);
   } else {
      /* On Gen4-5, we use the GS to decompose certain types of primitives.
       * Note that primitives which don't require a GS program have already
       * been weeded out by now.
       */
      switch (key->primitive) {
      case _3DPRIM_QUADLIST:
	 brw_gs_quads( &c, key );
	 break;
      case _3DPRIM_QUADSTRIP:
	 brw_gs_quad_strip( &c, key );
	 break;
      case _3DPRIM_LINELOOP:
	 brw_gs_lines( &c );
	 break;
      default:
	 ralloc_free(mem_ctx);
	 return;
      }
d117 1
a117 1
		    brw->gen);
d121 10
a130 6
   brw_upload_cache(&brw->cache, BRW_GS_PROG,
		    &c.key, sizeof(c.key),
		    program, program_size,
		    &c.prog_data, sizeof(c.prog_data),
		    &brw->gs.prog_offset, &brw->gs.prog_data);
   ralloc_free(mem_ctx);
d133 13
d149 2
a150 8
   static const unsigned swizzle_for_offset[4] = {
      BRW_SWIZZLE4(0, 1, 2, 3),
      BRW_SWIZZLE4(1, 2, 3, 3),
      BRW_SWIZZLE4(2, 3, 3, 3),
      BRW_SWIZZLE4(3, 3, 3, 3)
   };

   struct gl_context *ctx = &brw->ctx;
d154 2
a155 2
   /* CACHE_NEW_VS_PROG (part of VUE map) */
   key->attrs = brw->vs.prog_data->base.vue_map.slots_valid;
d158 1
a158 1
   key->primitive = brw->primitive;
d162 1
a162 1
   if (key->primitive == _3DPRIM_QUADLIST && ctx->Light.ShadeModel != GL_FLAT) {
d166 1
a166 1
      key->pv_first = true;
d169 5
a173 41
   if (brw->gen >= 7) {
      /* On Gen7 and later, we don't use GS (yet). */
      key->need_gs_prog = false;
   } else if (brw->gen == 6) {
      /* On Gen6, GS is used for transform feedback. */
      /* BRW_NEW_TRANSFORM_FEEDBACK */
      if (_mesa_is_xfb_active_and_unpaused(ctx)) {
         const struct gl_shader_program *shaderprog =
            ctx->Shader.CurrentVertexProgram;
         const struct gl_transform_feedback_info *linked_xfb_info =
            &shaderprog->LinkedTransformFeedback;
         int i;

         /* Make sure that the VUE slots won't overflow the unsigned chars in
          * key->transform_feedback_bindings[].
          */
         STATIC_ASSERT(BRW_VARYING_SLOT_COUNT <= 256);

         /* Make sure that we don't need more binding table entries than we've
          * set aside for use in transform feedback.  (We shouldn't, since we
          * set aside enough binding table entries to have one per component).
          */
         assert(linked_xfb_info->NumOutputs <= BRW_MAX_SOL_BINDINGS);

         key->need_gs_prog = true;
         key->num_transform_feedback_bindings = linked_xfb_info->NumOutputs;
         for (i = 0; i < key->num_transform_feedback_bindings; ++i) {
            key->transform_feedback_bindings[i] =
               linked_xfb_info->Outputs[i].OutputRegister;
            key->transform_feedback_swizzles[i] =
               swizzle_for_offset[linked_xfb_info->Outputs[i].ComponentOffset];
         }
      }
   } else {
      /* Pre-gen6, GS is used to transform QUADLIST, QUADSTRIP, and LINELOOP
       * into simpler primitives.
       */
      key->need_gs_prog = (brw->primitive == _3DPRIM_QUADLIST ||
                           brw->primitive == _3DPRIM_QUADSTRIP ||
                           brw->primitive == _3DPRIM_LINELOOP);
   }
d178 1
a178 2
static void
brw_upload_gs_prog(struct brw_context *brw)
d190 3
d194 5
a198 3
      if (!brw_search_cache(&brw->cache, BRW_GS_PROG,
			    &key, sizeof(key),
			    &brw->gs.prog_offset, &brw->gs.prog_data)) {
a199 1
      }
d206 2
a207 3
      .mesa  = (_NEW_LIGHT),
      .brw   = (BRW_NEW_PRIMITIVE |
                BRW_NEW_TRANSFORM_FEEDBACK),
d210 1
a210 1
   .emit = brw_upload_gs_prog
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics to
d5 1
a5 1

d13 1
a13 1

d17 1
a17 1

d25 1
a25 1

d29 1
a29 1
  *   Keith Whitwell <keithw@@vmware.com>
d31 1
a31 1

d48 2
a49 2
static void compile_ff_gs_prog(struct brw_context *brw,
                               struct brw_ff_gs_prog_key *key)
d51 1
a51 1
   struct brw_ff_gs_compile c;
d57 1
a57 1

d63 1
a63 1

d71 1
a71 1
    * unmasked.
d117 1
a117 1
	 brw_ff_gs_quads( &c, key );
d120 1
a120 1
	 brw_ff_gs_quad_strip( &c, key );
d123 1
a123 1
	 brw_ff_gs_lines( &c );
d138 1
a138 1
      fprintf(stderr, "gs:\n");
d140 1
a140 1
	 brw_disasm(stderr, &((struct brw_instruction *)program)[i],
d142 1
a142 1
      fprintf(stderr, "\n");
d145 1
a145 1
   brw_upload_cache(&brw->cache, BRW_FF_GS_PROG,
d149 1
a149 1
		    &brw->ff_gs.prog_offset, &brw->ff_gs.prog_data);
d153 2
a154 2
static void populate_key(struct brw_context *brw,
                         struct brw_ff_gs_prog_key *key)
d190 1
a190 1
            ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX];
d228 1
a228 1
brw_upload_ff_gs_prog(struct brw_context *brw)
d230 1
a230 1
   struct brw_ff_gs_prog_key key;
d235 3
a237 3
   if (brw->ff_gs.prog_active != key.need_gs_prog) {
      brw->state.dirty.cache |= CACHE_NEW_FF_GS_PROG;
      brw->ff_gs.prog_active = key.need_gs_prog;
d240 2
a241 2
   if (brw->ff_gs.prog_active) {
      if (!brw_search_cache(&brw->cache, BRW_FF_GS_PROG,
d243 2
a244 2
			    &brw->ff_gs.prog_offset, &brw->ff_gs.prog_data)) {
	 compile_ff_gs_prog( brw, &key );
d250 1
a250 1
const struct brw_tracked_state brw_ff_gs_prog = {
d257 1
a257 1
   .emit = brw_upload_ff_gs_prog
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@d2 34
a35 21
 * Copyright © 2013 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
d37 1
a37 5
/**
 * \file brw_vec4_gs.c
 *
 * State atom for client-programmable geometry shaders, and support code.
 */
d39 1
a39 1
#include "brw_gs.h"
d41 2
a42 1
#include "brw_vec4_gs_visitor.h"
d44 1
a44 1
#include "brw_ff_gs.h"
d46 1
d48 2
a49 5
static bool
do_gs_prog(struct brw_context *brw,
           struct gl_shader_program *prog,
           struct brw_geometry_program *gp,
           struct brw_gs_prog_key *key)
d51 5
a55 2
   struct brw_stage_state *stage_state = &brw->gs.base;
   struct brw_gs_compile c;
d57 1
d59 2
a60 4
   c.gp = gp;

   c.prog_data.include_primitive_id =
      (gp->program.Base.InputsRead & VARYING_BIT_PRIMITIVE_ID) != 0;
d62 1
a62 1
   c.prog_data.invocations = gp->program.Invocations;
d64 1
a64 7
   /* Allocate the references to the uniforms that will end up in the
    * prog_data associated with the compiled program, and which will be freed
    * by the state cache.
    *
    * Note: param_count needs to be num_uniform_components * 4, since we add
    * padding around uniform values below vec4 size, so the worst case is that
    * every uniform is a float which gets padded to the size of a vec4.
d66 1
a66 2
   struct gl_shader *gs = prog->_LinkedShaders[MESA_SHADER_GEOMETRY];
   int param_count = gs->num_uniform_components * 4;
d68 1
a68 2
   /* We also upload clip plane data as uniforms */
   param_count += MAX_CLIP_PLANES * 4;
d70 2
a71 7
   c.prog_data.base.base.param =
      rzalloc_array(NULL, const gl_constant_value *, param_count);
   c.prog_data.base.base.pull_param =
      rzalloc_array(NULL, const gl_constant_value *, param_count);
   /* Setting nr_params here NOT to the size of the param and pull_param
    * arrays, but to the number of uniform components vec4_visitor
    * needs. vec4_visitor::setup_uniforms() will set it back to a proper value.
d73 1
a73 1
   c.prog_data.base.base.nr_params = ALIGN(param_count, 4) / 4 + gs->num_samplers;
d75 33
a107 26
   if (brw->gen >= 7) {
      if (gp->program.OutputType == GL_POINTS) {
         /* When the output type is points, the geometry shader may output data
          * to multiple streams, and EndPrimitive() has no effect.  So we
          * configure the hardware to interpret the control data as stream ID.
          */
         c.prog_data.control_data_format = GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_SID;

         /* We only have to emit control bits if we are using streams */
         if (prog->Geom.UsesStreams)
            c.control_data_bits_per_vertex = 2;
         else
            c.control_data_bits_per_vertex = 0;
      } else {
         /* When the output type is triangle_strip or line_strip, EndPrimitive()
          * may be used to terminate the current strip and start a new one
          * (similar to primitive restart), and outputting data to multiple
          * streams is not supported.  So we configure the hardware to interpret
          * the control data as EndPrimitive information (a.k.a. "cut bits").
          */
         c.prog_data.control_data_format = GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_CUT;

         /* We only need to output control data if the shader actually calls
          * EndPrimitive().
          */
         c.control_data_bits_per_vertex = gp->program.UsesEndPrimitive ? 1 : 0;
d109 1
d111 18
a128 8
      /* There are no control data bits in gen6. */
      c.control_data_bits_per_vertex = 0;

      /* If it is using transform feedback, enable it */
      if (prog->TransformFeedback.NumVarying)
         c.prog_data.gen6_xfb_enabled = true;
      else
         c.prog_data.gen6_xfb_enabled = false;
a129 2
   c.control_data_header_size_bits =
      gp->program.VerticesOut * c.control_data_bits_per_vertex;
d131 1
a131 9
   /* 1 HWORD = 32 bytes = 256 bits */
   c.prog_data.control_data_header_size_hwords =
      ALIGN(c.control_data_header_size_bits, 256) / 256;

   GLbitfield64 outputs_written = gp->program.Base.OutputsWritten;

   /* In order for legacy clipping to work, we need to populate the clip
    * distance varying slots whenever clipping is enabled, even if the vertex
    * shader doesn't write to gl_ClipDistance.
d133 1
a133 4
   if (c.key.base.userclip_active) {
      outputs_written |= BITFIELD64_BIT(VARYING_SLOT_CLIP_DIST0);
      outputs_written |= BITFIELD64_BIT(VARYING_SLOT_CLIP_DIST1);
   }
d135 2
a136 1
   brw_compute_vue_map(brw, &c.prog_data.base.vue_map, outputs_written);
d138 14
a151 94
   /* Compute the output vertex size.
    *
    * From the Ivy Bridge PRM, Vol2 Part1 7.2.1.1 STATE_GS - Output Vertex
    * Size (p168):
    *
    *     [0,62] indicating [1,63] 16B units
    *
    *     Specifies the size of each vertex stored in the GS output entry
    *     (following any Control Header data) as a number of 128-bit units
    *     (minus one).
    *
    *     Programming Restrictions: The vertex size must be programmed as a
    *     multiple of 32B units with the following exception: Rendering is
    *     disabled (as per SOL stage state) and the vertex size output by the
    *     GS thread is 16B.
    *
    *     If rendering is enabled (as per SOL state) the vertex size must be
    *     programmed as a multiple of 32B units. In other words, the only time
    *     software can program a vertex size with an odd number of 16B units
    *     is when rendering is disabled.
    *
    * Note: B=bytes in the above text.
    *
    * It doesn't seem worth the extra trouble to optimize the case where the
    * vertex size is 16B (especially since this would require special-casing
    * the GEN assembly that writes to the URB).  So we just set the vertex
    * size to a multiple of 32B (2 vec4's) in all cases.
    *
    * The maximum output vertex size is 62*16 = 992 bytes (31 hwords).  We
    * budget that as follows:
    *
    *   512 bytes for varyings (a varying component is 4 bytes and
    *             gl_MaxGeometryOutputComponents = 128)
    *    16 bytes overhead for VARYING_SLOT_PSIZ (each varying slot is 16
    *             bytes)
    *    16 bytes overhead for gl_Position (we allocate it a slot in the VUE
    *             even if it's not used)
    *    32 bytes overhead for gl_ClipDistance (we allocate it 2 VUE slots
    *             whenever clip planes are enabled, even if the shader doesn't
    *             write to gl_ClipDistance)
    *    16 bytes overhead since the VUE size must be a multiple of 32 bytes
    *             (see below)--this causes up to 1 VUE slot to be wasted
    *   400 bytes available for varying packing overhead
    *
    * Worst-case varying packing overhead is 3/4 of a varying slot (12 bytes)
    * per interpolation type, so this is plenty.
    *
    */
   unsigned output_vertex_size_bytes = c.prog_data.base.vue_map.num_slots * 16;
   assert(brw->gen == 6 ||
          output_vertex_size_bytes <= GEN7_MAX_GS_OUTPUT_VERTEX_SIZE_BYTES);
   c.prog_data.output_vertex_size_hwords =
      ALIGN(output_vertex_size_bytes, 32) / 32;

   /* Compute URB entry size.  The maximum allowed URB entry size is 32k.
    * That divides up as follows:
    *
    *     64 bytes for the control data header (cut indices or StreamID bits)
    *   4096 bytes for varyings (a varying component is 4 bytes and
    *              gl_MaxGeometryTotalOutputComponents = 1024)
    *   4096 bytes overhead for VARYING_SLOT_PSIZ (each varying slot is 16
    *              bytes/vertex and gl_MaxGeometryOutputVertices is 256)
    *   4096 bytes overhead for gl_Position (we allocate it a slot in the VUE
    *              even if it's not used)
    *   8192 bytes overhead for gl_ClipDistance (we allocate it 2 VUE slots
    *              whenever clip planes are enabled, even if the shader doesn't
    *              write to gl_ClipDistance)
    *   4096 bytes overhead since the VUE size must be a multiple of 32
    *              bytes (see above)--this causes up to 1 VUE slot to be wasted
    *   8128 bytes available for varying packing overhead
    *
    * Worst-case varying packing overhead is 3/4 of a varying slot per
    * interpolation type, which works out to 3072 bytes, so this would allow
    * us to accommodate 2 interpolation types without any danger of running
    * out of URB space.
    *
    * In practice, the risk of running out of URB space is very small, since
    * the above figures are all worst-case, and most of them scale with the
    * number of output vertices.  So we'll just calculate the amount of space
    * we need, and if it's too large, fail to compile.
    *
    * The above is for gen7+ where we have a single URB entry that will hold
    * all the output. In gen6, we will have to allocate URB entries for every
    * vertex we emit, so our URB entries only need to be large enough to hold
    * a single vertex. Also, gen6 does not have a control data header.
    */
   unsigned output_size_bytes;
   if (brw->gen >= 7) {
      output_size_bytes =
         c.prog_data.output_vertex_size_hwords * 32 * gp->program.VerticesOut;
      output_size_bytes += 32 * c.prog_data.control_data_header_size_hwords;
   } else {
      output_size_bytes = c.prog_data.output_vertex_size_hwords * 32;
   }
d153 9
a161 5
   /* Broadwell stores "Vertex Count" as a full 8 DWord (32 byte) URB output,
    * which comes before the control header.
    */
   if (brw->gen >= 8)
      output_size_bytes += 32;
d163 1
a163 6
   assert(output_size_bytes >= 1);
   int max_output_size_bytes = GEN7_MAX_GS_URB_ENTRY_SIZE_BYTES;
   if (brw->gen == 6)
      max_output_size_bytes = GEN6_MAX_GS_URB_ENTRY_SIZE_BYTES;
   if (output_size_bytes > max_output_size_bytes)
      return false;
d165 1
d167 2
a168 7
   /* URB entry sizes are stored as a multiple of 64 bytes in gen7+ and
    * a multiple of 128 bytes in gen6.
    */
   if (brw->gen >= 7)
      c.prog_data.base.urb_entry_size = ALIGN(output_size_bytes, 64) / 64;
   else
      c.prog_data.base.urb_entry_size = ALIGN(output_size_bytes, 128) / 128;
d170 2
a171 2
   c.prog_data.output_topology =
      get_hw_prim_for_gl_prim(gp->program.OutputType);
d173 7
a179 14
   brw_compute_vue_map(brw, &c.input_vue_map, c.key.input_varyings);

   /* GS inputs are read from the VUE 256 bits (2 vec4's) at a time, so we
    * need to program a URB read length of ceiling(num_slots / 2).
    */
   c.prog_data.base.urb_read_length = (c.input_vue_map.num_slots + 1) / 2;

   void *mem_ctx = ralloc_context(NULL);
   unsigned program_size;
   const unsigned *program =
      brw_gs_emit(brw, prog, &c, mem_ctx, &program_size);
   if (program == NULL) {
      ralloc_free(mem_ctx);
      return false;
d182 12
a193 13
   /* Scratch space is used for register spilling */
   if (c.base.last_scratch) {
      perf_debug("Geometry shader triggered register spilling.  "
                 "Try reducing the number of live vec4 values to "
                 "improve performance.\n");

      c.prog_data.base.base.total_scratch
         = brw_get_scratch_size(c.base.last_scratch*REG_SIZE);

      brw_get_scratch_bo(brw, &stage_state->scratch_bo,
			 c.prog_data.base.base.total_scratch *
                         brw->max_gs_threads);
   }
d195 4
a198 6
   brw_upload_cache(&brw->cache, BRW_GS_PROG,
                    &c.key, sizeof(c.key),
                    program, program_size,
                    &c.prog_data, sizeof(c.prog_data),
                    &stage_state->prog_offset, &brw->gs.prog_data);
   ralloc_free(mem_ctx);
d200 5
a204 20
   return true;
}


static void
brw_upload_gs_prog(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   struct brw_stage_state *stage_state = &brw->gs.base;
   struct brw_gs_prog_key key;
   /* BRW_NEW_GEOMETRY_PROGRAM */
   struct brw_geometry_program *gp =
      (struct brw_geometry_program *) brw->geometry_program;

   if (gp == NULL) {
      /* No geometry shader.  Vertex data just passes straight through. */
      if (brw->state.dirty.brw & BRW_NEW_VUE_MAP_VS) {
         brw->vue_map_geom_out = brw->vue_map_vs;
         brw->state.dirty.brw |= BRW_NEW_VUE_MAP_GEOM_OUT;
      }
d206 8
a213 4
      if (brw->gen == 6 &&
          (brw->state.dirty.brw & BRW_NEW_TRANSFORM_FEEDBACK)) {
         gen6_brw_upload_ff_gs_prog(brw);
         return;
d215 3
a217 3

      /* Other state atoms had better not try to access prog_data, since
       * there's no GS program.
d219 3
a221 4
      brw->gs.prog_data = NULL;
      brw->gs.base.prog_data = NULL;

      return;
d223 1
d225 9
a233 1
   struct gl_program *prog = &gp->program.Base;
d235 3
a237 24
   memset(&key, 0, sizeof(key));

   key.base.program_string_id = gp->id;
   brw_setup_vec4_key_clip_info(brw, &key.base,
                                gp->program.Base.UsesClipDistanceOut);

   /* _NEW_LIGHT | _NEW_BUFFERS */
   key.base.clamp_vertex_color = ctx->Light._ClampVertexColor;

   /* _NEW_TEXTURE */
   brw_populate_sampler_prog_key_data(ctx, prog, stage_state->sampler_count,
                                      &key.base.tex);

   /* BRW_NEW_VUE_MAP_VS */
   key.input_varyings = brw->vue_map_vs.slots_valid;

   if (!brw_search_cache(&brw->cache, BRW_GS_PROG,
                         &key, sizeof(key),
                         &stage_state->prog_offset, &brw->gs.prog_data)) {
      bool success =
         do_gs_prog(brw, ctx->_Shader->CurrentProgram[MESA_SHADER_GEOMETRY], gp,
                    &key);
      assert(success);
      (void)success;
a238 1
   brw->gs.base.prog_data = &brw->gs.prog_data->base.base;
d240 6
a245 4
   if (memcmp(&brw->vs.prog_data->base.vue_map, &brw->vue_map_geom_out,
              sizeof(brw->vue_map_geom_out)) != 0) {
      brw->vue_map_geom_out = brw->gs.prog_data->base.vue_map;
      brw->state.dirty.brw |= BRW_NEW_VUE_MAP_GEOM_OUT;
d250 1
a250 1
const struct brw_tracked_state brw_gs_prog = {
d252 2
a253 3
      .mesa  = (_NEW_LIGHT | _NEW_BUFFERS | _NEW_TEXTURE),
      .brw   = (BRW_NEW_GEOMETRY_PROGRAM |
                BRW_NEW_VUE_MAP_VS |
d255 1
d257 1
a257 1
   .emit = brw_upload_gs_prog
a258 55


bool
brw_gs_precompile(struct gl_context *ctx, struct gl_shader_program *prog)
{
   struct brw_context *brw = brw_context(ctx);
   struct brw_gs_prog_key key;
   uint32_t old_prog_offset = brw->gs.base.prog_offset;
   struct brw_gs_prog_data *old_prog_data = brw->gs.prog_data;
   bool success;

   if (!prog->_LinkedShaders[MESA_SHADER_GEOMETRY])
      return true;

   struct gl_geometry_program *gp = (struct gl_geometry_program *)
      prog->_LinkedShaders[MESA_SHADER_GEOMETRY]->Program;
   struct brw_geometry_program *bgp = brw_geometry_program(gp);

   memset(&key, 0, sizeof(key));

   brw_vec4_setup_prog_key_for_precompile(ctx, &key.base, bgp->id, &gp->Base);

   /* Assume that the set of varyings coming in from the vertex shader exactly
    * matches what the geometry shader requires.
    */
   key.input_varyings = gp->Base.InputsRead;

   success = do_gs_prog(brw, prog, bgp, &key);

   brw->gs.base.prog_offset = old_prog_offset;
   brw->gs.prog_data = old_prog_data;

   return success;
}


bool
brw_gs_prog_data_compare(const void *in_a, const void *in_b)
{
   const struct brw_gs_prog_data *a = in_a;
   const struct brw_gs_prog_data *b = in_b;

   /* Compare the base structure. */
   if (!brw_stage_prog_data_compare(&a->base.base, &b->base.base))
      return false;

   /* Compare the rest of the struct. */
   const unsigned offset = sizeof(struct brw_stage_prog_data);
   if (memcmp(((char *) a) + offset, ((char *) b) + offset,
              sizeof(struct brw_gs_prog_data) - offset)) {
      return false;
   }

   return true;
}
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d2 21
a22 34
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics to
 develop this 3D driver.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */

#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"
#include "main/transformfeedback.h"
d24 5
a28 1
#include "intel_batchbuffer.h"
d30 1
a30 1
#include "brw_defines.h"
d32 1
a32 2
#include "brw_eu.h"
#include "brw_util.h"
d34 1
a34 1
#include "brw_gs.h"
a35 1
#include "glsl/ralloc.h"
d37 5
a41 2
static void compile_ff_gs_prog(struct brw_context *brw,
                               struct brw_ff_gs_prog_key *key)
d43 2
a44 5
   struct brw_ff_gs_compile c;
   const GLuint *program;
   void *mem_ctx;
   GLuint program_size;

d46 2
d49 2
a50 3
   c.key = *key;
   c.vue_map = brw->vs.prog_data->base.vue_map;
   c.nr_regs = (c.vue_map.num_slots + 1)/2;
d52 1
a52 1
   mem_ctx = ralloc_context(NULL);
d54 7
a60 1
   /* Begin the compilation:
d62 2
a63 1
   brw_init_compile(brw, &c.func, mem_ctx);
d65 2
a66 1
   c.func.single_program_flow = 1;
d68 7
a74 2
   /* For some reason the thread is spawned with only 4 channels
    * unmasked.
d76 9
a84 1
   brw_set_mask_control(&c.func, BRW_MASK_DISABLE);
d86 18
a103 33
   if (brw->gen >= 6) {
      unsigned num_verts;
      bool check_edge_flag;
      /* On Sandybridge, we use the GS for implementing transform feedback
       * (called "Stream Out" in the PRM).
       */
      switch (key->primitive) {
      case _3DPRIM_POINTLIST:
         num_verts = 1;
         check_edge_flag = false;
	 break;
      case _3DPRIM_LINELIST:
      case _3DPRIM_LINESTRIP:
      case _3DPRIM_LINELOOP:
         num_verts = 2;
         check_edge_flag = false;
	 break;
      case _3DPRIM_TRILIST:
      case _3DPRIM_TRIFAN:
      case _3DPRIM_TRISTRIP:
      case _3DPRIM_RECTLIST:
	 num_verts = 3;
         check_edge_flag = false;
         break;
      case _3DPRIM_QUADLIST:
      case _3DPRIM_QUADSTRIP:
      case _3DPRIM_POLYGON:
         num_verts = 3;
         check_edge_flag = true;
         break;
      default:
	 assert(!"Unexpected primitive type in Gen6 SOL program.");
	 return;
a104 1
      gen6_sol_program(&c, key, num_verts, check_edge_flag);
d106 122
a227 18
      /* On Gen4-5, we use the GS to decompose certain types of primitives.
       * Note that primitives which don't require a GS program have already
       * been weeded out by now.
       */
      switch (key->primitive) {
      case _3DPRIM_QUADLIST:
	 brw_ff_gs_quads( &c, key );
	 break;
      case _3DPRIM_QUADSTRIP:
	 brw_ff_gs_quad_strip( &c, key );
	 break;
      case _3DPRIM_LINELOOP:
	 brw_ff_gs_lines( &c );
	 break;
      default:
	 ralloc_free(mem_ctx);
	 return;
      }
d230 2
a231 1
   /* get the program
d233 2
a234 1
   program = brw_get_program(&c.func, &program_size);
d236 6
a241 2
   if (unlikely(INTEL_DEBUG & DEBUG_GS)) {
      int i;
a242 14
      fprintf(stderr, "gs:\n");
      for (i = 0; i < program_size / sizeof(struct brw_instruction); i++)
	 brw_disasm(stderr, &((struct brw_instruction *)program)[i],
		    brw->gen);
      fprintf(stderr, "\n");
    }

   brw_upload_cache(&brw->cache, BRW_FF_GS_PROG,
		    &c.key, sizeof(c.key),
		    program, program_size,
		    &c.prog_data, sizeof(c.prog_data),
		    &brw->ff_gs.prog_offset, &brw->ff_gs.prog_data);
   ralloc_free(mem_ctx);
}
d244 7
a250 9
static void populate_key(struct brw_context *brw,
                         struct brw_ff_gs_prog_key *key)
{
   static const unsigned swizzle_for_offset[4] = {
      BRW_SWIZZLE4(0, 1, 2, 3),
      BRW_SWIZZLE4(1, 2, 3, 3),
      BRW_SWIZZLE4(2, 3, 3, 3),
      BRW_SWIZZLE4(3, 3, 3, 3)
   };
d252 2
a253 1
   struct gl_context *ctx = &brw->ctx;
d255 1
a255 1
   memset(key, 0, sizeof(*key));
d257 4
a260 2
   /* CACHE_NEW_VS_PROG (part of VUE map) */
   key->attrs = brw->vs.prog_data->base.vue_map.slots_valid;
d262 8
a269 2
   /* BRW_NEW_PRIMITIVE */
   key->primitive = brw->primitive;
d271 12
a282 7
   /* _NEW_LIGHT */
   key->pv_first = (ctx->Light.ProvokingVertex == GL_FIRST_VERTEX_CONVENTION);
   if (key->primitive == _3DPRIM_QUADLIST && ctx->Light.ShadeModel != GL_FLAT) {
      /* Provide consistent primitive order with brw_set_prim's
       * optimization of single quads to trifans.
       */
      key->pv_first = true;
d285 9
a293 12
   if (brw->gen >= 7) {
      /* On Gen7 and later, we don't use GS (yet). */
      key->need_gs_prog = false;
   } else if (brw->gen == 6) {
      /* On Gen6, GS is used for transform feedback. */
      /* BRW_NEW_TRANSFORM_FEEDBACK */
      if (_mesa_is_xfb_active_and_unpaused(ctx)) {
         const struct gl_shader_program *shaderprog =
            ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX];
         const struct gl_transform_feedback_info *linked_xfb_info =
            &shaderprog->LinkedTransformFeedback;
         int i;
a294 4
         /* Make sure that the VUE slots won't overflow the unsigned chars in
          * key->transform_feedback_bindings[].
          */
         STATIC_ASSERT(BRW_VARYING_SLOT_COUNT <= 256);
d296 16
a311 5
         /* Make sure that we don't need more binding table entries than we've
          * set aside for use in transform feedback.  (We shouldn't, since we
          * set aside enough binding table entries to have one per component).
          */
         assert(linked_xfb_info->NumOutputs <= BRW_MAX_SOL_BINDINGS);
d313 4
a316 8
         key->need_gs_prog = true;
         key->num_transform_feedback_bindings = linked_xfb_info->NumOutputs;
         for (i = 0; i < key->num_transform_feedback_bindings; ++i) {
            key->transform_feedback_bindings[i] =
               linked_xfb_info->Outputs[i].OutputRegister;
            key->transform_feedback_swizzles[i] =
               swizzle_for_offset[linked_xfb_info->Outputs[i].ComponentOffset];
         }
d318 3
a320 3
   } else {
      /* Pre-gen6, GS is used to transform QUADLIST, QUADSTRIP, and LINELOOP
       * into simpler primitives.
d322 4
a325 3
      key->need_gs_prog = (brw->primitive == _3DPRIM_QUADLIST ||
                           brw->primitive == _3DPRIM_QUADSTRIP ||
                           brw->primitive == _3DPRIM_LINELOOP);
a326 1
}
d328 3
a330 9
/* Calculate interpolants for triangle and line rasterization.
 */
static void
brw_upload_ff_gs_prog(struct brw_context *brw)
{
   struct brw_ff_gs_prog_key key;
   /* Populate the key:
    */
   populate_key(brw, &key);
d332 22
a353 3
   if (brw->ff_gs.prog_active != key.need_gs_prog) {
      brw->state.dirty.cache |= CACHE_NEW_FF_GS_PROG;
      brw->ff_gs.prog_active = key.need_gs_prog;
d355 1
d357 4
a360 6
   if (brw->ff_gs.prog_active) {
      if (!brw_search_cache(&brw->cache, BRW_FF_GS_PROG,
			    &key, sizeof(key),
			    &brw->ff_gs.prog_offset, &brw->ff_gs.prog_data)) {
	 compile_ff_gs_prog( brw, &key );
      }
d365 1
a365 1
const struct brw_tracked_state brw_ff_gs_prog = {
d367 3
a369 2
      .mesa  = (_NEW_LIGHT),
      .brw   = (BRW_NEW_PRIMITIVE |
a370 1
      .cache = CACHE_NEW_VS_PROG
d372 1
a372 1
   .emit = brw_upload_ff_gs_prog
d374 55
@


