head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@// @;


1.9
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.09.07.15.20.07;	author jsg;	state Exp;
branches;
next	1.5;
commitid	7kimTMT4YlQauAIU;

1.5
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2014.01.19.03.13.15;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.05.09.53.58;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.09.05.14.04.19;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.15.35;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.10.05.09.25.19;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.01.19.03.04.26;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.50;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2014.09.07.15.06.09;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	dm8VnQHhowGHmemJ;

1.1.1.6
date	2015.01.25.14.11.40;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.48.46;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

/** @@file brw_fs_visitor.cpp
 *
 * This file supports generating the FS LIR from the GLSL IR.  The LIR
 * makes it easier to do backend-specific optimizations than doing so
 * in the GLSL IR or in the native code.
 */
extern "C" {

#include <sys/types.h>

#include "main/macros.h"
#include "main/shaderobj.h"
#include "program/prog_parameter.h"
#include "program/prog_print.h"
#include "program/prog_optimize.h"
#include "program/register_allocate.h"
#include "program/sampler.h"
#include "program/hash_table.h"
#include "brw_context.h"
#include "brw_eu.h"
#include "brw_wm.h"
}
#include "brw_fs.h"
#include "main/uniforms.h"
#include "glsl/glsl_types.h"
#include "glsl/ir_optimization.h"

void
fs_visitor::visit(ir_variable *ir)
{
   fs_reg *reg = NULL;

   if (variable_storage(ir))
      return;

   if (ir->data.mode == ir_var_shader_in) {
      if (!strcmp(ir->name, "gl_FragCoord")) {
	 reg = emit_fragcoord_interpolation(ir);
      } else if (!strcmp(ir->name, "gl_FrontFacing")) {
	 reg = emit_frontfacing_interpolation(ir);
      } else {
	 reg = emit_general_interpolation(ir);
      }
      assert(reg);
      hash_table_insert(this->variable_ht, reg, ir);
      return;
   } else if (ir->data.mode == ir_var_shader_out) {
      reg = new(this->mem_ctx) fs_reg(this, ir->type);

      if (ir->data.index > 0) {
	 assert(ir->data.location == FRAG_RESULT_DATA0);
	 assert(ir->data.index == 1);
	 this->dual_src_output = *reg;
         this->do_dual_src = true;
      } else if (ir->data.location == FRAG_RESULT_COLOR) {
	 /* Writing gl_FragColor outputs to all color regions. */
	 for (unsigned int i = 0; i < MAX2(c->key.nr_color_regions, 1); i++) {
	    this->outputs[i] = *reg;
	    this->output_components[i] = 4;
	 }
      } else if (ir->data.location == FRAG_RESULT_DEPTH) {
	 this->frag_depth = *reg;
      } else if (ir->data.location == FRAG_RESULT_SAMPLE_MASK) {
         this->sample_mask = *reg;
      } else {
	 /* gl_FragData or a user-defined FS output */
	 assert(ir->data.location >= FRAG_RESULT_DATA0 &&
		ir->data.location < FRAG_RESULT_DATA0 + BRW_MAX_DRAW_BUFFERS);

	 int vector_elements =
	    ir->type->is_array() ? ir->type->fields.array->vector_elements
				 : ir->type->vector_elements;

	 /* General color output. */
	 for (unsigned int i = 0; i < MAX2(1, ir->type->length); i++) {
	    int output = ir->data.location - FRAG_RESULT_DATA0 + i;
	    this->outputs[output] = *reg;
	    this->outputs[output].reg_offset += vector_elements * i;
	    this->output_components[output] = vector_elements;
	 }
      }
   } else if (ir->data.mode == ir_var_uniform) {
      int param_index = uniforms;

      /* Thanks to the lower_ubo_reference pass, we will see only
       * ir_binop_ubo_load expressions and not ir_dereference_variable for UBO
       * variables, so no need for them to be in variable_ht.
       *
       * Atomic counters take no uniform storage, no need to do
       * anything here.
       */
      if (ir->is_in_uniform_block() || ir->type->contains_atomic())
         return;

      if (dispatch_width == 16) {
	 if (!variable_storage(ir)) {
	    fail("Failed to find uniform '%s' in SIMD16\n", ir->name);
	 }
	 return;
      }

      param_size[param_index] = type_size(ir->type);
      if (!strncmp(ir->name, "gl_", 3)) {
	 setup_builtin_uniform_values(ir);
      } else {
	 setup_uniform_values(ir);
      }

      reg = new(this->mem_ctx) fs_reg(UNIFORM, param_index);
      reg->type = brw_type_for_base_type(ir->type);

   } else if (ir->data.mode == ir_var_system_value) {
      if (ir->data.location == SYSTEM_VALUE_SAMPLE_POS) {
	 reg = emit_samplepos_setup(ir);
      } else if (ir->data.location == SYSTEM_VALUE_SAMPLE_ID) {
	 reg = emit_sampleid_setup(ir);
      } else if (ir->data.location == SYSTEM_VALUE_SAMPLE_MASK_IN) {
         reg = emit_samplemaskin_setup(ir);
      }
   }

   if (!reg)
      reg = new(this->mem_ctx) fs_reg(this, ir->type);

   hash_table_insert(this->variable_ht, reg, ir);
}

void
fs_visitor::visit(ir_dereference_variable *ir)
{
   fs_reg *reg = variable_storage(ir->var);
   this->result = *reg;
}

void
fs_visitor::visit(ir_dereference_record *ir)
{
   const glsl_type *struct_type = ir->record->type;

   ir->record->accept(this);

   unsigned int offset = 0;
   for (unsigned int i = 0; i < struct_type->length; i++) {
      if (strcmp(struct_type->fields.structure[i].name, ir->field) == 0)
	 break;
      offset += type_size(struct_type->fields.structure[i].type);
   }
   this->result.reg_offset += offset;
   this->result.type = brw_type_for_base_type(ir->type);
}

void
fs_visitor::visit(ir_dereference_array *ir)
{
   ir_constant *constant_index;
   fs_reg src;
   int element_size = type_size(ir->type);

   constant_index = ir->array_index->as_constant();

   ir->array->accept(this);
   src = this->result;
   src.type = brw_type_for_base_type(ir->type);

   if (constant_index) {
      assert(src.file == UNIFORM || src.file == GRF);
      src.reg_offset += constant_index->value.i[0] * element_size;
   } else {
      /* Variable index array dereference.  We attach the variable index
       * component to the reg as a pointer to a register containing the
       * offset.  Currently only uniform arrays are supported in this patch,
       * and that reladdr pointer is resolved by
       * move_uniform_array_access_to_pull_constants().  All other array types
       * are lowered by lower_variable_index_to_cond_assign().
       */
      ir->array_index->accept(this);

      fs_reg index_reg;
      index_reg = fs_reg(this, glsl_type::int_type);
      emit(BRW_OPCODE_MUL, index_reg, this->result, fs_reg(element_size));

      if (src.reladdr) {
         emit(BRW_OPCODE_ADD, index_reg, *src.reladdr, index_reg);
      }

      src.reladdr = ralloc(mem_ctx, fs_reg);
      memcpy(src.reladdr, &index_reg, sizeof(index_reg));
   }
   this->result = src;
}

void
fs_visitor::emit_lrp(const fs_reg &dst, const fs_reg &x, const fs_reg &y,
                     const fs_reg &a)
{
   if (brw->gen < 6 ||
       !x.is_valid_3src() ||
       !y.is_valid_3src() ||
       !a.is_valid_3src()) {
      /* We can't use the LRP instruction.  Emit x*(1-a) + y*a. */
      fs_reg y_times_a           = fs_reg(this, glsl_type::float_type);
      fs_reg one_minus_a         = fs_reg(this, glsl_type::float_type);
      fs_reg x_times_one_minus_a = fs_reg(this, glsl_type::float_type);

      emit(MUL(y_times_a, y, a));

      fs_reg negative_a = a;
      negative_a.negate = !a.negate;
      emit(ADD(one_minus_a, negative_a, fs_reg(1.0f)));
      emit(MUL(x_times_one_minus_a, x, one_minus_a));

      emit(ADD(dst, x_times_one_minus_a, y_times_a));
   } else {
      /* The LRP instruction actually does op1 * op0 + op2 * (1 - op0), so
       * we need to reorder the operands.
       */
      emit(LRP(dst, a, y, x));
   }
}

void
fs_visitor::emit_minmax(uint32_t conditionalmod, const fs_reg &dst,
                        const fs_reg &src0, const fs_reg &src1)
{
   fs_inst *inst;

   if (brw->gen >= 6) {
      inst = emit(BRW_OPCODE_SEL, dst, src0, src1);
      inst->conditional_mod = conditionalmod;
   } else {
      emit(CMP(reg_null_d, src0, src1, conditionalmod));

      inst = emit(BRW_OPCODE_SEL, dst, src0, src1);
      inst->predicate = BRW_PREDICATE_NORMAL;
   }
}

/* Instruction selection: Produce a MOV.sat instead of
 * MIN(MAX(val, 0), 1) when possible.
 */
bool
fs_visitor::try_emit_saturate(ir_expression *ir)
{
   ir_rvalue *sat_val = ir->as_rvalue_to_saturate();

   if (!sat_val)
      return false;

   fs_inst *pre_inst = (fs_inst *) this->instructions.get_tail();

   sat_val->accept(this);
   fs_reg src = this->result;

   fs_inst *last_inst = (fs_inst *) this->instructions.get_tail();

   /* If the last instruction from our accept() didn't generate our
    * src, generate a saturated MOV
    */
   fs_inst *modify = get_instruction_generating_reg(pre_inst, last_inst, src);
   if (!modify || modify->regs_written != 1) {
      this->result = fs_reg(this, ir->type);
      fs_inst *inst = emit(MOV(this->result, src));
      inst->saturate = true;
   } else {
      modify->saturate = true;
      this->result = src;
   }


   return true;
}

bool
fs_visitor::try_emit_mad(ir_expression *ir)
{
   /* 3-src instructions were introduced in gen6. */
   if (brw->gen < 6)
      return false;

   /* MAD can only handle floating-point data. */
   if (ir->type != glsl_type::float_type)
      return false;

   ir_rvalue *nonmul = ir->operands[1];
   ir_expression *mul = ir->operands[0]->as_expression();

   if (!mul || mul->operation != ir_binop_mul) {
      nonmul = ir->operands[0];
      mul = ir->operands[1]->as_expression();

      if (!mul || mul->operation != ir_binop_mul)
         return false;
   }

   if (nonmul->as_constant() ||
       mul->operands[0]->as_constant() ||
       mul->operands[1]->as_constant())
      return false;

   nonmul->accept(this);
   fs_reg src0 = this->result;

   mul->operands[0]->accept(this);
   fs_reg src1 = this->result;

   mul->operands[1]->accept(this);
   fs_reg src2 = this->result;

   this->result = fs_reg(this, ir->type);
   emit(BRW_OPCODE_MAD, this->result, src0, src1, src2);

   return true;
}

void
fs_visitor::visit(ir_expression *ir)
{
   unsigned int operand;
   fs_reg op[3], temp;
   fs_inst *inst;

   assert(ir->get_num_operands() <= 3);

   if (try_emit_saturate(ir))
      return;
   if (ir->operation == ir_binop_add) {
      if (try_emit_mad(ir))
	 return;
   }

   for (operand = 0; operand < ir->get_num_operands(); operand++) {
      ir->operands[operand]->accept(this);
      if (this->result.file == BAD_FILE) {
	 fail("Failed to get tree for expression operand:\n");
	 ir->operands[operand]->fprint(stderr);
         fprintf(stderr, "\n");
      }
      assert(this->result.is_valid_3src());
      op[operand] = this->result;

      /* Matrix expression operands should have been broken down to vector
       * operations already.
       */
      assert(!ir->operands[operand]->type->is_matrix());
      /* And then those vector operands should have been broken down to scalar.
       */
      assert(!ir->operands[operand]->type->is_vector());
   }

   /* Storage for our result.  If our result goes into an assignment, it will
    * just get copy-propagated out, so no worries.
    */
   this->result = fs_reg(this, ir->type);

   switch (ir->operation) {
   case ir_unop_logic_not:
      /* Note that BRW_OPCODE_NOT is not appropriate here, since it is
       * ones complement of the whole register, not just bit 0.
       */
      emit(XOR(this->result, op[0], fs_reg(1)));
      break;
   case ir_unop_neg:
      op[0].negate = !op[0].negate;
      emit(MOV(this->result, op[0]));
      break;
   case ir_unop_abs:
      op[0].abs = true;
      op[0].negate = false;
      emit(MOV(this->result, op[0]));
      break;
   case ir_unop_sign:
      if (ir->type->is_float()) {
         /* AND(val, 0x80000000) gives the sign bit.
          *
          * Predicated OR ORs 1.0 (0x3f800000) with the sign bit if val is not
          * zero.
          */
         emit(CMP(reg_null_f, op[0], fs_reg(0.0f), BRW_CONDITIONAL_NZ));

         op[0].type = BRW_REGISTER_TYPE_UD;
         this->result.type = BRW_REGISTER_TYPE_UD;
         emit(AND(this->result, op[0], fs_reg(0x80000000u)));

         inst = emit(OR(this->result, this->result, fs_reg(0x3f800000u)));
         inst->predicate = BRW_PREDICATE_NORMAL;

         this->result.type = BRW_REGISTER_TYPE_F;
      } else {
         /*  ASR(val, 31) -> negative val generates 0xffffffff (signed -1).
          *               -> non-negative val generates 0x00000000.
          *  Predicated OR sets 1 if val is positive.
          */
         emit(CMP(reg_null_d, op[0], fs_reg(0), BRW_CONDITIONAL_G));

         emit(ASR(this->result, op[0], fs_reg(31)));

         inst = emit(OR(this->result, this->result, fs_reg(1)));
         inst->predicate = BRW_PREDICATE_NORMAL;
      }
      break;
   case ir_unop_rcp:
      emit_math(SHADER_OPCODE_RCP, this->result, op[0]);
      break;

   case ir_unop_exp2:
      emit_math(SHADER_OPCODE_EXP2, this->result, op[0]);
      break;
   case ir_unop_log2:
      emit_math(SHADER_OPCODE_LOG2, this->result, op[0]);
      break;
   case ir_unop_exp:
   case ir_unop_log:
      assert(!"not reached: should be handled by ir_explog_to_explog2");
      break;
   case ir_unop_sin:
   case ir_unop_sin_reduced:
      emit_math(SHADER_OPCODE_SIN, this->result, op[0]);
      break;
   case ir_unop_cos:
   case ir_unop_cos_reduced:
      emit_math(SHADER_OPCODE_COS, this->result, op[0]);
      break;

   case ir_unop_dFdx:
      emit(FS_OPCODE_DDX, this->result, op[0]);
      break;
   case ir_unop_dFdy:
      emit(FS_OPCODE_DDY, this->result, op[0]);
      break;

   case ir_binop_add:
      emit(ADD(this->result, op[0], op[1]));
      break;
   case ir_binop_sub:
      assert(!"not reached: should be handled by ir_sub_to_add_neg");
      break;

   case ir_binop_mul:
      if (brw->gen < 8 && ir->type->is_integer()) {
	 /* For integer multiplication, the MUL uses the low 16 bits
	  * of one of the operands (src0 on gen6, src1 on gen7).  The
	  * MACH accumulates in the contribution of the upper 16 bits
	  * of that operand.
          */
         if (ir->operands[0]->is_uint16_constant()) {
            if (brw->gen < 7)
               emit(MUL(this->result, op[0], op[1]));
            else
               emit(MUL(this->result, op[1], op[0]));
         } else if (ir->operands[1]->is_uint16_constant()) {
            if (brw->gen < 7)
               emit(MUL(this->result, op[1], op[0]));
            else
               emit(MUL(this->result, op[0], op[1]));
         } else {
            if (brw->gen >= 7)
               no16("SIMD16 explicit accumulator operands unsupported\n");

            struct brw_reg acc = retype(brw_acc_reg(), this->result.type);

            emit(MUL(acc, op[0], op[1]));
            emit(MACH(reg_null_d, op[0], op[1]));
            emit(MOV(this->result, fs_reg(acc)));
         }
      } else {
	 emit(MUL(this->result, op[0], op[1]));
      }
      break;
   case ir_binop_imul_high: {
      if (brw->gen >= 7)
         no16("SIMD16 explicit accumulator operands unsupported\n");

      struct brw_reg acc = retype(brw_acc_reg(), this->result.type);

      emit(MUL(acc, op[0], op[1]));
      emit(MACH(this->result, op[0], op[1]));
      break;
   }
   case ir_binop_div:
      /* Floating point should be lowered by DIV_TO_MUL_RCP in the compiler. */
      assert(ir->type->is_integer());
      emit_math(SHADER_OPCODE_INT_QUOTIENT, this->result, op[0], op[1]);
      break;
   case ir_binop_carry: {
      if (brw->gen >= 7)
         no16("SIMD16 explicit accumulator operands unsupported\n");

      struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_UD);

      emit(ADDC(reg_null_ud, op[0], op[1]));
      emit(MOV(this->result, fs_reg(acc)));
      break;
   }
   case ir_binop_borrow: {
      if (brw->gen >= 7)
         no16("SIMD16 explicit accumulator operands unsupported\n");

      struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_UD);

      emit(SUBB(reg_null_ud, op[0], op[1]));
      emit(MOV(this->result, fs_reg(acc)));
      break;
   }
   case ir_binop_mod:
      /* Floating point should be lowered by MOD_TO_FRACT in the compiler. */
      assert(ir->type->is_integer());
      emit_math(SHADER_OPCODE_INT_REMAINDER, this->result, op[0], op[1]);
      break;

   case ir_binop_less:
   case ir_binop_greater:
   case ir_binop_lequal:
   case ir_binop_gequal:
   case ir_binop_equal:
   case ir_binop_all_equal:
   case ir_binop_nequal:
   case ir_binop_any_nequal:
      resolve_bool_comparison(ir->operands[0], &op[0]);
      resolve_bool_comparison(ir->operands[1], &op[1]);

      emit(CMP(this->result, op[0], op[1],
               brw_conditional_for_comparison(ir->operation)));
      break;

   case ir_binop_logic_xor:
      emit(XOR(this->result, op[0], op[1]));
      break;

   case ir_binop_logic_or:
      emit(OR(this->result, op[0], op[1]));
      break;

   case ir_binop_logic_and:
      emit(AND(this->result, op[0], op[1]));
      break;

   case ir_binop_dot:
   case ir_unop_any:
      assert(!"not reached: should be handled by brw_fs_channel_expressions");
      break;

   case ir_unop_noise:
      assert(!"not reached: should be handled by lower_noise");
      break;

   case ir_quadop_vector:
      assert(!"not reached: should be handled by lower_quadop_vector");
      break;

   case ir_binop_vector_extract:
      assert(!"not reached: should be handled by lower_vec_index_to_cond_assign()");
      break;

   case ir_triop_vector_insert:
      assert(!"not reached: should be handled by lower_vector_insert()");
      break;

   case ir_binop_ldexp:
      assert(!"not reached: should be handled by ldexp_to_arith()");
      break;

   case ir_unop_sqrt:
      emit_math(SHADER_OPCODE_SQRT, this->result, op[0]);
      break;

   case ir_unop_rsq:
      emit_math(SHADER_OPCODE_RSQ, this->result, op[0]);
      break;

   case ir_unop_bitcast_i2f:
   case ir_unop_bitcast_u2f:
      op[0].type = BRW_REGISTER_TYPE_F;
      this->result = op[0];
      break;
   case ir_unop_i2u:
   case ir_unop_bitcast_f2u:
      op[0].type = BRW_REGISTER_TYPE_UD;
      this->result = op[0];
      break;
   case ir_unop_u2i:
   case ir_unop_bitcast_f2i:
      op[0].type = BRW_REGISTER_TYPE_D;
      this->result = op[0];
      break;
   case ir_unop_i2f:
   case ir_unop_u2f:
   case ir_unop_f2i:
   case ir_unop_f2u:
      emit(MOV(this->result, op[0]));
      break;

   case ir_unop_b2i:
      emit(AND(this->result, op[0], fs_reg(1)));
      break;
   case ir_unop_b2f:
      temp = fs_reg(this, glsl_type::int_type);
      emit(AND(temp, op[0], fs_reg(1)));
      emit(MOV(this->result, temp));
      break;

   case ir_unop_f2b:
      emit(CMP(this->result, op[0], fs_reg(0.0f), BRW_CONDITIONAL_NZ));
      break;
   case ir_unop_i2b:
      emit(CMP(this->result, op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
      break;

   case ir_unop_trunc:
      emit(RNDZ(this->result, op[0]));
      break;
   case ir_unop_ceil:
      op[0].negate = !op[0].negate;
      emit(RNDD(this->result, op[0]));
      this->result.negate = true;
      break;
   case ir_unop_floor:
      emit(RNDD(this->result, op[0]));
      break;
   case ir_unop_fract:
      emit(FRC(this->result, op[0]));
      break;
   case ir_unop_round_even:
      emit(RNDE(this->result, op[0]));
      break;

   case ir_binop_min:
   case ir_binop_max:
      resolve_ud_negate(&op[0]);
      resolve_ud_negate(&op[1]);
      emit_minmax(ir->operation == ir_binop_min ?
                  BRW_CONDITIONAL_L : BRW_CONDITIONAL_GE,
                  this->result, op[0], op[1]);
      break;
   case ir_unop_pack_snorm_2x16:
   case ir_unop_pack_snorm_4x8:
   case ir_unop_pack_unorm_2x16:
   case ir_unop_pack_unorm_4x8:
   case ir_unop_unpack_snorm_2x16:
   case ir_unop_unpack_snorm_4x8:
   case ir_unop_unpack_unorm_2x16:
   case ir_unop_unpack_unorm_4x8:
   case ir_unop_unpack_half_2x16:
   case ir_unop_pack_half_2x16:
      assert(!"not reached: should be handled by lower_packing_builtins");
      break;
   case ir_unop_unpack_half_2x16_split_x:
      emit(FS_OPCODE_UNPACK_HALF_2x16_SPLIT_X, this->result, op[0]);
      break;
   case ir_unop_unpack_half_2x16_split_y:
      emit(FS_OPCODE_UNPACK_HALF_2x16_SPLIT_Y, this->result, op[0]);
      break;
   case ir_binop_pow:
      emit_math(SHADER_OPCODE_POW, this->result, op[0], op[1]);
      break;

   case ir_unop_bitfield_reverse:
      emit(BFREV(this->result, op[0]));
      break;
   case ir_unop_bit_count:
      emit(CBIT(this->result, op[0]));
      break;
   case ir_unop_find_msb:
      temp = fs_reg(this, glsl_type::uint_type);
      emit(FBH(temp, op[0]));

      /* FBH counts from the MSB side, while GLSL's findMSB() wants the count
       * from the LSB side. If FBH didn't return an error (0xFFFFFFFF), then
       * subtract the result from 31 to convert the MSB count into an LSB count.
       */

      /* FBH only supports UD type for dst, so use a MOV to convert UD to D. */
      emit(MOV(this->result, temp));
      emit(CMP(reg_null_d, this->result, fs_reg(-1), BRW_CONDITIONAL_NZ));

      temp.negate = true;
      inst = emit(ADD(this->result, temp, fs_reg(31)));
      inst->predicate = BRW_PREDICATE_NORMAL;
      break;
   case ir_unop_find_lsb:
      emit(FBL(this->result, op[0]));
      break;
   case ir_triop_bitfield_extract:
      /* Note that the instruction's argument order is reversed from GLSL
       * and the IR.
       */
      emit(BFE(this->result, op[2], op[1], op[0]));
      break;
   case ir_binop_bfm:
      emit(BFI1(this->result, op[0], op[1]));
      break;
   case ir_triop_bfi:
      emit(BFI2(this->result, op[0], op[1], op[2]));
      break;
   case ir_quadop_bitfield_insert:
      assert(!"not reached: should be handled by "
              "lower_instructions::bitfield_insert_to_bfm_bfi");
      break;

   case ir_unop_bit_not:
      emit(NOT(this->result, op[0]));
      break;
   case ir_binop_bit_and:
      emit(AND(this->result, op[0], op[1]));
      break;
   case ir_binop_bit_xor:
      emit(XOR(this->result, op[0], op[1]));
      break;
   case ir_binop_bit_or:
      emit(OR(this->result, op[0], op[1]));
      break;

   case ir_binop_lshift:
      emit(SHL(this->result, op[0], op[1]));
      break;

   case ir_binop_rshift:
      if (ir->type->base_type == GLSL_TYPE_INT)
	 emit(ASR(this->result, op[0], op[1]));
      else
	 emit(SHR(this->result, op[0], op[1]));
      break;
   case ir_binop_pack_half_2x16_split:
      emit(FS_OPCODE_PACK_HALF_2x16_SPLIT, this->result, op[0], op[1]);
      break;
   case ir_binop_ubo_load: {
      /* This IR node takes a constant uniform block and a constant or
       * variable byte offset within the block and loads a vector from that.
       */
      ir_constant *uniform_block = ir->operands[0]->as_constant();
      ir_constant *const_offset = ir->operands[1]->as_constant();
      fs_reg surf_index = fs_reg(c->prog_data.base.binding_table.ubo_start +
                                 uniform_block->value.u[0]);
      if (const_offset) {
         fs_reg packed_consts = fs_reg(this, glsl_type::float_type);
         packed_consts.type = result.type;

         fs_reg const_offset_reg = fs_reg(const_offset->value.u[0] & ~15);
         emit(new(mem_ctx) fs_inst(FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD,
                                   packed_consts, surf_index, const_offset_reg));

         for (int i = 0; i < ir->type->vector_elements; i++) {
            packed_consts.set_smear(const_offset->value.u[0] % 16 / 4 + i);

            /* The std140 packing rules don't allow vectors to cross 16-byte
             * boundaries, and a reg is 32 bytes.
             */
            assert(packed_consts.subreg_offset < 32);

            /* UBO bools are any nonzero value.  We consider bools to be
             * values with the low bit set to 1.  Convert them using CMP.
             */
            if (ir->type->base_type == GLSL_TYPE_BOOL) {
               emit(CMP(result, packed_consts, fs_reg(0u), BRW_CONDITIONAL_NZ));
            } else {
               emit(MOV(result, packed_consts));
            }

            result.reg_offset++;
         }
      } else {
         /* Turn the byte offset into a dword offset. */
         fs_reg base_offset = fs_reg(this, glsl_type::int_type);
         emit(SHR(base_offset, op[1], fs_reg(2)));

         for (int i = 0; i < ir->type->vector_elements; i++) {
            emit(VARYING_PULL_CONSTANT_LOAD(result, surf_index,
                                            base_offset, i));

            if (ir->type->base_type == GLSL_TYPE_BOOL)
               emit(CMP(result, result, fs_reg(0), BRW_CONDITIONAL_NZ));

            result.reg_offset++;
         }
      }

      result.reg_offset = 0;
      break;
   }

   case ir_triop_fma:
      /* Note that the instruction's argument order is reversed from GLSL
       * and the IR.
       */
      emit(MAD(this->result, op[2], op[1], op[0]));
      break;

   case ir_triop_lrp:
      emit_lrp(this->result, op[0], op[1], op[2]);
      break;

   case ir_triop_csel:
      emit(CMP(reg_null_d, op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
      inst = emit(BRW_OPCODE_SEL, this->result, op[1], op[2]);
      inst->predicate = BRW_PREDICATE_NORMAL;
      break;
   }
}

void
fs_visitor::emit_assignment_writes(fs_reg &l, fs_reg &r,
				   const glsl_type *type, bool predicated)
{
   switch (type->base_type) {
   case GLSL_TYPE_FLOAT:
   case GLSL_TYPE_UINT:
   case GLSL_TYPE_INT:
   case GLSL_TYPE_BOOL:
      for (unsigned int i = 0; i < type->components(); i++) {
	 l.type = brw_type_for_base_type(type);
	 r.type = brw_type_for_base_type(type);

	 if (predicated || !l.equals(r)) {
	    fs_inst *inst = emit(MOV(l, r));
	    inst->predicate = predicated ? BRW_PREDICATE_NORMAL : BRW_PREDICATE_NONE;
	 }

	 l.reg_offset++;
	 r.reg_offset++;
      }
      break;
   case GLSL_TYPE_ARRAY:
      for (unsigned int i = 0; i < type->length; i++) {
	 emit_assignment_writes(l, r, type->fields.array, predicated);
      }
      break;

   case GLSL_TYPE_STRUCT:
      for (unsigned int i = 0; i < type->length; i++) {
	 emit_assignment_writes(l, r, type->fields.structure[i].type,
				predicated);
      }
      break;

   case GLSL_TYPE_SAMPLER:
   case GLSL_TYPE_IMAGE:
   case GLSL_TYPE_ATOMIC_UINT:
      break;

   case GLSL_TYPE_VOID:
   case GLSL_TYPE_ERROR:
   case GLSL_TYPE_INTERFACE:
      assert(!"not reached");
      break;
   }
}

/* If the RHS processing resulted in an instruction generating a
 * temporary value, and it would be easy to rewrite the instruction to
 * generate its result right into the LHS instead, do so.  This ends
 * up reliably removing instructions where it can be tricky to do so
 * later without real UD chain information.
 */
bool
fs_visitor::try_rewrite_rhs_to_dst(ir_assignment *ir,
                                   fs_reg dst,
                                   fs_reg src,
                                   fs_inst *pre_rhs_inst,
                                   fs_inst *last_rhs_inst)
{
   /* Only attempt if we're doing a direct assignment. */
   if (ir->condition ||
       !(ir->lhs->type->is_scalar() ||
        (ir->lhs->type->is_vector() &&
         ir->write_mask == (1 << ir->lhs->type->vector_elements) - 1)))
      return false;

   /* Make sure the last instruction generated our source reg. */
   fs_inst *modify = get_instruction_generating_reg(pre_rhs_inst,
						    last_rhs_inst,
						    src);
   if (!modify)
      return false;

   /* If last_rhs_inst wrote a different number of components than our LHS,
    * we can't safely rewrite it.
    */
   if (virtual_grf_sizes[dst.reg] != modify->regs_written)
      return false;

   /* Success!  Rewrite the instruction. */
   modify->dst = dst;

   return true;
}

void
fs_visitor::visit(ir_assignment *ir)
{
   fs_reg l, r;
   fs_inst *inst;

   /* FINISHME: arrays on the lhs */
   ir->lhs->accept(this);
   l = this->result;

   fs_inst *pre_rhs_inst = (fs_inst *) this->instructions.get_tail();

   ir->rhs->accept(this);
   r = this->result;

   fs_inst *last_rhs_inst = (fs_inst *) this->instructions.get_tail();

   assert(l.file != BAD_FILE);
   assert(r.file != BAD_FILE);

   if (try_rewrite_rhs_to_dst(ir, l, r, pre_rhs_inst, last_rhs_inst))
      return;

   if (ir->condition) {
      emit_bool_to_cond_code(ir->condition);
   }

   if (ir->lhs->type->is_scalar() ||
       ir->lhs->type->is_vector()) {
      for (int i = 0; i < ir->lhs->type->vector_elements; i++) {
	 if (ir->write_mask & (1 << i)) {
	    inst = emit(MOV(l, r));
	    if (ir->condition)
	       inst->predicate = BRW_PREDICATE_NORMAL;
	    r.reg_offset++;
	 }
	 l.reg_offset++;
      }
   } else {
      emit_assignment_writes(l, r, ir->lhs->type, ir->condition != NULL);
   }
}

fs_inst *
fs_visitor::emit_texture_gen4(ir_texture *ir, fs_reg dst, fs_reg coordinate,
			      fs_reg shadow_c, fs_reg lod, fs_reg dPdy)
{
   int mlen;
   int base_mrf = 1;
   bool simd16 = false;
   fs_reg orig_dst;

   /* g0 header. */
   mlen = 1;

   if (ir->shadow_comparitor) {
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
	 emit(MOV(fs_reg(MRF, base_mrf + mlen + i), coordinate));
	 coordinate.reg_offset++;
      }

      /* gen4's SIMD8 sampler always has the slots for u,v,r present.
       * the unused slots must be zeroed.
       */
      for (int i = ir->coordinate->type->vector_elements; i < 3; i++) {
         emit(MOV(fs_reg(MRF, base_mrf + mlen + i), fs_reg(0.0f)));
      }
      mlen += 3;

      if (ir->op == ir_tex) {
	 /* There's no plain shadow compare message, so we use shadow
	  * compare with a bias of 0.0.
	  */
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), fs_reg(0.0f)));
	 mlen++;
      } else if (ir->op == ir_txb || ir->op == ir_txl) {
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
	 mlen++;
      } else {
         assert(!"Should not get here.");
      }

      emit(MOV(fs_reg(MRF, base_mrf + mlen), shadow_c));
      mlen++;
   } else if (ir->op == ir_tex) {
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
	 emit(MOV(fs_reg(MRF, base_mrf + mlen + i), coordinate));
	 coordinate.reg_offset++;
      }
      /* zero the others. */
      for (int i = ir->coordinate->type->vector_elements; i<3; i++) {
         emit(MOV(fs_reg(MRF, base_mrf + mlen + i), fs_reg(0.0f)));
      }
      /* gen4's SIMD8 sampler always has the slots for u,v,r present. */
      mlen += 3;
   } else if (ir->op == ir_txd) {
      fs_reg &dPdx = lod;

      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
	 emit(MOV(fs_reg(MRF, base_mrf + mlen + i), coordinate));
	 coordinate.reg_offset++;
      }
      /* the slots for u and v are always present, but r is optional */
      mlen += MAX2(ir->coordinate->type->vector_elements, 2);

      /*  P   = u, v, r
       * dPdx = dudx, dvdx, drdx
       * dPdy = dudy, dvdy, drdy
       *
       * 1-arg: Does not exist.
       *
       * 2-arg: dudx   dvdx   dudy   dvdy
       *        dPdx.x dPdx.y dPdy.x dPdy.y
       *        m4     m5     m6     m7
       *
       * 3-arg: dudx   dvdx   drdx   dudy   dvdy   drdy
       *        dPdx.x dPdx.y dPdx.z dPdy.x dPdy.y dPdy.z
       *        m5     m6     m7     m8     m9     m10
       */
      for (int i = 0; i < ir->lod_info.grad.dPdx->type->vector_elements; i++) {
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), dPdx));
	 dPdx.reg_offset++;
      }
      mlen += MAX2(ir->lod_info.grad.dPdx->type->vector_elements, 2);

      for (int i = 0; i < ir->lod_info.grad.dPdy->type->vector_elements; i++) {
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), dPdy));
	 dPdy.reg_offset++;
      }
      mlen += MAX2(ir->lod_info.grad.dPdy->type->vector_elements, 2);
   } else if (ir->op == ir_txs) {
      /* There's no SIMD8 resinfo message on Gen4.  Use SIMD16 instead. */
      simd16 = true;
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), lod));
      mlen += 2;
   } else {
      /* Oh joy.  gen4 doesn't have SIMD8 non-shadow-compare bias/lod
       * instructions.  We'll need to do SIMD16 here.
       */
      simd16 = true;
      assert(ir->op == ir_txb || ir->op == ir_txl || ir->op == ir_txf);

      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
	 emit(MOV(fs_reg(MRF, base_mrf + mlen + i * 2, coordinate.type),
                  coordinate));
	 coordinate.reg_offset++;
      }

      /* Initialize the rest of u/v/r with 0.0.  Empirically, this seems to
       * be necessary for TXF (ld), but seems wise to do for all messages.
       */
      for (int i = ir->coordinate->type->vector_elements; i < 3; i++) {
	 emit(MOV(fs_reg(MRF, base_mrf + mlen + i * 2), fs_reg(0.0f)));
      }

      /* lod/bias appears after u/v/r. */
      mlen += 6;

      emit(MOV(fs_reg(MRF, base_mrf + mlen, lod.type), lod));
      mlen++;

      /* The unused upper half. */
      mlen++;
   }

   if (simd16) {
      /* Now, since we're doing simd16, the return is 2 interleaved
       * vec4s where the odd-indexed ones are junk. We'll need to move
       * this weirdness around to the expected layout.
       */
      orig_dst = dst;
      dst = fs_reg(GRF, virtual_grf_alloc(8),
                   (brw->is_g4x ?
                    brw_type_for_base_type(ir->type) :
                    BRW_REGISTER_TYPE_F));
   }

   fs_inst *inst = NULL;
   switch (ir->op) {
   case ir_tex:
      inst = emit(SHADER_OPCODE_TEX, dst);
      break;
   case ir_txb:
      inst = emit(FS_OPCODE_TXB, dst);
      break;
   case ir_txl:
      inst = emit(SHADER_OPCODE_TXL, dst);
      break;
   case ir_txd:
      inst = emit(SHADER_OPCODE_TXD, dst);
      break;
   case ir_txs:
      inst = emit(SHADER_OPCODE_TXS, dst);
      break;
   case ir_txf:
      inst = emit(SHADER_OPCODE_TXF, dst);
      break;
   default:
      fail("unrecognized texture opcode");
   }
   inst->base_mrf = base_mrf;
   inst->mlen = mlen;
   inst->header_present = true;
   inst->regs_written = simd16 ? 8 : 4;

   if (simd16) {
      for (int i = 0; i < 4; i++) {
	 emit(MOV(orig_dst, dst));
	 orig_dst.reg_offset++;
	 dst.reg_offset += 2;
      }
   }

   return inst;
}

/* gen5's sampler has slots for u, v, r, array index, then optional
 * parameters like shadow comparitor or LOD bias.  If optional
 * parameters aren't present, those base slots are optional and don't
 * need to be included in the message.
 *
 * We don't fill in the unnecessary slots regardless, which may look
 * surprising in the disassembly.
 */
fs_inst *
fs_visitor::emit_texture_gen5(ir_texture *ir, fs_reg dst, fs_reg coordinate,
                              fs_reg shadow_c, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index)
{
   int mlen = 0;
   int base_mrf = 2;
   int reg_width = dispatch_width / 8;
   bool header_present = false;
   const int vector_elements =
      ir->coordinate ? ir->coordinate->type->vector_elements : 0;

   if (ir->offset) {
      /* The offsets set up by the ir_texture visitor are in the
       * m1 header, so we can't go headerless.
       */
      header_present = true;
      mlen++;
      base_mrf--;
   }

   for (int i = 0; i < vector_elements; i++) {
      emit(MOV(fs_reg(MRF, base_mrf + mlen + i * reg_width, coordinate.type),
               coordinate));
      coordinate.reg_offset++;
   }
   mlen += vector_elements * reg_width;

   if (ir->shadow_comparitor) {
      mlen = MAX2(mlen, header_present + 4 * reg_width);

      emit(MOV(fs_reg(MRF, base_mrf + mlen), shadow_c));
      mlen += reg_width;
   }

   fs_inst *inst = NULL;
   switch (ir->op) {
   case ir_tex:
      inst = emit(SHADER_OPCODE_TEX, dst);
      break;
   case ir_txb:
      mlen = MAX2(mlen, header_present + 4 * reg_width);
      emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
      mlen += reg_width;

      inst = emit(FS_OPCODE_TXB, dst);
      break;
   case ir_txl:
      mlen = MAX2(mlen, header_present + 4 * reg_width);
      emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
      mlen += reg_width;

      inst = emit(SHADER_OPCODE_TXL, dst);
      break;
   case ir_txd: {
      mlen = MAX2(mlen, header_present + 4 * reg_width); /* skip over 'ai' */

      /**
       *  P   =  u,    v,    r
       * dPdx = dudx, dvdx, drdx
       * dPdy = dudy, dvdy, drdy
       *
       * Load up these values:
       * - dudx   dudy   dvdx   dvdy   drdx   drdy
       * - dPdx.x dPdy.x dPdx.y dPdy.y dPdx.z dPdy.z
       */
      for (int i = 0; i < ir->lod_info.grad.dPdx->type->vector_elements; i++) {
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
	 lod.reg_offset++;
	 mlen += reg_width;

	 emit(MOV(fs_reg(MRF, base_mrf + mlen), lod2));
	 lod2.reg_offset++;
	 mlen += reg_width;
      }

      inst = emit(SHADER_OPCODE_TXD, dst);
      break;
   }
   case ir_txs:
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), lod));
      mlen += reg_width;
      inst = emit(SHADER_OPCODE_TXS, dst);
      break;
   case ir_query_levels:
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
      mlen += reg_width;
      inst = emit(SHADER_OPCODE_TXS, dst);
      break;
   case ir_txf:
      mlen = header_present + 4 * reg_width;
      emit(MOV(fs_reg(MRF, base_mrf + mlen - reg_width, BRW_REGISTER_TYPE_UD), lod));
      inst = emit(SHADER_OPCODE_TXF, dst);
      break;
   case ir_txf_ms:
      mlen = header_present + 4 * reg_width;

      /* lod */
      emit(MOV(fs_reg(MRF, base_mrf + mlen - reg_width, BRW_REGISTER_TYPE_UD), fs_reg(0)));
      /* sample index */
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), sample_index));
      mlen += reg_width;
      inst = emit(SHADER_OPCODE_TXF_CMS, dst);
      break;
   case ir_lod:
      inst = emit(SHADER_OPCODE_LOD, dst);
      break;
   case ir_tg4:
      inst = emit(SHADER_OPCODE_TG4, dst);
      break;
   default:
      fail("unrecognized texture opcode");
      break;
   }
   inst->base_mrf = base_mrf;
   inst->mlen = mlen;
   inst->header_present = header_present;
   inst->regs_written = 4;

   if (mlen > MAX_SAMPLER_MESSAGE_SIZE) {
      fail("Message length >" STRINGIFY(MAX_SAMPLER_MESSAGE_SIZE)
           " disallowed by hardware\n");
   }

   return inst;
}

fs_inst *
fs_visitor::emit_texture_gen7(ir_texture *ir, fs_reg dst, fs_reg coordinate,
                              fs_reg shadow_c, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index, fs_reg mcs, int sampler)
{
   int reg_width = dispatch_width / 8;
   bool header_present = false;

   fs_reg payload = fs_reg(this, glsl_type::float_type);
   fs_reg next = payload;

   if (ir->op == ir_tg4 || (ir->offset && ir->op != ir_txf) || sampler >= 16) {
      /* For general texture offsets (no txf workaround), we need a header to
       * put them in.  Note that for SIMD16 we're making space for two actual
       * hardware registers here, so the emit will have to fix up for this.
       *
       * * ir4_tg4 needs to place its channel select in the header,
       * for interaction with ARB_texture_swizzle
       *
       * The sampler index is only 4-bits, so for larger sampler numbers we
       * need to offset the Sampler State Pointer in the header.
       */
      header_present = true;
      next.reg_offset++;
   }

   if (ir->shadow_comparitor) {
      emit(MOV(next, shadow_c));
      next.reg_offset++;
   }

   bool has_nonconstant_offset = ir->offset && !ir->offset->as_constant();
   bool coordinate_done = false;

   /* Set up the LOD info */
   switch (ir->op) {
   case ir_tex:
   case ir_lod:
      break;
   case ir_txb:
      emit(MOV(next, lod));
      next.reg_offset++;
      break;
   case ir_txl:
      emit(MOV(next, lod));
      next.reg_offset++;
      break;
   case ir_txd: {
      no16("Gen7 does not support sample_d/sample_d_c in SIMD16 mode.");

      /* Load dPdx and the coordinate together:
       * [hdr], [ref], x, dPdx.x, dPdy.x, y, dPdx.y, dPdy.y, z, dPdx.z, dPdy.z
       */
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
	 emit(MOV(next, coordinate));
	 coordinate.reg_offset++;
	 next.reg_offset++;

         /* For cube map array, the coordinate is (u,v,r,ai) but there are
          * only derivatives for (u, v, r).
          */
         if (i < ir->lod_info.grad.dPdx->type->vector_elements) {
            emit(MOV(next, lod));
            lod.reg_offset++;
            next.reg_offset++;

            emit(MOV(next, lod2));
            lod2.reg_offset++;
            next.reg_offset++;
         }
      }

      coordinate_done = true;
      break;
   }
   case ir_txs:
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), lod));
      next.reg_offset++;
      break;
   case ir_query_levels:
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
      next.reg_offset++;
      break;
   case ir_txf:
      /* Unfortunately, the parameters for LD are intermixed: u, lod, v, r. */
      emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
      coordinate.reg_offset++;
      next.reg_offset++;

      emit(MOV(retype(next, BRW_REGISTER_TYPE_D), lod));
      next.reg_offset++;

      for (int i = 1; i < ir->coordinate->type->vector_elements; i++) {
	 emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
	 coordinate.reg_offset++;
	 next.reg_offset++;
      }

      coordinate_done = true;
      break;
   case ir_txf_ms:
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), sample_index));
      next.reg_offset++;

      /* data from the multisample control surface */
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), mcs));
      next.reg_offset++;

      /* there is no offsetting for this message; just copy in the integer
       * texture coordinates
       */
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
         emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
         coordinate.reg_offset++;
         next.reg_offset++;
      }

      coordinate_done = true;
      break;
   case ir_tg4:
      if (has_nonconstant_offset) {
         if (ir->shadow_comparitor)
            no16("Gen7 does not support gather4_po_c in SIMD16 mode.");

         /* More crazy intermixing */
         ir->offset->accept(this);
         fs_reg offset_value = this->result;

         for (int i = 0; i < 2; i++) { /* u, v */
            emit(MOV(next, coordinate));
            coordinate.reg_offset++;
            next.reg_offset++;
         }

         for (int i = 0; i < 2; i++) { /* offu, offv */
            emit(MOV(retype(next, BRW_REGISTER_TYPE_D), offset_value));
            offset_value.reg_offset++;
            next.reg_offset++;
         }

         if (ir->coordinate->type->vector_elements == 3) { /* r if present */
            emit(MOV(next, coordinate));
            coordinate.reg_offset++;
            next.reg_offset++;
         }

         coordinate_done = true;
      }
      break;
   }

   /* Set up the coordinate (except for cases where it was done above) */
   if (ir->coordinate && !coordinate_done) {
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
         emit(MOV(next, coordinate));
         coordinate.reg_offset++;
         next.reg_offset++;
      }
   }

   /* Generate the SEND */
   fs_inst *inst = NULL;
   switch (ir->op) {
   case ir_tex: inst = emit(SHADER_OPCODE_TEX, dst, payload); break;
   case ir_txb: inst = emit(FS_OPCODE_TXB, dst, payload); break;
   case ir_txl: inst = emit(SHADER_OPCODE_TXL, dst, payload); break;
   case ir_txd: inst = emit(SHADER_OPCODE_TXD, dst, payload); break;
   case ir_txf: inst = emit(SHADER_OPCODE_TXF, dst, payload); break;
   case ir_txf_ms: inst = emit(SHADER_OPCODE_TXF_CMS, dst, payload); break;
   case ir_txs: inst = emit(SHADER_OPCODE_TXS, dst, payload); break;
   case ir_query_levels: inst = emit(SHADER_OPCODE_TXS, dst, payload); break;
   case ir_lod: inst = emit(SHADER_OPCODE_LOD, dst, payload); break;
   case ir_tg4:
      if (has_nonconstant_offset)
         inst = emit(SHADER_OPCODE_TG4_OFFSET, dst, payload);
      else
         inst = emit(SHADER_OPCODE_TG4, dst, payload);
      break;
   }
   inst->base_mrf = -1;
   if (reg_width == 2)
      inst->mlen = next.reg_offset * reg_width - header_present;
   else
      inst->mlen = next.reg_offset * reg_width;
   inst->header_present = header_present;
   inst->regs_written = 4;

   virtual_grf_sizes[payload.reg] = next.reg_offset;
   if (inst->mlen > MAX_SAMPLER_MESSAGE_SIZE) {
      fail("Message length >" STRINGIFY(MAX_SAMPLER_MESSAGE_SIZE)
           " disallowed by hardware\n");
   }

   return inst;
}

fs_reg
fs_visitor::rescale_texcoord(ir_texture *ir, fs_reg coordinate,
                             bool is_rect, int sampler, int texunit)
{
   fs_inst *inst = NULL;
   bool needs_gl_clamp = true;
   fs_reg scale_x, scale_y;

   /* The 965 requires the EU to do the normalization of GL rectangle
    * texture coordinates.  We use the program parameter state
    * tracking to get the scaling factor.
    */
   if (is_rect &&
       (brw->gen < 6 ||
	(brw->gen >= 6 && (c->key.tex.gl_clamp_mask[0] & (1 << sampler) ||
			     c->key.tex.gl_clamp_mask[1] & (1 << sampler))))) {
      struct gl_program_parameter_list *params = prog->Parameters;
      int tokens[STATE_LENGTH] = {
	 STATE_INTERNAL,
	 STATE_TEXRECT_SCALE,
	 texunit,
	 0,
	 0
      };

      no16("rectangle scale uniform setup not supported on SIMD16\n");
      if (dispatch_width == 16) {
	 return coordinate;
      }

      GLuint index = _mesa_add_state_reference(params,
					       (gl_state_index *)tokens);
      /* Try to find existing copies of the texrect scale uniforms. */
      for (unsigned i = 0; i < uniforms; i++) {
         if (stage_prog_data->param[i] ==
             &prog->Parameters->ParameterValues[index][0].f) {
            scale_x = fs_reg(UNIFORM, i);
            scale_y = fs_reg(UNIFORM, i + 1);
            break;
         }
      }

      /* If we didn't already set them up, do so now. */
      if (scale_x.file == BAD_FILE) {
         scale_x = fs_reg(UNIFORM, uniforms);
         scale_y = fs_reg(UNIFORM, uniforms + 1);

         stage_prog_data->param[uniforms++] =
            &prog->Parameters->ParameterValues[index][0].f;
         stage_prog_data->param[uniforms++] =
            &prog->Parameters->ParameterValues[index][1].f;
      }
   }

   /* The 965 requires the EU to do the normalization of GL rectangle
    * texture coordinates.  We use the program parameter state
    * tracking to get the scaling factor.
    */
   if (brw->gen < 6 && is_rect) {
      fs_reg dst = fs_reg(this, ir->coordinate->type);
      fs_reg src = coordinate;
      coordinate = dst;

      emit(MUL(dst, src, scale_x));
      dst.reg_offset++;
      src.reg_offset++;
      emit(MUL(dst, src, scale_y));
   } else if (is_rect) {
      /* On gen6+, the sampler handles the rectangle coordinates
       * natively, without needing rescaling.  But that means we have
       * to do GL_CLAMP clamping at the [0, width], [0, height] scale,
       * not [0, 1] like the default case below.
       */
      needs_gl_clamp = false;

      for (int i = 0; i < 2; i++) {
	 if (c->key.tex.gl_clamp_mask[i] & (1 << sampler)) {
	    fs_reg chan = coordinate;
	    chan.reg_offset += i;

	    inst = emit(BRW_OPCODE_SEL, chan, chan, fs_reg(0.0f));
	    inst->conditional_mod = BRW_CONDITIONAL_G;

	    /* Our parameter comes in as 1.0/width or 1.0/height,
	     * because that's what people normally want for doing
	     * texture rectangle handling.  We need width or height
	     * for clamping, but we don't care enough to make a new
	     * parameter type, so just invert back.
	     */
	    fs_reg limit = fs_reg(this, glsl_type::float_type);
	    emit(MOV(limit, i == 0 ? scale_x : scale_y));
	    emit(SHADER_OPCODE_RCP, limit, limit);

	    inst = emit(BRW_OPCODE_SEL, chan, chan, limit);
	    inst->conditional_mod = BRW_CONDITIONAL_L;
	 }
      }
   }

   if (ir->coordinate && needs_gl_clamp) {
      for (unsigned int i = 0;
	   i < MIN2(ir->coordinate->type->vector_elements, 3); i++) {
	 if (c->key.tex.gl_clamp_mask[i] & (1 << sampler)) {
	    fs_reg chan = coordinate;
	    chan.reg_offset += i;

	    fs_inst *inst = emit(MOV(chan, chan));
	    inst->saturate = true;
	 }
      }
   }
   return coordinate;
}

/* Sample from the MCS surface attached to this multisample texture. */
fs_reg
fs_visitor::emit_mcs_fetch(ir_texture *ir, fs_reg coordinate, int sampler)
{
   int reg_width = dispatch_width / 8;
   fs_reg payload = fs_reg(this, glsl_type::float_type);
   fs_reg dest = fs_reg(this, glsl_type::uvec4_type);
   fs_reg next = payload;

   /* parameters are: u, v, r, lod; missing parameters are treated as zero */
   for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
      emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
      coordinate.reg_offset++;
      next.reg_offset++;
   }

   fs_inst *inst = emit(SHADER_OPCODE_TXF_MCS, dest, payload);
   virtual_grf_sizes[payload.reg] = next.reg_offset;
   inst->base_mrf = -1;
   inst->mlen = next.reg_offset * reg_width;
   inst->header_present = false;
   inst->regs_written = 4; /* we only care about one reg of response,
                            * but the sampler always writes 4/8
                            */
   inst->sampler = sampler;

   return dest;
}

void
fs_visitor::visit(ir_texture *ir)
{
   fs_inst *inst = NULL;

   int sampler =
      _mesa_get_sampler_uniform_value(ir->sampler, shader_prog, prog);
   /* FINISHME: We're failing to recompile our programs when the sampler is
    * updated.  This only matters for the texture rectangle scale parameters
    * (pre-gen6, or gen6+ with GL_CLAMP).
    */
   int texunit = prog->SamplerUnits[sampler];

   if (ir->op == ir_tg4) {
      /* When tg4 is used with the degenerate ZERO/ONE swizzles, don't bother
       * emitting anything other than setting up the constant result.
       */
      ir_constant *chan = ir->lod_info.component->as_constant();
      int swiz = GET_SWZ(c->key.tex.swizzles[sampler], chan->value.i[0]);
      if (swiz == SWIZZLE_ZERO || swiz == SWIZZLE_ONE) {

         fs_reg res = fs_reg(this, glsl_type::vec4_type);
         this->result = res;

         for (int i=0; i<4; i++) {
            emit(MOV(res, fs_reg(swiz == SWIZZLE_ZERO ? 0.0f : 1.0f)));
            res.reg_offset++;
         }
         return;
      }
   }

   /* Should be lowered by do_lower_texture_projection */
   assert(!ir->projector);

   /* Should be lowered */
   assert(!ir->offset || !ir->offset->type->is_array());

   /* Generate code to compute all the subexpression trees.  This has to be
    * done before loading any values into MRFs for the sampler message since
    * generating these values may involve SEND messages that need the MRFs.
    */
   fs_reg coordinate;
   if (ir->coordinate) {
      ir->coordinate->accept(this);

      coordinate = rescale_texcoord(ir, this->result,
                                    ir->sampler->type->sampler_dimensionality ==
                                    GLSL_SAMPLER_DIM_RECT,
                                    sampler, texunit);
   }

   fs_reg shadow_comparitor;
   if (ir->shadow_comparitor) {
      ir->shadow_comparitor->accept(this);
      shadow_comparitor = this->result;
   }

   fs_reg lod, lod2, sample_index, mcs;
   switch (ir->op) {
   case ir_tex:
   case ir_lod:
   case ir_tg4:
   case ir_query_levels:
      break;
   case ir_txb:
      ir->lod_info.bias->accept(this);
      lod = this->result;
      break;
   case ir_txd:
      ir->lod_info.grad.dPdx->accept(this);
      lod = this->result;

      ir->lod_info.grad.dPdy->accept(this);
      lod2 = this->result;
      break;
   case ir_txf:
   case ir_txl:
   case ir_txs:
      ir->lod_info.lod->accept(this);
      lod = this->result;
      break;
   case ir_txf_ms:
      ir->lod_info.sample_index->accept(this);
      sample_index = this->result;

      if (brw->gen >= 7 && c->key.tex.compressed_multisample_layout_mask & (1<<sampler))
         mcs = emit_mcs_fetch(ir, coordinate, sampler);
      else
         mcs = fs_reg(0u);
      break;
   default:
      assert(!"Unrecognized texture opcode");
   };

   /* Writemasking doesn't eliminate channels on SIMD8 texture
    * samples, so don't worry about them.
    */
   fs_reg dst = fs_reg(this, glsl_type::get_instance(ir->type->base_type, 4, 1));

   if (brw->gen >= 7) {
      inst = emit_texture_gen7(ir, dst, coordinate, shadow_comparitor,
                               lod, lod2, sample_index, mcs, sampler);
   } else if (brw->gen >= 5) {
      inst = emit_texture_gen5(ir, dst, coordinate, shadow_comparitor,
                               lod, lod2, sample_index);
   } else {
      inst = emit_texture_gen4(ir, dst, coordinate, shadow_comparitor,
                               lod, lod2);
   }

   if (ir->offset != NULL && ir->op != ir_txf)
      inst->texture_offset = brw_texture_offset(ctx, ir->offset->as_constant());

   if (ir->op == ir_tg4)
      inst->texture_offset |= gather_channel(ir, sampler) << 16; // M0.2:16-17

   inst->sampler = sampler;

   if (ir->shadow_comparitor)
      inst->shadow_compare = true;

   /* fixup #layers for cube map arrays */
   if (ir->op == ir_txs) {
      glsl_type const *type = ir->sampler->type;
      if (type->sampler_dimensionality == GLSL_SAMPLER_DIM_CUBE &&
          type->sampler_array) {
         fs_reg depth = dst;
         depth.reg_offset = 2;
         emit_math(SHADER_OPCODE_INT_QUOTIENT, depth, depth, fs_reg(6));
      }
   }

   if (brw->gen == 6 && ir->op == ir_tg4) {
      emit_gen6_gather_wa(c->key.tex.gen6_gather_wa[sampler], dst);
   }

   swizzle_result(ir, dst, sampler);
}

/**
 * Apply workarounds for Gen6 gather with UINT/SINT
 */
void
fs_visitor::emit_gen6_gather_wa(uint8_t wa, fs_reg dst)
{
   if (!wa)
      return;

   int width = (wa & WA_8BIT) ? 8 : 16;

   for (int i = 0; i < 4; i++) {
      fs_reg dst_f = retype(dst, BRW_REGISTER_TYPE_F);
      /* Convert from UNORM to UINT */
      emit(MUL(dst_f, dst_f, fs_reg((float)((1 << width) - 1))));
      emit(MOV(dst, dst_f));

      if (wa & WA_SIGN) {
         /* Reinterpret the UINT value as a signed INT value by
          * shifting the sign bit into place, then shifting back
          * preserving sign.
          */
         emit(SHL(dst, dst, fs_reg(32 - width)));
         emit(ASR(dst, dst, fs_reg(32 - width)));
      }

      dst.reg_offset++;
   }
}

/**
 * Set up the gather channel based on the swizzle, for gather4.
 */
uint32_t
fs_visitor::gather_channel(ir_texture *ir, int sampler)
{
   ir_constant *chan = ir->lod_info.component->as_constant();
   int swiz = GET_SWZ(c->key.tex.swizzles[sampler], chan->value.i[0]);
   switch (swiz) {
      case SWIZZLE_X: return 0;
      case SWIZZLE_Y:
         /* gather4 sampler is broken for green channel on RG32F --
          * we must ask for blue instead.
          */
         if (c->key.tex.gather_channel_quirk_mask & (1<<sampler))
            return 2;
         return 1;
      case SWIZZLE_Z: return 2;
      case SWIZZLE_W: return 3;
      default:
         assert(!"Not reached"); /* zero, one swizzles handled already */
         return 0;
   }
}

/**
 * Swizzle the result of a texture result.  This is necessary for
 * EXT_texture_swizzle as well as DEPTH_TEXTURE_MODE for shadow comparisons.
 */
void
fs_visitor::swizzle_result(ir_texture *ir, fs_reg orig_val, int sampler)
{
   if (ir->op == ir_query_levels) {
      /* # levels is in .w */
      orig_val.reg_offset += 3;
      this->result = orig_val;
      return;
   }

   this->result = orig_val;

   /* txs,lod don't actually sample the texture, so swizzling the result
    * makes no sense.
    */
   if (ir->op == ir_txs || ir->op == ir_lod || ir->op == ir_tg4)
      return;

   if (ir->type == glsl_type::float_type) {
      /* Ignore DEPTH_TEXTURE_MODE swizzling. */
      assert(ir->sampler->type->sampler_shadow);
   } else if (c->key.tex.swizzles[sampler] != SWIZZLE_NOOP) {
      fs_reg swizzled_result = fs_reg(this, glsl_type::vec4_type);

      for (int i = 0; i < 4; i++) {
	 int swiz = GET_SWZ(c->key.tex.swizzles[sampler], i);
	 fs_reg l = swizzled_result;
	 l.reg_offset += i;

	 if (swiz == SWIZZLE_ZERO) {
	    emit(MOV(l, fs_reg(0.0f)));
	 } else if (swiz == SWIZZLE_ONE) {
	    emit(MOV(l, fs_reg(1.0f)));
	 } else {
	    fs_reg r = orig_val;
	    r.reg_offset += GET_SWZ(c->key.tex.swizzles[sampler], i);
	    emit(MOV(l, r));
	 }
      }
      this->result = swizzled_result;
   }
}

void
fs_visitor::visit(ir_swizzle *ir)
{
   ir->val->accept(this);
   fs_reg val = this->result;

   if (ir->type->vector_elements == 1) {
      this->result.reg_offset += ir->mask.x;
      return;
   }

   fs_reg result = fs_reg(this, ir->type);
   this->result = result;

   for (unsigned int i = 0; i < ir->type->vector_elements; i++) {
      fs_reg channel = val;
      int swiz = 0;

      switch (i) {
      case 0:
	 swiz = ir->mask.x;
	 break;
      case 1:
	 swiz = ir->mask.y;
	 break;
      case 2:
	 swiz = ir->mask.z;
	 break;
      case 3:
	 swiz = ir->mask.w;
	 break;
      }

      channel.reg_offset += swiz;
      emit(MOV(result, channel));
      result.reg_offset++;
   }
}

void
fs_visitor::visit(ir_discard *ir)
{
   assert(ir->condition == NULL); /* FINISHME */

   /* We track our discarded pixels in f0.1.  By predicating on it, we can
    * update just the flag bits that aren't yet discarded.  By emitting a
    * CMP of g0 != g0, all our currently executing channels will get turned
    * off.
    */
   fs_reg some_reg = fs_reg(retype(brw_vec8_grf(0, 0),
                                   BRW_REGISTER_TYPE_UW));
   fs_inst *cmp = emit(CMP(reg_null_f, some_reg, some_reg,
                           BRW_CONDITIONAL_NZ));
   cmp->predicate = BRW_PREDICATE_NORMAL;
   cmp->flag_subreg = 1;

   if (brw->gen >= 6) {
      /* For performance, after a discard, jump to the end of the shader.
       * However, many people will do foliage by discarding based on a
       * texture's alpha mask, and then continue on to texture with the
       * remaining pixels.  To avoid trashing the derivatives for those
       * texture samples, we'll only jump if all of the pixels in the subspan
       * have been discarded.
       */
      fs_inst *discard_jump = emit(FS_OPCODE_DISCARD_JUMP);
      discard_jump->flag_subreg = 1;
      discard_jump->predicate = BRW_PREDICATE_ALIGN1_ANY4H;
      discard_jump->predicate_inverse = true;
   }
}

void
fs_visitor::visit(ir_constant *ir)
{
   /* Set this->result to reg at the bottom of the function because some code
    * paths will cause this visitor to be applied to other fields.  This will
    * cause the value stored in this->result to be modified.
    *
    * Make reg constant so that it doesn't get accidentally modified along the
    * way.  Yes, I actually had this problem. :(
    */
   const fs_reg reg(this, ir->type);
   fs_reg dst_reg = reg;

   if (ir->type->is_array()) {
      const unsigned size = type_size(ir->type->fields.array);

      for (unsigned i = 0; i < ir->type->length; i++) {
	 ir->array_elements[i]->accept(this);
	 fs_reg src_reg = this->result;

	 dst_reg.type = src_reg.type;
	 for (unsigned j = 0; j < size; j++) {
	    emit(MOV(dst_reg, src_reg));
	    src_reg.reg_offset++;
	    dst_reg.reg_offset++;
	 }
      }
   } else if (ir->type->is_record()) {
      foreach_list(node, &ir->components) {
	 ir_constant *const field = (ir_constant *) node;
	 const unsigned size = type_size(field->type);

	 field->accept(this);
	 fs_reg src_reg = this->result;

	 dst_reg.type = src_reg.type;
	 for (unsigned j = 0; j < size; j++) {
	    emit(MOV(dst_reg, src_reg));
	    src_reg.reg_offset++;
	    dst_reg.reg_offset++;
	 }
      }
   } else {
      const unsigned size = type_size(ir->type);

      for (unsigned i = 0; i < size; i++) {
	 switch (ir->type->base_type) {
	 case GLSL_TYPE_FLOAT:
	    emit(MOV(dst_reg, fs_reg(ir->value.f[i])));
	    break;
	 case GLSL_TYPE_UINT:
	    emit(MOV(dst_reg, fs_reg(ir->value.u[i])));
	    break;
	 case GLSL_TYPE_INT:
	    emit(MOV(dst_reg, fs_reg(ir->value.i[i])));
	    break;
	 case GLSL_TYPE_BOOL:
	    emit(MOV(dst_reg, fs_reg((int)ir->value.b[i])));
	    break;
	 default:
	    assert(!"Non-float/uint/int/bool constant");
	 }
	 dst_reg.reg_offset++;
      }
   }

   this->result = reg;
}

void
fs_visitor::emit_bool_to_cond_code(ir_rvalue *ir)
{
   ir_expression *expr = ir->as_expression();

   if (expr &&
       expr->operation != ir_binop_logic_and &&
       expr->operation != ir_binop_logic_or &&
       expr->operation != ir_binop_logic_xor) {
      fs_reg op[2];
      fs_inst *inst;

      assert(expr->get_num_operands() <= 2);
      for (unsigned int i = 0; i < expr->get_num_operands(); i++) {
	 assert(expr->operands[i]->type->is_scalar());

	 expr->operands[i]->accept(this);
	 op[i] = this->result;

	 resolve_ud_negate(&op[i]);
      }

      switch (expr->operation) {
      case ir_unop_logic_not:
	 inst = emit(AND(reg_null_d, op[0], fs_reg(1)));
	 inst->conditional_mod = BRW_CONDITIONAL_Z;
	 break;

      case ir_unop_f2b:
	 if (brw->gen >= 6) {
	    emit(CMP(reg_null_d, op[0], fs_reg(0.0f), BRW_CONDITIONAL_NZ));
	 } else {
	    inst = emit(MOV(reg_null_f, op[0]));
            inst->conditional_mod = BRW_CONDITIONAL_NZ;
	 }
	 break;

      case ir_unop_i2b:
	 if (brw->gen >= 6) {
	    emit(CMP(reg_null_d, op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
	 } else {
	    inst = emit(MOV(reg_null_d, op[0]));
            inst->conditional_mod = BRW_CONDITIONAL_NZ;
	 }
	 break;

      case ir_binop_greater:
      case ir_binop_gequal:
      case ir_binop_less:
      case ir_binop_lequal:
      case ir_binop_equal:
      case ir_binop_all_equal:
      case ir_binop_nequal:
      case ir_binop_any_nequal:
	 resolve_bool_comparison(expr->operands[0], &op[0]);
	 resolve_bool_comparison(expr->operands[1], &op[1]);

	 emit(CMP(reg_null_d, op[0], op[1],
                  brw_conditional_for_comparison(expr->operation)));
	 break;

      default:
	 assert(!"not reached");
	 fail("bad cond code\n");
	 break;
      }
      return;
   }

   ir->accept(this);

   fs_inst *inst = emit(AND(reg_null_d, this->result, fs_reg(1)));
   inst->conditional_mod = BRW_CONDITIONAL_NZ;
}

/**
 * Emit a gen6 IF statement with the comparison folded into the IF
 * instruction.
 */
void
fs_visitor::emit_if_gen6(ir_if *ir)
{
   ir_expression *expr = ir->condition->as_expression();

   if (expr) {
      fs_reg op[2];
      fs_inst *inst;
      fs_reg temp;

      assert(expr->get_num_operands() <= 2);
      for (unsigned int i = 0; i < expr->get_num_operands(); i++) {
	 assert(expr->operands[i]->type->is_scalar());

	 expr->operands[i]->accept(this);
	 op[i] = this->result;
      }

      switch (expr->operation) {
      case ir_unop_logic_not:
      case ir_binop_logic_xor:
      case ir_binop_logic_or:
      case ir_binop_logic_and:
         /* For operations on bool arguments, only the low bit of the bool is
          * valid, and the others are undefined.  Fall back to the condition
          * code path.
          */
         break;

      case ir_unop_f2b:
	 inst = emit(BRW_OPCODE_IF, reg_null_f, op[0], fs_reg(0));
	 inst->conditional_mod = BRW_CONDITIONAL_NZ;
	 return;

      case ir_unop_i2b:
	 emit(IF(op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
	 return;

      case ir_binop_greater:
      case ir_binop_gequal:
      case ir_binop_less:
      case ir_binop_lequal:
      case ir_binop_equal:
      case ir_binop_all_equal:
      case ir_binop_nequal:
      case ir_binop_any_nequal:
	 resolve_bool_comparison(expr->operands[0], &op[0]);
	 resolve_bool_comparison(expr->operands[1], &op[1]);

	 emit(IF(op[0], op[1],
                 brw_conditional_for_comparison(expr->operation)));
	 return;
      default:
	 assert(!"not reached");
	 emit(IF(op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
	 fail("bad condition\n");
	 return;
      }
   }

   emit_bool_to_cond_code(ir->condition);
   fs_inst *inst = emit(BRW_OPCODE_IF);
   inst->predicate = BRW_PREDICATE_NORMAL;
}

/**
 * Try to replace IF/MOV/ELSE/MOV/ENDIF with SEL.
 *
 * Many GLSL shaders contain the following pattern:
 *
 *    x = condition ? foo : bar
 *
 * The compiler emits an ir_if tree for this, since each subexpression might be
 * a complex tree that could have side-effects or short-circuit logic.
 *
 * However, the common case is to simply select one of two constants or
 * variable values---which is exactly what SEL is for.  In this case, the
 * assembly looks like:
 *
 *    (+f0) IF
 *    MOV dst src0
 *    ELSE
 *    MOV dst src1
 *    ENDIF
 *
 * which can be easily translated into:
 *
 *    (+f0) SEL dst src0 src1
 *
 * If src0 is an immediate value, we promote it to a temporary GRF.
 */
void
fs_visitor::try_replace_with_sel()
{
   fs_inst *endif_inst = (fs_inst *) instructions.get_tail();
   assert(endif_inst->opcode == BRW_OPCODE_ENDIF);

   /* Pattern match in reverse: IF, MOV, ELSE, MOV, ENDIF. */
   int opcodes[] = {
      BRW_OPCODE_IF, BRW_OPCODE_MOV, BRW_OPCODE_ELSE, BRW_OPCODE_MOV,
   };

   fs_inst *match = (fs_inst *) endif_inst->prev;
   for (int i = 0; i < 4; i++) {
      if (match->is_head_sentinel() || match->opcode != opcodes[4-i-1])
         return;
      match = (fs_inst *) match->prev;
   }

   /* The opcodes match; it looks like the right sequence of instructions. */
   fs_inst *else_mov = (fs_inst *) endif_inst->prev;
   fs_inst *then_mov = (fs_inst *) else_mov->prev->prev;
   fs_inst *if_inst = (fs_inst *) then_mov->prev;

   /* Check that the MOVs are the right form. */
   if (then_mov->dst.equals(else_mov->dst) &&
       !then_mov->is_partial_write() &&
       !else_mov->is_partial_write()) {

      /* Remove the matched instructions; we'll emit a SEL to replace them. */
      while (!if_inst->next->is_tail_sentinel())
         if_inst->next->remove();
      if_inst->remove();

      /* Only the last source register can be a constant, so if the MOV in
       * the "then" clause uses a constant, we need to put it in a temporary.
       */
      fs_reg src0(then_mov->src[0]);
      if (src0.file == IMM) {
         src0 = fs_reg(this, glsl_type::float_type);
         src0.type = then_mov->src[0].type;
         emit(MOV(src0, then_mov->src[0]));
      }

      fs_inst *sel;
      if (if_inst->conditional_mod) {
         /* Sandybridge-specific IF with embedded comparison */
         emit(CMP(reg_null_d, if_inst->src[0], if_inst->src[1],
                  if_inst->conditional_mod));
         sel = emit(BRW_OPCODE_SEL, then_mov->dst, src0, else_mov->src[0]);
         sel->predicate = BRW_PREDICATE_NORMAL;
      } else {
         /* Separate CMP and IF instructions */
         sel = emit(BRW_OPCODE_SEL, then_mov->dst, src0, else_mov->src[0]);
         sel->predicate = if_inst->predicate;
         sel->predicate_inverse = if_inst->predicate_inverse;
      }
   }
}

void
fs_visitor::visit(ir_if *ir)
{
   if (brw->gen < 6) {
      no16("Can't support (non-uniform) control flow on SIMD16\n");
   }

   /* Don't point the annotation at the if statement, because then it plus
    * the then and else blocks get printed.
    */
   this->base_ir = ir->condition;

   if (brw->gen == 6) {
      emit_if_gen6(ir);
   } else {
      emit_bool_to_cond_code(ir->condition);

      emit(IF(BRW_PREDICATE_NORMAL));
   }

   foreach_list(node, &ir->then_instructions) {
      ir_instruction *ir = (ir_instruction *)node;
      this->base_ir = ir;

      ir->accept(this);
   }

   if (!ir->else_instructions.is_empty()) {
      emit(BRW_OPCODE_ELSE);

      foreach_list(node, &ir->else_instructions) {
	 ir_instruction *ir = (ir_instruction *)node;
	 this->base_ir = ir;

	 ir->accept(this);
      }
   }

   emit(BRW_OPCODE_ENDIF);

   try_replace_with_sel();
}

void
fs_visitor::visit(ir_loop *ir)
{
   if (brw->gen < 6) {
      no16("Can't support (non-uniform) control flow on SIMD16\n");
   }

   this->base_ir = NULL;
   emit(BRW_OPCODE_DO);

   foreach_list(node, &ir->body_instructions) {
      ir_instruction *ir = (ir_instruction *)node;

      this->base_ir = ir;
      ir->accept(this);
   }

   this->base_ir = NULL;
   emit(BRW_OPCODE_WHILE);
}

void
fs_visitor::visit(ir_loop_jump *ir)
{
   switch (ir->mode) {
   case ir_loop_jump::jump_break:
      emit(BRW_OPCODE_BREAK);
      break;
   case ir_loop_jump::jump_continue:
      emit(BRW_OPCODE_CONTINUE);
      break;
   }
}

void
fs_visitor::visit_atomic_counter_intrinsic(ir_call *ir)
{
   ir_dereference *deref = static_cast<ir_dereference *>(
      ir->actual_parameters.get_head());
   ir_variable *location = deref->variable_referenced();
   unsigned surf_index = (c->prog_data.base.binding_table.abo_start +
                          location->data.atomic.buffer_index);

   /* Calculate the surface offset */
   fs_reg offset(this, glsl_type::uint_type);
   ir_dereference_array *deref_array = deref->as_dereference_array();

   if (deref_array) {
      deref_array->array_index->accept(this);

      fs_reg tmp(this, glsl_type::uint_type);
      emit(MUL(tmp, this->result, ATOMIC_COUNTER_SIZE));
      emit(ADD(offset, tmp, location->data.atomic.offset));
   } else {
      offset = location->data.atomic.offset;
   }

   /* Emit the appropriate machine instruction */
   const char *callee = ir->callee->function_name();
   ir->return_deref->accept(this);
   fs_reg dst = this->result;

   if (!strcmp("__intrinsic_atomic_read", callee)) {
      emit_untyped_surface_read(surf_index, dst, offset);

   } else if (!strcmp("__intrinsic_atomic_increment", callee)) {
      emit_untyped_atomic(BRW_AOP_INC, surf_index, dst, offset,
                          fs_reg(), fs_reg());

   } else if (!strcmp("__intrinsic_atomic_predecrement", callee)) {
      emit_untyped_atomic(BRW_AOP_PREDEC, surf_index, dst, offset,
                          fs_reg(), fs_reg());
   }
}

void
fs_visitor::visit(ir_call *ir)
{
   const char *callee = ir->callee->function_name();

   if (!strcmp("__intrinsic_atomic_read", callee) ||
       !strcmp("__intrinsic_atomic_increment", callee) ||
       !strcmp("__intrinsic_atomic_predecrement", callee)) {
      visit_atomic_counter_intrinsic(ir);
   } else {
      assert(!"Unsupported intrinsic.");
   }
}

void
fs_visitor::visit(ir_return *ir)
{
   assert(!"FINISHME");
}

void
fs_visitor::visit(ir_function *ir)
{
   /* Ignore function bodies other than main() -- we shouldn't see calls to
    * them since they should all be inlined before we get to ir_to_mesa.
    */
   if (strcmp(ir->name, "main") == 0) {
      const ir_function_signature *sig;
      exec_list empty;

      sig = ir->matching_signature(NULL, &empty);

      assert(sig);

      foreach_list(node, &sig->body) {
	 ir_instruction *ir = (ir_instruction *)node;
	 this->base_ir = ir;

	 ir->accept(this);
      }
   }
}

void
fs_visitor::visit(ir_function_signature *ir)
{
   assert(!"not reached");
   (void)ir;
}

void
fs_visitor::visit(ir_emit_vertex *)
{
   assert(!"not reached");
}

void
fs_visitor::visit(ir_end_primitive *)
{
   assert(!"not reached");
}

void
fs_visitor::emit_untyped_atomic(unsigned atomic_op, unsigned surf_index,
                                fs_reg dst, fs_reg offset, fs_reg src0,
                                fs_reg src1)
{
   const unsigned operand_len = dispatch_width / 8;
   unsigned mlen = 0;

   /* Initialize the sample mask in the message header. */
   emit(MOV(brw_uvec_mrf(8, mlen, 0), fs_reg(0u)))
      ->force_writemask_all = true;

   if (fp->UsesKill) {
      emit(MOV(brw_uvec_mrf(1, mlen, 7), brw_flag_reg(0, 1)))
         ->force_writemask_all = true;
   } else {
      emit(MOV(brw_uvec_mrf(1, mlen, 7),
               retype(brw_vec1_grf(1, 7), BRW_REGISTER_TYPE_UD)))
         ->force_writemask_all = true;
   }

   mlen++;

   /* Set the atomic operation offset. */
   emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), offset));
   mlen += operand_len;

   /* Set the atomic operation arguments. */
   if (src0.file != BAD_FILE) {
      emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), src0));
      mlen += operand_len;
   }

   if (src1.file != BAD_FILE) {
      emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), src1));
      mlen += operand_len;
   }

   /* Emit the instruction. */
   fs_inst *inst = new(mem_ctx) fs_inst(SHADER_OPCODE_UNTYPED_ATOMIC, dst,
                                        atomic_op, surf_index);
   inst->base_mrf = 0;
   inst->mlen = mlen;
   inst->header_present = true;
   emit(inst);
}

void
fs_visitor::emit_untyped_surface_read(unsigned surf_index, fs_reg dst,
                                      fs_reg offset)
{
   const unsigned operand_len = dispatch_width / 8;
   unsigned mlen = 0;

   /* Initialize the sample mask in the message header. */
   emit(MOV(brw_uvec_mrf(8, mlen, 0), fs_reg(0u)))
      ->force_writemask_all = true;

   if (fp->UsesKill) {
      emit(MOV(brw_uvec_mrf(1, mlen, 7), brw_flag_reg(0, 1)))
         ->force_writemask_all = true;
   } else {
      emit(MOV(brw_uvec_mrf(1, mlen, 7),
               retype(brw_vec1_grf(1, 7), BRW_REGISTER_TYPE_UD)))
         ->force_writemask_all = true;
   }

   mlen++;

   /* Set the surface read offset. */
   emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), offset));
   mlen += operand_len;

   /* Emit the instruction. */
   fs_inst *inst = new(mem_ctx)
      fs_inst(SHADER_OPCODE_UNTYPED_SURFACE_READ, dst, surf_index);
   inst->base_mrf = 0;
   inst->mlen = mlen;
   inst->header_present = true;
   emit(inst);
}

fs_inst *
fs_visitor::emit(fs_inst *inst)
{
   if (force_uncompressed_stack > 0)
      inst->force_uncompressed = true;

   inst->annotation = this->current_annotation;
   inst->ir = this->base_ir;

   this->instructions.push_tail(inst);

   return inst;
}

void
fs_visitor::emit(exec_list list)
{
   foreach_list_safe(node, &list) {
      fs_inst *inst = (fs_inst *)node;
      inst->remove();
      emit(inst);
   }
}

/** Emits a dummy fragment shader consisting of magenta for bringup purposes. */
void
fs_visitor::emit_dummy_fs()
{
   int reg_width = dispatch_width / 8;

   /* Everyone's favorite color. */
   emit(MOV(fs_reg(MRF, 2 + 0 * reg_width), fs_reg(1.0f)));
   emit(MOV(fs_reg(MRF, 2 + 1 * reg_width), fs_reg(0.0f)));
   emit(MOV(fs_reg(MRF, 2 + 2 * reg_width), fs_reg(1.0f)));
   emit(MOV(fs_reg(MRF, 2 + 3 * reg_width), fs_reg(0.0f)));

   fs_inst *write;
   write = emit(FS_OPCODE_FB_WRITE, fs_reg(0), fs_reg(0));
   write->base_mrf = 2;
   write->mlen = 4 * reg_width;
   write->eot = true;
}

/* The register location here is relative to the start of the URB
 * data.  It will get adjusted to be a real location before
 * generate_code() time.
 */
struct brw_reg
fs_visitor::interp_reg(int location, int channel)
{
   int regnr = c->prog_data.urb_setup[location] * 2 + channel / 2;
   int stride = (channel & 1) * 4;

   assert(c->prog_data.urb_setup[location] != -1);

   return brw_vec1_grf(regnr, stride);
}

/** Emits the interpolation for the varying inputs. */
void
fs_visitor::emit_interpolation_setup_gen4()
{
   this->current_annotation = "compute pixel centers";
   this->pixel_x = fs_reg(this, glsl_type::uint_type);
   this->pixel_y = fs_reg(this, glsl_type::uint_type);
   this->pixel_x.type = BRW_REGISTER_TYPE_UW;
   this->pixel_y.type = BRW_REGISTER_TYPE_UW;

   emit(FS_OPCODE_PIXEL_X, this->pixel_x);
   emit(FS_OPCODE_PIXEL_Y, this->pixel_y);

   this->current_annotation = "compute pixel deltas from v0";
   if (brw->has_pln) {
      this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC] =
         fs_reg(this, glsl_type::vec2_type);
      this->delta_y[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC] =
         this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC];
      this->delta_y[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC].reg_offset++;
   } else {
      this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC] =
         fs_reg(this, glsl_type::float_type);
      this->delta_y[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC] =
         fs_reg(this, glsl_type::float_type);
   }
   emit(ADD(this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC],
            this->pixel_x, fs_reg(negate(brw_vec1_grf(1, 0)))));
   emit(ADD(this->delta_y[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC],
            this->pixel_y, fs_reg(negate(brw_vec1_grf(1, 1)))));

   this->current_annotation = "compute pos.w and 1/pos.w";
   /* Compute wpos.w.  It's always in our setup, since it's needed to
    * interpolate the other attributes.
    */
   this->wpos_w = fs_reg(this, glsl_type::float_type);
   emit(FS_OPCODE_LINTERP, wpos_w,
        this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC],
        this->delta_y[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC],
	interp_reg(VARYING_SLOT_POS, 3));
   /* Compute the pixel 1/W value from wpos.w. */
   this->pixel_w = fs_reg(this, glsl_type::float_type);
   emit_math(SHADER_OPCODE_RCP, this->pixel_w, wpos_w);
   this->current_annotation = NULL;
}

/** Emits the interpolation for the varying inputs. */
void
fs_visitor::emit_interpolation_setup_gen6()
{
   struct brw_reg g1_uw = retype(brw_vec1_grf(1, 0), BRW_REGISTER_TYPE_UW);

   /* If the pixel centers end up used, the setup is the same as for gen4. */
   this->current_annotation = "compute pixel centers";
   fs_reg int_pixel_x = fs_reg(this, glsl_type::uint_type);
   fs_reg int_pixel_y = fs_reg(this, glsl_type::uint_type);
   int_pixel_x.type = BRW_REGISTER_TYPE_UW;
   int_pixel_y.type = BRW_REGISTER_TYPE_UW;
   emit(ADD(int_pixel_x,
            fs_reg(stride(suboffset(g1_uw, 4), 2, 4, 0)),
            fs_reg(brw_imm_v(0x10101010))));
   emit(ADD(int_pixel_y,
            fs_reg(stride(suboffset(g1_uw, 5), 2, 4, 0)),
            fs_reg(brw_imm_v(0x11001100))));

   /* As of gen6, we can no longer mix float and int sources.  We have
    * to turn the integer pixel centers into floats for their actual
    * use.
    */
   this->pixel_x = fs_reg(this, glsl_type::float_type);
   this->pixel_y = fs_reg(this, glsl_type::float_type);
   emit(MOV(this->pixel_x, int_pixel_x));
   emit(MOV(this->pixel_y, int_pixel_y));

   this->current_annotation = "compute pos.w";
   this->pixel_w = fs_reg(brw_vec8_grf(c->source_w_reg, 0));
   this->wpos_w = fs_reg(this, glsl_type::float_type);
   emit_math(SHADER_OPCODE_RCP, this->wpos_w, this->pixel_w);

   for (int i = 0; i < BRW_WM_BARYCENTRIC_INTERP_MODE_COUNT; ++i) {
      uint8_t reg = c->barycentric_coord_reg[i];
      this->delta_x[i] = fs_reg(brw_vec8_grf(reg, 0));
      this->delta_y[i] = fs_reg(brw_vec8_grf(reg + 1, 0));
   }

   this->current_annotation = NULL;
}

void
fs_visitor::emit_color_write(int target, int index, int first_color_mrf)
{
   int reg_width = dispatch_width / 8;
   fs_inst *inst;
   fs_reg color = outputs[target];
   fs_reg mrf;

   /* If there's no color data to be written, skip it. */
   if (color.file == BAD_FILE)
      return;

   color.reg_offset += index;

   if (dispatch_width == 8 || brw->gen >= 6) {
      /* SIMD8 write looks like:
       * m + 0: r0
       * m + 1: r1
       * m + 2: g0
       * m + 3: g1
       *
       * gen6 SIMD16 DP write looks like:
       * m + 0: r0
       * m + 1: r1
       * m + 2: g0
       * m + 3: g1
       * m + 4: b0
       * m + 5: b1
       * m + 6: a0
       * m + 7: a1
       */
      inst = emit(MOV(fs_reg(MRF, first_color_mrf + index * reg_width,
                             color.type),
                      color));
      inst->saturate = c->key.clamp_fragment_color;
   } else {
      /* pre-gen6 SIMD16 single source DP write looks like:
       * m + 0: r0
       * m + 1: g0
       * m + 2: b0
       * m + 3: a0
       * m + 4: r1
       * m + 5: g1
       * m + 6: b1
       * m + 7: a1
       */
      if (brw->has_compr4) {
	 /* By setting the high bit of the MRF register number, we
	  * indicate that we want COMPR4 mode - instead of doing the
	  * usual destination + 1 for the second half we get
	  * destination + 4.
	  */
	 inst = emit(MOV(fs_reg(MRF, BRW_MRF_COMPR4 + first_color_mrf + index,
                                color.type),
                         color));
	 inst->saturate = c->key.clamp_fragment_color;
      } else {
	 push_force_uncompressed();
	 inst = emit(MOV(fs_reg(MRF, first_color_mrf + index, color.type),
                         color));
	 inst->saturate = c->key.clamp_fragment_color;
	 pop_force_uncompressed();

	 inst = emit(MOV(fs_reg(MRF, first_color_mrf + index + 4, color.type),
                         half(color, 1)));
	 inst->force_sechalf = true;
	 inst->saturate = c->key.clamp_fragment_color;
      }
   }
}

static int
cond_for_alpha_func(GLenum func)
{
   switch(func) {
      case GL_GREATER:
         return BRW_CONDITIONAL_G;
      case GL_GEQUAL:
         return BRW_CONDITIONAL_GE;
      case GL_LESS:
         return BRW_CONDITIONAL_L;
      case GL_LEQUAL:
         return BRW_CONDITIONAL_LE;
      case GL_EQUAL:
         return BRW_CONDITIONAL_EQ;
      case GL_NOTEQUAL:
         return BRW_CONDITIONAL_NEQ;
      default:
         assert(!"Not reached");
         return 0;
   }
}

/**
 * Alpha test support for when we compile it into the shader instead
 * of using the normal fixed-function alpha test.
 */
void
fs_visitor::emit_alpha_test()
{
   this->current_annotation = "Alpha test";

   fs_inst *cmp;
   if (c->key.alpha_test_func == GL_ALWAYS)
      return;

   if (c->key.alpha_test_func == GL_NEVER) {
      /* f0.1 = 0 */
      fs_reg some_reg = fs_reg(retype(brw_vec8_grf(0, 0),
                                      BRW_REGISTER_TYPE_UW));
      cmp = emit(CMP(reg_null_f, some_reg, some_reg,
                     BRW_CONDITIONAL_NEQ));
   } else {
      /* RT0 alpha */
      fs_reg color = outputs[0];
      color.reg_offset += 3;

      /* f0.1 &= func(color, ref) */
      cmp = emit(CMP(reg_null_f, color, fs_reg(c->key.alpha_test_ref),
                     cond_for_alpha_func(c->key.alpha_test_func)));
   }
   cmp->predicate = BRW_PREDICATE_NORMAL;
   cmp->flag_subreg = 1;
}

void
fs_visitor::emit_fb_writes()
{
   this->current_annotation = "FB write header";
   bool header_present = true;
   /* We can potentially have a message length of up to 15, so we have to set
    * base_mrf to either 0 or 1 in order to fit in m0..m15.
    */
   int base_mrf = 1;
   int nr = base_mrf;
   int reg_width = dispatch_width / 8;
   bool src0_alpha_to_render_target = false;

   if (do_dual_src) {
      no16("GL_ARB_blend_func_extended not yet supported in SIMD16.");
      if (dispatch_width == 16)
         do_dual_src = false;
   }

   /* From the Sandy Bridge PRM, volume 4, page 198:
    *
    *     "Dispatched Pixel Enables. One bit per pixel indicating
    *      which pixels were originally enabled when the thread was
    *      dispatched. This field is only required for the end-of-
    *      thread message and on all dual-source messages."
    */
   if (brw->gen >= 6 &&
       (brw->is_haswell || brw->gen >= 8 || !this->fp->UsesKill) &&
       !do_dual_src &&
       c->key.nr_color_regions == 1) {
      header_present = false;
   }

   if (header_present) {
      src0_alpha_to_render_target = brw->gen >= 6 &&
				    !do_dual_src &&
                                    c->key.replicate_alpha;
      /* m2, m3 header */
      nr += 2;
   }

   if (c->aa_dest_stencil_reg) {
      push_force_uncompressed();
      emit(MOV(fs_reg(MRF, nr++),
               fs_reg(brw_vec8_grf(c->aa_dest_stencil_reg, 0))));
      pop_force_uncompressed();
   }

   c->prog_data.uses_omask =
      fp->Base.OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_SAMPLE_MASK);
   if(c->prog_data.uses_omask) {
      this->current_annotation = "FB write oMask";
      assert(this->sample_mask.file != BAD_FILE);
      /* Hand over gl_SampleMask. Only lower 16 bits are relevant. */
      emit(FS_OPCODE_SET_OMASK, fs_reg(MRF, nr, BRW_REGISTER_TYPE_UW), this->sample_mask);
      nr += 1;
   }

   /* Reserve space for color. It'll be filled in per MRT below. */
   int color_mrf = nr;
   nr += 4 * reg_width;
   if (do_dual_src)
      nr += 4;
   if (src0_alpha_to_render_target)
      nr += reg_width;

   if (c->source_depth_to_render_target) {
      if (brw->gen == 6) {
	 /* For outputting oDepth on gen6, SIMD8 writes have to be
	  * used.  This would require SIMD8 moves of each half to
	  * message regs, kind of like pre-gen5 SIMD16 FB writes.
	  * Just bail on doing so for now.
	  */
	 no16("Missing support for simd16 depth writes on gen6\n");
      }

      if (prog->OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_DEPTH)) {
	 /* Hand over gl_FragDepth. */
	 assert(this->frag_depth.file != BAD_FILE);
	 emit(MOV(fs_reg(MRF, nr), this->frag_depth));
      } else {
	 /* Pass through the payload depth. */
	 emit(MOV(fs_reg(MRF, nr),
                  fs_reg(brw_vec8_grf(c->source_depth_reg, 0))));
      }
      nr += reg_width;
   }

   if (c->dest_depth_reg) {
      emit(MOV(fs_reg(MRF, nr),
               fs_reg(brw_vec8_grf(c->dest_depth_reg, 0))));
      nr += reg_width;
   }

   if (do_dual_src) {
      fs_reg src0 = this->outputs[0];
      fs_reg src1 = this->dual_src_output;

      this->current_annotation = ralloc_asprintf(this->mem_ctx,
						 "FB write src0");
      for (int i = 0; i < 4; i++) {
	 fs_inst *inst = emit(MOV(fs_reg(MRF, color_mrf + i, src0.type), src0));
	 src0.reg_offset++;
	 inst->saturate = c->key.clamp_fragment_color;
      }

      this->current_annotation = ralloc_asprintf(this->mem_ctx,
						 "FB write src1");
      for (int i = 0; i < 4; i++) {
	 fs_inst *inst = emit(MOV(fs_reg(MRF, color_mrf + 4 + i, src1.type),
                                  src1));
	 src1.reg_offset++;
	 inst->saturate = c->key.clamp_fragment_color;
      }

      if (INTEL_DEBUG & DEBUG_SHADER_TIME)
         emit_shader_time_end();

      fs_inst *inst = emit(FS_OPCODE_FB_WRITE);
      inst->target = 0;
      inst->base_mrf = base_mrf;
      inst->mlen = nr - base_mrf;
      inst->eot = true;
      inst->header_present = header_present;
      if ((brw->gen >= 8 || brw->is_haswell) && fp->UsesKill) {
         inst->predicate = BRW_PREDICATE_NORMAL;
         inst->flag_subreg = 1;
      }

      c->prog_data.dual_src_blend = true;
      this->current_annotation = NULL;
      return;
   }

   for (int target = 0; target < c->key.nr_color_regions; target++) {
      this->current_annotation = ralloc_asprintf(this->mem_ctx,
						 "FB write target %d",
						 target);
      /* If src0_alpha_to_render_target is true, include source zero alpha
       * data in RenderTargetWrite message for targets > 0.
       */
      int write_color_mrf = color_mrf;
      if (src0_alpha_to_render_target && target != 0) {
         fs_inst *inst;
         fs_reg color = outputs[0];
         color.reg_offset += 3;

         inst = emit(MOV(fs_reg(MRF, write_color_mrf, color.type),
                         color));
         inst->saturate = c->key.clamp_fragment_color;
         write_color_mrf = color_mrf + reg_width;
      }

      for (unsigned i = 0; i < this->output_components[target]; i++)
         emit_color_write(target, i, write_color_mrf);

      bool eot = false;
      if (target == c->key.nr_color_regions - 1) {
         eot = true;

         if (INTEL_DEBUG & DEBUG_SHADER_TIME)
            emit_shader_time_end();
      }

      fs_inst *inst = emit(FS_OPCODE_FB_WRITE);
      inst->target = target;
      inst->base_mrf = base_mrf;
      if (src0_alpha_to_render_target && target == 0)
         inst->mlen = nr - base_mrf - reg_width;
      else
         inst->mlen = nr - base_mrf;
      inst->eot = eot;
      inst->header_present = header_present;
      if ((brw->gen >= 8 || brw->is_haswell) && fp->UsesKill) {
         inst->predicate = BRW_PREDICATE_NORMAL;
         inst->flag_subreg = 1;
      }
   }

   if (c->key.nr_color_regions == 0) {
      /* Even if there's no color buffers enabled, we still need to send
       * alpha out the pipeline to our null renderbuffer to support
       * alpha-testing, alpha-to-coverage, and so on.
       */
      emit_color_write(0, 3, color_mrf);

      if (INTEL_DEBUG & DEBUG_SHADER_TIME)
         emit_shader_time_end();

      fs_inst *inst = emit(FS_OPCODE_FB_WRITE);
      inst->base_mrf = base_mrf;
      inst->mlen = nr - base_mrf;
      inst->eot = true;
      inst->header_present = header_present;
      if ((brw->gen >= 8 || brw->is_haswell) && fp->UsesKill) {
         inst->predicate = BRW_PREDICATE_NORMAL;
         inst->flag_subreg = 1;
      }
   }

   this->current_annotation = NULL;
}

void
fs_visitor::resolve_ud_negate(fs_reg *reg)
{
   if (reg->type != BRW_REGISTER_TYPE_UD ||
       !reg->negate)
      return;

   fs_reg temp = fs_reg(this, glsl_type::uint_type);
   emit(MOV(temp, *reg));
   *reg = temp;
}

void
fs_visitor::resolve_bool_comparison(ir_rvalue *rvalue, fs_reg *reg)
{
   if (rvalue->type != glsl_type::bool_type)
      return;

   fs_reg temp = fs_reg(this, glsl_type::bool_type);
   emit(AND(temp, *reg, fs_reg(1)));
   *reg = temp;
}

fs_visitor::fs_visitor(struct brw_context *brw,
                       struct brw_wm_compile *c,
                       struct gl_shader_program *shader_prog,
                       struct gl_fragment_program *fp,
                       unsigned dispatch_width)
   : backend_visitor(brw, shader_prog, &fp->Base, &c->prog_data.base,
                     MESA_SHADER_FRAGMENT),
     dispatch_width(dispatch_width)
{
   this->c = c;
   this->fp = fp;
   this->mem_ctx = ralloc_context(NULL);
   this->failed = false;
   this->simd16_unsupported = false;
   this->no16_msg = NULL;
   this->variable_ht = hash_table_ctor(0,
                                       hash_table_pointer_hash,
                                       hash_table_pointer_compare);

   memset(this->outputs, 0, sizeof(this->outputs));
   memset(this->output_components, 0, sizeof(this->output_components));
   this->first_non_payload_grf = 0;
   this->max_grf = brw->gen >= 7 ? GEN7_MRF_HACK_START : BRW_MAX_GRF;

   this->current_annotation = NULL;
   this->base_ir = NULL;

   this->virtual_grf_sizes = NULL;
   this->virtual_grf_count = 0;
   this->virtual_grf_array_size = 0;
   this->virtual_grf_start = NULL;
   this->virtual_grf_end = NULL;
   this->live_intervals = NULL;
   this->regs_live_at_ip = NULL;

   this->uniforms = 0;
   this->pull_constant_loc = NULL;
   this->push_constant_loc = NULL;

   this->force_uncompressed_stack = 0;

   this->spilled_any_registers = false;
   this->do_dual_src = false;

   if (dispatch_width == 8)
      this->param_size = rzalloc_array(mem_ctx, int, stage_prog_data->nr_params);
}

fs_visitor::~fs_visitor()
{
   ralloc_free(this->mem_ctx);
   hash_table_dtor(this->variable_ht);
}
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d39 1
a39 1
#include "util/register_allocate.h"
d63 1
a63 1
	 reg = emit_frontfacing_interpolation();
d80 1
a80 3
         assert(stage == MESA_SHADER_FRAGMENT);
         brw_wm_prog_key *key = (brw_wm_prog_key*) this->key;
	 for (unsigned int i = 0; i < MAX2(key->nr_color_regions, 1); i++) {
d100 2
a101 1
	    this->outputs[output] = offset(*reg, vector_elements * i);
d112 2
a113 2
       * Some uniforms, such as samplers and atomic counters, have no actual
       * storage, so we should ignore them.
d115 1
a115 1
      if (ir->is_in_uniform_block() || type_size(ir->type) == 0)
d137 1
a137 1
	 reg = emit_samplepos_setup();
d139 1
a139 1
	 reg = emit_sampleid_setup();
d141 1
a141 4
         assert(brw->gen >= 7);
         reg = new(mem_ctx)
            fs_reg(retype(brw_vec8_grf(payload.sample_mask_in_reg, 0),
                          BRW_REGISTER_TYPE_D));
a154 6

   if (!reg) {
      fail("Failed to find variable storage for %s\n", ir->var->name);
      this->result = fs_reg(reg_null_d);
      return;
   }
d165 1
a165 1
   unsigned int off = 0;
d169 1
a169 1
      off += type_size(struct_type->fields.structure[i].type);
d171 1
a171 1
   this->result = offset(this->result, off);
d189 2
a190 2
      assert(src.file == UNIFORM || src.file == GRF || src.file == HW_REG);
      src = offset(src, constant_index->value.i[0] * element_size);
d245 1
a245 1
fs_visitor::emit_minmax(enum brw_conditional_mod conditionalmod, const fs_reg &dst,
d261 3
d267 3
a269 1
   if (ir->operation != ir_unop_saturate)
a271 2
   ir_rvalue *sat_val = ir->operands[0];

d279 2
a280 2
   /* If the last instruction from our accept() generated our
    * src, just set the saturate flag instead of emmitting a separate mov.
d283 5
a287 2
   if (modify && modify->regs_written == modify->dst.width / 8 &&
       modify->can_do_saturate()) {
a289 1
      return true;
d292 2
a293 1
   return false;
a337 129
static int
pack_pixel_offset(float x)
{
   /* Clamp upper end of the range to +7/16. See explanation in non-constant
    * offset case below. */
   int n = MIN2((int)(x * 16), 7);
   return n & 0xf;
}

void
fs_visitor::emit_interpolate_expression(ir_expression *ir)
{
   /* in SIMD16 mode, the pixel interpolator returns coords interleaved
    * 8 channels at a time, same as the barycentric coords presented in
    * the FS payload. this requires a bit of extra work to support.
    */
   no16("interpolate_at_* not yet supported in SIMD16 mode.");

   assert(stage == MESA_SHADER_FRAGMENT);
   brw_wm_prog_key *key = (brw_wm_prog_key*) this->key;

   ir_dereference * deref = ir->operands[0]->as_dereference();
   ir_swizzle * swiz = NULL;
   if (!deref) {
      /* the api does not allow a swizzle here, but the varying packing code
       * may have pushed one into here.
       */
      swiz = ir->operands[0]->as_swizzle();
      assert(swiz);
      deref = swiz->val->as_dereference();
   }
   assert(deref);
   ir_variable * var = deref->variable_referenced();
   assert(var);

   /* 1. collect interpolation factors */

   fs_reg dst_x = fs_reg(this, glsl_type::get_instance(ir->type->base_type, 2, 1));
   fs_reg dst_y = offset(dst_x, 1);

   /* for most messages, we need one reg of ignored data; the hardware requires mlen==1
    * even when there is no payload. in the per-slot offset case, we'll replace this with
    * the proper source data. */
   fs_reg src = fs_reg(this, glsl_type::float_type);
   int mlen = 1;     /* one reg unless overriden */
   int reg_width = dispatch_width / 8;
   fs_inst *inst;

   switch (ir->operation) {
   case ir_unop_interpolate_at_centroid:
      inst = emit(FS_OPCODE_INTERPOLATE_AT_CENTROID, dst_x, src, fs_reg(0u));
      break;

   case ir_binop_interpolate_at_sample: {
      ir_constant *sample_num = ir->operands[1]->as_constant();
      assert(sample_num || !"nonconstant sample number should have been lowered.");

      unsigned msg_data = sample_num->value.i[0] << 4;
      inst = emit(FS_OPCODE_INTERPOLATE_AT_SAMPLE, dst_x, src, fs_reg(msg_data));
      break;
   }

   case ir_binop_interpolate_at_offset: {
      ir_constant *const_offset = ir->operands[1]->as_constant();
      if (const_offset) {
         unsigned msg_data = pack_pixel_offset(const_offset->value.f[0]) |
                            (pack_pixel_offset(const_offset->value.f[1]) << 4);
         inst = emit(FS_OPCODE_INTERPOLATE_AT_SHARED_OFFSET, dst_x, src,
                     fs_reg(msg_data));
      } else {
         /* pack the operands: hw wants offsets as 4 bit signed ints */
         ir->operands[1]->accept(this);
         src = fs_reg(this, glsl_type::ivec2_type);
         fs_reg src2 = src;
         for (int i = 0; i < 2; i++) {
            fs_reg temp = fs_reg(this, glsl_type::float_type);
            emit(MUL(temp, this->result, fs_reg(16.0f)));
            emit(MOV(src2, temp));  /* float to int */

            /* Clamp the upper end of the range to +7/16. ARB_gpu_shader5 requires
             * that we support a maximum offset of +0.5, which isn't representable
             * in a S0.4 value -- if we didn't clamp it, we'd end up with -8/16,
             * which is the opposite of what the shader author wanted.
             *
             * This is legal due to ARB_gpu_shader5's quantization rules:
             *
             * "Not all values of <offset> may be supported; x and y offsets may
             * be rounded to fixed-point values with the number of fraction bits
             * given by the implementation-dependent constant
             * FRAGMENT_INTERPOLATION_OFFSET_BITS"
             */

            fs_inst *inst = emit(BRW_OPCODE_SEL, src2, src2, fs_reg(7));
            inst->conditional_mod = BRW_CONDITIONAL_L; /* min(src2, 7) */

            src2 = offset(src2, 1);
            this->result = offset(this->result, 1);
         }

         mlen = 2 * reg_width;
         inst = emit(FS_OPCODE_INTERPOLATE_AT_PER_SLOT_OFFSET, dst_x, src,
                     fs_reg(0u));
      }
      break;
   }

   default:
      unreachable("not reached");
   }

   inst->mlen = mlen;
   inst->regs_written = 2 * reg_width; /* 2 floats per slot returned */
   inst->pi_noperspective = var->determine_interpolation_mode(key->flat_shade) ==
         INTERP_QUALIFIER_NOPERSPECTIVE;

   /* 2. emit linterp */

   fs_reg res(this, ir->type);
   this->result = res;

   for (int i = 0; i < ir->type->vector_elements; i++) {
      int ch = swiz ? ((*(int *)&swiz->mask) >> 2*i) & 3 : i;
      emit(FS_OPCODE_LINTERP, res,
           dst_x, dst_y,
           fs_reg(interp_reg(var->data.location, ch)));
      res = offset(res, 1);
   }
}

d349 1
a349 4

   /* Deal with the real oddball stuff first */
   switch (ir->operation) {
   case ir_binop_add:
d351 1
a351 24
         return;
      break;

   case ir_triop_csel:
      ir->operands[1]->accept(this);
      op[1] = this->result;
      ir->operands[2]->accept(this);
      op[2] = this->result;

      emit_bool_to_cond_code(ir->operands[0]);

      this->result = fs_reg(this, ir->type);
      inst = emit(SEL(this->result, op[1], op[2]));
      inst->predicate = BRW_PREDICATE_NORMAL;
      return;

   case ir_unop_interpolate_at_centroid:
   case ir_binop_interpolate_at_offset:
   case ir_binop_interpolate_at_sample:
      emit_interpolate_expression(ir);
      return;

   default:
      break;
d380 4
a383 5
      if (ctx->Const.UniformBooleanTrue != 1) {
         emit(NOT(this->result, op[0]));
      } else {
         emit(XOR(this->result, op[0], fs_reg(1u)));
      }
d436 2
a437 1
      unreachable("not reached: should be handled by ir_explog_to_explog2");
d448 1
a448 7
      emit(FS_OPCODE_DDX, this->result, op[0], fs_reg(BRW_DERIVATIVE_BY_HINT));
      break;
   case ir_unop_dFdx_coarse:
      emit(FS_OPCODE_DDX, this->result, op[0], fs_reg(BRW_DERIVATIVE_COARSE));
      break;
   case ir_unop_dFdx_fine:
      emit(FS_OPCODE_DDX, this->result, op[0], fs_reg(BRW_DERIVATIVE_FINE));
d451 1
a451 7
      emit(FS_OPCODE_DDY, this->result, op[0], fs_reg(BRW_DERIVATIVE_BY_HINT));
      break;
   case ir_unop_dFdy_coarse:
      emit(FS_OPCODE_DDY, this->result, op[0], fs_reg(BRW_DERIVATIVE_COARSE));
      break;
   case ir_unop_dFdy_fine:
      emit(FS_OPCODE_DDY, this->result, op[0], fs_reg(BRW_DERIVATIVE_FINE));
d458 2
a459 1
      unreachable("not reached: should be handled by ir_sub_to_add_neg");
d482 1
a482 2
            struct brw_reg acc = retype(brw_acc_reg(dispatch_width),
                                        this->result.type);
d493 1
a493 1
      if (brw->gen == 7)
d496 1
a496 2
      struct brw_reg acc = retype(brw_acc_reg(dispatch_width),
                                  this->result.type);
d498 1
a498 1
      fs_inst *mul = emit(MUL(acc, op[0], op[1]));
a499 21

      /* Until Gen8, integer multiplies read 32-bits from one source, and
       * 16-bits from the other, and relying on the MACH instruction to
       * generate the high bits of the result.
       *
       * On Gen8, the multiply instruction does a full 32x32-bit multiply,
       * but in order to do a 64x64-bit multiply we have to simulate the
       * previous behavior and then use a MACH instruction.
       *
       * FINISHME: Don't use source modifiers on src1.
       */
      if (brw->gen >= 8) {
         assert(mul->src[1].type == BRW_REGISTER_TYPE_D ||
                mul->src[1].type == BRW_REGISTER_TYPE_UD);
         if (mul->src[1].type == BRW_REGISTER_TYPE_D) {
            mul->src[1].type = BRW_REGISTER_TYPE_W;
         } else {
            mul->src[1].type = BRW_REGISTER_TYPE_UW;
         }
      }

d508 1
a508 1
      if (brw->gen == 7)
d511 1
a511 2
      struct brw_reg acc = retype(brw_acc_reg(dispatch_width),
                                  BRW_REGISTER_TYPE_UD);
d518 1
a518 1
      if (brw->gen == 7)
d521 1
a521 2
      struct brw_reg acc = retype(brw_acc_reg(dispatch_width),
                                  BRW_REGISTER_TYPE_UD);
d541 2
a542 4
      if (ctx->Const.UniformBooleanTrue == 1) {
         resolve_bool_comparison(ir->operands[0], &op[0]);
         resolve_bool_comparison(ir->operands[1], &op[1]);
      }
d562 2
a563 1
      unreachable("not reached: should be handled by brw_fs_channel_expressions");
d566 2
a567 1
      unreachable("not reached: should be handled by lower_noise");
d570 2
a571 1
      unreachable("not reached: should be handled by lower_quadop_vector");
d574 2
a575 1
      unreachable("not reached: should be handled by lower_vec_index_to_cond_assign()");
d578 2
a579 1
      unreachable("not reached: should be handled by lower_vector_insert()");
d582 2
a583 1
      unreachable("not reached: should be handled by ldexp_to_arith()");
d619 3
a621 10
      if (ctx->Const.UniformBooleanTrue != 1) {
         op[0].type = BRW_REGISTER_TYPE_UD;
         this->result.type = BRW_REGISTER_TYPE_UD;
         emit(AND(this->result, op[0], fs_reg(0x3f800000u)));
         this->result.type = BRW_REGISTER_TYPE_F;
      } else {
         temp = fs_reg(this, glsl_type::int_type);
         emit(AND(temp, op[0], fs_reg(1u)));
         emit(MOV(this->result, temp));
      }
d667 2
a668 1
      unreachable("not reached: should be handled by lower_packing_builtins");
a704 4
   case ir_unop_saturate:
      inst = emit(MOV(this->result, op[0]));
      inst->saturate = true;
      break;
d718 1
a718 1
      unreachable("not reached: should be handled by "
d720 1
d752 1
a752 1
      ir_constant *const_uniform_block = ir->operands[0]->as_constant();
d754 2
a755 26
      fs_reg surf_index;

      if (const_uniform_block) {
         /* The block index is a constant, so just emit the binding table entry
          * as an immediate.
          */
         surf_index = fs_reg(stage_prog_data->binding_table.ubo_start +
                                 const_uniform_block->value.u[0]);
      } else {
         /* The block index is not a constant. Evaluate the index expression
          * per-channel and add the base UBO index; the generator will select
          * a value from any live channel.
          */
         surf_index = fs_reg(this, glsl_type::uint_type);
         emit(ADD(surf_index, op[0],
                  fs_reg(stage_prog_data->binding_table.ubo_start)))
            ->force_writemask_all = true;

         /* Assume this may touch any UBO. It would be nice to provide
          * a tighter bound, but the array information is already lowered away.
          */
         brw_mark_surface_used(prog_data,
                               stage_prog_data->binding_table.ubo_start +
                               shader_prog->NumUniformBlocks - 1);
      }

d761 1
a761 1
         emit(new(mem_ctx) fs_inst(FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD, 8,
d781 1
a781 1
            result = offset(result, 1);
d795 1
a795 1
            result = offset(result, 1);
d815 3
a817 4
   case ir_unop_interpolate_at_centroid:
   case ir_binop_interpolate_at_offset:
   case ir_binop_interpolate_at_sample:
      unreachable("already handled above");
d840 2
a841 2
	 l = offset(l, 1);
	 r = offset(r, 1);
d865 2
a866 1
      unreachable("not reached");
d943 1
a943 1
	    r = offset(r, 1);
d945 1
a945 1
	 l = offset(l, 1);
d953 2
a954 5
fs_visitor::emit_texture_gen4(ir_texture_opcode op, fs_reg dst,
                              fs_reg coordinate, int coord_components,
                              fs_reg shadow_c,
                              fs_reg lod, fs_reg dPdy, int grad_components,
                              uint32_t sampler)
d964 2
a965 2
   if (shadow_c.file != BAD_FILE) {
      for (int i = 0; i < coord_components; i++) {
d967 1
a967 1
	 coordinate = offset(coordinate, 1);
d973 1
a973 1
      for (int i = coord_components; i < 3; i++) {
d978 1
a978 1
      if (op == ir_tex) {
d984 1
a984 1
      } else if (op == ir_txb || op == ir_txl) {
d988 1
a988 1
         unreachable("Should not get here.");
d993 2
a994 2
   } else if (op == ir_tex) {
      for (int i = 0; i < coord_components; i++) {
d996 1
a996 1
	 coordinate = offset(coordinate, 1);
d999 1
a999 1
      for (int i = coord_components; i<3; i++) {
d1004 1
a1004 1
   } else if (op == ir_txd) {
d1007 1
a1007 1
      for (int i = 0; i < coord_components; i++) {
d1009 1
a1009 1
	 coordinate = offset(coordinate, 1);
d1012 1
a1012 1
      mlen += MAX2(coord_components, 2);
d1028 1
a1028 1
      for (int i = 0; i < grad_components; i++) {
d1030 1
a1030 1
	 dPdx = offset(dPdx, 1);
d1032 1
a1032 1
      mlen += MAX2(grad_components, 2);
d1034 1
a1034 1
      for (int i = 0; i < grad_components; i++) {
d1036 1
a1036 1
	 dPdy = offset(dPdy, 1);
d1038 2
a1039 2
      mlen += MAX2(grad_components, 2);
   } else if (op == ir_txs) {
d1049 1
a1049 1
      assert(op == ir_txb || op == ir_txl || op == ir_txf);
d1051 1
a1051 1
      for (int i = 0; i < coord_components; i++) {
d1054 1
a1054 1
	 coordinate = offset(coordinate, 1);
d1060 1
a1060 1
      for (int i = coord_components; i < 3; i++) {
d1080 4
a1083 1
      dst = fs_reg(GRF, virtual_grf_alloc(8), orig_dst.type);
d1086 20
a1105 8
   enum opcode opcode;
   switch (op) {
   case ir_tex: opcode = SHADER_OPCODE_TEX; break;
   case ir_txb: opcode = FS_OPCODE_TXB; break;
   case ir_txl: opcode = SHADER_OPCODE_TXL; break;
   case ir_txd: opcode = SHADER_OPCODE_TXD; break;
   case ir_txs: opcode = SHADER_OPCODE_TXS; break;
   case ir_txf: opcode = SHADER_OPCODE_TXF; break;
d1107 1
a1107 1
      unreachable("not reached");
a1108 2

   fs_inst *inst = emit(opcode, dst, reg_undef, fs_reg(sampler));
d1117 2
a1118 2
	 orig_dst = offset(orig_dst, 1);
	 dst = offset(dst, 2);
d1134 3
a1136 6
fs_visitor::emit_texture_gen5(ir_texture_opcode op, fs_reg dst,
                              fs_reg coordinate, int vector_elements,
                              fs_reg shadow_c,
                              fs_reg lod, fs_reg lod2, int grad_components,
                              fs_reg sample_index, uint32_t sampler,
                              bool has_offset)
d1138 2
d1142 2
d1145 1
a1145 4
   fs_reg message(MRF, 2, BRW_REGISTER_TYPE_F, dispatch_width);
   fs_reg msg_coords = message;

   if (has_offset) {
d1150 2
a1151 1
      message.reg--;
d1155 3
a1157 2
      emit(MOV(retype(offset(msg_coords, i), coordinate.type), coordinate));
      coordinate = offset(coordinate, 1);
d1159 1
a1159 2
   fs_reg msg_end = offset(msg_coords, vector_elements);
   fs_reg msg_lod = offset(msg_coords, 4);
d1161 5
a1165 5
   if (shadow_c.file != BAD_FILE) {
      fs_reg msg_shadow = msg_lod;
      emit(MOV(msg_shadow, shadow_c));
      msg_lod = offset(msg_shadow, 1);
      msg_end = msg_lod;
d1168 2
a1169 2
   enum opcode opcode;
   switch (op) {
d1171 1
a1171 1
      opcode = SHADER_OPCODE_TEX;
d1174 3
a1176 2
      emit(MOV(msg_lod, lod));
      msg_end = offset(msg_lod, 1);
d1178 1
a1178 1
      opcode = FS_OPCODE_TXB;
d1181 3
a1183 2
      emit(MOV(msg_lod, lod));
      msg_end = offset(msg_lod, 1);
d1185 1
a1185 1
      opcode = SHADER_OPCODE_TXL;
d1188 2
d1199 8
a1206 9
      msg_end = msg_lod;
      for (int i = 0; i < grad_components; i++) {
         emit(MOV(msg_end, lod));
         lod = offset(lod, 1);
         msg_end = offset(msg_end, 1);

         emit(MOV(msg_end, lod2));
         lod2 = offset(lod2, 1);
         msg_end = offset(msg_end, 1);
d1209 1
a1209 1
      opcode = SHADER_OPCODE_TXD;
d1213 3
a1215 5
      msg_lod = retype(msg_end, BRW_REGISTER_TYPE_UD);
      emit(MOV(msg_lod, lod));
      msg_end = offset(msg_lod, 1);

      opcode = SHADER_OPCODE_TXS;
d1218 3
a1220 5
      msg_lod = msg_end;
      emit(MOV(retype(msg_lod, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
      msg_end = offset(msg_lod, 1);

      opcode = SHADER_OPCODE_TXS;
d1223 3
a1225 5
      msg_lod = offset(msg_coords, 3);
      emit(MOV(retype(msg_lod, BRW_REGISTER_TYPE_UD), lod));
      msg_end = offset(msg_lod, 1);

      opcode = SHADER_OPCODE_TXF;
d1228 2
a1229 1
      msg_lod = offset(msg_coords, 3);
d1231 1
a1231 1
      emit(MOV(retype(msg_lod, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
d1233 3
a1235 4
      emit(MOV(retype(offset(msg_lod, 1), BRW_REGISTER_TYPE_UD), sample_index));
      msg_end = offset(msg_lod, 2);

      opcode = SHADER_OPCODE_TXF_CMS;
d1238 1
a1238 1
      opcode = SHADER_OPCODE_LOD;
d1241 1
a1241 1
      opcode = SHADER_OPCODE_TG4;
d1244 2
a1245 1
      unreachable("not reached");
d1247 2
a1248 4

   fs_inst *inst = emit(opcode, dst, reg_undef, fs_reg(sampler));
   inst->base_mrf = message.reg;
   inst->mlen = msg_end.reg - message.reg;
d1250 1
a1250 1
   inst->regs_written = 4 * reg_width;
d1252 1
a1252 1
   if (inst->mlen > MAX_SAMPLER_MESSAGE_SIZE) {
a1259 9
static bool
is_high_sampler(struct brw_context *brw, fs_reg sampler)
{
   if (brw->gen < 8 && !brw->is_haswell)
      return false;

   return sampler.file != IMM || sampler.fixed_hw_reg.dw1.ud >= 16;
}

d1261 3
a1263 6
fs_visitor::emit_texture_gen7(ir_texture_opcode op, fs_reg dst,
                              fs_reg coordinate, int coord_components,
                              fs_reg shadow_c,
                              fs_reg lod, fs_reg lod2, int grad_components,
                              fs_reg sample_index, fs_reg mcs, fs_reg sampler,
                              fs_reg offset_value)
d1268 2
a1269 5
   fs_reg *sources = ralloc_array(mem_ctx, fs_reg, MAX_SAMPLER_MESSAGE_SIZE);
   for (int i = 0; i < MAX_SAMPLER_MESSAGE_SIZE; i++) {
      sources[i] = fs_reg(this, glsl_type::float_type);
   }
   int length = 0;
d1271 1
a1271 2
   if (op == ir_tg4 || offset_value.file != BAD_FILE ||
       is_high_sampler(brw, sampler)) {
d1283 1
a1283 2
      sources[0] = fs_reg(GRF, virtual_grf_alloc(1), BRW_REGISTER_TYPE_UD);
      length++;
d1286 3
a1288 3
   if (shadow_c.file != BAD_FILE) {
      emit(MOV(sources[length], shadow_c));
      length++;
d1291 1
a1291 2
   bool has_nonconstant_offset =
      offset_value.file != BAD_FILE && offset_value.file != IMM;
d1295 1
a1295 1
   switch (op) {
d1300 2
a1301 2
      emit(MOV(sources[length], lod));
      length++;
d1304 2
a1305 2
      emit(MOV(sources[length], lod));
      length++;
d1313 4
a1316 4
      for (int i = 0; i < coord_components; i++) {
	 emit(MOV(sources[length], coordinate));
	 coordinate = offset(coordinate, 1);
	 length++;
d1321 8
a1328 8
         if (i < grad_components) {
            emit(MOV(sources[length], lod));
            lod = offset(lod, 1);
            length++;

            emit(MOV(sources[length], lod2));
            lod2 = offset(lod2, 1);
            length++;
d1336 2
a1337 2
      emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_UD), lod));
      length++;
d1340 2
a1341 2
      emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_UD), fs_reg(0u)));
      length++;
d1345 11
a1355 11
      emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_D), coordinate));
      coordinate = offset(coordinate, 1);
      length++;

      emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_D), lod));
      length++;

      for (int i = 1; i < coord_components; i++) {
	 emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_D), coordinate));
	 coordinate = offset(coordinate, 1);
	 length++;
d1361 2
a1362 2
      emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_UD), sample_index));
      length++;
d1365 2
a1366 2
      emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_UD), mcs));
      length++;
d1371 4
a1374 4
      for (int i = 0; i < coord_components; i++) {
         emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_D), coordinate));
         coordinate = offset(coordinate, 1);
         length++;
d1381 1
a1381 1
         if (shadow_c.file != BAD_FILE)
d1385 3
d1389 3
a1391 3
            emit(MOV(sources[length], coordinate));
            coordinate = offset(coordinate, 1);
            length++;
d1395 3
a1397 3
            emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_D), offset_value));
            offset_value = offset(offset_value, 1);
            length++;
d1400 4
a1403 4
         if (coord_components == 3) { /* r if present */
            emit(MOV(sources[length], coordinate));
            coordinate = offset(coordinate, 1);
            length++;
d1412 5
a1416 5
   if (!coordinate_done) {
      for (int i = 0; i < coord_components; i++) {
         emit(MOV(sources[length], coordinate));
         coordinate = offset(coordinate, 1);
         length++;
a1419 10
   int mlen;
   if (reg_width == 2)
      mlen = length * reg_width - header_present;
   else
      mlen = length * reg_width;

   fs_reg src_payload = fs_reg(GRF, virtual_grf_alloc(mlen),
                               BRW_REGISTER_TYPE_F);
   emit(LOAD_PAYLOAD(src_payload, sources, length));

d1421 11
a1431 11
   enum opcode opcode;
   switch (op) {
   case ir_tex: opcode = SHADER_OPCODE_TEX; break;
   case ir_txb: opcode = FS_OPCODE_TXB; break;
   case ir_txl: opcode = SHADER_OPCODE_TXL; break;
   case ir_txd: opcode = SHADER_OPCODE_TXD; break;
   case ir_txf: opcode = SHADER_OPCODE_TXF; break;
   case ir_txf_ms: opcode = SHADER_OPCODE_TXF_CMS; break;
   case ir_txs: opcode = SHADER_OPCODE_TXS; break;
   case ir_query_levels: opcode = SHADER_OPCODE_TXS; break;
   case ir_lod: opcode = SHADER_OPCODE_LOD; break;
d1434 1
a1434 1
         opcode = SHADER_OPCODE_TG4_OFFSET;
d1436 1
a1436 1
         opcode = SHADER_OPCODE_TG4;
a1437 2
   default:
      unreachable("not reached");
a1438 1
   fs_inst *inst = emit(opcode, dst, src_payload, sampler);
d1440 4
a1443 1
   inst->mlen = mlen;
d1445 1
a1445 1
   inst->regs_written = 4 * reg_width;
d1447 1
d1457 2
a1458 2
fs_visitor::rescale_texcoord(fs_reg coordinate, const glsl_type *coord_type,
                             bool is_rect, uint32_t sampler, int texunit)
a1462 4
   const struct brw_sampler_prog_key_data *tex =
      (stage == MESA_SHADER_FRAGMENT) ?
      &((brw_wm_prog_key*) this->key)->tex : NULL;
   assert(tex);
d1470 2
a1471 2
        (brw->gen >= 6 && (tex->gl_clamp_mask[0] & (1 << sampler) ||
                           tex->gl_clamp_mask[1] & (1 << sampler))))) {
d1491 1
a1491 1
             &prog->Parameters->ParameterValues[index][0]) {
d1504 1
a1504 1
            &prog->Parameters->ParameterValues[index][0];
d1506 1
a1506 1
            &prog->Parameters->ParameterValues[index][1];
d1515 1
a1515 1
      fs_reg dst = fs_reg(this, coord_type);
d1520 2
a1521 2
      dst = offset(dst, 1);
      src = offset(src, 1);
d1532 1
a1532 1
	 if (tex->gl_clamp_mask[i] & (1 << sampler)) {
d1534 1
a1534 1
	    chan = offset(chan, i);
d1555 4
a1558 3
   if (coord_type && needs_gl_clamp) {
      for (unsigned int i = 0; i < MIN2(coord_type->vector_elements, 3); i++) {
	 if (tex->gl_clamp_mask[i] & (1 << sampler)) {
d1560 1
a1560 1
	    chan = offset(chan, i);
d1572 1
a1572 1
fs_visitor::emit_mcs_fetch(fs_reg coordinate, int components, fs_reg sampler)
d1575 1
a1575 2
   fs_reg payload = fs_reg(GRF, virtual_grf_alloc(components * reg_width),
                           BRW_REGISTER_TYPE_F);
d1577 1
a1577 1
   fs_reg *sources = ralloc_array(mem_ctx, fs_reg, components);
d1579 5
a1583 5
   /* parameters are: u, v, r; missing parameters are treated as zero */
   for (int i = 0; i < components; i++) {
      sources[i] = fs_reg(this, glsl_type::float_type);
      emit(MOV(retype(sources[i], BRW_REGISTER_TYPE_D), coordinate));
      coordinate = offset(coordinate, 1);
d1586 2
a1587 3
   emit(LOAD_PAYLOAD(payload, sources, components));

   fs_inst *inst = emit(SHADER_OPCODE_TXF_MCS, dest, payload, sampler);
d1589 1
a1589 1
   inst->mlen = components * reg_width;
d1591 4
a1594 4
   inst->regs_written = 4 * reg_width; /* we only care about one reg of
                                        * response, but the sampler always
                                        * writes 4/8
                                        */
d1600 2
a1601 18
fs_visitor::emit_texture(ir_texture_opcode op,
                         const glsl_type *dest_type,
                         fs_reg coordinate, const struct glsl_type *coord_type,
                         fs_reg shadow_c,
                         fs_reg lod, fs_reg lod2, int grad_components,
                         fs_reg sample_index,
                         fs_reg offset_value, unsigned offset_components,
                         fs_reg mcs,
                         int gather_component,
                         bool is_cube_array,
                         bool is_rect,
                         uint32_t sampler,
                         fs_reg sampler_reg, int texunit)
{
   const struct brw_sampler_prog_key_data *tex =
      (stage == MESA_SHADER_FRAGMENT) ?
      &((brw_wm_prog_key*) this->key)->tex : NULL;
   assert(tex);
d1604 9
a1612 1
   if (op == ir_tg4) {
d1616 2
a1617 1
      int swiz = GET_SWZ(tex->swizzles[sampler], gather_component);
d1625 1
a1625 1
            res = offset(res, 1);
a1630 118
   if (coordinate.file != BAD_FILE) {
      /* FINISHME: Texture coordinate rescaling doesn't work with non-constant
       * samplers.  This should only be a problem with GL_CLAMP on Gen7.
       */
      coordinate = rescale_texcoord(coordinate, coord_type, is_rect,
                                    sampler, texunit);
   }

   /* Writemasking doesn't eliminate channels on SIMD8 texture
    * samples, so don't worry about them.
    */
   fs_reg dst(this, glsl_type::get_instance(dest_type->base_type, 4, 1));

   int coord_components = coord_type ? coord_type->vector_elements : 0;

   if (brw->gen >= 7) {
      inst = emit_texture_gen7(op, dst, coordinate, coord_components,
                               shadow_c, lod, lod2, grad_components,
                               sample_index, mcs, sampler_reg,
                               offset_value);
   } else if (brw->gen >= 5) {
      inst = emit_texture_gen5(op, dst, coordinate, coord_components,
                               shadow_c, lod, lod2, grad_components,
                               sample_index, sampler,
                               offset_value.file != BAD_FILE);
   } else {
      inst = emit_texture_gen4(op, dst, coordinate, coord_components,
                               shadow_c, lod, lod2, grad_components,
                               sampler);
   }

   if (shadow_c.file != BAD_FILE)
      inst->shadow_compare = true;

   if (offset_value.file == IMM)
      inst->texture_offset = offset_value.fixed_hw_reg.dw1.ud;

   if (op == ir_tg4) {
      inst->texture_offset |=
         gather_channel(gather_component, sampler) << 16; /* M0.2:16-17 */

      if (brw->gen == 6)
         emit_gen6_gather_wa(tex->gen6_gather_wa[sampler], dst);
   }

   /* fixup #layers for cube map arrays */
   if (op == ir_txs && is_cube_array) {
      fs_reg depth = offset(dst, 2);
      fs_reg fixed_depth = fs_reg(this, glsl_type::int_type);
      emit_math(SHADER_OPCODE_INT_QUOTIENT, fixed_depth, depth, fs_reg(6));

      fs_reg *fixed_payload = ralloc_array(mem_ctx, fs_reg, inst->regs_written);
      int components = inst->regs_written / (dst.width / 8);
      for (int i = 0; i < components; i++) {
         if (i == 2) {
            fixed_payload[i] = fixed_depth;
         } else {
            fixed_payload[i] = offset(dst, i);
         }
      }
      emit(LOAD_PAYLOAD(dst, fixed_payload, components));
   }

   swizzle_result(op, dest_type->vector_elements, dst, sampler);
}

void
fs_visitor::visit(ir_texture *ir)
{
   const struct brw_sampler_prog_key_data *tex =
      (stage == MESA_SHADER_FRAGMENT) ?
      &((brw_wm_prog_key*) this->key)->tex : NULL;
   assert(tex);

   uint32_t sampler =
      _mesa_get_sampler_uniform_value(ir->sampler, shader_prog, prog);

   ir_rvalue *nonconst_sampler_index =
      _mesa_get_sampler_array_nonconst_index(ir->sampler);

   /* Handle non-constant sampler array indexing */
   fs_reg sampler_reg;
   if (nonconst_sampler_index) {
      /* The highest sampler which may be used by this operation is
       * the last element of the array. Mark it here, because the generator
       * doesn't have enough information to determine the bound.
       */
      uint32_t array_size = ir->sampler->as_dereference_array()
         ->array->type->array_size();

      uint32_t max_used = sampler + array_size - 1;
      if (ir->op == ir_tg4 && brw->gen < 8) {
         max_used += stage_prog_data->binding_table.gather_texture_start;
      } else {
         max_used += stage_prog_data->binding_table.texture_start;
      }

      brw_mark_surface_used(prog_data, max_used);

      /* Emit code to evaluate the actual indexing expression */
      nonconst_sampler_index->accept(this);
      fs_reg temp(this, glsl_type::uint_type);
      emit(ADD(temp, this->result, fs_reg(sampler)))
            ->force_writemask_all = true;
      sampler_reg = temp;
   } else {
      /* Single sampler, or constant array index; the indexing expression
       * is just an immediate.
       */
      sampler_reg = fs_reg(sampler);
   }

   /* FINISHME: We're failing to recompile our programs when the sampler is
    * updated.  This only matters for the texture rectangle scale parameters
    * (pre-gen6, or gen6+ with GL_CLAMP).
    */
   int texunit = prog->SamplerUnits[sampler];

a1641 1
   const glsl_type *coord_type = NULL;
a1642 1
      coord_type = ir->coordinate->type;
d1644 5
a1648 1
      coordinate = this->result;
a1656 19
   fs_reg offset_value;
   int offset_components = 0;
   if (ir->offset) {
      ir_constant *const_offset = ir->offset->as_constant();
      if (const_offset) {
         /* Store the header bitfield in an IMM register.  This allows us to
          * use offset_value.file to distinguish between no offset, a constant
          * offset, and a non-constant offset.
          */
         offset_value =
            fs_reg(brw_texture_offset(ctx, const_offset->value.i,
                                      const_offset->type->vector_elements));
      } else {
         ir->offset->accept(this);
         offset_value = this->result;
      }
      offset_components = ir->offset->type->vector_elements;
   }

a1657 1
   int grad_components = 0;
a1673 2

      grad_components = ir->lod_info.grad.dPdx->type->vector_elements;
d1685 2
a1686 3
      if (brw->gen >= 7 && tex->compressed_multisample_layout_mask & (1<<sampler))
         mcs = emit_mcs_fetch(coordinate, ir->coordinate->type->vector_elements,
                              sampler_reg);
d1691 1
a1691 1
      unreachable("Unrecognized texture opcode");
d1694 19
a1712 1
   int gather_component = 0;
d1714 3
a1716 1
      gather_component = ir->lod_info.component->as_constant()->value.i[0];
d1718 17
a1734 2
   bool is_rect =
      ir->sampler->type->sampler_dimensionality == GLSL_SAMPLER_DIM_RECT;
d1736 1
a1736 8
   bool is_cube_array =
      ir->sampler->type->sampler_dimensionality == GLSL_SAMPLER_DIM_CUBE &&
      ir->sampler->type->sampler_array;

   emit_texture(ir->op, ir->type, coordinate, coord_type, shadow_comparitor,
                lod, lod2, grad_components, sample_index, offset_value,
                offset_components, mcs, gather_component,
                is_cube_array, is_rect, sampler, sampler_reg, texunit);
d1765 1
a1765 1
      dst = offset(dst, 1);
d1773 1
a1773 1
fs_visitor::gather_channel(int orig_chan, uint32_t sampler)
d1775 2
a1776 5
   const struct brw_sampler_prog_key_data *tex =
      (stage == MESA_SHADER_FRAGMENT) ?
      &((brw_wm_prog_key*) this->key)->tex : NULL;
   assert(tex);
   int swiz = GET_SWZ(tex->swizzles[sampler], orig_chan);
d1783 1
a1783 1
         if (tex->gather_channel_quirk_mask & (1<<sampler))
d1789 2
a1790 1
         unreachable("Not reached"); /* zero, one swizzles handled already */
d1799 1
a1799 2
fs_visitor::swizzle_result(ir_texture_opcode op, int dest_components,
                           fs_reg orig_val, uint32_t sampler)
d1801 1
a1801 1
   if (op == ir_query_levels) {
d1803 2
a1804 1
      this->result = offset(orig_val, 3);
d1813 1
a1813 1
   if (op == ir_txs || op == ir_lod || op == ir_tg4)
d1816 1
a1816 6
   const struct brw_sampler_prog_key_data *tex =
      (stage == MESA_SHADER_FRAGMENT) ?
      &((brw_wm_prog_key*) this->key)->tex : NULL;
   assert(tex);

   if (dest_components == 1) {
d1818 2
a1819 1
   } else if (tex->swizzles[sampler] != SWIZZLE_NOOP) {
a1820 1
      swizzled_result.type = orig_val.type;
d1823 1
a1823 1
	 int swiz = GET_SWZ(tex->swizzles[sampler], i);
d1825 1
a1825 1
	 l = offset(l, i);
d1832 3
a1834 2
            emit(MOV(l, offset(orig_val,
                               GET_SWZ(tex->swizzles[sampler], i))));
d1848 1
a1848 1
      this->result = offset(this->result, ir->mask.x);
d1874 3
a1876 2
      emit(MOV(result, offset(channel, swiz)));
      result = offset(result, 1);
d1899 5
a1903 1
       * Only jump if all relevant channels have been discarded.
d1907 1
a1907 4

      discard_jump->predicate = (dispatch_width == 8)
                                ? BRW_PREDICATE_ALIGN1_ANY8H
                                : BRW_PREDICATE_ALIGN1_ANY16H;
d1935 2
a1936 2
	    src_reg = offset(src_reg, 1);
	    dst_reg = offset(dst_reg, 1);
d1940 2
a1941 1
      foreach_in_list(ir_constant, field, &ir->components) {
d1950 2
a1951 2
	    src_reg = offset(src_reg, 1);
	    dst_reg = offset(dst_reg, 1);
d1969 1
a1969 3
            emit(MOV(dst_reg,
                     fs_reg(ir->value.b[i] != 0 ? ctx->Const.UniformBooleanTrue
                                                : 0u)));
d1972 1
a1972 1
	    unreachable("Non-float/uint/int/bool constant");
d1974 1
a1974 1
	 dst_reg = offset(dst_reg, 1);
d1986 6
a1991 2
   if (!expr || expr->operation == ir_binop_ubo_load) {
      ir->accept(this);
d1993 3
a1995 4
      fs_inst *inst = emit(AND(reg_null_d, this->result, fs_reg(1)));
      inst->conditional_mod = BRW_CONDITIONAL_NZ;
      return;
   }
d1997 2
a1998 2
   fs_reg op[3];
   fs_inst *inst;
d2000 2
a2001 3
   assert(expr->get_num_operands() <= 3);
   for (unsigned int i = 0; i < expr->get_num_operands(); i++) {
      assert(expr->operands[i]->type->is_scalar());
d2003 5
a2007 2
      expr->operands[i]->accept(this);
      op[i] = this->result;
d2009 8
a2016 2
      resolve_ud_negate(&op[i]);
   }
d2018 8
a2025 5
   switch (expr->operation) {
   case ir_unop_logic_not:
      inst = emit(AND(reg_null_d, op[0], fs_reg(1)));
      inst->conditional_mod = BRW_CONDITIONAL_Z;
      break;
d2027 10
a2036 11
   case ir_binop_logic_xor:
      if (ctx->Const.UniformBooleanTrue == 1) {
         fs_reg dst = fs_reg(this, glsl_type::uint_type);
         emit(XOR(dst, op[0], op[1]));
         inst = emit(AND(reg_null_d, dst, fs_reg(1u)));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
      } else {
         inst = emit(XOR(reg_null_d, op[0], op[1]));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
      }
      break;
d2038 3
a2040 11
   case ir_binop_logic_or:
      if (ctx->Const.UniformBooleanTrue == 1) {
         fs_reg dst = fs_reg(this, glsl_type::uint_type);
         emit(OR(dst, op[0], op[1]));
         inst = emit(AND(reg_null_d, dst, fs_reg(1u)));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
      } else {
         inst = emit(OR(reg_null_d, op[0], op[1]));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
      }
      break;
d2042 4
a2045 9
   case ir_binop_logic_and:
      if (ctx->Const.UniformBooleanTrue == 1) {
         fs_reg dst = fs_reg(this, glsl_type::uint_type);
         emit(AND(dst, op[0], op[1]));
         inst = emit(AND(reg_null_d, dst, fs_reg(1u)));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
      } else {
         inst = emit(AND(reg_null_d, op[0], op[1]));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
d2047 2
a2048 1
      break;
d2050 1
a2050 8
   case ir_unop_f2b:
      if (brw->gen >= 6) {
         emit(CMP(reg_null_d, op[0], fs_reg(0.0f), BRW_CONDITIONAL_NZ));
      } else {
         inst = emit(MOV(reg_null_f, op[0]));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
      }
      break;
d2052 2
a2053 45
   case ir_unop_i2b:
      if (brw->gen >= 6) {
         emit(CMP(reg_null_d, op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
      } else {
         inst = emit(MOV(reg_null_d, op[0]));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
      }
      break;

   case ir_binop_greater:
   case ir_binop_gequal:
   case ir_binop_less:
   case ir_binop_lequal:
   case ir_binop_equal:
   case ir_binop_all_equal:
   case ir_binop_nequal:
   case ir_binop_any_nequal:
      if (ctx->Const.UniformBooleanTrue == 1) {
         resolve_bool_comparison(expr->operands[0], &op[0]);
         resolve_bool_comparison(expr->operands[1], &op[1]);
      }

      emit(CMP(reg_null_d, op[0], op[1],
               brw_conditional_for_comparison(expr->operation)));
      break;

   case ir_triop_csel: {
      /* Expand the boolean condition into the flag register. */
      inst = emit(MOV(reg_null_d, op[0]));
      inst->conditional_mod = BRW_CONDITIONAL_NZ;

      /* Select which boolean to return. */
      fs_reg temp(this, expr->operands[1]->type);
      inst = emit(SEL(temp, op[1], op[2]));
      inst->predicate = BRW_PREDICATE_NORMAL;

      /* Expand the result to a condition code. */
      inst = emit(MOV(reg_null_d, temp));
      inst->conditional_mod = BRW_CONDITIONAL_NZ;
      break;
   }

   default:
      unreachable("not reached");
   }
d2065 2
a2066 2
   if (expr && expr->operation != ir_binop_ubo_load) {
      fs_reg op[3];
d2070 1
a2070 1
      assert(expr->get_num_operands() <= 3);
a2079 3
         emit(IF(op[0], fs_reg(0), BRW_CONDITIONAL_Z));
         return;

a2080 3
         emit(IF(op[0], op[1], BRW_CONDITIONAL_NZ));
         return;

a2081 5
         temp = fs_reg(this, glsl_type::bool_type);
         emit(OR(temp, op[0], op[1]));
         emit(IF(temp, fs_reg(0), BRW_CONDITIONAL_NZ));
         return;

d2083 5
a2087 4
         temp = fs_reg(this, glsl_type::bool_type);
         emit(AND(temp, op[0], op[1]));
         emit(IF(temp, fs_reg(0), BRW_CONDITIONAL_NZ));
         return;
d2106 2
a2107 4
         if (ctx->Const.UniformBooleanTrue == 1) {
            resolve_bool_comparison(expr->operands[0], &op[0]);
            resolve_bool_comparison(expr->operands[1], &op[1]);
         }
d2112 4
a2115 12

      case ir_triop_csel: {
         /* Expand the boolean condition into the flag register. */
         fs_inst *inst = emit(MOV(reg_null_d, op[0]));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;

         /* Select which boolean to use as the result. */
         fs_reg temp(this, expr->operands[1]->type);
         inst = emit(SEL(temp, op[1], op[2]));
         inst->predicate = BRW_PREDICATE_NORMAL;

	 emit(IF(temp, fs_reg(0), BRW_CONDITIONAL_NZ));
a2117 4

      default:
	 unreachable("not reached");
      }
d2120 3
a2122 2
   ir->condition->accept(this);
   emit(IF(this->result, fs_reg(0), BRW_CONDITIONAL_NZ));
d2181 2
a2182 2
         if_inst->next->exec_node::remove();
      if_inst->exec_node::remove();
d2230 5
a2234 3
   foreach_in_list(ir_instruction, ir_, &ir->then_instructions) {
      this->base_ir = ir_;
      ir_->accept(this);
d2240 5
a2244 3
      foreach_in_list(ir_instruction, ir_, &ir->else_instructions) {
	 this->base_ir = ir_;
	 ir_->accept(this);
d2263 5
a2267 3
   foreach_in_list(ir_instruction, ir_, &ir->body_instructions) {
      this->base_ir = ir_;
      ir_->accept(this);
d2293 2
a2294 2
   unsigned surf_index = (stage_prog_data->binding_table.abo_start +
                          location->data.binding);
d2304 2
a2305 2
      emit(MUL(tmp, this->result, fs_reg(ATOMIC_COUNTER_SIZE)));
      emit(ADD(offset, tmp, fs_reg(location->data.atomic.offset)));
d2307 1
a2307 1
      offset = fs_reg(location->data.atomic.offset);
d2338 1
a2338 1
      unreachable("Unsupported intrinsic.");
d2343 1
a2343 1
fs_visitor::visit(ir_return *)
d2345 1
a2345 1
   unreachable("FINISHME");
d2358 1
a2358 1
      sig = ir->matching_signature(NULL, &empty, false);
d2362 5
a2366 3
      foreach_in_list(ir_instruction, ir_, &sig->body) {
	 this->base_ir = ir_;
	 ir_->accept(this);
d2372 1
a2372 1
fs_visitor::visit(ir_function_signature *)
d2374 2
a2375 1
   unreachable("not reached");
d2381 1
a2381 1
   unreachable("not reached");
d2387 1
a2387 1
   unreachable("not reached");
d2395 2
a2396 5
   bool uses_kill =
      (stage == MESA_SHADER_FRAGMENT) &&
      ((brw_wm_prog_data*) this->prog_data)->uses_kill;
   int reg_width = dispatch_width / 8;
   int length = 0;
a2397 3
   fs_reg *sources = ralloc_array(mem_ctx, fs_reg, 4);

   sources[0] = fs_reg(GRF, virtual_grf_alloc(1), BRW_REGISTER_TYPE_UD);
d2399 1
a2399 1
   emit(MOV(sources[0], fs_reg(0u)))
d2402 2
a2403 2
   if (uses_kill) {
      emit(MOV(component(sources[0], 7), brw_flag_reg(0, 1)))
d2406 1
a2406 1
      emit(MOV(component(sources[0], 7),
d2410 2
a2411 1
   length++;
d2414 2
a2415 3
   sources[1] = fs_reg(this, glsl_type::uint_type);
   emit(MOV(sources[1], offset));
   length++;
d2419 2
a2420 3
      sources[length] = fs_reg(this, glsl_type::uint_type);
      emit(MOV(sources[length], src0));
      length++;
d2424 2
a2425 3
      sources[length] = fs_reg(this, glsl_type::uint_type);
      emit(MOV(sources[length], src1));
      length++;
a2427 5
   int mlen = 1 + (length - 1) * reg_width;
   fs_reg src_payload = fs_reg(GRF, virtual_grf_alloc(mlen),
                               BRW_REGISTER_TYPE_UD);
   emit(LOAD_PAYLOAD(src_payload, sources, length));

d2429 3
a2431 2
   fs_inst *inst = emit(SHADER_OPCODE_UNTYPED_ATOMIC, dst, src_payload,
                        fs_reg(atomic_op), fs_reg(surf_index));
d2433 2
d2441 2
a2442 4
   bool uses_kill =
      (stage == MESA_SHADER_FRAGMENT) &&
      ((brw_wm_prog_data*) this->prog_data)->uses_kill;
   int reg_width = dispatch_width / 8;
a2443 3
   fs_reg *sources = ralloc_array(mem_ctx, fs_reg, 2);

   sources[0] = fs_reg(GRF, virtual_grf_alloc(1), BRW_REGISTER_TYPE_UD);
d2445 1
a2445 1
   emit(MOV(sources[0], fs_reg(0u)))
d2448 2
a2449 2
   if (uses_kill) {
      emit(MOV(component(sources[0], 7), brw_flag_reg(0, 1)))
d2452 1
a2452 1
      emit(MOV(component(sources[0], 7),
d2457 2
d2460 2
a2461 7
   sources[1] = fs_reg(this, glsl_type::uint_type);
   emit(MOV(sources[1], offset));

   int mlen = 1 + reg_width;
   fs_reg src_payload = fs_reg(GRF, virtual_grf_alloc(mlen),
                               BRW_REGISTER_TYPE_UD);
   fs_inst *inst = emit(LOAD_PAYLOAD(src_payload, sources, 2));
d2464 3
a2466 2
   inst = emit(SHADER_OPCODE_UNTYPED_SURFACE_READ, dst, src_payload,
               fs_reg(surf_index));
d2468 2
d2475 1
a2475 1
   if (dispatch_width == 16 && inst->exec_size == 8)
d2489 3
a2491 2
   foreach_in_list_safe(fs_inst, inst, &list) {
      inst->exec_node::remove();
d2522 1
a2522 3
   assert(stage == MESA_SHADER_FRAGMENT);
   brw_wm_prog_data *prog_data = (brw_wm_prog_data*) this->prog_data;
   int regnr = prog_data->urb_setup[location] * 2 + channel / 2;
d2525 1
a2525 1
   assert(prog_data->urb_setup[location] != -1);
d2548 2
a2549 1
         offset(this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC], 1);
d2605 1
a2605 1
   this->pixel_w = fs_reg(brw_vec8_grf(payload.source_w_reg, 0));
d2610 1
a2610 1
      uint8_t reg = payload.barycentric_coord_reg[i];
d2618 2
a2619 2
int
fs_visitor::setup_color_payload(fs_reg *dst, fs_reg color, unsigned components)
d2621 1
a2621 1
   brw_wm_prog_key *key = (brw_wm_prog_key*) this->key;
d2623 2
d2626 3
a2628 3
   if (color.file == BAD_FILE) {
      return 4 * (dispatch_width / 8);
   }
d2630 1
a2630 8
   uint8_t colors_enabled;
   if (components == 0) {
      /* We want to write one component to the alpha channel */
      colors_enabled = 0x8;
   } else {
      /* Enable the first components-many channels */
      colors_enabled = (1 << components) - 1;
   }
d2649 4
a2652 14
      int len = 0;
      for (unsigned i = 0; i < 4; ++i) {
         if (colors_enabled & (1 << i)) {
            dst[len] = fs_reg(GRF, virtual_grf_alloc(color.width / 8),
                              color.type, color.width);
            inst = emit(MOV(dst[len], offset(color, i)));
            inst->saturate = key->clamp_fragment_color;
         } else if (color.width == 16) {
            /* We need two BAD_FILE slots for a 16-wide color */
            len++;
         }
         len++;
      }
      return len;
d2664 21
a2684 11
      for (unsigned i = 0; i < 4; ++i) {
         if (colors_enabled & (1 << i)) {
            dst[i] = fs_reg(GRF, virtual_grf_alloc(1), color.type);
            inst = emit(MOV(dst[i], half(offset(color, i), 0)));
            inst->saturate = key->clamp_fragment_color;

            dst[i + 4] = fs_reg(GRF, virtual_grf_alloc(1), color.type);
            inst = emit(MOV(dst[i + 4], half(offset(color, i), 1)));
            inst->saturate = key->clamp_fragment_color;
            inst->force_sechalf = true;
         }
a2685 1
      return 8;
d2689 1
a2689 1
static enum brw_conditional_mod
d2706 2
a2707 1
         unreachable("Not reached");
a2717 2
   assert(stage == MESA_SHADER_FRAGMENT);
   brw_wm_prog_key *key = (brw_wm_prog_key*) this->key;
d2721 1
a2721 1
   if (key->alpha_test_func == GL_ALWAYS)
d2724 1
a2724 1
   if (key->alpha_test_func == GL_NEVER) {
d2732 2
a2733 1
      fs_reg color = offset(outputs[0], 3);
d2736 2
a2737 2
      cmp = emit(CMP(reg_null_f, color, fs_reg(key->alpha_test_ref),
                     cond_for_alpha_func(key->alpha_test_func)));
d2743 2
a2744 3
fs_inst *
fs_visitor::emit_single_fb_write(fs_reg color0, fs_reg color1,
                                 fs_reg src0_alpha, unsigned components)
a2745 4
   assert(stage == MESA_SHADER_FRAGMENT);
   brw_wm_prog_data *prog_data = (brw_wm_prog_data*) this->prog_data;
   brw_wm_prog_key *key = (brw_wm_prog_key*) this->key;

a2747 2
   int reg_size = dispatch_width / 8;

d2751 10
a2760 2
   fs_reg *sources = ralloc_array(mem_ctx, fs_reg, 15);
   int length = 0;
d2770 3
a2772 3
       (brw->is_haswell || brw->gen >= 8 || !prog_data->uses_kill) &&
       color1.file == BAD_FILE &&
       key->nr_color_regions == 1) {
d2776 18
a2793 14
   if (header_present)
      /* Allocate 2 registers for a header */
      length += 2;

   if (payload.aa_dest_stencil_reg) {
      sources[length] = fs_reg(GRF, virtual_grf_alloc(1));
      emit(MOV(sources[length],
               fs_reg(brw_vec8_grf(payload.aa_dest_stencil_reg, 0))));
      length++;
   }

   prog_data->uses_omask =
      prog->OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_SAMPLE_MASK);
   if (prog_data->uses_omask) {
d2796 3
a2798 7
      /* Hand over gl_SampleMask. Only lower 16 bits are relevant.  Since
       * it's unsinged single words, one vgrf is always 16-wide.
       */
      sources[length] = fs_reg(GRF, virtual_grf_alloc(1),
                               BRW_REGISTER_TYPE_UW, 16);
      emit(FS_OPCODE_SET_OMASK, sources[length], this->sample_mask);
      length++;
d2801 7
a2807 20
   if (color0.file == BAD_FILE) {
      /* Even if there's no color buffers enabled, we still need to send
       * alpha out the pipeline to our null renderbuffer to support
       * alpha-testing, alpha-to-coverage, and so on.
       */
      length += setup_color_payload(sources + length, this->outputs[0], 0);
   } else if (color1.file == BAD_FILE) {
      if (src0_alpha.file != BAD_FILE) {
         sources[length] = fs_reg(GRF, virtual_grf_alloc(reg_size),
                                  src0_alpha.type, src0_alpha.width);
         fs_inst *inst = emit(MOV(sources[length], src0_alpha));
         inst->saturate = key->clamp_fragment_color;
         length++;
      }

      length += setup_color_payload(sources + length, color0, components);
   } else {
      length += setup_color_payload(sources + length, color0, components);
      length += setup_color_payload(sources + length, color1, components);
   }
d2809 1
a2809 1
   if (source_depth_to_render_target) {
a2818 1
      sources[length] = fs_reg(this, glsl_type::float_type);
d2822 1
a2822 1
	 emit(MOV(sources[length], this->frag_depth));
d2825 2
a2826 2
	 emit(MOV(sources[length],
                  fs_reg(brw_vec8_grf(payload.source_depth_reg, 0))));
d2828 1
a2828 1
      length++;
d2831 4
a2834 5
   if (payload.dest_depth_reg) {
      sources[length] = fs_reg(this, glsl_type::float_type);
      emit(MOV(sources[length],
               fs_reg(brw_vec8_grf(payload.dest_depth_reg, 0))));
      length++;
d2837 3
a2839 17
   fs_inst *load;
   fs_inst *write;
   if (brw->gen >= 7) {
      /* Send from the GRF */
      fs_reg payload = fs_reg(GRF, -1, BRW_REGISTER_TYPE_F);
      load = emit(LOAD_PAYLOAD(payload, sources, length));
      payload.reg = virtual_grf_alloc(load->regs_written);
      load->dst = payload;
      write = emit(FS_OPCODE_FB_WRITE, reg_undef, payload);
      write->base_mrf = -1;
   } else {
      /* Send from the MRF */
      load = emit(LOAD_PAYLOAD(fs_reg(MRF, 1, BRW_REGISTER_TYPE_F),
                               sources, length));
      write = emit(FS_OPCODE_FB_WRITE);
      write->base_mrf = 1;
   }
d2841 7
a2847 8
   write->mlen = load->regs_written;
   write->header_present = header_present;
   if ((brw->gen >= 8 || brw->is_haswell) && prog_data->uses_kill) {
      write->predicate = BRW_PREDICATE_NORMAL;
      write->flag_subreg = 1;
   }
   return write;
}
d2849 8
a2856 12
void
fs_visitor::emit_fb_writes()
{
   assert(stage == MESA_SHADER_FRAGMENT);
   brw_wm_prog_data *prog_data = (brw_wm_prog_data*) this->prog_data;
   brw_wm_prog_key *key = (brw_wm_prog_key*) this->key;

   if (do_dual_src) {
      no16("GL_ARB_blend_func_extended not yet supported in SIMD16.");
      if (dispatch_width == 16)
         do_dual_src = false;
   }
a2857 2
   fs_inst *inst;
   if (do_dual_src) {
d2861 17
d2879 23
a2901 13
						 "FB dual-source write");
      inst = emit_single_fb_write(this->outputs[0], this->dual_src_output,
                                  reg_undef, 4);
      inst->target = 0;
      prog_data->dual_src_blend = true;
   } else if (key->nr_color_regions > 0) {
      for (int target = 0; target < key->nr_color_regions; target++) {
         this->current_annotation = ralloc_asprintf(this->mem_ctx,
                                                    "FB write target %d",
                                                    target);
         fs_reg src0_alpha;
         if (brw->gen >= 6 && key->replicate_alpha && target != 0)
            src0_alpha = offset(outputs[0], 3);
d2903 1
a2903 2
         if (target == key->nr_color_regions - 1 &&
             (INTEL_DEBUG & DEBUG_SHADER_TIME))
d2905 1
d2907 12
a2918 4
         inst = emit_single_fb_write(this->outputs[target], reg_undef,
                                     src0_alpha,
                                     this->output_components[target]);
         inst->target = target;
d2920 1
a2920 3
   } else {
      if (INTEL_DEBUG & DEBUG_SHADER_TIME)
         emit_shader_time_end();
d2922 1
d2927 14
a2940 2
      inst = emit_single_fb_write(reg_undef, reg_undef, reg_undef, 0);
      inst->target = 0;
a2942 1
   inst->eot = true;
a2960 2
   assert(ctx->Const.UniformBooleanTrue == 1);

d2965 1
a2965 1
   emit(AND(temp, *reg, fs_reg(1u)));
d2970 1
a2970 3
                       void *mem_ctx,
                       const struct brw_wm_prog_key *key,
                       struct brw_wm_prog_data *prog_data,
d2974 1
a2974 1
   : backend_visitor(brw, shader_prog, &fp->Base, &prog_data->base,
a2975 4
     reg_null_f(retype(brw_null_vec(dispatch_width), BRW_REGISTER_TYPE_F)),
     reg_null_d(retype(brw_null_vec(dispatch_width), BRW_REGISTER_TYPE_D)),
     reg_null_ud(retype(brw_null_vec(dispatch_width), BRW_REGISTER_TYPE_UD)),
     key(key), prog_data(&prog_data->base),
d2978 3
a2980 7
   this->mem_ctx = mem_ctx;
   init();
}

void
fs_visitor::init()
{
a2987 1
   memset(&this->payload, 0, sizeof(this->payload));
a2989 2
   this->source_depth_to_render_target = false;
   this->runtime_check_aads_emit = false;
a3004 1
   this->last_scratch = 0;
d3008 2
d3019 1
@


1.6
log
@Merge Mesa 10.2.7
@
text
@d39 1
a39 1
#include "program/register_allocate.h"
d63 1
a63 1
	 reg = emit_frontfacing_interpolation(ir);
d80 3
a82 1
	 for (unsigned int i = 0; i < MAX2(c->key.nr_color_regions, 1); i++) {
d102 1
a102 2
	    this->outputs[output] = *reg;
	    this->outputs[output].reg_offset += vector_elements * i;
d113 2
a114 2
       * Atomic counters take no uniform storage, no need to do
       * anything here.
d116 1
a116 1
      if (ir->is_in_uniform_block() || ir->type->contains_atomic())
d138 1
a138 1
	 reg = emit_samplepos_setup(ir);
d140 1
a140 1
	 reg = emit_sampleid_setup(ir);
d142 4
a145 1
         reg = emit_samplemaskin_setup(ir);
d159 6
d175 1
a175 1
   unsigned int offset = 0;
d179 1
a179 1
      offset += type_size(struct_type->fields.structure[i].type);
d181 1
a181 1
   this->result.reg_offset += offset;
d199 2
a200 2
      assert(src.file == UNIFORM || src.file == GRF);
      src.reg_offset += constant_index->value.i[0] * element_size;
d255 1
a255 1
fs_visitor::emit_minmax(uint32_t conditionalmod, const fs_reg &dst,
a270 3
/* Instruction selection: Produce a MOV.sat instead of
 * MIN(MAX(val, 0), 1) when possible.
 */
d274 2
a275 1
   ir_rvalue *sat_val = ir->as_rvalue_to_saturate();
d277 1
a277 2
   if (!sat_val)
      return false;
d286 2
a287 2
   /* If the last instruction from our accept() didn't generate our
    * src, generate a saturated MOV
d290 2
a291 5
   if (!modify || modify->regs_written != 1) {
      this->result = fs_reg(this, ir->type);
      fs_inst *inst = emit(MOV(this->result, src));
      inst->saturate = true;
   } else {
d294 1
d297 1
a297 2

   return true;
d342 129
d482 4
a485 1
   if (ir->operation == ir_binop_add) {
d487 24
a510 1
	 return;
d539 5
a543 4
      /* Note that BRW_OPCODE_NOT is not appropriate here, since it is
       * ones complement of the whole register, not just bit 0.
       */
      emit(XOR(this->result, op[0], fs_reg(1)));
d596 1
a596 2
      assert(!"not reached: should be handled by ir_explog_to_explog2");
      break;
d607 7
a613 1
      emit(FS_OPCODE_DDX, this->result, op[0]);
d616 7
a622 1
      emit(FS_OPCODE_DDY, this->result, op[0]);
d629 1
a629 2
      assert(!"not reached: should be handled by ir_sub_to_add_neg");
      break;
d652 2
a653 1
            struct brw_reg acc = retype(brw_acc_reg(), this->result.type);
d664 1
a664 1
      if (brw->gen >= 7)
d667 2
a668 1
      struct brw_reg acc = retype(brw_acc_reg(), this->result.type);
d670 1
a670 1
      emit(MUL(acc, op[0], op[1]));
d672 21
d701 1
a701 1
      if (brw->gen >= 7)
d704 2
a705 1
      struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_UD);
d712 1
a712 1
      if (brw->gen >= 7)
d715 2
a716 1
      struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_UD);
d736 4
a739 2
      resolve_bool_comparison(ir->operands[0], &op[0]);
      resolve_bool_comparison(ir->operands[1], &op[1]);
d759 1
a759 2
      assert(!"not reached: should be handled by brw_fs_channel_expressions");
      break;
d762 1
a762 2
      assert(!"not reached: should be handled by lower_noise");
      break;
d765 1
a765 2
      assert(!"not reached: should be handled by lower_quadop_vector");
      break;
d768 1
a768 2
      assert(!"not reached: should be handled by lower_vec_index_to_cond_assign()");
      break;
d771 1
a771 2
      assert(!"not reached: should be handled by lower_vector_insert()");
      break;
d774 1
a774 2
      assert(!"not reached: should be handled by ldexp_to_arith()");
      break;
d810 10
a819 3
      temp = fs_reg(this, glsl_type::int_type);
      emit(AND(temp, op[0], fs_reg(1)));
      emit(MOV(this->result, temp));
d865 1
a865 2
      assert(!"not reached: should be handled by lower_packing_builtins");
      break;
d902 4
d919 1
a919 1
      assert(!"not reached: should be handled by "
a920 1
      break;
d952 1
a952 1
      ir_constant *uniform_block = ir->operands[0]->as_constant();
d954 26
a979 2
      fs_reg surf_index = fs_reg(c->prog_data.base.binding_table.ubo_start +
                                 uniform_block->value.u[0]);
d985 1
a985 1
         emit(new(mem_ctx) fs_inst(FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD,
d1005 1
a1005 1
            result.reg_offset++;
d1019 1
a1019 1
            result.reg_offset++;
d1039 4
a1042 3
      emit(CMP(reg_null_d, op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
      inst = emit(BRW_OPCODE_SEL, this->result, op[1], op[2]);
      inst->predicate = BRW_PREDICATE_NORMAL;
d1065 2
a1066 2
	 l.reg_offset++;
	 r.reg_offset++;
d1090 1
a1090 2
      assert(!"not reached");
      break;
d1167 1
a1167 1
	    r.reg_offset++;
d1169 1
a1169 1
	 l.reg_offset++;
d1177 5
a1181 2
fs_visitor::emit_texture_gen4(ir_texture *ir, fs_reg dst, fs_reg coordinate,
			      fs_reg shadow_c, fs_reg lod, fs_reg dPdy)
d1191 2
a1192 2
   if (ir->shadow_comparitor) {
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
d1194 1
a1194 1
	 coordinate.reg_offset++;
d1200 1
a1200 1
      for (int i = ir->coordinate->type->vector_elements; i < 3; i++) {
d1205 1
a1205 1
      if (ir->op == ir_tex) {
d1211 1
a1211 1
      } else if (ir->op == ir_txb || ir->op == ir_txl) {
d1215 1
a1215 1
         assert(!"Should not get here.");
d1220 2
a1221 2
   } else if (ir->op == ir_tex) {
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
d1223 1
a1223 1
	 coordinate.reg_offset++;
d1226 1
a1226 1
      for (int i = ir->coordinate->type->vector_elements; i<3; i++) {
d1231 1
a1231 1
   } else if (ir->op == ir_txd) {
d1234 1
a1234 1
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
d1236 1
a1236 1
	 coordinate.reg_offset++;
d1239 1
a1239 1
      mlen += MAX2(ir->coordinate->type->vector_elements, 2);
d1255 1
a1255 1
      for (int i = 0; i < ir->lod_info.grad.dPdx->type->vector_elements; i++) {
d1257 1
a1257 1
	 dPdx.reg_offset++;
d1259 1
a1259 1
      mlen += MAX2(ir->lod_info.grad.dPdx->type->vector_elements, 2);
d1261 1
a1261 1
      for (int i = 0; i < ir->lod_info.grad.dPdy->type->vector_elements; i++) {
d1263 1
a1263 1
	 dPdy.reg_offset++;
d1265 2
a1266 2
      mlen += MAX2(ir->lod_info.grad.dPdy->type->vector_elements, 2);
   } else if (ir->op == ir_txs) {
d1276 1
a1276 1
      assert(ir->op == ir_txb || ir->op == ir_txl || ir->op == ir_txf);
d1278 1
a1278 1
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
d1281 1
a1281 1
	 coordinate.reg_offset++;
d1287 1
a1287 1
      for (int i = ir->coordinate->type->vector_elements; i < 3; i++) {
d1307 1
a1307 4
      dst = fs_reg(GRF, virtual_grf_alloc(8),
                   (brw->is_g4x ?
                    brw_type_for_base_type(ir->type) :
                    BRW_REGISTER_TYPE_F));
d1310 8
a1317 20
   fs_inst *inst = NULL;
   switch (ir->op) {
   case ir_tex:
      inst = emit(SHADER_OPCODE_TEX, dst);
      break;
   case ir_txb:
      inst = emit(FS_OPCODE_TXB, dst);
      break;
   case ir_txl:
      inst = emit(SHADER_OPCODE_TXL, dst);
      break;
   case ir_txd:
      inst = emit(SHADER_OPCODE_TXD, dst);
      break;
   case ir_txs:
      inst = emit(SHADER_OPCODE_TXS, dst);
      break;
   case ir_txf:
      inst = emit(SHADER_OPCODE_TXF, dst);
      break;
d1319 1
a1319 1
      fail("unrecognized texture opcode");
d1321 2
d1331 2
a1332 2
	 orig_dst.reg_offset++;
	 dst.reg_offset += 2;
d1348 6
a1353 3
fs_visitor::emit_texture_gen5(ir_texture *ir, fs_reg dst, fs_reg coordinate,
                              fs_reg shadow_c, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index)
a1354 2
   int mlen = 0;
   int base_mrf = 2;
a1356 2
   const int vector_elements =
      ir->coordinate ? ir->coordinate->type->vector_elements : 0;
d1358 4
a1361 1
   if (ir->offset) {
d1366 1
a1366 2
      mlen++;
      base_mrf--;
d1370 2
a1371 3
      emit(MOV(fs_reg(MRF, base_mrf + mlen + i * reg_width, coordinate.type),
               coordinate));
      coordinate.reg_offset++;
d1373 2
a1374 1
   mlen += vector_elements * reg_width;
d1376 5
a1380 5
   if (ir->shadow_comparitor) {
      mlen = MAX2(mlen, header_present + 4 * reg_width);

      emit(MOV(fs_reg(MRF, base_mrf + mlen), shadow_c));
      mlen += reg_width;
d1383 2
a1384 2
   fs_inst *inst = NULL;
   switch (ir->op) {
d1386 1
a1386 1
      inst = emit(SHADER_OPCODE_TEX, dst);
d1389 2
a1390 3
      mlen = MAX2(mlen, header_present + 4 * reg_width);
      emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
      mlen += reg_width;
d1392 1
a1392 1
      inst = emit(FS_OPCODE_TXB, dst);
d1395 2
a1396 3
      mlen = MAX2(mlen, header_present + 4 * reg_width);
      emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
      mlen += reg_width;
d1398 1
a1398 1
      inst = emit(SHADER_OPCODE_TXL, dst);
a1400 2
      mlen = MAX2(mlen, header_present + 4 * reg_width); /* skip over 'ai' */

d1410 9
a1418 8
      for (int i = 0; i < ir->lod_info.grad.dPdx->type->vector_elements; i++) {
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
	 lod.reg_offset++;
	 mlen += reg_width;

	 emit(MOV(fs_reg(MRF, base_mrf + mlen), lod2));
	 lod2.reg_offset++;
	 mlen += reg_width;
d1421 1
a1421 1
      inst = emit(SHADER_OPCODE_TXD, dst);
d1425 5
a1429 3
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), lod));
      mlen += reg_width;
      inst = emit(SHADER_OPCODE_TXS, dst);
d1432 5
a1436 3
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
      mlen += reg_width;
      inst = emit(SHADER_OPCODE_TXS, dst);
d1439 5
a1443 3
      mlen = header_present + 4 * reg_width;
      emit(MOV(fs_reg(MRF, base_mrf + mlen - reg_width, BRW_REGISTER_TYPE_UD), lod));
      inst = emit(SHADER_OPCODE_TXF, dst);
d1446 1
a1446 2
      mlen = header_present + 4 * reg_width;

d1448 1
a1448 1
      emit(MOV(fs_reg(MRF, base_mrf + mlen - reg_width, BRW_REGISTER_TYPE_UD), fs_reg(0)));
d1450 4
a1453 3
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), sample_index));
      mlen += reg_width;
      inst = emit(SHADER_OPCODE_TXF_CMS, dst);
d1456 1
a1456 1
      inst = emit(SHADER_OPCODE_LOD, dst);
d1459 1
a1459 1
      inst = emit(SHADER_OPCODE_TG4, dst);
d1462 1
a1462 2
      fail("unrecognized texture opcode");
      break;
d1464 4
a1467 2
   inst->base_mrf = base_mrf;
   inst->mlen = mlen;
d1469 1
a1469 1
   inst->regs_written = 4;
d1471 1
a1471 1
   if (mlen > MAX_SAMPLER_MESSAGE_SIZE) {
d1479 9
d1489 6
a1494 3
fs_visitor::emit_texture_gen7(ir_texture *ir, fs_reg dst, fs_reg coordinate,
                              fs_reg shadow_c, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index, fs_reg mcs, int sampler)
d1499 5
a1503 2
   fs_reg payload = fs_reg(this, glsl_type::float_type);
   fs_reg next = payload;
d1505 2
a1506 1
   if (ir->op == ir_tg4 || (ir->offset && ir->op != ir_txf) || sampler >= 16) {
d1518 2
a1519 1
      next.reg_offset++;
d1522 3
a1524 3
   if (ir->shadow_comparitor) {
      emit(MOV(next, shadow_c));
      next.reg_offset++;
d1527 2
a1528 1
   bool has_nonconstant_offset = ir->offset && !ir->offset->as_constant();
d1532 1
a1532 1
   switch (ir->op) {
d1537 2
a1538 2
      emit(MOV(next, lod));
      next.reg_offset++;
d1541 2
a1542 2
      emit(MOV(next, lod));
      next.reg_offset++;
d1550 4
a1553 4
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
	 emit(MOV(next, coordinate));
	 coordinate.reg_offset++;
	 next.reg_offset++;
d1558 8
a1565 8
         if (i < ir->lod_info.grad.dPdx->type->vector_elements) {
            emit(MOV(next, lod));
            lod.reg_offset++;
            next.reg_offset++;

            emit(MOV(next, lod2));
            lod2.reg_offset++;
            next.reg_offset++;
d1573 2
a1574 2
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), lod));
      next.reg_offset++;
d1577 2
a1578 2
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
      next.reg_offset++;
d1582 11
a1592 11
      emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
      coordinate.reg_offset++;
      next.reg_offset++;

      emit(MOV(retype(next, BRW_REGISTER_TYPE_D), lod));
      next.reg_offset++;

      for (int i = 1; i < ir->coordinate->type->vector_elements; i++) {
	 emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
	 coordinate.reg_offset++;
	 next.reg_offset++;
d1598 2
a1599 2
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), sample_index));
      next.reg_offset++;
d1602 2
a1603 2
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), mcs));
      next.reg_offset++;
d1608 4
a1611 4
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
         emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
         coordinate.reg_offset++;
         next.reg_offset++;
d1618 1
a1618 1
         if (ir->shadow_comparitor)
a1621 3
         ir->offset->accept(this);
         fs_reg offset_value = this->result;

d1623 3
a1625 3
            emit(MOV(next, coordinate));
            coordinate.reg_offset++;
            next.reg_offset++;
d1629 3
a1631 3
            emit(MOV(retype(next, BRW_REGISTER_TYPE_D), offset_value));
            offset_value.reg_offset++;
            next.reg_offset++;
d1634 4
a1637 4
         if (ir->coordinate->type->vector_elements == 3) { /* r if present */
            emit(MOV(next, coordinate));
            coordinate.reg_offset++;
            next.reg_offset++;
d1646 5
a1650 5
   if (ir->coordinate && !coordinate_done) {
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
         emit(MOV(next, coordinate));
         coordinate.reg_offset++;
         next.reg_offset++;
d1654 10
d1665 11
a1675 11
   fs_inst *inst = NULL;
   switch (ir->op) {
   case ir_tex: inst = emit(SHADER_OPCODE_TEX, dst, payload); break;
   case ir_txb: inst = emit(FS_OPCODE_TXB, dst, payload); break;
   case ir_txl: inst = emit(SHADER_OPCODE_TXL, dst, payload); break;
   case ir_txd: inst = emit(SHADER_OPCODE_TXD, dst, payload); break;
   case ir_txf: inst = emit(SHADER_OPCODE_TXF, dst, payload); break;
   case ir_txf_ms: inst = emit(SHADER_OPCODE_TXF_CMS, dst, payload); break;
   case ir_txs: inst = emit(SHADER_OPCODE_TXS, dst, payload); break;
   case ir_query_levels: inst = emit(SHADER_OPCODE_TXS, dst, payload); break;
   case ir_lod: inst = emit(SHADER_OPCODE_LOD, dst, payload); break;
d1678 1
a1678 1
         inst = emit(SHADER_OPCODE_TG4_OFFSET, dst, payload);
d1680 1
a1680 1
         inst = emit(SHADER_OPCODE_TG4, dst, payload);
d1682 2
d1685 1
d1687 1
a1687 4
   if (reg_width == 2)
      inst->mlen = next.reg_offset * reg_width - header_present;
   else
      inst->mlen = next.reg_offset * reg_width;
d1689 1
a1689 1
   inst->regs_written = 4;
a1690 1
   virtual_grf_sizes[payload.reg] = next.reg_offset;
d1700 2
a1701 2
fs_visitor::rescale_texcoord(ir_texture *ir, fs_reg coordinate,
                             bool is_rect, int sampler, int texunit)
d1706 4
d1717 2
a1718 2
	(brw->gen >= 6 && (c->key.tex.gl_clamp_mask[0] & (1 << sampler) ||
			     c->key.tex.gl_clamp_mask[1] & (1 << sampler))))) {
d1738 1
a1738 1
             &prog->Parameters->ParameterValues[index][0].f) {
d1751 1
a1751 1
            &prog->Parameters->ParameterValues[index][0].f;
d1753 1
a1753 1
            &prog->Parameters->ParameterValues[index][1].f;
d1762 1
a1762 1
      fs_reg dst = fs_reg(this, ir->coordinate->type);
d1767 2
a1768 2
      dst.reg_offset++;
      src.reg_offset++;
d1779 1
a1779 1
	 if (c->key.tex.gl_clamp_mask[i] & (1 << sampler)) {
d1781 1
a1781 1
	    chan.reg_offset += i;
d1802 3
a1804 4
   if (ir->coordinate && needs_gl_clamp) {
      for (unsigned int i = 0;
	   i < MIN2(ir->coordinate->type->vector_elements, 3); i++) {
	 if (c->key.tex.gl_clamp_mask[i] & (1 << sampler)) {
d1806 1
a1806 1
	    chan.reg_offset += i;
d1818 1
a1818 1
fs_visitor::emit_mcs_fetch(ir_texture *ir, fs_reg coordinate, int sampler)
d1821 2
a1822 1
   fs_reg payload = fs_reg(this, glsl_type::float_type);
d1824 1
a1824 1
   fs_reg next = payload;
d1826 5
a1830 5
   /* parameters are: u, v, r, lod; missing parameters are treated as zero */
   for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
      emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
      coordinate.reg_offset++;
      next.reg_offset++;
d1833 3
a1835 2
   fs_inst *inst = emit(SHADER_OPCODE_TXF_MCS, dest, payload);
   virtual_grf_sizes[payload.reg] = next.reg_offset;
d1837 1
a1837 1
   inst->mlen = next.reg_offset * reg_width;
d1839 4
a1842 4
   inst->regs_written = 4; /* we only care about one reg of response,
                            * but the sampler always writes 4/8
                            */
   inst->sampler = sampler;
d1848 18
a1865 2
fs_visitor::visit(ir_texture *ir)
{
d1868 1
a1868 9
   int sampler =
      _mesa_get_sampler_uniform_value(ir->sampler, shader_prog, prog);
   /* FINISHME: We're failing to recompile our programs when the sampler is
    * updated.  This only matters for the texture rectangle scale parameters
    * (pre-gen6, or gen6+ with GL_CLAMP).
    */
   int texunit = prog->SamplerUnits[sampler];

   if (ir->op == ir_tg4) {
d1872 1
a1872 2
      ir_constant *chan = ir->lod_info.component->as_constant();
      int swiz = GET_SWZ(c->key.tex.swizzles[sampler], chan->value.i[0]);
d1880 1
a1880 1
            res.reg_offset++;
d1886 118
d2015 1
d2017 1
d2019 1
a2019 5

      coordinate = rescale_texcoord(ir, this->result,
                                    ir->sampler->type->sampler_dimensionality ==
                                    GLSL_SAMPLER_DIM_RECT,
                                    sampler, texunit);
d2028 19
d2048 1
d2065 2
d2078 3
a2080 2
      if (brw->gen >= 7 && c->key.tex.compressed_multisample_layout_mask & (1<<sampler))
         mcs = emit_mcs_fetch(ir, coordinate, sampler);
d2085 1
a2085 1
      assert(!"Unrecognized texture opcode");
d2088 1
a2088 19
   /* Writemasking doesn't eliminate channels on SIMD8 texture
    * samples, so don't worry about them.
    */
   fs_reg dst = fs_reg(this, glsl_type::get_instance(ir->type->base_type, 4, 1));

   if (brw->gen >= 7) {
      inst = emit_texture_gen7(ir, dst, coordinate, shadow_comparitor,
                               lod, lod2, sample_index, mcs, sampler);
   } else if (brw->gen >= 5) {
      inst = emit_texture_gen5(ir, dst, coordinate, shadow_comparitor,
                               lod, lod2, sample_index);
   } else {
      inst = emit_texture_gen4(ir, dst, coordinate, shadow_comparitor,
                               lod, lod2);
   }

   if (ir->offset != NULL && ir->op != ir_txf)
      inst->texture_offset = brw_texture_offset(ctx, ir->offset->as_constant());

d2090 1
a2090 3
      inst->texture_offset |= gather_channel(ir, sampler) << 16; // M0.2:16-17

   inst->sampler = sampler;
d2092 2
a2093 17
   if (ir->shadow_comparitor)
      inst->shadow_compare = true;

   /* fixup #layers for cube map arrays */
   if (ir->op == ir_txs) {
      glsl_type const *type = ir->sampler->type;
      if (type->sampler_dimensionality == GLSL_SAMPLER_DIM_CUBE &&
          type->sampler_array) {
         fs_reg depth = dst;
         depth.reg_offset = 2;
         emit_math(SHADER_OPCODE_INT_QUOTIENT, depth, depth, fs_reg(6));
      }
   }

   if (brw->gen == 6 && ir->op == ir_tg4) {
      emit_gen6_gather_wa(c->key.tex.gen6_gather_wa[sampler], dst);
   }
d2095 8
a2102 1
   swizzle_result(ir, dst, sampler);
d2131 1
a2131 1
      dst.reg_offset++;
d2139 1
a2139 1
fs_visitor::gather_channel(ir_texture *ir, int sampler)
d2141 5
a2145 2
   ir_constant *chan = ir->lod_info.component->as_constant();
   int swiz = GET_SWZ(c->key.tex.swizzles[sampler], chan->value.i[0]);
d2152 1
a2152 1
         if (c->key.tex.gather_channel_quirk_mask & (1<<sampler))
d2158 1
a2158 2
         assert(!"Not reached"); /* zero, one swizzles handled already */
         return 0;
d2167 2
a2168 1
fs_visitor::swizzle_result(ir_texture *ir, fs_reg orig_val, int sampler)
d2170 1
a2170 1
   if (ir->op == ir_query_levels) {
d2172 1
a2172 2
      orig_val.reg_offset += 3;
      this->result = orig_val;
d2181 1
a2181 1
   if (ir->op == ir_txs || ir->op == ir_lod || ir->op == ir_tg4)
d2184 6
a2189 1
   if (ir->type == glsl_type::float_type) {
d2191 1
a2191 2
      assert(ir->sampler->type->sampler_shadow);
   } else if (c->key.tex.swizzles[sampler] != SWIZZLE_NOOP) {
d2193 1
d2196 1
a2196 1
	 int swiz = GET_SWZ(c->key.tex.swizzles[sampler], i);
d2198 1
a2198 1
	 l.reg_offset += i;
d2205 2
a2206 3
	    fs_reg r = orig_val;
	    r.reg_offset += GET_SWZ(c->key.tex.swizzles[sampler], i);
	    emit(MOV(l, r));
d2220 1
a2220 1
      this->result.reg_offset += ir->mask.x;
d2246 2
a2247 3
      channel.reg_offset += swiz;
      emit(MOV(result, channel));
      result.reg_offset++;
d2270 1
a2270 5
       * However, many people will do foliage by discarding based on a
       * texture's alpha mask, and then continue on to texture with the
       * remaining pixels.  To avoid trashing the derivatives for those
       * texture samples, we'll only jump if all of the pixels in the subspan
       * have been discarded.
d2274 4
a2277 1
      discard_jump->predicate = BRW_PREDICATE_ALIGN1_ANY4H;
d2305 2
a2306 2
	    src_reg.reg_offset++;
	    dst_reg.reg_offset++;
d2310 1
a2310 2
      foreach_list(node, &ir->components) {
	 ir_constant *const field = (ir_constant *) node;
d2319 2
a2320 2
	    src_reg.reg_offset++;
	    dst_reg.reg_offset++;
d2338 3
a2340 1
	    emit(MOV(dst_reg, fs_reg((int)ir->value.b[i])));
d2343 1
a2343 1
	    assert(!"Non-float/uint/int/bool constant");
d2345 1
a2345 1
	 dst_reg.reg_offset++;
d2357 38
a2394 6
   if (expr &&
       expr->operation != ir_binop_logic_and &&
       expr->operation != ir_binop_logic_or &&
       expr->operation != ir_binop_logic_xor) {
      fs_reg op[2];
      fs_inst *inst;
d2396 11
a2406 3
      assert(expr->get_num_operands() <= 2);
      for (unsigned int i = 0; i < expr->get_num_operands(); i++) {
	 assert(expr->operands[i]->type->is_scalar());
d2408 11
a2418 2
	 expr->operands[i]->accept(this);
	 op[i] = this->result;
d2420 6
a2425 1
	 resolve_ud_negate(&op[i]);
d2427 1
d2429 8
a2436 5
      switch (expr->operation) {
      case ir_unop_logic_not:
	 inst = emit(AND(reg_null_d, op[0], fs_reg(1)));
	 inst->conditional_mod = BRW_CONDITIONAL_Z;
	 break;
d2438 12
a2449 8
      case ir_unop_f2b:
	 if (brw->gen >= 6) {
	    emit(CMP(reg_null_d, op[0], fs_reg(0.0f), BRW_CONDITIONAL_NZ));
	 } else {
	    inst = emit(MOV(reg_null_f, op[0]));
            inst->conditional_mod = BRW_CONDITIONAL_NZ;
	 }
	 break;
d2451 3
a2453 8
      case ir_unop_i2b:
	 if (brw->gen >= 6) {
	    emit(CMP(reg_null_d, op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
	 } else {
	    inst = emit(MOV(reg_null_d, op[0]));
            inst->conditional_mod = BRW_CONDITIONAL_NZ;
	 }
	 break;
d2455 4
a2458 10
      case ir_binop_greater:
      case ir_binop_gequal:
      case ir_binop_less:
      case ir_binop_lequal:
      case ir_binop_equal:
      case ir_binop_all_equal:
      case ir_binop_nequal:
      case ir_binop_any_nequal:
	 resolve_bool_comparison(expr->operands[0], &op[0]);
	 resolve_bool_comparison(expr->operands[1], &op[1]);
d2460 4
a2463 3
	 emit(CMP(reg_null_d, op[0], op[1],
                  brw_conditional_for_comparison(expr->operation)));
	 break;
d2465 4
a2468 6
      default:
	 assert(!"not reached");
	 fail("bad cond code\n");
	 break;
      }
      return;
d2471 3
a2473 4
   ir->accept(this);

   fs_inst *inst = emit(AND(reg_null_d, this->result, fs_reg(1)));
   inst->conditional_mod = BRW_CONDITIONAL_NZ;
d2485 2
a2486 2
   if (expr) {
      fs_reg op[2];
d2490 1
a2490 1
      assert(expr->get_num_operands() <= 2);
d2500 3
d2504 3
d2508 5
d2514 4
a2517 5
         /* For operations on bool arguments, only the low bit of the bool is
          * valid, and the others are undefined.  Fall back to the condition
          * code path.
          */
         break;
d2536 4
a2539 2
	 resolve_bool_comparison(expr->operands[0], &op[0]);
	 resolve_bool_comparison(expr->operands[1], &op[1]);
d2544 15
d2560 1
a2560 4
	 assert(!"not reached");
	 emit(IF(op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
	 fail("bad condition\n");
	 return;
d2564 2
a2565 3
   emit_bool_to_cond_code(ir->condition);
   fs_inst *inst = emit(BRW_OPCODE_IF);
   inst->predicate = BRW_PREDICATE_NORMAL;
d2624 2
a2625 2
         if_inst->next->remove();
      if_inst->remove();
d2673 3
a2675 5
   foreach_list(node, &ir->then_instructions) {
      ir_instruction *ir = (ir_instruction *)node;
      this->base_ir = ir;

      ir->accept(this);
d2681 3
a2683 5
      foreach_list(node, &ir->else_instructions) {
	 ir_instruction *ir = (ir_instruction *)node;
	 this->base_ir = ir;

	 ir->accept(this);
d2702 3
a2704 5
   foreach_list(node, &ir->body_instructions) {
      ir_instruction *ir = (ir_instruction *)node;

      this->base_ir = ir;
      ir->accept(this);
d2730 2
a2731 2
   unsigned surf_index = (c->prog_data.base.binding_table.abo_start +
                          location->data.atomic.buffer_index);
d2741 2
a2742 2
      emit(MUL(tmp, this->result, ATOMIC_COUNTER_SIZE));
      emit(ADD(offset, tmp, location->data.atomic.offset));
d2744 1
a2744 1
      offset = location->data.atomic.offset;
d2775 1
a2775 1
      assert(!"Unsupported intrinsic.");
d2780 1
a2780 1
fs_visitor::visit(ir_return *ir)
d2782 1
a2782 1
   assert(!"FINISHME");
d2795 1
a2795 1
      sig = ir->matching_signature(NULL, &empty);
d2799 3
a2801 5
      foreach_list(node, &sig->body) {
	 ir_instruction *ir = (ir_instruction *)node;
	 this->base_ir = ir;

	 ir->accept(this);
d2807 1
a2807 1
fs_visitor::visit(ir_function_signature *ir)
d2809 1
a2809 2
   assert(!"not reached");
   (void)ir;
d2815 1
a2815 1
   assert(!"not reached");
d2821 1
a2821 1
   assert(!"not reached");
d2829 5
a2833 2
   const unsigned operand_len = dispatch_width / 8;
   unsigned mlen = 0;
d2835 3
d2839 1
a2839 1
   emit(MOV(brw_uvec_mrf(8, mlen, 0), fs_reg(0u)))
d2842 2
a2843 2
   if (fp->UsesKill) {
      emit(MOV(brw_uvec_mrf(1, mlen, 7), brw_flag_reg(0, 1)))
d2846 1
a2846 1
      emit(MOV(brw_uvec_mrf(1, mlen, 7),
d2850 1
a2850 2

   mlen++;
d2853 3
a2855 2
   emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), offset));
   mlen += operand_len;
d2859 3
a2861 2
      emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), src0));
      mlen += operand_len;
d2865 3
a2867 2
      emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), src1));
      mlen += operand_len;
d2870 5
d2876 2
a2877 3
   fs_inst *inst = new(mem_ctx) fs_inst(SHADER_OPCODE_UNTYPED_ATOMIC, dst,
                                        atomic_op, surf_index);
   inst->base_mrf = 0;
a2878 2
   inst->header_present = true;
   emit(inst);
d2885 4
a2888 2
   const unsigned operand_len = dispatch_width / 8;
   unsigned mlen = 0;
d2890 3
d2894 1
a2894 1
   emit(MOV(brw_uvec_mrf(8, mlen, 0), fs_reg(0u)))
d2897 2
a2898 2
   if (fp->UsesKill) {
      emit(MOV(brw_uvec_mrf(1, mlen, 7), brw_flag_reg(0, 1)))
d2901 1
a2901 1
      emit(MOV(brw_uvec_mrf(1, mlen, 7),
d2906 3
a2908 1
   mlen++;
d2910 4
a2913 3
   /* Set the surface read offset. */
   emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), offset));
   mlen += operand_len;
d2916 2
a2917 3
   fs_inst *inst = new(mem_ctx)
      fs_inst(SHADER_OPCODE_UNTYPED_SURFACE_READ, dst, surf_index);
   inst->base_mrf = 0;
a2918 2
   inst->header_present = true;
   emit(inst);
d2924 1
a2924 1
   if (force_uncompressed_stack > 0)
d2938 2
a2939 3
   foreach_list_safe(node, &list) {
      fs_inst *inst = (fs_inst *)node;
      inst->remove();
d2970 3
a2972 1
   int regnr = c->prog_data.urb_setup[location] * 2 + channel / 2;
d2975 1
a2975 1
   assert(c->prog_data.urb_setup[location] != -1);
d2998 1
a2998 2
         this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC];
      this->delta_y[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC].reg_offset++;
d3054 1
a3054 1
   this->pixel_w = fs_reg(brw_vec8_grf(c->source_w_reg, 0));
d3059 1
a3059 1
      uint8_t reg = c->barycentric_coord_reg[i];
d3067 2
a3068 2
void
fs_visitor::emit_color_write(int target, int index, int first_color_mrf)
d3070 1
a3070 1
   int reg_width = dispatch_width / 8;
a3071 2
   fs_reg color = outputs[target];
   fs_reg mrf;
d3073 3
a3075 3
   /* If there's no color data to be written, skip it. */
   if (color.file == BAD_FILE)
      return;
d3077 8
a3084 1
   color.reg_offset += index;
d3103 14
a3116 4
      inst = emit(MOV(fs_reg(MRF, first_color_mrf + index * reg_width,
                             color.type),
                      color));
      inst->saturate = c->key.clamp_fragment_color;
d3128 11
a3138 21
      if (brw->has_compr4) {
	 /* By setting the high bit of the MRF register number, we
	  * indicate that we want COMPR4 mode - instead of doing the
	  * usual destination + 1 for the second half we get
	  * destination + 4.
	  */
	 inst = emit(MOV(fs_reg(MRF, BRW_MRF_COMPR4 + first_color_mrf + index,
                                color.type),
                         color));
	 inst->saturate = c->key.clamp_fragment_color;
      } else {
	 push_force_uncompressed();
	 inst = emit(MOV(fs_reg(MRF, first_color_mrf + index, color.type),
                         color));
	 inst->saturate = c->key.clamp_fragment_color;
	 pop_force_uncompressed();

	 inst = emit(MOV(fs_reg(MRF, first_color_mrf + index + 4, color.type),
                         half(color, 1)));
	 inst->force_sechalf = true;
	 inst->saturate = c->key.clamp_fragment_color;
d3140 1
d3144 1
a3144 1
static int
d3161 1
a3161 2
         assert(!"Not reached");
         return 0;
d3172 2
d3177 1
a3177 1
   if (c->key.alpha_test_func == GL_ALWAYS)
d3180 1
a3180 1
   if (c->key.alpha_test_func == GL_NEVER) {
d3188 1
a3188 2
      fs_reg color = outputs[0];
      color.reg_offset += 3;
d3191 2
a3192 2
      cmp = emit(CMP(reg_null_f, color, fs_reg(c->key.alpha_test_ref),
                     cond_for_alpha_func(c->key.alpha_test_func)));
d3198 3
a3200 2
void
fs_visitor::emit_fb_writes()
d3202 4
d3208 2
d3213 2
a3214 10
   int base_mrf = 1;
   int nr = base_mrf;
   int reg_width = dispatch_width / 8;
   bool src0_alpha_to_render_target = false;

   if (do_dual_src) {
      no16("GL_ARB_blend_func_extended not yet supported in SIMD16.");
      if (dispatch_width == 16)
         do_dual_src = false;
   }
d3224 3
a3226 3
       (brw->is_haswell || brw->gen >= 8 || !this->fp->UsesKill) &&
       !do_dual_src &&
       c->key.nr_color_regions == 1) {
d3230 14
a3243 18
   if (header_present) {
      src0_alpha_to_render_target = brw->gen >= 6 &&
				    !do_dual_src &&
                                    c->key.replicate_alpha;
      /* m2, m3 header */
      nr += 2;
   }

   if (c->aa_dest_stencil_reg) {
      push_force_uncompressed();
      emit(MOV(fs_reg(MRF, nr++),
               fs_reg(brw_vec8_grf(c->aa_dest_stencil_reg, 0))));
      pop_force_uncompressed();
   }

   c->prog_data.uses_omask =
      fp->Base.OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_SAMPLE_MASK);
   if(c->prog_data.uses_omask) {
d3246 7
a3252 3
      /* Hand over gl_SampleMask. Only lower 16 bits are relevant. */
      emit(FS_OPCODE_SET_OMASK, fs_reg(MRF, nr, BRW_REGISTER_TYPE_UW), this->sample_mask);
      nr += 1;
d3255 20
a3274 7
   /* Reserve space for color. It'll be filled in per MRT below. */
   int color_mrf = nr;
   nr += 4 * reg_width;
   if (do_dual_src)
      nr += 4;
   if (src0_alpha_to_render_target)
      nr += reg_width;
d3276 1
a3276 1
   if (c->source_depth_to_render_target) {
d3286 1
d3290 1
a3290 1
	 emit(MOV(fs_reg(MRF, nr), this->frag_depth));
d3293 2
a3294 2
	 emit(MOV(fs_reg(MRF, nr),
                  fs_reg(brw_vec8_grf(c->source_depth_reg, 0))));
d3296 1
a3296 1
      nr += reg_width;
d3299 5
a3303 4
   if (c->dest_depth_reg) {
      emit(MOV(fs_reg(MRF, nr),
               fs_reg(brw_vec8_grf(c->dest_depth_reg, 0))));
      nr += reg_width;
d3306 26
a3331 3
   if (do_dual_src) {
      fs_reg src0 = this->outputs[0];
      fs_reg src1 = this->dual_src_output;
d3333 6
a3338 7
      this->current_annotation = ralloc_asprintf(this->mem_ctx,
						 "FB write src0");
      for (int i = 0; i < 4; i++) {
	 fs_inst *inst = emit(MOV(fs_reg(MRF, color_mrf + i, src0.type), src0));
	 src0.reg_offset++;
	 inst->saturate = c->key.clamp_fragment_color;
      }
d3340 5
a3344 8
      this->current_annotation = ralloc_asprintf(this->mem_ctx,
						 "FB write src1");
      for (int i = 0; i < 4; i++) {
	 fs_inst *inst = emit(MOV(fs_reg(MRF, color_mrf + 4 + i, src1.type),
                                  src1));
	 src1.reg_offset++;
	 inst->saturate = c->key.clamp_fragment_color;
      }
d3346 2
d3351 4
a3354 1
      fs_inst *inst = emit(FS_OPCODE_FB_WRITE);
d3356 9
a3364 39
      inst->base_mrf = base_mrf;
      inst->mlen = nr - base_mrf;
      inst->eot = true;
      inst->header_present = header_present;
      if ((brw->gen >= 8 || brw->is_haswell) && fp->UsesKill) {
         inst->predicate = BRW_PREDICATE_NORMAL;
         inst->flag_subreg = 1;
      }

      c->prog_data.dual_src_blend = true;
      this->current_annotation = NULL;
      return;
   }

   for (int target = 0; target < c->key.nr_color_regions; target++) {
      this->current_annotation = ralloc_asprintf(this->mem_ctx,
						 "FB write target %d",
						 target);
      /* If src0_alpha_to_render_target is true, include source zero alpha
       * data in RenderTargetWrite message for targets > 0.
       */
      int write_color_mrf = color_mrf;
      if (src0_alpha_to_render_target && target != 0) {
         fs_inst *inst;
         fs_reg color = outputs[0];
         color.reg_offset += 3;

         inst = emit(MOV(fs_reg(MRF, write_color_mrf, color.type),
                         color));
         inst->saturate = c->key.clamp_fragment_color;
         write_color_mrf = color_mrf + reg_width;
      }

      for (unsigned i = 0; i < this->output_components[target]; i++)
         emit_color_write(target, i, write_color_mrf);

      bool eot = false;
      if (target == c->key.nr_color_regions - 1) {
         eot = true;
d3366 2
a3367 1
         if (INTEL_DEBUG & DEBUG_SHADER_TIME)
a3368 1
      }
d3370 4
a3373 12
      fs_inst *inst = emit(FS_OPCODE_FB_WRITE);
      inst->target = target;
      inst->base_mrf = base_mrf;
      if (src0_alpha_to_render_target && target == 0)
         inst->mlen = nr - base_mrf - reg_width;
      else
         inst->mlen = nr - base_mrf;
      inst->eot = eot;
      inst->header_present = header_present;
      if ((brw->gen >= 8 || brw->is_haswell) && fp->UsesKill) {
         inst->predicate = BRW_PREDICATE_NORMAL;
         inst->flag_subreg = 1;
d3375 3
a3377 1
   }
a3378 1
   if (c->key.nr_color_regions == 0) {
d3383 2
a3384 14
      emit_color_write(0, 3, color_mrf);

      if (INTEL_DEBUG & DEBUG_SHADER_TIME)
         emit_shader_time_end();

      fs_inst *inst = emit(FS_OPCODE_FB_WRITE);
      inst->base_mrf = base_mrf;
      inst->mlen = nr - base_mrf;
      inst->eot = true;
      inst->header_present = header_present;
      if ((brw->gen >= 8 || brw->is_haswell) && fp->UsesKill) {
         inst->predicate = BRW_PREDICATE_NORMAL;
         inst->flag_subreg = 1;
      }
d3387 1
d3406 2
d3412 1
a3412 1
   emit(AND(temp, *reg, fs_reg(1)));
d3417 3
a3419 1
                       struct brw_wm_compile *c,
d3423 1
a3423 1
   : backend_visitor(brw, shader_prog, &fp->Base, &c->prog_data.base,
d3425 4
d3431 7
a3437 3
   this->c = c;
   this->fp = fp;
   this->mem_ctx = ralloc_context(NULL);
d3445 1
d3448 2
d3465 1
a3468 2
   this->force_uncompressed_stack = 0;

a3477 1
   ralloc_free(this->mem_ctx);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d1536 1
a1536 1
	    inst = emit(BRW_OPCODE_SEL, chan, chan, brw_imm_f(0.0));
d1591 3
a1593 3
   inst->regs_written = 4 * reg_width; /* we only care about one reg of response,
                                        * but the sampler always writes 4/8
                                        */
d2399 1
a2399 1
   emit(MOV(brw_uvec_mrf(8, mlen, 0), brw_imm_ud(0)))
d2445 1
a2445 1
   emit(MOV(brw_uvec_mrf(8, mlen, 0), brw_imm_ud(0)))
@


1.4
log
@Merge Mesa 9.2.5
@
text
@a35 1
#include "main/uniforms.h"
d47 1
d59 1
a59 1
   if (ir->mode == ir_var_shader_in) {
d70 1
a70 1
   } else if (ir->mode == ir_var_shader_out) {
d73 3
a75 3
      if (ir->index > 0) {
	 assert(ir->location == FRAG_RESULT_DATA0);
	 assert(ir->index == 1);
d77 2
a78 1
      } else if (ir->location == FRAG_RESULT_COLOR) {
d84 1
a84 1
      } else if (ir->location == FRAG_RESULT_DEPTH) {
d86 2
d90 2
a91 2
	 assert(ir->location >= FRAG_RESULT_DATA0 &&
		ir->location < FRAG_RESULT_DATA0 + BRW_MAX_DRAW_BUFFERS);
d99 1
a99 1
	    int output = ir->location - FRAG_RESULT_DATA0 + i;
d105 2
a106 2
   } else if (ir->mode == ir_var_uniform) {
      int param_index = c->prog_data.nr_params;
d111 3
d115 1
a115 1
      if (ir->is_in_uniform_block())
d120 1
a120 1
	    fail("Failed to find uniform '%s' in 16-wide\n", ir->name);
d134 9
d216 2
a217 1
fs_visitor::emit_lrp(fs_reg dst, fs_reg x, fs_reg y, fs_reg a)
d230 3
a232 2
      a.negate = !a.negate;
      emit(ADD(one_minus_a, a, fs_reg(1.0f)));
d245 2
a246 2
fs_visitor::emit_minmax(uint32_t conditionalmod, fs_reg dst,
                        fs_reg src0, fs_reg src1)
d297 1
a297 1
fs_visitor::try_emit_mad(ir_expression *ir, int mul_arg)
d307 2
a308 2
   ir_rvalue *nonmul = ir->operands[1 - mul_arg];
   ir_expression *mul = ir->operands[mul_arg]->as_expression();
d310 7
a316 2
   if (!mul || mul->operation != ir_binop_mul)
      return false;
d350 1
a350 1
      if (try_emit_mad(ir, 0) || try_emit_mad(ir, 1))
d358 2
a359 2
	 ir->operands[operand]->print();
         printf("\n");
d361 1
d395 11
a405 1
      temp = fs_reg(this, ir->type);
d407 2
a408 1
      emit(MOV(this->result, fs_reg(0.0f)));
d410 7
a416 3
      emit(CMP(reg_null_f, op[0], fs_reg(0.0f), BRW_CONDITIONAL_G));
      inst = emit(MOV(this->result, fs_reg(1.0f)));
      inst->predicate = BRW_PREDICATE_NORMAL;
d418 1
a418 3
      emit(CMP(reg_null_f, op[0], fs_reg(0.0f), BRW_CONDITIONAL_L));
      inst = emit(MOV(this->result, fs_reg(-1.0f)));
      inst->predicate = BRW_PREDICATE_NORMAL;
d420 3
d462 1
a462 1
      if (ir->type->is_integer()) {
d467 21
a487 12
	  *
	  * FINISHME: Emit just the MUL if we know an operand is small
	  * enough.
	  */
	 if (brw->gen >= 7 && dispatch_width == 16)
	    fail("16-wide explicit accumulator operands unsupported\n");

	 struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_D);

	 emit(MUL(acc, op[0], op[1]));
	 emit(MACH(reg_null_d, op[0], op[1]));
	 emit(MOV(this->result, fs_reg(acc)));
d492 10
d507 20
d581 4
d754 2
a755 1
      fs_reg surf_index = fs_reg((unsigned)SURF_INDEX_WM_UBO(uniform_block->value.u[0]));
d761 2
a762 2
         emit(fs_inst(FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD,
                      packed_consts, surf_index, const_offset_reg));
a763 1
         packed_consts.smear = const_offset->value.u[0] % 16 / 4;
d765 7
a780 1
            packed_consts.smear++;
a781 5

            /* The std140 packing rules don't allow vectors to cross 16-byte
             * boundaries, and a reg is 32 bytes.
             */
            assert(packed_consts.smear < 8);
d803 7
d813 6
d858 2
d1145 8
a1152 22
   if (ir->offset != NULL && ir->op == ir_txf) {
      /* It appears that the ld instruction used for txf does its
       * address bounds check before adding in the offset.  To work
       * around this, just add the integer offset to the integer texel
       * coordinate, and don't put the offset in the header.
       */
      ir_constant *offset = ir->offset->as_constant();
      for (int i = 0; i < vector_elements; i++) {
	 emit(ADD(fs_reg(MRF, base_mrf + mlen + i * reg_width, coordinate.type),
                  coordinate,
                  offset->value.i[i]));
	 coordinate.reg_offset++;
      }
   } else {
      if (ir->offset) {
	 /* The offsets set up by the ir_texture visitor are in the
	  * m1 header, so we can't go headerless.
	  */
	 header_present = true;
	 mlen++;
	 base_mrf--;
      }
d1154 4
a1157 5
      for (int i = 0; i < vector_elements; i++) {
	 emit(MOV(fs_reg(MRF, base_mrf + mlen + i * reg_width, coordinate.type),
                  coordinate));
	 coordinate.reg_offset++;
      }
d1217 5
d1235 1
a1235 1
      inst = emit(SHADER_OPCODE_TXF_MS, dst);
d1240 6
d1252 3
a1254 2
   if (mlen > 11) {
      fail("Message length >11 disallowed by hardware\n");
d1263 1
a1263 1
                              fs_reg sample_index)
a1264 2
   int mlen = 0;
   int base_mrf = 2;
a1266 1
   int offsets[3];
d1268 13
a1280 3
   if (ir->offset && ir->op != ir_txf) {
      /* The offsets set up by the ir_texture visitor are in the
       * m1 header, so we can't go headerless.
d1283 1
a1283 2
      mlen++;
      base_mrf--;
d1287 2
a1288 2
      emit(MOV(fs_reg(MRF, base_mrf + mlen), shadow_c));
      mlen += reg_width;
d1291 3
d1300 2
a1301 2
      emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
      mlen += reg_width;
d1304 2
a1305 2
      emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
      mlen += reg_width;
d1308 1
a1308 2
      if (dispatch_width == 16)
	 fail("Gen7 does not support sample_d/sample_d_c in SIMD16 mode.");
d1314 1
a1314 1
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), coordinate));
d1316 1
a1316 1
	 mlen += reg_width;
d1322 1
a1322 1
            emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
d1324 1
a1324 1
            mlen += reg_width;
d1326 1
a1326 1
            emit(MOV(fs_reg(MRF, base_mrf + mlen), lod2));
d1328 1
a1328 1
            mlen += reg_width;
d1331 2
d1336 6
a1341 2
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), lod));
      mlen += reg_width;
a1343 14
      /* It appears that the ld instruction used for txf does its
       * address bounds check before adding in the offset.  To work
       * around this, just add the integer offset to the integer texel
       * coordinate, and don't put the offset in the header.
       */
      if (ir->offset) {
	 ir_constant *offset = ir->offset->as_constant();
	 offsets[0] = offset->value.i[0];
	 offsets[1] = offset->value.i[1];
	 offsets[2] = offset->value.i[2];
      } else {
	 memset(offsets, 0, sizeof(offsets));
      }

d1345 1
a1345 2
      emit(ADD(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_D),
               coordinate, offsets[0]));
d1347 1
a1347 1
      mlen += reg_width;
d1349 2
a1350 2
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_D), lod));
      mlen += reg_width;
d1353 1
a1353 2
	 emit(ADD(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_D),
                  coordinate, offsets[i]));
d1355 1
a1355 1
	 mlen += reg_width;
d1357 2
d1361 2
a1362 2
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), sample_index));
      mlen += reg_width;
d1364 3
a1366 6
      /* constant zero MCS; we arrange to never actually have a compressed
       * multisample surface here for now. TODO: issue ld_mcs to get this first,
       * if we ever support texturing from compressed multisample surfaces
       */
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
      mlen += reg_width;
d1372 1
a1372 2
         emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_D),
                  coordinate));
d1374 33
a1406 1
         mlen += reg_width;
d1412 1
a1412 1
   if (ir->op != ir_txd && ir->op != ir_txs && ir->op != ir_txf && ir->op != ir_txf_ms) {
d1414 3
a1416 3
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), coordinate));
	 coordinate.reg_offset++;
	 mlen += reg_width;
d1423 15
a1437 8
   case ir_tex: inst = emit(SHADER_OPCODE_TEX, dst); break;
   case ir_txb: inst = emit(FS_OPCODE_TXB, dst); break;
   case ir_txl: inst = emit(SHADER_OPCODE_TXL, dst); break;
   case ir_txd: inst = emit(SHADER_OPCODE_TXD, dst); break;
   case ir_txf: inst = emit(SHADER_OPCODE_TXF, dst); break;
   case ir_txf_ms: inst = emit(SHADER_OPCODE_TXF_MS, dst); break;
   case ir_txs: inst = emit(SHADER_OPCODE_TXS, dst); break;
   case ir_lod: inst = emit(SHADER_OPCODE_LOD, dst); break;
d1439 5
a1443 2
   inst->base_mrf = base_mrf;
   inst->mlen = mlen;
d1447 4
a1450 2
   if (mlen > 11) {
      fail("Message length >11 disallowed by hardware\n");
d1472 1
a1472 1
      struct gl_program_parameter_list *params = fp->Base.Parameters;
d1481 1
a1482 1
	 fail("rectangle scale uniform setup not supported on 16-wide\n");
a1485 3
      scale_x = fs_reg(UNIFORM, c->prog_data.nr_params);
      scale_y = fs_reg(UNIFORM, c->prog_data.nr_params + 1);

d1488 20
a1507 4
      c->prog_data.param[c->prog_data.nr_params++] =
         &fp->Base.Parameters->ParameterValues[index][0].f;
      c->prog_data.param[c->prog_data.nr_params++] =
         &fp->Base.Parameters->ParameterValues[index][1].f;
d1570 29
d1605 1
a1605 1
      _mesa_get_sampler_uniform_value(ir->sampler, shader_prog, &fp->Base);
d1610 20
a1629 1
   int texunit = fp->Base.SamplerUnits[sampler];
d1634 3
d1657 1
a1657 1
   fs_reg lod, lod2, sample_index;
d1661 2
d1684 5
d1690 2
d1701 1
a1701 1
                               lod, lod2, sample_index);
d1710 2
a1711 2
   /* The header is set up by generate_tex() when necessary. */
   inst->src[0] = reg_undef;
d1713 2
a1714 2
   if (ir->offset != NULL && ir->op != ir_txf)
      inst->texture_offset = brw_texture_offset(ir->offset->as_constant());
d1732 4
d1740 55
d1801 7
d1810 4
a1813 1
   if (ir->op == ir_txs || ir->op == ir_lod)
d1986 4
a1989 1
   if (expr) {
a2008 5
      case ir_binop_logic_xor:
      case ir_binop_logic_or:
      case ir_binop_logic_and:
	 goto out;

a2049 1
out:
d2125 85
d2213 2
a2214 2
   if (brw->gen < 6 && dispatch_width == 16) {
      fail("Can't support (non-uniform) control flow on 16-wide\n");
d2249 2
d2256 2
a2257 17
   fs_reg counter = reg_undef;

   if (brw->gen < 6 && dispatch_width == 16) {
      fail("Can't support (non-uniform) control flow on 16-wide\n");
   }

   if (ir->counter) {
      this->base_ir = ir->counter;
      ir->counter->accept(this);
      counter = *(variable_storage(ir->counter));

      if (ir->from) {
	 this->base_ir = ir->from;
	 ir->from->accept(this);

	 emit(MOV(counter, this->result));
      }
a2262 11
   if (ir->to) {
      this->base_ir = ir->to;
      ir->to->accept(this);

      emit(CMP(reg_null_d, counter, this->result,
               brw_conditional_for_comparison(ir->cmp)));

      fs_inst *inst = emit(BRW_OPCODE_BREAK);
      inst->predicate = BRW_PREDICATE_NORMAL;
   }

a2269 6
   if (ir->increment) {
      this->base_ir = ir->increment;
      ir->increment->accept(this);
      emit(ADD(counter, counter, this->result));
   }

d2288 41
d2331 9
a2339 1
   assert(!"FINISHME");
d2358 1
a2358 1
      sig = ir->matching_signature(&empty);
d2378 62
a2439 2
fs_inst *
fs_visitor::emit(fs_inst inst)
d2441 29
a2469 4
   fs_inst *list_inst = new(mem_ctx) fs_inst;
   *list_inst = inst;
   emit(list_inst);
   return list_inst;
a2476 2
   else if (force_sechalf_stack > 0)
      inst->force_sechalf = true;
d2522 1
a2522 1
   int regnr = urb_setup[location] * 2 + channel / 2;
d2525 1
a2525 1
   assert(urb_setup[location] != -1);
a2680 2
	 push_force_sechalf();
	 color.sechalf = true;
d2682 2
a2683 1
                         color));
a2684 2
	 pop_force_sechalf();
	 color.sechalf = false;
a2753 1
   bool do_dual_src = this->dual_src_output.file != BAD_FILE;
d2756 4
a2759 3
   if (dispatch_width == 16 && do_dual_src) {
      fail("GL_ARB_blend_func_extended not yet supported in 16-wide.");
      do_dual_src = false;
d2770 1
a2770 1
       !this->fp->UsesKill &&
d2791 10
d2810 1
a2810 1
      if (brw->gen == 6 && dispatch_width == 16) {
d2812 1
a2812 1
	  * used.  This would require 8-wide moves of each half to
d2816 1
a2816 1
	 fail("Missing support for simd16 depth writes on gen6\n");
d2819 1
a2819 1
      if (fp->Base.OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_DEPTH)) {
d2867 4
d2916 4
d2937 4
d2974 3
a2976 1
   : dispatch_width(dispatch_width)
a2978 1
   this->brw = brw;
a2979 2
   this->shader_prog = shader_prog;
   this->ctx = &brw->ctx;
a2980 5
   if (shader_prog)
      shader = (struct brw_shader *)
         shader_prog->_LinkedShaders[MESA_SHADER_FRAGMENT];
   else
      shader = NULL;
d2982 2
d3001 2
a3002 1
   this->live_intervals_valid = false;
d3004 3
a3006 2
   this->params_remap = NULL;
   this->nr_params_remap = 0;
a3008 1
   this->force_sechalf_stack = 0;
d3010 5
a3014 1
   memset(&this->param_size, 0, sizeof(this->param_size));
@


1.3
log
@Merge Mesa 9.2.1
@
text
@d2231 54
@


1.2
log
@Merge Mesa 9.2.0
@
text
@d871 7
a877 1
      /* gen4's SIMD8 sampler always has the slots for u,v,r present. */
@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a46 1
#include "brw_shader.h"
d48 2
a49 3
#include "../glsl/glsl_types.h"
#include "../glsl/ir_optimization.h"
#include "../glsl/ir_print_visitor.h"
d59 1
a59 9
   if (strcmp(ir->name, "gl_FragColor") == 0) {
      this->frag_color = ir;
   } else if (strcmp(ir->name, "gl_FragData") == 0) {
      this->frag_data = ir;
   } else if (strcmp(ir->name, "gl_FragDepth") == 0) {
      this->frag_depth = ir;
   }

   if (ir->mode == ir_var_in) {
d70 2
a71 1
   }
d73 30
a102 1
   if (ir->mode == ir_var_uniform) {
d105 8
a112 1
      if (c->dispatch_width == 16) {
d119 1
d123 1
a123 1
	 setup_uniform_values(ir->location, ir->type);
d163 5
a167 2
   ir_constant *index;
   int element_size;
d170 56
a225 1
   index = ir->array_index->as_constant();
d227 5
a231 2
   element_size = type_size(ir->type);
   this->result.type = brw_type_for_base_type(ir->type);
d233 3
a235 5
   if (index) {
      assert(this->result.file == UNIFORM ||
	     (this->result.file == GRF &&
	      this->result.reg != 0));
      this->result.reg_offset += index->value.i[0] * element_size;
d237 4
a240 1
      assert(!"FINISHME: non-constant array element");
d255 2
a256 1
   this->result = reg_undef;
d260 50
d311 1
a311 2
   fs_inst *inst = emit(BRW_OPCODE_MOV, this->result, src);
   inst->saturate = true;
d320 1
a320 1
   fs_reg op[2], temp;
d323 1
a323 1
   assert(ir->get_num_operands() <= 2);
d327 4
a330 3

   /* This is where our caller would like us to put the result, if possible. */
   fs_reg saved_result_storage = this->result;
a332 1
      this->result = reg_undef;
a334 1
	 ir_print_visitor v;
d336 2
a337 1
	 ir->operands[operand]->accept(&v);
d350 2
a351 2
   /* Inherit storage from our parent if possible, and otherwise we
    * alloc a temporary.
d353 1
a353 5
   if (saved_result_storage.file == BAD_FILE) {
      this->result = fs_reg(this, ir->type);
   } else {
      this->result = saved_result_storage;
   }
d360 1
a360 1
      emit(BRW_OPCODE_XOR, this->result, op[0], fs_reg(1));
d364 1
a364 1
      this->result = op[0];
d369 1
a369 1
      this->result = op[0];
d374 1
a374 4
      /* Unalias the destination.  (imagine a = sign(a)) */
      this->result = fs_reg(this, ir->type);

      emit(BRW_OPCODE_MOV, this->result, fs_reg(0.0f));
d376 7
a382 9
      inst = emit(BRW_OPCODE_CMP, reg_null_f, op[0], fs_reg(0.0f));
      inst->conditional_mod = BRW_CONDITIONAL_G;
      inst = emit(BRW_OPCODE_MOV, this->result, fs_reg(1.0f));
      inst->predicated = true;

      inst = emit(BRW_OPCODE_CMP, reg_null_f, op[0], fs_reg(0.0f));
      inst->conditional_mod = BRW_CONDITIONAL_L;
      inst = emit(BRW_OPCODE_MOV, this->result, fs_reg(-1.0f));
      inst->predicated = true;
d386 1
a386 1
      emit_math(FS_OPCODE_RCP, this->result, op[0]);
d390 1
a390 1
      emit_math(FS_OPCODE_EXP2, this->result, op[0]);
d393 1
a393 1
      emit_math(FS_OPCODE_LOG2, this->result, op[0]);
d401 1
a401 1
      emit_math(FS_OPCODE_SIN, this->result, op[0]);
d405 1
a405 1
      emit_math(FS_OPCODE_COS, this->result, op[0]);
d416 1
a416 1
      emit(BRW_OPCODE_ADD, this->result, op[0], op[1]);
d423 20
a442 1
      emit(BRW_OPCODE_MUL, this->result, op[0], op[1]);
d445 3
a447 1
      assert(!"not reached: should be handled by ir_div_to_mul_rcp");
d450 3
a452 1
      assert(!"ir_binop_mod should have been converted to b * fract(a/b)");
d463 5
a467 8
      temp = this->result;
      /* original gen4 does implicit conversion before comparison. */
      if (intel->gen < 5)
	 temp.type = op[0].type;

      inst = emit(BRW_OPCODE_CMP, temp, op[0], op[1]);
      inst->conditional_mod = brw_conditional_for_comparison(ir->operation);
      emit(BRW_OPCODE_AND, this->result, this->result, fs_reg(0x1));
d471 1
a471 1
      emit(BRW_OPCODE_XOR, this->result, op[0], op[1]);
d475 1
a475 1
      emit(BRW_OPCODE_OR, this->result, op[0], op[1]);
d479 1
a479 1
      emit(BRW_OPCODE_AND, this->result, op[0], op[1]);
d495 8
d504 1
a504 1
      emit_math(FS_OPCODE_SQRT, this->result, op[0]);
d508 1
a508 1
      emit_math(FS_OPCODE_RSQ, this->result, op[0]);
d511 15
d527 9
d537 3
a539 3
   case ir_unop_b2i:
   case ir_unop_f2i:
      emit(BRW_OPCODE_MOV, this->result, op[0]);
d541 1
d543 2
d546 1
a546 8
      temp = this->result;
      /* original gen4 does implicit conversion before comparison. */
      if (intel->gen < 5)
	 temp.type = op[0].type;

      inst = emit(BRW_OPCODE_CMP, temp, op[0], fs_reg(0.0f));
      inst->conditional_mod = BRW_CONDITIONAL_NZ;
      inst = emit(BRW_OPCODE_AND, this->result, this->result, fs_reg(1));
d550 1
a550 1
      emit(BRW_OPCODE_RNDZ, this->result, op[0]);
d554 1
a554 1
      inst = emit(BRW_OPCODE_RNDD, this->result, op[0]);
d558 1
a558 1
      inst = emit(BRW_OPCODE_RNDD, this->result, op[0]);
d561 1
a561 1
      inst = emit(BRW_OPCODE_FRC, this->result, op[0]);
d564 1
a564 1
      emit(BRW_OPCODE_RNDE, this->result, op[0]);
d568 28
a595 6
      if (intel->gen >= 6) {
	 inst = emit(BRW_OPCODE_SEL, this->result, op[0], op[1]);
	 inst->conditional_mod = BRW_CONDITIONAL_L;
      } else {
	 /* Unalias the destination */
	 this->result = fs_reg(this, ir->type);
d597 5
a601 6
	 inst = emit(BRW_OPCODE_CMP, this->result, op[0], op[1]);
	 inst->conditional_mod = BRW_CONDITIONAL_L;

	 inst = emit(BRW_OPCODE_SEL, this->result, op[0], op[1]);
	 inst->predicated = true;
      }
d603 3
a605 7
   case ir_binop_max:
      if (intel->gen >= 6) {
	 inst = emit(BRW_OPCODE_SEL, this->result, op[0], op[1]);
	 inst->conditional_mod = BRW_CONDITIONAL_GE;
      } else {
	 /* Unalias the destination */
	 this->result = fs_reg(this, ir->type);
d607 4
a610 2
	 inst = emit(BRW_OPCODE_CMP, this->result, op[0], op[1]);
	 inst->conditional_mod = BRW_CONDITIONAL_G;
d612 22
a633 3
	 inst = emit(BRW_OPCODE_SEL, this->result, op[0], op[1]);
	 inst->predicated = true;
      }
d635 3
a637 3

   case ir_binop_pow:
      emit_math(FS_OPCODE_POW, this->result, op[0], op[1]);
d641 1
a641 1
      inst = emit(BRW_OPCODE_NOT, this->result, op[0]);
d644 1
a644 1
      inst = emit(BRW_OPCODE_AND, this->result, op[0], op[1]);
d647 1
a647 1
      inst = emit(BRW_OPCODE_XOR, this->result, op[0], op[1]);
d650 1
a650 1
      inst = emit(BRW_OPCODE_OR, this->result, op[0], op[1]);
a652 1
   case ir_unop_u2f:
d654 3
d658 64
a721 1
      assert(!"GLSL 1.30 features unsupported");
d739 3
a741 3
	 if (predicated || !l.equals(&r)) {
	    fs_inst *inst = emit(BRW_OPCODE_MOV, l, r);
	    inst->predicated = predicated;
d764 3
a766 1
   default:
d772 39
d814 1
a814 1
   struct fs_reg l, r;
a817 1
   this->result = reg_undef;
d821 1
a821 10
   /* If we're doing a direct assignment, an RHS expression could
    * drop its result right into our destination.  Otherwise, tell it
    * not to.
    */
   if (ir->condition ||
       !(ir->lhs->type->is_scalar() ||
	 (ir->lhs->type->is_vector() &&
	  ir->write_mask == (1 << ir->lhs->type->vector_elements) - 1))) {
      this->result = reg_undef;
   }
d826 2
d831 3
d842 3
a844 7
	    if (ir->condition) {
	       inst = emit(BRW_OPCODE_MOV, l, r);
	       inst->predicated = true;
	    } else if (!l.equals(&r)) {
	       inst = emit(BRW_OPCODE_MOV, l, r);
	    }

d856 1
a856 1
			      int sampler)
d866 1
a866 1
   if (ir->shadow_comparitor && ir->op != ir_txd) {
d868 1
a868 5
	 fs_inst *inst = emit(BRW_OPCODE_MOV,
			      fs_reg(MRF, base_mrf + mlen + i), coordinate);
	 if (i < 3 && c->key.gl_clamp_mask[i] & (1 << sampler))
	    inst->saturate = true;

d878 1
a878 1
	 emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), fs_reg(0.0f));
d880 2
a881 4
      } else if (ir->op == ir_txb) {
	 this->result = reg_undef;
	 ir->lod_info.bias->accept(this);
	 emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), this->result);
d884 1
a884 5
	 assert(ir->op == ir_txl);
	 this->result = reg_undef;
	 ir->lod_info.lod->accept(this);
	 emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), this->result);
	 mlen++;
d887 1
a887 3
      this->result = reg_undef;
      ir->shadow_comparitor->accept(this);
      emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), this->result);
d891 1
a891 4
	 fs_inst *inst = emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen + i),
			      coordinate);
	 if (i < 3 && c->key.gl_clamp_mask[i] & (1 << sampler))
	    inst->saturate = true;
d894 4
d901 1
a901 7
      this->result = reg_undef;
      ir->lod_info.grad.dPdx->accept(this);
      fs_reg dPdx = this->result;

      this->result = reg_undef;
      ir->lod_info.grad.dPdy->accept(this);
      fs_reg dPdy = this->result;
d904 1
a904 1
	 emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen + i), coordinate);
d925 1
a925 1
	 emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), dPdx);
d931 1
a931 1
	 emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), dPdy);
d935 5
d944 2
a945 1
      assert(ir->op == ir_txb || ir->op == ir_txl);
d948 2
a949 5
	 fs_inst *inst = emit(BRW_OPCODE_MOV, fs_reg(MRF,
						     base_mrf + mlen + i * 2),
			      coordinate);
	 if (i < 3 && c->key.gl_clamp_mask[i] & (1 << sampler))
	    inst->saturate = true;
d953 7
d963 2
a964 11
      if (ir->op == ir_txb) {
	 this->result = reg_undef;
	 ir->lod_info.bias->accept(this);
	 emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), this->result);
	 mlen++;
      } else {
	 this->result = reg_undef;
	 ir->lod_info.lod->accept(this);
	 emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), this->result);
	 mlen++;
      }
d968 1
d970 1
a974 1
      simd16 = true;
d976 4
a979 3
      dst = fs_reg(this, glsl_type::get_array_instance(glsl_type::vec4_type,
						       2));
      dst.type = BRW_REGISTER_TYPE_F;
d985 1
a985 1
      inst = emit(FS_OPCODE_TEX, dst);
d991 1
a991 1
      inst = emit(FS_OPCODE_TXL, dst);
d994 4
a997 1
      inst = emit(FS_OPCODE_TXD, dst);
d1000 1
a1000 1
      assert(!"GLSL 1.30 features unsupported");
d1002 2
d1008 1
d1012 1
a1012 1
	 emit(BRW_OPCODE_MOV, orig_dst, dst);
d1031 2
a1032 1
			      int sampler)
d1036 1
a1036 1
   int reg_width = c->dispatch_width / 8;
d1038 2
d1041 5
a1045 3
   if (ir->offset) {
      /* The offsets set up by the ir_texture visitor are in the
       * m1 header, so we can't go headerless.
d1047 16
a1062 4
      header_present = true;
      mlen++;
      base_mrf--;
   }
d1064 5
a1068 7
   for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
      fs_inst *inst = emit(BRW_OPCODE_MOV,
			   fs_reg(MRF, base_mrf + mlen + i * reg_width),
			   coordinate);
      if (i < 3 && c->key.gl_clamp_mask[i] & (1 << sampler))
	 inst->saturate = true;
      coordinate.reg_offset++;
d1070 1
a1070 1
   mlen += ir->coordinate->type->vector_elements * reg_width;
d1072 1
a1072 1
   if (ir->shadow_comparitor && ir->op != ir_txd) {
d1075 1
a1075 3
      this->result = reg_undef;
      ir->shadow_comparitor->accept(this);
      emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), this->result);
d1082 1
a1082 1
      inst = emit(FS_OPCODE_TEX, dst);
a1084 2
      this->result = reg_undef;
      ir->lod_info.bias->accept(this);
d1086 1
a1086 1
      emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), this->result);
a1089 1

a1091 2
      this->result = reg_undef;
      ir->lod_info.lod->accept(this);
d1093 1
a1093 1
      emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), this->result);
d1096 1
a1096 1
      inst = emit(FS_OPCODE_TXL, dst);
a1098 8
      this->result = reg_undef;
      ir->lod_info.grad.dPdx->accept(this);
      fs_reg dPdx = this->result;

      this->result = reg_undef;
      ir->lod_info.grad.dPdy->accept(this);
      fs_reg dPdy = this->result;

d1111 2
a1112 2
	 emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), dPdx);
	 dPdx.reg_offset++;
d1115 2
a1116 2
	 emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), dPdy);
	 dPdy.reg_offset++;
d1120 1
a1120 1
      inst = emit(FS_OPCODE_TXD, dst);
d1123 5
d1129 16
a1144 1
      assert(!"GLSL 1.30 features unsupported");
d1150 1
d1161 2
a1162 1
			      int sampler)
d1166 1
a1166 1
   int reg_width = c->dispatch_width / 8;
d1168 1
d1170 1
a1170 1
   if (ir->offset) {
d1179 2
a1180 4
   if (ir->shadow_comparitor && ir->op != ir_txd) {
      this->result = reg_undef;
      ir->shadow_comparitor->accept(this);
      emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), this->result);
d1187 1
d1190 1
a1190 3
      this->result = reg_undef;
      ir->lod_info.bias->accept(this);
      emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), this->result);
d1194 1
a1194 3
      this->result = reg_undef;
      ir->lod_info.lod->accept(this);
      emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), this->result);
d1198 1
a1198 1
      if (c->dispatch_width == 16)
a1200 8
      this->result = reg_undef;
      ir->lod_info.grad.dPdx->accept(this);
      fs_reg dPdx = this->result;

      this->result = reg_undef;
      ir->lod_info.grad.dPdy->accept(this);
      fs_reg dPdy = this->result;

d1205 1
a1205 4
	 fs_inst *inst = emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen),
			      coordinate);
	 if (i < 3 && c->key.gl_clamp_mask[i] & (1 << sampler))
	    inst->saturate = true;
d1209 42
a1250 3
	 emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), dPdx);
	 dPdx.reg_offset++;
	 mlen += reg_width;
d1252 4
a1255 2
	 emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen), dPdy);
	 dPdy.reg_offset++;
d1259 20
a1278 3
   }
   case ir_txf:
      assert(!"GLSL 1.30 features unsupported");
d1282 2
a1283 2
   /* Set up the coordinate (except for TXD where it was done earlier) */
   if (ir->op != ir_txd) {
d1285 1
a1285 4
	 fs_inst *inst = emit(BRW_OPCODE_MOV, fs_reg(MRF, base_mrf + mlen),
			      coordinate);
	 if (i < 3 && c->key.gl_clamp_mask[i] & (1 << sampler))
	    inst->saturate = true;
d1294 1
a1294 1
   case ir_tex: inst = emit(FS_OPCODE_TEX, dst); break;
d1296 6
a1301 3
   case ir_txl: inst = emit(FS_OPCODE_TXL, dst); break;
   case ir_txd: inst = emit(FS_OPCODE_TXD, dst); break;
   case ir_txf: assert(!"TXF unsupported.");
d1306 1
d1315 3
a1317 2
void
fs_visitor::visit(ir_texture *ir)
d1320 2
a1321 54

   int sampler = _mesa_get_sampler_uniform_value(ir->sampler, prog, &fp->Base);
   sampler = fp->Base.SamplerUnits[sampler];

   /* Our hardware doesn't have a sample_d_c message, so shadow compares
    * for textureGrad/TXD need to be emulated with instructions.
    */
   bool hw_compare_supported = ir->op != ir_txd;
   if (ir->shadow_comparitor && !hw_compare_supported) {
      assert(c->key.compare_funcs[sampler] != GL_NONE);
      /* No need to even sample for GL_ALWAYS or GL_NEVER...bail early */
      if (c->key.compare_funcs[sampler] == GL_ALWAYS)
	 return swizzle_result(ir, fs_reg(1.0f), sampler);
      else if (c->key.compare_funcs[sampler] == GL_NEVER)
	 return swizzle_result(ir, fs_reg(0.0f), sampler);
   }

   this->result = reg_undef;
   ir->coordinate->accept(this);
   fs_reg coordinate = this->result;

   if (ir->offset != NULL) {
      ir_constant *offset = ir->offset->as_constant();
      assert(offset != NULL);

      signed char offsets[3];
      for (unsigned i = 0; i < ir->offset->type->vector_elements; i++)
	 offsets[i] = (signed char) offset->value.i[i];

      /* Combine all three offsets into a single unsigned dword:
       *
       *    bits 11:8 - U Offset (X component)
       *    bits  7:4 - V Offset (Y component)
       *    bits  3:0 - R Offset (Z component)
       */
      unsigned offset_bits = 0;
      for (unsigned i = 0; i < ir->offset->type->vector_elements; i++) {
	 const unsigned shift = 4 * (2 - i);
	 offset_bits |= (offsets[i] << shift) & (0xF << shift);
      }

      /* Explicitly set up the message header by copying g0 to msg reg m1. */
      emit(BRW_OPCODE_MOV, fs_reg(MRF, 1, BRW_REGISTER_TYPE_UD),
	   fs_reg(GRF, 0, BRW_REGISTER_TYPE_UD));

      /* Then set the offset bits in DWord 2 of the message header. */
      emit(BRW_OPCODE_MOV,
	   fs_reg(retype(brw_vec1_reg(BRW_MESSAGE_REGISTER_FILE, 1, 2),
			 BRW_REGISTER_TYPE_UD)),
	   fs_reg(brw_imm_uw(offset_bits)));
   }

   /* Should be lowered by do_lower_texture_projection */
   assert(!ir->projector);
d1327 5
a1331 2
   if (ir->sampler->type->sampler_dimensionality == GLSL_SAMPLER_DIM_RECT) {
      struct gl_program_parameter_list *params = c->fp->program.Base.Parameters;
d1335 1
a1335 1
	 sampler,
d1340 1
a1340 1
      if (c->dispatch_width == 16) {
d1342 1
a1342 2
	 this->result = fs_reg(this, ir->type);
	 return;
d1345 2
a1346 4
      c->prog_data.param_convert[c->prog_data.nr_params] =
	 PARAM_NO_CONVERT;
      c->prog_data.param_convert[c->prog_data.nr_params + 1] =
	 PARAM_NO_CONVERT;
a1347 2
      fs_reg scale_x = fs_reg(UNIFORM, c->prog_data.nr_params);
      fs_reg scale_y = fs_reg(UNIFORM, c->prog_data.nr_params + 1);
d1350 5
d1356 5
a1360 7
      this->param_index[c->prog_data.nr_params] = index;
      this->param_offset[c->prog_data.nr_params] = 0;
      c->prog_data.nr_params++;
      this->param_index[c->prog_data.nr_params] = index;
      this->param_offset[c->prog_data.nr_params] = 1;
      c->prog_data.nr_params++;

d1365 1
a1365 1
      emit(BRW_OPCODE_MUL, dst, src, scale_x);
d1368 31
a1398 1
      emit(BRW_OPCODE_MUL, dst, src, scale_y);
d1401 79
d1483 1
a1483 1
   fs_reg dst = fs_reg(this, glsl_type::vec4_type);
d1485 6
a1490 4
   if (intel->gen >= 7) {
      inst = emit_texture_gen7(ir, dst, coordinate, sampler);
   } else if (intel->gen >= 5) {
      inst = emit_texture_gen5(ir, dst, coordinate, sampler);
d1492 2
a1493 1
      inst = emit_texture_gen4(ir, dst, coordinate, sampler);
d1496 5
a1500 7
   /* If there's an offset, we already set up m1.  To avoid the implied move,
    * use the null register.  Otherwise, we want an implied move from g0.
    */
   if (ir->offset != NULL || !inst->header_present)
      inst->src[0] = reg_undef;
   else
      inst->src[0] = fs_reg(retype(brw_vec8_grf(0, 0), BRW_REGISTER_TYPE_UW));
d1504 2
a1505 32
   if (ir->shadow_comparitor) {
      if (hw_compare_supported) {
	 inst->shadow_compare = true;
      } else {
	 this->result = reg_undef;
	 ir->shadow_comparitor->accept(this);
	 fs_reg ref = this->result;

	 fs_reg value = dst;
	 dst = fs_reg(this, glsl_type::vec4_type);

	 /* FINISHME: This needs to be done pre-filtering. */

	 uint32_t conditional = 0;
	 switch (c->key.compare_funcs[sampler]) {
	 /* GL_ALWAYS and GL_NEVER were handled at the top of the function */
	 case GL_LESS:     conditional = BRW_CONDITIONAL_L;   break;
	 case GL_GREATER:  conditional = BRW_CONDITIONAL_G;   break;
	 case GL_LEQUAL:   conditional = BRW_CONDITIONAL_LE;  break;
	 case GL_GEQUAL:   conditional = BRW_CONDITIONAL_GE;  break;
	 case GL_EQUAL:    conditional = BRW_CONDITIONAL_EQ;  break;
	 case GL_NOTEQUAL: conditional = BRW_CONDITIONAL_NEQ; break;
	 default: assert(!"Should not get here: bad shadow compare function");
	 }

	 /* Use conditional moves to load 0 or 1 as the result */
	 this->current_annotation = "manual shadow comparison";
	 for (int i = 0; i < 4; i++) {
	    inst = emit(BRW_OPCODE_MOV, dst, fs_reg(0.0f));

	    inst = emit(BRW_OPCODE_CMP, reg_null_f, ref, value);
	    inst->conditional_mod = conditional;
d1507 8
a1514 7
	    inst = emit(BRW_OPCODE_MOV, dst, fs_reg(1.0f));
	    inst->predicated = true;

	    dst.reg_offset++;
	    value.reg_offset++;
	 }
	 dst.reg_offset = 0;
d1530 3
d1536 1
a1536 1
   } else if (c->key.tex_swizzles[sampler] != SWIZZLE_NOOP) {
d1540 1
a1540 1
	 int swiz = GET_SWZ(c->key.tex_swizzles[sampler], i);
d1545 1
a1545 1
	    emit(BRW_OPCODE_MOV, l, fs_reg(0.0f));
d1547 1
a1547 1
	    emit(BRW_OPCODE_MOV, l, fs_reg(1.0f));
d1550 2
a1551 2
	    r.reg_offset += GET_SWZ(c->key.tex_swizzles[sampler], i);
	    emit(BRW_OPCODE_MOV, l, r);
a1560 1
   this->result = reg_undef;
d1592 1
a1592 1
      emit(BRW_OPCODE_MOV, result, channel);
d1602 25
a1626 2
   emit(FS_OPCODE_DISCARD);
   kill_emitted = true;
a1645 1
	 this->result = reg_undef;
d1651 1
a1651 1
	    emit(BRW_OPCODE_MOV, dst_reg, src_reg);
d1658 1
a1658 1
	 ir_instruction *const field = (ir_instruction *) node;
a1660 1
	 this->result = reg_undef;
d1666 1
a1666 1
	    emit(BRW_OPCODE_MOV, dst_reg, src_reg);
d1677 1
a1677 1
	    emit(BRW_OPCODE_MOV, dst_reg, fs_reg(ir->value.f[i]));
d1680 1
a1680 1
	    emit(BRW_OPCODE_MOV, dst_reg, fs_reg(ir->value.u[i]));
d1683 1
a1683 1
	    emit(BRW_OPCODE_MOV, dst_reg, fs_reg(ir->value.i[i]));
d1686 1
a1686 1
	    emit(BRW_OPCODE_MOV, dst_reg, fs_reg((int)ir->value.b[i]));
a1710 1
	 this->result = reg_undef;
d1713 2
d1719 1
a1719 1
	 inst = emit(BRW_OPCODE_AND, reg_null_d, op[0], fs_reg(1));
a1723 4
	 inst = emit(BRW_OPCODE_XOR, reg_null_d, op[0], op[1]);
	 inst->conditional_mod = BRW_CONDITIONAL_NZ;
	 break;

a1724 4
	 inst = emit(BRW_OPCODE_OR, reg_null_d, op[0], op[1]);
	 inst->conditional_mod = BRW_CONDITIONAL_NZ;
	 break;

d1726 1
a1726 3
	 inst = emit(BRW_OPCODE_AND, reg_null_d, op[0], op[1]);
	 inst->conditional_mod = BRW_CONDITIONAL_NZ;
	 break;
d1729 2
a1730 2
	 if (intel->gen >= 6) {
	    inst = emit(BRW_OPCODE_CMP, reg_null_d, op[0], fs_reg(0.0f));
d1732 2
a1733 1
	    inst = emit(BRW_OPCODE_MOV, reg_null_f, op[0]);
a1734 1
	 inst->conditional_mod = BRW_CONDITIONAL_NZ;
d1738 2
a1739 2
	 if (intel->gen >= 6) {
	    inst = emit(BRW_OPCODE_CMP, reg_null_d, op[0], fs_reg(0));
d1741 2
a1742 1
	    inst = emit(BRW_OPCODE_MOV, reg_null_d, op[0]);
a1743 1
	 inst->conditional_mod = BRW_CONDITIONAL_NZ;
d1754 5
a1758 3
	 inst = emit(BRW_OPCODE_CMP, reg_null_cmp, op[0], op[1]);
	 inst->conditional_mod =
	    brw_conditional_for_comparison(expr->operation);
d1769 1
a1769 1
   this->result = reg_undef;
d1772 2
a1773 7
   if (intel->gen >= 6) {
      fs_inst *inst = emit(BRW_OPCODE_AND, reg_null_d, this->result, fs_reg(1));
      inst->conditional_mod = BRW_CONDITIONAL_NZ;
   } else {
      fs_inst *inst = emit(BRW_OPCODE_MOV, reg_null_d, this->result);
      inst->conditional_mod = BRW_CONDITIONAL_NZ;
   }
a1793 1
	 this->result = reg_undef;
a1799 4
	 inst = emit(BRW_OPCODE_IF, temp, op[0], fs_reg(0));
	 inst->conditional_mod = BRW_CONDITIONAL_Z;
	 return;

a1800 4
	 inst = emit(BRW_OPCODE_IF, reg_null_d, op[0], op[1]);
	 inst->conditional_mod = BRW_CONDITIONAL_NZ;
	 return;

a1801 6
	 temp = fs_reg(this, glsl_type::bool_type);
	 emit(BRW_OPCODE_OR, temp, op[0], op[1]);
	 inst = emit(BRW_OPCODE_IF, reg_null_d, temp, fs_reg(0));
	 inst->conditional_mod = BRW_CONDITIONAL_NZ;
	 return;

d1803 5
a1807 5
	 temp = fs_reg(this, glsl_type::bool_type);
	 emit(BRW_OPCODE_AND, temp, op[0], op[1]);
	 inst = emit(BRW_OPCODE_IF, reg_null_d, temp, fs_reg(0));
	 inst->conditional_mod = BRW_CONDITIONAL_NZ;
	 return;
d1815 1
a1815 2
	 inst = emit(BRW_OPCODE_IF, reg_null_d, op[0], fs_reg(0));
	 inst->conditional_mod = BRW_CONDITIONAL_NZ;
d1826 5
a1830 3
	 inst = emit(BRW_OPCODE_IF, reg_null_d, op[0], op[1]);
	 inst->conditional_mod =
	    brw_conditional_for_comparison(expr->operation);
d1834 1
a1834 2
	 inst = emit(BRW_OPCODE_IF, reg_null_d, op[0], fs_reg(0));
	 inst->conditional_mod = BRW_CONDITIONAL_NZ;
a1837 1
      return;
d1840 3
a1842 5
   this->result = reg_undef;
   ir->condition->accept(this);

   fs_inst *inst = emit(BRW_OPCODE_IF, reg_null_d, this->result, fs_reg(0));
   inst->conditional_mod = BRW_CONDITIONAL_NZ;
d1848 1
a1848 3
   fs_inst *inst;

   if (intel->gen < 6 && c->dispatch_width == 16) {
d1857 1
a1857 1
   if (intel->gen == 6) {
d1862 1
a1862 2
      inst = emit(BRW_OPCODE_IF);
      inst->predicated = true;
d1865 2
a1866 2
   foreach_iter(exec_list_iterator, iter, ir->then_instructions) {
      ir_instruction *ir = (ir_instruction *)iter.get();
d1868 1
a1868 1
      this->result = reg_undef;
d1875 2
a1876 2
      foreach_iter(exec_list_iterator, iter, ir->else_instructions) {
	 ir_instruction *ir = (ir_instruction *)iter.get();
d1878 1
a1878 1
	 this->result = reg_undef;
d1891 1
a1891 1
   if (c->dispatch_width == 16) {
a1900 2
	 this->result = counter;

a1901 1
	 this->result = counter;
d1904 1
a1904 2
	 if (!this->result.equals(&counter))
	    emit(BRW_OPCODE_MOV, counter, this->result);
d1908 1
a1912 1
      this->result = reg_undef;
d1915 2
a1916 2
      fs_inst *inst = emit(BRW_OPCODE_CMP, reg_null_cmp, counter, this->result);
      inst->conditional_mod = brw_conditional_for_comparison(ir->cmp);
d1918 2
a1919 2
      inst = emit(BRW_OPCODE_BREAK);
      inst->predicated = true;
d1922 2
a1923 2
   foreach_iter(exec_list_iterator, iter, ir->body_instructions) {
      ir_instruction *ir = (ir_instruction *)iter.get();
a1925 1
      this->result = reg_undef;
a1930 1
      this->result = reg_undef;
d1932 1
a1932 1
      emit(BRW_OPCODE_ADD, counter, counter, this->result);
d1935 1
d1978 2
a1979 2
      foreach_iter(exec_list_iterator, iter, sig->body) {
	 ir_instruction *ir = (ir_instruction *)iter.get();
d1981 1
a1981 1
	 this->result = reg_undef;
d1999 3
d2003 3
d2007 1
a2007 1
      list_inst->force_uncompressed = true;
d2009 4
a2012 1
      list_inst->force_sechalf = true;
d2014 1
a2014 2
   list_inst->annotation = this->current_annotation;
   list_inst->ir = this->base_ir;
d2016 2
a2017 1
   this->instructions.push_tail(list_inst);
d2019 8
a2026 1
   return list_inst;
d2033 2
d2036 4
a2039 4
   emit(BRW_OPCODE_MOV, fs_reg(MRF, 2), fs_reg(1.0f));
   emit(BRW_OPCODE_MOV, fs_reg(MRF, 3), fs_reg(0.0f));
   emit(BRW_OPCODE_MOV, fs_reg(MRF, 4), fs_reg(1.0f));
   emit(BRW_OPCODE_MOV, fs_reg(MRF, 5), fs_reg(0.0f));
d2043 3
a2045 1
   write->base_mrf = 0;
d2078 5
a2082 3
      this->delta_x = fs_reg(this, glsl_type::vec2_type);
      this->delta_y = this->delta_x;
      this->delta_y.reg_offset++;
d2084 9
a2092 7
      this->delta_x = fs_reg(this, glsl_type::float_type);
      this->delta_y = fs_reg(this, glsl_type::float_type);
   }
   emit(BRW_OPCODE_ADD, this->delta_x,
	this->pixel_x, fs_reg(negate(brw_vec1_grf(1, 0))));
   emit(BRW_OPCODE_ADD, this->delta_y,
	this->pixel_y, fs_reg(negate(brw_vec1_grf(1, 1))));
d2099 4
a2102 2
   emit(FS_OPCODE_LINTERP, wpos_w, this->delta_x, this->delta_y,
	interp_reg(FRAG_ATTRIB_WPOS, 3));
d2105 1
a2105 1
   emit_math(FS_OPCODE_RCP, this->pixel_w, wpos_w);
d2121 6
a2126 8
   emit(BRW_OPCODE_ADD,
	int_pixel_x,
	fs_reg(stride(suboffset(g1_uw, 4), 2, 4, 0)),
	fs_reg(brw_imm_v(0x10101010)));
   emit(BRW_OPCODE_ADD,
	int_pixel_y,
	fs_reg(stride(suboffset(g1_uw, 5), 2, 4, 0)),
	fs_reg(brw_imm_v(0x11001100)));
d2134 2
a2135 2
   emit(BRW_OPCODE_MOV, this->pixel_x, int_pixel_x);
   emit(BRW_OPCODE_MOV, this->pixel_y, int_pixel_y);
d2140 1
a2140 1
   emit_math(FS_OPCODE_RCP, this->wpos_w, this->pixel_w);
d2142 5
a2146 2
   this->delta_x = fs_reg(brw_vec8_grf(2, 0));
   this->delta_y = fs_reg(brw_vec8_grf(3, 0));
d2152 1
a2152 1
fs_visitor::emit_color_write(int index, int first_color_mrf, fs_reg color)
d2154 1
a2154 1
   int reg_width = c->dispatch_width / 8;
d2156 8
d2165 1
a2165 1
   if (c->dispatch_width == 8 || intel->gen >= 6) {
d2182 3
a2184 3
      inst = emit(BRW_OPCODE_MOV,
		  fs_reg(MRF, first_color_mrf + index * reg_width),
		  color);
d2203 3
a2205 3
	 inst = emit(BRW_OPCODE_MOV,
		     fs_reg(MRF, BRW_MRF_COMPR4 + first_color_mrf + index),
		     color);
d2209 2
a2210 2
	 inst = emit(BRW_OPCODE_MOV, fs_reg(MRF, first_color_mrf + index),
		     color);
d2216 2
a2217 2
	 inst = emit(BRW_OPCODE_MOV, fs_reg(MRF, first_color_mrf + index + 4),
		     color);
d2229 14
a2242 3
   GLboolean header_present = GL_TRUE;
   int nr = 0;
   int reg_width = c->dispatch_width / 8;
d2244 10
a2253 2
   if (intel->gen >= 6 &&
       !this->kill_emitted &&
d2259 4
a2262 1
      /* m0, m1 header */
d2268 2
a2269 2
      emit(BRW_OPCODE_MOV, fs_reg(MRF, nr++),
	   fs_reg(brw_vec8_grf(c->aa_dest_stencil_reg, 0)));
d2276 4
d2282 1
a2282 1
      if (intel->gen == 6 && c->dispatch_width == 16) {
d2291 1
a2291 1
      if (c->computes_depth) {
d2293 2
a2294 4
	 assert(this->frag_depth);
	 fs_reg depth = *(variable_storage(this->frag_depth));

	 emit(BRW_OPCODE_MOV, fs_reg(MRF, nr), depth);
d2297 2
a2298 2
	 emit(BRW_OPCODE_MOV, fs_reg(MRF, nr),
	      fs_reg(brw_vec8_grf(c->source_depth_reg, 0)));
d2304 2
a2305 2
      emit(BRW_OPCODE_MOV, fs_reg(MRF, nr),
	   fs_reg(brw_vec8_grf(c->dest_depth_reg, 0)));
d2309 34
a2342 6
   fs_reg color = reg_undef;
   if (this->frag_color)
      color = *(variable_storage(this->frag_color));
   else if (this->frag_data) {
      color = *(variable_storage(this->frag_data));
      color.type = BRW_REGISTER_TYPE_F;
d2349 24
a2372 5
      if (this->frag_color || this->frag_data) {
	 for (int i = 0; i < 4; i++) {
	    emit_color_write(i, color_mrf, color);
	    color.reg_offset++;
	 }
a2374 3
      if (this->frag_color)
	 color.reg_offset -= 4;

d2377 6
a2382 4
      inst->base_mrf = 0;
      inst->mlen = nr;
      if (target == c->key.nr_color_regions - 1)
	 inst->eot = true;
d2387 8
a2394 8
      if (c->key.alpha_test && (this->frag_color || this->frag_data)) {
	 /* If the alpha test is enabled but there's no color buffer,
	  * we still need to send alpha out the pipeline to our null
	  * renderbuffer.
	  */
	 color.reg_offset += 3;
	 emit_color_write(3, color_mrf, color);
      }
d2397 2
a2398 2
      inst->base_mrf = 0;
      inst->mlen = nr;
d2404 76
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@d47 1
d49 3
a51 2
#include "glsl/glsl_types.h"
#include "glsl/ir_optimization.h"
d61 9
a69 1
   if (ir->mode == ir_var_shader_in) {
d80 1
a80 2
   } else if (ir->mode == ir_var_shader_out) {
      reg = new(this->mem_ctx) fs_reg(this, ir->type);
d82 1
a82 30
      if (ir->index > 0) {
	 assert(ir->location == FRAG_RESULT_DATA0);
	 assert(ir->index == 1);
	 this->dual_src_output = *reg;
      } else if (ir->location == FRAG_RESULT_COLOR) {
	 /* Writing gl_FragColor outputs to all color regions. */
	 for (unsigned int i = 0; i < MAX2(c->key.nr_color_regions, 1); i++) {
	    this->outputs[i] = *reg;
	    this->output_components[i] = 4;
	 }
      } else if (ir->location == FRAG_RESULT_DEPTH) {
	 this->frag_depth = *reg;
      } else {
	 /* gl_FragData or a user-defined FS output */
	 assert(ir->location >= FRAG_RESULT_DATA0 &&
		ir->location < FRAG_RESULT_DATA0 + BRW_MAX_DRAW_BUFFERS);

	 int vector_elements =
	    ir->type->is_array() ? ir->type->fields.array->vector_elements
				 : ir->type->vector_elements;

	 /* General color output. */
	 for (unsigned int i = 0; i < MAX2(1, ir->type->length); i++) {
	    int output = ir->location - FRAG_RESULT_DATA0 + i;
	    this->outputs[output] = *reg;
	    this->outputs[output].reg_offset += vector_elements * i;
	    this->output_components[output] = vector_elements;
	 }
      }
   } else if (ir->mode == ir_var_uniform) {
d85 1
a85 8
      /* Thanks to the lower_ubo_reference pass, we will see only
       * ir_binop_ubo_load expressions and not ir_dereference_variable for UBO
       * variables, so no need for them to be in variable_ht.
       */
      if (ir->is_in_uniform_block())
         return;

      if (dispatch_width == 16) {
a91 1
      param_size[param_index] = type_size(ir->type);
d95 1
a95 1
	 setup_uniform_values(ir);
d135 2
a136 5
   ir_constant *constant_index;
   fs_reg src;
   int element_size = type_size(ir->type);

   constant_index = ir->array_index->as_constant();
d139 1
a139 2
   src = this->result;
   src.type = brw_type_for_base_type(ir->type);
d141 2
a142 53
   if (constant_index) {
      assert(src.file == UNIFORM || src.file == GRF);
      src.reg_offset += constant_index->value.i[0] * element_size;
   } else {
      /* Variable index array dereference.  We attach the variable index
       * component to the reg as a pointer to a register containing the
       * offset.  Currently only uniform arrays are supported in this patch,
       * and that reladdr pointer is resolved by
       * move_uniform_array_access_to_pull_constants().  All other array types
       * are lowered by lower_variable_index_to_cond_assign().
       */
      ir->array_index->accept(this);

      fs_reg index_reg;
      index_reg = fs_reg(this, glsl_type::int_type);
      emit(BRW_OPCODE_MUL, index_reg, this->result, fs_reg(element_size));

      if (src.reladdr) {
         emit(BRW_OPCODE_ADD, index_reg, *src.reladdr, index_reg);
      }

      src.reladdr = ralloc(mem_ctx, fs_reg);
      memcpy(src.reladdr, &index_reg, sizeof(index_reg));
   }
   this->result = src;
}

void
fs_visitor::emit_lrp(fs_reg dst, fs_reg x, fs_reg y, fs_reg a)
{
   if (brw->gen < 6 ||
       !x.is_valid_3src() ||
       !y.is_valid_3src() ||
       !a.is_valid_3src()) {
      /* We can't use the LRP instruction.  Emit x*(1-a) + y*a. */
      fs_reg y_times_a           = fs_reg(this, glsl_type::float_type);
      fs_reg one_minus_a         = fs_reg(this, glsl_type::float_type);
      fs_reg x_times_one_minus_a = fs_reg(this, glsl_type::float_type);

      emit(MUL(y_times_a, y, a));

      a.negate = !a.negate;
      emit(ADD(one_minus_a, a, fs_reg(1.0f)));
      emit(MUL(x_times_one_minus_a, x, one_minus_a));

      emit(ADD(dst, x_times_one_minus_a, y_times_a));
   } else {
      /* The LRP instruction actually does op1 * op0 + op2 * (1 - op0), so
       * we need to reorder the operands.
       */
      emit(LRP(dst, a, y, x));
   }
}
d144 5
a148 9
void
fs_visitor::emit_minmax(uint32_t conditionalmod, fs_reg dst,
                        fs_reg src0, fs_reg src1)
{
   fs_inst *inst;

   if (brw->gen >= 6) {
      inst = emit(BRW_OPCODE_SEL, dst, src0, src1);
      inst->conditional_mod = conditionalmod;
d150 1
a150 4
      emit(CMP(reg_null_d, src0, src1, conditionalmod));

      inst = emit(BRW_OPCODE_SEL, dst, src0, src1);
      inst->predicate = BRW_PREDICATE_NORMAL;
d165 1
a165 2
   fs_inst *pre_inst = (fs_inst *) this->instructions.get_tail();

a168 50
   fs_inst *last_inst = (fs_inst *) this->instructions.get_tail();

   /* If the last instruction from our accept() didn't generate our
    * src, generate a saturated MOV
    */
   fs_inst *modify = get_instruction_generating_reg(pre_inst, last_inst, src);
   if (!modify || modify->regs_written != 1) {
      this->result = fs_reg(this, ir->type);
      fs_inst *inst = emit(MOV(this->result, src));
      inst->saturate = true;
   } else {
      modify->saturate = true;
      this->result = src;
   }


   return true;
}

bool
fs_visitor::try_emit_mad(ir_expression *ir, int mul_arg)
{
   /* 3-src instructions were introduced in gen6. */
   if (brw->gen < 6)
      return false;

   /* MAD can only handle floating-point data. */
   if (ir->type != glsl_type::float_type)
      return false;

   ir_rvalue *nonmul = ir->operands[1 - mul_arg];
   ir_expression *mul = ir->operands[mul_arg]->as_expression();

   if (!mul || mul->operation != ir_binop_mul)
      return false;

   if (nonmul->as_constant() ||
       mul->operands[0]->as_constant() ||
       mul->operands[1]->as_constant())
      return false;

   nonmul->accept(this);
   fs_reg src0 = this->result;

   mul->operands[0]->accept(this);
   fs_reg src1 = this->result;

   mul->operands[1]->accept(this);
   fs_reg src2 = this->result;

d170 2
a171 1
   emit(BRW_OPCODE_MAD, this->result, src0, src1, src2);
d180 1
a180 1
   fs_reg op[3], temp;
d183 1
a183 1
   assert(ir->get_num_operands() <= 3);
d187 3
a189 4
   if (ir->operation == ir_binop_add) {
      if (try_emit_mad(ir, 0) || try_emit_mad(ir, 1))
	 return;
   }
d192 1
d195 1
d197 1
a197 2
	 ir->operands[operand]->print();
         printf("\n");
d210 2
a211 2
   /* Storage for our result.  If our result goes into an assignment, it will
    * just get copy-propagated out, so no worries.
d213 5
a217 1
   this->result = fs_reg(this, ir->type);
d224 1
a224 1
      emit(XOR(this->result, op[0], fs_reg(1)));
d228 1
a228 1
      emit(MOV(this->result, op[0]));
d233 1
a233 1
      emit(MOV(this->result, op[0]));
d238 4
a241 1
      emit(MOV(this->result, fs_reg(0.0f)));
d243 9
a251 7
      emit(CMP(reg_null_f, op[0], fs_reg(0.0f), BRW_CONDITIONAL_G));
      inst = emit(MOV(this->result, fs_reg(1.0f)));
      inst->predicate = BRW_PREDICATE_NORMAL;

      emit(CMP(reg_null_f, op[0], fs_reg(0.0f), BRW_CONDITIONAL_L));
      inst = emit(MOV(this->result, fs_reg(-1.0f)));
      inst->predicate = BRW_PREDICATE_NORMAL;
d255 1
a255 1
      emit_math(SHADER_OPCODE_RCP, this->result, op[0]);
d259 1
a259 1
      emit_math(SHADER_OPCODE_EXP2, this->result, op[0]);
d262 1
a262 1
      emit_math(SHADER_OPCODE_LOG2, this->result, op[0]);
d270 1
a270 1
      emit_math(SHADER_OPCODE_SIN, this->result, op[0]);
d274 1
a274 1
      emit_math(SHADER_OPCODE_COS, this->result, op[0]);
d285 1
a285 1
      emit(ADD(this->result, op[0], op[1]));
d292 1
a292 20
      if (ir->type->is_integer()) {
	 /* For integer multiplication, the MUL uses the low 16 bits
	  * of one of the operands (src0 on gen6, src1 on gen7).  The
	  * MACH accumulates in the contribution of the upper 16 bits
	  * of that operand.
	  *
	  * FINISHME: Emit just the MUL if we know an operand is small
	  * enough.
	  */
	 if (brw->gen >= 7 && dispatch_width == 16)
	    fail("16-wide explicit accumulator operands unsupported\n");

	 struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_D);

	 emit(MUL(acc, op[0], op[1]));
	 emit(MACH(reg_null_d, op[0], op[1]));
	 emit(MOV(this->result, fs_reg(acc)));
      } else {
	 emit(MUL(this->result, op[0], op[1]));
      }
d295 1
a295 3
      /* Floating point should be lowered by DIV_TO_MUL_RCP in the compiler. */
      assert(ir->type->is_integer());
      emit_math(SHADER_OPCODE_INT_QUOTIENT, this->result, op[0], op[1]);
d298 1
a298 3
      /* Floating point should be lowered by MOD_TO_FRACT in the compiler. */
      assert(ir->type->is_integer());
      emit_math(SHADER_OPCODE_INT_REMAINDER, this->result, op[0], op[1]);
d309 8
a316 5
      resolve_bool_comparison(ir->operands[0], &op[0]);
      resolve_bool_comparison(ir->operands[1], &op[1]);

      emit(CMP(this->result, op[0], op[1],
               brw_conditional_for_comparison(ir->operation)));
d320 1
a320 1
      emit(XOR(this->result, op[0], op[1]));
d324 1
a324 1
      emit(OR(this->result, op[0], op[1]));
d328 1
a328 1
      emit(AND(this->result, op[0], op[1]));
a343 8
   case ir_binop_vector_extract:
      assert(!"not reached: should be handled by lower_vec_index_to_cond_assign()");
      break;

   case ir_triop_vector_insert:
      assert(!"not reached: should be handled by lower_vector_insert()");
      break;

d345 1
a345 1
      emit_math(SHADER_OPCODE_SQRT, this->result, op[0]);
d349 1
a349 1
      emit_math(SHADER_OPCODE_RSQ, this->result, op[0]);
a351 15
   case ir_unop_bitcast_i2f:
   case ir_unop_bitcast_u2f:
      op[0].type = BRW_REGISTER_TYPE_F;
      this->result = op[0];
      break;
   case ir_unop_i2u:
   case ir_unop_bitcast_f2u:
      op[0].type = BRW_REGISTER_TYPE_UD;
      this->result = op[0];
      break;
   case ir_unop_u2i:
   case ir_unop_bitcast_f2i:
      op[0].type = BRW_REGISTER_TYPE_D;
      this->result = op[0];
      break;
d353 2
a354 1
   case ir_unop_u2f:
d356 1
a356 11
   case ir_unop_f2u:
      emit(MOV(this->result, op[0]));
      break;

   case ir_unop_b2i:
      emit(AND(this->result, op[0], fs_reg(1)));
      break;
   case ir_unop_b2f:
      temp = fs_reg(this, glsl_type::int_type);
      emit(AND(temp, op[0], fs_reg(1)));
      emit(MOV(this->result, temp));
a357 1

a358 2
      emit(CMP(this->result, op[0], fs_reg(0.0f), BRW_CONDITIONAL_NZ));
      break;
d360 8
a367 1
      emit(CMP(this->result, op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
d371 1
a371 1
      emit(RNDZ(this->result, op[0]));
d375 1
a375 1
      emit(RNDD(this->result, op[0]));
d379 1
a379 1
      emit(RNDD(this->result, op[0]));
d382 1
a382 1
      emit(FRC(this->result, op[0]));
d385 1
a385 1
      emit(RNDE(this->result, op[0]));
d389 9
a397 28
   case ir_binop_max:
      resolve_ud_negate(&op[0]);
      resolve_ud_negate(&op[1]);
      emit_minmax(ir->operation == ir_binop_min ?
                  BRW_CONDITIONAL_L : BRW_CONDITIONAL_GE,
                  this->result, op[0], op[1]);
      break;
   case ir_unop_pack_snorm_2x16:
   case ir_unop_pack_snorm_4x8:
   case ir_unop_pack_unorm_2x16:
   case ir_unop_pack_unorm_4x8:
   case ir_unop_unpack_snorm_2x16:
   case ir_unop_unpack_snorm_4x8:
   case ir_unop_unpack_unorm_2x16:
   case ir_unop_unpack_unorm_4x8:
   case ir_unop_unpack_half_2x16:
   case ir_unop_pack_half_2x16:
      assert(!"not reached: should be handled by lower_packing_builtins");
      break;
   case ir_unop_unpack_half_2x16_split_x:
      emit(FS_OPCODE_UNPACK_HALF_2x16_SPLIT_X, this->result, op[0]);
      break;
   case ir_unop_unpack_half_2x16_split_y:
      emit(FS_OPCODE_UNPACK_HALF_2x16_SPLIT_Y, this->result, op[0]);
      break;
   case ir_binop_pow:
      emit_math(SHADER_OPCODE_POW, this->result, op[0], op[1]);
      break;
d399 3
a401 2
   case ir_unop_bitfield_reverse:
      emit(BFREV(this->result, op[0]));
d403 7
a409 6
   case ir_unop_bit_count:
      emit(CBIT(this->result, op[0]));
      break;
   case ir_unop_find_msb:
      temp = fs_reg(this, glsl_type::uint_type);
      emit(FBH(temp, op[0]));
d411 2
a412 4
      /* FBH counts from the MSB side, while GLSL's findMSB() wants the count
       * from the LSB side. If FBH didn't return an error (0xFFFFFFFF), then
       * subtract the result from 31 to convert the MSB count into an LSB count.
       */
d414 3
a416 16
      /* FBH only supports UD type for dst, so use a MOV to convert UD to D. */
      emit(MOV(this->result, temp));
      emit(CMP(reg_null_d, this->result, fs_reg(-1), BRW_CONDITIONAL_NZ));

      temp.negate = true;
      inst = emit(ADD(this->result, temp, fs_reg(31)));
      inst->predicate = BRW_PREDICATE_NORMAL;
      break;
   case ir_unop_find_lsb:
      emit(FBL(this->result, op[0]));
      break;
   case ir_triop_bitfield_extract:
      /* Note that the instruction's argument order is reversed from GLSL
       * and the IR.
       */
      emit(BFE(this->result, op[2], op[1], op[0]));
d418 3
a420 9
   case ir_binop_bfm:
      emit(BFI1(this->result, op[0], op[1]));
      break;
   case ir_triop_bfi:
      emit(BFI2(this->result, op[0], op[1], op[2]));
      break;
   case ir_quadop_bitfield_insert:
      assert(!"not reached: should be handled by "
              "lower_instructions::bitfield_insert_to_bfm_bfi");
d424 1
a424 1
      emit(NOT(this->result, op[0]));
d427 1
a427 1
      emit(AND(this->result, op[0], op[1]));
d430 1
a430 1
      emit(XOR(this->result, op[0], op[1]));
d433 1
a433 1
      emit(OR(this->result, op[0], op[1]));
d436 1
a437 3
      emit(SHL(this->result, op[0], op[1]));
      break;

d439 1
a439 64
      if (ir->type->base_type == GLSL_TYPE_INT)
	 emit(ASR(this->result, op[0], op[1]));
      else
	 emit(SHR(this->result, op[0], op[1]));
      break;
   case ir_binop_pack_half_2x16_split:
      emit(FS_OPCODE_PACK_HALF_2x16_SPLIT, this->result, op[0], op[1]);
      break;
   case ir_binop_ubo_load: {
      /* This IR node takes a constant uniform block and a constant or
       * variable byte offset within the block and loads a vector from that.
       */
      ir_constant *uniform_block = ir->operands[0]->as_constant();
      ir_constant *const_offset = ir->operands[1]->as_constant();
      fs_reg surf_index = fs_reg((unsigned)SURF_INDEX_WM_UBO(uniform_block->value.u[0]));
      if (const_offset) {
         fs_reg packed_consts = fs_reg(this, glsl_type::float_type);
         packed_consts.type = result.type;

         fs_reg const_offset_reg = fs_reg(const_offset->value.u[0] & ~15);
         emit(fs_inst(FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD,
                      packed_consts, surf_index, const_offset_reg));

         packed_consts.smear = const_offset->value.u[0] % 16 / 4;
         for (int i = 0; i < ir->type->vector_elements; i++) {
            /* UBO bools are any nonzero value.  We consider bools to be
             * values with the low bit set to 1.  Convert them using CMP.
             */
            if (ir->type->base_type == GLSL_TYPE_BOOL) {
               emit(CMP(result, packed_consts, fs_reg(0u), BRW_CONDITIONAL_NZ));
            } else {
               emit(MOV(result, packed_consts));
            }

            packed_consts.smear++;
            result.reg_offset++;

            /* The std140 packing rules don't allow vectors to cross 16-byte
             * boundaries, and a reg is 32 bytes.
             */
            assert(packed_consts.smear < 8);
         }
      } else {
         /* Turn the byte offset into a dword offset. */
         fs_reg base_offset = fs_reg(this, glsl_type::int_type);
         emit(SHR(base_offset, op[1], fs_reg(2)));

         for (int i = 0; i < ir->type->vector_elements; i++) {
            emit(VARYING_PULL_CONSTANT_LOAD(result, surf_index,
                                            base_offset, i));

            if (ir->type->base_type == GLSL_TYPE_BOOL)
               emit(CMP(result, result, fs_reg(0), BRW_CONDITIONAL_NZ));

            result.reg_offset++;
         }
      }

      result.reg_offset = 0;
      break;
   }

   case ir_triop_lrp:
      emit_lrp(this->result, op[0], op[1], op[2]);
d457 3
a459 3
	 if (predicated || !l.equals(r)) {
	    fs_inst *inst = emit(MOV(l, r));
	    inst->predicate = predicated ? BRW_PREDICATE_NORMAL : BRW_PREDICATE_NONE;
d482 1
a482 3
   case GLSL_TYPE_VOID:
   case GLSL_TYPE_ERROR:
   case GLSL_TYPE_INTERFACE:
a487 39
/* If the RHS processing resulted in an instruction generating a
 * temporary value, and it would be easy to rewrite the instruction to
 * generate its result right into the LHS instead, do so.  This ends
 * up reliably removing instructions where it can be tricky to do so
 * later without real UD chain information.
 */
bool
fs_visitor::try_rewrite_rhs_to_dst(ir_assignment *ir,
                                   fs_reg dst,
                                   fs_reg src,
                                   fs_inst *pre_rhs_inst,
                                   fs_inst *last_rhs_inst)
{
   /* Only attempt if we're doing a direct assignment. */
   if (ir->condition ||
       !(ir->lhs->type->is_scalar() ||
        (ir->lhs->type->is_vector() &&
         ir->write_mask == (1 << ir->lhs->type->vector_elements) - 1)))
      return false;

   /* Make sure the last instruction generated our source reg. */
   fs_inst *modify = get_instruction_generating_reg(pre_rhs_inst,
						    last_rhs_inst,
						    src);
   if (!modify)
      return false;

   /* If last_rhs_inst wrote a different number of components than our LHS,
    * we can't safely rewrite it.
    */
   if (virtual_grf_sizes[dst.reg] != modify->regs_written)
      return false;

   /* Success!  Rewrite the instruction. */
   modify->dst = dst;

   return true;
}

d491 1
a491 1
   fs_reg l, r;
d495 1
d499 10
a508 1
   fs_inst *pre_rhs_inst = (fs_inst *) this->instructions.get_tail();
a512 2
   fs_inst *last_rhs_inst = (fs_inst *) this->instructions.get_tail();

a515 3
   if (try_rewrite_rhs_to_dst(ir, l, r, pre_rhs_inst, last_rhs_inst))
      return;

d524 7
a530 3
	    inst = emit(MOV(l, r));
	    if (ir->condition)
	       inst->predicate = BRW_PREDICATE_NORMAL;
d542 1
a542 1
			      fs_reg shadow_c, fs_reg lod, fs_reg dPdy)
d552 1
a552 1
   if (ir->shadow_comparitor) {
d554 5
a558 1
	 emit(MOV(fs_reg(MRF, base_mrf + mlen + i), coordinate));
d568 1
a568 1
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), fs_reg(0.0f)));
d570 4
a573 2
      } else if (ir->op == ir_txb || ir->op == ir_txl) {
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
d576 5
a580 1
         assert(!"Should not get here.");
d583 3
a585 1
      emit(MOV(fs_reg(MRF, base_mrf + mlen), shadow_c));
d589 4
a592 1
	 emit(MOV(fs_reg(MRF, base_mrf + mlen + i), coordinate));
a594 4
      /* zero the others. */
      for (int i = ir->coordinate->type->vector_elements; i<3; i++) {
         emit(MOV(fs_reg(MRF, base_mrf + mlen + i), fs_reg(0.0f)));
      }
d598 7
a604 1
      fs_reg &dPdx = lod;
d607 1
a607 1
	 emit(MOV(fs_reg(MRF, base_mrf + mlen + i), coordinate));
d628 1
a628 1
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), dPdx));
d634 1
a634 1
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), dPdy));
a637 5
   } else if (ir->op == ir_txs) {
      /* There's no SIMD8 resinfo message on Gen4.  Use SIMD16 instead. */
      simd16 = true;
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), lod));
      mlen += 2;
d642 1
a642 2
      simd16 = true;
      assert(ir->op == ir_txb || ir->op == ir_txl || ir->op == ir_txf);
d645 5
a649 2
	 emit(MOV(fs_reg(MRF, base_mrf + mlen + i * 2, coordinate.type),
                  coordinate));
a652 7
      /* Initialize the rest of u/v/r with 0.0.  Empirically, this seems to
       * be necessary for TXF (ld), but seems wise to do for all messages.
       */
      for (int i = ir->coordinate->type->vector_elements; i < 3; i++) {
	 emit(MOV(fs_reg(MRF, base_mrf + mlen + i * 2), fs_reg(0.0f)));
      }

d656 11
a666 2
      emit(MOV(fs_reg(MRF, base_mrf + mlen, lod.type), lod));
      mlen++;
a669 1
   }
a670 1
   if (simd16) {
d675 1
d677 3
a679 4
      dst = fs_reg(GRF, virtual_grf_alloc(8),
                   (brw->is_g4x ?
                    brw_type_for_base_type(ir->type) :
                    BRW_REGISTER_TYPE_F));
d685 1
a685 1
      inst = emit(SHADER_OPCODE_TEX, dst);
d691 1
a691 1
      inst = emit(SHADER_OPCODE_TXL, dst);
d694 1
a694 4
      inst = emit(SHADER_OPCODE_TXD, dst);
      break;
   case ir_txs:
      inst = emit(SHADER_OPCODE_TXS, dst);
d697 1
a697 1
      inst = emit(SHADER_OPCODE_TXF, dst);
a698 2
   default:
      fail("unrecognized texture opcode");
a702 1
   inst->regs_written = simd16 ? 8 : 4;
d706 1
a706 1
	 emit(MOV(orig_dst, dst));
d725 1
a725 2
                              fs_reg shadow_c, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index)
d729 1
a729 1
   int reg_width = dispatch_width / 8;
a730 2
   const int vector_elements =
      ir->coordinate ? ir->coordinate->type->vector_elements : 0;
d732 3
a734 5
   if (ir->offset != NULL && ir->op == ir_txf) {
      /* It appears that the ld instruction used for txf does its
       * address bounds check before adding in the offset.  To work
       * around this, just add the integer offset to the integer texel
       * coordinate, and don't put the offset in the header.
d736 4
a739 16
      ir_constant *offset = ir->offset->as_constant();
      for (int i = 0; i < vector_elements; i++) {
	 emit(ADD(fs_reg(MRF, base_mrf + mlen + i * reg_width, coordinate.type),
                  coordinate,
                  offset->value.i[i]));
	 coordinate.reg_offset++;
      }
   } else {
      if (ir->offset) {
	 /* The offsets set up by the ir_texture visitor are in the
	  * m1 header, so we can't go headerless.
	  */
	 header_present = true;
	 mlen++;
	 base_mrf--;
      }
d741 7
a747 5
      for (int i = 0; i < vector_elements; i++) {
	 emit(MOV(fs_reg(MRF, base_mrf + mlen + i * reg_width, coordinate.type),
                  coordinate));
	 coordinate.reg_offset++;
      }
d749 1
a749 1
   mlen += vector_elements * reg_width;
d751 1
a751 1
   if (ir->shadow_comparitor) {
d754 3
a756 1
      emit(MOV(fs_reg(MRF, base_mrf + mlen), shadow_c));
d763 1
a763 1
      inst = emit(SHADER_OPCODE_TEX, dst);
d766 2
d769 1
a769 1
      emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
d773 1
d776 2
d779 1
a779 1
      emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
d782 1
a782 1
      inst = emit(SHADER_OPCODE_TXL, dst);
d785 8
d805 2
a806 2
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
	 lod.reg_offset++;
d809 2
a810 2
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), lod2));
	 lod2.reg_offset++;
d814 1
a814 1
      inst = emit(SHADER_OPCODE_TXD, dst);
a816 5
   case ir_txs:
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), lod));
      mlen += reg_width;
      inst = emit(SHADER_OPCODE_TXS, dst);
      break;
d818 1
a818 16
      mlen = header_present + 4 * reg_width;
      emit(MOV(fs_reg(MRF, base_mrf + mlen - reg_width, BRW_REGISTER_TYPE_UD), lod));
      inst = emit(SHADER_OPCODE_TXF, dst);
      break;
   case ir_txf_ms:
      mlen = header_present + 4 * reg_width;

      /* lod */
      emit(MOV(fs_reg(MRF, base_mrf + mlen - reg_width, BRW_REGISTER_TYPE_UD), fs_reg(0)));
      /* sample index */
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), sample_index));
      mlen += reg_width;
      inst = emit(SHADER_OPCODE_TXF_MS, dst);
      break;
   case ir_lod:
      inst = emit(SHADER_OPCODE_LOD, dst);
a823 1
   inst->regs_written = 4;
d834 1
a834 2
                              fs_reg shadow_c, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index)
d838 1
a838 1
   int reg_width = dispatch_width / 8;
a839 1
   int offsets[3];
d841 1
a841 1
   if (ir->offset && ir->op != ir_txf) {
d850 4
a853 2
   if (ir->shadow_comparitor) {
      emit(MOV(fs_reg(MRF, base_mrf + mlen), shadow_c));
a859 1
   case ir_lod:
d862 3
a864 1
      emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
d868 3
a870 1
      emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
d874 1
a874 1
      if (dispatch_width == 16)
d877 8
d889 4
a892 1
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), coordinate));
d896 7
a902 12
         /* For cube map array, the coordinate is (u,v,r,ai) but there are
          * only derivatives for (u, v, r).
          */
         if (i < ir->lod_info.grad.dPdx->type->vector_elements) {
            emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
            lod.reg_offset++;
            mlen += reg_width;

            emit(MOV(fs_reg(MRF, base_mrf + mlen), lod2));
            lod2.reg_offset++;
            mlen += reg_width;
         }
a905 4
   case ir_txs:
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), lod));
      mlen += reg_width;
      break;
d907 1
a907 50
      /* It appears that the ld instruction used for txf does its
       * address bounds check before adding in the offset.  To work
       * around this, just add the integer offset to the integer texel
       * coordinate, and don't put the offset in the header.
       */
      if (ir->offset) {
	 ir_constant *offset = ir->offset->as_constant();
	 offsets[0] = offset->value.i[0];
	 offsets[1] = offset->value.i[1];
	 offsets[2] = offset->value.i[2];
      } else {
	 memset(offsets, 0, sizeof(offsets));
      }

      /* Unfortunately, the parameters for LD are intermixed: u, lod, v, r. */
      emit(ADD(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_D),
               coordinate, offsets[0]));
      coordinate.reg_offset++;
      mlen += reg_width;

      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_D), lod));
      mlen += reg_width;

      for (int i = 1; i < ir->coordinate->type->vector_elements; i++) {
	 emit(ADD(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_D),
                  coordinate, offsets[i]));
	 coordinate.reg_offset++;
	 mlen += reg_width;
      }
      break;
   case ir_txf_ms:
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), sample_index));
      mlen += reg_width;

      /* constant zero MCS; we arrange to never actually have a compressed
       * multisample surface here for now. TODO: issue ld_mcs to get this first,
       * if we ever support texturing from compressed multisample surfaces
       */
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
      mlen += reg_width;

      /* there is no offsetting for this message; just copy in the integer
       * texture coordinates
       */
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
         emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_D),
                  coordinate));
         coordinate.reg_offset++;
         mlen += reg_width;
      }
d911 2
a912 2
   /* Set up the coordinate (except for cases where it was done above) */
   if (ir->op != ir_txd && ir->op != ir_txs && ir->op != ir_txf && ir->op != ir_txf_ms) {
d914 4
a917 1
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), coordinate));
d926 1
a926 1
   case ir_tex: inst = emit(SHADER_OPCODE_TEX, dst); break;
d928 3
a930 6
   case ir_txl: inst = emit(SHADER_OPCODE_TXL, dst); break;
   case ir_txd: inst = emit(SHADER_OPCODE_TXD, dst); break;
   case ir_txf: inst = emit(SHADER_OPCODE_TXF, dst); break;
   case ir_txf_ms: inst = emit(SHADER_OPCODE_TXF_MS, dst); break;
   case ir_txs: inst = emit(SHADER_OPCODE_TXS, dst); break;
   case ir_lod: inst = emit(SHADER_OPCODE_LOD, dst); break;
a934 1
   inst->regs_written = 4;
d943 2
a944 3
fs_reg
fs_visitor::rescale_texcoord(ir_texture *ir, fs_reg coordinate,
                             bool is_rect, int sampler, int texunit)
d947 54
a1000 2
   bool needs_gl_clamp = true;
   fs_reg scale_x, scale_y;
d1006 2
a1007 5
   if (is_rect &&
       (brw->gen < 6 ||
	(brw->gen >= 6 && (c->key.tex.gl_clamp_mask[0] & (1 << sampler) ||
			     c->key.tex.gl_clamp_mask[1] & (1 << sampler))))) {
      struct gl_program_parameter_list *params = fp->Base.Parameters;
d1011 1
a1011 1
	 texunit,
d1016 1
a1016 1
      if (dispatch_width == 16) {
d1018 2
a1019 1
	 return coordinate;
d1022 4
a1025 2
      scale_x = fs_reg(UNIFORM, c->prog_data.nr_params);
      scale_y = fs_reg(UNIFORM, c->prog_data.nr_params + 1);
d1027 2
a1030 5
      c->prog_data.param[c->prog_data.nr_params++] =
         &fp->Base.Parameters->ParameterValues[index][0].f;
      c->prog_data.param[c->prog_data.nr_params++] =
         &fp->Base.Parameters->ParameterValues[index][1].f;
   }
d1032 7
a1038 5
   /* The 965 requires the EU to do the normalization of GL rectangle
    * texture coordinates.  We use the program parameter state
    * tracking to get the scaling factor.
    */
   if (brw->gen < 6 && is_rect) {
d1043 1
a1043 1
      emit(MUL(dst, src, scale_x));
d1046 1
a1046 31
      emit(MUL(dst, src, scale_y));
   } else if (is_rect) {
      /* On gen6+, the sampler handles the rectangle coordinates
       * natively, without needing rescaling.  But that means we have
       * to do GL_CLAMP clamping at the [0, width], [0, height] scale,
       * not [0, 1] like the default case below.
       */
      needs_gl_clamp = false;

      for (int i = 0; i < 2; i++) {
	 if (c->key.tex.gl_clamp_mask[i] & (1 << sampler)) {
	    fs_reg chan = coordinate;
	    chan.reg_offset += i;

	    inst = emit(BRW_OPCODE_SEL, chan, chan, brw_imm_f(0.0));
	    inst->conditional_mod = BRW_CONDITIONAL_G;

	    /* Our parameter comes in as 1.0/width or 1.0/height,
	     * because that's what people normally want for doing
	     * texture rectangle handling.  We need width or height
	     * for clamping, but we don't care enough to make a new
	     * parameter type, so just invert back.
	     */
	    fs_reg limit = fs_reg(this, glsl_type::float_type);
	    emit(MOV(limit, i == 0 ? scale_x : scale_y));
	    emit(SHADER_OPCODE_RCP, limit, limit);

	    inst = emit(BRW_OPCODE_SEL, chan, chan, limit);
	    inst->conditional_mod = BRW_CONDITIONAL_L;
	 }
      }
d1049 4
a1052 6
   if (ir->coordinate && needs_gl_clamp) {
      for (unsigned int i = 0;
	   i < MIN2(ir->coordinate->type->vector_elements, 3); i++) {
	 if (c->key.tex.gl_clamp_mask[i] & (1 << sampler)) {
	    fs_reg chan = coordinate;
	    chan.reg_offset += i;
d1054 6
a1059 4
	    fs_inst *inst = emit(MOV(chan, chan));
	    inst->saturate = true;
	 }
      }
a1060 2
   return coordinate;
}
d1062 2
a1063 10
void
fs_visitor::visit(ir_texture *ir)
{
   fs_inst *inst = NULL;

   int sampler =
      _mesa_get_sampler_uniform_value(ir->sampler, shader_prog, &fp->Base);
   /* FINISHME: We're failing to recompile our programs when the sampler is
    * updated.  This only matters for the texture rectangle scale parameters
    * (pre-gen6, or gen6+ with GL_CLAMP).
d1065 4
a1068 1
   int texunit = fp->Base.SamplerUnits[sampler];
d1070 1
a1070 10
   /* Should be lowered by do_lower_texture_projection */
   assert(!ir->projector);

   /* Generate code to compute all the subexpression trees.  This has to be
    * done before loading any values into MRFs for the sampler message since
    * generating these values may involve SEND messages that need the MRFs.
    */
   fs_reg coordinate;
   if (ir->coordinate) {
      ir->coordinate->accept(this);
a1071 7
      coordinate = rescale_texcoord(ir, this->result,
                                    ir->sampler->type->sampler_dimensionality ==
                                    GLSL_SAMPLER_DIM_RECT,
                                    sampler, texunit);
   }

   fs_reg shadow_comparitor;
d1073 23
a1095 3
      ir->shadow_comparitor->accept(this);
      shadow_comparitor = this->result;
   }
d1097 4
a1100 12
   fs_reg lod, lod2, sample_index;
   switch (ir->op) {
   case ir_tex:
   case ir_lod:
      break;
   case ir_txb:
      ir->lod_info.bias->accept(this);
      lod = this->result;
      break;
   case ir_txd:
      ir->lod_info.grad.dPdx->accept(this);
      lod = this->result;
d1102 2
a1103 14
      ir->lod_info.grad.dPdy->accept(this);
      lod2 = this->result;
      break;
   case ir_txf:
   case ir_txl:
   case ir_txs:
      ir->lod_info.lod->accept(this);
      lod = this->result;
      break;
   case ir_txf_ms:
      ir->lod_info.sample_index->accept(this);
      sample_index = this->result;
      break;
   };
d1105 2
a1106 4
   /* Writemasking doesn't eliminate channels on SIMD8 texture
    * samples, so don't worry about them.
    */
   fs_reg dst = fs_reg(this, glsl_type::get_instance(ir->type->base_type, 4, 1));
d1108 4
a1111 30
   if (brw->gen >= 7) {
      inst = emit_texture_gen7(ir, dst, coordinate, shadow_comparitor,
                               lod, lod2, sample_index);
   } else if (brw->gen >= 5) {
      inst = emit_texture_gen5(ir, dst, coordinate, shadow_comparitor,
                               lod, lod2, sample_index);
   } else {
      inst = emit_texture_gen4(ir, dst, coordinate, shadow_comparitor,
                               lod, lod2);
   }

   /* The header is set up by generate_tex() when necessary. */
   inst->src[0] = reg_undef;

   if (ir->offset != NULL && ir->op != ir_txf)
      inst->texture_offset = brw_texture_offset(ir->offset->as_constant());

   inst->sampler = sampler;

   if (ir->shadow_comparitor)
      inst->shadow_compare = true;

   /* fixup #layers for cube map arrays */
   if (ir->op == ir_txs) {
      glsl_type const *type = ir->sampler->type;
      if (type->sampler_dimensionality == GLSL_SAMPLER_DIM_CUBE &&
          type->sampler_array) {
         fs_reg depth = dst;
         depth.reg_offset = 2;
         emit_math(SHADER_OPCODE_INT_QUOTIENT, depth, depth, fs_reg(6));
a1126 3
   if (ir->op == ir_txs || ir->op == ir_lod)
      return;

d1130 1
a1130 1
   } else if (c->key.tex.swizzles[sampler] != SWIZZLE_NOOP) {
d1134 1
a1134 1
	 int swiz = GET_SWZ(c->key.tex.swizzles[sampler], i);
d1139 1
a1139 1
	    emit(MOV(l, fs_reg(0.0f)));
d1141 1
a1141 1
	    emit(MOV(l, fs_reg(1.0f)));
d1144 2
a1145 2
	    r.reg_offset += GET_SWZ(c->key.tex.swizzles[sampler], i);
	    emit(MOV(l, r));
d1155 1
d1187 1
a1187 1
      emit(MOV(result, channel));
d1197 2
a1198 25
   /* We track our discarded pixels in f0.1.  By predicating on it, we can
    * update just the flag bits that aren't yet discarded.  By emitting a
    * CMP of g0 != g0, all our currently executing channels will get turned
    * off.
    */
   fs_reg some_reg = fs_reg(retype(brw_vec8_grf(0, 0),
                                   BRW_REGISTER_TYPE_UW));
   fs_inst *cmp = emit(CMP(reg_null_f, some_reg, some_reg,
                           BRW_CONDITIONAL_NZ));
   cmp->predicate = BRW_PREDICATE_NORMAL;
   cmp->flag_subreg = 1;

   if (brw->gen >= 6) {
      /* For performance, after a discard, jump to the end of the shader.
       * However, many people will do foliage by discarding based on a
       * texture's alpha mask, and then continue on to texture with the
       * remaining pixels.  To avoid trashing the derivatives for those
       * texture samples, we'll only jump if all of the pixels in the subspan
       * have been discarded.
       */
      fs_inst *discard_jump = emit(FS_OPCODE_DISCARD_JUMP);
      discard_jump->flag_subreg = 1;
      discard_jump->predicate = BRW_PREDICATE_ALIGN1_ANY4H;
      discard_jump->predicate_inverse = true;
   }
d1218 1
d1224 1
a1224 1
	    emit(MOV(dst_reg, src_reg));
d1231 1
a1231 1
	 ir_constant *const field = (ir_constant *) node;
d1234 1
d1240 1
a1240 1
	    emit(MOV(dst_reg, src_reg));
d1251 1
a1251 1
	    emit(MOV(dst_reg, fs_reg(ir->value.f[i])));
d1254 1
a1254 1
	    emit(MOV(dst_reg, fs_reg(ir->value.u[i])));
d1257 1
a1257 1
	    emit(MOV(dst_reg, fs_reg(ir->value.i[i])));
d1260 1
a1260 1
	    emit(MOV(dst_reg, fs_reg((int)ir->value.b[i])));
d1285 1
a1287 2

	 resolve_ud_negate(&op[i]);
d1292 1
a1292 1
	 inst = emit(AND(reg_null_d, op[0], fs_reg(1)));
d1297 4
d1302 4
d1307 3
a1309 1
	 goto out;
d1312 2
a1313 2
	 if (brw->gen >= 6) {
	    emit(CMP(reg_null_d, op[0], fs_reg(0.0f), BRW_CONDITIONAL_NZ));
d1315 1
a1315 2
	    inst = emit(MOV(reg_null_f, op[0]));
            inst->conditional_mod = BRW_CONDITIONAL_NZ;
d1317 1
d1321 2
a1322 2
	 if (brw->gen >= 6) {
	    emit(CMP(reg_null_d, op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
d1324 1
a1324 2
	    inst = emit(MOV(reg_null_d, op[0]));
            inst->conditional_mod = BRW_CONDITIONAL_NZ;
d1326 1
d1337 3
a1339 5
	 resolve_bool_comparison(expr->operands[0], &op[0]);
	 resolve_bool_comparison(expr->operands[1], &op[1]);

	 emit(CMP(reg_null_d, op[0], op[1],
                  brw_conditional_for_comparison(expr->operation)));
d1350 1
a1350 1
out:
d1353 7
a1359 2
   fs_inst *inst = emit(AND(reg_null_d, this->result, fs_reg(1)));
   inst->conditional_mod = BRW_CONDITIONAL_NZ;
d1380 1
d1387 4
d1392 4
d1397 6
d1404 5
a1408 5
         /* For operations on bool arguments, only the low bit of the bool is
          * valid, and the others are undefined.  Fall back to the condition
          * code path.
          */
         break;
d1416 2
a1417 1
	 emit(IF(op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
d1428 3
a1430 5
	 resolve_bool_comparison(expr->operands[0], &op[0]);
	 resolve_bool_comparison(expr->operands[1], &op[1]);

	 emit(IF(op[0], op[1],
                 brw_conditional_for_comparison(expr->operation)));
d1434 2
a1435 1
	 emit(IF(op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
d1439 1
d1442 5
a1446 3
   emit_bool_to_cond_code(ir->condition);
   fs_inst *inst = emit(BRW_OPCODE_IF);
   inst->predicate = BRW_PREDICATE_NORMAL;
d1452 3
a1454 1
   if (brw->gen < 6 && dispatch_width == 16) {
d1463 1
a1463 1
   if (brw->gen == 6) {
d1468 2
a1469 1
      emit(IF(BRW_PREDICATE_NORMAL));
d1472 2
a1473 2
   foreach_list(node, &ir->then_instructions) {
      ir_instruction *ir = (ir_instruction *)node;
d1475 1
a1475 1

d1482 2
a1483 2
      foreach_list(node, &ir->else_instructions) {
	 ir_instruction *ir = (ir_instruction *)node;
d1485 1
a1485 1

d1498 1
a1498 1
   if (brw->gen < 6 && dispatch_width == 16) {
d1508 2
d1511 1
d1514 2
a1515 1
	 emit(MOV(counter, this->result));
a1518 1
   this->base_ir = NULL;
d1523 1
d1526 2
a1527 2
      emit(CMP(reg_null_d, counter, this->result,
               brw_conditional_for_comparison(ir->cmp)));
d1529 2
a1530 2
      fs_inst *inst = emit(BRW_OPCODE_BREAK);
      inst->predicate = BRW_PREDICATE_NORMAL;
d1533 2
a1534 2
   foreach_list(node, &ir->body_instructions) {
      ir_instruction *ir = (ir_instruction *)node;
d1537 1
d1543 1
d1545 1
a1545 1
      emit(ADD(counter, counter, this->result));
a1547 1
   this->base_ir = NULL;
d1590 2
a1591 2
      foreach_list(node, &sig->body) {
	 ir_instruction *ir = (ir_instruction *)node;
d1593 1
a1593 1

a1610 3
   emit(list_inst);
   return list_inst;
}
a1611 3
fs_inst *
fs_visitor::emit(fs_inst *inst)
{
d1613 1
a1613 1
      inst->force_uncompressed = true;
d1615 1
a1615 1
      inst->force_sechalf = true;
d1617 2
a1618 2
   inst->annotation = this->current_annotation;
   inst->ir = this->base_ir;
d1620 1
a1620 1
   this->instructions.push_tail(inst);
d1622 1
a1622 11
   return inst;
}

void
fs_visitor::emit(exec_list list)
{
   foreach_list_safe(node, &list) {
      fs_inst *inst = (fs_inst *)node;
      inst->remove();
      emit(inst);
   }
a1628 2
   int reg_width = dispatch_width / 8;

d1630 4
a1633 4
   emit(MOV(fs_reg(MRF, 2 + 0 * reg_width), fs_reg(1.0f)));
   emit(MOV(fs_reg(MRF, 2 + 1 * reg_width), fs_reg(0.0f)));
   emit(MOV(fs_reg(MRF, 2 + 2 * reg_width), fs_reg(1.0f)));
   emit(MOV(fs_reg(MRF, 2 + 3 * reg_width), fs_reg(0.0f)));
d1637 1
a1637 3
   write->base_mrf = 2;
   write->mlen = 4 * reg_width;
   write->eot = true;
d1670 3
a1672 5
      this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC] =
         fs_reg(this, glsl_type::vec2_type);
      this->delta_y[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC] =
         this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC];
      this->delta_y[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC].reg_offset++;
d1674 7
a1680 9
      this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC] =
         fs_reg(this, glsl_type::float_type);
      this->delta_y[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC] =
         fs_reg(this, glsl_type::float_type);
   }
   emit(ADD(this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC],
            this->pixel_x, fs_reg(negate(brw_vec1_grf(1, 0)))));
   emit(ADD(this->delta_y[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC],
            this->pixel_y, fs_reg(negate(brw_vec1_grf(1, 1)))));
d1687 2
a1688 4
   emit(FS_OPCODE_LINTERP, wpos_w,
        this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC],
        this->delta_y[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC],
	interp_reg(VARYING_SLOT_POS, 3));
d1691 1
a1691 1
   emit_math(SHADER_OPCODE_RCP, this->pixel_w, wpos_w);
d1707 8
a1714 6
   emit(ADD(int_pixel_x,
            fs_reg(stride(suboffset(g1_uw, 4), 2, 4, 0)),
            fs_reg(brw_imm_v(0x10101010))));
   emit(ADD(int_pixel_y,
            fs_reg(stride(suboffset(g1_uw, 5), 2, 4, 0)),
            fs_reg(brw_imm_v(0x11001100))));
d1722 2
a1723 2
   emit(MOV(this->pixel_x, int_pixel_x));
   emit(MOV(this->pixel_y, int_pixel_y));
d1728 1
a1728 1
   emit_math(SHADER_OPCODE_RCP, this->wpos_w, this->pixel_w);
d1730 2
a1731 5
   for (int i = 0; i < BRW_WM_BARYCENTRIC_INTERP_MODE_COUNT; ++i) {
      uint8_t reg = c->barycentric_coord_reg[i];
      this->delta_x[i] = fs_reg(brw_vec8_grf(reg, 0));
      this->delta_y[i] = fs_reg(brw_vec8_grf(reg + 1, 0));
   }
d1737 1
a1737 1
fs_visitor::emit_color_write(int target, int index, int first_color_mrf)
d1739 1
a1739 1
   int reg_width = dispatch_width / 8;
a1740 8
   fs_reg color = outputs[target];
   fs_reg mrf;

   /* If there's no color data to be written, skip it. */
   if (color.file == BAD_FILE)
      return;

   color.reg_offset += index;
d1742 1
a1742 1
   if (dispatch_width == 8 || brw->gen >= 6) {
d1759 3
a1761 3
      inst = emit(MOV(fs_reg(MRF, first_color_mrf + index * reg_width,
                             color.type),
                      color));
d1780 3
a1782 3
	 inst = emit(MOV(fs_reg(MRF, BRW_MRF_COMPR4 + first_color_mrf + index,
                                color.type),
                         color));
d1786 2
a1787 2
	 inst = emit(MOV(fs_reg(MRF, first_color_mrf + index, color.type),
                         color));
d1793 2
a1794 2
	 inst = emit(MOV(fs_reg(MRF, first_color_mrf + index + 4, color.type),
                         color));
d1806 3
a1808 14
   bool header_present = true;
   /* We can potentially have a message length of up to 15, so we have to set
    * base_mrf to either 0 or 1 in order to fit in m0..m15.
    */
   int base_mrf = 1;
   int nr = base_mrf;
   int reg_width = dispatch_width / 8;
   bool do_dual_src = this->dual_src_output.file != BAD_FILE;
   bool src0_alpha_to_render_target = false;

   if (dispatch_width == 16 && do_dual_src) {
      fail("GL_ARB_blend_func_extended not yet supported in 16-wide.");
      do_dual_src = false;
   }
d1810 2
a1811 10
   /* From the Sandy Bridge PRM, volume 4, page 198:
    *
    *     "Dispatched Pixel Enables. One bit per pixel indicating
    *      which pixels were originally enabled when the thread was
    *      dispatched. This field is only required for the end-of-
    *      thread message and on all dual-source messages."
    */
   if (brw->gen >= 6 &&
       !this->fp->UsesKill &&
       !do_dual_src &&
d1817 1
a1817 4
      src0_alpha_to_render_target = brw->gen >= 6 &&
				    !do_dual_src &&
                                    c->key.replicate_alpha;
      /* m2, m3 header */
d1823 2
a1824 2
      emit(MOV(fs_reg(MRF, nr++),
               fs_reg(brw_vec8_grf(c->aa_dest_stencil_reg, 0))));
a1830 4
   if (do_dual_src)
      nr += 4;
   if (src0_alpha_to_render_target)
      nr += reg_width;
d1833 1
a1833 1
      if (brw->gen == 6 && dispatch_width == 16) {
d1842 1
a1842 1
      if (fp->Base.OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_DEPTH)) {
d1844 4
a1847 2
	 assert(this->frag_depth.file != BAD_FILE);
	 emit(MOV(fs_reg(MRF, nr), this->frag_depth));
d1850 2
a1851 2
	 emit(MOV(fs_reg(MRF, nr),
                  fs_reg(brw_vec8_grf(c->source_depth_reg, 0))));
d1857 2
a1858 2
      emit(MOV(fs_reg(MRF, nr),
               fs_reg(brw_vec8_grf(c->dest_depth_reg, 0))));
d1862 6
a1867 34
   if (do_dual_src) {
      fs_reg src0 = this->outputs[0];
      fs_reg src1 = this->dual_src_output;

      this->current_annotation = ralloc_asprintf(this->mem_ctx,
						 "FB write src0");
      for (int i = 0; i < 4; i++) {
	 fs_inst *inst = emit(MOV(fs_reg(MRF, color_mrf + i, src0.type), src0));
	 src0.reg_offset++;
	 inst->saturate = c->key.clamp_fragment_color;
      }

      this->current_annotation = ralloc_asprintf(this->mem_ctx,
						 "FB write src1");
      for (int i = 0; i < 4; i++) {
	 fs_inst *inst = emit(MOV(fs_reg(MRF, color_mrf + 4 + i, src1.type),
                                  src1));
	 src1.reg_offset++;
	 inst->saturate = c->key.clamp_fragment_color;
      }

      if (INTEL_DEBUG & DEBUG_SHADER_TIME)
         emit_shader_time_end();

      fs_inst *inst = emit(FS_OPCODE_FB_WRITE);
      inst->target = 0;
      inst->base_mrf = base_mrf;
      inst->mlen = nr - base_mrf;
      inst->eot = true;
      inst->header_present = header_present;

      c->prog_data.dual_src_blend = true;
      this->current_annotation = NULL;
      return;
d1874 6
a1879 21
      /* If src0_alpha_to_render_target is true, include source zero alpha
       * data in RenderTargetWrite message for targets > 0.
       */
      int write_color_mrf = color_mrf;
      if (src0_alpha_to_render_target && target != 0) {
         fs_inst *inst;
         fs_reg color = outputs[0];
         color.reg_offset += 3;

         inst = emit(MOV(fs_reg(MRF, write_color_mrf, color.type),
                         color));
         inst->saturate = c->key.clamp_fragment_color;
         write_color_mrf = color_mrf + reg_width;
      }

      for (unsigned i = 0; i < this->output_components[target]; i++)
         emit_color_write(target, i, write_color_mrf);

      bool eot = false;
      if (target == c->key.nr_color_regions - 1) {
         eot = true;
d1881 2
a1882 3
         if (INTEL_DEBUG & DEBUG_SHADER_TIME)
            emit_shader_time_end();
      }
d1886 4
a1889 6
      inst->base_mrf = base_mrf;
      if (src0_alpha_to_render_target && target == 0)
         inst->mlen = nr - base_mrf - reg_width;
      else
         inst->mlen = nr - base_mrf;
      inst->eot = eot;
d1894 8
a1901 8
      /* Even if there's no color buffers enabled, we still need to send
       * alpha out the pipeline to our null renderbuffer to support
       * alpha-testing, alpha-to-coverage, and so on.
       */
      emit_color_write(0, 3, color_mrf);

      if (INTEL_DEBUG & DEBUG_SHADER_TIME)
         emit_shader_time_end();
d1904 2
a1905 2
      inst->base_mrf = base_mrf;
      inst->mlen = nr - base_mrf;
a1910 76
}

void
fs_visitor::resolve_ud_negate(fs_reg *reg)
{
   if (reg->type != BRW_REGISTER_TYPE_UD ||
       !reg->negate)
      return;

   fs_reg temp = fs_reg(this, glsl_type::uint_type);
   emit(MOV(temp, *reg));
   *reg = temp;
}

void
fs_visitor::resolve_bool_comparison(ir_rvalue *rvalue, fs_reg *reg)
{
   if (rvalue->type != glsl_type::bool_type)
      return;

   fs_reg temp = fs_reg(this, glsl_type::bool_type);
   emit(AND(temp, *reg, fs_reg(1)));
   *reg = temp;
}

fs_visitor::fs_visitor(struct brw_context *brw,
                       struct brw_wm_compile *c,
                       struct gl_shader_program *shader_prog,
                       struct gl_fragment_program *fp,
                       unsigned dispatch_width)
   : dispatch_width(dispatch_width)
{
   this->c = c;
   this->brw = brw;
   this->fp = fp;
   this->shader_prog = shader_prog;
   this->ctx = &brw->ctx;
   this->mem_ctx = ralloc_context(NULL);
   if (shader_prog)
      shader = (struct brw_shader *)
         shader_prog->_LinkedShaders[MESA_SHADER_FRAGMENT];
   else
      shader = NULL;
   this->failed = false;
   this->variable_ht = hash_table_ctor(0,
                                       hash_table_pointer_hash,
                                       hash_table_pointer_compare);

   memset(this->outputs, 0, sizeof(this->outputs));
   memset(this->output_components, 0, sizeof(this->output_components));
   this->first_non_payload_grf = 0;
   this->max_grf = brw->gen >= 7 ? GEN7_MRF_HACK_START : BRW_MAX_GRF;

   this->current_annotation = NULL;
   this->base_ir = NULL;

   this->virtual_grf_sizes = NULL;
   this->virtual_grf_count = 0;
   this->virtual_grf_array_size = 0;
   this->virtual_grf_start = NULL;
   this->virtual_grf_end = NULL;
   this->live_intervals_valid = false;

   this->params_remap = NULL;
   this->nr_params_remap = 0;

   this->force_uncompressed_stack = 0;
   this->force_sechalf_stack = 0;

   memset(&this->param_size, 0, sizeof(this->param_size));
}

fs_visitor::~fs_visitor()
{
   ralloc_free(this->mem_ctx);
   hash_table_dtor(this->variable_ht);
@


1.1.1.2
log
@Import Mesa 9.2.1
@
text
@d871 1
a871 7

      /* gen4's SIMD8 sampler always has the slots for u,v,r present.
       * the unused slots must be zeroed.
       */
      for (int i = ir->coordinate->type->vector_elements; i < 3; i++) {
         emit(MOV(fs_reg(MRF, base_mrf + mlen + i), fs_reg(0.0f)));
      }
@


1.1.1.3
log
@Import Mesa 9.2.5
@
text
@a2230 54
static int
cond_for_alpha_func(GLenum func)
{
   switch(func) {
      case GL_GREATER:
         return BRW_CONDITIONAL_G;
      case GL_GEQUAL:
         return BRW_CONDITIONAL_GE;
      case GL_LESS:
         return BRW_CONDITIONAL_L;
      case GL_LEQUAL:
         return BRW_CONDITIONAL_LE;
      case GL_EQUAL:
         return BRW_CONDITIONAL_EQ;
      case GL_NOTEQUAL:
         return BRW_CONDITIONAL_NEQ;
      default:
         assert(!"Not reached");
         return 0;
   }
}

/**
 * Alpha test support for when we compile it into the shader instead
 * of using the normal fixed-function alpha test.
 */
void
fs_visitor::emit_alpha_test()
{
   this->current_annotation = "Alpha test";

   fs_inst *cmp;
   if (c->key.alpha_test_func == GL_ALWAYS)
      return;

   if (c->key.alpha_test_func == GL_NEVER) {
      /* f0.1 = 0 */
      fs_reg some_reg = fs_reg(retype(brw_vec8_grf(0, 0),
                                      BRW_REGISTER_TYPE_UW));
      cmp = emit(CMP(reg_null_f, some_reg, some_reg,
                     BRW_CONDITIONAL_NEQ));
   } else {
      /* RT0 alpha */
      fs_reg color = outputs[0];
      color.reg_offset += 3;

      /* f0.1 &= func(color, ref) */
      cmp = emit(CMP(reg_null_f, color, fs_reg(c->key.alpha_test_ref),
                     cond_for_alpha_func(c->key.alpha_test_func)));
   }
   cmp->predicate = BRW_PREDICATE_NORMAL;
   cmp->flag_subreg = 1;
}

@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d36 1
a47 1
#include "main/uniforms.h"
d59 1
a59 1
   if (ir->data.mode == ir_var_shader_in) {
d70 1
a70 1
   } else if (ir->data.mode == ir_var_shader_out) {
d73 3
a75 3
      if (ir->data.index > 0) {
	 assert(ir->data.location == FRAG_RESULT_DATA0);
	 assert(ir->data.index == 1);
d77 1
a77 2
         this->do_dual_src = true;
      } else if (ir->data.location == FRAG_RESULT_COLOR) {
d83 1
a83 1
      } else if (ir->data.location == FRAG_RESULT_DEPTH) {
a84 2
      } else if (ir->data.location == FRAG_RESULT_SAMPLE_MASK) {
         this->sample_mask = *reg;
d87 2
a88 2
	 assert(ir->data.location >= FRAG_RESULT_DATA0 &&
		ir->data.location < FRAG_RESULT_DATA0 + BRW_MAX_DRAW_BUFFERS);
d96 1
a96 1
	    int output = ir->data.location - FRAG_RESULT_DATA0 + i;
d102 2
a103 2
   } else if (ir->data.mode == ir_var_uniform) {
      int param_index = uniforms;
a107 3
       *
       * Atomic counters take no uniform storage, no need to do
       * anything here.
d109 1
a109 1
      if (ir->is_in_uniform_block() || ir->type->contains_atomic())
d114 1
a114 1
	    fail("Failed to find uniform '%s' in SIMD16\n", ir->name);
a127 9

   } else if (ir->data.mode == ir_var_system_value) {
      if (ir->data.location == SYSTEM_VALUE_SAMPLE_POS) {
	 reg = emit_samplepos_setup(ir);
      } else if (ir->data.location == SYSTEM_VALUE_SAMPLE_ID) {
	 reg = emit_sampleid_setup(ir);
      } else if (ir->data.location == SYSTEM_VALUE_SAMPLE_MASK_IN) {
         reg = emit_samplemaskin_setup(ir);
      }
d201 1
a201 2
fs_visitor::emit_lrp(const fs_reg &dst, const fs_reg &x, const fs_reg &y,
                     const fs_reg &a)
d214 2
a215 3
      fs_reg negative_a = a;
      negative_a.negate = !a.negate;
      emit(ADD(one_minus_a, negative_a, fs_reg(1.0f)));
d228 2
a229 2
fs_visitor::emit_minmax(uint32_t conditionalmod, const fs_reg &dst,
                        const fs_reg &src0, const fs_reg &src1)
d280 1
a280 1
fs_visitor::try_emit_mad(ir_expression *ir)
d290 2
a291 2
   ir_rvalue *nonmul = ir->operands[1];
   ir_expression *mul = ir->operands[0]->as_expression();
d293 2
a294 7
   if (!mul || mul->operation != ir_binop_mul) {
      nonmul = ir->operands[0];
      mul = ir->operands[1]->as_expression();

      if (!mul || mul->operation != ir_binop_mul)
         return false;
   }
d328 1
a328 1
      if (try_emit_mad(ir))
d336 2
a337 2
	 ir->operands[operand]->fprint(stderr);
         fprintf(stderr, "\n");
a338 1
      assert(this->result.is_valid_3src());
d372 1
a372 7
      if (ir->type->is_float()) {
         /* AND(val, 0x80000000) gives the sign bit.
          *
          * Predicated OR ORs 1.0 (0x3f800000) with the sign bit if val is not
          * zero.
          */
         emit(CMP(reg_null_f, op[0], fs_reg(0.0f), BRW_CONDITIONAL_NZ));
d374 1
a374 3
         op[0].type = BRW_REGISTER_TYPE_UD;
         this->result.type = BRW_REGISTER_TYPE_UD;
         emit(AND(this->result, op[0], fs_reg(0x80000000u)));
d376 3
a378 2
         inst = emit(OR(this->result, this->result, fs_reg(0x3f800000u)));
         inst->predicate = BRW_PREDICATE_NORMAL;
d380 3
a382 7
         this->result.type = BRW_REGISTER_TYPE_F;
      } else {
         /*  ASR(val, 31) -> negative val generates 0xffffffff (signed -1).
          *               -> non-negative val generates 0x00000000.
          *  Predicated OR sets 1 if val is positive.
          */
         emit(CMP(reg_null_d, op[0], fs_reg(0), BRW_CONDITIONAL_G));
a383 5
         emit(ASR(this->result, op[0], fs_reg(31)));

         inst = emit(OR(this->result, this->result, fs_reg(1)));
         inst->predicate = BRW_PREDICATE_NORMAL;
      }
d423 1
a423 1
      if (brw->gen < 8 && ir->type->is_integer()) {
d428 12
a439 21
          */
         if (ir->operands[0]->is_uint16_constant()) {
            if (brw->gen < 7)
               emit(MUL(this->result, op[0], op[1]));
            else
               emit(MUL(this->result, op[1], op[0]));
         } else if (ir->operands[1]->is_uint16_constant()) {
            if (brw->gen < 7)
               emit(MUL(this->result, op[1], op[0]));
            else
               emit(MUL(this->result, op[0], op[1]));
         } else {
            if (brw->gen >= 7)
               no16("SIMD16 explicit accumulator operands unsupported\n");

            struct brw_reg acc = retype(brw_acc_reg(), this->result.type);

            emit(MUL(acc, op[0], op[1]));
            emit(MACH(reg_null_d, op[0], op[1]));
            emit(MOV(this->result, fs_reg(acc)));
         }
a443 10
   case ir_binop_imul_high: {
      if (brw->gen >= 7)
         no16("SIMD16 explicit accumulator operands unsupported\n");

      struct brw_reg acc = retype(brw_acc_reg(), this->result.type);

      emit(MUL(acc, op[0], op[1]));
      emit(MACH(this->result, op[0], op[1]));
      break;
   }
a448 20
   case ir_binop_carry: {
      if (brw->gen >= 7)
         no16("SIMD16 explicit accumulator operands unsupported\n");

      struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_UD);

      emit(ADDC(reg_null_ud, op[0], op[1]));
      emit(MOV(this->result, fs_reg(acc)));
      break;
   }
   case ir_binop_borrow: {
      if (brw->gen >= 7)
         no16("SIMD16 explicit accumulator operands unsupported\n");

      struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_UD);

      emit(SUBB(reg_null_ud, op[0], op[1]));
      emit(MOV(this->result, fs_reg(acc)));
      break;
   }
a502 4
   case ir_binop_ldexp:
      assert(!"not reached: should be handled by ldexp_to_arith()");
      break;

d672 1
a672 2
      fs_reg surf_index = fs_reg(c->prog_data.base.binding_table.ubo_start +
                                 uniform_block->value.u[0]);
d678 2
a679 2
         emit(new(mem_ctx) fs_inst(FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD,
                                   packed_consts, surf_index, const_offset_reg));
d681 1
a682 7
            packed_consts.set_smear(const_offset->value.u[0] % 16 / 4 + i);

            /* The std140 packing rules don't allow vectors to cross 16-byte
             * boundaries, and a reg is 32 bytes.
             */
            assert(packed_consts.subreg_offset < 32);

d692 1
d694 5
a719 7
   case ir_triop_fma:
      /* Note that the instruction's argument order is reversed from GLSL
       * and the IR.
       */
      emit(MAD(this->result, op[2], op[1], op[0]));
      break;

a722 6

   case ir_triop_csel:
      emit(CMP(reg_null_d, op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
      inst = emit(BRW_OPCODE_SEL, this->result, op[1], op[2]);
      inst->predicate = BRW_PREDICATE_NORMAL;
      break;
a761 2
   case GLSL_TYPE_IMAGE:
   case GLSL_TYPE_ATOMIC_UINT:
d1047 22
a1068 8
   if (ir->offset) {
      /* The offsets set up by the ir_texture visitor are in the
       * m1 header, so we can't go headerless.
       */
      header_present = true;
      mlen++;
      base_mrf--;
   }
d1070 5
a1074 4
   for (int i = 0; i < vector_elements; i++) {
      emit(MOV(fs_reg(MRF, base_mrf + mlen + i * reg_width, coordinate.type),
               coordinate));
      coordinate.reg_offset++;
a1133 5
   case ir_query_levels:
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
      mlen += reg_width;
      inst = emit(SHADER_OPCODE_TXS, dst);
      break;
d1147 1
a1147 1
      inst = emit(SHADER_OPCODE_TXF_CMS, dst);
a1151 6
   case ir_tg4:
      inst = emit(SHADER_OPCODE_TG4, dst);
      break;
   default:
      fail("unrecognized texture opcode");
      break;
d1158 2
a1159 3
   if (mlen > MAX_SAMPLER_MESSAGE_SIZE) {
      fail("Message length >" STRINGIFY(MAX_SAMPLER_MESSAGE_SIZE)
           " disallowed by hardware\n");
d1168 1
a1168 1
                              fs_reg sample_index, fs_reg mcs, int sampler)
d1170 2
d1174 1
d1176 3
a1178 13
   fs_reg payload = fs_reg(this, glsl_type::float_type);
   fs_reg next = payload;

   if (ir->op == ir_tg4 || (ir->offset && ir->op != ir_txf) || sampler >= 16) {
      /* For general texture offsets (no txf workaround), we need a header to
       * put them in.  Note that for SIMD16 we're making space for two actual
       * hardware registers here, so the emit will have to fix up for this.
       *
       * * ir4_tg4 needs to place its channel select in the header,
       * for interaction with ARB_texture_swizzle
       *
       * The sampler index is only 4-bits, so for larger sampler numbers we
       * need to offset the Sampler State Pointer in the header.
d1181 2
a1182 1
      next.reg_offset++;
d1186 2
a1187 2
      emit(MOV(next, shadow_c));
      next.reg_offset++;
a1189 3
   bool has_nonconstant_offset = ir->offset && !ir->offset->as_constant();
   bool coordinate_done = false;

d1196 2
a1197 2
      emit(MOV(next, lod));
      next.reg_offset++;
d1200 2
a1201 2
      emit(MOV(next, lod));
      next.reg_offset++;
d1204 2
a1205 1
      no16("Gen7 does not support sample_d/sample_d_c in SIMD16 mode.");
d1211 1
a1211 1
	 emit(MOV(next, coordinate));
d1213 1
a1213 1
	 next.reg_offset++;
d1219 1
a1219 1
            emit(MOV(next, lod));
d1221 1
a1221 1
            next.reg_offset++;
d1223 1
a1223 1
            emit(MOV(next, lod2));
d1225 1
a1225 1
            next.reg_offset++;
a1227 2

      coordinate_done = true;
d1231 2
a1232 6
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), lod));
      next.reg_offset++;
      break;
   case ir_query_levels:
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
      next.reg_offset++;
d1235 14
d1250 2
a1251 1
      emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
d1253 1
a1253 1
      next.reg_offset++;
d1255 2
a1256 2
      emit(MOV(retype(next, BRW_REGISTER_TYPE_D), lod));
      next.reg_offset++;
d1259 2
a1260 1
	 emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
d1262 1
a1262 1
	 next.reg_offset++;
a1263 2

      coordinate_done = true;
d1266 2
a1267 2
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), sample_index));
      next.reg_offset++;
d1269 6
a1274 3
      /* data from the multisample control surface */
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), mcs));
      next.reg_offset++;
d1280 2
a1281 1
         emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
d1283 1
a1283 33
         next.reg_offset++;
      }

      coordinate_done = true;
      break;
   case ir_tg4:
      if (has_nonconstant_offset) {
         if (ir->shadow_comparitor)
            no16("Gen7 does not support gather4_po_c in SIMD16 mode.");

         /* More crazy intermixing */
         ir->offset->accept(this);
         fs_reg offset_value = this->result;

         for (int i = 0; i < 2; i++) { /* u, v */
            emit(MOV(next, coordinate));
            coordinate.reg_offset++;
            next.reg_offset++;
         }

         for (int i = 0; i < 2; i++) { /* offu, offv */
            emit(MOV(retype(next, BRW_REGISTER_TYPE_D), offset_value));
            offset_value.reg_offset++;
            next.reg_offset++;
         }

         if (ir->coordinate->type->vector_elements == 3) { /* r if present */
            emit(MOV(next, coordinate));
            coordinate.reg_offset++;
            next.reg_offset++;
         }

         coordinate_done = true;
d1289 1
a1289 1
   if (ir->coordinate && !coordinate_done) {
d1291 3
a1293 3
         emit(MOV(next, coordinate));
         coordinate.reg_offset++;
         next.reg_offset++;
d1300 8
a1307 15
   case ir_tex: inst = emit(SHADER_OPCODE_TEX, dst, payload); break;
   case ir_txb: inst = emit(FS_OPCODE_TXB, dst, payload); break;
   case ir_txl: inst = emit(SHADER_OPCODE_TXL, dst, payload); break;
   case ir_txd: inst = emit(SHADER_OPCODE_TXD, dst, payload); break;
   case ir_txf: inst = emit(SHADER_OPCODE_TXF, dst, payload); break;
   case ir_txf_ms: inst = emit(SHADER_OPCODE_TXF_CMS, dst, payload); break;
   case ir_txs: inst = emit(SHADER_OPCODE_TXS, dst, payload); break;
   case ir_query_levels: inst = emit(SHADER_OPCODE_TXS, dst, payload); break;
   case ir_lod: inst = emit(SHADER_OPCODE_LOD, dst, payload); break;
   case ir_tg4:
      if (has_nonconstant_offset)
         inst = emit(SHADER_OPCODE_TG4_OFFSET, dst, payload);
      else
         inst = emit(SHADER_OPCODE_TG4, dst, payload);
      break;
d1309 2
a1310 5
   inst->base_mrf = -1;
   if (reg_width == 2)
      inst->mlen = next.reg_offset * reg_width - header_present;
   else
      inst->mlen = next.reg_offset * reg_width;
d1314 2
a1315 4
   virtual_grf_sizes[payload.reg] = next.reg_offset;
   if (inst->mlen > MAX_SAMPLER_MESSAGE_SIZE) {
      fail("Message length >" STRINGIFY(MAX_SAMPLER_MESSAGE_SIZE)
           " disallowed by hardware\n");
d1337 1
a1337 1
      struct gl_program_parameter_list *params = prog->Parameters;
a1345 1
      no16("rectangle scale uniform setup not supported on SIMD16\n");
d1347 1
d1351 3
d1356 4
a1359 20
      /* Try to find existing copies of the texrect scale uniforms. */
      for (unsigned i = 0; i < uniforms; i++) {
         if (stage_prog_data->param[i] ==
             &prog->Parameters->ParameterValues[index][0].f) {
            scale_x = fs_reg(UNIFORM, i);
            scale_y = fs_reg(UNIFORM, i + 1);
            break;
         }
      }

      /* If we didn't already set them up, do so now. */
      if (scale_x.file == BAD_FILE) {
         scale_x = fs_reg(UNIFORM, uniforms);
         scale_y = fs_reg(UNIFORM, uniforms + 1);

         stage_prog_data->param[uniforms++] =
            &prog->Parameters->ParameterValues[index][0].f;
         stage_prog_data->param[uniforms++] =
            &prog->Parameters->ParameterValues[index][1].f;
      }
a1421 29
/* Sample from the MCS surface attached to this multisample texture. */
fs_reg
fs_visitor::emit_mcs_fetch(ir_texture *ir, fs_reg coordinate, int sampler)
{
   int reg_width = dispatch_width / 8;
   fs_reg payload = fs_reg(this, glsl_type::float_type);
   fs_reg dest = fs_reg(this, glsl_type::uvec4_type);
   fs_reg next = payload;

   /* parameters are: u, v, r, lod; missing parameters are treated as zero */
   for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
      emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
      coordinate.reg_offset++;
      next.reg_offset++;
   }

   fs_inst *inst = emit(SHADER_OPCODE_TXF_MCS, dest, payload);
   virtual_grf_sizes[payload.reg] = next.reg_offset;
   inst->base_mrf = -1;
   inst->mlen = next.reg_offset * reg_width;
   inst->header_present = false;
   inst->regs_written = 4 * reg_width; /* we only care about one reg of response,
                                        * but the sampler always writes 4/8
                                        */
   inst->sampler = sampler;

   return dest;
}

d1428 1
a1428 1
      _mesa_get_sampler_uniform_value(ir->sampler, shader_prog, prog);
d1433 1
a1433 20
   int texunit = prog->SamplerUnits[sampler];

   if (ir->op == ir_tg4) {
      /* When tg4 is used with the degenerate ZERO/ONE swizzles, don't bother
       * emitting anything other than setting up the constant result.
       */
      ir_constant *chan = ir->lod_info.component->as_constant();
      int swiz = GET_SWZ(c->key.tex.swizzles[sampler], chan->value.i[0]);
      if (swiz == SWIZZLE_ZERO || swiz == SWIZZLE_ONE) {

         fs_reg res = fs_reg(this, glsl_type::vec4_type);
         this->result = res;

         for (int i=0; i<4; i++) {
            emit(MOV(res, fs_reg(swiz == SWIZZLE_ZERO ? 0.0f : 1.0f)));
            res.reg_offset++;
         }
         return;
      }
   }
a1437 3
   /* Should be lowered */
   assert(!ir->offset || !ir->offset->type->is_array());

d1458 1
a1458 1
   fs_reg lod, lod2, sample_index, mcs;
a1461 2
   case ir_tg4:
   case ir_query_levels:
a1482 5

      if (brw->gen >= 7 && c->key.tex.compressed_multisample_layout_mask & (1<<sampler))
         mcs = emit_mcs_fetch(ir, coordinate, sampler);
      else
         mcs = fs_reg(0u);
a1483 2
   default:
      assert(!"Unrecognized texture opcode");
d1493 1
a1493 1
                               lod, lod2, sample_index, mcs, sampler);
d1502 3
d1506 1
a1506 4
      inst->texture_offset = brw_texture_offset(ctx, ir->offset->as_constant());

   if (ir->op == ir_tg4)
      inst->texture_offset |= gather_channel(ir, sampler) << 16; // M0.2:16-17
a1523 4
   if (brw->gen == 6 && ir->op == ir_tg4) {
      emit_gen6_gather_wa(c->key.tex.gen6_gather_wa[sampler], dst);
   }

a1527 55
 * Apply workarounds for Gen6 gather with UINT/SINT
 */
void
fs_visitor::emit_gen6_gather_wa(uint8_t wa, fs_reg dst)
{
   if (!wa)
      return;

   int width = (wa & WA_8BIT) ? 8 : 16;

   for (int i = 0; i < 4; i++) {
      fs_reg dst_f = retype(dst, BRW_REGISTER_TYPE_F);
      /* Convert from UNORM to UINT */
      emit(MUL(dst_f, dst_f, fs_reg((float)((1 << width) - 1))));
      emit(MOV(dst, dst_f));

      if (wa & WA_SIGN) {
         /* Reinterpret the UINT value as a signed INT value by
          * shifting the sign bit into place, then shifting back
          * preserving sign.
          */
         emit(SHL(dst, dst, fs_reg(32 - width)));
         emit(ASR(dst, dst, fs_reg(32 - width)));
      }

      dst.reg_offset++;
   }
}

/**
 * Set up the gather channel based on the swizzle, for gather4.
 */
uint32_t
fs_visitor::gather_channel(ir_texture *ir, int sampler)
{
   ir_constant *chan = ir->lod_info.component->as_constant();
   int swiz = GET_SWZ(c->key.tex.swizzles[sampler], chan->value.i[0]);
   switch (swiz) {
      case SWIZZLE_X: return 0;
      case SWIZZLE_Y:
         /* gather4 sampler is broken for green channel on RG32F --
          * we must ask for blue instead.
          */
         if (c->key.tex.gather_channel_quirk_mask & (1<<sampler))
            return 2;
         return 1;
      case SWIZZLE_Z: return 2;
      case SWIZZLE_W: return 3;
      default:
         assert(!"Not reached"); /* zero, one swizzles handled already */
         return 0;
   }
}

/**
a1533 7
   if (ir->op == ir_query_levels) {
      /* # levels is in .w */
      orig_val.reg_offset += 3;
      this->result = orig_val;
      return;
   }

d1536 1
a1536 4
   /* txs,lod don't actually sample the texture, so swizzling the result
    * makes no sense.
    */
   if (ir->op == ir_txs || ir->op == ir_lod || ir->op == ir_tg4)
d1709 1
a1709 4
   if (expr &&
       expr->operation != ir_binop_logic_and &&
       expr->operation != ir_binop_logic_or &&
       expr->operation != ir_binop_logic_xor) {
d1729 5
d1775 1
a1850 85
/**
 * Try to replace IF/MOV/ELSE/MOV/ENDIF with SEL.
 *
 * Many GLSL shaders contain the following pattern:
 *
 *    x = condition ? foo : bar
 *
 * The compiler emits an ir_if tree for this, since each subexpression might be
 * a complex tree that could have side-effects or short-circuit logic.
 *
 * However, the common case is to simply select one of two constants or
 * variable values---which is exactly what SEL is for.  In this case, the
 * assembly looks like:
 *
 *    (+f0) IF
 *    MOV dst src0
 *    ELSE
 *    MOV dst src1
 *    ENDIF
 *
 * which can be easily translated into:
 *
 *    (+f0) SEL dst src0 src1
 *
 * If src0 is an immediate value, we promote it to a temporary GRF.
 */
void
fs_visitor::try_replace_with_sel()
{
   fs_inst *endif_inst = (fs_inst *) instructions.get_tail();
   assert(endif_inst->opcode == BRW_OPCODE_ENDIF);

   /* Pattern match in reverse: IF, MOV, ELSE, MOV, ENDIF. */
   int opcodes[] = {
      BRW_OPCODE_IF, BRW_OPCODE_MOV, BRW_OPCODE_ELSE, BRW_OPCODE_MOV,
   };

   fs_inst *match = (fs_inst *) endif_inst->prev;
   for (int i = 0; i < 4; i++) {
      if (match->is_head_sentinel() || match->opcode != opcodes[4-i-1])
         return;
      match = (fs_inst *) match->prev;
   }

   /* The opcodes match; it looks like the right sequence of instructions. */
   fs_inst *else_mov = (fs_inst *) endif_inst->prev;
   fs_inst *then_mov = (fs_inst *) else_mov->prev->prev;
   fs_inst *if_inst = (fs_inst *) then_mov->prev;

   /* Check that the MOVs are the right form. */
   if (then_mov->dst.equals(else_mov->dst) &&
       !then_mov->is_partial_write() &&
       !else_mov->is_partial_write()) {

      /* Remove the matched instructions; we'll emit a SEL to replace them. */
      while (!if_inst->next->is_tail_sentinel())
         if_inst->next->remove();
      if_inst->remove();

      /* Only the last source register can be a constant, so if the MOV in
       * the "then" clause uses a constant, we need to put it in a temporary.
       */
      fs_reg src0(then_mov->src[0]);
      if (src0.file == IMM) {
         src0 = fs_reg(this, glsl_type::float_type);
         src0.type = then_mov->src[0].type;
         emit(MOV(src0, then_mov->src[0]));
      }

      fs_inst *sel;
      if (if_inst->conditional_mod) {
         /* Sandybridge-specific IF with embedded comparison */
         emit(CMP(reg_null_d, if_inst->src[0], if_inst->src[1],
                  if_inst->conditional_mod));
         sel = emit(BRW_OPCODE_SEL, then_mov->dst, src0, else_mov->src[0]);
         sel->predicate = BRW_PREDICATE_NORMAL;
      } else {
         /* Separate CMP and IF instructions */
         sel = emit(BRW_OPCODE_SEL, then_mov->dst, src0, else_mov->src[0]);
         sel->predicate = if_inst->predicate;
         sel->predicate_inverse = if_inst->predicate_inverse;
      }
   }
}

d1854 2
a1855 2
   if (brw->gen < 6) {
      no16("Can't support (non-uniform) control flow on SIMD16\n");
a1889 2

   try_replace_with_sel();
d1895 17
a1911 2
   if (brw->gen < 6) {
      no16("Can't support (non-uniform) control flow on SIMD16\n");
d1917 11
d1935 6
a1958 41
fs_visitor::visit_atomic_counter_intrinsic(ir_call *ir)
{
   ir_dereference *deref = static_cast<ir_dereference *>(
      ir->actual_parameters.get_head());
   ir_variable *location = deref->variable_referenced();
   unsigned surf_index = (c->prog_data.base.binding_table.abo_start +
                          location->data.atomic.buffer_index);

   /* Calculate the surface offset */
   fs_reg offset(this, glsl_type::uint_type);
   ir_dereference_array *deref_array = deref->as_dereference_array();

   if (deref_array) {
      deref_array->array_index->accept(this);

      fs_reg tmp(this, glsl_type::uint_type);
      emit(MUL(tmp, this->result, ATOMIC_COUNTER_SIZE));
      emit(ADD(offset, tmp, location->data.atomic.offset));
   } else {
      offset = location->data.atomic.offset;
   }

   /* Emit the appropriate machine instruction */
   const char *callee = ir->callee->function_name();
   ir->return_deref->accept(this);
   fs_reg dst = this->result;

   if (!strcmp("__intrinsic_atomic_read", callee)) {
      emit_untyped_surface_read(surf_index, dst, offset);

   } else if (!strcmp("__intrinsic_atomic_increment", callee)) {
      emit_untyped_atomic(BRW_AOP_INC, surf_index, dst, offset,
                          fs_reg(), fs_reg());

   } else if (!strcmp("__intrinsic_atomic_predecrement", callee)) {
      emit_untyped_atomic(BRW_AOP_PREDEC, surf_index, dst, offset,
                          fs_reg(), fs_reg());
   }
}

void
d1961 1
a1961 9
   const char *callee = ir->callee->function_name();

   if (!strcmp("__intrinsic_atomic_read", callee) ||
       !strcmp("__intrinsic_atomic_increment", callee) ||
       !strcmp("__intrinsic_atomic_predecrement", callee)) {
      visit_atomic_counter_intrinsic(ir);
   } else {
      assert(!"Unsupported intrinsic.");
   }
d1980 1
a1980 1
      sig = ir->matching_signature(NULL, &empty);
d2000 2
a2001 62
void
fs_visitor::visit(ir_emit_vertex *)
{
   assert(!"not reached");
}

void
fs_visitor::visit(ir_end_primitive *)
{
   assert(!"not reached");
}

void
fs_visitor::emit_untyped_atomic(unsigned atomic_op, unsigned surf_index,
                                fs_reg dst, fs_reg offset, fs_reg src0,
                                fs_reg src1)
{
   const unsigned operand_len = dispatch_width / 8;
   unsigned mlen = 0;

   /* Initialize the sample mask in the message header. */
   emit(MOV(brw_uvec_mrf(8, mlen, 0), brw_imm_ud(0)))
      ->force_writemask_all = true;

   if (fp->UsesKill) {
      emit(MOV(brw_uvec_mrf(1, mlen, 7), brw_flag_reg(0, 1)))
         ->force_writemask_all = true;
   } else {
      emit(MOV(brw_uvec_mrf(1, mlen, 7),
               retype(brw_vec1_grf(1, 7), BRW_REGISTER_TYPE_UD)))
         ->force_writemask_all = true;
   }

   mlen++;

   /* Set the atomic operation offset. */
   emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), offset));
   mlen += operand_len;

   /* Set the atomic operation arguments. */
   if (src0.file != BAD_FILE) {
      emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), src0));
      mlen += operand_len;
   }

   if (src1.file != BAD_FILE) {
      emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), src1));
      mlen += operand_len;
   }

   /* Emit the instruction. */
   fs_inst *inst = new(mem_ctx) fs_inst(SHADER_OPCODE_UNTYPED_ATOMIC, dst,
                                        atomic_op, surf_index);
   inst->base_mrf = 0;
   inst->mlen = mlen;
   inst->header_present = true;
   emit(inst);
}

void
fs_visitor::emit_untyped_surface_read(unsigned surf_index, fs_reg dst,
                                      fs_reg offset)
d2003 4
a2006 29
   const unsigned operand_len = dispatch_width / 8;
   unsigned mlen = 0;

   /* Initialize the sample mask in the message header. */
   emit(MOV(brw_uvec_mrf(8, mlen, 0), brw_imm_ud(0)))
      ->force_writemask_all = true;

   if (fp->UsesKill) {
      emit(MOV(brw_uvec_mrf(1, mlen, 7), brw_flag_reg(0, 1)))
         ->force_writemask_all = true;
   } else {
      emit(MOV(brw_uvec_mrf(1, mlen, 7),
               retype(brw_vec1_grf(1, 7), BRW_REGISTER_TYPE_UD)))
         ->force_writemask_all = true;
   }

   mlen++;

   /* Set the surface read offset. */
   emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), offset));
   mlen += operand_len;

   /* Emit the instruction. */
   fs_inst *inst = new(mem_ctx)
      fs_inst(SHADER_OPCODE_UNTYPED_SURFACE_READ, dst, surf_index);
   inst->base_mrf = 0;
   inst->mlen = mlen;
   inst->header_present = true;
   emit(inst);
d2014 2
d2061 1
a2061 1
   int regnr = c->prog_data.urb_setup[location] * 2 + channel / 2;
d2064 1
a2064 1
   assert(c->prog_data.urb_setup[location] != -1);
d2220 2
d2223 1
a2223 2
                         half(color, 1)));
	 inst->force_sechalf = true;
d2225 2
d2296 1
d2299 3
a2301 4
   if (do_dual_src) {
      no16("GL_ARB_blend_func_extended not yet supported in SIMD16.");
      if (dispatch_width == 16)
         do_dual_src = false;
d2312 1
a2312 1
       (brw->is_haswell || brw->gen >= 8 || !this->fp->UsesKill) &&
a2332 10
   c->prog_data.uses_omask =
      fp->Base.OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_SAMPLE_MASK);
   if(c->prog_data.uses_omask) {
      this->current_annotation = "FB write oMask";
      assert(this->sample_mask.file != BAD_FILE);
      /* Hand over gl_SampleMask. Only lower 16 bits are relevant. */
      emit(FS_OPCODE_SET_OMASK, fs_reg(MRF, nr, BRW_REGISTER_TYPE_UW), this->sample_mask);
      nr += 1;
   }

d2342 1
a2342 1
      if (brw->gen == 6) {
d2344 1
a2344 1
	  * used.  This would require SIMD8 moves of each half to
d2348 1
a2348 1
	 no16("Missing support for simd16 depth writes on gen6\n");
d2351 1
a2351 1
      if (prog->OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_DEPTH)) {
a2398 4
      if ((brw->gen >= 8 || brw->is_haswell) && fp->UsesKill) {
         inst->predicate = BRW_PREDICATE_NORMAL;
         inst->flag_subreg = 1;
      }
a2443 4
      if ((brw->gen >= 8 || brw->is_haswell) && fp->UsesKill) {
         inst->predicate = BRW_PREDICATE_NORMAL;
         inst->flag_subreg = 1;
      }
a2460 4
      if ((brw->gen >= 8 || brw->is_haswell) && fp->UsesKill) {
         inst->predicate = BRW_PREDICATE_NORMAL;
         inst->flag_subreg = 1;
      }
d2494 1
a2494 3
   : backend_visitor(brw, shader_prog, &fp->Base, &c->prog_data.base,
                     MESA_SHADER_FRAGMENT),
     dispatch_width(dispatch_width)
d2497 1
d2499 2
d2502 5
a2507 2
   this->simd16_unsupported = false;
   this->no16_msg = NULL;
d2525 1
a2525 2
   this->live_intervals = NULL;
   this->regs_live_at_ip = NULL;
d2527 2
a2528 3
   this->uniforms = 0;
   this->pull_constant_loc = NULL;
   this->push_constant_loc = NULL;
d2531 1
d2533 1
a2533 5
   this->spilled_any_registers = false;
   this->do_dual_src = false;

   if (dispatch_width == 8)
      this->param_size = rzalloc_array(mem_ctx, int, stage_prog_data->nr_params);
@


1.1.1.5
log
@Import Mesa 10.2.7
@
text
@d1536 1
a1536 1
	    inst = emit(BRW_OPCODE_SEL, chan, chan, fs_reg(0.0f));
d1591 3
a1593 3
   inst->regs_written = 4; /* we only care about one reg of response,
                            * but the sampler always writes 4/8
                            */
d2399 1
a2399 1
   emit(MOV(brw_uvec_mrf(8, mlen, 0), fs_reg(0u)))
d2445 1
a2445 1
   emit(MOV(brw_uvec_mrf(8, mlen, 0), fs_reg(0u)))
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@d39 1
a39 1
#include "util/register_allocate.h"
d63 1
a63 1
	 reg = emit_frontfacing_interpolation();
d80 1
a80 3
         assert(stage == MESA_SHADER_FRAGMENT);
         brw_wm_prog_key *key = (brw_wm_prog_key*) this->key;
	 for (unsigned int i = 0; i < MAX2(key->nr_color_regions, 1); i++) {
d100 2
a101 1
	    this->outputs[output] = offset(*reg, vector_elements * i);
d112 2
a113 2
       * Some uniforms, such as samplers and atomic counters, have no actual
       * storage, so we should ignore them.
d115 1
a115 1
      if (ir->is_in_uniform_block() || type_size(ir->type) == 0)
d137 1
a137 1
	 reg = emit_samplepos_setup();
d139 1
a139 1
	 reg = emit_sampleid_setup();
d141 1
a141 4
         assert(brw->gen >= 7);
         reg = new(mem_ctx)
            fs_reg(retype(brw_vec8_grf(payload.sample_mask_in_reg, 0),
                          BRW_REGISTER_TYPE_D));
a154 6

   if (!reg) {
      fail("Failed to find variable storage for %s\n", ir->var->name);
      this->result = fs_reg(reg_null_d);
      return;
   }
d165 1
a165 1
   unsigned int off = 0;
d169 1
a169 1
      off += type_size(struct_type->fields.structure[i].type);
d171 1
a171 1
   this->result = offset(this->result, off);
d189 2
a190 2
      assert(src.file == UNIFORM || src.file == GRF || src.file == HW_REG);
      src = offset(src, constant_index->value.i[0] * element_size);
d245 1
a245 1
fs_visitor::emit_minmax(enum brw_conditional_mod conditionalmod, const fs_reg &dst,
d261 3
d267 3
a269 1
   if (ir->operation != ir_unop_saturate)
a271 2
   ir_rvalue *sat_val = ir->operands[0];

d279 2
a280 2
   /* If the last instruction from our accept() generated our
    * src, just set the saturate flag instead of emmitting a separate mov.
d283 5
a287 2
   if (modify && modify->regs_written == modify->dst.width / 8 &&
       modify->can_do_saturate()) {
a289 1
      return true;
d292 2
a293 1
   return false;
a337 129
static int
pack_pixel_offset(float x)
{
   /* Clamp upper end of the range to +7/16. See explanation in non-constant
    * offset case below. */
   int n = MIN2((int)(x * 16), 7);
   return n & 0xf;
}

void
fs_visitor::emit_interpolate_expression(ir_expression *ir)
{
   /* in SIMD16 mode, the pixel interpolator returns coords interleaved
    * 8 channels at a time, same as the barycentric coords presented in
    * the FS payload. this requires a bit of extra work to support.
    */
   no16("interpolate_at_* not yet supported in SIMD16 mode.");

   assert(stage == MESA_SHADER_FRAGMENT);
   brw_wm_prog_key *key = (brw_wm_prog_key*) this->key;

   ir_dereference * deref = ir->operands[0]->as_dereference();
   ir_swizzle * swiz = NULL;
   if (!deref) {
      /* the api does not allow a swizzle here, but the varying packing code
       * may have pushed one into here.
       */
      swiz = ir->operands[0]->as_swizzle();
      assert(swiz);
      deref = swiz->val->as_dereference();
   }
   assert(deref);
   ir_variable * var = deref->variable_referenced();
   assert(var);

   /* 1. collect interpolation factors */

   fs_reg dst_x = fs_reg(this, glsl_type::get_instance(ir->type->base_type, 2, 1));
   fs_reg dst_y = offset(dst_x, 1);

   /* for most messages, we need one reg of ignored data; the hardware requires mlen==1
    * even when there is no payload. in the per-slot offset case, we'll replace this with
    * the proper source data. */
   fs_reg src = fs_reg(this, glsl_type::float_type);
   int mlen = 1;     /* one reg unless overriden */
   int reg_width = dispatch_width / 8;
   fs_inst *inst;

   switch (ir->operation) {
   case ir_unop_interpolate_at_centroid:
      inst = emit(FS_OPCODE_INTERPOLATE_AT_CENTROID, dst_x, src, fs_reg(0u));
      break;

   case ir_binop_interpolate_at_sample: {
      ir_constant *sample_num = ir->operands[1]->as_constant();
      assert(sample_num || !"nonconstant sample number should have been lowered.");

      unsigned msg_data = sample_num->value.i[0] << 4;
      inst = emit(FS_OPCODE_INTERPOLATE_AT_SAMPLE, dst_x, src, fs_reg(msg_data));
      break;
   }

   case ir_binop_interpolate_at_offset: {
      ir_constant *const_offset = ir->operands[1]->as_constant();
      if (const_offset) {
         unsigned msg_data = pack_pixel_offset(const_offset->value.f[0]) |
                            (pack_pixel_offset(const_offset->value.f[1]) << 4);
         inst = emit(FS_OPCODE_INTERPOLATE_AT_SHARED_OFFSET, dst_x, src,
                     fs_reg(msg_data));
      } else {
         /* pack the operands: hw wants offsets as 4 bit signed ints */
         ir->operands[1]->accept(this);
         src = fs_reg(this, glsl_type::ivec2_type);
         fs_reg src2 = src;
         for (int i = 0; i < 2; i++) {
            fs_reg temp = fs_reg(this, glsl_type::float_type);
            emit(MUL(temp, this->result, fs_reg(16.0f)));
            emit(MOV(src2, temp));  /* float to int */

            /* Clamp the upper end of the range to +7/16. ARB_gpu_shader5 requires
             * that we support a maximum offset of +0.5, which isn't representable
             * in a S0.4 value -- if we didn't clamp it, we'd end up with -8/16,
             * which is the opposite of what the shader author wanted.
             *
             * This is legal due to ARB_gpu_shader5's quantization rules:
             *
             * "Not all values of <offset> may be supported; x and y offsets may
             * be rounded to fixed-point values with the number of fraction bits
             * given by the implementation-dependent constant
             * FRAGMENT_INTERPOLATION_OFFSET_BITS"
             */

            fs_inst *inst = emit(BRW_OPCODE_SEL, src2, src2, fs_reg(7));
            inst->conditional_mod = BRW_CONDITIONAL_L; /* min(src2, 7) */

            src2 = offset(src2, 1);
            this->result = offset(this->result, 1);
         }

         mlen = 2 * reg_width;
         inst = emit(FS_OPCODE_INTERPOLATE_AT_PER_SLOT_OFFSET, dst_x, src,
                     fs_reg(0u));
      }
      break;
   }

   default:
      unreachable("not reached");
   }

   inst->mlen = mlen;
   inst->regs_written = 2 * reg_width; /* 2 floats per slot returned */
   inst->pi_noperspective = var->determine_interpolation_mode(key->flat_shade) ==
         INTERP_QUALIFIER_NOPERSPECTIVE;

   /* 2. emit linterp */

   fs_reg res(this, ir->type);
   this->result = res;

   for (int i = 0; i < ir->type->vector_elements; i++) {
      int ch = swiz ? ((*(int *)&swiz->mask) >> 2*i) & 3 : i;
      emit(FS_OPCODE_LINTERP, res,
           dst_x, dst_y,
           fs_reg(interp_reg(var->data.location, ch)));
      res = offset(res, 1);
   }
}

d349 1
a349 4

   /* Deal with the real oddball stuff first */
   switch (ir->operation) {
   case ir_binop_add:
d351 1
a351 24
         return;
      break;

   case ir_triop_csel:
      ir->operands[1]->accept(this);
      op[1] = this->result;
      ir->operands[2]->accept(this);
      op[2] = this->result;

      emit_bool_to_cond_code(ir->operands[0]);

      this->result = fs_reg(this, ir->type);
      inst = emit(SEL(this->result, op[1], op[2]));
      inst->predicate = BRW_PREDICATE_NORMAL;
      return;

   case ir_unop_interpolate_at_centroid:
   case ir_binop_interpolate_at_offset:
   case ir_binop_interpolate_at_sample:
      emit_interpolate_expression(ir);
      return;

   default:
      break;
d380 4
a383 5
      if (ctx->Const.UniformBooleanTrue != 1) {
         emit(NOT(this->result, op[0]));
      } else {
         emit(XOR(this->result, op[0], fs_reg(1u)));
      }
d436 2
a437 1
      unreachable("not reached: should be handled by ir_explog_to_explog2");
d448 1
a448 7
      emit(FS_OPCODE_DDX, this->result, op[0], fs_reg(BRW_DERIVATIVE_BY_HINT));
      break;
   case ir_unop_dFdx_coarse:
      emit(FS_OPCODE_DDX, this->result, op[0], fs_reg(BRW_DERIVATIVE_COARSE));
      break;
   case ir_unop_dFdx_fine:
      emit(FS_OPCODE_DDX, this->result, op[0], fs_reg(BRW_DERIVATIVE_FINE));
d451 1
a451 7
      emit(FS_OPCODE_DDY, this->result, op[0], fs_reg(BRW_DERIVATIVE_BY_HINT));
      break;
   case ir_unop_dFdy_coarse:
      emit(FS_OPCODE_DDY, this->result, op[0], fs_reg(BRW_DERIVATIVE_COARSE));
      break;
   case ir_unop_dFdy_fine:
      emit(FS_OPCODE_DDY, this->result, op[0], fs_reg(BRW_DERIVATIVE_FINE));
d458 2
a459 1
      unreachable("not reached: should be handled by ir_sub_to_add_neg");
d482 1
a482 2
            struct brw_reg acc = retype(brw_acc_reg(dispatch_width),
                                        this->result.type);
d493 1
a493 1
      if (brw->gen == 7)
d496 1
a496 2
      struct brw_reg acc = retype(brw_acc_reg(dispatch_width),
                                  this->result.type);
d498 1
a498 1
      fs_inst *mul = emit(MUL(acc, op[0], op[1]));
a499 21

      /* Until Gen8, integer multiplies read 32-bits from one source, and
       * 16-bits from the other, and relying on the MACH instruction to
       * generate the high bits of the result.
       *
       * On Gen8, the multiply instruction does a full 32x32-bit multiply,
       * but in order to do a 64x64-bit multiply we have to simulate the
       * previous behavior and then use a MACH instruction.
       *
       * FINISHME: Don't use source modifiers on src1.
       */
      if (brw->gen >= 8) {
         assert(mul->src[1].type == BRW_REGISTER_TYPE_D ||
                mul->src[1].type == BRW_REGISTER_TYPE_UD);
         if (mul->src[1].type == BRW_REGISTER_TYPE_D) {
            mul->src[1].type = BRW_REGISTER_TYPE_W;
         } else {
            mul->src[1].type = BRW_REGISTER_TYPE_UW;
         }
      }

d508 1
a508 1
      if (brw->gen == 7)
d511 1
a511 2
      struct brw_reg acc = retype(brw_acc_reg(dispatch_width),
                                  BRW_REGISTER_TYPE_UD);
d518 1
a518 1
      if (brw->gen == 7)
d521 1
a521 2
      struct brw_reg acc = retype(brw_acc_reg(dispatch_width),
                                  BRW_REGISTER_TYPE_UD);
d541 2
a542 4
      if (ctx->Const.UniformBooleanTrue == 1) {
         resolve_bool_comparison(ir->operands[0], &op[0]);
         resolve_bool_comparison(ir->operands[1], &op[1]);
      }
d562 2
a563 1
      unreachable("not reached: should be handled by brw_fs_channel_expressions");
d566 2
a567 1
      unreachable("not reached: should be handled by lower_noise");
d570 2
a571 1
      unreachable("not reached: should be handled by lower_quadop_vector");
d574 2
a575 1
      unreachable("not reached: should be handled by lower_vec_index_to_cond_assign()");
d578 2
a579 1
      unreachable("not reached: should be handled by lower_vector_insert()");
d582 2
a583 1
      unreachable("not reached: should be handled by ldexp_to_arith()");
d619 3
a621 10
      if (ctx->Const.UniformBooleanTrue != 1) {
         op[0].type = BRW_REGISTER_TYPE_UD;
         this->result.type = BRW_REGISTER_TYPE_UD;
         emit(AND(this->result, op[0], fs_reg(0x3f800000u)));
         this->result.type = BRW_REGISTER_TYPE_F;
      } else {
         temp = fs_reg(this, glsl_type::int_type);
         emit(AND(temp, op[0], fs_reg(1u)));
         emit(MOV(this->result, temp));
      }
d667 2
a668 1
      unreachable("not reached: should be handled by lower_packing_builtins");
a704 4
   case ir_unop_saturate:
      inst = emit(MOV(this->result, op[0]));
      inst->saturate = true;
      break;
d718 1
a718 1
      unreachable("not reached: should be handled by "
d720 1
d752 1
a752 1
      ir_constant *const_uniform_block = ir->operands[0]->as_constant();
d754 2
a755 26
      fs_reg surf_index;

      if (const_uniform_block) {
         /* The block index is a constant, so just emit the binding table entry
          * as an immediate.
          */
         surf_index = fs_reg(stage_prog_data->binding_table.ubo_start +
                                 const_uniform_block->value.u[0]);
      } else {
         /* The block index is not a constant. Evaluate the index expression
          * per-channel and add the base UBO index; the generator will select
          * a value from any live channel.
          */
         surf_index = fs_reg(this, glsl_type::uint_type);
         emit(ADD(surf_index, op[0],
                  fs_reg(stage_prog_data->binding_table.ubo_start)))
            ->force_writemask_all = true;

         /* Assume this may touch any UBO. It would be nice to provide
          * a tighter bound, but the array information is already lowered away.
          */
         brw_mark_surface_used(prog_data,
                               stage_prog_data->binding_table.ubo_start +
                               shader_prog->NumUniformBlocks - 1);
      }

d761 1
a761 1
         emit(new(mem_ctx) fs_inst(FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD, 8,
d781 1
a781 1
            result = offset(result, 1);
d795 1
a795 1
            result = offset(result, 1);
d815 3
a817 4
   case ir_unop_interpolate_at_centroid:
   case ir_binop_interpolate_at_offset:
   case ir_binop_interpolate_at_sample:
      unreachable("already handled above");
d840 2
a841 2
	 l = offset(l, 1);
	 r = offset(r, 1);
d865 2
a866 1
      unreachable("not reached");
d943 1
a943 1
	    r = offset(r, 1);
d945 1
a945 1
	 l = offset(l, 1);
d953 2
a954 5
fs_visitor::emit_texture_gen4(ir_texture_opcode op, fs_reg dst,
                              fs_reg coordinate, int coord_components,
                              fs_reg shadow_c,
                              fs_reg lod, fs_reg dPdy, int grad_components,
                              uint32_t sampler)
d964 2
a965 2
   if (shadow_c.file != BAD_FILE) {
      for (int i = 0; i < coord_components; i++) {
d967 1
a967 1
	 coordinate = offset(coordinate, 1);
d973 1
a973 1
      for (int i = coord_components; i < 3; i++) {
d978 1
a978 1
      if (op == ir_tex) {
d984 1
a984 1
      } else if (op == ir_txb || op == ir_txl) {
d988 1
a988 1
         unreachable("Should not get here.");
d993 2
a994 2
   } else if (op == ir_tex) {
      for (int i = 0; i < coord_components; i++) {
d996 1
a996 1
	 coordinate = offset(coordinate, 1);
d999 1
a999 1
      for (int i = coord_components; i<3; i++) {
d1004 1
a1004 1
   } else if (op == ir_txd) {
d1007 1
a1007 1
      for (int i = 0; i < coord_components; i++) {
d1009 1
a1009 1
	 coordinate = offset(coordinate, 1);
d1012 1
a1012 1
      mlen += MAX2(coord_components, 2);
d1028 1
a1028 1
      for (int i = 0; i < grad_components; i++) {
d1030 1
a1030 1
	 dPdx = offset(dPdx, 1);
d1032 1
a1032 1
      mlen += MAX2(grad_components, 2);
d1034 1
a1034 1
      for (int i = 0; i < grad_components; i++) {
d1036 1
a1036 1
	 dPdy = offset(dPdy, 1);
d1038 2
a1039 2
      mlen += MAX2(grad_components, 2);
   } else if (op == ir_txs) {
d1049 1
a1049 1
      assert(op == ir_txb || op == ir_txl || op == ir_txf);
d1051 1
a1051 1
      for (int i = 0; i < coord_components; i++) {
d1054 1
a1054 1
	 coordinate = offset(coordinate, 1);
d1060 1
a1060 1
      for (int i = coord_components; i < 3; i++) {
d1080 4
a1083 1
      dst = fs_reg(GRF, virtual_grf_alloc(8), orig_dst.type);
d1086 20
a1105 8
   enum opcode opcode;
   switch (op) {
   case ir_tex: opcode = SHADER_OPCODE_TEX; break;
   case ir_txb: opcode = FS_OPCODE_TXB; break;
   case ir_txl: opcode = SHADER_OPCODE_TXL; break;
   case ir_txd: opcode = SHADER_OPCODE_TXD; break;
   case ir_txs: opcode = SHADER_OPCODE_TXS; break;
   case ir_txf: opcode = SHADER_OPCODE_TXF; break;
d1107 1
a1107 1
      unreachable("not reached");
a1108 2

   fs_inst *inst = emit(opcode, dst, reg_undef, fs_reg(sampler));
d1117 2
a1118 2
	 orig_dst = offset(orig_dst, 1);
	 dst = offset(dst, 2);
d1134 3
a1136 6
fs_visitor::emit_texture_gen5(ir_texture_opcode op, fs_reg dst,
                              fs_reg coordinate, int vector_elements,
                              fs_reg shadow_c,
                              fs_reg lod, fs_reg lod2, int grad_components,
                              fs_reg sample_index, uint32_t sampler,
                              bool has_offset)
d1138 2
d1142 2
d1145 1
a1145 4
   fs_reg message(MRF, 2, BRW_REGISTER_TYPE_F, dispatch_width);
   fs_reg msg_coords = message;

   if (has_offset) {
d1150 2
a1151 1
      message.reg--;
d1155 3
a1157 2
      emit(MOV(retype(offset(msg_coords, i), coordinate.type), coordinate));
      coordinate = offset(coordinate, 1);
d1159 1
a1159 2
   fs_reg msg_end = offset(msg_coords, vector_elements);
   fs_reg msg_lod = offset(msg_coords, 4);
d1161 5
a1165 5
   if (shadow_c.file != BAD_FILE) {
      fs_reg msg_shadow = msg_lod;
      emit(MOV(msg_shadow, shadow_c));
      msg_lod = offset(msg_shadow, 1);
      msg_end = msg_lod;
d1168 2
a1169 2
   enum opcode opcode;
   switch (op) {
d1171 1
a1171 1
      opcode = SHADER_OPCODE_TEX;
d1174 3
a1176 2
      emit(MOV(msg_lod, lod));
      msg_end = offset(msg_lod, 1);
d1178 1
a1178 1
      opcode = FS_OPCODE_TXB;
d1181 3
a1183 2
      emit(MOV(msg_lod, lod));
      msg_end = offset(msg_lod, 1);
d1185 1
a1185 1
      opcode = SHADER_OPCODE_TXL;
d1188 2
d1199 8
a1206 9
      msg_end = msg_lod;
      for (int i = 0; i < grad_components; i++) {
         emit(MOV(msg_end, lod));
         lod = offset(lod, 1);
         msg_end = offset(msg_end, 1);

         emit(MOV(msg_end, lod2));
         lod2 = offset(lod2, 1);
         msg_end = offset(msg_end, 1);
d1209 1
a1209 1
      opcode = SHADER_OPCODE_TXD;
d1213 3
a1215 5
      msg_lod = retype(msg_end, BRW_REGISTER_TYPE_UD);
      emit(MOV(msg_lod, lod));
      msg_end = offset(msg_lod, 1);

      opcode = SHADER_OPCODE_TXS;
d1218 3
a1220 5
      msg_lod = msg_end;
      emit(MOV(retype(msg_lod, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
      msg_end = offset(msg_lod, 1);

      opcode = SHADER_OPCODE_TXS;
d1223 3
a1225 5
      msg_lod = offset(msg_coords, 3);
      emit(MOV(retype(msg_lod, BRW_REGISTER_TYPE_UD), lod));
      msg_end = offset(msg_lod, 1);

      opcode = SHADER_OPCODE_TXF;
d1228 2
a1229 1
      msg_lod = offset(msg_coords, 3);
d1231 1
a1231 1
      emit(MOV(retype(msg_lod, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
d1233 3
a1235 4
      emit(MOV(retype(offset(msg_lod, 1), BRW_REGISTER_TYPE_UD), sample_index));
      msg_end = offset(msg_lod, 2);

      opcode = SHADER_OPCODE_TXF_CMS;
d1238 1
a1238 1
      opcode = SHADER_OPCODE_LOD;
d1241 1
a1241 1
      opcode = SHADER_OPCODE_TG4;
d1244 2
a1245 1
      unreachable("not reached");
d1247 2
a1248 4

   fs_inst *inst = emit(opcode, dst, reg_undef, fs_reg(sampler));
   inst->base_mrf = message.reg;
   inst->mlen = msg_end.reg - message.reg;
d1250 1
a1250 1
   inst->regs_written = 4 * reg_width;
d1252 1
a1252 1
   if (inst->mlen > MAX_SAMPLER_MESSAGE_SIZE) {
a1259 9
static bool
is_high_sampler(struct brw_context *brw, fs_reg sampler)
{
   if (brw->gen < 8 && !brw->is_haswell)
      return false;

   return sampler.file != IMM || sampler.fixed_hw_reg.dw1.ud >= 16;
}

d1261 3
a1263 6
fs_visitor::emit_texture_gen7(ir_texture_opcode op, fs_reg dst,
                              fs_reg coordinate, int coord_components,
                              fs_reg shadow_c,
                              fs_reg lod, fs_reg lod2, int grad_components,
                              fs_reg sample_index, fs_reg mcs, fs_reg sampler,
                              fs_reg offset_value)
d1268 2
a1269 5
   fs_reg *sources = ralloc_array(mem_ctx, fs_reg, MAX_SAMPLER_MESSAGE_SIZE);
   for (int i = 0; i < MAX_SAMPLER_MESSAGE_SIZE; i++) {
      sources[i] = fs_reg(this, glsl_type::float_type);
   }
   int length = 0;
d1271 1
a1271 2
   if (op == ir_tg4 || offset_value.file != BAD_FILE ||
       is_high_sampler(brw, sampler)) {
d1283 1
a1283 2
      sources[0] = fs_reg(GRF, virtual_grf_alloc(1), BRW_REGISTER_TYPE_UD);
      length++;
d1286 3
a1288 3
   if (shadow_c.file != BAD_FILE) {
      emit(MOV(sources[length], shadow_c));
      length++;
d1291 1
a1291 2
   bool has_nonconstant_offset =
      offset_value.file != BAD_FILE && offset_value.file != IMM;
d1295 1
a1295 1
   switch (op) {
d1300 2
a1301 2
      emit(MOV(sources[length], lod));
      length++;
d1304 2
a1305 2
      emit(MOV(sources[length], lod));
      length++;
d1313 4
a1316 4
      for (int i = 0; i < coord_components; i++) {
	 emit(MOV(sources[length], coordinate));
	 coordinate = offset(coordinate, 1);
	 length++;
d1321 8
a1328 8
         if (i < grad_components) {
            emit(MOV(sources[length], lod));
            lod = offset(lod, 1);
            length++;

            emit(MOV(sources[length], lod2));
            lod2 = offset(lod2, 1);
            length++;
d1336 2
a1337 2
      emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_UD), lod));
      length++;
d1340 2
a1341 2
      emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_UD), fs_reg(0u)));
      length++;
d1345 11
a1355 11
      emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_D), coordinate));
      coordinate = offset(coordinate, 1);
      length++;

      emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_D), lod));
      length++;

      for (int i = 1; i < coord_components; i++) {
	 emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_D), coordinate));
	 coordinate = offset(coordinate, 1);
	 length++;
d1361 2
a1362 2
      emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_UD), sample_index));
      length++;
d1365 2
a1366 2
      emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_UD), mcs));
      length++;
d1371 4
a1374 4
      for (int i = 0; i < coord_components; i++) {
         emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_D), coordinate));
         coordinate = offset(coordinate, 1);
         length++;
d1381 1
a1381 1
         if (shadow_c.file != BAD_FILE)
d1385 3
d1389 3
a1391 3
            emit(MOV(sources[length], coordinate));
            coordinate = offset(coordinate, 1);
            length++;
d1395 3
a1397 3
            emit(MOV(retype(sources[length], BRW_REGISTER_TYPE_D), offset_value));
            offset_value = offset(offset_value, 1);
            length++;
d1400 4
a1403 4
         if (coord_components == 3) { /* r if present */
            emit(MOV(sources[length], coordinate));
            coordinate = offset(coordinate, 1);
            length++;
d1412 5
a1416 5
   if (!coordinate_done) {
      for (int i = 0; i < coord_components; i++) {
         emit(MOV(sources[length], coordinate));
         coordinate = offset(coordinate, 1);
         length++;
a1419 10
   int mlen;
   if (reg_width == 2)
      mlen = length * reg_width - header_present;
   else
      mlen = length * reg_width;

   fs_reg src_payload = fs_reg(GRF, virtual_grf_alloc(mlen),
                               BRW_REGISTER_TYPE_F);
   emit(LOAD_PAYLOAD(src_payload, sources, length));

d1421 11
a1431 11
   enum opcode opcode;
   switch (op) {
   case ir_tex: opcode = SHADER_OPCODE_TEX; break;
   case ir_txb: opcode = FS_OPCODE_TXB; break;
   case ir_txl: opcode = SHADER_OPCODE_TXL; break;
   case ir_txd: opcode = SHADER_OPCODE_TXD; break;
   case ir_txf: opcode = SHADER_OPCODE_TXF; break;
   case ir_txf_ms: opcode = SHADER_OPCODE_TXF_CMS; break;
   case ir_txs: opcode = SHADER_OPCODE_TXS; break;
   case ir_query_levels: opcode = SHADER_OPCODE_TXS; break;
   case ir_lod: opcode = SHADER_OPCODE_LOD; break;
d1434 1
a1434 1
         opcode = SHADER_OPCODE_TG4_OFFSET;
d1436 1
a1436 1
         opcode = SHADER_OPCODE_TG4;
a1437 2
   default:
      unreachable("not reached");
a1438 1
   fs_inst *inst = emit(opcode, dst, src_payload, sampler);
d1440 4
a1443 1
   inst->mlen = mlen;
d1445 1
a1445 1
   inst->regs_written = 4 * reg_width;
d1447 1
d1457 2
a1458 2
fs_visitor::rescale_texcoord(fs_reg coordinate, const glsl_type *coord_type,
                             bool is_rect, uint32_t sampler, int texunit)
a1462 4
   const struct brw_sampler_prog_key_data *tex =
      (stage == MESA_SHADER_FRAGMENT) ?
      &((brw_wm_prog_key*) this->key)->tex : NULL;
   assert(tex);
d1470 2
a1471 2
        (brw->gen >= 6 && (tex->gl_clamp_mask[0] & (1 << sampler) ||
                           tex->gl_clamp_mask[1] & (1 << sampler))))) {
d1491 1
a1491 1
             &prog->Parameters->ParameterValues[index][0]) {
d1504 1
a1504 1
            &prog->Parameters->ParameterValues[index][0];
d1506 1
a1506 1
            &prog->Parameters->ParameterValues[index][1];
d1515 1
a1515 1
      fs_reg dst = fs_reg(this, coord_type);
d1520 2
a1521 2
      dst = offset(dst, 1);
      src = offset(src, 1);
d1532 1
a1532 1
	 if (tex->gl_clamp_mask[i] & (1 << sampler)) {
d1534 1
a1534 1
	    chan = offset(chan, i);
d1555 4
a1558 3
   if (coord_type && needs_gl_clamp) {
      for (unsigned int i = 0; i < MIN2(coord_type->vector_elements, 3); i++) {
	 if (tex->gl_clamp_mask[i] & (1 << sampler)) {
d1560 1
a1560 1
	    chan = offset(chan, i);
d1572 1
a1572 1
fs_visitor::emit_mcs_fetch(fs_reg coordinate, int components, fs_reg sampler)
d1575 1
a1575 2
   fs_reg payload = fs_reg(GRF, virtual_grf_alloc(components * reg_width),
                           BRW_REGISTER_TYPE_F);
d1577 1
a1577 1
   fs_reg *sources = ralloc_array(mem_ctx, fs_reg, components);
d1579 5
a1583 5
   /* parameters are: u, v, r; missing parameters are treated as zero */
   for (int i = 0; i < components; i++) {
      sources[i] = fs_reg(this, glsl_type::float_type);
      emit(MOV(retype(sources[i], BRW_REGISTER_TYPE_D), coordinate));
      coordinate = offset(coordinate, 1);
d1586 2
a1587 3
   emit(LOAD_PAYLOAD(payload, sources, components));

   fs_inst *inst = emit(SHADER_OPCODE_TXF_MCS, dest, payload, sampler);
d1589 1
a1589 1
   inst->mlen = components * reg_width;
d1591 4
a1594 4
   inst->regs_written = 4 * reg_width; /* we only care about one reg of
                                        * response, but the sampler always
                                        * writes 4/8
                                        */
d1600 2
a1601 18
fs_visitor::emit_texture(ir_texture_opcode op,
                         const glsl_type *dest_type,
                         fs_reg coordinate, const struct glsl_type *coord_type,
                         fs_reg shadow_c,
                         fs_reg lod, fs_reg lod2, int grad_components,
                         fs_reg sample_index,
                         fs_reg offset_value, unsigned offset_components,
                         fs_reg mcs,
                         int gather_component,
                         bool is_cube_array,
                         bool is_rect,
                         uint32_t sampler,
                         fs_reg sampler_reg, int texunit)
{
   const struct brw_sampler_prog_key_data *tex =
      (stage == MESA_SHADER_FRAGMENT) ?
      &((brw_wm_prog_key*) this->key)->tex : NULL;
   assert(tex);
d1604 9
a1612 1
   if (op == ir_tg4) {
d1616 2
a1617 1
      int swiz = GET_SWZ(tex->swizzles[sampler], gather_component);
d1625 1
a1625 1
            res = offset(res, 1);
a1630 118
   if (coordinate.file != BAD_FILE) {
      /* FINISHME: Texture coordinate rescaling doesn't work with non-constant
       * samplers.  This should only be a problem with GL_CLAMP on Gen7.
       */
      coordinate = rescale_texcoord(coordinate, coord_type, is_rect,
                                    sampler, texunit);
   }

   /* Writemasking doesn't eliminate channels on SIMD8 texture
    * samples, so don't worry about them.
    */
   fs_reg dst(this, glsl_type::get_instance(dest_type->base_type, 4, 1));

   int coord_components = coord_type ? coord_type->vector_elements : 0;

   if (brw->gen >= 7) {
      inst = emit_texture_gen7(op, dst, coordinate, coord_components,
                               shadow_c, lod, lod2, grad_components,
                               sample_index, mcs, sampler_reg,
                               offset_value);
   } else if (brw->gen >= 5) {
      inst = emit_texture_gen5(op, dst, coordinate, coord_components,
                               shadow_c, lod, lod2, grad_components,
                               sample_index, sampler,
                               offset_value.file != BAD_FILE);
   } else {
      inst = emit_texture_gen4(op, dst, coordinate, coord_components,
                               shadow_c, lod, lod2, grad_components,
                               sampler);
   }

   if (shadow_c.file != BAD_FILE)
      inst->shadow_compare = true;

   if (offset_value.file == IMM)
      inst->texture_offset = offset_value.fixed_hw_reg.dw1.ud;

   if (op == ir_tg4) {
      inst->texture_offset |=
         gather_channel(gather_component, sampler) << 16; /* M0.2:16-17 */

      if (brw->gen == 6)
         emit_gen6_gather_wa(tex->gen6_gather_wa[sampler], dst);
   }

   /* fixup #layers for cube map arrays */
   if (op == ir_txs && is_cube_array) {
      fs_reg depth = offset(dst, 2);
      fs_reg fixed_depth = fs_reg(this, glsl_type::int_type);
      emit_math(SHADER_OPCODE_INT_QUOTIENT, fixed_depth, depth, fs_reg(6));

      fs_reg *fixed_payload = ralloc_array(mem_ctx, fs_reg, inst->regs_written);
      int components = inst->regs_written / (dst.width / 8);
      for (int i = 0; i < components; i++) {
         if (i == 2) {
            fixed_payload[i] = fixed_depth;
         } else {
            fixed_payload[i] = offset(dst, i);
         }
      }
      emit(LOAD_PAYLOAD(dst, fixed_payload, components));
   }

   swizzle_result(op, dest_type->vector_elements, dst, sampler);
}

void
fs_visitor::visit(ir_texture *ir)
{
   const struct brw_sampler_prog_key_data *tex =
      (stage == MESA_SHADER_FRAGMENT) ?
      &((brw_wm_prog_key*) this->key)->tex : NULL;
   assert(tex);

   uint32_t sampler =
      _mesa_get_sampler_uniform_value(ir->sampler, shader_prog, prog);

   ir_rvalue *nonconst_sampler_index =
      _mesa_get_sampler_array_nonconst_index(ir->sampler);

   /* Handle non-constant sampler array indexing */
   fs_reg sampler_reg;
   if (nonconst_sampler_index) {
      /* The highest sampler which may be used by this operation is
       * the last element of the array. Mark it here, because the generator
       * doesn't have enough information to determine the bound.
       */
      uint32_t array_size = ir->sampler->as_dereference_array()
         ->array->type->array_size();

      uint32_t max_used = sampler + array_size - 1;
      if (ir->op == ir_tg4 && brw->gen < 8) {
         max_used += stage_prog_data->binding_table.gather_texture_start;
      } else {
         max_used += stage_prog_data->binding_table.texture_start;
      }

      brw_mark_surface_used(prog_data, max_used);

      /* Emit code to evaluate the actual indexing expression */
      nonconst_sampler_index->accept(this);
      fs_reg temp(this, glsl_type::uint_type);
      emit(ADD(temp, this->result, fs_reg(sampler)))
            ->force_writemask_all = true;
      sampler_reg = temp;
   } else {
      /* Single sampler, or constant array index; the indexing expression
       * is just an immediate.
       */
      sampler_reg = fs_reg(sampler);
   }

   /* FINISHME: We're failing to recompile our programs when the sampler is
    * updated.  This only matters for the texture rectangle scale parameters
    * (pre-gen6, or gen6+ with GL_CLAMP).
    */
   int texunit = prog->SamplerUnits[sampler];

a1641 1
   const glsl_type *coord_type = NULL;
a1642 1
      coord_type = ir->coordinate->type;
d1644 5
a1648 1
      coordinate = this->result;
a1656 19
   fs_reg offset_value;
   int offset_components = 0;
   if (ir->offset) {
      ir_constant *const_offset = ir->offset->as_constant();
      if (const_offset) {
         /* Store the header bitfield in an IMM register.  This allows us to
          * use offset_value.file to distinguish between no offset, a constant
          * offset, and a non-constant offset.
          */
         offset_value =
            fs_reg(brw_texture_offset(ctx, const_offset->value.i,
                                      const_offset->type->vector_elements));
      } else {
         ir->offset->accept(this);
         offset_value = this->result;
      }
      offset_components = ir->offset->type->vector_elements;
   }

a1657 1
   int grad_components = 0;
a1673 2

      grad_components = ir->lod_info.grad.dPdx->type->vector_elements;
d1685 2
a1686 3
      if (brw->gen >= 7 && tex->compressed_multisample_layout_mask & (1<<sampler))
         mcs = emit_mcs_fetch(coordinate, ir->coordinate->type->vector_elements,
                              sampler_reg);
d1691 1
a1691 1
      unreachable("Unrecognized texture opcode");
d1694 19
a1712 1
   int gather_component = 0;
d1714 3
a1716 1
      gather_component = ir->lod_info.component->as_constant()->value.i[0];
d1718 17
a1734 2
   bool is_rect =
      ir->sampler->type->sampler_dimensionality == GLSL_SAMPLER_DIM_RECT;
d1736 1
a1736 8
   bool is_cube_array =
      ir->sampler->type->sampler_dimensionality == GLSL_SAMPLER_DIM_CUBE &&
      ir->sampler->type->sampler_array;

   emit_texture(ir->op, ir->type, coordinate, coord_type, shadow_comparitor,
                lod, lod2, grad_components, sample_index, offset_value,
                offset_components, mcs, gather_component,
                is_cube_array, is_rect, sampler, sampler_reg, texunit);
d1765 1
a1765 1
      dst = offset(dst, 1);
d1773 1
a1773 1
fs_visitor::gather_channel(int orig_chan, uint32_t sampler)
d1775 2
a1776 5
   const struct brw_sampler_prog_key_data *tex =
      (stage == MESA_SHADER_FRAGMENT) ?
      &((brw_wm_prog_key*) this->key)->tex : NULL;
   assert(tex);
   int swiz = GET_SWZ(tex->swizzles[sampler], orig_chan);
d1783 1
a1783 1
         if (tex->gather_channel_quirk_mask & (1<<sampler))
d1789 2
a1790 1
         unreachable("Not reached"); /* zero, one swizzles handled already */
d1799 1
a1799 2
fs_visitor::swizzle_result(ir_texture_opcode op, int dest_components,
                           fs_reg orig_val, uint32_t sampler)
d1801 1
a1801 1
   if (op == ir_query_levels) {
d1803 2
a1804 1
      this->result = offset(orig_val, 3);
d1813 1
a1813 1
   if (op == ir_txs || op == ir_lod || op == ir_tg4)
d1816 1
a1816 6
   const struct brw_sampler_prog_key_data *tex =
      (stage == MESA_SHADER_FRAGMENT) ?
      &((brw_wm_prog_key*) this->key)->tex : NULL;
   assert(tex);

   if (dest_components == 1) {
d1818 2
a1819 1
   } else if (tex->swizzles[sampler] != SWIZZLE_NOOP) {
a1820 1
      swizzled_result.type = orig_val.type;
d1823 1
a1823 1
	 int swiz = GET_SWZ(tex->swizzles[sampler], i);
d1825 1
a1825 1
	 l = offset(l, i);
d1832 3
a1834 2
            emit(MOV(l, offset(orig_val,
                               GET_SWZ(tex->swizzles[sampler], i))));
d1848 1
a1848 1
      this->result = offset(this->result, ir->mask.x);
d1874 3
a1876 2
      emit(MOV(result, offset(channel, swiz)));
      result = offset(result, 1);
d1899 5
a1903 1
       * Only jump if all relevant channels have been discarded.
d1907 1
a1907 4

      discard_jump->predicate = (dispatch_width == 8)
                                ? BRW_PREDICATE_ALIGN1_ANY8H
                                : BRW_PREDICATE_ALIGN1_ANY16H;
d1935 2
a1936 2
	    src_reg = offset(src_reg, 1);
	    dst_reg = offset(dst_reg, 1);
d1940 2
a1941 1
      foreach_in_list(ir_constant, field, &ir->components) {
d1950 2
a1951 2
	    src_reg = offset(src_reg, 1);
	    dst_reg = offset(dst_reg, 1);
d1969 1
a1969 3
            emit(MOV(dst_reg,
                     fs_reg(ir->value.b[i] != 0 ? ctx->Const.UniformBooleanTrue
                                                : 0u)));
d1972 1
a1972 1
	    unreachable("Non-float/uint/int/bool constant");
d1974 1
a1974 1
	 dst_reg = offset(dst_reg, 1);
d1986 6
a1991 2
   if (!expr || expr->operation == ir_binop_ubo_load) {
      ir->accept(this);
d1993 3
a1995 4
      fs_inst *inst = emit(AND(reg_null_d, this->result, fs_reg(1)));
      inst->conditional_mod = BRW_CONDITIONAL_NZ;
      return;
   }
d1997 2
a1998 2
   fs_reg op[3];
   fs_inst *inst;
d2000 2
a2001 3
   assert(expr->get_num_operands() <= 3);
   for (unsigned int i = 0; i < expr->get_num_operands(); i++) {
      assert(expr->operands[i]->type->is_scalar());
d2003 5
a2007 2
      expr->operands[i]->accept(this);
      op[i] = this->result;
d2009 8
a2016 2
      resolve_ud_negate(&op[i]);
   }
d2018 8
a2025 5
   switch (expr->operation) {
   case ir_unop_logic_not:
      inst = emit(AND(reg_null_d, op[0], fs_reg(1)));
      inst->conditional_mod = BRW_CONDITIONAL_Z;
      break;
d2027 10
a2036 11
   case ir_binop_logic_xor:
      if (ctx->Const.UniformBooleanTrue == 1) {
         fs_reg dst = fs_reg(this, glsl_type::uint_type);
         emit(XOR(dst, op[0], op[1]));
         inst = emit(AND(reg_null_d, dst, fs_reg(1u)));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
      } else {
         inst = emit(XOR(reg_null_d, op[0], op[1]));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
      }
      break;
d2038 3
a2040 11
   case ir_binop_logic_or:
      if (ctx->Const.UniformBooleanTrue == 1) {
         fs_reg dst = fs_reg(this, glsl_type::uint_type);
         emit(OR(dst, op[0], op[1]));
         inst = emit(AND(reg_null_d, dst, fs_reg(1u)));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
      } else {
         inst = emit(OR(reg_null_d, op[0], op[1]));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
      }
      break;
d2042 4
a2045 9
   case ir_binop_logic_and:
      if (ctx->Const.UniformBooleanTrue == 1) {
         fs_reg dst = fs_reg(this, glsl_type::uint_type);
         emit(AND(dst, op[0], op[1]));
         inst = emit(AND(reg_null_d, dst, fs_reg(1u)));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
      } else {
         inst = emit(AND(reg_null_d, op[0], op[1]));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
d2047 2
a2048 1
      break;
d2050 1
a2050 8
   case ir_unop_f2b:
      if (brw->gen >= 6) {
         emit(CMP(reg_null_d, op[0], fs_reg(0.0f), BRW_CONDITIONAL_NZ));
      } else {
         inst = emit(MOV(reg_null_f, op[0]));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
      }
      break;
d2052 2
a2053 45
   case ir_unop_i2b:
      if (brw->gen >= 6) {
         emit(CMP(reg_null_d, op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
      } else {
         inst = emit(MOV(reg_null_d, op[0]));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;
      }
      break;

   case ir_binop_greater:
   case ir_binop_gequal:
   case ir_binop_less:
   case ir_binop_lequal:
   case ir_binop_equal:
   case ir_binop_all_equal:
   case ir_binop_nequal:
   case ir_binop_any_nequal:
      if (ctx->Const.UniformBooleanTrue == 1) {
         resolve_bool_comparison(expr->operands[0], &op[0]);
         resolve_bool_comparison(expr->operands[1], &op[1]);
      }

      emit(CMP(reg_null_d, op[0], op[1],
               brw_conditional_for_comparison(expr->operation)));
      break;

   case ir_triop_csel: {
      /* Expand the boolean condition into the flag register. */
      inst = emit(MOV(reg_null_d, op[0]));
      inst->conditional_mod = BRW_CONDITIONAL_NZ;

      /* Select which boolean to return. */
      fs_reg temp(this, expr->operands[1]->type);
      inst = emit(SEL(temp, op[1], op[2]));
      inst->predicate = BRW_PREDICATE_NORMAL;

      /* Expand the result to a condition code. */
      inst = emit(MOV(reg_null_d, temp));
      inst->conditional_mod = BRW_CONDITIONAL_NZ;
      break;
   }

   default:
      unreachable("not reached");
   }
d2065 2
a2066 2
   if (expr && expr->operation != ir_binop_ubo_load) {
      fs_reg op[3];
d2070 1
a2070 1
      assert(expr->get_num_operands() <= 3);
a2079 3
         emit(IF(op[0], fs_reg(0), BRW_CONDITIONAL_Z));
         return;

a2080 3
         emit(IF(op[0], op[1], BRW_CONDITIONAL_NZ));
         return;

a2081 5
         temp = fs_reg(this, glsl_type::bool_type);
         emit(OR(temp, op[0], op[1]));
         emit(IF(temp, fs_reg(0), BRW_CONDITIONAL_NZ));
         return;

d2083 5
a2087 4
         temp = fs_reg(this, glsl_type::bool_type);
         emit(AND(temp, op[0], op[1]));
         emit(IF(temp, fs_reg(0), BRW_CONDITIONAL_NZ));
         return;
d2106 2
a2107 4
         if (ctx->Const.UniformBooleanTrue == 1) {
            resolve_bool_comparison(expr->operands[0], &op[0]);
            resolve_bool_comparison(expr->operands[1], &op[1]);
         }
d2112 4
a2115 12

      case ir_triop_csel: {
         /* Expand the boolean condition into the flag register. */
         fs_inst *inst = emit(MOV(reg_null_d, op[0]));
         inst->conditional_mod = BRW_CONDITIONAL_NZ;

         /* Select which boolean to use as the result. */
         fs_reg temp(this, expr->operands[1]->type);
         inst = emit(SEL(temp, op[1], op[2]));
         inst->predicate = BRW_PREDICATE_NORMAL;

	 emit(IF(temp, fs_reg(0), BRW_CONDITIONAL_NZ));
a2117 4

      default:
	 unreachable("not reached");
      }
d2120 3
a2122 2
   ir->condition->accept(this);
   emit(IF(this->result, fs_reg(0), BRW_CONDITIONAL_NZ));
d2181 2
a2182 2
         if_inst->next->exec_node::remove();
      if_inst->exec_node::remove();
d2230 5
a2234 3
   foreach_in_list(ir_instruction, ir_, &ir->then_instructions) {
      this->base_ir = ir_;
      ir_->accept(this);
d2240 5
a2244 3
      foreach_in_list(ir_instruction, ir_, &ir->else_instructions) {
	 this->base_ir = ir_;
	 ir_->accept(this);
d2263 5
a2267 3
   foreach_in_list(ir_instruction, ir_, &ir->body_instructions) {
      this->base_ir = ir_;
      ir_->accept(this);
d2293 2
a2294 2
   unsigned surf_index = (stage_prog_data->binding_table.abo_start +
                          location->data.binding);
d2304 2
a2305 2
      emit(MUL(tmp, this->result, fs_reg(ATOMIC_COUNTER_SIZE)));
      emit(ADD(offset, tmp, fs_reg(location->data.atomic.offset)));
d2307 1
a2307 1
      offset = fs_reg(location->data.atomic.offset);
d2338 1
a2338 1
      unreachable("Unsupported intrinsic.");
d2343 1
a2343 1
fs_visitor::visit(ir_return *)
d2345 1
a2345 1
   unreachable("FINISHME");
d2358 1
a2358 1
      sig = ir->matching_signature(NULL, &empty, false);
d2362 5
a2366 3
      foreach_in_list(ir_instruction, ir_, &sig->body) {
	 this->base_ir = ir_;
	 ir_->accept(this);
d2372 1
a2372 1
fs_visitor::visit(ir_function_signature *)
d2374 2
a2375 1
   unreachable("not reached");
d2381 1
a2381 1
   unreachable("not reached");
d2387 1
a2387 1
   unreachable("not reached");
d2395 2
a2396 5
   bool uses_kill =
      (stage == MESA_SHADER_FRAGMENT) &&
      ((brw_wm_prog_data*) this->prog_data)->uses_kill;
   int reg_width = dispatch_width / 8;
   int length = 0;
a2397 3
   fs_reg *sources = ralloc_array(mem_ctx, fs_reg, 4);

   sources[0] = fs_reg(GRF, virtual_grf_alloc(1), BRW_REGISTER_TYPE_UD);
d2399 1
a2399 1
   emit(MOV(sources[0], fs_reg(0u)))
d2402 2
a2403 2
   if (uses_kill) {
      emit(MOV(component(sources[0], 7), brw_flag_reg(0, 1)))
d2406 1
a2406 1
      emit(MOV(component(sources[0], 7),
d2410 2
a2411 1
   length++;
d2414 2
a2415 3
   sources[1] = fs_reg(this, glsl_type::uint_type);
   emit(MOV(sources[1], offset));
   length++;
d2419 2
a2420 3
      sources[length] = fs_reg(this, glsl_type::uint_type);
      emit(MOV(sources[length], src0));
      length++;
d2424 2
a2425 3
      sources[length] = fs_reg(this, glsl_type::uint_type);
      emit(MOV(sources[length], src1));
      length++;
a2427 5
   int mlen = 1 + (length - 1) * reg_width;
   fs_reg src_payload = fs_reg(GRF, virtual_grf_alloc(mlen),
                               BRW_REGISTER_TYPE_UD);
   emit(LOAD_PAYLOAD(src_payload, sources, length));

d2429 3
a2431 2
   fs_inst *inst = emit(SHADER_OPCODE_UNTYPED_ATOMIC, dst, src_payload,
                        fs_reg(atomic_op), fs_reg(surf_index));
d2433 2
d2441 2
a2442 4
   bool uses_kill =
      (stage == MESA_SHADER_FRAGMENT) &&
      ((brw_wm_prog_data*) this->prog_data)->uses_kill;
   int reg_width = dispatch_width / 8;
a2443 3
   fs_reg *sources = ralloc_array(mem_ctx, fs_reg, 2);

   sources[0] = fs_reg(GRF, virtual_grf_alloc(1), BRW_REGISTER_TYPE_UD);
d2445 1
a2445 1
   emit(MOV(sources[0], fs_reg(0u)))
d2448 2
a2449 2
   if (uses_kill) {
      emit(MOV(component(sources[0], 7), brw_flag_reg(0, 1)))
d2452 1
a2452 1
      emit(MOV(component(sources[0], 7),
d2457 2
d2460 2
a2461 7
   sources[1] = fs_reg(this, glsl_type::uint_type);
   emit(MOV(sources[1], offset));

   int mlen = 1 + reg_width;
   fs_reg src_payload = fs_reg(GRF, virtual_grf_alloc(mlen),
                               BRW_REGISTER_TYPE_UD);
   fs_inst *inst = emit(LOAD_PAYLOAD(src_payload, sources, 2));
d2464 3
a2466 2
   inst = emit(SHADER_OPCODE_UNTYPED_SURFACE_READ, dst, src_payload,
               fs_reg(surf_index));
d2468 2
d2475 1
a2475 1
   if (dispatch_width == 16 && inst->exec_size == 8)
d2489 3
a2491 2
   foreach_in_list_safe(fs_inst, inst, &list) {
      inst->exec_node::remove();
d2522 1
a2522 3
   assert(stage == MESA_SHADER_FRAGMENT);
   brw_wm_prog_data *prog_data = (brw_wm_prog_data*) this->prog_data;
   int regnr = prog_data->urb_setup[location] * 2 + channel / 2;
d2525 1
a2525 1
   assert(prog_data->urb_setup[location] != -1);
d2548 2
a2549 1
         offset(this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC], 1);
d2605 1
a2605 1
   this->pixel_w = fs_reg(brw_vec8_grf(payload.source_w_reg, 0));
d2610 1
a2610 1
      uint8_t reg = payload.barycentric_coord_reg[i];
d2618 2
a2619 2
int
fs_visitor::setup_color_payload(fs_reg *dst, fs_reg color, unsigned components)
d2621 1
a2621 1
   brw_wm_prog_key *key = (brw_wm_prog_key*) this->key;
d2623 2
d2626 3
a2628 3
   if (color.file == BAD_FILE) {
      return 4 * (dispatch_width / 8);
   }
d2630 1
a2630 8
   uint8_t colors_enabled;
   if (components == 0) {
      /* We want to write one component to the alpha channel */
      colors_enabled = 0x8;
   } else {
      /* Enable the first components-many channels */
      colors_enabled = (1 << components) - 1;
   }
d2649 4
a2652 14
      int len = 0;
      for (unsigned i = 0; i < 4; ++i) {
         if (colors_enabled & (1 << i)) {
            dst[len] = fs_reg(GRF, virtual_grf_alloc(color.width / 8),
                              color.type, color.width);
            inst = emit(MOV(dst[len], offset(color, i)));
            inst->saturate = key->clamp_fragment_color;
         } else if (color.width == 16) {
            /* We need two BAD_FILE slots for a 16-wide color */
            len++;
         }
         len++;
      }
      return len;
d2664 21
a2684 11
      for (unsigned i = 0; i < 4; ++i) {
         if (colors_enabled & (1 << i)) {
            dst[i] = fs_reg(GRF, virtual_grf_alloc(1), color.type);
            inst = emit(MOV(dst[i], half(offset(color, i), 0)));
            inst->saturate = key->clamp_fragment_color;

            dst[i + 4] = fs_reg(GRF, virtual_grf_alloc(1), color.type);
            inst = emit(MOV(dst[i + 4], half(offset(color, i), 1)));
            inst->saturate = key->clamp_fragment_color;
            inst->force_sechalf = true;
         }
a2685 1
      return 8;
d2689 1
a2689 1
static enum brw_conditional_mod
d2706 2
a2707 1
         unreachable("Not reached");
a2717 2
   assert(stage == MESA_SHADER_FRAGMENT);
   brw_wm_prog_key *key = (brw_wm_prog_key*) this->key;
d2721 1
a2721 1
   if (key->alpha_test_func == GL_ALWAYS)
d2724 1
a2724 1
   if (key->alpha_test_func == GL_NEVER) {
d2732 2
a2733 1
      fs_reg color = offset(outputs[0], 3);
d2736 2
a2737 2
      cmp = emit(CMP(reg_null_f, color, fs_reg(key->alpha_test_ref),
                     cond_for_alpha_func(key->alpha_test_func)));
d2743 2
a2744 3
fs_inst *
fs_visitor::emit_single_fb_write(fs_reg color0, fs_reg color1,
                                 fs_reg src0_alpha, unsigned components)
a2745 4
   assert(stage == MESA_SHADER_FRAGMENT);
   brw_wm_prog_data *prog_data = (brw_wm_prog_data*) this->prog_data;
   brw_wm_prog_key *key = (brw_wm_prog_key*) this->key;

a2747 2
   int reg_size = dispatch_width / 8;

d2751 10
a2760 2
   fs_reg *sources = ralloc_array(mem_ctx, fs_reg, 15);
   int length = 0;
d2770 3
a2772 3
       (brw->is_haswell || brw->gen >= 8 || !prog_data->uses_kill) &&
       color1.file == BAD_FILE &&
       key->nr_color_regions == 1) {
d2776 18
a2793 14
   if (header_present)
      /* Allocate 2 registers for a header */
      length += 2;

   if (payload.aa_dest_stencil_reg) {
      sources[length] = fs_reg(GRF, virtual_grf_alloc(1));
      emit(MOV(sources[length],
               fs_reg(brw_vec8_grf(payload.aa_dest_stencil_reg, 0))));
      length++;
   }

   prog_data->uses_omask =
      prog->OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_SAMPLE_MASK);
   if (prog_data->uses_omask) {
d2796 3
a2798 7
      /* Hand over gl_SampleMask. Only lower 16 bits are relevant.  Since
       * it's unsinged single words, one vgrf is always 16-wide.
       */
      sources[length] = fs_reg(GRF, virtual_grf_alloc(1),
                               BRW_REGISTER_TYPE_UW, 16);
      emit(FS_OPCODE_SET_OMASK, sources[length], this->sample_mask);
      length++;
d2801 7
a2807 20
   if (color0.file == BAD_FILE) {
      /* Even if there's no color buffers enabled, we still need to send
       * alpha out the pipeline to our null renderbuffer to support
       * alpha-testing, alpha-to-coverage, and so on.
       */
      length += setup_color_payload(sources + length, this->outputs[0], 0);
   } else if (color1.file == BAD_FILE) {
      if (src0_alpha.file != BAD_FILE) {
         sources[length] = fs_reg(GRF, virtual_grf_alloc(reg_size),
                                  src0_alpha.type, src0_alpha.width);
         fs_inst *inst = emit(MOV(sources[length], src0_alpha));
         inst->saturate = key->clamp_fragment_color;
         length++;
      }

      length += setup_color_payload(sources + length, color0, components);
   } else {
      length += setup_color_payload(sources + length, color0, components);
      length += setup_color_payload(sources + length, color1, components);
   }
d2809 1
a2809 1
   if (source_depth_to_render_target) {
a2818 1
      sources[length] = fs_reg(this, glsl_type::float_type);
d2822 1
a2822 1
	 emit(MOV(sources[length], this->frag_depth));
d2825 2
a2826 2
	 emit(MOV(sources[length],
                  fs_reg(brw_vec8_grf(payload.source_depth_reg, 0))));
d2828 1
a2828 1
      length++;
d2831 4
a2834 5
   if (payload.dest_depth_reg) {
      sources[length] = fs_reg(this, glsl_type::float_type);
      emit(MOV(sources[length],
               fs_reg(brw_vec8_grf(payload.dest_depth_reg, 0))));
      length++;
d2837 3
a2839 17
   fs_inst *load;
   fs_inst *write;
   if (brw->gen >= 7) {
      /* Send from the GRF */
      fs_reg payload = fs_reg(GRF, -1, BRW_REGISTER_TYPE_F);
      load = emit(LOAD_PAYLOAD(payload, sources, length));
      payload.reg = virtual_grf_alloc(load->regs_written);
      load->dst = payload;
      write = emit(FS_OPCODE_FB_WRITE, reg_undef, payload);
      write->base_mrf = -1;
   } else {
      /* Send from the MRF */
      load = emit(LOAD_PAYLOAD(fs_reg(MRF, 1, BRW_REGISTER_TYPE_F),
                               sources, length));
      write = emit(FS_OPCODE_FB_WRITE);
      write->base_mrf = 1;
   }
d2841 7
a2847 8
   write->mlen = load->regs_written;
   write->header_present = header_present;
   if ((brw->gen >= 8 || brw->is_haswell) && prog_data->uses_kill) {
      write->predicate = BRW_PREDICATE_NORMAL;
      write->flag_subreg = 1;
   }
   return write;
}
d2849 8
a2856 12
void
fs_visitor::emit_fb_writes()
{
   assert(stage == MESA_SHADER_FRAGMENT);
   brw_wm_prog_data *prog_data = (brw_wm_prog_data*) this->prog_data;
   brw_wm_prog_key *key = (brw_wm_prog_key*) this->key;

   if (do_dual_src) {
      no16("GL_ARB_blend_func_extended not yet supported in SIMD16.");
      if (dispatch_width == 16)
         do_dual_src = false;
   }
a2857 2
   fs_inst *inst;
   if (do_dual_src) {
d2861 17
d2879 23
a2901 13
						 "FB dual-source write");
      inst = emit_single_fb_write(this->outputs[0], this->dual_src_output,
                                  reg_undef, 4);
      inst->target = 0;
      prog_data->dual_src_blend = true;
   } else if (key->nr_color_regions > 0) {
      for (int target = 0; target < key->nr_color_regions; target++) {
         this->current_annotation = ralloc_asprintf(this->mem_ctx,
                                                    "FB write target %d",
                                                    target);
         fs_reg src0_alpha;
         if (brw->gen >= 6 && key->replicate_alpha && target != 0)
            src0_alpha = offset(outputs[0], 3);
d2903 1
a2903 2
         if (target == key->nr_color_regions - 1 &&
             (INTEL_DEBUG & DEBUG_SHADER_TIME))
d2905 1
d2907 12
a2918 4
         inst = emit_single_fb_write(this->outputs[target], reg_undef,
                                     src0_alpha,
                                     this->output_components[target]);
         inst->target = target;
d2920 1
a2920 3
   } else {
      if (INTEL_DEBUG & DEBUG_SHADER_TIME)
         emit_shader_time_end();
d2922 1
d2927 14
a2940 2
      inst = emit_single_fb_write(reg_undef, reg_undef, reg_undef, 0);
      inst->target = 0;
a2942 1
   inst->eot = true;
a2960 2
   assert(ctx->Const.UniformBooleanTrue == 1);

d2965 1
a2965 1
   emit(AND(temp, *reg, fs_reg(1u)));
d2970 1
a2970 3
                       void *mem_ctx,
                       const struct brw_wm_prog_key *key,
                       struct brw_wm_prog_data *prog_data,
d2974 1
a2974 1
   : backend_visitor(brw, shader_prog, &fp->Base, &prog_data->base,
a2975 4
     reg_null_f(retype(brw_null_vec(dispatch_width), BRW_REGISTER_TYPE_F)),
     reg_null_d(retype(brw_null_vec(dispatch_width), BRW_REGISTER_TYPE_D)),
     reg_null_ud(retype(brw_null_vec(dispatch_width), BRW_REGISTER_TYPE_UD)),
     key(key), prog_data(&prog_data->base),
d2978 3
a2980 7
   this->mem_ctx = mem_ctx;
   init();
}

void
fs_visitor::init()
{
a2987 1
   memset(&this->payload, 0, sizeof(this->payload));
a2989 2
   this->source_depth_to_render_target = false;
   this->runtime_check_aads_emit = false;
a3004 1
   this->last_scratch = 0;
d3008 2
d3019 1
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d39 1
a39 1
#include "program/register_allocate.h"
d63 1
a63 1
	 reg = emit_frontfacing_interpolation(ir);
d80 3
a82 1
	 for (unsigned int i = 0; i < MAX2(c->key.nr_color_regions, 1); i++) {
d102 1
a102 2
	    this->outputs[output] = *reg;
	    this->outputs[output].reg_offset += vector_elements * i;
d113 2
a114 2
       * Atomic counters take no uniform storage, no need to do
       * anything here.
d116 1
a116 1
      if (ir->is_in_uniform_block() || ir->type->contains_atomic())
d138 1
a138 1
	 reg = emit_samplepos_setup(ir);
d140 1
a140 1
	 reg = emit_sampleid_setup(ir);
d142 4
a145 1
         reg = emit_samplemaskin_setup(ir);
d159 6
d175 1
a175 1
   unsigned int offset = 0;
d179 1
a179 1
      offset += type_size(struct_type->fields.structure[i].type);
d181 1
a181 1
   this->result.reg_offset += offset;
d199 2
a200 2
      assert(src.file == UNIFORM || src.file == GRF);
      src.reg_offset += constant_index->value.i[0] * element_size;
d255 1
a255 1
fs_visitor::emit_minmax(uint32_t conditionalmod, const fs_reg &dst,
a270 3
/* Instruction selection: Produce a MOV.sat instead of
 * MIN(MAX(val, 0), 1) when possible.
 */
d274 2
a275 1
   ir_rvalue *sat_val = ir->as_rvalue_to_saturate();
d277 1
a277 2
   if (!sat_val)
      return false;
d286 2
a287 2
   /* If the last instruction from our accept() didn't generate our
    * src, generate a saturated MOV
d290 2
a291 5
   if (!modify || modify->regs_written != 1) {
      this->result = fs_reg(this, ir->type);
      fs_inst *inst = emit(MOV(this->result, src));
      inst->saturate = true;
   } else {
d294 1
d297 1
a297 2

   return true;
d342 129
d482 4
a485 1
   if (ir->operation == ir_binop_add) {
d487 24
a510 1
	 return;
d539 5
a543 4
      /* Note that BRW_OPCODE_NOT is not appropriate here, since it is
       * ones complement of the whole register, not just bit 0.
       */
      emit(XOR(this->result, op[0], fs_reg(1)));
d596 1
a596 2
      assert(!"not reached: should be handled by ir_explog_to_explog2");
      break;
d607 7
a613 1
      emit(FS_OPCODE_DDX, this->result, op[0]);
d616 7
a622 1
      emit(FS_OPCODE_DDY, this->result, op[0]);
d629 1
a629 2
      assert(!"not reached: should be handled by ir_sub_to_add_neg");
      break;
d652 2
a653 1
            struct brw_reg acc = retype(brw_acc_reg(), this->result.type);
d664 1
a664 1
      if (brw->gen >= 7)
d667 2
a668 1
      struct brw_reg acc = retype(brw_acc_reg(), this->result.type);
d670 1
a670 1
      emit(MUL(acc, op[0], op[1]));
d672 21
d701 1
a701 1
      if (brw->gen >= 7)
d704 2
a705 1
      struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_UD);
d712 1
a712 1
      if (brw->gen >= 7)
d715 2
a716 1
      struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_UD);
d736 4
a739 2
      resolve_bool_comparison(ir->operands[0], &op[0]);
      resolve_bool_comparison(ir->operands[1], &op[1]);
d759 1
a759 2
      assert(!"not reached: should be handled by brw_fs_channel_expressions");
      break;
d762 1
a762 2
      assert(!"not reached: should be handled by lower_noise");
      break;
d765 1
a765 2
      assert(!"not reached: should be handled by lower_quadop_vector");
      break;
d768 1
a768 2
      assert(!"not reached: should be handled by lower_vec_index_to_cond_assign()");
      break;
d771 1
a771 2
      assert(!"not reached: should be handled by lower_vector_insert()");
      break;
d774 1
a774 2
      assert(!"not reached: should be handled by ldexp_to_arith()");
      break;
d810 10
a819 3
      temp = fs_reg(this, glsl_type::int_type);
      emit(AND(temp, op[0], fs_reg(1)));
      emit(MOV(this->result, temp));
d865 1
a865 2
      assert(!"not reached: should be handled by lower_packing_builtins");
      break;
d902 4
d919 1
a919 1
      assert(!"not reached: should be handled by "
a920 1
      break;
d952 1
a952 1
      ir_constant *uniform_block = ir->operands[0]->as_constant();
d954 26
a979 2
      fs_reg surf_index = fs_reg(c->prog_data.base.binding_table.ubo_start +
                                 uniform_block->value.u[0]);
d985 1
a985 1
         emit(new(mem_ctx) fs_inst(FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD,
d1005 1
a1005 1
            result.reg_offset++;
d1019 1
a1019 1
            result.reg_offset++;
d1039 4
a1042 3
      emit(CMP(reg_null_d, op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
      inst = emit(BRW_OPCODE_SEL, this->result, op[1], op[2]);
      inst->predicate = BRW_PREDICATE_NORMAL;
d1065 2
a1066 2
	 l.reg_offset++;
	 r.reg_offset++;
d1090 1
a1090 2
      assert(!"not reached");
      break;
d1167 1
a1167 1
	    r.reg_offset++;
d1169 1
a1169 1
	 l.reg_offset++;
d1177 5
a1181 2
fs_visitor::emit_texture_gen4(ir_texture *ir, fs_reg dst, fs_reg coordinate,
			      fs_reg shadow_c, fs_reg lod, fs_reg dPdy)
d1191 2
a1192 2
   if (ir->shadow_comparitor) {
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
d1194 1
a1194 1
	 coordinate.reg_offset++;
d1200 1
a1200 1
      for (int i = ir->coordinate->type->vector_elements; i < 3; i++) {
d1205 1
a1205 1
      if (ir->op == ir_tex) {
d1211 1
a1211 1
      } else if (ir->op == ir_txb || ir->op == ir_txl) {
d1215 1
a1215 1
         assert(!"Should not get here.");
d1220 2
a1221 2
   } else if (ir->op == ir_tex) {
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
d1223 1
a1223 1
	 coordinate.reg_offset++;
d1226 1
a1226 1
      for (int i = ir->coordinate->type->vector_elements; i<3; i++) {
d1231 1
a1231 1
   } else if (ir->op == ir_txd) {
d1234 1
a1234 1
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
d1236 1
a1236 1
	 coordinate.reg_offset++;
d1239 1
a1239 1
      mlen += MAX2(ir->coordinate->type->vector_elements, 2);
d1255 1
a1255 1
      for (int i = 0; i < ir->lod_info.grad.dPdx->type->vector_elements; i++) {
d1257 1
a1257 1
	 dPdx.reg_offset++;
d1259 1
a1259 1
      mlen += MAX2(ir->lod_info.grad.dPdx->type->vector_elements, 2);
d1261 1
a1261 1
      for (int i = 0; i < ir->lod_info.grad.dPdy->type->vector_elements; i++) {
d1263 1
a1263 1
	 dPdy.reg_offset++;
d1265 2
a1266 2
      mlen += MAX2(ir->lod_info.grad.dPdy->type->vector_elements, 2);
   } else if (ir->op == ir_txs) {
d1276 1
a1276 1
      assert(ir->op == ir_txb || ir->op == ir_txl || ir->op == ir_txf);
d1278 1
a1278 1
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
d1281 1
a1281 1
	 coordinate.reg_offset++;
d1287 1
a1287 1
      for (int i = ir->coordinate->type->vector_elements; i < 3; i++) {
d1307 1
a1307 4
      dst = fs_reg(GRF, virtual_grf_alloc(8),
                   (brw->is_g4x ?
                    brw_type_for_base_type(ir->type) :
                    BRW_REGISTER_TYPE_F));
d1310 8
a1317 20
   fs_inst *inst = NULL;
   switch (ir->op) {
   case ir_tex:
      inst = emit(SHADER_OPCODE_TEX, dst);
      break;
   case ir_txb:
      inst = emit(FS_OPCODE_TXB, dst);
      break;
   case ir_txl:
      inst = emit(SHADER_OPCODE_TXL, dst);
      break;
   case ir_txd:
      inst = emit(SHADER_OPCODE_TXD, dst);
      break;
   case ir_txs:
      inst = emit(SHADER_OPCODE_TXS, dst);
      break;
   case ir_txf:
      inst = emit(SHADER_OPCODE_TXF, dst);
      break;
d1319 1
a1319 1
      fail("unrecognized texture opcode");
d1321 2
d1331 2
a1332 2
	 orig_dst.reg_offset++;
	 dst.reg_offset += 2;
d1348 6
a1353 3
fs_visitor::emit_texture_gen5(ir_texture *ir, fs_reg dst, fs_reg coordinate,
                              fs_reg shadow_c, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index)
a1354 2
   int mlen = 0;
   int base_mrf = 2;
a1356 2
   const int vector_elements =
      ir->coordinate ? ir->coordinate->type->vector_elements : 0;
d1358 4
a1361 1
   if (ir->offset) {
d1366 1
a1366 2
      mlen++;
      base_mrf--;
d1370 2
a1371 3
      emit(MOV(fs_reg(MRF, base_mrf + mlen + i * reg_width, coordinate.type),
               coordinate));
      coordinate.reg_offset++;
d1373 2
a1374 1
   mlen += vector_elements * reg_width;
d1376 5
a1380 5
   if (ir->shadow_comparitor) {
      mlen = MAX2(mlen, header_present + 4 * reg_width);

      emit(MOV(fs_reg(MRF, base_mrf + mlen), shadow_c));
      mlen += reg_width;
d1383 2
a1384 2
   fs_inst *inst = NULL;
   switch (ir->op) {
d1386 1
a1386 1
      inst = emit(SHADER_OPCODE_TEX, dst);
d1389 2
a1390 3
      mlen = MAX2(mlen, header_present + 4 * reg_width);
      emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
      mlen += reg_width;
d1392 1
a1392 1
      inst = emit(FS_OPCODE_TXB, dst);
d1395 2
a1396 3
      mlen = MAX2(mlen, header_present + 4 * reg_width);
      emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
      mlen += reg_width;
d1398 1
a1398 1
      inst = emit(SHADER_OPCODE_TXL, dst);
a1400 2
      mlen = MAX2(mlen, header_present + 4 * reg_width); /* skip over 'ai' */

d1410 9
a1418 8
      for (int i = 0; i < ir->lod_info.grad.dPdx->type->vector_elements; i++) {
	 emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
	 lod.reg_offset++;
	 mlen += reg_width;

	 emit(MOV(fs_reg(MRF, base_mrf + mlen), lod2));
	 lod2.reg_offset++;
	 mlen += reg_width;
d1421 1
a1421 1
      inst = emit(SHADER_OPCODE_TXD, dst);
d1425 5
a1429 3
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), lod));
      mlen += reg_width;
      inst = emit(SHADER_OPCODE_TXS, dst);
d1432 5
a1436 3
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
      mlen += reg_width;
      inst = emit(SHADER_OPCODE_TXS, dst);
d1439 5
a1443 3
      mlen = header_present + 4 * reg_width;
      emit(MOV(fs_reg(MRF, base_mrf + mlen - reg_width, BRW_REGISTER_TYPE_UD), lod));
      inst = emit(SHADER_OPCODE_TXF, dst);
d1446 1
a1446 2
      mlen = header_present + 4 * reg_width;

d1448 1
a1448 1
      emit(MOV(fs_reg(MRF, base_mrf + mlen - reg_width, BRW_REGISTER_TYPE_UD), fs_reg(0)));
d1450 4
a1453 3
      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), sample_index));
      mlen += reg_width;
      inst = emit(SHADER_OPCODE_TXF_CMS, dst);
d1456 1
a1456 1
      inst = emit(SHADER_OPCODE_LOD, dst);
d1459 1
a1459 1
      inst = emit(SHADER_OPCODE_TG4, dst);
d1462 1
a1462 2
      fail("unrecognized texture opcode");
      break;
d1464 4
a1467 2
   inst->base_mrf = base_mrf;
   inst->mlen = mlen;
d1469 1
a1469 1
   inst->regs_written = 4;
d1471 1
a1471 1
   if (mlen > MAX_SAMPLER_MESSAGE_SIZE) {
d1479 9
d1489 6
a1494 3
fs_visitor::emit_texture_gen7(ir_texture *ir, fs_reg dst, fs_reg coordinate,
                              fs_reg shadow_c, fs_reg lod, fs_reg lod2,
                              fs_reg sample_index, fs_reg mcs, int sampler)
d1499 5
a1503 2
   fs_reg payload = fs_reg(this, glsl_type::float_type);
   fs_reg next = payload;
d1505 2
a1506 1
   if (ir->op == ir_tg4 || (ir->offset && ir->op != ir_txf) || sampler >= 16) {
d1518 2
a1519 1
      next.reg_offset++;
d1522 3
a1524 3
   if (ir->shadow_comparitor) {
      emit(MOV(next, shadow_c));
      next.reg_offset++;
d1527 2
a1528 1
   bool has_nonconstant_offset = ir->offset && !ir->offset->as_constant();
d1532 1
a1532 1
   switch (ir->op) {
d1537 2
a1538 2
      emit(MOV(next, lod));
      next.reg_offset++;
d1541 2
a1542 2
      emit(MOV(next, lod));
      next.reg_offset++;
d1550 4
a1553 4
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
	 emit(MOV(next, coordinate));
	 coordinate.reg_offset++;
	 next.reg_offset++;
d1558 8
a1565 8
         if (i < ir->lod_info.grad.dPdx->type->vector_elements) {
            emit(MOV(next, lod));
            lod.reg_offset++;
            next.reg_offset++;

            emit(MOV(next, lod2));
            lod2.reg_offset++;
            next.reg_offset++;
d1573 2
a1574 2
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), lod));
      next.reg_offset++;
d1577 2
a1578 2
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
      next.reg_offset++;
d1582 11
a1592 11
      emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
      coordinate.reg_offset++;
      next.reg_offset++;

      emit(MOV(retype(next, BRW_REGISTER_TYPE_D), lod));
      next.reg_offset++;

      for (int i = 1; i < ir->coordinate->type->vector_elements; i++) {
	 emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
	 coordinate.reg_offset++;
	 next.reg_offset++;
d1598 2
a1599 2
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), sample_index));
      next.reg_offset++;
d1602 2
a1603 2
      emit(MOV(retype(next, BRW_REGISTER_TYPE_UD), mcs));
      next.reg_offset++;
d1608 4
a1611 4
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
         emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
         coordinate.reg_offset++;
         next.reg_offset++;
d1618 1
a1618 1
         if (ir->shadow_comparitor)
a1621 3
         ir->offset->accept(this);
         fs_reg offset_value = this->result;

d1623 3
a1625 3
            emit(MOV(next, coordinate));
            coordinate.reg_offset++;
            next.reg_offset++;
d1629 3
a1631 3
            emit(MOV(retype(next, BRW_REGISTER_TYPE_D), offset_value));
            offset_value.reg_offset++;
            next.reg_offset++;
d1634 4
a1637 4
         if (ir->coordinate->type->vector_elements == 3) { /* r if present */
            emit(MOV(next, coordinate));
            coordinate.reg_offset++;
            next.reg_offset++;
d1646 5
a1650 5
   if (ir->coordinate && !coordinate_done) {
      for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
         emit(MOV(next, coordinate));
         coordinate.reg_offset++;
         next.reg_offset++;
d1654 10
d1665 11
a1675 11
   fs_inst *inst = NULL;
   switch (ir->op) {
   case ir_tex: inst = emit(SHADER_OPCODE_TEX, dst, payload); break;
   case ir_txb: inst = emit(FS_OPCODE_TXB, dst, payload); break;
   case ir_txl: inst = emit(SHADER_OPCODE_TXL, dst, payload); break;
   case ir_txd: inst = emit(SHADER_OPCODE_TXD, dst, payload); break;
   case ir_txf: inst = emit(SHADER_OPCODE_TXF, dst, payload); break;
   case ir_txf_ms: inst = emit(SHADER_OPCODE_TXF_CMS, dst, payload); break;
   case ir_txs: inst = emit(SHADER_OPCODE_TXS, dst, payload); break;
   case ir_query_levels: inst = emit(SHADER_OPCODE_TXS, dst, payload); break;
   case ir_lod: inst = emit(SHADER_OPCODE_LOD, dst, payload); break;
d1678 1
a1678 1
         inst = emit(SHADER_OPCODE_TG4_OFFSET, dst, payload);
d1680 1
a1680 1
         inst = emit(SHADER_OPCODE_TG4, dst, payload);
d1682 2
d1685 1
d1687 1
a1687 4
   if (reg_width == 2)
      inst->mlen = next.reg_offset * reg_width - header_present;
   else
      inst->mlen = next.reg_offset * reg_width;
d1689 1
a1689 1
   inst->regs_written = 4;
a1690 1
   virtual_grf_sizes[payload.reg] = next.reg_offset;
d1700 2
a1701 2
fs_visitor::rescale_texcoord(ir_texture *ir, fs_reg coordinate,
                             bool is_rect, int sampler, int texunit)
d1706 4
d1717 2
a1718 2
	(brw->gen >= 6 && (c->key.tex.gl_clamp_mask[0] & (1 << sampler) ||
			     c->key.tex.gl_clamp_mask[1] & (1 << sampler))))) {
d1738 1
a1738 1
             &prog->Parameters->ParameterValues[index][0].f) {
d1751 1
a1751 1
            &prog->Parameters->ParameterValues[index][0].f;
d1753 1
a1753 1
            &prog->Parameters->ParameterValues[index][1].f;
d1762 1
a1762 1
      fs_reg dst = fs_reg(this, ir->coordinate->type);
d1767 2
a1768 2
      dst.reg_offset++;
      src.reg_offset++;
d1779 1
a1779 1
	 if (c->key.tex.gl_clamp_mask[i] & (1 << sampler)) {
d1781 1
a1781 1
	    chan.reg_offset += i;
d1802 3
a1804 4
   if (ir->coordinate && needs_gl_clamp) {
      for (unsigned int i = 0;
	   i < MIN2(ir->coordinate->type->vector_elements, 3); i++) {
	 if (c->key.tex.gl_clamp_mask[i] & (1 << sampler)) {
d1806 1
a1806 1
	    chan.reg_offset += i;
d1818 1
a1818 1
fs_visitor::emit_mcs_fetch(ir_texture *ir, fs_reg coordinate, int sampler)
d1821 2
a1822 1
   fs_reg payload = fs_reg(this, glsl_type::float_type);
d1824 1
a1824 1
   fs_reg next = payload;
d1826 5
a1830 5
   /* parameters are: u, v, r, lod; missing parameters are treated as zero */
   for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
      emit(MOV(retype(next, BRW_REGISTER_TYPE_D), coordinate));
      coordinate.reg_offset++;
      next.reg_offset++;
d1833 3
a1835 2
   fs_inst *inst = emit(SHADER_OPCODE_TXF_MCS, dest, payload);
   virtual_grf_sizes[payload.reg] = next.reg_offset;
d1837 1
a1837 1
   inst->mlen = next.reg_offset * reg_width;
d1839 4
a1842 4
   inst->regs_written = 4; /* we only care about one reg of response,
                            * but the sampler always writes 4/8
                            */
   inst->sampler = sampler;
d1848 18
a1865 2
fs_visitor::visit(ir_texture *ir)
{
d1868 1
a1868 9
   int sampler =
      _mesa_get_sampler_uniform_value(ir->sampler, shader_prog, prog);
   /* FINISHME: We're failing to recompile our programs when the sampler is
    * updated.  This only matters for the texture rectangle scale parameters
    * (pre-gen6, or gen6+ with GL_CLAMP).
    */
   int texunit = prog->SamplerUnits[sampler];

   if (ir->op == ir_tg4) {
d1872 1
a1872 2
      ir_constant *chan = ir->lod_info.component->as_constant();
      int swiz = GET_SWZ(c->key.tex.swizzles[sampler], chan->value.i[0]);
d1880 1
a1880 1
            res.reg_offset++;
d1886 118
d2015 1
d2017 1
d2019 1
a2019 5

      coordinate = rescale_texcoord(ir, this->result,
                                    ir->sampler->type->sampler_dimensionality ==
                                    GLSL_SAMPLER_DIM_RECT,
                                    sampler, texunit);
d2028 19
d2048 1
d2065 2
d2078 3
a2080 2
      if (brw->gen >= 7 && c->key.tex.compressed_multisample_layout_mask & (1<<sampler))
         mcs = emit_mcs_fetch(ir, coordinate, sampler);
d2085 1
a2085 1
      assert(!"Unrecognized texture opcode");
d2088 1
a2088 19
   /* Writemasking doesn't eliminate channels on SIMD8 texture
    * samples, so don't worry about them.
    */
   fs_reg dst = fs_reg(this, glsl_type::get_instance(ir->type->base_type, 4, 1));

   if (brw->gen >= 7) {
      inst = emit_texture_gen7(ir, dst, coordinate, shadow_comparitor,
                               lod, lod2, sample_index, mcs, sampler);
   } else if (brw->gen >= 5) {
      inst = emit_texture_gen5(ir, dst, coordinate, shadow_comparitor,
                               lod, lod2, sample_index);
   } else {
      inst = emit_texture_gen4(ir, dst, coordinate, shadow_comparitor,
                               lod, lod2);
   }

   if (ir->offset != NULL && ir->op != ir_txf)
      inst->texture_offset = brw_texture_offset(ctx, ir->offset->as_constant());

d2090 1
a2090 3
      inst->texture_offset |= gather_channel(ir, sampler) << 16; // M0.2:16-17

   inst->sampler = sampler;
d2092 2
a2093 17
   if (ir->shadow_comparitor)
      inst->shadow_compare = true;

   /* fixup #layers for cube map arrays */
   if (ir->op == ir_txs) {
      glsl_type const *type = ir->sampler->type;
      if (type->sampler_dimensionality == GLSL_SAMPLER_DIM_CUBE &&
          type->sampler_array) {
         fs_reg depth = dst;
         depth.reg_offset = 2;
         emit_math(SHADER_OPCODE_INT_QUOTIENT, depth, depth, fs_reg(6));
      }
   }

   if (brw->gen == 6 && ir->op == ir_tg4) {
      emit_gen6_gather_wa(c->key.tex.gen6_gather_wa[sampler], dst);
   }
d2095 8
a2102 1
   swizzle_result(ir, dst, sampler);
d2131 1
a2131 1
      dst.reg_offset++;
d2139 1
a2139 1
fs_visitor::gather_channel(ir_texture *ir, int sampler)
d2141 5
a2145 2
   ir_constant *chan = ir->lod_info.component->as_constant();
   int swiz = GET_SWZ(c->key.tex.swizzles[sampler], chan->value.i[0]);
d2152 1
a2152 1
         if (c->key.tex.gather_channel_quirk_mask & (1<<sampler))
d2158 1
a2158 2
         assert(!"Not reached"); /* zero, one swizzles handled already */
         return 0;
d2167 2
a2168 1
fs_visitor::swizzle_result(ir_texture *ir, fs_reg orig_val, int sampler)
d2170 1
a2170 1
   if (ir->op == ir_query_levels) {
d2172 1
a2172 2
      orig_val.reg_offset += 3;
      this->result = orig_val;
d2181 1
a2181 1
   if (ir->op == ir_txs || ir->op == ir_lod || ir->op == ir_tg4)
d2184 6
a2189 1
   if (ir->type == glsl_type::float_type) {
d2191 1
a2191 2
      assert(ir->sampler->type->sampler_shadow);
   } else if (c->key.tex.swizzles[sampler] != SWIZZLE_NOOP) {
d2193 1
d2196 1
a2196 1
	 int swiz = GET_SWZ(c->key.tex.swizzles[sampler], i);
d2198 1
a2198 1
	 l.reg_offset += i;
d2205 2
a2206 3
	    fs_reg r = orig_val;
	    r.reg_offset += GET_SWZ(c->key.tex.swizzles[sampler], i);
	    emit(MOV(l, r));
d2220 1
a2220 1
      this->result.reg_offset += ir->mask.x;
d2246 2
a2247 3
      channel.reg_offset += swiz;
      emit(MOV(result, channel));
      result.reg_offset++;
d2270 1
a2270 5
       * However, many people will do foliage by discarding based on a
       * texture's alpha mask, and then continue on to texture with the
       * remaining pixels.  To avoid trashing the derivatives for those
       * texture samples, we'll only jump if all of the pixels in the subspan
       * have been discarded.
d2274 4
a2277 1
      discard_jump->predicate = BRW_PREDICATE_ALIGN1_ANY4H;
d2305 2
a2306 2
	    src_reg.reg_offset++;
	    dst_reg.reg_offset++;
d2310 1
a2310 2
      foreach_list(node, &ir->components) {
	 ir_constant *const field = (ir_constant *) node;
d2319 2
a2320 2
	    src_reg.reg_offset++;
	    dst_reg.reg_offset++;
d2338 3
a2340 1
	    emit(MOV(dst_reg, fs_reg((int)ir->value.b[i])));
d2343 1
a2343 1
	    assert(!"Non-float/uint/int/bool constant");
d2345 1
a2345 1
	 dst_reg.reg_offset++;
d2357 38
a2394 6
   if (expr &&
       expr->operation != ir_binop_logic_and &&
       expr->operation != ir_binop_logic_or &&
       expr->operation != ir_binop_logic_xor) {
      fs_reg op[2];
      fs_inst *inst;
d2396 11
a2406 3
      assert(expr->get_num_operands() <= 2);
      for (unsigned int i = 0; i < expr->get_num_operands(); i++) {
	 assert(expr->operands[i]->type->is_scalar());
d2408 11
a2418 2
	 expr->operands[i]->accept(this);
	 op[i] = this->result;
d2420 6
a2425 1
	 resolve_ud_negate(&op[i]);
d2427 1
d2429 8
a2436 5
      switch (expr->operation) {
      case ir_unop_logic_not:
	 inst = emit(AND(reg_null_d, op[0], fs_reg(1)));
	 inst->conditional_mod = BRW_CONDITIONAL_Z;
	 break;
d2438 12
a2449 8
      case ir_unop_f2b:
	 if (brw->gen >= 6) {
	    emit(CMP(reg_null_d, op[0], fs_reg(0.0f), BRW_CONDITIONAL_NZ));
	 } else {
	    inst = emit(MOV(reg_null_f, op[0]));
            inst->conditional_mod = BRW_CONDITIONAL_NZ;
	 }
	 break;
d2451 3
a2453 8
      case ir_unop_i2b:
	 if (brw->gen >= 6) {
	    emit(CMP(reg_null_d, op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
	 } else {
	    inst = emit(MOV(reg_null_d, op[0]));
            inst->conditional_mod = BRW_CONDITIONAL_NZ;
	 }
	 break;
d2455 4
a2458 10
      case ir_binop_greater:
      case ir_binop_gequal:
      case ir_binop_less:
      case ir_binop_lequal:
      case ir_binop_equal:
      case ir_binop_all_equal:
      case ir_binop_nequal:
      case ir_binop_any_nequal:
	 resolve_bool_comparison(expr->operands[0], &op[0]);
	 resolve_bool_comparison(expr->operands[1], &op[1]);
d2460 4
a2463 3
	 emit(CMP(reg_null_d, op[0], op[1],
                  brw_conditional_for_comparison(expr->operation)));
	 break;
d2465 4
a2468 6
      default:
	 assert(!"not reached");
	 fail("bad cond code\n");
	 break;
      }
      return;
d2471 3
a2473 4
   ir->accept(this);

   fs_inst *inst = emit(AND(reg_null_d, this->result, fs_reg(1)));
   inst->conditional_mod = BRW_CONDITIONAL_NZ;
d2485 2
a2486 2
   if (expr) {
      fs_reg op[2];
d2490 1
a2490 1
      assert(expr->get_num_operands() <= 2);
d2500 3
d2504 3
d2508 5
d2514 4
a2517 5
         /* For operations on bool arguments, only the low bit of the bool is
          * valid, and the others are undefined.  Fall back to the condition
          * code path.
          */
         break;
d2536 4
a2539 2
	 resolve_bool_comparison(expr->operands[0], &op[0]);
	 resolve_bool_comparison(expr->operands[1], &op[1]);
d2544 15
d2560 1
a2560 4
	 assert(!"not reached");
	 emit(IF(op[0], fs_reg(0), BRW_CONDITIONAL_NZ));
	 fail("bad condition\n");
	 return;
d2564 2
a2565 3
   emit_bool_to_cond_code(ir->condition);
   fs_inst *inst = emit(BRW_OPCODE_IF);
   inst->predicate = BRW_PREDICATE_NORMAL;
d2624 2
a2625 2
         if_inst->next->remove();
      if_inst->remove();
d2673 3
a2675 5
   foreach_list(node, &ir->then_instructions) {
      ir_instruction *ir = (ir_instruction *)node;
      this->base_ir = ir;

      ir->accept(this);
d2681 3
a2683 5
      foreach_list(node, &ir->else_instructions) {
	 ir_instruction *ir = (ir_instruction *)node;
	 this->base_ir = ir;

	 ir->accept(this);
d2702 3
a2704 5
   foreach_list(node, &ir->body_instructions) {
      ir_instruction *ir = (ir_instruction *)node;

      this->base_ir = ir;
      ir->accept(this);
d2730 2
a2731 2
   unsigned surf_index = (c->prog_data.base.binding_table.abo_start +
                          location->data.atomic.buffer_index);
d2741 2
a2742 2
      emit(MUL(tmp, this->result, ATOMIC_COUNTER_SIZE));
      emit(ADD(offset, tmp, location->data.atomic.offset));
d2744 1
a2744 1
      offset = location->data.atomic.offset;
d2775 1
a2775 1
      assert(!"Unsupported intrinsic.");
d2780 1
a2780 1
fs_visitor::visit(ir_return *ir)
d2782 1
a2782 1
   assert(!"FINISHME");
d2795 1
a2795 1
      sig = ir->matching_signature(NULL, &empty);
d2799 3
a2801 5
      foreach_list(node, &sig->body) {
	 ir_instruction *ir = (ir_instruction *)node;
	 this->base_ir = ir;

	 ir->accept(this);
d2807 1
a2807 1
fs_visitor::visit(ir_function_signature *ir)
d2809 1
a2809 2
   assert(!"not reached");
   (void)ir;
d2815 1
a2815 1
   assert(!"not reached");
d2821 1
a2821 1
   assert(!"not reached");
d2829 5
a2833 2
   const unsigned operand_len = dispatch_width / 8;
   unsigned mlen = 0;
d2835 3
d2839 1
a2839 1
   emit(MOV(brw_uvec_mrf(8, mlen, 0), fs_reg(0u)))
d2842 2
a2843 2
   if (fp->UsesKill) {
      emit(MOV(brw_uvec_mrf(1, mlen, 7), brw_flag_reg(0, 1)))
d2846 1
a2846 1
      emit(MOV(brw_uvec_mrf(1, mlen, 7),
d2850 1
a2850 2

   mlen++;
d2853 3
a2855 2
   emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), offset));
   mlen += operand_len;
d2859 3
a2861 2
      emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), src0));
      mlen += operand_len;
d2865 3
a2867 2
      emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), src1));
      mlen += operand_len;
d2870 5
d2876 2
a2877 3
   fs_inst *inst = new(mem_ctx) fs_inst(SHADER_OPCODE_UNTYPED_ATOMIC, dst,
                                        atomic_op, surf_index);
   inst->base_mrf = 0;
a2878 2
   inst->header_present = true;
   emit(inst);
d2885 4
a2888 2
   const unsigned operand_len = dispatch_width / 8;
   unsigned mlen = 0;
d2890 3
d2894 1
a2894 1
   emit(MOV(brw_uvec_mrf(8, mlen, 0), fs_reg(0u)))
d2897 2
a2898 2
   if (fp->UsesKill) {
      emit(MOV(brw_uvec_mrf(1, mlen, 7), brw_flag_reg(0, 1)))
d2901 1
a2901 1
      emit(MOV(brw_uvec_mrf(1, mlen, 7),
d2906 3
a2908 1
   mlen++;
d2910 4
a2913 3
   /* Set the surface read offset. */
   emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), offset));
   mlen += operand_len;
d2916 2
a2917 3
   fs_inst *inst = new(mem_ctx)
      fs_inst(SHADER_OPCODE_UNTYPED_SURFACE_READ, dst, surf_index);
   inst->base_mrf = 0;
a2918 2
   inst->header_present = true;
   emit(inst);
d2924 1
a2924 1
   if (force_uncompressed_stack > 0)
d2938 2
a2939 3
   foreach_list_safe(node, &list) {
      fs_inst *inst = (fs_inst *)node;
      inst->remove();
d2970 3
a2972 1
   int regnr = c->prog_data.urb_setup[location] * 2 + channel / 2;
d2975 1
a2975 1
   assert(c->prog_data.urb_setup[location] != -1);
d2998 1
a2998 2
         this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC];
      this->delta_y[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC].reg_offset++;
d3054 1
a3054 1
   this->pixel_w = fs_reg(brw_vec8_grf(c->source_w_reg, 0));
d3059 1
a3059 1
      uint8_t reg = c->barycentric_coord_reg[i];
d3067 2
a3068 2
void
fs_visitor::emit_color_write(int target, int index, int first_color_mrf)
d3070 1
a3070 1
   int reg_width = dispatch_width / 8;
a3071 2
   fs_reg color = outputs[target];
   fs_reg mrf;
d3073 3
a3075 3
   /* If there's no color data to be written, skip it. */
   if (color.file == BAD_FILE)
      return;
d3077 8
a3084 1
   color.reg_offset += index;
d3103 14
a3116 4
      inst = emit(MOV(fs_reg(MRF, first_color_mrf + index * reg_width,
                             color.type),
                      color));
      inst->saturate = c->key.clamp_fragment_color;
d3128 11
a3138 21
      if (brw->has_compr4) {
	 /* By setting the high bit of the MRF register number, we
	  * indicate that we want COMPR4 mode - instead of doing the
	  * usual destination + 1 for the second half we get
	  * destination + 4.
	  */
	 inst = emit(MOV(fs_reg(MRF, BRW_MRF_COMPR4 + first_color_mrf + index,
                                color.type),
                         color));
	 inst->saturate = c->key.clamp_fragment_color;
      } else {
	 push_force_uncompressed();
	 inst = emit(MOV(fs_reg(MRF, first_color_mrf + index, color.type),
                         color));
	 inst->saturate = c->key.clamp_fragment_color;
	 pop_force_uncompressed();

	 inst = emit(MOV(fs_reg(MRF, first_color_mrf + index + 4, color.type),
                         half(color, 1)));
	 inst->force_sechalf = true;
	 inst->saturate = c->key.clamp_fragment_color;
d3140 1
d3144 1
a3144 1
static int
d3161 1
a3161 2
         assert(!"Not reached");
         return 0;
d3172 2
d3177 1
a3177 1
   if (c->key.alpha_test_func == GL_ALWAYS)
d3180 1
a3180 1
   if (c->key.alpha_test_func == GL_NEVER) {
d3188 1
a3188 2
      fs_reg color = outputs[0];
      color.reg_offset += 3;
d3191 2
a3192 2
      cmp = emit(CMP(reg_null_f, color, fs_reg(c->key.alpha_test_ref),
                     cond_for_alpha_func(c->key.alpha_test_func)));
d3198 3
a3200 2
void
fs_visitor::emit_fb_writes()
d3202 4
d3208 2
d3213 2
a3214 10
   int base_mrf = 1;
   int nr = base_mrf;
   int reg_width = dispatch_width / 8;
   bool src0_alpha_to_render_target = false;

   if (do_dual_src) {
      no16("GL_ARB_blend_func_extended not yet supported in SIMD16.");
      if (dispatch_width == 16)
         do_dual_src = false;
   }
d3224 3
a3226 3
       (brw->is_haswell || brw->gen >= 8 || !this->fp->UsesKill) &&
       !do_dual_src &&
       c->key.nr_color_regions == 1) {
d3230 14
a3243 18
   if (header_present) {
      src0_alpha_to_render_target = brw->gen >= 6 &&
				    !do_dual_src &&
                                    c->key.replicate_alpha;
      /* m2, m3 header */
      nr += 2;
   }

   if (c->aa_dest_stencil_reg) {
      push_force_uncompressed();
      emit(MOV(fs_reg(MRF, nr++),
               fs_reg(brw_vec8_grf(c->aa_dest_stencil_reg, 0))));
      pop_force_uncompressed();
   }

   c->prog_data.uses_omask =
      fp->Base.OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_SAMPLE_MASK);
   if(c->prog_data.uses_omask) {
d3246 7
a3252 3
      /* Hand over gl_SampleMask. Only lower 16 bits are relevant. */
      emit(FS_OPCODE_SET_OMASK, fs_reg(MRF, nr, BRW_REGISTER_TYPE_UW), this->sample_mask);
      nr += 1;
d3255 20
a3274 7
   /* Reserve space for color. It'll be filled in per MRT below. */
   int color_mrf = nr;
   nr += 4 * reg_width;
   if (do_dual_src)
      nr += 4;
   if (src0_alpha_to_render_target)
      nr += reg_width;
d3276 1
a3276 1
   if (c->source_depth_to_render_target) {
d3286 1
d3290 1
a3290 1
	 emit(MOV(fs_reg(MRF, nr), this->frag_depth));
d3293 2
a3294 2
	 emit(MOV(fs_reg(MRF, nr),
                  fs_reg(brw_vec8_grf(c->source_depth_reg, 0))));
d3296 1
a3296 1
      nr += reg_width;
d3299 5
a3303 4
   if (c->dest_depth_reg) {
      emit(MOV(fs_reg(MRF, nr),
               fs_reg(brw_vec8_grf(c->dest_depth_reg, 0))));
      nr += reg_width;
d3306 26
a3331 3
   if (do_dual_src) {
      fs_reg src0 = this->outputs[0];
      fs_reg src1 = this->dual_src_output;
d3333 6
a3338 7
      this->current_annotation = ralloc_asprintf(this->mem_ctx,
						 "FB write src0");
      for (int i = 0; i < 4; i++) {
	 fs_inst *inst = emit(MOV(fs_reg(MRF, color_mrf + i, src0.type), src0));
	 src0.reg_offset++;
	 inst->saturate = c->key.clamp_fragment_color;
      }
d3340 5
a3344 8
      this->current_annotation = ralloc_asprintf(this->mem_ctx,
						 "FB write src1");
      for (int i = 0; i < 4; i++) {
	 fs_inst *inst = emit(MOV(fs_reg(MRF, color_mrf + 4 + i, src1.type),
                                  src1));
	 src1.reg_offset++;
	 inst->saturate = c->key.clamp_fragment_color;
      }
d3346 2
d3351 4
a3354 1
      fs_inst *inst = emit(FS_OPCODE_FB_WRITE);
d3356 9
a3364 39
      inst->base_mrf = base_mrf;
      inst->mlen = nr - base_mrf;
      inst->eot = true;
      inst->header_present = header_present;
      if ((brw->gen >= 8 || brw->is_haswell) && fp->UsesKill) {
         inst->predicate = BRW_PREDICATE_NORMAL;
         inst->flag_subreg = 1;
      }

      c->prog_data.dual_src_blend = true;
      this->current_annotation = NULL;
      return;
   }

   for (int target = 0; target < c->key.nr_color_regions; target++) {
      this->current_annotation = ralloc_asprintf(this->mem_ctx,
						 "FB write target %d",
						 target);
      /* If src0_alpha_to_render_target is true, include source zero alpha
       * data in RenderTargetWrite message for targets > 0.
       */
      int write_color_mrf = color_mrf;
      if (src0_alpha_to_render_target && target != 0) {
         fs_inst *inst;
         fs_reg color = outputs[0];
         color.reg_offset += 3;

         inst = emit(MOV(fs_reg(MRF, write_color_mrf, color.type),
                         color));
         inst->saturate = c->key.clamp_fragment_color;
         write_color_mrf = color_mrf + reg_width;
      }

      for (unsigned i = 0; i < this->output_components[target]; i++)
         emit_color_write(target, i, write_color_mrf);

      bool eot = false;
      if (target == c->key.nr_color_regions - 1) {
         eot = true;
d3366 2
a3367 1
         if (INTEL_DEBUG & DEBUG_SHADER_TIME)
a3368 1
      }
d3370 4
a3373 12
      fs_inst *inst = emit(FS_OPCODE_FB_WRITE);
      inst->target = target;
      inst->base_mrf = base_mrf;
      if (src0_alpha_to_render_target && target == 0)
         inst->mlen = nr - base_mrf - reg_width;
      else
         inst->mlen = nr - base_mrf;
      inst->eot = eot;
      inst->header_present = header_present;
      if ((brw->gen >= 8 || brw->is_haswell) && fp->UsesKill) {
         inst->predicate = BRW_PREDICATE_NORMAL;
         inst->flag_subreg = 1;
d3375 3
a3377 1
   }
a3378 1
   if (c->key.nr_color_regions == 0) {
d3383 2
a3384 14
      emit_color_write(0, 3, color_mrf);

      if (INTEL_DEBUG & DEBUG_SHADER_TIME)
         emit_shader_time_end();

      fs_inst *inst = emit(FS_OPCODE_FB_WRITE);
      inst->base_mrf = base_mrf;
      inst->mlen = nr - base_mrf;
      inst->eot = true;
      inst->header_present = header_present;
      if ((brw->gen >= 8 || brw->is_haswell) && fp->UsesKill) {
         inst->predicate = BRW_PREDICATE_NORMAL;
         inst->flag_subreg = 1;
      }
d3387 1
d3406 2
d3412 1
a3412 1
   emit(AND(temp, *reg, fs_reg(1)));
d3417 3
a3419 1
                       struct brw_wm_compile *c,
d3423 1
a3423 1
   : backend_visitor(brw, shader_prog, &fp->Base, &c->prog_data.base,
d3425 4
d3431 7
a3437 3
   this->c = c;
   this->fp = fp;
   this->mem_ctx = ralloc_context(NULL);
d3445 1
d3448 2
d3465 1
a3468 2
   this->force_uncompressed_stack = 0;

a3477 1
   ralloc_free(this->mem_ctx);
@


