head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.04.12;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.32;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.32;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.08;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.28.11;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.15.19;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.46;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.11.22;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.48.28;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "i915_context.h"
#include "main/api_exec.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/version.h"
#include "main/vtxfmt.h"
#include "intel_chipset.h"
#include "intel_tris.h"
#include "tnl/t_context.h"
#include "tnl/t_pipeline.h"
#include "tnl/t_vertex.h"

#include "swrast/swrast.h"
#include "swrast_setup/swrast_setup.h"
#include "tnl/tnl.h"
#include "../glsl/ralloc.h"

#include "i915_reg.h"
#include "i915_program.h"

/***************************************
 * Mesa's Driver Functions
 ***************************************/

/* Override intel default.
 */
static void
i915InvalidateState(struct gl_context * ctx, GLuint new_state)
{
   _swrast_InvalidateState(ctx, new_state);
   _swsetup_InvalidateState(ctx, new_state);
   _vbo_InvalidateState(ctx, new_state);
   _tnl_InvalidateState(ctx, new_state);
   _tnl_invalidate_vertex_state(ctx, new_state);
   intel_context(ctx)->NewGLState |= new_state;

   /* Todo: gather state values under which tracked parameters become
    * invalidated, add callbacks for things like
    * ProgramLocalParameters, etc.
    */
   {
      struct i915_fragment_program *p =
         (struct i915_fragment_program *) ctx->FragmentProgram._Current;
      if (p && p->nr_params)
         p->params_uptodate = 0;
   }

   if (new_state & (_NEW_STENCIL | _NEW_BUFFERS | _NEW_POLYGON))
      i915_update_stencil(ctx);
   if (new_state & (_NEW_LIGHT))
       i915_update_provoking_vertex(ctx);
   if (new_state & (_NEW_PROGRAM | _NEW_PROGRAM_CONSTANTS))
       i915_update_program(ctx);
   if (new_state & (_NEW_PROGRAM | _NEW_POINT))
       i915_update_sprite_point_enable(ctx);
}


static void
i915InitDriverFunctions(struct dd_function_table *functions)
{
   intelInitDriverFunctions(functions);
   i915InitStateFunctions(functions);
   i915InitFragProgFuncs(functions);
   functions->UpdateState = i915InvalidateState;
}

/* Note: this is shared with i830. */
void
intel_init_texture_formats(struct gl_context *ctx)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_screen *intel_screen = intel->intelScreen;

   ctx->TextureFormatSupported[MESA_FORMAT_B8G8R8A8_UNORM] = true;
   if (intel_screen->deviceID != PCI_CHIP_I830_M &&
       intel_screen->deviceID != PCI_CHIP_845_G)
      ctx->TextureFormatSupported[MESA_FORMAT_B8G8R8X8_UNORM] = true;
   if (intel->gen == 3)
      ctx->TextureFormatSupported[MESA_FORMAT_B8G8R8A8_SRGB] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_B4G4R4A4_UNORM] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_B5G5R5A1_UNORM] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_B5G6R5_UNORM] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_L_UNORM8] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_A_UNORM8] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_I_UNORM8] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_L8A8_UNORM] = true;

   /* Depth and stencil */
   if (intel->gen == 3) {
      ctx->TextureFormatSupported[MESA_FORMAT_Z24_UNORM_S8_UINT] = true;
      ctx->TextureFormatSupported[MESA_FORMAT_Z24_UNORM_X8_UINT] = true;

      /*
       * This was disabled in initial FBO enabling to avoid combinations
       * of depth+stencil that wouldn't work together.  We since decided
       * that it was OK, since it's up to the app to come up with the
       * combo that actually works, so this can probably be re-enabled.
       */
      /*
      ctx->TextureFormatSupported[MESA_FORMAT_Z_UNORM16] = true;
      ctx->TextureFormatSupported[MESA_FORMAT_Z24] = true;
      */
   }

   /* ctx->Extensions.MESA_ycbcr_texture */
   ctx->TextureFormatSupported[MESA_FORMAT_YCBCR] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_YCBCR_REV] = true;

   /* GL_3DFX_texture_compression_FXT1 */
   ctx->TextureFormatSupported[MESA_FORMAT_RGB_FXT1] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_RGBA_FXT1] = true;

   /* GL_EXT_texture_compression_s3tc */
   ctx->TextureFormatSupported[MESA_FORMAT_RGB_DXT1] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_RGBA_DXT1] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_RGBA_DXT3] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_RGBA_DXT5] = true;
}

extern const struct tnl_pipeline_stage *intel_pipeline[];

bool
i915CreateContext(int api,
		  const struct gl_config * mesaVis,
                  __DRIcontext * driContextPriv,
                  unsigned major_version,
                  unsigned minor_version,
                  uint32_t flags,
                  unsigned *error,
                  void *sharedContextPrivate)
{
   struct dd_function_table functions;
   struct i915_context *i915 = rzalloc(NULL, struct i915_context);
   struct intel_context *intel = &i915->intel;
   struct gl_context *ctx = &intel->ctx;

   if (!i915) {
      *error = __DRI_CTX_ERROR_NO_MEMORY;
      return false;
   }

   i915InitVtbl(i915);

   i915InitDriverFunctions(&functions);

   if (!intelInitContext(intel, api, major_version, minor_version, flags,
                         mesaVis, driContextPriv,
                         sharedContextPrivate, &functions,
                         error)) {
      ralloc_free(i915);
      return false;
   }

   intel_init_texture_formats(ctx);

   _math_matrix_ctr(&intel->ViewportMatrix);

   /* Initialize swrast, tnl driver tables: */
   intelInitTriFuncs(ctx);

   /* Install the customized pipeline: */
   _tnl_destroy_pipeline(ctx);
   _tnl_install_pipeline(ctx, intel_pipeline);

   if (intel->no_rast)
      FALLBACK(intel, INTEL_FALLBACK_USER, 1);

   ctx->Const.MaxTextureUnits = I915_TEX_UNITS;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits = I915_TEX_UNITS;
   ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits = I915_TEX_UNITS;
   ctx->Const.MaxTextureCoordUnits = I915_TEX_UNITS;
   ctx->Const.MaxVarying = I915_TEX_UNITS;
   ctx->Const.Program[MESA_SHADER_VERTEX].MaxOutputComponents =
      ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxInputComponents = ctx->Const.MaxVarying * 4;
   ctx->Const.MaxCombinedTextureImageUnits =
      ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits +
      ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits;

   /* Advertise the full hardware capabilities.  The new memory
    * manager should cope much better with overload situations:
    */
   ctx->Const.MaxTextureLevels = 12;
   ctx->Const.Max3DTextureLevels = 9;
   ctx->Const.MaxCubeTextureLevels = 12;
   ctx->Const.MaxTextureRectSize = (1 << 11);
   ctx->Const.MaxTextureUnits = I915_TEX_UNITS;

   ctx->Const.MaxTextureMaxAnisotropy = 4.0;

   /* GL_ARB_fragment_program limits - don't think Mesa actually
    * validates programs against these, and in any case one ARB
    * instruction can translate to more than one HW instruction, so
    * we'll still have to check and fallback each time.
    */
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeTemps = I915_MAX_TEMPORARY;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeAttribs = 11;    /* 8 tex, 2 color, fog */
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeParameters = I915_MAX_CONSTANT;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeAluInstructions = I915_MAX_ALU_INSN;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeTexInstructions = I915_MAX_TEX_INSN;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeInstructions = (I915_MAX_ALU_INSN +
                                                       I915_MAX_TEX_INSN);
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeTexIndirections =
      I915_MAX_TEX_INDIRECT;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeAddressRegs = 0; /* I don't think we have one */
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxEnvParams =
      MIN2(ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeParameters,
	   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxEnvParams);

   /* i915 stores all values in single-precision floats.  Values aren't set
    * for other program targets because software is used for those targets.
    */
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumFloat.RangeMin = 127;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumFloat.RangeMax = 127;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumFloat.Precision = 23;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].LowFloat = ctx->Const.Program[MESA_SHADER_FRAGMENT].HighFloat =
      ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumFloat;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumInt.RangeMin = 24;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumInt.RangeMax = 24;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumInt.Precision = 0;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].LowInt = ctx->Const.Program[MESA_SHADER_FRAGMENT].HighInt =
      ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumInt;

   ctx->FragmentProgram._MaintainTexEnvProgram = true;

   /* FINISHME: Are there other options that should be enabled for software
    * FINISHME: vertex shaders?
    */
   ctx->ShaderCompilerOptions[MESA_SHADER_VERTEX].EmitCondCodes = true;

   struct gl_shader_compiler_options *const fs_options =
      & ctx->ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
   fs_options->MaxIfDepth = 0;
   fs_options->EmitNoNoise = true;
   fs_options->EmitNoPow = true;
   fs_options->EmitNoMainReturn = true;
   fs_options->EmitNoIndirectInput = true;
   fs_options->EmitNoIndirectOutput = true;
   fs_options->EmitNoIndirectUniform = true;
   fs_options->EmitNoIndirectTemp = true;

   ctx->Const.MaxDrawBuffers = 1;
   ctx->Const.QueryCounterBits.SamplesPassed = 0;

   _tnl_init_vertices(ctx, ctx->Const.MaxArrayLockSize + 12,
                      36 * sizeof(GLfloat));

   intel->verts = TNL_CONTEXT(ctx)->clipspace.vertex_buf;

   i915InitState(i915);

   /* Always enable pixel fog.  Vertex fog using fog coord will conflict
    * with fog code appended onto fragment program.
    */
   _tnl_allow_vertex_fog(ctx, 0);
   _tnl_allow_pixel_fog(ctx, 1);

   _mesa_compute_version(ctx);

   _mesa_initialize_dispatch_tables(ctx);
   _mesa_initialize_vbo_vtxfmt(ctx);

   return true;
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d43 1
a43 1
#include "util/ralloc.h"
d112 1
a112 2
   if (intel->gen == 3)
      ctx->TextureFormatSupported[MESA_FORMAT_A_UNORM8] = true;
d256 1
a256 1
   ctx->Const.ShaderCompilerOptions[MESA_SHADER_VERTEX].EmitCondCodes = true;
d259 1
a259 1
      & ctx->Const.ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d43 1
a43 1
#include "../glsl/ralloc.h"
d112 2
a113 1
   ctx->TextureFormatSupported[MESA_FORMAT_A_UNORM8] = true;
d257 1
a257 1
   ctx->ShaderCompilerOptions[MESA_SHADER_VERTEX].EmitCondCodes = true;
d260 1
a260 1
      & ctx->ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d102 1
a102 1
   ctx->TextureFormatSupported[MESA_FORMAT_ARGB8888] = true;
d105 1
a105 1
      ctx->TextureFormatSupported[MESA_FORMAT_XRGB8888] = true;
d107 8
a114 8
      ctx->TextureFormatSupported[MESA_FORMAT_SARGB8] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_ARGB4444] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_ARGB1555] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_RGB565] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_L8] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_A8] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_I8] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_AL88] = true;
d117 15
a131 13
   ctx->TextureFormatSupported[MESA_FORMAT_S8_Z24] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_X8_Z24] = true;

   /*
    * This was disabled in initial FBO enabling to avoid combinations
    * of depth+stencil that wouldn't work together.  We since decided
    * that it was OK, since it's up to the app to come up with the
    * combo that actually works, so this can probably be re-enabled.
    */
   /*
   ctx->TextureFormatSupported[MESA_FORMAT_Z16] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_Z24] = true;
   */
d156 1
d174 1
a174 1
   if (!intelInitContext(intel, api, major_version, minor_version,
d197 2
a198 1
   ctx->Const.FragmentProgram.MaxTextureImageUnits = I915_TEX_UNITS;
d201 2
d204 2
a205 2
      ctx->Const.VertexProgram.MaxTextureImageUnits +
      ctx->Const.FragmentProgram.MaxTextureImageUnits;
d223 6
a228 6
   ctx->Const.FragmentProgram.MaxNativeTemps = I915_MAX_TEMPORARY;
   ctx->Const.FragmentProgram.MaxNativeAttribs = 11;    /* 8 tex, 2 color, fog */
   ctx->Const.FragmentProgram.MaxNativeParameters = I915_MAX_CONSTANT;
   ctx->Const.FragmentProgram.MaxNativeAluInstructions = I915_MAX_ALU_INSN;
   ctx->Const.FragmentProgram.MaxNativeTexInstructions = I915_MAX_TEX_INSN;
   ctx->Const.FragmentProgram.MaxNativeInstructions = (I915_MAX_ALU_INSN +
d230 1
a230 1
   ctx->Const.FragmentProgram.MaxNativeTexIndirections =
d232 4
a235 4
   ctx->Const.FragmentProgram.MaxNativeAddressRegs = 0; /* I don't think we have one */
   ctx->Const.FragmentProgram.MaxEnvParams =
      MIN2(ctx->Const.FragmentProgram.MaxNativeParameters,
	   ctx->Const.FragmentProgram.MaxEnvParams);
d240 10
a249 10
   ctx->Const.FragmentProgram.MediumFloat.RangeMin = 127;
   ctx->Const.FragmentProgram.MediumFloat.RangeMax = 127;
   ctx->Const.FragmentProgram.MediumFloat.Precision = 23;
   ctx->Const.FragmentProgram.LowFloat = ctx->Const.FragmentProgram.HighFloat =
      ctx->Const.FragmentProgram.MediumFloat;
   ctx->Const.FragmentProgram.MediumInt.RangeMin = 24;
   ctx->Const.FragmentProgram.MediumInt.RangeMax = 24;
   ctx->Const.FragmentProgram.MediumInt.Precision = 0;
   ctx->Const.FragmentProgram.LowInt = ctx->Const.FragmentProgram.HighInt =
      ctx->Const.FragmentProgram.MediumInt;
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d29 1
d32 3
d43 1
a47 2
#include "intel_span.h"

d81 2
d95 50
d148 1
a148 1
GLboolean
d152 3
d158 1
a158 2
   struct i915_context *i915 =
      (struct i915_context *) CALLOC_STRUCT(i915_context);
d162 4
a165 2
   if (!i915)
      return GL_FALSE;
d171 6
a176 4
   if (!intelInitContext(intel, api, mesaVis, driContextPriv,
                         sharedContextPrivate, &functions)) {
      FREE(i915);
      return GL_FALSE;
d179 2
a183 1
   intelInitSpanFuncs(ctx);
d194 1
a194 1
   ctx->Const.MaxTextureImageUnits = I915_TEX_UNITS;
d198 2
a199 2
      ctx->Const.MaxVertexTextureImageUnits +
      ctx->Const.MaxTextureImageUnits;
d245 1
a245 1
   ctx->FragmentProgram._MaintainTexEnvProgram = GL_TRUE;
d250 1
a250 1
   ctx->ShaderCompilerOptions[MESA_SHADER_VERTEX].EmitCondCodes = GL_TRUE;
d254 8
a261 8
   fs_options->EmitNoIfs = GL_TRUE;
   fs_options->EmitNoNoise = GL_TRUE;
   fs_options->EmitNoPow = GL_TRUE;
   fs_options->EmitNoMainReturn = GL_TRUE;
   fs_options->EmitNoIndirectInput = GL_TRUE;
   fs_options->EmitNoIndirectOutput = GL_TRUE;
   fs_options->EmitNoIndirectUniform = GL_TRUE;
   fs_options->EmitNoIndirectTemp = GL_TRUE;
d264 1
d279 6
a284 1
   return GL_TRUE;
@


1.5
log
@Merge Mesa 7.10.3
@
text
@a71 2
   if (new_state & (_NEW_FOG | _NEW_HINT | _NEW_PROGRAM | _NEW_PROGRAM_CONSTANTS))
      i915_update_fog(ctx);
d209 6
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a42 1
#include "intel_tris.h"
d52 1
a52 1
i915InvalidateState(GLcontext * ctx, GLuint new_state)
d96 2
a97 1
i915CreateContext(const __GLcontextModes * mesaVis,
d105 1
a105 1
   GLcontext *ctx = &intel->ctx;
a109 3
   if (0)
      printf("\ntexmem-0-3 branch\n\n");

d114 1
a114 1
   if (!intelInitContext(intel, mesaVis, driContextPriv,
d171 14
d186 16
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d30 1
a30 1
#include "intel_tex.h"
a39 1
#include "utils.h"
d41 1
a42 2
#include "intel_regions.h"
#include "intel_batchbuffer.h"
a44 1
#include "intel_pixel.h"
a49 10
static const struct dri_extension i915_extensions[] = {
   {"GL_ARB_depth_texture", NULL},
   {"GL_ARB_fragment_program", NULL},
   {"GL_ARB_shadow", NULL},
   {"GL_ARB_texture_non_power_of_two", NULL},
   {"GL_ATI_texture_env_combine3",       NULL},
   {"GL_EXT_shadow_funcs", NULL},
   {NULL, NULL}
};

d73 1
a73 1
   if (new_state & (_NEW_FOG | _NEW_HINT | _NEW_PROGRAM))
d75 6
a88 1
   i915InitTextureFuncs(functions);
d98 1
a98 1
                  __DRIcontextPrivate * driContextPriv,
d111 1
a111 1
      _mesa_printf("\ntexmem-0-3 branch\n\n");
a113 1
   i915InitMetaFuncs(i915);
d123 2
d139 4
a142 1

d153 2
d170 3
d176 1
a176 2
   driInitExtensions(ctx, i915_extensions, GL_FALSE);

@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d29 1
a29 1
#include "imports.h"
d58 1
a59 2
   /* ARB extn won't work if not enabled */
   {"GL_SGIX_depth_texture", NULL},
d140 3
a173 1
   ctx->FragmentProgram._UseTexEnvProgram = GL_TRUE;
@


1.1
log
@Initial revision
@
text
@a38 1
#include "array_cache/acache.h"
d43 6
d53 9
a61 9
static const struct dri_extension i915_extensions[] =
{
    { "GL_ARB_depth_texture",              NULL },
    { "GL_ARB_fragment_program",           NULL },
    { "GL_ARB_shadow",                     NULL },
    { "GL_EXT_shadow_funcs",               NULL },
    /* ARB extn won't work if not enabled */
    { "GL_SGIX_depth_texture",             NULL },
    { NULL,                                NULL }
d66 2
a67 1
static void i915InvalidateState( GLcontext *ctx, GLuint new_state )
d69 6
a74 6
   _swrast_InvalidateState( ctx, new_state );
   _swsetup_InvalidateState( ctx, new_state );
   _ac_InvalidateState( ctx, new_state );
   _tnl_InvalidateState( ctx, new_state );
   _tnl_invalidate_vertex_state( ctx, new_state );
   INTEL_CONTEXT(ctx)->NewGLState |= new_state;
d81 2
a82 2
      struct i915_fragment_program *p = 
	 (struct i915_fragment_program *)ctx->FragmentProgram._Current;
d84 1
a84 1
	 p->params_uptodate = 0;
d87 1
a87 1
   if (new_state & (_NEW_FOG|_NEW_HINT|_NEW_PROGRAM))
d92 2
a93 1
static void i915InitDriverFunctions( struct dd_function_table *functions )
d95 4
a98 4
   intelInitDriverFunctions( functions );
   i915InitStateFunctions( functions );
   i915InitTextureFuncs( functions );
   i915InitFragProgFuncs( functions );
d103 1
d105 4
a108 3
GLboolean i915CreateContext( const __GLcontextModes *mesaVis,
			    __DRIcontextPrivate *driContextPriv,
			    void *sharedContextPrivate)
d111 3
a113 2
   i915ContextPtr i915 = (i915ContextPtr) CALLOC_STRUCT(i915_context);
   intelContextPtr intel = &i915->intel;
a114 1
   GLuint i;
d116 5
a120 1
   if (!i915) return GL_FALSE;
d122 2
a123 1
   i915InitVtbl( i915 );
d125 1
a125 1
   i915InitDriverFunctions( &functions );
d127 2
a128 2
   if (!intelInitContext( intel, mesaVis, driContextPriv,
			  sharedContextPrivate, &functions )) {
d133 8
d145 3
a147 15
   intel->nr_heaps = 1;
   intel->texture_heaps[0] = 
      driCreateTextureHeap( 0, intel,
			    intel->intelScreen->tex.size,
			    12,
			    I830_NR_TEX_REGIONS,
			    intel->sarea->texList,
			    (unsigned *) & intel->sarea->texAge,
			    & intel->swapped,
			    sizeof( struct i915_texture_object ),
			    (destroy_texture_object_t *)intelDestroyTexObj );

   /* FIXME: driCalculateMaxTextureLevels assumes that mipmaps are
    * tightly packed, but they're not in Intel graphics
    * hardware.
d149 4
a153 12
   i = driQueryOptioni( &intel->optionCache, "allow_large_textures");
   driCalculateMaxTextureLevels( intel->texture_heaps,
				 intel->nr_heaps,
				 &intel->ctx.Const,
				 4,
				 11, /* max 2D texture size is 2048x2048 */
				 8,  /* 3D texture */
				 11, /* cube texture. */
				 11, /* rect texture */
				 12,
				 GL_FALSE,
				 i );
a159 1
   
d161 1
a161 1
   ctx->Const.FragmentProgram.MaxNativeAttribs = 11; /* 8 tex, 2 color, fog */
d165 4
a168 3
   ctx->Const.FragmentProgram.MaxNativeInstructions = (I915_MAX_ALU_INSN + 
						I915_MAX_TEX_INSN);
   ctx->Const.FragmentProgram.MaxNativeTexIndirections = I915_MAX_TEX_INDIRECT;
d171 2
d174 1
a174 1
   driInitExtensions( ctx, i915_extensions, GL_FALSE );
d177 2
a178 2
   _tnl_init_vertices( ctx, ctx->Const.MaxArrayLockSize + 12, 
		       36 * sizeof(GLfloat) );
d182 1
a182 1
   i915InitState( i915 );
a185 1

@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a52 1
    { "GL_ARB_texture_env_crossbar",       NULL },
a167 2
   ctx->_MaintainTexEnvProgram = 1;
   ctx->_UseTexEnvProgram = 1;
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d39 1
a39 2
#include "vbo/vbo.h"

d66 1
a66 1
   _vbo_InvalidateState( ctx, new_state );
d169 2
a170 2
   ctx->FragmentProgram._MaintainTexEnvProgram = GL_TRUE;
   ctx->FragmentProgram._UseTexEnvProgram = GL_TRUE;
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d29 2
a30 2
#include "main/imports.h"
#include "main/macros.h"
d39 1
d41 2
a43 3
#include "i915_program.h"

#include "intel_span.h"
d49 12
d63 1
a63 2
static void
i915InvalidateState(struct gl_context * ctx, GLuint new_state)
d65 6
a70 6
   _swrast_InvalidateState(ctx, new_state);
   _swsetup_InvalidateState(ctx, new_state);
   _vbo_InvalidateState(ctx, new_state);
   _tnl_InvalidateState(ctx, new_state);
   _tnl_invalidate_vertex_state(ctx, new_state);
   intel_context(ctx)->NewGLState |= new_state;
d77 2
a78 2
      struct i915_fragment_program *p =
         (struct i915_fragment_program *) ctx->FragmentProgram._Current;
d80 1
a80 1
         p->params_uptodate = 0;
d83 1
a83 1
   if (new_state & (_NEW_FOG | _NEW_HINT | _NEW_PROGRAM | _NEW_PROGRAM_CONSTANTS))
a84 6
   if (new_state & (_NEW_STENCIL | _NEW_BUFFERS | _NEW_POLYGON))
      i915_update_stencil(ctx);
   if (new_state & (_NEW_LIGHT))
       i915_update_provoking_vertex(ctx);
   if (new_state & (_NEW_PROGRAM | _NEW_PROGRAM_CONSTANTS))
       i915_update_program(ctx);
d88 1
a88 2
static void
i915InitDriverFunctions(struct dd_function_table *functions)
d90 4
a93 3
   intelInitDriverFunctions(functions);
   i915InitStateFunctions(functions);
   i915InitFragProgFuncs(functions);
a97 1
extern const struct tnl_pipeline_stage *intel_pipeline[];
d99 3
a101 5
GLboolean
i915CreateContext(int api,
		  const struct gl_config * mesaVis,
                  __DRIcontext * driContextPriv,
                  void *sharedContextPrivate)
d104 4
a107 4
   struct i915_context *i915 =
      (struct i915_context *) CALLOC_STRUCT(i915_context);
   struct intel_context *intel = &i915->intel;
   struct gl_context *ctx = &intel->ctx;
d109 1
a109 2
   if (!i915)
      return GL_FALSE;
d111 1
a111 1
   i915InitVtbl(i915);
d113 1
a113 1
   i915InitDriverFunctions(&functions);
d115 2
a116 2
   if (!intelInitContext(intel, api, mesaVis, driContextPriv,
                         sharedContextPrivate, &functions)) {
a120 13
   _math_matrix_ctr(&intel->ViewportMatrix);

   /* Initialize swrast, tnl driver tables: */
   intelInitSpanFuncs(ctx);
   intelInitTriFuncs(ctx);

   /* Install the customized pipeline: */
   _tnl_destroy_pipeline(ctx);
   _tnl_install_pipeline(ctx, intel_pipeline);

   if (intel->no_rast)
      FALLBACK(intel, INTEL_FALLBACK_USER, 1);

a123 4
   ctx->Const.MaxVarying = I915_TEX_UNITS;
   ctx->Const.MaxCombinedTextureImageUnits =
      ctx->Const.MaxVertexTextureImageUnits +
      ctx->Const.MaxTextureImageUnits;
d125 15
a139 2
   /* Advertise the full hardware capabilities.  The new memory
    * manager should cope much better with overload situations:
a140 4
   ctx->Const.MaxTextureLevels = 12;
   ctx->Const.Max3DTextureLevels = 9;
   ctx->Const.MaxCubeTextureLevels = 12;
   ctx->Const.MaxTextureRectSize = (1 << 11);
d142 12
a153 2

   ctx->Const.MaxTextureMaxAnisotropy = 4.0;
d160 1
d162 1
a162 1
   ctx->Const.FragmentProgram.MaxNativeAttribs = 11;    /* 8 tex, 2 color, fog */
d166 3
a168 4
   ctx->Const.FragmentProgram.MaxNativeInstructions = (I915_MAX_ALU_INSN +
                                                       I915_MAX_TEX_INSN);
   ctx->Const.FragmentProgram.MaxNativeTexIndirections =
      I915_MAX_TEX_INDIRECT;
a169 18
   ctx->Const.FragmentProgram.MaxEnvParams =
      MIN2(ctx->Const.FragmentProgram.MaxNativeParameters,
	   ctx->Const.FragmentProgram.MaxEnvParams);

   /* i915 stores all values in single-precision floats.  Values aren't set
    * for other program targets because software is used for those targets.
    */
   ctx->Const.FragmentProgram.MediumFloat.RangeMin = 127;
   ctx->Const.FragmentProgram.MediumFloat.RangeMax = 127;
   ctx->Const.FragmentProgram.MediumFloat.Precision = 23;
   ctx->Const.FragmentProgram.LowFloat = ctx->Const.FragmentProgram.HighFloat =
      ctx->Const.FragmentProgram.MediumFloat;
   ctx->Const.FragmentProgram.MediumInt.RangeMin = 24;
   ctx->Const.FragmentProgram.MediumInt.RangeMax = 24;
   ctx->Const.FragmentProgram.MediumInt.Precision = 0;
   ctx->Const.FragmentProgram.LowInt = ctx->Const.FragmentProgram.HighInt =
      ctx->Const.FragmentProgram.MediumInt;

d171 1
a172 4
   /* FINISHME: Are there other options that should be enabled for software
    * FINISHME: vertex shaders?
    */
   ctx->ShaderCompilerOptions[MESA_SHADER_VERTEX].EmitCondCodes = GL_TRUE;
d174 1
a174 10
   struct gl_shader_compiler_options *const fs_options =
      & ctx->ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
   fs_options->EmitNoIfs = GL_TRUE;
   fs_options->EmitNoNoise = GL_TRUE;
   fs_options->EmitNoPow = GL_TRUE;
   fs_options->EmitNoMainReturn = GL_TRUE;
   fs_options->EmitNoIndirectInput = GL_TRUE;
   fs_options->EmitNoIndirectOutput = GL_TRUE;
   fs_options->EmitNoIndirectUniform = GL_TRUE;
   fs_options->EmitNoIndirectTemp = GL_TRUE;
a175 1
   ctx->Const.MaxDrawBuffers = 1;
d177 2
a178 2
   _tnl_init_vertices(ctx, ctx->Const.MaxArrayLockSize + 12,
                      36 * sizeof(GLfloat));
d182 1
a182 1
   i915InitState(i915);
d186 1
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@a28 1
#include "main/api_exec.h"
a30 3
#include "main/version.h"
#include "main/vtxfmt.h"
#include "intel_chipset.h"
a38 1
#include "../glsl/ralloc.h"
d43 2
d72 2
a79 2
   if (new_state & (_NEW_PROGRAM | _NEW_POINT))
       i915_update_sprite_point_enable(ctx);
a91 50
/* Note: this is shared with i830. */
void
intel_init_texture_formats(struct gl_context *ctx)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_screen *intel_screen = intel->intelScreen;

   ctx->TextureFormatSupported[MESA_FORMAT_ARGB8888] = true;
   if (intel_screen->deviceID != PCI_CHIP_I830_M &&
       intel_screen->deviceID != PCI_CHIP_845_G)
      ctx->TextureFormatSupported[MESA_FORMAT_XRGB8888] = true;
   if (intel->gen == 3)
      ctx->TextureFormatSupported[MESA_FORMAT_SARGB8] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_ARGB4444] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_ARGB1555] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_RGB565] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_L8] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_A8] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_I8] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_AL88] = true;

   /* Depth and stencil */
   ctx->TextureFormatSupported[MESA_FORMAT_S8_Z24] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_X8_Z24] = true;

   /*
    * This was disabled in initial FBO enabling to avoid combinations
    * of depth+stencil that wouldn't work together.  We since decided
    * that it was OK, since it's up to the app to come up with the
    * combo that actually works, so this can probably be re-enabled.
    */
   /*
   ctx->TextureFormatSupported[MESA_FORMAT_Z16] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_Z24] = true;
   */

   /* ctx->Extensions.MESA_ycbcr_texture */
   ctx->TextureFormatSupported[MESA_FORMAT_YCBCR] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_YCBCR_REV] = true;

   /* GL_3DFX_texture_compression_FXT1 */
   ctx->TextureFormatSupported[MESA_FORMAT_RGB_FXT1] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_RGBA_FXT1] = true;

   /* GL_EXT_texture_compression_s3tc */
   ctx->TextureFormatSupported[MESA_FORMAT_RGB_DXT1] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_RGBA_DXT1] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_RGBA_DXT3] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_RGBA_DXT5] = true;
}
d95 1
a95 1
bool
a98 3
                  unsigned major_version,
                  unsigned minor_version,
                  unsigned *error,
d102 2
a103 1
   struct i915_context *i915 = rzalloc(NULL, struct i915_context);
d107 2
a108 4
   if (!i915) {
      *error = __DRI_CTX_ERROR_NO_MEMORY;
      return false;
   }
d114 4
a117 6
   if (!intelInitContext(intel, api, major_version, minor_version,
                         mesaVis, driContextPriv,
                         sharedContextPrivate, &functions,
                         error)) {
      ralloc_free(i915);
      return false;
a119 2
   intel_init_texture_formats(ctx);

d123 1
d134 1
a134 1
   ctx->Const.FragmentProgram.MaxTextureImageUnits = I915_TEX_UNITS;
d138 2
a139 2
      ctx->Const.VertexProgram.MaxTextureImageUnits +
      ctx->Const.FragmentProgram.MaxTextureImageUnits;
d185 1
a185 1
   ctx->FragmentProgram._MaintainTexEnvProgram = true;
d190 1
a190 1
   ctx->ShaderCompilerOptions[MESA_SHADER_VERTEX].EmitCondCodes = true;
d194 8
a201 8
   fs_options->MaxIfDepth = 0;
   fs_options->EmitNoNoise = true;
   fs_options->EmitNoPow = true;
   fs_options->EmitNoMainReturn = true;
   fs_options->EmitNoIndirectInput = true;
   fs_options->EmitNoIndirectOutput = true;
   fs_options->EmitNoIndirectUniform = true;
   fs_options->EmitNoIndirectTemp = true;
a203 1
   ctx->Const.QueryCounterBits.SamplesPassed = 0;
d212 1
a212 12
   /* Always enable pixel fog.  Vertex fog using fog coord will conflict
    * with fog code appended onto fragment program.
    */
   _tnl_allow_vertex_fog(ctx, 0);
   _tnl_allow_pixel_fog(ctx, 1);

   _mesa_compute_version(ctx);

   _mesa_initialize_dispatch_tables(ctx);
   _mesa_initialize_vbo_vtxfmt(ctx);

   return true;
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d102 1
a102 1
   ctx->TextureFormatSupported[MESA_FORMAT_B8G8R8A8_UNORM] = true;
d105 1
a105 1
      ctx->TextureFormatSupported[MESA_FORMAT_B8G8R8X8_UNORM] = true;
d107 8
a114 8
      ctx->TextureFormatSupported[MESA_FORMAT_B8G8R8A8_SRGB] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_B4G4R4A4_UNORM] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_B5G5R5A1_UNORM] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_B5G6R5_UNORM] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_L_UNORM8] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_A_UNORM8] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_I_UNORM8] = true;
   ctx->TextureFormatSupported[MESA_FORMAT_L8A8_UNORM] = true;
d117 13
a129 15
   if (intel->gen == 3) {
      ctx->TextureFormatSupported[MESA_FORMAT_Z24_UNORM_S8_UINT] = true;
      ctx->TextureFormatSupported[MESA_FORMAT_Z24_UNORM_X8_UINT] = true;

      /*
       * This was disabled in initial FBO enabling to avoid combinations
       * of depth+stencil that wouldn't work together.  We since decided
       * that it was OK, since it's up to the app to come up with the
       * combo that actually works, so this can probably be re-enabled.
       */
      /*
      ctx->TextureFormatSupported[MESA_FORMAT_Z_UNORM16] = true;
      ctx->TextureFormatSupported[MESA_FORMAT_Z24] = true;
      */
   }
a153 1
                  uint32_t flags,
d171 1
a171 1
   if (!intelInitContext(intel, api, major_version, minor_version, flags,
d194 1
a194 2
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits = I915_TEX_UNITS;
   ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits = I915_TEX_UNITS;
a196 2
   ctx->Const.Program[MESA_SHADER_VERTEX].MaxOutputComponents =
      ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxInputComponents = ctx->Const.MaxVarying * 4;
d198 2
a199 2
      ctx->Const.Program[MESA_SHADER_VERTEX].MaxTextureImageUnits +
      ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits;
d217 6
a222 6
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeTemps = I915_MAX_TEMPORARY;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeAttribs = 11;    /* 8 tex, 2 color, fog */
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeParameters = I915_MAX_CONSTANT;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeAluInstructions = I915_MAX_ALU_INSN;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeTexInstructions = I915_MAX_TEX_INSN;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeInstructions = (I915_MAX_ALU_INSN +
d224 1
a224 1
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeTexIndirections =
d226 4
a229 4
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeAddressRegs = 0; /* I don't think we have one */
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxEnvParams =
      MIN2(ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxNativeParameters,
	   ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxEnvParams);
d234 10
a243 10
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumFloat.RangeMin = 127;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumFloat.RangeMax = 127;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumFloat.Precision = 23;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].LowFloat = ctx->Const.Program[MESA_SHADER_FRAGMENT].HighFloat =
      ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumFloat;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumInt.RangeMin = 24;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumInt.RangeMax = 24;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumInt.Precision = 0;
   ctx->Const.Program[MESA_SHADER_FRAGMENT].LowInt = ctx->Const.Program[MESA_SHADER_FRAGMENT].HighInt =
      ctx->Const.Program[MESA_SHADER_FRAGMENT].MediumInt;
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@d43 1
a43 1
#include "util/ralloc.h"
d112 1
a112 2
   if (intel->gen == 3)
      ctx->TextureFormatSupported[MESA_FORMAT_A_UNORM8] = true;
d256 1
a256 1
   ctx->Const.ShaderCompilerOptions[MESA_SHADER_VERTEX].EmitCondCodes = true;
d259 1
a259 1
      & ctx->Const.ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d43 1
a43 1
#include "../glsl/ralloc.h"
d112 2
a113 1
   ctx->TextureFormatSupported[MESA_FORMAT_A_UNORM8] = true;
d257 1
a257 1
   ctx->ShaderCompilerOptions[MESA_SHADER_VERTEX].EmitCondCodes = true;
d260 1
a260 1
      & ctx->ShaderCompilerOptions[MESA_SHADER_FRAGMENT];
@


