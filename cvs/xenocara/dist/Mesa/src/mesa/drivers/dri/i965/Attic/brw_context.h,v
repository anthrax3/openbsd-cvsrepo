head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.04.17;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.15;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.41;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.41;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.15;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.28.32;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.15.28;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.49;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.11.31;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.48.38;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics to
 develop this 3D driver.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */


#ifndef BRWCONTEXT_INC
#define BRWCONTEXT_INC

#include <stdbool.h>
#include <string.h>
#include "main/imports.h"
#include "main/macros.h"
#include "main/mm.h"
#include "main/mtypes.h"
#include "brw_structs.h"

#ifdef __cplusplus
extern "C" {
	/* Evil hack for using libdrm in a c++ compiler. */
        #define virtual virt
#endif

#include <drm.h>
#include <intel_bufmgr.h>
#include <i915_drm.h>
#ifdef __cplusplus
	#undef virtual
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
#include "intel_debug.h"
#include "intel_screen.h"
#include "intel_tex_obj.h"
#include "intel_resolve_map.h"

/* Glossary:
 *
 * URB - uniform resource buffer.  A mid-sized buffer which is
 * partitioned between the fixed function units and used for passing
 * values (vertices, primitives, constants) between them.
 *
 * CURBE - constant URB entry.  An urb region (entry) used to hold
 * constant values which the fixed function units can be instructed to
 * preload into the GRF when spawning a thread.
 *
 * VUE - vertex URB entry.  An urb entry holding a vertex and usually
 * a vertex header.  The header contains control information and
 * things like primitive type, Begin/end flags and clip codes.
 *
 * PUE - primitive URB entry.  An urb entry produced by the setup (SF)
 * unit holding rasterization and interpolation parameters.
 *
 * GRF - general register file.  One of several register files
 * addressable by programmed threads.  The inputs (r0, payload, curbe,
 * urb) of the thread are preloaded to this area before the thread is
 * spawned.  The registers are individually 8 dwords wide and suitable
 * for general usage.  Registers holding thread input values are not
 * special and may be overwritten.
 *
 * MRF - message register file.  Threads communicate (and terminate)
 * by sending messages.  Message parameters are placed in contiguous
 * MRF registers.  All program output is via these messages.  URB
 * entries are populated by sending a message to the shared URB
 * function containing the new data, together with a control word,
 * often an unmodified copy of R0.
 *
 * R0 - GRF register 0.  Typically holds control information used when
 * sending messages to other threads.
 *
 * EU or GEN4 EU: The name of the programmable subsystem of the
 * i965 hardware.  Threads are executed by the EU, the registers
 * described above are part of the EU architecture.
 *
 * Fixed function units:
 *
 * CS - Command streamer.  Notional first unit, little software
 * interaction.  Holds the URB entries used for constant data, ie the
 * CURBEs.
 *
 * VF/VS - Vertex Fetch / Vertex Shader.  The fixed function part of
 * this unit is responsible for pulling vertices out of vertex buffers
 * in vram and injecting them into the processing pipe as VUEs.  If
 * enabled, it first passes them to a VS thread which is a good place
 * for the driver to implement any active vertex shader.
 *
 * GS - Geometry Shader.  This corresponds to a new DX10 concept.  If
 * enabled, incoming strips etc are passed to GS threads in individual
 * line/triangle/point units.  The GS thread may perform arbitary
 * computation and emit whatever primtives with whatever vertices it
 * chooses.  This makes GS an excellent place to implement GL's
 * unfilled polygon modes, though of course it is capable of much
 * more.  Additionally, GS is used to translate away primitives not
 * handled by latter units, including Quads and Lineloops.
 *
 * CS - Clipper.  Mesa's clipping algorithms are imported to run on
 * this unit.  The fixed function part performs cliptesting against
 * the 6 fixed clipplanes and makes descisions on whether or not the
 * incoming primitive needs to be passed to a thread for clipping.
 * User clip planes are handled via cooperation with the VS thread.
 *
 * SF - Strips Fans or Setup: Triangles are prepared for
 * rasterization.  Interpolation coefficients are calculated.
 * Flatshading and two-side lighting usually performed here.
 *
 * WM - Windower.  Interpolation of vertex attributes performed here.
 * Fragment shader implemented here.  SIMD aspects of EU taken full
 * advantage of, as pixels are processed in blocks of 16.
 *
 * CC - Color Calculator.  No EU threads associated with this unit.
 * Handles blending and (presumably) depth and stencil testing.
 */

#define BRW_MAX_CURBE                    (32*16)

struct brw_context;
struct brw_instruction;
struct brw_vs_prog_key;
struct brw_vec4_prog_key;
struct brw_wm_prog_key;
struct brw_wm_prog_data;

enum brw_state_id {
   BRW_STATE_URB_FENCE,
   BRW_STATE_FRAGMENT_PROGRAM,
   BRW_STATE_GEOMETRY_PROGRAM,
   BRW_STATE_VERTEX_PROGRAM,
   BRW_STATE_CURBE_OFFSETS,
   BRW_STATE_REDUCED_PRIMITIVE,
   BRW_STATE_PRIMITIVE,
   BRW_STATE_CONTEXT,
   BRW_STATE_PSP,
   BRW_STATE_SURFACES,
   BRW_STATE_VS_BINDING_TABLE,
   BRW_STATE_GS_BINDING_TABLE,
   BRW_STATE_PS_BINDING_TABLE,
   BRW_STATE_INDICES,
   BRW_STATE_VERTICES,
   BRW_STATE_BATCH,
   BRW_STATE_INDEX_BUFFER,
   BRW_STATE_VS_CONSTBUF,
   BRW_STATE_GS_CONSTBUF,
   BRW_STATE_PROGRAM_CACHE,
   BRW_STATE_STATE_BASE_ADDRESS,
   BRW_STATE_VUE_MAP_VS,
   BRW_STATE_VUE_MAP_GEOM_OUT,
   BRW_STATE_TRANSFORM_FEEDBACK,
   BRW_STATE_RASTERIZER_DISCARD,
   BRW_STATE_STATS_WM,
   BRW_STATE_UNIFORM_BUFFER,
   BRW_STATE_ATOMIC_BUFFER,
   BRW_STATE_META_IN_PROGRESS,
   BRW_STATE_INTERPOLATION_MAP,
   BRW_STATE_PUSH_CONSTANT_ALLOCATION,
   BRW_STATE_NUM_SAMPLES,
   BRW_NUM_STATE_BITS
};

#define BRW_NEW_URB_FENCE               (1 << BRW_STATE_URB_FENCE)
#define BRW_NEW_FRAGMENT_PROGRAM        (1 << BRW_STATE_FRAGMENT_PROGRAM)
#define BRW_NEW_GEOMETRY_PROGRAM        (1 << BRW_STATE_GEOMETRY_PROGRAM)
#define BRW_NEW_VERTEX_PROGRAM          (1 << BRW_STATE_VERTEX_PROGRAM)
#define BRW_NEW_CURBE_OFFSETS           (1 << BRW_STATE_CURBE_OFFSETS)
#define BRW_NEW_REDUCED_PRIMITIVE       (1 << BRW_STATE_REDUCED_PRIMITIVE)
#define BRW_NEW_PRIMITIVE               (1 << BRW_STATE_PRIMITIVE)
#define BRW_NEW_CONTEXT                 (1 << BRW_STATE_CONTEXT)
#define BRW_NEW_PSP                     (1 << BRW_STATE_PSP)
#define BRW_NEW_SURFACES		(1 << BRW_STATE_SURFACES)
#define BRW_NEW_VS_BINDING_TABLE	(1 << BRW_STATE_VS_BINDING_TABLE)
#define BRW_NEW_GS_BINDING_TABLE	(1 << BRW_STATE_GS_BINDING_TABLE)
#define BRW_NEW_PS_BINDING_TABLE	(1 << BRW_STATE_PS_BINDING_TABLE)
#define BRW_NEW_INDICES			(1 << BRW_STATE_INDICES)
#define BRW_NEW_VERTICES		(1 << BRW_STATE_VERTICES)
/**
 * Used for any batch entry with a relocated pointer that will be used
 * by any 3D rendering.
 */
#define BRW_NEW_BATCH                  (1 << BRW_STATE_BATCH)
/** \see brw.state.depth_region */
#define BRW_NEW_INDEX_BUFFER           (1 << BRW_STATE_INDEX_BUFFER)
#define BRW_NEW_VS_CONSTBUF            (1 << BRW_STATE_VS_CONSTBUF)
#define BRW_NEW_GS_CONSTBUF            (1 << BRW_STATE_GS_CONSTBUF)
#define BRW_NEW_PROGRAM_CACHE		(1 << BRW_STATE_PROGRAM_CACHE)
#define BRW_NEW_STATE_BASE_ADDRESS	(1 << BRW_STATE_STATE_BASE_ADDRESS)
#define BRW_NEW_VUE_MAP_VS		(1 << BRW_STATE_VUE_MAP_VS)
#define BRW_NEW_VUE_MAP_GEOM_OUT	(1 << BRW_STATE_VUE_MAP_GEOM_OUT)
#define BRW_NEW_TRANSFORM_FEEDBACK	(1 << BRW_STATE_TRANSFORM_FEEDBACK)
#define BRW_NEW_RASTERIZER_DISCARD	(1 << BRW_STATE_RASTERIZER_DISCARD)
#define BRW_NEW_STATS_WM		(1 << BRW_STATE_STATS_WM)
#define BRW_NEW_UNIFORM_BUFFER          (1 << BRW_STATE_UNIFORM_BUFFER)
#define BRW_NEW_ATOMIC_BUFFER           (1 << BRW_STATE_ATOMIC_BUFFER)
#define BRW_NEW_META_IN_PROGRESS        (1 << BRW_STATE_META_IN_PROGRESS)
#define BRW_NEW_INTERPOLATION_MAP       (1 << BRW_STATE_INTERPOLATION_MAP)
#define BRW_NEW_PUSH_CONSTANT_ALLOCATION (1 << BRW_STATE_PUSH_CONSTANT_ALLOCATION)
#define BRW_NEW_NUM_SAMPLES             (1 << BRW_STATE_NUM_SAMPLES)

struct brw_state_flags {
   /** State update flags signalled by mesa internals */
   GLuint mesa;
   /**
    * State update flags signalled as the result of brw_tracked_state updates
    */
   GLuint brw;
   /** State update flags signalled by brw_state_cache.c searches */
   GLuint cache;
};

#define AUB_TRACE_TYPE_MASK		0x0000ff00
#define AUB_TRACE_TYPE_NOTYPE		(0 << 8)
#define AUB_TRACE_TYPE_BATCH		(1 << 8)
#define AUB_TRACE_TYPE_VERTEX_BUFFER	(5 << 8)
#define AUB_TRACE_TYPE_2D_MAP		(6 << 8)
#define AUB_TRACE_TYPE_CUBE_MAP		(7 << 8)
#define AUB_TRACE_TYPE_VOLUME_MAP	(9 << 8)
#define AUB_TRACE_TYPE_1D_MAP		(10 << 8)
#define AUB_TRACE_TYPE_CONSTANT_BUFFER	(11 << 8)
#define AUB_TRACE_TYPE_CONSTANT_URB	(12 << 8)
#define AUB_TRACE_TYPE_INDEX_BUFFER	(13 << 8)
#define AUB_TRACE_TYPE_GENERAL		(14 << 8)
#define AUB_TRACE_TYPE_SURFACE		(15 << 8)

/**
 * state_struct_type enum values are encoded with the top 16 bits representing
 * the type to be delivered to the .aub file, and the bottom 16 bits
 * representing the subtype.  This macro performs the encoding.
 */
#define ENCODE_SS_TYPE(type, subtype) (((type) << 16) | (subtype))

enum state_struct_type {
   AUB_TRACE_VS_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 1),
   AUB_TRACE_GS_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 2),
   AUB_TRACE_CLIP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 3),
   AUB_TRACE_SF_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 4),
   AUB_TRACE_WM_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 5),
   AUB_TRACE_CC_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 6),
   AUB_TRACE_CLIP_VP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 7),
   AUB_TRACE_SF_VP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 8),
   AUB_TRACE_CC_VP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x9),
   AUB_TRACE_SAMPLER_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xa),
   AUB_TRACE_KERNEL_INSTRUCTIONS =	ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xb),
   AUB_TRACE_SCRATCH_SPACE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xc),
   AUB_TRACE_SAMPLER_DEFAULT_COLOR =    ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xd),

   AUB_TRACE_SCISSOR_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x15),
   AUB_TRACE_BLEND_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x16),
   AUB_TRACE_DEPTH_STENCIL_STATE =	ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x17),

   AUB_TRACE_VERTEX_BUFFER =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_VERTEX_BUFFER, 0),
   AUB_TRACE_BINDING_TABLE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_SURFACE, 0x100),
   AUB_TRACE_SURFACE_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_SURFACE, 0x200),
   AUB_TRACE_VS_CONSTANTS =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_CONSTANT_BUFFER, 0),
   AUB_TRACE_WM_CONSTANTS =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_CONSTANT_BUFFER, 1),
};

/**
 * Decode a state_struct_type value to determine the type that should be
 * stored in the .aub file.
 */
static inline uint32_t AUB_TRACE_TYPE(enum state_struct_type ss_type)
{
   return (ss_type & 0xFFFF0000) >> 16;
}

/**
 * Decode a state_struct_type value to determine the subtype that should be
 * stored in the .aub file.
 */
static inline uint32_t AUB_TRACE_SUBTYPE(enum state_struct_type ss_type)
{
   return ss_type & 0xFFFF;
}

/** Subclass of Mesa vertex program */
struct brw_vertex_program {
   struct gl_vertex_program program;
   GLuint id;
};


/** Subclass of Mesa geometry program */
struct brw_geometry_program {
   struct gl_geometry_program program;
   unsigned id;  /**< serial no. to identify geom progs, never re-used */
};


/** Subclass of Mesa fragment program */
struct brw_fragment_program {
   struct gl_fragment_program program;
   GLuint id;  /**< serial no. to identify frag progs, never re-used */
};


/** Subclass of Mesa compute program */
struct brw_compute_program {
   struct gl_compute_program program;
   unsigned id;  /**< serial no. to identify compute progs, never re-used */
};


struct brw_shader {
   struct gl_shader base;

   bool compiled_once;
};

/* Note: If adding fields that need anything besides a normal memcmp() for
 * comparing them, be sure to go fix brw_stage_prog_data_compare().
 */
struct brw_stage_prog_data {
   struct {
      /** size of our binding table. */
      uint32_t size_bytes;

      /** @@{
       * surface indices for the various groups of surfaces
       */
      uint32_t pull_constants_start;
      uint32_t texture_start;
      uint32_t gather_texture_start;
      uint32_t ubo_start;
      uint32_t abo_start;
      uint32_t shader_time_start;
      /** @@} */
   } binding_table;

   GLuint nr_params;       /**< number of float params/constants */
   GLuint nr_pull_params;

   /* Pointers to tracked values (only valid once
    * _mesa_load_state_parameters has been called at runtime).
    *
    * These must be the last fields of the struct (see
    * brw_stage_prog_data_compare()).
    */
   const float **param;
   const float **pull_param;
};

/* Data about a particular attempt to compile a program.  Note that
 * there can be many of these, each in a different GL state
 * corresponding to a different brw_wm_prog_key struct, with different
 * compiled programs.
 *
 * Note: brw_wm_prog_data_compare() must be updated when adding fields to this
 * struct!
 */
struct brw_wm_prog_data {
   struct brw_stage_prog_data base;

   GLuint curb_read_length;
   GLuint num_varying_inputs;

   GLuint first_curbe_grf;
   GLuint first_curbe_grf_16;
   GLuint reg_blocks;
   GLuint reg_blocks_16;
   GLuint total_scratch;

   struct {
      /** @@{
       * surface indices the WM-specific surfaces
       */
      uint32_t render_target_start;
      /** @@} */
   } binding_table;

   bool dual_src_blend;
   bool uses_pos_offset;
   bool uses_omask;
   uint32_t prog_offset_16;

   /**
    * Mask of which interpolation modes are required by the fragment shader.
    * Used in hardware setup on gen6+.
    */
   uint32_t barycentric_interp_modes;

   /**
    * Map from gl_varying_slot to the position within the FS setup data
    * payload where the varying's attribute vertex deltas should be delivered.
    * For varying slots that are not used by the FS, the value is -1.
    */
   int urb_setup[VARYING_SLOT_MAX];
};

/**
 * Enum representing the i965-specific vertex results that don't correspond
 * exactly to any element of gl_varying_slot.  The values of this enum are
 * assigned such that they don't conflict with gl_varying_slot.
 */
typedef enum
{
   BRW_VARYING_SLOT_NDC = VARYING_SLOT_MAX,
   BRW_VARYING_SLOT_PAD,
   /**
    * Technically this is not a varying but just a placeholder that
    * compile_sf_prog() inserts into its VUE map to cause the gl_PointCoord
    * builtin variable to be compiled correctly. see compile_sf_prog() for
    * more info.
    */
   BRW_VARYING_SLOT_PNTC,
   BRW_VARYING_SLOT_COUNT
} brw_varying_slot;


/**
 * Data structure recording the relationship between the gl_varying_slot enum
 * and "slots" within the vertex URB entry (VUE).  A "slot" is defined as a
 * single octaword within the VUE (128 bits).
 *
 * Note that each BRW register contains 256 bits (2 octawords), so when
 * accessing the VUE in URB_NOSWIZZLE mode, each register corresponds to two
 * consecutive VUE slots.  When accessing the VUE in URB_INTERLEAVED mode (as
 * in a vertex shader), each register corresponds to a single VUE slot, since
 * it contains data for two separate vertices.
 */
struct brw_vue_map {
   /**
    * Bitfield representing all varying slots that are (a) stored in this VUE
    * map, and (b) actually written by the shader.  Does not include any of
    * the additional varying slots defined in brw_varying_slot.
    */
   GLbitfield64 slots_valid;

   /**
    * Map from gl_varying_slot value to VUE slot.  For gl_varying_slots that are
    * not stored in a slot (because they are not written, or because
    * additional processing is applied before storing them in the VUE), the
    * value is -1.
    */
   signed char varying_to_slot[BRW_VARYING_SLOT_COUNT];

   /**
    * Map from VUE slot to gl_varying_slot value.  For slots that do not
    * directly correspond to a gl_varying_slot, the value comes from
    * brw_varying_slot.
    *
    * For slots that are not in use, the value is BRW_VARYING_SLOT_COUNT (this
    * simplifies code that uses the value stored in slot_to_varying to
    * create a bit mask).
    */
   signed char slot_to_varying[BRW_VARYING_SLOT_COUNT];

   /**
    * Total number of VUE slots in use
    */
   int num_slots;
};

/**
 * Convert a VUE slot number into a byte offset within the VUE.
 */
static inline GLuint brw_vue_slot_to_offset(GLuint slot)
{
   return 16*slot;
}

/**
 * Convert a vertex output (brw_varying_slot) into a byte offset within the
 * VUE.
 */
static inline GLuint brw_varying_to_offset(struct brw_vue_map *vue_map,
                                           GLuint varying)
{
   return brw_vue_slot_to_offset(vue_map->varying_to_slot[varying]);
}

void brw_compute_vue_map(struct brw_context *brw, struct brw_vue_map *vue_map,
                         GLbitfield64 slots_valid);


/**
 * Bitmask indicating which fragment shader inputs represent varyings (and
 * hence have to be delivered to the fragment shader by the SF/SBE stage).
 */
#define BRW_FS_VARYING_INPUT_MASK \
   (BITFIELD64_RANGE(0, VARYING_SLOT_MAX) & \
    ~VARYING_BIT_POS & ~VARYING_BIT_FACE)


/*
 * Mapping of VUE map slots to interpolation modes.
 */
struct interpolation_mode_map {
   unsigned char mode[BRW_VARYING_SLOT_COUNT];
};

static inline bool brw_any_flat_varyings(struct interpolation_mode_map *map)
{
   for (int i = 0; i < BRW_VARYING_SLOT_COUNT; i++)
      if (map->mode[i] == INTERP_QUALIFIER_FLAT)
         return true;

   return false;
}

static inline bool brw_any_noperspective_varyings(struct interpolation_mode_map *map)
{
   for (int i = 0; i < BRW_VARYING_SLOT_COUNT; i++)
      if (map->mode[i] == INTERP_QUALIFIER_NOPERSPECTIVE)
         return true;

   return false;
}


struct brw_sf_prog_data {
   GLuint urb_read_length;
   GLuint total_grf;

   /* Each vertex may have upto 12 attributes, 4 components each,
    * except WPOS which requires only 2.  (11*4 + 2) == 44 ==> 11
    * rows.
    *
    * Actually we use 4 for each, so call it 12 rows.
    */
   GLuint urb_entry_size;
};


/**
 * We always program SF to start reading at an offset of 1 (2 varying slots)
 * from the start of the vertex URB entry.  This causes it to skip:
 * - VARYING_SLOT_PSIZ and BRW_VARYING_SLOT_NDC on gen4-5
 * - VARYING_SLOT_PSIZ and VARYING_SLOT_POS on gen6+
 */
#define BRW_SF_URB_ENTRY_READ_OFFSET 1


struct brw_clip_prog_data {
   GLuint curb_read_length;	/* user planes? */
   GLuint clip_mode;
   GLuint urb_read_length;
   GLuint total_grf;
};

struct brw_ff_gs_prog_data {
   GLuint urb_read_length;
   GLuint total_grf;

   /**
    * Gen6 transform feedback: Amount by which the streaming vertex buffer
    * indices should be incremented each time the GS is invoked.
    */
   unsigned svbi_postincrement_value;
};


/* Note: brw_vec4_prog_data_compare() must be updated when adding fields to
 * this struct!
 */
struct brw_vec4_prog_data {
   struct brw_stage_prog_data base;
   struct brw_vue_map vue_map;

   /**
    * Register where the thread expects to find input data from the URB
    * (typically uniforms, followed by per-vertex inputs).
    */
   unsigned dispatch_grf_start_reg;

   GLuint curb_read_length;
   GLuint urb_read_length;
   GLuint total_grf;
   GLuint total_scratch;

   /* Used for calculating urb partitions.  In the VS, this is the size of the
    * URB entry used for both input and output to the thread.  In the GS, this
    * is the size of the URB entry used for output.
    */
   GLuint urb_entry_size;
};


/* Note: brw_vs_prog_data_compare() must be updated when adding fields to this
 * struct!
 */
struct brw_vs_prog_data {
   struct brw_vec4_prog_data base;

   GLbitfield64 inputs_read;

   bool uses_vertexid;
};


/* Note: brw_gs_prog_data_compare() must be updated when adding fields to
 * this struct!
 */
struct brw_gs_prog_data
{
   struct brw_vec4_prog_data base;

   /**
    * Size of an output vertex, measured in HWORDS (32 bytes).
    */
   unsigned output_vertex_size_hwords;

   unsigned output_topology;

   /**
    * Size of the control data (cut bits or StreamID bits), in hwords (32
    * bytes).  0 if there is no control data.
    */
   unsigned control_data_header_size_hwords;

   /**
    * Format of the control data (either GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_SID
    * if the control data is StreamID bits, or
    * GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_CUT if the control data is cut bits).
    * Ignored if control_data_header_size is 0.
    */
   unsigned control_data_format;

   bool include_primitive_id;

   int invocations;

   /**
    * True if the thread should be dispatched in DUAL_INSTANCE mode, false if
    * it should be dispatched in DUAL_OBJECT mode.
    */
   bool dual_instanced_dispatch;
};

/** Number of texture sampler units */
#define BRW_MAX_TEX_UNIT 32

/** Max number of render targets in a shader */
#define BRW_MAX_DRAW_BUFFERS 8

/** Max number of atomic counter buffer objects in a shader */
#define BRW_MAX_ABO 16

/**
 * Max number of binding table entries used for stream output.
 *
 * From the OpenGL 3.0 spec, table 6.44 (Transform Feedback State), the
 * minimum value of MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS is 64.
 *
 * On Gen6, the size of transform feedback data is limited not by the number
 * of components but by the number of binding table entries we set aside.  We
 * use one binding table entry for a float, one entry for a vector, and one
 * entry per matrix column.  Since the only way we can communicate our
 * transform feedback capabilities to the client is via
 * MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS, we need to plan for the
 * worst case, in which all the varyings are floats, so we use up one binding
 * table entry per component.  Therefore we need to set aside at least 64
 * binding table entries for use by transform feedback.
 *
 * Note: since we don't currently pack varyings, it is currently impossible
 * for the client to actually use up all of these binding table entries--if
 * all of their varyings were floats, they would run out of varying slots and
 * fail to link.  But that's a bug, so it seems prudent to go ahead and
 * allocate the number of binding table entries we will need once the bug is
 * fixed.
 */
#define BRW_MAX_SOL_BINDINGS 64

/** Maximum number of actual buffers used for stream output */
#define BRW_MAX_SOL_BUFFERS 4

#define BRW_MAX_SURFACES   (BRW_MAX_DRAW_BUFFERS +                      \
                            BRW_MAX_TEX_UNIT * 2 + /* normal, gather */ \
                            12 + /* ubo */                              \
                            BRW_MAX_ABO +                               \
                            2 /* shader time, pull constants */)

#define SURF_INDEX_GEN6_SOL_BINDING(t) (t)
#define BRW_MAX_GEN6_GS_SURFACES       SURF_INDEX_GEN6_SOL_BINDING(BRW_MAX_SOL_BINDINGS)

/**
 * Stride in bytes between shader_time entries.
 *
 * We separate entries by a cacheline to reduce traffic between EUs writing to
 * different entries.
 */
#define SHADER_TIME_STRIDE 64

enum brw_cache_id {
   BRW_CC_VP,
   BRW_CC_UNIT,
   BRW_WM_PROG,
   BRW_BLORP_BLIT_PROG,
   BRW_BLORP_CONST_COLOR_PROG,
   BRW_SAMPLER,
   BRW_WM_UNIT,
   BRW_SF_PROG,
   BRW_SF_VP,
   BRW_SF_UNIT, /* scissor state on gen6 */
   BRW_VS_UNIT,
   BRW_VS_PROG,
   BRW_FF_GS_UNIT,
   BRW_FF_GS_PROG,
   BRW_GS_PROG,
   BRW_CLIP_VP,
   BRW_CLIP_UNIT,
   BRW_CLIP_PROG,

   BRW_MAX_CACHE
};

struct brw_cache_item {
   /**
    * Effectively part of the key, cache_id identifies what kind of state
    * buffer is involved, and also which brw->state.dirty.cache flag should
    * be set when this cache item is chosen.
    */
   enum brw_cache_id cache_id;
   /** 32-bit hash of the key data */
   GLuint hash;
   GLuint key_size;		/* for variable-sized keys */
   GLuint aux_size;
   const void *key;

   uint32_t offset;
   uint32_t size;

   struct brw_cache_item *next;
};


typedef bool (*cache_aux_compare_func)(const void *a, const void *b);
typedef void (*cache_aux_free_func)(const void *aux);

struct brw_cache {
   struct brw_context *brw;

   struct brw_cache_item **items;
   drm_intel_bo *bo;
   GLuint size, n_items;

   uint32_t next_offset;
   bool bo_used_by_gpu;

   /**
    * Optional functions used in determining whether the prog_data for a new
    * cache item matches an existing cache item (in case there's relevant data
    * outside of the prog_data).  If NULL, a plain memcmp is done.
    */
   cache_aux_compare_func aux_compare[BRW_MAX_CACHE];
   /** Optional functions for freeing other pointers attached to a prog_data. */
   cache_aux_free_func aux_free[BRW_MAX_CACHE];
};


/* Considered adding a member to this struct to document which flags
 * an update might raise so that ordering of the state atoms can be
 * checked or derived at runtime.  Dropped the idea in favor of having
 * a debug mode where the state is monitored for flags which are
 * raised that have already been tested against.
 */
struct brw_tracked_state {
   struct brw_state_flags dirty;
   void (*emit)( struct brw_context *brw );
};

enum shader_time_shader_type {
   ST_NONE,
   ST_VS,
   ST_VS_WRITTEN,
   ST_VS_RESET,
   ST_GS,
   ST_GS_WRITTEN,
   ST_GS_RESET,
   ST_FS8,
   ST_FS8_WRITTEN,
   ST_FS8_RESET,
   ST_FS16,
   ST_FS16_WRITTEN,
   ST_FS16_RESET,
};

/* Flags for brw->state.cache.
 */
#define CACHE_NEW_CC_VP                  (1<<BRW_CC_VP)
#define CACHE_NEW_CC_UNIT                (1<<BRW_CC_UNIT)
#define CACHE_NEW_WM_PROG                (1<<BRW_WM_PROG)
#define CACHE_NEW_BLORP_BLIT_PROG        (1<<BRW_BLORP_BLIT_PROG)
#define CACHE_NEW_BLORP_CONST_COLOR_PROG (1<<BRW_BLORP_CONST_COLOR_PROG)
#define CACHE_NEW_SAMPLER                (1<<BRW_SAMPLER)
#define CACHE_NEW_WM_UNIT                (1<<BRW_WM_UNIT)
#define CACHE_NEW_SF_PROG                (1<<BRW_SF_PROG)
#define CACHE_NEW_SF_VP                  (1<<BRW_SF_VP)
#define CACHE_NEW_SF_UNIT                (1<<BRW_SF_UNIT)
#define CACHE_NEW_VS_UNIT                (1<<BRW_VS_UNIT)
#define CACHE_NEW_VS_PROG                (1<<BRW_VS_PROG)
#define CACHE_NEW_FF_GS_UNIT             (1<<BRW_FF_GS_UNIT)
#define CACHE_NEW_FF_GS_PROG             (1<<BRW_FF_GS_PROG)
#define CACHE_NEW_GS_PROG                (1<<BRW_GS_PROG)
#define CACHE_NEW_CLIP_VP                (1<<BRW_CLIP_VP)
#define CACHE_NEW_CLIP_UNIT              (1<<BRW_CLIP_UNIT)
#define CACHE_NEW_CLIP_PROG              (1<<BRW_CLIP_PROG)

struct brw_vertex_buffer {
   /** Buffer object containing the uploaded vertex data */
   drm_intel_bo *bo;
   uint32_t offset;
   /** Byte stride between elements in the uploaded array */
   GLuint stride;
   GLuint step_rate;
};
struct brw_vertex_element {
   const struct gl_client_array *glarray;

   int buffer;

   /** Offset of the first element within the buffer object */
   unsigned int offset;
};

struct brw_query_object {
   struct gl_query_object Base;

   /** Last query BO associated with this query. */
   drm_intel_bo *bo;

   /** Last index in bo with query data for this object. */
   int last_index;
};

struct intel_sync_object {
   struct gl_sync_object Base;

   /** Batch associated with this sync object */
   drm_intel_bo *bo;
};

enum brw_gpu_ring {
   UNKNOWN_RING,
   RENDER_RING,
   BLT_RING,
};

struct intel_batchbuffer {
   /** Current batchbuffer being queued up. */
   drm_intel_bo *bo;
   /** Last BO submitted to the hardware.  Used for glFinish(). */
   drm_intel_bo *last_bo;
   /** BO for post-sync nonzero writes for gen6 workaround. */
   drm_intel_bo *workaround_bo;
   bool need_workaround_flush;

   uint16_t emit, total;
   uint16_t used, reserved_space;
   uint32_t *map;
   uint32_t *cpu_map;
#define BATCH_SZ (8192*sizeof(uint32_t))

   uint32_t state_batch_offset;
   enum brw_gpu_ring ring;
   bool needs_sol_reset;

   struct {
      uint16_t used;
      int reloc_count;
   } saved;
};

#define BRW_MAX_XFB_STREAMS 4

struct brw_transform_feedback_object {
   struct gl_transform_feedback_object base;

   /** A buffer to hold SO_WRITE_OFFSET(n) values while paused. */
   drm_intel_bo *offset_bo;

   /** If true, SO_WRITE_OFFSET(n) should be reset to zero at next use. */
   bool zero_offsets;

   /** The most recent primitive mode (GL_TRIANGLES/GL_POINTS/GL_LINES). */
   GLenum primitive_mode;

   /**
    * Count of primitives generated during this transform feedback operation.
    *  @@{
    */
   uint64_t prims_generated[BRW_MAX_XFB_STREAMS];
   drm_intel_bo *prim_count_bo;
   unsigned prim_count_buffer_index; /**< in number of uint64_t units */
   /** @@} */

   /**
    * Number of vertices written between last Begin/EndTransformFeedback().
    *
    * Used to implement DrawTransformFeedback().
    */
   uint64_t vertices_written[BRW_MAX_XFB_STREAMS];
   bool vertices_written_valid;
};

/**
 * Data shared between each programmable stage in the pipeline (vs, gs, and
 * wm).
 */
struct brw_stage_state
{
   gl_shader_stage stage;
   struct brw_stage_prog_data *prog_data;

   /**
    * Optional scratch buffer used to store spilled register values and
    * variably-indexed GRF arrays.
    */
   drm_intel_bo *scratch_bo;

   /** Offset in the program cache to the program */
   uint32_t prog_offset;

   /** Offset in the batchbuffer to Gen4-5 pipelined state (VS/WM/GS_STATE). */
   uint32_t state_offset;

   uint32_t push_const_offset; /* Offset in the batchbuffer */
   int push_const_size; /* in 256-bit register increments */

   /* Binding table: pointers to SURFACE_STATE entries. */
   uint32_t bind_bo_offset;
   uint32_t surf_offset[BRW_MAX_SURFACES];

   /** SAMPLER_STATE count and table offset */
   uint32_t sampler_count;
   uint32_t sampler_offset;

   /** Offsets in the batch to sampler default colors (texture border color) */
   uint32_t sdc_offset[BRW_MAX_TEX_UNIT];
};


/**
 * brw_context is derived from gl_context.
 */
struct brw_context
{
   struct gl_context ctx; /**< base class, must be first field */

   struct
   {
      void (*update_texture_surface)(struct gl_context *ctx,
                                     unsigned unit,
                                     uint32_t *surf_offset,
                                     bool for_gather);
      void (*update_renderbuffer_surface)(struct brw_context *brw,
					  struct gl_renderbuffer *rb,
					  bool layered,
					  unsigned unit);
      void (*update_null_renderbuffer_surface)(struct brw_context *brw,
					       unsigned unit);

      void (*create_raw_surface)(struct brw_context *brw,
                                 drm_intel_bo *bo,
                                 uint32_t offset,
                                 uint32_t size,
                                 uint32_t *out_offset,
                                 bool rw);
      void (*emit_buffer_surface_state)(struct brw_context *brw,
                                        uint32_t *out_offset,
                                        drm_intel_bo *bo,
                                        unsigned buffer_offset,
                                        unsigned surface_format,
                                        unsigned buffer_size,
                                        unsigned pitch,
                                        unsigned mocs,
                                        bool rw);

      /** Upload a SAMPLER_STATE table. */
      void (*upload_sampler_state_table)(struct brw_context *brw,
                                         struct gl_program *prog,
                                         struct brw_stage_state *stage_state);

      /**
       * Send the appropriate state packets to configure depth, stencil, and
       * HiZ buffers (i965+ only)
       */
      void (*emit_depth_stencil_hiz)(struct brw_context *brw,
                                     struct intel_mipmap_tree *depth_mt,
                                     uint32_t depth_offset,
                                     uint32_t depthbuffer_format,
                                     uint32_t depth_surface_type,
                                     struct intel_mipmap_tree *stencil_mt,
                                     bool hiz, bool separate_stencil,
                                     uint32_t width, uint32_t height,
                                     uint32_t tile_x, uint32_t tile_y);

   } vtbl;

   dri_bufmgr *bufmgr;

   drm_intel_context *hw_ctx;

   /**
    * Set of drm_intel_bo * that have been rendered to within this batchbuffer
    * and would need flushing before being used from another cache domain that
    * isn't coherent with it (i.e. the sampler).
    */
   struct set *render_cache;

   /**
    * Number of resets observed in the system at context creation.
    *
    * This is tracked in the context so that we can determine that another
    * reset has occured.
    */
   uint32_t reset_count;

   struct intel_batchbuffer batch;
   bool no_batch_wrap;

   struct {
      drm_intel_bo *bo;
      uint32_t next_offset;
   } upload;

   /**
    * Set if rendering has occured to the drawable's front buffer.
    *
    * This is used in the DRI2 case to detect that glFlush should also copy
    * the contents of the fake front buffer to the real front buffer.
    */
   bool front_buffer_dirty;

   /** Framerate throttling: @@{ */
   drm_intel_bo *first_post_swapbuffers_batch;
   bool need_throttle;
   /** @@} */

   GLuint stats_wm;

   /**
    * drirc options:
    * @@{
    */
   bool no_rast;
   bool always_flush_batch;
   bool always_flush_cache;
   bool disable_throttling;
   bool precompile;
   bool disable_derivative_optimization;

   driOptionCache optionCache;
   /** @@} */

   GLuint primitive; /**< Hardware primitive, such as _3DPRIM_TRILIST. */

   GLenum reduced_primitive;

   /**
    * Set if we're either a debug context or the INTEL_DEBUG=perf environment
    * variable is set, this is the flag indicating to do expensive work that
    * might lead to a perf_debug() call.
    */
   bool perf_debug;

   uint32_t max_gtt_map_object_size;

   int gen;
   int gt;

   bool is_g4x;
   bool is_baytrail;
   bool is_haswell;

   bool has_hiz;
   bool has_separate_stencil;
   bool must_use_separate_stencil;
   bool has_llc;
   bool has_swizzling;
   bool has_surface_tile_offset;
   bool has_compr4;
   bool has_negative_rhw_bug;
   bool has_pln;

   /**
    * Some versions of Gen hardware don't do centroid interpolation correctly
    * on unlit pixels, causing incorrect values for derivatives near triangle
    * edges.  Enabling this flag causes the fragment shader to use
    * non-centroid interpolation for unlit pixels, at the expense of two extra
    * fragment shader instructions.
    */
   bool needs_unlit_centroid_workaround;

   GLuint NewGLState;
   struct {
      struct brw_state_flags dirty;
   } state;

   struct brw_cache cache;

   /** IDs for meta stencil blit shader programs. */
   unsigned meta_stencil_blit_programs[2];

   /* Whether a meta-operation is in progress. */
   bool meta_in_progress;

   /* Whether the last depth/stencil packets were both NULL. */
   bool no_depth_or_stencil;

   struct {
      struct brw_vertex_element inputs[VERT_ATTRIB_MAX];
      struct brw_vertex_buffer buffers[VERT_ATTRIB_MAX];

      struct brw_vertex_element *enabled[VERT_ATTRIB_MAX];
      GLuint nr_enabled;
      GLuint nr_buffers;

      /* Summary of size and varying of active arrays, so we can check
       * for changes to this state:
       */
      unsigned int min_index, max_index;

      /* Offset from start of vertex buffer so we can avoid redefining
       * the same VB packed over and over again.
       */
      unsigned int start_vertex_bias;
   } vb;

   struct {
      /**
       * Index buffer for this draw_prims call.
       *
       * Updates are signaled by BRW_NEW_INDICES.
       */
      const struct _mesa_index_buffer *ib;

      /* Updates are signaled by BRW_NEW_INDEX_BUFFER. */
      drm_intel_bo *bo;
      GLuint type;

      /* Offset to index buffer index to use in CMD_3D_PRIM so that we can
       * avoid re-uploading the IB packet over and over if we're actually
       * referencing the same index buffer.
       */
      unsigned int start_vertex_offset;
   } ib;

   /* Active vertex program:
    */
   const struct gl_vertex_program *vertex_program;
   const struct gl_geometry_program *geometry_program;
   const struct gl_fragment_program *fragment_program;

   /**
    * Number of samples in ctx->DrawBuffer, updated by BRW_NEW_NUM_SAMPLES so
    * that we don't have to reemit that state every time we change FBOs.
    */
   int num_samples;

   /**
    * Platform specific constants containing the maximum number of threads
    * for each pipeline stage.
    */
   int max_vs_threads;
   int max_gs_threads;
   int max_wm_threads;

   /* BRW_NEW_URB_ALLOCATIONS:
    */
   struct {
      GLuint vsize;		/* vertex size plus header in urb registers */
      GLuint csize;		/* constant buffer size in urb registers */
      GLuint sfsize;		/* setup data size in urb registers */

      bool constrained;

      GLuint min_vs_entries;    /* Minimum number of VS entries */
      GLuint max_vs_entries;	/* Maximum number of VS entries */
      GLuint max_gs_entries;	/* Maximum number of GS entries */

      GLuint nr_vs_entries;
      GLuint nr_gs_entries;
      GLuint nr_clip_entries;
      GLuint nr_sf_entries;
      GLuint nr_cs_entries;

      GLuint vs_start;
      GLuint gs_start;
      GLuint clip_start;
      GLuint sf_start;
      GLuint cs_start;
      GLuint size; /* Hardware URB size, in KB. */

      /* gen6: True if the most recently sent _3DSTATE_URB message allocated
       * URB space for the GS.
       */
      bool gen6_gs_previously_active;
   } urb;


   /* BRW_NEW_CURBE_OFFSETS:
    */
   struct {
      GLuint wm_start;  /**< pos of first wm const in CURBE buffer */
      GLuint wm_size;   /**< number of float[4] consts, multiple of 16 */
      GLuint clip_start;
      GLuint clip_size;
      GLuint vs_start;
      GLuint vs_size;
      GLuint total_size;

      drm_intel_bo *curbe_bo;
      /** Offset within curbe_bo of space for current curbe entry */
      GLuint curbe_offset;
      /** Offset within curbe_bo of space for next curbe entry */
      GLuint curbe_next_offset;

      /**
       * Copy of the last set of CURBEs uploaded.  Frequently we'll end up
       * in brw_curbe.c with the same set of constant data to be uploaded,
       * so we'd rather not upload new constants in that case (it can cause
       * a pipeline bubble since only up to 4 can be pipelined at a time).
       */
      GLfloat *last_buf;
      /**
       * Allocation for where to calculate the next set of CURBEs.
       * It's a hot enough path that malloc/free of that data matters.
       */
      GLfloat *next_buf;
      GLuint last_bufsz;
   } curbe;

   /**
    * Layout of vertex data exiting the vertex shader.
    *
    * BRW_NEW_VUE_MAP_VS is flagged when this VUE map changes.
    */
   struct brw_vue_map vue_map_vs;

   /**
    * Layout of vertex data exiting the geometry portion of the pipleine.
    * This comes from the geometry shader if one exists, otherwise from the
    * vertex shader.
    *
    * BRW_NEW_VUE_MAP_GEOM_OUT is flagged when the VUE map changes.
    */
   struct brw_vue_map vue_map_geom_out;

   struct {
      struct brw_stage_state base;
      struct brw_vs_prog_data *prog_data;
   } vs;

   struct {
      struct brw_stage_state base;
      struct brw_gs_prog_data *prog_data;

      /**
       * True if the 3DSTATE_GS command most recently emitted to the 3D
       * pipeline enabled the GS; false otherwise.
       */
      bool enabled;
   } gs;

   struct {
      struct brw_ff_gs_prog_data *prog_data;

      bool prog_active;
      /** Offset in the program cache to the CLIP program pre-gen6 */
      uint32_t prog_offset;
      uint32_t state_offset;

      uint32_t bind_bo_offset;
      uint32_t surf_offset[BRW_MAX_GEN6_GS_SURFACES];
   } ff_gs;

   struct {
      struct brw_clip_prog_data *prog_data;

      /** Offset in the program cache to the CLIP program pre-gen6 */
      uint32_t prog_offset;

      /* Offset in the batch to the CLIP state on pre-gen6. */
      uint32_t state_offset;

      /* As of gen6, this is the offset in the batch to the CLIP VP,
       * instead of vp_bo.
       */
      uint32_t vp_offset;
   } clip;


   struct {
      struct brw_sf_prog_data *prog_data;

      /** Offset in the program cache to the CLIP program pre-gen6 */
      uint32_t prog_offset;
      uint32_t state_offset;
      uint32_t vp_offset;
   } sf;

   struct {
      struct brw_stage_state base;
      struct brw_wm_prog_data *prog_data;

      GLuint render_surf;

      /**
       * Buffer object used in place of multisampled null render targets on
       * Gen6.  See brw_update_null_renderbuffer_surface().
       */
      drm_intel_bo *multisampled_null_render_target_bo;
   } wm;


   struct {
      uint32_t state_offset;
      uint32_t blend_state_offset;
      uint32_t depth_stencil_state_offset;
      uint32_t vp_offset;
   } cc;

   struct {
      struct brw_query_object *obj;
      bool begin_emitted;
   } query;

   struct {
      /** A map from pipeline statistics counter IDs to MMIO addresses. */
      const int *statistics_registers;

      /** The number of active monitors using OA counters. */
      unsigned oa_users;

      /**
       * A buffer object storing OA counter snapshots taken at the start and
       * end of each batch (creating "bookends" around the batch).
       */
      drm_intel_bo *bookend_bo;

      /** The number of snapshots written to bookend_bo. */
      int bookend_snapshots;

      /**
       * An array of monitors whose results haven't yet been assembled based on
       * the data in buffer objects.
       *
       * These may be active, or have already ended.  However, the results
       * have not been requested.
       */
      struct brw_perf_monitor_object **unresolved;
      int unresolved_elements;
      int unresolved_array_size;

      /**
       * Mapping from a uint32_t offset within an OA snapshot to the ID of
       * the counter which MI_REPORT_PERF_COUNT stores there.
       */
      const int *oa_snapshot_layout;

      /** Number of 32-bit entries in a hardware counter snapshot. */
      int entries_per_oa_snapshot;
   } perfmon;

   int num_atoms;
   const struct brw_tracked_state **atoms;

   /* If (INTEL_DEBUG & DEBUG_BATCH) */
   struct {
      uint32_t offset;
      uint32_t size;
      enum state_struct_type type;
   } *state_batch_list;
   int state_batch_count;

   uint32_t render_target_format[MESA_FORMAT_COUNT];
   bool format_supported_as_render_target[MESA_FORMAT_COUNT];

   /* Interpolation modes, one byte per vue slot.
    * Used Gen4/5 by the clip|sf|wm stages. Ignored on Gen6+.
    */
   struct interpolation_mode_map interpolation_mode;

   /* PrimitiveRestart */
   struct {
      bool in_progress;
      bool enable_cut_index;
   } prim_restart;

   /** Computed depth/stencil/hiz state from the current attached
    * renderbuffers, valid only during the drawing state upload loop after
    * brw_workaround_depthstencil_alignment().
    */
   struct {
      struct intel_mipmap_tree *depth_mt;
      struct intel_mipmap_tree *stencil_mt;

      /* Inter-tile (page-aligned) byte offsets. */
      uint32_t depth_offset, hiz_offset, stencil_offset;
      /* Intra-tile x,y offsets for drawing to depth/stencil/hiz */
      uint32_t tile_x, tile_y;
   } depthstencil;

   uint32_t num_instances;
   int basevertex;

   struct {
      drm_intel_bo *bo;
      struct gl_shader_program **shader_programs;
      struct gl_program **programs;
      enum shader_time_shader_type *types;
      uint64_t *cumulative;
      int num_entries;
      int max_entries;
      double report_time;
   } shader_time;

   __DRIcontext *driContext;
   struct intel_screen *intelScreen;
};

/*======================================================================
 * brw_vtbl.c
 */
void brwInitVtbl( struct brw_context *brw );

/* brw_clear.c */
extern void intelInitClearFuncs(struct dd_function_table *functions);

/*======================================================================
 * brw_context.c
 */
extern const char *const brw_vendor_string;

extern const char *brw_get_renderer_string(unsigned deviceID);

extern void intelFinish(struct gl_context * ctx);

enum {
   DRI_CONF_BO_REUSE_DISABLED,
   DRI_CONF_BO_REUSE_ALL
};

void intel_update_renderbuffers(__DRIcontext *context,
                                __DRIdrawable *drawable);
void intel_prepare_render(struct brw_context *brw);

void intel_resolve_for_dri2_flush(struct brw_context *brw,
                                  __DRIdrawable *drawable);

GLboolean brwCreateContext(gl_api api,
		      const struct gl_config *mesaVis,
		      __DRIcontext *driContextPriv,
                      unsigned major_version,
                      unsigned minor_version,
                      uint32_t flags,
                      bool notify_reset,
                      unsigned *error,
		      void *sharedContextPrivate);

/*======================================================================
 * brw_misc_state.c
 */
GLuint brw_get_rb_for_slice(struct brw_context *brw,
                            struct intel_mipmap_tree *mt,
                            unsigned level, unsigned layer, bool flat);

void brw_meta_updownsample(struct brw_context *brw,
                           struct intel_mipmap_tree *src,
                           struct intel_mipmap_tree *dst);

void brw_meta_fbo_stencil_blit(struct brw_context *brw,
                               GLfloat srcX0, GLfloat srcY0,
                               GLfloat srcX1, GLfloat srcY1,
                               GLfloat dstX0, GLfloat dstY0,
                               GLfloat dstX1, GLfloat dstY1);

void brw_meta_stencil_updownsample(struct brw_context *brw,
                                   struct intel_mipmap_tree *src,
                                   struct intel_mipmap_tree *dst);
/*======================================================================
 * brw_misc_state.c
 */
void brw_get_depthstencil_tile_masks(struct intel_mipmap_tree *depth_mt,
                                     uint32_t depth_level,
                                     uint32_t depth_layer,
                                     struct intel_mipmap_tree *stencil_mt,
                                     uint32_t *out_tile_mask_x,
                                     uint32_t *out_tile_mask_y);
void brw_workaround_depthstencil_alignment(struct brw_context *brw,
                                           GLbitfield clear_mask);

/* brw_object_purgeable.c */
void brw_init_object_purgeable_functions(struct dd_function_table *functions);

/*======================================================================
 * brw_queryobj.c
 */
void brw_init_common_queryobj_functions(struct dd_function_table *functions);
void gen4_init_queryobj_functions(struct dd_function_table *functions);
void brw_emit_query_begin(struct brw_context *brw);
void brw_emit_query_end(struct brw_context *brw);

/** gen6_queryobj.c */
void gen6_init_queryobj_functions(struct dd_function_table *functions);
void brw_write_timestamp(struct brw_context *brw, drm_intel_bo *bo, int idx);
void brw_write_depth_count(struct brw_context *brw, drm_intel_bo *bo, int idx);
void brw_store_register_mem64(struct brw_context *brw,
                              drm_intel_bo *bo, uint32_t reg, int idx);

/** intel_batchbuffer.c */
void brw_load_register_mem(struct brw_context *brw,
                           uint32_t reg,
                           drm_intel_bo *bo,
                           uint32_t read_domains, uint32_t write_domain,
                           uint32_t offset);

/*======================================================================
 * brw_state_dump.c
 */
void brw_debug_batch(struct brw_context *brw);
void brw_annotate_aub(struct brw_context *brw);

/*======================================================================
 * brw_tex.c
 */
void brw_validate_textures( struct brw_context *brw );


/*======================================================================
 * brw_program.c
 */
void brwInitFragProgFuncs( struct dd_function_table *functions );

int brw_get_scratch_size(int size);
void brw_get_scratch_bo(struct brw_context *brw,
			drm_intel_bo **scratch_bo, int size);
void brw_init_shader_time(struct brw_context *brw);
int brw_get_shader_time_index(struct brw_context *brw,
                              struct gl_shader_program *shader_prog,
                              struct gl_program *prog,
                              enum shader_time_shader_type type);
void brw_collect_and_report_shader_time(struct brw_context *brw);
void brw_destroy_shader_time(struct brw_context *brw);

/* brw_urb.c
 */
void brw_upload_urb_fence(struct brw_context *brw);

/* brw_curbe.c
 */
void brw_upload_cs_urb_state(struct brw_context *brw);

/* brw_fs_reg_allocate.cpp
 */
void brw_fs_alloc_reg_sets(struct intel_screen *screen);

/* brw_vec4_reg_allocate.cpp */
void brw_vec4_alloc_reg_set(struct intel_screen *screen);

/* brw_disasm.c */
int brw_disasm (FILE *file, struct brw_instruction *inst, int gen);

/* brw_vs.c */
gl_clip_plane *brw_select_clip_planes(struct gl_context *ctx);

/* brw_draw_upload.c */
unsigned brw_get_vertex_surface_type(struct brw_context *brw,
                                     const struct gl_client_array *glarray);
unsigned brw_get_index_type(GLenum type);
void brw_prepare_vertices(struct brw_context *brw);

/* brw_wm_surface_state.c */
void brw_init_surface_formats(struct brw_context *brw);
void brw_create_constant_surface(struct brw_context *brw,
                                 drm_intel_bo *bo,
                                 uint32_t offset,
                                 uint32_t size,
                                 uint32_t *out_offset,
                                 bool dword_pitch);
void brw_update_buffer_texture_surface(struct gl_context *ctx,
                                       unsigned unit,
                                       uint32_t *surf_offset);
void
brw_update_sol_surface(struct brw_context *brw,
                       struct gl_buffer_object *buffer_obj,
                       uint32_t *out_offset, unsigned num_vector_components,
                       unsigned stride_dwords, unsigned offset_dwords);
void brw_upload_ubo_surfaces(struct brw_context *brw,
			     struct gl_shader *shader,
                             struct brw_stage_state *stage_state,
                             struct brw_stage_prog_data *prog_data);
void brw_upload_abo_surfaces(struct brw_context *brw,
                             struct gl_shader_program *prog,
                             struct brw_stage_state *stage_state,
                             struct brw_stage_prog_data *prog_data);

/* brw_surface_formats.c */
bool brw_is_hiz_depth_format(struct brw_context *ctx, mesa_format format);
bool brw_render_target_supported(struct brw_context *brw,
                                 struct gl_renderbuffer *rb);
uint32_t brw_depth_format(struct brw_context *brw, mesa_format format);

/* brw_performance_monitor.c */
void brw_init_performance_monitors(struct brw_context *brw);
void brw_dump_perf_monitors(struct brw_context *brw);
void brw_perf_monitor_new_batch(struct brw_context *brw);
void brw_perf_monitor_finish_batch(struct brw_context *brw);

/* intel_buffer_objects.c */
int brw_bo_map(struct brw_context *brw, drm_intel_bo *bo, int write_enable,
               const char *bo_name);
int brw_bo_map_gtt(struct brw_context *brw, drm_intel_bo *bo,
                   const char *bo_name);

/* intel_extensions.c */
extern void intelInitExtensions(struct gl_context *ctx);

/* intel_state.c */
extern int intel_translate_shadow_compare_func(GLenum func);
extern int intel_translate_compare_func(GLenum func);
extern int intel_translate_stencil_op(GLenum op);
extern int intel_translate_logic_op(GLenum opcode);

/* intel_syncobj.c */
void intel_init_syncobj_functions(struct dd_function_table *functions);

/* gen6_sol.c */
struct gl_transform_feedback_object *
brw_new_transform_feedback(struct gl_context *ctx, GLuint name);
void
brw_delete_transform_feedback(struct gl_context *ctx,
                              struct gl_transform_feedback_object *obj);
void
brw_begin_transform_feedback(struct gl_context *ctx, GLenum mode,
			     struct gl_transform_feedback_object *obj);
void
brw_end_transform_feedback(struct gl_context *ctx,
                           struct gl_transform_feedback_object *obj);
GLsizei
brw_get_transform_feedback_vertex_count(struct gl_context *ctx,
                                        struct gl_transform_feedback_object *obj,
                                        GLuint stream);

/* gen7_sol_state.c */
void
gen7_begin_transform_feedback(struct gl_context *ctx, GLenum mode,
                              struct gl_transform_feedback_object *obj);
void
gen7_end_transform_feedback(struct gl_context *ctx,
			    struct gl_transform_feedback_object *obj);
void
gen7_pause_transform_feedback(struct gl_context *ctx,
                              struct gl_transform_feedback_object *obj);
void
gen7_resume_transform_feedback(struct gl_context *ctx,
                               struct gl_transform_feedback_object *obj);

/* brw_blorp_blit.cpp */
GLbitfield
brw_blorp_framebuffer(struct brw_context *brw,
                      GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
                      GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
                      GLbitfield mask, GLenum filter);

bool
brw_blorp_copytexsubimage(struct brw_context *brw,
                          struct gl_renderbuffer *src_rb,
                          struct gl_texture_image *dst_image,
                          int slice,
                          int srcX0, int srcY0,
                          int dstX0, int dstY0,
                          int width, int height);

/* gen6_multisample_state.c */
unsigned
gen6_determine_sample_mask(struct brw_context *brw);

void
gen6_emit_3dstate_multisample(struct brw_context *brw,
                              unsigned num_samples);
void
gen6_emit_3dstate_sample_mask(struct brw_context *brw, unsigned mask);
void
gen6_get_sample_position(struct gl_context *ctx,
                         struct gl_framebuffer *fb,
                         GLuint index,
                         GLfloat *result);

/* gen8_multisample_state.c */
void gen8_emit_3dstate_multisample(struct brw_context *brw, unsigned num_samp);
void gen8_emit_3dstate_sample_pattern(struct brw_context *brw);

/* gen7_urb.c */
void
gen7_emit_push_constant_state(struct brw_context *brw, unsigned vs_size,
                              unsigned gs_size, unsigned fs_size);

void
gen7_emit_urb_state(struct brw_context *brw,
                    unsigned nr_vs_entries, unsigned vs_size,
                    unsigned vs_start, unsigned nr_gs_entries,
                    unsigned gs_size, unsigned gs_start);


/* brw_reset.c */
extern GLenum
brw_get_graphics_reset_status(struct gl_context *ctx);

/*======================================================================
 * Inline conversion functions.  These are better-typed than the
 * macros used previously:
 */
static inline struct brw_context *
brw_context( struct gl_context *ctx )
{
   return (struct brw_context *)ctx;
}

static inline struct brw_vertex_program *
brw_vertex_program(struct gl_vertex_program *p)
{
   return (struct brw_vertex_program *) p;
}

static inline const struct brw_vertex_program *
brw_vertex_program_const(const struct gl_vertex_program *p)
{
   return (const struct brw_vertex_program *) p;
}

static inline struct brw_geometry_program *
brw_geometry_program(struct gl_geometry_program *p)
{
   return (struct brw_geometry_program *) p;
}

static inline struct brw_fragment_program *
brw_fragment_program(struct gl_fragment_program *p)
{
   return (struct brw_fragment_program *) p;
}

static inline const struct brw_fragment_program *
brw_fragment_program_const(const struct gl_fragment_program *p)
{
   return (const struct brw_fragment_program *) p;
}

/**
 * Pre-gen6, the register file of the EUs was shared between threads,
 * and each thread used some subset allocated on a 16-register block
 * granularity.  The unit states wanted these block counts.
 */
static inline int
brw_register_blocks(int reg_count)
{
   return ALIGN(reg_count, 16) / 16 - 1;
}

static inline uint32_t
brw_program_reloc(struct brw_context *brw, uint32_t state_offset,
		  uint32_t prog_offset)
{
   if (brw->gen >= 5) {
      /* Using state base address. */
      return prog_offset;
   }

   drm_intel_bo_emit_reloc(brw->batch.bo,
			   state_offset,
			   brw->cache.bo,
			   prog_offset,
			   I915_GEM_DOMAIN_INSTRUCTION, 0);

   return brw->cache.bo->offset64 + prog_offset;
}

bool brw_do_cubemap_normalize(struct exec_list *instructions);
bool brw_lower_texture_gradients(struct brw_context *brw,
                                 struct exec_list *instructions);
bool brw_do_lower_unnormalized_offset(struct exec_list *instructions);

struct opcode_desc {
    char    *name;
    int	    nsrc;
    int	    ndst;
};

extern const struct opcode_desc opcode_descs[128];
extern const char * const conditional_modifier[16];

void
brw_emit_depthbuffer(struct brw_context *brw);

void
brw_emit_depth_stencil_hiz(struct brw_context *brw,
                           struct intel_mipmap_tree *depth_mt,
                           uint32_t depth_offset, uint32_t depthbuffer_format,
                           uint32_t depth_surface_type,
                           struct intel_mipmap_tree *stencil_mt,
                           bool hiz, bool separate_stencil,
                           uint32_t width, uint32_t height,
                           uint32_t tile_x, uint32_t tile_y);

void
gen7_emit_depth_stencil_hiz(struct brw_context *brw,
                            struct intel_mipmap_tree *depth_mt,
                            uint32_t depth_offset, uint32_t depthbuffer_format,
                            uint32_t depth_surface_type,
                            struct intel_mipmap_tree *stencil_mt,
                            bool hiz, bool separate_stencil,
                            uint32_t width, uint32_t height,
                            uint32_t tile_x, uint32_t tile_y);
void
gen8_emit_depth_stencil_hiz(struct brw_context *brw,
                            struct intel_mipmap_tree *depth_mt,
                            uint32_t depth_offset, uint32_t depthbuffer_format,
                            uint32_t depth_surface_type,
                            struct intel_mipmap_tree *stencil_mt,
                            bool hiz, bool separate_stencil,
                            uint32_t width, uint32_t height,
                            uint32_t tile_x, uint32_t tile_y);

void gen8_hiz_exec(struct brw_context *brw, struct intel_mipmap_tree *mt,
                   unsigned int level, unsigned int layer, enum gen6_hiz_op op);

extern const GLuint prim_to_hw_prim[GL_TRIANGLE_STRIP_ADJACENCY+1];

void
brw_setup_vec4_key_clip_info(struct brw_context *brw,
                             struct brw_vec4_prog_key *key,
                             bool program_uses_clip_distance);

void
gen6_upload_vec4_push_constants(struct brw_context *brw,
                                const struct gl_program *prog,
                                const struct brw_vec4_prog_data *prog_data,
                                struct brw_stage_state *stage_state,
                                enum state_struct_type type);

/* ================================================================
 * From linux kernel i386 header files, copes with odd sizes better
 * than COPY_DWORDS would:
 * XXX Put this in src/mesa/main/imports.h ???
 */
#if defined(i386) || defined(__i386__)
static inline void * __memcpy(void * to, const void * from, size_t n)
{
   int d0, d1, d2;
   __asm__ __volatile__(
      "rep ; movsl\n\t"
      "testb $2,%b4\n\t"
      "je 1f\n\t"
      "movsw\n"
      "1:\ttestb $1,%b4\n\t"
      "je 2f\n\t"
      "movsb\n"
      "2:"
      : "=&c" (d0), "=&D" (d1), "=&S" (d2)
      :"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
      : "memory");
   return (to);
}
#else
#define __memcpy(a,b,c) memcpy(a,b,c)
#endif

#ifdef __cplusplus
}
#endif

#endif
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a42 2
#include "intel_aub.h"
#include "program/prog_parameter.h"
d143 2
d146 1
a146 1
struct brw_inst;
a184 1
   BRW_STATE_TEXTURE_BUFFER,
d188 15
a202 15
#define BRW_NEW_URB_FENCE               (1ull << BRW_STATE_URB_FENCE)
#define BRW_NEW_FRAGMENT_PROGRAM        (1ull << BRW_STATE_FRAGMENT_PROGRAM)
#define BRW_NEW_GEOMETRY_PROGRAM        (1ull << BRW_STATE_GEOMETRY_PROGRAM)
#define BRW_NEW_VERTEX_PROGRAM          (1ull << BRW_STATE_VERTEX_PROGRAM)
#define BRW_NEW_CURBE_OFFSETS           (1ull << BRW_STATE_CURBE_OFFSETS)
#define BRW_NEW_REDUCED_PRIMITIVE       (1ull << BRW_STATE_REDUCED_PRIMITIVE)
#define BRW_NEW_PRIMITIVE               (1ull << BRW_STATE_PRIMITIVE)
#define BRW_NEW_CONTEXT                 (1ull << BRW_STATE_CONTEXT)
#define BRW_NEW_PSP                     (1ull << BRW_STATE_PSP)
#define BRW_NEW_SURFACES                (1ull << BRW_STATE_SURFACES)
#define BRW_NEW_VS_BINDING_TABLE        (1ull << BRW_STATE_VS_BINDING_TABLE)
#define BRW_NEW_GS_BINDING_TABLE        (1ull << BRW_STATE_GS_BINDING_TABLE)
#define BRW_NEW_PS_BINDING_TABLE        (1ull << BRW_STATE_PS_BINDING_TABLE)
#define BRW_NEW_INDICES                 (1ull << BRW_STATE_INDICES)
#define BRW_NEW_VERTICES                (1ull << BRW_STATE_VERTICES)
d207 1
a207 1
#define BRW_NEW_BATCH                   (1ull << BRW_STATE_BATCH)
d209 16
a224 17
#define BRW_NEW_INDEX_BUFFER            (1ull << BRW_STATE_INDEX_BUFFER)
#define BRW_NEW_VS_CONSTBUF             (1ull << BRW_STATE_VS_CONSTBUF)
#define BRW_NEW_GS_CONSTBUF             (1ull << BRW_STATE_GS_CONSTBUF)
#define BRW_NEW_PROGRAM_CACHE           (1ull << BRW_STATE_PROGRAM_CACHE)
#define BRW_NEW_STATE_BASE_ADDRESS      (1ull << BRW_STATE_STATE_BASE_ADDRESS)
#define BRW_NEW_VUE_MAP_VS              (1ull << BRW_STATE_VUE_MAP_VS)
#define BRW_NEW_VUE_MAP_GEOM_OUT        (1ull << BRW_STATE_VUE_MAP_GEOM_OUT)
#define BRW_NEW_TRANSFORM_FEEDBACK      (1ull << BRW_STATE_TRANSFORM_FEEDBACK)
#define BRW_NEW_RASTERIZER_DISCARD      (1ull << BRW_STATE_RASTERIZER_DISCARD)
#define BRW_NEW_STATS_WM                (1ull << BRW_STATE_STATS_WM)
#define BRW_NEW_UNIFORM_BUFFER          (1ull << BRW_STATE_UNIFORM_BUFFER)
#define BRW_NEW_ATOMIC_BUFFER           (1ull << BRW_STATE_ATOMIC_BUFFER)
#define BRW_NEW_META_IN_PROGRESS        (1ull << BRW_STATE_META_IN_PROGRESS)
#define BRW_NEW_INTERPOLATION_MAP       (1ull << BRW_STATE_INTERPOLATION_MAP)
#define BRW_NEW_PUSH_CONSTANT_ALLOCATION (1ull << BRW_STATE_PUSH_CONSTANT_ALLOCATION)
#define BRW_NEW_NUM_SAMPLES             (1ull << BRW_STATE_NUM_SAMPLES)
#define BRW_NEW_TEXTURE_BUFFER          (1ull << BRW_STATE_TEXTURE_BUFFER)
d232 2
a233 9
   uint64_t brw;
   /**
    * State update flags that used to be signalled by brw_state_cache.c
    * searches.
    *
    * Now almost all of that state is just streamed out on demand, but the
    * flags for those state blobs updating have stayed in the same bitfield.
    * brw_state_cache.c still flags CACHE_NEW_*_PROG.
    */
d237 65
a358 9
   unsigned curb_read_length;
   unsigned total_scratch;

   /**
    * Register where the thread expects to find input data from the URB
    * (typically uniforms, followed by vertex or fragment attributes).
    */
   unsigned dispatch_grf_start_reg;

d365 2
a366 2
   const gl_constant_value **param;
   const gl_constant_value **pull_param;
d380 1
d383 2
a384 1
   GLuint dispatch_grf_start_reg_16;
d387 1
a396 1
   bool no_8;
a399 1
   bool uses_kill;
d586 7
d595 1
d614 40
a653 1
   bool uses_instanceid;
d700 1
a700 71

/* Note: brw_gs_prog_data_compare() must be updated when adding fields to
 * this struct!
 */
struct brw_gs_prog_data
{
   struct brw_vec4_prog_data base;

   /**
    * Size of an output vertex, measured in HWORDS (32 bytes).
    */
   unsigned output_vertex_size_hwords;

   unsigned output_topology;

   /**
    * Size of the control data (cut bits or StreamID bits), in hwords (32
    * bytes).  0 if there is no control data.
    */
   unsigned control_data_header_size_hwords;

   /**
    * Format of the control data (either GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_SID
    * if the control data is StreamID bits, or
    * GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_CUT if the control data is cut bits).
    * Ignored if control_data_header_size is 0.
    */
   unsigned control_data_format;

   bool include_primitive_id;

   int invocations;

   /**
    * Dispatch mode, can be any of:
    * GEN7_GS_DISPATCH_MODE_DUAL_OBJECT
    * GEN7_GS_DISPATCH_MODE_DUAL_INSTANCE
    * GEN7_GS_DISPATCH_MODE_SINGLE
    */
   int dispatch_mode;

   /**
    * Gen6 transform feedback enabled flag.
    */
   bool gen6_xfb_enabled;

   /**
    * Gen6: Provoking vertex convention for odd-numbered triangles
    * in tristrips.
    */
   GLuint pv_first:1;

   /**
    * Gen6: Number of varyings that are output to transform feedback.
    */
   GLuint num_transform_feedback_bindings:7; /* 0-BRW_MAX_SOL_BINDINGS */

   /**
    * Gen6: Map from the index of a transform feedback binding table entry to the
    * gl_varying_slot that should be streamed out through that binding table
    * entry.
    */
   unsigned char transform_feedback_bindings[BRW_MAX_SOL_BINDINGS];

   /**
    * Gen6: Map from the index of a transform feedback binding table entry to the
    * swizzles that should be used when streaming out data through that
    * binding table entry.
    */
   unsigned char transform_feedback_swizzles[BRW_MAX_SOL_BINDINGS];
};
d715 1
d810 1
d953 3
d995 5
a1090 1
   bool is_cherryview;
a1100 2
   bool no_simd8;
   bool use_rep_send;
a1126 15
   /* The last PMA stall bits programmed. */
   uint32_t pma_stall_bits;

   struct {
      /** The value of gl_BaseVertex for the current _mesa_prim. */
      int gl_basevertex;

      /**
       * Buffer and offset used for GL_ARB_shader_draw_parameters
       * (for now, only gl_BaseVertex).
       */
      drm_intel_bo *draw_params_bo;
      uint32_t draw_params_offset;
   } draw;

a1188 1
      GLuint gsize;	        /* GS output size in urb registers */
d1211 1
a1211 1
      /* True if the most recently sent _3DSTATE_URB message allocated
d1214 1
a1214 1
      bool gs_present;
a1228 4
      /**
       * Pointer to the (intel_upload.c-generated) BO containing the uniforms
       * for upload to the CURBE.
       */
d1232 16
d1291 1
a1291 6
      /**
       * Surface offsets for the binding table. We only need surfaces to
       * implement transform feedback so BRW_MAX_SOL_BINDINGS is all that we
       * need in this case.
       */
      uint32_t surf_offset[BRW_MAX_SOL_BINDINGS];
a1316 1
      bool viewport_transform_enable;
a1329 1
      uint32_t fast_clear_op;
d1389 1
a1389 1
      enum aub_state_struct_type type;
a1434 2
   struct brw_fast_clear_state *fast_clear_state;

d1454 2
a1497 13

bool brw_meta_fast_clear(struct brw_context *brw,
                         struct gl_framebuffer *fb,
                         GLbitfield mask,
                         bool partial_clear);

void
brw_meta_resolve_color(struct brw_context *brw,
                       struct intel_mipmap_tree *mt);
void
brw_meta_fast_clear_free(struct brw_context *brw);


d1579 1
a1579 2
int brw_disassemble_inst(FILE *file, struct brw_context *brw,
                         struct brw_inst *inst, bool is_compacted);
a1705 2
void
gen6_set_sample_maps(struct gl_context *ctx);
a1823 10
gen6_emit_depth_stencil_hiz(struct brw_context *brw,
                            struct intel_mipmap_tree *depth_mt,
                            uint32_t depth_offset, uint32_t depthbuffer_format,
                            uint32_t depth_surface_type,
                            struct intel_mipmap_tree *stencil_mt,
                            bool hiz, bool separate_stencil,
                            uint32_t width, uint32_t height,
                            uint32_t tile_x, uint32_t tile_y);

void
d1845 1
a1845 1
uint32_t get_hw_prim_for_gl_prim(int mode);
d1853 5
a1857 5
gen6_upload_push_constants(struct brw_context *brw,
                           const struct gl_program *prog,
                           const struct brw_stage_prog_data *prog_data,
                           struct brw_stage_state *stage_state,
                           enum aub_state_struct_type type);
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d43 2
a144 2
#define BRW_MAX_CURBE                    (32*16)

d146 1
a146 1
struct brw_instruction;
d185 1
d189 15
a203 15
#define BRW_NEW_URB_FENCE               (1 << BRW_STATE_URB_FENCE)
#define BRW_NEW_FRAGMENT_PROGRAM        (1 << BRW_STATE_FRAGMENT_PROGRAM)
#define BRW_NEW_GEOMETRY_PROGRAM        (1 << BRW_STATE_GEOMETRY_PROGRAM)
#define BRW_NEW_VERTEX_PROGRAM          (1 << BRW_STATE_VERTEX_PROGRAM)
#define BRW_NEW_CURBE_OFFSETS           (1 << BRW_STATE_CURBE_OFFSETS)
#define BRW_NEW_REDUCED_PRIMITIVE       (1 << BRW_STATE_REDUCED_PRIMITIVE)
#define BRW_NEW_PRIMITIVE               (1 << BRW_STATE_PRIMITIVE)
#define BRW_NEW_CONTEXT                 (1 << BRW_STATE_CONTEXT)
#define BRW_NEW_PSP                     (1 << BRW_STATE_PSP)
#define BRW_NEW_SURFACES		(1 << BRW_STATE_SURFACES)
#define BRW_NEW_VS_BINDING_TABLE	(1 << BRW_STATE_VS_BINDING_TABLE)
#define BRW_NEW_GS_BINDING_TABLE	(1 << BRW_STATE_GS_BINDING_TABLE)
#define BRW_NEW_PS_BINDING_TABLE	(1 << BRW_STATE_PS_BINDING_TABLE)
#define BRW_NEW_INDICES			(1 << BRW_STATE_INDICES)
#define BRW_NEW_VERTICES		(1 << BRW_STATE_VERTICES)
d208 1
a208 1
#define BRW_NEW_BATCH                  (1 << BRW_STATE_BATCH)
d210 17
a226 16
#define BRW_NEW_INDEX_BUFFER           (1 << BRW_STATE_INDEX_BUFFER)
#define BRW_NEW_VS_CONSTBUF            (1 << BRW_STATE_VS_CONSTBUF)
#define BRW_NEW_GS_CONSTBUF            (1 << BRW_STATE_GS_CONSTBUF)
#define BRW_NEW_PROGRAM_CACHE		(1 << BRW_STATE_PROGRAM_CACHE)
#define BRW_NEW_STATE_BASE_ADDRESS	(1 << BRW_STATE_STATE_BASE_ADDRESS)
#define BRW_NEW_VUE_MAP_VS		(1 << BRW_STATE_VUE_MAP_VS)
#define BRW_NEW_VUE_MAP_GEOM_OUT	(1 << BRW_STATE_VUE_MAP_GEOM_OUT)
#define BRW_NEW_TRANSFORM_FEEDBACK	(1 << BRW_STATE_TRANSFORM_FEEDBACK)
#define BRW_NEW_RASTERIZER_DISCARD	(1 << BRW_STATE_RASTERIZER_DISCARD)
#define BRW_NEW_STATS_WM		(1 << BRW_STATE_STATS_WM)
#define BRW_NEW_UNIFORM_BUFFER          (1 << BRW_STATE_UNIFORM_BUFFER)
#define BRW_NEW_ATOMIC_BUFFER           (1 << BRW_STATE_ATOMIC_BUFFER)
#define BRW_NEW_META_IN_PROGRESS        (1 << BRW_STATE_META_IN_PROGRESS)
#define BRW_NEW_INTERPOLATION_MAP       (1 << BRW_STATE_INTERPOLATION_MAP)
#define BRW_NEW_PUSH_CONSTANT_ALLOCATION (1 << BRW_STATE_PUSH_CONSTANT_ALLOCATION)
#define BRW_NEW_NUM_SAMPLES             (1 << BRW_STATE_NUM_SAMPLES)
d234 9
a242 2
   GLuint brw;
   /** State update flags signalled by brw_state_cache.c searches */
a245 65
#define AUB_TRACE_TYPE_MASK		0x0000ff00
#define AUB_TRACE_TYPE_NOTYPE		(0 << 8)
#define AUB_TRACE_TYPE_BATCH		(1 << 8)
#define AUB_TRACE_TYPE_VERTEX_BUFFER	(5 << 8)
#define AUB_TRACE_TYPE_2D_MAP		(6 << 8)
#define AUB_TRACE_TYPE_CUBE_MAP		(7 << 8)
#define AUB_TRACE_TYPE_VOLUME_MAP	(9 << 8)
#define AUB_TRACE_TYPE_1D_MAP		(10 << 8)
#define AUB_TRACE_TYPE_CONSTANT_BUFFER	(11 << 8)
#define AUB_TRACE_TYPE_CONSTANT_URB	(12 << 8)
#define AUB_TRACE_TYPE_INDEX_BUFFER	(13 << 8)
#define AUB_TRACE_TYPE_GENERAL		(14 << 8)
#define AUB_TRACE_TYPE_SURFACE		(15 << 8)

/**
 * state_struct_type enum values are encoded with the top 16 bits representing
 * the type to be delivered to the .aub file, and the bottom 16 bits
 * representing the subtype.  This macro performs the encoding.
 */
#define ENCODE_SS_TYPE(type, subtype) (((type) << 16) | (subtype))

enum state_struct_type {
   AUB_TRACE_VS_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 1),
   AUB_TRACE_GS_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 2),
   AUB_TRACE_CLIP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 3),
   AUB_TRACE_SF_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 4),
   AUB_TRACE_WM_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 5),
   AUB_TRACE_CC_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 6),
   AUB_TRACE_CLIP_VP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 7),
   AUB_TRACE_SF_VP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 8),
   AUB_TRACE_CC_VP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x9),
   AUB_TRACE_SAMPLER_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xa),
   AUB_TRACE_KERNEL_INSTRUCTIONS =	ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xb),
   AUB_TRACE_SCRATCH_SPACE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xc),
   AUB_TRACE_SAMPLER_DEFAULT_COLOR =    ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xd),

   AUB_TRACE_SCISSOR_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x15),
   AUB_TRACE_BLEND_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x16),
   AUB_TRACE_DEPTH_STENCIL_STATE =	ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x17),

   AUB_TRACE_VERTEX_BUFFER =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_VERTEX_BUFFER, 0),
   AUB_TRACE_BINDING_TABLE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_SURFACE, 0x100),
   AUB_TRACE_SURFACE_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_SURFACE, 0x200),
   AUB_TRACE_VS_CONSTANTS =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_CONSTANT_BUFFER, 0),
   AUB_TRACE_WM_CONSTANTS =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_CONSTANT_BUFFER, 1),
};

/**
 * Decode a state_struct_type value to determine the type that should be
 * stored in the .aub file.
 */
static inline uint32_t AUB_TRACE_TYPE(enum state_struct_type ss_type)
{
   return (ss_type & 0xFFFF0000) >> 16;
}

/**
 * Decode a state_struct_type value to determine the subtype that should be
 * stored in the .aub file.
 */
static inline uint32_t AUB_TRACE_SUBTYPE(enum state_struct_type ss_type)
{
   return ss_type & 0xFFFF;
}

d303 9
d318 2
a319 2
   const float **param;
   const float **pull_param;
a332 1
   GLuint curb_read_length;
d335 1
a335 2
   GLuint first_curbe_grf;
   GLuint first_curbe_grf_16;
a337 1
   GLuint total_scratch;
d347 1
d351 1
a537 7
   /**
    * Register where the thread expects to find input data from the URB
    * (typically uniforms, followed by per-vertex inputs).
    */
   unsigned dispatch_grf_start_reg;

   GLuint curb_read_length;
a539 1
   GLuint total_scratch;
d558 1
a558 40
};


/* Note: brw_gs_prog_data_compare() must be updated when adding fields to
 * this struct!
 */
struct brw_gs_prog_data
{
   struct brw_vec4_prog_data base;

   /**
    * Size of an output vertex, measured in HWORDS (32 bytes).
    */
   unsigned output_vertex_size_hwords;

   unsigned output_topology;

   /**
    * Size of the control data (cut bits or StreamID bits), in hwords (32
    * bytes).  0 if there is no control data.
    */
   unsigned control_data_header_size_hwords;

   /**
    * Format of the control data (either GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_SID
    * if the control data is StreamID bits, or
    * GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_CUT if the control data is cut bits).
    * Ignored if control_data_header_size is 0.
    */
   unsigned control_data_format;

   bool include_primitive_id;

   int invocations;

   /**
    * True if the thread should be dispatched in DUAL_INSTANCE mode, false if
    * it should be dispatched in DUAL_OBJECT mode.
    */
   bool dual_instanced_dispatch;
d605 71
a675 1
#define BRW_MAX_GEN6_GS_SURFACES       SURF_INDEX_GEN6_SOL_BINDING(BRW_MAX_SOL_BINDINGS)
a689 1
   BRW_BLORP_CONST_COLOR_PROG,
a783 1
#define CACHE_NEW_BLORP_CONST_COLOR_PROG (1<<BRW_BLORP_CONST_COLOR_PROG)
a925 3

   /** Offsets in the batch to sampler default colors (texture border color) */
   uint32_t sdc_offset[BRW_MAX_TEX_UNIT];
a964 5
      /** Upload a SAMPLER_STATE table. */
      void (*upload_sampler_state_table)(struct brw_context *brw,
                                         struct gl_program *prog,
                                         struct brw_stage_state *stage_state);

d1056 1
d1067 2
d1095 15
d1172 1
d1195 1
a1195 1
      /* gen6: True if the most recently sent _3DSTATE_URB message allocated
d1198 1
a1198 1
      bool gen6_gs_previously_active;
d1213 4
a1219 16
      /** Offset within curbe_bo of space for next curbe entry */
      GLuint curbe_next_offset;

      /**
       * Copy of the last set of CURBEs uploaded.  Frequently we'll end up
       * in brw_curbe.c with the same set of constant data to be uploaded,
       * so we'd rather not upload new constants in that case (it can cause
       * a pipeline bubble since only up to 4 can be pipelined at a time).
       */
      GLfloat *last_buf;
      /**
       * Allocation for where to calculate the next set of CURBEs.
       * It's a hot enough path that malloc/free of that data matters.
       */
      GLfloat *next_buf;
      GLuint last_bufsz;
d1263 6
a1268 1
      uint32_t surf_offset[BRW_MAX_GEN6_GS_SURFACES];
d1294 1
d1308 1
d1368 1
a1368 1
      enum state_struct_type type;
d1414 2
a1434 2
extern void intelFinish(struct gl_context * ctx);

d1477 13
d1571 2
a1572 1
int brw_disasm (FILE *file, struct brw_instruction *inst, int gen);
d1699 2
d1819 10
d1850 1
a1850 1
extern const GLuint prim_to_hw_prim[GL_TRIANGLE_STRIP_ADJACENCY+1];
d1858 5
a1862 5
gen6_upload_vec4_push_constants(struct brw_context *brw,
                                const struct gl_program *prog,
                                const struct brw_vec4_prog_data *prog_data,
                                struct brw_stage_state *stage_state,
                                enum state_struct_type type);
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
d5 1
a5 1
 
d13 1
a13 1
 
d17 1
a17 1
 
d25 1
a25 1
 
d29 1
a29 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d36 2
a37 2
#include "intel_context.h"
#include "brw_structs.h"
d40 17
d61 4
d78 1
a78 1
 * things like primitive type, Begin/end flags and clip codes.  
a142 1

d148 1
d155 1
d171 1
d174 1
d180 1
d182 4
d190 1
d211 1
d214 1
d220 1
d222 3
d309 7
d322 8
d334 1
d336 31
a366 2
   /** Shader IR transformed for native compile, at link time. */
   struct exec_list *ir;
d378 2
d381 1
a381 1
   GLuint urb_read_length;
d389 8
a396 2
   GLuint nr_params;       /**< number of float params/constants */
   GLuint nr_pull_params;
d398 2
a399 1
   int dispatch_width;
d408 4
a411 5
   /* Pointers to tracked values (only valid once
    * _mesa_load_state_parameters has been called at runtime).
    *
    * These must be the last fields of the struct (see
    * brw_wm_prog_data_compare()).
d413 1
a413 2
   const float **param;
   const float **pull_param;
d499 36
a534 1
                         GLbitfield64 slots_valid, bool userclip_active);
d550 10
d567 1
a567 1
struct brw_gs_prog_data {
d583 1
d586 6
a594 2
   GLuint nr_params;       /**< number of float params/constants */
   GLuint nr_pull_params; /**< number of dwords referenced by pull_param[] */
a601 6

   int num_surfaces;

   /* These pointers must appear last.  See brw_vec4_prog_data_compare(). */
   const float **param;
   const float **pull_param;
d616 40
d657 1
a657 1
#define BRW_MAX_TEX_UNIT 16
d662 3
d693 5
a697 2
#define BRW_MAX_WM_UBOS              12
#define BRW_MAX_VS_UBOS              12
d699 2
a700 77
/**
 * Helpers to create Surface Binding Table indexes for draw buffers,
 * textures, and constant buffers.
 *
 * Shader threads access surfaces via numeric handles, rather than directly
 * using pointers.  The binding table maps these numeric handles to the
 * address of the actual buffer.
 *
 * For example, a shader might ask to sample from "surface 7."  In this case,
 * bind[7] would contain a pointer to a texture.
 *
 * Currently, our WM binding tables are (arbitrarily) programmed as follows:
 *
 *    +-------------------------------+
 *    |   0 | Draw buffer 0           |
 *    |   . |     .                   |
 *    |   : |     :                   |
 *    |   7 | Draw buffer 7           |
 *    |-----|-------------------------|
 *    |   8 | WM Pull Constant Buffer |
 *    |-----|-------------------------|
 *    |   9 | Texture 0               |
 *    |   . |     .                   |
 *    |   : |     :                   |
 *    |  24 | Texture 15              |
 *    |-----|-------------------------|
 *    |  25 | UBO 0                   |
 *    |   . |     .                   |
 *    |   : |     :                   |
 *    |  36 | UBO 11                  |
 *    +-------------------------------+
 *
 * Our VS binding tables are programmed as follows:
 *
 *    +-----+-------------------------+
 *    |   0 | VS Pull Constant Buffer |
 *    +-----+-------------------------+
 *    |   1 | Texture 0               |
 *    |   . |     .                   |
 *    |   : |     :                   |
 *    |  16 | Texture 15              |
 *    +-----+-------------------------+
 *    |  17 | UBO 0                   |
 *    |   . |     .                   |
 *    |   : |     :                   |
 *    |  28 | UBO 11                  |
 *    +-------------------------------+
 *
 * Our (gen6) GS binding tables are programmed as follows:
 *
 *    +-----+-------------------------+
 *    |   0 | SOL Binding 0           |
 *    |   . |     .                   |
 *    |   : |     :                   |
 *    |  63 | SOL Binding 63          |
 *    +-----+-------------------------+
 *
 * Note that nothing actually uses the SURF_INDEX_DRAW macro, so it has to be
 * the identity function or things will break.  We do want to keep draw buffers
 * first so we can use headerless render target writes for RT 0.
 */
#define SURF_INDEX_DRAW(d)           (d)
#define SURF_INDEX_FRAG_CONST_BUFFER (BRW_MAX_DRAW_BUFFERS + 1)
#define SURF_INDEX_TEXTURE(t)        (BRW_MAX_DRAW_BUFFERS + 2 + (t))
#define SURF_INDEX_WM_UBO(u)         (SURF_INDEX_TEXTURE(BRW_MAX_TEX_UNIT) + u)
#define SURF_INDEX_WM_SHADER_TIME    (SURF_INDEX_WM_UBO(12))
/** Maximum size of the binding table. */
#define BRW_MAX_WM_SURFACES          (SURF_INDEX_WM_SHADER_TIME + 1)

#define SURF_INDEX_VERT_CONST_BUFFER (0)
#define SURF_INDEX_VS_TEXTURE(t)     (SURF_INDEX_VERT_CONST_BUFFER + 1 + (t))
#define SURF_INDEX_VS_UBO(u)         (SURF_INDEX_VS_TEXTURE(BRW_MAX_TEX_UNIT) + u)
#define SURF_INDEX_VS_SHADER_TIME    (SURF_INDEX_VS_UBO(12))
#define BRW_MAX_VS_SURFACES          (SURF_INDEX_VS_SHADER_TIME + 1)

#define SURF_INDEX_SOL_BINDING(t)    ((t))
#define BRW_MAX_GS_SURFACES          SURF_INDEX_SOL_BINDING(BRW_MAX_SOL_BINDINGS)
d723 2
a724 1
   BRW_GS_UNIT,
d750 1
a750 1
};   
d753 1
a753 2
typedef bool (*cache_aux_compare_func)(const void *a, const void *b,
                                       int aux_size, const void *key);
d793 3
d809 2
d818 2
a819 1
#define CACHE_NEW_GS_UNIT                (1<<BRW_GS_UNIT)
a824 13
struct brw_cached_batch_item {
   struct header *header;
   GLuint sz;
   struct brw_cached_batch_item *next;
};
   


/* Protect against a future where VERT_ATTRIB_MAX > 32.  Wouldn't life
 * be easier if C allowed arrays of packed elements?
 */
#define ATTRIB_BIT_DWORDS  ((VERT_ATTRIB_MAX+31)/32)

a837 2
   /** The corresponding Mesa vertex attribute */
   gl_vert_attrib attrib;
d852 106
d962 1
a962 1
struct brw_context 
a967 4
      void (*destroy) (struct brw_context * brw);
      void (*finish_batch) (struct brw_context * brw);
      void (*new_batch) (struct brw_context * brw);

d970 2
a971 2
                                     uint32_t *binding_table,
                                     unsigned surf_index);
d978 21
a998 6
      void (*create_constant_surface)(struct brw_context *brw,
				      drm_intel_bo *bo,
				      uint32_t offset,
				      uint32_t size,
				      uint32_t *out_offset,
                                      bool dword_pitch);
d1020 15
d1040 1
a1040 4
      GLuint offset;
      uint32_t buffer_len;
      uint32_t buffer_offset;
      char buffer[4096];
a1050 17
   /**
    * Track whether front-buffer rendering is currently enabled
    *
    * A separate flag is used to track this in order to support MRT more
    * easily.
    */
   bool is_front_buffer_rendering;

   /**
    * Track whether front-buffer is the current read target.
    *
    * This is closely associated with is_front_buffer_rendering, but may
    * be set separately.  The DRI2 fake front buffer must be referenced
    * either way.
    */
   bool is_front_buffer_reading;

d1067 1
a1084 2
   bool emit_state_always;

a1099 1
   bool has_aa_line_parameters;
d1117 3
a1119 1
   struct brw_cached_batch_item *cached_batch_items;
d1124 3
d1165 1
a1165 1
   /* Active vertex program: 
d1168 1
d1171 5
a1175 4
   /* hw-dependent 3DSTATE_VF_STATISTICS opcode */
   uint32_t CMD_VF_STATISTICS;
   /* hw-dependent 3DSTATE_PIPELINE_SELECT opcode */
   uint32_t CMD_PIPELINE_SELECT;
d1194 1
d1217 2
a1218 2
   
   /* BRW_NEW_CURBE_OFFSETS: 
d1250 6
a1255 5
   /** SAMPLER_STATE count and offset */
   struct {
      GLuint count;
      uint32_t offset;
   } sampler;
d1267 1
d1269 1
d1271 3
a1273 12
      drm_intel_bo *scratch_bo;
      drm_intel_bo *const_bo;
      /** Offset in the program cache to the VS program */
      uint32_t prog_offset;
      uint32_t state_offset;

      uint32_t push_const_offset; /* Offset in the batchbuffer */
      int push_const_size; /* in 256-bit register increments */

      /** @@{ register allocator */

      struct ra_regs *regs;
d1276 2
a1277 2
       * Array of the ra classes for the unaligned contiguous register
       * block sizes used.
d1279 2
a1280 12
      int *classes;

      /**
       * Mapping for register-allocated objects in *regs to the first
       * GRF for that object.
      */
      uint8_t *ra_reg_to_grf;
      /** @@} */

      uint32_t bind_bo_offset;
      uint32_t surf_offset[BRW_MAX_VS_SURFACES];
   } vs;
d1283 1
a1283 1
      struct brw_gs_prog_data *prog_data;
d1291 2
a1292 2
      uint32_t surf_offset[BRW_MAX_GS_SURFACES];
   } gs;
d1320 1
a1322 4
      /** offsets in the batch to sampler default colors (texture border color)
       */
      uint32_t sdc_offset[BRW_MAX_TEX_UNIT];

a1324 2
      drm_intel_bo *scratch_bo;

a1329 38

      /** Offset in the program cache to the WM program */
      uint32_t prog_offset;

      uint32_t state_offset; /* offset in batchbuffer to pre-gen6 WM state */

      drm_intel_bo *const_bo; /* pull constant buffer. */
      /**
       * This is offset in the batch to the push constants on gen6.
       *
       * Pre-gen6, push constants live in the CURBE.
       */
      uint32_t push_const_offset;

      /** Binding table of pointers to surf_bo entries */
      uint32_t bind_bo_offset;
      uint32_t surf_offset[BRW_MAX_WM_SURFACES];

      struct {
         struct ra_regs *regs;

         /** Array of the ra classes for the unaligned contiguous
          * register block sizes used.
          */
         int *classes;

         /**
          * Mapping for register-allocated objects in *regs to the first
          * GRF for that object.
          */
         uint8_t *ra_reg_to_grf;

         /**
          * ra class for the aligned pairs we use for PLN, which doesn't
          * appear in *classes.
          */
         int aligned_pairs_class;
      } reg_sets[2];
d1345 37
d1396 5
a1436 2
   void (*saved_viewport)(struct gl_context *ctx,
                          GLint x, GLint y, GLsizei width, GLsizei height);
d1444 3
d1450 19
a1468 1
bool brwCreateContext(int api,
d1474 1
d1481 20
d1510 3
d1523 11
d1573 4
a1576 1
void brw_fs_alloc_reg_sets(struct brw_context *brw);
d1584 6
d1592 9
d1608 6
a1613 1
			     uint32_t *surf_offsets);
d1616 1
a1616 1
bool brw_is_hiz_depth_format(struct brw_context *ctx, gl_format format);
d1619 25
d1646 5
d1657 4
d1669 6
d1693 3
d1700 1
a1700 3
gen6_emit_3dstate_sample_mask(struct brw_context *brw,
                              unsigned num_samples, float coverage,
                              bool coverage_invert, unsigned sample_mask);
d1707 4
d1713 2
a1714 1
gen7_allocate_push_constants(struct brw_context *brw);
d1717 4
a1720 2
gen7_emit_urb_state(struct brw_context *brw, GLuint nr_vs_entries,
                    GLuint vs_size, GLuint vs_start);
d1723 3
d1731 1
a1731 1
static INLINE struct brw_context *
d1737 1
a1737 1
static INLINE struct brw_vertex_program *
d1743 1
a1743 1
static INLINE const struct brw_vertex_program *
d1749 7
a1755 1
static INLINE struct brw_fragment_program *
d1761 1
a1761 1
static INLINE const struct brw_fragment_program *
d1793 1
a1793 1
   return brw->cache.bo->offset + prog_offset;
d1799 1
d1808 1
d1832 53
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d39 1
d41 3
d126 4
a134 1
   BRW_STATE_INPUT_DIMENSIONS,
a138 1
   BRW_STATE_WM_INPUT_DIMENSIONS,
d140 1
a140 1
   BRW_STATE_WM_SURFACES,
a146 2
   BRW_STATE_NR_WM_SURFACES,
   BRW_STATE_NR_VS_SURFACES,
a148 1
   BRW_STATE_WM_CONSTBUF,
d151 6
a161 1
#define BRW_NEW_INPUT_DIMENSIONS        (1 << BRW_STATE_INPUT_DIMENSIONS)
a165 1
#define BRW_NEW_WM_INPUT_DIMENSIONS     (1 << BRW_STATE_WM_INPUT_DIMENSIONS)
d167 1
a167 1
#define BRW_NEW_WM_SURFACES		(1 << BRW_STATE_WM_SURFACES)
a178 2
#define BRW_NEW_NR_WM_SURFACES         (1 << BRW_STATE_NR_WM_SURFACES)
#define BRW_NEW_NR_VS_SURFACES         (1 << BRW_STATE_NR_VS_SURFACES)
a180 1
#define BRW_NEW_WM_CONSTBUF            (1 << BRW_STATE_WM_CONSTBUF)
d183 6
d201 64
a269 1
   GLboolean use_const_buffer;
a276 3

   /** for debugging, which texture units are referenced */
   GLbitfield tex_units_used;
d282 2
a287 11
struct brw_shader_program {
   struct gl_shader_program base;
};

enum param_conversion {
   PARAM_NO_CONVERT,
   PARAM_CONVERT_F2I,
   PARAM_CONVERT_F2U,
   PARAM_CONVERT_F2B,
};

d291 4
a294 1
 * compiled programs:
d308 1
a308 1
   GLboolean error;
d312 7
a318 1
   /* Pointer to tracked values (only valid once
d320 22
d343 47
a389 4
   const float *param[MAX_UNIFORMS * 4]; /* should be: BRW_MAX_CURBE */
   enum param_conversion param_convert[MAX_UNIFORMS * 4];
   const float *pull_param[MAX_UNIFORMS * 4];
   enum param_conversion pull_param_convert[MAX_UNIFORMS * 4];
d392 22
d437 6
d445 7
a451 1
struct brw_vs_prog_data {
a454 1
   GLbitfield64 outputs_written;
d456 2
d459 3
a461 3
   GLuint inputs_read;

   /* Used for calculating urb partitions:
d464 6
d473 2
a474 1
/* Size == 0 if output either not written, or always [0,0,0,1]
d476 6
a481 2
struct brw_vs_ouput_sizes {
   GLubyte output_size[VERT_RESULT_MAX];
a483 1

d491 21
a511 3
 * Size of our surface binding table for the WM.
 * This contains pointers to the drawing surfaces and current texture
 * objects and shader constant buffers (+2).
d513 7
a519 1
#define BRW_WM_MAX_SURF (BRW_MAX_DRAW_BUFFERS + BRW_MAX_TEX_UNIT + 1)
d522 59
a580 2
 * Helpers to convert drawing buffers, textures and constant buffers
 * to surface binding table indexes, for WM.
d583 12
a594 2
#define SURF_INDEX_FRAG_CONST_BUFFER (BRW_MAX_DRAW_BUFFERS) 
#define SURF_INDEX_TEXTURE(t)        (BRW_MAX_DRAW_BUFFERS + 1 + (t))
d596 2
a597 5
/**
 * Size of surface binding table for the VS.
 * Only one constant buffer for now.
 */
#define BRW_VS_MAX_SURF 1
d600 4
a603 1
 * Only a VS constant buffer
d605 1
a605 2
#define SURF_INDEX_VERT_CONST_BUFFER 0

a607 3
   BRW_BLEND_STATE,
   BRW_DEPTH_STENCIL_STATE,
   BRW_COLOR_CALC_STATE,
d611 2
d649 3
d662 9
a681 1
   void (*prepare)( struct brw_context *brw );
d685 13
a699 3
#define CACHE_NEW_BLEND_STATE            (1<<BRW_BLEND_STATE)
#define CACHE_NEW_DEPTH_STENCIL_STATE    (1<<BRW_DEPTH_STENCIL_STATE)
#define CACHE_NEW_COLOR_CALC_STATE       (1<<BRW_COLOR_CALC_STATE)
d735 1
a743 2
   /** Size of a complete element */
   GLuint element_size;
a747 6


struct brw_vertex_info {
   GLuint sizes[ATTRIB_BIT_DWORDS * 2]; /* sizes:2[VERT_ATTRIB_MAX] */
};

d753 1
a753 2
   /** First index in bo with query data for this object. */
   int first_index;
d760 1
a760 1
 * brw_context is derived from intel_context.
d764 71
a834 2
   struct intel_context intel;  /**< base class, must be first field */
   GLuint primitive;
d836 25
a860 6
   GLboolean emit_state_always;
   GLboolean has_surface_tile_offset;
   GLboolean has_compr4;
   GLboolean has_negative_rhw_bug;
   GLboolean has_aa_line_parameters;
   GLboolean has_pln;
d862 46
a909 13
      /**
       * List of buffers accumulated in brw_validate_state to receive
       * drm_intel_bo_check_aperture treatment before exec, so we can
       * know if we should flush the batch and try again before
       * emitting primitives.
       *
       * This can be a fixed number as we only have a limited number of
       * objects referenced from the batchbuffer in a primitive emit,
       * consisting of the vertex buffers, pipelined state pointers,
       * the CURBE, the depth buffer, and a query BO.
       */
      drm_intel_bo *validated_bos[VERT_ATTRIB_MAX + BRW_WM_MAX_SURF + 16];
      int validated_bo_count;
d915 3
a920 5
      struct {
	      uint32_t handle;
	      uint32_t offset;
	      uint32_t stride;
      } current_buffers[VERT_ATTRIB_MAX];
d924 1
a924 1
      GLuint nr_buffers, nr_current_buffers;
a928 1
      struct brw_vertex_info info;
d965 8
a972 2
   int vs_max_threads;
   int wm_max_threads;
d981 1
a981 1
      GLboolean constrained;
a991 9
      /* gen6:
       * The length of each URB entry owned by the VS (or GS), as
       * a number of 1024-bit (128-byte) rows.  Should be >= 1.
       *
       * gen7: Same meaning, but in 512-bit (64-byte) rows.
       */
      GLuint vs_size;
      GLuint gs_size;

d998 5
d1038 15
a1054 1
      int8_t *constant_map; /* variable array following prog_data */
d1056 1
a1061 5
      /** Binding table of pointers to surf_bo entries */
      uint32_t bind_bo_offset;
      uint32_t surf_offset[BRW_VS_MAX_SURF];
      GLuint nr_surfaces;      

d1064 20
d1089 1
a1089 1
      GLboolean prog_active;
d1093 3
a1124 6
      struct brw_wm_compile *compile_data;

      /** Input sizes, calculated from active vertex program.
       * One bit per fragment program input attribute.
       */
      GLbitfield input_size_masks[4];
a1130 1
      GLuint nr_surfaces;      
a1131 1
      GLuint max_threads;
d1134 5
a1138 2
      GLuint sampler_count;
      uint32_t sampler_offset;
a1142 3
      /** Binding table of pointers to surf_bo entries */
      uint32_t bind_bo_offset;
      uint32_t surf_offset[BRW_WM_MAX_SURF];
d1152 25
d1189 1
a1189 3
      drm_intel_bo *bo;
      int index;
      GLboolean active;
d1191 24
a1214 1
   /* Used to give every program string a unique id
d1216 3
a1218 1
   GLuint program_id;
d1220 5
a1224 3
   int num_prepare_atoms, num_emit_atoms;
   struct brw_tracked_state prepare_atoms[64], emit_atoms[64];
};
d1226 2
d1229 15
a1243 7
#define BRW_PACKCOLOR8888(r,g,b,a)  ((r<<24) | (g<<16) | (b<<8) | a)

struct brw_instruction_info {
    char    *name;
    int	    nsrc;
    int	    ndst;
    GLboolean is_arith;
a1244 1
extern const struct brw_instruction_info brw_opcodes[128];
d1254 20
a1273 4
GLboolean brwCreateContext( int api,
			    const struct gl_config *mesaVis,
			    __DRIcontext *driContextPriv,
			    void *sharedContextPrivate);
d1278 2
a1279 2
void brw_init_queryobj_functions(struct dd_function_table *functions);
void brw_prepare_query_begin(struct brw_context *brw);
d1283 3
d1289 2
a1290 1
void brw_debug_batch(struct intel_context *intel);
d1303 10
d1322 4
d1329 75
a1437 29
static inline
float convert_param(enum param_conversion conversion, float param)
{
   union {
      float f;
      uint32_t u;
      int32_t i;
   } fi;

   switch (conversion) {
   case PARAM_NO_CONVERT:
      return param;
   case PARAM_CONVERT_F2I:
      fi.i = param;
      return fi.f;
   case PARAM_CONVERT_F2U:
      fi.u = param;
      return fi.f;
   case PARAM_CONVERT_F2B:
      if (param != 0.0)
	 fi.i = 1;
      else
	 fi.i = 0;
      return fi.f;
   default:
      return param;
   }
}

d1453 1
a1453 3
   struct intel_context *intel = &brw->intel;

   if (intel->gen >= 5) {
d1458 1
a1458 1
   drm_intel_bo_emit_reloc(intel->batch.bo,
d1467 38
a1504 1
GLboolean brw_do_cubemap_normalize(struct exec_list *instructions);
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d123 43
a165 14
#define BRW_NEW_URB_FENCE               0x1
#define BRW_NEW_FRAGMENT_PROGRAM        0x2
#define BRW_NEW_VERTEX_PROGRAM          0x4
#define BRW_NEW_INPUT_DIMENSIONS        0x8
#define BRW_NEW_CURBE_OFFSETS           0x10
#define BRW_NEW_REDUCED_PRIMITIVE       0x20
#define BRW_NEW_PRIMITIVE               0x40
#define BRW_NEW_CONTEXT                 0x80
#define BRW_NEW_WM_INPUT_DIMENSIONS     0x100
#define BRW_NEW_PSP                     0x800
#define BRW_NEW_WM_SURFACES		0x1000
#define BRW_NEW_BINDING_TABLE		0x2000
#define BRW_NEW_INDICES			0x4000
#define BRW_NEW_VERTICES		0x8000
d170 9
a178 8
#define BRW_NEW_BATCH			0x10000
/** brw->depth_region updated */
#define BRW_NEW_DEPTH_BUFFER		0x20000
#define BRW_NEW_NR_WM_SURFACES		0x40000
#define BRW_NEW_NR_VS_SURFACES		0x80000
#define BRW_NEW_INDEX_BUFFER		0x100000
#define BRW_NEW_VS_CONSTBUF		0x200000
#define BRW_NEW_WM_CONSTBUF		0x200000
d237 3
a239 1
   GLuint total_grf;
d246 1
a343 1
   BRW_SAMPLER_DEFAULT_COLOR,
d370 1
a371 2
   drm_intel_bo **reloc_bufs;
   GLuint nr_reloc_bufs;
d373 2
a374 1
   drm_intel_bo *bo;
d385 1
d388 2
a389 6
   char *name[BRW_MAX_CACHE];

   /* Record of the last BOs chosen for each cache_id.  Used to set
    * brw->state.dirty.cache when a new cache item is chosen.
    */
   drm_intel_bo *last_bo[BRW_MAX_CACHE];
a412 1
#define CACHE_NEW_SAMPLER_DEFAULT_COLOR  (1<<BRW_SAMPLER_DEFAULT_COLOR)
d439 7
d449 2
a454 4
   /** Number of uploaded elements for this input. */
   GLuint count;
   /** Byte stride between elements in the uploaded array */
   GLuint stride;
a456 2
   /** Buffer object containing the uploaded vertex data */
   drm_intel_bo *bo;
d491 1
a491 1
;
a493 5

      GLuint nr_color_regions;
      struct intel_region *color_regions[MAX_DRAW_BUFFERS];
      struct intel_region *depth_region;

d514 6
d523 1
a523 8

#define BRW_NR_UPLOAD_BUFS 17
#define BRW_UPLOAD_INIT_SIZE (128*1024)

      struct {
	 drm_intel_bo *bo;
	 GLuint offset;
      } upload;
d530 5
d545 1
a545 1
      /* Updates to these fields are signaled by BRW_NEW_INDEX_BUFFER. */
d547 2
a548 2
      unsigned int offset;
      unsigned int size;
a560 5

   /* For populating the gtt:
    */
   GLuint next_free_page;

d577 2
a578 2
      GLuint max_vs_handles;	/* Maximum number of VS handles */
      GLuint max_gs_handles;	/* Maximum number of GS handles */
d586 6
a591 1
      /* gen6 */
a639 2
      drm_intel_bo *prog_bo;
      drm_intel_bo *state_bo;
d641 3
a645 1
      drm_intel_bo *bind_bo;
a646 1
      drm_intel_bo *surf_bo[BRW_VS_MAX_SURF];
d649 3
d658 3
a660 2
      drm_intel_bo *prog_bo;
      drm_intel_bo *state_bo;
d666 10
a675 3
      drm_intel_bo *prog_bo;
      drm_intel_bo *state_bo;
      drm_intel_bo *vp_bo;
d682 4
a685 3
      drm_intel_bo *prog_bo;
      drm_intel_bo *state_bo;
      drm_intel_bo *vp_bo;
d697 3
a699 2
      /** Array of surface default colors (texture border color) */
      drm_intel_bo *sdc_bo[BRW_MAX_TEX_UNIT];
d708 4
a711 1
      drm_intel_bo *sampler_bo;
a713 1
      drm_intel_bo *bind_bo;
a714 1
      drm_intel_bo *surf_bo[BRW_WM_MAX_SURF];
d716 1
a717 2
      drm_intel_bo *prog_bo;
      drm_intel_bo *state_bo;
d720 1
a720 1
       *  This is the push constant BO on gen6.
d724 1
a724 1
      drm_intel_bo *push_const_bo;
a728 10
      /* gen4 */
      drm_intel_bo *prog_bo;
      drm_intel_bo *vp_bo;

      /* gen6 */
      drm_intel_bo *blend_state_bo;
      drm_intel_bo *depth_stencil_state_bo;
      drm_intel_bo *color_calc_state_bo;

      drm_intel_bo *state_bo;
d730 3
d744 3
a801 3
/* brw_cc.c */
void brw_update_cc_vp(struct brw_context *brw);

a808 4
/* brw_state.c */
void brw_enable(struct gl_context * ctx, GLenum cap, GLboolean state);
void brw_depth_range(struct gl_context *ctx, GLclampd nearval, GLclampd farval);

d872 31
a905 1

@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d134 1
d147 2
a165 1
   dri_bo *const_buffer;    /** Program constant buffer/surface */
a173 4
   GLboolean isGLSL;  /**< really, any IF/LOOP/CONT/BREAK instructions */

   GLboolean use_const_buffer;
   dri_bo *const_buffer;    /** Program constant buffer/surface */
d179 17
d211 1
d213 1
d218 4
a221 1
   const GLfloat *param[BRW_MAX_CURBE];
d275 1
a275 1
#define BRW_MAX_DRAW_BUFFERS 4
a323 2
   BRW_SS_SURFACE,
   BRW_SS_SURF_BIND,
d339 1
a339 1
   dri_bo **reloc_bufs;
d342 1
a342 1
   dri_bo *bo;
d360 1
a360 1
   dri_bo *last_bo[BRW_MAX_CACHE];
a396 2
#define CACHE_NEW_SURFACE                (1<<BRW_SS_SURFACE)
#define CACHE_NEW_SURF_BIND              (1<<BRW_SS_SURF_BIND)
d425 1
a425 1
   dri_bo *bo;
a436 3
   /** Doubly linked list of active query objects in the context. */
   struct brw_query_object *prev, *next;

d438 1
a438 1
   dri_bo *bo;
a442 3

   /* Total count of pixels from previous BOs */
   unsigned int count;
d459 1
d470 3
a472 2
       * dri_bo_check_aperture treatment before exec, so we can know if we
       * should flush the batch and try again before emitting primitives.
d479 1
a479 1
      dri_bo *validated_bos[VERT_ATTRIB_MAX + 16];
d483 1
a483 2
   struct brw_cache cache;  /** non-surface items */
   struct brw_cache surface_cache;  /* surface items */
d496 1
a496 1
	 dri_bo *bo;
d516 1
a516 1
      dri_bo *bo;
d552 3
d563 1
a563 4
/*       GLuint gs_size; */
/*       GLuint clip_size; */
/*       GLuint sf_size; */
/*       GLuint cs_size; */
d585 1
a585 1
      dri_bo *curbe_bo;
d591 6
d598 5
d610 3
a612 2
      dri_bo *prog_bo;
      dri_bo *state_bo;
d615 4
a618 2
      dri_bo *bind_bo;
      dri_bo *surf_bo[BRW_VS_MAX_SURF];
d626 2
a627 2
      dri_bo *prog_bo;
      dri_bo *state_bo;
d633 3
a635 3
      dri_bo *prog_bo;
      dri_bo *state_bo;
      dri_bo *vp_bo;
d642 3
a644 3
      dri_bo *prog_bo;
      dri_bo *state_bo;
      dri_bo *vp_bo;
d657 1
a657 1
      dri_bo *sdc_bo[BRW_MAX_TEX_UNIT];
d663 1
a663 1
      dri_bo *scratch_bo;
d666 1
a666 1
      dri_bo *sampler_bo;
d669 14
a682 5
      dri_bo *bind_bo;
      dri_bo *surf_bo[BRW_WM_MAX_SURF];

      dri_bo *prog_bo;
      dri_bo *state_bo;
d688 2
a689 2
      dri_bo *prog_bo;
      dri_bo *vp_bo;
d692 3
a694 3
      dri_bo *blend_state_bo;
      dri_bo *depth_stencil_state_bo;
      dri_bo *color_calc_state_bo;
d696 2
a697 1
      dri_bo *state_bo;
d701 2
a702 2
      struct brw_query_object active_head;
      dri_bo *bo;
d714 7
a720 1

d730 2
a731 1
GLboolean brwCreateContext( const __GLcontextModes *mesaVis,
d764 3
d772 5
a776 1
int brw_disasm (FILE *file, struct brw_instruction *inst);
d783 1
a783 1
brw_context( GLcontext *ctx )
d811 31
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d49 1
a49 1
 * preload into the GRF when spawining a thread.
d66 1
a66 1
 * by sending messages.  Message parameters are placed in contigous
d118 1
a118 1
#define BRW_FALLBACK_TEXTURE		 0x1
a131 1
#define BRW_NEW_INPUT_VARYING           0x200
d133 1
a133 1
#define BRW_NEW_FENCE                   0x2000
d143 3
a145 1
#define BRW_NEW_NR_SURFACES		0x40000
d158 2
d163 2
d168 1
a168 1

d171 2
a172 2
   GLuint id;
};
d174 2
d177 3
d195 1
a195 1
   GLuint nr_params;
d233 2
a234 1
   GLuint outputs_written;
d251 1
d253 30
a282 1
#define BRW_WM_MAX_SURF BRW_MAX_TEX_UNIT + MAX_DRAW_BUFFERS
d285 3
d296 1
a296 1
   BRW_SF_UNIT,
a324 1
   GLuint data_size;
a336 2
   GLuint key_size[BRW_MAX_CACHE];		/* for fixed-size keys */
   GLuint aux_size[BRW_MAX_CACHE];
d360 3
d398 2
a414 1
   GLuint varying;  /* varying:1[VERT_ATTRIB_MAX] */
a417 17



/* Cache for TNL programs.
 */
struct brw_tnl_cache_item {
   GLuint hash;
   void *key;
   void *data;
   struct brw_tnl_cache_item *next;
};

struct brw_tnl_cache {
   struct brw_tnl_cache_item **items;
   GLuint size, n_items;
};

d435 4
d441 1
a441 1
   struct intel_context intel;
d445 5
a449 3
   GLboolean tmp_fallback;
   GLboolean no_batch_wrap;

a451 2
      struct brw_tracked_state **atoms;
      GLuint nr_atoms;
d453 2
a454 2
      GLuint nr_draw_regions;
      struct intel_region *draw_regions[MAX_DRAW_BUFFERS];
d471 2
a472 1
   struct brw_cache cache;
d478 3
d504 1
d507 6
d525 6
d547 2
a548 1
/*       GLuint vs_size; */
d559 1
d566 2
a567 2
      GLuint wm_start;
      GLuint wm_size;
a573 5
      /* Dynamic tracker which changes to reflect the state referenced
       * by active fp and vp program parameters:
       */
      struct brw_tracked_state tracked_state;

a581 5
      /**
       *  Whether we should create a new bo instead of reusing the old one
       * (if we just dispatch the batch pointing at the old one.
       */
      GLboolean need_new_bo;
d586 1
d590 5
d626 2
a627 1
      /* Input sizes, calculated from active vertex program:
d629 1
a629 1
      GLuint input_size_masks[4];
d638 1
a638 1
      dri_bo *scratch_buffer;
d653 1
d655 7
a662 1
      dri_bo *vp_bo;
a684 2
void brw_do_flush( struct brw_context *brw, 
		   GLuint flags );
d690 1
a690 1
			    __DRIcontextPrivate *driContextPriv,
a708 4
void brwUpdateTextureState( struct intel_context *intel );
void brw_FrameBufferTexInit( struct brw_context *brw,
			     struct intel_region *region );
void brw_FrameBufferTexDestroy( struct brw_context *brw );
d722 3
a724 1
void brw_upload_constant_buffer_state(struct brw_context *brw);
d726 2
d739 23
a761 1
#define DO_SETUP_BITS ((1<<(FRAG_ATTRIB_MAX)) - 1)
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d38 1
a38 1
#include "imports.h"
a132 1
#define BRW_NEW_TNL_PROGRAM             0x400
a133 1
#define BRW_NEW_METAOPS                 0x1000
d135 2
a136 1
#define BRW_NEW_LOCK                    0x4000
d141 1
a141 1
#define BRW_NEW_BATCH			0x8000
d143 2
a144 1
#define BRW_NEW_DEPTH_BUFFER		0x10000
a159 1
   GLuint param_state;		/* flags indicating state tracked by params */
a166 1
   GLuint param_state;		/* flags indicating state tracked by params */
d240 1
a240 1
#define BRW_MAX_TEX_UNIT 8
a304 20

struct brw_state_pointers {
   struct gl_colorbuffer_attrib	*Color;
   struct gl_depthbuffer_attrib	*Depth;
   struct gl_fog_attrib		*Fog;
   struct gl_hint_attrib	*Hint;
   struct gl_light_attrib	*Light;
   struct gl_line_attrib	*Line;
   struct gl_point_attrib	*Point;
   struct gl_polygon_attrib	*Polygon;
   GLuint                       *PolygonStipple;
   struct gl_scissor_attrib	*Scissor;
   struct gl_stencil_attrib	*Stencil;
   struct gl_texture_attrib	*Texture;
   struct gl_transform_attrib	*Transform;
   struct gl_viewport_attrib	*Viewport;
   struct gl_vertex_program_state *VertexProgram; 
   struct gl_fragment_program_state *FragmentProgram;
};

d313 1
a313 1
   int (*prepare)( struct brw_context *brw );
d390 5
d396 10
a412 1
   GLboolean wrap;
d424 13
a438 1
   struct brw_state_pointers attribs;
d457 1
d461 4
a464 1
      /* Will be allocated on demand if needed.   
d466 1
a466 17
      struct brw_state_pointers attribs;
      struct gl_vertex_program *vp;
      struct gl_fragment_program *fp, *fp_tex;

      struct gl_buffer_object *vbo;

      struct intel_region *saved_draw_region;
      GLuint saved_nr_draw_regions;
      struct intel_region *saved_depth_region;

      GLuint restore_draw_buffers[MAX_DRAW_BUFFERS];
      GLuint restore_num_draw_buffers;

      struct gl_fragment_program *restore_fp;
      
      GLboolean active;
   } metaops;
d468 3
a470 4
   /* Track fixed function t&l in a vertex program:
    */
   struct gl_vertex_program *tnl_program;
   struct brw_tnl_cache tnl_program_cache;
d536 5
d610 6
a615 1
   
a639 2


d641 1
a641 1
 * brw_state.c
d643 4
a646 4
int brw_validate_state( struct brw_context *brw );
void brw_init_state( struct brw_context *brw );
void brw_destroy_state( struct brw_context *brw );

a660 7

/*======================================================================
 * brw_metaops.c
 */

void brw_init_metaops( struct brw_context *brw );
void brw_destroy_metaops( struct brw_context *brw );
@


1.1
log
@Initial revision
@
text
@a38 1
#include "brw_attrib.h"
d138 7
a144 2


d147 1
d149 5
a154 1
   GLuint brw;
d227 1
a227 1
   GLuint64EXT inputs_read;
d243 1
a243 1
#define BRW_WM_MAX_SURF BRW_MAX_TEX_UNIT + 1
d245 19
a263 5
/* Create a fixed sized struct for caching binding tables:
 */
struct brw_surface_binding_table {
   GLuint surf_ss_offset[BRW_WM_MAX_SURF];
};
d265 1
a265 10

struct brw_cache;

struct brw_mem_pool {
   struct buffer *buffer;

   GLuint size;
   GLuint offset;		/* offset of first free byte */

   struct brw_context *brw;
d269 7
d279 2
d282 1
a282 1
   GLuint offset;		/* offset within pool's buffer */
a290 4
   GLuint id;

   const char *name;

a291 1
   struct brw_mem_pool *pool;
a294 3
   
   GLuint key_size;		/* for fixed-size keys */
   GLuint aux_size;
d296 8
a303 4
   GLuint aub_type;
   GLuint aub_sub_type;
   
   GLuint last_addr;			/* offset of active item */
d335 2
a336 28
   void (*update)( struct brw_context *brw );
};


enum brw_cache_id {
   BRW_CC_VP,
   BRW_CC_UNIT,
   BRW_WM_PROG,
   BRW_SAMPLER_DEFAULT_COLOR,
   BRW_SAMPLER,
   BRW_WM_UNIT,
   BRW_SF_PROG,
   BRW_SF_VP,
   BRW_SF_UNIT,
   BRW_VS_UNIT,
   BRW_VS_PROG,
   BRW_GS_UNIT,
   BRW_GS_PROG,
   BRW_CLIP_VP,
   BRW_CLIP_UNIT,
   BRW_CLIP_PROG,

   /* These two are in the SS pool:
    */
   BRW_SS_SURFACE,
   BRW_SS_SURF_BIND,

   BRW_MAX_CACHE
a359 10



enum brw_mempool_id {
   BRW_GS_POOL,
   BRW_SS_POOL,
   BRW_MAX_POOL
};


d368 1
a368 1
/* Protect against a future where BRW_ATTRIB_MAX > 32.  Wouldn't life
d371 1
a371 1
#define ATTRIB_BIT_DWORDS  ((BRW_ATTRIB_MAX+31)/32)
d376 1
a376 3
   struct brw_vertex_element_state *vep;

   GLuint index;
d378 1
d380 6
a385 1
   GLuint vbo_rebase_offset;
d391 2
a392 2
   GLuint64EXT varying;  /* varying:1[BRW_ATTRIB_MAX] */
   GLuint sizes[ATTRIB_BIT_DWORDS * 2]; /* sizes:2[BRW_ATTRIB_MAX] */
d422 1
d429 2
a430 2

      struct intel_region *draw_region;
d435 1
a435 2
   struct brw_mem_pool pool[BRW_MAX_POOL];
   struct brw_cache cache[BRW_MAX_CACHE];
d439 1
a439 8
      /* Fallback values for inputs not supplied: 
       */
      struct gl_client_array current_values[BRW_ATTRIB_MAX];

      /* Arrays with buffer objects to copy non-bufferobj arrays into
       * for upload:
       */
      struct gl_client_array vbo_array[BRW_ATTRIB_MAX];
d445 1
a445 2
	 struct gl_buffer_object *vbo[BRW_NR_UPLOAD_BUFS];
	 GLuint buf;
a446 2
	 GLuint size;
	 GLuint wrap;
a448 5
      /* Currenly bound arrays, including fallbacks to current_values
       * above:
       */
      struct brw_vertex_element inputs[BRW_ATTRIB_MAX];

d460 1
a460 1
      struct gl_fragment_program *fp;
d465 1
d468 5
a472 1
      GLuint restore_draw_mask;
d483 2
a484 2
   struct gl_vertex_program *vertex_program;
   struct gl_fragment_program *fragment_program;
d537 5
a541 1
      GLuint gs_offset;
d550 2
a551 2
      GLuint prog_gs_offset;
      GLuint state_gs_offset;	
d558 2
a559 2
      GLuint prog_gs_offset;
      GLuint state_gs_offset;	
d565 3
a567 3
      GLuint prog_gs_offset;
      GLuint vp_gs_offset;
      GLuint state_gs_offset;	
d574 3
a576 3
      GLuint prog_gs_offset;
      GLuint vp_gs_offset;
      GLuint state_gs_offset;
d581 1
d587 2
a588 5

      /* State structs
       */
      struct brw_sampler_default_color sdc[BRW_MAX_TEX_UNIT];
      struct brw_sampler_state sampler[BRW_MAX_TEX_UNIT];
d594 1
a594 2
      struct buffer *scratch_buffer;
      GLuint scratch_buffer_size;
d597 1
a597 1
      GLuint sampler_gs_offset;
d599 3
a601 2
      struct brw_surface_binding_table bind;
      GLuint bind_ss_offset;
d603 2
a604 2
      GLuint prog_gs_offset;
      GLuint state_gs_offset;
d609 3
a611 2
      GLuint vp_gs_offset;
      GLuint state_gs_offset;
d644 1
a644 1
void brw_validate_state( struct brw_context *brw );
d649 4
d658 4
a661 1
void brwInitTextureFuncs( struct dd_function_table *functions );
d688 1
a688 1
static inline struct brw_context *
d693 2
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d488 1
a488 1
      struct gl_fragment_program *fp, *fp_tex;
a495 2
      struct gl_fragment_program *restore_fp;
      
a674 2
void brw_FrameBufferTexInit( struct brw_context *brw );
void brw_FrameBufferTexDestroy( struct brw_context *brw );
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d39 1
d218 1
a218 1
   GLuint inputs_read;
d385 1
a385 1
/* Protect against a future where VERT_ATTRIB_MAX > 32.  Wouldn't life
d388 1
a388 1
#define ATTRIB_BIT_DWORDS  ((VERT_ATTRIB_MAX+31)/32)
d404 2
a405 2
   GLuint varying;  /* varying:1[VERT_ATTRIB_MAX] */
   GLuint sizes[ATTRIB_BIT_DWORDS * 2]; /* sizes:2[VERT_ATTRIB_MAX] */
d452 3
d459 1
a459 3
      struct gl_client_array vbo_array[VERT_ATTRIB_MAX];

      struct brw_vertex_element inputs[VERT_ATTRIB_MAX];
d472 5
d508 2
a509 2
   const struct gl_vertex_program *vertex_program;
   const struct gl_fragment_program *fragment_program;
a601 1
      struct brw_wm_compile *compile_data;
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d38 1
a38 1
#include "main/imports.h"
d49 1
a49 1
 * preload into the GRF when spawning a thread.
d66 1
a66 1
 * by sending messages.  Message parameters are placed in contiguous
d118 1
a118 1

d132 2
d135 5
a139 16
#define BRW_NEW_WM_SURFACES		0x1000
#define BRW_NEW_BINDING_TABLE		0x2000
#define BRW_NEW_INDICES			0x4000
#define BRW_NEW_VERTICES		0x8000
/**
 * Used for any batch entry with a relocated pointer that will be used
 * by any 3D rendering.
 */
#define BRW_NEW_BATCH			0x10000
/** brw->depth_region updated */
#define BRW_NEW_DEPTH_BUFFER		0x20000
#define BRW_NEW_NR_WM_SURFACES		0x40000
#define BRW_NEW_NR_VS_SURFACES		0x80000
#define BRW_NEW_INDEX_BUFFER		0x100000
#define BRW_NEW_VS_CONSTBUF		0x200000
#define BRW_NEW_WM_CONSTBUF		0x200000
a141 1
   /** State update flags signalled by mesa internals */
d143 1
a143 3
   /**
    * State update flags signalled as the result of brw_tracked_state updates
    */
a144 2
   /** State update flags signalled by brw_state_cache.c searches */
   GLuint cache;
a146 2

/** Subclass of Mesa vertex program */
d150 1
a150 1
   GLboolean use_const_buffer;
d154 1
a154 1
/** Subclass of Mesa fragment program */
d157 2
a158 4
   GLuint id;  /**< serial no. to identify frag progs, never re-used */

   /** for debugging, which texture units are referenced */
   GLbitfield tex_units_used;
a160 2
struct brw_shader {
   struct gl_shader base;
a161 3
   /** Shader IR transformed for native compile, at link time. */
   struct exec_list *ir;
};
a162 10
struct brw_shader_program {
   struct gl_shader_program base;
};

enum param_conversion {
   PARAM_NO_CONVERT,
   PARAM_CONVERT_F2I,
   PARAM_CONVERT_F2U,
   PARAM_CONVERT_F2B,
};
d177 1
a177 2
   GLuint nr_params;       /**< number of float params/constants */
   GLuint nr_pull_params;
a178 1
   int dispatch_width;
d183 1
a183 4
   const float *param[MAX_UNIFORMS * 4]; /* should be: BRW_MAX_CURBE */
   enum param_conversion param_convert[MAX_UNIFORMS * 4];
   const float *pull_param[MAX_UNIFORMS * 4];
   enum param_conversion pull_param_convert[MAX_UNIFORMS * 4];
d215 1
a215 2
   GLbitfield64 outputs_written;
   GLuint nr_params;       /**< number of float params/constants */
d232 2
a233 2
/** Number of texture sampler units */
#define BRW_MAX_TEX_UNIT 16
d235 1
a235 7
/** Max number of render targets in a shader */
#define BRW_MAX_DRAW_BUFFERS 8

/**
 * Size of our surface binding table for the WM.
 * This contains pointers to the drawing surfaces and current texture
 * objects and shader constant buffers (+2).
d237 3
a239 1
#define BRW_WM_MAX_SURF (BRW_MAX_DRAW_BUFFERS + BRW_MAX_TEX_UNIT + 1)
a240 7
/**
 * Helpers to convert drawing buffers, textures and constant buffers
 * to surface binding table indexes, for WM.
 */
#define SURF_INDEX_DRAW(d)           (d)
#define SURF_INDEX_FRAG_CONST_BUFFER (BRW_MAX_DRAW_BUFFERS) 
#define SURF_INDEX_TEXTURE(t)        (BRW_MAX_DRAW_BUFFERS + 1 + (t))
d242 1
a242 5
/**
 * Size of surface binding table for the VS.
 * Only one constant buffer for now.
 */
#define BRW_VS_MAX_SURF 1
d244 2
a245 4
/**
 * Only a VS constant buffer
 */
#define SURF_INDEX_VERT_CONST_BUFFER 0
d247 2
d250 1
a250 22
enum brw_cache_id {
   BRW_BLEND_STATE,
   BRW_DEPTH_STENCIL_STATE,
   BRW_COLOR_CALC_STATE,
   BRW_CC_VP,
   BRW_CC_UNIT,
   BRW_WM_PROG,
   BRW_SAMPLER_DEFAULT_COLOR,
   BRW_SAMPLER,
   BRW_WM_UNIT,
   BRW_SF_PROG,
   BRW_SF_VP,
   BRW_SF_UNIT, /* scissor state on gen6 */
   BRW_VS_UNIT,
   BRW_VS_PROG,
   BRW_GS_UNIT,
   BRW_GS_PROG,
   BRW_CLIP_VP,
   BRW_CLIP_UNIT,
   BRW_CLIP_PROG,

   BRW_MAX_CACHE
a253 7
   /**
    * Effectively part of the key, cache_id identifies what kind of state
    * buffer is involved, and also which brw->state.dirty.cache flag should
    * be set when this cache item is chosen.
    */
   enum brw_cache_id cache_id;
   /** 32-bit hash of the key data */
a256 2
   drm_intel_bo **reloc_bufs;
   GLuint nr_reloc_bufs;
d258 2
a259 1
   drm_intel_bo *bo;
d267 4
d272 1
d276 10
a286 1
   char *name[BRW_MAX_CACHE];
d288 17
a304 4
   /* Record of the last BOs chosen for each cache_id.  Used to set
    * brw->state.dirty.cache when a new cache item is chosen.
    */
   drm_intel_bo *last_bo[BRW_MAX_CACHE];
a306 1

d315 28
a342 2
   void (*prepare)( struct brw_context *brw );
   void (*emit)( struct brw_context *brw );
a346 3
#define CACHE_NEW_BLEND_STATE            (1<<BRW_BLEND_STATE)
#define CACHE_NEW_DEPTH_STENCIL_STATE    (1<<BRW_DEPTH_STENCIL_STATE)
#define CACHE_NEW_COLOR_CALC_STATE       (1<<BRW_COLOR_CALC_STATE)
d363 12
d392 3
a394 3
   /** The corresponding Mesa vertex attribute */
   gl_vert_attrib attrib;
   /** Size of a complete element */
a395 1
   /** Number of uploaded elements for this input. */
d397 1
a397 6
   /** Byte stride between elements in the uploaded array */
   GLuint stride;
   /** Offset of the first element within the buffer object */
   unsigned int offset;
   /** Buffer object containing the uploaded vertex data */
   drm_intel_bo *bo;
d403 1
a406 2
struct brw_query_object {
   struct gl_query_object Base;
d408 9
a416 6
   /** Last query BO associated with this query. */
   drm_intel_bo *bo;
   /** First index in bo with query data for this object. */
   int first_index;
   /** Last index in bo with query data for this object. */
   int last_index;
d419 6
a425 3
/**
 * brw_context is derived from intel_context.
 */
d428 1
a428 1
   struct intel_context intel;  /**< base class, must be first field */
d432 3
a434 6
   GLboolean has_surface_tile_offset;
   GLboolean has_compr4;
   GLboolean has_negative_rhw_bug;
   GLboolean has_aa_line_parameters;
   GLboolean has_pln;
;
d437 2
d440 2
a441 2
      GLuint nr_color_regions;
      struct intel_region *color_regions[MAX_DRAW_BUFFERS];
a442 14

      /**
       * List of buffers accumulated in brw_validate_state to receive
       * drm_intel_bo_check_aperture treatment before exec, so we can
       * know if we should flush the batch and try again before
       * emitting primitives.
       *
       * This can be a fixed number as we only have a limited number of
       * objects referenced from the batchbuffer in a primitive emit,
       * consisting of the vertex buffers, pipelined state pointers,
       * the CURBE, the depth buffer, and a query BO.
       */
      drm_intel_bo *validated_bos[VERT_ATTRIB_MAX + BRW_WM_MAX_SURF + 16];
      int validated_bo_count;
d445 3
a447 1
   struct brw_cache cache;
d451 6
a458 3
      struct brw_vertex_element *enabled[VERT_ATTRIB_MAX];
      GLuint nr_enabled;

d463 2
a464 1
	 drm_intel_bo *bo;
d466 2
a473 1
      unsigned int min_index, max_index;
d477 1
a477 4
      /**
       * Index buffer for this draw_prims call.
       *
       * Updates are signaled by BRW_NEW_INDICES.
d479 14
a492 1
      const struct _mesa_index_buffer *ib;
d494 4
a497 10
      /* Updates to these fields are signaled by BRW_NEW_INDEX_BUFFER. */
      drm_intel_bo *bo;
      unsigned int offset;
      unsigned int size;
      /* Offset to index buffer index to use in CMD_3D_PRIM so that we can
       * avoid re-uploading the IB packet over and over if we're actually
       * referencing the same index buffer.
       */
      unsigned int start_vertex_offset;
   } ib;
a508 6
   /* hw-dependent 3DSTATE_VF_STATISTICS opcode */
   uint32_t CMD_VF_STATISTICS;
   /* hw-dependent 3DSTATE_PIPELINE_SELECT opcode */
   uint32_t CMD_PIPELINE_SELECT;
   int vs_max_threads;
   int wm_max_threads;
a518 3
      GLuint max_vs_handles;	/* Maximum number of VS handles */
      GLuint max_gs_handles;	/* Maximum number of GS handles */

d525 5
a529 3
      /* gen6 */
      GLuint vs_size;
      GLuint gs_size;
a535 1
      GLuint size; /* Hardware URB size, in KB. */
d542 2
a543 2
      GLuint wm_start;  /**< pos of first wm const in CURBE buffer */
      GLuint wm_size;   /**< number of float[4] consts, multiple of 16 */
d550 2
a551 11
      drm_intel_bo *curbe_bo;
      /** Offset within curbe_bo of space for current curbe entry */
      GLuint curbe_offset;
      /** Offset within curbe_bo of space for next curbe entry */
      GLuint curbe_next_offset;

      /**
       * Copy of the last set of CURBEs uploaded.  Frequently we'll end up
       * in brw_curbe.c with the same set of constant data to be uploaded,
       * so we'd rather not upload new constants in that case (it can cause
       * a pipeline bubble since only up to 4 can be pipelined at a time).
d553 4
a557 5
      /**
       * Allocation for where to calculate the next set of CURBEs.
       * It's a hot enough path that malloc/free of that data matters.
       */
      GLfloat *next_buf;
a562 1
      int8_t *constant_map; /* variable array following prog_data */
d564 2
a565 10
      drm_intel_bo *prog_bo;
      drm_intel_bo *state_bo;
      drm_intel_bo *const_bo;

      /** Binding table of pointers to surf_bo entries */
      drm_intel_bo *bind_bo;
      uint32_t bind_bo_offset;
      drm_intel_bo *surf_bo[BRW_VS_MAX_SURF];
      uint32_t surf_offset[BRW_VS_MAX_SURF];
      GLuint nr_surfaces;      
d572 2
a573 2
      drm_intel_bo *prog_bo;
      drm_intel_bo *state_bo;
d579 3
a581 3
      drm_intel_bo *prog_bo;
      drm_intel_bo *state_bo;
      drm_intel_bo *vp_bo;
d588 3
a590 3
      drm_intel_bo *prog_bo;
      drm_intel_bo *state_bo;
      drm_intel_bo *vp_bo;
d597 1
a597 2
      /** Input sizes, calculated from active vertex program.
       * One bit per fragment program input attribute.
d599 2
a600 1
      GLbitfield input_size_masks[4];
d602 4
a605 2
      /** Array of surface default colors (texture border color) */
      drm_intel_bo *sdc_bo[BRW_MAX_TEX_UNIT];
d611 2
a612 1
      drm_intel_bo *scratch_bo;
d615 4
a618 1
      drm_intel_bo *sampler_bo;
d620 2
a621 15
      /** Binding table of pointers to surf_bo entries */
      drm_intel_bo *bind_bo;
      uint32_t bind_bo_offset;
      drm_intel_bo *surf_bo[BRW_WM_MAX_SURF];
      uint32_t surf_offset[BRW_WM_MAX_SURF];

      drm_intel_bo *prog_bo;
      drm_intel_bo *state_bo;
      drm_intel_bo *const_bo; /* pull constant buffer. */
      /**
       *  This is the push constant BO on gen6.
       *
       * Pre-gen6, push constants live in the CURBE.
       */
      drm_intel_bo *push_const_bo;
d626 2
a627 11
      /* gen4 */
      drm_intel_bo *prog_bo;
      drm_intel_bo *vp_bo;

      /* gen6 */
      drm_intel_bo *blend_state_bo;
      drm_intel_bo *depth_stencil_state_bo;
      drm_intel_bo *color_calc_state_bo;

      drm_intel_bo *state_bo;
      uint32_t state_offset;
d630 1
a630 6
   struct {
      struct brw_query_object *obj;
      drm_intel_bo *bo;
      int index;
      GLboolean active;
   } query;
d639 1
a639 7
struct brw_instruction_info {
    char    *name;
    int	    nsrc;
    int	    ndst;
    GLboolean is_arith;
};
extern const struct brw_instruction_info brw_opcodes[128];
d645 2
d651 2
a652 3
GLboolean brwCreateContext( int api,
			    const struct gl_config *mesaVis,
			    __DRIcontext *driContextPriv,
d655 2
d658 1
a658 1
 * brw_queryobj.c
d660 5
a664 4
void brw_init_queryobj_functions(struct dd_function_table *functions);
void brw_prepare_query_begin(struct brw_context *brw);
void brw_emit_query_begin(struct brw_context *brw);
void brw_emit_query_end(struct brw_context *brw);
d667 1
a667 1
 * brw_state_dump.c
d669 4
a672 1
void brw_debug_batch(struct intel_context *intel);
d675 1
a675 1
 * brw_tex.c
d677 3
a679 1
void brw_validate_textures( struct brw_context *brw );
d692 1
a692 6
/* brw_cc.c */
void brw_update_cc_vp(struct brw_context *brw);

/* brw_curbe.c
 */
void brw_upload_cs_urb_state(struct brw_context *brw);
a693 6
/* brw_disasm.c */
int brw_disasm (FILE *file, struct brw_instruction *inst, int gen);

/* brw_state.c */
void brw_enable(struct gl_context * ctx, GLenum cap, GLboolean state);
void brw_depth_range(struct gl_context *ctx, GLclampd nearval, GLclampd farval);
d699 2
a700 2
static INLINE struct brw_context *
brw_context( struct gl_context *ctx )
a703 55

static INLINE struct brw_vertex_program *
brw_vertex_program(struct gl_vertex_program *p)
{
   return (struct brw_vertex_program *) p;
}

static INLINE const struct brw_vertex_program *
brw_vertex_program_const(const struct gl_vertex_program *p)
{
   return (const struct brw_vertex_program *) p;
}

static INLINE struct brw_fragment_program *
brw_fragment_program(struct gl_fragment_program *p)
{
   return (struct brw_fragment_program *) p;
}

static INLINE const struct brw_fragment_program *
brw_fragment_program_const(const struct gl_fragment_program *p)
{
   return (const struct brw_fragment_program *) p;
}

static inline
float convert_param(enum param_conversion conversion, float param)
{
   union {
      float f;
      uint32_t u;
      int32_t i;
   } fi;

   switch (conversion) {
   case PARAM_NO_CONVERT:
      return param;
   case PARAM_CONVERT_F2I:
      fi.i = param;
      return fi.f;
   case PARAM_CONVERT_F2U:
      fi.u = param;
      return fi.f;
   case PARAM_CONVERT_F2B:
      if (param != 0.0)
	 fi.i = 1;
      else
	 fi.i = 0;
      return fi.f;
   default:
      return param;
   }
}

GLboolean brw_do_cubemap_normalize(struct exec_list *instructions);
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@a38 1
#include "main/macros.h"
a39 3
#ifdef __cplusplus
extern "C" {
#endif
d122 15
a136 47
struct brw_instruction;
struct brw_vs_prog_key;
struct brw_wm_prog_key;
struct brw_wm_prog_data;

enum brw_state_id {
   BRW_STATE_URB_FENCE,
   BRW_STATE_FRAGMENT_PROGRAM,
   BRW_STATE_VERTEX_PROGRAM,
   BRW_STATE_CURBE_OFFSETS,
   BRW_STATE_REDUCED_PRIMITIVE,
   BRW_STATE_PRIMITIVE,
   BRW_STATE_CONTEXT,
   BRW_STATE_PSP,
   BRW_STATE_SURFACES,
   BRW_STATE_VS_BINDING_TABLE,
   BRW_STATE_GS_BINDING_TABLE,
   BRW_STATE_PS_BINDING_TABLE,
   BRW_STATE_INDICES,
   BRW_STATE_VERTICES,
   BRW_STATE_BATCH,
   BRW_STATE_INDEX_BUFFER,
   BRW_STATE_VS_CONSTBUF,
   BRW_STATE_PROGRAM_CACHE,
   BRW_STATE_STATE_BASE_ADDRESS,
   BRW_STATE_VUE_MAP_GEOM_OUT,
   BRW_STATE_TRANSFORM_FEEDBACK,
   BRW_STATE_RASTERIZER_DISCARD,
   BRW_STATE_STATS_WM,
   BRW_STATE_UNIFORM_BUFFER,
   BRW_STATE_META_IN_PROGRESS,
};

#define BRW_NEW_URB_FENCE               (1 << BRW_STATE_URB_FENCE)
#define BRW_NEW_FRAGMENT_PROGRAM        (1 << BRW_STATE_FRAGMENT_PROGRAM)
#define BRW_NEW_VERTEX_PROGRAM          (1 << BRW_STATE_VERTEX_PROGRAM)
#define BRW_NEW_CURBE_OFFSETS           (1 << BRW_STATE_CURBE_OFFSETS)
#define BRW_NEW_REDUCED_PRIMITIVE       (1 << BRW_STATE_REDUCED_PRIMITIVE)
#define BRW_NEW_PRIMITIVE               (1 << BRW_STATE_PRIMITIVE)
#define BRW_NEW_CONTEXT                 (1 << BRW_STATE_CONTEXT)
#define BRW_NEW_PSP                     (1 << BRW_STATE_PSP)
#define BRW_NEW_SURFACES		(1 << BRW_STATE_SURFACES)
#define BRW_NEW_VS_BINDING_TABLE	(1 << BRW_STATE_VS_BINDING_TABLE)
#define BRW_NEW_GS_BINDING_TABLE	(1 << BRW_STATE_GS_BINDING_TABLE)
#define BRW_NEW_PS_BINDING_TABLE	(1 << BRW_STATE_PS_BINDING_TABLE)
#define BRW_NEW_INDICES			(1 << BRW_STATE_INDICES)
#define BRW_NEW_VERTICES		(1 << BRW_STATE_VERTICES)
d141 8
a148 12
#define BRW_NEW_BATCH                  (1 << BRW_STATE_BATCH)
/** \see brw.state.depth_region */
#define BRW_NEW_INDEX_BUFFER           (1 << BRW_STATE_INDEX_BUFFER)
#define BRW_NEW_VS_CONSTBUF            (1 << BRW_STATE_VS_CONSTBUF)
#define BRW_NEW_PROGRAM_CACHE		(1 << BRW_STATE_PROGRAM_CACHE)
#define BRW_NEW_STATE_BASE_ADDRESS	(1 << BRW_STATE_STATE_BASE_ADDRESS)
#define BRW_NEW_VUE_MAP_GEOM_OUT	(1 << BRW_STATE_VUE_MAP_GEOM_OUT)
#define BRW_NEW_TRANSFORM_FEEDBACK	(1 << BRW_STATE_TRANSFORM_FEEDBACK)
#define BRW_NEW_RASTERIZER_DISCARD	(1 << BRW_STATE_RASTERIZER_DISCARD)
#define BRW_NEW_STATS_WM		(1 << BRW_STATE_STATS_WM)
#define BRW_NEW_UNIFORM_BUFFER          (1 << BRW_STATE_UNIFORM_BUFFER)
#define BRW_NEW_META_IN_PROGRESS        (1 << BRW_STATE_META_IN_PROGRESS)
a160 64
#define AUB_TRACE_TYPE_MASK		0x0000ff00
#define AUB_TRACE_TYPE_NOTYPE		(0 << 8)
#define AUB_TRACE_TYPE_BATCH		(1 << 8)
#define AUB_TRACE_TYPE_VERTEX_BUFFER	(5 << 8)
#define AUB_TRACE_TYPE_2D_MAP		(6 << 8)
#define AUB_TRACE_TYPE_CUBE_MAP		(7 << 8)
#define AUB_TRACE_TYPE_VOLUME_MAP	(9 << 8)
#define AUB_TRACE_TYPE_1D_MAP		(10 << 8)
#define AUB_TRACE_TYPE_CONSTANT_BUFFER	(11 << 8)
#define AUB_TRACE_TYPE_CONSTANT_URB	(12 << 8)
#define AUB_TRACE_TYPE_INDEX_BUFFER	(13 << 8)
#define AUB_TRACE_TYPE_GENERAL		(14 << 8)
#define AUB_TRACE_TYPE_SURFACE		(15 << 8)

/**
 * state_struct_type enum values are encoded with the top 16 bits representing
 * the type to be delivered to the .aub file, and the bottom 16 bits
 * representing the subtype.  This macro performs the encoding.
 */
#define ENCODE_SS_TYPE(type, subtype) (((type) << 16) | (subtype))

enum state_struct_type {
   AUB_TRACE_VS_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 1),
   AUB_TRACE_GS_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 2),
   AUB_TRACE_CLIP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 3),
   AUB_TRACE_SF_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 4),
   AUB_TRACE_WM_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 5),
   AUB_TRACE_CC_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 6),
   AUB_TRACE_CLIP_VP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 7),
   AUB_TRACE_SF_VP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 8),
   AUB_TRACE_CC_VP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x9),
   AUB_TRACE_SAMPLER_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xa),
   AUB_TRACE_KERNEL_INSTRUCTIONS =	ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xb),
   AUB_TRACE_SCRATCH_SPACE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xc),
   AUB_TRACE_SAMPLER_DEFAULT_COLOR =    ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xd),

   AUB_TRACE_SCISSOR_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x15),
   AUB_TRACE_BLEND_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x16),
   AUB_TRACE_DEPTH_STENCIL_STATE =	ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x17),

   AUB_TRACE_VERTEX_BUFFER =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_VERTEX_BUFFER, 0),
   AUB_TRACE_BINDING_TABLE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_SURFACE, 0x100),
   AUB_TRACE_SURFACE_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_SURFACE, 0x200),
   AUB_TRACE_VS_CONSTANTS =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_CONSTANT_BUFFER, 0),
   AUB_TRACE_WM_CONSTANTS =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_CONSTANT_BUFFER, 1),
};

/**
 * Decode a state_struct_type value to determine the type that should be
 * stored in the .aub file.
 */
static inline uint32_t AUB_TRACE_TYPE(enum state_struct_type ss_type)
{
   return (ss_type & 0xFFFF0000) >> 16;
}

/**
 * Decode a state_struct_type value to determine the subtype that should be
 * stored in the .aub file.
 */
static inline uint32_t AUB_TRACE_SUBTYPE(enum state_struct_type ss_type)
{
   return ss_type & 0xFFFF;
}
d166 1
d174 3
a181 2
   bool compiled_once;

d186 11
d200 1
a200 4
 * compiled programs.
 *
 * Note: brw_wm_prog_data_compare() must be updated when adding fields to this
 * struct!
d207 1
a207 3
   GLuint first_curbe_grf_16;
   GLuint reg_blocks;
   GLuint reg_blocks_16;
d212 1
a212 1
   bool dual_src_blend;
a213 7
   uint32_t prog_offset_16;

   /**
    * Mask of which interpolation modes are required by the fragment shader.
    * Used in hardware setup on gen6+.
    */
   uint32_t barycentric_interp_modes;
d215 1
a215 1
   /* Pointers to tracked values (only valid once
a216 63
    *
    * These must be the last fields of the struct (see
    * brw_wm_prog_data_compare()).
    */
   const float **param;
   const float **pull_param;
};

/**
 * Enum representing the i965-specific vertex results that don't correspond
 * exactly to any element of gl_varying_slot.  The values of this enum are
 * assigned such that they don't conflict with gl_varying_slot.
 */
typedef enum
{
   BRW_VARYING_SLOT_NDC = VARYING_SLOT_MAX,
   BRW_VARYING_SLOT_PAD,
   /**
    * Technically this is not a varying but just a placeholder that
    * compile_sf_prog() inserts into its VUE map to cause the gl_PointCoord
    * builtin variable to be compiled correctly. see compile_sf_prog() for
    * more info.
    */
   BRW_VARYING_SLOT_PNTC,
   BRW_VARYING_SLOT_COUNT
} brw_varying_slot;


/**
 * Data structure recording the relationship between the gl_varying_slot enum
 * and "slots" within the vertex URB entry (VUE).  A "slot" is defined as a
 * single octaword within the VUE (128 bits).
 *
 * Note that each BRW register contains 256 bits (2 octawords), so when
 * accessing the VUE in URB_NOSWIZZLE mode, each register corresponds to two
 * consecutive VUE slots.  When accessing the VUE in URB_INTERLEAVED mode (as
 * in a vertex shader), each register corresponds to a single VUE slot, since
 * it contains data for two separate vertices.
 */
struct brw_vue_map {
   /**
    * Bitfield representing all varying slots that are (a) stored in this VUE
    * map, and (b) actually written by the shader.  Does not include any of
    * the additional varying slots defined in brw_varying_slot.
    */
   GLbitfield64 slots_valid;

   /**
    * Map from gl_varying_slot value to VUE slot.  For gl_varying_slots that are
    * not stored in a slot (because they are not written, or because
    * additional processing is applied before storing them in the VUE), the
    * value is -1.
    */
   signed char varying_to_slot[BRW_VARYING_SLOT_COUNT];

   /**
    * Map from VUE slot to gl_varying_slot value.  For slots that do not
    * directly correspond to a gl_varying_slot, the value comes from
    * brw_varying_slot.
    *
    * For slots that are not in use, the value is BRW_VARYING_SLOT_COUNT (this
    * simplifies code that uses the value stored in slot_to_varying to
    * create a bit mask).
d218 4
a221 6
   signed char slot_to_varying[BRW_VARYING_SLOT_COUNT];

   /**
    * Total number of VUE slots in use
    */
   int num_slots;
a223 22
/**
 * Convert a VUE slot number into a byte offset within the VUE.
 */
static inline GLuint brw_vue_slot_to_offset(GLuint slot)
{
   return 16*slot;
}

/**
 * Convert a vertex output (brw_varying_slot) into a byte offset within the
 * VUE.
 */
static inline GLuint brw_varying_to_offset(struct brw_vue_map *vue_map,
                                           GLuint varying)
{
   return brw_vue_slot_to_offset(vue_map->varying_to_slot[varying]);
}

void brw_compute_vue_map(struct brw_context *brw, struct brw_vue_map *vue_map,
                         GLbitfield64 slots_valid, bool userclip_active);


a246 6

   /**
    * Gen6 transform feedback: Amount by which the streaming vertex buffer
    * indices should be incremented each time the GS is invoked.
    */
   unsigned svbi_postincrement_value;
d249 1
a249 7

/* Note: brw_vec4_prog_data_compare() must be updated when adding fields to
 * this struct!
 */
struct brw_vec4_prog_data {
   struct brw_vue_map vue_map;

d253 1
a254 2
   GLuint nr_pull_params; /**< number of dwords referenced by pull_param[] */
   GLuint total_scratch;
d256 3
a258 3
   /* Used for calculating urb partitions.  In the VS, this is the size of the
    * URB entry used for both input and output to the thread.  In the GS, this
    * is the size of the URB entry used for output.
a260 6

   int num_surfaces;

   /* These pointers must appear last.  See brw_vec4_prog_data_compare(). */
   const float **param;
   const float **pull_param;
d264 1
a264 2
/* Note: brw_vs_prog_data_compare() must be updated when adding fields to this
 * struct!
d266 3
a268 2
struct brw_vs_prog_data {
   struct brw_vec4_prog_data base;
a269 4
   GLbitfield64 inputs_read;

   bool uses_vertexid;
};
d278 3
a280 21
 * Max number of binding table entries used for stream output.
 *
 * From the OpenGL 3.0 spec, table 6.44 (Transform Feedback State), the
 * minimum value of MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS is 64.
 *
 * On Gen6, the size of transform feedback data is limited not by the number
 * of components but by the number of binding table entries we set aside.  We
 * use one binding table entry for a float, one entry for a vector, and one
 * entry per matrix column.  Since the only way we can communicate our
 * transform feedback capabilities to the client is via
 * MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS, we need to plan for the
 * worst case, in which all the varyings are floats, so we use up one binding
 * table entry per component.  Therefore we need to set aside at least 64
 * binding table entries for use by transform feedback.
 *
 * Note: since we don't currently pack varyings, it is currently impossible
 * for the client to actually use up all of these binding table entries--if
 * all of their varyings were floats, they would run out of varying slots and
 * fail to link.  But that's a bug, so it seems prudent to go ahead and
 * allocate the number of binding table entries we will need once the bug is
 * fixed.
d282 1
a282 7
#define BRW_MAX_SOL_BINDINGS 64

/** Maximum number of actual buffers used for stream output */
#define BRW_MAX_SOL_BUFFERS 4

#define BRW_MAX_WM_UBOS              12
#define BRW_MAX_VS_UBOS              12
d285 2
a286 59
 * Helpers to create Surface Binding Table indexes for draw buffers,
 * textures, and constant buffers.
 *
 * Shader threads access surfaces via numeric handles, rather than directly
 * using pointers.  The binding table maps these numeric handles to the
 * address of the actual buffer.
 *
 * For example, a shader might ask to sample from "surface 7."  In this case,
 * bind[7] would contain a pointer to a texture.
 *
 * Currently, our WM binding tables are (arbitrarily) programmed as follows:
 *
 *    +-------------------------------+
 *    |   0 | Draw buffer 0           |
 *    |   . |     .                   |
 *    |   : |     :                   |
 *    |   7 | Draw buffer 7           |
 *    |-----|-------------------------|
 *    |   8 | WM Pull Constant Buffer |
 *    |-----|-------------------------|
 *    |   9 | Texture 0               |
 *    |   . |     .                   |
 *    |   : |     :                   |
 *    |  24 | Texture 15              |
 *    |-----|-------------------------|
 *    |  25 | UBO 0                   |
 *    |   . |     .                   |
 *    |   : |     :                   |
 *    |  36 | UBO 11                  |
 *    +-------------------------------+
 *
 * Our VS binding tables are programmed as follows:
 *
 *    +-----+-------------------------+
 *    |   0 | VS Pull Constant Buffer |
 *    +-----+-------------------------+
 *    |   1 | Texture 0               |
 *    |   . |     .                   |
 *    |   : |     :                   |
 *    |  16 | Texture 15              |
 *    +-----+-------------------------+
 *    |  17 | UBO 0                   |
 *    |   . |     .                   |
 *    |   : |     :                   |
 *    |  28 | UBO 11                  |
 *    +-------------------------------+
 *
 * Our (gen6) GS binding tables are programmed as follows:
 *
 *    +-----+-------------------------+
 *    |   0 | SOL Binding 0           |
 *    |   . |     .                   |
 *    |   : |     :                   |
 *    |  63 | SOL Binding 63          |
 *    +-----+-------------------------+
 *
 * Note that nothing actually uses the SURF_INDEX_DRAW macro, so it has to be
 * the identity function or things will break.  We do want to keep draw buffers
 * first so we can use headerless render target writes for RT 0.
d289 2
a290 12
#define SURF_INDEX_FRAG_CONST_BUFFER (BRW_MAX_DRAW_BUFFERS + 1)
#define SURF_INDEX_TEXTURE(t)        (BRW_MAX_DRAW_BUFFERS + 2 + (t))
#define SURF_INDEX_WM_UBO(u)         (SURF_INDEX_TEXTURE(BRW_MAX_TEX_UNIT) + u)
#define SURF_INDEX_WM_SHADER_TIME    (SURF_INDEX_WM_UBO(12))
/** Maximum size of the binding table. */
#define BRW_MAX_WM_SURFACES          (SURF_INDEX_WM_SHADER_TIME + 1)

#define SURF_INDEX_VERT_CONST_BUFFER (0)
#define SURF_INDEX_VS_TEXTURE(t)     (SURF_INDEX_VERT_CONST_BUFFER + 1 + (t))
#define SURF_INDEX_VS_UBO(u)         (SURF_INDEX_VS_TEXTURE(BRW_MAX_TEX_UNIT) + u)
#define SURF_INDEX_VS_SHADER_TIME    (SURF_INDEX_VS_UBO(12))
#define BRW_MAX_VS_SURFACES          (SURF_INDEX_VS_SHADER_TIME + 1)
d292 5
a296 2
#define SURF_INDEX_SOL_BINDING(t)    ((t))
#define BRW_MAX_GS_SURFACES          SURF_INDEX_SOL_BINDING(BRW_MAX_SOL_BINDINGS)
d299 1
a299 4
 * Stride in bytes between shader_time entries.
 *
 * We separate entries by a cacheline to reduce traffic between EUs writing to
 * different entries.
d301 2
a302 1
#define SHADER_TIME_STRIDE 64
d305 3
d311 1
a311 2
   BRW_BLORP_BLIT_PROG,
   BRW_BLORP_CONST_COLOR_PROG,
a337 1
   GLuint aux_size;
d339 2
d342 1
a342 2
   uint32_t offset;
   uint32_t size;
a347 3
typedef bool (*cache_aux_compare_func)(const void *a, const void *b,
                                       int aux_size, const void *key);
typedef void (*cache_aux_free_func)(const void *aux);
a352 1
   drm_intel_bo *bo;
d355 1
a355 2
   uint32_t next_offset;
   bool bo_used_by_gpu;
d357 2
a358 4
   /**
    * Optional functions used in determining whether the prog_data for a new
    * cache item matches an existing cache item (in case there's relevant data
    * outside of the prog_data).  If NULL, a plain memcmp is done.
d360 1
a360 3
   cache_aux_compare_func aux_compare[BRW_MAX_CACHE];
   /** Optional functions for freeing other pointers attached to a prog_data. */
   cache_aux_free_func aux_free[BRW_MAX_CACHE];
d372 1
a375 13
enum shader_time_shader_type {
   ST_NONE,
   ST_VS,
   ST_VS_WRITTEN,
   ST_VS_RESET,
   ST_FS8,
   ST_FS8_WRITTEN,
   ST_FS8_RESET,
   ST_FS16,
   ST_FS16_WRITTEN,
   ST_FS16_RESET,
};

d378 3
d384 1
a410 8
struct brw_vertex_buffer {
   /** Buffer object containing the uploaded vertex data */
   drm_intel_bo *bo;
   uint32_t offset;
   /** Byte stride between elements in the uploaded array */
   GLuint stride;
   GLuint step_rate;
};
a413 2
   int buffer;

d416 6
d424 8
d439 2
a440 1

d447 1
a447 1
 * brw_context is derived from gl_context.
d451 2
a452 1
   struct gl_context ctx; /**< base class, must be first field */
d454 13
a466 22
   struct
   {
      void (*destroy) (struct brw_context * brw);
      void (*finish_batch) (struct brw_context * brw);
      void (*new_batch) (struct brw_context * brw);

      void (*update_texture_surface)(struct gl_context *ctx,
                                     unsigned unit,
                                     uint32_t *binding_table,
                                     unsigned surf_index);
      void (*update_renderbuffer_surface)(struct brw_context *brw,
					  struct gl_renderbuffer *rb,
					  bool layered,
					  unsigned unit);
      void (*update_null_renderbuffer_surface)(struct brw_context *brw,
					       unsigned unit);
      void (*create_constant_surface)(struct brw_context *brw,
				      drm_intel_bo *bo,
				      uint32_t offset,
				      uint32_t size,
				      uint32_t *out_offset,
                                      bool dword_pitch);
d469 9
a477 2
       * Send the appropriate state packets to configure depth, stencil, and
       * HiZ buffers (i965+ only)
d479 2
a480 117
      void (*emit_depth_stencil_hiz)(struct brw_context *brw,
                                     struct intel_mipmap_tree *depth_mt,
                                     uint32_t depth_offset,
                                     uint32_t depthbuffer_format,
                                     uint32_t depth_surface_type,
                                     struct intel_mipmap_tree *stencil_mt,
                                     bool hiz, bool separate_stencil,
                                     uint32_t width, uint32_t height,
                                     uint32_t tile_x, uint32_t tile_y);

   } vtbl;

   dri_bufmgr *bufmgr;

   drm_intel_context *hw_ctx;

   struct intel_batchbuffer batch;
   bool no_batch_wrap;

   struct {
      drm_intel_bo *bo;
      GLuint offset;
      uint32_t buffer_len;
      uint32_t buffer_offset;
      char buffer[4096];
   } upload;

   /**
    * Set if rendering has occured to the drawable's front buffer.
    *
    * This is used in the DRI2 case to detect that glFlush should also copy
    * the contents of the fake front buffer to the real front buffer.
    */
   bool front_buffer_dirty;

   /**
    * Track whether front-buffer rendering is currently enabled
    *
    * A separate flag is used to track this in order to support MRT more
    * easily.
    */
   bool is_front_buffer_rendering;

   /**
    * Track whether front-buffer is the current read target.
    *
    * This is closely associated with is_front_buffer_rendering, but may
    * be set separately.  The DRI2 fake front buffer must be referenced
    * either way.
    */
   bool is_front_buffer_reading;

   /** Framerate throttling: @@{ */
   drm_intel_bo *first_post_swapbuffers_batch;
   bool need_throttle;
   /** @@} */

   GLuint stats_wm;

   /**
    * drirc options:
    * @@{
    */
   bool no_rast;
   bool always_flush_batch;
   bool always_flush_cache;
   bool disable_throttling;
   bool precompile;

   driOptionCache optionCache;
   /** @@} */

   GLuint primitive; /**< Hardware primitive, such as _3DPRIM_TRILIST. */

   GLenum reduced_primitive;

   /**
    * Set if we're either a debug context or the INTEL_DEBUG=perf environment
    * variable is set, this is the flag indicating to do expensive work that
    * might lead to a perf_debug() call.
    */
   bool perf_debug;

   uint32_t max_gtt_map_object_size;

   bool emit_state_always;

   int gen;
   int gt;

   bool is_g4x;
   bool is_baytrail;
   bool is_haswell;

   bool has_hiz;
   bool has_separate_stencil;
   bool must_use_separate_stencil;
   bool has_llc;
   bool has_swizzling;
   bool has_surface_tile_offset;
   bool has_compr4;
   bool has_negative_rhw_bug;
   bool has_aa_line_parameters;
   bool has_pln;

   /**
    * Some versions of Gen hardware don't do centroid interpolation correctly
    * on unlit pixels, causing incorrect values for derivatives near triangle
    * edges.  Enabling this flag causes the fragment shader to use
    * non-centroid interpolation for unlit pixels, at the expense of two extra
    * fragment shader instructions.
    */
   bool needs_unlit_centroid_workaround;

   GLuint NewGLState;
   struct {
      struct brw_state_flags dirty;
a485 3
   /* Whether a meta-operation is in progress. */
   bool meta_in_progress;

a487 1
      struct brw_vertex_buffer buffers[VERT_ATTRIB_MAX];
d491 8
a498 1
      GLuint nr_buffers;
d503 1
a504 5

      /* Offset from start of vertex buffer so we can avoid redefining
       * the same VB packed over and over again.
       */
      unsigned int start_vertex_bias;
d515 1
a515 1
      /* Updates are signaled by BRW_NEW_INDEX_BUFFER. */
d517 2
a518 2
      GLuint type;

d531 5
d540 2
a541 8

   /**
    * Platform specific constants containing the maximum number of threads
    * for each pipeline stage.
    */
   int max_vs_threads;
   int max_gs_threads;
   int max_wm_threads;
d550 1
a550 1
      bool constrained;
d552 2
a553 2
      GLuint max_vs_entries;	/* Maximum number of VS entries */
      GLuint max_gs_entries;	/* Maximum number of GS entries */
d561 4
a570 5

      /* gen6: True if the most recently sent _3DSTATE_URB message allocated
       * URB space for the GS.
       */
      bool gen6_gs_previously_active;
a605 15
   /** SAMPLER_STATE count and offset */
   struct {
      GLuint count;
      uint32_t offset;
   } sampler;

   /**
    * Layout of vertex data exiting the geometry portion of the pipleine.
    * This comes from the geometry shader if one exists, otherwise from the
    * vertex shader.
    *
    * BRW_NEW_VUE_MAP_GEOM_OUT is flagged when the VUE map changes.
    */
   struct brw_vue_map vue_map_geom_out;

d608 1
d610 2
a611 1
      drm_intel_bo *scratch_bo;
a612 23
      /** Offset in the program cache to the VS program */
      uint32_t prog_offset;
      uint32_t state_offset;

      uint32_t push_const_offset; /* Offset in the batchbuffer */
      int push_const_size; /* in 256-bit register increments */

      /** @@{ register allocator */

      struct ra_regs *regs;

      /**
       * Array of the ra classes for the unaligned contiguous register
       * block sizes used.
       */
      int *classes;

      /**
       * Mapping for register-allocated objects in *regs to the first
       * GRF for that object.
      */
      uint8_t *ra_reg_to_grf;
      /** @@} */
d614 2
d617 3
a619 1
      uint32_t surf_offset[BRW_MAX_VS_SURFACES];
d625 3
a627 7
      bool prog_active;
      /** Offset in the program cache to the CLIP program pre-gen6 */
      uint32_t prog_offset;
      uint32_t state_offset;

      uint32_t bind_bo_offset;
      uint32_t surf_offset[BRW_MAX_GS_SURFACES];
d633 3
a635 10
      /** Offset in the program cache to the CLIP program pre-gen6 */
      uint32_t prog_offset;

      /* Offset in the batch to the CLIP state on pre-gen6. */
      uint32_t state_offset;

      /* As of gen6, this is the offset in the batch to the CLIP VP,
       * instead of vp_bo.
       */
      uint32_t vp_offset;
d642 3
a644 4
      /** Offset in the program cache to the CLIP program pre-gen6 */
      uint32_t prog_offset;
      uint32_t state_offset;
      uint32_t vp_offset;
d649 1
d651 2
a652 1
      /** offsets in the batch to sampler default colors (texture border color)
d654 4
a657 1
      uint32_t sdc_offset[BRW_MAX_TEX_UNIT];
d660 1
d662 1
d665 2
a666 8
      /**
       * Buffer object used in place of multisampled null render targets on
       * Gen6.  See brw_update_null_renderbuffer_surface().
       */
      drm_intel_bo *multisampled_null_render_target_bo;

      /** Offset in the program cache to the WM program */
      uint32_t prog_offset;
d668 5
a672 1
      uint32_t state_offset; /* offset in batchbuffer to pre-gen6 WM state */
d674 2
d678 1
a678 1
       * This is offset in the batch to the push constants on gen6.
d682 1
a682 26
      uint32_t push_const_offset;

      /** Binding table of pointers to surf_bo entries */
      uint32_t bind_bo_offset;
      uint32_t surf_offset[BRW_MAX_WM_SURFACES];

      struct {
         struct ra_regs *regs;

         /** Array of the ra classes for the unaligned contiguous
          * register block sizes used.
          */
         int *classes;

         /**
          * Mapping for register-allocated objects in *regs to the first
          * GRF for that object.
          */
         uint8_t *ra_reg_to_grf;

         /**
          * ra class for the aligned pairs we use for PLN, which doesn't
          * appear in *classes.
          */
         int aligned_pairs_class;
      } reg_sets[2];
d687 10
a697 3
      uint32_t blend_state_offset;
      uint32_t depth_stencil_state_offset;
      uint32_t vp_offset;
d702 3
a704 1
      bool begin_emitted;
d706 1
a706 24

   int num_atoms;
   const struct brw_tracked_state **atoms;

   /* If (INTEL_DEBUG & DEBUG_BATCH) */
   struct {
      uint32_t offset;
      uint32_t size;
      enum state_struct_type type;
   } *state_batch_list;
   int state_batch_count;

   uint32_t render_target_format[MESA_FORMAT_COUNT];
   bool format_supported_as_render_target[MESA_FORMAT_COUNT];

   /* PrimitiveRestart */
   struct {
      bool in_progress;
      bool enable_cut_index;
   } prim_restart;

   /** Computed depth/stencil/hiz state from the current attached
    * renderbuffers, valid only during the drawing state upload loop after
    * brw_workaround_depthstencil_alignment().
d708 2
a709 3
   struct {
      struct intel_mipmap_tree *depth_mt;
      struct intel_mipmap_tree *stencil_mt;
a710 5
      /* Inter-tile (page-aligned) byte offsets. */
      uint32_t depth_offset, hiz_offset, stencil_offset;
      /* Intra-tile x,y offsets for drawing to depth/stencil/hiz */
      uint32_t tile_x, tile_y;
   } depthstencil;
d712 1
a712 2
   uint32_t num_instances;
   int basevertex;
d714 5
a718 15
   struct {
      drm_intel_bo *bo;
      struct gl_shader_program **shader_programs;
      struct gl_program **programs;
      enum shader_time_shader_type *types;
      uint64_t *cumulative;
      int num_entries;
      int max_entries;
      double report_time;
   } shader_time;

   __DRIcontext *driContext;
   struct intel_screen *intelScreen;
   void (*saved_viewport)(struct gl_context *ctx,
                          GLint x, GLint y, GLsizei width, GLsizei height);
d720 1
d730 4
a733 20
bool brwCreateContext(int api,
		      const struct gl_config *mesaVis,
		      __DRIcontext *driContextPriv,
                      unsigned major_version,
                      unsigned minor_version,
                      uint32_t flags,
                      unsigned *error,
		      void *sharedContextPrivate);

/*======================================================================
 * brw_misc_state.c
 */
void brw_get_depthstencil_tile_masks(struct intel_mipmap_tree *depth_mt,
                                     uint32_t depth_level,
                                     uint32_t depth_layer,
                                     struct intel_mipmap_tree *stencil_mt,
                                     uint32_t *out_tile_mask_x,
                                     uint32_t *out_tile_mask_y);
void brw_workaround_depthstencil_alignment(struct brw_context *brw,
                                           GLbitfield clear_mask);
d738 2
a739 2
void brw_init_common_queryobj_functions(struct dd_function_table *functions);
void gen4_init_queryobj_functions(struct dd_function_table *functions);
a742 3
/** gen6_queryobj.c */
void gen6_init_queryobj_functions(struct dd_function_table *functions);

d746 1
a746 2
void brw_debug_batch(struct brw_context *brw);
void brw_annotate_aub(struct brw_context *brw);
a758 10
int brw_get_scratch_size(int size);
void brw_get_scratch_bo(struct brw_context *brw,
			drm_intel_bo **scratch_bo, int size);
void brw_init_shader_time(struct brw_context *brw);
int brw_get_shader_time_index(struct brw_context *brw,
                              struct gl_shader_program *shader_prog,
                              struct gl_program *prog,
                              enum shader_time_shader_type type);
void brw_collect_and_report_shader_time(struct brw_context *brw);
void brw_destroy_shader_time(struct brw_context *brw);
d764 3
a770 4
/* brw_fs_reg_allocate.cpp
 */
void brw_fs_alloc_reg_sets(struct brw_context *brw);

d774 3
a776 74
/* brw_vs.c */
gl_clip_plane *brw_select_clip_planes(struct gl_context *ctx);

/* brw_wm_surface_state.c */
void brw_init_surface_formats(struct brw_context *brw);
void
brw_update_sol_surface(struct brw_context *brw,
                       struct gl_buffer_object *buffer_obj,
                       uint32_t *out_offset, unsigned num_vector_components,
                       unsigned stride_dwords, unsigned offset_dwords);
void brw_upload_ubo_surfaces(struct brw_context *brw,
			     struct gl_shader *shader,
			     uint32_t *surf_offsets);

/* brw_surface_formats.c */
bool brw_is_hiz_depth_format(struct brw_context *ctx, gl_format format);
bool brw_render_target_supported(struct brw_context *brw,
                                 struct gl_renderbuffer *rb);

/* gen6_sol.c */
void
brw_begin_transform_feedback(struct gl_context *ctx, GLenum mode,
			     struct gl_transform_feedback_object *obj);
void
brw_end_transform_feedback(struct gl_context *ctx,
                           struct gl_transform_feedback_object *obj);

/* gen7_sol_state.c */
void
gen7_begin_transform_feedback(struct gl_context *ctx, GLenum mode,
                              struct gl_transform_feedback_object *obj);
void
gen7_end_transform_feedback(struct gl_context *ctx,
			    struct gl_transform_feedback_object *obj);

/* brw_blorp_blit.cpp */
GLbitfield
brw_blorp_framebuffer(struct brw_context *brw,
                      GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,
                      GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,
                      GLbitfield mask, GLenum filter);

bool
brw_blorp_copytexsubimage(struct brw_context *brw,
                          struct gl_renderbuffer *src_rb,
                          struct gl_texture_image *dst_image,
                          int slice,
                          int srcX0, int srcY0,
                          int dstX0, int dstY0,
                          int width, int height);

/* gen6_multisample_state.c */
void
gen6_emit_3dstate_multisample(struct brw_context *brw,
                              unsigned num_samples);
void
gen6_emit_3dstate_sample_mask(struct brw_context *brw,
                              unsigned num_samples, float coverage,
                              bool coverage_invert, unsigned sample_mask);
void
gen6_get_sample_position(struct gl_context *ctx,
                         struct gl_framebuffer *fb,
                         GLuint index,
                         GLfloat *result);

/* gen7_urb.c */
void
gen7_allocate_push_constants(struct brw_context *brw);

void
gen7_emit_urb_state(struct brw_context *brw, GLuint nr_vs_entries,
                    GLuint vs_size, GLuint vs_start);


d812 2
a813 14
/**
 * Pre-gen6, the register file of the EUs was shared between threads,
 * and each thread used some subset allocated on a 16-register block
 * granularity.  The unit states wanted these block counts.
 */
static inline int
brw_register_blocks(int reg_count)
{
   return ALIGN(reg_count, 16) / 16 - 1;
}

static inline uint32_t
brw_program_reloc(struct brw_context *brw, uint32_t state_offset,
		  uint32_t prog_offset)
d815 23
a837 3
   if (brw->gen >= 5) {
      /* Using state base address. */
      return prog_offset;
a838 8

   drm_intel_bo_emit_reloc(brw->batch.bo,
			   state_offset,
			   brw->cache.bo,
			   prog_offset,
			   I915_GEM_DOMAIN_INSTRUCTION, 0);

   return brw->cache.bo->offset + prog_offset;
d841 1
a841 11
bool brw_do_cubemap_normalize(struct exec_list *instructions);
bool brw_lower_texture_gradients(struct brw_context *brw,
                                 struct exec_list *instructions);

struct opcode_desc {
    char    *name;
    int	    nsrc;
    int	    ndst;
};

extern const struct opcode_desc opcode_descs[128];
a842 25
void
brw_emit_depthbuffer(struct brw_context *brw);

void
brw_emit_depth_stencil_hiz(struct brw_context *brw,
                           struct intel_mipmap_tree *depth_mt,
                           uint32_t depth_offset, uint32_t depthbuffer_format,
                           uint32_t depth_surface_type,
                           struct intel_mipmap_tree *stencil_mt,
                           bool hiz, bool separate_stencil,
                           uint32_t width, uint32_t height,
                           uint32_t tile_x, uint32_t tile_y);

void
gen7_emit_depth_stencil_hiz(struct brw_context *brw,
                            struct intel_mipmap_tree *depth_mt,
                            uint32_t depth_offset, uint32_t depthbuffer_format,
                            uint32_t depth_surface_type,
                            struct intel_mipmap_tree *stencil_mt,
                            bool hiz, bool separate_stencil,
                            uint32_t width, uint32_t height,
                            uint32_t tile_x, uint32_t tile_y);

#ifdef __cplusplus
}
a844 1
#endif
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics to
d5 1
a5 1

d13 1
a13 1

d17 1
a17 1

d25 1
a25 1

d29 1
a29 1
  *   Keith Whitwell <keithw@@vmware.com>
d36 2
a37 2
#include <stdbool.h>
#include <string.h>
a39 17
#include "main/mm.h"
#include "main/mtypes.h"
#include "brw_structs.h"

#ifdef __cplusplus
extern "C" {
	/* Evil hack for using libdrm in a c++ compiler. */
        #define virtual virt
#endif

#include <drm.h>
#include <intel_bufmgr.h>
#include <i915_drm.h>
#ifdef __cplusplus
	#undef virtual
}
#endif
a43 4
#include "intel_debug.h"
#include "intel_screen.h"
#include "intel_tex_obj.h"
#include "intel_resolve_map.h"
d57 1
a57 1
 * things like primitive type, Begin/end flags and clip codes.
d122 1
a127 1
struct brw_vec4_prog_key;
a133 1
   BRW_STATE_GEOMETRY_PROGRAM,
a148 1
   BRW_STATE_GS_CONSTBUF,
a150 1
   BRW_STATE_VUE_MAP_VS,
a155 1
   BRW_STATE_ATOMIC_BUFFER,
a156 4
   BRW_STATE_INTERPOLATION_MAP,
   BRW_STATE_PUSH_CONSTANT_ALLOCATION,
   BRW_STATE_NUM_SAMPLES,
   BRW_NUM_STATE_BITS
a160 1
#define BRW_NEW_GEOMETRY_PROGRAM        (1 << BRW_STATE_GEOMETRY_PROGRAM)
a180 1
#define BRW_NEW_GS_CONSTBUF            (1 << BRW_STATE_GS_CONSTBUF)
a182 1
#define BRW_NEW_VUE_MAP_VS		(1 << BRW_STATE_VUE_MAP_VS)
a187 1
#define BRW_NEW_ATOMIC_BUFFER           (1 << BRW_STATE_ATOMIC_BUFFER)
a188 3
#define BRW_NEW_INTERPOLATION_MAP       (1 << BRW_STATE_INTERPOLATION_MAP)
#define BRW_NEW_PUSH_CONSTANT_ALLOCATION (1 << BRW_STATE_PUSH_CONSTANT_ALLOCATION)
#define BRW_NEW_NUM_SAMPLES             (1 << BRW_STATE_NUM_SAMPLES)
a272 7
/** Subclass of Mesa geometry program */
struct brw_geometry_program {
   struct gl_geometry_program program;
   unsigned id;  /**< serial no. to identify geom progs, never re-used */
};


a278 8

/** Subclass of Mesa compute program */
struct brw_compute_program {
   struct gl_compute_program program;
   unsigned id;  /**< serial no. to identify compute progs, never re-used */
};


a282 1
};
d284 2
a285 31
/* Note: If adding fields that need anything besides a normal memcmp() for
 * comparing them, be sure to go fix brw_stage_prog_data_compare().
 */
struct brw_stage_prog_data {
   struct {
      /** size of our binding table. */
      uint32_t size_bytes;

      /** @@{
       * surface indices for the various groups of surfaces
       */
      uint32_t pull_constants_start;
      uint32_t texture_start;
      uint32_t gather_texture_start;
      uint32_t ubo_start;
      uint32_t abo_start;
      uint32_t shader_time_start;
      /** @@} */
   } binding_table;

   GLuint nr_params;       /**< number of float params/constants */
   GLuint nr_pull_params;

   /* Pointers to tracked values (only valid once
    * _mesa_load_state_parameters has been called at runtime).
    *
    * These must be the last fields of the struct (see
    * brw_stage_prog_data_compare()).
    */
   const float **param;
   const float **pull_param;
a296 2
   struct brw_stage_prog_data base;

d298 1
a298 1
   GLuint num_varying_inputs;
d306 2
a307 8
   struct {
      /** @@{
       * surface indices the WM-specific surfaces
       */
      uint32_t render_target_start;
      /** @@} */
   } binding_table;

d309 1
a309 2
   bool uses_pos_offset;
   bool uses_omask;
d318 5
a322 4
   /**
    * Map from gl_varying_slot to the position within the FS setup data
    * payload where the varying's attribute vertex deltas should be delivered.
    * For varying slots that are not used by the FS, the value is -1.
d324 2
a325 1
   int urb_setup[VARYING_SLOT_MAX];
d411 1
a411 36
                         GLbitfield64 slots_valid);


/**
 * Bitmask indicating which fragment shader inputs represent varyings (and
 * hence have to be delivered to the fragment shader by the SF/SBE stage).
 */
#define BRW_FS_VARYING_INPUT_MASK \
   (BITFIELD64_RANGE(0, VARYING_SLOT_MAX) & \
    ~VARYING_BIT_POS & ~VARYING_BIT_FACE)


/*
 * Mapping of VUE map slots to interpolation modes.
 */
struct interpolation_mode_map {
   unsigned char mode[BRW_VARYING_SLOT_COUNT];
};

static inline bool brw_any_flat_varyings(struct interpolation_mode_map *map)
{
   for (int i = 0; i < BRW_VARYING_SLOT_COUNT; i++)
      if (map->mode[i] == INTERP_QUALIFIER_FLAT)
         return true;

   return false;
}

static inline bool brw_any_noperspective_varyings(struct interpolation_mode_map *map)
{
   for (int i = 0; i < BRW_VARYING_SLOT_COUNT; i++)
      if (map->mode[i] == INTERP_QUALIFIER_NOPERSPECTIVE)
         return true;

   return false;
}
a426 10

/**
 * We always program SF to start reading at an offset of 1 (2 varying slots)
 * from the start of the vertex URB entry.  This causes it to skip:
 * - VARYING_SLOT_PSIZ and BRW_VARYING_SLOT_NDC on gen4-5
 * - VARYING_SLOT_PSIZ and VARYING_SLOT_POS on gen6+
 */
#define BRW_SF_URB_ENTRY_READ_OFFSET 1


d434 1
a434 1
struct brw_ff_gs_prog_data {
a449 1
   struct brw_stage_prog_data base;
a451 6
   /**
    * Register where the thread expects to find input data from the URB
    * (typically uniforms, followed by per-vertex inputs).
    */
   unsigned dispatch_grf_start_reg;

d455 2
d464 6
a483 40

/* Note: brw_gs_prog_data_compare() must be updated when adding fields to
 * this struct!
 */
struct brw_gs_prog_data
{
   struct brw_vec4_prog_data base;

   /**
    * Size of an output vertex, measured in HWORDS (32 bytes).
    */
   unsigned output_vertex_size_hwords;

   unsigned output_topology;

   /**
    * Size of the control data (cut bits or StreamID bits), in hwords (32
    * bytes).  0 if there is no control data.
    */
   unsigned control_data_header_size_hwords;

   /**
    * Format of the control data (either GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_SID
    * if the control data is StreamID bits, or
    * GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_CUT if the control data is cut bits).
    * Ignored if control_data_header_size is 0.
    */
   unsigned control_data_format;

   bool include_primitive_id;

   int invocations;

   /**
    * True if the thread should be dispatched in DUAL_INSTANCE mode, false if
    * it should be dispatched in DUAL_OBJECT mode.
    */
   bool dual_instanced_dispatch;
};

d485 1
a485 1
#define BRW_MAX_TEX_UNIT 32
a489 3
/** Max number of atomic counter buffer objects in a shader */
#define BRW_MAX_ABO 16

d518 2
a519 5
#define BRW_MAX_SURFACES   (BRW_MAX_DRAW_BUFFERS +                      \
                            BRW_MAX_TEX_UNIT * 2 + /* normal, gather */ \
                            12 + /* ubo */                              \
                            BRW_MAX_ABO +                               \
                            2 /* shader time, pull constants */)
d521 77
a597 2
#define SURF_INDEX_GEN6_SOL_BINDING(t) (t)
#define BRW_MAX_GEN6_GS_SURFACES       SURF_INDEX_GEN6_SOL_BINDING(BRW_MAX_SOL_BINDINGS)
d620 1
a620 2
   BRW_FF_GS_UNIT,
   BRW_FF_GS_PROG,
d646 1
a646 1
};
d649 2
a650 1
typedef bool (*cache_aux_compare_func)(const void *a, const void *b);
a689 3
   ST_GS,
   ST_GS_WRITTEN,
   ST_GS_RESET,
a702 2
#define CACHE_NEW_BLORP_BLIT_PROG        (1<<BRW_BLORP_BLIT_PROG)
#define CACHE_NEW_BLORP_CONST_COLOR_PROG (1<<BRW_BLORP_CONST_COLOR_PROG)
d710 1
a710 2
#define CACHE_NEW_FF_GS_UNIT             (1<<BRW_FF_GS_UNIT)
#define CACHE_NEW_FF_GS_PROG             (1<<BRW_FF_GS_PROG)
d716 13
d742 2
a757 106
struct intel_sync_object {
   struct gl_sync_object Base;

   /** Batch associated with this sync object */
   drm_intel_bo *bo;
};

enum brw_gpu_ring {
   UNKNOWN_RING,
   RENDER_RING,
   BLT_RING,
};

struct intel_batchbuffer {
   /** Current batchbuffer being queued up. */
   drm_intel_bo *bo;
   /** Last BO submitted to the hardware.  Used for glFinish(). */
   drm_intel_bo *last_bo;
   /** BO for post-sync nonzero writes for gen6 workaround. */
   drm_intel_bo *workaround_bo;
   bool need_workaround_flush;

   uint16_t emit, total;
   uint16_t used, reserved_space;
   uint32_t *map;
   uint32_t *cpu_map;
#define BATCH_SZ (8192*sizeof(uint32_t))

   uint32_t state_batch_offset;
   enum brw_gpu_ring ring;
   bool needs_sol_reset;

   struct {
      uint16_t used;
      int reloc_count;
   } saved;
};

#define BRW_MAX_XFB_STREAMS 4

struct brw_transform_feedback_object {
   struct gl_transform_feedback_object base;

   /** A buffer to hold SO_WRITE_OFFSET(n) values while paused. */
   drm_intel_bo *offset_bo;

   /** If true, SO_WRITE_OFFSET(n) should be reset to zero at next use. */
   bool zero_offsets;

   /** The most recent primitive mode (GL_TRIANGLES/GL_POINTS/GL_LINES). */
   GLenum primitive_mode;

   /**
    * Count of primitives generated during this transform feedback operation.
    *  @@{
    */
   uint64_t prims_generated[BRW_MAX_XFB_STREAMS];
   drm_intel_bo *prim_count_bo;
   unsigned prim_count_buffer_index; /**< in number of uint64_t units */
   /** @@} */

   /**
    * Number of vertices written between last Begin/EndTransformFeedback().
    *
    * Used to implement DrawTransformFeedback().
    */
   uint64_t vertices_written[BRW_MAX_XFB_STREAMS];
   bool vertices_written_valid;
};

/**
 * Data shared between each programmable stage in the pipeline (vs, gs, and
 * wm).
 */
struct brw_stage_state
{
   gl_shader_stage stage;
   struct brw_stage_prog_data *prog_data;

   /**
    * Optional scratch buffer used to store spilled register values and
    * variably-indexed GRF arrays.
    */
   drm_intel_bo *scratch_bo;

   /** Offset in the program cache to the program */
   uint32_t prog_offset;

   /** Offset in the batchbuffer to Gen4-5 pipelined state (VS/WM/GS_STATE). */
   uint32_t state_offset;

   uint32_t push_const_offset; /* Offset in the batchbuffer */
   int push_const_size; /* in 256-bit register increments */

   /* Binding table: pointers to SURFACE_STATE entries. */
   uint32_t bind_bo_offset;
   uint32_t surf_offset[BRW_MAX_SURFACES];

   /** SAMPLER_STATE count and table offset */
   uint32_t sampler_count;
   uint32_t sampler_offset;

   /** Offsets in the batch to sampler default colors (texture border color) */
   uint32_t sdc_offset[BRW_MAX_TEX_UNIT];
};

d762 1
a762 1
struct brw_context
d768 4
d774 2
a775 2
                                     uint32_t *surf_offset,
                                     bool for_gather);
d782 6
a787 21

      void (*create_raw_surface)(struct brw_context *brw,
                                 drm_intel_bo *bo,
                                 uint32_t offset,
                                 uint32_t size,
                                 uint32_t *out_offset,
                                 bool rw);
      void (*emit_buffer_surface_state)(struct brw_context *brw,
                                        uint32_t *out_offset,
                                        drm_intel_bo *bo,
                                        unsigned buffer_offset,
                                        unsigned surface_format,
                                        unsigned buffer_size,
                                        unsigned pitch,
                                        unsigned mocs,
                                        bool rw);

      /** Upload a SAMPLER_STATE table. */
      void (*upload_sampler_state_table)(struct brw_context *brw,
                                         struct gl_program *prog,
                                         struct brw_stage_state *stage_state);
a808 15
   /**
    * Set of drm_intel_bo * that have been rendered to within this batchbuffer
    * and would need flushing before being used from another cache domain that
    * isn't coherent with it (i.e. the sampler).
    */
   struct set *render_cache;

   /**
    * Number of resets observed in the system at context creation.
    *
    * This is tracked in the context so that we can determine that another
    * reset has occured.
    */
   uint32_t reset_count;

d814 4
a817 1
      uint32_t next_offset;
d828 17
a860 1
   bool disable_derivative_optimization;
d878 2
d895 1
d913 1
a913 3

   /** IDs for meta stencil blit shader programs. */
   unsigned meta_stencil_blit_programs[2];
a917 3
   /* Whether the last depth/stencil packets were both NULL. */
   bool no_depth_or_stencil;

d956 1
a956 1
   /* Active vertex program:
a958 1
   const struct gl_geometry_program *geometry_program;
d961 4
a964 5
   /**
    * Number of samples in ctx->DrawBuffer, updated by BRW_NEW_NUM_SAMPLES so
    * that we don't have to reemit that state every time we change FBOs.
    */
   int num_samples;
a982 1
      GLuint min_vs_entries;    /* Minimum number of VS entries */
d1005 2
a1006 2

   /* BRW_NEW_CURBE_OFFSETS:
d1038 5
a1042 6
   /**
    * Layout of vertex data exiting the vertex shader.
    *
    * BRW_NEW_VUE_MAP_VS is flagged when this VUE map changes.
    */
   struct brw_vue_map vue_map_vs;
a1053 1
      struct brw_stage_state base;
a1054 1
   } vs;
d1056 12
a1067 3
   struct {
      struct brw_stage_state base;
      struct brw_gs_prog_data *prog_data;
d1070 2
a1071 2
       * True if the 3DSTATE_GS command most recently emitted to the 3D
       * pipeline enabled the GS; false otherwise.
d1073 12
a1084 2
      bool enabled;
   } gs;
d1087 1
a1087 1
      struct brw_ff_gs_prog_data *prog_data;
d1095 2
a1096 2
      uint32_t surf_offset[BRW_MAX_GEN6_GS_SURFACES];
   } ff_gs;
a1123 1
      struct brw_stage_state base;
d1126 4
d1132 2
d1139 38
a1191 37
   struct {
      /** A map from pipeline statistics counter IDs to MMIO addresses. */
      const int *statistics_registers;

      /** The number of active monitors using OA counters. */
      unsigned oa_users;

      /**
       * A buffer object storing OA counter snapshots taken at the start and
       * end of each batch (creating "bookends" around the batch).
       */
      drm_intel_bo *bookend_bo;

      /** The number of snapshots written to bookend_bo. */
      int bookend_snapshots;

      /**
       * An array of monitors whose results haven't yet been assembled based on
       * the data in buffer objects.
       *
       * These may be active, or have already ended.  However, the results
       * have not been requested.
       */
      struct brw_perf_monitor_object **unresolved;
      int unresolved_elements;
      int unresolved_array_size;

      /**
       * Mapping from a uint32_t offset within an OA snapshot to the ID of
       * the counter which MI_REPORT_PERF_COUNT stores there.
       */
      const int *oa_snapshot_layout;

      /** Number of 32-bit entries in a hardware counter snapshot. */
      int entries_per_oa_snapshot;
   } perfmon;

a1205 5
   /* Interpolation modes, one byte per vue slot.
    * Used Gen4/5 by the clip|sf|wm stages. Ignored on Gen6+.
    */
   struct interpolation_mode_map interpolation_mode;

d1242 2
a1250 3
/* brw_clear.c */
extern void intelInitClearFuncs(struct dd_function_table *functions);

d1254 1
a1254 19
extern const char *const brw_vendor_string;

extern const char *brw_get_renderer_string(unsigned deviceID);

extern void intelFinish(struct gl_context * ctx);

enum {
   DRI_CONF_BO_REUSE_DISABLED,
   DRI_CONF_BO_REUSE_ALL
};

void intel_update_renderbuffers(__DRIcontext *context,
                                __DRIdrawable *drawable);
void intel_prepare_render(struct brw_context *brw);

void intel_resolve_for_dri2_flush(struct brw_context *brw,
                                  __DRIdrawable *drawable);

GLboolean brwCreateContext(gl_api api,
a1259 1
                      bool notify_reset,
a1265 20
GLuint brw_get_rb_for_slice(struct brw_context *brw,
                            struct intel_mipmap_tree *mt,
                            unsigned level, unsigned layer, bool flat);

void brw_meta_updownsample(struct brw_context *brw,
                           struct intel_mipmap_tree *src,
                           struct intel_mipmap_tree *dst);

void brw_meta_fbo_stencil_blit(struct brw_context *brw,
                               GLfloat srcX0, GLfloat srcY0,
                               GLfloat srcX1, GLfloat srcY1,
                               GLfloat dstX0, GLfloat dstY0,
                               GLfloat dstX1, GLfloat dstY1);

void brw_meta_stencil_updownsample(struct brw_context *brw,
                                   struct intel_mipmap_tree *src,
                                   struct intel_mipmap_tree *dst);
/*======================================================================
 * brw_misc_state.c
 */
a1274 3
/* brw_object_purgeable.c */
void brw_init_object_purgeable_functions(struct dd_function_table *functions);

a1284 11
void brw_write_timestamp(struct brw_context *brw, drm_intel_bo *bo, int idx);
void brw_write_depth_count(struct brw_context *brw, drm_intel_bo *bo, int idx);
void brw_store_register_mem64(struct brw_context *brw,
                              drm_intel_bo *bo, uint32_t reg, int idx);

/** intel_batchbuffer.c */
void brw_load_register_mem(struct brw_context *brw,
                           uint32_t reg,
                           drm_intel_bo *bo,
                           uint32_t read_domains, uint32_t write_domain,
                           uint32_t offset);
d1324 1
a1324 4
void brw_fs_alloc_reg_sets(struct intel_screen *screen);

/* brw_vec4_reg_allocate.cpp */
void brw_vec4_alloc_reg_set(struct intel_screen *screen);
a1331 6
/* brw_draw_upload.c */
unsigned brw_get_vertex_surface_type(struct brw_context *brw,
                                     const struct gl_client_array *glarray);
unsigned brw_get_index_type(GLenum type);
void brw_prepare_vertices(struct brw_context *brw);

a1333 9
void brw_create_constant_surface(struct brw_context *brw,
                                 drm_intel_bo *bo,
                                 uint32_t offset,
                                 uint32_t size,
                                 uint32_t *out_offset,
                                 bool dword_pitch);
void brw_update_buffer_texture_surface(struct gl_context *ctx,
                                       unsigned unit,
                                       uint32_t *surf_offset);
d1341 1
a1341 6
                             struct brw_stage_state *stage_state,
                             struct brw_stage_prog_data *prog_data);
void brw_upload_abo_surfaces(struct brw_context *brw,
                             struct gl_shader_program *prog,
                             struct brw_stage_state *stage_state,
                             struct brw_stage_prog_data *prog_data);
d1344 1
a1344 1
bool brw_is_hiz_depth_format(struct brw_context *ctx, mesa_format format);
a1346 25
uint32_t brw_depth_format(struct brw_context *brw, mesa_format format);

/* brw_performance_monitor.c */
void brw_init_performance_monitors(struct brw_context *brw);
void brw_dump_perf_monitors(struct brw_context *brw);
void brw_perf_monitor_new_batch(struct brw_context *brw);
void brw_perf_monitor_finish_batch(struct brw_context *brw);

/* intel_buffer_objects.c */
int brw_bo_map(struct brw_context *brw, drm_intel_bo *bo, int write_enable,
               const char *bo_name);
int brw_bo_map_gtt(struct brw_context *brw, drm_intel_bo *bo,
                   const char *bo_name);

/* intel_extensions.c */
extern void intelInitExtensions(struct gl_context *ctx);

/* intel_state.c */
extern int intel_translate_shadow_compare_func(GLenum func);
extern int intel_translate_compare_func(GLenum func);
extern int intel_translate_stencil_op(GLenum op);
extern int intel_translate_logic_op(GLenum opcode);

/* intel_syncobj.c */
void intel_init_syncobj_functions(struct dd_function_table *functions);
a1348 5
struct gl_transform_feedback_object *
brw_new_transform_feedback(struct gl_context *ctx, GLuint name);
void
brw_delete_transform_feedback(struct gl_context *ctx,
                              struct gl_transform_feedback_object *obj);
a1354 4
GLsizei
brw_get_transform_feedback_vertex_count(struct gl_context *ctx,
                                        struct gl_transform_feedback_object *obj,
                                        GLuint stream);
a1362 6
void
gen7_pause_transform_feedback(struct gl_context *ctx,
                              struct gl_transform_feedback_object *obj);
void
gen7_resume_transform_feedback(struct gl_context *ctx,
                               struct gl_transform_feedback_object *obj);
a1380 3
unsigned
gen6_determine_sample_mask(struct brw_context *brw);

d1385 3
a1387 1
gen6_emit_3dstate_sample_mask(struct brw_context *brw, unsigned mask);
a1393 4
/* gen8_multisample_state.c */
void gen8_emit_3dstate_multisample(struct brw_context *brw, unsigned num_samp);
void gen8_emit_3dstate_sample_pattern(struct brw_context *brw);

d1396 1
a1396 2
gen7_emit_push_constant_state(struct brw_context *brw, unsigned vs_size,
                              unsigned gs_size, unsigned fs_size);
d1399 2
a1400 4
gen7_emit_urb_state(struct brw_context *brw,
                    unsigned nr_vs_entries, unsigned vs_size,
                    unsigned vs_start, unsigned nr_gs_entries,
                    unsigned gs_size, unsigned gs_start);
a1402 3
/* brw_reset.c */
extern GLenum
brw_get_graphics_reset_status(struct gl_context *ctx);
d1408 1
a1408 1
static inline struct brw_context *
d1414 1
a1414 1
static inline struct brw_vertex_program *
d1420 1
a1420 1
static inline const struct brw_vertex_program *
d1426 1
a1426 7
static inline struct brw_geometry_program *
brw_geometry_program(struct gl_geometry_program *p)
{
   return (struct brw_geometry_program *) p;
}

static inline struct brw_fragment_program *
d1432 1
a1432 1
static inline const struct brw_fragment_program *
d1464 1
a1464 1
   return brw->cache.bo->offset64 + prog_offset;
a1469 1
bool brw_do_lower_unnormalized_offset(struct exec_list *instructions);
a1477 1
extern const char * const conditional_modifier[16];
a1500 53
void
gen8_emit_depth_stencil_hiz(struct brw_context *brw,
                            struct intel_mipmap_tree *depth_mt,
                            uint32_t depth_offset, uint32_t depthbuffer_format,
                            uint32_t depth_surface_type,
                            struct intel_mipmap_tree *stencil_mt,
                            bool hiz, bool separate_stencil,
                            uint32_t width, uint32_t height,
                            uint32_t tile_x, uint32_t tile_y);

void gen8_hiz_exec(struct brw_context *brw, struct intel_mipmap_tree *mt,
                   unsigned int level, unsigned int layer, enum gen6_hiz_op op);

extern const GLuint prim_to_hw_prim[GL_TRIANGLE_STRIP_ADJACENCY+1];

void
brw_setup_vec4_key_clip_info(struct brw_context *brw,
                             struct brw_vec4_prog_key *key,
                             bool program_uses_clip_distance);

void
gen6_upload_vec4_push_constants(struct brw_context *brw,
                                const struct gl_program *prog,
                                const struct brw_vec4_prog_data *prog_data,
                                struct brw_stage_state *stage_state,
                                enum state_struct_type type);

/* ================================================================
 * From linux kernel i386 header files, copes with odd sizes better
 * than COPY_DWORDS would:
 * XXX Put this in src/mesa/main/imports.h ???
 */
#if defined(i386) || defined(__i386__)
static inline void * __memcpy(void * to, const void * from, size_t n)
{
   int d0, d1, d2;
   __asm__ __volatile__(
      "rep ; movsl\n\t"
      "testb $2,%b4\n\t"
      "je 1f\n\t"
      "movsw\n"
      "1:\ttestb $1,%b4\n\t"
      "je 2f\n\t"
      "movsb\n"
      "2:"
      : "=&c" (d0), "=&D" (d1), "=&S" (d2)
      :"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
      : "memory");
   return (to);
}
#else
#define __memcpy(a,b,c) memcpy(a,b,c)
#endif
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@a42 2
#include "intel_aub.h"
#include "program/prog_parameter.h"
d143 2
d146 1
a146 1
struct brw_inst;
a184 1
   BRW_STATE_TEXTURE_BUFFER,
d188 15
a202 15
#define BRW_NEW_URB_FENCE               (1ull << BRW_STATE_URB_FENCE)
#define BRW_NEW_FRAGMENT_PROGRAM        (1ull << BRW_STATE_FRAGMENT_PROGRAM)
#define BRW_NEW_GEOMETRY_PROGRAM        (1ull << BRW_STATE_GEOMETRY_PROGRAM)
#define BRW_NEW_VERTEX_PROGRAM          (1ull << BRW_STATE_VERTEX_PROGRAM)
#define BRW_NEW_CURBE_OFFSETS           (1ull << BRW_STATE_CURBE_OFFSETS)
#define BRW_NEW_REDUCED_PRIMITIVE       (1ull << BRW_STATE_REDUCED_PRIMITIVE)
#define BRW_NEW_PRIMITIVE               (1ull << BRW_STATE_PRIMITIVE)
#define BRW_NEW_CONTEXT                 (1ull << BRW_STATE_CONTEXT)
#define BRW_NEW_PSP                     (1ull << BRW_STATE_PSP)
#define BRW_NEW_SURFACES                (1ull << BRW_STATE_SURFACES)
#define BRW_NEW_VS_BINDING_TABLE        (1ull << BRW_STATE_VS_BINDING_TABLE)
#define BRW_NEW_GS_BINDING_TABLE        (1ull << BRW_STATE_GS_BINDING_TABLE)
#define BRW_NEW_PS_BINDING_TABLE        (1ull << BRW_STATE_PS_BINDING_TABLE)
#define BRW_NEW_INDICES                 (1ull << BRW_STATE_INDICES)
#define BRW_NEW_VERTICES                (1ull << BRW_STATE_VERTICES)
d207 1
a207 1
#define BRW_NEW_BATCH                   (1ull << BRW_STATE_BATCH)
d209 16
a224 17
#define BRW_NEW_INDEX_BUFFER            (1ull << BRW_STATE_INDEX_BUFFER)
#define BRW_NEW_VS_CONSTBUF             (1ull << BRW_STATE_VS_CONSTBUF)
#define BRW_NEW_GS_CONSTBUF             (1ull << BRW_STATE_GS_CONSTBUF)
#define BRW_NEW_PROGRAM_CACHE           (1ull << BRW_STATE_PROGRAM_CACHE)
#define BRW_NEW_STATE_BASE_ADDRESS      (1ull << BRW_STATE_STATE_BASE_ADDRESS)
#define BRW_NEW_VUE_MAP_VS              (1ull << BRW_STATE_VUE_MAP_VS)
#define BRW_NEW_VUE_MAP_GEOM_OUT        (1ull << BRW_STATE_VUE_MAP_GEOM_OUT)
#define BRW_NEW_TRANSFORM_FEEDBACK      (1ull << BRW_STATE_TRANSFORM_FEEDBACK)
#define BRW_NEW_RASTERIZER_DISCARD      (1ull << BRW_STATE_RASTERIZER_DISCARD)
#define BRW_NEW_STATS_WM                (1ull << BRW_STATE_STATS_WM)
#define BRW_NEW_UNIFORM_BUFFER          (1ull << BRW_STATE_UNIFORM_BUFFER)
#define BRW_NEW_ATOMIC_BUFFER           (1ull << BRW_STATE_ATOMIC_BUFFER)
#define BRW_NEW_META_IN_PROGRESS        (1ull << BRW_STATE_META_IN_PROGRESS)
#define BRW_NEW_INTERPOLATION_MAP       (1ull << BRW_STATE_INTERPOLATION_MAP)
#define BRW_NEW_PUSH_CONSTANT_ALLOCATION (1ull << BRW_STATE_PUSH_CONSTANT_ALLOCATION)
#define BRW_NEW_NUM_SAMPLES             (1ull << BRW_STATE_NUM_SAMPLES)
#define BRW_NEW_TEXTURE_BUFFER          (1ull << BRW_STATE_TEXTURE_BUFFER)
d232 2
a233 9
   uint64_t brw;
   /**
    * State update flags that used to be signalled by brw_state_cache.c
    * searches.
    *
    * Now almost all of that state is just streamed out on demand, but the
    * flags for those state blobs updating have stayed in the same bitfield.
    * brw_state_cache.c still flags CACHE_NEW_*_PROG.
    */
d237 65
a358 9
   unsigned curb_read_length;
   unsigned total_scratch;

   /**
    * Register where the thread expects to find input data from the URB
    * (typically uniforms, followed by vertex or fragment attributes).
    */
   unsigned dispatch_grf_start_reg;

d365 2
a366 2
   const gl_constant_value **param;
   const gl_constant_value **pull_param;
d380 1
d383 2
a384 1
   GLuint dispatch_grf_start_reg_16;
d387 1
a396 1
   bool no_8;
a399 1
   bool uses_kill;
d586 7
d595 1
d614 40
a653 1
   bool uses_instanceid;
d700 1
a700 71

/* Note: brw_gs_prog_data_compare() must be updated when adding fields to
 * this struct!
 */
struct brw_gs_prog_data
{
   struct brw_vec4_prog_data base;

   /**
    * Size of an output vertex, measured in HWORDS (32 bytes).
    */
   unsigned output_vertex_size_hwords;

   unsigned output_topology;

   /**
    * Size of the control data (cut bits or StreamID bits), in hwords (32
    * bytes).  0 if there is no control data.
    */
   unsigned control_data_header_size_hwords;

   /**
    * Format of the control data (either GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_SID
    * if the control data is StreamID bits, or
    * GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_CUT if the control data is cut bits).
    * Ignored if control_data_header_size is 0.
    */
   unsigned control_data_format;

   bool include_primitive_id;

   int invocations;

   /**
    * Dispatch mode, can be any of:
    * GEN7_GS_DISPATCH_MODE_DUAL_OBJECT
    * GEN7_GS_DISPATCH_MODE_DUAL_INSTANCE
    * GEN7_GS_DISPATCH_MODE_SINGLE
    */
   int dispatch_mode;

   /**
    * Gen6 transform feedback enabled flag.
    */
   bool gen6_xfb_enabled;

   /**
    * Gen6: Provoking vertex convention for odd-numbered triangles
    * in tristrips.
    */
   GLuint pv_first:1;

   /**
    * Gen6: Number of varyings that are output to transform feedback.
    */
   GLuint num_transform_feedback_bindings:7; /* 0-BRW_MAX_SOL_BINDINGS */

   /**
    * Gen6: Map from the index of a transform feedback binding table entry to the
    * gl_varying_slot that should be streamed out through that binding table
    * entry.
    */
   unsigned char transform_feedback_bindings[BRW_MAX_SOL_BINDINGS];

   /**
    * Gen6: Map from the index of a transform feedback binding table entry to the
    * swizzles that should be used when streaming out data through that
    * binding table entry.
    */
   unsigned char transform_feedback_swizzles[BRW_MAX_SOL_BINDINGS];
};
d715 1
d810 1
d953 3
d995 5
a1090 1
   bool is_cherryview;
a1100 2
   bool no_simd8;
   bool use_rep_send;
a1126 15
   /* The last PMA stall bits programmed. */
   uint32_t pma_stall_bits;

   struct {
      /** The value of gl_BaseVertex for the current _mesa_prim. */
      int gl_basevertex;

      /**
       * Buffer and offset used for GL_ARB_shader_draw_parameters
       * (for now, only gl_BaseVertex).
       */
      drm_intel_bo *draw_params_bo;
      uint32_t draw_params_offset;
   } draw;

a1188 1
      GLuint gsize;	        /* GS output size in urb registers */
d1211 1
a1211 1
      /* True if the most recently sent _3DSTATE_URB message allocated
d1214 1
a1214 1
      bool gs_present;
a1228 4
      /**
       * Pointer to the (intel_upload.c-generated) BO containing the uniforms
       * for upload to the CURBE.
       */
d1232 16
d1291 1
a1291 6
      /**
       * Surface offsets for the binding table. We only need surfaces to
       * implement transform feedback so BRW_MAX_SOL_BINDINGS is all that we
       * need in this case.
       */
      uint32_t surf_offset[BRW_MAX_SOL_BINDINGS];
a1316 1
      bool viewport_transform_enable;
a1329 1
      uint32_t fast_clear_op;
d1389 1
a1389 1
      enum aub_state_struct_type type;
a1434 2
   struct brw_fast_clear_state *fast_clear_state;

d1454 2
a1497 13

bool brw_meta_fast_clear(struct brw_context *brw,
                         struct gl_framebuffer *fb,
                         GLbitfield mask,
                         bool partial_clear);

void
brw_meta_resolve_color(struct brw_context *brw,
                       struct intel_mipmap_tree *mt);
void
brw_meta_fast_clear_free(struct brw_context *brw);


d1579 1
a1579 2
int brw_disassemble_inst(FILE *file, struct brw_context *brw,
                         struct brw_inst *inst, bool is_compacted);
a1705 2
void
gen6_set_sample_maps(struct gl_context *ctx);
a1823 10
gen6_emit_depth_stencil_hiz(struct brw_context *brw,
                            struct intel_mipmap_tree *depth_mt,
                            uint32_t depth_offset, uint32_t depthbuffer_format,
                            uint32_t depth_surface_type,
                            struct intel_mipmap_tree *stencil_mt,
                            bool hiz, bool separate_stencil,
                            uint32_t width, uint32_t height,
                            uint32_t tile_x, uint32_t tile_y);

void
d1845 1
a1845 1
uint32_t get_hw_prim_for_gl_prim(int mode);
d1853 5
a1857 5
gen6_upload_push_constants(struct brw_context *brw,
                           const struct gl_program *prog,
                           const struct brw_stage_prog_data *prog_data,
                           struct brw_stage_state *stage_state,
                           enum aub_state_struct_type type);
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d43 2
a144 2
#define BRW_MAX_CURBE                    (32*16)

d146 1
a146 1
struct brw_instruction;
d185 1
d189 15
a203 15
#define BRW_NEW_URB_FENCE               (1 << BRW_STATE_URB_FENCE)
#define BRW_NEW_FRAGMENT_PROGRAM        (1 << BRW_STATE_FRAGMENT_PROGRAM)
#define BRW_NEW_GEOMETRY_PROGRAM        (1 << BRW_STATE_GEOMETRY_PROGRAM)
#define BRW_NEW_VERTEX_PROGRAM          (1 << BRW_STATE_VERTEX_PROGRAM)
#define BRW_NEW_CURBE_OFFSETS           (1 << BRW_STATE_CURBE_OFFSETS)
#define BRW_NEW_REDUCED_PRIMITIVE       (1 << BRW_STATE_REDUCED_PRIMITIVE)
#define BRW_NEW_PRIMITIVE               (1 << BRW_STATE_PRIMITIVE)
#define BRW_NEW_CONTEXT                 (1 << BRW_STATE_CONTEXT)
#define BRW_NEW_PSP                     (1 << BRW_STATE_PSP)
#define BRW_NEW_SURFACES		(1 << BRW_STATE_SURFACES)
#define BRW_NEW_VS_BINDING_TABLE	(1 << BRW_STATE_VS_BINDING_TABLE)
#define BRW_NEW_GS_BINDING_TABLE	(1 << BRW_STATE_GS_BINDING_TABLE)
#define BRW_NEW_PS_BINDING_TABLE	(1 << BRW_STATE_PS_BINDING_TABLE)
#define BRW_NEW_INDICES			(1 << BRW_STATE_INDICES)
#define BRW_NEW_VERTICES		(1 << BRW_STATE_VERTICES)
d208 1
a208 1
#define BRW_NEW_BATCH                  (1 << BRW_STATE_BATCH)
d210 17
a226 16
#define BRW_NEW_INDEX_BUFFER           (1 << BRW_STATE_INDEX_BUFFER)
#define BRW_NEW_VS_CONSTBUF            (1 << BRW_STATE_VS_CONSTBUF)
#define BRW_NEW_GS_CONSTBUF            (1 << BRW_STATE_GS_CONSTBUF)
#define BRW_NEW_PROGRAM_CACHE		(1 << BRW_STATE_PROGRAM_CACHE)
#define BRW_NEW_STATE_BASE_ADDRESS	(1 << BRW_STATE_STATE_BASE_ADDRESS)
#define BRW_NEW_VUE_MAP_VS		(1 << BRW_STATE_VUE_MAP_VS)
#define BRW_NEW_VUE_MAP_GEOM_OUT	(1 << BRW_STATE_VUE_MAP_GEOM_OUT)
#define BRW_NEW_TRANSFORM_FEEDBACK	(1 << BRW_STATE_TRANSFORM_FEEDBACK)
#define BRW_NEW_RASTERIZER_DISCARD	(1 << BRW_STATE_RASTERIZER_DISCARD)
#define BRW_NEW_STATS_WM		(1 << BRW_STATE_STATS_WM)
#define BRW_NEW_UNIFORM_BUFFER          (1 << BRW_STATE_UNIFORM_BUFFER)
#define BRW_NEW_ATOMIC_BUFFER           (1 << BRW_STATE_ATOMIC_BUFFER)
#define BRW_NEW_META_IN_PROGRESS        (1 << BRW_STATE_META_IN_PROGRESS)
#define BRW_NEW_INTERPOLATION_MAP       (1 << BRW_STATE_INTERPOLATION_MAP)
#define BRW_NEW_PUSH_CONSTANT_ALLOCATION (1 << BRW_STATE_PUSH_CONSTANT_ALLOCATION)
#define BRW_NEW_NUM_SAMPLES             (1 << BRW_STATE_NUM_SAMPLES)
d234 9
a242 2
   GLuint brw;
   /** State update flags signalled by brw_state_cache.c searches */
a245 65
#define AUB_TRACE_TYPE_MASK		0x0000ff00
#define AUB_TRACE_TYPE_NOTYPE		(0 << 8)
#define AUB_TRACE_TYPE_BATCH		(1 << 8)
#define AUB_TRACE_TYPE_VERTEX_BUFFER	(5 << 8)
#define AUB_TRACE_TYPE_2D_MAP		(6 << 8)
#define AUB_TRACE_TYPE_CUBE_MAP		(7 << 8)
#define AUB_TRACE_TYPE_VOLUME_MAP	(9 << 8)
#define AUB_TRACE_TYPE_1D_MAP		(10 << 8)
#define AUB_TRACE_TYPE_CONSTANT_BUFFER	(11 << 8)
#define AUB_TRACE_TYPE_CONSTANT_URB	(12 << 8)
#define AUB_TRACE_TYPE_INDEX_BUFFER	(13 << 8)
#define AUB_TRACE_TYPE_GENERAL		(14 << 8)
#define AUB_TRACE_TYPE_SURFACE		(15 << 8)

/**
 * state_struct_type enum values are encoded with the top 16 bits representing
 * the type to be delivered to the .aub file, and the bottom 16 bits
 * representing the subtype.  This macro performs the encoding.
 */
#define ENCODE_SS_TYPE(type, subtype) (((type) << 16) | (subtype))

enum state_struct_type {
   AUB_TRACE_VS_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 1),
   AUB_TRACE_GS_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 2),
   AUB_TRACE_CLIP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 3),
   AUB_TRACE_SF_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 4),
   AUB_TRACE_WM_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 5),
   AUB_TRACE_CC_STATE =			ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 6),
   AUB_TRACE_CLIP_VP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 7),
   AUB_TRACE_SF_VP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 8),
   AUB_TRACE_CC_VP_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x9),
   AUB_TRACE_SAMPLER_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xa),
   AUB_TRACE_KERNEL_INSTRUCTIONS =	ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xb),
   AUB_TRACE_SCRATCH_SPACE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xc),
   AUB_TRACE_SAMPLER_DEFAULT_COLOR =    ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0xd),

   AUB_TRACE_SCISSOR_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x15),
   AUB_TRACE_BLEND_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x16),
   AUB_TRACE_DEPTH_STENCIL_STATE =	ENCODE_SS_TYPE(AUB_TRACE_TYPE_GENERAL, 0x17),

   AUB_TRACE_VERTEX_BUFFER =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_VERTEX_BUFFER, 0),
   AUB_TRACE_BINDING_TABLE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_SURFACE, 0x100),
   AUB_TRACE_SURFACE_STATE =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_SURFACE, 0x200),
   AUB_TRACE_VS_CONSTANTS =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_CONSTANT_BUFFER, 0),
   AUB_TRACE_WM_CONSTANTS =		ENCODE_SS_TYPE(AUB_TRACE_TYPE_CONSTANT_BUFFER, 1),
};

/**
 * Decode a state_struct_type value to determine the type that should be
 * stored in the .aub file.
 */
static inline uint32_t AUB_TRACE_TYPE(enum state_struct_type ss_type)
{
   return (ss_type & 0xFFFF0000) >> 16;
}

/**
 * Decode a state_struct_type value to determine the subtype that should be
 * stored in the .aub file.
 */
static inline uint32_t AUB_TRACE_SUBTYPE(enum state_struct_type ss_type)
{
   return ss_type & 0xFFFF;
}

d303 9
d318 2
a319 2
   const float **param;
   const float **pull_param;
a332 1
   GLuint curb_read_length;
d335 1
a335 2
   GLuint first_curbe_grf;
   GLuint first_curbe_grf_16;
a337 1
   GLuint total_scratch;
d347 1
d351 1
a537 7
   /**
    * Register where the thread expects to find input data from the URB
    * (typically uniforms, followed by per-vertex inputs).
    */
   unsigned dispatch_grf_start_reg;

   GLuint curb_read_length;
a539 1
   GLuint total_scratch;
d558 1
a558 40
};


/* Note: brw_gs_prog_data_compare() must be updated when adding fields to
 * this struct!
 */
struct brw_gs_prog_data
{
   struct brw_vec4_prog_data base;

   /**
    * Size of an output vertex, measured in HWORDS (32 bytes).
    */
   unsigned output_vertex_size_hwords;

   unsigned output_topology;

   /**
    * Size of the control data (cut bits or StreamID bits), in hwords (32
    * bytes).  0 if there is no control data.
    */
   unsigned control_data_header_size_hwords;

   /**
    * Format of the control data (either GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_SID
    * if the control data is StreamID bits, or
    * GEN7_GS_CONTROL_DATA_FORMAT_GSCTL_CUT if the control data is cut bits).
    * Ignored if control_data_header_size is 0.
    */
   unsigned control_data_format;

   bool include_primitive_id;

   int invocations;

   /**
    * True if the thread should be dispatched in DUAL_INSTANCE mode, false if
    * it should be dispatched in DUAL_OBJECT mode.
    */
   bool dual_instanced_dispatch;
d605 71
a675 1
#define BRW_MAX_GEN6_GS_SURFACES       SURF_INDEX_GEN6_SOL_BINDING(BRW_MAX_SOL_BINDINGS)
a689 1
   BRW_BLORP_CONST_COLOR_PROG,
a783 1
#define CACHE_NEW_BLORP_CONST_COLOR_PROG (1<<BRW_BLORP_CONST_COLOR_PROG)
a925 3

   /** Offsets in the batch to sampler default colors (texture border color) */
   uint32_t sdc_offset[BRW_MAX_TEX_UNIT];
a964 5
      /** Upload a SAMPLER_STATE table. */
      void (*upload_sampler_state_table)(struct brw_context *brw,
                                         struct gl_program *prog,
                                         struct brw_stage_state *stage_state);

d1056 1
d1067 2
d1095 15
d1172 1
d1195 1
a1195 1
      /* gen6: True if the most recently sent _3DSTATE_URB message allocated
d1198 1
a1198 1
      bool gen6_gs_previously_active;
d1213 4
a1219 16
      /** Offset within curbe_bo of space for next curbe entry */
      GLuint curbe_next_offset;

      /**
       * Copy of the last set of CURBEs uploaded.  Frequently we'll end up
       * in brw_curbe.c with the same set of constant data to be uploaded,
       * so we'd rather not upload new constants in that case (it can cause
       * a pipeline bubble since only up to 4 can be pipelined at a time).
       */
      GLfloat *last_buf;
      /**
       * Allocation for where to calculate the next set of CURBEs.
       * It's a hot enough path that malloc/free of that data matters.
       */
      GLfloat *next_buf;
      GLuint last_bufsz;
d1263 6
a1268 1
      uint32_t surf_offset[BRW_MAX_GEN6_GS_SURFACES];
d1294 1
d1308 1
d1368 1
a1368 1
      enum state_struct_type type;
d1414 2
a1434 2
extern void intelFinish(struct gl_context * ctx);

d1477 13
d1571 2
a1572 1
int brw_disasm (FILE *file, struct brw_instruction *inst, int gen);
d1699 2
d1819 10
d1850 1
a1850 1
extern const GLuint prim_to_hw_prim[GL_TRIANGLE_STRIP_ADJACENCY+1];
d1858 5
a1862 5
gen6_upload_vec4_push_constants(struct brw_context *brw,
                                const struct gl_program *prog,
                                const struct brw_vec4_prog_data *prog_data,
                                struct brw_stage_state *stage_state,
                                enum state_struct_type type);
@


