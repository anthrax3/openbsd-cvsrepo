head	1.14;
access;
symbols
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	v10_2_9:1.1.1.10
	v10_4_3:1.1.1.9
	v10_2_7:1.1.1.8
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	v10_2_3:1.1.1.7
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	v9_2_5:1.1.1.6
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.13;
commitid	TnlogFl9nOv2eaRf;

1.13
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.12;
commitid	4ry2gvZGMXkCUD2n;

1.12
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.11;
commitid	mcxB0JvoI9gTDYXU;

1.11
date	2014.09.07.15.20.07;	author jsg;	state Exp;
branches;
next	1.10;
commitid	7kimTMT4YlQauAIU;

1.10
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.9;
commitid	WPD6rgPryPkvXOr9;

1.9
date	2014.01.19.03.13.15;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2013.09.05.14.04.22;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.22.20.04.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.15;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.49;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.49;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.17;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.28.39;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.15.41;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.01.19.03.04.27;	author jsg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.07.09.20.34.52;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.8
date	2014.09.07.15.06.17;	author jsg;	state Exp;
branches;
next	1.1.1.9;
commitid	dm8VnQHhowGHmemJ;

1.1.1.9
date	2015.01.25.14.11.49;	author jsg;	state Exp;
branches;
next	1.1.1.10;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.10
date	2015.02.20.22.48.54;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.14
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics to
 develop this 3D driver.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */


#ifndef BRW_WM_H
#define BRW_WM_H

#include <stdbool.h>

#include "program/prog_instruction.h"
#include "brw_context.h"
#include "brw_eu.h"
#include "brw_program.h"

/* A big lookup table is used to figure out which and how many
 * additional regs will inserted before the main payload in the WM
 * program execution.  These mainly relate to depth and stencil
 * processing and the early-depth-test optimization.
 */
#define IZ_PS_KILL_ALPHATEST_BIT    0x1
#define IZ_PS_COMPUTES_DEPTH_BIT    0x2
#define IZ_DEPTH_WRITE_ENABLE_BIT   0x4
#define IZ_DEPTH_TEST_ENABLE_BIT    0x8
#define IZ_STENCIL_WRITE_ENABLE_BIT 0x10
#define IZ_STENCIL_TEST_ENABLE_BIT  0x20
#define IZ_BIT_MAX                  0x40

#define AA_NEVER     0
#define AA_SOMETIMES 1
#define AA_ALWAYS    2

struct brw_wm_prog_key {
   uint8_t iz_lookup;
   GLuint stats_wm:1;
   GLuint flat_shade:1;
   GLuint persample_shading:1;
   GLuint persample_2x:1;
   GLuint nr_color_regions:5;
   GLuint replicate_alpha:1;
   GLuint render_to_fbo:1;
   GLuint clamp_fragment_color:1;
   GLuint compute_pos_offset:1;
   GLuint compute_sample_id:1;
   GLuint line_aa:2;
   GLuint high_quality_derivatives:1;

   GLushort drawable_height;
   GLbitfield64 input_slots_valid;
   GLuint program_string_id:32;
   GLenum alpha_test_func;          /* < For Gen4/5 MRT alpha test */
   float alpha_test_ref;

   struct brw_sampler_prog_key_data tex;
};

struct brw_wm_compile {
   struct brw_wm_prog_key key;
   struct brw_wm_prog_data prog_data;

   uint8_t source_depth_reg;
   uint8_t source_w_reg;
   uint8_t aa_dest_stencil_reg;
   uint8_t dest_depth_reg;
   uint8_t sample_pos_reg;
   uint8_t sample_mask_reg;
   uint8_t barycentric_coord_reg[BRW_WM_BARYCENTRIC_INTERP_MODE_COUNT];
   uint8_t nr_payload_regs;
   GLuint source_depth_to_render_target:1;
   GLuint runtime_check_aads_emit:1;

   GLuint last_scratch;
};

/**
 * Compile a fragment shader.
 *
 * Returns the final assembly and the program's size.
 */
const unsigned *brw_wm_fs_emit(struct brw_context *brw,
                               struct brw_wm_compile *c,
                               struct gl_fragment_program *fp,
                               struct gl_shader_program *prog,
                               unsigned *final_assembly_size);

GLboolean brw_link_shader(struct gl_context *ctx, struct gl_shader_program *prog);
struct gl_shader *brw_new_shader(struct gl_context *ctx, GLuint name, GLuint type);
struct gl_shader_program *brw_new_shader_program(struct gl_context *ctx, GLuint name);

bool brw_color_buffer_write_enabled(struct brw_context *brw);
bool do_wm_prog(struct brw_context *brw,
		struct gl_shader_program *prog,
		struct brw_fragment_program *fp,
		struct brw_wm_prog_key *key);
void brw_wm_debug_recompile(struct brw_context *brw,
                            struct gl_shader_program *prog,
                            const struct brw_wm_prog_key *key);
bool brw_wm_prog_data_compare(const void *a, const void *b);

#endif
@


1.13
log
@Merge Mesa 10.2.9
@
text
@@


1.12
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d84 18
d108 1
a108 3
                               void *mem_ctx,
                               const struct brw_wm_prog_key *key,
                               struct brw_wm_prog_data *prog_data,
d115 1
@


1.11
log
@Merge Mesa 10.2.7
@
text
@a83 18
struct brw_wm_compile {
   struct brw_wm_prog_key key;
   struct brw_wm_prog_data prog_data;

   uint8_t source_depth_reg;
   uint8_t source_w_reg;
   uint8_t aa_dest_stencil_reg;
   uint8_t dest_depth_reg;
   uint8_t sample_pos_reg;
   uint8_t sample_mask_reg;
   uint8_t barycentric_coord_reg[BRW_WM_BARYCENTRIC_INTERP_MODE_COUNT];
   uint8_t nr_payload_regs;
   GLuint source_depth_to_render_target:1;
   GLuint runtime_check_aads_emit:1;

   GLuint last_scratch;
};

d90 3
a92 1
                               struct brw_wm_compile *c,
a98 1
struct gl_shader_program *brw_new_shader_program(struct gl_context *ctx, GLuint name);
@


1.10
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d65 1
@


1.9
log
@Merge Mesa 9.2.5
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
d5 1
a5 1
 
d13 1
a13 1
 
d17 1
a17 1
 
d25 1
a25 1
 
d29 1
a29 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d31 1
a31 1
              
d64 1
d69 2
d72 1
d91 2
d124 1
a124 3
bool brw_wm_prog_data_compare(const void *a, const void *b,
                              int aux_size, const void *key);
void brw_wm_prog_data_free(const void *in_prog_data);
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d73 2
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d41 1
a41 2

#define SATURATE (1<<5)
d65 1
a66 1
   GLuint alpha_test:1;
a69 18
   /**
    * Per-sampler comparison functions:
    *
    * If comparison mode is GL_COMPARE_R_TO_TEXTURE, then this is set to one
    * of GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL,
    * GL_GEQUAL, or GL_ALWAYS.  Otherwise (comparison mode is GL_NONE), this
    * field is irrelevant so it's left as GL_NONE (0).
    *
    * While this is a GLenum, all possible values fit in 16-bits.
    */
   uint16_t compare_funcs[BRW_MAX_TEX_UNIT];

   GLbitfield proj_attrib_mask; /**< one bit per fragment program attribute */
   GLuint yuvtex_mask:16;
   GLuint yuvtex_swap_mask:16;	/* UV swaped */
   uint16_t gl_clamp_mask[3];

   GLushort tex_swizzles[BRW_MAX_TEX_UNIT];
d71 1
a71 1
   GLbitfield64 vp_outputs_written;
a72 2
};

d74 1
a74 32
/* A bit of a glossary:
 *
 * brw_wm_value: A computed value or program input.  Values are
 * constant, they are created once and are never modified.  When a
 * fragment program register is written or overwritten, new values are
 * created fresh, preserving the rule that values are constant.
 *
 * brw_wm_ref: A reference to a value.  Wherever a value used is by an
 * instruction or as a program output, that is tracked with an
 * instance of this struct.  All references to a value occur after it
 * is created.  After the last reference, a value is dead and can be
 * discarded.
 *
 * brw_wm_grf: Represents a physical hardware register.  May be either
 * empty or hold a value.  Register allocation is the process of
 * assigning values to grf registers.  This occurs in pass2 and the
 * brw_wm_grf struct is not used before that.
 *
 * Fragment program registers: These are time-varying constructs that
 * are hard to reason about and which we translate away in pass0.  A
 * single fragment program register element (eg. temp[0].x) will be
 * translated to one or more brw_wm_value structs, one for each time
 * that temp[0].x is written to during the program. 
 */



/* Used in pass2 to track register allocation.
 */
struct brw_wm_grf {
   struct brw_wm_value *value;
   GLuint nextuse;
a76 71
struct brw_wm_value {
   struct brw_reg hw_reg;	/* emitted to this reg, may not always be there */
   struct brw_wm_ref *lastuse;
   struct brw_wm_grf *resident; 
   GLuint contributes_to_output:1;
   GLuint spill_slot:16;	/* if non-zero, spill immediately after calculation */
};

struct brw_wm_ref {
   struct brw_reg hw_reg;	/* nr filled in in pass2, everything else, pass0 */
   struct brw_wm_value *value;
   struct brw_wm_ref *prevuse;
   GLuint unspill_reg:7;	/* unspill to reg */
   GLuint emitted:1;
   GLuint insn:24;
};

struct brw_wm_constref {
   const struct brw_wm_ref *ref;
   GLfloat constval;
};


struct brw_wm_instruction {
   struct brw_wm_value *dst[4];
   struct brw_wm_ref *src[3][4];
   GLuint opcode:8;
   GLuint saturate:1;
   GLuint writemask:4;
   GLuint tex_unit:4;   /* texture unit for TEX, TXD, TXP instructions */
   GLuint tex_idx:3;    /* TEXTURE_1D,2D,3D,CUBE,RECT_INDEX source target */
   GLuint tex_shadow:1; /* do shadow comparison? */
   GLuint eot:1;    	/* End of thread indicator for FB_WRITE*/
   GLuint target:10;    /* target binding table index for FB_WRITE*/
};


#define BRW_WM_MAX_INSN  (MAX_PROGRAM_INSTRUCTIONS*3 + FRAG_ATTRIB_MAX + 3)
#define BRW_WM_MAX_GRF   128		/* hardware limit */
#define BRW_WM_MAX_VREG  (BRW_WM_MAX_INSN * 4)
#define BRW_WM_MAX_REF   (BRW_WM_MAX_INSN * 12)
#define BRW_WM_MAX_PARAM 256
#define BRW_WM_MAX_CONST 256
#define BRW_WM_MAX_SUBROUTINE 16

/* used in masks next to WRITEMASK_*. */
#define SATURATE (1<<5)


/* New opcodes to track internal operations required for WM unit.
 * These are added early so that the registers used can be tracked,
 * freed and reused like those of other instructions.
 */
#define WM_PIXELXY        (MAX_OPCODE)
#define WM_DELTAXY        (MAX_OPCODE + 1)
#define WM_PIXELW         (MAX_OPCODE + 2)
#define WM_LINTERP        (MAX_OPCODE + 3)
#define WM_PINTERP        (MAX_OPCODE + 4)
#define WM_CINTERP        (MAX_OPCODE + 5)
#define WM_WPOSXY         (MAX_OPCODE + 6)
#define WM_FB_WRITE       (MAX_OPCODE + 7)
#define WM_FRONTFACING    (MAX_OPCODE + 8)
#define MAX_WM_OPCODE     (MAX_OPCODE + 9)

#define PROGRAM_PAYLOAD   (PROGRAM_FILE_MAX)
#define NUM_FILES	  (PROGRAM_PAYLOAD + 1)

#define PAYLOAD_DEPTH     (FRAG_ATTRIB_MAX)
#define PAYLOAD_W         (FRAG_ATTRIB_MAX + 1)
#define PAYLOAD_FP_REG_MAX (FRAG_ATTRIB_MAX + 2)

a77 1
   struct brw_compile func;
a80 9
   struct brw_fragment_program *fp;

   GLfloat (*env_param)[4];

   enum {
      START,
      PASS2_DONE
   } state;

d85 1
a86 1
   GLuint computes_depth:1;	/* could be derived from program string */
a89 44
   /* Initial pass - translate fp instructions to fp instructions,
    * simplifying and adding instructions for interpolation and
    * framebuffer writes.
    */
   struct prog_instruction *prog_instructions;
   GLuint nr_fp_insns;
   GLuint fp_temp;
   GLuint fp_interp_emitted;

   struct prog_src_register pixel_xy;
   struct prog_src_register delta_xy;
   struct prog_src_register pixel_w;


   struct brw_wm_value *vreg;
   GLuint nr_vreg;

   struct brw_wm_value creg[BRW_WM_MAX_PARAM];
   GLuint nr_creg;

   struct {
      struct brw_wm_value depth[4]; /* includes r0/r1 */
      struct brw_wm_value input_interp[FRAG_ATTRIB_MAX];
   } payload;


   const struct brw_wm_ref *pass0_fp_reg[NUM_FILES][256][4];

   struct brw_wm_ref undef_ref;
   struct brw_wm_value undef_value;

   struct brw_wm_ref *refs;
   GLuint nr_refs;

   struct brw_wm_instruction *instruction;
   GLuint nr_insns;

   struct brw_wm_constref constref[BRW_WM_MAX_CONST];
   GLuint nr_constrefs;

   struct brw_wm_grf pass2_grf[BRW_WM_MAX_GRF/2];

   GLuint grf_limit;
   GLuint max_wm_grf;
a90 26

   GLuint cur_inst;  /**< index of current instruction */

   GLboolean out_of_regs;  /**< ran out of GRF registers? */

   /** Mapping from Mesa registers to hardware registers */
   struct {
      GLboolean inited;
      struct brw_reg reg;
   } wm_regs[NUM_FILES][256][4];

   GLboolean used_grf[BRW_WM_MAX_GRF];
   GLuint first_free_grf;
   struct brw_reg stack;
   struct brw_reg emit_mask_reg;
   GLuint tmp_regs[BRW_WM_MAX_GRF];
   GLuint tmp_index;
   GLuint tmp_max;
   GLuint subroutines[BRW_WM_MAX_SUBROUTINE];
   GLuint dispatch_width;

   /** we may need up to 3 constants per instruction (if use_const_buffer) */
   struct {
      GLint index;
      struct brw_reg reg;
   } current_const[3];
d93 10
a102 185

/** Bits for prog_instruction::Aux field */
#define INST_AUX_EOT      0x1
#define INST_AUX_TARGET(T)  (T << 1)
#define INST_AUX_GET_TARGET(AUX) ((AUX) >> 1)


GLuint brw_wm_nr_args( GLuint opcode );
GLuint brw_wm_is_scalar_result( GLuint opcode );

void brw_wm_pass_fp( struct brw_wm_compile *c );
void brw_wm_pass0( struct brw_wm_compile *c );
void brw_wm_pass1( struct brw_wm_compile *c );
void brw_wm_pass2( struct brw_wm_compile *c );
void brw_wm_emit( struct brw_wm_compile *c );
GLboolean brw_wm_arg_can_be_immediate(enum prog_opcode, int arg);
void brw_wm_print_value( struct brw_wm_compile *c,
			 struct brw_wm_value *value );

void brw_wm_print_ref( struct brw_wm_compile *c,
		       struct brw_wm_ref *ref );

void brw_wm_print_insn( struct brw_wm_compile *c,
			struct brw_wm_instruction *inst );

void brw_wm_print_program( struct brw_wm_compile *c,
			   const char *stage );

void brw_wm_lookup_iz(struct intel_context *intel,
		      struct brw_wm_compile *c);

bool brw_wm_fs_emit(struct brw_context *brw, struct brw_wm_compile *c,
		    struct gl_shader_program *prog);

/* brw_wm_emit.c */
void emit_alu1(struct brw_compile *p,
	       struct brw_instruction *(*func)(struct brw_compile *,
					       struct brw_reg,
					       struct brw_reg),
	       const struct brw_reg *dst,
	       GLuint mask,
	       const struct brw_reg *arg0);
void emit_alu2(struct brw_compile *p,
	       struct brw_instruction *(*func)(struct brw_compile *,
					       struct brw_reg,
					       struct brw_reg,
					       struct brw_reg),
	       const struct brw_reg *dst,
	       GLuint mask,
	       const struct brw_reg *arg0,
	       const struct brw_reg *arg1);
void emit_cinterp(struct brw_compile *p,
		  const struct brw_reg *dst,
		  GLuint mask,
		  const struct brw_reg *arg0);
void emit_cmp(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1,
	      const struct brw_reg *arg2);
void emit_ddxy(struct brw_compile *p,
	       const struct brw_reg *dst,
	       GLuint mask,
	       GLboolean is_ddx,
	       const struct brw_reg *arg0);
void emit_delta_xy(struct brw_compile *p,
		   const struct brw_reg *dst,
		   GLuint mask,
		   const struct brw_reg *arg0);
void emit_dp2(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);
void emit_dp3(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);
void emit_dp4(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);
void emit_dph(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);
void emit_fb_write(struct brw_wm_compile *c,
		   struct brw_reg *arg0,
		   struct brw_reg *arg1,
		   struct brw_reg *arg2,
		   GLuint target,
		   GLuint eot);
void emit_frontfacing(struct brw_compile *p,
		      const struct brw_reg *dst,
		      GLuint mask);
void emit_linterp(struct brw_compile *p,
		  const struct brw_reg *dst,
		  GLuint mask,
		  const struct brw_reg *arg0,
		  const struct brw_reg *deltas);
void emit_lrp(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1,
	      const struct brw_reg *arg2);
void emit_mad(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1,
	      const struct brw_reg *arg2);
void emit_math1(struct brw_wm_compile *c,
		GLuint function,
		const struct brw_reg *dst,
		GLuint mask,
		const struct brw_reg *arg0);
void emit_math2(struct brw_wm_compile *c,
		GLuint function,
		const struct brw_reg *dst,
		GLuint mask,
		const struct brw_reg *arg0,
		const struct brw_reg *arg1);
void emit_min(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);
void emit_max(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);
void emit_pinterp(struct brw_compile *p,
		  const struct brw_reg *dst,
		  GLuint mask,
		  const struct brw_reg *arg0,
		  const struct brw_reg *deltas,
		  const struct brw_reg *w);
void emit_pixel_xy(struct brw_wm_compile *c,
		   const struct brw_reg *dst,
		   GLuint mask);
void emit_pixel_w(struct brw_wm_compile *c,
		  const struct brw_reg *dst,
		  GLuint mask,
		  const struct brw_reg *arg0,
		  const struct brw_reg *deltas);
void emit_sop(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      GLuint cond,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);
void emit_sign(struct brw_compile *p,
	       const struct brw_reg *dst,
	       GLuint mask,
	       const struct brw_reg *arg0);
void emit_tex(struct brw_wm_compile *c,
	      struct brw_reg *dst,
	      GLuint dst_flags,
	      struct brw_reg *arg,
	      struct brw_reg depth_payload,
	      GLuint tex_idx,
	      GLuint sampler,
	      GLboolean shadow);
void emit_txb(struct brw_wm_compile *c,
	      struct brw_reg *dst,
	      GLuint dst_flags,
	      struct brw_reg *arg,
	      struct brw_reg depth_payload,
	      GLuint tex_idx,
	      GLuint sampler);
void emit_wpos_xy(struct brw_wm_compile *c,
		  const struct brw_reg *dst,
		  GLuint mask,
		  const struct brw_reg *arg0);
void emit_xpd(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);
a108 3
bool brw_render_target_supported(gl_format format);
void brw_wm_payload_setup(struct brw_context *brw,
			  struct brw_wm_compile *c);
d113 6
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d62 1
a64 1
   GLuint linear_color:1;  /**< linear interpolation vs perspective interp */
d68 14
a83 1
   GLuint shadowtex_mask:16;
d86 1
a88 1

a90 2
   GLuint iz_lookup;
   GLuint line_aa;
d214 5
a218 5
   GLuint source_depth_reg:3;
   GLuint source_w_reg:3;
   GLuint aa_dest_stencil_reg:3;
   GLuint dest_depth_reg:3;
   GLuint nr_payload_regs:4;
a230 1
   GLuint fp_fragcolor_emitted;
d327 2
a328 1
GLboolean brw_wm_fs_emit(struct brw_context *brw, struct brw_wm_compile *c);
a481 2
GLboolean brw_compile_shader(struct gl_context *ctx,
			     struct gl_shader *shader);
d487 7
@


1.5
log
@Update to Mesa 7.8.2. Tested by johan@@. Thanks.
@
text
@d36 1
d38 1
a38 1
#include "shader/prog_instruction.h"
d62 1
a62 6
   GLuint source_depth_reg:3;
   GLuint aa_dest_stencil_reg:3;
   GLuint dest_depth_reg:3;
   GLuint nr_depth_regs:3;
   GLuint computes_depth:1;	/* could be derived from program string */
   GLuint source_depth_to_render_target:1;
a64 1
   GLuint runtime_check_aads_emit:1;
d66 3
a68 1
   
d78 2
d183 2
d186 2
d203 9
d239 1
a239 1
   const struct brw_wm_ref *pass0_fp_reg[PROGRAM_PAYLOAD+1][256][4];
d267 1
a267 1
   } wm_regs[PROGRAM_PAYLOAD+1][256][4];
d301 1
a301 1

d314 2
a315 4
void brw_wm_lookup_iz( GLuint line_aa,
		       GLuint lookup,
		       GLboolean ps_uses_depth,
		       struct brw_wm_prog_key *key );
d317 1
a317 2
GLboolean brw_wm_is_glsl(const struct gl_fragment_program *fp);
void brw_wm_glsl_emit(struct brw_context *brw, struct brw_wm_compile *c);
d355 5
d442 4
d470 8
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d70 1
a70 1
   GLuint nr_color_regions:2;
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d41 2
d68 1
d70 1
d72 1
a72 1
   GLuint projtex_mask:16;
a75 1
   //   GLuint pad1:16;
d77 4
a81 2
   GLuint origin_x, origin_y;
   GLuint drawable_height;
d150 1
d156 1
a156 3
#define PROGRAM_INTERNAL_PARAM 

#define BRW_WM_MAX_INSN  (MAX_NV_FRAGMENT_PROGRAM_INSTRUCTIONS*3 + FRAG_ATTRIB_MAX + 3)
a161 1
#define BRW_WM_MAX_KILLS MAX_NV_FRAGMENT_PROGRAM_INSTRUCTIONS
d164 2
d204 1
a204 1
   struct prog_instruction prog_instructions[BRW_WM_MAX_INSN];
a208 1
   GLuint fp_deriv_emitted;
d215 1
a215 1
   struct brw_wm_value vreg[BRW_WM_MAX_VREG];
d232 1
a232 1
   struct brw_wm_ref refs[BRW_WM_MAX_REF];
d235 1
a235 1
   struct brw_wm_instruction instruction[BRW_WM_MAX_INSN];
d247 5
d253 2
a254 2
	GLboolean inited;
	struct brw_reg reg;
d256 3
a260 1
   GLuint reg_index;
d265 7
d275 6
d304 1
d310 142
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d52 1
a52 2
#define IZ_EARLY_DEPTH_TEST_BIT     0x40
#define IZ_BIT_MAX                  0x80
a62 2
   GLuint projtex_mask:8;
   GLuint shadowtex_mask:8;
d68 5
a72 3
   GLuint yuvtex_mask:8;
   GLuint yuvtex_swap_mask:8;	/* UV swaped */
   GLuint pad1:16;
d159 1
d175 2
a176 1
#define MAX_WM_OPCODE     (MAX_OPCODE + 8)
d250 1
d252 2
d284 2
@


1.1
log
@Initial revision
@
text
@d37 1
a39 1
#include "program_instruction.h"
d72 2
a73 1
   GLuint pad1:24;
d76 2
d146 2
d175 1
d202 2
d241 9
d278 2
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a169 1
#define MAX_WM_OPCODE     (MAX_OPCODE + 8)
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d39 1
a39 1
#include "prog_instruction.h"
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@a35 1
#include <stdbool.h>
a36 1
#include "program/prog_instruction.h"
d39 1
a39 2

#define SATURATE (1<<5)
d52 2
a53 1
#define IZ_BIT_MAX                  0x40
d60 8
a67 1
   GLuint stats_wm:1;
d69 5
a73 16
   GLuint linear_color:1;  /**< linear interpolation vs perspective interp */
   GLuint nr_color_regions:5;
   GLuint render_to_fbo:1;
   GLuint alpha_test:1;

   GLbitfield proj_attrib_mask; /**< one bit per fragment program attribute */
   GLuint shadowtex_mask:16;
   GLuint yuvtex_mask:16;
   GLuint yuvtex_swap_mask:16;	/* UV swaped */

   GLushort tex_swizzles[BRW_MAX_TEX_UNIT];

   GLushort drawable_height;
   GLbitfield64 vp_outputs_written;
   GLuint iz_lookup;
   GLuint line_aa;
a142 3
   GLuint tex_shadow:1; /* do shadow comparison? */
   GLuint eot:1;    	/* End of thread indicator for FB_WRITE*/
   GLuint target:10;    /* target binding table index for FB_WRITE*/
d146 3
a148 1
#define BRW_WM_MAX_INSN  (MAX_PROGRAM_INSTRUCTIONS*3 + FRAG_ATTRIB_MAX + 3)
d154 1
a154 1
#define BRW_WM_MAX_SUBROUTINE 16
a155 2
/* used in masks next to WRITEMASK_*. */
#define SATURATE (1<<5)
d170 1
a170 2
#define WM_FRONTFACING    (MAX_OPCODE + 8)
#define MAX_WM_OPCODE     (MAX_OPCODE + 9)
a172 2
#define NUM_FILES	  (PROGRAM_PAYLOAD + 1)

a173 2
#define PAYLOAD_W         (FRAG_ATTRIB_MAX + 1)
#define PAYLOAD_FP_REG_MAX (FRAG_ATTRIB_MAX + 2)
a188 9
   GLuint source_depth_reg:3;
   GLuint source_w_reg:3;
   GLuint aa_dest_stencil_reg:3;
   GLuint dest_depth_reg:3;
   GLuint nr_payload_regs:4;
   GLuint computes_depth:1;	/* could be derived from program string */
   GLuint source_depth_to_render_target:1;
   GLuint runtime_check_aads_emit:1;

d193 1
a193 1
   struct prog_instruction *prog_instructions;
a196 1
   GLuint fp_fragcolor_emitted;
d203 1
a203 1
   struct brw_wm_value *vreg;
d215 1
a215 1
   const struct brw_wm_ref *pass0_fp_reg[NUM_FILES][256][4];
d220 1
a220 1
   struct brw_wm_ref *refs;
d223 1
a223 1
   struct brw_wm_instruction *instruction;
a233 26

   GLuint cur_inst;  /**< index of current instruction */

   GLboolean out_of_regs;  /**< ran out of GRF registers? */

   /** Mapping from Mesa registers to hardware registers */
   struct {
      GLboolean inited;
      struct brw_reg reg;
   } wm_regs[NUM_FILES][256][4];

   GLboolean used_grf[BRW_WM_MAX_GRF];
   GLuint first_free_grf;
   struct brw_reg stack;
   struct brw_reg emit_mask_reg;
   GLuint tmp_regs[BRW_WM_MAX_GRF];
   GLuint tmp_index;
   GLuint tmp_max;
   GLuint subroutines[BRW_WM_MAX_SUBROUTINE];
   GLuint dispatch_width;

   /** we may need up to 3 constants per instruction (if use_const_buffer) */
   struct {
      GLint index;
      struct brw_reg reg;
   } current_const[3];
a236 6
/** Bits for prog_instruction::Aux field */
#define INST_AUX_EOT      0x1
#define INST_AUX_TARGET(T)  (T << 1)
#define INST_AUX_GET_TARGET(AUX) ((AUX) >> 1)


d245 1
a245 1
GLboolean brw_wm_arg_can_be_immediate(enum prog_opcode, int arg);
d258 3
a260 164
void brw_wm_lookup_iz(struct intel_context *intel,
		      struct brw_wm_compile *c);

GLboolean brw_wm_fs_emit(struct brw_context *brw, struct brw_wm_compile *c);

/* brw_wm_emit.c */
void emit_alu1(struct brw_compile *p,
	       struct brw_instruction *(*func)(struct brw_compile *,
					       struct brw_reg,
					       struct brw_reg),
	       const struct brw_reg *dst,
	       GLuint mask,
	       const struct brw_reg *arg0);
void emit_alu2(struct brw_compile *p,
	       struct brw_instruction *(*func)(struct brw_compile *,
					       struct brw_reg,
					       struct brw_reg,
					       struct brw_reg),
	       const struct brw_reg *dst,
	       GLuint mask,
	       const struct brw_reg *arg0,
	       const struct brw_reg *arg1);
void emit_cinterp(struct brw_compile *p,
		  const struct brw_reg *dst,
		  GLuint mask,
		  const struct brw_reg *arg0);
void emit_cmp(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1,
	      const struct brw_reg *arg2);
void emit_ddxy(struct brw_compile *p,
	       const struct brw_reg *dst,
	       GLuint mask,
	       GLboolean is_ddx,
	       const struct brw_reg *arg0);
void emit_delta_xy(struct brw_compile *p,
		   const struct brw_reg *dst,
		   GLuint mask,
		   const struct brw_reg *arg0);
void emit_dp2(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);
void emit_dp3(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);
void emit_dp4(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);
void emit_dph(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);
void emit_fb_write(struct brw_wm_compile *c,
		   struct brw_reg *arg0,
		   struct brw_reg *arg1,
		   struct brw_reg *arg2,
		   GLuint target,
		   GLuint eot);
void emit_frontfacing(struct brw_compile *p,
		      const struct brw_reg *dst,
		      GLuint mask);
void emit_linterp(struct brw_compile *p,
		  const struct brw_reg *dst,
		  GLuint mask,
		  const struct brw_reg *arg0,
		  const struct brw_reg *deltas);
void emit_lrp(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1,
	      const struct brw_reg *arg2);
void emit_mad(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1,
	      const struct brw_reg *arg2);
void emit_math1(struct brw_wm_compile *c,
		GLuint function,
		const struct brw_reg *dst,
		GLuint mask,
		const struct brw_reg *arg0);
void emit_math2(struct brw_wm_compile *c,
		GLuint function,
		const struct brw_reg *dst,
		GLuint mask,
		const struct brw_reg *arg0,
		const struct brw_reg *arg1);
void emit_min(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);
void emit_max(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);
void emit_pinterp(struct brw_compile *p,
		  const struct brw_reg *dst,
		  GLuint mask,
		  const struct brw_reg *arg0,
		  const struct brw_reg *deltas,
		  const struct brw_reg *w);
void emit_pixel_xy(struct brw_wm_compile *c,
		   const struct brw_reg *dst,
		   GLuint mask);
void emit_pixel_w(struct brw_wm_compile *c,
		  const struct brw_reg *dst,
		  GLuint mask,
		  const struct brw_reg *arg0,
		  const struct brw_reg *deltas);
void emit_sop(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      GLuint cond,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);
void emit_sign(struct brw_compile *p,
	       const struct brw_reg *dst,
	       GLuint mask,
	       const struct brw_reg *arg0);
void emit_tex(struct brw_wm_compile *c,
	      struct brw_reg *dst,
	      GLuint dst_flags,
	      struct brw_reg *arg,
	      struct brw_reg depth_payload,
	      GLuint tex_idx,
	      GLuint sampler,
	      GLboolean shadow);
void emit_txb(struct brw_wm_compile *c,
	      struct brw_reg *dst,
	      GLuint dst_flags,
	      struct brw_reg *arg,
	      struct brw_reg depth_payload,
	      GLuint tex_idx,
	      GLuint sampler);
void emit_wpos_xy(struct brw_wm_compile *c,
		  const struct brw_reg *dst,
		  GLuint mask,
		  const struct brw_reg *arg0);
void emit_xpd(struct brw_compile *p,
	      const struct brw_reg *dst,
	      GLuint mask,
	      const struct brw_reg *arg0,
	      const struct brw_reg *arg1);

GLboolean brw_compile_shader(struct gl_context *ctx,
			     struct gl_shader *shader);
GLboolean brw_link_shader(struct gl_context *ctx, struct gl_shader_program *prog);
struct gl_shader *brw_new_shader(struct gl_context *ctx, GLuint name, GLuint type);
struct gl_shader_program *brw_new_shader_program(struct gl_context *ctx, GLuint name);

bool brw_color_buffer_write_enabled(struct brw_context *brw);
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d41 2
a42 1
#include "brw_program.h"
a61 1
   uint8_t iz_lookup;
d64 1
a65 1
   GLuint replicate_alpha:1;
d67 8
a74 2
   GLuint clamp_fragment_color:1;
   GLuint line_aa:2;
d77 3
a79 1
   GLbitfield64 input_slots_valid;
d81 29
d111 41
a151 1
   struct brw_sampler_prog_key_data tex;
d154 35
d190 1
d194 15
a208 6
   uint8_t source_depth_reg;
   uint8_t source_w_reg;
   uint8_t aa_dest_stencil_reg;
   uint8_t dest_depth_reg;
   uint8_t barycentric_coord_reg[BRW_WM_BARYCENTRIC_INTERP_MODE_COUNT];
   uint8_t nr_payload_regs;
d212 45
d258 26
a285 10
/**
 * Compile a fragment shader.
 *
 * Returns the final assembly and the program's size.
 */
const unsigned *brw_wm_fs_emit(struct brw_context *brw,
                               struct brw_wm_compile *c,
                               struct gl_fragment_program *fp,
                               struct gl_shader_program *prog,
                               unsigned *final_assembly_size);
d287 186
a477 10
bool do_wm_prog(struct brw_context *brw,
		struct gl_shader_program *prog,
		struct brw_fragment_program *fp,
		struct brw_wm_prog_key *key);
void brw_wm_debug_recompile(struct brw_context *brw,
                            struct gl_shader_program *prog,
                            const struct brw_wm_prog_key *key);
bool brw_wm_prog_data_compare(const void *a, const void *b,
                              int aux_size, const void *key);
void brw_wm_prog_data_free(const void *in_prog_data);
@


1.1.1.6
log
@Import Mesa 9.2.5
@
text
@a72 2
   GLenum alpha_test_func;          /* < For Gen4/5 MRT alpha test */
   float alpha_test_ref;
@


1.1.1.7
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics to
d5 1
a5 1

d13 1
a13 1

d17 1
a17 1

d25 1
a25 1

d29 1
a29 1
  *   Keith Whitwell <keithw@@vmware.com>
d31 1
a31 1

a63 1
   GLuint persample_shading:1;
a67 2
   GLuint compute_pos_offset:1;
   GLuint compute_sample_id:1;
a68 1
   GLuint high_quality_derivatives:1;
a86 2
   uint8_t sample_pos_reg;
   uint8_t sample_mask_reg;
d118 3
a120 1
bool brw_wm_prog_data_compare(const void *a, const void *b);
@


1.1.1.8
log
@Import Mesa 10.2.7
@
text
@a64 1
   GLuint persample_2x:1;
@


1.1.1.9
log
@Import Mesa 10.4.3
@
text
@d84 18
d108 1
a108 3
                               void *mem_ctx,
                               const struct brw_wm_prog_key *key,
                               struct brw_wm_prog_data *prog_data,
d115 1
@


1.1.1.10
log
@Import Mesa 10.2.9
@
text
@a83 18
struct brw_wm_compile {
   struct brw_wm_prog_key key;
   struct brw_wm_prog_data prog_data;

   uint8_t source_depth_reg;
   uint8_t source_w_reg;
   uint8_t aa_dest_stencil_reg;
   uint8_t dest_depth_reg;
   uint8_t sample_pos_reg;
   uint8_t sample_mask_reg;
   uint8_t barycentric_coord_reg[BRW_WM_BARYCENTRIC_INTERP_MODE_COUNT];
   uint8_t nr_payload_regs;
   GLuint source_depth_to_render_target:1;
   GLuint runtime_check_aads_emit:1;

   GLuint last_scratch;
};

d90 3
a92 1
                               struct brw_wm_compile *c,
a98 1
struct gl_shader_program *brw_new_shader_program(struct gl_context *ctx, GLuint name);
@


