head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.5.0.4
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.2
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.15.39;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.15.39;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.51;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2014.09.07.15.06.15;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	dm8VnQHhowGHmemJ;

1.1.1.4
date	2015.01.25.14.11.46;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.48.52;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2011 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

/**
 * @@file brw_vec4_copy_propagation.cpp
 *
 * Implements tracking of values copied between registers, and
 * optimizations based on that: copy propagation and constant
 * propagation.
 */

#include "brw_vec4.h"
extern "C" {
#include "main/macros.h"
}

namespace brw {

static bool
is_direct_copy(vec4_instruction *inst)
{
   return (inst->opcode == BRW_OPCODE_MOV &&
	   !inst->predicate &&
	   inst->dst.file == GRF &&
	   !inst->saturate &&
	   !inst->dst.reladdr &&
	   !inst->src[0].reladdr &&
	   inst->dst.type == inst->src[0].type);
}

static bool
is_dominated_by_previous_instruction(vec4_instruction *inst)
{
   return (inst->opcode != BRW_OPCODE_DO &&
	   inst->opcode != BRW_OPCODE_WHILE &&
	   inst->opcode != BRW_OPCODE_ELSE &&
	   inst->opcode != BRW_OPCODE_ENDIF);
}

static bool
try_constant_propagation(vec4_instruction *inst, int arg, src_reg *values[4])
{
   /* For constant propagation, we only handle the same constant
    * across all 4 channels.  Some day, we should handle the 8-bit
    * float vector format, which would let us constant propagate
    * vectors better.
    */
   src_reg value = *values[0];
   for (int i = 1; i < 4; i++) {
      if (!value.equals(values[i]))
	 return false;
   }

   if (value.file != IMM)
      return false;

   if (inst->src[arg].abs) {
      if (value.type == BRW_REGISTER_TYPE_F) {
	 value.imm.f = fabs(value.imm.f);
      } else if (value.type == BRW_REGISTER_TYPE_D) {
	 if (value.imm.i < 0)
	    value.imm.i = -value.imm.i;
      }
   }

   if (inst->src[arg].negate) {
      if (value.type == BRW_REGISTER_TYPE_F)
	 value.imm.f = -value.imm.f;
      else
	 value.imm.u = -value.imm.u;
   }

   switch (inst->opcode) {
   case BRW_OPCODE_MOV:
      inst->src[arg] = value;
      return true;

   case BRW_OPCODE_MACH:
   case BRW_OPCODE_MUL:
   case BRW_OPCODE_ADD:
      if (arg == 1) {
	 inst->src[arg] = value;
	 return true;
      } else if (arg == 0 && inst->src[1].file != IMM) {
	 /* Fit this constant in by commuting the operands.  Exception: we
	  * can't do this for 32-bit integer MUL/MACH because it's asymmetric.
	  */
	 if ((inst->opcode == BRW_OPCODE_MUL ||
              inst->opcode == BRW_OPCODE_MACH) &&
	     (inst->src[1].type == BRW_REGISTER_TYPE_D ||
	      inst->src[1].type == BRW_REGISTER_TYPE_UD))
	    break;
	 inst->src[0] = inst->src[1];
	 inst->src[1] = value;
	 return true;
      }
      break;

   case BRW_OPCODE_CMP:
      if (arg == 1) {
	 inst->src[arg] = value;
	 return true;
      } else if (arg == 0 && inst->src[1].file != IMM) {
	 uint32_t new_cmod;

	 new_cmod = brw_swap_cmod(inst->conditional_mod);
	 if (new_cmod != ~0u) {
	    /* Fit this constant in by swapping the operands and
	     * flipping the test.
	     */
	    inst->src[0] = inst->src[1];
	    inst->src[1] = value;
	    inst->conditional_mod = new_cmod;
	    return true;
	 }
      }
      break;

   case BRW_OPCODE_SEL:
      if (arg == 1) {
	 inst->src[arg] = value;
	 return true;
      } else if (arg == 0 && inst->src[1].file != IMM) {
	 inst->src[0] = inst->src[1];
	 inst->src[1] = value;

	 /* If this was predicated, flipping operands means
	  * we also need to flip the predicate.
	  */
	 if (inst->conditional_mod == BRW_CONDITIONAL_NONE) {
	    inst->predicate_inverse = !inst->predicate_inverse;
	 }
	 return true;
      }
      break;

   default:
      break;
   }

   return false;
}

bool
vec4_visitor::try_copy_propagation(vec4_instruction *inst, int arg,
                                   src_reg *values[4])
{
   /* For constant propagation, we only handle the same constant
    * across all 4 channels.  Some day, we should handle the 8-bit
    * float vector format, which would let us constant propagate
    * vectors better.
    */
   src_reg value = *values[0];
   for (int i = 1; i < 4; i++) {
      /* This is equals() except we don't care about the swizzle. */
      if (value.file != values[i]->file ||
	  value.reg != values[i]->reg ||
	  value.reg_offset != values[i]->reg_offset ||
	  value.type != values[i]->type ||
	  value.negate != values[i]->negate ||
	  value.abs != values[i]->abs) {
	 return false;
      }
   }

   /* Compute the swizzle of the original register by swizzling the
    * component loaded from each value according to the swizzle of
    * operand we're going to change.
    */
   int s[4];
   for (int i = 0; i < 4; i++) {
      s[i] = BRW_GET_SWZ(values[i]->swizzle,
			 BRW_GET_SWZ(inst->src[arg].swizzle, i));
   }
   value.swizzle = BRW_SWIZZLE4(s[0], s[1], s[2], s[3]);

   if (value.file != UNIFORM &&
       value.file != GRF &&
       value.file != ATTR)
      return false;

   if (inst->src[arg].abs) {
      value.negate = false;
      value.abs = true;
   }
   if (inst->src[arg].negate)
      value.negate = !value.negate;

   bool has_source_modifiers = value.negate || value.abs;

   /* gen6 math and gen7+ SENDs from GRFs ignore source modifiers on
    * instructions.
    */
   if ((has_source_modifiers || value.file == UNIFORM ||
        value.swizzle != BRW_SWIZZLE_XYZW) && !can_do_source_mods(inst))
      return false;

   if (has_source_modifiers && value.type != inst->src[arg].type)
      return false;

   bool is_3src_inst = (inst->opcode == BRW_OPCODE_LRP ||
                        inst->opcode == BRW_OPCODE_MAD ||
                        inst->opcode == BRW_OPCODE_BFE ||
                        inst->opcode == BRW_OPCODE_BFI2);
   if (is_3src_inst && value.file == UNIFORM)
      return false;

   /* We can't copy-propagate a UD negation into a condmod
    * instruction, because the condmod ends up looking at the 33-bit
    * signed accumulator value instead of the 32-bit value we wanted
    */
   if (inst->conditional_mod &&
       value.negate &&
       value.type == BRW_REGISTER_TYPE_UD)
      return false;

   /* Don't report progress if this is a noop. */
   if (value.equals(&inst->src[arg]))
      return false;

   value.type = inst->src[arg].type;
   inst->src[arg] = value;
   return true;
}

bool
vec4_visitor::opt_copy_propagation()
{
   bool progress = false;
   src_reg *cur_value[virtual_grf_reg_count][4];

   memset(&cur_value, 0, sizeof(cur_value));

   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

      /* This pass only works on basic blocks.  If there's flow
       * control, throw out all our information and start from
       * scratch.
       *
       * This should really be fixed by using a structure like in
       * src/glsl/opt_copy_propagation.cpp to track available copies.
       */
      if (!is_dominated_by_previous_instruction(inst)) {
	 memset(cur_value, 0, sizeof(cur_value));
	 continue;
      }

      /* For each source arg, see if each component comes from a copy
       * from the same type file (IMM, GRF, UNIFORM), and try
       * optimizing out access to the copy result
       */
      for (int i = 2; i >= 0; i--) {
	 /* Copied values end up in GRFs, and we don't track reladdr
	  * accesses.
	  */
	 if (inst->src[i].file != GRF ||
	     inst->src[i].reladdr)
	    continue;

	 int reg = (virtual_grf_reg_map[inst->src[i].reg] +
		    inst->src[i].reg_offset);

	 /* Find the regs that each swizzle component came from.
	  */
	 src_reg *values[4];
	 int c;
	 for (c = 0; c < 4; c++) {
	    values[c] = cur_value[reg][BRW_GET_SWZ(inst->src[i].swizzle, c)];

	    /* If there's no available copy for this channel, bail.
	     * We could be more aggressive here -- some channels might
	     * not get used based on the destination writemask.
	     */
	    if (!values[c])
	       break;

	    /* We'll only be able to copy propagate if the sources are
	     * all from the same file -- there's no ability to swizzle
	     * 0 or 1 constants in with source registers like in i915.
	     */
	    if (c > 0 && values[c - 1]->file != values[c]->file)
	       break;
	 }

	 if (c != 4)
	    continue;

	 if (try_constant_propagation(inst, i, values) ||
	     try_copy_propagation(inst, i, values))
	    progress = true;
      }

      /* Track available source registers. */
      if (inst->dst.file == GRF) {
	 const int reg =
	    virtual_grf_reg_map[inst->dst.reg] + inst->dst.reg_offset;

	 /* Update our destination's current channel values.  For a direct copy,
	  * the value is the newly propagated source.  Otherwise, we don't know
	  * the new value, so clear it.
	  */
	 bool direct_copy = is_direct_copy(inst);
	 for (int i = 0; i < 4; i++) {
	    if (inst->dst.writemask & (1 << i)) {
	       cur_value[reg][i] = direct_copy ? &inst->src[0] : NULL;
	    }
	 }

	 /* Clear the records for any registers whose current value came from
	  * our destination's updated channels, as the two are no longer equal.
	  */
	 if (inst->dst.reladdr)
	    memset(cur_value, 0, sizeof(cur_value));
	 else {
	    for (int i = 0; i < virtual_grf_reg_count; i++) {
	       for (int j = 0; j < 4; j++) {
		  if (inst->dst.writemask & (1 << j) &&
		      cur_value[i][j] &&
		      cur_value[i][j]->file == GRF &&
		      cur_value[i][j]->reg == inst->dst.reg &&
		      cur_value[i][j]->reg_offset == inst->dst.reg_offset) {
		     cur_value[i][j] = NULL;
		  }
	       }
	    }
	 }
      }
   }

   if (progress)
      live_intervals_valid = false;

   return progress;
}

} /* namespace brw */
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@a60 15
is_channel_updated(vec4_instruction *inst, src_reg *values[4], int ch)
{
   const src_reg *src = values[ch];

   /* consider GRF only */
   assert(inst->dst.file == GRF);
   if (!src || src->file != GRF)
      return false;

   return (src->reg == inst->dst.reg &&
	   src->reg_offset == inst->dst.reg_offset &&
	   inst->dst.writemask & (1 << BRW_GET_SWZ(src->swizzle, ch)));
}

static bool
a97 15
   case BRW_OPCODE_DP2:
   case BRW_OPCODE_DP3:
   case BRW_OPCODE_DP4:
   case BRW_OPCODE_DPH:
   case BRW_OPCODE_BFI1:
   case BRW_OPCODE_ASR:
   case BRW_OPCODE_SHL:
   case BRW_OPCODE_SHR:
   case BRW_OPCODE_SUBB:
      if (arg == 1) {
         inst->src[arg] = value;
         return true;
      }
      break;

a100 4
   case BRW_OPCODE_OR:
   case BRW_OPCODE_AND:
   case BRW_OPCODE_XOR:
   case BRW_OPCODE_ADDC:
a227 3
   if (inst->is_send_from_grf())
      return false;

d338 5
a342 1
		  if (is_channel_updated(inst, cur_value[i], j)){
d352 1
a352 1
      invalidate_live_intervals();
@


1.1.1.3
log
@Import Mesa 10.2.7
@
text
@d76 1
a76 2
try_constant_propagation(struct brw_context *brw, vec4_instruction *inst,
                         int arg, src_reg *values[4])
a112 6
   case SHADER_OPCODE_POW:
   case SHADER_OPCODE_INT_QUOTIENT:
   case SHADER_OPCODE_INT_REMAINDER:
      if (brw->gen < 8)
         break;
      /* fallthrough */
a197 9
static bool
is_logic_op(enum opcode opcode)
{
   return (opcode == BRW_OPCODE_AND ||
           opcode == BRW_OPCODE_OR  ||
           opcode == BRW_OPCODE_XOR ||
           opcode == BRW_OPCODE_NOT);
}

a235 5
   if (brw->gen >= 8 && (value.negate || value.abs) &&
       is_logic_op(inst->opcode)) {
      return false;
   }

a254 4
   if (has_source_modifiers &&
       inst->opcode == SHADER_OPCODE_GEN4_SCRATCH_WRITE)
      return false;

d346 1
a346 1
	 if (try_constant_propagation(brw, inst, i, values) ||
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a32 1
#include "brw_cfg.h"
a38 5
struct copy_entry {
   src_reg *value[4];
   int saturatemask;
};

d45 1
d76 2
a77 2
try_constant_propagate(struct brw_context *brw, vec4_instruction *inst,
                       int arg, struct copy_entry *entry)
d84 1
a84 1
   src_reg value = *entry->value[0];
d86 1
a86 1
      if (!value.equals(*entry->value[i]))
d95 1
a95 1
	 value.fixed_hw_reg.dw1.f = fabs(value.fixed_hw_reg.dw1.f);
d97 2
a98 2
	 if (value.fixed_hw_reg.dw1.d < 0)
	    value.fixed_hw_reg.dw1.d = -value.fixed_hw_reg.dw1.d;
d104 1
a104 1
	 value.fixed_hw_reg.dw1.f = -value.fixed_hw_reg.dw1.f;
d106 1
a106 1
	 value.fixed_hw_reg.dw1.ud = -value.fixed_hw_reg.dw1.ud;
d165 1
a165 1
	 enum brw_conditional_mod new_cmod;
d168 1
a168 1
	 if (new_cmod != BRW_CONDITIONAL_NONE) {
d214 3
a216 3
static bool
try_copy_propagate(struct brw_context *brw, vec4_instruction *inst,
                   int arg, struct copy_entry *entry, int reg)
d223 1
a223 1
   src_reg value = *entry->value[0];
d226 6
a231 6
      if (value.file != entry->value[i]->file ||
	  value.reg != entry->value[i]->reg ||
	  value.reg_offset != entry->value[i]->reg_offset ||
	  value.type != entry->value[i]->type ||
	  value.negate != entry->value[i]->negate ||
	  value.abs != entry->value[i]->abs) {
d242 1
a242 1
      s[i] = BRW_GET_SWZ(entry->value[i]->swizzle,
d270 1
a270 1
        value.swizzle != BRW_SWIZZLE_XYZW) && !inst->can_do_source_mods(brw))
d300 1
a300 1
   if (value.equals(inst->src[arg]))
a302 19
   /* Limit saturate propagation only to SEL with src1 bounded within 1.0 and 1.0
    * otherwise, skip copy propagate altogether
    */
   if (entry->saturatemask & (1 << arg)) {
      switch(inst->opcode) {
      case BRW_OPCODE_SEL:
         if (inst->src[1].file != IMM ||
             inst->src[1].fixed_hw_reg.dw1.f < 0.0 ||
             inst->src[1].fixed_hw_reg.dw1.f > 1.0) {
            return false;
         }
         if (!inst->saturate)
            inst->saturate = true;
         break;
      default:
         return false;
      }
   }

d312 3
a314 1
   struct copy_entry entries[virtual_grf_reg_count];
d316 2
a317 1
   memset(&entries, 0, sizeof(entries));
a318 1
   foreach_block_and_inst(block, vec4_instruction, inst, cfg) {
d327 1
a327 1
	 memset(&entries, 0, sizeof(entries));
d348 1
a348 2
         struct copy_entry entry;
         memset(&entry, 0, sizeof(copy_entry));
d351 1
a351 2
            int channel = BRW_GET_SWZ(inst->src[i].swizzle, c);
            entry.value[c] = entries[reg].value[channel];
d357 1
a357 1
	    if (!entry.value[c])
a359 3
            entry.saturatemask |=
               (entries[reg].saturatemask & (1 << channel) ? 1 : 0) << c;

d364 1
a364 1
	    if (c > 0 && entry.value[c - 1]->file != entry.value[c]->file)
d371 2
a372 4
	 if (try_constant_propagate(brw, inst, i, &entry))
            progress = true;

	 if (try_copy_propagate(brw, inst, i, &entry, reg))
a385 1
	 entries[reg].saturatemask = 0x0;
d388 1
a388 2
               entries[reg].value[i] = direct_copy ? &inst->src[0] : NULL;
               entries[reg].saturatemask |= (((inst->saturate && direct_copy) ? 1 : 0) << i);
d396 1
a396 1
	    memset(&entries, 0, sizeof(entries));
d400 3
a402 4
		  if (is_channel_updated(inst, entries[i].value, j)){
		     entries[i].value[j] = NULL;
		     entries[i].saturatemask &= ~(1 << j);
                  }
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d33 1
d40 5
a50 1
	   !inst->saturate &&
d81 2
a82 2
try_constant_propagation(struct brw_context *brw, vec4_instruction *inst,
                         int arg, src_reg *values[4])
d89 1
a89 1
   src_reg value = *values[0];
d91 1
a91 1
      if (!value.equals(values[i]))
d100 1
a100 1
	 value.imm.f = fabs(value.imm.f);
d102 2
a103 2
	 if (value.imm.i < 0)
	    value.imm.i = -value.imm.i;
d109 1
a109 1
	 value.imm.f = -value.imm.f;
d111 1
a111 1
	 value.imm.u = -value.imm.u;
d170 1
a170 1
	 uint32_t new_cmod;
d173 1
a173 1
	 if (new_cmod != ~0u) {
d219 3
a221 3
bool
vec4_visitor::try_copy_propagation(vec4_instruction *inst, int arg,
                                   src_reg *values[4])
d228 1
a228 1
   src_reg value = *values[0];
d231 6
a236 6
      if (value.file != values[i]->file ||
	  value.reg != values[i]->reg ||
	  value.reg_offset != values[i]->reg_offset ||
	  value.type != values[i]->type ||
	  value.negate != values[i]->negate ||
	  value.abs != values[i]->abs) {
d247 1
a247 1
      s[i] = BRW_GET_SWZ(values[i]->swizzle,
d275 1
a275 1
        value.swizzle != BRW_SWIZZLE_XYZW) && !can_do_source_mods(inst))
d305 1
a305 1
   if (value.equals(&inst->src[arg]))
d308 19
d336 1
a336 3
   src_reg *cur_value[virtual_grf_reg_count][4];

   memset(&cur_value, 0, sizeof(cur_value));
d338 1
a338 2
   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;
d340 1
d349 1
a349 1
	 memset(cur_value, 0, sizeof(cur_value));
d370 2
a371 1
	 src_reg *values[4];
d374 2
a375 1
	    values[c] = cur_value[reg][BRW_GET_SWZ(inst->src[i].swizzle, c)];
d381 1
a381 1
	    if (!values[c])
d384 3
d391 1
a391 1
	    if (c > 0 && values[c - 1]->file != values[c]->file)
d398 4
a401 2
	 if (try_constant_propagation(brw, inst, i, values) ||
	     try_copy_propagation(inst, i, values))
d415 1
d418 2
a419 1
	       cur_value[reg][i] = direct_copy ? &inst->src[0] : NULL;
d427 1
a427 1
	    memset(cur_value, 0, sizeof(cur_value));
d431 4
a434 3
		  if (is_channel_updated(inst, cur_value[i], j)){
		     cur_value[i][j] = NULL;
		  }
@


