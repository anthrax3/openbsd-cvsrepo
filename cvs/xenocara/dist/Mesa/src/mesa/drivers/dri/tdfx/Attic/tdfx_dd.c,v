head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.2.0.8
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.09.05.14.05.47;	author jsg;	state dead;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.54.00;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.54.00;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.36;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.43;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@/* -*- mode: c; c-basic-offset: 3 -*-
 *
 * Copyright 2000 VA Linux Systems Inc., Fremont, California.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEMS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * \file tdfx_dd.c
 * Device driver interface functions for 3Dfx based cards.
 * 
 * \author Gareth Hughes <gareth@@valinux.com> (Original rewrite 29 Sep - 1 Oct 2000)
 * \author Brian Paul <brianp@@valinux.com>
 */

#include "tdfx_context.h"
#include "tdfx_dd.h"
#include "tdfx_lock.h"
#include "tdfx_pixels.h"

#include "utils.h"
#include "main/context.h"


/* These are used in calls to FX_grColorMaskv() */
const GLboolean false4[4] = { GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE };
const GLboolean true4[4] = { GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE };



/* KW: Put the word Mesa in the render string because quakeworld
 * checks for this rather than doing a glGet(GL_MAX_TEXTURE_SIZE).
 * Why?
 */
static const GLubyte *tdfxDDGetString( struct gl_context *ctx, GLenum name )
{
   tdfxContextPtr fxMesa = (tdfxContextPtr) ctx->DriverCtx;

   switch (name) {
   case GL_RENDERER:
   {
      /* The renderer string must be per-context state to handle
       * multihead correctly.
       */
      char *const buffer = fxMesa->rendererString;
      char hardware[64];

      LOCK_HARDWARE(fxMesa);
      strncpy(hardware, fxMesa->Glide.grGetString(GR_HARDWARE),
	      sizeof(hardware));
      hardware[sizeof(hardware) - 1] = '\0';
      UNLOCK_HARDWARE(fxMesa);

      if ((strncmp(hardware, "Voodoo3", 7) == 0)
	  || (strncmp(hardware, "Voodoo4", 7) == 0)
	  || (strncmp(hardware, "Voodoo5", 7) == 0)) {
	 hardware[7] = '\0';
      }
      else if (strncmp(hardware, "Voodoo Banshee", 14) == 0) {
	 strcpy(&hardware[6], "Banshee");
      }
      else {
	 /* unexpected result: replace spaces with hyphens */
	 int i;
	 for (i = 0; i < sizeof(hardware) && hardware[i]; i++) {
	    if (hardware[i] == ' ' || hardware[i] == '\t') {
	       hardware[i] = '-';
	    }
	 }
      }

      (void) driGetRendererString(buffer, hardware, 0);
      return (const GLubyte *) buffer;
   }
   case GL_VENDOR:
      return (const GLubyte *)"VA Linux Systems, Inc.";
   default:
      return NULL;
   }
}


static void
tdfxBeginQuery(struct gl_context *ctx, struct gl_query_object *q)
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);

   (void) q;

   if (q->Target == GL_SAMPLES_PASSED_ARB) {
      LOCK_HARDWARE(fxMesa);
      fxMesa->Glide.grFinish();
      fxMesa->Glide.grReset(GR_STATS_PIXELS);
      UNLOCK_HARDWARE(fxMesa);
   }
}


static void
tdfxEndQuery(struct gl_context *ctx, struct gl_query_object *q)
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   FxI32 total_pixels;
   FxI32 z_fail_pixels;


   if (q->Target == GL_SAMPLES_PASSED_ARB) {
      LOCK_HARDWARE(fxMesa);
      fxMesa->Glide.grFinish();

      fxMesa->Glide.grGet(GR_STATS_PIXELS_DEPTHFUNC_FAIL, sizeof(FxI32),
			  &z_fail_pixels);
      fxMesa->Glide.grGet(GR_STATS_PIXELS_IN, sizeof(FxI32), &total_pixels);

      q->Result = total_pixels - z_fail_pixels;
      
      /* Apparently, people have seen z_fail_pixels > total_pixels under
       * some conditions on some 3Dfx hardware.  The occlusion query spec
       * requires that we clamp to 0.
       */
      if (q->Result < 0) {
	 q->Result = 0;
      }

      q->Ready = GL_TRUE;

      UNLOCK_HARDWARE(fxMesa);
   }
}


#define VISUAL_EQUALS_RGBA(vis, r, g, b, a)        \
   ((vis->redBits == r) &&                         \
    (vis->greenBits == g) &&                       \
    (vis->blueBits == b) &&                        \
    (vis->alphaBits == a))

void tdfxDDInitDriverFuncs( const struct gl_config *visual,
                            struct dd_function_table *functions )
{
   if ( MESA_VERBOSE & VERBOSE_DRIVER ) {
      fprintf( stderr, "tdfx: %s()\n", __FUNCTION__ );
   }

   functions->GetString         = tdfxDDGetString;
   functions->BeginQuery        = tdfxBeginQuery;
   functions->EndQuery          = tdfxEndQuery;

   /* Accelerated paths
    */
   if ( VISUAL_EQUALS_RGBA(visual, 8, 8, 8, 8) )
   {
      functions->DrawPixels	= tdfx_drawpixels_R8G8B8A8;
      functions->ReadPixels	= tdfx_readpixels_R8G8B8A8;
   }
   else if ( VISUAL_EQUALS_RGBA(visual, 5, 6, 5, 0) )
   {
      functions->ReadPixels	= tdfx_readpixels_R5G6B5;
   }
}


/*
 * These are here for lack of a better place.
 */

void
FX_grColorMaskv(struct gl_context *ctx, const GLboolean rgba[4])
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   LOCK_HARDWARE(fxMesa);
   if (ctx->Visual.redBits == 8) {
      /* 32bpp mode */
      ASSERT( fxMesa->Glide.grColorMaskExt );
      fxMesa->Glide.grColorMaskExt(rgba[RCOMP], rgba[GCOMP],
                                   rgba[BCOMP], rgba[ACOMP]);
   }
   else {
      /* 16 bpp mode */
      /* we never have an alpha buffer */
      fxMesa->Glide.grColorMask(rgba[RCOMP] || rgba[GCOMP] || rgba[BCOMP],
                                GL_FALSE);
   }
   UNLOCK_HARDWARE(fxMesa);
}

void
FX_grColorMaskv_NoLock(struct gl_context *ctx, const GLboolean rgba[4])
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   if (ctx->Visual.redBits == 8) {
      /* 32bpp mode */
      ASSERT( fxMesa->Glide.grColorMaskExt );
      fxMesa->Glide.grColorMaskExt(rgba[RCOMP], rgba[GCOMP],
                                   rgba[BCOMP], rgba[ACOMP]);
   }
   else {
      /* 16 bpp mode */
      /* we never have an alpha buffer */
      fxMesa->Glide.grColorMask(rgba[RCOMP] || rgba[GCOMP] || rgba[BCOMP],
                                GL_FALSE);
   }
}
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.4
log
@Merge Mesa 7.10.3
@
text
@a43 3
#define DRIVER_DATE	"20061113"


d91 1
a91 1
      (void) driGetRendererString(buffer, hardware, DRIVER_DATE, 0);
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d57 1
a57 1
static const GLubyte *tdfxDDGetString( GLcontext *ctx, GLenum name )
d106 1
a106 1
tdfxBeginQuery(GLcontext *ctx, struct gl_query_object *q)
d122 1
a122 1
tdfxEndQuery(GLcontext *ctx, struct gl_query_object *q)
d160 1
a160 1
void tdfxDDInitDriverFuncs( const __GLcontextModes *visual,
d190 1
a190 1
FX_grColorMaskv(GLcontext *ctx, const GLboolean rgba[4])
d210 1
a210 1
FX_grColorMaskv_NoLock(GLcontext *ctx, const GLboolean rgba[4])
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a37 1
#include "tdfx_vb.h"
a41 6
#include "main/enums.h"
#include "main/framebuffer.h"
#include "swrast/swrast.h"
#if defined(USE_X86_ASM)
#include "x86/common_x86_asm.h"
#endif
d87 1
a87 1
	 for (i = 0; hardware[i] && (i < sizeof(hardware)); i++) {
@


1.1
log
@Initial revision
@
text
@a25 1
/* $XFree86: xc/lib/GL/mesa/src/drv/tdfx/tdfx_dd.c,v 1.10 2002/10/30 12:52:00 alanh Exp $ */
d27 6
a32 8
/*
 * Original rewrite:
 *	Gareth Hughes <gareth@@valinux.com>, 29 Sep - 1 Oct 2000
 *
 * Authors:
 *	Gareth Hughes <gareth@@valinux.com>
 *	Brian Paul <brianp@@valinux.com>
 *
d41 4
a44 3
#include "context.h"
#include "enums.h"
#include "framebuffer.h"
d51 1
a51 1
#define TDFX_DATE	"20040719"
d68 1
a68 1
   switch ( name ) {
d74 2
a75 2
      char *buffer = fxMesa->rendererString;
      char hardware[100];
d78 3
a80 1
      strcpy( hardware, fxMesa->Glide.grGetString(GR_HARDWARE) );
d83 4
a86 9
      strcpy( buffer, "Mesa DRI " );
      strcat( buffer, TDFX_DATE );
      strcat( buffer, " " );

      if ( strcmp( hardware, "Voodoo3 (tm)" ) == 0 ) {
	 strcat( buffer, "Voodoo3" );
      }
      else if ( strcmp( hardware, "Voodoo Banshee (tm)" ) == 0 ) {
	 strcat( buffer, "VoodooBanshee" );
d88 2
a89 5
      else if ( strcmp( hardware, "Voodoo4 (tm)" ) == 0 ) {
	 strcat( buffer, "Voodoo4" );
      }
      else if ( strcmp( hardware, "Voodoo5 (tm)" ) == 0 ) {
	 strcat( buffer, "Voodoo5" );
d94 2
a95 2
	 for ( i = 0 ; hardware[i] && i < 60 ; i++ ) {
	    if ( hardware[i] == ' ' || hardware[i] == '\t' )
d97 1
a98 1
         strcat( buffer, hardware );
d101 1
a101 22
      /* Append any CPU-specific information.
       */
#ifdef USE_X86_ASM
      if ( _mesa_x86_cpu_features ) {
	 strncat( buffer, " x86", 4 );
      }
#endif
#ifdef USE_MMX_ASM
      if ( cpu_has_mmx ) {
	 strncat( buffer, "/MMX", 4 );
      }
#endif
#ifdef USE_3DNOW_ASM
      if ( cpu_has_3dnow ) {
	 strncat( buffer, "/3DNow!", 7 );
      }
#endif
#ifdef USE_SSE_ASM
      if ( cpu_has_xmm ) {
	 strncat( buffer, "/SSE", 4 );
      }
#endif
d112 18
a129 4
/* Return uptodate buffer size information.
 */
static void tdfxDDGetBufferSize( GLframebuffer *buffer,
				 GLuint *width, GLuint *height )
a130 1
   GET_CURRENT_CONTEXT(ctx);
d132 3
d136 22
a157 4
   LOCK_HARDWARE( fxMesa );
   *width = fxMesa->width;
   *height = fxMesa->height;
   UNLOCK_HARDWARE( fxMesa );
d174 3
a176 3
   functions->GetString		= tdfxDDGetString;
   functions->GetBufferSize	= tdfxDDGetBufferSize;
   functions->ResizeBuffers     = _mesa_resize_framebuffer;
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d26 1
d28 8
a35 6
/**
 * \file tdfx_dd.c
 * Device driver interface functions for 3Dfx based cards.
 * 
 * \author Gareth Hughes <gareth@@valinux.com> (Original rewrite 29 Sep - 1 Oct 2000)
 * \author Brian Paul <brianp@@valinux.com>
a43 1
#include "utils.h"
d53 1
a53 1
#define DRIVER_DATE	"20061113"
d70 1
a70 1
   switch (name) {
d76 2
a77 2
      char *const buffer = fxMesa->rendererString;
      char hardware[64];
d80 1
a80 3
      strncpy(hardware, fxMesa->Glide.grGetString(GR_HARDWARE),
	      sizeof(hardware));
      hardware[sizeof(hardware) - 1] = '\0';
d83 9
a91 4
      if ((strncmp(hardware, "Voodoo3", 7) == 0)
	  || (strncmp(hardware, "Voodoo4", 7) == 0)
	  || (strncmp(hardware, "Voodoo5", 7) == 0)) {
	 hardware[7] = '\0';
d93 5
a97 2
      else if (strncmp(hardware, "Voodoo Banshee", 14) == 0) {
	 strcpy(&hardware[6], "Banshee");
d102 2
a103 2
	 for (i = 0; hardware[i] && (i < sizeof(hardware)); i++) {
	    if (hardware[i] == ' ' || hardware[i] == '\t') {
a104 1
	    }
d106 1
d109 22
a130 1
      (void) driGetRendererString(buffer, hardware, DRIVER_DATE, 0);
d141 4
a144 18
static void
tdfxBeginQuery(GLcontext *ctx, GLenum target, struct gl_query_object *q)
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);

   (void) q;

   if (target == GL_SAMPLES_PASSED_ARB) {
      LOCK_HARDWARE(fxMesa);
      fxMesa->Glide.grFinish();
      fxMesa->Glide.grReset(GR_STATS_PIXELS);
      UNLOCK_HARDWARE(fxMesa);
   }
}


static void
tdfxEndQuery(GLcontext *ctx, GLenum target, struct gl_query_object *q)
d146 1
a147 3
   FxI32 total_pixels;
   FxI32 z_fail_pixels;

d149 4
a152 22
   if (target == GL_SAMPLES_PASSED_ARB) {
      LOCK_HARDWARE(fxMesa);
      fxMesa->Glide.grFinish();

      fxMesa->Glide.grGet(GR_STATS_PIXELS_DEPTHFUNC_FAIL, sizeof(FxI32),
			  &z_fail_pixels);
      fxMesa->Glide.grGet(GR_STATS_PIXELS_IN, sizeof(FxI32), &total_pixels);

      q->Result = total_pixels - z_fail_pixels;
      
      /* Apparently, people have seen z_fail_pixels > total_pixels under
       * some conditions on some 3Dfx hardware.  The occlusion query spec
       * requires that we clamp to 0.
       */
      if (q->Result < 0) {
	 q->Result = 0;
      }

      q->Ready = GL_TRUE;

      UNLOCK_HARDWARE(fxMesa);
   }
d169 3
a171 3
   functions->GetString         = tdfxDDGetString;
   functions->BeginQuery        = tdfxBeginQuery;
   functions->EndQuery          = tdfxEndQuery;
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d38 1
d42 7
a48 1
#include "main/context.h"
d64 1
a64 1
static const GLubyte *tdfxDDGetString( struct gl_context *ctx, GLenum name )
d94 1
a94 1
	 for (i = 0; i < sizeof(hardware) && hardware[i]; i++) {
d113 1
a113 1
tdfxBeginQuery(struct gl_context *ctx, struct gl_query_object *q)
d119 1
a119 1
   if (q->Target == GL_SAMPLES_PASSED_ARB) {
d129 1
a129 1
tdfxEndQuery(struct gl_context *ctx, struct gl_query_object *q)
d136 1
a136 1
   if (q->Target == GL_SAMPLES_PASSED_ARB) {
d167 1
a167 1
void tdfxDDInitDriverFuncs( const struct gl_config *visual,
d197 1
a197 1
FX_grColorMaskv(struct gl_context *ctx, const GLboolean rgba[4])
d217 1
a217 1
FX_grColorMaskv_NoLock(struct gl_context *ctx, const GLboolean rgba[4])
@


