head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.05.33;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.25;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.42;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.16.05;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.56;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright (C) 2009 Maciej Cencora.
 * Copyright (C) 2008 Nicolai Haehnle.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "radeon_mipmap_tree.h"

#include <errno.h>
#include <unistd.h>

#include "main/simple_list.h"
#include "main/teximage.h"
#include "main/texobj.h"
#include "main/enums.h"
#include "radeon_texture.h"
#include "radeon_tile.h"

static unsigned get_aligned_compressed_row_stride(
		mesa_format format,
		unsigned width,
		unsigned minStride)
{
	const unsigned blockBytes = _mesa_get_format_bytes(format);
	unsigned blockWidth, blockHeight;
	unsigned stride;

	_mesa_get_format_block_size(format, &blockWidth, &blockHeight);

	/* Count number of blocks required to store the given width.
	 * And then multiple it with bytes required to store a block.
	 */
	stride = (width + blockWidth - 1) / blockWidth * blockBytes;

	/* Round the given minimum stride to the next full blocksize.
	 * (minStride + blockBytes - 1) / blockBytes * blockBytes
	 */
	if ( stride < minStride )
		stride = (minStride + blockBytes - 1) / blockBytes * blockBytes;

	radeon_print(RADEON_TEXTURE, RADEON_TRACE,
			"%s width %u, minStride %u, block(bytes %u, width %u):"
			"stride %u\n",
			__func__, width, minStride,
			blockBytes, blockWidth,
			stride);

	return stride;
}

unsigned get_texture_image_size(
		mesa_format format,
		unsigned rowStride,
		unsigned height,
		unsigned depth,
		unsigned tiling)
{
	if (_mesa_is_format_compressed(format)) {
		unsigned blockWidth, blockHeight;

		_mesa_get_format_block_size(format, &blockWidth, &blockHeight);

		return rowStride * ((height + blockHeight - 1) / blockHeight) * depth;
	} else if (tiling) {
		/* Need to align height to tile height */
		unsigned tileWidth, tileHeight;

		get_tile_size(format, &tileWidth, &tileHeight);
		tileHeight--;

		height = (height + tileHeight) & ~tileHeight;
	}

	return rowStride * height * depth;
}

unsigned get_texture_image_row_stride(radeonContextPtr rmesa, mesa_format format, unsigned width, unsigned tiling, GLuint target)
{
	if (_mesa_is_format_compressed(format)) {
		return get_aligned_compressed_row_stride(format, width, rmesa->texture_compressed_row_align);
	} else {
		unsigned row_align;

		if (!_mesa_is_pow_two(width) || target == GL_TEXTURE_RECTANGLE) {
			row_align = rmesa->texture_rect_row_align - 1;
		} else if (tiling) {
			unsigned tileWidth, tileHeight;
			get_tile_size(format, &tileWidth, &tileHeight);
			row_align = tileWidth * _mesa_get_format_bytes(format) - 1;
		} else {
			row_align = rmesa->texture_row_align - 1;
		}

		return (_mesa_format_row_stride(format, width) + row_align) & ~row_align;
	}
}

/**
 * Compute sizes and fill in offset and blit information for the given
 * image (determined by \p face and \p level).
 *
 * \param curOffset points to the offset at which the image is to be stored
 * and is updated by this function according to the size of the image.
 */
static void compute_tex_image_offset(radeonContextPtr rmesa, radeon_mipmap_tree *mt,
	GLuint face, GLuint level, GLuint* curOffset)
{
	radeon_mipmap_level *lvl = &mt->levels[level];
	GLuint height;

	height = _mesa_next_pow_two_32(lvl->height);

	lvl->rowstride = get_texture_image_row_stride(rmesa, mt->mesaFormat, lvl->width, mt->tilebits, mt->target);
	lvl->size = get_texture_image_size(mt->mesaFormat, lvl->rowstride, height, lvl->depth, mt->tilebits);

	assert(lvl->size > 0);

	lvl->faces[face].offset = *curOffset;
	*curOffset += lvl->size;

	radeon_print(RADEON_TEXTURE, RADEON_TRACE,
			"%s(%p) level %d, face %d: rs:%d %dx%d at %d\n",
			__func__, rmesa,
			level, face,
			lvl->rowstride, lvl->width, height, lvl->faces[face].offset);
}

static void calculate_miptree_layout(radeonContextPtr rmesa, radeon_mipmap_tree *mt)
{
	GLuint curOffset, i, face, level;

	assert(mt->numLevels <= rmesa->glCtx.Const.MaxTextureLevels);

	curOffset = 0;
	for(face = 0; face < mt->faces; face++) {

		for(i = 0, level = mt->baseLevel; i < mt->numLevels; i++, level++) {
			mt->levels[level].valid = 1;
			mt->levels[level].width = minify(mt->width0, i);
			mt->levels[level].height = minify(mt->height0, i);
			mt->levels[level].depth = minify(mt->depth0, i);
			compute_tex_image_offset(rmesa, mt, face, level, &curOffset);
		}
	}

	/* Note the required size in memory */
	mt->totalsize = (curOffset + RADEON_OFFSET_MASK) & ~RADEON_OFFSET_MASK;

	radeon_print(RADEON_TEXTURE, RADEON_TRACE,
			"%s(%p, %p) total size %d\n",
			__func__, rmesa, mt, mt->totalsize);
}

/**
 * Create a new mipmap tree, calculate its layout and allocate memory.
 */
radeon_mipmap_tree* radeon_miptree_create(radeonContextPtr rmesa,
					  GLenum target, mesa_format mesaFormat, GLuint baseLevel, GLuint numLevels,
					  GLuint width0, GLuint height0, GLuint depth0, GLuint tilebits)
{
	radeon_mipmap_tree *mt = CALLOC_STRUCT(_radeon_mipmap_tree);

	radeon_print(RADEON_TEXTURE, RADEON_NORMAL,
		"%s(%p) new tree is %p.\n",
		__func__, rmesa, mt);

	mt->mesaFormat = mesaFormat;
	mt->refcount = 1;
	mt->target = target;
	mt->faces = _mesa_num_tex_faces(target);
	mt->baseLevel = baseLevel;
	mt->numLevels = numLevels;
	mt->width0 = width0;
	mt->height0 = height0;
	mt->depth0 = depth0;
	mt->tilebits = tilebits;

	calculate_miptree_layout(rmesa, mt);

	mt->bo = radeon_bo_open(rmesa->radeonScreen->bom,
                            0, mt->totalsize, 1024,
                            RADEON_GEM_DOMAIN_VRAM,
                            0);

	return mt;
}

void radeon_miptree_reference(radeon_mipmap_tree *mt, radeon_mipmap_tree **ptr)
{
	assert(!*ptr);

	mt->refcount++;
	assert(mt->refcount > 0);

	*ptr = mt;
}

void radeon_miptree_unreference(radeon_mipmap_tree **ptr)
{
	radeon_mipmap_tree *mt = *ptr;
	if (!mt)
		return;

	assert(mt->refcount > 0);

	mt->refcount--;
	if (!mt->refcount) {
		radeon_bo_unref(mt->bo);
		free(mt);
	}

	*ptr = 0;
}

/**
 * Calculate min and max LOD for the given texture object.
 * @@param[in] tObj texture object whose LOD values to calculate
 * @@param[out] pminLod minimal LOD
 * @@param[out] pmaxLod maximal LOD
 */
static void calculate_min_max_lod(struct gl_sampler_object *samp, struct gl_texture_object *tObj,
				       unsigned *pminLod, unsigned *pmaxLod)
{
	int minLod, maxLod;
	/* Yes, this looks overly complicated, but it's all needed.
	*/
	switch (tObj->Target) {
	case GL_TEXTURE_1D:
	case GL_TEXTURE_2D:
	case GL_TEXTURE_3D:
	case GL_TEXTURE_CUBE_MAP:
		if (samp->MinFilter == GL_NEAREST || samp->MinFilter == GL_LINEAR) {
			/* GL_NEAREST and GL_LINEAR only care about GL_TEXTURE_BASE_LEVEL.
			*/
			minLod = maxLod = tObj->BaseLevel;
		} else {
			minLod = tObj->BaseLevel + (GLint)(samp->MinLod);
			minLod = MAX2(minLod, tObj->BaseLevel);
			minLod = MIN2(minLod, tObj->MaxLevel);
			maxLod = tObj->BaseLevel + (GLint)(samp->MaxLod + 0.5);
			maxLod = MIN2(maxLod, tObj->MaxLevel);
			maxLod = MIN2(maxLod, tObj->Image[0][minLod]->MaxNumLevels - 1 + minLod);
			maxLod = MAX2(maxLod, minLod); /* need at least one level */
		}
		break;
	case GL_TEXTURE_RECTANGLE_NV:
	case GL_TEXTURE_4D_SGIS:
		minLod = maxLod = 0;
		break;
	default:
		return;
	}

	radeon_print(RADEON_TEXTURE, RADEON_TRACE,
			"%s(%p) target %s, min %d, max %d.\n",
			__func__, tObj,
			_mesa_lookup_enum_by_nr(tObj->Target),
			minLod, maxLod);

	/* save these values */
	*pminLod = minLod;
	*pmaxLod = maxLod;
}

/**
 * Checks whether the given miptree can hold the given texture image at the
 * given face and level.
 */
GLboolean radeon_miptree_matches_image(radeon_mipmap_tree *mt,
				       struct gl_texture_image *texImage)
{
	radeon_mipmap_level *lvl;
	GLuint level = texImage->Level;
	if (texImage->TexFormat != mt->mesaFormat)
		return GL_FALSE;

	lvl = &mt->levels[level];
	if (!lvl->valid ||
	    lvl->width != texImage->Width ||
	    lvl->height != texImage->Height ||
	    lvl->depth != texImage->Depth)
		return GL_FALSE;

	return GL_TRUE;
}

/**
 * Checks whether the given miptree has the right format to store the given texture object.
 */
static GLboolean radeon_miptree_matches_texture(radeon_mipmap_tree *mt, struct gl_texture_object *texObj)
{
	struct gl_texture_image *firstImage;
	unsigned numLevels;
	radeon_mipmap_level *mtBaseLevel;

	if (texObj->BaseLevel < mt->baseLevel)
		return GL_FALSE;

	mtBaseLevel = &mt->levels[texObj->BaseLevel - mt->baseLevel];
	firstImage = texObj->Image[0][texObj->BaseLevel];
	numLevels = MIN2(texObj->_MaxLevel - texObj->BaseLevel + 1, firstImage->MaxNumLevels);

	if (radeon_is_debug_enabled(RADEON_TEXTURE,RADEON_TRACE)) {
		fprintf(stderr, "Checking if miptree %p matches texObj %p\n", mt, texObj);
		fprintf(stderr, "target %d vs %d\n", mt->target, texObj->Target);
		fprintf(stderr, "format %d vs %d\n", mt->mesaFormat, firstImage->TexFormat);
		fprintf(stderr, "numLevels %d vs %d\n", mt->numLevels, numLevels);
		fprintf(stderr, "width0 %d vs %d\n", mtBaseLevel->width, firstImage->Width);
		fprintf(stderr, "height0 %d vs %d\n", mtBaseLevel->height, firstImage->Height);
		fprintf(stderr, "depth0 %d vs %d\n", mtBaseLevel->depth, firstImage->Depth);
		if (mt->target == texObj->Target &&
	        mt->mesaFormat == firstImage->TexFormat &&
	        mt->numLevels >= numLevels &&
	        mtBaseLevel->width == firstImage->Width &&
	        mtBaseLevel->height == firstImage->Height &&
	        mtBaseLevel->depth == firstImage->Depth) {
			fprintf(stderr, "MATCHED\n");
		} else {
			fprintf(stderr, "NOT MATCHED\n");
		}
	}

	return (mt->target == texObj->Target &&
	        mt->mesaFormat == firstImage->TexFormat &&
	        mt->numLevels >= numLevels &&
	        mtBaseLevel->width == firstImage->Width &&
	        mtBaseLevel->height == firstImage->Height &&
	        mtBaseLevel->depth == firstImage->Depth);
}

/**
 * Try to allocate a mipmap tree for the given texture object.
 * @@param[in] rmesa radeon context
 * @@param[in] t radeon texture object
 */
void radeon_try_alloc_miptree(radeonContextPtr rmesa, radeonTexObj *t)
{
	struct gl_texture_object *texObj = &t->base;
	struct gl_texture_image *texImg = texObj->Image[0][texObj->BaseLevel];
	GLuint numLevels;
	assert(!t->mt);

	if (!texImg) {
		radeon_warning("%s(%p) No image in given texture object(%p).\n",
				__func__, rmesa, t);
		return;
	}


	numLevels = MIN2(texObj->MaxLevel - texObj->BaseLevel + 1, texImg->MaxNumLevels);

	t->mt = radeon_miptree_create(rmesa, t->base.Target,
		texImg->TexFormat, texObj->BaseLevel,
		numLevels, texImg->Width, texImg->Height,
		texImg->Depth, t->tile_bits);
}

GLuint
radeon_miptree_image_offset(radeon_mipmap_tree *mt,
			    GLuint face, GLuint level)
{
	if (mt->target == GL_TEXTURE_CUBE_MAP_ARB)
		return (mt->levels[level].faces[face].offset);
	else
		return mt->levels[level].faces[0].offset;
}

/**
 * Ensure that the given image is stored in the given miptree from now on.
 */
static void migrate_image_to_miptree(radeon_mipmap_tree *mt,
									 radeon_texture_image *image,
									 int face, int level)
{
	radeon_mipmap_level *dstlvl = &mt->levels[level];
	unsigned char *dest;

	assert(image->mt != mt);
	assert(dstlvl->valid);
	assert(dstlvl->width == image->base.Base.Width);
	assert(dstlvl->height == image->base.Base.Height);
	assert(dstlvl->depth == image->base.Base.Depth);

	radeon_print(RADEON_TEXTURE, RADEON_VERBOSE,
			"%s miptree %p, image %p, face %d, level %d.\n",
			__func__, mt, image, face, level);

	radeon_bo_map(mt->bo, GL_TRUE);
	dest = mt->bo->ptr + dstlvl->faces[face].offset;

	if (image->mt) {
		/* Format etc. should match, so we really just need a memcpy().
		 * In fact, that memcpy() could be done by the hardware in many
		 * cases, provided that we have a proper memory manager.
		 */
		assert(mt->mesaFormat == image->base.Base.TexFormat);

		radeon_mipmap_level *srclvl = &image->mt->levels[image->base.Base.Level];

		assert(image->base.Base.Level == level);
		assert(srclvl->size == dstlvl->size);
		assert(srclvl->rowstride == dstlvl->rowstride);

		radeon_bo_map(image->mt->bo, GL_FALSE);

		memcpy(dest,
			image->mt->bo->ptr + srclvl->faces[face].offset,
			dstlvl->size);
		radeon_bo_unmap(image->mt->bo);

		radeon_miptree_unreference(&image->mt);
	}

	radeon_bo_unmap(mt->bo);

	radeon_miptree_reference(mt, &image->mt);
}

/**
 * Filter matching miptrees, and select one with the most of data.
 * @@param[in] texObj radeon texture object
 * @@param[in] firstLevel first texture level to check
 * @@param[in] lastLevel last texture level to check
 */
static radeon_mipmap_tree * get_biggest_matching_miptree(radeonTexObj *texObj,
														 unsigned firstLevel,
														 unsigned lastLevel)
{
	const unsigned numLevels = lastLevel - firstLevel + 1;
	unsigned *mtSizes = calloc(numLevels, sizeof(unsigned));
	radeon_mipmap_tree **mts = calloc(numLevels, sizeof(radeon_mipmap_tree *));
	unsigned mtCount = 0;
	unsigned maxMtIndex = 0;
	radeon_mipmap_tree *tmp;
	unsigned int level;
	int i;

	for (level = firstLevel; level <= lastLevel; ++level) {
		radeon_texture_image *img = get_radeon_texture_image(texObj->base.Image[0][level]);
		unsigned found = 0;
		// TODO: why this hack??
		if (!img)
			break;

		if (!img->mt)
			continue;

		for (i = 0; i < mtCount; ++i) {
			if (mts[i] == img->mt) {
				found = 1;
				mtSizes[i] += img->mt->levels[img->base.Base.Level].size;
				break;
			}
		}

		if (!found && radeon_miptree_matches_texture(img->mt, &texObj->base)) {
			mtSizes[mtCount] = img->mt->levels[img->base.Base.Level].size;
			mts[mtCount] = img->mt;
			mtCount++;
		}
	}

	if (mtCount == 0) {
		free(mtSizes);
		free(mts);
		return NULL;
	}

	for (i = 1; i < mtCount; ++i) {
		if (mtSizes[i] > mtSizes[maxMtIndex]) {
			maxMtIndex = i;
		}
	}

	tmp = mts[maxMtIndex];
	free(mtSizes);
	free(mts);

	return tmp;
}

/**
 * Validate texture mipmap tree.
 * If individual images are stored in different mipmap trees
 * use the mipmap tree that has the most of the correct data.
 */
int radeon_validate_texture_miptree(struct gl_context * ctx,
				    struct gl_sampler_object *samp,
				    struct gl_texture_object *texObj)
{
	radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
	radeonTexObj *t = radeon_tex_obj(texObj);
	radeon_mipmap_tree *dst_miptree;

	if (samp == &texObj->Sampler && (t->validated || t->image_override)) {
		return GL_TRUE;
	}

	calculate_min_max_lod(samp, &t->base, &t->minLod, &t->maxLod);

	radeon_print(RADEON_TEXTURE, RADEON_NORMAL,
			"%s: Validating texture %p now, minLod = %d, maxLod = %d\n",
			__FUNCTION__, texObj ,t->minLod, t->maxLod);

	dst_miptree = get_biggest_matching_miptree(t, t->base.BaseLevel, t->base._MaxLevel);

	radeon_miptree_unreference(&t->mt);
	if (!dst_miptree) {
		radeon_try_alloc_miptree(rmesa, t);
		radeon_print(RADEON_TEXTURE, RADEON_NORMAL,
			"%s: No matching miptree found, allocated new one %p\n",
			__FUNCTION__, t->mt);

	} else {
		radeon_miptree_reference(dst_miptree, &t->mt);
		radeon_print(RADEON_TEXTURE, RADEON_NORMAL,
			"%s: Using miptree %p\n", __FUNCTION__, t->mt);
	}

	const unsigned faces = _mesa_num_tex_faces(texObj->Target);
	unsigned face, level;
	radeon_texture_image *img;
	/* Validate only the levels that will actually be used during rendering */
	for (face = 0; face < faces; ++face) {
		for (level = t->minLod; level <= t->maxLod; ++level) {
			img = get_radeon_texture_image(texObj->Image[face][level]);

			radeon_print(RADEON_TEXTURE, RADEON_TRACE,
				"Checking image level %d, face %d, mt %p ... ",
				level, face, img->mt);
			
			if (img->mt != t->mt && !img->used_as_render_target) {
				radeon_print(RADEON_TEXTURE, RADEON_TRACE,
					"MIGRATING\n");

				struct radeon_bo *src_bo = (img->mt) ? img->mt->bo : img->bo;
				if (src_bo && radeon_bo_is_referenced_by_cs(src_bo, rmesa->cmdbuf.cs)) {
					radeon_firevertices(rmesa);
				}
				migrate_image_to_miptree(t->mt, img, face, level);
			} else
				radeon_print(RADEON_TEXTURE, RADEON_TRACE, "OK\n");
		}
	}

	t->validated = GL_TRUE;

	return GL_TRUE;
}

uint32_t get_base_teximage_offset(radeonTexObj *texObj)
{
	if (!texObj->mt) {
		return 0;
	} else {
		return radeon_miptree_image_offset(texObj->mt, 0, texObj->minLod);
	}
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d42 1
a42 1
		gl_format format,
d74 1
a74 1
		gl_format format,
d99 1
a99 1
unsigned get_texture_image_row_stride(radeonContextPtr rmesa, gl_format format, unsigned width, unsigned tiling, GLuint target)
d180 1
a180 1
					  GLenum target, gl_format mesaFormat, GLuint baseLevel, GLuint numLevels,
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d99 1
a99 1
unsigned get_texture_image_row_stride(radeonContextPtr rmesa, gl_format format, unsigned width, unsigned tiling)
d106 1
a106 1
		if (!_mesa_is_pow_two(width)) {
d135 1
a135 1
	lvl->rowstride = get_texture_image_row_stride(rmesa, mt->mesaFormat, lvl->width, mt->tilebits);
d150 1
a150 10
static GLuint minify(GLuint size, GLuint levels)
{
	size = size >> levels;
	if (size < 1)
		size = 1;
	return size;
}


static void calculate_miptree_layout_r100(radeonContextPtr rmesa, radeon_mipmap_tree *mt)
d154 1
a154 1
	assert(mt->numLevels <= rmesa->glCtx->Const.MaxTextureLevels);
a175 33
static void calculate_miptree_layout_r300(radeonContextPtr rmesa, radeon_mipmap_tree *mt)
{
	GLuint curOffset, i, level;

	assert(mt->numLevels <= rmesa->glCtx->Const.MaxTextureLevels);

	curOffset = 0;
	for(i = 0, level = mt->baseLevel; i < mt->numLevels; i++, level++) {
		GLuint face;

		mt->levels[level].valid = 1;
		mt->levels[level].width = minify(mt->width0, i);
		mt->levels[level].height = minify(mt->height0, i);
		mt->levels[level].depth = minify(mt->depth0, i);

		for(face = 0; face < mt->faces; face++)
			compute_tex_image_offset(rmesa, mt, face, level, &curOffset);
		/* from r700? cube levels seems to be aligned to 8 faces,
		 * as we have separate register for 1'st level offset add
		 * 2 image alignment after 1'st mip level */
		if(rmesa->radeonScreen->chip_family >= CHIP_FAMILY_RV770 &&
		   mt->target == GL_TEXTURE_CUBE_MAP && level >= 1)
			curOffset += 2 * mt->levels[level].size;
	}

	/* Note the required size in memory */
	mt->totalsize = (curOffset + RADEON_OFFSET_MASK) & ~RADEON_OFFSET_MASK;

	radeon_print(RADEON_TEXTURE, RADEON_TRACE,
			"%s(%p, %p) total size %d\n",
			__func__, rmesa, mt, mt->totalsize);
}

d179 3
a181 3
static radeon_mipmap_tree* radeon_miptree_create(radeonContextPtr rmesa,
		GLenum target, gl_format mesaFormat, GLuint baseLevel, GLuint numLevels,
		GLuint width0, GLuint height0, GLuint depth0, GLuint tilebits)
d192 1
a192 1
	mt->faces = (target == GL_TEXTURE_CUBE_MAP) ? 6 : 1;
d200 1
a200 4
	if (rmesa->radeonScreen->chip_family >= CHIP_FAMILY_R300)
		calculate_miptree_layout_r300(rmesa, mt);
	else
		calculate_miptree_layout_r100(rmesa, mt);
d243 1
a243 1
static void calculate_min_max_lod(struct gl_texture_object *tObj,
d254 1
a254 1
		if (tObj->Sampler.MinFilter == GL_NEAREST || tObj->Sampler.MinFilter == GL_LINEAR) {
d259 1
a259 1
			minLod = tObj->BaseLevel + (GLint)(tObj->Sampler.MinLod);
d262 1
a262 1
			maxLod = tObj->BaseLevel + (GLint)(tObj->Sampler.MaxLod + 0.5);
d264 1
a264 1
			maxLod = MIN2(maxLod, tObj->Image[0][minLod]->MaxLog2 + minLod);
d292 1
a292 1
		struct gl_texture_image *texImage, GLuint face, GLuint level)
d295 1
a295 4

	if (face >= mt->faces)
		return GL_FALSE;

d323 1
a323 1
	numLevels = MIN2(texObj->MaxLevel - texObj->BaseLevel + 1, firstImage->MaxLog2 + 1);
a362 1

d372 1
a372 1
	numLevels = MIN2(texObj->MaxLevel - texObj->BaseLevel + 1, texImg->MaxLog2 + 1);
d402 3
a404 3
	assert(dstlvl->width == image->base.Width);
	assert(dstlvl->height == image->base.Height);
	assert(dstlvl->depth == image->base.Depth);
d418 1
a418 1
		assert(mt->mesaFormat == image->base.TexFormat);
d420 1
a420 1
		radeon_mipmap_level *srclvl = &image->mt->levels[image->mtlevel];
d422 1
a422 1
		assert(image->mtlevel == level);
a433 21
	} else if (image->base.Data) {
		/* This condition should be removed, it's here to workaround
		 * a segfault when mapping textures during software fallbacks.
		 */
		radeon_print(RADEON_FALLBACKS, RADEON_IMPORTANT,
				"%s Trying to map texture in sowftware fallback.\n",
				__func__);
		const uint32_t srcrowstride = _mesa_format_row_stride(image->base.TexFormat, image->base.Width);
		uint32_t rows = image->base.Height * image->base.Depth;

		if (_mesa_is_format_compressed(image->base.TexFormat)) {
			uint32_t blockWidth, blockHeight;
			_mesa_get_format_block_size(image->base.TexFormat, &blockWidth, &blockHeight);
			rows = (rows + blockHeight - 1) / blockHeight;
		}

		copy_rows(dest, dstlvl->rowstride, image->base.Data, srcrowstride,
				  rows, srcrowstride);

		_mesa_free_texmemory(image->base.Data);
		image->base.Data = 0;
a438 2
	image->mtface = face;
	image->mtlevel = level;
d473 1
a473 1
				mtSizes[i] += img->mt->levels[img->mtlevel].size;
d479 1
a479 1
			mtSizes[mtCount] = img->mt->levels[img->mtlevel].size;
d509 3
a511 1
int radeon_validate_texture_miptree(struct gl_context * ctx, struct gl_texture_object *texObj)
d515 1
d517 1
a517 1
	if (t->validated || t->image_override) {
d521 1
a521 9
	if (texObj->Image[0][texObj->BaseLevel]->Border > 0)
		return GL_FALSE;

	_mesa_test_texobj_completeness(rmesa->glCtx, texObj);
	if (!texObj->_Complete) {
		return GL_FALSE;
	}

	calculate_min_max_lod(&t->base, &t->minLod, &t->maxLod);
d527 1
a527 2
	radeon_mipmap_tree *dst_miptree;
	dst_miptree = get_biggest_matching_miptree(t, t->base.BaseLevel, t->base.MaxLevel);
d542 1
a542 1
	const unsigned faces = texObj->Target == GL_TEXTURE_CUBE_MAP ? 6 : 1;
d554 1
a554 1
			if (img->mt != t->mt) {
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d299 1
a299 1
		if (tObj->MinFilter == GL_NEAREST || tObj->MinFilter == GL_LINEAR) {
d304 1
a304 1
			minLod = tObj->BaseLevel + (GLint)(tObj->MinLod);
d307 1
a307 1
			maxLod = tObj->BaseLevel + (GLint)(tObj->MaxLod + 0.5);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d39 1
d73 1
a73 1
static unsigned get_compressed_image_size(
d76 3
a78 1
		unsigned height)
d80 25
a104 1
	unsigned blockWidth, blockHeight;
d106 9
a114 1
	_mesa_get_format_block_size(format, &blockWidth, &blockHeight);
d116 2
a117 1
	return rowStride * ((height + blockHeight - 1) / blockHeight);
a130 1
	uint32_t row_align;
d135 3
a137 19
	/* Find image size in bytes */
	if (_mesa_is_format_compressed(mt->mesaFormat)) {
		lvl->rowstride = get_aligned_compressed_row_stride(mt->mesaFormat, lvl->width, rmesa->texture_compressed_row_align);
		lvl->size = get_compressed_image_size(mt->mesaFormat, lvl->rowstride, height);
	} else if (mt->target == GL_TEXTURE_RECTANGLE_NV) {
		row_align = rmesa->texture_rect_row_align - 1;
		lvl->rowstride = (_mesa_format_row_stride(mt->mesaFormat, lvl->width) + row_align) & ~row_align;
		lvl->size = lvl->rowstride * height;
	} else if (mt->tilebits & RADEON_TXO_MICRO_TILE) {
		/* tile pattern is 16 bytes x2. mipmaps stay 32 byte aligned,
		 * though the actual offset may be different (if texture is less than
		 * 32 bytes width) to the untiled case */
		lvl->rowstride = (_mesa_format_row_stride(mt->mesaFormat, lvl->width) * 2 + 31) & ~31;
		lvl->size = lvl->rowstride * ((height + 1) / 2) * lvl->depth;
	} else {
		row_align = rmesa->texture_row_align - 1;
		lvl->rowstride = (_mesa_format_row_stride(mt->mesaFormat, lvl->width) + row_align) & ~row_align;
		lvl->size = lvl->rowstride * height * lvl->depth;
	}
a139 2
	/* All images are aligned to a 32-byte offset */
	*curOffset = (*curOffset + 0x1f) & ~0x1f;
d202 2
a203 2
		/* r600 cube levels seems to be aligned to 8 faces but
		 * we have separate register for 1'st level offset so add
d205 1
a205 1
		if(rmesa->radeonScreen->chip_family >= CHIP_FAMILY_R600 &&
a470 2
		/* TODO: bring back these assertions once the FBOs are fixed */
#if 0
a473 1
#endif
d581 1
a581 1
int radeon_validate_texture_miptree(GLcontext * ctx, struct gl_texture_object *texObj)
d605 1
a605 1
	dst_miptree = get_biggest_matching_miptree(t, t->minLod, t->maxLod);
d607 1
a608 1
		radeon_miptree_unreference(&t->mt);
a609 1
		dst_miptree = t->mt;
d615 1
d632 1
a632 1
			if (img->mt != dst_miptree) {
d640 1
a640 1
				migrate_image_to_miptree(dst_miptree, img, face, level);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a38 1
#include "radeon_tile.h"
d72 1
a72 1
unsigned get_texture_image_size(
d75 1
a75 3
		unsigned height,
		unsigned depth,
		unsigned tiling)
d77 1
a77 2
	if (_mesa_is_format_compressed(format)) {
		unsigned blockWidth, blockHeight;
d79 1
a79 32
		_mesa_get_format_block_size(format, &blockWidth, &blockHeight);

		return rowStride * ((height + blockHeight - 1) / blockHeight) * depth;
	} else if (tiling) {
		/* Need to align height to tile height */
		unsigned tileWidth, tileHeight;

		get_tile_size(format, &tileWidth, &tileHeight);
		tileHeight--;

		height = (height + tileHeight) & ~tileHeight;
	}

	return rowStride * height * depth;
}

unsigned get_texture_image_row_stride(radeonContextPtr rmesa, gl_format format, unsigned width, unsigned tiling)
{
	if (_mesa_is_format_compressed(format)) {
		return get_aligned_compressed_row_stride(format, width, rmesa->texture_compressed_row_align);
	} else {
		unsigned row_align;

		if (!_mesa_is_pow_two(width)) {
			row_align = rmesa->texture_rect_row_align - 1;
		} else if (tiling) {
			unsigned tileWidth, tileHeight;
			get_tile_size(format, &tileWidth, &tileHeight);
			row_align = tileWidth * _mesa_get_format_bytes(format) - 1;
		} else {
			row_align = rmesa->texture_row_align - 1;
		}
d81 1
a81 2
		return (_mesa_format_row_stride(format, width) + row_align) & ~row_align;
	}
d95 1
d100 19
a118 3
	lvl->rowstride = get_texture_image_row_stride(rmesa, mt->mesaFormat, lvl->width, mt->tilebits);
	lvl->size = get_texture_image_size(mt->mesaFormat, lvl->rowstride, height, lvl->depth, mt->tilebits);

d121 2
d185 2
a186 2
		/* from r700? cube levels seems to be aligned to 8 faces,
		 * as we have separate register for 1'st level offset add
d188 1
a188 1
		if(rmesa->radeonScreen->chip_family >= CHIP_FAMILY_RV770 &&
d454 2
d459 1
d567 1
a567 1
int radeon_validate_texture_miptree(struct gl_context * ctx, struct gl_texture_object *texObj)
d591 1
a591 1
	dst_miptree = get_biggest_matching_miptree(t, t->base.BaseLevel, t->base.MaxLevel);
a592 1
	radeon_miptree_unreference(&t->mt);
d594 1
d596 1
a601 1
		radeon_miptree_reference(dst_miptree, &t->mt);
d618 1
a618 1
			if (img->mt != t->mt) {
d626 1
a626 1
				migrate_image_to_miptree(t->mt, img, face, level);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d99 1
a99 1
unsigned get_texture_image_row_stride(radeonContextPtr rmesa, gl_format format, unsigned width, unsigned tiling, GLuint target)
d106 1
a106 1
		if (!_mesa_is_pow_two(width) || target == GL_TEXTURE_RECTANGLE) {
d135 1
a135 1
	lvl->rowstride = get_texture_image_row_stride(rmesa, mt->mesaFormat, lvl->width, mt->tilebits, mt->target);
d150 10
a159 1
static void calculate_miptree_layout(radeonContextPtr rmesa, radeon_mipmap_tree *mt)
d163 1
a163 1
	assert(mt->numLevels <= rmesa->glCtx.Const.MaxTextureLevels);
d185 33
d221 3
a223 3
radeon_mipmap_tree* radeon_miptree_create(radeonContextPtr rmesa,
					  GLenum target, gl_format mesaFormat, GLuint baseLevel, GLuint numLevels,
					  GLuint width0, GLuint height0, GLuint depth0, GLuint tilebits)
d234 1
a234 1
	mt->faces = _mesa_num_tex_faces(target);
d242 4
a245 1
	calculate_miptree_layout(rmesa, mt);
d288 1
a288 1
static void calculate_min_max_lod(struct gl_sampler_object *samp, struct gl_texture_object *tObj,
d299 1
a299 1
		if (samp->MinFilter == GL_NEAREST || samp->MinFilter == GL_LINEAR) {
d304 1
a304 1
			minLod = tObj->BaseLevel + (GLint)(samp->MinLod);
d307 1
a307 1
			maxLod = tObj->BaseLevel + (GLint)(samp->MaxLod + 0.5);
d309 1
a309 1
			maxLod = MIN2(maxLod, tObj->Image[0][minLod]->MaxNumLevels - 1 + minLod);
d337 1
a337 1
				       struct gl_texture_image *texImage)
d340 4
a343 1
	GLuint level = texImage->Level;
d371 1
a371 1
	numLevels = MIN2(texObj->_MaxLevel - texObj->BaseLevel + 1, firstImage->MaxNumLevels);
d411 1
d421 1
a421 1
	numLevels = MIN2(texObj->MaxLevel - texObj->BaseLevel + 1, texImg->MaxNumLevels);
d451 3
a453 3
	assert(dstlvl->width == image->base.Base.Width);
	assert(dstlvl->height == image->base.Base.Height);
	assert(dstlvl->depth == image->base.Base.Depth);
d467 1
a467 1
		assert(mt->mesaFormat == image->base.Base.TexFormat);
d469 1
a469 1
		radeon_mipmap_level *srclvl = &image->mt->levels[image->base.Base.Level];
d471 1
a471 1
		assert(image->base.Base.Level == level);
d483 21
d509 2
d545 1
a545 1
				mtSizes[i] += img->mt->levels[img->base.Base.Level].size;
d551 1
a551 1
			mtSizes[mtCount] = img->mt->levels[img->base.Base.Level].size;
d581 1
a581 3
int radeon_validate_texture_miptree(struct gl_context * ctx,
				    struct gl_sampler_object *samp,
				    struct gl_texture_object *texObj)
a584 1
	radeon_mipmap_tree *dst_miptree;
d586 1
a586 1
	if (samp == &texObj->Sampler && (t->validated || t->image_override)) {
d590 9
a598 1
	calculate_min_max_lod(samp, &t->base, &t->minLod, &t->maxLod);
d604 2
a605 1
	dst_miptree = get_biggest_matching_miptree(t, t->base.BaseLevel, t->base._MaxLevel);
d620 1
a620 1
	const unsigned faces = _mesa_num_tex_faces(texObj->Target);
d632 1
a632 1
			if (img->mt != t->mt && !img->used_as_render_target) {
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d42 1
a42 1
		mesa_format format,
d74 1
a74 1
		mesa_format format,
d99 1
a99 1
unsigned get_texture_image_row_stride(radeonContextPtr rmesa, mesa_format format, unsigned width, unsigned tiling, GLuint target)
d180 1
a180 1
					  GLenum target, mesa_format mesaFormat, GLuint baseLevel, GLuint numLevels,
@


