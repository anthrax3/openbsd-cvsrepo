head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.3.0.4
	OPENBSD_5_8_BASE:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.2
	OPENBSD_5_6_BASE:1.1.1.1
	v10_2_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.2
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2014.07.09.20.34.50;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.1
date	2014.07.09.20.34.50;	author jsg;	state Exp;
branches;
next	1.1.1.2;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.2
date	2015.01.25.14.11.39;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.3
date	2015.02.20.22.48.45;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2012 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

/** @@file brw_fs_register_coalesce.cpp
 *
 * Implements register coalescing: Checks if the two registers involved in a
 * raw move don't interfere, in which case they can both be stored in the same
 * place and the MOV removed.
 *
 * To do this, all uses of the source of the MOV in the shader are replaced
 * with the destination of the MOV. For example:
 *
 * add vgrf3:F, vgrf1:F, vgrf2:F
 * mov vgrf4:F, vgrf3:F
 * mul vgrf5:F, vgrf5:F, vgrf4:F
 *
 * becomes
 *
 * add vgrf4:F, vgrf1:F, vgrf2:F
 * mul vgrf5:F, vgrf5:F, vgrf4:F
 */

#include "brw_fs.h"
#include "brw_fs_live_variables.h"

static bool
is_nop_mov(const fs_inst *inst)
{
   if (inst->opcode == BRW_OPCODE_MOV) {
      return inst->dst.equals(inst->src[0]);
   }

   return false;
}

static bool
is_coalesce_candidate(const fs_inst *inst, const int *virtual_grf_sizes)
{
   if (inst->opcode != BRW_OPCODE_MOV ||
       inst->is_partial_write() ||
       inst->saturate ||
       inst->src[0].file != GRF ||
       inst->src[0].negate ||
       inst->src[0].abs ||
       !inst->src[0].is_contiguous() ||
       inst->dst.file != GRF ||
       inst->dst.type != inst->src[0].type) {
      return false;
   }

   if (virtual_grf_sizes[inst->src[0].reg] >
       virtual_grf_sizes[inst->dst.reg])
      return false;

   return true;
}

static bool
can_coalesce_vars(brw::fs_live_variables *live_intervals,
                  const exec_list *instructions, const fs_inst *inst,
                  int var_to, int var_from)
{
   if (!live_intervals->vars_interfere(var_from, var_to))
      return true;

   /* We know that the live ranges of A (var_from) and B (var_to)
    * interfere because of the ->vars_interfere() call above. If the end
    * of B's live range is after the end of A's range, then we know two
    * things:
    *  - the start of B's live range must be in A's live range (since we
    *    already know the two ranges interfere, this is the only remaining
    *    possibility)
    *  - the interference isn't of the form we're looking for (where B is
    *    entirely inside A)
    */
   if (live_intervals->end[var_to] > live_intervals->end[var_from])
      return false;

   int scan_ip = -1;

   foreach_list(n, instructions) {
      fs_inst *scan_inst = (fs_inst *)n;
      scan_ip++;

      if (scan_inst->is_control_flow())
         return false;

      if (scan_ip <= live_intervals->start[var_to])
         continue;

      if (scan_ip > live_intervals->end[var_to])
         break;

      if (scan_inst->dst.equals(inst->dst) ||
          scan_inst->dst.equals(inst->src[0]))
         return false;
   }

   return true;
}

bool
fs_visitor::register_coalesce()
{
   bool progress = false;

   calculate_live_intervals();

   int src_size = 0;
   int channels_remaining = 0;
   int reg_from = -1, reg_to = -1;
   int reg_to_offset[MAX_SAMPLER_MESSAGE_SIZE];
   fs_inst *mov[MAX_SAMPLER_MESSAGE_SIZE];
   int var_to[MAX_SAMPLER_MESSAGE_SIZE];
   int var_from[MAX_SAMPLER_MESSAGE_SIZE];

   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      if (!is_coalesce_candidate(inst, virtual_grf_sizes))
         continue;

      if (is_nop_mov(inst)) {
         inst->opcode = BRW_OPCODE_NOP;
         progress = true;
         continue;
      }

      if (reg_from != inst->src[0].reg) {
         reg_from = inst->src[0].reg;

         src_size = virtual_grf_sizes[inst->src[0].reg];
         assert(src_size <= MAX_SAMPLER_MESSAGE_SIZE);

         channels_remaining = src_size;
         memset(mov, 0, sizeof(mov));

         reg_to = inst->dst.reg;
      }

      if (reg_to != inst->dst.reg)
         continue;

      const int offset = inst->src[0].reg_offset;
      reg_to_offset[offset] = inst->dst.reg_offset;
      mov[offset] = inst;
      channels_remaining--;

      if (channels_remaining)
         continue;

      bool can_coalesce = true;
      for (int i = 0; i < src_size; i++) {
         var_to[i] = live_intervals->var_from_vgrf[reg_to] + reg_to_offset[i];
         var_from[i] = live_intervals->var_from_vgrf[reg_from] + i;

         if (!can_coalesce_vars(live_intervals, &instructions, inst,
                                var_to[i], var_from[i])) {
            can_coalesce = false;
            reg_from = -1;
            break;
         }
      }

      if (!can_coalesce)
         continue;

      progress = true;

      for (int i = 0; i < src_size; i++) {
         if (mov[i]) {
            mov[i]->opcode = BRW_OPCODE_NOP;
            mov[i]->conditional_mod = BRW_CONDITIONAL_NONE;
            mov[i]->dst = reg_undef;
            mov[i]->src[0] = reg_undef;
            mov[i]->src[1] = reg_undef;
            mov[i]->src[2] = reg_undef;
         }
      }

      foreach_list(node, &this->instructions) {
         fs_inst *scan_inst = (fs_inst *)node;

         for (int i = 0; i < src_size; i++) {
            if (mov[i]) {
               if (scan_inst->dst.file == GRF &&
                   scan_inst->dst.reg == reg_from &&
                   scan_inst->dst.reg_offset == i) {
                  scan_inst->dst.reg = reg_to;
                  scan_inst->dst.reg_offset = reg_to_offset[i];
               }
               for (int j = 0; j < 3; j++) {
                  if (scan_inst->src[j].file == GRF &&
                      scan_inst->src[j].reg == reg_from &&
                      scan_inst->src[j].reg_offset == i) {
                     scan_inst->src[j].reg = reg_to;
                     scan_inst->src[j].reg_offset = reg_to_offset[i];
                  }
               }
            }
         }
      }

      for (int i = 0; i < src_size; i++) {
         live_intervals->start[var_to[i]] =
            MIN2(live_intervals->start[var_to[i]],
                 live_intervals->start[var_from[i]]);
         live_intervals->end[var_to[i]] =
            MAX2(live_intervals->end[var_to[i]],
                 live_intervals->end[var_from[i]]);
      }
      reg_from = -1;
   }

   if (progress) {
      foreach_list_safe(node, &this->instructions) {
         fs_inst *inst = (fs_inst *)node;

         if (inst->opcode == BRW_OPCODE_NOP) {
            inst->remove();
         }
      }

      invalidate_live_intervals();
   }

   return progress;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 10.2.3
@
text
@@


1.1.1.2
log
@Import Mesa 10.4.3
@
text
@a43 1
#include "brw_cfg.h"
d49 1
a49 10
   if (inst->opcode == SHADER_OPCODE_LOAD_PAYLOAD) {
      fs_reg dst = inst->dst;
      for (int i = 0; i < inst->sources; i++) {
         dst.reg_offset = i;
         if (!dst.equals(inst->src[i])) {
            return false;
         }
      }
      return true;
   } else if (inst->opcode == BRW_OPCODE_MOV) {
d57 1
a57 16
is_copy_payload(const fs_visitor *v, const fs_inst *inst)
{
   if (v->virtual_grf_sizes[inst->src[0].reg] != inst->regs_written)
      return false;

   fs_reg reg = inst->src[0];

   for (int i = 0; i < inst->sources; i++)
      if (!inst->src[i].equals(offset(reg, i)))
         return false;

   return true;
}

static bool
is_coalesce_candidate(const fs_visitor *v, const fs_inst *inst)
d59 1
a59 2
   if ((inst->opcode != BRW_OPCODE_MOV &&
        inst->opcode != SHADER_OPCODE_LOAD_PAYLOAD) ||
d71 2
a72 2
   if (v->virtual_grf_sizes[inst->src[0].reg] >
       v->virtual_grf_sizes[inst->dst.reg])
a74 6
   if (inst->opcode == SHADER_OPCODE_LOAD_PAYLOAD) {
      if (!is_copy_payload(v, inst)) {
         return false;
      }
   }

d80 1
a80 1
                  const cfg_t *cfg, const fs_inst *inst,
d86 11
a96 8
   int start_to = live_intervals->start[var_to];
   int end_to = live_intervals->end[var_to];
   int start_from = live_intervals->start[var_from];
   int end_from = live_intervals->end[var_from];

   /* Variables interfere and one line range isn't a subset of the other. */
   if ((end_to > end_from && start_from < start_to) ||
       (end_from > end_to && start_to < start_from))
a98 1
   int start_ip = MIN2(start_to, start_from);
d101 2
a102 1
   foreach_block_and_inst(block, fs_inst, scan_inst, cfg) {
a104 3
      if (scan_ip < start_ip)
         continue;

d112 1
a112 1
         return true;
d132 7
a138 4
   int reg_to_offset[MAX_VGRF_SIZE];
   fs_inst *mov[MAX_VGRF_SIZE];
   int var_to[MAX_VGRF_SIZE];
   int var_from[MAX_VGRF_SIZE];
d140 1
a140 2
   foreach_block_and_inst(block, fs_inst, inst, cfg) {
      if (!is_coalesce_candidate(this, inst))
d153 1
a153 1
         assert(src_size <= MAX_VGRF_SIZE);
a154 1
         assert(inst->src[0].width % 8 == 0);
d164 4
a167 24
      if (inst->opcode == SHADER_OPCODE_LOAD_PAYLOAD) {
         for (int i = 0; i < src_size; i++) {
            reg_to_offset[i] = i;
         }
         mov[0] = inst;
         channels_remaining -= inst->regs_written;
      } else {
         const int offset = inst->src[0].reg_offset;
         if (mov[offset]) {
            /* This is the second time that this offset in the register has
             * been set.  This means, in particular, that inst->dst was
             * live before this instruction and that the live ranges of
             * inst->dst and inst->src[0] overlap and we can't coalesce the
             * two variables.  Let's ensure that doesn't happen.
             */
            channels_remaining = -1;
            continue;
         }
         reg_to_offset[offset] = inst->dst.reg_offset;
         if (inst->src[0].width == 16)
            reg_to_offset[offset + 1] = inst->dst.reg_offset + 1;
         mov[offset] = inst;
         channels_remaining -= inst->regs_written;
      }
a173 7
         if (reg_to_offset[i] != reg_to_offset[0] + i) {
            /* Registers are out-of-order. */
            can_coalesce = false;
            reg_from = -1;
            break;
         }

d177 1
a177 1
         if (!can_coalesce_vars(live_intervals, cfg, inst,
a188 1
      bool was_load_payload = inst->opcode == SHADER_OPCODE_LOAD_PAYLOAD;
d195 3
a197 3
            for (int j = 0; j < mov[i]->sources; j++) {
               mov[i]->src[j] = reg_undef;
            }
d201 3
a203 1
      foreach_block_and_inst(block, fs_inst, scan_inst, cfg) {
d205 1
a205 1
            if (mov[i] || was_load_payload) {
d212 1
a212 1
               for (int j = 0; j < scan_inst->sources; j++) {
d236 3
a238 1
      foreach_block_and_inst_safe (block, backend_instruction, inst, cfg) {
d240 1
a240 1
            inst->remove(block);
@


1.1.1.3
log
@Import Mesa 10.2.9
@
text
@d44 1
d50 10
a59 1
   if (inst->opcode == BRW_OPCODE_MOV) {
d67 16
a82 1
is_coalesce_candidate(const fs_inst *inst, const int *virtual_grf_sizes)
d84 2
a85 1
   if (inst->opcode != BRW_OPCODE_MOV ||
d97 2
a98 2
   if (virtual_grf_sizes[inst->src[0].reg] >
       virtual_grf_sizes[inst->dst.reg])
d101 6
d112 1
a112 1
                  const exec_list *instructions, const fs_inst *inst,
d118 8
a125 11
   /* We know that the live ranges of A (var_from) and B (var_to)
    * interfere because of the ->vars_interfere() call above. If the end
    * of B's live range is after the end of A's range, then we know two
    * things:
    *  - the start of B's live range must be in A's live range (since we
    *    already know the two ranges interfere, this is the only remaining
    *    possibility)
    *  - the interference isn't of the form we're looking for (where B is
    *    entirely inside A)
    */
   if (live_intervals->end[var_to] > live_intervals->end[var_from])
d128 1
d131 1
a131 2
   foreach_list(n, instructions) {
      fs_inst *scan_inst = (fs_inst *)n;
d134 3
d144 1
a144 1
         break;
d164 4
a167 7
   int reg_to_offset[MAX_SAMPLER_MESSAGE_SIZE];
   fs_inst *mov[MAX_SAMPLER_MESSAGE_SIZE];
   int var_to[MAX_SAMPLER_MESSAGE_SIZE];
   int var_from[MAX_SAMPLER_MESSAGE_SIZE];

   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;
d169 2
a170 1
      if (!is_coalesce_candidate(inst, virtual_grf_sizes))
d183 1
a183 1
         assert(src_size <= MAX_SAMPLER_MESSAGE_SIZE);
d185 1
d195 24
a218 4
      const int offset = inst->src[0].reg_offset;
      reg_to_offset[offset] = inst->dst.reg_offset;
      mov[offset] = inst;
      channels_remaining--;
d225 7
d235 1
a235 1
         if (!can_coalesce_vars(live_intervals, &instructions, inst,
d247 1
d254 3
a256 3
            mov[i]->src[0] = reg_undef;
            mov[i]->src[1] = reg_undef;
            mov[i]->src[2] = reg_undef;
d260 1
a260 3
      foreach_list(node, &this->instructions) {
         fs_inst *scan_inst = (fs_inst *)node;

d262 1
a262 1
            if (mov[i]) {
d269 1
a269 1
               for (int j = 0; j < 3; j++) {
d293 1
a293 3
      foreach_list_safe(node, &this->instructions) {
         fs_inst *inst = (fs_inst *)node;

d295 1
a295 1
            inst->remove();
@


