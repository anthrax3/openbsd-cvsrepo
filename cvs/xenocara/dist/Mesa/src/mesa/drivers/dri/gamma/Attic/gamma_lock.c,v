head	1.3;
access;
symbols
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2010.05.22.20.06.17;	author matthieu;	state dead;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.38;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.23;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.23;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@
#include "gammacontext.h"
#include "gamma_lock.h"
#include "drirenderbuffer.h"

#ifdef DEBUG_LOCKING
char *prevLockFile = NULL;
int prevLockLine = 0;
#endif


/* Update the hardware state.  This is called if another context has
 * grabbed the hardware lock, which includes the X server.  This
 * function also updates the driver's window state after the X server
 * moves, resizes or restacks a window -- the change will be reflected
 * in the drawable position and clip rects.  Since the X server grabs
 * the hardware lock when it changes the window state, this routine will
 * automatically be called after such a change.
 */
void gammaGetLock( gammaContextPtr gmesa, GLuint flags )
{
   __DRIdrawablePrivate *dPriv = gmesa->driDrawable;
   __DRIscreenPrivate *sPriv = gmesa->driScreen;

   drmGetLock( gmesa->driFd, gmesa->hHWContext, flags );

   /* The window might have moved, so we might need to get new clip
    * rects.
    *
    * NOTE: This releases and regrabs the hw lock to allow the X server
    * to respond to the DRI protocol request for new drawable info.
    * Since the hardware state depends on having the latest drawable
    * clip rects, all state checking must be done _after_ this call.
    */
   DRI_VALIDATE_DRAWABLE_INFO( sPriv, dPriv );

   if ( gmesa->lastStamp != dPriv->lastStamp ) {
      driUpdateFramebufferSize(gmesa->glCtx, dPriv);
      gmesa->lastStamp = dPriv->lastStamp;
      gmesa->new_state |= GAMMA_NEW_WINDOW | GAMMA_NEW_CLIP;
   }

   gmesa->numClipRects = dPriv->numClipRects;
   gmesa->pClipRects = dPriv->pClipRects;

#if 0
   gmesa->dirty = ~0;

   if ( sarea->ctxOwner != gmesa->hHWContext ) {
      sarea->ctxOwner = gmesa->hHWContext;
      gmesa->dirty = GAMMA_UPLOAD_ALL;
   }

   for ( i = 0 ; i < gmesa->lastTexHeap ; i++ ) {
      if ( sarea->texAge[i] != gmesa->lastTexAge[i] ) {
	 gammaAgeTextures( gmesa, i );
      }
   }
#endif
}
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86: xc/lib/GL/mesa/src/drv/gamma/gamma_lock.c,v 1.4 2002/11/05 17:46:07 tsi Exp $ */
d2 1
a2 1
#include "gamma_context.h"
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@
