head	1.3;
access;
symbols
	OPENBSD_5_8:1.2.0.8
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.6
	OPENBSD_5_7_BASE:1.2
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.1.0.20
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.18
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.16
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.14
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.12
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.8
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.10
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.2;
commitid	TnlogFl9nOv2eaRf;

1.2
date	2013.09.05.14.04.07;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.35;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.17;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove the now unused Mesa 10.2.9 code
@
text
@#!/usr/bin/python

#
# Usage:
#     gen_xmlpool.py /path/to/t_option.h localedir lang lang lang ...
#
# For each given language, this script expects to find a .mo file at
# `{localedir}/{language}/LC_MESSAGES/options.mo`.
#

import sys
import gettext
import re

# Path to t_options.h
template_header_path = sys.argv[1]

localedir = sys.argv[2]

# List of supported languages
languages = sys.argv[3:]

# Escape special characters in C strings
def escapeCString (s):
    escapeSeqs = {'\a' : '\\a', '\b' : '\\b', '\f' : '\\f', '\n' : '\\n',
                  '\r' : '\\r', '\t' : '\\t', '\v' : '\\v', '\\' : '\\\\'}
    # " -> '' is a hack. Quotes (") aren't possible in XML attributes.
    # Better use Unicode characters for typographic quotes in option
    # descriptions and translations.
    i = 0
    r = ''
    while i < len(s):
        # Special case: escape double quote with \u201c or \u201d, depending
        # on whether it's an open or close quote. This is needed because plain
        # double quotes are not possible in XML attributes.
        if s[i] == '"':
            if i == len(s)-1 or s[i+1].isspace():
                # close quote
                q = u'\u201c'
            else:
                # open quote
                q = u'\u201d'
            r = r + q
        elif escapeSeqs.has_key(s[i]):
            r = r + escapeSeqs[s[i]]
        else:
            r = r + s[i]
        i = i + 1
    return r

# Expand escape sequences in C strings (needed for gettext lookup)
def expandCString (s):
    escapeSeqs = {'a' : '\a', 'b' : '\b', 'f' : '\f', 'n' : '\n',
                  'r' : '\r', 't' : '\t', 'v' : '\v',
                  '"' : '"', '\\' : '\\'}
    i = 0
    escape = False
    hexa = False
    octa = False
    num = 0
    digits = 0
    r = ''
    while i < len(s):
        if not escape:
            if s[i] == '\\':
                escape = True
            else:
                r = r + s[i]
        elif hexa:
            if (s[i] >= '0' and s[i] <= '9') or \
               (s[i] >= 'a' and s[i] <= 'f') or \
               (s[i] >= 'A' and s[i] <= 'F'):
                num = num * 16 + int(s[i],16)
                digits = digits + 1
            else:
                digits = 2
            if digits >= 2:
                hexa = False
                escape = False
                r = r + chr(num)
        elif octa:
            if s[i] >= '0' and s[i] <= '7':
                num = num * 8 + int(s[i],8)
                digits = digits + 1
            else:
                digits = 3
            if digits >= 3:
                octa = False
                escape = False
                r = r + chr(num)
        else:
            if escapeSeqs.has_key(s[i]):
                r = r + escapeSeqs[s[i]]
                escape = False
            elif s[i] >= '0' and s[i] <= '7':
                octa = True
                num = int(s[i],8)
                if num <= 3:
                    digits = 1
                else:
                    digits = 2
            elif s[i] == 'x' or s[i] == 'X':
                hexa = True
                num = 0
                digits = 0
            else:
                r = r + s[i]
                escape = False
        i = i + 1
    return r

# Expand matches. The first match is always a DESC or DESC_BEGIN match.
# Subsequent matches are ENUM matches.
#
# DESC, DESC_BEGIN format: \1 \2=<lang> \3 \4=gettext(" \5=<text> \6=") \7
# ENUM format:             \1 \2=gettext(" \3=<text> \4=") \5
def expandMatches (matches, translations, end=None):
    assert len(matches) > 0
    nTranslations = len(translations)
    i = 0
    # Expand the description+enums for all translations
    for lang,trans in translations:
        i = i + 1
        # Make sure that all but the last line of a simple description
        # are extended with a backslash.
        suffix = ''
        if len(matches) == 1 and i < len(translations) and \
               not matches[0].expand (r'\7').endswith('\\'):
            suffix = ' \\'
        # Expand the description line. Need to use ugettext in order to allow
        # non-ascii unicode chars in the original English descriptions.
        text = escapeCString (trans.ugettext (unicode (expandCString (
            matches[0].expand (r'\5')), "utf-8"))).encode("utf-8")
        print matches[0].expand (r'\1' + lang + r'\3"' + text + r'"\7') + suffix
        # Expand any subsequent enum lines
        for match in matches[1:]:
            text = escapeCString (trans.ugettext (unicode (expandCString (
                match.expand (r'\3')), "utf-8"))).encode("utf-8")
            print match.expand (r'\1"' + text + r'"\5')

        # Expand description end
        if end:
            print end,

# Compile a list of translation classes to all supported languages.
# The first translation is always a NullTranslations.
translations = [("en", gettext.NullTranslations())]
for lang in languages:
    try:
        trans = gettext.translation ("options", localedir, [lang])
    except IOError:
        sys.stderr.write ("Warning: language '%s' not found.\n" % lang)
        continue
    translations.append ((lang, trans))

# Regular expressions:
reLibintl_h  = re.compile (r'#\s*include\s*<libintl.h>')
reDESC       = re.compile (r'(\s*DRI_CONF_DESC\s*\(\s*)([a-z]+)(\s*,\s*)(gettext\s*\(\s*")(.*)("\s*\))(\s*\)[ \t]*\\?)$')
reDESC_BEGIN = re.compile (r'(\s*DRI_CONF_DESC_BEGIN\s*\(\s*)([a-z]+)(\s*,\s*)(gettext\s*\(\s*")(.*)("\s*\))(\s*\)[ \t]*\\?)$')
reENUM       = re.compile (r'(\s*DRI_CONF_ENUM\s*\([^,]+,\s*)(gettext\s*\(\s*")(.*)("\s*\))(\s*\)[ \t]*\\?)$')
reDESC_END   = re.compile (r'\s*DRI_CONF_DESC_END')

# Print a header
print \
"/***********************************************************************\n" \
" ***        THIS FILE IS GENERATED AUTOMATICALLY. DON'T EDIT!        ***\n" \
" ***********************************************************************/"

# Process the options template and generate options.h with all
# translations.
template = file (template_header_path, "r")
descMatches = []
for line in template:
    if len(descMatches) > 0:
        matchENUM     = reENUM    .match (line)
        matchDESC_END = reDESC_END.match (line)
        if matchENUM:
            descMatches.append (matchENUM)
        elif matchDESC_END:
            expandMatches (descMatches, translations, line)
            descMatches = []
        else:
            sys.stderr.write (
                "Warning: unexpected line inside description dropped:\n%s\n" \
                % line)
        continue
    if reLibintl_h.search (line):
        # Ignore (comment out) #include <libintl.h>
        print "/* %s * commented out by gen_xmlpool.py */" % line
        continue
    matchDESC       = reDESC      .match (line)
    matchDESC_BEGIN = reDESC_BEGIN.match (line)
    if matchDESC:
        assert len(descMatches) == 0
        expandMatches ([matchDESC], translations)
    elif matchDESC_BEGIN:
        assert len(descMatches) == 0
        descMatches = [matchDESC_BEGIN]
    else:
        print line,

if len(descMatches) > 0:
    sys.stderr.write ("Warning: unterminated description at end of file.\n")
    expandMatches (descMatches, translations)
@


1.2
log
@Merge Mesa 9.2.0
@
text
@@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d3 8
d15 5
d21 1
a21 1
languages = sys.argv[1:]
d150 1
a150 1
        trans = gettext.translation ("options", ".", [lang])
d171 1
a171 1
template = file ("t_options.h", "r")
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a2 8
#
# Usage:
#     gen_xmlpool.py /path/to/t_option.h localedir lang lang lang ...
#
# For each given language, this script expects to find a .mo file at
# `{localedir}/{language}/LC_MESSAGES/options.mo`.
#

a6 5
# Path to t_options.h
template_header_path = sys.argv[1]

localedir = sys.argv[2]

d8 1
a8 1
languages = sys.argv[3:]
d137 1
a137 1
        trans = gettext.translation ("options", localedir, [lang])
d158 1
a158 1
template = file (template_header_path, "r")
@


