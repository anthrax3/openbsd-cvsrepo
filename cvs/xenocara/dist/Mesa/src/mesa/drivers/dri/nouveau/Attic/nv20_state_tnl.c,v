head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.4
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.04.52;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.22;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.40;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.57;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.55;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright (C) 2009-2010 Francisco Jerez.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "nouveau_driver.h"
#include "nouveau_context.h"
#include "nouveau_gldefs.h"
#include "nouveau_util.h"
#include "nv20_3d.xml.h"
#include "nv10_driver.h"
#include "nv20_driver.h"

#define LIGHT_MODEL_AMBIENT_R(side)			\
	((side) ? NV20_3D_LIGHT_MODEL_BACK_AMBIENT_R :	\
	 NV20_3D_LIGHT_MODEL_FRONT_AMBIENT_R)
#define LIGHT_AMBIENT_R(side, i)			\
	((side) ? NV20_3D_LIGHT_BACK_AMBIENT_R(i) :	\
	 NV20_3D_LIGHT_FRONT_AMBIENT_R(i))
#define LIGHT_DIFFUSE_R(side, i)			\
	((side) ? NV20_3D_LIGHT_BACK_DIFFUSE_R(i) :	\
	 NV20_3D_LIGHT_FRONT_DIFFUSE_R(i))
#define LIGHT_SPECULAR_R(side, i)			\
	((side) ? NV20_3D_LIGHT_BACK_SPECULAR_R(i) :	\
	 NV20_3D_LIGHT_FRONT_SPECULAR_R(i))
#define MATERIAL_FACTOR_R(side)				\
	((side) ? NV20_3D_MATERIAL_FACTOR_BACK_R :	\
	 NV20_3D_MATERIAL_FACTOR_FRONT_R)
#define MATERIAL_FACTOR_A(side)				\
	((side) ? NV20_3D_MATERIAL_FACTOR_BACK_A :	\
	 NV20_3D_MATERIAL_FACTOR_FRONT_A)
#define MATERIAL_SHININESS(side)			\
	((side) ? NV20_3D_BACK_MATERIAL_SHININESS(0) :	\
	 NV20_3D_FRONT_MATERIAL_SHININESS(0))

void
nv20_emit_clip_plane(struct gl_context *ctx, int emit)
{
}

static inline unsigned
get_material_bitmask(unsigned m)
{
	unsigned ret = 0;

	if (m & MAT_BIT_FRONT_EMISSION)
		ret |= NV20_3D_COLOR_MATERIAL_FRONT_EMISSION_COL1;
	if (m & MAT_BIT_FRONT_AMBIENT)
		ret |= NV20_3D_COLOR_MATERIAL_FRONT_AMBIENT_COL1;
	if (m & MAT_BIT_FRONT_DIFFUSE)
		ret |= NV20_3D_COLOR_MATERIAL_FRONT_DIFFUSE_COL1;
	if (m & MAT_BIT_FRONT_SPECULAR)
		ret |= NV20_3D_COLOR_MATERIAL_FRONT_SPECULAR_COL1;

	if (m & MAT_BIT_BACK_EMISSION)
		ret |= NV20_3D_COLOR_MATERIAL_BACK_EMISSION_COL1;
	if (m & MAT_BIT_BACK_AMBIENT)
		ret |= NV20_3D_COLOR_MATERIAL_BACK_AMBIENT_COL1;
	if (m & MAT_BIT_BACK_DIFFUSE)
		ret |= NV20_3D_COLOR_MATERIAL_BACK_DIFFUSE_COL1;
	if (m & MAT_BIT_BACK_SPECULAR)
		ret |= NV20_3D_COLOR_MATERIAL_BACK_SPECULAR_COL1;

	return ret;
}

void
nv20_emit_color_material(struct gl_context *ctx, int emit)
{
	struct nouveau_pushbuf *push = context_push(ctx);
	unsigned mask = get_material_bitmask(ctx->Light._ColorMaterialBitmask);

	BEGIN_NV04(push, NV20_3D(COLOR_MATERIAL), 1);
	PUSH_DATA (push, ctx->Light.ColorMaterialEnabled ? mask : 0);
}

static unsigned
get_fog_mode_signed(unsigned mode)
{
	switch (mode) {
	case GL_LINEAR:
		return NV20_3D_FOG_MODE_LINEAR_SIGNED;
	case GL_EXP:
		return NV20_3D_FOG_MODE_EXP_SIGNED;
	case GL_EXP2:
		return NV20_3D_FOG_MODE_EXP2_SIGNED;
	default:
		assert(0);
	}
}

static unsigned
get_fog_mode_unsigned(unsigned mode)
{
	switch (mode) {
	case GL_LINEAR:
		return NV20_3D_FOG_MODE_LINEAR_UNSIGNED;
	case GL_EXP:
		return NV20_3D_FOG_MODE_EXP_UNSIGNED;
	case GL_EXP2:
		return NV20_3D_FOG_MODE_EXP2_UNSIGNED;
	default:
		assert(0);
	}
}

static unsigned
get_fog_source(unsigned source, unsigned distance_mode)
{
	switch (source) {
	case GL_FOG_COORDINATE_EXT:
		return NV20_3D_FOG_COORD_FOG;
	case GL_FRAGMENT_DEPTH_EXT:
		switch (distance_mode) {
		case GL_EYE_PLANE_ABSOLUTE_NV:
			return NV20_3D_FOG_COORD_DIST_ORTHOGONAL_ABS;
		case GL_EYE_PLANE:
			return NV20_3D_FOG_COORD_DIST_ORTHOGONAL;
		case GL_EYE_RADIAL_NV:
			return NV20_3D_FOG_COORD_DIST_RADIAL;
		default:
			assert(0);
		}
	default:
		assert(0);
	}
}

void
nv20_emit_fog(struct gl_context *ctx, int emit)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct nouveau_pushbuf *push = context_push(ctx);
	struct gl_fog_attrib *f = &ctx->Fog;
	unsigned source = nctx->fallback == HWTNL ?
		f->FogCoordinateSource : GL_FOG_COORDINATE_EXT;
	float k[3];

	nv10_get_fog_coeff(ctx, k);

	BEGIN_NV04(push, NV20_3D(FOG_MODE), 4);
	PUSH_DATA (push, ((source == GL_FRAGMENT_DEPTH_EXT &&
			 f->FogDistanceMode == GL_EYE_PLANE_ABSOLUTE_NV) ?
			get_fog_mode_unsigned(f->Mode) :
			get_fog_mode_signed(f->Mode)));
	PUSH_DATA (push, get_fog_source(source, f->FogDistanceMode));
	PUSH_DATAb(push, f->Enabled);
	PUSH_DATA (push, pack_rgba_f(MESA_FORMAT_R8G8B8A8_UNORM, f->Color));

	BEGIN_NV04(push, NV20_3D(FOG_COEFF(0)), 3);
	PUSH_DATAp(push, k, 3);
}

void
nv20_emit_light_model(struct gl_context *ctx, int emit)
{
	struct nouveau_pushbuf *push = context_push(ctx);
	struct gl_lightmodel *m = &ctx->Light.Model;

	BEGIN_NV04(push, NV20_3D(SEPARATE_SPECULAR_ENABLE), 1);
	PUSH_DATAb(push, m->ColorControl == GL_SEPARATE_SPECULAR_COLOR);

	BEGIN_NV04(push, NV20_3D(LIGHT_MODEL), 1);
	PUSH_DATA (push, ((m->LocalViewer ?
			 NV20_3D_LIGHT_MODEL_VIEWER_LOCAL :
			 NV20_3D_LIGHT_MODEL_VIEWER_NONLOCAL) |
			(_mesa_need_secondary_color(ctx) ?
			 NV20_3D_LIGHT_MODEL_SEPARATE_SPECULAR :
			 0)));

	BEGIN_NV04(push, NV20_3D(LIGHT_MODEL_TWO_SIDE_ENABLE), 1);
	PUSH_DATAb(push, ctx->Light.Model.TwoSide);
}

void
nv20_emit_light_source(struct gl_context *ctx, int emit)
{
	const int i = emit - NOUVEAU_STATE_LIGHT_SOURCE0;
	struct nouveau_pushbuf *push = context_push(ctx);
	struct gl_light *l = &ctx->Light.Light[i];

	if (l->_Flags & LIGHT_POSITIONAL) {
		BEGIN_NV04(push, NV20_3D(LIGHT_POSITION_X(i)), 3);
		PUSH_DATAp(push, l->_Position, 3);

		BEGIN_NV04(push, NV20_3D(LIGHT_ATTENUATION_CONSTANT(i)), 3);
		PUSH_DATAf(push, l->ConstantAttenuation);
		PUSH_DATAf(push, l->LinearAttenuation);
		PUSH_DATAf(push, l->QuadraticAttenuation);

	} else {
		BEGIN_NV04(push, NV20_3D(LIGHT_DIRECTION_X(i)), 3);
		PUSH_DATAp(push, l->_VP_inf_norm, 3);

		BEGIN_NV04(push, NV20_3D(LIGHT_HALF_VECTOR_X(i)), 3);
		PUSH_DATAp(push, l->_h_inf_norm, 3);
	}

	if (l->_Flags & LIGHT_SPOT) {
		float k[7];

		nv10_get_spot_coeff(l, k);

		BEGIN_NV04(push, NV20_3D(LIGHT_SPOT_CUTOFF(i, 0)), 7);
		PUSH_DATAp(push, k, 7);
	}
}

#define USE_COLOR_MATERIAL(attr, side)					\
	(ctx->Light.ColorMaterialEnabled &&				\
	 ctx->Light._ColorMaterialBitmask & (1 << MAT_ATTRIB_##attr(side)))

void
nv20_emit_material_ambient(struct gl_context *ctx, int emit)
{
	const int side = emit - NOUVEAU_STATE_MATERIAL_FRONT_AMBIENT;
	struct nouveau_pushbuf *push = context_push(ctx);
	float (*mat)[4] = ctx->Light.Material.Attrib;
	float c_scene[3], c_factor[3];
	struct gl_light *l;

	if (USE_COLOR_MATERIAL(AMBIENT, side)) {
		COPY_3V(c_scene, mat[MAT_ATTRIB_EMISSION(side)]);
		COPY_3V(c_factor, ctx->Light.Model.Ambient);

	} else if (USE_COLOR_MATERIAL(EMISSION, side)) {
		SCALE_3V(c_scene, mat[MAT_ATTRIB_AMBIENT(side)],
			 ctx->Light.Model.Ambient);
		ASSIGN_3V(c_factor, 1, 1, 1);

	} else {
		COPY_3V(c_scene, ctx->Light._BaseColor[side]);
		ZERO_3V(c_factor);
	}

	BEGIN_NV04(push, SUBC_3D(LIGHT_MODEL_AMBIENT_R(side)), 3);
	PUSH_DATAp(push, c_scene, 3);

	if (ctx->Light.ColorMaterialEnabled) {
		BEGIN_NV04(push, SUBC_3D(MATERIAL_FACTOR_R(side)), 3);
		PUSH_DATAp(push, c_factor, 3);
	}

	foreach(l, &ctx->Light.EnabledList) {
		const int i = l - ctx->Light.Light;
		float *c_light = (USE_COLOR_MATERIAL(AMBIENT, side) ?
				  l->Ambient :
				  l->_MatAmbient[side]);

		BEGIN_NV04(push, SUBC_3D(LIGHT_AMBIENT_R(side, i)), 3);
		PUSH_DATAp(push, c_light, 3);
	}
}

void
nv20_emit_material_diffuse(struct gl_context *ctx, int emit)
{
	const int side = emit - NOUVEAU_STATE_MATERIAL_FRONT_DIFFUSE;
	struct nouveau_pushbuf *push = context_push(ctx);
	GLfloat (*mat)[4] = ctx->Light.Material.Attrib;
	struct gl_light *l;

	BEGIN_NV04(push, SUBC_3D(MATERIAL_FACTOR_A(side)), 1);
	PUSH_DATAf(push, mat[MAT_ATTRIB_DIFFUSE(side)][3]);

	foreach(l, &ctx->Light.EnabledList) {
		const int i = l - ctx->Light.Light;
		float *c_light = (USE_COLOR_MATERIAL(DIFFUSE, side) ?
				  l->Diffuse :
				  l->_MatDiffuse[side]);

		BEGIN_NV04(push, SUBC_3D(LIGHT_DIFFUSE_R(side, i)), 3);
		PUSH_DATAp(push, c_light, 3);
	}
}

void
nv20_emit_material_specular(struct gl_context *ctx, int emit)
{
	const int side = emit - NOUVEAU_STATE_MATERIAL_FRONT_SPECULAR;
	struct nouveau_pushbuf *push = context_push(ctx);
	struct gl_light *l;

	foreach(l, &ctx->Light.EnabledList) {
		const int i = l - ctx->Light.Light;
		float *c_light = (USE_COLOR_MATERIAL(SPECULAR, side) ?
				  l->Specular :
				  l->_MatSpecular[side]);

		BEGIN_NV04(push, SUBC_3D(LIGHT_SPECULAR_R(side, i)), 3);
		PUSH_DATAp(push, c_light, 3);
	}
}

void
nv20_emit_material_shininess(struct gl_context *ctx, int emit)
{
	const int side = emit - NOUVEAU_STATE_MATERIAL_FRONT_SHININESS;
	struct nouveau_pushbuf *push = context_push(ctx);
	float (*mat)[4] = ctx->Light.Material.Attrib;
	float k[6];

	nv10_get_shininess_coeff(
		CLAMP(mat[MAT_ATTRIB_SHININESS(side)][0], 0, 1024),
		k);

	BEGIN_NV04(push, SUBC_3D(MATERIAL_SHININESS(side)), 6);
	PUSH_DATAp(push, k, 6);
}

void
nv20_emit_modelview(struct gl_context *ctx, int emit)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct nouveau_pushbuf *push = context_push(ctx);
	GLmatrix *m = ctx->ModelviewMatrixStack.Top;

	if (nctx->fallback != HWTNL)
		return;

	if (ctx->Light._NeedEyeCoords || ctx->Fog.Enabled ||
	    (ctx->Texture._GenFlags & TEXGEN_NEED_EYE_COORD)) {
		BEGIN_NV04(push, NV20_3D(MODELVIEW_MATRIX(0, 0)), 16);
		PUSH_DATAm(push, m->m);
	}

	if (ctx->Light.Enabled ||
	    (ctx->Texture._GenFlags & TEXGEN_NEED_EYE_COORD)) {
		int i, j;

		BEGIN_NV04(push, NV20_3D(INVERSE_MODELVIEW_MATRIX(0, 0)), 12);
		for (i = 0; i < 3; i++)
			for (j = 0; j < 4; j++)
				PUSH_DATAf(push, m->inv[4*i + j]);
	}
}

void
nv20_emit_projection(struct gl_context *ctx, int emit)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct nouveau_pushbuf *push = context_push(ctx);
	GLmatrix m;

	_math_matrix_ctr(&m);
	get_viewport_scale(ctx, m.m);

	if (nctx->fallback == HWTNL)
		_math_matrix_mul_matrix(&m, &m, &ctx->_ModelProjectMatrix);

	BEGIN_NV04(push, NV20_3D(PROJECTION_MATRIX(0)), 16);
	PUSH_DATAm(push, m.m);

	_math_matrix_dtr(&m);
}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@d169 1
a169 1
	PUSH_DATA (push, pack_rgba_f(MESA_FORMAT_RGBA8888_REV, f->Color));
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d91 2
a92 3
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *kelvin = context_eng3d(ctx);
	unsigned mask = get_material_bitmask(ctx->Light.ColorMaterialBitmask);
d94 2
a95 2
	BEGIN_RING(chan, kelvin, NV20_3D_COLOR_MATERIAL, 1);
	OUT_RING(chan, ctx->Light.ColorMaterialEnabled ? mask : 0);
d129 1
a129 1
get_fog_source(unsigned source)
d135 10
a144 1
		return NV20_3D_FOG_COORD_DIST_ORTHOGONAL_ABS;
d154 1
a154 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *kelvin = context_eng3d(ctx);
d162 8
a169 7
	BEGIN_RING(chan, kelvin, NV20_3D_FOG_MODE, 4);
	OUT_RING(chan, (source == GL_FOG_COORDINATE_EXT ?
			get_fog_mode_signed(f->Mode) :
			get_fog_mode_unsigned(f->Mode)));
	OUT_RING(chan, get_fog_source(source));
	OUT_RINGb(chan, f->Enabled);
	OUT_RING(chan, pack_rgba_f(MESA_FORMAT_RGBA8888_REV, f->Color));
d171 2
a172 2
	BEGIN_RING(chan, kelvin, NV20_3D_FOG_COEFF(0), 3);
	OUT_RINGp(chan, k, 3);
d178 1
a178 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *kelvin = context_eng3d(ctx);
d181 2
a182 2
	BEGIN_RING(chan, kelvin, NV20_3D_SEPARATE_SPECULAR_ENABLE, 1);
	OUT_RINGb(chan, m->ColorControl == GL_SEPARATE_SPECULAR_COLOR);
d184 2
a185 2
	BEGIN_RING(chan, kelvin, NV20_3D_LIGHT_MODEL, 1);
	OUT_RING(chan, ((m->LocalViewer ?
d192 2
a193 2
	BEGIN_RING(chan, kelvin, NV20_3D_LIGHT_MODEL_TWO_SIDE_ENABLE, 1);
	OUT_RINGb(chan, ctx->Light.Model.TwoSide);
d200 1
a200 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *kelvin = context_eng3d(ctx);
d204 2
a205 2
		BEGIN_RING(chan, kelvin, NV20_3D_LIGHT_POSITION_X(i), 3);
		OUT_RINGp(chan, l->_Position, 3);
d207 4
a210 4
		BEGIN_RING(chan, kelvin, NV20_3D_LIGHT_ATTENUATION_CONSTANT(i), 3);
		OUT_RINGf(chan, l->ConstantAttenuation);
		OUT_RINGf(chan, l->LinearAttenuation);
		OUT_RINGf(chan, l->QuadraticAttenuation);
d213 2
a214 2
		BEGIN_RING(chan, kelvin, NV20_3D_LIGHT_DIRECTION_X(i), 3);
		OUT_RINGp(chan, l->_VP_inf_norm, 3);
d216 2
a217 2
		BEGIN_RING(chan, kelvin, NV20_3D_LIGHT_HALF_VECTOR_X(i), 3);
		OUT_RINGp(chan, l->_h_inf_norm, 3);
d225 2
a226 2
		BEGIN_RING(chan, kelvin, NV20_3D_LIGHT_SPOT_CUTOFF(i, 0), 7);
		OUT_RINGp(chan, k, 7);
d232 1
a232 1
	 ctx->Light.ColorMaterialBitmask & (1 << MAT_ATTRIB_##attr(side)))
d238 1
a238 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *kelvin = context_eng3d(ctx);
d257 2
a258 2
	BEGIN_RING(chan, kelvin, LIGHT_MODEL_AMBIENT_R(side), 3);
	OUT_RINGp(chan, c_scene, 3);
d261 2
a262 2
		BEGIN_RING(chan, kelvin, MATERIAL_FACTOR_R(side), 3);
		OUT_RINGp(chan, c_factor, 3);
d271 2
a272 2
		BEGIN_RING(chan, kelvin, LIGHT_AMBIENT_R(side, i), 3);
		OUT_RINGp(chan, c_light, 3);
d280 1
a280 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *kelvin = context_eng3d(ctx);
d284 2
a285 2
	BEGIN_RING(chan, kelvin, MATERIAL_FACTOR_A(side), 1);
	OUT_RINGf(chan, mat[MAT_ATTRIB_DIFFUSE(side)][3]);
d293 2
a294 2
		BEGIN_RING(chan, kelvin, LIGHT_DIFFUSE_R(side, i), 3);
		OUT_RINGp(chan, c_light, 3);
d302 1
a302 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *kelvin = context_eng3d(ctx);
d311 2
a312 2
		BEGIN_RING(chan, kelvin, LIGHT_SPECULAR_R(side, i), 3);
		OUT_RINGp(chan, c_light, 3);
d320 1
a320 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *kelvin = context_eng3d(ctx);
d328 2
a329 2
	BEGIN_RING(chan, kelvin, MATERIAL_SHININESS(side), 6);
	OUT_RINGp(chan, k, 6);
d336 1
a336 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *kelvin = context_eng3d(ctx);
d344 2
a345 2
		BEGIN_RING(chan, kelvin, NV20_3D_MODELVIEW_MATRIX(0, 0), 16);
		OUT_RINGm(chan, m->m);
d352 1
a352 2
		BEGIN_RING(chan, kelvin,
			   NV20_3D_INVERSE_MODELVIEW_MATRIX(0, 0), 12);
d355 1
a355 1
				OUT_RINGf(chan, m->inv[4*i + j]);
d363 1
a363 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *kelvin = context_eng3d(ctx);
d372 2
a373 2
	BEGIN_RING(chan, kelvin, NV20_3D_PROJECTION_MATRIX(0), 16);
	OUT_RINGm(chan, m.m);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d181 1
a181 1
			(NEED_SECONDARY_COLOR(ctx) ?
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d31 1
a31 1
#include "nouveau_class.h"
d35 22
d58 1
a58 1
nv20_emit_clip_plane(GLcontext *ctx, int emit)
d68 1
a68 1
		ret |= NV20TCL_COLOR_MATERIAL_FRONT_EMISSION_COL1;
d70 1
a70 1
		ret |= NV20TCL_COLOR_MATERIAL_FRONT_AMBIENT_COL1;
d72 1
a72 1
		ret |= NV20TCL_COLOR_MATERIAL_FRONT_DIFFUSE_COL1;
d74 1
a74 1
		ret |= NV20TCL_COLOR_MATERIAL_FRONT_SPECULAR_COL1;
d77 1
a77 1
		ret |= NV20TCL_COLOR_MATERIAL_BACK_EMISSION_COL1;
d79 1
a79 1
		ret |= NV20TCL_COLOR_MATERIAL_BACK_AMBIENT_COL1;
d81 1
a81 1
		ret |= NV20TCL_COLOR_MATERIAL_BACK_DIFFUSE_COL1;
d83 1
a83 1
		ret |= NV20TCL_COLOR_MATERIAL_BACK_SPECULAR_COL1;
d89 1
a89 1
nv20_emit_color_material(GLcontext *ctx, int emit)
d95 1
a95 1
	BEGIN_RING(chan, kelvin, NV20TCL_COLOR_MATERIAL, 1);
d104 1
a104 1
		return NV20TCL_FOG_MODE_LINEAR_SIGNED;
d106 1
a106 1
		return NV20TCL_FOG_MODE_EXP_SIGNED;
d108 1
a108 1
		return NV20TCL_FOG_MODE_EXP2_SIGNED;
d119 1
a119 1
		return NV20TCL_FOG_MODE_LINEAR_UNSIGNED;
d121 1
a121 1
		return NV20TCL_FOG_MODE_EXP_UNSIGNED;
d123 1
a123 1
		return NV20TCL_FOG_MODE_EXP2_UNSIGNED;
d134 1
a134 1
		return NV20TCL_FOG_COORD_FOG;
d136 1
a136 1
		return NV20TCL_FOG_COORD_DIST_ORTHOGONAL_ABS;
d143 1
a143 1
nv20_emit_fog(GLcontext *ctx, int emit)
d155 1
a155 1
	BEGIN_RING(chan, kelvin, NV20TCL_FOG_MODE, 4);
d160 1
a160 1
	OUT_RING(chan, f->Enabled ? 1 : 0);
d163 2
a164 4
	BEGIN_RING(chan, kelvin, NV20TCL_FOG_EQUATION_CONSTANT, 3);
	OUT_RINGf(chan, k[0]);
	OUT_RINGf(chan, k[1]);
	OUT_RINGf(chan, k[2]);
d168 1
a168 1
nv20_emit_light_model(GLcontext *ctx, int emit)
d174 2
a175 2
	BEGIN_RING(chan, kelvin, NV20TCL_SEPARATE_SPECULAR_ENABLE, 1);
	OUT_RING(chan, m->ColorControl == GL_SEPARATE_SPECULAR_COLOR ? 1 : 0);
d177 1
a177 1
	BEGIN_RING(chan, kelvin, NV20TCL_LIGHT_MODEL, 1);
d179 4
a182 4
			 NV20TCL_LIGHT_MODEL_VIEWER_LOCAL :
			 NV20TCL_LIGHT_MODEL_VIEWER_NONLOCAL) |
			(m->ColorControl == GL_SEPARATE_SPECULAR_COLOR ?
			 NV20TCL_LIGHT_MODEL_SEPARATE_SPECULAR :
d185 2
a186 2
	BEGIN_RING(chan, kelvin, NV20TCL_LIGHT_MODEL_TWO_SIDE_ENABLE, 1);
	OUT_RING(chan, ctx->Light.Model.TwoSide ? 1 : 0);
d190 1
a190 1
nv20_emit_light_source(GLcontext *ctx, int emit)
d198 2
a199 4
		BEGIN_RING(chan, kelvin, NV20TCL_LIGHT_POSITION_X(i), 3);
		OUT_RINGf(chan, l->_Position[0]);
		OUT_RINGf(chan, l->_Position[1]);
		OUT_RINGf(chan, l->_Position[2]);
d201 1
a201 1
		BEGIN_RING(chan, kelvin, NV20TCL_LIGHT_ATTENUATION_CONSTANT(i), 3);
d207 5
a211 9
		BEGIN_RING(chan, kelvin, NV20TCL_LIGHT_DIRECTION_X(i), 3);
		OUT_RINGf(chan, l->_VP_inf_norm[0]);
		OUT_RINGf(chan, l->_VP_inf_norm[1]);
		OUT_RINGf(chan, l->_VP_inf_norm[2]);

		BEGIN_RING(chan, kelvin, NV20TCL_LIGHT_HALF_VECTOR_X(i), 3);
		OUT_RINGf(chan, l->_h_inf_norm[0]);
		OUT_RINGf(chan, l->_h_inf_norm[1]);
		OUT_RINGf(chan, l->_h_inf_norm[2]);
d219 2
a220 8
		BEGIN_RING(chan, kelvin, NV20TCL_LIGHT_SPOT_CUTOFF_A(i), 7);
		OUT_RINGf(chan, k[0]);
		OUT_RINGf(chan, k[1]);
		OUT_RINGf(chan, k[2]);
		OUT_RINGf(chan, k[3]);
		OUT_RINGf(chan, k[4]);
		OUT_RINGf(chan, k[5]);
		OUT_RINGf(chan, k[6]);
d229 1
a229 1
nv20_emit_material_ambient(GLcontext *ctx, int emit)
a234 4
	uint32_t m_scene[] = { NV20TCL_LIGHT_MODEL_FRONT_AMBIENT_R,
			       NV20TCL_LIGHT_MODEL_BACK_AMBIENT_R };
	uint32_t m_factor[] = { NV20TCL_MATERIAL_FACTOR_FRONT_R,
			      NV20TCL_MATERIAL_FACTOR_BACK_R };
d252 2
a253 4
	BEGIN_RING(chan, kelvin, m_scene[side], 3);
	OUT_RINGf(chan, c_scene[0]);
	OUT_RINGf(chan, c_scene[1]);
	OUT_RINGf(chan, c_scene[2]);
d256 2
a257 4
		BEGIN_RING(chan, kelvin, m_factor[side], 3);
		OUT_RINGf(chan, c_factor[0]);
		OUT_RINGf(chan, c_factor[1]);
		OUT_RINGf(chan, c_factor[2]);
a261 2
		uint32_t m_light[] = { NV20TCL_LIGHT_FRONT_AMBIENT_R(i),
				      NV20TCL_LIGHT_BACK_AMBIENT_R(i) };
d266 2
a267 4
		BEGIN_RING(chan, kelvin, m_light[side], 3);
		OUT_RINGf(chan, c_light[0]);
		OUT_RINGf(chan, c_light[1]);
		OUT_RINGf(chan, c_light[2]);
d272 1
a272 1
nv20_emit_material_diffuse(GLcontext *ctx, int emit)
a277 2
	uint32_t m_factor[] = { NV20TCL_MATERIAL_FACTOR_FRONT_A,
				NV20TCL_MATERIAL_FACTOR_BACK_A };
d280 1
a280 1
	BEGIN_RING(chan, kelvin, m_factor[side], 1);
a284 2
		uint32_t m_light[] = { NV20TCL_LIGHT_FRONT_DIFFUSE_R(i),
				       NV20TCL_LIGHT_BACK_DIFFUSE_R(i) };
d289 2
a290 4
		BEGIN_RING(chan, kelvin, m_light[side], 3);
		OUT_RINGf(chan, c_light[0]);
		OUT_RINGf(chan, c_light[1]);
		OUT_RINGf(chan, c_light[2]);
d295 1
a295 1
nv20_emit_material_specular(GLcontext *ctx, int emit)
a303 2
		uint32_t m_light[] = { NV20TCL_LIGHT_FRONT_SPECULAR_R(i),
				       NV20TCL_LIGHT_BACK_SPECULAR_R(i) };
d308 2
a309 4
		BEGIN_RING(chan, kelvin, m_light[side], 3);
		OUT_RINGf(chan, c_light[0]);
		OUT_RINGf(chan, c_light[1]);
		OUT_RINGf(chan, c_light[2]);
d314 1
a314 1
nv20_emit_material_shininess(GLcontext *ctx, int emit)
a319 2
	uint32_t mthd[] = { NV20TCL_FRONT_MATERIAL_SHININESS(0),
			    NV20TCL_BACK_MATERIAL_SHININESS(0) };
d326 2
a327 7
	BEGIN_RING(chan, kelvin, mthd[side], 6);
	OUT_RINGf(chan, k[0]);
	OUT_RINGf(chan, k[1]);
	OUT_RINGf(chan, k[2]);
	OUT_RINGf(chan, k[3]);
	OUT_RINGf(chan, k[4]);
	OUT_RINGf(chan, k[5]);
d331 1
a331 1
nv20_emit_modelview(GLcontext *ctx, int emit)
d341 3
a343 2
	if (ctx->Light._NeedEyeCoords || ctx->Fog.Enabled) {
		BEGIN_RING(chan, kelvin, NV20TCL_MODELVIEW0_MATRIX(0), 16);
d347 2
a348 1
	if (ctx->Light.Enabled) {
d352 1
a352 1
			   NV20TCL_INVERSE_MODELVIEW0_MATRIX(0), 12);
d360 1
a360 1
nv20_emit_projection(GLcontext *ctx, int emit)
d373 1
a373 1
	BEGIN_RING(chan, kelvin, NV20TCL_PROJECTION_MATRIX(0), 16);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d31 1
a31 1
#include "nv20_3d.xml.h"
a34 22
#define LIGHT_MODEL_AMBIENT_R(side)			\
	((side) ? NV20_3D_LIGHT_MODEL_BACK_AMBIENT_R :	\
	 NV20_3D_LIGHT_MODEL_FRONT_AMBIENT_R)
#define LIGHT_AMBIENT_R(side, i)			\
	((side) ? NV20_3D_LIGHT_BACK_AMBIENT_R(i) :	\
	 NV20_3D_LIGHT_FRONT_AMBIENT_R(i))
#define LIGHT_DIFFUSE_R(side, i)			\
	((side) ? NV20_3D_LIGHT_BACK_DIFFUSE_R(i) :	\
	 NV20_3D_LIGHT_FRONT_DIFFUSE_R(i))
#define LIGHT_SPECULAR_R(side, i)			\
	((side) ? NV20_3D_LIGHT_BACK_SPECULAR_R(i) :	\
	 NV20_3D_LIGHT_FRONT_SPECULAR_R(i))
#define MATERIAL_FACTOR_R(side)				\
	((side) ? NV20_3D_MATERIAL_FACTOR_BACK_R :	\
	 NV20_3D_MATERIAL_FACTOR_FRONT_R)
#define MATERIAL_FACTOR_A(side)				\
	((side) ? NV20_3D_MATERIAL_FACTOR_BACK_A :	\
	 NV20_3D_MATERIAL_FACTOR_FRONT_A)
#define MATERIAL_SHININESS(side)			\
	((side) ? NV20_3D_BACK_MATERIAL_SHININESS(0) :	\
	 NV20_3D_FRONT_MATERIAL_SHININESS(0))

d36 1
a36 1
nv20_emit_clip_plane(struct gl_context *ctx, int emit)
d46 1
a46 1
		ret |= NV20_3D_COLOR_MATERIAL_FRONT_EMISSION_COL1;
d48 1
a48 1
		ret |= NV20_3D_COLOR_MATERIAL_FRONT_AMBIENT_COL1;
d50 1
a50 1
		ret |= NV20_3D_COLOR_MATERIAL_FRONT_DIFFUSE_COL1;
d52 1
a52 1
		ret |= NV20_3D_COLOR_MATERIAL_FRONT_SPECULAR_COL1;
d55 1
a55 1
		ret |= NV20_3D_COLOR_MATERIAL_BACK_EMISSION_COL1;
d57 1
a57 1
		ret |= NV20_3D_COLOR_MATERIAL_BACK_AMBIENT_COL1;
d59 1
a59 1
		ret |= NV20_3D_COLOR_MATERIAL_BACK_DIFFUSE_COL1;
d61 1
a61 1
		ret |= NV20_3D_COLOR_MATERIAL_BACK_SPECULAR_COL1;
d67 1
a67 1
nv20_emit_color_material(struct gl_context *ctx, int emit)
d73 1
a73 1
	BEGIN_RING(chan, kelvin, NV20_3D_COLOR_MATERIAL, 1);
d82 1
a82 1
		return NV20_3D_FOG_MODE_LINEAR_SIGNED;
d84 1
a84 1
		return NV20_3D_FOG_MODE_EXP_SIGNED;
d86 1
a86 1
		return NV20_3D_FOG_MODE_EXP2_SIGNED;
d97 1
a97 1
		return NV20_3D_FOG_MODE_LINEAR_UNSIGNED;
d99 1
a99 1
		return NV20_3D_FOG_MODE_EXP_UNSIGNED;
d101 1
a101 1
		return NV20_3D_FOG_MODE_EXP2_UNSIGNED;
d112 1
a112 1
		return NV20_3D_FOG_COORD_FOG;
d114 1
a114 1
		return NV20_3D_FOG_COORD_DIST_ORTHOGONAL_ABS;
d121 1
a121 1
nv20_emit_fog(struct gl_context *ctx, int emit)
d133 1
a133 1
	BEGIN_RING(chan, kelvin, NV20_3D_FOG_MODE, 4);
d138 1
a138 1
	OUT_RINGb(chan, f->Enabled);
d141 4
a144 2
	BEGIN_RING(chan, kelvin, NV20_3D_FOG_COEFF(0), 3);
	OUT_RINGp(chan, k, 3);
d148 1
a148 1
nv20_emit_light_model(struct gl_context *ctx, int emit)
d154 2
a155 2
	BEGIN_RING(chan, kelvin, NV20_3D_SEPARATE_SPECULAR_ENABLE, 1);
	OUT_RINGb(chan, m->ColorControl == GL_SEPARATE_SPECULAR_COLOR);
d157 1
a157 1
	BEGIN_RING(chan, kelvin, NV20_3D_LIGHT_MODEL, 1);
d159 4
a162 4
			 NV20_3D_LIGHT_MODEL_VIEWER_LOCAL :
			 NV20_3D_LIGHT_MODEL_VIEWER_NONLOCAL) |
			(NEED_SECONDARY_COLOR(ctx) ?
			 NV20_3D_LIGHT_MODEL_SEPARATE_SPECULAR :
d165 2
a166 2
	BEGIN_RING(chan, kelvin, NV20_3D_LIGHT_MODEL_TWO_SIDE_ENABLE, 1);
	OUT_RINGb(chan, ctx->Light.Model.TwoSide);
d170 1
a170 1
nv20_emit_light_source(struct gl_context *ctx, int emit)
d178 4
a181 2
		BEGIN_RING(chan, kelvin, NV20_3D_LIGHT_POSITION_X(i), 3);
		OUT_RINGp(chan, l->_Position, 3);
d183 1
a183 1
		BEGIN_RING(chan, kelvin, NV20_3D_LIGHT_ATTENUATION_CONSTANT(i), 3);
d189 9
a197 5
		BEGIN_RING(chan, kelvin, NV20_3D_LIGHT_DIRECTION_X(i), 3);
		OUT_RINGp(chan, l->_VP_inf_norm, 3);

		BEGIN_RING(chan, kelvin, NV20_3D_LIGHT_HALF_VECTOR_X(i), 3);
		OUT_RINGp(chan, l->_h_inf_norm, 3);
d205 8
a212 2
		BEGIN_RING(chan, kelvin, NV20_3D_LIGHT_SPOT_CUTOFF(i, 0), 7);
		OUT_RINGp(chan, k, 7);
d221 1
a221 1
nv20_emit_material_ambient(struct gl_context *ctx, int emit)
d227 4
d248 4
a251 2
	BEGIN_RING(chan, kelvin, LIGHT_MODEL_AMBIENT_R(side), 3);
	OUT_RINGp(chan, c_scene, 3);
d254 4
a257 2
		BEGIN_RING(chan, kelvin, MATERIAL_FACTOR_R(side), 3);
		OUT_RINGp(chan, c_factor, 3);
d262 2
d268 4
a271 2
		BEGIN_RING(chan, kelvin, LIGHT_AMBIENT_R(side, i), 3);
		OUT_RINGp(chan, c_light, 3);
d276 1
a276 1
nv20_emit_material_diffuse(struct gl_context *ctx, int emit)
d282 2
d286 1
a286 1
	BEGIN_RING(chan, kelvin, MATERIAL_FACTOR_A(side), 1);
d291 2
d297 4
a300 2
		BEGIN_RING(chan, kelvin, LIGHT_DIFFUSE_R(side, i), 3);
		OUT_RINGp(chan, c_light, 3);
d305 1
a305 1
nv20_emit_material_specular(struct gl_context *ctx, int emit)
d314 2
d320 4
a323 2
		BEGIN_RING(chan, kelvin, LIGHT_SPECULAR_R(side, i), 3);
		OUT_RINGp(chan, c_light, 3);
d328 1
a328 1
nv20_emit_material_shininess(struct gl_context *ctx, int emit)
d334 2
d342 7
a348 2
	BEGIN_RING(chan, kelvin, MATERIAL_SHININESS(side), 6);
	OUT_RINGp(chan, k, 6);
d352 1
a352 1
nv20_emit_modelview(struct gl_context *ctx, int emit)
d362 2
a363 3
	if (ctx->Light._NeedEyeCoords || ctx->Fog.Enabled ||
	    (ctx->Texture._GenFlags & TEXGEN_NEED_EYE_COORD)) {
		BEGIN_RING(chan, kelvin, NV20_3D_MODELVIEW_MATRIX(0, 0), 16);
d367 1
a367 2
	if (ctx->Light.Enabled ||
	    (ctx->Texture._GenFlags & TEXGEN_NEED_EYE_COORD)) {
d371 1
a371 1
			   NV20_3D_INVERSE_MODELVIEW_MATRIX(0, 0), 12);
d379 1
a379 1
nv20_emit_projection(struct gl_context *ctx, int emit)
d392 1
a392 1
	BEGIN_RING(chan, kelvin, NV20_3D_PROJECTION_MATRIX(0), 16);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d91 3
a93 2
	struct nouveau_pushbuf *push = context_push(ctx);
	unsigned mask = get_material_bitmask(ctx->Light._ColorMaterialBitmask);
d95 2
a96 2
	BEGIN_NV04(push, NV20_3D(COLOR_MATERIAL), 1);
	PUSH_DATA (push, ctx->Light.ColorMaterialEnabled ? mask : 0);
d130 1
a130 1
get_fog_source(unsigned source, unsigned distance_mode)
d136 1
a136 10
		switch (distance_mode) {
		case GL_EYE_PLANE_ABSOLUTE_NV:
			return NV20_3D_FOG_COORD_DIST_ORTHOGONAL_ABS;
		case GL_EYE_PLANE:
			return NV20_3D_FOG_COORD_DIST_ORTHOGONAL;
		case GL_EYE_RADIAL_NV:
			return NV20_3D_FOG_COORD_DIST_RADIAL;
		default:
			assert(0);
		}
d146 2
a147 1
	struct nouveau_pushbuf *push = context_push(ctx);
d155 7
a161 8
	BEGIN_NV04(push, NV20_3D(FOG_MODE), 4);
	PUSH_DATA (push, ((source == GL_FRAGMENT_DEPTH_EXT &&
			 f->FogDistanceMode == GL_EYE_PLANE_ABSOLUTE_NV) ?
			get_fog_mode_unsigned(f->Mode) :
			get_fog_mode_signed(f->Mode)));
	PUSH_DATA (push, get_fog_source(source, f->FogDistanceMode));
	PUSH_DATAb(push, f->Enabled);
	PUSH_DATA (push, pack_rgba_f(MESA_FORMAT_RGBA8888_REV, f->Color));
d163 2
a164 2
	BEGIN_NV04(push, NV20_3D(FOG_COEFF(0)), 3);
	PUSH_DATAp(push, k, 3);
d170 2
a171 1
	struct nouveau_pushbuf *push = context_push(ctx);
d174 2
a175 2
	BEGIN_NV04(push, NV20_3D(SEPARATE_SPECULAR_ENABLE), 1);
	PUSH_DATAb(push, m->ColorControl == GL_SEPARATE_SPECULAR_COLOR);
d177 2
a178 2
	BEGIN_NV04(push, NV20_3D(LIGHT_MODEL), 1);
	PUSH_DATA (push, ((m->LocalViewer ?
d181 1
a181 1
			(_mesa_need_secondary_color(ctx) ?
d185 2
a186 2
	BEGIN_NV04(push, NV20_3D(LIGHT_MODEL_TWO_SIDE_ENABLE), 1);
	PUSH_DATAb(push, ctx->Light.Model.TwoSide);
d193 2
a194 1
	struct nouveau_pushbuf *push = context_push(ctx);
d198 2
a199 2
		BEGIN_NV04(push, NV20_3D(LIGHT_POSITION_X(i)), 3);
		PUSH_DATAp(push, l->_Position, 3);
d201 4
a204 4
		BEGIN_NV04(push, NV20_3D(LIGHT_ATTENUATION_CONSTANT(i)), 3);
		PUSH_DATAf(push, l->ConstantAttenuation);
		PUSH_DATAf(push, l->LinearAttenuation);
		PUSH_DATAf(push, l->QuadraticAttenuation);
d207 2
a208 2
		BEGIN_NV04(push, NV20_3D(LIGHT_DIRECTION_X(i)), 3);
		PUSH_DATAp(push, l->_VP_inf_norm, 3);
d210 2
a211 2
		BEGIN_NV04(push, NV20_3D(LIGHT_HALF_VECTOR_X(i)), 3);
		PUSH_DATAp(push, l->_h_inf_norm, 3);
d219 2
a220 2
		BEGIN_NV04(push, NV20_3D(LIGHT_SPOT_CUTOFF(i, 0)), 7);
		PUSH_DATAp(push, k, 7);
d226 1
a226 1
	 ctx->Light._ColorMaterialBitmask & (1 << MAT_ATTRIB_##attr(side)))
d232 2
a233 1
	struct nouveau_pushbuf *push = context_push(ctx);
d252 2
a253 2
	BEGIN_NV04(push, SUBC_3D(LIGHT_MODEL_AMBIENT_R(side)), 3);
	PUSH_DATAp(push, c_scene, 3);
d256 2
a257 2
		BEGIN_NV04(push, SUBC_3D(MATERIAL_FACTOR_R(side)), 3);
		PUSH_DATAp(push, c_factor, 3);
d266 2
a267 2
		BEGIN_NV04(push, SUBC_3D(LIGHT_AMBIENT_R(side, i)), 3);
		PUSH_DATAp(push, c_light, 3);
d275 2
a276 1
	struct nouveau_pushbuf *push = context_push(ctx);
d280 2
a281 2
	BEGIN_NV04(push, SUBC_3D(MATERIAL_FACTOR_A(side)), 1);
	PUSH_DATAf(push, mat[MAT_ATTRIB_DIFFUSE(side)][3]);
d289 2
a290 2
		BEGIN_NV04(push, SUBC_3D(LIGHT_DIFFUSE_R(side, i)), 3);
		PUSH_DATAp(push, c_light, 3);
d298 2
a299 1
	struct nouveau_pushbuf *push = context_push(ctx);
d308 2
a309 2
		BEGIN_NV04(push, SUBC_3D(LIGHT_SPECULAR_R(side, i)), 3);
		PUSH_DATAp(push, c_light, 3);
d317 2
a318 1
	struct nouveau_pushbuf *push = context_push(ctx);
d326 2
a327 2
	BEGIN_NV04(push, SUBC_3D(MATERIAL_SHININESS(side)), 6);
	PUSH_DATAp(push, k, 6);
d334 2
a335 1
	struct nouveau_pushbuf *push = context_push(ctx);
d343 2
a344 2
		BEGIN_NV04(push, NV20_3D(MODELVIEW_MATRIX(0, 0)), 16);
		PUSH_DATAm(push, m->m);
d351 2
a352 1
		BEGIN_NV04(push, NV20_3D(INVERSE_MODELVIEW_MATRIX(0, 0)), 12);
d355 1
a355 1
				PUSH_DATAf(push, m->inv[4*i + j]);
d363 2
a364 1
	struct nouveau_pushbuf *push = context_push(ctx);
d373 2
a374 2
	BEGIN_NV04(push, NV20_3D(PROJECTION_MATRIX(0)), 16);
	PUSH_DATAm(push, m.m);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d169 1
a169 1
	PUSH_DATA (push, pack_rgba_f(MESA_FORMAT_R8G8B8A8_UNORM, f->Color));
@


