head	1.12;
access;
symbols
	OPENBSD_5_4:1.11.0.4
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.10.0.4
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.8.0.6
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.12
date	2013.09.05.14.04.34;	author jsg;	state dead;
branches;
next	1.11;

1.11
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.10;

1.10
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.10.01.16.13.08;	author robert;	state Exp;
branches;
next	1.8;

1.8
date	2010.07.24.19.03.21;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.11.21.13.05.59;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.10.15.56.13;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.10.15.27.14;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.10.15.12.43;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.38;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Merge Mesa 9.2.0
@
text
@/**************************************************************************
 * 
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include <errno.h>
#include "main/glheader.h"
#include "main/context.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
#include "main/hash.h"
#include "main/fbobject.h"
#include "main/mfeatures.h"

#include "utils.h"
#include "xmlpool.h"

PUBLIC const char __driConfigOptions[] =
   DRI_CONF_BEGIN
   DRI_CONF_SECTION_PERFORMANCE
      DRI_CONF_VBLANK_MODE(DRI_CONF_VBLANK_ALWAYS_SYNC)
      /* Options correspond to DRI_CONF_BO_REUSE_DISABLED,
       * DRI_CONF_BO_REUSE_ALL
       */
      DRI_CONF_OPT_BEGIN_V(bo_reuse, enum, 1, "0:1")
	 DRI_CONF_DESC_BEGIN(en, "Buffer object reuse")
	    DRI_CONF_ENUM(0, "Disable buffer object reuse")
	    DRI_CONF_ENUM(1, "Enable reuse of all sizes of buffer objects")
	 DRI_CONF_DESC_END
      DRI_CONF_OPT_END

      DRI_CONF_OPT_BEGIN(texture_tiling, bool, true)
	 DRI_CONF_DESC(en, "Enable texture tiling")
      DRI_CONF_OPT_END

      DRI_CONF_OPT_BEGIN(early_z, bool, false)
	 DRI_CONF_DESC(en, "Enable early Z in classic mode (unstable, 945-only).")
      DRI_CONF_OPT_END

      DRI_CONF_OPT_BEGIN(fragment_shader, bool, true)
	 DRI_CONF_DESC(en, "Enable limited ARB_fragment_shader support on 915/945.")
      DRI_CONF_OPT_END

   DRI_CONF_SECTION_END
   DRI_CONF_SECTION_QUALITY
      DRI_CONF_FORCE_S3TC_ENABLE(false)
      DRI_CONF_ALLOW_LARGE_TEXTURES(2)
   DRI_CONF_SECTION_END
   DRI_CONF_SECTION_DEBUG
     DRI_CONF_NO_RAST(false)
     DRI_CONF_ALWAYS_FLUSH_BATCH(false)
     DRI_CONF_ALWAYS_FLUSH_CACHE(false)

      DRI_CONF_OPT_BEGIN(stub_occlusion_query, bool, false)
	 DRI_CONF_DESC(en, "Enable stub ARB_occlusion_query support on 915/945.")
      DRI_CONF_OPT_END
   DRI_CONF_SECTION_END
DRI_CONF_END;

const GLuint __driNConfigOptions = 11;

#include "intel_batchbuffer.h"
#include "intel_buffers.h"
#include "intel_bufmgr.h"
#include "intel_chipset.h"
#include "intel_fbo.h"
#include "intel_screen.h"
#include "intel_tex.h"
#include "intel_regions.h"

#include "i915_drm.h"

#ifdef USE_NEW_INTERFACE
static PFNGLXCREATECONTEXTMODES create_context_modes = NULL;
#endif /*USE_NEW_INTERFACE */

static const __DRItexBufferExtension intelTexBufferExtension = {
    { __DRI_TEX_BUFFER, __DRI_TEX_BUFFER_VERSION },
   intelSetTexBuffer,
   intelSetTexBuffer2,
};

static void
intelDRI2Flush(__DRIdrawable *drawable)
{
   GET_CURRENT_CONTEXT(ctx);
   struct intel_context *intel = intel_context(ctx);

   if (intel != NULL) {
      if (intel->gen < 4)
	 INTEL_FIREVERTICES(intel);

      intel->need_throttle = GL_TRUE;

      if (intel->batch.used)
	 intel_batchbuffer_flush(intel);
   }
}

static const struct __DRI2flushExtensionRec intelFlushExtension = {
    { __DRI2_FLUSH, __DRI2_FLUSH_VERSION },
    intelDRI2Flush,
    dri2InvalidateDrawable,
};

static __DRIimage *
intel_create_image_from_name(__DRIscreen *screen,
			     int width, int height, int format,
			     int name, int pitch, void *loaderPrivate)
{
    struct intel_screen *intelScreen = screen->private;
    __DRIimage *image;
    int cpp;

    image = CALLOC(sizeof *image);
    if (image == NULL)
	return NULL;

    switch (format) {
    case __DRI_IMAGE_FORMAT_RGB565:
       image->format = MESA_FORMAT_RGB565;
       image->internal_format = GL_RGB;
       image->data_type = GL_UNSIGNED_BYTE;
       break;
    case __DRI_IMAGE_FORMAT_XRGB8888:
       image->format = MESA_FORMAT_XRGB8888;
       image->internal_format = GL_RGB;
       image->data_type = GL_UNSIGNED_BYTE;
       break;
    case __DRI_IMAGE_FORMAT_ARGB8888:
       image->format = MESA_FORMAT_ARGB8888;
       image->internal_format = GL_RGBA;
       image->data_type = GL_UNSIGNED_BYTE;
       break;
    default:
       free(image);
       return NULL;
    }

    image->data = loaderPrivate;
    cpp = _mesa_get_format_bytes(image->format);

    image->region = intel_region_alloc_for_handle(intelScreen,
						  cpp, width, height,
						  pitch, name, "image");
    if (image->region == NULL) {
       FREE(image);
       return NULL;
    }

    return image;	
}

static __DRIimage *
intel_create_image_from_renderbuffer(__DRIcontext *context,
				     int renderbuffer, void *loaderPrivate)
{
   __DRIimage *image;
   struct intel_context *intel = context->driverPrivate;
   struct gl_renderbuffer *rb;
   struct intel_renderbuffer *irb;

   rb = _mesa_lookup_renderbuffer(&intel->ctx, renderbuffer);
   if (!rb) {
      _mesa_error(&intel->ctx,
		  GL_INVALID_OPERATION, "glRenderbufferExternalMESA");
      return NULL;
   }

   irb = intel_renderbuffer(rb);
   image = CALLOC(sizeof *image);
   if (image == NULL)
      return NULL;

   image->internal_format = rb->InternalFormat;
   image->format = rb->Format;
   image->data_type = rb->DataType;
   image->data = loaderPrivate;
   intel_region_reference(&image->region, irb->region);

   return image;
}

static void
intel_destroy_image(__DRIimage *image)
{
    intel_region_release(&image->region);
    FREE(image);
}

static __DRIimage *
intel_create_image(__DRIscreen *screen,
		   int width, int height, int format,
		   unsigned int use,
		   void *loaderPrivate)
{
   __DRIimage *image;
   struct intel_screen *intelScreen = screen->private;
   uint32_t tiling;
   int cpp;

   tiling = I915_TILING_X;
   if (use & __DRI_IMAGE_USE_CURSOR) {
      if (width != 64 || height != 64)
	 return NULL;
      tiling = I915_TILING_NONE;
   }

   image = CALLOC(sizeof *image);
   if (image == NULL)
      return NULL;

   switch (format) {
   case __DRI_IMAGE_FORMAT_RGB565:
      image->format = MESA_FORMAT_RGB565;
      image->internal_format = GL_RGB;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   case __DRI_IMAGE_FORMAT_XRGB8888:
      image->format = MESA_FORMAT_XRGB8888;
      image->internal_format = GL_RGB;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   case __DRI_IMAGE_FORMAT_ARGB8888:
      image->format = MESA_FORMAT_ARGB8888;
      image->internal_format = GL_RGBA;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   default:
      free(image);
      return NULL;
   }

   image->data = loaderPrivate;
   cpp = _mesa_get_format_bytes(image->format);

   image->region =
      intel_region_alloc(intelScreen, tiling,
			 cpp, width, height, GL_TRUE);
   if (image->region == NULL) {
      FREE(image);
      return NULL;
   }
   
   return image;
}

static GLboolean
intel_query_image(__DRIimage *image, int attrib, int *value)
{
   switch (attrib) {
   case __DRI_IMAGE_ATTRIB_STRIDE:
      *value = image->region->pitch * image->region->cpp;
      return GL_TRUE;
   case __DRI_IMAGE_ATTRIB_HANDLE:
      *value = image->region->buffer->handle;
      return GL_TRUE;
   case __DRI_IMAGE_ATTRIB_NAME:
      return intel_region_flink(image->region, (uint32_t *) value);
   default:
      return GL_FALSE;
   }
}

static __DRIimage *
intel_dup_image(__DRIimage *orig_image, void *loaderPrivate)
{
   __DRIimage *image;

   image = CALLOC(sizeof *image);
   if (image == NULL)
      return NULL;

   image->region = NULL;
   intel_region_reference(&image->region, orig_image->region);
   if (image->region == NULL) {
      FREE(image);
      return NULL;
   }

   image->internal_format = orig_image->internal_format;
   image->format          = orig_image->format;
   image->data_type       = orig_image->data_type;
   image->data            = loaderPrivate;
   
   return image;
}

static struct __DRIimageExtensionRec intelImageExtension = {
    { __DRI_IMAGE, __DRI_IMAGE_VERSION },
    intel_create_image_from_name,
    intel_create_image_from_renderbuffer,
    intel_destroy_image,
    intel_create_image,
    intel_query_image,
    intel_dup_image
};

static const __DRIextension *intelScreenExtensions[] = {
    &driReadDrawableExtension,
    &intelTexBufferExtension.base,
    &intelFlushExtension.base,
    &intelImageExtension.base,
    &dri2ConfigQueryExtension.base,
    NULL
};

static GLboolean
intel_get_param(__DRIscreen *psp, int param, int *value)
{
   int ret;
   struct drm_i915_getparam gp;

   gp.param = param;
   gp.value = value;

   ret = drmCommandWriteRead(psp->fd, DRM_I915_GETPARAM, &gp, sizeof(gp));
   if (ret) {
      if (ret != -EINVAL)
	 _mesa_warning(NULL, "drm_i915_getparam: %d", ret);
      return GL_FALSE;
   }

   return GL_TRUE;
}

static GLboolean
intel_get_boolean(__DRIscreen *psp, int param)
{
   int value = 0;
   return intel_get_param(psp, param, &value) && value;
}

static void
nop_callback(GLuint key, void *data, void *userData)
{
}

static void
intelDestroyScreen(__DRIscreen * sPriv)
{
   struct intel_screen *intelScreen = sPriv->private;

   dri_bufmgr_destroy(intelScreen->bufmgr);
   driDestroyOptionInfo(&intelScreen->optionCache);

   /* Some regions may still have references to them at this point, so
    * flush the hash table to prevent _mesa_DeleteHashTable() from
    * complaining about the hash not being empty; */
   _mesa_HashDeleteAll(intelScreen->named_regions, nop_callback, NULL);
   _mesa_DeleteHashTable(intelScreen->named_regions);

   FREE(intelScreen);
   sPriv->private = NULL;
}


/**
 * This is called when we need to set up GL rendering to a new X window.
 */
static GLboolean
intelCreateBuffer(__DRIscreen * driScrnPriv,
                  __DRIdrawable * driDrawPriv,
                  const struct gl_config * mesaVis, GLboolean isPixmap)
{
   struct intel_renderbuffer *rb;
   struct intel_screen *screen = (struct intel_screen*) driScrnPriv->private;

   if (isPixmap) {
      return GL_FALSE;          /* not implemented */
   }
   else {
      gl_format rgbFormat;

      struct gl_framebuffer *fb = CALLOC_STRUCT(gl_framebuffer);

      if (!fb)
	 return GL_FALSE;

      _mesa_initialize_window_framebuffer(fb, mesaVis);

      if (mesaVis->redBits == 5)
	 rgbFormat = MESA_FORMAT_RGB565;
      else if (mesaVis->alphaBits == 0)
	 rgbFormat = MESA_FORMAT_XRGB8888;
      else
	 rgbFormat = MESA_FORMAT_ARGB8888;

      /* setup the hardware-based renderbuffers */
      rb = intel_create_renderbuffer(rgbFormat);
      _mesa_add_renderbuffer(fb, BUFFER_FRONT_LEFT, &rb->Base);

      if (mesaVis->doubleBufferMode) {
	 rb = intel_create_renderbuffer(rgbFormat);
         _mesa_add_renderbuffer(fb, BUFFER_BACK_LEFT, &rb->Base);
      }

      /*
       * Assert here that the gl_config has an expected depth/stencil bit
       * combination: one of d24/s8, d16/s0, d0/s0. (See intelInitScreen2(),
       * which constructs the advertised configs.)
       */
      if (mesaVis->depthBits == 24) {
	 assert(mesaVis->stencilBits == 8);

	 if (screen->hw_has_separate_stencil
	     && screen->dri2_has_hiz != INTEL_DRI2_HAS_HIZ_FALSE) {
	    /*
	     * Request a separate stencil buffer even if we do not yet know if
	     * the screen supports it. (See comments for
	     * enum intel_dri2_has_hiz).
	     */
	    rb = intel_create_renderbuffer(MESA_FORMAT_X8_Z24);
	    _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &rb->Base);
	    rb = intel_create_renderbuffer(MESA_FORMAT_S8);
	    _mesa_add_renderbuffer(fb, BUFFER_STENCIL, &rb->Base);
	 } else {
	    /*
	     * Use combined depth/stencil. Note that the renderbuffer is
	     * attached to two attachment points.
	     */
	    rb = intel_create_renderbuffer(MESA_FORMAT_S8_Z24);
	    _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &rb->Base);
	    _mesa_add_renderbuffer(fb, BUFFER_STENCIL, &rb->Base);
	 }
      }
      else if (mesaVis->depthBits == 16) {
	 assert(mesaVis->stencilBits == 0);
         /* just 16-bit depth buffer, no hw stencil */
         struct intel_renderbuffer *depthRb
	    = intel_create_renderbuffer(MESA_FORMAT_Z16);
         _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthRb->Base);
      }
      else {
	 assert(mesaVis->depthBits == 0);
	 assert(mesaVis->stencilBits == 0);
      }

      /* now add any/all software-based renderbuffers we may need */
      _mesa_add_soft_renderbuffers(fb,
                                   GL_FALSE, /* never sw color */
                                   GL_FALSE, /* never sw depth */
                                   GL_FALSE, /* never sw stencil */
                                   mesaVis->accumRedBits > 0,
                                   GL_FALSE, /* never sw alpha */
                                   GL_FALSE  /* never sw aux */ );
      driDrawPriv->driverPrivate = fb;

      return GL_TRUE;
   }
}

static void
intelDestroyBuffer(__DRIdrawable * driDrawPriv)
{
    struct gl_framebuffer *fb = driDrawPriv->driverPrivate;
  
    _mesa_reference_framebuffer(&fb, NULL);
}

/* There are probably better ways to do this, such as an
 * init-designated function to register chipids and createcontext
 * functions.
 */
extern GLboolean i830CreateContext(const struct gl_config * mesaVis,
                                   __DRIcontext * driContextPriv,
                                   void *sharedContextPrivate);

extern GLboolean i915CreateContext(int api,
				   const struct gl_config * mesaVis,
                                   __DRIcontext * driContextPriv,
                                   void *sharedContextPrivate);
extern GLboolean brwCreateContext(int api,
				  const struct gl_config * mesaVis,
				  __DRIcontext * driContextPriv,
				  void *sharedContextPrivate);

static GLboolean
intelCreateContext(gl_api api,
		   const struct gl_config * mesaVis,
                   __DRIcontext * driContextPriv,
                   void *sharedContextPrivate)
{
   __DRIscreen *sPriv = driContextPriv->driScreenPriv;
   struct intel_screen *intelScreen = sPriv->private;

#ifdef I915
   if (IS_9XX(intelScreen->deviceID)) {
      if (!IS_965(intelScreen->deviceID)) {
	 return i915CreateContext(api, mesaVis, driContextPriv,
				  sharedContextPrivate);
      }
   } else {
      intelScreen->no_vbo = GL_TRUE;
      return i830CreateContext(mesaVis, driContextPriv, sharedContextPrivate);
   }
#else
   if (IS_965(intelScreen->deviceID))
      return brwCreateContext(api, mesaVis,
			      driContextPriv, sharedContextPrivate);
#endif
   fprintf(stderr, "Unrecognized deviceID 0x%x\n", intelScreen->deviceID);
   return GL_FALSE;
}

static GLboolean
intel_init_bufmgr(struct intel_screen *intelScreen)
{
   __DRIscreen *spriv = intelScreen->driScrnPriv;
   int num_fences = 0;

   intelScreen->no_hw = (getenv("INTEL_NO_HW") != NULL ||
			 getenv("INTEL_DEVID_OVERRIDE") != NULL);

   intelScreen->bufmgr = intel_bufmgr_gem_init(spriv->fd, BATCH_SZ);
   if (intelScreen->bufmgr == NULL) {
      fprintf(stderr, "[%s:%u] Error initializing buffer manager.\n",
	      __func__, __LINE__);
      return GL_FALSE;
   }

   if (!intel_get_param(spriv, I915_PARAM_NUM_FENCES_AVAIL, &num_fences) ||
       num_fences == 0) {
      fprintf(stderr, "[%s: %u] Kernel 2.6.29 required.\n", __func__, __LINE__);
      return GL_FALSE;
   }

   drm_intel_bufmgr_gem_enable_fenced_relocs(intelScreen->bufmgr);

   intelScreen->named_regions = _mesa_NewHashTable();

   intelScreen->relaxed_relocations = 0;
   intelScreen->relaxed_relocations |=
      intel_get_boolean(spriv, I915_PARAM_HAS_RELAXED_DELTA) << 0;

   return GL_TRUE;
}

/**
 * Override intel_screen.hw_has_hiz with environment variable INTEL_HIZ.
 *
 * Valid values for INTEL_HIZ are "0" and "1". If an invalid valid value is
 * encountered, a warning is emitted and INTEL_HIZ is ignored.
 */
static void
intel_override_hiz(struct intel_screen *intel)
{
   const char *s = getenv("INTEL_HIZ");
   if (!s) {
      return;
   } else if (!strncmp("0", s, 2)) {
      intel->hw_has_hiz = false;
   } else if (!strncmp("1", s, 2)) {
      intel->hw_has_hiz = true;
   } else {
      fprintf(stderr,
	      "warning: env variable INTEL_HIZ=\"%s\" has invalid value "
	      "and is ignored", s);
   }
}

/**
 * Override intel_screen.hw_has_separate_stencil with environment variable
 * INTEL_SEPARATE_STENCIL.
 *
 * Valid values for INTEL_SEPARATE_STENCIL are "0" and "1". If an invalid
 * valid value is encountered, a warning is emitted and INTEL_SEPARATE_STENCIL
 * is ignored.
 */
static void
intel_override_separate_stencil(struct intel_screen *screen)
{
   const char *s = getenv("INTEL_SEPARATE_STENCIL");
   if (!s) {
      return;
   } else if (!strncmp("0", s, 2)) {
      screen->hw_has_separate_stencil = false;
   } else if (!strncmp("1", s, 2)) {
      screen->hw_has_separate_stencil = true;
   } else {
      fprintf(stderr,
	      "warning: env variable INTEL_SEPARATE_STENCIL=\"%s\" has "
	      "invalid value and is ignored", s);
   }
}

/**
 * This is the driver specific part of the createNewScreen entry point.
 * Called when using DRI2.
 *
 * \return the struct gl_config supported by this driver
 */
static const
__DRIconfig **intelInitScreen2(__DRIscreen *psp)
{
   struct intel_screen *intelScreen;
   GLenum fb_format[3];
   GLenum fb_type[3];
   unsigned int api_mask;
   char *devid_override;

   static const GLenum back_buffer_modes[] = {
       GLX_NONE, GLX_SWAP_UNDEFINED_OML, GLX_SWAP_COPY_OML
   };
   uint8_t depth_bits[4], stencil_bits[4], msaa_samples_array[1];
   int color;
   __DRIconfig **configs = NULL;

   /* Allocate the private area */
   intelScreen = CALLOC(sizeof *intelScreen);
   if (!intelScreen) {
      fprintf(stderr, "\nERROR!  Allocating private area failed\n");
      return GL_FALSE;
   }
   /* parse information in __driConfigOptions */
   driParseOptionInfo(&intelScreen->optionCache,
                      __driConfigOptions, __driNConfigOptions);

   intelScreen->driScrnPriv = psp;
   psp->private = (void *) intelScreen;

   /* Determine chipset ID */
   if (!intel_get_param(psp, I915_PARAM_CHIPSET_ID,
			&intelScreen->deviceID))
      return GL_FALSE;

   /* Allow an override of the device ID for the purpose of making the
    * driver produce dumps for debugging of new chipset enablement.
    * This implies INTEL_NO_HW, to avoid programming your actual GPU
    * incorrectly.
    */
   devid_override = getenv("INTEL_DEVID_OVERRIDE");
   if (devid_override) {
      intelScreen->deviceID = strtod(devid_override, NULL);
   }

   if (IS_GEN7(intelScreen->deviceID)) {
      intelScreen->gen = 7;
   } else if (IS_GEN6(intelScreen->deviceID)) {
      intelScreen->gen = 6;
   } else if (IS_GEN5(intelScreen->deviceID)) {
      intelScreen->gen = 5;
   } else if (IS_965(intelScreen->deviceID)) {
      intelScreen->gen = 4;
   } else if (IS_9XX(intelScreen->deviceID)) {
      intelScreen->gen = 3;
   } else {
      intelScreen->gen = 2;
   }

   /*
    * FIXME: The hiz and separate stencil fields need updating once the
    * FIXME: features are completely implemented for a given chipset.
    */
   intelScreen->hw_has_separate_stencil = intelScreen->gen >= 7;
   intelScreen->hw_must_use_separate_stencil = intelScreen->gen >= 7;
   intelScreen->hw_has_hiz = false;
   intelScreen->dri2_has_hiz = INTEL_DRI2_HAS_HIZ_UNKNOWN;

   intel_override_hiz(intelScreen);
   intel_override_separate_stencil(intelScreen);

   api_mask = (1 << __DRI_API_OPENGL);
#if FEATURE_ES1
   api_mask |= (1 << __DRI_API_GLES);
#endif
#if FEATURE_ES2
   api_mask |= (1 << __DRI_API_GLES2);
#endif

   if (IS_9XX(intelScreen->deviceID) || IS_965(intelScreen->deviceID))
      psp->api_mask = api_mask;

   if (!intel_init_bufmgr(intelScreen))
       return GL_FALSE;

   psp->extensions = intelScreenExtensions;

   msaa_samples_array[0] = 0;

   fb_format[0] = GL_RGB;
   fb_type[0] = GL_UNSIGNED_SHORT_5_6_5;

   fb_format[1] = GL_BGR;
   fb_type[1] = GL_UNSIGNED_INT_8_8_8_8_REV;

   fb_format[2] = GL_BGRA;
   fb_type[2] = GL_UNSIGNED_INT_8_8_8_8_REV;

   depth_bits[0] = 0;
   stencil_bits[0] = 0;

   /* Generate a rich set of useful configs that do not include an
    * accumulation buffer.
    */
   for (color = 0; color < ARRAY_SIZE(fb_format); color++) {
      __DRIconfig **new_configs;
      int depth_factor;

      /* Starting with DRI2 protocol version 1.1 we can request a depth/stencil
       * buffer that has a diffferent number of bits per pixel than the color
       * buffer.  This isn't yet supported here.
       */
      if (fb_type[color] == GL_UNSIGNED_SHORT_5_6_5) {
	 depth_bits[1] = 16;
	 stencil_bits[1] = 0;
      } else {
	 depth_bits[1] = 24;
	 stencil_bits[1] = 8;
      }

      depth_factor = 2;

      new_configs = driCreateConfigs(fb_format[color], fb_type[color],
				     depth_bits,
				     stencil_bits,
				     depth_factor,
				     back_buffer_modes,
				     ARRAY_SIZE(back_buffer_modes),
				     msaa_samples_array,
				     ARRAY_SIZE(msaa_samples_array),
				     GL_FALSE);
      if (configs == NULL)
	 configs = new_configs;
      else
	 configs = driConcatConfigs(configs, new_configs);
   }

   /* Generate the minimum possible set of configs that include an
    * accumulation buffer.
    */
   for (color = 0; color < ARRAY_SIZE(fb_format); color++) {
      __DRIconfig **new_configs;

      if (fb_type[color] == GL_UNSIGNED_SHORT_5_6_5) {
	 depth_bits[0] = 16;
	 stencil_bits[0] = 0;
      } else {
	 depth_bits[0] = 24;
	 stencil_bits[0] = 8;
      }

      new_configs = driCreateConfigs(fb_format[color], fb_type[color],
				     depth_bits, stencil_bits, 1,
				     back_buffer_modes + 1, 1,
				     msaa_samples_array, 1,
				     GL_TRUE);
      if (configs == NULL)
	 configs = new_configs;
      else
	 configs = driConcatConfigs(configs, new_configs);
   }

   if (configs == NULL) {
      fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
              __LINE__);
      return NULL;
   }

   return (const __DRIconfig **)configs;
}

struct intel_buffer {
   __DRIbuffer base;
   struct intel_region *region;
};

/**
 * \brief Get tiling format for a DRI buffer.
 *
 * \param attachment is the buffer's attachmet point, such as
 *        __DRI_BUFFER_DEPTH.
 * \param out_tiling is the returned tiling format for buffer.
 * \return false if attachment is unrecognized or is incompatible with screen.
 */
static bool
intel_get_dri_buffer_tiling(struct intel_screen *screen,
                            uint32_t attachment,
                            uint32_t *out_tiling)
{
   if (screen->gen < 4) {
      *out_tiling = I915_TILING_X;
      return true;
   }

   switch (attachment) {
   case __DRI_BUFFER_DEPTH:
   case __DRI_BUFFER_DEPTH_STENCIL:
   case __DRI_BUFFER_HIZ:
      *out_tiling = I915_TILING_Y;
      return true;
   case __DRI_BUFFER_ACCUM:
   case __DRI_BUFFER_FRONT_LEFT:
   case __DRI_BUFFER_FRONT_RIGHT:
   case __DRI_BUFFER_BACK_LEFT:
   case __DRI_BUFFER_BACK_RIGHT:
   case __DRI_BUFFER_FAKE_FRONT_LEFT:
   case __DRI_BUFFER_FAKE_FRONT_RIGHT:
      *out_tiling = I915_TILING_X;
      return true;
   case __DRI_BUFFER_STENCIL:
      /* The stencil buffer is W tiled. However, we request from the kernel
       * a non-tiled buffer because the GTT is incapable of W fencing.
       */
      *out_tiling = I915_TILING_NONE;
      return true;
   default:
      if(unlikely(INTEL_DEBUG & DEBUG_DRI)) {
	 fprintf(stderr, "error: %s: unrecognized DRI buffer attachment 0x%x\n",
	         __FUNCTION__, attachment);
      }
       return false;
   }
}

static __DRIbuffer *
intelAllocateBuffer(__DRIscreen *screen,
		    unsigned attachment, unsigned format,
		    int width, int height)
{
   struct intel_buffer *intelBuffer;
   struct intel_screen *intelScreen = screen->private;

   uint32_t tiling;
   uint32_t region_width;
   uint32_t region_height;
   uint32_t region_cpp;

   bool ok = true;

   ok = intel_get_dri_buffer_tiling(intelScreen, attachment, &tiling);
   if (!ok)
      return NULL;

   intelBuffer = CALLOC(sizeof *intelBuffer);
   if (intelBuffer == NULL)
      return NULL;

   if (attachment == __DRI_BUFFER_STENCIL) {
      /* The stencil buffer has quirky pitch requirements.  From Vol 2a,
       * 11.5.6.2.1 3DSTATE_STENCIL_BUFFER, field "Surface Pitch":
       *    The pitch must be set to 2x the value computed based on width, as
       *    the stencil buffer is stored with two rows interleaved.
       * To accomplish this, we resort to the nasty hack of doubling the
       * region's cpp and halving its height.
       */
      region_width = ALIGN(width, 64);
      region_height = ALIGN(ALIGN(height, 2) / 2, 64);
      region_cpp = format / 4;
   } else {
      region_width = width;
      region_height = height;
      region_cpp = format / 8;
   }

   intelBuffer->region = intel_region_alloc(intelScreen,
                                            tiling,
                                            region_cpp,
                                            region_width,
                                            region_height,
                                            true);
   
   if (intelBuffer->region == NULL) {
	   FREE(intelBuffer);
	   return NULL;
   }
   
   intel_region_flink(intelBuffer->region, &intelBuffer->base.name);

   intelBuffer->base.attachment = attachment;
   intelBuffer->base.cpp = intelBuffer->region->cpp;
   intelBuffer->base.pitch =
         intelBuffer->region->pitch * intelBuffer->region->cpp;

   return &intelBuffer->base;
}

static void
intelReleaseBuffer(__DRIscreen *screen, __DRIbuffer *buffer)
{
   struct intel_buffer *intelBuffer = (struct intel_buffer *) buffer;

   intel_region_release(&intelBuffer->region);
   free(intelBuffer);
}


const struct __DriverAPIRec driDriverAPI = {
   .DestroyScreen	 = intelDestroyScreen,
   .CreateContext	 = intelCreateContext,
   .DestroyContext	 = intelDestroyContext,
   .CreateBuffer	 = intelCreateBuffer,
   .DestroyBuffer	 = intelDestroyBuffer,
   .MakeCurrent		 = intelMakeCurrent,
   .UnbindContext	 = intelUnbindContext,
   .InitScreen2		 = intelInitScreen2,
   .AllocateBuffer       = intelAllocateBuffer,
   .ReleaseBuffer        = intelReleaseBuffer
};

/* This is the table of extensions that the loader will dlsym() for. */
PUBLIC const __DRIextension *__driDriverExtensions[] = {
    &driCoreExtension.base,
    &driDRI2Extension.base,
    NULL
};
@


1.11
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.10
log
@Merge Mesa 7.10.3
@
text
@d28 1
d35 1
d108 2
a109 1
   struct intel_context *intel = drawable->driContextPriv->driverPrivate;
d111 3
a113 2
   if (intel->gen < 4)
      INTEL_FIREVERTICES(intel);
d115 1
a115 1
   intel->need_throttle = GL_TRUE;
d117 3
a119 2
   if (intel->batch->map != intel->batch->ptr)
      intel_batchbuffer_flush(intel->batch);
d221 1
d224 7
d260 1
a260 1
      intel_region_alloc(intelScreen, I915_TILING_NONE,
d287 24
d317 2
a318 1
    intel_query_image
d341 2
a342 1
      _mesa_warning(NULL, "drm_i915_getparam: %d", ret);
d349 7
d389 1
a394 2
      GLboolean swStencil = (mesaVis->stencilBits > 0 &&
                             mesaVis->depthBits != 24);
d420 5
d427 21
a447 6
	 /* combined depth/stencil buffer */
	 struct intel_renderbuffer *depthStencilRb
	    = intel_create_renderbuffer(MESA_FORMAT_S8_Z24);
	 /* note: bind RB to two attachment points */
	 _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthStencilRb->Base);
	 _mesa_add_renderbuffer(fb, BUFFER_STENCIL, &depthStencilRb->Base);
d450 1
d456 4
d465 2
a466 1
                                   swStencil, mesaVis->accumRedBits > 0,
d554 4
d562 48
d659 26
d785 125
d919 2
@


1.9
log
@Fix an X server crash when starting GLX 1.3 apps;
https://bugs.freedesktop.org/show_bug.cgi?id=29091

ok matthieu@@, oga@@
@
text
@a37 13
#include "intel_batchbuffer.h"
#include "intel_buffers.h"
#include "intel_bufmgr.h"
#include "intel_chipset.h"
#include "intel_fbo.h"
#include "intel_screen.h"
#include "intel_tex.h"
#include "intel_regions.h"

#include "i915_drm.h"

#define DRI_CONF_TEXTURE_TILING(def) \

d60 1
a60 1
      DRI_CONF_OPT_BEGIN(fragment_shader, bool, false)
d82 11
a102 9
static inline struct intel_context *
to_intel_context(__DRIdrawable *drawable)
{
   if (drawable->driContextPriv == NULL)
      return NULL;

   return drawable->driContextPriv->driverPrivate;
}

d106 1
a106 3
   struct intel_context *intel = to_intel_context(drawable);
   if (!intel)
      return;
d111 2
a116 9
static void
intelDRI2Invalidate(__DRIdrawable *drawable)
{
   struct intel_context *intel = to_intel_context(drawable);
   if (intel)
      intel->using_dri2_swapbuffers = GL_TRUE;
   dri2InvalidateDrawable(drawable);
}

d120 1
a120 1
    intelDRI2Invalidate,
d124 1
a124 1
intel_create_image_from_name(__DRIcontext *context,
d128 1
a129 1
    struct intel_context *intel = context->driverPrivate;
d160 2
a161 1
    image->region = intel_region_alloc_for_handle(intel, cpp, width, height,
d208 66
d279 2
d340 1
a340 1
                  const __GLcontextModes * mesaVis, GLboolean isPixmap)
d376 7
a382 12
	 if (mesaVis->stencilBits == 8) {
	    /* combined depth/stencil buffer */
	    struct intel_renderbuffer *depthStencilRb
	       = intel_create_renderbuffer(MESA_FORMAT_S8_Z24);
	    /* note: bind RB to two attachment points */
	    _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthStencilRb->Base);
	    _mesa_add_renderbuffer(fb, BUFFER_STENCIL, &depthStencilRb->Base);
	 } else {
	    struct intel_renderbuffer *depthRb
	       = intel_create_renderbuffer(MESA_FORMAT_X8_Z24);
	    _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthRb->Base);
	 }
d416 1
a416 1
extern GLboolean i830CreateContext(const __GLcontextModes * mesaVis,
d420 2
a421 1
extern GLboolean i915CreateContext(const __GLcontextModes * mesaVis,
d424 2
a425 1
extern GLboolean brwCreateContext(const __GLcontextModes * mesaVis,
d430 2
a431 1
intelCreateContext(const __GLcontextModes * mesaVis,
d441 1
a441 1
	 return i915CreateContext(mesaVis, driContextPriv,
d450 2
a451 1
      return brwCreateContext(mesaVis, driContextPriv, sharedContextPrivate);
d453 1
a453 1
   fprintf(stderr, "Unrecognized deviceID %x\n", intelScreen->deviceID);
d463 2
a464 1
   intelScreen->no_hw = getenv("INTEL_NO_HW") != NULL;
a466 1
   /* Otherwise, use the classic buffer manager. */
d490 1
a490 1
 * \return the __GLcontextModes supported by this driver
d498 2
d525 21
@


1.8
log
@Two patches cherry picked from mesa master just after 7.8 was branched
(but never made it into the 7.8 branch).

first:
Author: Jesse Barnes <jbarnes@@virtuousgeek.org>
Date:   Thu Apr 22 12:47:41 2010 -0700

    DRI2: add config query extension

    Add a new DRI2 configuration query extension.  Allows for DRI2
    client code to query for common DRI2 configuration options.

second:
Author: Jesse Barnes <jbarnes@@virtuousgeek.org>
Date:   Thu Apr 22 12:49:03 2010 -0700

    DRI2/GLX: check for vblank_mode in DRI2 GLX code

    Re-add support for the vblank_mode environment and configuration
    variable.  Useful for benchmarking and app control.

The final affect being that config and environment variables for
controlling swap mode work with dri2 now. which helps me a lot with
debugging.

ok matthieu@@.
@
text
@d105 9
d117 3
a119 1
   struct intel_context *intel = drawable->driContextPriv->driverPrivate;
d131 3
a133 3
   struct intel_context *intel = drawable->driContextPriv->driverPrivate;

   intel->using_dri2_swapbuffers = GL_TRUE;
@


1.7
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d228 1
@


1.6
log
@Stop printing to stderr whenever we fail to initialise GEM (every time
without diffs), libraries shouldn't do that, and it's frankly pretty
irritating.

ok matthieu ages ago. prompted by deraadt@@
@
text
@a30 1
#include "main/matrix.h"
d32 3
a34 1
#include "main/simple_list.h"
a35 1
#include "vblank.h"
d38 5
a42 1

a43 2

#include "intel_buffers.h"
d45 1
a45 4
#include "intel_span.h"
#include "intel_fbo.h"
#include "intel_chipset.h"
#include "intel_swapbuffers.h"
d48 2
a49 4
#include "i830_dri.h"
#include "intel_regions.h"
#include "intel_batchbuffer.h"
#include "intel_bufmgr.h"
a53 1
      DRI_CONF_FTHROTTLE_MODE(DRI_CONF_FTHROTTLE_IRQS)
d64 13
d84 6
d93 1
a93 1
const GLuint __driNConfigOptions = 6;
d99 8
a106 6
/**
 * Map all the memory regions described by the screen.
 * \return GL_TRUE if success, GL_FALSE if error.
 */
GLboolean
intelMapScreenRegions(__DRIscreenPrivate * sPriv)
d108 1
a108 1
   intelScreenPrivate *intelScreen = (intelScreenPrivate *) sPriv->private;
d110 2
a111 11
   if (0)
      _mesa_printf("TEX 0x%08x ", intelScreen->tex.handle);
   if (intelScreen->tex.size != 0) {
      if (drmMap(sPriv->fd,
		 intelScreen->tex.handle,
		 intelScreen->tex.size,
		 (drmAddress *) & intelScreen->tex.map) != 0) {
	 intelUnmapScreenRegions(intelScreen);
	 return GL_FALSE;
      }
   }
d113 2
a114 1
   return GL_TRUE;
d117 2
a118 2
void
intelUnmapScreenRegions(intelScreenPrivate * intelScreen)
d120 4
a123 4
   if (intelScreen->tex.map) {
      drmUnmap(intelScreen->tex.map, intelScreen->tex.size);
      intelScreen->tex.map = NULL;
   }
d126 39
d166 2
a167 17
static void
intelPrintDRIInfo(intelScreenPrivate * intelScreen,
                  __DRIscreenPrivate * sPriv, I830DRIPtr gDRIPriv)
{
   fprintf(stderr, "*** Front size:   0x%x  offset: 0x%x  pitch: %d\n",
           intelScreen->front.size, intelScreen->front.offset,
           intelScreen->pitch);
   fprintf(stderr, "*** Back size:    0x%x  offset: 0x%x  pitch: %d\n",
           intelScreen->back.size, intelScreen->back.offset,
           intelScreen->pitch);
   fprintf(stderr, "*** Depth size:   0x%x  offset: 0x%x  pitch: %d\n",
           intelScreen->depth.size, intelScreen->depth.offset,
           intelScreen->pitch);
   fprintf(stderr, "*** Texture size: 0x%x  offset: 0x%x\n",
           intelScreen->tex.size, intelScreen->tex.offset);
   fprintf(stderr, "*** Memory : 0x%x\n", gDRIPriv->mem);
}
d169 6
d176 1
a176 19
static void
intelPrintSAREA(const drm_i915_sarea_t * sarea)
{
   fprintf(stderr, "SAREA: sarea width %d  height %d\n", sarea->width,
           sarea->height);
   fprintf(stderr, "SAREA: pitch: %d\n", sarea->pitch);
   fprintf(stderr,
           "SAREA: front offset: 0x%08x  size: 0x%x  handle: 0x%x tiled: %d\n",
           sarea->front_offset, sarea->front_size,
           (unsigned) sarea->front_handle, sarea->front_tiled);
   fprintf(stderr,
           "SAREA: back  offset: 0x%08x  size: 0x%x  handle: 0x%x tiled: %d\n",
           sarea->back_offset, sarea->back_size,
           (unsigned) sarea->back_handle, sarea->back_tiled);
   fprintf(stderr, "SAREA: depth offset: 0x%08x  size: 0x%x  handle: 0x%x tiled: %d\n",
           sarea->depth_offset, sarea->depth_size,
           (unsigned) sarea->depth_handle, sarea->depth_tiled);
   fprintf(stderr, "SAREA: tex   offset: 0x%08x  size: 0x%x  handle: 0x%x\n",
           sarea->tex_offset, sarea->tex_size, (unsigned) sarea->tex_handle);
d179 8
d188 5
a192 35
/**
 * A number of the screen parameters are obtained/computed from
 * information in the SAREA.  This function updates those parameters.
 */
static void
intelUpdateScreenFromSAREA(intelScreenPrivate * intelScreen,
                           drm_i915_sarea_t * sarea)
{
   intelScreen->width = sarea->width;
   intelScreen->height = sarea->height;
   intelScreen->pitch = sarea->pitch;

   intelScreen->front.offset = sarea->front_offset;
   intelScreen->front.handle = sarea->front_handle;
   intelScreen->front.size = sarea->front_size;
   intelScreen->front.tiled = sarea->front_tiled;

   intelScreen->back.offset = sarea->back_offset;
   intelScreen->back.handle = sarea->back_handle;
   intelScreen->back.size = sarea->back_size;
   intelScreen->back.tiled = sarea->back_tiled;

   intelScreen->depth.offset = sarea->depth_offset;
   intelScreen->depth.handle = sarea->depth_handle;
   intelScreen->depth.size = sarea->depth_size;
   intelScreen->depth.tiled = sarea->depth_tiled;

   if (intelScreen->driScrnPriv->ddx_version.minor >= 9) {
      intelScreen->front.bo_handle = sarea->front_bo_handle;
      intelScreen->back.bo_handle = sarea->back_bo_handle;
      intelScreen->depth.bo_handle = sarea->depth_bo_handle;
   } else {
      intelScreen->front.bo_handle = -1;
      intelScreen->back.bo_handle = -1;
      intelScreen->depth.bo_handle = -1;
d195 10
a204 4
   intelScreen->tex.offset = sarea->tex_offset;
   intelScreen->logTextureGranularity = sarea->log_tex_granularity;
   intelScreen->tex.handle = sarea->tex_handle;
   intelScreen->tex.size = sarea->tex_size;
d206 1
a206 2
   if (0)
      intelPrintSAREA(sarea);
d209 6
a214 4
static const __DRItexOffsetExtension intelTexOffsetExtension = {
   { __DRI_TEX_OFFSET },
   intelSetTexOffset,
};
d216 5
a220 3
static const __DRItexBufferExtension intelTexBufferExtension = {
    { __DRI_TEX_BUFFER, __DRI_TEX_BUFFER_VERSION },
   intelSetTexBuffer,
a224 5
    &driCopySubBufferExtension.base,
    &driSwapControlExtension.base,
    &driFrameTrackingExtension.base,
    &driMediaStreamCounterExtension.base,
    &intelTexOffsetExtension.base,
d226 2
d232 1
a232 1
intel_get_param(__DRIscreenPrivate *psp, int param, int *value)
d242 1
a242 1
      fprintf(stderr, "drm_i915_getparam: %d\n", ret);
d249 2
a250 1
static GLboolean intelInitDriver(__DRIscreenPrivate *sPriv)
a251 50
   intelScreenPrivate *intelScreen;
   I830DRIPtr gDRIPriv = (I830DRIPtr) sPriv->pDevPriv;
   drm_i915_sarea_t *sarea;

   if (sPriv->devPrivSize != sizeof(I830DRIRec)) {
      fprintf(stderr,
              "\nERROR!  sizeof(I830DRIRec) does not match passed size from device driver\n");
      return GL_FALSE;
   }

   /* Allocate the private area */
   intelScreen = (intelScreenPrivate *) CALLOC(sizeof(intelScreenPrivate));
   if (!intelScreen) {
      fprintf(stderr, "\nERROR!  Allocating private area failed\n");
      return GL_FALSE;
   }
   /* parse information in __driConfigOptions */
   driParseOptionInfo(&intelScreen->optionCache,
                      __driConfigOptions, __driNConfigOptions);

   intelScreen->driScrnPriv = sPriv;
   sPriv->private = (void *) intelScreen;
   sarea = (drm_i915_sarea_t *)
      (((GLubyte *) sPriv->pSAREA) + gDRIPriv->sarea_priv_offset);
   intelScreen->sarea = sarea;

   intelScreen->deviceID = gDRIPriv->deviceID;

   intelUpdateScreenFromSAREA(intelScreen, sarea);

   if (!intelMapScreenRegions(sPriv)) {
      fprintf(stderr, "\nERROR!  mapping regions\n");
      _mesa_free(intelScreen);
      sPriv->private = NULL;
      return GL_FALSE;
   }

   if (0)
      intelPrintDRIInfo(intelScreen, sPriv, gDRIPriv);

   intelScreen->drmMinor = sPriv->drm_version.minor;

   /* Determine if IRQs are active? */
   if (!intel_get_param(sPriv, I915_PARAM_IRQ_ACTIVE,
			&intelScreen->irq_active))
      return GL_FALSE;

   sPriv->extensions = intelScreenExtensions;

   return GL_TRUE;
a253 1

d255 1
a255 1
intelDestroyScreen(__DRIscreenPrivate * sPriv)
d257 1
a257 1
   intelScreenPrivate *intelScreen = (intelScreenPrivate *) sPriv->private;
d260 7
a266 1
   intelUnmapScreenRegions(intelScreen);
d277 2
a278 2
intelCreateBuffer(__DRIscreenPrivate * driScrnPriv,
                  __DRIdrawablePrivate * driDrawPriv,
d281 2
d289 1
a289 1
      GLenum rgbFormat = (mesaVis->redBits == 5 ? GL_RGB5 : GL_RGBA8);
d291 1
a291 1
      struct intel_framebuffer *intel_fb = CALLOC_STRUCT(intel_framebuffer);
d293 1
a293 1
      if (!intel_fb)
d296 8
a303 1
      _mesa_initialize_framebuffer(&intel_fb->Base, mesaVis);
d306 2
a307 3
      intel_fb->color_rb[0] = intel_create_renderbuffer(rgbFormat);
      _mesa_add_renderbuffer(&intel_fb->Base, BUFFER_FRONT_LEFT,
			     &intel_fb->color_rb[0]->Base);
d310 2
a311 5
	 intel_fb->color_rb[1] = intel_create_renderbuffer(rgbFormat);

         _mesa_add_renderbuffer(&intel_fb->Base, BUFFER_BACK_LEFT,
				&intel_fb->color_rb[1]->Base);

d318 1
a318 1
	       = intel_create_renderbuffer(GL_DEPTH24_STENCIL8_EXT);
d320 2
a321 4
	    _mesa_add_renderbuffer(&intel_fb->Base, BUFFER_DEPTH,
				   &depthStencilRb->Base);
	    _mesa_add_renderbuffer(&intel_fb->Base, BUFFER_STENCIL,
				   &depthStencilRb->Base);
d324 2
a325 3
	       = intel_create_renderbuffer(GL_DEPTH_COMPONENT24);
	    _mesa_add_renderbuffer(&intel_fb->Base, BUFFER_DEPTH,
				   &depthRb->Base);
d331 2
a332 2
	    = intel_create_renderbuffer(GL_DEPTH_COMPONENT16);
         _mesa_add_renderbuffer(&intel_fb->Base, BUFFER_DEPTH, &depthRb->Base);
d336 1
a336 1
      _mesa_add_soft_renderbuffers(&intel_fb->Base,
d342 1
a342 1
      driDrawPriv->driverPrivate = (void *) intel_fb;
d349 1
a349 11
intelDestroyBuffer(__DRIdrawablePrivate * driDrawPriv)
{
   _mesa_unreference_framebuffer((GLframebuffer **)(&(driDrawPriv->driverPrivate)));
}


/**
 * Get information about previous buffer swaps.
 */
static int
intelGetSwapInfo(__DRIdrawablePrivate * dPriv, __DRIswapInfo * sInfo)
d351 3
a353 17
   struct intel_framebuffer *intel_fb;

   if ((dPriv == NULL) || (dPriv->driverPrivate == NULL)
       || (sInfo == NULL)) {
      return -1;
   }

   intel_fb = dPriv->driverPrivate;
   sInfo->swap_count = intel_fb->swap_count;
   sInfo->swap_ust = intel_fb->swap_ust;
   sInfo->swap_missed_count = intel_fb->swap_missed_count;

   sInfo->swap_missed_usage = (sInfo->swap_missed_count != 0)
      ? driCalculateSwapUsage(dPriv, 0, intel_fb->swap_missed_ust)
      : 0.0;

   return 0;
a355 1

d361 1
a361 1
                                   __DRIcontextPrivate * driContextPriv,
d365 1
a365 1
                                   __DRIcontextPrivate * driContextPriv,
d368 1
a368 1
				  __DRIcontextPrivate * driContextPriv,
d373 1
a373 1
                   __DRIcontextPrivate * driContextPriv,
d376 2
a377 2
   __DRIscreenPrivate *sPriv = driContextPriv->driScreenPriv;
   intelScreenPrivate *intelScreen = (intelScreenPrivate *) sPriv->private;
a396 73

static __DRIconfig **
intelFillInModes(__DRIscreenPrivate *psp,
		 unsigned pixel_bits, unsigned depth_bits,
                 unsigned stencil_bits, GLboolean have_back_buffer)
{
   __DRIconfig **configs;
   __GLcontextModes *m;
   unsigned depth_buffer_factor;
   unsigned back_buffer_factor;
   GLenum fb_format;
   GLenum fb_type;
   int i;

   /* GLX_SWAP_COPY_OML is only supported because the Intel driver doesn't
    * support pageflipping at all.
    */
   static const GLenum back_buffer_modes[] = {
      GLX_NONE, GLX_SWAP_UNDEFINED_OML, GLX_SWAP_COPY_OML
   };

   uint8_t depth_bits_array[3];
   uint8_t stencil_bits_array[3];

   depth_bits_array[0] = 0;
   depth_bits_array[1] = depth_bits;
   depth_bits_array[2] = depth_bits;

   /* Just like with the accumulation buffer, always provide some modes
    * with a stencil buffer.  It will be a sw fallback, but some apps won't
    * care about that.
    */
   stencil_bits_array[0] = 0;
   stencil_bits_array[1] = 0;
   if (depth_bits == 24)
      stencil_bits_array[1] = (stencil_bits == 0) ? 8 : stencil_bits;

   stencil_bits_array[2] = (stencil_bits == 0) ? 8 : stencil_bits;

   depth_buffer_factor = ((depth_bits != 0) || (stencil_bits != 0)) ? 3 : 1;
   back_buffer_factor = (have_back_buffer) ? 3 : 1;

   if (pixel_bits == 16) {
      fb_format = GL_RGB;
      fb_type = GL_UNSIGNED_SHORT_5_6_5;
   }
   else {
      fb_format = GL_BGRA;
      fb_type = GL_UNSIGNED_INT_8_8_8_8_REV;
   }

   configs = driCreateConfigs(fb_format, fb_type,
			      depth_bits_array, stencil_bits_array,
			      depth_buffer_factor, back_buffer_modes,
			      back_buffer_factor);
   if (configs == NULL) {
    fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
              __LINE__);
      return NULL;
   }

   /* Mark the visual as slow if there are "fake" stencil bits.
    */
   for (i = 0; configs[i]; i++) {
      m = &configs[i]->modes;
      if ((m->stencilBits != 0) && (m->stencilBits != stencil_bits)) {
         m->visualRating = GLX_SLOW_CONFIG;
      }
   }

   return configs;
}

d398 1
a398 1
intel_init_bufmgr(intelScreenPrivate *intelScreen)
d400 2
a401 5
   GLboolean gem_disable = getenv("INTEL_NO_GEM") != NULL;
   int gem_kernel = 0;
   GLboolean gem_supported;
   struct drm_i915_getparam gp;
   __DRIscreenPrivate *spriv = intelScreen->driScrnPriv;
d405 1
a405 23
   gp.param = I915_PARAM_HAS_GEM;
   gp.value = &gem_kernel;

   (void) drmCommandWriteRead(spriv->fd, DRM_I915_GETPARAM, &gp, sizeof(gp));

   /* If we've got a new enough DDX that's initializing GEM and giving us
    * object handles for the shared buffers, use that.
    */
   intelScreen->ttm = GL_FALSE;
   if (intelScreen->driScrnPriv->dri2.enabled)
       gem_supported = GL_TRUE;
   else if (intelScreen->driScrnPriv->ddx_version.minor >= 9 &&
	    gem_kernel &&
	    intelScreen->front.bo_handle != -1)
       gem_supported = GL_TRUE;
   else
       gem_supported = GL_FALSE;

   if (!gem_disable && gem_supported) {
      intelScreen->bufmgr = intel_bufmgr_gem_init(spriv->fd, BATCH_SZ);
      if (intelScreen->bufmgr != NULL)
	 intelScreen->ttm = GL_TRUE;
   }
d408 3
a410 13
      if (intelScreen->tex.size == 0) {
	 fprintf(stderr, "[%s:%u] Error initializing buffer manager.\n",
		 __func__, __LINE__);
	 return GL_FALSE;
      }

      intelScreen->bufmgr =
	 intel_bufmgr_fake_init(spriv->fd,
				intelScreen->tex.offset,
				intelScreen->tex.map,
				intelScreen->tex.size,
				(unsigned int * volatile)
				&intelScreen->sarea->last_dispatch);
d413 4
a416 31
   /* XXX bufmgr should be per-screen, not per-context */
   intelScreen->ttm = intelScreen->ttm;

   return GL_TRUE;
}

/**
 * This is the driver specific part of the createNewScreen entry point.
 * Called when using legacy DRI.
 * 
 * \todo maybe fold this into intelInitDriver
 *
 * \return the __GLcontextModes supported by this driver
 */
static const __DRIconfig **intelInitScreen(__DRIscreenPrivate *psp)
{
   intelScreenPrivate *intelScreen;
#ifdef I915
   static const __DRIversion ddx_expected = { 1, 5, 0 };
#else
   static const __DRIversion ddx_expected = { 1, 6, 0 };
#endif
   static const __DRIversion dri_expected = { 4, 0, 0 };
   static const __DRIversion drm_expected = { 1, 5, 0 };
   I830DRIPtr dri_priv = (I830DRIPtr) psp->pDevPriv;

   if (!driCheckDriDdxDrmVersions2("i915",
                                   &psp->dri_version, &dri_expected,
                                   &psp->ddx_version, &ddx_expected,
                                   &psp->drm_version, &drm_expected)) {
      return NULL;
d419 1
a419 16
   /* Calling driInitExtensions here, with a NULL context pointer,
    * does not actually enable the extensions.  It just makes sure
    * that all the dispatch offsets for all the extensions that
    * *might* be enables are known.  This is needed because the
    * dispatch offsets need to be known when _mesa_context_create is
    * called, but we can't enable the extensions until we have a
    * context pointer.
    *
    * Hello chicken.  Hello egg.  How are you two today?
    */
   intelInitExtensions(NULL, GL_TRUE);
	   
   if (!intelInitDriver(psp))
       return NULL;

   psp->extensions = intelScreenExtensions;
d421 1
a421 3
   intelScreen = psp->private;
   if (!intel_init_bufmgr(intelScreen))
       return GL_FALSE;
d423 1
a423 19
   return (const __DRIconfig **)
       intelFillInModes(psp, dri_priv->cpp * 8,
			(dri_priv->cpp == 2) ? 16 : 24,
			(dri_priv->cpp == 2) ? 0  : 8, 1);
}

struct intel_context *intelScreenContext(intelScreenPrivate *intelScreen)
{
  /*
   * This should probably change to have the screen allocate a dummy
   * context at screen creation. For now just use the current context.
   */

  GET_CURRENT_CONTEXT(ctx);
  if (ctx == NULL) {
     _mesa_problem(NULL, "No current context in intelScreenContext\n");
     return NULL;
  }
  return intel_context(ctx);
d433 1
a433 1
__DRIconfig **intelInitScreen2(__DRIscreenPrivate *psp)
d435 3
a437 1
   intelScreenPrivate *intelScreen;
d439 6
a444 11
   /* Calling driInitExtensions here, with a NULL context pointer,
    * does not actually enable the extensions.  It just makes sure
    * that all the dispatch offsets for all the extensions that
    * *might* be enables are known.  This is needed because the
    * dispatch offsets need to be known when _mesa_context_create is
    * called, but we can't enable the extensions until we have a
    * context pointer.
    *
    * Hello chicken.  Hello egg.  How are you two today?
    */
   intelInitExtensions(NULL, GL_TRUE);
d447 1
a447 1
   intelScreen = (intelScreenPrivate *) CALLOC(sizeof(intelScreenPrivate));
a458 2
   intelScreen->drmMinor = psp->drm_version.minor;

a466 1
   intelScreen->irq_active = 1;
d469 82
a550 2
   return driConcatConfigs(intelFillInModes(psp, 16, 16, 0, 1),
			   intelFillInModes(psp, 32, 24, 8, 1));
a553 1
   .InitScreen		 = intelInitScreen,
a558 1
   .SwapBuffers		 = intelSwapBuffers,
d561 2
a562 4
   .GetSwapInfo		 = intelGetSwapInfo,
   .GetDrawableMSC	 = driDrawableGetMSC32,
   .WaitForMSC		 = driWaitForMSC32,
   .CopySubBuffer	 = intelCopySubBuffer,
d564 5
a568 1
   .InitScreen2		 = intelInitScreen2,
@


1.5
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a567 7
      if (gem_disable) {
	 fprintf(stderr, "GEM disabled.  Using classic.\n");
      } else {
	 fprintf(stderr, "Failed to initialize GEM.  "
		 "Falling back to classic.\n");
      }

@


1.4
log
@Remove ttm entrypoints. That memory manager interface isn't going to see the
light of day and has already been removed in mesa master (ages ago).

As a bonus, removes the annoying "falling back to classic" message on
launching a gl application.

ok matthieu@@.
@
text
@d28 6
a33 6
#include "glheader.h"
#include "context.h"
#include "framebuffer.h"
#include "matrix.h"
#include "renderbuffer.h"
#include "simple_list.h"
a43 1
#include "intel_ioctl.h"
d46 1
d52 1
d62 1
a62 1
      DRI_CONF_OPT_BEGIN_V(bo_reuse, enum, 0, "0:1")
a92 33
   if (intelScreen->front.handle) {
      if (drmMap(sPriv->fd,
                 intelScreen->front.handle,
                 intelScreen->front.size,
                 (drmAddress *) & intelScreen->front.map) != 0) {
         _mesa_problem(NULL, "drmMap(frontbuffer) failed!");
         return GL_FALSE;
      }
   }
   else {
      _mesa_warning(NULL, "no front buffer handle in intelMapScreenRegions!");
   }

   if (0)
      _mesa_printf("Back 0x%08x ", intelScreen->back.handle);
   if (drmMap(sPriv->fd,
              intelScreen->back.handle,
              intelScreen->back.size,
              (drmAddress *) & intelScreen->back.map) != 0) {
      intelUnmapScreenRegions(intelScreen);
      return GL_FALSE;
   }

   if (0)
      _mesa_printf("Depth 0x%08x ", intelScreen->depth.handle);
   if (drmMap(sPriv->fd,
              intelScreen->depth.handle,
              intelScreen->depth.size,
              (drmAddress *) & intelScreen->depth.map) != 0) {
      intelUnmapScreenRegions(intelScreen);
      return GL_FALSE;
   }

a104 4
   if (0)
      printf("Mappings:  front: %p  back: %p  depth: %p  tex: %p\n",
             intelScreen->front.map, intelScreen->back.map, 
             intelScreen->depth.map, intelScreen->tex.map);
a110 21
#define REALLY_UNMAP 1
   if (intelScreen->front.map) {
#if REALLY_UNMAP
      if (drmUnmap(intelScreen->front.map, intelScreen->front.size) != 0)
         printf("drmUnmap front failed!\n");
#endif
      intelScreen->front.map = NULL;
   }
   if (intelScreen->back.map) {
#if REALLY_UNMAP
      if (drmUnmap(intelScreen->back.map, intelScreen->back.size) != 0)
         printf("drmUnmap back failed!\n");
#endif
      intelScreen->back.map = NULL;
   }
   if (intelScreen->depth.map) {
#if REALLY_UNMAP
      drmUnmap(intelScreen->depth.map, intelScreen->depth.size);
      intelScreen->depth.map = NULL;
#endif
   }
a111 1
#if REALLY_UNMAP
a113 1
#endif
d138 1
a138 1
intelPrintSAREA(const struct drm_i915_sarea * sarea)
d144 1
a144 1
           "SAREA: front offset: 0x%08x  size: 0x%x  handle: 0x%x\n",
d146 1
a146 1
           (unsigned) sarea->front_handle);
d148 1
a148 1
           "SAREA: back  offset: 0x%08x  size: 0x%x  handle: 0x%x\n",
d150 2
a151 2
           (unsigned) sarea->back_handle);
   fprintf(stderr, "SAREA: depth offset: 0x%08x  size: 0x%x  handle: 0x%x\n",
d153 1
a153 1
           (unsigned) sarea->depth_handle);
d163 1
a163 1
void
d165 1
a165 1
                           struct drm_i915_sarea * sarea)
d186 10
a204 2
#define BUFFER_FLAG_TILED 0x0100

d248 1
a248 1
   struct drm_i915_sarea *sarea;
d268 3
a270 3
   intelScreen->sarea_priv_offset = gDRIPriv->sarea_priv_offset;
   sarea = (struct drm_i915_sarea *)
      (((GLubyte *) sPriv->pSAREA) + intelScreen->sarea_priv_offset);
a282 2
   intelScreen->sarea_priv_offset = gDRIPriv->sarea_priv_offset;

a292 5
   /* Determine if batchbuffers are allowed */
   if (!intel_get_param(sPriv, I915_PARAM_ALLOW_BATCHBUFFER,
			&intelScreen->allow_batchbuffer))
      return GL_FALSE;

d304 1
a319 2
   intelScreenPrivate *screen = (intelScreenPrivate *) driScrnPriv->private;

d336 3
a338 5
      {
         intel_fb->color_rb[0] = intel_create_renderbuffer(rgbFormat);
         _mesa_add_renderbuffer(&intel_fb->Base, BUFFER_FRONT_LEFT,
				&intel_fb->color_rb[0]->Base);
      }
d341 2
a342 1
         intel_fb->color_rb[1] = intel_create_renderbuffer(rgbFormat);
d345 1
d368 1
a368 1
            = intel_create_renderbuffer(GL_DEPTH_COMPONENT16);
d448 1
d480 2
a481 2
   u_int8_t depth_bits_array[3];
   u_int8_t stencil_bits_array[3];
d532 63
d606 1
d640 4
d665 53
d732 2
@


1.3
log
@remove the triple buffering support from the intel driver, the support
from this was removed from the kernel and is very much deprecated.
Pageflipping is also probably broken and should not be used. Similar
change happened in mesa master a while back.

ok matthieu@@
@
text
@a51 1
#include "intel_bufmgr_ttm.h"
a243 10

   if (intelScreen->driScrnPriv->ddx_version.minor >= 9) {
      intelScreen->front.bo_handle = sarea->front_bo_handle;
      intelScreen->back.bo_handle = sarea->back_bo_handle;
      intelScreen->depth.bo_handle = sarea->depth_bo_handle;
   } else {
      intelScreen->front.bo_handle = -1;
      intelScreen->back.bo_handle = -1;
      intelScreen->depth.bo_handle = -1;
   }
@


1.2
log
@Remove "old style" DRI2 entrypoints.

ok matthieu@@.
@
text
@a115 12
   if (intelScreen->third.handle) {
      if (0)
	 _mesa_printf("Third 0x%08x ", intelScreen->third.handle);
      if (drmMap(sPriv->fd,
		 intelScreen->third.handle,
		 intelScreen->third.size,
		 (drmAddress *) & intelScreen->third.map) != 0) {
	 intelUnmapScreenRegions(intelScreen);
	 return GL_FALSE;
      }
   }

d139 2
a140 3
      printf("Mappings:  front: %p  back: %p  third: %p  depth: %p  tex: %p\n",
             intelScreen->front.map,
             intelScreen->back.map, intelScreen->third.map,
a162 7
   if (intelScreen->third.map) {
#if REALLY_UNMAP
      if (drmUnmap(intelScreen->third.map, intelScreen->third.size) != 0)
         printf("drmUnmap third failed!\n");
#endif
      intelScreen->third.map = NULL;
   }
a240 7
   if (intelScreen->driScrnPriv->ddx_version.minor >= 8) {
      intelScreen->third.offset = sarea->third_offset;
      intelScreen->third.handle = sarea->third_handle;
      intelScreen->third.size = sarea->third_size;
      intelScreen->third.tiled = sarea->third_tiled;
   }

a248 1
      intelScreen->third.bo_handle = sarea->third_bo_handle;
a252 1
      intelScreen->third.bo_handle = -1;
a415 7

	 if (screen->third.handle) {
	    struct gl_renderbuffer *tmp_rb = NULL;

	    intel_fb->color_rb[2] = intel_create_renderbuffer(rgbFormat);
	    _mesa_reference_renderbuffer(&tmp_rb, &intel_fb->color_rb[2]->Base);
	 }
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a293 43

/**
 * DRI2 entrypoint
 */
static void
intelHandleDrawableConfig(__DRIdrawablePrivate *dPriv,
			  __DRIcontextPrivate *pcp,
			  __DRIDrawableConfigEvent *event)
{
   struct intel_framebuffer *intel_fb = dPriv->driverPrivate;
   struct intel_region *region = NULL;
   struct intel_renderbuffer *rb, *depth_rb, *stencil_rb;
   struct intel_context *intel = pcp->driverPrivate;
   int cpp, pitch;

   cpp = intel->ctx.Visual.rgbBits / 8;
   pitch = ((cpp * dPriv->w + 63) & ~63) / cpp;

   rb = intel_fb->color_rb[1];
   if (rb) {
      region = intel_region_alloc(intel, cpp, pitch, dPriv->h);
      intel_renderbuffer_set_region(rb, region);
   }

   rb = intel_fb->color_rb[2];
   if (rb) {
      region = intel_region_alloc(intel, cpp, pitch, dPriv->h);
      intel_renderbuffer_set_region(rb, region);
   }

   depth_rb = intel_get_renderbuffer(&intel_fb->Base, BUFFER_DEPTH);
   stencil_rb = intel_get_renderbuffer(&intel_fb->Base, BUFFER_STENCIL);
   if (depth_rb || stencil_rb)
      region = intel_region_alloc(intel, cpp, pitch, dPriv->h);
   if (depth_rb)
      intel_renderbuffer_set_region(depth_rb, region);
   if (stencil_rb)
      intel_renderbuffer_set_region(stencil_rb, region);

   /* FIXME: Tell the X server about the regions we just allocated and
    * attached. */
}

a295 55
/**
 * DRI2 entrypoint
 */
static void
intelHandleBufferAttach(__DRIdrawablePrivate *dPriv,
			__DRIcontextPrivate *pcp,
			__DRIBufferAttachEvent *ba)
{
   struct intel_framebuffer *intel_fb = dPriv->driverPrivate;
   struct intel_renderbuffer *rb;
   struct intel_region *region;
   struct intel_context *intel = pcp->driverPrivate;
   GLuint tiled;

   switch (ba->buffer.attachment) {
   case DRI_DRAWABLE_BUFFER_FRONT_LEFT:
      rb = intel_fb->color_rb[0];
      break;

   case DRI_DRAWABLE_BUFFER_BACK_LEFT:
      rb = intel_fb->color_rb[0];
      break;

   case DRI_DRAWABLE_BUFFER_DEPTH:
     rb = intel_get_renderbuffer(&intel_fb->Base, BUFFER_DEPTH);
     break;

   case DRI_DRAWABLE_BUFFER_STENCIL:
     rb = intel_get_renderbuffer(&intel_fb->Base, BUFFER_STENCIL);
     break;

   case DRI_DRAWABLE_BUFFER_ACCUM:
   default:
      fprintf(stderr, "unhandled buffer attach event, attacment type %d\n",
	      ba->buffer.attachment);
      return;
   }

#if 0
   /* FIXME: Add this so we can filter out when the X server sends us
    * attachment events for the buffers we just allocated.  Need to
    * get the BO handle for a render buffer. */
   if (intel_renderbuffer_get_region_handle(rb) == ba->buffer.handle)
      return;
#endif

   tiled = (ba->buffer.flags & BUFFER_FLAG_TILED) > 0;
   region = intel_region_alloc_for_handle(intel, ba->buffer.cpp,
					  ba->buffer.pitch / ba->buffer.cpp,
					  dPriv->h, tiled,
					  ba->buffer.handle);

   intel_renderbuffer_set_region(rb, region);
}

a701 64
/**
 * This is the driver specific part of the createNewScreen entry point.
 * Called when using DRI2.
 *
 * \return the __GLcontextModes supported by this driver
 */
static const
__DRIconfig **intelInitScreen2(__DRIscreenPrivate *psp)
{
   intelScreenPrivate *intelScreen;

   /* Calling driInitExtensions here, with a NULL context pointer,
    * does not actually enable the extensions.  It just makes sure
    * that all the dispatch offsets for all the extensions that
    * *might* be enables are known.  This is needed because the
    * dispatch offsets need to be known when _mesa_context_create is
    * called, but we can't enable the extensions until we have a
    * context pointer.
    *
    * Hello chicken.  Hello egg.  How are you two today?
    */
   intelInitExtensions(NULL, GL_TRUE);

   /* Allocate the private area */
   intelScreen = (intelScreenPrivate *) CALLOC(sizeof(intelScreenPrivate));
   if (!intelScreen) {
      fprintf(stderr, "\nERROR!  Allocating private area failed\n");
      return GL_FALSE;
   }
   /* parse information in __driConfigOptions */
   driParseOptionInfo(&intelScreen->optionCache,
                      __driConfigOptions, __driNConfigOptions);

   intelScreen->driScrnPriv = psp;
   psp->private = (void *) intelScreen;

   intelScreen->drmMinor = psp->drm_version.minor;

   /* Determine chipset ID? */
   if (!intel_get_param(psp, I915_PARAM_CHIPSET_ID,
			&intelScreen->deviceID))
      return GL_FALSE;

   /* Determine if IRQs are active? */
   if (!intel_get_param(psp, I915_PARAM_IRQ_ACTIVE,
			&intelScreen->irq_active))
      return GL_FALSE;

   /* Determine if batchbuffers are allowed */
   if (!intel_get_param(psp, I915_PARAM_ALLOW_BATCHBUFFER,
			&intelScreen->allow_batchbuffer))
      return GL_FALSE;

   if (!intelScreen->allow_batchbuffer) {
      fprintf(stderr, "batch buffer not allowed\n");
      return GL_FALSE;
   }

   psp->extensions = intelScreenExtensions;

   return driConcatConfigs(intelFillInModes(psp, 16, 16, 0, 1),
			   intelFillInModes(psp, 32, 24, 8, 1));
}

a715 4

   .InitScreen2		 = intelInitScreen2,
   .HandleDrawableConfig = intelHandleDrawableConfig,
   .HandleBufferAttach	 = intelHandleBufferAttach,
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d28 6
a33 7
#include "main/glheader.h"
#include "main/context.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
#include "main/hash.h"
#include "main/fbobject.h"

d35 1
d38 16
d57 1
d62 1
a62 1
      DRI_CONF_OPT_BEGIN_V(bo_reuse, enum, 1, "0:1")
a67 13

      DRI_CONF_OPT_BEGIN(texture_tiling, bool, true)
	 DRI_CONF_DESC(en, "Enable texture tiling")
      DRI_CONF_OPT_END

      DRI_CONF_OPT_BEGIN(early_z, bool, false)
	 DRI_CONF_DESC(en, "Enable early Z in classic mode (unstable, 945-only).")
      DRI_CONF_OPT_END

      DRI_CONF_OPT_BEGIN(fragment_shader, bool, true)
	 DRI_CONF_DESC(en, "Enable limited ARB_fragment_shader support on 915/945.")
      DRI_CONF_OPT_END

a74 6
     DRI_CONF_ALWAYS_FLUSH_BATCH(false)
     DRI_CONF_ALWAYS_FLUSH_CACHE(false)

      DRI_CONF_OPT_BEGIN(stub_occlusion_query, bool, false)
	 DRI_CONF_DESC(en, "Enable stub ARB_occlusion_query support on 915/945.")
      DRI_CONF_OPT_END
d78 1
a78 12
const GLuint __driNConfigOptions = 11;

#include "intel_batchbuffer.h"
#include "intel_buffers.h"
#include "intel_bufmgr.h"
#include "intel_chipset.h"
#include "intel_fbo.h"
#include "intel_screen.h"
#include "intel_tex.h"
#include "intel_regions.h"

#include "i915_drm.h"
d84 31
a114 5
static const __DRItexBufferExtension intelTexBufferExtension = {
    { __DRI_TEX_BUFFER, __DRI_TEX_BUFFER_VERSION },
   intelSetTexBuffer,
   intelSetTexBuffer2,
};
d116 11
a126 4
static void
intelDRI2Flush(__DRIdrawable *drawable)
{
   struct intel_context *intel = drawable->driContextPriv->driverPrivate;
d128 9
a136 2
   if (intel->gen < 4)
      INTEL_FIREVERTICES(intel);
d138 11
a148 1
   intel->need_throttle = GL_TRUE;
d150 6
a155 2
   if (intel->batch->map != intel->batch->ptr)
      intel_batchbuffer_flush(intel->batch);
d158 38
a195 5
static const struct __DRI2flushExtensionRec intelFlushExtension = {
    { __DRI2_FLUSH, __DRI2_FLUSH_VERSION },
    intelDRI2Flush,
    dri2InvalidateDrawable,
};
a196 33
static __DRIimage *
intel_create_image_from_name(__DRIscreen *screen,
			     int width, int height, int format,
			     int name, int pitch, void *loaderPrivate)
{
    struct intel_screen *intelScreen = screen->private;
    __DRIimage *image;
    int cpp;

    image = CALLOC(sizeof *image);
    if (image == NULL)
	return NULL;

    switch (format) {
    case __DRI_IMAGE_FORMAT_RGB565:
       image->format = MESA_FORMAT_RGB565;
       image->internal_format = GL_RGB;
       image->data_type = GL_UNSIGNED_BYTE;
       break;
    case __DRI_IMAGE_FORMAT_XRGB8888:
       image->format = MESA_FORMAT_XRGB8888;
       image->internal_format = GL_RGB;
       image->data_type = GL_UNSIGNED_BYTE;
       break;
    case __DRI_IMAGE_FORMAT_ARGB8888:
       image->format = MESA_FORMAT_ARGB8888;
       image->internal_format = GL_RGBA;
       image->data_type = GL_UNSIGNED_BYTE;
       break;
    default:
       free(image);
       return NULL;
    }
d198 17
a214 2
    image->data = loaderPrivate;
    cpp = _mesa_get_format_bytes(image->format);
a215 7
    image->region = intel_region_alloc_for_handle(intelScreen,
						  cpp, width, height,
						  pitch, name, "image");
    if (image->region == NULL) {
       FREE(image);
       return NULL;
    }
d217 19
a235 1
    return image;	
a237 8
static __DRIimage *
intel_create_image_from_renderbuffer(__DRIcontext *context,
				     int renderbuffer, void *loaderPrivate)
{
   __DRIimage *image;
   struct intel_context *intel = context->driverPrivate;
   struct gl_renderbuffer *rb;
   struct intel_renderbuffer *irb;
d239 44
a282 5
   rb = _mesa_lookup_renderbuffer(&intel->ctx, renderbuffer);
   if (!rb) {
      _mesa_error(&intel->ctx,
		  GL_INVALID_OPERATION, "glRenderbufferExternalMESA");
      return NULL;
d285 4
a288 4
   irb = intel_renderbuffer(rb);
   image = CALLOC(sizeof *image);
   if (image == NULL)
      return NULL;
d290 3
a292 5
   image->internal_format = rb->InternalFormat;
   image->format = rb->Format;
   image->data_type = rb->DataType;
   image->data = loaderPrivate;
   intel_region_reference(&image->region, irb->region);
a293 2
   return image;
}
d295 3
d299 3
a301 1
intel_destroy_image(__DRIimage *image)
d303 5
a307 3
    intel_region_release(&image->region);
    FREE(image);
}
d309 2
a310 9
static __DRIimage *
intel_create_image(__DRIscreen *screen,
		   int width, int height, int format,
		   unsigned int use,
		   void *loaderPrivate)
{
   __DRIimage *image;
   struct intel_screen *intelScreen = screen->private;
   int cpp;
d312 5
a316 3
   image = CALLOC(sizeof *image);
   if (image == NULL)
      return NULL;
d318 4
a321 19
   switch (format) {
   case __DRI_IMAGE_FORMAT_RGB565:
      image->format = MESA_FORMAT_RGB565;
      image->internal_format = GL_RGB;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   case __DRI_IMAGE_FORMAT_XRGB8888:
      image->format = MESA_FORMAT_XRGB8888;
      image->internal_format = GL_RGB;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   case __DRI_IMAGE_FORMAT_ARGB8888:
      image->format = MESA_FORMAT_ARGB8888;
      image->internal_format = GL_RGBA;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   default:
      free(image);
      return NULL;
d324 8
a331 2
   image->data = loaderPrivate;
   cpp = _mesa_get_format_bytes(image->format);
d333 2
a334 9
   image->region =
      intel_region_alloc(intelScreen, I915_TILING_NONE,
			 cpp, width, height, GL_TRUE);
   if (image->region == NULL) {
      FREE(image);
      return NULL;
   }
   
   return image;
d337 9
a345 2
static GLboolean
intel_query_image(__DRIimage *image, int attrib, int *value)
d347 24
a370 9
   switch (attrib) {
   case __DRI_IMAGE_ATTRIB_STRIDE:
      *value = image->region->pitch * image->region->cpp;
      return GL_TRUE;
   case __DRI_IMAGE_ATTRIB_HANDLE:
      *value = image->region->buffer->handle;
      return GL_TRUE;
   case __DRI_IMAGE_ATTRIB_NAME:
      return intel_region_flink(image->region, (uint32_t *) value);
d372 3
a374 1
      return GL_FALSE;
d376 16
d394 8
a401 7
static struct __DRIimageExtensionRec intelImageExtension = {
    { __DRI_IMAGE, __DRI_IMAGE_VERSION },
    intel_create_image_from_name,
    intel_create_image_from_renderbuffer,
    intel_destroy_image,
    intel_create_image,
    intel_query_image
d406 5
a411 3
    &intelFlushExtension.base,
    &intelImageExtension.base,
    &dri2ConfigQueryExtension.base,
d416 1
a416 1
intel_get_param(__DRIscreen *psp, int param, int *value)
d426 1
a426 1
      _mesa_warning(NULL, "drm_i915_getparam: %d", ret);
d433 1
a433 2
static void
nop_callback(GLuint key, void *data, void *userData)
d435 57
d494 1
d496 1
a496 1
intelDestroyScreen(__DRIscreen * sPriv)
d498 1
a498 1
   struct intel_screen *intelScreen = sPriv->private;
d500 1
a500 8
   dri_bufmgr_destroy(intelScreen->bufmgr);
   driDestroyOptionInfo(&intelScreen->optionCache);

   /* Some regions may still have references to them at this point, so
    * flush the hash table to prevent _mesa_DeleteHashTable() from
    * complaining about the hash not being empty; */
   _mesa_HashDeleteAll(intelScreen->named_regions, nop_callback, NULL);
   _mesa_DeleteHashTable(intelScreen->named_regions);
d511 3
a513 3
intelCreateBuffer(__DRIscreen * driScrnPriv,
                  __DRIdrawable * driDrawPriv,
                  const struct gl_config * mesaVis, GLboolean isPixmap)
d515 1
a515 1
   struct intel_renderbuffer *rb;
d523 1
a523 1
      gl_format rgbFormat;
d525 1
a525 1
      struct gl_framebuffer *fb = CALLOC_STRUCT(gl_framebuffer);
d527 1
a527 1
      if (!fb)
d530 1
a530 8
      _mesa_initialize_window_framebuffer(fb, mesaVis);

      if (mesaVis->redBits == 5)
	 rgbFormat = MESA_FORMAT_RGB565;
      else if (mesaVis->alphaBits == 0)
	 rgbFormat = MESA_FORMAT_XRGB8888;
      else
	 rgbFormat = MESA_FORMAT_ARGB8888;
d533 5
a537 2
      rb = intel_create_renderbuffer(rgbFormat);
      _mesa_add_renderbuffer(fb, BUFFER_FRONT_LEFT, &rb->Base);
d540 10
a549 2
	 rb = intel_create_renderbuffer(rgbFormat);
         _mesa_add_renderbuffer(fb, BUFFER_BACK_LEFT, &rb->Base);
d553 15
a567 7
	 assert(mesaVis->stencilBits == 8);
	 /* combined depth/stencil buffer */
	 struct intel_renderbuffer *depthStencilRb
	    = intel_create_renderbuffer(MESA_FORMAT_S8_Z24);
	 /* note: bind RB to two attachment points */
	 _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthStencilRb->Base);
	 _mesa_add_renderbuffer(fb, BUFFER_STENCIL, &depthStencilRb->Base);
d572 2
a573 2
	    = intel_create_renderbuffer(MESA_FORMAT_Z16);
         _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthRb->Base);
d577 1
a577 1
      _mesa_add_soft_renderbuffers(fb,
d583 1
a583 1
      driDrawPriv->driverPrivate = fb;
d590 1
a590 1
intelDestroyBuffer(__DRIdrawable * driDrawPriv)
d592 1
a592 3
    struct gl_framebuffer *fb = driDrawPriv->driverPrivate;
  
    _mesa_reference_framebuffer(&fb, NULL);
d595 27
d626 2
a627 2
extern GLboolean i830CreateContext(const struct gl_config * mesaVis,
                                   __DRIcontext * driContextPriv,
d630 2
a631 3
extern GLboolean i915CreateContext(int api,
				   const struct gl_config * mesaVis,
                                   __DRIcontext * driContextPriv,
d633 2
a634 3
extern GLboolean brwCreateContext(int api,
				  const struct gl_config * mesaVis,
				  __DRIcontext * driContextPriv,
d638 2
a639 3
intelCreateContext(gl_api api,
		   const struct gl_config * mesaVis,
                   __DRIcontext * driContextPriv,
d642 2
a643 2
   __DRIscreen *sPriv = driContextPriv->driScreenPriv;
   struct intel_screen *intelScreen = sPriv->private;
d648 1
a648 1
	 return i915CreateContext(api, mesaVis, driContextPriv,
a651 1
      intelScreen->no_vbo = GL_TRUE;
d656 1
a656 2
      return brwCreateContext(api, mesaVis,
			      driContextPriv, sharedContextPrivate);
d658 1
a658 1
   fprintf(stderr, "Unrecognized deviceID 0x%x\n", intelScreen->deviceID);
a661 5
static GLboolean
intel_init_bufmgr(struct intel_screen *intelScreen)
{
   __DRIscreen *spriv = intelScreen->driScrnPriv;
   int num_fences = 0;
d663 59
a721 2
   intelScreen->no_hw = (getenv("INTEL_NO_HW") != NULL ||
			 getenv("INTEL_DEVID_OVERRIDE") != NULL);
d723 7
a729 5
   intelScreen->bufmgr = intel_bufmgr_gem_init(spriv->fd, BATCH_SZ);
   if (intelScreen->bufmgr == NULL) {
      fprintf(stderr, "[%s:%u] Error initializing buffer manager.\n",
	      __func__, __LINE__);
      return GL_FALSE;
d732 28
a759 4
   if (!intel_get_param(spriv, I915_PARAM_NUM_FENCES_AVAIL, &num_fences) ||
       num_fences == 0) {
      fprintf(stderr, "[%s: %u] Kernel 2.6.29 required.\n", __func__, __LINE__);
      return GL_FALSE;
d762 14
a775 1
   drm_intel_bufmgr_gem_enable_fenced_relocs(intelScreen->bufmgr);
d777 1
a777 1
   intelScreen->named_regions = _mesa_NewHashTable();
d779 19
a797 1
   return GL_TRUE;
d804 1
a804 1
 * \return the struct gl_config supported by this driver
d807 1
a807 1
__DRIconfig **intelInitScreen2(__DRIscreen *psp)
d809 1
a809 5
   struct intel_screen *intelScreen;
   GLenum fb_format[3];
   GLenum fb_type[3];
   unsigned int api_mask;
   char *devid_override;
d811 11
a821 6
   static const GLenum back_buffer_modes[] = {
       GLX_NONE, GLX_SWAP_UNDEFINED_OML, GLX_SWAP_COPY_OML
   };
   uint8_t depth_bits[4], stencil_bits[4], msaa_samples_array[1];
   int color;
   __DRIconfig **configs = NULL;
d824 1
a824 1
   intelScreen = CALLOC(sizeof *intelScreen);
d836 3
a838 1
   /* Determine chipset ID */
d843 4
a846 9
   /* Allow an override of the device ID for the purpose of making the
    * driver produce dumps for debugging of new chipset enablement.
    * This implies INTEL_NO_HW, to avoid programming your actual GPU
    * incorrectly.
    */
   devid_override = getenv("INTEL_DEVID_OVERRIDE");
   if (devid_override) {
      intelScreen->deviceID = strtod(devid_override, NULL);
   }
d848 4
a851 7
   api_mask = (1 << __DRI_API_OPENGL);
#if FEATURE_ES1
   api_mask |= (1 << __DRI_API_GLES);
#endif
#if FEATURE_ES2
   api_mask |= (1 << __DRI_API_GLES2);
#endif
d853 4
a856 5
   if (IS_9XX(intelScreen->deviceID) || IS_965(intelScreen->deviceID))
      psp->api_mask = api_mask;

   if (!intel_init_bufmgr(intelScreen))
       return GL_FALSE;
d860 2
a861 82
   msaa_samples_array[0] = 0;

   fb_format[0] = GL_RGB;
   fb_type[0] = GL_UNSIGNED_SHORT_5_6_5;

   fb_format[1] = GL_BGR;
   fb_type[1] = GL_UNSIGNED_INT_8_8_8_8_REV;

   fb_format[2] = GL_BGRA;
   fb_type[2] = GL_UNSIGNED_INT_8_8_8_8_REV;

   depth_bits[0] = 0;
   stencil_bits[0] = 0;

   /* Generate a rich set of useful configs that do not include an
    * accumulation buffer.
    */
   for (color = 0; color < ARRAY_SIZE(fb_format); color++) {
      __DRIconfig **new_configs;
      int depth_factor;

      /* Starting with DRI2 protocol version 1.1 we can request a depth/stencil
       * buffer that has a diffferent number of bits per pixel than the color
       * buffer.  This isn't yet supported here.
       */
      if (fb_type[color] == GL_UNSIGNED_SHORT_5_6_5) {
	 depth_bits[1] = 16;
	 stencil_bits[1] = 0;
      } else {
	 depth_bits[1] = 24;
	 stencil_bits[1] = 8;
      }

      depth_factor = 2;

      new_configs = driCreateConfigs(fb_format[color], fb_type[color],
				     depth_bits,
				     stencil_bits,
				     depth_factor,
				     back_buffer_modes,
				     ARRAY_SIZE(back_buffer_modes),
				     msaa_samples_array,
				     ARRAY_SIZE(msaa_samples_array),
				     GL_FALSE);
      if (configs == NULL)
	 configs = new_configs;
      else
	 configs = driConcatConfigs(configs, new_configs);
   }

   /* Generate the minimum possible set of configs that include an
    * accumulation buffer.
    */
   for (color = 0; color < ARRAY_SIZE(fb_format); color++) {
      __DRIconfig **new_configs;

      if (fb_type[color] == GL_UNSIGNED_SHORT_5_6_5) {
	 depth_bits[0] = 16;
	 stencil_bits[0] = 0;
      } else {
	 depth_bits[0] = 24;
	 stencil_bits[0] = 8;
      }

      new_configs = driCreateConfigs(fb_format[color], fb_type[color],
				     depth_bits, stencil_bits, 1,
				     back_buffer_modes + 1, 1,
				     msaa_samples_array, 1,
				     GL_TRUE);
      if (configs == NULL)
	 configs = new_configs;
      else
	 configs = driConcatConfigs(configs, new_configs);
   }

   if (configs == NULL) {
      fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
              __LINE__);
      return NULL;
   }

   return (const __DRIconfig **)configs;
d865 1
d871 1
d874 5
d880 2
a881 7
};

/* This is the table of extensions that the loader will dlsym() for. */
PUBLIC const __DRIextension *__driDriverExtensions[] = {
    &driCoreExtension.base,
    &driDRI2Extension.base,
    NULL
@


