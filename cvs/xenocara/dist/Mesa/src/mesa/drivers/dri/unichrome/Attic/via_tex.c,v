head	1.7;
access;
symbols
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.09.05.14.05.55;	author jsg;	state dead;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.19;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.54.12;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.54.12;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.39;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.43;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@/*
 * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
 * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sub license,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */


#include <stdlib.h>
#include <stdio.h>

#include "main/glheader.h"
#include "main/macros.h"
#include "main/mtypes.h"
#include "main/enums.h"
#include "main/formats.h"
#include "main/context.h"
#include "main/mipmap.h"
#include "main/mm.h"
#include "main/pbo.h"
#include "main/simple_list.h"
#include "main/texobj.h"
#include "main/texstore.h"

#include "via_context.h"
#include "via_fb.h"
#include "via_tex.h"
#include "via_ioctl.h"
#include "via_3d_reg.h"

static gl_format
viaChooseTexFormat( struct gl_context *ctx, GLint internalFormat,
		    GLenum format, GLenum type )
{
   struct via_context *vmesa = VIA_CONTEXT(ctx);
   const GLboolean do32bpt = ( vmesa->viaScreen->bitsPerPixel == 32
/* 			       && vmesa->viaScreen->textureSize > 4*1024*1024 */
      );


   switch ( internalFormat ) {
   case 4:
   case GL_RGBA:
   case GL_COMPRESSED_RGBA:
      if ( format == GL_BGRA ) {
	 if ( type == GL_UNSIGNED_INT_8_8_8_8_REV ||
	      type == GL_UNSIGNED_BYTE ) {
	    return MESA_FORMAT_ARGB8888;
	 }
         else if ( type == GL_UNSIGNED_SHORT_4_4_4_4_REV ) {
            return MESA_FORMAT_ARGB4444;
	 }
         else if ( type == GL_UNSIGNED_SHORT_1_5_5_5_REV ) {
	    return MESA_FORMAT_ARGB1555;
	 }
      }
      else if ( type == GL_UNSIGNED_BYTE ||
		type == GL_UNSIGNED_INT_8_8_8_8_REV ||
		type == GL_UNSIGNED_INT_8_8_8_8 ) {
	 return MESA_FORMAT_ARGB8888;
      }
      return do32bpt ? MESA_FORMAT_ARGB8888 : MESA_FORMAT_ARGB4444;

   case 3:
   case GL_RGB:
   case GL_COMPRESSED_RGB:
      if ( format == GL_RGB && type == GL_UNSIGNED_SHORT_5_6_5 ) {
	 return MESA_FORMAT_RGB565;
      }
      else if ( type == GL_UNSIGNED_BYTE ) {
	 return MESA_FORMAT_ARGB8888;
      }
      return do32bpt ? MESA_FORMAT_ARGB8888 : MESA_FORMAT_RGB565;

   case GL_RGBA8:
   case GL_RGB10_A2:
   case GL_RGBA12:
   case GL_RGBA16:
      return MESA_FORMAT_ARGB8888;

   case GL_RGBA4:
   case GL_RGBA2:
      return MESA_FORMAT_ARGB4444;

   case GL_RGB5_A1:
      return MESA_FORMAT_ARGB1555;

   case GL_RGB8:
   case GL_RGB10:
   case GL_RGB12:
   case GL_RGB16:
      return MESA_FORMAT_ARGB8888;

   case GL_RGB5:
   case GL_RGB4:
   case GL_R3_G3_B2:
      return MESA_FORMAT_RGB565;

   case GL_ALPHA:
   case GL_ALPHA4:
   case GL_ALPHA8:
   case GL_ALPHA12:
   case GL_ALPHA16:
   case GL_COMPRESSED_ALPHA:
      return MESA_FORMAT_A8;

   case 1:
   case GL_LUMINANCE:
   case GL_LUMINANCE4:
   case GL_LUMINANCE8:
   case GL_LUMINANCE12:
   case GL_LUMINANCE16:
   case GL_COMPRESSED_LUMINANCE:
      return MESA_FORMAT_L8;

   case 2:
   case GL_LUMINANCE_ALPHA:
   case GL_LUMINANCE4_ALPHA4:
   case GL_LUMINANCE6_ALPHA2:
   case GL_LUMINANCE8_ALPHA8:
   case GL_LUMINANCE12_ALPHA4:
   case GL_LUMINANCE12_ALPHA12:
   case GL_LUMINANCE16_ALPHA16:
   case GL_COMPRESSED_LUMINANCE_ALPHA:
      return MESA_FORMAT_AL88;

   case GL_INTENSITY:
   case GL_INTENSITY4:
   case GL_INTENSITY8:
   case GL_INTENSITY12:
   case GL_INTENSITY16:
   case GL_COMPRESSED_INTENSITY:
      return MESA_FORMAT_I8;

   case GL_YCBCR_MESA:
      if (type == GL_UNSIGNED_SHORT_8_8_MESA ||
	  type == GL_UNSIGNED_BYTE)
         return MESA_FORMAT_YCBCR;
      else
         return MESA_FORMAT_YCBCR_REV;

   case GL_COMPRESSED_RGB_FXT1_3DFX:
      return MESA_FORMAT_RGB_FXT1;
   case GL_COMPRESSED_RGBA_FXT1_3DFX:
      return MESA_FORMAT_RGBA_FXT1;

   case GL_RGB_S3TC:
   case GL_RGB4_S3TC:
   case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
      return MESA_FORMAT_RGB_DXT1;

   case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
      return MESA_FORMAT_RGBA_DXT1;

   case GL_RGBA_S3TC:
   case GL_RGBA4_S3TC:
   case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
      return MESA_FORMAT_RGBA_DXT3;

   case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
      return MESA_FORMAT_RGBA_DXT5;

   case GL_COLOR_INDEX:	
   case GL_COLOR_INDEX1_EXT:	
   case GL_COLOR_INDEX2_EXT:	
   case GL_COLOR_INDEX4_EXT:	
   case GL_COLOR_INDEX8_EXT:	
   case GL_COLOR_INDEX12_EXT:	    
   case GL_COLOR_INDEX16_EXT:
      return MESA_FORMAT_CI8;

   default:
      fprintf(stderr, "unexpected texture format %s in %s\n", 
	      _mesa_lookup_enum_by_nr(internalFormat),
	      __FUNCTION__);
      return MESA_FORMAT_NONE;
   }

   return MESA_FORMAT_NONE; /* never get here */
}


static const char *get_memtype_name( GLint memType )
{
   static const char *names[] = {
      "VIA_MEM_VIDEO",
      "VIA_MEM_AGP",
      "VIA_MEM_SYSTEM",
      "VIA_MEM_MIXED",
      "VIA_MEM_UNKNOWN"
   };

   return names[memType];
}


static GLboolean viaMoveTexBuffers( struct via_context *vmesa,
				    struct via_tex_buffer **buffers,
				    GLuint nr,
				    GLint newMemType )
{
   struct via_tex_buffer *newTexBuf[VIA_MAX_TEXLEVELS];
   GLint i;

   if (VIA_DEBUG & DEBUG_TEXTURE)
      fprintf(stderr, "%s to %s\n",
	      __FUNCTION__,
	      get_memtype_name(newMemType));

   memset(newTexBuf, 0, sizeof(newTexBuf));

   /* First do all the allocations (or fail):
    */ 
   for (i = 0; i < nr; i++) {    
      if (buffers[i]->memType != newMemType) {	 

	 /* Don't allow uploads in a thrash state.  Should try and
	  * catch this earlier.
	  */
	 if (vmesa->thrashing && newMemType != VIA_MEM_SYSTEM)
	    goto cleanup;

	 newTexBuf[i] = via_alloc_texture(vmesa, 
					  buffers[i]->size,
					  newMemType);
	 if (!newTexBuf[i]) 
	    goto cleanup;
      }
   }


   /* Now copy all the image data and free the old texture memory.
    */
   for (i = 0; i < nr; i++) {    
      if (newTexBuf[i]) {
	 memcpy(newTexBuf[i]->bufAddr,
		buffers[i]->bufAddr, 
		buffers[i]->size);

	 newTexBuf[i]->image = buffers[i]->image;
	 newTexBuf[i]->image->texMem = newTexBuf[i];
	 newTexBuf[i]->image->image.Data = newTexBuf[i]->bufAddr;
	 via_free_texture(vmesa, buffers[i]);
      }
   }

   if (VIA_DEBUG & DEBUG_TEXTURE)
      fprintf(stderr, "%s - success\n", __FUNCTION__);

   return GL_TRUE;

 cleanup:
   /* Release any allocations made prior to failure:
    */
   if (VIA_DEBUG & DEBUG_TEXTURE)
      fprintf(stderr, "%s - failed\n", __FUNCTION__);

   for (i = 0; i < nr; i++) {    
      if (newTexBuf[i]) {
	 via_free_texture(vmesa, newTexBuf[i]);
      }
   }
   
   return GL_FALSE;   
}


static GLboolean viaMoveTexObject( struct via_context *vmesa,
				   struct via_texture_object *viaObj,
				   GLint newMemType )
{   
   struct via_texture_image **viaImage = 
      (struct via_texture_image **)&viaObj->obj.Image[0][0];
   struct via_tex_buffer *buffers[VIA_MAX_TEXLEVELS];
   GLuint i, nr = 0;

   for (i = viaObj->firstLevel; i <= viaObj->lastLevel; i++)
      buffers[nr++] = viaImage[i]->texMem;

   if (viaMoveTexBuffers( vmesa, &buffers[0], nr, newMemType )) {
      viaObj->memType = newMemType;
      return GL_TRUE;
   }

   return GL_FALSE;
}



static GLboolean viaSwapInTexObject( struct via_context *vmesa,
				     struct via_texture_object *viaObj )
{
   const struct via_texture_image *baseImage = 
      (struct via_texture_image *)viaObj->obj.Image[0][viaObj->obj.BaseLevel]; 

   if (VIA_DEBUG & DEBUG_TEXTURE)
      fprintf(stderr, "%s\n", __FUNCTION__);

   if (baseImage->texMem->memType != VIA_MEM_SYSTEM) 
      return viaMoveTexObject( vmesa, viaObj, baseImage->texMem->memType );

   return (viaMoveTexObject( vmesa, viaObj, VIA_MEM_AGP ) ||
	   viaMoveTexObject( vmesa, viaObj, VIA_MEM_VIDEO ));
}


/* This seems crude, but it asks a fairly pertinent question and gives
 * an accurate answer:
 */
static GLboolean viaIsTexMemLow( struct via_context *vmesa,
				 GLuint heap )
{
   struct via_tex_buffer *buf =  via_alloc_texture(vmesa, 512 * 1024, heap );
   if (!buf)
      return GL_TRUE;
   
   via_free_texture(vmesa, buf);
   return GL_FALSE;
}


/* Speculatively move texture images which haven't been used in a
 * while back to system memory. 
 * 
 * TODO: only do this when texture memory is low.
 * 
 * TODO: use dma.
 *
 * TODO: keep the fb/agp version hanging around and use the local
 * version as backing store, so re-upload might be avoided.
 *
 * TODO: do this properly in the kernel...
 */
GLboolean viaSwapOutWork( struct via_context *vmesa )
{
   struct via_tex_buffer *s, *tmp;
   GLuint done = 0;
   GLuint heap, target;

   if (VIA_DEBUG & DEBUG_TEXTURE)
      fprintf(stderr, "%s VID %d AGP %d SYS %d\n", __FUNCTION__,
	      vmesa->total_alloc[VIA_MEM_VIDEO],
	      vmesa->total_alloc[VIA_MEM_AGP],
	      vmesa->total_alloc[VIA_MEM_SYSTEM]);

   
   for (heap = VIA_MEM_VIDEO; heap <= VIA_MEM_AGP; heap++) {
      GLuint nr = 0, sz = 0;

      if (vmesa->thrashing) {
 	 if (VIA_DEBUG & DEBUG_TEXTURE)
	    fprintf(stderr, "Heap %d: trash flag\n", heap);
	 target = 1*1024*1024;
      }
      else if (viaIsTexMemLow(vmesa, heap)) {
 	 if (VIA_DEBUG & DEBUG_TEXTURE)
	    fprintf(stderr, "Heap %d: low memory\n", heap);
	 target = 64*1024;
      }
      else {
 	 if (VIA_DEBUG & DEBUG_TEXTURE)
	    fprintf(stderr, "Heap %d: nothing to do\n", heap);
	 continue;
      }

      foreach_s( s, tmp, &vmesa->tex_image_list[heap] ) {
	 if (s->lastUsed < vmesa->lastSwap[1]) {
	    struct via_texture_object *viaObj = 
	       (struct via_texture_object *) s->image->image.TexObject;

	    if (VIA_DEBUG & DEBUG_TEXTURE)
	       fprintf(stderr, 
		       "back copy tex sz %d, lastUsed %d lastSwap %d\n", 
		       s->size, s->lastUsed, vmesa->lastSwap[1]);

	    if (viaMoveTexBuffers( vmesa, &s, 1, VIA_MEM_SYSTEM )) {
	       viaObj->memType = VIA_MEM_MIXED;
	       done += s->size;
	    }
	    else {
	       if (VIA_DEBUG & DEBUG_TEXTURE)
		  fprintf(stderr, "Failed to back copy texture!\n");
	       sz += s->size;
	    }
	 }
	 else {
	    nr ++;
	    sz += s->size;
	 }

	 if (done > target) {
	    vmesa->thrashing = GL_FALSE; /* might not get set otherwise? */
	    return GL_TRUE;
	 }
      }

      assert(sz == vmesa->total_alloc[heap]);
	 
      if (VIA_DEBUG & DEBUG_TEXTURE)
	 fprintf(stderr, "Heap %d: nr %d tot sz %d\n", heap, nr, sz);
   }

   
   return done != 0;
}



/* Basically, just collect the image dimensions and addresses for each
 * image and update the texture object state accordingly.
 */
static GLboolean viaSetTexImages(struct gl_context *ctx,
				 struct gl_texture_object *texObj)
{
   struct via_context *vmesa = VIA_CONTEXT(ctx);
   struct via_texture_object *viaObj = (struct via_texture_object *)texObj;
   const struct via_texture_image *baseImage = 
      (struct via_texture_image *)texObj->Image[0][texObj->BaseLevel];
   GLint firstLevel, lastLevel, numLevels;
   GLuint texFormat;
   GLint w, h, p;
   GLint i, j = 0, k = 0, l = 0, m = 0;
   GLuint texBase;
   GLuint basH = 0;
   GLuint widthExp = 0;
   GLuint heightExp = 0;    

   switch (baseImage->image.TexFormat) {
   case MESA_FORMAT_ARGB8888:
      texFormat = HC_HTXnFM_ARGB8888;
      break;
   case MESA_FORMAT_ARGB4444:
      texFormat = HC_HTXnFM_ARGB4444; 
      break;
   case MESA_FORMAT_RGB565:
      texFormat = HC_HTXnFM_RGB565;   
      break;
   case MESA_FORMAT_ARGB1555:
      texFormat = HC_HTXnFM_ARGB1555;   
      break;
   case MESA_FORMAT_RGB888:
      texFormat = HC_HTXnFM_ARGB0888;
      break;
   case MESA_FORMAT_L8:
      texFormat = HC_HTXnFM_L8;       
      break;
   case MESA_FORMAT_I8:
      texFormat = HC_HTXnFM_T8;       
      break;
   case MESA_FORMAT_CI8:
      texFormat = HC_HTXnFM_Index8;   
      break;
   case MESA_FORMAT_AL88:
      texFormat = HC_HTXnFM_AL88;     
      break;
   case MESA_FORMAT_A8:
      texFormat = HC_HTXnFM_A8;     
      break;
   default:
      _mesa_problem(vmesa->glCtx, "Bad texture format in viaSetTexImages");
      return GL_FALSE;
   }

   /* Compute which mipmap levels we really want to send to the hardware.
    * This depends on the base image size, GL_TEXTURE_MIN_LOD,
    * GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, and GL_TEXTURE_MAX_LEVEL.
    * Yes, this looks overly complicated, but it's all needed.
    */
   if (texObj->Sampler.MinFilter == GL_LINEAR || texObj->Sampler.MinFilter == GL_NEAREST) {
      firstLevel = lastLevel = texObj->BaseLevel;
   }
   else {
      firstLevel = texObj->BaseLevel + (GLint)(texObj->Sampler.MinLod + 0.5);
      firstLevel = MAX2(firstLevel, texObj->BaseLevel);
      lastLevel = texObj->BaseLevel + (GLint)(texObj->Sampler.MaxLod + 0.5);
      lastLevel = MAX2(lastLevel, texObj->BaseLevel);
      lastLevel = MIN2(lastLevel, texObj->BaseLevel + baseImage->image.MaxLog2);
      lastLevel = MIN2(lastLevel, texObj->MaxLevel);
      lastLevel = MAX2(firstLevel, lastLevel);     /* need at least one level */
   }

   numLevels = lastLevel - firstLevel + 1;

   /* The hardware supports only 10 mipmap levels; ignore higher levels.
    */
   if ((numLevels > 10) && (ctx->Const.MaxTextureLevels > 10)) {
       lastLevel -= numLevels - 10;
       numLevels = 10;
   }

   /* save these values, check if they effect the residency of the
    * texture:
    */
   if (viaObj->firstLevel != firstLevel ||
       viaObj->lastLevel != lastLevel) {
      viaObj->firstLevel = firstLevel;
      viaObj->lastLevel = lastLevel;
      viaObj->memType = VIA_MEM_MIXED;
   }

   if (VIA_DEBUG & DEBUG_TEXTURE & 0)
      fprintf(stderr, "%s, current memType: %s\n",
	      __FUNCTION__,
	      get_memtype_name(viaObj->memType));

   
   if (viaObj->memType == VIA_MEM_MIXED ||
       viaObj->memType == VIA_MEM_SYSTEM) {
      if (!viaSwapInTexObject(vmesa, viaObj)) {
 	 if (VIA_DEBUG & DEBUG_TEXTURE) 
	    if (!vmesa->thrashing)
	       fprintf(stderr, "Thrashing flag set for frame %d\n", 
		       vmesa->swap_count);
	 vmesa->thrashing = GL_TRUE;
	 return GL_FALSE;
      }
   }

   if (viaObj->memType == VIA_MEM_AGP)
      viaObj->regTexFM = (HC_SubA_HTXnFM << 24) | HC_HTXnLoc_AGP | texFormat;
   else
      viaObj->regTexFM = (HC_SubA_HTXnFM << 24) | HC_HTXnLoc_Local | texFormat;


   for (i = 0; i < numLevels; i++) {    
      struct via_texture_image *viaImage = 
	 (struct via_texture_image *)texObj->Image[0][firstLevel + i];

      w = viaImage->image.WidthLog2;
      h = viaImage->image.HeightLog2;
      p = viaImage->pitchLog2;

      assert(viaImage->texMem->memType == viaObj->memType);

      texBase = viaImage->texMem->texBase;
      if (!texBase) {
	 if (VIA_DEBUG & DEBUG_TEXTURE)
	    fprintf(stderr, "%s: no texBase[%d]\n", __FUNCTION__, i); 
	 return GL_FALSE;
      }

      /* Image has to remain resident until the coming fence is retired.
       */
      move_to_head( &vmesa->tex_image_list[viaImage->texMem->memType],
		    viaImage->texMem );
      viaImage->texMem->lastUsed = vmesa->lastBreadcrumbWrite;


      viaObj->regTexBaseAndPitch[i].baseL = 
	 ((HC_SubA_HTXnL0BasL + i) << 24) | (texBase & 0xFFFFFF);

      viaObj->regTexBaseAndPitch[i].pitchLog2 = 
	 ((HC_SubA_HTXnL0Pit + i) << 24) | (p << 20);
					      
					      
      /* The base high bytes for each 3 levels are packed
       * together into one register:
       */
      j = i / 3;
      k = 3 - (i % 3);
      basH |= ((texBase & 0xFF000000) >> (k << 3));
      if (k == 1) {
	 viaObj->regTexBaseH[j] = ((j + HC_SubA_HTXnL012BasH) << 24) | basH;
	 basH = 0;
      }
            
      /* Likewise, sets of 6 log2width and log2height values are
       * packed into individual registers:
       */
      l = i / 6;
      m = i % 6;
      widthExp |= (((GLuint)w & 0xF) << (m << 2));
      heightExp |= (((GLuint)h & 0xF) << (m << 2));
      if (m == 5) {
	 viaObj->regTexWidthLog2[l] = 
	    (l + HC_SubA_HTXnL0_5WE) << 24 | widthExp;
	 viaObj->regTexHeightLog2[l] = 
	    (l + HC_SubA_HTXnL0_5HE) << 24 | heightExp;
	 widthExp = 0;
	 heightExp = 0;
      }
      if (w) w--;
      if (h) h--;
      if (p) p--;                                           
   }
        
   if (k != 1) {
      viaObj->regTexBaseH[j] = ((j + HC_SubA_HTXnL012BasH) << 24) | basH;      
   }
   if (m != 5) {
      viaObj->regTexWidthLog2[l] = (l + HC_SubA_HTXnL0_5WE) << 24 | widthExp;
      viaObj->regTexHeightLog2[l] = (l + HC_SubA_HTXnL0_5HE) << 24 | heightExp;
   }

   return GL_TRUE;
}


GLboolean viaUpdateTextureState( struct gl_context *ctx )
{
   struct gl_texture_unit *texUnit = ctx->Texture.Unit;
   GLuint i;

   for (i = 0; i < 2; i++) {   
      if (texUnit[i]._ReallyEnabled == TEXTURE_2D_BIT || 
	  texUnit[i]._ReallyEnabled == TEXTURE_1D_BIT) {

	 if (!viaSetTexImages(ctx, texUnit[i]._Current)) 
	    return GL_FALSE;
      }
      else if (texUnit[i]._ReallyEnabled) {
	 return GL_FALSE;
      } 
   }
   
   return GL_TRUE;
}





				 


static void viaTexImage(struct gl_context *ctx, 
			GLint dims,
			GLenum target, GLint level,
			GLint internalFormat,
			GLint width, GLint height, GLint border,
			GLenum format, GLenum type, const void *pixels,
			const struct gl_pixelstore_attrib *packing,
			struct gl_texture_object *texObj,
			struct gl_texture_image *texImage)
{
   struct via_context *vmesa = VIA_CONTEXT(ctx);
   GLint postConvWidth = width;
   GLint postConvHeight = height;
   GLint texelBytes, sizeInBytes;
   struct via_texture_object *viaObj = (struct via_texture_object *)texObj;
   struct via_texture_image *viaImage = (struct via_texture_image *)texImage;
   int heaps[3], nheaps, i;

   if (!is_empty_list(&vmesa->freed_tex_buffers)) {
      viaCheckBreadcrumb(vmesa, 0);
      via_release_pending_textures(vmesa);
   }

   /* choose the texture format */
   texImage->TexFormat = viaChooseTexFormat(ctx, internalFormat, 
					    format, type);

   assert(texImage->TexFormat);

   texelBytes = _mesa_get_format_bytes(texImage->TexFormat);

   /* Minimum pitch of 32 bytes */
   if (postConvWidth * texelBytes < 32) {
      postConvWidth = 32 / texelBytes;
      texImage->RowStride = postConvWidth;
   }

   assert(texImage->RowStride == postConvWidth);
   viaImage->pitchLog2 = _mesa_logbase2(postConvWidth * texelBytes);

   /* allocate memory */
   if (_mesa_is_format_compressed(texImage->TexFormat))
      sizeInBytes = _mesa_format_image_size(texImage->TexFormat,
                                            texImage->Width,
                                            texImage->Height,
                                            texImage->Depth);
   else
      sizeInBytes = postConvWidth * postConvHeight * texelBytes;


   /* Attempt to allocate texture memory directly, otherwise use main
    * memory and this texture will always be a fallback.   FIXME!
    *
    * TODO: make room in agp if this fails.
    * TODO: use fb ram for textures as well.
    */
   
      
   switch (viaObj->memType) {
   case VIA_MEM_UNKNOWN:
      heaps[0] = VIA_MEM_AGP;
      heaps[1] = VIA_MEM_VIDEO;
      heaps[2] = VIA_MEM_SYSTEM;
      nheaps = 3;
      break;
   case VIA_MEM_AGP:
   case VIA_MEM_VIDEO:
      heaps[0] = viaObj->memType;
      heaps[1] = VIA_MEM_SYSTEM;
      nheaps = 2;
      break;
   case VIA_MEM_MIXED:
   case VIA_MEM_SYSTEM:
   default:
      heaps[0] = VIA_MEM_SYSTEM;
      nheaps = 1;
      break;
   }
	
   for (i = 0; i < nheaps && !viaImage->texMem; i++) {
      if (VIA_DEBUG & DEBUG_TEXTURE) 
	 fprintf(stderr, "try %s (obj %s)\n", get_memtype_name(heaps[i]),
		 get_memtype_name(viaObj->memType));
      viaImage->texMem = via_alloc_texture(vmesa, sizeInBytes, heaps[i]);
   }

   if (!viaImage->texMem) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage");
      return;
   }

   if (VIA_DEBUG & DEBUG_TEXTURE)
      fprintf(stderr, "upload %d bytes to %s\n", sizeInBytes, 
	      get_memtype_name(viaImage->texMem->memType));

   viaImage->texMem->image = viaImage;
   texImage->Data = viaImage->texMem->bufAddr;

   if (viaObj->memType == VIA_MEM_UNKNOWN)
      viaObj->memType = viaImage->texMem->memType;
   else if (viaObj->memType != viaImage->texMem->memType)
      viaObj->memType = VIA_MEM_MIXED;

   if (VIA_DEBUG & DEBUG_TEXTURE)
      fprintf(stderr, "%s, obj %s, image : %s\n",
	      __FUNCTION__,	      
	      get_memtype_name(viaObj->memType),
	      get_memtype_name(viaImage->texMem->memType));

   vmesa->clearTexCache = 1;

   pixels = _mesa_validate_pbo_teximage(ctx, dims, width, height, 1, 
					format, type,
					pixels, packing, "glTexImage");
   if (!pixels) {
      /* Note: we check for a NULL image pointer here, _after_ we allocated
       * memory for the texture.  That's what the GL spec calls for.
       */
      return;
   }
   else {
      GLint dstRowStride;
      GLboolean success;

      if (_mesa_is_format_compressed(texImage->TexFormat)) {
         dstRowStride = _mesa_format_row_stride(texImage->TexFormat, width);
      }
      else {
         dstRowStride = postConvWidth * _mesa_get_format_bytes(texImage->TexFormat);
      }
      success = _mesa_texstore(ctx, dims,
                               texImage->_BaseFormat,
                               texImage->TexFormat,
                               texImage->Data,
                               0, 0, 0,  /* dstX/Y/Zoffset */
                               dstRowStride,
                               texImage->ImageOffsets,
                               width, height, 1,
                               format, type, pixels, packing);
      if (!success) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage");
      }
   }

   _mesa_unmap_teximage_pbo(ctx, packing);
}

static void viaTexImage2D(struct gl_context *ctx, 
			  GLenum target, GLint level,
			  GLint internalFormat,
			  GLint width, GLint height, GLint border,
			  GLenum format, GLenum type, const void *pixels,
			  const struct gl_pixelstore_attrib *packing,
			  struct gl_texture_object *texObj,
			  struct gl_texture_image *texImage)
{
   viaTexImage( ctx, 2, target, level, 
		internalFormat, width, height, border,
		format, type, pixels,
		packing, texObj, texImage );
}

static void viaTexSubImage2D(struct gl_context *ctx,
                             GLenum target,
                             GLint level,
                             GLint xoffset, GLint yoffset,
                             GLsizei width, GLsizei height,
                             GLenum format, GLenum type,
                             const GLvoid *pixels,
                             const struct gl_pixelstore_attrib *packing,
                             struct gl_texture_object *texObj,
                             struct gl_texture_image *texImage)
{
   struct via_context *vmesa = VIA_CONTEXT(ctx);
  
   viaWaitIdle(vmesa, GL_TRUE);
   vmesa->clearTexCache = 1;

   _mesa_store_texsubimage2d(ctx, target, level, xoffset, yoffset, width,
			     height, format, type, pixels, packing, texObj,
			     texImage);
}

static void viaTexImage1D(struct gl_context *ctx, 
			  GLenum target, GLint level,
			  GLint internalFormat,
			  GLint width, GLint border,
			  GLenum format, GLenum type, const void *pixels,
			  const struct gl_pixelstore_attrib *packing,
			  struct gl_texture_object *texObj,
			  struct gl_texture_image *texImage)
{
   viaTexImage( ctx, 1, target, level, 
		internalFormat, width, 1, border,
		format, type, pixels,
		packing, texObj, texImage );
}

static void viaTexSubImage1D(struct gl_context *ctx,
                             GLenum target,
                             GLint level,
                             GLint xoffset,
                             GLsizei width,
                             GLenum format, GLenum type,
                             const GLvoid *pixels,
                             const struct gl_pixelstore_attrib *packing,
                             struct gl_texture_object *texObj,
                             struct gl_texture_image *texImage)
{
   struct via_context *vmesa = VIA_CONTEXT(ctx);

   viaWaitIdle(vmesa, GL_TRUE); 
   vmesa->clearTexCache = 1;

   _mesa_store_texsubimage1d(ctx, target, level, xoffset, width,
			     format, type, pixels, packing, texObj,
			     texImage);
}



static GLboolean viaIsTextureResident(struct gl_context *ctx,
                                      struct gl_texture_object *texObj)
{
   struct via_texture_object *viaObj = 
      (struct via_texture_object *)texObj;

   return (viaObj->memType == VIA_MEM_AGP ||
	   viaObj->memType == VIA_MEM_VIDEO);
}



static struct gl_texture_image *viaNewTextureImage( struct gl_context *ctx )
{
   (void) ctx;
   return (struct gl_texture_image *)CALLOC_STRUCT(via_texture_image);
}


static struct gl_texture_object *viaNewTextureObject( struct gl_context *ctx, 
						      GLuint name, 
						      GLenum target )
{
   struct via_texture_object *obj = CALLOC_STRUCT(via_texture_object);

   _mesa_initialize_texture_object(&obj->obj, name, target);
   (void) ctx;

   obj->memType = VIA_MEM_UNKNOWN;

   return &obj->obj;
}


static void viaFreeTextureImageData( struct gl_context *ctx, 
				     struct gl_texture_image *texImage )
{
   struct via_context *vmesa = VIA_CONTEXT(ctx);
   struct via_texture_image *image = (struct via_texture_image *)texImage;

   if (image->texMem) {
      via_free_texture(vmesa, image->texMem);
      image->texMem = NULL;
   }
   
   texImage->Data = NULL;
}




void viaInitTextureFuncs(struct dd_function_table * functions)
{
   functions->ChooseTextureFormat = viaChooseTexFormat;
   functions->TexImage1D = viaTexImage1D;
   functions->TexImage2D = viaTexImage2D;
   functions->TexSubImage1D = viaTexSubImage1D;
   functions->TexSubImage2D = viaTexSubImage2D;

   functions->NewTextureObject = viaNewTextureObject;
   functions->NewTextureImage = viaNewTextureImage;
   functions->DeleteTexture = _mesa_delete_texture_object;
   functions->FreeTexImageData = viaFreeTextureImageData;

#if 0 && defined( USE_SSE_ASM )
   /*
    * XXX this code is disabled for now because the via_sse_memcpy()
    * routine causes segfaults with flightgear.
    * See Mesa3d-dev mail list messages from 7/15/2005 for details.
    * Note that this function is currently disabled in via_tris.c too.
    */
   if (getenv("VIA_NO_SSE"))
      functions->TextureMemCpy = memcpy;
   else
      functions->TextureMemCpy = via_sse_memcpy;
#else
   functions->TextureMemCpy = memcpy;
#endif

   functions->IsTextureResident = viaIsTextureResident;
}


@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.5
log
@Merge Mesa 7.10.3
@
text
@d37 1
a198 12
static int logbase2(int n)
{
   GLint i = 1;
   GLint log2 = 0;

   while (n > i) {
      i *= 2;
      log2++;
   }

   return log2;
}
d486 1
a486 1
   if (texObj->MinFilter == GL_LINEAR || texObj->MinFilter == GL_NEAREST) {
d490 1
a490 1
      firstLevel = texObj->BaseLevel + (GLint)(texObj->MinLod + 0.5);
d492 1
a492 1
      lastLevel = texObj->BaseLevel + (GLint)(texObj->MaxLod + 0.5);
d681 1
a681 1
   viaImage->pitchLog2 = logbase2(postConvWidth * texelBytes);
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a33 2
#include "main/colortab.h"
#include "main/convolve.h"
d48 1
a48 1
viaChooseTexFormat( GLcontext *ctx, GLint internalFormat,
d440 1
a440 1
static GLboolean viaSetTexImages(GLcontext *ctx,
d627 1
a627 1
GLboolean viaUpdateTextureState( GLcontext *ctx )
d654 1
a654 1
static void viaTexImage(GLcontext *ctx, 
a676 5
   if (ctx->_ImageTransferState & IMAGE_CONVOLUTION_BIT) {
      _mesa_adjust_image_for_convolution(ctx, dims, &postConvWidth,
                                         &postConvHeight);
   }

d801 1
a801 1
static void viaTexImage2D(GLcontext *ctx, 
d816 1
a816 1
static void viaTexSubImage2D(GLcontext *ctx,
d837 1
a837 1
static void viaTexImage1D(GLcontext *ctx, 
d852 1
a852 1
static void viaTexSubImage1D(GLcontext *ctx,
d875 1
a875 1
static GLboolean viaIsTextureResident(GLcontext *ctx,
d887 1
a887 1
static struct gl_texture_image *viaNewTextureImage( GLcontext *ctx )
d894 1
a894 1
static struct gl_texture_object *viaNewTextureObject( GLcontext *ctx, 
d909 1
a909 1
static void viaFreeTextureImageData( GLcontext *ctx, 
a953 1
   functions->UpdateTexturePalette = 0;
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d33 1
d38 1
a39 2
#include "main/texcompress.h"
#include "main/texformat.h"
a42 1
#include "main/mm.h"
a45 1
#include "via_state.h"
d49 1
a49 1
static const struct gl_texture_format *
d66 1
a66 1
	    return &_mesa_texformat_argb8888;
d69 1
a69 1
            return &_mesa_texformat_argb4444;
d72 1
a72 1
	    return &_mesa_texformat_argb1555;
d78 1
a78 1
	 return &_mesa_texformat_argb8888;
d80 1
a80 1
      return do32bpt ? &_mesa_texformat_argb8888 : &_mesa_texformat_argb4444;
d86 1
a86 1
	 return &_mesa_texformat_rgb565;
d89 1
a89 1
	 return &_mesa_texformat_argb8888;
d91 1
a91 1
      return do32bpt ? &_mesa_texformat_argb8888 : &_mesa_texformat_rgb565;
d97 1
a97 1
      return &_mesa_texformat_argb8888;
d101 1
a101 1
      return &_mesa_texformat_argb4444;
d104 1
a104 1
      return &_mesa_texformat_argb1555;
d110 1
a110 1
      return &_mesa_texformat_argb8888;
d115 1
a115 1
      return &_mesa_texformat_rgb565;
d123 1
a123 1
      return &_mesa_texformat_a8;
d132 1
a132 1
      return &_mesa_texformat_l8;
d143 1
a143 1
      return &_mesa_texformat_al88;
d151 1
a151 1
      return &_mesa_texformat_i8;
d156 1
a156 1
         return &_mesa_texformat_ycbcr;
d158 1
a158 1
         return &_mesa_texformat_ycbcr_rev;
d161 1
a161 1
      return &_mesa_texformat_rgb_fxt1;
d163 1
a163 1
      return &_mesa_texformat_rgba_fxt1;
d168 1
a168 1
      return &_mesa_texformat_rgb_dxt1;
d171 1
a171 1
      return &_mesa_texformat_rgba_dxt1;
d176 1
a176 1
      return &_mesa_texformat_rgba_dxt3;
d179 1
a179 1
      return &_mesa_texformat_rgba_dxt5;
d188 1
a188 1
      return &_mesa_texformat_ci8;    
d194 1
a194 1
      return NULL;
d197 1
a197 1
   return NULL; /* never get here */
d458 1
a458 1
   switch (baseImage->image.TexFormat->MesaFormat) {
d690 1
a690 18
   if (dims == 1) {
      texImage->FetchTexelc = texImage->TexFormat->FetchTexel1D;
      texImage->FetchTexelf = texImage->TexFormat->FetchTexel1Df;
   }
   else {
      texImage->FetchTexelc = texImage->TexFormat->FetchTexel2D;
      texImage->FetchTexelf = texImage->TexFormat->FetchTexel2Df;
   }
   texelBytes = texImage->TexFormat->TexelBytes;

   if (texelBytes == 0) {
      /* compressed format */
      texImage->IsCompressed = GL_TRUE;
      texImage->CompressedSize =
         ctx->Driver.CompressedTextureSize(ctx, texImage->Width,
                                           texImage->Height, texImage->Depth,
                                           texImage->TexFormat->MesaFormat);
   }
d702 5
a706 2
   if (texImage->IsCompressed)
      sizeInBytes = texImage->CompressedSize;
d784 3
a786 2
      if (texImage->IsCompressed) {
         dstRowStride = _mesa_compressed_row_stride(texImage->TexFormat->MesaFormat, width);
d789 1
a789 1
         dstRowStride = postConvWidth * texImage->TexFormat->TexelBytes;
d791 9
a799 10
      ASSERT(texImage->TexFormat->StoreImage);
      success = texImage->TexFormat->StoreImage(ctx, dims,
                                                texImage->_BaseFormat,
                                                texImage->TexFormat,
                                                texImage->Data,
                                                0, 0, 0,  /* dstX/Y/Zoffset */
                                                dstRowStride,
                                                texImage->ImageOffsets,
                                                width, height, 1,
                                                format, type, pixels, packing);
a804 5
   /* GL_SGIS_generate_mipmap */
   if (level == texObj->BaseLevel && texObj->GenerateMipmap) {
      _mesa_generate_mipmap(ctx, target, texObj);
   }

d954 1
a954 1
      functions->TextureMemCpy = _mesa_memcpy;
d958 1
a958 1
   functions->TextureMemCpy = _mesa_memcpy;
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d29 13
a41 13
#include "glheader.h"
#include "macros.h"
#include "mtypes.h"
#include "enums.h"
#include "colortab.h"
#include "convolve.h"
#include "context.h"
#include "mipmap.h"
#include "simple_list.h"
#include "texcompress.h"
#include "texformat.h"
#include "texobj.h"
#include "texstore.h"
d43 1
a43 1
#include "mm.h"
@


1.1
log
@Initial revision
@
text
@d36 1
d516 7
d823 1
a823 3
      _mesa_generate_mipmap(ctx, target,
                            &ctx->Texture.Unit[ctx->Texture.CurrentUnit],
                            texObj);
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a35 1
#include "mipmap.h"
a513 7

   /* The hardware supports only 10 mipmap levels; ignore higher levels.
    */
   if ((numLevels > 10) && (ctx->Const.MaxTextureLevels > 10)) {
       lastLevel -= numLevels - 10;
       numLevels = 10;
   }
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d29 13
a41 11
#include "main/glheader.h"
#include "main/macros.h"
#include "main/mtypes.h"
#include "main/enums.h"
#include "main/formats.h"
#include "main/context.h"
#include "main/mipmap.h"
#include "main/mm.h"
#include "main/simple_list.h"
#include "main/texobj.h"
#include "main/texstore.h"
d43 1
d47 1
d51 2
a52 2
static gl_format
viaChooseTexFormat( struct gl_context *ctx, GLint internalFormat,
d68 1
a68 1
	    return MESA_FORMAT_ARGB8888;
d71 1
a71 1
            return MESA_FORMAT_ARGB4444;
d74 1
a74 1
	    return MESA_FORMAT_ARGB1555;
d80 1
a80 1
	 return MESA_FORMAT_ARGB8888;
d82 1
a82 1
      return do32bpt ? MESA_FORMAT_ARGB8888 : MESA_FORMAT_ARGB4444;
d88 1
a88 1
	 return MESA_FORMAT_RGB565;
d91 1
a91 1
	 return MESA_FORMAT_ARGB8888;
d93 1
a93 1
      return do32bpt ? MESA_FORMAT_ARGB8888 : MESA_FORMAT_RGB565;
d99 1
a99 1
      return MESA_FORMAT_ARGB8888;
d103 1
a103 1
      return MESA_FORMAT_ARGB4444;
d106 1
a106 1
      return MESA_FORMAT_ARGB1555;
d112 1
a112 1
      return MESA_FORMAT_ARGB8888;
d117 1
a117 1
      return MESA_FORMAT_RGB565;
d125 1
a125 1
      return MESA_FORMAT_A8;
d134 1
a134 1
      return MESA_FORMAT_L8;
d145 1
a145 1
      return MESA_FORMAT_AL88;
d153 1
a153 1
      return MESA_FORMAT_I8;
d158 1
a158 1
         return MESA_FORMAT_YCBCR;
d160 1
a160 1
         return MESA_FORMAT_YCBCR_REV;
d163 1
a163 1
      return MESA_FORMAT_RGB_FXT1;
d165 1
a165 1
      return MESA_FORMAT_RGBA_FXT1;
d170 1
a170 1
      return MESA_FORMAT_RGB_DXT1;
d173 1
a173 1
      return MESA_FORMAT_RGBA_DXT1;
d178 1
a178 1
      return MESA_FORMAT_RGBA_DXT3;
d181 1
a181 1
      return MESA_FORMAT_RGBA_DXT5;
d190 1
a190 1
      return MESA_FORMAT_CI8;
d196 1
a196 1
      return MESA_FORMAT_NONE;
d199 1
a199 1
   return MESA_FORMAT_NONE; /* never get here */
d444 1
a444 1
static GLboolean viaSetTexImages(struct gl_context *ctx,
d460 1
a460 1
   switch (baseImage->image.TexFormat) {
d631 1
a631 1
GLboolean viaUpdateTextureState( struct gl_context *ctx )
d658 1
a658 1
static void viaTexImage(struct gl_context *ctx, 
d681 5
d692 18
a709 1
   texelBytes = _mesa_get_format_bytes(texImage->TexFormat);
d721 2
a722 5
   if (_mesa_is_format_compressed(texImage->TexFormat))
      sizeInBytes = _mesa_format_image_size(texImage->TexFormat,
                                            texImage->Width,
                                            texImage->Height,
                                            texImage->Depth);
d800 2
a801 3

      if (_mesa_is_format_compressed(texImage->TexFormat)) {
         dstRowStride = _mesa_format_row_stride(texImage->TexFormat, width);
d804 1
a804 1
         dstRowStride = postConvWidth * _mesa_get_format_bytes(texImage->TexFormat);
d806 10
a815 9
      success = _mesa_texstore(ctx, dims,
                               texImage->_BaseFormat,
                               texImage->TexFormat,
                               texImage->Data,
                               0, 0, 0,  /* dstX/Y/Zoffset */
                               dstRowStride,
                               texImage->ImageOffsets,
                               width, height, 1,
                               format, type, pixels, packing);
d821 7
d831 1
a831 1
static void viaTexImage2D(struct gl_context *ctx, 
d846 1
a846 1
static void viaTexSubImage2D(struct gl_context *ctx,
d867 1
a867 1
static void viaTexImage1D(struct gl_context *ctx, 
d882 1
a882 1
static void viaTexSubImage1D(struct gl_context *ctx,
d905 1
a905 1
static GLboolean viaIsTextureResident(struct gl_context *ctx,
d917 1
a917 1
static struct gl_texture_image *viaNewTextureImage( struct gl_context *ctx )
d924 1
a924 1
static struct gl_texture_object *viaNewTextureObject( struct gl_context *ctx, 
d939 1
a939 1
static void viaFreeTextureImageData( struct gl_context *ctx, 
d977 1
a977 1
      functions->TextureMemCpy = memcpy;
d981 1
a981 1
   functions->TextureMemCpy = memcpy;
d984 1
@


