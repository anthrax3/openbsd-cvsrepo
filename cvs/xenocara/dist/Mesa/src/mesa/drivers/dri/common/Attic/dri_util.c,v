head	1.15;
access;
symbols
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.12.0.2
	OPENBSD_5_6_BASE:1.12
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.11.0.2
	OPENBSD_5_5_BASE:1.11
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.8.0.4
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.14;
commitid	TnlogFl9nOv2eaRf;

1.14
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.13;
commitid	4ry2gvZGMXkCUD2n;

1.13
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.12;
commitid	mcxB0JvoI9gTDYXU;

1.12
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.11;
commitid	WPD6rgPryPkvXOr9;

1.11
date	2013.09.05.14.04.04;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2012.09.16.17.02.37;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.8;

1.8
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.10.01.16.13.07;	author robert;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.24.19.03.21;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.16;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.47;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.07;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.02;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.27.45;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.35;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.15.16;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.46;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.11.18;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.48.25;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.15
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * (C) Copyright IBM Corporation 2002, 2004
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file dri_util.c
 * DRI utility functions.
 *
 * This module acts as glue between GLX and the actual hardware driver.  A DRI
 * driver doesn't really \e have to use any of this - it's optional.  But, some
 * useful stuff is done here that otherwise would have to be duplicated in most
 * drivers.
 * 
 * Basically, these utility functions take care of some of the dirty details of
 * screen initialization, context creation, context binding, DRM setup, etc.
 *
 * These functions are compiled into each DRI driver so libGL.so knows nothing
 * about them.
 */


#include <stdbool.h>
#ifndef __NOT_HAVE_DRM_H
#include <xf86drm.h>
#endif
#include "dri_util.h"
#include "utils.h"
#include "xmlpool.h"
#include "../glsl/glsl_parser_extras.h"
#include "main/mtypes.h"
#include "main/version.h"
#include "main/errors.h"
#include "main/macros.h"

PUBLIC const char __dri2ConfigOptions[] =
   DRI_CONF_BEGIN
      DRI_CONF_SECTION_PERFORMANCE
         DRI_CONF_VBLANK_MODE(DRI_CONF_VBLANK_DEF_INTERVAL_1)
      DRI_CONF_SECTION_END
   DRI_CONF_END;

/*****************************************************************/
/** \name Screen handling functions                              */
/*****************************************************************/
/*@@{*/

static void
setupLoaderExtensions(__DRIscreen *psp,
		      const __DRIextension **extensions)
{
    int i;

    for (i = 0; extensions[i]; i++) {
	if (strcmp(extensions[i]->name, __DRI_DRI2_LOADER) == 0)
	    psp->dri2.loader = (__DRIdri2LoaderExtension *) extensions[i];
	if (strcmp(extensions[i]->name, __DRI_IMAGE_LOOKUP) == 0)
	    psp->dri2.image = (__DRIimageLookupExtension *) extensions[i];
	if (strcmp(extensions[i]->name, __DRI_USE_INVALIDATE) == 0)
	    psp->dri2.useInvalidate = (__DRIuseInvalidateExtension *) extensions[i];
	if (strcmp(extensions[i]->name, __DRI_SWRAST_LOADER) == 0)
	    psp->swrast_loader = (__DRIswrastLoaderExtension *) extensions[i];
        if (strcmp(extensions[i]->name, __DRI_IMAGE_LOADER) == 0)
           psp->image.loader = (__DRIimageLoaderExtension *) extensions[i];
    }
}

/**
 * This pointer determines which driver API we'll use in the case of the
 * loader not passing us an explicit driver extensions list (that would,
 * itself, contain a pointer to a driver API.)
 *
 * A driver's driDriverGetExtensions_drivername() can update this pointer to
 * what it's returning, and a loader that is ignorant of createNewScreen2()
 * will get the correct driver screen created, as long as no other
 * driDriverGetExtensions() happened in between the first one and the
 * createNewScreen().
 *
 * This allows the X Server to not require the significant dri_interface.h
 * updates for doing createNewScreen2(), which would discourage backporting of
 * the X Server patches to support the new loader interface.
 */
const struct __DriverAPIRec *globalDriverAPI = &driDriverAPI;

/**
 * This is the first entrypoint in the driver called by the DRI driver loader
 * after dlopen()ing it.
 *
 * It's used to create global state for the driver across contexts on the same
 * Display.
 */
static __DRIscreen *
driCreateNewScreen2(int scrn, int fd,
                    const __DRIextension **extensions,
                    const __DRIextension **driver_extensions,
                    const __DRIconfig ***driver_configs, void *data)
{
    static const __DRIextension *emptyExtensionList[] = { NULL };
    __DRIscreen *psp;

    psp = calloc(1, sizeof(*psp));
    if (!psp)
	return NULL;

    /* By default, use the global driDriverAPI symbol (non-megadrivers). */
    psp->driver = globalDriverAPI;

    /* If the driver exposes its vtable through its extensions list
     * (megadrivers), use that instead.
     */
    if (driver_extensions) {
       for (int i = 0; driver_extensions[i]; i++) {
          if (strcmp(driver_extensions[i]->name, __DRI_DRIVER_VTABLE) == 0) {
             psp->driver =
                ((__DRIDriverVtableExtension *)driver_extensions[i])->vtable;
          }
       }
    }

    setupLoaderExtensions(psp, extensions);

#ifndef __NOT_HAVE_DRM_H
    if (fd != -1) {
       drmVersionPtr version = drmGetVersion(fd);
       if (version) {
          psp->drm_version.major = version->version_major;
          psp->drm_version.minor = version->version_minor;
          psp->drm_version.patch = version->version_patchlevel;
          drmFreeVersion(version);
       }
    }
#endif

    psp->loaderPrivate = data;

    psp->extensions = emptyExtensionList;
    psp->fd = fd;
    psp->myNum = scrn;

    *driver_configs = psp->driver->InitScreen(psp);
    if (*driver_configs == NULL) {
	free(psp);
	return NULL;
    }

    int gl_version_override = _mesa_get_gl_version_override();
    if (gl_version_override >= 31) {
       psp->max_gl_core_version = MAX2(psp->max_gl_core_version,
                                       gl_version_override);
    } else {
       psp->max_gl_compat_version = MAX2(psp->max_gl_compat_version,
                                         gl_version_override);
    }

    psp->api_mask = (1 << __DRI_API_OPENGL);
    if (psp->max_gl_core_version > 0)
       psp->api_mask |= (1 << __DRI_API_OPENGL_CORE);
    if (psp->max_gl_es1_version > 0)
       psp->api_mask |= (1 << __DRI_API_GLES);
    if (psp->max_gl_es2_version > 0)
       psp->api_mask |= (1 << __DRI_API_GLES2);
    if (psp->max_gl_es2_version >= 30)
       psp->api_mask |= (1 << __DRI_API_GLES3);

    driParseOptionInfo(&psp->optionInfo, __dri2ConfigOptions);
    driParseConfigFiles(&psp->optionCache, &psp->optionInfo, psp->myNum, "dri2");


    return psp;
}

static __DRIscreen *
dri2CreateNewScreen(int scrn, int fd,
		    const __DRIextension **extensions,
		    const __DRIconfig ***driver_configs, void *data)
{
   return driCreateNewScreen2(scrn, fd, extensions, NULL,
                               driver_configs, data);
}

/** swrast driver createNewScreen entrypoint. */
static __DRIscreen *
driSWRastCreateNewScreen(int scrn, const __DRIextension **extensions,
                         const __DRIconfig ***driver_configs, void *data)
{
   return driCreateNewScreen2(scrn, -1, extensions, NULL,
                               driver_configs, data);
}

static __DRIscreen *
driSWRastCreateNewScreen2(int scrn, const __DRIextension **extensions,
                          const __DRIextension **driver_extensions,
                          const __DRIconfig ***driver_configs, void *data)
{
   return driCreateNewScreen2(scrn, -1, extensions, driver_extensions,
                               driver_configs, data);
}

/**
 * Destroy the per-screen private information.
 * 
 * \internal
 * This function calls __DriverAPIRec::DestroyScreen on \p screenPrivate, calls
 * drmClose(), and finally frees \p screenPrivate.
 */
static void driDestroyScreen(__DRIscreen *psp)
{
    if (psp) {
	/* No interaction with the X-server is possible at this point.  This
	 * routine is called after XCloseDisplay, so there is no protocol
	 * stream open to the X-server anymore.
	 */

       _mesa_destroy_shader_compiler();

	psp->driver->DestroyScreen(psp);

	driDestroyOptionCache(&psp->optionCache);
	driDestroyOptionInfo(&psp->optionInfo);

	free(psp);
    }
}

static const __DRIextension **driGetExtensions(__DRIscreen *psp)
{
    return psp->extensions;
}

/*@@}*/


static bool
validate_context_version(__DRIscreen *screen,
                         int mesa_api,
                         unsigned major_version,
                         unsigned minor_version,
                         unsigned *dri_ctx_error)
{
   unsigned req_version = 10 * major_version + minor_version;
   unsigned max_version = 0;

   switch (mesa_api) {
   case API_OPENGL_COMPAT:
      max_version = screen->max_gl_compat_version;
      break;
   case API_OPENGL_CORE:
      max_version = screen->max_gl_core_version;
      break;
   case API_OPENGLES:
      max_version = screen->max_gl_es1_version;
      break;
   case API_OPENGLES2:
      max_version = screen->max_gl_es2_version;
      break;
   default:
      max_version = 0;
      break;
   }

   if (max_version == 0) {
      *dri_ctx_error = __DRI_CTX_ERROR_BAD_API;
      return false;
   } else if (req_version > max_version) {
      *dri_ctx_error = __DRI_CTX_ERROR_BAD_VERSION;
      return false;
   }

   return true;
}

/*****************************************************************/
/** \name Context handling functions                             */
/*****************************************************************/
/*@@{*/

static __DRIcontext *
driCreateContextAttribs(__DRIscreen *screen, int api,
                        const __DRIconfig *config,
                        __DRIcontext *shared,
                        unsigned num_attribs,
                        const uint32_t *attribs,
                        unsigned *error,
                        void *data)
{
    __DRIcontext *context;
    const struct gl_config *modes = (config != NULL) ? &config->modes : NULL;
    void *shareCtx = (shared != NULL) ? shared->driverPrivate : NULL;
    gl_api mesa_api;
    unsigned major_version = 1;
    unsigned minor_version = 0;
    uint32_t flags = 0;
    bool notify_reset = false;

    assert((num_attribs == 0) || (attribs != NULL));

    if (!(screen->api_mask & (1 << api))) {
	*error = __DRI_CTX_ERROR_BAD_API;
	return NULL;
    }

    switch (api) {
    case __DRI_API_OPENGL:
	mesa_api = API_OPENGL_COMPAT;
	break;
    case __DRI_API_GLES:
	mesa_api = API_OPENGLES;
	break;
    case __DRI_API_GLES2:
    case __DRI_API_GLES3:
	mesa_api = API_OPENGLES2;
	break;
    case __DRI_API_OPENGL_CORE:
        mesa_api = API_OPENGL_CORE;
        break;
    default:
	*error = __DRI_CTX_ERROR_BAD_API;
	return NULL;
    }

    for (unsigned i = 0; i < num_attribs; i++) {
	switch (attribs[i * 2]) {
	case __DRI_CTX_ATTRIB_MAJOR_VERSION:
	    major_version = attribs[i * 2 + 1];
	    break;
	case __DRI_CTX_ATTRIB_MINOR_VERSION:
	    minor_version = attribs[i * 2 + 1];
	    break;
	case __DRI_CTX_ATTRIB_FLAGS:
	    flags = attribs[i * 2 + 1];
	    break;
        case __DRI_CTX_ATTRIB_RESET_STRATEGY:
            notify_reset = (attribs[i * 2 + 1]
                            != __DRI_CTX_RESET_NO_NOTIFICATION);
            break;
	default:
	    /* We can't create a context that satisfies the requirements of an
	     * attribute that we don't understand.  Return failure.
	     */
	    assert(!"Should not get here.");
	    *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
	    return NULL;
	}
    }

    /* Mesa does not support the GL_ARB_compatibilty extension or the
     * compatibility profile.  This means that we treat a API_OPENGL_COMPAT 3.1 as
     * API_OPENGL_CORE and reject API_OPENGL_COMPAT 3.2+.
     */
    if (mesa_api == API_OPENGL_COMPAT && major_version == 3 && minor_version == 1)
       mesa_api = API_OPENGL_CORE;

    if (mesa_api == API_OPENGL_COMPAT
        && ((major_version > 3)
            || (major_version == 3 && minor_version >= 2))) {
       *error = __DRI_CTX_ERROR_BAD_API;
       return NULL;
    }

    /* The EGL_KHR_create_context spec says:
     *
     *     "Flags are only defined for OpenGL context creation, and specifying
     *     a flags value other than zero for other types of contexts,
     *     including OpenGL ES contexts, will generate an error."
     *
     * The GLX_EXT_create_context_es2_profile specification doesn't say
     * anything specific about this case.  However, none of the known flags
     * have any meaning in an ES context, so this seems safe.
     */
    if (mesa_api != API_OPENGL_COMPAT
        && mesa_api != API_OPENGL_CORE
        && flags != 0) {
	*error = __DRI_CTX_ERROR_BAD_FLAG;
	return NULL;
    }

    /* There are no forward-compatible contexts before OpenGL 3.0.  The
     * GLX_ARB_create_context spec says:
     *
     *     "Forward-compatible contexts are defined only for OpenGL versions
     *     3.0 and later."
     *
     * Forward-looking contexts are supported by silently converting the
     * requested API to API_OPENGL_CORE.
     *
     * In Mesa, a debug context is the same as a regular context.
     */
    if ((flags & __DRI_CTX_FLAG_FORWARD_COMPATIBLE) != 0) {
       mesa_api = API_OPENGL_CORE;
    }

    const uint32_t allowed_flags = (__DRI_CTX_FLAG_DEBUG
                                    | __DRI_CTX_FLAG_FORWARD_COMPATIBLE
                                    | __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS);
    if (flags & ~allowed_flags) {
	*error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
	return NULL;
    }

    if (!validate_context_version(screen, mesa_api,
                                  major_version, minor_version, error))
       return NULL;

    context = calloc(1, sizeof *context);
    if (!context) {
	*error = __DRI_CTX_ERROR_NO_MEMORY;
	return NULL;
    }

    context->loaderPrivate = data;

    context->driScreenPriv = screen;
    context->driDrawablePriv = NULL;
    context->driReadablePriv = NULL;

    if (!screen->driver->CreateContext(mesa_api, modes, context,
                                       major_version, minor_version,
                                       flags, notify_reset, error, shareCtx)) {
        free(context);
        return NULL;
    }

    *error = __DRI_CTX_ERROR_SUCCESS;
    return context;
}

void
driContextSetFlags(struct gl_context *ctx, uint32_t flags)
{
    if ((flags & __DRI_CTX_FLAG_FORWARD_COMPATIBLE) != 0)
        ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT;
    if ((flags & __DRI_CTX_FLAG_DEBUG) != 0) {
       _mesa_set_debug_state_int(ctx, GL_DEBUG_OUTPUT, GL_TRUE);
        ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_DEBUG_BIT;
    }
}

static __DRIcontext *
driCreateNewContextForAPI(__DRIscreen *screen, int api,
                          const __DRIconfig *config,
                          __DRIcontext *shared, void *data)
{
    unsigned error;

    return driCreateContextAttribs(screen, api, config, shared, 0, NULL,
                                   &error, data);
}

static __DRIcontext *
driCreateNewContext(__DRIscreen *screen, const __DRIconfig *config,
                    __DRIcontext *shared, void *data)
{
    return driCreateNewContextForAPI(screen, __DRI_API_OPENGL,
                                     config, shared, data);
}

/**
 * Destroy the per-context private information.
 * 
 * \internal
 * This function calls __DriverAPIRec::DestroyContext on \p contextPrivate, calls
 * drmDestroyContext(), and finally frees \p contextPrivate.
 */
static void
driDestroyContext(__DRIcontext *pcp)
{
    if (pcp) {
	pcp->driScreenPriv->driver->DestroyContext(pcp);
	free(pcp);
    }
}

static int
driCopyContext(__DRIcontext *dest, __DRIcontext *src, unsigned long mask)
{
    (void) dest;
    (void) src;
    (void) mask;
    return GL_FALSE;
}

/*@@}*/


/*****************************************************************/
/** \name Context (un)binding functions                          */
/*****************************************************************/
/*@@{*/

static void dri_get_drawable(__DRIdrawable *pdp);
static void dri_put_drawable(__DRIdrawable *pdp);

/**
 * This function takes both a read buffer and a draw buffer.  This is needed
 * for \c glXMakeCurrentReadSGI or GLX 1.3's \c glXMakeContextCurrent
 * function.
 */
static int driBindContext(__DRIcontext *pcp,
			  __DRIdrawable *pdp,
			  __DRIdrawable *prp)
{
    /*
    ** Assume error checking is done properly in glXMakeCurrent before
    ** calling driUnbindContext.
    */

    if (!pcp)
	return GL_FALSE;

    /* Bind the drawable to the context */
    pcp->driDrawablePriv = pdp;
    pcp->driReadablePriv = prp;
    if (pdp) {
	pdp->driContextPriv = pcp;
	dri_get_drawable(pdp);
    }
    if (prp && pdp != prp) {
	dri_get_drawable(prp);
    }

    return pcp->driScreenPriv->driver->MakeCurrent(pcp, pdp, prp);
}

/**
 * Unbind context.
 * 
 * \param scrn the screen.
 * \param gc context.
 *
 * \return \c GL_TRUE on success, or \c GL_FALSE on failure.
 * 
 * \internal
 * This function calls __DriverAPIRec::UnbindContext, and then decrements
 * __DRIdrawableRec::refcount which must be non-zero for a successful
 * return.
 * 
 * While casting the opaque private pointers associated with the parameters
 * into their respective real types it also assures they are not \c NULL. 
 */
static int driUnbindContext(__DRIcontext *pcp)
{
    __DRIdrawable *pdp;
    __DRIdrawable *prp;

    /*
    ** Assume error checking is done properly in glXMakeCurrent before
    ** calling driUnbindContext.
    */

    if (pcp == NULL)
	return GL_FALSE;

    pdp = pcp->driDrawablePriv;
    prp = pcp->driReadablePriv;

    /* already unbound */
    if (!pdp && !prp)
	return GL_TRUE;

    pcp->driScreenPriv->driver->UnbindContext(pcp);

    assert(pdp);
    if (pdp->refcount == 0) {
	/* ERROR!!! */
	return GL_FALSE;
    }

    dri_put_drawable(pdp);

    if (prp != pdp) {
	if (prp->refcount == 0) {
	    /* ERROR!!! */
	    return GL_FALSE;
	}

	dri_put_drawable(prp);
    }

    pcp->driDrawablePriv = NULL;
    pcp->driReadablePriv = NULL;

    return GL_TRUE;
}

/*@@}*/


static void dri_get_drawable(__DRIdrawable *pdp)
{
    pdp->refcount++;
}

static void dri_put_drawable(__DRIdrawable *pdp)
{
    if (pdp) {
	pdp->refcount--;
	if (pdp->refcount)
	    return;

	pdp->driScreenPriv->driver->DestroyBuffer(pdp);
	free(pdp);
    }
}

static __DRIdrawable *
driCreateNewDrawable(__DRIscreen *screen,
                     const __DRIconfig *config,
                     void *data)
{
    __DRIdrawable *pdraw;

    pdraw = malloc(sizeof *pdraw);
    if (!pdraw)
	return NULL;

    pdraw->loaderPrivate = data;

    pdraw->driScreenPriv = screen;
    pdraw->driContextPriv = NULL;
    pdraw->refcount = 0;
    pdraw->lastStamp = 0;
    pdraw->w = 0;
    pdraw->h = 0;

    dri_get_drawable(pdraw);

    if (!screen->driver->CreateBuffer(screen, pdraw, &config->modes,
                                      GL_FALSE)) {
       free(pdraw);
       return NULL;
    }

    pdraw->dri2.stamp = pdraw->lastStamp + 1;

    return pdraw;
}

static void
driDestroyDrawable(__DRIdrawable *pdp)
{
    dri_put_drawable(pdp);
}

static __DRIbuffer *
dri2AllocateBuffer(__DRIscreen *screen,
		   unsigned int attachment, unsigned int format,
		   int width, int height)
{
    return screen->driver->AllocateBuffer(screen, attachment, format,
                                          width, height);
}

static void
dri2ReleaseBuffer(__DRIscreen *screen, __DRIbuffer *buffer)
{
    screen->driver->ReleaseBuffer(screen, buffer);
}


static int
dri2ConfigQueryb(__DRIscreen *screen, const char *var, GLboolean *val)
{
   if (!driCheckOption(&screen->optionCache, var, DRI_BOOL))
      return -1;

   *val = driQueryOptionb(&screen->optionCache, var);

   return 0;
}

static int
dri2ConfigQueryi(__DRIscreen *screen, const char *var, GLint *val)
{
   if (!driCheckOption(&screen->optionCache, var, DRI_INT) &&
       !driCheckOption(&screen->optionCache, var, DRI_ENUM))
      return -1;

    *val = driQueryOptioni(&screen->optionCache, var);

    return 0;
}

static int
dri2ConfigQueryf(__DRIscreen *screen, const char *var, GLfloat *val)
{
   if (!driCheckOption(&screen->optionCache, var, DRI_FLOAT))
      return -1;

    *val = driQueryOptionf(&screen->optionCache, var);

    return 0;
}

static unsigned int
driGetAPIMask(__DRIscreen *screen)
{
    return screen->api_mask;
}

/**
 * swrast swapbuffers entrypoint.
 *
 * DRI2 implements this inside the loader with only flushes handled by the
 * driver.
 */
static void
driSwapBuffers(__DRIdrawable *pdp)
{
    assert(pdp->driScreenPriv->swrast_loader);

    pdp->driScreenPriv->driver->SwapBuffers(pdp);
}

/** Core interface */
const __DRIcoreExtension driCoreExtension = {
    .base = { __DRI_CORE, __DRI_CORE_VERSION },

    .createNewScreen            = NULL,
    .destroyScreen              = driDestroyScreen,
    .getExtensions              = driGetExtensions,
    .getConfigAttrib            = driGetConfigAttrib,
    .indexConfigAttrib          = driIndexConfigAttrib,
    .createNewDrawable          = NULL,
    .destroyDrawable            = driDestroyDrawable,
    .swapBuffers                = driSwapBuffers, /* swrast */
    .createNewContext           = driCreateNewContext, /* swrast */
    .copyContext                = driCopyContext,
    .destroyContext             = driDestroyContext,
    .bindContext                = driBindContext,
    .unbindContext              = driUnbindContext
};

/** DRI2 interface */
const __DRIdri2Extension driDRI2Extension = {
    .base = { __DRI_DRI2, 4 },

    .createNewScreen            = dri2CreateNewScreen,
    .createNewDrawable          = driCreateNewDrawable,
    .createNewContext           = driCreateNewContext,
    .getAPIMask                 = driGetAPIMask,
    .createNewContextForAPI     = driCreateNewContextForAPI,
    .allocateBuffer             = dri2AllocateBuffer,
    .releaseBuffer              = dri2ReleaseBuffer,
    .createContextAttribs       = driCreateContextAttribs,
    .createNewScreen2           = driCreateNewScreen2,
};

const __DRIswrastExtension driSWRastExtension = {
    .base = { __DRI_SWRAST, 4 },

    .createNewScreen            = driSWRastCreateNewScreen,
    .createNewDrawable          = driCreateNewDrawable,
    .createNewContextForAPI     = driCreateNewContextForAPI,
    .createContextAttribs       = driCreateContextAttribs,
    .createNewScreen2           = driSWRastCreateNewScreen2,
};

const __DRI2configQueryExtension dri2ConfigQueryExtension = {
   .base = { __DRI2_CONFIG_QUERY, 1 },

   .configQueryb        = dri2ConfigQueryb,
   .configQueryi        = dri2ConfigQueryi,
   .configQueryf        = dri2ConfigQueryf,
};

void
dri2InvalidateDrawable(__DRIdrawable *drawable)
{
    drawable->dri2.stamp++;
}

/**
 * Check that the gl_framebuffer associated with dPriv is the right size.
 * Resize the gl_framebuffer if needed.
 * It's expected that the dPriv->driverPrivate member points to a
 * gl_framebuffer object.
 */
void
driUpdateFramebufferSize(struct gl_context *ctx, const __DRIdrawable *dPriv)
{
   struct gl_framebuffer *fb = (struct gl_framebuffer *) dPriv->driverPrivate;
   if (fb && (dPriv->w != fb->Width || dPriv->h != fb->Height)) {
      ctx->Driver.ResizeBuffers(ctx, fb, dPriv->w, dPriv->h);
      /* if the driver needs the hw lock for ResizeBuffers, the drawable
         might have changed again by now */
      assert(fb->Width == dPriv->w);
      assert(fb->Height == dPriv->h);
   }
}

uint32_t
driGLFormatToImageFormat(mesa_format format)
{
   switch (format) {
   case MESA_FORMAT_B5G6R5_UNORM:
      return __DRI_IMAGE_FORMAT_RGB565;
   case MESA_FORMAT_B8G8R8X8_UNORM:
      return __DRI_IMAGE_FORMAT_XRGB8888;
   case MESA_FORMAT_B10G10R10A2_UNORM:
      return __DRI_IMAGE_FORMAT_ARGB2101010;
   case MESA_FORMAT_B10G10R10X2_UNORM:
      return __DRI_IMAGE_FORMAT_XRGB2101010;
   case MESA_FORMAT_B8G8R8A8_UNORM:
      return __DRI_IMAGE_FORMAT_ARGB8888;
   case MESA_FORMAT_R8G8B8A8_UNORM:
      return __DRI_IMAGE_FORMAT_ABGR8888;
   case MESA_FORMAT_R8G8B8X8_UNORM:
      return __DRI_IMAGE_FORMAT_XBGR8888;
   case MESA_FORMAT_R_UNORM8:
      return __DRI_IMAGE_FORMAT_R8;
   case MESA_FORMAT_R8G8_UNORM:
      return __DRI_IMAGE_FORMAT_GR88;
   case MESA_FORMAT_NONE:
      return __DRI_IMAGE_FORMAT_NONE;
   case MESA_FORMAT_B8G8R8A8_SRGB:
      return __DRI_IMAGE_FORMAT_SARGB8;
   default:
      return 0;
   }
}

mesa_format
driImageFormatToGLFormat(uint32_t image_format)
{
   switch (image_format) {
   case __DRI_IMAGE_FORMAT_RGB565:
      return MESA_FORMAT_B5G6R5_UNORM;
   case __DRI_IMAGE_FORMAT_XRGB8888:
      return MESA_FORMAT_B8G8R8X8_UNORM;
   case __DRI_IMAGE_FORMAT_ARGB2101010:
      return MESA_FORMAT_B10G10R10A2_UNORM;
   case __DRI_IMAGE_FORMAT_XRGB2101010:
      return MESA_FORMAT_B10G10R10X2_UNORM;
   case __DRI_IMAGE_FORMAT_ARGB8888:
      return MESA_FORMAT_B8G8R8A8_UNORM;
   case __DRI_IMAGE_FORMAT_ABGR8888:
      return MESA_FORMAT_R8G8B8A8_UNORM;
   case __DRI_IMAGE_FORMAT_XBGR8888:
      return MESA_FORMAT_R8G8B8X8_UNORM;
   case __DRI_IMAGE_FORMAT_R8:
      return MESA_FORMAT_R_UNORM8;
   case __DRI_IMAGE_FORMAT_GR88:
      return MESA_FORMAT_R8G8_UNORM;
   case __DRI_IMAGE_FORMAT_SARGB8:
      return MESA_FORMAT_B8G8R8A8_SRGB;
   case __DRI_IMAGE_FORMAT_NONE:
      return MESA_FORMAT_NONE;
   default:
      return MESA_FORMAT_NONE;
   }
}

/** Image driver interface */
const __DRIimageDriverExtension driImageDriverExtension = {
    .base = { __DRI_IMAGE_DRIVER, 1 },

    .createNewScreen2           = driCreateNewScreen2,
    .createNewDrawable          = driCreateNewDrawable,
    .getAPIMask                 = driGetAPIMask,
    .createContextAttribs       = driCreateContextAttribs,
};

/* swrast copy sub buffer entrypoint. */
static void driCopySubBuffer(__DRIdrawable *pdp, int x, int y,
                             int w, int h)
{
    assert(pdp->driScreenPriv->swrast_loader);

    pdp->driScreenPriv->driver->CopySubBuffer(pdp, x, y, w, h);
}

/* for swrast only */
const __DRIcopySubBufferExtension driCopySubBufferExtension = {
   .base = { __DRI_COPY_SUB_BUFFER, 1 },

   .copySubBuffer               = driCopySubBuffer,
};
@


1.14
log
@Merge Mesa 10.2.9
@
text
@@


1.13
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d55 1
a55 1
const char __dri2ConfigOptions[] =
d379 1
a379 1
    /* The latest version of EGL_KHR_create_context spec says:
d381 3
a383 3
     *     "If the EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR flag bit is set in
     *     EGL_CONTEXT_FLAGS_KHR, then a <debug context> will be created.
     *     [...] This bit is supported for OpenGL and OpenGL ES contexts.
d385 3
a387 1
     * None of the other flags have any meaning in an ES context, so this seems safe.
d391 1
a391 1
        && (flags & ~__DRI_CTX_FLAG_DEBUG)) {
a571 6
    /*
    ** Call driUnbindContext before checking for valid drawables
    ** to handle surfaceless contexts properly.
    */
    pcp->driScreenPriv->driver->UnbindContext(pcp);

d579 2
d680 1
a680 1
dri2ConfigQueryb(__DRIscreen *screen, const char *var, unsigned char *val)
d691 1
a691 1
dri2ConfigQueryi(__DRIscreen *screen, const char *var, int *val)
d703 1
a703 1
dri2ConfigQueryf(__DRIscreen *screen, const char *var, float *val)
d735 1
a735 1
    .base = { __DRI_CORE, 1 },
@


1.12
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d55 1
a55 1
PUBLIC const char __dri2ConfigOptions[] =
d379 1
a379 1
    /* The EGL_KHR_create_context spec says:
d381 3
a383 3
     *     "Flags are only defined for OpenGL context creation, and specifying
     *     a flags value other than zero for other types of contexts,
     *     including OpenGL ES contexts, will generate an error."
d385 1
a385 3
     * The GLX_EXT_create_context_es2_profile specification doesn't say
     * anything specific about this case.  However, none of the known flags
     * have any meaning in an ES context, so this seems safe.
d389 1
a389 1
        && flags != 0) {
d570 6
a582 2
    pcp->driScreenPriv->driver->UnbindContext(pcp);

d682 1
a682 1
dri2ConfigQueryb(__DRIscreen *screen, const char *var, GLboolean *val)
d693 1
a693 1
dri2ConfigQueryi(__DRIscreen *screen, const char *var, GLint *val)
d705 1
a705 1
dri2ConfigQueryf(__DRIscreen *screen, const char *var, GLfloat *val)
d737 1
a737 1
    .base = { __DRI_CORE, __DRI_CORE_VERSION },
@


1.11
log
@Merge Mesa 9.2.0
@
text
@d42 2
d45 1
d50 4
a61 2
static const uint __dri2NConfigOptions = 1;

d80 4
d87 24
d112 4
a115 3
dri2CreateNewScreen(int scrn, int fd,
		    const __DRIextension **extensions,
		    const __DRIconfig ***driver_configs, void *data)
a118 1
    drmVersionPtr version;
d124 15
d141 9
a149 6
    version = drmGetVersion(fd);
    if (version) {
	psp->drm_version.major = version->version_major;
	psp->drm_version.minor = version->version_minor;
	psp->drm_version.patch = version->version_patchlevel;
	drmFreeVersion(version);
d151 1
d159 1
a159 3
    psp->api_mask = (1 << __DRI_API_OPENGL);

    *driver_configs = driDriverAPI.InitScreen(psp);
d165 20
a184 1
    driParseOptionInfo(&psp->optionInfo, __dri2ConfigOptions, __dri2NConfigOptions);
d187 1
d191 27
d235 1
a235 1
	driDriverAPI.DestroyScreen(psp);
d252 39
d297 7
a303 7
dri2CreateContextAttribs(__DRIscreen *screen, int api,
			 const __DRIconfig *config,
			 __DRIcontext *shared,
			 unsigned num_attribs,
			 const uint32_t *attribs,
			 unsigned *error,
			 void *data)
d312 1
d351 4
d411 4
a414 2
    if ((flags & ~(__DRI_CTX_FLAG_DEBUG | __DRI_CTX_FLAG_FORWARD_COMPATIBLE))
        != 0) {
d419 4
d435 3
a437 3
    if (!driDriverAPI.CreateContext(mesa_api, modes, context,
				    major_version, minor_version,
				    flags, error, shareCtx) ) {
d446 11
d458 3
a460 3
dri2CreateNewContextForAPI(__DRIscreen *screen, int api,
			   const __DRIconfig *config,
			   __DRIcontext *shared, void *data)
d464 2
a465 2
    return dri2CreateContextAttribs(screen, api, config, shared, 0, NULL,
				    &error, data);
d469 2
a470 2
dri2CreateNewContext(__DRIscreen *screen, const __DRIconfig *config,
		      __DRIcontext *shared, void *data)
d472 2
a473 2
    return dri2CreateNewContextForAPI(screen, __DRI_API_OPENGL,
				      config, shared, data);
d487 1
a487 1
	driDriverAPI.DestroyContext(pcp);
d540 1
a540 1
    return driDriverAPI.MakeCurrent(pcp, pdp, prp);
d579 1
a579 1
    driDriverAPI.UnbindContext(pcp);
a597 4
    /* XXX this is disabled so that if we call SwapBuffers on an unbound
     * window we can determine the last context bound to the window and
     * use that context's lock. (BrianP, 2-Dec-2000)
     */
d619 1
a619 1
	driDriverAPI.DestroyBuffer(pdp);
d625 3
a627 3
dri2CreateNewDrawable(__DRIscreen *screen,
		      const __DRIconfig *config,
		      void *data)
d646 2
a647 1
    if (!driDriverAPI.CreateBuffer(screen, pdraw, &config->modes, GL_FALSE)) {
d668 2
a669 2
    return driDriverAPI.AllocateBuffer(screen, attachment, format,
				       width, height);
d675 1
a675 1
    driDriverAPI.ReleaseBuffer(screen, buffer);
d714 1
a714 1
dri2GetAPIMask(__DRIscreen *screen)
d719 13
d744 2
a745 2
    .swapBuffers                = NULL,
    .createNewContext           = NULL,
d754 1
a754 1
    .base = { __DRI_DRI2, 3 },
d757 4
a760 4
    .createNewDrawable          = dri2CreateNewDrawable,
    .createNewContext           = dri2CreateNewContext,
    .getAPIMask                 = dri2GetAPIMask,
    .createNewContextForAPI     = dri2CreateNewContextForAPI,
d763 12
a774 1
    .createContextAttribs       = dri2CreateContextAttribs
d778 1
a778 1
   .base = { __DRI2_CONFIG_QUERY, __DRI2_CONFIG_QUERY_VERSION },
d809 88
@


1.10
log
@Merge some definitions from dri 2.3 needed by xserver 1.13.
ok mpi@@
@
text
@d1 24
d42 1
a42 13
#include <assert.h>
#include <stdarg.h>
#include <unistd.h>
#include <sys/mman.h>
#include <stdio.h>

#ifndef MAP_FAILED
#define MAP_FAILED ((void *)-1)
#endif

#include "main/imports.h"
#define None 0

a43 1
#include "drm_sarea.h"
d57 57
a113 3
#ifndef GLX_OML_sync_control
typedef GLboolean ( * PFNGLXGETMSCRATEOMLPROC) (__DRIdrawable *drawable, int32_t *numerator, int32_t *denominator);
#endif
d115 5
a119 2
static void dri_get_drawable(__DRIdrawable *pdp);
static void dri_put_drawable(__DRIdrawable *pdp);
d122 5
a126 2
 * This is just a token extension used to signal that the driver
 * supports setting a read drawable.
d128 181
a308 3
const __DRIextension driReadDrawableExtension = {
    __DRI_READ_DRAWABLE, __DRI_READ_DRAWABLE_VERSION
};
d310 3
a312 2
GLint
driIntersectArea( drm_clip_rect_t rect1, drm_clip_rect_t rect2 )
d314 3
a316 4
   if (rect2.x1 > rect1.x1) rect1.x1 = rect2.x1;
   if (rect2.x2 < rect1.x2) rect1.x2 = rect2.x2;
   if (rect2.y1 > rect1.y1) rect1.y1 = rect2.y1;
   if (rect2.y2 < rect1.y2) rect1.y2 = rect2.y2;
d318 15
a332 1
   if (rect1.x1 > rect1.x2 || rect1.y1 > rect1.y2) return 0;
d334 7
a340 1
   return (rect1.x2 - rect1.x1) * (rect1.y2 - rect1.y1);
d343 3
d351 34
a402 1
    __DRIscreen *psp;
d412 1
a412 1
        return GL_FALSE;
a413 1
    psp = pcp->driScreenPriv;
d419 3
a421 3
      return GL_TRUE;
    /* Let driver unbind drawable from context */
    (*psp->DriverAPI.UnbindContext)(pcp);
d432 1
a432 1
        if (prp->refcount == 0) {
d437 1
a437 1
    	dri_put_drawable(prp);
a439 1

d444 2
a445 1
    pcp->driDrawablePriv = pcp->driReadablePriv = NULL;
d450 4
a453 8
/**
 * This function takes both a read buffer and a draw buffer.  This is needed
 * for \c glXMakeCurrentReadSGI or GLX 1.3's \c glXMakeContextCurrent
 * function.
 */
static int driBindContext(__DRIcontext *pcp,
			  __DRIdrawable *pdp,
			  __DRIdrawable *prp)
d455 2
a456 1
    __DRIscreen *psp = NULL;
d458 6
a463 4
    /*
    ** Assume error checking is done properly in glXMakeCurrent before
    ** calling driUnbindContext.
    */
d465 4
a468 2
    if (!pcp)
	return GL_FALSE;
d470 4
a473 56
    /* Bind the drawable to the context */
    psp = pcp->driScreenPriv;
    pcp->driDrawablePriv = pdp;
    pcp->driReadablePriv = prp;
    if (pdp) {
	pdp->driContextPriv = pcp;
	dri_get_drawable(pdp);
    }
    if (prp && pdp != prp) {
	dri_get_drawable(prp);
    }

    /*
    ** Now that we have a context associated with this drawable, we can
    ** initialize the drawable information if has not been done before.
    */

    if (!psp->dri2.enabled) {
	if (pdp && !pdp->pStamp) {
	    DRM_SPINLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);
	    __driUtilUpdateDrawableInfo(pdp);
	    DRM_SPINUNLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);
	}
	if (prp && pdp != prp && !prp->pStamp) {
	    DRM_SPINLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);
	    __driUtilUpdateDrawableInfo(prp);
	    DRM_SPINUNLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);
        }
    }

    /* Call device-specific MakeCurrent */
    return (*psp->DriverAPI.MakeCurrent)(pcp, pdp, prp);
}

/*@@}*/


/*****************************************************************/
/** \name Drawable handling functions                            */
/*****************************************************************/
/*@@{*/

/**
 * Update private drawable information.
 *
 * \param pdp pointer to the private drawable information to update.
 * 
 * This function basically updates the __DRIdrawable struct's
 * cliprect information by calling \c __DRIinterfaceMethods::getDrawableInfo.
 * This is usually called by the DRI_VALIDATE_DRAWABLE_INFO macro which
 * compares the __DRIdrwablePrivate pStamp and lastStamp values.  If
 * the values are different that means we have to update the clipping
 * info.
 */
void
__driUtilUpdateDrawableInfo(__DRIdrawable *pdp)
d475 1
a475 10
    __DRIscreen *psp = pdp->driScreenPriv;
    __DRIcontext *pcp = pdp->driContextPriv;
    
    if (!pcp 
	|| ((pdp != pcp->driDrawablePriv) && (pdp != pcp->driReadablePriv))) {
	/* ERROR!!! 
	 * ...but we must ignore it. There can be many contexts bound to a
	 * drawable.
	 */
    }
d477 3
a479 82
    if (pdp->pClipRects) {
	free(pdp->pClipRects); 
	pdp->pClipRects = NULL;
    }

    if (pdp->pBackClipRects) {
	free(pdp->pBackClipRects); 
	pdp->pBackClipRects = NULL;
    }

    DRM_SPINUNLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);

    if (! (*psp->getDrawableInfo->getDrawableInfo)(pdp,
			  &pdp->index, &pdp->lastStamp,
			  &pdp->x, &pdp->y, &pdp->w, &pdp->h,
			  &pdp->numClipRects, &pdp->pClipRects,
			  &pdp->backX,
			  &pdp->backY,
			  &pdp->numBackClipRects,
			  &pdp->pBackClipRects,
			  pdp->loaderPrivate)) {
	/* Error -- eg the window may have been destroyed.  Keep going
	 * with no cliprects.
	 */
        pdp->pStamp = &pdp->lastStamp; /* prevent endless loop */
	pdp->numClipRects = 0;
	pdp->pClipRects = NULL;
	pdp->numBackClipRects = 0;
	pdp->pBackClipRects = NULL;
    }
    else
       pdp->pStamp = &(psp->pSAREA->drawableTable[pdp->index].stamp);

    DRM_SPINLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);
}

/*@@}*/

/*****************************************************************/
/** \name GLX callbacks                                          */
/*****************************************************************/
/*@@{*/

static void driReportDamage(__DRIdrawable *pdp,
			    struct drm_clip_rect *pClipRects, int numClipRects)
{
    __DRIscreen *psp = pdp->driScreenPriv;

    /* Check that we actually have the new damage report method */
    if (psp->damage) {
	/* Report the damage.  Currently, all our drivers draw
	 * directly to the front buffer, so we report the damage there
	 * rather than to the backing storein (if any).
	 */
	(*psp->damage->reportDamage)(pdp,
				     pdp->x, pdp->y,
				     pClipRects, numClipRects,
				     GL_TRUE, pdp->loaderPrivate);
    }
}


/**
 * Swap buffers.
 *
 * \param drawablePrivate opaque pointer to the per-drawable private info.
 * 
 * \internal
 * This function calls __DRIdrawable::swapBuffers.
 * 
 * Is called directly from glXSwapBuffers().
 */
static void driSwapBuffers(__DRIdrawable *dPriv)
{
    __DRIscreen *psp = dPriv->driScreenPriv;
    drm_clip_rect_t *rects;
    int i;

    psp->DriverAPI.SwapBuffers(dPriv);

    if (!dPriv->numClipRects)
        return;
d481 1
a481 1
    rects = malloc(sizeof(*rects) * dPriv->numClipRects);
d483 6
a488 2
    if (!rects)
        return;
d490 1
a490 16
    for (i = 0; i < dPriv->numClipRects; i++) {
        rects[i].x1 = dPriv->pClipRects[i].x1 - dPriv->x;
        rects[i].y1 = dPriv->pClipRects[i].y1 - dPriv->y;
        rects[i].x2 = dPriv->pClipRects[i].x2 - dPriv->x;
        rects[i].y2 = dPriv->pClipRects[i].y2 - dPriv->y;
    }

    driReportDamage(dPriv, rects, dPriv->numClipRects);
    free(rects);
}

static int driDrawableGetMSC( __DRIscreen *sPriv, __DRIdrawable *dPriv,
			      int64_t *msc )
{
    return sPriv->DriverAPI.GetDrawableMSC(sPriv, dPriv, msc);
}
d492 2
a493 111

static int driWaitForMSC(__DRIdrawable *dPriv, int64_t target_msc,
			 int64_t divisor, int64_t remainder,
			 int64_t * msc, int64_t * sbc)
{
    __DRIswapInfo  sInfo;
    int  status;

    status = dPriv->driScreenPriv->DriverAPI.WaitForMSC( dPriv, target_msc,
                                                         divisor, remainder,
                                                         msc );

    /* GetSwapInfo() may not be provided by the driver if GLX_SGI_video_sync
     * is supported but GLX_OML_sync_control is not.  Therefore, don't return
     * an error value if GetSwapInfo() is not implemented.
    */
    if ( status == 0
         && dPriv->driScreenPriv->DriverAPI.GetSwapInfo ) {
        status = dPriv->driScreenPriv->DriverAPI.GetSwapInfo( dPriv, & sInfo );
        *sbc = sInfo.swap_count;
    }

    return status;
}


const __DRImediaStreamCounterExtension driMediaStreamCounterExtension = {
    { __DRI_MEDIA_STREAM_COUNTER, __DRI_MEDIA_STREAM_COUNTER_VERSION },
    driWaitForMSC,
    driDrawableGetMSC,
};


static void driCopySubBuffer(__DRIdrawable *dPriv,
			      int x, int y, int w, int h)
{
    drm_clip_rect_t rect;

    rect.x1 = x;
    rect.y1 = dPriv->h - y - h;
    rect.x2 = x + w;
    rect.y2 = rect.y1 + h;
    driReportDamage(dPriv, &rect, 1);

    dPriv->driScreenPriv->DriverAPI.CopySubBuffer(dPriv, x, y, w, h);
}

const __DRIcopySubBufferExtension driCopySubBufferExtension = {
    { __DRI_COPY_SUB_BUFFER, __DRI_COPY_SUB_BUFFER_VERSION },
    driCopySubBuffer
};

static void driSetSwapInterval(__DRIdrawable *dPriv, unsigned int interval)
{
    dPriv->swap_interval = interval;
}

static unsigned int driGetSwapInterval(__DRIdrawable *dPriv)
{
    return dPriv->swap_interval;
}

const __DRIswapControlExtension driSwapControlExtension = {
    { __DRI_SWAP_CONTROL, __DRI_SWAP_CONTROL_VERSION },
    driSetSwapInterval,
    driGetSwapInterval
};


/**
 * This is called via __DRIscreenRec's createNewDrawable pointer.
 */
static __DRIdrawable *
driCreateNewDrawable(__DRIscreen *psp, const __DRIconfig *config,
		     drm_drawable_t hwDrawable, int renderType,
		     const int *attrs, void *data)
{
    __DRIdrawable *pdp;

    /* Since pbuffers are not yet supported, no drawable attributes are
     * supported either.
     */
    (void) attrs;

    pdp = malloc(sizeof *pdp);
    if (!pdp) {
	return NULL;
    }

    pdp->driContextPriv = NULL;
    pdp->loaderPrivate = data;
    pdp->hHWDrawable = hwDrawable;
    pdp->refcount = 1;
    pdp->pStamp = NULL;
    pdp->lastStamp = 0;
    pdp->index = 0;
    pdp->x = 0;
    pdp->y = 0;
    pdp->w = 0;
    pdp->h = 0;
    pdp->numClipRects = 0;
    pdp->numBackClipRects = 0;
    pdp->pClipRects = NULL;
    pdp->pBackClipRects = NULL;
    pdp->vblSeq = 0;
    pdp->vblFlags = 0;

    pdp->driScreenPriv = psp;

    if (!(*psp->DriverAPI.CreateBuffer)(psp, pdp, &config->modes, 0)) {
       free(pdp);
d497 1
a497 1
    pdp->msc_base = 0;
d499 1
a499 7
    /* This special default value is replaced with the configured
     * default value when the drawable is first bound to a direct
     * rendering context. 
     */
    pdp->swap_interval = (unsigned)-1;

    return pdp;
d502 2
a503 5

static __DRIdrawable *
dri2CreateNewDrawable(__DRIscreen *screen,
		      const __DRIconfig *config,
		      void *loaderPrivate)
d505 1
a505 13
    __DRIdrawable *pdraw;

    pdraw = driCreateNewDrawable(screen, config, 0, 0, NULL, loaderPrivate);
    if (!pdraw)
    	return NULL;

    pdraw->pClipRects = &pdraw->dri2.clipRect;
    pdraw->pBackClipRects = &pdraw->dri2.clipRect;

    pdraw->pStamp = &pdraw->dri2.stamp;
    *pdraw->pStamp = pdraw->lastStamp + 1;

    return pdraw;
d513 2
a514 2
    return (*screen->DriverAPI.AllocateBuffer)(screen, attachment, format,
					       width, height);
d520 1
a520 1
   (*screen->DriverAPI.ReleaseBuffer)(screen, buffer);
a557 107

static void dri_get_drawable(__DRIdrawable *pdp)
{
    pdp->refcount++;
}
	
static void dri_put_drawable(__DRIdrawable *pdp)
{
    __DRIscreen *psp;

    if (pdp) {
	pdp->refcount--;
	if (pdp->refcount)
	    return;

	psp = pdp->driScreenPriv;
        (*psp->DriverAPI.DestroyBuffer)(pdp);
	if (pdp->pClipRects && pdp->pClipRects != &pdp->dri2.clipRect) {
	    free(pdp->pClipRects);
	    pdp->pClipRects = NULL;
	}
	if (pdp->pBackClipRects && pdp->pClipRects != &pdp->dri2.clipRect) {
	    free(pdp->pBackClipRects);
	    pdp->pBackClipRects = NULL;
	}
	free(pdp);
    }
}

static void
driDestroyDrawable(__DRIdrawable *pdp)
{
    dri_put_drawable(pdp);
}

/*@@}*/


/*****************************************************************/
/** \name Context handling functions                             */
/*****************************************************************/
/*@@{*/

/**
 * Destroy the per-context private information.
 * 
 * \internal
 * This function calls __DriverAPIRec::DestroyContext on \p contextPrivate, calls
 * drmDestroyContext(), and finally frees \p contextPrivate.
 */
static void
driDestroyContext(__DRIcontext *pcp)
{
    if (pcp) {
	(*pcp->driScreenPriv->DriverAPI.DestroyContext)(pcp);
	free(pcp);
    }
}


/**
 * Create the per-drawable private driver information.
 * 
 * \param render_type   Type of rendering target.  \c GLX_RGBA is the only
 *                      type likely to ever be supported for direct-rendering.
 * \param shared        Context with which to share textures, etc. or NULL
 *
 * \returns An opaque pointer to the per-context private information on
 *          success, or \c NULL on failure.
 * 
 * \internal
 * This function allocates and fills a __DRIcontextRec structure.  It
 * performs some device independent initialization and passes all the
 * relevent information to __DriverAPIRec::CreateContext to create the
 * context.
 *
 */
static __DRIcontext *
driCreateNewContext(__DRIscreen *psp, const __DRIconfig *config,
		    int render_type, __DRIcontext *shared, 
		    drm_context_t hwContext, void *data)
{
    __DRIcontext *pcp;
    void * const shareCtx = (shared != NULL) ? shared->driverPrivate : NULL;

    pcp = malloc(sizeof *pcp);
    if (!pcp)
	return NULL;

    pcp->driScreenPriv = psp;
    pcp->driDrawablePriv = NULL;
    pcp->loaderPrivate = data;
    
    pcp->dri2.draw_stamp = 0;
    pcp->dri2.read_stamp = 0;

    pcp->hHWContext = hwContext;

    if ( !(*psp->DriverAPI.CreateContext)(API_OPENGL,
					  &config->modes, pcp, shareCtx) ) {
        free(pcp);
        return NULL;
    }

    return pcp;
}

a563 268
static __DRIcontext *
dri2CreateNewContextForAPI(__DRIscreen *screen, int api,
			   const __DRIconfig *config,
			   __DRIcontext *shared, void *data)
{
    __DRIcontext *context;
    const struct gl_config *modes = (config != NULL) ? &config->modes : NULL;
    void *shareCtx = (shared != NULL) ? shared->driverPrivate : NULL;
    gl_api mesa_api;

    if (!(screen->api_mask & (1 << api)))
	return NULL;

    switch (api) {
    case __DRI_API_OPENGL:
	    mesa_api = API_OPENGL;
	    break;
    case __DRI_API_GLES:
	    mesa_api = API_OPENGLES;
	    break;
    case __DRI_API_GLES2:
	    mesa_api = API_OPENGLES2;
	    break;
    default:
	    return NULL;
    }

    context = malloc(sizeof *context);
    if (!context)
	return NULL;

    context->driScreenPriv = screen;
    context->driDrawablePriv = NULL;
    context->loaderPrivate = data;
    
    if (!(*screen->DriverAPI.CreateContext)(mesa_api, modes,
					    context, shareCtx) ) {
        free(context);
        return NULL;
    }

    return context;
}


static __DRIcontext *
dri2CreateNewContext(__DRIscreen *screen, const __DRIconfig *config,
		      __DRIcontext *shared, void *data)
{
   return dri2CreateNewContextForAPI(screen, __DRI_API_OPENGL,
				     config, shared, data);
}

static int
driCopyContext(__DRIcontext *dest, __DRIcontext *src, unsigned long mask)
{
    return GL_FALSE;
}

/*@@}*/


/*****************************************************************/
/** \name Screen handling functions                              */
/*****************************************************************/
/*@@{*/

/**
 * Destroy the per-screen private information.
 * 
 * \internal
 * This function calls __DriverAPIRec::DestroyScreen on \p screenPrivate, calls
 * drmClose(), and finally frees \p screenPrivate.
 */
static void driDestroyScreen(__DRIscreen *psp)
{
    if (psp) {
	/* No interaction with the X-server is possible at this point.  This
	 * routine is called after XCloseDisplay, so there is no protocol
	 * stream open to the X-server anymore.
	 */

       _mesa_destroy_shader_compiler();

	if (psp->DriverAPI.DestroyScreen)
	    (*psp->DriverAPI.DestroyScreen)(psp);

	if (!psp->dri2.enabled) {
	   (void)drmUnmap((drmAddress)psp->pSAREA, SAREA_MAX);
	   (void)drmUnmap((drmAddress)psp->pFB, psp->fbSize);
	   (void)drmCloseOnce(psp->fd);
	} else {
	   driDestroyOptionCache(&psp->optionCache);
	   driDestroyOptionInfo(&psp->optionInfo);
	}

	free(psp);
    }
}

static void
setupLoaderExtensions(__DRIscreen *psp,
		      const __DRIextension **extensions)
{
    int i;

    for (i = 0; extensions[i]; i++) {
	if (strcmp(extensions[i]->name, __DRI_GET_DRAWABLE_INFO) == 0)
	    psp->getDrawableInfo = (__DRIgetDrawableInfoExtension *) extensions[i];
	if (strcmp(extensions[i]->name, __DRI_DAMAGE) == 0)
	    psp->damage = (__DRIdamageExtension *) extensions[i];
	if (strcmp(extensions[i]->name, __DRI_SYSTEM_TIME) == 0)
	    psp->systemTime = (__DRIsystemTimeExtension *) extensions[i];
	if (strcmp(extensions[i]->name, __DRI_DRI2_LOADER) == 0)
	    psp->dri2.loader = (__DRIdri2LoaderExtension *) extensions[i];
	if (strcmp(extensions[i]->name, __DRI_IMAGE_LOOKUP) == 0)
	    psp->dri2.image = (__DRIimageLookupExtension *) extensions[i];
	if (strcmp(extensions[i]->name, __DRI_USE_INVALIDATE) == 0)
	    psp->dri2.useInvalidate = (__DRIuseInvalidateExtension *) extensions[i];
    }
}

/**
 * This is the bootstrap function for the driver.  libGL supplies all of the
 * requisite information about the system, and the driver initializes itself.
 * This routine also fills in the linked list pointed to by \c driver_modes
 * with the \c struct gl_config that the driver can support for windows or
 * pbuffers.
 *
 * For legacy DRI.
 * 
 * \param scrn  Index of the screen
 * \param ddx_version Version of the 2D DDX.  This may not be meaningful for
 *                    all drivers.
 * \param dri_version Version of the "server-side" DRI.
 * \param drm_version Version of the kernel DRM.
 * \param frame_buffer Data describing the location and layout of the
 *                     framebuffer.
 * \param pSAREA       Pointer to the SAREA.
 * \param fd           Device handle for the DRM.
 * \param extensions   ??
 * \param driver_modes  Returns modes suppoted by the driver
 * \param loaderPrivate  ??
 * 
 * \note There is no need to check the minimum API version in this
 * function.  Since the name of this function is versioned, it is
 * impossible for a loader that is too old to even load this driver.
 */
static __DRIscreen *
driCreateNewScreen(int scrn,
		   const __DRIversion *ddx_version,
		   const __DRIversion *dri_version,
		   const __DRIversion *drm_version,
		   const __DRIframebuffer *frame_buffer,
		   drmAddress pSAREA, int fd, 
		   const __DRIextension **extensions,
		   const __DRIconfig ***driver_modes,
		   void *loaderPrivate)
{
    static const __DRIextension *emptyExtensionList[] = { NULL };
    __DRIscreen *psp;

    if (driDriverAPI.InitScreen == NULL)
	return NULL;

    psp = calloc(1, sizeof *psp);
    if (!psp)
	return NULL;

    setupLoaderExtensions(psp, extensions);

    /*
    ** NOT_DONE: This is used by the X server to detect when the client
    ** has died while holding the drawable lock.  The client sets the
    ** drawable lock to this value.
    */
    psp->drawLockID = 1;

    psp->drm_version = *drm_version;
    psp->ddx_version = *ddx_version;
    psp->dri_version = *dri_version;

    psp->pSAREA = pSAREA;
    psp->lock = (drmLock *) &psp->pSAREA->lock;

    psp->pFB = frame_buffer->base;
    psp->fbSize = frame_buffer->size;
    psp->fbStride = frame_buffer->stride;
    psp->fbWidth = frame_buffer->width;
    psp->fbHeight = frame_buffer->height;
    psp->devPrivSize = frame_buffer->dev_priv_size;
    psp->pDevPriv = frame_buffer->dev_priv;
    psp->fbBPP = psp->fbStride * 8 / frame_buffer->width;

    psp->extensions = emptyExtensionList;
    psp->fd = fd;
    psp->myNum = scrn;
    psp->dri2.enabled = GL_FALSE;

    psp->DriverAPI = driDriverAPI;
    psp->api_mask = (1 << __DRI_API_OPENGL);

    *driver_modes = driDriverAPI.InitScreen(psp);
    if (*driver_modes == NULL) {
	free(psp);
	return NULL;
    }

    return psp;
}

/**
 * DRI2
 */
static __DRIscreen *
dri2CreateNewScreen(int scrn, int fd,
		    const __DRIextension **extensions,
		    const __DRIconfig ***driver_configs, void *data)
{
    static const __DRIextension *emptyExtensionList[] = { NULL };
    __DRIscreen *psp;
    drmVersionPtr version;

    if (driDriverAPI.InitScreen2 == NULL)
        return NULL;

    psp = calloc(1, sizeof(*psp));
    if (!psp)
	return NULL;

    setupLoaderExtensions(psp, extensions);

    version = drmGetVersion(fd);
    if (version) {
	psp->drm_version.major = version->version_major;
	psp->drm_version.minor = version->version_minor;
	psp->drm_version.patch = version->version_patchlevel;
	drmFreeVersion(version);
    }

    psp->extensions = emptyExtensionList;
    psp->fd = fd;
    psp->myNum = scrn;
    psp->dri2.enabled = GL_TRUE;

    psp->DriverAPI = driDriverAPI;
    psp->api_mask = (1 << __DRI_API_OPENGL);
    *driver_configs = driDriverAPI.InitScreen2(psp);
    if (*driver_configs == NULL) {
	free(psp);
	return NULL;
    }

    psp->DriverAPI = driDriverAPI;
    psp->loaderPrivate = data;

    driParseOptionInfo(&psp->optionInfo, __dri2ConfigOptions,
		       __dri2NConfigOptions);
    driParseConfigFiles(&psp->optionCache, &psp->optionInfo, psp->myNum,
			"dri2");

    return psp;
}

static const __DRIextension **driGetExtensions(__DRIscreen *psp)
{
    return psp->extensions;
}
d567 1
a567 15
    { __DRI_CORE, __DRI_CORE_VERSION },
    NULL,
    driDestroyScreen,
    driGetExtensions,
    driGetConfigAttrib,
    driIndexConfigAttrib,
    NULL,
    driDestroyDrawable,
    driSwapBuffers,
    NULL,
    driCopyContext,
    driDestroyContext,
    driBindContext,
    driUnbindContext
};
d569 13
a581 6
/** Legacy DRI interface */
const __DRIlegacyExtension driLegacyExtension = {
    { __DRI_LEGACY, __DRI_LEGACY_VERSION },
    driCreateNewScreen,
    driCreateNewDrawable,
    driCreateNewContext,
d586 10
a595 12
    /* Force the version to 2 because the underlying drivers don't (can't!)
     * support the extra requirements of CreateContextAttribs.
     */
    { __DRI_DRI2, 2 },
    dri2CreateNewScreen,
    dri2CreateNewDrawable,
    dri2CreateNewContext,
    dri2GetAPIMask,
    dri2CreateNewContextForAPI,
    dri2AllocateBuffer,
    dri2ReleaseBuffer,
    NULL
d599 5
a603 4
   { __DRI2_CONFIG_QUERY, __DRI2_CONFIG_QUERY_VERSION },
   dri2ConfigQueryb,
   dri2ConfigQueryi,
   dri2ConfigQueryf,
a605 63
/**
 * Calculate amount of swap interval used between GLX buffer swaps.
 * 
 * The usage value, on the range [0,max], is the fraction of total swap
 * interval time used between GLX buffer swaps is calculated.
 *
 *            \f$p = t_d / (i * t_r)\f$
 * 
 * Where \f$t_d\f$ is the time since the last GLX buffer swap, \f$i\f$ is the
 * swap interval (as set by \c glXSwapIntervalSGI), and \f$t_r\f$ time
 * required for a single vertical refresh period (as returned by \c
 * glXGetMscRateOML).
 * 
 * See the documentation for the GLX_MESA_swap_frame_usage extension for more
 * details.
 *
 * \param   dPriv  Pointer to the private drawable structure.
 * \return  If less than a single swap interval time period was required
 *          between GLX buffer swaps, a number greater than 0 and less than
 *          1.0 is returned.  If exactly one swap interval time period is
 *          required, 1.0 is returned, and if more than one is required then
 *          a number greater than 1.0 will be returned.
 *
 * \sa glXSwapIntervalSGI glXGetMscRateOML
 * 
 * \todo Instead of caching the \c glXGetMscRateOML function pointer, would it
 *       be possible to cache the sync rate?
 */
float
driCalculateSwapUsage( __DRIdrawable *dPriv, int64_t last_swap_ust,
		       int64_t current_ust )
{
   int32_t   n;
   int32_t   d;
   int       interval;
   float     usage = 1.0;
   __DRIscreen *psp = dPriv->driScreenPriv;

   if ( (*psp->systemTime->getMSCRate)(dPriv, &n, &d, dPriv->loaderPrivate) ) {
      interval = (dPriv->swap_interval != 0) ? dPriv->swap_interval : 1;


      /* We want to calculate
       * (current_UST - last_swap_UST) / (interval * us_per_refresh).  We get
       * current_UST by calling __glXGetUST.  last_swap_UST is stored in
       * dPriv->swap_ust.  interval has already been calculated.
       *
       * The only tricky part is us_per_refresh.  us_per_refresh is
       * 1000000 / MSC_rate.  We know the MSC_rate is n / d.  We can flip it
       * around and say us_per_refresh = 1000000 * d / n.  Since this goes in
       * the denominator of the final calculation, we calculate
       * (interval * 1000000 * d) and move n into the numerator.
       */

      usage = (current_ust - last_swap_ust);
      usage *= n;
      usage /= (interval * d);
      usage /= 1000000.0;
   }
   
   return usage;
}

d612 18
a629 1
/*@@}*/
@


1.9
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d944 4
a947 1
    { __DRI_DRI2, __DRI_DRI2_VERSION },
d954 2
a955 1
    dri2ReleaseBuffer
@


1.8
log
@Merge Mesa 7.10.3
@
text
@d484 16
d949 3
a951 1
    dri2CreateNewContextForAPI
@


1.7
log
@Fix an X server crash when starting GLX 1.3 apps;
https://bugs.freedesktop.org/show_bug.cgi?id=29091

ok matthieu@@, oga@@
@
text
@a33 1
#include "vblank.h"
d35 1
a60 22
/**
 * Print message to \c stderr if the \c LIBGL_DEBUG environment variable
 * is set. 
 * 
 * Is called from the drivers.
 * 
 * \param f \c printf like format string.
 */
void
__driUtilMessage(const char *f, ...)
{
    va_list args;

    if (getenv("LIBGL_DEBUG")) {
        fprintf(stderr, "libGL: ");
        va_start(args, f);
        vfprintf(stderr, f, args);
        va_end(args);
        fprintf(stderr, "\n");
    }
}

a142 5
#if 0
    /* Unbind the drawable */
    pdp->driContextPriv = &psp->dummyContextPriv;
#endif

d157 8
d166 9
a174 12

    if (pcp) {
	psp = pcp->driScreenPriv;
	pcp->driDrawablePriv = pdp;
	pcp->driReadablePriv = prp;
	if (pdp) {
	    pdp->driContextPriv = pcp;
    	    dri_get_drawable(pdp);
	}
	if ( prp && pdp != prp ) {
    	    dri_get_drawable(prp);
	}
a181 1
    assert(psp);
a195 1

d422 1
a422 1
    pdp = calloc(1, sizeof *pdp);
d427 1
a445 1
    pdp->driContextPriv = &psp->dummyContextPriv;
d447 1
a447 2
    if (!(*psp->DriverAPI.CreateBuffer)(psp, pdp, &config->modes,
					renderType == GLX_PIXMAP_BIT)) {
a612 11
    /* When the first context is created for a screen, initialize a "dummy"
     * context.
     */

    if (!psp->dri2.enabled && !psp->dummyContextPriv.driScreenPriv) {
        psp->dummyContextPriv.hHWContext = psp->pSAREA->dummy_context;
        psp->dummyContextPriv.driScreenPriv = psp;
        psp->dummyContextPriv.driDrawablePriv = NULL;
        psp->dummyContextPriv.driverPrivate = NULL;
	/* No other fields should be used! */
    }
d616 2
a617 1
    if ( !(*psp->DriverAPI.CreateContext)(&config->modes, pcp, shareCtx) ) {
d625 50
d680 2
a681 1
    return driCreateNewContext(screen, config, 0, shared, 0, data);
a683 1

d713 2
d722 3
d748 2
d757 1
a757 1
 * with the \c __GLcontextModes that the driver can support for windows or
d793 3
a829 7
    /*
    ** Do not init dummy context here; actual initialization will be
    ** done when the first DRI context is created.  Init screen priv ptr
    ** to NULL to let CreateContext routine that it needs to be inited.
    */
    psp->dummyContextPriv.driScreenPriv = NULL;

d831 1
a852 1
    driOptionCache options;
d877 1
d885 1
d887 4
a890 2
    driParseOptionInfo(&options, __dri2ConfigOptions, __dri2NConfigOptions);
    driParseConfigFiles(&psp->optionCache, &options, psp->myNum, "dri2");
d932 2
a940 35
};

static int
driFrameTracking(__DRIdrawable *drawable, GLboolean enable)
{
    return GLX_BAD_CONTEXT;
}

static int
driQueryFrameTracking(__DRIdrawable *dpriv,
		      int64_t * sbc, int64_t * missedFrames,
		      float * lastMissedUsage, float * usage)
{
   __DRIswapInfo   sInfo;
   int             status;
   int64_t         ust;
   __DRIscreen *psp = dpriv->driScreenPriv;

   status = dpriv->driScreenPriv->DriverAPI.GetSwapInfo( dpriv, & sInfo );
   if ( status == 0 ) {
      *sbc = sInfo.swap_count;
      *missedFrames = sInfo.swap_missed_count;
      *lastMissedUsage = sInfo.swap_missed_usage;

      (*psp->systemTime->getUST)( & ust );
      *usage = driCalculateSwapUsage( dpriv, sInfo.swap_ust, ust );
   }

   return status;
}

const __DRIframeTrackingExtension driFrameTrackingExtension = {
    { __DRI_FRAME_TRACKING, __DRI_FRAME_TRACKING_VERSION },
    driFrameTracking,
    driQueryFrameTracking    
@


1.6
log
@Two patches cherry picked from mesa master just after 7.8 was branched
(but never made it into the 7.8 branch).

first:
Author: Jesse Barnes <jbarnes@@virtuousgeek.org>
Date:   Thu Apr 22 12:47:41 2010 -0700

    DRI2: add config query extension

    Add a new DRI2 configuration query extension.  Allows for DRI2
    client code to query for common DRI2 configuration options.

second:
Author: Jesse Barnes <jbarnes@@virtuousgeek.org>
Date:   Thu Apr 22 12:49:03 2010 -0700

    DRI2/GLX: check for vblank_mode in DRI2 GLX code

    Re-add support for the vblank_mode environment and configuration
    variable.  Useful for benchmarking and app control.

The final affect being that config and environment variables for
controlling swap mode work with dri2 now. which helps me a lot with
debugging.

ok matthieu@@.
@
text
@d446 1
a446 1
    pdp = malloc(sizeof *pdp);
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d34 11
d509 35
d834 1
d867 3
d910 7
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a0 1
/* $XFree86: xc/lib/GL/dri/dri_util.c,v 1.7 2003/04/28 17:01:25 dawes Exp $ */
d39 3
d64 1
a64 1
        fprintf(stderr, "libGL error: \n");
d100 1
a100 1
 * __DRIdrawablePrivateRec::refcount which must be non-zero for a successful
d124 3
d130 1
d136 1
a136 1
    pdp->refcount--;
d144 1
a144 1
	prp->refcount--;
d152 2
a155 1
    pcp->driDrawablePriv = NULL;
d171 1
a171 1
    __DRIscreenPrivate *psp = pcp->driScreenPriv;
d173 1
a173 4
    /*
    ** Assume error checking is done properly in glXMakeCurrent before
    ** calling driBindContext.
    */
d175 11
a185 10
    if (pcp == NULL || pdp == None || prp == None)
	return GL_FALSE;

    /* Bind the drawable to the context */
    pcp->driDrawablePriv = pdp;
    pcp->driReadablePriv = prp;
    pdp->driContextPriv = pcp;
    pdp->refcount++;
    if ( pdp != prp ) {
	prp->refcount++;
d193 1
d195 1
a195 1
	if (!pdp->pStamp || *pdp->pStamp != pdp->lastStamp) {
d200 1
a200 2
	
	if ((pdp != prp) && (!prp->pStamp || *prp->pStamp != prp->lastStamp)) {
d204 1
a204 1
	}
a207 1
    (*psp->DriverAPI.MakeCurrent)(pcp, pdp, prp);
d209 1
a209 1
    return GL_TRUE;
d225 1
a225 1
 * This function basically updates the __DRIdrawablePrivate struct's
d233 1
a233 1
__driUtilUpdateDrawableInfo(__DRIdrawablePrivate *pdp)
d235 2
a236 2
    __DRIscreenPrivate *psp = pdp->driScreenPriv;
    __DRIcontextPrivate *pcp = pdp->driContextPriv;
d247 1
a247 1
	_mesa_free(pdp->pClipRects); 
d252 1
a252 1
	_mesa_free(pdp->pBackClipRects); 
d314 1
a314 1
 * This function calls __DRIdrawablePrivate::swapBuffers.
d323 3
a325 1
    
d329 1
a329 3
    psp->DriverAPI.SwapBuffers(dPriv);

    rects = _mesa_malloc(sizeof(*rects) * dPriv->numClipRects);
d342 1
a342 1
    _mesa_free(rects);
d435 1
a435 1
    pdp = _mesa_malloc(sizeof *pdp);
d442 1
a442 1
    pdp->refcount = 0;
d462 1
a462 1
       _mesa_free(pdp);
d489 5
a493 2
    pdraw->pClipRects = _mesa_malloc(sizeof *pdraw->pBackClipRects);
    pdraw->pBackClipRects = _mesa_malloc(sizeof *pdraw->pBackClipRects);
d498 6
a503 3

static void
driDestroyDrawable(__DRIdrawable *pdp)
d505 1
a505 1
    __DRIscreenPrivate *psp;
d508 4
d514 2
a515 2
	if (pdp->pClipRects) {
	    _mesa_free(pdp->pClipRects);
d518 2
a519 2
	if (pdp->pBackClipRects) {
	    _mesa_free(pdp->pBackClipRects);
d522 1
a522 1
	_mesa_free(pdp);
d526 6
d552 1
a552 1
	_mesa_free(pcp);
d568 1
a568 1
 * This function allocates and fills a __DRIcontextPrivateRec structure.  It
d582 1
a582 1
    pcp = _mesa_malloc(sizeof *pcp);
d588 4
a591 1

d607 1
a607 1
        _mesa_free(pcp);
d661 1
a661 1
	_mesa_free(psp);
d680 2
d701 1
a701 1
 * \param pSAREA       Pointer the the SAREA.
d725 1
a725 1
    psp = _mesa_calloc(sizeof *psp);
d770 1
a770 1
	_mesa_free(psp);
d792 1
a792 1
    psp = _mesa_malloc(sizeof(*psp));
d814 1
a814 1
	_mesa_free(psp);
d854 1
a854 1
/** Legacy DRI interface */
a861 8
/* This is the table of extensions that the loader will dlsym() for. */
PUBLIC const __DRIextension *__driDriverExtensions[] = {
    &driCoreExtension.base,
    &driLegacyExtension.base,
    &driDRI2Extension.base,
    NULL
};

d876 1
a876 1
   __DRIscreenPrivate *psp = dpriv->driScreenPriv;
d926 1
a926 1
driCalculateSwapUsage( __DRIdrawablePrivate *dPriv, int64_t last_swap_ust,
d933 1
a933 1
   __DRIscreenPrivate *psp = dPriv->driScreenPriv;
d958 6
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d29 1
a29 1
#include "imports.h"
a154 1

d188 1
a188 4
    if (psp->dri2.enabled) {
       __driParseEvents(pcp, pdp);
       __driParseEvents(pcp, prp);
    } else {
a277 133

int
__driParseEvents(__DRIcontextPrivate *pcp, __DRIdrawablePrivate *pdp)
{
    __DRIscreenPrivate *psp = pdp->driScreenPriv;
    __DRIDrawableConfigEvent *dc, *last_dc;
    __DRIBufferAttachEvent *ba, *last_ba;
    unsigned int tail, mask, *p, end, total, size, changed;
    unsigned char *data;
    size_t rect_size;

    /* Check for wraparound. */
    if (pcp && psp->dri2.buffer->prealloc - pdp->dri2.tail > psp->dri2.buffer->size) {
       /* If prealloc overlaps into what we just parsed, the
	* server overwrote it and we have to reset our tail
	* pointer. */
	DRM_UNLOCK(psp->fd, psp->lock, pcp->hHWContext);
	(*psp->dri2.loader->reemitDrawableInfo)(pdp, &pdp->dri2.tail,
						pdp->loaderPrivate);
	DRM_LIGHT_LOCK(psp->fd, psp->lock, pcp->hHWContext);
    }

    total = psp->dri2.buffer->head - pdp->dri2.tail;
    mask = psp->dri2.buffer->size - 1;
    end = psp->dri2.buffer->head;
    data = psp->dri2.buffer->data;

    changed = 0;
    last_dc = NULL;
    last_ba = NULL;

    for (tail = pdp->dri2.tail; tail != end; tail += size) {
       p = (unsigned int *) (data + (tail & mask));
       size = DRI2_EVENT_SIZE(*p);
       if (size > total || (tail & mask) + size > psp->dri2.buffer->size) {
	  /* illegal data, bail out. */
	  fprintf(stderr, "illegal event size\n");
	  break;
       }

       switch (DRI2_EVENT_TYPE(*p)) {
       case DRI2_EVENT_DRAWABLE_CONFIG:
	  dc = (__DRIDrawableConfigEvent *) p;
	  if (dc->drawable == pdp->dri2.drawable_id)
	     last_dc = dc;
	  break;

       case DRI2_EVENT_BUFFER_ATTACH:
	  ba = (__DRIBufferAttachEvent *) p;
	  if (ba->drawable == pdp->dri2.drawable_id && 
	      ba->buffer.attachment == DRI_DRAWABLE_BUFFER_FRONT_LEFT)
	     last_ba = ba;
	  break;
       }
    }
	  
    if (last_dc) {
       if (pdp->w != last_dc->width || pdp->h != last_dc->height)
	  changed = 1;

       pdp->x = last_dc->x;
       pdp->y = last_dc->y;
       pdp->w = last_dc->width;
       pdp->h = last_dc->height;

       pdp->backX = 0;
       pdp->backY = 0;
       pdp->numBackClipRects = 1;
       pdp->pBackClipRects[0].x1 = 0;
       pdp->pBackClipRects[0].y1 = 0;
       pdp->pBackClipRects[0].x2 = pdp->w;
       pdp->pBackClipRects[0].y2 = pdp->h;

       pdp->numClipRects = last_dc->num_rects;
       _mesa_free(pdp->pClipRects);
       rect_size = last_dc->num_rects * sizeof last_dc->rects[0];
       pdp->pClipRects = _mesa_malloc(rect_size);
       memcpy(pdp->pClipRects, last_dc->rects, rect_size);
    }

    /* We only care about the most recent drawable config. */
    if (last_dc && changed)
       (*psp->DriverAPI.HandleDrawableConfig)(pdp, pcp, last_dc);

    /* Front buffer attachments are special, they typically mean that
     * we're rendering to a redirected window (or a child window of a
     * redirected window) and that it got resized.  Resizing the root
     * window on randr events is a special case of this.  Other causes
     * may be a window transitioning between redirected and
     * non-redirected, or a window getting reparented between parents
     * with different window pixmaps (eg two redirected windows).
     * These events are special in that the X server allocates the
     * buffer and that the buffer may be shared by other child
     * windows.  When our window share the window pixmap with its
     * parent, drawable config events doesn't affect the front buffer.
     * We only care about the last such event in the buffer; in fact,
     * older events will refer to invalid buffer objects.*/
    if (last_ba)
       (*psp->DriverAPI.HandleBufferAttach)(pdp, pcp, last_ba);

    /* If there was a drawable config event in the buffer and it
     * changed the size of the window, all buffer auxillary buffer
     * attachments prior to that are invalid (as opposed to the front
     * buffer case discussed above).  In that case we can start
     * looking for buffer attachment after the last drawable config
     * event.  If there is no drawable config event in this batch of
     * events, we have to assume that the last batch might have had
     * one and process all buffer attach events.*/
    if (last_dc && changed)
       tail = (unsigned char *) last_dc - data;
    else
       tail = pdp->dri2.tail;

    for ( ; tail != end; tail += size) {
       ba = (__DRIBufferAttachEvent *) (data + (tail & mask));
       size = DRI2_EVENT_SIZE(ba->event_header);

       if (DRI2_EVENT_TYPE(ba->event_header) != DRI2_EVENT_BUFFER_ATTACH)
	  continue;
       if (ba->drawable != pdp->dri2.drawable_id)
	  continue;
       if (last_ba == ba)
	  continue;

       (*psp->DriverAPI.HandleBufferAttach)(pdp, pcp, ba);
       changed = 1;
    }

    pdp->dri2.tail = tail;

    return changed || last_ba;
}

d291 1
a291 6
    if (psp->dri2.enabled) {
	(*psp->dri2.loader->postDamage)(pdp,
					pClipRects,
					numClipRects,
					pdp->loaderPrivate);
    } else if (psp->damage) {
d317 3
a319 1

d323 6
a328 2
    if (psp->dri2.enabled)
       __driParseEvents(NULL, dPriv);
d330 6
a335 1
    psp->DriverAPI.SwapBuffers(dPriv);
d337 2
a338 1
    driReportDamage(dPriv, dPriv->pClipRects, dPriv->numClipRects);
d475 3
a477 2
dri2CreateNewDrawable(__DRIscreen *screen, const __DRIconfig *config,
		      unsigned int drawable_id, unsigned int head, void *data)
d481 1
a481 1
    pdraw = driCreateNewDrawable(screen, config, 0, 0, NULL, data);
d485 1
a485 2
    pdraw->dri2.drawable_id = drawable_id;
    pdraw->dri2.tail = head;
d596 1
a596 12
    drm_context_t hwContext;
    DRM_CAS_RESULT(ret);

    /* DRI2 doesn't use kernel with context IDs, we just need an ID that's
     * different from the kernel context ID to make drmLock() happy. */

    do {
	hwContext = screen->dri2.lock->next_id;
	DRM_CAS(&screen->dri2.lock->next_id, hwContext, hwContext + 1, ret);
    } while (ret);

    return driCreateNewContext(screen, config, 0, shared, hwContext, data);
d632 1
a632 6
	if (psp->dri2.enabled) {
#ifdef TTM_API
	    drmBOUnmap(psp->fd, &psp->dri2.sareaBO);
	    drmBOUnreference(psp->fd, &psp->dri2.sareaBO);
#endif
	} else {
d655 2
a656 2
	if (strcmp(extensions[i]->name, __DRI_LOADER) == 0)
	    psp->dri2.loader = (__DRIloaderExtension *) extensions[i];
d700 1
a700 1
    psp = _mesa_malloc(sizeof *psp);
a751 1

d756 1
a756 1
dri2CreateNewScreen(int scrn, int fd, unsigned int sarea_handle,
a759 1
#ifdef TTM_API
a761 1
    unsigned int *p;
a785 28
    if (drmBOReference(psp->fd, sarea_handle, &psp->dri2.sareaBO)) {
	fprintf(stderr, "Failed to reference DRI2 sarea BO\n");
	_mesa_free(psp);
	return NULL;
    }

    if (drmBOMap(psp->fd, &psp->dri2.sareaBO,
		 DRM_BO_FLAG_READ | DRM_BO_FLAG_WRITE, 0, &psp->dri2.sarea)) {
	drmBOUnreference(psp->fd, &psp->dri2.sareaBO);
	_mesa_free(psp);
	return NULL;
    }

    p = psp->dri2.sarea;
    while (DRI2_SAREA_BLOCK_TYPE(*p)) {
	switch (DRI2_SAREA_BLOCK_TYPE(*p)) {
	case DRI2_SAREA_BLOCK_LOCK:
	    psp->dri2.lock = (__DRILock *) p;
	    break;
	case DRI2_SAREA_BLOCK_EVENT_BUFFER:
	    psp->dri2.buffer = (__DRIEventBuffer *) p;
	    break;
	}
	p = DRI2_SAREA_BLOCK_NEXT(p);
    }

    psp->lock = (drmLock *) &psp->dri2.lock->lock;

a788 2
	drmBOUnmap(psp->fd, &psp->dri2.sareaBO);
	drmBOUnreference(psp->fd, &psp->dri2.sareaBO);
a795 3
#else
    return NULL;
#endif
d803 1
a803 9
/** Legacy DRI interface */
const __DRIlegacyExtension driLegacyExtension = {
    { __DRI_LEGACY, __DRI_LEGACY_VERSION },
    driCreateNewScreen,
    driCreateNewDrawable,
    driCreateNewContext
};

/** DRI2 interface */
d806 1
a806 1
    dri2CreateNewScreen,
d811 1
a811 1
    dri2CreateNewDrawable,
d814 1
a814 1
    dri2CreateNewContext,
d821 16
d841 1
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d34 1
d37 1
a37 1
typedef GLboolean ( * PFNGLXGETMSCRATEOMLPROC) (__DRInativeDisplay *dpy, __DRIid drawable, int32_t *numerator, int32_t *denominator);
a39 4
/* This pointer *must* be set by the driver's __driCreateNewScreen funciton!
 */
const __DRIinterfaceMethods * dri_interface = NULL;

d41 2
a42 1
 * This is used in a couple of places that call \c driCreateNewDrawable.
d44 3
a46 21
static const int empty_attribute_list[1] = { None };


/**
 * Cached copy of the internal API version used by libGL and the client-side
 * DRI driver.
 */
static int api_ver = 0;

/* forward declarations */
static int driQueryFrameTracking( __DRInativeDisplay *dpy, void *priv,
                                  int64_t *sbc, int64_t *missedFrames,
                                  float *lastMissedUsage, float *usage );

static void *driCreateNewDrawable(__DRInativeDisplay *dpy,
                                  const __GLcontextModes *modes,
                                  __DRIid draw, __DRIdrawable *pdraw,
                                  int renderType, const int *attrs);

static void driDestroyDrawable(__DRInativeDisplay *dpy, void *drawablePrivate);

d70 2
a71 17

/*****************************************************************/
/** \name Drawable list management */
/*****************************************************************/
/*@@{*/

static GLboolean __driAddDrawable(void *drawHash, __DRIdrawable *pdraw)
{
    __DRIdrawablePrivate *pdp = (__DRIdrawablePrivate *)pdraw->private;

    if (drmHashInsert(drawHash, pdp->draw, pdraw))
	return GL_FALSE;

    return GL_TRUE;
}

static __DRIdrawable *__driFindDrawable(void *drawHash, __DRIid draw)
d73 4
a76 2
    int retcode;
    __DRIdrawable *pdraw;
d78 1
a78 6
    retcode = drmHashLookup(drawHash, draw, (void *)&pdraw);
    if (retcode)
	return NULL;

    return pdraw;
}
d80 1
a80 25

/**
 * Find drawables in the local hash that have been destroyed on the
 * server.
 * 
 * \param drawHash  Hash-table containing all know drawables.
 */
static void __driGarbageCollectDrawables(void *drawHash)
{
    __DRIid draw;
    __DRInativeDisplay *dpy;
    __DRIdrawable *pdraw;

    if (drmHashFirst(drawHash, &draw, (void *)&pdraw) == 1) {
	do {
	    __DRIdrawablePrivate *pdp = (__DRIdrawablePrivate *)pdraw->private;
	    dpy = pdp->driScreenPriv->display;
	    if (! (*dri_interface->windowExists)(dpy, draw)) {
		/* Destroy the local drawable data, if the drawable no
		   longer exists in the Xserver */
		(*pdraw->destroyDrawable)(dpy, pdraw->private);
		_mesa_free(pdraw);
	    }
	} while (drmHashNext(drawHash, &draw, (void *)&pdraw) == 1);
    }
a82 3
/*@@}*/


d91 1
a91 4
 * \param dpy the display handle.
 * \param scrn the screen number.
 * \param draw drawable.
 * \param read Current reading drawable.
d104 1
a104 3
static GLboolean driUnbindContext(__DRInativeDisplay *dpy, int scrn,
			      __DRIid draw, __DRIid read,
			      __DRIcontext *ctx)
d106 3
a108 7
    __DRIscreen *pDRIScreen;
    __DRIdrawable *pdraw;
    __DRIdrawable *pread;
    __DRIcontextPrivate *pcp;
    __DRIscreenPrivate *psp;
    __DRIdrawablePrivate *pdp;
    __DRIdrawablePrivate *prp;
d115 2
a116 27
    if (ctx == NULL || draw == None || read == None) {
	/* ERROR!!! */
	return GL_FALSE;
    }

    pDRIScreen = (*dri_interface->getScreen)(dpy, scrn);
    if ( (pDRIScreen == NULL) || (pDRIScreen->private == NULL) ) {
	/* ERROR!!! */
	return GL_FALSE;
    }

    psp = (__DRIscreenPrivate *)pDRIScreen->private;
    pcp = (__DRIcontextPrivate *)ctx->private;

    pdraw = __driFindDrawable(psp->drawHash, draw);
    if (!pdraw) {
	/* ERROR!!! */
	return GL_FALSE;
    }
    pdp = (__DRIdrawablePrivate *)pdraw->private;

    pread = __driFindDrawable(psp->drawHash, read);
    if (!pread) {
	/* ERROR!!! */
	return GL_FALSE;
    }
    prp = (__DRIdrawablePrivate *)pread->private;
d118 3
a124 1

a159 5
 * 
 * \bug This function calls \c driCreateNewDrawable in two places with the
 *      \c renderType hard-coded to \c GLX_WINDOW_BIT.  Some checking might
 *      be needed in those places when support for pbuffers and / or pixmaps
 *      is added.  Is it safe to assume that the drawable is a window?
d161 3
a163 4
static GLboolean DoBindContext(__DRInativeDisplay *dpy,
			  __DRIid draw, __DRIid read,
			  __DRIcontext *ctx, const __GLcontextModes * modes,
			  __DRIscreenPrivate *psp)
d165 1
a165 5
    __DRIdrawable *pdraw;
    __DRIdrawablePrivate *pdp;
    __DRIdrawable *pread;
    __DRIdrawablePrivate *prp;
    __DRIcontextPrivate * const pcp = ctx->private;
d167 4
d172 2
a173 48
    /* Find the _DRIdrawable which corresponds to the writing drawable. */
    pdraw = __driFindDrawable(psp->drawHash, draw);
    if (!pdraw) {
	/* Allocate a new drawable */
	pdraw = (__DRIdrawable *)_mesa_malloc(sizeof(__DRIdrawable));
	if (!pdraw) {
	    /* ERROR!!! */
	    return GL_FALSE;
	}

	/* Create a new drawable */
	driCreateNewDrawable(dpy, modes, draw, pdraw, GLX_WINDOW_BIT,
			     empty_attribute_list);
	if (!pdraw->private) {
	    /* ERROR!!! */
	    _mesa_free(pdraw);
	    return GL_FALSE;
	}

    }
    pdp = (__DRIdrawablePrivate *) pdraw->private;

    /* Find the _DRIdrawable which corresponds to the reading drawable. */
    if (read == draw) {
        /* read buffer == draw buffer */
        prp = pdp;
    }
    else {
        pread = __driFindDrawable(psp->drawHash, read);
        if (!pread) {
            /* Allocate a new drawable */
            pread = (__DRIdrawable *)_mesa_malloc(sizeof(__DRIdrawable));
            if (!pread) {
                /* ERROR!!! */
                return GL_FALSE;
            }

            /* Create a new drawable */
	    driCreateNewDrawable(dpy, modes, read, pread, GLX_WINDOW_BIT,
				 empty_attribute_list);
            if (!pread->private) {
                /* ERROR!!! */
                _mesa_free(pread);
                return GL_FALSE;
            }
        }
        prp = (__DRIdrawablePrivate *) pread->private;
    }
a187 5
    if (!pdp->pStamp || *pdp->pStamp != pdp->lastStamp) {
	DRM_SPINLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);
	__driUtilUpdateDrawableInfo(pdp);
	DRM_SPINUNLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);
    }
d189 15
a203 4
    if ((pdp != prp) && (!prp->pStamp || *prp->pStamp != prp->lastStamp)) {
	DRM_SPINLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);
	__driUtilUpdateDrawableInfo(prp);
	DRM_SPINUNLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);
a211 31

/**
 * This function takes both a read buffer and a draw buffer.  This is needed
 * for \c glXMakeCurrentReadSGI or GLX 1.3's \c glXMakeContextCurrent
 * function.
 */
static GLboolean driBindContext(__DRInativeDisplay *dpy, int scrn,
                            __DRIid draw, __DRIid read,
                            __DRIcontext * ctx)
{
    __DRIscreen *pDRIScreen;

    /*
    ** Assume error checking is done properly in glXMakeCurrent before
    ** calling driBindContext.
    */

    if (ctx == NULL || draw == None || read == None) {
	/* ERROR!!! */
	return GL_FALSE;
    }

    pDRIScreen = (*dri_interface->getScreen)(dpy, scrn);
    if ( (pDRIScreen == NULL) || (pDRIScreen->private == NULL) ) {
	/* ERROR!!! */
	return GL_FALSE;
    }

    return DoBindContext( dpy, draw, read, ctx, ctx->mode,
			  (__DRIscreenPrivate *)pDRIScreen->private );
}
d235 1
a235 1
    __DRIscreenPrivate *psp;
a245 9
    psp = pdp->driScreenPriv;
    if (!psp) {
	/* ERROR!!! */
       _mesa_problem(NULL, "Warning! Possible infinite loop due to bug "
		     "in file %s, line %d\n",
		     __FILE__, __LINE__);
	return;
    }

d258 1
a258 2
    if (!__driFindDrawable(psp->drawHash, pdp->draw) ||
	! (*dri_interface->getDrawableInfo)(pdp->display, pdp->screen, pdp->draw,
d265 2
a266 1
			  &pdp->pBackClipRects )) {
d280 2
d283 130
d422 24
a448 1
 * \param dpy the display handle.
d456 1
a456 1
static void driSwapBuffers( __DRInativeDisplay *dpy, void *drawablePrivate )
d458 1
a458 2
    __DRIdrawablePrivate *dPriv = (__DRIdrawablePrivate *) drawablePrivate;
    drm_clip_rect_t rect;
d463 2
a464 1
    dPriv->swapBuffers(dPriv);
d466 1
a466 3
    /* Check that we actually have the new damage report method */
    if (api_ver < 20070105 || dri_interface->reportDamage == NULL)
	return;
d468 1
a468 13
    /* Assume it's affecting the whole drawable for now */
    rect.x1 = 0;
    rect.y1 = 0;
    rect.x2 = rect.x1 + dPriv->w;
    rect.y2 = rect.y1 + dPriv->h;

    /* Report the damage.  Currently, all our drivers draw directly to the
     * front buffer, so we report the damage there rather than to the backing
     * store (if any).
     */
    (*dri_interface->reportDamage)(dpy, dPriv->screen, dPriv->draw,
				   dPriv->x, dPriv->y,
				   &rect, 1, GL_TRUE);
d471 2
a472 4
/**
 * Called directly from a number of higher-level GLX functions.
 */
static int driGetMSC( void *screenPrivate, int64_t *msc )
d474 1
a474 19
    __DRIscreenPrivate *sPriv = (__DRIscreenPrivate *) screenPrivate;

    return sPriv->DriverAPI.GetMSC( sPriv, msc );
}

/**
 * Called directly from a number of higher-level GLX functions.
 */
static int driGetSBC( __DRInativeDisplay *dpy, void *drawablePrivate, int64_t *sbc )
{
   __DRIdrawablePrivate *dPriv = (__DRIdrawablePrivate *) drawablePrivate;
   __DRIswapInfo  sInfo;
   int  status;


   status = dPriv->driScreenPriv->DriverAPI.GetSwapInfo( dPriv, & sInfo );
   *sbc = sInfo.swap_count;

   return status;
a476 9
static int driWaitForSBC( __DRInativeDisplay * dpy, void *drawablePriv,
			  int64_t target_sbc,
			  int64_t * msc, int64_t * sbc )
{
    __DRIdrawablePrivate *dPriv = (__DRIdrawablePrivate *) drawablePriv;

    return dPriv->driScreenPriv->DriverAPI.WaitForSBC( dPriv, target_sbc,
                                                       msc, sbc );
}
d478 3
a480 4
static int driWaitForMSC( __DRInativeDisplay * dpy, void *drawablePriv,
			  int64_t target_msc,
			  int64_t divisor, int64_t remainder,
			  int64_t * msc, int64_t * sbc )
a481 1
    __DRIdrawablePrivate *dPriv = (__DRIdrawablePrivate *) drawablePriv;
a484 1

d502 10
a511 3
static int64_t driSwapBuffersMSC( __DRInativeDisplay * dpy, void *drawablePriv,
				  int64_t target_msc,
				  int64_t divisor, int64_t remainder )
d513 1
a513 1
    __DRIdrawablePrivate *dPriv = (__DRIdrawablePrivate *) drawablePriv;
d515 17
a531 3
    return dPriv->driScreenPriv->DriverAPI.SwapBuffersMSC( dPriv, target_msc,
                                                           divisor, 
                                                           remainder );
d534 1
a534 2
static void driCopySubBuffer( __DRInativeDisplay *dpy, void *drawablePrivate,
			      int x, int y, int w, int h)
d536 1
a536 3
    __DRIdrawablePrivate *dPriv = (__DRIdrawablePrivate *) drawablePrivate;
    dPriv->driScreenPriv->DriverAPI.CopySubBuffer(dPriv, x, y, w, h);
    (void) dpy;
d539 7
d549 4
a552 6
static void *driCreateNewDrawable(__DRInativeDisplay *dpy,
				  const __GLcontextModes *modes,
				  __DRIid draw,
				  __DRIdrawable *pdraw,
				  int renderType,
				  const int *attrs)
d554 1
a554 6
    __DRIscreen * const pDRIScreen = (*dri_interface->getScreen)(dpy, modes->screen);
    __DRIscreenPrivate *psp;
    __DRIdrawablePrivate *pdp;


    pdraw->private = NULL;
d561 1
a561 5
    if ( (pDRIScreen == NULL) || (pDRIScreen->private == NULL) ) {
	return NULL;
    }

    pdp = (__DRIdrawablePrivate *)_mesa_malloc(sizeof(__DRIdrawablePrivate));
d566 2
a567 7
    if (!(*dri_interface->createDrawable)(dpy, modes->screen, draw, &pdp->hHWDrawable)) {
	_mesa_free(pdp);
	return NULL;
    }

    pdp->draw = draw;
    pdp->pdraw = pdraw;
d580 2
a581 2
    pdp->display = dpy;
    pdp->screen = modes->screen;
a582 1
    psp = (__DRIscreenPrivate *)pDRIScreen->private;
d586 1
a586 1
    if (!(*psp->DriverAPI.CreateBuffer)(psp, pdp, modes,
a587 1
       (void)(*dri_interface->destroyDrawable)(dpy, modes->screen, pdp->draw);
d592 1
a592 13
    pdraw->private = pdp;
    pdraw->destroyDrawable = driDestroyDrawable;
    pdraw->swapBuffers = driSwapBuffers;  /* called by glXSwapBuffers() */

    pdraw->getSBC = driGetSBC;
    pdraw->waitForSBC = driWaitForSBC;
    pdraw->waitForMSC = driWaitForMSC;
    pdraw->swapBuffersMSC = driSwapBuffersMSC;
    pdraw->frameTracking = NULL;
    pdraw->queryFrameTracking = driQueryFrameTracking;

    if (driCompareGLXAPIVersion (20060314) >= 0)
	pdraw->copySubBuffer = driCopySubBuffer;
d598 1
a598 1
    pdraw->swap_interval = (unsigned)-1;
d600 2
a601 10
    pdp->swapBuffers = psp->DriverAPI.SwapBuffers;

    /* Add pdraw to drawable list */
    if (!__driAddDrawable(psp->drawHash, pdraw)) {
	/* ERROR!!! */
	(*pdraw->destroyDrawable)(dpy, pdp);
	_mesa_free(pdp);
	pdp = NULL;
	pdraw->private = NULL;
    }
a602 2
   return (void *) pdp;
}
d605 2
a606 1
driGetDrawable(__DRInativeDisplay *dpy, __DRIid draw, void *screenPrivate)
d608 9
a616 1
    __DRIscreenPrivate *psp = (__DRIscreenPrivate *) screenPrivate;
d618 1
a618 5
    /*
    ** Make sure this routine returns NULL if the drawable is not bound
    ** to a direct rendering context!
    */
    return __driFindDrawable(psp->drawHash, draw);
d621 1
d623 1
a623 1
driDestroyDrawable(__DRInativeDisplay *dpy, void *drawablePrivate)
a624 1
    __DRIdrawablePrivate *pdp = (__DRIdrawablePrivate *) drawablePrivate;
a625 1
    int scrn;
a628 1
	scrn = psp->myNum;
a629 3
	if ((*dri_interface->windowExists)(dpy, pdp->draw))
	    (void)(*dri_interface->destroyDrawable)(dpy, scrn, pdp->draw);
	drmHashDelete(psp->drawHash, pdp->draw);
a652 4
 * \param dpy the display handle.
 * \param scrn the screen number.
 * \param contextPrivate opaque pointer to the per-drawable private info.
 *
d658 1
a658 1
driDestroyContext(__DRInativeDisplay *dpy, int scrn, void *contextPrivate)
a659 2
    __DRIcontextPrivate  *pcp   = (__DRIcontextPrivate *) contextPrivate;

a661 2
	__driGarbageCollectDrawables(pcp->driScreenPriv->drawHash);
	(void) (*dri_interface->destroyContext)(dpy, scrn, pcp->contextID);
a669 2
 * \param dpy           The display handle.
 * \param modes         Mode used to create the new context.
d672 1
a672 3
 * \param sharedPrivate The shared context dependent methods or \c NULL if
 *                      non-existent.
 * \param pctx          DRI context to receive the context dependent methods.
d684 7
a690 17
static void *
driCreateNewContext(__DRInativeDisplay *dpy, const __GLcontextModes *modes,
		    int render_type, void *sharedPrivate, __DRIcontext *pctx)
{
    __DRIscreen *pDRIScreen;
    __DRIcontextPrivate *pcp;
    __DRIcontextPrivate *pshare = (__DRIcontextPrivate *) sharedPrivate;
    __DRIscreenPrivate *psp;
    void * const shareCtx = (pshare != NULL) ? pshare->driverPrivate : NULL;

    pDRIScreen = (*dri_interface->getScreen)(dpy, modes->screen);
    if ( (pDRIScreen == NULL) || (pDRIScreen->private == NULL) ) {
	/* ERROR!!! */
	return NULL;
    } 

    psp = (__DRIscreenPrivate *)pDRIScreen->private;
d692 2
a693 2
    pcp = (__DRIcontextPrivate *)_mesa_malloc(sizeof(__DRIcontextPrivate));
    if (!pcp) {
a694 7
    }

    if (! (*dri_interface->createContext)(dpy, modes->screen, modes->fbconfigID,
					&pcp->contextID, &pcp->hHWContext)) {
	_mesa_free(pcp);
	return NULL;
    }
a695 1
    pcp->display = dpy;
d703 1
a703 2
    if (!psp->dummyContextPriv.driScreenPriv) {
        psp->dummyContextPriv.contextID = 0;
d711 3
a713 7
    pctx->destroyContext = driDestroyContext;
    pctx->bindContext    = driBindContext;
    pctx->unbindContext  = driUnbindContext;

    if ( !(*psp->DriverAPI.CreateContext)(modes, pcp, shareCtx) ) {
        (void) (*dri_interface->destroyContext)(dpy, modes->screen,
						pcp->contextID);
d718 3
a720 1
    __driGarbageCollectDrawables(pcp->driScreenPriv->drawHash);
d722 23
a744 1
    return pcp;
d746 1
a757 4
 * \param dpy the display handle.
 * \param scrn the screen number.
 * \param screenPrivate opaque pointer to the per-screen private information.
 *
d762 1
a762 1
static void driDestroyScreen(__DRInativeDisplay *dpy, int scrn, void *screenPrivate)
a763 2
    __DRIscreenPrivate *psp = (__DRIscreenPrivate *) screenPrivate;

d773 9
a781 6
	(void)drmUnmap((drmAddress)psp->pSAREA, SAREA_MAX);
	(void)drmUnmap((drmAddress)psp->pFB, psp->fbSize);
	_mesa_free(psp->pDevPriv);
	(void)drmCloseOnce(psp->fd);
	if ( psp->modes != NULL ) {
	    (*dri_interface->destroyContextModes)( psp->modes );
a783 3
	assert(psp->drawHash);
	drmHashDestroy(psp->drawHash);

d788 17
d807 7
a813 1
 * Utility function used to create a new driver-private screen structure.
a814 1
 * \param dpy   Display pointer
a815 7
 * \param psc   DRI screen data (not driver private)
 * \param modes Linked list of known display modes.  This list is, at a
 *              minimum, a list of modes based on the current display mode.
 *              These roughly match the set of available X11 visuals, but it
 *              need not be limited to X11!  The calling libGL should create
 *              a list that will inform the driver of the current display
 *              mode (i.e., color buffer depth, depth buffer depth, etc.).
d824 7
a830 8
 * \param internal_api_version  Version of the internal interface between the
 *                              driver and libGL.
 * \param driverAPI Driver API functions used by other routines in dri_util.c.
 * 
 * \note
 * There is no need to check the minimum API version in this function.  Since
 * the \c __driCreateNewScreen function is versioned, it is impossible for a
 * loader that is too old to even load this driver.
d832 10
a841 11
__DRIscreenPrivate *
__driUtilCreateNewScreen(__DRInativeDisplay *dpy, int scrn, __DRIscreen *psc,
			 __GLcontextModes * modes,
			 const __DRIversion * ddx_version,
			 const __DRIversion * dri_version,
			 const __DRIversion * drm_version,
			 const __DRIframebuffer * frame_buffer,
			 drm_sarea_t *pSAREA,
			 int fd,
			 int internal_api_version,
			 const struct __DriverAPIRec *driverAPI)
d843 2
a844 9
    __DRIscreenPrivate *psp;


    api_ver = internal_api_version;

    psp = (__DRIscreenPrivate *)_mesa_malloc(sizeof(__DRIscreenPrivate));
    if (!psp) {
	return NULL;
    }
d846 2
a847 4
    /* Create the hash table */
    psp->drawHash = drmHashCreate();
    if ( psp->drawHash == NULL ) {
	_mesa_free( psp );
a848 1
    }
d850 1
a850 4
    psp->display = dpy;
    psp->myNum = scrn;
    psp->psc = psc;
    psp->modes = modes;
d859 3
a861 12
    psp->drmMajor = drm_version->major;
    psp->drmMinor = drm_version->minor;
    psp->drmPatch = drm_version->patch;
    psp->ddxMajor = ddx_version->major;
    psp->ddxMinor = ddx_version->minor;
    psp->ddxPatch = ddx_version->patch;
    psp->driMajor = dri_version->major;
    psp->driMinor = dri_version->minor;
    psp->driPatch = dri_version->patch;

    /* install driver's callback functions */
    memcpy( &psp->DriverAPI, driverAPI, sizeof(struct __DriverAPIRec) );
d864 1
d875 1
d877 2
d887 5
a891 12
    psc->destroyScreen     = driDestroyScreen;
    psc->createNewDrawable = driCreateNewDrawable;
    psc->getDrawable       = driGetDrawable;
    psc->getMSC            = driGetMSC;
    psc->createNewContext  = driCreateNewContext;

    if (internal_api_version >= 20070121)
	psc->setTexOffset  = psp->DriverAPI.setTexOffset;

    if ( (psp->DriverAPI.InitDriver != NULL)
	 && !(*psp->DriverAPI.InitDriver)(psp) ) {
	_mesa_free( psp );
a894 1

d900 1
a900 12
 * Compare the current GLX API version with a driver supplied required version.
 * 
 * The minimum required version is compared with the API version exported by
 * the \c __glXGetInternalVersion function (in libGL.so).
 * 
 * \param   required_version Minimum required internal GLX API version.
 * \return  A tri-value return, as from strcmp is returned.  A value less
 *          than, equal to, or greater than zero will be returned if the
 *          internal GLX API version is less than, equal to, or greater
 *          than \c required_version.
 *
 * \sa __glXGetInternalVersion().
d902 79
a980 1
int driCompareGLXAPIVersion( GLint required_version )
d982 35
a1016 6
   if ( api_ver > required_version ) {
      return 1;
   }
   else if ( api_ver == required_version ) {
      return 0;
   }
d1018 4
a1021 1
   return -1;
a1023 1

d1025 3
a1027 3
driQueryFrameTracking( __DRInativeDisplay * dpy, void * priv,
		       int64_t * sbc, int64_t * missedFrames,
		       float * lastMissedUsage, float * usage )
d1032 1
a1032 2
   __DRIdrawablePrivate * dpriv = (__DRIdrawablePrivate *) priv;

d1040 1
a1040 1
      (*dri_interface->getUST)( & ust );
d1047 5
d1089 1
d1091 2
a1092 4

   if ( (*dri_interface->getMSCRate)( dPriv->display, dPriv->draw, &n, &d ) ) {
      interval = (dPriv->pdraw->swap_interval != 0)
	  ? dPriv->pdraw->swap_interval : 1;
@


1.1
log
@Initial revision
@
text
@d326 1
d343 6
d412 6
a417 3
    if (!pcp || (pdp != pcp->driDrawablePriv)) {
	/* ERROR!!! */
	return;
d423 3
d431 1
d436 1
d487 5
d493 18
a510 1
    (void) dpy;
d881 1
a881 1
	(void)drmClose(psp->fd);
d1002 3
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a325 1
    pcp->driReadablePriv = prp;
a341 6
    if ((pdp != prp) && (!pdp->pStamp || *pdp->pStamp != pdp->lastStamp)) {
	DRM_SPINLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);
	__driUtilUpdateDrawableInfo(prp);
	DRM_SPINUNLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);
    }

d405 3
a407 6
    if (!pcp 
	|| ((pdp != pcp->driDrawablePriv) && (pdp != pcp->driReadablePriv))) {
	/* ERROR!!! 
	 * ...but we must ignore it. There can be many contexts bound to a
	 * drawable.
	 */
a412 3
       _mesa_problem("Warning! Possible infinite loop due to bug "
		     "in file %s, line %d\n",
		     __FILE__, __LINE__);
d844 1
a844 1
	(void)drmCloseOnce(psp->fd);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d343 1
a343 1
    if ((pdp != prp) && (!prp->pStamp || *prp->pStamp != prp->lastStamp)) {
d423 1
a423 1
       _mesa_problem(NULL, "Warning! Possible infinite loop due to bug "
a430 1
	pdp->pClipRects = NULL;
a434 1
	pdp->pBackClipRects = NULL;
a484 2
    drm_clip_rect_t rect;

d486 1
a486 18

    /* Check that we actually have the new damage report method */
    if (api_ver < 20070105 || dri_interface->reportDamage == NULL)
	return;

    /* Assume it's affecting the whole drawable for now */
    rect.x1 = 0;
    rect.y1 = 0;
    rect.x2 = rect.x1 + dPriv->w;
    rect.y2 = rect.y1 + dPriv->h;

    /* Report the damage.  Currently, all our drivers draw directly to the
     * front buffer, so we report the damage there rather than to the backing
     * store (if any).
     */
    (*dri_interface->reportDamage)(dpy, dPriv->screen, dPriv->draw,
				   dPriv->x, dPriv->y,
				   &rect, 1, GL_TRUE);
a977 3

    if (internal_api_version >= 20070121)
	psc->setTexOffset  = psp->DriverAPI.setTexOffset;
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d1 1
d29 1
a29 1
#include "main/imports.h"
a33 12
#include "utils.h"
#include "xmlpool.h"
#include "../glsl/glsl_parser_extras.h"

PUBLIC const char __dri2ConfigOptions[] =
   DRI_CONF_BEGIN
      DRI_CONF_SECTION_PERFORMANCE
         DRI_CONF_VBLANK_MODE(DRI_CONF_VBLANK_DEF_INTERVAL_1)
      DRI_CONF_SECTION_END
   DRI_CONF_END;

static const uint __dri2NConfigOptions = 1;
d36 1
a36 1
typedef GLboolean ( * PFNGLXGETMSCRATEOMLPROC) (__DRIdrawable *drawable, int32_t *numerator, int32_t *denominator);
d39 9
a47 2
static void dri_get_drawable(__DRIdrawable *pdp);
static void dri_put_drawable(__DRIdrawable *pdp);
d50 2
a51 2
 * This is just a token extension used to signal that the driver
 * supports setting a read drawable.
d53 36
a88 3
const __DRIextension driReadDrawableExtension = {
    __DRI_READ_DRAWABLE, __DRI_READ_DRAWABLE_VERSION
};
d90 7
a96 2
GLint
driIntersectArea( drm_clip_rect_t rect1, drm_clip_rect_t rect2 )
d98 1
a98 4
   if (rect2.x1 > rect1.x1) rect1.x1 = rect2.x1;
   if (rect2.x2 < rect1.x2) rect1.x2 = rect2.x2;
   if (rect2.y1 > rect1.y1) rect1.y1 = rect2.y1;
   if (rect2.y2 < rect1.y2) rect1.y2 = rect2.y2;
d100 2
a101 1
   if (rect1.x1 > rect1.x2 || rect1.y1 > rect1.y2) return 0;
d103 1
a103 1
   return (rect1.x2 - rect1.x1) * (rect1.y2 - rect1.y1);
d106 42
d156 4
a159 1
 * \param scrn the screen.
d166 1
a166 1
 * __DRIdrawableRec::refcount which must be non-zero for a successful
d172 3
a174 1
static int driUnbindContext(__DRIcontext *pcp)
d176 7
a182 3
    __DRIscreen *psp;
    __DRIdrawable *pdp;
    __DRIdrawable *prp;
d189 28
a216 2
    if (pcp == NULL)
        return GL_FALSE;
a217 7
    psp = pcp->driScreenPriv;
    pdp = pcp->driDrawablePriv;
    prp = pcp->driReadablePriv;

    /* already unbound */
    if (!pdp && !prp)
      return GL_TRUE;
d221 1
a221 1
    assert(pdp);
d227 1
a227 1
    dri_put_drawable(pdp);
d235 1
a235 1
    	dri_put_drawable(prp);
d243 5
a247 1
    pcp->driDrawablePriv = pcp->driReadablePriv = NULL;
d252 1
d257 5
d263 4
a266 3
static int driBindContext(__DRIcontext *pcp,
			  __DRIdrawable *pdp,
			  __DRIdrawable *prp)
d268 5
a272 1
    __DRIscreen *psp = NULL;
a273 4
    /*
    ** Assume error checking is done properly in glXMakeCurrent before
    ** calling driUnbindContext.
    */
d275 48
a322 2
    if (!pcp)
	return GL_FALSE;
a324 1
    psp = pcp->driScreenPriv;
d327 4
a330 6
    if (pdp) {
	pdp->driContextPriv = pcp;
	dri_get_drawable(pdp);
    }
    if (prp && pdp != prp) {
	dri_get_drawable(prp);
d337 5
d343 4
a346 11
    if (!psp->dri2.enabled) {
	if (pdp && !pdp->pStamp) {
	    DRM_SPINLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);
	    __driUtilUpdateDrawableInfo(pdp);
	    DRM_SPINUNLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);
	}
	if (prp && pdp != prp && !prp->pStamp) {
	    DRM_SPINLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);
	    __driUtilUpdateDrawableInfo(prp);
	    DRM_SPINUNLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);
        }
d350 3
a352 1
    return (*psp->DriverAPI.MakeCurrent)(pcp, pdp, prp);
d355 31
d399 1
a399 1
 * This function basically updates the __DRIdrawable struct's
d407 1
a407 1
__driUtilUpdateDrawableInfo(__DRIdrawable *pdp)
d409 2
a410 2
    __DRIscreen *psp = pdp->driScreenPriv;
    __DRIcontext *pcp = pdp->driContextPriv;
d420 9
d430 1
a430 1
	free(pdp->pClipRects); 
d435 1
a435 1
	free(pdp->pBackClipRects); 
d441 2
a442 1
    if (! (*psp->getDrawableInfo->getDrawableInfo)(pdp,
d449 1
a449 2
			  &pdp->pBackClipRects,
			  pdp->loaderPrivate)) {
d463 1
a472 19
static void driReportDamage(__DRIdrawable *pdp,
			    struct drm_clip_rect *pClipRects, int numClipRects)
{
    __DRIscreen *psp = pdp->driScreenPriv;

    /* Check that we actually have the new damage report method */
    if (psp->damage) {
	/* Report the damage.  Currently, all our drivers draw
	 * directly to the front buffer, so we report the damage there
	 * rather than to the backing storein (if any).
	 */
	(*psp->damage->reportDamage)(pdp,
				     pdp->x, pdp->y,
				     pClipRects, numClipRects,
				     GL_TRUE, pdp->loaderPrivate);
    }
}


d476 1
d480 1
a480 1
 * This function calls __DRIdrawable::swapBuffers.
d484 1
a484 1
static void driSwapBuffers(__DRIdrawable *dPriv)
d486 2
a487 3
    __DRIscreen *psp = dPriv->driScreenPriv;
    drm_clip_rect_t *rects;
    int i;
d489 1
a489 1
    psp->DriverAPI.SwapBuffers(dPriv);
d491 3
a493 2
    if (!dPriv->numClipRects)
        return;
d495 33
a527 1
    rects = malloc(sizeof(*rects) * dPriv->numClipRects);
a528 2
    if (!rects)
        return;
d530 2
a531 6
    for (i = 0; i < dPriv->numClipRects; i++) {
        rects[i].x1 = dPriv->pClipRects[i].x1 - dPriv->x;
        rects[i].y1 = dPriv->pClipRects[i].y1 - dPriv->y;
        rects[i].x2 = dPriv->pClipRects[i].x2 - dPriv->x;
        rects[i].y2 = dPriv->pClipRects[i].y2 - dPriv->y;
    }
d533 1
a533 2
    driReportDamage(dPriv, rects, dPriv->numClipRects);
    free(rects);
d536 3
a538 2
static int driDrawableGetMSC( __DRIscreen *sPriv, __DRIdrawable *dPriv,
			      int64_t *msc )
d540 4
a543 1
    return sPriv->DriverAPI.GetDrawableMSC(sPriv, dPriv, msc);
d546 4
a549 4

static int driWaitForMSC(__DRIdrawable *dPriv, int64_t target_msc,
			 int64_t divisor, int64_t remainder,
			 int64_t * msc, int64_t * sbc)
d551 1
d555 1
d573 5
d579 4
a582 5
const __DRImediaStreamCounterExtension driMediaStreamCounterExtension = {
    { __DRI_MEDIA_STREAM_COUNTER, __DRI_MEDIA_STREAM_COUNTER_VERSION },
    driWaitForMSC,
    driDrawableGetMSC,
};
d584 1
a584 2

static void driCopySubBuffer(__DRIdrawable *dPriv,
d587 1
a587 8
    drm_clip_rect_t rect;

    rect.x1 = x;
    rect.y1 = dPriv->h - y - h;
    rect.x2 = x + w;
    rect.y2 = rect.y1 + h;
    driReportDamage(dPriv, &rect, 1);

d589 1
a591 22
const __DRIcopySubBufferExtension driCopySubBufferExtension = {
    { __DRI_COPY_SUB_BUFFER, __DRI_COPY_SUB_BUFFER_VERSION },
    driCopySubBuffer
};

static void driSetSwapInterval(__DRIdrawable *dPriv, unsigned int interval)
{
    dPriv->swap_interval = interval;
}

static unsigned int driGetSwapInterval(__DRIdrawable *dPriv)
{
    return dPriv->swap_interval;
}

const __DRIswapControlExtension driSwapControlExtension = {
    { __DRI_SWAP_CONTROL, __DRI_SWAP_CONTROL_VERSION },
    driSetSwapInterval,
    driGetSwapInterval
};


d595 13
a607 6
static __DRIdrawable *
driCreateNewDrawable(__DRIscreen *psp, const __DRIconfig *config,
		     drm_drawable_t hwDrawable, int renderType,
		     const int *attrs, void *data)
{
    __DRIdrawable *pdp;
d614 5
a618 1
    pdp = malloc(sizeof *pdp);
d623 8
a630 4
    pdp->driContextPriv = NULL;
    pdp->loaderPrivate = data;
    pdp->hHWDrawable = hwDrawable;
    pdp->refcount = 1;
d642 2
a643 2
    pdp->vblSeq = 0;
    pdp->vblFlags = 0;
d645 1
d647 1
d649 4
a652 2
    if (!(*psp->DriverAPI.CreateBuffer)(psp, pdp, &config->modes, 0)) {
       free(pdp);
d656 13
a668 1
    pdp->msc_base = 0;
d674 1
a674 1
    pdp->swap_interval = (unsigned)-1;
d676 1
a676 2
    return pdp;
}
d678 8
d687 1
a687 18
static __DRIdrawable *
dri2CreateNewDrawable(__DRIscreen *screen,
		      const __DRIconfig *config,
		      void *loaderPrivate)
{
    __DRIdrawable *pdraw;

    pdraw = driCreateNewDrawable(screen, config, 0, 0, NULL, loaderPrivate);
    if (!pdraw)
    	return NULL;

    pdraw->pClipRects = &pdraw->dri2.clipRect;
    pdraw->pBackClipRects = &pdraw->dri2.clipRect;

    pdraw->pStamp = &pdraw->dri2.stamp;
    *pdraw->pStamp = pdraw->lastStamp + 1;

    return pdraw;
d690 2
a691 2
static int
dri2ConfigQueryb(__DRIscreen *screen, const char *var, GLboolean *val)
d693 1
a693 2
   if (!driCheckOption(&screen->optionCache, var, DRI_BOOL))
      return -1;
d695 5
a699 3
   *val = driQueryOptionb(&screen->optionCache, var);

   return 0;
d702 2
a703 2
static int
dri2ConfigQueryi(__DRIscreen *screen, const char *var, GLint *val)
d705 3
a707 29
   if (!driCheckOption(&screen->optionCache, var, DRI_INT) &&
       !driCheckOption(&screen->optionCache, var, DRI_ENUM))
      return -1;

    *val = driQueryOptioni(&screen->optionCache, var);

    return 0;
}

static int
dri2ConfigQueryf(__DRIscreen *screen, const char *var, GLfloat *val)
{
   if (!driCheckOption(&screen->optionCache, var, DRI_FLOAT))
      return -1;

    *val = driQueryOptionf(&screen->optionCache, var);

    return 0;
}


static void dri_get_drawable(__DRIdrawable *pdp)
{
    pdp->refcount++;
}
	
static void dri_put_drawable(__DRIdrawable *pdp)
{
    __DRIscreen *psp;
a709 4
	pdp->refcount--;
	if (pdp->refcount)
	    return;

d711 1
d713 5
a717 2
	if (pdp->pClipRects && pdp->pClipRects != &pdp->dri2.clipRect) {
	    free(pdp->pClipRects);
d720 2
a721 2
	if (pdp->pBackClipRects && pdp->pClipRects != &pdp->dri2.clipRect) {
	    free(pdp->pBackClipRects);
d724 1
a724 1
	free(pdp);
a727 6
static void
driDestroyDrawable(__DRIdrawable *pdp)
{
    dri_put_drawable(pdp);
}

d739 4
d748 1
a748 1
driDestroyContext(__DRIcontext *pcp)
d750 2
d754 3
a756 1
	free(pcp);
d764 2
d768 3
a770 1
 * \param shared        Context with which to share textures, etc. or NULL
d776 1
a776 1
 * This function allocates and fills a __DRIcontextRec structure.  It
d782 9
a790 7
static __DRIcontext *
driCreateNewContext(__DRIscreen *psp, const __DRIconfig *config,
		    int render_type, __DRIcontext *shared, 
		    drm_context_t hwContext, void *data)
{
    __DRIcontext *pcp;
    void * const shareCtx = (shared != NULL) ? shared->driverPrivate : NULL;
d792 3
a794 2
    pcp = malloc(sizeof *pcp);
    if (!pcp)
d796 1
d798 1
a798 6
    pcp->driScreenPriv = psp;
    pcp->driDrawablePriv = NULL;
    pcp->loaderPrivate = data;
    
    pcp->dri2.draw_stamp = 0;
    pcp->dri2.read_stamp = 0;
d800 3
a802 6
    pcp->hHWContext = hwContext;

    if ( !(*psp->DriverAPI.CreateContext)(API_OPENGL,
					  &config->modes, pcp, shareCtx) ) {
        free(pcp);
        return NULL;
d805 3
a807 20
    return pcp;
}

static unsigned int
dri2GetAPIMask(__DRIscreen *screen)
{
    return screen->api_mask;
}

static __DRIcontext *
dri2CreateNewContextForAPI(__DRIscreen *screen, int api,
			   const __DRIconfig *config,
			   __DRIcontext *shared, void *data)
{
    __DRIcontext *context;
    const struct gl_config *modes = (config != NULL) ? &config->modes : NULL;
    void *shareCtx = (shared != NULL) ? shared->driverPrivate : NULL;
    gl_api mesa_api;

    if (!(screen->api_mask & (1 << api)))
d809 1
d811 3
a813 13
    switch (api) {
    case __DRI_API_OPENGL:
	    mesa_api = API_OPENGL;
	    break;
    case __DRI_API_GLES:
	    mesa_api = API_OPENGLES;
	    break;
    case __DRI_API_GLES2:
	    mesa_api = API_OPENGLES2;
	    break;
    default:
	    return NULL;
    }
d815 3
a817 3
    context = malloc(sizeof *context);
    if (!context)
	return NULL;
d819 17
a835 7
    context->driScreenPriv = screen;
    context->driDrawablePriv = NULL;
    context->loaderPrivate = data;
    
    if (!(*screen->DriverAPI.CreateContext)(mesa_api, modes,
					    context, shareCtx) ) {
        free(context);
d839 1
a839 2
    return context;
}
d841 1
a841 7

static __DRIcontext *
dri2CreateNewContext(__DRIscreen *screen, const __DRIconfig *config,
		      __DRIcontext *shared, void *data)
{
   return dri2CreateNewContextForAPI(screen, __DRI_API_OPENGL,
				     config, shared, data);
a842 7

static int
driCopyContext(__DRIcontext *dest, __DRIcontext *src, unsigned long mask)
{
    return GL_FALSE;
}

d854 4
d862 1
a862 1
static void driDestroyScreen(__DRIscreen *psp)
d864 2
a871 2
       _mesa_destroy_shader_compiler();

d875 6
a880 7
	if (!psp->dri2.enabled) {
	   (void)drmUnmap((drmAddress)psp->pSAREA, SAREA_MAX);
	   (void)drmUnmap((drmAddress)psp->pFB, psp->fbSize);
	   (void)drmCloseOnce(psp->fd);
	} else {
	   driDestroyOptionCache(&psp->optionCache);
	   driDestroyOptionInfo(&psp->optionInfo);
d883 4
a886 1
	free(psp);
a889 21
static void
setupLoaderExtensions(__DRIscreen *psp,
		      const __DRIextension **extensions)
{
    int i;

    for (i = 0; extensions[i]; i++) {
	if (strcmp(extensions[i]->name, __DRI_GET_DRAWABLE_INFO) == 0)
	    psp->getDrawableInfo = (__DRIgetDrawableInfoExtension *) extensions[i];
	if (strcmp(extensions[i]->name, __DRI_DAMAGE) == 0)
	    psp->damage = (__DRIdamageExtension *) extensions[i];
	if (strcmp(extensions[i]->name, __DRI_SYSTEM_TIME) == 0)
	    psp->systemTime = (__DRIsystemTimeExtension *) extensions[i];
	if (strcmp(extensions[i]->name, __DRI_DRI2_LOADER) == 0)
	    psp->dri2.loader = (__DRIdri2LoaderExtension *) extensions[i];
	if (strcmp(extensions[i]->name, __DRI_IMAGE_LOOKUP) == 0)
	    psp->dri2.image = (__DRIimageLookupExtension *) extensions[i];
	if (strcmp(extensions[i]->name, __DRI_USE_INVALIDATE) == 0)
	    psp->dri2.useInvalidate = (__DRIuseInvalidateExtension *) extensions[i];
    }
}
d892 1
a892 7
 * This is the bootstrap function for the driver.  libGL supplies all of the
 * requisite information about the system, and the driver initializes itself.
 * This routine also fills in the linked list pointed to by \c driver_modes
 * with the \c struct gl_config that the driver can support for windows or
 * pbuffers.
 *
 * For legacy DRI.
d894 1
d896 7
d909 1
a909 1
 * \param pSAREA       Pointer to the SAREA.
d911 20
a930 18
 * \param extensions   ??
 * \param driver_modes  Returns modes suppoted by the driver
 * \param loaderPrivate  ??
 * 
 * \note There is no need to check the minimum API version in this
 * function.  Since the name of this function is versioned, it is
 * impossible for a loader that is too old to even load this driver.
 */
static __DRIscreen *
driCreateNewScreen(int scrn,
		   const __DRIversion *ddx_version,
		   const __DRIversion *dri_version,
		   const __DRIversion *drm_version,
		   const __DRIframebuffer *frame_buffer,
		   drmAddress pSAREA, int fd, 
		   const __DRIextension **extensions,
		   const __DRIconfig ***driver_modes,
		   void *loaderPrivate)
d932 2
a933 2
    static const __DRIextension *emptyExtensionList[] = { NULL };
    __DRIscreen *psp;
d935 4
a938 1
    if (driDriverAPI.InitScreen == NULL)
d940 1
d942 4
a945 2
    psp = calloc(1, sizeof *psp);
    if (!psp)
d947 1
d949 4
a952 1
    setupLoaderExtensions(psp, extensions);
d961 12
a972 3
    psp->drm_version = *drm_version;
    psp->ddx_version = *ddx_version;
    psp->dri_version = *dri_version;
a974 1
    psp->lock = (drmLock *) &psp->pSAREA->lock;
a984 1
    psp->extensions = emptyExtensionList;
a985 2
    psp->myNum = scrn;
    psp->dri2.enabled = GL_FALSE;
d987 6
a992 2
    psp->DriverAPI = driDriverAPI;
    psp->api_mask = (1 << __DRI_API_OPENGL);
d994 12
a1005 3
    *driver_modes = driDriverAPI.InitScreen(psp);
    if (*driver_modes == NULL) {
	free(psp);
d1009 1
d1013 1
d1015 12
a1026 1
 * DRI2
d1028 8
a1035 8
static __DRIscreen *
dri2CreateNewScreen(int scrn, int fd,
		    const __DRIextension **extensions,
		    const __DRIconfig ***driver_configs, void *data)
{
    static const __DRIextension *emptyExtensionList[] = { NULL };
    __DRIscreen *psp;
    drmVersionPtr version;
d1037 2
a1038 2
    if (driDriverAPI.InitScreen2 == NULL)
        return NULL;
a1039 3
    psp = calloc(1, sizeof(*psp));
    if (!psp)
	return NULL;
d1041 16
a1056 1
    setupLoaderExtensions(psp, extensions);
d1058 3
a1060 28
    version = drmGetVersion(fd);
    if (version) {
	psp->drm_version.major = version->version_major;
	psp->drm_version.minor = version->version_minor;
	psp->drm_version.patch = version->version_patchlevel;
	drmFreeVersion(version);
    }

    psp->extensions = emptyExtensionList;
    psp->fd = fd;
    psp->myNum = scrn;
    psp->dri2.enabled = GL_TRUE;

    psp->DriverAPI = driDriverAPI;
    psp->api_mask = (1 << __DRI_API_OPENGL);
    *driver_configs = driDriverAPI.InitScreen2(psp);
    if (*driver_configs == NULL) {
	free(psp);
	return NULL;
    }

    psp->DriverAPI = driDriverAPI;
    psp->loaderPrivate = data;

    driParseOptionInfo(&psp->optionInfo, __dri2ConfigOptions,
		       __dri2NConfigOptions);
    driParseConfigFiles(&psp->optionCache, &psp->optionInfo, psp->myNum,
			"dri2");
d1062 1
a1062 1
    return psp;
a1064 47
static const __DRIextension **driGetExtensions(__DRIscreen *psp)
{
    return psp->extensions;
}

/** Core interface */
const __DRIcoreExtension driCoreExtension = {
    { __DRI_CORE, __DRI_CORE_VERSION },
    NULL,
    driDestroyScreen,
    driGetExtensions,
    driGetConfigAttrib,
    driIndexConfigAttrib,
    NULL,
    driDestroyDrawable,
    driSwapBuffers,
    NULL,
    driCopyContext,
    driDestroyContext,
    driBindContext,
    driUnbindContext
};

/** Legacy DRI interface */
const __DRIlegacyExtension driLegacyExtension = {
    { __DRI_LEGACY, __DRI_LEGACY_VERSION },
    driCreateNewScreen,
    driCreateNewDrawable,
    driCreateNewContext,
};

/** DRI2 interface */
const __DRIdri2Extension driDRI2Extension = {
    { __DRI_DRI2, __DRI_DRI2_VERSION },
    dri2CreateNewScreen,
    dri2CreateNewDrawable,
    dri2CreateNewContext,
    dri2GetAPIMask,
    dri2CreateNewContextForAPI
};

const __DRI2configQueryExtension dri2ConfigQueryExtension = {
   { __DRI2_CONFIG_QUERY, __DRI2_CONFIG_QUERY_VERSION },
   dri2ConfigQueryb,
   dri2ConfigQueryi,
   dri2ConfigQueryf,
};
d1095 1
a1095 1
driCalculateSwapUsage( __DRIdrawable *dPriv, int64_t last_swap_ust,
a1101 1
   __DRIscreen *psp = dPriv->driScreenPriv;
d1103 4
a1106 2
   if ( (*psp->systemTime->getMSCRate)(dPriv, &n, &d, dPriv->loaderPrivate) ) {
      interval = (dPriv->swap_interval != 0) ? dPriv->swap_interval : 1;
a1127 6
}

void
dri2InvalidateDrawable(__DRIdrawable *drawable)
{
    drawable->dri2.stamp++;
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@a0 24
/*
 * (C) Copyright IBM Corporation 2002, 2004
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

d18 13
a30 1
#include <xf86drm.h>
d32 1
d46 3
a48 10
/*****************************************************************/
/** \name Screen handling functions                              */
/*****************************************************************/
/*@@{*/

static void
setupLoaderExtensions(__DRIscreen *psp,
		      const __DRIextension **extensions)
{
    int i;
d50 2
a51 52
    for (i = 0; extensions[i]; i++) {
	if (strcmp(extensions[i]->name, __DRI_DRI2_LOADER) == 0)
	    psp->dri2.loader = (__DRIdri2LoaderExtension *) extensions[i];
	if (strcmp(extensions[i]->name, __DRI_IMAGE_LOOKUP) == 0)
	    psp->dri2.image = (__DRIimageLookupExtension *) extensions[i];
	if (strcmp(extensions[i]->name, __DRI_USE_INVALIDATE) == 0)
	    psp->dri2.useInvalidate = (__DRIuseInvalidateExtension *) extensions[i];
    }
}

static __DRIscreen *
dri2CreateNewScreen(int scrn, int fd,
		    const __DRIextension **extensions,
		    const __DRIconfig ***driver_configs, void *data)
{
    static const __DRIextension *emptyExtensionList[] = { NULL };
    __DRIscreen *psp;
    drmVersionPtr version;

    psp = calloc(1, sizeof(*psp));
    if (!psp)
	return NULL;

    setupLoaderExtensions(psp, extensions);

    version = drmGetVersion(fd);
    if (version) {
	psp->drm_version.major = version->version_major;
	psp->drm_version.minor = version->version_minor;
	psp->drm_version.patch = version->version_patchlevel;
	drmFreeVersion(version);
    }

    psp->loaderPrivate = data;

    psp->extensions = emptyExtensionList;
    psp->fd = fd;
    psp->myNum = scrn;

    psp->api_mask = (1 << __DRI_API_OPENGL);

    *driver_configs = driDriverAPI.InitScreen(psp);
    if (*driver_configs == NULL) {
	free(psp);
	return NULL;
    }

    driParseOptionInfo(&psp->optionInfo, __dri2ConfigOptions, __dri2NConfigOptions);
    driParseConfigFiles(&psp->optionCache, &psp->optionInfo, psp->myNum, "dri2");

    return psp;
}
d54 2
a55 5
 * Destroy the per-screen private information.
 * 
 * \internal
 * This function calls __DriverAPIRec::DestroyScreen on \p screenPrivate, calls
 * drmClose(), and finally frees \p screenPrivate.
d57 3
a59 181
static void driDestroyScreen(__DRIscreen *psp)
{
    if (psp) {
	/* No interaction with the X-server is possible at this point.  This
	 * routine is called after XCloseDisplay, so there is no protocol
	 * stream open to the X-server anymore.
	 */

       _mesa_destroy_shader_compiler();

	driDriverAPI.DestroyScreen(psp);

	driDestroyOptionCache(&psp->optionCache);
	driDestroyOptionInfo(&psp->optionInfo);

	free(psp);
    }
}

static const __DRIextension **driGetExtensions(__DRIscreen *psp)
{
    return psp->extensions;
}

/*@@}*/


/*****************************************************************/
/** \name Context handling functions                             */
/*****************************************************************/
/*@@{*/

static __DRIcontext *
dri2CreateContextAttribs(__DRIscreen *screen, int api,
			 const __DRIconfig *config,
			 __DRIcontext *shared,
			 unsigned num_attribs,
			 const uint32_t *attribs,
			 unsigned *error,
			 void *data)
{
    __DRIcontext *context;
    const struct gl_config *modes = (config != NULL) ? &config->modes : NULL;
    void *shareCtx = (shared != NULL) ? shared->driverPrivate : NULL;
    gl_api mesa_api;
    unsigned major_version = 1;
    unsigned minor_version = 0;
    uint32_t flags = 0;

    assert((num_attribs == 0) || (attribs != NULL));

    if (!(screen->api_mask & (1 << api))) {
	*error = __DRI_CTX_ERROR_BAD_API;
	return NULL;
    }

    switch (api) {
    case __DRI_API_OPENGL:
	mesa_api = API_OPENGL_COMPAT;
	break;
    case __DRI_API_GLES:
	mesa_api = API_OPENGLES;
	break;
    case __DRI_API_GLES2:
    case __DRI_API_GLES3:
	mesa_api = API_OPENGLES2;
	break;
    case __DRI_API_OPENGL_CORE:
        mesa_api = API_OPENGL_CORE;
        break;
    default:
	*error = __DRI_CTX_ERROR_BAD_API;
	return NULL;
    }

    for (unsigned i = 0; i < num_attribs; i++) {
	switch (attribs[i * 2]) {
	case __DRI_CTX_ATTRIB_MAJOR_VERSION:
	    major_version = attribs[i * 2 + 1];
	    break;
	case __DRI_CTX_ATTRIB_MINOR_VERSION:
	    minor_version = attribs[i * 2 + 1];
	    break;
	case __DRI_CTX_ATTRIB_FLAGS:
	    flags = attribs[i * 2 + 1];
	    break;
	default:
	    /* We can't create a context that satisfies the requirements of an
	     * attribute that we don't understand.  Return failure.
	     */
	    assert(!"Should not get here.");
	    *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
	    return NULL;
	}
    }

    /* Mesa does not support the GL_ARB_compatibilty extension or the
     * compatibility profile.  This means that we treat a API_OPENGL_COMPAT 3.1 as
     * API_OPENGL_CORE and reject API_OPENGL_COMPAT 3.2+.
     */
    if (mesa_api == API_OPENGL_COMPAT && major_version == 3 && minor_version == 1)
       mesa_api = API_OPENGL_CORE;

    if (mesa_api == API_OPENGL_COMPAT
        && ((major_version > 3)
            || (major_version == 3 && minor_version >= 2))) {
       *error = __DRI_CTX_ERROR_BAD_API;
       return NULL;
    }

    /* The EGL_KHR_create_context spec says:
     *
     *     "Flags are only defined for OpenGL context creation, and specifying
     *     a flags value other than zero for other types of contexts,
     *     including OpenGL ES contexts, will generate an error."
     *
     * The GLX_EXT_create_context_es2_profile specification doesn't say
     * anything specific about this case.  However, none of the known flags
     * have any meaning in an ES context, so this seems safe.
     */
    if (mesa_api != API_OPENGL_COMPAT
        && mesa_api != API_OPENGL_CORE
        && flags != 0) {
	*error = __DRI_CTX_ERROR_BAD_FLAG;
	return NULL;
    }

    /* There are no forward-compatible contexts before OpenGL 3.0.  The
     * GLX_ARB_create_context spec says:
     *
     *     "Forward-compatible contexts are defined only for OpenGL versions
     *     3.0 and later."
     *
     * Forward-looking contexts are supported by silently converting the
     * requested API to API_OPENGL_CORE.
     *
     * In Mesa, a debug context is the same as a regular context.
     */
    if ((flags & __DRI_CTX_FLAG_FORWARD_COMPATIBLE) != 0) {
       mesa_api = API_OPENGL_CORE;
    }

    if ((flags & ~(__DRI_CTX_FLAG_DEBUG | __DRI_CTX_FLAG_FORWARD_COMPATIBLE))
        != 0) {
	*error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
	return NULL;
    }

    context = calloc(1, sizeof *context);
    if (!context) {
	*error = __DRI_CTX_ERROR_NO_MEMORY;
	return NULL;
    }

    context->loaderPrivate = data;

    context->driScreenPriv = screen;
    context->driDrawablePriv = NULL;
    context->driReadablePriv = NULL;

    if (!driDriverAPI.CreateContext(mesa_api, modes, context,
				    major_version, minor_version,
				    flags, error, shareCtx) ) {
        free(context);
        return NULL;
    }

    *error = __DRI_CTX_ERROR_SUCCESS;
    return context;
}

static __DRIcontext *
dri2CreateNewContextForAPI(__DRIscreen *screen, int api,
			   const __DRIconfig *config,
			   __DRIcontext *shared, void *data)
{
    unsigned error;

    return dri2CreateContextAttribs(screen, api, config, shared, 0, NULL,
				    &error, data);
}
d61 2
a62 3
static __DRIcontext *
dri2CreateNewContext(__DRIscreen *screen, const __DRIconfig *config,
		      __DRIcontext *shared, void *data)
d64 4
a67 3
    return dri2CreateNewContextForAPI(screen, __DRI_API_OPENGL,
				      config, shared, data);
}
d69 1
a69 15
/**
 * Destroy the per-context private information.
 * 
 * \internal
 * This function calls __DriverAPIRec::DestroyContext on \p contextPrivate, calls
 * drmDestroyContext(), and finally frees \p contextPrivate.
 */
static void
driDestroyContext(__DRIcontext *pcp)
{
    if (pcp) {
	driDriverAPI.DestroyContext(pcp);
	free(pcp);
    }
}
d71 1
a71 7
static int
driCopyContext(__DRIcontext *dest, __DRIcontext *src, unsigned long mask)
{
    (void) dest;
    (void) src;
    (void) mask;
    return GL_FALSE;
a73 3
/*@@}*/


a78 34
static void dri_get_drawable(__DRIdrawable *pdp);
static void dri_put_drawable(__DRIdrawable *pdp);

/**
 * This function takes both a read buffer and a draw buffer.  This is needed
 * for \c glXMakeCurrentReadSGI or GLX 1.3's \c glXMakeContextCurrent
 * function.
 */
static int driBindContext(__DRIcontext *pcp,
			  __DRIdrawable *pdp,
			  __DRIdrawable *prp)
{
    /*
    ** Assume error checking is done properly in glXMakeCurrent before
    ** calling driUnbindContext.
    */

    if (!pcp)
	return GL_FALSE;

    /* Bind the drawable to the context */
    pcp->driDrawablePriv = pdp;
    pcp->driReadablePriv = prp;
    if (pdp) {
	pdp->driContextPriv = pcp;
	dri_get_drawable(pdp);
    }
    if (prp && pdp != prp) {
	dri_get_drawable(prp);
    }

    return driDriverAPI.MakeCurrent(pcp, pdp, prp);
}

d97 1
d107 1
a107 1
	return GL_FALSE;
d109 1
d115 3
a117 3
	return GL_TRUE;

    driDriverAPI.UnbindContext(pcp);
d128 1
a128 1
	if (prp->refcount == 0) {
d133 1
a133 1
	dri_put_drawable(prp);
d136 1
d141 1
a141 2
    pcp->driDrawablePriv = NULL;
    pcp->driReadablePriv = NULL;
d146 10
a155 1
/*@@}*/
d157 4
d162 2
a163 4
static void dri_get_drawable(__DRIdrawable *pdp)
{
    pdp->refcount++;
}
d165 4
a168 2
static void dri_put_drawable(__DRIdrawable *pdp)
{
d170 110
a279 3
	pdp->refcount--;
	if (pdp->refcount)
	    return;
d281 10
a290 2
	driDriverAPI.DestroyBuffer(pdp);
	free(pdp);
d294 12
a305 4
static __DRIdrawable *
dri2CreateNewDrawable(__DRIscreen *screen,
		      const __DRIconfig *config,
		      void *data)
d307 24
a330 1
    __DRIdrawable *pdraw;
d332 5
a336 3
    pdraw = malloc(sizeof *pdraw);
    if (!pdraw)
	return NULL;
a337 1
    pdraw->loaderPrivate = data;
d339 6
a344 6
    pdraw->driScreenPriv = screen;
    pdraw->driContextPriv = NULL;
    pdraw->refcount = 0;
    pdraw->lastStamp = 0;
    pdraw->w = 0;
    pdraw->h = 0;
d346 3
a348 1
    dri_get_drawable(pdraw);
d350 8
a357 3
    if (!driDriverAPI.CreateBuffer(screen, pdraw, &config->modes, GL_FALSE)) {
       free(pdraw);
       return NULL;
d360 21
a380 1
    pdraw->dri2.stamp = pdraw->lastStamp + 1;
d382 1
a382 1
    return pdraw;
d385 6
a390 2
static void
driDestroyDrawable(__DRIdrawable *pdp)
d392 1
a392 1
    dri_put_drawable(pdp);
d395 1
a395 4
static __DRIbuffer *
dri2AllocateBuffer(__DRIscreen *screen,
		   unsigned int attachment, unsigned int format,
		   int width, int height)
d397 1
a397 2
    return driDriverAPI.AllocateBuffer(screen, attachment, format,
				       width, height);
d400 14
a413 2
static void
dri2ReleaseBuffer(__DRIscreen *screen, __DRIbuffer *buffer)
d415 46
a460 1
    driDriverAPI.ReleaseBuffer(screen, buffer);
d464 20
d518 107
d631 268
d902 15
a916 1
    .base = { __DRI_CORE, __DRI_CORE_VERSION },
d918 6
a923 13
    .createNewScreen            = NULL,
    .destroyScreen              = driDestroyScreen,
    .getExtensions              = driGetExtensions,
    .getConfigAttrib            = driGetConfigAttrib,
    .indexConfigAttrib          = driIndexConfigAttrib,
    .createNewDrawable          = NULL,
    .destroyDrawable            = driDestroyDrawable,
    .swapBuffers                = NULL,
    .createNewContext           = NULL,
    .copyContext                = driCopyContext,
    .destroyContext             = driDestroyContext,
    .bindContext                = driBindContext,
    .unbindContext              = driUnbindContext
d928 6
a933 10
    .base = { __DRI_DRI2, 3 },

    .createNewScreen            = dri2CreateNewScreen,
    .createNewDrawable          = dri2CreateNewDrawable,
    .createNewContext           = dri2CreateNewContext,
    .getAPIMask                 = dri2GetAPIMask,
    .createNewContextForAPI     = dri2CreateNewContextForAPI,
    .allocateBuffer             = dri2AllocateBuffer,
    .releaseBuffer              = dri2ReleaseBuffer,
    .createContextAttribs       = dri2CreateContextAttribs
d937 5
a941 1
   .base = { __DRI2_CONFIG_QUERY, __DRI2_CONFIG_QUERY_VERSION },
d943 62
a1004 4
   .configQueryb        = dri2ConfigQueryb,
   .configQueryi        = dri2ConfigQueryi,
   .configQueryf        = dri2ConfigQueryf,
};
d1012 1
a1012 18
/**
 * Check that the gl_framebuffer associated with dPriv is the right size.
 * Resize the gl_framebuffer if needed.
 * It's expected that the dPriv->driverPrivate member points to a
 * gl_framebuffer object.
 */
void
driUpdateFramebufferSize(struct gl_context *ctx, const __DRIdrawable *dPriv)
{
   struct gl_framebuffer *fb = (struct gl_framebuffer *) dPriv->driverPrivate;
   if (fb && (dPriv->w != fb->Width || dPriv->h != fb->Height)) {
      ctx->Driver.ResizeBuffers(ctx, fb, dPriv->w, dPriv->h);
      /* if the driver needs the hw lock for ResizeBuffers, the drawable
         might have changed again by now */
      assert(fb->Width == dPriv->w);
      assert(fb->Height == dPriv->h);
   }
}
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@a41 2
#include <stdbool.h>
#ifndef __NOT_HAVE_DRM_H
a42 1
#endif
a46 4
#include "main/mtypes.h"
#include "main/version.h"
#include "main/errors.h"
#include "main/macros.h"
d55 2
a74 4
	if (strcmp(extensions[i]->name, __DRI_SWRAST_LOADER) == 0)
	    psp->swrast_loader = (__DRIswrastLoaderExtension *) extensions[i];
        if (strcmp(extensions[i]->name, __DRI_IMAGE_LOADER) == 0)
           psp->image.loader = (__DRIimageLoaderExtension *) extensions[i];
a77 24
/**
 * This pointer determines which driver API we'll use in the case of the
 * loader not passing us an explicit driver extensions list (that would,
 * itself, contain a pointer to a driver API.)
 *
 * A driver's driDriverGetExtensions_drivername() can update this pointer to
 * what it's returning, and a loader that is ignorant of createNewScreen2()
 * will get the correct driver screen created, as long as no other
 * driDriverGetExtensions() happened in between the first one and the
 * createNewScreen().
 *
 * This allows the X Server to not require the significant dri_interface.h
 * updates for doing createNewScreen2(), which would discourage backporting of
 * the X Server patches to support the new loader interface.
 */
const struct __DriverAPIRec *globalDriverAPI = &driDriverAPI;

/**
 * This is the first entrypoint in the driver called by the DRI driver loader
 * after dlopen()ing it.
 *
 * It's used to create global state for the driver across contexts on the same
 * Display.
 */
d79 3
a81 4
driCreateNewScreen2(int scrn, int fd,
                    const __DRIextension **extensions,
                    const __DRIextension **driver_extensions,
                    const __DRIconfig ***driver_configs, void *data)
d85 1
a90 15
    /* By default, use the global driDriverAPI symbol (non-megadrivers). */
    psp->driver = globalDriverAPI;

    /* If the driver exposes its vtable through its extensions list
     * (megadrivers), use that instead.
     */
    if (driver_extensions) {
       for (int i = 0; driver_extensions[i]; i++) {
          if (strcmp(driver_extensions[i]->name, __DRI_DRIVER_VTABLE) == 0) {
             psp->driver =
                ((__DRIDriverVtableExtension *)driver_extensions[i])->vtable;
          }
       }
    }

d93 6
a98 9
#ifndef __NOT_HAVE_DRM_H
    if (fd != -1) {
       drmVersionPtr version = drmGetVersion(fd);
       if (version) {
          psp->drm_version.major = version->version_major;
          psp->drm_version.minor = version->version_minor;
          psp->drm_version.patch = version->version_patchlevel;
          drmFreeVersion(version);
       }
a99 1
#endif
d107 3
a109 1
    *driver_configs = psp->driver->InitScreen(psp);
d115 1
a115 20
    int gl_version_override = _mesa_get_gl_version_override();
    if (gl_version_override >= 31) {
       psp->max_gl_core_version = MAX2(psp->max_gl_core_version,
                                       gl_version_override);
    } else {
       psp->max_gl_compat_version = MAX2(psp->max_gl_compat_version,
                                         gl_version_override);
    }

    psp->api_mask = (1 << __DRI_API_OPENGL);
    if (psp->max_gl_core_version > 0)
       psp->api_mask |= (1 << __DRI_API_OPENGL_CORE);
    if (psp->max_gl_es1_version > 0)
       psp->api_mask |= (1 << __DRI_API_GLES);
    if (psp->max_gl_es2_version > 0)
       psp->api_mask |= (1 << __DRI_API_GLES2);
    if (psp->max_gl_es2_version >= 30)
       psp->api_mask |= (1 << __DRI_API_GLES3);

    driParseOptionInfo(&psp->optionInfo, __dri2ConfigOptions);
a117 1

a120 27
static __DRIscreen *
dri2CreateNewScreen(int scrn, int fd,
		    const __DRIextension **extensions,
		    const __DRIconfig ***driver_configs, void *data)
{
   return driCreateNewScreen2(scrn, fd, extensions, NULL,
                               driver_configs, data);
}

/** swrast driver createNewScreen entrypoint. */
static __DRIscreen *
driSWRastCreateNewScreen(int scrn, const __DRIextension **extensions,
                         const __DRIconfig ***driver_configs, void *data)
{
   return driCreateNewScreen2(scrn, -1, extensions, NULL,
                               driver_configs, data);
}

static __DRIscreen *
driSWRastCreateNewScreen2(int scrn, const __DRIextension **extensions,
                          const __DRIextension **driver_extensions,
                          const __DRIconfig ***driver_configs, void *data)
{
   return driCreateNewScreen2(scrn, -1, extensions, driver_extensions,
                               driver_configs, data);
}

d138 1
a138 1
	psp->driver->DestroyScreen(psp);
a154 39
static bool
validate_context_version(__DRIscreen *screen,
                         int mesa_api,
                         unsigned major_version,
                         unsigned minor_version,
                         unsigned *dri_ctx_error)
{
   unsigned req_version = 10 * major_version + minor_version;
   unsigned max_version = 0;

   switch (mesa_api) {
   case API_OPENGL_COMPAT:
      max_version = screen->max_gl_compat_version;
      break;
   case API_OPENGL_CORE:
      max_version = screen->max_gl_core_version;
      break;
   case API_OPENGLES:
      max_version = screen->max_gl_es1_version;
      break;
   case API_OPENGLES2:
      max_version = screen->max_gl_es2_version;
      break;
   default:
      max_version = 0;
      break;
   }

   if (max_version == 0) {
      *dri_ctx_error = __DRI_CTX_ERROR_BAD_API;
      return false;
   } else if (req_version > max_version) {
      *dri_ctx_error = __DRI_CTX_ERROR_BAD_VERSION;
      return false;
   }

   return true;
}

d161 7
a167 7
driCreateContextAttribs(__DRIscreen *screen, int api,
                        const __DRIconfig *config,
                        __DRIcontext *shared,
                        unsigned num_attribs,
                        const uint32_t *attribs,
                        unsigned *error,
                        void *data)
a175 1
    bool notify_reset = false;
a213 4
        case __DRI_CTX_ATTRIB_RESET_STRATEGY:
            notify_reset = (attribs[i * 2 + 1]
                            != __DRI_CTX_RESET_NO_NOTIFICATION);
            break;
d270 2
a271 4
    const uint32_t allowed_flags = (__DRI_CTX_FLAG_DEBUG
                                    | __DRI_CTX_FLAG_FORWARD_COMPATIBLE
                                    | __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS);
    if (flags & ~allowed_flags) {
a275 4
    if (!validate_context_version(screen, mesa_api,
                                  major_version, minor_version, error))
       return NULL;

d288 3
a290 3
    if (!screen->driver->CreateContext(mesa_api, modes, context,
                                       major_version, minor_version,
                                       flags, notify_reset, error, shareCtx)) {
a298 11
void
driContextSetFlags(struct gl_context *ctx, uint32_t flags)
{
    if ((flags & __DRI_CTX_FLAG_FORWARD_COMPATIBLE) != 0)
        ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT;
    if ((flags & __DRI_CTX_FLAG_DEBUG) != 0) {
       _mesa_set_debug_state_int(ctx, GL_DEBUG_OUTPUT, GL_TRUE);
        ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_DEBUG_BIT;
    }
}

d300 3
a302 3
driCreateNewContextForAPI(__DRIscreen *screen, int api,
                          const __DRIconfig *config,
                          __DRIcontext *shared, void *data)
d306 2
a307 2
    return driCreateContextAttribs(screen, api, config, shared, 0, NULL,
                                   &error, data);
d311 2
a312 2
driCreateNewContext(__DRIscreen *screen, const __DRIconfig *config,
                    __DRIcontext *shared, void *data)
d314 2
a315 2
    return driCreateNewContextForAPI(screen, __DRI_API_OPENGL,
                                     config, shared, data);
d329 1
a329 1
	pcp->driScreenPriv->driver->DestroyContext(pcp);
d382 1
a382 1
    return pcp->driScreenPriv->driver->MakeCurrent(pcp, pdp, prp);
d421 1
a421 1
    pcp->driScreenPriv->driver->UnbindContext(pcp);
d440 4
d465 1
a465 1
	pdp->driScreenPriv->driver->DestroyBuffer(pdp);
d471 3
a473 3
driCreateNewDrawable(__DRIscreen *screen,
                     const __DRIconfig *config,
                     void *data)
d492 1
a492 2
    if (!screen->driver->CreateBuffer(screen, pdraw, &config->modes,
                                      GL_FALSE)) {
d513 2
a514 2
    return screen->driver->AllocateBuffer(screen, attachment, format,
                                          width, height);
d520 1
a520 1
    screen->driver->ReleaseBuffer(screen, buffer);
d559 1
a559 1
driGetAPIMask(__DRIscreen *screen)
a563 13
/**
 * swrast swapbuffers entrypoint.
 *
 * DRI2 implements this inside the loader with only flushes handled by the
 * driver.
 */
static void
driSwapBuffers(__DRIdrawable *pdp)
{
    assert(pdp->driScreenPriv->swrast_loader);

    pdp->driScreenPriv->driver->SwapBuffers(pdp);
}
d576 2
a577 2
    .swapBuffers                = driSwapBuffers, /* swrast */
    .createNewContext           = driCreateNewContext, /* swrast */
d586 1
a586 1
    .base = { __DRI_DRI2, 4 },
d589 4
a592 4
    .createNewDrawable          = driCreateNewDrawable,
    .createNewContext           = driCreateNewContext,
    .getAPIMask                 = driGetAPIMask,
    .createNewContextForAPI     = driCreateNewContextForAPI,
d595 1
a595 12
    .createContextAttribs       = driCreateContextAttribs,
    .createNewScreen2           = driCreateNewScreen2,
};

const __DRIswrastExtension driSWRastExtension = {
    .base = { __DRI_SWRAST, 4 },

    .createNewScreen            = driSWRastCreateNewScreen,
    .createNewDrawable          = driCreateNewDrawable,
    .createNewContextForAPI     = driCreateNewContextForAPI,
    .createContextAttribs       = driCreateContextAttribs,
    .createNewScreen2           = driSWRastCreateNewScreen2,
d599 1
a599 1
   .base = { __DRI2_CONFIG_QUERY, 1 },
a629 88

uint32_t
driGLFormatToImageFormat(mesa_format format)
{
   switch (format) {
   case MESA_FORMAT_B5G6R5_UNORM:
      return __DRI_IMAGE_FORMAT_RGB565;
   case MESA_FORMAT_B8G8R8X8_UNORM:
      return __DRI_IMAGE_FORMAT_XRGB8888;
   case MESA_FORMAT_B10G10R10A2_UNORM:
      return __DRI_IMAGE_FORMAT_ARGB2101010;
   case MESA_FORMAT_B10G10R10X2_UNORM:
      return __DRI_IMAGE_FORMAT_XRGB2101010;
   case MESA_FORMAT_B8G8R8A8_UNORM:
      return __DRI_IMAGE_FORMAT_ARGB8888;
   case MESA_FORMAT_R8G8B8A8_UNORM:
      return __DRI_IMAGE_FORMAT_ABGR8888;
   case MESA_FORMAT_R8G8B8X8_UNORM:
      return __DRI_IMAGE_FORMAT_XBGR8888;
   case MESA_FORMAT_R_UNORM8:
      return __DRI_IMAGE_FORMAT_R8;
   case MESA_FORMAT_R8G8_UNORM:
      return __DRI_IMAGE_FORMAT_GR88;
   case MESA_FORMAT_NONE:
      return __DRI_IMAGE_FORMAT_NONE;
   case MESA_FORMAT_B8G8R8A8_SRGB:
      return __DRI_IMAGE_FORMAT_SARGB8;
   default:
      return 0;
   }
}

mesa_format
driImageFormatToGLFormat(uint32_t image_format)
{
   switch (image_format) {
   case __DRI_IMAGE_FORMAT_RGB565:
      return MESA_FORMAT_B5G6R5_UNORM;
   case __DRI_IMAGE_FORMAT_XRGB8888:
      return MESA_FORMAT_B8G8R8X8_UNORM;
   case __DRI_IMAGE_FORMAT_ARGB2101010:
      return MESA_FORMAT_B10G10R10A2_UNORM;
   case __DRI_IMAGE_FORMAT_XRGB2101010:
      return MESA_FORMAT_B10G10R10X2_UNORM;
   case __DRI_IMAGE_FORMAT_ARGB8888:
      return MESA_FORMAT_B8G8R8A8_UNORM;
   case __DRI_IMAGE_FORMAT_ABGR8888:
      return MESA_FORMAT_R8G8B8A8_UNORM;
   case __DRI_IMAGE_FORMAT_XBGR8888:
      return MESA_FORMAT_R8G8B8X8_UNORM;
   case __DRI_IMAGE_FORMAT_R8:
      return MESA_FORMAT_R_UNORM8;
   case __DRI_IMAGE_FORMAT_GR88:
      return MESA_FORMAT_R8G8_UNORM;
   case __DRI_IMAGE_FORMAT_SARGB8:
      return MESA_FORMAT_B8G8R8A8_SRGB;
   case __DRI_IMAGE_FORMAT_NONE:
      return MESA_FORMAT_NONE;
   default:
      return MESA_FORMAT_NONE;
   }
}

/** Image driver interface */
const __DRIimageDriverExtension driImageDriverExtension = {
    .base = { __DRI_IMAGE_DRIVER, 1 },

    .createNewScreen2           = driCreateNewScreen2,
    .createNewDrawable          = driCreateNewDrawable,
    .getAPIMask                 = driGetAPIMask,
    .createContextAttribs       = driCreateContextAttribs,
};

/* swrast copy sub buffer entrypoint. */
static void driCopySubBuffer(__DRIdrawable *pdp, int x, int y,
                             int w, int h)
{
    assert(pdp->driScreenPriv->swrast_loader);

    pdp->driScreenPriv->driver->CopySubBuffer(pdp, x, y, w, h);
}

/* for swrast only */
const __DRIcopySubBufferExtension driCopySubBufferExtension = {
   .base = { __DRI_COPY_SUB_BUFFER, 1 },

   .copySubBuffer               = driCopySubBuffer,
};
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@d55 1
a55 1
const char __dri2ConfigOptions[] =
d379 1
a379 1
    /* The latest version of EGL_KHR_create_context spec says:
d381 3
a383 3
     *     "If the EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR flag bit is set in
     *     EGL_CONTEXT_FLAGS_KHR, then a <debug context> will be created.
     *     [...] This bit is supported for OpenGL and OpenGL ES contexts.
d385 3
a387 1
     * None of the other flags have any meaning in an ES context, so this seems safe.
d391 1
a391 1
        && (flags & ~__DRI_CTX_FLAG_DEBUG)) {
a571 6
    /*
    ** Call driUnbindContext before checking for valid drawables
    ** to handle surfaceless contexts properly.
    */
    pcp->driScreenPriv->driver->UnbindContext(pcp);

d579 2
d680 1
a680 1
dri2ConfigQueryb(__DRIscreen *screen, const char *var, unsigned char *val)
d691 1
a691 1
dri2ConfigQueryi(__DRIscreen *screen, const char *var, int *val)
d703 1
a703 1
dri2ConfigQueryf(__DRIscreen *screen, const char *var, float *val)
d735 1
a735 1
    .base = { __DRI_CORE, 1 },
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d55 1
a55 1
PUBLIC const char __dri2ConfigOptions[] =
d379 1
a379 1
    /* The EGL_KHR_create_context spec says:
d381 3
a383 3
     *     "Flags are only defined for OpenGL context creation, and specifying
     *     a flags value other than zero for other types of contexts,
     *     including OpenGL ES contexts, will generate an error."
d385 1
a385 3
     * The GLX_EXT_create_context_es2_profile specification doesn't say
     * anything specific about this case.  However, none of the known flags
     * have any meaning in an ES context, so this seems safe.
d389 1
a389 1
        && flags != 0) {
d570 6
a582 2
    pcp->driScreenPriv->driver->UnbindContext(pcp);

d682 1
a682 1
dri2ConfigQueryb(__DRIscreen *screen, const char *var, GLboolean *val)
d693 1
a693 1
dri2ConfigQueryi(__DRIscreen *screen, const char *var, GLint *val)
d705 1
a705 1
dri2ConfigQueryf(__DRIscreen *screen, const char *var, GLfloat *val)
d737 1
a737 1
    .base = { __DRI_CORE, __DRI_CORE_VERSION },
@


