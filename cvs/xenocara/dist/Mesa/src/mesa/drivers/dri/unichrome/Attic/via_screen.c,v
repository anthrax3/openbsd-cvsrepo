head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.09.05.14.05.54;	author jsg;	state dead;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.18;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.54.11;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.54.11;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.39;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.30.03;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.43;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@/*
 * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
 * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sub license,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <stdio.h>

#include "dri_util.h"
#include "utils.h"
#include "main/glheader.h"
#include "main/context.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
#include "main/simple_list.h"
#include "vblank.h"

#include "via_state.h"
#include "via_tex.h"
#include "via_span.h"
#include "via_screen.h"
#include "via_dri.h"

#include "GL/internal/dri_interface.h"
#include "drirenderbuffer.h"

#include "xmlpool.h"

PUBLIC const char __driConfigOptions[] =
DRI_CONF_BEGIN
    DRI_CONF_SECTION_PERFORMANCE
        DRI_CONF_VBLANK_MODE(DRI_CONF_VBLANK_DEF_INTERVAL_0)
    DRI_CONF_SECTION_END
    DRI_CONF_SECTION_QUALITY
        DRI_CONF_EXCESS_MIPMAP(false)
    DRI_CONF_SECTION_END
    DRI_CONF_SECTION_DEBUG
        DRI_CONF_NO_RAST(false)
    DRI_CONF_SECTION_END
DRI_CONF_END;
static const GLuint __driNConfigOptions = 3;

static drmBufMapPtr via_create_empty_buffers(void)
{
    drmBufMapPtr retval;

    retval = (drmBufMapPtr)MALLOC(sizeof(drmBufMap));
    if (retval == NULL) return NULL;
    memset(retval, 0, sizeof(drmBufMap));

    retval->list = (drmBufPtr)MALLOC(sizeof(drmBuf) * VIA_DMA_BUF_NR);
    if (retval->list == NULL) {
       FREE(retval);
       return NULL;
    }
    memset(retval->list, 0, sizeof(drmBuf) * VIA_DMA_BUF_NR);
    return retval;
}

static void via_free_empty_buffers( drmBufMapPtr bufs )
{
   if (bufs && bufs->list)
      FREE(bufs->list);

   if (bufs)
      FREE(bufs);
}


static GLboolean
viaInitDriver(__DRIscreen *sPriv)
{
    viaScreenPrivate *viaScreen;
    VIADRIPtr gDRIPriv = (VIADRIPtr)sPriv->pDevPriv;
    int i;

    if (sPriv->devPrivSize != sizeof(VIADRIRec)) {
      fprintf(stderr,"\nERROR!  sizeof(VIADRIRec) does not match passed size from device driver\n");
      return GL_FALSE;
    }

    /* Allocate the private area */
    viaScreen = (viaScreenPrivate *) CALLOC(sizeof(viaScreenPrivate));
    if (!viaScreen) {
        __driUtilMessage("viaInitDriver: alloc viaScreenPrivate struct failed");
        return GL_FALSE;
    }

    /* parse information in __driConfigOptions */
    driParseOptionInfo (&viaScreen->optionCache,
			__driConfigOptions, __driNConfigOptions);


    viaScreen->driScrnPriv = sPriv;
    sPriv->private = (void *)viaScreen;

    viaScreen->deviceID = gDRIPriv->deviceID;
    viaScreen->width = gDRIPriv->width;
    viaScreen->height = gDRIPriv->height;
    viaScreen->mem = gDRIPriv->mem;
    viaScreen->bitsPerPixel = gDRIPriv->bytesPerPixel * 8;
    viaScreen->bytesPerPixel = gDRIPriv->bytesPerPixel;
    viaScreen->fbOffset = 0;
    viaScreen->fbSize = gDRIPriv->fbSize;
    viaScreen->irqEnabled = gDRIPriv->irqEnabled;

    if (VIA_DEBUG & DEBUG_DRI) {
	fprintf(stderr, "deviceID = %08x\n", viaScreen->deviceID);
	fprintf(stderr, "width = %08x\n", viaScreen->width);	
	fprintf(stderr, "height = %08x\n", viaScreen->height);	
	fprintf(stderr, "cpp = %08x\n", viaScreen->cpp);	
	fprintf(stderr, "fbOffset = %08x\n", viaScreen->fbOffset);	
    }

    viaScreen->bufs = via_create_empty_buffers();
    if (viaScreen->bufs == NULL) {
        __driUtilMessage("viaInitDriver: via_create_empty_buffers() failed");
        FREE(viaScreen);
        return GL_FALSE;
    }

    if (drmMap(sPriv->fd,
               gDRIPriv->regs.handle,
               gDRIPriv->regs.size,
               &viaScreen->reg) != 0) {
        FREE(viaScreen);
        sPriv->private = NULL;
        __driUtilMessage("viaInitDriver: drmMap regs failed");
        return GL_FALSE;
    }

    if (gDRIPriv->agp.size) {
        if (drmMap(sPriv->fd,
                   gDRIPriv->agp.handle,
                   gDRIPriv->agp.size,
	           (drmAddress *)&viaScreen->agpLinearStart) != 0) {
	    drmUnmap(viaScreen->reg, gDRIPriv->regs.size);
	    FREE(viaScreen);
	    sPriv->private = NULL;
	    __driUtilMessage("viaInitDriver: drmMap agp failed");
	    return GL_FALSE;
	}

	viaScreen->agpBase = drmAgpBase(sPriv->fd);
    } else
	viaScreen->agpLinearStart = 0;

    viaScreen->sareaPrivOffset = gDRIPriv->sarea_priv_offset;

    i = 0;
    viaScreen->extensions[i++] = &driReadDrawableExtension;
    if ( viaScreen->irqEnabled ) {
	viaScreen->extensions[i++] = &driSwapControlExtension.base;
	viaScreen->extensions[i++] = &driMediaStreamCounterExtension.base;
    }

    viaScreen->extensions[i++] = NULL;
    sPriv->extensions = viaScreen->extensions;

    return GL_TRUE;
}

static void
viaDestroyScreen(__DRIscreen *sPriv)
{
    viaScreenPrivate *viaScreen = (viaScreenPrivate *)sPriv->private;
    VIADRIPtr gDRIPriv = (VIADRIPtr)sPriv->pDevPriv;

    drmUnmap(viaScreen->reg, gDRIPriv->regs.size);
    if (gDRIPriv->agp.size)
        drmUnmap(viaScreen->agpLinearStart, gDRIPriv->agp.size);

    via_free_empty_buffers(viaScreen->bufs);

    driDestroyOptionInfo(&viaScreen->optionCache);

    FREE(viaScreen);
    sPriv->private = NULL;
}


static GLboolean
viaCreateBuffer(__DRIscreen *driScrnPriv,
                __DRIdrawable *driDrawPriv,
                const struct gl_config *mesaVis,
                GLboolean isPixmap)
{
#if 0
    viaScreenPrivate *screen = (viaScreenPrivate *) driScrnPriv->private;
#endif

    GLboolean swStencil = (mesaVis->stencilBits > 0 && 
			   mesaVis->depthBits != 24);
    GLboolean swAccum = mesaVis->accumRedBits > 0;

    if (isPixmap) {
       /* KW: This needs work, disabled for now:
	*/
#if 0
	driDrawPriv->driverPrivate = (void *)
            _mesa_create_framebuffer(mesaVis,
                                     GL_FALSE,	/* software depth buffer? */
                                     swStencil,
                                     mesaVis->accumRedBits > 0,
                                     GL_FALSE 	/* s/w alpha planes */);

        return (driDrawPriv->driverPrivate != NULL);
#endif
	return GL_FALSE;
    }
    else {
      struct gl_framebuffer *fb = _mesa_create_framebuffer(mesaVis);

      /* The front color, back color and depth renderbuffers are
       * set up later in calculate_buffer_parameters().
       * Only create/connect software-based buffers here.
       */

#if 000
      /* This code _should_ be put to use.  We have to move the
       * viaRenderbuffer members out of the via_context structure.
       * Those members should just be the renderbuffers hanging off the
       * gl_framebuffer object.
       */
      /* XXX check/fix the offset/pitch parameters! */
      {
         driRenderbuffer *frontRb
            = driNewRenderbuffer(MESA_FORMAT_ARGB8888, NULL,
                                 screen->bytesPerPixel,
                                 0, screen->width, driDrawPriv);
         viaSetSpanFunctions(frontRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_FRONT_LEFT, &frontRb->Base);
      }

      if (mesaVis->doubleBufferMode) {
         driRenderbuffer *backRb
            = driNewRenderbuffer(MESA_FORMAT_ARGB8888, NULL,
                                 screen->bytesPerPixel,
                                 0, screen->width, driDrawPriv);
         viaSetSpanFunctions(backRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_BACK_LEFT, &backRb->Base);
      }

      if (mesaVis->depthBits == 16) {
         driRenderbuffer *depthRb
            = driNewRenderbuffer(MESA_FORMAT_Z16, NULL,
                                 screen->bytesPerPixel,
                                 0, screen->width, driDrawPriv);
         viaSetSpanFunctions(depthRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthRb->Base);
      }
      else if (mesaVis->depthBits == 24) {
         driRenderbuffer *depthRb
            = driNewRenderbuffer(MESA_FORMAT_Z24_S8, NULL,
                                 screen->bytesPerPixel,
                                 0, screen->width, driDrawPriv);
         viaSetSpanFunctions(depthRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthRb->Base);
      }
      else if (mesaVis->depthBits == 32) {
         driRenderbuffer *depthRb
            = driNewRenderbuffer(MESA_FORMAT_Z32, NULL,
                                 screen->bytesPerPixel,
                                 0, screen->width, driDrawPriv);
         viaSetSpanFunctions(depthRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthRb->Base);
      }

      if (mesaVis->stencilBits > 0 && !swStencil) {
         driRenderbuffer *stencilRb
            = driNewRenderbuffer(MESA_FORMAT_S8, NULL,
                                 screen->bytesPerPixel,
                                 0, screen->width, driDrawPriv);
         viaSetSpanFunctions(stencilRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_STENCIL, &stencilRb->Base);
      }
#endif

      _mesa_add_soft_renderbuffers(fb,
                                   GL_FALSE, /* color */
                                   GL_FALSE, /* depth */
                                   swStencil,
                                   swAccum,
                                   GL_FALSE, /* alpha */
                                   GL_FALSE /* aux */);
      driDrawPriv->driverPrivate = (void *) fb;

      return (driDrawPriv->driverPrivate != NULL);
   }
}


static void
viaDestroyBuffer(__DRIdrawable *driDrawPriv)
{
   _mesa_reference_framebuffer((struct gl_framebuffer **)(&(driDrawPriv->driverPrivate)), NULL);
}

static const __DRIconfig **
viaFillInModes( __DRIscreen *psp,
		unsigned pixel_bits, GLboolean have_back_buffer )
{
    __DRIconfig **configs;
    const unsigned back_buffer_factor = (have_back_buffer) ? 2 : 1;
    GLenum fb_format;
    GLenum fb_type;

    /* Right now GLX_SWAP_COPY_OML isn't supported, but it would be easy
     * enough to add support.  Basically, if a context is created with an
     * fbconfig where the swap method is GLX_SWAP_COPY_OML, pageflipping
     * will never be used.
     */
    static const GLenum back_buffer_modes[] = {
	GLX_NONE, GLX_SWAP_UNDEFINED_OML /*, GLX_SWAP_COPY_OML */
    };

    /* The 32-bit depth-buffer mode isn't supported yet, so don't actually
     * enable it.
     */
    static const uint8_t depth_bits_array[4]   = { 0, 16, 24, 32 };
    static const uint8_t stencil_bits_array[4] = { 0,  0,  8,  0 };
    uint8_t msaa_samples_array[1] = { 0 };
    const unsigned depth_buffer_factor = 3;

    if ( pixel_bits == 16 ) {
        fb_format = GL_RGB;
        fb_type = GL_UNSIGNED_SHORT_5_6_5;
    }
    else {
        fb_format = GL_BGRA;
        fb_type = GL_UNSIGNED_INT_8_8_8_8_REV;
    }

    configs = driCreateConfigs(fb_format, fb_type,
			       depth_bits_array, stencil_bits_array,
			       depth_buffer_factor, back_buffer_modes,
			       back_buffer_factor,
                               msaa_samples_array, 1, GL_TRUE);
    if (configs == NULL) {
	fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
		__LINE__);
	return NULL;
    }

    return (const __DRIconfig **) configs;
}


/**
 * This is the driver specific part of the createNewScreen entry point.
 * 
 * \todo maybe fold this into intelInitDriver
 *
 * \return the struct gl_config supported by this driver
 */
static const __DRIconfig **
viaInitScreen(__DRIscreen *psp)
{
   static const __DRIversion ddx_expected = { VIA_DRIDDX_VERSION_MAJOR,
                                              VIA_DRIDDX_VERSION_MINOR,
                                              VIA_DRIDDX_VERSION_PATCH };
   static const __DRIversion dri_expected = { 4, 0, 0 };
   static const __DRIversion drm_expected = { 2, 3, 0 };
   static const char *driver_name = "Unichrome";
   VIADRIPtr dri_priv = (VIADRIPtr) psp->pDevPriv;

   if ( ! driCheckDriDdxDrmVersions2( driver_name,
				      &psp->dri_version, & dri_expected,
				      &psp->ddx_version, & ddx_expected,
				      &psp->drm_version, & drm_expected) )
      return NULL;

   if (!viaInitDriver(psp))
       return NULL;

   return viaFillInModes( psp, dri_priv->bytesPerPixel * 8, GL_TRUE );

}


/**
 * Get information about previous buffer swaps.
 */
static int
getSwapInfo( __DRIdrawable *dPriv, __DRIswapInfo * sInfo )
{
   struct via_context *vmesa;

   if ( (dPriv == NULL) || (dPriv->driContextPriv == NULL)
	|| (dPriv->driContextPriv->driverPrivate == NULL)
	|| (sInfo == NULL) ) {
      return -1;
   }

   vmesa = (struct via_context *) dPriv->driContextPriv->driverPrivate;
   sInfo->swap_count = vmesa->swap_count;
   sInfo->swap_ust = vmesa->swap_ust;
   sInfo->swap_missed_count = vmesa->swap_missed_count;

   sInfo->swap_missed_usage = (sInfo->swap_missed_count != 0)
       ? driCalculateSwapUsage( dPriv, 0, vmesa->swap_missed_ust )
       : 0.0;

   return 0;
}

const struct __DriverAPIRec driDriverAPI = {
   .InitScreen      = viaInitScreen,
   .DestroyScreen   = viaDestroyScreen,
   .CreateContext   = viaCreateContext,
   .DestroyContext  = viaDestroyContext,
   .CreateBuffer    = viaCreateBuffer,
   .DestroyBuffer   = viaDestroyBuffer,
   .SwapBuffers     = viaSwapBuffers,
   .MakeCurrent     = viaMakeCurrent,
   .UnbindContext   = viaUnbindContext,
   .GetSwapInfo     = getSwapInfo,
   .GetDrawableMSC  = driDrawableGetMSC32,
   .WaitForMSC      = driWaitForMSC32,
   .WaitForSBC      = NULL,
   .SwapBuffersMSC  = NULL
};

/* This is the table of extensions that the loader will dlsym() for. */
PUBLIC const __DRIextension *__driDriverExtensions[] = {
    &driCoreExtension.base,
    &driLegacyExtension.base,
    NULL
};
@


1.5
log
@Merge Mesa 7.10.3
@
text
@@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a168 1
    viaScreen->extensions[i++] = &driFrameTrackingExtension.base;
d203 1
a203 1
                const __GLcontextModes *mesaVis,
d314 1
a314 1
   _mesa_reference_framebuffer((GLframebuffer **)(&(driDrawPriv->driverPrivate)), NULL);
d372 1
a372 1
 * \return the __GLcontextModes supported by this driver
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a32 1
#include "main/matrix.h"
a38 2
#include "via_tris.h"
#include "via_ioctl.h"
a39 1
#include "via_fb.h"
a60 2
extern const struct dri_extension card_extensions[];

d89 1
a89 1
viaInitDriver(__DRIscreenPrivate *sPriv)
d183 1
a183 1
viaDestroyScreen(__DRIscreenPrivate *sPriv)
d202 2
a203 2
viaCreateBuffer(__DRIscreenPrivate *driScrnPriv,
                __DRIdrawablePrivate *driDrawPriv,
d207 1
d209 1
d247 1
a247 1
            = driNewRenderbuffer(GL_RGBA, NULL,
d256 1
a256 1
            = driNewRenderbuffer(GL_RGBA, NULL,
d265 1
a265 1
            = driNewRenderbuffer(GL_DEPTH_COMPONENT16, NULL,
d273 1
a273 1
            = driNewRenderbuffer(GL_DEPTH_COMPONENT24, NULL,
d281 1
a281 1
            = driNewRenderbuffer(GL_DEPTH_COMPONENT32, NULL,
d290 1
a290 1
            = driNewRenderbuffer(GL_STENCIL_INDEX8_EXT, NULL,
d313 1
a313 1
viaDestroyBuffer(__DRIdrawablePrivate *driDrawPriv)
d315 1
a315 1
   _mesa_unreference_framebuffer((GLframebuffer **)(&(driDrawPriv->driverPrivate)));
d319 1
a319 1
viaFillInModes( __DRIscreenPrivate *psp,
d341 1
d356 2
a357 1
			       back_buffer_factor);
d376 1
a376 1
viaInitScreen(__DRIscreenPrivate *psp)
a391 12
   /* Calling driInitExtensions here, with a NULL context pointer,
    * does not actually enable the extensions.  It just makes sure
    * that all the dispatch offsets for all the extensions that
    * *might* be enables are known.  This is needed because the
    * dispatch offsets need to be known when _mesa_context_create is
    * called, but we can't enable the extensions until we have a
    * context pointer.
    *
    * Hello chicken.  Hello egg.  How are you two today?
    */
   driInitExtensions( NULL, card_extensions, GL_FALSE );

d404 1
a404 1
getSwapInfo( __DRIdrawablePrivate *dPriv, __DRIswapInfo * sInfo )
d441 7
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d29 6
a34 6
#include "glheader.h"
#include "context.h"
#include "framebuffer.h"
#include "renderbuffer.h"
#include "matrix.h"
#include "simple_list.h"
d343 2
a344 2
    static const u_int8_t depth_bits_array[4]   = { 0, 16, 24, 32 };
    static const u_int8_t stencil_bits_array[4] = { 0,  0,  8,  0 };
@


1.1
log
@Initial revision
@
text
@d27 1
a28 1
#include "dri_util.h"
a48 2
/* Radeon configuration
 */
d51 1
a51 1
const char __driConfigOptions[] =
a53 1
        DRI_CONF_FTHROTTLE_MODE(DRI_CONF_FTHROTTLE_IRQS)
d56 3
a66 2
static int getSwapInfo( __DRIdrawablePrivate *dPriv, __DRIswapInfo * sInfo );

d99 1
a99 3
    PFNGLXSCRENABLEEXTENSIONPROC glx_enable_extension =
      (PFNGLXSCRENABLEEXTENSIONPROC) (*dri_interface->getProcAddress("glxEnableExtension"));
    void * const psc = sPriv->psc->screenConfigs;
a129 1
    viaScreen->irqEnabled = 1;
d174 7
a180 6
    if ( glx_enable_extension != NULL ) {
       if ( viaScreen->irqEnabled ) {
	  (*glx_enable_extension)( psc, "GLX_SGI_swap_control" );
	  (*glx_enable_extension)( psc, "GLX_SGI_video_sync" );
	  (*glx_enable_extension)( psc, "GLX_MESA_swap_control" );
       }
d182 2
a183 2
       (*glx_enable_extension)( psc, "GLX_MESA_swap_frame_usage" );
    }
d200 2
d319 1
a319 1
    _mesa_destroy_framebuffer((GLframebuffer *)(driDrawPriv->driverPrivate));
d322 3
a324 22


static struct __DriverAPIRec viaAPI = {
   .InitDriver      = viaInitDriver,
   .DestroyScreen   = viaDestroyScreen,
   .CreateContext   = viaCreateContext,
   .DestroyContext  = viaDestroyContext,
   .CreateBuffer    = viaCreateBuffer,
   .DestroyBuffer   = viaDestroyBuffer,
   .SwapBuffers     = viaSwapBuffers,
   .MakeCurrent     = viaMakeCurrent,
   .UnbindContext   = viaUnbindContext,
   .GetSwapInfo     = getSwapInfo,
   .GetMSC          = driGetMSC32,
   .WaitForMSC      = driWaitForMSC32,
   .WaitForSBC      = NULL,
   .SwapBuffersMSC  = NULL
};


static __GLcontextModes *
viaFillInModes( unsigned pixel_bits, GLboolean have_back_buffer )
d326 1
a326 3
    __GLcontextModes * modes;
    __GLcontextModes * m;
    unsigned num_modes;
a346 3

    num_modes = depth_buffer_factor * back_buffer_factor * 4;

d356 7
a362 19
    modes = (*dri_interface->createContextModes)( num_modes, sizeof( __GLcontextModes ) );
    m = modes;
    if ( ! driFillInModes( & m, fb_format, fb_type,
			   depth_bits_array, stencil_bits_array, 
			   depth_buffer_factor,
			   back_buffer_modes, back_buffer_factor,
			   GLX_TRUE_COLOR ) ) {
	fprintf( stderr, "[%s:%u] Error creating FBConfig!\n",
		 __func__, __LINE__ );
	return NULL;
    }

    if ( ! driFillInModes( & m, fb_format, fb_type,
			   depth_bits_array, stencil_bits_array, 
			   depth_buffer_factor,
			   back_buffer_modes, back_buffer_factor,
			   GLX_DIRECT_COLOR ) ) {
	fprintf( stderr, "[%s:%u] Error creating FBConfig!\n",
		 __func__, __LINE__ );
d366 1
a366 1
    return modes;
d371 1
a371 5
 * This is the bootstrap function for the driver.  libGL supplies all of the
 * requisite information about the system, and the driver initializes itself.
 * This routine also fills in the linked list pointed to by \c driver_modes
 * with the \c __GLcontextModes that the driver can support for windows or
 * pbuffers.
d373 3
a375 2
 * \return A pointer to a \c __DRIscreenPrivate on success, or \c NULL on 
 *         failure.
d377 2
a378 13
PUBLIC
void * __driCreateNewScreen_20050727( __DRInativeDisplay *dpy, int scrn,
			     __DRIscreen *psc,
			     const __GLcontextModes * modes,
			     const __DRIversion * ddx_version,
			     const __DRIversion * dri_version,
			     const __DRIversion * drm_version,
			     const __DRIframebuffer * frame_buffer,
			     drmAddress pSAREA, int fd, 
			     int internal_api_version,
			     const __DRIinterfaceMethods * interface,
			     __GLcontextModes ** driver_modes )
			     
a379 1
   __DRIscreenPrivate *psp;
d386 1
a386 2

   dri_interface = interface;
d389 3
a391 3
				      dri_version, & dri_expected,
				      ddx_version, & ddx_expected,
				      drm_version, & drm_expected) ) {
a392 21
   }
      
   psp = __driUtilCreateNewScreen(dpy, scrn, psc, NULL,
				  ddx_version, dri_version, drm_version,
				  frame_buffer, pSAREA, fd,
				  internal_api_version, &viaAPI);
   if ( psp != NULL ) {
      VIADRIPtr dri_priv = (VIADRIPtr) psp->pDevPriv;
      *driver_modes = viaFillInModes( dri_priv->bytesPerPixel * 8,
				      GL_TRUE );

      /* Calling driInitExtensions here, with a NULL context pointer, does not actually
       * enable the extensions.  It just makes sure that all the dispatch offsets for all
       * the extensions that *might* be enables are known.  This is needed because the
       * dispatch offsets need to be known when _mesa_context_create is called, but we can't
       * enable the extensions until we have a context pointer.
       *
       * Hello chicken.  Hello egg.  How are you two today?
       */
      driInitExtensions( NULL, card_extensions, GL_FALSE );
   }
d394 17
a410 1
   return (void *) psp;
d439 17
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d49 2
d56 1
a58 3
    DRI_CONF_SECTION_QUALITY
        DRI_CONF_EXCESS_MIPMAP(false)
    DRI_CONF_SECTION_END
d134 1
a185 1
       (*glx_enable_extension)( psc, "GLX_SGI_make_current_read" );
a202 2

    driDestroyOptionInfo(&viaScreen->optionCache);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d323 1
a323 1
   _mesa_unreference_framebuffer((GLframebuffer **)(&(driDrawPriv->driverPrivate)));
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d27 1
d29 6
a34 6
#include "utils.h"
#include "main/glheader.h"
#include "main/context.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
#include "main/simple_list.h"
d40 2
d43 1
d51 1
a51 1
PUBLIC const char __driConfigOptions[] =
d65 4
d97 1
a97 1
viaInitDriver(__DRIscreen *sPriv)
d101 3
a103 1
    int i;
d178 9
a186 5
    i = 0;
    viaScreen->extensions[i++] = &driReadDrawableExtension;
    if ( viaScreen->irqEnabled ) {
	viaScreen->extensions[i++] = &driSwapControlExtension.base;
	viaScreen->extensions[i++] = &driMediaStreamCounterExtension.base;
a188 3
    viaScreen->extensions[i++] = NULL;
    sPriv->extensions = viaScreen->extensions;

d193 1
a193 1
viaDestroyScreen(__DRIscreen *sPriv)
d212 3
a214 3
viaCreateBuffer(__DRIscreen *driScrnPriv,
                __DRIdrawable *driDrawPriv,
                const struct gl_config *mesaVis,
a216 1
#if 0
a217 1
#endif
d255 1
a255 1
            = driNewRenderbuffer(MESA_FORMAT_ARGB8888, NULL,
d264 1
a264 1
            = driNewRenderbuffer(MESA_FORMAT_ARGB8888, NULL,
d273 1
a273 1
            = driNewRenderbuffer(MESA_FORMAT_Z16, NULL,
d281 1
a281 1
            = driNewRenderbuffer(MESA_FORMAT_Z24_S8, NULL,
d289 1
a289 1
            = driNewRenderbuffer(MESA_FORMAT_Z32, NULL,
d298 1
a298 1
            = driNewRenderbuffer(MESA_FORMAT_S8, NULL,
d321 1
a321 1
viaDestroyBuffer(__DRIdrawable *driDrawPriv)
d323 1
a323 1
   _mesa_reference_framebuffer((struct gl_framebuffer **)(&(driDrawPriv->driverPrivate)), NULL);
d326 22
a347 3
static const __DRIconfig **
viaFillInModes( __DRIscreen *psp,
		unsigned pixel_bits, GLboolean have_back_buffer )
d349 3
a351 1
    __DRIconfig **configs;
d368 2
a369 3
    static const uint8_t depth_bits_array[4]   = { 0, 16, 24, 32 };
    static const uint8_t stencil_bits_array[4] = { 0,  0,  8,  0 };
    uint8_t msaa_samples_array[1] = { 0 };
d372 3
d384 9
a392 8
    configs = driCreateConfigs(fb_format, fb_type,
			       depth_bits_array, stencil_bits_array,
			       depth_buffer_factor, back_buffer_modes,
			       back_buffer_factor,
                               msaa_samples_array, 1, GL_TRUE);
    if (configs == NULL) {
	fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
		__LINE__);
d396 11
a406 1
    return (const __DRIconfig **) configs;
d411 5
a415 1
 * This is the driver specific part of the createNewScreen entry point.
d417 2
a418 3
 * \todo maybe fold this into intelInitDriver
 *
 * \return the struct gl_config supported by this driver
d420 13
a432 2
static const __DRIconfig **
viaInitScreen(__DRIscreen *psp)
d434 1
d441 2
a442 1
   VIADRIPtr dri_priv = (VIADRIPtr) psp->pDevPriv;
d445 3
a447 3
				      &psp->dri_version, & dri_expected,
				      &psp->ddx_version, & ddx_expected,
				      &psp->drm_version, & drm_expected) )
d449 21
d471 1
a471 5
   if (!viaInitDriver(psp))
       return NULL;

   return viaFillInModes( psp, dri_priv->bytesPerPixel * 8, GL_TRUE );

d479 1
a479 1
getSwapInfo( __DRIdrawable *dPriv, __DRIswapInfo * sInfo )
a499 24

const struct __DriverAPIRec driDriverAPI = {
   .InitScreen      = viaInitScreen,
   .DestroyScreen   = viaDestroyScreen,
   .CreateContext   = viaCreateContext,
   .DestroyContext  = viaDestroyContext,
   .CreateBuffer    = viaCreateBuffer,
   .DestroyBuffer   = viaDestroyBuffer,
   .SwapBuffers     = viaSwapBuffers,
   .MakeCurrent     = viaMakeCurrent,
   .UnbindContext   = viaUnbindContext,
   .GetSwapInfo     = getSwapInfo,
   .GetDrawableMSC  = driDrawableGetMSC32,
   .WaitForMSC      = driWaitForMSC32,
   .WaitForSBC      = NULL,
   .SwapBuffersMSC  = NULL
};

/* This is the table of extensions that the loader will dlsym() for. */
PUBLIC const __DRIextension *__driDriverExtensions[] = {
    &driCoreExtension.base,
    &driLegacyExtension.base,
    NULL
};
@


