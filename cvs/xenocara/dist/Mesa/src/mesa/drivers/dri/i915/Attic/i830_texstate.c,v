head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.04.12;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.32;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.32;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.15.19;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.46;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.11.21;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.48.28;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "main/mtypes.h"
#include "main/enums.h"
#include "main/colormac.h"
#include "main/macros.h"
#include "main/samplerobj.h"

#include "intel_mipmap_tree.h"
#include "intel_tex.h"

#include "i830_context.h"
#include "i830_reg.h"
#include "intel_chipset.h"


static GLuint
translate_texture_format(GLuint mesa_format)
{
   switch (mesa_format) {
   case MESA_FORMAT_L_UNORM8:
      return MAPSURF_8BIT | MT_8BIT_L8;
   case MESA_FORMAT_I_UNORM8:
      return MAPSURF_8BIT | MT_8BIT_I8;
   case MESA_FORMAT_A_UNORM8:
      return MAPSURF_8BIT | MT_8BIT_I8; /* Kludge! */
   case MESA_FORMAT_L8A8_UNORM:
      return MAPSURF_16BIT | MT_16BIT_AY88;
   case MESA_FORMAT_B5G6R5_UNORM:
      return MAPSURF_16BIT | MT_16BIT_RGB565;
   case MESA_FORMAT_B5G5R5A1_UNORM:
      return MAPSURF_16BIT | MT_16BIT_ARGB1555;
   case MESA_FORMAT_B4G4R4A4_UNORM:
      return MAPSURF_16BIT | MT_16BIT_ARGB4444;
   case MESA_FORMAT_B8G8R8A8_UNORM:
      return MAPSURF_32BIT | MT_32BIT_ARGB8888;
   case MESA_FORMAT_B8G8R8X8_UNORM:
      return MAPSURF_32BIT | MT_32BIT_XRGB8888;
   case MESA_FORMAT_YCBCR_REV:
      return (MAPSURF_422 | MT_422_YCRCB_NORMAL);
   case MESA_FORMAT_YCBCR:
      return (MAPSURF_422 | MT_422_YCRCB_SWAPY);
   case MESA_FORMAT_RGB_FXT1:
   case MESA_FORMAT_RGBA_FXT1:
      return (MAPSURF_COMPRESSED | MT_COMPRESS_FXT1);
   case MESA_FORMAT_RGBA_DXT1:
   case MESA_FORMAT_RGB_DXT1:
      return (MAPSURF_COMPRESSED | MT_COMPRESS_DXT1);
   case MESA_FORMAT_RGBA_DXT3:
      return (MAPSURF_COMPRESSED | MT_COMPRESS_DXT2_3);
   case MESA_FORMAT_RGBA_DXT5:
      return (MAPSURF_COMPRESSED | MT_COMPRESS_DXT4_5);
   default:
      fprintf(stderr, "%s: bad image format %s\n", __FUNCTION__,
	      _mesa_get_format_name(mesa_format));
      abort();
      return 0;
   }
}




/* The i915 (and related graphics cores) do not support GL_CLAMP.  The
 * Intel drivers for "other operating systems" implement GL_CLAMP as
 * GL_CLAMP_TO_EDGE, so the same is done here.
 */
static GLuint
translate_wrap_mode(GLenum wrap)
{
   switch (wrap) {
   case GL_REPEAT:
      return TEXCOORDMODE_WRAP;
   case GL_CLAMP:
   case GL_CLAMP_TO_EDGE:
      return TEXCOORDMODE_CLAMP;        /* not really correct */
   case GL_CLAMP_TO_BORDER:
      return TEXCOORDMODE_CLAMP_BORDER;
   case GL_MIRRORED_REPEAT:
      return TEXCOORDMODE_MIRROR;
   default:
      return TEXCOORDMODE_WRAP;
   }
}


/* Recalculate all state from scratch.  Perhaps not the most
 * efficient, but this has gotten complex enough that we need
 * something which is understandable and reliable.
 */
static bool
i830_update_tex_unit(struct intel_context *intel, GLuint unit, GLuint ss3)
{
   struct gl_context *ctx = &intel->ctx;
   struct i830_context *i830 = i830_context(ctx);
   struct gl_texture_unit *tUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *tObj = tUnit->_Current;
   struct intel_texture_object *intelObj = intel_texture_object(tObj);
   struct gl_texture_image *firstImage;
   struct gl_sampler_object *sampler = _mesa_get_samplerobj(ctx, unit);
   GLuint *state = i830->state.Tex[unit], format, pitch;
   GLint lodbias;
   GLubyte border[4];
   GLuint dst_x, dst_y;

   memset(state, 0, sizeof(*state));

   /*We need to refcount these. */

   if (i830->state.tex_buffer[unit] != NULL) {
       drm_intel_bo_unreference(i830->state.tex_buffer[unit]);
       i830->state.tex_buffer[unit] = NULL;
   }

   if (!intel_finalize_mipmap_tree(intel, unit))
      return false;

   /* Get first image here, since intelObj->firstLevel will get set in
    * the intel_finalize_mipmap_tree() call above.
    */
   firstImage = tObj->Image[0][tObj->BaseLevel];

   intel_miptree_get_image_offset(intelObj->mt, tObj->BaseLevel, 0,
				  &dst_x, &dst_y);

   drm_intel_bo_reference(intelObj->mt->region->bo);
   i830->state.tex_buffer[unit] = intelObj->mt->region->bo;
   pitch = intelObj->mt->region->pitch;

   /* XXX: This calculation is probably broken for tiled images with
    * a non-page-aligned offset.
    */
   i830->state.tex_offset[unit] = dst_x * intelObj->mt->cpp + dst_y * pitch;

   format = translate_texture_format(firstImage->TexFormat);

   state[I830_TEXREG_TM0LI] = (_3DSTATE_LOAD_STATE_IMMEDIATE_2 |
                               (LOAD_TEXTURE_MAP0 << unit) | 4);

   state[I830_TEXREG_TM0S1] =
      (((firstImage->Height - 1) << TM0S1_HEIGHT_SHIFT) |
       ((firstImage->Width - 1) << TM0S1_WIDTH_SHIFT) | format);

   if (intelObj->mt->region->tiling != I915_TILING_NONE) {
      state[I830_TEXREG_TM0S1] |= TM0S1_TILED_SURFACE;
      if (intelObj->mt->region->tiling == I915_TILING_Y)
	 state[I830_TEXREG_TM0S1] |= TM0S1_TILE_WALK;
   }

   state[I830_TEXREG_TM0S2] =
      ((((pitch / 4) - 1) << TM0S2_PITCH_SHIFT) | TM0S2_CUBE_FACE_ENA_MASK);

   {
      if (tObj->Target == GL_TEXTURE_CUBE_MAP)
         state[I830_TEXREG_CUBE] = (_3DSTATE_MAP_CUBE | MAP_UNIT(unit) |
                                    CUBE_NEGX_ENABLE |
                                    CUBE_POSX_ENABLE |
                                    CUBE_NEGY_ENABLE |
                                    CUBE_POSY_ENABLE |
                                    CUBE_NEGZ_ENABLE | CUBE_POSZ_ENABLE);
      else
         state[I830_TEXREG_CUBE] = (_3DSTATE_MAP_CUBE | MAP_UNIT(unit));
   }




   {
      GLuint minFilt, mipFilt, magFilt;
      float maxlod;
      uint32_t minlod_fixed, maxlod_fixed;

      switch (sampler->MinFilter) {
      case GL_NEAREST:
         minFilt = FILTER_NEAREST;
         mipFilt = MIPFILTER_NONE;
         break;
      case GL_LINEAR:
         minFilt = FILTER_LINEAR;
         mipFilt = MIPFILTER_NONE;
         break;
      case GL_NEAREST_MIPMAP_NEAREST:
         minFilt = FILTER_NEAREST;
         mipFilt = MIPFILTER_NEAREST;
         break;
      case GL_LINEAR_MIPMAP_NEAREST:
         minFilt = FILTER_LINEAR;
         mipFilt = MIPFILTER_NEAREST;
         break;
      case GL_NEAREST_MIPMAP_LINEAR:
         minFilt = FILTER_NEAREST;
         mipFilt = MIPFILTER_LINEAR;
         break;
      case GL_LINEAR_MIPMAP_LINEAR:
         minFilt = FILTER_LINEAR;
         mipFilt = MIPFILTER_LINEAR;
         break;
      default:
         return false;
      }

      if (sampler->MaxAnisotropy > 1.0) {
         minFilt = FILTER_ANISOTROPIC;
         magFilt = FILTER_ANISOTROPIC;
      }
      else {
         switch (sampler->MagFilter) {
         case GL_NEAREST:
            magFilt = FILTER_NEAREST;
            break;
         case GL_LINEAR:
            magFilt = FILTER_LINEAR;
            break;
         default:
            return false;
         }
      }

      lodbias = (int) ((tUnit->LodBias + sampler->LodBias) * 16.0);
      if (lodbias < -64)
          lodbias = -64;
      if (lodbias > 63)
          lodbias = 63;
      
      state[I830_TEXREG_TM0S3] = ((lodbias << TM0S3_LOD_BIAS_SHIFT) & 
                                  TM0S3_LOD_BIAS_MASK);
#if 0
      /* YUV conversion:
       */
      if (firstImage->TexFormat->MesaFormat == MESA_FORMAT_YCBCR ||
          firstImage->TexFormat->MesaFormat == MESA_FORMAT_YCBCR_REV)
         state[I830_TEXREG_TM0S3] |= SS2_COLORSPACE_CONVERSION;
#endif

      /* We get one field with fraction bits for the maximum
       * addressable (smallest resolution) LOD.  Use it to cover both
       * MAX_LEVEL and MAX_LOD.
       */
      minlod_fixed = U_FIXED(CLAMP(sampler->MinLod, 0.0, 11), 4);
      maxlod = MIN2(sampler->MaxLod, tObj->_MaxLevel - tObj->BaseLevel);
      if (intel->intelScreen->deviceID == PCI_CHIP_I855_GM ||
	  intel->intelScreen->deviceID == PCI_CHIP_I865_G) {
	 maxlod_fixed = U_FIXED(CLAMP(maxlod, 0.0, 11.75), 2);
	 maxlod_fixed = MAX2(maxlod_fixed, (minlod_fixed + 3) >> 2);
	 state[I830_TEXREG_TM0S3] |= maxlod_fixed << TM0S3_MIN_MIP_SHIFT;
	 state[I830_TEXREG_TM0S2] |= TM0S2_LOD_PRECLAMP;
      } else {
	 maxlod_fixed = U_FIXED(CLAMP(maxlod, 0.0, 11), 0);
	 maxlod_fixed = MAX2(maxlod_fixed, (minlod_fixed + 15) >> 4);
	 state[I830_TEXREG_TM0S3] |= maxlod_fixed << TM0S3_MIN_MIP_SHIFT_830;
      }
      state[I830_TEXREG_TM0S3] |= minlod_fixed << TM0S3_MAX_MIP_SHIFT;
      state[I830_TEXREG_TM0S3] |= ((minFilt << TM0S3_MIN_FILTER_SHIFT) |
                                   (mipFilt << TM0S3_MIP_FILTER_SHIFT) |
                                   (magFilt << TM0S3_MAG_FILTER_SHIFT));
   }

   {
      GLenum ws = sampler->WrapS;
      GLenum wt = sampler->WrapT;


      /* 3D textures not available on i830
       */
      if (tObj->Target == GL_TEXTURE_3D)
         return false;

      state[I830_TEXREG_MCS] = (_3DSTATE_MAP_COORD_SET_CMD |
                                MAP_UNIT(unit) |
                                ENABLE_TEXCOORD_PARAMS |
                                ss3 |
                                ENABLE_ADDR_V_CNTL |
                                TEXCOORD_ADDR_V_MODE(translate_wrap_mode(wt))
                                | ENABLE_ADDR_U_CNTL |
                                TEXCOORD_ADDR_U_MODE(translate_wrap_mode
                                                     (ws)));
   }

   /* convert border color from float to ubyte */
   CLAMPED_FLOAT_TO_UBYTE(border[0], sampler->BorderColor.f[0]);
   CLAMPED_FLOAT_TO_UBYTE(border[1], sampler->BorderColor.f[1]);
   CLAMPED_FLOAT_TO_UBYTE(border[2], sampler->BorderColor.f[2]);
   CLAMPED_FLOAT_TO_UBYTE(border[3], sampler->BorderColor.f[3]);

   state[I830_TEXREG_TM0S4] = PACK_COLOR_8888(border[3],
					      border[0],
					      border[1],
					      border[2]);

   I830_ACTIVESTATE(i830, I830_UPLOAD_TEX(unit), true);
   /* memcmp was already disabled, but definitely won't work as the
    * region might now change and that wouldn't be detected:
    */
   I830_STATECHANGE(i830, I830_UPLOAD_TEX(unit));
   return true;
}




void
i830UpdateTextureState(struct intel_context *intel)
{
   struct i830_context *i830 = i830_context(&intel->ctx);
   bool ok = true;
   GLuint i;

   for (i = 0; i < I830_TEX_UNITS && ok; i++) {
      if (intel->ctx.Texture.Unit[i]._Current) {
         switch (intel->ctx.Texture.Unit[i]._Current->Target) {
         case GL_TEXTURE_1D:
         case GL_TEXTURE_2D:
         case GL_TEXTURE_CUBE_MAP:
            ok = i830_update_tex_unit(intel, i, TEXCOORDS_ARE_NORMAL);
            break;
         case GL_TEXTURE_RECTANGLE:
            ok = i830_update_tex_unit(intel, i, TEXCOORDS_ARE_IN_TEXELUNITS);
            break;
         case GL_TEXTURE_3D:
         default:
            ok = false;
            break;
         }
      } else {
         struct i830_context *i830 = i830_context(&intel->ctx);
         if (i830->state.active & I830_UPLOAD_TEX(i))
            I830_ACTIVESTATE(i830, I830_UPLOAD_TEX(i), false);

         if (i830->state.tex_buffer[i] != NULL) {
            drm_intel_bo_unreference(i830->state.tex_buffer[i]);
            i830->state.tex_buffer[i] = NULL;
         }
      }
   }

   FALLBACK(intel, I830_FALLBACK_TEXTURE, !ok);

   if (ok)
      i830EmitTextureBlend(i830);
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d50 2
a229 2
         /* no trilinear + anisotropic */
         mipFilt = MIPFILTER_NEAREST;
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a49 2
   case MESA_FORMAT_A_UNORM8:
      return MAPSURF_8BIT | MT_8BIT_I8; /* Kludge! */
d228 2
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d46 1
a46 1
   case MESA_FORMAT_L8:
d48 1
a48 1
   case MESA_FORMAT_I8:
d50 1
a50 1
   case MESA_FORMAT_A8:
d52 1
a52 1
   case MESA_FORMAT_AL88:
d54 1
a54 1
   case MESA_FORMAT_RGB565:
d56 1
a56 1
   case MESA_FORMAT_ARGB1555:
d58 1
a58 1
   case MESA_FORMAT_ARGB4444:
d60 1
a60 1
   case MESA_FORMAT_ARGB8888:
d62 1
a62 1
   case MESA_FORMAT_XRGB8888:
d334 18
a351 12
      switch (intel->ctx.Texture.Unit[i]._ReallyEnabled) {
      case TEXTURE_1D_BIT:
      case TEXTURE_2D_BIT:
      case TEXTURE_CUBE_BIT:
         ok = i830_update_tex_unit(intel, i, TEXCOORDS_ARE_NORMAL);
         break;
      case TEXTURE_RECT_BIT:
         ok = i830_update_tex_unit(intel, i, TEXCOORDS_ARE_IN_TEXELUNITS);
         break;
      case 0:{
	 struct i830_context *i830 = i830_context(&intel->ctx);
         if (i830->state.active & I830_UPLOAD_TEX(i)) 
d354 4
a357 10
	 if (i830->state.tex_buffer[i] != NULL) {
	    drm_intel_bo_unreference(i830->state.tex_buffer[i]);
	    i830->state.tex_buffer[i] = NULL;
	 }
         break;
      }
      case TEXTURE_3D_BIT:
      default:
         ok = false;
         break;
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d79 2
a80 1
      fprintf(stderr, "%s: bad image format %x\n", __FUNCTION__, mesa_format);
d116 1
a116 1
static GLboolean
d131 1
a131 1
   memset(state, 0, sizeof(state));
d141 1
a141 1
      return GL_FALSE;
d148 1
a148 1
   intel_miptree_get_image_offset(intelObj->mt, tObj->BaseLevel, 0, 0,
d151 3
a153 3
   drm_intel_bo_reference(intelObj->mt->region->buffer);
   i830->state.tex_buffer[unit] = intelObj->mt->region->buffer;
   pitch = intelObj->mt->region->pitch * intelObj->mt->cpp;
d224 1
a224 1
         return GL_FALSE;
d240 1
a240 1
            return GL_FALSE;
d291 1
a291 1
         return GL_FALSE;
d315 1
a315 1
   I830_ACTIVESTATE(i830, I830_UPLOAD_TEX(unit), GL_TRUE);
d320 1
a320 1
   return GL_TRUE;
d330 1
a330 1
   GLboolean ok = GL_TRUE;
d346 1
a346 1
            I830_ACTIVESTATE(i830, I830_UPLOAD_TEX(i), GL_FALSE);
d356 1
a356 1
         ok = GL_FALSE;
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d31 2
d39 1
a39 1

d43 1
a43 1
translate_texture_format(GLuint mesa_format, GLuint internal_format)
d124 1
d145 1
a145 1
   firstImage = tObj->Image[0][intelObj->firstLevel];
d147 1
a147 1
   intel_miptree_get_image_offset(intelObj->mt, intelObj->firstLevel, 0, 0,
d159 1
a159 2
   format = translate_texture_format(firstImage->TexFormat,
				     firstImage->InternalFormat);
d194 2
d197 1
a197 1
      switch (tObj->MinFilter) {
d226 1
a226 1
      if (tObj->MaxAnisotropy > 1.0) {
d231 1
a231 1
         switch (tObj->MagFilter) {
d243 1
a243 1
      lodbias = (int) ((tUnit->LodBias + tObj->LodBias) * 16.0);
d259 18
a276 4
      state[I830_TEXREG_TM0S3] |= ((intelObj->lastLevel -
                                    intelObj->firstLevel) *
                                   4) << TM0S3_MIN_MIP_SHIFT;

d283 2
a284 2
      GLenum ws = tObj->WrapS;
      GLenum wt = tObj->WrapT;
d304 4
a307 4
   CLAMPED_FLOAT_TO_UBYTE(border[0], tObj->BorderColor.f[0]);
   CLAMPED_FLOAT_TO_UBYTE(border[1], tObj->BorderColor.f[1]);
   CLAMPED_FLOAT_TO_UBYTE(border[2], tObj->BorderColor.f[2]);
   CLAMPED_FLOAT_TO_UBYTE(border[3], tObj->BorderColor.f[3]);
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d116 1
a116 1
   GLcontext *ctx = &intel->ctx;
d132 1
a132 1
       dri_bo_unreference(i830->state.tex_buffer[unit]);
d147 1
a147 1
   dri_bo_reference(intelObj->mt->region->buffer);
d149 2
d154 1
a154 2
   i830->state.tex_offset[unit] = (dst_x + dst_y * intelObj->mt->pitch) *
      intelObj->mt->cpp;
a157 1
   pitch = intelObj->mt->pitch * intelObj->mt->cpp;
d330 1
a330 1
	    dri_bo_unreference(i830->state.tex_buffer[i]);
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d30 1
a30 1
#include "main/texformat.h"
d41 1
a41 1
translate_texture_format(GLuint mesa_format)
d60 2
d124 2
d136 1
a136 1
   if (!intelObj->imageOverride && !intel_finalize_mipmap_tree(intel, unit))
d144 2
a145 16
   if (intelObj->imageOverride) {
      i830->state.tex_buffer[unit] = NULL;
      i830->state.tex_offset[unit] = intelObj->textureOffset;

      switch (intelObj->depthOverride) {
      case 32:
	 format = MAPSURF_32BIT | MT_32BIT_ARGB8888;
	 break;
      case 24:
      default:
	 format = MAPSURF_32BIT | MT_32BIT_XRGB8888;
	 break;
      case 16:
	 format = MAPSURF_16BIT | MT_16BIT_RGB565;
	 break;
      }
d147 7
a153 7
      pitch = intelObj->pitchOverride;
   } else {
      dri_bo_reference(intelObj->mt->region->buffer);
      i830->state.tex_buffer[unit] = intelObj->mt->region->buffer;
      i830->state.tex_offset[unit] = intel_miptree_image_offset(intelObj->mt,
								0, intelObj->
								firstLevel);
d155 3
a157 3
      format = translate_texture_format(firstImage->TexFormat->MesaFormat);
      pitch = intelObj->mt->pitch * intelObj->mt->cpp;
   }
a161 4
/*    state[I830_TEXREG_TM0S0] = (TM0S0_USE_FENCE | */
/* 			       t->intel.TextureOffset); */


d166 6
d285 10
a294 6

   state[I830_TEXREG_TM0S4] = INTEL_PACKCOLOR8888(tObj->_BorderChan[0],
                                                  tObj->_BorderChan[1],
                                                  tObj->_BorderChan[2],
                                                  tObj->_BorderChan[3]);

@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d28 3
a30 4
#include "mtypes.h"
#include "enums.h"
#include "texformat.h"
#include "dri_bufmgr.h"
@


1.1
log
@Initial revision
@
text
@a27 2
#include "glheader.h"
#include "macros.h"
a28 1
#include "simple_list.h"
d31 1
a31 1
#include "texstore.h"
d33 1
a33 4
#include "mm.h"

#include "intel_screen.h"
#include "intel_ioctl.h"
a38 13
static const GLint initial_offsets[6][2] = { {0,0},
				       {0,2},
				       {1,0},
				       {1,2},
				       {1,1},
				       {1,3} };

static const GLint step_offsets[6][2] = { {0,2},
				    {0,2},
				    {-1,2},
				    {-1,2},
				    {-1,1},
				    {-1,1} };
a39 1
#define I830_TEX_UNIT_ENABLED(unit)		(1<<unit)
d41 2
a42 2
static GLboolean i830SetTexImages( i830ContextPtr i830, 
				  struct gl_texture_object *tObj )
d44 1
a44 6
   GLuint total_height, pitch, i, textureFormat;
   i830TextureObjectPtr t = (i830TextureObjectPtr) tObj->DriverData;
   const struct gl_texture_image *baseImage = tObj->Image[0][tObj->BaseLevel];
   GLint firstLevel, lastLevel, numLevels;

   switch( baseImage->TexFormat->MesaFormat ) {
d46 1
a46 4
      t->intel.texelBytes = 1;
      textureFormat = MAPSURF_8BIT | MT_8BIT_L8;
      break;

d48 1
a48 4
      t->intel.texelBytes = 1;
      textureFormat = MAPSURF_8BIT | MT_8BIT_I8;
      break;

d50 1
a50 4
      t->intel.texelBytes = 1;
      textureFormat = MAPSURF_8BIT | MT_8BIT_I8; /* Kludge -- check with conform, glean */
      break;

d52 1
a52 4
      t->intel.texelBytes = 2;
      textureFormat = MAPSURF_16BIT | MT_16BIT_AY88;
      break;

d54 1
a54 4
      t->intel.texelBytes = 2;
      textureFormat = MAPSURF_16BIT | MT_16BIT_RGB565;
      break;

d56 1
a56 4
      t->intel.texelBytes = 2;
      textureFormat = MAPSURF_16BIT | MT_16BIT_ARGB1555;
      break;

d58 1
a58 4
      t->intel.texelBytes = 2;
      textureFormat = MAPSURF_16BIT | MT_16BIT_ARGB4444;
      break;

d60 1
a60 4
      t->intel.texelBytes = 4;
      textureFormat = MAPSURF_32BIT | MT_32BIT_ARGB8888;
      break;

d62 1
a62 5
      t->intel.texelBytes = 2;
      textureFormat = (MAPSURF_422 | MT_422_YCRCB_NORMAL | 
		       TM0S1_COLORSPACE_CONVERSION);
      break;

d64 1
a64 5
      t->intel.texelBytes = 2;
      textureFormat = (MAPSURF_422 | MT_422_YCRCB_SWAPY | /* ??? */
		       TM0S1_COLORSPACE_CONVERSION);
      break;

d67 1
a67 4
     t->intel.texelBytes = 2;
     textureFormat = MAPSURF_COMPRESSED | MT_COMPRESS_FXT1;
     break;

d70 1
a70 8
     /* 
      * DXTn pitches are Width/4 * blocksize in bytes 
      * for DXT1: blocksize=8 so Width/4*8 = Width * 2 
      * for DXT3/5: blocksize=16 so Width/4*16 = Width * 4
      */
     t->intel.texelBytes = 2;
     textureFormat = (MAPSURF_COMPRESSED | MT_COMPRESS_DXT1);
     break;
d72 1
a72 3
     t->intel.texelBytes = 4;
     textureFormat = (MAPSURF_COMPRESSED | MT_COMPRESS_DXT2_3);
     break;
d74 1
a74 4
     t->intel.texelBytes = 4;
     textureFormat = (MAPSURF_COMPRESSED | MT_COMPRESS_DXT4_5);
     break;

d76 1
a76 1
      fprintf(stderr, "%s: bad image format\n", __FUNCTION__);
d78 1
d80 1
a81 6
   /* Compute which mipmap levels we really want to send to the hardware.
    * This depends on the base image size, GL_TEXTURE_MIN_LOD,
    * GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, and GL_TEXTURE_MAX_LEVEL.
    * Yes, this looks overly complicated, but it's all needed.
    */
   driCalculateTextureFirstLastLevel( (driTextureObject *) t );
a83 7
   /* Figure out the amount of memory required to hold all the mipmap
    * levels.  Choose the smallest pitch to accomodate the largest
    * mipmap:
    */
   firstLevel = t->intel.base.firstLevel;
   lastLevel = t->intel.base.lastLevel;
   numLevels = lastLevel - firstLevel + 1;
d85 17
a101 43

   /* All images must be loaded at this pitch.  Count the number of
    * lines required:
    */
   switch (tObj->Target) {
   case GL_TEXTURE_CUBE_MAP: {
      const GLuint dim = tObj->Image[0][firstLevel]->Width;
      GLuint face;

      pitch = dim * t->intel.texelBytes;
      pitch *= 2;		/* double pitch for cube layouts */
      pitch = (pitch + 3) & ~3;
      
      total_height = dim * 4;

      for ( face = 0 ; face < 6 ; face++) {
	 GLuint x = initial_offsets[face][0] * dim;
	 GLuint y = initial_offsets[face][1] * dim;
	 GLuint d = dim;
	 
	 t->intel.base.dirty_images[face] = ~0;

	 assert(tObj->Image[face][firstLevel]->Width == dim);
	 assert(tObj->Image[face][firstLevel]->Height == dim);

	 for (i = 0; i < numLevels; i++) {
	    t->intel.image[face][i].image = tObj->Image[face][firstLevel + i];
	    if (!t->intel.image[face][i].image) {
	       fprintf(stderr, "no image %d %d\n", face, i);
	       break;		/* can't happen */
	    }
	 
	    t->intel.image[face][i].offset = 
	       y * pitch + x * t->intel.texelBytes;
	    t->intel.image[face][i].internalFormat = baseImage->_BaseFormat;

	    d >>= 1;
	    x += step_offsets[face][0] * d;
	    y += step_offsets[face][1] * d;
	 }
      }
      break;
   }
d103 1
a103 22
      pitch = tObj->Image[0][firstLevel]->Width * t->intel.texelBytes;
      pitch = (pitch + 3) & ~3;
      t->intel.base.dirty_images[0] = ~0;

      for ( total_height = i = 0 ; i < numLevels ; i++ ) {
	 t->intel.image[0][i].image = tObj->Image[0][firstLevel + i];
	 if (!t->intel.image[0][i].image) 
	    break;
	 
	 t->intel.image[0][i].offset = total_height * pitch;
	 t->intel.image[0][i].internalFormat = baseImage->_BaseFormat;
	 if (t->intel.image[0][i].image->IsCompressed)
	 {
	   if (t->intel.image[0][i].image->Height > 4)
	     total_height += t->intel.image[0][i].image->Height/4;
	   else
	     total_height += 1;
	 }
	 else
	   total_height += MAX2(2, t->intel.image[0][i].image->Height);
      }
      break;
a104 17

   t->intel.Pitch = pitch;
   t->intel.base.totalSize = total_height*pitch;
   t->intel.max_level = i-1;
   t->Setup[I830_TEXREG_TM0S1] = 
      (((tObj->Image[0][firstLevel]->Height - 1) << TM0S1_HEIGHT_SHIFT) |
       ((tObj->Image[0][firstLevel]->Width - 1) << TM0S1_WIDTH_SHIFT) |
       textureFormat);
   t->Setup[I830_TEXREG_TM0S2] = 
      (((pitch / 4) - 1) << TM0S2_PITCH_SHIFT) |
      TM0S2_CUBE_FACE_ENA_MASK;
   t->Setup[I830_TEXREG_TM0S3] &= ~TM0S3_MAX_MIP_MASK;
   t->Setup[I830_TEXREG_TM0S3] &= ~TM0S3_MIN_MIP_MASK;
   t->Setup[I830_TEXREG_TM0S3] |= ((numLevels - 1)*4) << TM0S3_MIN_MIP_SHIFT;
   t->intel.dirty = I830_UPLOAD_TEX_ALL;

   return intelUploadTexImages( &i830->intel, &t->intel, 0 );
d108 6
a113 3
static void i830_import_tex_unit( i830ContextPtr i830, 
			   i830TextureObjectPtr t,
			   GLuint unit )
d115 8
a122 28
   if(INTEL_DEBUG&DEBUG_TEXTURE)
      fprintf(stderr, "%s unit(%d)\n", __FUNCTION__, unit);
   
   if (i830->intel.CurrentTexObj[unit]) 
      i830->intel.CurrentTexObj[unit]->base.bound &= ~(1U << unit);

   i830->intel.CurrentTexObj[unit] = (intelTextureObjectPtr)t;
   t->intel.base.bound |= (1 << unit);

   I830_STATECHANGE( i830, I830_UPLOAD_TEX(unit) );

   i830->state.Tex[unit][I830_TEXREG_TM0LI] = (_3DSTATE_LOAD_STATE_IMMEDIATE_2 | 
					       (LOAD_TEXTURE_MAP0 << unit) | 4);
   i830->state.Tex[unit][I830_TEXREG_TM0S0] = (TM0S0_USE_FENCE |
					       t->intel.TextureOffset);

   i830->state.Tex[unit][I830_TEXREG_TM0S1] = t->Setup[I830_TEXREG_TM0S1];
   i830->state.Tex[unit][I830_TEXREG_TM0S2] = t->Setup[I830_TEXREG_TM0S2];

   i830->state.Tex[unit][I830_TEXREG_TM0S3] &= TM0S3_LOD_BIAS_MASK;
   i830->state.Tex[unit][I830_TEXREG_TM0S3] |= (t->Setup[I830_TEXREG_TM0S3] &
						~TM0S3_LOD_BIAS_MASK);

   i830->state.Tex[unit][I830_TEXREG_TM0S4] = t->Setup[I830_TEXREG_TM0S4];
   i830->state.Tex[unit][I830_TEXREG_MCS] = (t->Setup[I830_TEXREG_MCS] & 
					     ~MAP_UNIT_MASK);   
   i830->state.Tex[unit][I830_TEXREG_CUBE] = t->Setup[I830_TEXREG_CUBE];
   i830->state.Tex[unit][I830_TEXREG_MCS] |= MAP_UNIT(unit);
d124 1
a124 2
   t->intel.dirty &= ~I830_UPLOAD_TEX(unit);
}
d126 1
d128 4
d133 1
a133 12
static GLboolean enable_tex_common( GLcontext *ctx, GLuint unit )
{
   i830ContextPtr i830 = I830_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *tObj = texUnit->_Current;
   i830TextureObjectPtr t = (i830TextureObjectPtr)tObj->DriverData;

   if (0) fprintf(stderr, "%s\n", __FUNCTION__);

   /* Fallback if there's a texture border */
   if ( tObj->Image[0][tObj->BaseLevel]->Border > 0 ) {
      fprintf(stderr, "Texture border\n");
a134 1
   }
d136 2
a137 1
   /* Upload teximages (not pipelined)
d139 17
a155 3
   if (t->intel.base.dirty_images[0]) {
      if (!i830SetTexImages( i830, tObj )) {
	 return GL_FALSE;
a156 1
   }
d158 36
a193 6
   /* Update state if this is a different texture object to last
    * time.
    */
   if (i830->intel.CurrentTexObj[unit] != &t->intel || 
       (t->intel.dirty & I830_UPLOAD_TEX(unit))) {
      i830_import_tex_unit( i830, t, unit);
a195 1
   I830_ACTIVESTATE(i830, I830_UPLOAD_TEX(unit), GL_TRUE);
a196 2
   return GL_TRUE;
}
a197 4
static GLboolean enable_tex_rect( GLcontext *ctx, GLuint unit )
{
   i830ContextPtr i830 = I830_CONTEXT(ctx);
   GLuint mcs = i830->state.Tex[unit][I830_TEXREG_MCS];
d199 31
a229 2
   mcs &= ~TEXCOORDS_ARE_NORMAL;
   mcs |= TEXCOORDS_ARE_IN_TEXELUNITS;
d231 16
a246 9
   if ((mcs != i830->state.Tex[unit][I830_TEXREG_MCS])
       || (0 != i830->state.Tex[unit][I830_TEXREG_CUBE])) {
      I830_STATECHANGE(i830, I830_UPLOAD_TEX(unit));
      i830->state.Tex[unit][I830_TEXREG_MCS] = mcs;
      i830->state.Tex[unit][I830_TEXREG_CUBE] = 0;
   }

   return GL_TRUE;
}
d248 15
d264 3
a266 4
static GLboolean enable_tex_2d( GLcontext *ctx, GLuint unit )
{
   i830ContextPtr i830 = I830_CONTEXT(ctx);
   GLuint mcs = i830->state.Tex[unit][I830_TEXREG_MCS];
d268 3
a270 8
   mcs &= ~TEXCOORDS_ARE_IN_TEXELUNITS;
   mcs |= TEXCOORDS_ARE_NORMAL;

   if ((mcs != i830->state.Tex[unit][I830_TEXREG_MCS])
       || (0 != i830->state.Tex[unit][I830_TEXREG_CUBE])) {
      I830_STATECHANGE(i830, I830_UPLOAD_TEX(unit));
      i830->state.Tex[unit][I830_TEXREG_MCS] = mcs;
      i830->state.Tex[unit][I830_TEXREG_CUBE] = 0;
d273 3
a275 2
   return GL_TRUE;
}
a276 22
 
static GLboolean enable_tex_cube( GLcontext *ctx, GLuint unit )
{
   i830ContextPtr i830 = I830_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *tObj = texUnit->_Current;
   i830TextureObjectPtr t = (i830TextureObjectPtr)tObj->DriverData;
   GLuint mcs = i830->state.Tex[unit][I830_TEXREG_MCS];
   const GLuint cube = CUBE_NEGX_ENABLE | CUBE_POSX_ENABLE
     | CUBE_NEGY_ENABLE | CUBE_POSY_ENABLE
     | CUBE_NEGZ_ENABLE | CUBE_POSZ_ENABLE;
   GLuint face;

   mcs &= ~TEXCOORDS_ARE_IN_TEXELUNITS;
   mcs |= TEXCOORDS_ARE_NORMAL;

   if ((mcs != i830->state.Tex[unit][I830_TEXREG_MCS])
       || (cube != i830->state.Tex[unit][I830_TEXREG_CUBE])) {
      I830_STATECHANGE(i830, I830_UPLOAD_TEX(unit));
      i830->state.Tex[unit][I830_TEXREG_MCS] = mcs;
      i830->state.Tex[unit][I830_TEXREG_CUBE] = cube;
   }
d278 4
a281 7
   /* Upload teximages (not pipelined)
    */
   if ( t->intel.base.dirty_images[0] || t->intel.base.dirty_images[1] ||
        t->intel.base.dirty_images[2] || t->intel.base.dirty_images[3] ||
        t->intel.base.dirty_images[4] || t->intel.base.dirty_images[5] ) {
      i830SetTexImages( i830, tObj );
   }
d283 9
a291 7
   /* upload (per face) */
   for (face = 0; face < 6; face++) {
      if (t->intel.base.dirty_images[face]) {
	 if (!intelUploadTexImages( &i830->intel, &t->intel, face )) {
	    return GL_FALSE;
	 }
      }
d295 4
a298 2
   return GL_TRUE;
}
d301 3
a303 9
static GLboolean disable_tex( GLcontext *ctx, GLuint unit )
{
   i830ContextPtr i830 = I830_CONTEXT(ctx);

   /* This is happening too often.  I need to conditionally send diffuse
    * state to the card.  Perhaps a diffuse dirty flag of some kind.
    * Will need to change this logic if more than 2 texture units are
    * used.  We need to only do this up to the last unit enabled, or unit
    * one if nothing is enabled.
d305 1
a305 10

   if ( i830->intel.CurrentTexObj[unit] != NULL ) {
      /* The old texture is no longer bound to this texture unit.
       * Mark it as such.
       */

      i830->intel.CurrentTexObj[unit]->base.bound &= ~(1U << 0);
      i830->intel.CurrentTexObj[unit] = NULL;
   }

a308 3
static GLboolean i830UpdateTexUnit( GLcontext *ctx, GLuint unit )
{
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
a309 21
   if (texUnit->_ReallyEnabled &&
       INTEL_CONTEXT(ctx)->intelScreen->tex.size < 2048 * 1024)
      return GL_FALSE;

   switch(texUnit->_ReallyEnabled) {
   case TEXTURE_1D_BIT:
   case TEXTURE_2D_BIT:
      return (enable_tex_common( ctx, unit ) &&
	      enable_tex_2d( ctx, unit ));
   case TEXTURE_RECT_BIT:
      return (enable_tex_common( ctx, unit ) &&
	      enable_tex_rect( ctx, unit ));
   case TEXTURE_CUBE_BIT:
      return (enable_tex_common( ctx, unit ) &&
	      enable_tex_cube( ctx, unit ));
   case 0:
      return disable_tex( ctx, unit );
   default:
      return GL_FALSE;
   }
}
d312 2
a313 1
void i830UpdateTextureState( intelContextPtr intel )
d315 31
a345 5
   i830ContextPtr i830 = I830_CONTEXT(intel);
   GLcontext *ctx = &intel->ctx;
   GLboolean ok;

   if (0) fprintf(stderr, "%s\n", __FUNCTION__);
d347 1
a347 8
   I830_ACTIVESTATE(i830, I830_UPLOAD_TEX_ALL, GL_FALSE);

   ok = (i830UpdateTexUnit( ctx, 0 ) &&
	 i830UpdateTexUnit( ctx, 1 ) &&
	 i830UpdateTexUnit( ctx, 2 ) &&
	 i830UpdateTexUnit( ctx, 3 ));

   FALLBACK( intel, I830_FALLBACK_TEXTURE, !ok );
d350 1
a350 1
      i830EmitTextureBlend( i830 );
a351 3



@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d28 7
a34 3
#include "main/mtypes.h"
#include "main/enums.h"
#include "main/colormac.h"
d36 4
a39 1
#include "intel_mipmap_tree.h"
d45 13
d59 1
d61 2
a62 2
static GLuint
translate_texture_format(GLuint mesa_format, GLuint internal_format)
d64 6
a69 1
   switch (mesa_format) {
d71 4
a74 1
      return MAPSURF_8BIT | MT_8BIT_L8;
d76 4
a79 1
      return MAPSURF_8BIT | MT_8BIT_I8;
d81 4
a84 1
      return MAPSURF_8BIT | MT_8BIT_I8; /* Kludge! */
d86 4
a89 1
      return MAPSURF_16BIT | MT_16BIT_AY88;
d91 4
a94 1
      return MAPSURF_16BIT | MT_16BIT_RGB565;
d96 4
a99 1
      return MAPSURF_16BIT | MT_16BIT_ARGB1555;
d101 4
a104 1
      return MAPSURF_16BIT | MT_16BIT_ARGB4444;
d106 4
a109 3
      return MAPSURF_32BIT | MT_32BIT_ARGB8888;
   case MESA_FORMAT_XRGB8888:
      return MAPSURF_32BIT | MT_32BIT_XRGB8888;
d111 5
a115 1
      return (MAPSURF_422 | MT_422_YCRCB_NORMAL);
d117 5
a121 1
      return (MAPSURF_422 | MT_422_YCRCB_SWAPY);
d124 4
a127 1
      return (MAPSURF_COMPRESSED | MT_COMPRESS_FXT1);
d130 8
a137 1
      return (MAPSURF_COMPRESSED | MT_COMPRESS_DXT1);
d139 3
a141 1
      return (MAPSURF_COMPRESSED | MT_COMPRESS_DXT2_3);
d143 4
a146 1
      return (MAPSURF_COMPRESSED | MT_COMPRESS_DXT4_5);
d148 1
a148 1
      fprintf(stderr, "%s: bad image format %x\n", __FUNCTION__, mesa_format);
a149 1
      return 0;
d151 7
a157 1
}
d160 7
d169 42
a210 17
/* The i915 (and related graphics cores) do not support GL_CLAMP.  The
 * Intel drivers for "other operating systems" implement GL_CLAMP as
 * GL_CLAMP_TO_EDGE, so the same is done here.
 */
static GLuint
translate_wrap_mode(GLenum wrap)
{
   switch (wrap) {
   case GL_REPEAT:
      return TEXCOORDMODE_WRAP;
   case GL_CLAMP:
   case GL_CLAMP_TO_EDGE:
      return TEXCOORDMODE_CLAMP;        /* not really correct */
   case GL_CLAMP_TO_BORDER:
      return TEXCOORDMODE_CLAMP_BORDER;
   case GL_MIRRORED_REPEAT:
      return TEXCOORDMODE_MIRROR;
d212 22
a233 1
      return TEXCOORDMODE_WRAP;
d235 17
d255 3
a257 6
/* Recalculate all state from scratch.  Perhaps not the most
 * efficient, but this has gotten complex enough that we need
 * something which is understandable and reliable.
 */
static GLboolean
i830_update_tex_unit(struct intel_context *intel, GLuint unit, GLuint ss3)
d259 33
a291 19
   struct gl_context *ctx = &intel->ctx;
   struct i830_context *i830 = i830_context(ctx);
   struct gl_texture_unit *tUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *tObj = tUnit->_Current;
   struct intel_texture_object *intelObj = intel_texture_object(tObj);
   struct gl_texture_image *firstImage;
   GLuint *state = i830->state.Tex[unit], format, pitch;
   GLint lodbias;
   GLubyte border[4];
   GLuint dst_x, dst_y;

   memset(state, 0, sizeof(state));

   /*We need to refcount these. */

   if (i830->state.tex_buffer[unit] != NULL) {
       drm_intel_bo_unreference(i830->state.tex_buffer[unit]);
       i830->state.tex_buffer[unit] = NULL;
   }
d293 12
a304 1
   if (!intel_finalize_mipmap_tree(intel, unit))
d306 1
d308 1
a308 2
   /* Get first image here, since intelObj->firstLevel will get set in
    * the intel_finalize_mipmap_tree() call above.
d310 5
a314 1
   firstImage = tObj->Image[0][intelObj->firstLevel];
d316 7
a322 2
   intel_miptree_get_image_offset(intelObj->mt, intelObj->firstLevel, 0, 0,
				  &dst_x, &dst_y);
d324 1
a324 3
   drm_intel_bo_reference(intelObj->mt->region->buffer);
   i830->state.tex_buffer[unit] = intelObj->mt->region->buffer;
   pitch = intelObj->mt->region->pitch * intelObj->mt->cpp;
d326 2
a327 4
   /* XXX: This calculation is probably broken for tiled images with
    * a non-page-aligned offset.
    */
   i830->state.tex_offset[unit] = dst_x * intelObj->mt->cpp + dst_y * pitch;
d329 4
a332 2
   format = translate_texture_format(firstImage->TexFormat,
				     firstImage->InternalFormat);
d334 2
a335 2
   state[I830_TEXREG_TM0LI] = (_3DSTATE_LOAD_STATE_IMMEDIATE_2 |
                               (LOAD_TEXTURE_MAP0 << unit) | 4);
d337 5
a341 23
   state[I830_TEXREG_TM0S1] =
      (((firstImage->Height - 1) << TM0S1_HEIGHT_SHIFT) |
       ((firstImage->Width - 1) << TM0S1_WIDTH_SHIFT) | format);

   if (intelObj->mt->region->tiling != I915_TILING_NONE) {
      state[I830_TEXREG_TM0S1] |= TM0S1_TILED_SURFACE;
      if (intelObj->mt->region->tiling == I915_TILING_Y)
	 state[I830_TEXREG_TM0S1] |= TM0S1_TILE_WALK;
   }

   state[I830_TEXREG_TM0S2] =
      ((((pitch / 4) - 1) << TM0S2_PITCH_SHIFT) | TM0S2_CUBE_FACE_ENA_MASK);

   {
      if (tObj->Target == GL_TEXTURE_CUBE_MAP)
         state[I830_TEXREG_CUBE] = (_3DSTATE_MAP_CUBE | MAP_UNIT(unit) |
                                    CUBE_NEGX_ENABLE |
                                    CUBE_POSX_ENABLE |
                                    CUBE_NEGY_ENABLE |
                                    CUBE_POSY_ENABLE |
                                    CUBE_NEGZ_ENABLE | CUBE_POSZ_ENABLE);
      else
         state[I830_TEXREG_CUBE] = (_3DSTATE_MAP_CUBE | MAP_UNIT(unit));
d344 3
d348 4
d353 2
d356 6
a361 31
   {
      GLuint minFilt, mipFilt, magFilt;

      switch (tObj->MinFilter) {
      case GL_NEAREST:
         minFilt = FILTER_NEAREST;
         mipFilt = MIPFILTER_NONE;
         break;
      case GL_LINEAR:
         minFilt = FILTER_LINEAR;
         mipFilt = MIPFILTER_NONE;
         break;
      case GL_NEAREST_MIPMAP_NEAREST:
         minFilt = FILTER_NEAREST;
         mipFilt = MIPFILTER_NEAREST;
         break;
      case GL_LINEAR_MIPMAP_NEAREST:
         minFilt = FILTER_LINEAR;
         mipFilt = MIPFILTER_NEAREST;
         break;
      case GL_NEAREST_MIPMAP_LINEAR:
         minFilt = FILTER_NEAREST;
         mipFilt = MIPFILTER_LINEAR;
         break;
      case GL_LINEAR_MIPMAP_LINEAR:
         minFilt = FILTER_LINEAR;
         mipFilt = MIPFILTER_LINEAR;
         break;
      default:
         return GL_FALSE;
      }
d363 2
a364 16
      if (tObj->MaxAnisotropy > 1.0) {
         minFilt = FILTER_ANISOTROPIC;
         magFilt = FILTER_ANISOTROPIC;
      }
      else {
         switch (tObj->MagFilter) {
         case GL_NEAREST:
            magFilt = FILTER_NEAREST;
            break;
         case GL_LINEAR:
            magFilt = FILTER_LINEAR;
            break;
         default:
            return GL_FALSE;
         }
      }
d366 22
a387 15
      lodbias = (int) ((tUnit->LodBias + tObj->LodBias) * 16.0);
      if (lodbias < -64)
          lodbias = -64;
      if (lodbias > 63)
          lodbias = 63;
      
      state[I830_TEXREG_TM0S3] = ((lodbias << TM0S3_LOD_BIAS_SHIFT) & 
                                  TM0S3_LOD_BIAS_MASK);
#if 0
      /* YUV conversion:
       */
      if (firstImage->TexFormat->MesaFormat == MESA_FORMAT_YCBCR ||
          firstImage->TexFormat->MesaFormat == MESA_FORMAT_YCBCR_REV)
         state[I830_TEXREG_TM0S3] |= SS2_COLORSPACE_CONVERSION;
#endif
d389 7
a395 3
      state[I830_TEXREG_TM0S3] |= ((intelObj->lastLevel -
                                    intelObj->firstLevel) *
                                   4) << TM0S3_MIN_MIP_SHIFT;
d397 7
a403 3
      state[I830_TEXREG_TM0S3] |= ((minFilt << TM0S3_MIN_FILTER_SHIFT) |
                                   (mipFilt << TM0S3_MIP_FILTER_SHIFT) |
                                   (magFilt << TM0S3_MAG_FILTER_SHIFT));
a405 3
   {
      GLenum ws = tObj->WrapS;
      GLenum wt = tObj->WrapT;
d407 7
d415 10
a424 1
      /* 3D textures not available on i830
a425 2
      if (tObj->Target == GL_TEXTURE_3D)
         return GL_FALSE;
d427 3
a429 21
      state[I830_TEXREG_MCS] = (_3DSTATE_MAP_COORD_SET_CMD |
                                MAP_UNIT(unit) |
                                ENABLE_TEXCOORD_PARAMS |
                                ss3 |
                                ENABLE_ADDR_V_CNTL |
                                TEXCOORD_ADDR_V_MODE(translate_wrap_mode(wt))
                                | ENABLE_ADDR_U_CNTL |
                                TEXCOORD_ADDR_U_MODE(translate_wrap_mode
                                                     (ws)));
   }

   /* convert border color from float to ubyte */
   CLAMPED_FLOAT_TO_UBYTE(border[0], tObj->BorderColor.f[0]);
   CLAMPED_FLOAT_TO_UBYTE(border[1], tObj->BorderColor.f[1]);
   CLAMPED_FLOAT_TO_UBYTE(border[2], tObj->BorderColor.f[2]);
   CLAMPED_FLOAT_TO_UBYTE(border[3], tObj->BorderColor.f[3]);

   state[I830_TEXREG_TM0S4] = PACK_COLOR_8888(border[3],
					      border[0],
					      border[1],
					      border[2]);
a430 5
   I830_ACTIVESTATE(i830, I830_UPLOAD_TEX(unit), GL_TRUE);
   /* memcmp was already disabled, but definitely won't work as the
    * region might now change and that wouldn't be detected:
    */
   I830_STATECHANGE(i830, I830_UPLOAD_TEX(unit));
d434 3
d438 21
d461 1
a461 2
void
i830UpdateTextureState(struct intel_context *intel)
d463 12
a474 31
   struct i830_context *i830 = i830_context(&intel->ctx);
   GLboolean ok = GL_TRUE;
   GLuint i;

   for (i = 0; i < I830_TEX_UNITS && ok; i++) {
      switch (intel->ctx.Texture.Unit[i]._ReallyEnabled) {
      case TEXTURE_1D_BIT:
      case TEXTURE_2D_BIT:
      case TEXTURE_CUBE_BIT:
         ok = i830_update_tex_unit(intel, i, TEXCOORDS_ARE_NORMAL);
         break;
      case TEXTURE_RECT_BIT:
         ok = i830_update_tex_unit(intel, i, TEXCOORDS_ARE_IN_TEXELUNITS);
         break;
      case 0:{
	 struct i830_context *i830 = i830_context(&intel->ctx);
         if (i830->state.active & I830_UPLOAD_TEX(i)) 
            I830_ACTIVESTATE(i830, I830_UPLOAD_TEX(i), GL_FALSE);

	 if (i830->state.tex_buffer[i] != NULL) {
	    drm_intel_bo_unreference(i830->state.tex_buffer[i]);
	    i830->state.tex_buffer[i] = NULL;
	 }
         break;
      }
      case TEXTURE_3D_BIT:
      default:
         ok = GL_FALSE;
         break;
      }
   }
d476 1
a476 1
   FALLBACK(intel, I830_FALLBACK_TEXTURE, !ok);
d479 1
a479 1
      i830EmitTextureBlend(i830);
d481 3
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@a30 2
#include "main/macros.h"
#include "main/samplerobj.h"
d37 1
a37 1
#include "intel_chipset.h"
d41 1
a41 1
translate_texture_format(GLuint mesa_format)
d77 1
a77 2
      fprintf(stderr, "%s: bad image format %s\n", __FUNCTION__,
	      _mesa_get_format_name(mesa_format));
d113 1
a113 1
static bool
a121 1
   struct gl_sampler_object *sampler = _mesa_get_samplerobj(ctx, unit);
d127 1
a127 1
   memset(state, 0, sizeof(*state));
d137 1
a137 1
      return false;
d142 1
a142 1
   firstImage = tObj->Image[0][tObj->BaseLevel];
d144 1
a144 1
   intel_miptree_get_image_offset(intelObj->mt, tObj->BaseLevel, 0,
d147 3
a149 3
   drm_intel_bo_reference(intelObj->mt->region->bo);
   i830->state.tex_buffer[unit] = intelObj->mt->region->bo;
   pitch = intelObj->mt->region->pitch;
d156 2
a157 1
   format = translate_texture_format(firstImage->TexFormat);
a191 2
      float maxlod;
      uint32_t minlod_fixed, maxlod_fixed;
d193 1
a193 1
      switch (sampler->MinFilter) {
d219 1
a219 1
         return false;
d222 1
a222 1
      if (sampler->MaxAnisotropy > 1.0) {
d227 1
a227 1
         switch (sampler->MagFilter) {
d235 1
a235 1
            return false;
d239 1
a239 1
      lodbias = (int) ((tUnit->LodBias + sampler->LodBias) * 16.0);
d255 4
a258 18
      /* We get one field with fraction bits for the maximum
       * addressable (smallest resolution) LOD.  Use it to cover both
       * MAX_LEVEL and MAX_LOD.
       */
      minlod_fixed = U_FIXED(CLAMP(sampler->MinLod, 0.0, 11), 4);
      maxlod = MIN2(sampler->MaxLod, tObj->_MaxLevel - tObj->BaseLevel);
      if (intel->intelScreen->deviceID == PCI_CHIP_I855_GM ||
	  intel->intelScreen->deviceID == PCI_CHIP_I865_G) {
	 maxlod_fixed = U_FIXED(CLAMP(maxlod, 0.0, 11.75), 2);
	 maxlod_fixed = MAX2(maxlod_fixed, (minlod_fixed + 3) >> 2);
	 state[I830_TEXREG_TM0S3] |= maxlod_fixed << TM0S3_MIN_MIP_SHIFT;
	 state[I830_TEXREG_TM0S2] |= TM0S2_LOD_PRECLAMP;
      } else {
	 maxlod_fixed = U_FIXED(CLAMP(maxlod, 0.0, 11), 0);
	 maxlod_fixed = MAX2(maxlod_fixed, (minlod_fixed + 15) >> 4);
	 state[I830_TEXREG_TM0S3] |= maxlod_fixed << TM0S3_MIN_MIP_SHIFT_830;
      }
      state[I830_TEXREG_TM0S3] |= minlod_fixed << TM0S3_MAX_MIP_SHIFT;
d265 2
a266 2
      GLenum ws = sampler->WrapS;
      GLenum wt = sampler->WrapT;
d272 1
a272 1
         return false;
d286 4
a289 4
   CLAMPED_FLOAT_TO_UBYTE(border[0], sampler->BorderColor.f[0]);
   CLAMPED_FLOAT_TO_UBYTE(border[1], sampler->BorderColor.f[1]);
   CLAMPED_FLOAT_TO_UBYTE(border[2], sampler->BorderColor.f[2]);
   CLAMPED_FLOAT_TO_UBYTE(border[3], sampler->BorderColor.f[3]);
d296 1
a296 1
   I830_ACTIVESTATE(i830, I830_UPLOAD_TEX(unit), true);
d301 1
a301 1
   return true;
d311 1
a311 1
   bool ok = true;
d327 1
a327 1
            I830_ACTIVESTATE(i830, I830_UPLOAD_TEX(i), false);
d337 1
a337 1
         ok = false;
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d46 1
a46 1
   case MESA_FORMAT_L_UNORM8:
d48 1
a48 1
   case MESA_FORMAT_I_UNORM8:
d50 1
a50 1
   case MESA_FORMAT_A_UNORM8:
d52 1
a52 1
   case MESA_FORMAT_L8A8_UNORM:
d54 1
a54 1
   case MESA_FORMAT_B5G6R5_UNORM:
d56 1
a56 1
   case MESA_FORMAT_B5G5R5A1_UNORM:
d58 1
a58 1
   case MESA_FORMAT_B4G4R4A4_UNORM:
d60 1
a60 1
   case MESA_FORMAT_B8G8R8A8_UNORM:
d62 1
a62 1
   case MESA_FORMAT_B8G8R8X8_UNORM:
d334 12
a345 18
      if (intel->ctx.Texture.Unit[i]._Current) {
         switch (intel->ctx.Texture.Unit[i]._Current->Target) {
         case GL_TEXTURE_1D:
         case GL_TEXTURE_2D:
         case GL_TEXTURE_CUBE_MAP:
            ok = i830_update_tex_unit(intel, i, TEXCOORDS_ARE_NORMAL);
            break;
         case GL_TEXTURE_RECTANGLE:
            ok = i830_update_tex_unit(intel, i, TEXCOORDS_ARE_IN_TEXELUNITS);
            break;
         case GL_TEXTURE_3D:
         default:
            ok = false;
            break;
         }
      } else {
         struct i830_context *i830 = i830_context(&intel->ctx);
         if (i830->state.active & I830_UPLOAD_TEX(i))
d348 10
a357 4
         if (i830->state.tex_buffer[i] != NULL) {
            drm_intel_bo_unreference(i830->state.tex_buffer[i]);
            i830->state.tex_buffer[i] = NULL;
         }
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d50 2
a229 2
         /* no trilinear + anisotropic */
         mipFilt = MIPFILTER_NEAREST;
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@a49 2
   case MESA_FORMAT_A_UNORM8:
      return MAPSURF_8BIT | MT_8BIT_I8; /* Kludge! */
d228 2
@


