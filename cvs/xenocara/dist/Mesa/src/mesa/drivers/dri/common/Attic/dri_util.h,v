head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.04.04;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.24.19.03.21;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.16;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.07;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.02;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.27.45;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.35;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.15.16;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.46;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file dri_util.h
 * DRI utility functions definitions.
 *
 * This module acts as glue between GLX and the actual hardware driver.  A DRI
 * driver doesn't really \e have to use any of this - it's optional.  But, some
 * useful stuff is done here that otherwise would have to be duplicated in most
 * drivers.
 * 
 * Basically, these utility functions take care of some of the dirty details of
 * screen initialization, context creation, context binding, DRM setup, etc.
 *
 * These functions are compiled into each DRI driver so libGL.so knows nothing
 * about them.
 *
 * \sa dri_util.c.
 * 
 * \author Kevin E. Martin <kevin@@precisioninsight.com>
 * \author Brian Paul <brian@@precisioninsight.com>
 */

/**
 * The following structs are shared between DRISW and DRI2, the DRISW structs
 * are essentially base classes of the DRI2 structs. DRISW needs to compile on
 * platforms without DRM, so keep the structs opaque to DRM.
 */

#ifndef _DRI_UTIL_H_
#define _DRI_UTIL_H_

#include <GL/gl.h>
#include <GL/internal/dri_interface.h>
#include "main/mtypes.h"
#include "xmlconfig.h"
#include <stdbool.h>

/**
 * Extensions.
 */
extern const __DRIcoreExtension driCoreExtension;
extern const __DRIswrastExtension driSWRastExtension;
extern const __DRIdri2Extension driDRI2Extension;
extern const __DRI2configQueryExtension dri2ConfigQueryExtension;
extern const __DRIcopySubBufferExtension driCopySubBufferExtension;
/**
 * Driver callback functions.
 *
 * Each DRI driver must have one of these structures with all the pointers set
 * to appropriate functions within the driver.
 * 
 * When glXCreateContext() is called, for example, it'll call a helper function
 * dri_util.c which in turn will jump through the \a CreateContext pointer in
 * this structure.
 */
struct __DriverAPIRec {
    const __DRIconfig **(*InitScreen) (__DRIscreen * priv);

    void (*DestroyScreen)(__DRIscreen *driScrnPriv);

    GLboolean (*CreateContext)(gl_api api,
                               const struct gl_config *glVis,
                               __DRIcontext *driContextPriv,
			       unsigned major_version,
			       unsigned minor_version,
			       uint32_t flags,
                               bool notify_reset,
			       unsigned *error,
                               void *sharedContextPrivate);

    void (*DestroyContext)(__DRIcontext *driContextPriv);

    GLboolean (*CreateBuffer)(__DRIscreen *driScrnPriv,
                              __DRIdrawable *driDrawPriv,
                              const struct gl_config *glVis,
                              GLboolean pixmapBuffer);

    void (*DestroyBuffer)(__DRIdrawable *driDrawPriv);

    void (*SwapBuffers)(__DRIdrawable *driDrawPriv);

    GLboolean (*MakeCurrent)(__DRIcontext *driContextPriv,
                             __DRIdrawable *driDrawPriv,
                             __DRIdrawable *driReadPriv);

    GLboolean (*UnbindContext)(__DRIcontext *driContextPriv);

    __DRIbuffer *(*AllocateBuffer) (__DRIscreen *screenPrivate,
                                    unsigned int attachment,
                                    unsigned int format,
                                    int width, int height);

    void (*ReleaseBuffer) (__DRIscreen *screenPrivate, __DRIbuffer *buffer);

    void (*CopySubBuffer)(__DRIdrawable *driDrawPriv, int x, int y,
                          int w, int h);
};

extern const struct __DriverAPIRec driDriverAPI;
extern const struct __DriverAPIRec *globalDriverAPI;

/**
 * Per-screen private driver information.
 */
struct __DRIscreenRec {
    /**
     * Driver-specific entrypoints provided by the driver's
     * __DRIDriverVtableExtensionRec.
     */
    const struct __DriverAPIRec *driver;

    /**
     * Current screen's number
     */
    int myNum;

    /**
     * File descriptor returned when the kernel device driver is opened.
     * 
     * Used to:
     *   - authenticate client to kernel
     *   - map the frame buffer, SAREA, etc.
     *   - close the kernel device driver
     */
    int fd;

    /**
     * DRM (kernel module) version information.
     */
    __DRIversion drm_version;

    /**
     * Device-dependent private information (not stored in the SAREA).
     * 
     * This pointer is never touched by the DRI layer.
     */
    void *driverPrivate;

    void *loaderPrivate;

    int max_gl_core_version;
    int max_gl_compat_version;
    int max_gl_es1_version;
    int max_gl_es2_version;

    const __DRIextension **extensions;

    const __DRIswrastLoaderExtension *swrast_loader;

    struct {
	/* Flag to indicate that this is a DRI2 screen.  Many of the above
	 * fields will not be valid or initializaed in that case. */
	const __DRIdri2LoaderExtension *loader;
	const __DRIimageLookupExtension *image;
	const __DRIuseInvalidateExtension *useInvalidate;
    } dri2;

    struct {
        const __DRIimageLoaderExtension *loader;
    } image;

    driOptionCache optionInfo;
    driOptionCache optionCache;

    unsigned int api_mask;
};

/**
 * Per-context private driver information.
 */
struct __DRIcontextRec {
    /**
     * Device driver's private context data.  This structure is opaque.
     */
    void *driverPrivate;

    /**
     * The loaders's private context data.  This structure is opaque.
     */
    void *loaderPrivate;

    /**
     * Pointer to drawable currently bound to this context for drawing.
     */
    __DRIdrawable *driDrawablePriv;

    /**
     * Pointer to drawable currently bound to this context for reading.
     */
    __DRIdrawable *driReadablePriv;

    /**
     * Pointer to screen on which this context was created.
     */
    __DRIscreen *driScreenPriv;

    struct {
	int draw_stamp;
	int read_stamp;
    } dri2;
};

/**
 * Per-drawable private DRI driver information.
 */
struct __DRIdrawableRec {
    /**
     * Driver's private drawable information.
     *
     * This structure is opaque.
     */
    void *driverPrivate;

    /**
     * Private data from the loader.  We just hold on to it and pass
     * it back when calling into loader provided functions.
     */
    void *loaderPrivate;

    /**
     * Pointer to context to which this drawable is currently bound.
     */
    __DRIcontext *driContextPriv;

    /**
     * Pointer to screen on which this drawable was created.
     */
    __DRIscreen *driScreenPriv;

    /**
     * Reference count for number of context's currently bound to this
     * drawable.
     *
     * Once it reaches zero, the drawable can be destroyed.
     *
     * \note This behavior will change with GLX 1.3.
     */
    int refcount;

    /**
     * Last value of the stamp.
     *
     * If this differs from the value stored at __DRIdrawable::dri2.stamp,
     * then the drawable information has been modified by the X server, and the
     * drawable information (below) should be retrieved from the X server.
     */
    unsigned int lastStamp;

    int w, h;

    /**
     * Drawable timestamp.  Increased when the loader calls invalidate.
     */
    struct {
	unsigned int stamp;
    } dri2;
};

extern uint32_t
driGLFormatToImageFormat(mesa_format format);

extern mesa_format
driImageFormatToGLFormat(uint32_t image_format);

extern void
dri2InvalidateDrawable(__DRIdrawable *drawable);

extern void
driUpdateFramebufferSize(struct gl_context *ctx, const __DRIdrawable *dPriv);

extern void
driContextSetFlags(struct gl_context *ctx, uint32_t flags);

extern const __DRIimageDriverExtension driImageDriverExtension;

#endif /* _DRI_UTIL_H_ */
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.8
log
@Merge Mesa 9.2.0
@
text
@d60 1
d69 1
a69 1

d91 1
d118 3
d124 1
a124 1

d131 6
d165 5
d177 3
a179 3
	__DRIdri2LoaderExtension *loader;
	__DRIimageLookupExtension *image;
	__DRIuseInvalidateExtension *useInvalidate;
d182 4
d283 6
d294 5
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d47 6
d57 2
a58 3
#include <drm.h>
#include <drm_sarea.h>
#include <xf86drm.h>
a59 7
#include "main/glheader.h"
#include "main/mtypes.h"
#include "GL/internal/dri_interface.h"

#define GLX_BAD_CONTEXT                    5

typedef struct __DRIswapInfoRec        __DRIswapInfo;
a63 1
extern const __DRIlegacyExtension driLegacyExtension;
d65 1
a66 4
extern const __DRIextension driReadDrawableExtension;
extern const __DRIcopySubBufferExtension driCopySubBufferExtension;
extern const __DRIswapControlExtension driSwapControlExtension;
extern const __DRImediaStreamCounterExtension driMediaStreamCounterExtension;
a69 54
 * Used by DRI_VALIDATE_DRAWABLE_INFO
 */
#define DRI_VALIDATE_DRAWABLE_INFO_ONCE(pDrawPriv)              \
    do {                                                        \
	if (*(pDrawPriv->pStamp) != pDrawPriv->lastStamp) {     \
	    __driUtilUpdateDrawableInfo(pDrawPriv);             \
	}                                                       \
    } while (0)


/**
 * Utility macro to validate the drawable information.
 *
 * See __DRIdrawable::pStamp and __DRIdrawable::lastStamp.
 */
#define DRI_VALIDATE_DRAWABLE_INFO(psp, pdp)                            \
do {                                                                    \
    while (*(pdp->pStamp) != pdp->lastStamp) {                          \
        register unsigned int hwContext = psp->pSAREA->lock.lock &      \
		     ~(DRM_LOCK_HELD | DRM_LOCK_CONT);                  \
	DRM_UNLOCK(psp->fd, &psp->pSAREA->lock, hwContext);             \
                                                                        \
	DRM_SPINLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);     \
	DRI_VALIDATE_DRAWABLE_INFO_ONCE(pdp);                           \
	DRM_SPINUNLOCK(&psp->pSAREA->drawable_lock, psp->drawLockID);   \
                                                                        \
	DRM_LIGHT_LOCK(psp->fd, &psp->pSAREA->lock, hwContext);         \
    }                                                                   \
} while (0)

/**
 * Same as above, but for two drawables simultaneously.
 *
 */

#define DRI_VALIDATE_TWO_DRAWABLES_INFO(psp, pdp, prp)			\
do {								\
    while (*((pdp)->pStamp) != (pdp)->lastStamp ||			\
	   *((prp)->pStamp) != (prp)->lastStamp) {			\
        register unsigned int hwContext = (psp)->pSAREA->lock.lock &	\
	    ~(DRM_LOCK_HELD | DRM_LOCK_CONT);				\
	DRM_UNLOCK((psp)->fd, &(psp)->pSAREA->lock, hwContext);		\
									\
	DRM_SPINLOCK(&(psp)->pSAREA->drawable_lock, (psp)->drawLockID);	\
	DRI_VALIDATE_DRAWABLE_INFO_ONCE(pdp);                           \
	DRI_VALIDATE_DRAWABLE_INFO_ONCE(prp);				\
	DRM_SPINUNLOCK(&(psp)->pSAREA->drawable_lock, (psp)->drawLockID); \
									\
	DRM_LIGHT_LOCK((psp)->fd, &(psp)->pSAREA->lock, hwContext);	\
    }                                                                   \
} while (0)


/**
a81 3
    /**
     * Screen destruction callback
     */
a83 3
    /**
     * Context creation callback
     */	    	    
d85 6
a90 2
			       const struct gl_config *glVis,
			       __DRIcontext *driContextPriv,
a92 3
    /**
     * Context destruction callback
     */
a94 3
    /**
     * Buffer (drawable) creation callback
     */
d99 1
a99 4
    
    /**
     * Buffer (drawable) destruction callback
     */
a101 3
    /**
     * Buffer swapping callback 
     */
a103 3
    /**
     * Context activation callback
     */
a107 3
    /**
     * Context unbinding callback
     */
a108 33
  
    /**
     * Retrieves statistics about buffer swap operations.  Required if
     * GLX_OML_sync_control or GLX_MESA_swap_frame_usage is supported.
     */
    int (*GetSwapInfo)( __DRIdrawable *dPriv, __DRIswapInfo * sInfo );


    /**
     * These are required if GLX_OML_sync_control is supported.
     */
    /*@@{*/
    int (*WaitForMSC)( __DRIdrawable *priv, int64_t target_msc, 
		       int64_t divisor, int64_t remainder,
		       int64_t * msc );
    int (*WaitForSBC)( __DRIdrawable *priv, int64_t target_sbc,
		       int64_t * msc, int64_t * sbc );

    int64_t (*SwapBuffersMSC)( __DRIdrawable *priv, int64_t target_msc,
			       int64_t divisor, int64_t remainder );
    /*@@}*/
    void (*CopySubBuffer)(__DRIdrawable *driDrawPriv,
			  int x, int y, int w, int h);

    /**
     * New version of GetMSC so we can pass drawable data to the low
     * level DRM driver (e.g. pipe info).  Required if
     * GLX_SGI_video_sync or GLX_OML_sync_control is supported.
     */
    int (*GetDrawableMSC) ( __DRIscreen * priv,
			    __DRIdrawable *drawablePrivate,
			    int64_t *count);

d110 4
a114 7
    /* DRI2 Entry point */
    const __DRIconfig **(*InitScreen2) (__DRIscreen * priv);

    __DRIbuffer *(*AllocateBuffer) (__DRIscreen *screenPrivate,
				    unsigned int attachment,
				    unsigned int format,
				    int width, int height);
d121 4
a124 6
struct __DRIswapInfoRec {
    /** 
     * Number of swapBuffers operations that have been *completed*. 
     */
    uint64_t swap_count;

d126 1
a126 2
     * Unadjusted system time of the last buffer swap.  This is the time
     * when the swap completed, not the time when swapBuffers was called.
d128 1
a128 1
    int64_t   swap_ust;
d131 6
a136 4
     * Number of swap operations that occurred after the swap deadline.  That
     * is if a swap happens more than swap_interval frames after the previous
     * swap, it has missed its deadline.  If swap_interval is 0, then the
     * swap deadline is 1 frame after the previous swap.
d138 1
a138 1
    uint64_t swap_missed_count;
d141 1
a141 5
     * Amount of time used by the last swap that missed its deadline.  This
     * is calculated as (__glXGetUST() - swap_ust) / (swap_interval * 
     * time_for_single_vrefresh)).  If the actual value of swap_interval is
     * 0, then 1 is used instead.  If swap_missed_count is non-zero, this
     * should be greater-than 1.0.
d143 1
a143 3
    float     swap_missed_usage;
};

a144 4
/**
 * Per-drawable private DRI driver information.
 */
struct __DRIdrawableRec {
d146 3
a148 8
     * Kernel drawable handle
     */
    drm_drawable_t hHWDrawable;

    /**
     * Driver's private drawable information.  
     *
     * This structure is opaque.
a151 4
    /**
     * Private data from the loader.  We just hold on to it and pass
     * it back when calling into loader provided functions.
     */
d154 1
a154 9
    /**
     * Reference count for number of context's currently bound to this
     * drawable.  
     *
     * Once it reaches zero, the drawable can be destroyed.
     *
     * \note This behavior will change with GLX 1.3.
     */
    int refcount;
d156 1
a156 4
    /**
     * Index of this drawable information in the SAREA.
     */
    unsigned int index;
d158 7
a164 5
    /**
     * Pointer to the "drawable has changed ID" stamp in the SAREA (or
     * to dri2.stamp if DRI2 is being used).
     */
    unsigned int *pStamp;
d166 2
a167 77
    /**
     * Last value of the stamp.
     *
     * If this differs from the value stored at __DRIdrawable::pStamp,
     * then the drawable information has been modified by the X server, and the
     * drawable information (below) should be retrieved from the X server.
     */
    unsigned int lastStamp;

    /**
     * \name Drawable 
     *
     * Drawable information used in software fallbacks.
     */
    /*@@{*/
    int x;
    int y;
    int w;
    int h;
    int numClipRects;
    drm_clip_rect_t *pClipRects;
    /*@@}*/

    /**
     * \name Back and depthbuffer
     *
     * Information about the back and depthbuffer where different from above.
     */
    /*@@{*/
    int backX;
    int backY;
    int backClipRectType;
    int numBackClipRects;
    drm_clip_rect_t *pBackClipRects;
    /*@@}*/

    /**
     * \name Vertical blank tracking information
     * Used for waiting on vertical blank events.
     */
    /*@@{*/
    unsigned int vblSeq;
    unsigned int vblFlags;
    /*@@}*/

    /**
     * \name Monotonic MSC tracking
     *
     * Low level driver is responsible for updating msc_base and
     * vblSeq values so that higher level code can calculate
     * a new msc value or msc target for a WaitMSC call.  The new value
     * will be:
     *   msc = msc_base + get_vblank_count() - vblank_base;
     *
     * And for waiting on a value, core code will use:
     *   actual_target = target_msc - msc_base + vblank_base;
     */
    /*@@{*/
    int64_t vblank_base;
    int64_t msc_base;
    /*@@}*/

    /**
     * Pointer to context to which this drawable is currently bound.
     */
    __DRIcontext *driContextPriv;

    /**
     * Pointer to screen on which this drawable was created.
     */
    __DRIscreen *driScreenPriv;

    /**
     * Controls swap interval as used by GLX_SGI_swap_control and
     * GLX_MESA_swap_control.
     */
    unsigned int swap_interval;
d169 1
a169 4
    struct {
	unsigned int stamp;
	drm_clip_rect_t clipRect;
    } dri2;
d177 1
a177 1
     * Kernel context handle used to access the device lock.
d179 1
a179 1
    drm_context_t hHWContext;
d182 1
a182 1
     * Device driver's private context data.  This structure is opaque.
d184 1
a184 1
    void *driverPrivate;
a200 5
    /**
     * The loaders's private context data.  This structure is opaque.
     */
    void *loaderPrivate;

d208 1
a208 1
 * Per-screen private driver information.
d210 1
a210 1
struct __DRIscreenRec {
d212 3
a214 1
     * Current screen's number
d216 1
a216 1
    int myNum;
d219 2
a220 1
     * Callback functions into the hardware-specific DRI driver code.
d222 1
a222 1
    struct __DriverAPIRec DriverAPI;
a223 1
    const __DRIextension **extensions;
d225 1
a225 1
     * DDX / 2D driver version information.
d227 1
a227 1
    __DRIversion ddx_version;
d230 1
a230 1
     * DRI X extension version information.
d232 1
a232 1
    __DRIversion dri_version;
d235 4
a238 6
     * DRM (kernel module) version information.
     */
    __DRIversion drm_version;

    /**
     * ID used when the client sets the drawable lock.
d240 1
a240 2
     * The X server uses this value to detect if the client has died while
     * holding the drawable lock.
d242 1
a242 1
    int drawLockID;
d245 1
a245 11
     * File descriptor returned when the kernel device driver is opened.
     * 
     * Used to:
     *   - authenticate client to kernel
     *   - map the frame buffer, SAREA, etc.
     *   - close the kernel device driver
     */
    int fd;

    /**
     * SAREA pointer 
d247 3
a249 3
     * Used to access:
     *   - the device lock
     *   - the device-independent per-drawable and per-context(?) information
d251 1
a251 1
    drm_sarea_t *pSAREA;
d253 1
a253 23
    /**
     * \name Direct frame buffer access information 
     * Used for software fallbacks.
     */
    /*@@{*/
    unsigned char *pFB;
    int fbSize;
    int fbOrigin;
    int fbStride;
    int fbWidth;
    int fbHeight;
    int fbBPP;
    /*@@}*/

    /**
     * \name Device-dependent private information (stored in the SAREA).
     *
     * This data is accessed by the client driver only.
     */
    /*@@{*/
    void *pDevPriv;
    int devPrivSize;
    /*@@}*/
d256 1
a256 3
     * Device-dependent private information (not stored in the SAREA).
     * 
     * This pointer is never touched by the DRI layer.
a257 11
#ifdef __cplusplus
    void *priv;
#else
    void *private;
#endif

    /* Extensions provided by the loader. */
    const __DRIgetDrawableInfoExtension *getDrawableInfo;
    const __DRIsystemTimeExtension *systemTime;
    const __DRIdamageExtension *damage;

d259 1
a259 6
	/* Flag to indicate that this is a DRI2 screen.  Many of the above
	 * fields will not be valid or initializaed in that case. */
	int enabled;
	__DRIdri2LoaderExtension *loader;
	__DRIimageLookupExtension *image;
	__DRIuseInvalidateExtension *useInvalidate;
a260 8

    /* The lock actually in use, old sarea or DRI2 */
    drmLock *lock;

    driOptionCache optionInfo;
    driOptionCache optionCache;
   unsigned int api_mask;
   void *loaderPrivate;
d264 1
a264 8
__driUtilUpdateDrawableInfo(__DRIdrawable *pdp);

extern float
driCalculateSwapUsage( __DRIdrawable *dPriv,
		       int64_t last_swap_ust, int64_t current_ust );

extern GLint
driIntersectArea( drm_clip_rect_t rect1, drm_clip_rect_t rect2 );
d267 1
a267 1
dri2InvalidateDrawable(__DRIdrawable *drawable);
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d226 6
@


1.5
log
@Two patches cherry picked from mesa master just after 7.8 was branched
(but never made it into the 7.8 branch).

first:
Author: Jesse Barnes <jbarnes@@virtuousgeek.org>
Date:   Thu Apr 22 12:47:41 2010 -0700

    DRI2: add config query extension

    Add a new DRI2 configuration query extension.  Allows for DRI2
    client code to query for common DRI2 configuration options.

second:
Author: Jesse Barnes <jbarnes@@virtuousgeek.org>
Date:   Thu Apr 22 12:49:03 2010 -0700

    DRI2/GLX: check for vblank_mode in DRI2 GLX code

    Re-add support for the vblank_mode environment and configuration
    variable.  Useful for benchmarking and app control.

The final affect being that config and environment variables for
controlling swap mode work with dri2 now. which helps me a lot with
debugging.

ok matthieu@@.
@
text
@d56 1
a56 1
#include "GL/internal/glcore.h"
a71 1
extern const __DRIframeTrackingExtension driFrameTrackingExtension;
d150 3
a152 2
    GLboolean (*CreateContext)(const __GLcontextModes *glVis,
                               __DRIcontext *driContextPriv,
d165 1
a165 1
                              const __GLcontextModes *glVis,
a403 5
     * Pointer back to the \c __DRIcontext that contains this structure.
     */
    __DRIcontext *pctx;

    /**
a510 12
     * Dummy context to which drawables are bound when not bound to any
     * other context. 
     *
     * A dummy hHWContext is created for this context, and is used by the GL
     * core when a hardware lock is required but the drawable is not currently
     * bound (e.g., potentially during a SwapBuffers request).  The dummy
     * context is created when the first "real" context is created on this
     * screen.
     */
    __DRIcontext dummyContextPriv;

    /**
d515 3
d519 1
a519 5

    /**
     * Pointer back to the \c __DRIscreen that contains this structure.
     */
    __DRIscreen *psc;
d532 1
d538 1
d540 2
a542 4

extern void
__driUtilMessage(const char *f, ...);

@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d54 1
d74 1
d554 2
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a0 22
/* $XFree86: xc/lib/GL/dri/dri_util.h,v 1.1 2002/02/22 21:32:52 dawes Exp $ */
/**
 * \file dri_util.h
 * DRI utility functions definitions.
 *
 * This module acts as glue between GLX and the actual hardware driver.  A DRI
 * driver doesn't really \e have to use any of this - it's optional.  But, some
 * useful stuff is done here that otherwise would have to be duplicated in most
 * drivers.
 * 
 * Basically, these utility functions take care of some of the dirty details of
 * screen initialization, context creation, context binding, DRM setup, etc.
 *
 * These functions are compiled into each DRI driver so libGL.so knows nothing
 * about them.
 *
 * \sa dri_util.c.
 * 
 * \author Kevin E. Martin <kevin@@precisioninsight.com>
 * \author Brian Paul <brian@@precisioninsight.com>
 */

d26 20
a61 5
/* Typedefs to avoid rewriting the world. */
typedef struct __DRIscreenRec	__DRIscreenPrivate;
typedef struct __DRIdrawableRec	__DRIdrawablePrivate;
typedef struct __DRIcontextRec	__DRIcontextPrivate;

d67 1
d298 2
a299 1
     * Pointer to the "drawable has changed ID" stamp in the SAREA.
d380 5
d420 10
d547 1
d567 3
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d56 1
a56 1
#include "glheader.h"
a58 1
#include "GL/internal/dri_sarea.h"
d111 22
d228 1
a228 1
    /* DRI2 Entry points */
a229 8
    void (*HandleDrawableConfig)(__DRIdrawable *dPriv,
				__DRIcontext *pcp,
				__DRIDrawableConfigEvent *event);

    void (*HandleBufferAttach)(__DRIdrawable *dPriv,
			       __DRIcontext *pcp,
			       __DRIBufferAttachEvent *ba);

d239 1
a239 1
    u_int64_t swap_count;
d253 1
a253 1
    u_int64_t swap_missed_count;
a384 4
    struct {
	unsigned int tail;
	unsigned int drawable_id;
    } dri2;
d536 1
a536 7
#ifdef TTM_API
	drmBO sareaBO;
#endif
	void *sarea;
	__DRIEventBuffer *buffer;
	__DRILock *lock;
	__DRIloaderExtension *loader;
a548 3

extern int
__driParseEvents(__DRIcontext *psp, __DRIdrawable *pdp);
@


1.1
log
@Initial revision
@
text
@a51 2
#define CAPI  /* XXX this should be globally defined somewhere */

d53 4
a56 3
#include "drm.h"
#include "drm_sarea.h"
#include "xf86drm.h"
d59 1
a62 4
typedef struct __DRIdisplayPrivateRec  __DRIdisplayPrivate;
typedef struct __DRIscreenPrivateRec   __DRIscreenPrivate;
typedef struct __DRIcontextPrivateRec  __DRIcontextPrivate;
typedef struct __DRIdrawablePrivateRec __DRIdrawablePrivate;
a63 1
typedef struct __DRIutilversionRec2    __DRIutilversion2;
d65 15
d95 1
a95 1
 * See __DRIdrawablePrivate::pStamp and __DRIdrawablePrivate::lastStamp.
d100 3
a102 2
	DRM_UNLOCK(psp->fd, &psp->pSAREA->lock,                         \
		   pdp->driContextPriv->hHWContext);                    \
d108 1
a108 2
	DRM_LIGHT_LOCK(psp->fd, &psp->pSAREA->lock,                     \
		       pdp->driContextPriv->hHWContext);                \
d124 2
a125 5
    /** 
     * Driver initialization callback
     */
    GLboolean (*InitDriver)(__DRIscreenPrivate *driScrnPriv);
    
d129 1
a129 1
    void (*DestroyScreen)(__DRIscreenPrivate *driScrnPriv);
d135 1
a135 1
                               __DRIcontextPrivate *driContextPriv,
d141 1
a141 1
    void (*DestroyContext)(__DRIcontextPrivate *driContextPriv);
d146 2
a147 2
    GLboolean (*CreateBuffer)(__DRIscreenPrivate *driScrnPriv,
                              __DRIdrawablePrivate *driDrawPriv,
d154 1
a154 1
    void (*DestroyBuffer)(__DRIdrawablePrivate *driDrawPriv);
d159 1
a159 1
    void (*SwapBuffers)(__DRIdrawablePrivate *driDrawPriv);
d164 3
a166 3
    GLboolean (*MakeCurrent)(__DRIcontextPrivate *driContextPriv,
                             __DRIdrawablePrivate *driDrawPriv,
                             __DRIdrawablePrivate *driReadPriv);
d171 1
a171 1
    GLboolean (*UnbindContext)(__DRIcontextPrivate *driContextPriv);
d177 1
a177 2
    int (*GetSwapInfo)( __DRIdrawablePrivate *dPriv, __DRIswapInfo * sInfo );

a178 5
    /**
     * Required if GLX_SGI_video_sync or GLX_OML_sync_control is
     * supported.
     */
    int (*GetMSC)( __DRIscreenPrivate * priv, int64_t * count );
d184 1
a184 1
    int (*WaitForMSC)( __DRIdrawablePrivate *priv, int64_t target_msc, 
d187 1
a187 1
    int (*WaitForSBC)( __DRIdrawablePrivate *priv, int64_t target_sbc,
d190 1
a190 1
    int64_t (*SwapBuffersMSC)( __DRIdrawablePrivate *priv, int64_t target_msc,
d193 1
a193 1
    void (*CopySubBuffer)(__DRIdrawablePrivate *driDrawPriv,
d195 22
d219 2
d256 1
a256 1
struct __DRIdrawablePrivateRec {
d270 2
a271 1
     * X's drawable ID associated with this private drawable.
d273 1
a273 2
    __DRIid draw;
    __DRIdrawable *pdraw;
d298 1
a298 1
     * If this differs from the value stored at __DRIdrawablePrivate::pStamp,
d332 19
a350 1
     * Pointer to context to which this drawable is currently bound.
d352 4
a355 1
    __DRIcontextPrivate *driContextPriv;
d358 1
a358 1
     * Pointer to screen on which this drawable was created.
d360 1
a360 1
    __DRIscreenPrivate *driScreenPriv;
d363 1
a363 4
     * \name Display and screen information.
     * 
     * Basically just need these for when the locking code needs to call
     * \c __driUtilUpdateDrawableInfo.
d365 1
a365 4
    /*@@{*/
    __DRInativeDisplay *display;
    int screen;
    /*@@}*/
d368 2
a369 1
     * Called via glXSwapBuffers().
d371 5
a375 1
    void (*swapBuffers)( __DRIdrawablePrivate *dPriv );
d381 1
a381 1
struct __DRIcontextPrivateRec {
d385 1
a385 1
    __DRIid contextID;
d388 1
a388 1
     * Kernel context handle used to access the device lock.
d390 1
a390 1
    drm_context_t hHWContext;
d393 1
a393 1
     * Device driver's private context data.  This structure is opaque.
d395 1
a395 1
    void *driverPrivate;
d398 1
a398 1
     * This context's display pointer.
d400 1
a400 1
    __DRInativeDisplay *display;
d403 1
a403 1
     * Pointer to drawable currently bound to this context.
d405 1
a405 1
    __DRIdrawablePrivate *driDrawablePriv;
d410 1
a410 1
    __DRIscreenPrivate *driScreenPriv;
d416 1
a416 6
struct __DRIscreenPrivateRec {
    /**
     * Display for this screen
     */
    __DRInativeDisplay *display;

d427 1
a428 1
     * \name DDX version
a429 1
     * \todo Replace these fields with a \c __DRIversionRec.
d431 1
a431 5
    /*@@{*/
    int ddxMajor;
    int ddxMinor;
    int ddxPatch;
    /*@@}*/
a433 1
     * \name DRI version
a434 1
     * \todo Replace these fields with a \c __DRIversionRec.
d436 1
a436 5
    /*@@{*/
    int driMajor;
    int driMinor;
    int driPatch;
    /*@@}*/
a438 1
     * \name DRM version
a439 1
     * \todo Replace these fields with a \c __DRIversionRec.
d441 1
a441 5
    /*@@{*/
    int drmMajor;
    int drmMinor;
    int drmPatch;
    /*@@}*/
d504 1
a504 6
    __DRIcontextPrivate dummyContextPriv;

    /**
     * Hash table to hold the drawable information for this screen.
     */
    void *drawHash;
a513 11
     * GLX visuals / FBConfigs for this screen.  These are stored as a
     * linked list.
     * 
     * \note
     * This field is \b only used in conjunction with the old interfaces.  If
     * the new interfaces are used, this field will be set to \c NULL and will
     * not be dereferenced.
     */
    __GLcontextModes *modes;

    /**
a515 1

a516 1
};
d518 17
d536 2
a537 9
/**
 * Used to store a version which includes a major range instead of a single
 * major version number.
 */
struct __DRIutilversionRec2 {
    int    major_min;    /** min allowed Major version number. */
    int    major_max;    /** max allowed Major version number. */
    int    minor;        /**< Minor version number. */
    int    patch;        /**< Patch-level. */
a539 1

d545 1
a545 2
__driUtilUpdateDrawableInfo(__DRIdrawablePrivate *pdp);

a546 8
extern __DRIscreenPrivate * __driUtilCreateNewScreen( __DRInativeDisplay *dpy,
    int scrn, __DRIscreen *psc, __GLcontextModes * modes,
    const __DRIversion * ddx_version, const __DRIversion * dri_version,
    const __DRIversion * drm_version, const __DRIframebuffer * frame_buffer,
    drm_sarea_t *pSAREA, int fd, int internal_api_version,
    const struct __DriverAPIRec *driverAPI );

/* Test the version of the internal GLX API.  Returns a value like strcmp. */
d548 1
a548 1
driCompareGLXAPIVersion( GLint required_version );
d551 1
a551 1
driCalculateSwapUsage( __DRIdrawablePrivate *dPriv,
d554 2
a555 7
/**
 * Pointer to the \c __DRIinterfaceMethods passed to the driver by the loader.
 * 
 * This pointer is set in the driver's \c __driCreateNewScreen function and
 * is defined in dri_util.c.
 */
extern const __DRIinterfaceMethods * dri_interface;
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d90 2
a91 3
        register unsigned int hwContext = psp->pSAREA->lock.lock &      \
		     ~(DRM_LOCK_HELD | DRM_LOCK_CONT);                  \
	DRM_UNLOCK(psp->fd, &psp->pSAREA->lock, hwContext);             \
d97 2
a98 1
	DRM_LIGHT_LOCK(psp->fd, &psp->pSAREA->lock, hwContext);         \
d358 1
a358 1
     * Pointer to drawable currently bound to this context for drawing.
a360 5

    /**
     * Pointer to drawable currently bound to this context for reading.
     */
    __DRIdrawablePrivate *driReadablePriv;
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d52 2
a193 6

    /**
     * See corresponding field in \c __DRIscreenRec.
     */
    void (*setTexOffset)(__DRIcontext *pDRICtx, GLint texname,
			 unsigned long long offset, GLint depth, GLuint pitch);
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d1 22
a47 20
/**
 * \file dri_util.h
 * DRI utility functions definitions.
 *
 * This module acts as glue between GLX and the actual hardware driver.  A DRI
 * driver doesn't really \e have to use any of this - it's optional.  But, some
 * useful stuff is done here that otherwise would have to be duplicated in most
 * drivers.
 * 
 * Basically, these utility functions take care of some of the dirty details of
 * screen initialization, context creation, context binding, DRM setup, etc.
 *
 * These functions are compiled into each DRI driver so libGL.so knows nothing
 * about them.
 *
 * \sa dri_util.c.
 * 
 * \author Kevin E. Martin <kevin@@precisioninsight.com>
 * \author Brian Paul <brian@@precisioninsight.com>
 */
d53 4
a56 6
#include <drm.h>
#include <drm_sarea.h>
#include <xf86drm.h>
#include "xmlconfig.h"
#include "main/glheader.h"
#include "main/mtypes.h"
d61 4
d66 1
a67 11
/**
 * Extensions.
 */
extern const __DRIlegacyExtension driLegacyExtension;
extern const __DRIcoreExtension driCoreExtension;
extern const __DRIdri2Extension driDRI2Extension;
extern const __DRIextension driReadDrawableExtension;
extern const __DRIcopySubBufferExtension driCopySubBufferExtension;
extern const __DRIswapControlExtension driSwapControlExtension;
extern const __DRImediaStreamCounterExtension driMediaStreamCounterExtension;
extern const __DRI2configQueryExtension dri2ConfigQueryExtension;
d83 1
a83 1
 * See __DRIdrawable::pStamp and __DRIdrawable::lastStamp.
a99 22
/**
 * Same as above, but for two drawables simultaneously.
 *
 */

#define DRI_VALIDATE_TWO_DRAWABLES_INFO(psp, pdp, prp)			\
do {								\
    while (*((pdp)->pStamp) != (pdp)->lastStamp ||			\
	   *((prp)->pStamp) != (prp)->lastStamp) {			\
        register unsigned int hwContext = (psp)->pSAREA->lock.lock &	\
	    ~(DRM_LOCK_HELD | DRM_LOCK_CONT);				\
	DRM_UNLOCK((psp)->fd, &(psp)->pSAREA->lock, hwContext);		\
									\
	DRM_SPINLOCK(&(psp)->pSAREA->drawable_lock, (psp)->drawLockID);	\
	DRI_VALIDATE_DRAWABLE_INFO_ONCE(pdp);                           \
	DRI_VALIDATE_DRAWABLE_INFO_ONCE(prp);				\
	DRM_SPINUNLOCK(&(psp)->pSAREA->drawable_lock, (psp)->drawLockID); \
									\
	DRM_LIGHT_LOCK((psp)->fd, &(psp)->pSAREA->lock, hwContext);	\
    }                                                                   \
} while (0)

d112 5
a116 2
    const __DRIconfig **(*InitScreen) (__DRIscreen * priv);

d120 1
a120 1
    void (*DestroyScreen)(__DRIscreen *driScrnPriv);
d125 2
a126 3
    GLboolean (*CreateContext)(gl_api api,
			       const struct gl_config *glVis,
			       __DRIcontext *driContextPriv,
d132 1
a132 1
    void (*DestroyContext)(__DRIcontext *driContextPriv);
d137 3
a139 3
    GLboolean (*CreateBuffer)(__DRIscreen *driScrnPriv,
                              __DRIdrawable *driDrawPriv,
                              const struct gl_config *glVis,
d145 1
a145 1
    void (*DestroyBuffer)(__DRIdrawable *driDrawPriv);
d150 1
a150 1
    void (*SwapBuffers)(__DRIdrawable *driDrawPriv);
d155 3
a157 3
    GLboolean (*MakeCurrent)(__DRIcontext *driContextPriv,
                             __DRIdrawable *driDrawPriv,
                             __DRIdrawable *driReadPriv);
d162 1
a162 1
    GLboolean (*UnbindContext)(__DRIcontext *driContextPriv);
d168 1
a168 1
    int (*GetSwapInfo)( __DRIdrawable *dPriv, __DRIswapInfo * sInfo );
d172 6
d181 1
a181 1
    int (*WaitForMSC)( __DRIdrawable *priv, int64_t target_msc, 
d184 1
a184 1
    int (*WaitForSBC)( __DRIdrawable *priv, int64_t target_sbc,
d187 1
a187 1
    int64_t (*SwapBuffersMSC)( __DRIdrawable *priv, int64_t target_msc,
d190 1
a190 1
    void (*CopySubBuffer)(__DRIdrawable *driDrawPriv,
d194 1
a194 3
     * New version of GetMSC so we can pass drawable data to the low
     * level DRM driver (e.g. pipe info).  Required if
     * GLX_SGI_video_sync or GLX_OML_sync_control is supported.
d196 2
a197 8
    int (*GetDrawableMSC) ( __DRIscreen * priv,
			    __DRIdrawable *drawablePrivate,
			    int64_t *count);



    /* DRI2 Entry point */
    const __DRIconfig **(*InitScreen2) (__DRIscreen * priv);
a199 2
extern const struct __DriverAPIRec driDriverAPI;

d205 1
a205 1
    uint64_t swap_count;
d219 1
a219 1
    uint64_t swap_missed_count;
d235 1
a235 1
struct __DRIdrawableRec {
d249 1
a249 2
     * Private data from the loader.  We just hold on to it and pass
     * it back when calling into loader provided functions.
d251 2
a252 1
    void *loaderPrivate;
d270 1
a270 2
     * Pointer to the "drawable has changed ID" stamp in the SAREA (or
     * to dri2.stamp if DRI2 is being used).
d277 1
a277 1
     * If this differs from the value stored at __DRIdrawable::pStamp,
d311 1
a311 2
     * \name Vertical blank tracking information
     * Used for waiting on vertical blank events.
d313 1
a313 4
    /*@@{*/
    unsigned int vblSeq;
    unsigned int vblFlags;
    /*@@}*/
d316 1
a316 10
     * \name Monotonic MSC tracking
     *
     * Low level driver is responsible for updating msc_base and
     * vblSeq values so that higher level code can calculate
     * a new msc value or msc target for a WaitMSC call.  The new value
     * will be:
     *   msc = msc_base + get_vblank_count() - vblank_base;
     *
     * And for waiting on a value, core code will use:
     *   actual_target = target_msc - msc_base + vblank_base;
d318 1
a318 4
    /*@@{*/
    int64_t vblank_base;
    int64_t msc_base;
    /*@@}*/
d321 4
a324 1
     * Pointer to context to which this drawable is currently bound.
d326 4
a329 6
    __DRIcontext *driContextPriv;

    /**
     * Pointer to screen on which this drawable was created.
     */
    __DRIscreen *driScreenPriv;
d332 1
a332 2
     * Controls swap interval as used by GLX_SGI_swap_control and
     * GLX_MESA_swap_control.
d334 1
a334 6
    unsigned int swap_interval;

    struct {
	unsigned int stamp;
	drm_clip_rect_t clipRect;
    } dri2;
d340 6
a345 1
struct __DRIcontextRec {
d357 5
d364 1
a364 1
    __DRIdrawable *driDrawablePriv;
d369 1
a369 1
    __DRIdrawable *driReadablePriv;
d374 1
a374 11
    __DRIscreen *driScreenPriv;

    /**
     * The loaders's private context data.  This structure is opaque.
     */
    void *loaderPrivate;

    struct {
	int draw_stamp;
	int read_stamp;
    } dri2;
d380 6
a385 1
struct __DRIscreenRec {
a395 1
    const __DRIextension **extensions;
d397 1
d399 1
d401 5
a405 1
    __DRIversion ddx_version;
d408 1
d410 1
d412 5
a416 1
    __DRIversion dri_version;
d419 1
d421 1
d423 5
a427 1
    __DRIversion drm_version;
d481 17
a501 3
#ifdef __cplusplus
    void *priv;
#else
a502 1
#endif
d504 16
a519 21
    /* Extensions provided by the loader. */
    const __DRIgetDrawableInfoExtension *getDrawableInfo;
    const __DRIsystemTimeExtension *systemTime;
    const __DRIdamageExtension *damage;

    struct {
	/* Flag to indicate that this is a DRI2 screen.  Many of the above
	 * fields will not be valid or initializaed in that case. */
	int enabled;
	__DRIdri2LoaderExtension *loader;
	__DRIimageLookupExtension *image;
	__DRIuseInvalidateExtension *useInvalidate;
    } dri2;

    /* The lock actually in use, old sarea or DRI2 */
    drmLock *lock;

    driOptionCache optionInfo;
    driOptionCache optionCache;
   unsigned int api_mask;
   void *loaderPrivate;
d522 17
d540 13
a552 1
__driUtilUpdateDrawableInfo(__DRIdrawable *pdp);
d555 1
a555 1
driCalculateSwapUsage( __DRIdrawable *dPriv,
d558 7
a564 5
extern GLint
driIntersectArea( drm_clip_rect_t rect1, drm_clip_rect_t rect2 );

extern void
dri2InvalidateDrawable(__DRIdrawable *drawable);
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@a46 6
/**
 * The following structs are shared between DRISW and DRI2, the DRISW structs
 * are essentially base classes of the DRI2 structs. DRISW needs to compile on
 * platforms without DRM, so keep the structs opaque to DRM.
 */

d51 5
a55 1
#include <GL/internal/dri_interface.h>
d57 5
a61 1
#include "xmlconfig.h"
d66 1
a67 1
extern const __DRIswrastExtension driSWRastExtension;
d69 4
d76 54
d142 3
d147 3
d151 2
a152 6
                               const struct gl_config *glVis,
                               __DRIcontext *driContextPriv,
			       unsigned major_version,
			       unsigned minor_version,
			       uint32_t flags,
			       unsigned *error,
d155 3
d160 3
d167 4
a170 1

d173 3
d178 3
d185 3
d189 6
a195 4
    __DRIbuffer *(*AllocateBuffer) (__DRIscreen *screenPrivate,
                                    unsigned int attachment,
                                    unsigned int format,
                                    int width, int height);
d197 29
a225 1
    void (*ReleaseBuffer) (__DRIscreen *screenPrivate, __DRIbuffer *buffer);
d231 31
d263 1
a263 1
 * Per-screen private driver information.
d265 49
a313 1
struct __DRIscreenRec {
d315 3
a317 1
     * Current screen's number
d319 8
a326 1
    int myNum;
d329 3
a331 6
     * File descriptor returned when the kernel device driver is opened.
     * 
     * Used to:
     *   - authenticate client to kernel
     *   - map the frame buffer, SAREA, etc.
     *   - close the kernel device driver
d333 7
a339 1
    int fd;
d342 2
a343 1
     * DRM (kernel module) version information.
d345 4
a348 1
    __DRIversion drm_version;
d351 10
a360 3
     * Device-dependent private information (not stored in the SAREA).
     * 
     * This pointer is never touched by the DRI layer.
d362 4
a365 1
    void *driverPrivate;
d367 4
a370 1
    void *loaderPrivate;
d372 4
a375 1
    const __DRIextension **extensions;
d377 5
a381 1
    const __DRIswrastLoaderExtension *swrast_loader;
d384 2
a385 5
	/* Flag to indicate that this is a DRI2 screen.  Many of the above
	 * fields will not be valid or initializaed in that case. */
	__DRIdri2LoaderExtension *loader;
	__DRIimageLookupExtension *image;
	__DRIuseInvalidateExtension *useInvalidate;
a386 5

    driOptionCache optionInfo;
    driOptionCache optionCache;

    unsigned int api_mask;
d394 1
a394 1
     * Device driver's private context data.  This structure is opaque.
d396 1
a396 1
    void *driverPrivate;
d399 1
a399 1
     * The loaders's private context data.  This structure is opaque.
d401 1
a401 1
    void *loaderPrivate;
d418 5
d430 1
a430 1
 * Per-drawable private DRI driver information.
d432 6
a437 1
struct __DRIdrawableRec {
d439 1
a439 3
     * Driver's private drawable information.
     *
     * This structure is opaque.
d441 1
a441 1
    void *driverPrivate;
d443 1
d445 1
a445 2
     * Private data from the loader.  We just hold on to it and pass
     * it back when calling into loader provided functions.
d447 1
a447 1
    void *loaderPrivate;
d450 1
a450 1
     * Pointer to context to which this drawable is currently bound.
d452 1
a452 1
    __DRIcontext *driContextPriv;
d455 1
a455 1
     * Pointer to screen on which this drawable was created.
d457 1
a457 1
    __DRIscreen *driScreenPriv;
d460 1
a460 2
     * Reference count for number of context's currently bound to this
     * drawable.
d462 17
a478 1
     * Once it reaches zero, the drawable can be destroyed.
d480 9
a488 1
     * \note This behavior will change with GLX 1.3.
d490 9
a498 1
    int refcount;
d501 1
a501 1
     * Last value of the stamp.
d503 1
a503 3
     * If this differs from the value stored at __DRIdrawable::dri2.stamp,
     * then the drawable information has been modified by the X server, and the
     * drawable information (below) should be retrieved from the X server.
d505 4
a508 3
    unsigned int lastStamp;

    int w, h;
d511 3
a513 1
     * Drawable timestamp.  Increased when the loader calls invalidate.
d515 11
d527 6
a532 1
	unsigned int stamp;
d534 8
d545 8
a552 1
dri2InvalidateDrawable(__DRIdrawable *drawable);
d555 1
a555 1
driUpdateFramebufferSize(struct gl_context *ctx, const __DRIdrawable *dPriv);
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@a59 1
#include <stdbool.h>
d68 1
a68 1
extern const __DRIcopySubBufferExtension driCopySubBufferExtension;
a89 1
                               bool notify_reset,
a115 3

    void (*CopySubBuffer)(__DRIdrawable *driDrawPriv, int x, int y,
                          int w, int h);
d119 1
a119 1
extern const struct __DriverAPIRec *globalDriverAPI;
a125 6
     * Driver-specific entrypoints provided by the driver's
     * __DRIDriverVtableExtensionRec.
     */
    const struct __DriverAPIRec *driver;

    /**
a153 5
    int max_gl_core_version;
    int max_gl_compat_version;
    int max_gl_es1_version;
    int max_gl_es2_version;

d161 3
a163 3
	const __DRIdri2LoaderExtension *loader;
	const __DRIimageLookupExtension *image;
	const __DRIuseInvalidateExtension *useInvalidate;
a165 4
    struct {
        const __DRIimageLoaderExtension *loader;
    } image;

a262 6
extern uint32_t
driGLFormatToImageFormat(mesa_format format);

extern mesa_format
driImageFormatToGLFormat(uint32_t image_format);

a267 5

extern void
driContextSetFlags(struct gl_context *ctx, uint32_t flags);

extern const __DRIimageDriverExtension driImageDriverExtension;
@


