head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.09.05.14.04.29;	author jsg;	state dead;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.38;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@/**************************************************************************
 * 
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/


#include "main/imports.h"
#include "main/mfeatures.h"
#include "main/mtypes.h"
#include "main/macros.h"
#include "main/bufferobj.h"

#include "intel_blit.h"
#include "intel_buffer_objects.h"
#include "intel_batchbuffer.h"
#include "intel_context.h"
#include "intel_fbo.h"
#include "intel_mipmap_tree.h"
#include "intel_regions.h"

static GLboolean
intel_bufferobj_unmap(struct gl_context * ctx,
                      GLenum target, struct gl_buffer_object *obj);

/** Allocates a new drm_intel_bo to store the data for the buffer object. */
static void
intel_bufferobj_alloc_buffer(struct intel_context *intel,
			     struct intel_buffer_object *intel_obj)
{
   intel_obj->buffer = drm_intel_bo_alloc(intel->bufmgr, "bufferobj",
					  intel_obj->Base.Size, 64);
}

static void
release_buffer(struct intel_buffer_object *intel_obj)
{
   drm_intel_bo_unreference(intel_obj->buffer);
   intel_obj->buffer = NULL;
   intel_obj->offset = 0;
   intel_obj->source = 0;
}

/**
 * There is some duplication between mesa's bufferobjects and our
 * bufmgr buffers.  Both have an integer handle and a hashtable to
 * lookup an opaque structure.  It would be nice if the handles and
 * internal structure where somehow shared.
 */
static struct gl_buffer_object *
intel_bufferobj_alloc(struct gl_context * ctx, GLuint name, GLenum target)
{
   struct intel_buffer_object *obj = CALLOC_STRUCT(intel_buffer_object);

   _mesa_initialize_buffer_object(&obj->Base, name, target);

   obj->buffer = NULL;

   return &obj->Base;
}

/* Break the COW tie to the region.  The region gets to keep the data.
 */
void
intel_bufferobj_release_region(struct intel_context *intel,
                               struct intel_buffer_object *intel_obj)
{
   assert(intel_obj->region->buffer == intel_obj->buffer);
   intel_obj->region->pbo = NULL;
   intel_obj->region = NULL;

   release_buffer(intel_obj);
}

/* Break the COW tie to the region.  Both the pbo and the region end
 * up with a copy of the data.
 */
void
intel_bufferobj_cow(struct intel_context *intel,
                    struct intel_buffer_object *intel_obj)
{
   assert(intel_obj->region);
   intel_region_cow(intel, intel_obj->region);
}


/**
 * Deallocate/free a vertex/pixel buffer object.
 * Called via glDeleteBuffersARB().
 */
static void
intel_bufferobj_free(struct gl_context * ctx, struct gl_buffer_object *obj)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_buffer_object *intel_obj = intel_buffer_object(obj);

   assert(intel_obj);

   /* Buffer objects are automatically unmapped when deleting according
    * to the spec, but Mesa doesn't do UnmapBuffer for us at context destroy
    * (though it does if you call glDeleteBuffers)
    */
   if (obj->Pointer)
      intel_bufferobj_unmap(ctx, 0, obj);

   free(intel_obj->sys_buffer);
   if (intel_obj->region) {
      intel_bufferobj_release_region(intel, intel_obj);
   }

   drm_intel_bo_unreference(intel_obj->buffer);
   free(intel_obj);
}



/**
 * Allocate space for and store data in a buffer object.  Any data that was
 * previously stored in the buffer object is lost.  If data is NULL,
 * memory will be allocated, but no copy will occur.
 * Called via ctx->Driver.BufferData().
 * \return GL_TRUE for success, GL_FALSE if out of memory
 */
static GLboolean
intel_bufferobj_data(struct gl_context * ctx,
                     GLenum target,
                     GLsizeiptrARB size,
                     const GLvoid * data,
                     GLenum usage, struct gl_buffer_object *obj)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_buffer_object *intel_obj = intel_buffer_object(obj);

   intel_obj->Base.Size = size;
   intel_obj->Base.Usage = usage;

   assert(!obj->Pointer); /* Mesa should have unmapped it */

   if (intel_obj->region)
      intel_bufferobj_release_region(intel, intel_obj);

   if (intel_obj->buffer != NULL)
      release_buffer(intel_obj);

   free(intel_obj->sys_buffer);
   intel_obj->sys_buffer = NULL;

   if (size != 0) {
      if (usage == GL_DYNAMIC_DRAW
#ifdef I915
	  /* On pre-965, stick VBOs in system memory, as we're always doing
	   * swtnl with their contents anyway.
	   */
	  || target == GL_ARRAY_BUFFER || target == GL_ELEMENT_ARRAY_BUFFER
#endif
	 )
      {
	 intel_obj->sys_buffer = malloc(size);
	 if (intel_obj->sys_buffer != NULL) {
	    if (data != NULL)
	       memcpy(intel_obj->sys_buffer, data, size);
	    return GL_TRUE;
	 }
      }
      intel_bufferobj_alloc_buffer(intel, intel_obj);
      if (!intel_obj->buffer)
         return GL_FALSE;

      if (data != NULL)
	 drm_intel_bo_subdata(intel_obj->buffer, 0, size, data);
   }

   return GL_TRUE;
}


/**
 * Replace data in a subrange of buffer object.  If the data range
 * specified by size + offset extends beyond the end of the buffer or
 * if data is NULL, no copy is performed.
 * Called via glBufferSubDataARB().
 */
static void
intel_bufferobj_subdata(struct gl_context * ctx,
                        GLenum target,
                        GLintptrARB offset,
                        GLsizeiptrARB size,
                        const GLvoid * data, struct gl_buffer_object *obj)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_buffer_object *intel_obj = intel_buffer_object(obj);
   bool busy;

   if (size == 0)
      return;

   assert(intel_obj);

   if (intel_obj->region)
      intel_bufferobj_cow(intel, intel_obj);

   /* If we have a single copy in system memory, update that */
   if (intel_obj->sys_buffer) {
      if (intel_obj->source)
	 release_buffer(intel_obj);

      if (intel_obj->buffer == NULL) {
	 memcpy((char *)intel_obj->sys_buffer + offset, data, size);
	 return;
      }

      free(intel_obj->sys_buffer);
      intel_obj->sys_buffer = NULL;
   }

   /* Otherwise we need to update the copy in video memory. */
   busy =
      drm_intel_bo_busy(intel_obj->buffer) ||
      drm_intel_bo_references(intel->batch.bo, intel_obj->buffer);

   /* replace the current busy bo with fresh data */
   if (busy && size == intel_obj->Base.Size) {
      drm_intel_bo_unreference(intel_obj->buffer);
      intel_bufferobj_alloc_buffer(intel, intel_obj);
      drm_intel_bo_subdata(intel_obj->buffer, 0, size, data);
   } else if (intel->gen < 6) {
      if (busy) {
	 drm_intel_bo *temp_bo;

	 temp_bo = drm_intel_bo_alloc(intel->bufmgr, "subdata temp", size, 64);

	 drm_intel_bo_subdata(temp_bo, 0, size, data);

	 intel_emit_linear_blit(intel,
				intel_obj->buffer, offset,
				temp_bo, 0,
				size);

	 drm_intel_bo_unreference(temp_bo);
      } else {
	 drm_intel_bo_subdata(intel_obj->buffer, offset, size, data);
      }
   } else {
      /* Can't use the blit to modify the buffer in the middle of batch. */
      if (drm_intel_bo_references(intel->batch.bo, intel_obj->buffer)) {
	 intel_batchbuffer_flush(intel);
      }
      drm_intel_bo_subdata(intel_obj->buffer, offset, size, data);
   }
}


/**
 * Called via glGetBufferSubDataARB().
 */
static void
intel_bufferobj_get_subdata(struct gl_context * ctx,
                            GLenum target,
                            GLintptrARB offset,
                            GLsizeiptrARB size,
                            GLvoid * data, struct gl_buffer_object *obj)
{
   struct intel_buffer_object *intel_obj = intel_buffer_object(obj);
   struct intel_context *intel = intel_context(ctx);

   assert(intel_obj);
   if (intel_obj->sys_buffer)
      memcpy(data, (char *)intel_obj->sys_buffer + offset, size);
   else {
      if (drm_intel_bo_references(intel->batch.bo, intel_obj->buffer)) {
	 intel_batchbuffer_flush(intel);
      }
      drm_intel_bo_get_subdata(intel_obj->buffer, offset, size, data);
   }
}



/**
 * Called via glMapBufferARB().
 */
static void *
intel_bufferobj_map(struct gl_context * ctx,
                    GLenum target,
                    GLenum access, struct gl_buffer_object *obj)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_buffer_object *intel_obj = intel_buffer_object(obj);
   GLboolean read_only = (access == GL_READ_ONLY_ARB);
   GLboolean write_only = (access == GL_WRITE_ONLY_ARB);

   assert(intel_obj);

   if (intel_obj->sys_buffer) {
      if (!read_only && intel_obj->source) {
	 release_buffer(intel_obj);
      }

      if (!intel_obj->buffer || intel_obj->source) {
	 obj->Pointer = intel_obj->sys_buffer;
	 obj->Length = obj->Size;
	 obj->Offset = 0;
	 return obj->Pointer;
      }

      free(intel_obj->sys_buffer);
      intel_obj->sys_buffer = NULL;
   }

   /* Flush any existing batchbuffer that might reference this data. */
   if (drm_intel_bo_references(intel->batch.bo, intel_obj->buffer))
      intel_flush(ctx);

   if (intel_obj->region)
      intel_bufferobj_cow(intel, intel_obj);

   if (intel_obj->buffer == NULL) {
      obj->Pointer = NULL;
      return NULL;
   }

   if (write_only) {
      drm_intel_gem_bo_map_gtt(intel_obj->buffer);
      intel_obj->mapped_gtt = GL_TRUE;
   } else {
      drm_intel_bo_map(intel_obj->buffer, !read_only);
      intel_obj->mapped_gtt = GL_FALSE;
   }

   obj->Pointer = intel_obj->buffer->virtual;
   obj->Length = obj->Size;
   obj->Offset = 0;

   return obj->Pointer;
}

/**
 * Called via glMapBufferRange().
 *
 * The goal of this extension is to allow apps to accumulate their rendering
 * at the same time as they accumulate their buffer object.  Without it,
 * you'd end up blocking on execution of rendering every time you mapped
 * the buffer to put new data in.
 *
 * We support it in 3 ways: If unsynchronized, then don't bother
 * flushing the batchbuffer before mapping the buffer, which can save blocking
 * in many cases.  If we would still block, and they allow the whole buffer
 * to be invalidated, then just allocate a new buffer to replace the old one.
 * If not, and we'd block, and they allow the subrange of the buffer to be
 * invalidated, then we can make a new little BO, let them write into that,
 * and blit it into the real BO at unmap time.
 */
static void *
intel_bufferobj_map_range(struct gl_context * ctx,
			  GLenum target, GLintptr offset, GLsizeiptr length,
			  GLbitfield access, struct gl_buffer_object *obj)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_buffer_object *intel_obj = intel_buffer_object(obj);
   GLboolean read_only = (access == GL_READ_ONLY_ARB);

   assert(intel_obj);

   /* _mesa_MapBufferRange (GL entrypoint) sets these, but the vbo module also
    * internally uses our functions directly.
    */
   obj->Offset = offset;
   obj->Length = length;
   obj->AccessFlags = access;

   if (intel_obj->sys_buffer) {
      if (!read_only && intel_obj->source)
	 release_buffer(intel_obj);

      if (!intel_obj->buffer || intel_obj->source) {
	 obj->Pointer = intel_obj->sys_buffer + offset;
	 return obj->Pointer;
      }

      free(intel_obj->sys_buffer);
      intel_obj->sys_buffer = NULL;
   }

   if (intel_obj->region)
      intel_bufferobj_cow(intel, intel_obj);

   /* If the mapping is synchronized with other GL operations, flush
    * the batchbuffer so that GEM knows about the buffer access for later
    * syncing.
    */
   if (!(access & GL_MAP_UNSYNCHRONIZED_BIT) &&
       drm_intel_bo_references(intel->batch.bo, intel_obj->buffer))
      intel_flush(ctx);

   if (intel_obj->buffer == NULL) {
      obj->Pointer = NULL;
      return NULL;
   }

   /* If the user doesn't care about existing buffer contents and mapping
    * would cause us to block, then throw out the old buffer.
    */
   if (!(access & GL_MAP_UNSYNCHRONIZED_BIT) &&
       (access & GL_MAP_INVALIDATE_BUFFER_BIT) &&
       drm_intel_bo_busy(intel_obj->buffer)) {
      drm_intel_bo_unreference(intel_obj->buffer);
      intel_bufferobj_alloc_buffer(intel, intel_obj);
   }

   /* If the user is mapping a range of an active buffer object but
    * doesn't require the current contents of that range, make a new
    * BO, and we'll copy what they put in there out at unmap or
    * FlushRange time.
    */
   if ((access & GL_MAP_INVALIDATE_RANGE_BIT) &&
       drm_intel_bo_busy(intel_obj->buffer)) {
      if (access & GL_MAP_FLUSH_EXPLICIT_BIT) {
	 intel_obj->range_map_buffer = malloc(length);
	 obj->Pointer = intel_obj->range_map_buffer;
      } else {
	 intel_obj->range_map_bo = drm_intel_bo_alloc(intel->bufmgr,
						      "range map",
						      length, 64);
	 if (!(access & GL_MAP_READ_BIT)) {
	    drm_intel_gem_bo_map_gtt(intel_obj->range_map_bo);
	    intel_obj->mapped_gtt = GL_TRUE;
	 } else {
	    drm_intel_bo_map(intel_obj->range_map_bo,
			     (access & GL_MAP_WRITE_BIT) != 0);
	    intel_obj->mapped_gtt = GL_FALSE;
	 }
	 obj->Pointer = intel_obj->range_map_bo->virtual;
      }
      return obj->Pointer;
   }

   if (!(access & GL_MAP_READ_BIT)) {
      drm_intel_gem_bo_map_gtt(intel_obj->buffer);
      intel_obj->mapped_gtt = GL_TRUE;
   } else {
      drm_intel_bo_map(intel_obj->buffer, (access & GL_MAP_WRITE_BIT) != 0);
      intel_obj->mapped_gtt = GL_FALSE;
   }

   obj->Pointer = intel_obj->buffer->virtual + offset;
   return obj->Pointer;
}

/* Ideally we'd use a BO to avoid taking up cache space for the temporary
 * data, but FlushMappedBufferRange may be followed by further writes to
 * the pointer, so we would have to re-map after emitting our blit, which
 * would defeat the point.
 */
static void
intel_bufferobj_flush_mapped_range(struct gl_context *ctx, GLenum target,
				   GLintptr offset, GLsizeiptr length,
				   struct gl_buffer_object *obj)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_buffer_object *intel_obj = intel_buffer_object(obj);
   drm_intel_bo *temp_bo;

   /* Unless we're in the range map using a temporary system buffer,
    * there's no work to do.
    */
   if (intel_obj->range_map_buffer == NULL)
      return;

   if (length == 0)
      return;

   temp_bo = drm_intel_bo_alloc(intel->bufmgr, "range map flush", length, 64);

   drm_intel_bo_subdata(temp_bo, 0, length, intel_obj->range_map_buffer);

   intel_emit_linear_blit(intel,
			  intel_obj->buffer, obj->Offset + offset,
			  temp_bo, 0,
			  length);

   drm_intel_bo_unreference(temp_bo);
}


/**
 * Called via glUnmapBuffer().
 */
static GLboolean
intel_bufferobj_unmap(struct gl_context * ctx,
                      GLenum target, struct gl_buffer_object *obj)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_buffer_object *intel_obj = intel_buffer_object(obj);

   assert(intel_obj);
   assert(obj->Pointer);
   if (intel_obj->sys_buffer != NULL) {
      /* always keep the mapping around. */
   } else if (intel_obj->range_map_buffer != NULL) {
      /* Since we've emitted some blits to buffers that will (likely) be used
       * in rendering operations in other cache domains in this batch, emit a
       * flush.  Once again, we wish for a domain tracker in libdrm to cover
       * usage inside of a batchbuffer.
       */
      intel_batchbuffer_emit_mi_flush(intel);
      free(intel_obj->range_map_buffer);
      intel_obj->range_map_buffer = NULL;
   } else if (intel_obj->range_map_bo != NULL) {
      if (intel_obj->mapped_gtt) {
	 drm_intel_gem_bo_unmap_gtt(intel_obj->range_map_bo);
      } else {
	 drm_intel_bo_unmap(intel_obj->range_map_bo);
      }

      intel_emit_linear_blit(intel,
			     intel_obj->buffer, obj->Offset,
			     intel_obj->range_map_bo, 0,
			     obj->Length);

      /* Since we've emitted some blits to buffers that will (likely) be used
       * in rendering operations in other cache domains in this batch, emit a
       * flush.  Once again, we wish for a domain tracker in libdrm to cover
       * usage inside of a batchbuffer.
       */
      intel_batchbuffer_emit_mi_flush(intel);

      drm_intel_bo_unreference(intel_obj->range_map_bo);
      intel_obj->range_map_bo = NULL;
   } else if (intel_obj->buffer != NULL) {
      if (intel_obj->mapped_gtt) {
	 drm_intel_gem_bo_unmap_gtt(intel_obj->buffer);
      } else {
	 drm_intel_bo_unmap(intel_obj->buffer);
      }
   }
   obj->Pointer = NULL;
   obj->Offset = 0;
   obj->Length = 0;

   return GL_TRUE;
}

drm_intel_bo *
intel_bufferobj_buffer(struct intel_context *intel,
                       struct intel_buffer_object *intel_obj,
		       GLuint flag)
{
   if (intel_obj->region) {
      if (flag == INTEL_WRITE_PART)
         intel_bufferobj_cow(intel, intel_obj);
      else if (flag == INTEL_WRITE_FULL) {
         intel_bufferobj_release_region(intel, intel_obj);
	 intel_bufferobj_alloc_buffer(intel, intel_obj);
      }
   }

   if (intel_obj->source)
      release_buffer(intel_obj);

   if (intel_obj->buffer == NULL) {
      intel_bufferobj_alloc_buffer(intel, intel_obj);
      drm_intel_bo_subdata(intel_obj->buffer,
			   0, intel_obj->Base.Size,
			   intel_obj->sys_buffer);

      free(intel_obj->sys_buffer);
      intel_obj->sys_buffer = NULL;
      intel_obj->offset = 0;
   }

   return intel_obj->buffer;
}

#define INTEL_UPLOAD_SIZE (64*1024)

void
intel_upload_finish(struct intel_context *intel)
{
   if (!intel->upload.bo)
	   return;

   if (intel->upload.buffer_len) {
	   drm_intel_bo_subdata(intel->upload.bo,
				intel->upload.buffer_offset,
				intel->upload.buffer_len,
				intel->upload.buffer);
	   intel->upload.buffer_len = 0;
   }

   drm_intel_bo_unreference(intel->upload.bo);
   intel->upload.bo = NULL;
}

static void wrap_buffers(struct intel_context *intel, GLuint size)
{
   intel_upload_finish(intel);

   if (size < INTEL_UPLOAD_SIZE)
      size = INTEL_UPLOAD_SIZE;

   intel->upload.bo = drm_intel_bo_alloc(intel->bufmgr, "upload", size, 0);
   intel->upload.offset = 0;
}

void intel_upload_data(struct intel_context *intel,
		       const void *ptr, GLuint size, GLuint align,
		       drm_intel_bo **return_bo,
		       GLuint *return_offset)
{
   GLuint base, delta;

   base = (intel->upload.offset + align - 1) / align * align;
   if (intel->upload.bo == NULL || base + size > intel->upload.bo->size) {
      wrap_buffers(intel, size);
      base = 0;
   }

   drm_intel_bo_reference(intel->upload.bo);
   *return_bo = intel->upload.bo;
   *return_offset = base;

   delta = base - intel->upload.offset;
   if (intel->upload.buffer_len &&
       intel->upload.buffer_len + delta + size > sizeof(intel->upload.buffer))
   {
      drm_intel_bo_subdata(intel->upload.bo,
			   intel->upload.buffer_offset,
			   intel->upload.buffer_len,
			   intel->upload.buffer);
      intel->upload.buffer_len = 0;
   }

   if (size < sizeof(intel->upload.buffer))
   {
      if (intel->upload.buffer_len == 0)
	 intel->upload.buffer_offset = base;
      else
	 intel->upload.buffer_len += delta;

      memcpy(intel->upload.buffer + intel->upload.buffer_len, ptr, size);
      intel->upload.buffer_len += size;
   }
   else
   {
      drm_intel_bo_subdata(intel->upload.bo, base, size, ptr);
   }

   intel->upload.offset = base + size;
}

void *intel_upload_map(struct intel_context *intel, GLuint size, GLuint align)
{
   GLuint base, delta;
   char *ptr;

   base = (intel->upload.offset + align - 1) / align * align;
   if (intel->upload.bo == NULL || base + size > intel->upload.bo->size) {
      wrap_buffers(intel, size);
      base = 0;
   }

   delta = base - intel->upload.offset;
   if (intel->upload.buffer_len &&
       intel->upload.buffer_len + delta + size > sizeof(intel->upload.buffer))
   {
      drm_intel_bo_subdata(intel->upload.bo,
			   intel->upload.buffer_offset,
			   intel->upload.buffer_len,
			   intel->upload.buffer);
      intel->upload.buffer_len = 0;
   }

   if (size <= sizeof(intel->upload.buffer)) {
      if (intel->upload.buffer_len == 0)
	 intel->upload.buffer_offset = base;
      else
	 intel->upload.buffer_len += delta;

      ptr = intel->upload.buffer + intel->upload.buffer_len;
      intel->upload.buffer_len += size;
   } else
      ptr = malloc(size);

   return ptr;
}

void intel_upload_unmap(struct intel_context *intel,
			const void *ptr, GLuint size, GLuint align,
			drm_intel_bo **return_bo,
			GLuint *return_offset)
{
   GLuint base;

   base = (intel->upload.offset + align - 1) / align * align;
   if (size > sizeof(intel->upload.buffer)) {
      drm_intel_bo_subdata(intel->upload.bo, base, size, ptr);
      free((void*)ptr);
   }

   drm_intel_bo_reference(intel->upload.bo);
   *return_bo = intel->upload.bo;
   *return_offset = base;

   intel->upload.offset = base + size;
}

drm_intel_bo *
intel_bufferobj_source(struct intel_context *intel,
                       struct intel_buffer_object *intel_obj,
		       GLuint align, GLuint *offset)
{
   if (intel_obj->buffer == NULL) {
      intel_upload_data(intel,
			intel_obj->sys_buffer, intel_obj->Base.Size, align,
			&intel_obj->buffer, &intel_obj->offset);
      intel_obj->source = 1;
   }

   *offset = intel_obj->offset;
   return intel_obj->buffer;
}

static void
intel_bufferobj_copy_subdata(struct gl_context *ctx,
			     struct gl_buffer_object *src,
			     struct gl_buffer_object *dst,
			     GLintptr read_offset, GLintptr write_offset,
			     GLsizeiptr size)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_buffer_object *intel_src = intel_buffer_object(src);
   struct intel_buffer_object *intel_dst = intel_buffer_object(dst);
   drm_intel_bo *src_bo, *dst_bo;
   GLuint src_offset;

   if (size == 0)
      return;

   /* If we're in system memory, just map and memcpy. */
   if (intel_src->sys_buffer || intel_dst->sys_buffer || intel->gen >= 6) {
      /* The same buffer may be used, but note that regions copied may
       * not overlap.
       */
      if (src == dst) {
	 char *ptr = intel_bufferobj_map(ctx, GL_COPY_WRITE_BUFFER,
					 GL_READ_WRITE, dst);
	 memmove(ptr + write_offset, ptr + read_offset, size);
	 intel_bufferobj_unmap(ctx, GL_COPY_WRITE_BUFFER, dst);
      } else {
	 const char *src_ptr;
	 char *dst_ptr;

	 src_ptr =  intel_bufferobj_map(ctx, GL_COPY_READ_BUFFER,
					GL_READ_ONLY, src);
	 dst_ptr =  intel_bufferobj_map(ctx, GL_COPY_WRITE_BUFFER,
					GL_WRITE_ONLY, dst);

	 memcpy(dst_ptr + write_offset, src_ptr + read_offset, size);

	 intel_bufferobj_unmap(ctx, GL_COPY_READ_BUFFER, src);
	 intel_bufferobj_unmap(ctx, GL_COPY_WRITE_BUFFER, dst);
      }
      return;
   }

   /* Otherwise, we have real BOs, so blit them. */

   dst_bo = intel_bufferobj_buffer(intel, intel_dst, INTEL_WRITE_PART);
   src_bo = intel_bufferobj_source(intel, intel_src, 64, &src_offset);

   intel_emit_linear_blit(intel,
			  dst_bo, write_offset,
			  src_bo, read_offset + src_offset, size);

   /* Since we've emitted some blits to buffers that will (likely) be used
    * in rendering operations in other cache domains in this batch, emit a
    * flush.  Once again, we wish for a domain tracker in libdrm to cover
    * usage inside of a batchbuffer.
    */
   intel_batchbuffer_emit_mi_flush(intel);
}

#if FEATURE_APPLE_object_purgeable
static GLenum
intel_buffer_purgeable(struct gl_context * ctx,
                       drm_intel_bo *buffer,
                       GLenum option)
{
   int retained = 0;

   if (buffer != NULL)
      retained = drm_intel_bo_madvise (buffer, I915_MADV_DONTNEED);

   return retained ? GL_VOLATILE_APPLE : GL_RELEASED_APPLE;
}

static GLenum
intel_buffer_object_purgeable(struct gl_context * ctx,
                              struct gl_buffer_object *obj,
                              GLenum option)
{
   struct intel_buffer_object *intel;

   intel = intel_buffer_object (obj);
   if (intel->buffer != NULL)
      return intel_buffer_purgeable (ctx, intel->buffer, option);

   if (option == GL_RELEASED_APPLE) {
      if (intel->sys_buffer != NULL) {
         free(intel->sys_buffer);
         intel->sys_buffer = NULL;
      }

      return GL_RELEASED_APPLE;
   } else {
      /* XXX Create the buffer and madvise(MADV_DONTNEED)? */
      return intel_buffer_purgeable (ctx,
                                     intel_bufferobj_buffer(intel_context(ctx),
                                                            intel, INTEL_READ),
                                     option);
   }
}

static GLenum
intel_texture_object_purgeable(struct gl_context * ctx,
                               struct gl_texture_object *obj,
                               GLenum option)
{
   struct intel_texture_object *intel;

   intel = intel_texture_object(obj);
   if (intel->mt == NULL || intel->mt->region == NULL)
      return GL_RELEASED_APPLE;

   return intel_buffer_purgeable (ctx, intel->mt->region->buffer, option);
}

static GLenum
intel_render_object_purgeable(struct gl_context * ctx,
                              struct gl_renderbuffer *obj,
                              GLenum option)
{
   struct intel_renderbuffer *intel;

   intel = intel_renderbuffer(obj);
   if (intel->region == NULL)
      return GL_RELEASED_APPLE;

   return intel_buffer_purgeable (ctx, intel->region->buffer, option);
}

static GLenum
intel_buffer_unpurgeable(struct gl_context * ctx,
                         drm_intel_bo *buffer,
                         GLenum option)
{
   int retained;

   retained = 0;
   if (buffer != NULL)
      retained = drm_intel_bo_madvise (buffer, I915_MADV_WILLNEED);

   return retained ? GL_RETAINED_APPLE : GL_UNDEFINED_APPLE;
}

static GLenum
intel_buffer_object_unpurgeable(struct gl_context * ctx,
                                struct gl_buffer_object *obj,
                                GLenum option)
{
   return intel_buffer_unpurgeable (ctx, intel_buffer_object (obj)->buffer, option);
}

static GLenum
intel_texture_object_unpurgeable(struct gl_context * ctx,
                                 struct gl_texture_object *obj,
                                 GLenum option)
{
   struct intel_texture_object *intel;

   intel = intel_texture_object(obj);
   if (intel->mt == NULL || intel->mt->region == NULL)
      return GL_UNDEFINED_APPLE;

   return intel_buffer_unpurgeable (ctx, intel->mt->region->buffer, option);
}

static GLenum
intel_render_object_unpurgeable(struct gl_context * ctx,
                                struct gl_renderbuffer *obj,
                                GLenum option)
{
   struct intel_renderbuffer *intel;

   intel = intel_renderbuffer(obj);
   if (intel->region == NULL)
      return GL_UNDEFINED_APPLE;

   return intel_buffer_unpurgeable (ctx, intel->region->buffer, option);
}
#endif

void
intelInitBufferObjectFuncs(struct dd_function_table *functions)
{
   functions->NewBufferObject = intel_bufferobj_alloc;
   functions->DeleteBuffer = intel_bufferobj_free;
   functions->BufferData = intel_bufferobj_data;
   functions->BufferSubData = intel_bufferobj_subdata;
   functions->GetBufferSubData = intel_bufferobj_get_subdata;
   functions->MapBuffer = intel_bufferobj_map;
   functions->MapBufferRange = intel_bufferobj_map_range;
   functions->FlushMappedBufferRange = intel_bufferobj_flush_mapped_range;
   functions->UnmapBuffer = intel_bufferobj_unmap;
   functions->CopyBufferSubData = intel_bufferobj_copy_subdata;

#if FEATURE_APPLE_object_purgeable
   functions->BufferObjectPurgeable = intel_buffer_object_purgeable;
   functions->TextureObjectPurgeable = intel_texture_object_purgeable;
   functions->RenderObjectPurgeable = intel_render_object_purgeable;

   functions->BufferObjectUnpurgeable = intel_buffer_object_unpurgeable;
   functions->TextureObjectUnpurgeable = intel_texture_object_unpurgeable;
   functions->RenderObjectUnpurgeable = intel_render_object_unpurgeable;
#endif
}
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.4
log
@Merge Mesa 7.10.3
@
text
@d30 1
d56 9
d93 1
a93 2
   drm_intel_bo_unreference(intel_obj->buffer);
   intel_obj->buffer = NULL;
a130 3
   else if (intel_obj->buffer) {
      drm_intel_bo_unreference(intel_obj->buffer);
   }
d132 1
d163 3
a165 4
   if (intel_obj->buffer != NULL) {
      drm_intel_bo_unreference(intel_obj->buffer);
      intel_obj->buffer = NULL;
   }
d170 1
d172 7
a178 4
      /* On pre-965, stick VBOs in system memory, as we're always doing swtnl
       * with their contents anyway.
       */
      if (target == GL_ARRAY_BUFFER || target == GL_ELEMENT_ARRAY_BUFFER) {
a185 1
#endif
d213 1
d223 36
a258 17
   if (intel_obj->sys_buffer)
      memcpy((char *)intel_obj->sys_buffer + offset, data, size);
   else {
      /* Flush any existing batchbuffer that might reference this data. */
      if (intel->gen < 6) {
	 if (drm_intel_bo_busy(intel_obj->buffer) ||
	     drm_intel_bo_references(intel->batch->buf, intel_obj->buffer)) {
	    drm_intel_bo *temp_bo;

	    temp_bo = drm_intel_bo_alloc(intel->bufmgr, "subdata temp", size, 64);

	    drm_intel_bo_subdata(temp_bo, 0, size, data);

	    intel_emit_linear_blit(intel,
				   intel_obj->buffer, offset,
				   temp_bo, 0,
				   size);
d260 1
a260 4
	    drm_intel_bo_unreference(temp_bo);
	 } else {
	    drm_intel_bo_subdata(intel_obj->buffer, offset, size, data);
	 }
a261 3
	 if (drm_intel_bo_references(intel->batch->buf, intel_obj->buffer)) {
	    intel_batchbuffer_flush(intel->batch);
	 }
d264 6
d285 1
d290 4
a293 1
   else
d295 1
d316 13
a328 4
      obj->Pointer = intel_obj->sys_buffer;
      obj->Length = obj->Size;
      obj->Offset = 0;
      return obj->Pointer;
d332 1
a332 1
   if (drm_intel_bo_references(intel->batch->buf, intel_obj->buffer))
d381 1
d393 10
a402 2
      obj->Pointer = intel_obj->sys_buffer + offset;
      return obj->Pointer;
d413 1
a413 1
       drm_intel_bo_references(intel->batch->buf, intel_obj->buffer))
d428 1
a428 2
      intel_obj->buffer = drm_intel_bo_alloc(intel->bufmgr, "bufferobj",
					     intel_obj->Base.Size, 64);
d526 1
a526 1
      intel_batchbuffer_emit_mi_flush(intel->batch);
d546 1
a546 1
      intel_batchbuffer_emit_mi_flush(intel->batch);
d566 2
a567 1
                       struct intel_buffer_object *intel_obj, GLuint flag)
d578 3
d582 4
a585 1
      void *sys_buffer = intel_obj->sys_buffer;
d587 1
a587 2
      /* only one of buffer and sys_buffer could be non-NULL */
      intel_bufferobj_alloc_buffer(intel, intel_obj);
d589 71
d661 77
a737 8
      intel_bufferobj_subdata(&intel->ctx,
			      GL_ARRAY_BUFFER_ARB,
			      0,
			      intel_obj->Base.Size,
			      sys_buffer,
			      &intel_obj->Base);
      free(sys_buffer);
      intel_obj->sys_buffer = NULL;
d740 1
d755 1
d768 1
a768 1
	 memcpy(ptr + write_offset, ptr + read_offset, size);
d790 1
a790 1
   src_bo = intel_bufferobj_buffer(intel, intel_src, INTEL_READ);
d794 1
a794 1
			  src_bo, read_offset, size);
d801 1
a801 1
   intel_batchbuffer_emit_mi_flush(intel->batch);
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d43 1
a43 1
intel_bufferobj_unmap(GLcontext * ctx,
d46 1
a46 1
/** Allocates a new dri_bo to store the data for the buffer object. */
d51 2
a52 2
   intel_obj->buffer = dri_bo_alloc(intel->bufmgr, "bufferobj",
				    intel_obj->Base.Size, 64);
d62 1
a62 1
intel_bufferobj_alloc(GLcontext * ctx, GLuint name, GLenum target)
d83 1
a83 1
   dri_bo_unreference(intel_obj->buffer);
d104 1
a104 1
intel_bufferobj_free(GLcontext * ctx, struct gl_buffer_object *obj)
d123 1
a123 1
      dri_bo_unreference(intel_obj->buffer);
d139 1
a139 1
intel_bufferobj_data(GLcontext * ctx,
d157 1
a157 1
      dri_bo_unreference(intel_obj->buffer);
d182 1
a182 1
	 dri_bo_subdata(intel_obj->buffer, 0, size, data);
d196 1
a196 1
intel_bufferobj_subdata(GLcontext * ctx,
d205 3
d217 4
a220 3
      if (drm_intel_bo_busy(intel_obj->buffer) ||
	  drm_intel_bo_references(intel->batch->buf, intel_obj->buffer)) {
	 drm_intel_bo *temp_bo;
d222 1
a222 1
	 temp_bo = drm_intel_bo_alloc(intel->bufmgr, "subdata temp", size, 64);
d224 1
a224 1
	 drm_intel_bo_subdata(temp_bo, 0, size, data);
d226 4
a229 4
	 intel_emit_linear_blit(intel,
				intel_obj->buffer, offset,
				temp_bo, 0,
				size);
d231 4
a234 1
	 drm_intel_bo_unreference(temp_bo);
d236 4
a239 1
	 dri_bo_subdata(intel_obj->buffer, offset, size, data);
d249 1
a249 1
intel_bufferobj_get_subdata(GLcontext * ctx,
d261 1
a261 1
      dri_bo_get_subdata(intel_obj->buffer, offset, size, data);
d270 1
a270 1
intel_bufferobj_map(GLcontext * ctx,
d290 1
a290 1
      intelFlush(ctx);
d332 1
a332 1
intel_bufferobj_map_range(GLcontext * ctx,
d362 1
a362 1
      intelFlush(ctx);
d376 2
a377 2
      intel_obj->buffer = dri_bo_alloc(intel->bufmgr, "bufferobj",
				       intel_obj->Base.Size, 64);
d425 1
a425 1
intel_bufferobj_flush_mapped_range(GLcontext *ctx, GLenum target,
d439 3
d459 1
a459 1
intel_bufferobj_unmap(GLcontext * ctx,
d513 1
a513 1
dri_bo *
d547 1
a547 1
intel_bufferobj_copy_subdata(GLcontext *ctx,
d562 1
a562 1
   if (intel_src->sys_buffer || intel_dst->sys_buffer) {
d585 1
d607 1
a607 1
intel_buffer_purgeable(GLcontext * ctx,
d620 1
a620 1
intel_buffer_object_purgeable(GLcontext * ctx,
d647 1
a647 1
intel_texture_object_purgeable(GLcontext * ctx,
d661 1
a661 1
intel_render_object_purgeable(GLcontext * ctx,
d675 1
a675 1
intel_buffer_unpurgeable(GLcontext * ctx,
d689 1
a689 1
intel_buffer_object_unpurgeable(GLcontext * ctx,
d697 1
a697 1
intel_texture_object_unpurgeable(GLcontext * ctx,
d711 1
a711 1
intel_render_object_unpurgeable(GLcontext * ctx,
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d31 1
d34 1
a34 1
#include "intel_context.h"
d37 3
d42 3
a44 3
static GLboolean intel_bufferobj_unmap(GLcontext * ctx,
				       GLenum target,
				       struct gl_buffer_object *obj);
d112 2
a113 1
    * to the spec.
d118 1
d126 1
a126 1
   _mesa_free(intel_obj);
d135 2
a136 1
 * Called via glBufferDataARB().
d138 1
a138 1
static void
d151 1
a151 5
   /* Buffer objects are automatically unmapped when creating new data buffers
    * according to the spec.
    */
   if (obj->Pointer)
      intel_bufferobj_unmap(ctx, 0, obj);
d160 3
d164 13
d178 2
d184 2
d210 22
a231 1
   dri_bo_subdata(intel_obj->buffer, offset, size, data);
d248 4
a251 1
   dri_bo_get_subdata(intel_obj->buffer, offset, size, data);
d266 2
a268 2
   /* XXX: Translate access to flags arg below:
    */
d271 11
d290 8
a297 1
   dri_bo_map(intel_obj->buffer, GL_TRUE);
d299 3
d305 136
d443 1
a443 1
 * Called via glMapBufferARB().
d449 1
d453 39
a491 4
   if (intel_obj->buffer != NULL) {
      assert(obj->Pointer);
      dri_bo_unmap(intel_obj->buffer);
      obj->Pointer = NULL;
d493 4
d513 17
d533 178
d712 1
a712 1
intel_bufferobj_init(struct intel_context *intel)
d714 20
a733 9
   GLcontext *ctx = &intel->ctx;

   ctx->Driver.NewBufferObject = intel_bufferobj_alloc;
   ctx->Driver.DeleteBuffer = intel_bufferobj_free;
   ctx->Driver.BufferData = intel_bufferobj_data;
   ctx->Driver.BufferSubData = intel_bufferobj_subdata;
   ctx->Driver.GetBufferSubData = intel_bufferobj_get_subdata;
   ctx->Driver.MapBuffer = intel_bufferobj_map;
   ctx->Driver.UnmapBuffer = intel_bufferobj_unmap;
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d29 3
a31 3
#include "imports.h"
#include "mtypes.h"
#include "bufferobj.h"
d35 1
a36 1
#include "dri_bufmgr.h"
d48 1
a48 2
				    intel_obj->Base.Size, 64,
				    DRM_BO_FLAG_MEM_LOCAL | DRM_BO_FLAG_CACHED | DRM_BO_FLAG_CACHED_MAPPED);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d29 3
a31 4
#include "main/imports.h"
#include "main/mtypes.h"
#include "main/macros.h"
#include "main/bufferobj.h"
d33 1
a33 1
#include "intel_blit.h"
a34 4
#include "intel_batchbuffer.h"
#include "intel_context.h"
#include "intel_fbo.h"
#include "intel_mipmap_tree.h"
d36 1
d38 3
a40 3
static GLboolean
intel_bufferobj_unmap(struct gl_context * ctx,
                      GLenum target, struct gl_buffer_object *obj);
d42 1
a42 1
/** Allocates a new drm_intel_bo to store the data for the buffer object. */
d47 3
a49 2
   intel_obj->buffer = drm_intel_bo_alloc(intel->bufmgr, "bufferobj",
					  intel_obj->Base.Size, 64);
d59 1
a59 1
intel_bufferobj_alloc(struct gl_context * ctx, GLuint name, GLenum target)
d80 1
a80 1
   drm_intel_bo_unreference(intel_obj->buffer);
d101 1
a101 1
intel_bufferobj_free(struct gl_context * ctx, struct gl_buffer_object *obj)
d109 1
a109 2
    * to the spec, but Mesa doesn't do UnmapBuffer for us at context destroy
    * (though it does if you call glDeleteBuffers)
a113 1
   free(intel_obj->sys_buffer);
d118 1
a118 1
      drm_intel_bo_unreference(intel_obj->buffer);
d121 1
a121 1
   free(intel_obj);
d130 1
a130 2
 * Called via ctx->Driver.BufferData().
 * \return GL_TRUE for success, GL_FALSE if out of memory
d132 2
a133 2
static GLboolean
intel_bufferobj_data(struct gl_context * ctx,
d145 5
a149 1
   assert(!obj->Pointer); /* Mesa should have unmapped it */
d155 1
a155 1
      drm_intel_bo_unreference(intel_obj->buffer);
a157 3
   free(intel_obj->sys_buffer);
   intel_obj->sys_buffer = NULL;

a158 13
#ifdef I915
      /* On pre-965, stick VBOs in system memory, as we're always doing swtnl
       * with their contents anyway.
       */
      if (target == GL_ARRAY_BUFFER || target == GL_ELEMENT_ARRAY_BUFFER) {
	 intel_obj->sys_buffer = malloc(size);
	 if (intel_obj->sys_buffer != NULL) {
	    if (data != NULL)
	       memcpy(intel_obj->sys_buffer, data, size);
	    return GL_TRUE;
	 }
      }
#endif
a159 2
      if (!intel_obj->buffer)
         return GL_FALSE;
d162 1
a162 1
	 drm_intel_bo_subdata(intel_obj->buffer, 0, size, data);
a163 2

   return GL_TRUE;
d174 1
a174 1
intel_bufferobj_subdata(struct gl_context * ctx,
a182 3
   if (size == 0)
      return;

d188 1
a188 29
   if (intel_obj->sys_buffer)
      memcpy((char *)intel_obj->sys_buffer + offset, data, size);
   else {
      /* Flush any existing batchbuffer that might reference this data. */
      if (intel->gen < 6) {
	 if (drm_intel_bo_busy(intel_obj->buffer) ||
	     drm_intel_bo_references(intel->batch->buf, intel_obj->buffer)) {
	    drm_intel_bo *temp_bo;

	    temp_bo = drm_intel_bo_alloc(intel->bufmgr, "subdata temp", size, 64);

	    drm_intel_bo_subdata(temp_bo, 0, size, data);

	    intel_emit_linear_blit(intel,
				   intel_obj->buffer, offset,
				   temp_bo, 0,
				   size);

	    drm_intel_bo_unreference(temp_bo);
	 } else {
	    drm_intel_bo_subdata(intel_obj->buffer, offset, size, data);
	 }
      } else {
	 if (drm_intel_bo_references(intel->batch->buf, intel_obj->buffer)) {
	    intel_batchbuffer_flush(intel->batch);
	 }
	 drm_intel_bo_subdata(intel_obj->buffer, offset, size, data);
      }
   }
d196 1
a196 1
intel_bufferobj_get_subdata(struct gl_context * ctx,
d205 1
a205 4
   if (intel_obj->sys_buffer)
      memcpy(data, (char *)intel_obj->sys_buffer + offset, size);
   else
      drm_intel_bo_get_subdata(intel_obj->buffer, offset, size, data);
d214 1
a214 1
intel_bufferobj_map(struct gl_context * ctx,
a219 2
   GLboolean read_only = (access == GL_READ_ONLY_ARB);
   GLboolean write_only = (access == GL_WRITE_ONLY_ARB);
d221 2
a224 11
   if (intel_obj->sys_buffer) {
      obj->Pointer = intel_obj->sys_buffer;
      obj->Length = obj->Size;
      obj->Offset = 0;
      return obj->Pointer;
   }

   /* Flush any existing batchbuffer that might reference this data. */
   if (drm_intel_bo_references(intel->batch->buf, intel_obj->buffer))
      intel_flush(ctx);

d233 1
a233 8
   if (write_only) {
      drm_intel_gem_bo_map_gtt(intel_obj->buffer);
      intel_obj->mapped_gtt = GL_TRUE;
   } else {
      drm_intel_bo_map(intel_obj->buffer, !read_only);
      intel_obj->mapped_gtt = GL_FALSE;
   }

a234 107
   obj->Length = obj->Size;
   obj->Offset = 0;

   return obj->Pointer;
}

/**
 * Called via glMapBufferRange().
 *
 * The goal of this extension is to allow apps to accumulate their rendering
 * at the same time as they accumulate their buffer object.  Without it,
 * you'd end up blocking on execution of rendering every time you mapped
 * the buffer to put new data in.
 *
 * We support it in 3 ways: If unsynchronized, then don't bother
 * flushing the batchbuffer before mapping the buffer, which can save blocking
 * in many cases.  If we would still block, and they allow the whole buffer
 * to be invalidated, then just allocate a new buffer to replace the old one.
 * If not, and we'd block, and they allow the subrange of the buffer to be
 * invalidated, then we can make a new little BO, let them write into that,
 * and blit it into the real BO at unmap time.
 */
static void *
intel_bufferobj_map_range(struct gl_context * ctx,
			  GLenum target, GLintptr offset, GLsizeiptr length,
			  GLbitfield access, struct gl_buffer_object *obj)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_buffer_object *intel_obj = intel_buffer_object(obj);

   assert(intel_obj);

   /* _mesa_MapBufferRange (GL entrypoint) sets these, but the vbo module also
    * internally uses our functions directly.
    */
   obj->Offset = offset;
   obj->Length = length;
   obj->AccessFlags = access;

   if (intel_obj->sys_buffer) {
      obj->Pointer = intel_obj->sys_buffer + offset;
      return obj->Pointer;
   }

   if (intel_obj->region)
      intel_bufferobj_cow(intel, intel_obj);

   /* If the mapping is synchronized with other GL operations, flush
    * the batchbuffer so that GEM knows about the buffer access for later
    * syncing.
    */
   if (!(access & GL_MAP_UNSYNCHRONIZED_BIT) &&
       drm_intel_bo_references(intel->batch->buf, intel_obj->buffer))
      intel_flush(ctx);

   if (intel_obj->buffer == NULL) {
      obj->Pointer = NULL;
      return NULL;
   }

   /* If the user doesn't care about existing buffer contents and mapping
    * would cause us to block, then throw out the old buffer.
    */
   if (!(access & GL_MAP_UNSYNCHRONIZED_BIT) &&
       (access & GL_MAP_INVALIDATE_BUFFER_BIT) &&
       drm_intel_bo_busy(intel_obj->buffer)) {
      drm_intel_bo_unreference(intel_obj->buffer);
      intel_obj->buffer = drm_intel_bo_alloc(intel->bufmgr, "bufferobj",
					     intel_obj->Base.Size, 64);
   }

   /* If the user is mapping a range of an active buffer object but
    * doesn't require the current contents of that range, make a new
    * BO, and we'll copy what they put in there out at unmap or
    * FlushRange time.
    */
   if ((access & GL_MAP_INVALIDATE_RANGE_BIT) &&
       drm_intel_bo_busy(intel_obj->buffer)) {
      if (access & GL_MAP_FLUSH_EXPLICIT_BIT) {
	 intel_obj->range_map_buffer = malloc(length);
	 obj->Pointer = intel_obj->range_map_buffer;
      } else {
	 intel_obj->range_map_bo = drm_intel_bo_alloc(intel->bufmgr,
						      "range map",
						      length, 64);
	 if (!(access & GL_MAP_READ_BIT)) {
	    drm_intel_gem_bo_map_gtt(intel_obj->range_map_bo);
	    intel_obj->mapped_gtt = GL_TRUE;
	 } else {
	    drm_intel_bo_map(intel_obj->range_map_bo,
			     (access & GL_MAP_WRITE_BIT) != 0);
	    intel_obj->mapped_gtt = GL_FALSE;
	 }
	 obj->Pointer = intel_obj->range_map_bo->virtual;
      }
      return obj->Pointer;
   }

   if (!(access & GL_MAP_READ_BIT)) {
      drm_intel_gem_bo_map_gtt(intel_obj->buffer);
      intel_obj->mapped_gtt = GL_TRUE;
   } else {
      drm_intel_bo_map(intel_obj->buffer, (access & GL_MAP_WRITE_BIT) != 0);
      intel_obj->mapped_gtt = GL_FALSE;
   }

   obj->Pointer = intel_obj->buffer->virtual + offset;
a237 35
/* Ideally we'd use a BO to avoid taking up cache space for the temporary
 * data, but FlushMappedBufferRange may be followed by further writes to
 * the pointer, so we would have to re-map after emitting our blit, which
 * would defeat the point.
 */
static void
intel_bufferobj_flush_mapped_range(struct gl_context *ctx, GLenum target,
				   GLintptr offset, GLsizeiptr length,
				   struct gl_buffer_object *obj)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_buffer_object *intel_obj = intel_buffer_object(obj);
   drm_intel_bo *temp_bo;

   /* Unless we're in the range map using a temporary system buffer,
    * there's no work to do.
    */
   if (intel_obj->range_map_buffer == NULL)
      return;

   if (length == 0)
      return;

   temp_bo = drm_intel_bo_alloc(intel->bufmgr, "range map flush", length, 64);

   drm_intel_bo_subdata(temp_bo, 0, length, intel_obj->range_map_buffer);

   intel_emit_linear_blit(intel,
			  intel_obj->buffer, obj->Offset + offset,
			  temp_bo, 0,
			  length);

   drm_intel_bo_unreference(temp_bo);
}

d240 1
a240 1
 * Called via glUnmapBuffer().
d243 1
a243 1
intel_bufferobj_unmap(struct gl_context * ctx,
a245 1
   struct intel_context *intel = intel_context(ctx);
d249 4
a252 39
   assert(obj->Pointer);
   if (intel_obj->sys_buffer != NULL) {
      /* always keep the mapping around. */
   } else if (intel_obj->range_map_buffer != NULL) {
      /* Since we've emitted some blits to buffers that will (likely) be used
       * in rendering operations in other cache domains in this batch, emit a
       * flush.  Once again, we wish for a domain tracker in libdrm to cover
       * usage inside of a batchbuffer.
       */
      intel_batchbuffer_emit_mi_flush(intel->batch);
      free(intel_obj->range_map_buffer);
      intel_obj->range_map_buffer = NULL;
   } else if (intel_obj->range_map_bo != NULL) {
      if (intel_obj->mapped_gtt) {
	 drm_intel_gem_bo_unmap_gtt(intel_obj->range_map_bo);
      } else {
	 drm_intel_bo_unmap(intel_obj->range_map_bo);
      }

      intel_emit_linear_blit(intel,
			     intel_obj->buffer, obj->Offset,
			     intel_obj->range_map_bo, 0,
			     obj->Length);

      /* Since we've emitted some blits to buffers that will (likely) be used
       * in rendering operations in other cache domains in this batch, emit a
       * flush.  Once again, we wish for a domain tracker in libdrm to cover
       * usage inside of a batchbuffer.
       */
      intel_batchbuffer_emit_mi_flush(intel->batch);

      drm_intel_bo_unreference(intel_obj->range_map_bo);
      intel_obj->range_map_bo = NULL;
   } else if (intel_obj->buffer != NULL) {
      if (intel_obj->mapped_gtt) {
	 drm_intel_gem_bo_unmap_gtt(intel_obj->buffer);
      } else {
	 drm_intel_bo_unmap(intel_obj->buffer);
      }
a253 4
   obj->Pointer = NULL;
   obj->Offset = 0;
   obj->Length = 0;

d257 1
a257 1
drm_intel_bo *
a269 17
   if (intel_obj->buffer == NULL) {
      void *sys_buffer = intel_obj->sys_buffer;

      /* only one of buffer and sys_buffer could be non-NULL */
      intel_bufferobj_alloc_buffer(intel, intel_obj);
      intel_obj->sys_buffer = NULL;

      intel_bufferobj_subdata(&intel->ctx,
			      GL_ARRAY_BUFFER_ARB,
			      0,
			      intel_obj->Base.Size,
			      sys_buffer,
			      &intel_obj->Base);
      free(sys_buffer);
      intel_obj->sys_buffer = NULL;
   }

d273 2
a274 6
static void
intel_bufferobj_copy_subdata(struct gl_context *ctx,
			     struct gl_buffer_object *src,
			     struct gl_buffer_object *dst,
			     GLintptr read_offset, GLintptr write_offset,
			     GLsizeiptr size)
d276 1
a276 28
   struct intel_context *intel = intel_context(ctx);
   struct intel_buffer_object *intel_src = intel_buffer_object(src);
   struct intel_buffer_object *intel_dst = intel_buffer_object(dst);
   drm_intel_bo *src_bo, *dst_bo;

   if (size == 0)
      return;

   /* If we're in system memory, just map and memcpy. */
   if (intel_src->sys_buffer || intel_dst->sys_buffer || intel->gen >= 6) {
      /* The same buffer may be used, but note that regions copied may
       * not overlap.
       */
      if (src == dst) {
	 char *ptr = intel_bufferobj_map(ctx, GL_COPY_WRITE_BUFFER,
					 GL_READ_WRITE, dst);
	 memcpy(ptr + write_offset, ptr + read_offset, size);
	 intel_bufferobj_unmap(ctx, GL_COPY_WRITE_BUFFER, dst);
      } else {
	 const char *src_ptr;
	 char *dst_ptr;

	 src_ptr =  intel_bufferobj_map(ctx, GL_COPY_READ_BUFFER,
					GL_READ_ONLY, src);
	 dst_ptr =  intel_bufferobj_map(ctx, GL_COPY_WRITE_BUFFER,
					GL_WRITE_ONLY, dst);

	 memcpy(dst_ptr + write_offset, src_ptr + read_offset, size);
d278 7
a284 166
	 intel_bufferobj_unmap(ctx, GL_COPY_READ_BUFFER, src);
	 intel_bufferobj_unmap(ctx, GL_COPY_WRITE_BUFFER, dst);
      }
      return;
   }

   /* Otherwise, we have real BOs, so blit them. */

   dst_bo = intel_bufferobj_buffer(intel, intel_dst, INTEL_WRITE_PART);
   src_bo = intel_bufferobj_buffer(intel, intel_src, INTEL_READ);

   intel_emit_linear_blit(intel,
			  dst_bo, write_offset,
			  src_bo, read_offset, size);

   /* Since we've emitted some blits to buffers that will (likely) be used
    * in rendering operations in other cache domains in this batch, emit a
    * flush.  Once again, we wish for a domain tracker in libdrm to cover
    * usage inside of a batchbuffer.
    */
   intel_batchbuffer_emit_mi_flush(intel->batch);
}

#if FEATURE_APPLE_object_purgeable
static GLenum
intel_buffer_purgeable(struct gl_context * ctx,
                       drm_intel_bo *buffer,
                       GLenum option)
{
   int retained = 0;

   if (buffer != NULL)
      retained = drm_intel_bo_madvise (buffer, I915_MADV_DONTNEED);

   return retained ? GL_VOLATILE_APPLE : GL_RELEASED_APPLE;
}

static GLenum
intel_buffer_object_purgeable(struct gl_context * ctx,
                              struct gl_buffer_object *obj,
                              GLenum option)
{
   struct intel_buffer_object *intel;

   intel = intel_buffer_object (obj);
   if (intel->buffer != NULL)
      return intel_buffer_purgeable (ctx, intel->buffer, option);

   if (option == GL_RELEASED_APPLE) {
      if (intel->sys_buffer != NULL) {
         free(intel->sys_buffer);
         intel->sys_buffer = NULL;
      }

      return GL_RELEASED_APPLE;
   } else {
      /* XXX Create the buffer and madvise(MADV_DONTNEED)? */
      return intel_buffer_purgeable (ctx,
                                     intel_bufferobj_buffer(intel_context(ctx),
                                                            intel, INTEL_READ),
                                     option);
   }
}

static GLenum
intel_texture_object_purgeable(struct gl_context * ctx,
                               struct gl_texture_object *obj,
                               GLenum option)
{
   struct intel_texture_object *intel;

   intel = intel_texture_object(obj);
   if (intel->mt == NULL || intel->mt->region == NULL)
      return GL_RELEASED_APPLE;

   return intel_buffer_purgeable (ctx, intel->mt->region->buffer, option);
}

static GLenum
intel_render_object_purgeable(struct gl_context * ctx,
                              struct gl_renderbuffer *obj,
                              GLenum option)
{
   struct intel_renderbuffer *intel;

   intel = intel_renderbuffer(obj);
   if (intel->region == NULL)
      return GL_RELEASED_APPLE;

   return intel_buffer_purgeable (ctx, intel->region->buffer, option);
}

static GLenum
intel_buffer_unpurgeable(struct gl_context * ctx,
                         drm_intel_bo *buffer,
                         GLenum option)
{
   int retained;

   retained = 0;
   if (buffer != NULL)
      retained = drm_intel_bo_madvise (buffer, I915_MADV_WILLNEED);

   return retained ? GL_RETAINED_APPLE : GL_UNDEFINED_APPLE;
}

static GLenum
intel_buffer_object_unpurgeable(struct gl_context * ctx,
                                struct gl_buffer_object *obj,
                                GLenum option)
{
   return intel_buffer_unpurgeable (ctx, intel_buffer_object (obj)->buffer, option);
}

static GLenum
intel_texture_object_unpurgeable(struct gl_context * ctx,
                                 struct gl_texture_object *obj,
                                 GLenum option)
{
   struct intel_texture_object *intel;

   intel = intel_texture_object(obj);
   if (intel->mt == NULL || intel->mt->region == NULL)
      return GL_UNDEFINED_APPLE;

   return intel_buffer_unpurgeable (ctx, intel->mt->region->buffer, option);
}

static GLenum
intel_render_object_unpurgeable(struct gl_context * ctx,
                                struct gl_renderbuffer *obj,
                                GLenum option)
{
   struct intel_renderbuffer *intel;

   intel = intel_renderbuffer(obj);
   if (intel->region == NULL)
      return GL_UNDEFINED_APPLE;

   return intel_buffer_unpurgeable (ctx, intel->region->buffer, option);
}
#endif

void
intelInitBufferObjectFuncs(struct dd_function_table *functions)
{
   functions->NewBufferObject = intel_bufferobj_alloc;
   functions->DeleteBuffer = intel_bufferobj_free;
   functions->BufferData = intel_bufferobj_data;
   functions->BufferSubData = intel_bufferobj_subdata;
   functions->GetBufferSubData = intel_bufferobj_get_subdata;
   functions->MapBuffer = intel_bufferobj_map;
   functions->MapBufferRange = intel_bufferobj_map_range;
   functions->FlushMappedBufferRange = intel_bufferobj_flush_mapped_range;
   functions->UnmapBuffer = intel_bufferobj_unmap;
   functions->CopyBufferSubData = intel_bufferobj_copy_subdata;

#if FEATURE_APPLE_object_purgeable
   functions->BufferObjectPurgeable = intel_buffer_object_purgeable;
   functions->TextureObjectPurgeable = intel_texture_object_purgeable;
   functions->RenderObjectPurgeable = intel_render_object_purgeable;

   functions->BufferObjectUnpurgeable = intel_buffer_object_unpurgeable;
   functions->TextureObjectUnpurgeable = intel_texture_object_unpurgeable;
   functions->RenderObjectUnpurgeable = intel_render_object_unpurgeable;
#endif
@


