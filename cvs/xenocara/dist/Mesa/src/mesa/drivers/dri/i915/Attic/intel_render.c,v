head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.04.14;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.14;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.47;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.37;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.37;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.15.24;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.47;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/*
 * Render unclipped vertex buffers by emitting vertices directly to
 * dma buffers.  Use strip/fan hardware acceleration where possible.
 *
 */
#include "main/glheader.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/imports.h"
#include "main/mtypes.h"
#include "main/enums.h"

#include "math/m_xform.h"

#include "tnl/t_context.h"
#include "tnl/t_vertex.h"
#include "tnl/t_pipeline.h"

#include "intel_screen.h"
#include "intel_context.h"
#include "intel_tris.h"
#include "intel_batchbuffer.h"
#include "intel_reg.h"

/*
 * Render unclipped vertex buffers by emitting vertices directly to
 * dma buffers.  Use strip/fan hardware primitives where possible.
 * Try to simulate missing primitives with indexed vertices.
 */
#define HAVE_POINTS      0      /* Has it, but can't use because subpixel has to
                                 * be adjusted for points on the INTEL/I845G
                                 */
#define HAVE_LINES       1
#define HAVE_LINE_STRIPS 1
#define HAVE_TRIANGLES   1
#define HAVE_TRI_STRIPS  1
#define HAVE_TRI_STRIP_1 0      /* has it, template can't use it yet */
#define HAVE_TRI_FANS    1
#define HAVE_POLYGONS    1
#define HAVE_QUADS       0
#define HAVE_QUAD_STRIPS 0

#define HAVE_ELTS        0

static uint32_t hw_prim[GL_POLYGON + 1] = {
   0,
   PRIM3D_LINELIST,
   PRIM3D_LINESTRIP,
   PRIM3D_LINESTRIP,
   PRIM3D_TRILIST,
   PRIM3D_TRISTRIP,
   PRIM3D_TRIFAN,
   0,
   0,
   PRIM3D_POLY
};

static const GLenum reduced_prim[GL_POLYGON + 1] = {
   GL_POINTS,
   GL_LINES,
   GL_LINES,
   GL_LINES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES
};

static const int scale_prim[GL_POLYGON + 1] = {
   0,                           /* fallback case */
   1,
   2,
   2,
   1,
   3,
   3,
   0,                           /* fallback case */
   0,                           /* fallback case */
   3
};


static void
intelDmaPrimitive(struct intel_context *intel, GLenum prim)
{
   if (0)
      fprintf(stderr, "%s %s\n", __FUNCTION__, _mesa_lookup_enum_by_nr(prim));
   INTEL_FIREVERTICES(intel);
   intel->vtbl.reduced_primitive_state(intel, reduced_prim[prim]);
   intel_set_prim(intel, hw_prim[prim]);
}

#define INTEL_NO_VBO_STATE_RESERVED 1500

static INLINE GLuint intel_get_vb_max(struct intel_context *intel)
{
   GLuint ret;

   if (intel->intelScreen->no_vbo) {
      ret = intel->batch.bo->size - INTEL_NO_VBO_STATE_RESERVED;
   } else
      ret = INTEL_VB_SIZE;
   ret /= (intel->vertex_size * 4);
   return ret;
}

static INLINE GLuint intel_get_current_max(struct intel_context *intel)
{
   GLuint ret;

   if (intel->intelScreen->no_vbo) {
      ret = intel_batchbuffer_space(intel);
      ret = ret <= INTEL_NO_VBO_STATE_RESERVED ? 0 : ret - INTEL_NO_VBO_STATE_RESERVED;
   } else
      ret = (INTEL_VB_SIZE - intel->prim.current_offset);

   return ret / (intel->vertex_size * 4);
}

#define LOCAL_VARS struct intel_context *intel = intel_context(ctx)
#define INIT( prim ) 				\
do {						\
   intelDmaPrimitive( intel, prim );		\
} while (0)

#define FLUSH() INTEL_FIREVERTICES(intel)

#define GET_SUBSEQUENT_VB_MAX_VERTS() intel_get_vb_max(intel)
#define GET_CURRENT_VB_MAX_VERTS() intel_get_current_max(intel)

#define ALLOC_VERTS(nr) intel_get_prim_space(intel, nr)

#define EMIT_VERTS( ctx, j, nr, buf ) \
  _tnl_emit_vertices_to_buffer(ctx, j, (j)+(nr), buf )

#define TAG(x) intel_##x
#include "tnl_dd/t_dd_dmatmp.h"


/**********************************************************************/
/*                          Render pipeline stage                     */
/**********************************************************************/

/* Heuristic to choose between the two render paths:  
 */
static bool
choose_render(struct intel_context *intel, struct vertex_buffer *VB)
{
   int vertsz = intel->vertex_size;
   int cost_render = 0;
   int cost_fallback = 0;
   int nr_prims = 0;
   int nr_rprims = 0;
   int nr_rverts = 0;
   int rprim = intel->reduced_primitive;
   int i = 0;

   for (i = 0; i < VB->PrimitiveCount; i++) {
      GLuint prim = VB->Primitive[i].mode;
      GLuint length = VB->Primitive[i].count;

      if (!length)
         continue;

      nr_prims++;
      nr_rverts += length * scale_prim[prim & PRIM_MODE_MASK];

      if (reduced_prim[prim & PRIM_MODE_MASK] != rprim) {
         nr_rprims++;
         rprim = reduced_prim[prim & PRIM_MODE_MASK];
      }
   }

   /* One point for each generated primitive:
    */
   cost_render = nr_prims;
   cost_fallback = nr_rprims;

   /* One point for every 1024 dwords (4k) of dma:
    */
   cost_render += (vertsz * i) / 1024;
   cost_fallback += (vertsz * nr_rverts) / 1024;

   if (0)
      fprintf(stderr, "cost render: %d fallback: %d\n",
              cost_render, cost_fallback);

   if (cost_render > cost_fallback)
      return false;

   return true;
}


static GLboolean
intel_run_render(struct gl_context * ctx, struct tnl_pipeline_stage *stage)
{
   struct intel_context *intel = intel_context(ctx);
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct vertex_buffer *VB = &tnl->vb;
   GLuint i;

   intel->vtbl.render_prevalidate( intel );

   /* Don't handle clipping or indexed vertices.
    */
   if (intel->RenderIndex != 0 ||
       !intel_validate_render(ctx, VB) || !choose_render(intel, VB)) {
      return true;
   }

   tnl->clipspace.new_inputs |= VERT_BIT_POS;

   tnl->Driver.Render.Start(ctx);

   for (i = 0; i < VB->PrimitiveCount; i++) {
      GLuint prim = _tnl_translate_prim(&VB->Primitive[i]);
      GLuint start = VB->Primitive[i].start;
      GLuint length = VB->Primitive[i].count;

      if (!length)
         continue;

      intel_render_tab_verts[prim & PRIM_MODE_MASK] (ctx, start,
                                                     start + length, prim);
   }

   tnl->Driver.Render.Finish(ctx);

   INTEL_FIREVERTICES(intel);

   return false;             /* finished the pipe */
}

static const struct tnl_pipeline_stage _intel_render_stage = {
   "intel render",
   NULL,
   NULL,
   NULL,
   NULL,
   intel_run_render             /* run */
};

const struct tnl_pipeline_stage *intel_pipeline[] = {
   &_tnl_vertex_transform_stage,
   &_tnl_normal_transform_stage,
   &_tnl_lighting_stage,
   &_tnl_fog_coordinate_stage,
   &_tnl_texgen_stage,
   &_tnl_texture_transform_stage,
   &_tnl_point_attenuation_stage,
   &_tnl_vertex_program_stage,
#if 1
   &_intel_render_stage,        /* ADD: unclipped rastersetup-to-dma */
#endif
   &_tnl_render_stage,
   0,
};
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.8
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d175 1
a175 1
static GLboolean
d218 1
a218 1
      return GL_FALSE;
d220 1
a220 1
   return GL_TRUE;
d238 1
a238 1
      return GL_TRUE;
d261 1
a261 1
   return GL_FALSE;             /* finished the pipe */
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d122 2
d128 3
a130 3
   if (intel->intelScreen->no_vbo)
      ret = intel->batch->size - 1500;
   else
d138 7
d146 1
a146 4
   if (intel->intelScreen->no_vbo)
      return intel_get_vb_max(intel);
   else
      return (INTEL_VB_SIZE - intel->prim.current_offset) / (intel->vertex_size * 4);
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d40 2
d219 1
a219 1
intel_run_render(GLcontext * ctx, struct tnl_pipeline_stage *stage)
a268 1
   &_tnl_vertex_cull_stage,
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d120 1
a120 1
static inline GLuint intel_get_vb_max(struct intel_context *intel)
d132 1
a132 1
static inline GLuint intel_get_current_max(struct intel_context *intel)
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d33 6
a38 6
#include "glheader.h"
#include "context.h"
#include "macros.h"
#include "imports.h"
#include "mtypes.h"
#include "enums.h"
d70 1
a70 1
static GLuint hw_prim[GL_POLYGON + 1] = {
d117 1
a117 1
   intelStartInlinePrimitive(intel, hw_prim[prim], LOOP_CLIPRECTS);
d120 20
d149 2
a150 3
#define GET_SUBSEQUENT_VB_MAX_VERTS() \
  ((intel->batch->size - 1500) / (intel->vertex_size*4))
#define GET_CURRENT_VB_MAX_VERTS() GET_SUBSEQUENT_VB_MAX_VERTS()
d152 1
a152 2
#define ALLOC_VERTS( nr ) \
   intelExtendInlinePrimitive( intel, (nr) * intel->vertex_size )
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d42 1
d55 3
a57 3
#define HAVE_POINTS      0  /* Has it, but can't use because subpixel has to
			     * be adjusted for points on the INTEL/I845G
			     */
d62 1
a62 1
#define HAVE_TRI_STRIP_1 0  /* has it, template can't use it yet */
d70 1
a70 1
static GLuint hw_prim[GL_POLYGON+1] = {
d83 1
a83 1
static const GLenum reduced_prim[GL_POLYGON+1] = {  
d96 2
a97 2
static const int scale_prim[GL_POLYGON+1] = {  
   0,				/* fallback case */
d104 2
a105 2
   0,				/* fallback case */
   0,				/* fallback case */
d110 2
a111 1
static void intelDmaPrimitive( intelContextPtr intel, GLenum prim )
d113 2
a114 1
   if (0) fprintf(stderr, "%s %s\n", __FUNCTION__, _mesa_lookup_enum_by_nr(prim));
d116 2
a117 2
   intel->vtbl.reduced_primitive_state( intel, reduced_prim[prim] );
   intelStartInlinePrimitive( intel, hw_prim[prim] );
d121 1
a121 1
#define LOCAL_VARS intelContextPtr intel = INTEL_CONTEXT(ctx)
d126 2
a127 1
#define FLUSH()  INTEL_FIREVERTICES( intel )
d130 1
a130 1
  (((intel->alloc.size / 2) - 1500) / (intel->vertex_size*4))
d135 1
a135 1
  
d137 1
a137 1
  _tnl_emit_vertices_to_buffer(ctx, j, (j)+(nr), buf )  
d141 2
a142 2
  
  
d149 2
a150 2
static GLboolean choose_render( intelContextPtr intel,
				struct vertex_buffer *VB )
d160 2
a161 2
   
   for (i = 0 ; i < VB->PrimitiveCount ; i++) {
d166 1
a166 1
	 continue;
d172 2
a173 2
	 nr_rprims++;
	 rprim = reduced_prim[prim & PRIM_MODE_MASK];
d184 2
a185 2
   cost_render += (vertsz * i) / 1024; 
   cost_fallback += (vertsz * nr_rverts) / 1024; 
d189 1
a189 1
	      cost_render, cost_fallback);
d191 1
a191 1
   if (cost_render > cost_fallback) 
d198 2
a199 2
static GLboolean intel_run_render( GLcontext *ctx, 
				 struct tnl_pipeline_stage *stage )
d201 1
a201 1
   intelContextPtr intel = INTEL_CONTEXT(ctx);
d206 2
d210 2
a211 3
   if (intel->RenderIndex != 0 || 
       !intel_validate_render( ctx, VB ) || 
       !choose_render( intel, VB )) {
d217 3
a219 4
   tnl->Driver.Render.Start( ctx );
   
   for (i = 0 ; i < VB->PrimitiveCount ; i++)
   {
d225 1
a225 1
	 continue;
d227 2
a228 2
      intel_render_tab_verts[prim & PRIM_MODE_MASK]( ctx, start, start + length,
						     prim );
a229 2
      
   tnl->Driver.Render.Finish( ctx );
d231 5
a235 1
   return GL_FALSE;     /* finished the pipe */
d238 1
a238 2
const struct tnl_pipeline_stage _intel_render_stage =
{
d244 18
a261 1
   intel_run_render	/* run */
@


1.1
log
@Initial revision
@
text
@d216 1
a216 1
      GLuint prim = VB->Primitive[i].mode;
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d33 6
a38 8
#include "main/glheader.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/imports.h"
#include "main/mtypes.h"
#include "main/enums.h"

#include "math/m_xform.h"
a41 1
#include "tnl/t_pipeline.h"
d54 3
a56 3
#define HAVE_POINTS      0      /* Has it, but can't use because subpixel has to
                                 * be adjusted for points on the INTEL/I845G
                                 */
d61 1
a61 1
#define HAVE_TRI_STRIP_1 0      /* has it, template can't use it yet */
d69 1
a69 1
static uint32_t hw_prim[GL_POLYGON + 1] = {
d82 1
a82 1
static const GLenum reduced_prim[GL_POLYGON + 1] = {
d95 2
a96 2
static const int scale_prim[GL_POLYGON + 1] = {
   0,                           /* fallback case */
d103 2
a104 2
   0,                           /* fallback case */
   0,                           /* fallback case */
d109 1
a109 2
static void
intelDmaPrimitive(struct intel_context *intel, GLenum prim)
d111 1
a111 2
   if (0)
      fprintf(stderr, "%s %s\n", __FUNCTION__, _mesa_lookup_enum_by_nr(prim));
d113 2
a114 2
   intel->vtbl.reduced_primitive_state(intel, reduced_prim[prim]);
   intel_set_prim(intel, hw_prim[prim]);
a116 14
static INLINE GLuint intel_get_vb_max(struct intel_context *intel)
{
   GLuint ret;

   if (intel->intelScreen->no_vbo)
      ret = intel->batch->size - 1500;
   else
      ret = INTEL_VB_SIZE;
   ret /= (intel->vertex_size * 4);
   return ret;
}

static INLINE GLuint intel_get_current_max(struct intel_context *intel)
{
d118 1
a118 7
   if (intel->intelScreen->no_vbo)
      return intel_get_vb_max(intel);
   else
      return (INTEL_VB_SIZE - intel->prim.current_offset) / (intel->vertex_size * 4);
}

#define LOCAL_VARS struct intel_context *intel = intel_context(ctx)
d123 1
d125 7
a131 7
#define FLUSH() INTEL_FIREVERTICES(intel)

#define GET_SUBSEQUENT_VB_MAX_VERTS() intel_get_vb_max(intel)
#define GET_CURRENT_VB_MAX_VERTS() intel_get_current_max(intel)

#define ALLOC_VERTS(nr) intel_get_prim_space(intel, nr)

d133 1
a133 1
  _tnl_emit_vertices_to_buffer(ctx, j, (j)+(nr), buf )
d137 2
a138 2


d145 2
a146 2
static GLboolean
choose_render(struct intel_context *intel, struct vertex_buffer *VB)
d156 2
a157 2

   for (i = 0; i < VB->PrimitiveCount; i++) {
d162 1
a162 1
         continue;
d168 2
a169 2
         nr_rprims++;
         rprim = reduced_prim[prim & PRIM_MODE_MASK];
d180 2
a181 2
   cost_render += (vertsz * i) / 1024;
   cost_fallback += (vertsz * nr_rverts) / 1024;
d185 1
a185 1
              cost_render, cost_fallback);
d187 1
a187 1
   if (cost_render > cost_fallback)
d194 2
a195 2
static GLboolean
intel_run_render(struct gl_context * ctx, struct tnl_pipeline_stage *stage)
d197 1
a197 1
   struct intel_context *intel = intel_context(ctx);
a201 2
   intel->vtbl.render_prevalidate( intel );

d204 3
a206 2
   if (intel->RenderIndex != 0 ||
       !intel_validate_render(ctx, VB) || !choose_render(intel, VB)) {
d212 5
a216 4
   tnl->Driver.Render.Start(ctx);

   for (i = 0; i < VB->PrimitiveCount; i++) {
      GLuint prim = _tnl_translate_prim(&VB->Primitive[i]);
d221 1
a221 1
         continue;
d223 2
a224 2
      intel_render_tab_verts[prim & PRIM_MODE_MASK] (ctx, start,
                                                     start + length, prim);
d226 2
d229 1
a229 5
   tnl->Driver.Render.Finish(ctx);

   INTEL_FIREVERTICES(intel);

   return GL_FALSE;             /* finished the pipe */
d232 2
a233 1
static const struct tnl_pipeline_stage _intel_render_stage = {
d239 1
a239 17
   intel_run_render             /* run */
};

const struct tnl_pipeline_stage *intel_pipeline[] = {
   &_tnl_vertex_transform_stage,
   &_tnl_normal_transform_stage,
   &_tnl_lighting_stage,
   &_tnl_fog_coordinate_stage,
   &_tnl_texgen_stage,
   &_tnl_texture_transform_stage,
   &_tnl_point_attenuation_stage,
   &_tnl_vertex_program_stage,
#if 1
   &_intel_render_stage,        /* ADD: unclipped rastersetup-to-dma */
#endif
   &_tnl_render_stage,
   0,
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@a121 2
#define INTEL_NO_VBO_STATE_RESERVED 1500

d126 3
a128 3
   if (intel->intelScreen->no_vbo) {
      ret = intel->batch.bo->size - INTEL_NO_VBO_STATE_RESERVED;
   } else
a135 1
   GLuint ret;
d137 4
a140 7
   if (intel->intelScreen->no_vbo) {
      ret = intel_batchbuffer_space(intel);
      ret = ret <= INTEL_NO_VBO_STATE_RESERVED ? 0 : ret - INTEL_NO_VBO_STATE_RESERVED;
   } else
      ret = (INTEL_VB_SIZE - intel->prim.current_offset);

   return ret / (intel->vertex_size * 4);
d169 1
a169 1
static bool
d212 1
a212 1
      return false;
d214 1
a214 1
   return true;
d232 1
a232 1
      return true;
d255 1
a255 1
   return false;             /* finished the pipe */
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
@


