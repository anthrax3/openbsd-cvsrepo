head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.4
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.9;
commitid	WPD6rgPryPkvXOr9;

1.9
date	2013.09.05.14.04.13;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.7;

1.7
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.22.20.04.22;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.14;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.35;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.35;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.28.14;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.15.21;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.47;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "main/mtypes.h"
#include "main/enums.h"
#include "main/macros.h"
#include "main/colormac.h"
#include "main/samplerobj.h"

#include "intel_mipmap_tree.h"
#include "intel_tex.h"

#include "i915_context.h"
#include "i915_reg.h"


static GLuint
translate_texture_format(mesa_format mesa_format, GLenum DepthMode)
{
   switch (mesa_format) {
   case MESA_FORMAT_L_UNORM8:
      return MAPSURF_8BIT | MT_8BIT_L8;
   case MESA_FORMAT_I_UNORM8:
      return MAPSURF_8BIT | MT_8BIT_I8;
   case MESA_FORMAT_A_UNORM8:
      return MAPSURF_8BIT | MT_8BIT_A8;
   case MESA_FORMAT_L8A8_UNORM:
      return MAPSURF_16BIT | MT_16BIT_AY88;
   case MESA_FORMAT_B5G6R5_UNORM:
      return MAPSURF_16BIT | MT_16BIT_RGB565;
   case MESA_FORMAT_B5G5R5A1_UNORM:
      return MAPSURF_16BIT | MT_16BIT_ARGB1555;
   case MESA_FORMAT_B4G4R4A4_UNORM:
      return MAPSURF_16BIT | MT_16BIT_ARGB4444;
   case MESA_FORMAT_B8G8R8A8_SRGB:
   case MESA_FORMAT_B8G8R8A8_UNORM:
      return MAPSURF_32BIT | MT_32BIT_ARGB8888;
   case MESA_FORMAT_B8G8R8X8_UNORM:
      return MAPSURF_32BIT | MT_32BIT_XRGB8888;
   case MESA_FORMAT_R8G8B8A8_UNORM:
      return MAPSURF_32BIT | MT_32BIT_ABGR8888;
   case MESA_FORMAT_YCBCR_REV:
      return (MAPSURF_422 | MT_422_YCRCB_NORMAL);
   case MESA_FORMAT_YCBCR:
      return (MAPSURF_422 | MT_422_YCRCB_SWAPY);
   case MESA_FORMAT_RGB_FXT1:
   case MESA_FORMAT_RGBA_FXT1:
      return (MAPSURF_COMPRESSED | MT_COMPRESS_FXT1);
   case MESA_FORMAT_Z_UNORM16:
      if (DepthMode == GL_ALPHA)
          return (MAPSURF_16BIT | MT_16BIT_A16);
      else if (DepthMode == GL_INTENSITY)
          return (MAPSURF_16BIT | MT_16BIT_I16);
      else
          return (MAPSURF_16BIT | MT_16BIT_L16);
   case MESA_FORMAT_RGBA_DXT1:
   case MESA_FORMAT_RGB_DXT1:
   case MESA_FORMAT_SRGB_DXT1:
   case MESA_FORMAT_SRGBA_DXT1:
      return (MAPSURF_COMPRESSED | MT_COMPRESS_DXT1);
   case MESA_FORMAT_RGBA_DXT3:
   case MESA_FORMAT_SRGBA_DXT3:
      return (MAPSURF_COMPRESSED | MT_COMPRESS_DXT2_3);
   case MESA_FORMAT_RGBA_DXT5:
   case MESA_FORMAT_SRGBA_DXT5:
      return (MAPSURF_COMPRESSED | MT_COMPRESS_DXT4_5);
   case MESA_FORMAT_Z24_UNORM_S8_UINT:
   case MESA_FORMAT_Z24_UNORM_X8_UINT:
      if (DepthMode == GL_ALPHA)
	 return (MAPSURF_32BIT | MT_32BIT_x8A24);
      else if (DepthMode == GL_INTENSITY)
	 return (MAPSURF_32BIT | MT_32BIT_x8I24);
      else
	 return (MAPSURF_32BIT | MT_32BIT_x8L24);
   default:
      fprintf(stderr, "%s: bad image format %s\n", __FUNCTION__,
	      _mesa_get_format_name(mesa_format));
      abort();
      return 0;
   }
}




/* The i915 (and related graphics cores) do not support GL_CLAMP.  The
 * Intel drivers for "other operating systems" implement GL_CLAMP as
 * GL_CLAMP_TO_EDGE, so the same is done here.
 */
static GLuint
translate_wrap_mode(GLenum wrap)
{
   switch (wrap) {
   case GL_REPEAT:
      return TEXCOORDMODE_WRAP;
   case GL_CLAMP:
      return TEXCOORDMODE_CLAMP_EDGE;   /* not quite correct */
   case GL_CLAMP_TO_EDGE:
      return TEXCOORDMODE_CLAMP_EDGE;
   case GL_CLAMP_TO_BORDER:
      return TEXCOORDMODE_CLAMP_BORDER;
   case GL_MIRRORED_REPEAT:
      return TEXCOORDMODE_MIRROR;
   default:
      return TEXCOORDMODE_WRAP;
   }
}



/* Recalculate all state from scratch.  Perhaps not the most
 * efficient, but this has gotten complex enough that we need
 * something which is understandable and reliable.
 */
static bool
i915_update_tex_unit(struct intel_context *intel, GLuint unit, GLuint ss3)
{
   struct gl_context *ctx = &intel->ctx;
   struct i915_context *i915 = i915_context(ctx);
   struct gl_texture_unit *tUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *tObj = tUnit->_Current;
   struct intel_texture_object *intelObj = intel_texture_object(tObj);
   struct gl_texture_image *firstImage;
   struct gl_sampler_object *sampler = _mesa_get_samplerobj(ctx, unit);
   GLuint *state = i915->state.Tex[unit], format;
   GLint lodbias, aniso = 0;
   GLubyte border[4];
   GLfloat maxlod;

   memset(state, 0, sizeof(*state));

   /*We need to refcount these. */

   if (i915->state.tex_buffer[unit] != NULL) {
       drm_intel_bo_unreference(i915->state.tex_buffer[unit]);
       i915->state.tex_buffer[unit] = NULL;
   }

   if (!intel_finalize_mipmap_tree(intel, unit))
      return false;

   /* Get first image here, since intelObj->firstLevel will get set in
    * the intel_finalize_mipmap_tree() call above.
    */
   firstImage = tObj->Image[0][tObj->BaseLevel];

   drm_intel_bo_reference(intelObj->mt->region->bo);
   i915->state.tex_buffer[unit] = intelObj->mt->region->bo;
   i915->state.tex_offset[unit] = intelObj->mt->offset;

   format = translate_texture_format(firstImage->TexFormat,
				     tObj->DepthMode);

   state[I915_TEXREG_MS3] =
      (((firstImage->Height - 1) << MS3_HEIGHT_SHIFT) |
       ((firstImage->Width - 1) << MS3_WIDTH_SHIFT) | format);

   if (intelObj->mt->region->tiling != I915_TILING_NONE) {
      state[I915_TEXREG_MS3] |= MS3_TILED_SURFACE;
      if (intelObj->mt->region->tiling == I915_TILING_Y)
	 state[I915_TEXREG_MS3] |= MS3_TILE_WALK;
   }

   /* We get one field with fraction bits for the maximum addressable
    * (lowest resolution) LOD.  Use it to cover both MAX_LEVEL and
    * MAX_LOD.
    */
   maxlod = MIN2(sampler->MaxLod, tObj->_MaxLevel - tObj->BaseLevel);
   state[I915_TEXREG_MS4] =
      ((((intelObj->mt->region->pitch / 4) - 1) << MS4_PITCH_SHIFT) |
       MS4_CUBE_FACE_ENA_MASK |
       (U_FIXED(CLAMP(maxlod, 0.0, 11.0), 2) << MS4_MAX_LOD_SHIFT) |
       ((firstImage->Depth - 1) << MS4_VOLUME_DEPTH_SHIFT));


   {
      GLuint minFilt, mipFilt, magFilt;

      switch (sampler->MinFilter) {
      case GL_NEAREST:
         minFilt = FILTER_NEAREST;
         mipFilt = MIPFILTER_NONE;
         break;
      case GL_LINEAR:
         minFilt = FILTER_LINEAR;
         mipFilt = MIPFILTER_NONE;
         break;
      case GL_NEAREST_MIPMAP_NEAREST:
         minFilt = FILTER_NEAREST;
         mipFilt = MIPFILTER_NEAREST;
         break;
      case GL_LINEAR_MIPMAP_NEAREST:
         minFilt = FILTER_LINEAR;
         mipFilt = MIPFILTER_NEAREST;
         break;
      case GL_NEAREST_MIPMAP_LINEAR:
         minFilt = FILTER_NEAREST;
         mipFilt = MIPFILTER_LINEAR;
         break;
      case GL_LINEAR_MIPMAP_LINEAR:
         minFilt = FILTER_LINEAR;
         mipFilt = MIPFILTER_LINEAR;
         break;
      default:
         return false;
      }

      if (sampler->MaxAnisotropy > 1.0) {
         minFilt = FILTER_ANISOTROPIC;
         magFilt = FILTER_ANISOTROPIC;
         if (sampler->MaxAnisotropy > 2.0)
            aniso = SS2_MAX_ANISO_4;
         else
            aniso = SS2_MAX_ANISO_2;
      }
      else {
         switch (sampler->MagFilter) {
         case GL_NEAREST:
            magFilt = FILTER_NEAREST;
            break;
         case GL_LINEAR:
            magFilt = FILTER_LINEAR;
            break;
         default:
            return false;
         }
      }

      lodbias = (int) ((tUnit->LodBias + sampler->LodBias) * 16.0);
      if (lodbias < -256)
          lodbias = -256;
      if (lodbias > 255)
          lodbias = 255;
      state[I915_TEXREG_SS2] = ((lodbias << SS2_LOD_BIAS_SHIFT) & 
                                SS2_LOD_BIAS_MASK);

      /* YUV conversion:
       */
      if (firstImage->TexFormat == MESA_FORMAT_YCBCR ||
          firstImage->TexFormat == MESA_FORMAT_YCBCR_REV)
         state[I915_TEXREG_SS2] |= SS2_COLORSPACE_CONVERSION;

      /* Shadow:
       */
      if (sampler->CompareMode == GL_COMPARE_R_TO_TEXTURE_ARB &&
          tObj->Target != GL_TEXTURE_3D) {
         if (tObj->Target == GL_TEXTURE_1D) 
            return false;

         state[I915_TEXREG_SS2] |=
            (SS2_SHADOW_ENABLE |
             intel_translate_shadow_compare_func(sampler->CompareFunc));

         minFilt = FILTER_4X4_FLAT;
         magFilt = FILTER_4X4_FLAT;
      }

      state[I915_TEXREG_SS2] |= ((minFilt << SS2_MIN_FILTER_SHIFT) |
                                 (mipFilt << SS2_MIP_FILTER_SHIFT) |
                                 (magFilt << SS2_MAG_FILTER_SHIFT) |
                                 aniso);
   }

   {
      GLenum ws = sampler->WrapS;
      GLenum wt = sampler->WrapT;
      GLenum wr = sampler->WrapR;
      float minlod;

      /* We program 1D textures as 2D textures, so the 2D texcoord could
       * result in sampling border values if we don't set the T wrap to
       * repeat.
       */
      if (tObj->Target == GL_TEXTURE_1D)
	 wt = GL_REPEAT;

      /* 3D textures don't seem to respect the border color.
       * Fallback if there's ever a danger that they might refer to
       * it.  
       * 
       * Effectively this means fallback on 3D clamp or
       * clamp_to_border.
       */
      if (tObj->Target == GL_TEXTURE_3D &&
          (sampler->MinFilter != GL_NEAREST ||
           sampler->MagFilter != GL_NEAREST) &&
          (ws == GL_CLAMP ||
           wt == GL_CLAMP ||
           wr == GL_CLAMP ||
           ws == GL_CLAMP_TO_BORDER ||
           wt == GL_CLAMP_TO_BORDER || wr == GL_CLAMP_TO_BORDER))
         return false;

      /* Only support TEXCOORDMODE_CLAMP_EDGE and TEXCOORDMODE_CUBE (not 
       * used) when using cube map texture coordinates
       */
      if (tObj->Target == GL_TEXTURE_CUBE_MAP_ARB &&
          (((ws != GL_CLAMP) && (ws != GL_CLAMP_TO_EDGE)) ||
           ((wt != GL_CLAMP) && (wt != GL_CLAMP_TO_EDGE))))
          return false;

      /*
       * According to 3DSTATE_MAP_STATE at page of 104 in Bspec
       * Vol3d 3D Instructions:
       *   [DevGDG and DevAlv]: Must be a power of 2 for cube maps.
       *   [DevLPT, DevCST and DevBLB]: If not a power of 2, cube maps
       *      must have all faces enabled.
       *
       * But, as I tested on pineview(DevBLB derived), the rendering is
       * bad(you will find the color isn't samplered right in some
       * fragments). After checking, it seems that the texture layout is
       * wrong: making the width and height align of 4(although this
       * doesn't make much sense) will fix this issue and also broke some
       * others. Well, Bspec mentioned nothing about the layout alignment
       * and layout for NPOT cube map.  I guess the Bspec just assume it's
       * a POT cube map.
       *
       * Thus, I guess we need do this for other platforms as well.
       */
      if (tObj->Target == GL_TEXTURE_CUBE_MAP_ARB &&
          !is_power_of_two(firstImage->Height))
         return false;

      state[I915_TEXREG_SS3] = ss3;     /* SS3_NORMALIZED_COORDS */

      state[I915_TEXREG_SS3] |=
         ((translate_wrap_mode(ws) << SS3_TCX_ADDR_MODE_SHIFT) |
          (translate_wrap_mode(wt) << SS3_TCY_ADDR_MODE_SHIFT) |
          (translate_wrap_mode(wr) << SS3_TCZ_ADDR_MODE_SHIFT));

      minlod = MIN2(sampler->MinLod, tObj->_MaxLevel - tObj->BaseLevel);
      state[I915_TEXREG_SS3] |= (unit << SS3_TEXTUREMAP_INDEX_SHIFT);
      state[I915_TEXREG_SS3] |= (U_FIXED(CLAMP(minlod, 0.0, 11.0), 4) <<
				 SS3_MIN_LOD_SHIFT);

   }

   if (sampler->sRGBDecode == GL_DECODE_EXT &&
       (_mesa_get_srgb_format_linear(firstImage->TexFormat) !=
        firstImage->TexFormat)) {
      state[I915_TEXREG_SS2] |= SS2_REVERSE_GAMMA_ENABLE;
   }

   /* convert border color from float to ubyte */
   CLAMPED_FLOAT_TO_UBYTE(border[0], sampler->BorderColor.f[0]);
   CLAMPED_FLOAT_TO_UBYTE(border[1], sampler->BorderColor.f[1]);
   CLAMPED_FLOAT_TO_UBYTE(border[2], sampler->BorderColor.f[2]);
   CLAMPED_FLOAT_TO_UBYTE(border[3], sampler->BorderColor.f[3]);

   if (firstImage->_BaseFormat == GL_DEPTH_COMPONENT) {
      /* GL specs that border color for depth textures is taken from the
       * R channel, while the hardware uses A.  Spam R into all the channels
       * for safety.
       */
      state[I915_TEXREG_SS4] = PACK_COLOR_8888(border[0],
					       border[0],
					       border[0],
					       border[0]);
   } else {
      state[I915_TEXREG_SS4] = PACK_COLOR_8888(border[3],
					       border[0],
					       border[1],
					       border[2]);
   }


   I915_ACTIVESTATE(i915, I915_UPLOAD_TEX(unit), true);
   /* memcmp was already disabled, but definitely won't work as the
    * region might now change and that wouldn't be detected:
    */
   I915_STATECHANGE(i915, I915_UPLOAD_TEX(unit));


#if 0
   DBG(TEXTURE, "state[I915_TEXREG_SS2] = 0x%x\n", state[I915_TEXREG_SS2]);
   DBG(TEXTURE, "state[I915_TEXREG_SS3] = 0x%x\n", state[I915_TEXREG_SS3]);
   DBG(TEXTURE, "state[I915_TEXREG_SS4] = 0x%x\n", state[I915_TEXREG_SS4]);
   DBG(TEXTURE, "state[I915_TEXREG_MS2] = 0x%x\n", state[I915_TEXREG_MS2]);
   DBG(TEXTURE, "state[I915_TEXREG_MS3] = 0x%x\n", state[I915_TEXREG_MS3]);
   DBG(TEXTURE, "state[I915_TEXREG_MS4] = 0x%x\n", state[I915_TEXREG_MS4]);
#endif

   return true;
}




void
i915UpdateTextureState(struct intel_context *intel)
{
   bool ok = true;
   GLuint i;

   for (i = 0; i < I915_TEX_UNITS && ok; i++) {
      if (intel->ctx.Texture.Unit[i]._Current) {
         switch (intel->ctx.Texture.Unit[i]._Current->Target) {
         case GL_TEXTURE_1D:
         case GL_TEXTURE_2D:
         case GL_TEXTURE_CUBE_MAP:
         case GL_TEXTURE_3D:
            ok = i915_update_tex_unit(intel, i, SS3_NORMALIZED_COORDS);
            break;
         case GL_TEXTURE_RECTANGLE:
            ok = i915_update_tex_unit(intel, i, 0);
            break;
         default:
            ok = false;
            break;
         }
      } else {
         struct i915_context *i915 = i915_context(&intel->ctx);
         if (i915->state.active & I915_UPLOAD_TEX(i))
            I915_ACTIVESTATE(i915, I915_UPLOAD_TEX(i), false);

         if (i915->state.tex_buffer[i] != NULL) {
            drm_intel_bo_unreference(i915->state.tex_buffer[i]);
            i915->state.tex_buffer[i] = NULL;
         }
      }
   }

   FALLBACK(intel, I915_FALLBACK_TEXTURE, !ok);
}
@


1.10
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.9
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d42 1
a42 1
translate_texture_format(gl_format mesa_format, GLenum DepthMode)
d45 1
a45 1
   case MESA_FORMAT_L8:
d47 1
a47 1
   case MESA_FORMAT_I8:
d49 1
a49 1
   case MESA_FORMAT_A8:
d51 1
a51 1
   case MESA_FORMAT_AL88:
d53 1
a53 1
   case MESA_FORMAT_RGB565:
d55 1
a55 1
   case MESA_FORMAT_ARGB1555:
d57 1
a57 1
   case MESA_FORMAT_ARGB4444:
d59 2
a60 2
   case MESA_FORMAT_SARGB8:
   case MESA_FORMAT_ARGB8888:
d62 1
a62 1
   case MESA_FORMAT_XRGB8888:
d64 1
a64 1
   case MESA_FORMAT_RGBA8888_REV:
d73 1
a73 1
   case MESA_FORMAT_Z16:
d91 2
a92 2
   case MESA_FORMAT_S8_Z24:
   case MESA_FORMAT_X8_Z24:
d420 13
a432 20
      switch (intel->ctx.Texture.Unit[i]._ReallyEnabled) {
      case TEXTURE_1D_BIT:
      case TEXTURE_2D_BIT:
      case TEXTURE_CUBE_BIT:
      case TEXTURE_3D_BIT:
         ok = i915_update_tex_unit(intel, i, SS3_NORMALIZED_COORDS);
         break;
      case TEXTURE_RECT_BIT:
         ok = i915_update_tex_unit(intel, i, 0);
         break;
      case 0:{
            struct i915_context *i915 = i915_context(&intel->ctx);
            if (i915->state.active & I915_UPLOAD_TEX(i))
               I915_ACTIVESTATE(i915, I915_UPLOAD_TEX(i), false);

	    if (i915->state.tex_buffer[i] != NULL) {
	       drm_intel_bo_unreference(i915->state.tex_buffer[i]);
	       i915->state.tex_buffer[i] = NULL;
	    }

d435 9
a443 3
      default:
         ok = false;
         break;
@


1.8
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d59 1
d64 2
d82 2
d86 1
d89 1
d100 2
a101 1
      fprintf(stderr, "%s: bad image format %x\n", __FUNCTION__, mesa_format);
d139 1
a139 1
static GLboolean
d149 1
a149 1
   GLuint *state = i915->state.Tex[unit], format, pitch;
d154 1
a154 1
   memset(state, 0, sizeof(state));
d164 1
a164 1
      return GL_FALSE;
d171 3
a173 3
   drm_intel_bo_reference(intelObj->mt->region->buffer);
   i915->state.tex_buffer[unit] = intelObj->mt->region->buffer;
   i915->state.tex_offset[unit] = 0; /* Always the origin of the miptree */
d176 1
a176 2
				     sampler->DepthMode);
   pitch = intelObj->mt->region->pitch * intelObj->mt->cpp;
d194 1
a194 1
      ((((pitch / 4) - 1) << MS4_PITCH_SHIFT) |
d229 1
a229 1
         return GL_FALSE;
d249 1
a249 1
            return GL_FALSE;
d272 1
a272 1
            return GL_FALSE;
d316 1
a316 1
         return GL_FALSE;
d324 23
a346 1
          return GL_FALSE;
d362 6
d391 1
a391 1
   I915_ACTIVESTATE(i915, I915_UPLOAD_TEX(unit), GL_TRUE);
d407 1
a407 1
   return GL_TRUE;
d416 1
a416 1
   GLboolean ok = GL_TRUE;
d433 1
a433 1
               I915_ACTIVESTATE(i915, I915_UPLOAD_TEX(i), GL_FALSE);
d443 1
a443 1
         ok = GL_FALSE;
@


1.7
log
@Merge Mesa 7.10.3
@
text
@d32 1
d42 1
a42 2
translate_texture_format(gl_format mesa_format, GLuint internal_format,
			 GLenum DepthMode)
d85 1
d140 1
d161 1
a161 1
   firstImage = tObj->Image[0][intelObj->firstLevel];
d168 1
a168 2
				     firstImage->InternalFormat,
				     tObj->DepthMode);
d185 1
a185 1
   maxlod = MIN2(tObj->MaxLod, tObj->_MaxLevel - tObj->BaseLevel);
d196 1
a196 1
      switch (tObj->MinFilter) {
d225 1
a225 1
      if (tObj->MaxAnisotropy > 1.0) {
d228 1
a228 1
         if (tObj->MaxAnisotropy > 2.0)
d234 1
a234 1
         switch (tObj->MagFilter) {
d246 1
a246 1
      lodbias = (int) ((tUnit->LodBias + tObj->LodBias) * 16.0);
d262 1
a262 1
      if (tObj->CompareMode == GL_COMPARE_R_TO_TEXTURE_ARB &&
d269 1
a269 1
             intel_translate_shadow_compare_func(tObj->CompareFunc));
d282 3
a284 3
      GLenum ws = tObj->WrapS;
      GLenum wt = tObj->WrapT;
      GLenum wr = tObj->WrapR;
d302 2
a303 2
          (tObj->MinFilter != GL_NEAREST ||
           tObj->MagFilter != GL_NEAREST) &&
d326 1
a326 1
      minlod = MIN2(tObj->MinLod, tObj->_MaxLevel - tObj->BaseLevel);
d334 4
a337 4
   CLAMPED_FLOAT_TO_UBYTE(border[0], tObj->BorderColor.f[0]);
   CLAMPED_FLOAT_TO_UBYTE(border[1], tObj->BorderColor.f[1]);
   CLAMPED_FLOAT_TO_UBYTE(border[2], tObj->BorderColor.f[2]);
   CLAMPED_FLOAT_TO_UBYTE(border[3], tObj->BorderColor.f[3]);
@


1.6
log
@Update to Mesa 7.8.2. Tested by johan@@. Thanks.
@
text
@d133 1
a133 1
   GLcontext *ctx = &intel->ctx;
d149 1
a149 1
       dri_bo_unreference(i915->state.tex_buffer[unit]);
d161 1
a161 1
   dri_bo_reference(intelObj->mt->region->buffer);
d168 1
a168 1
   pitch = intelObj->mt->pitch * intelObj->mt->cpp;
d400 1
a400 1
	       dri_bo_unreference(i915->state.tex_buffer[i]);
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d284 1
d325 1
d327 1
a327 1
      state[I915_TEXREG_SS3] |= (U_FIXED(CLAMP(tObj->MinLod, 0.0, 11.0), 4) <<
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d30 2
a31 1
#include "main/texformat.h"
d41 2
a42 1
translate_texture_format(GLuint mesa_format, GLenum DepthMode)
d61 2
d85 6
a90 1
      return (MAPSURF_32BIT | MT_32BIT_xI824);
d140 3
a142 1
   GLint lodbias;
d153 1
a153 1
   if (!intelObj->imageOverride && !intel_finalize_mipmap_tree(intel, unit))
d161 8
a168 29
   if (intelObj->imageOverride) {
      i915->state.tex_buffer[unit] = NULL;
      i915->state.tex_offset[unit] = intelObj->textureOffset;

      switch (intelObj->depthOverride) {
      case 32:
	 format = MAPSURF_32BIT | MT_32BIT_ARGB8888;
	 break;
      case 24:
      default:
	 format = MAPSURF_32BIT | MT_32BIT_XRGB8888;
	 break;
      case 16:
	 format = MAPSURF_16BIT | MT_16BIT_RGB565;
	 break;
      }

      pitch = intelObj->pitchOverride;
   } else {
      dri_bo_reference(intelObj->mt->region->buffer);
      i915->state.tex_buffer[unit] = intelObj->mt->region->buffer;
      i915->state.tex_offset[unit] =  intel_miptree_image_offset(intelObj->mt,
								 0, intelObj->
								 firstLevel);

      format = translate_texture_format(firstImage->TexFormat->MesaFormat, 
		tObj->DepthMode);
      pitch = intelObj->mt->pitch * intelObj->mt->cpp;
   }
d172 7
a178 2
       ((firstImage->Width - 1) << MS3_WIDTH_SHIFT) | format |
       MS3_USE_FENCE_REGS);
d180 5
d186 4
a189 4
     ((((pitch / 4) - 1) << MS4_PITCH_SHIFT) | MS4_CUBE_FACE_ENA_MASK |
       ((((intelObj->lastLevel - intelObj->firstLevel) * 4)) <<
	MS4_MAX_LOD_SHIFT) | ((firstImage->Depth - 1) <<
			      MS4_VOLUME_DEPTH_SHIFT));
d227 4
d255 2
a256 2
      if (firstImage->TexFormat->MesaFormat == MESA_FORMAT_YCBCR ||
          firstImage->TexFormat->MesaFormat == MESA_FORMAT_YCBCR_REV)
d276 2
a277 1
                                 (magFilt << SS2_MAG_FILTER_SHIFT));
d285 6
d325 3
d330 5
d341 4
a344 4
      state[I915_TEXREG_SS4] = INTEL_PACKCOLOR8888(tObj->_BorderChan[0],
						   tObj->_BorderChan[0],
						   tObj->_BorderChan[0],
						   tObj->_BorderChan[0]);
d346 4
a349 4
      state[I915_TEXREG_SS4] = INTEL_PACKCOLOR8888(tObj->_BorderChan[0],
						   tObj->_BorderChan[1],
						   tObj->_BorderChan[2],
						   tObj->_BorderChan[3]);
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d28 3
a30 4
#include "mtypes.h"
#include "enums.h"
#include "texformat.h"
#include "dri_bufmgr.h"
d298 7
d317 15
a331 4
   state[I915_TEXREG_SS4] = INTEL_PACKCOLOR8888(tObj->_BorderChan[0],
                                                tObj->_BorderChan[1],
                                                tObj->_BorderChan[2],
                                                tObj->_BorderChan[3]);
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@a27 2
#include "glheader.h"
#include "macros.h"
a28 1
#include "simple_list.h"
d31 1
a31 1
#include "texstore.h"
d33 1
a33 4
#include "mm.h"

#include "intel_screen.h"
#include "intel_ioctl.h"
a38 330
static GLint initial_offsets[6][2] = { {0,0},
				       {0,2},
				       {1,0},
				       {1,2},
				       {1,1},
				       {1,3} };


static GLint step_offsets[6][2] = { {0,2},
				    {0,2},
				    {-1,2},
				    {-1,2},
				    {-1,1},
				    {-1,1} };


#define I915_TEX_UNIT_ENABLED(unit)		(1<<unit)

static void i915LayoutTextureImages( i915ContextPtr i915,
				     struct gl_texture_object *tObj )
{
   const struct gl_texture_image *baseImage = tObj->Image[0][tObj->BaseLevel];
   i915TextureObjectPtr t = (i915TextureObjectPtr) tObj->DriverData;
   GLint firstLevel, lastLevel, numLevels;
   GLint i, total_height, pitch;

   /* Compute which mipmap levels we really want to send to the hardware.
    */
   driCalculateTextureFirstLastLevel( (driTextureObject *) t );

   /* Figure out the amount of memory required to hold all the mipmap
    * levels.  Choose the smallest pitch to accomodate the largest
    * mipmap:
    */
   firstLevel = t->intel.base.firstLevel;
   lastLevel = t->intel.base.lastLevel;
   numLevels = lastLevel - firstLevel + 1;



   /* All images must be loaded at this pitch.  Count the number of
    * lines required:
    */
   switch (tObj->Target) {
   case GL_TEXTURE_CUBE_MAP: {
      const GLuint dim = tObj->Image[0][firstLevel]->Width;
      GLuint face;

      pitch = dim * t->intel.texelBytes;
      pitch *= 2;		/* double pitch for cube layouts */
      pitch = (pitch + 3) & ~3;
      
      total_height = dim * 4;

      for ( face = 0 ; face < 6 ; face++) {
	 GLuint x = initial_offsets[face][0] * dim;
	 GLuint y = initial_offsets[face][1] * dim;
	 GLuint d = dim;
	 
	 t->intel.base.dirty_images[face] = ~0;

	 assert(tObj->Image[face][firstLevel]->Width == dim);
	 assert(tObj->Image[face][firstLevel]->Height == dim);

	 for (i = 0; i < numLevels; i++) {
	    t->intel.image[face][i].image = tObj->Image[face][firstLevel + i];
	    if (!t->intel.image[face][i].image) {
	       fprintf(stderr, "no image %d %d\n", face, i);
	       break;		/* can't happen */
	    }
	 
	    t->intel.image[face][i].offset = 
	       y * pitch + x * t->intel.texelBytes;
	    t->intel.image[face][i].internalFormat = baseImage->_BaseFormat;

	    d >>= 1;
	    x += step_offsets[face][0] * d;
	    y += step_offsets[face][1] * d;
	 }
      }
      break;
   }
   case GL_TEXTURE_3D: {
      GLuint virtual_height;
      GLuint tmp_numLevels = numLevels;
      pitch = tObj->Image[0][firstLevel]->Width * t->intel.texelBytes;
      pitch = (pitch + 3) & ~3;
      t->intel.base.dirty_images[0] = ~0;

      /* Calculate the size of a single slice.  Hardware demands a
       * minimum of 8 mipmaps, some of which might ultimately not be
       * used:
       */
      if (tmp_numLevels < 9)
	 tmp_numLevels = 9;

      virtual_height = tObj->Image[0][firstLevel]->Height;

      for ( total_height = i = 0 ; i < tmp_numLevels ; i++ ) {
	 t->intel.image[0][i].image = tObj->Image[0][firstLevel + i];
	 if (t->intel.image[0][i].image) {
	    t->intel.image[0][i].offset = total_height * pitch;
	    t->intel.image[0][i].internalFormat = baseImage->_BaseFormat;
	 }

	 total_height += MAX2(2, virtual_height);
	 virtual_height >>= 1;
      }

      t->intel.depth_pitch = total_height * pitch;

      /* Multiply slice size by texture depth for total size.  It's
       * remarkable how wasteful of memory all the i8x0 texture
       * layouts are.
       */
      total_height *= t->intel.image[0][0].image->Depth;
      break;
   }
   default:
      pitch = tObj->Image[0][firstLevel]->Width * t->intel.texelBytes;
      pitch = (pitch + 3) & ~3;
      t->intel.base.dirty_images[0] = ~0;

      for ( total_height = i = 0 ; i < numLevels ; i++ ) {
	 t->intel.image[0][i].image = tObj->Image[0][firstLevel + i];
	 if (!t->intel.image[0][i].image) 
	    break;
	 
	 t->intel.image[0][i].offset = total_height * pitch;
	 t->intel.image[0][i].internalFormat = baseImage->_BaseFormat;
	 if (t->intel.image[0][i].image->IsCompressed) {
	    total_height += (t->intel.image[0][i].image->Height + 3) / 4;
	 }
	 else
	   total_height += MAX2(2, t->intel.image[0][i].image->Height);
      }
      break;
   }

   t->intel.Pitch = pitch;
   t->intel.base.totalSize = total_height*pitch;
   t->intel.max_level = numLevels-1;
}


static void i945LayoutTextureImages( i915ContextPtr i915,
				    struct gl_texture_object *tObj )
{
   const struct gl_texture_image *baseImage = tObj->Image[0][tObj->BaseLevel];
   i915TextureObjectPtr t = (i915TextureObjectPtr) tObj->DriverData;
   GLint firstLevel, lastLevel, numLevels;
   GLint i, total_height, pitch, sz, max_offset = 0, offset;


   /* Compute which mipmap levels we really want to send to the hardware.
    */
   driCalculateTextureFirstLastLevel( (driTextureObject *) t );

   /* Figure out the amount of memory required to hold all the mipmap
    * levels.  Choose the smallest pitch to accomodate the largest
    * mipmap:
    */
   firstLevel = t->intel.base.firstLevel;
   lastLevel = t->intel.base.lastLevel;
   numLevels = lastLevel - firstLevel + 1;



   /* All images must be loaded at this pitch.  Count the number of
    * lines required:
    */
   switch (tObj->Target) {
   case GL_TEXTURE_CUBE_MAP: {
      const GLuint dim = tObj->Image[0][firstLevel]->Width;
      GLuint face;

      /* Depending on the size of the largest images, pitch can be
       * determined either by the old-style packing of cubemap faces,
       * or the final row of 4x4, 2x2 and 1x1 faces below this. 
       */
      if (dim > 32) {
	 pitch = dim * t->intel.texelBytes;
	 pitch *= 2;		/* double pitch for cube layouts */
	 pitch = (pitch + 3) & ~3;
      }
      else {
	 pitch = 14 * 8 * t->intel.texelBytes; /* determined by row of
						* little maps at
						* bottom */
      }
      
      total_height = dim * 4 + 4;

      for ( face = 0 ; face < 6 ; face++) {
	 GLuint x = initial_offsets[face][0] * dim;
	 GLuint y = initial_offsets[face][1] * dim;
	 GLuint d = dim;
	 
	 if (dim == 4 && face >= 4) {
	    y = total_height - 4;
	    x = (face - 4) * 8;
	 }
	 else if (dim < 4) {
	    y = total_height - 4;
	    x = face * 8;
	 }

	 t->intel.base.dirty_images[face] = ~0;

	 assert(tObj->Image[face][firstLevel]->Width == dim);
	 assert(tObj->Image[face][firstLevel]->Height == dim);

	 for (i = 0; i < numLevels; i++) {


	    t->intel.image[face][i].image = tObj->Image[face][firstLevel + i];
	    assert(t->intel.image[face][i].image);
	 
	    t->intel.image[face][i].offset = 
	       y * pitch + x * t->intel.texelBytes;
	    t->intel.image[face][i].internalFormat = baseImage->_BaseFormat;

	    d >>= 1;
	    
	    switch (d) {
	    case 4:
	       switch (face) {
	       case FACE_POS_X:
	       case FACE_NEG_X:
		  x += step_offsets[face][0] * d;
		  y += step_offsets[face][1] * d;
		  break;
	       case FACE_POS_Y:
	       case FACE_NEG_Y:
		  y += 12;
		  x -= 8;
		  break;
	       case FACE_POS_Z:
	       case FACE_NEG_Z:
		  y = total_height - 4;
		  x = (face - 4) * 8;
		  break;
	       }

	    case 2:
	       y = total_height - 4;
	       x = 16 + face * 8;
	       break;

	    case 1:
	       x += 48;
	       break;
	       
	    default:
	       x += step_offsets[face][0] * d;
	       y += step_offsets[face][1] * d;
	       break;
	    }
	 }
      }
      max_offset = total_height * pitch;
      break;
   }
   case GL_TEXTURE_3D: {
      GLuint depth_packing = 0, depth_pack_pitch;
      GLuint tmp_numLevels = numLevels;
      pitch = tObj->Image[0][firstLevel]->Width * t->intel.texelBytes;
      pitch = (pitch + 3) & ~3;
      depth_pack_pitch = pitch;
      
      t->intel.base.dirty_images[0] = ~0;


      for ( total_height = i = 0 ; i < tmp_numLevels ; i++ ) {
	 t->intel.image[0][i].image = tObj->Image[0][firstLevel + i];
	 if (!t->intel.image[0][i].image) 
	    break;

	 
	 t->intel.image[0][i].offset = total_height * pitch;
	 t->intel.image[0][i].internalFormat = baseImage->_BaseFormat;
	 


	 total_height += MAX2(2, t->intel.image[0][i].image->Height) * 
	    MAX2((t->intel.image[0][i].image->Depth >> depth_packing), 1);

	 /* When alignment dominates, can't increase depth packing?
	  * Or does pitch grow???  What are the alignment constraints,
	  * anyway?
	  */
	 if (depth_pack_pitch > 4) {
	    depth_packing++;
	    depth_pack_pitch <<= 2;
	 }
      }

      max_offset = total_height * pitch;
      break;
   }
   default:
      pitch = tObj->Image[0][firstLevel]->Width * t->intel.texelBytes;
      pitch = (pitch + 3) & ~3;
      t->intel.base.dirty_images[0] = ~0;
      max_offset = 0;

      for ( offset = i = 0 ; i < numLevels ; i++ ) {
	 t->intel.image[0][i].image = tObj->Image[0][firstLevel + i];
	 if (!t->intel.image[0][i].image) 
	    break;
	 
	 t->intel.image[0][i].offset = offset;
	 t->intel.image[0][i].internalFormat = baseImage->_BaseFormat;

	 if (t->intel.image[0][i].image->IsCompressed)
	    sz = MAX2(1, t->intel.image[0][i].image->Height/4) * pitch;
	 else
	    sz = MAX2(2, t->intel.image[0][i].image->Height) * pitch;
	 
	 /* Because the images are packed better, the final offset
	  * might not be the maximal one:
	  */
	 max_offset = MAX2(max_offset, offset + sz);

	 /* LPT change: step right after second mipmap.
	  */
	 if (i == 1) 
	    offset += pitch / 2;
	 else 
	    offset += sz;
d40 2
a41 14
      }
      break;
   }

   t->intel.Pitch = pitch;
   t->intel.base.totalSize = max_offset;
   t->intel.max_level = numLevels-1;
}




static void i915SetTexImages( i915ContextPtr i915, 
			     struct gl_texture_object *tObj )
d43 1
a43 6
   GLuint textureFormat;
   i915TextureObjectPtr t = (i915TextureObjectPtr) tObj->DriverData;
   const struct gl_texture_image *baseImage = tObj->Image[0][tObj->BaseLevel];
   GLint ss2 = 0;

   switch( baseImage->TexFormat->MesaFormat ) {
d45 1
a45 4
      t->intel.texelBytes = 1;
      textureFormat = MAPSURF_8BIT | MT_8BIT_L8;
      break;

d47 1
a47 4
      t->intel.texelBytes = 1;
      textureFormat = MAPSURF_8BIT | MT_8BIT_I8;
      break;

d49 1
a49 4
      t->intel.texelBytes = 1;
      textureFormat = MAPSURF_8BIT | MT_8BIT_A8; 
      break;

d51 1
a51 4
      t->intel.texelBytes = 2;
      textureFormat = MAPSURF_16BIT | MT_16BIT_AY88;
      break;

d53 1
a53 4
      t->intel.texelBytes = 2;
      textureFormat = MAPSURF_16BIT | MT_16BIT_RGB565;
      break;

d55 1
a55 4
      t->intel.texelBytes = 2;
      textureFormat = MAPSURF_16BIT | MT_16BIT_ARGB1555;
      break;

d57 1
a57 4
      t->intel.texelBytes = 2;
      textureFormat = MAPSURF_16BIT | MT_16BIT_ARGB4444;
      break;

d59 1
a59 4
      t->intel.texelBytes = 4;
      textureFormat = MAPSURF_32BIT | MT_32BIT_ARGB8888;
      break;

d61 1
a61 5
      t->intel.texelBytes = 2;
      textureFormat = (MAPSURF_422 | MT_422_YCRCB_NORMAL);
      ss2 |= SS2_COLORSPACE_CONVERSION;
      break;

d63 1
a63 5
      t->intel.texelBytes = 2;
      textureFormat = (MAPSURF_422 | MT_422_YCRCB_SWAPY);
      ss2 |= SS2_COLORSPACE_CONVERSION;
      break;

d66 1
a66 4
     t->intel.texelBytes = 2;
     textureFormat = (MAPSURF_COMPRESSED | MT_COMPRESS_FXT1);
     break;

d68 6
a73 4
      t->intel.texelBytes = 2;
      textureFormat = (MAPSURF_16BIT | MT_16BIT_L16);
      break;

d76 1
a76 9
     /* 
      * DXTn pitches are Width/4 * blocksize in bytes 
      * for DXT1: blocksize=8 so Width/4*8 = Width * 2 
      * for DXT3/5: blocksize=16 so Width/4*16 = Width * 4
      */
     t->intel.texelBytes = 2;
     textureFormat = (MAPSURF_COMPRESSED | MT_COMPRESS_DXT1);
     break;

d78 1
a78 4
     t->intel.texelBytes = 4;
     textureFormat = (MAPSURF_COMPRESSED | MT_COMPRESS_DXT2_3);
     break;

d80 3
a82 11
     t->intel.texelBytes = 4;
     textureFormat = (MAPSURF_COMPRESSED | MT_COMPRESS_DXT4_5);
     break;

#if 0
   case MESA_FORMAT_Z24_S8:
      t->intel.texelBytes = 4;
      textureFormat = (MAPSURF_32BIT | MT_32BIT_xL824);
      break;
#endif

d84 1
a84 2
      fprintf(stderr, "%s: bad image format %x\n", __FUNCTION__,
	      baseImage->TexFormat->MesaFormat);
d86 1
d88 1
a89 13
   switch (i915->intel.intelScreen->deviceID) {
   case PCI_CHIP_I945_G:
   case PCI_CHIP_I945_GM:
   case PCI_CHIP_I945_GME:
   case PCI_CHIP_G33_G:
   case PCI_CHIP_Q33_G:
   case PCI_CHIP_Q35_G:
       i945LayoutTextureImages( i915, tObj );
       break;
   default:
       i915LayoutTextureImages( i915, tObj );
       break;
   }
a90 18
   t->Setup[I915_TEXREG_MS3] = 
      (((tObj->Image[0][t->intel.base.firstLevel]->Height - 1) << MS3_HEIGHT_SHIFT) |
       ((tObj->Image[0][t->intel.base.firstLevel]->Width - 1) << MS3_WIDTH_SHIFT) |
       textureFormat |
       MS3_USE_FENCE_REGS);

   t->Setup[I915_TEXREG_MS4] = 
      ((((t->intel.Pitch / 4) - 1) << MS4_PITCH_SHIFT) | 
       MS4_CUBE_FACE_ENA_MASK |
       (((t->intel.max_level * 4)) << MS4_MAX_LOD_SHIFT) |
       ((tObj->Image[0][t->intel.base.firstLevel]->Depth - 1) << MS4_VOLUME_DEPTH_SHIFT));

   t->Setup[I915_TEXREG_SS2] &= ~(SS2_COLORSPACE_CONVERSION);
   t->Setup[I915_TEXREG_SS2] |= ss2;

   t->intel.dirty = I915_UPLOAD_TEX_ALL;

}
d97 2
a98 1
static GLuint translate_wrap_mode( GLenum wrap )
d100 11
a110 46
   switch( wrap ) {
   case GL_REPEAT: return TEXCOORDMODE_WRAP;
   case GL_CLAMP:  return TEXCOORDMODE_CLAMP_EDGE; /* not quite correct */
   case GL_CLAMP_TO_EDGE: return TEXCOORDMODE_CLAMP_EDGE;
   case GL_CLAMP_TO_BORDER: return TEXCOORDMODE_CLAMP_BORDER;
   case GL_MIRRORED_REPEAT: return TEXCOORDMODE_MIRROR;
   default: return TEXCOORDMODE_WRAP;
   }
}


/**
 */
static void i915ImportTexObjState( struct gl_texture_object *texObj )
{   
   i915TextureObjectPtr t = (i915TextureObjectPtr)texObj->DriverData;
   int minFilt = 0, mipFilt = 0, magFilt = 0, shadow = 0;

   if(INTEL_DEBUG&DEBUG_DRI)
      fprintf(stderr, "%s\n", __FUNCTION__);

   switch (texObj->MinFilter) {
   case GL_NEAREST:
      minFilt = FILTER_NEAREST;
      mipFilt = MIPFILTER_NONE;
      break;
   case GL_LINEAR:
      minFilt = FILTER_LINEAR;
      mipFilt = MIPFILTER_NONE;
      break;
   case GL_NEAREST_MIPMAP_NEAREST:
      minFilt = FILTER_NEAREST;
      mipFilt = MIPFILTER_NEAREST;
      break;
   case GL_LINEAR_MIPMAP_NEAREST:
      minFilt = FILTER_LINEAR;
      mipFilt = MIPFILTER_NEAREST;
      break;
   case GL_NEAREST_MIPMAP_LINEAR:
      minFilt = FILTER_NEAREST;
      mipFilt = MIPFILTER_LINEAR;
      break;
   case GL_LINEAR_MIPMAP_LINEAR:
      minFilt = FILTER_LINEAR;
      mipFilt = MIPFILTER_LINEAR;
      break;
d112 1
a112 89
      break;
   }

   if ( texObj->MaxAnisotropy > 1.0 ) {
      minFilt = FILTER_ANISOTROPIC; 
      magFilt = FILTER_ANISOTROPIC;
   }
   else {
      switch (texObj->MagFilter) {
      case GL_NEAREST:
	 magFilt = FILTER_NEAREST;
	 break;
      case GL_LINEAR:
	 magFilt = FILTER_LINEAR;
	 break;
      default:
	 break;
      }  
   }

   if (texObj->CompareMode == GL_COMPARE_R_TO_TEXTURE_ARB && 
       texObj->Target != GL_TEXTURE_3D) {

      shadow = SS2_SHADOW_ENABLE;
      shadow |= intel_translate_compare_func( texObj->CompareFunc );
      
      minFilt = FILTER_4X4_FLAT;
      magFilt = FILTER_4X4_FLAT;
   }


   t->Setup[I915_TEXREG_SS2] &= ~(SS2_MIN_FILTER_MASK |
				 SS2_MIP_FILTER_MASK |
				 SS2_MAG_FILTER_MASK |
				 SS2_SHADOW_ENABLE |
				 SS2_SHADOW_FUNC_MASK);
   t->Setup[I915_TEXREG_SS2] |= ((minFilt << SS2_MIN_FILTER_SHIFT) |
				(mipFilt << SS2_MIP_FILTER_SHIFT) |
				(magFilt << SS2_MAG_FILTER_SHIFT) |
				shadow);

   {
      GLuint ss3 = t->Setup[I915_TEXREG_SS3] & ~(SS3_TCX_ADDR_MODE_MASK |
						SS3_TCY_ADDR_MODE_MASK |
						SS3_TCZ_ADDR_MODE_MASK);
      GLenum ws = texObj->WrapS;
      GLenum wt = texObj->WrapT;
      GLenum wr = texObj->WrapR;
      
      t->refs_border_color = 0;

      if (texObj->Target == GL_TEXTURE_3D &&
	  (texObj->MinFilter != GL_NEAREST ||
	   texObj->MagFilter != GL_NEAREST)) {
	 
	 /* Try to mimic GL_CLAMP functionality a little better -
	  * switch to CLAMP_TO_BORDER whenever a non-NEAREST filter is
	  * in use.  Only do this for 3D textures at the moment --
	  * doing it universally would fix the conform texbc.c
	  * failure, though.
	  */
	 if (ws == GL_CLAMP) ws = GL_CLAMP_TO_BORDER;
	 if (wt == GL_CLAMP) wt = GL_CLAMP_TO_BORDER;
	 if (wr == GL_CLAMP) wr = GL_CLAMP_TO_BORDER;

	 /* 3D textures don't seem to respect the border color.
	  * Fallback if there's ever a danger that they might refer to
	  * it.
	  */
	 if (ws == GL_CLAMP_TO_BORDER) t->refs_border_color = 1;
	 if (wt == GL_CLAMP_TO_BORDER) t->refs_border_color = 1;
	 if (wr == GL_CLAMP_TO_BORDER) t->refs_border_color = 1;
      }

      ss3 |= translate_wrap_mode(ws) << SS3_TCX_ADDR_MODE_SHIFT;
      ss3 |= translate_wrap_mode(wt) << SS3_TCY_ADDR_MODE_SHIFT;
      ss3 |= translate_wrap_mode(wr) << SS3_TCZ_ADDR_MODE_SHIFT;
   
      if (ss3 != t->Setup[I915_TEXREG_SS3]) {
	 t->intel.dirty = I915_UPLOAD_TEX_ALL;
	 t->Setup[I915_TEXREG_SS3] = ss3;
      }
   }

   {   
      const GLubyte *color = texObj->_BorderChan;

      t->Setup[I915_TEXREG_SS4] = INTEL_PACKCOLOR8888(color[0],color[1],
						     color[2],color[3]);
d118 6
a123 3
static void i915_import_tex_unit( i915ContextPtr i915, 
				 i915TextureObjectPtr t,
				 GLuint unit )
d125 8
a132 15
   GLuint state[I915_TEX_SETUP_SIZE];

   if(INTEL_DEBUG&DEBUG_TEXTURE)
      fprintf(stderr, "%s unit(%d)\n", __FUNCTION__, unit);
   
   if (i915->intel.CurrentTexObj[unit]) 
      i915->intel.CurrentTexObj[unit]->base.bound &= ~(1U << unit);

   i915->intel.CurrentTexObj[unit] = (intelTextureObjectPtr)t;
   t->intel.base.bound |= (1 << unit);

   if (t->intel.dirty & I915_UPLOAD_TEX(unit)) {
      i915ImportTexObjState( t->intel.base.tObj );
      t->intel.dirty &= ~I915_UPLOAD_TEX(unit);
   }
d134 1
a134 3
   state[I915_TEXREG_MS2] = t->intel.TextureOffset;
   state[I915_TEXREG_MS3] = t->Setup[I915_TEXREG_MS3];
   state[I915_TEXREG_MS4] = t->Setup[I915_TEXREG_MS4];
d136 1
a136 3
   state[I915_TEXREG_SS2] = (i915->state.Tex[unit][I915_TEXREG_SS2] &
			    SS2_LOD_BIAS_MASK);
   state[I915_TEXREG_SS2] |= (t->Setup[I915_TEXREG_SS2] & ~SS2_LOD_BIAS_MASK);
d138 3
a140 14
   state[I915_TEXREG_SS3] = (i915->state.Tex[unit][I915_TEXREG_SS3] &
			    SS3_NORMALIZED_COORDS);
   state[I915_TEXREG_SS3] |= (t->Setup[I915_TEXREG_SS3] &
			     ~(SS3_NORMALIZED_COORDS|
			       SS3_TEXTUREMAP_INDEX_MASK));

   state[I915_TEXREG_SS3] |= (unit<<SS3_TEXTUREMAP_INDEX_SHIFT);

   state[I915_TEXREG_SS4] = t->Setup[I915_TEXREG_SS4];


   if (memcmp(state, i915->state.Tex[unit], sizeof(state)) != 0) {
      I915_STATECHANGE( i915, I915_UPLOAD_TEX(unit) );
      memcpy(i915->state.Tex[unit], state, sizeof(state));
a141 1
}
d143 2
d146 4
d151 16
a166 6
static GLboolean enable_tex_common( GLcontext *ctx, GLuint unit )
{
   i915ContextPtr i915 = I915_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *tObj = texUnit->_Current;
   i915TextureObjectPtr t = (i915TextureObjectPtr)tObj->DriverData;
d168 17
a184 1
   if (0) fprintf(stderr, "%s %d\n", __FUNCTION__, unit);
d186 5
a190 3
   if (!(i915->state.active & I915_UPLOAD_TEX(unit))) {
      I915_ACTIVESTATE(i915, I915_UPLOAD_TEX(unit), GL_TRUE);
   }
a191 4
   /* Fallback if there's a texture border */
   if ( tObj->Image[0][tObj->BaseLevel]->Border > 0 ) {
      return GL_FALSE;
   }
d193 2
d196 28
a223 8
   /* Update state if this is a different texture object to last
    * time.
    */
   if (i915->intel.CurrentTexObj[unit] != &t->intel || 
       (t->intel.dirty & I915_UPLOAD_TEX(unit))) {
      i915_import_tex_unit( i915, t, unit);
      i915->tex_program.translated = 0;
   }
d225 24
a248 2
   return GL_TRUE;
}
d250 5
a254 14
static GLboolean enable_tex_rect( GLcontext *ctx, GLuint unit )
{
   i915ContextPtr i915 = I915_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *tObj = texUnit->_Current;
   i915TextureObjectPtr t = (i915TextureObjectPtr)tObj->DriverData;
   GLuint ss3 = i915->state.Tex[unit][I915_TEXREG_SS3];

   ss3 &= ~SS3_NORMALIZED_COORDS;

   if (ss3 != i915->state.Tex[unit][I915_TEXREG_SS3]) {
      I915_STATECHANGE(i915, I915_UPLOAD_TEX(unit));
      i915->state.Tex[unit][I915_TEXREG_SS3] = ss3;
   }
d256 18
a273 7
   /* Upload teximages (not pipelined)
    */
   if (t->intel.base.dirty_images[0]) {
      i915SetTexImages( i915, tObj );
      if (!intelUploadTexImages( &i915->intel, &t->intel, 0 )) {
	 return GL_FALSE;
      }
d276 4
a279 2
   return GL_TRUE;
}
d282 16
a297 23
static GLboolean enable_tex_2d( GLcontext *ctx, GLuint unit )
{
   i915ContextPtr i915 = I915_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *tObj = texUnit->_Current;
   i915TextureObjectPtr t = (i915TextureObjectPtr)tObj->DriverData;
   GLuint ss3 = i915->state.Tex[unit][I915_TEXREG_SS3];

   ss3 |= SS3_NORMALIZED_COORDS;

   if (ss3 != i915->state.Tex[unit][I915_TEXREG_SS3]) {
      I915_STATECHANGE(i915, I915_UPLOAD_TEX(unit));
      i915->state.Tex[unit][I915_TEXREG_SS3] = ss3;
   }

   /* Upload teximages (not pipelined)
    */
   if (t->intel.base.dirty_images[0]) {
      i915SetTexImages( i915, tObj );
      if (!intelUploadTexImages( &i915->intel, &t->intel, 0 )) {
	 return GL_FALSE;
      }
   }
a298 2
   return GL_TRUE;
}
d300 1
a300 15
static GLboolean enable_tex_cube( GLcontext *ctx, GLuint unit )
{
   i915ContextPtr i915 = I915_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *tObj = texUnit->_Current;
   i915TextureObjectPtr t = (i915TextureObjectPtr)tObj->DriverData;
   GLuint ss3 = i915->state.Tex[unit][I915_TEXREG_SS3];
   GLuint face;

   ss3 |= SS3_NORMALIZED_COORDS;

   if (ss3 != i915->state.Tex[unit][I915_TEXREG_SS3]) {
      I915_STATECHANGE(i915, I915_UPLOAD_TEX(unit));
      i915->state.Tex[unit][I915_TEXREG_SS3] = ss3;
   }
d302 4
a305 7
   /* Upload teximages (not pipelined)
    */
   if ( t->intel.base.dirty_images[0] || t->intel.base.dirty_images[1] ||
        t->intel.base.dirty_images[2] || t->intel.base.dirty_images[3] ||
        t->intel.base.dirty_images[4] || t->intel.base.dirty_images[5] ) {
      i915SetTexImages( i915, tObj );
   }
d307 1
a307 7
   /* upload (per face) */
   for (face = 0; face < 6; face++) {
      if (t->intel.base.dirty_images[face]) {
	 if (!intelUploadTexImages( &i915->intel, &t->intel, face )) {
	    return GL_FALSE;
	 }
      }
d311 4
a314 2
   return GL_TRUE;
}
a315 4
static GLboolean enable_tex_3d( GLcontext *ctx, GLuint unit )
{
   struct gl_texture_object *tObj = ctx->Texture.Unit[unit]._Current;
   i915TextureObjectPtr t = (i915TextureObjectPtr)tObj->DriverData;
d317 3
a319 2
   /* 3D textures on I915 seem to get bogus border colors, hence this
    * fallback:
d321 1
a321 2
   if (t->refs_border_color)
      return GL_FALSE;
a322 2
   return GL_TRUE;
}
d324 8
a331 18


 
static GLboolean disable_tex( GLcontext *ctx, GLuint unit )
{
   i915ContextPtr i915 = I915_CONTEXT(ctx);

   if (i915->state.active & I915_UPLOAD_TEX(unit)) {
      I915_ACTIVESTATE(i915, I915_UPLOAD_TEX(unit), GL_FALSE);
   }

   /* The old texture is no longer bound to this texture unit.
    * Mark it as such.
    */
   if ( i915->intel.CurrentTexObj[unit] != NULL ) {
      i915->intel.CurrentTexObj[unit]->base.bound &= ~(1U << 0);
      i915->intel.CurrentTexObj[unit] = NULL;
   }
a335 3
static GLboolean i915UpdateTexUnit( GLcontext *ctx, GLuint unit )
{
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
a336 3
   if (texUnit->_ReallyEnabled &&
       INTEL_CONTEXT(ctx)->intelScreen->tex.size < 2048 * 1024)
      return GL_FALSE;
a337 21
   switch (texUnit->_ReallyEnabled) {
   case TEXTURE_1D_BIT:
   case TEXTURE_2D_BIT:
      return (enable_tex_2d( ctx, unit ) &&
	      enable_tex_common( ctx, unit ));
   case TEXTURE_RECT_BIT:
      return (enable_tex_rect( ctx, unit ) &&
	      enable_tex_common( ctx, unit ));
   case TEXTURE_CUBE_BIT:
      return (enable_tex_cube( ctx, unit ) &&
	      enable_tex_common( ctx, unit ));
   case TEXTURE_3D_BIT:
       return (enable_tex_2d( ctx, unit ) && 
	       enable_tex_common( ctx, unit ) &&
	       enable_tex_3d( ctx, unit)); 
   case 0:
      return disable_tex( ctx, unit );
   default:
      return GL_FALSE;
   }
}
d339 2
a340 2

void i915UpdateTextureState( intelContextPtr intel )
a341 1
   GLcontext *ctx = &intel->ctx;
d345 27
a371 2
   for (i = 0 ; i < I915_TEX_UNITS && ok ; i++) {
      ok = i915UpdateTexUnit( ctx, i );
d374 1
a374 1
   FALLBACK( intel, I915_FALLBACK_TEXTURE, !ok );
a375 3



@


1.1
log
@Initial revision
@
text
@d175 2
a176 6
	 if (t->intel.image[0][i].image->IsCompressed)
	 {
	   if (t->intel.image[0][i].image->Height > 4)
	     total_height += t->intel.image[0][i].image->Height/4;
	   else
	     total_height += 1;
d494 13
a506 6

   if (i915->intel.intelScreen->deviceID == PCI_CHIP_I945_G ||
       i915->intel.intelScreen->deviceID == PCI_CHIP_I945_GM)
      i945LayoutTextureImages( i915, tObj );	 
   else
      i915LayoutTextureImages( i915, tObj );
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d175 6
a180 2
	 if (t->intel.image[0][i].image->IsCompressed) {
	    total_height += (t->intel.image[0][i].image->Height + 3) / 4;
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d28 7
a34 4
#include "main/mtypes.h"
#include "main/enums.h"
#include "main/macros.h"
#include "main/colormac.h"
d36 4
a39 1
#include "intel_mipmap_tree.h"
d45 342
d388 2
a389 3
static GLuint
translate_texture_format(gl_format mesa_format, GLuint internal_format,
			 GLenum DepthMode)
d391 6
a396 1
   switch (mesa_format) {
d398 4
a401 1
      return MAPSURF_8BIT | MT_8BIT_L8;
d403 4
a406 1
      return MAPSURF_8BIT | MT_8BIT_I8;
d408 4
a411 1
      return MAPSURF_8BIT | MT_8BIT_A8;
d413 4
a416 1
      return MAPSURF_16BIT | MT_16BIT_AY88;
d418 4
a421 1
      return MAPSURF_16BIT | MT_16BIT_RGB565;
d423 4
a426 1
      return MAPSURF_16BIT | MT_16BIT_ARGB1555;
d428 4
a431 1
      return MAPSURF_16BIT | MT_16BIT_ARGB4444;
d433 4
a436 3
      return MAPSURF_32BIT | MT_32BIT_ARGB8888;
   case MESA_FORMAT_XRGB8888:
      return MAPSURF_32BIT | MT_32BIT_XRGB8888;
d438 5
a442 1
      return (MAPSURF_422 | MT_422_YCRCB_NORMAL);
d444 5
a448 1
      return (MAPSURF_422 | MT_422_YCRCB_SWAPY);
d451 4
a454 1
      return (MAPSURF_COMPRESSED | MT_COMPRESS_FXT1);
d456 4
a459 6
      if (DepthMode == GL_ALPHA)
          return (MAPSURF_16BIT | MT_16BIT_A16);
      else if (DepthMode == GL_INTENSITY)
          return (MAPSURF_16BIT | MT_16BIT_I16);
      else
          return (MAPSURF_16BIT | MT_16BIT_L16);
d462 9
a470 1
      return (MAPSURF_COMPRESSED | MT_COMPRESS_DXT1);
d472 4
a475 1
      return (MAPSURF_COMPRESSED | MT_COMPRESS_DXT2_3);
d477 11
a487 8
      return (MAPSURF_COMPRESSED | MT_COMPRESS_DXT4_5);
   case MESA_FORMAT_S8_Z24:
      if (DepthMode == GL_ALPHA)
	 return (MAPSURF_32BIT | MT_32BIT_x8A24);
      else if (DepthMode == GL_INTENSITY)
	 return (MAPSURF_32BIT | MT_32BIT_x8I24);
      else
	 return (MAPSURF_32BIT | MT_32BIT_x8L24);
d489 2
a490 1
      fprintf(stderr, "%s: bad image format %x\n", __FUNCTION__, mesa_format);
a491 1
      return 0;
a492 1
}
d495 24
d525 1
a525 2
static GLuint
translate_wrap_mode(GLenum wrap)
d527 46
a572 11
   switch (wrap) {
   case GL_REPEAT:
      return TEXCOORDMODE_WRAP;
   case GL_CLAMP:
      return TEXCOORDMODE_CLAMP_EDGE;   /* not quite correct */
   case GL_CLAMP_TO_EDGE:
      return TEXCOORDMODE_CLAMP_EDGE;
   case GL_CLAMP_TO_BORDER:
      return TEXCOORDMODE_CLAMP_BORDER;
   case GL_MIRRORED_REPEAT:
      return TEXCOORDMODE_MIRROR;
d574 89
a662 1
      return TEXCOORDMODE_WRAP;
d668 3
a670 6
/* Recalculate all state from scratch.  Perhaps not the most
 * efficient, but this has gotten complex enough that we need
 * something which is understandable and reliable.
 */
static GLboolean
i915_update_tex_unit(struct intel_context *intel, GLuint unit, GLuint ss3)
d672 14
a685 18
   struct gl_context *ctx = &intel->ctx;
   struct i915_context *i915 = i915_context(ctx);
   struct gl_texture_unit *tUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *tObj = tUnit->_Current;
   struct intel_texture_object *intelObj = intel_texture_object(tObj);
   struct gl_texture_image *firstImage;
   GLuint *state = i915->state.Tex[unit], format, pitch;
   GLint lodbias, aniso = 0;
   GLubyte border[4];
   GLfloat maxlod;

   memset(state, 0, sizeof(state));

   /*We need to refcount these. */

   if (i915->state.tex_buffer[unit] != NULL) {
       drm_intel_bo_unreference(i915->state.tex_buffer[unit]);
       i915->state.tex_buffer[unit] = NULL;
d688 25
a712 2
   if (!intel_finalize_mipmap_tree(intel, unit))
      return GL_FALSE;
a713 4
   /* Get first image here, since intelObj->firstLevel will get set in
    * the intel_finalize_mipmap_tree() call above.
    */
   firstImage = tObj->Image[0][intelObj->firstLevel];
d715 6
a720 3
   drm_intel_bo_reference(intelObj->mt->region->buffer);
   i915->state.tex_buffer[unit] = intelObj->mt->region->buffer;
   i915->state.tex_offset[unit] = 0; /* Always the origin of the miptree */
d722 1
a722 4
   format = translate_texture_format(firstImage->TexFormat,
				     firstImage->InternalFormat,
				     tObj->DepthMode);
   pitch = intelObj->mt->region->pitch * intelObj->mt->cpp;
d724 3
a726 3
   state[I915_TEXREG_MS3] =
      (((firstImage->Height - 1) << MS3_HEIGHT_SHIFT) |
       ((firstImage->Width - 1) << MS3_WIDTH_SHIFT) | format);
d728 3
a730 4
   if (intelObj->mt->region->tiling != I915_TILING_NONE) {
      state[I915_TEXREG_MS3] |= MS3_TILED_SURFACE;
      if (intelObj->mt->region->tiling == I915_TILING_Y)
	 state[I915_TEXREG_MS3] |= MS3_TILE_WALK;
d733 3
a735 3
   /* We get one field with fraction bits for the maximum addressable
    * (lowest resolution) LOD.  Use it to cover both MAX_LEVEL and
    * MAX_LOD.
d737 5
a741 6
   maxlod = MIN2(tObj->MaxLod, tObj->_MaxLevel - tObj->BaseLevel);
   state[I915_TEXREG_MS4] =
      ((((pitch / 4) - 1) << MS4_PITCH_SHIFT) |
       MS4_CUBE_FACE_ENA_MASK |
       (U_FIXED(CLAMP(maxlod, 0.0, 11.0), 2) << MS4_MAX_LOD_SHIFT) |
       ((firstImage->Depth - 1) << MS4_VOLUME_DEPTH_SHIFT));
d743 2
d746 14
a759 2
   {
      GLuint minFilt, mipFilt, magFilt;
d761 6
a766 27
      switch (tObj->MinFilter) {
      case GL_NEAREST:
         minFilt = FILTER_NEAREST;
         mipFilt = MIPFILTER_NONE;
         break;
      case GL_LINEAR:
         minFilt = FILTER_LINEAR;
         mipFilt = MIPFILTER_NONE;
         break;
      case GL_NEAREST_MIPMAP_NEAREST:
         minFilt = FILTER_NEAREST;
         mipFilt = MIPFILTER_NEAREST;
         break;
      case GL_LINEAR_MIPMAP_NEAREST:
         minFilt = FILTER_LINEAR;
         mipFilt = MIPFILTER_NEAREST;
         break;
      case GL_NEAREST_MIPMAP_LINEAR:
         minFilt = FILTER_NEAREST;
         mipFilt = MIPFILTER_LINEAR;
         break;
      case GL_LINEAR_MIPMAP_LINEAR:
         minFilt = FILTER_LINEAR;
         mipFilt = MIPFILTER_LINEAR;
         break;
      default:
         return GL_FALSE;
d768 1
d770 2
a771 28
      if (tObj->MaxAnisotropy > 1.0) {
         minFilt = FILTER_ANISOTROPIC;
         magFilt = FILTER_ANISOTROPIC;
         if (tObj->MaxAnisotropy > 2.0)
            aniso = SS2_MAX_ANISO_4;
         else
            aniso = SS2_MAX_ANISO_2;
      }
      else {
         switch (tObj->MagFilter) {
         case GL_NEAREST:
            magFilt = FILTER_NEAREST;
            break;
         case GL_LINEAR:
            magFilt = FILTER_LINEAR;
            break;
         default:
            return GL_FALSE;
         }
      }

      lodbias = (int) ((tUnit->LodBias + tObj->LodBias) * 16.0);
      if (lodbias < -256)
          lodbias = -256;
      if (lodbias > 255)
          lodbias = 255;
      state[I915_TEXREG_SS2] = ((lodbias << SS2_LOD_BIAS_SHIFT) & 
                                SS2_LOD_BIAS_MASK);
a772 5
      /* YUV conversion:
       */
      if (firstImage->TexFormat == MESA_FORMAT_YCBCR ||
          firstImage->TexFormat == MESA_FORMAT_YCBCR_REV)
         state[I915_TEXREG_SS2] |= SS2_COLORSPACE_CONVERSION;
d774 13
a786 19
      /* Shadow:
       */
      if (tObj->CompareMode == GL_COMPARE_R_TO_TEXTURE_ARB &&
          tObj->Target != GL_TEXTURE_3D) {
         if (tObj->Target == GL_TEXTURE_1D) 
            return GL_FALSE;

         state[I915_TEXREG_SS2] |=
            (SS2_SHADOW_ENABLE |
             intel_translate_shadow_compare_func(tObj->CompareFunc));

         minFilt = FILTER_4X4_FLAT;
         magFilt = FILTER_4X4_FLAT;
      }

      state[I915_TEXREG_SS2] |= ((minFilt << SS2_MIN_FILTER_SHIFT) |
                                 (mipFilt << SS2_MIP_FILTER_SHIFT) |
                                 (magFilt << SS2_MAG_FILTER_SHIFT) |
                                 aniso);
d789 8
a796 12
   {
      GLenum ws = tObj->WrapS;
      GLenum wt = tObj->WrapT;
      GLenum wr = tObj->WrapR;
      float minlod;

      /* We program 1D textures as 2D textures, so the 2D texcoord could
       * result in sampling border values if we don't set the T wrap to
       * repeat.
       */
      if (tObj->Target == GL_TEXTURE_1D)
	 wt = GL_REPEAT;
d798 2
a799 16
      /* 3D textures don't seem to respect the border color.
       * Fallback if there's ever a danger that they might refer to
       * it.  
       * 
       * Effectively this means fallback on 3D clamp or
       * clamp_to_border.
       */
      if (tObj->Target == GL_TEXTURE_3D &&
          (tObj->MinFilter != GL_NEAREST ||
           tObj->MagFilter != GL_NEAREST) &&
          (ws == GL_CLAMP ||
           wt == GL_CLAMP ||
           wr == GL_CLAMP ||
           ws == GL_CLAMP_TO_BORDER ||
           wt == GL_CLAMP_TO_BORDER || wr == GL_CLAMP_TO_BORDER))
         return GL_FALSE;
d801 15
a815 19
      /* Only support TEXCOORDMODE_CLAMP_EDGE and TEXCOORDMODE_CUBE (not 
       * used) when using cube map texture coordinates
       */
      if (tObj->Target == GL_TEXTURE_CUBE_MAP_ARB &&
          (((ws != GL_CLAMP) && (ws != GL_CLAMP_TO_EDGE)) ||
           ((wt != GL_CLAMP) && (wt != GL_CLAMP_TO_EDGE))))
          return GL_FALSE;

      state[I915_TEXREG_SS3] = ss3;     /* SS3_NORMALIZED_COORDS */

      state[I915_TEXREG_SS3] |=
         ((translate_wrap_mode(ws) << SS3_TCX_ADDR_MODE_SHIFT) |
          (translate_wrap_mode(wt) << SS3_TCY_ADDR_MODE_SHIFT) |
          (translate_wrap_mode(wr) << SS3_TCZ_ADDR_MODE_SHIFT));

      minlod = MIN2(tObj->MinLod, tObj->_MaxLevel - tObj->BaseLevel);
      state[I915_TEXREG_SS3] |= (unit << SS3_TEXTUREMAP_INDEX_SHIFT);
      state[I915_TEXREG_SS3] |= (U_FIXED(CLAMP(minlod, 0.0, 11.0), 4) <<
				 SS3_MIN_LOD_SHIFT);
d817 6
d825 7
a831 20
   /* convert border color from float to ubyte */
   CLAMPED_FLOAT_TO_UBYTE(border[0], tObj->BorderColor.f[0]);
   CLAMPED_FLOAT_TO_UBYTE(border[1], tObj->BorderColor.f[1]);
   CLAMPED_FLOAT_TO_UBYTE(border[2], tObj->BorderColor.f[2]);
   CLAMPED_FLOAT_TO_UBYTE(border[3], tObj->BorderColor.f[3]);

   if (firstImage->_BaseFormat == GL_DEPTH_COMPONENT) {
      /* GL specs that border color for depth textures is taken from the
       * R channel, while the hardware uses A.  Spam R into all the channels
       * for safety.
       */
      state[I915_TEXREG_SS4] = PACK_COLOR_8888(border[0],
					       border[0],
					       border[0],
					       border[0]);
   } else {
      state[I915_TEXREG_SS4] = PACK_COLOR_8888(border[3],
					       border[0],
					       border[1],
					       border[2]);
d835 10
a844 3
   I915_ACTIVESTATE(i915, I915_UPLOAD_TEX(unit), GL_TRUE);
   /* memcmp was already disabled, but definitely won't work as the
    * region might now change and that wouldn't be detected:
d846 7
a852 1
   I915_STATECHANGE(i915, I915_UPLOAD_TEX(unit));
d854 8
d863 7
a869 8
#if 0
   DBG(TEXTURE, "state[I915_TEXREG_SS2] = 0x%x\n", state[I915_TEXREG_SS2]);
   DBG(TEXTURE, "state[I915_TEXREG_SS3] = 0x%x\n", state[I915_TEXREG_SS3]);
   DBG(TEXTURE, "state[I915_TEXREG_SS4] = 0x%x\n", state[I915_TEXREG_SS4]);
   DBG(TEXTURE, "state[I915_TEXREG_MS2] = 0x%x\n", state[I915_TEXREG_MS2]);
   DBG(TEXTURE, "state[I915_TEXREG_MS3] = 0x%x\n", state[I915_TEXREG_MS3]);
   DBG(TEXTURE, "state[I915_TEXREG_MS4] = 0x%x\n", state[I915_TEXREG_MS4]);
#endif
d874 7
d882 21
d905 1
a905 2
void
i915UpdateTextureState(struct intel_context *intel)
d907 1
d911 2
a912 27
   for (i = 0; i < I915_TEX_UNITS && ok; i++) {
      switch (intel->ctx.Texture.Unit[i]._ReallyEnabled) {
      case TEXTURE_1D_BIT:
      case TEXTURE_2D_BIT:
      case TEXTURE_CUBE_BIT:
      case TEXTURE_3D_BIT:
         ok = i915_update_tex_unit(intel, i, SS3_NORMALIZED_COORDS);
         break;
      case TEXTURE_RECT_BIT:
         ok = i915_update_tex_unit(intel, i, 0);
         break;
      case 0:{
            struct i915_context *i915 = i915_context(&intel->ctx);
            if (i915->state.active & I915_UPLOAD_TEX(i))
               I915_ACTIVESTATE(i915, I915_UPLOAD_TEX(i), GL_FALSE);

	    if (i915->state.tex_buffer[i] != NULL) {
	       drm_intel_bo_unreference(i915->state.tex_buffer[i]);
	       i915->state.tex_buffer[i] = NULL;
	    }

            break;
         }
      default:
         ok = GL_FALSE;
         break;
      }
d915 1
a915 1
   FALLBACK(intel, I915_FALLBACK_TEXTURE, !ok);
d917 3
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@a31 1
#include "main/samplerobj.h"
d41 2
a42 1
translate_texture_format(gl_format mesa_format, GLenum DepthMode)
a58 1
   case MESA_FORMAT_SARGB8:
a62 2
   case MESA_FORMAT_RGBA8888_REV:
      return MAPSURF_32BIT | MT_32BIT_ABGR8888;
a78 2
   case MESA_FORMAT_SRGB_DXT1:
   case MESA_FORMAT_SRGBA_DXT1:
a80 1
   case MESA_FORMAT_SRGBA_DXT3:
a82 1
   case MESA_FORMAT_SRGBA_DXT5:
a84 1
   case MESA_FORMAT_X8_Z24:
d92 1
a92 2
      fprintf(stderr, "%s: bad image format %s\n", __FUNCTION__,
	      _mesa_get_format_name(mesa_format));
d130 1
a130 1
static bool
d139 1
a139 2
   struct gl_sampler_object *sampler = _mesa_get_samplerobj(ctx, unit);
   GLuint *state = i915->state.Tex[unit], format;
d144 1
a144 1
   memset(state, 0, sizeof(*state));
d154 1
a154 1
      return false;
d159 1
a159 1
   firstImage = tObj->Image[0][tObj->BaseLevel];
d161 3
a163 3
   drm_intel_bo_reference(intelObj->mt->region->bo);
   i915->state.tex_buffer[unit] = intelObj->mt->region->bo;
   i915->state.tex_offset[unit] = intelObj->mt->offset;
d166 1
d168 1
d184 1
a184 1
   maxlod = MIN2(sampler->MaxLod, tObj->_MaxLevel - tObj->BaseLevel);
d186 1
a186 1
      ((((intelObj->mt->region->pitch / 4) - 1) << MS4_PITCH_SHIFT) |
d195 1
a195 1
      switch (sampler->MinFilter) {
d221 1
a221 1
         return false;
d224 1
a224 1
      if (sampler->MaxAnisotropy > 1.0) {
d227 1
a227 1
         if (sampler->MaxAnisotropy > 2.0)
d233 1
a233 1
         switch (sampler->MagFilter) {
d241 1
a241 1
            return false;
d245 1
a245 1
      lodbias = (int) ((tUnit->LodBias + sampler->LodBias) * 16.0);
d261 1
a261 1
      if (sampler->CompareMode == GL_COMPARE_R_TO_TEXTURE_ARB &&
d264 1
a264 1
            return false;
d268 1
a268 1
             intel_translate_shadow_compare_func(sampler->CompareFunc));
d281 3
a283 3
      GLenum ws = sampler->WrapS;
      GLenum wt = sampler->WrapT;
      GLenum wr = sampler->WrapR;
d301 2
a302 2
          (sampler->MinFilter != GL_NEAREST ||
           sampler->MagFilter != GL_NEAREST) &&
d308 1
a308 1
         return false;
d316 1
a316 23
          return false;

      /*
       * According to 3DSTATE_MAP_STATE at page of 104 in Bspec
       * Vol3d 3D Instructions:
       *   [DevGDG and DevAlv]: Must be a power of 2 for cube maps.
       *   [DevLPT, DevCST and DevBLB]: If not a power of 2, cube maps
       *      must have all faces enabled.
       *
       * But, as I tested on pineview(DevBLB derived), the rendering is
       * bad(you will find the color isn't samplered right in some
       * fragments). After checking, it seems that the texture layout is
       * wrong: making the width and height align of 4(although this
       * doesn't make much sense) will fix this issue and also broke some
       * others. Well, Bspec mentioned nothing about the layout alignment
       * and layout for NPOT cube map.  I guess the Bspec just assume it's
       * a POT cube map.
       *
       * Thus, I guess we need do this for other platforms as well.
       */
      if (tObj->Target == GL_TEXTURE_CUBE_MAP_ARB &&
          !is_power_of_two(firstImage->Height))
         return false;
d325 1
a325 1
      minlod = MIN2(sampler->MinLod, tObj->_MaxLevel - tObj->BaseLevel);
a331 6
   if (sampler->sRGBDecode == GL_DECODE_EXT &&
       (_mesa_get_srgb_format_linear(firstImage->TexFormat) !=
        firstImage->TexFormat)) {
      state[I915_TEXREG_SS2] |= SS2_REVERSE_GAMMA_ENABLE;
   }

d333 4
a336 4
   CLAMPED_FLOAT_TO_UBYTE(border[0], sampler->BorderColor.f[0]);
   CLAMPED_FLOAT_TO_UBYTE(border[1], sampler->BorderColor.f[1]);
   CLAMPED_FLOAT_TO_UBYTE(border[2], sampler->BorderColor.f[2]);
   CLAMPED_FLOAT_TO_UBYTE(border[3], sampler->BorderColor.f[3]);
d355 1
a355 1
   I915_ACTIVESTATE(i915, I915_UPLOAD_TEX(unit), true);
d371 1
a371 1
   return true;
d380 1
a380 1
   bool ok = true;
d397 1
a397 1
               I915_ACTIVESTATE(i915, I915_UPLOAD_TEX(i), false);
d407 1
a407 1
         ok = false;
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d42 1
a42 1
translate_texture_format(mesa_format mesa_format, GLenum DepthMode)
d45 1
a45 1
   case MESA_FORMAT_L_UNORM8:
d47 1
a47 1
   case MESA_FORMAT_I_UNORM8:
d49 1
a49 1
   case MESA_FORMAT_A_UNORM8:
d51 1
a51 1
   case MESA_FORMAT_L8A8_UNORM:
d53 1
a53 1
   case MESA_FORMAT_B5G6R5_UNORM:
d55 1
a55 1
   case MESA_FORMAT_B5G5R5A1_UNORM:
d57 1
a57 1
   case MESA_FORMAT_B4G4R4A4_UNORM:
d59 2
a60 2
   case MESA_FORMAT_B8G8R8A8_SRGB:
   case MESA_FORMAT_B8G8R8A8_UNORM:
d62 1
a62 1
   case MESA_FORMAT_B8G8R8X8_UNORM:
d64 1
a64 1
   case MESA_FORMAT_R8G8B8A8_UNORM:
d73 1
a73 1
   case MESA_FORMAT_Z_UNORM16:
d91 2
a92 2
   case MESA_FORMAT_Z24_UNORM_S8_UINT:
   case MESA_FORMAT_Z24_UNORM_X8_UINT:
d420 20
a439 13
      if (intel->ctx.Texture.Unit[i]._Current) {
         switch (intel->ctx.Texture.Unit[i]._Current->Target) {
         case GL_TEXTURE_1D:
         case GL_TEXTURE_2D:
         case GL_TEXTURE_CUBE_MAP:
         case GL_TEXTURE_3D:
            ok = i915_update_tex_unit(intel, i, SS3_NORMALIZED_COORDS);
            break;
         case GL_TEXTURE_RECTANGLE:
            ok = i915_update_tex_unit(intel, i, 0);
            break;
         default:
            ok = false;
d442 3
a444 9
      } else {
         struct i915_context *i915 = i915_context(&intel->ctx);
         if (i915->state.active & I915_UPLOAD_TEX(i))
            I915_ACTIVESTATE(i915, I915_UPLOAD_TEX(i), false);

         if (i915->state.tex_buffer[i] != NULL) {
            drm_intel_bo_unreference(i915->state.tex_buffer[i]);
            i915->state.tex_buffer[i] = NULL;
         }
@


