head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.04.15;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.14;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.38;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.38;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.10;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.15.25;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.48;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.11.27;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.48.34;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/** @@file intel_tris.c
 *
 * This file contains functions for managing the vertex buffer and emitting
 * primitives into it.
 */

#include "main/glheader.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/enums.h"
#include "main/texobj.h"
#include "main/state.h"
#include "main/dd.h"
#include "main/fbobject.h"

#include "swrast/swrast.h"
#include "swrast_setup/swrast_setup.h"
#include "tnl/t_context.h"
#include "tnl/t_pipeline.h"
#include "tnl/t_vertex.h"

#include "intel_screen.h"
#include "intel_context.h"
#include "intel_tris.h"
#include "intel_batchbuffer.h"
#include "intel_buffers.h"
#include "intel_reg.h"
#include "i830_context.h"
#include "i830_reg.h"
#include "i915_context.h"

static void intelRenderPrimitive(struct gl_context * ctx, GLenum prim);
static void intelRasterPrimitive(struct gl_context * ctx, GLenum rprim,
                                 GLuint hwprim);

static void
intel_flush_inline_primitive(struct intel_context *intel)
{
   GLuint used = intel->batch.used - intel->prim.start_ptr;

   assert(intel->prim.primitive != ~0);

/*    printf("/\n"); */

   if (used < 2)
      goto do_discard;

   intel->batch.map[intel->prim.start_ptr] =
      _3DPRIMITIVE | intel->prim.primitive | (used - 2);

   goto finished;

 do_discard:
   intel->batch.used = intel->prim.start_ptr;

 finished:
   intel->prim.primitive = ~0;
   intel->prim.start_ptr = 0;
   intel->prim.flush = 0;
}

static void intel_start_inline(struct intel_context *intel, uint32_t prim)
{
   BATCH_LOCALS;

   intel->vtbl.emit_state(intel);

   intel->no_batch_wrap = true;

   /* Emit a slot which will be filled with the inline primitive
    * command later.
    */
   BEGIN_BATCH(1);

   intel->prim.start_ptr = intel->batch.used;
   intel->prim.primitive = prim;
   intel->prim.flush = intel_flush_inline_primitive;

   OUT_BATCH(0);
   ADVANCE_BATCH();

   intel->no_batch_wrap = false;
/*    printf(">"); */
}

static void intel_wrap_inline(struct intel_context *intel)
{
   GLuint prim = intel->prim.primitive;

   intel_flush_inline_primitive(intel);
   intel_batchbuffer_flush(intel);
   intel_start_inline(intel, prim);  /* ??? */
}

static GLuint *intel_extend_inline(struct intel_context *intel, GLuint dwords)
{
   GLuint *ptr;

   assert(intel->prim.flush == intel_flush_inline_primitive);

   if (intel_batchbuffer_space(intel) < dwords * sizeof(GLuint))
      intel_wrap_inline(intel);

/*    printf("."); */

   intel->vtbl.assert_not_dirty(intel);

   ptr = intel->batch.map + intel->batch.used;
   intel->batch.used += dwords;

   return ptr;
}

/** Sets the primitive type for a primitive sequence, flushing as needed. */
void intel_set_prim(struct intel_context *intel, uint32_t prim)
{
   /* if we have no VBOs */

   if (intel->intelScreen->no_vbo) {
      intel_start_inline(intel, prim);
      return;
   }
   if (prim != intel->prim.primitive) {
      INTEL_FIREVERTICES(intel);
      intel->prim.primitive = prim;
   }
}

/** Returns mapped VB space for the given number of vertices */
uint32_t *intel_get_prim_space(struct intel_context *intel, unsigned int count)
{
   uint32_t *addr;

   if (intel->intelScreen->no_vbo) {
      return intel_extend_inline(intel, count * intel->vertex_size);
   }

   /* Check for space in the existing VB */
   if (intel->prim.vb_bo == NULL ||
       (intel->prim.current_offset +
	count * intel->vertex_size * 4) > INTEL_VB_SIZE ||
       (intel->prim.count + count) >= (1 << 16)) {
      /* Flush existing prim if any */
      INTEL_FIREVERTICES(intel);

      intel_finish_vb(intel);

      /* Start a new VB */
      if (intel->prim.vb == NULL)
	 intel->prim.vb = malloc(INTEL_VB_SIZE);
      intel->prim.vb_bo = drm_intel_bo_alloc(intel->bufmgr, "vb",
					     INTEL_VB_SIZE, 4);
      intel->prim.start_offset = 0;
      intel->prim.current_offset = 0;
   }

   intel->prim.flush = intel_flush_prim;

   addr = (uint32_t *)(intel->prim.vb + intel->prim.current_offset);
   intel->prim.current_offset += intel->vertex_size * 4 * count;
   intel->prim.count += count;

   return addr;
}

/** Dispatches the accumulated primitive to the batchbuffer. */
void intel_flush_prim(struct intel_context *intel)
{
   drm_intel_bo *aper_array[2];
   drm_intel_bo *vb_bo;
   unsigned int offset, count;
   BATCH_LOCALS;

   /* Must be called after an intel_start_prim. */
   assert(intel->prim.primitive != ~0);

   if (intel->prim.count == 0)
      return;

   /* Clear the current prims out of the context state so that a batch flush
    * flush triggered by emit_state doesn't loop back to flush_prim again.
    */
   vb_bo = intel->prim.vb_bo;
   drm_intel_bo_reference(vb_bo);
   count = intel->prim.count;
   intel->prim.count = 0;
   offset = intel->prim.start_offset;
   intel->prim.start_offset = intel->prim.current_offset;
   if (intel->gen < 3)
      intel->prim.current_offset = intel->prim.start_offset = ALIGN(intel->prim.start_offset, 128);
   intel->prim.flush = NULL;

   intel->vtbl.emit_state(intel);

   aper_array[0] = intel->batch.bo;
   aper_array[1] = vb_bo;
   if (dri_bufmgr_check_aperture_space(aper_array, 2)) {
      intel_batchbuffer_flush(intel);
      intel->vtbl.emit_state(intel);
   }

   /* Ensure that we don't start a new batch for the following emit, which
    * depends on the state just emitted. emit_state should be making sure we
    * have the space for this.
    */
   intel->no_batch_wrap = true;

   if (intel->always_flush_cache) {
      intel_batchbuffer_emit_mi_flush(intel);
   }

#if 0
   printf("emitting %d..%d=%d vertices size %d\n", offset,
	  intel->prim.current_offset, count,
	  intel->vertex_size * 4);
#endif

   if (intel->gen >= 3) {
      struct i915_context *i915 = i915_context(&intel->ctx);
      unsigned int cmd = 0, len = 0;

      if (vb_bo != i915->current_vb_bo) {
	 cmd |= I1_LOAD_S(0);
	 len++;
      }

      if (intel->vertex_size != i915->current_vertex_size) {
	 cmd |= I1_LOAD_S(1);
	 len++;
      }
      if (len)
	 len++;

      BEGIN_BATCH(2+len);
      if (cmd)
	 OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | cmd | (len - 2));
      if (vb_bo != i915->current_vb_bo) {
	 OUT_RELOC(vb_bo, I915_GEM_DOMAIN_VERTEX, 0, 0);
	 i915->current_vb_bo = vb_bo;
      }
      if (intel->vertex_size != i915->current_vertex_size) {
	 OUT_BATCH((intel->vertex_size << S1_VERTEX_WIDTH_SHIFT) |
		   (intel->vertex_size << S1_VERTEX_PITCH_SHIFT));
	 i915->current_vertex_size = intel->vertex_size;
      }
      OUT_BATCH(_3DPRIMITIVE |
		PRIM_INDIRECT |
		PRIM_INDIRECT_SEQUENTIAL |
		intel->prim.primitive |
		count);
      OUT_BATCH(offset / (intel->vertex_size * 4));
      ADVANCE_BATCH();
   } else {
      struct i830_context *i830 = i830_context(&intel->ctx);

      BEGIN_BATCH(5);
      OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 |
		I1_LOAD_S(0) | I1_LOAD_S(2) | 1);
      /* S0 */
      assert((offset & ~S0_VB_OFFSET_MASK_830) == 0);
      OUT_RELOC(vb_bo, I915_GEM_DOMAIN_VERTEX, 0,
		offset | (intel->vertex_size << S0_VB_PITCH_SHIFT_830) |
		S0_VB_ENABLE_830);
      /* S2
       * This is somewhat unfortunate -- VB width is tied up with
       * vertex format data that we've already uploaded through
       * _3DSTATE_VFT[01]_CMD.  We may want to replace emits of VFT state with
       * STATE_IMMEDIATE_1 like this to avoid duplication.
       */
      OUT_BATCH((i830->state.Ctx[I830_CTXREG_VF] & VFT0_TEX_COUNT_MASK) >>
		VFT0_TEX_COUNT_SHIFT << S2_TEX_COUNT_SHIFT_830 |
		(i830->state.Ctx[I830_CTXREG_VF2] << 16) |
		intel->vertex_size << S2_VERTEX_0_WIDTH_SHIFT_830);

      OUT_BATCH(_3DPRIMITIVE |
		PRIM_INDIRECT |
		PRIM_INDIRECT_SEQUENTIAL |
		intel->prim.primitive |
		count);
      OUT_BATCH(0); /* Beginning vertex index */
      ADVANCE_BATCH();
   }

   if (intel->always_flush_cache) {
      intel_batchbuffer_emit_mi_flush(intel);
   }

   intel->no_batch_wrap = false;

   drm_intel_bo_unreference(vb_bo);
}

/**
 * Uploads the locally-accumulated VB into the buffer object.
 *
 * This avoids us thrashing the cachelines in and out as the buffer gets
 * filled, dispatched, then reused as the hardware completes rendering from it,
 * and also lets us clflush less if we dispatch with a partially-filled VB.
 *
 * This is called normally from get_space when we're finishing a BO, but also
 * at batch flush time so that we don't try accessing the contents of a
 * just-dispatched buffer.
 */
void intel_finish_vb(struct intel_context *intel)
{
   if (intel->prim.vb_bo == NULL)
      return;

   drm_intel_bo_subdata(intel->prim.vb_bo, 0, intel->prim.start_offset,
			intel->prim.vb);
   drm_intel_bo_unreference(intel->prim.vb_bo);
   intel->prim.vb_bo = NULL;
}

/***********************************************************************
 *                    Emit primitives as inline vertices               *
 ***********************************************************************/

#ifdef __i386__
#define COPY_DWORDS( j, vb, vertsize, v )			\
do {								\
   int __tmp;							\
   __asm__ __volatile__( "rep ; movsl"				\
			 : "=%c" (j), "=D" (vb), "=S" (__tmp)	\
			 : "0" (vertsize),			\
			 "D" ((long)vb),			\
			 "S" ((long)v) );			\
} while (0)
#else
#define COPY_DWORDS( j, vb, vertsize, v )	\
do {						\
   for ( j = 0 ; j < vertsize ; j++ ) {		\
      vb[j] = ((GLuint *)v)[j];			\
   }						\
   vb += vertsize;				\
} while (0)
#endif

static void
intel_draw_quad(struct intel_context *intel,
                intelVertexPtr v0,
                intelVertexPtr v1, intelVertexPtr v2, intelVertexPtr v3)
{
   GLuint vertsize = intel->vertex_size;
   GLuint *vb = intel_get_prim_space(intel, 6);
   int j;

   COPY_DWORDS(j, vb, vertsize, v0);
   COPY_DWORDS(j, vb, vertsize, v1);

   /* If smooth shading, draw like a trifan which gives better
    * rasterization.  Otherwise draw as two triangles with provoking
    * vertex in third position as required for flat shading.
    */
   if (intel->ctx.Light.ShadeModel == GL_FLAT) {
      COPY_DWORDS(j, vb, vertsize, v3);
      COPY_DWORDS(j, vb, vertsize, v1);
   }
   else {
      COPY_DWORDS(j, vb, vertsize, v2);
      COPY_DWORDS(j, vb, vertsize, v0);
   }

   COPY_DWORDS(j, vb, vertsize, v2);
   COPY_DWORDS(j, vb, vertsize, v3);
}

static void
intel_draw_triangle(struct intel_context *intel,
                    intelVertexPtr v0, intelVertexPtr v1, intelVertexPtr v2)
{
   GLuint vertsize = intel->vertex_size;
   GLuint *vb = intel_get_prim_space(intel, 3);
   int j;

   COPY_DWORDS(j, vb, vertsize, v0);
   COPY_DWORDS(j, vb, vertsize, v1);
   COPY_DWORDS(j, vb, vertsize, v2);
}


static void
intel_draw_line(struct intel_context *intel,
                intelVertexPtr v0, intelVertexPtr v1)
{
   GLuint vertsize = intel->vertex_size;
   GLuint *vb = intel_get_prim_space(intel, 2);
   int j;

   COPY_DWORDS(j, vb, vertsize, v0);
   COPY_DWORDS(j, vb, vertsize, v1);
}


static void
intel_draw_point(struct intel_context *intel, intelVertexPtr v0)
{
   GLuint vertsize = intel->vertex_size;
   GLuint *vb = intel_get_prim_space(intel, 1);
   int j;

   /* Adjust for sub pixel position -- still required for conform. */
   *(float *) &vb[0] = v0->v.x;
   *(float *) &vb[1] = v0->v.y;
   for (j = 2; j < vertsize; j++)
      vb[j] = v0->ui[j];
}



/***********************************************************************
 *                Fixup for ARB_point_parameters                       *
 ***********************************************************************/

/* Currently not working - VERT_ATTRIB_POINTSIZE isn't correctly
 * represented in the fragment program InputsRead field.
 */
static void
intel_atten_point(struct intel_context *intel, intelVertexPtr v0)
{
   struct gl_context *ctx = &intel->ctx;
   GLfloat psz[4], col[4], restore_psz, restore_alpha;

   _tnl_get_attr(ctx, v0, _TNL_ATTRIB_POINTSIZE, psz);
   _tnl_get_attr(ctx, v0, _TNL_ATTRIB_COLOR0, col);

   restore_psz = psz[0];
   restore_alpha = col[3];

   if (psz[0] >= ctx->Point.Threshold) {
      psz[0] = MIN2(psz[0], ctx->Point.MaxSize);
   }
   else {
      GLfloat dsize = psz[0] / ctx->Point.Threshold;
      psz[0] = MAX2(ctx->Point.Threshold, ctx->Point.MinSize);
      col[3] *= dsize * dsize;
   }

   if (psz[0] < 1.0)
      psz[0] = 1.0;

   if (restore_psz != psz[0] || restore_alpha != col[3]) {
      _tnl_set_attr(ctx, v0, _TNL_ATTRIB_POINTSIZE, psz);
      _tnl_set_attr(ctx, v0, _TNL_ATTRIB_COLOR0, col);

      intel_draw_point(intel, v0);

      psz[0] = restore_psz;
      col[3] = restore_alpha;

      _tnl_set_attr(ctx, v0, _TNL_ATTRIB_POINTSIZE, psz);
      _tnl_set_attr(ctx, v0, _TNL_ATTRIB_COLOR0, col);
   }
   else
      intel_draw_point(intel, v0);
}





/***********************************************************************
 *                Fixup for I915 WPOS texture coordinate                *
 ***********************************************************************/

static void
intel_emit_fragcoord(struct intel_context *intel, intelVertexPtr v)
{
   struct gl_context *ctx = &intel->ctx;
   struct gl_framebuffer *fb = ctx->DrawBuffer;
   GLuint offset = intel->wpos_offset;
   float *vertex_position = (float *)v;
   float *fragcoord = (float *)((char *)v + offset);

   fragcoord[0] = vertex_position[0];

   if (_mesa_is_user_fbo(fb))
      fragcoord[1] = vertex_position[1];
   else
      fragcoord[1] = fb->Height - vertex_position[1];

   fragcoord[2] = vertex_position[2];
   fragcoord[3] = vertex_position[3];
}

static void
intel_wpos_triangle(struct intel_context *intel,
                    intelVertexPtr v0, intelVertexPtr v1, intelVertexPtr v2)
{
   intel_emit_fragcoord(intel, v0);
   intel_emit_fragcoord(intel, v1);
   intel_emit_fragcoord(intel, v2);

   intel_draw_triangle(intel, v0, v1, v2);
}


static void
intel_wpos_line(struct intel_context *intel,
                intelVertexPtr v0, intelVertexPtr v1)
{
   intel_emit_fragcoord(intel, v0);
   intel_emit_fragcoord(intel, v1);
   intel_draw_line(intel, v0, v1);
}


static void
intel_wpos_point(struct intel_context *intel, intelVertexPtr v0)
{
   intel_emit_fragcoord(intel, v0);
   intel_draw_point(intel, v0);
}






/***********************************************************************
 *          Macros for t_dd_tritmp.h to draw basic primitives          *
 ***********************************************************************/

#define TRI( a, b, c )				\
do { 						\
   if (DO_FALLBACK)				\
      intel->draw_tri( intel, a, b, c );	\
   else						\
      intel_draw_triangle( intel, a, b, c );	\
} while (0)

#define QUAD( a, b, c, d )			\
do { 						\
   if (DO_FALLBACK) {				\
      intel->draw_tri( intel, a, b, d );	\
      intel->draw_tri( intel, b, c, d );	\
   } else					\
      intel_draw_quad( intel, a, b, c, d );	\
} while (0)

#define LINE( v0, v1 )				\
do { 						\
   if (DO_FALLBACK)				\
      intel->draw_line( intel, v0, v1 );	\
   else						\
      intel_draw_line( intel, v0, v1 );		\
} while (0)

#define POINT( v0 )				\
do { 						\
   if (DO_FALLBACK)				\
      intel->draw_point( intel, v0 );		\
   else						\
      intel_draw_point( intel, v0 );		\
} while (0)


/***********************************************************************
 *              Build render functions from dd templates               *
 ***********************************************************************/

#define INTEL_OFFSET_BIT 	0x01
#define INTEL_TWOSIDE_BIT	0x02
#define INTEL_UNFILLED_BIT	0x04
#define INTEL_FALLBACK_BIT	0x08
#define INTEL_MAX_TRIFUNC	0x10


static struct
{
   tnl_points_func points;
   tnl_line_func line;
   tnl_triangle_func triangle;
   tnl_quad_func quad;
} rast_tab[INTEL_MAX_TRIFUNC];


#define DO_FALLBACK (IND & INTEL_FALLBACK_BIT)
#define DO_OFFSET   (IND & INTEL_OFFSET_BIT)
#define DO_UNFILLED (IND & INTEL_UNFILLED_BIT)
#define DO_TWOSIDE  (IND & INTEL_TWOSIDE_BIT)
#define DO_FLAT      0
#define DO_TRI       1
#define DO_QUAD      1
#define DO_LINE      1
#define DO_POINTS    1
#define DO_FULL_QUAD 1

#define HAVE_SPEC         1
#define HAVE_BACK_COLORS  0
#define HAVE_HW_FLATSHADE 1
#define VERTEX            intelVertex
#define TAB               rast_tab

/* Only used to pull back colors into vertices (ie, we know color is
 * floating point).
 */
#define INTEL_COLOR( dst, src )				\
do {							\
   UNCLAMPED_FLOAT_TO_UBYTE((dst)[0], (src)[2]);	\
   UNCLAMPED_FLOAT_TO_UBYTE((dst)[1], (src)[1]);	\
   UNCLAMPED_FLOAT_TO_UBYTE((dst)[2], (src)[0]);	\
   UNCLAMPED_FLOAT_TO_UBYTE((dst)[3], (src)[3]);	\
} while (0)

#define INTEL_SPEC( dst, src )				\
do {							\
   UNCLAMPED_FLOAT_TO_UBYTE((dst)[0], (src)[2]);	\
   UNCLAMPED_FLOAT_TO_UBYTE((dst)[1], (src)[1]);	\
   UNCLAMPED_FLOAT_TO_UBYTE((dst)[2], (src)[0]);	\
} while (0)


#define DEPTH_SCALE (ctx->DrawBuffer->Visual.depthBits == 16 ? 1.0 : 2.0)
#define UNFILLED_TRI unfilled_tri
#define UNFILLED_QUAD unfilled_quad
#define VERT_X(_v) _v->v.x
#define VERT_Y(_v) _v->v.y
#define VERT_Z(_v) _v->v.z
#define AREA_IS_CCW( a ) (a > 0)
#define GET_VERTEX(e) (intel->verts + (e * intel->vertex_size * sizeof(GLuint)))

#define VERT_SET_RGBA( v, c )    if (coloroffset) INTEL_COLOR( v->ub4[coloroffset], c )
#define VERT_COPY_RGBA( v0, v1 ) if (coloroffset) v0->ui[coloroffset] = v1->ui[coloroffset]
#define VERT_SAVE_RGBA( idx )    if (coloroffset) color[idx] = v[idx]->ui[coloroffset]
#define VERT_RESTORE_RGBA( idx ) if (coloroffset) v[idx]->ui[coloroffset] = color[idx]

#define VERT_SET_SPEC( v, c )    if (specoffset) INTEL_SPEC( v->ub4[specoffset], c )
#define VERT_COPY_SPEC( v0, v1 ) if (specoffset) COPY_3V(v0->ub4[specoffset], v1->ub4[specoffset])
#define VERT_SAVE_SPEC( idx )    if (specoffset) spec[idx] = v[idx]->ui[specoffset]
#define VERT_RESTORE_SPEC( idx ) if (specoffset) v[idx]->ui[specoffset] = spec[idx]

#define LOCAL_VARS(n)							\
   struct intel_context *intel = intel_context(ctx);			\
   GLuint color[n] = { 0, }, spec[n] = { 0, };				\
   GLuint coloroffset = intel->coloroffset;				\
   GLuint specoffset = intel->specoffset;				\
   (void) color; (void) spec; (void) coloroffset; (void) specoffset;


/***********************************************************************
 *                Helpers for rendering unfilled primitives            *
 ***********************************************************************/

static const GLuint hw_prim[GL_POLYGON + 1] = {
   PRIM3D_POINTLIST,
   PRIM3D_LINELIST,
   PRIM3D_LINELIST,
   PRIM3D_LINELIST,
   PRIM3D_TRILIST,
   PRIM3D_TRILIST,
   PRIM3D_TRILIST,
   PRIM3D_TRILIST,
   PRIM3D_TRILIST,
   PRIM3D_TRILIST
};

#define RASTERIZE(x) intelRasterPrimitive( ctx, x, hw_prim[x] )
#define RENDER_PRIMITIVE intel->render_primitive
#define TAG(x) x
#define IND INTEL_FALLBACK_BIT
#include "tnl_dd/t_dd_unfilled.h"
#undef IND

/***********************************************************************
 *                      Generate GL render functions                   *
 ***********************************************************************/

#define IND (0)
#define TAG(x) x
#include "tnl_dd/t_dd_tritmp.h"

#define IND (INTEL_OFFSET_BIT)
#define TAG(x) x##_offset
#include "tnl_dd/t_dd_tritmp.h"

#define IND (INTEL_TWOSIDE_BIT)
#define TAG(x) x##_twoside
#include "tnl_dd/t_dd_tritmp.h"

#define IND (INTEL_TWOSIDE_BIT|INTEL_OFFSET_BIT)
#define TAG(x) x##_twoside_offset
#include "tnl_dd/t_dd_tritmp.h"

#define IND (INTEL_UNFILLED_BIT)
#define TAG(x) x##_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (INTEL_OFFSET_BIT|INTEL_UNFILLED_BIT)
#define TAG(x) x##_offset_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (INTEL_TWOSIDE_BIT|INTEL_UNFILLED_BIT)
#define TAG(x) x##_twoside_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (INTEL_TWOSIDE_BIT|INTEL_OFFSET_BIT|INTEL_UNFILLED_BIT)
#define TAG(x) x##_twoside_offset_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (INTEL_FALLBACK_BIT)
#define TAG(x) x##_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (INTEL_OFFSET_BIT|INTEL_FALLBACK_BIT)
#define TAG(x) x##_offset_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (INTEL_TWOSIDE_BIT|INTEL_FALLBACK_BIT)
#define TAG(x) x##_twoside_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (INTEL_TWOSIDE_BIT|INTEL_OFFSET_BIT|INTEL_FALLBACK_BIT)
#define TAG(x) x##_twoside_offset_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (INTEL_UNFILLED_BIT|INTEL_FALLBACK_BIT)
#define TAG(x) x##_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (INTEL_OFFSET_BIT|INTEL_UNFILLED_BIT|INTEL_FALLBACK_BIT)
#define TAG(x) x##_offset_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (INTEL_TWOSIDE_BIT|INTEL_UNFILLED_BIT|INTEL_FALLBACK_BIT)
#define TAG(x) x##_twoside_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (INTEL_TWOSIDE_BIT|INTEL_OFFSET_BIT|INTEL_UNFILLED_BIT| \
	     INTEL_FALLBACK_BIT)
#define TAG(x) x##_twoside_offset_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"


static void
init_rast_tab(void)
{
   init();
   init_offset();
   init_twoside();
   init_twoside_offset();
   init_unfilled();
   init_offset_unfilled();
   init_twoside_unfilled();
   init_twoside_offset_unfilled();
   init_fallback();
   init_offset_fallback();
   init_twoside_fallback();
   init_twoside_offset_fallback();
   init_unfilled_fallback();
   init_offset_unfilled_fallback();
   init_twoside_unfilled_fallback();
   init_twoside_offset_unfilled_fallback();
}


/***********************************************************************
 *                    Rasterization fallback helpers                   *
 ***********************************************************************/


/* This code is hit only when a mix of accelerated and unaccelerated
 * primitives are being drawn, and only for the unaccelerated
 * primitives.
 */
static void
intel_fallback_tri(struct intel_context *intel,
                   intelVertex * v0, intelVertex * v1, intelVertex * v2)
{
   struct gl_context *ctx = &intel->ctx;
   SWvertex v[3];

   if (0)
      fprintf(stderr, "\n%s\n", __FUNCTION__);

   INTEL_FIREVERTICES(intel);

   _swsetup_Translate(ctx, v0, &v[0]);
   _swsetup_Translate(ctx, v1, &v[1]);
   _swsetup_Translate(ctx, v2, &v[2]);
   _swrast_render_start(ctx);
   _swrast_Triangle(ctx, &v[0], &v[1], &v[2]);
   _swrast_render_finish(ctx);
}


static void
intel_fallback_line(struct intel_context *intel,
                    intelVertex * v0, intelVertex * v1)
{
   struct gl_context *ctx = &intel->ctx;
   SWvertex v[2];

   if (0)
      fprintf(stderr, "\n%s\n", __FUNCTION__);

   INTEL_FIREVERTICES(intel);

   _swsetup_Translate(ctx, v0, &v[0]);
   _swsetup_Translate(ctx, v1, &v[1]);
   _swrast_render_start(ctx);
   _swrast_Line(ctx, &v[0], &v[1]);
   _swrast_render_finish(ctx);
}

static void
intel_fallback_point(struct intel_context *intel,
		     intelVertex * v0)
{
   struct gl_context *ctx = &intel->ctx;
   SWvertex v[1];

   if (0)
      fprintf(stderr, "\n%s\n", __FUNCTION__);

   INTEL_FIREVERTICES(intel);

   _swsetup_Translate(ctx, v0, &v[0]);
   _swrast_render_start(ctx);
   _swrast_Point(ctx, &v[0]);
   _swrast_render_finish(ctx);
}


/**********************************************************************/
/*               Render unclipped begin/end objects                   */
/**********************************************************************/

#define IND 0
#define V(x) (intelVertex *)(vertptr + ((x)*vertsize*sizeof(GLuint)))
#define RENDER_POINTS( start, count )	\
   for ( ; start < count ; start++) POINT( V(ELT(start)) );
#define RENDER_LINE( v0, v1 )         LINE( V(v0), V(v1) )
#define RENDER_TRI(  v0, v1, v2 )     TRI(  V(v0), V(v1), V(v2) )
#define RENDER_QUAD( v0, v1, v2, v3 ) QUAD( V(v0), V(v1), V(v2), V(v3) )
#define INIT(x) intelRenderPrimitive( ctx, x )
#undef LOCAL_VARS
#define LOCAL_VARS						\
    struct intel_context *intel = intel_context(ctx);			\
    GLubyte *vertptr = (GLubyte *)intel->verts;			\
    const GLuint vertsize = intel->vertex_size;       	\
    const GLuint * const elt = TNL_CONTEXT(ctx)->vb.Elts;	\
    (void) elt;
#define RESET_STIPPLE
#define RESET_OCCLUSION
#define PRESERVE_VB_DEFS
#define ELT(x) x
#define TAG(x) intel_##x##_verts
#include "tnl/t_vb_rendertmp.h"
#undef ELT
#undef TAG
#define TAG(x) intel_##x##_elts
#define ELT(x) elt[x]
#include "tnl/t_vb_rendertmp.h"

/**********************************************************************/
/*                   Render clipped primitives                        */
/**********************************************************************/



static void
intelRenderClippedPoly(struct gl_context * ctx, const GLuint * elts, GLuint n)
{
   struct intel_context *intel = intel_context(ctx);
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct vertex_buffer *VB = &TNL_CONTEXT(ctx)->vb;
   GLuint prim = intel->render_primitive;

   /* Render the new vertices as an unclipped polygon.
    */
   {
      GLuint *tmp = VB->Elts;
      VB->Elts = (GLuint *) elts;
      tnl->Driver.Render.PrimTabElts[GL_POLYGON] (ctx, 0, n,
                                                  PRIM_BEGIN | PRIM_END);
      VB->Elts = tmp;
   }

   /* Restore the render primitive
    */
   if (prim != GL_POLYGON)
      tnl->Driver.Render.PrimitiveNotify(ctx, prim);
}

static void
intelRenderClippedLine(struct gl_context * ctx, GLuint ii, GLuint jj)
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);

   tnl->Driver.Render.Line(ctx, ii, jj);
}

static void
intelFastRenderClippedPoly(struct gl_context * ctx, const GLuint * elts, GLuint n)
{
   struct intel_context *intel = intel_context(ctx);
   const GLuint vertsize = intel->vertex_size;
   GLuint *vb = intel_get_prim_space(intel, (n - 2) * 3);
   GLubyte *vertptr = (GLubyte *) intel->verts;
   const GLuint *start = (const GLuint *) V(elts[0]);
   int i, j;

   for (i = 2; i < n; i++) {
      COPY_DWORDS(j, vb, vertsize, V(elts[i - 1]));
      COPY_DWORDS(j, vb, vertsize, V(elts[i]));
      COPY_DWORDS(j, vb, vertsize, start);
   }
}

/**********************************************************************/
/*                    Choose render functions                         */
/**********************************************************************/


#define DD_TRI_LIGHT_TWOSIDE (1 << 1)
#define DD_TRI_UNFILLED (1 << 2)
#define DD_TRI_STIPPLE  (1 << 4)
#define DD_TRI_OFFSET   (1 << 5)
#define DD_LINE_STIPPLE (1 << 7)
#define DD_POINT_ATTEN  (1 << 9)

#define ANY_FALLBACK_FLAGS (DD_LINE_STIPPLE | DD_TRI_STIPPLE | DD_POINT_ATTEN)
#define ANY_RASTER_FLAGS (DD_TRI_LIGHT_TWOSIDE | DD_TRI_OFFSET | DD_TRI_UNFILLED)

void
intelChooseRenderState(struct gl_context * ctx)
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct intel_context *intel = intel_context(ctx);
   GLuint flags =
      ((ctx->Light.Enabled &&
        ctx->Light.Model.TwoSide) ? DD_TRI_LIGHT_TWOSIDE : 0) |
      ((ctx->Polygon.FrontMode != GL_FILL ||
        ctx->Polygon.BackMode != GL_FILL) ? DD_TRI_UNFILLED : 0) |
      (ctx->Polygon.StippleFlag ? DD_TRI_STIPPLE : 0) |
      ((ctx->Polygon.OffsetPoint ||
        ctx->Polygon.OffsetLine ||
        ctx->Polygon.OffsetFill) ? DD_TRI_OFFSET : 0) |
      (ctx->Line.StippleFlag ? DD_LINE_STIPPLE : 0) |
      (ctx->Point._Attenuated ? DD_POINT_ATTEN : 0);
   const struct gl_fragment_program *fprog = ctx->FragmentProgram._Current;
   bool have_wpos = (fprog && (fprog->Base.InputsRead & VARYING_BIT_POS));
   GLuint index = 0;

   if (INTEL_DEBUG & DEBUG_STATE)
      fprintf(stderr, "\n%s\n", __FUNCTION__);

   if ((flags & (ANY_FALLBACK_FLAGS | ANY_RASTER_FLAGS)) || have_wpos) {

      if (flags & ANY_RASTER_FLAGS) {
         if (flags & DD_TRI_LIGHT_TWOSIDE)
            index |= INTEL_TWOSIDE_BIT;
         if (flags & DD_TRI_OFFSET)
            index |= INTEL_OFFSET_BIT;
         if (flags & DD_TRI_UNFILLED)
            index |= INTEL_UNFILLED_BIT;
      }

      if (have_wpos) {
         intel->draw_point = intel_wpos_point;
         intel->draw_line = intel_wpos_line;
         intel->draw_tri = intel_wpos_triangle;

         /* Make sure these get called:
          */
         index |= INTEL_FALLBACK_BIT;
      }
      else {
         intel->draw_point = intel_draw_point;
         intel->draw_line = intel_draw_line;
         intel->draw_tri = intel_draw_triangle;
      }

      /* Hook in fallbacks for specific primitives.
       */
      if (flags & ANY_FALLBACK_FLAGS) {
         if (flags & DD_LINE_STIPPLE)
            intel->draw_line = intel_fallback_line;

         if ((flags & DD_TRI_STIPPLE) && !intel->hw_stipple)
            intel->draw_tri = intel_fallback_tri;

         if (flags & DD_POINT_ATTEN) {
	    if (0)
	       intel->draw_point = intel_atten_point;
	    else
	       intel->draw_point = intel_fallback_point;
	 }

         index |= INTEL_FALLBACK_BIT;
      }
   }

   if (intel->RenderIndex != index) {
      intel->RenderIndex = index;

      tnl->Driver.Render.Points = rast_tab[index].points;
      tnl->Driver.Render.Line = rast_tab[index].line;
      tnl->Driver.Render.Triangle = rast_tab[index].triangle;
      tnl->Driver.Render.Quad = rast_tab[index].quad;

      if (index == 0) {
         tnl->Driver.Render.PrimTabVerts = intel_render_tab_verts;
         tnl->Driver.Render.PrimTabElts = intel_render_tab_elts;
         tnl->Driver.Render.ClippedLine = line; /* from tritmp.h */
         tnl->Driver.Render.ClippedPolygon = intelFastRenderClippedPoly;
      }
      else {
         tnl->Driver.Render.PrimTabVerts = _tnl_render_tab_verts;
         tnl->Driver.Render.PrimTabElts = _tnl_render_tab_elts;
         tnl->Driver.Render.ClippedLine = intelRenderClippedLine;
         tnl->Driver.Render.ClippedPolygon = intelRenderClippedPoly;
      }
   }
}

static const GLenum reduced_prim[GL_POLYGON + 1] = {
   GL_POINTS,
   GL_LINES,
   GL_LINES,
   GL_LINES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES
};


/**********************************************************************/
/*                 High level hooks for t_vb_render.c                 */
/**********************************************************************/




static void
intelRunPipeline(struct gl_context * ctx)
{
   struct intel_context *intel = intel_context(ctx);

   _mesa_lock_context_textures(ctx);
   
   if (ctx->NewState)
      _mesa_update_state_locked(ctx);

   /* We need to get this done before we start the pipeline, or a
    * change in the INTEL_FALLBACK() of its intel_draw_buffers() call
    * while the pipeline is running will result in mismatched swrast
    * map/unmaps, and later assertion failures.
    */
   intel_prepare_render(intel);

   if (intel->NewGLState) {
      if (intel->NewGLState & _NEW_TEXTURE) {
         intel->vtbl.update_texture_state(intel);
      }

      if (!intel->Fallback) {
         if (intel->NewGLState & _INTEL_NEW_RENDERSTATE)
            intelChooseRenderState(ctx);
      }

      intel->NewGLState = 0;
   }

   intel->tnl_pipeline_running = true;
   _tnl_run_pipeline(ctx);
   intel->tnl_pipeline_running = false;

   _mesa_unlock_context_textures(ctx);
}

static void
intelRenderStart(struct gl_context * ctx)
{
   struct intel_context *intel = intel_context(ctx);

   intel_check_front_buffer_rendering(intel);
   intel->vtbl.render_start(intel_context(ctx));
   intel->vtbl.emit_state(intel);
}

static void
intelRenderFinish(struct gl_context * ctx)
{
   struct intel_context *intel = intel_context(ctx);

   if (intel->RenderIndex & INTEL_FALLBACK_BIT)
      _swrast_flush(ctx);

   INTEL_FIREVERTICES(intel);
}




 /* System to flush dma and emit state changes based on the rasterized
  * primitive.
  */
static void
intelRasterPrimitive(struct gl_context * ctx, GLenum rprim, GLuint hwprim)
{
   struct intel_context *intel = intel_context(ctx);

   if (0)
      fprintf(stderr, "%s %s %x\n", __FUNCTION__,
              _mesa_lookup_enum_by_nr(rprim), hwprim);

   intel->vtbl.reduced_primitive_state(intel, rprim);

   /* Start a new primitive.  Arrange to have it flushed later on.
    */
   if (hwprim != intel->prim.primitive) {
      INTEL_FIREVERTICES(intel);

      intel_set_prim(intel, hwprim);
   }
}


 /* 
  */
static void
intelRenderPrimitive(struct gl_context * ctx, GLenum prim)
{
   struct intel_context *intel = intel_context(ctx);
   GLboolean unfilled = (ctx->Polygon.FrontMode != GL_FILL ||
                         ctx->Polygon.BackMode != GL_FILL);

   if (0)
      fprintf(stderr, "%s %s\n", __FUNCTION__, _mesa_lookup_enum_by_nr(prim));

   /* Let some clipping routines know which primitive they're dealing
    * with.
    */
   intel->render_primitive = prim;

   /* Shortcircuit this when called for unfilled triangles.  The rasterized
    * primitive will always be reset by lower level functions in that case,
    * potentially pingponging the state:
    */
   if (reduced_prim[prim] == GL_TRIANGLES && unfilled)
      return;

   /* Set some primitive-dependent state and Start? a new primitive.
    */
   intelRasterPrimitive(ctx, reduced_prim[prim], hw_prim[prim]);
}


 /**********************************************************************/
 /*           Transition to/from hardware rasterization.               */
 /**********************************************************************/

static char *fallbackStrings[] = {
   [0] = "Draw buffer",
   [1] = "Read buffer",
   [2] = "Depth buffer",
   [3] = "Stencil buffer",
   [4] = "User disable",
   [5] = "Render mode",

   [12] = "Texture",
   [13] = "Color mask",
   [14] = "Stencil",
   [15] = "Stipple",
   [16] = "Program",
   [17] = "Logic op",
   [18] = "Smooth polygon",
   [19] = "Smooth point",
   [20] = "point sprite coord origin",
   [21] = "depth/color drawing offset",
   [22] = "coord replace(SPRITE POINT ENABLE)",
};


static char *
getFallbackString(GLuint bit)
{
   int i = 0;
   while (bit > 1) {
      i++;
      bit >>= 1;
   }
   return fallbackStrings[i];
}



/**
 * Enable/disable a fallback flag.
 * \param bit  one of INTEL_FALLBACK_x flags.
 */
void
intelFallback(struct intel_context *intel, GLbitfield bit, bool mode)
{
   struct gl_context *ctx = &intel->ctx;
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   const GLbitfield oldfallback = intel->Fallback;

   if (mode) {
      intel->Fallback |= bit;
      if (oldfallback == 0) {
	 assert(!intel->tnl_pipeline_running);

         intel_flush(ctx);
         if (INTEL_DEBUG & DEBUG_PERF)
            fprintf(stderr, "ENTER FALLBACK %x: %s\n",
                    bit, getFallbackString(bit));
         _swsetup_Wakeup(ctx);
         intel->RenderIndex = ~0;
      }
   }
   else {
      intel->Fallback &= ~bit;
      if (oldfallback == bit) {
	 assert(!intel->tnl_pipeline_running);

         _swrast_flush(ctx);
         if (INTEL_DEBUG & DEBUG_PERF)
            fprintf(stderr, "LEAVE FALLBACK %s\n", getFallbackString(bit));
         tnl->Driver.Render.Start = intelRenderStart;
         tnl->Driver.Render.PrimitiveNotify = intelRenderPrimitive;
         tnl->Driver.Render.Finish = intelRenderFinish;
         tnl->Driver.Render.BuildVertices = _tnl_build_vertices;
         tnl->Driver.Render.CopyPV = _tnl_copy_pv;
         tnl->Driver.Render.Interp = _tnl_interp;

         _tnl_invalidate_vertex_state(ctx, ~0);
         _tnl_invalidate_vertices(ctx, ~0);
         _tnl_install_attrs(ctx,
                            intel->vertex_attrs,
                            intel->vertex_attr_count,
                            intel->ViewportMatrix.m, 0);

         intel->NewGLState |= _INTEL_NEW_RENDERSTATE;
      }
   }
}

union fi
{
   GLfloat f;
   GLint i;
};

/**********************************************************************/
/*                            Initialization.                         */
/**********************************************************************/


void
intelInitTriFuncs(struct gl_context * ctx)
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   static int firsttime = 1;

   if (firsttime) {
      init_rast_tab();
      firsttime = 0;
   }

   tnl->Driver.RunPipeline = intelRunPipeline;
   tnl->Driver.Render.Start = intelRenderStart;
   tnl->Driver.Render.Finish = intelRenderFinish;
   tnl->Driver.Render.PrimitiveNotify = intelRenderPrimitive;
   tnl->Driver.Render.ResetLineStipple = _swrast_ResetLineStipple;
   tnl->Driver.Render.BuildVertices = _tnl_build_vertices;
   tnl->Driver.Render.CopyPV = _tnl_copy_pv;
   tnl->Driver.Render.Interp = _tnl_interp;
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d605 4
a608 4
#define DO_FALLBACK ((IND & INTEL_FALLBACK_BIT) != 0)
#define DO_OFFSET   ((IND & INTEL_OFFSET_BIT) != 0)
#define DO_UNFILLED ((IND & INTEL_UNFILLED_BIT) != 0)
#define DO_TWOSIDE  ((IND & INTEL_TWOSIDE_BIT) != 0)
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d605 4
a608 4
#define DO_FALLBACK (IND & INTEL_FALLBACK_BIT)
#define DO_OFFSET   (IND & INTEL_OFFSET_BIT)
#define DO_UNFILLED (IND & INTEL_UNFILLED_BIT)
#define DO_TWOSIDE  (IND & INTEL_TWOSIDE_BIT)
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d41 1
a54 1
#include "intel_span.h"
d95 1
a95 3
   intel->no_batch_wrap = GL_TRUE;

   /*printf("%s *", __progname);*/
d109 1
a109 1
   intel->no_batch_wrap = GL_FALSE;
d233 5
a237 1
   intel->no_batch_wrap = GL_TRUE;
d311 5
a315 1
   intel->no_batch_wrap = GL_FALSE;
d504 1
a504 1
   if (fb->Name)
d641 1
a641 1
#define DEPTH_SCALE intel->polygon_offset_scale
d664 1
a664 1
   GLboolean specoffset = intel->specoffset;				\
d808 1
a808 1
   intelSpanRenderStart(ctx);
d810 1
a810 1
   intelSpanRenderFinish(ctx);
d828 1
a828 1
   intelSpanRenderStart(ctx);
d830 1
a830 1
   intelSpanRenderFinish(ctx);
d846 1
a846 1
   intelSpanRenderStart(ctx);
d848 1
a848 1
   intelSpanRenderFinish(ctx);
d943 6
d950 1
a950 2

#define ANY_FALLBACK_FLAGS (DD_LINE_STIPPLE | DD_TRI_STIPPLE | DD_POINT_ATTEN | DD_POINT_SMOOTH | DD_TRI_SMOOTH)
d958 11
a968 1
   GLuint flags = ctx->_TriangleCaps;
d970 1
a970 1
   GLboolean have_wpos = (fprog && (fprog->Base.InputsRead & FRAG_BIT_WPOS));
a1010 5
         if (flags & DD_TRI_SMOOTH) {
	    if (intel->conformance_mode > 0)
	       intel->draw_tri = intel_fallback_tri;
	 }

a1017 5
	 if (flags & DD_POINT_SMOOTH) {
	    if (intel->conformance_mode > 0)
	       intel->draw_point = intel_fallback_point;
	 }

a1095 1
   intel_map_vertex_shader_textures(ctx);
a1098 1
   intel_unmap_vertex_shader_textures(ctx);
d1157 2
d1168 3
a1170 4
   /* Shortcircuit this when called from t_dd_rendertmp.h for unfilled
    * triangles.  The rasterized primitive will always be reset by
    * lower level functions in that case, potentially pingponging the
    * state:
d1172 1
a1172 2
   if (reduced_prim[prim] == GL_TRIANGLES &&
       (ctx->_TriangleCaps & DD_TRI_UNFILLED))
d1203 1
d1225 1
a1225 1
intelFallback(struct intel_context *intel, GLbitfield bit, GLboolean mode)
d1237 1
a1237 1
         if (INTEL_DEBUG & DEBUG_FALLBACKS)
d1250 1
a1250 1
         if (INTEL_DEBUG & DEBUG_FALLBACKS)
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d57 1
d66 1
a66 1
   GLuint used = intel->batch->ptr - intel->prim.start_ptr;
d72 1
a72 1
   if (used < 8)
d75 2
a76 2
   *(int *) intel->prim.start_ptr = (_3DPRIMITIVE |
                                     intel->prim.primitive | (used / 4 - 2));
d81 1
a81 1
   intel->batch->ptr -= used;
d104 1
a104 3
   assert((intel->batch->dirty_state & (1<<1)) == 0);

   intel->prim.start_ptr = intel->batch->ptr;
d120 1
a120 1
   intel_batchbuffer_flush(intel->batch);
a125 1
   GLuint sz = dwords * sizeof(GLuint);
d130 1
a130 1
   if (intel_batchbuffer_space(intel->batch) < sz)
d137 2
a138 2
   ptr = (GLuint *) intel->batch->ptr;
   intel->batch->ptr += sz;
d219 1
a219 1
      intel->prim.start_offset = ALIGN(intel->prim.start_offset, 128);
d224 1
a224 1
   aper_array[0] = intel->batch->buf;
d227 1
a227 1
      intel_batchbuffer_flush(intel->batch);
a236 5
   /* Check that we actually emitted the state into this batch, using the
    * UPLOAD_CTX bit as the signal.
    */
   assert((intel->batch->dirty_state & (1<<1)) == 0);

d244 14
a257 7
      BEGIN_BATCH(5);
      OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 |
		I1_LOAD_S(0) | I1_LOAD_S(1) | 1);
      assert((offset & ~S0_VB_OFFSET_MASK) == 0);
      OUT_RELOC(vb_bo, I915_GEM_DOMAIN_VERTEX, 0, offset);
      OUT_BATCH((intel->vertex_size << S1_VERTEX_WIDTH_SHIFT) |
		(intel->vertex_size << S1_VERTEX_PITCH_SHIFT));
d259 12
d276 1
a276 1
      OUT_BATCH(0); /* Beginning vertex index */
d487 8
d496 10
d511 3
a513 14
   GLuint offset = intel->wpos_offset;
   GLuint size = intel->wpos_size;
   GLfloat *v0_wpos = (GLfloat *)((char *)v0 + offset);
   GLfloat *v1_wpos = (GLfloat *)((char *)v1 + offset);
   GLfloat *v2_wpos = (GLfloat *)((char *)v2 + offset);

   __memcpy(v0_wpos, v0, size);
   __memcpy(v1_wpos, v1, size);
   __memcpy(v2_wpos, v2, size);

   v0_wpos[1] = -v0_wpos[1] + intel->ctx.DrawBuffer->Height;
   v1_wpos[1] = -v1_wpos[1] + intel->ctx.DrawBuffer->Height;
   v2_wpos[1] = -v2_wpos[1] + intel->ctx.DrawBuffer->Height;

d523 2
a524 11
   GLuint offset = intel->wpos_offset;
   GLuint size = intel->wpos_size;
   GLfloat *v0_wpos = (GLfloat *)((char *)v0 + offset);
   GLfloat *v1_wpos = (GLfloat *)((char *)v1 + offset);

   __memcpy(v0_wpos, v0, size);
   __memcpy(v1_wpos, v1, size);

   v0_wpos[1] = -v0_wpos[1] + intel->ctx.DrawBuffer->Height;
   v1_wpos[1] = -v1_wpos[1] + intel->ctx.DrawBuffer->Height;

d532 1
a532 7
   GLuint offset = intel->wpos_offset;
   GLuint size = intel->wpos_size;
   GLfloat *v0_wpos = (GLfloat *)((char *)v0 + offset);

   __memcpy(v0_wpos, v0, size);
   v0_wpos[1] = -v0_wpos[1] + intel->ctx.DrawBuffer->Height;

d1065 7
d1086 1
d1088 1
d1224 2
d1237 2
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d58 2
a59 2
static void intelRenderPrimitive(GLcontext * ctx, GLenum prim);
static void intelRasterPrimitive(GLcontext * ctx, GLenum rprim,
d182 2
a183 2
      intel->prim.vb_bo = dri_bo_alloc(intel->bufmgr, "vb",
				       INTEL_VB_SIZE, 4);
d200 2
a201 2
   dri_bo *aper_array[2];
   dri_bo *vb_bo;
d215 1
a215 1
   dri_bo_reference(vb_bo);
d299 1
a299 1
   dri_bo_unreference(vb_bo);
d318 3
a320 3
   dri_bo_subdata(intel->prim.vb_bo, 0, intel->prim.start_offset,
		  intel->prim.vb);
   dri_bo_unreference(intel->prim.vb_bo);
d430 1
a430 1
   GLcontext *ctx = &intel->ctx;
d491 3
a493 3
   v0_wpos[1] = -v0_wpos[1] + intel->driDrawable->h;
   v1_wpos[1] = -v1_wpos[1] + intel->driDrawable->h;
   v2_wpos[1] = -v2_wpos[1] + intel->driDrawable->h;
d512 2
a513 2
   v0_wpos[1] = -v0_wpos[1] + intel->driDrawable->h;
   v1_wpos[1] = -v1_wpos[1] + intel->driDrawable->h;
d527 1
a527 1
   v0_wpos[1] = -v0_wpos[1] + intel->driDrawable->h;
d787 1
a787 1
   GLcontext *ctx = &intel->ctx;
d808 1
a808 1
   GLcontext *ctx = &intel->ctx;
d827 1
a827 1
   GLcontext *ctx = &intel->ctx;
d880 1
a880 1
intelRenderClippedPoly(GLcontext * ctx, const GLuint * elts, GLuint n)
d904 1
a904 1
intelRenderClippedLine(GLcontext * ctx, GLuint ii, GLuint jj)
d912 1
a912 1
intelFastRenderClippedPoly(GLcontext * ctx, const GLuint * elts, GLuint n)
d939 1
a939 1
intelChooseRenderState(GLcontext * ctx)
d1052 1
a1052 1
intelRunPipeline(GLcontext * ctx)
d1082 1
a1082 1
intelRenderStart(GLcontext * ctx)
d1092 1
a1092 1
intelRenderFinish(GLcontext * ctx)
d1109 1
a1109 1
intelRasterPrimitive(GLcontext * ctx, GLenum rprim, GLuint hwprim)
d1132 1
a1132 1
intelRenderPrimitive(GLcontext * ctx, GLenum prim)
d1204 1
a1204 1
   GLcontext *ctx = &intel->ctx;
d1211 1
a1211 1
         intelFlush(ctx);
d1256 1
a1256 1
intelInitTriFuncs(GLcontext * ctx)
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a54 2
#include "intel_tex.h"
#include "intel_chipset.h"
d69 1
a69 1
/*    _mesa_printf("/\n"); */
a90 1
   uint32_t batch_flags = LOOP_CLIPRECTS;
d96 1
a96 1
   /*_mesa_printf("%s *", __progname);*/
d101 1
a101 2
   BEGIN_BATCH(2, batch_flags);
   OUT_BATCH(0);
d113 1
a113 1
/*    _mesa_printf(">"); */
d135 1
a135 1
/*    _mesa_printf("."); */
a199 1
   BATCH_LOCALS;
d203 1
d220 1
a220 1
   if (!IS_9XX(intel->intelScreen->deviceID))
d250 2
a251 2
   if (IS_9XX(intel->intelScreen->deviceID)) {
      BEGIN_BATCH(5, LOOP_CLIPRECTS);
d254 1
a254 1
      assert((offset & !S0_VB_OFFSET_MASK) == 0);
d269 1
a269 1
      BEGIN_BATCH(5, LOOP_CLIPRECTS);
d273 1
a273 1
      assert((offset & !S0_VB_OFFSET_MASK_830) == 0);
a605 1
#define HAVE_RGBA         1
d1074 1
d1076 1
d1086 1
d1179 2
d1197 4
d1202 1
a1202 1
intelFallback(struct intel_context *intel, GLuint bit, GLboolean mode)
d1206 1
a1206 1
   GLuint oldfallback = intel->Fallback;
a1249 78

/**********************************************************************/
/*             Used only with the metaops callbacks.                  */
/**********************************************************************/
static void
intel_meta_draw_poly(struct intel_context *intel,
                     GLuint n,
                     GLfloat xy[][2],
                     GLfloat z, GLuint color, GLfloat tex[][2])
{
   union fi *vb;
   GLint i;
   GLboolean was_locked = intel->locked;
   unsigned int saved_vertex_size = intel->vertex_size;

   if (!was_locked)
       LOCK_HARDWARE(intel);

   intel->vertex_size = 6;

   /* All 3d primitives should be emitted with LOOP_CLIPRECTS,
    * otherwise the drawing origin (DR4) might not be set correctly.
    */
   intel_set_prim(intel, PRIM3D_TRIFAN);
   vb = (union fi *) intel_get_prim_space(intel, n);

   for (i = 0; i < n; i++) {
      vb[0].f = xy[i][0];
      vb[1].f = xy[i][1];
      vb[2].f = z;
      vb[3].i = color;
      vb[4].f = tex[i][0];
      vb[5].f = tex[i][1];
      vb += 6;
   }

   INTEL_FIREVERTICES(intel);

   intel->vertex_size = saved_vertex_size;

   if (!was_locked)
       UNLOCK_HARDWARE(intel);
}

static void
intel_meta_draw_quad(struct intel_context *intel,
                     GLfloat x0, GLfloat x1,
                     GLfloat y0, GLfloat y1,
                     GLfloat z,
                     GLuint color,
                     GLfloat s0, GLfloat s1, GLfloat t0, GLfloat t1)
{
   GLfloat xy[4][2];
   GLfloat tex[4][2];

   xy[0][0] = x0;
   xy[0][1] = y0;
   xy[1][0] = x1;
   xy[1][1] = y0;
   xy[2][0] = x1;
   xy[2][1] = y1;
   xy[3][0] = x0;
   xy[3][1] = y1;

   tex[0][0] = s0;
   tex[0][1] = t0;
   tex[1][0] = s1;
   tex[1][1] = t0;
   tex[2][0] = s1;
   tex[2][1] = t1;
   tex[3][0] = s0;
   tex[3][1] = t1;

   intel_meta_draw_poly(intel, 4, xy, z, color, tex);
}



a1257 1
   struct intel_context *intel = intel_context(ctx);
a1273 2

   intel->vtbl.meta_draw_quad = intel_meta_draw_quad;
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d28 13
a40 7
#include "glheader.h"
#include "context.h"
#include "macros.h"
#include "enums.h"
#include "texobj.h"
#include "state.h"
#include "dd.h"
d56 3
a63 2
/*
 */
d90 1
a90 6

/* Emit a primitive referencing vertices in a vertex buffer.
 */
void
intelStartInlinePrimitive(struct intel_context *intel,
                          GLuint prim, GLuint batch_flags)
d93 1
a93 2

   intel_wait_flips(intel);
d99 1
a99 1
/*    _mesa_printf("%s *", __progname); */
a116 1

d120 1
a120 3

void
intelWrapInlinePrimitive(struct intel_context *intel)
a122 1
   enum cliprect_mode cliprect_mode = intel->batch->cliprect_mode;
d126 1
a126 1
   intelStartInlinePrimitive(intel, prim, cliprect_mode);  /* ??? */
d129 1
a129 2
GLuint *
intelExtendInlinePrimitive(struct intel_context *intel, GLuint dwords)
d137 1
a137 1
      intelWrapInlinePrimitive(intel);
d149 4
d154 173
d358 1
a358 1
   GLuint *vb = intelExtendInlinePrimitive(intel, 6 * vertsize);
d386 1
a386 1
   GLuint *vb = intelExtendInlinePrimitive(intel, 3 * vertsize);
d400 1
a400 1
   GLuint *vb = intelExtendInlinePrimitive(intel, 2 * vertsize);
d412 1
a412 1
   GLuint *vb = intelExtendInlinePrimitive(intel, vertsize);
d921 1
a921 1
   GLuint *vb = intelExtendInlinePrimitive(intel, (n - 2) * 3 * vertsize);
d992 1
a992 1
	    if (intel->strict_conformance)
d1004 1
a1004 1
	    if (intel->strict_conformance)
d1126 1
a1126 1
      intelStartInlinePrimitive(intel, hwprim, LOOP_CLIPRECTS);
d1259 1
d1264 2
d1269 2
a1270 2
   intelStartInlinePrimitive(intel, PRIM3D_TRIFAN, LOOP_CLIPRECTS);
   vb = (union fi *) intelExtendInlinePrimitive(intel, n * 6);
d1283 2
@


1.1
log
@Initial revision
@
text
@d32 2
d43 1
d46 1
d49 104
a153 2
static void intelRenderPrimitive( GLcontext *ctx, GLenum prim );
static void intelRasterPrimitive( GLcontext *ctx, GLenum rprim, GLuint hwprim );
a171 1
   if (0) fprintf(stderr, "\n");	\
a172 3
      if (0) fprintf(stderr, "   -- v(%d): %x/%f\n",j,	\
	      ((GLuint *)v)[j],			\
	      ((GLfloat *)v)[j]);		\
d179 4
a182 5
static void __inline__ intel_draw_quad( intelContextPtr intel,
					intelVertexPtr v0,
					intelVertexPtr v1,
					intelVertexPtr v2,
					intelVertexPtr v3 )
d185 1
a185 1
   GLuint *vb = intelExtendInlinePrimitive( intel, 6 * vertsize );
d188 18
a205 6
   COPY_DWORDS( j, vb, vertsize, v0 );
   COPY_DWORDS( j, vb, vertsize, v1 );
   COPY_DWORDS( j, vb, vertsize, v3 );
   COPY_DWORDS( j, vb, vertsize, v1 );
   COPY_DWORDS( j, vb, vertsize, v2 );
   COPY_DWORDS( j, vb, vertsize, v3 );
d208 3
a210 4
static void __inline__ intel_draw_triangle( intelContextPtr intel,
					    intelVertexPtr v0,
					    intelVertexPtr v1,
					    intelVertexPtr v2 )
d213 1
a213 1
   GLuint *vb = intelExtendInlinePrimitive( intel, 3 * vertsize );
d215 4
a218 4
   
   COPY_DWORDS( j, vb, vertsize, v0 );
   COPY_DWORDS( j, vb, vertsize, v1 );
   COPY_DWORDS( j, vb, vertsize, v2 );
d222 3
a224 3
static __inline__ void intel_draw_line( intelContextPtr intel,
					intelVertexPtr v0,
					intelVertexPtr v1 )
d227 1
a227 1
   GLuint *vb = intelExtendInlinePrimitive( intel, 2 * vertsize );
d230 2
a231 2
   COPY_DWORDS( j, vb, vertsize, v0 );
   COPY_DWORDS( j, vb, vertsize, v1 );
d235 2
a236 2
static __inline__ void intel_draw_point( intelContextPtr intel,
					 intelVertexPtr v0 )
d239 1
a239 1
   GLuint *vb = intelExtendInlinePrimitive( intel, vertsize );
d243 4
a246 4
   *(float *)&vb[0] = v0->v.x - 0.125;
   *(float *)&vb[1] = v0->v.y - 0.125;
   for (j = 2 ; j < vertsize ; j++)
     vb[j] = v0->ui[j];
d255 5
a259 1
static void intel_atten_point( intelContextPtr intel, intelVertexPtr v0 )
d264 2
a265 2
   _tnl_get_attr( ctx, v0, _TNL_ATTRIB_POINTSIZE, psz );
   _tnl_get_attr( ctx, v0, _TNL_ATTRIB_COLOR0, col );
d283 4
a286 4
      _tnl_set_attr( ctx, v0, _TNL_ATTRIB_POINTSIZE, psz);
      _tnl_set_attr( ctx, v0, _TNL_ATTRIB_COLOR0, col);
   
      intel_draw_point( intel, v0 );
d291 2
a292 2
      _tnl_set_attr( ctx, v0, _TNL_ATTRIB_POINTSIZE, psz);
      _tnl_set_attr( ctx, v0, _TNL_ATTRIB_COLOR0, col);
d295 1
a295 1
      intel_draw_point( intel, v0 );
d308 3
a310 4
static void intel_wpos_triangle( intelContextPtr intel,
				 intelVertexPtr v0,
				 intelVertexPtr v1,
				 intelVertexPtr v2 )
d314 12
a325 4
   
   __memcpy( ((char *)v0) + offset, v0, size );
   __memcpy( ((char *)v1) + offset, v1, size );
   __memcpy( ((char *)v2) + offset, v2, size );
d327 1
a327 1
   intel_draw_triangle( intel, v0, v1, v2 );
d331 3
a333 3
static void intel_wpos_line( intelContextPtr intel,
			     intelVertexPtr v0,
			     intelVertexPtr v1 )
d337 2
d340 2
a341 2
   __memcpy( ((char *)v0) + offset, v0, size );
   __memcpy( ((char *)v1) + offset, v1, size );
d343 4
a346 1
   intel_draw_line( intel, v0, v1 );
d350 2
a351 2
static void intel_wpos_point( intelContextPtr intel,
			      intelVertexPtr v0 )
d355 1
d357 2
a358 1
   __memcpy( ((char *)v0) + offset, v0, size );
d360 1
a360 1
   intel_draw_point( intel, v0 );
d417 6
a422 5
static struct {
   tnl_points_func	        points;
   tnl_line_func		line;
   tnl_triangle_func	triangle;
   tnl_quad_func		quad;
d483 4
a486 4
   intelContextPtr intel = INTEL_CONTEXT(ctx);				\
   GLuint color[n], spec[n];						\
   GLuint coloroffset = intel->coloroffset;		\
   GLboolean specoffset = intel->specoffset;			\
d494 1
a494 1
static const GLuint hw_prim[GL_POLYGON+1] = {
d584 2
a585 1
static void init_rast_tab( void )
d616 2
a617 4
intel_fallback_tri( intelContextPtr intel,
		   intelVertex *v0,
		   intelVertex *v1,
		   intelVertex *v2 )
d625 8
a632 6
   _swsetup_Translate( ctx, v0, &v[0] );
   _swsetup_Translate( ctx, v1, &v[1] );
   _swsetup_Translate( ctx, v2, &v[2] );
   intelSpanRenderStart( ctx );
   _swrast_Triangle( ctx, &v[0], &v[1], &v[2] );
   intelSpanRenderFinish( ctx );
d637 2
a638 3
intel_fallback_line( intelContextPtr intel,
		    intelVertex *v0,
		    intelVertex *v1 )
d646 7
a652 5
   _swsetup_Translate( ctx, v0, &v[0] );
   _swsetup_Translate( ctx, v1, &v[1] );
   intelSpanRenderStart( ctx );
   _swrast_Line( ctx, &v[0], &v[1] );
   intelSpanRenderFinish( ctx );
a654 1

d656 2
a657 2
intel_fallback_point( intelContextPtr intel,
		     intelVertex *v0 )
d665 6
a670 4
   _swsetup_Translate( ctx, v0, &v[0] );
   intelSpanRenderStart( ctx );
   _swrast_Point( ctx, &v[0] );
   intelSpanRenderFinish( ctx );
a673 1

d688 1
a688 1
    intelContextPtr intel = INTEL_CONTEXT(ctx);			\
d711 2
a712 2
static void intelRenderClippedPoly( GLcontext *ctx, const GLuint *elts,
				   GLuint n )
d714 1
a714 1
   intelContextPtr intel = INTEL_CONTEXT(ctx);
d723 3
a725 3
      VB->Elts = (GLuint *)elts;
      tnl->Driver.Render.PrimTabElts[GL_POLYGON]( ctx, 0, n, 
						  PRIM_BEGIN|PRIM_END );
d732 1
a732 1
      tnl->Driver.Render.PrimitiveNotify( ctx, prim );
d735 2
a736 1
static void intelRenderClippedLine( GLcontext *ctx, GLuint ii, GLuint jj )
d740 1
a740 1
   tnl->Driver.Render.Line( ctx, ii, jj );
d743 2
a744 2
static void intelFastRenderClippedPoly( GLcontext *ctx, const GLuint *elts,
				       GLuint n )
d746 1
a746 1
   intelContextPtr intel = INTEL_CONTEXT( ctx );
d748 9
a756 9
   GLuint *vb = intelExtendInlinePrimitive( intel, (n-2) * 3 * vertsize );
   GLubyte *vertptr = (GLubyte *)intel->verts;
   const GLuint *start = (const GLuint *)V(elts[0]);
   int i,j;

   for (i = 2 ; i < n ; i++) {
      COPY_DWORDS( j, vb, vertsize, V(elts[i-1]) );
      COPY_DWORDS( j, vb, vertsize, V(elts[i]) );
      COPY_DWORDS( j, vb, vertsize, start );
d767 2
a768 6
#define POINT_FALLBACK (0)
#define LINE_FALLBACK (DD_LINE_STIPPLE)
#define TRI_FALLBACK (0)
#define ANY_FALLBACK_FLAGS (POINT_FALLBACK|LINE_FALLBACK|TRI_FALLBACK|\
                            DD_TRI_STIPPLE|DD_POINT_ATTEN)
#define ANY_RASTER_FLAGS (DD_TRI_LIGHT_TWOSIDE|DD_TRI_OFFSET|DD_TRI_UNFILLED)
d770 2
a771 1
void intelChooseRenderState(GLcontext *ctx)
d774 1
a774 1
   intelContextPtr intel = INTEL_CONTEXT(ctx);
d781 1
a781 1
     fprintf(stderr,"\n%s\n",__FUNCTION__);
d783 1
a783 1
   if ((flags & (ANY_FALLBACK_FLAGS|ANY_RASTER_FLAGS)) || have_wpos) {
d786 6
a791 3
	 if (flags & DD_TRI_LIGHT_TWOSIDE)    index |= INTEL_TWOSIDE_BIT;
	 if (flags & DD_TRI_OFFSET)	      index |= INTEL_OFFSET_BIT;
	 if (flags & DD_TRI_UNFILLED)	      index |= INTEL_UNFILLED_BIT;
d795 7
a801 7
	 intel->draw_point = intel_wpos_point;
	 intel->draw_line = intel_wpos_line;
	 intel->draw_tri = intel_wpos_triangle;

	 /* Make sure these get called:
	  */
	 index |= INTEL_FALLBACK_BIT;
d804 3
a806 3
	 intel->draw_point = intel_draw_point;
	 intel->draw_line = intel_draw_line;
	 intel->draw_tri = intel_draw_triangle;
d811 23
a833 7
      if (flags & ANY_FALLBACK_FLAGS)
      {
	 if (flags & POINT_FALLBACK)
	    intel->draw_point = intel_fallback_point;

	 if (flags & LINE_FALLBACK)
	    intel->draw_line = intel_fallback_line;
d835 1
a835 10
	 if (flags & TRI_FALLBACK)
	    intel->draw_tri = intel_fallback_tri;

	 if ((flags & DD_TRI_STIPPLE) && !intel->hw_stipple) 
	    intel->draw_tri = intel_fallback_tri;

	 if (flags & DD_POINT_ATTEN)
	    intel->draw_point = intel_atten_point;

	 index |= INTEL_FALLBACK_BIT;
d848 10
a857 9
	 tnl->Driver.Render.PrimTabVerts = intel_render_tab_verts;
	 tnl->Driver.Render.PrimTabElts = intel_render_tab_elts;
	 tnl->Driver.Render.ClippedLine = line; /* from tritmp.h */
	 tnl->Driver.Render.ClippedPolygon = intelFastRenderClippedPoly;
      } else {
	 tnl->Driver.Render.PrimTabVerts = _tnl_render_tab_verts;
	 tnl->Driver.Render.PrimTabElts = _tnl_render_tab_elts;
	 tnl->Driver.Render.ClippedLine = intelRenderClippedLine;
	 tnl->Driver.Render.ClippedPolygon = intelRenderClippedPoly;
d862 1
a862 1
static const GLenum reduced_prim[GL_POLYGON+1] = {
d883 2
a884 1
static void intelRunPipeline( GLcontext *ctx )
d886 6
a891 1
   intelContextPtr intel = INTEL_CONTEXT(ctx);
d895 1
a895 1
	 intel->vtbl.update_texture_state( intel ); 
d899 2
a900 2
	 if (intel->NewGLState & _INTEL_NEW_RENDERSTATE)
	    intelChooseRenderState( ctx );
d906 3
a908 1
   _tnl_run_pipeline( ctx );
d911 2
a912 1
static void intelRenderStart( GLcontext *ctx )
d914 4
a917 1
   INTEL_CONTEXT(ctx)->vtbl.render_start( INTEL_CONTEXT(ctx) );
d920 2
a921 1
static void intelRenderFinish( GLcontext *ctx )
d923 6
a928 2
   if (INTEL_CONTEXT(ctx)->RenderIndex & INTEL_FALLBACK_BIT)
      _swrast_flush( ctx );
d937 2
a938 1
static void intelRasterPrimitive( GLcontext *ctx, GLenum rprim, GLuint hwprim )
d940 1
a940 1
   intelContextPtr intel = INTEL_CONTEXT(ctx);
d943 4
a946 2
      fprintf(stderr, "%s %s %x\n", __FUNCTION__, 
	      _mesa_lookup_enum_by_nr(rprim), hwprim);
a947 2
   intel->vtbl.reduced_primitive_state( intel, rprim );
    
d950 5
a954 2
   if (hwprim != intel->prim.primitive) 
      intelStartInlinePrimitive( intel, hwprim );
d960 26
a985 25
 static void intelRenderPrimitive( GLcontext *ctx, GLenum prim )
 {
    intelContextPtr intel = INTEL_CONTEXT(ctx);

    if (0)
       fprintf(stderr, "%s %s\n", __FUNCTION__, _mesa_lookup_enum_by_nr(prim));

    /* Let some clipping routines know which primitive they're dealing
     * with.
     */
    intel->render_primitive = prim;

    /* Shortcircuit this when called from t_dd_rendertmp.h for unfilled
     * triangles.  The rasterized primitive will always be reset by
     * lower level functions in that case, potentially pingponging the
     * state:
     */
    if (reduced_prim[prim] == GL_TRIANGLES && 
	(ctx->_TriangleCaps & DD_TRI_UNFILLED))
       return;

    /* Set some primitive-dependent state and Start? a new primitive.
     */
    intelRasterPrimitive( ctx, reduced_prim[prim], hw_prim[prim] );
 }
d992 29
a1020 65
 static char *fallbackStrings[] = {
    "Texture",
    "Draw buffer",
    "Read buffer",
    "Color mask",
    "Render mode",
    "Stencil",
    "Stipple",
    "User disable"
 };


 static char *getFallbackString(GLuint bit)
 {
    int i = 0;
    while (bit > 1) {
       i++;
       bit >>= 1;
    }
    return fallbackStrings[i];
 }



 void intelFallback( intelContextPtr intel, GLuint bit, GLboolean mode )
 {
    GLcontext *ctx = &intel->ctx;
    TNLcontext *tnl = TNL_CONTEXT(ctx);
    GLuint oldfallback = intel->Fallback;

    if (mode) {
       intel->Fallback |= bit;
       if (oldfallback == 0) {
	  intelFlush(ctx);
	  if (INTEL_DEBUG & DEBUG_FALLBACKS) 
	     fprintf(stderr, "ENTER FALLBACK %x: %s\n",
		     bit, getFallbackString( bit ));
	  _swsetup_Wakeup( ctx );
	  intel->RenderIndex = ~0;
       }
    }
    else {
       intel->Fallback &= ~bit;
       if (oldfallback == bit) {
	  _swrast_flush( ctx );
	  if (INTEL_DEBUG & DEBUG_FALLBACKS) 
	     fprintf(stderr, "LEAVE FALLBACK %s\n", getFallbackString( bit ));
	  tnl->Driver.Render.Start = intelRenderStart;
	  tnl->Driver.Render.PrimitiveNotify = intelRenderPrimitive;
	  tnl->Driver.Render.Finish = intelRenderFinish;
	  tnl->Driver.Render.BuildVertices = _tnl_build_vertices;
	  tnl->Driver.Render.CopyPV = _tnl_copy_pv;
	  tnl->Driver.Render.Interp = _tnl_interp;

	  _tnl_invalidate_vertex_state( ctx, ~0 );
	  _tnl_invalidate_vertices( ctx, ~0 );
	  _tnl_install_attrs( ctx, 
			      intel->vertex_attrs, 
			      intel->vertex_attr_count,
			      intel->ViewportMatrix.m, 0 ); 

	  intel->NewGLState |= _INTEL_NEW_RENDERSTATE;
       }
    }
 }
d1024 121
d1151 2
a1152 1
void intelInitTriFuncs( GLcontext *ctx )
d1154 1
d1171 2
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a45 6
/* XXX we shouldn't include these headers in this file, but we need them
 * for fallbackStrings, below.
 */
#include "i830_context.h"
#include "i915_context.h"

d795 98
a892 117
/* 
 */
static void intelRenderPrimitive( GLcontext *ctx, GLenum prim )
{
   intelContextPtr intel = INTEL_CONTEXT(ctx);

   if (0)
      fprintf(stderr, "%s %s\n", __FUNCTION__, _mesa_lookup_enum_by_nr(prim));

   /* Let some clipping routines know which primitive they're dealing
    * with.
    */
   intel->render_primitive = prim;

   /* Shortcircuit this when called from t_dd_rendertmp.h for unfilled
    * triangles.  The rasterized primitive will always be reset by
    * lower level functions in that case, potentially pingponging the
    * state:
    */
   if (reduced_prim[prim] == GL_TRIANGLES && 
       (ctx->_TriangleCaps & DD_TRI_UNFILLED))
      return;

   /* Set some primitive-dependent state and Start? a new primitive.
    */
   intelRasterPrimitive( ctx, reduced_prim[prim], hw_prim[prim] );
}


/**********************************************************************/
/*           Transition to/from hardware rasterization.               */
/**********************************************************************/

static struct {
   GLuint bit;
   const char *str;
} fallbackStrings[] = {
   { INTEL_FALLBACK_DRAW_BUFFER, "Draw buffer" },
   { INTEL_FALLBACK_READ_BUFFER, "Read buffer" },
   { INTEL_FALLBACK_USER, "User" },
   { INTEL_FALLBACK_NO_BATCHBUFFER, "No Batchbuffer" },
   { INTEL_FALLBACK_NO_TEXMEM, "No Texmem" },
   { INTEL_FALLBACK_RENDERMODE, "Rendermode" },

   { I830_FALLBACK_TEXTURE, "i830 texture" },
   { I830_FALLBACK_COLORMASK, "i830 colormask" },
   { I830_FALLBACK_STENCIL, "i830 stencil" },
   { I830_FALLBACK_STIPPLE, "i830 stipple" },
   { I830_FALLBACK_LOGICOP, "i830 logicop" },

   { I915_FALLBACK_TEXTURE, "i915 texture" },
   { I915_FALLBACK_COLORMASK, "i915 colormask" },
   { I915_FALLBACK_STENCIL, "i915 stencil" },
   { I915_FALLBACK_STIPPLE, "i915 stipple" },
   { I915_FALLBACK_PROGRAM, "i915 program" },
   { I915_FALLBACK_LOGICOP, "i915 logicop" },
   { I915_FALLBACK_POLYGON_SMOOTH, "i915 polygon smooth" },
   { I915_FALLBACK_POINT_SMOOTH, "i915 point smooth" },

   { 0, NULL }
};


static const char *
getFallbackString(GLuint bit)
{
   int i;
   for (i = 0; fallbackStrings[i].bit; i++) {
      if (fallbackStrings[i].bit == bit)
         return fallbackStrings[i].str;
   }
   return "unknown fallback bit";
}


void intelFallback( intelContextPtr intel, GLuint bit, GLboolean mode )
{
   GLcontext *ctx = &intel->ctx;
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   GLuint oldfallback = intel->Fallback;

   if (mode) {
      intel->Fallback |= bit;
      if (oldfallback == 0) {
         intelFlush(ctx);
         if (INTEL_DEBUG & DEBUG_FALLBACKS) 
            fprintf(stderr, "ENTER FALLBACK 0x%x: %s\n",
                    bit, getFallbackString(bit));
         _swsetup_Wakeup( ctx );
         intel->RenderIndex = ~0;
      }
   }
   else {
      intel->Fallback &= ~bit;
      if (oldfallback == bit) {
         _swrast_flush( ctx );
         if (INTEL_DEBUG & DEBUG_FALLBACKS) 
            fprintf(stderr, "LEAVE FALLBACK 0x%x: %s\n",
                    bit, getFallbackString(bit));
         tnl->Driver.Render.Start = intelRenderStart;
         tnl->Driver.Render.PrimitiveNotify = intelRenderPrimitive;
         tnl->Driver.Render.Finish = intelRenderFinish;
         tnl->Driver.Render.BuildVertices = _tnl_build_vertices;
         tnl->Driver.Render.CopyPV = _tnl_copy_pv;
         tnl->Driver.Render.Interp = _tnl_interp;

         _tnl_invalidate_vertex_state( ctx, ~0 );
         _tnl_invalidate_vertices( ctx, ~0 );
         _tnl_install_attrs( ctx, 
                             intel->vertex_attrs, 
                             intel->vertex_attr_count,
                             intel->ViewportMatrix.m, 0 ); 

         intel->NewGLState |= _INTEL_NEW_RENDERSTATE;
      }
   }
}
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d28 5
a32 13
/** @@file intel_tris.c
 *
 * This file contains functions for managing the vertex buffer and emitting
 * primitives into it.
 */

#include "main/glheader.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/enums.h"
#include "main/texobj.h"
#include "main/state.h"
#include "main/dd.h"
a40 1
#include "intel_context.h"
a42 1
#include "intel_buffers.h"
a44 243
#include "i830_context.h"
#include "i830_reg.h"

static void intelRenderPrimitive(struct gl_context * ctx, GLenum prim);
static void intelRasterPrimitive(struct gl_context * ctx, GLenum rprim,
                                 GLuint hwprim);

static void
intel_flush_inline_primitive(struct intel_context *intel)
{
   GLuint used = intel->batch->ptr - intel->prim.start_ptr;

   assert(intel->prim.primitive != ~0);

/*    printf("/\n"); */

   if (used < 8)
      goto do_discard;

   *(int *) intel->prim.start_ptr = (_3DPRIMITIVE |
                                     intel->prim.primitive | (used / 4 - 2));

   goto finished;

 do_discard:
   intel->batch->ptr -= used;

 finished:
   intel->prim.primitive = ~0;
   intel->prim.start_ptr = 0;
   intel->prim.flush = 0;
}

static void intel_start_inline(struct intel_context *intel, uint32_t prim)
{
   BATCH_LOCALS;

   intel->vtbl.emit_state(intel);

   intel->no_batch_wrap = GL_TRUE;

   /*printf("%s *", __progname);*/

   /* Emit a slot which will be filled with the inline primitive
    * command later.
    */
   BEGIN_BATCH(1);

   assert((intel->batch->dirty_state & (1<<1)) == 0);

   intel->prim.start_ptr = intel->batch->ptr;
   intel->prim.primitive = prim;
   intel->prim.flush = intel_flush_inline_primitive;

   OUT_BATCH(0);
   ADVANCE_BATCH();

   intel->no_batch_wrap = GL_FALSE;
/*    printf(">"); */
}

static void intel_wrap_inline(struct intel_context *intel)
{
   GLuint prim = intel->prim.primitive;

   intel_flush_inline_primitive(intel);
   intel_batchbuffer_flush(intel->batch);
   intel_start_inline(intel, prim);  /* ??? */
}

static GLuint *intel_extend_inline(struct intel_context *intel, GLuint dwords)
{
   GLuint sz = dwords * sizeof(GLuint);
   GLuint *ptr;

   assert(intel->prim.flush == intel_flush_inline_primitive);

   if (intel_batchbuffer_space(intel->batch) < sz)
      intel_wrap_inline(intel);

/*    printf("."); */

   intel->vtbl.assert_not_dirty(intel);

   ptr = (GLuint *) intel->batch->ptr;
   intel->batch->ptr += sz;

   return ptr;
}

/** Sets the primitive type for a primitive sequence, flushing as needed. */
void intel_set_prim(struct intel_context *intel, uint32_t prim)
{
   /* if we have no VBOs */

   if (intel->intelScreen->no_vbo) {
      intel_start_inline(intel, prim);
      return;
   }
   if (prim != intel->prim.primitive) {
      INTEL_FIREVERTICES(intel);
      intel->prim.primitive = prim;
   }
}

/** Returns mapped VB space for the given number of vertices */
uint32_t *intel_get_prim_space(struct intel_context *intel, unsigned int count)
{
   uint32_t *addr;

   if (intel->intelScreen->no_vbo) {
      return intel_extend_inline(intel, count * intel->vertex_size);
   }

   /* Check for space in the existing VB */
   if (intel->prim.vb_bo == NULL ||
       (intel->prim.current_offset +
	count * intel->vertex_size * 4) > INTEL_VB_SIZE ||
       (intel->prim.count + count) >= (1 << 16)) {
      /* Flush existing prim if any */
      INTEL_FIREVERTICES(intel);

      intel_finish_vb(intel);

      /* Start a new VB */
      if (intel->prim.vb == NULL)
	 intel->prim.vb = malloc(INTEL_VB_SIZE);
      intel->prim.vb_bo = drm_intel_bo_alloc(intel->bufmgr, "vb",
					     INTEL_VB_SIZE, 4);
      intel->prim.start_offset = 0;
      intel->prim.current_offset = 0;
   }

   intel->prim.flush = intel_flush_prim;

   addr = (uint32_t *)(intel->prim.vb + intel->prim.current_offset);
   intel->prim.current_offset += intel->vertex_size * 4 * count;
   intel->prim.count += count;

   return addr;
}

/** Dispatches the accumulated primitive to the batchbuffer. */
void intel_flush_prim(struct intel_context *intel)
{
   drm_intel_bo *aper_array[2];
   drm_intel_bo *vb_bo;
   unsigned int offset, count;
   BATCH_LOCALS;

   /* Must be called after an intel_start_prim. */
   assert(intel->prim.primitive != ~0);

   if (intel->prim.count == 0)
      return;

   /* Clear the current prims out of the context state so that a batch flush
    * flush triggered by emit_state doesn't loop back to flush_prim again.
    */
   vb_bo = intel->prim.vb_bo;
   drm_intel_bo_reference(vb_bo);
   count = intel->prim.count;
   intel->prim.count = 0;
   offset = intel->prim.start_offset;
   intel->prim.start_offset = intel->prim.current_offset;
   if (intel->gen < 3)
      intel->prim.start_offset = ALIGN(intel->prim.start_offset, 128);
   intel->prim.flush = NULL;

   intel->vtbl.emit_state(intel);

   aper_array[0] = intel->batch->buf;
   aper_array[1] = vb_bo;
   if (dri_bufmgr_check_aperture_space(aper_array, 2)) {
      intel_batchbuffer_flush(intel->batch);
      intel->vtbl.emit_state(intel);
   }

   /* Ensure that we don't start a new batch for the following emit, which
    * depends on the state just emitted. emit_state should be making sure we
    * have the space for this.
    */
   intel->no_batch_wrap = GL_TRUE;

   /* Check that we actually emitted the state into this batch, using the
    * UPLOAD_CTX bit as the signal.
    */
   assert((intel->batch->dirty_state & (1<<1)) == 0);

#if 0
   printf("emitting %d..%d=%d vertices size %d\n", offset,
	  intel->prim.current_offset, count,
	  intel->vertex_size * 4);
#endif

   if (intel->gen >= 3) {
      BEGIN_BATCH(5);
      OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 |
		I1_LOAD_S(0) | I1_LOAD_S(1) | 1);
      assert((offset & ~S0_VB_OFFSET_MASK) == 0);
      OUT_RELOC(vb_bo, I915_GEM_DOMAIN_VERTEX, 0, offset);
      OUT_BATCH((intel->vertex_size << S1_VERTEX_WIDTH_SHIFT) |
		(intel->vertex_size << S1_VERTEX_PITCH_SHIFT));

      OUT_BATCH(_3DPRIMITIVE |
		PRIM_INDIRECT |
		PRIM_INDIRECT_SEQUENTIAL |
		intel->prim.primitive |
		count);
      OUT_BATCH(0); /* Beginning vertex index */
      ADVANCE_BATCH();
   } else {
      struct i830_context *i830 = i830_context(&intel->ctx);

      BEGIN_BATCH(5);
      OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 |
		I1_LOAD_S(0) | I1_LOAD_S(2) | 1);
      /* S0 */
      assert((offset & ~S0_VB_OFFSET_MASK_830) == 0);
      OUT_RELOC(vb_bo, I915_GEM_DOMAIN_VERTEX, 0,
		offset | (intel->vertex_size << S0_VB_PITCH_SHIFT_830) |
		S0_VB_ENABLE_830);
      /* S2
       * This is somewhat unfortunate -- VB width is tied up with
       * vertex format data that we've already uploaded through
       * _3DSTATE_VFT[01]_CMD.  We may want to replace emits of VFT state with
       * STATE_IMMEDIATE_1 like this to avoid duplication.
       */
      OUT_BATCH((i830->state.Ctx[I830_CTXREG_VF] & VFT0_TEX_COUNT_MASK) >>
		VFT0_TEX_COUNT_SHIFT << S2_TEX_COUNT_SHIFT_830 |
		(i830->state.Ctx[I830_CTXREG_VF2] << 16) |
		intel->vertex_size << S2_VERTEX_0_WIDTH_SHIFT_830);

      OUT_BATCH(_3DPRIMITIVE |
		PRIM_INDIRECT |
		PRIM_INDIRECT_SEQUENTIAL |
		intel->prim.primitive |
		count);
      OUT_BATCH(0); /* Beginning vertex index */
      ADVANCE_BATCH();
   }

   intel->no_batch_wrap = GL_FALSE;
d46 2
a47 13
   drm_intel_bo_unreference(vb_bo);
}

/**
 * Uploads the locally-accumulated VB into the buffer object.
 *
 * This avoids us thrashing the cachelines in and out as the buffer gets
 * filled, dispatched, then reused as the hardware completes rendering from it,
 * and also lets us clflush less if we dispatch with a partially-filled VB.
 *
 * This is called normally from get_space when we're finishing a BO, but also
 * at batch flush time so that we don't try accessing the contents of a
 * just-dispatched buffer.
d49 2
a50 4
void intel_finish_vb(struct intel_context *intel)
{
   if (intel->prim.vb_bo == NULL)
      return;
d52 2
a53 5
   drm_intel_bo_subdata(intel->prim.vb_bo, 0, intel->prim.start_offset,
			intel->prim.vb);
   drm_intel_bo_unreference(intel->prim.vb_bo);
   intel->prim.vb_bo = NULL;
}
d72 1
d74 3
d83 5
a87 4
static void
intel_draw_quad(struct intel_context *intel,
                intelVertexPtr v0,
                intelVertexPtr v1, intelVertexPtr v2, intelVertexPtr v3)
d90 1
a90 1
   GLuint *vb = intel_get_prim_space(intel, 6);
d93 6
a98 18
   COPY_DWORDS(j, vb, vertsize, v0);
   COPY_DWORDS(j, vb, vertsize, v1);

   /* If smooth shading, draw like a trifan which gives better
    * rasterization.  Otherwise draw as two triangles with provoking
    * vertex in third position as required for flat shading.
    */
   if (intel->ctx.Light.ShadeModel == GL_FLAT) {
      COPY_DWORDS(j, vb, vertsize, v3);
      COPY_DWORDS(j, vb, vertsize, v1);
   }
   else {
      COPY_DWORDS(j, vb, vertsize, v2);
      COPY_DWORDS(j, vb, vertsize, v0);
   }

   COPY_DWORDS(j, vb, vertsize, v2);
   COPY_DWORDS(j, vb, vertsize, v3);
d101 4
a104 3
static void
intel_draw_triangle(struct intel_context *intel,
                    intelVertexPtr v0, intelVertexPtr v1, intelVertexPtr v2)
d107 1
a107 1
   GLuint *vb = intel_get_prim_space(intel, 3);
d109 4
a112 4

   COPY_DWORDS(j, vb, vertsize, v0);
   COPY_DWORDS(j, vb, vertsize, v1);
   COPY_DWORDS(j, vb, vertsize, v2);
d116 3
a118 3
static void
intel_draw_line(struct intel_context *intel,
                intelVertexPtr v0, intelVertexPtr v1)
d121 1
a121 1
   GLuint *vb = intel_get_prim_space(intel, 2);
d124 2
a125 2
   COPY_DWORDS(j, vb, vertsize, v0);
   COPY_DWORDS(j, vb, vertsize, v1);
d129 2
a130 2
static void
intel_draw_point(struct intel_context *intel, intelVertexPtr v0)
d133 1
a133 1
   GLuint *vb = intel_get_prim_space(intel, 1);
d137 4
a140 4
   *(float *) &vb[0] = v0->v.x;
   *(float *) &vb[1] = v0->v.y;
   for (j = 2; j < vertsize; j++)
      vb[j] = v0->ui[j];
d149 1
a149 5
/* Currently not working - VERT_ATTRIB_POINTSIZE isn't correctly
 * represented in the fragment program InputsRead field.
 */
static void
intel_atten_point(struct intel_context *intel, intelVertexPtr v0)
d151 1
a151 1
   struct gl_context *ctx = &intel->ctx;
d154 2
a155 2
   _tnl_get_attr(ctx, v0, _TNL_ATTRIB_POINTSIZE, psz);
   _tnl_get_attr(ctx, v0, _TNL_ATTRIB_COLOR0, col);
d173 4
a176 4
      _tnl_set_attr(ctx, v0, _TNL_ATTRIB_POINTSIZE, psz);
      _tnl_set_attr(ctx, v0, _TNL_ATTRIB_COLOR0, col);

      intel_draw_point(intel, v0);
d181 2
a182 2
      _tnl_set_attr(ctx, v0, _TNL_ATTRIB_POINTSIZE, psz);
      _tnl_set_attr(ctx, v0, _TNL_ATTRIB_COLOR0, col);
d185 1
a185 1
      intel_draw_point(intel, v0);
d198 4
a201 3
static void
intel_wpos_triangle(struct intel_context *intel,
                    intelVertexPtr v0, intelVertexPtr v1, intelVertexPtr v2)
d205 4
a208 3
   GLfloat *v0_wpos = (GLfloat *)((char *)v0 + offset);
   GLfloat *v1_wpos = (GLfloat *)((char *)v1 + offset);
   GLfloat *v2_wpos = (GLfloat *)((char *)v2 + offset);
d210 1
a210 10
   __memcpy(v0_wpos, v0, size);
   __memcpy(v1_wpos, v1, size);
   __memcpy(v2_wpos, v2, size);

   v0_wpos[1] = -v0_wpos[1] + intel->ctx.DrawBuffer->Height;
   v1_wpos[1] = -v1_wpos[1] + intel->ctx.DrawBuffer->Height;
   v2_wpos[1] = -v2_wpos[1] + intel->ctx.DrawBuffer->Height;


   intel_draw_triangle(intel, v0, v1, v2);
d214 3
a216 3
static void
intel_wpos_line(struct intel_context *intel,
                intelVertexPtr v0, intelVertexPtr v1)
a219 2
   GLfloat *v0_wpos = (GLfloat *)((char *)v0 + offset);
   GLfloat *v1_wpos = (GLfloat *)((char *)v1 + offset);
d221 2
a222 2
   __memcpy(v0_wpos, v0, size);
   __memcpy(v1_wpos, v1, size);
d224 1
a224 4
   v0_wpos[1] = -v0_wpos[1] + intel->ctx.DrawBuffer->Height;
   v1_wpos[1] = -v1_wpos[1] + intel->ctx.DrawBuffer->Height;

   intel_draw_line(intel, v0, v1);
d228 2
a229 2
static void
intel_wpos_point(struct intel_context *intel, intelVertexPtr v0)
a232 1
   GLfloat *v0_wpos = (GLfloat *)((char *)v0 + offset);
d234 1
a234 2
   __memcpy(v0_wpos, v0, size);
   v0_wpos[1] = -v0_wpos[1] + intel->ctx.DrawBuffer->Height;
d236 1
a236 1
   intel_draw_point(intel, v0);
d293 5
a297 6
static struct
{
   tnl_points_func points;
   tnl_line_func line;
   tnl_triangle_func triangle;
   tnl_quad_func quad;
d312 1
d358 4
a361 4
   struct intel_context *intel = intel_context(ctx);			\
   GLuint color[n] = { 0, }, spec[n] = { 0, };				\
   GLuint coloroffset = intel->coloroffset;				\
   GLboolean specoffset = intel->specoffset;				\
d369 1
a369 1
static const GLuint hw_prim[GL_POLYGON + 1] = {
d459 1
a459 2
static void
init_rast_tab(void)
d490 4
a493 2
intel_fallback_tri(struct intel_context *intel,
                   intelVertex * v0, intelVertex * v1, intelVertex * v2)
d495 1
a495 1
   struct gl_context *ctx = &intel->ctx;
d501 6
a506 8
   INTEL_FIREVERTICES(intel);

   _swsetup_Translate(ctx, v0, &v[0]);
   _swsetup_Translate(ctx, v1, &v[1]);
   _swsetup_Translate(ctx, v2, &v[2]);
   intelSpanRenderStart(ctx);
   _swrast_Triangle(ctx, &v[0], &v[1], &v[2]);
   intelSpanRenderFinish(ctx);
d511 3
a513 2
intel_fallback_line(struct intel_context *intel,
                    intelVertex * v0, intelVertex * v1)
d515 1
a515 1
   struct gl_context *ctx = &intel->ctx;
d521 6
a526 1
   INTEL_FIREVERTICES(intel);
a527 6
   _swsetup_Translate(ctx, v0, &v[0]);
   _swsetup_Translate(ctx, v1, &v[1]);
   intelSpanRenderStart(ctx);
   _swrast_Line(ctx, &v[0], &v[1]);
   intelSpanRenderFinish(ctx);
}
d530 2
a531 2
intel_fallback_point(struct intel_context *intel,
		     intelVertex * v0)
d533 1
a533 1
   struct gl_context *ctx = &intel->ctx;
d539 5
a543 1
   INTEL_FIREVERTICES(intel);
a544 5
   _swsetup_Translate(ctx, v0, &v[0]);
   intelSpanRenderStart(ctx);
   _swrast_Point(ctx, &v[0]);
   intelSpanRenderFinish(ctx);
}
d561 1
a561 1
    struct intel_context *intel = intel_context(ctx);			\
d584 2
a585 2
static void
intelRenderClippedPoly(struct gl_context * ctx, const GLuint * elts, GLuint n)
d587 1
a587 1
   struct intel_context *intel = intel_context(ctx);
d596 3
a598 3
      VB->Elts = (GLuint *) elts;
      tnl->Driver.Render.PrimTabElts[GL_POLYGON] (ctx, 0, n,
                                                  PRIM_BEGIN | PRIM_END);
d605 1
a605 1
      tnl->Driver.Render.PrimitiveNotify(ctx, prim);
d608 1
a608 2
static void
intelRenderClippedLine(struct gl_context * ctx, GLuint ii, GLuint jj)
d612 1
a612 1
   tnl->Driver.Render.Line(ctx, ii, jj);
d615 2
a616 2
static void
intelFastRenderClippedPoly(struct gl_context * ctx, const GLuint * elts, GLuint n)
d618 1
a618 1
   struct intel_context *intel = intel_context(ctx);
d620 9
a628 9
   GLuint *vb = intel_get_prim_space(intel, (n - 2) * 3);
   GLubyte *vertptr = (GLubyte *) intel->verts;
   const GLuint *start = (const GLuint *) V(elts[0]);
   int i, j;

   for (i = 2; i < n; i++) {
      COPY_DWORDS(j, vb, vertsize, V(elts[i - 1]));
      COPY_DWORDS(j, vb, vertsize, V(elts[i]));
      COPY_DWORDS(j, vb, vertsize, start);
d639 6
a644 2
#define ANY_FALLBACK_FLAGS (DD_LINE_STIPPLE | DD_TRI_STIPPLE | DD_POINT_ATTEN | DD_POINT_SMOOTH | DD_TRI_SMOOTH)
#define ANY_RASTER_FLAGS (DD_TRI_LIGHT_TWOSIDE | DD_TRI_OFFSET | DD_TRI_UNFILLED)
d646 1
a646 2
void
intelChooseRenderState(struct gl_context * ctx)
d649 1
a649 1
   struct intel_context *intel = intel_context(ctx);
d656 1
a656 1
      fprintf(stderr, "\n%s\n", __FUNCTION__);
d658 1
a658 1
   if ((flags & (ANY_FALLBACK_FLAGS | ANY_RASTER_FLAGS)) || have_wpos) {
d661 3
a663 6
         if (flags & DD_TRI_LIGHT_TWOSIDE)
            index |= INTEL_TWOSIDE_BIT;
         if (flags & DD_TRI_OFFSET)
            index |= INTEL_OFFSET_BIT;
         if (flags & DD_TRI_UNFILLED)
            index |= INTEL_UNFILLED_BIT;
d667 7
a673 7
         intel->draw_point = intel_wpos_point;
         intel->draw_line = intel_wpos_line;
         intel->draw_tri = intel_wpos_triangle;

         /* Make sure these get called:
          */
         index |= INTEL_FALLBACK_BIT;
d676 3
a678 3
         intel->draw_point = intel_draw_point;
         intel->draw_line = intel_draw_line;
         intel->draw_tri = intel_draw_triangle;
d683 7
a689 23
      if (flags & ANY_FALLBACK_FLAGS) {
         if (flags & DD_LINE_STIPPLE)
            intel->draw_line = intel_fallback_line;

         if ((flags & DD_TRI_STIPPLE) && !intel->hw_stipple)
            intel->draw_tri = intel_fallback_tri;

         if (flags & DD_TRI_SMOOTH) {
	    if (intel->conformance_mode > 0)
	       intel->draw_tri = intel_fallback_tri;
	 }

         if (flags & DD_POINT_ATTEN) {
	    if (0)
	       intel->draw_point = intel_atten_point;
	    else
	       intel->draw_point = intel_fallback_point;
	 }

	 if (flags & DD_POINT_SMOOTH) {
	    if (intel->conformance_mode > 0)
	       intel->draw_point = intel_fallback_point;
	 }
d691 10
a700 1
         index |= INTEL_FALLBACK_BIT;
d713 9
a721 10
         tnl->Driver.Render.PrimTabVerts = intel_render_tab_verts;
         tnl->Driver.Render.PrimTabElts = intel_render_tab_elts;
         tnl->Driver.Render.ClippedLine = line; /* from tritmp.h */
         tnl->Driver.Render.ClippedPolygon = intelFastRenderClippedPoly;
      }
      else {
         tnl->Driver.Render.PrimTabVerts = _tnl_render_tab_verts;
         tnl->Driver.Render.PrimTabElts = _tnl_render_tab_elts;
         tnl->Driver.Render.ClippedLine = intelRenderClippedLine;
         tnl->Driver.Render.ClippedPolygon = intelRenderClippedPoly;
d726 1
a726 1
static const GLenum reduced_prim[GL_POLYGON + 1] = {
d747 1
a747 2
static void
intelRunPipeline(struct gl_context * ctx)
d749 1
a749 6
   struct intel_context *intel = intel_context(ctx);

   _mesa_lock_context_textures(ctx);
   
   if (ctx->NewState)
      _mesa_update_state_locked(ctx);
d753 1
a753 1
         intel->vtbl.update_texture_state(intel);
d757 2
a758 2
         if (intel->NewGLState & _INTEL_NEW_RENDERSTATE)
            intelChooseRenderState(ctx);
d764 1
a764 5
   intel_map_vertex_shader_textures(ctx);
   _tnl_run_pipeline(ctx);
   intel_unmap_vertex_shader_textures(ctx);

   _mesa_unlock_context_textures(ctx);
d767 1
a767 2
static void
intelRenderStart(struct gl_context * ctx)
d769 1
a769 5
   struct intel_context *intel = intel_context(ctx);

   intel_check_front_buffer_rendering(intel);
   intel->vtbl.render_start(intel_context(ctx));
   intel->vtbl.emit_state(intel);
d772 1
a772 2
static void
intelRenderFinish(struct gl_context * ctx)
d774 2
a775 6
   struct intel_context *intel = intel_context(ctx);

   if (intel->RenderIndex & INTEL_FALLBACK_BIT)
      _swrast_flush(ctx);

   INTEL_FIREVERTICES(intel);
d784 1
a784 2
static void
intelRasterPrimitive(struct gl_context * ctx, GLenum rprim, GLuint hwprim)
d786 1
a786 1
   struct intel_context *intel = intel_context(ctx);
d789 2
a790 4
      fprintf(stderr, "%s %s %x\n", __FUNCTION__,
              _mesa_lookup_enum_by_nr(rprim), hwprim);

   intel->vtbl.reduced_primitive_state(intel, rprim);
d792 2
d796 2
a797 5
   if (hwprim != intel->prim.primitive) {
      INTEL_FIREVERTICES(intel);

      intel_set_prim(intel, hwprim);
   }
d801 3
a803 4
 /* 
  */
static void
intelRenderPrimitive(struct gl_context * ctx, GLenum prim)
d805 1
a805 1
   struct intel_context *intel = intel_context(ctx);
d820 1
a820 1
   if (reduced_prim[prim] == GL_TRIANGLES &&
d826 1
a826 1
   intelRasterPrimitive(ctx, reduced_prim[prim], hw_prim[prim]);
d830 31
a860 22
 /**********************************************************************/
 /*           Transition to/from hardware rasterization.               */
 /**********************************************************************/

static char *fallbackStrings[] = {
   [0] = "Draw buffer",
   [1] = "Read buffer",
   [2] = "Depth buffer",
   [3] = "Stencil buffer",
   [4] = "User disable",
   [5] = "Render mode",

   [12] = "Texture",
   [13] = "Color mask",
   [14] = "Stencil",
   [15] = "Stipple",
   [16] = "Program",
   [17] = "Logic op",
   [18] = "Smooth polygon",
   [19] = "Smooth point",
   [20] = "point sprite coord origin",
   [21] = "depth/color drawing offset",
d864 1
a864 1
static char *
d867 4
a870 4
   int i = 0;
   while (bit > 1) {
      i++;
      bit >>= 1;
d872 1
a872 1
   return fallbackStrings[i];
d876 1
a876 7

/**
 * Enable/disable a fallback flag.
 * \param bit  one of INTEL_FALLBACK_x flags.
 */
void
intelFallback(struct intel_context *intel, GLbitfield bit, GLboolean mode)
d878 1
a878 1
   struct gl_context *ctx = &intel->ctx;
d880 1
a880 1
   const GLbitfield oldfallback = intel->Fallback;
d885 3
a887 3
         intel_flush(ctx);
         if (INTEL_DEBUG & DEBUG_FALLBACKS)
            fprintf(stderr, "ENTER FALLBACK %x: %s\n",
d889 1
a889 1
         _swsetup_Wakeup(ctx);
d896 4
a899 3
         _swrast_flush(ctx);
         if (INTEL_DEBUG & DEBUG_FALLBACKS)
            fprintf(stderr, "LEAVE FALLBACK %s\n", getFallbackString(bit));
d907 6
a912 6
         _tnl_invalidate_vertex_state(ctx, ~0);
         _tnl_invalidate_vertices(ctx, ~0);
         _tnl_install_attrs(ctx,
                            intel->vertex_attrs,
                            intel->vertex_attr_count,
                            intel->ViewportMatrix.m, 0);
d919 2
a920 5
union fi
{
   GLfloat f;
   GLint i;
};
d927 1
a927 2
void
intelInitTriFuncs(struct gl_context * ctx)
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@a40 1
#include "main/fbobject.h"
d54 1
a56 1
#include "i915_context.h"
d65 1
a65 1
   GLuint used = intel->batch.used - intel->prim.start_ptr;
d71 1
a71 1
   if (used < 2)
d74 2
a75 2
   intel->batch.map[intel->prim.start_ptr] =
      _3DPRIMITIVE | intel->prim.primitive | (used - 2);
d80 1
a80 1
   intel->batch.used = intel->prim.start_ptr;
d94 3
a96 1
   intel->no_batch_wrap = true;
d103 3
a105 1
   intel->prim.start_ptr = intel->batch.used;
d112 1
a112 1
   intel->no_batch_wrap = false;
d121 1
a121 1
   intel_batchbuffer_flush(intel);
d127 1
d132 1
a132 1
   if (intel_batchbuffer_space(intel) < dwords * sizeof(GLuint))
d139 2
a140 2
   ptr = intel->batch.map + intel->batch.used;
   intel->batch.used += dwords;
d221 1
a221 1
      intel->prim.current_offset = intel->prim.start_offset = ALIGN(intel->prim.start_offset, 128);
d226 1
a226 1
   aper_array[0] = intel->batch.bo;
d229 1
a229 1
      intel_batchbuffer_flush(intel);
d237 1
a237 1
   intel->no_batch_wrap = true;
d239 4
a242 3
   if (intel->always_flush_cache) {
      intel_batchbuffer_emit_mi_flush(intel);
   }
d251 7
a257 2
      struct i915_context *i915 = i915_context(&intel->ctx);
      unsigned int cmd = 0, len = 0;
a258 24
      if (vb_bo != i915->current_vb_bo) {
	 cmd |= I1_LOAD_S(0);
	 len++;
      }

      if (intel->vertex_size != i915->current_vertex_size) {
	 cmd |= I1_LOAD_S(1);
	 len++;
      }
      if (len)
	 len++;

      BEGIN_BATCH(2+len);
      if (cmd)
	 OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | cmd | (len - 2));
      if (vb_bo != i915->current_vb_bo) {
	 OUT_RELOC(vb_bo, I915_GEM_DOMAIN_VERTEX, 0, 0);
	 i915->current_vb_bo = vb_bo;
      }
      if (intel->vertex_size != i915->current_vertex_size) {
	 OUT_BATCH((intel->vertex_size << S1_VERTEX_WIDTH_SHIFT) |
		   (intel->vertex_size << S1_VERTEX_PITCH_SHIFT));
	 i915->current_vertex_size = intel->vertex_size;
      }
d264 1
a264 1
      OUT_BATCH(offset / (intel->vertex_size * 4));
d297 1
a297 5
   if (intel->always_flush_cache) {
      intel_batchbuffer_emit_mi_flush(intel);
   }

   intel->no_batch_wrap = false;
a474 15
static void
intel_emit_fragcoord(struct intel_context *intel, intelVertexPtr v)
{
   struct gl_context *ctx = &intel->ctx;
   struct gl_framebuffer *fb = ctx->DrawBuffer;
   GLuint offset = intel->wpos_offset;
   float *vertex_position = (float *)v;
   float *fragcoord = (float *)((char *)v + offset);

   fragcoord[0] = vertex_position[0];

   if (_mesa_is_user_fbo(fb))
      fragcoord[1] = vertex_position[1];
   else
      fragcoord[1] = fb->Height - vertex_position[1];
a475 3
   fragcoord[2] = vertex_position[2];
   fragcoord[3] = vertex_position[3];
}
d481 14
a494 3
   intel_emit_fragcoord(intel, v0);
   intel_emit_fragcoord(intel, v1);
   intel_emit_fragcoord(intel, v2);
d504 11
a514 2
   intel_emit_fragcoord(intel, v0);
   intel_emit_fragcoord(intel, v1);
d522 7
a528 1
   intel_emit_fragcoord(intel, v0);
d631 1
a631 1
#define DEPTH_SCALE (ctx->DrawBuffer->Visual.depthBits == 16 ? 1.0 : 2.0)
d654 1
a654 1
   GLuint specoffset = intel->specoffset;				\
d798 1
a798 1
   _swrast_render_start(ctx);
d800 1
a800 1
   _swrast_render_finish(ctx);
d818 1
a818 1
   _swrast_render_start(ctx);
d820 1
a820 1
   _swrast_render_finish(ctx);
d836 1
a836 1
   _swrast_render_start(ctx);
d838 1
a838 1
   _swrast_render_finish(ctx);
a932 6
#define DD_TRI_LIGHT_TWOSIDE (1 << 1)
#define DD_TRI_UNFILLED (1 << 2)
#define DD_TRI_STIPPLE  (1 << 4)
#define DD_TRI_OFFSET   (1 << 5)
#define DD_LINE_STIPPLE (1 << 7)
#define DD_POINT_ATTEN  (1 << 9)
d934 2
a935 1
#define ANY_FALLBACK_FLAGS (DD_LINE_STIPPLE | DD_TRI_STIPPLE | DD_POINT_ATTEN)
d943 1
a943 11
   GLuint flags =
      ((ctx->Light.Enabled &&
        ctx->Light.Model.TwoSide) ? DD_TRI_LIGHT_TWOSIDE : 0) |
      ((ctx->Polygon.FrontMode != GL_FILL ||
        ctx->Polygon.BackMode != GL_FILL) ? DD_TRI_UNFILLED : 0) |
      (ctx->Polygon.StippleFlag ? DD_TRI_STIPPLE : 0) |
      ((ctx->Polygon.OffsetPoint ||
        ctx->Polygon.OffsetLine ||
        ctx->Polygon.OffsetFill) ? DD_TRI_OFFSET : 0) |
      (ctx->Line.StippleFlag ? DD_LINE_STIPPLE : 0) |
      (ctx->Point._Attenuated ? DD_POINT_ATTEN : 0);
d945 1
a945 1
   bool have_wpos = (fprog && (fprog->Base.InputsRead & VARYING_BIT_POS));
d986 5
d998 5
a1060 7
   /* We need to get this done before we start the pipeline, or a
    * change in the INTEL_FALLBACK() of its intel_draw_buffers() call
    * while the pipeline is running will result in mismatched swrast
    * map/unmaps, and later assertion failures.
    */
   intel_prepare_render(intel);

d1074 1
a1074 1
   intel->tnl_pipeline_running = true;
d1076 1
a1076 1
   intel->tnl_pipeline_running = false;
a1134 2
   GLboolean unfilled = (ctx->Polygon.FrontMode != GL_FILL ||
                         ctx->Polygon.BackMode != GL_FILL);
d1144 4
a1147 3
   /* Shortcircuit this when called for unfilled triangles.  The rasterized
    * primitive will always be reset by lower level functions in that case,
    * potentially pingponging the state:
d1149 2
a1150 1
   if (reduced_prim[prim] == GL_TRIANGLES && unfilled)
a1180 1
   [22] = "coord replace(SPRITE POINT ENABLE)",
d1202 1
a1202 1
intelFallback(struct intel_context *intel, GLbitfield bit, bool mode)
a1210 2
	 assert(!intel->tnl_pipeline_running);

d1212 1
a1212 1
         if (INTEL_DEBUG & DEBUG_PERF)
a1221 2
	 assert(!intel->tnl_pipeline_running);

d1223 1
a1223 1
         if (INTEL_DEBUG & DEBUG_PERF)
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@d605 4
a608 4
#define DO_FALLBACK ((IND & INTEL_FALLBACK_BIT) != 0)
#define DO_OFFSET   ((IND & INTEL_OFFSET_BIT) != 0)
#define DO_UNFILLED ((IND & INTEL_UNFILLED_BIT) != 0)
#define DO_TWOSIDE  ((IND & INTEL_TWOSIDE_BIT) != 0)
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d605 4
a608 4
#define DO_FALLBACK (IND & INTEL_FALLBACK_BIT)
#define DO_OFFSET   (IND & INTEL_OFFSET_BIT)
#define DO_UNFILLED (IND & INTEL_UNFILLED_BIT)
#define DO_TWOSIDE  (IND & INTEL_TWOSIDE_BIT)
@


