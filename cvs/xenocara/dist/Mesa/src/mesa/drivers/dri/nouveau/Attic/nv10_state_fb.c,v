head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.04.51;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.22;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.39;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.55;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.54;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.12.02;	author jsg;	state Exp;
branches;
next	;
commitid	ce2W5rH5aF7VS9gi;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright (C) 2009 Francisco Jerez.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "nouveau_driver.h"
#include "nouveau_context.h"
#include "nouveau_fbo.h"
#include "nouveau_util.h"
#include "nv_object.xml.h"
#include "nv10_3d.xml.h"
#include "nv10_driver.h"

static inline unsigned
get_rt_format(mesa_format format)
{
	switch (format) {
	case MESA_FORMAT_B8G8R8X8_UNORM:
		return NV10_3D_RT_FORMAT_COLOR_X8R8G8B8;
	case MESA_FORMAT_B8G8R8A8_UNORM:
		return NV10_3D_RT_FORMAT_COLOR_A8R8G8B8;
	case MESA_FORMAT_B5G6R5_UNORM:
		return NV10_3D_RT_FORMAT_COLOR_R5G6B5;
	case MESA_FORMAT_Z_UNORM16:
		return NV10_3D_RT_FORMAT_DEPTH_Z16;
	case MESA_FORMAT_S8_UINT_Z24_UNORM:
		return NV10_3D_RT_FORMAT_DEPTH_Z24S8;
	default:
		assert(0);
	}
}

static void
setup_hierz_buffer(struct gl_context *ctx)
{
	struct nouveau_pushbuf *push = context_push(ctx);
	struct gl_framebuffer *fb = ctx->DrawBuffer;
	struct nouveau_framebuffer *nfb = to_nouveau_framebuffer(fb);
	unsigned pitch = align(fb->Width, 128),
		height = align(fb->Height, 2),
		size = pitch * height;

	if (!nfb->hierz.bo || nfb->hierz.bo->size != size) {
		union nouveau_bo_config config = {
			.nv04.surf_flags = NV04_BO_ZETA,
			.nv04.surf_pitch = 0
		};

		nouveau_bo_ref(NULL, &nfb->hierz.bo);
		nouveau_bo_new(context_dev(ctx), NOUVEAU_BO_VRAM, 0, size,
			       &config, &nfb->hierz.bo);
	}

	PUSH_SPACE(push, 11);
	BEGIN_NV04(push, NV17_3D(HIERZ_OFFSET), 1);
	PUSH_MTHDl(push, NV17_3D(HIERZ_OFFSET), BUFCTX_FB,
			 nfb->hierz.bo, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR);
	BEGIN_NV04(push, NV17_3D(HIERZ_WINDOW_X), 4);
	PUSH_DATAf(push, - 1792);
	PUSH_DATAf(push, - 2304 + fb->Height);
	PUSH_DATAf(push, fb->_DepthMaxF / 2);
	PUSH_DATAf(push, 0);

	BEGIN_NV04(push, NV17_3D(HIERZ_PITCH), 1);
	PUSH_DATA (push, pitch);

	BEGIN_NV04(push, NV17_3D(HIERZ_ENABLE), 1);
	PUSH_DATA (push, 1);
}

void
nv10_emit_framebuffer(struct gl_context *ctx, int emit)
{
	struct nouveau_pushbuf *push = context_push(ctx);
	struct gl_framebuffer *fb = ctx->DrawBuffer;
	struct nouveau_surface *s;
	unsigned rt_format = NV10_3D_RT_FORMAT_TYPE_LINEAR;
	unsigned rt_pitch = 0, zeta_pitch = 0;
	unsigned bo_flags = NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR;

	if (fb->_Status != GL_FRAMEBUFFER_COMPLETE_EXT)
		return;

	PUSH_RESET(push, BUFCTX_FB);

	/* At least nv11 seems to get sad if we don't do this before
	 * swapping RTs.*/
	if (context_eng3d(ctx)->oclass < NV17_3D_CLASS) {
		int i;

		for (i = 0; i < 6; i++) {
			BEGIN_NV04(push, NV04_GRAPH(3D, NOP), 1);
			PUSH_DATA (push, 0);
		}
	}

	/* Render target */
	if (fb->_ColorDrawBuffers[0]) {
		s = &to_nouveau_renderbuffer(
			fb->_ColorDrawBuffers[0])->surface;

		rt_format |= get_rt_format(s->format);
		zeta_pitch = rt_pitch = s->pitch;

		BEGIN_NV04(push, NV10_3D(COLOR_OFFSET), 1);
		PUSH_MTHDl(push, NV10_3D(COLOR_OFFSET), BUFCTX_FB,
				 s->bo, 0, bo_flags);
	}

	/* depth/stencil */
	if (fb->Attachment[BUFFER_DEPTH].Renderbuffer) {
		s = &to_nouveau_renderbuffer(
			fb->Attachment[BUFFER_DEPTH].Renderbuffer)->surface;

		rt_format |= get_rt_format(s->format);
		zeta_pitch = s->pitch;

		BEGIN_NV04(push, NV10_3D(ZETA_OFFSET), 1);
		PUSH_MTHDl(push, NV10_3D(ZETA_OFFSET), BUFCTX_FB,
				 s->bo, 0, bo_flags);

		if (context_eng3d(ctx)->oclass >= NV17_3D_CLASS) {
			setup_hierz_buffer(ctx);
			context_dirty(ctx, ZCLEAR);
		}
	}

	BEGIN_NV04(push, NV10_3D(RT_FORMAT), 2);
	PUSH_DATA (push, rt_format);
	PUSH_DATA (push, zeta_pitch << 16 | rt_pitch);

	context_dirty(ctx, VIEWPORT);
	context_dirty(ctx, SCISSOR);
	context_dirty(ctx, DEPTH);
}

void
nv10_emit_render_mode(struct gl_context *ctx, int emit)
{
}

void
nv10_emit_scissor(struct gl_context *ctx, int emit)
{
	struct nouveau_pushbuf *push = context_push(ctx);
	int x, y, w, h;

	get_scissors(ctx->DrawBuffer, &x, &y, &w, &h);

	BEGIN_NV04(push, NV10_3D(RT_HORIZ), 2);
	PUSH_DATA (push, w << 16 | x);
	PUSH_DATA (push, h << 16 | y);
}

void
nv10_emit_viewport(struct gl_context *ctx, int emit)
{
	struct nouveau_pushbuf *push = context_push(ctx);
	struct gl_viewport_attrib *vp = &ctx->ViewportArray[0];
	struct gl_framebuffer *fb = ctx->DrawBuffer;
	float a[4] = {};

	get_viewport_translate(ctx, a);
	a[0] -= 2048;
	a[1] -= 2048;
	if (nv10_use_viewport_zclear(ctx))
		a[2] = nv10_transform_depth(ctx, (vp->Far + vp->Near) / 2);

	BEGIN_NV04(push, NV10_3D(VIEWPORT_TRANSLATE_X), 4);
	PUSH_DATAp(push, a, 4);

	BEGIN_NV04(push, NV10_3D(VIEWPORT_CLIP_HORIZ(0)), 1);
	PUSH_DATA (push, (fb->Width - 1) << 16 | 0x08000800);
	BEGIN_NV04(push, NV10_3D(VIEWPORT_CLIP_VERT(0)), 1);
	PUSH_DATA (push, (fb->Height - 1) << 16 | 0x08000800);

	context_dirty(ctx, PROJECTION);
}

void
nv10_emit_zclear(struct gl_context *ctx, int emit)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct nouveau_pushbuf *push = context_push(ctx);
	struct nouveau_framebuffer *nfb =
		to_nouveau_framebuffer(ctx->DrawBuffer);

	if (nfb->hierz.bo) {
		BEGIN_NV04(push, NV17_3D(ZCLEAR_ENABLE), 2);
		PUSH_DATAb(push, !nctx->hierz.clear_blocked);
		PUSH_DATA (push, nfb->hierz.clear_value |
			 (nctx->hierz.clear_seq & 0xff));
	} else {
		BEGIN_NV04(push, NV10_3D(DEPTH_RANGE_NEAR), 2);
		PUSH_DATAf(push, nv10_transform_depth(ctx, 0));
		PUSH_DATAf(push, nv10_transform_depth(ctx, 1));
		context_dirty(ctx, VIEWPORT);
	}
}
@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d155 1
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d36 1
a36 1
get_rt_format(gl_format format)
d39 1
a39 1
	case MESA_FORMAT_XRGB8888:
d41 1
a41 1
	case MESA_FORMAT_ARGB8888:
d43 1
a43 1
	case MESA_FORMAT_RGB565:
d45 1
a45 1
	case MESA_FORMAT_Z16:
d47 1
a47 1
	case MESA_FORMAT_Z24_S8:
d109 1
a109 1
	if (context_chipset(ctx) < 0x17) {
d143 1
a143 1
		if (context_chipset(ctx) >= 0x17) {
d179 1
a179 1
	struct gl_viewport_attrib *vp = &ctx->Viewport;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d57 1
a57 3
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *celsius = context_eng3d(ctx);
	struct nouveau_bo_context *bctx = context_bctx(ctx, HIERZ);
d65 5
d71 2
a72 2
		nouveau_bo_new_tile(context_dev(ctx), NOUVEAU_BO_VRAM, 0, size,
				    0, NOUVEAU_BO_TILE_ZETA, &nfb->hierz.bo);
d75 3
a77 1
	nouveau_bo_markl(bctx, celsius, NV17_3D_HIERZ_OFFSET,
d79 5
d85 2
a86 9
	WAIT_RING(chan, 9);
	BEGIN_RING(chan, celsius, NV17_3D_HIERZ_WINDOW_X, 4);
	OUT_RINGf(chan, - 1792);
	OUT_RINGf(chan, - 2304 + fb->Height);
	OUT_RINGf(chan, fb->_DepthMaxF / 2);
	OUT_RINGf(chan, 0);

	BEGIN_RING(chan, celsius, NV17_3D_HIERZ_PITCH, 1);
	OUT_RING(chan, pitch);
d88 2
a89 2
	BEGIN_RING(chan, celsius, NV17_3D_HIERZ_ENABLE, 1);
	OUT_RING(chan, 1);
d95 1
a95 3
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *celsius = context_eng3d(ctx);
	struct nouveau_bo_context *bctx = context_bctx(ctx, FRAMEBUFFER);
d105 2
d113 2
a114 2
			BEGIN_RING(chan, celsius, NV04_GRAPH_NOP, 1);
			OUT_RING(chan, 0);
d126 2
a127 1
		nouveau_bo_markl(bctx, celsius, NV10_3D_COLOR_OFFSET,
d132 1
a132 1
	if (fb->_DepthBuffer) {
d134 1
a134 1
			fb->_DepthBuffer->Wrapped)->surface;
d139 2
a140 1
		nouveau_bo_markl(bctx, celsius, NV10_3D_ZETA_OFFSET,
d149 3
a151 3
	BEGIN_RING(chan, celsius, NV10_3D_RT_FORMAT, 2);
	OUT_RING(chan, rt_format);
	OUT_RING(chan, zeta_pitch << 16 | rt_pitch);
d165 1
a165 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *celsius = context_eng3d(ctx);
d170 3
a172 3
	BEGIN_RING(chan, celsius, NV10_3D_RT_HORIZ, 2);
	OUT_RING(chan, w << 16 | x);
	OUT_RING(chan, h << 16 | y);
d178 1
a178 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *celsius = context_eng3d(ctx);
d189 2
a190 2
	BEGIN_RING(chan, celsius, NV10_3D_VIEWPORT_TRANSLATE_X, 4);
	OUT_RINGp(chan, a, 4);
d192 4
a195 4
	BEGIN_RING(chan, celsius, NV10_3D_VIEWPORT_CLIP_HORIZ(0), 1);
	OUT_RING(chan, (fb->Width - 1) << 16 | 0x08000800);
	BEGIN_RING(chan, celsius, NV10_3D_VIEWPORT_CLIP_VERT(0), 1);
	OUT_RING(chan, (fb->Height - 1) << 16 | 0x08000800);
d204 1
a204 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *celsius = context_eng3d(ctx);
d209 3
a211 3
		BEGIN_RING(chan, celsius, NV17_3D_ZCLEAR_ENABLE, 2);
		OUT_RINGb(chan, !nctx->hierz.clear_blocked);
		OUT_RING(chan, nfb->hierz.clear_value |
d214 3
a216 3
		BEGIN_RING(chan, celsius, NV10_3D_DEPTH_RANGE_NEAR, 2);
		OUT_RINGf(chan, nv10_transform_depth(ctx, 0));
		OUT_RINGf(chan, nv10_transform_depth(ctx, 1));
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a29 1
#include "nouveau_class.h"
d31 2
d40 1
a40 1
		return 0x05;
d42 1
a42 1
		return 0x08;
d44 1
a44 1
		return 0x03;
d46 1
a46 1
		return 0x10;
d48 1
a48 1
		return 0x0;
d55 1
a55 1
setup_lma_buffer(GLcontext *ctx)
d59 1
a59 1
	struct nouveau_bo_context *bctx = context_bctx(ctx, LMA_DEPTH);
d66 4
a69 4
	if (!nfb->lma_bo || nfb->lma_bo->size != size) {
		nouveau_bo_ref(NULL, &nfb->lma_bo);
		nouveau_bo_new(context_dev(ctx), NOUVEAU_BO_VRAM, 0, size,
			       &nfb->lma_bo);
d72 2
a73 2
	nouveau_bo_markl(bctx, celsius, NV17TCL_LMA_DEPTH_BUFFER_OFFSET,
			 nfb->lma_bo, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR);
d75 2
a76 1
	BEGIN_RING(chan, celsius, NV17TCL_LMA_DEPTH_WINDOW_X, 4);
d82 1
a82 1
	BEGIN_RING(chan, celsius, NV17TCL_LMA_DEPTH_BUFFER_PITCH, 1);
d85 1
a85 1
	BEGIN_RING(chan, celsius, NV17TCL_LMA_DEPTH_ENABLE, 1);
d90 1
a90 1
nv10_emit_framebuffer(GLcontext *ctx, int emit)
d97 1
a97 1
	unsigned rt_format = NV10TCL_RT_FORMAT_TYPE_LINEAR;
d110 1
a110 1
			BEGIN_RING(chan, celsius, NV10TCL_NOP, 1);
d116 1
a116 1
	if (fb->_NumColorDrawBuffers) {
d123 1
a123 1
		nouveau_bo_markl(bctx, celsius, NV10TCL_COLOR_OFFSET,
d135 1
a135 1
		nouveau_bo_markl(bctx, celsius, NV10TCL_ZETA_OFFSET,
d138 4
a141 2
		if (context_chipset(ctx) >= 0x17)
			setup_lma_buffer(ctx);
d144 1
a144 1
	BEGIN_RING(chan, celsius, NV10TCL_RT_FORMAT, 2);
d153 1
a153 1
nv10_emit_render_mode(GLcontext *ctx, int emit)
d158 1
a158 1
nv10_emit_scissor(GLcontext *ctx, int emit)
d166 1
a166 1
	BEGIN_RING(chan, celsius, NV10TCL_RT_HORIZ, 2);
d172 1
a172 1
nv10_emit_viewport(GLcontext *ctx, int emit)
d176 1
a178 1
	int i;
d183 2
d186 2
a187 3
	BEGIN_RING(chan, celsius, NV10TCL_VIEWPORT_TRANSLATE_X, 4);
	for (i = 0; i < 4; i++)
		OUT_RINGf(chan, a[i]);
d189 1
a189 1
	BEGIN_RING(chan, celsius, NV10TCL_VIEWPORT_CLIP_HORIZ(0), 1);
d191 1
a191 1
	BEGIN_RING(chan, celsius, NV10TCL_VIEWPORT_CLIP_VERT(0), 1);
d195 22
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d30 1
a31 2
#include "nv_object.xml.h"
#include "nv10_3d.xml.h"
d39 1
a39 1
		return NV10_3D_RT_FORMAT_COLOR_X8R8G8B8;
d41 1
a41 1
		return NV10_3D_RT_FORMAT_COLOR_A8R8G8B8;
d43 1
a43 1
		return NV10_3D_RT_FORMAT_COLOR_R5G6B5;
d45 1
a45 1
		return NV10_3D_RT_FORMAT_DEPTH_Z16;
d47 1
a47 1
		return NV10_3D_RT_FORMAT_DEPTH_Z24S8;
d54 1
a54 1
setup_hierz_buffer(struct gl_context *ctx)
d58 1
a58 1
	struct nouveau_bo_context *bctx = context_bctx(ctx, HIERZ);
d65 4
a68 4
	if (!nfb->hierz.bo || nfb->hierz.bo->size != size) {
		nouveau_bo_ref(NULL, &nfb->hierz.bo);
		nouveau_bo_new_tile(context_dev(ctx), NOUVEAU_BO_VRAM, 0, size,
				    0, NOUVEAU_BO_TILE_ZETA, &nfb->hierz.bo);
d71 2
a72 2
	nouveau_bo_markl(bctx, celsius, NV17_3D_HIERZ_OFFSET,
			 nfb->hierz.bo, 0, NOUVEAU_BO_VRAM | NOUVEAU_BO_RDWR);
d74 1
a74 2
	WAIT_RING(chan, 9);
	BEGIN_RING(chan, celsius, NV17_3D_HIERZ_WINDOW_X, 4);
d80 1
a80 1
	BEGIN_RING(chan, celsius, NV17_3D_HIERZ_PITCH, 1);
d83 1
a83 1
	BEGIN_RING(chan, celsius, NV17_3D_HIERZ_ENABLE, 1);
d88 1
a88 1
nv10_emit_framebuffer(struct gl_context *ctx, int emit)
d95 1
a95 1
	unsigned rt_format = NV10_3D_RT_FORMAT_TYPE_LINEAR;
d108 1
a108 1
			BEGIN_RING(chan, celsius, NV04_GRAPH_NOP, 1);
d114 1
a114 1
	if (fb->_ColorDrawBuffers[0]) {
d121 1
a121 1
		nouveau_bo_markl(bctx, celsius, NV10_3D_COLOR_OFFSET,
d133 1
a133 1
		nouveau_bo_markl(bctx, celsius, NV10_3D_ZETA_OFFSET,
d136 2
a137 4
		if (context_chipset(ctx) >= 0x17) {
			setup_hierz_buffer(ctx);
			context_dirty(ctx, ZCLEAR);
		}
d140 1
a140 1
	BEGIN_RING(chan, celsius, NV10_3D_RT_FORMAT, 2);
d149 1
a149 1
nv10_emit_render_mode(struct gl_context *ctx, int emit)
d154 1
a154 1
nv10_emit_scissor(struct gl_context *ctx, int emit)
d162 1
a162 1
	BEGIN_RING(chan, celsius, NV10_3D_RT_HORIZ, 2);
d168 1
a168 1
nv10_emit_viewport(struct gl_context *ctx, int emit)
a171 1
	struct gl_viewport_attrib *vp = &ctx->Viewport;
d174 1
a178 2
	if (nv10_use_viewport_zclear(ctx))
		a[2] = nv10_transform_depth(ctx, (vp->Far + vp->Near) / 2);
d180 3
a182 2
	BEGIN_RING(chan, celsius, NV10_3D_VIEWPORT_TRANSLATE_X, 4);
	OUT_RINGp(chan, a, 4);
d184 1
a184 1
	BEGIN_RING(chan, celsius, NV10_3D_VIEWPORT_CLIP_HORIZ(0), 1);
d186 1
a186 1
	BEGIN_RING(chan, celsius, NV10_3D_VIEWPORT_CLIP_VERT(0), 1);
a189 22
}

void
nv10_emit_zclear(struct gl_context *ctx, int emit)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *celsius = context_eng3d(ctx);
	struct nouveau_framebuffer *nfb =
		to_nouveau_framebuffer(ctx->DrawBuffer);

	if (nfb->hierz.bo) {
		BEGIN_RING(chan, celsius, NV17_3D_ZCLEAR_ENABLE, 2);
		OUT_RINGb(chan, !nctx->hierz.clear_blocked);
		OUT_RING(chan, nfb->hierz.clear_value |
			 (nctx->hierz.clear_seq & 0xff));
	} else {
		BEGIN_RING(chan, celsius, NV10_3D_DEPTH_RANGE_NEAR, 2);
		OUT_RINGf(chan, nv10_transform_depth(ctx, 0));
		OUT_RINGf(chan, nv10_transform_depth(ctx, 1));
		context_dirty(ctx, VIEWPORT);
	}
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d57 3
a59 1
	struct nouveau_pushbuf *push = context_push(ctx);
a66 5
		union nouveau_bo_config config = {
			.nv04.surf_flags = NV04_BO_ZETA,
			.nv04.surf_pitch = 0
		};

d68 2
a69 2
		nouveau_bo_new(context_dev(ctx), NOUVEAU_BO_VRAM, 0, size,
			       &config, &nfb->hierz.bo);
d72 1
a72 3
	PUSH_SPACE(push, 11);
	BEGIN_NV04(push, NV17_3D(HIERZ_OFFSET), 1);
	PUSH_MTHDl(push, NV17_3D(HIERZ_OFFSET), BUFCTX_FB,
a73 5
	BEGIN_NV04(push, NV17_3D(HIERZ_WINDOW_X), 4);
	PUSH_DATAf(push, - 1792);
	PUSH_DATAf(push, - 2304 + fb->Height);
	PUSH_DATAf(push, fb->_DepthMaxF / 2);
	PUSH_DATAf(push, 0);
d75 9
a83 2
	BEGIN_NV04(push, NV17_3D(HIERZ_PITCH), 1);
	PUSH_DATA (push, pitch);
d85 2
a86 2
	BEGIN_NV04(push, NV17_3D(HIERZ_ENABLE), 1);
	PUSH_DATA (push, 1);
d92 3
a94 1
	struct nouveau_pushbuf *push = context_push(ctx);
a103 2
	PUSH_RESET(push, BUFCTX_FB);

d110 2
a111 2
			BEGIN_NV04(push, NV04_GRAPH(3D, NOP), 1);
			PUSH_DATA (push, 0);
d123 1
a123 2
		BEGIN_NV04(push, NV10_3D(COLOR_OFFSET), 1);
		PUSH_MTHDl(push, NV10_3D(COLOR_OFFSET), BUFCTX_FB,
d128 1
a128 1
	if (fb->Attachment[BUFFER_DEPTH].Renderbuffer) {
d130 1
a130 1
			fb->Attachment[BUFFER_DEPTH].Renderbuffer)->surface;
d135 1
a135 2
		BEGIN_NV04(push, NV10_3D(ZETA_OFFSET), 1);
		PUSH_MTHDl(push, NV10_3D(ZETA_OFFSET), BUFCTX_FB,
d144 3
a146 3
	BEGIN_NV04(push, NV10_3D(RT_FORMAT), 2);
	PUSH_DATA (push, rt_format);
	PUSH_DATA (push, zeta_pitch << 16 | rt_pitch);
d160 2
a161 1
	struct nouveau_pushbuf *push = context_push(ctx);
d166 3
a168 3
	BEGIN_NV04(push, NV10_3D(RT_HORIZ), 2);
	PUSH_DATA (push, w << 16 | x);
	PUSH_DATA (push, h << 16 | y);
d174 2
a175 1
	struct nouveau_pushbuf *push = context_push(ctx);
d186 2
a187 2
	BEGIN_NV04(push, NV10_3D(VIEWPORT_TRANSLATE_X), 4);
	PUSH_DATAp(push, a, 4);
d189 4
a192 4
	BEGIN_NV04(push, NV10_3D(VIEWPORT_CLIP_HORIZ(0)), 1);
	PUSH_DATA (push, (fb->Width - 1) << 16 | 0x08000800);
	BEGIN_NV04(push, NV10_3D(VIEWPORT_CLIP_VERT(0)), 1);
	PUSH_DATA (push, (fb->Height - 1) << 16 | 0x08000800);
d201 2
a202 1
	struct nouveau_pushbuf *push = context_push(ctx);
d207 3
a209 3
		BEGIN_NV04(push, NV17_3D(ZCLEAR_ENABLE), 2);
		PUSH_DATAb(push, !nctx->hierz.clear_blocked);
		PUSH_DATA (push, nfb->hierz.clear_value |
d212 3
a214 3
		BEGIN_NV04(push, NV10_3D(DEPTH_RANGE_NEAR), 2);
		PUSH_DATAf(push, nv10_transform_depth(ctx, 0));
		PUSH_DATAf(push, nv10_transform_depth(ctx, 1));
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d36 1
a36 1
get_rt_format(mesa_format format)
d39 1
a39 1
	case MESA_FORMAT_B8G8R8X8_UNORM:
d41 1
a41 1
	case MESA_FORMAT_B8G8R8A8_UNORM:
d43 1
a43 1
	case MESA_FORMAT_B5G6R5_UNORM:
d45 1
a45 1
	case MESA_FORMAT_Z_UNORM16:
d47 1
a47 1
	case MESA_FORMAT_S8_UINT_Z24_UNORM:
d109 1
a109 1
	if (context_eng3d(ctx)->oclass < NV17_3D_CLASS) {
d143 1
a143 1
		if (context_eng3d(ctx)->oclass >= NV17_3D_CLASS) {
d179 1
a179 1
	struct gl_viewport_attrib *vp = &ctx->ViewportArray[0];
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a154 1
	context_dirty(ctx, DEPTH);
@


