head	1.6;
access;
symbols
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.07.09.21.08.59;	author jsg;	state dead;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.09.05.14.04.27;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.14.58.15;	author matthieu;	state dead;
branches;
next	1.3;

1.3
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.51;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.51;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.18;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.28.42;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.15.46;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@/**************************************************************************
 * 
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#ifndef INTELCONTEXT_INC
#define INTELCONTEXT_INC


#include <stdbool.h>
#include <string.h>
#include "main/mtypes.h"
#include "main/mm.h"

#ifdef __cplusplus
extern "C" {
	/* Evil hack for using libdrm in a c++ compiler. */
	#define virtual virt
#endif

#include "drm.h"
#include "intel_bufmgr.h"

#include "intel_screen.h"
#include "intel_tex_obj.h"
#include "i915_drm.h"

#ifdef __cplusplus
	#undef virtual
#endif

#include "tnl/t_vertex.h"

struct intel_region;

#define INTEL_WRITE_PART  0x1
#define INTEL_WRITE_FULL  0x2
#define INTEL_READ        0x4

#ifndef likely
#ifdef __GNUC__
#define likely(expr) (__builtin_expect(expr, 1))
#define unlikely(expr) (__builtin_expect(expr, 0))
#else
#define likely(expr) (expr)
#define unlikely(expr) (expr)
#endif
#endif

struct intel_sync_object {
   struct gl_sync_object Base;

   /** Batch associated with this sync object */
   drm_intel_bo *bo;
};

struct brw_context;

struct intel_batchbuffer {
   /** Current batchbuffer being queued up. */
   drm_intel_bo *bo;
   /** Last BO submitted to the hardware.  Used for glFinish(). */
   drm_intel_bo *last_bo;
   /** BO for post-sync nonzero writes for gen6 workaround. */
   drm_intel_bo *workaround_bo;
   bool need_workaround_flush;

   struct cached_batch_item *cached_items;

   uint16_t emit, total;
   uint16_t used, reserved_space;
   uint32_t *map;
   uint32_t *cpu_map;
#define BATCH_SZ (8192*sizeof(uint32_t))

   uint32_t state_batch_offset;
   bool is_blit;
   bool needs_sol_reset;

   struct {
      uint16_t used;
      int reloc_count;
   } saved;
};

/**
 * Align a value down to an alignment value
 *
 * If \c value is not already aligned to the requested alignment value, it
 * will be rounded down.
 *
 * \param value  Value to be rounded
 * \param alignment  Alignment value to be used.  This must be a power of two.
 *
 * \sa ALIGN()
 */
#define ROUND_DOWN_TO(value, alignment) ((value) & ~(alignment - 1))

static INLINE uint32_t
U_FIXED(float value, uint32_t frac_bits)
{
   value *= (1 << frac_bits);
   return value < 0 ? 0 : value;
}

static INLINE uint32_t
S_FIXED(float value, uint32_t frac_bits)
{
   return value * (1 << frac_bits);
}

/* ================================================================
 * From linux kernel i386 header files, copes with odd sizes better
 * than COPY_DWORDS would:
 * XXX Put this in src/mesa/main/imports.h ???
 */
#if defined(i386) || defined(__i386__)
static INLINE void * __memcpy(void * to, const void * from, size_t n)
{
   int d0, d1, d2;
   __asm__ __volatile__(
      "rep ; movsl\n\t"
      "testb $2,%b4\n\t"
      "je 1f\n\t"
      "movsw\n"
      "1:\ttestb $1,%b4\n\t"
      "je 2f\n\t"
      "movsb\n"
      "2:"
      : "=&c" (d0), "=&D" (d1), "=&S" (d2)
      :"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
      : "memory");
   return (to);
}
#else
#define __memcpy(a,b,c) memcpy(a,b,c)
#endif


/* ================================================================
 * Debugging:
 */
extern int INTEL_DEBUG;

#define DEBUG_TEXTURE	0x1
#define DEBUG_STATE	0x2
#define DEBUG_IOCTL	0x4
#define DEBUG_BLIT	0x8
#define DEBUG_MIPTREE   0x10
#define DEBUG_PERF	0x20
#define DEBUG_BATCH     0x80
#define DEBUG_PIXEL     0x100
#define DEBUG_BUFMGR    0x200
#define DEBUG_REGION    0x400
#define DEBUG_FBO       0x800
#define DEBUG_GS        0x1000
#define DEBUG_SYNC	0x2000
#define DEBUG_PRIMS	0x4000
#define DEBUG_VERTS	0x8000
#define DEBUG_DRI       0x10000
#define DEBUG_SF        0x20000
#define DEBUG_STATS     0x100000
#define DEBUG_WM        0x400000
#define DEBUG_URB       0x800000
#define DEBUG_VS        0x1000000
#define DEBUG_CLIP      0x2000000
#define DEBUG_AUB       0x4000000
#define DEBUG_SHADER_TIME 0x8000000
#define DEBUG_BLORP     0x10000000
#define DEBUG_NO16      0x20000000

#ifdef HAVE_ANDROID_PLATFORM
#define LOG_TAG "INTEL-MESA"
#include <cutils/log.h>
#ifndef ALOGW
#define ALOGW LOGW
#endif
#define dbg_printf(...)	ALOGW(__VA_ARGS__)
#else
#define dbg_printf(...)	printf(__VA_ARGS__)
#endif /* HAVE_ANDROID_PLATFORM */

#define DBG(...) do {						\
	if (unlikely(INTEL_DEBUG & FILE_DEBUG_FLAG))		\
		dbg_printf(__VA_ARGS__);			\
} while(0)

#define perf_debug(...) do {					\
   static GLuint msg_id = 0;                                    \
   if (unlikely(INTEL_DEBUG & DEBUG_PERF))                      \
      dbg_printf(__VA_ARGS__);                                  \
   if (brw->perf_debug)                                         \
      _mesa_gl_debug(&brw->ctx, &msg_id,                        \
                     MESA_DEBUG_TYPE_PERFORMANCE,               \
                     MESA_DEBUG_SEVERITY_MEDIUM,                \
                     __VA_ARGS__);                              \
} while(0)

#define WARN_ONCE(cond, fmt...) do {                            \
   if (unlikely(cond)) {                                        \
      static bool _warned = false;                              \
      static GLuint msg_id = 0;                                 \
      if (!_warned) {                                           \
         fprintf(stderr, "WARNING: ");                          \
         fprintf(stderr, fmt);                                  \
         _warned = true;                                        \
                                                                \
         _mesa_gl_debug(ctx, &msg_id,                           \
                        MESA_DEBUG_TYPE_OTHER,                  \
                        MESA_DEBUG_SEVERITY_HIGH, fmt);         \
      }                                                         \
   }                                                            \
} while (0)

/* ================================================================
 * intel_context.c:
 */

extern bool intelInitContext(struct brw_context *brw,
                             int api,
                             unsigned major_version,
                             unsigned minor_version,
                             const struct gl_config * mesaVis,
                             __DRIcontext * driContextPriv,
                             void *sharedContextPrivate,
                             struct dd_function_table *functions,
                             unsigned *dri_ctx_error);

extern void intelFinish(struct gl_context * ctx);
extern void _intel_flush(struct gl_context * ctx, const char *file, int line);

#define intel_flush(ctx) _intel_flush(ctx, __FILE__, __LINE__)

extern void intelInitDriverFunctions(struct dd_function_table *functions);

void intel_init_syncobj_functions(struct dd_function_table *functions);

enum {
   DRI_CONF_BO_REUSE_DISABLED,
   DRI_CONF_BO_REUSE_ALL
};

extern int intel_translate_shadow_compare_func(GLenum func);
extern int intel_translate_compare_func(GLenum func);
extern int intel_translate_stencil_op(GLenum op);
extern int intel_translate_logic_op(GLenum opcode);

void intel_update_renderbuffers(__DRIcontext *context,
				__DRIdrawable *drawable);
void intel_prepare_render(struct brw_context *brw);

void
intel_resolve_for_dri2_flush(struct brw_context *brw,
                             __DRIdrawable *drawable);

extern void
intelInitExtensions(struct gl_context *ctx);
extern void
intelInitClearFuncs(struct dd_function_table *functions);

static INLINE bool
is_power_of_two(uint32_t value)
{
   return (value & (value - 1)) == 0;
}

#ifdef __cplusplus
}
#endif

#endif
@


1.5
log
@Merge Mesa 9.2.0
@
text
@@


1.4
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d32 10
a42 1
#include "mtypes.h"
d44 1
a44 1
#include "texmem.h"
d47 7
a53 1
#include "i830_common.h"
a55 8
#define TAG(x) intel##x
#include "tnl_dd/t_dd_vertex.h"
#undef TAG

#define DV_PF_555  (1<<8)
#define DV_PF_565  (2<<8)
#define DV_PF_8888 (3<<8)

a56 1
struct intel_context;
d58 13
a70 10
typedef void (*intel_tri_func)(struct intel_context *, intelVertex *, intelVertex *,
							  intelVertex *);
typedef void (*intel_line_func)(struct intel_context *, intelVertex *, intelVertex *);
typedef void (*intel_point_func)(struct intel_context *, intelVertex *);

#define INTEL_FALLBACK_DRAW_BUFFER	 0x1
#define INTEL_FALLBACK_READ_BUFFER	 0x2
#define INTEL_FALLBACK_USER		 0x4
#define INTEL_FALLBACK_RENDERMODE	 0x8
#define INTEL_FALLBACK_TEXTURE   	 0x10
d72 2
a73 2
extern void intelFallback( struct intel_context *intel, GLuint bit, GLboolean mode );
#define FALLBACK( intel, bit, mode ) intelFallback( intel, bit, mode )
d75 2
a76 19


struct intel_texture_object
{
   struct gl_texture_object base; /* The "parent" object */

   /* The mipmap tree must include at least these levels once
    * validated:
    */
   GLuint firstLevel;
   GLuint lastLevel;

   GLuint dirty_images[6];
   GLuint dirty;

   /* On validation any active images held in main memory or in other
    * regions will be copied to this region and the old storage freed.
    */
   struct intel_mipmap_tree *mt;
d79 1
d81 20
a100 4

struct intel_context
{
   GLcontext ctx;		/* the parent class */
d103 3
a105 167
      void (*destroy)( struct intel_context *intel ); 
      void (*emit_state)( struct intel_context *intel );
      void (*emit_invarient_state)( struct intel_context *intel );
      void (*lost_hardware)( struct intel_context *intel );
      void (*note_fence)( struct intel_context *intel, GLuint fence );
      void (*note_unlock)( struct intel_context *intel );
      void (*update_texture_state)( struct intel_context *intel );

      void (*render_start)( struct intel_context *intel );
      void (*set_draw_region)( struct intel_context *intel, 
			       struct intel_region *draw_region,
			       struct intel_region *depth_region );

      GLuint (*flush_cmd)( void );

      void (*emit_flush)( struct intel_context *intel,
			  GLuint unused );

      void (*aub_commands)( struct intel_context *intel, 
			    GLuint offset,
			    const void *buf,
			    GLuint sz );
      void (*aub_dump_bmp)( struct intel_context *intel, GLuint buffer );
      void (*aub_wrap)( struct intel_context *intel );
      void (*aub_gtt_data)( struct intel_context *intel, 
			    GLuint offset,
			    const void *src,
			    GLuint size,
			    GLuint aubtype, 
			    GLuint aubsubtype);


      void (*reduced_primitive_state)( struct intel_context *intel, GLenum rprim );

      GLboolean (*check_vertex_size)( struct intel_context *intel, GLuint expected );

      void (*invalidate_state)( struct intel_context *intel, GLuint new_state );

      /* Metaops: 
       */
      void (*install_meta_state)( struct intel_context *intel );
      void (*leave_meta_state)( struct intel_context *intel );

      void (*meta_draw_region)( struct intel_context *intel,
				struct intel_region *draw_region,
				struct intel_region *depth_region );

      void (*meta_color_mask)( struct intel_context *intel,
			       GLboolean );
      
      void (*meta_stencil_replace)( struct intel_context *intel,
				    GLuint mask,
				    GLuint clear );

      void (*meta_depth_replace)( struct intel_context *intel );

      void (*meta_texture_blend_replace) (struct intel_context * intel);
      
      void (*meta_no_stencil_write)( struct intel_context *intel );
      void (*meta_no_depth_write)( struct intel_context *intel );
      void (*meta_no_texture)( struct intel_context *intel );
      void (*meta_import_pixel_state) (struct intel_context * intel);
      void (*meta_frame_buffer_texture)( struct intel_context *intel,
					 GLint xoff, GLint yoff );

      void (*meta_draw_quad)(struct intel_context *intel, 
			     GLfloat x0, GLfloat x1,
			     GLfloat y0, GLfloat y1, 
			     GLfloat z,
			     GLubyte red, GLubyte green,
			     GLubyte blue, GLubyte alpha,
			     GLfloat s0, GLfloat s1,
			     GLfloat t0, GLfloat t1);



   } vtbl;

   GLint refcount;   
   GLuint Fallback;
   GLuint NewGLState;
   
   GLuint last_swap_fence;
   GLuint second_last_swap_fence;
   
   GLboolean aub_wrap;
   GLuint stats_wm;

   struct intel_batchbuffer *batch;

   GLubyte clear_chan[4];
   GLuint ClearColor;
   GLuint ClearDepth;

   GLfloat depth_scale;
   GLfloat polygon_offset_scale; /* dependent on depth_scale, bpp */
   GLuint depth_clear_mask;
   GLuint stencil_clear_mask;

   GLboolean hw_stencil;
   GLboolean hw_stipple;
   GLboolean depth_buffer_is_float;
   GLboolean no_hw;
   GLboolean no_rast;
   GLboolean thrashing;
   GLboolean locked;
   GLboolean strict_conformance;
   GLboolean need_flush;


   
   /* AGP memory buffer manager:
    */
   struct bufmgr *bm;


   /* State for intelvb.c and inteltris.c.
    */
   GLenum render_primitive;
   GLenum reduced_primitive;

   struct intel_region *front_region;
   struct intel_region *back_region;
   struct intel_region *draw_region;
   struct intel_region *depth_region;

   /* These refer to the current draw (front vs. back) buffer:
    */
   int drawX;			/* origin of drawable in draw buffer */
   int drawY;
   GLuint numClipRects;		/* cliprects for that buffer */
   drm_clip_rect_t *pClipRects;
   struct gl_texture_object *frame_buffer_texobj;

   GLboolean scissor;
   drm_clip_rect_t draw_rect;
   drm_clip_rect_t scissor_rect;

   drm_context_t hHWContext;
   drmLock *driHwLock;
   int driFd;

   __DRIdrawablePrivate *driDrawable;
   __DRIdrawablePrivate *driReadDrawable;
   __DRIscreenPrivate *driScreen;
   intelScreenPrivate *intelScreen; 
   volatile drmI830Sarea *sarea; 
   
   FILE *aub_file;

   GLuint lastStamp;

   /**
    * Configuration cache
    */
   driOptionCache optionCache;

   /* VBI
    */
   GLuint vbl_seq;
   GLuint vblank_flags;

   int64_t swap_ust;
   int64_t swap_missed_ust;

   GLuint swap_count;
   GLuint swap_missed_count;
d108 10
a117 1
/* These are functions now:
d119 1
a119 30
void LOCK_HARDWARE( struct intel_context *intel );
void UNLOCK_HARDWARE( struct intel_context *intel );


#define SUBPIXEL_X 0.125
#define SUBPIXEL_Y 0.125

/* ================================================================
 * Color packing:
 */

#define INTEL_PACKCOLOR4444(r,g,b,a) \
  ((((a) & 0xf0) << 8) | (((r) & 0xf0) << 4) | ((g) & 0xf0) | ((b) >> 4))

#define INTEL_PACKCOLOR1555(r,g,b,a) \
  ((((r) & 0xf8) << 7) | (((g) & 0xf8) << 2) | (((b) & 0xf8) >> 3) | \
    ((a) ? 0x8000 : 0))

#define INTEL_PACKCOLOR565(r,g,b) \
  ((((r) & 0xf8) << 8) | (((g) & 0xfc) << 3) | (((b) & 0xf8) >> 3))

#define INTEL_PACKCOLOR8888(r,g,b,a) \
  ((a<<24) | (r<<16) | (g<<8) | b)


#define INTEL_PACKCOLOR(format, r,  g,  b, a)		\
(format == DV_PF_555 ? INTEL_PACKCOLOR1555(r,g,b,a) :	\
 (format == DV_PF_565 ? INTEL_PACKCOLOR565(r,g,b) :	\
  (format == DV_PF_8888 ? INTEL_PACKCOLOR8888(r,g,b,a) :	\
   0)))
d121 6
d128 5
d137 1
d140 1
a140 1
static inline void * __memcpy(void * to, const void * from, size_t n)
a161 26
/* The system memcpy (at least on ubuntu 5.10) has problems copying
 * to agp (writecombined) memory from a source which isn't 64-byte
 * aligned - there is a 4x performance falloff.
 *
 * The x86 __memcpy is immune to this but is slightly slower
 * (10%-ish) than the system memcpy.
 *
 * The sse_memcpy seems to have a slight cliff at 64/32 bytes, but
 * isn't much faster than x86_memcpy for agp copies.
 * 
 * TODO: switch dynamically.
 */
static inline void *do_memcpy( void *dest, const void *src, size_t n )
{
   if ( (((unsigned long)src) & 63) ||
	(((unsigned long)dest) & 63)) {
      return  __memcpy(dest, src, n);	
   }
   else
      return memcpy(dest, src, n);
}





d170 34
a203 32
#define DEBUG_PRIMS	0x8
#define DEBUG_VERTS	0x10
#define DEBUG_FALLBACKS	0x20
#define DEBUG_VERBOSE	0x40
#define DEBUG_DRI       0x80
#define DEBUG_DMA       0x100
#define DEBUG_SANITY    0x200
#define DEBUG_SYNC      0x400
#define DEBUG_SLEEP     0x800
#define DEBUG_PIXEL     0x1000
#define DEBUG_STATS     0x2000
#define DEBUG_TILE      0x4000
#define DEBUG_SINGLE_THREAD   0x8000
#define DEBUG_WM        0x10000
#define DEBUG_URB       0x20000
#define DEBUG_VS        0x40000


#define PCI_CHIP_845_G			0x2562
#define PCI_CHIP_I830_M			0x3577
#define PCI_CHIP_I855_GM		0x3582
#define PCI_CHIP_I865_G			0x2572
#define PCI_CHIP_I915_G			0x2582
#define PCI_CHIP_I915_GM		0x2592
#define PCI_CHIP_I945_G			0x2772
#define PCI_CHIP_I965_G			0x29A2
#define PCI_CHIP_I965_Q			0x2992
#define PCI_CHIP_I965_G_1		0x2982
#define PCI_CHIP_I946_GZ		0x2972
#define PCI_CHIP_I965_GM                0x2A02

#define PCI_CHIP_IGD_GM       0x2A42
d205 31
d241 23
a263 19
extern GLboolean intelInitContext( struct intel_context *intel, 
				   const __GLcontextModes *mesaVis,
				   __DRIcontextPrivate *driContextPriv,
				   void *sharedContextPrivate,
				   struct dd_function_table *functions );

extern void intelGetLock(struct intel_context *intel, GLuint flags);

extern void intelInitState( GLcontext *ctx );
extern void intelFinish( GLcontext *ctx );
extern void intelFlush( GLcontext *ctx );

extern void intelInitDriverFunctions( struct dd_function_table *functions );


/* ================================================================
 * intel_state.c:
 */
extern void intelInitStateFuncs( struct dd_function_table *functions );
d265 17
a281 57
#define COMPAREFUNC_ALWAYS		0
#define COMPAREFUNC_NEVER		0x1
#define COMPAREFUNC_LESS		0x2
#define COMPAREFUNC_EQUAL		0x3
#define COMPAREFUNC_LEQUAL		0x4
#define COMPAREFUNC_GREATER		0x5
#define COMPAREFUNC_NOTEQUAL		0x6
#define COMPAREFUNC_GEQUAL		0x7

#define STENCILOP_KEEP			0
#define STENCILOP_ZERO			0x1
#define STENCILOP_REPLACE		0x2
#define STENCILOP_INCRSAT		0x3
#define STENCILOP_DECRSAT		0x4
#define STENCILOP_INCR			0x5
#define STENCILOP_DECR			0x6
#define STENCILOP_INVERT		0x7

#define LOGICOP_CLEAR			0
#define LOGICOP_NOR			0x1
#define LOGICOP_AND_INV 		0x2
#define LOGICOP_COPY_INV		0x3
#define LOGICOP_AND_RVRSE		0x4
#define LOGICOP_INV			0x5
#define LOGICOP_XOR			0x6
#define LOGICOP_NAND			0x7
#define LOGICOP_AND			0x8
#define LOGICOP_EQUIV			0x9
#define LOGICOP_NOOP			0xa
#define LOGICOP_OR_INV			0xb
#define LOGICOP_COPY			0xc
#define LOGICOP_OR_RVRSE		0xd
#define LOGICOP_OR			0xe
#define LOGICOP_SET			0xf

#define BLENDFACT_ZERO			0x01
#define BLENDFACT_ONE			0x02
#define BLENDFACT_SRC_COLR		0x03
#define BLENDFACT_INV_SRC_COLR 		0x04
#define BLENDFACT_SRC_ALPHA		0x05
#define BLENDFACT_INV_SRC_ALPHA 	0x06
#define BLENDFACT_DST_ALPHA		0x07
#define BLENDFACT_INV_DST_ALPHA 	0x08
#define BLENDFACT_DST_COLR		0x09
#define BLENDFACT_INV_DST_COLR		0x0a
#define BLENDFACT_SRC_ALPHA_SATURATE	0x0b
#define BLENDFACT_CONST_COLOR		0x0c
#define BLENDFACT_INV_CONST_COLOR	0x0d
#define BLENDFACT_CONST_ALPHA		0x0e
#define BLENDFACT_INV_CONST_ALPHA	0x0f
#define BLENDFACT_MASK          	0x0f

extern int intel_translate_shadow_compare_func( GLenum func );
extern int intel_translate_compare_func( GLenum func );
extern int intel_translate_stencil_op( GLenum op );
extern int intel_translate_blend_factor( GLenum factor );
extern int intel_translate_logic_op( GLenum opcode );
d283 2
a284 41

/* ================================================================
 * intel_buffers.c:
 */
void intelInitBufferFuncs( struct dd_function_table *functions );

struct intel_region *intel_readbuf_region( struct intel_context *intel );
struct intel_region *intel_drawbuf_region( struct intel_context *intel );

extern void intelWindowMoved( struct intel_context *intel );

extern GLboolean intel_intersect_cliprects( drm_clip_rect_t *dest,
					    const drm_clip_rect_t *a,
					    const drm_clip_rect_t *b );


/* ================================================================
 * intel_pixel_copy.c:
 */
void intelCopyPixels(GLcontext * ctx,
                     GLint srcx, GLint srcy,
                     GLsizei width, GLsizei height,
                     GLint destx, GLint desty, GLenum type);

GLboolean intel_check_blit_fragment_ops(GLcontext * ctx);

void intelBitmap(GLcontext * ctx,
		 GLint x, GLint y,
		 GLsizei width, GLsizei height,
		 const struct gl_pixelstore_attrib *unpack,
		 const GLubyte * pixels);

void intelInitExtensions(GLcontext *ctx, GLboolean enable_imaging);
#define _NEW_WINDOW_POS 0x40000000


/*======================================================================
 * Inline conversion functions.  
 * These are better-typed than the macros used previously:
 */
static inline struct intel_context *intel_context( GLcontext *ctx )
d286 1
a286 1
   return (struct intel_context *)ctx;
d289 1
a289 8
static inline struct intel_texture_object *intel_texture_object( struct gl_texture_object *obj )
{
   return (struct intel_texture_object *)obj;
}

static inline struct intel_texture_image *intel_texture_image( struct gl_texture_image *img )
{
   return (struct intel_texture_image *)img;
d291 1
a293 1

@


1.3
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d390 2
@


1.1
log
@Initial revision
@
text
@a88 1

d150 2
d155 3
d180 1
a183 10
   struct {
      GLuint id;
      GLuint primitive;
      GLubyte *start_ptr;      
      void (*flush)( struct intel_context * );
   } prim;

   GLboolean locked;
   GLboolean strict_conformance;

d199 4
a211 2
   GLuint RenderIndex;
   GLmatrix ViewportMatrix;
a213 3
   GLuint vertex_size;
   GLubyte *verts;			/* points to tnl->clipspace.vertex_buf */

a219 7

   /* Fallback rasterization functions 
    */
   intel_point_func draw_point;
   intel_line_func draw_line;
   intel_tri_func draw_tri;

d226 1
d237 1
d339 2
a340 2
   if ( (((unsigned)src) & 63) ||
	(((unsigned)dest) & 63)) {
d388 1
d467 1
a467 1

d489 15
d505 1
a526 1

@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d89 1
a150 2
      void (*meta_texture_blend_replace) (struct intel_context * intel);
      
a153 3
      void (*meta_import_pixel_state) (struct intel_context * intel);
      void (*meta_frame_buffer_texture)( struct intel_context *intel,
					 GLint xoff, GLint yoff );
d179 10
a203 4
   GLboolean locked;
   GLboolean strict_conformance;
   GLboolean need_flush;

d213 2
d217 3
d226 7
a238 1
   struct gl_texture_object *frame_buffer_texobj;
d350 2
a351 2
   if ( (((unsigned long)src) & 63) ||
	(((unsigned long)dest) & 63)) {
a498 15
/* ================================================================
 * intel_pixel_copy.c:
 */
void intelCopyPixels(GLcontext * ctx,
                     GLint srcx, GLint srcy,
                     GLsizei width, GLsizei height,
                     GLint destx, GLint desty, GLenum type);

GLboolean intel_check_blit_fragment_ops(GLcontext * ctx);

void intelBitmap(GLcontext * ctx,
		 GLint x, GLint y,
		 GLsizei width, GLsizei height,
		 const struct gl_pixelstore_attrib *unpack,
		 const GLubyte * pixels);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@a179 1
   GLuint stats_wm;
a385 1
#define PCI_CHIP_I965_GM                0x2A02
a501 1
void intelInitExtensions(GLcontext *ctx, GLboolean enable_imaging);
d523 1
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@a31 10
#include <stdbool.h>
#include <string.h>
#include "main/mtypes.h"
#include "main/mm.h"

#ifdef __cplusplus
extern "C" {
	/* Evil hack for using libdrm in a c++ compiler. */
	#define virtual virt
#endif
d33 1
d35 1
a35 1
#include "intel_bufmgr.h"
d38 13
a50 2
#include "intel_tex_obj.h"
#include "i915_drm.h"
d52 10
a61 3
#ifdef __cplusplus
	#undef virtual
#endif
d63 2
a64 1
#include "tnl/t_vertex.h"
a65 1
struct intel_region;
a66 13
#define INTEL_WRITE_PART  0x1
#define INTEL_WRITE_FULL  0x2
#define INTEL_READ        0x4

#ifndef likely
#ifdef __GNUC__
#define likely(expr) (__builtin_expect(expr, 1))
#define unlikely(expr) (__builtin_expect(expr, 0))
#else
#define likely(expr) (expr)
#define unlikely(expr) (expr)
#endif
#endif
d68 3
a70 2
struct intel_sync_object {
   struct gl_sync_object Base;
d72 13
a84 2
   /** Batch associated with this sync object */
   drm_intel_bo *bo;
a86 1
struct brw_context;
d88 4
a91 20
struct intel_batchbuffer {
   /** Current batchbuffer being queued up. */
   drm_intel_bo *bo;
   /** Last BO submitted to the hardware.  Used for glFinish(). */
   drm_intel_bo *last_bo;
   /** BO for post-sync nonzero writes for gen6 workaround. */
   drm_intel_bo *workaround_bo;
   bool need_workaround_flush;

   struct cached_batch_item *cached_items;

   uint16_t emit, total;
   uint16_t used, reserved_space;
   uint32_t *map;
   uint32_t *cpu_map;
#define BATCH_SZ (8192*sizeof(uint32_t))

   uint32_t state_batch_offset;
   bool is_blit;
   bool needs_sol_reset;
d94 166
a259 3
      uint16_t used;
      int reloc_count;
   } saved;
d262 11
a272 10
/**
 * Align a value down to an alignment value
 *
 * If \c value is not already aligned to the requested alignment value, it
 * will be rounded down.
 *
 * \param value  Value to be rounded
 * \param alignment  Alignment value to be used.  This must be a power of two.
 *
 * \sa ALIGN()
a273 1
#define ROUND_DOWN_TO(value, alignment) ((value) & ~(alignment - 1))
d275 20
a294 6
static INLINE uint32_t
U_FIXED(float value, uint32_t frac_bits)
{
   value *= (1 << frac_bits);
   return value < 0 ? 0 : value;
}
a295 5
static INLINE uint32_t
S_FIXED(float value, uint32_t frac_bits)
{
   return value * (1 << frac_bits);
}
a299 1
 * XXX Put this in src/mesa/main/imports.h ???
d302 1
a302 1
static INLINE void * __memcpy(void * to, const void * from, size_t n)
d324 26
d358 30
a387 34
#define DEBUG_BLIT	0x8
#define DEBUG_MIPTREE   0x10
#define DEBUG_PERF	0x20
#define DEBUG_BATCH     0x80
#define DEBUG_PIXEL     0x100
#define DEBUG_BUFMGR    0x200
#define DEBUG_REGION    0x400
#define DEBUG_FBO       0x800
#define DEBUG_GS        0x1000
#define DEBUG_SYNC	0x2000
#define DEBUG_PRIMS	0x4000
#define DEBUG_VERTS	0x8000
#define DEBUG_DRI       0x10000
#define DEBUG_SF        0x20000
#define DEBUG_STATS     0x100000
#define DEBUG_WM        0x400000
#define DEBUG_URB       0x800000
#define DEBUG_VS        0x1000000
#define DEBUG_CLIP      0x2000000
#define DEBUG_AUB       0x4000000
#define DEBUG_SHADER_TIME 0x8000000
#define DEBUG_BLORP     0x10000000
#define DEBUG_NO16      0x20000000

#ifdef HAVE_ANDROID_PLATFORM
#define LOG_TAG "INTEL-MESA"
#include <cutils/log.h>
#ifndef ALOGW
#define ALOGW LOGW
#endif
#define dbg_printf(...)	ALOGW(__VA_ARGS__)
#else
#define dbg_printf(...)	printf(__VA_ARGS__)
#endif /* HAVE_ANDROID_PLATFORM */
a388 31
#define DBG(...) do {						\
	if (unlikely(INTEL_DEBUG & FILE_DEBUG_FLAG))		\
		dbg_printf(__VA_ARGS__);			\
} while(0)

#define perf_debug(...) do {					\
   static GLuint msg_id = 0;                                    \
   if (unlikely(INTEL_DEBUG & DEBUG_PERF))                      \
      dbg_printf(__VA_ARGS__);                                  \
   if (brw->perf_debug)                                         \
      _mesa_gl_debug(&brw->ctx, &msg_id,                        \
                     MESA_DEBUG_TYPE_PERFORMANCE,               \
                     MESA_DEBUG_SEVERITY_MEDIUM,                \
                     __VA_ARGS__);                              \
} while(0)

#define WARN_ONCE(cond, fmt...) do {                            \
   if (unlikely(cond)) {                                        \
      static bool _warned = false;                              \
      static GLuint msg_id = 0;                                 \
      if (!_warned) {                                           \
         fprintf(stderr, "WARNING: ");                          \
         fprintf(stderr, fmt);                                  \
         _warned = true;                                        \
                                                                \
         _mesa_gl_debug(ctx, &msg_id,                           \
                        MESA_DEBUG_TYPE_OTHER,                  \
                        MESA_DEBUG_SEVERITY_HIGH, fmt);         \
      }                                                         \
   }                                                            \
} while (0)
d394 92
a485 23
extern bool intelInitContext(struct brw_context *brw,
                             int api,
                             unsigned major_version,
                             unsigned minor_version,
                             const struct gl_config * mesaVis,
                             __DRIcontext * driContextPriv,
                             void *sharedContextPrivate,
                             struct dd_function_table *functions,
                             unsigned *dri_ctx_error);

extern void intelFinish(struct gl_context * ctx);
extern void _intel_flush(struct gl_context * ctx, const char *file, int line);

#define intel_flush(ctx) _intel_flush(ctx, __FILE__, __LINE__)

extern void intelInitDriverFunctions(struct dd_function_table *functions);

void intel_init_syncobj_functions(struct dd_function_table *functions);

enum {
   DRI_CONF_BO_REUSE_DISABLED,
   DRI_CONF_BO_REUSE_ALL
};
a486 17
extern int intel_translate_shadow_compare_func(GLenum func);
extern int intel_translate_compare_func(GLenum func);
extern int intel_translate_stencil_op(GLenum op);
extern int intel_translate_logic_op(GLenum opcode);

void intel_update_renderbuffers(__DRIcontext *context,
				__DRIdrawable *drawable);
void intel_prepare_render(struct brw_context *brw);

void
intel_resolve_for_dri2_flush(struct brw_context *brw,
                             __DRIdrawable *drawable);

extern void
intelInitExtensions(struct gl_context *ctx);
extern void
intelInitClearFuncs(struct dd_function_table *functions);
d488 30
a517 2
static INLINE bool
is_power_of_two(uint32_t value)
d519 1
a519 1
   return (value & (value - 1)) == 0;
d522 3
a524 1
#ifdef __cplusplus
d526 1
a528 1
#endif
@


