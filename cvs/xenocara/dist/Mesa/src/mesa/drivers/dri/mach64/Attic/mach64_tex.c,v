head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.09.05.14.04.40;	author jsg;	state dead;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.56;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.56;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.28.47;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.39;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@/* -*- mode: c; c-basic-offset: 3 -*- */
/*
 * Copyright 2000 Gareth Hughes
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * GARETH HUGHES BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * Authors:
 *	Gareth Hughes <gareth@@valinux.com>
 *	Leif Delgass <ldelgass@@retinalburn.net>
 *	José Fonseca <j_r_fonseca@@yahoo.co.uk>
 */

#include "mach64_context.h"
#include "mach64_ioctl.h"
#include "mach64_tex.h"

#include "main/simple_list.h"
#include "main/enums.h"
#include "main/texstore.h"
#include "main/teximage.h"
#include "main/texobj.h"
#include "main/imports.h"


static void mach64SetTexWrap( mach64TexObjPtr t,
			      GLenum swrap, GLenum twrap )
{
   switch ( swrap ) {
   case GL_CLAMP:
   case GL_CLAMP_TO_EDGE:
   case GL_CLAMP_TO_BORDER:
      t->ClampS = GL_TRUE;
      break;
   case GL_REPEAT:
      t->ClampS = GL_FALSE;
      break;
   }

   switch ( twrap ) {
   case GL_CLAMP:
   case GL_CLAMP_TO_EDGE:
   case GL_CLAMP_TO_BORDER:
      t->ClampT = GL_TRUE;
      break;
   case GL_REPEAT:
      t->ClampT = GL_FALSE;
      break;
   }
}

static void mach64SetTexFilter( mach64TexObjPtr t,
				GLenum minf, GLenum magf )
{
   switch ( minf ) {
   case GL_NEAREST:
   case GL_NEAREST_MIPMAP_NEAREST:
   case GL_NEAREST_MIPMAP_LINEAR:
      t->BilinearMin = GL_FALSE;
      break;
   case GL_LINEAR:
   case GL_LINEAR_MIPMAP_NEAREST:
   case GL_LINEAR_MIPMAP_LINEAR:
      t->BilinearMin = GL_TRUE;
      break;
   }

   switch ( magf ) {
   case GL_NEAREST:
      t->BilinearMag = GL_FALSE;
      break;
   case GL_LINEAR:
      t->BilinearMag = GL_TRUE;
      break;
   }
}

static void mach64SetTexBorderColor( mach64TexObjPtr t, const GLfloat c[4] )
{
#if 0
   GLuint border = mach64PackColor( 4, c[0], c[1], c[2], c[3] );
#endif
}


static mach64TexObjPtr
mach64AllocTexObj( struct gl_texture_object *texObj )
{
   mach64TexObjPtr t;

   if ( MACH64_DEBUG & DEBUG_VERBOSE_API )
      fprintf( stderr, "%s( %p )\n", __FUNCTION__, texObj );

   t = (mach64TexObjPtr) CALLOC_STRUCT( mach64_texture_object );
   texObj->DriverData = t;
   if ( !t )
      return NULL;

   /* Initialize non-image-dependent parts of the state:
    */
   t->base.tObj = texObj;
   t->base.dirty_images[0] = (1 << 0);

   t->bufAddr = 0;

   make_empty_list( (driTextureObject *) t );

   mach64SetTexWrap( t, texObj->Sampler.WrapS, texObj->Sampler.WrapT );
   mach64SetTexFilter( t, texObj->Sampler.MinFilter, texObj->Sampler.MagFilter );
   mach64SetTexBorderColor( t, texObj->Sampler.BorderColor.f );

   return t;
}


/* Called by the _mesa_store_teximage[123]d() functions. */
static gl_format
mach64ChooseTextureFormat( struct gl_context *ctx, GLint internalFormat,
			   GLenum format, GLenum type )
{
   mach64ContextPtr mmesa = MACH64_CONTEXT(ctx);
   (void) format;
   (void) type;

   switch ( internalFormat ) {
   case GL_ALPHA:
   case GL_ALPHA4:
   case GL_ALPHA8:
   case GL_ALPHA12:
   case GL_ALPHA16:
   case GL_COMPRESSED_ALPHA:
   case 2:
   case GL_LUMINANCE_ALPHA:
   case GL_LUMINANCE4_ALPHA4:
   case GL_LUMINANCE6_ALPHA2:
   case GL_LUMINANCE8_ALPHA8:
   case GL_LUMINANCE12_ALPHA4:
   case GL_LUMINANCE12_ALPHA12:
   case GL_LUMINANCE16_ALPHA16:
   case GL_COMPRESSED_LUMINANCE_ALPHA:
   case 4:
   case GL_RGBA:
   case GL_RGBA2:
   case GL_COMPRESSED_RGBA:
      if (mmesa->mach64Screen->cpp == 4)
         return MESA_FORMAT_ARGB8888;
      else
         return MESA_FORMAT_ARGB4444;

   case GL_RGB5_A1:
      if (mmesa->mach64Screen->cpp == 4)
         return MESA_FORMAT_ARGB8888;
      else
         return MESA_FORMAT_ARGB1555;

   case GL_RGBA8:
   case GL_RGB10_A2:
   case GL_RGBA12:
   case GL_RGBA16:
   case GL_RGBA4:
      if (mmesa->mach64Screen->cpp == 4)
         return MESA_FORMAT_ARGB8888;
      else
         return MESA_FORMAT_ARGB4444;

   case 3:
   case GL_RGB:
   case GL_R3_G3_B2:
   case GL_RGB4:
   case GL_RGB5:
   case GL_RGB8:
   case GL_RGB10:
   case GL_RGB12:
   case GL_RGB16:
   case GL_COMPRESSED_RGB:
      if (mmesa->mach64Screen->cpp == 4)
         return MESA_FORMAT_ARGB8888;
      else
         return MESA_FORMAT_RGB565;

   case 1:
   case GL_LUMINANCE:
   case GL_LUMINANCE4:
   case GL_LUMINANCE8:
   case GL_LUMINANCE12:
   case GL_LUMINANCE16:
   case GL_COMPRESSED_LUMINANCE:
      if (mmesa->mach64Screen->cpp == 4)
         return MESA_FORMAT_ARGB8888; /* inefficient but accurate */
      else
         return MESA_FORMAT_ARGB1555;

   case GL_INTENSITY4:
   case GL_INTENSITY:
   case GL_INTENSITY8:
   case GL_INTENSITY12:
   case GL_INTENSITY16:
   case GL_COMPRESSED_INTENSITY:
      if (mmesa->mach64Screen->cpp == 4)
         return MESA_FORMAT_ARGB8888; /* inefficient but accurate */
      else
         return MESA_FORMAT_ARGB4444;

   case GL_COLOR_INDEX:
   case GL_COLOR_INDEX1_EXT:
   case GL_COLOR_INDEX2_EXT:
   case GL_COLOR_INDEX4_EXT:
   case GL_COLOR_INDEX8_EXT:
   case GL_COLOR_INDEX12_EXT:
   case GL_COLOR_INDEX16_EXT:
      return MESA_FORMAT_CI8;

   case GL_YCBCR_MESA:
      if (type == GL_UNSIGNED_SHORT_8_8_APPLE ||
          type == GL_UNSIGNED_BYTE)
         return MESA_FORMAT_YCBCR;
      else
         return MESA_FORMAT_YCBCR_REV;

   default:
      _mesa_problem( ctx, "unexpected format in %s", __FUNCTION__ );
      return MESA_FORMAT_NONE;
   }
}

static void mach64TexImage1D( struct gl_context *ctx, GLenum target, GLint level,
			    GLint internalFormat,
			    GLint width, GLint border,
			    GLenum format, GLenum type, const GLvoid *pixels,
			    const struct gl_pixelstore_attrib *packing,
			    struct gl_texture_object *texObj,
			    struct gl_texture_image *texImage )
{
   mach64ContextPtr mmesa = MACH64_CONTEXT(ctx);
   driTextureObject * t = (driTextureObject *) texObj->DriverData;

   if ( t ) {
      driSwapOutTextureObject( t );
   }
   else {
      t = (driTextureObject *) mach64AllocTexObj(texObj);
      if (!t) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage1D");
         return;
      }
   }

   /* Note, this will call mach64ChooseTextureFormat */
   _mesa_store_teximage1d( ctx, target, level, internalFormat,
			   width, border, format, type,
			   pixels, packing, texObj, texImage );

   mmesa->new_state |= MACH64_NEW_TEXTURE;
}

static void mach64TexSubImage1D( struct gl_context *ctx,
				 GLenum target,
				 GLint level,
				 GLint xoffset,
				 GLsizei width,
				 GLenum format, GLenum type,
				 const GLvoid *pixels,
				 const struct gl_pixelstore_attrib *packing,
				 struct gl_texture_object *texObj,
				 struct gl_texture_image *texImage )
{
   mach64ContextPtr mmesa = MACH64_CONTEXT(ctx);
   driTextureObject * t = (driTextureObject *) texObj->DriverData;

   assert( t ); /* this _should_ be true */
   if ( t ) {
      driSwapOutTextureObject( t );
   }
   else {
      t = (driTextureObject *) mach64AllocTexObj(texObj);
      if (!t) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexSubImage1D");
         return;
      }
   }

   _mesa_store_texsubimage1d(ctx, target, level, xoffset, width,
			     format, type, pixels, packing, texObj,
			     texImage);

   mmesa->new_state |= MACH64_NEW_TEXTURE;
}

static void mach64TexImage2D( struct gl_context *ctx, GLenum target, GLint level,
			      GLint internalFormat,
			      GLint width, GLint height, GLint border,
			      GLenum format, GLenum type, const GLvoid *pixels,
			      const struct gl_pixelstore_attrib *packing,
			      struct gl_texture_object *texObj,
			      struct gl_texture_image *texImage )
{
   mach64ContextPtr mmesa = MACH64_CONTEXT(ctx);
   driTextureObject * t = (driTextureObject *) texObj->DriverData;

   if ( t ) {
      driSwapOutTextureObject( t );
   }
   else {
      t = (driTextureObject *) mach64AllocTexObj(texObj);
      if (!t) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage2D");
         return;
      }
   }

   /* Note, this will call mach64ChooseTextureFormat */
   _mesa_store_teximage2d( ctx, target, level, internalFormat,
			   width, height, border, format, type, pixels,
			   &ctx->Unpack, texObj, texImage );

   mmesa->new_state |= MACH64_NEW_TEXTURE;
}

static void mach64TexSubImage2D( struct gl_context *ctx,
				 GLenum target,
				 GLint level,
				 GLint xoffset, GLint yoffset,
				 GLsizei width, GLsizei height,
				 GLenum format, GLenum type,
				 const GLvoid *pixels,
				 const struct gl_pixelstore_attrib *packing,
				 struct gl_texture_object *texObj,
				 struct gl_texture_image *texImage )
{
   mach64ContextPtr mmesa = MACH64_CONTEXT(ctx);
   driTextureObject * t = (driTextureObject *) texObj->DriverData;

   assert( t ); /* this _should_ be true */
   if ( t ) {
      driSwapOutTextureObject( t );
   }
   else {
      t = (driTextureObject *) mach64AllocTexObj(texObj);
      if (!t) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexSubImage2D");
         return;
      }
   }

   _mesa_store_texsubimage2d(ctx, target, level, xoffset, yoffset, width,
			     height, format, type, pixels, packing, texObj,
			     texImage);

   mmesa->new_state |= MACH64_NEW_TEXTURE;
}

/* ================================================================
 * Device Driver API texture functions
 */

static void mach64DDTexEnv( struct gl_context *ctx, GLenum target,
			    GLenum pname, const GLfloat *param )
{
   mach64ContextPtr mmesa = MACH64_CONTEXT(ctx);
#if 0
   struct gl_texture_unit *texUnit;
   GLubyte c[4];
#endif

   if ( MACH64_DEBUG & DEBUG_VERBOSE_API ) {
      fprintf( stderr, "%s( %s )\n",
	       __FUNCTION__, _mesa_lookup_enum_by_nr( pname ) );
   }

   switch ( pname ) {
   case GL_TEXTURE_ENV_MODE:
      FLUSH_BATCH( mmesa );
      mmesa->new_state |= MACH64_NEW_TEXTURE | MACH64_NEW_ALPHA;
      break;

#if 0
   case GL_TEXTURE_ENV_COLOR:
      texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      CLAMPED_FLOAT_TO_UBYTE( c[0], texUnit->EnvColor[0] );
      CLAMPED_FLOAT_TO_UBYTE( c[1], texUnit->EnvColor[1] );
      CLAMPED_FLOAT_TO_UBYTE( c[2], texUnit->EnvColor[2] );
      CLAMPED_FLOAT_TO_UBYTE( c[3], texUnit->EnvColor[3] );
      mmesa->env_color = mach64PackColor( 32, c[0], c[1], c[2], c[3] );
      if ( mmesa->setup.constant_color_c != mmesa->env_color ) {
	 FLUSH_BATCH( mmesa );
	 mmesa->setup.constant_color_c = mmesa->env_color;

	 mmesa->new_state |= MACH64_NEW_TEXTURE;

	 /* More complex multitexture/multipass fallbacks for GL_BLEND
	  * can be done later, but this allows a single pass GL_BLEND
	  * in some cases (ie. Performer town demo).
	  */
	 mmesa->blend_flags &= ~MACH64_BLEND_ENV_COLOR;
	 if ( mmesa->env_color != 0x00000000 &&
	      mmesa->env_color != 0xff000000 &&
	      mmesa->env_color != 0x00ffffff &&
	      mmesa->env_color != 0xffffffff )) {	
	    mmesa->blend_flags |= MACH64_BLEND_ENV_COLOR;
	 }
      }
      break;
#endif

   default:
      return;
   }
}

static void mach64DDTexParameter( struct gl_context *ctx, GLenum target,
				  struct gl_texture_object *tObj,
				  GLenum pname, const GLfloat *params )
{
   mach64ContextPtr mmesa = MACH64_CONTEXT(ctx);
   mach64TexObjPtr t = (mach64TexObjPtr)tObj->DriverData;

   if ( MACH64_DEBUG & DEBUG_VERBOSE_API ) {
      fprintf( stderr, "%s( %s )\n",
	       __FUNCTION__, _mesa_lookup_enum_by_nr( pname ) );
   }

   if ( ( target != GL_TEXTURE_2D ) &&
	( target != GL_TEXTURE_1D ) ) {
      return;
   }

   if (!t) {
      t = mach64AllocTexObj(tObj);
      if (!t) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexParameter");
         return;
      }
   }

   switch ( pname ) {
   case GL_TEXTURE_MIN_FILTER:
   case GL_TEXTURE_MAG_FILTER:
      if ( t->base.bound ) FLUSH_BATCH( mmesa );
      mach64SetTexFilter( t, tObj->Sampler.MinFilter, tObj->Sampler.MagFilter );
      break;

   case GL_TEXTURE_WRAP_S:
   case GL_TEXTURE_WRAP_T:
      if ( t->base.bound ) FLUSH_BATCH( mmesa );
      mach64SetTexWrap( t, tObj->Sampler.WrapS, tObj->Sampler.WrapT );
      break;

   case GL_TEXTURE_BORDER_COLOR:
      if ( t->base.bound ) FLUSH_BATCH( mmesa );
      mach64SetTexBorderColor( t, tObj->Sampler.BorderColor.f );
      break;

   case GL_TEXTURE_BASE_LEVEL:
      /* From Radeon/Rage128:
       * This isn't the most efficient solution but there doesn't appear to
       * be a nice alternative.  Since there's no LOD clamping,
       * we just have to rely on loading the right subset of mipmap levels
       * to simulate a clamped LOD.  
       *
       * For mach64 we're only concerned with the base level
       * since that's the only texture we upload.
       */
      if ( t->base.bound ) FLUSH_BATCH( mmesa );
      driSwapOutTextureObject( (driTextureObject *) t );
      break;

   default:
      return;
   }

   mmesa->new_state |= MACH64_NEW_TEXTURE;
}

static void mach64DDBindTexture( struct gl_context *ctx, GLenum target,
				 struct gl_texture_object *tObj )
{
   mach64ContextPtr mmesa = MACH64_CONTEXT(ctx);
   GLint unit = ctx->Texture.CurrentUnit;

   if ( MACH64_DEBUG & DEBUG_VERBOSE_API ) {
      fprintf( stderr, "%s( %p ) unit=%d\n",
	       __FUNCTION__, tObj, unit );
   }

   FLUSH_BATCH( mmesa );

   if ( mmesa->CurrentTexObj[unit] ) {
      mmesa->CurrentTexObj[unit]->base.bound &= ~(1 << unit);
      mmesa->CurrentTexObj[unit] = NULL;
   }

   mmesa->new_state |= MACH64_NEW_TEXTURE;
}

static void mach64DDDeleteTexture( struct gl_context *ctx,
				   struct gl_texture_object *tObj )
{
   mach64ContextPtr mmesa = MACH64_CONTEXT(ctx);
   driTextureObject * t = (driTextureObject *) tObj->DriverData;

   if ( t ) {
      if ( t->bound && mmesa ) {
	 FLUSH_BATCH( mmesa );

	 mmesa->new_state |= MACH64_NEW_TEXTURE;
      }

      driDestroyTextureObject( t );

      /* Free mipmap images and the texture object itself */
      _mesa_delete_texture_object(ctx, tObj);
   }
}

/**
 * Allocate a new texture object.
 * Called via ctx->Driver.NewTextureObject.
 * Note: we could use containment here to 'derive' the driver-specific
 * texture object from the core mesa gl_texture_object.  Not done at this time.
 */
static struct gl_texture_object *
mach64NewTextureObject( struct gl_context *ctx, GLuint name, GLenum target )
{
   struct gl_texture_object *obj;
   obj = _mesa_new_texture_object(ctx, name, target);
   mach64AllocTexObj( obj );
   return obj;
}

void mach64InitTextureFuncs( struct dd_function_table *functions )
{
   functions->TexEnv			= mach64DDTexEnv;
   functions->ChooseTextureFormat	= mach64ChooseTextureFormat;
   functions->TexImage1D		= mach64TexImage1D;
   functions->TexSubImage1D		= mach64TexSubImage1D;
   functions->TexImage2D		= mach64TexImage2D;
   functions->TexSubImage2D		= mach64TexSubImage2D;
   functions->TexParameter		= mach64DDTexParameter;
   functions->BindTexture		= mach64DDBindTexture;
   functions->NewTextureObject		= mach64NewTextureObject;
   functions->DeleteTexture		= mach64DDDeleteTexture;
   functions->IsTextureResident		= driIsTextureResident;

   driInitTextureFormats();
}
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.4
log
@Merge Mesa 7.10.3
@
text
@d126 3
a128 3
   mach64SetTexWrap( t, texObj->WrapS, texObj->WrapT );
   mach64SetTexFilter( t, texObj->MinFilter, texObj->MagFilter );
   mach64SetTexBorderColor( t, texObj->BorderColor.f );
d457 1
a457 1
      mach64SetTexFilter( t, tObj->MinFilter, tObj->MagFilter );
d463 1
a463 1
      mach64SetTexWrap( t, tObj->WrapS, tObj->WrapT );
d468 1
a468 1
      mach64SetTexBorderColor( t, tObj->BorderColor.f );
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d136 1
a136 1
mach64ChooseTextureFormat( GLcontext *ctx, GLint internalFormat,
d244 1
a244 1
static void mach64TexImage1D( GLcontext *ctx, GLenum target, GLint level,
d274 1
a274 1
static void mach64TexSubImage1D( GLcontext *ctx,
d307 1
a307 1
static void mach64TexImage2D( GLcontext *ctx, GLenum target, GLint level,
d337 1
a337 1
static void mach64TexSubImage2D( GLcontext *ctx,
d374 1
a374 1
static void mach64DDTexEnv( GLcontext *ctx, GLenum target,
d428 1
a428 1
static void mach64DDTexParameter( GLcontext *ctx, GLenum target,
d492 1
a492 1
static void mach64DDBindTexture( GLcontext *ctx, GLenum target,
d513 1
a513 1
static void mach64DDDeleteTexture( GLcontext *ctx,
d540 1
a540 1
mach64NewTextureObject( GLcontext *ctx, GLuint name, GLenum target )
a560 2

   functions->UpdateTexturePalette	= NULL;
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a33 3
#include "mach64_state.h"
#include "mach64_vb.h"
#include "mach64_tris.h"
a35 2
#include "main/context.h"
#include "main/macros.h"
a38 1
#include "main/texformat.h"
d96 1
a96 1
static void mach64SetTexBorderColor( mach64TexObjPtr t, GLubyte c[4] )
d128 1
a128 1
   mach64SetTexBorderColor( t, texObj->_BorderChan );
d135 1
a135 1
static const struct gl_texture_format *
d149 1
d158 1
d162 1
d164 1
a164 1
         return &_mesa_texformat_argb8888;
d166 1
a166 1
         return &_mesa_texformat_argb4444;
d170 1
a170 1
         return &_mesa_texformat_argb8888;
d172 1
a172 1
         return &_mesa_texformat_argb1555;
d180 1
a180 1
         return &_mesa_texformat_argb8888;
d182 1
a182 1
         return &_mesa_texformat_argb4444;
d193 1
d195 1
a195 1
         return &_mesa_texformat_argb8888;
d197 1
a197 1
         return &_mesa_texformat_rgb565;
d205 1
d207 1
a207 1
         return &_mesa_texformat_argb8888; /* inefficient but accurate */
d209 1
a209 1
         return &_mesa_texformat_argb1555;
d216 1
d218 1
a218 1
         return &_mesa_texformat_argb8888; /* inefficient but accurate */
d220 1
a220 1
         return &_mesa_texformat_argb4444;
d229 1
a229 1
      return &_mesa_texformat_ci8;
d234 1
a234 1
         return &_mesa_texformat_ycbcr;
d236 1
a236 1
         return &_mesa_texformat_ycbcr_rev;
d240 1
a240 1
      return NULL;
d468 1
a468 1
      mach64SetTexBorderColor( t, tObj->_BorderChan );
a562 2
   functions->ActiveTexture		= NULL;
   functions->PrioritizeTexture		= NULL;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XFree86$ */ /* -*- mode: c; c-basic-offset: 3 -*- */
d39 9
a47 9
#include "context.h"
#include "macros.h"
#include "simple_list.h"
#include "enums.h"
#include "texstore.h"
#include "texformat.h"
#include "teximage.h"
#include "texobj.h"
#include "imports.h"
d119 1
d125 2
a126 1
   t->tObj = texObj;
d128 1
a128 1
   t->offset = 0;
d130 1
a130 3
   t->dirty = 1;

   make_empty_list( t );
a132 1
   /*mach64SetTexMaxAnisotropy( t, texObj->MaxAnisotropy );*/
d253 1
a253 1
   mach64TexObjPtr t = (mach64TexObjPtr) texObj->DriverData;
d256 1
a256 1
      mach64SwapOutTexObj( mmesa, t );
d259 1
a259 1
      t = mach64AllocTexObj(texObj);
a263 1
      texObj->DriverData = t;
d286 1
a286 1
   mach64TexObjPtr t = (mach64TexObjPtr) texObj->DriverData;
d290 1
a290 1
      mach64SwapOutTexObj( mmesa, t );
d293 1
a293 1
      t = mach64AllocTexObj(texObj);
a297 1
      texObj->DriverData = t;
d316 1
a316 1
   mach64TexObjPtr t = (mach64TexObjPtr) texObj->DriverData;
d319 1
a319 1
      mach64SwapOutTexObj( mmesa, t );
d322 1
a322 1
      t = mach64AllocTexObj(texObj);
a326 1
      texObj->DriverData = t;
d349 1
a349 1
   mach64TexObjPtr t = (mach64TexObjPtr) texObj->DriverData;
d353 1
a353 1
      mach64SwapOutTexObj( mmesa, t );
d356 1
a356 1
      t = mach64AllocTexObj(texObj);
a360 1
      texObj->DriverData = t;
a369 38
/* Due to the way we must program texture state into the Rage Pro,
 * we must leave these calculations to the absolute last minute.
 */
void mach64EmitTexStateLocked( mach64ContextPtr mmesa,
			       mach64TexObjPtr t0,
			       mach64TexObjPtr t1 )
{
   drm_mach64_sarea_t *sarea = mmesa->sarea;
   drm_mach64_context_regs_t *regs = &(mmesa->setup);

   /* for multitex, both textures must be local or AGP */
   if ( t0 && t1 )
      assert(t0->heap == t1->heap);

   if ( t0 ) {
      if (t0->heap == MACH64_CARD_HEAP) {
#if ENABLE_PERF_BOXES
	 mmesa->c_texsrc_card++;
#endif
	 mmesa->setup.tex_cntl &= ~MACH64_TEX_SRC_AGP;
      } else {
#if ENABLE_PERF_BOXES
	 mmesa->c_texsrc_agp++;
#endif
	 mmesa->setup.tex_cntl |= MACH64_TEX_SRC_AGP;
      }
      mmesa->setup.tex_offset = t0->offset;
   }

   if ( t1 ) {
      mmesa->setup.secondary_tex_off = t1->offset;
   }

   memcpy( &sarea->context_state.tex_size_pitch, &regs->tex_size_pitch,
	   MACH64_NR_TEXTURE_REGS * sizeof(GLuint) );
}


a450 1
      tObj->DriverData = t;
d456 1
a456 1
      if ( t->bound ) FLUSH_BATCH( mmesa );
d462 1
a462 1
      if ( t->bound ) FLUSH_BATCH( mmesa );
d467 1
a467 1
      if ( t->bound ) FLUSH_BATCH( mmesa );
d481 2
a482 2
      if ( t->bound ) FLUSH_BATCH( mmesa );
      mach64SwapOutTexObj( mmesa, t );
d506 1
a506 1
      mmesa->CurrentTexObj[unit]->bound &= ~(unit+1);
d517 1
a517 1
   mach64TexObjPtr t = (mach64TexObjPtr)tObj->DriverData;
a522 1
	 mmesa->CurrentTexObj[t->bound-1] = 0;
d526 2
a527 2
      mach64DestroyTexObj( mmesa, t );
      tObj->DriverData = NULL;
a529 1

d533 8
a540 2
static GLboolean mach64DDIsTextureResident( GLcontext *ctx,
					    struct gl_texture_object *tObj )
d542 4
a545 3
   mach64TexObjPtr t = (mach64TexObjPtr)tObj->DriverData;

   return ( t && t->memBlock );
a547 1

a555 7
   functions->TexImage3D               = _mesa_store_teximage3d;
   functions->TexSubImage3D            = _mesa_store_texsubimage3d;
   functions->CopyTexImage1D           = _swrast_copy_teximage1d;
   functions->CopyTexImage2D           = _swrast_copy_teximage2d;
   functions->CopyTexSubImage1D        = _swrast_copy_texsubimage1d;
   functions->CopyTexSubImage2D        = _swrast_copy_texsubimage2d;
   functions->CopyTexSubImage3D        = _swrast_copy_texsubimage3d;
d558 1
d560 2
d564 3
a566 2
   functions->IsTextureResident	= mach64DDIsTextureResident;
   functions->PrioritizeTexture	= NULL;
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@a118 1
   texObj->DriverData = t;
d124 1
a124 2
   t->base.tObj = texObj;
   t->base.dirty_images[0] = (1 << 0);
d126 1
a126 1
   t->bufAddr = 0;
d128 3
a130 1
   make_empty_list( (driTextureObject *) t );
d133 1
d254 1
a254 1
   driTextureObject * t = (driTextureObject *) texObj->DriverData;
d257 1
a257 1
      driSwapOutTextureObject( t );
d260 1
a260 1
      t = (driTextureObject *) mach64AllocTexObj(texObj);
d265 1
d288 1
a288 1
   driTextureObject * t = (driTextureObject *) texObj->DriverData;
d292 1
a292 1
      driSwapOutTextureObject( t );
d295 1
a295 1
      t = (driTextureObject *) mach64AllocTexObj(texObj);
d300 1
d319 1
a319 1
   driTextureObject * t = (driTextureObject *) texObj->DriverData;
d322 1
a322 1
      driSwapOutTextureObject( t );
d325 1
a325 1
      t = (driTextureObject *) mach64AllocTexObj(texObj);
d330 1
d353 1
a353 1
   driTextureObject * t = (driTextureObject *) texObj->DriverData;
d357 1
a357 1
      driSwapOutTextureObject( t );
d360 1
a360 1
      t = (driTextureObject *) mach64AllocTexObj(texObj);
d365 1
d375 38
d494 1
d500 1
a500 1
      if ( t->base.bound ) FLUSH_BATCH( mmesa );
d506 1
a506 1
      if ( t->base.bound ) FLUSH_BATCH( mmesa );
d511 1
a511 1
      if ( t->base.bound ) FLUSH_BATCH( mmesa );
d525 2
a526 2
      if ( t->base.bound ) FLUSH_BATCH( mmesa );
      driSwapOutTextureObject( (driTextureObject *) t );
d550 1
a550 1
      mmesa->CurrentTexObj[unit]->base.bound &= ~(1 << unit);
d561 1
a561 1
   driTextureObject * t = (driTextureObject *) tObj->DriverData;
d567 1
d571 2
a572 2
      driDestroyTextureObject( t );

d575 1
d579 2
a580 8
/**
 * Allocate a new texture object.
 * Called via ctx->Driver.NewTextureObject.
 * Note: we could use containment here to 'derive' the driver-specific
 * texture object from the core mesa gl_texture_object.  Not done at this time.
 */
static struct gl_texture_object *
mach64NewTextureObject( GLcontext *ctx, GLuint name, GLenum target )
d582 3
a584 4
   struct gl_texture_object *obj;
   obj = _mesa_new_texture_object(ctx, name, target);
   mach64AllocTexObj( obj );
   return obj;
d587 1
d596 7
a604 1
   functions->NewTextureObject		= mach64NewTextureObject;
a605 2
   functions->IsTextureResident		= driIsTextureResident;

d608 2
a609 3
   functions->PrioritizeTexture		= NULL;

   driInitTextureFormats();
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d1 1
a1 1
/* -*- mode: c; c-basic-offset: 3 -*- */
d34 3
d39 9
a47 6
#include "main/simple_list.h"
#include "main/enums.h"
#include "main/texstore.h"
#include "main/teximage.h"
#include "main/texobj.h"
#include "main/imports.h"
d102 1
a102 1
static void mach64SetTexBorderColor( mach64TexObjPtr t, const GLfloat c[4] )
d134 1
a134 1
   mach64SetTexBorderColor( t, texObj->BorderColor.f );
d141 2
a142 2
static gl_format
mach64ChooseTextureFormat( struct gl_context *ctx, GLint internalFormat,
a154 1
   case GL_COMPRESSED_ALPHA:
a162 1
   case GL_COMPRESSED_LUMINANCE_ALPHA:
a165 1
   case GL_COMPRESSED_RGBA:
d167 1
a167 1
         return MESA_FORMAT_ARGB8888;
d169 1
a169 1
         return MESA_FORMAT_ARGB4444;
d173 1
a173 1
         return MESA_FORMAT_ARGB8888;
d175 1
a175 1
         return MESA_FORMAT_ARGB1555;
d183 1
a183 1
         return MESA_FORMAT_ARGB8888;
d185 1
a185 1
         return MESA_FORMAT_ARGB4444;
a195 1
   case GL_COMPRESSED_RGB:
d197 1
a197 1
         return MESA_FORMAT_ARGB8888;
d199 1
a199 1
         return MESA_FORMAT_RGB565;
a206 1
   case GL_COMPRESSED_LUMINANCE:
d208 1
a208 1
         return MESA_FORMAT_ARGB8888; /* inefficient but accurate */
d210 1
a210 1
         return MESA_FORMAT_ARGB1555;
a216 1
   case GL_COMPRESSED_INTENSITY:
d218 1
a218 1
         return MESA_FORMAT_ARGB8888; /* inefficient but accurate */
d220 1
a220 1
         return MESA_FORMAT_ARGB4444;
d229 1
a229 1
      return MESA_FORMAT_CI8;
d234 1
a234 1
         return MESA_FORMAT_YCBCR;
d236 1
a236 1
         return MESA_FORMAT_YCBCR_REV;
d240 1
a240 1
      return MESA_FORMAT_NONE;
d244 1
a244 1
static void mach64TexImage1D( struct gl_context *ctx, GLenum target, GLint level,
d274 1
a274 1
static void mach64TexSubImage1D( struct gl_context *ctx,
d307 1
a307 1
static void mach64TexImage2D( struct gl_context *ctx, GLenum target, GLint level,
d337 1
a337 1
static void mach64TexSubImage2D( struct gl_context *ctx,
d374 1
a374 1
static void mach64DDTexEnv( struct gl_context *ctx, GLenum target,
d428 1
a428 1
static void mach64DDTexParameter( struct gl_context *ctx, GLenum target,
d468 1
a468 1
      mach64SetTexBorderColor( t, tObj->BorderColor.f );
d492 1
a492 1
static void mach64DDBindTexture( struct gl_context *ctx, GLenum target,
d513 1
a513 1
static void mach64DDDeleteTexture( struct gl_context *ctx,
d540 1
a540 1
mach64NewTextureObject( struct gl_context *ctx, GLuint name, GLenum target )
d561 4
@


