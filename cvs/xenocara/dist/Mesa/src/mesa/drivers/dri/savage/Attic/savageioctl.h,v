head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.09.05.14.05.37;	author jsg;	state dead;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.18;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.53.51;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.53.51;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.42;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@/*
 * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
 * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sub license,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */


#ifndef SAVAGE_IOCTL_H
#define SAVAGE_IOCTL_H

#include "savagecontext.h"

void savageFlushVertices( savageContextPtr mmesa ); 

unsigned int savageEmitEventLocked( savageContextPtr imesa, unsigned int flags );
unsigned int savageEmitEvent( savageContextPtr imesa, unsigned int flags );
void savageWaitEvent( savageContextPtr imesa, unsigned int event);

void savageFlushCmdBufLocked( savageContextPtr imesa, GLboolean discard );
void savageFlushCmdBuf( savageContextPtr imesa, GLboolean discard );

void savageDDInitIoctlFuncs( struct gl_context *ctx );

void savageSwapBuffers( __DRIdrawable *dPriv );

#define WAIT_IDLE_EMPTY(imesa) do { \
    if (SAVAGE_DEBUG & DEBUG_VERBOSE_MSG) \
        fprintf (stderr, "WAIT_IDLE_EMPTY in %s\n", __FUNCTION__); \
    savageWaitEvent(imesa, \
		    savageEmitEvent(imesa, SAVAGE_WAIT_2D|SAVAGE_WAIT_3D)); \
} while (0)

#define WAIT_IDLE_EMPTY_LOCKED(imesa) do { \
    if (SAVAGE_DEBUG & DEBUG_VERBOSE_MSG) \
        fprintf (stderr, "WAIT_IDLE_EMPTY_LOCKED in %s\n", __FUNCTION__); \
    savageWaitEvent(imesa, savageEmitEventLocked( \
			imesa, SAVAGE_WAIT_2D|SAVAGE_WAIT_3D)); \
} while (0)

#define FLUSH_BATCH(imesa) do { \
    if (SAVAGE_DEBUG & DEBUG_VERBOSE_MSG) \
        fprintf (stderr, "FLUSH_BATCH in %s\n", __FUNCTION__); \
    savageFlushVertices(imesa); \
    savageFlushCmdBuf(imesa, GL_FALSE); \
} while (0)

extern void savageGetDMABuffer( savageContextPtr imesa );

static INLINE
void savageReleaseIndexedVerts( savageContextPtr imesa )
{
    imesa->firstElt = -1;
}

static INLINE
GLboolean savageHaveIndexedVerts( savageContextPtr imesa )
{
    return (imesa->firstElt != -1);
}

static INLINE
uint32_t *savageAllocVtxBuf( savageContextPtr imesa, GLuint words )
{
   struct savage_vtxbuf_t *buffer = imesa->vtxBuf;
   uint32_t *head;

   if (buffer == &imesa->dmaVtxBuf) {
       if (!buffer->total) {
	   LOCK_HARDWARE(imesa);
	   savageGetDMABuffer(imesa);
	   UNLOCK_HARDWARE(imesa);
       } else if (buffer->used + words > buffer->total) {
	   if (SAVAGE_DEBUG & DEBUG_VERBOSE_MSG)
	       fprintf (stderr, "... flushing DMA buffer in %s\n",
			__FUNCTION__);
	   savageReleaseIndexedVerts(imesa);
	   savageFlushVertices(imesa);
	   LOCK_HARDWARE(imesa);
	   savageFlushCmdBufLocked(imesa, GL_TRUE); /* discard DMA buffer */
	   savageGetDMABuffer(imesa);
	   UNLOCK_HARDWARE(imesa);
       }
   } else if (buffer->used + words > buffer->total) {
       if (SAVAGE_DEBUG & DEBUG_VERBOSE_MSG)
	   fprintf (stderr, "... flushing client vertex buffer in %s\n",
		    __FUNCTION__);
       savageReleaseIndexedVerts(imesa);
       savageFlushVertices(imesa);
       LOCK_HARDWARE(imesa);
       savageFlushCmdBufLocked(imesa, GL_FALSE); /* free clientVtxBuf */
       UNLOCK_HARDWARE(imesa);
   }

   head = &buffer->buf[buffer->used];

   buffer->used += words;
   return head;
}

static INLINE
uint32_t *savageAllocIndexedVerts( savageContextPtr imesa, GLuint n )
{
    uint32_t *ret;
    savageFlushVertices(imesa);
    ret = savageAllocVtxBuf(imesa, n*imesa->HwVertexSize);
    imesa->firstElt = imesa->vtxBuf->flushed / imesa->HwVertexSize;
    imesa->vtxBuf->flushed = imesa->vtxBuf->used;
    return ret;
}

/* Flush Elts:
 * - Complete the drawing command with the correct number of indices.
 * - Actually allocate entries for the indices in the command buffer.
 *   (This allocation must succeed without wrapping the cmd buffer!)
 */
static INLINE
void savageFlushElts( savageContextPtr imesa )
{
    if (imesa->elts.cmd) {
	GLuint qwords = (imesa->elts.n + 3) >> 2;
	assert(imesa->cmdBuf.write - imesa->cmdBuf.base + qwords
	       <= imesa->cmdBuf.size);
	imesa->cmdBuf.write += qwords;

	imesa->elts.cmd->idx.count = imesa->elts.n;
	imesa->elts.cmd = NULL;
    }
}

/* Allocate a command buffer entry with <bytes> bytes of arguments:
 * - implies savageFlushElts
 */
static INLINE
drm_savage_cmd_header_t *savageAllocCmdBuf( savageContextPtr imesa, GLuint bytes )
{
    drm_savage_cmd_header_t *ret;
    GLuint qwords = ((bytes + 7) >> 3) + 1; /* round up */
    assert (qwords < imesa->cmdBuf.size);

    savageFlushElts(imesa);

    if (imesa->cmdBuf.write - imesa->cmdBuf.base + qwords > imesa->cmdBuf.size)
	savageFlushCmdBuf(imesa, GL_FALSE);

    ret = (drm_savage_cmd_header_t *)imesa->cmdBuf.write;
    imesa->cmdBuf.write += qwords;
    return ret;
}

/* Allocate Elts:
 * - if it doesn't fit, flush the cmd buffer first
 * - allocates the drawing command on the cmd buffer if there is no
 *   incomplete indexed drawing command yet
 * - increments the number of elts. Final allocation is done in savageFlushElts
 */
static INLINE
uint16_t *savageAllocElts( savageContextPtr imesa, GLuint n )
{
    uint16_t *ret;
    GLuint qwords;
    assert (savageHaveIndexedVerts(imesa));

    if (imesa->elts.cmd)
	qwords = (imesa->elts.n + n + 3) >> 2;
    else
	qwords = ((n + 3) >> 2) + 1;
    if (imesa->cmdBuf.write - imesa->cmdBuf.base + qwords > imesa->cmdBuf.size)
	savageFlushCmdBuf(imesa, GL_FALSE); /* implies savageFlushElts */

    if (!imesa->elts.cmd) {
	savageFlushVertices(imesa);
	imesa->elts.cmd = savageAllocCmdBuf(imesa, 0);
	imesa->elts.cmd->idx.cmd = (imesa->vtxBuf == &imesa->dmaVtxBuf) ?
	    SAVAGE_CMD_DMA_IDX : SAVAGE_CMD_VB_IDX;
	imesa->elts.cmd->idx.prim = imesa->HwPrim;
	imesa->elts.cmd->idx.skip = imesa->skip;
	imesa->elts.n = 0;
    }

    ret = (uint16_t *)(imesa->elts.cmd+1) + imesa->elts.n;
    imesa->elts.n += n;
    return ret;
}

#endif
@


1.5
log
@Merge Mesa 7.10.3
@
text
@@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d40 1
a40 1
void savageDDInitIoctlFuncs( GLcontext *ctx );
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d42 1
a42 1
void savageSwapBuffers( __DRIdrawablePrivate *dPriv );
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d80 1
a80 1
u_int32_t *savageAllocVtxBuf( savageContextPtr imesa, GLuint words )
d83 1
a83 1
   u_int32_t *head;
d119 1
a119 1
u_int32_t *savageAllocIndexedVerts( savageContextPtr imesa, GLuint n )
d121 1
a121 1
    u_int32_t *ret;
d175 1
a175 1
u_int16_t *savageAllocElts( savageContextPtr imesa, GLuint n )
d177 1
a177 1
    u_int16_t *ret;
d198 1
a198 1
    ret = (u_int16_t *)(imesa->elts.cmd+1) + imesa->elts.n;
@


1.1
log
@Initial revision
@
text
@d67 1
a67 1
static __inline
d73 1
a73 1
static __inline
d79 1
a79 1
static __inline
d118 1
a118 1
static __inline
d134 1
a134 1
static __inline
d151 1
a151 1
static __inline
d174 1
a174 1
static __inline
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d40 1
a40 1
void savageDDInitIoctlFuncs( struct gl_context *ctx );
d42 1
a42 1
void savageSwapBuffers( __DRIdrawable *dPriv );
d67 1
a67 1
static INLINE
d73 1
a73 1
static INLINE
d79 2
a80 2
static INLINE
uint32_t *savageAllocVtxBuf( savageContextPtr imesa, GLuint words )
d83 1
a83 1
   uint32_t *head;
d118 2
a119 2
static INLINE
uint32_t *savageAllocIndexedVerts( savageContextPtr imesa, GLuint n )
d121 1
a121 1
    uint32_t *ret;
d134 1
a134 1
static INLINE
d151 1
a151 1
static INLINE
d174 2
a175 2
static INLINE
uint16_t *savageAllocElts( savageContextPtr imesa, GLuint n )
d177 1
a177 1
    uint16_t *ret;
d198 1
a198 1
    ret = (uint16_t *)(imesa->elts.cmd+1) + imesa->elts.n;
@

