head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.04.50;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.22;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.39;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.55;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.54;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright (C) 2009-2010 Francisco Jerez.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include <stdbool.h>
#include "main/state.h"
#include "nouveau_driver.h"
#include "nouveau_context.h"
#include "nouveau_fbo.h"
#include "nouveau_util.h"
#include "nv_object.xml.h"
#include "nv10_3d.xml.h"
#include "nv04_driver.h"
#include "nv10_driver.h"

static GLboolean
use_fast_zclear(struct gl_context *ctx, GLbitfield buffers)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct gl_framebuffer *fb = ctx->DrawBuffer;

	if (buffers & BUFFER_BIT_STENCIL) {
		/*
		 * The stencil test is bypassed when fast Z clears are
		 * enabled.
		 */
		nctx->hierz.clear_blocked = GL_TRUE;
		context_dirty(ctx, ZCLEAR);
		return GL_FALSE;
	}

	return !nctx->hierz.clear_blocked &&
		fb->_Xmax == fb->Width && fb->_Xmin == 0 &&
		fb->_Ymax == fb->Height && fb->_Ymin == 0;
}

GLboolean
nv10_use_viewport_zclear(struct gl_context *ctx)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct gl_framebuffer *fb = ctx->DrawBuffer;
	struct gl_renderbuffer *depthRb = fb->Attachment[BUFFER_DEPTH].Renderbuffer;

	return context_eng3d(ctx)->oclass < NV17_3D_CLASS &&
		!nctx->hierz.clear_blocked && depthRb &&
		(_mesa_get_format_bits(depthRb->Format,
				       GL_DEPTH_BITS) >= 24);
}

float
nv10_transform_depth(struct gl_context *ctx, float z)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);

	if (nv10_use_viewport_zclear(ctx))
		return 2097152.0 * (z + (nctx->hierz.clear_seq & 7));
	else
		return ctx->DrawBuffer->_DepthMaxF * z;
}

static void
nv10_zclear(struct gl_context *ctx, GLbitfield *buffers)
{
	/*
	 * Pre-nv17 cards don't have native support for fast Z clears,
	 * but in some cases we can still "clear" the Z buffer without
	 * actually blitting to it if we're willing to sacrifice a few
	 * bits of depth precision.
	 *
	 * Each time a clear is requested we modify the viewport
	 * transform in such a way that the old contents of the depth
	 * buffer are clamped to the requested clear value when
	 * they're read by the GPU.
	 */
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct gl_framebuffer *fb = ctx->DrawBuffer;
	struct nouveau_framebuffer *nfb = to_nouveau_framebuffer(fb);
	struct nouveau_surface *s = &to_nouveau_renderbuffer(
		fb->Attachment[BUFFER_DEPTH].Renderbuffer)->surface;

	if (nv10_use_viewport_zclear(ctx)) {
		int x, y, w, h;
		float z = ctx->Depth.Clear;
		uint32_t value = pack_zs_f(s->format, z, 0);

		get_scissors(fb, &x, &y, &w, &h);
		*buffers &= ~BUFFER_BIT_DEPTH;

		if (use_fast_zclear(ctx, *buffers)) {
			if (nfb->hierz.clear_value != value) {
				/* Don't fast clear if we're changing
				 * the depth value. */
				nfb->hierz.clear_value = value;

			} else if (z == 0.0) {
				nctx->hierz.clear_seq++;
				context_dirty(ctx, ZCLEAR);

				if ((nctx->hierz.clear_seq & 7) != 0 &&
				    nctx->hierz.clear_seq != 1)
					/* We didn't wrap around -- no need to
					 * clear the depth buffer for real. */
					return;

			} else if (z == 1.0) {
				nctx->hierz.clear_seq--;
				context_dirty(ctx, ZCLEAR);

				if ((nctx->hierz.clear_seq & 7) != 7)
					/* No wrap around */
					return;
			}
		}

		value = pack_zs_f(s->format,
				  (z + (nctx->hierz.clear_seq & 7)) / 8, 0);
		context_drv(ctx)->surface_fill(ctx, s, ~0, value, x, y, w, h);
	}
}

static void
nv17_zclear(struct gl_context *ctx, GLbitfield *buffers)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct nouveau_pushbuf *push = context_push(ctx);
	struct nouveau_framebuffer *nfb = to_nouveau_framebuffer(
		ctx->DrawBuffer);
	struct nouveau_surface *s = &to_nouveau_renderbuffer(
		nfb->base.Attachment[BUFFER_DEPTH].Renderbuffer)->surface;

	/* Clear the hierarchical depth buffer */
	BEGIN_NV04(push, NV17_3D(HIERZ_FILL_VALUE), 1);
	PUSH_DATA (push, pack_zs_f(s->format, ctx->Depth.Clear, 0));
	BEGIN_NV04(push, NV17_3D(HIERZ_BUFFER_CLEAR), 1);
	PUSH_DATA (push, 1);

	/* Mark the depth buffer as cleared */
	if (use_fast_zclear(ctx, *buffers)) {
		if (nctx->hierz.clear_seq)
			*buffers &= ~BUFFER_BIT_DEPTH;

		nfb->hierz.clear_value =
			pack_zs_f(s->format, ctx->Depth.Clear, 0);
		nctx->hierz.clear_seq++;

		context_dirty(ctx, ZCLEAR);
	}
}

static void
nv10_clear(struct gl_context *ctx, GLbitfield buffers)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct nouveau_pushbuf *push = context_push(ctx);

	nouveau_validate_framebuffer(ctx);

	nouveau_pushbuf_bufctx(push, nctx->hw.bufctx);
	if (nouveau_pushbuf_validate(push)) {
		nouveau_pushbuf_bufctx(push, NULL);
		return;
	}

	if ((buffers & BUFFER_BIT_DEPTH) && ctx->Depth.Mask) {
		if (context_eng3d(ctx)->oclass >= NV17_3D_CLASS)
			nv17_zclear(ctx, &buffers);
		else
			nv10_zclear(ctx, &buffers);

		/* Emit the zclear state if it's dirty */
		_mesa_update_state(ctx);
	}

	nouveau_pushbuf_bufctx(push, NULL);
	nouveau_clear(ctx, buffers);
}

static void
nv10_hwctx_init(struct gl_context *ctx)
{
	struct nouveau_pushbuf *push = context_push(ctx);
	struct nouveau_hw_state *hw = &to_nouveau_context(ctx)->hw;
	struct nv04_fifo *fifo = hw->chan->data;
	int i;

	BEGIN_NV04(push, NV01_SUBC(3D, OBJECT), 1);
	PUSH_DATA (push, hw->eng3d->handle);
	BEGIN_NV04(push, NV10_3D(DMA_NOTIFY), 1);
	PUSH_DATA (push, hw->ntfy->handle);

	BEGIN_NV04(push, NV10_3D(DMA_TEXTURE0), 3);
	PUSH_DATA (push, fifo->vram);
	PUSH_DATA (push, fifo->gart);
	PUSH_DATA (push, fifo->gart);
	BEGIN_NV04(push, NV10_3D(DMA_COLOR), 2);
	PUSH_DATA (push, fifo->vram);
	PUSH_DATA (push, fifo->vram);

	BEGIN_NV04(push, NV04_GRAPH(3D, NOP), 1);
	PUSH_DATA (push, 0);

	BEGIN_NV04(push, NV10_3D(RT_HORIZ), 2);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);

	BEGIN_NV04(push, NV10_3D(VIEWPORT_CLIP_HORIZ(0)), 1);
	PUSH_DATA (push, 0x7ff << 16 | 0x800);
	BEGIN_NV04(push, NV10_3D(VIEWPORT_CLIP_VERT(0)), 1);
	PUSH_DATA (push, 0x7ff << 16 | 0x800);

	for (i = 1; i < 8; i++) {
		BEGIN_NV04(push, NV10_3D(VIEWPORT_CLIP_HORIZ(i)), 1);
		PUSH_DATA (push, 0);
		BEGIN_NV04(push, NV10_3D(VIEWPORT_CLIP_VERT(i)), 1);
		PUSH_DATA (push, 0);
	}

	BEGIN_NV04(push, SUBC_3D(0x290), 1);
	PUSH_DATA (push, 0x10 << 16 | 1);
	BEGIN_NV04(push, SUBC_3D(0x3f4), 1);
	PUSH_DATA (push, 0);

	BEGIN_NV04(push, NV04_GRAPH(3D, NOP), 1);
	PUSH_DATA (push, 0);

	if (context_eng3d(ctx)->oclass >= NV17_3D_CLASS) {
		BEGIN_NV04(push, NV17_3D(UNK01AC), 2);
		PUSH_DATA (push, fifo->vram);
		PUSH_DATA (push, fifo->vram);

		BEGIN_NV04(push, SUBC_3D(0xd84), 1);
		PUSH_DATA (push, 0x3);

		BEGIN_NV04(push, NV17_3D(COLOR_MASK_ENABLE), 1);
		PUSH_DATA (push, 1);
	}

	if (context_eng3d(ctx)->oclass >= NV15_3D_CLASS) {
		BEGIN_NV04(push, SUBC_3D(0x120), 3);
		PUSH_DATA (push, 0);
		PUSH_DATA (push, 1);
		PUSH_DATA (push, 2);

		BEGIN_NV04(push, NV04_GRAPH(3D, NOP), 1);
		PUSH_DATA (push, 0);
	}

	BEGIN_NV04(push, NV04_GRAPH(3D, NOP), 1);
	PUSH_DATA (push, 0);

	/* Set state */
	BEGIN_NV04(push, NV10_3D(FOG_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(ALPHA_FUNC_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(ALPHA_FUNC_FUNC), 2);
	PUSH_DATA (push, 0x207);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(TEX_ENABLE(0)), 2);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);

	BEGIN_NV04(push, NV10_3D(BLEND_FUNC_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(DITHER_ENABLE), 2);
	PUSH_DATA (push, 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(LINE_SMOOTH_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(VERTEX_WEIGHT_ENABLE), 2);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(BLEND_FUNC_SRC), 4);
	PUSH_DATA (push, 1);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0x8006);
	BEGIN_NV04(push, NV10_3D(STENCIL_MASK), 8);
	PUSH_DATA (push, 0xff);
	PUSH_DATA (push, 0x207);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0xff);
	PUSH_DATA (push, 0x1e00);
	PUSH_DATA (push, 0x1e00);
	PUSH_DATA (push, 0x1e00);
	PUSH_DATA (push, 0x1d01);
	BEGIN_NV04(push, NV10_3D(NORMALIZE_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(FOG_ENABLE), 2);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(LIGHT_MODEL), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(SEPARATE_SPECULAR_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(ENABLED_LIGHTS), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(POLYGON_OFFSET_POINT_ENABLE), 3);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(DEPTH_FUNC), 1);
	PUSH_DATA (push, 0x201);
	BEGIN_NV04(push, NV10_3D(DEPTH_WRITE_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(DEPTH_TEST_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(POLYGON_OFFSET_FACTOR), 2);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(POINT_SIZE), 1);
	PUSH_DATA (push, 8);
	BEGIN_NV04(push, NV10_3D(POINT_PARAMETERS_ENABLE), 2);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(LINE_WIDTH), 1);
	PUSH_DATA (push, 8);
	BEGIN_NV04(push, NV10_3D(LINE_SMOOTH_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(POLYGON_MODE_FRONT), 2);
	PUSH_DATA (push, 0x1b02);
	PUSH_DATA (push, 0x1b02);
	BEGIN_NV04(push, NV10_3D(CULL_FACE), 2);
	PUSH_DATA (push, 0x405);
	PUSH_DATA (push, 0x901);
	BEGIN_NV04(push, NV10_3D(POLYGON_SMOOTH_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(CULL_FACE_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(TEX_GEN_MODE(0, 0)), 8);
	for (i = 0; i < 8; i++)
		PUSH_DATA (push, 0);

	BEGIN_NV04(push, NV10_3D(TEX_MATRIX_ENABLE(0)), 2);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(FOG_COEFF(0)), 3);
	PUSH_DATA (push, 0x3fc00000);	/* -1.50 */
	PUSH_DATA (push, 0xbdb8aa0a);	/* -0.09 */
	PUSH_DATA (push, 0);		/*  0.00 */

	BEGIN_NV04(push, NV04_GRAPH(3D, NOP), 1);
	PUSH_DATA (push, 0);

	BEGIN_NV04(push, NV10_3D(FOG_MODE), 2);
	PUSH_DATA (push, 0x802);
	PUSH_DATA (push, 2);
	/* for some reason VIEW_MATRIX_ENABLE need to be 6 instead of 4 when
	 * using texturing, except when using the texture matrix
	 */
	BEGIN_NV04(push, NV10_3D(VIEW_MATRIX_ENABLE), 1);
	PUSH_DATA (push, 6);
	BEGIN_NV04(push, NV10_3D(COLOR_MASK), 1);
	PUSH_DATA (push, 0x01010101);

	/* Set vertex component */
	BEGIN_NV04(push, NV10_3D(VERTEX_COL_4F_R), 4);
	PUSH_DATAf(push, 1.0);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 1.0);
	BEGIN_NV04(push, NV10_3D(VERTEX_COL2_3F_R), 3);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(VERTEX_NOR_3F_X), 3);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	PUSH_DATAf(push, 1.0);
	BEGIN_NV04(push, NV10_3D(VERTEX_TX0_4F_S), 4);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 1.0);
	BEGIN_NV04(push, NV10_3D(VERTEX_TX1_4F_S), 4);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 1.0);
	BEGIN_NV04(push, NV10_3D(VERTEX_FOG_1F), 1);
	PUSH_DATAf(push, 0.0);
	BEGIN_NV04(push, NV10_3D(EDGEFLAG_ENABLE), 1);
	PUSH_DATA (push, 1);

	BEGIN_NV04(push, NV10_3D(DEPTH_RANGE_NEAR), 2);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 16777216.0);

	PUSH_KICK (push);
}

static void
nv10_context_destroy(struct gl_context *ctx)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);

	nv04_surface_takedown(ctx);
	nv10_swtnl_destroy(ctx);
	nv10_vbo_destroy(ctx);

	nouveau_object_del(&nctx->hw.eng3d);

	nouveau_context_deinit(ctx);
	free(ctx);
}

static struct gl_context *
nv10_context_create(struct nouveau_screen *screen, gl_api api,
		    const struct gl_config *visual,
		    struct gl_context *share_ctx)
{
	struct nouveau_context *nctx;
	struct gl_context *ctx;
	unsigned celsius_class;
	int ret;

	nctx = CALLOC_STRUCT(nouveau_context);
	if (!nctx)
		return NULL;

	ctx = &nctx->base;

	if (!nouveau_context_init(ctx, api, screen, visual, share_ctx))
		goto fail;

	ctx->Extensions.ARB_texture_env_crossbar = true;
	ctx->Extensions.ARB_texture_env_combine = true;
	ctx->Extensions.ARB_texture_env_dot3 = true;
	ctx->Extensions.NV_fog_distance = true;
	ctx->Extensions.NV_texture_rectangle = true;
	if (ctx->Mesa_DXTn) {
		ctx->Extensions.EXT_texture_compression_s3tc = true;
		ctx->Extensions.ANGLE_texture_compression_dxt = true;
	}

	/* GL constants. */
	ctx->Const.MaxTextureLevels = 12;
	ctx->Const.MaxTextureCoordUnits = NV10_TEXTURE_UNITS;
	ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits = NV10_TEXTURE_UNITS;
	ctx->Const.MaxTextureUnits = NV10_TEXTURE_UNITS;
	ctx->Const.MaxTextureMaxAnisotropy = 2;
	ctx->Const.MaxTextureLodBias = 15;
	ctx->Driver.Clear = nv10_clear;

	/* 2D engine. */
	ret = nv04_surface_init(ctx);
	if (!ret)
		goto fail;

	/* 3D engine. */
	if (context_chipset(ctx) >= 0x17 && context_chipset(ctx) != 0x1a)
		celsius_class = NV17_3D_CLASS;
	else if (context_chipset(ctx) >= 0x11)
		celsius_class = NV15_3D_CLASS;
	else
		celsius_class = NV10_3D_CLASS;

	ret = nouveau_object_new(context_chan(ctx), 0xbeef0001, celsius_class,
				 NULL, 0, &nctx->hw.eng3d);
	if (ret)
		goto fail;

	nv10_hwctx_init(ctx);
	nv10_vbo_init(ctx);
	nv10_swtnl_init(ctx);

	return ctx;

fail:
	nv10_context_destroy(ctx);
	return NULL;
}

const struct nouveau_driver nv10_driver = {
	.context_create = nv10_context_create,
	.context_destroy = nv10_context_destroy,
	.surface_copy = nv04_surface_copy,
	.surface_fill = nv04_surface_fill,
	.emit = (nouveau_state_func[]) {
		nv10_emit_alpha_func,
		nv10_emit_blend_color,
		nv10_emit_blend_equation,
		nv10_emit_blend_func,
		nv10_emit_clip_plane,
		nv10_emit_clip_plane,
		nv10_emit_clip_plane,
		nv10_emit_clip_plane,
		nv10_emit_clip_plane,
		nv10_emit_clip_plane,
		nv10_emit_color_mask,
		nv10_emit_color_material,
		nv10_emit_cull_face,
		nv10_emit_front_face,
		nv10_emit_depth,
		nv10_emit_dither,
		nv10_emit_frag,
		nv10_emit_framebuffer,
		nv10_emit_fog,
		nv10_emit_light_enable,
		nv10_emit_light_model,
		nv10_emit_light_source,
		nv10_emit_light_source,
		nv10_emit_light_source,
		nv10_emit_light_source,
		nv10_emit_light_source,
		nv10_emit_light_source,
		nv10_emit_light_source,
		nv10_emit_light_source,
		nv10_emit_line_stipple,
		nv10_emit_line_mode,
		nv10_emit_logic_opcode,
		nv10_emit_material_ambient,
		nouveau_emit_nothing,
		nv10_emit_material_diffuse,
		nouveau_emit_nothing,
		nv10_emit_material_specular,
		nouveau_emit_nothing,
		nv10_emit_material_shininess,
		nouveau_emit_nothing,
		nv10_emit_modelview,
		nv10_emit_point_mode,
		nv10_emit_point_parameter,
		nv10_emit_polygon_mode,
		nv10_emit_polygon_offset,
		nv10_emit_polygon_stipple,
		nv10_emit_projection,
		nv10_emit_render_mode,
		nv10_emit_scissor,
		nv10_emit_shade_model,
		nv10_emit_stencil_func,
		nv10_emit_stencil_mask,
		nv10_emit_stencil_op,
		nv10_emit_tex_env,
		nv10_emit_tex_env,
		nouveau_emit_nothing,
		nouveau_emit_nothing,
		nv10_emit_tex_gen,
		nv10_emit_tex_gen,
		nouveau_emit_nothing,
		nouveau_emit_nothing,
		nv10_emit_tex_mat,
		nv10_emit_tex_mat,
		nouveau_emit_nothing,
		nouveau_emit_nothing,
		nv10_emit_tex_obj,
		nv10_emit_tex_obj,
		nouveau_emit_nothing,
		nouveau_emit_nothing,
		nv10_emit_viewport,
		nv10_emit_zclear
	},
	.num_emit = NUM_NV10_STATE,
};
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d66 1
a66 1
	return context_chipset(ctx) < 0x17 &&
d187 1
a187 1
		if (context_chipset(ctx) >= 0x17)
d248 1
a248 1
	if (context_chipset(ctx) >= 0x17) {
d260 1
a260 1
	if (context_chipset(ctx) >= 0x11) {
d430 2
a431 1
nv10_context_create(struct nouveau_screen *screen, const struct gl_config *visual,
d445 1
a445 1
	if (!nouveau_context_init(ctx, screen, visual, share_ctx))
d461 1
a461 1
	ctx->Const.FragmentProgram.MaxTextureImageUnits = NV10_TEXTURE_UNITS;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d27 1
a37 8
static const struct dri_extension nv10_extensions[] = {
	{ "GL_ARB_texture_env_crossbar", NULL },
	{ "GL_EXT_texture_rectangle",	NULL },
	{ "GL_ARB_texture_env_combine", NULL },
	{ "GL_ARB_texture_env_dot3",    NULL },
	{ NULL,				NULL }
};

d64 1
d67 2
a68 2
		!nctx->hierz.clear_blocked && fb->_DepthBuffer &&
		(_mesa_get_format_bits(fb->_DepthBuffer->Format,
d101 1
a101 1
		fb->_DepthBuffer->Wrapped)->surface;
d147 1
a147 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *celsius = context_eng3d(ctx);
d151 1
a151 1
		nfb->base._DepthBuffer->Wrapped)->surface;
d154 4
a157 4
	BEGIN_RING(chan, celsius, NV17_3D_HIERZ_FILL_VALUE, 1);
	OUT_RING(chan, pack_zs_f(s->format, ctx->Depth.Clear, 0));
	BEGIN_RING(chan, celsius, NV17_3D_HIERZ_BUFFER_CLEAR, 1);
	OUT_RING(chan, 1);
d175 3
d180 6
d196 1
d203 1
a203 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *celsius = context_eng3d(ctx);
d205 1
d208 24
a231 22
	BEGIN_RING(chan, celsius, NV10_3D_DMA_NOTIFY, 1);
	OUT_RING(chan, hw->ntfy->handle);

	BEGIN_RING(chan, celsius, NV10_3D_DMA_TEXTURE0, 3);
	OUT_RING(chan, chan->vram->handle);
	OUT_RING(chan, chan->gart->handle);
	OUT_RING(chan, chan->gart->handle);
	BEGIN_RING(chan, celsius, NV10_3D_DMA_COLOR, 2);
	OUT_RING(chan, chan->vram->handle);
	OUT_RING(chan, chan->vram->handle);

	BEGIN_RING(chan, celsius, NV04_GRAPH_NOP, 1);
	OUT_RING(chan, 0);

	BEGIN_RING(chan, celsius, NV10_3D_RT_HORIZ, 2);
	OUT_RING(chan, 0);
	OUT_RING(chan, 0);

	BEGIN_RING(chan, celsius, NV10_3D_VIEWPORT_CLIP_HORIZ(0), 1);
	OUT_RING(chan, 0x7ff << 16 | 0x800);
	BEGIN_RING(chan, celsius, NV10_3D_VIEWPORT_CLIP_VERT(0), 1);
	OUT_RING(chan, 0x7ff << 16 | 0x800);
d234 4
a237 4
		BEGIN_RING(chan, celsius, NV10_3D_VIEWPORT_CLIP_HORIZ(i), 1);
		OUT_RING(chan, 0);
		BEGIN_RING(chan, celsius, NV10_3D_VIEWPORT_CLIP_VERT(i), 1);
		OUT_RING(chan, 0);
d240 4
a243 4
	BEGIN_RING(chan, celsius, 0x290, 1);
	OUT_RING(chan, 0x10 << 16 | 1);
	BEGIN_RING(chan, celsius, 0x3f4, 1);
	OUT_RING(chan, 0);
d245 2
a246 2
	BEGIN_RING(chan, celsius,  NV04_GRAPH_NOP, 1);
	OUT_RING(chan, 0);
d249 3
a251 3
		BEGIN_RING(chan, celsius, NV17_3D_UNK01AC, 2);
		OUT_RING(chan, chan->vram->handle);
		OUT_RING(chan, chan->vram->handle);
d253 2
a254 2
		BEGIN_RING(chan, celsius, 0xd84, 1);
		OUT_RING(chan, 0x3);
d256 2
a257 2
		BEGIN_RING(chan, celsius, NV17_3D_COLOR_MASK_ENABLE, 1);
		OUT_RING(chan, 1);
d261 4
a264 4
		BEGIN_RING(chan, celsius, 0x120, 3);
		OUT_RING(chan, 0);
		OUT_RING(chan, 1);
		OUT_RING(chan, 2);
d266 2
a267 2
		BEGIN_RING(chan, celsius, NV04_GRAPH_NOP, 1);
		OUT_RING(chan, 0);
d270 2
a271 2
	BEGIN_RING(chan, celsius,  NV04_GRAPH_NOP, 1);
	OUT_RING(chan, 0);
d274 79
a352 79
	BEGIN_RING(chan, celsius, NV10_3D_FOG_ENABLE, 1);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_ALPHA_FUNC_ENABLE, 1);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_ALPHA_FUNC_FUNC, 2);
	OUT_RING(chan, 0x207);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_TEX_ENABLE(0), 2);
	OUT_RING(chan, 0);
	OUT_RING(chan, 0);

	BEGIN_RING(chan, celsius, NV10_3D_BLEND_FUNC_ENABLE, 1);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_DITHER_ENABLE, 2);
	OUT_RING(chan, 1);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_LINE_SMOOTH_ENABLE, 1);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_VERTEX_WEIGHT_ENABLE, 2);
	OUT_RING(chan, 0);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_BLEND_FUNC_SRC, 4);
	OUT_RING(chan, 1);
	OUT_RING(chan, 0);
	OUT_RING(chan, 0);
	OUT_RING(chan, 0x8006);
	BEGIN_RING(chan, celsius, NV10_3D_STENCIL_MASK, 8);
	OUT_RING(chan, 0xff);
	OUT_RING(chan, 0x207);
	OUT_RING(chan, 0);
	OUT_RING(chan, 0xff);
	OUT_RING(chan, 0x1e00);
	OUT_RING(chan, 0x1e00);
	OUT_RING(chan, 0x1e00);
	OUT_RING(chan, 0x1d01);
	BEGIN_RING(chan, celsius, NV10_3D_NORMALIZE_ENABLE, 1);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_FOG_ENABLE, 2);
	OUT_RING(chan, 0);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_LIGHT_MODEL, 1);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_SEPARATE_SPECULAR_ENABLE, 1);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_ENABLED_LIGHTS, 1);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_POLYGON_OFFSET_POINT_ENABLE, 3);
	OUT_RING(chan, 0);
	OUT_RING(chan, 0);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_DEPTH_FUNC, 1);
	OUT_RING(chan, 0x201);
	BEGIN_RING(chan, celsius, NV10_3D_DEPTH_WRITE_ENABLE, 1);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_DEPTH_TEST_ENABLE, 1);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_POLYGON_OFFSET_FACTOR, 2);
	OUT_RING(chan, 0);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_POINT_SIZE, 1);
	OUT_RING(chan, 8);
	BEGIN_RING(chan, celsius, NV10_3D_POINT_PARAMETERS_ENABLE, 2);
	OUT_RING(chan, 0);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_LINE_WIDTH, 1);
	OUT_RING(chan, 8);
	BEGIN_RING(chan, celsius, NV10_3D_LINE_SMOOTH_ENABLE, 1);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_POLYGON_MODE_FRONT, 2);
	OUT_RING(chan, 0x1b02);
	OUT_RING(chan, 0x1b02);
	BEGIN_RING(chan, celsius, NV10_3D_CULL_FACE, 2);
	OUT_RING(chan, 0x405);
	OUT_RING(chan, 0x901);
	BEGIN_RING(chan, celsius, NV10_3D_POLYGON_SMOOTH_ENABLE, 1);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_CULL_FACE_ENABLE, 1);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_TEX_GEN_MODE(0, 0), 8);
d354 1
a354 1
		OUT_RING(chan, 0);
d356 14
a369 14
	BEGIN_RING(chan, celsius, NV10_3D_TEX_MATRIX_ENABLE(0), 2);
	OUT_RING(chan, 0);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_FOG_COEFF(0), 3);
	OUT_RING(chan, 0x3fc00000);	/* -1.50 */
	OUT_RING(chan, 0xbdb8aa0a);	/* -0.09 */
	OUT_RING(chan, 0);		/*  0.00 */

	BEGIN_RING(chan, celsius,  NV04_GRAPH_NOP, 1);
	OUT_RING(chan, 0);

	BEGIN_RING(chan, celsius, NV10_3D_FOG_MODE, 2);
	OUT_RING(chan, 0x802);
	OUT_RING(chan, 2);
d373 4
a376 4
	BEGIN_RING(chan, celsius, NV10_3D_VIEW_MATRIX_ENABLE, 1);
	OUT_RING(chan, 6);
	BEGIN_RING(chan, celsius, NV10_3D_COLOR_MASK, 1);
	OUT_RING(chan, 0x01010101);
d379 31
a409 31
	BEGIN_RING(chan, celsius, NV10_3D_VERTEX_COL_4F_R, 4);
	OUT_RINGf(chan, 1.0);
	OUT_RINGf(chan, 0.0);
	OUT_RINGf(chan, 0.0);
	OUT_RINGf(chan, 1.0);
	BEGIN_RING(chan, celsius, NV10_3D_VERTEX_COL2_3F_R, 3);
	OUT_RING(chan, 0);
	OUT_RING(chan, 0);
	OUT_RING(chan, 0);
	BEGIN_RING(chan, celsius, NV10_3D_VERTEX_NOR_3F_X, 3);
	OUT_RING(chan, 0);
	OUT_RING(chan, 0);
	OUT_RINGf(chan, 1.0);
	BEGIN_RING(chan, celsius, NV10_3D_VERTEX_TX0_4F_S, 4);
	OUT_RINGf(chan, 0.0);
	OUT_RINGf(chan, 0.0);
	OUT_RINGf(chan, 0.0);
	OUT_RINGf(chan, 1.0);
	BEGIN_RING(chan, celsius, NV10_3D_VERTEX_TX1_4F_S, 4);
	OUT_RINGf(chan, 0.0);
	OUT_RINGf(chan, 0.0);
	OUT_RINGf(chan, 0.0);
	OUT_RINGf(chan, 1.0);
	BEGIN_RING(chan, celsius, NV10_3D_VERTEX_FOG_1F, 1);
	OUT_RINGf(chan, 0.0);
	BEGIN_RING(chan, celsius, NV10_3D_EDGEFLAG_ENABLE, 1);
	OUT_RING(chan, 1);

	BEGIN_RING(chan, celsius, NV10_3D_DEPTH_RANGE_NEAR, 2);
	OUT_RINGf(chan, 0.0);
	OUT_RINGf(chan, 16777216.0);
d411 1
a411 1
	FIRE_RING(chan);
d423 1
a423 1
	nouveau_grobj_free(&nctx->hw.eng3d);
d426 1
a426 1
	FREE(ctx);
d447 9
a455 1
	driInitExtensions(ctx, nv10_extensions, GL_FALSE);
d460 1
a460 1
	ctx->Const.MaxTextureImageUnits = NV10_TEXTURE_UNITS;
d472 2
a473 2
	if (context_chipset(ctx) >= 0x17)
		celsius_class = NV17_3D;
d475 1
a475 1
		celsius_class = NV11_3D;
d477 1
a477 1
		celsius_class = NV10_3D;
d479 2
a480 2
	ret = nouveau_grobj_alloc(context_chan(ctx), 0xbeef0001, celsius_class,
				  &nctx->hw.eng3d);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d27 1
d32 2
a33 1
#include "nouveau_class.h"
d38 1
d40 2
d45 44
d90 1
a90 1
nv10_clear(GLcontext *ctx, GLbitfield buffers)
d92 61
d157 8
d166 16
d184 8
a191 10
	/* Clear the LMA depth buffer, if present. */
	if ((buffers & BUFFER_BIT_DEPTH) && ctx->Depth.Mask &&
	    nfb->lma_bo) {
		struct nouveau_surface *s = &to_nouveau_renderbuffer(
			nfb->base._DepthBuffer->Wrapped)->surface;

		BEGIN_RING(chan, celsius, NV17TCL_LMA_DEPTH_FILL_VALUE, 1);
		OUT_RING(chan, pack_zs_f(s->format, ctx->Depth.Clear, 0));
		BEGIN_RING(chan, celsius, NV17TCL_LMA_DEPTH_BUFFER_CLEAR, 1);
		OUT_RING(chan, 1);
d198 1
a198 1
nv10_hwctx_init(GLcontext *ctx)
d205 1
a205 1
	BEGIN_RING(chan, celsius, NV10TCL_DMA_NOTIFY, 1);
d208 1
a208 1
	BEGIN_RING(chan, celsius, NV10TCL_DMA_IN_MEMORY0, 3);
d212 1
a212 1
	BEGIN_RING(chan, celsius, NV10TCL_DMA_IN_MEMORY2, 2);
d216 1
a216 1
	BEGIN_RING(chan, celsius, NV10TCL_NOP, 1);
d219 1
a219 1
	BEGIN_RING(chan, celsius, NV10TCL_RT_HORIZ, 2);
d223 1
a223 1
	BEGIN_RING(chan, celsius, NV10TCL_VIEWPORT_CLIP_HORIZ(0), 1);
d225 1
a225 1
	BEGIN_RING(chan, celsius, NV10TCL_VIEWPORT_CLIP_VERT(0), 1);
d229 1
a229 1
		BEGIN_RING(chan, celsius, NV10TCL_VIEWPORT_CLIP_HORIZ(i), 1);
d231 1
a231 1
		BEGIN_RING(chan, celsius, NV10TCL_VIEWPORT_CLIP_VERT(i), 1);
d240 1
a240 1
	BEGIN_RING(chan, celsius, NV10TCL_NOP, 1);
d244 1
a244 1
		BEGIN_RING(chan, celsius, NV17TCL_DMA_IN_MEMORY4, 2);
d251 1
a251 1
		BEGIN_RING(chan, celsius, NV17TCL_COLOR_MASK_ENABLE, 1);
d261 1
a261 1
		BEGIN_RING(chan, celsius, NV10TCL_NOP, 1);
d265 1
a265 1
	BEGIN_RING(chan, celsius, NV10TCL_NOP, 1);
d269 1
a269 1
	BEGIN_RING(chan, celsius, NV10TCL_FOG_ENABLE, 1);
d271 1
a271 1
	BEGIN_RING(chan, celsius, NV10TCL_ALPHA_FUNC_ENABLE, 1);
d273 1
a273 1
	BEGIN_RING(chan, celsius, NV10TCL_ALPHA_FUNC_FUNC, 2);
d276 1
a276 1
	BEGIN_RING(chan, celsius, NV10TCL_TX_ENABLE(0), 2);
d280 1
a280 1
	BEGIN_RING(chan, celsius, NV10TCL_BLEND_FUNC_ENABLE, 1);
d282 1
a282 1
	BEGIN_RING(chan, celsius, NV10TCL_DITHER_ENABLE, 2);
d285 1
a285 1
	BEGIN_RING(chan, celsius, NV10TCL_LINE_SMOOTH_ENABLE, 1);
d287 1
a287 1
	BEGIN_RING(chan, celsius, NV10TCL_VERTEX_WEIGHT_ENABLE, 2);
d290 1
a290 1
	BEGIN_RING(chan, celsius, NV10TCL_BLEND_FUNC_SRC, 4);
d295 1
a295 1
	BEGIN_RING(chan, celsius, NV10TCL_STENCIL_MASK, 8);
d304 1
a304 1
	BEGIN_RING(chan, celsius, NV10TCL_NORMALIZE_ENABLE, 1);
d306 1
a306 1
	BEGIN_RING(chan, celsius, NV10TCL_FOG_ENABLE, 2);
d309 1
a309 1
	BEGIN_RING(chan, celsius, NV10TCL_LIGHT_MODEL, 1);
d311 1
a311 1
	BEGIN_RING(chan, celsius, NV10TCL_SEPARATE_SPECULAR_ENABLE, 1);
d313 1
a313 1
	BEGIN_RING(chan, celsius, NV10TCL_ENABLED_LIGHTS, 1);
d315 1
a315 1
	BEGIN_RING(chan, celsius, NV10TCL_POLYGON_OFFSET_POINT_ENABLE, 3);
d319 1
a319 1
	BEGIN_RING(chan, celsius, NV10TCL_DEPTH_FUNC, 1);
d321 1
a321 1
	BEGIN_RING(chan, celsius, NV10TCL_DEPTH_WRITE_ENABLE, 1);
d323 1
a323 1
	BEGIN_RING(chan, celsius, NV10TCL_DEPTH_TEST_ENABLE, 1);
d325 1
a325 1
	BEGIN_RING(chan, celsius, NV10TCL_POLYGON_OFFSET_FACTOR, 2);
d328 1
a328 1
	BEGIN_RING(chan, celsius, NV10TCL_POINT_SIZE, 1);
d330 1
a330 1
	BEGIN_RING(chan, celsius, NV10TCL_POINT_PARAMETERS_ENABLE, 2);
d333 1
a333 1
	BEGIN_RING(chan, celsius, NV10TCL_LINE_WIDTH, 1);
d335 1
a335 1
	BEGIN_RING(chan, celsius, NV10TCL_LINE_SMOOTH_ENABLE, 1);
d337 1
a337 1
	BEGIN_RING(chan, celsius, NV10TCL_POLYGON_MODE_FRONT, 2);
d340 1
a340 1
	BEGIN_RING(chan, celsius, NV10TCL_CULL_FACE, 2);
d343 1
a343 1
	BEGIN_RING(chan, celsius, NV10TCL_POLYGON_SMOOTH_ENABLE, 1);
d345 1
a345 1
	BEGIN_RING(chan, celsius, NV10TCL_CULL_FACE_ENABLE, 1);
d347 1
a347 1
	BEGIN_RING(chan, celsius, NV10TCL_TX_GEN_S(0), 8);
d351 1
a351 1
	BEGIN_RING(chan, celsius, NV10TCL_TX_MATRIX_ENABLE(0), 2);
d354 1
a354 1
	BEGIN_RING(chan, celsius, NV10TCL_FOG_EQUATION_CONSTANT, 3);
d359 1
a359 1
	BEGIN_RING(chan, celsius, NV10TCL_NOP, 1);
d362 1
a362 1
	BEGIN_RING(chan, celsius, NV10TCL_FOG_MODE, 2);
d368 1
a368 1
	BEGIN_RING(chan, celsius, NV10TCL_VIEW_MATRIX_ENABLE, 1);
d370 1
a370 1
	BEGIN_RING(chan, celsius, NV10TCL_COLOR_MASK, 1);
d374 1
a374 1
	BEGIN_RING(chan, celsius, NV10TCL_VERTEX_COL_4F_R, 4);
d379 1
a379 1
	BEGIN_RING(chan, celsius, NV10TCL_VERTEX_COL2_3F_R, 3);
d383 1
a383 1
	BEGIN_RING(chan, celsius, NV10TCL_VERTEX_NOR_3F_X, 3);
d387 1
a387 1
	BEGIN_RING(chan, celsius, NV10TCL_VERTEX_TX0_4F_S, 4);
d392 1
a392 1
	BEGIN_RING(chan, celsius, NV10TCL_VERTEX_TX1_4F_S, 4);
d397 1
a397 1
	BEGIN_RING(chan, celsius, NV10TCL_VERTEX_FOG_1F, 1);
d399 1
a399 1
	BEGIN_RING(chan, celsius, NV10TCL_EDGEFLAG_ENABLE, 1);
d402 2
a403 2
	BEGIN_RING(chan, celsius, NV10TCL_DEPTH_RANGE_NEAR, 2);
	OUT_RING(chan, 0.0);
d410 1
a410 1
nv10_context_destroy(GLcontext *ctx)
d415 2
a416 1
	nv10_render_destroy(ctx);
d424 3
a426 3
static GLcontext *
nv10_context_create(struct nouveau_screen *screen, const GLvisual *visual,
		    GLcontext *share_ctx)
d429 1
a429 1
	GLcontext *ctx;
d460 1
a460 1
		celsius_class = NV17TCL;
d462 1
a462 1
		celsius_class = NV11TCL;
d464 1
a464 1
		celsius_class = NV10TCL;
d472 2
a473 1
	nv10_render_init(ctx);
d549 4
d557 2
a558 1
		nv10_emit_viewport
d560 1
a560 1
	.num_emit = NUM_NOUVEAU_STATE,
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a26 1
#include "main/state.h"
d31 1
a31 2
#include "nv_object.xml.h"
#include "nv10_3d.xml.h"
a35 1
	{ "GL_ARB_texture_env_crossbar", NULL },
a36 2
	{ "GL_ARB_texture_env_combine", NULL },
	{ "GL_ARB_texture_env_dot3",    NULL },
a39 44
static GLboolean
use_fast_zclear(struct gl_context *ctx, GLbitfield buffers)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct gl_framebuffer *fb = ctx->DrawBuffer;

	if (buffers & BUFFER_BIT_STENCIL) {
		/*
		 * The stencil test is bypassed when fast Z clears are
		 * enabled.
		 */
		nctx->hierz.clear_blocked = GL_TRUE;
		context_dirty(ctx, ZCLEAR);
		return GL_FALSE;
	}

	return !nctx->hierz.clear_blocked &&
		fb->_Xmax == fb->Width && fb->_Xmin == 0 &&
		fb->_Ymax == fb->Height && fb->_Ymin == 0;
}

GLboolean
nv10_use_viewport_zclear(struct gl_context *ctx)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct gl_framebuffer *fb = ctx->DrawBuffer;

	return context_chipset(ctx) < 0x17 &&
		!nctx->hierz.clear_blocked && fb->_DepthBuffer &&
		(_mesa_get_format_bits(fb->_DepthBuffer->Format,
				       GL_DEPTH_BITS) >= 24);
}

float
nv10_transform_depth(struct gl_context *ctx, float z)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);

	if (nv10_use_viewport_zclear(ctx))
		return 2097152.0 * (z + (nctx->hierz.clear_seq & 7));
	else
		return ctx->DrawBuffer->_DepthMaxF * z;
}

d41 1
a41 1
nv10_zclear(struct gl_context *ctx, GLbitfield *buffers)
a42 61
	/*
	 * Pre-nv17 cards don't have native support for fast Z clears,
	 * but in some cases we can still "clear" the Z buffer without
	 * actually blitting to it if we're willing to sacrifice a few
	 * bits of depth precision.
	 *
	 * Each time a clear is requested we modify the viewport
	 * transform in such a way that the old contents of the depth
	 * buffer are clamped to the requested clear value when
	 * they're read by the GPU.
	 */
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct gl_framebuffer *fb = ctx->DrawBuffer;
	struct nouveau_framebuffer *nfb = to_nouveau_framebuffer(fb);
	struct nouveau_surface *s = &to_nouveau_renderbuffer(
		fb->_DepthBuffer->Wrapped)->surface;

	if (nv10_use_viewport_zclear(ctx)) {
		int x, y, w, h;
		float z = ctx->Depth.Clear;
		uint32_t value = pack_zs_f(s->format, z, 0);

		get_scissors(fb, &x, &y, &w, &h);
		*buffers &= ~BUFFER_BIT_DEPTH;

		if (use_fast_zclear(ctx, *buffers)) {
			if (nfb->hierz.clear_value != value) {
				/* Don't fast clear if we're changing
				 * the depth value. */
				nfb->hierz.clear_value = value;

			} else if (z == 0.0) {
				nctx->hierz.clear_seq++;
				context_dirty(ctx, ZCLEAR);

				if ((nctx->hierz.clear_seq & 7) != 0 &&
				    nctx->hierz.clear_seq != 1)
					/* We didn't wrap around -- no need to
					 * clear the depth buffer for real. */
					return;

			} else if (z == 1.0) {
				nctx->hierz.clear_seq--;
				context_dirty(ctx, ZCLEAR);

				if ((nctx->hierz.clear_seq & 7) != 7)
					/* No wrap around */
					return;
			}
		}

		value = pack_zs_f(s->format,
				  (z + (nctx->hierz.clear_seq & 7)) / 8, 0);
		context_drv(ctx)->surface_fill(ctx, s, ~0, value, x, y, w, h);
	}
}

static void
nv17_zclear(struct gl_context *ctx, GLbitfield *buffers)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);
a46 8
	struct nouveau_surface *s = &to_nouveau_renderbuffer(
		nfb->base._DepthBuffer->Wrapped)->surface;

	/* Clear the hierarchical depth buffer */
	BEGIN_RING(chan, celsius, NV17_3D_HIERZ_FILL_VALUE, 1);
	OUT_RING(chan, pack_zs_f(s->format, ctx->Depth.Clear, 0));
	BEGIN_RING(chan, celsius, NV17_3D_HIERZ_BUFFER_CLEAR, 1);
	OUT_RING(chan, 1);
a47 16
	/* Mark the depth buffer as cleared */
	if (use_fast_zclear(ctx, *buffers)) {
		if (nctx->hierz.clear_seq)
			*buffers &= ~BUFFER_BIT_DEPTH;

		nfb->hierz.clear_value =
			pack_zs_f(s->format, ctx->Depth.Clear, 0);
		nctx->hierz.clear_seq++;

		context_dirty(ctx, ZCLEAR);
	}
}

static void
nv10_clear(struct gl_context *ctx, GLbitfield buffers)
{
d50 10
a59 8
	if ((buffers & BUFFER_BIT_DEPTH) && ctx->Depth.Mask) {
		if (context_chipset(ctx) >= 0x17)
			nv17_zclear(ctx, &buffers);
		else
			nv10_zclear(ctx, &buffers);

		/* Emit the zclear state if it's dirty */
		_mesa_update_state(ctx);
d66 1
a66 1
nv10_hwctx_init(struct gl_context *ctx)
d73 1
a73 1
	BEGIN_RING(chan, celsius, NV10_3D_DMA_NOTIFY, 1);
d76 1
a76 1
	BEGIN_RING(chan, celsius, NV10_3D_DMA_TEXTURE0, 3);
d80 1
a80 1
	BEGIN_RING(chan, celsius, NV10_3D_DMA_COLOR, 2);
d84 1
a84 1
	BEGIN_RING(chan, celsius, NV04_GRAPH_NOP, 1);
d87 1
a87 1
	BEGIN_RING(chan, celsius, NV10_3D_RT_HORIZ, 2);
d91 1
a91 1
	BEGIN_RING(chan, celsius, NV10_3D_VIEWPORT_CLIP_HORIZ(0), 1);
d93 1
a93 1
	BEGIN_RING(chan, celsius, NV10_3D_VIEWPORT_CLIP_VERT(0), 1);
d97 1
a97 1
		BEGIN_RING(chan, celsius, NV10_3D_VIEWPORT_CLIP_HORIZ(i), 1);
d99 1
a99 1
		BEGIN_RING(chan, celsius, NV10_3D_VIEWPORT_CLIP_VERT(i), 1);
d108 1
a108 1
	BEGIN_RING(chan, celsius,  NV04_GRAPH_NOP, 1);
d112 1
a112 1
		BEGIN_RING(chan, celsius, NV17_3D_UNK01AC, 2);
d119 1
a119 1
		BEGIN_RING(chan, celsius, NV17_3D_COLOR_MASK_ENABLE, 1);
d129 1
a129 1
		BEGIN_RING(chan, celsius, NV04_GRAPH_NOP, 1);
d133 1
a133 1
	BEGIN_RING(chan, celsius,  NV04_GRAPH_NOP, 1);
d137 1
a137 1
	BEGIN_RING(chan, celsius, NV10_3D_FOG_ENABLE, 1);
d139 1
a139 1
	BEGIN_RING(chan, celsius, NV10_3D_ALPHA_FUNC_ENABLE, 1);
d141 1
a141 1
	BEGIN_RING(chan, celsius, NV10_3D_ALPHA_FUNC_FUNC, 2);
d144 1
a144 1
	BEGIN_RING(chan, celsius, NV10_3D_TEX_ENABLE(0), 2);
d148 1
a148 1
	BEGIN_RING(chan, celsius, NV10_3D_BLEND_FUNC_ENABLE, 1);
d150 1
a150 1
	BEGIN_RING(chan, celsius, NV10_3D_DITHER_ENABLE, 2);
d153 1
a153 1
	BEGIN_RING(chan, celsius, NV10_3D_LINE_SMOOTH_ENABLE, 1);
d155 1
a155 1
	BEGIN_RING(chan, celsius, NV10_3D_VERTEX_WEIGHT_ENABLE, 2);
d158 1
a158 1
	BEGIN_RING(chan, celsius, NV10_3D_BLEND_FUNC_SRC, 4);
d163 1
a163 1
	BEGIN_RING(chan, celsius, NV10_3D_STENCIL_MASK, 8);
d172 1
a172 1
	BEGIN_RING(chan, celsius, NV10_3D_NORMALIZE_ENABLE, 1);
d174 1
a174 1
	BEGIN_RING(chan, celsius, NV10_3D_FOG_ENABLE, 2);
d177 1
a177 1
	BEGIN_RING(chan, celsius, NV10_3D_LIGHT_MODEL, 1);
d179 1
a179 1
	BEGIN_RING(chan, celsius, NV10_3D_SEPARATE_SPECULAR_ENABLE, 1);
d181 1
a181 1
	BEGIN_RING(chan, celsius, NV10_3D_ENABLED_LIGHTS, 1);
d183 1
a183 1
	BEGIN_RING(chan, celsius, NV10_3D_POLYGON_OFFSET_POINT_ENABLE, 3);
d187 1
a187 1
	BEGIN_RING(chan, celsius, NV10_3D_DEPTH_FUNC, 1);
d189 1
a189 1
	BEGIN_RING(chan, celsius, NV10_3D_DEPTH_WRITE_ENABLE, 1);
d191 1
a191 1
	BEGIN_RING(chan, celsius, NV10_3D_DEPTH_TEST_ENABLE, 1);
d193 1
a193 1
	BEGIN_RING(chan, celsius, NV10_3D_POLYGON_OFFSET_FACTOR, 2);
d196 1
a196 1
	BEGIN_RING(chan, celsius, NV10_3D_POINT_SIZE, 1);
d198 1
a198 1
	BEGIN_RING(chan, celsius, NV10_3D_POINT_PARAMETERS_ENABLE, 2);
d201 1
a201 1
	BEGIN_RING(chan, celsius, NV10_3D_LINE_WIDTH, 1);
d203 1
a203 1
	BEGIN_RING(chan, celsius, NV10_3D_LINE_SMOOTH_ENABLE, 1);
d205 1
a205 1
	BEGIN_RING(chan, celsius, NV10_3D_POLYGON_MODE_FRONT, 2);
d208 1
a208 1
	BEGIN_RING(chan, celsius, NV10_3D_CULL_FACE, 2);
d211 1
a211 1
	BEGIN_RING(chan, celsius, NV10_3D_POLYGON_SMOOTH_ENABLE, 1);
d213 1
a213 1
	BEGIN_RING(chan, celsius, NV10_3D_CULL_FACE_ENABLE, 1);
d215 1
a215 1
	BEGIN_RING(chan, celsius, NV10_3D_TEX_GEN_MODE(0, 0), 8);
d219 1
a219 1
	BEGIN_RING(chan, celsius, NV10_3D_TEX_MATRIX_ENABLE(0), 2);
d222 1
a222 1
	BEGIN_RING(chan, celsius, NV10_3D_FOG_COEFF(0), 3);
d227 1
a227 1
	BEGIN_RING(chan, celsius,  NV04_GRAPH_NOP, 1);
d230 1
a230 1
	BEGIN_RING(chan, celsius, NV10_3D_FOG_MODE, 2);
d236 1
a236 1
	BEGIN_RING(chan, celsius, NV10_3D_VIEW_MATRIX_ENABLE, 1);
d238 1
a238 1
	BEGIN_RING(chan, celsius, NV10_3D_COLOR_MASK, 1);
d242 1
a242 1
	BEGIN_RING(chan, celsius, NV10_3D_VERTEX_COL_4F_R, 4);
d247 1
a247 1
	BEGIN_RING(chan, celsius, NV10_3D_VERTEX_COL2_3F_R, 3);
d251 1
a251 1
	BEGIN_RING(chan, celsius, NV10_3D_VERTEX_NOR_3F_X, 3);
d255 1
a255 1
	BEGIN_RING(chan, celsius, NV10_3D_VERTEX_TX0_4F_S, 4);
d260 1
a260 1
	BEGIN_RING(chan, celsius, NV10_3D_VERTEX_TX1_4F_S, 4);
d265 1
a265 1
	BEGIN_RING(chan, celsius, NV10_3D_VERTEX_FOG_1F, 1);
d267 1
a267 1
	BEGIN_RING(chan, celsius, NV10_3D_EDGEFLAG_ENABLE, 1);
d270 2
a271 2
	BEGIN_RING(chan, celsius, NV10_3D_DEPTH_RANGE_NEAR, 2);
	OUT_RINGf(chan, 0.0);
d278 1
a278 1
nv10_context_destroy(struct gl_context *ctx)
d283 1
a283 2
	nv10_swtnl_destroy(ctx);
	nv10_vbo_destroy(ctx);
d291 3
a293 3
static struct gl_context *
nv10_context_create(struct nouveau_screen *screen, const struct gl_config *visual,
		    struct gl_context *share_ctx)
d296 1
a296 1
	struct gl_context *ctx;
d327 1
a327 1
		celsius_class = NV17_3D;
d329 1
a329 1
		celsius_class = NV11_3D;
d331 1
a331 1
		celsius_class = NV10_3D;
d339 1
a339 2
	nv10_vbo_init(ctx);
	nv10_swtnl_init(ctx);
a414 4
		nv10_emit_tex_mat,
		nv10_emit_tex_mat,
		nouveau_emit_nothing,
		nouveau_emit_nothing,
d419 1
a419 2
		nv10_emit_viewport,
		nv10_emit_zclear
d421 1
a421 1
	.num_emit = NUM_NV10_STATE,
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a26 1
#include <stdbool.h>
d37 8
a70 1
	struct gl_renderbuffer *depthRb = fb->Attachment[BUFFER_DEPTH].Renderbuffer;
d73 2
a74 2
		!nctx->hierz.clear_blocked && depthRb &&
		(_mesa_get_format_bits(depthRb->Format,
d107 1
a107 1
		fb->Attachment[BUFFER_DEPTH].Renderbuffer)->surface;
d153 2
a154 1
	struct nouveau_pushbuf *push = context_push(ctx);
d158 1
a158 1
		nfb->base.Attachment[BUFFER_DEPTH].Renderbuffer)->surface;
d161 4
a164 4
	BEGIN_NV04(push, NV17_3D(HIERZ_FILL_VALUE), 1);
	PUSH_DATA (push, pack_zs_f(s->format, ctx->Depth.Clear, 0));
	BEGIN_NV04(push, NV17_3D(HIERZ_BUFFER_CLEAR), 1);
	PUSH_DATA (push, 1);
a181 3
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct nouveau_pushbuf *push = context_push(ctx);

a183 6
	nouveau_pushbuf_bufctx(push, nctx->hw.bufctx);
	if (nouveau_pushbuf_validate(push)) {
		nouveau_pushbuf_bufctx(push, NULL);
		return;
	}

a193 1
	nouveau_pushbuf_bufctx(push, NULL);
d200 2
a201 1
	struct nouveau_pushbuf *push = context_push(ctx);
a202 1
	struct nv04_fifo *fifo = hw->chan->data;
d205 22
a226 24
	BEGIN_NV04(push, NV01_SUBC(3D, OBJECT), 1);
	PUSH_DATA (push, hw->eng3d->handle);
	BEGIN_NV04(push, NV10_3D(DMA_NOTIFY), 1);
	PUSH_DATA (push, hw->ntfy->handle);

	BEGIN_NV04(push, NV10_3D(DMA_TEXTURE0), 3);
	PUSH_DATA (push, fifo->vram);
	PUSH_DATA (push, fifo->gart);
	PUSH_DATA (push, fifo->gart);
	BEGIN_NV04(push, NV10_3D(DMA_COLOR), 2);
	PUSH_DATA (push, fifo->vram);
	PUSH_DATA (push, fifo->vram);

	BEGIN_NV04(push, NV04_GRAPH(3D, NOP), 1);
	PUSH_DATA (push, 0);

	BEGIN_NV04(push, NV10_3D(RT_HORIZ), 2);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);

	BEGIN_NV04(push, NV10_3D(VIEWPORT_CLIP_HORIZ(0)), 1);
	PUSH_DATA (push, 0x7ff << 16 | 0x800);
	BEGIN_NV04(push, NV10_3D(VIEWPORT_CLIP_VERT(0)), 1);
	PUSH_DATA (push, 0x7ff << 16 | 0x800);
d229 4
a232 4
		BEGIN_NV04(push, NV10_3D(VIEWPORT_CLIP_HORIZ(i)), 1);
		PUSH_DATA (push, 0);
		BEGIN_NV04(push, NV10_3D(VIEWPORT_CLIP_VERT(i)), 1);
		PUSH_DATA (push, 0);
d235 4
a238 4
	BEGIN_NV04(push, SUBC_3D(0x290), 1);
	PUSH_DATA (push, 0x10 << 16 | 1);
	BEGIN_NV04(push, SUBC_3D(0x3f4), 1);
	PUSH_DATA (push, 0);
d240 2
a241 2
	BEGIN_NV04(push, NV04_GRAPH(3D, NOP), 1);
	PUSH_DATA (push, 0);
d244 3
a246 3
		BEGIN_NV04(push, NV17_3D(UNK01AC), 2);
		PUSH_DATA (push, fifo->vram);
		PUSH_DATA (push, fifo->vram);
d248 2
a249 2
		BEGIN_NV04(push, SUBC_3D(0xd84), 1);
		PUSH_DATA (push, 0x3);
d251 2
a252 2
		BEGIN_NV04(push, NV17_3D(COLOR_MASK_ENABLE), 1);
		PUSH_DATA (push, 1);
d256 4
a259 4
		BEGIN_NV04(push, SUBC_3D(0x120), 3);
		PUSH_DATA (push, 0);
		PUSH_DATA (push, 1);
		PUSH_DATA (push, 2);
d261 2
a262 2
		BEGIN_NV04(push, NV04_GRAPH(3D, NOP), 1);
		PUSH_DATA (push, 0);
d265 2
a266 2
	BEGIN_NV04(push, NV04_GRAPH(3D, NOP), 1);
	PUSH_DATA (push, 0);
d269 79
a347 79
	BEGIN_NV04(push, NV10_3D(FOG_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(ALPHA_FUNC_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(ALPHA_FUNC_FUNC), 2);
	PUSH_DATA (push, 0x207);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(TEX_ENABLE(0)), 2);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);

	BEGIN_NV04(push, NV10_3D(BLEND_FUNC_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(DITHER_ENABLE), 2);
	PUSH_DATA (push, 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(LINE_SMOOTH_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(VERTEX_WEIGHT_ENABLE), 2);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(BLEND_FUNC_SRC), 4);
	PUSH_DATA (push, 1);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0x8006);
	BEGIN_NV04(push, NV10_3D(STENCIL_MASK), 8);
	PUSH_DATA (push, 0xff);
	PUSH_DATA (push, 0x207);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0xff);
	PUSH_DATA (push, 0x1e00);
	PUSH_DATA (push, 0x1e00);
	PUSH_DATA (push, 0x1e00);
	PUSH_DATA (push, 0x1d01);
	BEGIN_NV04(push, NV10_3D(NORMALIZE_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(FOG_ENABLE), 2);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(LIGHT_MODEL), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(SEPARATE_SPECULAR_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(ENABLED_LIGHTS), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(POLYGON_OFFSET_POINT_ENABLE), 3);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(DEPTH_FUNC), 1);
	PUSH_DATA (push, 0x201);
	BEGIN_NV04(push, NV10_3D(DEPTH_WRITE_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(DEPTH_TEST_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(POLYGON_OFFSET_FACTOR), 2);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(POINT_SIZE), 1);
	PUSH_DATA (push, 8);
	BEGIN_NV04(push, NV10_3D(POINT_PARAMETERS_ENABLE), 2);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(LINE_WIDTH), 1);
	PUSH_DATA (push, 8);
	BEGIN_NV04(push, NV10_3D(LINE_SMOOTH_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(POLYGON_MODE_FRONT), 2);
	PUSH_DATA (push, 0x1b02);
	PUSH_DATA (push, 0x1b02);
	BEGIN_NV04(push, NV10_3D(CULL_FACE), 2);
	PUSH_DATA (push, 0x405);
	PUSH_DATA (push, 0x901);
	BEGIN_NV04(push, NV10_3D(POLYGON_SMOOTH_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(CULL_FACE_ENABLE), 1);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(TEX_GEN_MODE(0, 0)), 8);
d349 1
a349 1
		PUSH_DATA (push, 0);
d351 14
a364 14
	BEGIN_NV04(push, NV10_3D(TEX_MATRIX_ENABLE(0)), 2);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(FOG_COEFF(0)), 3);
	PUSH_DATA (push, 0x3fc00000);	/* -1.50 */
	PUSH_DATA (push, 0xbdb8aa0a);	/* -0.09 */
	PUSH_DATA (push, 0);		/*  0.00 */

	BEGIN_NV04(push, NV04_GRAPH(3D, NOP), 1);
	PUSH_DATA (push, 0);

	BEGIN_NV04(push, NV10_3D(FOG_MODE), 2);
	PUSH_DATA (push, 0x802);
	PUSH_DATA (push, 2);
d368 4
a371 4
	BEGIN_NV04(push, NV10_3D(VIEW_MATRIX_ENABLE), 1);
	PUSH_DATA (push, 6);
	BEGIN_NV04(push, NV10_3D(COLOR_MASK), 1);
	PUSH_DATA (push, 0x01010101);
d374 31
a404 31
	BEGIN_NV04(push, NV10_3D(VERTEX_COL_4F_R), 4);
	PUSH_DATAf(push, 1.0);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 1.0);
	BEGIN_NV04(push, NV10_3D(VERTEX_COL2_3F_R), 3);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	BEGIN_NV04(push, NV10_3D(VERTEX_NOR_3F_X), 3);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	PUSH_DATAf(push, 1.0);
	BEGIN_NV04(push, NV10_3D(VERTEX_TX0_4F_S), 4);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 1.0);
	BEGIN_NV04(push, NV10_3D(VERTEX_TX1_4F_S), 4);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 1.0);
	BEGIN_NV04(push, NV10_3D(VERTEX_FOG_1F), 1);
	PUSH_DATAf(push, 0.0);
	BEGIN_NV04(push, NV10_3D(EDGEFLAG_ENABLE), 1);
	PUSH_DATA (push, 1);

	BEGIN_NV04(push, NV10_3D(DEPTH_RANGE_NEAR), 2);
	PUSH_DATAf(push, 0.0);
	PUSH_DATAf(push, 16777216.0);
d406 1
a406 1
	PUSH_KICK (push);
d418 1
a418 1
	nouveau_object_del(&nctx->hw.eng3d);
d421 1
a421 1
	free(ctx);
d442 1
a442 9
	ctx->Extensions.ARB_texture_env_crossbar = true;
	ctx->Extensions.ARB_texture_env_combine = true;
	ctx->Extensions.ARB_texture_env_dot3 = true;
	ctx->Extensions.NV_fog_distance = true;
	ctx->Extensions.NV_texture_rectangle = true;
	if (ctx->Mesa_DXTn) {
		ctx->Extensions.EXT_texture_compression_s3tc = true;
		ctx->Extensions.ANGLE_texture_compression_dxt = true;
	}
d447 1
a447 1
	ctx->Const.FragmentProgram.MaxTextureImageUnits = NV10_TEXTURE_UNITS;
d459 2
a460 2
	if (context_chipset(ctx) >= 0x17 && context_chipset(ctx) != 0x1a)
		celsius_class = NV17_3D_CLASS;
d462 1
a462 1
		celsius_class = NV15_3D_CLASS;
d464 1
a464 1
		celsius_class = NV10_3D_CLASS;
d466 2
a467 2
	ret = nouveau_object_new(context_chan(ctx), 0xbeef0001, celsius_class,
				 NULL, 0, &nctx->hw.eng3d);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d66 1
a66 1
	return context_eng3d(ctx)->oclass < NV17_3D_CLASS &&
d187 1
a187 1
		if (context_eng3d(ctx)->oclass >= NV17_3D_CLASS)
d248 1
a248 1
	if (context_eng3d(ctx)->oclass >= NV17_3D_CLASS) {
d260 1
a260 1
	if (context_eng3d(ctx)->oclass >= NV15_3D_CLASS) {
d430 1
a430 2
nv10_context_create(struct nouveau_screen *screen, gl_api api,
		    const struct gl_config *visual,
d444 1
a444 1
	if (!nouveau_context_init(ctx, api, screen, visual, share_ctx))
d460 1
a460 1
	ctx->Const.Program[MESA_SHADER_FRAGMENT].MaxTextureImageUnits = NV10_TEXTURE_UNITS;
@


