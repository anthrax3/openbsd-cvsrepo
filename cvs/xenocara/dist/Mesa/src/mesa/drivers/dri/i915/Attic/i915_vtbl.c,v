head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.04.13;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.22.20.04.22;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.14;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.35;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.35;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.09;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.28.14;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.15.21;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.47;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.11.23;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.48.30;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/



#include "main/glheader.h"
#include "main/mtypes.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/colormac.h"
#include "main/renderbuffer.h"
#include "main/framebuffer.h"

#include "tnl/tnl.h"
#include "tnl/t_context.h"
#include "tnl/t_vertex.h"
#include "swrast_setup/swrast_setup.h"

#include "intel_batchbuffer.h"
#include "intel_mipmap_tree.h"
#include "intel_regions.h"
#include "intel_tris.h"
#include "intel_fbo.h"
#include "intel_buffers.h"

#include "i915_reg.h"
#include "i915_context.h"

static void
i915_render_prevalidate(struct intel_context *intel)
{
   struct i915_context *i915 = i915_context(&intel->ctx);

   i915ValidateFragmentProgram(i915);
}

static void
i915_render_start(struct intel_context *intel)
{
   intel_prepare_render(intel);
}


static void
i915_reduced_primitive_state(struct intel_context *intel, GLenum rprim)
{
   struct i915_context *i915 = i915_context(&intel->ctx);
   GLuint st1 = i915->state.Stipple[I915_STPREG_ST1];

   st1 &= ~ST1_ENABLE;

   switch (rprim) {
   case GL_QUADS: /* from RASTERIZE(GL_QUADS) in t_dd_tritemp.h */
   case GL_TRIANGLES:
      if (intel->ctx.Polygon.StippleFlag && intel->hw_stipple)
         st1 |= ST1_ENABLE;
      break;
   case GL_LINES:
   case GL_POINTS:
   default:
      break;
   }

   i915->intel.reduced_primitive = rprim;

   if (st1 != i915->state.Stipple[I915_STPREG_ST1]) {
      INTEL_FIREVERTICES(intel);

      I915_STATECHANGE(i915, I915_UPLOAD_STIPPLE);
      i915->state.Stipple[I915_STPREG_ST1] = st1;
   }
}


/* Pull apart the vertex format registers and figure out how large a
 * vertex is supposed to be. 
 */
static bool
i915_check_vertex_size(struct intel_context *intel, GLuint expected)
{
   struct i915_context *i915 = i915_context(&intel->ctx);
   int lis2 = i915->state.Ctx[I915_CTXREG_LIS2];
   int lis4 = i915->state.Ctx[I915_CTXREG_LIS4];
   int i, sz = 0;

   switch (lis4 & S4_VFMT_XYZW_MASK) {
   case S4_VFMT_XY:
      sz = 2;
      break;
   case S4_VFMT_XYZ:
      sz = 3;
      break;
   case S4_VFMT_XYW:
      sz = 3;
      break;
   case S4_VFMT_XYZW:
      sz = 4;
      break;
   default:
      fprintf(stderr, "no xyzw specified\n");
      return 0;
   }

   if (lis4 & S4_VFMT_SPEC_FOG)
      sz++;
   if (lis4 & S4_VFMT_COLOR)
      sz++;
   if (lis4 & S4_VFMT_DEPTH_OFFSET)
      sz++;
   if (lis4 & S4_VFMT_POINT_WIDTH)
      sz++;
   if (lis4 & S4_VFMT_FOG_PARAM)
      sz++;

   for (i = 0; i < 8; i++) {
      switch (lis2 & S2_TEXCOORD_FMT0_MASK) {
      case TEXCOORDFMT_2D:
         sz += 2;
         break;
      case TEXCOORDFMT_3D:
         sz += 3;
         break;
      case TEXCOORDFMT_4D:
         sz += 4;
         break;
      case TEXCOORDFMT_1D:
         sz += 1;
         break;
      case TEXCOORDFMT_2D_16:
         sz += 1;
         break;
      case TEXCOORDFMT_4D_16:
         sz += 2;
         break;
      case TEXCOORDFMT_NOT_PRESENT:
         break;
      default:
         fprintf(stderr, "bad texcoord fmt %d\n", i);
         return false;
      }
      lis2 >>= S2_TEXCOORD_FMT1_SHIFT;
   }

   if (sz != expected)
      fprintf(stderr, "vertex size mismatch %d/%d\n", sz, expected);

   return sz == expected;
}


static void
i915_emit_invarient_state(struct intel_context *intel)
{
   BATCH_LOCALS;

   BEGIN_BATCH(17);

   OUT_BATCH(_3DSTATE_AA_CMD |
             AA_LINE_ECAAR_WIDTH_ENABLE |
             AA_LINE_ECAAR_WIDTH_1_0 |
             AA_LINE_REGION_WIDTH_ENABLE | AA_LINE_REGION_WIDTH_1_0);

   OUT_BATCH(_3DSTATE_DFLT_DIFFUSE_CMD);
   OUT_BATCH(0);

   OUT_BATCH(_3DSTATE_DFLT_SPEC_CMD);
   OUT_BATCH(0);

   OUT_BATCH(_3DSTATE_DFLT_Z_CMD);
   OUT_BATCH(0);

   /* Don't support texture crossbar yet */
   OUT_BATCH(_3DSTATE_COORD_SET_BINDINGS |
             CSB_TCB(0, 0) |
             CSB_TCB(1, 1) |
             CSB_TCB(2, 2) |
             CSB_TCB(3, 3) |
             CSB_TCB(4, 4) | CSB_TCB(5, 5) | CSB_TCB(6, 6) | CSB_TCB(7, 7));

   /* Need to initialize this to zero.
    */
   OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(3) | (0));
   OUT_BATCH(0);

   /* XXX: Use this */
   OUT_BATCH(_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);

   OUT_BATCH(_3DSTATE_SCISSOR_RECT_0_CMD);
   OUT_BATCH(0);
   OUT_BATCH(0);

   OUT_BATCH(_3DSTATE_DEPTH_SUBRECT_DISABLE);

   OUT_BATCH(_3DSTATE_LOAD_INDIRECT | 0);       /* disable indirect state */
   OUT_BATCH(0);

   ADVANCE_BATCH();
}


#define emit(intel, state, size )		     \
   intel_batchbuffer_data(intel, state, size)

static GLuint
get_dirty(struct i915_hw_state *state)
{
   GLuint dirty;

   /* Workaround the multitex hang - if one texture unit state is
    * modified, emit all texture units.
    */
   dirty = state->active & ~state->emitted;
   if (dirty & I915_UPLOAD_TEX_ALL)
      state->emitted &= ~I915_UPLOAD_TEX_ALL;
   dirty = state->active & ~state->emitted;
   return dirty;
}


static GLuint
get_state_size(struct i915_hw_state *state)
{
   GLuint dirty = get_dirty(state);
   GLuint i;
   GLuint sz = 0;

   if (dirty & I915_UPLOAD_INVARIENT)
      sz += 30 * 4;

   if (dirty & I915_UPLOAD_RASTER_RULES)
      sz += sizeof(state->RasterRules);

   if (dirty & I915_UPLOAD_CTX)
      sz += sizeof(state->Ctx);

   if (dirty & I915_UPLOAD_BLEND)
      sz += sizeof(state->Blend);

   if (dirty & I915_UPLOAD_BUFFERS)
      sz += sizeof(state->Buffer);

   if (dirty & I915_UPLOAD_STIPPLE)
      sz += sizeof(state->Stipple);

   if (dirty & I915_UPLOAD_TEX_ALL) {
      int nr = 0;
      for (i = 0; i < I915_TEX_UNITS; i++)
         if (dirty & I915_UPLOAD_TEX(i))
            nr++;

      sz += (2 + nr * 3) * sizeof(GLuint) * 2;
   }

   if (dirty & I915_UPLOAD_CONSTANTS)
      sz += state->ConstantSize * sizeof(GLuint);

   if (dirty & I915_UPLOAD_PROGRAM)
      sz += state->ProgramSize * sizeof(GLuint);

   return sz;
}

/* Push the state into the sarea and/or texture memory.
 */
static void
i915_emit_state(struct intel_context *intel)
{
   struct i915_context *i915 = i915_context(&intel->ctx);
   struct i915_hw_state *state = &i915->state;
   int i, count, aper_count;
   GLuint dirty;
   drm_intel_bo *aper_array[3 + I915_TEX_UNITS];
   GET_CURRENT_CONTEXT(ctx);
   BATCH_LOCALS;

   /* We don't hold the lock at this point, so want to make sure that
    * there won't be a buffer wrap between the state emits and the primitive
    * emit header.
    *
    * It might be better to talk about explicit places where
    * scheduling is allowed, rather than assume that it is whenever a
    * batchbuffer fills up.
    */
   intel_batchbuffer_require_space(intel,
				   get_state_size(state) +
                                   INTEL_PRIM_EMIT_SIZE);
   count = 0;
 again:
   if (intel->batch.bo == NULL) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "i915 emit state");
      assert(0);
   }
   aper_count = 0;
   dirty = get_dirty(state);

   aper_array[aper_count++] = intel->batch.bo;
   if (dirty & I915_UPLOAD_BUFFERS) {
      if (state->draw_region)
	 aper_array[aper_count++] = state->draw_region->bo;
      if (state->depth_region)
	 aper_array[aper_count++] = state->depth_region->bo;
   }

   if (dirty & I915_UPLOAD_TEX_ALL) {
      for (i = 0; i < I915_TEX_UNITS; i++) {
	 if (dirty & I915_UPLOAD_TEX(i)) {
	    if (state->tex_buffer[i]) {
	       aper_array[aper_count++] = state->tex_buffer[i];
	    }
	 }
      }
   }

   if (dri_bufmgr_check_aperture_space(aper_array, aper_count)) {
       if (count == 0) {
	   count++;
	   intel_batchbuffer_flush(intel);
	   goto again;
       } else {
	   _mesa_error(ctx, GL_OUT_OF_MEMORY, "i915 emit state");
	   assert(0);
       }
   }

   /* work out list of buffers to emit */
   
   /* Do this here as we may have flushed the batchbuffer above,
    * causing more state to be dirty!
    */
   dirty = get_dirty(state);
   state->emitted |= dirty;
   assert(get_dirty(state) == 0);

   if (INTEL_DEBUG & DEBUG_STATE)
      fprintf(stderr, "%s dirty: %x\n", __FUNCTION__, dirty);

   if (dirty & I915_UPLOAD_INVARIENT) {
      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_INVARIENT:\n");
      i915_emit_invarient_state(intel);
   }

   if (dirty & I915_UPLOAD_RASTER_RULES) {
      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_RASTER_RULES:\n");
      emit(intel, state->RasterRules, sizeof(state->RasterRules));
   }

   if (dirty & I915_UPLOAD_CTX) {
      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_CTX:\n");

      emit(intel, state->Ctx, sizeof(state->Ctx));
   }

   if (dirty & I915_UPLOAD_BLEND) {
      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_BLEND:\n");

      emit(intel, state->Blend, sizeof(state->Blend));
   }

   if (dirty & I915_UPLOAD_BUFFERS) {
      GLuint count;

      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_BUFFERS:\n");

      count = 17;
      if (state->Buffer[I915_DESTREG_DRAWRECT0] != MI_NOOP)
         count++;

      BEGIN_BATCH(count);
      OUT_BATCH(state->Buffer[I915_DESTREG_CBUFADDR0]);
      OUT_BATCH(state->Buffer[I915_DESTREG_CBUFADDR1]);
      if (state->draw_region) {
	 OUT_RELOC(state->draw_region->bo,
		   I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER, 0);
      } else {
	 OUT_BATCH(0);
      }

      OUT_BATCH(state->Buffer[I915_DESTREG_DBUFADDR0]);
      OUT_BATCH(state->Buffer[I915_DESTREG_DBUFADDR1]);
      if (state->depth_region) {
         OUT_RELOC(state->depth_region->bo,
		   I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER, 0);
      } else {
	 OUT_BATCH(0);
      }

      OUT_BATCH(state->Buffer[I915_DESTREG_DV0]);
      OUT_BATCH(state->Buffer[I915_DESTREG_DV1]);
      OUT_BATCH(state->Buffer[I915_DESTREG_SENABLE]);
      OUT_BATCH(state->Buffer[I915_DESTREG_SR0]);
      OUT_BATCH(state->Buffer[I915_DESTREG_SR1]);
      OUT_BATCH(state->Buffer[I915_DESTREG_SR2]);

      if (state->Buffer[I915_DESTREG_DRAWRECT0] != MI_NOOP)
         OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT0]);
      OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT1]);
      OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT2]);
      OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT3]);
      OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT4]);
      OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT5]);

      ADVANCE_BATCH();
   }

   if (dirty & I915_UPLOAD_STIPPLE) {
      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_STIPPLE:\n");
      emit(intel, state->Stipple, sizeof(state->Stipple));
   }

   /* Combine all the dirty texture state into a single command to
    * avoid lockups on I915 hardware. 
    */
   if (dirty & I915_UPLOAD_TEX_ALL) {
      int nr = 0;
      GLuint unwind;

      for (i = 0; i < I915_TEX_UNITS; i++)
         if (dirty & I915_UPLOAD_TEX(i))
            nr++;

      BEGIN_BATCH(2 + nr * 3);
      OUT_BATCH(_3DSTATE_MAP_STATE | (3 * nr));
      OUT_BATCH((dirty & I915_UPLOAD_TEX_ALL) >> I915_UPLOAD_TEX_0_SHIFT);
      for (i = 0; i < I915_TEX_UNITS; i++)
         if (dirty & I915_UPLOAD_TEX(i)) {
	    OUT_RELOC(state->tex_buffer[i],
		      I915_GEM_DOMAIN_SAMPLER, 0,
		      state->tex_offset[i]);

            OUT_BATCH(state->Tex[i][I915_TEXREG_MS3]);
            OUT_BATCH(state->Tex[i][I915_TEXREG_MS4]);
         }
      ADVANCE_BATCH();

      unwind = intel->batch.used;
      BEGIN_BATCH(2 + nr * 3);
      OUT_BATCH(_3DSTATE_SAMPLER_STATE | (3 * nr));
      OUT_BATCH((dirty & I915_UPLOAD_TEX_ALL) >> I915_UPLOAD_TEX_0_SHIFT);
      for (i = 0; i < I915_TEX_UNITS; i++)
         if (dirty & I915_UPLOAD_TEX(i)) {
            OUT_BATCH(state->Tex[i][I915_TEXREG_SS2]);
            OUT_BATCH(state->Tex[i][I915_TEXREG_SS3]);
            OUT_BATCH(state->Tex[i][I915_TEXREG_SS4]);
         }
      ADVANCE_BATCH();
      if (i915->last_sampler &&
	  memcmp(intel->batch.map + i915->last_sampler,
		 intel->batch.map + unwind,
		 (2 + nr*3)*sizeof(int)) == 0)
	  intel->batch.used = unwind;
      else
	  i915->last_sampler = unwind;
   }

   if (dirty & I915_UPLOAD_CONSTANTS) {
      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_CONSTANTS:\n");
      emit(intel, state->Constant, state->ConstantSize * sizeof(GLuint));
   }

   if (dirty & I915_UPLOAD_PROGRAM) {
      if (state->ProgramSize) {
         if (INTEL_DEBUG & DEBUG_STATE)
            fprintf(stderr, "I915_UPLOAD_PROGRAM:\n");

         assert((state->Program[0] & 0x1ff) + 2 == state->ProgramSize);

         emit(intel, state->Program, state->ProgramSize * sizeof(GLuint));
         if (INTEL_DEBUG & DEBUG_STATE)
            i915_disassemble_program(state->Program, state->ProgramSize);
      }
   }

   assert(get_dirty(state) == 0);
}

static void
i915_destroy_context(struct intel_context *intel)
{
   GLuint i;
   struct i915_context *i915 = i915_context(&intel->ctx);

   intel_region_release(&i915->state.draw_region);
   intel_region_release(&i915->state.depth_region);

   for (i = 0; i < I915_TEX_UNITS; i++) {
      if (i915->state.tex_buffer[i] != NULL) {
	 drm_intel_bo_unreference(i915->state.tex_buffer[i]);
	 i915->state.tex_buffer[i] = NULL;
      }
   }

   _tnl_free_vertices(&intel->ctx);
}

void
i915_set_buf_info_for_region(uint32_t *state, struct intel_region *region,
			     uint32_t buffer_id)
{
   state[0] = _3DSTATE_BUF_INFO_CMD;
   state[1] = buffer_id;

   if (region != NULL) {
      state[1] |= BUF_3D_PITCH(region->pitch);

      if (region->tiling != I915_TILING_NONE) {
	 state[1] |= BUF_3D_TILED_SURFACE;
	 if (region->tiling == I915_TILING_Y)
	    state[1] |= BUF_3D_TILE_WALK_Y;
      }
   } else {
      /* Fill in a default pitch, since 0 is invalid.  We'll be
       * setting the buffer offset to 0 and not referencing the
       * buffer, so the pitch could really be any valid value.
       */
      state[1] |= BUF_3D_PITCH(4096);
   }
}

static uint32_t i915_render_target_format_for_mesa_format[MESA_FORMAT_COUNT] =
{
   [MESA_FORMAT_B8G8R8A8_UNORM] = DV_PF_8888,
   [MESA_FORMAT_B8G8R8X8_UNORM] = DV_PF_8888,
   [MESA_FORMAT_B5G6R5_UNORM] = DV_PF_565 | DITHER_FULL_ALWAYS,
   [MESA_FORMAT_B5G5R5A1_UNORM] = DV_PF_1555 | DITHER_FULL_ALWAYS,
   [MESA_FORMAT_B4G4R4A4_UNORM] = DV_PF_4444 | DITHER_FULL_ALWAYS,
};

static bool
i915_render_target_supported(struct intel_context *intel,
			     struct gl_renderbuffer *rb)
{
   mesa_format format = rb->Format;

   if (format == MESA_FORMAT_Z24_UNORM_S8_UINT ||
       format == MESA_FORMAT_Z24_UNORM_X8_UINT ||
       format == MESA_FORMAT_Z_UNORM16) {
      return true;
   }

   return i915_render_target_format_for_mesa_format[format] != 0;
}

static void
i915_set_draw_region(struct intel_context *intel,
                     struct intel_region *color_regions[],
                     struct intel_region *depth_region,
		     GLuint num_regions)
{
   struct i915_context *i915 = i915_context(&intel->ctx);
   struct gl_context *ctx = &intel->ctx;
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0];
   struct intel_renderbuffer *irb = intel_renderbuffer(rb);
   struct gl_renderbuffer *drb;
   struct intel_renderbuffer *idrb = NULL;
   GLuint value;
   struct i915_hw_state *state = &i915->state;
   uint32_t draw_x, draw_y, draw_offset;

   if (state->draw_region != color_regions[0]) {
      intel_region_reference(&state->draw_region, color_regions[0]);
   }
   if (state->depth_region != depth_region) {
      intel_region_reference(&state->depth_region, depth_region);
   }

   /*
    * Set stride/cpp values
    */
   i915_set_buf_info_for_region(&state->Buffer[I915_DESTREG_CBUFADDR0],
				color_regions[0], BUF_3D_ID_COLOR_BACK);

   i915_set_buf_info_for_region(&state->Buffer[I915_DESTREG_DBUFADDR0],
				depth_region, BUF_3D_ID_DEPTH);

   /*
    * Compute/set I915_DESTREG_DV1 value
    */
   value = (DSTORG_HORT_BIAS(0x8) |     /* .5 */
            DSTORG_VERT_BIAS(0x8) |     /* .5 */
            LOD_PRECLAMP_OGL | TEX_DEFAULT_COLOR_OGL);
   if (irb != NULL) {
      value |= i915_render_target_format_for_mesa_format[intel_rb_format(irb)];
   } else {
      value |= DV_PF_8888;
   }

   /* This isn't quite safe, thus being hidden behind an option.  When changing
    * the value of this bit, the pipeline needs to be MI_FLUSHed.  And it
    * can only be set when a depth buffer is already defined.
    */
   if (intel->is_945 && intel->use_early_z &&
       depth_region->tiling != I915_TILING_NONE)
      value |= CLASSIC_EARLY_DEPTH;

   if (depth_region && depth_region->cpp == 4) {
      value |= DEPTH_FRMT_24_FIXED_8_OTHER;
   }
   else {
      value |= DEPTH_FRMT_16_FIXED;
   }
   state->Buffer[I915_DESTREG_DV1] = value;

   drb = ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
   if (!drb)
      drb = ctx->DrawBuffer->Attachment[BUFFER_STENCIL].Renderbuffer;

   if (drb)
      idrb = intel_renderbuffer(drb);

   /* We set up the drawing rectangle to be offset into the color
    * region's location in the miptree.  If it doesn't match with
    * depth's offsets, we can't render to it.
    *
    * (Well, not actually true -- the hw grew a bit to let depth's
    * offset get forced to 0,0.  We may want to use that if people are
    * hitting that case.  Also, some configurations may be supportable
    * by tweaking the start offset of the buffers around, which we
    * can't do in general due to tiling)
    */
   FALLBACK(intel, I915_FALLBACK_DRAW_OFFSET,
	    idrb && irb && (idrb->draw_x != irb->draw_x ||
			    idrb->draw_y != irb->draw_y));

   if (irb) {
      draw_x = irb->draw_x;
      draw_y = irb->draw_y;
   } else if (idrb) {
      draw_x = idrb->draw_x;
      draw_y = idrb->draw_y;
   } else {
      draw_x = 0;
      draw_y = 0;
   }

   draw_offset = (draw_y << 16) | draw_x;

   FALLBACK(intel, I915_FALLBACK_DRAW_OFFSET,
            (ctx->DrawBuffer->Width + draw_x > 2048) ||
            (ctx->DrawBuffer->Height + draw_y > 2048));
   /* When changing drawing rectangle offset, an MI_FLUSH is first required. */
   if (draw_offset != i915->last_draw_offset) {
      state->Buffer[I915_DESTREG_DRAWRECT0] = MI_FLUSH | INHIBIT_FLUSH_RENDER_CACHE;
      i915->last_draw_offset = draw_offset;
   } else
      state->Buffer[I915_DESTREG_DRAWRECT0] = MI_NOOP;

   state->Buffer[I915_DESTREG_DRAWRECT1] = _3DSTATE_DRAWRECT_INFO;
   state->Buffer[I915_DESTREG_DRAWRECT2] = 0;
   state->Buffer[I915_DESTREG_DRAWRECT3] = draw_offset;
   state->Buffer[I915_DESTREG_DRAWRECT4] =
      ((ctx->DrawBuffer->Width + draw_x - 1) & 0xffff) |
      ((ctx->DrawBuffer->Height + draw_y - 1) << 16);
   state->Buffer[I915_DESTREG_DRAWRECT5] = draw_offset;

   I915_STATECHANGE(i915, I915_UPLOAD_BUFFERS);
}

static void
i915_update_color_write_enable(struct i915_context *i915, bool enable)
{
   uint32_t dw = i915->state.Ctx[I915_CTXREG_LIS6];
   if (enable)
      dw |= S6_COLOR_WRITE_ENABLE;
   else
      dw &= ~S6_COLOR_WRITE_ENABLE;
   if (dw != i915->state.Ctx[I915_CTXREG_LIS6]) {
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      i915->state.Ctx[I915_CTXREG_LIS6] = dw;
   }
}

/**
 * Update the hardware state for drawing into a window or framebuffer object.
 *
 * Called by glDrawBuffer, glBindFramebufferEXT, MakeCurrent, and other
 * places within the driver.
 *
 * Basically, this needs to be called any time the current framebuffer
 * changes, the renderbuffers change, or we need to draw into different
 * color buffers.
 */
static void
i915_update_draw_buffer(struct intel_context *intel)
{
   struct i915_context *i915 = (struct i915_context *)intel;
   struct gl_context *ctx = &intel->ctx;
   struct gl_framebuffer *fb = ctx->DrawBuffer;
   struct intel_region *colorRegion = NULL, *depthRegion = NULL;
   struct intel_renderbuffer *irbDepth = NULL, *irbStencil = NULL;

   if (!fb) {
      /* this can happen during the initial context initialization */
      return;
   }

   irbDepth = intel_get_renderbuffer(fb, BUFFER_DEPTH);
   irbStencil = intel_get_renderbuffer(fb, BUFFER_STENCIL);

   /* Do this here, not core Mesa, since this function is called from
    * many places within the driver.
    */
   if (ctx->NewState & _NEW_BUFFERS) {
      /* this updates the DrawBuffer->_NumColorDrawBuffers fields, etc */
      _mesa_update_framebuffer(ctx);
      /* this updates the DrawBuffer's Width/Height if it's a FBO */
      _mesa_update_draw_buffer_bounds(ctx);
   }

   if (fb->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
      /* this may occur when we're called by glBindFrameBuffer() during
       * the process of someone setting up renderbuffers, etc.
       */
      /*_mesa_debug(ctx, "DrawBuffer: incomplete user FBO\n");*/
      return;
   }

   /* How many color buffers are we drawing into?
    *
    * If there is more than one drawbuffer (GL_FRONT_AND_BACK), or the
    * drawbuffers are too big, we have to fallback to software.
    */
   if ((fb->Width > ctx->Const.MaxRenderbufferSize)
       || (fb->Height > ctx->Const.MaxRenderbufferSize)) {
      FALLBACK(intel, INTEL_FALLBACK_DRAW_BUFFER, true);
   } else if (fb->_NumColorDrawBuffers > 1) {
      FALLBACK(intel, INTEL_FALLBACK_DRAW_BUFFER, true);
   } else {
      struct intel_renderbuffer *irb;
      irb = intel_renderbuffer(fb->_ColorDrawBuffers[0]);
      colorRegion = (irb && irb->mt) ? irb->mt->region : NULL;
      FALLBACK(intel, INTEL_FALLBACK_DRAW_BUFFER, false);
   }

   /* Check for depth fallback. */
   if (irbDepth && irbDepth->mt) {
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, false);
      depthRegion = irbDepth->mt->region;
   } else if (irbDepth && !irbDepth->mt) {
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, true);
      depthRegion = NULL;
   } else { /* !irbDepth */
      /* No fallback is needed because there is no depth buffer. */
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, false);
      depthRegion = NULL;
   }

   /* Check for stencil fallback. */
   if (irbStencil && irbStencil->mt) {
      assert(intel_rb_format(irbStencil) == MESA_FORMAT_Z24_UNORM_S8_UINT);
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, false);
   } else if (irbStencil && !irbStencil->mt) {
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, true);
   } else { /* !irbStencil */
      /* No fallback is needed because there is no stencil buffer. */
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, false);
   }

   /* If we have a (packed) stencil buffer attached but no depth buffer,
    * we still need to set up the shared depth/stencil state so we can use it.
    */
   if (depthRegion == NULL && irbStencil && irbStencil->mt
       && intel_rb_format(irbStencil) == MESA_FORMAT_Z24_UNORM_S8_UINT) {
      depthRegion = irbStencil->mt->region;
   }

   /*
    * Update depth and stencil test state
    */
   ctx->Driver.Enable(ctx, GL_DEPTH_TEST, ctx->Depth.Test);
   ctx->Driver.Enable(ctx, GL_STENCIL_TEST, ctx->Stencil.Enabled);

   i915_update_color_write_enable(i915, colorRegion != NULL);

   intel->vtbl.set_draw_region(intel, &colorRegion, depthRegion,
                               fb->_NumColorDrawBuffers);
   intel->NewGLState |= _NEW_BUFFERS;

   /* Set state we know depends on drawable parameters:
    */
   intelCalcViewport(ctx);
   ctx->Driver.Scissor(ctx);

   /* Update culling direction which changes depending on the
    * orientation of the buffer:
    */
   ctx->Driver.FrontFace(ctx, ctx->Polygon.FrontFace);
}

static void
i915_new_batch(struct intel_context *intel)
{
   struct i915_context *i915 = i915_context(&intel->ctx);

   /* Mark all state as needing to be emitted when starting a new batchbuffer.
    * Using hardware contexts would be an alternative, but they have some
    * difficulties associated with them (physical address requirements).
    */
   i915->state.emitted = 0;
   i915->last_draw_offset = 0;
   i915->last_sampler = 0;

   i915->current_vb_bo = NULL;
   i915->current_vertex_size = 0;
}

static void 
i915_assert_not_dirty( struct intel_context *intel )
{
   struct i915_context *i915 = i915_context(&intel->ctx);
   GLuint dirty = get_dirty(&i915->state);
   assert(!dirty);
   (void) dirty;
}

static void
i915_invalidate_state(struct intel_context *intel, GLuint new_state)
{
   struct gl_context *ctx = &intel->ctx;

   _swsetup_InvalidateState(ctx, new_state);
   _tnl_InvalidateState(ctx, new_state);
   _tnl_invalidate_vertex_state(ctx, new_state);
}

void
i915InitVtbl(struct i915_context *i915)
{
   i915->intel.vtbl.check_vertex_size = i915_check_vertex_size;
   i915->intel.vtbl.destroy = i915_destroy_context;
   i915->intel.vtbl.emit_state = i915_emit_state;
   i915->intel.vtbl.new_batch = i915_new_batch;
   i915->intel.vtbl.reduced_primitive_state = i915_reduced_primitive_state;
   i915->intel.vtbl.render_start = i915_render_start;
   i915->intel.vtbl.render_prevalidate = i915_render_prevalidate;
   i915->intel.vtbl.set_draw_region = i915_set_draw_region;
   i915->intel.vtbl.update_draw_buffer = i915_update_draw_buffer;
   i915->intel.vtbl.update_texture_state = i915UpdateTextureState;
   i915->intel.vtbl.assert_not_dirty = i915_assert_not_dirty;
   i915->intel.vtbl.finish_batch = intel_finish_vb;
   i915->intel.vtbl.invalidate_state = i915_invalidate_state;
   i915->intel.vtbl.render_target_supported = i915_render_target_supported;
}
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d209 3
a215 3
   /* XXX: Use this */
   OUT_BATCH(_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);

d418 1
a421 1
      OUT_BATCH(state->Buffer[I915_DESTREG_SENABLE]);
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a208 3
   /* XXX: Use this */
   OUT_BATCH(_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);

d213 3
a417 1
      OUT_BATCH(state->Buffer[I915_DESTREG_SENABLE]);
d421 1
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d552 5
a556 5
   [MESA_FORMAT_ARGB8888] = DV_PF_8888,
   [MESA_FORMAT_XRGB8888] = DV_PF_8888,
   [MESA_FORMAT_RGB565] = DV_PF_565 | DITHER_FULL_ALWAYS,
   [MESA_FORMAT_ARGB1555] = DV_PF_1555 | DITHER_FULL_ALWAYS,
   [MESA_FORMAT_ARGB4444] = DV_PF_4444 | DITHER_FULL_ALWAYS,
d563 1
a563 1
   gl_format format = rb->Format;
d565 3
a567 3
   if (format == MESA_FORMAT_S8_Z24 ||
       format == MESA_FORMAT_X8_Z24 ||
       format == MESA_FORMAT_Z16) {
d780 1
a780 1
      assert(intel_rb_format(irbStencil) == MESA_FORMAT_S8_Z24);
d793 1
a793 1
       && intel_rb_format(irbStencil) == MESA_FORMAT_S8_Z24) {
a808 3
   /* update viewport since it depends on window size */
   intelCalcViewport(ctx);

d811 2
a812 3
   ctx->Driver.Scissor(ctx, ctx->Scissor.X, ctx->Scissor.Y,
		       ctx->Scissor.Width, ctx->Scissor.Height);
   ctx->Driver.DepthRange(ctx, ctx->Viewport.Near, ctx->Viewport.Far);
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d44 1
d102 1
a102 1
static GLboolean
d163 1
a163 1
         return GL_FALSE;
d226 1
a226 1
   intel_batchbuffer_data(intel, state, size, false)
d309 2
a310 2
				   get_state_size(state) + INTEL_PRIM_EMIT_SIZE,
				   false);
d322 2
a323 1
      aper_array[aper_count++] = state->draw_region->buffer;
d325 1
a325 1
	 aper_array[aper_count++] = state->depth_region->buffer;
d393 1
a393 1
      count = 14;
a395 2
      if (state->depth_region)
         count += 3;
d400 6
a405 2
      OUT_RELOC(state->draw_region->buffer,
		I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER, 0);
d407 2
d410 1
a410 3
         OUT_BATCH(state->Buffer[I915_DESTREG_DBUFADDR0]);
         OUT_BATCH(state->Buffer[I915_DESTREG_DBUFADDR1]);
         OUT_RELOC(state->depth_region->buffer,
d412 2
d534 1
a534 1
      state[1] |= BUF_3D_PITCH(region->pitch * region->cpp);
d541 6
d560 2
a561 1
i915_render_target_supported(gl_format format)
d563 2
a590 1
      intel_region_release(&state->draw_region);
a593 1
      intel_region_release(&state->depth_region);
d613 3
a615 1
      value |= i915_render_target_format_for_mesa_format[irb->Base.Format];
d668 3
a672 4
      FALLBACK(intel, I915_FALLBACK_DRAW_OFFSET,
               (ctx->DrawBuffer->Width + draw_x > 2048) ||
               (ctx->DrawBuffer->Height + draw_y > 2048));

d689 14
d716 1
d719 1
a719 1
   struct intel_region *colorRegions[MAX_DRAW_BUFFERS], *depthRegion = NULL;
a720 1
   bool fb_has_hiz = intel_framebuffer_has_hiz(fb);
d750 2
a751 3
    * If there are zero buffers or the buffer is too big, don't configure any
    * regions for hardware drawing.  We'll fallback to software below.  Not
    * having regions set makes some of the software fallback paths faster.
d754 9
a762 38
       || (fb->Height > ctx->Const.MaxRenderbufferSize)
       || (fb->_NumColorDrawBuffers == 0)) {
      /* writing to 0  */
      colorRegions[0] = NULL;
   }
   else if (fb->_NumColorDrawBuffers > 1) {
       int i;
       struct intel_renderbuffer *irb;

       for (i = 0; i < fb->_NumColorDrawBuffers; i++) {
           irb = intel_renderbuffer(fb->_ColorDrawBuffers[i]);
           colorRegions[i] = irb ? irb->region : NULL;
       }
   }
   else {
      /* Get the intel_renderbuffer for the single colorbuffer we're drawing
       * into.
       */
      if (fb->Name == 0) {
	 /* drawing to window system buffer */
	 if (fb->_ColorDrawBufferIndexes[0] == BUFFER_FRONT_LEFT)
	    colorRegions[0] = intel_get_rb_region(fb, BUFFER_FRONT_LEFT);
	 else
	    colorRegions[0] = intel_get_rb_region(fb, BUFFER_BACK_LEFT);
      }
      else {
	 /* drawing to user-created FBO */
	 struct intel_renderbuffer *irb;
	 irb = intel_renderbuffer(fb->_ColorDrawBuffers[0]);
	 colorRegions[0] = (irb && irb->region) ? irb->region : NULL;
      }
   }

   if (!colorRegions[0]) {
      FALLBACK(intel, INTEL_FALLBACK_DRAW_BUFFER, GL_TRUE);
   }
   else {
      FALLBACK(intel, INTEL_FALLBACK_DRAW_BUFFER, GL_FALSE);
d766 5
a770 6
   if (irbDepth && irbDepth->region) {
      assert(!fb_has_hiz || irbDepth->Base.Format != MESA_FORMAT_S8_Z24);
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, GL_FALSE);
      depthRegion = irbDepth->region;
   } else if (irbDepth && !irbDepth->region) {
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, GL_TRUE);
d774 1
a774 1
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, GL_FALSE);
d779 5
a783 5
   if (irbStencil && irbStencil->region) {
      assert(irbStencil->Base.Format == MESA_FORMAT_S8_Z24);
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, GL_FALSE);
   } else if (irbStencil && !irbStencil->region) {
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, GL_TRUE);
d786 1
a786 1
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, GL_FALSE);
d792 3
a794 3
   if (depthRegion == NULL && irbStencil && irbStencil->region
       && irbStencil->Base.Format == MESA_FORMAT_S8_Z24) {
      depthRegion = irbStencil->region;
d803 3
a805 1
   intel->vtbl.set_draw_region(intel, colorRegions, depthRegion,
a849 8
/** Return false; i915 does not support HiZ. */
static bool
i915_is_hiz_depth_format(struct intel_context *intel,
                         gl_format format)
{
   return false;
}

a876 1
   i915->intel.vtbl.is_hiz_depth_format = i915_is_hiz_depth_format;
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d35 2
d38 1
d41 1
d47 1
d225 1
a225 1
   intel_batchbuffer_data(intel->batch, state, size, false)
d259 3
a267 3
   if (dirty & I915_UPLOAD_FOG)
      sz += sizeof(state->Fog);

d307 1
a307 1
   intel_batchbuffer_require_space(intel->batch,
d312 4
d319 1
a319 1
   aper_array[aper_count++] = intel->batch->buf;
d339 1
a339 1
	   intel_batchbuffer_flush(intel->batch);
d378 7
a433 6
   if (dirty & I915_UPLOAD_FOG) {
      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_FOG:\n");
      emit(intel, state->Fog, sizeof(state->Fog));
   }

d439 1
d450 3
a452 9

            if (state->tex_buffer[i]) {
               OUT_RELOC(state->tex_buffer[i],
			 I915_GEM_DOMAIN_SAMPLER, 0,
                         state->tex_offset[i]);
            }
            else {
               OUT_BATCH(state->tex_offset[i]);
            }
d459 1
d470 7
a497 1
   intel->batch->dirty_state &= ~dirty;
a498 1
   assert((intel->batch->dirty_state & (1<<1)) == 0);
d538 21
d569 2
d600 1
a600 18
      switch (irb->Base.Format) {
      case MESA_FORMAT_ARGB8888:
      case MESA_FORMAT_XRGB8888:
	 value |= DV_PF_8888;
	 break;
      case MESA_FORMAT_RGB565:
	 value |= DV_PF_565 | DITHER_FULL_ALWAYS;
	 break;
      case MESA_FORMAT_ARGB1555:
	 value |= DV_PF_1555 | DITHER_FULL_ALWAYS;
	 break;
      case MESA_FORMAT_ARGB4444:
	 value |= DV_PF_4444 | DITHER_FULL_ALWAYS;
	 break;
      default:
	 _mesa_problem(ctx, "Bad renderbuffer format: %d\n",
		       irb->Base.Format);
      }
d619 7
d637 9
a645 10
	    (depth_region && color_regions[0]) &&
	    (depth_region->draw_x != color_regions[0]->draw_x ||
	     depth_region->draw_y != color_regions[0]->draw_y));

   if (color_regions[0]) {
      draw_x = color_regions[0]->draw_x;
      draw_y = color_regions[0]->draw_y;
   } else if (depth_region) {
      draw_x = depth_region->draw_x;
      draw_y = depth_region->draw_y;
d675 116
d792 32
d836 4
d851 18
d880 1
d884 3
@


1.5
log
@Update to Mesa 7.8.2. Tested by johan@@. Thanks.
@
text
@d220 1
a220 1
   intel_batchbuffer_data(intel->batch, state, size)
d290 1
a290 1
   dri_bo *aper_array[3 + I915_TEX_UNITS];
d303 2
a304 1
				   get_state_size(state) + INTEL_PRIM_EMIT_SIZE);
d370 1
a370 1
      GLuint count = 15;
d375 3
d379 1
a379 1
          count += 3;
d401 2
a402 2
      assert(state->Buffer[I915_DESTREG_DRAWRECT0] != MI_NOOP);
      OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT0]);
d501 1
a501 1
	 dri_bo_unreference(i915->state.tex_buffer[i]);
d534 1
a534 1
   GLcontext *ctx = &intel->ctx;
d539 1
a539 1
   uint32_t draw_x, draw_y;
d628 2
d631 10
a640 1
   state->Buffer[I915_DESTREG_DRAWRECT0] = MI_FLUSH;
d643 1
a643 1
   state->Buffer[I915_DESTREG_DRAWRECT3] = (draw_y << 16) | draw_x;
d647 1
a647 1
   state->Buffer[I915_DESTREG_DRAWRECT5] = (draw_y << 16) | draw_x;
d664 1
d673 1
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d630 2
a631 2
      ((ctx->DrawBuffer->Width + draw_x) & 0xffff) |
      ((ctx->DrawBuffer->Height + draw_y) << 16);
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a39 1
#include "intel_tex.h"
d42 1
a46 2
#include "glapi/glapi.h"

d52 1
a52 2
   if (!intel->Fallback)
       i915ValidateFragmentProgram(i915);
d58 1
d100 2
a101 2
   int lis2 = i915->current->Ctx[I915_CTXREG_LIS2];
   int lis4 = i915->current->Ctx[I915_CTXREG_LIS4];
d174 1
a174 1
   BEGIN_BATCH(20, IGNORE_CLIPRECTS);
a197 8
   OUT_BATCH(_3DSTATE_RASTER_RULES_CMD |
             ENABLE_POINT_RASTER_RULE |
             OGL_POINT_RASTER_RULE |
             ENABLE_LINE_STRIP_PROVOKE_VRTX |
             ENABLE_TRI_FAN_PROVOKE_VRTX |
             LINE_STRIP_PROVOKE_VRTX(1) |
             TRI_FAN_PROVOKE_VRTX(2) | ENABLE_TEXKILL_3D_4D | TEXKILL_4D);

a214 5

   /* Don't support twosided stencil yet */
   OUT_BATCH(_3DSTATE_BACKFACE_STENCIL_OPS | BFO_ENABLE_STENCIL_TWO_SIDE | 0);
   OUT_BATCH(0);

d220 1
a220 1
   intel_batchbuffer_data(intel->batch, state, size, IGNORE_CLIPRECTS )
d248 3
d287 1
a287 1
   struct i915_hw_state *state = i915->current;
a300 3
    *
    * Set the space as LOOP_CLIPRECTS now, since that's what our primitives
    * will be emitted under.
d303 1
a303 2
				   get_state_size(state) + INTEL_PRIM_EMIT_SIZE,
				   LOOP_CLIPRECTS);
d355 6
d369 1
a369 1
      GLuint count = 9;
d377 1
a377 4
      if (intel->constant_cliprect)
          count += 6;

      BEGIN_BATCH(count, IGNORE_CLIPRECTS);
d381 1
a381 2
		I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER,
                state->draw_region->draw_offset);
d387 1
a387 2
		   I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER,
                   state->depth_region->draw_offset);
d397 7
a403 9
      if (intel->constant_cliprect) {
	 assert(state->Buffer[I915_DESTREG_DRAWRECT0] != MI_NOOP);
	 OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT0]);
	 OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT1]);
	 OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT2]);
	 OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT3]);
	 OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT4]);
	 OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT5]);
      }
d430 1
a430 1
      BEGIN_BATCH(2 + nr * 3, IGNORE_CLIPRECTS);
a440 4
            else if (state == &i915->meta) {
               assert(i == 0);
               OUT_BATCH(0);
            }
d450 1
a450 1
      BEGIN_BATCH(2 + nr * 3, IGNORE_CLIPRECTS);
a493 4
   intel_region_release(&i915->meta.draw_region);
   intel_region_release(&i915->meta.depth_region);
   intel_region_release(&i915->initial.draw_region);
   intel_region_release(&i915->initial.depth_region);
d505 9
d515 13
a527 11
/**
 * Set the drawing regions for the color and depth/stencil buffers.
 * This involves setting the pitch, cpp and buffer ID/location.
 * Also set pixel format for color and Z rendering
 * Used for setting both regular and meta state.
 */
void
i915_state_draw_region(struct intel_context *intel,
                       struct i915_hw_state *state,
                       struct intel_region *color_region,
                       struct intel_region *depth_region)
d531 2
d534 2
d537 1
a537 3
   ASSERT(state == &i915->state || state == &i915->meta);

   if (state->draw_region != color_region) {
d539 1
a539 1
      intel_region_reference(&state->draw_region, color_region);
d549 2
a550 7
   if (color_region) {
      state->Buffer[I915_DESTREG_CBUFADDR0] = _3DSTATE_BUF_INFO_CMD;
      state->Buffer[I915_DESTREG_CBUFADDR1] =
         (BUF_3D_ID_COLOR_BACK |
          BUF_3D_PITCH(color_region->pitch * color_region->cpp) |
          BUF_3D_USE_FENCE);
   }
d552 2
a553 7
   if (depth_region) {
      state->Buffer[I915_DESTREG_DBUFADDR0] = _3DSTATE_BUF_INFO_CMD;
      state->Buffer[I915_DESTREG_DBUFADDR1] =
         (BUF_3D_ID_DEPTH |
          BUF_3D_PITCH(depth_region->pitch * depth_region->cpp) |
          BUF_3D_USE_FENCE);
   }
d561 19
a579 5
   if (color_region && color_region->cpp == 4) {
      value |= DV_PF_8888;
   }
   else {
      value |= (DITHER_FULL_ALWAYS | DV_PF_565);
d581 9
d598 21
a618 9
   if (intel->constant_cliprect) {
      state->Buffer[I915_DESTREG_DRAWRECT0] = _3DSTATE_DRAWRECT_INFO;
      state->Buffer[I915_DESTREG_DRAWRECT1] = 0;
      state->Buffer[I915_DESTREG_DRAWRECT2] = 0; /* xmin, ymin */
      state->Buffer[I915_DESTREG_DRAWRECT3] =
	 (ctx->DrawBuffer->Width & 0xffff) |
	 (ctx->DrawBuffer->Height << 16);
      state->Buffer[I915_DESTREG_DRAWRECT4] = 0; /* xoff, yoff */
      state->Buffer[I915_DESTREG_DRAWRECT5] = 0;
d620 2
a621 6
      state->Buffer[I915_DESTREG_DRAWRECT0] = MI_NOOP;
      state->Buffer[I915_DESTREG_DRAWRECT1] = MI_NOOP;
      state->Buffer[I915_DESTREG_DRAWRECT2] = MI_NOOP;
      state->Buffer[I915_DESTREG_DRAWRECT3] = MI_NOOP;
      state->Buffer[I915_DESTREG_DRAWRECT4] = MI_NOOP;
      state->Buffer[I915_DESTREG_DRAWRECT5] = MI_NOOP;
d624 10
a637 11
static void
i915_set_draw_region(struct intel_context *intel,
                     struct intel_region *color_regions[],
                     struct intel_region *depth_region,
		     GLuint num_regions)
{
   struct i915_context *i915 = i915_context(&intel->ctx);
   i915_state_draw_region(intel, &i915->state, color_regions[0], depth_region);
}


a648 9

   /* Check that we didn't just wrap our batchbuffer at a bad time. */
   assert(!intel->no_batch_wrap);
}

static GLuint
i915_flush_cmd(void)
{
   return MI_FLUSH | FLUSH_MAP_CACHE;
d655 1
a655 2
   struct i915_hw_state *state = i915->current;
   GLuint dirty = get_dirty(state);
a658 7
static void
i915_note_unlock( struct intel_context *intel )
{
    /* nothing */
}


a670 1
   i915->intel.vtbl.flush_cmd = i915_flush_cmd;
a671 1
   i915->intel.vtbl.note_unlock = i915_note_unlock; 
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d30 5
a34 5
#include "glheader.h"
#include "mtypes.h"
#include "imports.h"
#include "macros.h"
#include "colormac.h"
d42 1
d47 1
a47 1
#include "glapi.h"
d176 1
a176 1
   BEGIN_BATCH(200, IGNORE_CLIPRECTS);
d300 1
a300 2
   int i;
   int ret, count;
d302 1
d317 2
a318 1
   intel_batchbuffer_require_space(intel->batch, get_state_size(state) + 8,
d322 1
d325 1
a325 1
   ret = 0;
d327 3
a329 3
     ret |= dri_bufmgr_check_aperture_space(state->draw_region->buffer);
     if (state->depth_region)
        ret |= dri_bufmgr_check_aperture_space(state->depth_region->buffer);
d333 7
a339 6
     for (i = 0; i < I915_TEX_UNITS; i++)
       if (dirty & I915_UPLOAD_TEX(i)) {
	   if (state->tex_buffer[i]) {
	       ret |= dri_bufmgr_check_aperture_space(state->tex_buffer[i]);
	   }
       }
d341 2
a342 1
   if (ret) {
d379 2
d383 8
a390 1
      BEGIN_BATCH(I915_DEST_SETUP_SIZE + 2, IGNORE_CLIPRECTS);
d394 1
a394 1
                DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_WRITE,
d401 1
a401 1
                   DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_WRITE,
d411 11
d455 1
a455 1
                         DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_READ,
d513 7
d544 1
d597 18
d683 1
@


1.1
log
@Initial revision
@
text
@d40 2
d46 4
a49 1
static void i915_render_start( intelContextPtr intel )
d51 1
a51 2
   GLcontext *ctx = &intel->ctx;
   i915ContextPtr i915 = I915_CONTEXT(intel);
d53 7
a59 4
   if (ctx->FragmentProgram._Active) 
      i915ValidateFragmentProgram( i915 );
   else 
      i915ValidateTextureProgram( i915 );
d63 2
a64 2
static void i915_reduced_primitive_state( intelContextPtr intel,
					  GLenum rprim )
d66 2
a67 2
    i915ContextPtr i915 = I915_CONTEXT(intel);
    GLuint st1 = i915->state.Stipple[I915_STPREG_ST1];
d69 1
a69 1
    st1 &= ~ST1_ENABLE;
d71 11
a81 11
    switch (rprim) {
    case GL_TRIANGLES:
       if (intel->ctx.Polygon.StippleFlag &&
	   intel->hw_stipple)
	  st1 |= ST1_ENABLE;
       break;
    case GL_LINES:
    case GL_POINTS:
    default:
       break;
    }
d83 1
a83 1
    i915->intel.reduced_primitive = rprim;
d85 6
a90 4
    if (st1 != i915->state.Stipple[I915_STPREG_ST1]) {
       I915_STATECHANGE(i915, I915_UPLOAD_STIPPLE);
       i915->state.Stipple[I915_STPREG_ST1] = st1;
    }
d97 2
a98 2
static GLboolean i915_check_vertex_size( intelContextPtr intel,
					 GLuint expected )
d100 1
a100 1
   i915ContextPtr i915 = I915_CONTEXT(intel);
d106 13
a118 5
   case S4_VFMT_XY: sz = 2; break;
   case S4_VFMT_XYZ: sz = 3; break;
   case S4_VFMT_XYW: sz = 3; break;
   case S4_VFMT_XYZW: sz = 4; break;
   default: 
d123 12
a134 7
   if (lis4 & S4_VFMT_SPEC_FOG) sz++;
   if (lis4 & S4_VFMT_COLOR) sz++;
   if (lis4 & S4_VFMT_DEPTH_OFFSET) sz++;
   if (lis4 & S4_VFMT_POINT_WIDTH) sz++;
   if (lis4 & S4_VFMT_FOG_PARAM) sz++;
	
   for (i = 0 ; i < 8 ; i++) { 
d136 20
a155 7
      case TEXCOORDFMT_2D: sz += 2; break;
      case TEXCOORDFMT_3D: sz += 3; break;
      case TEXCOORDFMT_4D: sz += 4; break;
      case TEXCOORDFMT_1D: sz += 1; break;
      case TEXCOORDFMT_2D_16: sz += 1; break;
      case TEXCOORDFMT_4D_16: sz += 2; break;
      case TEXCOORDFMT_NOT_PRESENT: break;
d157 2
a158 2
	 fprintf(stderr, "bad texcoord fmt %d\n", i);
	 return GL_FALSE;
d162 2
a163 2
	
   if (sz != expected) 
d165 1
a165 1
   
d170 2
a171 1
static void i915_emit_invarient_state( intelContextPtr intel )
d175 1
a175 1
   BEGIN_BATCH( 20 );
d178 3
a180 4
	     AA_LINE_ECAAR_WIDTH_ENABLE |
	     AA_LINE_ECAAR_WIDTH_1_0 |
	     AA_LINE_REGION_WIDTH_ENABLE |
	     AA_LINE_REGION_WIDTH_1_0);
d193 5
a197 8
	     CSB_TCB(0, 0) |
	     CSB_TCB(1, 1) |
	     CSB_TCB(2, 2) |
	     CSB_TCB(3, 3) |
	     CSB_TCB(4, 4) |
	     CSB_TCB(5, 5) |
	     CSB_TCB(6, 6) |
	     CSB_TCB(7, 7));
d200 6
a205 8
	     ENABLE_POINT_RASTER_RULE |
	     OGL_POINT_RASTER_RULE |
	     ENABLE_LINE_STRIP_PROVOKE_VRTX |
	     ENABLE_TRI_FAN_PROVOKE_VRTX |
	     LINE_STRIP_PROVOKE_VRTX(1) |
	     TRI_FAN_PROVOKE_VRTX(2) | 
	     ENABLE_TEXKILL_3D_4D |
	     TEXKILL_4D);
d209 1
a209 3
   OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | 
	     I1_LOAD_S(3) |
	     (1));
d211 1
a211 1
 
d213 1
a213 2
   OUT_BATCH(_3DSTATE_SCISSOR_ENABLE_CMD | 
	     DISABLE_SCISSOR_RECT);
d221 1
a221 1
   OUT_BATCH(_3DSTATE_LOAD_INDIRECT | 0); /* disable indirect state */
d226 3
a228 4
   OUT_BATCH(_3DSTATE_BACKFACE_STENCIL_OPS |
	     BFO_ENABLE_STENCIL_TWO_SIDE |
	     0 );
   
d233 2
a234 8
#define emit( intel, state, size )			\
do {							\
   int k;						\
   BEGIN_BATCH( (size) / sizeof(GLuint));		\
   for (k = 0 ; k < (size) / sizeof(GLuint) ; k++)	\
      OUT_BATCH((state)[k]);				\
   ADVANCE_BATCH();					\
} while (0);
d236 2
a237 1
static GLuint get_dirty( struct i915_hw_state *state )
a247 1

d252 2
a253 1
static GLuint get_state_size( struct i915_hw_state *state )
d260 1
a260 1
      sz += 20 * sizeof(int);
d265 1
a265 1
   if (dirty & I915_UPLOAD_BUFFERS) 
d271 1
a271 1
   if (dirty & I915_UPLOAD_FOG) 
d276 3
a278 3
      for (i = 0; i < I915_TEX_UNITS; i++) 
	 if (dirty & I915_UPLOAD_TEX(i)) 
	    nr++;
d280 1
a280 1
      sz += (2+nr*3) * sizeof(GLuint) * 2;
d283 1
a283 1
   if (dirty & I915_UPLOAD_CONSTANTS) 
d286 1
a286 1
   if (dirty & I915_UPLOAD_PROGRAM) 
a291 1

d294 2
a295 1
static void i915_emit_state( intelContextPtr intel )
d297 1
a297 1
   i915ContextPtr i915 = I915_CONTEXT(intel);
d300 3
a302 2
   GLuint dirty = get_dirty(state);
   GLuint counter = intel->batch.counter;
d305 41
a345 4
   if (intel->batch.space < get_state_size(state)) {
      intelFlushBatch(intel, GL_TRUE);
      dirty = get_dirty(state);
      counter = intel->batch.counter;
d348 10
a357 1
   if (VERBOSE) 
d361 3
a363 2
      if (VERBOSE) fprintf(stderr, "I915_UPLOAD_INVARIENT:\n"); 
      i915_emit_invarient_state( intel );
d367 4
a370 2
      if (VERBOSE) fprintf(stderr, "I915_UPLOAD_CTX:\n"); 
      emit( i915, state->Ctx, sizeof(state->Ctx) );
d374 24
a397 2
      if (VERBOSE) fprintf(stderr, "I915_UPLOAD_BUFFERS:\n"); 
      emit( i915, state->Buffer, sizeof(state->Buffer) );
d401 3
a403 2
      if (VERBOSE) fprintf(stderr, "I915_UPLOAD_STIPPLE:\n"); 
      emit( i915, state->Stipple, sizeof(state->Stipple) );
d407 3
a409 2
      if (VERBOSE) fprintf(stderr, "I915_UPLOAD_FOG:\n"); 
      emit( i915, state->Fog, sizeof(state->Fog) );
d418 3
a420 3
      for (i = 0; i < I915_TEX_UNITS; i++) 
	 if (dirty & I915_UPLOAD_TEX(i)) 
	    nr++;
d422 2
a423 2
      BEGIN_BATCH(2+nr*3);
      OUT_BATCH(_3DSTATE_MAP_STATE | (3*nr));
d425 19
a443 6
      for (i = 0 ; i < I915_TEX_UNITS ; i++)
	 if (dirty & I915_UPLOAD_TEX(i)) {
	    OUT_BATCH(state->Tex[i][I915_TEXREG_MS2]);
	    OUT_BATCH(state->Tex[i][I915_TEXREG_MS3]);
	    OUT_BATCH(state->Tex[i][I915_TEXREG_MS4]);
	 }
d446 2
a447 2
      BEGIN_BATCH(2+nr*3);
      OUT_BATCH(_3DSTATE_SAMPLER_STATE | (3*nr));
d449 6
a454 6
      for (i = 0 ; i < I915_TEX_UNITS ; i++)
	 if (dirty & I915_UPLOAD_TEX(i)) {
	    OUT_BATCH(state->Tex[i][I915_TEXREG_SS2]);
	    OUT_BATCH(state->Tex[i][I915_TEXREG_SS3]);
	    OUT_BATCH(state->Tex[i][I915_TEXREG_SS4]);
	 }
d459 3
a461 2
      if (VERBOSE) fprintf(stderr, "I915_UPLOAD_CONSTANTS:\n"); 
      emit( i915, state->Constant, state->ConstantSize * sizeof(GLuint) );
d465 10
a474 7
      if (VERBOSE) fprintf(stderr, "I915_UPLOAD_PROGRAM:\n"); 

      assert((state->Program[0] & 0x1ff)+2 == state->ProgramSize);
      
      emit( i915, state->Program, state->ProgramSize * sizeof(GLuint) );
      if (VERBOSE)
	 i915_disassemble_program( state->Program, state->ProgramSize );
d477 3
a479 3
   state->emitted |= dirty;
   intel->batch.last_emit_state = counter;
   assert(counter == intel->batch.counter);
d482 2
a483 1
static void i915_destroy_context( intelContextPtr intel )
d485 10
d500 4
a503 1
 * Set the color buffer drawing region.
d505 5
a509 2
static void
i915_set_color_region( intelContextPtr intel, const intelRegion *region)
d511 54
a564 5
   i915ContextPtr i915 = I915_CONTEXT(intel);
   I915_STATECHANGE( i915, I915_UPLOAD_BUFFERS );
   i915->state.Buffer[I915_DESTREG_CBUFADDR1] =
      (BUF_3D_ID_COLOR_BACK | BUF_3D_PITCH(region->pitch) | BUF_3D_USE_FENCE);
   i915->state.Buffer[I915_DESTREG_CBUFADDR2] = region->offset;
a567 3
/**
 * specify the z-buffer/stencil region
 */
d569 4
a572 1
i915_set_z_region( intelContextPtr intel, const intelRegion *region)
d574 2
a575 5
   i915ContextPtr i915 = I915_CONTEXT(intel);
   I915_STATECHANGE( i915, I915_UPLOAD_BUFFERS );
   i915->state.Buffer[I915_DESTREG_DBUFADDR1] =
      (BUF_3D_ID_DEPTH | BUF_3D_PITCH(region->pitch) | BUF_3D_USE_FENCE);
   i915->state.Buffer[I915_DESTREG_DBUFADDR2] = region->offset;
d579 1
a579 4
/**
 * Set both the color and Z/stencil drawing regions.
 * Similar to two previous functions, but don't use I915_STATECHANGE()
 */
d581 1
a581 3
i915_update_color_z_regions(intelContextPtr intel,
                            const intelRegion *colorRegion,
                            const intelRegion *depthRegion)
d583 1
a583 1
   i915ContextPtr i915 = I915_CONTEXT(intel);
d585 5
a589 3
   i915->state.Buffer[I915_DESTREG_CBUFADDR1] =
      (BUF_3D_ID_COLOR_BACK | BUF_3D_PITCH(colorRegion->pitch) | BUF_3D_USE_FENCE);
   i915->state.Buffer[I915_DESTREG_CBUFADDR2] = colorRegion->offset;
d591 2
a592 5
   i915->state.Buffer[I915_DESTREG_DBUFADDR1] =
      (BUF_3D_ID_DEPTH |
       BUF_3D_PITCH(depthRegion->pitch) |  /* pitch in bytes */
       BUF_3D_USE_FENCE);
   i915->state.Buffer[I915_DESTREG_DBUFADDR2] = depthRegion->offset;
d595 5
d601 2
a602 1
static void i915_lost_hardware( intelContextPtr intel )
d604 4
a607 1
   I915_CONTEXT(intel)->state.emitted = 0;
d610 2
a611 1
static void i915_emit_flush( intelContextPtr intel )
d613 1
a613 6
   BATCH_LOCALS;

   BEGIN_BATCH(2);
   OUT_BATCH( MI_FLUSH | FLUSH_MAP_CACHE | FLUSH_RENDER_CACHE ); 
   OUT_BATCH( 0 );
   ADVANCE_BATCH();
d617 2
a618 1
void i915InitVtbl( i915ContextPtr i915 )
a619 1
   i915->intel.vtbl.alloc_tex_obj = i915AllocTexObj;
a620 2
   i915->intel.vtbl.clear_with_tris = i915ClearWithTris;
   i915->intel.vtbl.rotate_window = i915RotateWindow;
d623 1
a623 1
   i915->intel.vtbl.lost_hardware = i915_lost_hardware;
d626 2
a627 3
   i915->intel.vtbl.set_color_region = i915_set_color_region;
   i915->intel.vtbl.set_z_region = i915_set_z_region;
   i915->intel.vtbl.update_color_z_regions = i915_update_color_z_regions;
d629 3
a631 1
   i915->intel.vtbl.emit_flush = i915_emit_flush;
a632 1

@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d51 1
a51 2
   else {
      assert(!ctx->_MaintainTexEnvProgram);
a52 1
   }
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d52 1
a52 1
      assert(!ctx->FragmentProgram._MaintainTexEnvProgram);
a66 1
    case GL_QUADS: /* from RASTERIZE(GL_QUADS) in t_dd_tritemp.h */
d183 1
a183 1
	     (0));
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d30 5
a34 5
#include "main/glheader.h"
#include "main/mtypes.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/colormac.h"
a39 3
#include "intel_regions.h"
#include "intel_tris.h"
#include "intel_fbo.h"
d44 1
a44 2
static void
i915_render_prevalidate(struct intel_context *intel)
d46 2
a47 1
   struct i915_context *i915 = i915_context(&intel->ctx);
d49 6
a54 7
   i915ValidateFragmentProgram(i915);
}

static void
i915_render_start(struct intel_context *intel)
{
   intel_prepare_render(intel);
d58 2
a59 2
static void
i915_reduced_primitive_state(struct intel_context *intel, GLenum rprim)
d61 2
a62 4
   struct i915_context *i915 = i915_context(&intel->ctx);
   GLuint st1 = i915->state.Stipple[I915_STPREG_ST1];

   st1 &= ~ST1_ENABLE;
d64 1
a64 11
   switch (rprim) {
   case GL_QUADS: /* from RASTERIZE(GL_QUADS) in t_dd_tritemp.h */
   case GL_TRIANGLES:
      if (intel->ctx.Polygon.StippleFlag && intel->hw_stipple)
         st1 |= ST1_ENABLE;
      break;
   case GL_LINES:
   case GL_POINTS:
   default:
      break;
   }
d66 12
a77 1
   i915->intel.reduced_primitive = rprim;
d79 1
a79 2
   if (st1 != i915->state.Stipple[I915_STPREG_ST1]) {
      INTEL_FIREVERTICES(intel);
d81 4
a84 3
      I915_STATECHANGE(i915, I915_UPLOAD_STIPPLE);
      i915->state.Stipple[I915_STPREG_ST1] = st1;
   }
d91 2
a92 2
static GLboolean
i915_check_vertex_size(struct intel_context *intel, GLuint expected)
d94 3
a96 3
   struct i915_context *i915 = i915_context(&intel->ctx);
   int lis2 = i915->state.Ctx[I915_CTXREG_LIS2];
   int lis4 = i915->state.Ctx[I915_CTXREG_LIS4];
d100 5
a104 13
   case S4_VFMT_XY:
      sz = 2;
      break;
   case S4_VFMT_XYZ:
      sz = 3;
      break;
   case S4_VFMT_XYW:
      sz = 3;
      break;
   case S4_VFMT_XYZW:
      sz = 4;
      break;
   default:
d109 7
a115 12
   if (lis4 & S4_VFMT_SPEC_FOG)
      sz++;
   if (lis4 & S4_VFMT_COLOR)
      sz++;
   if (lis4 & S4_VFMT_DEPTH_OFFSET)
      sz++;
   if (lis4 & S4_VFMT_POINT_WIDTH)
      sz++;
   if (lis4 & S4_VFMT_FOG_PARAM)
      sz++;

   for (i = 0; i < 8; i++) {
d117 7
a123 20
      case TEXCOORDFMT_2D:
         sz += 2;
         break;
      case TEXCOORDFMT_3D:
         sz += 3;
         break;
      case TEXCOORDFMT_4D:
         sz += 4;
         break;
      case TEXCOORDFMT_1D:
         sz += 1;
         break;
      case TEXCOORDFMT_2D_16:
         sz += 1;
         break;
      case TEXCOORDFMT_4D_16:
         sz += 2;
         break;
      case TEXCOORDFMT_NOT_PRESENT:
         break;
d125 2
a126 2
         fprintf(stderr, "bad texcoord fmt %d\n", i);
         return GL_FALSE;
d130 2
a131 2

   if (sz != expected)
d133 1
a133 1

d138 1
a138 2
static void
i915_emit_invarient_state(struct intel_context *intel)
d142 1
a142 1
   BEGIN_BATCH(17);
d145 4
a148 3
             AA_LINE_ECAAR_WIDTH_ENABLE |
             AA_LINE_ECAAR_WIDTH_1_0 |
             AA_LINE_REGION_WIDTH_ENABLE | AA_LINE_REGION_WIDTH_1_0);
d161 18
a178 5
             CSB_TCB(0, 0) |
             CSB_TCB(1, 1) |
             CSB_TCB(2, 2) |
             CSB_TCB(3, 3) |
             CSB_TCB(4, 4) | CSB_TCB(5, 5) | CSB_TCB(6, 6) | CSB_TCB(7, 7));
d182 3
a184 1
   OUT_BATCH(_3DSTATE_LOAD_STATE_IMMEDIATE_1 | I1_LOAD_S(3) | (0));
d186 1
a186 1

d188 2
a189 1
   OUT_BATCH(_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);
d197 1
a197 1
   OUT_BATCH(_3DSTATE_LOAD_INDIRECT | 0);       /* disable indirect state */
d200 6
d210 8
a217 2
#define emit(intel, state, size )		     \
   intel_batchbuffer_data(intel->batch, state, size, false)
d219 1
a219 2
static GLuint
get_dirty(struct i915_hw_state *state)
d230 1
d235 1
a235 2
static GLuint
get_state_size(struct i915_hw_state *state)
d242 1
a242 4
      sz += 30 * 4;

   if (dirty & I915_UPLOAD_RASTER_RULES)
      sz += sizeof(state->RasterRules);
d247 1
a247 1
   if (dirty & I915_UPLOAD_BUFFERS)
d253 1
a253 1
   if (dirty & I915_UPLOAD_FOG)
d258 3
a260 3
      for (i = 0; i < I915_TEX_UNITS; i++)
         if (dirty & I915_UPLOAD_TEX(i))
            nr++;
d262 1
a262 1
      sz += (2 + nr * 3) * sizeof(GLuint) * 2;
d265 1
a265 1
   if (dirty & I915_UPLOAD_CONSTANTS)
d268 1
a268 1
   if (dirty & I915_UPLOAD_PROGRAM)
d274 1
d277 1
a277 2
static void
i915_emit_state(struct intel_context *intel)
d279 5
a283 6
   struct i915_context *i915 = i915_context(&intel->ctx);
   struct i915_hw_state *state = &i915->state;
   int i, count, aper_count;
   GLuint dirty;
   drm_intel_bo *aper_array[3 + I915_TEX_UNITS];
   GET_CURRENT_CONTEXT(ctx);
d286 4
a289 31
   /* We don't hold the lock at this point, so want to make sure that
    * there won't be a buffer wrap between the state emits and the primitive
    * emit header.
    *
    * It might be better to talk about explicit places where
    * scheduling is allowed, rather than assume that it is whenever a
    * batchbuffer fills up.
    */
   intel_batchbuffer_require_space(intel->batch,
				   get_state_size(state) + INTEL_PRIM_EMIT_SIZE,
				   false);
   count = 0;
 again:
   aper_count = 0;
   dirty = get_dirty(state);

   aper_array[aper_count++] = intel->batch->buf;
   if (dirty & I915_UPLOAD_BUFFERS) {
      aper_array[aper_count++] = state->draw_region->buffer;
      if (state->depth_region)
	 aper_array[aper_count++] = state->depth_region->buffer;
   }

   if (dirty & I915_UPLOAD_TEX_ALL) {
      for (i = 0; i < I915_TEX_UNITS; i++) {
	 if (dirty & I915_UPLOAD_TEX(i)) {
	    if (state->tex_buffer[i]) {
	       aper_array[aper_count++] = state->tex_buffer[i];
	    }
	 }
      }
d292 1
a292 21
   if (dri_bufmgr_check_aperture_space(aper_array, aper_count)) {
       if (count == 0) {
	   count++;
	   intel_batchbuffer_flush(intel->batch);
	   goto again;
       } else {
	   _mesa_error(ctx, GL_OUT_OF_MEMORY, "i915 emit state");
	   assert(0);
       }
   }

   /* work out list of buffers to emit */
   
   /* Do this here as we may have flushed the batchbuffer above,
    * causing more state to be dirty!
    */
   dirty = get_dirty(state);
   state->emitted |= dirty;
   assert(get_dirty(state) == 0);

   if (INTEL_DEBUG & DEBUG_STATE)
d296 2
a297 9
      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_INVARIENT:\n");
      i915_emit_invarient_state(intel);
   }

   if (dirty & I915_UPLOAD_RASTER_RULES) {
      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_RASTER_RULES:\n");
      emit(intel, state->RasterRules, sizeof(state->RasterRules));
d301 2
a302 4
      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_CTX:\n");

      emit(intel, state->Ctx, sizeof(state->Ctx));
d306 2
a307 40
      GLuint count;

      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_BUFFERS:\n");

      count = 14;
      if (state->Buffer[I915_DESTREG_DRAWRECT0] != MI_NOOP)
         count++;
      if (state->depth_region)
         count += 3;

      BEGIN_BATCH(count);
      OUT_BATCH(state->Buffer[I915_DESTREG_CBUFADDR0]);
      OUT_BATCH(state->Buffer[I915_DESTREG_CBUFADDR1]);
      OUT_RELOC(state->draw_region->buffer,
		I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER, 0);

      if (state->depth_region) {
         OUT_BATCH(state->Buffer[I915_DESTREG_DBUFADDR0]);
         OUT_BATCH(state->Buffer[I915_DESTREG_DBUFADDR1]);
         OUT_RELOC(state->depth_region->buffer,
		   I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER, 0);
      }

      OUT_BATCH(state->Buffer[I915_DESTREG_DV0]);
      OUT_BATCH(state->Buffer[I915_DESTREG_DV1]);
      OUT_BATCH(state->Buffer[I915_DESTREG_SENABLE]);
      OUT_BATCH(state->Buffer[I915_DESTREG_SR0]);
      OUT_BATCH(state->Buffer[I915_DESTREG_SR1]);
      OUT_BATCH(state->Buffer[I915_DESTREG_SR2]);

      if (state->Buffer[I915_DESTREG_DRAWRECT0] != MI_NOOP)
         OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT0]);
      OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT1]);
      OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT2]);
      OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT3]);
      OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT4]);
      OUT_BATCH(state->Buffer[I915_DESTREG_DRAWRECT5]);

      ADVANCE_BATCH();
d311 2
a312 3
      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_STIPPLE:\n");
      emit(intel, state->Stipple, sizeof(state->Stipple));
d316 2
a317 3
      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_FOG:\n");
      emit(intel, state->Fog, sizeof(state->Fog));
d326 3
a328 3
      for (i = 0; i < I915_TEX_UNITS; i++)
         if (dirty & I915_UPLOAD_TEX(i))
            nr++;
d330 2
a331 2
      BEGIN_BATCH(2 + nr * 3);
      OUT_BATCH(_3DSTATE_MAP_STATE | (3 * nr));
d333 6
a338 15
      for (i = 0; i < I915_TEX_UNITS; i++)
         if (dirty & I915_UPLOAD_TEX(i)) {

            if (state->tex_buffer[i]) {
               OUT_RELOC(state->tex_buffer[i],
			 I915_GEM_DOMAIN_SAMPLER, 0,
                         state->tex_offset[i]);
            }
            else {
               OUT_BATCH(state->tex_offset[i]);
            }

            OUT_BATCH(state->Tex[i][I915_TEXREG_MS3]);
            OUT_BATCH(state->Tex[i][I915_TEXREG_MS4]);
         }
d341 2
a342 2
      BEGIN_BATCH(2 + nr * 3);
      OUT_BATCH(_3DSTATE_SAMPLER_STATE | (3 * nr));
d344 6
a349 6
      for (i = 0; i < I915_TEX_UNITS; i++)
         if (dirty & I915_UPLOAD_TEX(i)) {
            OUT_BATCH(state->Tex[i][I915_TEXREG_SS2]);
            OUT_BATCH(state->Tex[i][I915_TEXREG_SS3]);
            OUT_BATCH(state->Tex[i][I915_TEXREG_SS4]);
         }
d354 2
a355 3
      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_CONSTANTS:\n");
      emit(intel, state->Constant, state->ConstantSize * sizeof(GLuint));
d359 7
a365 10
      if (state->ProgramSize) {
         if (INTEL_DEBUG & DEBUG_STATE)
            fprintf(stderr, "I915_UPLOAD_PROGRAM:\n");

         assert((state->Program[0] & 0x1ff) + 2 == state->ProgramSize);

         emit(intel, state->Program, state->ProgramSize * sizeof(GLuint));
         if (INTEL_DEBUG & DEBUG_STATE)
            i915_disassemble_program(state->Program, state->ProgramSize);
      }
d368 3
a370 3
   intel->batch->dirty_state &= ~dirty;
   assert(get_dirty(state) == 0);
   assert((intel->batch->dirty_state & (1<<1)) == 0);
d373 1
a373 2
static void
i915_destroy_context(struct intel_context *intel)
a374 13
   GLuint i;
   struct i915_context *i915 = i915_context(&intel->ctx);

   intel_region_release(&i915->state.draw_region);
   intel_region_release(&i915->state.depth_region);

   for (i = 0; i < I915_TEX_UNITS; i++) {
      if (i915->state.tex_buffer[i] != NULL) {
	 drm_intel_bo_unreference(i915->state.tex_buffer[i]);
	 i915->state.tex_buffer[i] = NULL;
      }
   }

a377 17
void
i915_set_buf_info_for_region(uint32_t *state, struct intel_region *region,
			     uint32_t buffer_id)
{
   state[0] = _3DSTATE_BUF_INFO_CMD;
   state[1] = buffer_id;

   if (region != NULL) {
      state[1] |= BUF_3D_PITCH(region->pitch * region->cpp);

      if (region->tiling != I915_TILING_NONE) {
	 state[1] |= BUF_3D_TILED_SURFACE;
	 if (region->tiling == I915_TILING_Y)
	    state[1] |= BUF_3D_TILE_WALK_Y;
      }
   }
}
d379 3
d383 8
a390 21
i915_set_draw_region(struct intel_context *intel,
                     struct intel_region *color_regions[],
                     struct intel_region *depth_region,
		     GLuint num_regions)
{
   struct i915_context *i915 = i915_context(&intel->ctx);
   struct gl_context *ctx = &intel->ctx;
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0];
   struct intel_renderbuffer *irb = intel_renderbuffer(rb);
   GLuint value;
   struct i915_hw_state *state = &i915->state;
   uint32_t draw_x, draw_y, draw_offset;

   if (state->draw_region != color_regions[0]) {
      intel_region_release(&state->draw_region);
      intel_region_reference(&state->draw_region, color_regions[0]);
   }
   if (state->depth_region != depth_region) {
      intel_region_release(&state->depth_region);
      intel_region_reference(&state->depth_region, depth_region);
   }
a391 5
   /*
    * Set stride/cpp values
    */
   i915_set_buf_info_for_region(&state->Buffer[I915_DESTREG_CBUFADDR0],
				color_regions[0], BUF_3D_ID_COLOR_BACK);
d393 12
a404 29
   i915_set_buf_info_for_region(&state->Buffer[I915_DESTREG_DBUFADDR0],
				depth_region, BUF_3D_ID_DEPTH);

   /*
    * Compute/set I915_DESTREG_DV1 value
    */
   value = (DSTORG_HORT_BIAS(0x8) |     /* .5 */
            DSTORG_VERT_BIAS(0x8) |     /* .5 */
            LOD_PRECLAMP_OGL | TEX_DEFAULT_COLOR_OGL);
   if (irb != NULL) {
      switch (irb->Base.Format) {
      case MESA_FORMAT_ARGB8888:
      case MESA_FORMAT_XRGB8888:
	 value |= DV_PF_8888;
	 break;
      case MESA_FORMAT_RGB565:
	 value |= DV_PF_565 | DITHER_FULL_ALWAYS;
	 break;
      case MESA_FORMAT_ARGB1555:
	 value |= DV_PF_1555 | DITHER_FULL_ALWAYS;
	 break;
      case MESA_FORMAT_ARGB4444:
	 value |= DV_PF_4444 | DITHER_FULL_ALWAYS;
	 break;
      default:
	 _mesa_problem(ctx, "Bad renderbuffer format: %d\n",
		       irb->Base.Format);
      }
   }
a405 7
   /* This isn't quite safe, thus being hidden behind an option.  When changing
    * the value of this bit, the pipeline needs to be MI_FLUSHed.  And it
    * can only be set when a depth buffer is already defined.
    */
   if (intel->is_945 && intel->use_early_z &&
       depth_region->tiling != I915_TILING_NONE)
      value |= CLASSIC_EARLY_DEPTH;
d407 10
a416 7
   if (depth_region && depth_region->cpp == 4) {
      value |= DEPTH_FRMT_24_FIXED_8_OTHER;
   }
   else {
      value |= DEPTH_FRMT_16_FIXED;
   }
   state->Buffer[I915_DESTREG_DV1] = value;
d418 3
a420 46
   /* We set up the drawing rectangle to be offset into the color
    * region's location in the miptree.  If it doesn't match with
    * depth's offsets, we can't render to it.
    *
    * (Well, not actually true -- the hw grew a bit to let depth's
    * offset get forced to 0,0.  We may want to use that if people are
    * hitting that case.  Also, some configurations may be supportable
    * by tweaking the start offset of the buffers around, which we
    * can't do in general due to tiling)
    */
   FALLBACK(intel, I915_FALLBACK_DRAW_OFFSET,
	    (depth_region && color_regions[0]) &&
	    (depth_region->draw_x != color_regions[0]->draw_x ||
	     depth_region->draw_y != color_regions[0]->draw_y));

   if (color_regions[0]) {
      draw_x = color_regions[0]->draw_x;
      draw_y = color_regions[0]->draw_y;
   } else if (depth_region) {
      draw_x = depth_region->draw_x;
      draw_y = depth_region->draw_y;
   } else {
      draw_x = 0;
      draw_y = 0;
   }

   draw_offset = (draw_y << 16) | draw_x;

   /* When changing drawing rectangle offset, an MI_FLUSH is first required. */
   if (draw_offset != i915->last_draw_offset) {
      FALLBACK(intel, I915_FALLBACK_DRAW_OFFSET,
               (ctx->DrawBuffer->Width + draw_x > 2048) ||
               (ctx->DrawBuffer->Height + draw_y > 2048));

      state->Buffer[I915_DESTREG_DRAWRECT0] = MI_FLUSH | INHIBIT_FLUSH_RENDER_CACHE;
      i915->last_draw_offset = draw_offset;
   } else
      state->Buffer[I915_DESTREG_DRAWRECT0] = MI_NOOP;

   state->Buffer[I915_DESTREG_DRAWRECT1] = _3DSTATE_DRAWRECT_INFO;
   state->Buffer[I915_DESTREG_DRAWRECT2] = 0;
   state->Buffer[I915_DESTREG_DRAWRECT3] = draw_offset;
   state->Buffer[I915_DESTREG_DRAWRECT4] =
      ((ctx->DrawBuffer->Width + draw_x - 1) & 0xffff) |
      ((ctx->DrawBuffer->Height + draw_y - 1) << 16);
   state->Buffer[I915_DESTREG_DRAWRECT5] = draw_offset;
d422 5
a426 1
   I915_STATECHANGE(i915, I915_UPLOAD_BUFFERS);
d430 4
d435 1
a435 2
static void
i915_new_batch(struct intel_context *intel)
d437 1
a437 1
   struct i915_context *i915 = i915_context(&intel->ctx);
d439 4
a442 6
   /* Mark all state as needing to be emitted when starting a new batchbuffer.
    * Using hardware contexts would be an alternative, but they have some
    * difficulties associated with them (physical address requirements).
    */
   i915->state.emitted = 0;
   i915->last_draw_offset = 0;
a444 8
static void 
i915_assert_not_dirty( struct intel_context *intel )
{
   struct i915_context *i915 = i915_context(&intel->ctx);
   GLuint dirty = get_dirty(&i915->state);
   assert(!dirty);
   (void) dirty;
}
d446 1
a446 2
void
i915InitVtbl(struct i915_context *i915)
d448 1
d450 2
d454 1
a454 1
   i915->intel.vtbl.new_batch = i915_new_batch;
d457 3
a459 2
   i915->intel.vtbl.render_prevalidate = i915_render_prevalidate;
   i915->intel.vtbl.set_draw_region = i915_set_draw_region;
d461 1
a461 2
   i915->intel.vtbl.assert_not_dirty = i915_assert_not_dirty;
   i915->intel.vtbl.finish_batch = intel_finish_vb;
d463 1
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@a34 2
#include "main/renderbuffer.h"
#include "main/framebuffer.h"
a35 1
#include "tnl/tnl.h"
a37 1
#include "swrast_setup/swrast_setup.h"
a39 1
#include "intel_mipmap_tree.h"
a42 1
#include "intel_buffers.h"
d96 1
a96 1
static bool
d157 1
a157 1
         return false;
d220 1
a220 1
   intel_batchbuffer_data(intel, state, size)
a253 3
   if (dirty & I915_UPLOAD_BLEND)
      sz += sizeof(state->Blend);

d260 3
d302 3
a304 3
   intel_batchbuffer_require_space(intel,
				   get_state_size(state) +
                                   INTEL_PRIM_EMIT_SIZE);
a306 4
   if (intel->batch.bo == NULL) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "i915 emit state");
      assert(0);
   }
d310 1
a310 1
   aper_array[aper_count++] = intel->batch.bo;
d312 1
a312 2
      if (state->draw_region)
	 aper_array[aper_count++] = state->draw_region->bo;
d314 1
a314 1
	 aper_array[aper_count++] = state->depth_region->bo;
d330 1
a330 1
	   intel_batchbuffer_flush(intel);
a368 7
   if (dirty & I915_UPLOAD_BLEND) {
      if (INTEL_DEBUG & DEBUG_STATE)
         fprintf(stderr, "I915_UPLOAD_BLEND:\n");

      emit(intel, state->Blend, sizeof(state->Blend));
   }

d375 1
a375 1
      count = 17;
d378 2
d384 2
a385 6
      if (state->draw_region) {
	 OUT_RELOC(state->draw_region->bo,
		   I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER, 0);
      } else {
	 OUT_BATCH(0);
      }
a386 2
      OUT_BATCH(state->Buffer[I915_DESTREG_DBUFADDR0]);
      OUT_BATCH(state->Buffer[I915_DESTREG_DBUFADDR1]);
d388 3
a390 1
         OUT_RELOC(state->depth_region->bo,
a391 2
      } else {
	 OUT_BATCH(0);
d418 6
a428 1
      GLuint unwind;
d439 9
a447 3
	    OUT_RELOC(state->tex_buffer[i],
		      I915_GEM_DOMAIN_SAMPLER, 0,
		      state->tex_offset[i]);
a453 1
      unwind = intel->batch.used;
a463 7
      if (i915->last_sampler &&
	  memcmp(intel->batch.map + i915->last_sampler,
		 intel->batch.map + unwind,
		 (2 + nr*3)*sizeof(int)) == 0)
	  intel->batch.used = unwind;
      else
	  i915->last_sampler = unwind;
d485 1
d487 1
d517 1
a517 1
      state[1] |= BUF_3D_PITCH(region->pitch);
a523 28
   } else {
      /* Fill in a default pitch, since 0 is invalid.  We'll be
       * setting the buffer offset to 0 and not referencing the
       * buffer, so the pitch could really be any valid value.
       */
      state[1] |= BUF_3D_PITCH(4096);
   }
}

static uint32_t i915_render_target_format_for_mesa_format[MESA_FORMAT_COUNT] =
{
   [MESA_FORMAT_ARGB8888] = DV_PF_8888,
   [MESA_FORMAT_XRGB8888] = DV_PF_8888,
   [MESA_FORMAT_RGB565] = DV_PF_565 | DITHER_FULL_ALWAYS,
   [MESA_FORMAT_ARGB1555] = DV_PF_1555 | DITHER_FULL_ALWAYS,
   [MESA_FORMAT_ARGB4444] = DV_PF_4444 | DITHER_FULL_ALWAYS,
};

static bool
i915_render_target_supported(struct intel_context *intel,
			     struct gl_renderbuffer *rb)
{
   gl_format format = rb->Format;

   if (format == MESA_FORMAT_S8_Z24 ||
       format == MESA_FORMAT_X8_Z24 ||
       format == MESA_FORMAT_Z16) {
      return true;
a524 2

   return i915_render_target_format_for_mesa_format[format] != 0;
a536 2
   struct gl_renderbuffer *drb;
   struct intel_renderbuffer *idrb = NULL;
d542 1
d546 1
d566 18
a583 3
      value |= i915_render_target_format_for_mesa_format[intel_rb_format(irb)];
   } else {
      value |= DV_PF_8888;
a601 7
   drb = ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
   if (!drb)
      drb = ctx->DrawBuffer->Attachment[BUFFER_STENCIL].Renderbuffer;

   if (drb)
      idrb = intel_renderbuffer(drb);

d613 10
a622 9
	    idrb && irb && (idrb->draw_x != irb->draw_x ||
			    idrb->draw_y != irb->draw_y));

   if (irb) {
      draw_x = irb->draw_x;
      draw_y = irb->draw_y;
   } else if (idrb) {
      draw_x = idrb->draw_x;
      draw_y = idrb->draw_y;
a629 3
   FALLBACK(intel, I915_FALLBACK_DRAW_OFFSET,
            (ctx->DrawBuffer->Width + draw_x > 2048) ||
            (ctx->DrawBuffer->Height + draw_y > 2048));
d632 4
a651 13
static void
i915_update_color_write_enable(struct i915_context *i915, bool enable)
{
   uint32_t dw = i915->state.Ctx[I915_CTXREG_LIS6];
   if (enable)
      dw |= S6_COLOR_WRITE_ENABLE;
   else
      dw &= ~S6_COLOR_WRITE_ENABLE;
   if (dw != i915->state.Ctx[I915_CTXREG_LIS6]) {
      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
      i915->state.Ctx[I915_CTXREG_LIS6] = dw;
   }
}
a652 120
/**
 * Update the hardware state for drawing into a window or framebuffer object.
 *
 * Called by glDrawBuffer, glBindFramebufferEXT, MakeCurrent, and other
 * places within the driver.
 *
 * Basically, this needs to be called any time the current framebuffer
 * changes, the renderbuffers change, or we need to draw into different
 * color buffers.
 */
static void
i915_update_draw_buffer(struct intel_context *intel)
{
   struct i915_context *i915 = (struct i915_context *)intel;
   struct gl_context *ctx = &intel->ctx;
   struct gl_framebuffer *fb = ctx->DrawBuffer;
   struct intel_region *colorRegion = NULL, *depthRegion = NULL;
   struct intel_renderbuffer *irbDepth = NULL, *irbStencil = NULL;

   if (!fb) {
      /* this can happen during the initial context initialization */
      return;
   }

   irbDepth = intel_get_renderbuffer(fb, BUFFER_DEPTH);
   irbStencil = intel_get_renderbuffer(fb, BUFFER_STENCIL);

   /* Do this here, not core Mesa, since this function is called from
    * many places within the driver.
    */
   if (ctx->NewState & _NEW_BUFFERS) {
      /* this updates the DrawBuffer->_NumColorDrawBuffers fields, etc */
      _mesa_update_framebuffer(ctx);
      /* this updates the DrawBuffer's Width/Height if it's a FBO */
      _mesa_update_draw_buffer_bounds(ctx);
   }

   if (fb->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
      /* this may occur when we're called by glBindFrameBuffer() during
       * the process of someone setting up renderbuffers, etc.
       */
      /*_mesa_debug(ctx, "DrawBuffer: incomplete user FBO\n");*/
      return;
   }

   /* How many color buffers are we drawing into?
    *
    * If there is more than one drawbuffer (GL_FRONT_AND_BACK), or the
    * drawbuffers are too big, we have to fallback to software.
    */
   if ((fb->Width > ctx->Const.MaxRenderbufferSize)
       || (fb->Height > ctx->Const.MaxRenderbufferSize)) {
      FALLBACK(intel, INTEL_FALLBACK_DRAW_BUFFER, true);
   } else if (fb->_NumColorDrawBuffers > 1) {
      FALLBACK(intel, INTEL_FALLBACK_DRAW_BUFFER, true);
   } else {
      struct intel_renderbuffer *irb;
      irb = intel_renderbuffer(fb->_ColorDrawBuffers[0]);
      colorRegion = (irb && irb->mt) ? irb->mt->region : NULL;
      FALLBACK(intel, INTEL_FALLBACK_DRAW_BUFFER, false);
   }

   /* Check for depth fallback. */
   if (irbDepth && irbDepth->mt) {
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, false);
      depthRegion = irbDepth->mt->region;
   } else if (irbDepth && !irbDepth->mt) {
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, true);
      depthRegion = NULL;
   } else { /* !irbDepth */
      /* No fallback is needed because there is no depth buffer. */
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, false);
      depthRegion = NULL;
   }

   /* Check for stencil fallback. */
   if (irbStencil && irbStencil->mt) {
      assert(intel_rb_format(irbStencil) == MESA_FORMAT_S8_Z24);
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, false);
   } else if (irbStencil && !irbStencil->mt) {
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, true);
   } else { /* !irbStencil */
      /* No fallback is needed because there is no stencil buffer. */
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, false);
   }

   /* If we have a (packed) stencil buffer attached but no depth buffer,
    * we still need to set up the shared depth/stencil state so we can use it.
    */
   if (depthRegion == NULL && irbStencil && irbStencil->mt
       && intel_rb_format(irbStencil) == MESA_FORMAT_S8_Z24) {
      depthRegion = irbStencil->mt->region;
   }

   /*
    * Update depth and stencil test state
    */
   ctx->Driver.Enable(ctx, GL_DEPTH_TEST, ctx->Depth.Test);
   ctx->Driver.Enable(ctx, GL_STENCIL_TEST, ctx->Stencil.Enabled);

   i915_update_color_write_enable(i915, colorRegion != NULL);

   intel->vtbl.set_draw_region(intel, &colorRegion, depthRegion,
                               fb->_NumColorDrawBuffers);
   intel->NewGLState |= _NEW_BUFFERS;

   /* update viewport since it depends on window size */
   intelCalcViewport(ctx);

   /* Set state we know depends on drawable parameters:
    */
   ctx->Driver.Scissor(ctx, ctx->Scissor.X, ctx->Scissor.Y,
		       ctx->Scissor.Width, ctx->Scissor.Height);
   ctx->Driver.DepthRange(ctx, ctx->Viewport.Near, ctx->Viewport.Far);

   /* Update culling direction which changes depending on the
    * orientation of the buffer:
    */
   ctx->Driver.FrontFace(ctx, ctx->Polygon.FrontFace);
}
a664 4
   i915->last_sampler = 0;

   i915->current_vb_bo = NULL;
   i915->current_vertex_size = 0;
a675 10
static void
i915_invalidate_state(struct intel_context *intel, GLuint new_state)
{
   struct gl_context *ctx = &intel->ctx;

   _swsetup_InvalidateState(ctx, new_state);
   _tnl_InvalidateState(ctx, new_state);
   _tnl_invalidate_vertex_state(ctx, new_state);
}

a686 1
   i915->intel.vtbl.update_draw_buffer = i915_update_draw_buffer;
a689 2
   i915->intel.vtbl.invalidate_state = i915_invalidate_state;
   i915->intel.vtbl.render_target_supported = i915_render_target_supported;
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d552 5
a556 5
   [MESA_FORMAT_B8G8R8A8_UNORM] = DV_PF_8888,
   [MESA_FORMAT_B8G8R8X8_UNORM] = DV_PF_8888,
   [MESA_FORMAT_B5G6R5_UNORM] = DV_PF_565 | DITHER_FULL_ALWAYS,
   [MESA_FORMAT_B5G5R5A1_UNORM] = DV_PF_1555 | DITHER_FULL_ALWAYS,
   [MESA_FORMAT_B4G4R4A4_UNORM] = DV_PF_4444 | DITHER_FULL_ALWAYS,
d563 1
a563 1
   mesa_format format = rb->Format;
d565 3
a567 3
   if (format == MESA_FORMAT_Z24_UNORM_S8_UINT ||
       format == MESA_FORMAT_Z24_UNORM_X8_UINT ||
       format == MESA_FORMAT_Z_UNORM16) {
d780 1
a780 1
      assert(intel_rb_format(irbStencil) == MESA_FORMAT_Z24_UNORM_S8_UINT);
d793 1
a793 1
       && intel_rb_format(irbStencil) == MESA_FORMAT_Z24_UNORM_S8_UINT) {
d809 3
d814 3
a816 2
   intelCalcViewport(ctx);
   ctx->Driver.Scissor(ctx);
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@d209 3
a215 3
   /* XXX: Use this */
   OUT_BATCH(_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);

d418 1
a421 1
      OUT_BATCH(state->Buffer[I915_DESTREG_SENABLE]);
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@a208 3
   /* XXX: Use this */
   OUT_BATCH(_3DSTATE_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);

d213 3
a417 1
      OUT_BATCH(state->Buffer[I915_DESTREG_SENABLE]);
d421 1
@


