head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.04.22;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.41;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.52;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.11.49;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.48.54;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics to
 develop this 3D driver.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */

#include "main/mtypes.h"
#include "program/prog_parameter.h"

#include "brw_context.h"
#include "brw_state.h"
#include "intel_buffer_objects.h"

void
brw_upload_vec4_pull_constants(struct brw_context *brw,
                               GLbitfield brw_new_constbuf,
                               const struct gl_program *prog,
                               struct brw_stage_state *stage_state,
                               const struct brw_vec4_prog_data *prog_data)
{
   int i;
   uint32_t surf_index = prog_data->base.binding_table.pull_constants_start;

   /* Updates the ParamaterValues[i] pointers for all parameters of the
    * basic type of PROGRAM_STATE_VAR.
    */
   _mesa_load_state_parameters(&brw->ctx, prog->Parameters);

   if (!prog_data->base.nr_pull_params) {
      if (stage_state->surf_offset[surf_index]) {
	 stage_state->surf_offset[surf_index] = 0;
	 brw->state.dirty.brw |= brw_new_constbuf;
      }
      return;
   }

   /* _NEW_PROGRAM_CONSTANTS */
   uint32_t size = prog_data->base.nr_pull_params * 4;
   drm_intel_bo *const_bo = NULL;
   uint32_t const_offset;
   float *constants = intel_upload_space(brw, size, 64,
                                         &const_bo, &const_offset);

   for (i = 0; i < prog_data->base.nr_pull_params; i++) {
      constants[i] = *prog_data->base.pull_param[i];
   }

   if (0) {
      for (i = 0; i < ALIGN(prog_data->base.nr_pull_params, 4) / 4; i++) {
	 float *row = &constants[i * 4];
	 fprintf(stderr, "const surface %3d: %4.3f %4.3f %4.3f %4.3f\n",
                 i, row[0], row[1], row[2], row[3]);
      }
   }

   brw_create_constant_surface(brw, const_bo, const_offset, size,
                               &stage_state->surf_offset[surf_index],
                               false);
   drm_intel_bo_unreference(const_bo);

   brw->state.dirty.brw |= brw_new_constbuf;
}


/* Creates a new VS constant buffer reflecting the current VS program's
 * constants, if needed by the VS program.
 *
 * Otherwise, constants go through the CURBEs using the brw_constant_buffer
 * state atom.
 */
static void
brw_upload_vs_pull_constants(struct brw_context *brw)
{
   struct brw_stage_state *stage_state = &brw->vs.base;

   /* BRW_NEW_VERTEX_PROGRAM */
   struct brw_vertex_program *vp =
      (struct brw_vertex_program *) brw->vertex_program;

   /* CACHE_NEW_VS_PROG */
   const struct brw_vec4_prog_data *prog_data = &brw->vs.prog_data->base;

   /* _NEW_PROGRAM_CONSTANTS */
   brw_upload_vec4_pull_constants(brw, BRW_NEW_VS_CONSTBUF, &vp->program.Base,
                                  stage_state, prog_data);
}

const struct brw_tracked_state brw_vs_pull_constants = {
   .dirty = {
      .mesa = (_NEW_PROGRAM_CONSTANTS),
      .brw = (BRW_NEW_BATCH | BRW_NEW_VERTEX_PROGRAM),
      .cache = CACHE_NEW_VS_PROG,
   },
   .emit = brw_upload_vs_pull_constants,
};

static void
brw_upload_vs_ubo_surfaces(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   /* _NEW_PROGRAM */
   struct gl_shader_program *prog =
      ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX];

   if (!prog)
      return;

   /* CACHE_NEW_VS_PROG */
   brw_upload_ubo_surfaces(brw, prog->_LinkedShaders[MESA_SHADER_VERTEX],
			   &brw->vs.base, &brw->vs.prog_data->base.base);
}

const struct brw_tracked_state brw_vs_ubo_surfaces = {
   .dirty = {
      .mesa = _NEW_PROGRAM,
      .brw = BRW_NEW_BATCH | BRW_NEW_UNIFORM_BUFFER,
      .cache = CACHE_NEW_VS_PROG,
   },
   .emit = brw_upload_vs_ubo_surfaces,
};

static void
brw_upload_vs_abo_surfaces(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   /* _NEW_PROGRAM */
   struct gl_shader_program *prog =
      ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX];

   if (prog) {
      /* CACHE_NEW_VS_PROG */
      brw_upload_abo_surfaces(brw, prog, &brw->vs.base,
                              &brw->vs.prog_data->base.base);
   }
}

const struct brw_tracked_state brw_vs_abo_surfaces = {
   .dirty = {
      .mesa = _NEW_PROGRAM,
      .brw = BRW_NEW_BATCH | BRW_NEW_ATOMIC_BUFFER,
      .cache = CACHE_NEW_VS_PROG,
   },
   .emit = brw_upload_vs_abo_surfaces,
};
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a38 12
/**
 * Creates a temporary BO containing the pull constant data for the shader
 * stage, and the SURFACE_STATE struct that points at it.
 *
 * Pull constants are GLSL uniforms (and other constant data) beyond what we
 * could fit as push constants, or that have variable-index array access
 * (which is easiest to support using pull constants, and avoids filling
 * register space with mostly-unused data).
 *
 * Compare this path to brw_curbe.c for gen4/5 push constants, and
 * gen6_vs_state.c for gen6+ push constants.
 */
d40 5
a44 6
brw_upload_pull_constants(struct brw_context *brw,
                          GLbitfield brw_new_constbuf,
                          const struct gl_program *prog,
                          struct brw_stage_state *stage_state,
                          const struct brw_stage_prog_data *prog_data,
                          bool dword_pitch)
d47 1
a47 1
   uint32_t surf_index = prog_data->binding_table.pull_constants_start;
d54 1
a54 1
   if (!prog_data->nr_pull_params) {
d62 2
a63 2
   /* CACHE_NEW_*_PROG | _NEW_PROGRAM_CONSTANTS */
   uint32_t size = prog_data->nr_pull_params * 4;
d66 2
a67 4
   gl_constant_value *constants = intel_upload_space(brw, size, 64,
                                                     &const_bo, &const_offset);

   STATIC_ASSERT(sizeof(gl_constant_value) == sizeof(float));
d69 2
a70 2
   for (i = 0; i < prog_data->nr_pull_params; i++) {
      constants[i] = *prog_data->pull_param[i];
d74 2
a75 2
      for (i = 0; i < ALIGN(prog_data->nr_pull_params, 4) / 4; i++) {
	 const gl_constant_value *row = &constants[i * 4];
d77 1
a77 1
                 i, row[0].f, row[1].f, row[2].f, row[3].f);
d83 1
a83 1
                               dword_pitch);
d106 1
a106 1
   const struct brw_stage_prog_data *prog_data = &brw->vs.prog_data->base.base;
d109 2
a110 2
   brw_upload_pull_constants(brw, BRW_NEW_VS_CONSTBUF, &vp->program.Base,
                             stage_state, prog_data, false);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d39 12
d52 6
a57 5
brw_upload_vec4_pull_constants(struct brw_context *brw,
                               GLbitfield brw_new_constbuf,
                               const struct gl_program *prog,
                               struct brw_stage_state *stage_state,
                               const struct brw_vec4_prog_data *prog_data)
d60 1
a60 1
   uint32_t surf_index = prog_data->base.binding_table.pull_constants_start;
d67 1
a67 1
   if (!prog_data->base.nr_pull_params) {
d75 2
a76 2
   /* _NEW_PROGRAM_CONSTANTS */
   uint32_t size = prog_data->base.nr_pull_params * 4;
d79 4
a82 2
   float *constants = intel_upload_space(brw, size, 64,
                                         &const_bo, &const_offset);
d84 2
a85 2
   for (i = 0; i < prog_data->base.nr_pull_params; i++) {
      constants[i] = *prog_data->base.pull_param[i];
d89 2
a90 2
      for (i = 0; i < ALIGN(prog_data->base.nr_pull_params, 4) / 4; i++) {
	 float *row = &constants[i * 4];
d92 1
a92 1
                 i, row[0], row[1], row[2], row[3]);
d98 1
a98 1
                               false);
d121 1
a121 1
   const struct brw_vec4_prog_data *prog_data = &brw->vs.prog_data->base;
d124 2
a125 2
   brw_upload_vec4_pull_constants(brw, BRW_NEW_VS_CONSTBUF, &vp->program.Base,
                                  stage_state, prog_data);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
d29 1
a29 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d37 1
d39 6
a44 8
/* Creates a new VS constant buffer reflecting the current VS program's
 * constants, if needed by the VS program.
 *
 * Otherwise, constants go through the CURBEs using the brw_constant_buffer
 * state atom.
 */
static void
brw_upload_vs_pull_constants(struct brw_context *brw)
a45 3
   /* BRW_NEW_VERTEX_PROGRAM */
   struct brw_vertex_program *vp =
      (struct brw_vertex_program *) brw->vertex_program;
d47 1
d52 1
a52 1
   _mesa_load_state_parameters(&brw->ctx, vp->program.Base.Parameters);
d54 4
a57 7
   /* CACHE_NEW_VS_PROG */
   if (!brw->vs.prog_data->base.nr_pull_params) {
      if (brw->vs.const_bo) {
	 drm_intel_bo_unreference(brw->vs.const_bo);
	 brw->vs.const_bo = NULL;
	 brw->vs.surf_offset[SURF_INDEX_VERT_CONST_BUFFER] = 0;
	 brw->state.dirty.brw |= BRW_NEW_VS_CONSTBUF;
d63 8
a70 10
   drm_intel_bo_unreference(brw->vs.const_bo);
   uint32_t size = brw->vs.prog_data->base.nr_pull_params * 4;
   brw->vs.const_bo = drm_intel_bo_alloc(brw->bufmgr, "vp_const_buffer",
					 size, 64);

   drm_intel_gem_bo_map_gtt(brw->vs.const_bo);
   for (i = 0; i < brw->vs.prog_data->base.nr_pull_params; i++) {
      memcpy(brw->vs.const_bo->virtual + i * 4,
	     brw->vs.prog_data->base.pull_param[i],
	     4);
d74 4
a77 5
      for (i = 0; i < ALIGN(brw->vs.prog_data->base.nr_pull_params, 4) / 4;
           i++) {
	 float *row = (float *)brw->vs.const_bo->virtual + i * 4;
	 printf("vs const surface %3d: %4.3f %4.3f %4.3f %4.3f\n",
		i, row[0], row[1], row[2], row[3]);
d81 23
a103 1
   drm_intel_gem_bo_unmap_gtt(brw->vs.const_bo);
d105 2
a106 3
   const int surf = SURF_INDEX_VERT_CONST_BUFFER;
   brw->vtbl.create_constant_surface(brw, brw->vs.const_bo, 0, size,
                                     &brw->vs.surf_offset[surf], false);
d108 3
a110 1
   brw->state.dirty.brw |= BRW_NEW_VS_CONSTBUF;
d127 2
a128 1
   struct gl_shader_program *prog = ctx->Shader.CurrentVertexProgram;
d133 1
d135 1
a135 1
			   &brw->vs.surf_offset[SURF_INDEX_VS_UBO(0)]);
d142 1
a142 1
      .cache = 0,
a146 4
/**
 * Constructs the binding table for the WM surface state, which maps unit
 * numbers to surface state objects.
 */
d148 1
a148 1
brw_vs_upload_binding_table(struct brw_context *brw)
d150 4
a153 2
   uint32_t *bind;
   int i;
d155 4
a158 17
   if (INTEL_DEBUG & DEBUG_SHADER_TIME) {
      gen7_create_shader_time_surface(brw, &brw->vs.surf_offset[SURF_INDEX_VS_SHADER_TIME]);

      assert(brw->vs.prog_data->base.num_surfaces
             <= SURF_INDEX_VS_SHADER_TIME);
      brw->vs.prog_data->base.num_surfaces = SURF_INDEX_VS_SHADER_TIME;
   }

   /* CACHE_NEW_VS_PROG: Skip making a binding table if we don't use textures or
    * pull constants.
    */
   if (brw->vs.prog_data->base.num_surfaces == 0) {
      if (brw->vs.bind_bo_offset != 0) {
	 brw->state.dirty.brw |= BRW_NEW_VS_BINDING_TABLE;
	 brw->vs.bind_bo_offset = 0;
      }
      return;
a159 14

   /* Might want to calculate nr_surfaces first, to avoid taking up so much
    * space for the binding table.
    */
   bind = brw_state_batch(brw, AUB_TRACE_BINDING_TABLE,
			  sizeof(uint32_t) * BRW_MAX_VS_SURFACES,
			  32, &brw->vs.bind_bo_offset);

   /* BRW_NEW_SURFACES and BRW_NEW_VS_CONSTBUF */
   for (i = 0; i < BRW_MAX_VS_SURFACES; i++) {
      bind[i] = brw->vs.surf_offset[i];
   }

   brw->state.dirty.brw |= BRW_NEW_VS_BINDING_TABLE;
d162 1
a162 1
const struct brw_tracked_state brw_vs_binding_table = {
d164 3
a166 5
      .mesa = 0,
      .brw = (BRW_NEW_BATCH |
	      BRW_NEW_VS_CONSTBUF |
	      BRW_NEW_SURFACES),
      .cache = CACHE_NEW_VS_PROG
d168 1
a168 1
   .emit = brw_vs_upload_binding_table,
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a32 1
#include "main/texstore.h"
d45 1
a45 1
prepare_vs_constants(struct brw_context *brw)
d47 1
a47 2
   struct gl_context *ctx = &brw->intel.ctx;
   struct intel_context *intel = &brw->intel;
a49 2
   const struct gl_program_parameter_list *params = vp->program.Base.Parameters;
   const int size = params->NumParameters * 4 * sizeof(GLfloat);
a51 3
   if (vp->program.IsNVProgram)
      _mesa_load_tracked_matrices(ctx);

d55 1
a55 1
   _mesa_load_state_parameters(&brw->intel.ctx, vp->program.Base.Parameters);
d57 2
a58 2
   /* BRW_NEW_VERTEX_PROGRAM */
   if (!vp->use_const_buffer) {
d62 1
d70 2
a71 1
   brw->vs.const_bo = drm_intel_bo_alloc(intel->bufmgr, "vp_const_buffer",
d75 4
a78 4
   for (i = 0; i < params->NumParameters; i++) {
      memcpy(brw->vs.const_bo->virtual + i * 4 * sizeof(float),
	     params->ParameterValues[i],
	     4 * sizeof(float));
d82 2
a83 1
      for (i = 0; i < params->NumParameters; i++) {
d91 5
d99 1
a99 1
const struct brw_tracked_state brw_vs_constants = {
d102 2
a103 2
      .brw = (BRW_NEW_VERTEX_PROGRAM),
      .cache = 0
d105 1
a105 1
   .prepare = prepare_vs_constants,
a107 5
/**
 * Update the surface state for a VS constant buffer.
 *
 * Sets brw->vs.surf_bo[surf] and brw->vp->const_buffer.
 */
d109 1
a109 2
brw_update_vs_constant_surface( struct gl_context *ctx,
                                GLuint surf)
d111 3
a113 5
   struct brw_context *brw = brw_context(ctx);
   struct intel_context *intel = &brw->intel;
   struct brw_vertex_program *vp =
      (struct brw_vertex_program *) brw->vertex_program;
   const struct gl_program_parameter_list *params = vp->program.Base.Parameters;
d115 1
a115 7
   assert(surf == 0);

   /* If there's no constant buffer, then no surface BO is needed to point at
    * it.
    */
   if (brw->vs.const_bo == NULL) {
      brw->vs.surf_offset[surf] = 0;
a116 1
   }
d118 2
a119 7
   if (intel->gen >= 7) {
      gen7_create_constant_surface(brw, brw->vs.const_bo, params->NumParameters,
				  &brw->vs.surf_offset[surf]);
   } else {
      brw_create_constant_surface(brw, brw->vs.const_bo, params->NumParameters,
				  &brw->vs.surf_offset[surf]);
   }
d122 8
d131 4
d136 1
a136 1
prepare_vs_surfaces(struct brw_context *brw)
d138 2
a139 1
   int nr_surfaces = 0;
d141 2
a142 4
   if (brw->vs.const_bo) {
      brw_add_validated_bo(brw, brw->vs.const_bo);
      nr_surfaces = 1;
   }
d144 3
a146 3
   if (brw->vs.nr_surfaces != nr_surfaces) {
      brw->state.dirty.brw |= BRW_NEW_NR_VS_SURFACES;
      brw->vs.nr_surfaces = nr_surfaces;
a147 1
}
d149 5
a153 16
/**
 * Vertex shader surfaces (constant buffer).
 *
 * This consumes the state updates for the constant buffer needing
 * to be updated, and produces BRW_NEW_NR_VS_SURFACES for the VS unit and
 * CACHE_NEW_SURF_BIND for the binding table upload.
 */
static void upload_vs_surfaces(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->intel.ctx;
   uint32_t *bind;
   int i;

   /* BRW_NEW_NR_VS_SURFACES */
   if (brw->vs.nr_surfaces == 0) {
      if (brw->vs.bind_bo_offset) {
d155 1
a156 1
      brw->vs.bind_bo_offset = 0;
a159 2
   brw_update_vs_constant_surface(ctx, SURF_INDEX_VERT_CONST_BUFFER);

d161 1
a161 1
    * space for the binding table. (once we have vs samplers)
d163 2
a164 1
   bind = brw_state_batch(brw, sizeof(uint32_t) * BRW_VS_MAX_SURF,
d167 2
a168 2
   for (i = 0; i < BRW_VS_MAX_SURF; i++) {
      /* BRW_NEW_VS_CONSTBUF */
d175 1
a175 1
const struct brw_tracked_state brw_vs_surfaces = {
d178 4
a181 4
      .brw = (BRW_NEW_VS_CONSTBUF |
	      BRW_NEW_NR_VS_SURFACES |
	      BRW_NEW_BATCH),
      .cache = 0
d183 1
a183 2
   .prepare = prepare_vs_surfaces,
   .emit = upload_vs_surfaces,
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d85 9
d117 1
d128 1
a128 2
      drm_intel_bo_unreference(brw->vs.surf_bo[surf]);
      brw->vs.surf_bo[surf] = NULL;
d132 7
a138 3
   brw_create_constant_surface(brw, brw->vs.const_bo, params->NumParameters,
			       &brw->vs.surf_bo[surf],
			       &brw->vs.surf_offset[surf]);
d173 2
a174 4
      if (brw->vs.bind_bo) {
	 drm_intel_bo_unreference(brw->vs.bind_bo);
	 brw->vs.bind_bo = NULL;
	 brw->state.dirty.brw |= BRW_NEW_BINDING_TABLE;
d176 1
d186 1
a186 1
			  32, &brw->vs.bind_bo, &brw->vs.bind_bo_offset);
d190 1
a190 5
      if (brw->vs.surf_bo[i]) {
	 bind[i] = brw->vs.surf_offset[i];
      } else {
	 bind[i] = 0;
      }
d193 1
a193 1
   brw->state.dirty.brw |= BRW_NEW_BINDING_TABLE;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d34 1
a34 1
#include "shader/prog_parameter.h"
d45 2
a46 2
static drm_intel_bo *
brw_vs_update_constant_buffer(struct brw_context *brw)
d48 1
a53 1
   drm_intel_bo *const_buffer;
d56 2
a57 8
   /* BRW_NEW_VERTEX_PROGRAM */
   if (!vp->use_const_buffer)
      return NULL;

   const_buffer = drm_intel_bo_alloc(intel->bufmgr, "vp_const_buffer",
				     size, 64);

   /* _NEW_PROGRAM_CONSTANTS */
d64 16
a79 1
   drm_intel_gem_bo_map_gtt(const_buffer);
d81 1
a81 1
      memcpy(const_buffer->virtual + i * 4 * sizeof(float),
d85 3
a87 1
   drm_intel_gem_bo_unmap_gtt(const_buffer);
d89 8
a96 2
   return const_buffer;
}
d104 1
a104 1
brw_update_vs_constant_surface( GLcontext *ctx,
a107 1
   struct brw_surface_key key;
a113 6
   /* If we're in this state update atom, we need to update VS constants, so
    * free the old buffer and create a new one for the new contents.
    */
   dri_bo_unreference(vp->const_buffer);
   vp->const_buffer = brw_vs_update_constant_buffer(brw);

d117 1
a117 1
   if (vp->const_buffer == NULL) {
d123 3
a125 27
   memset(&key, 0, sizeof(key));

   key.format = MESA_FORMAT_RGBA_FLOAT32;
   key.internal_format = GL_RGBA;
   key.bo = vp->const_buffer;
   key.depthmode = GL_NONE;
   key.pitch = params->NumParameters;
   key.width = params->NumParameters;
   key.height = 1;
   key.depth = 1;
   key.cpp = 16;

   /*
   printf("%s:\n", __FUNCTION__);
   printf("  width %d  height %d  depth %d  cpp %d  pitch %d\n",
          key.width, key.height, key.depth, key.cpp, key.pitch);
   */

   drm_intel_bo_unreference(brw->vs.surf_bo[surf]);
   brw->vs.surf_bo[surf] = brw_search_cache(&brw->surface_cache,
                                            BRW_SS_SURFACE,
                                            &key, sizeof(key),
                                            &key.bo, 1,
                                            NULL);
   if (brw->vs.surf_bo[surf] == NULL) {
      brw->vs.surf_bo[surf] = brw_create_constant_surface(brw, &key);
   }
d129 2
a130 5
/**
 * Constructs the binding table for the VS surface state.
 */
static dri_bo *
brw_vs_get_binding_table(struct brw_context *brw)
d132 1
a132 1
   dri_bo *bind_bo;
d134 3
a136 32
   bind_bo = brw_search_cache(&brw->surface_cache, BRW_SS_SURF_BIND,
			      NULL, 0,
			      brw->vs.surf_bo, BRW_VS_MAX_SURF,
			      NULL);

   if (bind_bo == NULL) {
      GLuint data_size = BRW_VS_MAX_SURF * sizeof(GLuint);
      uint32_t data[BRW_VS_MAX_SURF];
      int i;

      for (i = 0; i < BRW_VS_MAX_SURF; i++)
         if (brw->vs.surf_bo[i])
            data[i] = brw->vs.surf_bo[i]->offset;
         else
            data[i] = 0;

      bind_bo = brw_upload_cache( &brw->surface_cache, BRW_SS_SURF_BIND,
				  NULL, 0,
				  brw->vs.surf_bo, BRW_VS_MAX_SURF,
				  data, data_size);

      /* Emit binding table relocations to surface state */
      for (i = 0; i < BRW_VS_MAX_SURF; i++) {
	 if (brw->vs.surf_bo[i] != NULL) {
	    /* The presumed offsets were set in the data values for
	     * brw_upload_cache.
	     */
	    drm_intel_bo_emit_reloc(bind_bo, i * 4,
				    brw->vs.surf_bo[i], 0,
				    I915_GEM_DOMAIN_INSTRUCTION, 0);
	 }
      }
d139 4
a142 1
   return bind_bo;
d152 1
a152 1
static void prepare_vs_surfaces(struct brw_context *brw )
d154 2
a155 1
   GLcontext *ctx = &brw->intel.ctx;
d157 10
a166 1
   int nr_surfaces = 0;
d170 6
d177 5
a181 2
      if (brw->vs.surf_bo[i] != NULL) {
	 nr_surfaces = i + 1;
d185 1
a185 13
   if (brw->vs.nr_surfaces != nr_surfaces) {
      brw->state.dirty.brw |= BRW_NEW_NR_VS_SURFACES;
      brw->vs.nr_surfaces = nr_surfaces;
   }

   /* Note that we don't end up updating the bind_bo if we don't have a
    * surface to be pointing at.  This should be relatively harmless, as it
    * just slightly increases our working set size.
    */
   if (brw->vs.nr_surfaces != 0) {
      dri_bo_unreference(brw->vs.bind_bo);
      brw->vs.bind_bo = brw_vs_get_binding_table(brw);
   }
d190 4
a193 2
      .mesa = (_NEW_PROGRAM_CONSTANTS),
      .brw = (BRW_NEW_VERTEX_PROGRAM),
d197 1
a198 3



@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d34 1
a34 1
#include "program/prog_parameter.h"
d45 2
a46 2
static void
prepare_vs_constants(struct brw_context *brw)
a47 1
   struct gl_context *ctx = &brw->intel.ctx;
d53 1
d56 8
a63 2
   if (vp->program.IsNVProgram)
      _mesa_load_tracked_matrices(ctx);
d70 1
a70 16
   /* BRW_NEW_VERTEX_PROGRAM */
   if (!vp->use_const_buffer) {
      if (brw->vs.const_bo) {
	 drm_intel_bo_unreference(brw->vs.const_bo);
	 brw->vs.const_bo = NULL;
	 brw->state.dirty.brw |= BRW_NEW_VS_CONSTBUF;
      }
      return;
   }

   /* _NEW_PROGRAM_CONSTANTS */
   drm_intel_bo_unreference(brw->vs.const_bo);
   brw->vs.const_bo = drm_intel_bo_alloc(intel->bufmgr, "vp_const_buffer",
					 size, 64);

   drm_intel_gem_bo_map_gtt(brw->vs.const_bo);
d72 1
a72 1
      memcpy(brw->vs.const_bo->virtual + i * 4 * sizeof(float),
d76 3
a78 2
   drm_intel_gem_bo_unmap_gtt(brw->vs.const_bo);
   brw->state.dirty.brw |= BRW_NEW_VS_CONSTBUF;
a80 9
const struct brw_tracked_state brw_vs_constants = {
   .dirty = {
      .mesa = (_NEW_PROGRAM_CONSTANTS),
      .brw = (BRW_NEW_VERTEX_PROGRAM),
      .cache = 0
   },
   .prepare = prepare_vs_constants,
};

d87 1
a87 1
brw_update_vs_constant_surface( struct gl_context *ctx,
d91 1
d98 6
d107 1
a107 1
   if (brw->vs.const_bo == NULL) {
d113 27
a139 3
   brw_create_constant_surface(brw, brw->vs.const_bo, params->NumParameters,
			       &brw->vs.surf_bo[surf],
			       &brw->vs.surf_offset[surf]);
d143 5
a147 2
static void
prepare_vs_surfaces(struct brw_context *brw)
d149 1
a149 1
   int nr_surfaces = 0;
d151 32
a182 3
   if (brw->vs.const_bo) {
      brw_add_validated_bo(brw, brw->vs.const_bo);
      nr_surfaces = 1;
d185 1
a185 4
   if (brw->vs.nr_surfaces != nr_surfaces) {
      brw->state.dirty.brw |= BRW_NEW_NR_VS_SURFACES;
      brw->vs.nr_surfaces = nr_surfaces;
   }
d195 1
a195 1
static void upload_vs_surfaces(struct brw_context *brw)
d197 1
a197 2
   struct gl_context *ctx = &brw->intel.ctx;
   uint32_t *bind;
d199 3
d203 3
a205 6
   /* BRW_NEW_NR_VS_SURFACES */
   if (brw->vs.nr_surfaces == 0) {
      if (brw->vs.bind_bo) {
	 drm_intel_bo_unreference(brw->vs.bind_bo);
	 brw->vs.bind_bo = NULL;
	 brw->state.dirty.brw |= BRW_NEW_BINDING_TABLE;
a206 1
      return;
d209 4
a212 1
   brw_update_vs_constant_surface(ctx, SURF_INDEX_VERT_CONST_BUFFER);
d214 3
a216 2
   /* Might want to calculate nr_surfaces first, to avoid taking up so much
    * space for the binding table. (once we have vs samplers)
d218 3
a220 10
   bind = brw_state_batch(brw, sizeof(uint32_t) * BRW_VS_MAX_SURF,
			  32, &brw->vs.bind_bo, &brw->vs.bind_bo_offset);

   for (i = 0; i < BRW_VS_MAX_SURF; i++) {
      /* BRW_NEW_VS_CONSTBUF */
      if (brw->vs.surf_bo[i]) {
	 bind[i] = brw->vs.surf_offset[i];
      } else {
	 bind[i] = 0;
      }
a221 2

   brw->state.dirty.brw |= BRW_NEW_BINDING_TABLE;
d226 2
a227 4
      .mesa = 0,
      .brw = (BRW_NEW_VS_CONSTBUF |
	      BRW_NEW_NR_VS_SURFACES |
	      BRW_NEW_BATCH),
a230 1
   .emit = upload_vs_surfaces,
d232 3
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d33 1
d46 1
a46 1
brw_upload_vs_pull_constants(struct brw_context *brw)
d48 2
a49 1
   /* BRW_NEW_VERTEX_PROGRAM */
d52 2
d56 3
d62 1
a62 1
   _mesa_load_state_parameters(&brw->ctx, vp->program.Base.Parameters);
d64 2
a65 2
   /* CACHE_NEW_VS_PROG */
   if (!brw->vs.prog_data->base.nr_pull_params) {
a68 1
	 brw->vs.surf_offset[SURF_INDEX_VERT_CONST_BUFFER] = 0;
d76 1
a76 2
   uint32_t size = brw->vs.prog_data->base.nr_pull_params * 4;
   brw->vs.const_bo = drm_intel_bo_alloc(brw->bufmgr, "vp_const_buffer",
d80 4
a83 4
   for (i = 0; i < brw->vs.prog_data->base.nr_pull_params; i++) {
      memcpy(brw->vs.const_bo->virtual + i * 4,
	     brw->vs.prog_data->base.pull_param[i],
	     4);
a84 10

   if (0) {
      for (i = 0; i < ALIGN(brw->vs.prog_data->base.nr_pull_params, 4) / 4;
           i++) {
	 float *row = (float *)brw->vs.const_bo->virtual + i * 4;
	 printf("vs const surface %3d: %4.3f %4.3f %4.3f %4.3f\n",
		i, row[0], row[1], row[2], row[3]);
      }
   }

a85 5

   const int surf = SURF_INDEX_VERT_CONST_BUFFER;
   brw->vtbl.create_constant_surface(brw, brw->vs.const_bo, 0, size,
                                     &brw->vs.surf_offset[surf], false);

d89 1
a89 1
const struct brw_tracked_state brw_vs_pull_constants = {
d92 2
a93 2
      .brw = (BRW_NEW_BATCH | BRW_NEW_VERTEX_PROGRAM),
      .cache = CACHE_NEW_VS_PROG,
d95 1
a95 1
   .emit = brw_upload_vs_pull_constants,
d98 5
d104 2
a105 1
brw_upload_vs_ubo_surfaces(struct brw_context *brw)
d107 4
a110 3
   struct gl_context *ctx = &brw->ctx;
   /* _NEW_PROGRAM */
   struct gl_shader_program *prog = ctx->Shader.CurrentVertexProgram;
d112 8
a119 1
   if (!prog)
d121 1
d123 3
a125 2
   brw_upload_ubo_surfaces(brw, prog->_LinkedShaders[MESA_SHADER_VERTEX],
			   &brw->vs.surf_offset[SURF_INDEX_VS_UBO(0)]);
d128 16
a143 8
const struct brw_tracked_state brw_vs_ubo_surfaces = {
   .dirty = {
      .mesa = _NEW_PROGRAM,
      .brw = BRW_NEW_BATCH | BRW_NEW_UNIFORM_BUFFER,
      .cache = 0,
   },
   .emit = brw_upload_vs_ubo_surfaces,
};
d146 5
a150 2
 * Constructs the binding table for the WM surface state, which maps unit
 * numbers to surface state objects.
d152 1
a152 2
static void
brw_vs_upload_binding_table(struct brw_context *brw)
d154 1
d158 6
a163 15
   if (INTEL_DEBUG & DEBUG_SHADER_TIME) {
      gen7_create_shader_time_surface(brw, &brw->vs.surf_offset[SURF_INDEX_VS_SHADER_TIME]);

      assert(brw->vs.prog_data->base.num_surfaces
             <= SURF_INDEX_VS_SHADER_TIME);
      brw->vs.prog_data->base.num_surfaces = SURF_INDEX_VS_SHADER_TIME;
   }

   /* CACHE_NEW_VS_PROG: Skip making a binding table if we don't use textures or
    * pull constants.
    */
   if (brw->vs.prog_data->base.num_surfaces == 0) {
      if (brw->vs.bind_bo_offset != 0) {
	 brw->state.dirty.brw |= BRW_NEW_VS_BINDING_TABLE;
	 brw->vs.bind_bo_offset = 0;
d168 2
d171 1
a171 1
    * space for the binding table.
d173 2
a174 3
   bind = brw_state_batch(brw, AUB_TRACE_BINDING_TABLE,
			  sizeof(uint32_t) * BRW_MAX_VS_SURFACES,
			  32, &brw->vs.bind_bo_offset);
d176 7
a182 3
   /* BRW_NEW_SURFACES and BRW_NEW_VS_CONSTBUF */
   for (i = 0; i < BRW_MAX_VS_SURFACES; i++) {
      bind[i] = brw->vs.surf_offset[i];
d185 1
a185 1
   brw->state.dirty.brw |= BRW_NEW_VS_BINDING_TABLE;
d188 1
a188 1
const struct brw_tracked_state brw_vs_binding_table = {
d191 4
a194 4
      .brw = (BRW_NEW_BATCH |
	      BRW_NEW_VS_CONSTBUF |
	      BRW_NEW_SURFACES),
      .cache = CACHE_NEW_VS_PROG
d196 2
a197 1
   .emit = brw_vs_upload_binding_table,
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics to
d29 1
a29 1
  *   Keith Whitwell <keithw@@vmware.com>
a36 1
#include "intel_buffer_objects.h"
d38 8
a45 6
void
brw_upload_vec4_pull_constants(struct brw_context *brw,
                               GLbitfield brw_new_constbuf,
                               const struct gl_program *prog,
                               struct brw_stage_state *stage_state,
                               const struct brw_vec4_prog_data *prog_data)
d47 3
a50 1
   uint32_t surf_index = prog_data->base.binding_table.pull_constants_start;
d55 1
a55 1
   _mesa_load_state_parameters(&brw->ctx, prog->Parameters);
d57 7
a63 4
   if (!prog_data->base.nr_pull_params) {
      if (stage_state->surf_offset[surf_index]) {
	 stage_state->surf_offset[surf_index] = 0;
	 brw->state.dirty.brw |= brw_new_constbuf;
d69 10
a78 8
   uint32_t size = prog_data->base.nr_pull_params * 4;
   drm_intel_bo *const_bo = NULL;
   uint32_t const_offset;
   float *constants = intel_upload_space(brw, size, 64,
                                         &const_bo, &const_offset);

   for (i = 0; i < prog_data->base.nr_pull_params; i++) {
      constants[i] = *prog_data->base.pull_param[i];
d82 5
a86 4
      for (i = 0; i < ALIGN(prog_data->base.nr_pull_params, 4) / 4; i++) {
	 float *row = &constants[i * 4];
	 fprintf(stderr, "const surface %3d: %4.3f %4.3f %4.3f %4.3f\n",
                 i, row[0], row[1], row[2], row[3]);
d90 1
a90 23
   brw_create_constant_surface(brw, const_bo, const_offset, size,
                               &stage_state->surf_offset[surf_index],
                               false);
   drm_intel_bo_unreference(const_bo);

   brw->state.dirty.brw |= brw_new_constbuf;
}


/* Creates a new VS constant buffer reflecting the current VS program's
 * constants, if needed by the VS program.
 *
 * Otherwise, constants go through the CURBEs using the brw_constant_buffer
 * state atom.
 */
static void
brw_upload_vs_pull_constants(struct brw_context *brw)
{
   struct brw_stage_state *stage_state = &brw->vs.base;

   /* BRW_NEW_VERTEX_PROGRAM */
   struct brw_vertex_program *vp =
      (struct brw_vertex_program *) brw->vertex_program;
d92 3
a94 2
   /* CACHE_NEW_VS_PROG */
   const struct brw_vec4_prog_data *prog_data = &brw->vs.prog_data->base;
d96 1
a96 3
   /* _NEW_PROGRAM_CONSTANTS */
   brw_upload_vec4_pull_constants(brw, BRW_NEW_VS_CONSTBUF, &vp->program.Base,
                                  stage_state, prog_data);
d113 1
a113 2
   struct gl_shader_program *prog =
      ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX];
a117 1
   /* CACHE_NEW_VS_PROG */
d119 1
a119 1
			   &brw->vs.base, &brw->vs.prog_data->base.base);
d126 1
a126 1
      .cache = CACHE_NEW_VS_PROG,
d131 4
d136 1
a136 1
brw_upload_vs_abo_surfaces(struct brw_context *brw)
d138 21
a158 4
   struct gl_context *ctx = &brw->ctx;
   /* _NEW_PROGRAM */
   struct gl_shader_program *prog =
      ctx->_Shader->CurrentProgram[MESA_SHADER_VERTEX];
d160 10
a169 4
   if (prog) {
      /* CACHE_NEW_VS_PROG */
      brw_upload_abo_surfaces(brw, prog, &brw->vs.base,
                              &brw->vs.prog_data->base.base);
d171 2
d175 1
a175 1
const struct brw_tracked_state brw_vs_abo_surfaces = {
d177 5
a181 3
      .mesa = _NEW_PROGRAM,
      .brw = BRW_NEW_BATCH | BRW_NEW_ATOMIC_BUFFER,
      .cache = CACHE_NEW_VS_PROG,
d183 1
a183 1
   .emit = brw_upload_vs_abo_surfaces,
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a38 12
/**
 * Creates a temporary BO containing the pull constant data for the shader
 * stage, and the SURFACE_STATE struct that points at it.
 *
 * Pull constants are GLSL uniforms (and other constant data) beyond what we
 * could fit as push constants, or that have variable-index array access
 * (which is easiest to support using pull constants, and avoids filling
 * register space with mostly-unused data).
 *
 * Compare this path to brw_curbe.c for gen4/5 push constants, and
 * gen6_vs_state.c for gen6+ push constants.
 */
d40 5
a44 6
brw_upload_pull_constants(struct brw_context *brw,
                          GLbitfield brw_new_constbuf,
                          const struct gl_program *prog,
                          struct brw_stage_state *stage_state,
                          const struct brw_stage_prog_data *prog_data,
                          bool dword_pitch)
d47 1
a47 1
   uint32_t surf_index = prog_data->binding_table.pull_constants_start;
d54 1
a54 1
   if (!prog_data->nr_pull_params) {
d62 2
a63 2
   /* CACHE_NEW_*_PROG | _NEW_PROGRAM_CONSTANTS */
   uint32_t size = prog_data->nr_pull_params * 4;
d66 2
a67 4
   gl_constant_value *constants = intel_upload_space(brw, size, 64,
                                                     &const_bo, &const_offset);

   STATIC_ASSERT(sizeof(gl_constant_value) == sizeof(float));
d69 2
a70 2
   for (i = 0; i < prog_data->nr_pull_params; i++) {
      constants[i] = *prog_data->pull_param[i];
d74 2
a75 2
      for (i = 0; i < ALIGN(prog_data->nr_pull_params, 4) / 4; i++) {
	 const gl_constant_value *row = &constants[i * 4];
d77 1
a77 1
                 i, row[0].f, row[1].f, row[2].f, row[3].f);
d83 1
a83 1
                               dword_pitch);
d106 1
a106 1
   const struct brw_stage_prog_data *prog_data = &brw->vs.prog_data->base.base;
d109 2
a110 2
   brw_upload_pull_constants(brw, BRW_NEW_VS_CONSTBUF, &vp->program.Base,
                             stage_state, prog_data, false);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d39 12
d52 6
a57 5
brw_upload_vec4_pull_constants(struct brw_context *brw,
                               GLbitfield brw_new_constbuf,
                               const struct gl_program *prog,
                               struct brw_stage_state *stage_state,
                               const struct brw_vec4_prog_data *prog_data)
d60 1
a60 1
   uint32_t surf_index = prog_data->base.binding_table.pull_constants_start;
d67 1
a67 1
   if (!prog_data->base.nr_pull_params) {
d75 2
a76 2
   /* _NEW_PROGRAM_CONSTANTS */
   uint32_t size = prog_data->base.nr_pull_params * 4;
d79 4
a82 2
   float *constants = intel_upload_space(brw, size, 64,
                                         &const_bo, &const_offset);
d84 2
a85 2
   for (i = 0; i < prog_data->base.nr_pull_params; i++) {
      constants[i] = *prog_data->base.pull_param[i];
d89 2
a90 2
      for (i = 0; i < ALIGN(prog_data->base.nr_pull_params, 4) / 4; i++) {
	 float *row = &constants[i * 4];
d92 1
a92 1
                 i, row[0], row[1], row[2], row[3]);
d98 1
a98 1
                               false);
d121 1
a121 1
   const struct brw_vec4_prog_data *prog_data = &brw->vs.prog_data->base;
d124 2
a125 2
   brw_upload_vec4_pull_constants(brw, BRW_NEW_VS_CONSTBUF, &vp->program.Base,
                                  stage_state, prog_data);
@


