head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.05.35;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.18;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.53.42;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.53.42;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.31;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.42;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.16.08;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.57;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************

Copyright 2000, 2001 ATI Technologies Inc., Ontario, Canada, and
                     VA Linux Systems Inc., Fremont, California.

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial
portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Kevin E. Martin <martin@@valinux.com>
 *   Gareth Hughes <gareth@@valinux.com>
 */

#include "main/glheader.h"
#include "main/imports.h"
#include "main/colormac.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/teximage.h"
#include "main/texstate.h"
#include "main/texobj.h"
#include "main/enums.h"
#include "main/samplerobj.h"

#include "radeon_context.h"
#include "radeon_mipmap_tree.h"
#include "radeon_state.h"
#include "radeon_ioctl.h"
#include "radeon_swtcl.h"
#include "radeon_tex.h"
#include "radeon_tcl.h"


#define RADEON_TXFORMAT_A8        RADEON_TXFORMAT_I8
#define RADEON_TXFORMAT_L8        RADEON_TXFORMAT_I8
#define RADEON_TXFORMAT_AL88      RADEON_TXFORMAT_AI88
#define RADEON_TXFORMAT_YCBCR     RADEON_TXFORMAT_YVYU422
#define RADEON_TXFORMAT_YCBCR_REV RADEON_TXFORMAT_VYUY422
#define RADEON_TXFORMAT_RGB_DXT1  RADEON_TXFORMAT_DXT1
#define RADEON_TXFORMAT_RGBA_DXT1 RADEON_TXFORMAT_DXT1
#define RADEON_TXFORMAT_RGBA_DXT3 RADEON_TXFORMAT_DXT23
#define RADEON_TXFORMAT_RGBA_DXT5 RADEON_TXFORMAT_DXT45

#define VALID_FORMAT(f) ( ((f) <= MESA_FORMAT_RGBA_DXT5) \
			     && (tx_table[f].format != 0xffffffff) )

struct tx_table {
   GLuint format, filter;
};

/* XXX verify this table against MESA_FORMAT_x values */
static const struct tx_table tx_table[] =
{
   [ MESA_FORMAT_NONE ] = { 0xffffffff, 0 },
   [ MESA_FORMAT_A8B8G8R8_UNORM ] = { RADEON_TXFORMAT_RGBA8888 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_R8G8B8A8_UNORM ] = { RADEON_TXFORMAT_RGBA8888 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_B8G8R8A8_UNORM ] = { RADEON_TXFORMAT_ARGB8888 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_A8R8G8B8_UNORM ] = { RADEON_TXFORMAT_ARGB8888 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_BGR_UNORM8 ] = { RADEON_TXFORMAT_ARGB8888, 0 },
   [ MESA_FORMAT_B5G6R5_UNORM ] = { RADEON_TXFORMAT_RGB565, 0 },
   [ MESA_FORMAT_R5G6B5_UNORM ] = { RADEON_TXFORMAT_RGB565, 0 },
   [ MESA_FORMAT_B4G4R4A4_UNORM ] = { RADEON_TXFORMAT_ARGB4444 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_A4R4G4B4_UNORM ] = { RADEON_TXFORMAT_ARGB4444 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_B5G5R5A1_UNORM ] = { RADEON_TXFORMAT_ARGB1555 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_A1R5G5B5_UNORM ] = { RADEON_TXFORMAT_ARGB1555 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_L8A8_UNORM ] = { RADEON_TXFORMAT_AL88 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_A8L8_UNORM ] = { RADEON_TXFORMAT_AL88 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_A_UNORM8 ] = { RADEON_TXFORMAT_A8 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_L_UNORM8 ] = { RADEON_TXFORMAT_L8, 0 },
   [ MESA_FORMAT_I_UNORM8 ] = { RADEON_TXFORMAT_I8 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_YCBCR ] = { RADEON_TXFORMAT_YCBCR, RADEON_YUV_TO_RGB },
   [ MESA_FORMAT_YCBCR_REV ] = { RADEON_TXFORMAT_YCBCR_REV, RADEON_YUV_TO_RGB },
   [ MESA_FORMAT_RGB_FXT1 ] = { 0xffffffff, 0 },
   [ MESA_FORMAT_RGBA_FXT1 ] = { 0xffffffff, 0 },
   [ MESA_FORMAT_RGB_DXT1 ] = { RADEON_TXFORMAT_RGB_DXT1, 0 },
   [ MESA_FORMAT_RGBA_DXT1 ] = { RADEON_TXFORMAT_RGBA_DXT1 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_RGBA_DXT3 ] = { RADEON_TXFORMAT_RGBA_DXT3 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_RGBA_DXT5 ] = { RADEON_TXFORMAT_RGBA_DXT5 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
};

/* ================================================================
 * Texture combine functions
 */

/* GL_ARB_texture_env_combine support
 */

/* The color tables have combine functions for GL_SRC_COLOR,
 * GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA and GL_ONE_MINUS_SRC_ALPHA.
 */
static GLuint radeon_texture_color[][RADEON_MAX_TEXTURE_UNITS] =
{
   {
      RADEON_COLOR_ARG_A_T0_COLOR,
      RADEON_COLOR_ARG_A_T1_COLOR,
      RADEON_COLOR_ARG_A_T2_COLOR
   },
   {
      RADEON_COLOR_ARG_A_T0_COLOR | RADEON_COMP_ARG_A,
      RADEON_COLOR_ARG_A_T1_COLOR | RADEON_COMP_ARG_A,
      RADEON_COLOR_ARG_A_T2_COLOR | RADEON_COMP_ARG_A
   },
   {
      RADEON_COLOR_ARG_A_T0_ALPHA,
      RADEON_COLOR_ARG_A_T1_ALPHA,
      RADEON_COLOR_ARG_A_T2_ALPHA
   },
   {
      RADEON_COLOR_ARG_A_T0_ALPHA | RADEON_COMP_ARG_A,
      RADEON_COLOR_ARG_A_T1_ALPHA | RADEON_COMP_ARG_A,
      RADEON_COLOR_ARG_A_T2_ALPHA | RADEON_COMP_ARG_A
   },
};

static GLuint radeon_tfactor_color[] =
{
   RADEON_COLOR_ARG_A_TFACTOR_COLOR,
   RADEON_COLOR_ARG_A_TFACTOR_COLOR | RADEON_COMP_ARG_A,
   RADEON_COLOR_ARG_A_TFACTOR_ALPHA,
   RADEON_COLOR_ARG_A_TFACTOR_ALPHA | RADEON_COMP_ARG_A
};

static GLuint radeon_primary_color[] =
{
   RADEON_COLOR_ARG_A_DIFFUSE_COLOR,
   RADEON_COLOR_ARG_A_DIFFUSE_COLOR | RADEON_COMP_ARG_A,
   RADEON_COLOR_ARG_A_DIFFUSE_ALPHA,
   RADEON_COLOR_ARG_A_DIFFUSE_ALPHA | RADEON_COMP_ARG_A
};

static GLuint radeon_previous_color[] =
{
   RADEON_COLOR_ARG_A_CURRENT_COLOR,
   RADEON_COLOR_ARG_A_CURRENT_COLOR | RADEON_COMP_ARG_A,
   RADEON_COLOR_ARG_A_CURRENT_ALPHA,
   RADEON_COLOR_ARG_A_CURRENT_ALPHA | RADEON_COMP_ARG_A
};

/* GL_ZERO table - indices 0-3
 * GL_ONE  table - indices 1-4
 */
static GLuint radeon_zero_color[] =
{
   RADEON_COLOR_ARG_A_ZERO,
   RADEON_COLOR_ARG_A_ZERO | RADEON_COMP_ARG_A,
   RADEON_COLOR_ARG_A_ZERO,
   RADEON_COLOR_ARG_A_ZERO | RADEON_COMP_ARG_A,
   RADEON_COLOR_ARG_A_ZERO
};


/* The alpha tables only have GL_SRC_ALPHA and GL_ONE_MINUS_SRC_ALPHA.
 */
static GLuint radeon_texture_alpha[][RADEON_MAX_TEXTURE_UNITS] =
{
   {
      RADEON_ALPHA_ARG_A_T0_ALPHA,
      RADEON_ALPHA_ARG_A_T1_ALPHA,
      RADEON_ALPHA_ARG_A_T2_ALPHA
   },
   {
      RADEON_ALPHA_ARG_A_T0_ALPHA | RADEON_COMP_ARG_A,
      RADEON_ALPHA_ARG_A_T1_ALPHA | RADEON_COMP_ARG_A,
      RADEON_ALPHA_ARG_A_T2_ALPHA | RADEON_COMP_ARG_A
   },
};

static GLuint radeon_tfactor_alpha[] =
{
   RADEON_ALPHA_ARG_A_TFACTOR_ALPHA,
   RADEON_ALPHA_ARG_A_TFACTOR_ALPHA | RADEON_COMP_ARG_A
};

static GLuint radeon_primary_alpha[] =
{
   RADEON_ALPHA_ARG_A_DIFFUSE_ALPHA,
   RADEON_ALPHA_ARG_A_DIFFUSE_ALPHA | RADEON_COMP_ARG_A
};

static GLuint radeon_previous_alpha[] =
{
   RADEON_ALPHA_ARG_A_CURRENT_ALPHA,
   RADEON_ALPHA_ARG_A_CURRENT_ALPHA | RADEON_COMP_ARG_A
};

/* GL_ZERO table - indices 0-1
 * GL_ONE  table - indices 1-2
 */
static GLuint radeon_zero_alpha[] =
{
   RADEON_ALPHA_ARG_A_ZERO,
   RADEON_ALPHA_ARG_A_ZERO | RADEON_COMP_ARG_A,
   RADEON_ALPHA_ARG_A_ZERO
};


/* Extract the arg from slot A, shift it into the correct argument slot
 * and set the corresponding complement bit.
 */
#define RADEON_COLOR_ARG( n, arg )			\
do {							\
   color_combine |=					\
      ((color_arg[n] & RADEON_COLOR_ARG_MASK)		\
       << RADEON_COLOR_ARG_##arg##_SHIFT);		\
   color_combine |=					\
      ((color_arg[n] >> RADEON_COMP_ARG_SHIFT)		\
       << RADEON_COMP_ARG_##arg##_SHIFT);		\
} while (0)

#define RADEON_ALPHA_ARG( n, arg )			\
do {							\
   alpha_combine |=					\
      ((alpha_arg[n] & RADEON_ALPHA_ARG_MASK)		\
       << RADEON_ALPHA_ARG_##arg##_SHIFT);		\
   alpha_combine |=					\
      ((alpha_arg[n] >> RADEON_COMP_ARG_SHIFT)		\
       << RADEON_COMP_ARG_##arg##_SHIFT);		\
} while (0)


/* ================================================================
 * Texture unit state management
 */

static GLboolean radeonUpdateTextureEnv( struct gl_context *ctx, int unit )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   GLuint color_combine, alpha_combine;
   const GLuint color_combine0 = RADEON_COLOR_ARG_A_ZERO | RADEON_COLOR_ARG_B_ZERO
         | RADEON_COLOR_ARG_C_CURRENT_COLOR | RADEON_BLEND_CTL_ADD
         | RADEON_SCALE_1X | RADEON_CLAMP_TX;
   const GLuint alpha_combine0 = RADEON_ALPHA_ARG_A_ZERO | RADEON_ALPHA_ARG_B_ZERO
         | RADEON_ALPHA_ARG_C_CURRENT_ALPHA | RADEON_BLEND_CTL_ADD
         | RADEON_SCALE_1X | RADEON_CLAMP_TX;


   if ( RADEON_DEBUG & RADEON_TEXTURE ) {
      fprintf( stderr, "%s( %p, %d )\n", __FUNCTION__, (void *)ctx, unit );
   }

   /* Set the texture environment state.  Isn't this nice and clean?
    * The chip will automagically set the texture alpha to 0xff when
    * the texture format does not include an alpha component. This
    * reduces the amount of special-casing we have to do, alpha-only
    * textures being a notable exception. Doesn't work for luminance
    * textures realized with I8 and ALPHA_IN_MAP not set neither (on r100).
    */
    /* Don't cache these results.
    */
   rmesa->state.texture.unit[unit].format = 0;
   rmesa->state.texture.unit[unit].envMode = 0;

   if ( !texUnit->_Current ) {
      color_combine = color_combine0;
      alpha_combine = alpha_combine0;
   }
   else {
      GLuint color_arg[3], alpha_arg[3];
      GLuint i;
      const GLuint numColorArgs = texUnit->_CurrentCombine->_NumArgsRGB;
      const GLuint numAlphaArgs = texUnit->_CurrentCombine->_NumArgsA;
      GLuint RGBshift = texUnit->_CurrentCombine->ScaleShiftRGB;
      GLuint Ashift = texUnit->_CurrentCombine->ScaleShiftA;


      /* Step 1:
       * Extract the color and alpha combine function arguments.
       */
      for ( i = 0 ; i < numColorArgs ; i++ ) {
	 const GLint op = texUnit->_CurrentCombine->OperandRGB[i] - GL_SRC_COLOR;
	 const GLuint srcRGBi = texUnit->_CurrentCombine->SourceRGB[i];
	 assert(op >= 0);
	 assert(op <= 3);
	 switch ( srcRGBi ) {
	 case GL_TEXTURE:
	    if (texUnit->_Current->Image[0][0]->_BaseFormat == GL_ALPHA)
	       color_arg[i] = radeon_zero_color[op];
	    else
	       color_arg[i] = radeon_texture_color[op][unit];
	    break;
	 case GL_CONSTANT:
	    color_arg[i] = radeon_tfactor_color[op];
	    break;
	 case GL_PRIMARY_COLOR:
	    color_arg[i] = radeon_primary_color[op];
	    break;
	 case GL_PREVIOUS:
	    color_arg[i] = radeon_previous_color[op];
	    break;
	 case GL_ZERO:
	    color_arg[i] = radeon_zero_color[op];
	    break;
	 case GL_ONE:
	    color_arg[i] = radeon_zero_color[op+1];
	    break;
	 case GL_TEXTURE0:
	 case GL_TEXTURE1:
	 case GL_TEXTURE2: {
	    GLuint txunit = srcRGBi - GL_TEXTURE0;
	    if (ctx->Texture.Unit[txunit]._Current->Image[0][0]->_BaseFormat == GL_ALPHA)
	       color_arg[i] = radeon_zero_color[op];
	    else
	 /* implement ogl 1.4/1.5 core spec here, not specification of
	  * GL_ARB_texture_env_crossbar (which would require disabling blending
	  * instead of undefined results when referencing not enabled texunit) */
	      color_arg[i] = radeon_texture_color[op][txunit];
	    }
	    break;
	 default:
	    return GL_FALSE;
	 }
      }

      for ( i = 0 ; i < numAlphaArgs ; i++ ) {
	 const GLint op = texUnit->_CurrentCombine->OperandA[i] - GL_SRC_ALPHA;
	 const GLuint srcAi = texUnit->_CurrentCombine->SourceA[i];
	 assert(op >= 0);
	 assert(op <= 1);
	 switch ( srcAi ) {
	 case GL_TEXTURE:
	    if (texUnit->_Current->Image[0][0]->_BaseFormat == GL_LUMINANCE)
	       alpha_arg[i] = radeon_zero_alpha[op+1];
	    else
	       alpha_arg[i] = radeon_texture_alpha[op][unit];
	    break;
	 case GL_CONSTANT:
	    alpha_arg[i] = radeon_tfactor_alpha[op];
	    break;
	 case GL_PRIMARY_COLOR:
	    alpha_arg[i] = radeon_primary_alpha[op];
	    break;
	 case GL_PREVIOUS:
	    alpha_arg[i] = radeon_previous_alpha[op];
	    break;
	 case GL_ZERO:
	    alpha_arg[i] = radeon_zero_alpha[op];
	    break;
	 case GL_ONE:
	    alpha_arg[i] = radeon_zero_alpha[op+1];
	    break;
	 case GL_TEXTURE0:
	 case GL_TEXTURE1:
	 case GL_TEXTURE2: {    
	    GLuint txunit = srcAi - GL_TEXTURE0;
	    if (ctx->Texture.Unit[txunit]._Current->Image[0][0]->_BaseFormat == GL_LUMINANCE)
	       alpha_arg[i] = radeon_zero_alpha[op+1];
	    else
	       alpha_arg[i] = radeon_texture_alpha[op][txunit];
	    }
	    break;
	 default:
	    return GL_FALSE;
	 }
      }

      /* Step 2:
       * Build up the color and alpha combine functions.
       */
      switch ( texUnit->_CurrentCombine->ModeRGB ) {
      case GL_REPLACE:
	 color_combine = (RADEON_COLOR_ARG_A_ZERO |
			  RADEON_COLOR_ARG_B_ZERO |
			  RADEON_BLEND_CTL_ADD |
			  RADEON_CLAMP_TX);
	 RADEON_COLOR_ARG( 0, C );
	 break;
      case GL_MODULATE:
	 color_combine = (RADEON_COLOR_ARG_C_ZERO |
			  RADEON_BLEND_CTL_ADD |
			  RADEON_CLAMP_TX);
	 RADEON_COLOR_ARG( 0, A );
	 RADEON_COLOR_ARG( 1, B );
	 break;
      case GL_ADD:
	 color_combine = (RADEON_COLOR_ARG_B_ZERO |
			  RADEON_COMP_ARG_B |
			  RADEON_BLEND_CTL_ADD |
			  RADEON_CLAMP_TX);
	 RADEON_COLOR_ARG( 0, A );
	 RADEON_COLOR_ARG( 1, C );
	 break;
      case GL_ADD_SIGNED:
	 color_combine = (RADEON_COLOR_ARG_B_ZERO |
			  RADEON_COMP_ARG_B |
			  RADEON_BLEND_CTL_ADDSIGNED |
			  RADEON_CLAMP_TX);
	 RADEON_COLOR_ARG( 0, A );
	 RADEON_COLOR_ARG( 1, C );
	 break;
      case GL_SUBTRACT:
	 color_combine = (RADEON_COLOR_ARG_B_ZERO |
			  RADEON_COMP_ARG_B |
			  RADEON_BLEND_CTL_SUBTRACT |
			  RADEON_CLAMP_TX);
	 RADEON_COLOR_ARG( 0, A );
	 RADEON_COLOR_ARG( 1, C );
	 break;
      case GL_INTERPOLATE:
	 color_combine = (RADEON_BLEND_CTL_BLEND |
			  RADEON_CLAMP_TX);
	 RADEON_COLOR_ARG( 0, B );
	 RADEON_COLOR_ARG( 1, A );
	 RADEON_COLOR_ARG( 2, C );
	 break;

      case GL_DOT3_RGB_EXT:
      case GL_DOT3_RGBA_EXT:
	 /* The EXT version of the DOT3 extension does not support the
	  * scale factor, but the ARB version (and the version in OpenGL
	  * 1.3) does.
	  */
	 RGBshift = 0;
	 /* FALLTHROUGH */

      case GL_DOT3_RGB:
      case GL_DOT3_RGBA:
	 /* The R100 / RV200 only support a 1X multiplier in hardware
	  * w/the ARB version.
	  */
	 if ( RGBshift != (RADEON_SCALE_1X >> RADEON_SCALE_SHIFT) ) {
	    return GL_FALSE;
	 }

	 RGBshift += 2;
	 if ( (texUnit->_CurrentCombine->ModeRGB == GL_DOT3_RGBA_EXT)
	    || (texUnit->_CurrentCombine->ModeRGB == GL_DOT3_RGBA) ) {
            /* is it necessary to set this or will it be ignored anyway? */
	    Ashift = RGBshift;
	 }

	 color_combine = (RADEON_COLOR_ARG_C_ZERO |
			  RADEON_BLEND_CTL_DOT3 |
			  RADEON_CLAMP_TX);
	 RADEON_COLOR_ARG( 0, A );
	 RADEON_COLOR_ARG( 1, B );
	 break;

      case GL_MODULATE_ADD_ATI:
	 color_combine = (RADEON_BLEND_CTL_ADD |
			  RADEON_CLAMP_TX);
	 RADEON_COLOR_ARG( 0, A );
	 RADEON_COLOR_ARG( 1, C );
	 RADEON_COLOR_ARG( 2, B );
	 break;
      case GL_MODULATE_SIGNED_ADD_ATI:
	 color_combine = (RADEON_BLEND_CTL_ADDSIGNED |
			  RADEON_CLAMP_TX);
	 RADEON_COLOR_ARG( 0, A );
	 RADEON_COLOR_ARG( 1, C );
	 RADEON_COLOR_ARG( 2, B );
	 break;
      case GL_MODULATE_SUBTRACT_ATI:
	 color_combine = (RADEON_BLEND_CTL_SUBTRACT |
			  RADEON_CLAMP_TX);
	 RADEON_COLOR_ARG( 0, A );
	 RADEON_COLOR_ARG( 1, C );
	 RADEON_COLOR_ARG( 2, B );
	 break;
      default:
	 return GL_FALSE;
      }

      switch ( texUnit->_CurrentCombine->ModeA ) {
      case GL_REPLACE:
	 alpha_combine = (RADEON_ALPHA_ARG_A_ZERO |
			  RADEON_ALPHA_ARG_B_ZERO |
			  RADEON_BLEND_CTL_ADD |
			  RADEON_CLAMP_TX);
	 RADEON_ALPHA_ARG( 0, C );
	 break;
      case GL_MODULATE:
	 alpha_combine = (RADEON_ALPHA_ARG_C_ZERO |
			  RADEON_BLEND_CTL_ADD |
			  RADEON_CLAMP_TX);
	 RADEON_ALPHA_ARG( 0, A );
	 RADEON_ALPHA_ARG( 1, B );
	 break;
      case GL_ADD:
	 alpha_combine = (RADEON_ALPHA_ARG_B_ZERO |
			  RADEON_COMP_ARG_B |
			  RADEON_BLEND_CTL_ADD |
			  RADEON_CLAMP_TX);
	 RADEON_ALPHA_ARG( 0, A );
	 RADEON_ALPHA_ARG( 1, C );
	 break;
      case GL_ADD_SIGNED:
	 alpha_combine = (RADEON_ALPHA_ARG_B_ZERO |
			  RADEON_COMP_ARG_B |
			  RADEON_BLEND_CTL_ADDSIGNED |
			  RADEON_CLAMP_TX);
	 RADEON_ALPHA_ARG( 0, A );
	 RADEON_ALPHA_ARG( 1, C );
	 break;
      case GL_SUBTRACT:
	 alpha_combine = (RADEON_COLOR_ARG_B_ZERO |
			  RADEON_COMP_ARG_B |
			  RADEON_BLEND_CTL_SUBTRACT |
			  RADEON_CLAMP_TX);
	 RADEON_ALPHA_ARG( 0, A );
	 RADEON_ALPHA_ARG( 1, C );
	 break;
      case GL_INTERPOLATE:
	 alpha_combine = (RADEON_BLEND_CTL_BLEND |
			  RADEON_CLAMP_TX);
	 RADEON_ALPHA_ARG( 0, B );
	 RADEON_ALPHA_ARG( 1, A );
	 RADEON_ALPHA_ARG( 2, C );
	 break;

      case GL_MODULATE_ADD_ATI:
	 alpha_combine = (RADEON_BLEND_CTL_ADD |
			  RADEON_CLAMP_TX);
	 RADEON_ALPHA_ARG( 0, A );
	 RADEON_ALPHA_ARG( 1, C );
	 RADEON_ALPHA_ARG( 2, B );
	 break;
      case GL_MODULATE_SIGNED_ADD_ATI:
	 alpha_combine = (RADEON_BLEND_CTL_ADDSIGNED |
			  RADEON_CLAMP_TX);
	 RADEON_ALPHA_ARG( 0, A );
	 RADEON_ALPHA_ARG( 1, C );
	 RADEON_ALPHA_ARG( 2, B );
	 break;
      case GL_MODULATE_SUBTRACT_ATI:
	 alpha_combine = (RADEON_BLEND_CTL_SUBTRACT |
			  RADEON_CLAMP_TX);
	 RADEON_ALPHA_ARG( 0, A );
	 RADEON_ALPHA_ARG( 1, C );
	 RADEON_ALPHA_ARG( 2, B );
	 break;
      default:
	 return GL_FALSE;
      }

      if ( (texUnit->_CurrentCombine->ModeRGB == GL_DOT3_RGB_EXT)
	   || (texUnit->_CurrentCombine->ModeRGB == GL_DOT3_RGB) ) {
	 alpha_combine |= RADEON_DOT_ALPHA_DONT_REPLICATE;
      }

      /* Step 3:
       * Apply the scale factor.
       */
      color_combine |= (RGBshift << RADEON_SCALE_SHIFT);
      alpha_combine |= (Ashift   << RADEON_SCALE_SHIFT);

      /* All done!
       */
   }

   if ( rmesa->hw.tex[unit].cmd[TEX_PP_TXCBLEND] != color_combine ||
	rmesa->hw.tex[unit].cmd[TEX_PP_TXABLEND] != alpha_combine ) {
      RADEON_STATECHANGE( rmesa, tex[unit] );
      rmesa->hw.tex[unit].cmd[TEX_PP_TXCBLEND] = color_combine;
      rmesa->hw.tex[unit].cmd[TEX_PP_TXABLEND] = alpha_combine;
   }

   return GL_TRUE;
}

void radeonSetTexBuffer2(__DRIcontext *pDRICtx, GLint target, GLint texture_format,
			 __DRIdrawable *dPriv)
{
	struct gl_texture_object *texObj;
	struct gl_texture_image *texImage;
	struct radeon_renderbuffer *rb;
	radeon_texture_image *rImage;
	radeonContextPtr radeon;
	struct radeon_framebuffer *rfb;
	radeonTexObjPtr t;
	uint32_t pitch_val;
	mesa_format texFormat;

	radeon = pDRICtx->driverPrivate;

	rfb = dPriv->driverPrivate;
	texObj = _mesa_get_current_tex_object(&radeon->glCtx, target);
	texImage = _mesa_get_tex_image(&radeon->glCtx, texObj, target, 0);

	rImage = get_radeon_texture_image(texImage);
	t = radeon_tex_obj(texObj);
        if (t == NULL) {
    	    return;
    	}

	radeon_update_renderbuffers(pDRICtx, dPriv, GL_TRUE);
	rb = rfb->color_rb[0];
	if (rb->bo == NULL) {
		/* Failed to BO for the buffer */
		return;
	}

	_mesa_lock_texture(&radeon->glCtx, texObj);
	if (t->bo) {
		radeon_bo_unref(t->bo);
		t->bo = NULL;
	}
	if (rImage->bo) {
		radeon_bo_unref(rImage->bo);
		rImage->bo = NULL;
	}

	radeon_miptree_unreference(&t->mt);
	radeon_miptree_unreference(&rImage->mt);

	rImage->bo = rb->bo;
	radeon_bo_ref(rImage->bo);
	t->bo = rb->bo;
	radeon_bo_ref(t->bo);
	t->tile_bits = 0;
	t->image_override = GL_TRUE;
	t->override_offset = 0;
	switch (rb->cpp) {
	case 4:
		if (texture_format == __DRI_TEXTURE_FORMAT_RGB) {
			t->pp_txformat = tx_table[MESA_FORMAT_BGR_UNORM8].format;
			texFormat = MESA_FORMAT_BGR_UNORM8;
		}
		else {
			t->pp_txformat = tx_table[MESA_FORMAT_B8G8R8A8_UNORM].format;
			texFormat = MESA_FORMAT_B8G8R8A8_UNORM;
		}
		t->pp_txfilter |= tx_table[MESA_FORMAT_B8G8R8A8_UNORM].filter;
		break;
	case 3:
	default:
		texFormat = MESA_FORMAT_BGR_UNORM8;
		t->pp_txformat = tx_table[MESA_FORMAT_BGR_UNORM8].format;
		t->pp_txfilter |= tx_table[MESA_FORMAT_BGR_UNORM8].filter;
		break;
	case 2:
		texFormat = MESA_FORMAT_B5G6R5_UNORM;
		t->pp_txformat = tx_table[MESA_FORMAT_B5G6R5_UNORM].format;
		t->pp_txfilter |= tx_table[MESA_FORMAT_B5G6R5_UNORM].filter;
		break;
	}

	_mesa_init_teximage_fields(&radeon->glCtx, texImage,
				   rb->base.Base.Width, rb->base.Base.Height,
				   1, 0,
				   rb->cpp, texFormat);
	rImage->base.RowStride = rb->pitch / rb->cpp;

	t->pp_txpitch &= (1 << 13) -1;
	pitch_val = rb->pitch;

        t->pp_txsize = ((rb->base.Base.Width - 1) << RADEON_TEX_USIZE_SHIFT)
		| ((rb->base.Base.Height - 1) << RADEON_TEX_VSIZE_SHIFT);
	if (target == GL_TEXTURE_RECTANGLE_NV) {
		t->pp_txformat |= RADEON_TXFORMAT_NON_POWER2;
		t->pp_txpitch = pitch_val;
		t->pp_txpitch -= 32;
	} else {
	  t->pp_txformat &= ~(RADEON_TXFORMAT_WIDTH_MASK |
			      RADEON_TXFORMAT_HEIGHT_MASK |
			      RADEON_TXFORMAT_CUBIC_MAP_ENABLE |
			      RADEON_TXFORMAT_F5_WIDTH_MASK |
			      RADEON_TXFORMAT_F5_HEIGHT_MASK);
	  t->pp_txformat |= ((texImage->WidthLog2 << RADEON_TXFORMAT_WIDTH_SHIFT) |
			     (texImage->HeightLog2 << RADEON_TXFORMAT_HEIGHT_SHIFT));
	}
	t->validated = GL_TRUE;
	_mesa_unlock_texture(&radeon->glCtx, texObj);
	return;
}


void radeonSetTexBuffer(__DRIcontext *pDRICtx, GLint target, __DRIdrawable *dPriv)
{
        radeonSetTexBuffer2(pDRICtx, target, __DRI_TEXTURE_FORMAT_RGBA, dPriv);
}


#define TEXOBJ_TXFILTER_MASK (RADEON_MAX_MIP_LEVEL_MASK |	\
			      RADEON_MIN_FILTER_MASK | 		\
			      RADEON_MAG_FILTER_MASK |		\
			      RADEON_MAX_ANISO_MASK |		\
			      RADEON_YUV_TO_RGB |		\
			      RADEON_YUV_TEMPERATURE_MASK |	\
			      RADEON_CLAMP_S_MASK | 		\
			      RADEON_CLAMP_T_MASK | 		\
			      RADEON_BORDER_MODE_D3D )

#define TEXOBJ_TXFORMAT_MASK (RADEON_TXFORMAT_WIDTH_MASK |	\
			      RADEON_TXFORMAT_HEIGHT_MASK |	\
			      RADEON_TXFORMAT_FORMAT_MASK |	\
                              RADEON_TXFORMAT_F5_WIDTH_MASK |	\
                              RADEON_TXFORMAT_F5_HEIGHT_MASK |	\
			      RADEON_TXFORMAT_ALPHA_IN_MAP |	\
			      RADEON_TXFORMAT_CUBIC_MAP_ENABLE |	\
                              RADEON_TXFORMAT_NON_POWER2)


static void disable_tex_obj_state( r100ContextPtr rmesa, 
				   int unit )
{
   RADEON_STATECHANGE( rmesa, tex[unit] );

   RADEON_STATECHANGE( rmesa, tcl );
   rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] &= ~(RADEON_ST_BIT(unit) |
					     RADEON_Q_BIT(unit));
   
   if (rmesa->radeon.TclFallback & (RADEON_TCL_FALLBACK_TEXGEN_0<<unit)) {
     TCL_FALLBACK( &rmesa->radeon.glCtx, (RADEON_TCL_FALLBACK_TEXGEN_0<<unit), GL_FALSE);
     rmesa->recheck_texgen[unit] = GL_TRUE;
   }

   if (rmesa->hw.tex[unit].cmd[TEX_PP_TXFORMAT] & RADEON_TXFORMAT_CUBIC_MAP_ENABLE) {
     /* this seems to be a genuine (r100 only?) hw bug. Need to remove the
	cubic_map bit on unit 2 when the unit is disabled, otherwise every
	2nd (2d) mipmap on unit 0 will be broken (may not be needed for other
	units, better be safe than sorry though).*/
     RADEON_STATECHANGE( rmesa, tex[unit] );
     rmesa->hw.tex[unit].cmd[TEX_PP_TXFORMAT] &= ~RADEON_TXFORMAT_CUBIC_MAP_ENABLE;
   }

   {
      GLuint inputshift = RADEON_TEXGEN_0_INPUT_SHIFT + unit*4;
      GLuint tmp = rmesa->TexGenEnabled;

      rmesa->TexGenEnabled &= ~(RADEON_TEXGEN_TEXMAT_0_ENABLE<<unit);
      rmesa->TexGenEnabled &= ~(RADEON_TEXMAT_0_ENABLE<<unit);
      rmesa->TexGenEnabled &= ~(RADEON_TEXGEN_INPUT_MASK<<inputshift);
      rmesa->TexGenNeedNormals[unit] = 0;
      rmesa->TexGenEnabled |= 
	(RADEON_TEXGEN_INPUT_TEXCOORD_0+unit) << inputshift;

      if (tmp != rmesa->TexGenEnabled) {
	rmesa->recheck_texgen[unit] = GL_TRUE;
	rmesa->radeon.NewGLState |= _NEW_TEXTURE_MATRIX;
      }
   }
}

static void import_tex_obj_state( r100ContextPtr rmesa,
				  int unit,
				  radeonTexObjPtr texobj )
{
/* do not use RADEON_DB_STATE to avoid stale texture caches */
   uint32_t *cmd = &rmesa->hw.tex[unit].cmd[TEX_CMD_0];
   GLuint se_coord_fmt = rmesa->hw.set.cmd[SET_SE_COORDFMT];

   RADEON_STATECHANGE( rmesa, tex[unit] );

   cmd[TEX_PP_TXFILTER] &= ~TEXOBJ_TXFILTER_MASK;
   cmd[TEX_PP_TXFILTER] |= texobj->pp_txfilter & TEXOBJ_TXFILTER_MASK;
   cmd[TEX_PP_TXFORMAT] &= ~TEXOBJ_TXFORMAT_MASK;
   cmd[TEX_PP_TXFORMAT] |= texobj->pp_txformat & TEXOBJ_TXFORMAT_MASK;
   cmd[TEX_PP_BORDER_COLOR] = texobj->pp_border_color;

   if (texobj->pp_txformat & RADEON_TXFORMAT_NON_POWER2) {
      uint32_t *txr_cmd = &rmesa->hw.txr[unit].cmd[TXR_CMD_0];
      txr_cmd[TXR_PP_TEX_SIZE] = texobj->pp_txsize; /* NPOT only! */
      txr_cmd[TXR_PP_TEX_PITCH] = texobj->pp_txpitch; /* NPOT only! */
      RADEON_STATECHANGE( rmesa, txr[unit] );
   }

   if (texobj->base.Target == GL_TEXTURE_RECTANGLE_NV) {
      se_coord_fmt |= RADEON_VTX_ST0_NONPARAMETRIC << unit;
   }
   else {
      se_coord_fmt &= ~(RADEON_VTX_ST0_NONPARAMETRIC << unit);

      if (texobj->base.Target == GL_TEXTURE_CUBE_MAP) {
	 uint32_t *cube_cmd = &rmesa->hw.cube[unit].cmd[CUBE_CMD_0];

	 RADEON_STATECHANGE( rmesa, cube[unit] );
	 cube_cmd[CUBE_PP_CUBIC_FACES] = texobj->pp_cubic_faces;
	 /* state filled out in the cube_emit */
      }
   }

   if (se_coord_fmt != rmesa->hw.set.cmd[SET_SE_COORDFMT]) {
      RADEON_STATECHANGE( rmesa, set );
      rmesa->hw.set.cmd[SET_SE_COORDFMT] = se_coord_fmt;
   }

   rmesa->radeon.NewGLState |= _NEW_TEXTURE_MATRIX;
}


static void set_texgen_matrix( r100ContextPtr rmesa, 
			       GLuint unit,
			       const GLfloat *s_plane,
			       const GLfloat *t_plane,
			       const GLfloat *r_plane,
			       const GLfloat *q_plane )
{
   rmesa->TexGenMatrix[unit].m[0]  = s_plane[0];
   rmesa->TexGenMatrix[unit].m[4]  = s_plane[1];
   rmesa->TexGenMatrix[unit].m[8]  = s_plane[2];
   rmesa->TexGenMatrix[unit].m[12] = s_plane[3];

   rmesa->TexGenMatrix[unit].m[1]  = t_plane[0];
   rmesa->TexGenMatrix[unit].m[5]  = t_plane[1];
   rmesa->TexGenMatrix[unit].m[9]  = t_plane[2];
   rmesa->TexGenMatrix[unit].m[13] = t_plane[3];

   rmesa->TexGenMatrix[unit].m[2]  = r_plane[0];
   rmesa->TexGenMatrix[unit].m[6]  = r_plane[1];
   rmesa->TexGenMatrix[unit].m[10] = r_plane[2];
   rmesa->TexGenMatrix[unit].m[14] = r_plane[3];

   rmesa->TexGenMatrix[unit].m[3]  = q_plane[0];
   rmesa->TexGenMatrix[unit].m[7]  = q_plane[1];
   rmesa->TexGenMatrix[unit].m[11] = q_plane[2];
   rmesa->TexGenMatrix[unit].m[15] = q_plane[3];

   rmesa->TexGenEnabled |= RADEON_TEXMAT_0_ENABLE << unit;
   rmesa->radeon.NewGLState |= _NEW_TEXTURE_MATRIX;
}

/* Returns GL_FALSE if fallback required.
 */
static GLboolean radeon_validate_texgen( struct gl_context *ctx, GLuint unit )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   GLuint inputshift = RADEON_TEXGEN_0_INPUT_SHIFT + unit*4;
   GLuint tmp = rmesa->TexGenEnabled;
   static const GLfloat reflect[16] = {
      -1,  0,  0,  0,
       0, -1,  0,  0,
       0,  0,  -1, 0,
       0,  0,  0,  1 };

   rmesa->TexGenEnabled &= ~(RADEON_TEXGEN_TEXMAT_0_ENABLE << unit);
   rmesa->TexGenEnabled &= ~(RADEON_TEXMAT_0_ENABLE << unit);
   rmesa->TexGenEnabled &= ~(RADEON_TEXGEN_INPUT_MASK << inputshift);
   rmesa->TexGenNeedNormals[unit] = 0;

   if ((texUnit->TexGenEnabled & (S_BIT|T_BIT|R_BIT|Q_BIT)) == 0) {
      /* Disabled, no fallback:
       */
      rmesa->TexGenEnabled |=
	 (RADEON_TEXGEN_INPUT_TEXCOORD_0 + unit) << inputshift;
      return GL_TRUE;
   }
   /* the r100 cannot do texgen for some coords and not for others
    * we do not detect such cases (certainly can't do it here) and just
    * ASSUME that when S and T are texgen enabled we do not need other
    * non-texgen enabled coords, no matter if the R and Q bits are texgen
    * enabled. Still check for mixed mode texgen for all coords.
    */
   else if ( (texUnit->TexGenEnabled & S_BIT) &&
	     (texUnit->TexGenEnabled & T_BIT) &&
	     (texUnit->GenS.Mode == texUnit->GenT.Mode) ) {
      if ( ((texUnit->TexGenEnabled & R_BIT) &&
	    (texUnit->GenS.Mode != texUnit->GenR.Mode)) ||
	   ((texUnit->TexGenEnabled & Q_BIT) &&
	    (texUnit->GenS.Mode != texUnit->GenQ.Mode)) ) {
	 /* Mixed modes, fallback:
	  */
	 if (RADEON_DEBUG & RADEON_FALLBACKS)
	    fprintf(stderr, "fallback mixed texgen\n");
	 return GL_FALSE;
      }
      rmesa->TexGenEnabled |= RADEON_TEXGEN_TEXMAT_0_ENABLE << unit;
   }
   else {
   /* some texgen mode not including both S and T bits */
      if (RADEON_DEBUG & RADEON_FALLBACKS)
	 fprintf(stderr, "fallback mixed texgen/nontexgen\n");
      return GL_FALSE;
   }

   if ((texUnit->TexGenEnabled & (R_BIT | Q_BIT)) != 0) {
      /* need this here for vtxfmt presumably. Argh we need to set
         this from way too many places, would be much easier if we could leave
         tcl q coord always enabled as on r200) */
      RADEON_STATECHANGE( rmesa, tcl );
      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_Q_BIT(unit);
   }

   switch (texUnit->GenS.Mode) {
   case GL_OBJECT_LINEAR:
      rmesa->TexGenEnabled |= RADEON_TEXGEN_INPUT_OBJ << inputshift;
      set_texgen_matrix( rmesa, unit,
			 texUnit->GenS.ObjectPlane,
			 texUnit->GenT.ObjectPlane,
			 texUnit->GenR.ObjectPlane,
			 texUnit->GenQ.ObjectPlane);
      break;

   case GL_EYE_LINEAR:
      rmesa->TexGenEnabled |= RADEON_TEXGEN_INPUT_EYE << inputshift;
      set_texgen_matrix( rmesa, unit,
			 texUnit->GenS.EyePlane,
			 texUnit->GenT.EyePlane,
			 texUnit->GenR.EyePlane,
			 texUnit->GenQ.EyePlane);
      break;

   case GL_REFLECTION_MAP_NV:
      rmesa->TexGenNeedNormals[unit] = GL_TRUE;
      rmesa->TexGenEnabled |= RADEON_TEXGEN_INPUT_EYE_REFLECT << inputshift;
      /* TODO: unknown if this is needed/correct */
      set_texgen_matrix( rmesa, unit, reflect, reflect + 4,
			reflect + 8, reflect + 12 );
      break;

   case GL_NORMAL_MAP_NV:
      rmesa->TexGenNeedNormals[unit] = GL_TRUE;
      rmesa->TexGenEnabled |= RADEON_TEXGEN_INPUT_EYE_NORMAL << inputshift;
      break;

   case GL_SPHERE_MAP:
      /* the mode which everyone uses :-( */
   default:
      /* Unsupported mode, fallback:
       */
      if (RADEON_DEBUG & RADEON_FALLBACKS)
	 fprintf(stderr, "fallback GL_SPHERE_MAP\n");
      return GL_FALSE;
   }

   if (tmp != rmesa->TexGenEnabled) {
      rmesa->radeon.NewGLState |= _NEW_TEXTURE_MATRIX;
   }

   return GL_TRUE;
}

/**
 * Compute the cached hardware register values for the given texture object.
 *
 * \param rmesa Context pointer
 * \param t the r300 texture object
 */
static GLboolean setup_hardware_state(r100ContextPtr rmesa, radeonTexObj *t, int unit)
{
   const struct gl_texture_image *firstImage;
   GLint log2Width, log2Height, texelBytes;

   if ( t->bo ) {
	return GL_TRUE;
   }

   firstImage = t->base.Image[0][t->minLod];

   log2Width  = firstImage->WidthLog2;
   log2Height = firstImage->HeightLog2;
   texelBytes = _mesa_get_format_bytes(firstImage->TexFormat);

   if (!t->image_override) {
      if (VALID_FORMAT(firstImage->TexFormat)) {
	const struct tx_table *table = tx_table;

	 t->pp_txformat &= ~(RADEON_TXFORMAT_FORMAT_MASK |
			     RADEON_TXFORMAT_ALPHA_IN_MAP);
	 t->pp_txfilter &= ~RADEON_YUV_TO_RGB;	 
	 
	 t->pp_txformat |= table[ firstImage->TexFormat ].format;
	 t->pp_txfilter |= table[ firstImage->TexFormat ].filter;
      } else {
	 _mesa_problem(NULL, "unexpected texture format in %s",
		       __FUNCTION__);
	 return GL_FALSE;
      }
   }

   t->pp_txfilter &= ~RADEON_MAX_MIP_LEVEL_MASK;
   t->pp_txfilter |= (t->maxLod - t->minLod) << RADEON_MAX_MIP_LEVEL_SHIFT;
	
   t->pp_txformat &= ~(RADEON_TXFORMAT_WIDTH_MASK |
		       RADEON_TXFORMAT_HEIGHT_MASK |
		       RADEON_TXFORMAT_CUBIC_MAP_ENABLE |
		       RADEON_TXFORMAT_F5_WIDTH_MASK |
		       RADEON_TXFORMAT_F5_HEIGHT_MASK);
   t->pp_txformat |= ((log2Width << RADEON_TXFORMAT_WIDTH_SHIFT) |
		      (log2Height << RADEON_TXFORMAT_HEIGHT_SHIFT));

   t->tile_bits = 0;

   if (t->base.Target == GL_TEXTURE_CUBE_MAP) {
      ASSERT(log2Width == log2Height);
      t->pp_txformat |= ((log2Width << RADEON_TXFORMAT_F5_WIDTH_SHIFT) |
			 (log2Height << RADEON_TXFORMAT_F5_HEIGHT_SHIFT) |
			 /* don't think we need this bit, if it exists at all - fglrx does not set it */
			 (RADEON_TXFORMAT_CUBIC_MAP_ENABLE));
      t->pp_cubic_faces = ((log2Width << RADEON_FACE_WIDTH_1_SHIFT) |
                           (log2Height << RADEON_FACE_HEIGHT_1_SHIFT) |
                           (log2Width << RADEON_FACE_WIDTH_2_SHIFT) |
                           (log2Height << RADEON_FACE_HEIGHT_2_SHIFT) |
                           (log2Width << RADEON_FACE_WIDTH_3_SHIFT) |
                           (log2Height << RADEON_FACE_HEIGHT_3_SHIFT) |
                           (log2Width << RADEON_FACE_WIDTH_4_SHIFT) |
                           (log2Height << RADEON_FACE_HEIGHT_4_SHIFT));
   }

   t->pp_txsize = (((firstImage->Width - 1) << RADEON_TEX_USIZE_SHIFT)
		   | ((firstImage->Height - 1) << RADEON_TEX_VSIZE_SHIFT));

   if ( !t->image_override ) {
      if (_mesa_is_format_compressed(firstImage->TexFormat))
         t->pp_txpitch = (firstImage->Width + 63) & ~(63);
      else
         t->pp_txpitch = ((firstImage->Width * texelBytes) + 63) & ~(63);
      t->pp_txpitch -= 32;
   }

   if (t->base.Target == GL_TEXTURE_RECTANGLE_NV) {
      t->pp_txformat |= RADEON_TXFORMAT_NON_POWER2;
   }

   return GL_TRUE;
}

static GLboolean radeon_validate_texture(struct gl_context *ctx, struct gl_texture_object *texObj, int unit)
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   radeonTexObj *t = radeon_tex_obj(texObj);
   int ret;

   if (!radeon_validate_texture_miptree(ctx, _mesa_get_samplerobj(ctx, unit), texObj))
      return GL_FALSE;

   ret = setup_hardware_state(rmesa, t, unit);
   if (ret == GL_FALSE)
     return GL_FALSE;

   /* yuv conversion only works in first unit */
   if (unit != 0 && (t->pp_txfilter & RADEON_YUV_TO_RGB))
      return GL_FALSE;

   RADEON_STATECHANGE( rmesa, ctx );
   rmesa->hw.ctx.cmd[CTX_PP_CNTL] |= 
     (RADEON_TEX_0_ENABLE | RADEON_TEX_BLEND_0_ENABLE) << unit;
   RADEON_STATECHANGE( rmesa, tcl );
   rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_ST_BIT(unit);

   rmesa->recheck_texgen[unit] = GL_TRUE;

   radeonTexUpdateParameters(ctx, unit);
   import_tex_obj_state( rmesa, unit, t );

   if (rmesa->recheck_texgen[unit]) {
      GLboolean fallback = !radeon_validate_texgen( ctx, unit );
      TCL_FALLBACK( ctx, (RADEON_TCL_FALLBACK_TEXGEN_0<<unit), fallback);
      rmesa->recheck_texgen[unit] = 0;
      rmesa->radeon.NewGLState |= _NEW_TEXTURE_MATRIX;
   }

   if ( ! radeonUpdateTextureEnv( ctx, unit ) ) {
     return GL_FALSE;
   }
   FALLBACK( rmesa, RADEON_FALLBACK_BORDER_MODE, t->border_fallback );

   t->validated = GL_TRUE;
   return !t->border_fallback;
}

static GLboolean radeonUpdateTextureUnit( struct gl_context *ctx, int unit )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);

   if (ctx->Texture.Unit[unit]._Current &&
       ctx->Texture.Unit[unit]._Current->Target == GL_TEXTURE_3D) {
     disable_tex_obj_state(rmesa, unit);
     rmesa->state.texture.unit[unit].texobj = NULL;
     return GL_FALSE;
   }

   if (!ctx->Texture.Unit[unit]._Current) {
     /* disable the unit */
     disable_tex_obj_state(rmesa, unit);
     rmesa->state.texture.unit[unit].texobj = NULL;
     return GL_TRUE;
   }

   if (!radeon_validate_texture(ctx, ctx->Texture.Unit[unit]._Current, unit)) {
    _mesa_warning(ctx,
		  "failed to validate texture for unit %d.\n",
		  unit);
     rmesa->state.texture.unit[unit].texobj = NULL;
     return GL_FALSE;
   }
   rmesa->state.texture.unit[unit].texobj = radeon_tex_obj(ctx->Texture.Unit[unit]._Current);
   return GL_TRUE;
}

void radeonUpdateTextureState( struct gl_context *ctx )
{
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   GLboolean ok;

   /* set the ctx all textures off */
   RADEON_STATECHANGE( rmesa, ctx );
   rmesa->hw.ctx.cmd[CTX_PP_CNTL] &= ~((RADEON_TEX_ENABLE_MASK) | (RADEON_TEX_BLEND_ENABLE_MASK));

   ok = (radeonUpdateTextureUnit( ctx, 0 ) &&
	 radeonUpdateTextureUnit( ctx, 1 ) &&
	 radeonUpdateTextureUnit( ctx, 2 ));

   FALLBACK( rmesa, RADEON_FALLBACK_TEXTURE, !ok );

   if (rmesa->radeon.TclFallback)
      radeonChooseVertexState( ctx );
}
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@a65 12
#define _COLOR(f) \
    [ MESA_FORMAT_ ## f ] = { RADEON_TXFORMAT_ ## f, 0 }
#define _COLOR_REV(f) \
    [ MESA_FORMAT_ ## f ## _REV ] = { RADEON_TXFORMAT_ ## f, 0 }
#define _ALPHA(f) \
    [ MESA_FORMAT_ ## f ] = { RADEON_TXFORMAT_ ## f | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 }
#define _ALPHA_REV(f) \
    [ MESA_FORMAT_ ## f ## _REV ] = { RADEON_TXFORMAT_ ## f | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 }
#define _YUV(f) \
   [ MESA_FORMAT_ ## f ] = { RADEON_TXFORMAT_ ## f, RADEON_YUV_TO_RGB }
#define _INVALID(f) \
    [ MESA_FORMAT_ ## f ] = { 0xffffffff, 0 }
d76 25
a100 25
   _INVALID(NONE), /* MESA_FORMAT_NONE */
   _ALPHA(RGBA8888),
   _ALPHA_REV(RGBA8888),
   _ALPHA(ARGB8888),
   _ALPHA_REV(ARGB8888),
   [ MESA_FORMAT_RGB888 ] = { RADEON_TXFORMAT_ARGB8888, 0 },
   _COLOR(RGB565),
   _COLOR_REV(RGB565),
   _ALPHA(ARGB4444),
   _ALPHA_REV(ARGB4444),
   _ALPHA(ARGB1555),
   _ALPHA_REV(ARGB1555),
   _ALPHA(AL88),
   _ALPHA_REV(AL88),
   _ALPHA(A8),
   _COLOR(L8),
   _ALPHA(I8),
   _YUV(YCBCR),
   _YUV(YCBCR_REV),
   _INVALID(RGB_FXT1),
   _INVALID(RGBA_FXT1),
   _COLOR(RGB_DXT1),
   _ALPHA(RGBA_DXT1),
   _ALPHA(RGBA_DXT3),
   _ALPHA(RGBA_DXT5),
a102 4
#undef _COLOR
#undef _ALPHA
#undef _INVALID

a259 6
   /* texUnit->_Current can be NULL if and only if the texture unit is
    * not actually enabled.
    */
   assert( (texUnit->_ReallyEnabled == 0)
	   || (texUnit->_Current != NULL) );

d276 1
a276 1
   if ( !texUnit->_ReallyEnabled ) {
a585 1
	struct gl_texture_unit *texUnit;
d594 1
a594 1
	gl_format texFormat;
d599 2
a600 3
        texUnit = _mesa_get_current_tex_unit(&radeon->glCtx);
	texObj = _mesa_select_tex_object(&radeon->glCtx, texUnit, target);
        texImage = _mesa_get_tex_image(&radeon->glCtx, texObj, target, 0);
d638 2
a639 2
			t->pp_txformat = tx_table[MESA_FORMAT_RGB888].format;
			texFormat = MESA_FORMAT_RGB888;
d642 2
a643 2
			t->pp_txformat = tx_table[MESA_FORMAT_ARGB8888].format;
			texFormat = MESA_FORMAT_ARGB8888;
d645 1
a645 1
		t->pp_txfilter |= tx_table[MESA_FORMAT_ARGB8888].filter;
d649 3
a651 3
		texFormat = MESA_FORMAT_RGB888;
		t->pp_txformat = tx_table[MESA_FORMAT_RGB888].format;
		t->pp_txfilter |= tx_table[MESA_FORMAT_RGB888].filter;
d654 3
a656 3
		texFormat = MESA_FORMAT_RGB565;
		t->pp_txformat = tx_table[MESA_FORMAT_RGB565].format;
		t->pp_txfilter |= tx_table[MESA_FORMAT_RGB565].filter;
d1079 2
a1080 1
   if (ctx->Texture.Unit[unit]._ReallyEnabled & TEXTURE_3D_BIT) {
d1086 1
a1086 1
   if (!ctx->Texture.Unit[unit]._ReallyEnabled) {
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d45 1
a104 1
   _INVALID(CI8),
a604 37
void radeonSetTexOffset(__DRIcontext * pDRICtx, GLint texname,
                        unsigned long long offset, GLint depth, GLuint pitch)
{
	r100ContextPtr rmesa = pDRICtx->driverPrivate;
	struct gl_texture_object *tObj =
	    _mesa_lookup_texture(rmesa->radeon.glCtx, texname);
	radeonTexObjPtr t = radeon_tex_obj(tObj);

	if (tObj == NULL)
		return;

	t->image_override = GL_TRUE;

	if (!offset)
		return;
	
	t->bo = NULL;
	t->override_offset = offset;
	t->pp_txpitch = pitch - 32;

	switch (depth) {
	case 32:
		t->pp_txformat = tx_table[MESA_FORMAT_ARGB8888].format;
		t->pp_txfilter |= tx_table[MESA_FORMAT_ARGB8888].filter;
		break;
	case 24:
	default:
		t->pp_txformat = tx_table[MESA_FORMAT_RGB888].format;
		t->pp_txfilter |= tx_table[MESA_FORMAT_RGB888].filter;
		break;
	case 16:
		t->pp_txformat = tx_table[MESA_FORMAT_RGB565].format;
		t->pp_txfilter |= tx_table[MESA_FORMAT_RGB565].filter;
		break;
	}
}

a613 1
	r100ContextPtr rmesa;
a616 1
	uint32_t internalFormat, format;
a618 3
	format = GL_UNSIGNED_BYTE;
	internalFormat = (texture_format == __DRI_TEXTURE_FORMAT_RGB ? GL_RGB : GL_RGBA);

a619 1
	rmesa = pDRICtx->driverPrivate;
d622 3
a624 3
        texUnit = _mesa_get_current_tex_unit(radeon->glCtx);
	texObj = _mesa_select_tex_object(radeon->glCtx, texUnit, target);
        texImage = _mesa_get_tex_image(radeon->glCtx, texObj, target, 0);
d639 1
a639 1
	_mesa_lock_texture(radeon->glCtx, texObj);
d684 3
a686 2
	_mesa_init_teximage_fields(radeon->glCtx, target, texImage,
				   rb->base.Width, rb->base.Height, 1, 0,
d688 1
a688 1
	texImage->RowStride = rb->pitch / rb->cpp;
d693 2
a694 2
        t->pp_txsize = ((rb->base.Width - 1) << RADEON_TEX_USIZE_SHIFT)
		| ((rb->base.Height - 1) << RADEON_TEX_VSIZE_SHIFT);
d709 1
a709 1
	_mesa_unlock_texture(radeon->glCtx, texObj);
d750 1
a750 1
     TCL_FALLBACK( rmesa->radeon.glCtx, (RADEON_TCL_FALLBACK_TEXGEN_0<<unit), GL_FALSE);
d979 1
a979 1
   GLint log2Width, log2Height, log2Depth, texelBytes;
a986 5
   if (firstImage->Border > 0) {
      fprintf(stderr, "%s: border\n", __FUNCTION__);
      return GL_FALSE;
   }

a988 1
   log2Depth  = firstImage->DepthLog2;
d1061 1
a1061 1
   if (!radeon_validate_texture_miptree(ctx, texObj))
d1080 1
d1104 1
@


1.5
log
@Merge Mesa 7.10.3
@
text
@a641 15
static int
logbase2(int n)
{
   GLint i = 1;
   GLint log2 = 0;

   while (n > i) {
      i *= 2;
      log2++;
   }

   return log2;
}


@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d263 1
a263 1
static GLboolean radeonUpdateTextureEnv( GLcontext *ctx, int unit )
d642 15
d670 2
a671 1
	uint32_t internalFormat, type, format;
a672 1
	type = GL_BGRA;
d674 1
a674 1
	internalFormat = (texture_format == __DRI_TEXTURE_FORMAT_RGB ? 3 : 4);
a709 4
	_mesa_init_teximage_fields(radeon->glCtx, target, texImage,
				   rb->base.Width, rb->base.Height, 1, 0, rb->cpp);
	texImage->RowStride = rb->pitch / rb->cpp;

d719 1
a719 1
		if (texture_format == __DRI_TEXTURE_FORMAT_RGB)
d721 3
a723 1
		else
d725 2
d731 1
d736 1
d742 5
d756 8
d918 1
a918 1
static GLboolean radeon_validate_texgen( GLcontext *ctx, GLuint unit )
d1118 1
a1118 1
static GLboolean radeon_validate_texture(GLcontext *ctx, struct gl_texture_object *texObj, int unit)
d1161 1
a1161 1
static GLboolean radeonUpdateTextureUnit( GLcontext *ctx, int unit )
d1188 1
a1188 1
void radeonUpdateTextureState( GLcontext *ctx )
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d41 2
a42 1
#include "main/texformat.h"
d47 1
d80 1
a80 1
static const struct {
d82 4
a85 2
}
tx_table[] =
d87 1
a118 246
/**
 * This function computes the number of bytes of storage needed for
 * the given texture object (all mipmap levels, all cube faces).
 * The \c image[face][level].x/y/width/height parameters for upload/blitting
 * are computed here.  \c pp_txfilter, \c pp_txformat, etc. will be set here
 * too.
 * 
 * \param rmesa Context pointer
 * \param tObj GL texture object whose images are to be posted to
 *                 hardware state.
 */
static void radeonSetTexImages( radeonContextPtr rmesa,
				struct gl_texture_object *tObj )
{
   radeonTexObjPtr t = (radeonTexObjPtr)tObj->DriverData;
   const struct gl_texture_image *baseImage = tObj->Image[0][tObj->BaseLevel];
   GLint curOffset, blitWidth;
   GLint i, texelBytes;
   GLint numLevels;
   GLint log2Width, log2Height, log2Depth;

   /* Set the hardware texture format
    */
   if ( !t->image_override ) {
      t->pp_txformat &= ~(RADEON_TXFORMAT_FORMAT_MASK |
                          RADEON_TXFORMAT_ALPHA_IN_MAP);
      t->pp_txfilter &= ~RADEON_YUV_TO_RGB;

      if ( VALID_FORMAT( baseImage->TexFormat->MesaFormat ) ) {
         t->pp_txformat |= tx_table[ baseImage->TexFormat->MesaFormat ].format;
         t->pp_txfilter |= tx_table[ baseImage->TexFormat->MesaFormat ].filter;
      }
      else {
         _mesa_problem(NULL, "unexpected texture format in %s", __FUNCTION__);
         return;
      }
   }

   texelBytes = baseImage->TexFormat->TexelBytes;

   /* Compute which mipmap levels we really want to send to the hardware.
    */

   if (tObj->Target != GL_TEXTURE_CUBE_MAP)
      driCalculateTextureFirstLastLevel( (driTextureObject *) t );
   else {
      /* r100 can't handle mipmaps for cube/3d textures, so don't waste
         memory for them */
      t->base.firstLevel = t->base.lastLevel = tObj->BaseLevel;
   }
   log2Width  = tObj->Image[0][t->base.firstLevel]->WidthLog2;
   log2Height = tObj->Image[0][t->base.firstLevel]->HeightLog2;
   log2Depth  = tObj->Image[0][t->base.firstLevel]->DepthLog2;

   numLevels = t->base.lastLevel - t->base.firstLevel + 1;

   assert(numLevels <= RADEON_MAX_TEXTURE_LEVELS);

   /* Calculate mipmap offsets and dimensions for blitting (uploading)
    * The idea is that we lay out the mipmap levels within a block of
    * memory organized as a rectangle of width BLIT_WIDTH_BYTES.
    */
   curOffset = 0;
   blitWidth = BLIT_WIDTH_BYTES;
   t->tile_bits = 0;

   /* figure out if this texture is suitable for tiling. */
   if (texelBytes && (tObj->Target != GL_TEXTURE_RECTANGLE_NV)) {
      if (rmesa->texmicrotile && (baseImage->Height > 1)) {
	 /* allow 32 (bytes) x 1 mip (which will use two times the space
	    the non-tiled version would use) max if base texture is large enough */
	 if ((numLevels == 1) ||
	   (((baseImage->Width * texelBytes / baseImage->Height) <= 32) &&
	       (baseImage->Width * texelBytes > 64)) ||
	    ((baseImage->Width * texelBytes / baseImage->Height) <= 16)) {
	    /* R100 has two microtile bits (only the txoffset reg, not the blitter)
	       weird: X2 + OPT: 32bit correct, 16bit completely hosed
		      X2: 32bit correct, 16bit correct
		      OPT: 32bit large mips correct, small mips hosed, 16bit completely hosed */
	    t->tile_bits |= RADEON_TXO_MICRO_TILE_X2 /*| RADEON_TXO_MICRO_TILE_OPT*/;
	 }
      }
      if ((baseImage->Width * texelBytes >= 256) && (baseImage->Height >= 16)) {
	 /* R100 disables macro tiling only if mip width is smaller than 256 bytes, and not
	    in the case if height is smaller than 16 (not 100% sure), as does the r200,
	    so need to disable macro tiling in that case */
	 if ((numLevels == 1) || ((baseImage->Width * texelBytes / baseImage->Height) <= 4)) {
	    t->tile_bits |= RADEON_TXO_MACRO_TILE;
	 }
      }
   }

   for (i = 0; i < numLevels; i++) {
      const struct gl_texture_image *texImage;
      GLuint size;

      texImage = tObj->Image[0][i + t->base.firstLevel];
      if ( !texImage )
	 break;

      /* find image size in bytes */
      if (texImage->IsCompressed) {
      /* need to calculate the size AFTER padding even though the texture is
         submitted without padding.
         Only handle pot textures currently - don't know if npot is even possible,
         size calculation would certainly need (trivial) adjustments.
         Align (and later pad) to 32byte, not sure what that 64byte blit width is
         good for? */
         if ((t->pp_txformat & RADEON_TXFORMAT_FORMAT_MASK) == RADEON_TXFORMAT_DXT1) {
            /* RGB_DXT1/RGBA_DXT1, 8 bytes per block */
            if ((texImage->Width + 3) < 8) /* width one block */
               size = texImage->CompressedSize * 4;
            else if ((texImage->Width + 3) < 16)
               size = texImage->CompressedSize * 2;
            else size = texImage->CompressedSize;
         }
         else /* DXT3/5, 16 bytes per block */
            if ((texImage->Width + 3) < 8)
               size = texImage->CompressedSize * 2;
            else size = texImage->CompressedSize;
      }
      else if (tObj->Target == GL_TEXTURE_RECTANGLE_NV) {
	 size = ((texImage->Width * texelBytes + 63) & ~63) * texImage->Height;
      }
      else if (t->tile_bits & RADEON_TXO_MICRO_TILE_X2) {
	 /* tile pattern is 16 bytes x2. mipmaps stay 32 byte aligned,
	    though the actual offset may be different (if texture is less than
	    32 bytes width) to the untiled case */
	 int w = (texImage->Width * texelBytes * 2 + 31) & ~31;
	 size = (w * ((texImage->Height + 1) / 2)) * texImage->Depth;
	 blitWidth = MAX2(texImage->Width, 64 / texelBytes);
      }
      else {
	 int w = (texImage->Width * texelBytes + 31) & ~31;
	 size = w * texImage->Height * texImage->Depth;
	 blitWidth = MAX2(texImage->Width, 64 / texelBytes);
      }
      assert(size > 0);

      /* Align to 32-byte offset.  It is faster to do this unconditionally
       * (no branch penalty).
       */

      curOffset = (curOffset + 0x1f) & ~0x1f;

      if (texelBytes) {
	 t->image[0][i].x = curOffset; /* fix x and y coords up later together with offset */
	 t->image[0][i].y = 0;
	 t->image[0][i].width = MIN2(size / texelBytes, blitWidth);
	 t->image[0][i].height = (size / texelBytes) / t->image[0][i].width;
      }
      else {
         t->image[0][i].x = curOffset % BLIT_WIDTH_BYTES;
         t->image[0][i].y = curOffset / BLIT_WIDTH_BYTES;
         t->image[0][i].width  = MIN2(size, BLIT_WIDTH_BYTES);
         t->image[0][i].height = size / t->image[0][i].width;     
      }

#if 0
      /* for debugging only and only  applicable to non-rectangle targets */
      assert(size % t->image[0][i].width == 0);
      assert(t->image[0][i].x == 0
             || (size < BLIT_WIDTH_BYTES && t->image[0][i].height == 1));
#endif

      if (0)
         fprintf(stderr,
                 "level %d: %dx%d x=%d y=%d w=%d h=%d size=%d at %d\n",
                 i, texImage->Width, texImage->Height,
                 t->image[0][i].x, t->image[0][i].y,
                 t->image[0][i].width, t->image[0][i].height, size, curOffset);

      curOffset += size;

   }

   /* Align the total size of texture memory block.
    */
   t->base.totalSize = (curOffset + RADEON_OFFSET_MASK) & ~RADEON_OFFSET_MASK;

   /* Setup remaining cube face blits, if needed */
   if (tObj->Target == GL_TEXTURE_CUBE_MAP) {
      const GLuint faceSize = t->base.totalSize;
      GLuint face;
      /* reuse face 0 x/y/width/height - just update the offset when uploading */
      for (face = 1; face < 6; face++) {
         for (i = 0; i < numLevels; i++) {
            t->image[face][i].x =  t->image[0][i].x;
            t->image[face][i].y =  t->image[0][i].y;
            t->image[face][i].width  = t->image[0][i].width;
            t->image[face][i].height = t->image[0][i].height;
         }
      }
      t->base.totalSize = 6 * faceSize; /* total texmem needed */
   }

   /* Hardware state:
    */
   t->pp_txfilter &= ~RADEON_MAX_MIP_LEVEL_MASK;
   t->pp_txfilter |= (numLevels - 1) << RADEON_MAX_MIP_LEVEL_SHIFT;

   t->pp_txformat &= ~(RADEON_TXFORMAT_WIDTH_MASK |
		       RADEON_TXFORMAT_HEIGHT_MASK |
                       RADEON_TXFORMAT_CUBIC_MAP_ENABLE |
                       RADEON_TXFORMAT_F5_WIDTH_MASK |
                       RADEON_TXFORMAT_F5_HEIGHT_MASK);
   t->pp_txformat |= ((log2Width << RADEON_TXFORMAT_WIDTH_SHIFT) |
		      (log2Height << RADEON_TXFORMAT_HEIGHT_SHIFT));

   if (tObj->Target == GL_TEXTURE_CUBE_MAP) {
      assert(log2Width == log2Height);
      t->pp_txformat |= ((log2Width << RADEON_TXFORMAT_F5_WIDTH_SHIFT) |
                         (log2Height << RADEON_TXFORMAT_F5_HEIGHT_SHIFT) |
                         (RADEON_TXFORMAT_CUBIC_MAP_ENABLE));
      t->pp_cubic_faces = ((log2Width << RADEON_FACE_WIDTH_1_SHIFT) |
                           (log2Height << RADEON_FACE_HEIGHT_1_SHIFT) |
                           (log2Width << RADEON_FACE_WIDTH_2_SHIFT) |
                           (log2Height << RADEON_FACE_HEIGHT_2_SHIFT) |
                           (log2Width << RADEON_FACE_WIDTH_3_SHIFT) |
                           (log2Height << RADEON_FACE_HEIGHT_3_SHIFT) |
                           (log2Width << RADEON_FACE_WIDTH_4_SHIFT) |
                           (log2Height << RADEON_FACE_HEIGHT_4_SHIFT));
   }

   t->pp_txsize = (((tObj->Image[0][t->base.firstLevel]->Width - 1) << 0) |
                   ((tObj->Image[0][t->base.firstLevel]->Height - 1) << 16));

   /* Only need to round to nearest 32 for textures, but the blitter
    * requires 64-byte aligned pitches, and we may/may not need the
    * blitter.   NPOT only!
    */
   if ( !t->image_override ) {
      if (baseImage->IsCompressed)
         t->pp_txpitch = (tObj->Image[0][t->base.firstLevel]->Width + 63) & ~(63);
      else
         t->pp_txpitch = ((tObj->Image[0][t->base.firstLevel]->Width * texelBytes) + 63) & ~(63);
      t->pp_txpitch -= 32;
   }

   t->dirty_state = TEX_ALL;

   /* FYI: radeonUploadTexImages( rmesa, t ); used to be called here */
}



d265 1
a265 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d282 1
a282 1
   if ( RADEON_DEBUG & DEBUG_TEXTURE ) {
d608 1
a608 1
	radeonContextPtr rmesa = pDRICtx->driverPrivate;
d610 2
a611 2
	    _mesa_lookup_texture(rmesa->glCtx, texname);
	radeonTexObjPtr t;
a615 2
	t = (radeonTexObjPtr) tObj->DriverData;

d620 3
a622 2

	t->pp_txoffset = offset;
d642 105
d767 42
a808 1
static void import_tex_obj_state( radeonContextPtr rmesa,
d813 1
a813 1
   int *cmd = &rmesa->hw.tex[unit].cmd[TEX_CMD_0];
a821 1
   cmd[TEX_PP_TXOFFSET] = texobj->pp_txoffset;
d824 2
a825 2
   if (texobj->base.tObj->Target == GL_TEXTURE_RECTANGLE_NV) {
      GLuint *txr_cmd = RADEON_DB_STATE( txr[unit] );
d828 4
a831 1
      RADEON_DB_STATECHANGE( rmesa, &rmesa->hw.txr[unit] );
d837 2
a838 4
      if (texobj->base.tObj->Target == GL_TEXTURE_CUBE_MAP) {
	 int *cube_cmd = &rmesa->hw.cube[unit].cmd[CUBE_CMD_0];
	 GLuint bytesPerFace = texobj->base.totalSize / 6;
	 ASSERT(texobj->base.totalSize % 6 == 0);
d842 1
a842 9
	 /* dont know if this setup conforms to OpenGL.. 
	  * at least it matches the behavior of mesa software renderer
	  */
	 cube_cmd[CUBE_PP_CUBIC_OFFSET_0] = texobj->pp_txoffset; /* right */
	 cube_cmd[CUBE_PP_CUBIC_OFFSET_1] = texobj->pp_txoffset + 1 * bytesPerFace; /* left */
	 cube_cmd[CUBE_PP_CUBIC_OFFSET_2] = texobj->pp_txoffset + 2 * bytesPerFace; /* top */
	 cube_cmd[CUBE_PP_CUBIC_OFFSET_3] = texobj->pp_txoffset + 3 * bytesPerFace; /* bottom */
	 cube_cmd[CUBE_PP_CUBIC_OFFSET_4] = texobj->pp_txoffset + 4 * bytesPerFace; /* front */
	 cmd[TEX_PP_TXOFFSET] = texobj->pp_txoffset + 5 * bytesPerFace; /* back */
d851 1
a851 1
   texobj->dirty_state &= ~(1<<unit);
d855 1
a855 3


static void set_texgen_matrix( radeonContextPtr rmesa, 
d883 1
a883 1
   rmesa->NewGLState |= _NEW_TEXTURE_MATRIX;
d890 1
a890 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d920 1
a920 1
	     (texUnit->GenModeS == texUnit->GenModeT) ) {
d922 1
a922 1
	    (texUnit->GenModeS != texUnit->GenModeR)) ||
d924 1
a924 1
	    (texUnit->GenModeS != texUnit->GenModeQ)) ) {
d927 1
a927 1
	 if (RADEON_DEBUG & DEBUG_FALLBACKS)
d935 1
a935 1
      if (RADEON_DEBUG & DEBUG_FALLBACKS)
d948 1
a948 1
   switch (texUnit->GenModeS) {
d952 4
a955 4
			 texUnit->ObjectPlaneS,
			 texUnit->ObjectPlaneT,
			 texUnit->ObjectPlaneR,
			 texUnit->ObjectPlaneQ);
d961 4
a964 4
			 texUnit->EyePlaneS,
			 texUnit->EyePlaneT,
			 texUnit->EyePlaneR,
			 texUnit->EyePlaneQ);
d985 1
a985 1
      if (RADEON_DEBUG & DEBUG_FALLBACKS) 
d991 1
a991 1
      rmesa->NewGLState |= _NEW_TEXTURE_MATRIX;
d997 7
a1003 2

static void disable_tex( GLcontext *ctx, int unit )
d1005 2
a1006 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d1008 3
a1010 6
   if (rmesa->hw.ctx.cmd[CTX_PP_CNTL] & (RADEON_TEX_0_ENABLE<<unit)) {
      /* Texture unit disabled */
      if ( rmesa->state.texture.unit[unit].texobj != NULL ) {
	 /* The old texture is no longer bound to this texture unit.
	  * Mark it as such.
	  */
d1012 1
a1012 3
	 rmesa->state.texture.unit[unit].texobj->base.bound &= ~(1UL << unit);
	 rmesa->state.texture.unit[unit].texobj = NULL;
      }
d1014 4
a1017 3
      RADEON_STATECHANGE( rmesa, ctx );
      rmesa->hw.ctx.cmd[CTX_PP_CNTL] &= 
	  ~((RADEON_TEX_0_ENABLE | RADEON_TEX_BLEND_0_ENABLE) << unit);
d1019 19
a1037 33
      RADEON_STATECHANGE( rmesa, tcl );
      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] &= ~(RADEON_ST_BIT(unit) |
						RADEON_Q_BIT(unit));

      if (rmesa->TclFallback & (RADEON_TCL_FALLBACK_TEXGEN_0<<unit)) {
	 TCL_FALLBACK( ctx, (RADEON_TCL_FALLBACK_TEXGEN_0<<unit), GL_FALSE);
	 rmesa->recheck_texgen[unit] = GL_TRUE;
      }

      if (rmesa->hw.tex[unit].cmd[TEX_PP_TXFORMAT] & RADEON_TXFORMAT_CUBIC_MAP_ENABLE) {
      /* this seems to be a genuine (r100 only?) hw bug. Need to remove the
         cubic_map bit on unit 2 when the unit is disabled, otherwise every
	 2nd (2d) mipmap on unit 0 will be broken (may not be needed for other
	 units, better be safe than sorry though).*/
	 RADEON_STATECHANGE( rmesa, tex[unit] );
	 rmesa->hw.tex[unit].cmd[TEX_PP_TXFORMAT] &= ~RADEON_TXFORMAT_CUBIC_MAP_ENABLE;
      }

      {
	 GLuint inputshift = RADEON_TEXGEN_0_INPUT_SHIFT + unit*4;
	 GLuint tmp = rmesa->TexGenEnabled;

	 rmesa->TexGenEnabled &= ~(RADEON_TEXGEN_TEXMAT_0_ENABLE<<unit);
	 rmesa->TexGenEnabled &= ~(RADEON_TEXMAT_0_ENABLE<<unit);
	 rmesa->TexGenEnabled &= ~(RADEON_TEXGEN_INPUT_MASK<<inputshift);
	 rmesa->TexGenNeedNormals[unit] = 0;
	 rmesa->TexGenEnabled |= 
	     (RADEON_TEXGEN_INPUT_TEXCOORD_0+unit) << inputshift;

	 if (tmp != rmesa->TexGenEnabled) {
	    rmesa->recheck_texgen[unit] = GL_TRUE;
	    rmesa->NewGLState |= _NEW_TEXTURE_MATRIX;
	 }
a1039 1
}
d1041 10
a1050 6
static GLboolean enable_tex_2d( GLcontext *ctx, int unit )
{
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *tObj = texUnit->_Current;
   radeonTexObjPtr t = (radeonTexObjPtr) tObj->DriverData;
d1052 1
a1052 6
   /* Need to load the 2d images associated with this unit.
    */
   if (t->pp_txformat & RADEON_TXFORMAT_NON_POWER2) {
      t->pp_txformat &= ~RADEON_TXFORMAT_NON_POWER2;
      t->base.dirty_images[0] = ~0;
   }
d1054 14
a1067 8
   ASSERT(tObj->Target == GL_TEXTURE_2D || tObj->Target == GL_TEXTURE_1D);

   if ( t->base.dirty_images[0] ) {
      RADEON_FIREVERTICES( rmesa );
      radeonSetTexImages( rmesa, tObj );
      radeonUploadTexImages( rmesa, (radeonTexObjPtr) tObj->DriverData, 0 );
      if ( !t->base.memBlock && !t->image_override ) 
	return GL_FALSE;
d1070 2
a1071 2
   return GL_TRUE;
}
d1073 6
a1078 37
static GLboolean enable_tex_cube( GLcontext *ctx, int unit )
{
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *tObj = texUnit->_Current;
   radeonTexObjPtr t = (radeonTexObjPtr) tObj->DriverData;
   GLuint face;

   /* Need to load the 2d images associated with this unit.
    */
   if (t->pp_txformat & RADEON_TXFORMAT_NON_POWER2) {
      t->pp_txformat &= ~RADEON_TXFORMAT_NON_POWER2;
      for (face = 0; face < 6; face++)
         t->base.dirty_images[face] = ~0;
   }

   ASSERT(tObj->Target == GL_TEXTURE_CUBE_MAP);

   if ( t->base.dirty_images[0] || t->base.dirty_images[1] ||
        t->base.dirty_images[2] || t->base.dirty_images[3] ||
        t->base.dirty_images[4] || t->base.dirty_images[5] ) {
      /* flush */
      RADEON_FIREVERTICES( rmesa );
      /* layout memory space, once for all faces */
      radeonSetTexImages( rmesa, tObj );
   }

   /* upload (per face) */
   for (face = 0; face < 6; face++) {
      if (t->base.dirty_images[face]) {
         radeonUploadTexImages( rmesa, (radeonTexObjPtr) tObj->DriverData, face );
      }
   }
      
   if ( !t->base.memBlock ) {
      /* texmem alloc failed, use s/w fallback */
      return GL_FALSE;
d1081 1
a1081 11
   return GL_TRUE;
}

static GLboolean enable_tex_rect( GLcontext *ctx, int unit )
{
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *tObj = texUnit->_Current;
   radeonTexObjPtr t = (radeonTexObjPtr) tObj->DriverData;

   if (!(t->pp_txformat & RADEON_TXFORMAT_NON_POWER2)) {
a1082 14
      t->base.dirty_images[0] = ~0;
   }

   ASSERT(tObj->Target == GL_TEXTURE_RECTANGLE_NV);

   if ( t->base.dirty_images[0] ) {
      RADEON_FIREVERTICES( rmesa );
      radeonSetTexImages( rmesa, tObj );
      radeonUploadTexImages( rmesa, (radeonTexObjPtr) tObj->DriverData, 0 );
      if ( !t->base.memBlock &&
           !t->image_override /* && !rmesa->prefer_gart_client_texturing  FIXME */ ) {
	 fprintf(stderr, "%s: upload failed\n", __FUNCTION__);
	 return GL_FALSE;
      }
d1088 1
a1088 2

static GLboolean update_tex_common( GLcontext *ctx, int unit )
d1090 3
a1092 5
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *tObj = texUnit->_Current;
   radeonTexObjPtr t = (radeonTexObjPtr) tObj->DriverData;
   GLenum format;
d1094 1
a1094 3
   /* Fallback if there's a texture border */
   if ( tObj->Image[0][tObj->BaseLevel]->Border > 0 ) {
      fprintf(stderr, "%s: border\n", __FUNCTION__);
d1096 5
a1100 1
   }
d1105 5
a1109 19
   /* Update state if this is a different texture object to last
    * time.
    */
   if ( rmesa->state.texture.unit[unit].texobj != t ) {
      if ( rmesa->state.texture.unit[unit].texobj != NULL ) {
	 /* The old texture is no longer bound to this texture unit.
	  * Mark it as such.
	  */

	 rmesa->state.texture.unit[unit].texobj->base.bound &= 
	     ~(1UL << unit);
      }

      rmesa->state.texture.unit[unit].texobj = t;
      t->base.bound |= (1UL << unit);
      t->dirty_state |= 1<<unit;
      driUpdateTextureLRU( (driTextureObject *) t ); /* XXX: should be locked! */
   }

d1111 1
a1111 10
   /* Newly enabled?
    */
   if ( !(rmesa->hw.ctx.cmd[CTX_PP_CNTL] & (RADEON_TEX_0_ENABLE<<unit))) {
      RADEON_STATECHANGE( rmesa, ctx );
      rmesa->hw.ctx.cmd[CTX_PP_CNTL] |= 
	  (RADEON_TEX_0_ENABLE | RADEON_TEX_BLEND_0_ENABLE) << unit;

      RADEON_STATECHANGE( rmesa, tcl );

      rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_ST_BIT(unit);
d1113 1
a1113 8
      rmesa->recheck_texgen[unit] = GL_TRUE;
   }

   if (t->dirty_state & (1<<unit)) {
      import_tex_obj_state( rmesa, unit, t );
      /* may need to update texture matrix (for texrect adjustments) */
      rmesa->NewGLState |= _NEW_TEXTURE_MATRIX;
   }
d1119 1
a1119 1
      rmesa->NewGLState |= _NEW_TEXTURE_MATRIX;
d1122 2
a1123 8
   format = tObj->Image[0][tObj->BaseLevel]->_BaseFormat;
   if ( rmesa->state.texture.unit[unit].format != format ||
	rmesa->state.texture.unit[unit].envMode != texUnit->EnvMode ) {
      rmesa->state.texture.unit[unit].format = format;
      rmesa->state.texture.unit[unit].envMode = texUnit->EnvMode;
      if ( ! radeonUpdateTextureEnv( ctx, unit ) ) {
	 return GL_FALSE;
      }
d1125 1
d1127 1
a1127 1
   FALLBACK( rmesa, RADEON_FALLBACK_BORDER_MODE, t->border_fallback );
a1130 2


d1133 1
a1133 1
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
d1135 3
a1137 11
   if ( texUnit->_ReallyEnabled & (TEXTURE_RECT_BIT) ) {
      return (enable_tex_rect( ctx, unit ) &&
	      update_tex_common( ctx, unit ));
   }
   else if ( texUnit->_ReallyEnabled & (TEXTURE_1D_BIT | TEXTURE_2D_BIT) ) {
      return (enable_tex_2d( ctx, unit ) &&
	      update_tex_common( ctx, unit ));
   }
   else if ( texUnit->_ReallyEnabled & (TEXTURE_CUBE_BIT) ) {
      return (enable_tex_cube( ctx, unit ) &&
	      update_tex_common( ctx, unit ));
d1139 6
a1144 2
   else if ( texUnit->_ReallyEnabled ) {
      return GL_FALSE;
d1146 7
a1152 3
   else {
      disable_tex( ctx, unit );
      return GL_TRUE;
d1154 2
d1160 1
a1160 1
   radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
d1163 4
d1173 1
a1173 1
   if (rmesa->TclFallback)
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a0 1
/* $XFree86: xc/lib/GL/mesa/src/drv/radeon/radeon_texstate.c,v 1.6 2002/12/16 16:18:59 dawes Exp $ */
d36 8
a43 8
#include "glheader.h"
#include "imports.h"
#include "colormac.h"
#include "context.h"
#include "macros.h"
#include "texformat.h"
#include "texobj.h"
#include "enums.h"
@


1.1
log
@Initial revision
@
text
@d43 1
d88 1
a88 1
   _INVALID(RGB888),
d138 13
a150 12

   t->pp_txformat &= ~(RADEON_TXFORMAT_FORMAT_MASK |
		       RADEON_TXFORMAT_ALPHA_IN_MAP);
   t->pp_txfilter &= ~RADEON_YUV_TO_RGB;

   if ( VALID_FORMAT( baseImage->TexFormat->MesaFormat ) ) {
      t->pp_txformat |= tx_table[ baseImage->TexFormat->MesaFormat ].format;
      t->pp_txfilter |= tx_table[ baseImage->TexFormat->MesaFormat ].filter;
   }
   else {
      _mesa_problem(NULL, "unexpected texture format in %s", __FUNCTION__);
      return;
d346 7
a352 5
   if (baseImage->IsCompressed)
      t->pp_txpitch = (tObj->Image[0][t->base.firstLevel]->Width + 63) & ~(63);
   else
      t->pp_txpitch = ((tObj->Image[0][t->base.firstLevel]->Width * texelBytes) + 63) & ~(63);
   t->pp_txpitch -= 32;
d530 1
a530 1
    * the texture format does not include an alpha component.  This
d532 2
a533 1
    * textures being a notable exception.
d563 4
a566 1
	    color_arg[i] = radeon_texture_color[op][unit];
d585 5
a589 1
	 case GL_TEXTURE2:
d593 3
a595 2
	   color_arg[i] = radeon_texture_color[op][srcRGBi - GL_TEXTURE0];
	   break;
d608 4
a611 1
	    alpha_arg[i] = radeon_texture_alpha[op][unit];
d630 8
a637 3
	 case GL_TEXTURE2:
	   alpha_arg[i] = radeon_texture_alpha[op][srcAi - GL_TEXTURE0];
	   break;
d847 38
d910 1
a910 1
   GLuint *cmd = &rmesa->hw.tex[unit].cmd[TEX_CMD_0];
d933 1
a933 1
	 GLuint *cube_cmd = &rmesa->hw.cube[unit].cmd[CUBE_CMD_0];
d1181 1
a1181 1
      if ( !t->base.memBlock ) 
d1248 2
a1249 1
      if ( !t->base.memBlock /* && !rmesa->prefer_gart_client_texturing  FIXME */ ) {
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d526 1
a526 1
    * the texture format does not include an alpha component. This
d528 1
a528 2
    * textures being a notable exception. Doesn't work for luminance
    * textures realized with I8 and ALPHA_IN_MAP not set neither (on r100).
d558 1
a558 4
	    if (texUnit->_Current->Image[0][0]->_BaseFormat == GL_ALPHA)
	       color_arg[i] = radeon_zero_color[op];
	    else
	       color_arg[i] = radeon_texture_color[op][unit];
d577 1
a577 5
	 case GL_TEXTURE2: {
	    GLuint txunit = srcRGBi - GL_TEXTURE0;
	    if (ctx->Texture.Unit[txunit]._Current->Image[0][0]->_BaseFormat == GL_ALPHA)
	       color_arg[i] = radeon_zero_color[op];
	    else
d581 2
a582 3
	      color_arg[i] = radeon_texture_color[op][txunit];
	    }
	    break;
d595 1
a595 4
	    if (texUnit->_Current->Image[0][0]->_BaseFormat == GL_LUMINANCE)
	       alpha_arg[i] = radeon_zero_alpha[op+1];
	    else
	       alpha_arg[i] = radeon_texture_alpha[op][unit];
d614 3
a616 8
	 case GL_TEXTURE2: {    
	    GLuint txunit = srcAi - GL_TEXTURE0;
	    if (ctx->Texture.Unit[txunit]._Current->Image[0][0]->_BaseFormat == GL_LUMINANCE)
	       alpha_arg[i] = radeon_zero_alpha[op+1];
	    else
	       alpha_arg[i] = radeon_texture_alpha[op][txunit];
	    }
	    break;
d851 1
a851 1
   int *cmd = &rmesa->hw.tex[unit].cmd[TEX_CMD_0];
d874 1
a874 1
	 int *cube_cmd = &rmesa->hw.cube[unit].cmd[CUBE_CMD_0];
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d1 1
d37 7
a43 9
#include "main/glheader.h"
#include "main/imports.h"
#include "main/colormac.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/teximage.h"
#include "main/texstate.h"
#include "main/texobj.h"
#include "main/enums.h"
a45 1
#include "radeon_mipmap_tree.h"
d78 1
a78 1
struct tx_table {
d80 2
a81 4
};

/* XXX verify this table against MESA_FORMAT_x values */
static const struct tx_table tx_table[] =
a82 1
   _INVALID(NONE), /* MESA_FORMAT_NONE */
d87 1
a87 1
   [ MESA_FORMAT_RGB888 ] = { RADEON_TXFORMAT_ARGB8888, 0 },
d114 243
d501 1
a501 1
static GLboolean radeonUpdateTextureEnv( struct gl_context *ctx, int unit )
d503 1
a503 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d520 1
a520 1
   if ( RADEON_DEBUG & RADEON_TEXTURE ) {
a842 172
void radeonSetTexOffset(__DRIcontext * pDRICtx, GLint texname,
                        unsigned long long offset, GLint depth, GLuint pitch)
{
	r100ContextPtr rmesa = pDRICtx->driverPrivate;
	struct gl_texture_object *tObj =
	    _mesa_lookup_texture(rmesa->radeon.glCtx, texname);
	radeonTexObjPtr t = radeon_tex_obj(tObj);

	if (tObj == NULL)
		return;

	t->image_override = GL_TRUE;

	if (!offset)
		return;
	
	t->bo = NULL;
	t->override_offset = offset;
	t->pp_txpitch = pitch - 32;

	switch (depth) {
	case 32:
		t->pp_txformat = tx_table[MESA_FORMAT_ARGB8888].format;
		t->pp_txfilter |= tx_table[MESA_FORMAT_ARGB8888].filter;
		break;
	case 24:
	default:
		t->pp_txformat = tx_table[MESA_FORMAT_RGB888].format;
		t->pp_txfilter |= tx_table[MESA_FORMAT_RGB888].filter;
		break;
	case 16:
		t->pp_txformat = tx_table[MESA_FORMAT_RGB565].format;
		t->pp_txfilter |= tx_table[MESA_FORMAT_RGB565].filter;
		break;
	}
}

static int
logbase2(int n)
{
   GLint i = 1;
   GLint log2 = 0;

   while (n > i) {
      i *= 2;
      log2++;
   }

   return log2;
}


void radeonSetTexBuffer2(__DRIcontext *pDRICtx, GLint target, GLint texture_format,
			 __DRIdrawable *dPriv)
{
	struct gl_texture_unit *texUnit;
	struct gl_texture_object *texObj;
	struct gl_texture_image *texImage;
	struct radeon_renderbuffer *rb;
	radeon_texture_image *rImage;
	radeonContextPtr radeon;
	r100ContextPtr rmesa;
	struct radeon_framebuffer *rfb;
	radeonTexObjPtr t;
	uint32_t pitch_val;
	uint32_t internalFormat, format;
	gl_format texFormat;

	format = GL_UNSIGNED_BYTE;
	internalFormat = (texture_format == __DRI_TEXTURE_FORMAT_RGB ? GL_RGB : GL_RGBA);

	radeon = pDRICtx->driverPrivate;
	rmesa = pDRICtx->driverPrivate;

	rfb = dPriv->driverPrivate;
        texUnit = _mesa_get_current_tex_unit(radeon->glCtx);
	texObj = _mesa_select_tex_object(radeon->glCtx, texUnit, target);
        texImage = _mesa_get_tex_image(radeon->glCtx, texObj, target, 0);

	rImage = get_radeon_texture_image(texImage);
	t = radeon_tex_obj(texObj);
        if (t == NULL) {
    	    return;
    	}

	radeon_update_renderbuffers(pDRICtx, dPriv, GL_TRUE);
	rb = rfb->color_rb[0];
	if (rb->bo == NULL) {
		/* Failed to BO for the buffer */
		return;
	}

	_mesa_lock_texture(radeon->glCtx, texObj);
	if (t->bo) {
		radeon_bo_unref(t->bo);
		t->bo = NULL;
	}
	if (rImage->bo) {
		radeon_bo_unref(rImage->bo);
		rImage->bo = NULL;
	}

	radeon_miptree_unreference(&t->mt);
	radeon_miptree_unreference(&rImage->mt);

	rImage->bo = rb->bo;
	radeon_bo_ref(rImage->bo);
	t->bo = rb->bo;
	radeon_bo_ref(t->bo);
	t->tile_bits = 0;
	t->image_override = GL_TRUE;
	t->override_offset = 0;
	switch (rb->cpp) {
	case 4:
		if (texture_format == __DRI_TEXTURE_FORMAT_RGB) {
			t->pp_txformat = tx_table[MESA_FORMAT_RGB888].format;
			texFormat = MESA_FORMAT_RGB888;
		}
		else {
			t->pp_txformat = tx_table[MESA_FORMAT_ARGB8888].format;
			texFormat = MESA_FORMAT_ARGB8888;
		}
		t->pp_txfilter |= tx_table[MESA_FORMAT_ARGB8888].filter;
		break;
	case 3:
	default:
		texFormat = MESA_FORMAT_RGB888;
		t->pp_txformat = tx_table[MESA_FORMAT_RGB888].format;
		t->pp_txfilter |= tx_table[MESA_FORMAT_RGB888].filter;
		break;
	case 2:
		texFormat = MESA_FORMAT_RGB565;
		t->pp_txformat = tx_table[MESA_FORMAT_RGB565].format;
		t->pp_txfilter |= tx_table[MESA_FORMAT_RGB565].filter;
		break;
	}

	_mesa_init_teximage_fields(radeon->glCtx, target, texImage,
				   rb->base.Width, rb->base.Height, 1, 0,
				   rb->cpp, texFormat);
	texImage->RowStride = rb->pitch / rb->cpp;

	t->pp_txpitch &= (1 << 13) -1;
	pitch_val = rb->pitch;

        t->pp_txsize = ((rb->base.Width - 1) << RADEON_TEX_USIZE_SHIFT)
		| ((rb->base.Height - 1) << RADEON_TEX_VSIZE_SHIFT);
	if (target == GL_TEXTURE_RECTANGLE_NV) {
		t->pp_txformat |= RADEON_TXFORMAT_NON_POWER2;
		t->pp_txpitch = pitch_val;
		t->pp_txpitch -= 32;
	} else {
	  t->pp_txformat &= ~(RADEON_TXFORMAT_WIDTH_MASK |
			      RADEON_TXFORMAT_HEIGHT_MASK |
			      RADEON_TXFORMAT_CUBIC_MAP_ENABLE |
			      RADEON_TXFORMAT_F5_WIDTH_MASK |
			      RADEON_TXFORMAT_F5_HEIGHT_MASK);
	  t->pp_txformat |= ((texImage->WidthLog2 << RADEON_TXFORMAT_WIDTH_SHIFT) |
			     (texImage->HeightLog2 << RADEON_TXFORMAT_HEIGHT_SHIFT));
	}
	t->validated = GL_TRUE;
	_mesa_unlock_texture(radeon->glCtx, texObj);
	return;
}


void radeonSetTexBuffer(__DRIcontext *pDRICtx, GLint target, __DRIdrawable *dPriv)
{
        radeonSetTexBuffer2(pDRICtx, target, __DRI_TEXTURE_FORMAT_RGBA, dPriv);
}


d863 1
a863 42
static void disable_tex_obj_state( r100ContextPtr rmesa, 
				   int unit )
{
   RADEON_STATECHANGE( rmesa, tex[unit] );

   RADEON_STATECHANGE( rmesa, tcl );
   rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] &= ~(RADEON_ST_BIT(unit) |
					     RADEON_Q_BIT(unit));
   
   if (rmesa->radeon.TclFallback & (RADEON_TCL_FALLBACK_TEXGEN_0<<unit)) {
     TCL_FALLBACK( rmesa->radeon.glCtx, (RADEON_TCL_FALLBACK_TEXGEN_0<<unit), GL_FALSE);
     rmesa->recheck_texgen[unit] = GL_TRUE;
   }

   if (rmesa->hw.tex[unit].cmd[TEX_PP_TXFORMAT] & RADEON_TXFORMAT_CUBIC_MAP_ENABLE) {
     /* this seems to be a genuine (r100 only?) hw bug. Need to remove the
	cubic_map bit on unit 2 when the unit is disabled, otherwise every
	2nd (2d) mipmap on unit 0 will be broken (may not be needed for other
	units, better be safe than sorry though).*/
     RADEON_STATECHANGE( rmesa, tex[unit] );
     rmesa->hw.tex[unit].cmd[TEX_PP_TXFORMAT] &= ~RADEON_TXFORMAT_CUBIC_MAP_ENABLE;
   }

   {
      GLuint inputshift = RADEON_TEXGEN_0_INPUT_SHIFT + unit*4;
      GLuint tmp = rmesa->TexGenEnabled;

      rmesa->TexGenEnabled &= ~(RADEON_TEXGEN_TEXMAT_0_ENABLE<<unit);
      rmesa->TexGenEnabled &= ~(RADEON_TEXMAT_0_ENABLE<<unit);
      rmesa->TexGenEnabled &= ~(RADEON_TEXGEN_INPUT_MASK<<inputshift);
      rmesa->TexGenNeedNormals[unit] = 0;
      rmesa->TexGenEnabled |= 
	(RADEON_TEXGEN_INPUT_TEXCOORD_0+unit) << inputshift;

      if (tmp != rmesa->TexGenEnabled) {
	rmesa->recheck_texgen[unit] = GL_TRUE;
	rmesa->radeon.NewGLState |= _NEW_TEXTURE_MATRIX;
      }
   }
}

static void import_tex_obj_state( r100ContextPtr rmesa,
d868 1
a868 1
   uint32_t *cmd = &rmesa->hw.tex[unit].cmd[TEX_CMD_0];
d877 1
d880 2
a881 2
   if (texobj->pp_txformat & RADEON_TXFORMAT_NON_POWER2) {
      uint32_t *txr_cmd = &rmesa->hw.txr[unit].cmd[TXR_CMD_0];
d884 1
a884 4
      RADEON_STATECHANGE( rmesa, txr[unit] );
   }

   if (texobj->base.Target == GL_TEXTURE_RECTANGLE_NV) {
d890 4
a893 2
      if (texobj->base.Target == GL_TEXTURE_CUBE_MAP) {
	 uint32_t *cube_cmd = &rmesa->hw.cube[unit].cmd[CUBE_CMD_0];
d897 9
a905 1
	 /* state filled out in the cube_emit */
d914 1
a914 1
   rmesa->radeon.NewGLState |= _NEW_TEXTURE_MATRIX;
d918 3
a920 1
static void set_texgen_matrix( r100ContextPtr rmesa, 
d948 1
a948 1
   rmesa->radeon.NewGLState |= _NEW_TEXTURE_MATRIX;
d953 1
a953 1
static GLboolean radeon_validate_texgen( struct gl_context *ctx, GLuint unit )
d955 1
a955 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d985 1
a985 1
	     (texUnit->GenS.Mode == texUnit->GenT.Mode) ) {
d987 1
a987 1
	    (texUnit->GenS.Mode != texUnit->GenR.Mode)) ||
d989 1
a989 1
	    (texUnit->GenS.Mode != texUnit->GenQ.Mode)) ) {
d992 1
a992 1
	 if (RADEON_DEBUG & RADEON_FALLBACKS)
d1000 1
a1000 1
      if (RADEON_DEBUG & RADEON_FALLBACKS)
d1013 1
a1013 1
   switch (texUnit->GenS.Mode) {
d1017 4
a1020 4
			 texUnit->GenS.ObjectPlane,
			 texUnit->GenT.ObjectPlane,
			 texUnit->GenR.ObjectPlane,
			 texUnit->GenQ.ObjectPlane);
d1026 4
a1029 4
			 texUnit->GenS.EyePlane,
			 texUnit->GenT.EyePlane,
			 texUnit->GenR.EyePlane,
			 texUnit->GenQ.EyePlane);
d1050 1
a1050 1
      if (RADEON_DEBUG & RADEON_FALLBACKS)
d1056 1
a1056 1
      rmesa->radeon.NewGLState |= _NEW_TEXTURE_MATRIX;
d1062 2
a1063 7
/**
 * Compute the cached hardware register values for the given texture object.
 *
 * \param rmesa Context pointer
 * \param t the r300 texture object
 */
static GLboolean setup_hardware_state(r100ContextPtr rmesa, radeonTexObj *t, int unit)
d1065 34
a1098 2
   const struct gl_texture_image *firstImage;
   GLint log2Width, log2Height, log2Depth, texelBytes;
d1100 16
a1115 2
   if ( t->bo ) {
	return GL_TRUE;
d1117 1
d1119 6
a1124 1
   firstImage = t->base.Image[0][t->minLod];
d1126 5
a1130 3
   if (firstImage->Border > 0) {
      fprintf(stderr, "%s: border\n", __FUNCTION__);
      return GL_FALSE;
d1133 8
a1140 20
   log2Width  = firstImage->WidthLog2;
   log2Height = firstImage->HeightLog2;
   log2Depth  = firstImage->DepthLog2;
   texelBytes = _mesa_get_format_bytes(firstImage->TexFormat);

   if (!t->image_override) {
      if (VALID_FORMAT(firstImage->TexFormat)) {
	const struct tx_table *table = tx_table;

	 t->pp_txformat &= ~(RADEON_TXFORMAT_FORMAT_MASK |
			     RADEON_TXFORMAT_ALPHA_IN_MAP);
	 t->pp_txfilter &= ~RADEON_YUV_TO_RGB;	 
	 
	 t->pp_txformat |= table[ firstImage->TexFormat ].format;
	 t->pp_txfilter |= table[ firstImage->TexFormat ].filter;
      } else {
	 _mesa_problem(NULL, "unexpected texture format in %s",
		       __FUNCTION__);
	 return GL_FALSE;
      }
d1143 2
a1144 10
   t->pp_txfilter &= ~RADEON_MAX_MIP_LEVEL_MASK;
   t->pp_txfilter |= (t->maxLod - t->minLod) << RADEON_MAX_MIP_LEVEL_SHIFT;
	
   t->pp_txformat &= ~(RADEON_TXFORMAT_WIDTH_MASK |
		       RADEON_TXFORMAT_HEIGHT_MASK |
		       RADEON_TXFORMAT_CUBIC_MAP_ENABLE |
		       RADEON_TXFORMAT_F5_WIDTH_MASK |
		       RADEON_TXFORMAT_F5_HEIGHT_MASK);
   t->pp_txformat |= ((log2Width << RADEON_TXFORMAT_WIDTH_SHIFT) |
		      (log2Height << RADEON_TXFORMAT_HEIGHT_SHIFT));
d1146 7
a1152 1
   t->tile_bits = 0;
d1154 29
a1182 14
   if (t->base.Target == GL_TEXTURE_CUBE_MAP) {
      ASSERT(log2Width == log2Height);
      t->pp_txformat |= ((log2Width << RADEON_TXFORMAT_F5_WIDTH_SHIFT) |
			 (log2Height << RADEON_TXFORMAT_F5_HEIGHT_SHIFT) |
			 /* don't think we need this bit, if it exists at all - fglrx does not set it */
			 (RADEON_TXFORMAT_CUBIC_MAP_ENABLE));
      t->pp_cubic_faces = ((log2Width << RADEON_FACE_WIDTH_1_SHIFT) |
                           (log2Height << RADEON_FACE_HEIGHT_1_SHIFT) |
                           (log2Width << RADEON_FACE_WIDTH_2_SHIFT) |
                           (log2Height << RADEON_FACE_HEIGHT_2_SHIFT) |
                           (log2Width << RADEON_FACE_WIDTH_3_SHIFT) |
                           (log2Height << RADEON_FACE_HEIGHT_3_SHIFT) |
                           (log2Width << RADEON_FACE_WIDTH_4_SHIFT) |
                           (log2Height << RADEON_FACE_HEIGHT_4_SHIFT));
d1185 9
a1193 2
   t->pp_txsize = (((firstImage->Width - 1) << RADEON_TEX_USIZE_SHIFT)
		   | ((firstImage->Height - 1) << RADEON_TEX_VSIZE_SHIFT));
d1195 3
a1197 6
   if ( !t->image_override ) {
      if (_mesa_is_format_compressed(firstImage->TexFormat))
         t->pp_txpitch = (firstImage->Width + 63) & ~(63);
      else
         t->pp_txpitch = ((firstImage->Width * texelBytes) + 63) & ~(63);
      t->pp_txpitch -= 32;
d1200 10
a1209 2
   if (t->base.Target == GL_TEXTURE_RECTANGLE_NV) {
      t->pp_txformat |= RADEON_TXFORMAT_NON_POWER2;
d1215 2
a1216 1
static GLboolean radeon_validate_texture(struct gl_context *ctx, struct gl_texture_object *texObj, int unit)
d1218 5
a1222 3
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
   radeonTexObj *t = radeon_tex_obj(texObj);
   int ret;
d1224 3
a1226 1
   if (!radeon_validate_texture_miptree(ctx, texObj))
d1228 1
a1228 5

   ret = setup_hardware_state(rmesa, t, unit);
   if (ret == GL_FALSE)
     return GL_FALSE;

d1233 18
a1250 5
   RADEON_STATECHANGE( rmesa, ctx );
   rmesa->hw.ctx.cmd[CTX_PP_CNTL] |= 
     (RADEON_TEX_0_ENABLE | RADEON_TEX_BLEND_0_ENABLE) << unit;
   RADEON_STATECHANGE( rmesa, tcl );
   rmesa->hw.tcl.cmd[TCL_OUTPUT_VTXFMT] |= RADEON_ST_BIT(unit);
a1251 1
   rmesa->recheck_texgen[unit] = GL_TRUE;
d1253 19
a1271 1
   import_tex_obj_state( rmesa, unit, t );
d1277 1
a1277 1
      rmesa->radeon.NewGLState |= _NEW_TEXTURE_MATRIX;
d1280 8
a1287 2
   if ( ! radeonUpdateTextureEnv( ctx, unit ) ) {
     return GL_FALSE;
d1289 1
a1290 2

   t->validated = GL_TRUE;
d1294 3
a1296 1
static GLboolean radeonUpdateTextureUnit( struct gl_context *ctx, int unit )
d1298 1
a1298 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
d1300 11
a1310 3
   if (ctx->Texture.Unit[unit]._ReallyEnabled & TEXTURE_3D_BIT) {
     rmesa->state.texture.unit[unit].texobj = NULL;
     return GL_FALSE;
d1312 2
a1313 6

   if (!ctx->Texture.Unit[unit]._ReallyEnabled) {
     /* disable the unit */
     disable_tex_obj_state(rmesa, unit);
     rmesa->state.texture.unit[unit].texobj = NULL;
     return GL_TRUE;
d1315 3
a1317 7

   if (!radeon_validate_texture(ctx, ctx->Texture.Unit[unit]._Current, unit)) {
    _mesa_warning(ctx,
		  "failed to validate texture for unit %d.\n",
		  unit);
     rmesa->state.texture.unit[unit].texobj = NULL;
     return GL_FALSE;
a1318 2
   rmesa->state.texture.unit[unit].texobj = radeon_tex_obj(ctx->Texture.Unit[unit]._Current);
   return GL_TRUE;
d1321 1
a1321 1
void radeonUpdateTextureState( struct gl_context *ctx )
d1323 1
a1323 1
   r100ContextPtr rmesa = R100_CONTEXT(ctx);
a1325 4
   /* set the ctx all textures off */
   RADEON_STATECHANGE( rmesa, ctx );
   rmesa->hw.ctx.cmd[CTX_PP_CNTL] &= ~((RADEON_TEX_ENABLE_MASK) | (RADEON_TEX_BLEND_ENABLE_MASK));

d1332 1
a1332 1
   if (rmesa->radeon.TclFallback)
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@a44 1
#include "main/samplerobj.h"
d104 1
d605 52
d666 1
d670 1
d673 3
d677 1
d680 3
a682 3
        texUnit = _mesa_get_current_tex_unit(&radeon->glCtx);
	texObj = _mesa_select_tex_object(&radeon->glCtx, texUnit, target);
        texImage = _mesa_get_tex_image(&radeon->glCtx, texObj, target, 0);
d697 1
a697 1
	_mesa_lock_texture(&radeon->glCtx, texObj);
d742 2
a743 3
	_mesa_init_teximage_fields(&radeon->glCtx, texImage,
				   rb->base.Base.Width, rb->base.Base.Height,
				   1, 0,
d745 1
a745 1
	rImage->base.RowStride = rb->pitch / rb->cpp;
d750 2
a751 2
        t->pp_txsize = ((rb->base.Base.Width - 1) << RADEON_TEX_USIZE_SHIFT)
		| ((rb->base.Base.Height - 1) << RADEON_TEX_VSIZE_SHIFT);
d766 1
a766 1
	_mesa_unlock_texture(&radeon->glCtx, texObj);
d807 1
a807 1
     TCL_FALLBACK( &rmesa->radeon.glCtx, (RADEON_TCL_FALLBACK_TEXGEN_0<<unit), GL_FALSE);
d1036 1
a1036 1
   GLint log2Width, log2Height, texelBytes;
d1044 5
d1051 1
d1124 1
a1124 1
   if (!radeon_validate_texture_miptree(ctx, _mesa_get_samplerobj(ctx, unit), texObj))
a1142 1
   radeonTexUpdateParameters(ctx, unit);
a1165 1
     disable_tex_obj_state(rmesa, unit);
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d66 12
d88 25
a112 25
   [ MESA_FORMAT_NONE ] = { 0xffffffff, 0 },
   [ MESA_FORMAT_A8B8G8R8_UNORM ] = { RADEON_TXFORMAT_RGBA8888 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_R8G8B8A8_UNORM ] = { RADEON_TXFORMAT_RGBA8888 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_B8G8R8A8_UNORM ] = { RADEON_TXFORMAT_ARGB8888 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_A8R8G8B8_UNORM ] = { RADEON_TXFORMAT_ARGB8888 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_BGR_UNORM8 ] = { RADEON_TXFORMAT_ARGB8888, 0 },
   [ MESA_FORMAT_B5G6R5_UNORM ] = { RADEON_TXFORMAT_RGB565, 0 },
   [ MESA_FORMAT_R5G6B5_UNORM ] = { RADEON_TXFORMAT_RGB565, 0 },
   [ MESA_FORMAT_B4G4R4A4_UNORM ] = { RADEON_TXFORMAT_ARGB4444 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_A4R4G4B4_UNORM ] = { RADEON_TXFORMAT_ARGB4444 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_B5G5R5A1_UNORM ] = { RADEON_TXFORMAT_ARGB1555 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_A1R5G5B5_UNORM ] = { RADEON_TXFORMAT_ARGB1555 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_L8A8_UNORM ] = { RADEON_TXFORMAT_AL88 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_A8L8_UNORM ] = { RADEON_TXFORMAT_AL88 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_A_UNORM8 ] = { RADEON_TXFORMAT_A8 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_L_UNORM8 ] = { RADEON_TXFORMAT_L8, 0 },
   [ MESA_FORMAT_I_UNORM8 ] = { RADEON_TXFORMAT_I8 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_YCBCR ] = { RADEON_TXFORMAT_YCBCR, RADEON_YUV_TO_RGB },
   [ MESA_FORMAT_YCBCR_REV ] = { RADEON_TXFORMAT_YCBCR_REV, RADEON_YUV_TO_RGB },
   [ MESA_FORMAT_RGB_FXT1 ] = { 0xffffffff, 0 },
   [ MESA_FORMAT_RGBA_FXT1 ] = { 0xffffffff, 0 },
   [ MESA_FORMAT_RGB_DXT1 ] = { RADEON_TXFORMAT_RGB_DXT1, 0 },
   [ MESA_FORMAT_RGBA_DXT1 ] = { RADEON_TXFORMAT_RGBA_DXT1 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_RGBA_DXT3 ] = { RADEON_TXFORMAT_RGBA_DXT3 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
   [ MESA_FORMAT_RGBA_DXT5 ] = { RADEON_TXFORMAT_RGBA_DXT5 | RADEON_TXFORMAT_ALPHA_IN_MAP, 0 },
d115 4
d276 6
d298 1
a298 1
   if ( !texUnit->_Current ) {
d608 1
d617 1
a617 1
	mesa_format texFormat;
d622 3
a624 2
	texObj = _mesa_get_current_tex_object(&radeon->glCtx, target);
	texImage = _mesa_get_tex_image(&radeon->glCtx, texObj, target, 0);
d662 2
a663 2
			t->pp_txformat = tx_table[MESA_FORMAT_BGR_UNORM8].format;
			texFormat = MESA_FORMAT_BGR_UNORM8;
d666 2
a667 2
			t->pp_txformat = tx_table[MESA_FORMAT_B8G8R8A8_UNORM].format;
			texFormat = MESA_FORMAT_B8G8R8A8_UNORM;
d669 1
a669 1
		t->pp_txfilter |= tx_table[MESA_FORMAT_B8G8R8A8_UNORM].filter;
d673 3
a675 3
		texFormat = MESA_FORMAT_BGR_UNORM8;
		t->pp_txformat = tx_table[MESA_FORMAT_BGR_UNORM8].format;
		t->pp_txfilter |= tx_table[MESA_FORMAT_BGR_UNORM8].filter;
d678 3
a680 3
		texFormat = MESA_FORMAT_B5G6R5_UNORM;
		t->pp_txformat = tx_table[MESA_FORMAT_B5G6R5_UNORM].format;
		t->pp_txfilter |= tx_table[MESA_FORMAT_B5G6R5_UNORM].filter;
d1103 1
a1103 2
   if (ctx->Texture.Unit[unit]._Current &&
       ctx->Texture.Unit[unit]._Current->Target == GL_TEXTURE_3D) {
d1109 1
a1109 1
   if (!ctx->Texture.Unit[unit]._Current) {
@


