head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2014.01.19.03.13.15;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2013.09.05.14.04.16;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.15;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.39;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.39;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.28.30;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.15.27;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.01.19.03.04.25;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.48;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.11.29;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.48.36;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics to
 develop this 3D driver.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */


#include "brw_context.h"
#include "brw_state.h"
#include "brw_defines.h"
#include "brw_util.h"
#include "main/macros.h"
#include "main/stencil.h"
#include "intel_batchbuffer.h"

static void
brw_upload_cc_vp(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   struct brw_cc_viewport *ccv;

   ccv = brw_state_batch(brw, AUB_TRACE_CC_VP_STATE,
			 sizeof(*ccv) * ctx->Const.MaxViewports, 32,
                         &brw->cc.vp_offset);

   /* _NEW_TRANSFORM */
   for (unsigned i = 0; i < ctx->Const.MaxViewports; i++) {
      if (ctx->Transform.DepthClamp) {
         /* _NEW_VIEWPORT */
         ccv[i].min_depth = MIN2(ctx->ViewportArray[i].Near,
                                 ctx->ViewportArray[i].Far);
         ccv[i].max_depth = MAX2(ctx->ViewportArray[i].Near,
                                 ctx->ViewportArray[i].Far);
      } else {
         ccv[i].min_depth = 0.0;
         ccv[i].max_depth = 1.0;
      }
   }

   brw->state.dirty.cache |= CACHE_NEW_CC_VP;
}

const struct brw_tracked_state brw_cc_vp = {
   .dirty = {
      .mesa = _NEW_VIEWPORT | _NEW_TRANSFORM,
      .brw = BRW_NEW_BATCH,
      .cache = 0
   },
   .emit = brw_upload_cc_vp
};

/**
 * Modify blend function to force destination alpha to 1.0
 *
 * If \c function specifies a blend function that uses destination alpha,
 * replace it with a function that hard-wires destination alpha to 1.0.  This
 * is used when rendering to xRGB targets.
 */
GLenum
brw_fix_xRGB_alpha(GLenum function)
{
   switch (function) {
   case GL_DST_ALPHA:
      return GL_ONE;

   case GL_ONE_MINUS_DST_ALPHA:
   case GL_SRC_ALPHA_SATURATE:
      return GL_ZERO;
   }

   return function;
}

/**
 * Creates the state cache entry for the given CC unit key.
 */
static void upload_cc_unit(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   struct brw_cc_unit_state *cc;

   cc = brw_state_batch(brw, AUB_TRACE_CC_STATE,
			sizeof(*cc), 64, &brw->cc.state_offset);
   memset(cc, 0, sizeof(*cc));

   /* _NEW_STENCIL | _NEW_BUFFERS */
   if (ctx->Stencil._Enabled) {
      const unsigned back = ctx->Stencil._BackFace;

      cc->cc0.stencil_enable = 1;
      cc->cc0.stencil_func =
	 intel_translate_compare_func(ctx->Stencil.Function[0]);
      cc->cc0.stencil_fail_op =
	 intel_translate_stencil_op(ctx->Stencil.FailFunc[0]);
      cc->cc0.stencil_pass_depth_fail_op =
	 intel_translate_stencil_op(ctx->Stencil.ZFailFunc[0]);
      cc->cc0.stencil_pass_depth_pass_op =
	 intel_translate_stencil_op(ctx->Stencil.ZPassFunc[0]);
      cc->cc1.stencil_ref = _mesa_get_stencil_ref(ctx, 0);
      cc->cc1.stencil_write_mask = ctx->Stencil.WriteMask[0];
      cc->cc1.stencil_test_mask = ctx->Stencil.ValueMask[0];

      if (ctx->Stencil._TestTwoSide) {
	 cc->cc0.bf_stencil_enable = 1;
	 cc->cc0.bf_stencil_func =
	    intel_translate_compare_func(ctx->Stencil.Function[back]);
	 cc->cc0.bf_stencil_fail_op =
	    intel_translate_stencil_op(ctx->Stencil.FailFunc[back]);
	 cc->cc0.bf_stencil_pass_depth_fail_op =
	    intel_translate_stencil_op(ctx->Stencil.ZFailFunc[back]);
	 cc->cc0.bf_stencil_pass_depth_pass_op =
	    intel_translate_stencil_op(ctx->Stencil.ZPassFunc[back]);
	 cc->cc1.bf_stencil_ref = _mesa_get_stencil_ref(ctx, back);
	 cc->cc2.bf_stencil_write_mask = ctx->Stencil.WriteMask[back];
	 cc->cc2.bf_stencil_test_mask = ctx->Stencil.ValueMask[back];
      }

      /* Not really sure about this:
       */
      if (ctx->Stencil.WriteMask[0] ||
	  (ctx->Stencil._TestTwoSide && ctx->Stencil.WriteMask[back]))
	 cc->cc0.stencil_write_enable = 1;
   }

   /* _NEW_COLOR */
   if (ctx->Color.ColorLogicOpEnabled && ctx->Color.LogicOp != GL_COPY) {
      cc->cc2.logicop_enable = 1;
      cc->cc5.logicop_func = intel_translate_logic_op(ctx->Color.LogicOp);
   } else if (ctx->Color.BlendEnabled) {
      GLenum eqRGB = ctx->Color.Blend[0].EquationRGB;
      GLenum eqA = ctx->Color.Blend[0].EquationA;
      GLenum srcRGB = ctx->Color.Blend[0].SrcRGB;
      GLenum dstRGB = ctx->Color.Blend[0].DstRGB;
      GLenum srcA = ctx->Color.Blend[0].SrcA;
      GLenum dstA = ctx->Color.Blend[0].DstA;

      /* If the renderbuffer is XRGB, we have to frob the blend function to
       * force the destination alpha to 1.0.  This means replacing GL_DST_ALPHA
       * with GL_ONE and GL_ONE_MINUS_DST_ALPHA with GL_ZERO.
       */
      if (ctx->DrawBuffer->Visual.alphaBits == 0) {
	 srcRGB = brw_fix_xRGB_alpha(srcRGB);
	 srcA   = brw_fix_xRGB_alpha(srcA);
	 dstRGB = brw_fix_xRGB_alpha(dstRGB);
	 dstA   = brw_fix_xRGB_alpha(dstA);
      }

      if (eqRGB == GL_MIN || eqRGB == GL_MAX) {
	 srcRGB = dstRGB = GL_ONE;
      }

      if (eqA == GL_MIN || eqA == GL_MAX) {
	 srcA = dstA = GL_ONE;
      }

      cc->cc6.dest_blend_factor = brw_translate_blend_factor(dstRGB);
      cc->cc6.src_blend_factor = brw_translate_blend_factor(srcRGB);
      cc->cc6.blend_function = brw_translate_blend_equation(eqRGB);

      cc->cc5.ia_dest_blend_factor = brw_translate_blend_factor(dstA);
      cc->cc5.ia_src_blend_factor = brw_translate_blend_factor(srcA);
      cc->cc5.ia_blend_function = brw_translate_blend_equation(eqA);

      cc->cc3.blend_enable = 1;
      cc->cc3.ia_blend_enable = (srcA != srcRGB ||
				dstA != dstRGB ||
				eqA != eqRGB);
   }

   /* _NEW_BUFFERS */
   if (ctx->Color.AlphaEnabled && ctx->DrawBuffer->_NumColorDrawBuffers <= 1) {
      cc->cc3.alpha_test = 1;
      cc->cc3.alpha_test_func =
	 intel_translate_compare_func(ctx->Color.AlphaFunc);
      cc->cc3.alpha_test_format = BRW_ALPHATEST_FORMAT_UNORM8;

      UNCLAMPED_FLOAT_TO_UBYTE(cc->cc7.alpha_ref.ub[0], ctx->Color.AlphaRef);
   }

   if (ctx->Color.DitherFlag) {
      cc->cc5.dither_enable = 1;
      cc->cc6.y_dither_offset = 0;
      cc->cc6.x_dither_offset = 0;
   }

   /* _NEW_DEPTH */
   if (ctx->Depth.Test) {
      cc->cc2.depth_test = 1;
      cc->cc2.depth_test_function =
	 intel_translate_compare_func(ctx->Depth.Func);
      cc->cc2.depth_write_enable = ctx->Depth.Mask;
   }

   if (brw->stats_wm || unlikely(INTEL_DEBUG & DEBUG_STATS))
      cc->cc5.statistics_enable = 1;

   /* CACHE_NEW_CC_VP */
   cc->cc4.cc_viewport_state_offset = (brw->batch.bo->offset64 +
				       brw->cc.vp_offset) >> 5; /* reloc */

   brw->state.dirty.cache |= CACHE_NEW_CC_UNIT;

   /* Emit CC viewport relocation */
   drm_intel_bo_emit_reloc(brw->batch.bo,
			   (brw->cc.state_offset +
			    offsetof(struct brw_cc_unit_state, cc4)),
			   brw->batch.bo, brw->cc.vp_offset,
			   I915_GEM_DOMAIN_INSTRUCTION, 0);
}

const struct brw_tracked_state brw_cc_unit = {
   .dirty = {
      .mesa = _NEW_STENCIL | _NEW_COLOR | _NEW_DEPTH | _NEW_BUFFERS,
      .brw = BRW_NEW_BATCH | BRW_NEW_STATS_WM,
      .cache = CACHE_NEW_CC_VP
   },
   .emit = upload_cc_unit,
};

static void upload_blend_constant_color(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;

   BEGIN_BATCH(5);
   OUT_BATCH(_3DSTATE_BLEND_CONSTANT_COLOR << 16 | (5-2));
   OUT_BATCH_F(ctx->Color.BlendColorUnclamped[0]);
   OUT_BATCH_F(ctx->Color.BlendColorUnclamped[1]);
   OUT_BATCH_F(ctx->Color.BlendColorUnclamped[2]);
   OUT_BATCH_F(ctx->Color.BlendColorUnclamped[3]);
   ADVANCE_BATCH();
}

const struct brw_tracked_state brw_blend_constant_color = {
   .dirty = {
      .mesa = _NEW_COLOR,
      .brw = BRW_NEW_CONTEXT,
      .cache = 0
   },
   .emit = upload_blend_constant_color
};
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d100 1
a100 1
 * Creates a CC unit packet from the current blend state.
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d100 1
a100 1
 * Creates the state cache entry for the given CC unit key.
@


1.8
log
@Merge Mesa 9.2.5
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
d5 1
a5 1
 
d13 1
a13 1
 
d17 1
a17 1
 
d25 1
a25 1
 
d29 1
a29 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d48 2
a49 1
			 sizeof(*ccv), 32, &brw->cc.vp_offset);
d52 11
a62 7
   if (ctx->Transform.DepthClamp) {
      /* _NEW_VIEWPORT */
      ccv->min_depth = MIN2(ctx->Viewport.Near, ctx->Viewport.Far);
      ccv->max_depth = MAX2(ctx->Viewport.Near, ctx->Viewport.Far);
   } else {
      ccv->min_depth = 0.0;
      ccv->max_depth = 1.0;
d223 1
a223 1
   cc->cc4.cc_viewport_state_offset = (brw->batch.bo->offset +
d255 1
a255 1
   CACHED_BATCH();
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d190 2
a191 1
   if (ctx->Color.AlphaEnabled) {
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d38 1
d42 1
a42 1
prepare_cc_vp(struct brw_context *brw)
d44 1
a44 1
   struct gl_context *ctx = &brw->intel.ctx;
d47 2
a48 1
   ccv = brw_state_batch(brw, sizeof(*ccv), 32, &brw->cc.vp_offset);
d50 1
a50 1
   /* _NEW_TRANSOFORM */
d69 1
a69 1
   .prepare = prepare_cc_vp
d79 2
a80 2
static GLenum
fix_xRGB_alpha(GLenum function)
d99 1
a99 2
   struct intel_context *intel = &brw->intel;
   struct gl_context *ctx = &brw->intel.ctx;
d102 2
a103 1
   cc = brw_state_batch(brw, sizeof(*cc), 64, &brw->cc.state_offset);
d106 1
a106 1
   /* _NEW_STENCIL */
d119 1
a119 1
      cc->cc1.stencil_ref = ctx->Stencil.Ref[0];
d133 1
a133 1
	 cc->cc1.bf_stencil_ref = ctx->Stencil.Ref[back];
d146 1
a146 1
   if (ctx->Color._LogicOpEnabled && ctx->Color.LogicOp != GL_COPY) {
d162 4
a165 4
	 srcRGB = fix_xRGB_alpha(srcRGB);
	 srcA   = fix_xRGB_alpha(srcA);
	 dstRGB = fix_xRGB_alpha(dstRGB);
	 dstA   = fix_xRGB_alpha(dstA);
d213 1
a213 1
   if (intel->stats_wm || unlikely(INTEL_DEBUG & DEBUG_STATS))
d217 1
a217 1
   cc->cc4.cc_viewport_state_offset = (intel->batch.bo->offset +
d223 1
a223 1
   drm_intel_bo_emit_reloc(brw->intel.batch.bo,
d226 1
a226 1
			   intel->batch.bo, brw->cc.vp_offset,
d232 2
a233 2
      .mesa = _NEW_STENCIL | _NEW_COLOR | _NEW_DEPTH,
      .brw = BRW_NEW_BATCH,
d241 1
a241 2
   struct intel_context *intel = &brw->intel;
   struct gl_context *ctx = &intel->ctx;
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d38 1
d40 2
a41 2
void
brw_update_cc_vp(struct brw_context *brw)
d44 1
a44 1
   struct brw_cc_viewport ccv;
d46 1
a46 1
   memset(&ccv, 0, sizeof(ccv));
d51 2
a52 2
      ccv.min_depth = MIN2(ctx->Viewport.Near, ctx->Viewport.Far);
      ccv.max_depth = MAX2(ctx->Viewport.Near, ctx->Viewport.Far);
d54 2
a55 2
      ccv.min_depth = 0.0;
      ccv.max_depth = 1.0;
d58 1
a58 2
   drm_intel_bo_unreference(brw->cc.vp_bo);
   brw->cc.vp_bo = brw_cache_data(&brw->cache, BRW_CC_VP, &ccv, sizeof(ccv));
d61 9
a91 5
static void prepare_cc_unit(struct brw_context *brw)
{
   brw_add_validated_bo(brw, brw->cc.vp_bo);
}

d99 1
a99 2
   struct brw_cc_unit_state cc;
   void *map;
d101 2
a102 1
   memset(&cc, 0, sizeof(cc));
d108 2
a109 2
      cc.cc0.stencil_enable = 1;
      cc.cc0.stencil_func =
d111 1
a111 1
      cc.cc0.stencil_fail_op =
d113 1
a113 1
      cc.cc0.stencil_pass_depth_fail_op =
d115 1
a115 1
      cc.cc0.stencil_pass_depth_pass_op =
d117 3
a119 3
      cc.cc1.stencil_ref = ctx->Stencil.Ref[0];
      cc.cc1.stencil_write_mask = ctx->Stencil.WriteMask[0];
      cc.cc1.stencil_test_mask = ctx->Stencil.ValueMask[0];
d122 2
a123 2
	 cc.cc0.bf_stencil_enable = 1;
	 cc.cc0.bf_stencil_func =
d125 1
a125 1
	 cc.cc0.bf_stencil_fail_op =
d127 1
a127 1
	 cc.cc0.bf_stencil_pass_depth_fail_op =
d129 1
a129 1
	 cc.cc0.bf_stencil_pass_depth_pass_op =
d131 3
a133 3
	 cc.cc1.bf_stencil_ref = ctx->Stencil.Ref[back];
	 cc.cc2.bf_stencil_write_mask = ctx->Stencil.WriteMask[back];
	 cc.cc2.bf_stencil_test_mask = ctx->Stencil.ValueMask[back];
d140 1
a140 1
	 cc.cc0.stencil_write_enable = 1;
d145 2
a146 2
      cc.cc2.logicop_enable = 1;
      cc.cc5.logicop_func = intel_translate_logic_op(ctx->Color.LogicOp);
d148 6
a153 6
      GLenum eqRGB = ctx->Color.BlendEquationRGB;
      GLenum eqA = ctx->Color.BlendEquationA;
      GLenum srcRGB = ctx->Color.BlendSrcRGB;
      GLenum dstRGB = ctx->Color.BlendDstRGB;
      GLenum srcA = ctx->Color.BlendSrcA;
      GLenum dstA = ctx->Color.BlendDstA;
d174 7
a180 7
      cc.cc6.dest_blend_factor = brw_translate_blend_factor(dstRGB);
      cc.cc6.src_blend_factor = brw_translate_blend_factor(srcRGB);
      cc.cc6.blend_function = brw_translate_blend_equation(eqRGB);

      cc.cc5.ia_dest_blend_factor = brw_translate_blend_factor(dstA);
      cc.cc5.ia_src_blend_factor = brw_translate_blend_factor(srcA);
      cc.cc5.ia_blend_function = brw_translate_blend_equation(eqA);
d182 2
a183 2
      cc.cc3.blend_enable = 1;
      cc.cc3.ia_blend_enable = (srcA != srcRGB ||
d189 2
a190 2
      cc.cc3.alpha_test = 1;
      cc.cc3.alpha_test_func =
d192 1
a192 1
      cc.cc3.alpha_test_format = BRW_ALPHATEST_FORMAT_UNORM8;
d194 1
a194 1
      UNCLAMPED_FLOAT_TO_UBYTE(cc.cc7.alpha_ref.ub[0], ctx->Color.AlphaRef);
d198 3
a200 3
      cc.cc5.dither_enable = 1;
      cc.cc6.y_dither_offset = 0;
      cc.cc6.x_dither_offset = 0;
d205 2
a206 2
      cc.cc2.depth_test = 1;
      cc.cc2.depth_test_function =
d208 1
a208 1
      cc.cc2.depth_write_enable = ctx->Depth.Mask;
d212 1
a212 1
      cc.cc5.statistics_enable = 1;
d215 2
a216 1
   cc.cc4.cc_viewport_state_offset = brw->cc.vp_bo->offset >> 5; /* reloc */
a217 3
   map = brw_state_batch(brw, sizeof(cc), 64,
			 &brw->cc.state_bo, &brw->cc.state_offset);
   memcpy(map, &cc, sizeof(cc));
d221 4
a224 4
   drm_intel_bo_emit_reloc(brw->cc.state_bo, (brw->cc.state_offset +
					      offsetof(struct brw_cc_unit_state,
						       cc4)),
			   brw->cc.vp_bo, 0,
a233 1
   .prepare = prepare_cc_unit,
d239 2
a240 10
   struct gl_context *ctx = &brw->intel.ctx;
   struct brw_blend_constant_color bcc;

   memset(&bcc, 0, sizeof(bcc));
   bcc.header.opcode = CMD_BLEND_CONSTANT_COLOR;
   bcc.header.length = sizeof(bcc)/4-2;
   bcc.blend_constant_color[0] = ctx->Color.BlendColor[0];
   bcc.blend_constant_color[1] = ctx->Color.BlendColor[1];
   bcc.blend_constant_color[2] = ctx->Color.BlendColor[2];
   bcc.blend_constant_color[3] = ctx->Color.BlendColor[3];
d242 7
a248 1
   BRW_CACHED_BATCH_STRUCT(brw, &bcc);
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d39 2
a40 1
static void prepare_cc_vp( struct brw_context *brw )
d42 1
a42 1
   GLcontext *ctx = &brw->intel.ctx;
d57 2
a58 3
   dri_bo_unreference(brw->cc.vp_bo);
   brw->cc.vp_bo = brw_cache_data(&brw->cache, BRW_CC_VP, &ccv, sizeof(ccv),
				  NULL, 0);
a60 30
const struct brw_tracked_state brw_cc_vp = {
   .dirty = {
      .mesa = _NEW_VIEWPORT | _NEW_TRANSFORM,
      .brw = BRW_NEW_CONTEXT,
      .cache = 0
   },
   .prepare = prepare_cc_vp
};

struct brw_cc_unit_key {
   GLboolean stencil, stencil_two_side, color_blend, alpha_enabled;

   GLenum stencil_func[2], stencil_fail_op[2];
   GLenum stencil_pass_depth_fail_op[2], stencil_pass_depth_pass_op[2];
   GLubyte stencil_ref[2], stencil_write_mask[2], stencil_test_mask[2];
   GLenum logic_op;

   GLenum blend_eq_rgb, blend_eq_a;
   GLenum blend_src_rgb, blend_src_a;
   GLenum blend_dst_rgb, blend_dst_a;

   GLenum alpha_func;
   GLclampf alpha_ref;

   GLboolean dither;

   GLboolean depth_test, depth_write;
   GLenum depth_func;
};

d83 1
a83 2
static void
cc_unit_populate_key(struct brw_context *brw, struct brw_cc_unit_key *key)
d85 1
a85 66
   GLcontext *ctx = &brw->intel.ctx;
   const unsigned back = ctx->Stencil._BackFace;

   memset(key, 0, sizeof(*key));

   key->stencil = ctx->Stencil._Enabled;
   key->stencil_two_side = ctx->Stencil._TestTwoSide;

   if (key->stencil) {
      key->stencil_func[0] = ctx->Stencil.Function[0];
      key->stencil_fail_op[0] = ctx->Stencil.FailFunc[0];
      key->stencil_pass_depth_fail_op[0] = ctx->Stencil.ZFailFunc[0];
      key->stencil_pass_depth_pass_op[0] = ctx->Stencil.ZPassFunc[0];
      key->stencil_ref[0] = ctx->Stencil.Ref[0];
      key->stencil_write_mask[0] = ctx->Stencil.WriteMask[0];
      key->stencil_test_mask[0] = ctx->Stencil.ValueMask[0];
   }
   if (key->stencil_two_side) {
      key->stencil_func[1] = ctx->Stencil.Function[back];
      key->stencil_fail_op[1] = ctx->Stencil.FailFunc[back];
      key->stencil_pass_depth_fail_op[1] = ctx->Stencil.ZFailFunc[back];
      key->stencil_pass_depth_pass_op[1] = ctx->Stencil.ZPassFunc[back];
      key->stencil_ref[1] = ctx->Stencil.Ref[back];
      key->stencil_write_mask[1] = ctx->Stencil.WriteMask[back];
      key->stencil_test_mask[1] = ctx->Stencil.ValueMask[back];
   }

   if (ctx->Color._LogicOpEnabled)
      key->logic_op = ctx->Color.LogicOp;
   else
      key->logic_op = GL_COPY;

   key->color_blend = ctx->Color.BlendEnabled;
   if (key->color_blend) {
      key->blend_eq_rgb = ctx->Color.BlendEquationRGB;
      key->blend_eq_a = ctx->Color.BlendEquationA;
      key->blend_src_rgb = ctx->Color.BlendSrcRGB;
      key->blend_dst_rgb = ctx->Color.BlendDstRGB;
      key->blend_src_a = ctx->Color.BlendSrcA;
      key->blend_dst_a = ctx->Color.BlendDstA;

      /* If the renderbuffer is XRGB, we have to frob the blend function to
       * force the destination alpha to 1.0.  This means replacing GL_DST_ALPHA
       * with GL_ONE and GL_ONE_MINUS_DST_ALPHA with GL_ZERO.
       */
      if (ctx->DrawBuffer->Visual.alphaBits == 0) {
	 key->blend_src_rgb = fix_xRGB_alpha(key->blend_src_rgb);
	 key->blend_src_a   = fix_xRGB_alpha(key->blend_src_a);
	 key->blend_dst_rgb = fix_xRGB_alpha(key->blend_dst_rgb);
	 key->blend_dst_a   = fix_xRGB_alpha(key->blend_dst_a);
      }
   }

   key->alpha_enabled = ctx->Color.AlphaEnabled;
   if (key->alpha_enabled) {
      key->alpha_func = ctx->Color.AlphaFunc;
      key->alpha_ref = ctx->Color.AlphaRef;
   }

   key->dither = ctx->Color.DitherFlag;

   key->depth_test = ctx->Depth.Test;
   if (key->depth_test) {
      key->depth_func = ctx->Depth.Func;
      key->depth_write = ctx->Depth.Mask;
   }
d91 1
a91 2
static dri_bo *
cc_unit_create_from_key(struct brw_context *brw, struct brw_cc_unit_key *key)
d93 2
d96 1
a96 1
   dri_bo *bo;
d101 3
a103 1
   if (key->stencil) {
d106 1
a106 1
	 intel_translate_compare_func(key->stencil_func[0]);
d108 1
a108 1
	 intel_translate_stencil_op(key->stencil_fail_op[0]);
d110 1
a110 1
	 intel_translate_stencil_op(key->stencil_pass_depth_fail_op[0]);
d112 4
a115 4
	 intel_translate_stencil_op(key->stencil_pass_depth_pass_op[0]);
      cc.cc1.stencil_ref = key->stencil_ref[0];
      cc.cc1.stencil_write_mask = key->stencil_write_mask[0];
      cc.cc1.stencil_test_mask = key->stencil_test_mask[0];
d117 1
a117 1
      if (key->stencil_two_side) {
d120 1
a120 1
	    intel_translate_compare_func(key->stencil_func[1]);
d122 1
a122 1
	    intel_translate_stencil_op(key->stencil_fail_op[1]);
d124 1
a124 1
	    intel_translate_stencil_op(key->stencil_pass_depth_fail_op[1]);
d126 4
a129 4
	    intel_translate_stencil_op(key->stencil_pass_depth_pass_op[1]);
	 cc.cc1.bf_stencil_ref = key->stencil_ref[1];
	 cc.cc2.bf_stencil_write_mask = key->stencil_write_mask[1];
	 cc.cc2.bf_stencil_test_mask = key->stencil_test_mask[1];
d134 2
a135 2
      if (key->stencil_write_mask[0] ||
	  (key->stencil_two_side && key->stencil_write_mask[1]))
d140 1
a140 1
   if (key->logic_op != GL_COPY) {
d142 19
a160 8
      cc.cc5.logicop_func = intel_translate_logic_op(key->logic_op);
   } else if (key->color_blend) {
      GLenum eqRGB = key->blend_eq_rgb;
      GLenum eqA = key->blend_eq_a;
      GLenum srcRGB = key->blend_src_rgb;
      GLenum dstRGB = key->blend_dst_rgb;
      GLenum srcA = key->blend_src_a;
      GLenum dstA = key->blend_dst_a;
d184 1
a184 1
   if (key->alpha_enabled) {
d186 2
a187 1
      cc.cc3.alpha_test_func = intel_translate_compare_func(key->alpha_func);
d190 1
a190 1
      UNCLAMPED_FLOAT_TO_UBYTE(cc.cc7.alpha_ref.ub[0], key->alpha_ref);
d193 1
a193 1
   if (key->dither) {
d200 1
a200 1
   if (key->depth_test) {
d202 3
a204 2
      cc.cc2.depth_test_function = intel_translate_compare_func(key->depth_func);
      cc.cc2.depth_write_enable = key->depth_write;
d207 3
d213 4
a216 7
   if (INTEL_DEBUG & DEBUG_STATS)
      cc.cc5.statistics_enable = 1;

   bo = brw_upload_cache(&brw->cache, BRW_CC_UNIT,
			 key, sizeof(*key),
			 &brw->cc.vp_bo, 1,
			 &cc, sizeof(cc));
d219 5
a223 24
   dri_bo_emit_reloc(bo,
		     I915_GEM_DOMAIN_INSTRUCTION,
		     0,
		     0,
		     offsetof(struct brw_cc_unit_state, cc4),
		     brw->cc.vp_bo);

   return bo;
}

static void prepare_cc_unit( struct brw_context *brw )
{
   struct brw_cc_unit_key key;

   cc_unit_populate_key(brw, &key);

   dri_bo_unreference(brw->cc.state_bo);
   brw->cc.state_bo = brw_search_cache(&brw->cache, BRW_CC_UNIT,
				       &key, sizeof(key),
				       &brw->cc.vp_bo, 1,
				       NULL);

   if (brw->cc.state_bo == NULL)
      brw->cc.state_bo = cc_unit_create_from_key(brw, &key);
d229 1
a229 1
      .brw = 0,
d233 1
d236 12
d249 2
d252 8
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a37 1
#include "main/enums.h"
d41 1
d46 9
a54 2
   ccv.min_depth = 0.0;
   ccv.max_depth = 1.0;
d57 2
a58 1
   brw->cc.vp_bo = brw_cache_data( &brw->cache, BRW_CC_VP, &ccv, NULL, 0 );
d63 1
a63 1
      .mesa = 0,
d91 22
d121 1
a121 1
   key->stencil = ctx->Stencil.Enabled;
d156 11
d296 1
a296 2
			 &cc, sizeof(cc),
			 NULL, NULL);
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d37 2
a38 2
#include "macros.h"
#include "enums.h"
d40 1
a40 1
static int upload_cc_vp( struct brw_context *brw )
a50 1
   return dri_bufmgr_check_aperture_space(brw->cc.vp_bo);
d59 1
a59 1
   .prepare = upload_cc_vp
d86 2
a87 1
   struct gl_stencil_attrib *stencil = brw->attribs.Stencil;
d91 2
a92 2
   key->stencil = stencil->Enabled;
   key->stencil_two_side = stencil->_TestTwoSide;
d95 7
a101 7
      key->stencil_func[0] = stencil->Function[0];
      key->stencil_fail_op[0] = stencil->FailFunc[0];
      key->stencil_pass_depth_fail_op[0] = stencil->ZFailFunc[0];
      key->stencil_pass_depth_pass_op[0] = stencil->ZPassFunc[0];
      key->stencil_ref[0] = stencil->Ref[0];
      key->stencil_write_mask[0] = stencil->WriteMask[0];
      key->stencil_test_mask[0] = stencil->ValueMask[0];
d104 7
a110 7
      key->stencil_func[1] = stencil->Function[1];
      key->stencil_fail_op[1] = stencil->FailFunc[1];
      key->stencil_pass_depth_fail_op[1] = stencil->ZFailFunc[1];
      key->stencil_pass_depth_pass_op[1] = stencil->ZPassFunc[1];
      key->stencil_ref[1] = stencil->Ref[1];
      key->stencil_write_mask[1] = stencil->WriteMask[1];
      key->stencil_test_mask[1] = stencil->ValueMask[1];
d113 2
a114 2
   if (brw->attribs.Color->_LogicOpEnabled)
      key->logic_op = brw->attribs.Color->LogicOp;
d118 1
a118 1
   key->color_blend = brw->attribs.Color->BlendEnabled;
d120 6
a125 6
      key->blend_eq_rgb = brw->attribs.Color->BlendEquationRGB;
      key->blend_eq_a = brw->attribs.Color->BlendEquationA;
      key->blend_src_rgb = brw->attribs.Color->BlendSrcRGB;
      key->blend_dst_rgb = brw->attribs.Color->BlendDstRGB;
      key->blend_src_a = brw->attribs.Color->BlendSrcA;
      key->blend_dst_a = brw->attribs.Color->BlendDstA;
d128 1
a128 1
   key->alpha_enabled = brw->attribs.Color->AlphaEnabled;
d130 2
a131 2
      key->alpha_func = brw->attribs.Color->AlphaFunc;
      key->alpha_ref = brw->attribs.Color->AlphaRef;
d134 1
a134 1
   key->dither = brw->attribs.Color->DitherFlag;
d136 1
a136 1
   key->depth_test = brw->attribs.Depth->Test;
d138 2
a139 2
      key->depth_func = brw->attribs.Depth->Func;
      key->depth_write = brw->attribs.Depth->Mask;
d259 6
a264 5
   dri_emit_reloc(bo,
		  DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_READ,
		  0,
		  offsetof(struct brw_cc_unit_state, cc4),
		  brw->cc.vp_bo);
d269 1
a269 1
static int prepare_cc_unit( struct brw_context *brw )
a282 1
   return dri_bufmgr_check_aperture_space(brw->cc.state_bo);
@


1.1
log
@Initial revision
@
text
@d37 1
d40 1
a40 1
static void upload_cc_vp( struct brw_context *brw )
d49 3
a51 1
   brw->cc.vp_gs_offset = brw_cache_data( &brw->cache[BRW_CC_VP], &ccv );
d60 1
a60 1
   .update = upload_cc_vp
d63 2
d66 82
a147 1
static void upload_cc_unit( struct brw_context *brw )
d150 2
a151 1
   
d155 27
a181 19
   if (brw->attribs.Stencil->Enabled) {
      cc.cc0.stencil_enable = brw->attribs.Stencil->Enabled;
      cc.cc0.stencil_func = intel_translate_compare_func(brw->attribs.Stencil->Function[0]);
      cc.cc0.stencil_fail_op = intel_translate_stencil_op(brw->attribs.Stencil->FailFunc[0]);
      cc.cc0.stencil_pass_depth_fail_op = intel_translate_stencil_op(brw->attribs.Stencil->ZFailFunc[0]);
      cc.cc0.stencil_pass_depth_pass_op = intel_translate_stencil_op(brw->attribs.Stencil->ZPassFunc[0]);
      cc.cc1.stencil_ref = brw->attribs.Stencil->Ref[0];
      cc.cc1.stencil_write_mask = brw->attribs.Stencil->WriteMask[0];
      cc.cc1.stencil_test_mask = brw->attribs.Stencil->ValueMask[0];

      if (brw->attribs.Stencil->TestTwoSide) {
	 cc.cc0.bf_stencil_enable = brw->attribs.Stencil->TestTwoSide;
	 cc.cc0.bf_stencil_func = intel_translate_compare_func(brw->attribs.Stencil->Function[1]);
	 cc.cc0.bf_stencil_fail_op = intel_translate_stencil_op(brw->attribs.Stencil->FailFunc[1]);
	 cc.cc0.bf_stencil_pass_depth_fail_op = intel_translate_stencil_op(brw->attribs.Stencil->ZFailFunc[1]);
	 cc.cc0.bf_stencil_pass_depth_pass_op = intel_translate_stencil_op(brw->attribs.Stencil->ZPassFunc[1]);
	 cc.cc1.bf_stencil_ref = brw->attribs.Stencil->Ref[1];
	 cc.cc2.bf_stencil_write_mask = brw->attribs.Stencil->WriteMask[1];
	 cc.cc2.bf_stencil_test_mask = brw->attribs.Stencil->ValueMask[1];
d186 2
a187 2
      if (brw->attribs.Stencil->WriteMask[0] ||
	  (brw->attribs.Stencil->TestTwoSide && brw->attribs.Stencil->WriteMask[1]))
d192 1
a192 1
   if (brw->attribs.Color->_LogicOpEnabled) {
d194 8
a201 9
      cc.cc5.logicop_func = intel_translate_logic_op( brw->attribs.Color->LogicOp );
   }
   else if (brw->attribs.Color->BlendEnabled) {
      GLenum eqRGB = brw->attribs.Color->BlendEquationRGB;
      GLenum eqA = brw->attribs.Color->BlendEquationA;
      GLenum srcRGB = brw->attribs.Color->BlendSrcRGB;
      GLenum dstRGB = brw->attribs.Color->BlendDstRGB;
      GLenum srcA = brw->attribs.Color->BlendSrcA;
      GLenum dstA = brw->attribs.Color->BlendDstA;
d211 7
a217 7
      cc.cc6.dest_blend_factor = brw_translate_blend_factor(dstRGB); 
      cc.cc6.src_blend_factor = brw_translate_blend_factor(srcRGB); 
      cc.cc6.blend_function = brw_translate_blend_equation( eqRGB );

      cc.cc5.ia_dest_blend_factor = brw_translate_blend_factor(dstA); 
      cc.cc5.ia_src_blend_factor = brw_translate_blend_factor(srcA); 
      cc.cc5.ia_blend_function = brw_translate_blend_equation( eqA );
d220 2
a221 2
      cc.cc3.ia_blend_enable = (srcA != srcRGB || 
				dstA != dstRGB || 
d225 1
a225 1
   if (brw->attribs.Color->AlphaEnabled) {
d227 2
a228 3
      cc.cc3.alpha_test_func = intel_translate_compare_func(brw->attribs.Color->AlphaFunc);

      UNCLAMPED_FLOAT_TO_UBYTE(cc.cc7.alpha_ref.ub[0], brw->attribs.Color->AlphaRef);
d230 1
a230 1
      cc.cc3.alpha_test_format = BRW_ALPHATEST_FORMAT_UNORM8;
d233 1
a233 1
   if (brw->attribs.Color->DitherFlag) {
d235 2
a236 2
      cc.cc6.y_dither_offset = 0; 
      cc.cc6.x_dither_offset = 0;     
d240 4
a243 4
   if (brw->attribs.Depth->Test) {
      cc.cc2.depth_test = brw->attribs.Depth->Test;
      cc.cc2.depth_test_function = intel_translate_compare_func(brw->attribs.Depth->Func);
      cc.cc2.depth_write_enable = brw->attribs.Depth->Mask;
d245 1
a245 1
 
d247 2
a248 2
   cc.cc4.cc_viewport_state_offset =  brw->cc.vp_gs_offset >> 5;
 
d250 23
a272 1
      cc.cc5.statistics_enable = 1; 
d274 9
a282 1
   brw->cc.state_gs_offset = brw_cache_data( &brw->cache[BRW_CC_UNIT], &cc );
d291 1
a291 1
   .update = upload_cc_unit
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@a36 1
#include "macros.h"
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d37 2
a38 1
#include "main/macros.h"
d40 1
a40 2
void
brw_update_cc_vp(struct brw_context *brw)
a41 1
   struct gl_context *ctx = &brw->intel.ctx;
d46 2
a47 9
   /* _NEW_TRANSOFORM */
   if (ctx->Transform.DepthClamp) {
      /* _NEW_VIEWPORT */
      ccv.min_depth = MIN2(ctx->Viewport.Near, ctx->Viewport.Far);
      ccv.max_depth = MAX2(ctx->Viewport.Near, ctx->Viewport.Far);
   } else {
      ccv.min_depth = 0.0;
      ccv.max_depth = 1.0;
   }
d49 1
a49 2
   drm_intel_bo_unreference(brw->cc.vp_bo);
   brw->cc.vp_bo = brw_cache_data(&brw->cache, BRW_CC_VP, &ccv, sizeof(ccv));
d52 8
a59 21
/**
 * Modify blend function to force destination alpha to 1.0
 *
 * If \c function specifies a blend function that uses destination alpha,
 * replace it with a function that hard-wires destination alpha to 1.0.  This
 * is used when rendering to xRGB targets.
 */
static GLenum
fix_xRGB_alpha(GLenum function)
{
   switch (function) {
   case GL_DST_ALPHA:
      return GL_ONE;

   case GL_ONE_MINUS_DST_ALPHA:
   case GL_SRC_ALPHA_SATURATE:
      return GL_ZERO;
   }

   return function;
}
a60 4
static void prepare_cc_unit(struct brw_context *brw)
{
   brw_add_validated_bo(brw, brw->cc.vp_bo);
}
d62 1
a62 4
/**
 * Creates the state cache entry for the given CC unit key.
 */
static void upload_cc_unit(struct brw_context *brw)
a63 2
   struct intel_context *intel = &brw->intel;
   struct gl_context *ctx = &brw->intel.ctx;
d65 1
a65 2
   void *map;

d69 19
a87 29
   if (ctx->Stencil._Enabled) {
      const unsigned back = ctx->Stencil._BackFace;

      cc.cc0.stencil_enable = 1;
      cc.cc0.stencil_func =
	 intel_translate_compare_func(ctx->Stencil.Function[0]);
      cc.cc0.stencil_fail_op =
	 intel_translate_stencil_op(ctx->Stencil.FailFunc[0]);
      cc.cc0.stencil_pass_depth_fail_op =
	 intel_translate_stencil_op(ctx->Stencil.ZFailFunc[0]);
      cc.cc0.stencil_pass_depth_pass_op =
	 intel_translate_stencil_op(ctx->Stencil.ZPassFunc[0]);
      cc.cc1.stencil_ref = ctx->Stencil.Ref[0];
      cc.cc1.stencil_write_mask = ctx->Stencil.WriteMask[0];
      cc.cc1.stencil_test_mask = ctx->Stencil.ValueMask[0];

      if (ctx->Stencil._TestTwoSide) {
	 cc.cc0.bf_stencil_enable = 1;
	 cc.cc0.bf_stencil_func =
	    intel_translate_compare_func(ctx->Stencil.Function[back]);
	 cc.cc0.bf_stencil_fail_op =
	    intel_translate_stencil_op(ctx->Stencil.FailFunc[back]);
	 cc.cc0.bf_stencil_pass_depth_fail_op =
	    intel_translate_stencil_op(ctx->Stencil.ZFailFunc[back]);
	 cc.cc0.bf_stencil_pass_depth_pass_op =
	    intel_translate_stencil_op(ctx->Stencil.ZPassFunc[back]);
	 cc.cc1.bf_stencil_ref = ctx->Stencil.Ref[back];
	 cc.cc2.bf_stencil_write_mask = ctx->Stencil.WriteMask[back];
	 cc.cc2.bf_stencil_test_mask = ctx->Stencil.ValueMask[back];
d92 2
a93 2
      if (ctx->Stencil.WriteMask[0] ||
	  (ctx->Stencil._TestTwoSide && ctx->Stencil.WriteMask[back]))
d98 1
a98 1
   if (ctx->Color._LogicOpEnabled && ctx->Color.LogicOp != GL_COPY) {
d100 9
a108 19
      cc.cc5.logicop_func = intel_translate_logic_op(ctx->Color.LogicOp);
   } else if (ctx->Color.BlendEnabled) {
      GLenum eqRGB = ctx->Color.BlendEquationRGB;
      GLenum eqA = ctx->Color.BlendEquationA;
      GLenum srcRGB = ctx->Color.BlendSrcRGB;
      GLenum dstRGB = ctx->Color.BlendDstRGB;
      GLenum srcA = ctx->Color.BlendSrcA;
      GLenum dstA = ctx->Color.BlendDstA;

      /* If the renderbuffer is XRGB, we have to frob the blend function to
       * force the destination alpha to 1.0.  This means replacing GL_DST_ALPHA
       * with GL_ONE and GL_ONE_MINUS_DST_ALPHA with GL_ZERO.
       */
      if (ctx->DrawBuffer->Visual.alphaBits == 0) {
	 srcRGB = fix_xRGB_alpha(srcRGB);
	 srcA   = fix_xRGB_alpha(srcA);
	 dstRGB = fix_xRGB_alpha(dstRGB);
	 dstA   = fix_xRGB_alpha(dstA);
      }
d118 7
a124 7
      cc.cc6.dest_blend_factor = brw_translate_blend_factor(dstRGB);
      cc.cc6.src_blend_factor = brw_translate_blend_factor(srcRGB);
      cc.cc6.blend_function = brw_translate_blend_equation(eqRGB);

      cc.cc5.ia_dest_blend_factor = brw_translate_blend_factor(dstA);
      cc.cc5.ia_src_blend_factor = brw_translate_blend_factor(srcA);
      cc.cc5.ia_blend_function = brw_translate_blend_equation(eqA);
d127 2
a128 2
      cc.cc3.ia_blend_enable = (srcA != srcRGB ||
				dstA != dstRGB ||
d132 1
a132 1
   if (ctx->Color.AlphaEnabled) {
d134 4
a137 2
      cc.cc3.alpha_test_func =
	 intel_translate_compare_func(ctx->Color.AlphaFunc);
a138 2

      UNCLAMPED_FLOAT_TO_UBYTE(cc.cc7.alpha_ref.ub[0], ctx->Color.AlphaRef);
d141 1
a141 1
   if (ctx->Color.DitherFlag) {
d143 2
a144 2
      cc.cc6.y_dither_offset = 0;
      cc.cc6.x_dither_offset = 0;
d148 4
a151 5
   if (ctx->Depth.Test) {
      cc.cc2.depth_test = 1;
      cc.cc2.depth_test_function =
	 intel_translate_compare_func(ctx->Depth.Func);
      cc.cc2.depth_write_enable = ctx->Depth.Mask;
d153 1
a153 4

   if (intel->stats_wm || unlikely(INTEL_DEBUG & DEBUG_STATS))
      cc.cc5.statistics_enable = 1;

d155 4
a158 1
   cc.cc4.cc_viewport_state_offset = brw->cc.vp_bo->offset >> 5; /* reloc */
d160 1
a160 11
   map = brw_state_batch(brw, sizeof(cc), 64,
			 &brw->cc.state_bo, &brw->cc.state_offset);
   memcpy(map, &cc, sizeof(cc));
   brw->state.dirty.cache |= CACHE_NEW_CC_UNIT;

   /* Emit CC viewport relocation */
   drm_intel_bo_emit_reloc(brw->cc.state_bo, (brw->cc.state_offset +
					      offsetof(struct brw_cc_unit_state,
						       cc4)),
			   brw->cc.vp_bo, 0,
			   I915_GEM_DOMAIN_INSTRUCTION, 0);
d166 1
a166 1
      .brw = BRW_NEW_BATCH,
d169 1
a169 2
   .prepare = prepare_cc_unit,
   .emit = upload_cc_unit,
a171 4
static void upload_blend_constant_color(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->intel.ctx;
   struct brw_blend_constant_color bcc;
a172 7
   memset(&bcc, 0, sizeof(bcc));
   bcc.header.opcode = CMD_BLEND_CONSTANT_COLOR;
   bcc.header.length = sizeof(bcc)/4-2;
   bcc.blend_constant_color[0] = ctx->Color.BlendColor[0];
   bcc.blend_constant_color[1] = ctx->Color.BlendColor[1];
   bcc.blend_constant_color[2] = ctx->Color.BlendColor[2];
   bcc.blend_constant_color[3] = ctx->Color.BlendColor[3];
a173 11
   BRW_CACHED_BATCH_STRUCT(brw, &bcc);
}

const struct brw_tracked_state brw_blend_constant_color = {
   .dirty = {
      .mesa = _NEW_COLOR,
      .brw = BRW_NEW_CONTEXT,
      .cache = 0
   },
   .emit = upload_blend_constant_color
};
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@a37 2
#include "main/stencil.h"
#include "intel_batchbuffer.h"
d39 2
a40 2
static void
brw_upload_cc_vp(struct brw_context *brw)
d42 2
a43 2
   struct gl_context *ctx = &brw->ctx;
   struct brw_cc_viewport *ccv;
d45 1
a45 2
   ccv = brw_state_batch(brw, AUB_TRACE_CC_VP_STATE,
			 sizeof(*ccv), 32, &brw->cc.vp_offset);
d47 1
a47 1
   /* _NEW_TRANSFORM */
d50 2
a51 2
      ccv->min_depth = MIN2(ctx->Viewport.Near, ctx->Viewport.Far);
      ccv->max_depth = MAX2(ctx->Viewport.Near, ctx->Viewport.Far);
d53 2
a54 2
      ccv->min_depth = 0.0;
      ccv->max_depth = 1.0;
d57 2
a58 1
   brw->state.dirty.cache |= CACHE_NEW_CC_VP;
a60 9
const struct brw_tracked_state brw_cc_vp = {
   .dirty = {
      .mesa = _NEW_VIEWPORT | _NEW_TRANSFORM,
      .brw = BRW_NEW_BATCH,
      .cache = 0
   },
   .emit = brw_upload_cc_vp
};

d68 2
a69 2
GLenum
brw_fix_xRGB_alpha(GLenum function)
d83 5
d93 4
a96 2
   struct gl_context *ctx = &brw->ctx;
   struct brw_cc_unit_state *cc;
d98 1
a98 3
   cc = brw_state_batch(brw, AUB_TRACE_CC_STATE,
			sizeof(*cc), 64, &brw->cc.state_offset);
   memset(cc, 0, sizeof(*cc));
d100 1
a100 1
   /* _NEW_STENCIL | _NEW_BUFFERS */
d104 2
a105 2
      cc->cc0.stencil_enable = 1;
      cc->cc0.stencil_func =
d107 1
a107 1
      cc->cc0.stencil_fail_op =
d109 1
a109 1
      cc->cc0.stencil_pass_depth_fail_op =
d111 1
a111 1
      cc->cc0.stencil_pass_depth_pass_op =
d113 3
a115 3
      cc->cc1.stencil_ref = _mesa_get_stencil_ref(ctx, 0);
      cc->cc1.stencil_write_mask = ctx->Stencil.WriteMask[0];
      cc->cc1.stencil_test_mask = ctx->Stencil.ValueMask[0];
d118 2
a119 2
	 cc->cc0.bf_stencil_enable = 1;
	 cc->cc0.bf_stencil_func =
d121 1
a121 1
	 cc->cc0.bf_stencil_fail_op =
d123 1
a123 1
	 cc->cc0.bf_stencil_pass_depth_fail_op =
d125 1
a125 1
	 cc->cc0.bf_stencil_pass_depth_pass_op =
d127 3
a129 3
	 cc->cc1.bf_stencil_ref = _mesa_get_stencil_ref(ctx, back);
	 cc->cc2.bf_stencil_write_mask = ctx->Stencil.WriteMask[back];
	 cc->cc2.bf_stencil_test_mask = ctx->Stencil.ValueMask[back];
d136 1
a136 1
	 cc->cc0.stencil_write_enable = 1;
d140 3
a142 3
   if (ctx->Color.ColorLogicOpEnabled && ctx->Color.LogicOp != GL_COPY) {
      cc->cc2.logicop_enable = 1;
      cc->cc5.logicop_func = intel_translate_logic_op(ctx->Color.LogicOp);
d144 6
a149 6
      GLenum eqRGB = ctx->Color.Blend[0].EquationRGB;
      GLenum eqA = ctx->Color.Blend[0].EquationA;
      GLenum srcRGB = ctx->Color.Blend[0].SrcRGB;
      GLenum dstRGB = ctx->Color.Blend[0].DstRGB;
      GLenum srcA = ctx->Color.Blend[0].SrcA;
      GLenum dstA = ctx->Color.Blend[0].DstA;
d156 4
a159 4
	 srcRGB = brw_fix_xRGB_alpha(srcRGB);
	 srcA   = brw_fix_xRGB_alpha(srcA);
	 dstRGB = brw_fix_xRGB_alpha(dstRGB);
	 dstA   = brw_fix_xRGB_alpha(dstA);
d170 7
a176 7
      cc->cc6.dest_blend_factor = brw_translate_blend_factor(dstRGB);
      cc->cc6.src_blend_factor = brw_translate_blend_factor(srcRGB);
      cc->cc6.blend_function = brw_translate_blend_equation(eqRGB);

      cc->cc5.ia_dest_blend_factor = brw_translate_blend_factor(dstA);
      cc->cc5.ia_src_blend_factor = brw_translate_blend_factor(srcA);
      cc->cc5.ia_blend_function = brw_translate_blend_equation(eqA);
d178 2
a179 2
      cc->cc3.blend_enable = 1;
      cc->cc3.ia_blend_enable = (srcA != srcRGB ||
d185 2
a186 2
      cc->cc3.alpha_test = 1;
      cc->cc3.alpha_test_func =
d188 1
a188 1
      cc->cc3.alpha_test_format = BRW_ALPHATEST_FORMAT_UNORM8;
d190 1
a190 1
      UNCLAMPED_FLOAT_TO_UBYTE(cc->cc7.alpha_ref.ub[0], ctx->Color.AlphaRef);
d194 3
a196 3
      cc->cc5.dither_enable = 1;
      cc->cc6.y_dither_offset = 0;
      cc->cc6.x_dither_offset = 0;
d201 2
a202 2
      cc->cc2.depth_test = 1;
      cc->cc2.depth_test_function =
d204 1
a204 1
      cc->cc2.depth_write_enable = ctx->Depth.Mask;
d207 2
a208 2
   if (brw->stats_wm || unlikely(INTEL_DEBUG & DEBUG_STATS))
      cc->cc5.statistics_enable = 1;
d211 1
a211 2
   cc->cc4.cc_viewport_state_offset = (brw->batch.bo->offset +
				       brw->cc.vp_offset) >> 5; /* reloc */
d213 3
d219 4
a222 4
   drm_intel_bo_emit_reloc(brw->batch.bo,
			   (brw->cc.state_offset +
			    offsetof(struct brw_cc_unit_state, cc4)),
			   brw->batch.bo, brw->cc.vp_offset,
d228 2
a229 2
      .mesa = _NEW_STENCIL | _NEW_COLOR | _NEW_DEPTH | _NEW_BUFFERS,
      .brw = BRW_NEW_BATCH | BRW_NEW_STATS_WM,
d232 1
d238 10
a247 1
   struct gl_context *ctx = &brw->ctx;
d249 1
a249 7
   BEGIN_BATCH(5);
   OUT_BATCH(_3DSTATE_BLEND_CONSTANT_COLOR << 16 | (5-2));
   OUT_BATCH_F(ctx->Color.BlendColorUnclamped[0]);
   OUT_BATCH_F(ctx->Color.BlendColorUnclamped[1]);
   OUT_BATCH_F(ctx->Color.BlendColorUnclamped[2]);
   OUT_BATCH_F(ctx->Color.BlendColorUnclamped[3]);
   CACHED_BATCH();
@


1.1.1.5
log
@Import Mesa 9.2.5
@
text
@d190 1
a190 2
   /* _NEW_BUFFERS */
   if (ctx->Color.AlphaEnabled && ctx->DrawBuffer->_NumColorDrawBuffers <= 1) {
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics to
d5 1
a5 1

d13 1
a13 1

d17 1
a17 1

d25 1
a25 1

d29 1
a29 1
  *   Keith Whitwell <keithw@@vmware.com>
d48 1
a48 2
			 sizeof(*ccv) * ctx->Const.MaxViewports, 32,
                         &brw->cc.vp_offset);
d51 7
a57 11
   for (unsigned i = 0; i < ctx->Const.MaxViewports; i++) {
      if (ctx->Transform.DepthClamp) {
         /* _NEW_VIEWPORT */
         ccv[i].min_depth = MIN2(ctx->ViewportArray[i].Near,
                                 ctx->ViewportArray[i].Far);
         ccv[i].max_depth = MAX2(ctx->ViewportArray[i].Near,
                                 ctx->ViewportArray[i].Far);
      } else {
         ccv[i].min_depth = 0.0;
         ccv[i].max_depth = 1.0;
      }
d218 1
a218 1
   cc->cc4.cc_viewport_state_offset = (brw->batch.bo->offset64 +
d250 1
a250 1
   ADVANCE_BATCH();
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@d100 1
a100 1
 * Creates a CC unit packet from the current blend state.
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d100 1
a100 1
 * Creates the state cache entry for the given CC unit key.
@


