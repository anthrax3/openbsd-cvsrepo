head	1.7;
access;
symbols
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.09.05.14.04.54;	author jsg;	state dead;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.22;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.17;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.53.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.53.07;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.22;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.29.08;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.40;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@/**************************************************************************

Copyright 1999, 2000 ATI Technologies Inc. and Precision Insight, Inc.,
                                               Cedar Park, Texas.
All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
on the rights to use, copy, modify, merge, publish, distribute, sub
license, and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
ATI, PRECISION INSIGHT AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Gareth Hughes <gareth@@valinux.com>
 *   Kevin E. Martin <martin@@valinux.com>
 *   Keith Whitwell <keith@@tungstengraphics.com>
 *
 */

#include "r128_context.h"
#include "r128_state.h"
#include "r128_ioctl.h"
#include "r128_tris.h"
#include "r128_tex.h"

#include "main/context.h"
#include "main/enums.h"
#include "main/colormac.h"
#include "main/macros.h"
#include "main/state.h"
#include "swrast/swrast.h"
#include "vbo/vbo.h"
#include "tnl/tnl.h"
#include "swrast_setup/swrast_setup.h"

#include "drirenderbuffer.h"


/* =============================================================
 * Alpha blending
 */


/**
 * Calculate the hardware blend factor setting.  This same function is used
 * for source and destination of both alpha and RGB.  
 *
 * \returns
 * The hardware register value for the specified blend factor.  This value
 * will need to be shifted into the correct position for either source or
 * destination factor.
 *
 * \todo
 * Since the two cases where source and destination are handled differently
 * are essentially error cases, they should never happen.  Determine if these
 * cases can be removed.
 */
static int blend_factor( r128ContextPtr rmesa, GLenum factor, GLboolean is_src )
{
   int   func;

   switch ( factor ) {
   case GL_ZERO:
      func = R128_ALPHA_BLEND_ZERO;
      break;
   case GL_ONE:
      func = R128_ALPHA_BLEND_ONE;
      break;

   case GL_SRC_COLOR:
      func = R128_ALPHA_BLEND_SRCCOLOR;
      break;
   case GL_ONE_MINUS_SRC_COLOR:
      func = R128_ALPHA_BLEND_INVSRCCOLOR;
      break;
   case GL_SRC_ALPHA:
      func = R128_ALPHA_BLEND_SRCALPHA;
      break;
   case GL_ONE_MINUS_SRC_ALPHA:
      func = R128_ALPHA_BLEND_INVSRCALPHA;
      break;
   case GL_SRC_ALPHA_SATURATE:
      func = (is_src) ? R128_ALPHA_BLEND_SAT : R128_ALPHA_BLEND_ZERO;
      break;

   case GL_DST_COLOR:
      func = R128_ALPHA_BLEND_DSTCOLOR;
      break;
   case GL_ONE_MINUS_DST_COLOR:
      func = R128_ALPHA_BLEND_INVDSTCOLOR;
      break;
   case GL_DST_ALPHA:
      func = R128_ALPHA_BLEND_DSTALPHA;
      break;
   case GL_ONE_MINUS_DST_ALPHA:
      func = R128_ALPHA_BLEND_INVDSTALPHA;
      break;

   case GL_CONSTANT_COLOR:
   case GL_ONE_MINUS_CONSTANT_COLOR:
   case GL_CONSTANT_ALPHA:
   case GL_ONE_MINUS_CONSTANT_ALPHA:
   default:
      FALLBACK( rmesa, R128_FALLBACK_BLEND_FUNC, GL_TRUE );
      func = (is_src) ? R128_ALPHA_BLEND_ONE : R128_ALPHA_BLEND_ZERO;
      break;
   }
   
   return func;
}


static void r128UpdateAlphaMode( struct gl_context *ctx )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint a = rmesa->setup.misc_3d_state_cntl_reg;
   GLuint t = rmesa->setup.tex_cntl_c;

   if ( ctx->Color.AlphaEnabled ) {
      GLubyte ref;

      CLAMPED_FLOAT_TO_UBYTE(ref, ctx->Color.AlphaRef);

      a &= ~(R128_ALPHA_TEST_MASK | R128_REF_ALPHA_MASK);

      switch ( ctx->Color.AlphaFunc ) {
      case GL_NEVER:
	 a |= R128_ALPHA_TEST_NEVER;
	 break;
      case GL_LESS:
	 a |= R128_ALPHA_TEST_LESS;
         break;
      case GL_LEQUAL:
	 a |= R128_ALPHA_TEST_LESSEQUAL;
	 break;
      case GL_EQUAL:
	 a |= R128_ALPHA_TEST_EQUAL;
	 break;
      case GL_GEQUAL:
	 a |= R128_ALPHA_TEST_GREATEREQUAL;
	 break;
      case GL_GREATER:
	 a |= R128_ALPHA_TEST_GREATER;
	 break;
      case GL_NOTEQUAL:
	 a |= R128_ALPHA_TEST_NEQUAL;
	 break;
      case GL_ALWAYS:
	 a |= R128_ALPHA_TEST_ALWAYS;
	 break;
      }

      a |= ref & R128_REF_ALPHA_MASK;
      t |= R128_ALPHA_TEST_ENABLE;
   } else {
      t &= ~R128_ALPHA_TEST_ENABLE;
   }

   FALLBACK( rmesa, R128_FALLBACK_BLEND_FUNC, GL_FALSE );

   if ( ctx->Color.BlendEnabled ) {
      a &= ~((R128_ALPHA_BLEND_MASK << R128_ALPHA_BLEND_SRC_SHIFT) |
	     (R128_ALPHA_BLEND_MASK << R128_ALPHA_BLEND_DST_SHIFT)
	     | R128_ALPHA_COMB_FCN_MASK);

      a |= blend_factor( rmesa, ctx->Color.Blend[0].SrcRGB, GL_TRUE ) 
	  << R128_ALPHA_BLEND_SRC_SHIFT;
      a |= blend_factor( rmesa, ctx->Color.Blend[0].DstRGB, GL_FALSE ) 
	  << R128_ALPHA_BLEND_DST_SHIFT;

      switch (ctx->Color.Blend[0].EquationRGB) {
      case GL_FUNC_ADD:
	 a |= R128_ALPHA_COMB_ADD_CLAMP;
	 break;
      case GL_FUNC_SUBTRACT:
	 a |= R128_ALPHA_COMB_SUB_SRC_DST_CLAMP;
	 break;
      default:
	 FALLBACK( rmesa, R128_FALLBACK_BLEND_EQ, GL_TRUE );
      }

      t |=  R128_ALPHA_ENABLE;
   } else {
      t &= ~R128_ALPHA_ENABLE;
   }

   if ( rmesa->setup.misc_3d_state_cntl_reg != a ) {
      rmesa->setup.misc_3d_state_cntl_reg = a;
      rmesa->dirty |= R128_UPLOAD_CONTEXT | R128_UPLOAD_MASKS;
   }
   if ( rmesa->setup.tex_cntl_c != t ) {
      rmesa->setup.tex_cntl_c = t;
      rmesa->dirty |= R128_UPLOAD_CONTEXT | R128_UPLOAD_MASKS;
   }
}

static void r128DDAlphaFunc( struct gl_context *ctx, GLenum func, GLfloat ref )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   FLUSH_BATCH( rmesa );
   rmesa->new_state |= R128_NEW_ALPHA;
}

static void r128DDBlendEquationSeparate( struct gl_context *ctx, 
					 GLenum modeRGB, GLenum modeA )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   assert( modeRGB == modeA );
   FLUSH_BATCH( rmesa );

   /* BlendEquation sets ColorLogicOpEnabled in an unexpected
    * manner.
    */
   FALLBACK( R128_CONTEXT(ctx), R128_FALLBACK_LOGICOP,
	     (ctx->Color.ColorLogicOpEnabled &&
	      ctx->Color.LogicOp != GL_COPY));

   /* Can only do blend addition, not min, max, subtract, etc. */
   FALLBACK( R128_CONTEXT(ctx), R128_FALLBACK_BLEND_EQ,
	     (modeRGB != GL_FUNC_ADD) && (modeRGB != GL_FUNC_SUBTRACT));

   rmesa->new_state |= R128_NEW_ALPHA;
}

static void r128DDBlendFuncSeparate( struct gl_context *ctx,
				     GLenum sfactorRGB, GLenum dfactorRGB,
				     GLenum sfactorA, GLenum dfactorA )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   FLUSH_BATCH( rmesa );
   rmesa->new_state |= R128_NEW_ALPHA;
}

/* =============================================================
 * Stencil
 */

static void
r128DDStencilFuncSeparate( struct gl_context *ctx, GLenum face, GLenum func,
                           GLint ref, GLuint mask )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint refmask = (((ctx->Stencil.Ref[0] & 0xff) << 0) |
		     ((ctx->Stencil.ValueMask[0] & 0xff) << 16) |
		     ((ctx->Stencil.WriteMask[0] & 0xff) << 24)); 
   GLuint z = rmesa->setup.z_sten_cntl_c;

   z &= ~R128_STENCIL_TEST_MASK;
   switch ( ctx->Stencil.Function[0] ) {
   case GL_NEVER:
      z |= R128_STENCIL_TEST_NEVER;
      break;
   case GL_LESS:
      z |= R128_STENCIL_TEST_LESS;
      break;
   case GL_EQUAL:
      z |= R128_STENCIL_TEST_EQUAL;
      break;
   case GL_LEQUAL:
      z |= R128_STENCIL_TEST_LESSEQUAL;
      break;
   case GL_GREATER:
      z |= R128_STENCIL_TEST_GREATER;
      break;
   case GL_NOTEQUAL:
      z |= R128_STENCIL_TEST_NEQUAL;
      break;
   case GL_GEQUAL:
      z |= R128_STENCIL_TEST_GREATEREQUAL;
      break;
   case GL_ALWAYS:
      z |= R128_STENCIL_TEST_ALWAYS;
      break;
   }

   if ( rmesa->setup.sten_ref_mask_c != refmask ) {
      rmesa->setup.sten_ref_mask_c = refmask;
      rmesa->dirty |= R128_UPLOAD_MASKS;
   }
   if ( rmesa->setup.z_sten_cntl_c != z ) {
      rmesa->setup.z_sten_cntl_c = z;
      rmesa->dirty |= R128_UPLOAD_CONTEXT;
   }
}

static void
r128DDStencilMaskSeparate( struct gl_context *ctx, GLenum face, GLuint mask )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint refmask = (((ctx->Stencil.Ref[0] & 0xff) << 0) |
		     ((ctx->Stencil.ValueMask[0] & 0xff) << 16) |
		     ((ctx->Stencil.WriteMask[0] & 0xff) << 24)); 

   if ( rmesa->setup.sten_ref_mask_c != refmask ) {
      rmesa->setup.sten_ref_mask_c = refmask;
      rmesa->dirty |= R128_UPLOAD_MASKS;
   }
}

static void r128DDStencilOpSeparate( struct gl_context *ctx, GLenum face, GLenum fail,
                                     GLenum zfail, GLenum zpass )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint z = rmesa->setup.z_sten_cntl_c;

   if (!( ctx->Visual.stencilBits > 0 && ctx->Visual.depthBits == 24 ))
      return;

   z &= ~(R128_STENCIL_S_FAIL_MASK | R128_STENCIL_ZPASS_MASK |
	  R128_STENCIL_ZFAIL_MASK);

   switch ( ctx->Stencil.FailFunc[0] ) {
   case GL_KEEP:
      z |= R128_STENCIL_S_FAIL_KEEP;
      break;
   case GL_ZERO:
      z |= R128_STENCIL_S_FAIL_ZERO;
      break;
   case GL_REPLACE:
      z |= R128_STENCIL_S_FAIL_REPLACE;
      break;
   case GL_INCR:
      z |= R128_STENCIL_S_FAIL_INC;
      break;
   case GL_DECR:
      z |= R128_STENCIL_S_FAIL_DEC;
      break;
   case GL_INVERT:
      z |= R128_STENCIL_S_FAIL_INV;
      break;
   case GL_INCR_WRAP:
      z |= R128_STENCIL_S_FAIL_INC_WRAP;
      break;
   case GL_DECR_WRAP:
      z |= R128_STENCIL_S_FAIL_DEC_WRAP;
      break;
   }

   switch ( ctx->Stencil.ZFailFunc[0] ) {
   case GL_KEEP:
      z |= R128_STENCIL_ZFAIL_KEEP;
      break;
   case GL_ZERO:
      z |= R128_STENCIL_ZFAIL_ZERO;
      break;
   case GL_REPLACE:
      z |= R128_STENCIL_ZFAIL_REPLACE;
      break;
   case GL_INCR:
      z |= R128_STENCIL_ZFAIL_INC;
      break;
   case GL_DECR:
      z |= R128_STENCIL_ZFAIL_DEC;
      break;
   case GL_INVERT:
      z |= R128_STENCIL_ZFAIL_INV;
      break;
   case GL_INCR_WRAP:
      z |= R128_STENCIL_ZFAIL_INC_WRAP;
      break;
   case GL_DECR_WRAP:
      z |= R128_STENCIL_ZFAIL_DEC_WRAP;
      break;
   }

   switch ( ctx->Stencil.ZPassFunc[0] ) {
   case GL_KEEP:
      z |= R128_STENCIL_ZPASS_KEEP;
      break;
   case GL_ZERO:
      z |= R128_STENCIL_ZPASS_ZERO;
      break;
   case GL_REPLACE:
      z |= R128_STENCIL_ZPASS_REPLACE;
      break;
   case GL_INCR:
      z |= R128_STENCIL_ZPASS_INC;
      break;
   case GL_DECR:
      z |= R128_STENCIL_ZPASS_DEC;
      break;
   case GL_INVERT:
      z |= R128_STENCIL_ZPASS_INV;
      break;
   case GL_INCR_WRAP:
      z |= R128_STENCIL_ZPASS_INC_WRAP;
      break;
   case GL_DECR_WRAP:
      z |= R128_STENCIL_ZPASS_DEC_WRAP;
      break;
   }

   if ( rmesa->setup.z_sten_cntl_c != z ) {
      rmesa->setup.z_sten_cntl_c = z;
      rmesa->dirty |= R128_UPLOAD_CONTEXT;
   }
}

static void r128DDClearStencil( struct gl_context *ctx, GLint s )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   if (ctx->Visual.stencilBits > 0 && ctx->Visual.depthBits == 24) {
      rmesa->ClearDepth &= 0x00ffffff;
      rmesa->ClearDepth |= ctx->Stencil.Clear << 24;
   }
}

/* =============================================================
 * Depth testing
 */

static void r128UpdateZMode( struct gl_context *ctx )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint z = rmesa->setup.z_sten_cntl_c;
   GLuint t = rmesa->setup.tex_cntl_c;

   if ( ctx->Depth.Test ) {
      z &= ~R128_Z_TEST_MASK;

      switch ( ctx->Depth.Func ) {
      case GL_NEVER:
	 z |= R128_Z_TEST_NEVER;
	 break;
      case GL_ALWAYS:
	 z |= R128_Z_TEST_ALWAYS;
	 break;
      case GL_LESS:
	 z |= R128_Z_TEST_LESS;
	 break;
      case GL_LEQUAL:
	 z |= R128_Z_TEST_LESSEQUAL;
	 break;
      case GL_EQUAL:
	 z |= R128_Z_TEST_EQUAL;
	 break;
      case GL_GEQUAL:
	 z |= R128_Z_TEST_GREATEREQUAL;
	 break;
      case GL_GREATER:
	 z |= R128_Z_TEST_GREATER;
	 break;
      case GL_NOTEQUAL:
	 z |= R128_Z_TEST_NEQUAL;
	 break;
      }

      t |=  R128_Z_ENABLE;
   } else {
      t &= ~R128_Z_ENABLE;
   }

   if ( ctx->Depth.Mask ) {
      t |=  R128_Z_WRITE_ENABLE;
   } else {
      t &= ~R128_Z_WRITE_ENABLE;
   }

   if ( rmesa->setup.z_sten_cntl_c != z ) {
      rmesa->setup.z_sten_cntl_c = z;
      rmesa->dirty |= R128_UPLOAD_CONTEXT;
   }
   if ( rmesa->setup.tex_cntl_c != t ) {
      rmesa->setup.tex_cntl_c = t;
      rmesa->dirty |= R128_UPLOAD_CONTEXT;
   }
}

static void r128DDDepthFunc( struct gl_context *ctx, GLenum func )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   FLUSH_BATCH( rmesa );
   rmesa->new_state |= R128_NEW_DEPTH;
}

static void r128DDDepthMask( struct gl_context *ctx, GLboolean flag )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   FLUSH_BATCH( rmesa );
   rmesa->new_state |= R128_NEW_DEPTH;
}

static void r128DDClearDepth( struct gl_context *ctx, GLclampd d )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   switch ( rmesa->setup.z_sten_cntl_c &  R128_Z_PIX_WIDTH_MASK ) {
   case R128_Z_PIX_WIDTH_16:
      rmesa->ClearDepth = d * 0x0000ffff;
      break;
   case R128_Z_PIX_WIDTH_24:
      rmesa->ClearDepth = d * 0x00ffffff;
      rmesa->ClearDepth |= ctx->Stencil.Clear << 24;
      break;
   case R128_Z_PIX_WIDTH_32:
      rmesa->ClearDepth = d * 0xffffffff;
      break;
   }
}


/* =============================================================
 * Fog
 */

static void r128UpdateFogAttrib( struct gl_context *ctx )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint t = rmesa->setup.tex_cntl_c;
   GLubyte c[4];
   GLuint col;

   if ( ctx->Fog.Enabled ) {
      t |=  R128_FOG_ENABLE;
   } else {
      t &= ~R128_FOG_ENABLE;
   }

   c[0] = FLOAT_TO_UBYTE( ctx->Fog.Color[0] );
   c[1] = FLOAT_TO_UBYTE( ctx->Fog.Color[1] );
   c[2] = FLOAT_TO_UBYTE( ctx->Fog.Color[2] );

   col = r128PackColor( 4, c[0], c[1], c[2], 0 );

   if ( rmesa->setup.fog_color_c != col ) {
      rmesa->setup.fog_color_c = col;
      rmesa->dirty |= R128_UPLOAD_CONTEXT;
   }
   if ( rmesa->setup.tex_cntl_c != t ) {
      rmesa->setup.tex_cntl_c = t;
      rmesa->dirty |= R128_UPLOAD_CONTEXT;
   }
}

static void r128DDFogfv( struct gl_context *ctx, GLenum pname, const GLfloat *param )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   FLUSH_BATCH( rmesa );
   rmesa->new_state |= R128_NEW_FOG;
}


/* =============================================================
 * Clipping
 */

static void r128UpdateClipping( struct gl_context *ctx )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   if ( rmesa->driDrawable ) {
      __DRIdrawable *drawable = rmesa->driDrawable;
      int x1 = 0;
      int y1 = 0;
      int x2 = drawable->w - 1;
      int y2 = drawable->h - 1;

      if ( ctx->Scissor.Enabled ) {
	 if ( ctx->Scissor.X > x1 ) {
	    x1 = ctx->Scissor.X;
	 }
	 if ( drawable->h - ctx->Scissor.Y - ctx->Scissor.Height > y1 ) {
	    y1 = drawable->h - ctx->Scissor.Y - ctx->Scissor.Height;
	 }
	 if ( ctx->Scissor.X + ctx->Scissor.Width - 1 < x2 ) {
	    x2 = ctx->Scissor.X + ctx->Scissor.Width - 1;
	 }
	 if ( drawable->h - ctx->Scissor.Y - 1 < y2 ) {
	    y2 = drawable->h - ctx->Scissor.Y - 1;
	 }
      }

      x1 += drawable->x;
      y1 += drawable->y;
      x2 += drawable->x;
      y2 += drawable->y;

      /* Clamp values to screen to avoid wrapping problems */
      if ( x1 < 0 )
         x1 = 0;
      else if ( x1 >= rmesa->driScreen->fbWidth )
         x1 = rmesa->driScreen->fbWidth - 1;
      if ( y1 < 0 )
         y1 = 0;
      else if ( y1 >= rmesa->driScreen->fbHeight )
         y1 = rmesa->driScreen->fbHeight - 1;
      if ( x2 < 0 )
         x2 = 0;
      else if ( x2 >= rmesa->driScreen->fbWidth )
         x2 = rmesa->driScreen->fbWidth - 1;
      if ( y2 < 0 )
         y2 = 0;
      else if ( y2 >= rmesa->driScreen->fbHeight )
         y2 = rmesa->driScreen->fbHeight - 1;

      rmesa->setup.sc_top_left_c     = (((y1 & 0x3FFF) << 16) | (x1 & 0x3FFF));
      rmesa->setup.sc_bottom_right_c = (((y2 & 0x3FFF) << 16) | (x2 & 0x3FFF));

      rmesa->dirty |= R128_UPLOAD_CONTEXT;
   }
}

static void r128DDScissor( struct gl_context *ctx,
			   GLint x, GLint y, GLsizei w, GLsizei h )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   FLUSH_BATCH( rmesa );
   rmesa->new_state |= R128_NEW_CLIP;
}


/* =============================================================
 * Culling
 */

static void r128UpdateCull( struct gl_context *ctx )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint f = rmesa->setup.pm4_vc_fpu_setup;

   f &= ~R128_FRONT_DIR_MASK;

   switch ( ctx->Polygon.FrontFace ) {
   case GL_CW:
      f |= R128_FRONT_DIR_CW;
      break;
   case GL_CCW:
      f |= R128_FRONT_DIR_CCW;
      break;
   }

   f |= R128_BACKFACE_SOLID | R128_FRONTFACE_SOLID;

   if ( ctx->Polygon.CullFlag ) {
      switch ( ctx->Polygon.CullFaceMode ) {
      case GL_FRONT:
	 f &= ~R128_FRONTFACE_SOLID;
	 break;
      case GL_BACK:
	 f &= ~R128_BACKFACE_SOLID;
	 break;
      case GL_FRONT_AND_BACK:
	 f &= ~(R128_BACKFACE_SOLID |
		R128_FRONTFACE_SOLID);
	 break;
      }
   }

   if ( 1 || rmesa->setup.pm4_vc_fpu_setup != f ) {
      rmesa->setup.pm4_vc_fpu_setup = f;
      rmesa->dirty |= R128_UPLOAD_CONTEXT | R128_UPLOAD_SETUP;
   }
}

static void r128DDCullFace( struct gl_context *ctx, GLenum mode )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   FLUSH_BATCH( rmesa );
   rmesa->new_state |= R128_NEW_CULL;
}

static void r128DDFrontFace( struct gl_context *ctx, GLenum mode )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   FLUSH_BATCH( rmesa );
   rmesa->new_state |= R128_NEW_CULL;
}


/* =============================================================
 * Masks
 */

static void r128UpdateMasks( struct gl_context *ctx )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   GLuint mask = r128PackColor( rmesa->r128Screen->cpp,
				ctx->Color.ColorMask[0][RCOMP],
				ctx->Color.ColorMask[0][GCOMP],
				ctx->Color.ColorMask[0][BCOMP],
				ctx->Color.ColorMask[0][ACOMP] );

   if ( rmesa->setup.plane_3d_mask_c != mask ) {
      rmesa->setup.plane_3d_mask_c = mask;
      rmesa->dirty |= R128_UPLOAD_CONTEXT | R128_UPLOAD_MASKS;
   }
}

static void r128DDColorMask( struct gl_context *ctx,
			     GLboolean r, GLboolean g,
			     GLboolean b, GLboolean a )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   FLUSH_BATCH( rmesa );
   rmesa->new_state |= R128_NEW_MASKS;
}


/* =============================================================
 * Rendering attributes
 *
 * We really don't want to recalculate all this every time we bind a
 * texture.  These things shouldn't change all that often, so it makes
 * sense to break them out of the core texture state update routines.
 */

static void updateSpecularLighting( struct gl_context *ctx )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint t = rmesa->setup.tex_cntl_c;

   if ( _mesa_need_secondary_color( ctx ) ) {
      if (ctx->Light.ShadeModel == GL_FLAT) {
         /* R128 can't do flat-shaded separate specular */
         t &= ~R128_SPEC_LIGHT_ENABLE;
         FALLBACK( rmesa, R128_FALLBACK_SEP_SPECULAR, GL_TRUE );
      }
      else {
         t |= R128_SPEC_LIGHT_ENABLE;
         FALLBACK( rmesa, R128_FALLBACK_SEP_SPECULAR, GL_FALSE );
      }
   }
   else {
      t &= ~R128_SPEC_LIGHT_ENABLE;
      FALLBACK( rmesa, R128_FALLBACK_SEP_SPECULAR, GL_FALSE );
   }

   if ( rmesa->setup.tex_cntl_c != t ) {
      rmesa->setup.tex_cntl_c = t;
      rmesa->dirty |= R128_UPLOAD_CONTEXT;
      rmesa->dirty |= R128_UPLOAD_SETUP;
      rmesa->new_state |= R128_NEW_CONTEXT;
   }
}


static void r128DDLightModelfv( struct gl_context *ctx, GLenum pname,
				const GLfloat *param )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   if ( pname == GL_LIGHT_MODEL_COLOR_CONTROL ) {
      FLUSH_BATCH( rmesa );
      updateSpecularLighting(ctx);
   }

   if ( pname == GL_LIGHT_MODEL_TWO_SIDE ) {
      FLUSH_BATCH( rmesa );
      r128ChooseRenderState( ctx );
   }
}

static void r128DDShadeModel( struct gl_context *ctx, GLenum mode )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint s = rmesa->setup.pm4_vc_fpu_setup;

   s &= ~R128_FPU_COLOR_MASK;

   switch ( mode ) {
   case GL_FLAT:
      s |= R128_FPU_COLOR_FLAT;
      break;
   case GL_SMOOTH:
      s |= R128_FPU_COLOR_GOURAUD;
      break;
   default:
      return;
   }

   updateSpecularLighting(ctx);

   if ( rmesa->setup.pm4_vc_fpu_setup != s ) {
      FLUSH_BATCH( rmesa );
      rmesa->setup.pm4_vc_fpu_setup = s;

      rmesa->new_state |= R128_NEW_CONTEXT;
      rmesa->dirty |= R128_UPLOAD_SETUP;
   }
}


/* =============================================================
 * Window position
 */

static void r128UpdateWindow( struct gl_context *ctx )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   int x = rmesa->driDrawable->x;
   int y = rmesa->driDrawable->y;
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0];
   driRenderbuffer *drb = (driRenderbuffer *) rb;

   rmesa->setup.window_xy_offset = (((y & 0xFFF) << R128_WINDOW_Y_SHIFT) |
				    ((x & 0xFFF) << R128_WINDOW_X_SHIFT));

   rmesa->setup.dst_pitch_offset_c = (((drb->flippedPitch/8) << 21) |
                                      (drb->flippedOffset >> 5));


   rmesa->dirty |= R128_UPLOAD_CONTEXT | R128_UPLOAD_WINDOW;
}


/* =============================================================
 * Viewport
 */

static void r128CalcViewport( struct gl_context *ctx )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   const GLfloat *v = ctx->Viewport._WindowMap.m;
   GLfloat *m = rmesa->hw_viewport;

   /* See also r128_translate_vertex.
    */
   m[MAT_SX] =   v[MAT_SX];
   m[MAT_TX] =   v[MAT_TX] + SUBPIXEL_X;
   m[MAT_SY] = - v[MAT_SY];
   m[MAT_TY] = - v[MAT_TY] + rmesa->driDrawable->h + SUBPIXEL_Y;
   m[MAT_SZ] =   v[MAT_SZ] * rmesa->depth_scale;
   m[MAT_TZ] =   v[MAT_TZ] * rmesa->depth_scale;
}

static void r128Viewport( struct gl_context *ctx,
			  GLint x, GLint y,
			  GLsizei width, GLsizei height )
{
   r128CalcViewport( ctx );
}

static void r128DepthRange( struct gl_context *ctx,
			    GLclampd nearval, GLclampd farval )
{
   r128CalcViewport( ctx );
}


/* =============================================================
 * Miscellaneous
 */

static void r128DDClearColor( struct gl_context *ctx,
			      const GLfloat color[4] )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLubyte c[4];

   CLAMPED_FLOAT_TO_UBYTE(c[0], color[0]);
   CLAMPED_FLOAT_TO_UBYTE(c[1], color[1]);
   CLAMPED_FLOAT_TO_UBYTE(c[2], color[2]);
   CLAMPED_FLOAT_TO_UBYTE(c[3], color[3]);

   rmesa->ClearColor = r128PackColor( rmesa->r128Screen->cpp,
				      c[0], c[1], c[2], c[3] );
}

static void r128DDLogicOpCode( struct gl_context *ctx, GLenum opcode )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   if ( ctx->Color.ColorLogicOpEnabled ) {
      FLUSH_BATCH( rmesa );

      FALLBACK( rmesa, R128_FALLBACK_LOGICOP, opcode != GL_COPY );
   }
}

static void r128DDDrawBuffer( struct gl_context *ctx, GLenum mode )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   FLUSH_BATCH( rmesa );

   if (ctx->DrawBuffer->_NumColorDrawBuffers != 1) {
      /* GL_NONE or GL_FRONT_AND_BACK or stereo left&right, etc */
      FALLBACK( rmesa, R128_FALLBACK_DRAW_BUFFER, GL_TRUE );
      return;
   }
   else {
      switch ( ctx->DrawBuffer->_ColorDrawBufferIndexes[0] ) {
      case BUFFER_FRONT_LEFT:
      case BUFFER_BACK_LEFT:
         FALLBACK( rmesa, R128_FALLBACK_DRAW_BUFFER, GL_FALSE );
         break;
      default:
         /* GL_NONE or GL_FRONT_AND_BACK or stereo left&right, etc */
         FALLBACK( rmesa, R128_FALLBACK_DRAW_BUFFER, GL_TRUE );
         break;
      }
   }

   rmesa->new_state |= R128_NEW_WINDOW;
}

static void r128DDReadBuffer( struct gl_context *ctx, GLenum mode )
{
   /* nothing, until we implement h/w glRead/CopyPixels or CopyTexImage */
}


/* =============================================================
 * Polygon stipple
 */

static void r128DDPolygonStipple( struct gl_context *ctx, const GLubyte *mask )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint stipple[32], i;
   drm_r128_stipple_t stippleRec;

   for (i = 0; i < 32; i++) {
      stipple[31 - i] = ((mask[i*4+0] << 24) |
                         (mask[i*4+1] << 16) |
                         (mask[i*4+2] << 8)  |
                         (mask[i*4+3]));
   }

   FLUSH_BATCH( rmesa );
   LOCK_HARDWARE( rmesa );

   stippleRec.mask = stipple;
   drmCommandWrite( rmesa->driFd, DRM_R128_STIPPLE, 
                    &stippleRec, sizeof(stippleRec) );

   UNLOCK_HARDWARE( rmesa );

   rmesa->new_state |= R128_NEW_CONTEXT;
   rmesa->dirty |= R128_UPLOAD_CONTEXT;
}


/* =============================================================
 * Render mode
 */

static void r128DDRenderMode( struct gl_context *ctx, GLenum mode )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   FALLBACK( rmesa, R128_FALLBACK_RENDER_MODE, (mode != GL_RENDER) );
}



/* =============================================================
 * State enable/disable
 */

static void r128DDEnable( struct gl_context *ctx, GLenum cap, GLboolean state )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);

   if ( R128_DEBUG & DEBUG_VERBOSE_API ) {
      fprintf( stderr, "%s( %s = %s )\n",
	       __FUNCTION__, _mesa_lookup_enum_by_nr( cap ),
	       state ? "GL_TRUE" : "GL_FALSE" );
   }

   switch ( cap ) {
   case GL_ALPHA_TEST:
      FLUSH_BATCH( rmesa );
      rmesa->new_state |= R128_NEW_ALPHA;
      break;

   case GL_BLEND:
      FLUSH_BATCH( rmesa );
      rmesa->new_state |= R128_NEW_ALPHA;

      /* For some reason enable(GL_BLEND) affects ColorLogicOpEnabled.
       */
      FALLBACK( rmesa, R128_FALLBACK_LOGICOP,
		(ctx->Color.ColorLogicOpEnabled &&
		 ctx->Color.LogicOp != GL_COPY));
      break;

   case GL_CULL_FACE:
      FLUSH_BATCH( rmesa );
      rmesa->new_state |= R128_NEW_CULL;
      break;

   case GL_DEPTH_TEST:
      FLUSH_BATCH( rmesa );
      rmesa->new_state |= R128_NEW_DEPTH;
      break;

   case GL_DITHER:
      do {
	 GLuint t = rmesa->setup.tex_cntl_c;
	 FLUSH_BATCH( rmesa );

	 if ( ctx->Color.DitherFlag ) {
	    t |=  R128_DITHER_ENABLE;
	 } else {
	    t &= ~R128_DITHER_ENABLE;
	 }

	 if ( rmesa->setup.tex_cntl_c != t ) {
	    rmesa->setup.tex_cntl_c = t;
	    rmesa->dirty |= R128_UPLOAD_CONTEXT;
	 }
      } while (0);
      break;

   case GL_FOG:
      FLUSH_BATCH( rmesa );
      rmesa->new_state |= R128_NEW_FOG;
      break;

   case GL_COLOR_LOGIC_OP:
      FLUSH_BATCH( rmesa );
      FALLBACK( rmesa, R128_FALLBACK_LOGICOP,
		state && ctx->Color.LogicOp != GL_COPY );
      break;

   case GL_LIGHTING:
   case GL_COLOR_SUM_EXT:
      updateSpecularLighting(ctx);
      break;

   case GL_SCISSOR_TEST:
      FLUSH_BATCH( rmesa );
      rmesa->scissor = state;
      rmesa->new_state |= R128_NEW_CLIP;
      break;

   case GL_STENCIL_TEST:
      FLUSH_BATCH( rmesa );
      if ( ctx->Visual.stencilBits > 0 && ctx->Visual.depthBits == 24 ) {
	 if ( state ) {
	    rmesa->setup.tex_cntl_c |=  R128_STENCIL_ENABLE;
	    /* Reset the fallback (if any) for bad stencil funcs */
	    r128DDStencilOpSeparate( ctx, 0, ctx->Stencil.FailFunc[0],
				     ctx->Stencil.ZFailFunc[0],
				     ctx->Stencil.ZPassFunc[0] );
	 } else {
	    rmesa->setup.tex_cntl_c &= ~R128_STENCIL_ENABLE;
	    FALLBACK( rmesa, R128_FALLBACK_STENCIL, GL_FALSE );
	 }
	 rmesa->dirty |= R128_UPLOAD_CONTEXT;
      } else {
	 FALLBACK( rmesa, R128_FALLBACK_STENCIL, state );
      }
      break;

   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_TEXTURE_3D:
      FLUSH_BATCH( rmesa );
      break;

   case GL_POLYGON_STIPPLE:
      if ( rmesa->render_primitive == GL_TRIANGLES ) {
	 FLUSH_BATCH( rmesa );
	 rmesa->setup.dp_gui_master_cntl_c &= ~R128_GMC_BRUSH_NONE;
	 if ( state ) {
	    rmesa->setup.dp_gui_master_cntl_c |=
	       R128_GMC_BRUSH_32x32_MONO_FG_LA;
	 } else {
	    rmesa->setup.dp_gui_master_cntl_c |=
	       R128_GMC_BRUSH_SOLID_COLOR;
	 }
	 rmesa->new_state |= R128_NEW_CONTEXT;
	 rmesa->dirty |= R128_UPLOAD_CONTEXT;
      }
      break;

   default:
      return;
   }
}


/* =============================================================
 * State initialization, management
 */

static void r128DDPrintDirty( const char *msg, GLuint state )
{
   fprintf( stderr,
	    "%s: (0x%x) %s%s%s%s%s%s%s%s%s\n",
	    msg,
	    state,
	    (state & R128_UPLOAD_CORE)		? "core, " : "",
	    (state & R128_UPLOAD_CONTEXT)	? "context, " : "",
	    (state & R128_UPLOAD_SETUP)		? "setup, " : "",
	    (state & R128_UPLOAD_TEX0)		? "tex0, " : "",
	    (state & R128_UPLOAD_TEX1)		? "tex1, " : "",
	    (state & R128_UPLOAD_MASKS)		? "masks, " : "",
	    (state & R128_UPLOAD_WINDOW)	? "window, " : "",
	    (state & R128_UPLOAD_CLIPRECTS)	? "cliprects, " : "",
	    (state & R128_REQUIRE_QUIESCENCE)	? "quiescence, " : "" );
}

/*
 * Load the current context's state into the hardware.
 *
 * NOTE: Be VERY careful about ensuring the context state is marked for
 * upload, the only place it shouldn't be uploaded is when the setup
 * state has changed in ReducedPrimitiveChange as this comes right after
 * a state update.
 *
 * Blits of any type should always upload the context and masks after
 * they are done.
 */
void r128EmitHwStateLocked( r128ContextPtr rmesa )
{
   drm_r128_sarea_t *sarea = rmesa->sarea;
   drm_r128_context_regs_t *regs = &(rmesa->setup);
   const r128TexObjPtr t0 = rmesa->CurrentTexObj[0];
   const r128TexObjPtr t1 = rmesa->CurrentTexObj[1];

   if ( R128_DEBUG & DEBUG_VERBOSE_MSG ) {
      r128DDPrintDirty( "r128EmitHwStateLocked", rmesa->dirty );
   }

   if ( rmesa->dirty & (R128_UPLOAD_CONTEXT |
			R128_UPLOAD_SETUP |
			R128_UPLOAD_MASKS |
			R128_UPLOAD_WINDOW |
			R128_UPLOAD_CORE) ) {
      memcpy( &sarea->context_state, regs, sizeof(sarea->context_state) );
      
      if( rmesa->dirty & R128_UPLOAD_CONTEXT )
      {
         /* One possible side-effect of uploading a new context is the
          * setting of the R128_GMC_AUX_CLIP_DIS bit, which causes all
          * auxilliary cliprects to be disabled. So the next command must
          * upload them again. */
         rmesa->dirty |= R128_UPLOAD_CLIPRECTS;
      }
   }

   if ( (rmesa->dirty & R128_UPLOAD_TEX0) && t0 ) {
      drm_r128_texture_regs_t *tex = &sarea->tex_state[0];

      tex->tex_cntl		= t0->setup.tex_cntl;
      tex->tex_combine_cntl	= rmesa->tex_combine[0];
      tex->tex_size_pitch	= t0->setup.tex_size_pitch;
      memcpy( &tex->tex_offset[0], &t0->setup.tex_offset[0],
	      sizeof(tex->tex_offset ) );
      tex->tex_border_color	= t0->setup.tex_border_color;
   }

   if ( (rmesa->dirty & R128_UPLOAD_TEX1) && t1 ) {
      drm_r128_texture_regs_t *tex = &sarea->tex_state[1];

      tex->tex_cntl		= t1->setup.tex_cntl;
      tex->tex_combine_cntl	= rmesa->tex_combine[1];
      tex->tex_size_pitch	= t1->setup.tex_size_pitch;
      memcpy( &tex->tex_offset[0], &t1->setup.tex_offset[0],
	      sizeof(tex->tex_offset ) );
      tex->tex_border_color	= t1->setup.tex_border_color;
   }

   sarea->vertsize = rmesa->vertex_size;
   sarea->vc_format = rmesa->vertex_format;

   /* Turn off the texture cache flushing */
   rmesa->setup.tex_cntl_c &= ~R128_TEX_CACHE_FLUSH;

   sarea->dirty |= rmesa->dirty;
   rmesa->dirty &= R128_UPLOAD_CLIPRECTS;
}

static void r128DDPrintState( const char *msg, GLuint flags )
{
   fprintf( stderr,
	    "%s: (0x%x) %s%s%s%s%s%s%s%s\n",
	    msg,
	    flags,
	    (flags & R128_NEW_CONTEXT)	? "context, " : "",
	    (flags & R128_NEW_ALPHA)	? "alpha, " : "",
	    (flags & R128_NEW_DEPTH)	? "depth, " : "",
	    (flags & R128_NEW_FOG)	? "fog, " : "",
	    (flags & R128_NEW_CLIP)	? "clip, " : "",
	    (flags & R128_NEW_CULL)	? "cull, " : "",
	    (flags & R128_NEW_MASKS)	? "masks, " : "",
	    (flags & R128_NEW_WINDOW)	? "window, " : "" );
}

void r128DDUpdateHWState( struct gl_context *ctx )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   int new_state = rmesa->new_state;

   if ( new_state || rmesa->NewGLState & _NEW_TEXTURE )
   {
      FLUSH_BATCH( rmesa );

      rmesa->new_state = 0;

      if ( R128_DEBUG & DEBUG_VERBOSE_MSG )
	 r128DDPrintState( "r128UpdateHwState", new_state );

      /* Update the various parts of the context's state.
       */
      if ( new_state & R128_NEW_ALPHA )
	 r128UpdateAlphaMode( ctx );

      if ( new_state & R128_NEW_DEPTH )
	 r128UpdateZMode( ctx );

      if ( new_state & R128_NEW_FOG )
	 r128UpdateFogAttrib( ctx );

      if ( new_state & R128_NEW_CLIP )
	 r128UpdateClipping( ctx );

      if ( new_state & R128_NEW_CULL )
	 r128UpdateCull( ctx );

      if ( new_state & R128_NEW_MASKS )
	 r128UpdateMasks( ctx );

      if ( new_state & R128_NEW_WINDOW )
      {
	 r128UpdateWindow( ctx );
	 r128CalcViewport( ctx );
      }

      if ( rmesa->NewGLState & _NEW_TEXTURE ) {
	 r128UpdateTextureState( ctx );
      }
   }
}


static void r128DDInvalidateState( struct gl_context *ctx, GLuint new_state )
{
   _swrast_InvalidateState( ctx, new_state );
   _swsetup_InvalidateState( ctx, new_state );
   _vbo_InvalidateState( ctx, new_state );
   _tnl_InvalidateState( ctx, new_state );
   R128_CONTEXT(ctx)->NewGLState |= new_state;
}



/* Initialize the context's hardware state.
 */
void r128DDInitState( r128ContextPtr rmesa )
{
   int dst_bpp, depth_bpp;

   switch ( rmesa->r128Screen->cpp ) {
   case 2:
      dst_bpp = R128_GMC_DST_16BPP;
      break;
   case 4:
      dst_bpp = R128_GMC_DST_32BPP;
      break;
   default:
      fprintf( stderr, "Error: Unsupported pixel depth... exiting\n" );
      exit( -1 );
   }

   rmesa->ClearColor = 0x00000000;

   switch ( rmesa->glCtx->Visual.depthBits ) {
   case 16:
      rmesa->ClearDepth = 0x0000ffff;
      depth_bpp = R128_Z_PIX_WIDTH_16;
      rmesa->depth_scale = 1.0 / (GLfloat)0xffff;
      break;
   case 24:
      rmesa->ClearDepth = 0x00ffffff;
      depth_bpp = R128_Z_PIX_WIDTH_24;
      rmesa->depth_scale = 1.0 / (GLfloat)0xffffff;
      break;
   default:
      fprintf( stderr, "Error: Unsupported depth %d... exiting\n",
	       rmesa->glCtx->Visual.depthBits );
      exit( -1 );
   }

   rmesa->Fallback = 0;

   /* Hardware state:
    */
   rmesa->setup.dp_gui_master_cntl_c = (R128_GMC_DST_PITCH_OFFSET_CNTL |
					R128_GMC_DST_CLIPPING |
					R128_GMC_BRUSH_SOLID_COLOR |
					dst_bpp |
					R128_GMC_SRC_DATATYPE_COLOR |
					R128_GMC_BYTE_MSB_TO_LSB |
					R128_GMC_CONVERSION_TEMP_6500 |
					R128_ROP3_S |
					R128_DP_SRC_SOURCE_MEMORY |
					R128_GMC_3D_FCN_EN |
					R128_GMC_CLR_CMP_CNTL_DIS |
					R128_GMC_AUX_CLIP_DIS |
					R128_GMC_WR_MSK_DIS);

   rmesa->setup.sc_top_left_c     = 0x00000000;
   rmesa->setup.sc_bottom_right_c = 0x1fff1fff;

   rmesa->setup.z_offset_c = rmesa->r128Screen->depthOffset;
   rmesa->setup.z_pitch_c = ((rmesa->r128Screen->depthPitch >> 3) |
			     R128_Z_TILE);

   rmesa->setup.z_sten_cntl_c = (depth_bpp |
				 R128_Z_TEST_LESS |
				 R128_STENCIL_TEST_ALWAYS |
				 R128_STENCIL_S_FAIL_KEEP |
				 R128_STENCIL_ZPASS_KEEP |
				 R128_STENCIL_ZFAIL_KEEP);

   rmesa->setup.tex_cntl_c = (R128_Z_WRITE_ENABLE |
			      R128_SHADE_ENABLE |
			      R128_DITHER_ENABLE |
			      R128_ALPHA_IN_TEX_COMPLETE_A |
			      R128_LIGHT_DIS |
			      R128_ALPHA_LIGHT_DIS |
			      R128_TEX_CACHE_FLUSH |
			      (0x3f << R128_LOD_BIAS_SHIFT));

   rmesa->setup.misc_3d_state_cntl_reg = (R128_MISC_SCALE_3D_TEXMAP_SHADE |
					  R128_MISC_SCALE_PIX_REPLICATE |
					  R128_ALPHA_COMB_ADD_CLAMP |
					  R128_FOG_VERTEX |
					  (R128_ALPHA_BLEND_ONE << R128_ALPHA_BLEND_SRC_SHIFT) |
					  (R128_ALPHA_BLEND_ZERO << R128_ALPHA_BLEND_DST_SHIFT) |
					  R128_ALPHA_TEST_ALWAYS);

   rmesa->setup.texture_clr_cmp_clr_c = 0x00000000;
   rmesa->setup.texture_clr_cmp_msk_c = 0xffffffff;

   rmesa->setup.fog_color_c = 0x00000000;

   rmesa->setup.pm4_vc_fpu_setup = (R128_FRONT_DIR_CCW |
				    R128_BACKFACE_SOLID |
				    R128_FRONTFACE_SOLID |
				    R128_FPU_COLOR_GOURAUD |
				    R128_FPU_SUB_PIX_4BITS |
				    R128_FPU_MODE_3D |
				    R128_TRAP_BITS_DISABLE |
				    R128_XFACTOR_2 |
				    R128_YFACTOR_2 |
				    R128_FLAT_SHADE_VERTEX_OGL |
				    R128_FPU_ROUND_TRUNCATE |
				    R128_WM_SEL_8DW);

   rmesa->setup.setup_cntl = (R128_COLOR_GOURAUD |
			      R128_PRIM_TYPE_TRI |
			      R128_TEXTURE_ST_MULT_W |
			      R128_STARTING_VERTEX_1 |
			      R128_ENDING_VERTEX_3 |
			      R128_SU_POLY_LINE_NOT_LAST |
			      R128_SUB_PIX_4BITS);

   rmesa->setup.tex_size_pitch_c = 0x00000000;
   rmesa->setup.constant_color_c = 0x00ffffff;

   rmesa->setup.dp_write_mask   = 0xffffffff;
   rmesa->setup.sten_ref_mask_c = 0xffff0000;
   rmesa->setup.plane_3d_mask_c = 0xffffffff;

   rmesa->setup.window_xy_offset = 0x00000000;

   rmesa->setup.scale_3d_cntl = (R128_SCALE_DITHER_TABLE |
				 R128_TEX_CACHE_SIZE_FULL |
				 R128_DITHER_INIT_RESET |
				 R128_SCALE_3D_TEXMAP_SHADE |
				 R128_SCALE_PIX_REPLICATE |
				 R128_ALPHA_COMB_ADD_CLAMP |
				 R128_FOG_VERTEX |
				 (R128_ALPHA_BLEND_ONE << R128_ALPHA_BLEND_SRC_SHIFT) |
				 (R128_ALPHA_BLEND_ZERO << R128_ALPHA_BLEND_DST_SHIFT) |
				 R128_ALPHA_TEST_ALWAYS |
				 R128_COMPOSITE_SHADOW_CMP_EQUAL |
				 R128_TEX_MAP_ALPHA_IN_TEXTURE |
				 R128_TEX_CACHE_LINE_SIZE_4QW);

   rmesa->new_state = R128_NEW_ALL;
}

/* Initialize the driver's state functions.
 */
void r128DDInitStateFuncs( struct gl_context *ctx )
{
   ctx->Driver.UpdateState		= r128DDInvalidateState;

   ctx->Driver.ClearColor		= r128DDClearColor;
   ctx->Driver.ClearStencil		= r128DDClearStencil;
   ctx->Driver.DrawBuffer		= r128DDDrawBuffer;
   ctx->Driver.ReadBuffer		= r128DDReadBuffer;

   ctx->Driver.ColorMask		= r128DDColorMask;
   ctx->Driver.AlphaFunc		= r128DDAlphaFunc;
   ctx->Driver.BlendEquationSeparate	= r128DDBlendEquationSeparate;
   ctx->Driver.BlendFuncSeparate	= r128DDBlendFuncSeparate;
   ctx->Driver.ClearDepth		= r128DDClearDepth;
   ctx->Driver.CullFace			= r128DDCullFace;
   ctx->Driver.FrontFace		= r128DDFrontFace;
   ctx->Driver.DepthFunc		= r128DDDepthFunc;
   ctx->Driver.DepthMask		= r128DDDepthMask;
   ctx->Driver.Enable			= r128DDEnable;
   ctx->Driver.Fogfv			= r128DDFogfv;
   ctx->Driver.Hint			= NULL;
   ctx->Driver.Lightfv			= NULL;
   ctx->Driver.LightModelfv		= r128DDLightModelfv;
   ctx->Driver.LogicOpcode		= r128DDLogicOpCode;
   ctx->Driver.PolygonMode		= NULL;
   ctx->Driver.PolygonStipple		= r128DDPolygonStipple;
   ctx->Driver.RenderMode		= r128DDRenderMode;
   ctx->Driver.Scissor			= r128DDScissor;
   ctx->Driver.ShadeModel		= r128DDShadeModel;
   ctx->Driver.StencilFuncSeparate	= r128DDStencilFuncSeparate;
   ctx->Driver.StencilMaskSeparate	= r128DDStencilMaskSeparate;
   ctx->Driver.StencilOpSeparate	= r128DDStencilOpSeparate;

   ctx->Driver.DepthRange               = r128DepthRange;
   ctx->Driver.Viewport                 = r128Viewport;
}
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.5
log
@Merge Mesa 7.10.3
@
text
@d46 1
d182 1
a182 1
      a |= blend_factor( rmesa, ctx->Color.BlendSrcRGB, GL_TRUE ) 
d184 1
a184 1
      a |= blend_factor( rmesa, ctx->Color.BlendDstRGB, GL_FALSE ) 
d187 1
a187 1
      switch (ctx->Color.BlendEquationRGB) {
d740 1
a740 1
   if ( NEED_SECONDARY_COLOR( ctx ) ) {
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d45 1
d128 1
a128 1
static void r128UpdateAlphaMode( GLcontext *ctx )
d212 1
a212 1
static void r128DDAlphaFunc( GLcontext *ctx, GLenum func, GLfloat ref )
d220 1
a220 1
static void r128DDBlendEquationSeparate( GLcontext *ctx, 
d242 1
a242 1
static void r128DDBlendFuncSeparate( GLcontext *ctx,
d257 1
a257 1
r128DDStencilFuncSeparate( GLcontext *ctx, GLenum face, GLenum func,
d305 1
a305 1
r128DDStencilMaskSeparate( GLcontext *ctx, GLenum face, GLuint mask )
d318 1
a318 1
static void r128DDStencilOpSeparate( GLcontext *ctx, GLenum face, GLenum fail,
d417 1
a417 1
static void r128DDClearStencil( GLcontext *ctx, GLint s )
d431 1
a431 1
static void r128UpdateZMode( GLcontext *ctx )
d488 1
a488 1
static void r128DDDepthFunc( GLcontext *ctx, GLenum func )
d496 1
a496 1
static void r128DDDepthMask( GLcontext *ctx, GLboolean flag )
d504 1
a504 1
static void r128DDClearDepth( GLcontext *ctx, GLclampd d )
d527 1
a527 1
static void r128UpdateFogAttrib( GLcontext *ctx )
d556 1
a556 1
static void r128DDFogfv( GLcontext *ctx, GLenum pname, const GLfloat *param )
d569 1
a569 1
static void r128UpdateClipping( GLcontext *ctx )
d625 1
a625 1
static void r128DDScissor( GLcontext *ctx,
d639 1
a639 1
static void r128UpdateCull( GLcontext *ctx )
d678 1
a678 1
static void r128DDCullFace( GLcontext *ctx, GLenum mode )
d686 1
a686 1
static void r128DDFrontFace( GLcontext *ctx, GLenum mode )
d699 1
a699 1
static void r128UpdateMasks( GLcontext *ctx )
d715 1
a715 1
static void r128DDColorMask( GLcontext *ctx,
d734 1
a734 1
static void updateSpecularLighting( GLcontext *ctx )
d764 1
a764 1
static void r128DDLightModelfv( GLcontext *ctx, GLenum pname,
d780 1
a780 1
static void r128DDShadeModel( GLcontext *ctx, GLenum mode )
d814 1
a814 1
static void r128UpdateWindow( GLcontext *ctx )
d837 1
a837 1
static void r128CalcViewport( GLcontext *ctx )
d853 1
a853 1
static void r128Viewport( GLcontext *ctx,
d860 1
a860 1
static void r128DepthRange( GLcontext *ctx,
d871 1
a871 1
static void r128DDClearColor( GLcontext *ctx,
d886 1
a886 1
static void r128DDLogicOpCode( GLcontext *ctx, GLenum opcode )
d897 1
a897 1
static void r128DDDrawBuffer( GLcontext *ctx, GLenum mode )
d924 1
a924 1
static void r128DDReadBuffer( GLcontext *ctx, GLenum mode )
d934 1
a934 1
static void r128DDPolygonStipple( GLcontext *ctx, const GLubyte *mask )
d965 1
a965 1
static void r128DDRenderMode( GLcontext *ctx, GLenum mode )
d977 1
a977 1
static void r128DDEnable( GLcontext *ctx, GLenum cap, GLboolean state )
d1209 1
a1209 1
void r128DDUpdateHWState( GLcontext *ctx )
d1256 1
a1256 1
static void r128DDInvalidateState( GLcontext *ctx, GLuint new_state )
d1407 1
a1407 1
void r128DDInitStateFuncs( GLcontext *ctx )
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a49 2
#include "tnl/t_pipeline.h"

d573 1
a573 1
      __DRIdrawablePrivate *drawable = rmesa->driDrawable;
d703 4
a706 4
				ctx->Color.ColorMask[RCOMP],
				ctx->Color.ColorMask[GCOMP],
				ctx->Color.ColorMask[BCOMP],
				ctx->Color.ColorMask[ACOMP] );
d772 5
a1409 1
   ctx->Driver.ClearIndex		= NULL;
a1414 1
   ctx->Driver.IndexMask		= NULL;
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a0 1
/* $XFree86: xc/lib/GL/mesa/src/drv/r128/r128_state.c,v 1.11 2002/10/30 12:51:39 alanh Exp $ */
d42 3
a44 3
#include "context.h"
#include "enums.h"
#include "colormac.h"
@


1.1
log
@Initial revision
@
text
@d47 1
a47 1
#include "array_cache/acache.h"
d816 1
a816 1
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0][0];
d900 1
a900 9
   /*
    * _ColorDrawBufferMask is easier to cope with than <mode>.
    */
   switch ( ctx->DrawBuffer->_ColorDrawBufferMask[0] ) {
   case BUFFER_BIT_FRONT_LEFT:
   case BUFFER_BIT_BACK_LEFT:
      FALLBACK( rmesa, R128_FALLBACK_DRAW_BUFFER, GL_FALSE );
      break;
   default:
d903 13
a915 1
      break;
d1257 1
a1257 1
   _ac_InvalidateState( ctx, new_state );
a1440 15

   /* Pixel path fallbacks.
    */
   ctx->Driver.Accum = _swrast_Accum;
   ctx->Driver.Bitmap = _swrast_Bitmap;
   ctx->Driver.CopyPixels = _swrast_CopyPixels;
   ctx->Driver.DrawPixels = _swrast_DrawPixels;
   ctx->Driver.ReadPixels = _swrast_ReadPixels;

   /* Swrast hooks for imaging extensions:
    */
   ctx->Driver.CopyColorTable = _swrast_CopyColorTable;
   ctx->Driver.CopyColorSubTable = _swrast_CopyColorSubTable;
   ctx->Driver.CopyConvolutionFilter1D = _swrast_CopyConvolutionFilter1D;
   ctx->Driver.CopyConvolutionFilter2D = _swrast_CopyConvolutionFilter2D;
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d1437 15
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d47 1
a47 1
#include "vbo/vbo.h"
d1253 1
a1253 1
   _vbo_InvalidateState( ctx, new_state );
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d1 1
d43 3
a45 4
#include "main/context.h"
#include "main/enums.h"
#include "main/colormac.h"
#include "main/macros.h"
d51 2
d130 1
a130 1
static void r128UpdateAlphaMode( struct gl_context *ctx )
d214 1
a214 1
static void r128DDAlphaFunc( struct gl_context *ctx, GLenum func, GLfloat ref )
d222 1
a222 1
static void r128DDBlendEquationSeparate( struct gl_context *ctx, 
d244 1
a244 1
static void r128DDBlendFuncSeparate( struct gl_context *ctx,
d259 1
a259 1
r128DDStencilFuncSeparate( struct gl_context *ctx, GLenum face, GLenum func,
d307 1
a307 1
r128DDStencilMaskSeparate( struct gl_context *ctx, GLenum face, GLuint mask )
d320 1
a320 1
static void r128DDStencilOpSeparate( struct gl_context *ctx, GLenum face, GLenum fail,
d419 1
a419 1
static void r128DDClearStencil( struct gl_context *ctx, GLint s )
d433 1
a433 1
static void r128UpdateZMode( struct gl_context *ctx )
d490 1
a490 1
static void r128DDDepthFunc( struct gl_context *ctx, GLenum func )
d498 1
a498 1
static void r128DDDepthMask( struct gl_context *ctx, GLboolean flag )
d506 1
a506 1
static void r128DDClearDepth( struct gl_context *ctx, GLclampd d )
d529 1
a529 1
static void r128UpdateFogAttrib( struct gl_context *ctx )
d558 1
a558 1
static void r128DDFogfv( struct gl_context *ctx, GLenum pname, const GLfloat *param )
d571 1
a571 1
static void r128UpdateClipping( struct gl_context *ctx )
d576 1
a576 1
      __DRIdrawable *drawable = rmesa->driDrawable;
d627 1
a627 1
static void r128DDScissor( struct gl_context *ctx,
d641 1
a641 1
static void r128UpdateCull( struct gl_context *ctx )
d680 1
a680 1
static void r128DDCullFace( struct gl_context *ctx, GLenum mode )
d688 1
a688 1
static void r128DDFrontFace( struct gl_context *ctx, GLenum mode )
d701 1
a701 1
static void r128UpdateMasks( struct gl_context *ctx )
d706 4
a709 4
				ctx->Color.ColorMask[0][RCOMP],
				ctx->Color.ColorMask[0][GCOMP],
				ctx->Color.ColorMask[0][BCOMP],
				ctx->Color.ColorMask[0][ACOMP] );
d717 1
a717 1
static void r128DDColorMask( struct gl_context *ctx,
d736 1
a736 1
static void updateSpecularLighting( struct gl_context *ctx )
d766 1
a766 1
static void r128DDLightModelfv( struct gl_context *ctx, GLenum pname,
a774 5

   if ( pname == GL_LIGHT_MODEL_TWO_SIDE ) {
      FLUSH_BATCH( rmesa );
      r128ChooseRenderState( ctx );
   }
d777 1
a777 1
static void r128DDShadeModel( struct gl_context *ctx, GLenum mode )
d811 1
a811 1
static void r128UpdateWindow( struct gl_context *ctx )
d816 1
a816 1
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0];
d834 1
a834 1
static void r128CalcViewport( struct gl_context *ctx )
d850 1
a850 1
static void r128Viewport( struct gl_context *ctx,
d857 1
a857 1
static void r128DepthRange( struct gl_context *ctx,
d868 1
a868 1
static void r128DDClearColor( struct gl_context *ctx,
d883 1
a883 1
static void r128DDLogicOpCode( struct gl_context *ctx, GLenum opcode )
d894 1
a894 1
static void r128DDDrawBuffer( struct gl_context *ctx, GLenum mode )
d900 9
a908 1
   if (ctx->DrawBuffer->_NumColorDrawBuffers != 1) {
d911 1
a911 13
      return;
   }
   else {
      switch ( ctx->DrawBuffer->_ColorDrawBufferIndexes[0] ) {
      case BUFFER_FRONT_LEFT:
      case BUFFER_BACK_LEFT:
         FALLBACK( rmesa, R128_FALLBACK_DRAW_BUFFER, GL_FALSE );
         break;
      default:
         /* GL_NONE or GL_FRONT_AND_BACK or stereo left&right, etc */
         FALLBACK( rmesa, R128_FALLBACK_DRAW_BUFFER, GL_TRUE );
         break;
      }
d917 1
a917 1
static void r128DDReadBuffer( struct gl_context *ctx, GLenum mode )
d927 1
a927 1
static void r128DDPolygonStipple( struct gl_context *ctx, const GLubyte *mask )
d958 1
a958 1
static void r128DDRenderMode( struct gl_context *ctx, GLenum mode )
d970 1
a970 1
static void r128DDEnable( struct gl_context *ctx, GLenum cap, GLboolean state )
d1202 1
a1202 1
void r128DDUpdateHWState( struct gl_context *ctx )
d1249 1
a1249 1
static void r128DDInvalidateState( struct gl_context *ctx, GLuint new_state )
d1400 1
a1400 1
void r128DDInitStateFuncs( struct gl_context *ctx )
d1404 1
d1410 1
@


