head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.21;	author jsg;	state dead;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.04.23;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.15;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.49;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.49;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.37;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.15.42;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.52;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics to
 develop this 3D driver.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */


#include "brw_context.h"
#include "brw_state.h"
#include "brw_defines.h"
#include "intel_mipmap_tree.h"

#include "main/macros.h"
#include "main/samplerobj.h"


/* Samplers aren't strictly wm state from the hardware's perspective,
 * but that is the only situation in which we use them in this driver.
 */



uint32_t
translate_wrap_mode(struct brw_context *brw, GLenum wrap, bool using_nearest)
{
   switch( wrap ) {
   case GL_REPEAT:
      return BRW_TEXCOORDMODE_WRAP;
   case GL_CLAMP:
      /* GL_CLAMP is the weird mode where coordinates are clamped to
       * [0.0, 1.0], so linear filtering of coordinates outside of
       * [0.0, 1.0] give you half edge texel value and half border
       * color.
       *
       * Gen8+ supports this natively.
       */
      if (brw->gen >= 8)
         return GEN8_TEXCOORDMODE_HALF_BORDER;

      /* On Gen4-7.5, we clamp the coordinates in the fragment shader
       * and set clamp_border here, which gets the result desired.
       * We just use clamp(_to_edge) for nearest, because for nearest
       * clamping to 1.0 gives border color instead of the desired
       * edge texels.
       */
      if (using_nearest)
	 return BRW_TEXCOORDMODE_CLAMP;
      else
	 return BRW_TEXCOORDMODE_CLAMP_BORDER;
   case GL_CLAMP_TO_EDGE:
      return BRW_TEXCOORDMODE_CLAMP;
   case GL_CLAMP_TO_BORDER:
      return BRW_TEXCOORDMODE_CLAMP_BORDER;
   case GL_MIRRORED_REPEAT:
      return BRW_TEXCOORDMODE_MIRROR;
   case GL_MIRROR_CLAMP_TO_EDGE:
      return BRW_TEXCOORDMODE_MIRROR_ONCE;
   default:
      return BRW_TEXCOORDMODE_WRAP;
   }
}

/**
 * Upload SAMPLER_BORDER_COLOR_STATE.
 */
void
upload_default_color(struct brw_context *brw,
                     struct gl_sampler_object *sampler,
                     int unit,
                     uint32_t *sdc_offset)
{
   struct gl_context *ctx = &brw->ctx;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *texObj = texUnit->_Current;
   struct gl_texture_image *firstImage = texObj->Image[0][texObj->BaseLevel];
   float color[4];

   switch (firstImage->_BaseFormat) {
   case GL_DEPTH_COMPONENT:
      /* GL specs that border color for depth textures is taken from the
       * R channel, while the hardware uses A.  Spam R into all the
       * channels for safety.
       */
      color[0] = sampler->BorderColor.f[0];
      color[1] = sampler->BorderColor.f[0];
      color[2] = sampler->BorderColor.f[0];
      color[3] = sampler->BorderColor.f[0];
      break;
   case GL_ALPHA:
      color[0] = 0.0;
      color[1] = 0.0;
      color[2] = 0.0;
      color[3] = sampler->BorderColor.f[3];
      break;
   case GL_INTENSITY:
      color[0] = sampler->BorderColor.f[0];
      color[1] = sampler->BorderColor.f[0];
      color[2] = sampler->BorderColor.f[0];
      color[3] = sampler->BorderColor.f[0];
      break;
   case GL_LUMINANCE:
      color[0] = sampler->BorderColor.f[0];
      color[1] = sampler->BorderColor.f[0];
      color[2] = sampler->BorderColor.f[0];
      color[3] = 1.0;
      break;
   case GL_LUMINANCE_ALPHA:
      color[0] = sampler->BorderColor.f[0];
      color[1] = sampler->BorderColor.f[0];
      color[2] = sampler->BorderColor.f[0];
      color[3] = sampler->BorderColor.f[3];
      break;
   default:
      color[0] = sampler->BorderColor.f[0];
      color[1] = sampler->BorderColor.f[1];
      color[2] = sampler->BorderColor.f[2];
      color[3] = sampler->BorderColor.f[3];
      break;
   }

   /* In some cases we use an RGBA surface format for GL RGB textures,
    * where we've initialized the A channel to 1.0.  We also have to set
    * the border color alpha to 1.0 in that case.
    */
   if (firstImage->_BaseFormat == GL_RGB)
      color[3] = 1.0;

   if (brw->gen >= 8) {
      /* On Broadwell, the border color is represented as four 32-bit floats,
       * integers, or unsigned values, interpreted according to the surface
       * format.  This matches the sampler->BorderColor union exactly.  Since
       * we use floats both here and in the above reswizzling code, we preserve
       * the original bit pattern.  So we actually handle all three formats.
       */
      float *sdc = brw_state_batch(brw, AUB_TRACE_SAMPLER_DEFAULT_COLOR,
                                   4 * 4, 64, sdc_offset);
      COPY_4FV(sdc, color);
   } else if (brw->gen == 5 || brw->gen == 6) {
      struct gen5_sampler_default_color *sdc;

      sdc = brw_state_batch(brw, AUB_TRACE_SAMPLER_DEFAULT_COLOR,
			    sizeof(*sdc), 32, sdc_offset);

      memset(sdc, 0, sizeof(*sdc));

      UNCLAMPED_FLOAT_TO_UBYTE(sdc->ub[0], color[0]);
      UNCLAMPED_FLOAT_TO_UBYTE(sdc->ub[1], color[1]);
      UNCLAMPED_FLOAT_TO_UBYTE(sdc->ub[2], color[2]);
      UNCLAMPED_FLOAT_TO_UBYTE(sdc->ub[3], color[3]);

      UNCLAMPED_FLOAT_TO_USHORT(sdc->us[0], color[0]);
      UNCLAMPED_FLOAT_TO_USHORT(sdc->us[1], color[1]);
      UNCLAMPED_FLOAT_TO_USHORT(sdc->us[2], color[2]);
      UNCLAMPED_FLOAT_TO_USHORT(sdc->us[3], color[3]);

      UNCLAMPED_FLOAT_TO_SHORT(sdc->s[0], color[0]);
      UNCLAMPED_FLOAT_TO_SHORT(sdc->s[1], color[1]);
      UNCLAMPED_FLOAT_TO_SHORT(sdc->s[2], color[2]);
      UNCLAMPED_FLOAT_TO_SHORT(sdc->s[3], color[3]);

      sdc->hf[0] = _mesa_float_to_half(color[0]);
      sdc->hf[1] = _mesa_float_to_half(color[1]);
      sdc->hf[2] = _mesa_float_to_half(color[2]);
      sdc->hf[3] = _mesa_float_to_half(color[3]);

      sdc->b[0] = sdc->s[0] >> 8;
      sdc->b[1] = sdc->s[1] >> 8;
      sdc->b[2] = sdc->s[2] >> 8;
      sdc->b[3] = sdc->s[3] >> 8;

      sdc->f[0] = color[0];
      sdc->f[1] = color[1];
      sdc->f[2] = color[2];
      sdc->f[3] = color[3];
   } else {
      struct brw_sampler_default_color *sdc;

      sdc = brw_state_batch(brw, AUB_TRACE_SAMPLER_DEFAULT_COLOR,
			    sizeof(*sdc), 32, sdc_offset);

      COPY_4V(sdc->color, color);
   }
}

/**
 * Sets the sampler state for a single unit based off of the sampler key
 * entry.
 */
static void brw_update_sampler_state(struct brw_context *brw,
				     int unit,
                                     int ss_index,
                                     struct brw_sampler_state *sampler,
                                     uint32_t sampler_state_table_offset,
                                     uint32_t *sdc_offset)
{
   struct gl_context *ctx = &brw->ctx;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *texObj = texUnit->_Current;
   struct gl_sampler_object *gl_sampler = _mesa_get_samplerobj(ctx, unit);
   bool using_nearest = false;

   /* These don't use samplers at all. */
   if (texObj->Target == GL_TEXTURE_BUFFER)
      return;

   switch (gl_sampler->MinFilter) {
   case GL_NEAREST:
      sampler->ss0.min_filter = BRW_MAPFILTER_NEAREST;
      sampler->ss0.mip_filter = BRW_MIPFILTER_NONE;
      using_nearest = true;
      break;
   case GL_LINEAR:
      sampler->ss0.min_filter = BRW_MAPFILTER_LINEAR;
      sampler->ss0.mip_filter = BRW_MIPFILTER_NONE;
      break;
   case GL_NEAREST_MIPMAP_NEAREST:
      sampler->ss0.min_filter = BRW_MAPFILTER_NEAREST;
      sampler->ss0.mip_filter = BRW_MIPFILTER_NEAREST;
      break;
   case GL_LINEAR_MIPMAP_NEAREST:
      sampler->ss0.min_filter = BRW_MAPFILTER_LINEAR;
      sampler->ss0.mip_filter = BRW_MIPFILTER_NEAREST;
      break;
   case GL_NEAREST_MIPMAP_LINEAR:
      sampler->ss0.min_filter = BRW_MAPFILTER_NEAREST;
      sampler->ss0.mip_filter = BRW_MIPFILTER_LINEAR;
      break;
   case GL_LINEAR_MIPMAP_LINEAR:
      sampler->ss0.min_filter = BRW_MAPFILTER_LINEAR;
      sampler->ss0.mip_filter = BRW_MIPFILTER_LINEAR;
      break;
   default:
      break;
   }

   /* Set Anisotropy:
    */
   if (gl_sampler->MaxAnisotropy > 1.0) {
      sampler->ss0.min_filter = BRW_MAPFILTER_ANISOTROPIC;
      sampler->ss0.mag_filter = BRW_MAPFILTER_ANISOTROPIC;

      if (gl_sampler->MaxAnisotropy > 2.0) {
	 sampler->ss3.max_aniso = MIN2((gl_sampler->MaxAnisotropy - 2) / 2,
				       BRW_ANISORATIO_16);
      }
   }
   else {
      switch (gl_sampler->MagFilter) {
      case GL_NEAREST:
	 sampler->ss0.mag_filter = BRW_MAPFILTER_NEAREST;
	 using_nearest = true;
	 break;
      case GL_LINEAR:
	 sampler->ss0.mag_filter = BRW_MAPFILTER_LINEAR;
	 break;
      default:
	 break;
      }
   }

   sampler->ss1.r_wrap_mode = translate_wrap_mode(brw, gl_sampler->WrapR,
						  using_nearest);
   sampler->ss1.s_wrap_mode = translate_wrap_mode(brw, gl_sampler->WrapS,
						  using_nearest);
   sampler->ss1.t_wrap_mode = translate_wrap_mode(brw, gl_sampler->WrapT,
						  using_nearest);

   if (brw->gen >= 6 &&
       sampler->ss0.min_filter != sampler->ss0.mag_filter)
	sampler->ss0.min_mag_neq = 1;

   /* Cube-maps on 965 and later must use the same wrap mode for all 3
    * coordinate dimensions.  Futher, only CUBE and CLAMP are valid.
    */
   if (texObj->Target == GL_TEXTURE_CUBE_MAP ||
       texObj->Target == GL_TEXTURE_CUBE_MAP_ARRAY) {
      if ((ctx->Texture.CubeMapSeamless || gl_sampler->CubeMapSeamless) &&
	  (gl_sampler->MinFilter != GL_NEAREST ||
	   gl_sampler->MagFilter != GL_NEAREST)) {
	 sampler->ss1.r_wrap_mode = BRW_TEXCOORDMODE_CUBE;
	 sampler->ss1.s_wrap_mode = BRW_TEXCOORDMODE_CUBE;
	 sampler->ss1.t_wrap_mode = BRW_TEXCOORDMODE_CUBE;
      } else {
	 sampler->ss1.r_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	 sampler->ss1.s_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	 sampler->ss1.t_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
      }
   } else if (texObj->Target == GL_TEXTURE_1D) {
      /* There's a bug in 1D texture sampling - it actually pays
       * attention to the wrap_t value, though it should not.
       * Override the wrap_t value here to GL_REPEAT to keep
       * any nonexistent border pixels from floating in.
       */
      sampler->ss1.t_wrap_mode = BRW_TEXCOORDMODE_WRAP;
   }


   /* Set shadow function:
    */
   if (gl_sampler->CompareMode == GL_COMPARE_R_TO_TEXTURE_ARB) {
      /* Shadowing is "enabled" by emitting a particular sampler
       * message (sample_c).  So need to recompile WM program when
       * shadow comparison is enabled on each/any texture unit.
       */
      sampler->ss0.shadow_function =
	 intel_translate_shadow_compare_func(gl_sampler->CompareFunc);
   }

   /* Set LOD bias:
    */
   sampler->ss0.lod_bias = S_FIXED(CLAMP(texUnit->LodBias +
					 gl_sampler->LodBias, -16, 15), 6);

   sampler->ss0.lod_preclamp = 1; /* OpenGL mode */
   sampler->ss0.default_color_mode = 0; /* OpenGL/DX10 mode */

   sampler->ss0.base_level = U_FIXED(0, 1);

   sampler->ss1.max_lod = U_FIXED(CLAMP(gl_sampler->MaxLod, 0, 13), 6);
   sampler->ss1.min_lod = U_FIXED(CLAMP(gl_sampler->MinLod, 0, 13), 6);

   /* On Gen6+, the sampler can handle non-normalized texture
    * rectangle coordinates natively
    */
   if (brw->gen >= 6 && texObj->Target == GL_TEXTURE_RECTANGLE) {
      sampler->ss3.non_normalized_coord = 1;
   }

   upload_default_color(brw, gl_sampler, unit, sdc_offset);

   if (brw->gen >= 6) {
      sampler->ss2.default_color_pointer = *sdc_offset >> 5;
   } else {
      /* reloc */
      sampler->ss2.default_color_pointer = (brw->batch.bo->offset64 +
					    *sdc_offset) >> 5;

      drm_intel_bo_emit_reloc(brw->batch.bo,
			      sampler_state_table_offset +
			      ss_index * sizeof(struct brw_sampler_state) +
			      offsetof(struct brw_sampler_state, ss2),
			      brw->batch.bo, *sdc_offset,
			      I915_GEM_DOMAIN_SAMPLER, 0);
   }

   if (sampler->ss0.min_filter != BRW_MAPFILTER_NEAREST)
      sampler->ss3.address_round |= BRW_ADDRESS_ROUNDING_ENABLE_U_MIN |
                                    BRW_ADDRESS_ROUNDING_ENABLE_V_MIN |
                                    BRW_ADDRESS_ROUNDING_ENABLE_R_MIN;
   if (sampler->ss0.mag_filter != BRW_MAPFILTER_NEAREST)
      sampler->ss3.address_round |= BRW_ADDRESS_ROUNDING_ENABLE_U_MAG |
                                    BRW_ADDRESS_ROUNDING_ENABLE_V_MAG |
                                    BRW_ADDRESS_ROUNDING_ENABLE_R_MAG;
}


static void
brw_upload_sampler_state_table(struct brw_context *brw,
                               struct gl_program *prog,
                               struct brw_stage_state *stage_state)
{
   struct gl_context *ctx = &brw->ctx;
   struct brw_sampler_state *samplers;
   uint32_t sampler_count = stage_state->sampler_count;

   GLbitfield SamplersUsed = prog->SamplersUsed;

   if (sampler_count == 0)
      return;

   samplers = brw_state_batch(brw, AUB_TRACE_SAMPLER_STATE,
			      sampler_count * sizeof(*samplers),
			      32, &stage_state->sampler_offset);
   memset(samplers, 0, sampler_count * sizeof(*samplers));

   for (unsigned s = 0; s < sampler_count; s++) {
      if (SamplersUsed & (1 << s)) {
         const unsigned unit = prog->SamplerUnits[s];
         if (ctx->Texture.Unit[unit]._Current)
            brw_update_sampler_state(brw, unit, s, &samplers[s],
                                     stage_state->sampler_offset,
                                     &stage_state->sdc_offset[s]);
      }
   }

   brw->state.dirty.cache |= CACHE_NEW_SAMPLER;
}

static void
brw_upload_fs_samplers(struct brw_context *brw)
{
   /* BRW_NEW_FRAGMENT_PROGRAM */
   struct gl_program *fs = (struct gl_program *) brw->fragment_program;
   brw->vtbl.upload_sampler_state_table(brw, fs, &brw->wm.base);
}

const struct brw_tracked_state brw_fs_samplers = {
   .dirty = {
      .mesa = _NEW_TEXTURE,
      .brw = BRW_NEW_BATCH |
             BRW_NEW_FRAGMENT_PROGRAM,
      .cache = 0
   },
   .emit = brw_upload_fs_samplers,
};

static void
brw_upload_vs_samplers(struct brw_context *brw)
{
   /* BRW_NEW_VERTEX_PROGRAM */
   struct gl_program *vs = (struct gl_program *) brw->vertex_program;
   brw->vtbl.upload_sampler_state_table(brw, vs, &brw->vs.base);
}


const struct brw_tracked_state brw_vs_samplers = {
   .dirty = {
      .mesa = _NEW_TEXTURE,
      .brw = BRW_NEW_BATCH |
             BRW_NEW_VERTEX_PROGRAM,
      .cache = 0
   },
   .emit = brw_upload_vs_samplers,
};


static void
brw_upload_gs_samplers(struct brw_context *brw)
{
   /* BRW_NEW_GEOMETRY_PROGRAM */
   struct gl_program *gs = (struct gl_program *) brw->geometry_program;
   if (!gs)
      return;

   brw->vtbl.upload_sampler_state_table(brw, gs, &brw->gs.base);
}


const struct brw_tracked_state brw_gs_samplers = {
   .dirty = {
      .mesa = _NEW_TEXTURE,
      .brw = BRW_NEW_BATCH |
             BRW_NEW_GEOMETRY_PROGRAM,
      .cache = 0
   },
   .emit = brw_upload_gs_samplers,
};


void
gen4_init_vtable_sampler_functions(struct brw_context *brw)
{
   brw->vtbl.upload_sampler_state_table = brw_upload_sampler_state_table;
}
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.8
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
d5 1
a5 1
 
d13 1
a13 1
 
d17 1
a17 1
 
d25 1
a25 1
 
d29 1
a29 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d31 1
a31 1
                   
d36 1
d49 1
a49 1
translate_wrap_mode(GLenum wrap, bool using_nearest)
d52 1
a52 1
   case GL_REPEAT: 
d58 10
a67 3
       * color.  The fragment shader will clamp the coordinates, and
       * we set clamp_border here, which gets the result desired.  We
       * just use clamp(_to_edge) for nearest, because for nearest
d75 1
a75 1
   case GL_CLAMP_TO_EDGE: 
d77 1
a77 1
   case GL_CLAMP_TO_BORDER: 
d79 1
a79 1
   case GL_MIRRORED_REPEAT: 
d81 3
a83 1
   default: 
d92 4
a95 2
upload_default_color(struct brw_context *brw, struct gl_sampler_object *sampler,
		     int unit, int ss_index)
d153 11
a163 1
   if (brw->gen == 5 || brw->gen == 6) {
d167 1
a167 1
			    sizeof(*sdc), 32, &brw->wm.sdc_offset[ss_index]);
d204 1
a204 1
			    sizeof(*sdc), 32, &brw->wm.sdc_offset[ss_index]);
d217 3
a219 1
				     struct brw_sampler_state *sampler)
d261 1
a261 1
   /* Set Anisotropy: 
d264 1
a264 1
      sampler->ss0.min_filter = BRW_MAPFILTER_ANISOTROPIC; 
d283 1
a283 1
      }  
d286 1
a286 1
   sampler->ss1.r_wrap_mode = translate_wrap_mode(gl_sampler->WrapR,
d288 1
a288 1
   sampler->ss1.s_wrap_mode = translate_wrap_mode(gl_sampler->WrapS,
d290 1
a290 1
   sampler->ss1.t_wrap_mode = translate_wrap_mode(gl_sampler->WrapT,
d302 1
a302 1
      if (ctx->Texture.CubeMapSeamless &&
d323 1
a323 1
   /* Set shadow function: 
d334 1
a334 1
   /* Set LOD bias: 
a341 7
   /* Set BaseMipLevel, MaxLOD, MinLOD: 
    *
    * XXX: I don't think that using firstLevel, lastLevel works,
    * because we always setup the surface state as if firstLevel ==
    * level zero.  Probably have to subtract firstLevel from each of
    * these:
    */
d354 1
a354 1
   upload_default_color(brw, gl_sampler, unit, ss_index);
d357 1
a357 1
      sampler->ss2.default_color_pointer = brw->wm.sdc_offset[ss_index] >> 5;
d360 2
a361 2
      sampler->ss2.default_color_pointer = (brw->batch.bo->offset +
					    brw->wm.sdc_offset[ss_index]) >> 5;
d364 1
a364 1
			      brw->sampler.offset +
d367 1
a367 1
			      brw->batch.bo, brw->wm.sdc_offset[ss_index],
d383 3
a385 1
brw_upload_samplers(struct brw_context *brw)
d389 1
d391 1
a391 10
   /* BRW_NEW_VERTEX_PROGRAM and BRW_NEW_FRAGMENT_PROGRAM */
   struct gl_program *vs = (struct gl_program *) brw->vertex_program;
   struct gl_program *fs = (struct gl_program *) brw->fragment_program;

   GLbitfield SamplersUsed = vs->SamplersUsed | fs->SamplersUsed;

   /* ARB programs use the texture unit number as the sampler index, so we
    * need to find the highest unit used.  A bit-count will not work.
    */
   brw->sampler.count = _mesa_fls(SamplersUsed);
d393 1
a393 1
   if (brw->sampler.count == 0)
d397 3
a399 3
			      brw->sampler.count * sizeof(*samplers),
			      32, &brw->sampler.offset);
   memset(samplers, 0, brw->sampler.count * sizeof(*samplers));
d401 1
a401 1
   for (unsigned s = 0; s < brw->sampler.count; s++) {
d403 5
a407 4
         const unsigned unit = (fs->SamplersUsed & (1 << s)) ?
            fs->SamplerUnits[s] : vs->SamplerUnits[s];
         if (ctx->Texture.Unit[unit]._ReallyEnabled)
            brw_update_sampler_state(brw, unit, s, &samplers[s]);
d414 9
a422 1
const struct brw_tracked_state brw_samplers = {
a425 1
             BRW_NEW_VERTEX_PROGRAM |
d429 43
a471 1
   .emit = brw_upload_samplers,
d475 5
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d83 1
a83 1
		     int unit)
d85 1
a85 2
   struct intel_context *intel = &brw->intel;
   struct gl_context *ctx = &intel->ctx;
d91 2
a92 1
   if (firstImage->_BaseFormat == GL_DEPTH_COMPONENT) {
d101 26
a126 1
   } else {
d131 1
d134 8
a141 1
   if (intel->gen == 5 || intel->gen == 6) {
d144 2
a145 1
      sdc = brw_state_batch(brw, sizeof(*sdc), 32, &brw->wm.sdc_offset[unit]);
d181 2
a182 1
      sdc = brw_state_batch(brw, sizeof(*sdc), 32, &brw->wm.sdc_offset[unit]);
d194 1
d197 1
a197 2
   struct intel_context *intel = &brw->intel;
   struct gl_context *ctx = &intel->ctx;
d203 4
d269 1
a269 1
   if (intel->gen >= 6 &&
d276 2
a277 1
   if (texObj->Target == GL_TEXTURE_CUBE_MAP) {
d330 8
a337 1
   upload_default_color(brw, gl_sampler, unit);
d339 2
a340 2
   if (intel->gen >= 6) {
      sampler->ss2.default_color_pointer = brw->wm.sdc_offset[unit] >> 5;
d343 2
a344 2
      sampler->ss2.default_color_pointer = (intel->batch.bo->offset +
					    brw->wm.sdc_offset[unit]) >> 5;
d346 3
a348 3
      drm_intel_bo_emit_reloc(intel->batch.bo,
			      brw->wm.sampler_offset +
			      unit * sizeof(struct brw_sampler_state) +
d350 1
a350 1
			      intel->batch.bo, brw->wm.sdc_offset[unit],
a364 4
/* All samplers must be uploaded in a single contiguous array, which
 * complicates various things.  However, this is still too confusing -
 * FIXME: simplify all the different new texture state flags.
 */
d366 1
a366 1
prepare_wm_samplers(struct brw_context *brw)
d368 1
a368 1
   struct gl_context *ctx = &brw->intel.ctx;
a369 1
   int i;
d371 10
a380 5
   brw->wm.sampler_count = 0;
   for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
      if (ctx->Texture.Unit[i]._ReallyEnabled)
	 brw->wm.sampler_count = i + 1;
   }
d382 1
a382 1
   if (brw->wm.sampler_count == 0)
d385 12
a396 7
   samplers = brw_state_batch(brw, brw->wm.sampler_count * sizeof(*samplers),
			      32, &brw->wm.sampler_offset);
   memset(samplers, 0, brw->wm.sampler_count * sizeof(*samplers));

   for (i = 0; i < brw->wm.sampler_count; i++) {
      if (ctx->Texture.Unit[i]._ReallyEnabled)
	 brw_update_sampler_state(brw, i, &samplers[i]);
d402 1
a402 1
const struct brw_tracked_state brw_wm_samplers = {
d405 3
a407 1
      .brw = BRW_NEW_BATCH,
d410 1
a410 1
   .prepare = prepare_wm_samplers,
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d38 1
a38 1

d47 2
a48 5
/* The brw (and related graphics cores) do not support GL_CLAMP.  The
 * Intel drivers for "other operating systems" implement GL_CLAMP as
 * GL_CLAMP_TO_EDGE, so the same is done here.
 */
static GLuint translate_wrap_mode( GLenum wrap )
d53 15
a67 1
   case GL_CLAMP:  
a68 2
   case GL_CLAMP_TO_EDGE: 
      return BRW_TEXCOORDMODE_CLAMP; /* conform likes it this way */
d78 6
a83 2
static drm_intel_bo *upload_default_color( struct brw_context *brw,
				     const GLfloat *color )
d86 21
d108 2
a109 2
   if (intel->gen >= 5) {
      struct gen5_sampler_default_color sdc;
d111 1
a111 1
      memset(&sdc, 0, sizeof(sdc));
d113 1
a113 4
      UNCLAMPED_FLOAT_TO_UBYTE(sdc.ub[0], color[0]);
      UNCLAMPED_FLOAT_TO_UBYTE(sdc.ub[1], color[1]);
      UNCLAMPED_FLOAT_TO_UBYTE(sdc.ub[2], color[2]);
      UNCLAMPED_FLOAT_TO_UBYTE(sdc.ub[3], color[3]);
d115 29
a143 17
      UNCLAMPED_FLOAT_TO_USHORT(sdc.us[0], color[0]);
      UNCLAMPED_FLOAT_TO_USHORT(sdc.us[1], color[1]);
      UNCLAMPED_FLOAT_TO_USHORT(sdc.us[2], color[2]);
      UNCLAMPED_FLOAT_TO_USHORT(sdc.us[3], color[3]);

      UNCLAMPED_FLOAT_TO_SHORT(sdc.s[0], color[0]);
      UNCLAMPED_FLOAT_TO_SHORT(sdc.s[1], color[1]);
      UNCLAMPED_FLOAT_TO_SHORT(sdc.s[2], color[2]);
      UNCLAMPED_FLOAT_TO_SHORT(sdc.s[3], color[3]);

      /* XXX: Fill in half floats */
      /* XXX: Fill in signed bytes */

      COPY_4V(sdc.f, color);

      return brw_cache_data(&brw->cache, BRW_SAMPLER_DEFAULT_COLOR,
			    &sdc, sizeof(sdc));
d145 1
a145 1
      struct brw_sampler_default_color sdc;
d147 1
a147 1
      COPY_4V(sdc.color, color);
d149 1
a149 2
      return brw_cache_data(&brw->cache, BRW_SAMPLER_DEFAULT_COLOR,
			    &sdc, sizeof(sdc));
a152 19

struct wm_sampler_key {
   int sampler_count;

   struct wm_sampler_entry {
      GLenum tex_target;
      GLenum wrap_r, wrap_s, wrap_t;
      float maxlod, minlod;
      float lod_bias;
      float max_aniso;
      GLenum minfilter, magfilter;
      GLenum comparemode, comparefunc;

      /** If target is cubemap, take context setting.
       */
      GLboolean seamless_cube_map;
   } sampler[BRW_MAX_TEX_UNIT];
};

d158 1
a158 2
				     struct wm_sampler_entry *key,
				     drm_intel_bo *sdc_bo,
d162 5
d168 1
a168 3
   memset(sampler, 0, sizeof(*sampler));

   switch (key->minfilter) {
d172 1
d200 1
a200 1
   if (key->max_aniso > 1.0) {
d204 2
a205 2
      if (key->max_aniso > 2.0) {
	 sampler->ss3.max_aniso = MIN2((key->max_aniso - 2) / 2,
d210 1
a210 1
      switch (key->magfilter) {
d213 1
d223 6
a228 3
   sampler->ss1.r_wrap_mode = translate_wrap_mode(key->wrap_r);
   sampler->ss1.s_wrap_mode = translate_wrap_mode(key->wrap_s);
   sampler->ss1.t_wrap_mode = translate_wrap_mode(key->wrap_t);
d237 4
a240 3
   if (key->tex_target == GL_TEXTURE_CUBE_MAP) {
      if (key->seamless_cube_map &&
	  (key->minfilter != GL_NEAREST || key->magfilter != GL_NEAREST)) {
d249 1
a249 1
   } else if (key->tex_target == GL_TEXTURE_1D) {
d261 1
a261 1
   if (key->comparemode == GL_COMPARE_R_TO_TEXTURE_ARB) {
d267 1
a267 1
	 intel_translate_shadow_compare_func(key->comparefunc);
d272 2
a273 1
   sampler->ss0.lod_bias = S_FIXED(CLAMP(key->lod_bias, -16, 15), 6);
d287 2
a288 5
   sampler->ss1.max_lod = U_FIXED(CLAMP(key->maxlod, 0, 13), 6);
   sampler->ss1.min_lod = U_FIXED(CLAMP(key->minlod, 0, 13), 6);
   
   sampler->ss2.default_color_pointer = sdc_bo->offset >> 5; /* reloc */
}
d290 1
d292 13
a304 62
/** Sets up the cache key for sampler state for all texture units */
static void
brw_wm_sampler_populate_key(struct brw_context *brw,
			    struct wm_sampler_key *key)
{
   struct gl_context *ctx = &brw->intel.ctx;
   int unit;
   char *last_entry_end = ((char*)&key->sampler_count) + 
      sizeof(key->sampler_count);

   key->sampler_count = 0;

   for (unit = 0; unit < BRW_MAX_TEX_UNIT; unit++) {
      if (ctx->Texture.Unit[unit]._ReallyEnabled) {
	 struct wm_sampler_entry *entry = &key->sampler[unit];
	 struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
	 struct gl_texture_object *texObj = texUnit->_Current;
	 struct intel_texture_object *intelObj = intel_texture_object(texObj);
	 struct gl_texture_image *firstImage =
	    texObj->Image[0][intelObj->firstLevel];

	 memset(last_entry_end, 0, 
		(char*)entry - last_entry_end + sizeof(*entry));
	 last_entry_end = ((char*)entry) + sizeof(*entry);

         entry->tex_target = texObj->Target;

	 entry->seamless_cube_map = (texObj->Target == GL_TEXTURE_CUBE_MAP)
	    ? ctx->Texture.CubeMapSeamless : GL_FALSE;

	 entry->wrap_r = texObj->WrapR;
	 entry->wrap_s = texObj->WrapS;
	 entry->wrap_t = texObj->WrapT;

	 entry->maxlod = texObj->MaxLod;
	 entry->minlod = texObj->MinLod;
	 entry->lod_bias = texUnit->LodBias + texObj->LodBias;
	 entry->max_aniso = texObj->MaxAnisotropy;
	 entry->minfilter = texObj->MinFilter;
	 entry->magfilter = texObj->MagFilter;
	 entry->comparemode = texObj->CompareMode;
         entry->comparefunc = texObj->CompareFunc;

	 drm_intel_bo_unreference(brw->wm.sdc_bo[unit]);
	 if (firstImage->_BaseFormat == GL_DEPTH_COMPONENT) {
	    float bordercolor[4] = {
	       texObj->BorderColor.f[0],
	       texObj->BorderColor.f[0],
	       texObj->BorderColor.f[0],
	       texObj->BorderColor.f[0]
	    };
	    /* GL specs that border color for depth textures is taken from the
	     * R channel, while the hardware uses A.  Spam R into all the
	     * channels for safety.
	     */
	    brw->wm.sdc_bo[unit] = upload_default_color(brw, bordercolor);
	 } else {
	    brw->wm.sdc_bo[unit] = upload_default_color(brw,
							texObj->BorderColor.f);
	 }
	 key->sampler_count = unit + 1;
      }
d306 9
a314 2
   struct wm_sampler_entry *entry = &key->sampler[key->sampler_count];
   memset(last_entry_end, 0, (char*)entry - last_entry_end);
d317 1
d322 2
a323 1
static void upload_wm_samplers( struct brw_context *brw )
d326 2
a327 2
   struct wm_sampler_key key;
   int i, sampler_key_size;
d329 4
a332 5
   brw_wm_sampler_populate_key(brw, &key);

   if (brw->wm.sampler_count != key.sampler_count) {
      brw->wm.sampler_count = key.sampler_count;
      brw->state.dirty.cache |= CACHE_NEW_SAMPLER;
a334 2
   drm_intel_bo_unreference(brw->wm.sampler_bo);
   brw->wm.sampler_bo = NULL;
d338 8
a345 18
   /* Only include the populated portion of the key in the search. */
   sampler_key_size = offsetof(struct wm_sampler_key,
			       sampler[key.sampler_count]);
   brw->wm.sampler_bo = brw_search_cache(&brw->cache, BRW_SAMPLER,
					 &key, sampler_key_size,
					 brw->wm.sdc_bo, key.sampler_count,
					 NULL);

   /* If we didnt find it in the cache, compute the state and put it in the
    * cache.
    */
   if (brw->wm.sampler_bo == NULL) {
      struct brw_sampler_state sampler[BRW_MAX_TEX_UNIT];

      memset(sampler, 0, sizeof(sampler));
      for (i = 0; i < key.sampler_count; i++) {
	 if (brw->wm.sdc_bo[i] == NULL)
	    continue;
d347 1
a347 21
	 brw_update_sampler_state(brw, &key.sampler[i], brw->wm.sdc_bo[i],
				  &sampler[i]);
      }

      brw->wm.sampler_bo = brw_upload_cache(&brw->cache, BRW_SAMPLER,
					    &key, sampler_key_size,
					    brw->wm.sdc_bo, key.sampler_count,
					    &sampler, sizeof(sampler));

      /* Emit SDC relocations */
      for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
	 if (!ctx->Texture.Unit[i]._ReallyEnabled)
	    continue;

	 drm_intel_bo_emit_reloc(brw->wm.sampler_bo,
				 i * sizeof(struct brw_sampler_state) +
				 offsetof(struct brw_sampler_state, ss2),
				 brw->wm.sdc_bo[i], 0,
				 I915_GEM_DOMAIN_SAMPLER, 0);
      }
   }
d353 1
a353 1
      .brw = 0,
d356 1
a356 1
   .prepare = upload_wm_samplers,
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d69 1
a69 1
static dri_bo *upload_default_color( struct brw_context *brw,
d72 1
a72 1
   struct brw_sampler_default_color sdc;
d74 35
a108 4
   COPY_4V(sdc.color, color); 
   
   return brw_cache_data(&brw->cache, BRW_SAMPLER_DEFAULT_COLOR,
			 &sdc, sizeof(sdc), NULL, 0);
d134 3
a136 2
static void brw_update_sampler_state(struct wm_sampler_entry *key,
				     dri_bo *sdc_bo,
d139 2
d200 4
d267 1
a267 1
   GLcontext *ctx = &brw->intel.ctx;
d269 2
d283 3
a285 1
	 memset(entry, 0, sizeof(*entry));
d305 1
a305 1
	 dri_bo_unreference(brw->wm.sdc_bo[unit]);
d325 2
d335 1
a335 1
   GLcontext *ctx = &brw->intel.ctx;
d346 1
a346 1
   dri_bo_unreference(brw->wm.sampler_bo);
d370 1
a370 1
	 brw_update_sampler_state(&key.sampler[i], brw->wm.sdc_bo[i],
d384 5
a388 6
	 dri_bo_emit_reloc(brw->wm.sampler_bo,
			   I915_GEM_DOMAIN_SAMPLER, 0,
			   0,
			   i * sizeof(struct brw_sampler_state) +
			   offsetof(struct brw_sampler_state, ss2),
			   brw->wm.sdc_bo[i]);
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a68 13

static GLuint U_FIXED(GLfloat value, GLuint frac_bits)
{
   value *= (1<<frac_bits);
   return value < 0 ? 0 : value;
}

static GLint S_FIXED(GLfloat value, GLuint frac_bits)
{
   return value * (1<<frac_bits);
}


d76 2
a77 2
   return brw_cache_data( &brw->cache, BRW_SAMPLER_DEFAULT_COLOR, &sdc,
			  NULL, 0 );
d92 4
a95 1
      dri_bo *sdc_bo;
d107 1
a107 1
   _mesa_memset(sampler, 0, sizeof(*sampler));
d145 1
a145 1
	 sampler->ss3.max_aniso = MAX2((key->max_aniso - 2) / 2,
d162 23
a184 4
   if (key->tex_target == GL_TEXTURE_CUBE_MAP &&
       (key->minfilter != GL_NEAREST || key->magfilter != GL_NEAREST)) {
      /* If we're using anything but nearest sampling for a cube map, we
       * need to set this wrap mode to avoid GPU lock-ups.
d186 1
a186 8
      sampler->ss1.r_wrap_mode = BRW_TEXCOORDMODE_CUBE;
      sampler->ss1.s_wrap_mode = BRW_TEXCOORDMODE_CUBE;
      sampler->ss1.t_wrap_mode = BRW_TEXCOORDMODE_CUBE;
   }
   else {
      sampler->ss1.r_wrap_mode = translate_wrap_mode(key->wrap_r);
      sampler->ss1.s_wrap_mode = translate_wrap_mode(key->wrap_s);
      sampler->ss1.t_wrap_mode = translate_wrap_mode(key->wrap_t);
d188 1
d217 2
a218 2
   sampler->ss1.max_lod = U_FIXED(MIN2(MAX2(key->maxlod, 0), 13), 6);
   sampler->ss1.min_lod = U_FIXED(MIN2(MAX2(key->minlod, 0), 13), 6);
d223 1
d232 1
a232 1
   memset(key, 0, sizeof(*key));
d243 2
d247 3
d266 4
a269 4
	       texObj->BorderColor[0],
	       texObj->BorderColor[0],
	       texObj->BorderColor[0],
	       texObj->BorderColor[0]
d278 1
a278 1
							texObj->BorderColor);
d293 1
a293 1
   int i;
d307 3
d311 1
a311 1
					 &key, sizeof(key),
d331 1
a331 1
					    &key, sizeof(key),
d333 1
a333 2
					    &sampler, sizeof(sampler),
					    NULL, NULL);
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d37 1
a37 1
#include "macros.h"
d98 1
d172 5
a176 8
   sampler->ss1.r_wrap_mode = translate_wrap_mode(key->wrap_r);
   sampler->ss1.s_wrap_mode = translate_wrap_mode(key->wrap_s);
   sampler->ss1.t_wrap_mode = translate_wrap_mode(key->wrap_t);

   /* Fulsim complains if I don't do this.  Hardware doesn't mind:
    */
#if 0
   if (texObj->Target == GL_TEXTURE_CUBE_MAP_ARB) {
d181 5
a185 1
#endif
d225 1
d231 1
a231 1
      if (brw->attribs.Texture->Unit[unit]._ReallyEnabled) {
d233 1
a233 1
	 struct gl_texture_unit *texUnit = &brw->attribs.Texture->Unit[unit];
d235 5
d252 1
a252 1
    entry->comparefunc = texObj->CompareFunc;
d255 16
a270 2
	 brw->wm.sdc_bo[unit] = upload_default_color(brw, texObj->BorderColor);

d280 1
a280 1
static int upload_wm_samplers( struct brw_context *brw )
d282 1
a284 1
   int ret = 0;
d296 1
a296 1
      return 0;
d326 1
a326 1
	 if (!brw->attribs.Texture->Unit[i]._ReallyEnabled)
d329 6
a334 7
	 ret |= dri_bufmgr_check_aperture_space(brw->wm.sdc_bo[i]);
	 dri_emit_reloc(brw->wm.sampler_bo,
			DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_READ,
			0,
			i * sizeof(struct brw_sampler_state) +
			offsetof(struct brw_sampler_state, ss2),
			brw->wm.sdc_bo[i]);
a336 4

   ret |= dri_bufmgr_check_aperture_space(brw->wm.sampler_bo);
   return ret;

@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d57 1
a57 1
      return BRW_TEXCOORDMODE_CLAMP_BORDER; /* conform likes it this way */
d82 2
a83 2
static GLuint upload_default_color( struct brw_context *brw,
				    const GLfloat *color )
d89 2
a90 1
   return brw_cache_data( &brw->cache[BRW_SAMPLER_DEFAULT_COLOR], &sdc );
d94 17
a110 1
/*
d112 4
a115 5
static void brw_update_sampler_state( struct gl_texture_unit *texUnit,
				      struct gl_texture_object *texObj,
				      GLuint sdc_gs_offset,
				      struct brw_sampler_state *sampler)
{   
d118 1
a118 1
   switch (texObj->MinFilter) {
d149 1
a149 1
   if ( texObj->MaxAnisotropy > 1.0 ) {
d153 2
a154 2
      if (texObj->MaxAnisotropy > 2.0) {
	 sampler->ss3.max_aniso = MAX2((texObj->MaxAnisotropy - 2) / 2,
d159 1
a159 1
      switch (texObj->MagFilter) {
d171 3
a173 3
   sampler->ss1.r_wrap_mode = translate_wrap_mode(texObj->WrapR);
   sampler->ss1.s_wrap_mode = translate_wrap_mode(texObj->WrapS);
   sampler->ss1.t_wrap_mode = translate_wrap_mode(texObj->WrapT);
d187 1
a187 1
   if (texObj->CompareMode == GL_COMPARE_R_TO_TEXTURE_ARB) {
d192 2
a193 1
      sampler->ss0.shadow_function = intel_translate_shadow_compare_func(texObj->CompareFunc);
d198 1
a198 1
   sampler->ss0.lod_bias = S_FIXED(CLAMP(texUnit->LodBias + texObj->LodBias, -16, 15), 6);
d212 2
a213 2
   sampler->ss1.max_lod = U_FIXED(MIN2(MAX2(texObj->MaxLod, 0), 13), 6);
   sampler->ss1.min_lod = U_FIXED(MIN2(MAX2(texObj->MinLod, 0), 13), 6);
d215 1
a215 1
   sampler->ss2.default_color_pointer = sdc_gs_offset >> 5;
d218 27
d246 7
d258 1
a258 1
static void upload_wm_samplers( struct brw_context *brw )
d260 5
a264 2
   GLuint unit;
   GLuint sampler_count = 0;
d266 20
a285 5
   /* _NEW_TEXTURE */
   for (unit = 0; unit < BRW_MAX_TEX_UNIT; unit++) {
      if (brw->attribs.Texture->Unit[unit]._ReallyEnabled) {	 
	 struct gl_texture_unit *texUnit = &brw->attribs.Texture->Unit[unit];
	 struct gl_texture_object *texObj = texUnit->_Current;
d287 4
a290 1
	 GLuint sdc_gs_offset = upload_default_color(brw, texObj->BorderColor);
d292 3
a294 4
	 brw_update_sampler_state(texUnit,
				  texObj, 
				  sdc_gs_offset,
				  &brw->wm.sampler[unit]);
d296 18
a313 1
	 sampler_count = unit + 1;
a315 5
   
   if (brw->wm.sampler_count != sampler_count) {
      brw->wm.sampler_count = sampler_count;
      brw->state.dirty.cache |= CACHE_NEW_SAMPLER;
   }
d317 2
a318 1
   brw->wm.sampler_gs_offset = 0;
a319 5
   if (brw->wm.sampler_count) 
      brw->wm.sampler_gs_offset = 
	 brw_cache_data_sz(&brw->cache[BRW_SAMPLER],
			   brw->wm.sampler,
			   sizeof(struct brw_sampler_state) * brw->wm.sampler_count);
a321 1

d328 1
a328 1
   .update = upload_wm_samplers
@


1.1
log
@Initial revision
@
text
@d176 1
a176 1
      sampler->ss0.shadow_function = intel_translate_compare_func(texObj->CompareFunc);
d181 1
a181 1
   sampler->ss0.lod_bias = S_FIXED(texUnit->LodBias + texObj->LodBias, 6);
d195 2
a196 2
   sampler->ss1.max_lod = U_FIXED(MAX2(texObj->MaxLod, 0), 6);
   sampler->ss1.min_lod = U_FIXED(MAX2(texObj->MinLod, 0), 6);
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d37 1
a37 1
#include "main/macros.h"
d57 1
a57 1
      return BRW_TEXCOORDMODE_CLAMP;
d69 2
a70 2
static drm_intel_bo *upload_default_color( struct brw_context *brw,
				     const GLfloat *color )
d72 3
a74 1
   struct intel_context *intel = &brw->intel;
d76 4
a79 2
   if (intel->gen >= 5) {
      struct gen5_sampler_default_color sdc;
a80 1
      memset(&sdc, 0, sizeof(sdc));
d82 4
a85 4
      UNCLAMPED_FLOAT_TO_UBYTE(sdc.ub[0], color[0]);
      UNCLAMPED_FLOAT_TO_UBYTE(sdc.ub[1], color[1]);
      UNCLAMPED_FLOAT_TO_UBYTE(sdc.ub[2], color[2]);
      UNCLAMPED_FLOAT_TO_UBYTE(sdc.ub[3], color[3]);
d87 3
a89 25
      UNCLAMPED_FLOAT_TO_USHORT(sdc.us[0], color[0]);
      UNCLAMPED_FLOAT_TO_USHORT(sdc.us[1], color[1]);
      UNCLAMPED_FLOAT_TO_USHORT(sdc.us[2], color[2]);
      UNCLAMPED_FLOAT_TO_USHORT(sdc.us[3], color[3]);

      UNCLAMPED_FLOAT_TO_SHORT(sdc.s[0], color[0]);
      UNCLAMPED_FLOAT_TO_SHORT(sdc.s[1], color[1]);
      UNCLAMPED_FLOAT_TO_SHORT(sdc.s[2], color[2]);
      UNCLAMPED_FLOAT_TO_SHORT(sdc.s[3], color[3]);

      /* XXX: Fill in half floats */
      /* XXX: Fill in signed bytes */

      COPY_4V(sdc.f, color);

      return brw_cache_data(&brw->cache, BRW_SAMPLER_DEFAULT_COLOR,
			    &sdc, sizeof(sdc));
   } else {
      struct brw_sampler_default_color sdc;

      COPY_4V(sdc.color, color);

      return brw_cache_data(&brw->cache, BRW_SAMPLER_DEFAULT_COLOR,
			    &sdc, sizeof(sdc));
   }
d93 1
a93 21
struct wm_sampler_key {
   int sampler_count;

   struct wm_sampler_entry {
      GLenum tex_target;
      GLenum wrap_r, wrap_s, wrap_t;
      float maxlod, minlod;
      float lod_bias;
      float max_aniso;
      GLenum minfilter, magfilter;
      GLenum comparemode, comparefunc;

      /** If target is cubemap, take context setting.
       */
      GLboolean seamless_cube_map;
   } sampler[BRW_MAX_TEX_UNIT];
};

/**
 * Sets the sampler state for a single unit based off of the sampler key
 * entry.
d95 6
a100 8
static void brw_update_sampler_state(struct brw_context *brw,
				     struct wm_sampler_entry *key,
				     drm_intel_bo *sdc_bo,
				     struct brw_sampler_state *sampler)
{
   struct intel_context *intel = &brw->intel;

   memset(sampler, 0, sizeof(*sampler));
d102 1
a102 1
   switch (key->minfilter) {
d133 1
a133 1
   if (key->max_aniso > 1.0) {
d137 2
a138 2
      if (key->max_aniso > 2.0) {
	 sampler->ss3.max_aniso = MIN2((key->max_aniso - 2) / 2,
d143 1
a143 1
      switch (key->magfilter) {
d155 11
a165 29
   sampler->ss1.r_wrap_mode = translate_wrap_mode(key->wrap_r);
   sampler->ss1.s_wrap_mode = translate_wrap_mode(key->wrap_s);
   sampler->ss1.t_wrap_mode = translate_wrap_mode(key->wrap_t);

   if (intel->gen >= 6 &&
       sampler->ss0.min_filter != sampler->ss0.mag_filter)
	sampler->ss0.min_mag_neq = 1;

   /* Cube-maps on 965 and later must use the same wrap mode for all 3
    * coordinate dimensions.  Futher, only CUBE and CLAMP are valid.
    */
   if (key->tex_target == GL_TEXTURE_CUBE_MAP) {
      if (key->seamless_cube_map &&
	  (key->minfilter != GL_NEAREST || key->magfilter != GL_NEAREST)) {
	 sampler->ss1.r_wrap_mode = BRW_TEXCOORDMODE_CUBE;
	 sampler->ss1.s_wrap_mode = BRW_TEXCOORDMODE_CUBE;
	 sampler->ss1.t_wrap_mode = BRW_TEXCOORDMODE_CUBE;
      } else {
	 sampler->ss1.r_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	 sampler->ss1.s_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	 sampler->ss1.t_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
      }
   } else if (key->tex_target == GL_TEXTURE_1D) {
      /* There's a bug in 1D texture sampling - it actually pays
       * attention to the wrap_t value, though it should not.
       * Override the wrap_t value here to GL_REPEAT to keep
       * any nonexistent border pixels from floating in.
       */
      sampler->ss1.t_wrap_mode = BRW_TEXCOORDMODE_WRAP;
d167 1
a167 1

d171 1
a171 1
   if (key->comparemode == GL_COMPARE_R_TO_TEXTURE_ARB) {
d176 1
a176 2
      sampler->ss0.shadow_function =
	 intel_translate_shadow_compare_func(key->comparefunc);
d181 1
a181 1
   sampler->ss0.lod_bias = S_FIXED(CLAMP(key->lod_bias, -16, 15), 6);
d195 2
a196 2
   sampler->ss1.max_lod = U_FIXED(CLAMP(key->maxlod, 0, 13), 6);
   sampler->ss1.min_lod = U_FIXED(CLAMP(key->minlod, 0, 13), 6);
d198 1
a198 1
   sampler->ss2.default_color_pointer = sdc_bo->offset >> 5; /* reloc */
a201 66
/** Sets up the cache key for sampler state for all texture units */
static void
brw_wm_sampler_populate_key(struct brw_context *brw,
			    struct wm_sampler_key *key)
{
   struct gl_context *ctx = &brw->intel.ctx;
   int unit;
   char *last_entry_end = ((char*)&key->sampler_count) + 
      sizeof(key->sampler_count);

   key->sampler_count = 0;

   for (unit = 0; unit < BRW_MAX_TEX_UNIT; unit++) {
      if (ctx->Texture.Unit[unit]._ReallyEnabled) {
	 struct wm_sampler_entry *entry = &key->sampler[unit];
	 struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
	 struct gl_texture_object *texObj = texUnit->_Current;
	 struct intel_texture_object *intelObj = intel_texture_object(texObj);
	 struct gl_texture_image *firstImage =
	    texObj->Image[0][intelObj->firstLevel];

	 memset(last_entry_end, 0, 
		(char*)entry - last_entry_end + sizeof(*entry));
	 last_entry_end = ((char*)entry) + sizeof(*entry);

         entry->tex_target = texObj->Target;

	 entry->seamless_cube_map = (texObj->Target == GL_TEXTURE_CUBE_MAP)
	    ? ctx->Texture.CubeMapSeamless : GL_FALSE;

	 entry->wrap_r = texObj->WrapR;
	 entry->wrap_s = texObj->WrapS;
	 entry->wrap_t = texObj->WrapT;

	 entry->maxlod = texObj->MaxLod;
	 entry->minlod = texObj->MinLod;
	 entry->lod_bias = texUnit->LodBias + texObj->LodBias;
	 entry->max_aniso = texObj->MaxAnisotropy;
	 entry->minfilter = texObj->MinFilter;
	 entry->magfilter = texObj->MagFilter;
	 entry->comparemode = texObj->CompareMode;
         entry->comparefunc = texObj->CompareFunc;

	 drm_intel_bo_unreference(brw->wm.sdc_bo[unit]);
	 if (firstImage->_BaseFormat == GL_DEPTH_COMPONENT) {
	    float bordercolor[4] = {
	       texObj->BorderColor.f[0],
	       texObj->BorderColor.f[0],
	       texObj->BorderColor.f[0],
	       texObj->BorderColor.f[0]
	    };
	    /* GL specs that border color for depth textures is taken from the
	     * R channel, while the hardware uses A.  Spam R into all the
	     * channels for safety.
	     */
	    brw->wm.sdc_bo[unit] = upload_default_color(brw, bordercolor);
	 } else {
	    brw->wm.sdc_bo[unit] = upload_default_color(brw,
							texObj->BorderColor.f);
	 }
	 key->sampler_count = unit + 1;
      }
   }
   struct wm_sampler_entry *entry = &key->sampler[key->sampler_count];
   memset(last_entry_end, 0, (char*)entry - last_entry_end);
}
d209 10
a218 3
   struct gl_context *ctx = &brw->intel.ctx;
   struct wm_sampler_key key;
   int i, sampler_key_size;
d220 4
a223 1
   brw_wm_sampler_populate_key(brw, &key);
d225 6
a230 2
   if (brw->wm.sampler_count != key.sampler_count) {
      brw->wm.sampler_count = key.sampler_count;
d234 1
a234 12
   drm_intel_bo_unreference(brw->wm.sampler_bo);
   brw->wm.sampler_bo = NULL;
   if (brw->wm.sampler_count == 0)
      return;

   /* Only include the populated portion of the key in the search. */
   sampler_key_size = offsetof(struct wm_sampler_key,
			       sampler[key.sampler_count]);
   brw->wm.sampler_bo = brw_search_cache(&brw->cache, BRW_SAMPLER,
					 &key, sampler_key_size,
					 brw->wm.sdc_bo, key.sampler_count,
					 NULL);
d236 6
a241 10
   /* If we didnt find it in the cache, compute the state and put it in the
    * cache.
    */
   if (brw->wm.sampler_bo == NULL) {
      struct brw_sampler_state sampler[BRW_MAX_TEX_UNIT];

      memset(sampler, 0, sizeof(sampler));
      for (i = 0; i < key.sampler_count; i++) {
	 if (brw->wm.sdc_bo[i] == NULL)
	    continue;
a242 22
	 brw_update_sampler_state(brw, &key.sampler[i], brw->wm.sdc_bo[i],
				  &sampler[i]);
      }

      brw->wm.sampler_bo = brw_upload_cache(&brw->cache, BRW_SAMPLER,
					    &key, sampler_key_size,
					    brw->wm.sdc_bo, key.sampler_count,
					    &sampler, sizeof(sampler));

      /* Emit SDC relocations */
      for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
	 if (!ctx->Texture.Unit[i]._ReallyEnabled)
	    continue;

	 drm_intel_bo_emit_reloc(brw->wm.sampler_bo,
				 i * sizeof(struct brw_sampler_state) +
				 offsetof(struct brw_sampler_state, ss2),
				 brw->wm.sdc_bo[i], 0,
				 I915_GEM_DOMAIN_SAMPLER, 0);
      }
   }
}
d250 1
a250 1
   .prepare = upload_wm_samplers,
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d38 1
a38 1
#include "main/samplerobj.h"
d47 5
a51 2
uint32_t
translate_wrap_mode(GLenum wrap, bool using_nearest)
d56 2
a57 14
   case GL_CLAMP:
      /* GL_CLAMP is the weird mode where coordinates are clamped to
       * [0.0, 1.0], so linear filtering of coordinates outside of
       * [0.0, 1.0] give you half edge texel value and half border
       * color.  The fragment shader will clamp the coordinates, and
       * we set clamp_border here, which gets the result desired.  We
       * just use clamp(_to_edge) for nearest, because for nearest
       * clamping to 1.0 gives border color instead of the desired
       * edge texels.
       */
      if (using_nearest)
	 return BRW_TEXCOORDMODE_CLAMP;
      else
	 return BRW_TEXCOORDMODE_CLAMP_BORDER;
d59 1
a59 1
      return BRW_TEXCOORDMODE_CLAMP;
d69 2
a70 6
/**
 * Upload SAMPLER_BORDER_COLOR_STATE.
 */
void
upload_default_color(struct brw_context *brw, struct gl_sampler_object *sampler,
		     int unit, int ss_index)
d72 16
a87 48
   struct gl_context *ctx = &brw->ctx;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *texObj = texUnit->_Current;
   struct gl_texture_image *firstImage = texObj->Image[0][texObj->BaseLevel];
   float color[4];

   switch (firstImage->_BaseFormat) {
   case GL_DEPTH_COMPONENT:
      /* GL specs that border color for depth textures is taken from the
       * R channel, while the hardware uses A.  Spam R into all the
       * channels for safety.
       */
      color[0] = sampler->BorderColor.f[0];
      color[1] = sampler->BorderColor.f[0];
      color[2] = sampler->BorderColor.f[0];
      color[3] = sampler->BorderColor.f[0];
      break;
   case GL_ALPHA:
      color[0] = 0.0;
      color[1] = 0.0;
      color[2] = 0.0;
      color[3] = sampler->BorderColor.f[3];
      break;
   case GL_INTENSITY:
      color[0] = sampler->BorderColor.f[0];
      color[1] = sampler->BorderColor.f[0];
      color[2] = sampler->BorderColor.f[0];
      color[3] = sampler->BorderColor.f[0];
      break;
   case GL_LUMINANCE:
      color[0] = sampler->BorderColor.f[0];
      color[1] = sampler->BorderColor.f[0];
      color[2] = sampler->BorderColor.f[0];
      color[3] = 1.0;
      break;
   case GL_LUMINANCE_ALPHA:
      color[0] = sampler->BorderColor.f[0];
      color[1] = sampler->BorderColor.f[0];
      color[2] = sampler->BorderColor.f[0];
      color[3] = sampler->BorderColor.f[3];
      break;
   default:
      color[0] = sampler->BorderColor.f[0];
      color[1] = sampler->BorderColor.f[1];
      color[2] = sampler->BorderColor.f[2];
      color[3] = sampler->BorderColor.f[3];
      break;
   }
d89 4
a92 6
   /* In some cases we use an RGBA surface format for GL RGB textures,
    * where we've initialized the A channel to 1.0.  We also have to set
    * the border color alpha to 1.0 in that case.
    */
   if (firstImage->_BaseFormat == GL_RGB)
      color[3] = 1.0;
d94 2
a95 2
   if (brw->gen == 5 || brw->gen == 6) {
      struct gen5_sampler_default_color *sdc;
d97 1
a97 2
      sdc = brw_state_batch(brw, AUB_TRACE_SAMPLER_DEFAULT_COLOR,
			    sizeof(*sdc), 32, &brw->wm.sdc_offset[ss_index]);
d99 2
a100 31
      memset(sdc, 0, sizeof(*sdc));

      UNCLAMPED_FLOAT_TO_UBYTE(sdc->ub[0], color[0]);
      UNCLAMPED_FLOAT_TO_UBYTE(sdc->ub[1], color[1]);
      UNCLAMPED_FLOAT_TO_UBYTE(sdc->ub[2], color[2]);
      UNCLAMPED_FLOAT_TO_UBYTE(sdc->ub[3], color[3]);

      UNCLAMPED_FLOAT_TO_USHORT(sdc->us[0], color[0]);
      UNCLAMPED_FLOAT_TO_USHORT(sdc->us[1], color[1]);
      UNCLAMPED_FLOAT_TO_USHORT(sdc->us[2], color[2]);
      UNCLAMPED_FLOAT_TO_USHORT(sdc->us[3], color[3]);

      UNCLAMPED_FLOAT_TO_SHORT(sdc->s[0], color[0]);
      UNCLAMPED_FLOAT_TO_SHORT(sdc->s[1], color[1]);
      UNCLAMPED_FLOAT_TO_SHORT(sdc->s[2], color[2]);
      UNCLAMPED_FLOAT_TO_SHORT(sdc->s[3], color[3]);

      sdc->hf[0] = _mesa_float_to_half(color[0]);
      sdc->hf[1] = _mesa_float_to_half(color[1]);
      sdc->hf[2] = _mesa_float_to_half(color[2]);
      sdc->hf[3] = _mesa_float_to_half(color[3]);

      sdc->b[0] = sdc->s[0] >> 8;
      sdc->b[1] = sdc->s[1] >> 8;
      sdc->b[2] = sdc->s[2] >> 8;
      sdc->b[3] = sdc->s[3] >> 8;

      sdc->f[0] = color[0];
      sdc->f[1] = color[1];
      sdc->f[2] = color[2];
      sdc->f[3] = color[3];
d102 1
a102 1
      struct brw_sampler_default_color *sdc;
d104 1
a104 2
      sdc = brw_state_batch(brw, AUB_TRACE_SAMPLER_DEFAULT_COLOR,
			    sizeof(*sdc), 32, &brw->wm.sdc_offset[ss_index]);
d106 2
a107 1
      COPY_4V(sdc->color, color);
d111 19
d135 2
a136 2
				     int unit,
                                     int ss_index,
d139 1
a139 5
   struct gl_context *ctx = &brw->ctx;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *texObj = texUnit->_Current;
   struct gl_sampler_object *gl_sampler = _mesa_get_samplerobj(ctx, unit);
   bool using_nearest = false;
d141 1
a141 3
   /* These don't use samplers at all. */
   if (texObj->Target == GL_TEXTURE_BUFFER)
      return;
d143 1
a143 1
   switch (gl_sampler->MinFilter) {
a146 1
      using_nearest = true;
d174 1
a174 1
   if (gl_sampler->MaxAnisotropy > 1.0) {
d178 2
a179 2
      if (gl_sampler->MaxAnisotropy > 2.0) {
	 sampler->ss3.max_aniso = MIN2((gl_sampler->MaxAnisotropy - 2) / 2,
d184 1
a184 1
      switch (gl_sampler->MagFilter) {
a186 1
	 using_nearest = true;
d196 3
a198 6
   sampler->ss1.r_wrap_mode = translate_wrap_mode(gl_sampler->WrapR,
						  using_nearest);
   sampler->ss1.s_wrap_mode = translate_wrap_mode(gl_sampler->WrapS,
						  using_nearest);
   sampler->ss1.t_wrap_mode = translate_wrap_mode(gl_sampler->WrapT,
						  using_nearest);
d200 1
a200 1
   if (brw->gen >= 6 &&
d207 3
a209 5
   if (texObj->Target == GL_TEXTURE_CUBE_MAP ||
       texObj->Target == GL_TEXTURE_CUBE_MAP_ARRAY) {
      if (ctx->Texture.CubeMapSeamless &&
	  (gl_sampler->MinFilter != GL_NEAREST ||
	   gl_sampler->MagFilter != GL_NEAREST)) {
d218 1
a218 1
   } else if (texObj->Target == GL_TEXTURE_1D) {
d230 1
a230 1
   if (gl_sampler->CompareMode == GL_COMPARE_R_TO_TEXTURE_ARB) {
d236 1
a236 1
	 intel_translate_shadow_compare_func(gl_sampler->CompareFunc);
d241 1
a241 2
   sampler->ss0.lod_bias = S_FIXED(CLAMP(texUnit->LodBias +
					 gl_sampler->LodBias, -16, 15), 6);
d255 5
a259 9
   sampler->ss1.max_lod = U_FIXED(CLAMP(gl_sampler->MaxLod, 0, 13), 6);
   sampler->ss1.min_lod = U_FIXED(CLAMP(gl_sampler->MinLod, 0, 13), 6);

   /* On Gen6+, the sampler can handle non-normalized texture
    * rectangle coordinates natively
    */
   if (brw->gen >= 6 && texObj->Target == GL_TEXTURE_RECTANGLE) {
      sampler->ss3.non_normalized_coord = 1;
   }
a260 1
   upload_default_color(brw, gl_sampler, unit, ss_index);
d262 62
a323 13
   if (brw->gen >= 6) {
      sampler->ss2.default_color_pointer = brw->wm.sdc_offset[ss_index] >> 5;
   } else {
      /* reloc */
      sampler->ss2.default_color_pointer = (brw->batch.bo->offset +
					    brw->wm.sdc_offset[ss_index]) >> 5;

      drm_intel_bo_emit_reloc(brw->batch.bo,
			      brw->sampler.offset +
			      ss_index * sizeof(struct brw_sampler_state) +
			      offsetof(struct brw_sampler_state, ss2),
			      brw->batch.bo, brw->wm.sdc_offset[ss_index],
			      I915_GEM_DOMAIN_SAMPLER, 0);
d325 3
d329 9
a337 9
   if (sampler->ss0.min_filter != BRW_MAPFILTER_NEAREST)
      sampler->ss3.address_round |= BRW_ADDRESS_ROUNDING_ENABLE_U_MIN |
                                    BRW_ADDRESS_ROUNDING_ENABLE_V_MIN |
                                    BRW_ADDRESS_ROUNDING_ENABLE_R_MIN;
   if (sampler->ss0.mag_filter != BRW_MAPFILTER_NEAREST)
      sampler->ss3.address_round |= BRW_ADDRESS_ROUNDING_ENABLE_U_MAG |
                                    BRW_ADDRESS_ROUNDING_ENABLE_V_MAG |
                                    BRW_ADDRESS_ROUNDING_ENABLE_R_MAG;
}
d339 1
d341 4
a344 5
static void
brw_upload_samplers(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   struct brw_sampler_state *samplers;
d346 4
a349 3
   /* BRW_NEW_VERTEX_PROGRAM and BRW_NEW_FRAGMENT_PROGRAM */
   struct gl_program *vs = (struct gl_program *) brw->vertex_program;
   struct gl_program *fs = (struct gl_program *) brw->fragment_program;
d351 7
a357 1
   GLbitfield SamplersUsed = vs->SamplersUsed | fs->SamplersUsed;
d359 2
a360 2
   /* ARB programs use the texture unit number as the sampler index, so we
    * need to find the highest unit used.  A bit-count will not work.
d362 7
a368 1
   brw->sampler.count = _mesa_fls(SamplersUsed);
d370 3
a372 2
   if (brw->sampler.count == 0)
      return;
d374 15
a388 11
   samplers = brw_state_batch(brw, AUB_TRACE_SAMPLER_STATE,
			      brw->sampler.count * sizeof(*samplers),
			      32, &brw->sampler.offset);
   memset(samplers, 0, brw->sampler.count * sizeof(*samplers));

   for (unsigned s = 0; s < brw->sampler.count; s++) {
      if (SamplersUsed & (1 << s)) {
         const unsigned unit = (fs->SamplersUsed & (1 << s)) ?
            fs->SamplerUnits[s] : vs->SamplerUnits[s];
         if (ctx->Texture.Unit[unit]._ReallyEnabled)
            brw_update_sampler_state(brw, unit, s, &samplers[s]);
a390 2

   brw->state.dirty.cache |= CACHE_NEW_SAMPLER;
d393 1
a393 1
const struct brw_tracked_state brw_samplers = {
d396 1
a396 3
      .brw = BRW_NEW_BATCH |
             BRW_NEW_VERTEX_PROGRAM |
             BRW_NEW_FRAGMENT_PROGRAM,
d399 1
a399 1
   .emit = brw_upload_samplers,
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics to
d5 1
a5 1

d13 1
a13 1

d17 1
a17 1

d25 1
a25 1

d29 1
a29 1
  *   Keith Whitwell <keithw@@vmware.com>
d31 1
a31 1

a35 1
#include "intel_mipmap_tree.h"
d48 1
a48 1
translate_wrap_mode(struct brw_context *brw, GLenum wrap, bool using_nearest)
d51 1
a51 1
   case GL_REPEAT:
d57 3
a59 10
       * color.
       *
       * Gen8+ supports this natively.
       */
      if (brw->gen >= 8)
         return GEN8_TEXCOORDMODE_HALF_BORDER;

      /* On Gen4-7.5, we clamp the coordinates in the fragment shader
       * and set clamp_border here, which gets the result desired.
       * We just use clamp(_to_edge) for nearest, because for nearest
d67 1
a67 1
   case GL_CLAMP_TO_EDGE:
d69 1
a69 1
   case GL_CLAMP_TO_BORDER:
d71 1
a71 1
   case GL_MIRRORED_REPEAT:
d73 1
a73 3
   case GL_MIRROR_CLAMP_TO_EDGE:
      return BRW_TEXCOORDMODE_MIRROR_ONCE;
   default:
d82 2
a83 4
upload_default_color(struct brw_context *brw,
                     struct gl_sampler_object *sampler,
                     int unit,
                     uint32_t *sdc_offset)
d141 1
a141 11
   if (brw->gen >= 8) {
      /* On Broadwell, the border color is represented as four 32-bit floats,
       * integers, or unsigned values, interpreted according to the surface
       * format.  This matches the sampler->BorderColor union exactly.  Since
       * we use floats both here and in the above reswizzling code, we preserve
       * the original bit pattern.  So we actually handle all three formats.
       */
      float *sdc = brw_state_batch(brw, AUB_TRACE_SAMPLER_DEFAULT_COLOR,
                                   4 * 4, 64, sdc_offset);
      COPY_4FV(sdc, color);
   } else if (brw->gen == 5 || brw->gen == 6) {
d145 1
a145 1
			    sizeof(*sdc), 32, sdc_offset);
d182 1
a182 1
			    sizeof(*sdc), 32, sdc_offset);
d195 1
a195 3
                                     struct brw_sampler_state *sampler,
                                     uint32_t sampler_state_table_offset,
                                     uint32_t *sdc_offset)
d237 1
a237 1
   /* Set Anisotropy:
d240 1
a240 1
      sampler->ss0.min_filter = BRW_MAPFILTER_ANISOTROPIC;
d259 1
a259 1
      }
d262 1
a262 1
   sampler->ss1.r_wrap_mode = translate_wrap_mode(brw, gl_sampler->WrapR,
d264 1
a264 1
   sampler->ss1.s_wrap_mode = translate_wrap_mode(brw, gl_sampler->WrapS,
d266 1
a266 1
   sampler->ss1.t_wrap_mode = translate_wrap_mode(brw, gl_sampler->WrapT,
d278 1
a278 1
      if ((ctx->Texture.CubeMapSeamless || gl_sampler->CubeMapSeamless) &&
d299 1
a299 1
   /* Set shadow function:
d310 1
a310 1
   /* Set LOD bias:
d318 7
d337 1
a337 1
   upload_default_color(brw, gl_sampler, unit, sdc_offset);
d340 1
a340 1
      sampler->ss2.default_color_pointer = *sdc_offset >> 5;
d343 2
a344 2
      sampler->ss2.default_color_pointer = (brw->batch.bo->offset64 +
					    *sdc_offset) >> 5;
d347 1
a347 1
			      sampler_state_table_offset +
d350 1
a350 1
			      brw->batch.bo, *sdc_offset,
d366 1
a366 3
brw_upload_sampler_state_table(struct brw_context *brw,
                               struct gl_program *prog,
                               struct brw_stage_state *stage_state)
a369 1
   uint32_t sampler_count = stage_state->sampler_count;
d371 10
a380 1
   GLbitfield SamplersUsed = prog->SamplersUsed;
d382 1
a382 1
   if (sampler_count == 0)
d386 3
a388 3
			      sampler_count * sizeof(*samplers),
			      32, &stage_state->sampler_offset);
   memset(samplers, 0, sampler_count * sizeof(*samplers));
d390 1
a390 1
   for (unsigned s = 0; s < sampler_count; s++) {
d392 4
a395 5
         const unsigned unit = prog->SamplerUnits[s];
         if (ctx->Texture.Unit[unit]._Current)
            brw_update_sampler_state(brw, unit, s, &samplers[s],
                                     stage_state->sampler_offset,
                                     &stage_state->sdc_offset[s]);
d402 1
a402 9
static void
brw_upload_fs_samplers(struct brw_context *brw)
{
   /* BRW_NEW_FRAGMENT_PROGRAM */
   struct gl_program *fs = (struct gl_program *) brw->fragment_program;
   brw->vtbl.upload_sampler_state_table(brw, fs, &brw->wm.base);
}

const struct brw_tracked_state brw_fs_samplers = {
d406 1
d410 1
a410 43
   .emit = brw_upload_fs_samplers,
};

static void
brw_upload_vs_samplers(struct brw_context *brw)
{
   /* BRW_NEW_VERTEX_PROGRAM */
   struct gl_program *vs = (struct gl_program *) brw->vertex_program;
   brw->vtbl.upload_sampler_state_table(brw, vs, &brw->vs.base);
}


const struct brw_tracked_state brw_vs_samplers = {
   .dirty = {
      .mesa = _NEW_TEXTURE,
      .brw = BRW_NEW_BATCH |
             BRW_NEW_VERTEX_PROGRAM,
      .cache = 0
   },
   .emit = brw_upload_vs_samplers,
};


static void
brw_upload_gs_samplers(struct brw_context *brw)
{
   /* BRW_NEW_GEOMETRY_PROGRAM */
   struct gl_program *gs = (struct gl_program *) brw->geometry_program;
   if (!gs)
      return;

   brw->vtbl.upload_sampler_state_table(brw, gs, &brw->gs.base);
}


const struct brw_tracked_state brw_gs_samplers = {
   .dirty = {
      .mesa = _NEW_TEXTURE,
      .brw = BRW_NEW_BATCH |
             BRW_NEW_GEOMETRY_PROGRAM,
      .cache = 0
   },
   .emit = brw_upload_gs_samplers,
a413 5
void
gen4_init_vtable_sampler_functions(struct brw_context *brw)
{
   brw->vtbl.upload_sampler_state_table = brw_upload_sampler_state_table;
}
@


