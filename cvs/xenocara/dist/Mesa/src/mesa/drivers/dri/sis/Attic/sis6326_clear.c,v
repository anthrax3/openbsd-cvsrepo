head	1.4;
access;
symbols
	OPENBSD_5_4:1.3.0.8
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.6
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.2.0.10
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.6
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.8
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.2.0.8
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2013.09.05.14.05.39;	author jsg;	state dead;
branches;
next	1.3;

1.3
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.53.55;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.53.55;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.34;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.42;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@/*
 * Copyright 2005 Eric Anholt
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <anholt@@FreeBSD.org>
 *
 */

#include "sis_context.h"
#include "sis_state.h"
#include "sis_lock.h"
#include "sis_reg.h"

#include "swrast/swrast.h"
#include "main/macros.h"

static void sis_clear_front_buffer(struct gl_context *ctx, GLenum mask, GLint x,
				   GLint y, GLint width, GLint height);
static void sis_clear_back_buffer(struct gl_context *ctx, GLenum mask, GLint x,
				  GLint y, GLint width, GLint height);
static void sis_clear_z_buffer(struct gl_context * ctx, GLbitfield mask, GLint x,
			       GLint y, GLint width, GLint height );

static void
set_color_pattern( sisContextPtr smesa, GLubyte red, GLubyte green,
		   GLubyte blue, GLubyte alpha )
{
   /* XXX only RGB565 and ARGB8888 */
   switch (smesa->colorFormat)
   {
   case DST_FORMAT_ARGB_8888:
      smesa->clearColorPattern = (alpha << 24) +
	 (red << 16) + (green << 8) + (blue);
      break;
   case DST_FORMAT_RGB_565:
      smesa->clearColorPattern = ((red >> 3) << 11) +
	 ((green >> 2) << 5) + (blue >> 3);
      smesa->clearColorPattern |= smesa->clearColorPattern << 16;
      break;
   default:
      sis_fatal_error("Bad dst color format\n");
   }
}

void
sis6326UpdateZPattern(sisContextPtr smesa, GLclampd z)
{
   CLAMPED_FLOAT_TO_USHORT(smesa->clearZStencilPattern, z * 65535.0);
}

void
sis6326DDClear(struct gl_context *ctx, GLbitfield mask)
{
   sisContextPtr smesa = SIS_CONTEXT(ctx);
   GLint x1, y1, width1, height1;

   /* get region after locking: */
   x1 = ctx->DrawBuffer->_Xmin;
   y1 = ctx->DrawBuffer->_Ymin;
   width1 = ctx->DrawBuffer->_Xmax - x1;
   height1 = ctx->DrawBuffer->_Ymax - y1;
   y1 = Y_FLIP(y1 + height1 - 1);

   /* XXX: Scissoring */
   
   fprintf(stderr, "Clear\n");

   /* Mask out any non-existent buffers */
   if (smesa->depth.offset == 0 || !ctx->Depth.Mask)
      mask &= ~BUFFER_BIT_DEPTH;

   LOCK_HARDWARE();

   if (mask & BUFFER_BIT_FRONT_LEFT) {
      sis_clear_front_buffer(ctx, mask, x1, y1, width1, height1);
      mask &= ~BUFFER_BIT_FRONT_LEFT;
   }

   if (mask & BUFFER_BIT_BACK_LEFT) {
      sis_clear_back_buffer(ctx, mask, x1, y1, width1, height1);
      mask &= ~BUFFER_BIT_BACK_LEFT;
   }

   if (mask & BUFFER_BIT_DEPTH) {
      sis_clear_z_buffer(ctx, mask, x1, y1, width1, height1);
      mask &= ~BUFFER_BIT_DEPTH;
   }

   UNLOCK_HARDWARE();

   if (mask != 0)
      _swrast_Clear(ctx, mask);
}


void
sis6326DDClearColor(struct gl_context *ctx, const GLfloat color[4])
{
   sisContextPtr smesa = SIS_CONTEXT(ctx);
   GLubyte c[4];

   CLAMPED_FLOAT_TO_UBYTE(c[0], color[0]);
   CLAMPED_FLOAT_TO_UBYTE(c[1], color[1]);
   CLAMPED_FLOAT_TO_UBYTE(c[2], color[2]);
   CLAMPED_FLOAT_TO_UBYTE(c[3], color[3]);

   set_color_pattern( smesa, c[0], c[1], c[2], c[3] );
}

void
sis6326DDClearDepth(struct gl_context *ctx, GLclampd d)
{
   sisContextPtr smesa = SIS_CONTEXT(ctx);

   sis6326UpdateZPattern(smesa, d);
}

static void
sis_clear_back_buffer(struct gl_context *ctx, GLenum mask, GLint x, GLint y,
		      GLint width, GLint height)
{
   sisContextPtr smesa = SIS_CONTEXT(ctx);
   
   /* XXX: The order of writing these registers seems to matter, while
    * it actually shouldn't.
    */
   mWait3DCmdQueue(6);
   MMIO(REG_6326_BitBlt_DstSrcPitch, smesa->back.pitch << 16);
   MMIO(REG_6326_BitBlt_fgColor, SiS_ROP_PATCOPY |
	smesa->clearColorPattern);
   MMIO(REG_6326_BitBlt_bgColor, SiS_ROP_PATCOPY |
	smesa->clearColorPattern);
   MMIO(REG_6326_BitBlt_DstAddr, smesa->back.offset +
	(y+height) * smesa->back.pitch +
	(x+width) * smesa->bytesPerPixel);
   MMIO(REG_6326_BitBlt_HeightWidth, ((height-1) << 16) |
	(width * smesa->bytesPerPixel));
   MMIO_WMB();
   MMIO(REG_6326_BitBlt_Cmd, BLT_PAT_BG);
}

static void
sis_clear_front_buffer(struct gl_context *ctx, GLenum mask, GLint x, GLint y,
		       GLint width, GLint height)
{
   sisContextPtr smesa = SIS_CONTEXT(ctx);
   int count;
   drm_clip_rect_t *pExtents = NULL;
   
   pExtents = smesa->driDrawable->pClipRects;
   count = smesa->driDrawable->numClipRects;

   mWait3DCmdQueue(3);
   MMIO(REG_6326_BitBlt_DstSrcPitch, smesa->front.pitch << 16);
   MMIO(REG_6326_BitBlt_fgColor, SiS_ROP_PATCOPY |
       smesa->clearColorPattern);
   MMIO(REG_6326_BitBlt_bgColor, SiS_ROP_PATCOPY |
       smesa->clearColorPattern);

   while (count--) {
      GLint x1 = pExtents->x1 - smesa->driDrawable->x;
      GLint y1 = pExtents->y1 - smesa->driDrawable->y;
      GLint x2 = pExtents->x2 - smesa->driDrawable->x;
      GLint y2 = pExtents->y2 - smesa->driDrawable->y;

      if (x > x1)
	 x1 = x;
      if (y > y1)
	 y1 = y;

      if (x + width < x2)
	 x2 = x + width;
      if (y + height < y2)
	 y2 = y + height;
      width = x2 - x1;
      height = y2 - y1;

      pExtents++;

      if (width <= 0 || height <= 0)
	 continue;

      mWait3DCmdQueue(3);
      MMIO(REG_6326_BitBlt_DstAddr, smesa->front.offset +
	   (y2-1) * smesa->front.pitch + x2 * smesa->bytesPerPixel);
      MMIO(REG_6326_BitBlt_HeightWidth, ((height-1) << 16) |
	   (width * smesa->bytesPerPixel));
      MMIO_WMB();
      MMIO(REG_6326_BitBlt_Cmd, BLT_PAT_BG);
   }
}

static void
sis_clear_z_buffer(struct gl_context * ctx, GLbitfield mask, GLint x, GLint y,
		   GLint width, GLint height)
{
   sisContextPtr smesa = SIS_CONTEXT(ctx);

   mWait3DCmdQueue(6);
   MMIO(REG_6326_BitBlt_DstAddr,
	smesa->depth.offset + y * smesa->depth.pitch + x * 2);
   MMIO(REG_6326_BitBlt_DstSrcPitch, smesa->depth.pitch << 16);
   MMIO(REG_6326_BitBlt_HeightWidth, ((height-1) << 16) | (width * 2));
   MMIO(REG_6326_BitBlt_fgColor, SiS_ROP_PATCOPY | smesa->clearZStencilPattern);
   MMIO(REG_6326_BitBlt_bgColor, SiS_ROP_PATCOPY | smesa->clearZStencilPattern);
   MMIO_WMB();
   MMIO(REG_6326_BitBlt_Cmd, BLT_PAT_BG | BLT_XINC | BLT_YINC);
}

@


1.3
log
@Merge Mesa 7.10.3
@
text
@@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d37 1
a37 1
static void sis_clear_front_buffer(GLcontext *ctx, GLenum mask, GLint x,
d39 1
a39 1
static void sis_clear_back_buffer(GLcontext *ctx, GLenum mask, GLint x,
d41 1
a41 1
static void sis_clear_z_buffer(GLcontext * ctx, GLbitfield mask, GLint x,
d72 1
a72 1
sis6326DDClear(GLcontext *ctx, GLbitfield mask)
d117 1
a117 1
sis6326DDClearColor(GLcontext *ctx, const GLfloat color[4])
d131 1
a131 1
sis6326DDClearDepth(GLcontext *ctx, GLclampd d)
d139 1
a139 1
sis_clear_back_buffer(GLcontext *ctx, GLenum mask, GLint x, GLint y,
d163 1
a163 1
sis_clear_front_buffer(GLcontext *ctx, GLenum mask, GLint x, GLint y,
d214 1
a214 1
sis_clear_z_buffer(GLcontext * ctx, GLbitfield mask, GLint x, GLint y,
@


1.1
log
@Initial revision
@
text
@d35 1
a35 1
#include "macros.h"
d72 1
a72 2
sis6326DDClear(GLcontext *ctx, GLbitfield mask, GLboolean all,
       GLint x, GLint y, GLint width, GLint height)
d77 6
a82 2
   if (all) {
      GLframebuffer *buffer = ctx->DrawBuffer;
a83 10
      x1 = 0;
      y1 = 0;
      width1 = buffer->Width;
      height1 = buffer->Height;
   } else {
      x1 = x;
      y1 = Y_FLIP(y+height-1);
      width1 = width;
      height1 = height;
   }
d112 1
a112 1
      _swrast_Clear(ctx, mask, all, x1, y1, width, height);
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d72 2
a73 1
sis6326DDClear(GLcontext *ctx, GLbitfield mask)
d78 2
a79 6
   /* get region after locking: */
   x1 = ctx->DrawBuffer->_Xmin;
   y1 = ctx->DrawBuffer->_Ymin;
   width1 = ctx->DrawBuffer->_Xmax - x1;
   height1 = ctx->DrawBuffer->_Ymax - y1;
   y1 = Y_FLIP(y1 + height1 - 1);
d81 10
d119 1
a119 1
      _swrast_Clear(ctx, mask);
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d35 1
a35 1
#include "main/macros.h"
d37 1
a37 1
static void sis_clear_front_buffer(struct gl_context *ctx, GLenum mask, GLint x,
d39 1
a39 1
static void sis_clear_back_buffer(struct gl_context *ctx, GLenum mask, GLint x,
d41 1
a41 1
static void sis_clear_z_buffer(struct gl_context * ctx, GLbitfield mask, GLint x,
d72 1
a72 1
sis6326DDClear(struct gl_context *ctx, GLbitfield mask)
d117 1
a117 1
sis6326DDClearColor(struct gl_context *ctx, const GLfloat color[4])
d131 1
a131 1
sis6326DDClearDepth(struct gl_context *ctx, GLclampd d)
d139 1
a139 1
sis_clear_back_buffer(struct gl_context *ctx, GLenum mask, GLint x, GLint y,
d163 1
a163 1
sis_clear_front_buffer(struct gl_context *ctx, GLenum mask, GLint x, GLint y,
d214 1
a214 1
sis_clear_z_buffer(struct gl_context * ctx, GLbitfield mask, GLint x, GLint y,
@


