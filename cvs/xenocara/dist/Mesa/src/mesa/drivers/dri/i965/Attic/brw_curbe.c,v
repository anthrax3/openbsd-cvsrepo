head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.04.17;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.15;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.41;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.41;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.28.32;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.15.29;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.49;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.11.32;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.48.38;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics to
 develop this 3D driver.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */



#include "main/glheader.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/enums.h"
#include "program/prog_parameter.h"
#include "program/prog_print.h"
#include "program/prog_statevars.h"
#include "intel_batchbuffer.h"
#include "brw_context.h"
#include "brw_defines.h"
#include "brw_state.h"
#include "brw_util.h"


/**
 * Partition the CURBE between the various users of constant values:
 * Note that vertex and fragment shaders can now fetch constants out
 * of constant buffers.  We no longer allocatea block of the GRF for
 * constants.  That greatly reduces the demand for space in the CURBE.
 * Some of the comments within are dated...
 */
static void calculate_curbe_offsets( struct brw_context *brw )
{
   struct gl_context *ctx = &brw->ctx;
   /* CACHE_NEW_WM_PROG */
   const GLuint nr_fp_regs = (brw->wm.prog_data->base.nr_params + 15) / 16;

   /* BRW_NEW_VERTEX_PROGRAM */
   const GLuint nr_vp_regs = (brw->vs.prog_data->base.base.nr_params + 15) / 16;
   GLuint nr_clip_regs = 0;
   GLuint total_regs;

   /* _NEW_TRANSFORM */
   if (ctx->Transform.ClipPlanesEnabled) {
      GLuint nr_planes = 6 + _mesa_bitcount_64(ctx->Transform.ClipPlanesEnabled);
      nr_clip_regs = (nr_planes * 4 + 15) / 16;
   }


   total_regs = nr_fp_regs + nr_vp_regs + nr_clip_regs;

   /* This can happen - what to do?  Probably rather than falling
    * back, the best thing to do is emit programs which code the
    * constants as immediate values.  Could do this either as a static
    * cap on WM and VS, or adaptively.
    *
    * Unfortunately, this is currently dependent on the results of the
    * program generation process (in the case of wm), so this would
    * introduce the need to re-generate programs in the event of a
    * curbe allocation failure.
    */
   /* Max size is 32 - just large enough to
    * hold the 128 parameters allowed by
    * the fragment and vertex program
    * api's.  It's not clear what happens
    * when both VP and FP want to use 128
    * parameters, though.
    */
   assert(total_regs <= 32);

   /* Lazy resize:
    */
   if (nr_fp_regs > brw->curbe.wm_size ||
       nr_vp_regs > brw->curbe.vs_size ||
       nr_clip_regs != brw->curbe.clip_size ||
       (total_regs < brw->curbe.total_size / 4 &&
	brw->curbe.total_size > 16)) {

      GLuint reg = 0;

      /* Calculate a new layout:
       */
      reg = 0;
      brw->curbe.wm_start = reg;
      brw->curbe.wm_size = nr_fp_regs; reg += nr_fp_regs;
      brw->curbe.clip_start = reg;
      brw->curbe.clip_size = nr_clip_regs; reg += nr_clip_regs;
      brw->curbe.vs_start = reg;
      brw->curbe.vs_size = nr_vp_regs; reg += nr_vp_regs;
      brw->curbe.total_size = reg;

      if (0)
	 fprintf(stderr, "curbe wm %d+%d clip %d+%d vs %d+%d\n",
                 brw->curbe.wm_start,
                 brw->curbe.wm_size,
                 brw->curbe.clip_start,
                 brw->curbe.clip_size,
                 brw->curbe.vs_start,
                 brw->curbe.vs_size );

      brw->state.dirty.brw |= BRW_NEW_CURBE_OFFSETS;
   }
}


const struct brw_tracked_state brw_curbe_offsets = {
   .dirty = {
      .mesa = _NEW_TRANSFORM,
      .brw  = BRW_NEW_VERTEX_PROGRAM | BRW_NEW_CONTEXT,
      .cache = CACHE_NEW_WM_PROG
   },
   .emit = calculate_curbe_offsets
};




/* Define the number of curbes within CS's urb allocation.  Multiple
 * urb entries -> multiple curbes.  These will be used by
 * fixed-function hardware in a double-buffering scheme to avoid a
 * pipeline stall each time the contents of the curbe is changed.
 */
void brw_upload_cs_urb_state(struct brw_context *brw)
{
   BEGIN_BATCH(2);
   /* It appears that this is the state packet for the CS unit, ie. the
    * urb entries detailed here are housed in the CS range from the
    * URB_FENCE command.
    */
   OUT_BATCH(CMD_CS_URB_STATE << 16 | (2-2));

   /* BRW_NEW_URB_FENCE */
   if (brw->urb.csize == 0) {
      OUT_BATCH(0);
   } else {
      /* BRW_NEW_URB_FENCE */
      assert(brw->urb.nr_cs_entries);
      OUT_BATCH((brw->urb.csize - 1) << 4 | brw->urb.nr_cs_entries);
   }
   ADVANCE_BATCH();
}

static GLfloat fixed_plane[6][4] = {
   { 0,    0,   -1, 1 },
   { 0,    0,    1, 1 },
   { 0,   -1,    0, 1 },
   { 0,    1,    0, 1 },
   {-1,    0,    0, 1 },
   { 1,    0,    0, 1 }
};

/* Upload a new set of constants.  Too much variability to go into the
 * cache mechanism, but maybe would benefit from a comparison against
 * the current uploaded set of constants.
 */
static void
brw_upload_constant_buffer(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   const GLuint sz = brw->curbe.total_size;
   const GLuint bufsz = sz * 16 * sizeof(GLfloat);
   GLfloat *buf;
   GLuint i;
   gl_clip_plane *clip_planes;

   if (sz == 0) {
      brw->curbe.last_bufsz  = 0;
      goto emit;
   }

   buf = brw->curbe.next_buf;

   /* fragment shader constants */
   if (brw->curbe.wm_size) {
      GLuint offset = brw->curbe.wm_start * 16;

      /* copy float constants */
      for (i = 0; i < brw->wm.prog_data->base.nr_params; i++) {
	 buf[offset + i] = *brw->wm.prog_data->base.param[i];
      }
   }

   /* clipper constants */
   if (brw->curbe.clip_size) {
      GLuint offset = brw->curbe.clip_start * 16;
      GLuint j;

      /* If any planes are going this way, send them all this way:
       */
      for (i = 0; i < 6; i++) {
	 buf[offset + i * 4 + 0] = fixed_plane[i][0];
	 buf[offset + i * 4 + 1] = fixed_plane[i][1];
	 buf[offset + i * 4 + 2] = fixed_plane[i][2];
	 buf[offset + i * 4 + 3] = fixed_plane[i][3];
      }

      /* Clip planes: _NEW_TRANSFORM plus _NEW_PROJECTION to get to
       * clip-space:
       */
      clip_planes = brw_select_clip_planes(ctx);
      for (j = 0; j < MAX_CLIP_PLANES; j++) {
	 if (ctx->Transform.ClipPlanesEnabled & (1<<j)) {
	    buf[offset + i * 4 + 0] = clip_planes[j][0];
	    buf[offset + i * 4 + 1] = clip_planes[j][1];
	    buf[offset + i * 4 + 2] = clip_planes[j][2];
	    buf[offset + i * 4 + 3] = clip_planes[j][3];
	    i++;
	 }
      }
   }

   /* vertex shader constants */
   if (brw->curbe.vs_size) {
      GLuint offset = brw->curbe.vs_start * 16;

      for (i = 0; i < brw->vs.prog_data->base.base.nr_params; i++) {
         buf[offset + i] = *brw->vs.prog_data->base.base.param[i];
      }
   }

   if (0) {
      for (i = 0; i < sz*16; i+=4)
	 fprintf(stderr, "curbe %d.%d: %f %f %f %f\n", i/8, i&4,
                 buf[i+0], buf[i+1], buf[i+2], buf[i+3]);

      fprintf(stderr, "last_buf %p buf %p sz %d/%d cmp %d\n",
              brw->curbe.last_buf, buf,
              bufsz, brw->curbe.last_bufsz,
              brw->curbe.last_buf ? memcmp(buf, brw->curbe.last_buf, bufsz) : -1);
   }

   if (brw->curbe.curbe_bo != NULL &&
       bufsz == brw->curbe.last_bufsz &&
       memcmp(buf, brw->curbe.last_buf, bufsz) == 0) {
      /* constants have not changed */
   } else {
      /* Update the record of what our last set of constants was.  We
       * don't just flip the pointers because we don't fill in the
       * data in the padding between the entries.
       */
      memcpy(brw->curbe.last_buf, buf, bufsz);
      brw->curbe.last_bufsz = bufsz;

      if (brw->curbe.curbe_bo != NULL &&
	  brw->curbe.curbe_next_offset + bufsz > brw->curbe.curbe_bo->size)
      {
	 drm_intel_gem_bo_unmap_gtt(brw->curbe.curbe_bo);
	 drm_intel_bo_unreference(brw->curbe.curbe_bo);
	 brw->curbe.curbe_bo = NULL;
      }

      if (brw->curbe.curbe_bo == NULL) {
	 /* Allocate a single page for CURBE entries for this batchbuffer.
	  * They're generally around 64b.
	  */
	 brw->curbe.curbe_bo = drm_intel_bo_alloc(brw->bufmgr, "CURBE",
						  4096, 1 << 6);
	 brw->curbe.curbe_next_offset = 0;
	 drm_intel_gem_bo_map_gtt(brw->curbe.curbe_bo);
	 assert(bufsz < 4096);
      }

      brw->curbe.curbe_offset = brw->curbe.curbe_next_offset;
      brw->curbe.curbe_next_offset += bufsz;
      brw->curbe.curbe_next_offset = ALIGN(brw->curbe.curbe_next_offset, 64);

      /* Copy data to the buffer:
       */
      memcpy(brw->curbe.curbe_bo->virtual + brw->curbe.curbe_offset,
	     buf,
	     bufsz);
   }

   /* Because this provokes an action (ie copy the constants into the
    * URB), it shouldn't be shortcircuited if identical to the
    * previous time - because eg. the urb destination may have
    * changed, or the urb contents different to last time.
    *
    * Note that the data referred to is actually copied internally,
    * not just used in place according to passed pointer.
    *
    * It appears that the CS unit takes care of using each available
    * URB entry (Const URB Entry == CURBE) in turn, and issuing
    * flushes as necessary when doublebuffering of CURBEs isn't
    * possible.
    */

emit:
   BEGIN_BATCH(2);
   if (brw->curbe.total_size == 0) {
      OUT_BATCH((CMD_CONST_BUFFER << 16) | (2 - 2));
      OUT_BATCH(0);
   } else {
      OUT_BATCH((CMD_CONST_BUFFER << 16) | (1 << 8) | (2 - 2));
      OUT_RELOC(brw->curbe.curbe_bo,
		I915_GEM_DOMAIN_INSTRUCTION, 0,
		(brw->curbe.total_size - 1) + brw->curbe.curbe_offset);
   }
   ADVANCE_BATCH();
}

const struct brw_tracked_state brw_constant_buffer = {
   .dirty = {
      .mesa = _NEW_PROGRAM_CONSTANTS,
      .brw  = (BRW_NEW_FRAGMENT_PROGRAM |
	       BRW_NEW_VERTEX_PROGRAM |
	       BRW_NEW_URB_FENCE | /* Implicit - hardware requires this, not used above */
	       BRW_NEW_PSP | /* Implicit - hardware requires this, not used above */
	       BRW_NEW_CURBE_OFFSETS |
	       BRW_NEW_BATCH),
      .cache = (CACHE_NEW_WM_PROG)
   },
   .emit = brw_upload_constant_buffer,
};

@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a31 19
/** @@file brw_curbe.c
 *
 * Push constant handling for gen4/5.
 *
 * Push constants are constant values (such as GLSL uniforms) that are
 * pre-loaded into a shader stage's register space at thread spawn time.  On
 * gen4 and gen5, we create a blob in memory containing all the push constants
 * for all the stages in order.  At CMD_CONST_BUFFER time that blob is loaded
 * into URB space as a constant URB entry (CURBE) so that it can be accessed
 * quickly at thread setup time.  Each individual fixed function unit's state
 * (brw_vs_state.c for example) tells the hardware which subset of the CURBE
 * it wants in its register space, and we calculate those areas here under the
 * BRW_NEW_CURBE_OFFSETS state flag.  The brw_urb.c allocation will control
 * how many CURBEs can be loaded into the hardware at once before a pipeline
 * stall occurs at CMD_CONST_BUFFER time.
 *
 * On gen6+, constant handling becomes a much simpler set of per-unit state.
 * See gen6_upload_vec4_push_constants() in gen6_vs_state.c for that code.
 */
a41 1
#include "intel_buffer_objects.h"
d49 5
a53 5
 * Partition the CURBE between the various users of constant values.
 *
 * If the users all fit within the previous allocatation, we avoid changing
 * the layout because that means reuploading all unit state and uploading new
 * constant buffers.
d61 1
a61 1
   /* CACHE_NEW_VS_PROG */
d75 4
a78 3
   /* The CURBE allocation size is limited to 32 512-bit units (128 EU
    * registers, or 1024 floats).  See CS_URB_STATE in the gen4 or gen5
    * (volume 1, part 1) PRMs.
d80 11
a90 5
    * Note that in brw_fs.cpp we're only loading up to 16 EU registers of
    * values as push constants before spilling to pull constants, and in
    * brw_vec4.cpp we're loading up to 32 registers of push constants.  An EU
    * register is 1/2 of one of these URB entry units, so that leaves us 16 EU
    * regs for clip.
d132 2
a133 2
      .brw  = BRW_NEW_CONTEXT,
      .cache = CACHE_NEW_VS_PROG | CACHE_NEW_WM_PROG
d141 4
a144 7
/** Uploads the CS_URB_STATE packet.
 *
 * Just like brw_vs_state.c and brw_wm_state.c define a URB entry size and
 * number of entries for their stages, constant buffers do so using this state
 * packet.  Having multiple CURBEs in the URB at the same time allows the
 * hardware to avoid a pipeline stall between primitives using different
 * constant buffer contents.
d149 4
d175 3
a177 4
/**
 * Gathers together all the uniform values into a block of memory to be
 * uploaded into the CURBE, then emits the state packet telling the hardware
 * the new location.
a182 1
   /* BRW_NEW_CURBE_OFFSETS */
d185 1
a185 1
   gl_constant_value *buf;
d190 1
d194 1
a194 4
   buf = intel_upload_space(brw, bufsz, 64,
                            &brw->curbe.curbe_bo, &brw->curbe.curbe_offset);

   STATIC_ASSERT(sizeof(gl_constant_value) == sizeof(float));
a197 1
      /* BRW_NEW_CURBE_OFFSETS */
d200 1
a200 1
      /* CACHE_NEW_WM_PROG | _NEW_PROGRAM_CONSTANTS: copy uniform values */
d214 4
a217 4
	 buf[offset + i * 4 + 0].f = fixed_plane[i][0];
	 buf[offset + i * 4 + 1].f = fixed_plane[i][1];
	 buf[offset + i * 4 + 2].f = fixed_plane[i][2];
	 buf[offset + i * 4 + 3].f = fixed_plane[i][3];
d226 4
a229 4
	    buf[offset + i * 4 + 0].f = clip_planes[j][0];
	    buf[offset + i * 4 + 1].f = clip_planes[j][1];
	    buf[offset + i * 4 + 2].f = clip_planes[j][2];
	    buf[offset + i * 4 + 3].f = clip_planes[j][3];
a238 1
      /* CACHE_NEW_VS_PROG | _NEW_PROGRAM_CONSTANTS: copy uniform values */
d247 48
a294 1
                 buf[i+0].f, buf[i+1].f, buf[i+2].f, buf[i+3].f);
a311 21
   /* Work around mysterious 965 hangs that appear to happen if you do
    * two 3DPRIMITIVEs with only a CONSTANT_BUFFER inbetween.  If we
    * haven't already flushed for some other reason, explicitly do so.
    *
    * We've found no documented reason why this should be necessary.
    */
   if (brw->gen == 4 && !brw->is_g4x &&
       (brw->state.dirty.brw & (BRW_NEW_BATCH | BRW_NEW_PSP)) == 0) {
      BEGIN_BATCH(1);
      OUT_BATCH(MI_FLUSH);
      ADVANCE_BATCH();
   }

   /* BRW_NEW_URB_FENCE: From the gen4 PRM, volume 1, section 3.9.8
    * (CONSTANT_BUFFER (CURBE Load)):
    *
    *     "Modifying the CS URB allocation via URB_FENCE invalidates any
    *      previous CURBE entries. Therefore software must subsequently
    *      [re]issue a CONSTANT_BUFFER command before CURBE data can be used
    *      in the pipeline."
    */
d328 3
a330 1
      .brw  = (BRW_NEW_URB_FENCE |
d334 1
a334 2
      .cache = (CACHE_NEW_VS_PROG |
                CACHE_NEW_WM_PROG)
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d32 19
d61 1
d69 5
a73 5
 * Partition the CURBE between the various users of constant values:
 * Note that vertex and fragment shaders can now fetch constants out
 * of constant buffers.  We no longer allocatea block of the GRF for
 * constants.  That greatly reduces the demand for space in the CURBE.
 * Some of the comments within are dated...
d81 1
a81 1
   /* BRW_NEW_VERTEX_PROGRAM */
d95 3
a97 4
   /* This can happen - what to do?  Probably rather than falling
    * back, the best thing to do is emit programs which code the
    * constants as immediate values.  Could do this either as a static
    * cap on WM and VS, or adaptively.
d99 5
a103 11
    * Unfortunately, this is currently dependent on the results of the
    * program generation process (in the case of wm), so this would
    * introduce the need to re-generate programs in the event of a
    * curbe allocation failure.
    */
   /* Max size is 32 - just large enough to
    * hold the 128 parameters allowed by
    * the fragment and vertex program
    * api's.  It's not clear what happens
    * when both VP and FP want to use 128
    * parameters, though.
d145 2
a146 2
      .brw  = BRW_NEW_VERTEX_PROGRAM | BRW_NEW_CONTEXT,
      .cache = CACHE_NEW_WM_PROG
d154 7
a160 4
/* Define the number of curbes within CS's urb allocation.  Multiple
 * urb entries -> multiple curbes.  These will be used by
 * fixed-function hardware in a double-buffering scheme to avoid a
 * pipeline stall each time the contents of the curbe is changed.
a164 4
   /* It appears that this is the state packet for the CS unit, ie. the
    * urb entries detailed here are housed in the CS range from the
    * URB_FENCE command.
    */
d187 4
a190 3
/* Upload a new set of constants.  Too much variability to go into the
 * cache mechanism, but maybe would benefit from a comparison against
 * the current uploaded set of constants.
d196 1
d199 1
a199 1
   GLfloat *buf;
a203 1
      brw->curbe.last_bufsz  = 0;
d207 4
a210 1
   buf = brw->curbe.next_buf;
d214 1
d217 1
a217 1
      /* copy float constants */
d231 4
a234 4
	 buf[offset + i * 4 + 0] = fixed_plane[i][0];
	 buf[offset + i * 4 + 1] = fixed_plane[i][1];
	 buf[offset + i * 4 + 2] = fixed_plane[i][2];
	 buf[offset + i * 4 + 3] = fixed_plane[i][3];
d243 4
a246 4
	    buf[offset + i * 4 + 0] = clip_planes[j][0];
	    buf[offset + i * 4 + 1] = clip_planes[j][1];
	    buf[offset + i * 4 + 2] = clip_planes[j][2];
	    buf[offset + i * 4 + 3] = clip_planes[j][3];
d256 1
d265 1
a265 48
                 buf[i+0], buf[i+1], buf[i+2], buf[i+3]);

      fprintf(stderr, "last_buf %p buf %p sz %d/%d cmp %d\n",
              brw->curbe.last_buf, buf,
              bufsz, brw->curbe.last_bufsz,
              brw->curbe.last_buf ? memcmp(buf, brw->curbe.last_buf, bufsz) : -1);
   }

   if (brw->curbe.curbe_bo != NULL &&
       bufsz == brw->curbe.last_bufsz &&
       memcmp(buf, brw->curbe.last_buf, bufsz) == 0) {
      /* constants have not changed */
   } else {
      /* Update the record of what our last set of constants was.  We
       * don't just flip the pointers because we don't fill in the
       * data in the padding between the entries.
       */
      memcpy(brw->curbe.last_buf, buf, bufsz);
      brw->curbe.last_bufsz = bufsz;

      if (brw->curbe.curbe_bo != NULL &&
	  brw->curbe.curbe_next_offset + bufsz > brw->curbe.curbe_bo->size)
      {
	 drm_intel_gem_bo_unmap_gtt(brw->curbe.curbe_bo);
	 drm_intel_bo_unreference(brw->curbe.curbe_bo);
	 brw->curbe.curbe_bo = NULL;
      }

      if (brw->curbe.curbe_bo == NULL) {
	 /* Allocate a single page for CURBE entries for this batchbuffer.
	  * They're generally around 64b.
	  */
	 brw->curbe.curbe_bo = drm_intel_bo_alloc(brw->bufmgr, "CURBE",
						  4096, 1 << 6);
	 brw->curbe.curbe_next_offset = 0;
	 drm_intel_gem_bo_map_gtt(brw->curbe.curbe_bo);
	 assert(bufsz < 4096);
      }

      brw->curbe.curbe_offset = brw->curbe.curbe_next_offset;
      brw->curbe.curbe_next_offset += bufsz;
      brw->curbe.curbe_next_offset = ALIGN(brw->curbe.curbe_next_offset, 64);

      /* Copy data to the buffer:
       */
      memcpy(brw->curbe.curbe_bo->virtual + brw->curbe.curbe_offset,
	     buf,
	     bufsz);
d283 21
d320 1
a320 3
      .brw  = (BRW_NEW_FRAGMENT_PROGRAM |
	       BRW_NEW_VERTEX_PROGRAM |
	       BRW_NEW_URB_FENCE | /* Implicit - hardware requires this, not used above */
d324 2
a325 1
      .cache = (CACHE_NEW_WM_PROG)
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
d5 1
a5 1
 
d13 1
a13 1
 
d17 1
a17 1
 
d25 1
a25 1
 
d29 1
a29 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
a41 1
#include "intel_regions.h"
d59 2
a60 2
   const GLuint nr_fp_regs = (brw->wm.prog_data->nr_params + 15) / 16;
   
d62 1
a62 1
   const GLuint nr_vp_regs = (brw->vs.prog_data->base.nr_params + 15) / 16;
d90 1
a90 1
    * parameters, though. 
d104 1
a104 1
      /* Calculate a new layout: 
d116 7
a122 7
	 printf("curbe wm %d+%d clip %d+%d vs %d+%d\n",
		brw->curbe.wm_start,
		brw->curbe.wm_size,
		brw->curbe.clip_start,
		brw->curbe.clip_size,
		brw->curbe.vs_start,
		brw->curbe.vs_size );
d163 1
a163 1
   CACHED_BATCH();
d201 2
a202 2
      for (i = 0; i < brw->wm.prog_data->nr_params; i++) {
	 buf[offset + i] = *brw->wm.prog_data->param[i];
d239 2
a240 2
      for (i = 0; i < brw->vs.prog_data->base.nr_params; i++) {
         buf[offset + i] = *brw->vs.prog_data->base.param[i];
d245 8
a252 8
      for (i = 0; i < sz*16; i+=4) 
	 printf("curbe %d.%d: %f %f %f %f\n", i/8, i&4,
		buf[i+0], buf[i+1], buf[i+2], buf[i+3]);

      printf("last_buf %p buf %p sz %d/%d cmp %d\n",
	     brw->curbe.last_buf, buf,
	     bufsz, brw->curbe.last_bufsz,
	     brw->curbe.last_buf ? memcmp(buf, brw->curbe.last_buf, bufsz) : -1);
d334 1
a334 1
      .cache = (CACHE_NEW_WM_PROG) 
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d58 1
a58 1
   struct gl_context *ctx = &brw->intel.ctx;
d63 1
a63 1
   const GLuint nr_vp_regs = (brw->vs.prog_data->nr_params + 15) / 16;
d69 1
a69 1
      GLuint nr_planes = 6 + brw_count_bits(ctx->Transform.ClipPlanesEnabled);
d136 1
a136 1
   .prepare = calculate_curbe_offsets
a148 2
   struct intel_context *intel = &brw->intel;

d180 2
a181 1
static void prepare_constant_buffer(struct brw_context *brw)
d183 1
a183 3
   struct gl_context *ctx = &brw->intel.ctx;
   const struct brw_vertex_program *vp =
      brw_vertex_program_const(brw->vertex_program);
d188 1
d192 1
a192 1
      return;
d203 1
a203 2
	 buf[offset + i] = convert_param(brw->wm.prog_data->param_convert[i],
					 *brw->wm.prog_data->param[i]);
d207 1
a207 4

   /* The clipplanes are actually delivered to both CLIP and VS units.
    * VS uses them to calculate the outcode bitmasks.
    */
d224 1
a224 1
      assert(MAX_CLIP_PLANES == 6);
d227 4
a230 4
	    buf[offset + i * 4 + 0] = ctx->Transform._ClipUserPlane[j][0];
	    buf[offset + i * 4 + 1] = ctx->Transform._ClipUserPlane[j][1];
	    buf[offset + i * 4 + 2] = ctx->Transform._ClipUserPlane[j][2];
	    buf[offset + i * 4 + 3] = ctx->Transform._ClipUserPlane[j][3];
a238 1
      GLuint nr = brw->vs.prog_data->nr_params / 4;
d240 2
a241 10
      /* Load the subset of push constants that will get used when
       * we also have a pull constant buffer.
       */
      for (i = 0; i < vp->program.Base.Parameters->NumParameters; i++) {
	 if (brw->vs.constant_map[i] != -1) {
	    assert(brw->vs.constant_map[i] <= nr);
	    memcpy(buf + offset + brw->vs.constant_map[i] * 4,
		   vp->program.Base.Parameters->ParameterValues[i],
		   4 * sizeof(float));
	 }
d280 1
a280 1
	 brw->curbe.curbe_bo = drm_intel_bo_alloc(brw->intel.bufmgr, "CURBE",
a297 2
   brw_add_validated_bo(brw, brw->curbe.curbe_bo);

a310 6
}

static void emit_constant_buffer(struct brw_context *brw)
{
   struct intel_context *intel = &brw->intel;
   GLuint sz = brw->curbe.total_size;
d312 1
d314 1
a314 1
   if (sz == 0) {
d321 1
a321 1
		(sz - 1) + brw->curbe.curbe_offset);
a325 6
/* This tracked state is unique in that the state it monitors varies
 * dynamically depending on the parameters tracked by the fragment and
 * vertex programs.  This is the template used as a starting point,
 * each context will maintain a copy of this internally and update as
 * required.
 */
d337 1
a337 2
   .prepare = prepare_constant_buffer,
   .emit = emit_constant_buffer,
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d149 1
a149 2
   struct brw_cs_urb_state cs_urb;
   memset(&cs_urb, 0, sizeof(cs_urb));
d151 1
d156 1
a156 2
   cs_urb.header.opcode = CMD_CS_URB_STATE;
   cs_urb.header.length = sizeof(cs_urb)/4 - 2;
d159 8
a166 5
   cs_urb.bits0.nr_urb_entries = brw->urb.nr_cs_entries;
   cs_urb.bits0.urb_entry_size = brw->urb.csize - 1;

   assert(brw->urb.nr_cs_entries);
   BRW_CACHED_BATCH_STRUCT(brw, &cs_urb);
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d38 3
a40 3
#include "shader/prog_parameter.h"
#include "shader/prog_print.h"
#include "shader/prog_statevars.h"
d58 1
a58 1
   GLcontext *ctx = &brw->intel.ctx;
d182 1
a182 1
   GLcontext *ctx = &brw->intel.ctx;
a184 2
   const struct brw_fragment_program *fp =
      brw_fragment_program_const(brw->fragment_program);
d191 1
a191 5
      if (brw->curbe.last_buf) {
	 free(brw->curbe.last_buf);
	 brw->curbe.last_buf = NULL;
	 brw->curbe.last_bufsz  = 0;
      }
d195 1
a195 1
   buf = (GLfloat *) calloc(1, bufsz);
a200 2
      _mesa_load_state_parameters(ctx, fp->program.Base.Parameters); 

d202 4
a205 2
      for (i = 0; i < brw->wm.prog_data->nr_params; i++) 
	 buf[offset + i] = *brw->wm.prog_data->param[i];
d245 2
a246 5
      if (brw->vertex_program->IsNVProgram)
	 _mesa_load_tracked_matrices(ctx);

      /* Updates the ParamaterValues[i] pointers for all parameters of the
       * basic type of PROGRAM_STATE_VAR.
d248 4
a251 17
      _mesa_load_state_parameters(ctx, vp->program.Base.Parameters); 

      if (vp->use_const_buffer) {
	 /* Load the subset of push constants that will get used when
	  * we also have a pull constant buffer.
	  */
	 for (i = 0; i < vp->program.Base.Parameters->NumParameters; i++) {
	    if (brw->vs.constant_map[i] != -1) {
	       assert(brw->vs.constant_map[i] <= nr);
	       memcpy(buf + offset + brw->vs.constant_map[i] * 4,
		      vp->program.Base.Parameters->ParameterValues[i],
		      4 * sizeof(float));
	    }
	 }
      } else {
	 for (i = 0; i < nr; i++) {
	    memcpy(buf + offset + i * 4,
a269 1
       brw->curbe.last_buf &&
d273 6
a278 8
      free(buf);
   } 
   else {
      /* constants have changed */
      if (brw->curbe.last_buf)
	 free(brw->curbe.last_buf);

      brw->curbe.last_buf = buf;
d285 1
a285 1
	 dri_bo_unreference(brw->curbe.curbe_bo);
d293 2
a294 2
	 brw->curbe.curbe_bo = dri_bo_alloc(brw->intel.bufmgr, "CURBE",
					    4096, 1 << 6);
d297 1
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d39 1
d42 1
d49 6
a54 1
/* Partition the CURBE between the various users of constant values:
d60 1
a60 1
   GLuint nr_fp_regs = (brw->wm.prog_data->nr_params + 15) / 16;
d63 1
a63 2
   struct brw_vertex_program *vp = (struct brw_vertex_program *)brw->vertex_program;
   GLuint nr_vp_regs = (vp->program.Base.Parameters->NumParameters * 4 + 15) / 16;
d117 7
a123 7
	 _mesa_printf("curbe wm %d+%d clip %d+%d vs %d+%d\n",
		      brw->curbe.wm_start,
		      brw->curbe.wm_size,
		      brw->curbe.clip_start,
		      brw->curbe.clip_size,
		      brw->curbe.vs_start,
		      brw->curbe.vs_size );
d133 1
a133 1
      .brw  = BRW_NEW_VERTEX_PROGRAM,
d147 1
a147 1
void brw_upload_constant_buffer_state(struct brw_context *brw)
d149 2
a150 2
   struct brw_constant_buffer_state cbs; 
   memset(&cbs, 0, sizeof(cbs));
d156 2
a157 2
   cbs.header.opcode = CMD_CONST_BUFFER_STATE;
   cbs.header.length = sizeof(cbs)/4 - 2;
d160 2
a161 2
   cbs.bits0.nr_urb_entries = brw->urb.nr_cs_entries;
   cbs.bits0.urb_entry_size = brw->urb.csize - 1;
d164 1
a164 1
   BRW_CACHED_BATCH_STRUCT(brw, &cbs);
d183 6
a188 4
   struct brw_vertex_program *vp = (struct brw_vertex_program *)brw->vertex_program;
   struct brw_fragment_program *fp = (struct brw_fragment_program *)brw->fragment_program;
   GLuint sz = brw->curbe.total_size;
   GLuint bufsz = sz * 16 * sizeof(GLfloat);
a191 7
   /* Update our own dependency flags.  This works because this
    * function will also be called whenever fp or vp changes.
    */
   brw->curbe.tracked_state.dirty.mesa = (_NEW_TRANSFORM|_NEW_PROJECTION);
   brw->curbe.tracked_state.dirty.mesa |= vp->program.Base.Parameters->StateFlags;
   brw->curbe.tracked_state.dirty.mesa |= fp->program.Base.Parameters->StateFlags;

a192 1

a197 1

d201 1
a201 3
   buf = (GLfloat *)malloc(bufsz);

   memset(buf, 0, bufsz);
d203 1
d209 1
d211 1
a211 1
	 buf[offset + i] = brw->wm.prog_data->param[i][0];
d246 1
a246 1

d249 1
a249 1
      GLuint nr = vp->program.Base.Parameters->NumParameters;
d251 6
d259 18
a276 5
      for (i = 0; i < nr; i++) {
	 buf[offset + i * 4 + 0] = vp->program.Base.Parameters->ParameterValues[i][0];
	 buf[offset + i * 4 + 1] = vp->program.Base.Parameters->ParameterValues[i][1];
	 buf[offset + i * 4 + 2] = vp->program.Base.Parameters->ParameterValues[i][2];
	 buf[offset + i * 4 + 3] = vp->program.Base.Parameters->ParameterValues[i][3];
d282 2
a283 2
	 _mesa_printf("curbe %d.%d: %f %f %f %f\n", i/8, i&4,
		      buf[i+0], buf[i+1], buf[i+2], buf[i+3]);
d285 4
a288 4
      _mesa_printf("last_buf %p buf %p sz %d/%d cmp %d\n",
		   brw->curbe.last_buf, buf,
		   bufsz, brw->curbe.last_bufsz,
		   brw->curbe.last_buf ? memcmp(buf, brw->curbe.last_buf, bufsz) : -1);
d295 1
d299 1
d302 1
d307 1
a307 2
	  (brw->curbe.need_new_bo ||
	   brw->curbe.curbe_next_offset + bufsz > brw->curbe.curbe_bo->size))
d309 1
d321 1
d330 3
a332 1
      dri_bo_subdata(brw->curbe.curbe_bo, brw->curbe.curbe_offset, bufsz, buf);
a351 1

d357 1
a357 1
   BEGIN_BATCH(2, IGNORE_CLIPRECTS);
d378 1
a378 1
      .mesa = (_NEW_TRANSFORM|_NEW_PROJECTION),      /* plus fp and vp flags */
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d34 4
a37 4
#include "glheader.h"
#include "context.h"
#include "macros.h"
#include "enums.h"
d49 1
a49 1
static int calculate_curbe_offsets( struct brw_context *brw )
d51 1
d62 2
a63 2
   if (brw->attribs.Transform->ClipPlanesEnabled) {
      GLuint nr_planes = 6 + brw_count_bits(brw->attribs.Transform->ClipPlanesEnabled);
a120 1
   return 0;
d159 1
a159 13
}      

#if 0
const struct brw_tracked_state brw_constant_buffer_state = {
   .dirty = {
      .mesa = 0,
      .brw = BRW_NEW_URB_FENCE,
      .cache = 0
   },
   .update = brw_upload_constant_buffer_state
};
#endif

d174 1
a174 1
static int prepare_constant_buffer(struct brw_context *brw)
d188 2
a189 2
   brw->curbe.tracked_state.dirty.mesa |= vp->param_state;
   brw->curbe.tracked_state.dirty.mesa |= fp->param_state;
d198 2
a199 2
       
      return 0;
d237 5
a241 5
	 if (brw->attribs.Transform->ClipPlanesEnabled & (1<<j)) {
	    buf[offset + i * 4 + 0] = brw->attribs.Transform->_ClipUserPlane[j][0];
	    buf[offset + i * 4 + 1] = brw->attribs.Transform->_ClipUserPlane[j][1];
	    buf[offset + i * 4 + 2] = brw->attribs.Transform->_ClipUserPlane[j][2];
	    buf[offset + i * 4 + 3] = brw->attribs.Transform->_ClipUserPlane[j][3];
d286 2
a287 1
	  brw->curbe.curbe_next_offset + bufsz > brw->curbe.curbe_bo->size)
d298 1
a298 4
					    4096, 1 << 6,
					    DRM_BO_FLAG_MEM_LOCAL |
					    DRM_BO_FLAG_CACHED |
					    DRM_BO_FLAG_CACHED_MAPPED);
d311 1
a325 3

   /* check aperture space for this bo */
   return dri_bufmgr_check_aperture_space(brw->curbe.curbe_bo);
d340 2
a341 1
      OUT_RELOC(brw->curbe.curbe_bo, DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_READ,
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@a44 1
#include "brw_aub.h"
d49 1
a49 1
static void calculate_curbe_offsets( struct brw_context *brw )
d120 1
d130 1
a130 1
   .update = calculate_curbe_offsets
d186 1
a186 1
static void upload_constant_buffer(struct brw_context *brw)
a190 1
   struct brw_mem_pool *pool = &brw->pool[BRW_GS_POOL];
a203 7
      struct brw_constant_buffer cb;
      cb.header.opcode = CMD_CONST_BUFFER;
      cb.header.length = sizeof(cb)/4 - 2;
      cb.header.valid = 0;
      cb.bits0.buffer_length = 0;
      cb.bits0.buffer_address = 0;
      BRW_BATCH_STRUCT(brw, &cb);
d211 1
a211 1
      return;
d285 2
a286 1
   if (brw->curbe.last_buf &&
a289 1
/*       return; */
d297 5
a301 8
      
      if (!brw_pool_alloc(pool, 
			  bufsz,
			  6,
			  &brw->curbe.gs_offset)) {
	 _mesa_printf("out of GS memory for curbe\n");
	 assert(0);
	 return;
d303 16
a318 1
            
d322 1
a322 7
      bmBufferSubDataAUB(&brw->intel,
			 pool->buffer,
			 brw->curbe.gs_offset, 
			 bufsz, 
			 buf,
			 DW_CONSTANT_BUFFER,
			 0);
d325 33
a357 32
   /* TODO: only emit the constant_buffer packet when necessary, ie:
      - contents have changed
      - offset has changed
      - hw requirements due to other packets emitted.
   */
   {
      struct brw_constant_buffer cb;
      
      memset(&cb, 0, sizeof(cb));

      cb.header.opcode = CMD_CONST_BUFFER;
      cb.header.length = sizeof(cb)/4 - 2;
      cb.header.valid = 1;
      cb.bits0.buffer_length = sz - 1;
      cb.bits0.buffer_address = brw->curbe.gs_offset >> 6;
      
      /* Because this provokes an action (ie copy the constants into the
       * URB), it shouldn't be shortcircuited if identical to the
       * previous time - because eg. the urb destination may have
       * changed, or the urb contents different to last time.  
       *
       * Note that the data referred to is actually copied internally,
       * not just used in place according to passed pointer.
       *
       * It appears that the CS unit takes care of using each available
       * URB entry (Const URB Entry == CURBE) in turn, and issuing
       * flushes as necessary when doublebuffering of CURBEs isn't
       * possible.
       */
/*       intel_batchbuffer_align(brw->intel.batch, 64, sizeof(cb)); */
      BRW_BATCH_STRUCT(brw, &cb);
/*       intel_batchbuffer_align(brw->intel.batch, 64, 0); */
d359 1
d375 2
a376 1
	       BRW_NEW_CURBE_OFFSETS),
d379 2
a380 1
   .update = upload_constant_buffer
@


1.1
log
@Initial revision
@
text
@d38 2
a39 1
#include "shader/program.h"
d93 1
a93 1
       nr_clip_regs > brw->curbe.clip_size ||
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d38 1
a38 2
#include "shader/prog_parameter.h"
#include "shader/prog_statevars.h"
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d34 6
a39 7
#include "main/glheader.h"
#include "main/context.h"
#include "main/macros.h"
#include "main/enums.h"
#include "program/prog_parameter.h"
#include "program/prog_print.h"
#include "program/prog_statevars.h"
a40 1
#include "intel_regions.h"
d45 1
d48 1
a48 6
/**
 * Partition the CURBE between the various users of constant values:
 * Note that vertex and fragment shaders can now fetch constants out
 * of constant buffers.  We no longer allocatea block of the GRF for
 * constants.  That greatly reduces the demand for space in the CURBE.
 * Some of the comments within are dated...
a51 1
   struct gl_context *ctx = &brw->intel.ctx;
d53 1
a53 1
   const GLuint nr_fp_regs = (brw->wm.prog_data->nr_params + 15) / 16;
d56 2
a57 1
   const GLuint nr_vp_regs = (brw->vs.prog_data->nr_params + 15) / 16;
d62 2
a63 2
   if (ctx->Transform.ClipPlanesEnabled) {
      GLuint nr_planes = 6 + brw_count_bits(ctx->Transform.ClipPlanesEnabled);
d93 1
a93 1
       nr_clip_regs != brw->curbe.clip_size ||
d111 7
a117 7
	 printf("curbe wm %d+%d clip %d+%d vs %d+%d\n",
		brw->curbe.wm_start,
		brw->curbe.wm_size,
		brw->curbe.clip_start,
		brw->curbe.clip_size,
		brw->curbe.vs_start,
		brw->curbe.vs_size );
d127 1
a127 1
      .brw  = BRW_NEW_VERTEX_PROGRAM | BRW_NEW_CONTEXT,
d130 1
a130 1
   .prepare = calculate_curbe_offsets
d141 1
a141 1
void brw_upload_cs_urb_state(struct brw_context *brw)
d143 2
a144 2
   struct brw_cs_urb_state cs_urb;
   memset(&cs_urb, 0, sizeof(cs_urb));
d150 2
a151 2
   cs_urb.header.opcode = CMD_CS_URB_STATE;
   cs_urb.header.length = sizeof(cs_urb)/4 - 2;
d154 2
a155 2
   cs_urb.bits0.nr_urb_entries = brw->urb.nr_cs_entries;
   cs_urb.bits0.urb_entry_size = brw->urb.csize - 1;
d158 14
a171 2
   BRW_CACHED_BATCH_STRUCT(brw, &cs_urb);
}
d186 1
a186 1
static void prepare_constant_buffer(struct brw_context *brw)
d188 6
a193 5
   struct gl_context *ctx = &brw->intel.ctx;
   const struct brw_vertex_program *vp =
      brw_vertex_program_const(brw->vertex_program);
   const GLuint sz = brw->curbe.total_size;
   const GLuint bufsz = sz * 16 * sizeof(GLfloat);
d197 7
d205 14
a218 1
      brw->curbe.last_bufsz  = 0;
d222 3
a224 1
   buf = brw->curbe.next_buf;
a225 1
   /* fragment shader constants */
d229 4
a232 5
      /* copy float constants */
      for (i = 0; i < brw->wm.prog_data->nr_params; i++) {
	 buf[offset + i] = convert_param(brw->wm.prog_data->param_convert[i],
					 *brw->wm.prog_data->param[i]);
      }
d257 5
a261 5
	 if (ctx->Transform.ClipPlanesEnabled & (1<<j)) {
	    buf[offset + i * 4 + 0] = ctx->Transform._ClipUserPlane[j][0];
	    buf[offset + i * 4 + 1] = ctx->Transform._ClipUserPlane[j][1];
	    buf[offset + i * 4 + 2] = ctx->Transform._ClipUserPlane[j][2];
	    buf[offset + i * 4 + 3] = ctx->Transform._ClipUserPlane[j][3];
d267 1
a267 1
   /* vertex shader constants */
d270 1
a270 1
      GLuint nr = brw->vs.prog_data->nr_params / 4;
d272 7
a278 10
      /* Load the subset of push constants that will get used when
       * we also have a pull constant buffer.
       */
      for (i = 0; i < vp->program.Base.Parameters->NumParameters; i++) {
	 if (brw->vs.constant_map[i] != -1) {
	    assert(brw->vs.constant_map[i] <= nr);
	    memcpy(buf + offset + brw->vs.constant_map[i] * 4,
		   vp->program.Base.Parameters->ParameterValues[i],
		   4 * sizeof(float));
	 }
d284 2
a285 2
	 printf("curbe %d.%d: %f %f %f %f\n", i/8, i&4,
		buf[i+0], buf[i+1], buf[i+2], buf[i+3]);
d287 4
a290 4
      printf("last_buf %p buf %p sz %d/%d cmp %d\n",
	     brw->curbe.last_buf, buf,
	     bufsz, brw->curbe.last_bufsz,
	     brw->curbe.last_buf ? memcmp(buf, brw->curbe.last_buf, bufsz) : -1);
d293 1
a293 1
   if (brw->curbe.curbe_bo != NULL &&
d296 7
a302 7
      /* constants have not changed */
   } else {
      /* Update the record of what our last set of constants was.  We
       * don't just flip the pointers because we don't fill in the
       * data in the padding between the entries.
       */
      memcpy(brw->curbe.last_buf, buf, bufsz);
d305 8
a312 17
      if (brw->curbe.curbe_bo != NULL &&
	  brw->curbe.curbe_next_offset + bufsz > brw->curbe.curbe_bo->size)
      {
	 drm_intel_gem_bo_unmap_gtt(brw->curbe.curbe_bo);
	 drm_intel_bo_unreference(brw->curbe.curbe_bo);
	 brw->curbe.curbe_bo = NULL;
      }

      if (brw->curbe.curbe_bo == NULL) {
	 /* Allocate a single page for CURBE entries for this batchbuffer.
	  * They're generally around 64b.
	  */
	 brw->curbe.curbe_bo = drm_intel_bo_alloc(brw->intel.bufmgr, "CURBE",
						  4096, 1 << 6);
	 brw->curbe.curbe_next_offset = 0;
	 drm_intel_gem_bo_map_gtt(brw->curbe.curbe_bo);
	 assert(bufsz < 4096);
d314 1
a314 4

      brw->curbe.curbe_offset = brw->curbe.curbe_next_offset;
      brw->curbe.curbe_next_offset += bufsz;
      brw->curbe.curbe_next_offset = ALIGN(brw->curbe.curbe_next_offset, 64);
d318 7
a324 3
      memcpy(brw->curbe.curbe_bo->virtual + brw->curbe.curbe_offset,
	     buf,
	     bufsz);
d327 32
a358 31
   brw_add_validated_bo(brw, brw->curbe.curbe_bo);

   /* Because this provokes an action (ie copy the constants into the
    * URB), it shouldn't be shortcircuited if identical to the
    * previous time - because eg. the urb destination may have
    * changed, or the urb contents different to last time.
    *
    * Note that the data referred to is actually copied internally,
    * not just used in place according to passed pointer.
    *
    * It appears that the CS unit takes care of using each available
    * URB entry (Const URB Entry == CURBE) in turn, and issuing
    * flushes as necessary when doublebuffering of CURBEs isn't
    * possible.
    */
}

static void emit_constant_buffer(struct brw_context *brw)
{
   struct intel_context *intel = &brw->intel;
   GLuint sz = brw->curbe.total_size;

   BEGIN_BATCH(2);
   if (sz == 0) {
      OUT_BATCH((CMD_CONST_BUFFER << 16) | (2 - 2));
      OUT_BATCH(0);
   } else {
      OUT_BATCH((CMD_CONST_BUFFER << 16) | (1 << 8) | (2 - 2));
      OUT_RELOC(brw->curbe.curbe_bo,
		I915_GEM_DOMAIN_INSTRUCTION, 0,
		(sz - 1) + brw->curbe.curbe_offset);
a359 1
   ADVANCE_BATCH();
d370 1
a370 1
      .mesa = _NEW_PROGRAM_CONSTANTS,
d375 1
a375 2
	       BRW_NEW_CURBE_OFFSETS |
	       BRW_NEW_BATCH),
d378 1
a378 2
   .prepare = prepare_constant_buffer,
   .emit = emit_constant_buffer,
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d58 1
a58 1
   struct gl_context *ctx = &brw->ctx;
d63 1
a63 1
   const GLuint nr_vp_regs = (brw->vs.prog_data->base.nr_params + 15) / 16;
d69 1
a69 1
      GLuint nr_planes = 6 + _mesa_bitcount_64(ctx->Transform.ClipPlanesEnabled);
d136 1
a136 1
   .emit = calculate_curbe_offsets
d149 3
a151 1
   BEGIN_BATCH(2);
d156 2
a157 1
   OUT_BATCH(CMD_CS_URB_STATE << 16 | (2-2));
d160 5
a164 8
   if (brw->urb.csize == 0) {
      OUT_BATCH(0);
   } else {
      /* BRW_NEW_URB_FENCE */
      assert(brw->urb.nr_cs_entries);
      OUT_BATCH((brw->urb.csize - 1) << 4 | brw->urb.nr_cs_entries);
   }
   CACHED_BATCH();
d180 1
a180 2
static void
brw_upload_constant_buffer(struct brw_context *brw)
d182 3
a184 1
   struct gl_context *ctx = &brw->ctx;
a188 1
   gl_clip_plane *clip_planes;
d192 1
a192 1
      goto emit;
d203 2
a204 1
	 buf[offset + i] = *brw->wm.prog_data->param[i];
d208 4
a211 1
   /* clipper constants */
d228 1
a228 1
      clip_planes = brw_select_clip_planes(ctx);
d231 4
a234 4
	    buf[offset + i * 4 + 0] = clip_planes[j][0];
	    buf[offset + i * 4 + 1] = clip_planes[j][1];
	    buf[offset + i * 4 + 2] = clip_planes[j][2];
	    buf[offset + i * 4 + 3] = clip_planes[j][3];
d243 1
d245 10
a254 2
      for (i = 0; i < brw->vs.prog_data->base.nr_params; i++) {
         buf[offset + i] = *brw->vs.prog_data->base.param[i];
d293 1
a293 1
	 brw->curbe.curbe_bo = drm_intel_bo_alloc(brw->bufmgr, "CURBE",
d311 2
d326 6
a332 1
emit:
d334 1
a334 1
   if (brw->curbe.total_size == 0) {
d341 1
a341 1
		(brw->curbe.total_size - 1) + brw->curbe.curbe_offset);
d346 6
d363 2
a364 1
   .emit = brw_upload_constant_buffer,
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics to
d5 1
a5 1

d13 1
a13 1

d17 1
a17 1

d25 1
a25 1

d29 1
a29 1
  *   Keith Whitwell <keithw@@vmware.com>
d42 1
d60 2
a61 2
   const GLuint nr_fp_regs = (brw->wm.prog_data->base.nr_params + 15) / 16;

d63 1
a63 1
   const GLuint nr_vp_regs = (brw->vs.prog_data->base.base.nr_params + 15) / 16;
d91 1
a91 1
    * parameters, though.
d105 1
a105 1
      /* Calculate a new layout:
d117 7
a123 7
	 fprintf(stderr, "curbe wm %d+%d clip %d+%d vs %d+%d\n",
                 brw->curbe.wm_start,
                 brw->curbe.wm_size,
                 brw->curbe.clip_start,
                 brw->curbe.clip_size,
                 brw->curbe.vs_start,
                 brw->curbe.vs_size );
d164 1
a164 1
   ADVANCE_BATCH();
d202 2
a203 2
      for (i = 0; i < brw->wm.prog_data->base.nr_params; i++) {
	 buf[offset + i] = *brw->wm.prog_data->base.param[i];
d240 2
a241 2
      for (i = 0; i < brw->vs.prog_data->base.base.nr_params; i++) {
         buf[offset + i] = *brw->vs.prog_data->base.base.param[i];
d246 8
a253 8
      for (i = 0; i < sz*16; i+=4)
	 fprintf(stderr, "curbe %d.%d: %f %f %f %f\n", i/8, i&4,
                 buf[i+0], buf[i+1], buf[i+2], buf[i+3]);

      fprintf(stderr, "last_buf %p buf %p sz %d/%d cmp %d\n",
              brw->curbe.last_buf, buf,
              bufsz, brw->curbe.last_bufsz,
              brw->curbe.last_buf ? memcmp(buf, brw->curbe.last_buf, bufsz) : -1);
d335 1
a335 1
      .cache = (CACHE_NEW_WM_PROG)
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@a31 19
/** @@file brw_curbe.c
 *
 * Push constant handling for gen4/5.
 *
 * Push constants are constant values (such as GLSL uniforms) that are
 * pre-loaded into a shader stage's register space at thread spawn time.  On
 * gen4 and gen5, we create a blob in memory containing all the push constants
 * for all the stages in order.  At CMD_CONST_BUFFER time that blob is loaded
 * into URB space as a constant URB entry (CURBE) so that it can be accessed
 * quickly at thread setup time.  Each individual fixed function unit's state
 * (brw_vs_state.c for example) tells the hardware which subset of the CURBE
 * it wants in its register space, and we calculate those areas here under the
 * BRW_NEW_CURBE_OFFSETS state flag.  The brw_urb.c allocation will control
 * how many CURBEs can be loaded into the hardware at once before a pipeline
 * stall occurs at CMD_CONST_BUFFER time.
 *
 * On gen6+, constant handling becomes a much simpler set of per-unit state.
 * See gen6_upload_vec4_push_constants() in gen6_vs_state.c for that code.
 */
a41 1
#include "intel_buffer_objects.h"
d49 5
a53 5
 * Partition the CURBE between the various users of constant values.
 *
 * If the users all fit within the previous allocatation, we avoid changing
 * the layout because that means reuploading all unit state and uploading new
 * constant buffers.
d61 1
a61 1
   /* CACHE_NEW_VS_PROG */
d75 4
a78 3
   /* The CURBE allocation size is limited to 32 512-bit units (128 EU
    * registers, or 1024 floats).  See CS_URB_STATE in the gen4 or gen5
    * (volume 1, part 1) PRMs.
d80 11
a90 5
    * Note that in brw_fs.cpp we're only loading up to 16 EU registers of
    * values as push constants before spilling to pull constants, and in
    * brw_vec4.cpp we're loading up to 32 registers of push constants.  An EU
    * register is 1/2 of one of these URB entry units, so that leaves us 16 EU
    * regs for clip.
d132 2
a133 2
      .brw  = BRW_NEW_CONTEXT,
      .cache = CACHE_NEW_VS_PROG | CACHE_NEW_WM_PROG
d141 4
a144 7
/** Uploads the CS_URB_STATE packet.
 *
 * Just like brw_vs_state.c and brw_wm_state.c define a URB entry size and
 * number of entries for their stages, constant buffers do so using this state
 * packet.  Having multiple CURBEs in the URB at the same time allows the
 * hardware to avoid a pipeline stall between primitives using different
 * constant buffer contents.
d149 4
d175 3
a177 4
/**
 * Gathers together all the uniform values into a block of memory to be
 * uploaded into the CURBE, then emits the state packet telling the hardware
 * the new location.
a182 1
   /* BRW_NEW_CURBE_OFFSETS */
d185 1
a185 1
   gl_constant_value *buf;
d190 1
d194 1
a194 4
   buf = intel_upload_space(brw, bufsz, 64,
                            &brw->curbe.curbe_bo, &brw->curbe.curbe_offset);

   STATIC_ASSERT(sizeof(gl_constant_value) == sizeof(float));
a197 1
      /* BRW_NEW_CURBE_OFFSETS */
d200 1
a200 1
      /* CACHE_NEW_WM_PROG | _NEW_PROGRAM_CONSTANTS: copy uniform values */
d214 4
a217 4
	 buf[offset + i * 4 + 0].f = fixed_plane[i][0];
	 buf[offset + i * 4 + 1].f = fixed_plane[i][1];
	 buf[offset + i * 4 + 2].f = fixed_plane[i][2];
	 buf[offset + i * 4 + 3].f = fixed_plane[i][3];
d226 4
a229 4
	    buf[offset + i * 4 + 0].f = clip_planes[j][0];
	    buf[offset + i * 4 + 1].f = clip_planes[j][1];
	    buf[offset + i * 4 + 2].f = clip_planes[j][2];
	    buf[offset + i * 4 + 3].f = clip_planes[j][3];
a238 1
      /* CACHE_NEW_VS_PROG | _NEW_PROGRAM_CONSTANTS: copy uniform values */
d247 48
a294 1
                 buf[i+0].f, buf[i+1].f, buf[i+2].f, buf[i+3].f);
a311 21
   /* Work around mysterious 965 hangs that appear to happen if you do
    * two 3DPRIMITIVEs with only a CONSTANT_BUFFER inbetween.  If we
    * haven't already flushed for some other reason, explicitly do so.
    *
    * We've found no documented reason why this should be necessary.
    */
   if (brw->gen == 4 && !brw->is_g4x &&
       (brw->state.dirty.brw & (BRW_NEW_BATCH | BRW_NEW_PSP)) == 0) {
      BEGIN_BATCH(1);
      OUT_BATCH(MI_FLUSH);
      ADVANCE_BATCH();
   }

   /* BRW_NEW_URB_FENCE: From the gen4 PRM, volume 1, section 3.9.8
    * (CONSTANT_BUFFER (CURBE Load)):
    *
    *     "Modifying the CS URB allocation via URB_FENCE invalidates any
    *      previous CURBE entries. Therefore software must subsequently
    *      [re]issue a CONSTANT_BUFFER command before CURBE data can be used
    *      in the pipeline."
    */
d328 3
a330 1
      .brw  = (BRW_NEW_URB_FENCE |
d334 1
a334 2
      .cache = (CACHE_NEW_VS_PROG |
                CACHE_NEW_WM_PROG)
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d32 19
d61 1
d69 5
a73 5
 * Partition the CURBE between the various users of constant values:
 * Note that vertex and fragment shaders can now fetch constants out
 * of constant buffers.  We no longer allocatea block of the GRF for
 * constants.  That greatly reduces the demand for space in the CURBE.
 * Some of the comments within are dated...
d81 1
a81 1
   /* BRW_NEW_VERTEX_PROGRAM */
d95 3
a97 4
   /* This can happen - what to do?  Probably rather than falling
    * back, the best thing to do is emit programs which code the
    * constants as immediate values.  Could do this either as a static
    * cap on WM and VS, or adaptively.
d99 5
a103 11
    * Unfortunately, this is currently dependent on the results of the
    * program generation process (in the case of wm), so this would
    * introduce the need to re-generate programs in the event of a
    * curbe allocation failure.
    */
   /* Max size is 32 - just large enough to
    * hold the 128 parameters allowed by
    * the fragment and vertex program
    * api's.  It's not clear what happens
    * when both VP and FP want to use 128
    * parameters, though.
d145 2
a146 2
      .brw  = BRW_NEW_VERTEX_PROGRAM | BRW_NEW_CONTEXT,
      .cache = CACHE_NEW_WM_PROG
d154 7
a160 4
/* Define the number of curbes within CS's urb allocation.  Multiple
 * urb entries -> multiple curbes.  These will be used by
 * fixed-function hardware in a double-buffering scheme to avoid a
 * pipeline stall each time the contents of the curbe is changed.
a164 4
   /* It appears that this is the state packet for the CS unit, ie. the
    * urb entries detailed here are housed in the CS range from the
    * URB_FENCE command.
    */
d187 4
a190 3
/* Upload a new set of constants.  Too much variability to go into the
 * cache mechanism, but maybe would benefit from a comparison against
 * the current uploaded set of constants.
d196 1
d199 1
a199 1
   GLfloat *buf;
a203 1
      brw->curbe.last_bufsz  = 0;
d207 4
a210 1
   buf = brw->curbe.next_buf;
d214 1
d217 1
a217 1
      /* copy float constants */
d231 4
a234 4
	 buf[offset + i * 4 + 0] = fixed_plane[i][0];
	 buf[offset + i * 4 + 1] = fixed_plane[i][1];
	 buf[offset + i * 4 + 2] = fixed_plane[i][2];
	 buf[offset + i * 4 + 3] = fixed_plane[i][3];
d243 4
a246 4
	    buf[offset + i * 4 + 0] = clip_planes[j][0];
	    buf[offset + i * 4 + 1] = clip_planes[j][1];
	    buf[offset + i * 4 + 2] = clip_planes[j][2];
	    buf[offset + i * 4 + 3] = clip_planes[j][3];
d256 1
d265 1
a265 48
                 buf[i+0], buf[i+1], buf[i+2], buf[i+3]);

      fprintf(stderr, "last_buf %p buf %p sz %d/%d cmp %d\n",
              brw->curbe.last_buf, buf,
              bufsz, brw->curbe.last_bufsz,
              brw->curbe.last_buf ? memcmp(buf, brw->curbe.last_buf, bufsz) : -1);
   }

   if (brw->curbe.curbe_bo != NULL &&
       bufsz == brw->curbe.last_bufsz &&
       memcmp(buf, brw->curbe.last_buf, bufsz) == 0) {
      /* constants have not changed */
   } else {
      /* Update the record of what our last set of constants was.  We
       * don't just flip the pointers because we don't fill in the
       * data in the padding between the entries.
       */
      memcpy(brw->curbe.last_buf, buf, bufsz);
      brw->curbe.last_bufsz = bufsz;

      if (brw->curbe.curbe_bo != NULL &&
	  brw->curbe.curbe_next_offset + bufsz > brw->curbe.curbe_bo->size)
      {
	 drm_intel_gem_bo_unmap_gtt(brw->curbe.curbe_bo);
	 drm_intel_bo_unreference(brw->curbe.curbe_bo);
	 brw->curbe.curbe_bo = NULL;
      }

      if (brw->curbe.curbe_bo == NULL) {
	 /* Allocate a single page for CURBE entries for this batchbuffer.
	  * They're generally around 64b.
	  */
	 brw->curbe.curbe_bo = drm_intel_bo_alloc(brw->bufmgr, "CURBE",
						  4096, 1 << 6);
	 brw->curbe.curbe_next_offset = 0;
	 drm_intel_gem_bo_map_gtt(brw->curbe.curbe_bo);
	 assert(bufsz < 4096);
      }

      brw->curbe.curbe_offset = brw->curbe.curbe_next_offset;
      brw->curbe.curbe_next_offset += bufsz;
      brw->curbe.curbe_next_offset = ALIGN(brw->curbe.curbe_next_offset, 64);

      /* Copy data to the buffer:
       */
      memcpy(brw->curbe.curbe_bo->virtual + brw->curbe.curbe_offset,
	     buf,
	     bufsz);
d283 21
d320 1
a320 3
      .brw  = (BRW_NEW_FRAGMENT_PROGRAM |
	       BRW_NEW_VERTEX_PROGRAM |
	       BRW_NEW_URB_FENCE | /* Implicit - hardware requires this, not used above */
d324 2
a325 1
      .cache = (CACHE_NEW_WM_PROG)
@


