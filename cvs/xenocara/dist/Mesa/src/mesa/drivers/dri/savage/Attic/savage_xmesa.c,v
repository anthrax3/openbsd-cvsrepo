head	1.7;
access;
symbols
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.09.05.14.05.36;	author jsg;	state dead;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.18;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.53.55;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.53.55;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.34;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.29.43;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.42;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@/*
 * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
 * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sub license,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */


#include <stdio.h>

#include "main/context.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
#include "main/simple_list.h"

#include "utils.h"

#include "main/extensions.h"

#include "swrast/swrast.h"
#include "swrast_setup/swrast_setup.h"
#include "tnl/tnl.h"
#include "vbo/vbo.h"

#include "tnl/t_pipeline.h"

#include "drivers/common/driverfuncs.h"
#include "drivers/common/meta.h"

#include "savagedd.h"
#include "savagestate.h"
#include "savagetex.h"
#include "savagespan.h"
#include "savagetris.h"
#include "savageioctl.h"

#include "savage_dri.h"

#include "drirenderbuffer.h"
#include "texmem.h"

#define need_GL_EXT_secondary_color
#include "main/remap_helper.h"

#include "xmlpool.h"

/* Driver-specific options
 */
#define SAVAGE_ENABLE_VDMA(def) \
DRI_CONF_OPT_BEGIN(enable_vdma,bool,def) \
	DRI_CONF_DESC(en,"Use DMA for vertex transfers") \
	DRI_CONF_DESC(de,"Benutze DMA für Vertextransfers") \
DRI_CONF_OPT_END
#define SAVAGE_ENABLE_FASTPATH(def) \
DRI_CONF_OPT_BEGIN(enable_fastpath,bool,def) \
	DRI_CONF_DESC(en,"Use fast path for unclipped primitives") \
	DRI_CONF_DESC(de,"Schneller Codepfad für ungeschnittene Polygone") \
DRI_CONF_OPT_END
#define SAVAGE_SYNC_FRAMES(def) \
DRI_CONF_OPT_BEGIN(sync_frames,bool,def) \
	DRI_CONF_DESC(en,"Synchronize with graphics hardware after each frame") \
	DRI_CONF_DESC(de,"Synchronisiere nach jedem Frame mit Grafikhardware") \
DRI_CONF_OPT_END

/* Configuration
 */
PUBLIC const char __driConfigOptions[] =
DRI_CONF_BEGIN
    DRI_CONF_SECTION_QUALITY
        DRI_CONF_TEXTURE_DEPTH(DRI_CONF_TEXTURE_DEPTH_FB)
        DRI_CONF_COLOR_REDUCTION(DRI_CONF_COLOR_REDUCTION_DITHER)
        DRI_CONF_FLOAT_DEPTH(false)
    DRI_CONF_SECTION_END
    DRI_CONF_SECTION_PERFORMANCE
        SAVAGE_ENABLE_VDMA(true)
        SAVAGE_ENABLE_FASTPATH(true)
        SAVAGE_SYNC_FRAMES(false)
        DRI_CONF_MAX_TEXTURE_UNITS(2,1,2)
    	DRI_CONF_TEXTURE_HEAPS(DRI_CONF_TEXTURE_HEAPS_ALL)
        DRI_CONF_FORCE_S3TC_ENABLE(false)
    DRI_CONF_SECTION_END
    DRI_CONF_SECTION_DEBUG
        DRI_CONF_NO_RAST(false)
    DRI_CONF_SECTION_END
DRI_CONF_END;
static const GLuint __driNConfigOptions = 10;


static const struct dri_debug_control debug_control[] =
{
    { "fall",  DEBUG_FALLBACKS },
    { "api",   DEBUG_VERBOSE_API },
    { "tex",   DEBUG_VERBOSE_TEX },
    { "verb",  DEBUG_VERBOSE_MSG },
    { "dma",   DEBUG_DMA },
    { "state", DEBUG_STATE },
    { NULL,    0 }
};
#ifndef SAVAGE_DEBUG
int SAVAGE_DEBUG = 0;
#endif


/*For time caculating test*/
#if defined(DEBUG_TIME) && DEBUG_TIME
struct timeval tv_s,tv_f;
unsigned long time_sum=0;
struct timeval tv_s1,tv_f1;
#endif

static const struct dri_extension card_extensions[] =
{
    { "GL_ARB_multitexture",               NULL },
    { "GL_EXT_stencil_wrap",               NULL },
    { "GL_EXT_texture_lod_bias",           NULL },
    { "GL_EXT_secondary_color",            GL_EXT_secondary_color_functions },
    { NULL,                                NULL }
};

static const struct dri_extension s4_extensions[] =
{
    { "GL_ARB_texture_env_add",            NULL },
    { "GL_ARB_texture_mirrored_repeat",    NULL },
    { NULL,                                NULL }
};

extern struct tnl_pipeline_stage _savage_texnorm_stage;
extern struct tnl_pipeline_stage _savage_render_stage;

static const struct tnl_pipeline_stage *savage_pipeline[] = {

   &_tnl_vertex_transform_stage,
   &_tnl_normal_transform_stage,
   &_tnl_lighting_stage,
   &_tnl_fog_coordinate_stage,
   &_tnl_texgen_stage,
   &_tnl_texture_transform_stage,
   &_savage_texnorm_stage,
   &_savage_render_stage,
   &_tnl_render_stage,
   0,
};


PUBLIC const __DRIextension *savageScreenExtensions[] = {
    &driCoreExtension.base,
    &driLegacyExtension.base,
    &driReadDrawableExtension,
};

static GLboolean
savageInitDriver(__DRIscreen *sPriv)
{
  savageScreenPrivate *savageScreen;
  SAVAGEDRIPtr         gDRIPriv = (SAVAGEDRIPtr)sPriv->pDevPriv;

   if (sPriv->devPrivSize != sizeof(SAVAGEDRIRec)) {
      fprintf(stderr,"\nERROR!  sizeof(SAVAGEDRIRec) does not match passed size from device driver\n");
      return GL_FALSE;
   }

   /* Allocate the private area */
   savageScreen = (savageScreenPrivate *)malloc(sizeof(savageScreenPrivate));
   if (!savageScreen)
      return GL_FALSE;

   savageScreen->driScrnPriv = sPriv;
   sPriv->private = (void *)savageScreen;

   savageScreen->chipset=gDRIPriv->chipset; 
   savageScreen->width=gDRIPriv->width;
   savageScreen->height=gDRIPriv->height;
   savageScreen->mem=gDRIPriv->mem;
   savageScreen->cpp=gDRIPriv->cpp;
   savageScreen->zpp=gDRIPriv->zpp;

   savageScreen->agpMode=gDRIPriv->agpMode;

   savageScreen->bufferSize=gDRIPriv->bufferSize;

   if (gDRIPriv->cpp == 4) 
       savageScreen->frontFormat = DV_PF_8888;
   else
       savageScreen->frontFormat = DV_PF_565;
   savageScreen->frontOffset=gDRIPriv->frontOffset;
   savageScreen->backOffset = gDRIPriv->backOffset; 
   savageScreen->depthOffset=gDRIPriv->depthOffset;

   savageScreen->textureOffset[SAVAGE_CARD_HEAP] = 
                                   gDRIPriv->textureOffset;
   savageScreen->textureSize[SAVAGE_CARD_HEAP] = 
                                   gDRIPriv->textureSize;
   savageScreen->logTextureGranularity[SAVAGE_CARD_HEAP] = 
                                   gDRIPriv->logTextureGranularity;

   savageScreen->textureOffset[SAVAGE_AGP_HEAP] = 
                                   gDRIPriv->agpTextureHandle;
   savageScreen->textureSize[SAVAGE_AGP_HEAP] = 
                                   gDRIPriv->agpTextureSize;
   savageScreen->logTextureGranularity[SAVAGE_AGP_HEAP] =
                                   gDRIPriv->logAgpTextureGranularity;

   savageScreen->agpTextures.handle = gDRIPriv->agpTextureHandle;
   savageScreen->agpTextures.size   = gDRIPriv->agpTextureSize;
   if (gDRIPriv->agpTextureSize) {
       if (drmMap(sPriv->fd, 
		  savageScreen->agpTextures.handle,
		  savageScreen->agpTextures.size,
		  (drmAddress *)&(savageScreen->agpTextures.map)) != 0) {
	   free(savageScreen);
	   sPriv->private = NULL;
	   return GL_FALSE;
       }
   } else
       savageScreen->agpTextures.map = NULL;

   savageScreen->texVirtual[SAVAGE_CARD_HEAP] = 
             (drmAddress)(((GLubyte *)sPriv->pFB)+gDRIPriv->textureOffset);
   savageScreen->texVirtual[SAVAGE_AGP_HEAP] = 
                        (drmAddress)(savageScreen->agpTextures.map);

   savageScreen->aperture.handle = gDRIPriv->apertureHandle;
   savageScreen->aperture.size   = gDRIPriv->apertureSize;
   savageScreen->aperturePitch   = gDRIPriv->aperturePitch;
   if (drmMap(sPriv->fd, 
	      savageScreen->aperture.handle, 
	      savageScreen->aperture.size, 
	      (drmAddress *)&savageScreen->aperture.map) != 0) 
   {
      free(savageScreen);
      sPriv->private = NULL;
      return GL_FALSE;
   }

   savageScreen->bufs = drmMapBufs(sPriv->fd);

   savageScreen->sarea_priv_offset = gDRIPriv->sarea_priv_offset;

   /* parse information in __driConfigOptions */
   driParseOptionInfo (&savageScreen->optionCache,
		       __driConfigOptions, __driNConfigOptions);

   sPriv->extensions = savageScreenExtensions;

#if 0
   savageDDFastPathInit();
   savageDDTrifuncInit();
   savageDDSetupInit();
#endif
   return GL_TRUE;
}

/* Accessed by dlsym from dri_mesa_init.c
 */
static void
savageDestroyScreen(__DRIscreen *sPriv)
{
   savageScreenPrivate *savageScreen = (savageScreenPrivate *)sPriv->private;

   if (savageScreen->bufs)
       drmUnmapBufs(savageScreen->bufs);

   /* free all option information */
   driDestroyOptionInfo (&savageScreen->optionCache);

   free(savageScreen);
   sPriv->private = NULL;
}

static GLboolean
savageCreateContext( gl_api api,
		     const struct gl_config *mesaVis,
		     __DRIcontext *driContextPriv,
		     void *sharedContextPrivate )
{
   struct gl_context *ctx, *shareCtx;
   savageContextPtr imesa;
   __DRIscreen *sPriv = driContextPriv->driScreenPriv;
   struct dd_function_table functions;
   savageScreenPrivate *savageScreen = (savageScreenPrivate *)sPriv->private;
   drm_savage_sarea_t *saPriv=(drm_savage_sarea_t *)(((char*)sPriv->pSAREA)+
						 savageScreen->sarea_priv_offset);
   int textureSize[SAVAGE_NR_TEX_HEAPS];
   int i;
   imesa = (savageContextPtr)calloc(1, sizeof(savageContext));
   if (!imesa) {
      return GL_FALSE;
   }

   /* Init default driver functions then plug in savage-specific texture
    * functions that are needed as early as during context creation. */
   _mesa_init_driver_functions( &functions );
   savageDDInitTextureFuncs( &functions );

   /* Allocate the Mesa context */
   if (sharedContextPrivate)
      shareCtx = ((savageContextPtr) sharedContextPrivate)->glCtx;
   else 
      shareCtx = NULL;
   ctx = _mesa_create_context(api, mesaVis, shareCtx, &functions, imesa);
   if (!ctx) {
      free(imesa);
      return GL_FALSE;
   }
   driContextPriv->driverPrivate = imesa;

   imesa->cmdBuf.size = SAVAGE_CMDBUF_SIZE;
   imesa->cmdBuf.base = imesa->cmdBuf.write =
       malloc(SAVAGE_CMDBUF_SIZE * sizeof(drm_savage_cmd_header_t));
   if (!imesa->cmdBuf.base)
       return GL_FALSE;

   /* Parse configuration files */
   driParseConfigFiles (&imesa->optionCache, &savageScreen->optionCache,
                        sPriv->myNum, "savage");

   imesa->float_depth = driQueryOptionb(&imesa->optionCache, "float_depth") &&
       savageScreen->chipset >= S3_SAVAGE4;
   imesa->no_rast = driQueryOptionb(&imesa->optionCache, "no_rast");

#if 0
   ctx->Const.MinLineWidth = 1.0;
   ctx->Const.MinLineWidthAA = 1.0;
   ctx->Const.MaxLineWidth = 3.0;
   ctx->Const.MaxLineWidthAA = 3.0;
   ctx->Const.LineWidthGranularity = 1.0;
#endif

   ctx->Const.MaxDrawBuffers = 1;

   /* Dri stuff
    */
   imesa->hHWContext = driContextPriv->hHWContext;
   imesa->driFd = sPriv->fd;
   imesa->driHwLock = &sPriv->pSAREA->lock;
   
   imesa->savageScreen = savageScreen;
   imesa->driScreen = sPriv;
   imesa->sarea = saPriv;
   imesa->glBuffer = NULL;
   
   /* DMA buffer */

   for(i=0;i<5;i++)
   {
       imesa->apertureBase[i] = (GLubyte *)savageScreen->aperture.map + 
	   0x01000000 * i;
   }
   
   imesa->aperturePitch = savageScreen->aperturePitch;

   /* change texHeap initialize to support two kind of texture heap*/
   /* here is some parts of initialization, others in InitDriver() */
    
   (void) memset( imesa->textureHeaps, 0, sizeof( imesa->textureHeaps ) );
   make_empty_list( & imesa->swapped );

   textureSize[SAVAGE_CARD_HEAP] = savageScreen->textureSize[SAVAGE_CARD_HEAP];
   textureSize[SAVAGE_AGP_HEAP] = savageScreen->textureSize[SAVAGE_AGP_HEAP];
   imesa->lastTexHeap = savageScreen->texVirtual[SAVAGE_AGP_HEAP] ? 2 : 1;
   switch(driQueryOptioni (&imesa->optionCache, "texture_heaps")) {
   case DRI_CONF_TEXTURE_HEAPS_CARD: /* only use card memory, if available */
       if (textureSize[SAVAGE_CARD_HEAP])
	   imesa->lastTexHeap = 1;
       break;
   case DRI_CONF_TEXTURE_HEAPS_GART: /* only use gart memory, if available */
       if (imesa->lastTexHeap == 2 && textureSize[SAVAGE_AGP_HEAP])
	   textureSize[SAVAGE_CARD_HEAP] = 0;
       break;
   /*default: Nothing to do, use all available memory. */
   }
   
   for (i = 0; i < imesa->lastTexHeap; i++) {
       imesa->textureHeaps[i] = driCreateTextureHeap(
	   i, imesa,
	   textureSize[i],
	   11,					/* 2^11 = 2k alignment */
	   SAVAGE_NR_TEX_REGIONS,
	   (drmTextureRegionPtr)imesa->sarea->texList[i],
	    &imesa->sarea->texAge[i],
	    &imesa->swapped,
	    sizeof( savageTexObj ),
	    (destroy_texture_object_t *) savageDestroyTexObj );
       /* If textureSize[i] == 0 textureHeaps[i] is NULL. This can happen
	* if there is not enough card memory for a card texture heap. */
       if (imesa->textureHeaps[i])
	   driSetTextureSwapCounterLocation( imesa->textureHeaps[i],
					     & imesa->c_textureSwaps );
   }
   imesa->texture_depth = driQueryOptioni (&imesa->optionCache,
					   "texture_depth");
   if (imesa->texture_depth == DRI_CONF_TEXTURE_DEPTH_FB)
       imesa->texture_depth = ( savageScreen->cpp == 4 ) ?
	   DRI_CONF_TEXTURE_DEPTH_32 : DRI_CONF_TEXTURE_DEPTH_16;

   if (savageScreen->chipset >= S3_SAVAGE4)
       ctx->Const.MaxTextureUnits = 2;
   else
       ctx->Const.MaxTextureUnits = 1;
   if (driQueryOptioni(&imesa->optionCache, "texture_units") <
       ctx->Const.MaxTextureUnits)
       ctx->Const.MaxTextureUnits =
	   driQueryOptioni(&imesa->optionCache, "texture_units");
   ctx->Const.MaxTextureImageUnits = ctx->Const.MaxTextureUnits;
   ctx->Const.MaxTextureCoordUnits = ctx->Const.MaxTextureUnits;

   driCalculateMaxTextureLevels( imesa->textureHeaps,
				 imesa->lastTexHeap,
				 & ctx->Const,
				 4,
				 11, /* max 2D texture size is 2048x2048 */
				 0,  /* 3D textures unsupported. */
				 0,  /* cube textures unsupported. */
				 0,  /* texture rectangles unsupported. */
				 12,
				 GL_FALSE,
				 0 );
   if (ctx->Const.MaxTextureLevels <= 6) { /*spec requires at least 64x64*/
       __driUtilMessage("Not enough texture memory. "
			"Falling back to indirect rendering.");
       free(imesa);
       return GL_FALSE;
   }

   imesa->hw_stencil = mesaVis->stencilBits && mesaVis->depthBits == 24;
   imesa->depth_scale = (imesa->savageScreen->zpp == 2) ?
       (1.0F/0xffff):(1.0F/0xffffff);

   imesa->bufferSize = savageScreen->bufferSize;
   imesa->dmaVtxBuf.total = 0;
   imesa->dmaVtxBuf.used = 0;
   imesa->dmaVtxBuf.flushed = 0;

   imesa->clientVtxBuf.total = imesa->bufferSize / 4;
   imesa->clientVtxBuf.used = 0;
   imesa->clientVtxBuf.flushed = 0;
   imesa->clientVtxBuf.buf = (uint32_t *)malloc(imesa->bufferSize);

   imesa->vtxBuf = &imesa->clientVtxBuf;

   imesa->firstElt = -1;

   /* Uninitialized vertex format. Force setting the vertex state in
    * savageRenderStart.
    */
   imesa->vertex_size = 0;

   /* Utah stuff
    */
   imesa->new_state = ~0;
   imesa->new_gl_state = ~0;
   imesa->RenderIndex = ~0;
   imesa->dirty = ~0;
   imesa->lostContext = GL_TRUE;
   imesa->CurrentTexObj[0] = 0;
   imesa->CurrentTexObj[1] = 0;

   _mesa_meta_init( ctx );

   /* Initialize the software rasterizer and helper modules.
    */
   _swrast_CreateContext( ctx );
   _vbo_CreateContext( ctx );
   _tnl_CreateContext( ctx );
   
   _swsetup_CreateContext( ctx );

   /* Install the customized pipeline:
    */
   _tnl_destroy_pipeline( ctx );
   _tnl_install_pipeline( ctx, savage_pipeline );

   imesa->enable_fastpath = driQueryOptionb(&imesa->optionCache,
					    "enable_fastpath");
   /* DRM versions before 2.1.3 would only render triangle lists. ELTS
    * support was added in 2.2.0. */
   if (imesa->enable_fastpath && sPriv->drm_version.minor < 2) {
      fprintf (stderr,
	       "*** Disabling fast path because your DRM version is buggy "
	       "or doesn't\n*** support ELTS. You need at least Savage DRM "
	       "version 2.2.\n");
      imesa->enable_fastpath = GL_FALSE;
   }

   if (!savageScreen->bufs || savageScreen->chipset == S3_SUPERSAVAGE)
       imesa->enable_vdma = GL_FALSE;
   else
       imesa->enable_vdma = driQueryOptionb(&imesa->optionCache, "enable_vdma");

   imesa->sync_frames = driQueryOptionb(&imesa->optionCache, "sync_frames");

   /* Configure swrast to match hardware characteristics:
    */
   _tnl_allow_pixel_fog( ctx, GL_FALSE );
   _tnl_allow_vertex_fog( ctx, GL_TRUE );
   _swrast_allow_pixel_fog( ctx, GL_FALSE );
   _swrast_allow_vertex_fog( ctx, GL_TRUE );

   ctx->DriverCtx = (void *) imesa;
   imesa->glCtx = ctx;

#ifndef SAVAGE_DEBUG
   SAVAGE_DEBUG = driParseDebugString( getenv( "SAVAGE_DEBUG" ),
				       debug_control );
#endif

   driInitExtensions( ctx, card_extensions, GL_TRUE );
   if (savageScreen->chipset >= S3_SAVAGE4)
       driInitExtensions( ctx, s4_extensions, GL_FALSE );
   if (ctx->Mesa_DXTn ||
       driQueryOptionb (&imesa->optionCache, "force_s3tc_enable")) {
       _mesa_enable_extension( ctx, "GL_S3_s3tc" );
       if (savageScreen->chipset >= S3_SAVAGE4)
	   /* This extension needs DXT3 and DTX5 support in hardware.
	    * Not available on Savage3D/MX/IX. */
	   _mesa_enable_extension( ctx, "GL_EXT_texture_compression_s3tc" );
   }

   savageDDInitStateFuncs( ctx );
   savageDDInitSpanFuncs( ctx );
   savageDDInitDriverFuncs( ctx );
   savageDDInitIoctlFuncs( ctx );
   savageInitTriFuncs( ctx );

   savageDDInitState( imesa );

   driContextPriv->driverPrivate = (void *) imesa;

   return GL_TRUE;
}

static void
savageDestroyContext(__DRIcontext *driContextPriv)
{
   savageContextPtr imesa = (savageContextPtr) driContextPriv->driverPrivate;
   GLuint i;

   assert (imesa); /* should never be NULL */
   if (imesa) {
      savageFlushVertices(imesa);
      savageReleaseIndexedVerts(imesa);
      savageFlushCmdBuf(imesa, GL_TRUE); /* release DMA buffer */
      WAIT_IDLE_EMPTY(imesa);

      for (i = 0; i < imesa->lastTexHeap; i++)
	 driDestroyTextureHeap(imesa->textureHeaps[i]);

      free(imesa->cmdBuf.base);
      free(imesa->clientVtxBuf.buf);

      _mesa_meta_free( imesa->glCtx );

      _swsetup_DestroyContext(imesa->glCtx );
      _tnl_DestroyContext( imesa->glCtx );
      _vbo_DestroyContext( imesa->glCtx );
      _swrast_DestroyContext( imesa->glCtx );

      /* free the Mesa context */
      imesa->glCtx->DriverCtx = NULL;
      _mesa_destroy_context(imesa->glCtx);

      /* no longer use vertex_dma_buf*/
      free(imesa);
   }
}


static GLboolean
savageCreateBuffer( __DRIscreen *driScrnPriv,
		    __DRIdrawable *driDrawPriv,
		    const struct gl_config *mesaVis,
		    GLboolean isPixmap)
{
   savageScreenPrivate *screen = (savageScreenPrivate *) driScrnPriv->private;

   if (isPixmap) {
      return GL_FALSE; /* not implemented */
   }
   else {
      GLboolean swStencil = mesaVis->stencilBits > 0 && mesaVis->depthBits != 24;
      struct gl_framebuffer *fb = _mesa_create_framebuffer(mesaVis);
      /*
       * XXX: this value needs to be set according to the config file
       * setting.  But we don't get that until we create a rendering
       * context!!!!
       */
      GLboolean float_depth = GL_FALSE;

      {
         driRenderbuffer *frontRb
            = driNewRenderbuffer(MESA_FORMAT_ARGB8888,
                                 (GLubyte *) screen->aperture.map
                                 + 0x01000000 * TARGET_FRONT,
                                 screen->cpp,
                                 screen->frontOffset, screen->aperturePitch,
                                 driDrawPriv);
         savageSetSpanFunctions(frontRb, mesaVis, float_depth);
         assert(frontRb->Base.Data);
         _mesa_add_renderbuffer(fb, BUFFER_FRONT_LEFT, &frontRb->Base);
      }

      if (mesaVis->doubleBufferMode) {
         driRenderbuffer *backRb
            = driNewRenderbuffer(MESA_FORMAT_ARGB8888,
                                 (GLubyte *) screen->aperture.map
                                 + 0x01000000 * TARGET_BACK,
                                 screen->cpp,
                                 screen->backOffset, screen->aperturePitch,
                                 driDrawPriv);
         savageSetSpanFunctions(backRb, mesaVis, float_depth);
         assert(backRb->Base.Data);
         _mesa_add_renderbuffer(fb, BUFFER_BACK_LEFT, &backRb->Base);
      }

      if (mesaVis->depthBits == 16) {
         driRenderbuffer *depthRb
            = driNewRenderbuffer(MESA_FORMAT_Z16,
                                 (GLubyte *) screen->aperture.map
                                 + 0x01000000 * TARGET_DEPTH,
                                 screen->zpp,
                                 screen->depthOffset, screen->aperturePitch,
                                 driDrawPriv);
         savageSetSpanFunctions(depthRb, mesaVis, float_depth);
         _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthRb->Base);
      }
      else if (mesaVis->depthBits == 24) {
         driRenderbuffer *depthRb
            = driNewRenderbuffer(MESA_FORMAT_S8_Z24,
                                 (GLubyte *) screen->aperture.map
                                 + 0x01000000 * TARGET_DEPTH,
                                 screen->zpp,
                                 screen->depthOffset, screen->aperturePitch,
                                 driDrawPriv);
         savageSetSpanFunctions(depthRb, mesaVis, float_depth);
         _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthRb->Base);
      }

      if (mesaVis->stencilBits > 0 && !swStencil) {
         driRenderbuffer *stencilRb
            = driNewRenderbuffer(MESA_FORMAT_S8,
                                 (GLubyte *) screen->aperture.map
                                 + 0x01000000 * TARGET_DEPTH,
                                 screen->zpp,
                                 screen->depthOffset, screen->aperturePitch,
                                 driDrawPriv);
         savageSetSpanFunctions(stencilRb, mesaVis, float_depth);
         _mesa_add_renderbuffer(fb, BUFFER_STENCIL, &stencilRb->Base);
      }

      _mesa_add_soft_renderbuffers(fb,
                                   GL_FALSE, /* color */
                                   GL_FALSE, /* depth */
                                   swStencil,
                                   mesaVis->accumRedBits > 0,
                                   GL_FALSE, /* alpha */
                                   GL_FALSE /* aux */);
      driDrawPriv->driverPrivate = (void *) fb;

      return (driDrawPriv->driverPrivate != NULL);
   }
}

static void
savageDestroyBuffer(__DRIdrawable *driDrawPriv)
{
   _mesa_reference_framebuffer((struct gl_framebuffer **)(&(driDrawPriv->driverPrivate)), NULL);
}

#if 0
void XMesaSwapBuffers(__DRIdrawable *driDrawPriv)
{
   /* XXX should do swap according to the buffer, not the context! */
   savageContextPtr imesa = savageCtx; 

   FLUSH_VB( imesa->glCtx, "swap buffers" );
   savageSwapBuffers(imesa);
}
#endif


void savageXMesaSetClipRects(savageContextPtr imesa)
{
   __DRIdrawable *dPriv = imesa->driDrawable;

   if ((dPriv->numBackClipRects == 0)
       || (imesa->glCtx->DrawBuffer->_ColorDrawBufferIndexes[0] == BUFFER_FRONT_LEFT)) {
      imesa->numClipRects = dPriv->numClipRects;
      imesa->pClipRects = dPriv->pClipRects;
      imesa->drawX = dPriv->x;
      imesa->drawY = dPriv->y;
   } else {
      imesa->numClipRects = dPriv->numBackClipRects;
      imesa->pClipRects = dPriv->pBackClipRects;
      imesa->drawX = dPriv->backX;
      imesa->drawY = dPriv->backY;
   }

   savageCalcViewport( imesa->glCtx );
}


static void savageXMesaWindowMoved( savageContextPtr imesa ) 
{
   __DRIdrawable *const drawable = imesa->driDrawable;
   __DRIdrawable *const readable = imesa->driReadable;

   if (0)
      fprintf(stderr, "savageXMesaWindowMoved\n\n");

   savageXMesaSetClipRects(imesa);

   driUpdateFramebufferSize(imesa->glCtx, drawable);
   if (drawable != readable) {
      driUpdateFramebufferSize(imesa->glCtx, readable);
   }
}


static GLboolean
savageUnbindContext(__DRIcontext *driContextPriv)
{
   savageContextPtr savage = (savageContextPtr) driContextPriv->driverPrivate;
   if (savage)
      savage->dirty = ~0;

   return GL_TRUE;
}

#if 0
static GLboolean
savageOpenFullScreen(__DRIcontext *driContextPriv)
{
    
  
    
    if (driContextPriv) {
      savageContextPtr imesa = (savageContextPtr) driContextPriv->driverPrivate;
      imesa->IsFullScreen = GL_TRUE;
      imesa->backup_frontOffset = imesa->savageScreen->frontOffset;
      imesa->backup_backOffset = imesa->savageScreen->backOffset;
      imesa->backup_frontBitmapDesc = imesa->savageScreen->frontBitmapDesc;
      imesa->savageScreen->frontBitmapDesc = imesa->savageScreen->backBitmapDesc;      
      imesa->toggle = TARGET_BACK;
   }

    return GL_TRUE;
}

static GLboolean
savageCloseFullScreen(__DRIcontext *driContextPriv)
{
    
    if (driContextPriv) {
      savageContextPtr imesa = (savageContextPtr) driContextPriv->driverPrivate;
      WAIT_IDLE_EMPTY(imesa);
      imesa->IsFullScreen = GL_FALSE;   
      imesa->savageScreen->frontOffset = imesa->backup_frontOffset;
      imesa->savageScreen->backOffset = imesa->backup_backOffset;
      imesa->savageScreen->frontBitmapDesc = imesa->backup_frontBitmapDesc;
   }
    return GL_TRUE;
}
#endif

static GLboolean
savageMakeCurrent(__DRIcontext *driContextPriv,
		  __DRIdrawable *driDrawPriv,
		  __DRIdrawable *driReadPriv)
{
   if (driContextPriv) {
      savageContextPtr imesa
         = (savageContextPtr) driContextPriv->driverPrivate;
      struct gl_framebuffer *drawBuffer
         = (struct gl_framebuffer *) driDrawPriv->driverPrivate;
      struct gl_framebuffer *readBuffer
         = (struct gl_framebuffer *) driReadPriv->driverPrivate;
      driRenderbuffer *frontRb = (driRenderbuffer *)
         drawBuffer->Attachment[BUFFER_FRONT_LEFT].Renderbuffer;
      driRenderbuffer *backRb = (driRenderbuffer *)
         drawBuffer->Attachment[BUFFER_BACK_LEFT].Renderbuffer;

      assert(frontRb->Base.Data);
      if (imesa->glCtx->Visual.doubleBufferMode) {
         assert(backRb->Base.Data);
      }

      imesa->driReadable = driReadPriv;
      imesa->driDrawable = driDrawPriv;
      imesa->dirty = ~0;
      
      _mesa_make_current(imesa->glCtx, drawBuffer, readBuffer);
      
      savageXMesaWindowMoved( imesa );
   }
   else 
   {
      _mesa_make_current(NULL, NULL, NULL);
   }
   return GL_TRUE;
}


void savageGetLock( savageContextPtr imesa, GLuint flags ) 
{
   __DRIdrawable *const drawable = imesa->driDrawable;
   __DRIdrawable *const readable = imesa->driReadable;
   __DRIscreen *sPriv = imesa->driScreen;
   drm_savage_sarea_t *sarea = imesa->sarea;
   int me = imesa->hHWContext;
   int stamp = drawable->lastStamp; 
   int heap;
   unsigned int timestamp = 0;

  

   /* We know there has been contention.
    */
   drmGetLock(imesa->driFd, imesa->hHWContext, flags);	


   /* Note contention for throttling hint
    */
   imesa->any_contend = 1;

   /* If the window moved, may need to set a new cliprect now.
    *
    * NOTE: This releases and regains the hw lock, so all state
    * checking must be done *after* this call:
    */
   DRI_VALIDATE_DRAWABLE_INFO(sPriv, drawable);
   if (drawable != readable) {
      DRI_VALIDATE_DRAWABLE_INFO(sPriv, readable);
   }


   /* If we lost context, need to dump all registers to hardware.
    * Note that we don't care about 2d contexts, even if they perform
    * accelerated commands, so the DRI locking in the X server is even
    * more broken than usual.
    */
   if (sarea->ctxOwner != me) {
      imesa->dirty |= (SAVAGE_UPLOAD_LOCAL |
		       SAVAGE_UPLOAD_GLOBAL |
		       SAVAGE_UPLOAD_FOGTBL |
		       SAVAGE_UPLOAD_TEX0 |
		       SAVAGE_UPLOAD_TEX1 |
		       SAVAGE_UPLOAD_TEXGLOBAL);
      imesa->lostContext = GL_TRUE;
      sarea->ctxOwner = me;
   }

   for (heap = 0; heap < imesa->lastTexHeap; ++heap) {
      /* If a heap was changed, update its timestamp. Do this before
       * DRI_AGE_TEXTURES updates the local_age. */
      if (imesa->textureHeaps[heap] &&
	  imesa->textureHeaps[heap]->global_age[0] >
	  imesa->textureHeaps[heap]->local_age) {
	 if (timestamp == 0)
	    timestamp = savageEmitEventLocked(imesa, 0);
	 imesa->textureHeaps[heap]->timestamp = timestamp;
      }
      DRI_AGE_TEXTURES( imesa->textureHeaps[heap] );
   }

   if (drawable->lastStamp != stamp) {
      driUpdateFramebufferSize(imesa->glCtx, drawable);
      savageXMesaWindowMoved( imesa );
   }
}

static const  __DRIconfig **
savageFillInModes( __DRIscreen *psp,
		   unsigned pixel_bits, unsigned depth_bits,
		   unsigned stencil_bits, GLboolean have_back_buffer )
{
    __DRIconfig **configs;
    struct gl_config * m;
    unsigned depth_buffer_factor;
    unsigned back_buffer_factor;
    GLenum fb_format;
    GLenum fb_type;
    int i;

    /* Right now GLX_SWAP_COPY_OML isn't supported, but it would be easy
     * enough to add support.  Basically, if a context is created with an
     * fbconfig where the swap method is GLX_SWAP_COPY_OML, pageflipping
     * will never be used.
     *
     * FK: What about drivers that don't use page flipping? Could they
     * just expose GLX_SWAP_COPY_OML?
     */
    static const GLenum back_buffer_modes[] = {
	GLX_NONE, GLX_SWAP_UNDEFINED_OML /*, GLX_SWAP_COPY_OML */
    };

    uint8_t depth_bits_array[2];
    uint8_t stencil_bits_array[2];
    uint8_t msaa_samples_array[1];

    depth_bits_array[0] = depth_bits;
    depth_bits_array[1] = depth_bits;
    
    /* Just like with the accumulation buffer, always provide some modes
     * with a stencil buffer.  It will be a sw fallback, but some apps won't
     * care about that.
     */
    stencil_bits_array[0] = 0;
    stencil_bits_array[1] = (stencil_bits == 0) ? 8 : stencil_bits;

    msaa_samples_array[0] = 0;

    depth_buffer_factor = ((depth_bits != 0) || (stencil_bits != 0)) ? 2 : 1;
    back_buffer_factor  = (have_back_buffer) ? 2 : 1;

    if ( pixel_bits == 16 ) {
        fb_format = GL_RGB;
        fb_type = GL_UNSIGNED_SHORT_5_6_5;
    }
    else {
        fb_format = GL_BGR;
        fb_type = GL_UNSIGNED_INT_8_8_8_8_REV;
    }

    configs = driCreateConfigs(fb_format, fb_type,
			       depth_bits_array, stencil_bits_array,
			       depth_buffer_factor,
			       back_buffer_modes, back_buffer_factor,
                               msaa_samples_array, 1, GL_TRUE);
    if (configs == NULL) {
	fprintf( stderr, "[%s:%u] Error creating FBConfig!\n",
		 __func__, __LINE__ );
	return NULL;
    }

    /* Mark the visual as slow if there are "fake" stencil bits.
     */
    for (i = 0; configs[i]; i++) {
	m = &configs[i]->modes;
	if ((m->stencilBits != 0) && (m->stencilBits != stencil_bits)) {
	    m->visualRating = GLX_SLOW_CONFIG;
	}
    }

    return (const __DRIconfig **) configs;
}


/**
 * This is the driver specific part of the createNewScreen entry point.
 * 
 * \todo maybe fold this into intelInitDriver
 *
 * \return the struct gl_config supported by this driver
 */
static const __DRIconfig **
savageInitScreen(__DRIscreen *psp)
{
   static const __DRIversion ddx_expected = { 2, 0, 0 };
   static const __DRIversion dri_expected = { 4, 0, 0 };
   static const __DRIversion drm_expected = { 2, 1, 0 };
   SAVAGEDRIPtr dri_priv = (SAVAGEDRIPtr)psp->pDevPriv;

   if ( ! driCheckDriDdxDrmVersions2( "Savage",
				      &psp->dri_version, & dri_expected,
				      &psp->ddx_version, & ddx_expected,
				      &psp->drm_version, & drm_expected ) )
      return NULL;

   if (!savageInitDriver(psp))
       return NULL;

   return savageFillInModes( psp,
			     dri_priv->cpp*8,
			     (dri_priv->cpp == 2) ? 16 : 24,
			     (dri_priv->cpp == 2) ? 0  : 8,
			     (dri_priv->backOffset != dri_priv->depthOffset) );
}

const struct __DriverAPIRec driDriverAPI = {
   savageInitScreen, 
   savageDestroyScreen,
   savageCreateContext,
   savageDestroyContext,
   savageCreateBuffer,
   savageDestroyBuffer,
   savageSwapBuffers,
   savageMakeCurrent,
   savageUnbindContext
};

/* This is the table of extensions that the loader will dlsym() for. */
PUBLIC const __DRIextension *__driDriverExtensions[] = {
    &driCoreExtension.base,
    &driLegacyExtension.base,
    NULL
};
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.5
log
@Merge Mesa 7.10.3
@
text
@d317 1
a317 1
   ctx = _mesa_create_context(mesaVis, shareCtx, &functions, imesa);
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a28 2
#include "main/context.h"
#include "main/matrix.h"
a52 1
#include "savage_bci.h"
d288 2
a289 1
savageCreateContext( const __GLcontextModes *mesaVis,
d293 1
a293 1
   GLcontext *ctx, *shareCtx;
d588 1
a588 1
		    const __GLcontextModes *mesaVis,
d683 1
a683 1
   _mesa_reference_framebuffer((GLframebuffer **)(&(driDrawPriv->driverPrivate)), NULL);
d791 1
a791 1
         = (GLframebuffer *) driDrawPriv->driverPrivate;
d793 1
a793 1
         = (GLframebuffer *) driReadPriv->driverPrivate;
d894 1
a894 1
    __GLcontextModes * m;
d970 1
a970 1
 * \return the __GLcontextModes supported by this driver
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a25 1
#include <X11/Xlibint.h>
d47 1
a61 3
#define need_GL_ARB_multisample
#define need_GL_ARB_texture_compression
#define need_GL_ARB_vertex_buffer_object
d63 1
a63 1
#include "extension_helper.h"
a132 1
    { "GL_ARB_multisample",                GL_ARB_multisample_functions },
a133 2
    { "GL_ARB_texture_compression",        GL_ARB_texture_compression_functions },
    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
d172 1
a172 1
savageInitDriver(__DRIscreenPrivate *sPriv)
d183 1
a183 1
   savageScreen = (savageScreenPrivate *)Xmalloc(sizeof(savageScreenPrivate));
d230 1
a230 1
	   Xfree(savageScreen);
d250 1
a250 1
      Xfree(savageScreen);
d276 1
a276 1
savageDestroyScreen(__DRIscreenPrivate *sPriv)
d286 1
a286 1
   Xfree(savageScreen);
d292 1
a292 1
		     __DRIcontextPrivate *driContextPriv,
d297 1
a297 1
   __DRIscreenPrivate *sPriv = driContextPriv->driScreenPriv;
d304 1
a304 1
   imesa = (savageContextPtr)Xcalloc(sizeof(savageContext), 1);
d321 1
a321 1
      Xfree(imesa);
d347 3
a349 1
   
d440 1
a440 1
       Xfree(imesa);
d477 2
d552 1
a552 1
savageDestroyContext(__DRIcontextPrivate *driContextPriv)
d570 2
d582 1
a582 1
      Xfree(imesa);
d588 2
a589 2
savageCreateBuffer( __DRIscreenPrivate *driScrnPriv,
		    __DRIdrawablePrivate *driDrawPriv,
d610 1
a610 1
            = driNewRenderbuffer(GL_RGBA,
d623 1
a623 1
            = driNewRenderbuffer(GL_RGBA,
d636 1
a636 1
            = driNewRenderbuffer(GL_DEPTH_COMPONENT16,
d647 1
a647 1
            = driNewRenderbuffer(GL_DEPTH_COMPONENT24,
d659 1
a659 1
            = driNewRenderbuffer(GL_STENCIL_INDEX8_EXT,
d683 1
a683 1
savageDestroyBuffer(__DRIdrawablePrivate *driDrawPriv)
d685 1
a685 1
   _mesa_unreference_framebuffer((GLframebuffer **)(&(driDrawPriv->driverPrivate)));
d689 1
a689 1
void XMesaSwapBuffers(__DRIdrawablePrivate *driDrawPriv)
d702 1
a702 1
   __DRIdrawablePrivate *dPriv = imesa->driDrawable;
d723 2
a724 2
   __DRIdrawablePrivate *const drawable = imesa->driDrawable;
   __DRIdrawablePrivate *const readable = imesa->driReadable;
d739 1
a739 1
savageUnbindContext(__DRIcontextPrivate *driContextPriv)
d750 1
a750 1
savageOpenFullScreen(__DRIcontextPrivate *driContextPriv)
d769 1
a769 1
savageCloseFullScreen(__DRIcontextPrivate *driContextPriv)
d785 3
a787 3
savageMakeCurrent(__DRIcontextPrivate *driContextPriv,
		  __DRIdrawablePrivate *driDrawPriv,
		  __DRIdrawablePrivate *driReadPriv)
d824 3
a826 3
   __DRIdrawablePrivate *const drawable = imesa->driDrawable;
   __DRIdrawablePrivate *const readable = imesa->driReadable;
   __DRIscreenPrivate *sPriv = imesa->driScreen;
d891 1
a891 1
savageFillInModes( __DRIscreenPrivate *psp,
d917 1
a917 1

d929 2
d946 2
a947 1
			       back_buffer_modes, back_buffer_factor);
d975 1
a975 1
savageInitScreen(__DRIscreenPrivate *psp)
a987 12
   /* Calling driInitExtensions here, with a NULL context pointer,
    * does not actually enable the extensions.  It just makes sure
    * that all the dispatch offsets for all the extensions that
    * *might* be enables are known.  This is needed because the
    * dispatch offsets need to be known when _mesa_context_create is
    * called, but we can't enable the extensions until we have a
    * context pointer.
    *
    * Hello chicken.  Hello egg.  How are you two today?
    */
   driInitExtensions( NULL, card_extensions, GL_FALSE );

d1008 7
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d29 6
a34 6
#include "savagecontext.h"
#include "context.h"
#include "matrix.h"
#include "framebuffer.h"
#include "renderbuffer.h"
#include "simple_list.h"
d38 1
a38 1
#include "extensions.h"
d460 1
a460 1
   imesa->clientVtxBuf.buf = (u_int32_t *)malloc(imesa->bufferSize);
d915 2
a916 2
    u_int8_t depth_bits_array[2];
    u_int8_t stencil_bits_array[2];
@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
#include "array_cache/acache.h"
d64 1
d139 1
d171 5
a175 1
/* this is first function called in dirver*/
d269 2
a295 28
#if 0
GLvisual *XMesaCreateVisual(Display *dpy,
                            __DRIscreenPrivate *driScrnPriv,
                            const XVisualInfo *visinfo,
                            const __GLXvisualConfig *config)
{
   /* Drivers may change the args to _mesa_create_visual() in order to
    * setup special visuals.
    */
   return _mesa_create_visual( config->rgba,
                               config->doubleBuffer,
                               config->stereo,
                               _mesa_bitcount(visinfo->red_mask),
                               _mesa_bitcount(visinfo->green_mask),
                               _mesa_bitcount(visinfo->blue_mask),
                               config->alphaSize,
                               0, /* index bits */
                               config->depthSize,
                               config->stencilSize,
                               config->accumRedSize,
                               config->accumGreenSize,
                               config->accumBlueSize,
                               config->accumAlphaSize,
                               0 /* num samples */ );
}
#endif


d484 1
a484 1
   _ac_CreateContext( ctx );
d498 1
a498 1
   if (imesa->enable_fastpath && sPriv->drmMinor < 2) {
d574 1
a574 1
      _ac_DestroyContext( imesa->glCtx );
d685 1
a685 1
   _mesa_destroy_framebuffer((GLframebuffer *) (driDrawPriv->driverPrivate));
a698 11
void savageXMesaSetFrontClipRects( savageContextPtr imesa )
{
   __DRIdrawablePrivate *dPriv = imesa->driDrawable;

   imesa->numClipRects = dPriv->numClipRects;
   imesa->pClipRects = dPriv->pClipRects;
   imesa->drawX = dPriv->x;
   imesa->drawY = dPriv->y;

   savageCalcViewport( imesa->glCtx );
}
d700 1
a700 2

void savageXMesaSetBackClipRects( savageContextPtr imesa )
d704 2
a705 4
   if (dPriv->numBackClipRects == 0) 
   {


a710 2


d723 3
d729 5
a733 9
   switch (imesa->glCtx->DrawBuffer->_ColorDrawBufferMask[0]) {
   case BUFFER_BIT_FRONT_LEFT:
      savageXMesaSetFrontClipRects( imesa );
      break;
   case BUFFER_BIT_BACK_LEFT:
      savageXMesaSetBackClipRects( imesa );
      break;
   default:
       break;
d824 2
a825 1
   __DRIdrawablePrivate *dPriv = imesa->driDrawable;
d829 1
a829 1
   int stamp = dPriv->lastStamp; 
d849 4
a852 2
   DRI_VALIDATE_DRAWABLE_INFO(sPriv, dPriv);		

a853 1
  
d884 2
a885 2
   if (dPriv->lastStamp != stamp) {
      driUpdateFramebufferSize(imesa->glCtx, dPriv);
d890 3
a892 17


static const struct __DriverAPIRec savageAPI = {
   savageInitDriver,
   savageDestroyScreen,
   savageCreateContext,
   savageDestroyContext,
   savageCreateBuffer,
   savageDestroyBuffer,
   savageSwapBuffers,
   savageMakeCurrent,
   savageUnbindContext
};


static __GLcontextModes *
savageFillInModes( unsigned pixel_bits, unsigned depth_bits,
d895 1
a895 1
    __GLcontextModes * modes;
a896 1
    unsigned num_modes;
d901 1
a931 2
    num_modes = depth_buffer_factor * back_buffer_factor * 4;

d941 5
a945 15
    modes = (*dri_interface->createContextModes)( num_modes, sizeof( __GLcontextModes ) );
    m = modes;
    if ( ! driFillInModes( & m, fb_format, fb_type,
			   depth_bits_array, stencil_bits_array, depth_buffer_factor,
			   back_buffer_modes, back_buffer_factor,
			   GLX_TRUE_COLOR ) ) {
	fprintf( stderr, "[%s:%u] Error creating FBConfig!\n",
		 __func__, __LINE__ );
	return NULL;
    }

    if ( ! driFillInModes( & m, fb_format, fb_type,
			   depth_bits_array, stencil_bits_array, depth_buffer_factor,
			   back_buffer_modes, back_buffer_factor,
			   GLX_DIRECT_COLOR ) ) {
d953 3
a955 2
    for ( m = modes ; m != NULL ; m = m->next ) {
	if ( (m->stencilBits != 0) && (m->stencilBits != stencil_bits) ) {
d960 1
a960 1
    return modes;
d965 1
a965 5
 * This is the bootstrap function for the driver.  libGL supplies all of the
 * requisite information about the system, and the driver initializes itself.
 * This routine also fills in the linked list pointed to by \c driver_modes
 * with the \c __GLcontextModes that the driver can support for windows or
 * pbuffers.
d967 3
a969 2
 * \return A pointer to a \c __DRIscreenPrivate on success, or \c NULL on 
 *         failure.
d971 2
a972 12
PUBLIC
void * __driCreateNewScreen_20050727( __DRInativeDisplay *dpy, int scrn, __DRIscreen *psc,
			     const __GLcontextModes * modes,
			     const __DRIversion * ddx_version,
			     const __DRIversion * dri_version,
			     const __DRIversion * drm_version,
			     const __DRIframebuffer * frame_buffer,
			     drmAddress pSAREA, int fd, 
			     int internal_api_version,
			     const __DRIinterfaceMethods * interface,
			     __GLcontextModes ** driver_modes )
			     
a973 1
   __DRIscreenPrivate *psp;
d977 1
a977 2

   dri_interface = interface;
d980 3
a982 3
				      dri_version, & dri_expected,
				      ddx_version, & ddx_expected,
				      drm_version, & drm_expected ) ) {
a983 23
   }
      
   psp = __driUtilCreateNewScreen(dpy, scrn, psc, NULL,
				  ddx_version, dri_version, drm_version,
				  frame_buffer, pSAREA, fd,
				  internal_api_version, &savageAPI);
   if ( psp != NULL ) {
      SAVAGEDRIPtr dri_priv = (SAVAGEDRIPtr)psp->pDevPriv;
      *driver_modes = savageFillInModes( dri_priv->cpp*8,
					 (dri_priv->cpp == 2) ? 16 : 24,
					 (dri_priv->cpp == 2) ? 0  : 8,
					 (dri_priv->backOffset != dri_priv->depthOffset) );

      /* Calling driInitExtensions here, with a NULL context pointer, does not actually
       * enable the extensions.  It just makes sure that all the dispatch offsets for all
       * the extensions that *might* be enables are known.  This is needed because the
       * dispatch offsets need to be known when _mesa_context_create is called, but we can't
       * enable the extensions until we have a context pointer.
       *
       * Hello chicken.  Hello egg.  How are you two today?
       */
      driInitExtensions( NULL, card_extensions, GL_FALSE );
   }
d985 20
a1004 1
   return (void *) psp;
d1006 12
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a175 3
   PFNGLXSCRENABLEEXTENSIONPROC glx_enable_extension =
     (PFNGLXSCRENABLEEXTENSIONPROC) (*dri_interface->getProcAddress("glxEnableExtension"));

a262 5
   if (glx_enable_extension != NULL) {
      (*glx_enable_extension)(sPriv->psc->screenConfigs,
			      "GLX_SGI_make_current_read");
   }

d719 8
d728 5
a732 1
void savageXMesaSetClipRects(savageContextPtr imesa)
d736 4
a739 2
   if ((dPriv->numBackClipRects == 0)
       || (imesa->glCtx->DrawBuffer->_ColorDrawBufferMask[0] == BUFFER_BIT_FRONT_LEFT)) {
d745 2
a758 3
   __DRIdrawablePrivate *const drawable = imesa->driDrawable;
   __DRIdrawablePrivate *const readable = imesa->driReadable;

d762 9
a770 5
   savageXMesaSetClipRects(imesa);

   driUpdateFramebufferSize(imesa->glCtx, drawable);
   if (drawable != readable) {
      driUpdateFramebufferSize(imesa->glCtx, readable);
d861 1
a861 2
   __DRIdrawablePrivate *const drawable = imesa->driDrawable;
   __DRIdrawablePrivate *const readable = imesa->driReadable;
d865 1
a865 1
   int stamp = drawable->lastStamp; 
d885 2
a886 4
   DRI_VALIDATE_DRAWABLE_INFO(sPriv, drawable);
   if (drawable != readable) {
      DRI_VALIDATE_DRAWABLE_INFO(sPriv, readable);
   }
d888 1
d919 2
a920 2
   if (drawable->lastStamp != stamp) {
      driUpdateFramebufferSize(imesa->glCtx, drawable);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d43 1
a43 1
#include "vbo/vbo.h"
a63 1
#define need_GL_ARB_vertex_buffer_object
a137 1
    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
d512 1
a512 1
   _vbo_CreateContext( ctx );
d602 1
a602 1
      _vbo_DestroyContext( imesa->glCtx );
d713 1
a713 1
   _mesa_unreference_framebuffer((GLframebuffer **)(&(driDrawPriv->driverPrivate)));
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d26 1
d29 6
a34 4
#include "main/context.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
#include "main/simple_list.h"
d38 1
a38 1
#include "main/extensions.h"
a47 1
#include "drivers/common/meta.h"
d55 1
d62 3
d66 1
a66 1
#include "main/remap_helper.h"
d136 1
d138 2
d171 1
a171 5
PUBLIC const __DRIextension *savageScreenExtensions[] = {
    &driCoreExtension.base,
    &driLegacyExtension.base,
    &driReadDrawableExtension,
};
d174 1
a174 1
savageInitDriver(__DRIscreen *sPriv)
d178 3
d188 1
a188 1
   savageScreen = (savageScreenPrivate *)malloc(sizeof(savageScreenPrivate));
d235 1
a235 1
	   free(savageScreen);
d255 1
a255 1
      free(savageScreen);
d268 4
a271 1
   sPriv->extensions = savageScreenExtensions;
d284 1
a284 1
savageDestroyScreen(__DRIscreen *sPriv)
d294 1
a294 1
   free(savageScreen);
d298 28
d327 2
a328 3
savageCreateContext( gl_api api,
		     const struct gl_config *mesaVis,
		     __DRIcontext *driContextPriv,
d331 1
a331 1
   struct gl_context *ctx, *shareCtx;
d333 1
a333 1
   __DRIscreen *sPriv = driContextPriv->driScreenPriv;
d340 1
a340 1
   imesa = (savageContextPtr)calloc(1, sizeof(savageContext));
d357 1
a357 1
      free(imesa);
d383 1
a383 3

   ctx->Const.MaxDrawBuffers = 1;

d474 1
a474 1
       free(imesa);
d490 1
a490 1
   imesa->clientVtxBuf.buf = (uint32_t *)malloc(imesa->bufferSize);
a510 2
   _mesa_meta_init( ctx );

d528 1
a528 1
   if (imesa->enable_fastpath && sPriv->drm_version.minor < 2) {
d584 1
a584 1
savageDestroyContext(__DRIcontext *driContextPriv)
a601 2
      _mesa_meta_free( imesa->glCtx );

d612 1
a612 1
      free(imesa);
d618 3
a620 3
savageCreateBuffer( __DRIscreen *driScrnPriv,
		    __DRIdrawable *driDrawPriv,
		    const struct gl_config *mesaVis,
d640 1
a640 1
            = driNewRenderbuffer(MESA_FORMAT_ARGB8888,
d653 1
a653 1
            = driNewRenderbuffer(MESA_FORMAT_ARGB8888,
d666 1
a666 1
            = driNewRenderbuffer(MESA_FORMAT_Z16,
d677 1
a677 1
            = driNewRenderbuffer(MESA_FORMAT_S8_Z24,
d689 1
a689 1
            = driNewRenderbuffer(MESA_FORMAT_S8,
d713 1
a713 1
savageDestroyBuffer(__DRIdrawable *driDrawPriv)
d715 1
a715 1
   _mesa_reference_framebuffer((struct gl_framebuffer **)(&(driDrawPriv->driverPrivate)), NULL);
d719 1
a719 1
void XMesaSwapBuffers(__DRIdrawable *driDrawPriv)
d732 1
a732 1
   __DRIdrawable *dPriv = imesa->driDrawable;
d735 1
a735 1
       || (imesa->glCtx->DrawBuffer->_ColorDrawBufferIndexes[0] == BUFFER_FRONT_LEFT)) {
d753 2
a754 2
   __DRIdrawable *const drawable = imesa->driDrawable;
   __DRIdrawable *const readable = imesa->driReadable;
d769 1
a769 1
savageUnbindContext(__DRIcontext *driContextPriv)
d780 1
a780 1
savageOpenFullScreen(__DRIcontext *driContextPriv)
d799 1
a799 1
savageCloseFullScreen(__DRIcontext *driContextPriv)
d815 3
a817 3
savageMakeCurrent(__DRIcontext *driContextPriv,
		  __DRIdrawable *driDrawPriv,
		  __DRIdrawable *driReadPriv)
d823 1
a823 1
         = (struct gl_framebuffer *) driDrawPriv->driverPrivate;
d825 1
a825 1
         = (struct gl_framebuffer *) driReadPriv->driverPrivate;
d854 3
a856 3
   __DRIdrawable *const drawable = imesa->driDrawable;
   __DRIdrawable *const readable = imesa->driReadable;
   __DRIscreen *sPriv = imesa->driScreen;
d920 17
a936 3
static const  __DRIconfig **
savageFillInModes( __DRIscreen *psp,
		   unsigned pixel_bits, unsigned depth_bits,
d939 3
a941 2
    __DRIconfig **configs;
    struct gl_config * m;
a945 1
    int i;
d959 3
a961 3
    uint8_t depth_bits_array[2];
    uint8_t stencil_bits_array[2];
    uint8_t msaa_samples_array[1];
a972 2
    msaa_samples_array[0] = 0;

d976 2
d987 15
a1001 6
    configs = driCreateConfigs(fb_format, fb_type,
			       depth_bits_array, stencil_bits_array,
			       depth_buffer_factor,
			       back_buffer_modes, back_buffer_factor,
                               msaa_samples_array, 1, GL_TRUE);
    if (configs == NULL) {
d1009 2
a1010 3
    for (i = 0; configs[i]; i++) {
	m = &configs[i]->modes;
	if ((m->stencilBits != 0) && (m->stencilBits != stencil_bits)) {
d1015 1
a1015 1
    return (const __DRIconfig **) configs;
d1020 5
a1024 1
 * This is the driver specific part of the createNewScreen entry point.
d1026 2
a1027 3
 * \todo maybe fold this into intelInitDriver
 *
 * \return the struct gl_config supported by this driver
d1029 12
a1040 2
static const __DRIconfig **
savageInitScreen(__DRIscreen *psp)
d1042 1
d1046 2
a1047 1
   SAVAGEDRIPtr dri_priv = (SAVAGEDRIPtr)psp->pDevPriv;
d1050 3
a1052 3
				      &psp->dri_version, & dri_expected,
				      &psp->ddx_version, & ddx_expected,
				      &psp->drm_version, & drm_expected ) )
d1054 23
d1078 1
a1078 8
   if (!savageInitDriver(psp))
       return NULL;

   return savageFillInModes( psp,
			     dri_priv->cpp*8,
			     (dri_priv->cpp == 2) ? 16 : 24,
			     (dri_priv->cpp == 2) ? 0  : 8,
			     (dri_priv->backOffset != dri_priv->depthOffset) );
a1079 19

const struct __DriverAPIRec driDriverAPI = {
   savageInitScreen, 
   savageDestroyScreen,
   savageCreateContext,
   savageDestroyContext,
   savageCreateBuffer,
   savageDestroyBuffer,
   savageSwapBuffers,
   savageMakeCurrent,
   savageUnbindContext
};

/* This is the table of extensions that the loader will dlsym() for. */
PUBLIC const __DRIextension *__driDriverExtensions[] = {
    &driCoreExtension.base,
    &driLegacyExtension.base,
    NULL
};
@


