head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.10
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.8
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2013.09.05.14.04.34;	author jsg;	state dead;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.10.15.27.14;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.38;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@/**************************************************************************
 * 
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#ifndef _INTEL_INIT_H_
#define _INTEL_INIT_H_

#include <sys/time.h>
#include "dri_util.h"
#include "intel_bufmgr.h"
#include "i915_drm.h"
#include "xmlconfig.h"

/**
 * \brief Does X driver support DRI2BufferHiz and DRI2BufferStencil?
 *
 * (Here, "X driver" referes to the DDX driver, xf86-video-intel).
 *
 * The DRI2 protocol does not allow us to query the X driver's version nor
 * query for a list of buffer formats that the driver supports. So, to
 * determine if the X driver supports DRI2BufferHiz and DRI2BufferStencil we
 * must resort to a handshake.
 *
 * If the hardware lacks support for separate stencil (and consequently, lacks
 * support for hiz also), then the X driver's separate stencil and hiz support
 * is irrelevant and the handshake never occurs.
 *
 * Complications
 * -------------
 * The handshake is complicated by a bug in xf86-video-intel 2.15. Even though
 * that version of the X driver did not supppot requests for DRI2BufferHiz or
 * DRI2BufferStencil, if requested one it still allocated and returned one.
 * The returned buffer, however, was incorrectly X tiled.
 *
 * How the handshake works
 * -----------------------
 * Initially, intel_screen.dri2_has_hiz is set to unknown. The first time the
 * user requests a depth and stencil buffer, intelCreateBuffers() creates a
 * framebuffer with separate depth and stencil attachments (with formats
 * x8_z24 and s8).
 *
 * Eventually, intel_update_renderbuffers() makes a DRI2 request for
 * DRI2BufferStencil and DRI2BufferHiz. If the stencil buffer's tiling is
 * I915_TILING_NONE [1], then we joyfully set intel_screen.dri2_has_hiz to
 * true and continue as if nothing happend.
 *
 * [1] The stencil buffer is actually W tiled. However, we request from the
 *     kernel a non-tiled buffer because the GTT is incapable of W fencing.
 *
 * If the buffers are X tiled, however, the handshake has failed and we must
 * clean up.
 *    1. Angrily set intel_screen.dri2_has_hiz to false.
 *    2. Discard the framebuffer's depth and stencil attachments.
 *    3. Attach a packed depth/stencil buffer to the framebuffer (with format
 *       s8_z24).
 *    4. Make a DRI2 request for the new buffer, using attachment type
 *       DRI2BufferDepthStencil).
 *
 * Future Considerations
 * ---------------------
 * On a sunny day in the far future, when we are certain that no one has an
 * xf86-video-intel installed without hiz and separate stencil support, then
 * this enumerant and the handshake should die.
 */
enum intel_dri2_has_hiz {
   INTEL_DRI2_HAS_HIZ_UNKNOWN,
   INTEL_DRI2_HAS_HIZ_TRUE,
   INTEL_DRI2_HAS_HIZ_FALSE,
};

struct intel_screen
{
   int deviceID;
   int gen;

   int logTextureGranularity;

   __DRIscreen *driScrnPriv;

   GLboolean no_hw;
   GLuint relaxed_relocations;

   /*
    * The hardware hiz and separate stencil fields are needed in intel_screen,
    * rather than solely in intel_context, because glXCreatePbuffer and
    * glXCreatePixmap are not passed a GLXContext.
    */
   GLboolean hw_has_separate_stencil;
   GLboolean hw_must_use_separate_stencil;
   GLboolean hw_has_hiz;
   enum intel_dri2_has_hiz dri2_has_hiz;

   GLboolean no_vbo;
   dri_bufmgr *bufmgr;
   struct _mesa_HashTable *named_regions;

   /**
   * Configuration cache with default values for all contexts
   */
   driOptionCache optionCache;
};

extern GLboolean intelMapScreenRegions(__DRIscreen * sPriv);

extern void intelDestroyContext(__DRIcontext * driContextPriv);

extern GLboolean intelUnbindContext(__DRIcontext * driContextPriv);

extern GLboolean
intelMakeCurrent(__DRIcontext * driContextPriv,
                 __DRIdrawable * driDrawPriv,
                 __DRIdrawable * driReadPriv);

#endif
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d37 57
d97 1
d104 11
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d37 1
a37 4
/* XXX: change name or eliminate to avoid conflict with "struct
 * intel_region"!!!
 */
typedef struct
a38 20
   drm_handle_t handle;
   drmSize size;                /* region size in bytes */
   char *map;                   /* memory map */
   int offset;                  /* from start of video mem, in bytes */
   unsigned int bo_handle;	/* buffer object id if available, or -1 */
   /**
    * Flags if the region is tiled.
    *
    * Not included is Y versus X tiling.
    */
   GLboolean tiled;
} intelRegion;

typedef struct
{
   intelRegion front;
   intelRegion back;
   intelRegion depth;
   intelRegion tex;

a39 3
   int width;
   int height;
   int pitch;                   /* common row stride, in pixels */
d43 1
a43 7
   __DRIscreenPrivate *driScrnPriv;

   volatile drm_i915_sarea_t *sarea;

   int drmMinor;

   int irq_active;
a47 1
   int ttm;
d49 1
d55 1
a55 3
} intelScreenPrivate;


d57 1
a57 1
extern GLboolean intelMapScreenRegions(__DRIscreenPrivate * sPriv);
d59 1
a59 1
extern void intelUnmapScreenRegions(intelScreenPrivate * intelScreen);
d61 1
a61 3
extern void intelDestroyContext(__DRIcontextPrivate * driContextPriv);

extern GLboolean intelUnbindContext(__DRIcontextPrivate * driContextPriv);
d64 3
a66 5
intelMakeCurrent(__DRIcontextPrivate * driContextPriv,
                 __DRIdrawablePrivate * driDrawPriv,
                 __DRIdrawablePrivate * driReadPriv);

extern struct intel_context *intelScreenContext(intelScreenPrivate *intelScreen);
@


1.2
log
@remove the triple buffering support from the intel driver, the support
from this was removed from the kernel and is very much deprecated.
Pageflipping is also probably broken and should not be used. Similar
change happened in mesa master a while back.

ok matthieu@@
@
text
@d33 1
d70 2
a71 1
   unsigned int sarea_priv_offset;
d76 6
a81 1
   int allow_batchbuffer;
a94 4
extern void
intelUpdateScreenFromSAREA(intelScreenPrivate * intelScreen,
                           struct drm_i915_sarea * sarea);

a102 5

extern void intelSwapBuffers(__DRIdrawablePrivate * dPriv);

extern void
intelCopySubBuffer(__DRIdrawablePrivate * dPriv, int x, int y, int w, int h);
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a57 1
   intelRegion third;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a32 1
#include "intel_bufmgr.h"
d36 4
a39 1
struct intel_screen
d41 21
d63 3
d69 2
a70 1
   __DRIscreen *driScrnPriv;
d72 1
a72 1
   GLboolean no_hw;
d74 2
a75 3
   GLboolean no_vbo;
   dri_bufmgr *bufmgr;
   struct _mesa_HashTable *named_regions;
d81 3
a83 1
};
d85 1
a85 1
extern GLboolean intelMapScreenRegions(__DRIscreen * sPriv);
d87 1
a87 1
extern void intelDestroyContext(__DRIcontext * driContextPriv);
d89 7
a95 1
extern GLboolean intelUnbindContext(__DRIcontext * driContextPriv);
d98 10
a107 3
intelMakeCurrent(__DRIcontext * driContextPriv,
                 __DRIdrawable * driDrawPriv,
                 __DRIdrawable * driReadPriv);
@


