head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.04.17;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.30;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.49;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.11.33;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.48.40;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2008 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>
#include <unistd.h>
#include <stdarg.h>

#include "main/mtypes.h"

#include "brw_context.h"
#include "brw_defines.h"

const struct opcode_desc opcode_descs[128] = {
    [BRW_OPCODE_MOV] = { .name = "mov", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_FRC] = { .name = "frc", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_RNDU] = { .name = "rndu", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_RNDD] = { .name = "rndd", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_RNDE] = { .name = "rnde", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_RNDZ] = { .name = "rndz", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_NOT] = { .name = "not", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_LZD] = { .name = "lzd", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_F32TO16] = { .name = "f32to16", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_F16TO32] = { .name = "f16to32", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_BFREV] = { .name = "bfrev", .nsrc = 1, .ndst = 1},
    [BRW_OPCODE_FBH] = { .name = "fbh", .nsrc = 1, .ndst = 1},
    [BRW_OPCODE_FBL] = { .name = "fbl", .nsrc = 1, .ndst = 1},
    [BRW_OPCODE_CBIT] = { .name = "cbit", .nsrc = 1, .ndst = 1},

    [BRW_OPCODE_MUL] = { .name = "mul", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_MAC] = { .name = "mac", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_MACH] = { .name = "mach", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_LINE] = { .name = "line", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_PLN] = { .name = "pln", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_MAD] = { .name = "mad", .nsrc = 3, .ndst = 1 },
    [BRW_OPCODE_LRP] = { .name = "lrp", .nsrc = 3, .ndst = 1 },
    [BRW_OPCODE_SAD2] = { .name = "sad2", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_SADA2] = { .name = "sada2", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_DP4] = { .name = "dp4", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_DPH] = { .name = "dph", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_DP3] = { .name = "dp3", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_DP2] = { .name = "dp2", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_MATH] = { .name = "math", .nsrc = 2, .ndst = 1 },

    [BRW_OPCODE_AVG] = { .name = "avg", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_ADD] = { .name = "add", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_SEL] = { .name = "sel", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_AND] = { .name = "and", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_OR] = { .name = "or", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_XOR] = { .name = "xor", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_SHR] = { .name = "shr", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_SHL] = { .name = "shl", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_ASR] = { .name = "asr", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_CMP] = { .name = "cmp", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_CMPN] = { .name = "cmpn", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_BFE] = { .name = "bfe", .nsrc = 3, .ndst = 1},
    [BRW_OPCODE_BFI1] = { .name = "bfi1", .nsrc = 2, .ndst = 1},
    [BRW_OPCODE_BFI2] = { .name = "bfi2", .nsrc = 3, .ndst = 1},
    [BRW_OPCODE_ADDC] = { .name = "addc", .nsrc = 2, .ndst = 1},
    [BRW_OPCODE_SUBB] = { .name = "subb", .nsrc = 2, .ndst = 1},

    [BRW_OPCODE_SEND] = { .name = "send", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_SENDC] = { .name = "sendc", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_NOP] = { .name = "nop", .nsrc = 0, .ndst = 0 },
    [BRW_OPCODE_JMPI] = { .name = "jmpi", .nsrc = 0, .ndst = 0 },
    [BRW_OPCODE_IF] = { .name = "if", .nsrc = 2, .ndst = 0 },
    [BRW_OPCODE_IFF] = { .name = "iff", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_WHILE] = { .name = "while", .nsrc = 2, .ndst = 0 },
    [BRW_OPCODE_ELSE] = { .name = "else", .nsrc = 2, .ndst = 0 },
    [BRW_OPCODE_BREAK] = { .name = "break", .nsrc = 2, .ndst = 0 },
    [BRW_OPCODE_CONTINUE] = { .name = "cont", .nsrc = 1, .ndst = 0 },
    [BRW_OPCODE_HALT] = { .name = "halt", .nsrc = 1, .ndst = 0 },
    [BRW_OPCODE_MSAVE] = { .name = "msave", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_PUSH] = { .name = "push", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_MRESTORE] = { .name = "mrest", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_POP] = { .name = "pop", .nsrc = 2, .ndst = 0 },
    [BRW_OPCODE_WAIT] = { .name = "wait", .nsrc = 1, .ndst = 0 },
    [BRW_OPCODE_DO] = { .name = "do", .nsrc = 0, .ndst = 0 },
    [BRW_OPCODE_ENDIF] = { .name = "endif", .nsrc = 2, .ndst = 0 },
};
static const struct opcode_desc *opcode = opcode_descs;

const char * const conditional_modifier[16] = {
    [BRW_CONDITIONAL_NONE] = "",
    [BRW_CONDITIONAL_Z] = ".e",
    [BRW_CONDITIONAL_NZ] = ".ne",
    [BRW_CONDITIONAL_G] = ".g",
    [BRW_CONDITIONAL_GE] = ".ge",
    [BRW_CONDITIONAL_L] = ".l",
    [BRW_CONDITIONAL_LE] = ".le",
    [BRW_CONDITIONAL_R] = ".r",
    [BRW_CONDITIONAL_O] = ".o",
    [BRW_CONDITIONAL_U] = ".u",
};

static const char * const negate[2] = {
    [0] = "",
    [1] = "-",
};

static const char * const _abs[2] = {
    [0] = "",
    [1] = "(abs)",
};

static const char * const vert_stride[16] = {
    [0] = "0",
    [1] = "1",
    [2] = "2",
    [3] = "4",
    [4] = "8",
    [5] = "16",
    [6] = "32",
    [15] = "VxH",
};

static const char * const width[8] = {
    [0] = "1",
    [1] = "2",
    [2] = "4",
    [3] = "8",
    [4] = "16",
};

static const char * const horiz_stride[4] = {
    [0] = "0",
    [1] = "1",
    [2] = "2",
    [3] = "4"
};

static const char * const chan_sel[4] = {
    [0] = "x",
    [1] = "y",
    [2] = "z",
    [3] = "w",
};

static const char * const debug_ctrl[2] = {
    [0] = "",
    [1] = ".breakpoint"
};

static const char * const saturate[2] = {
    [0] = "",
    [1] = ".sat"
};

static const char * const accwr[2] = {
    [0] = "",
    [1] = "AccWrEnable"
};

static const char * const wectrl[2] = {
    [0] = "WE_normal",
    [1] = "WE_all"
};

static const char * const exec_size[8] = {
    [0] = "1",
    [1] = "2",
    [2] = "4",
    [3] = "8",
    [4] = "16",
    [5] = "32"
};

static const char * const pred_inv[2] = {
    [0] = "+",
    [1] = "-"
};

static const char * const pred_ctrl_align16[16] = {
    [1] = "",
    [2] = ".x",
    [3] = ".y",
    [4] = ".z",
    [5] = ".w",
    [6] = ".any4h",
    [7] = ".all4h",
};

static const char * const pred_ctrl_align1[16] = {
    [1] = "",
    [2] = ".anyv",
    [3] = ".allv",
    [4] = ".any2h",
    [5] = ".all2h",
    [6] = ".any4h",
    [7] = ".all4h",
    [8] = ".any8h",
    [9] = ".all8h",
    [10] = ".any16h",
    [11] = ".all16h",
};

static const char * const thread_ctrl[4] = {
    [0] = "",
    [2] = "switch"
};

static const char * const compr_ctrl[4] = {
    [0] = "",
    [1] = "sechalf",
    [2] = "compr",
    [3] = "compr4",
};

static const char * const dep_ctrl[4] = {
    [0] = "",
    [1] = "NoDDClr",
    [2] = "NoDDChk",
    [3] = "NoDDClr,NoDDChk",
};

static const char * const mask_ctrl[4] = {
    [0] = "",
    [1] = "nomask",
};

static const char * const access_mode[2] = {
    [0] = "align1",
    [1] = "align16",
};

static const char * const reg_encoding[8] = {
    [0] = "UD",
    [1] = "D",
    [2] = "UW",
    [3] = "W",
    [4] = "UB",
    [5] = "B",
    [7] = "F"
};

const char * const three_source_reg_encoding[] = {
   [BRW_3SRC_TYPE_F]  = "F",
   [BRW_3SRC_TYPE_D]  = "D",
   [BRW_3SRC_TYPE_UD] = "UD",
};

const int reg_type_size[8] = {
    [0] = 4,
    [1] = 4,
    [2] = 2,
    [3] = 2,
    [4] = 1,
    [5] = 1,
    [7] = 4
};

static const char * const reg_file[4] = {
    [0] = "A",
    [1] = "g",
    [2] = "m",
    [3] = "imm",
};

static const char * const writemask[16] = {
    [0x0] = ".",
    [0x1] = ".x",
    [0x2] = ".y",
    [0x3] = ".xy",
    [0x4] = ".z",
    [0x5] = ".xz",
    [0x6] = ".yz",
    [0x7] = ".xyz",
    [0x8] = ".w",
    [0x9] = ".xw",
    [0xa] = ".yw",
    [0xb] = ".xyw",
    [0xc] = ".zw",
    [0xd] = ".xzw",
    [0xe] = ".yzw",
    [0xf] = "",
};

static const char * const end_of_thread[2] = {
    [0] = "",
    [1] = "EOT"
};

static const char * const target_function[16] = {
    [BRW_SFID_NULL] = "null",
    [BRW_SFID_MATH] = "math",
    [BRW_SFID_SAMPLER] = "sampler",
    [BRW_SFID_MESSAGE_GATEWAY] = "gateway",
    [BRW_SFID_DATAPORT_READ] = "read",
    [BRW_SFID_DATAPORT_WRITE] = "write",
    [BRW_SFID_URB] = "urb",
    [BRW_SFID_THREAD_SPAWNER] = "thread_spawner",
    [BRW_SFID_VME] = "vme",
};

static const char * const target_function_gen6[16] = {
    [BRW_SFID_NULL] = "null",
    [BRW_SFID_MATH] = "math",
    [BRW_SFID_SAMPLER] = "sampler",
    [BRW_SFID_MESSAGE_GATEWAY] = "gateway",
    [BRW_SFID_URB] = "urb",
    [BRW_SFID_THREAD_SPAWNER] = "thread_spawner",
    [GEN6_SFID_DATAPORT_SAMPLER_CACHE] = "sampler",
    [GEN6_SFID_DATAPORT_RENDER_CACHE] = "render",
    [GEN6_SFID_DATAPORT_CONSTANT_CACHE] = "const",
    [GEN7_SFID_DATAPORT_DATA_CACHE] = "data",
    [GEN7_SFID_PIXEL_INTERPOLATOR] = "pixel interp",
    [HSW_SFID_DATAPORT_DATA_CACHE_1] = "dp data 1",
    [HSW_SFID_CRE] = "cre",
};

static const char * const dp_rc_msg_type_gen6[16] = {
    [BRW_DATAPORT_READ_MESSAGE_OWORD_BLOCK_READ] = "OWORD block read",
    [GEN6_DATAPORT_READ_MESSAGE_RENDER_UNORM_READ] = "RT UNORM read",
    [GEN6_DATAPORT_READ_MESSAGE_OWORD_DUAL_BLOCK_READ] = "OWORD dual block read",
    [GEN6_DATAPORT_READ_MESSAGE_MEDIA_BLOCK_READ] = "media block read",
    [GEN6_DATAPORT_READ_MESSAGE_OWORD_UNALIGN_BLOCK_READ] = "OWORD unaligned block read",
    [GEN6_DATAPORT_READ_MESSAGE_DWORD_SCATTERED_READ] = "DWORD scattered read",
    [GEN6_DATAPORT_WRITE_MESSAGE_DWORD_ATOMIC_WRITE] = "DWORD atomic write",
    [GEN6_DATAPORT_WRITE_MESSAGE_OWORD_BLOCK_WRITE] = "OWORD block write",
    [GEN6_DATAPORT_WRITE_MESSAGE_OWORD_DUAL_BLOCK_WRITE] = "OWORD dual block write",
    [GEN6_DATAPORT_WRITE_MESSAGE_MEDIA_BLOCK_WRITE] = "media block write",
    [GEN6_DATAPORT_WRITE_MESSAGE_DWORD_SCATTERED_WRITE] = "DWORD scattered write",
    [GEN6_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_WRITE] = "RT write",
    [GEN6_DATAPORT_WRITE_MESSAGE_STREAMED_VB_WRITE] = "streamed VB write",
    [GEN6_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_UNORM_WRITE] = "RT UNORMc write",
};

static const char *const dp_dc0_msg_type_gen7[16] = {
    [GEN7_DATAPORT_DC_OWORD_BLOCK_READ] = "DC OWORD block read",
    [GEN7_DATAPORT_DC_UNALIGNED_OWORD_BLOCK_READ] = "DC unaligned OWORD block read",
    [GEN7_DATAPORT_DC_OWORD_DUAL_BLOCK_READ] = "DC OWORD dual block read",
    [GEN7_DATAPORT_DC_DWORD_SCATTERED_READ] = "DC DWORD scattered read",
    [GEN7_DATAPORT_DC_BYTE_SCATTERED_READ] = "DC byte scattered read",
    [GEN7_DATAPORT_DC_UNTYPED_ATOMIC_OP] = "DC untyped atomic",
    [GEN7_DATAPORT_DC_MEMORY_FENCE] = "DC mfence",
    [GEN7_DATAPORT_DC_OWORD_BLOCK_WRITE] = "DC OWORD block write",
    [GEN7_DATAPORT_DC_OWORD_DUAL_BLOCK_WRITE] = "DC OWORD dual block write",
    [GEN7_DATAPORT_DC_DWORD_SCATTERED_WRITE] = "DC DWORD scatterd write",
    [GEN7_DATAPORT_DC_BYTE_SCATTERED_WRITE] = "DC byte scattered write",
    [GEN7_DATAPORT_DC_UNTYPED_SURFACE_WRITE] = "DC untyped surface write",
};

static const char *const dp_dc1_msg_type_hsw[16] = {
    [HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_READ] = "untyped surface read",
    [HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP] = "DC untyped atomic op",
    [HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP_SIMD4X2] = "DC untyped 4x2 atomic op",
    [HSW_DATAPORT_DC_PORT1_MEDIA_BLOCK_READ] = "DC media block read",
    [HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_READ] = "DC typed surface read",
    [HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP] = "DC typed atomic",
    [HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP_SIMD4X2] = "DC typed 4x2 atomic op",
    [HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_WRITE] = "DC untyped surface write",
    [HSW_DATAPORT_DC_PORT1_MEDIA_BLOCK_WRITE] = "DC media block write",
    [HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP] = "DC atomic counter op",
    [HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP_SIMD4X2] = "DC 4x2 atomic counter op",
    [HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_WRITE] = "DC typed surface write",
};

static const char * const aop[16] = {
   [BRW_AOP_AND] = "and",
   [BRW_AOP_OR] = "or",
   [BRW_AOP_XOR] = "xor",
   [BRW_AOP_MOV] = "mov",
   [BRW_AOP_INC] = "inc",
   [BRW_AOP_DEC] = "dec",
   [BRW_AOP_ADD] = "add",
   [BRW_AOP_SUB] = "sub",
   [BRW_AOP_REVSUB] = "revsub",
   [BRW_AOP_IMAX] = "imax",
   [BRW_AOP_IMIN] = "imin",
   [BRW_AOP_UMAX] = "umax",
   [BRW_AOP_UMIN] = "umin",
   [BRW_AOP_CMPWR] = "cmpwr",
   [BRW_AOP_PREDEC] = "predec",
};

static const char * const math_function[16] = {
    [BRW_MATH_FUNCTION_INV] = "inv",
    [BRW_MATH_FUNCTION_LOG] = "log",
    [BRW_MATH_FUNCTION_EXP] = "exp",
    [BRW_MATH_FUNCTION_SQRT] = "sqrt",
    [BRW_MATH_FUNCTION_RSQ] = "rsq",
    [BRW_MATH_FUNCTION_SIN] = "sin",
    [BRW_MATH_FUNCTION_COS] = "cos",
    [BRW_MATH_FUNCTION_SINCOS] = "sincos",
    [BRW_MATH_FUNCTION_FDIV] = "fdiv",
    [BRW_MATH_FUNCTION_POW] = "pow",
    [BRW_MATH_FUNCTION_INT_DIV_QUOTIENT_AND_REMAINDER] = "intdivmod",
    [BRW_MATH_FUNCTION_INT_DIV_QUOTIENT] = "intdiv",
    [BRW_MATH_FUNCTION_INT_DIV_REMAINDER] = "intmod",
};

static const char * const math_saturate[2] = {
    [0] = "",
    [1] = "sat"
};

static const char * const math_signed[2] = {
    [0] = "",
    [1] = "signed"
};

static const char * const math_scalar[2] = {
    [0] = "",
    [1] = "scalar"
};

static const char * const math_precision[2] = {
    [0] = "",
    [1] = "partial_precision"
};

static const char * const urb_opcode[2] = {
    [0] = "urb_write",
    [1] = "ff_sync",
};

static const char * const urb_swizzle[4] = {
    [BRW_URB_SWIZZLE_NONE] = "",
    [BRW_URB_SWIZZLE_INTERLEAVE] = "interleave",
    [BRW_URB_SWIZZLE_TRANSPOSE] = "transpose",
};

static const char * const urb_allocate[2] = {
    [0] = "",
    [1] = "allocate"
};

static const char * const urb_used[2] = {
    [0] = "",
    [1] = "used"
};

static const char * const urb_complete[2] = {
    [0] = "",
    [1] = "complete"
};

static const char * const sampler_target_format[4] = {
    [0] = "F",
    [2] = "UD",
    [3] = "D"
};


static int column;

static int string (FILE *file, const char *string)
{
    fputs (string, file);
    column += strlen (string);
    return 0;
}

static int format (FILE *f, const char *format, ...)
{
    char    buf[1024];
    va_list	args;
    va_start (args, format);

    vsnprintf (buf, sizeof (buf) - 1, format, args);
    va_end (args);
    string (f, buf);
    return 0;
}

static int newline (FILE *f)
{
    putc ('\n', f);
    column = 0;
    return 0;
}

static int pad (FILE *f, int c)
{
    do
	string (f, " ");
    while (column < c);
    return 0;
}

static int control (FILE *file, const char *name, const char * const ctrl[],
                    unsigned id, int *space)
{
    if (!ctrl[id]) {
	fprintf (file, "*** invalid %s value %d ",
		 name, id);
	return 1;
    }
    if (ctrl[id][0])
    {
	if (space && *space)
	    string (file, " ");
	string (file, ctrl[id]);
	if (space)
	    *space = 1;
    }
    return 0;
}

static int print_opcode (FILE *file, int id)
{
    if (!opcode[id].name) {
	format (file, "*** invalid opcode value %d ", id);
	return 1;
    }
    string (file, opcode[id].name);
    return 0;
}

static int reg (FILE *file, unsigned _reg_file, unsigned _reg_nr)
{
    int	err = 0;

    /* Clear the Compr4 instruction compression bit. */
    if (_reg_file == BRW_MESSAGE_REGISTER_FILE)
       _reg_nr &= ~(1 << 7);

    if (_reg_file == BRW_ARCHITECTURE_REGISTER_FILE) {
	switch (_reg_nr & 0xf0) {
	case BRW_ARF_NULL:
	    string (file, "null");
	    return -1;
	case BRW_ARF_ADDRESS:
	    format (file, "a%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_ACCUMULATOR:
	    format (file, "acc%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_FLAG:
	    format (file, "f%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_MASK:
	    format (file, "mask%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_MASK_STACK:
	    format (file, "msd%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_STATE:
	    format (file, "sr%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_CONTROL:
	    format (file, "cr%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_NOTIFICATION_COUNT:
	    format (file, "n%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_IP:
	    string (file, "ip");
	    return -1;
	    break;
	default:
	    format (file, "ARF%d", _reg_nr);
	    break;
	}
    } else {
	err  |= control (file, "src reg file", reg_file, _reg_file, NULL);
	format (file, "%d", _reg_nr);
    }
    return err;
}

static int dest (FILE *file, struct brw_instruction *inst)
{
    int	err = 0;

    if (inst->header.access_mode == BRW_ALIGN_1)
    {
	if (inst->bits1.da1.dest_address_mode == BRW_ADDRESS_DIRECT)
	{
	    err |= reg (file, inst->bits1.da1.dest_reg_file, inst->bits1.da1.dest_reg_nr);
	    if (err == -1)
		return 0;
	    if (inst->bits1.da1.dest_subreg_nr)
		format (file, ".%d", inst->bits1.da1.dest_subreg_nr /
				     reg_type_size[inst->bits1.da1.dest_reg_type]);
	    string (file, "<");
	    err |= control (file, "horiz stride", horiz_stride, inst->bits1.da1.dest_horiz_stride, NULL);
	    string (file, ">");
	    err |= control (file, "dest reg encoding", reg_encoding, inst->bits1.da1.dest_reg_type, NULL);
	}
	else
	{
	    string (file, "g[a0");
	    if (inst->bits1.ia1.dest_subreg_nr)
		format (file, ".%d", inst->bits1.ia1.dest_subreg_nr /
					reg_type_size[inst->bits1.ia1.dest_reg_type]);
	    if (inst->bits1.ia1.dest_indirect_offset)
		format (file, " %d", inst->bits1.ia1.dest_indirect_offset);
	    string (file, "]<");
	    err |= control (file, "horiz stride", horiz_stride, inst->bits1.ia1.dest_horiz_stride, NULL);
	    string (file, ">");
	    err |= control (file, "dest reg encoding", reg_encoding, inst->bits1.ia1.dest_reg_type, NULL);
	}
    }
    else
    {
	if (inst->bits1.da16.dest_address_mode == BRW_ADDRESS_DIRECT)
	{
	    err |= reg (file, inst->bits1.da16.dest_reg_file, inst->bits1.da16.dest_reg_nr);
	    if (err == -1)
		return 0;
	    if (inst->bits1.da16.dest_subreg_nr)
		format (file, ".%d", inst->bits1.da16.dest_subreg_nr /
				     reg_type_size[inst->bits1.da16.dest_reg_type]);
	    string (file, "<1>");
	    err |= control (file, "writemask", writemask, inst->bits1.da16.dest_writemask, NULL);
	    err |= control (file, "dest reg encoding", reg_encoding, inst->bits1.da16.dest_reg_type, NULL);
	}
	else
	{
	    err = 1;
	    string (file, "Indirect align16 address mode not supported");
	}
    }

    return 0;
}

static int dest_3src (FILE *file, struct brw_instruction *inst)
{
    int	err = 0;
    uint32_t reg_file;

    if (inst->bits1.da3src.dest_reg_file)
       reg_file = BRW_MESSAGE_REGISTER_FILE;
    else
       reg_file = BRW_GENERAL_REGISTER_FILE;

    err |= reg (file, reg_file, inst->bits1.da3src.dest_reg_nr);
    if (err == -1)
       return 0;
    if (inst->bits1.da3src.dest_subreg_nr)
       format (file, ".%d", inst->bits1.da3src.dest_subreg_nr);
    string (file, "<1>");
    err |= control (file, "writemask", writemask, inst->bits1.da3src.dest_writemask, NULL);
    err |= control (file, "dest reg encoding", three_source_reg_encoding,
                    inst->bits1.da3src.dst_type, NULL);

    return 0;
}

static int src_align1_region (FILE *file,
			      unsigned _vert_stride, unsigned _width, unsigned _horiz_stride)
{
    int err = 0;
    string (file, "<");
    err |= control (file, "vert stride", vert_stride, _vert_stride, NULL);
    string (file, ",");
    err |= control (file, "width", width, _width, NULL);
    string (file, ",");
    err |= control (file, "horiz_stride", horiz_stride, _horiz_stride, NULL);
    string (file, ">");
    return err;
}

static int src_da1 (FILE *file, unsigned type, unsigned _reg_file,
		    unsigned _vert_stride, unsigned _width, unsigned _horiz_stride,
		    unsigned reg_num, unsigned sub_reg_num, unsigned __abs, unsigned _negate)
{
    int err = 0;
    err |= control (file, "negate", negate, _negate, NULL);
    err |= control (file, "abs", _abs, __abs, NULL);

    err |= reg (file, _reg_file, reg_num);
    if (err == -1)
	return 0;
    if (sub_reg_num)
	format (file, ".%d", sub_reg_num / reg_type_size[type]); /* use formal style like spec */
    src_align1_region (file, _vert_stride, _width, _horiz_stride);
    err |= control (file, "src reg encoding", reg_encoding, type, NULL);
    return err;
}

static int src_ia1 (FILE *file,
		    unsigned type,
		    unsigned _reg_file,
		    int _addr_imm,
		    unsigned _addr_subreg_nr,
		    unsigned _negate,
		    unsigned __abs,
		    unsigned _addr_mode,
		    unsigned _horiz_stride,
		    unsigned _width,
		    unsigned _vert_stride)
{
    int err = 0;
    err |= control (file, "negate", negate, _negate, NULL);
    err |= control (file, "abs", _abs, __abs, NULL);

    string (file, "g[a0");
    if (_addr_subreg_nr)
	format (file, ".%d", _addr_subreg_nr);
    if (_addr_imm)
	format (file, " %d", _addr_imm);
    string (file, "]");
    src_align1_region (file, _vert_stride, _width, _horiz_stride);
    err |= control (file, "src reg encoding", reg_encoding, type, NULL);
    return err;
}

static int src_da16 (FILE *file,
		     unsigned _reg_type,
		     unsigned _reg_file,
		     unsigned _vert_stride,
		     unsigned _reg_nr,
		     unsigned _subreg_nr,
		     unsigned __abs,
		     unsigned _negate,
		     unsigned swz_x,
		     unsigned swz_y,
		     unsigned swz_z,
		     unsigned swz_w)
{
    int err = 0;
    err |= control (file, "negate", negate, _negate, NULL);
    err |= control (file, "abs", _abs, __abs, NULL);

    err |= reg (file, _reg_file, _reg_nr);
    if (err == -1)
	return 0;
    if (_subreg_nr)
	/* bit4 for subreg number byte addressing. Make this same meaning as
	   in da1 case, so output looks consistent. */
	format (file, ".%d", 16 / reg_type_size[_reg_type]);
    string (file, "<");
    err |= control (file, "vert stride", vert_stride, _vert_stride, NULL);
    string (file, ",4,1>");
    /*
     * Three kinds of swizzle display:
     *  identity - nothing printed
     *  1->all	 - print the single channel
     *  1->1     - print the mapping
     */
    if (swz_x == BRW_CHANNEL_X &&
	swz_y == BRW_CHANNEL_Y &&
	swz_z == BRW_CHANNEL_Z &&
	swz_w == BRW_CHANNEL_W)
    {
	;
    }
    else if (swz_x == swz_y && swz_x == swz_z && swz_x == swz_w)
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
    }
    else
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
	err |= control (file, "channel select", chan_sel, swz_y, NULL);
	err |= control (file, "channel select", chan_sel, swz_z, NULL);
	err |= control (file, "channel select", chan_sel, swz_w, NULL);
    }
    err |= control (file, "src da16 reg type", reg_encoding, _reg_type, NULL);
    return err;
}

static int src0_3src (FILE *file, struct brw_instruction *inst)
{
    int err = 0;
    unsigned swz_x = (inst->bits2.da3src.src0_swizzle >> 0) & 0x3;
    unsigned swz_y = (inst->bits2.da3src.src0_swizzle >> 2) & 0x3;
    unsigned swz_z = (inst->bits2.da3src.src0_swizzle >> 4) & 0x3;
    unsigned swz_w = (inst->bits2.da3src.src0_swizzle >> 6) & 0x3;

    err |= control (file, "negate", negate, inst->bits1.da3src.src0_negate, NULL);
    err |= control (file, "abs", _abs, inst->bits1.da3src.src0_abs, NULL);

    err |= reg (file, BRW_GENERAL_REGISTER_FILE, inst->bits2.da3src.src0_reg_nr);
    if (err == -1)
	return 0;
    if (inst->bits2.da3src.src0_subreg_nr)
	format (file, ".%d", inst->bits2.da3src.src0_subreg_nr);
    if (inst->bits2.da3src.src0_rep_ctrl)
       string (file, "<0,1,0>");
    else
       string (file, "<4,4,1>");
    err |= control (file, "src da16 reg type", three_source_reg_encoding,
                    inst->bits1.da3src.src_type, NULL);
    /*
     * Three kinds of swizzle display:
     *  identity - nothing printed
     *  1->all	 - print the single channel
     *  1->1     - print the mapping
     */
    if (swz_x == BRW_CHANNEL_X &&
	swz_y == BRW_CHANNEL_Y &&
	swz_z == BRW_CHANNEL_Z &&
	swz_w == BRW_CHANNEL_W)
    {
	;
    }
    else if (swz_x == swz_y && swz_x == swz_z && swz_x == swz_w)
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
    }
    else
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
	err |= control (file, "channel select", chan_sel, swz_y, NULL);
	err |= control (file, "channel select", chan_sel, swz_z, NULL);
	err |= control (file, "channel select", chan_sel, swz_w, NULL);
    }
    return err;
}

static int src1_3src (FILE *file, struct brw_instruction *inst)
{
    int err = 0;
    unsigned swz_x = (inst->bits2.da3src.src1_swizzle >> 0) & 0x3;
    unsigned swz_y = (inst->bits2.da3src.src1_swizzle >> 2) & 0x3;
    unsigned swz_z = (inst->bits2.da3src.src1_swizzle >> 4) & 0x3;
    unsigned swz_w = (inst->bits2.da3src.src1_swizzle >> 6) & 0x3;
    unsigned src1_subreg_nr = (inst->bits2.da3src.src1_subreg_nr_low |
			     (inst->bits3.da3src.src1_subreg_nr_high << 2));

    err |= control (file, "negate", negate, inst->bits1.da3src.src1_negate,
		    NULL);
    err |= control (file, "abs", _abs, inst->bits1.da3src.src1_abs, NULL);

    err |= reg (file, BRW_GENERAL_REGISTER_FILE,
		inst->bits3.da3src.src1_reg_nr);
    if (err == -1)
	return 0;
    if (src1_subreg_nr)
	format (file, ".%d", src1_subreg_nr);
    if (inst->bits2.da3src.src1_rep_ctrl)
       string (file, "<0,1,0>");
    else
       string (file, "<4,4,1>");
    err |= control (file, "src da16 reg type", three_source_reg_encoding,
                    inst->bits1.da3src.src_type, NULL);
    /*
     * Three kinds of swizzle display:
     *  identity - nothing printed
     *  1->all	 - print the single channel
     *  1->1     - print the mapping
     */
    if (swz_x == BRW_CHANNEL_X &&
	swz_y == BRW_CHANNEL_Y &&
	swz_z == BRW_CHANNEL_Z &&
	swz_w == BRW_CHANNEL_W)
    {
	;
    }
    else if (swz_x == swz_y && swz_x == swz_z && swz_x == swz_w)
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
    }
    else
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
	err |= control (file, "channel select", chan_sel, swz_y, NULL);
	err |= control (file, "channel select", chan_sel, swz_z, NULL);
	err |= control (file, "channel select", chan_sel, swz_w, NULL);
    }
    return err;
}


static int src2_3src (FILE *file, struct brw_instruction *inst)
{
    int err = 0;
    unsigned swz_x = (inst->bits3.da3src.src2_swizzle >> 0) & 0x3;
    unsigned swz_y = (inst->bits3.da3src.src2_swizzle >> 2) & 0x3;
    unsigned swz_z = (inst->bits3.da3src.src2_swizzle >> 4) & 0x3;
    unsigned swz_w = (inst->bits3.da3src.src2_swizzle >> 6) & 0x3;

    err |= control (file, "negate", negate, inst->bits1.da3src.src2_negate,
		    NULL);
    err |= control (file, "abs", _abs, inst->bits1.da3src.src2_abs, NULL);

    err |= reg (file, BRW_GENERAL_REGISTER_FILE,
		inst->bits3.da3src.src2_reg_nr);
    if (err == -1)
	return 0;
    if (inst->bits3.da3src.src2_subreg_nr)
	format (file, ".%d", inst->bits3.da3src.src2_subreg_nr);
    if (inst->bits3.da3src.src2_rep_ctrl)
       string (file, "<0,1,0>");
    else
       string (file, "<4,4,1>");
    err |= control (file, "src da16 reg type", three_source_reg_encoding,
                    inst->bits1.da3src.src_type, NULL);
    /*
     * Three kinds of swizzle display:
     *  identity - nothing printed
     *  1->all	 - print the single channel
     *  1->1     - print the mapping
     */
    if (swz_x == BRW_CHANNEL_X &&
	swz_y == BRW_CHANNEL_Y &&
	swz_z == BRW_CHANNEL_Z &&
	swz_w == BRW_CHANNEL_W)
    {
	;
    }
    else if (swz_x == swz_y && swz_x == swz_z && swz_x == swz_w)
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
    }
    else
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
	err |= control (file, "channel select", chan_sel, swz_y, NULL);
	err |= control (file, "channel select", chan_sel, swz_z, NULL);
	err |= control (file, "channel select", chan_sel, swz_w, NULL);
    }
    return err;
}

static int imm (FILE *file, unsigned type, struct brw_instruction *inst) {
    switch (type) {
    case BRW_HW_REG_TYPE_UD:
	format (file, "0x%08xUD", inst->bits3.ud);
	break;
    case BRW_HW_REG_TYPE_D:
	format (file, "%dD", inst->bits3.d);
	break;
    case BRW_HW_REG_TYPE_UW:
	format (file, "0x%04xUW", (uint16_t) inst->bits3.ud);
	break;
    case BRW_HW_REG_TYPE_W:
	format (file, "%dW", (int16_t) inst->bits3.d);
	break;
    case BRW_HW_REG_IMM_TYPE_UV:
	format (file, "0x%08xUV", inst->bits3.ud);
	break;
    case BRW_HW_REG_IMM_TYPE_VF:
	format (file, "Vector Float");
	break;
    case BRW_HW_REG_IMM_TYPE_V:
	format (file, "0x%08xV", inst->bits3.ud);
	break;
    case BRW_HW_REG_TYPE_F:
	format (file, "%-gF", inst->bits3.f);
    }
    return 0;
}

static int src0 (FILE *file, struct brw_instruction *inst)
{
    if (inst->bits1.da1.src0_reg_file == BRW_IMMEDIATE_VALUE)
	return imm (file, inst->bits1.da1.src0_reg_type,
		    inst);
    else if (inst->header.access_mode == BRW_ALIGN_1)
    {
	if (inst->bits2.da1.src0_address_mode == BRW_ADDRESS_DIRECT)
	{
	    return src_da1 (file,
			    inst->bits1.da1.src0_reg_type,
			    inst->bits1.da1.src0_reg_file,
			    inst->bits2.da1.src0_vert_stride,
			    inst->bits2.da1.src0_width,
			    inst->bits2.da1.src0_horiz_stride,
			    inst->bits2.da1.src0_reg_nr,
			    inst->bits2.da1.src0_subreg_nr,
			    inst->bits2.da1.src0_abs,
			    inst->bits2.da1.src0_negate);
	}
	else
	{
	    return src_ia1 (file,
			    inst->bits1.ia1.src0_reg_type,
			    inst->bits1.ia1.src0_reg_file,
			    inst->bits2.ia1.src0_indirect_offset,
			    inst->bits2.ia1.src0_subreg_nr,
			    inst->bits2.ia1.src0_negate,
			    inst->bits2.ia1.src0_abs,
			    inst->bits2.ia1.src0_address_mode,
			    inst->bits2.ia1.src0_horiz_stride,
			    inst->bits2.ia1.src0_width,
			    inst->bits2.ia1.src0_vert_stride);
	}
    }
    else
    {
	if (inst->bits2.da16.src0_address_mode == BRW_ADDRESS_DIRECT)
	{
	    return src_da16 (file,
			     inst->bits1.da16.src0_reg_type,
			     inst->bits1.da16.src0_reg_file,
			     inst->bits2.da16.src0_vert_stride,
			     inst->bits2.da16.src0_reg_nr,
			     inst->bits2.da16.src0_subreg_nr,
			     inst->bits2.da16.src0_abs,
			     inst->bits2.da16.src0_negate,
			     inst->bits2.da16.src0_swz_x,
			     inst->bits2.da16.src0_swz_y,
			     inst->bits2.da16.src0_swz_z,
			     inst->bits2.da16.src0_swz_w);
	}
	else
	{
	    string (file, "Indirect align16 address mode not supported");
	    return 1;
	}
    }
}

static int src1 (FILE *file, struct brw_instruction *inst)
{
    if (inst->bits1.da1.src1_reg_file == BRW_IMMEDIATE_VALUE)
	return imm (file, inst->bits1.da1.src1_reg_type,
		    inst);
    else if (inst->header.access_mode == BRW_ALIGN_1)
    {
	if (inst->bits3.da1.src1_address_mode == BRW_ADDRESS_DIRECT)
	{
	    return src_da1 (file,
			    inst->bits1.da1.src1_reg_type,
			    inst->bits1.da1.src1_reg_file,
			    inst->bits3.da1.src1_vert_stride,
			    inst->bits3.da1.src1_width,
			    inst->bits3.da1.src1_horiz_stride,
			    inst->bits3.da1.src1_reg_nr,
			    inst->bits3.da1.src1_subreg_nr,
			    inst->bits3.da1.src1_abs,
			    inst->bits3.da1.src1_negate);
	}
	else
	{
	    return src_ia1 (file,
			    inst->bits1.ia1.src1_reg_type,
			    inst->bits1.ia1.src1_reg_file,
			    inst->bits3.ia1.src1_indirect_offset,
			    inst->bits3.ia1.src1_subreg_nr,
			    inst->bits3.ia1.src1_negate,
			    inst->bits3.ia1.src1_abs,
			    inst->bits3.ia1.src1_address_mode,
			    inst->bits3.ia1.src1_horiz_stride,
			    inst->bits3.ia1.src1_width,
			    inst->bits3.ia1.src1_vert_stride);
	}
    }
    else
    {
	if (inst->bits3.da16.src1_address_mode == BRW_ADDRESS_DIRECT)
	{
	    return src_da16 (file,
			     inst->bits1.da16.src1_reg_type,
			     inst->bits1.da16.src1_reg_file,
			     inst->bits3.da16.src1_vert_stride,
			     inst->bits3.da16.src1_reg_nr,
			     inst->bits3.da16.src1_subreg_nr,
			     inst->bits3.da16.src1_abs,
			     inst->bits3.da16.src1_negate,
			     inst->bits3.da16.src1_swz_x,
			     inst->bits3.da16.src1_swz_y,
			     inst->bits3.da16.src1_swz_z,
			     inst->bits3.da16.src1_swz_w);
	}
	else
	{
	    string (file, "Indirect align16 address mode not supported");
	    return 1;
	}
    }
}

static int qtr_ctrl(FILE *file, struct brw_instruction *inst)
{
    int qtr_ctl = inst->header.compression_control;
    int exec_size = 1 << inst->header.execution_size;

    if (exec_size == 8) {
	switch (qtr_ctl) {
	case 0:
	    string (file, " 1Q");
	    break;
	case 1:
	    string (file, " 2Q");
	    break;
	case 2:
	    string (file, " 3Q");
	    break;
	case 3:
	    string (file, " 4Q");
	    break;
	}
    } else if (exec_size == 16){
	if (qtr_ctl < 2)
	    string (file, " 1H");
	else
	    string (file, " 2H");
    }
    return 0;
}

int brw_disasm (FILE *file, struct brw_instruction *inst, int gen)
{
    int	err = 0;
    int space = 0;

    if (inst->header.predicate_control) {
	string (file, "(");
	err |= control (file, "predicate inverse", pred_inv, inst->header.predicate_inverse, NULL);
	format (file, "f%d", gen >= 7 ? inst->bits2.da1.flag_reg_nr : 0);
	if (inst->bits2.da1.flag_subreg_nr)
	    format (file, ".%d", inst->bits2.da1.flag_subreg_nr);
	if (inst->header.access_mode == BRW_ALIGN_1)
	    err |= control (file, "predicate control align1", pred_ctrl_align1,
			    inst->header.predicate_control, NULL);
	else
	    err |= control (file, "predicate control align16", pred_ctrl_align16,
			    inst->header.predicate_control, NULL);
	string (file, ") ");
    }

    err |= print_opcode (file, inst->header.opcode);
    err |= control (file, "saturate", saturate, inst->header.saturate, NULL);
    err |= control (file, "debug control", debug_ctrl, inst->header.debug_control, NULL);

    if (inst->header.opcode == BRW_OPCODE_MATH) {
	string (file, " ");
	err |= control (file, "function", math_function,
			inst->header.destreg__conditionalmod, NULL);
    } else if (inst->header.opcode != BRW_OPCODE_SEND &&
	       inst->header.opcode != BRW_OPCODE_SENDC) {
	err |= control (file, "conditional modifier", conditional_modifier,
			inst->header.destreg__conditionalmod, NULL);

        /* If we're using the conditional modifier, print which flags reg is
         * used for it.  Note that on gen6+, the embedded-condition SEL and
         * control flow doesn't update flags.
         */
	if (inst->header.destreg__conditionalmod &&
            (gen < 6 || (inst->header.opcode != BRW_OPCODE_SEL &&
                         inst->header.opcode != BRW_OPCODE_IF &&
                         inst->header.opcode != BRW_OPCODE_WHILE))) {
	    format (file, ".f%d", gen >= 7 ? inst->bits2.da1.flag_reg_nr : 0);
	    if (inst->bits2.da1.flag_subreg_nr)
		format (file, ".%d", inst->bits2.da1.flag_subreg_nr);
        }
    }

    if (inst->header.opcode != BRW_OPCODE_NOP) {
	string (file, "(");
	err |= control (file, "execution size", exec_size, inst->header.execution_size, NULL);
	string (file, ")");
    }

    if (inst->header.opcode == BRW_OPCODE_SEND && gen < 6)
	format (file, " %d", inst->header.destreg__conditionalmod);

    if (opcode[inst->header.opcode].nsrc == 3) {
       pad (file, 16);
       err |= dest_3src (file, inst);

       pad (file, 32);
       err |= src0_3src (file, inst);

       pad (file, 48);
       err |= src1_3src (file, inst);

       pad (file, 64);
       err |= src2_3src (file, inst);
    } else {
       if (opcode[inst->header.opcode].ndst > 0) {
	  pad (file, 16);
	  err |= dest (file, inst);
       } else if (gen == 7 && (inst->header.opcode == BRW_OPCODE_ELSE ||
			       inst->header.opcode == BRW_OPCODE_ENDIF ||
			       inst->header.opcode == BRW_OPCODE_WHILE)) {
	  format (file, " %d", inst->bits3.break_cont.jip);
       } else if (gen == 6 && (inst->header.opcode == BRW_OPCODE_IF ||
			       inst->header.opcode == BRW_OPCODE_ELSE ||
			       inst->header.opcode == BRW_OPCODE_ENDIF ||
			       inst->header.opcode == BRW_OPCODE_WHILE)) {
	  format (file, " %d", inst->bits1.branch_gen6.jump_count);
       } else if ((gen >= 6 && (inst->header.opcode == BRW_OPCODE_BREAK ||
                                inst->header.opcode == BRW_OPCODE_CONTINUE ||
                                inst->header.opcode == BRW_OPCODE_HALT)) ||
                  (gen == 7 && inst->header.opcode == BRW_OPCODE_IF)) {
	  format (file, " %d %d", inst->bits3.break_cont.uip, inst->bits3.break_cont.jip);
       } else if (inst->header.opcode == BRW_OPCODE_JMPI) {
	  format (file, " %d", inst->bits3.d);
       }

       if (opcode[inst->header.opcode].nsrc > 0) {
	  pad (file, 32);
	  err |= src0 (file, inst);
       }
       if (opcode[inst->header.opcode].nsrc > 1) {
	  pad (file, 48);
	  err |= src1 (file, inst);
       }
    }

    if (inst->header.opcode == BRW_OPCODE_SEND ||
	inst->header.opcode == BRW_OPCODE_SENDC) {
	enum brw_message_target target;

	if (gen >= 6)
	    target = inst->header.destreg__conditionalmod;
	else if (gen == 5)
	    target = inst->bits2.send_gen5.sfid;
	else
	    target = inst->bits3.generic.msg_target;

	newline (file);
	pad (file, 16);
	space = 0;

	if (gen >= 6) {
	   err |= control (file, "target function", target_function_gen6,
			   target, &space);
	} else {
	   err |= control (file, "target function", target_function,
			   target, &space);
	}

	switch (target) {
	case BRW_SFID_MATH:
	    err |= control (file, "math function", math_function,
			    inst->bits3.math.function, &space);
	    err |= control (file, "math saturate", math_saturate,
			    inst->bits3.math.saturate, &space);
	    err |= control (file, "math signed", math_signed,
			    inst->bits3.math.int_type, &space);
	    err |= control (file, "math scalar", math_scalar,
			    inst->bits3.math.data_type, &space);
	    err |= control (file, "math precision", math_precision,
			    inst->bits3.math.precision, &space);
	    break;
	case BRW_SFID_SAMPLER:
	    if (gen >= 7) {
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.sampler_gen7.binding_table_index,
			inst->bits3.sampler_gen7.sampler,
			inst->bits3.sampler_gen7.msg_type,
			inst->bits3.sampler_gen7.simd_mode);
	    } else if (gen >= 5) {
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.sampler_gen5.binding_table_index,
			inst->bits3.sampler_gen5.sampler,
			inst->bits3.sampler_gen5.msg_type,
			inst->bits3.sampler_gen5.simd_mode);
	    } else if (0 /* FINISHME: is_g4x */) {
		format (file, " (%d, %d)",
			inst->bits3.sampler_g4x.binding_table_index,
			inst->bits3.sampler_g4x.sampler);
	    } else {
		format (file, " (%d, %d, ",
			inst->bits3.sampler.binding_table_index,
			inst->bits3.sampler.sampler);
		err |= control (file, "sampler target format",
				sampler_target_format,
				inst->bits3.sampler.return_format, NULL);
		string (file, ")");
	    }
	    break;
	case BRW_SFID_DATAPORT_READ:
	    if (gen >= 6) {
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.gen6_dp.binding_table_index,
			inst->bits3.gen6_dp.msg_control,
			inst->bits3.gen6_dp.msg_type,
			inst->bits3.gen6_dp.send_commit_msg);
	    } else if (gen >= 5 /* FINISHME: || is_g4x */) {
		format (file, " (%d, %d, %d)",
			inst->bits3.dp_read_gen5.binding_table_index,
			inst->bits3.dp_read_gen5.msg_control,
			inst->bits3.dp_read_gen5.msg_type);
	    } else {
		format (file, " (%d, %d, %d)",
			inst->bits3.dp_read.binding_table_index,
			inst->bits3.dp_read.msg_control,
			inst->bits3.dp_read.msg_type);
	    }
	    break;

	case BRW_SFID_DATAPORT_WRITE:
	    if (gen >= 7) {
		format (file, " (");

		err |= control (file, "DP rc message type",
				dp_rc_msg_type_gen6,
				inst->bits3.gen7_dp.msg_type, &space);

		format (file, ", %d, %d, %d)",
			inst->bits3.gen7_dp.binding_table_index,
			inst->bits3.gen7_dp.msg_control,
			inst->bits3.gen7_dp.msg_type);
	    } else if (gen == 6) {
		format (file, " (");

		err |= control (file, "DP rc message type",
				dp_rc_msg_type_gen6,
				inst->bits3.gen6_dp.msg_type, &space);

		format (file, ", %d, %d, %d, %d)",
			inst->bits3.gen6_dp.binding_table_index,
			inst->bits3.gen6_dp.msg_control,
			inst->bits3.gen6_dp.msg_type,
			inst->bits3.gen6_dp.send_commit_msg);
	    } else {
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.dp_write.binding_table_index,
			(inst->bits3.dp_write.last_render_target << 3) |
			inst->bits3.dp_write.msg_control,
			inst->bits3.dp_write.msg_type,
			inst->bits3.dp_write.send_commit_msg);
	    }
	    break;

	case BRW_SFID_URB:
	    if (gen >= 5) {
		format (file, " %d", inst->bits3.urb_gen5.offset);
	    } else {
		format (file, " %d", inst->bits3.urb.offset);
	    }

	    space = 1;
	    if (gen >= 5) {
		err |= control (file, "urb opcode", urb_opcode,
				inst->bits3.urb_gen5.opcode, &space);
	    }
	    err |= control (file, "urb swizzle", urb_swizzle,
			    inst->bits3.urb.swizzle_control, &space);
	    err |= control (file, "urb allocate", urb_allocate,
			    inst->bits3.urb.allocate, &space);
	    err |= control (file, "urb used", urb_used,
			    inst->bits3.urb.used, &space);
	    err |= control (file, "urb complete", urb_complete,
			    inst->bits3.urb.complete, &space);
	    break;
	case BRW_SFID_THREAD_SPAWNER:
	    break;
	case GEN7_SFID_DATAPORT_DATA_CACHE:
           if (gen >= 7) {
              format (file, " (");

              err |= control (file, "DP DC0 message type",
                              dp_dc0_msg_type_gen7,
                              inst->bits3.gen7_dp.msg_type, &space);

              format (file, ", %d, ", inst->bits3.gen7_dp.binding_table_index);

              switch (inst->bits3.gen7_dp.msg_type) {
              case GEN7_DATAPORT_DC_UNTYPED_ATOMIC_OP:
                 control (file, "atomic op", aop, inst->bits3.ud >> 8 & 0xf,
                          &space);
                 break;
              default:
                 format (file, "%d", inst->bits3.gen7_dp.msg_control);
              }
              format (file, ")");
              break;
           }
           /* FALLTHROUGH */

	case HSW_SFID_DATAPORT_DATA_CACHE_1:
	    if (gen >= 7) {
		format (file, " (");

		err |= control (file, "DP DC1 message type",
				dp_dc1_msg_type_hsw,
				inst->bits3.gen7_dp.msg_type, &space);

		format (file, ", %d, ",
			inst->bits3.gen7_dp.binding_table_index);

                switch (inst->bits3.gen7_dp.msg_type) {
                case HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP:
                case HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP_SIMD4X2:
                case HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP:
                case HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP_SIMD4X2:
                case HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP:
                case HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP_SIMD4X2:
                   control (file, "atomic op", aop,
                            inst->bits3.ud >> 8 & 0xf, &space);
                   break;
                default:
                   format (file, "%d", inst->bits3.gen7_dp.msg_control);
                }
                format (file, ")");
                break;
            }
            /* FALLTHROUGH */

	default:
	    format (file, "unsupported target %d", target);
	    break;
	}
	if (space)
	    string (file, " ");
	if (gen >= 5) {
	   format (file, "mlen %d",
		   inst->bits3.generic_gen5.msg_length);
	   format (file, " rlen %d",
		   inst->bits3.generic_gen5.response_length);
	} else {
	   format (file, "mlen %d",
		   inst->bits3.generic.msg_length);
	   format (file, " rlen %d",
		   inst->bits3.generic.response_length);
	}
    }
    pad (file, 64);
    if (inst->header.opcode != BRW_OPCODE_NOP) {
	string (file, "{");
	space = 1;
	err |= control(file, "access mode", access_mode, inst->header.access_mode, &space);
	if (gen >= 6)
	    err |= control (file, "write enable control", wectrl, inst->header.mask_control, &space);
	else
	    err |= control (file, "mask control", mask_ctrl, inst->header.mask_control, &space);
	err |= control (file, "dependency control", dep_ctrl, inst->header.dependency_control, &space);

	if (gen >= 6)
	    err |= qtr_ctrl (file, inst);
	else {
	    if (inst->header.compression_control == BRW_COMPRESSION_COMPRESSED &&
		opcode[inst->header.opcode].ndst > 0 &&
		inst->bits1.da1.dest_reg_file == BRW_MESSAGE_REGISTER_FILE &&
		inst->bits1.da1.dest_reg_nr & (1 << 7)) {
		format (file, " compr4");
	    } else {
		err |= control (file, "compression control", compr_ctrl,
				inst->header.compression_control, &space);
	    }
	}

	err |= control (file, "thread control", thread_ctrl, inst->header.thread_control, &space);
	if (gen >= 6)
	    err |= control (file, "acc write control", accwr, inst->header.acc_wr_control, &space);
	if (inst->header.opcode == BRW_OPCODE_SEND ||
	    inst->header.opcode == BRW_OPCODE_SENDC)
	    err |= control (file, "end of thread", end_of_thread,
			    inst->bits3.generic.end_of_thread, &space);
	if (space)
	    string (file, " ");
	string (file, "}");
    }
    string (file, ";");
    newline (file);
    return err;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d30 2
a33 2
#include "brw_reg.h"
#include "brw_inst.h"
d36 219
a254 196
   [BRW_OPCODE_MOV]      = { .name = "mov",     .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_FRC]      = { .name = "frc",     .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_RNDU]     = { .name = "rndu",    .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_RNDD]     = { .name = "rndd",    .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_RNDE]     = { .name = "rnde",    .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_RNDZ]     = { .name = "rndz",    .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_NOT]      = { .name = "not",     .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_LZD]      = { .name = "lzd",     .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_F32TO16]  = { .name = "f32to16", .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_F16TO32]  = { .name = "f16to32", .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_BFREV]    = { .name = "bfrev",   .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_FBH]      = { .name = "fbh",     .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_FBL]      = { .name = "fbl",     .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_CBIT]     = { .name = "cbit",    .nsrc = 1, .ndst = 1 },

   [BRW_OPCODE_MUL]      = { .name = "mul",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_MAC]      = { .name = "mac",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_MACH]     = { .name = "mach",    .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_LINE]     = { .name = "line",    .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_PLN]      = { .name = "pln",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_MAD]      = { .name = "mad",     .nsrc = 3, .ndst = 1 },
   [BRW_OPCODE_LRP]      = { .name = "lrp",     .nsrc = 3, .ndst = 1 },
   [BRW_OPCODE_SAD2]     = { .name = "sad2",    .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_SADA2]    = { .name = "sada2",   .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_DP4]      = { .name = "dp4",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_DPH]      = { .name = "dph",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_DP3]      = { .name = "dp3",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_DP2]      = { .name = "dp2",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_MATH]     = { .name = "math",    .nsrc = 2, .ndst = 1 },

   [BRW_OPCODE_AVG]      = { .name = "avg",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_ADD]      = { .name = "add",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_SEL]      = { .name = "sel",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_AND]      = { .name = "and",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_OR]       = { .name = "or",      .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_XOR]      = { .name = "xor",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_SHR]      = { .name = "shr",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_SHL]      = { .name = "shl",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_ASR]      = { .name = "asr",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_CMP]      = { .name = "cmp",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_CMPN]     = { .name = "cmpn",    .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_CSEL]     = { .name = "csel",    .nsrc = 3, .ndst = 1 },
   [BRW_OPCODE_BFE]      = { .name = "bfe",     .nsrc = 3, .ndst = 1 },
   [BRW_OPCODE_BFI1]     = { .name = "bfi1",    .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_BFI2]     = { .name = "bfi2",    .nsrc = 3, .ndst = 1 },
   [BRW_OPCODE_ADDC]     = { .name = "addc",    .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_SUBB]     = { .name = "subb",    .nsrc = 2, .ndst = 1 },

   [BRW_OPCODE_SEND]     = { .name = "send",    .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_SENDC]    = { .name = "sendc",   .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_NOP]      = { .name = "nop",     .nsrc = 0, .ndst = 0 },
   [BRW_OPCODE_NENOP]    = { .name = "nenop",   .nsrc = 0, .ndst = 0 },
   [BRW_OPCODE_JMPI]     = { .name = "jmpi",    .nsrc = 0, .ndst = 0 },
   [BRW_OPCODE_IF]       = { .name = "if",      .nsrc = 2, .ndst = 0 },
   [BRW_OPCODE_IFF]      = { .name = "iff",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_WHILE]    = { .name = "while",   .nsrc = 2, .ndst = 0 },
   [BRW_OPCODE_ELSE]     = { .name = "else",    .nsrc = 2, .ndst = 0 },
   [BRW_OPCODE_BREAK]    = { .name = "break",   .nsrc = 2, .ndst = 0 },
   [BRW_OPCODE_CONTINUE] = { .name = "cont",    .nsrc = 1, .ndst = 0 },
   [BRW_OPCODE_HALT]     = { .name = "halt",    .nsrc = 1, .ndst = 0 },
   [BRW_OPCODE_MSAVE]    = { .name = "msave",   .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_PUSH]     = { .name = "push",    .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_MRESTORE] = { .name = "mrest",   .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_POP]      = { .name = "pop",     .nsrc = 2, .ndst = 0 },
   [BRW_OPCODE_WAIT]     = { .name = "wait",    .nsrc = 1, .ndst = 0 },
   [BRW_OPCODE_DO]       = { .name = "do",      .nsrc = 0, .ndst = 0 },
   [BRW_OPCODE_ENDIF]    = { .name = "endif",   .nsrc = 2, .ndst = 0 },
};

static bool
has_jip(struct brw_context *brw, enum opcode opcode)
{
   if (brw->gen < 6)
      return false;

   return opcode == BRW_OPCODE_IF ||
          opcode == BRW_OPCODE_ELSE ||
          opcode == BRW_OPCODE_ENDIF ||
          opcode == BRW_OPCODE_WHILE ||
          opcode == BRW_OPCODE_BREAK ||
          opcode == BRW_OPCODE_CONTINUE ||
          opcode == BRW_OPCODE_HALT;
}

static bool
has_uip(struct brw_context *brw, enum opcode opcode)
{
   if (brw->gen < 6)
      return false;

   return (brw->gen >= 7 && opcode == BRW_OPCODE_IF) ||
          (brw->gen >= 8 && opcode == BRW_OPCODE_ELSE) ||
          opcode == BRW_OPCODE_BREAK ||
          opcode == BRW_OPCODE_CONTINUE ||
          opcode == BRW_OPCODE_HALT;
}

static bool
is_logic_instruction(unsigned opcode)
{
   return opcode == BRW_OPCODE_AND ||
          opcode == BRW_OPCODE_NOT ||
          opcode == BRW_OPCODE_OR ||
          opcode == BRW_OPCODE_XOR;
}

const char *const conditional_modifier[16] = {
   [BRW_CONDITIONAL_NONE] = "",
   [BRW_CONDITIONAL_Z]    = ".z",
   [BRW_CONDITIONAL_NZ]   = ".nz",
   [BRW_CONDITIONAL_G]    = ".g",
   [BRW_CONDITIONAL_GE]   = ".ge",
   [BRW_CONDITIONAL_L]    = ".l",
   [BRW_CONDITIONAL_LE]   = ".le",
   [BRW_CONDITIONAL_R]    = ".r",
   [BRW_CONDITIONAL_O]    = ".o",
   [BRW_CONDITIONAL_U]    = ".u",
};

static const char *const m_negate[2] = {
   [0] = "",
   [1] = "-",
};

static const char *const _abs[2] = {
   [0] = "",
   [1] = "(abs)",
};

static const char *const m_bitnot[2] = { "", "~" };

static const char *const vert_stride[16] = {
   [0] = "0",
   [1] = "1",
   [2] = "2",
   [3] = "4",
   [4] = "8",
   [5] = "16",
   [6] = "32",
   [15] = "VxH",
};

static const char *const width[8] = {
   [0] = "1",
   [1] = "2",
   [2] = "4",
   [3] = "8",
   [4] = "16",
};

static const char *const horiz_stride[4] = {
   [0] = "0",
   [1] = "1",
   [2] = "2",
   [3] = "4"
};

static const char *const chan_sel[4] = {
   [0] = "x",
   [1] = "y",
   [2] = "z",
   [3] = "w",
};

static const char *const debug_ctrl[2] = {
   [0] = "",
   [1] = ".breakpoint"
};

static const char *const saturate[2] = {
   [0] = "",
   [1] = ".sat"
};

static const char *const cmpt_ctrl[2] = {
   [0] = "",
   [1] = "compacted"
};

static const char *const accwr[2] = {
   [0] = "",
   [1] = "AccWrEnable"
};

static const char *const wectrl[2] = {
   [0] = "",
   [1] = "WE_all"
};

static const char *const exec_size[8] = {
   [0] = "1",
   [1] = "2",
   [2] = "4",
   [3] = "8",
   [4] = "16",
   [5] = "32"
d257 1
a257 76
static const char *const pred_inv[2] = {
   [0] = "+",
   [1] = "-"
};

static const char *const pred_ctrl_align16[16] = {
   [1] = "",
   [2] = ".x",
   [3] = ".y",
   [4] = ".z",
   [5] = ".w",
   [6] = ".any4h",
   [7] = ".all4h",
};

static const char *const pred_ctrl_align1[16] = {
   [BRW_PREDICATE_NORMAL]        = "",
   [BRW_PREDICATE_ALIGN1_ANYV]   = ".anyv",
   [BRW_PREDICATE_ALIGN1_ALLV]   = ".allv",
   [BRW_PREDICATE_ALIGN1_ANY2H]  = ".any2h",
   [BRW_PREDICATE_ALIGN1_ALL2H]  = ".all2h",
   [BRW_PREDICATE_ALIGN1_ANY4H]  = ".any4h",
   [BRW_PREDICATE_ALIGN1_ALL4H]  = ".all4h",
   [BRW_PREDICATE_ALIGN1_ANY8H]  = ".any8h",
   [BRW_PREDICATE_ALIGN1_ALL8H]  = ".all8h",
   [BRW_PREDICATE_ALIGN1_ANY16H] = ".any16h",
   [BRW_PREDICATE_ALIGN1_ALL16H] = ".all16h",
   [BRW_PREDICATE_ALIGN1_ANY32H] = ".any32h",
   [BRW_PREDICATE_ALIGN1_ANY32H] = ".all32h",
};

static const char *const thread_ctrl[4] = {
   [BRW_THREAD_NORMAL] = "",
   [BRW_THREAD_ATOMIC] = "atomic",
   [BRW_THREAD_SWITCH] = "switch",
};

static const char *const compr_ctrl[4] = {
   [0] = "",
   [1] = "sechalf",
   [2] = "compr",
   [3] = "compr4",
};

static const char *const dep_ctrl[4] = {
   [0] = "",
   [1] = "NoDDClr",
   [2] = "NoDDChk",
   [3] = "NoDDClr,NoDDChk",
};

static const char *const mask_ctrl[4] = {
   [0] = "",
   [1] = "nomask",
};

static const char *const access_mode[2] = {
   [0] = "align1",
   [1] = "align16",
};

static const char * const reg_encoding[] = {
   [BRW_HW_REG_TYPE_UD]          = "UD",
   [BRW_HW_REG_TYPE_D]           = "D",
   [BRW_HW_REG_TYPE_UW]          = "UW",
   [BRW_HW_REG_TYPE_W]           = "W",
   [BRW_HW_REG_NON_IMM_TYPE_UB]  = "UB",
   [BRW_HW_REG_NON_IMM_TYPE_B]   = "B",
   [GEN7_HW_REG_NON_IMM_TYPE_DF] = "DF",
   [BRW_HW_REG_TYPE_F]           = "F",
   [GEN8_HW_REG_TYPE_UQ]         = "UQ",
   [GEN8_HW_REG_TYPE_Q]          = "Q",
   [GEN8_HW_REG_NON_IMM_TYPE_HF] = "HF",
};

static const char *const three_source_reg_encoding[] = {
d263 84
a346 113
const int reg_type_size[] = {
   [BRW_HW_REG_TYPE_UD]          = 4,
   [BRW_HW_REG_TYPE_D]           = 4,
   [BRW_HW_REG_TYPE_UW]          = 2,
   [BRW_HW_REG_TYPE_W]           = 2,
   [BRW_HW_REG_NON_IMM_TYPE_UB]  = 1,
   [BRW_HW_REG_NON_IMM_TYPE_B]   = 1,
   [GEN7_HW_REG_NON_IMM_TYPE_DF] = 8,
   [BRW_HW_REG_TYPE_F]           = 4,
   [GEN8_HW_REG_TYPE_UQ]         = 8,
   [GEN8_HW_REG_TYPE_Q]          = 8,
   [GEN8_HW_REG_NON_IMM_TYPE_HF] = 2,
};

static const char *const reg_file[4] = {
   [0] = "A",
   [1] = "g",
   [2] = "m",
   [3] = "imm",
};

static const char *const writemask[16] = {
   [0x0] = ".",
   [0x1] = ".x",
   [0x2] = ".y",
   [0x3] = ".xy",
   [0x4] = ".z",
   [0x5] = ".xz",
   [0x6] = ".yz",
   [0x7] = ".xyz",
   [0x8] = ".w",
   [0x9] = ".xw",
   [0xa] = ".yw",
   [0xb] = ".xyw",
   [0xc] = ".zw",
   [0xd] = ".xzw",
   [0xe] = ".yzw",
   [0xf] = "",
};

static const char *const end_of_thread[2] = {
   [0] = "",
   [1] = "EOT"
};

/* SFIDs on Gen4-5 */
static const char *const gen4_sfid[16] = {
   [BRW_SFID_NULL]            = "null",
   [BRW_SFID_MATH]            = "math",
   [BRW_SFID_SAMPLER]         = "sampler",
   [BRW_SFID_MESSAGE_GATEWAY] = "gateway",
   [BRW_SFID_DATAPORT_READ]   = "read",
   [BRW_SFID_DATAPORT_WRITE]  = "write",
   [BRW_SFID_URB]             = "urb",
   [BRW_SFID_THREAD_SPAWNER]  = "thread_spawner",
   [BRW_SFID_VME]             = "vme",
};

static const char *const gen6_sfid[16] = {
   [BRW_SFID_NULL]                     = "null",
   [BRW_SFID_MATH]                     = "math",
   [BRW_SFID_SAMPLER]                  = "sampler",
   [BRW_SFID_MESSAGE_GATEWAY]          = "gateway",
   [BRW_SFID_URB]                      = "urb",
   [BRW_SFID_THREAD_SPAWNER]           = "thread_spawner",
   [GEN6_SFID_DATAPORT_SAMPLER_CACHE]  = "sampler",
   [GEN6_SFID_DATAPORT_RENDER_CACHE]   = "render",
   [GEN6_SFID_DATAPORT_CONSTANT_CACHE] = "const",
   [GEN7_SFID_DATAPORT_DATA_CACHE]     = "data",
   [GEN7_SFID_PIXEL_INTERPOLATOR]      = "pixel interp",
   [HSW_SFID_DATAPORT_DATA_CACHE_1]    = "dp data 1",
   [HSW_SFID_CRE]                      = "cre",
};

static const char *const dp_write_port_msg_type[8] = {
   [0b000] = "OWord block write",
   [0b001] = "OWord dual block write",
   [0b010] = "media block write",
   [0b011] = "DWord scattered write",
   [0b100] = "RT write",
   [0b101] = "streamed VB write",
   [0b110] = "RT UNORM write", /* G45+ */
   [0b111] = "flush render cache",
};

static const char *const dp_rc_msg_type_gen6[16] = {
   [BRW_DATAPORT_READ_MESSAGE_OWORD_BLOCK_READ] = "OWORD block read",
   [GEN6_DATAPORT_READ_MESSAGE_RENDER_UNORM_READ] = "RT UNORM read",
   [GEN6_DATAPORT_READ_MESSAGE_OWORD_DUAL_BLOCK_READ] = "OWORD dual block read",
   [GEN6_DATAPORT_READ_MESSAGE_MEDIA_BLOCK_READ] = "media block read",
   [GEN6_DATAPORT_READ_MESSAGE_OWORD_UNALIGN_BLOCK_READ] =
      "OWORD unaligned block read",
   [GEN6_DATAPORT_READ_MESSAGE_DWORD_SCATTERED_READ] = "DWORD scattered read",
   [GEN6_DATAPORT_WRITE_MESSAGE_DWORD_ATOMIC_WRITE] = "DWORD atomic write",
   [GEN6_DATAPORT_WRITE_MESSAGE_OWORD_BLOCK_WRITE] = "OWORD block write",
   [GEN6_DATAPORT_WRITE_MESSAGE_OWORD_DUAL_BLOCK_WRITE] =
      "OWORD dual block write",
   [GEN6_DATAPORT_WRITE_MESSAGE_MEDIA_BLOCK_WRITE] = "media block write",
   [GEN6_DATAPORT_WRITE_MESSAGE_DWORD_SCATTERED_WRITE] =
      "DWORD scattered write",
   [GEN6_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_WRITE] = "RT write",
   [GEN6_DATAPORT_WRITE_MESSAGE_STREAMED_VB_WRITE] = "streamed VB write",
   [GEN6_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_UNORM_WRITE] = "RT UNORM write",
};

static const char *const m_rt_write_subtype[] = {
   [0b000] = "SIMD16",
   [0b001] = "SIMD16/RepData",
   [0b010] = "SIMD8/DualSrcLow",
   [0b011] = "SIMD8/DualSrcHigh",
   [0b100] = "SIMD8",
   [0b101] = "SIMD8/ImageWrite",   /* Gen6+ */
   [0b111] = "SIMD16/RepData-111", /* no idea how this is different than 1 */
d350 12
a361 14
   [GEN7_DATAPORT_DC_OWORD_BLOCK_READ] = "DC OWORD block read",
   [GEN7_DATAPORT_DC_UNALIGNED_OWORD_BLOCK_READ] =
      "DC unaligned OWORD block read",
   [GEN7_DATAPORT_DC_OWORD_DUAL_BLOCK_READ] = "DC OWORD dual block read",
   [GEN7_DATAPORT_DC_DWORD_SCATTERED_READ] = "DC DWORD scattered read",
   [GEN7_DATAPORT_DC_BYTE_SCATTERED_READ] = "DC byte scattered read",
   [GEN7_DATAPORT_DC_UNTYPED_SURFACE_READ] = "DC untyped surface read",
   [GEN7_DATAPORT_DC_UNTYPED_ATOMIC_OP] = "DC untyped atomic",
   [GEN7_DATAPORT_DC_MEMORY_FENCE] = "DC mfence",
   [GEN7_DATAPORT_DC_OWORD_BLOCK_WRITE] = "DC OWORD block write",
   [GEN7_DATAPORT_DC_OWORD_DUAL_BLOCK_WRITE] = "DC OWORD dual block write",
   [GEN7_DATAPORT_DC_DWORD_SCATTERED_WRITE] = "DC DWORD scatterd write",
   [GEN7_DATAPORT_DC_BYTE_SCATTERED_WRITE] = "DC byte scattered write",
   [GEN7_DATAPORT_DC_UNTYPED_SURFACE_WRITE] = "DC untyped surface write",
d365 23
a387 25
   [HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_READ] = "untyped surface read",
   [HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP] = "DC untyped atomic op",
   [HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP_SIMD4X2] =
      "DC untyped 4x2 atomic op",
   [HSW_DATAPORT_DC_PORT1_MEDIA_BLOCK_READ] = "DC media block read",
   [HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_READ] = "DC typed surface read",
   [HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP] = "DC typed atomic",
   [HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP_SIMD4X2] = "DC typed 4x2 atomic op",
   [HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_WRITE] = "DC untyped surface write",
   [HSW_DATAPORT_DC_PORT1_MEDIA_BLOCK_WRITE] = "DC media block write",
   [HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP] = "DC atomic counter op",
   [HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP_SIMD4X2] =
      "DC 4x2 atomic counter op",
   [HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_WRITE] = "DC typed surface write",
};

static const char *const aop[16] = {
   [BRW_AOP_AND]    = "and",
   [BRW_AOP_OR]     = "or",
   [BRW_AOP_XOR]    = "xor",
   [BRW_AOP_MOV]    = "mov",
   [BRW_AOP_INC]    = "inc",
   [BRW_AOP_DEC]    = "dec",
   [BRW_AOP_ADD]    = "add",
   [BRW_AOP_SUB]    = "sub",
d389 5
a393 5
   [BRW_AOP_IMAX]   = "imax",
   [BRW_AOP_IMIN]   = "imin",
   [BRW_AOP_UMAX]   = "umax",
   [BRW_AOP_UMIN]   = "umin",
   [BRW_AOP_CMPWR]  = "cmpwr",
d397 14
a410 28
static const char * const pixel_interpolator_msg_types[4] = {
    [GEN7_PIXEL_INTERPOLATOR_LOC_SHARED_OFFSET] = "per_message_offset",
    [GEN7_PIXEL_INTERPOLATOR_LOC_SAMPLE] = "sample_position",
    [GEN7_PIXEL_INTERPOLATOR_LOC_CENTROID] = "centroid",
    [GEN7_PIXEL_INTERPOLATOR_LOC_PER_SLOT_OFFSET] = "per_slot_offset",
};

static const char *const math_function[16] = {
   [BRW_MATH_FUNCTION_INV]    = "inv",
   [BRW_MATH_FUNCTION_LOG]    = "log",
   [BRW_MATH_FUNCTION_EXP]    = "exp",
   [BRW_MATH_FUNCTION_SQRT]   = "sqrt",
   [BRW_MATH_FUNCTION_RSQ]    = "rsq",
   [BRW_MATH_FUNCTION_SIN]    = "sin",
   [BRW_MATH_FUNCTION_COS]    = "cos",
   [BRW_MATH_FUNCTION_SINCOS] = "sincos",
   [BRW_MATH_FUNCTION_FDIV]   = "fdiv",
   [BRW_MATH_FUNCTION_POW]    = "pow",
   [BRW_MATH_FUNCTION_INT_DIV_QUOTIENT_AND_REMAINDER] = "intdivmod",
   [BRW_MATH_FUNCTION_INT_DIV_QUOTIENT]  = "intdiv",
   [BRW_MATH_FUNCTION_INT_DIV_REMAINDER] = "intmod",
   [GEN8_MATH_FUNCTION_INVM]  = "invm",
   [GEN8_MATH_FUNCTION_RSQRTM] = "rsqrtm",
};

static const char *const math_saturate[2] = {
   [0] = "",
   [1] = "sat"
d413 3
a415 3
static const char *const math_signed[2] = {
   [0] = "",
   [1] = "signed"
d418 3
a420 3
static const char *const math_scalar[2] = {
   [0] = "",
   [1] = "scalar"
d423 3
a425 3
static const char *const math_precision[2] = {
   [0] = "",
   [1] = "partial_precision"
d428 3
a430 3
static const char *const gen5_urb_opcode[] = {
   [0] = "urb_write",
   [1] = "ff_sync",
d433 3
a435 11
static const char *const gen7_urb_opcode[] = {
   [0] = "write HWord",
   [1] = "write OWord",
   [2] = "read HWord",
   [3] = "read OWord",
   [4] = "atomic mov",  /* Gen7+ */
   [5] = "atomic inc",  /* Gen7+ */
   [6] = "atomic add",  /* Gen8+ */
   [7] = "SIMD8 write", /* Gen8+ */
   [8] = "SIMD8 read",  /* Gen8+ */
   /* [9-15] - reserved */
d438 4
a441 4
static const char *const urb_swizzle[4] = {
   [BRW_URB_SWIZZLE_NONE]       = "",
   [BRW_URB_SWIZZLE_INTERLEAVE] = "interleave",
   [BRW_URB_SWIZZLE_TRANSPOSE]  = "transpose",
d444 3
a446 3
static const char *const urb_allocate[2] = {
   [0] = "",
   [1] = "allocate"
d449 3
a451 3
static const char *const urb_used[2] = {
   [0] = "",
   [1] = "used"
d454 3
a456 3
static const char *const urb_complete[2] = {
   [0] = "",
   [1] = "complete"
d459 4
a462 4
static const char *const sampler_target_format[4] = {
   [0] = "F",
   [2] = "UD",
   [3] = "D"
d468 1
a468 10
static int
string(FILE *file, const char *string)
{
   fputs(string, file);
   column += strlen(string);
   return 0;
}

static int
format(FILE *f, const char *format, ...)
d470 890
a1359 55
   char buf[1024];
   va_list args;
   va_start(args, format);

   vsnprintf(buf, sizeof(buf) - 1, format, args);
   va_end(args);
   string(f, buf);
   return 0;
}

static int
newline(FILE *f)
{
   putc('\n', f);
   column = 0;
   return 0;
}

static int
pad(FILE *f, int c)
{
   do
      string(f, " ");
   while (column < c);
   return 0;
}

static int
control(FILE *file, const char *name, const char *const ctrl[],
        unsigned id, int *space)
{
   if (!ctrl[id]) {
      fprintf(file, "*** invalid %s value %d ", name, id);
      return 1;
   }
   if (ctrl[id][0]) {
      if (space && *space)
         string(file, " ");
      string(file, ctrl[id]);
      if (space)
         *space = 1;
   }
   return 0;
}

static int
print_opcode(FILE *file, int id)
{
   if (!opcode_descs[id].name) {
      format(file, "*** invalid opcode value %d ", id);
      return 1;
   }
   string(file, opcode_descs[id].name);
   return 0;
}
d1361 1
a1361 790
static int
reg(FILE *file, unsigned _reg_file, unsigned _reg_nr)
{
   int err = 0;

   /* Clear the Compr4 instruction compression bit. */
   if (_reg_file == BRW_MESSAGE_REGISTER_FILE)
      _reg_nr &= ~(1 << 7);

   if (_reg_file == BRW_ARCHITECTURE_REGISTER_FILE) {
      switch (_reg_nr & 0xf0) {
      case BRW_ARF_NULL:
         string(file, "null");
         return -1;
      case BRW_ARF_ADDRESS:
         format(file, "a%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_ACCUMULATOR:
         format(file, "acc%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_FLAG:
         format(file, "f%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_MASK:
         format(file, "mask%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_MASK_STACK:
         format(file, "msd%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_STATE:
         format(file, "sr%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_CONTROL:
         format(file, "cr%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_NOTIFICATION_COUNT:
         format(file, "n%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_IP:
         string(file, "ip");
         return -1;
         break;
      default:
         format(file, "ARF%d", _reg_nr);
         break;
      }
   } else {
      err |= control(file, "src reg file", reg_file, _reg_file, NULL);
      format(file, "%d", _reg_nr);
   }
   return err;
}

static int
dest(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   int err = 0;

   if (brw_inst_access_mode(brw, inst) == BRW_ALIGN_1) {
      if (brw_inst_dst_address_mode(brw, inst) == BRW_ADDRESS_DIRECT) {
         err |= reg(file, brw_inst_dst_reg_file(brw, inst),
                    brw_inst_dst_da_reg_nr(brw, inst));
         if (err == -1)
            return 0;
         if (brw_inst_dst_da1_subreg_nr(brw, inst))
            format(file, ".%d", brw_inst_dst_da1_subreg_nr(brw, inst) /
                   reg_type_size[brw_inst_dst_reg_type(brw, inst)]);
         string(file, "<");
         err |= control(file, "horiz stride", horiz_stride,
                        brw_inst_dst_hstride(brw, inst), NULL);
         string(file, ">");
         err |= control(file, "dest reg encoding", reg_encoding,
                        brw_inst_dst_reg_type(brw, inst), NULL);
      } else {
         string(file, "g[a0");
         if (brw_inst_dst_ia_subreg_nr(brw, inst))
            format(file, ".%d", brw_inst_dst_ia_subreg_nr(brw, inst) /
                   reg_type_size[brw_inst_dst_reg_type(brw, inst)]);
         if (brw_inst_dst_ia1_addr_imm(brw, inst))
            format(file, " %d", brw_inst_dst_ia1_addr_imm(brw, inst));
         string(file, "]<");
         err |= control(file, "horiz stride", horiz_stride,
                        brw_inst_dst_hstride(brw, inst), NULL);
         string(file, ">");
         err |= control(file, "dest reg encoding", reg_encoding,
                        brw_inst_dst_reg_type(brw, inst), NULL);
      }
   } else {
      if (brw_inst_dst_address_mode(brw, inst) == BRW_ADDRESS_DIRECT) {
         err |= reg(file, brw_inst_dst_reg_file(brw, inst),
                    brw_inst_dst_da_reg_nr(brw, inst));
         if (err == -1)
            return 0;
         if (brw_inst_dst_da16_subreg_nr(brw, inst))
            format(file, ".%d", brw_inst_dst_da16_subreg_nr(brw, inst) /
                   reg_type_size[brw_inst_dst_reg_type(brw, inst)]);
         string(file, "<1>");
         err |= control(file, "writemask", writemask,
                        brw_inst_da16_writemask(brw, inst), NULL);
         err |= control(file, "dest reg encoding", reg_encoding,
                        brw_inst_dst_reg_type(brw, inst), NULL);
      } else {
         err = 1;
         string(file, "Indirect align16 address mode not supported");
      }
   }

   return 0;
}

static int
dest_3src(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   int err = 0;
   uint32_t reg_file;

   if (brw->gen == 6 && brw_inst_3src_dst_reg_file(brw, inst))
      reg_file = BRW_MESSAGE_REGISTER_FILE;
   else
      reg_file = BRW_GENERAL_REGISTER_FILE;

   err |= reg(file, reg_file, brw_inst_3src_dst_reg_nr(brw, inst));
   if (err == -1)
      return 0;
   if (brw_inst_3src_dst_subreg_nr(brw, inst))
      format(file, ".%d", brw_inst_3src_dst_subreg_nr(brw, inst));
   string(file, "<1>");
   err |= control(file, "writemask", writemask,
                  brw_inst_3src_dst_writemask(brw, inst), NULL);
   err |= control(file, "dest reg encoding", three_source_reg_encoding,
                  brw_inst_3src_dst_type(brw, inst), NULL);

   return 0;
}

static int
src_align1_region(FILE *file,
                  unsigned _vert_stride, unsigned _width,
                  unsigned _horiz_stride)
{
   int err = 0;
   string(file, "<");
   err |= control(file, "vert stride", vert_stride, _vert_stride, NULL);
   string(file, ",");
   err |= control(file, "width", width, _width, NULL);
   string(file, ",");
   err |= control(file, "horiz_stride", horiz_stride, _horiz_stride, NULL);
   string(file, ">");
   return err;
}

static int
src_da1(FILE *file,
        const struct brw_context *brw,
        unsigned opcode,
        unsigned type, unsigned _reg_file,
        unsigned _vert_stride, unsigned _width, unsigned _horiz_stride,
        unsigned reg_num, unsigned sub_reg_num, unsigned __abs,
        unsigned _negate)
{
   int err = 0;

   if (brw->gen >= 8 && is_logic_instruction(opcode))
      err |= control(file, "bitnot", m_bitnot, _negate, NULL);
   else
      err |= control(file, "negate", m_negate, _negate, NULL);

   err |= control(file, "abs", _abs, __abs, NULL);

   err |= reg(file, _reg_file, reg_num);
   if (err == -1)
      return 0;
   if (sub_reg_num)
      format(file, ".%d", sub_reg_num / reg_type_size[type]);   /* use formal style like spec */
   src_align1_region(file, _vert_stride, _width, _horiz_stride);
   err |= control(file, "src reg encoding", reg_encoding, type, NULL);
   return err;
}

static int
src_ia1(FILE *file,
        const struct brw_context *brw,
        unsigned opcode,
        unsigned type,
        unsigned _reg_file,
        int _addr_imm,
        unsigned _addr_subreg_nr,
        unsigned _negate,
        unsigned __abs,
        unsigned _addr_mode,
        unsigned _horiz_stride, unsigned _width, unsigned _vert_stride)
{
   int err = 0;

   if (brw->gen >= 8 && is_logic_instruction(opcode))
      err |= control(file, "bitnot", m_bitnot, _negate, NULL);
   else
      err |= control(file, "negate", m_negate, _negate, NULL);

   err |= control(file, "abs", _abs, __abs, NULL);

   string(file, "g[a0");
   if (_addr_subreg_nr)
      format(file, ".%d", _addr_subreg_nr);
   if (_addr_imm)
      format(file, " %d", _addr_imm);
   string(file, "]");
   src_align1_region(file, _vert_stride, _width, _horiz_stride);
   err |= control(file, "src reg encoding", reg_encoding, type, NULL);
   return err;
}

static int
src_swizzle(FILE *file, unsigned swiz)
{
   unsigned x = BRW_GET_SWZ(swiz, BRW_CHANNEL_X);
   unsigned y = BRW_GET_SWZ(swiz, BRW_CHANNEL_Y);
   unsigned z = BRW_GET_SWZ(swiz, BRW_CHANNEL_Z);
   unsigned w = BRW_GET_SWZ(swiz, BRW_CHANNEL_W);
   int err = 0;

   if (x == y && x == z && x == w) {
      string(file, ".");
      err |= control(file, "channel select", chan_sel, x, NULL);
   } else if (swiz != BRW_SWIZZLE_XYZW) {
      string(file, ".");
      err |= control(file, "channel select", chan_sel, x, NULL);
      err |= control(file, "channel select", chan_sel, y, NULL);
      err |= control(file, "channel select", chan_sel, z, NULL);
      err |= control(file, "channel select", chan_sel, w, NULL);
   }
   return err;
}

static int
src_da16(FILE *file,
         const struct brw_context *brw,
         unsigned opcode,
         unsigned _reg_type,
         unsigned _reg_file,
         unsigned _vert_stride,
         unsigned _reg_nr,
         unsigned _subreg_nr,
         unsigned __abs,
         unsigned _negate,
         unsigned swz_x, unsigned swz_y, unsigned swz_z, unsigned swz_w)
{
   int err = 0;

   if (brw->gen >= 8 && is_logic_instruction(opcode))
      err |= control(file, "bitnot", m_bitnot, _negate, NULL);
   else
      err |= control(file, "negate", m_negate, _negate, NULL);

   err |= control(file, "abs", _abs, __abs, NULL);

   err |= reg(file, _reg_file, _reg_nr);
   if (err == -1)
      return 0;
   if (_subreg_nr)
      /* bit4 for subreg number byte addressing. Make this same meaning as
         in da1 case, so output looks consistent. */
      format(file, ".%d", 16 / reg_type_size[_reg_type]);
   string(file, "<");
   err |= control(file, "vert stride", vert_stride, _vert_stride, NULL);
   string(file, ",4,1>");
   err |= src_swizzle(file, BRW_SWIZZLE4(swz_x, swz_y, swz_z, swz_w));
   err |= control(file, "src da16 reg type", reg_encoding, _reg_type, NULL);
   return err;
}

static int
src0_3src(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   int err = 0;
   unsigned src0_subreg_nr = brw_inst_3src_src0_subreg_nr(brw, inst);

   err |= control(file, "negate", m_negate,
                  brw_inst_3src_src0_negate(brw, inst), NULL);
   err |= control(file, "abs", _abs, brw_inst_3src_src0_abs(brw, inst), NULL);

   err |= reg(file, BRW_GENERAL_REGISTER_FILE,
              brw_inst_3src_src0_reg_nr(brw, inst));
   if (err == -1)
      return 0;
   if (src0_subreg_nr)
      format(file, ".%d", src0_subreg_nr);
   if (brw_inst_3src_src0_rep_ctrl(brw, inst))
      string(file, "<0,1,0>");
   else
      string(file, "<4,4,1>");
   err |= control(file, "src da16 reg type", three_source_reg_encoding,
                  brw_inst_3src_src_type(brw, inst), NULL);
   err |= src_swizzle(file, brw_inst_3src_src0_swizzle(brw, inst));
   return err;
}

static int
src1_3src(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   int err = 0;
   unsigned src1_subreg_nr = brw_inst_3src_src1_subreg_nr(brw, inst);

   err |= control(file, "negate", m_negate,
                  brw_inst_3src_src1_negate(brw, inst), NULL);
   err |= control(file, "abs", _abs, brw_inst_3src_src1_abs(brw, inst), NULL);

   err |= reg(file, BRW_GENERAL_REGISTER_FILE,
              brw_inst_3src_src1_reg_nr(brw, inst));
   if (err == -1)
      return 0;
   if (src1_subreg_nr)
      format(file, ".%d", src1_subreg_nr);
   if (brw_inst_3src_src1_rep_ctrl(brw, inst))
      string(file, "<0,1,0>");
   else
      string(file, "<4,4,1>");
   err |= control(file, "src da16 reg type", three_source_reg_encoding,
                  brw_inst_3src_src_type(brw, inst), NULL);
   err |= src_swizzle(file, brw_inst_3src_src1_swizzle(brw, inst));
   return err;
}


static int
src2_3src(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   int err = 0;
   unsigned src2_subreg_nr = brw_inst_3src_src2_subreg_nr(brw, inst);

   err |= control(file, "negate", m_negate,
                  brw_inst_3src_src2_negate(brw, inst), NULL);
   err |= control(file, "abs", _abs, brw_inst_3src_src2_abs(brw, inst), NULL);

   err |= reg(file, BRW_GENERAL_REGISTER_FILE,
              brw_inst_3src_src2_reg_nr(brw, inst));
   if (err == -1)
      return 0;
   if (src2_subreg_nr)
      format(file, ".%d", src2_subreg_nr);
   if (brw_inst_3src_src2_rep_ctrl(brw, inst))
      string(file, "<0,1,0>");
   else
      string(file, "<4,4,1>");
   err |= control(file, "src da16 reg type", three_source_reg_encoding,
                  brw_inst_3src_src_type(brw, inst), NULL);
   err |= src_swizzle(file, brw_inst_3src_src2_swizzle(brw, inst));
   return err;
}

static int
imm(FILE *file, struct brw_context *brw, unsigned type, brw_inst *inst)
{
   switch (type) {
   case BRW_HW_REG_TYPE_UD:
      format(file, "0x%08xUD", brw_inst_imm_ud(brw, inst));
      break;
   case BRW_HW_REG_TYPE_D:
      format(file, "%dD", brw_inst_imm_d(brw, inst));
      break;
   case BRW_HW_REG_TYPE_UW:
      format(file, "0x%04xUW", (uint16_t) brw_inst_imm_ud(brw, inst));
      break;
   case BRW_HW_REG_TYPE_W:
      format(file, "%dW", (int16_t) brw_inst_imm_d(brw, inst));
      break;
   case BRW_HW_REG_IMM_TYPE_UV:
      format(file, "0x%08xUV", brw_inst_imm_ud(brw, inst));
      break;
   case BRW_HW_REG_IMM_TYPE_VF:
      format(file, "Vector Float");
      break;
   case BRW_HW_REG_IMM_TYPE_V:
      format(file, "0x%08xV", brw_inst_imm_ud(brw, inst));
      break;
   case BRW_HW_REG_TYPE_F:
      format(file, "%-gF", brw_inst_imm_f(brw, inst));
      break;
   case GEN8_HW_REG_IMM_TYPE_DF:
      string(file, "Double IMM");
      break;
   case GEN8_HW_REG_IMM_TYPE_HF:
      string(file, "Half Float IMM");
      break;
   }
   return 0;
}

static int
src0(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   if (brw_inst_src0_reg_file(brw, inst) == BRW_IMMEDIATE_VALUE) {
      return imm(file, brw, brw_inst_src0_reg_type(brw, inst), inst);
   } else if (brw_inst_access_mode(brw, inst) == BRW_ALIGN_1) {
      if (brw_inst_src0_address_mode(brw, inst) == BRW_ADDRESS_DIRECT) {
         return src_da1(file,
                        brw,
                        brw_inst_opcode(brw, inst),
                        brw_inst_src0_reg_type(brw, inst),
                        brw_inst_src0_reg_file(brw, inst),
                        brw_inst_src0_vstride(brw, inst),
                        brw_inst_src0_width(brw, inst),
                        brw_inst_src0_hstride(brw, inst),
                        brw_inst_src0_da_reg_nr(brw, inst),
                        brw_inst_src0_da1_subreg_nr(brw, inst),
                        brw_inst_src0_abs(brw, inst),
                        brw_inst_src0_negate(brw, inst));
      } else {
         return src_ia1(file,
                        brw,
                        brw_inst_opcode(brw, inst),
                        brw_inst_src0_reg_type(brw, inst),
                        brw_inst_src0_reg_file(brw, inst),
                        brw_inst_src0_ia1_addr_imm(brw, inst),
                        brw_inst_src0_ia_subreg_nr(brw, inst),
                        brw_inst_src0_negate(brw, inst),
                        brw_inst_src0_abs(brw, inst),
                        brw_inst_src0_address_mode(brw, inst),
                        brw_inst_src0_hstride(brw, inst),
                        brw_inst_src0_width(brw, inst),
                        brw_inst_src0_vstride(brw, inst));
      }
   } else {
      if (brw_inst_src0_address_mode(brw, inst) == BRW_ADDRESS_DIRECT) {
         return src_da16(file,
                         brw,
                         brw_inst_opcode(brw, inst),
                         brw_inst_src0_reg_type(brw, inst),
                         brw_inst_src0_reg_file(brw, inst),
                         brw_inst_src0_vstride(brw, inst),
                         brw_inst_src0_da_reg_nr(brw, inst),
                         brw_inst_src0_da16_subreg_nr(brw, inst),
                         brw_inst_src0_abs(brw, inst),
                         brw_inst_src0_negate(brw, inst),
                         brw_inst_src0_da16_swiz_x(brw, inst),
                         brw_inst_src0_da16_swiz_y(brw, inst),
                         brw_inst_src0_da16_swiz_z(brw, inst),
                         brw_inst_src0_da16_swiz_w(brw, inst));
      } else {
         string(file, "Indirect align16 address mode not supported");
         return 1;
      }
   }
}

static int
src1(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   if (brw_inst_src1_reg_file(brw, inst) == BRW_IMMEDIATE_VALUE) {
      return imm(file, brw, brw_inst_src1_reg_type(brw, inst), inst);
   } else if (brw_inst_access_mode(brw, inst) == BRW_ALIGN_1) {
      if (brw_inst_src1_address_mode(brw, inst) == BRW_ADDRESS_DIRECT) {
         return src_da1(file,
                        brw,
                        brw_inst_opcode(brw, inst),
                        brw_inst_src1_reg_type(brw, inst),
                        brw_inst_src1_reg_file(brw, inst),
                        brw_inst_src1_vstride(brw, inst),
                        brw_inst_src1_width(brw, inst),
                        brw_inst_src1_hstride(brw, inst),
                        brw_inst_src1_da_reg_nr(brw, inst),
                        brw_inst_src1_da1_subreg_nr(brw, inst),
                        brw_inst_src1_abs(brw, inst),
                        brw_inst_src1_negate(brw, inst));
      } else {
         return src_ia1(file,
                        brw,
                        brw_inst_opcode(brw, inst),
                        brw_inst_src1_reg_type(brw, inst),
                        brw_inst_src1_reg_file(brw, inst),
                        brw_inst_src1_ia1_addr_imm(brw, inst),
                        brw_inst_src1_ia_subreg_nr(brw, inst),
                        brw_inst_src1_negate(brw, inst),
                        brw_inst_src1_abs(brw, inst),
                        brw_inst_src1_address_mode(brw, inst),
                        brw_inst_src1_hstride(brw, inst),
                        brw_inst_src1_width(brw, inst),
                        brw_inst_src1_vstride(brw, inst));
      }
   } else {
      if (brw_inst_src1_address_mode(brw, inst) == BRW_ADDRESS_DIRECT) {
         return src_da16(file,
                         brw,
                         brw_inst_opcode(brw, inst),
                         brw_inst_src1_reg_type(brw, inst),
                         brw_inst_src1_reg_file(brw, inst),
                         brw_inst_src1_vstride(brw, inst),
                         brw_inst_src1_da_reg_nr(brw, inst),
                         brw_inst_src1_da16_subreg_nr(brw, inst),
                         brw_inst_src1_abs(brw, inst),
                         brw_inst_src1_negate(brw, inst),
                         brw_inst_src1_da16_swiz_x(brw, inst),
                         brw_inst_src1_da16_swiz_y(brw, inst),
                         brw_inst_src1_da16_swiz_z(brw, inst),
                         brw_inst_src1_da16_swiz_w(brw, inst));
      } else {
         string(file, "Indirect align16 address mode not supported");
         return 1;
      }
   }
}

static int
qtr_ctrl(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   int qtr_ctl = brw_inst_qtr_control(brw, inst);
   int exec_size = 1 << brw_inst_exec_size(brw, inst);

   if (exec_size == 8) {
      switch (qtr_ctl) {
      case 0:
         string(file, " 1Q");
         break;
      case 1:
         string(file, " 2Q");
         break;
      case 2:
         string(file, " 3Q");
         break;
      case 3:
         string(file, " 4Q");
         break;
      }
   } else if (exec_size == 16) {
      if (qtr_ctl < 2)
         string(file, " 1H");
      else
         string(file, " 2H");
   }
   return 0;
}

int
brw_disassemble_inst(FILE *file, struct brw_context *brw, brw_inst *inst,
                     bool is_compacted)
{
   int err = 0;
   int space = 0;

   const enum opcode opcode = brw_inst_opcode(brw, inst);

   if (brw_inst_pred_control(brw, inst)) {
      string(file, "(");
      err |= control(file, "predicate inverse", pred_inv,
                     brw_inst_pred_inv(brw, inst), NULL);
      format(file, "f%d", brw->gen >= 7 ? brw_inst_flag_reg_nr(brw, inst) : 0);
      if (brw_inst_flag_subreg_nr(brw, inst))
         format(file, ".%d", brw_inst_flag_subreg_nr(brw, inst));
      if (brw_inst_access_mode(brw, inst) == BRW_ALIGN_1) {
         err |= control(file, "predicate control align1", pred_ctrl_align1,
                        brw_inst_pred_control(brw, inst), NULL);
      } else {
         err |= control(file, "predicate control align16", pred_ctrl_align16,
                        brw_inst_pred_control(brw, inst), NULL);
      }
      string(file, ") ");
   }

   err |= print_opcode(file, opcode);
   err |= control(file, "saturate", saturate, brw_inst_saturate(brw, inst),
                  NULL);

   err |= control(file, "debug control", debug_ctrl,
                  brw_inst_debug_control(brw, inst), NULL);

   if (opcode == BRW_OPCODE_MATH) {
      string(file, " ");
      err |= control(file, "function", math_function,
                     brw_inst_math_function(brw, inst), NULL);
   } else if (opcode != BRW_OPCODE_SEND && opcode != BRW_OPCODE_SENDC) {
      err |= control(file, "conditional modifier", conditional_modifier,
                     brw_inst_cond_modifier(brw, inst), NULL);

      /* If we're using the conditional modifier, print which flags reg is
       * used for it.  Note that on gen6+, the embedded-condition SEL and
       * control flow doesn't update flags.
       */
      if (brw_inst_cond_modifier(brw, inst) &&
          (brw->gen < 6 || (opcode != BRW_OPCODE_SEL &&
                            opcode != BRW_OPCODE_IF &&
                            opcode != BRW_OPCODE_WHILE))) {
         format(file, ".f%d",
                brw->gen >= 7 ? brw_inst_flag_reg_nr(brw, inst) : 0);
         if (brw_inst_flag_subreg_nr(brw, inst))
            format(file, ".%d", brw_inst_flag_subreg_nr(brw, inst));
      }
   }

   if (opcode != BRW_OPCODE_NOP && opcode != BRW_OPCODE_NENOP) {
      string(file, "(");
      err |= control(file, "execution size", exec_size,
                     brw_inst_exec_size(brw, inst), NULL);
      string(file, ")");
   }

   if (opcode == BRW_OPCODE_SEND && brw->gen < 6)
      format(file, " %d", brw_inst_base_mrf(brw, inst));

   if (has_uip(brw, opcode)) {
      /* Instructions that have UIP also have JIP. */
      pad(file, 16);
      format(file, "JIP: %d", brw_inst_jip(brw, inst));
      pad(file, 32);
      format(file, "UIP: %d", brw_inst_uip(brw, inst));
   } else if (has_jip(brw, opcode)) {
      pad(file, 16);
      if (brw->gen >= 7) {
         format(file, "JIP: %d", brw_inst_jip(brw, inst));
      } else {
         format(file, "JIP: %d", brw_inst_gen6_jump_count(brw, inst));
      }
   } else if (brw->gen < 6 && (opcode == BRW_OPCODE_BREAK ||
                               opcode == BRW_OPCODE_CONTINUE ||
                               opcode == BRW_OPCODE_ELSE)) {
      pad(file, 16);
      format(file, "Jump: %d", brw_inst_gen4_jump_count(brw, inst));
      pad(file, 32);
      format(file, "Pop: %d", brw_inst_gen4_pop_count(brw, inst));
   } else if (brw->gen < 6 && (opcode == BRW_OPCODE_IF ||
                               opcode == BRW_OPCODE_IFF ||
                               opcode == BRW_OPCODE_HALT)) {
      pad(file, 16);
      format(file, "Jump: %d", brw_inst_gen4_jump_count(brw, inst));
   } else if (brw->gen < 6 && opcode == BRW_OPCODE_ENDIF) {
      pad(file, 16);
      format(file, "Pop: %d", brw_inst_gen4_pop_count(brw, inst));
   } else if (opcode == BRW_OPCODE_JMPI) {
      pad(file, 16);
      err |= src1(file, brw, inst);
   } else if (opcode_descs[opcode].nsrc == 3) {
      pad(file, 16);
      err |= dest_3src(file, brw, inst);

      pad(file, 32);
      err |= src0_3src(file, brw, inst);

      pad(file, 48);
      err |= src1_3src(file, brw, inst);

      pad(file, 64);
      err |= src2_3src(file, brw, inst);
   } else {
      if (opcode_descs[opcode].ndst > 0) {
         pad(file, 16);
         err |= dest(file, brw, inst);
      }

      if (opcode_descs[opcode].nsrc > 0) {
         pad(file, 32);
         err |= src0(file, brw, inst);
      }

      if (opcode_descs[opcode].nsrc > 1) {
         pad(file, 48);
         err |= src1(file, brw, inst);
      }
   }

   if (opcode == BRW_OPCODE_SEND || opcode == BRW_OPCODE_SENDC) {
      enum brw_message_target sfid = brw_inst_sfid(brw, inst);

      if (brw_inst_src1_reg_file(brw, inst) != BRW_IMMEDIATE_VALUE) {
         /* show the indirect descriptor source */
         pad(file, 48);
         err |= src1(file, brw, inst);
      }

      newline(file);
      pad(file, 16);
      space = 0;

      fprintf(file, "            ");
      err |= control(file, "SFID", brw->gen >= 6 ? gen6_sfid : gen4_sfid,
                     sfid, &space);


      if (brw_inst_src1_reg_file(brw, inst) != BRW_IMMEDIATE_VALUE) {
         format(file, " indirect");
      } else {
         switch (sfid) {
         case BRW_SFID_MATH:
            err |= control(file, "math function", math_function,
                           brw_inst_math_msg_function(brw, inst), &space);
            err |= control(file, "math saturate", math_saturate,
                           brw_inst_math_msg_saturate(brw, inst), &space);
            err |= control(file, "math signed", math_signed,
                           brw_inst_math_msg_signed_int(brw, inst), &space);
            err |= control(file, "math scalar", math_scalar,
                           brw_inst_math_msg_data_type(brw, inst), &space);
            err |= control(file, "math precision", math_precision,
                           brw_inst_math_msg_precision(brw, inst), &space);
            break;
         case BRW_SFID_SAMPLER:
            if (brw->gen >= 5) {
               format(file, " (%d, %d, %d, %d)",
                      brw_inst_binding_table_index(brw, inst),
                      brw_inst_sampler(brw, inst),
                      brw_inst_sampler_msg_type(brw, inst),
                      brw_inst_sampler_simd_mode(brw, inst));
            } else {
               format(file, " (%d, %d, %d, ",
                      brw_inst_binding_table_index(brw, inst),
                      brw_inst_sampler(brw, inst),
                      brw_inst_sampler_msg_type(brw, inst));
               if (!brw->is_g4x) {
                  err |= control(file, "sampler target format",
                                 sampler_target_format,
                                 brw_inst_sampler_return_format(brw, inst), NULL);
               }
               string(file, ")");
            }
            break;
         case GEN6_SFID_DATAPORT_SAMPLER_CACHE:
            /* aka BRW_SFID_DATAPORT_READ on Gen4-5 */
            if (brw->gen >= 6) {
               format(file, " (%d, %d, %d, %d)",
                      brw_inst_binding_table_index(brw, inst),
                      brw_inst_dp_msg_control(brw, inst),
                      brw_inst_dp_msg_type(brw, inst),
                      brw->gen >= 7 ? 0 : brw_inst_dp_write_commit(brw, inst));
            } else {
               format(file, " (%d, %d, %d)",
                      brw_inst_binding_table_index(brw, inst),
                      brw_inst_dp_read_msg_control(brw, inst),
                      brw_inst_dp_read_msg_type(brw, inst));
            }
            break;

         case GEN6_SFID_DATAPORT_RENDER_CACHE: {
            /* aka BRW_SFID_DATAPORT_WRITE on Gen4-5 */
            unsigned msg_type = brw_inst_dp_write_msg_type(brw, inst);

            err |= control(file, "DP rc message type",
                           brw->gen >= 6 ? dp_rc_msg_type_gen6
                                         : dp_write_port_msg_type,
                           msg_type, &space);

            bool is_rt_write = msg_type ==
               (brw->gen >= 6 ? GEN6_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_WRITE
                              : BRW_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_WRITE);

            if (is_rt_write) {
               err |= control(file, "RT message type", m_rt_write_subtype,
                              brw_inst_rt_message_type(brw, inst), &space);
               if (brw->gen >= 6 && brw_inst_rt_slot_group(brw, inst))
                  string(file, " Hi");
               if (brw_inst_rt_last(brw, inst))
                  string(file, " LastRT");
               if (brw->gen < 7 && brw_inst_dp_write_commit(brw, inst))
                  string(file, " WriteCommit");
            } else {
               format(file, " MsgCtrl = 0x%x",
                      brw_inst_dp_write_msg_control(brw, inst));
            }

            format(file, " Surface = %d", brw_inst_binding_table_index(brw, inst));
            break;
         }

         case BRW_SFID_URB:
            format(file, " %d", brw_inst_urb_global_offset(brw, inst));

            space = 1;
            if (brw->gen >= 7) {
               err |= control(file, "urb opcode", gen7_urb_opcode,
                              brw_inst_urb_opcode(brw, inst), &space);
            } else if (brw->gen >= 5) {
               err |= control(file, "urb opcode", gen5_urb_opcode,
                              brw_inst_urb_opcode(brw, inst), &space);
            }
            err |= control(file, "urb swizzle", urb_swizzle,
                           brw_inst_urb_swizzle_control(brw, inst), &space);
            if (brw->gen < 7) {
               err |= control(file, "urb allocate", urb_allocate,
                              brw_inst_urb_allocate(brw, inst), &space);
               err |= control(file, "urb used", urb_used,
                              brw_inst_urb_used(brw, inst), &space);
            }
            if (brw->gen < 8) {
               err |= control(file, "urb complete", urb_complete,
                              brw_inst_urb_complete(brw, inst), &space);
            }
            break;
         case BRW_SFID_THREAD_SPAWNER:
            break;
         case GEN7_SFID_DATAPORT_DATA_CACHE:
            if (brw->gen >= 7) {
               format(file, " (");

               err |= control(file, "DP DC0 message type",
d1363 1
a1363 1
                              brw_inst_dp_msg_type(brw, inst), &space);
d1365 1
a1365 56
               format(file, ", %d, ", brw_inst_binding_table_index(brw, inst));

               switch (brw_inst_dp_msg_type(brw, inst)) {
               case GEN7_DATAPORT_DC_UNTYPED_ATOMIC_OP:
                  control(file, "atomic op", aop,
                          brw_inst_imm_ud(brw, inst) >> 8 & 0xf, &space);
                  break;
               default:
                  format(file, "%d", brw_inst_dp_msg_control(brw, inst));
               }
               format(file, ")");
               break;
            }
            /* FALLTHROUGH */

         case HSW_SFID_DATAPORT_DATA_CACHE_1: {
            if (brw->gen >= 7) {
               format(file, " (");

               unsigned msg_ctrl = brw_inst_dp_msg_control(brw, inst);

               err |= control(file, "DP DC1 message type",
                              dp_dc1_msg_type_hsw,
                              brw_inst_dp_msg_type(brw, inst), &space);

               format(file, ", Surface = %d, ",
                      brw_inst_binding_table_index(brw, inst));

               switch (brw_inst_dp_msg_type(brw, inst)) {
               case HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP:
               case HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP:
               case HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP:
                  format(file, "SIMD%d,", (msg_ctrl & (1 << 4)) ? 8 : 16);
                  /* fallthrough */
               case HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP_SIMD4X2:
               case HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP_SIMD4X2:
               case HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP_SIMD4X2:
                  control(file, "atomic op", aop, msg_ctrl & 0xf, &space);
                  break;
               case HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_READ:
               case HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_WRITE:
               case HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_READ:
               case HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_WRITE: {
                  static const char *simd_modes[] = { "4x2", "16", "8" };
                  format(file, "SIMD%s, Mask = 0x%x",
                         simd_modes[msg_ctrl >> 4], msg_ctrl & 0xf);
                  break;
               }
               default:
                  format(file, "0x%x", msg_ctrl);
               }
               format(file, ")");
               break;
            }
            /* FALLTHROUGH */
         }
d1367 39
a1405 7
         case GEN7_SFID_PIXEL_INTERPOLATOR:
            if (brw->gen >= 7) {
               format(file, " (%s, %s, 0x%02x)",
                      brw_inst_pi_nopersp(brw, inst) ? "linear" : "persp",
                      pixel_interpolator_msg_types[brw_inst_pi_message_type(brw, inst)],
                      brw_inst_pi_message_data(brw, inst));
               break;
d1409 57
a1465 58
         default:
            format(file, "unsupported shared function ID %d", sfid);
            break;
         }

         if (space)
            string(file, " ");
         format(file, "mlen %d", brw_inst_mlen(brw, inst));
         format(file, " rlen %d", brw_inst_rlen(brw, inst));
      }
   }
   pad(file, 64);
   if (opcode != BRW_OPCODE_NOP && opcode != BRW_OPCODE_NENOP) {
      string(file, "{");
      space = 1;
      err |= control(file, "access mode", access_mode,
                     brw_inst_access_mode(brw, inst), &space);
      if (brw->gen >= 6) {
         err |= control(file, "write enable control", wectrl,
                        brw_inst_mask_control(brw, inst), &space);
      } else {
         err |= control(file, "mask control", mask_ctrl,
                        brw_inst_mask_control(brw, inst), &space);
      }
      err |= control(file, "dependency control", dep_ctrl,
                     ((brw_inst_no_dd_check(brw, inst) << 1) |
                      brw_inst_no_dd_clear(brw, inst)), &space);

      if (brw->gen >= 6)
         err |= qtr_ctrl(file, brw, inst);
      else {
         if (brw_inst_qtr_control(brw, inst) == BRW_COMPRESSION_COMPRESSED &&
             opcode_descs[opcode].ndst > 0 &&
             brw_inst_dst_reg_file(brw, inst) == BRW_MESSAGE_REGISTER_FILE &&
             brw_inst_dst_da_reg_nr(brw, inst) & (1 << 7)) {
            format(file, " compr4");
         } else {
            err |= control(file, "compression control", compr_ctrl,
                           brw_inst_qtr_control(brw, inst), &space);
         }
      }

      err |= control(file, "compaction", cmpt_ctrl, is_compacted, &space);
      err |= control(file, "thread control", thread_ctrl,
                     brw_inst_thread_control(brw, inst), &space);
      if (brw->gen >= 6)
         err |= control(file, "acc write control", accwr,
                        brw_inst_acc_wr_control(brw, inst), &space);
      if (opcode == BRW_OPCODE_SEND || opcode == BRW_OPCODE_SENDC)
         err |= control(file, "end of thread", end_of_thread,
                        brw_inst_eot(brw, inst), &space);
      if (space)
         string(file, " ");
      string(file, "}");
   }
   string(file, ";");
   newline(file);
   return err;
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a29 2
#include "main/mtypes.h"

d32 2
d36 196
a231 219
    [BRW_OPCODE_MOV] = { .name = "mov", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_FRC] = { .name = "frc", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_RNDU] = { .name = "rndu", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_RNDD] = { .name = "rndd", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_RNDE] = { .name = "rnde", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_RNDZ] = { .name = "rndz", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_NOT] = { .name = "not", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_LZD] = { .name = "lzd", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_F32TO16] = { .name = "f32to16", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_F16TO32] = { .name = "f16to32", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_BFREV] = { .name = "bfrev", .nsrc = 1, .ndst = 1},
    [BRW_OPCODE_FBH] = { .name = "fbh", .nsrc = 1, .ndst = 1},
    [BRW_OPCODE_FBL] = { .name = "fbl", .nsrc = 1, .ndst = 1},
    [BRW_OPCODE_CBIT] = { .name = "cbit", .nsrc = 1, .ndst = 1},

    [BRW_OPCODE_MUL] = { .name = "mul", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_MAC] = { .name = "mac", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_MACH] = { .name = "mach", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_LINE] = { .name = "line", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_PLN] = { .name = "pln", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_MAD] = { .name = "mad", .nsrc = 3, .ndst = 1 },
    [BRW_OPCODE_LRP] = { .name = "lrp", .nsrc = 3, .ndst = 1 },
    [BRW_OPCODE_SAD2] = { .name = "sad2", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_SADA2] = { .name = "sada2", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_DP4] = { .name = "dp4", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_DPH] = { .name = "dph", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_DP3] = { .name = "dp3", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_DP2] = { .name = "dp2", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_MATH] = { .name = "math", .nsrc = 2, .ndst = 1 },

    [BRW_OPCODE_AVG] = { .name = "avg", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_ADD] = { .name = "add", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_SEL] = { .name = "sel", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_AND] = { .name = "and", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_OR] = { .name = "or", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_XOR] = { .name = "xor", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_SHR] = { .name = "shr", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_SHL] = { .name = "shl", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_ASR] = { .name = "asr", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_CMP] = { .name = "cmp", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_CMPN] = { .name = "cmpn", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_BFE] = { .name = "bfe", .nsrc = 3, .ndst = 1},
    [BRW_OPCODE_BFI1] = { .name = "bfi1", .nsrc = 2, .ndst = 1},
    [BRW_OPCODE_BFI2] = { .name = "bfi2", .nsrc = 3, .ndst = 1},
    [BRW_OPCODE_ADDC] = { .name = "addc", .nsrc = 2, .ndst = 1},
    [BRW_OPCODE_SUBB] = { .name = "subb", .nsrc = 2, .ndst = 1},

    [BRW_OPCODE_SEND] = { .name = "send", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_SENDC] = { .name = "sendc", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_NOP] = { .name = "nop", .nsrc = 0, .ndst = 0 },
    [BRW_OPCODE_JMPI] = { .name = "jmpi", .nsrc = 0, .ndst = 0 },
    [BRW_OPCODE_IF] = { .name = "if", .nsrc = 2, .ndst = 0 },
    [BRW_OPCODE_IFF] = { .name = "iff", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_WHILE] = { .name = "while", .nsrc = 2, .ndst = 0 },
    [BRW_OPCODE_ELSE] = { .name = "else", .nsrc = 2, .ndst = 0 },
    [BRW_OPCODE_BREAK] = { .name = "break", .nsrc = 2, .ndst = 0 },
    [BRW_OPCODE_CONTINUE] = { .name = "cont", .nsrc = 1, .ndst = 0 },
    [BRW_OPCODE_HALT] = { .name = "halt", .nsrc = 1, .ndst = 0 },
    [BRW_OPCODE_MSAVE] = { .name = "msave", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_PUSH] = { .name = "push", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_MRESTORE] = { .name = "mrest", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_POP] = { .name = "pop", .nsrc = 2, .ndst = 0 },
    [BRW_OPCODE_WAIT] = { .name = "wait", .nsrc = 1, .ndst = 0 },
    [BRW_OPCODE_DO] = { .name = "do", .nsrc = 0, .ndst = 0 },
    [BRW_OPCODE_ENDIF] = { .name = "endif", .nsrc = 2, .ndst = 0 },
};
static const struct opcode_desc *opcode = opcode_descs;

const char * const conditional_modifier[16] = {
    [BRW_CONDITIONAL_NONE] = "",
    [BRW_CONDITIONAL_Z] = ".e",
    [BRW_CONDITIONAL_NZ] = ".ne",
    [BRW_CONDITIONAL_G] = ".g",
    [BRW_CONDITIONAL_GE] = ".ge",
    [BRW_CONDITIONAL_L] = ".l",
    [BRW_CONDITIONAL_LE] = ".le",
    [BRW_CONDITIONAL_R] = ".r",
    [BRW_CONDITIONAL_O] = ".o",
    [BRW_CONDITIONAL_U] = ".u",
};

static const char * const negate[2] = {
    [0] = "",
    [1] = "-",
};

static const char * const _abs[2] = {
    [0] = "",
    [1] = "(abs)",
};

static const char * const vert_stride[16] = {
    [0] = "0",
    [1] = "1",
    [2] = "2",
    [3] = "4",
    [4] = "8",
    [5] = "16",
    [6] = "32",
    [15] = "VxH",
};

static const char * const width[8] = {
    [0] = "1",
    [1] = "2",
    [2] = "4",
    [3] = "8",
    [4] = "16",
};

static const char * const horiz_stride[4] = {
    [0] = "0",
    [1] = "1",
    [2] = "2",
    [3] = "4"
};

static const char * const chan_sel[4] = {
    [0] = "x",
    [1] = "y",
    [2] = "z",
    [3] = "w",
};

static const char * const debug_ctrl[2] = {
    [0] = "",
    [1] = ".breakpoint"
};

static const char * const saturate[2] = {
    [0] = "",
    [1] = ".sat"
};

static const char * const accwr[2] = {
    [0] = "",
    [1] = "AccWrEnable"
};

static const char * const wectrl[2] = {
    [0] = "WE_normal",
    [1] = "WE_all"
};

static const char * const exec_size[8] = {
    [0] = "1",
    [1] = "2",
    [2] = "4",
    [3] = "8",
    [4] = "16",
    [5] = "32"
};

static const char * const pred_inv[2] = {
    [0] = "+",
    [1] = "-"
};

static const char * const pred_ctrl_align16[16] = {
    [1] = "",
    [2] = ".x",
    [3] = ".y",
    [4] = ".z",
    [5] = ".w",
    [6] = ".any4h",
    [7] = ".all4h",
};

static const char * const pred_ctrl_align1[16] = {
    [1] = "",
    [2] = ".anyv",
    [3] = ".allv",
    [4] = ".any2h",
    [5] = ".all2h",
    [6] = ".any4h",
    [7] = ".all4h",
    [8] = ".any8h",
    [9] = ".all8h",
    [10] = ".any16h",
    [11] = ".all16h",
};

static const char * const thread_ctrl[4] = {
    [0] = "",
    [2] = "switch"
};

static const char * const compr_ctrl[4] = {
    [0] = "",
    [1] = "sechalf",
    [2] = "compr",
    [3] = "compr4",
};

static const char * const dep_ctrl[4] = {
    [0] = "",
    [1] = "NoDDClr",
    [2] = "NoDDChk",
    [3] = "NoDDClr,NoDDChk",
};

static const char * const mask_ctrl[4] = {
    [0] = "",
    [1] = "nomask",
};

static const char * const access_mode[2] = {
    [0] = "align1",
    [1] = "align16",
};

static const char * const reg_encoding[8] = {
    [0] = "UD",
    [1] = "D",
    [2] = "UW",
    [3] = "W",
    [4] = "UB",
    [5] = "B",
    [7] = "F"
d234 76
a309 1
const char * const three_source_reg_encoding[] = {
d315 113
a427 84
const int reg_type_size[8] = {
    [0] = 4,
    [1] = 4,
    [2] = 2,
    [3] = 2,
    [4] = 1,
    [5] = 1,
    [7] = 4
};

static const char * const reg_file[4] = {
    [0] = "A",
    [1] = "g",
    [2] = "m",
    [3] = "imm",
};

static const char * const writemask[16] = {
    [0x0] = ".",
    [0x1] = ".x",
    [0x2] = ".y",
    [0x3] = ".xy",
    [0x4] = ".z",
    [0x5] = ".xz",
    [0x6] = ".yz",
    [0x7] = ".xyz",
    [0x8] = ".w",
    [0x9] = ".xw",
    [0xa] = ".yw",
    [0xb] = ".xyw",
    [0xc] = ".zw",
    [0xd] = ".xzw",
    [0xe] = ".yzw",
    [0xf] = "",
};

static const char * const end_of_thread[2] = {
    [0] = "",
    [1] = "EOT"
};

static const char * const target_function[16] = {
    [BRW_SFID_NULL] = "null",
    [BRW_SFID_MATH] = "math",
    [BRW_SFID_SAMPLER] = "sampler",
    [BRW_SFID_MESSAGE_GATEWAY] = "gateway",
    [BRW_SFID_DATAPORT_READ] = "read",
    [BRW_SFID_DATAPORT_WRITE] = "write",
    [BRW_SFID_URB] = "urb",
    [BRW_SFID_THREAD_SPAWNER] = "thread_spawner",
    [BRW_SFID_VME] = "vme",
};

static const char * const target_function_gen6[16] = {
    [BRW_SFID_NULL] = "null",
    [BRW_SFID_MATH] = "math",
    [BRW_SFID_SAMPLER] = "sampler",
    [BRW_SFID_MESSAGE_GATEWAY] = "gateway",
    [BRW_SFID_URB] = "urb",
    [BRW_SFID_THREAD_SPAWNER] = "thread_spawner",
    [GEN6_SFID_DATAPORT_SAMPLER_CACHE] = "sampler",
    [GEN6_SFID_DATAPORT_RENDER_CACHE] = "render",
    [GEN6_SFID_DATAPORT_CONSTANT_CACHE] = "const",
    [GEN7_SFID_DATAPORT_DATA_CACHE] = "data",
    [GEN7_SFID_PIXEL_INTERPOLATOR] = "pixel interp",
    [HSW_SFID_DATAPORT_DATA_CACHE_1] = "dp data 1",
    [HSW_SFID_CRE] = "cre",
};

static const char * const dp_rc_msg_type_gen6[16] = {
    [BRW_DATAPORT_READ_MESSAGE_OWORD_BLOCK_READ] = "OWORD block read",
    [GEN6_DATAPORT_READ_MESSAGE_RENDER_UNORM_READ] = "RT UNORM read",
    [GEN6_DATAPORT_READ_MESSAGE_OWORD_DUAL_BLOCK_READ] = "OWORD dual block read",
    [GEN6_DATAPORT_READ_MESSAGE_MEDIA_BLOCK_READ] = "media block read",
    [GEN6_DATAPORT_READ_MESSAGE_OWORD_UNALIGN_BLOCK_READ] = "OWORD unaligned block read",
    [GEN6_DATAPORT_READ_MESSAGE_DWORD_SCATTERED_READ] = "DWORD scattered read",
    [GEN6_DATAPORT_WRITE_MESSAGE_DWORD_ATOMIC_WRITE] = "DWORD atomic write",
    [GEN6_DATAPORT_WRITE_MESSAGE_OWORD_BLOCK_WRITE] = "OWORD block write",
    [GEN6_DATAPORT_WRITE_MESSAGE_OWORD_DUAL_BLOCK_WRITE] = "OWORD dual block write",
    [GEN6_DATAPORT_WRITE_MESSAGE_MEDIA_BLOCK_WRITE] = "media block write",
    [GEN6_DATAPORT_WRITE_MESSAGE_DWORD_SCATTERED_WRITE] = "DWORD scattered write",
    [GEN6_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_WRITE] = "RT write",
    [GEN6_DATAPORT_WRITE_MESSAGE_STREAMED_VB_WRITE] = "streamed VB write",
    [GEN6_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_UNORM_WRITE] = "RT UNORMc write",
d431 14
a444 12
    [GEN7_DATAPORT_DC_OWORD_BLOCK_READ] = "DC OWORD block read",
    [GEN7_DATAPORT_DC_UNALIGNED_OWORD_BLOCK_READ] = "DC unaligned OWORD block read",
    [GEN7_DATAPORT_DC_OWORD_DUAL_BLOCK_READ] = "DC OWORD dual block read",
    [GEN7_DATAPORT_DC_DWORD_SCATTERED_READ] = "DC DWORD scattered read",
    [GEN7_DATAPORT_DC_BYTE_SCATTERED_READ] = "DC byte scattered read",
    [GEN7_DATAPORT_DC_UNTYPED_ATOMIC_OP] = "DC untyped atomic",
    [GEN7_DATAPORT_DC_MEMORY_FENCE] = "DC mfence",
    [GEN7_DATAPORT_DC_OWORD_BLOCK_WRITE] = "DC OWORD block write",
    [GEN7_DATAPORT_DC_OWORD_DUAL_BLOCK_WRITE] = "DC OWORD dual block write",
    [GEN7_DATAPORT_DC_DWORD_SCATTERED_WRITE] = "DC DWORD scatterd write",
    [GEN7_DATAPORT_DC_BYTE_SCATTERED_WRITE] = "DC byte scattered write",
    [GEN7_DATAPORT_DC_UNTYPED_SURFACE_WRITE] = "DC untyped surface write",
d448 25
a472 23
    [HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_READ] = "untyped surface read",
    [HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP] = "DC untyped atomic op",
    [HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP_SIMD4X2] = "DC untyped 4x2 atomic op",
    [HSW_DATAPORT_DC_PORT1_MEDIA_BLOCK_READ] = "DC media block read",
    [HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_READ] = "DC typed surface read",
    [HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP] = "DC typed atomic",
    [HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP_SIMD4X2] = "DC typed 4x2 atomic op",
    [HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_WRITE] = "DC untyped surface write",
    [HSW_DATAPORT_DC_PORT1_MEDIA_BLOCK_WRITE] = "DC media block write",
    [HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP] = "DC atomic counter op",
    [HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP_SIMD4X2] = "DC 4x2 atomic counter op",
    [HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_WRITE] = "DC typed surface write",
};

static const char * const aop[16] = {
   [BRW_AOP_AND] = "and",
   [BRW_AOP_OR] = "or",
   [BRW_AOP_XOR] = "xor",
   [BRW_AOP_MOV] = "mov",
   [BRW_AOP_INC] = "inc",
   [BRW_AOP_DEC] = "dec",
   [BRW_AOP_ADD] = "add",
   [BRW_AOP_SUB] = "sub",
d474 5
a478 5
   [BRW_AOP_IMAX] = "imax",
   [BRW_AOP_IMIN] = "imin",
   [BRW_AOP_UMAX] = "umax",
   [BRW_AOP_UMIN] = "umin",
   [BRW_AOP_CMPWR] = "cmpwr",
d482 28
a509 14
static const char * const math_function[16] = {
    [BRW_MATH_FUNCTION_INV] = "inv",
    [BRW_MATH_FUNCTION_LOG] = "log",
    [BRW_MATH_FUNCTION_EXP] = "exp",
    [BRW_MATH_FUNCTION_SQRT] = "sqrt",
    [BRW_MATH_FUNCTION_RSQ] = "rsq",
    [BRW_MATH_FUNCTION_SIN] = "sin",
    [BRW_MATH_FUNCTION_COS] = "cos",
    [BRW_MATH_FUNCTION_SINCOS] = "sincos",
    [BRW_MATH_FUNCTION_FDIV] = "fdiv",
    [BRW_MATH_FUNCTION_POW] = "pow",
    [BRW_MATH_FUNCTION_INT_DIV_QUOTIENT_AND_REMAINDER] = "intdivmod",
    [BRW_MATH_FUNCTION_INT_DIV_QUOTIENT] = "intdiv",
    [BRW_MATH_FUNCTION_INT_DIV_REMAINDER] = "intmod",
d512 3
a514 3
static const char * const math_saturate[2] = {
    [0] = "",
    [1] = "sat"
d517 3
a519 3
static const char * const math_signed[2] = {
    [0] = "",
    [1] = "signed"
d522 3
a524 3
static const char * const math_scalar[2] = {
    [0] = "",
    [1] = "scalar"
d527 3
a529 3
static const char * const math_precision[2] = {
    [0] = "",
    [1] = "partial_precision"
d532 11
a542 3
static const char * const urb_opcode[2] = {
    [0] = "urb_write",
    [1] = "ff_sync",
d545 4
a548 4
static const char * const urb_swizzle[4] = {
    [BRW_URB_SWIZZLE_NONE] = "",
    [BRW_URB_SWIZZLE_INTERLEAVE] = "interleave",
    [BRW_URB_SWIZZLE_TRANSPOSE] = "transpose",
d551 3
a553 3
static const char * const urb_allocate[2] = {
    [0] = "",
    [1] = "allocate"
d556 3
a558 3
static const char * const urb_used[2] = {
    [0] = "",
    [1] = "used"
d561 3
a563 3
static const char * const urb_complete[2] = {
    [0] = "",
    [1] = "complete"
d566 4
a569 4
static const char * const sampler_target_format[4] = {
    [0] = "F",
    [2] = "UD",
    [3] = "D"
d575 10
a584 1
static int string (FILE *file, const char *string)
d586 55
a640 890
    fputs (string, file);
    column += strlen (string);
    return 0;
}

static int format (FILE *f, const char *format, ...)
{
    char    buf[1024];
    va_list	args;
    va_start (args, format);

    vsnprintf (buf, sizeof (buf) - 1, format, args);
    va_end (args);
    string (f, buf);
    return 0;
}

static int newline (FILE *f)
{
    putc ('\n', f);
    column = 0;
    return 0;
}

static int pad (FILE *f, int c)
{
    do
	string (f, " ");
    while (column < c);
    return 0;
}

static int control (FILE *file, const char *name, const char * const ctrl[],
                    unsigned id, int *space)
{
    if (!ctrl[id]) {
	fprintf (file, "*** invalid %s value %d ",
		 name, id);
	return 1;
    }
    if (ctrl[id][0])
    {
	if (space && *space)
	    string (file, " ");
	string (file, ctrl[id]);
	if (space)
	    *space = 1;
    }
    return 0;
}

static int print_opcode (FILE *file, int id)
{
    if (!opcode[id].name) {
	format (file, "*** invalid opcode value %d ", id);
	return 1;
    }
    string (file, opcode[id].name);
    return 0;
}

static int reg (FILE *file, unsigned _reg_file, unsigned _reg_nr)
{
    int	err = 0;

    /* Clear the Compr4 instruction compression bit. */
    if (_reg_file == BRW_MESSAGE_REGISTER_FILE)
       _reg_nr &= ~(1 << 7);

    if (_reg_file == BRW_ARCHITECTURE_REGISTER_FILE) {
	switch (_reg_nr & 0xf0) {
	case BRW_ARF_NULL:
	    string (file, "null");
	    return -1;
	case BRW_ARF_ADDRESS:
	    format (file, "a%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_ACCUMULATOR:
	    format (file, "acc%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_FLAG:
	    format (file, "f%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_MASK:
	    format (file, "mask%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_MASK_STACK:
	    format (file, "msd%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_STATE:
	    format (file, "sr%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_CONTROL:
	    format (file, "cr%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_NOTIFICATION_COUNT:
	    format (file, "n%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_IP:
	    string (file, "ip");
	    return -1;
	    break;
	default:
	    format (file, "ARF%d", _reg_nr);
	    break;
	}
    } else {
	err  |= control (file, "src reg file", reg_file, _reg_file, NULL);
	format (file, "%d", _reg_nr);
    }
    return err;
}

static int dest (FILE *file, struct brw_instruction *inst)
{
    int	err = 0;

    if (inst->header.access_mode == BRW_ALIGN_1)
    {
	if (inst->bits1.da1.dest_address_mode == BRW_ADDRESS_DIRECT)
	{
	    err |= reg (file, inst->bits1.da1.dest_reg_file, inst->bits1.da1.dest_reg_nr);
	    if (err == -1)
		return 0;
	    if (inst->bits1.da1.dest_subreg_nr)
		format (file, ".%d", inst->bits1.da1.dest_subreg_nr /
				     reg_type_size[inst->bits1.da1.dest_reg_type]);
	    string (file, "<");
	    err |= control (file, "horiz stride", horiz_stride, inst->bits1.da1.dest_horiz_stride, NULL);
	    string (file, ">");
	    err |= control (file, "dest reg encoding", reg_encoding, inst->bits1.da1.dest_reg_type, NULL);
	}
	else
	{
	    string (file, "g[a0");
	    if (inst->bits1.ia1.dest_subreg_nr)
		format (file, ".%d", inst->bits1.ia1.dest_subreg_nr /
					reg_type_size[inst->bits1.ia1.dest_reg_type]);
	    if (inst->bits1.ia1.dest_indirect_offset)
		format (file, " %d", inst->bits1.ia1.dest_indirect_offset);
	    string (file, "]<");
	    err |= control (file, "horiz stride", horiz_stride, inst->bits1.ia1.dest_horiz_stride, NULL);
	    string (file, ">");
	    err |= control (file, "dest reg encoding", reg_encoding, inst->bits1.ia1.dest_reg_type, NULL);
	}
    }
    else
    {
	if (inst->bits1.da16.dest_address_mode == BRW_ADDRESS_DIRECT)
	{
	    err |= reg (file, inst->bits1.da16.dest_reg_file, inst->bits1.da16.dest_reg_nr);
	    if (err == -1)
		return 0;
	    if (inst->bits1.da16.dest_subreg_nr)
		format (file, ".%d", inst->bits1.da16.dest_subreg_nr /
				     reg_type_size[inst->bits1.da16.dest_reg_type]);
	    string (file, "<1>");
	    err |= control (file, "writemask", writemask, inst->bits1.da16.dest_writemask, NULL);
	    err |= control (file, "dest reg encoding", reg_encoding, inst->bits1.da16.dest_reg_type, NULL);
	}
	else
	{
	    err = 1;
	    string (file, "Indirect align16 address mode not supported");
	}
    }

    return 0;
}

static int dest_3src (FILE *file, struct brw_instruction *inst)
{
    int	err = 0;
    uint32_t reg_file;

    if (inst->bits1.da3src.dest_reg_file)
       reg_file = BRW_MESSAGE_REGISTER_FILE;
    else
       reg_file = BRW_GENERAL_REGISTER_FILE;

    err |= reg (file, reg_file, inst->bits1.da3src.dest_reg_nr);
    if (err == -1)
       return 0;
    if (inst->bits1.da3src.dest_subreg_nr)
       format (file, ".%d", inst->bits1.da3src.dest_subreg_nr);
    string (file, "<1>");
    err |= control (file, "writemask", writemask, inst->bits1.da3src.dest_writemask, NULL);
    err |= control (file, "dest reg encoding", three_source_reg_encoding,
                    inst->bits1.da3src.dst_type, NULL);

    return 0;
}

static int src_align1_region (FILE *file,
			      unsigned _vert_stride, unsigned _width, unsigned _horiz_stride)
{
    int err = 0;
    string (file, "<");
    err |= control (file, "vert stride", vert_stride, _vert_stride, NULL);
    string (file, ",");
    err |= control (file, "width", width, _width, NULL);
    string (file, ",");
    err |= control (file, "horiz_stride", horiz_stride, _horiz_stride, NULL);
    string (file, ">");
    return err;
}

static int src_da1 (FILE *file, unsigned type, unsigned _reg_file,
		    unsigned _vert_stride, unsigned _width, unsigned _horiz_stride,
		    unsigned reg_num, unsigned sub_reg_num, unsigned __abs, unsigned _negate)
{
    int err = 0;
    err |= control (file, "negate", negate, _negate, NULL);
    err |= control (file, "abs", _abs, __abs, NULL);

    err |= reg (file, _reg_file, reg_num);
    if (err == -1)
	return 0;
    if (sub_reg_num)
	format (file, ".%d", sub_reg_num / reg_type_size[type]); /* use formal style like spec */
    src_align1_region (file, _vert_stride, _width, _horiz_stride);
    err |= control (file, "src reg encoding", reg_encoding, type, NULL);
    return err;
}

static int src_ia1 (FILE *file,
		    unsigned type,
		    unsigned _reg_file,
		    int _addr_imm,
		    unsigned _addr_subreg_nr,
		    unsigned _negate,
		    unsigned __abs,
		    unsigned _addr_mode,
		    unsigned _horiz_stride,
		    unsigned _width,
		    unsigned _vert_stride)
{
    int err = 0;
    err |= control (file, "negate", negate, _negate, NULL);
    err |= control (file, "abs", _abs, __abs, NULL);

    string (file, "g[a0");
    if (_addr_subreg_nr)
	format (file, ".%d", _addr_subreg_nr);
    if (_addr_imm)
	format (file, " %d", _addr_imm);
    string (file, "]");
    src_align1_region (file, _vert_stride, _width, _horiz_stride);
    err |= control (file, "src reg encoding", reg_encoding, type, NULL);
    return err;
}

static int src_da16 (FILE *file,
		     unsigned _reg_type,
		     unsigned _reg_file,
		     unsigned _vert_stride,
		     unsigned _reg_nr,
		     unsigned _subreg_nr,
		     unsigned __abs,
		     unsigned _negate,
		     unsigned swz_x,
		     unsigned swz_y,
		     unsigned swz_z,
		     unsigned swz_w)
{
    int err = 0;
    err |= control (file, "negate", negate, _negate, NULL);
    err |= control (file, "abs", _abs, __abs, NULL);

    err |= reg (file, _reg_file, _reg_nr);
    if (err == -1)
	return 0;
    if (_subreg_nr)
	/* bit4 for subreg number byte addressing. Make this same meaning as
	   in da1 case, so output looks consistent. */
	format (file, ".%d", 16 / reg_type_size[_reg_type]);
    string (file, "<");
    err |= control (file, "vert stride", vert_stride, _vert_stride, NULL);
    string (file, ",4,1>");
    /*
     * Three kinds of swizzle display:
     *  identity - nothing printed
     *  1->all	 - print the single channel
     *  1->1     - print the mapping
     */
    if (swz_x == BRW_CHANNEL_X &&
	swz_y == BRW_CHANNEL_Y &&
	swz_z == BRW_CHANNEL_Z &&
	swz_w == BRW_CHANNEL_W)
    {
	;
    }
    else if (swz_x == swz_y && swz_x == swz_z && swz_x == swz_w)
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
    }
    else
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
	err |= control (file, "channel select", chan_sel, swz_y, NULL);
	err |= control (file, "channel select", chan_sel, swz_z, NULL);
	err |= control (file, "channel select", chan_sel, swz_w, NULL);
    }
    err |= control (file, "src da16 reg type", reg_encoding, _reg_type, NULL);
    return err;
}

static int src0_3src (FILE *file, struct brw_instruction *inst)
{
    int err = 0;
    unsigned swz_x = (inst->bits2.da3src.src0_swizzle >> 0) & 0x3;
    unsigned swz_y = (inst->bits2.da3src.src0_swizzle >> 2) & 0x3;
    unsigned swz_z = (inst->bits2.da3src.src0_swizzle >> 4) & 0x3;
    unsigned swz_w = (inst->bits2.da3src.src0_swizzle >> 6) & 0x3;

    err |= control (file, "negate", negate, inst->bits1.da3src.src0_negate, NULL);
    err |= control (file, "abs", _abs, inst->bits1.da3src.src0_abs, NULL);

    err |= reg (file, BRW_GENERAL_REGISTER_FILE, inst->bits2.da3src.src0_reg_nr);
    if (err == -1)
	return 0;
    if (inst->bits2.da3src.src0_subreg_nr)
	format (file, ".%d", inst->bits2.da3src.src0_subreg_nr);
    if (inst->bits2.da3src.src0_rep_ctrl)
       string (file, "<0,1,0>");
    else
       string (file, "<4,4,1>");
    err |= control (file, "src da16 reg type", three_source_reg_encoding,
                    inst->bits1.da3src.src_type, NULL);
    /*
     * Three kinds of swizzle display:
     *  identity - nothing printed
     *  1->all	 - print the single channel
     *  1->1     - print the mapping
     */
    if (swz_x == BRW_CHANNEL_X &&
	swz_y == BRW_CHANNEL_Y &&
	swz_z == BRW_CHANNEL_Z &&
	swz_w == BRW_CHANNEL_W)
    {
	;
    }
    else if (swz_x == swz_y && swz_x == swz_z && swz_x == swz_w)
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
    }
    else
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
	err |= control (file, "channel select", chan_sel, swz_y, NULL);
	err |= control (file, "channel select", chan_sel, swz_z, NULL);
	err |= control (file, "channel select", chan_sel, swz_w, NULL);
    }
    return err;
}

static int src1_3src (FILE *file, struct brw_instruction *inst)
{
    int err = 0;
    unsigned swz_x = (inst->bits2.da3src.src1_swizzle >> 0) & 0x3;
    unsigned swz_y = (inst->bits2.da3src.src1_swizzle >> 2) & 0x3;
    unsigned swz_z = (inst->bits2.da3src.src1_swizzle >> 4) & 0x3;
    unsigned swz_w = (inst->bits2.da3src.src1_swizzle >> 6) & 0x3;
    unsigned src1_subreg_nr = (inst->bits2.da3src.src1_subreg_nr_low |
			     (inst->bits3.da3src.src1_subreg_nr_high << 2));

    err |= control (file, "negate", negate, inst->bits1.da3src.src1_negate,
		    NULL);
    err |= control (file, "abs", _abs, inst->bits1.da3src.src1_abs, NULL);

    err |= reg (file, BRW_GENERAL_REGISTER_FILE,
		inst->bits3.da3src.src1_reg_nr);
    if (err == -1)
	return 0;
    if (src1_subreg_nr)
	format (file, ".%d", src1_subreg_nr);
    if (inst->bits2.da3src.src1_rep_ctrl)
       string (file, "<0,1,0>");
    else
       string (file, "<4,4,1>");
    err |= control (file, "src da16 reg type", three_source_reg_encoding,
                    inst->bits1.da3src.src_type, NULL);
    /*
     * Three kinds of swizzle display:
     *  identity - nothing printed
     *  1->all	 - print the single channel
     *  1->1     - print the mapping
     */
    if (swz_x == BRW_CHANNEL_X &&
	swz_y == BRW_CHANNEL_Y &&
	swz_z == BRW_CHANNEL_Z &&
	swz_w == BRW_CHANNEL_W)
    {
	;
    }
    else if (swz_x == swz_y && swz_x == swz_z && swz_x == swz_w)
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
    }
    else
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
	err |= control (file, "channel select", chan_sel, swz_y, NULL);
	err |= control (file, "channel select", chan_sel, swz_z, NULL);
	err |= control (file, "channel select", chan_sel, swz_w, NULL);
    }
    return err;
}


static int src2_3src (FILE *file, struct brw_instruction *inst)
{
    int err = 0;
    unsigned swz_x = (inst->bits3.da3src.src2_swizzle >> 0) & 0x3;
    unsigned swz_y = (inst->bits3.da3src.src2_swizzle >> 2) & 0x3;
    unsigned swz_z = (inst->bits3.da3src.src2_swizzle >> 4) & 0x3;
    unsigned swz_w = (inst->bits3.da3src.src2_swizzle >> 6) & 0x3;

    err |= control (file, "negate", negate, inst->bits1.da3src.src2_negate,
		    NULL);
    err |= control (file, "abs", _abs, inst->bits1.da3src.src2_abs, NULL);

    err |= reg (file, BRW_GENERAL_REGISTER_FILE,
		inst->bits3.da3src.src2_reg_nr);
    if (err == -1)
	return 0;
    if (inst->bits3.da3src.src2_subreg_nr)
	format (file, ".%d", inst->bits3.da3src.src2_subreg_nr);
    if (inst->bits3.da3src.src2_rep_ctrl)
       string (file, "<0,1,0>");
    else
       string (file, "<4,4,1>");
    err |= control (file, "src da16 reg type", three_source_reg_encoding,
                    inst->bits1.da3src.src_type, NULL);
    /*
     * Three kinds of swizzle display:
     *  identity - nothing printed
     *  1->all	 - print the single channel
     *  1->1     - print the mapping
     */
    if (swz_x == BRW_CHANNEL_X &&
	swz_y == BRW_CHANNEL_Y &&
	swz_z == BRW_CHANNEL_Z &&
	swz_w == BRW_CHANNEL_W)
    {
	;
    }
    else if (swz_x == swz_y && swz_x == swz_z && swz_x == swz_w)
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
    }
    else
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
	err |= control (file, "channel select", chan_sel, swz_y, NULL);
	err |= control (file, "channel select", chan_sel, swz_z, NULL);
	err |= control (file, "channel select", chan_sel, swz_w, NULL);
    }
    return err;
}

static int imm (FILE *file, unsigned type, struct brw_instruction *inst) {
    switch (type) {
    case BRW_HW_REG_TYPE_UD:
	format (file, "0x%08xUD", inst->bits3.ud);
	break;
    case BRW_HW_REG_TYPE_D:
	format (file, "%dD", inst->bits3.d);
	break;
    case BRW_HW_REG_TYPE_UW:
	format (file, "0x%04xUW", (uint16_t) inst->bits3.ud);
	break;
    case BRW_HW_REG_TYPE_W:
	format (file, "%dW", (int16_t) inst->bits3.d);
	break;
    case BRW_HW_REG_IMM_TYPE_UV:
	format (file, "0x%08xUV", inst->bits3.ud);
	break;
    case BRW_HW_REG_IMM_TYPE_VF:
	format (file, "Vector Float");
	break;
    case BRW_HW_REG_IMM_TYPE_V:
	format (file, "0x%08xV", inst->bits3.ud);
	break;
    case BRW_HW_REG_TYPE_F:
	format (file, "%-gF", inst->bits3.f);
    }
    return 0;
}

static int src0 (FILE *file, struct brw_instruction *inst)
{
    if (inst->bits1.da1.src0_reg_file == BRW_IMMEDIATE_VALUE)
	return imm (file, inst->bits1.da1.src0_reg_type,
		    inst);
    else if (inst->header.access_mode == BRW_ALIGN_1)
    {
	if (inst->bits2.da1.src0_address_mode == BRW_ADDRESS_DIRECT)
	{
	    return src_da1 (file,
			    inst->bits1.da1.src0_reg_type,
			    inst->bits1.da1.src0_reg_file,
			    inst->bits2.da1.src0_vert_stride,
			    inst->bits2.da1.src0_width,
			    inst->bits2.da1.src0_horiz_stride,
			    inst->bits2.da1.src0_reg_nr,
			    inst->bits2.da1.src0_subreg_nr,
			    inst->bits2.da1.src0_abs,
			    inst->bits2.da1.src0_negate);
	}
	else
	{
	    return src_ia1 (file,
			    inst->bits1.ia1.src0_reg_type,
			    inst->bits1.ia1.src0_reg_file,
			    inst->bits2.ia1.src0_indirect_offset,
			    inst->bits2.ia1.src0_subreg_nr,
			    inst->bits2.ia1.src0_negate,
			    inst->bits2.ia1.src0_abs,
			    inst->bits2.ia1.src0_address_mode,
			    inst->bits2.ia1.src0_horiz_stride,
			    inst->bits2.ia1.src0_width,
			    inst->bits2.ia1.src0_vert_stride);
	}
    }
    else
    {
	if (inst->bits2.da16.src0_address_mode == BRW_ADDRESS_DIRECT)
	{
	    return src_da16 (file,
			     inst->bits1.da16.src0_reg_type,
			     inst->bits1.da16.src0_reg_file,
			     inst->bits2.da16.src0_vert_stride,
			     inst->bits2.da16.src0_reg_nr,
			     inst->bits2.da16.src0_subreg_nr,
			     inst->bits2.da16.src0_abs,
			     inst->bits2.da16.src0_negate,
			     inst->bits2.da16.src0_swz_x,
			     inst->bits2.da16.src0_swz_y,
			     inst->bits2.da16.src0_swz_z,
			     inst->bits2.da16.src0_swz_w);
	}
	else
	{
	    string (file, "Indirect align16 address mode not supported");
	    return 1;
	}
    }
}

static int src1 (FILE *file, struct brw_instruction *inst)
{
    if (inst->bits1.da1.src1_reg_file == BRW_IMMEDIATE_VALUE)
	return imm (file, inst->bits1.da1.src1_reg_type,
		    inst);
    else if (inst->header.access_mode == BRW_ALIGN_1)
    {
	if (inst->bits3.da1.src1_address_mode == BRW_ADDRESS_DIRECT)
	{
	    return src_da1 (file,
			    inst->bits1.da1.src1_reg_type,
			    inst->bits1.da1.src1_reg_file,
			    inst->bits3.da1.src1_vert_stride,
			    inst->bits3.da1.src1_width,
			    inst->bits3.da1.src1_horiz_stride,
			    inst->bits3.da1.src1_reg_nr,
			    inst->bits3.da1.src1_subreg_nr,
			    inst->bits3.da1.src1_abs,
			    inst->bits3.da1.src1_negate);
	}
	else
	{
	    return src_ia1 (file,
			    inst->bits1.ia1.src1_reg_type,
			    inst->bits1.ia1.src1_reg_file,
			    inst->bits3.ia1.src1_indirect_offset,
			    inst->bits3.ia1.src1_subreg_nr,
			    inst->bits3.ia1.src1_negate,
			    inst->bits3.ia1.src1_abs,
			    inst->bits3.ia1.src1_address_mode,
			    inst->bits3.ia1.src1_horiz_stride,
			    inst->bits3.ia1.src1_width,
			    inst->bits3.ia1.src1_vert_stride);
	}
    }
    else
    {
	if (inst->bits3.da16.src1_address_mode == BRW_ADDRESS_DIRECT)
	{
	    return src_da16 (file,
			     inst->bits1.da16.src1_reg_type,
			     inst->bits1.da16.src1_reg_file,
			     inst->bits3.da16.src1_vert_stride,
			     inst->bits3.da16.src1_reg_nr,
			     inst->bits3.da16.src1_subreg_nr,
			     inst->bits3.da16.src1_abs,
			     inst->bits3.da16.src1_negate,
			     inst->bits3.da16.src1_swz_x,
			     inst->bits3.da16.src1_swz_y,
			     inst->bits3.da16.src1_swz_z,
			     inst->bits3.da16.src1_swz_w);
	}
	else
	{
	    string (file, "Indirect align16 address mode not supported");
	    return 1;
	}
    }
}

static int qtr_ctrl(FILE *file, struct brw_instruction *inst)
{
    int qtr_ctl = inst->header.compression_control;
    int exec_size = 1 << inst->header.execution_size;

    if (exec_size == 8) {
	switch (qtr_ctl) {
	case 0:
	    string (file, " 1Q");
	    break;
	case 1:
	    string (file, " 2Q");
	    break;
	case 2:
	    string (file, " 3Q");
	    break;
	case 3:
	    string (file, " 4Q");
	    break;
	}
    } else if (exec_size == 16){
	if (qtr_ctl < 2)
	    string (file, " 1H");
	else
	    string (file, " 2H");
    }
    return 0;
}

int brw_disasm (FILE *file, struct brw_instruction *inst, int gen)
{
    int	err = 0;
    int space = 0;

    if (inst->header.predicate_control) {
	string (file, "(");
	err |= control (file, "predicate inverse", pred_inv, inst->header.predicate_inverse, NULL);
	format (file, "f%d", gen >= 7 ? inst->bits2.da1.flag_reg_nr : 0);
	if (inst->bits2.da1.flag_subreg_nr)
	    format (file, ".%d", inst->bits2.da1.flag_subreg_nr);
	if (inst->header.access_mode == BRW_ALIGN_1)
	    err |= control (file, "predicate control align1", pred_ctrl_align1,
			    inst->header.predicate_control, NULL);
	else
	    err |= control (file, "predicate control align16", pred_ctrl_align16,
			    inst->header.predicate_control, NULL);
	string (file, ") ");
    }

    err |= print_opcode (file, inst->header.opcode);
    err |= control (file, "saturate", saturate, inst->header.saturate, NULL);
    err |= control (file, "debug control", debug_ctrl, inst->header.debug_control, NULL);

    if (inst->header.opcode == BRW_OPCODE_MATH) {
	string (file, " ");
	err |= control (file, "function", math_function,
			inst->header.destreg__conditionalmod, NULL);
    } else if (inst->header.opcode != BRW_OPCODE_SEND &&
	       inst->header.opcode != BRW_OPCODE_SENDC) {
	err |= control (file, "conditional modifier", conditional_modifier,
			inst->header.destreg__conditionalmod, NULL);

        /* If we're using the conditional modifier, print which flags reg is
         * used for it.  Note that on gen6+, the embedded-condition SEL and
         * control flow doesn't update flags.
         */
	if (inst->header.destreg__conditionalmod &&
            (gen < 6 || (inst->header.opcode != BRW_OPCODE_SEL &&
                         inst->header.opcode != BRW_OPCODE_IF &&
                         inst->header.opcode != BRW_OPCODE_WHILE))) {
	    format (file, ".f%d", gen >= 7 ? inst->bits2.da1.flag_reg_nr : 0);
	    if (inst->bits2.da1.flag_subreg_nr)
		format (file, ".%d", inst->bits2.da1.flag_subreg_nr);
        }
    }

    if (inst->header.opcode != BRW_OPCODE_NOP) {
	string (file, "(");
	err |= control (file, "execution size", exec_size, inst->header.execution_size, NULL);
	string (file, ")");
    }

    if (inst->header.opcode == BRW_OPCODE_SEND && gen < 6)
	format (file, " %d", inst->header.destreg__conditionalmod);

    if (opcode[inst->header.opcode].nsrc == 3) {
       pad (file, 16);
       err |= dest_3src (file, inst);

       pad (file, 32);
       err |= src0_3src (file, inst);

       pad (file, 48);
       err |= src1_3src (file, inst);

       pad (file, 64);
       err |= src2_3src (file, inst);
    } else {
       if (opcode[inst->header.opcode].ndst > 0) {
	  pad (file, 16);
	  err |= dest (file, inst);
       } else if (gen == 7 && (inst->header.opcode == BRW_OPCODE_ELSE ||
			       inst->header.opcode == BRW_OPCODE_ENDIF ||
			       inst->header.opcode == BRW_OPCODE_WHILE)) {
	  format (file, " %d", inst->bits3.break_cont.jip);
       } else if (gen == 6 && (inst->header.opcode == BRW_OPCODE_IF ||
			       inst->header.opcode == BRW_OPCODE_ELSE ||
			       inst->header.opcode == BRW_OPCODE_ENDIF ||
			       inst->header.opcode == BRW_OPCODE_WHILE)) {
	  format (file, " %d", inst->bits1.branch_gen6.jump_count);
       } else if ((gen >= 6 && (inst->header.opcode == BRW_OPCODE_BREAK ||
                                inst->header.opcode == BRW_OPCODE_CONTINUE ||
                                inst->header.opcode == BRW_OPCODE_HALT)) ||
                  (gen == 7 && inst->header.opcode == BRW_OPCODE_IF)) {
	  format (file, " %d %d", inst->bits3.break_cont.uip, inst->bits3.break_cont.jip);
       } else if (inst->header.opcode == BRW_OPCODE_JMPI) {
	  format (file, " %d", inst->bits3.d);
       }

       if (opcode[inst->header.opcode].nsrc > 0) {
	  pad (file, 32);
	  err |= src0 (file, inst);
       }
       if (opcode[inst->header.opcode].nsrc > 1) {
	  pad (file, 48);
	  err |= src1 (file, inst);
       }
    }

    if (inst->header.opcode == BRW_OPCODE_SEND ||
	inst->header.opcode == BRW_OPCODE_SENDC) {
	enum brw_message_target target;

	if (gen >= 6)
	    target = inst->header.destreg__conditionalmod;
	else if (gen == 5)
	    target = inst->bits2.send_gen5.sfid;
	else
	    target = inst->bits3.generic.msg_target;

	newline (file);
	pad (file, 16);
	space = 0;

	if (gen >= 6) {
	   err |= control (file, "target function", target_function_gen6,
			   target, &space);
	} else {
	   err |= control (file, "target function", target_function,
			   target, &space);
	}

	switch (target) {
	case BRW_SFID_MATH:
	    err |= control (file, "math function", math_function,
			    inst->bits3.math.function, &space);
	    err |= control (file, "math saturate", math_saturate,
			    inst->bits3.math.saturate, &space);
	    err |= control (file, "math signed", math_signed,
			    inst->bits3.math.int_type, &space);
	    err |= control (file, "math scalar", math_scalar,
			    inst->bits3.math.data_type, &space);
	    err |= control (file, "math precision", math_precision,
			    inst->bits3.math.precision, &space);
	    break;
	case BRW_SFID_SAMPLER:
	    if (gen >= 7) {
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.sampler_gen7.binding_table_index,
			inst->bits3.sampler_gen7.sampler,
			inst->bits3.sampler_gen7.msg_type,
			inst->bits3.sampler_gen7.simd_mode);
	    } else if (gen >= 5) {
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.sampler_gen5.binding_table_index,
			inst->bits3.sampler_gen5.sampler,
			inst->bits3.sampler_gen5.msg_type,
			inst->bits3.sampler_gen5.simd_mode);
	    } else if (0 /* FINISHME: is_g4x */) {
		format (file, " (%d, %d)",
			inst->bits3.sampler_g4x.binding_table_index,
			inst->bits3.sampler_g4x.sampler);
	    } else {
		format (file, " (%d, %d, ",
			inst->bits3.sampler.binding_table_index,
			inst->bits3.sampler.sampler);
		err |= control (file, "sampler target format",
				sampler_target_format,
				inst->bits3.sampler.return_format, NULL);
		string (file, ")");
	    }
	    break;
	case BRW_SFID_DATAPORT_READ:
	    if (gen >= 6) {
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.gen6_dp.binding_table_index,
			inst->bits3.gen6_dp.msg_control,
			inst->bits3.gen6_dp.msg_type,
			inst->bits3.gen6_dp.send_commit_msg);
	    } else if (gen >= 5 /* FINISHME: || is_g4x */) {
		format (file, " (%d, %d, %d)",
			inst->bits3.dp_read_gen5.binding_table_index,
			inst->bits3.dp_read_gen5.msg_control,
			inst->bits3.dp_read_gen5.msg_type);
	    } else {
		format (file, " (%d, %d, %d)",
			inst->bits3.dp_read.binding_table_index,
			inst->bits3.dp_read.msg_control,
			inst->bits3.dp_read.msg_type);
	    }
	    break;

	case BRW_SFID_DATAPORT_WRITE:
	    if (gen >= 7) {
		format (file, " (");

		err |= control (file, "DP rc message type",
				dp_rc_msg_type_gen6,
				inst->bits3.gen7_dp.msg_type, &space);

		format (file, ", %d, %d, %d)",
			inst->bits3.gen7_dp.binding_table_index,
			inst->bits3.gen7_dp.msg_control,
			inst->bits3.gen7_dp.msg_type);
	    } else if (gen == 6) {
		format (file, " (");

		err |= control (file, "DP rc message type",
				dp_rc_msg_type_gen6,
				inst->bits3.gen6_dp.msg_type, &space);

		format (file, ", %d, %d, %d, %d)",
			inst->bits3.gen6_dp.binding_table_index,
			inst->bits3.gen6_dp.msg_control,
			inst->bits3.gen6_dp.msg_type,
			inst->bits3.gen6_dp.send_commit_msg);
	    } else {
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.dp_write.binding_table_index,
			(inst->bits3.dp_write.last_render_target << 3) |
			inst->bits3.dp_write.msg_control,
			inst->bits3.dp_write.msg_type,
			inst->bits3.dp_write.send_commit_msg);
	    }
	    break;

	case BRW_SFID_URB:
	    if (gen >= 5) {
		format (file, " %d", inst->bits3.urb_gen5.offset);
	    } else {
		format (file, " %d", inst->bits3.urb.offset);
	    }

	    space = 1;
	    if (gen >= 5) {
		err |= control (file, "urb opcode", urb_opcode,
				inst->bits3.urb_gen5.opcode, &space);
	    }
	    err |= control (file, "urb swizzle", urb_swizzle,
			    inst->bits3.urb.swizzle_control, &space);
	    err |= control (file, "urb allocate", urb_allocate,
			    inst->bits3.urb.allocate, &space);
	    err |= control (file, "urb used", urb_used,
			    inst->bits3.urb.used, &space);
	    err |= control (file, "urb complete", urb_complete,
			    inst->bits3.urb.complete, &space);
	    break;
	case BRW_SFID_THREAD_SPAWNER:
	    break;
	case GEN7_SFID_DATAPORT_DATA_CACHE:
           if (gen >= 7) {
              format (file, " (");
d642 790
a1431 1
              err |= control (file, "DP DC0 message type",
d1433 1
a1433 1
                              inst->bits3.gen7_dp.msg_type, &space);
d1435 56
a1490 1
              format (file, ", %d, ", inst->bits3.gen7_dp.binding_table_index);
d1492 7
a1498 39
              switch (inst->bits3.gen7_dp.msg_type) {
              case GEN7_DATAPORT_DC_UNTYPED_ATOMIC_OP:
                 control (file, "atomic op", aop, inst->bits3.ud >> 8 & 0xf,
                          &space);
                 break;
              default:
                 format (file, "%d", inst->bits3.gen7_dp.msg_control);
              }
              format (file, ")");
              break;
           }
           /* FALLTHROUGH */

	case HSW_SFID_DATAPORT_DATA_CACHE_1:
	    if (gen >= 7) {
		format (file, " (");

		err |= control (file, "DP DC1 message type",
				dp_dc1_msg_type_hsw,
				inst->bits3.gen7_dp.msg_type, &space);

		format (file, ", %d, ",
			inst->bits3.gen7_dp.binding_table_index);

                switch (inst->bits3.gen7_dp.msg_type) {
                case HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP:
                case HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP_SIMD4X2:
                case HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP:
                case HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP_SIMD4X2:
                case HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP:
                case HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP_SIMD4X2:
                   control (file, "atomic op", aop,
                            inst->bits3.ud >> 8 & 0xf, &space);
                   break;
                default:
                   format (file, "%d", inst->bits3.gen7_dp.msg_control);
                }
                format (file, ")");
                break;
d1502 58
a1559 57
	default:
	    format (file, "unsupported target %d", target);
	    break;
	}
	if (space)
	    string (file, " ");
	if (gen >= 5) {
	   format (file, "mlen %d",
		   inst->bits3.generic_gen5.msg_length);
	   format (file, " rlen %d",
		   inst->bits3.generic_gen5.response_length);
	} else {
	   format (file, "mlen %d",
		   inst->bits3.generic.msg_length);
	   format (file, " rlen %d",
		   inst->bits3.generic.response_length);
	}
    }
    pad (file, 64);
    if (inst->header.opcode != BRW_OPCODE_NOP) {
	string (file, "{");
	space = 1;
	err |= control(file, "access mode", access_mode, inst->header.access_mode, &space);
	if (gen >= 6)
	    err |= control (file, "write enable control", wectrl, inst->header.mask_control, &space);
	else
	    err |= control (file, "mask control", mask_ctrl, inst->header.mask_control, &space);
	err |= control (file, "dependency control", dep_ctrl, inst->header.dependency_control, &space);

	if (gen >= 6)
	    err |= qtr_ctrl (file, inst);
	else {
	    if (inst->header.compression_control == BRW_COMPRESSION_COMPRESSED &&
		opcode[inst->header.opcode].ndst > 0 &&
		inst->bits1.da1.dest_reg_file == BRW_MESSAGE_REGISTER_FILE &&
		inst->bits1.da1.dest_reg_nr & (1 << 7)) {
		format (file, " compr4");
	    } else {
		err |= control (file, "compression control", compr_ctrl,
				inst->header.compression_control, &space);
	    }
	}

	err |= control (file, "thread control", thread_ctrl, inst->header.thread_control, &space);
	if (gen >= 6)
	    err |= control (file, "acc write control", accwr, inst->header.acc_wr_control, &space);
	if (inst->header.opcode == BRW_OPCODE_SEND ||
	    inst->header.opcode == BRW_OPCODE_SENDC)
	    err |= control (file, "end of thread", end_of_thread,
			    inst->bits3.generic.end_of_thread, &space);
	if (space)
	    string (file, " ");
	string (file, "}");
    }
    string (file, ";");
    newline (file);
    return err;
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d78 4
a81 2
    [BRW_OPCODE_BFI1] = { .name = "bfe1", .nsrc = 2, .ndst = 1},
    [BRW_OPCODE_BFI2] = { .name = "bfe2", .nsrc = 3, .ndst = 1},
d104 1
a104 1
static const char * const conditional_modifier[16] = {
d257 6
d312 2
a313 1
    [BRW_SFID_THREAD_SPAWNER] = "thread_spawner"
d326 4
a329 1
    [GEN7_SFID_DATAPORT_DATA_CACHE] = "data"
d349 48
d503 1
a503 1
                    GLuint id, int *space)
d531 1
a531 14
static int three_source_type_to_reg_type(int three_source_type)
{
   switch (three_source_type) {
   case BRW_3SRC_TYPE_F:
      return BRW_REGISTER_TYPE_F;
   case BRW_3SRC_TYPE_D:
      return BRW_REGISTER_TYPE_D;
   case BRW_3SRC_TYPE_UD:
      return BRW_REGISTER_TYPE_UD;
   }
   return -1;
}

static int reg (FILE *file, GLuint _reg_file, GLuint _reg_nr)
d657 2
a658 3
    err |= control (file, "dest reg encoding", reg_encoding,
                    three_source_type_to_reg_type(inst->bits1.da3src.dst_type),
                    NULL);
d664 1
a664 1
			      GLuint _vert_stride, GLuint _width, GLuint _horiz_stride)
d677 3
a679 3
static int src_da1 (FILE *file, GLuint type, GLuint _reg_file,
		    GLuint _vert_stride, GLuint _width, GLuint _horiz_stride,
		    GLuint reg_num, GLuint sub_reg_num, GLuint __abs, GLuint _negate)
d696 10
a705 10
		    GLuint type,
		    GLuint _reg_file,
		    GLint _addr_imm,
		    GLuint _addr_subreg_nr,
		    GLuint _negate,
		    GLuint __abs,
		    GLuint _addr_mode,
		    GLuint _horiz_stride,
		    GLuint _width,
		    GLuint _vert_stride)
d723 11
a733 11
		     GLuint _reg_type,
		     GLuint _reg_file,
		     GLuint _vert_stride,
		     GLuint _reg_nr,
		     GLuint _subreg_nr,
		     GLuint __abs,
		     GLuint _negate,
		     GLuint swz_x,
		     GLuint swz_y,
		     GLuint swz_z,
		     GLuint swz_w)
d782 4
a785 4
    GLuint swz_x = (inst->bits2.da3src.src0_swizzle >> 0) & 0x3;
    GLuint swz_y = (inst->bits2.da3src.src0_swizzle >> 2) & 0x3;
    GLuint swz_z = (inst->bits2.da3src.src0_swizzle >> 4) & 0x3;
    GLuint swz_w = (inst->bits2.da3src.src0_swizzle >> 6) & 0x3;
d795 6
a800 4
    string (file, "<4,1,1>");
    err |= control (file, "src da16 reg type", reg_encoding,
                    three_source_type_to_reg_type(inst->bits1.da3src.src_type),
                    NULL);
d833 5
a837 5
    GLuint swz_x = (inst->bits2.da3src.src1_swizzle >> 0) & 0x3;
    GLuint swz_y = (inst->bits2.da3src.src1_swizzle >> 2) & 0x3;
    GLuint swz_z = (inst->bits2.da3src.src1_swizzle >> 4) & 0x3;
    GLuint swz_w = (inst->bits2.da3src.src1_swizzle >> 6) & 0x3;
    GLuint src1_subreg_nr = (inst->bits2.da3src.src1_subreg_nr_low |
d850 6
a855 4
    string (file, "<4,1,1>");
    err |= control (file, "src da16 reg type", reg_encoding,
                    three_source_type_to_reg_type(inst->bits1.da3src.src_type),
                    NULL);
d889 4
a892 4
    GLuint swz_x = (inst->bits3.da3src.src2_swizzle >> 0) & 0x3;
    GLuint swz_y = (inst->bits3.da3src.src2_swizzle >> 2) & 0x3;
    GLuint swz_z = (inst->bits3.da3src.src2_swizzle >> 4) & 0x3;
    GLuint swz_w = (inst->bits3.da3src.src2_swizzle >> 6) & 0x3;
d904 6
a909 4
    string (file, "<4,1,1>");
    err |= control (file, "src da16 reg type", reg_encoding,
                    three_source_type_to_reg_type(inst->bits1.da3src.src_type),
                    NULL);
d939 1
a939 1
static int imm (FILE *file, GLuint type, struct brw_instruction *inst) {
d941 1
a941 1
    case BRW_REGISTER_TYPE_UD:
d944 1
a944 1
    case BRW_REGISTER_TYPE_D:
d947 1
a947 1
    case BRW_REGISTER_TYPE_UW:
d950 1
a950 1
    case BRW_REGISTER_TYPE_W:
d953 2
a954 2
    case BRW_REGISTER_TYPE_UB:
	format (file, "0x%02xUB", (int8_t) inst->bits3.ud);
d956 1
a956 1
    case BRW_REGISTER_TYPE_VF:
d959 1
a959 1
    case BRW_REGISTER_TYPE_V:
d962 1
a962 1
    case BRW_REGISTER_TYPE_F:
a1087 9
int esize[6] = {
	[0] = 1,
	[1] = 2,
	[2] = 4,
	[3] = 8,
	[4] = 16,
	[5] = 32,
};

d1091 1
a1091 1
    int exec_size = esize[inst->header.execution_size];
d1358 32
a1389 5
	    format (file, " (%d, %d, %d)",
		    inst->bits3.gen7_dp.binding_table_index,
		    inst->bits3.gen7_dp.msg_control,
		    inst->bits3.gen7_dp.msg_type);
	    break;
d1391 17
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d35 1
a35 5
struct {
    char    *name;
    int	    nsrc;
    int	    ndst;
} opcode[128] = {
d44 6
d56 2
d77 3
d84 1
a84 1
    [BRW_OPCODE_JMPI] = { .name = "jmpi", .nsrc = 1, .ndst = 0 },
d100 1
d102 1
a102 1
char *conditional_modifier[16] = {
d115 1
a115 1
char *negate[2] = {
d120 1
a120 1
char *_abs[2] = {
d125 1
a125 1
char *vert_stride[16] = {
d136 1
a136 1
char *width[8] = {
d144 1
a144 1
char *horiz_stride[4] = {
d151 1
a151 1
char *chan_sel[4] = {
d158 1
a158 4
char *dest_condmod[16] = {
};

char *debug_ctrl[2] = {
d163 1
a163 1
char *saturate[2] = {
d168 1
a168 1
char *accwr[2] = {
d173 1
a173 1
char *wectrl[2] = {
d178 1
a178 1
char *exec_size[8] = {
d187 1
a187 1
char *pred_inv[2] = {
d192 1
a192 1
char *pred_ctrl_align16[16] = {
d202 1
a202 1
char *pred_ctrl_align1[16] = {
d216 1
a216 1
char *thread_ctrl[4] = {
d221 1
a221 1
char *compr_ctrl[4] = {
d228 1
a228 1
char *dep_ctrl[4] = {
d235 1
a235 1
char *mask_ctrl[4] = {
d240 1
a240 1
char *access_mode[2] = {
d245 1
a245 1
char *reg_encoding[8] = {
d255 1
a255 1
int reg_type_size[8] = {
d265 1
a265 11
char *imm_encoding[8] = {
    [0] = "UD",
    [1] = "D",
    [2] = "UW",
    [3] = "W",
    [5] = "VF",
    [6] = "V",
    [7] = "F"
};

char *reg_file[4] = {
d272 1
a272 1
char *writemask[16] = {
d291 1
a291 1
char *end_of_thread[2] = {
d296 39
a334 9
char *target_function[16] = {
    [BRW_MESSAGE_TARGET_NULL] = "null",
    [BRW_MESSAGE_TARGET_MATH] = "math",
    [BRW_MESSAGE_TARGET_SAMPLER] = "sampler",
    [BRW_MESSAGE_TARGET_GATEWAY] = "gateway",
    [BRW_MESSAGE_TARGET_DATAPORT_READ] = "read",
    [BRW_MESSAGE_TARGET_DATAPORT_WRITE] = "write",
    [BRW_MESSAGE_TARGET_URB] = "urb",
    [BRW_MESSAGE_TARGET_THREAD_SPAWNER] = "thread_spawner"
d337 1
a337 1
char *math_function[16] = {
d346 1
a346 1
    [BRW_MATH_FUNCTION_TAN] = "tan",
d349 2
a350 2
    [BRW_MATH_FUNCTION_INT_DIV_QUOTIENT] = "intmod",
    [BRW_MATH_FUNCTION_INT_DIV_REMAINDER] = "intdiv",
d353 1
a353 1
char *math_saturate[2] = {
d358 1
a358 1
char *math_signed[2] = {
d363 1
a363 1
char *math_scalar[2] = {
d368 1
a368 1
char *math_precision[2] = {
d373 1
a373 1
char *urb_opcode[2] = {
d378 1
a378 1
char *urb_swizzle[4] = {
d384 1
a384 1
char *urb_allocate[2] = {
d389 1
a389 1
char *urb_used[2] = {
d394 1
a394 1
char *urb_complete[2] = {
d399 1
a399 1
char *sampler_target_format[4] = {
d408 1
a408 1
static int string (FILE *file, char *string)
d415 1
a415 1
static int format (FILE *f, char *format, ...)
d442 2
a443 1
static int control (FILE *file, char *name, char *ctrl[], GLuint id, int *space)
d471 13
d550 3
a552 1
	    format (file, "<%d>", inst->bits1.da1.dest_horiz_stride);
d563 3
a565 2
	    string (file, "]");
	    format (file, "<%d>", inst->bits1.ia1.dest_horiz_stride);
d593 24
d733 153
d1082 3
a1084 3
	string (file, "f0");
	if (inst->bits2.da1.flag_reg_nr)
	    format (file, ".%d", inst->bits2.da1.flag_reg_nr);
d1103 1
a1103 1
	       inst->header.opcode != BRW_OPCODE_SENDC)
d1107 14
d1130 9
a1138 9
    if (opcode[inst->header.opcode].ndst > 0) {
	pad (file, 16);
	err |= dest (file, inst);
    } else if (gen >= 6 && (inst->header.opcode == BRW_OPCODE_IF ||
			    inst->header.opcode == BRW_OPCODE_ELSE ||
			    inst->header.opcode == BRW_OPCODE_ENDIF ||
			    inst->header.opcode == BRW_OPCODE_WHILE)) {
       format (file, " %d", inst->bits1.branch_gen6.jump_count);
    }
d1140 32
a1171 7
    if (opcode[inst->header.opcode].nsrc > 0) {
	pad (file, 32);
	err |= src0 (file, inst);
    }
    if (opcode[inst->header.opcode].nsrc > 1) {
	pad (file, 48);
	err |= src1 (file, inst);
d1176 1
a1176 1
	int target;
d1188 8
a1195 2
	err |= control (file, "target function", target_function,
			target, &space);
d1198 1
a1198 1
	case BRW_MESSAGE_TARGET_MATH:
d1210 8
a1217 2
	case BRW_MESSAGE_TARGET_SAMPLER:
	    if (gen >= 5) {
d1237 1
a1237 1
	case BRW_MESSAGE_TARGET_DATAPORT_READ:
d1239 1
a1239 1
		format (file, " (%d, %d, %d, %d, %d, %d)",
d1243 1
a1243 3
			inst->bits3.gen6_dp.send_commit_msg,
			inst->bits3.gen6_dp.msg_length,
			inst->bits3.gen6_dp.response_length);
d1256 21
a1276 3
	case BRW_MESSAGE_TARGET_DATAPORT_WRITE:
	    if (gen >= 6) {
		format (file, " (%d, %d, %d, %d, %d, %d)",
d1280 1
a1280 3
			inst->bits3.gen6_dp.send_commit_msg,
			inst->bits3.gen6_dp.msg_length,
			inst->bits3.gen6_dp.response_length);
d1284 1
a1284 1
			(inst->bits3.dp_write.pixel_scoreboard_clear << 3) |
d1290 2
a1291 1
	case BRW_MESSAGE_TARGET_URB:
a1310 5
	    if (gen >= 5) {
		format (file, " mlen %d, rlen %d\n",
			inst->bits3.urb_gen5.msg_length,
			inst->bits3.urb_gen5.response_length);
	    }
d1312 7
a1318 1
	case BRW_MESSAGE_TARGET_THREAD_SPAWNER:
d1320 2
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d970 6
a975 6
			inst->bits3.dp_render_cache.binding_table_index,
			inst->bits3.dp_render_cache.msg_control,
			inst->bits3.dp_render_cache.msg_type,
			inst->bits3.dp_render_cache.send_commit_msg,
			inst->bits3.dp_render_cache.msg_length,
			inst->bits3.dp_render_cache.response_length);
d991 6
a996 6
			inst->bits3.dp_render_cache.binding_table_index,
			inst->bits3.dp_render_cache.msg_control,
			inst->bits3.dp_render_cache.msg_type,
			inst->bits3.dp_render_cache.send_commit_msg,
			inst->bits3.dp_render_cache.msg_length,
			inst->bits3.dp_render_cache.response_length);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d53 1
d60 1
d75 1
d79 2
a80 2
    [BRW_OPCODE_IFF] = { .name = "iff", .nsrc = 1, .ndst = 01 },
    [BRW_OPCODE_WHILE] = { .name = "while", .nsrc = 1, .ndst = 0 },
d82 1
a82 1
    [BRW_OPCODE_BREAK] = { .name = "break", .nsrc = 1, .ndst = 0 },
d163 10
d220 1
d250 10
d348 5
d448 5
d464 3
d509 2
a510 1
		format (file, ".%d", inst->bits1.da1.dest_subreg_nr);
d518 2
a519 1
		format (file, ".%d", inst->bits1.ia1.dest_subreg_nr);
d535 2
a536 1
		format (file, ".%d", inst->bits1.da16.dest_subreg_nr);
d577 1
a577 1
	format (file, ".%d", sub_reg_num);
d631 3
a633 1
	format (file, ".%d", _subreg_nr);
d636 1
a636 2
    string (file, ",1,1>");
    err |= control (file, "src da16 reg type", reg_encoding, _reg_type, NULL);
d663 1
d817 39
a855 1
int brw_disasm (FILE *file, struct brw_instruction *inst)
d879 6
a884 1
    if (inst->header.opcode != BRW_OPCODE_SEND)
d894 1
a894 1
    if (inst->header.opcode == BRW_OPCODE_SEND)
d900 5
d906 1
d916 11
a926 1
    if (inst->header.opcode == BRW_OPCODE_SEND) {
d931 3
a933 2
			inst->bits3.generic.msg_target, &space);
	switch (inst->bits3.generic.msg_target) {
d947 40
a986 6
	    format (file, " (%d, %d, ",
		    inst->bits3.sampler.binding_table_index,
		    inst->bits3.sampler.sampler);
	    err |= control (file, "sampler target format", sampler_target_format,
			    inst->bits3.sampler.return_format, NULL);
	    string (file, ")");
d989 16
a1004 6
	    format (file, " (%d, %d, %d, %d)",
		    inst->bits3.dp_write.binding_table_index,
		    (inst->bits3.dp_write.pixel_scoreboard_clear << 3) |
		    inst->bits3.dp_write.msg_control,
		    inst->bits3.dp_write.msg_type,
		    inst->bits3.dp_write.send_commit_msg);
d1007 6
a1012 1
	    format (file, " %d", inst->bits3.urb.offset);
d1014 4
d1026 5
d1035 1
a1035 1
	    format (file, "unsupported target %d", inst->bits3.generic.msg_target);
d1040 11
a1050 4
	format (file, "mlen %d",
		inst->bits3.generic.msg_length);
	format (file, " rlen %d",
		inst->bits3.generic.response_length);
d1057 4
a1060 1
	err |= control (file, "mask control", mask_ctrl, inst->header.mask_control, &space);
d1062 15
a1076 1
	err |= control (file, "compression control", compr_ctrl, inst->header.compression_control, &space);
d1078 4
a1081 1
	if (inst->header.opcode == BRW_OPCODE_SEND)
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a52 1
    [BRW_OPCODE_PLN] = { .name = "pln", .nsrc = 2, .ndst = 1 },
a58 1
    [BRW_OPCODE_MATH] = { .name = "math", .nsrc = 2, .ndst = 1 },
a72 1
    [BRW_OPCODE_SENDC] = { .name = "sendc", .nsrc = 1, .ndst = 1 },
d76 2
a77 2
    [BRW_OPCODE_IFF] = { .name = "iff", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_WHILE] = { .name = "while", .nsrc = 2, .ndst = 0 },
d79 1
a79 1
    [BRW_OPCODE_BREAK] = { .name = "break", .nsrc = 2, .ndst = 0 },
a159 10
char *accwr[2] = {
    [0] = "",
    [1] = "AccWrEnable"
};

char *wectrl[2] = {
    [0] = "WE_normal",
    [1] = "WE_all"
};

a206 1
    [3] = "compr4",
a235 10
int reg_type_size[8] = {
    [0] = 4,
    [1] = 4,
    [2] = 2,
    [3] = 2,
    [4] = 1,
    [5] = 1,
    [7] = 4
};

a323 5
char *urb_opcode[2] = {
    [0] = "urb_write",
    [1] = "ff_sync",
};

a418 5

    /* Clear the Compr4 instruction compression bit. */
    if (_reg_file == BRW_MESSAGE_REGISTER_FILE)
       _reg_nr &= ~(1 << 7);

a429 3
	case BRW_ARF_FLAG:
	    format (file, "f%d", _reg_nr & 0x0f);
	    break;
d472 1
a472 2
		format (file, ".%d", inst->bits1.da1.dest_subreg_nr /
				     reg_type_size[inst->bits1.da1.dest_reg_type]);
d480 1
a480 2
		format (file, ".%d", inst->bits1.ia1.dest_subreg_nr /
					reg_type_size[inst->bits1.ia1.dest_reg_type]);
d496 1
a496 2
		format (file, ".%d", inst->bits1.da16.dest_subreg_nr /
				     reg_type_size[inst->bits1.da16.dest_reg_type]);
d537 1
a537 1
	format (file, ".%d", sub_reg_num / reg_type_size[type]); /* use formal style like spec */
d591 1
a591 3
	/* bit4 for subreg number byte addressing. Make this same meaning as
	   in da1 case, so output looks consistent. */
	format (file, ".%d", 16 / reg_type_size[_reg_type]);
d594 2
a595 1
    string (file, ",4,1>");
a621 1
    err |= control (file, "src da16 reg type", reg_encoding, _reg_type, NULL);
d775 1
a775 39
int esize[6] = {
	[0] = 1,
	[1] = 2,
	[2] = 4,
	[3] = 8,
	[4] = 16,
	[5] = 32,
};

static int qtr_ctrl(FILE *file, struct brw_instruction *inst)
{
    int qtr_ctl = inst->header.compression_control;
    int exec_size = esize[inst->header.execution_size];

    if (exec_size == 8) {
	switch (qtr_ctl) {
	case 0:
	    string (file, " 1Q");
	    break;
	case 1:
	    string (file, " 2Q");
	    break;
	case 2:
	    string (file, " 3Q");
	    break;
	case 3:
	    string (file, " 4Q");
	    break;
	}
    } else if (exec_size == 16){
	if (qtr_ctl < 2)
	    string (file, " 1H");
	else
	    string (file, " 2H");
    }
    return 0;
}

int brw_disasm (FILE *file, struct brw_instruction *inst, int gen)
d799 1
a799 6
    if (inst->header.opcode == BRW_OPCODE_MATH) {
	string (file, " ");
	err |= control (file, "function", math_function,
			inst->header.destreg__conditionalmod, NULL);
    } else if (inst->header.opcode != BRW_OPCODE_SEND &&
	       inst->header.opcode != BRW_OPCODE_SENDC)
d809 1
a809 1
    if (inst->header.opcode == BRW_OPCODE_SEND && gen < 6)
a814 5
    } else if (gen >= 6 && (inst->header.opcode == BRW_OPCODE_IF ||
			    inst->header.opcode == BRW_OPCODE_ELSE ||
			    inst->header.opcode == BRW_OPCODE_ENDIF ||
			    inst->header.opcode == BRW_OPCODE_WHILE)) {
       format (file, " %d", inst->bits1.branch_gen6.jump_count);
a815 1

d825 1
a825 11
    if (inst->header.opcode == BRW_OPCODE_SEND ||
	inst->header.opcode == BRW_OPCODE_SENDC) {
	int target;

	if (gen >= 6)
	    target = inst->header.destreg__conditionalmod;
	else if (gen == 5)
	    target = inst->bits2.send_gen5.sfid;
	else
	    target = inst->bits3.generic.msg_target;

d830 2
a831 3
			target, &space);

	switch (target) {
d845 6
a850 40
	    if (gen >= 5) {
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.sampler_gen5.binding_table_index,
			inst->bits3.sampler_gen5.sampler,
			inst->bits3.sampler_gen5.msg_type,
			inst->bits3.sampler_gen5.simd_mode);
	    } else if (0 /* FINISHME: is_g4x */) {
		format (file, " (%d, %d)",
			inst->bits3.sampler_g4x.binding_table_index,
			inst->bits3.sampler_g4x.sampler);
	    } else {
		format (file, " (%d, %d, ",
			inst->bits3.sampler.binding_table_index,
			inst->bits3.sampler.sampler);
		err |= control (file, "sampler target format",
				sampler_target_format,
				inst->bits3.sampler.return_format, NULL);
		string (file, ")");
	    }
	    break;
	case BRW_MESSAGE_TARGET_DATAPORT_READ:
	    if (gen >= 6) {
		format (file, " (%d, %d, %d, %d, %d, %d)",
			inst->bits3.dp_render_cache.binding_table_index,
			inst->bits3.dp_render_cache.msg_control,
			inst->bits3.dp_render_cache.msg_type,
			inst->bits3.dp_render_cache.send_commit_msg,
			inst->bits3.dp_render_cache.msg_length,
			inst->bits3.dp_render_cache.response_length);
	    } else if (gen >= 5 /* FINISHME: || is_g4x */) {
		format (file, " (%d, %d, %d)",
			inst->bits3.dp_read_gen5.binding_table_index,
			inst->bits3.dp_read_gen5.msg_control,
			inst->bits3.dp_read_gen5.msg_type);
	    } else {
		format (file, " (%d, %d, %d)",
			inst->bits3.dp_read.binding_table_index,
			inst->bits3.dp_read.msg_control,
			inst->bits3.dp_read.msg_type);
	    }
d853 6
a858 16
	    if (gen >= 6) {
		format (file, " (%d, %d, %d, %d, %d, %d)",
			inst->bits3.dp_render_cache.binding_table_index,
			inst->bits3.dp_render_cache.msg_control,
			inst->bits3.dp_render_cache.msg_type,
			inst->bits3.dp_render_cache.send_commit_msg,
			inst->bits3.dp_render_cache.msg_length,
			inst->bits3.dp_render_cache.response_length);
	    } else {
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.dp_write.binding_table_index,
			(inst->bits3.dp_write.pixel_scoreboard_clear << 3) |
			inst->bits3.dp_write.msg_control,
			inst->bits3.dp_write.msg_type,
			inst->bits3.dp_write.send_commit_msg);
	    }
d861 1
a861 6
	    if (gen >= 5) {
		format (file, " %d", inst->bits3.urb_gen5.offset);
	    } else {
		format (file, " %d", inst->bits3.urb.offset);
	    }

a862 4
	    if (gen >= 5) {
		err |= control (file, "urb opcode", urb_opcode,
				inst->bits3.urb_gen5.opcode, &space);
	    }
a870 5
	    if (gen >= 5) {
		format (file, " mlen %d, rlen %d\n",
			inst->bits3.urb_gen5.msg_length,
			inst->bits3.urb_gen5.response_length);
	    }
d875 1
a875 1
	    format (file, "unsupported target %d", target);
d880 4
a883 11
	if (gen >= 5) {
	   format (file, "mlen %d",
		   inst->bits3.generic_gen5.msg_length);
	   format (file, " rlen %d",
		   inst->bits3.generic_gen5.response_length);
	} else {
	   format (file, "mlen %d",
		   inst->bits3.generic.msg_length);
	   format (file, " rlen %d",
		   inst->bits3.generic.response_length);
	}
d890 1
a890 4
	if (gen >= 6)
	    err |= control (file, "write enable control", wectrl, inst->header.mask_control, &space);
	else
	    err |= control (file, "mask control", mask_ctrl, inst->header.mask_control, &space);
d892 1
a892 15

	if (gen >= 6)
	    err |= qtr_ctrl (file, inst);
	else {
	    if (inst->header.compression_control == BRW_COMPRESSION_COMPRESSED &&
		opcode[inst->header.opcode].ndst > 0 &&
		inst->bits1.da1.dest_reg_file == BRW_MESSAGE_REGISTER_FILE &&
		inst->bits1.da1.dest_reg_nr & (1 << 7)) {
		format (file, " compr4");
	    } else {
		err |= control (file, "compression control", compr_ctrl,
				inst->header.compression_control, &space);
	    }
	}

d894 1
a894 4
	if (gen >= 6)
	    err |= control (file, "acc write control", accwr, inst->header.acc_wr_control, &space);
	if (inst->header.opcode == BRW_OPCODE_SEND ||
	    inst->header.opcode == BRW_OPCODE_SENDC)
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d35 5
a39 1
const struct opcode_desc opcode_descs[128] = {
a47 6
    [BRW_OPCODE_F32TO16] = { .name = "f32to16", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_F16TO32] = { .name = "f16to32", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_BFREV] = { .name = "bfrev", .nsrc = 1, .ndst = 1},
    [BRW_OPCODE_FBH] = { .name = "fbh", .nsrc = 1, .ndst = 1},
    [BRW_OPCODE_FBL] = { .name = "fbl", .nsrc = 1, .ndst = 1},
    [BRW_OPCODE_CBIT] = { .name = "cbit", .nsrc = 1, .ndst = 1},
a53 2
    [BRW_OPCODE_MAD] = { .name = "mad", .nsrc = 3, .ndst = 1 },
    [BRW_OPCODE_LRP] = { .name = "lrp", .nsrc = 3, .ndst = 1 },
a72 3
    [BRW_OPCODE_BFE] = { .name = "bfe", .nsrc = 3, .ndst = 1},
    [BRW_OPCODE_BFI1] = { .name = "bfe1", .nsrc = 2, .ndst = 1},
    [BRW_OPCODE_BFI2] = { .name = "bfe2", .nsrc = 3, .ndst = 1},
d77 1
a77 1
    [BRW_OPCODE_JMPI] = { .name = "jmpi", .nsrc = 0, .ndst = 0 },
a92 1
static const struct opcode_desc *opcode = opcode_descs;
d94 1
a94 1
static const char * const conditional_modifier[16] = {
d107 1
a107 1
static const char * const negate[2] = {
d112 1
a112 1
static const char * const _abs[2] = {
d117 1
a117 1
static const char * const vert_stride[16] = {
d128 1
a128 1
static const char * const width[8] = {
d136 1
a136 1
static const char * const horiz_stride[4] = {
d143 1
a143 1
static const char * const chan_sel[4] = {
d150 4
a153 1
static const char * const debug_ctrl[2] = {
d158 1
a158 1
static const char * const saturate[2] = {
d163 1
a163 1
static const char * const accwr[2] = {
d168 1
a168 1
static const char * const wectrl[2] = {
d173 1
a173 1
static const char * const exec_size[8] = {
d182 1
a182 1
static const char * const pred_inv[2] = {
d187 1
a187 1
static const char * const pred_ctrl_align16[16] = {
d197 1
a197 1
static const char * const pred_ctrl_align1[16] = {
d211 1
a211 1
static const char * const thread_ctrl[4] = {
d216 1
a216 1
static const char * const compr_ctrl[4] = {
d223 1
a223 1
static const char * const dep_ctrl[4] = {
d230 1
a230 1
static const char * const mask_ctrl[4] = {
d235 1
a235 1
static const char * const access_mode[2] = {
d240 1
a240 1
static const char * const reg_encoding[8] = {
d250 1
a250 1
const int reg_type_size[8] = {
d260 11
a270 1
static const char * const reg_file[4] = {
d277 1
a277 1
static const char * const writemask[16] = {
d296 1
a296 1
static const char * const end_of_thread[2] = {
d301 9
a309 39
static const char * const target_function[16] = {
    [BRW_SFID_NULL] = "null",
    [BRW_SFID_MATH] = "math",
    [BRW_SFID_SAMPLER] = "sampler",
    [BRW_SFID_MESSAGE_GATEWAY] = "gateway",
    [BRW_SFID_DATAPORT_READ] = "read",
    [BRW_SFID_DATAPORT_WRITE] = "write",
    [BRW_SFID_URB] = "urb",
    [BRW_SFID_THREAD_SPAWNER] = "thread_spawner"
};

static const char * const target_function_gen6[16] = {
    [BRW_SFID_NULL] = "null",
    [BRW_SFID_MATH] = "math",
    [BRW_SFID_SAMPLER] = "sampler",
    [BRW_SFID_MESSAGE_GATEWAY] = "gateway",
    [BRW_SFID_URB] = "urb",
    [BRW_SFID_THREAD_SPAWNER] = "thread_spawner",
    [GEN6_SFID_DATAPORT_SAMPLER_CACHE] = "sampler",
    [GEN6_SFID_DATAPORT_RENDER_CACHE] = "render",
    [GEN6_SFID_DATAPORT_CONSTANT_CACHE] = "const",
    [GEN7_SFID_DATAPORT_DATA_CACHE] = "data"
};

static const char * const dp_rc_msg_type_gen6[16] = {
    [BRW_DATAPORT_READ_MESSAGE_OWORD_BLOCK_READ] = "OWORD block read",
    [GEN6_DATAPORT_READ_MESSAGE_RENDER_UNORM_READ] = "RT UNORM read",
    [GEN6_DATAPORT_READ_MESSAGE_OWORD_DUAL_BLOCK_READ] = "OWORD dual block read",
    [GEN6_DATAPORT_READ_MESSAGE_MEDIA_BLOCK_READ] = "media block read",
    [GEN6_DATAPORT_READ_MESSAGE_OWORD_UNALIGN_BLOCK_READ] = "OWORD unaligned block read",
    [GEN6_DATAPORT_READ_MESSAGE_DWORD_SCATTERED_READ] = "DWORD scattered read",
    [GEN6_DATAPORT_WRITE_MESSAGE_DWORD_ATOMIC_WRITE] = "DWORD atomic write",
    [GEN6_DATAPORT_WRITE_MESSAGE_OWORD_BLOCK_WRITE] = "OWORD block write",
    [GEN6_DATAPORT_WRITE_MESSAGE_OWORD_DUAL_BLOCK_WRITE] = "OWORD dual block write",
    [GEN6_DATAPORT_WRITE_MESSAGE_MEDIA_BLOCK_WRITE] = "media block write",
    [GEN6_DATAPORT_WRITE_MESSAGE_DWORD_SCATTERED_WRITE] = "DWORD scattered write",
    [GEN6_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_WRITE] = "RT write",
    [GEN6_DATAPORT_WRITE_MESSAGE_STREAMED_VB_WRITE] = "streamed VB write",
    [GEN6_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_UNORM_WRITE] = "RT UNORMc write",
d312 1
a312 1
static const char * const math_function[16] = {
d321 1
a321 1
    [BRW_MATH_FUNCTION_FDIV] = "fdiv",
d324 2
a325 2
    [BRW_MATH_FUNCTION_INT_DIV_QUOTIENT] = "intdiv",
    [BRW_MATH_FUNCTION_INT_DIV_REMAINDER] = "intmod",
d328 1
a328 1
static const char * const math_saturate[2] = {
d333 1
a333 1
static const char * const math_signed[2] = {
d338 1
a338 1
static const char * const math_scalar[2] = {
d343 1
a343 1
static const char * const math_precision[2] = {
d348 1
a348 1
static const char * const urb_opcode[2] = {
d353 1
a353 1
static const char * const urb_swizzle[4] = {
d359 1
a359 1
static const char * const urb_allocate[2] = {
d364 1
a364 1
static const char * const urb_used[2] = {
d369 1
a369 1
static const char * const urb_complete[2] = {
d374 1
a374 1
static const char * const sampler_target_format[4] = {
d383 1
a383 1
static int string (FILE *file, const char *string)
d390 1
a390 1
static int format (FILE *f, const char *format, ...)
d417 1
a417 2
static int control (FILE *file, const char *name, const char * const ctrl[],
                    GLuint id, int *space)
a444 13
static int three_source_type_to_reg_type(int three_source_type)
{
   switch (three_source_type) {
   case BRW_3SRC_TYPE_F:
      return BRW_REGISTER_TYPE_F;
   case BRW_3SRC_TYPE_D:
      return BRW_REGISTER_TYPE_D;
   case BRW_3SRC_TYPE_UD:
      return BRW_REGISTER_TYPE_UD;
   }
   return -1;
}

d511 1
a511 3
	    string (file, "<");
	    err |= control (file, "horiz stride", horiz_stride, inst->bits1.da1.dest_horiz_stride, NULL);
	    string (file, ">");
d522 2
a523 3
	    string (file, "]<");
	    err |= control (file, "horiz stride", horiz_stride, inst->bits1.ia1.dest_horiz_stride, NULL);
	    string (file, ">");
a550 24
static int dest_3src (FILE *file, struct brw_instruction *inst)
{
    int	err = 0;
    uint32_t reg_file;

    if (inst->bits1.da3src.dest_reg_file)
       reg_file = BRW_MESSAGE_REGISTER_FILE;
    else
       reg_file = BRW_GENERAL_REGISTER_FILE;

    err |= reg (file, reg_file, inst->bits1.da3src.dest_reg_nr);
    if (err == -1)
       return 0;
    if (inst->bits1.da3src.dest_subreg_nr)
       format (file, ".%d", inst->bits1.da3src.dest_subreg_nr);
    string (file, "<1>");
    err |= control (file, "writemask", writemask, inst->bits1.da3src.dest_writemask, NULL);
    err |= control (file, "dest reg encoding", reg_encoding,
                    three_source_type_to_reg_type(inst->bits1.da3src.dst_type),
                    NULL);

    return 0;
}

a666 153
static int src0_3src (FILE *file, struct brw_instruction *inst)
{
    int err = 0;
    GLuint swz_x = (inst->bits2.da3src.src0_swizzle >> 0) & 0x3;
    GLuint swz_y = (inst->bits2.da3src.src0_swizzle >> 2) & 0x3;
    GLuint swz_z = (inst->bits2.da3src.src0_swizzle >> 4) & 0x3;
    GLuint swz_w = (inst->bits2.da3src.src0_swizzle >> 6) & 0x3;

    err |= control (file, "negate", negate, inst->bits1.da3src.src0_negate, NULL);
    err |= control (file, "abs", _abs, inst->bits1.da3src.src0_abs, NULL);

    err |= reg (file, BRW_GENERAL_REGISTER_FILE, inst->bits2.da3src.src0_reg_nr);
    if (err == -1)
	return 0;
    if (inst->bits2.da3src.src0_subreg_nr)
	format (file, ".%d", inst->bits2.da3src.src0_subreg_nr);
    string (file, "<4,1,1>");
    err |= control (file, "src da16 reg type", reg_encoding,
                    three_source_type_to_reg_type(inst->bits1.da3src.src_type),
                    NULL);
    /*
     * Three kinds of swizzle display:
     *  identity - nothing printed
     *  1->all	 - print the single channel
     *  1->1     - print the mapping
     */
    if (swz_x == BRW_CHANNEL_X &&
	swz_y == BRW_CHANNEL_Y &&
	swz_z == BRW_CHANNEL_Z &&
	swz_w == BRW_CHANNEL_W)
    {
	;
    }
    else if (swz_x == swz_y && swz_x == swz_z && swz_x == swz_w)
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
    }
    else
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
	err |= control (file, "channel select", chan_sel, swz_y, NULL);
	err |= control (file, "channel select", chan_sel, swz_z, NULL);
	err |= control (file, "channel select", chan_sel, swz_w, NULL);
    }
    return err;
}

static int src1_3src (FILE *file, struct brw_instruction *inst)
{
    int err = 0;
    GLuint swz_x = (inst->bits2.da3src.src1_swizzle >> 0) & 0x3;
    GLuint swz_y = (inst->bits2.da3src.src1_swizzle >> 2) & 0x3;
    GLuint swz_z = (inst->bits2.da3src.src1_swizzle >> 4) & 0x3;
    GLuint swz_w = (inst->bits2.da3src.src1_swizzle >> 6) & 0x3;
    GLuint src1_subreg_nr = (inst->bits2.da3src.src1_subreg_nr_low |
			     (inst->bits3.da3src.src1_subreg_nr_high << 2));

    err |= control (file, "negate", negate, inst->bits1.da3src.src1_negate,
		    NULL);
    err |= control (file, "abs", _abs, inst->bits1.da3src.src1_abs, NULL);

    err |= reg (file, BRW_GENERAL_REGISTER_FILE,
		inst->bits3.da3src.src1_reg_nr);
    if (err == -1)
	return 0;
    if (src1_subreg_nr)
	format (file, ".%d", src1_subreg_nr);
    string (file, "<4,1,1>");
    err |= control (file, "src da16 reg type", reg_encoding,
                    three_source_type_to_reg_type(inst->bits1.da3src.src_type),
                    NULL);
    /*
     * Three kinds of swizzle display:
     *  identity - nothing printed
     *  1->all	 - print the single channel
     *  1->1     - print the mapping
     */
    if (swz_x == BRW_CHANNEL_X &&
	swz_y == BRW_CHANNEL_Y &&
	swz_z == BRW_CHANNEL_Z &&
	swz_w == BRW_CHANNEL_W)
    {
	;
    }
    else if (swz_x == swz_y && swz_x == swz_z && swz_x == swz_w)
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
    }
    else
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
	err |= control (file, "channel select", chan_sel, swz_y, NULL);
	err |= control (file, "channel select", chan_sel, swz_z, NULL);
	err |= control (file, "channel select", chan_sel, swz_w, NULL);
    }
    return err;
}


static int src2_3src (FILE *file, struct brw_instruction *inst)
{
    int err = 0;
    GLuint swz_x = (inst->bits3.da3src.src2_swizzle >> 0) & 0x3;
    GLuint swz_y = (inst->bits3.da3src.src2_swizzle >> 2) & 0x3;
    GLuint swz_z = (inst->bits3.da3src.src2_swizzle >> 4) & 0x3;
    GLuint swz_w = (inst->bits3.da3src.src2_swizzle >> 6) & 0x3;

    err |= control (file, "negate", negate, inst->bits1.da3src.src2_negate,
		    NULL);
    err |= control (file, "abs", _abs, inst->bits1.da3src.src2_abs, NULL);

    err |= reg (file, BRW_GENERAL_REGISTER_FILE,
		inst->bits3.da3src.src2_reg_nr);
    if (err == -1)
	return 0;
    if (inst->bits3.da3src.src2_subreg_nr)
	format (file, ".%d", inst->bits3.da3src.src2_subreg_nr);
    string (file, "<4,1,1>");
    err |= control (file, "src da16 reg type", reg_encoding,
                    three_source_type_to_reg_type(inst->bits1.da3src.src_type),
                    NULL);
    /*
     * Three kinds of swizzle display:
     *  identity - nothing printed
     *  1->all	 - print the single channel
     *  1->1     - print the mapping
     */
    if (swz_x == BRW_CHANNEL_X &&
	swz_y == BRW_CHANNEL_Y &&
	swz_z == BRW_CHANNEL_Z &&
	swz_w == BRW_CHANNEL_W)
    {
	;
    }
    else if (swz_x == swz_y && swz_x == swz_z && swz_x == swz_w)
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
    }
    else
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
	err |= control (file, "channel select", chan_sel, swz_y, NULL);
	err |= control (file, "channel select", chan_sel, swz_z, NULL);
	err |= control (file, "channel select", chan_sel, swz_w, NULL);
    }
    return err;
}
d863 3
a865 3
	format (file, "f%d", gen >= 7 ? inst->bits2.da1.flag_reg_nr : 0);
	if (inst->bits2.da1.flag_subreg_nr)
	    format (file, ".%d", inst->bits2.da1.flag_subreg_nr);
d884 1
a884 1
	       inst->header.opcode != BRW_OPCODE_SENDC) {
a887 14
        /* If we're using the conditional modifier, print which flags reg is
         * used for it.  Note that on gen6+, the embedded-condition SEL and
         * control flow doesn't update flags.
         */
	if (inst->header.destreg__conditionalmod &&
            (gen < 6 || (inst->header.opcode != BRW_OPCODE_SEL &&
                         inst->header.opcode != BRW_OPCODE_IF &&
                         inst->header.opcode != BRW_OPCODE_WHILE))) {
	    format (file, ".f%d", gen >= 7 ? inst->bits2.da1.flag_reg_nr : 0);
	    if (inst->bits2.da1.flag_subreg_nr)
		format (file, ".%d", inst->bits2.da1.flag_subreg_nr);
        }
    }

d897 9
a905 6
    if (opcode[inst->header.opcode].nsrc == 3) {
       pad (file, 16);
       err |= dest_3src (file, inst);

       pad (file, 32);
       err |= src0_3src (file, inst);
d907 7
a913 35
       pad (file, 48);
       err |= src1_3src (file, inst);

       pad (file, 64);
       err |= src2_3src (file, inst);
    } else {
       if (opcode[inst->header.opcode].ndst > 0) {
	  pad (file, 16);
	  err |= dest (file, inst);
       } else if (gen == 7 && (inst->header.opcode == BRW_OPCODE_ELSE ||
			       inst->header.opcode == BRW_OPCODE_ENDIF ||
			       inst->header.opcode == BRW_OPCODE_WHILE)) {
	  format (file, " %d", inst->bits3.break_cont.jip);
       } else if (gen == 6 && (inst->header.opcode == BRW_OPCODE_IF ||
			       inst->header.opcode == BRW_OPCODE_ELSE ||
			       inst->header.opcode == BRW_OPCODE_ENDIF ||
			       inst->header.opcode == BRW_OPCODE_WHILE)) {
	  format (file, " %d", inst->bits1.branch_gen6.jump_count);
       } else if ((gen >= 6 && (inst->header.opcode == BRW_OPCODE_BREAK ||
                                inst->header.opcode == BRW_OPCODE_CONTINUE ||
                                inst->header.opcode == BRW_OPCODE_HALT)) ||
                  (gen == 7 && inst->header.opcode == BRW_OPCODE_IF)) {
	  format (file, " %d %d", inst->bits3.break_cont.uip, inst->bits3.break_cont.jip);
       } else if (inst->header.opcode == BRW_OPCODE_JMPI) {
	  format (file, " %d", inst->bits3.d);
       }

       if (opcode[inst->header.opcode].nsrc > 0) {
	  pad (file, 32);
	  err |= src0 (file, inst);
       }
       if (opcode[inst->header.opcode].nsrc > 1) {
	  pad (file, 48);
	  err |= src1 (file, inst);
       }
d918 1
a918 1
	enum brw_message_target target;
d930 2
a931 8

	if (gen >= 6) {
	   err |= control (file, "target function", target_function_gen6,
			   target, &space);
	} else {
	   err |= control (file, "target function", target_function,
			   target, &space);
	}
d934 1
a934 1
	case BRW_SFID_MATH:
d946 2
a947 8
	case BRW_SFID_SAMPLER:
	    if (gen >= 7) {
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.sampler_gen7.binding_table_index,
			inst->bits3.sampler_gen7.sampler,
			inst->bits3.sampler_gen7.msg_type,
			inst->bits3.sampler_gen7.simd_mode);
	    } else if (gen >= 5) {
d967 1
a967 1
	case BRW_SFID_DATAPORT_READ:
d969 7
a975 5
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.gen6_dp.binding_table_index,
			inst->bits3.gen6_dp.msg_control,
			inst->bits3.gen6_dp.msg_type,
			inst->bits3.gen6_dp.send_commit_msg);
d988 9
a996 25

	case BRW_SFID_DATAPORT_WRITE:
	    if (gen >= 7) {
		format (file, " (");

		err |= control (file, "DP rc message type",
				dp_rc_msg_type_gen6,
				inst->bits3.gen7_dp.msg_type, &space);

		format (file, ", %d, %d, %d)",
			inst->bits3.gen7_dp.binding_table_index,
			inst->bits3.gen7_dp.msg_control,
			inst->bits3.gen7_dp.msg_type);
	    } else if (gen == 6) {
		format (file, " (");

		err |= control (file, "DP rc message type",
				dp_rc_msg_type_gen6,
				inst->bits3.gen6_dp.msg_type, &space);

		format (file, ", %d, %d, %d, %d)",
			inst->bits3.gen6_dp.binding_table_index,
			inst->bits3.gen6_dp.msg_control,
			inst->bits3.gen6_dp.msg_type,
			inst->bits3.gen6_dp.send_commit_msg);
d1000 1
a1000 1
			(inst->bits3.dp_write.last_render_target << 3) |
d1006 1
a1006 2

	case BRW_SFID_URB:
d1026 5
d1032 1
a1032 7
	case BRW_SFID_THREAD_SPAWNER:
	    break;
	case GEN7_SFID_DATAPORT_DATA_CACHE:
	    format (file, " (%d, %d, %d)",
		    inst->bits3.gen7_dp.binding_table_index,
		    inst->bits3.gen7_dp.msg_control,
		    inst->bits3.gen7_dp.msg_type);
a1033 2


@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d78 2
a79 4
    [BRW_OPCODE_BFI1] = { .name = "bfi1", .nsrc = 2, .ndst = 1},
    [BRW_OPCODE_BFI2] = { .name = "bfi2", .nsrc = 3, .ndst = 1},
    [BRW_OPCODE_ADDC] = { .name = "addc", .nsrc = 2, .ndst = 1},
    [BRW_OPCODE_SUBB] = { .name = "subb", .nsrc = 2, .ndst = 1},
d102 1
a102 1
const char * const conditional_modifier[16] = {
a254 6
const char * const three_source_reg_encoding[] = {
   [BRW_3SRC_TYPE_F]  = "F",
   [BRW_3SRC_TYPE_D]  = "D",
   [BRW_3SRC_TYPE_UD] = "UD",
};

d304 1
a304 2
    [BRW_SFID_THREAD_SPAWNER] = "thread_spawner",
    [BRW_SFID_VME] = "vme",
d317 1
a317 4
    [GEN7_SFID_DATAPORT_DATA_CACHE] = "data",
    [GEN7_SFID_PIXEL_INTERPOLATOR] = "pixel interp",
    [HSW_SFID_DATAPORT_DATA_CACHE_1] = "dp data 1",
    [HSW_SFID_CRE] = "cre",
a336 48
static const char *const dp_dc0_msg_type_gen7[16] = {
    [GEN7_DATAPORT_DC_OWORD_BLOCK_READ] = "DC OWORD block read",
    [GEN7_DATAPORT_DC_UNALIGNED_OWORD_BLOCK_READ] = "DC unaligned OWORD block read",
    [GEN7_DATAPORT_DC_OWORD_DUAL_BLOCK_READ] = "DC OWORD dual block read",
    [GEN7_DATAPORT_DC_DWORD_SCATTERED_READ] = "DC DWORD scattered read",
    [GEN7_DATAPORT_DC_BYTE_SCATTERED_READ] = "DC byte scattered read",
    [GEN7_DATAPORT_DC_UNTYPED_ATOMIC_OP] = "DC untyped atomic",
    [GEN7_DATAPORT_DC_MEMORY_FENCE] = "DC mfence",
    [GEN7_DATAPORT_DC_OWORD_BLOCK_WRITE] = "DC OWORD block write",
    [GEN7_DATAPORT_DC_OWORD_DUAL_BLOCK_WRITE] = "DC OWORD dual block write",
    [GEN7_DATAPORT_DC_DWORD_SCATTERED_WRITE] = "DC DWORD scatterd write",
    [GEN7_DATAPORT_DC_BYTE_SCATTERED_WRITE] = "DC byte scattered write",
    [GEN7_DATAPORT_DC_UNTYPED_SURFACE_WRITE] = "DC untyped surface write",
};

static const char *const dp_dc1_msg_type_hsw[16] = {
    [HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_READ] = "untyped surface read",
    [HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP] = "DC untyped atomic op",
    [HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP_SIMD4X2] = "DC untyped 4x2 atomic op",
    [HSW_DATAPORT_DC_PORT1_MEDIA_BLOCK_READ] = "DC media block read",
    [HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_READ] = "DC typed surface read",
    [HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP] = "DC typed atomic",
    [HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP_SIMD4X2] = "DC typed 4x2 atomic op",
    [HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_WRITE] = "DC untyped surface write",
    [HSW_DATAPORT_DC_PORT1_MEDIA_BLOCK_WRITE] = "DC media block write",
    [HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP] = "DC atomic counter op",
    [HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP_SIMD4X2] = "DC 4x2 atomic counter op",
    [HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_WRITE] = "DC typed surface write",
};

static const char * const aop[16] = {
   [BRW_AOP_AND] = "and",
   [BRW_AOP_OR] = "or",
   [BRW_AOP_XOR] = "xor",
   [BRW_AOP_MOV] = "mov",
   [BRW_AOP_INC] = "inc",
   [BRW_AOP_DEC] = "dec",
   [BRW_AOP_ADD] = "add",
   [BRW_AOP_SUB] = "sub",
   [BRW_AOP_REVSUB] = "revsub",
   [BRW_AOP_IMAX] = "imax",
   [BRW_AOP_IMIN] = "imin",
   [BRW_AOP_UMAX] = "umax",
   [BRW_AOP_UMIN] = "umin",
   [BRW_AOP_CMPWR] = "cmpwr",
   [BRW_AOP_PREDEC] = "predec",
};

d443 1
a443 1
                    unsigned id, int *space)
d471 14
a484 1
static int reg (FILE *file, unsigned _reg_file, unsigned _reg_nr)
d610 3
a612 2
    err |= control (file, "dest reg encoding", three_source_reg_encoding,
                    inst->bits1.da3src.dst_type, NULL);
d618 1
a618 1
			      unsigned _vert_stride, unsigned _width, unsigned _horiz_stride)
d631 3
a633 3
static int src_da1 (FILE *file, unsigned type, unsigned _reg_file,
		    unsigned _vert_stride, unsigned _width, unsigned _horiz_stride,
		    unsigned reg_num, unsigned sub_reg_num, unsigned __abs, unsigned _negate)
d650 10
a659 10
		    unsigned type,
		    unsigned _reg_file,
		    int _addr_imm,
		    unsigned _addr_subreg_nr,
		    unsigned _negate,
		    unsigned __abs,
		    unsigned _addr_mode,
		    unsigned _horiz_stride,
		    unsigned _width,
		    unsigned _vert_stride)
d677 11
a687 11
		     unsigned _reg_type,
		     unsigned _reg_file,
		     unsigned _vert_stride,
		     unsigned _reg_nr,
		     unsigned _subreg_nr,
		     unsigned __abs,
		     unsigned _negate,
		     unsigned swz_x,
		     unsigned swz_y,
		     unsigned swz_z,
		     unsigned swz_w)
d736 4
a739 4
    unsigned swz_x = (inst->bits2.da3src.src0_swizzle >> 0) & 0x3;
    unsigned swz_y = (inst->bits2.da3src.src0_swizzle >> 2) & 0x3;
    unsigned swz_z = (inst->bits2.da3src.src0_swizzle >> 4) & 0x3;
    unsigned swz_w = (inst->bits2.da3src.src0_swizzle >> 6) & 0x3;
d749 4
a752 6
    if (inst->bits2.da3src.src0_rep_ctrl)
       string (file, "<0,1,0>");
    else
       string (file, "<4,4,1>");
    err |= control (file, "src da16 reg type", three_source_reg_encoding,
                    inst->bits1.da3src.src_type, NULL);
d785 5
a789 5
    unsigned swz_x = (inst->bits2.da3src.src1_swizzle >> 0) & 0x3;
    unsigned swz_y = (inst->bits2.da3src.src1_swizzle >> 2) & 0x3;
    unsigned swz_z = (inst->bits2.da3src.src1_swizzle >> 4) & 0x3;
    unsigned swz_w = (inst->bits2.da3src.src1_swizzle >> 6) & 0x3;
    unsigned src1_subreg_nr = (inst->bits2.da3src.src1_subreg_nr_low |
d802 4
a805 6
    if (inst->bits2.da3src.src1_rep_ctrl)
       string (file, "<0,1,0>");
    else
       string (file, "<4,4,1>");
    err |= control (file, "src da16 reg type", three_source_reg_encoding,
                    inst->bits1.da3src.src_type, NULL);
d839 4
a842 4
    unsigned swz_x = (inst->bits3.da3src.src2_swizzle >> 0) & 0x3;
    unsigned swz_y = (inst->bits3.da3src.src2_swizzle >> 2) & 0x3;
    unsigned swz_z = (inst->bits3.da3src.src2_swizzle >> 4) & 0x3;
    unsigned swz_w = (inst->bits3.da3src.src2_swizzle >> 6) & 0x3;
d854 4
a857 6
    if (inst->bits3.da3src.src2_rep_ctrl)
       string (file, "<0,1,0>");
    else
       string (file, "<4,4,1>");
    err |= control (file, "src da16 reg type", three_source_reg_encoding,
                    inst->bits1.da3src.src_type, NULL);
d887 1
a887 1
static int imm (FILE *file, unsigned type, struct brw_instruction *inst) {
d889 1
a889 1
    case BRW_HW_REG_TYPE_UD:
d892 1
a892 1
    case BRW_HW_REG_TYPE_D:
d895 1
a895 1
    case BRW_HW_REG_TYPE_UW:
d898 1
a898 1
    case BRW_HW_REG_TYPE_W:
d901 2
a902 2
    case BRW_HW_REG_IMM_TYPE_UV:
	format (file, "0x%08xUV", inst->bits3.ud);
d904 1
a904 1
    case BRW_HW_REG_IMM_TYPE_VF:
d907 1
a907 1
    case BRW_HW_REG_IMM_TYPE_V:
d910 1
a910 1
    case BRW_HW_REG_TYPE_F:
d1036 9
d1048 1
a1048 1
    int exec_size = 1 << inst->header.execution_size;
d1315 5
a1319 32
           if (gen >= 7) {
              format (file, " (");

              err |= control (file, "DP DC0 message type",
                              dp_dc0_msg_type_gen7,
                              inst->bits3.gen7_dp.msg_type, &space);

              format (file, ", %d, ", inst->bits3.gen7_dp.binding_table_index);

              switch (inst->bits3.gen7_dp.msg_type) {
              case GEN7_DATAPORT_DC_UNTYPED_ATOMIC_OP:
                 control (file, "atomic op", aop, inst->bits3.ud >> 8 & 0xf,
                          &space);
                 break;
              default:
                 format (file, "%d", inst->bits3.gen7_dp.msg_control);
              }
              format (file, ")");
              break;
           }
           /* FALLTHROUGH */

	case HSW_SFID_DATAPORT_DATA_CACHE_1:
	    if (gen >= 7) {
		format (file, " (");

		err |= control (file, "DP DC1 message type",
				dp_dc1_msg_type_hsw,
				inst->bits3.gen7_dp.msg_type, &space);

		format (file, ", %d, ",
			inst->bits3.gen7_dp.binding_table_index);
a1320 17
                switch (inst->bits3.gen7_dp.msg_type) {
                case HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP:
                case HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP_SIMD4X2:
                case HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP:
                case HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP_SIMD4X2:
                case HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP:
                case HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP_SIMD4X2:
                   control (file, "atomic op", aop,
                            inst->bits3.ud >> 8 & 0xf, &space);
                   break;
                default:
                   format (file, "%d", inst->bits3.gen7_dp.msg_control);
                }
                format (file, ")");
                break;
            }
            /* FALLTHROUGH */
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d30 2
a33 2
#include "brw_reg.h"
#include "brw_inst.h"
d36 219
a254 196
   [BRW_OPCODE_MOV]      = { .name = "mov",     .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_FRC]      = { .name = "frc",     .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_RNDU]     = { .name = "rndu",    .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_RNDD]     = { .name = "rndd",    .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_RNDE]     = { .name = "rnde",    .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_RNDZ]     = { .name = "rndz",    .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_NOT]      = { .name = "not",     .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_LZD]      = { .name = "lzd",     .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_F32TO16]  = { .name = "f32to16", .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_F16TO32]  = { .name = "f16to32", .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_BFREV]    = { .name = "bfrev",   .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_FBH]      = { .name = "fbh",     .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_FBL]      = { .name = "fbl",     .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_CBIT]     = { .name = "cbit",    .nsrc = 1, .ndst = 1 },

   [BRW_OPCODE_MUL]      = { .name = "mul",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_MAC]      = { .name = "mac",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_MACH]     = { .name = "mach",    .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_LINE]     = { .name = "line",    .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_PLN]      = { .name = "pln",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_MAD]      = { .name = "mad",     .nsrc = 3, .ndst = 1 },
   [BRW_OPCODE_LRP]      = { .name = "lrp",     .nsrc = 3, .ndst = 1 },
   [BRW_OPCODE_SAD2]     = { .name = "sad2",    .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_SADA2]    = { .name = "sada2",   .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_DP4]      = { .name = "dp4",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_DPH]      = { .name = "dph",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_DP3]      = { .name = "dp3",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_DP2]      = { .name = "dp2",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_MATH]     = { .name = "math",    .nsrc = 2, .ndst = 1 },

   [BRW_OPCODE_AVG]      = { .name = "avg",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_ADD]      = { .name = "add",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_SEL]      = { .name = "sel",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_AND]      = { .name = "and",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_OR]       = { .name = "or",      .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_XOR]      = { .name = "xor",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_SHR]      = { .name = "shr",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_SHL]      = { .name = "shl",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_ASR]      = { .name = "asr",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_CMP]      = { .name = "cmp",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_CMPN]     = { .name = "cmpn",    .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_CSEL]     = { .name = "csel",    .nsrc = 3, .ndst = 1 },
   [BRW_OPCODE_BFE]      = { .name = "bfe",     .nsrc = 3, .ndst = 1 },
   [BRW_OPCODE_BFI1]     = { .name = "bfi1",    .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_BFI2]     = { .name = "bfi2",    .nsrc = 3, .ndst = 1 },
   [BRW_OPCODE_ADDC]     = { .name = "addc",    .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_SUBB]     = { .name = "subb",    .nsrc = 2, .ndst = 1 },

   [BRW_OPCODE_SEND]     = { .name = "send",    .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_SENDC]    = { .name = "sendc",   .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_NOP]      = { .name = "nop",     .nsrc = 0, .ndst = 0 },
   [BRW_OPCODE_NENOP]    = { .name = "nenop",   .nsrc = 0, .ndst = 0 },
   [BRW_OPCODE_JMPI]     = { .name = "jmpi",    .nsrc = 0, .ndst = 0 },
   [BRW_OPCODE_IF]       = { .name = "if",      .nsrc = 2, .ndst = 0 },
   [BRW_OPCODE_IFF]      = { .name = "iff",     .nsrc = 2, .ndst = 1 },
   [BRW_OPCODE_WHILE]    = { .name = "while",   .nsrc = 2, .ndst = 0 },
   [BRW_OPCODE_ELSE]     = { .name = "else",    .nsrc = 2, .ndst = 0 },
   [BRW_OPCODE_BREAK]    = { .name = "break",   .nsrc = 2, .ndst = 0 },
   [BRW_OPCODE_CONTINUE] = { .name = "cont",    .nsrc = 1, .ndst = 0 },
   [BRW_OPCODE_HALT]     = { .name = "halt",    .nsrc = 1, .ndst = 0 },
   [BRW_OPCODE_MSAVE]    = { .name = "msave",   .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_PUSH]     = { .name = "push",    .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_MRESTORE] = { .name = "mrest",   .nsrc = 1, .ndst = 1 },
   [BRW_OPCODE_POP]      = { .name = "pop",     .nsrc = 2, .ndst = 0 },
   [BRW_OPCODE_WAIT]     = { .name = "wait",    .nsrc = 1, .ndst = 0 },
   [BRW_OPCODE_DO]       = { .name = "do",      .nsrc = 0, .ndst = 0 },
   [BRW_OPCODE_ENDIF]    = { .name = "endif",   .nsrc = 2, .ndst = 0 },
};

static bool
has_jip(struct brw_context *brw, enum opcode opcode)
{
   if (brw->gen < 6)
      return false;

   return opcode == BRW_OPCODE_IF ||
          opcode == BRW_OPCODE_ELSE ||
          opcode == BRW_OPCODE_ENDIF ||
          opcode == BRW_OPCODE_WHILE ||
          opcode == BRW_OPCODE_BREAK ||
          opcode == BRW_OPCODE_CONTINUE ||
          opcode == BRW_OPCODE_HALT;
}

static bool
has_uip(struct brw_context *brw, enum opcode opcode)
{
   if (brw->gen < 6)
      return false;

   return (brw->gen >= 7 && opcode == BRW_OPCODE_IF) ||
          (brw->gen >= 8 && opcode == BRW_OPCODE_ELSE) ||
          opcode == BRW_OPCODE_BREAK ||
          opcode == BRW_OPCODE_CONTINUE ||
          opcode == BRW_OPCODE_HALT;
}

static bool
is_logic_instruction(unsigned opcode)
{
   return opcode == BRW_OPCODE_AND ||
          opcode == BRW_OPCODE_NOT ||
          opcode == BRW_OPCODE_OR ||
          opcode == BRW_OPCODE_XOR;
}

const char *const conditional_modifier[16] = {
   [BRW_CONDITIONAL_NONE] = "",
   [BRW_CONDITIONAL_Z]    = ".z",
   [BRW_CONDITIONAL_NZ]   = ".nz",
   [BRW_CONDITIONAL_G]    = ".g",
   [BRW_CONDITIONAL_GE]   = ".ge",
   [BRW_CONDITIONAL_L]    = ".l",
   [BRW_CONDITIONAL_LE]   = ".le",
   [BRW_CONDITIONAL_R]    = ".r",
   [BRW_CONDITIONAL_O]    = ".o",
   [BRW_CONDITIONAL_U]    = ".u",
};

static const char *const m_negate[2] = {
   [0] = "",
   [1] = "-",
};

static const char *const _abs[2] = {
   [0] = "",
   [1] = "(abs)",
};

static const char *const m_bitnot[2] = { "", "~" };

static const char *const vert_stride[16] = {
   [0] = "0",
   [1] = "1",
   [2] = "2",
   [3] = "4",
   [4] = "8",
   [5] = "16",
   [6] = "32",
   [15] = "VxH",
};

static const char *const width[8] = {
   [0] = "1",
   [1] = "2",
   [2] = "4",
   [3] = "8",
   [4] = "16",
};

static const char *const horiz_stride[4] = {
   [0] = "0",
   [1] = "1",
   [2] = "2",
   [3] = "4"
};

static const char *const chan_sel[4] = {
   [0] = "x",
   [1] = "y",
   [2] = "z",
   [3] = "w",
};

static const char *const debug_ctrl[2] = {
   [0] = "",
   [1] = ".breakpoint"
};

static const char *const saturate[2] = {
   [0] = "",
   [1] = ".sat"
};

static const char *const cmpt_ctrl[2] = {
   [0] = "",
   [1] = "compacted"
};

static const char *const accwr[2] = {
   [0] = "",
   [1] = "AccWrEnable"
};

static const char *const wectrl[2] = {
   [0] = "",
   [1] = "WE_all"
};

static const char *const exec_size[8] = {
   [0] = "1",
   [1] = "2",
   [2] = "4",
   [3] = "8",
   [4] = "16",
   [5] = "32"
d257 1
a257 76
static const char *const pred_inv[2] = {
   [0] = "+",
   [1] = "-"
};

static const char *const pred_ctrl_align16[16] = {
   [1] = "",
   [2] = ".x",
   [3] = ".y",
   [4] = ".z",
   [5] = ".w",
   [6] = ".any4h",
   [7] = ".all4h",
};

static const char *const pred_ctrl_align1[16] = {
   [BRW_PREDICATE_NORMAL]        = "",
   [BRW_PREDICATE_ALIGN1_ANYV]   = ".anyv",
   [BRW_PREDICATE_ALIGN1_ALLV]   = ".allv",
   [BRW_PREDICATE_ALIGN1_ANY2H]  = ".any2h",
   [BRW_PREDICATE_ALIGN1_ALL2H]  = ".all2h",
   [BRW_PREDICATE_ALIGN1_ANY4H]  = ".any4h",
   [BRW_PREDICATE_ALIGN1_ALL4H]  = ".all4h",
   [BRW_PREDICATE_ALIGN1_ANY8H]  = ".any8h",
   [BRW_PREDICATE_ALIGN1_ALL8H]  = ".all8h",
   [BRW_PREDICATE_ALIGN1_ANY16H] = ".any16h",
   [BRW_PREDICATE_ALIGN1_ALL16H] = ".all16h",
   [BRW_PREDICATE_ALIGN1_ANY32H] = ".any32h",
   [BRW_PREDICATE_ALIGN1_ANY32H] = ".all32h",
};

static const char *const thread_ctrl[4] = {
   [BRW_THREAD_NORMAL] = "",
   [BRW_THREAD_ATOMIC] = "atomic",
   [BRW_THREAD_SWITCH] = "switch",
};

static const char *const compr_ctrl[4] = {
   [0] = "",
   [1] = "sechalf",
   [2] = "compr",
   [3] = "compr4",
};

static const char *const dep_ctrl[4] = {
   [0] = "",
   [1] = "NoDDClr",
   [2] = "NoDDChk",
   [3] = "NoDDClr,NoDDChk",
};

static const char *const mask_ctrl[4] = {
   [0] = "",
   [1] = "nomask",
};

static const char *const access_mode[2] = {
   [0] = "align1",
   [1] = "align16",
};

static const char * const reg_encoding[] = {
   [BRW_HW_REG_TYPE_UD]          = "UD",
   [BRW_HW_REG_TYPE_D]           = "D",
   [BRW_HW_REG_TYPE_UW]          = "UW",
   [BRW_HW_REG_TYPE_W]           = "W",
   [BRW_HW_REG_NON_IMM_TYPE_UB]  = "UB",
   [BRW_HW_REG_NON_IMM_TYPE_B]   = "B",
   [GEN7_HW_REG_NON_IMM_TYPE_DF] = "DF",
   [BRW_HW_REG_TYPE_F]           = "F",
   [GEN8_HW_REG_TYPE_UQ]         = "UQ",
   [GEN8_HW_REG_TYPE_Q]          = "Q",
   [GEN8_HW_REG_NON_IMM_TYPE_HF] = "HF",
};

static const char *const three_source_reg_encoding[] = {
d263 84
a346 113
const int reg_type_size[] = {
   [BRW_HW_REG_TYPE_UD]          = 4,
   [BRW_HW_REG_TYPE_D]           = 4,
   [BRW_HW_REG_TYPE_UW]          = 2,
   [BRW_HW_REG_TYPE_W]           = 2,
   [BRW_HW_REG_NON_IMM_TYPE_UB]  = 1,
   [BRW_HW_REG_NON_IMM_TYPE_B]   = 1,
   [GEN7_HW_REG_NON_IMM_TYPE_DF] = 8,
   [BRW_HW_REG_TYPE_F]           = 4,
   [GEN8_HW_REG_TYPE_UQ]         = 8,
   [GEN8_HW_REG_TYPE_Q]          = 8,
   [GEN8_HW_REG_NON_IMM_TYPE_HF] = 2,
};

static const char *const reg_file[4] = {
   [0] = "A",
   [1] = "g",
   [2] = "m",
   [3] = "imm",
};

static const char *const writemask[16] = {
   [0x0] = ".",
   [0x1] = ".x",
   [0x2] = ".y",
   [0x3] = ".xy",
   [0x4] = ".z",
   [0x5] = ".xz",
   [0x6] = ".yz",
   [0x7] = ".xyz",
   [0x8] = ".w",
   [0x9] = ".xw",
   [0xa] = ".yw",
   [0xb] = ".xyw",
   [0xc] = ".zw",
   [0xd] = ".xzw",
   [0xe] = ".yzw",
   [0xf] = "",
};

static const char *const end_of_thread[2] = {
   [0] = "",
   [1] = "EOT"
};

/* SFIDs on Gen4-5 */
static const char *const gen4_sfid[16] = {
   [BRW_SFID_NULL]            = "null",
   [BRW_SFID_MATH]            = "math",
   [BRW_SFID_SAMPLER]         = "sampler",
   [BRW_SFID_MESSAGE_GATEWAY] = "gateway",
   [BRW_SFID_DATAPORT_READ]   = "read",
   [BRW_SFID_DATAPORT_WRITE]  = "write",
   [BRW_SFID_URB]             = "urb",
   [BRW_SFID_THREAD_SPAWNER]  = "thread_spawner",
   [BRW_SFID_VME]             = "vme",
};

static const char *const gen6_sfid[16] = {
   [BRW_SFID_NULL]                     = "null",
   [BRW_SFID_MATH]                     = "math",
   [BRW_SFID_SAMPLER]                  = "sampler",
   [BRW_SFID_MESSAGE_GATEWAY]          = "gateway",
   [BRW_SFID_URB]                      = "urb",
   [BRW_SFID_THREAD_SPAWNER]           = "thread_spawner",
   [GEN6_SFID_DATAPORT_SAMPLER_CACHE]  = "sampler",
   [GEN6_SFID_DATAPORT_RENDER_CACHE]   = "render",
   [GEN6_SFID_DATAPORT_CONSTANT_CACHE] = "const",
   [GEN7_SFID_DATAPORT_DATA_CACHE]     = "data",
   [GEN7_SFID_PIXEL_INTERPOLATOR]      = "pixel interp",
   [HSW_SFID_DATAPORT_DATA_CACHE_1]    = "dp data 1",
   [HSW_SFID_CRE]                      = "cre",
};

static const char *const dp_write_port_msg_type[8] = {
   [0b000] = "OWord block write",
   [0b001] = "OWord dual block write",
   [0b010] = "media block write",
   [0b011] = "DWord scattered write",
   [0b100] = "RT write",
   [0b101] = "streamed VB write",
   [0b110] = "RT UNORM write", /* G45+ */
   [0b111] = "flush render cache",
};

static const char *const dp_rc_msg_type_gen6[16] = {
   [BRW_DATAPORT_READ_MESSAGE_OWORD_BLOCK_READ] = "OWORD block read",
   [GEN6_DATAPORT_READ_MESSAGE_RENDER_UNORM_READ] = "RT UNORM read",
   [GEN6_DATAPORT_READ_MESSAGE_OWORD_DUAL_BLOCK_READ] = "OWORD dual block read",
   [GEN6_DATAPORT_READ_MESSAGE_MEDIA_BLOCK_READ] = "media block read",
   [GEN6_DATAPORT_READ_MESSAGE_OWORD_UNALIGN_BLOCK_READ] =
      "OWORD unaligned block read",
   [GEN6_DATAPORT_READ_MESSAGE_DWORD_SCATTERED_READ] = "DWORD scattered read",
   [GEN6_DATAPORT_WRITE_MESSAGE_DWORD_ATOMIC_WRITE] = "DWORD atomic write",
   [GEN6_DATAPORT_WRITE_MESSAGE_OWORD_BLOCK_WRITE] = "OWORD block write",
   [GEN6_DATAPORT_WRITE_MESSAGE_OWORD_DUAL_BLOCK_WRITE] =
      "OWORD dual block write",
   [GEN6_DATAPORT_WRITE_MESSAGE_MEDIA_BLOCK_WRITE] = "media block write",
   [GEN6_DATAPORT_WRITE_MESSAGE_DWORD_SCATTERED_WRITE] =
      "DWORD scattered write",
   [GEN6_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_WRITE] = "RT write",
   [GEN6_DATAPORT_WRITE_MESSAGE_STREAMED_VB_WRITE] = "streamed VB write",
   [GEN6_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_UNORM_WRITE] = "RT UNORM write",
};

static const char *const m_rt_write_subtype[] = {
   [0b000] = "SIMD16",
   [0b001] = "SIMD16/RepData",
   [0b010] = "SIMD8/DualSrcLow",
   [0b011] = "SIMD8/DualSrcHigh",
   [0b100] = "SIMD8",
   [0b101] = "SIMD8/ImageWrite",   /* Gen6+ */
   [0b111] = "SIMD16/RepData-111", /* no idea how this is different than 1 */
d350 12
a361 14
   [GEN7_DATAPORT_DC_OWORD_BLOCK_READ] = "DC OWORD block read",
   [GEN7_DATAPORT_DC_UNALIGNED_OWORD_BLOCK_READ] =
      "DC unaligned OWORD block read",
   [GEN7_DATAPORT_DC_OWORD_DUAL_BLOCK_READ] = "DC OWORD dual block read",
   [GEN7_DATAPORT_DC_DWORD_SCATTERED_READ] = "DC DWORD scattered read",
   [GEN7_DATAPORT_DC_BYTE_SCATTERED_READ] = "DC byte scattered read",
   [GEN7_DATAPORT_DC_UNTYPED_SURFACE_READ] = "DC untyped surface read",
   [GEN7_DATAPORT_DC_UNTYPED_ATOMIC_OP] = "DC untyped atomic",
   [GEN7_DATAPORT_DC_MEMORY_FENCE] = "DC mfence",
   [GEN7_DATAPORT_DC_OWORD_BLOCK_WRITE] = "DC OWORD block write",
   [GEN7_DATAPORT_DC_OWORD_DUAL_BLOCK_WRITE] = "DC OWORD dual block write",
   [GEN7_DATAPORT_DC_DWORD_SCATTERED_WRITE] = "DC DWORD scatterd write",
   [GEN7_DATAPORT_DC_BYTE_SCATTERED_WRITE] = "DC byte scattered write",
   [GEN7_DATAPORT_DC_UNTYPED_SURFACE_WRITE] = "DC untyped surface write",
d365 23
a387 25
   [HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_READ] = "untyped surface read",
   [HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP] = "DC untyped atomic op",
   [HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP_SIMD4X2] =
      "DC untyped 4x2 atomic op",
   [HSW_DATAPORT_DC_PORT1_MEDIA_BLOCK_READ] = "DC media block read",
   [HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_READ] = "DC typed surface read",
   [HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP] = "DC typed atomic",
   [HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP_SIMD4X2] = "DC typed 4x2 atomic op",
   [HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_WRITE] = "DC untyped surface write",
   [HSW_DATAPORT_DC_PORT1_MEDIA_BLOCK_WRITE] = "DC media block write",
   [HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP] = "DC atomic counter op",
   [HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP_SIMD4X2] =
      "DC 4x2 atomic counter op",
   [HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_WRITE] = "DC typed surface write",
};

static const char *const aop[16] = {
   [BRW_AOP_AND]    = "and",
   [BRW_AOP_OR]     = "or",
   [BRW_AOP_XOR]    = "xor",
   [BRW_AOP_MOV]    = "mov",
   [BRW_AOP_INC]    = "inc",
   [BRW_AOP_DEC]    = "dec",
   [BRW_AOP_ADD]    = "add",
   [BRW_AOP_SUB]    = "sub",
d389 5
a393 5
   [BRW_AOP_IMAX]   = "imax",
   [BRW_AOP_IMIN]   = "imin",
   [BRW_AOP_UMAX]   = "umax",
   [BRW_AOP_UMIN]   = "umin",
   [BRW_AOP_CMPWR]  = "cmpwr",
d397 14
a410 28
static const char * const pixel_interpolator_msg_types[4] = {
    [GEN7_PIXEL_INTERPOLATOR_LOC_SHARED_OFFSET] = "per_message_offset",
    [GEN7_PIXEL_INTERPOLATOR_LOC_SAMPLE] = "sample_position",
    [GEN7_PIXEL_INTERPOLATOR_LOC_CENTROID] = "centroid",
    [GEN7_PIXEL_INTERPOLATOR_LOC_PER_SLOT_OFFSET] = "per_slot_offset",
};

static const char *const math_function[16] = {
   [BRW_MATH_FUNCTION_INV]    = "inv",
   [BRW_MATH_FUNCTION_LOG]    = "log",
   [BRW_MATH_FUNCTION_EXP]    = "exp",
   [BRW_MATH_FUNCTION_SQRT]   = "sqrt",
   [BRW_MATH_FUNCTION_RSQ]    = "rsq",
   [BRW_MATH_FUNCTION_SIN]    = "sin",
   [BRW_MATH_FUNCTION_COS]    = "cos",
   [BRW_MATH_FUNCTION_SINCOS] = "sincos",
   [BRW_MATH_FUNCTION_FDIV]   = "fdiv",
   [BRW_MATH_FUNCTION_POW]    = "pow",
   [BRW_MATH_FUNCTION_INT_DIV_QUOTIENT_AND_REMAINDER] = "intdivmod",
   [BRW_MATH_FUNCTION_INT_DIV_QUOTIENT]  = "intdiv",
   [BRW_MATH_FUNCTION_INT_DIV_REMAINDER] = "intmod",
   [GEN8_MATH_FUNCTION_INVM]  = "invm",
   [GEN8_MATH_FUNCTION_RSQRTM] = "rsqrtm",
};

static const char *const math_saturate[2] = {
   [0] = "",
   [1] = "sat"
d413 3
a415 3
static const char *const math_signed[2] = {
   [0] = "",
   [1] = "signed"
d418 3
a420 3
static const char *const math_scalar[2] = {
   [0] = "",
   [1] = "scalar"
d423 3
a425 3
static const char *const math_precision[2] = {
   [0] = "",
   [1] = "partial_precision"
d428 3
a430 3
static const char *const gen5_urb_opcode[] = {
   [0] = "urb_write",
   [1] = "ff_sync",
d433 3
a435 11
static const char *const gen7_urb_opcode[] = {
   [0] = "write HWord",
   [1] = "write OWord",
   [2] = "read HWord",
   [3] = "read OWord",
   [4] = "atomic mov",  /* Gen7+ */
   [5] = "atomic inc",  /* Gen7+ */
   [6] = "atomic add",  /* Gen8+ */
   [7] = "SIMD8 write", /* Gen8+ */
   [8] = "SIMD8 read",  /* Gen8+ */
   /* [9-15] - reserved */
d438 4
a441 4
static const char *const urb_swizzle[4] = {
   [BRW_URB_SWIZZLE_NONE]       = "",
   [BRW_URB_SWIZZLE_INTERLEAVE] = "interleave",
   [BRW_URB_SWIZZLE_TRANSPOSE]  = "transpose",
d444 3
a446 3
static const char *const urb_allocate[2] = {
   [0] = "",
   [1] = "allocate"
d449 3
a451 3
static const char *const urb_used[2] = {
   [0] = "",
   [1] = "used"
d454 3
a456 3
static const char *const urb_complete[2] = {
   [0] = "",
   [1] = "complete"
d459 4
a462 4
static const char *const sampler_target_format[4] = {
   [0] = "F",
   [2] = "UD",
   [3] = "D"
d468 1
a468 10
static int
string(FILE *file, const char *string)
{
   fputs(string, file);
   column += strlen(string);
   return 0;
}

static int
format(FILE *f, const char *format, ...)
d470 890
a1359 55
   char buf[1024];
   va_list args;
   va_start(args, format);

   vsnprintf(buf, sizeof(buf) - 1, format, args);
   va_end(args);
   string(f, buf);
   return 0;
}

static int
newline(FILE *f)
{
   putc('\n', f);
   column = 0;
   return 0;
}

static int
pad(FILE *f, int c)
{
   do
      string(f, " ");
   while (column < c);
   return 0;
}

static int
control(FILE *file, const char *name, const char *const ctrl[],
        unsigned id, int *space)
{
   if (!ctrl[id]) {
      fprintf(file, "*** invalid %s value %d ", name, id);
      return 1;
   }
   if (ctrl[id][0]) {
      if (space && *space)
         string(file, " ");
      string(file, ctrl[id]);
      if (space)
         *space = 1;
   }
   return 0;
}

static int
print_opcode(FILE *file, int id)
{
   if (!opcode_descs[id].name) {
      format(file, "*** invalid opcode value %d ", id);
      return 1;
   }
   string(file, opcode_descs[id].name);
   return 0;
}
d1361 1
a1361 790
static int
reg(FILE *file, unsigned _reg_file, unsigned _reg_nr)
{
   int err = 0;

   /* Clear the Compr4 instruction compression bit. */
   if (_reg_file == BRW_MESSAGE_REGISTER_FILE)
      _reg_nr &= ~(1 << 7);

   if (_reg_file == BRW_ARCHITECTURE_REGISTER_FILE) {
      switch (_reg_nr & 0xf0) {
      case BRW_ARF_NULL:
         string(file, "null");
         return -1;
      case BRW_ARF_ADDRESS:
         format(file, "a%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_ACCUMULATOR:
         format(file, "acc%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_FLAG:
         format(file, "f%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_MASK:
         format(file, "mask%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_MASK_STACK:
         format(file, "msd%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_STATE:
         format(file, "sr%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_CONTROL:
         format(file, "cr%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_NOTIFICATION_COUNT:
         format(file, "n%d", _reg_nr & 0x0f);
         break;
      case BRW_ARF_IP:
         string(file, "ip");
         return -1;
         break;
      default:
         format(file, "ARF%d", _reg_nr);
         break;
      }
   } else {
      err |= control(file, "src reg file", reg_file, _reg_file, NULL);
      format(file, "%d", _reg_nr);
   }
   return err;
}

static int
dest(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   int err = 0;

   if (brw_inst_access_mode(brw, inst) == BRW_ALIGN_1) {
      if (brw_inst_dst_address_mode(brw, inst) == BRW_ADDRESS_DIRECT) {
         err |= reg(file, brw_inst_dst_reg_file(brw, inst),
                    brw_inst_dst_da_reg_nr(brw, inst));
         if (err == -1)
            return 0;
         if (brw_inst_dst_da1_subreg_nr(brw, inst))
            format(file, ".%d", brw_inst_dst_da1_subreg_nr(brw, inst) /
                   reg_type_size[brw_inst_dst_reg_type(brw, inst)]);
         string(file, "<");
         err |= control(file, "horiz stride", horiz_stride,
                        brw_inst_dst_hstride(brw, inst), NULL);
         string(file, ">");
         err |= control(file, "dest reg encoding", reg_encoding,
                        brw_inst_dst_reg_type(brw, inst), NULL);
      } else {
         string(file, "g[a0");
         if (brw_inst_dst_ia_subreg_nr(brw, inst))
            format(file, ".%d", brw_inst_dst_ia_subreg_nr(brw, inst) /
                   reg_type_size[brw_inst_dst_reg_type(brw, inst)]);
         if (brw_inst_dst_ia1_addr_imm(brw, inst))
            format(file, " %d", brw_inst_dst_ia1_addr_imm(brw, inst));
         string(file, "]<");
         err |= control(file, "horiz stride", horiz_stride,
                        brw_inst_dst_hstride(brw, inst), NULL);
         string(file, ">");
         err |= control(file, "dest reg encoding", reg_encoding,
                        brw_inst_dst_reg_type(brw, inst), NULL);
      }
   } else {
      if (brw_inst_dst_address_mode(brw, inst) == BRW_ADDRESS_DIRECT) {
         err |= reg(file, brw_inst_dst_reg_file(brw, inst),
                    brw_inst_dst_da_reg_nr(brw, inst));
         if (err == -1)
            return 0;
         if (brw_inst_dst_da16_subreg_nr(brw, inst))
            format(file, ".%d", brw_inst_dst_da16_subreg_nr(brw, inst) /
                   reg_type_size[brw_inst_dst_reg_type(brw, inst)]);
         string(file, "<1>");
         err |= control(file, "writemask", writemask,
                        brw_inst_da16_writemask(brw, inst), NULL);
         err |= control(file, "dest reg encoding", reg_encoding,
                        brw_inst_dst_reg_type(brw, inst), NULL);
      } else {
         err = 1;
         string(file, "Indirect align16 address mode not supported");
      }
   }

   return 0;
}

static int
dest_3src(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   int err = 0;
   uint32_t reg_file;

   if (brw->gen == 6 && brw_inst_3src_dst_reg_file(brw, inst))
      reg_file = BRW_MESSAGE_REGISTER_FILE;
   else
      reg_file = BRW_GENERAL_REGISTER_FILE;

   err |= reg(file, reg_file, brw_inst_3src_dst_reg_nr(brw, inst));
   if (err == -1)
      return 0;
   if (brw_inst_3src_dst_subreg_nr(brw, inst))
      format(file, ".%d", brw_inst_3src_dst_subreg_nr(brw, inst));
   string(file, "<1>");
   err |= control(file, "writemask", writemask,
                  brw_inst_3src_dst_writemask(brw, inst), NULL);
   err |= control(file, "dest reg encoding", three_source_reg_encoding,
                  brw_inst_3src_dst_type(brw, inst), NULL);

   return 0;
}

static int
src_align1_region(FILE *file,
                  unsigned _vert_stride, unsigned _width,
                  unsigned _horiz_stride)
{
   int err = 0;
   string(file, "<");
   err |= control(file, "vert stride", vert_stride, _vert_stride, NULL);
   string(file, ",");
   err |= control(file, "width", width, _width, NULL);
   string(file, ",");
   err |= control(file, "horiz_stride", horiz_stride, _horiz_stride, NULL);
   string(file, ">");
   return err;
}

static int
src_da1(FILE *file,
        const struct brw_context *brw,
        unsigned opcode,
        unsigned type, unsigned _reg_file,
        unsigned _vert_stride, unsigned _width, unsigned _horiz_stride,
        unsigned reg_num, unsigned sub_reg_num, unsigned __abs,
        unsigned _negate)
{
   int err = 0;

   if (brw->gen >= 8 && is_logic_instruction(opcode))
      err |= control(file, "bitnot", m_bitnot, _negate, NULL);
   else
      err |= control(file, "negate", m_negate, _negate, NULL);

   err |= control(file, "abs", _abs, __abs, NULL);

   err |= reg(file, _reg_file, reg_num);
   if (err == -1)
      return 0;
   if (sub_reg_num)
      format(file, ".%d", sub_reg_num / reg_type_size[type]);   /* use formal style like spec */
   src_align1_region(file, _vert_stride, _width, _horiz_stride);
   err |= control(file, "src reg encoding", reg_encoding, type, NULL);
   return err;
}

static int
src_ia1(FILE *file,
        const struct brw_context *brw,
        unsigned opcode,
        unsigned type,
        unsigned _reg_file,
        int _addr_imm,
        unsigned _addr_subreg_nr,
        unsigned _negate,
        unsigned __abs,
        unsigned _addr_mode,
        unsigned _horiz_stride, unsigned _width, unsigned _vert_stride)
{
   int err = 0;

   if (brw->gen >= 8 && is_logic_instruction(opcode))
      err |= control(file, "bitnot", m_bitnot, _negate, NULL);
   else
      err |= control(file, "negate", m_negate, _negate, NULL);

   err |= control(file, "abs", _abs, __abs, NULL);

   string(file, "g[a0");
   if (_addr_subreg_nr)
      format(file, ".%d", _addr_subreg_nr);
   if (_addr_imm)
      format(file, " %d", _addr_imm);
   string(file, "]");
   src_align1_region(file, _vert_stride, _width, _horiz_stride);
   err |= control(file, "src reg encoding", reg_encoding, type, NULL);
   return err;
}

static int
src_swizzle(FILE *file, unsigned swiz)
{
   unsigned x = BRW_GET_SWZ(swiz, BRW_CHANNEL_X);
   unsigned y = BRW_GET_SWZ(swiz, BRW_CHANNEL_Y);
   unsigned z = BRW_GET_SWZ(swiz, BRW_CHANNEL_Z);
   unsigned w = BRW_GET_SWZ(swiz, BRW_CHANNEL_W);
   int err = 0;

   if (x == y && x == z && x == w) {
      string(file, ".");
      err |= control(file, "channel select", chan_sel, x, NULL);
   } else if (swiz != BRW_SWIZZLE_XYZW) {
      string(file, ".");
      err |= control(file, "channel select", chan_sel, x, NULL);
      err |= control(file, "channel select", chan_sel, y, NULL);
      err |= control(file, "channel select", chan_sel, z, NULL);
      err |= control(file, "channel select", chan_sel, w, NULL);
   }
   return err;
}

static int
src_da16(FILE *file,
         const struct brw_context *brw,
         unsigned opcode,
         unsigned _reg_type,
         unsigned _reg_file,
         unsigned _vert_stride,
         unsigned _reg_nr,
         unsigned _subreg_nr,
         unsigned __abs,
         unsigned _negate,
         unsigned swz_x, unsigned swz_y, unsigned swz_z, unsigned swz_w)
{
   int err = 0;

   if (brw->gen >= 8 && is_logic_instruction(opcode))
      err |= control(file, "bitnot", m_bitnot, _negate, NULL);
   else
      err |= control(file, "negate", m_negate, _negate, NULL);

   err |= control(file, "abs", _abs, __abs, NULL);

   err |= reg(file, _reg_file, _reg_nr);
   if (err == -1)
      return 0;
   if (_subreg_nr)
      /* bit4 for subreg number byte addressing. Make this same meaning as
         in da1 case, so output looks consistent. */
      format(file, ".%d", 16 / reg_type_size[_reg_type]);
   string(file, "<");
   err |= control(file, "vert stride", vert_stride, _vert_stride, NULL);
   string(file, ",4,1>");
   err |= src_swizzle(file, BRW_SWIZZLE4(swz_x, swz_y, swz_z, swz_w));
   err |= control(file, "src da16 reg type", reg_encoding, _reg_type, NULL);
   return err;
}

static int
src0_3src(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   int err = 0;
   unsigned src0_subreg_nr = brw_inst_3src_src0_subreg_nr(brw, inst);

   err |= control(file, "negate", m_negate,
                  brw_inst_3src_src0_negate(brw, inst), NULL);
   err |= control(file, "abs", _abs, brw_inst_3src_src0_abs(brw, inst), NULL);

   err |= reg(file, BRW_GENERAL_REGISTER_FILE,
              brw_inst_3src_src0_reg_nr(brw, inst));
   if (err == -1)
      return 0;
   if (src0_subreg_nr)
      format(file, ".%d", src0_subreg_nr);
   if (brw_inst_3src_src0_rep_ctrl(brw, inst))
      string(file, "<0,1,0>");
   else
      string(file, "<4,4,1>");
   err |= control(file, "src da16 reg type", three_source_reg_encoding,
                  brw_inst_3src_src_type(brw, inst), NULL);
   err |= src_swizzle(file, brw_inst_3src_src0_swizzle(brw, inst));
   return err;
}

static int
src1_3src(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   int err = 0;
   unsigned src1_subreg_nr = brw_inst_3src_src1_subreg_nr(brw, inst);

   err |= control(file, "negate", m_negate,
                  brw_inst_3src_src1_negate(brw, inst), NULL);
   err |= control(file, "abs", _abs, brw_inst_3src_src1_abs(brw, inst), NULL);

   err |= reg(file, BRW_GENERAL_REGISTER_FILE,
              brw_inst_3src_src1_reg_nr(brw, inst));
   if (err == -1)
      return 0;
   if (src1_subreg_nr)
      format(file, ".%d", src1_subreg_nr);
   if (brw_inst_3src_src1_rep_ctrl(brw, inst))
      string(file, "<0,1,0>");
   else
      string(file, "<4,4,1>");
   err |= control(file, "src da16 reg type", three_source_reg_encoding,
                  brw_inst_3src_src_type(brw, inst), NULL);
   err |= src_swizzle(file, brw_inst_3src_src1_swizzle(brw, inst));
   return err;
}


static int
src2_3src(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   int err = 0;
   unsigned src2_subreg_nr = brw_inst_3src_src2_subreg_nr(brw, inst);

   err |= control(file, "negate", m_negate,
                  brw_inst_3src_src2_negate(brw, inst), NULL);
   err |= control(file, "abs", _abs, brw_inst_3src_src2_abs(brw, inst), NULL);

   err |= reg(file, BRW_GENERAL_REGISTER_FILE,
              brw_inst_3src_src2_reg_nr(brw, inst));
   if (err == -1)
      return 0;
   if (src2_subreg_nr)
      format(file, ".%d", src2_subreg_nr);
   if (brw_inst_3src_src2_rep_ctrl(brw, inst))
      string(file, "<0,1,0>");
   else
      string(file, "<4,4,1>");
   err |= control(file, "src da16 reg type", three_source_reg_encoding,
                  brw_inst_3src_src_type(brw, inst), NULL);
   err |= src_swizzle(file, brw_inst_3src_src2_swizzle(brw, inst));
   return err;
}

static int
imm(FILE *file, struct brw_context *brw, unsigned type, brw_inst *inst)
{
   switch (type) {
   case BRW_HW_REG_TYPE_UD:
      format(file, "0x%08xUD", brw_inst_imm_ud(brw, inst));
      break;
   case BRW_HW_REG_TYPE_D:
      format(file, "%dD", brw_inst_imm_d(brw, inst));
      break;
   case BRW_HW_REG_TYPE_UW:
      format(file, "0x%04xUW", (uint16_t) brw_inst_imm_ud(brw, inst));
      break;
   case BRW_HW_REG_TYPE_W:
      format(file, "%dW", (int16_t) brw_inst_imm_d(brw, inst));
      break;
   case BRW_HW_REG_IMM_TYPE_UV:
      format(file, "0x%08xUV", brw_inst_imm_ud(brw, inst));
      break;
   case BRW_HW_REG_IMM_TYPE_VF:
      format(file, "Vector Float");
      break;
   case BRW_HW_REG_IMM_TYPE_V:
      format(file, "0x%08xV", brw_inst_imm_ud(brw, inst));
      break;
   case BRW_HW_REG_TYPE_F:
      format(file, "%-gF", brw_inst_imm_f(brw, inst));
      break;
   case GEN8_HW_REG_IMM_TYPE_DF:
      string(file, "Double IMM");
      break;
   case GEN8_HW_REG_IMM_TYPE_HF:
      string(file, "Half Float IMM");
      break;
   }
   return 0;
}

static int
src0(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   if (brw_inst_src0_reg_file(brw, inst) == BRW_IMMEDIATE_VALUE) {
      return imm(file, brw, brw_inst_src0_reg_type(brw, inst), inst);
   } else if (brw_inst_access_mode(brw, inst) == BRW_ALIGN_1) {
      if (brw_inst_src0_address_mode(brw, inst) == BRW_ADDRESS_DIRECT) {
         return src_da1(file,
                        brw,
                        brw_inst_opcode(brw, inst),
                        brw_inst_src0_reg_type(brw, inst),
                        brw_inst_src0_reg_file(brw, inst),
                        brw_inst_src0_vstride(brw, inst),
                        brw_inst_src0_width(brw, inst),
                        brw_inst_src0_hstride(brw, inst),
                        brw_inst_src0_da_reg_nr(brw, inst),
                        brw_inst_src0_da1_subreg_nr(brw, inst),
                        brw_inst_src0_abs(brw, inst),
                        brw_inst_src0_negate(brw, inst));
      } else {
         return src_ia1(file,
                        brw,
                        brw_inst_opcode(brw, inst),
                        brw_inst_src0_reg_type(brw, inst),
                        brw_inst_src0_reg_file(brw, inst),
                        brw_inst_src0_ia1_addr_imm(brw, inst),
                        brw_inst_src0_ia_subreg_nr(brw, inst),
                        brw_inst_src0_negate(brw, inst),
                        brw_inst_src0_abs(brw, inst),
                        brw_inst_src0_address_mode(brw, inst),
                        brw_inst_src0_hstride(brw, inst),
                        brw_inst_src0_width(brw, inst),
                        brw_inst_src0_vstride(brw, inst));
      }
   } else {
      if (brw_inst_src0_address_mode(brw, inst) == BRW_ADDRESS_DIRECT) {
         return src_da16(file,
                         brw,
                         brw_inst_opcode(brw, inst),
                         brw_inst_src0_reg_type(brw, inst),
                         brw_inst_src0_reg_file(brw, inst),
                         brw_inst_src0_vstride(brw, inst),
                         brw_inst_src0_da_reg_nr(brw, inst),
                         brw_inst_src0_da16_subreg_nr(brw, inst),
                         brw_inst_src0_abs(brw, inst),
                         brw_inst_src0_negate(brw, inst),
                         brw_inst_src0_da16_swiz_x(brw, inst),
                         brw_inst_src0_da16_swiz_y(brw, inst),
                         brw_inst_src0_da16_swiz_z(brw, inst),
                         brw_inst_src0_da16_swiz_w(brw, inst));
      } else {
         string(file, "Indirect align16 address mode not supported");
         return 1;
      }
   }
}

static int
src1(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   if (brw_inst_src1_reg_file(brw, inst) == BRW_IMMEDIATE_VALUE) {
      return imm(file, brw, brw_inst_src1_reg_type(brw, inst), inst);
   } else if (brw_inst_access_mode(brw, inst) == BRW_ALIGN_1) {
      if (brw_inst_src1_address_mode(brw, inst) == BRW_ADDRESS_DIRECT) {
         return src_da1(file,
                        brw,
                        brw_inst_opcode(brw, inst),
                        brw_inst_src1_reg_type(brw, inst),
                        brw_inst_src1_reg_file(brw, inst),
                        brw_inst_src1_vstride(brw, inst),
                        brw_inst_src1_width(brw, inst),
                        brw_inst_src1_hstride(brw, inst),
                        brw_inst_src1_da_reg_nr(brw, inst),
                        brw_inst_src1_da1_subreg_nr(brw, inst),
                        brw_inst_src1_abs(brw, inst),
                        brw_inst_src1_negate(brw, inst));
      } else {
         return src_ia1(file,
                        brw,
                        brw_inst_opcode(brw, inst),
                        brw_inst_src1_reg_type(brw, inst),
                        brw_inst_src1_reg_file(brw, inst),
                        brw_inst_src1_ia1_addr_imm(brw, inst),
                        brw_inst_src1_ia_subreg_nr(brw, inst),
                        brw_inst_src1_negate(brw, inst),
                        brw_inst_src1_abs(brw, inst),
                        brw_inst_src1_address_mode(brw, inst),
                        brw_inst_src1_hstride(brw, inst),
                        brw_inst_src1_width(brw, inst),
                        brw_inst_src1_vstride(brw, inst));
      }
   } else {
      if (brw_inst_src1_address_mode(brw, inst) == BRW_ADDRESS_DIRECT) {
         return src_da16(file,
                         brw,
                         brw_inst_opcode(brw, inst),
                         brw_inst_src1_reg_type(brw, inst),
                         brw_inst_src1_reg_file(brw, inst),
                         brw_inst_src1_vstride(brw, inst),
                         brw_inst_src1_da_reg_nr(brw, inst),
                         brw_inst_src1_da16_subreg_nr(brw, inst),
                         brw_inst_src1_abs(brw, inst),
                         brw_inst_src1_negate(brw, inst),
                         brw_inst_src1_da16_swiz_x(brw, inst),
                         brw_inst_src1_da16_swiz_y(brw, inst),
                         brw_inst_src1_da16_swiz_z(brw, inst),
                         brw_inst_src1_da16_swiz_w(brw, inst));
      } else {
         string(file, "Indirect align16 address mode not supported");
         return 1;
      }
   }
}

static int
qtr_ctrl(FILE *file, struct brw_context *brw, brw_inst *inst)
{
   int qtr_ctl = brw_inst_qtr_control(brw, inst);
   int exec_size = 1 << brw_inst_exec_size(brw, inst);

   if (exec_size == 8) {
      switch (qtr_ctl) {
      case 0:
         string(file, " 1Q");
         break;
      case 1:
         string(file, " 2Q");
         break;
      case 2:
         string(file, " 3Q");
         break;
      case 3:
         string(file, " 4Q");
         break;
      }
   } else if (exec_size == 16) {
      if (qtr_ctl < 2)
         string(file, " 1H");
      else
         string(file, " 2H");
   }
   return 0;
}

int
brw_disassemble_inst(FILE *file, struct brw_context *brw, brw_inst *inst,
                     bool is_compacted)
{
   int err = 0;
   int space = 0;

   const enum opcode opcode = brw_inst_opcode(brw, inst);

   if (brw_inst_pred_control(brw, inst)) {
      string(file, "(");
      err |= control(file, "predicate inverse", pred_inv,
                     brw_inst_pred_inv(brw, inst), NULL);
      format(file, "f%d", brw->gen >= 7 ? brw_inst_flag_reg_nr(brw, inst) : 0);
      if (brw_inst_flag_subreg_nr(brw, inst))
         format(file, ".%d", brw_inst_flag_subreg_nr(brw, inst));
      if (brw_inst_access_mode(brw, inst) == BRW_ALIGN_1) {
         err |= control(file, "predicate control align1", pred_ctrl_align1,
                        brw_inst_pred_control(brw, inst), NULL);
      } else {
         err |= control(file, "predicate control align16", pred_ctrl_align16,
                        brw_inst_pred_control(brw, inst), NULL);
      }
      string(file, ") ");
   }

   err |= print_opcode(file, opcode);
   err |= control(file, "saturate", saturate, brw_inst_saturate(brw, inst),
                  NULL);

   err |= control(file, "debug control", debug_ctrl,
                  brw_inst_debug_control(brw, inst), NULL);

   if (opcode == BRW_OPCODE_MATH) {
      string(file, " ");
      err |= control(file, "function", math_function,
                     brw_inst_math_function(brw, inst), NULL);
   } else if (opcode != BRW_OPCODE_SEND && opcode != BRW_OPCODE_SENDC) {
      err |= control(file, "conditional modifier", conditional_modifier,
                     brw_inst_cond_modifier(brw, inst), NULL);

      /* If we're using the conditional modifier, print which flags reg is
       * used for it.  Note that on gen6+, the embedded-condition SEL and
       * control flow doesn't update flags.
       */
      if (brw_inst_cond_modifier(brw, inst) &&
          (brw->gen < 6 || (opcode != BRW_OPCODE_SEL &&
                            opcode != BRW_OPCODE_IF &&
                            opcode != BRW_OPCODE_WHILE))) {
         format(file, ".f%d",
                brw->gen >= 7 ? brw_inst_flag_reg_nr(brw, inst) : 0);
         if (brw_inst_flag_subreg_nr(brw, inst))
            format(file, ".%d", brw_inst_flag_subreg_nr(brw, inst));
      }
   }

   if (opcode != BRW_OPCODE_NOP && opcode != BRW_OPCODE_NENOP) {
      string(file, "(");
      err |= control(file, "execution size", exec_size,
                     brw_inst_exec_size(brw, inst), NULL);
      string(file, ")");
   }

   if (opcode == BRW_OPCODE_SEND && brw->gen < 6)
      format(file, " %d", brw_inst_base_mrf(brw, inst));

   if (has_uip(brw, opcode)) {
      /* Instructions that have UIP also have JIP. */
      pad(file, 16);
      format(file, "JIP: %d", brw_inst_jip(brw, inst));
      pad(file, 32);
      format(file, "UIP: %d", brw_inst_uip(brw, inst));
   } else if (has_jip(brw, opcode)) {
      pad(file, 16);
      if (brw->gen >= 7) {
         format(file, "JIP: %d", brw_inst_jip(brw, inst));
      } else {
         format(file, "JIP: %d", brw_inst_gen6_jump_count(brw, inst));
      }
   } else if (brw->gen < 6 && (opcode == BRW_OPCODE_BREAK ||
                               opcode == BRW_OPCODE_CONTINUE ||
                               opcode == BRW_OPCODE_ELSE)) {
      pad(file, 16);
      format(file, "Jump: %d", brw_inst_gen4_jump_count(brw, inst));
      pad(file, 32);
      format(file, "Pop: %d", brw_inst_gen4_pop_count(brw, inst));
   } else if (brw->gen < 6 && (opcode == BRW_OPCODE_IF ||
                               opcode == BRW_OPCODE_IFF ||
                               opcode == BRW_OPCODE_HALT)) {
      pad(file, 16);
      format(file, "Jump: %d", brw_inst_gen4_jump_count(brw, inst));
   } else if (brw->gen < 6 && opcode == BRW_OPCODE_ENDIF) {
      pad(file, 16);
      format(file, "Pop: %d", brw_inst_gen4_pop_count(brw, inst));
   } else if (opcode == BRW_OPCODE_JMPI) {
      pad(file, 16);
      err |= src1(file, brw, inst);
   } else if (opcode_descs[opcode].nsrc == 3) {
      pad(file, 16);
      err |= dest_3src(file, brw, inst);

      pad(file, 32);
      err |= src0_3src(file, brw, inst);

      pad(file, 48);
      err |= src1_3src(file, brw, inst);

      pad(file, 64);
      err |= src2_3src(file, brw, inst);
   } else {
      if (opcode_descs[opcode].ndst > 0) {
         pad(file, 16);
         err |= dest(file, brw, inst);
      }

      if (opcode_descs[opcode].nsrc > 0) {
         pad(file, 32);
         err |= src0(file, brw, inst);
      }

      if (opcode_descs[opcode].nsrc > 1) {
         pad(file, 48);
         err |= src1(file, brw, inst);
      }
   }

   if (opcode == BRW_OPCODE_SEND || opcode == BRW_OPCODE_SENDC) {
      enum brw_message_target sfid = brw_inst_sfid(brw, inst);

      if (brw_inst_src1_reg_file(brw, inst) != BRW_IMMEDIATE_VALUE) {
         /* show the indirect descriptor source */
         pad(file, 48);
         err |= src1(file, brw, inst);
      }

      newline(file);
      pad(file, 16);
      space = 0;

      fprintf(file, "            ");
      err |= control(file, "SFID", brw->gen >= 6 ? gen6_sfid : gen4_sfid,
                     sfid, &space);


      if (brw_inst_src1_reg_file(brw, inst) != BRW_IMMEDIATE_VALUE) {
         format(file, " indirect");
      } else {
         switch (sfid) {
         case BRW_SFID_MATH:
            err |= control(file, "math function", math_function,
                           brw_inst_math_msg_function(brw, inst), &space);
            err |= control(file, "math saturate", math_saturate,
                           brw_inst_math_msg_saturate(brw, inst), &space);
            err |= control(file, "math signed", math_signed,
                           brw_inst_math_msg_signed_int(brw, inst), &space);
            err |= control(file, "math scalar", math_scalar,
                           brw_inst_math_msg_data_type(brw, inst), &space);
            err |= control(file, "math precision", math_precision,
                           brw_inst_math_msg_precision(brw, inst), &space);
            break;
         case BRW_SFID_SAMPLER:
            if (brw->gen >= 5) {
               format(file, " (%d, %d, %d, %d)",
                      brw_inst_binding_table_index(brw, inst),
                      brw_inst_sampler(brw, inst),
                      brw_inst_sampler_msg_type(brw, inst),
                      brw_inst_sampler_simd_mode(brw, inst));
            } else {
               format(file, " (%d, %d, %d, ",
                      brw_inst_binding_table_index(brw, inst),
                      brw_inst_sampler(brw, inst),
                      brw_inst_sampler_msg_type(brw, inst));
               if (!brw->is_g4x) {
                  err |= control(file, "sampler target format",
                                 sampler_target_format,
                                 brw_inst_sampler_return_format(brw, inst), NULL);
               }
               string(file, ")");
            }
            break;
         case GEN6_SFID_DATAPORT_SAMPLER_CACHE:
            /* aka BRW_SFID_DATAPORT_READ on Gen4-5 */
            if (brw->gen >= 6) {
               format(file, " (%d, %d, %d, %d)",
                      brw_inst_binding_table_index(brw, inst),
                      brw_inst_dp_msg_control(brw, inst),
                      brw_inst_dp_msg_type(brw, inst),
                      brw->gen >= 7 ? 0 : brw_inst_dp_write_commit(brw, inst));
            } else {
               format(file, " (%d, %d, %d)",
                      brw_inst_binding_table_index(brw, inst),
                      brw_inst_dp_read_msg_control(brw, inst),
                      brw_inst_dp_read_msg_type(brw, inst));
            }
            break;

         case GEN6_SFID_DATAPORT_RENDER_CACHE: {
            /* aka BRW_SFID_DATAPORT_WRITE on Gen4-5 */
            unsigned msg_type = brw_inst_dp_write_msg_type(brw, inst);

            err |= control(file, "DP rc message type",
                           brw->gen >= 6 ? dp_rc_msg_type_gen6
                                         : dp_write_port_msg_type,
                           msg_type, &space);

            bool is_rt_write = msg_type ==
               (brw->gen >= 6 ? GEN6_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_WRITE
                              : BRW_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_WRITE);

            if (is_rt_write) {
               err |= control(file, "RT message type", m_rt_write_subtype,
                              brw_inst_rt_message_type(brw, inst), &space);
               if (brw->gen >= 6 && brw_inst_rt_slot_group(brw, inst))
                  string(file, " Hi");
               if (brw_inst_rt_last(brw, inst))
                  string(file, " LastRT");
               if (brw->gen < 7 && brw_inst_dp_write_commit(brw, inst))
                  string(file, " WriteCommit");
            } else {
               format(file, " MsgCtrl = 0x%x",
                      brw_inst_dp_write_msg_control(brw, inst));
            }

            format(file, " Surface = %d", brw_inst_binding_table_index(brw, inst));
            break;
         }

         case BRW_SFID_URB:
            format(file, " %d", brw_inst_urb_global_offset(brw, inst));

            space = 1;
            if (brw->gen >= 7) {
               err |= control(file, "urb opcode", gen7_urb_opcode,
                              brw_inst_urb_opcode(brw, inst), &space);
            } else if (brw->gen >= 5) {
               err |= control(file, "urb opcode", gen5_urb_opcode,
                              brw_inst_urb_opcode(brw, inst), &space);
            }
            err |= control(file, "urb swizzle", urb_swizzle,
                           brw_inst_urb_swizzle_control(brw, inst), &space);
            if (brw->gen < 7) {
               err |= control(file, "urb allocate", urb_allocate,
                              brw_inst_urb_allocate(brw, inst), &space);
               err |= control(file, "urb used", urb_used,
                              brw_inst_urb_used(brw, inst), &space);
            }
            if (brw->gen < 8) {
               err |= control(file, "urb complete", urb_complete,
                              brw_inst_urb_complete(brw, inst), &space);
            }
            break;
         case BRW_SFID_THREAD_SPAWNER:
            break;
         case GEN7_SFID_DATAPORT_DATA_CACHE:
            if (brw->gen >= 7) {
               format(file, " (");

               err |= control(file, "DP DC0 message type",
d1363 1
a1363 1
                              brw_inst_dp_msg_type(brw, inst), &space);
d1365 1
a1365 56
               format(file, ", %d, ", brw_inst_binding_table_index(brw, inst));

               switch (brw_inst_dp_msg_type(brw, inst)) {
               case GEN7_DATAPORT_DC_UNTYPED_ATOMIC_OP:
                  control(file, "atomic op", aop,
                          brw_inst_imm_ud(brw, inst) >> 8 & 0xf, &space);
                  break;
               default:
                  format(file, "%d", brw_inst_dp_msg_control(brw, inst));
               }
               format(file, ")");
               break;
            }
            /* FALLTHROUGH */

         case HSW_SFID_DATAPORT_DATA_CACHE_1: {
            if (brw->gen >= 7) {
               format(file, " (");

               unsigned msg_ctrl = brw_inst_dp_msg_control(brw, inst);

               err |= control(file, "DP DC1 message type",
                              dp_dc1_msg_type_hsw,
                              brw_inst_dp_msg_type(brw, inst), &space);

               format(file, ", Surface = %d, ",
                      brw_inst_binding_table_index(brw, inst));

               switch (brw_inst_dp_msg_type(brw, inst)) {
               case HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP:
               case HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP:
               case HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP:
                  format(file, "SIMD%d,", (msg_ctrl & (1 << 4)) ? 8 : 16);
                  /* fallthrough */
               case HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP_SIMD4X2:
               case HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP_SIMD4X2:
               case HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP_SIMD4X2:
                  control(file, "atomic op", aop, msg_ctrl & 0xf, &space);
                  break;
               case HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_READ:
               case HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_WRITE:
               case HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_READ:
               case HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_WRITE: {
                  static const char *simd_modes[] = { "4x2", "16", "8" };
                  format(file, "SIMD%s, Mask = 0x%x",
                         simd_modes[msg_ctrl >> 4], msg_ctrl & 0xf);
                  break;
               }
               default:
                  format(file, "0x%x", msg_ctrl);
               }
               format(file, ")");
               break;
            }
            /* FALLTHROUGH */
         }
d1367 39
a1405 7
         case GEN7_SFID_PIXEL_INTERPOLATOR:
            if (brw->gen >= 7) {
               format(file, " (%s, %s, 0x%02x)",
                      brw_inst_pi_nopersp(brw, inst) ? "linear" : "persp",
                      pixel_interpolator_msg_types[brw_inst_pi_message_type(brw, inst)],
                      brw_inst_pi_message_data(brw, inst));
               break;
d1409 57
a1465 58
         default:
            format(file, "unsupported shared function ID %d", sfid);
            break;
         }

         if (space)
            string(file, " ");
         format(file, "mlen %d", brw_inst_mlen(brw, inst));
         format(file, " rlen %d", brw_inst_rlen(brw, inst));
      }
   }
   pad(file, 64);
   if (opcode != BRW_OPCODE_NOP && opcode != BRW_OPCODE_NENOP) {
      string(file, "{");
      space = 1;
      err |= control(file, "access mode", access_mode,
                     brw_inst_access_mode(brw, inst), &space);
      if (brw->gen >= 6) {
         err |= control(file, "write enable control", wectrl,
                        brw_inst_mask_control(brw, inst), &space);
      } else {
         err |= control(file, "mask control", mask_ctrl,
                        brw_inst_mask_control(brw, inst), &space);
      }
      err |= control(file, "dependency control", dep_ctrl,
                     ((brw_inst_no_dd_check(brw, inst) << 1) |
                      brw_inst_no_dd_clear(brw, inst)), &space);

      if (brw->gen >= 6)
         err |= qtr_ctrl(file, brw, inst);
      else {
         if (brw_inst_qtr_control(brw, inst) == BRW_COMPRESSION_COMPRESSED &&
             opcode_descs[opcode].ndst > 0 &&
             brw_inst_dst_reg_file(brw, inst) == BRW_MESSAGE_REGISTER_FILE &&
             brw_inst_dst_da_reg_nr(brw, inst) & (1 << 7)) {
            format(file, " compr4");
         } else {
            err |= control(file, "compression control", compr_ctrl,
                           brw_inst_qtr_control(brw, inst), &space);
         }
      }

      err |= control(file, "compaction", cmpt_ctrl, is_compacted, &space);
      err |= control(file, "thread control", thread_ctrl,
                     brw_inst_thread_control(brw, inst), &space);
      if (brw->gen >= 6)
         err |= control(file, "acc write control", accwr,
                        brw_inst_acc_wr_control(brw, inst), &space);
      if (opcode == BRW_OPCODE_SEND || opcode == BRW_OPCODE_SENDC)
         err |= control(file, "end of thread", end_of_thread,
                        brw_inst_eot(brw, inst), &space);
      if (space)
         string(file, " ");
      string(file, "}");
   }
   string(file, ";");
   newline(file);
   return err;
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@a29 2
#include "main/mtypes.h"

d32 2
d36 196
a231 219
    [BRW_OPCODE_MOV] = { .name = "mov", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_FRC] = { .name = "frc", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_RNDU] = { .name = "rndu", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_RNDD] = { .name = "rndd", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_RNDE] = { .name = "rnde", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_RNDZ] = { .name = "rndz", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_NOT] = { .name = "not", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_LZD] = { .name = "lzd", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_F32TO16] = { .name = "f32to16", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_F16TO32] = { .name = "f16to32", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_BFREV] = { .name = "bfrev", .nsrc = 1, .ndst = 1},
    [BRW_OPCODE_FBH] = { .name = "fbh", .nsrc = 1, .ndst = 1},
    [BRW_OPCODE_FBL] = { .name = "fbl", .nsrc = 1, .ndst = 1},
    [BRW_OPCODE_CBIT] = { .name = "cbit", .nsrc = 1, .ndst = 1},

    [BRW_OPCODE_MUL] = { .name = "mul", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_MAC] = { .name = "mac", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_MACH] = { .name = "mach", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_LINE] = { .name = "line", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_PLN] = { .name = "pln", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_MAD] = { .name = "mad", .nsrc = 3, .ndst = 1 },
    [BRW_OPCODE_LRP] = { .name = "lrp", .nsrc = 3, .ndst = 1 },
    [BRW_OPCODE_SAD2] = { .name = "sad2", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_SADA2] = { .name = "sada2", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_DP4] = { .name = "dp4", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_DPH] = { .name = "dph", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_DP3] = { .name = "dp3", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_DP2] = { .name = "dp2", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_MATH] = { .name = "math", .nsrc = 2, .ndst = 1 },

    [BRW_OPCODE_AVG] = { .name = "avg", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_ADD] = { .name = "add", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_SEL] = { .name = "sel", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_AND] = { .name = "and", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_OR] = { .name = "or", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_XOR] = { .name = "xor", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_SHR] = { .name = "shr", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_SHL] = { .name = "shl", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_ASR] = { .name = "asr", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_CMP] = { .name = "cmp", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_CMPN] = { .name = "cmpn", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_BFE] = { .name = "bfe", .nsrc = 3, .ndst = 1},
    [BRW_OPCODE_BFI1] = { .name = "bfi1", .nsrc = 2, .ndst = 1},
    [BRW_OPCODE_BFI2] = { .name = "bfi2", .nsrc = 3, .ndst = 1},
    [BRW_OPCODE_ADDC] = { .name = "addc", .nsrc = 2, .ndst = 1},
    [BRW_OPCODE_SUBB] = { .name = "subb", .nsrc = 2, .ndst = 1},

    [BRW_OPCODE_SEND] = { .name = "send", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_SENDC] = { .name = "sendc", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_NOP] = { .name = "nop", .nsrc = 0, .ndst = 0 },
    [BRW_OPCODE_JMPI] = { .name = "jmpi", .nsrc = 0, .ndst = 0 },
    [BRW_OPCODE_IF] = { .name = "if", .nsrc = 2, .ndst = 0 },
    [BRW_OPCODE_IFF] = { .name = "iff", .nsrc = 2, .ndst = 1 },
    [BRW_OPCODE_WHILE] = { .name = "while", .nsrc = 2, .ndst = 0 },
    [BRW_OPCODE_ELSE] = { .name = "else", .nsrc = 2, .ndst = 0 },
    [BRW_OPCODE_BREAK] = { .name = "break", .nsrc = 2, .ndst = 0 },
    [BRW_OPCODE_CONTINUE] = { .name = "cont", .nsrc = 1, .ndst = 0 },
    [BRW_OPCODE_HALT] = { .name = "halt", .nsrc = 1, .ndst = 0 },
    [BRW_OPCODE_MSAVE] = { .name = "msave", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_PUSH] = { .name = "push", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_MRESTORE] = { .name = "mrest", .nsrc = 1, .ndst = 1 },
    [BRW_OPCODE_POP] = { .name = "pop", .nsrc = 2, .ndst = 0 },
    [BRW_OPCODE_WAIT] = { .name = "wait", .nsrc = 1, .ndst = 0 },
    [BRW_OPCODE_DO] = { .name = "do", .nsrc = 0, .ndst = 0 },
    [BRW_OPCODE_ENDIF] = { .name = "endif", .nsrc = 2, .ndst = 0 },
};
static const struct opcode_desc *opcode = opcode_descs;

const char * const conditional_modifier[16] = {
    [BRW_CONDITIONAL_NONE] = "",
    [BRW_CONDITIONAL_Z] = ".e",
    [BRW_CONDITIONAL_NZ] = ".ne",
    [BRW_CONDITIONAL_G] = ".g",
    [BRW_CONDITIONAL_GE] = ".ge",
    [BRW_CONDITIONAL_L] = ".l",
    [BRW_CONDITIONAL_LE] = ".le",
    [BRW_CONDITIONAL_R] = ".r",
    [BRW_CONDITIONAL_O] = ".o",
    [BRW_CONDITIONAL_U] = ".u",
};

static const char * const negate[2] = {
    [0] = "",
    [1] = "-",
};

static const char * const _abs[2] = {
    [0] = "",
    [1] = "(abs)",
};

static const char * const vert_stride[16] = {
    [0] = "0",
    [1] = "1",
    [2] = "2",
    [3] = "4",
    [4] = "8",
    [5] = "16",
    [6] = "32",
    [15] = "VxH",
};

static const char * const width[8] = {
    [0] = "1",
    [1] = "2",
    [2] = "4",
    [3] = "8",
    [4] = "16",
};

static const char * const horiz_stride[4] = {
    [0] = "0",
    [1] = "1",
    [2] = "2",
    [3] = "4"
};

static const char * const chan_sel[4] = {
    [0] = "x",
    [1] = "y",
    [2] = "z",
    [3] = "w",
};

static const char * const debug_ctrl[2] = {
    [0] = "",
    [1] = ".breakpoint"
};

static const char * const saturate[2] = {
    [0] = "",
    [1] = ".sat"
};

static const char * const accwr[2] = {
    [0] = "",
    [1] = "AccWrEnable"
};

static const char * const wectrl[2] = {
    [0] = "WE_normal",
    [1] = "WE_all"
};

static const char * const exec_size[8] = {
    [0] = "1",
    [1] = "2",
    [2] = "4",
    [3] = "8",
    [4] = "16",
    [5] = "32"
};

static const char * const pred_inv[2] = {
    [0] = "+",
    [1] = "-"
};

static const char * const pred_ctrl_align16[16] = {
    [1] = "",
    [2] = ".x",
    [3] = ".y",
    [4] = ".z",
    [5] = ".w",
    [6] = ".any4h",
    [7] = ".all4h",
};

static const char * const pred_ctrl_align1[16] = {
    [1] = "",
    [2] = ".anyv",
    [3] = ".allv",
    [4] = ".any2h",
    [5] = ".all2h",
    [6] = ".any4h",
    [7] = ".all4h",
    [8] = ".any8h",
    [9] = ".all8h",
    [10] = ".any16h",
    [11] = ".all16h",
};

static const char * const thread_ctrl[4] = {
    [0] = "",
    [2] = "switch"
};

static const char * const compr_ctrl[4] = {
    [0] = "",
    [1] = "sechalf",
    [2] = "compr",
    [3] = "compr4",
};

static const char * const dep_ctrl[4] = {
    [0] = "",
    [1] = "NoDDClr",
    [2] = "NoDDChk",
    [3] = "NoDDClr,NoDDChk",
};

static const char * const mask_ctrl[4] = {
    [0] = "",
    [1] = "nomask",
};

static const char * const access_mode[2] = {
    [0] = "align1",
    [1] = "align16",
};

static const char * const reg_encoding[8] = {
    [0] = "UD",
    [1] = "D",
    [2] = "UW",
    [3] = "W",
    [4] = "UB",
    [5] = "B",
    [7] = "F"
d234 76
a309 1
const char * const three_source_reg_encoding[] = {
d315 113
a427 84
const int reg_type_size[8] = {
    [0] = 4,
    [1] = 4,
    [2] = 2,
    [3] = 2,
    [4] = 1,
    [5] = 1,
    [7] = 4
};

static const char * const reg_file[4] = {
    [0] = "A",
    [1] = "g",
    [2] = "m",
    [3] = "imm",
};

static const char * const writemask[16] = {
    [0x0] = ".",
    [0x1] = ".x",
    [0x2] = ".y",
    [0x3] = ".xy",
    [0x4] = ".z",
    [0x5] = ".xz",
    [0x6] = ".yz",
    [0x7] = ".xyz",
    [0x8] = ".w",
    [0x9] = ".xw",
    [0xa] = ".yw",
    [0xb] = ".xyw",
    [0xc] = ".zw",
    [0xd] = ".xzw",
    [0xe] = ".yzw",
    [0xf] = "",
};

static const char * const end_of_thread[2] = {
    [0] = "",
    [1] = "EOT"
};

static const char * const target_function[16] = {
    [BRW_SFID_NULL] = "null",
    [BRW_SFID_MATH] = "math",
    [BRW_SFID_SAMPLER] = "sampler",
    [BRW_SFID_MESSAGE_GATEWAY] = "gateway",
    [BRW_SFID_DATAPORT_READ] = "read",
    [BRW_SFID_DATAPORT_WRITE] = "write",
    [BRW_SFID_URB] = "urb",
    [BRW_SFID_THREAD_SPAWNER] = "thread_spawner",
    [BRW_SFID_VME] = "vme",
};

static const char * const target_function_gen6[16] = {
    [BRW_SFID_NULL] = "null",
    [BRW_SFID_MATH] = "math",
    [BRW_SFID_SAMPLER] = "sampler",
    [BRW_SFID_MESSAGE_GATEWAY] = "gateway",
    [BRW_SFID_URB] = "urb",
    [BRW_SFID_THREAD_SPAWNER] = "thread_spawner",
    [GEN6_SFID_DATAPORT_SAMPLER_CACHE] = "sampler",
    [GEN6_SFID_DATAPORT_RENDER_CACHE] = "render",
    [GEN6_SFID_DATAPORT_CONSTANT_CACHE] = "const",
    [GEN7_SFID_DATAPORT_DATA_CACHE] = "data",
    [GEN7_SFID_PIXEL_INTERPOLATOR] = "pixel interp",
    [HSW_SFID_DATAPORT_DATA_CACHE_1] = "dp data 1",
    [HSW_SFID_CRE] = "cre",
};

static const char * const dp_rc_msg_type_gen6[16] = {
    [BRW_DATAPORT_READ_MESSAGE_OWORD_BLOCK_READ] = "OWORD block read",
    [GEN6_DATAPORT_READ_MESSAGE_RENDER_UNORM_READ] = "RT UNORM read",
    [GEN6_DATAPORT_READ_MESSAGE_OWORD_DUAL_BLOCK_READ] = "OWORD dual block read",
    [GEN6_DATAPORT_READ_MESSAGE_MEDIA_BLOCK_READ] = "media block read",
    [GEN6_DATAPORT_READ_MESSAGE_OWORD_UNALIGN_BLOCK_READ] = "OWORD unaligned block read",
    [GEN6_DATAPORT_READ_MESSAGE_DWORD_SCATTERED_READ] = "DWORD scattered read",
    [GEN6_DATAPORT_WRITE_MESSAGE_DWORD_ATOMIC_WRITE] = "DWORD atomic write",
    [GEN6_DATAPORT_WRITE_MESSAGE_OWORD_BLOCK_WRITE] = "OWORD block write",
    [GEN6_DATAPORT_WRITE_MESSAGE_OWORD_DUAL_BLOCK_WRITE] = "OWORD dual block write",
    [GEN6_DATAPORT_WRITE_MESSAGE_MEDIA_BLOCK_WRITE] = "media block write",
    [GEN6_DATAPORT_WRITE_MESSAGE_DWORD_SCATTERED_WRITE] = "DWORD scattered write",
    [GEN6_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_WRITE] = "RT write",
    [GEN6_DATAPORT_WRITE_MESSAGE_STREAMED_VB_WRITE] = "streamed VB write",
    [GEN6_DATAPORT_WRITE_MESSAGE_RENDER_TARGET_UNORM_WRITE] = "RT UNORMc write",
d431 14
a444 12
    [GEN7_DATAPORT_DC_OWORD_BLOCK_READ] = "DC OWORD block read",
    [GEN7_DATAPORT_DC_UNALIGNED_OWORD_BLOCK_READ] = "DC unaligned OWORD block read",
    [GEN7_DATAPORT_DC_OWORD_DUAL_BLOCK_READ] = "DC OWORD dual block read",
    [GEN7_DATAPORT_DC_DWORD_SCATTERED_READ] = "DC DWORD scattered read",
    [GEN7_DATAPORT_DC_BYTE_SCATTERED_READ] = "DC byte scattered read",
    [GEN7_DATAPORT_DC_UNTYPED_ATOMIC_OP] = "DC untyped atomic",
    [GEN7_DATAPORT_DC_MEMORY_FENCE] = "DC mfence",
    [GEN7_DATAPORT_DC_OWORD_BLOCK_WRITE] = "DC OWORD block write",
    [GEN7_DATAPORT_DC_OWORD_DUAL_BLOCK_WRITE] = "DC OWORD dual block write",
    [GEN7_DATAPORT_DC_DWORD_SCATTERED_WRITE] = "DC DWORD scatterd write",
    [GEN7_DATAPORT_DC_BYTE_SCATTERED_WRITE] = "DC byte scattered write",
    [GEN7_DATAPORT_DC_UNTYPED_SURFACE_WRITE] = "DC untyped surface write",
d448 25
a472 23
    [HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_READ] = "untyped surface read",
    [HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP] = "DC untyped atomic op",
    [HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP_SIMD4X2] = "DC untyped 4x2 atomic op",
    [HSW_DATAPORT_DC_PORT1_MEDIA_BLOCK_READ] = "DC media block read",
    [HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_READ] = "DC typed surface read",
    [HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP] = "DC typed atomic",
    [HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP_SIMD4X2] = "DC typed 4x2 atomic op",
    [HSW_DATAPORT_DC_PORT1_UNTYPED_SURFACE_WRITE] = "DC untyped surface write",
    [HSW_DATAPORT_DC_PORT1_MEDIA_BLOCK_WRITE] = "DC media block write",
    [HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP] = "DC atomic counter op",
    [HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP_SIMD4X2] = "DC 4x2 atomic counter op",
    [HSW_DATAPORT_DC_PORT1_TYPED_SURFACE_WRITE] = "DC typed surface write",
};

static const char * const aop[16] = {
   [BRW_AOP_AND] = "and",
   [BRW_AOP_OR] = "or",
   [BRW_AOP_XOR] = "xor",
   [BRW_AOP_MOV] = "mov",
   [BRW_AOP_INC] = "inc",
   [BRW_AOP_DEC] = "dec",
   [BRW_AOP_ADD] = "add",
   [BRW_AOP_SUB] = "sub",
d474 5
a478 5
   [BRW_AOP_IMAX] = "imax",
   [BRW_AOP_IMIN] = "imin",
   [BRW_AOP_UMAX] = "umax",
   [BRW_AOP_UMIN] = "umin",
   [BRW_AOP_CMPWR] = "cmpwr",
d482 28
a509 14
static const char * const math_function[16] = {
    [BRW_MATH_FUNCTION_INV] = "inv",
    [BRW_MATH_FUNCTION_LOG] = "log",
    [BRW_MATH_FUNCTION_EXP] = "exp",
    [BRW_MATH_FUNCTION_SQRT] = "sqrt",
    [BRW_MATH_FUNCTION_RSQ] = "rsq",
    [BRW_MATH_FUNCTION_SIN] = "sin",
    [BRW_MATH_FUNCTION_COS] = "cos",
    [BRW_MATH_FUNCTION_SINCOS] = "sincos",
    [BRW_MATH_FUNCTION_FDIV] = "fdiv",
    [BRW_MATH_FUNCTION_POW] = "pow",
    [BRW_MATH_FUNCTION_INT_DIV_QUOTIENT_AND_REMAINDER] = "intdivmod",
    [BRW_MATH_FUNCTION_INT_DIV_QUOTIENT] = "intdiv",
    [BRW_MATH_FUNCTION_INT_DIV_REMAINDER] = "intmod",
d512 3
a514 3
static const char * const math_saturate[2] = {
    [0] = "",
    [1] = "sat"
d517 3
a519 3
static const char * const math_signed[2] = {
    [0] = "",
    [1] = "signed"
d522 3
a524 3
static const char * const math_scalar[2] = {
    [0] = "",
    [1] = "scalar"
d527 3
a529 3
static const char * const math_precision[2] = {
    [0] = "",
    [1] = "partial_precision"
d532 11
a542 3
static const char * const urb_opcode[2] = {
    [0] = "urb_write",
    [1] = "ff_sync",
d545 4
a548 4
static const char * const urb_swizzle[4] = {
    [BRW_URB_SWIZZLE_NONE] = "",
    [BRW_URB_SWIZZLE_INTERLEAVE] = "interleave",
    [BRW_URB_SWIZZLE_TRANSPOSE] = "transpose",
d551 3
a553 3
static const char * const urb_allocate[2] = {
    [0] = "",
    [1] = "allocate"
d556 3
a558 3
static const char * const urb_used[2] = {
    [0] = "",
    [1] = "used"
d561 3
a563 3
static const char * const urb_complete[2] = {
    [0] = "",
    [1] = "complete"
d566 4
a569 4
static const char * const sampler_target_format[4] = {
    [0] = "F",
    [2] = "UD",
    [3] = "D"
d575 10
a584 1
static int string (FILE *file, const char *string)
d586 55
a640 890
    fputs (string, file);
    column += strlen (string);
    return 0;
}

static int format (FILE *f, const char *format, ...)
{
    char    buf[1024];
    va_list	args;
    va_start (args, format);

    vsnprintf (buf, sizeof (buf) - 1, format, args);
    va_end (args);
    string (f, buf);
    return 0;
}

static int newline (FILE *f)
{
    putc ('\n', f);
    column = 0;
    return 0;
}

static int pad (FILE *f, int c)
{
    do
	string (f, " ");
    while (column < c);
    return 0;
}

static int control (FILE *file, const char *name, const char * const ctrl[],
                    unsigned id, int *space)
{
    if (!ctrl[id]) {
	fprintf (file, "*** invalid %s value %d ",
		 name, id);
	return 1;
    }
    if (ctrl[id][0])
    {
	if (space && *space)
	    string (file, " ");
	string (file, ctrl[id]);
	if (space)
	    *space = 1;
    }
    return 0;
}

static int print_opcode (FILE *file, int id)
{
    if (!opcode[id].name) {
	format (file, "*** invalid opcode value %d ", id);
	return 1;
    }
    string (file, opcode[id].name);
    return 0;
}

static int reg (FILE *file, unsigned _reg_file, unsigned _reg_nr)
{
    int	err = 0;

    /* Clear the Compr4 instruction compression bit. */
    if (_reg_file == BRW_MESSAGE_REGISTER_FILE)
       _reg_nr &= ~(1 << 7);

    if (_reg_file == BRW_ARCHITECTURE_REGISTER_FILE) {
	switch (_reg_nr & 0xf0) {
	case BRW_ARF_NULL:
	    string (file, "null");
	    return -1;
	case BRW_ARF_ADDRESS:
	    format (file, "a%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_ACCUMULATOR:
	    format (file, "acc%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_FLAG:
	    format (file, "f%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_MASK:
	    format (file, "mask%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_MASK_STACK:
	    format (file, "msd%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_STATE:
	    format (file, "sr%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_CONTROL:
	    format (file, "cr%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_NOTIFICATION_COUNT:
	    format (file, "n%d", _reg_nr & 0x0f);
	    break;
	case BRW_ARF_IP:
	    string (file, "ip");
	    return -1;
	    break;
	default:
	    format (file, "ARF%d", _reg_nr);
	    break;
	}
    } else {
	err  |= control (file, "src reg file", reg_file, _reg_file, NULL);
	format (file, "%d", _reg_nr);
    }
    return err;
}

static int dest (FILE *file, struct brw_instruction *inst)
{
    int	err = 0;

    if (inst->header.access_mode == BRW_ALIGN_1)
    {
	if (inst->bits1.da1.dest_address_mode == BRW_ADDRESS_DIRECT)
	{
	    err |= reg (file, inst->bits1.da1.dest_reg_file, inst->bits1.da1.dest_reg_nr);
	    if (err == -1)
		return 0;
	    if (inst->bits1.da1.dest_subreg_nr)
		format (file, ".%d", inst->bits1.da1.dest_subreg_nr /
				     reg_type_size[inst->bits1.da1.dest_reg_type]);
	    string (file, "<");
	    err |= control (file, "horiz stride", horiz_stride, inst->bits1.da1.dest_horiz_stride, NULL);
	    string (file, ">");
	    err |= control (file, "dest reg encoding", reg_encoding, inst->bits1.da1.dest_reg_type, NULL);
	}
	else
	{
	    string (file, "g[a0");
	    if (inst->bits1.ia1.dest_subreg_nr)
		format (file, ".%d", inst->bits1.ia1.dest_subreg_nr /
					reg_type_size[inst->bits1.ia1.dest_reg_type]);
	    if (inst->bits1.ia1.dest_indirect_offset)
		format (file, " %d", inst->bits1.ia1.dest_indirect_offset);
	    string (file, "]<");
	    err |= control (file, "horiz stride", horiz_stride, inst->bits1.ia1.dest_horiz_stride, NULL);
	    string (file, ">");
	    err |= control (file, "dest reg encoding", reg_encoding, inst->bits1.ia1.dest_reg_type, NULL);
	}
    }
    else
    {
	if (inst->bits1.da16.dest_address_mode == BRW_ADDRESS_DIRECT)
	{
	    err |= reg (file, inst->bits1.da16.dest_reg_file, inst->bits1.da16.dest_reg_nr);
	    if (err == -1)
		return 0;
	    if (inst->bits1.da16.dest_subreg_nr)
		format (file, ".%d", inst->bits1.da16.dest_subreg_nr /
				     reg_type_size[inst->bits1.da16.dest_reg_type]);
	    string (file, "<1>");
	    err |= control (file, "writemask", writemask, inst->bits1.da16.dest_writemask, NULL);
	    err |= control (file, "dest reg encoding", reg_encoding, inst->bits1.da16.dest_reg_type, NULL);
	}
	else
	{
	    err = 1;
	    string (file, "Indirect align16 address mode not supported");
	}
    }

    return 0;
}

static int dest_3src (FILE *file, struct brw_instruction *inst)
{
    int	err = 0;
    uint32_t reg_file;

    if (inst->bits1.da3src.dest_reg_file)
       reg_file = BRW_MESSAGE_REGISTER_FILE;
    else
       reg_file = BRW_GENERAL_REGISTER_FILE;

    err |= reg (file, reg_file, inst->bits1.da3src.dest_reg_nr);
    if (err == -1)
       return 0;
    if (inst->bits1.da3src.dest_subreg_nr)
       format (file, ".%d", inst->bits1.da3src.dest_subreg_nr);
    string (file, "<1>");
    err |= control (file, "writemask", writemask, inst->bits1.da3src.dest_writemask, NULL);
    err |= control (file, "dest reg encoding", three_source_reg_encoding,
                    inst->bits1.da3src.dst_type, NULL);

    return 0;
}

static int src_align1_region (FILE *file,
			      unsigned _vert_stride, unsigned _width, unsigned _horiz_stride)
{
    int err = 0;
    string (file, "<");
    err |= control (file, "vert stride", vert_stride, _vert_stride, NULL);
    string (file, ",");
    err |= control (file, "width", width, _width, NULL);
    string (file, ",");
    err |= control (file, "horiz_stride", horiz_stride, _horiz_stride, NULL);
    string (file, ">");
    return err;
}

static int src_da1 (FILE *file, unsigned type, unsigned _reg_file,
		    unsigned _vert_stride, unsigned _width, unsigned _horiz_stride,
		    unsigned reg_num, unsigned sub_reg_num, unsigned __abs, unsigned _negate)
{
    int err = 0;
    err |= control (file, "negate", negate, _negate, NULL);
    err |= control (file, "abs", _abs, __abs, NULL);

    err |= reg (file, _reg_file, reg_num);
    if (err == -1)
	return 0;
    if (sub_reg_num)
	format (file, ".%d", sub_reg_num / reg_type_size[type]); /* use formal style like spec */
    src_align1_region (file, _vert_stride, _width, _horiz_stride);
    err |= control (file, "src reg encoding", reg_encoding, type, NULL);
    return err;
}

static int src_ia1 (FILE *file,
		    unsigned type,
		    unsigned _reg_file,
		    int _addr_imm,
		    unsigned _addr_subreg_nr,
		    unsigned _negate,
		    unsigned __abs,
		    unsigned _addr_mode,
		    unsigned _horiz_stride,
		    unsigned _width,
		    unsigned _vert_stride)
{
    int err = 0;
    err |= control (file, "negate", negate, _negate, NULL);
    err |= control (file, "abs", _abs, __abs, NULL);

    string (file, "g[a0");
    if (_addr_subreg_nr)
	format (file, ".%d", _addr_subreg_nr);
    if (_addr_imm)
	format (file, " %d", _addr_imm);
    string (file, "]");
    src_align1_region (file, _vert_stride, _width, _horiz_stride);
    err |= control (file, "src reg encoding", reg_encoding, type, NULL);
    return err;
}

static int src_da16 (FILE *file,
		     unsigned _reg_type,
		     unsigned _reg_file,
		     unsigned _vert_stride,
		     unsigned _reg_nr,
		     unsigned _subreg_nr,
		     unsigned __abs,
		     unsigned _negate,
		     unsigned swz_x,
		     unsigned swz_y,
		     unsigned swz_z,
		     unsigned swz_w)
{
    int err = 0;
    err |= control (file, "negate", negate, _negate, NULL);
    err |= control (file, "abs", _abs, __abs, NULL);

    err |= reg (file, _reg_file, _reg_nr);
    if (err == -1)
	return 0;
    if (_subreg_nr)
	/* bit4 for subreg number byte addressing. Make this same meaning as
	   in da1 case, so output looks consistent. */
	format (file, ".%d", 16 / reg_type_size[_reg_type]);
    string (file, "<");
    err |= control (file, "vert stride", vert_stride, _vert_stride, NULL);
    string (file, ",4,1>");
    /*
     * Three kinds of swizzle display:
     *  identity - nothing printed
     *  1->all	 - print the single channel
     *  1->1     - print the mapping
     */
    if (swz_x == BRW_CHANNEL_X &&
	swz_y == BRW_CHANNEL_Y &&
	swz_z == BRW_CHANNEL_Z &&
	swz_w == BRW_CHANNEL_W)
    {
	;
    }
    else if (swz_x == swz_y && swz_x == swz_z && swz_x == swz_w)
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
    }
    else
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
	err |= control (file, "channel select", chan_sel, swz_y, NULL);
	err |= control (file, "channel select", chan_sel, swz_z, NULL);
	err |= control (file, "channel select", chan_sel, swz_w, NULL);
    }
    err |= control (file, "src da16 reg type", reg_encoding, _reg_type, NULL);
    return err;
}

static int src0_3src (FILE *file, struct brw_instruction *inst)
{
    int err = 0;
    unsigned swz_x = (inst->bits2.da3src.src0_swizzle >> 0) & 0x3;
    unsigned swz_y = (inst->bits2.da3src.src0_swizzle >> 2) & 0x3;
    unsigned swz_z = (inst->bits2.da3src.src0_swizzle >> 4) & 0x3;
    unsigned swz_w = (inst->bits2.da3src.src0_swizzle >> 6) & 0x3;

    err |= control (file, "negate", negate, inst->bits1.da3src.src0_negate, NULL);
    err |= control (file, "abs", _abs, inst->bits1.da3src.src0_abs, NULL);

    err |= reg (file, BRW_GENERAL_REGISTER_FILE, inst->bits2.da3src.src0_reg_nr);
    if (err == -1)
	return 0;
    if (inst->bits2.da3src.src0_subreg_nr)
	format (file, ".%d", inst->bits2.da3src.src0_subreg_nr);
    if (inst->bits2.da3src.src0_rep_ctrl)
       string (file, "<0,1,0>");
    else
       string (file, "<4,4,1>");
    err |= control (file, "src da16 reg type", three_source_reg_encoding,
                    inst->bits1.da3src.src_type, NULL);
    /*
     * Three kinds of swizzle display:
     *  identity - nothing printed
     *  1->all	 - print the single channel
     *  1->1     - print the mapping
     */
    if (swz_x == BRW_CHANNEL_X &&
	swz_y == BRW_CHANNEL_Y &&
	swz_z == BRW_CHANNEL_Z &&
	swz_w == BRW_CHANNEL_W)
    {
	;
    }
    else if (swz_x == swz_y && swz_x == swz_z && swz_x == swz_w)
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
    }
    else
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
	err |= control (file, "channel select", chan_sel, swz_y, NULL);
	err |= control (file, "channel select", chan_sel, swz_z, NULL);
	err |= control (file, "channel select", chan_sel, swz_w, NULL);
    }
    return err;
}

static int src1_3src (FILE *file, struct brw_instruction *inst)
{
    int err = 0;
    unsigned swz_x = (inst->bits2.da3src.src1_swizzle >> 0) & 0x3;
    unsigned swz_y = (inst->bits2.da3src.src1_swizzle >> 2) & 0x3;
    unsigned swz_z = (inst->bits2.da3src.src1_swizzle >> 4) & 0x3;
    unsigned swz_w = (inst->bits2.da3src.src1_swizzle >> 6) & 0x3;
    unsigned src1_subreg_nr = (inst->bits2.da3src.src1_subreg_nr_low |
			     (inst->bits3.da3src.src1_subreg_nr_high << 2));

    err |= control (file, "negate", negate, inst->bits1.da3src.src1_negate,
		    NULL);
    err |= control (file, "abs", _abs, inst->bits1.da3src.src1_abs, NULL);

    err |= reg (file, BRW_GENERAL_REGISTER_FILE,
		inst->bits3.da3src.src1_reg_nr);
    if (err == -1)
	return 0;
    if (src1_subreg_nr)
	format (file, ".%d", src1_subreg_nr);
    if (inst->bits2.da3src.src1_rep_ctrl)
       string (file, "<0,1,0>");
    else
       string (file, "<4,4,1>");
    err |= control (file, "src da16 reg type", three_source_reg_encoding,
                    inst->bits1.da3src.src_type, NULL);
    /*
     * Three kinds of swizzle display:
     *  identity - nothing printed
     *  1->all	 - print the single channel
     *  1->1     - print the mapping
     */
    if (swz_x == BRW_CHANNEL_X &&
	swz_y == BRW_CHANNEL_Y &&
	swz_z == BRW_CHANNEL_Z &&
	swz_w == BRW_CHANNEL_W)
    {
	;
    }
    else if (swz_x == swz_y && swz_x == swz_z && swz_x == swz_w)
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
    }
    else
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
	err |= control (file, "channel select", chan_sel, swz_y, NULL);
	err |= control (file, "channel select", chan_sel, swz_z, NULL);
	err |= control (file, "channel select", chan_sel, swz_w, NULL);
    }
    return err;
}


static int src2_3src (FILE *file, struct brw_instruction *inst)
{
    int err = 0;
    unsigned swz_x = (inst->bits3.da3src.src2_swizzle >> 0) & 0x3;
    unsigned swz_y = (inst->bits3.da3src.src2_swizzle >> 2) & 0x3;
    unsigned swz_z = (inst->bits3.da3src.src2_swizzle >> 4) & 0x3;
    unsigned swz_w = (inst->bits3.da3src.src2_swizzle >> 6) & 0x3;

    err |= control (file, "negate", negate, inst->bits1.da3src.src2_negate,
		    NULL);
    err |= control (file, "abs", _abs, inst->bits1.da3src.src2_abs, NULL);

    err |= reg (file, BRW_GENERAL_REGISTER_FILE,
		inst->bits3.da3src.src2_reg_nr);
    if (err == -1)
	return 0;
    if (inst->bits3.da3src.src2_subreg_nr)
	format (file, ".%d", inst->bits3.da3src.src2_subreg_nr);
    if (inst->bits3.da3src.src2_rep_ctrl)
       string (file, "<0,1,0>");
    else
       string (file, "<4,4,1>");
    err |= control (file, "src da16 reg type", three_source_reg_encoding,
                    inst->bits1.da3src.src_type, NULL);
    /*
     * Three kinds of swizzle display:
     *  identity - nothing printed
     *  1->all	 - print the single channel
     *  1->1     - print the mapping
     */
    if (swz_x == BRW_CHANNEL_X &&
	swz_y == BRW_CHANNEL_Y &&
	swz_z == BRW_CHANNEL_Z &&
	swz_w == BRW_CHANNEL_W)
    {
	;
    }
    else if (swz_x == swz_y && swz_x == swz_z && swz_x == swz_w)
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
    }
    else
    {
	string (file, ".");
	err |= control (file, "channel select", chan_sel, swz_x, NULL);
	err |= control (file, "channel select", chan_sel, swz_y, NULL);
	err |= control (file, "channel select", chan_sel, swz_z, NULL);
	err |= control (file, "channel select", chan_sel, swz_w, NULL);
    }
    return err;
}

static int imm (FILE *file, unsigned type, struct brw_instruction *inst) {
    switch (type) {
    case BRW_HW_REG_TYPE_UD:
	format (file, "0x%08xUD", inst->bits3.ud);
	break;
    case BRW_HW_REG_TYPE_D:
	format (file, "%dD", inst->bits3.d);
	break;
    case BRW_HW_REG_TYPE_UW:
	format (file, "0x%04xUW", (uint16_t) inst->bits3.ud);
	break;
    case BRW_HW_REG_TYPE_W:
	format (file, "%dW", (int16_t) inst->bits3.d);
	break;
    case BRW_HW_REG_IMM_TYPE_UV:
	format (file, "0x%08xUV", inst->bits3.ud);
	break;
    case BRW_HW_REG_IMM_TYPE_VF:
	format (file, "Vector Float");
	break;
    case BRW_HW_REG_IMM_TYPE_V:
	format (file, "0x%08xV", inst->bits3.ud);
	break;
    case BRW_HW_REG_TYPE_F:
	format (file, "%-gF", inst->bits3.f);
    }
    return 0;
}

static int src0 (FILE *file, struct brw_instruction *inst)
{
    if (inst->bits1.da1.src0_reg_file == BRW_IMMEDIATE_VALUE)
	return imm (file, inst->bits1.da1.src0_reg_type,
		    inst);
    else if (inst->header.access_mode == BRW_ALIGN_1)
    {
	if (inst->bits2.da1.src0_address_mode == BRW_ADDRESS_DIRECT)
	{
	    return src_da1 (file,
			    inst->bits1.da1.src0_reg_type,
			    inst->bits1.da1.src0_reg_file,
			    inst->bits2.da1.src0_vert_stride,
			    inst->bits2.da1.src0_width,
			    inst->bits2.da1.src0_horiz_stride,
			    inst->bits2.da1.src0_reg_nr,
			    inst->bits2.da1.src0_subreg_nr,
			    inst->bits2.da1.src0_abs,
			    inst->bits2.da1.src0_negate);
	}
	else
	{
	    return src_ia1 (file,
			    inst->bits1.ia1.src0_reg_type,
			    inst->bits1.ia1.src0_reg_file,
			    inst->bits2.ia1.src0_indirect_offset,
			    inst->bits2.ia1.src0_subreg_nr,
			    inst->bits2.ia1.src0_negate,
			    inst->bits2.ia1.src0_abs,
			    inst->bits2.ia1.src0_address_mode,
			    inst->bits2.ia1.src0_horiz_stride,
			    inst->bits2.ia1.src0_width,
			    inst->bits2.ia1.src0_vert_stride);
	}
    }
    else
    {
	if (inst->bits2.da16.src0_address_mode == BRW_ADDRESS_DIRECT)
	{
	    return src_da16 (file,
			     inst->bits1.da16.src0_reg_type,
			     inst->bits1.da16.src0_reg_file,
			     inst->bits2.da16.src0_vert_stride,
			     inst->bits2.da16.src0_reg_nr,
			     inst->bits2.da16.src0_subreg_nr,
			     inst->bits2.da16.src0_abs,
			     inst->bits2.da16.src0_negate,
			     inst->bits2.da16.src0_swz_x,
			     inst->bits2.da16.src0_swz_y,
			     inst->bits2.da16.src0_swz_z,
			     inst->bits2.da16.src0_swz_w);
	}
	else
	{
	    string (file, "Indirect align16 address mode not supported");
	    return 1;
	}
    }
}

static int src1 (FILE *file, struct brw_instruction *inst)
{
    if (inst->bits1.da1.src1_reg_file == BRW_IMMEDIATE_VALUE)
	return imm (file, inst->bits1.da1.src1_reg_type,
		    inst);
    else if (inst->header.access_mode == BRW_ALIGN_1)
    {
	if (inst->bits3.da1.src1_address_mode == BRW_ADDRESS_DIRECT)
	{
	    return src_da1 (file,
			    inst->bits1.da1.src1_reg_type,
			    inst->bits1.da1.src1_reg_file,
			    inst->bits3.da1.src1_vert_stride,
			    inst->bits3.da1.src1_width,
			    inst->bits3.da1.src1_horiz_stride,
			    inst->bits3.da1.src1_reg_nr,
			    inst->bits3.da1.src1_subreg_nr,
			    inst->bits3.da1.src1_abs,
			    inst->bits3.da1.src1_negate);
	}
	else
	{
	    return src_ia1 (file,
			    inst->bits1.ia1.src1_reg_type,
			    inst->bits1.ia1.src1_reg_file,
			    inst->bits3.ia1.src1_indirect_offset,
			    inst->bits3.ia1.src1_subreg_nr,
			    inst->bits3.ia1.src1_negate,
			    inst->bits3.ia1.src1_abs,
			    inst->bits3.ia1.src1_address_mode,
			    inst->bits3.ia1.src1_horiz_stride,
			    inst->bits3.ia1.src1_width,
			    inst->bits3.ia1.src1_vert_stride);
	}
    }
    else
    {
	if (inst->bits3.da16.src1_address_mode == BRW_ADDRESS_DIRECT)
	{
	    return src_da16 (file,
			     inst->bits1.da16.src1_reg_type,
			     inst->bits1.da16.src1_reg_file,
			     inst->bits3.da16.src1_vert_stride,
			     inst->bits3.da16.src1_reg_nr,
			     inst->bits3.da16.src1_subreg_nr,
			     inst->bits3.da16.src1_abs,
			     inst->bits3.da16.src1_negate,
			     inst->bits3.da16.src1_swz_x,
			     inst->bits3.da16.src1_swz_y,
			     inst->bits3.da16.src1_swz_z,
			     inst->bits3.da16.src1_swz_w);
	}
	else
	{
	    string (file, "Indirect align16 address mode not supported");
	    return 1;
	}
    }
}

static int qtr_ctrl(FILE *file, struct brw_instruction *inst)
{
    int qtr_ctl = inst->header.compression_control;
    int exec_size = 1 << inst->header.execution_size;

    if (exec_size == 8) {
	switch (qtr_ctl) {
	case 0:
	    string (file, " 1Q");
	    break;
	case 1:
	    string (file, " 2Q");
	    break;
	case 2:
	    string (file, " 3Q");
	    break;
	case 3:
	    string (file, " 4Q");
	    break;
	}
    } else if (exec_size == 16){
	if (qtr_ctl < 2)
	    string (file, " 1H");
	else
	    string (file, " 2H");
    }
    return 0;
}

int brw_disasm (FILE *file, struct brw_instruction *inst, int gen)
{
    int	err = 0;
    int space = 0;

    if (inst->header.predicate_control) {
	string (file, "(");
	err |= control (file, "predicate inverse", pred_inv, inst->header.predicate_inverse, NULL);
	format (file, "f%d", gen >= 7 ? inst->bits2.da1.flag_reg_nr : 0);
	if (inst->bits2.da1.flag_subreg_nr)
	    format (file, ".%d", inst->bits2.da1.flag_subreg_nr);
	if (inst->header.access_mode == BRW_ALIGN_1)
	    err |= control (file, "predicate control align1", pred_ctrl_align1,
			    inst->header.predicate_control, NULL);
	else
	    err |= control (file, "predicate control align16", pred_ctrl_align16,
			    inst->header.predicate_control, NULL);
	string (file, ") ");
    }

    err |= print_opcode (file, inst->header.opcode);
    err |= control (file, "saturate", saturate, inst->header.saturate, NULL);
    err |= control (file, "debug control", debug_ctrl, inst->header.debug_control, NULL);

    if (inst->header.opcode == BRW_OPCODE_MATH) {
	string (file, " ");
	err |= control (file, "function", math_function,
			inst->header.destreg__conditionalmod, NULL);
    } else if (inst->header.opcode != BRW_OPCODE_SEND &&
	       inst->header.opcode != BRW_OPCODE_SENDC) {
	err |= control (file, "conditional modifier", conditional_modifier,
			inst->header.destreg__conditionalmod, NULL);

        /* If we're using the conditional modifier, print which flags reg is
         * used for it.  Note that on gen6+, the embedded-condition SEL and
         * control flow doesn't update flags.
         */
	if (inst->header.destreg__conditionalmod &&
            (gen < 6 || (inst->header.opcode != BRW_OPCODE_SEL &&
                         inst->header.opcode != BRW_OPCODE_IF &&
                         inst->header.opcode != BRW_OPCODE_WHILE))) {
	    format (file, ".f%d", gen >= 7 ? inst->bits2.da1.flag_reg_nr : 0);
	    if (inst->bits2.da1.flag_subreg_nr)
		format (file, ".%d", inst->bits2.da1.flag_subreg_nr);
        }
    }

    if (inst->header.opcode != BRW_OPCODE_NOP) {
	string (file, "(");
	err |= control (file, "execution size", exec_size, inst->header.execution_size, NULL);
	string (file, ")");
    }

    if (inst->header.opcode == BRW_OPCODE_SEND && gen < 6)
	format (file, " %d", inst->header.destreg__conditionalmod);

    if (opcode[inst->header.opcode].nsrc == 3) {
       pad (file, 16);
       err |= dest_3src (file, inst);

       pad (file, 32);
       err |= src0_3src (file, inst);

       pad (file, 48);
       err |= src1_3src (file, inst);

       pad (file, 64);
       err |= src2_3src (file, inst);
    } else {
       if (opcode[inst->header.opcode].ndst > 0) {
	  pad (file, 16);
	  err |= dest (file, inst);
       } else if (gen == 7 && (inst->header.opcode == BRW_OPCODE_ELSE ||
			       inst->header.opcode == BRW_OPCODE_ENDIF ||
			       inst->header.opcode == BRW_OPCODE_WHILE)) {
	  format (file, " %d", inst->bits3.break_cont.jip);
       } else if (gen == 6 && (inst->header.opcode == BRW_OPCODE_IF ||
			       inst->header.opcode == BRW_OPCODE_ELSE ||
			       inst->header.opcode == BRW_OPCODE_ENDIF ||
			       inst->header.opcode == BRW_OPCODE_WHILE)) {
	  format (file, " %d", inst->bits1.branch_gen6.jump_count);
       } else if ((gen >= 6 && (inst->header.opcode == BRW_OPCODE_BREAK ||
                                inst->header.opcode == BRW_OPCODE_CONTINUE ||
                                inst->header.opcode == BRW_OPCODE_HALT)) ||
                  (gen == 7 && inst->header.opcode == BRW_OPCODE_IF)) {
	  format (file, " %d %d", inst->bits3.break_cont.uip, inst->bits3.break_cont.jip);
       } else if (inst->header.opcode == BRW_OPCODE_JMPI) {
	  format (file, " %d", inst->bits3.d);
       }

       if (opcode[inst->header.opcode].nsrc > 0) {
	  pad (file, 32);
	  err |= src0 (file, inst);
       }
       if (opcode[inst->header.opcode].nsrc > 1) {
	  pad (file, 48);
	  err |= src1 (file, inst);
       }
    }

    if (inst->header.opcode == BRW_OPCODE_SEND ||
	inst->header.opcode == BRW_OPCODE_SENDC) {
	enum brw_message_target target;

	if (gen >= 6)
	    target = inst->header.destreg__conditionalmod;
	else if (gen == 5)
	    target = inst->bits2.send_gen5.sfid;
	else
	    target = inst->bits3.generic.msg_target;

	newline (file);
	pad (file, 16);
	space = 0;

	if (gen >= 6) {
	   err |= control (file, "target function", target_function_gen6,
			   target, &space);
	} else {
	   err |= control (file, "target function", target_function,
			   target, &space);
	}

	switch (target) {
	case BRW_SFID_MATH:
	    err |= control (file, "math function", math_function,
			    inst->bits3.math.function, &space);
	    err |= control (file, "math saturate", math_saturate,
			    inst->bits3.math.saturate, &space);
	    err |= control (file, "math signed", math_signed,
			    inst->bits3.math.int_type, &space);
	    err |= control (file, "math scalar", math_scalar,
			    inst->bits3.math.data_type, &space);
	    err |= control (file, "math precision", math_precision,
			    inst->bits3.math.precision, &space);
	    break;
	case BRW_SFID_SAMPLER:
	    if (gen >= 7) {
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.sampler_gen7.binding_table_index,
			inst->bits3.sampler_gen7.sampler,
			inst->bits3.sampler_gen7.msg_type,
			inst->bits3.sampler_gen7.simd_mode);
	    } else if (gen >= 5) {
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.sampler_gen5.binding_table_index,
			inst->bits3.sampler_gen5.sampler,
			inst->bits3.sampler_gen5.msg_type,
			inst->bits3.sampler_gen5.simd_mode);
	    } else if (0 /* FINISHME: is_g4x */) {
		format (file, " (%d, %d)",
			inst->bits3.sampler_g4x.binding_table_index,
			inst->bits3.sampler_g4x.sampler);
	    } else {
		format (file, " (%d, %d, ",
			inst->bits3.sampler.binding_table_index,
			inst->bits3.sampler.sampler);
		err |= control (file, "sampler target format",
				sampler_target_format,
				inst->bits3.sampler.return_format, NULL);
		string (file, ")");
	    }
	    break;
	case BRW_SFID_DATAPORT_READ:
	    if (gen >= 6) {
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.gen6_dp.binding_table_index,
			inst->bits3.gen6_dp.msg_control,
			inst->bits3.gen6_dp.msg_type,
			inst->bits3.gen6_dp.send_commit_msg);
	    } else if (gen >= 5 /* FINISHME: || is_g4x */) {
		format (file, " (%d, %d, %d)",
			inst->bits3.dp_read_gen5.binding_table_index,
			inst->bits3.dp_read_gen5.msg_control,
			inst->bits3.dp_read_gen5.msg_type);
	    } else {
		format (file, " (%d, %d, %d)",
			inst->bits3.dp_read.binding_table_index,
			inst->bits3.dp_read.msg_control,
			inst->bits3.dp_read.msg_type);
	    }
	    break;

	case BRW_SFID_DATAPORT_WRITE:
	    if (gen >= 7) {
		format (file, " (");

		err |= control (file, "DP rc message type",
				dp_rc_msg_type_gen6,
				inst->bits3.gen7_dp.msg_type, &space);

		format (file, ", %d, %d, %d)",
			inst->bits3.gen7_dp.binding_table_index,
			inst->bits3.gen7_dp.msg_control,
			inst->bits3.gen7_dp.msg_type);
	    } else if (gen == 6) {
		format (file, " (");

		err |= control (file, "DP rc message type",
				dp_rc_msg_type_gen6,
				inst->bits3.gen6_dp.msg_type, &space);

		format (file, ", %d, %d, %d, %d)",
			inst->bits3.gen6_dp.binding_table_index,
			inst->bits3.gen6_dp.msg_control,
			inst->bits3.gen6_dp.msg_type,
			inst->bits3.gen6_dp.send_commit_msg);
	    } else {
		format (file, " (%d, %d, %d, %d)",
			inst->bits3.dp_write.binding_table_index,
			(inst->bits3.dp_write.last_render_target << 3) |
			inst->bits3.dp_write.msg_control,
			inst->bits3.dp_write.msg_type,
			inst->bits3.dp_write.send_commit_msg);
	    }
	    break;

	case BRW_SFID_URB:
	    if (gen >= 5) {
		format (file, " %d", inst->bits3.urb_gen5.offset);
	    } else {
		format (file, " %d", inst->bits3.urb.offset);
	    }

	    space = 1;
	    if (gen >= 5) {
		err |= control (file, "urb opcode", urb_opcode,
				inst->bits3.urb_gen5.opcode, &space);
	    }
	    err |= control (file, "urb swizzle", urb_swizzle,
			    inst->bits3.urb.swizzle_control, &space);
	    err |= control (file, "urb allocate", urb_allocate,
			    inst->bits3.urb.allocate, &space);
	    err |= control (file, "urb used", urb_used,
			    inst->bits3.urb.used, &space);
	    err |= control (file, "urb complete", urb_complete,
			    inst->bits3.urb.complete, &space);
	    break;
	case BRW_SFID_THREAD_SPAWNER:
	    break;
	case GEN7_SFID_DATAPORT_DATA_CACHE:
           if (gen >= 7) {
              format (file, " (");
d642 790
a1431 1
              err |= control (file, "DP DC0 message type",
d1433 1
a1433 1
                              inst->bits3.gen7_dp.msg_type, &space);
d1435 56
a1490 1
              format (file, ", %d, ", inst->bits3.gen7_dp.binding_table_index);
d1492 7
a1498 39
              switch (inst->bits3.gen7_dp.msg_type) {
              case GEN7_DATAPORT_DC_UNTYPED_ATOMIC_OP:
                 control (file, "atomic op", aop, inst->bits3.ud >> 8 & 0xf,
                          &space);
                 break;
              default:
                 format (file, "%d", inst->bits3.gen7_dp.msg_control);
              }
              format (file, ")");
              break;
           }
           /* FALLTHROUGH */

	case HSW_SFID_DATAPORT_DATA_CACHE_1:
	    if (gen >= 7) {
		format (file, " (");

		err |= control (file, "DP DC1 message type",
				dp_dc1_msg_type_hsw,
				inst->bits3.gen7_dp.msg_type, &space);

		format (file, ", %d, ",
			inst->bits3.gen7_dp.binding_table_index);

                switch (inst->bits3.gen7_dp.msg_type) {
                case HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP:
                case HSW_DATAPORT_DC_PORT1_UNTYPED_ATOMIC_OP_SIMD4X2:
                case HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP:
                case HSW_DATAPORT_DC_PORT1_TYPED_ATOMIC_OP_SIMD4X2:
                case HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP:
                case HSW_DATAPORT_DC_PORT1_ATOMIC_COUNTER_OP_SIMD4X2:
                   control (file, "atomic op", aop,
                            inst->bits3.ud >> 8 & 0xf, &space);
                   break;
                default:
                   format (file, "%d", inst->bits3.gen7_dp.msg_control);
                }
                format (file, ")");
                break;
d1502 58
a1559 57
	default:
	    format (file, "unsupported target %d", target);
	    break;
	}
	if (space)
	    string (file, " ");
	if (gen >= 5) {
	   format (file, "mlen %d",
		   inst->bits3.generic_gen5.msg_length);
	   format (file, " rlen %d",
		   inst->bits3.generic_gen5.response_length);
	} else {
	   format (file, "mlen %d",
		   inst->bits3.generic.msg_length);
	   format (file, " rlen %d",
		   inst->bits3.generic.response_length);
	}
    }
    pad (file, 64);
    if (inst->header.opcode != BRW_OPCODE_NOP) {
	string (file, "{");
	space = 1;
	err |= control(file, "access mode", access_mode, inst->header.access_mode, &space);
	if (gen >= 6)
	    err |= control (file, "write enable control", wectrl, inst->header.mask_control, &space);
	else
	    err |= control (file, "mask control", mask_ctrl, inst->header.mask_control, &space);
	err |= control (file, "dependency control", dep_ctrl, inst->header.dependency_control, &space);

	if (gen >= 6)
	    err |= qtr_ctrl (file, inst);
	else {
	    if (inst->header.compression_control == BRW_COMPRESSION_COMPRESSED &&
		opcode[inst->header.opcode].ndst > 0 &&
		inst->bits1.da1.dest_reg_file == BRW_MESSAGE_REGISTER_FILE &&
		inst->bits1.da1.dest_reg_nr & (1 << 7)) {
		format (file, " compr4");
	    } else {
		err |= control (file, "compression control", compr_ctrl,
				inst->header.compression_control, &space);
	    }
	}

	err |= control (file, "thread control", thread_ctrl, inst->header.thread_control, &space);
	if (gen >= 6)
	    err |= control (file, "acc write control", accwr, inst->header.acc_wr_control, &space);
	if (inst->header.opcode == BRW_OPCODE_SEND ||
	    inst->header.opcode == BRW_OPCODE_SENDC)
	    err |= control (file, "end of thread", end_of_thread,
			    inst->bits3.generic.end_of_thread, &space);
	if (space)
	    string (file, " ");
	string (file, "}");
    }
    string (file, ";");
    newline (file);
    return err;
@


