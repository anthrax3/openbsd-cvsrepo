head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.8;
commitid	4ry2gvZGMXkCUD2n;

1.8
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.7;
commitid	mcxB0JvoI9gTDYXU;

1.7
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.14.04.12;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.15.19;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.46;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.11.21;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.48.28;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "main/glheader.h"
#include "main/macros.h"
#include "main/mtypes.h"
#include "main/simple_list.h"
#include "main/enums.h"
#include "main/mm.h"

#include "intel_screen.h"
#include "intel_tex.h"

#include "i830_context.h"
#include "i830_reg.h"


/* ================================================================
 * Texture combine functions
 */
static GLuint
pass_through(GLuint * state, GLuint blendUnit)
{
   state[0] = (_3DSTATE_MAP_BLEND_OP_CMD(blendUnit) |
               TEXPIPE_COLOR |
               ENABLE_TEXOUTPUT_WRT_SEL |
               TEXOP_OUTPUT_CURRENT |
               DISABLE_TEX_CNTRL_STAGE |
               TEXOP_SCALE_1X | TEXOP_MODIFY_PARMS | TEXBLENDOP_ARG1);
   state[1] = (_3DSTATE_MAP_BLEND_OP_CMD(blendUnit) |
               TEXPIPE_ALPHA |
               ENABLE_TEXOUTPUT_WRT_SEL |
               TEXOP_OUTPUT_CURRENT |
               TEXOP_SCALE_1X | TEXOP_MODIFY_PARMS | TEXBLENDOP_ARG1);
   state[2] = (_3DSTATE_MAP_BLEND_ARG_CMD(blendUnit) |
               TEXPIPE_COLOR |
               TEXBLEND_ARG1 |
               TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_CURRENT);
   state[3] = (_3DSTATE_MAP_BLEND_ARG_CMD(blendUnit) |
               TEXPIPE_ALPHA |
               TEXBLEND_ARG1 |
               TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_CURRENT);

   return 4;
}

static GLuint
emit_factor(GLuint blendUnit, GLuint * state, GLuint count,
            const GLfloat * factor)
{
   GLubyte r, g, b, a;
   GLuint col;

   if (0)
      fprintf(stderr, "emit constant %d: %.2f %.2f %.2f %.2f\n",
              blendUnit, factor[0], factor[1], factor[2], factor[3]);

   UNCLAMPED_FLOAT_TO_UBYTE(r, factor[0]);
   UNCLAMPED_FLOAT_TO_UBYTE(g, factor[1]);
   UNCLAMPED_FLOAT_TO_UBYTE(b, factor[2]);
   UNCLAMPED_FLOAT_TO_UBYTE(a, factor[3]);

   col = ((a << 24) | (r << 16) | (g << 8) | b);

   state[count++] = _3DSTATE_COLOR_FACTOR_N_CMD(blendUnit);
   state[count++] = col;

   return count;
}


static INLINE GLuint
GetTexelOp(GLint unit)
{
   switch (unit) {
   case 0:
      return TEXBLENDARG_TEXEL0;
   case 1:
      return TEXBLENDARG_TEXEL1;
   case 2:
      return TEXBLENDARG_TEXEL2;
   case 3:
      return TEXBLENDARG_TEXEL3;
   default:
      return TEXBLENDARG_TEXEL0;
   }
}


/**
 * Calculate the hardware instuctions to setup the current texture enviromnemt
 * settings.  Since \c gl_texture_unit::_CurrentCombine is used, both
 * "classic" texture enviroments and GL_ARB_texture_env_combine type texture
 * environments are treated identically.
 *
 * \todo
 * This function should return \c bool.  When \c false is returned,
 * it means that an environment is selected that the hardware cannot do.  This
 * is the way the Radeon and R200 drivers work.
 * 
 * \todo
 * Looking at i830_3d_regs.h, it seems the i830 can do part of
 * GL_ATI_texture_env_combine3.  It can handle using \c GL_ONE and
 * \c GL_ZERO as combine inputs (which the code already supports).  It can
 * also handle the \c GL_MODULATE_ADD_ATI mode.  Is it worth investigating
 * partial support for the extension?
 */
GLuint
i830SetTexEnvCombine(struct i830_context * i830,
                     const struct gl_tex_env_combine_state * combine,
                     GLint blendUnit,
                     GLuint texel_op, GLuint * state, const GLfloat * factor)
{
   const GLuint numColorArgs = combine->_NumArgsRGB;
   const GLuint numAlphaArgs = combine->_NumArgsA;

   GLuint blendop;
   GLuint ablendop;
   GLuint args_RGB[3];
   GLuint args_A[3];
   GLuint rgb_shift;
   GLuint alpha_shift;
   bool need_factor = 0;
   int i;
   unsigned used;
   static const GLuint tex_blend_rgb[3] = {
      TEXPIPE_COLOR | TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS,
      TEXPIPE_COLOR | TEXBLEND_ARG2 | TEXBLENDARG_MODIFY_PARMS,
      TEXPIPE_COLOR | TEXBLEND_ARG0 | TEXBLENDARG_MODIFY_PARMS,
   };
   static const GLuint tex_blend_a[3] = {
      TEXPIPE_ALPHA | TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS,
      TEXPIPE_ALPHA | TEXBLEND_ARG2 | TEXBLENDARG_MODIFY_PARMS,
      TEXPIPE_ALPHA | TEXBLEND_ARG0 | TEXBLENDARG_MODIFY_PARMS,
   };

   if (INTEL_DEBUG & DEBUG_TEXTURE)
      fprintf(stderr, "%s\n", __FUNCTION__);


   /* The EXT version of the DOT3 extension does not support the
    * scale factor, but the ARB version (and the version in OpenGL
    * 1.3) does.
    */
   switch (combine->ModeRGB) {
   case GL_DOT3_RGB_EXT:
      alpha_shift = combine->ScaleShiftA;
      rgb_shift = 0;
      break;

   case GL_DOT3_RGBA_EXT:
      alpha_shift = 0;
      rgb_shift = 0;
      break;

   default:
      rgb_shift = combine->ScaleShiftRGB;
      alpha_shift = combine->ScaleShiftA;
      break;
   }


   switch (combine->ModeRGB) {
   case GL_REPLACE:
      blendop = TEXBLENDOP_ARG1;
      break;
   case GL_MODULATE:
      blendop = TEXBLENDOP_MODULATE;
      break;
   case GL_ADD:
      blendop = TEXBLENDOP_ADD;
      break;
   case GL_ADD_SIGNED:
      blendop = TEXBLENDOP_ADDSIGNED;
      break;
   case GL_INTERPOLATE:
      blendop = TEXBLENDOP_BLEND;
      break;
   case GL_SUBTRACT:
      blendop = TEXBLENDOP_SUBTRACT;
      break;
   case GL_DOT3_RGB_EXT:
   case GL_DOT3_RGB:
      blendop = TEXBLENDOP_DOT3;
      break;
   case GL_DOT3_RGBA_EXT:
   case GL_DOT3_RGBA:
      blendop = TEXBLENDOP_DOT3;
      break;
   default:
      return pass_through(state, blendUnit);
   }

   blendop |= (rgb_shift << TEXOP_SCALE_SHIFT);


   /* Handle RGB args */
   for (i = 0; i < 3; i++) {
      switch (combine->SourceRGB[i]) {
      case GL_TEXTURE:
         args_RGB[i] = texel_op;
         break;
      case GL_TEXTURE0:
      case GL_TEXTURE1:
      case GL_TEXTURE2:
      case GL_TEXTURE3:
         args_RGB[i] = GetTexelOp(combine->SourceRGB[i] - GL_TEXTURE0);
         break;
      case GL_CONSTANT:
         args_RGB[i] = TEXBLENDARG_FACTOR_N;
         need_factor = 1;
         break;
      case GL_PRIMARY_COLOR:
         args_RGB[i] = TEXBLENDARG_DIFFUSE;
         break;
      case GL_PREVIOUS:
         args_RGB[i] = TEXBLENDARG_CURRENT;
         break;
      default:
         return pass_through(state, blendUnit);
      }

      switch (combine->OperandRGB[i]) {
      case GL_SRC_COLOR:
         args_RGB[i] |= 0;
         break;
      case GL_ONE_MINUS_SRC_COLOR:
         args_RGB[i] |= TEXBLENDARG_INV_ARG;
         break;
      case GL_SRC_ALPHA:
         args_RGB[i] |= TEXBLENDARG_REPLICATE_ALPHA;
         break;
      case GL_ONE_MINUS_SRC_ALPHA:
         args_RGB[i] |= (TEXBLENDARG_REPLICATE_ALPHA | TEXBLENDARG_INV_ARG);
         break;
      default:
         return pass_through(state, blendUnit);
      }
   }


   /* Need to knobble the alpha calculations of TEXBLENDOP_DOT4 to
    * match the spec.  Can't use DOT3 as it won't propogate values
    * into alpha as required:
    *
    * Note - the global factor is set up with alpha == .5, so 
    * the alpha part of the DOT4 calculation should be zero.
    */
   if (combine->ModeRGB == GL_DOT3_RGBA_EXT ||
       combine->ModeRGB == GL_DOT3_RGBA) {
      ablendop = TEXBLENDOP_DOT4;
      args_A[0] = TEXBLENDARG_FACTOR;   /* the global factor */
      args_A[1] = TEXBLENDARG_FACTOR;
      args_A[2] = TEXBLENDARG_FACTOR;
   }
   else {
      switch (combine->ModeA) {
      case GL_REPLACE:
         ablendop = TEXBLENDOP_ARG1;
         break;
      case GL_MODULATE:
         ablendop = TEXBLENDOP_MODULATE;
         break;
      case GL_ADD:
         ablendop = TEXBLENDOP_ADD;
         break;
      case GL_ADD_SIGNED:
         ablendop = TEXBLENDOP_ADDSIGNED;
         break;
      case GL_INTERPOLATE:
         ablendop = TEXBLENDOP_BLEND;
         break;
      case GL_SUBTRACT:
         ablendop = TEXBLENDOP_SUBTRACT;
         break;
      default:
         return pass_through(state, blendUnit);
      }


      ablendop |= (alpha_shift << TEXOP_SCALE_SHIFT);

      /* Handle A args */
      for (i = 0; i < 3; i++) {
         switch (combine->SourceA[i]) {
         case GL_TEXTURE:
            args_A[i] = texel_op;
            break;
         case GL_TEXTURE0:
         case GL_TEXTURE1:
         case GL_TEXTURE2:
         case GL_TEXTURE3:
            args_A[i] = GetTexelOp(combine->SourceA[i] - GL_TEXTURE0);
            break;
         case GL_CONSTANT:
            args_A[i] = TEXBLENDARG_FACTOR_N;
            need_factor = 1;
            break;
         case GL_PRIMARY_COLOR:
            args_A[i] = TEXBLENDARG_DIFFUSE;
            break;
         case GL_PREVIOUS:
            args_A[i] = TEXBLENDARG_CURRENT;
            break;
         default:
            return pass_through(state, blendUnit);
         }

         switch (combine->OperandA[i]) {
         case GL_SRC_ALPHA:
            args_A[i] |= 0;
            break;
         case GL_ONE_MINUS_SRC_ALPHA:
            args_A[i] |= TEXBLENDARG_INV_ARG;
            break;
         default:
            return pass_through(state, blendUnit);
         }
      }
   }



   /* Native Arg1 == Arg0 in GL_EXT_texture_env_combine spec */
   /* Native Arg2 == Arg1 in GL_EXT_texture_env_combine spec */
   /* Native Arg0 == Arg2 in GL_EXT_texture_env_combine spec */

   /* When we render we need to figure out which is the last really enabled
    * tex unit, and put last stage on it
    */


   /* Build color & alpha pipelines */

   used = 0;
   state[used++] = (_3DSTATE_MAP_BLEND_OP_CMD(blendUnit) |
                    TEXPIPE_COLOR |
                    ENABLE_TEXOUTPUT_WRT_SEL |
                    TEXOP_OUTPUT_CURRENT |
                    DISABLE_TEX_CNTRL_STAGE | TEXOP_MODIFY_PARMS | blendop);
   state[used++] = (_3DSTATE_MAP_BLEND_OP_CMD(blendUnit) |
                    TEXPIPE_ALPHA |
                    ENABLE_TEXOUTPUT_WRT_SEL |
                    TEXOP_OUTPUT_CURRENT | TEXOP_MODIFY_PARMS | ablendop);

   for (i = 0; i < numColorArgs; i++) {
      state[used++] = (_3DSTATE_MAP_BLEND_ARG_CMD(blendUnit) |
                       tex_blend_rgb[i] | args_RGB[i]);
   }

   for (i = 0; i < numAlphaArgs; i++) {
      state[used++] = (_3DSTATE_MAP_BLEND_ARG_CMD(blendUnit) |
                       tex_blend_a[i] | args_A[i]);
   }


   if (need_factor)
      return emit_factor(blendUnit, state, used, factor);
   else
      return used;
}


static void
emit_texblend(struct i830_context *i830, GLuint unit, GLuint blendUnit,
              bool last_stage)
{
   struct gl_texture_unit *texUnit = &i830->intel.ctx.Texture.Unit[unit];
   GLuint tmp[I830_TEXBLEND_SIZE], tmp_sz;


   if (0)
      fprintf(stderr, "%s unit %d\n", __FUNCTION__, unit);

   /* Update i830->state.TexBlend
    */
   tmp_sz = i830SetTexEnvCombine(i830, texUnit->_CurrentCombine, blendUnit,
                                 GetTexelOp(unit), tmp, texUnit->EnvColor);

   if (last_stage)
      tmp[0] |= TEXOP_LAST_STAGE;

   if (tmp_sz != i830->state.TexBlendWordsUsed[blendUnit] ||
       memcmp(tmp, i830->state.TexBlend[blendUnit],
              tmp_sz * sizeof(GLuint))) {

      I830_STATECHANGE(i830, I830_UPLOAD_TEXBLEND(blendUnit));
      memcpy(i830->state.TexBlend[blendUnit], tmp, tmp_sz * sizeof(GLuint));
      i830->state.TexBlendWordsUsed[blendUnit] = tmp_sz;
   }

   I830_ACTIVESTATE(i830, I830_UPLOAD_TEXBLEND(blendUnit), true);
}

static void
emit_passthrough(struct i830_context *i830)
{
   GLuint tmp[I830_TEXBLEND_SIZE], tmp_sz;
   GLuint unit = 0;

   tmp_sz = pass_through(tmp, unit);
   tmp[0] |= TEXOP_LAST_STAGE;

   if (tmp_sz != i830->state.TexBlendWordsUsed[unit] ||
       memcmp(tmp, i830->state.TexBlend[unit], tmp_sz * sizeof(GLuint))) {

      I830_STATECHANGE(i830, I830_UPLOAD_TEXBLEND(unit));
      memcpy(i830->state.TexBlend[unit], tmp, tmp_sz * sizeof(GLuint));
      i830->state.TexBlendWordsUsed[unit] = tmp_sz;
   }

   I830_ACTIVESTATE(i830, I830_UPLOAD_TEXBLEND(unit), true);
}

void
i830EmitTextureBlend(struct i830_context *i830)
{
   struct gl_context *ctx = &i830->intel.ctx;
   GLuint unit, blendunit = 0;

   I830_ACTIVESTATE(i830, I830_UPLOAD_TEXBLEND_ALL, false);

   if (ctx->Texture._MaxEnabledTexImageUnit != -1) {
      for (unit = 0; unit <= ctx->Texture._MaxEnabledTexImageUnit; unit++)
         if (ctx->Texture.Unit[unit]._Current)
            emit_texblend(i830, unit, blendunit++,
                          unit == ctx->Texture._MaxEnabledTexImageUnit);
   } else {
      emit_passthrough(i830);
   }
}
@


1.9
log
@Merge Mesa 10.2.9
@
text
@@


1.8
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d139 1
a139 1
   GLuint numAlphaArgs = combine->_NumArgsA;
d212 1
a212 1
      blendop = TEXBLENDOP_DOT4;
a275 1
      numAlphaArgs = 2;
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d139 1
a139 1
   const GLuint numAlphaArgs = combine->_NumArgsA;
d212 1
a212 1
      blendop = TEXBLENDOP_DOT3;
d276 1
@


1.6
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d443 1
a443 1
   GLuint unit, last_stage = 0, blendunit = 0;
d447 6
a452 10
   if (ctx->Texture._EnabledUnits) {
      for (unit = 0; unit < ctx->Const.MaxTextureUnits; unit++)
         if (ctx->Texture.Unit[unit]._ReallyEnabled)
            last_stage = unit;

      for (unit = 0; unit < ctx->Const.MaxTextureUnits; unit++)
         if (ctx->Texture.Unit[unit]._ReallyEnabled)
            emit_texblend(i830, unit, blendunit++, last_stage == unit);
   }
   else {
@


1.5
log
@Merge Mesa 7.10.3
@
text
@a32 1
#include "main/texstore.h"
d121 1
a121 1
 * This function should return \c GLboolean.  When \c GL_FALSE is returned,
d147 1
a147 1
   GLboolean need_factor = 0;
d390 1
a390 1
              GLboolean last_stage)
d416 1
a416 1
   I830_ACTIVESTATE(i830, I830_UPLOAD_TEXBLEND(blendUnit), GL_TRUE);
d436 1
a436 1
   I830_ACTIVESTATE(i830, I830_UPLOAD_TEXBLEND(unit), GL_TRUE);
d445 1
a445 1
   I830_ACTIVESTATE(i830, I830_UPLOAD_TEXBLEND_ALL, GL_FALSE);
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d443 1
a443 1
   GLcontext *ctx = &i830->intel.ctx;
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a32 1
#include "main/texformat.h"
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d28 8
a35 9
#include "glheader.h"
#include "macros.h"
#include "mtypes.h"
#include "simple_list.h"
#include "enums.h"
#include "texformat.h"
#include "texstore.h"

#include "mm.h"
a37 1
#include "intel_ioctl.h"
@


1.1
log
@Initial revision
@
text
@d49 2
a50 1
static GLuint pass_through( GLuint *state, GLuint blendUnit )
d53 5
a57 7
	       TEXPIPE_COLOR |
	       ENABLE_TEXOUTPUT_WRT_SEL |
	       TEXOP_OUTPUT_CURRENT |
	       DISABLE_TEX_CNTRL_STAGE |
	       TEXOP_SCALE_1X |
	       TEXOP_MODIFY_PARMS |
	       TEXBLENDOP_ARG1);
d59 4
a62 6
	       TEXPIPE_ALPHA |
	       ENABLE_TEXOUTPUT_WRT_SEL |
	       TEXOP_OUTPUT_CURRENT |
	       TEXOP_SCALE_1X |
	       TEXOP_MODIFY_PARMS |
	       TEXBLENDOP_ARG1);
d64 3
a66 4
	       TEXPIPE_COLOR |
	       TEXBLEND_ARG1 |
	       TEXBLENDARG_MODIFY_PARMS |
	       TEXBLENDARG_CURRENT);
d68 3
a70 4
	       TEXPIPE_ALPHA |
	       TEXBLEND_ARG1 |
	       TEXBLENDARG_MODIFY_PARMS |
	       TEXBLENDARG_CURRENT);
d75 3
a77 2
static GLuint emit_factor( GLuint blendUnit, GLuint *state, GLuint count, 
			   const GLfloat *factor )
d81 1
a81 1
      
d84 1
a84 1
	  blendUnit, factor[0], factor[1], factor[2], factor[3]);
d93 1
a93 1
   state[count++] = _3DSTATE_COLOR_FACTOR_N_CMD(blendUnit); 
d100 2
a101 1
static __inline__ GLuint GetTexelOp(GLint unit)
d103 11
a113 6
   switch(unit) {
   case 0: return TEXBLENDARG_TEXEL0;
   case 1: return TEXBLENDARG_TEXEL1;
   case 2: return TEXBLENDARG_TEXEL2;
   case 3: return TEXBLENDARG_TEXEL3;
   default: return TEXBLENDARG_TEXEL0;
d137 4
a140 6
i830SetTexEnvCombine(i830ContextPtr i830,
		     const struct gl_tex_env_combine_state * combine,
		     GLint blendUnit,
		     GLuint texel_op,
		     GLuint *state,
		     const GLfloat *factor )
d165 1
a165 1
   if(INTEL_DEBUG&DEBUG_TEXTURE)
d191 2
a192 2
   switch(combine->ModeRGB) {
   case GL_REPLACE: 
d195 1
a195 1
   case GL_MODULATE: 
d198 1
a198 1
   case GL_ADD: 
d202 1
a202 1
      blendop = TEXBLENDOP_ADDSIGNED; 
d205 1
a205 1
      blendop = TEXBLENDOP_BLEND; 
d207 1
a207 1
   case GL_SUBTRACT: 
d218 2
a219 2
   default: 
      return pass_through( state, blendUnit );
d226 5
a230 5
   for(i = 0; i < 3; i++) {
      switch(combine->SourceRGB[i]) {
      case GL_TEXTURE: 
	 args_RGB[i] = texel_op;
	 break;
d235 2
a236 2
	 args_RGB[i] = GetTexelOp( combine->SourceRGB[i] - GL_TEXTURE0 );
	 break;
d238 3
a240 3
	 args_RGB[i] = TEXBLENDARG_FACTOR_N; 
	 need_factor = 1;
	 break;
d242 2
a243 2
	 args_RGB[i] = TEXBLENDARG_DIFFUSE;
	 break;
d245 4
a248 4
	 args_RGB[i] = TEXBLENDARG_CURRENT; 
	 break;
      default: 
	 return pass_through( state, blendUnit );
d251 15
a265 16
      switch(combine->OperandRGB[i]) {
      case GL_SRC_COLOR: 
	 args_RGB[i] |= 0;
	 break;
      case GL_ONE_MINUS_SRC_COLOR: 
	 args_RGB[i] |= TEXBLENDARG_INV_ARG;
	 break;
      case GL_SRC_ALPHA: 
	 args_RGB[i] |= TEXBLENDARG_REPLICATE_ALPHA;
	 break;
      case GL_ONE_MINUS_SRC_ALPHA: 
	 args_RGB[i] |= (TEXBLENDARG_REPLICATE_ALPHA | 
			 TEXBLENDARG_INV_ARG);
	 break;
      default: 
	 return pass_through( state, blendUnit );
d277 2
a278 2
   if ( combine->ModeRGB == GL_DOT3_RGBA_EXT || 
	combine->ModeRGB == GL_DOT3_RGBA ) {
d280 1
a280 1
      args_A[0] = TEXBLENDARG_FACTOR; /* the global factor */
d285 10
a294 10
      switch(combine->ModeA) {
      case GL_REPLACE: 
	 ablendop = TEXBLENDOP_ARG1;
	 break;
      case GL_MODULATE: 
	 ablendop = TEXBLENDOP_MODULATE;
	 break;
      case GL_ADD: 
	 ablendop = TEXBLENDOP_ADD;
	 break;
d296 2
a297 2
	 ablendop = TEXBLENDOP_ADDSIGNED; 
	 break;
d299 5
a303 5
	 ablendop = TEXBLENDOP_BLEND; 
	 break;
      case GL_SUBTRACT: 
	 ablendop = TEXBLENDOP_SUBTRACT;
	 break;
d305 1
a305 1
	 return pass_through( state, blendUnit );
d312 35
a346 35
      for(i = 0; i < 3; i++) {
	 switch(combine->SourceA[i]) {
	 case GL_TEXTURE: 
	    args_A[i] = texel_op;
	    break;
	 case GL_TEXTURE0:
	 case GL_TEXTURE1:
	 case GL_TEXTURE2:
	 case GL_TEXTURE3:
	    args_A[i] = GetTexelOp( combine->SourceA[i] - GL_TEXTURE0 );
	    break;
	 case GL_CONSTANT:
	    args_A[i] = TEXBLENDARG_FACTOR_N; 
	    need_factor = 1;
	    break;
	 case GL_PRIMARY_COLOR:
	    args_A[i] = TEXBLENDARG_DIFFUSE; 
	    break;
	 case GL_PREVIOUS:
	    args_A[i] = TEXBLENDARG_CURRENT; 
	    break;
	 default: 
	    return pass_through( state, blendUnit );
	 }

	 switch(combine->OperandA[i]) {
	 case GL_SRC_ALPHA: 
	    args_A[i] |= 0;
	    break;
	 case GL_ONE_MINUS_SRC_ALPHA: 
	    args_A[i] |= TEXBLENDARG_INV_ARG;
	    break;
	 default: 
	    return pass_through( state, blendUnit );
	 }
d365 4
a368 6
		    TEXPIPE_COLOR |
		    ENABLE_TEXOUTPUT_WRT_SEL |
		    TEXOP_OUTPUT_CURRENT |
		    DISABLE_TEX_CNTRL_STAGE |
		    TEXOP_MODIFY_PARMS |
		    blendop);
d370 3
a372 5
		    TEXPIPE_ALPHA |
		    ENABLE_TEXOUTPUT_WRT_SEL |
		    TEXOP_OUTPUT_CURRENT |
		    TEXOP_MODIFY_PARMS |
		    ablendop);
d374 1
a374 1
   for ( i = 0 ; i < numColorArgs ; i++ ) {
d376 1
a376 1
		       tex_blend_rgb[i] | args_RGB[i]);
d379 1
a379 1
   for ( i = 0 ; i < numAlphaArgs ; i++ ) {
d381 1
a381 1
		       tex_blend_a[i] | args_A[i]);
d385 3
a387 3
   if (need_factor) 
      return emit_factor( blendUnit, state, used, factor );
   else 
d392 3
a394 2
static void emit_texblend( i830ContextPtr i830, GLuint unit, GLuint blendUnit,
			   GLboolean last_stage )
d400 2
a401 1
   if (0) fprintf(stderr, "%s unit %d\n", __FUNCTION__, unit);
d404 3
a406 4
    */ 
   tmp_sz = i830SetTexEnvCombine(i830, texUnit->_CurrentCombine, blendUnit, 
				 GetTexelOp(unit), tmp,
				 texUnit->EnvColor );
d408 1
a408 1
   if (last_stage) 
d412 5
a416 4
       memcmp( tmp, i830->state.TexBlend[blendUnit], tmp_sz * sizeof(GLuint))) {
      
      I830_STATECHANGE( i830, I830_UPLOAD_TEXBLEND(blendUnit) );
      memcpy( i830->state.TexBlend[blendUnit], tmp, tmp_sz * sizeof(GLuint));
d423 2
a424 1
static void emit_passthrough( i830ContextPtr i830 )
d429 1
a429 1
   tmp_sz = pass_through( tmp, unit );
d433 4
a436 4
       memcmp( tmp, i830->state.TexBlend[unit], tmp_sz * sizeof(GLuint))) {
      
      I830_STATECHANGE( i830, I830_UPLOAD_TEXBLEND(unit) );
      memcpy( i830->state.TexBlend[unit], tmp, tmp_sz * sizeof(GLuint));
d443 2
a444 1
void i830EmitTextureBlend( i830ContextPtr i830 )
d452 7
a458 7
      for (unit = 0 ; unit < ctx->Const.MaxTextureUnits ; unit++)
	 if (ctx->Texture.Unit[unit]._ReallyEnabled) 
	    last_stage = unit;

      for (unit = 0 ; unit < ctx->Const.MaxTextureUnits ; unit++)
	 if (ctx->Texture.Unit[unit]._ReallyEnabled) 
	    emit_texblend( i830, unit, blendunit++, last_stage == unit );
d461 1
a461 1
      emit_passthrough( i830 );
a463 1

@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d28 9
a36 7
#include "main/glheader.h"
#include "main/macros.h"
#include "main/mtypes.h"
#include "main/simple_list.h"
#include "main/enums.h"
#include "main/texstore.h"
#include "main/mm.h"
d39 1
d49 1
a49 2
static GLuint
pass_through(GLuint * state, GLuint blendUnit)
d52 7
a58 5
               TEXPIPE_COLOR |
               ENABLE_TEXOUTPUT_WRT_SEL |
               TEXOP_OUTPUT_CURRENT |
               DISABLE_TEX_CNTRL_STAGE |
               TEXOP_SCALE_1X | TEXOP_MODIFY_PARMS | TEXBLENDOP_ARG1);
d60 6
a65 4
               TEXPIPE_ALPHA |
               ENABLE_TEXOUTPUT_WRT_SEL |
               TEXOP_OUTPUT_CURRENT |
               TEXOP_SCALE_1X | TEXOP_MODIFY_PARMS | TEXBLENDOP_ARG1);
d67 4
a70 3
               TEXPIPE_COLOR |
               TEXBLEND_ARG1 |
               TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_CURRENT);
d72 4
a75 3
               TEXPIPE_ALPHA |
               TEXBLEND_ARG1 |
               TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_CURRENT);
d80 2
a81 3
static GLuint
emit_factor(GLuint blendUnit, GLuint * state, GLuint count,
            const GLfloat * factor)
d85 1
a85 1

d88 1
a88 1
              blendUnit, factor[0], factor[1], factor[2], factor[3]);
d97 1
a97 1
   state[count++] = _3DSTATE_COLOR_FACTOR_N_CMD(blendUnit);
d104 1
a104 2
static INLINE GLuint
GetTexelOp(GLint unit)
d106 6
a111 11
   switch (unit) {
   case 0:
      return TEXBLENDARG_TEXEL0;
   case 1:
      return TEXBLENDARG_TEXEL1;
   case 2:
      return TEXBLENDARG_TEXEL2;
   case 3:
      return TEXBLENDARG_TEXEL3;
   default:
      return TEXBLENDARG_TEXEL0;
d135 6
a140 4
i830SetTexEnvCombine(struct i830_context * i830,
                     const struct gl_tex_env_combine_state * combine,
                     GLint blendUnit,
                     GLuint texel_op, GLuint * state, const GLfloat * factor)
d165 1
a165 1
   if (INTEL_DEBUG & DEBUG_TEXTURE)
d191 2
a192 2
   switch (combine->ModeRGB) {
   case GL_REPLACE:
d195 1
a195 1
   case GL_MODULATE:
d198 1
a198 1
   case GL_ADD:
d202 1
a202 1
      blendop = TEXBLENDOP_ADDSIGNED;
d205 1
a205 1
      blendop = TEXBLENDOP_BLEND;
d207 1
a207 1
   case GL_SUBTRACT:
d218 2
a219 2
   default:
      return pass_through(state, blendUnit);
d226 5
a230 5
   for (i = 0; i < 3; i++) {
      switch (combine->SourceRGB[i]) {
      case GL_TEXTURE:
         args_RGB[i] = texel_op;
         break;
d235 2
a236 2
         args_RGB[i] = GetTexelOp(combine->SourceRGB[i] - GL_TEXTURE0);
         break;
d238 3
a240 3
         args_RGB[i] = TEXBLENDARG_FACTOR_N;
         need_factor = 1;
         break;
d242 2
a243 2
         args_RGB[i] = TEXBLENDARG_DIFFUSE;
         break;
d245 4
a248 4
         args_RGB[i] = TEXBLENDARG_CURRENT;
         break;
      default:
         return pass_through(state, blendUnit);
d251 16
a266 15
      switch (combine->OperandRGB[i]) {
      case GL_SRC_COLOR:
         args_RGB[i] |= 0;
         break;
      case GL_ONE_MINUS_SRC_COLOR:
         args_RGB[i] |= TEXBLENDARG_INV_ARG;
         break;
      case GL_SRC_ALPHA:
         args_RGB[i] |= TEXBLENDARG_REPLICATE_ALPHA;
         break;
      case GL_ONE_MINUS_SRC_ALPHA:
         args_RGB[i] |= (TEXBLENDARG_REPLICATE_ALPHA | TEXBLENDARG_INV_ARG);
         break;
      default:
         return pass_through(state, blendUnit);
d278 2
a279 2
   if (combine->ModeRGB == GL_DOT3_RGBA_EXT ||
       combine->ModeRGB == GL_DOT3_RGBA) {
d281 1
a281 1
      args_A[0] = TEXBLENDARG_FACTOR;   /* the global factor */
d286 10
a295 10
      switch (combine->ModeA) {
      case GL_REPLACE:
         ablendop = TEXBLENDOP_ARG1;
         break;
      case GL_MODULATE:
         ablendop = TEXBLENDOP_MODULATE;
         break;
      case GL_ADD:
         ablendop = TEXBLENDOP_ADD;
         break;
d297 2
a298 2
         ablendop = TEXBLENDOP_ADDSIGNED;
         break;
d300 5
a304 5
         ablendop = TEXBLENDOP_BLEND;
         break;
      case GL_SUBTRACT:
         ablendop = TEXBLENDOP_SUBTRACT;
         break;
d306 1
a306 1
         return pass_through(state, blendUnit);
d313 35
a347 35
      for (i = 0; i < 3; i++) {
         switch (combine->SourceA[i]) {
         case GL_TEXTURE:
            args_A[i] = texel_op;
            break;
         case GL_TEXTURE0:
         case GL_TEXTURE1:
         case GL_TEXTURE2:
         case GL_TEXTURE3:
            args_A[i] = GetTexelOp(combine->SourceA[i] - GL_TEXTURE0);
            break;
         case GL_CONSTANT:
            args_A[i] = TEXBLENDARG_FACTOR_N;
            need_factor = 1;
            break;
         case GL_PRIMARY_COLOR:
            args_A[i] = TEXBLENDARG_DIFFUSE;
            break;
         case GL_PREVIOUS:
            args_A[i] = TEXBLENDARG_CURRENT;
            break;
         default:
            return pass_through(state, blendUnit);
         }

         switch (combine->OperandA[i]) {
         case GL_SRC_ALPHA:
            args_A[i] |= 0;
            break;
         case GL_ONE_MINUS_SRC_ALPHA:
            args_A[i] |= TEXBLENDARG_INV_ARG;
            break;
         default:
            return pass_through(state, blendUnit);
         }
d366 6
a371 4
                    TEXPIPE_COLOR |
                    ENABLE_TEXOUTPUT_WRT_SEL |
                    TEXOP_OUTPUT_CURRENT |
                    DISABLE_TEX_CNTRL_STAGE | TEXOP_MODIFY_PARMS | blendop);
d373 5
a377 3
                    TEXPIPE_ALPHA |
                    ENABLE_TEXOUTPUT_WRT_SEL |
                    TEXOP_OUTPUT_CURRENT | TEXOP_MODIFY_PARMS | ablendop);
d379 1
a379 1
   for (i = 0; i < numColorArgs; i++) {
d381 1
a381 1
                       tex_blend_rgb[i] | args_RGB[i]);
d384 1
a384 1
   for (i = 0; i < numAlphaArgs; i++) {
d386 1
a386 1
                       tex_blend_a[i] | args_A[i]);
d390 3
a392 3
   if (need_factor)
      return emit_factor(blendUnit, state, used, factor);
   else
d397 2
a398 3
static void
emit_texblend(struct i830_context *i830, GLuint unit, GLuint blendUnit,
              GLboolean last_stage)
d404 1
a404 2
   if (0)
      fprintf(stderr, "%s unit %d\n", __FUNCTION__, unit);
d407 4
a410 3
    */
   tmp_sz = i830SetTexEnvCombine(i830, texUnit->_CurrentCombine, blendUnit,
                                 GetTexelOp(unit), tmp, texUnit->EnvColor);
d412 1
a412 1
   if (last_stage)
d416 4
a419 5
       memcmp(tmp, i830->state.TexBlend[blendUnit],
              tmp_sz * sizeof(GLuint))) {

      I830_STATECHANGE(i830, I830_UPLOAD_TEXBLEND(blendUnit));
      memcpy(i830->state.TexBlend[blendUnit], tmp, tmp_sz * sizeof(GLuint));
d426 1
a426 2
static void
emit_passthrough(struct i830_context *i830)
d431 1
a431 1
   tmp_sz = pass_through(tmp, unit);
d435 4
a438 4
       memcmp(tmp, i830->state.TexBlend[unit], tmp_sz * sizeof(GLuint))) {

      I830_STATECHANGE(i830, I830_UPLOAD_TEXBLEND(unit));
      memcpy(i830->state.TexBlend[unit], tmp, tmp_sz * sizeof(GLuint));
d445 1
a445 2
void
i830EmitTextureBlend(struct i830_context *i830)
d447 1
a447 1
   struct gl_context *ctx = &i830->intel.ctx;
d453 7
a459 7
      for (unit = 0; unit < ctx->Const.MaxTextureUnits; unit++)
         if (ctx->Texture.Unit[unit]._ReallyEnabled)
            last_stage = unit;

      for (unit = 0; unit < ctx->Const.MaxTextureUnits; unit++)
         if (ctx->Texture.Unit[unit]._ReallyEnabled)
            emit_texblend(i830, unit, blendunit++, last_stage == unit);
d462 1
a462 1
      emit_passthrough(i830);
d465 1
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d33 1
d122 1
a122 1
 * This function should return \c bool.  When \c false is returned,
d148 1
a148 1
   bool need_factor = 0;
d391 1
a391 1
              bool last_stage)
d417 1
a417 1
   I830_ACTIVESTATE(i830, I830_UPLOAD_TEXBLEND(blendUnit), true);
d437 1
a437 1
   I830_ACTIVESTATE(i830, I830_UPLOAD_TEXBLEND(unit), true);
d446 1
a446 1
   I830_ACTIVESTATE(i830, I830_UPLOAD_TEXBLEND_ALL, false);
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d443 1
a443 1
   GLuint unit, blendunit = 0;
d447 10
a456 6
   if (ctx->Texture._MaxEnabledTexImageUnit != -1) {
      for (unit = 0; unit <= ctx->Texture._MaxEnabledTexImageUnit; unit++)
         if (ctx->Texture.Unit[unit]._Current)
            emit_texblend(i830, unit, blendunit++,
                          unit == ctx->Texture._MaxEnabledTexImageUnit);
   } else {
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d139 1
a139 1
   GLuint numAlphaArgs = combine->_NumArgsA;
d212 1
a212 1
      blendop = TEXBLENDOP_DOT4;
a275 1
      numAlphaArgs = 2;
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d139 1
a139 1
   const GLuint numAlphaArgs = combine->_NumArgsA;
d212 1
a212 1
      blendop = TEXBLENDOP_DOT3;
d276 1
@


