head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.7
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.04.14;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.14;	author matthieu;	state dead;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.36;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.10;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.28.15;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.15.22;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.47;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.6
date	2015.01.25.14.11.25;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.7
date	2015.02.20.22.48.31;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/


#include "main/glheader.h"
#include "main/context.h"
#include "main/extensions.h"
#include "main/fbobject.h"
#include "main/framebuffer.h"
#include "main/imports.h"
#include "main/points.h"
#include "main/renderbuffer.h"

#include "swrast/swrast.h"
#include "swrast_setup/swrast_setup.h"
#include "tnl/tnl.h"
#include "drivers/common/driverfuncs.h"
#include "drivers/common/meta.h"

#include "intel_chipset.h"
#include "intel_buffers.h"
#include "intel_tex.h"
#include "intel_batchbuffer.h"
#include "intel_clear.h"
#include "intel_extensions.h"
#include "intel_pixel.h"
#include "intel_regions.h"
#include "intel_buffer_objects.h"
#include "intel_fbo.h"
#include "intel_bufmgr.h"
#include "intel_screen.h"
#include "intel_mipmap_tree.h"

#include "utils.h"
#include "../glsl/ralloc.h"

int INTEL_DEBUG = (0);

const char *const i915_vendor_string = "Intel Open Source Technology Center";

const char *
i915_get_renderer_string(unsigned deviceID)
{
   const char *chipset;
   static char buffer[128];

   switch (deviceID) {
#undef CHIPSET
#define CHIPSET(id, symbol, str) case id: chipset = str; break;
#include "pci_ids/i915_pci_ids.h"
   default:
      chipset = "Unknown Intel Chipset";
      break;
   }

   (void) driGetRendererString(buffer, chipset, 0);
   return buffer;
}

static const GLubyte *
intelGetString(struct gl_context * ctx, GLenum name)
{
   const struct intel_context *const intel = intel_context(ctx);

   switch (name) {
   case GL_VENDOR:
      return (GLubyte *) i915_vendor_string;

   case GL_RENDERER:
      return
         (GLubyte *) i915_get_renderer_string(intel->intelScreen->deviceID);

   default:
      return NULL;
   }
}

#define flushFront(screen)      ((screen)->image.loader ? (screen)->image.loader->flushFrontBuffer : (screen)->dri2.loader->flushFrontBuffer)

static void
intel_flush_front(struct gl_context *ctx)
{
   struct intel_context *intel = intel_context(ctx);
    __DRIcontext *driContext = intel->driContext;
    __DRIdrawable *driDrawable = driContext->driDrawablePriv;
    __DRIscreen *const screen = intel->intelScreen->driScrnPriv;

    if (intel->front_buffer_dirty && _mesa_is_winsys_fbo(ctx->DrawBuffer)) {
      if (flushFront(screen) && 
          driDrawable &&
          driDrawable->loaderPrivate) {
         flushFront(screen)(driDrawable, driDrawable->loaderPrivate);

	 /* We set the dirty bit in intel_prepare_render() if we're
	  * front buffer rendering once we get there.
	  */
	 intel->front_buffer_dirty = false;
      }
   }
}

static void
intel_update_image_buffers(struct intel_context *intel, __DRIdrawable *drawable);

static unsigned
intel_bits_per_pixel(const struct intel_renderbuffer *rb)
{
   return _mesa_get_format_bytes(intel_rb_format(rb)) * 8;
}

static void
intel_query_dri2_buffers(struct intel_context *intel,
			 __DRIdrawable *drawable,
			 __DRIbuffer **buffers,
			 int *count);

static void
intel_process_dri2_buffer(struct intel_context *intel,
			  __DRIdrawable *drawable,
			  __DRIbuffer *buffer,
			  struct intel_renderbuffer *rb,
			  const char *buffer_name);

static void
intel_update_dri2_buffers(struct intel_context *intel, __DRIdrawable *drawable)
{
   __DRIbuffer *buffers = NULL;
   int i, count;
   const char *region_name;
   struct intel_renderbuffer *rb;
   struct gl_framebuffer *fb = drawable->driverPrivate;

   intel_query_dri2_buffers(intel, drawable, &buffers, &count);

   if (buffers == NULL)
      return;

   for (i = 0; i < count; i++) {
      switch (buffers[i].attachment) {
      case __DRI_BUFFER_FRONT_LEFT:
         rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
         region_name = "dri2 front buffer";
         break;

      case __DRI_BUFFER_FAKE_FRONT_LEFT:
         rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
         region_name = "dri2 fake front buffer";
         break;

      case __DRI_BUFFER_BACK_LEFT:
         rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);
         region_name = "dri2 back buffer";
         break;

      case __DRI_BUFFER_DEPTH:
      case __DRI_BUFFER_HIZ:
      case __DRI_BUFFER_DEPTH_STENCIL:
      case __DRI_BUFFER_STENCIL:
      case __DRI_BUFFER_ACCUM:
      default:
         fprintf(stderr,
                 "unhandled buffer attach event, attachment type %d\n",
                 buffers[i].attachment);
         return;
      }

      intel_process_dri2_buffer(intel, drawable, &buffers[i], rb, region_name);
   }
}

void
intel_update_renderbuffers(__DRIcontext *context, __DRIdrawable *drawable)
{
   struct intel_context *intel = context->driverPrivate;
   __DRIscreen *screen = intel->intelScreen->driScrnPriv;

   /* Set this up front, so that in case our buffers get invalidated
    * while we're getting new buffers, we don't clobber the stamp and
    * thus ignore the invalidate. */
   drawable->lastStamp = drawable->dri2.stamp;

   if (unlikely(INTEL_DEBUG & DEBUG_DRI))
      fprintf(stderr, "enter %s, drawable %p\n", __func__, drawable);

   if (screen->image.loader)
      intel_update_image_buffers(intel, drawable);
   else
      intel_update_dri2_buffers(intel, drawable);

   driUpdateFramebufferSize(&intel->ctx, drawable);
}

/**
 * intel_prepare_render should be called anywhere that curent read/drawbuffer
 * state is required.
 */
void
intel_prepare_render(struct intel_context *intel)
{
   __DRIcontext *driContext = intel->driContext;
   __DRIdrawable *drawable;

   drawable = driContext->driDrawablePriv;
   if (drawable && drawable->dri2.stamp != driContext->dri2.draw_stamp) {
      if (drawable->lastStamp != drawable->dri2.stamp)
	 intel_update_renderbuffers(driContext, drawable);
      intel_draw_buffer(&intel->ctx);
      driContext->dri2.draw_stamp = drawable->dri2.stamp;
   }

   drawable = driContext->driReadablePriv;
   if (drawable && drawable->dri2.stamp != driContext->dri2.read_stamp) {
      if (drawable->lastStamp != drawable->dri2.stamp)
	 intel_update_renderbuffers(driContext, drawable);
      driContext->dri2.read_stamp = drawable->dri2.stamp;
   }

   /* If we're currently rendering to the front buffer, the rendering
    * that will happen next will probably dirty the front buffer.  So
    * mark it as dirty here.
    */
   if (intel->is_front_buffer_rendering)
      intel->front_buffer_dirty = true;

   /* Wait for the swapbuffers before the one we just emitted, so we
    * don't get too many swaps outstanding for apps that are GPU-heavy
    * but not CPU-heavy.
    *
    * We're using intelDRI2Flush (called from the loader before
    * swapbuffer) and glFlush (for front buffer rendering) as the
    * indicator that a frame is done and then throttle when we get
    * here as we prepare to render the next frame.  At this point for
    * round trips for swap/copy and getting new buffers are done and
    * we'll spend less time waiting on the GPU.
    *
    * Unfortunately, we don't have a handle to the batch containing
    * the swap, and getting our hands on that doesn't seem worth it,
    * so we just us the first batch we emitted after the last swap.
    */
   if (intel->need_throttle && intel->first_post_swapbuffers_batch) {
      if (!intel->disable_throttling)
         drm_intel_bo_wait_rendering(intel->first_post_swapbuffers_batch);
      drm_intel_bo_unreference(intel->first_post_swapbuffers_batch);
      intel->first_post_swapbuffers_batch = NULL;
      intel->need_throttle = false;
   }
}

static void
intel_noninvalidate_viewport(struct gl_context *ctx)
{
    struct intel_context *intel = intel_context(ctx);
    __DRIcontext *driContext = intel->driContext;

    intelCalcViewport(ctx);

    if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
       dri2InvalidateDrawable(driContext->driDrawablePriv);
       dri2InvalidateDrawable(driContext->driReadablePriv);
    }
}

static void
intel_viewport(struct gl_context *ctx)
{
    intelCalcViewport(ctx);
}

static const struct dri_debug_control debug_control[] = {
   { "tex",   DEBUG_TEXTURE},
   { "state", DEBUG_STATE},
   { "blit",  DEBUG_BLIT},
   { "mip",   DEBUG_MIPTREE},
   { "fall",  DEBUG_PERF},
   { "perf",  DEBUG_PERF},
   { "bat",   DEBUG_BATCH},
   { "pix",   DEBUG_PIXEL},
   { "buf",   DEBUG_BUFMGR},
   { "reg",   DEBUG_REGION},
   { "fbo",   DEBUG_FBO},
   { "fs",    DEBUG_WM },
   { "sync",  DEBUG_SYNC},
   { "dri",   DEBUG_DRI },
   { "stats", DEBUG_STATS },
   { "wm",    DEBUG_WM },
   { "aub",   DEBUG_AUB },
   { NULL,    0 }
};


static void
intelInvalidateState(struct gl_context * ctx, GLuint new_state)
{
    struct intel_context *intel = intel_context(ctx);

    if (ctx->swrast_context)
       _swrast_InvalidateState(ctx, new_state);
   _vbo_InvalidateState(ctx, new_state);

   intel->NewGLState |= new_state;

   if (intel->vtbl.invalidate_state)
      intel->vtbl.invalidate_state( intel, new_state );
}

void
intel_flush_rendering_to_batch(struct gl_context *ctx)
{
   struct intel_context *intel = intel_context(ctx);

   if (intel->Fallback)
      _swrast_flush(ctx);

   INTEL_FIREVERTICES(intel);
}

void
_intel_flush(struct gl_context *ctx, const char *file, int line)
{
   struct intel_context *intel = intel_context(ctx);

   intel_flush_rendering_to_batch(ctx);

   if (intel->batch.used)
      _intel_batchbuffer_flush(intel, file, line);
}

static void
intel_glFlush(struct gl_context *ctx)
{
   struct intel_context *intel = intel_context(ctx);

   intel_flush(ctx);
   intel_flush_front(ctx);
   if (intel->is_front_buffer_rendering)
      intel->need_throttle = true;
}

void
intelFinish(struct gl_context * ctx)
{
   struct intel_context *intel = intel_context(ctx);

   intel_flush(ctx);
   intel_flush_front(ctx);

   if (intel->batch.last_bo)
      drm_intel_bo_wait_rendering(intel->batch.last_bo);
}

void
intelInitDriverFunctions(struct dd_function_table *functions)
{
   _mesa_init_driver_functions(functions);

   functions->Flush = intel_glFlush;
   functions->Finish = intelFinish;
   functions->GetString = intelGetString;
   functions->UpdateState = intelInvalidateState;

   intelInitTextureFuncs(functions);
   intelInitTextureImageFuncs(functions);
   intelInitTextureSubImageFuncs(functions);
   intelInitTextureCopyImageFuncs(functions);
   intelInitClearFuncs(functions);
   intelInitBufferFuncs(functions);
   intelInitPixelFuncs(functions);
   intelInitBufferObjectFuncs(functions);
   intel_init_syncobj_functions(functions);
}

bool
intelInitContext(struct intel_context *intel,
                 int api,
                 unsigned major_version,
                 unsigned minor_version,
                 uint32_t flags,
                 const struct gl_config * mesaVis,
                 __DRIcontext * driContextPriv,
                 void *sharedContextPrivate,
                 struct dd_function_table *functions,
                 unsigned *dri_ctx_error)
{
   struct gl_context *ctx = &intel->ctx;
   struct gl_context *shareCtx = (struct gl_context *) sharedContextPrivate;
   __DRIscreen *sPriv = driContextPriv->driScreenPriv;
   struct intel_screen *intelScreen = sPriv->driverPrivate;
   int bo_reuse_mode;

   /* Can't rely on invalidate events, fall back to glViewport hack */
   if (!driContextPriv->driScreenPriv->dri2.useInvalidate)
      functions->Viewport = intel_noninvalidate_viewport;
   else
      functions->Viewport = intel_viewport;

   intel->intelScreen = intelScreen;

   if (!_mesa_initialize_context(&intel->ctx, api, mesaVis, shareCtx,
                                 functions)) {
      *dri_ctx_error = __DRI_CTX_ERROR_NO_MEMORY;
      printf("%s: failed to init mesa context\n", __FUNCTION__);
      return false;
   }

   driContextPriv->driverPrivate = intel;
   intel->driContext = driContextPriv;
   intel->driFd = sPriv->fd;

   intel->gen = intelScreen->gen;

   const int devID = intelScreen->deviceID;

   intel->is_945 = IS_945(devID);

   intel->has_swizzling = intel->intelScreen->hw_has_swizzling;

   memset(&ctx->TextureFormatSupported,
	  0, sizeof(ctx->TextureFormatSupported));

   driParseConfigFiles(&intel->optionCache, &intelScreen->optionCache,
                       sPriv->myNum, "i915");
   intel->maxBatchSize = 4096;

   /* Estimate the size of the mappable aperture into the GTT.  There's an
    * ioctl to get the whole GTT size, but not one to get the mappable subset.
    * It turns out it's basically always 256MB, though some ancient hardware
    * was smaller.
    */
   uint32_t gtt_size = 256 * 1024 * 1024;
   if (intel->gen == 2)
      gtt_size = 128 * 1024 * 1024;

   /* We don't want to map two objects such that a memcpy between them would
    * just fault one mapping in and then the other over and over forever.  So
    * we would need to divide the GTT size by 2.  Additionally, some GTT is
    * taken up by things like the framebuffer and the ringbuffer and such, so
    * be more conservative.
    */
   intel->max_gtt_map_object_size = gtt_size / 4;

   intel->bufmgr = intelScreen->bufmgr;

   bo_reuse_mode = driQueryOptioni(&intel->optionCache, "bo_reuse");
   switch (bo_reuse_mode) {
   case DRI_CONF_BO_REUSE_DISABLED:
      break;
   case DRI_CONF_BO_REUSE_ALL:
      intel_bufmgr_gem_enable_reuse(intel->bufmgr);
      break;
   }

   ctx->Const.MinLineWidth = 1.0;
   ctx->Const.MinLineWidthAA = 1.0;
   ctx->Const.MaxLineWidth = 5.0;
   ctx->Const.MaxLineWidthAA = 5.0;
   ctx->Const.LineWidthGranularity = 0.5;

   ctx->Const.MinPointSize = 1.0;
   ctx->Const.MinPointSizeAA = 1.0;
   ctx->Const.MaxPointSize = 255.0;
   ctx->Const.MaxPointSizeAA = 3.0;
   ctx->Const.PointSizeGranularity = 1.0;

   ctx->Const.StripTextureBorder = GL_TRUE;

   /* reinitialize the context point state.
    * It depend on constants in __struct gl_contextRec::Const
    */
   _mesa_init_point(ctx);

   ctx->Const.MaxRenderbufferSize = 2048;

   _swrast_CreateContext(ctx);
   _vbo_CreateContext(ctx);
   if (ctx->swrast_context) {
      _tnl_CreateContext(ctx);
      _swsetup_CreateContext(ctx);

      /* Configure swrast to match hardware characteristics: */
      _swrast_allow_pixel_fog(ctx, false);
      _swrast_allow_vertex_fog(ctx, true);
   }

   _mesa_meta_init(ctx);

   intel->hw_stencil = mesaVis && mesaVis->stencilBits && mesaVis->depthBits == 24;
   intel->hw_stipple = 1;

   intel->RenderIndex = ~0;

   intelInitExtensions(ctx);

   INTEL_DEBUG = driParseDebugString(getenv("INTEL_DEBUG"), debug_control);
   if (INTEL_DEBUG & DEBUG_BUFMGR)
      dri_bufmgr_set_debug(intel->bufmgr, true);
   if (INTEL_DEBUG & DEBUG_PERF)
      intel->perf_debug = true;

   if (INTEL_DEBUG & DEBUG_AUB)
      drm_intel_bufmgr_gem_set_aub_dump(intel->bufmgr, true);

   intel_batchbuffer_init(intel);

   intel_fbo_init(intel);

   intel->use_early_z = driQueryOptionb(&intel->optionCache, "early_z");

   intel->prim.primitive = ~0;

   /* Force all software fallbacks */
   if (driQueryOptionb(&intel->optionCache, "no_rast")) {
      fprintf(stderr, "disabling 3D rasterization\n");
      intel->no_rast = 1;
   }

   if (driQueryOptionb(&intel->optionCache, "always_flush_batch")) {
      fprintf(stderr, "flushing batchbuffer before/after each draw call\n");
      intel->always_flush_batch = 1;
   }

   if (driQueryOptionb(&intel->optionCache, "always_flush_cache")) {
      fprintf(stderr, "flushing GPU caches before/after each draw call\n");
      intel->always_flush_cache = 1;
   }

   if (driQueryOptionb(&intel->optionCache, "disable_throttling")) {
      fprintf(stderr, "disabling flush throttling\n");
      intel->disable_throttling = 1;
   }

   return true;
}

void
intelDestroyContext(__DRIcontext * driContextPriv)
{
   struct intel_context *intel =
      (struct intel_context *) driContextPriv->driverPrivate;
   struct gl_context *ctx = &intel->ctx;

   assert(intel);               /* should never be null */
   if (intel) {
      INTEL_FIREVERTICES(intel);

      /* Dump a final BMP in case the application doesn't call SwapBuffers */
      if (INTEL_DEBUG & DEBUG_AUB) {
         intel_batchbuffer_flush(intel);
	 aub_dump_bmp(&intel->ctx);
      }

      _mesa_meta_free(&intel->ctx);

      intel->vtbl.destroy(intel);

      if (ctx->swrast_context) {
         _swsetup_DestroyContext(&intel->ctx);
         _tnl_DestroyContext(&intel->ctx);
      }
      _vbo_DestroyContext(&intel->ctx);

      if (ctx->swrast_context)
         _swrast_DestroyContext(&intel->ctx);
      intel->Fallback = 0x0;      /* don't call _swrast_Flush later */

      intel_batchbuffer_free(intel);

      free(intel->prim.vb);
      intel->prim.vb = NULL;
      drm_intel_bo_unreference(intel->prim.vb_bo);
      intel->prim.vb_bo = NULL;
      drm_intel_bo_unreference(intel->first_post_swapbuffers_batch);
      intel->first_post_swapbuffers_batch = NULL;

      driDestroyOptionCache(&intel->optionCache);

      /* free the Mesa context */
      _mesa_free_context_data(&intel->ctx);

      _math_matrix_dtr(&intel->ViewportMatrix);

      ralloc_free(intel);
      driContextPriv->driverPrivate = NULL;
   }
}

GLboolean
intelUnbindContext(__DRIcontext * driContextPriv)
{
   /* Unset current context and dispath table */
   _mesa_make_current(NULL, NULL, NULL);

   return true;
}

GLboolean
intelMakeCurrent(__DRIcontext * driContextPriv,
                 __DRIdrawable * driDrawPriv,
                 __DRIdrawable * driReadPriv)
{
   struct intel_context *intel;
   GET_CURRENT_CONTEXT(curCtx);

   if (driContextPriv)
      intel = (struct intel_context *) driContextPriv->driverPrivate;
   else
      intel = NULL;

   /* According to the glXMakeCurrent() man page: "Pending commands to
    * the previous context, if any, are flushed before it is released."
    * But only flush if we're actually changing contexts.
    */
   if (intel_context(curCtx) && intel_context(curCtx) != intel) {
      _mesa_flush(curCtx);
   }

   if (driContextPriv) {
      struct gl_context *ctx = &intel->ctx;
      struct gl_framebuffer *fb, *readFb;
      
      if (driDrawPriv == NULL && driReadPriv == NULL) {
	 fb = _mesa_get_incomplete_framebuffer();
	 readFb = _mesa_get_incomplete_framebuffer();
      } else {
	 fb = driDrawPriv->driverPrivate;
	 readFb = driReadPriv->driverPrivate;
	 driContextPriv->dri2.draw_stamp = driDrawPriv->dri2.stamp - 1;
	 driContextPriv->dri2.read_stamp = driReadPriv->dri2.stamp - 1;
      }

      intel_prepare_render(intel);
      _mesa_make_current(ctx, fb, readFb);

      /* We do this in intel_prepare_render() too, but intel->ctx.DrawBuffer
       * is NULL at that point.  We can't call _mesa_makecurrent()
       * first, since we need the buffer size for the initial
       * viewport.  So just call intel_draw_buffer() again here. */
      intel_draw_buffer(ctx);
   }
   else {
      _mesa_make_current(NULL, NULL, NULL);
   }

   return true;
}

/**
 * \brief Query DRI2 to obtain a DRIdrawable's buffers.
 *
 * To determine which DRI buffers to request, examine the renderbuffers
 * attached to the drawable's framebuffer. Then request the buffers with
 * DRI2GetBuffers() or DRI2GetBuffersWithFormat().
 *
 * This is called from intel_update_renderbuffers().
 *
 * \param drawable      Drawable whose buffers are queried.
 * \param buffers       [out] List of buffers returned by DRI2 query.
 * \param buffer_count  [out] Number of buffers returned.
 *
 * \see intel_update_renderbuffers()
 * \see DRI2GetBuffers()
 * \see DRI2GetBuffersWithFormat()
 */
static void
intel_query_dri2_buffers(struct intel_context *intel,
			 __DRIdrawable *drawable,
			 __DRIbuffer **buffers,
			 int *buffer_count)
{
   __DRIscreen *screen = intel->intelScreen->driScrnPriv;
   struct gl_framebuffer *fb = drawable->driverPrivate;
   int i = 0;
   unsigned attachments[8];

   struct intel_renderbuffer *front_rb;
   struct intel_renderbuffer *back_rb;

   front_rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
   back_rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);

   memset(attachments, 0, sizeof(attachments));
   if ((intel->is_front_buffer_rendering ||
	intel->is_front_buffer_reading ||
	!back_rb) && front_rb) {
      /* If a fake front buffer is in use, then querying for
       * __DRI_BUFFER_FRONT_LEFT will cause the server to copy the image from
       * the real front buffer to the fake front buffer.  So before doing the
       * query, we need to make sure all the pending drawing has landed in the
       * real front buffer.
       */
      intel_flush(&intel->ctx);
      intel_flush_front(&intel->ctx);

      attachments[i++] = __DRI_BUFFER_FRONT_LEFT;
      attachments[i++] = intel_bits_per_pixel(front_rb);
   } else if (front_rb && intel->front_buffer_dirty) {
      /* We have pending front buffer rendering, but we aren't querying for a
       * front buffer.  If the front buffer we have is a fake front buffer,
       * the X server is going to throw it away when it processes the query.
       * So before doing the query, make sure all the pending drawing has
       * landed in the real front buffer.
       */
      intel_flush(&intel->ctx);
      intel_flush_front(&intel->ctx);
   }

   if (back_rb) {
      attachments[i++] = __DRI_BUFFER_BACK_LEFT;
      attachments[i++] = intel_bits_per_pixel(back_rb);
   }

   assert(i <= ARRAY_SIZE(attachments));

   *buffers = screen->dri2.loader->getBuffersWithFormat(drawable,
							&drawable->w,
							&drawable->h,
							attachments, i / 2,
							buffer_count,
							drawable->loaderPrivate);
}

/**
 * \brief Assign a DRI buffer's DRM region to a renderbuffer.
 *
 * This is called from intel_update_renderbuffers().
 *
 * \par Note:
 *    DRI buffers whose attachment point is DRI2BufferStencil or
 *    DRI2BufferDepthStencil are handled as special cases.
 *
 * \param buffer_name is a human readable name, such as "dri2 front buffer",
 *        that is passed to intel_region_alloc_for_handle().
 *
 * \see intel_update_renderbuffers()
 * \see intel_region_alloc_for_handle()
 */
static void
intel_process_dri2_buffer(struct intel_context *intel,
			  __DRIdrawable *drawable,
			  __DRIbuffer *buffer,
			  struct intel_renderbuffer *rb,
			  const char *buffer_name)
{
   struct intel_region *region = NULL;

   if (!rb)
      return;

   /* We try to avoid closing and reopening the same BO name, because the first
    * use of a mapping of the buffer involves a bunch of page faulting which is
    * moderately expensive.
    */
   if (rb->mt &&
       rb->mt->region &&
       rb->mt->region->name == buffer->name)
      return;

   if (unlikely(INTEL_DEBUG & DEBUG_DRI)) {
      fprintf(stderr,
	      "attaching buffer %d, at %d, cpp %d, pitch %d\n",
	      buffer->name, buffer->attachment,
	      buffer->cpp, buffer->pitch);
   }

   intel_miptree_release(&rb->mt);
   region = intel_region_alloc_for_handle(intel->intelScreen,
                                          buffer->cpp,
                                          drawable->w,
                                          drawable->h,
                                          buffer->pitch,
                                          buffer->name,
                                          buffer_name);
   if (!region)
      return;

   rb->mt = intel_miptree_create_for_dri2_buffer(intel,
                                                 buffer->attachment,
                                                 intel_rb_format(rb),
                                                 region);
   intel_region_release(&region);
}

/**
 * \brief Query DRI Image loader to obtain a DRIdrawable's buffers.
 *
 * To determine which DRI buffers to request, examine the renderbuffers
 * attached to the drawable's framebuffer. Then request the buffers with
 * dri3
 *
 * This is called from intel_update_renderbuffers().
 *
 * \param drawable      Drawable whose buffers are queried.
 * \param buffers       [out] List of buffers returned by DRI2 query.
 * \param buffer_count  [out] Number of buffers returned.
 *
 * \see intel_update_renderbuffers()
 */

static void
intel_update_image_buffer(struct intel_context *intel,
                          __DRIdrawable *drawable,
                          struct intel_renderbuffer *rb,
                          __DRIimage *buffer,
                          enum __DRIimageBufferMask buffer_type)
{
   struct intel_region *region = buffer->region;

   if (!rb || !region)
      return;

   unsigned num_samples = rb->Base.Base.NumSamples;

   if (rb->mt &&
       rb->mt->region &&
       rb->mt->region == region)
      return;

   intel_miptree_release(&rb->mt);
   rb->mt = intel_miptree_create_for_image_buffer(intel,
                                                  buffer_type,
                                                  intel_rb_format(rb),
                                                  num_samples,
                                                  region);
}


static void
intel_update_image_buffers(struct intel_context *intel, __DRIdrawable *drawable)
{
   struct gl_framebuffer *fb = drawable->driverPrivate;
   __DRIscreen *screen = intel->intelScreen->driScrnPriv;
   struct intel_renderbuffer *front_rb;
   struct intel_renderbuffer *back_rb;
   struct __DRIimageList images;
   unsigned int format;
   uint32_t buffer_mask = 0;

   front_rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
   back_rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);

   if (back_rb)
      format = intel_rb_format(back_rb);
   else if (front_rb)
      format = intel_rb_format(front_rb);
   else
      return;

   if ((intel->is_front_buffer_rendering || intel->is_front_buffer_reading || !back_rb) && front_rb)
      buffer_mask |= __DRI_IMAGE_BUFFER_FRONT;

   if (back_rb)
      buffer_mask |= __DRI_IMAGE_BUFFER_BACK;

   (*screen->image.loader->getBuffers) (drawable,
                                        driGLFormatToImageFormat(format),
                                        &drawable->dri2.stamp,
                                        drawable->loaderPrivate,
                                        buffer_mask,
                                        &images);

   if (images.image_mask & __DRI_IMAGE_BUFFER_FRONT) {
      drawable->w = images.front->width;
      drawable->h = images.front->height;
      intel_update_image_buffer(intel,
                                drawable,
                                front_rb,
                                images.front,
                                __DRI_IMAGE_BUFFER_FRONT);
   }
   if (images.image_mask & __DRI_IMAGE_BUFFER_BACK) {
      drawable->w = images.back->width;
      drawable->h = images.back->height;
      intel_update_image_buffer(intel,
                                drawable,
                                back_rb,
                                images.back,
                                __DRI_IMAGE_BUFFER_BACK);
   }
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d59 1
a59 1
#include "util/ralloc.h"
d510 1
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d59 1
a59 1
#include "../glsl/ralloc.h"
a509 1
   intel->hw_stencil = mesaVis && mesaVis->stencilBits && mesaVis->depthBits == 24;
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
a60 1
#ifndef INTEL_DEBUG
a61 1
#endif
d63 20
a87 2
   const char *chipset;
   static char buffer[128];
d91 1
a91 2
      return (GLubyte *) "Intel Open Source Technology Center";
      break;
d94 2
a95 11
      switch (intel->intelScreen->deviceID) {
#undef CHIPSET
#define CHIPSET(id, symbol, str) case id: chipset = str; break;
#include "pci_ids/i915_pci_ids.h"
      default:
         chipset = "Unknown Intel Chipset";
         break;
      }

      (void) driGetRendererString(buffer, chipset, 0);
      return (GLubyte *) buffer;
d102 2
d113 1
a113 1
      if (screen->dri2.loader->flushFrontBuffer != NULL &&
d116 1
a116 2
         screen->dri2.loader->flushFrontBuffer(driDrawable,
                                               driDrawable->loaderPrivate);
d126 3
d148 47
a197 2
   struct gl_framebuffer *fb = drawable->driverPrivate;
   struct intel_renderbuffer *rb;
d199 1
a199 3
   __DRIbuffer *buffers = NULL;
   int i, count;
   const char *region_name;
d209 4
a212 36
   intel_query_dri2_buffers(intel, drawable, &buffers, &count);

   if (buffers == NULL)
      return;

   for (i = 0; i < count; i++) {
       switch (buffers[i].attachment) {
       case __DRI_BUFFER_FRONT_LEFT:
	   rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
	   region_name = "dri2 front buffer";
	   break;

       case __DRI_BUFFER_FAKE_FRONT_LEFT:
	   rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
	   region_name = "dri2 fake front buffer";
	   break;

       case __DRI_BUFFER_BACK_LEFT:
	   rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);
	   region_name = "dri2 back buffer";
	   break;

       case __DRI_BUFFER_DEPTH:
       case __DRI_BUFFER_HIZ:
       case __DRI_BUFFER_DEPTH_STENCIL:
       case __DRI_BUFFER_STENCIL:
       case __DRI_BUFFER_ACCUM:
       default:
	   fprintf(stderr,
		   "unhandled buffer attach event, attachment type %d\n",
		   buffers[i].attachment);
	   return;
       }

       intel_process_dri2_buffer(intel, drawable, &buffers[i], rb, region_name);
   }
d274 1
a274 1
intel_viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
d279 1
a279 2
    if (intel->saved_viewport)
	intel->saved_viewport(ctx, x, y, w, h);
d287 6
a395 39
static bool
validate_context_version(struct intel_screen *screen,
                         int mesa_api,
                         unsigned major_version,
                         unsigned minor_version,
                         unsigned *dri_ctx_error)
{
   unsigned req_version = 10 * major_version + minor_version;
   unsigned max_version = 0;

   switch (mesa_api) {
   case API_OPENGL_COMPAT:
      max_version = screen->max_gl_compat_version;
      break;
   case API_OPENGL_CORE:
      max_version = screen->max_gl_core_version;
      break;
   case API_OPENGLES:
      max_version = screen->max_gl_es1_version;
      break;
   case API_OPENGLES2:
      max_version = screen->max_gl_es2_version;
      break;
   default:
      max_version = 0;
      break;
   }

   if (max_version == 0) {
      *dri_ctx_error = __DRI_CTX_ERROR_BAD_API;
      return false;
   } else if (req_version > max_version) {
      *dri_ctx_error = __DRI_CTX_ERROR_BAD_VERSION;
      return false;
   }

   return true;
}

d401 1
a412 12
   struct gl_config visual;

   /* we can't do anything without a connection to the device */
   if (intelScreen->bufmgr == NULL) {
      *dri_ctx_error = __DRI_CTX_ERROR_NO_MEMORY;
      return false;
   }

   if (!validate_context_version(intelScreen,
                                 api, major_version, minor_version,
                                 dri_ctx_error))
      return false;
d415 3
a417 2
   if (!driContextPriv->driScreenPriv->dri2.useInvalidate) {
      intel->saved_viewport = functions->Viewport;
a418 6
   }

   if (mesaVis == NULL) {
      memset(&visual, 0, sizeof visual);
      mesaVis = &visual;
   }
d510 1
a510 1
   intel->hw_stencil = mesaVis->stencilBits && mesaVis->depthBits == 24;
d804 98
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d29 8
a36 8
#include "glheader.h"
#include "context.h"
#include "matrix.h"
#include "simple_list.h"
#include "extensions.h"
#include "framebuffer.h"
#include "imports.h"
#include "points.h"
a40 5
#include "vbo/vbo.h"

#include "tnl/t_pipeline.h"
#include "tnl/t_vertex.h"

d42 1
d44 2
a45 5
#include "intel_screen.h"

#include "i830_dri.h"
#include "i830_common.h"

a46 3
#include "intel_span.h"
#include "intel_tris.h"
#include "intel_ioctl.h"
d48 9
a57 1
#include "vblank.h"
d59 2
a60 1
#include "xmlpool.h" /* for symbolic values of enum-type options */
a64 31
#define need_GL_ARB_multisample
#define need_GL_ARB_point_parameters
#define need_GL_ARB_texture_compression
#define need_GL_ARB_vertex_buffer_object
#define need_GL_ARB_vertex_program
#define need_GL_ARB_window_pos
#define need_GL_EXT_blend_color
#define need_GL_EXT_blend_equation_separate
#define need_GL_EXT_blend_func_separate
#define need_GL_EXT_blend_minmax
#define need_GL_EXT_cull_vertex
#define need_GL_EXT_fog_coord
#define need_GL_EXT_multi_draw_arrays
#define need_GL_EXT_secondary_color
#define need_GL_NV_vertex_program
#include "extension_helper.h"

#ifndef VERBOSE
int VERBOSE = 0;
#endif

#if DEBUG_LOCKING
char *prevLockFile;
int prevLockLine;
#endif

/***************************************
 * Mesa's Driver Functions
 ***************************************/

#define DRIVER_DATE "20061017"
d66 2
a67 1
const GLubyte *intelGetString( GLcontext *ctx, GLenum name )
d69 2
a70 1
   const char * chipset;
d75 1
a75 1
      return (GLubyte *)"Tungsten Graphics, Inc";
d77 1
a77 1
      
d79 4
a82 25
      switch (INTEL_CONTEXT(ctx)->intelScreen->deviceID) {
      case PCI_CHIP_845_G:
	 chipset = "Intel(R) 845G"; break;
      case PCI_CHIP_I830_M:
	 chipset = "Intel(R) 830M"; break;
      case PCI_CHIP_I855_GM:
	 chipset = "Intel(R) 852GM/855GM"; break;
      case PCI_CHIP_I865_G:
	 chipset = "Intel(R) 865G"; break;
      case PCI_CHIP_I915_G:
	 chipset = "Intel(R) 915G"; break;
      case PCI_CHIP_I915_GM:
	 chipset = "Intel(R) 915GM"; break;
      case PCI_CHIP_I945_G:
	 chipset = "Intel(R) 945G"; break;
      case PCI_CHIP_I945_GM:
	 chipset = "Intel(R) 945GM"; break;
      case PCI_CHIP_I945_GME:
	 chipset = "Intel(R) 945GME"; break;
      case PCI_CHIP_G33_G:
	 chipset = "Intel(R) G33"; break;
      case PCI_CHIP_Q35_G:
	 chipset = "Intel(R) Q35"; break;
      case PCI_CHIP_Q33_G:
	 chipset = "Intel(R) Q33"; break;
d84 2
a85 1
	 chipset = "Unknown Intel Chipset"; break;
d88 1
a88 1
      (void) driGetRendererString( buffer, chipset, DRIVER_DATE, 0 );
d96 99
d197 2
a198 5
 * Extension strings exported by the intel driver.
 *
 * \note
 * It appears that ARB_texture_env_crossbar has "disappeared" compared to the
 * old i830-specific driver.
d200 2
a201 1
const struct dri_extension card_extensions[] =
d203 54
a256 39
    { "GL_ARB_multisample",                GL_ARB_multisample_functions },
    { "GL_ARB_multitexture",               NULL },
    { "GL_ARB_point_parameters",           GL_ARB_point_parameters_functions },
    { "GL_ARB_texture_border_clamp",       NULL },
    { "GL_ARB_texture_compression",        GL_ARB_texture_compression_functions },
    { "GL_ARB_texture_cube_map",           NULL },
    { "GL_ARB_texture_env_add",            NULL },
    { "GL_ARB_texture_env_combine",        NULL },
    { "GL_ARB_texture_env_dot3",           NULL },
    { "GL_ARB_texture_mirrored_repeat",    NULL },
    { "GL_ARB_texture_rectangle",          NULL },
    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
    { "GL_ARB_vertex_program",             GL_ARB_vertex_program_functions },
    { "GL_ARB_window_pos",                 GL_ARB_window_pos_functions },
    { "GL_EXT_blend_color",                GL_EXT_blend_color_functions },
    { "GL_EXT_blend_equation_separate",    GL_EXT_blend_equation_separate_functions },
    { "GL_EXT_blend_func_separate",        GL_EXT_blend_func_separate_functions },
    { "GL_EXT_blend_minmax",               GL_EXT_blend_minmax_functions },
    { "GL_EXT_blend_subtract",             NULL },
    { "GL_EXT_cull_vertex",                GL_EXT_cull_vertex_functions },
    { "GL_EXT_fog_coord",                  GL_EXT_fog_coord_functions },
    { "GL_EXT_multi_draw_arrays",          GL_EXT_multi_draw_arrays_functions },
    { "GL_EXT_secondary_color",            GL_EXT_secondary_color_functions },
    { "GL_EXT_stencil_wrap",               NULL },
    { "GL_EXT_texture_edge_clamp",         NULL },
    { "GL_EXT_texture_env_combine",        NULL },
    { "GL_EXT_texture_env_dot3",           NULL },
    { "GL_EXT_texture_filter_anisotropic", NULL },
    { "GL_EXT_texture_lod_bias",           NULL },
    { "GL_3DFX_texture_compression_FXT1",  NULL },
    { "GL_APPLE_client_storage",           NULL },
    { "GL_MESA_pack_invert",               NULL },
    { "GL_MESA_ycbcr_texture",             NULL },
    { "GL_NV_blend_square",                NULL },
    { "GL_NV_vertex_program",              GL_NV_vertex_program_functions },
    { "GL_NV_vertex_program1_1",           NULL },
    { "GL_SGIS_generate_mipmap",           NULL },
    { NULL,                                NULL }
};
d258 2
a259 1
extern const struct tnl_pipeline_stage _intel_render_stage;
d261 25
a285 15
static const struct tnl_pipeline_stage *intel_pipeline[] = {
   &_tnl_vertex_transform_stage,
   &_tnl_vertex_cull_stage,
   &_tnl_normal_transform_stage,
   &_tnl_lighting_stage,
   &_tnl_fog_coordinate_stage,
   &_tnl_texgen_stage,
   &_tnl_texture_transform_stage,
   &_tnl_point_attenuation_stage,
   &_tnl_vertex_program_stage,
#if 1
   &_intel_render_stage,     /* ADD: unclipped rastersetup-to-dma */
#endif
   &_tnl_render_stage,
   0,
d289 2
a290 1
static const struct dri_debug_control debug_control[] =
d292 7
a298 15
    { "fall",  DEBUG_FALLBACKS },
    { "tex",   DEBUG_TEXTURE },
    { "ioctl", DEBUG_IOCTL },
    { "prim",  DEBUG_PRIMS },
    { "vert",  DEBUG_VERTS },
    { "state", DEBUG_STATE },
    { "verb",  DEBUG_VERBOSE },
    { "dri",   DEBUG_DRI },
    { "dma",   DEBUG_DMA },
    { "san",   DEBUG_SANITY },
    { "sync",  DEBUG_SYNC },
    { "sleep", DEBUG_SLEEP },
    { "pix",   DEBUG_PIXEL },
    { NULL,    0 }
};
d300 3
d304 2
a305 1
static void intelInvalidateState( GLcontext *ctx, GLuint new_state )
d307 6
a312 6
   _swrast_InvalidateState( ctx, new_state );
   _swsetup_InvalidateState( ctx, new_state );
   _vbo_InvalidateState( ctx, new_state );
   _tnl_InvalidateState( ctx, new_state );
   _tnl_invalidate_vertex_state( ctx, new_state );
   INTEL_CONTEXT(ctx)->NewGLState |= new_state;
d315 2
a316 2

void intelInitDriverFunctions( struct dd_function_table *functions )
d318 1
a318 1
   _mesa_init_driver_functions( functions );
d320 1
a320 5
   functions->Clear = intelClear;
   functions->Flush = intelglFlush;
   functions->Finish = intelFinish;
   functions->GetString = intelGetString;
   functions->UpdateState = intelInvalidateState;
d322 2
a323 3
   intelInitTextureFuncs( functions );
   intelInitPixelFuncs( functions );
   intelInitStateFuncs( functions );
d326 2
a327 1
static void intel_emit_invarient_state( GLcontext *ctx )
d329 6
d337 7
d345 3
d349 2
a350 5
GLboolean intelInitContext( intelContextPtr intel,
			    const __GLcontextModes *mesaVis,
			    __DRIcontextPrivate *driContextPriv,
			    void *sharedContextPrivate,
			    struct dd_function_table *functions )
d352 6
a357 7
   GLcontext *ctx = &intel->ctx;
   GLcontext *shareCtx = (GLcontext *) sharedContextPrivate;
   __DRIscreenPrivate *sPriv = driContextPriv->driScreenPriv;
   intelScreenPrivate *intelScreen = (intelScreenPrivate *)sPriv->private;
   drmI830Sarea *saPriv = (drmI830Sarea *)
      (((GLubyte *)sPriv->pSAREA)+intelScreen->sarea_priv_offset);
   int fthrottle_mode;
d359 98
a456 5
   if (!_mesa_initialize_context(&intel->ctx,
				 mesaVis, shareCtx, 
				 functions,
				 (void*) intel))
      return GL_FALSE;
d459 10
a468 3
   intel->intelScreen = intelScreen;
   intel->driScreen = sPriv;
   intel->sarea = saPriv;
d470 2
d473 3
a475 2
   (void) memset( intel->texture_heaps, 0, sizeof( intel->texture_heaps ) );
   make_empty_list( & intel->swapped );
d477 16
a492 2
   driParseConfigFiles (&intel->optionCache, &intelScreen->optionCache,
			intel->driScreen->myNum, "i915");
d494 10
a503 1
   ctx->Const.MaxTextureMaxAnisotropy = 2.0;
d507 3
a509 3
   ctx->Const.MaxLineWidth = 3.0;
   ctx->Const.MaxLineWidthAA = 3.0;
   ctx->Const.LineWidthGranularity = 1.0;
d517 2
d520 1
a520 1
    * It depend on constants in __GLcontextRec::Const
d524 1
a524 13
   /* Initialize the software rasterizer and helper modules. */
   _swrast_CreateContext( ctx );
   _vbo_CreateContext( ctx );
   _tnl_CreateContext( ctx );
   _swsetup_CreateContext( ctx );

   /* Install the customized pipeline: */
   _tnl_destroy_pipeline( ctx );
   _tnl_install_pipeline( ctx, intel_pipeline );

   /* Configure swrast to match hardware characteristics: */
   _swrast_allow_pixel_fog( ctx, GL_FALSE );
   _swrast_allow_vertex_fog( ctx, GL_TRUE );
d526 5
a530 7
   /* Dri stuff */
   intel->hHWContext = driContextPriv->hHWContext;
   intel->driFd = sPriv->fd;
   intel->driHwLock = (drmLock *) &sPriv->pSAREA->lock;

   intel->hw_stencil = mesaVis->stencilBits && mesaVis->depthBits == 24;
   intel->hw_stipple = 1;
d532 3
a534 18
   switch(mesaVis->depthBits) {
   case 0:			/* what to do in this case? */
   case 16:
      intel->depth_scale = 1.0/0xffff;
      intel->polygon_offset_scale = 1.0/0xffff;
      intel->depth_clear_mask = ~0;
      intel->ClearDepth = 0xffff;
      break;
   case 24:
      intel->depth_scale = 1.0/0xffffff;
      intel->polygon_offset_scale = 2.0/0xffffff; /* req'd to pass glean */
      intel->depth_clear_mask = 0x00ffffff;
      intel->stencil_clear_mask = 0xff000000;
      intel->ClearDepth = 0x00ffffff;
      break;
   default:
      assert(0); 
      break;
d537 1
a537 3
   /* Initialize swrast, tnl driver tables: */
   intelInitSpanFuncs( ctx );
   intelInitTriFuncs( ctx );
d539 2
d544 1
a544 6
   fthrottle_mode = driQueryOptioni(&intel->optionCache, "fthrottle_mode");
   intel->iw.irq_seq = -1;
   intel->irqsEmitted = 0;

   intel->do_irqs = (intel->intelScreen->irq_active &&
		     fthrottle_mode == DRI_CONF_FTHROTTLE_IRQS);
d546 5
a550 1
   intel->do_usleeps = (fthrottle_mode == DRI_CONF_FTHROTTLE_USLEEPS);
d552 2
a553 2
   intel->vblank_flags = (intel->intelScreen->irq_active != 0)
       ? driGetDefaultVBlankFlags(&intel->optionCache) : VBLANK_FLAG_NO_IRQ;
d555 1
a555 2
   (*dri_interface->getUST)(&intel->swap_ust);
   _math_matrix_ctr (&intel->ViewportMatrix);
d557 1
a557 1
   driInitExtensions( ctx, card_extensions, GL_TRUE );
d559 1
a559 7
   if (intel->ctx.Mesa_DXTn) {
     _mesa_enable_extension( ctx, "GL_EXT_texture_compression_s3tc" );
     _mesa_enable_extension( ctx, "GL_S3_s3tc" );
   }
   else if (driQueryOptionb (&intel->optionCache, "force_s3tc_enable")) {
     _mesa_enable_extension( ctx, "GL_EXT_texture_compression_s3tc" );
   }
a560 8
/*    driInitTextureObjects( ctx, & intel->swapped, */
/* 			  DRI_TEXMGR_DO_TEXTURE_1D | */
/* 			  DRI_TEXMGR_DO_TEXTURE_2D |  */
/* 			  DRI_TEXMGR_DO_TEXTURE_RECT ); */


   intelInitBatchBuffer(&intel->ctx);
   intel->prim.flush = intel_emit_invarient_state;
d563 5
d569 4
a572 6
#if DO_DEBUG
   INTEL_DEBUG  = driParseDebugString( getenv( "INTEL_DEBUG" ),
				       debug_control );
   INTEL_DEBUG |= driParseDebugString( getenv( "INTEL_DEBUG" ),
				       debug_control );
#endif
d574 4
a577 4
#ifndef VERBOSE
   if (getenv("INTEL_VERBOSE"))
      VERBOSE=1;
#endif
d579 3
a581 4
   if (getenv("INTEL_NO_RAST") || 
       getenv("INTEL_NO_RAST")) {
      fprintf(stderr, "disabling 3D rasterization\n");
      FALLBACK(intel, INTEL_FALLBACK_USER, 1); 
d584 1
a584 1
   return GL_TRUE;
d587 2
a588 1
void intelDestroyContext(__DRIcontextPrivate *driContextPriv)
d590 3
a592 1
   intelContextPtr intel = (intelContextPtr) driContextPriv->driverPrivate;
d594 1
a594 1
   assert(intel); /* should never be null */
d596 1
a596 1
      GLboolean   release_texture_heaps;
d598 5
a602 1
      INTEL_FIREVERTICES( intel );
d604 1
a604 1
      intel->vtbl.destroy( intel );
d606 1
a606 4
      release_texture_heaps = (intel->ctx.Shared->RefCount == 1);
      _swsetup_DestroyContext (&intel->ctx);
      _tnl_DestroyContext (&intel->ctx);
      _vbo_DestroyContext (&intel->ctx);
d608 5
a612 2
      _swrast_DestroyContext (&intel->ctx);
      intel->Fallback = 0;	/* don't call _swrast_Flush later */
d614 12
a625 2
      intelDestroyBatchBuffer(&intel->ctx);
      
d627 1
a627 13
      if ( release_texture_heaps ) {
         /* This share group is about to go away, free our private
          * texture object data.
          */
         int i;

         for ( i = 0 ; i < intel->nr_heaps ; i++ ) {
	    driDestroyTextureHeap( intel->texture_heaps[ i ] );
	    intel->texture_heaps[ i ] = NULL;
         }

	 assert( is_empty_list( & intel->swapped ) );
      }
d630 1
a630 3
      _mesa_destroy_context(&intel->ctx);
   }
}
d632 1
a632 3
void intelSetFrontClipRects( intelContextPtr intel )
{
   __DRIdrawablePrivate *dPriv = intel->driDrawable;
d634 3
a636 6
   if (!dPriv) return;

   intel->numClipRects = dPriv->numClipRects;
   intel->pClipRects = dPriv->pClipRects;
   intel->drawX = dPriv->x;
   intel->drawY = dPriv->y;
d639 2
a640 2

void intelSetBackClipRects( intelContextPtr intel )
d642 2
a643 3
   __DRIdrawablePrivate *dPriv = intel->driDrawable;

   if (!dPriv) return;
d645 1
a645 41
   if (intel->sarea->pf_enabled == 0 && dPriv->numBackClipRects == 0) {
      intel->numClipRects = dPriv->numClipRects;
      intel->pClipRects = dPriv->pClipRects;
      intel->drawX = dPriv->x;
      intel->drawY = dPriv->y;
   } else {
      intel->numClipRects = dPriv->numBackClipRects;
      intel->pClipRects = dPriv->pBackClipRects;
      intel->drawX = dPriv->backX;
      intel->drawY = dPriv->backY;
      
      if (dPriv->numBackClipRects == 1 &&
	  dPriv->x == dPriv->backX &&
	  dPriv->y == dPriv->backY) {
      
	 /* Repeat the calculation of the back cliprect dimensions here
	  * as early versions of dri.a in the Xserver are incorrect.  Try
	  * very hard not to restrict future versions of dri.a which
	  * might eg. allocate truly private back buffers.
	  */
	 int x1, y1;
	 int x2, y2;
	 
	 x1 = dPriv->x;
	 y1 = dPriv->y;      
	 x2 = dPriv->x + dPriv->w;
	 y2 = dPriv->y + dPriv->h;
	 
	 if (x1 < 0) x1 = 0;
	 if (y1 < 0) y1 = 0;
	 if (x2 > intel->intelScreen->width) x2 = intel->intelScreen->width;
	 if (y2 > intel->intelScreen->height) y2 = intel->intelScreen->height;

	 if (x1 == dPriv->pBackClipRects[0].x1 &&
	     y1 == dPriv->pBackClipRects[0].y1) {

	    dPriv->pBackClipRects[0].x2 = x2;
	    dPriv->pBackClipRects[0].y2 = y2;
	 }
      }
   }
d648 4
a651 2

void intelWindowMoved( intelContextPtr intel )
d653 2
a654 2
   __DRIdrawablePrivate *dPriv = intel->driDrawable;
   GLframebuffer *drawFb = (GLframebuffer *) dPriv->driverPrivate;
d656 4
a659 23
   if (!intel->ctx.DrawBuffer) {
      intelSetFrontClipRects( intel );
   }
   else {
      driUpdateFramebufferSize(&intel->ctx, dPriv);
      switch (drawFb->_ColorDrawBufferMask[0]) {
      case BUFFER_BIT_FRONT_LEFT:
	 intelSetFrontClipRects( intel );
	 break;
      case BUFFER_BIT_BACK_LEFT:
	 intelSetBackClipRects( intel );
	 break;
      default:
	 /* glDrawBuffer(GL_NONE or GL_FRONT_AND_BACK): software fallback */
	 intelSetFrontClipRects( intel );
      }
   }

   if (drawFb->Width != dPriv->w || drawFb->Height != dPriv->h) {
      /* update Mesa's notion of framebuffer/window size */
      _mesa_resize_framebuffer(&intel->ctx, drawFb, dPriv->w, dPriv->h);
      drawFb->Initialized = GL_TRUE; /* XXX remove someday */
   }
d661 3
a663 1
   /* Set state we know depends on drawable parameters:
d665 2
a666 39
   {
      GLcontext *ctx = &intel->ctx;

      if (intel->intelScreen->driScrnPriv->ddxMinor >= 7) {
	 drmI830Sarea *sarea = intel->sarea;
	 drm_clip_rect_t drw_rect = { .x1 = dPriv->x, .x2 = dPriv->x + dPriv->w,
				      .y1 = dPriv->y, .y2 = dPriv->y + dPriv->h };
	 drm_clip_rect_t pipeA_rect = { .x1 = sarea->pipeA_x,
					.x2 = sarea->pipeA_x + sarea->pipeA_w,
					.y1 = sarea->pipeA_y,
					.y2 = sarea->pipeA_y + sarea->pipeA_h };
	 drm_clip_rect_t pipeB_rect = { .x1 = sarea->pipeB_x,
					.x2 = sarea->pipeB_x + sarea->pipeB_w,
					.y1 = sarea->pipeB_y,
					.y2 = sarea->pipeB_y + sarea->pipeB_h };
	 GLint areaA = driIntersectArea( drw_rect, pipeA_rect );
	 GLint areaB = driIntersectArea( drw_rect, pipeB_rect );
	 GLuint flags = intel->vblank_flags;

	 if (areaB > areaA || (areaA == areaB && areaB > 0)) {
	    flags = intel->vblank_flags | VBLANK_FLAG_SECONDARY;
	 } else {
	    flags = intel->vblank_flags & ~VBLANK_FLAG_SECONDARY;
	 }

	 if (flags != intel->vblank_flags) {
	    intel->vblank_flags = flags;
	    driGetCurrentVBlank(dPriv, intel->vblank_flags, &intel->vbl_seq);
	 }
      } else {
	 intel->vblank_flags &= ~VBLANK_FLAG_SECONDARY;
      }

      ctx->Driver.Scissor( ctx, ctx->Scissor.X, ctx->Scissor.Y,
			   ctx->Scissor.Width, ctx->Scissor.Height );
      
      ctx->Driver.DepthRange( ctx, 
			      ctx->Viewport.Near,
			      ctx->Viewport.Far );
a667 11
}

GLboolean intelUnbindContext(__DRIcontextPrivate *driContextPriv)
{
   return GL_TRUE;
}

GLboolean intelMakeCurrent(__DRIcontextPrivate *driContextPriv,
			  __DRIdrawablePrivate *driDrawPriv,
			  __DRIdrawablePrivate *driReadPriv)
{
d670 11
a680 9
      intelContextPtr intel = (intelContextPtr) driContextPriv->driverPrivate;

      if ( intel->driDrawable != driDrawPriv ) {
	 /* Shouldn't the readbuffer be stored also? */
	 driDrawableInitVBlank( driDrawPriv, intel->vblank_flags,
				&intel->vbl_seq );

	 intel->driDrawable = driDrawPriv;
	 intelWindowMoved( intel );
d683 2
a684 3
      _mesa_make_current(&intel->ctx,
			 (GLframebuffer *) driDrawPriv->driverPrivate,
			 (GLframebuffer *) driReadPriv->driverPrivate);
d686 7
a692 2
      intel->ctx.Driver.DrawBuffer( &intel->ctx, intel->ctx.Color.DrawBuffer[0] );
   } else {
d696 1
a696 1
   return GL_TRUE;
d700 15
a714 2
 * Use the information in the sarea to update the screen parameters
 * related to screen rotation.
d717 25
a741 69
intelUpdateScreenRotation(intelContextPtr intel,
                          __DRIscreenPrivate *sPriv,
                          drmI830Sarea *sarea)
{
   intelScreenPrivate *intelScreen = (intelScreenPrivate *)sPriv->private;
   intelRegion *colorBuf;

   intelUnmapScreenRegions(intelScreen);

   intelUpdateScreenFromSAREA(intelScreen, sarea);

   /* update the current hw offsets for the color and depth buffers */
   if (intel->ctx.DrawBuffer->_ColorDrawBufferMask[0] == BUFFER_BIT_BACK_LEFT)
      colorBuf = &intelScreen->back;
   else
      colorBuf = &intelScreen->front;
   intel->vtbl.update_color_z_regions(intel, colorBuf, &intelScreen->depth);

   if (!intelMapScreenRegions(sPriv)) {
      fprintf(stderr, "ERROR Remapping screen regions!!!\n");
   }
}

void intelGetLock( intelContextPtr intel, GLuint flags )
{
   __DRIdrawablePrivate *dPriv = intel->driDrawable;
   __DRIscreenPrivate *sPriv = intel->driScreen;
   intelScreenPrivate *intelScreen = (intelScreenPrivate *)sPriv->private;
   drmI830Sarea * sarea = intel->sarea;
   unsigned   i;

   drmGetLock(intel->driFd, intel->hHWContext, flags);

   /* If the window moved, may need to set a new cliprect now.
    *
    * NOTE: This releases and regains the hw lock, so all state
    * checking must be done *after* this call:
    */
   if (dPriv)
      DRI_VALIDATE_DRAWABLE_INFO(sPriv, dPriv);

   if (dPriv && intel->lastStamp != dPriv->lastStamp) {
      intelWindowMoved( intel );
      intel->lastStamp = dPriv->lastStamp;
   }

   /* If we lost context, need to dump all registers to hardware.
    * Note that we don't care about 2d contexts, even if they perform
    * accelerated commands, so the DRI locking in the X server is even
    * more broken than usual.
    */

   if (sarea->width != intelScreen->width ||
       sarea->height != intelScreen->height ||
       sarea->rotation != intelScreen->current_rotation) {
      intelUpdateScreenRotation(intel, sPriv, sarea);

      /* This will drop the outstanding batchbuffer on the floor */
      intel->batch.ptr -= (intel->batch.size - intel->batch.space);
      intel->batch.space = intel->batch.size;
      /* lose all primitives */
      intel->prim.primitive = ~0;
      intel->prim.start_ptr = 0;
      intel->prim.flush = 0;
      intel->vtbl.lost_hardware( intel ); 

      intel->lastStamp = 0; /* force window update */

      /* Release batch buffer
d743 2
a744 3
      intelDestroyBatchBuffer(&intel->ctx);
      intelInitBatchBuffer(&intel->ctx);
      intel->prim.flush = intel_emit_invarient_state;
d746 8
a753 1
      /* Still need to reset the global LRU?
d755 2
a756 1
      intel_driReinitTextureHeap( intel->texture_heaps[0], intel->intelScreen->tex.size );
d759 3
a761 6
   /* Shared texture managment - if another client has played with
    * texture space, figure out which if any of our textures have been
    * ejected, and update our global LRU.
    */
   for ( i = 0 ; i < intel->nr_heaps ; i++ ) {
      DRI_AGE_TEXTURES( intel->texture_heaps[ i ] );
a762 1
}
d764 1
d766 6
a771 23
void intelSwapBuffers( __DRIdrawablePrivate *dPriv )
{
   if (dPriv->driContextPriv && dPriv->driContextPriv->driverPrivate) {
      intelContextPtr intel;
      GLcontext *ctx;
      intel = (intelContextPtr) dPriv->driContextPriv->driverPrivate;
      ctx = &intel->ctx;
      if (ctx->Visual.doubleBufferMode) {
         intelScreenPrivate *screen = intel->intelScreen;
	 _mesa_notifySwapBuffers( ctx );  /* flush pending rendering comands */
	 if ( 0 /*intel->doPageFlip*/ ) { /* doPageFlip is never set !!! */
	    intelPageFlip( dPriv );
	 } else {
	     intelCopyBuffer( dPriv, NULL );
	 }
         if (screen->current_rotation != 0) {
            intelRotateWindow(intel, dPriv, BUFFER_BIT_FRONT_LEFT);
         }
      }
   } else {
      /* XXX this shouldn't be an error but we can't handle it for now */
      fprintf(stderr, "%s: drawable has no context!\n", __FUNCTION__);
   }
d774 30
a803 26
void intelCopySubBuffer( __DRIdrawablePrivate *dPriv,
			 int x, int y, int w, int h )
{
   if (dPriv->driContextPriv && dPriv->driContextPriv->driverPrivate) {
      intelContextPtr intel;
      GLcontext *ctx;
      intel = (intelContextPtr) dPriv->driContextPriv->driverPrivate;
      ctx = &intel->ctx;
      if (ctx->Visual.doubleBufferMode) {
	 drm_clip_rect_t rect;
	 rect.x1 = x + dPriv->x;
	 rect.y1 = (dPriv->h - y - h) + dPriv->y;
	 rect.x2 = rect.x1 + w;
	 rect.y2 = rect.y1 + h;
	 _mesa_notifySwapBuffers( ctx );  /* flush pending rendering comands */
	 intelCopyBuffer( dPriv, &rect );
      }
   } else {
      /* XXX this shouldn't be an error but we can't handle it for now */
      fprintf(stderr, "%s: drawable has no context!\n", __FUNCTION__);
   }
}

void intelInitState( GLcontext *ctx )
{
   /* Mesa should do this for us:
d805 28
a832 87
   ctx->Driver.AlphaFunc( ctx, 
			  ctx->Color.AlphaFunc,
			  ctx->Color.AlphaRef);

   ctx->Driver.BlendColor( ctx,
			   ctx->Color.BlendColor );

   ctx->Driver.BlendEquationSeparate( ctx, 
				      ctx->Color.BlendEquationRGB,
				      ctx->Color.BlendEquationA);

   ctx->Driver.BlendFuncSeparate( ctx,
				  ctx->Color.BlendSrcRGB,
				  ctx->Color.BlendDstRGB,
				  ctx->Color.BlendSrcA,
				  ctx->Color.BlendDstA);

   ctx->Driver.ColorMask( ctx, 
			  ctx->Color.ColorMask[RCOMP],
			  ctx->Color.ColorMask[GCOMP],
			  ctx->Color.ColorMask[BCOMP],
			  ctx->Color.ColorMask[ACOMP]);

   ctx->Driver.CullFace( ctx, ctx->Polygon.CullFaceMode );
   ctx->Driver.DepthFunc( ctx, ctx->Depth.Func );
   ctx->Driver.DepthMask( ctx, ctx->Depth.Mask );

   ctx->Driver.Enable( ctx, GL_ALPHA_TEST, ctx->Color.AlphaEnabled );
   ctx->Driver.Enable( ctx, GL_BLEND, ctx->Color.BlendEnabled );
   ctx->Driver.Enable( ctx, GL_COLOR_LOGIC_OP, ctx->Color.ColorLogicOpEnabled );
   ctx->Driver.Enable( ctx, GL_COLOR_SUM, ctx->Fog.ColorSumEnabled );
   ctx->Driver.Enable( ctx, GL_CULL_FACE, ctx->Polygon.CullFlag );
   ctx->Driver.Enable( ctx, GL_DEPTH_TEST, ctx->Depth.Test );
   ctx->Driver.Enable( ctx, GL_DITHER, ctx->Color.DitherFlag );
   ctx->Driver.Enable( ctx, GL_FOG, ctx->Fog.Enabled );
   ctx->Driver.Enable( ctx, GL_LIGHTING, ctx->Light.Enabled );
   ctx->Driver.Enable( ctx, GL_LINE_SMOOTH, ctx->Line.SmoothFlag );
   ctx->Driver.Enable( ctx, GL_POLYGON_STIPPLE, ctx->Polygon.StippleFlag );
   ctx->Driver.Enable( ctx, GL_SCISSOR_TEST, ctx->Scissor.Enabled );
   ctx->Driver.Enable( ctx, GL_STENCIL_TEST, ctx->Stencil.Enabled );
   ctx->Driver.Enable( ctx, GL_TEXTURE_1D, GL_FALSE );
   ctx->Driver.Enable( ctx, GL_TEXTURE_2D, GL_FALSE );
   ctx->Driver.Enable( ctx, GL_TEXTURE_RECTANGLE_NV, GL_FALSE );
   ctx->Driver.Enable( ctx, GL_TEXTURE_3D, GL_FALSE );
   ctx->Driver.Enable( ctx, GL_TEXTURE_CUBE_MAP, GL_FALSE );

   ctx->Driver.Fogfv( ctx, GL_FOG_COLOR, ctx->Fog.Color );
   ctx->Driver.Fogfv( ctx, GL_FOG_MODE, 0 );
   ctx->Driver.Fogfv( ctx, GL_FOG_DENSITY, &ctx->Fog.Density );
   ctx->Driver.Fogfv( ctx, GL_FOG_START, &ctx->Fog.Start );
   ctx->Driver.Fogfv( ctx, GL_FOG_END, &ctx->Fog.End );

   ctx->Driver.FrontFace( ctx, ctx->Polygon.FrontFace );

   {
      GLfloat f = (GLfloat)ctx->Light.Model.ColorControl;
      ctx->Driver.LightModelfv( ctx, GL_LIGHT_MODEL_COLOR_CONTROL, &f );
   }

   ctx->Driver.LineWidth( ctx, ctx->Line.Width );
   ctx->Driver.LogicOpcode( ctx, ctx->Color.LogicOp );
   ctx->Driver.PointSize( ctx, ctx->Point.Size );
   ctx->Driver.PolygonStipple( ctx, (const GLubyte *)ctx->PolygonStipple );
   ctx->Driver.Scissor( ctx, ctx->Scissor.X, ctx->Scissor.Y,
			ctx->Scissor.Width, ctx->Scissor.Height );
   ctx->Driver.ShadeModel( ctx, ctx->Light.ShadeModel );
   ctx->Driver.StencilFuncSeparate( ctx, GL_FRONT,
                                    ctx->Stencil.Function[0],
                                    ctx->Stencil.Ref[0],
                                    ctx->Stencil.ValueMask[0] );
   ctx->Driver.StencilFuncSeparate( ctx, GL_BACK,
                                    ctx->Stencil.Function[1],
                                    ctx->Stencil.Ref[1],
                                    ctx->Stencil.ValueMask[1] );
   ctx->Driver.StencilMaskSeparate( ctx, GL_FRONT, ctx->Stencil.WriteMask[0] );
   ctx->Driver.StencilMaskSeparate( ctx, GL_BACK, ctx->Stencil.WriteMask[1] );
   ctx->Driver.StencilOpSeparate( ctx, GL_FRONT,
                                  ctx->Stencil.FailFunc[0],
                                  ctx->Stencil.ZFailFunc[0],
                                  ctx->Stencil.ZPassFunc[0]);
   ctx->Driver.StencilOpSeparate( ctx, GL_BACK,
                                  ctx->Stencil.FailFunc[1],
                                  ctx->Stencil.ZFailFunc[1],
                                  ctx->Stencil.ZPassFunc[1]);


   ctx->Driver.DrawBuffer( ctx, ctx->Color.DrawBuffer[0] );
a833 2


@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@@


1.1
log
@Initial revision
@
text
@d36 1
d41 1
a41 1
#include "array_cache/acache.h"
d96 1
a96 1
#define DRIVER_DATE                     "20050225"
d126 8
a145 21
static void intelBufferSize(GLframebuffer *buffer,
			   GLuint *width, GLuint *height)
{
   GET_CURRENT_CONTEXT(ctx);
   intelContextPtr intel = INTEL_CONTEXT(ctx);
   /* Need to lock to make sure the driDrawable is uptodate.  This
    * information is used to resize Mesa's software buffers, so it has
    * to be correct.
    */
   LOCK_HARDWARE(intel);
   if (intel->driDrawable) {
      *width = intel->driDrawable->w;
      *height = intel->driDrawable->h;
   }
   else {
      *width = 0;
      *height = 0;
   }
   UNLOCK_HARDWARE(intel);
}

a206 1
   &_tnl_arb_vertex_program_stage,
d239 1
a239 1
   _ac_InvalidateState( ctx, new_state );
a252 2
   functions->GetBufferSize = intelBufferSize;
   functions->ResizeBuffers = _mesa_resize_framebuffer;
a254 4
   functions->CopyColorTable = _swrast_CopyColorTable;
   functions->CopyColorSubTable = _swrast_CopyColorSubTable;
   functions->CopyConvolutionFilter1D = _swrast_CopyConvolutionFilter1D;
   functions->CopyConvolutionFilter2D = _swrast_CopyConvolutionFilter2D;
d313 5
d320 1
a320 1
   _ac_CreateContext( ctx );
d439 1
a439 1
      _ac_DestroyContext (&intel->ctx);
d532 1
d538 2
a539 3
      driUpdateFramebufferSize(&intel->ctx, intel->driDrawable);
    
      switch (intel->ctx.DrawBuffer->_ColorDrawBufferMask[0]) {
d552 6
a557 4
   _mesa_resize_framebuffer(&intel->ctx,
			    (GLframebuffer*)dPriv->driverPrivate,
			    dPriv->w, dPriv->h);
   
d563 30
d617 2
a618 1
	 driDrawableInitVBlank( driDrawPriv, intel->vblank_flags );
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d95 1
a95 1
#define DRIVER_DATE "20061017"
d137 21
d266 2
d270 4
a545 1
   GLframebuffer *drawFb = (GLframebuffer *) dPriv->driverPrivate;
d551 3
a553 2
      driUpdateFramebufferSize(&intel->ctx, dPriv);
      switch (drawFb->_ColorDrawBufferMask[0]) {
d566 4
a569 6
   if (drawFb->Width != dPriv->w || drawFb->Height != dPriv->h) {
      /* update Mesa's notion of framebuffer/window size */
      _mesa_resize_framebuffer(&intel->ctx, drawFb, dPriv->w, dPriv->h);
      drawFb->Initialized = GL_TRUE; /* XXX remove someday */
   }

a574 30
      if (intel->intelScreen->driScrnPriv->ddxMinor >= 7) {
	 drmI830Sarea *sarea = intel->sarea;
	 drm_clip_rect_t drw_rect = { .x1 = dPriv->x, .x2 = dPriv->x + dPriv->w,
				      .y1 = dPriv->y, .y2 = dPriv->y + dPriv->h };
	 drm_clip_rect_t pipeA_rect = { .x1 = sarea->pipeA_x,
					.x2 = sarea->pipeA_x + sarea->pipeA_w,
					.y1 = sarea->pipeA_y,
					.y2 = sarea->pipeA_y + sarea->pipeA_h };
	 drm_clip_rect_t pipeB_rect = { .x1 = sarea->pipeB_x,
					.x2 = sarea->pipeB_x + sarea->pipeB_w,
					.y1 = sarea->pipeB_y,
					.y2 = sarea->pipeB_y + sarea->pipeB_h };
	 GLint areaA = driIntersectArea( drw_rect, pipeA_rect );
	 GLint areaB = driIntersectArea( drw_rect, pipeB_rect );
	 GLuint flags = intel->vblank_flags;

	 if (areaB > areaA || (areaA > 0 && areaB > 0)) {
	    flags = intel->vblank_flags | VBLANK_FLAG_SECONDARY;
	 } else {
	    flags = intel->vblank_flags & ~VBLANK_FLAG_SECONDARY;
	 }

	 if (flags != intel->vblank_flags) {
	    intel->vblank_flags = flags;
	    driGetCurrentVBlank(dPriv, intel->vblank_flags, &intel->vbl_seq);
	 }
      } else {
	 intel->vblank_flags &= ~VBLANK_FLAG_SECONDARY;
      }

d599 1
a599 2
	 driDrawableInitVBlank( driDrawPriv, intel->vblank_flags,
				&intel->vbl_seq );
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@a35 1
#include "points.h"
d40 1
a40 1
#include "vbo/vbo.h"
d198 1
d231 1
a231 1
   _vbo_InvalidateState( ctx, new_state );
a304 5
   /* reinitialize the context point state.
    * It depend on constants in __GLcontextRec::Const
    */
   _mesa_init_point(ctx);

d307 1
a307 1
   _vbo_CreateContext( ctx );
d426 1
a426 1
      _vbo_DestroyContext (&intel->ctx);
d566 1
a566 1
	 if (areaB > areaA || (areaA == areaB && areaB > 0)) {
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@d29 8
a36 8
#include "main/glheader.h"
#include "main/context.h"
#include "main/extensions.h"
#include "main/fbobject.h"
#include "main/framebuffer.h"
#include "main/imports.h"
#include "main/points.h"
#include "main/renderbuffer.h"
d41 5
a46 1
#include "drivers/common/meta.h"
d48 5
a52 2
#include "intel_chipset.h"
#include "intel_buffers.h"
d54 3
a57 9
#include "intel_clear.h"
#include "intel_extensions.h"
#include "intel_pixel.h"
#include "intel_regions.h"
#include "intel_buffer_objects.h"
#include "intel_fbo.h"
#include "intel_bufmgr.h"
#include "intel_screen.h"
#include "intel_mipmap_tree.h"
d59 1
d61 1
a61 2
#include "../glsl/ralloc.h"

d66 31
d98 1
a98 2
static const GLubyte *
intelGetString(struct gl_context * ctx, GLenum name)
d100 1
a100 2
   const struct intel_context *const intel = intel_context(ctx);
   const char *chipset;
d105 1
a105 1
      return (GLubyte *) "Intel Open Source Technology Center";
d107 1
a107 1

d109 17
a125 4
      switch (intel->intelScreen->deviceID) {
#undef CHIPSET
#define CHIPSET(id, symbol, str) case id: chipset = str; break;
#include "pci_ids/i915_pci_ids.h"
d127 1
a127 2
         chipset = "Unknown Intel Chipset";
         break;
d130 1
a130 1
      (void) driGetRendererString(buffer, chipset, 0);
a137 14
static void
intel_flush_front(struct gl_context *ctx)
{
   struct intel_context *intel = intel_context(ctx);
    __DRIcontext *driContext = intel->driContext;
    __DRIdrawable *driDrawable = driContext->driDrawablePriv;
    __DRIscreen *const screen = intel->intelScreen->driScrnPriv;

    if (intel->front_buffer_dirty && _mesa_is_winsys_fbo(ctx->DrawBuffer)) {
      if (screen->dri2.loader->flushFrontBuffer != NULL &&
          driDrawable &&
          driDrawable->loaderPrivate) {
         screen->dri2.loader->flushFrontBuffer(driDrawable,
                                               driDrawable->loaderPrivate);
d139 8
a146 10
	 /* We set the dirty bit in intel_prepare_render() if we're
	  * front buffer rendering once we get there.
	  */
	 intel->front_buffer_dirty = false;
      }
   }
}

static unsigned
intel_bits_per_pixel(const struct intel_renderbuffer *rb)
d148 39
a186 2
   return _mesa_get_format_bytes(intel_rb_format(rb)) * 8;
}
d188 1
a188 5
static void
intel_query_dri2_buffers(struct intel_context *intel,
			 __DRIdrawable *drawable,
			 __DRIbuffer **buffers,
			 int *count);
d190 16
a205 58
static void
intel_process_dri2_buffer(struct intel_context *intel,
			  __DRIdrawable *drawable,
			  __DRIbuffer *buffer,
			  struct intel_renderbuffer *rb,
			  const char *buffer_name);

void
intel_update_renderbuffers(__DRIcontext *context, __DRIdrawable *drawable)
{
   struct gl_framebuffer *fb = drawable->driverPrivate;
   struct intel_renderbuffer *rb;
   struct intel_context *intel = context->driverPrivate;
   __DRIbuffer *buffers = NULL;
   int i, count;
   const char *region_name;

   /* Set this up front, so that in case our buffers get invalidated
    * while we're getting new buffers, we don't clobber the stamp and
    * thus ignore the invalidate. */
   drawable->lastStamp = drawable->dri2.stamp;

   if (unlikely(INTEL_DEBUG & DEBUG_DRI))
      fprintf(stderr, "enter %s, drawable %p\n", __func__, drawable);

   intel_query_dri2_buffers(intel, drawable, &buffers, &count);

   if (buffers == NULL)
      return;

   for (i = 0; i < count; i++) {
       switch (buffers[i].attachment) {
       case __DRI_BUFFER_FRONT_LEFT:
	   rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
	   region_name = "dri2 front buffer";
	   break;

       case __DRI_BUFFER_FAKE_FRONT_LEFT:
	   rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
	   region_name = "dri2 fake front buffer";
	   break;

       case __DRI_BUFFER_BACK_LEFT:
	   rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);
	   region_name = "dri2 back buffer";
	   break;

       case __DRI_BUFFER_DEPTH:
       case __DRI_BUFFER_HIZ:
       case __DRI_BUFFER_DEPTH_STENCIL:
       case __DRI_BUFFER_STENCIL:
       case __DRI_BUFFER_ACCUM:
       default:
	   fprintf(stderr,
		   "unhandled buffer attach event, attachment type %d\n",
		   buffers[i].attachment);
	   return;
       }
a206 2
       intel_process_dri2_buffer(intel, drawable, &buffers[i], rb, region_name);
   }
d208 1
a208 9
   driUpdateFramebufferSize(&intel->ctx, drawable);
}

/**
 * intel_prepare_render should be called anywhere that curent read/drawbuffer
 * state is required.
 */
void
intel_prepare_render(struct intel_context *intel)
d210 15
a224 2
   __DRIcontext *driContext = intel->driContext;
   __DRIdrawable *drawable;
a225 21
   drawable = driContext->driDrawablePriv;
   if (drawable && drawable->dri2.stamp != driContext->dri2.draw_stamp) {
      if (drawable->lastStamp != drawable->dri2.stamp)
	 intel_update_renderbuffers(driContext, drawable);
      intel_draw_buffer(&intel->ctx);
      driContext->dri2.draw_stamp = drawable->dri2.stamp;
   }

   drawable = driContext->driReadablePriv;
   if (drawable && drawable->dri2.stamp != driContext->dri2.read_stamp) {
      if (drawable->lastStamp != drawable->dri2.stamp)
	 intel_update_renderbuffers(driContext, drawable);
      driContext->dri2.read_stamp = drawable->dri2.stamp;
   }

   /* If we're currently rendering to the front buffer, the rendering
    * that will happen next will probably dirty the front buffer.  So
    * mark it as dirty here.
    */
   if (intel->is_front_buffer_rendering)
      intel->front_buffer_dirty = true;
d227 8
a234 22
   /* Wait for the swapbuffers before the one we just emitted, so we
    * don't get too many swaps outstanding for apps that are GPU-heavy
    * but not CPU-heavy.
    *
    * We're using intelDRI2Flush (called from the loader before
    * swapbuffer) and glFlush (for front buffer rendering) as the
    * indicator that a frame is done and then throttle when we get
    * here as we prepare to render the next frame.  At this point for
    * round trips for swap/copy and getting new buffers are done and
    * we'll spend less time waiting on the GPU.
    *
    * Unfortunately, we don't have a handle to the batch containing
    * the swap, and getting our hands on that doesn't seem worth it,
    * so we just us the first batch we emitted after the last swap.
    */
   if (intel->need_throttle && intel->first_post_swapbuffers_batch) {
      if (!intel->disable_throttling)
         drm_intel_bo_wait_rendering(intel->first_post_swapbuffers_batch);
      drm_intel_bo_unreference(intel->first_post_swapbuffers_batch);
      intel->first_post_swapbuffers_batch = NULL;
      intel->need_throttle = false;
   }
d237 2
a238 2
static void
intel_viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
d240 1
a240 2
    struct intel_context *intel = intel_context(ctx);
    __DRIcontext *driContext = intel->driContext;
d242 5
a246 29
    if (intel->saved_viewport)
	intel->saved_viewport(ctx, x, y, w, h);

    if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
       dri2InvalidateDrawable(driContext->driDrawablePriv);
       dri2InvalidateDrawable(driContext->driReadablePriv);
    }
}

static const struct dri_debug_control debug_control[] = {
   { "tex",   DEBUG_TEXTURE},
   { "state", DEBUG_STATE},
   { "blit",  DEBUG_BLIT},
   { "mip",   DEBUG_MIPTREE},
   { "fall",  DEBUG_PERF},
   { "perf",  DEBUG_PERF},
   { "bat",   DEBUG_BATCH},
   { "pix",   DEBUG_PIXEL},
   { "buf",   DEBUG_BUFMGR},
   { "reg",   DEBUG_REGION},
   { "fbo",   DEBUG_FBO},
   { "fs",    DEBUG_WM },
   { "sync",  DEBUG_SYNC},
   { "dri",   DEBUG_DRI },
   { "stats", DEBUG_STATS },
   { "wm",    DEBUG_WM },
   { "aub",   DEBUG_AUB },
   { NULL,    0 }
};
d248 4
d253 1
a253 2
static void
intelInvalidateState(struct gl_context * ctx, GLuint new_state)
d255 1
a255 1
    struct intel_context *intel = intel_context(ctx);
a256 3
    if (ctx->swrast_context)
       _swrast_InvalidateState(ctx, new_state);
   _vbo_InvalidateState(ctx, new_state);
a257 5
   intel->NewGLState |= new_state;

   if (intel->vtbl.invalidate_state)
      intel->vtbl.invalidate_state( intel, new_state );
}
d259 5
a263 2
void
intel_flush_rendering_to_batch(struct gl_context *ctx)
d265 7
a271 1
   struct intel_context *intel = intel_context(ctx);
d273 5
a277 2
   if (intel->Fallback)
      _swrast_flush(ctx);
d279 4
a282 2
   INTEL_FIREVERTICES(intel);
}
a283 4
void
_intel_flush(struct gl_context *ctx, const char *file, int line)
{
   struct intel_context *intel = intel_context(ctx);
d285 2
a286 1
   intel_flush_rendering_to_batch(ctx);
d288 2
a289 3
   if (intel->batch.used)
      _intel_batchbuffer_flush(intel, file, line);
}
d291 1
a291 4
static void
intel_glFlush(struct gl_context *ctx)
{
   struct intel_context *intel = intel_context(ctx);
d293 5
a297 5
   intel_flush(ctx);
   intel_flush_front(ctx);
   if (intel->is_front_buffer_rendering)
      intel->need_throttle = true;
}
d299 5
a303 4
void
intelFinish(struct gl_context * ctx)
{
   struct intel_context *intel = intel_context(ctx);
d305 4
a308 2
   intel_flush(ctx);
   intel_flush_front(ctx);
d310 13
a322 3
   if (intel->batch.last_bo)
      drm_intel_bo_wait_rendering(intel->batch.last_bo);
}
d324 4
a327 4
void
intelInitDriverFunctions(struct dd_function_table *functions)
{
   _mesa_init_driver_functions(functions);
d329 2
a330 4
   functions->Flush = intel_glFlush;
   functions->Finish = intelFinish;
   functions->GetString = intelGetString;
   functions->UpdateState = intelInvalidateState;
d332 7
a338 30
   intelInitTextureFuncs(functions);
   intelInitTextureImageFuncs(functions);
   intelInitTextureSubImageFuncs(functions);
   intelInitTextureCopyImageFuncs(functions);
   intelInitClearFuncs(functions);
   intelInitBufferFuncs(functions);
   intelInitPixelFuncs(functions);
   intelInitBufferObjectFuncs(functions);
   intel_init_syncobj_functions(functions);
}

static bool
validate_context_version(struct intel_screen *screen,
                         int mesa_api,
                         unsigned major_version,
                         unsigned minor_version,
                         unsigned *dri_ctx_error)
{
   unsigned req_version = 10 * major_version + minor_version;
   unsigned max_version = 0;

   switch (mesa_api) {
   case API_OPENGL_COMPAT:
      max_version = screen->max_gl_compat_version;
      break;
   case API_OPENGL_CORE:
      max_version = screen->max_gl_core_version;
      break;
   case API_OPENGLES:
      max_version = screen->max_gl_es1_version;
d340 6
a345 2
   case API_OPENGLES2:
      max_version = screen->max_gl_es2_version;
d348 1
a348 1
      max_version = 0;
d352 3
a354 50
   if (max_version == 0) {
      *dri_ctx_error = __DRI_CTX_ERROR_BAD_API;
      return false;
   } else if (req_version > max_version) {
      *dri_ctx_error = __DRI_CTX_ERROR_BAD_VERSION;
      return false;
   }

   return true;
}

bool
intelInitContext(struct intel_context *intel,
                 int api,
                 unsigned major_version,
                 unsigned minor_version,
                 const struct gl_config * mesaVis,
                 __DRIcontext * driContextPriv,
                 void *sharedContextPrivate,
                 struct dd_function_table *functions,
                 unsigned *dri_ctx_error)
{
   struct gl_context *ctx = &intel->ctx;
   struct gl_context *shareCtx = (struct gl_context *) sharedContextPrivate;
   __DRIscreen *sPriv = driContextPriv->driScreenPriv;
   struct intel_screen *intelScreen = sPriv->driverPrivate;
   int bo_reuse_mode;
   struct gl_config visual;

   /* we can't do anything without a connection to the device */
   if (intelScreen->bufmgr == NULL) {
      *dri_ctx_error = __DRI_CTX_ERROR_NO_MEMORY;
      return false;
   }

   if (!validate_context_version(intelScreen,
                                 api, major_version, minor_version,
                                 dri_ctx_error))
      return false;

   /* Can't rely on invalidate events, fall back to glViewport hack */
   if (!driContextPriv->driScreenPriv->dri2.useInvalidate) {
      intel->saved_viewport = functions->Viewport;
      functions->Viewport = intel_viewport;
   }

   if (mesaVis == NULL) {
      memset(&visual, 0, sizeof visual);
      mesaVis = &visual;
   }
a355 1
   intel->intelScreen = intelScreen;
d357 1
a357 6
   if (!_mesa_initialize_context(&intel->ctx, api, mesaVis, shareCtx,
                                 functions)) {
      *dri_ctx_error = __DRI_CTX_ERROR_NO_MEMORY;
      printf("%s: failed to init mesa context\n", __FUNCTION__);
      return false;
   }
d359 3
a361 3
   driContextPriv->driverPrivate = intel;
   intel->driContext = driContextPriv;
   intel->driFd = sPriv->fd;
d363 2
a364 1
   intel->gen = intelScreen->gen;
d366 1
a366 1
   const int devID = intelScreen->deviceID;
d368 2
a369 1
   intel->is_945 = IS_945(devID);
d371 2
a372 1
   intel->has_swizzling = intel->intelScreen->hw_has_swizzling;
d374 1
a374 2
   memset(&ctx->TextureFormatSupported,
	  0, sizeof(ctx->TextureFormatSupported));
d376 6
a381 30
   driParseConfigFiles(&intel->optionCache, &intelScreen->optionCache,
                       sPriv->myNum, "i915");
   intel->maxBatchSize = 4096;

   /* Estimate the size of the mappable aperture into the GTT.  There's an
    * ioctl to get the whole GTT size, but not one to get the mappable subset.
    * It turns out it's basically always 256MB, though some ancient hardware
    * was smaller.
    */
   uint32_t gtt_size = 256 * 1024 * 1024;
   if (intel->gen == 2)
      gtt_size = 128 * 1024 * 1024;

   /* We don't want to map two objects such that a memcpy between them would
    * just fault one mapping in and then the other over and over forever.  So
    * we would need to divide the GTT size by 2.  Additionally, some GTT is
    * taken up by things like the framebuffer and the ringbuffer and such, so
    * be more conservative.
    */
   intel->max_gtt_map_object_size = gtt_size / 4;

   intel->bufmgr = intelScreen->bufmgr;

   bo_reuse_mode = driQueryOptioni(&intel->optionCache, "bo_reuse");
   switch (bo_reuse_mode) {
   case DRI_CONF_BO_REUSE_DISABLED:
      break;
   case DRI_CONF_BO_REUSE_ALL:
      intel_bufmgr_gem_enable_reuse(intel->bufmgr);
      break;
d384 4
a387 5
   ctx->Const.MinLineWidth = 1.0;
   ctx->Const.MinLineWidthAA = 1.0;
   ctx->Const.MaxLineWidth = 5.0;
   ctx->Const.MaxLineWidthAA = 5.0;
   ctx->Const.LineWidthGranularity = 0.5;
a388 5
   ctx->Const.MinPointSize = 1.0;
   ctx->Const.MinPointSizeAA = 1.0;
   ctx->Const.MaxPointSize = 255.0;
   ctx->Const.MaxPointSizeAA = 3.0;
   ctx->Const.PointSizeGranularity = 1.0;
d390 3
a392 1
   ctx->Const.StripTextureBorder = GL_TRUE;
a393 4
   /* reinitialize the context point state.
    * It depend on constants in __struct gl_contextRec::Const
    */
   _mesa_init_point(ctx);
d395 6
a400 1
   ctx->Const.MaxRenderbufferSize = 2048;
d402 4
a405 5
   _swrast_CreateContext(ctx);
   _vbo_CreateContext(ctx);
   if (ctx->swrast_context) {
      _tnl_CreateContext(ctx);
      _swsetup_CreateContext(ctx);
d407 4
a410 3
      /* Configure swrast to match hardware characteristics: */
      _swrast_allow_pixel_fog(ctx, false);
      _swrast_allow_vertex_fog(ctx, true);
d413 2
a414 1
   _mesa_meta_init(ctx);
d416 3
a418 2
   intel->hw_stencil = mesaVis->stencilBits && mesaVis->depthBits == 24;
   intel->hw_stipple = 1;
d420 3
a422 1
   intel->RenderIndex = ~0;
d424 1
a424 1
   intelInitExtensions(ctx);
d426 1
a426 5
   INTEL_DEBUG = driParseDebugString(getenv("INTEL_DEBUG"), debug_control);
   if (INTEL_DEBUG & DEBUG_BUFMGR)
      dri_bufmgr_set_debug(intel->bufmgr, true);
   if (INTEL_DEBUG & DEBUG_PERF)
      intel->perf_debug = true;
d428 4
a431 2
   if (INTEL_DEBUG & DEBUG_AUB)
      drm_intel_bufmgr_gem_set_aub_dump(intel->bufmgr, true);
d433 2
a434 1
   intel_batchbuffer_init(intel);
d436 2
a437 1
   intel_fbo_init(intel);
d439 10
a448 1
   intel->use_early_z = driQueryOptionb(&intel->optionCache, "early_z");
d450 2
a451 1
   intel->prim.primitive = ~0;
d453 2
a454 4
   /* Force all software fallbacks */
   if (driQueryOptionb(&intel->optionCache, "no_rast")) {
      fprintf(stderr, "disabling 3D rasterization\n");
      intel->no_rast = 1;
d456 1
d458 3
a460 4
   if (driQueryOptionb(&intel->optionCache, "always_flush_batch")) {
      fprintf(stderr, "flushing batchbuffer before/after each draw call\n");
      intel->always_flush_batch = 1;
   }
d462 1
a462 4
   if (driQueryOptionb(&intel->optionCache, "always_flush_cache")) {
      fprintf(stderr, "flushing GPU caches before/after each draw call\n");
      intel->always_flush_cache = 1;
   }
d464 5
a468 4
   if (driQueryOptionb(&intel->optionCache, "disable_throttling")) {
      fprintf(stderr, "disabling flush throttling\n");
      intel->disable_throttling = 1;
   }
a469 2
   return true;
}
d471 1
a471 2
void
intelDestroyContext(__DRIcontext * driContextPriv)
d473 1
a473 3
   struct intel_context *intel =
      (struct intel_context *) driContextPriv->driverPrivate;
   struct gl_context *ctx = &intel->ctx;
d475 1
a475 3
   assert(intel);               /* should never be null */
   if (intel) {
      INTEL_FIREVERTICES(intel);
d477 39
a515 4
      /* Dump a final BMP in case the application doesn't call SwapBuffers */
      if (INTEL_DEBUG & DEBUG_AUB) {
         intel_batchbuffer_flush(intel);
	 aub_dump_bmp(&intel->ctx);
d517 2
a519 1
      _mesa_meta_free(&intel->ctx);
d521 4
a524 1
      intel->vtbl.destroy(intel);
d526 15
a540 3
      if (ctx->swrast_context) {
         _swsetup_DestroyContext(&intel->ctx);
         _tnl_DestroyContext(&intel->ctx);
d542 1
a542 1
      _vbo_DestroyContext(&intel->ctx);
d544 5
a548 12
      if (ctx->swrast_context)
         _swrast_DestroyContext(&intel->ctx);
      intel->Fallback = 0x0;      /* don't call _swrast_Flush later */

      intel_batchbuffer_free(intel);

      free(intel->prim.vb);
      intel->prim.vb = NULL;
      drm_intel_bo_unreference(intel->prim.vb_bo);
      intel->prim.vb_bo = NULL;
      drm_intel_bo_unreference(intel->first_post_swapbuffers_batch);
      intel->first_post_swapbuffers_batch = NULL;
d550 4
a553 1
      driDestroyOptionCache(&intel->optionCache);
d555 29
a583 2
      /* free the Mesa context */
      _mesa_free_context_data(&intel->ctx);
d585 6
a590 4
      _math_matrix_dtr(&intel->ViewportMatrix);

      ralloc_free(intel);
      driContextPriv->driverPrivate = NULL;
d594 1
a594 2
GLboolean
intelUnbindContext(__DRIcontext * driContextPriv)
d596 1
a596 4
   /* Unset current context and dispath table */
   _mesa_make_current(NULL, NULL, NULL);

   return true;
d599 3
a601 4
GLboolean
intelMakeCurrent(__DRIcontext * driContextPriv,
                 __DRIdrawable * driDrawPriv,
                 __DRIdrawable * driReadPriv)
a602 2
   struct intel_context *intel;
   GET_CURRENT_CONTEXT(curCtx);
d604 2
a605 4
   if (driContextPriv)
      intel = (struct intel_context *) driContextPriv->driverPrivate;
   else
      intel = NULL;
d607 4
a610 7
   /* According to the glXMakeCurrent() man page: "Pending commands to
    * the previous context, if any, are flushed before it is released."
    * But only flush if we're actually changing contexts.
    */
   if (intel_context(curCtx) && intel_context(curCtx) != intel) {
      _mesa_flush(curCtx);
   }
d612 2
a613 12
   if (driContextPriv) {
      struct gl_context *ctx = &intel->ctx;
      struct gl_framebuffer *fb, *readFb;
      
      if (driDrawPriv == NULL && driReadPriv == NULL) {
	 fb = _mesa_get_incomplete_framebuffer();
	 readFb = _mesa_get_incomplete_framebuffer();
      } else {
	 fb = driDrawPriv->driverPrivate;
	 readFb = driReadPriv->driverPrivate;
	 driContextPriv->dri2.draw_stamp = driDrawPriv->dri2.stamp - 1;
	 driContextPriv->dri2.read_stamp = driReadPriv->dri2.stamp - 1;
d616 3
a618 2
      intel_prepare_render(intel);
      _mesa_make_current(ctx, fb, readFb);
d620 2
a621 7
      /* We do this in intel_prepare_render() too, but intel->ctx.DrawBuffer
       * is NULL at that point.  We can't call _mesa_makecurrent()
       * first, since we need the buffer size for the initial
       * viewport.  So just call intel_draw_buffer() again here. */
      intel_draw_buffer(ctx);
   }
   else {
d625 1
a625 1
   return true;
d629 2
a630 15
 * \brief Query DRI2 to obtain a DRIdrawable's buffers.
 *
 * To determine which DRI buffers to request, examine the renderbuffers
 * attached to the drawable's framebuffer. Then request the buffers with
 * DRI2GetBuffers() or DRI2GetBuffersWithFormat().
 *
 * This is called from intel_update_renderbuffers().
 *
 * \param drawable      Drawable whose buffers are queried.
 * \param buffers       [out] List of buffers returned by DRI2 query.
 * \param buffer_count  [out] Number of buffers returned.
 *
 * \see intel_update_renderbuffers()
 * \see DRI2GetBuffers()
 * \see DRI2GetBuffersWithFormat()
d633 69
a701 25
intel_query_dri2_buffers(struct intel_context *intel,
			 __DRIdrawable *drawable,
			 __DRIbuffer **buffers,
			 int *buffer_count)
{
   __DRIscreen *screen = intel->intelScreen->driScrnPriv;
   struct gl_framebuffer *fb = drawable->driverPrivate;
   int i = 0;
   unsigned attachments[8];

   struct intel_renderbuffer *front_rb;
   struct intel_renderbuffer *back_rb;

   front_rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
   back_rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);

   memset(attachments, 0, sizeof(attachments));
   if ((intel->is_front_buffer_rendering ||
	intel->is_front_buffer_reading ||
	!back_rb) && front_rb) {
      /* If a fake front buffer is in use, then querying for
       * __DRI_BUFFER_FRONT_LEFT will cause the server to copy the image from
       * the real front buffer to the fake front buffer.  So before doing the
       * query, we need to make sure all the pending drawing has landed in the
       * real front buffer.
d703 3
a705 2
      intel_flush(&intel->ctx);
      intel_flush_front(&intel->ctx);
d707 1
a707 8
      attachments[i++] = __DRI_BUFFER_FRONT_LEFT;
      attachments[i++] = intel_bits_per_pixel(front_rb);
   } else if (front_rb && intel->front_buffer_dirty) {
      /* We have pending front buffer rendering, but we aren't querying for a
       * front buffer.  If the front buffer we have is a fake front buffer,
       * the X server is going to throw it away when it processes the query.
       * So before doing the query, make sure all the pending drawing has
       * landed in the real front buffer.
d709 1
a709 2
      intel_flush(&intel->ctx);
      intel_flush_front(&intel->ctx);
d712 6
a717 3
   if (back_rb) {
      attachments[i++] = __DRI_BUFFER_BACK_LEFT;
      attachments[i++] = intel_bits_per_pixel(back_rb);
d719 1
a720 1
   assert(i <= ARRAY_SIZE(attachments));
d722 46
a767 6
   *buffers = screen->dri2.loader->getBuffersWithFormat(drawable,
							&drawable->w,
							&drawable->h,
							attachments, i / 2,
							buffer_count,
							drawable->loaderPrivate);
d770 3
a772 30
/**
 * \brief Assign a DRI buffer's DRM region to a renderbuffer.
 *
 * This is called from intel_update_renderbuffers().
 *
 * \par Note:
 *    DRI buffers whose attachment point is DRI2BufferStencil or
 *    DRI2BufferDepthStencil are handled as special cases.
 *
 * \param buffer_name is a human readable name, such as "dri2 front buffer",
 *        that is passed to intel_region_alloc_for_handle().
 *
 * \see intel_update_renderbuffers()
 * \see intel_region_alloc_for_handle()
 */
static void
intel_process_dri2_buffer(struct intel_context *intel,
			  __DRIdrawable *drawable,
			  __DRIbuffer *buffer,
			  struct intel_renderbuffer *rb,
			  const char *buffer_name)
{
   struct intel_region *region = NULL;

   if (!rb)
      return;

   /* We try to avoid closing and reopening the same BO name, because the first
    * use of a mapping of the buffer involves a bunch of page faulting which is
    * moderately expensive.
d774 87
a860 28
   if (rb->mt &&
       rb->mt->region &&
       rb->mt->region->name == buffer->name)
      return;

   if (unlikely(INTEL_DEBUG & DEBUG_DRI)) {
      fprintf(stderr,
	      "attaching buffer %d, at %d, cpp %d, pitch %d\n",
	      buffer->name, buffer->attachment,
	      buffer->cpp, buffer->pitch);
   }

   intel_miptree_release(&rb->mt);
   region = intel_region_alloc_for_handle(intel->intelScreen,
                                          buffer->cpp,
                                          drawable->w,
                                          drawable->h,
                                          buffer->pitch,
                                          buffer->name,
                                          buffer_name);
   if (!region)
      return;

   rb->mt = intel_miptree_create_for_dri2_buffer(intel,
                                                 buffer->attachment,
                                                 intel_rb_format(rb),
                                                 region);
   intel_region_release(&region);
d862 2
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d61 1
d63 1
a64 20
const char *const i915_vendor_string = "Intel Open Source Technology Center";

const char *
i915_get_renderer_string(unsigned deviceID)
{
   const char *chipset;
   static char buffer[128];

   switch (deviceID) {
#undef CHIPSET
#define CHIPSET(id, symbol, str) case id: chipset = str; break;
#include "pci_ids/i915_pci_ids.h"
   default:
      chipset = "Unknown Intel Chipset";
      break;
   }

   (void) driGetRendererString(buffer, chipset, 0);
   return buffer;
}
d70 2
d75 2
a76 1
      return (GLubyte *) i915_vendor_string;
d79 11
a89 2
      return
         (GLubyte *) i915_get_renderer_string(intel->intelScreen->deviceID);
a95 2
#define flushFront(screen)      ((screen)->image.loader ? (screen)->image.loader->flushFrontBuffer : (screen)->dri2.loader->flushFrontBuffer)

d105 1
a105 1
      if (flushFront(screen) && 
d108 2
a109 1
         flushFront(screen)(driDrawable, driDrawable->loaderPrivate);
a118 3
static void
intel_update_image_buffers(struct intel_context *intel, __DRIdrawable *drawable);

d138 2
a139 2
static void
intel_update_dri2_buffers(struct intel_context *intel, __DRIdrawable *drawable)
d141 3
d147 8
a154 2
   struct intel_renderbuffer *rb;
   struct gl_framebuffer *fb = drawable->driverPrivate;
d162 27
a188 10
      switch (buffers[i].attachment) {
      case __DRI_BUFFER_FRONT_LEFT:
         rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
         region_name = "dri2 front buffer";
         break;

      case __DRI_BUFFER_FAKE_FRONT_LEFT:
         rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
         region_name = "dri2 fake front buffer";
         break;
d190 1
a190 18
      case __DRI_BUFFER_BACK_LEFT:
         rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);
         region_name = "dri2 back buffer";
         break;

      case __DRI_BUFFER_DEPTH:
      case __DRI_BUFFER_HIZ:
      case __DRI_BUFFER_DEPTH_STENCIL:
      case __DRI_BUFFER_STENCIL:
      case __DRI_BUFFER_ACCUM:
      default:
         fprintf(stderr,
                 "unhandled buffer attach event, attachment type %d\n",
                 buffers[i].attachment);
         return;
      }

      intel_process_dri2_buffer(intel, drawable, &buffers[i], rb, region_name);
a191 20
}

void
intel_update_renderbuffers(__DRIcontext *context, __DRIdrawable *drawable)
{
   struct intel_context *intel = context->driverPrivate;
   __DRIscreen *screen = intel->intelScreen->driScrnPriv;

   /* Set this up front, so that in case our buffers get invalidated
    * while we're getting new buffers, we don't clobber the stamp and
    * thus ignore the invalidate. */
   drawable->lastStamp = drawable->dri2.stamp;

   if (unlikely(INTEL_DEBUG & DEBUG_DRI))
      fprintf(stderr, "enter %s, drawable %p\n", __func__, drawable);

   if (screen->image.loader)
      intel_update_image_buffers(intel, drawable);
   else
      intel_update_dri2_buffers(intel, drawable);
d253 1
a253 1
intel_noninvalidate_viewport(struct gl_context *ctx)
d258 2
a259 1
    intelCalcViewport(ctx);
a266 6
static void
intel_viewport(struct gl_context *ctx)
{
    intelCalcViewport(ctx);
}

d370 39
a413 1
                 uint32_t flags,
d425 12
d439 2
a440 3
   if (!driContextPriv->driScreenPriv->dri2.useInvalidate)
      functions->Viewport = intel_noninvalidate_viewport;
   else
d442 6
d539 1
a539 1
   intel->hw_stencil = mesaVis && mesaVis->stencilBits && mesaVis->depthBits == 24;
a832 98
}

/**
 * \brief Query DRI Image loader to obtain a DRIdrawable's buffers.
 *
 * To determine which DRI buffers to request, examine the renderbuffers
 * attached to the drawable's framebuffer. Then request the buffers with
 * dri3
 *
 * This is called from intel_update_renderbuffers().
 *
 * \param drawable      Drawable whose buffers are queried.
 * \param buffers       [out] List of buffers returned by DRI2 query.
 * \param buffer_count  [out] Number of buffers returned.
 *
 * \see intel_update_renderbuffers()
 */

static void
intel_update_image_buffer(struct intel_context *intel,
                          __DRIdrawable *drawable,
                          struct intel_renderbuffer *rb,
                          __DRIimage *buffer,
                          enum __DRIimageBufferMask buffer_type)
{
   struct intel_region *region = buffer->region;

   if (!rb || !region)
      return;

   unsigned num_samples = rb->Base.Base.NumSamples;

   if (rb->mt &&
       rb->mt->region &&
       rb->mt->region == region)
      return;

   intel_miptree_release(&rb->mt);
   rb->mt = intel_miptree_create_for_image_buffer(intel,
                                                  buffer_type,
                                                  intel_rb_format(rb),
                                                  num_samples,
                                                  region);
}


static void
intel_update_image_buffers(struct intel_context *intel, __DRIdrawable *drawable)
{
   struct gl_framebuffer *fb = drawable->driverPrivate;
   __DRIscreen *screen = intel->intelScreen->driScrnPriv;
   struct intel_renderbuffer *front_rb;
   struct intel_renderbuffer *back_rb;
   struct __DRIimageList images;
   unsigned int format;
   uint32_t buffer_mask = 0;

   front_rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
   back_rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);

   if (back_rb)
      format = intel_rb_format(back_rb);
   else if (front_rb)
      format = intel_rb_format(front_rb);
   else
      return;

   if ((intel->is_front_buffer_rendering || intel->is_front_buffer_reading || !back_rb) && front_rb)
      buffer_mask |= __DRI_IMAGE_BUFFER_FRONT;

   if (back_rb)
      buffer_mask |= __DRI_IMAGE_BUFFER_BACK;

   (*screen->image.loader->getBuffers) (drawable,
                                        driGLFormatToImageFormat(format),
                                        &drawable->dri2.stamp,
                                        drawable->loaderPrivate,
                                        buffer_mask,
                                        &images);

   if (images.image_mask & __DRI_IMAGE_BUFFER_FRONT) {
      drawable->w = images.front->width;
      drawable->h = images.front->height;
      intel_update_image_buffer(intel,
                                drawable,
                                front_rb,
                                images.front,
                                __DRI_IMAGE_BUFFER_FRONT);
   }
   if (images.image_mask & __DRI_IMAGE_BUFFER_BACK) {
      drawable->w = images.back->width;
      drawable->h = images.back->height;
      intel_update_image_buffer(intel,
                                drawable,
                                back_rb,
                                images.back,
                                __DRI_IMAGE_BUFFER_BACK);
   }
@


1.1.1.6
log
@Import Mesa 10.4.3
@
text
@d59 1
a59 1
#include "util/ralloc.h"
d510 1
@


1.1.1.7
log
@Import Mesa 10.2.9
@
text
@d59 1
a59 1
#include "../glsl/ralloc.h"
a509 1
   intel->hw_stencil = mesaVis && mesaVis->stencilBits && mesaVis->depthBits == 24;
@


