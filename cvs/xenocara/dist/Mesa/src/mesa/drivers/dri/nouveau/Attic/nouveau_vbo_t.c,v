head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.04.50;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.39;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.52;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.54;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright (C) 2009-2010 Francisco Jerez.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "nouveau_driver.h"
#include "nouveau_bufferobj.h"
#include "nouveau_util.h"

#include "main/bufferobj.h"
#include "main/glformats.h"
#include "main/image.h"

/* Arbitrary pushbuf length we can assume we can get with a single
 * call to WAIT_RING. */
#define PUSHBUF_DWORDS 65536

/* Functions to turn GL arrays or index buffers into nouveau_array
 * structures. */

static int
get_array_stride(struct gl_context *ctx, const struct gl_client_array *a)
{
	struct nouveau_render_state *render = to_render_state(ctx);

	if (render->mode == VBO && !_mesa_is_bufferobj(a->BufferObj))
		/* Pack client buffers. */
		return align(_mesa_sizeof_type(a->Type) * a->Size, 4);
	else
		return a->StrideB;
}

static void
vbo_init_arrays(struct gl_context *ctx, const struct _mesa_index_buffer *ib,
		const struct gl_client_array **arrays)
{
	struct nouveau_render_state *render = to_render_state(ctx);
	GLboolean imm = (render->mode == IMM);
	int i, attr;

	if (ib)
		nouveau_init_array(&render->ib, 0, 0, ib->count, ib->type,
				   ib->obj, ib->ptr, GL_TRUE, ctx);

	FOR_EACH_BOUND_ATTR(render, i, attr) {
		const struct gl_client_array *array = arrays[attr];

		nouveau_init_array(&render->attrs[attr], attr,
				   get_array_stride(ctx, array),
				   array->Size, array->Type,
				   imm ? array->BufferObj : NULL,
				   array->Ptr, imm, ctx);
	}
}

static void
vbo_deinit_arrays(struct gl_context *ctx, const struct _mesa_index_buffer *ib,
		  const struct gl_client_array **arrays)
{
	struct nouveau_render_state *render = to_render_state(ctx);
	int i, attr;

	if (ib)
		nouveau_cleanup_array(&render->ib);

	FOR_EACH_BOUND_ATTR(render, i, attr) {
		struct nouveau_array *a = &render->attrs[attr];

		if (render->mode == IMM)
			nouveau_bo_ref(NULL, &a->bo);

		nouveau_deinit_array(a);
		render->map[i] = -1;
	}

	render->attr_count = 0;
}

/* Make some rendering decisions from the GL context. */

static void
vbo_choose_render_mode(struct gl_context *ctx, const struct gl_client_array **arrays)
{
	struct nouveau_render_state *render = to_render_state(ctx);
	int i;

	render->mode = VBO;

	if (ctx->Light.Enabled) {
		for (i = 0; i < MAT_ATTRIB_MAX; i++) {
			if (arrays[VERT_ATTRIB_GENERIC0 + i]->StrideB) {
				render->mode = IMM;
				break;
			}
		}
	}
}

static void
vbo_emit_attr(struct gl_context *ctx, const struct gl_client_array **arrays,
	      int attr)
{
	struct nouveau_pushbuf *push = context_push(ctx);
	struct nouveau_render_state *render = to_render_state(ctx);
	const struct gl_client_array *array = arrays[attr];
	struct nouveau_array *a = &render->attrs[attr];
	RENDER_LOCALS(ctx);

	if (!array->StrideB) {
		if (attr >= VERT_ATTRIB_GENERIC0)
			/* nouveau_update_state takes care of materials. */
			return;

		/* Constant attribute. */
		nouveau_init_array(a, attr, array->StrideB, array->Size,
				   array->Type, array->BufferObj, array->Ptr,
				   GL_TRUE, ctx);
		EMIT_IMM(ctx, a, 0);
		nouveau_deinit_array(a);

	} else {
		/* Varying attribute. */
		struct nouveau_attr_info *info = &TAG(vertex_attrs)[attr];

		if (render->mode == VBO) {
			render->map[info->vbo_index] = attr;
			render->vertex_size += array->_ElementSize;
			render->attr_count = MAX2(render->attr_count,
						  info->vbo_index + 1);
		} else {
			render->map[render->attr_count++] = attr;
			render->vertex_size += 4 * info->imm_fields;
		}
	}
}

#define MAT(a) (VERT_ATTRIB_GENERIC0 + MAT_ATTRIB_##a)

static void
vbo_choose_attrs(struct gl_context *ctx, const struct gl_client_array **arrays)
{
	struct nouveau_render_state *render = to_render_state(ctx);
	int i;

	/* Reset the vertex size. */
	render->vertex_size = 0;
	render->attr_count = 0;

	vbo_emit_attr(ctx, arrays, VERT_ATTRIB_COLOR0);
	if (ctx->Fog.ColorSumEnabled && !ctx->Light.Enabled)
		vbo_emit_attr(ctx, arrays, VERT_ATTRIB_COLOR1);

	for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++) {
		if (ctx->Texture._EnabledCoordUnits & (1 << i))
			vbo_emit_attr(ctx, arrays, VERT_ATTRIB_TEX0 + i);
	}

	if (ctx->Fog.Enabled && ctx->Fog.FogCoordinateSource == GL_FOG_COORD)
		vbo_emit_attr(ctx, arrays, VERT_ATTRIB_FOG);

	if (ctx->Light.Enabled ||
	    (ctx->Texture._GenFlags & TEXGEN_NEED_NORMALS))
		vbo_emit_attr(ctx, arrays, VERT_ATTRIB_NORMAL);

	if (ctx->Light.Enabled && render->mode == IMM) {
		vbo_emit_attr(ctx, arrays, MAT(FRONT_AMBIENT));
		vbo_emit_attr(ctx, arrays, MAT(FRONT_DIFFUSE));
		vbo_emit_attr(ctx, arrays, MAT(FRONT_SPECULAR));
		vbo_emit_attr(ctx, arrays, MAT(FRONT_SHININESS));

		if (ctx->Light.Model.TwoSide) {
			vbo_emit_attr(ctx, arrays, MAT(BACK_AMBIENT));
			vbo_emit_attr(ctx, arrays, MAT(BACK_DIFFUSE));
			vbo_emit_attr(ctx, arrays, MAT(BACK_SPECULAR));
			vbo_emit_attr(ctx, arrays, MAT(BACK_SHININESS));
		}
	}

	vbo_emit_attr(ctx, arrays, VERT_ATTRIB_POS);
}

static int
get_max_client_stride(struct gl_context *ctx, const struct gl_client_array **arrays)
{
	struct nouveau_render_state *render = to_render_state(ctx);
	int i, attr, s = 0;

	FOR_EACH_BOUND_ATTR(render, i, attr) {
		const struct gl_client_array *a = arrays[attr];

		if (!_mesa_is_bufferobj(a->BufferObj))
			s = MAX2(s, get_array_stride(ctx, a));
	}

	return s;
}

static void
TAG(vbo_render_prims)(struct gl_context *ctx,
		      const struct _mesa_prim *prims, GLuint nr_prims,
		      const struct _mesa_index_buffer *ib,
		      GLboolean index_bounds_valid,
		      GLuint min_index, GLuint max_index,
		      struct gl_transform_feedback_object *tfb_vertcount,
		      struct gl_buffer_object *indirect);

static GLboolean
vbo_maybe_split(struct gl_context *ctx, const struct gl_client_array **arrays,
	    const struct _mesa_prim *prims, GLuint nr_prims,
	    const struct _mesa_index_buffer *ib,
	    GLuint min_index, GLuint max_index)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct nouveau_render_state *render = to_render_state(ctx);
	struct nouveau_bufctx *bufctx = nctx->hw.bufctx;
	unsigned pushbuf_avail = PUSHBUF_DWORDS - 2 * (bufctx->relocs +
						       render->attr_count),
		vert_avail = get_max_vertices(ctx, NULL, pushbuf_avail),
		idx_avail = get_max_vertices(ctx, ib, pushbuf_avail);
	int stride;

	/* Try to keep client buffers smaller than the scratch BOs. */
	if (render->mode == VBO &&
	    (stride = get_max_client_stride(ctx, arrays)))
		    vert_avail = MIN2(vert_avail,
				      NOUVEAU_SCRATCH_SIZE / stride);

	if (max_index - min_index > vert_avail ||
	    (ib && ib->count > idx_avail)) {
		struct split_limits limits = {
			.max_verts = vert_avail,
			.max_indices = idx_avail,
			.max_vb_size = ~0,
		};

		vbo_split_prims(ctx, arrays, prims, nr_prims, ib, min_index,
				max_index, TAG(vbo_render_prims), &limits);
		return GL_TRUE;
	}

	return GL_FALSE;
}

/* VBO rendering path. */

static GLboolean
check_update_array(struct nouveau_array *a, unsigned offset,
		   struct nouveau_bo *bo, int *pdelta)
{
	int delta = *pdelta;
	GLboolean dirty;

	if (a->bo == bo) {
		if (delta < 0)
			delta = ((int)offset - (int)a->offset) / a->stride;

		dirty = (delta < 0 ||
			 offset != (a->offset + delta * a->stride));
	} else {
		dirty = GL_TRUE;
	}

	*pdelta = (dirty ? 0 : delta);
	return dirty;
}

static void
vbo_bind_vertices(struct gl_context *ctx, const struct gl_client_array **arrays,
		  int base, unsigned min_index, unsigned max_index, int *pdelta)
{
	struct nouveau_render_state *render = to_render_state(ctx);
	struct nouveau_pushbuf *push = context_push(ctx);
	struct nouveau_bo *bo[NUM_VERTEX_ATTRS];
	unsigned offset[NUM_VERTEX_ATTRS];
	GLboolean dirty = GL_FALSE;
	int i, j, attr;
	RENDER_LOCALS(ctx);

	*pdelta = -1;

	FOR_EACH_BOUND_ATTR(render, i, attr) {
		const struct gl_client_array *array = arrays[attr];
		struct gl_buffer_object *obj = array->BufferObj;
		struct nouveau_array *a = &render->attrs[attr];
		unsigned delta = (base + min_index) * array->StrideB;

		bo[i] = NULL;

		if (nouveau_bufferobj_hw(obj)) {
			/* Array in a buffer obj. */
			nouveau_bo_ref(to_nouveau_bufferobj(obj)->bo, &bo[i]);
			offset[i] = delta + (intptr_t)array->Ptr;

		} else {
			int n = max_index - min_index + 1;
			char *sp = (char *)ADD_POINTERS(
				nouveau_bufferobj_sys(obj), array->Ptr) + delta;
			char *dp  = nouveau_get_scratch(ctx, n * a->stride,
							&bo[i], &offset[i]);

			/* Array in client memory, move it to a
			 * scratch buffer obj. */
			for (j = 0; j < n; j++)
				memcpy(dp + j * a->stride,
				       sp + j * array->StrideB,
				       a->stride);
		}

		dirty |= check_update_array(a, offset[i], bo[i], pdelta);
	}

	*pdelta -= min_index;

	if (dirty) {
		/* Buffers changed, update the attribute binding. */
		FOR_EACH_BOUND_ATTR(render, i, attr) {
			struct nouveau_array *a = &render->attrs[attr];

			nouveau_bo_ref(NULL, &a->bo);
			a->offset = offset[i];
			a->bo = bo[i];
		}

		TAG(render_release_vertices)(ctx);
		TAG(render_bind_vertices)(ctx);
	} else {
		/* Just cleanup. */
		FOR_EACH_BOUND_ATTR(render, i, attr)
			nouveau_bo_ref(NULL, &bo[i]);
	}

	BATCH_VALIDATE();
}

static void
vbo_draw_vbo(struct gl_context *ctx, const struct gl_client_array **arrays,
	     const struct _mesa_prim *prims, GLuint nr_prims,
	     const struct _mesa_index_buffer *ib, GLuint min_index,
	     GLuint max_index)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct nouveau_pushbuf *push = context_push(ctx);
	dispatch_t dispatch = get_array_dispatch(&to_render_state(ctx)->ib);
	int i, delta = 0, basevertex = 0;
	RENDER_LOCALS(ctx);

	TAG(render_set_format)(ctx);

	for (i = 0; i < nr_prims; i++) {
		unsigned start = prims[i].start,
			count = prims[i].count;

		if (i == 0 || basevertex != prims[i].basevertex) {
			basevertex = prims[i].basevertex;
			vbo_bind_vertices(ctx, arrays, basevertex, min_index,
					  max_index, &delta);

			nouveau_pushbuf_bufctx(push, nctx->hw.bufctx);
			if (nouveau_pushbuf_validate(push)) {
				nouveau_pushbuf_bufctx(push, NULL);
				return;
			}
		}

		if (count > get_max_vertices(ctx, ib, PUSH_AVAIL(push)))
			PUSH_SPACE(push, PUSHBUF_DWORDS);

		BATCH_BEGIN(nvgl_primitive(prims[i].mode));
		dispatch(ctx, start, delta, count);
		BATCH_END();
	}

	nouveau_pushbuf_bufctx(push, NULL);
	TAG(render_release_vertices)(ctx);
}

/* Immediate rendering path. */

static unsigned
extract_id(struct nouveau_array *a, int i, int j)
{
	return j;
}

static void
vbo_draw_imm(struct gl_context *ctx, const struct gl_client_array **arrays,
	     const struct _mesa_prim *prims, GLuint nr_prims,
	     const struct _mesa_index_buffer *ib, GLuint min_index,
	     GLuint max_index)
{
	struct nouveau_render_state *render = to_render_state(ctx);
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct nouveau_pushbuf *push = context_push(ctx);
	extract_u_t extract = ib ? render->ib.extract_u : extract_id;
	int i, j, k, attr;
	RENDER_LOCALS(ctx);

	nouveau_pushbuf_bufctx(push, nctx->hw.bufctx);
	if (nouveau_pushbuf_validate(push)) {
		nouveau_pushbuf_bufctx(push, NULL);
		return;
	}

	for (i = 0; i < nr_prims; i++) {
		unsigned start = prims[i].start,
			end = start + prims[i].count;

		if (prims[i].count > get_max_vertices(ctx, ib,
						      PUSH_AVAIL(push)))
			PUSH_SPACE(push, PUSHBUF_DWORDS);

		BATCH_BEGIN(nvgl_primitive(prims[i].mode));

		for (; start < end; start++) {
			j = prims[i].basevertex +
				extract(&render->ib, 0, start);

			FOR_EACH_BOUND_ATTR(render, k, attr)
				EMIT_IMM(ctx, &render->attrs[attr], j);
		}

		BATCH_END();
	}

	nouveau_pushbuf_bufctx(push, NULL);
}

/* draw_prims entry point when we're doing hw-tnl. */

static void
TAG(vbo_render_prims)(struct gl_context *ctx,
		      const struct _mesa_prim *prims, GLuint nr_prims,
		      const struct _mesa_index_buffer *ib,
		      GLboolean index_bounds_valid,
		      GLuint min_index, GLuint max_index,
		      struct gl_transform_feedback_object *tfb_vertcount,
		      struct gl_buffer_object *indirect)
{
	struct nouveau_render_state *render = to_render_state(ctx);
	const struct gl_client_array **arrays = ctx->Array._DrawArrays;

	if (!index_bounds_valid)
		vbo_get_minmax_indices(ctx, prims, ib, &min_index, &max_index,
				       nr_prims);

	vbo_choose_render_mode(ctx, arrays);
	vbo_choose_attrs(ctx, arrays);

	if (vbo_maybe_split(ctx, arrays, prims, nr_prims, ib, min_index,
			    max_index))
		return;

	vbo_init_arrays(ctx, ib, arrays);

	if (render->mode == VBO)
		vbo_draw_vbo(ctx, arrays, prims, nr_prims, ib, min_index,
			     max_index);
	else
		vbo_draw_imm(ctx, arrays, prims, nr_prims, ib, min_index,
			     max_index);

	vbo_deinit_arrays(ctx, ib, arrays);
}

/* VBO rendering entry points. */

static void
TAG(vbo_check_render_prims)(struct gl_context *ctx,
			    const struct _mesa_prim *prims, GLuint nr_prims,
			    const struct _mesa_index_buffer *ib,
			    GLboolean index_bounds_valid,
			    GLuint min_index, GLuint max_index,
			    struct gl_transform_feedback_object *tfb_vertcount,
			    struct gl_buffer_object *indirect)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);

	nouveau_validate_framebuffer(ctx);

	if (nctx->fallback == HWTNL)
		TAG(vbo_render_prims)(ctx, prims, nr_prims, ib,
				      index_bounds_valid, min_index, max_index,
				      tfb_vertcount, indirect);

	if (nctx->fallback == SWTNL)
		_tnl_draw_prims(ctx, prims, nr_prims, ib,
				index_bounds_valid, min_index, max_index,
				tfb_vertcount, indirect);
}

void
TAG(vbo_init)(struct gl_context *ctx)
{
	struct nouveau_render_state *render = to_render_state(ctx);
	int i;

	for (i = 0; i < VERT_ATTRIB_MAX; i++)
		render->map[i] = -1;

	vbo_set_draw_func(ctx, TAG(vbo_check_render_prims));
	vbo_use_buffer_objects(ctx);
}

void
TAG(vbo_destroy)(struct gl_context *ctx)
{
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d225 2
a226 1
		      struct gl_transform_feedback_object *tfb_vertcount);
d457 2
a458 1
		      struct gl_transform_feedback_object *tfb_vertcount)
d494 2
a495 1
			    struct gl_transform_feedback_object *tfb_vertcount)
d504 1
a504 1
				      tfb_vertcount);
d507 3
a509 3
		_tnl_vbo_draw_prims(ctx, prims, nr_prims, ib,
				    index_bounds_valid, min_index, max_index,
				    tfb_vertcount);
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d27 1
d32 1
d64 1
a64 1
				   ib->obj, ib->ptr, GL_TRUE);
d73 1
a73 1
				   array->Ptr, imm);
d124 1
a124 1
	struct nouveau_channel *chan = context_chan(ctx);
d138 1
a138 1
				   GL_TRUE);
d220 1
a220 1
TAG(vbo_render_prims)(struct gl_context *ctx, const struct gl_client_array **arrays,
d224 2
a225 1
		      GLuint min_index, GLuint max_index);
d235 2
a236 1
	unsigned pushbuf_avail = PUSHBUF_DWORDS - 2 * (nctx->bo.count +
d292 1
a292 1
	struct nouveau_channel *chan = context_chan(ctx);
d344 1
a345 1

d361 2
a362 1
	struct nouveau_channel *chan = context_chan(ctx);
d377 6
d385 2
a386 2
		if (count > get_max_vertices(ctx, ib, AVAIL_RING(chan)))
			WAIT_RING(chan, PUSHBUF_DWORDS);
d392 3
d412 2
a413 1
	struct nouveau_channel *chan = context_chan(ctx);
d418 6
d429 2
a430 2
						      AVAIL_RING(chan)))
			WAIT_RING(chan, PUSHBUF_DWORDS);
d444 2
a451 1
		      const struct gl_client_array **arrays,
d455 2
a456 1
		      GLuint min_index, GLuint max_index)
d459 1
d462 2
a463 1
		vbo_get_minmax_index(ctx, prims, ib, &min_index, &max_index);
a487 1
			    const struct gl_client_array **arrays,
d491 2
a492 1
			    GLuint min_index, GLuint max_index)
d499 3
a501 2
		TAG(vbo_render_prims)(ctx, arrays, prims, nr_prims, ib,
				      index_bounds_valid, min_index, max_index);
d504 3
a506 2
		_tnl_vbo_draw_prims(ctx, arrays, prims, nr_prims, ib,
				    index_bounds_valid, min_index, max_index);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d34 2
a35 2
 * WAIT_RING. */
#define PUSHBUF_DWORDS 2048
d37 2
a38 2
/* Functions to set up struct nouveau_array_state from something like
 * a GL array or index buffer. */
d40 2
a41 4
static void
vbo_init_array(struct nouveau_array_state *a, int attr, int stride,
	       int fields, int type, struct gl_buffer_object *obj,
	       const void *ptr, GLboolean map)
d43 1
a43 4
	a->attr = attr;
	a->stride = stride;
	a->fields = fields;
	a->type = type;
d45 5
a49 23
	if (_mesa_is_bufferobj(obj)) {
		nouveau_bo_ref(to_nouveau_bufferobj(obj)->bo, &a->bo);
		a->offset = (intptr_t)ptr;

		if (map) {
			nouveau_bo_map(a->bo, NOUVEAU_BO_RD);
			a->buf = a->bo->map + a->offset;
		} else {
			a->buf = NULL;
		}

	} else {
		nouveau_bo_ref(NULL, &a->bo);
		a->offset = 0;

		if (map)
			a->buf = ptr;
		else
			a->buf = NULL;
	}

	if (a->buf)
		get_array_extract(a, &a->extract_u, &a->extract_f);
d53 1
a53 14
vbo_deinit_array(struct nouveau_array_state *a)
{
	if (a->bo) {
		if (a->bo->map)
			nouveau_bo_unmap(a->bo);
		nouveau_bo_ref(NULL, &a->bo);
	}

	a->buf = NULL;
	a->fields = 0;
}

static void
vbo_init_arrays(GLcontext *ctx, const struct _mesa_index_buffer *ib,
d57 2
a58 1
	int i;
d61 2
a62 2
		vbo_init_array(&render->ib, 0, 0, ib->count, ib->type,
			       ib->obj, ib->ptr, GL_TRUE);
d64 2
a65 2
	for (i = 0; i < render->attr_count; i++) {
		int attr = render->map[i];
d67 5
a71 17
		if (attr >= 0) {
			const struct gl_client_array *array = arrays[attr];
			int stride;

			if (render->mode == VBO &&
			    !_mesa_is_bufferobj(array->BufferObj))
				/* Pack client buffers. */
				stride = align(_mesa_sizeof_type(array->Type)
					       * array->Size, 4);
			else
				stride = array->StrideB;

			vbo_init_array(&render->attrs[attr], attr,
				       stride, array->Size, array->Type,
				       array->BufferObj, array->Ptr,
				       render->mode == IMM);
		}
d76 2
a77 2
vbo_deinit_arrays(GLcontext *ctx, const struct _mesa_index_buffer *ib,
		const struct gl_client_array **arrays)
d80 1
a80 1
	int i;
d83 4
a86 1
		vbo_deinit_array(&render->ib);
d88 2
a89 2
	for (i = 0; i < render->attr_count; i++) {
		int *attr = &render->map[i];
d91 2
a92 4
		if (*attr >= 0) {
			vbo_deinit_array(&render->attrs[*attr]);
			*attr = -1;
		}
d101 1
a101 1
vbo_choose_render_mode(GLcontext *ctx, const struct gl_client_array **arrays)
a115 5

	if (render->mode == VBO)
		render->attr_count = NUM_VERTEX_ATTRS;
	else
		render->attr_count = 0;
d119 2
a120 1
vbo_emit_attr(GLcontext *ctx, const struct gl_client_array **arrays, int attr)
d125 1
a125 1
	struct nouveau_array_state *a = &render->attrs[attr];
d134 3
a136 3
		vbo_init_array(a, attr, array->StrideB, array->Size,
			       array->Type, array->BufferObj, array->Ptr,
			       GL_TRUE);
d138 1
a138 1
		vbo_deinit_array(a);
d147 2
d159 1
a159 1
vbo_choose_attrs(GLcontext *ctx, const struct gl_client_array **arrays)
d166 1
d180 2
a181 1
	if (ctx->Light.Enabled) {
d184 1
d201 2
a202 2
static unsigned
get_max_client_stride(GLcontext *ctx)
d205 1
a205 1
	int i, s = 0;
d207 2
a208 3
	for (i = 0; i < render->attr_count; i++) {
		int attr = render->map[i];
		struct nouveau_array_state *a = &render->attrs[attr];
d210 2
a211 2
		if (attr >= 0 && !a->bo)
			s = MAX2(a->stride, s);
d218 1
a218 1
TAG(vbo_render_prims)(GLcontext *ctx, const struct gl_client_array **arrays,
d225 1
a225 1
vbo_maybe_split(GLcontext *ctx, const struct gl_client_array **arrays,
d232 2
a233 1
	unsigned pushbuf_avail = PUSHBUF_DWORDS - 2 * nctx->bo.count,
d239 2
a240 2
	if (!ib && render->mode == VBO &&
	    (stride = get_max_client_stride(ctx)))
d242 1
a242 1
				      RENDER_SCRATCH_SIZE / stride);
d244 2
a245 3

	if ((ib && ib->count > idx_avail) ||
	    (!ib && max_index - min_index > vert_avail)) {
d262 21
d284 2
a285 2
vbo_bind_vertices(GLcontext *ctx, const struct gl_client_array **arrays,
		  GLint basevertex, GLuint min_index, GLuint max_index)
d288 41
a328 1
	int i;
d330 4
a333 2
	for (i = 0; i < NUM_VERTEX_ATTRS; i++) {
		int attr = render->map[i];
d335 3
a337 19
		if (attr >= 0) {
			const struct gl_client_array *array = arrays[attr];
			struct nouveau_array_state *a = &render->attrs[attr];
			unsigned delta = (basevertex + min_index)
				* array->StrideB;

			if (a->bo) {
				a->offset = (intptr_t)array->Ptr + delta;
			} else {
				int j, n = max_index - min_index + 1;
				char *sp = (char *)array->Ptr + delta;
				char *dp = get_scratch_vbo(ctx, n * a->stride,
							   &a->bo, &a->offset);

				for (j = 0; j < n; j++)
					memcpy(dp + j * a->stride,
					       sp + j * array->StrideB,
					       a->stride);
			}
d339 7
d348 1
a348 1
	TAG(render_bind_vertices)(ctx);
d352 1
a352 1
vbo_draw_vbo(GLcontext *ctx, const struct gl_client_array **arrays,
d358 2
a359 2
	dispatch_t dispatch;
	int delta = -min_index, basevertex = 0, i;
a361 2
	get_array_dispatch(&to_render_state(ctx)->ib, &dispatch);

d370 2
a371 2
			vbo_bind_vertices(ctx, arrays, basevertex,
					  min_index, max_index);
a380 2

	FIRE_RING(chan);
d386 1
a386 1
extract_id(struct nouveau_array_state *a, int i, int j)
d392 1
a392 1
vbo_draw_imm(GLcontext *ctx, const struct gl_client_array **arrays,
d400 1
a400 1
	int i, j, k;
d417 2
a418 3
			for (k = 0; k < render->attr_count; k++)
				EMIT_IMM(ctx, &render->attrs[render->map[k]],
					 j);
a422 2

	FIRE_RING(chan);
d428 2
a429 1
TAG(vbo_render_prims)(GLcontext *ctx, const struct gl_client_array **arrays,
d457 41
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d34 2
a35 2
 * call to WAIT_RING. */
#define PUSHBUF_DWORDS 65536
d37 2
a38 2
/* Functions to turn GL arrays or index buffers into nouveau_array
 * structures. */
d40 4
a43 2
static int
get_array_stride(struct gl_context *ctx, const struct gl_client_array *a)
d45 38
a82 1
	struct nouveau_render_state *render = to_render_state(ctx);
d84 2
a85 5
	if (render->mode == VBO && !_mesa_is_bufferobj(a->BufferObj))
		/* Pack client buffers. */
		return align(_mesa_sizeof_type(a->Type) * a->Size, 4);
	else
		return a->StrideB;
d89 1
a89 1
vbo_init_arrays(struct gl_context *ctx, const struct _mesa_index_buffer *ib,
d93 1
a93 2
	GLboolean imm = (render->mode == IMM);
	int i, attr;
d96 2
a97 2
		nouveau_init_array(&render->ib, 0, 0, ib->count, ib->type,
				   ib->obj, ib->ptr, GL_TRUE);
d99 2
a100 2
	FOR_EACH_BOUND_ATTR(render, i, attr) {
		const struct gl_client_array *array = arrays[attr];
d102 17
a118 5
		nouveau_init_array(&render->attrs[attr], attr,
				   get_array_stride(ctx, array),
				   array->Size, array->Type,
				   imm ? array->BufferObj : NULL,
				   array->Ptr, imm);
d123 2
a124 2
vbo_deinit_arrays(struct gl_context *ctx, const struct _mesa_index_buffer *ib,
		  const struct gl_client_array **arrays)
d127 1
a127 1
	int i, attr;
d130 1
a130 1
		nouveau_cleanup_array(&render->ib);
d132 2
a133 2
	FOR_EACH_BOUND_ATTR(render, i, attr) {
		struct nouveau_array *a = &render->attrs[attr];
d135 4
a138 5
		if (render->mode == IMM)
			nouveau_bo_ref(NULL, &a->bo);

		nouveau_deinit_array(a);
		render->map[i] = -1;
d147 1
a147 1
vbo_choose_render_mode(struct gl_context *ctx, const struct gl_client_array **arrays)
d162 5
d170 1
a170 2
vbo_emit_attr(struct gl_context *ctx, const struct gl_client_array **arrays,
	      int attr)
d175 1
a175 1
	struct nouveau_array *a = &render->attrs[attr];
d184 3
a186 3
		nouveau_init_array(a, attr, array->StrideB, array->Size,
				   array->Type, array->BufferObj, array->Ptr,
				   GL_TRUE);
d188 1
a188 1
		nouveau_deinit_array(a);
a196 2
			render->attr_count = MAX2(render->attr_count,
						  info->vbo_index + 1);
d207 1
a207 1
vbo_choose_attrs(struct gl_context *ctx, const struct gl_client_array **arrays)
a213 1
	render->attr_count = 0;
d227 1
a227 2
	if (ctx->Light.Enabled ||
	    (ctx->Texture._GenFlags & TEXGEN_NEED_NORMALS))
a229 1
	if (ctx->Light.Enabled && render->mode == IMM) {
d246 2
a247 2
static int
get_max_client_stride(struct gl_context *ctx, const struct gl_client_array **arrays)
d250 1
a250 1
	int i, attr, s = 0;
d252 3
a254 2
	FOR_EACH_BOUND_ATTR(render, i, attr) {
		const struct gl_client_array *a = arrays[attr];
d256 2
a257 2
		if (!_mesa_is_bufferobj(a->BufferObj))
			s = MAX2(s, get_array_stride(ctx, a));
d264 1
a264 1
TAG(vbo_render_prims)(struct gl_context *ctx, const struct gl_client_array **arrays,
d271 1
a271 1
vbo_maybe_split(struct gl_context *ctx, const struct gl_client_array **arrays,
d278 1
a278 2
	unsigned pushbuf_avail = PUSHBUF_DWORDS - 2 * (nctx->bo.count +
						       render->attr_count),
d284 2
a285 2
	if (render->mode == VBO &&
	    (stride = get_max_client_stride(ctx, arrays)))
d287 1
a287 1
				      NOUVEAU_SCRATCH_SIZE / stride);
d289 3
a291 2
	if (max_index - min_index > vert_avail ||
	    (ib && ib->count > idx_avail)) {
a307 21
static GLboolean
check_update_array(struct nouveau_array *a, unsigned offset,
		   struct nouveau_bo *bo, int *pdelta)
{
	int delta = *pdelta;
	GLboolean dirty;

	if (a->bo == bo) {
		if (delta < 0)
			delta = ((int)offset - (int)a->offset) / a->stride;

		dirty = (delta < 0 ||
			 offset != (a->offset + delta * a->stride));
	} else {
		dirty = GL_TRUE;
	}

	*pdelta = (dirty ? 0 : delta);
	return dirty;
}

d309 2
a310 2
vbo_bind_vertices(struct gl_context *ctx, const struct gl_client_array **arrays,
		  int base, unsigned min_index, unsigned max_index, int *pdelta)
d313 1
a313 6
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_bo *bo[NUM_VERTEX_ATTRS];
	unsigned offset[NUM_VERTEX_ATTRS];
	GLboolean dirty = GL_FALSE;
	int i, j, attr;
	RENDER_LOCALS(ctx);
d315 2
a316 1
	*pdelta = -1;
d318 19
a336 26
	FOR_EACH_BOUND_ATTR(render, i, attr) {
		const struct gl_client_array *array = arrays[attr];
		struct gl_buffer_object *obj = array->BufferObj;
		struct nouveau_array *a = &render->attrs[attr];
		unsigned delta = (base + min_index) * array->StrideB;

		bo[i] = NULL;

		if (nouveau_bufferobj_hw(obj)) {
			/* Array in a buffer obj. */
			nouveau_bo_ref(to_nouveau_bufferobj(obj)->bo, &bo[i]);
			offset[i] = delta + (intptr_t)array->Ptr;

		} else {
			int n = max_index - min_index + 1;
			char *sp = (char *)ADD_POINTERS(
				nouveau_bufferobj_sys(obj), array->Ptr) + delta;
			char *dp  = nouveau_get_scratch(ctx, n * a->stride,
							&bo[i], &offset[i]);

			/* Array in client memory, move it to a
			 * scratch buffer obj. */
			for (j = 0; j < n; j++)
				memcpy(dp + j * a->stride,
				       sp + j * array->StrideB,
				       a->stride);
a337 2

		dirty |= check_update_array(a, offset[i], bo[i], pdelta);
d340 1
a340 21
	*pdelta -= min_index;

	if (dirty) {
		/* Buffers changed, update the attribute binding. */
		FOR_EACH_BOUND_ATTR(render, i, attr) {
			struct nouveau_array *a = &render->attrs[attr];

			nouveau_bo_ref(NULL, &a->bo);
			a->offset = offset[i];
			a->bo = bo[i];
		}

		TAG(render_bind_vertices)(ctx);

	} else {
		/* Just cleanup. */
		FOR_EACH_BOUND_ATTR(render, i, attr)
			nouveau_bo_ref(NULL, &bo[i]);
	}

	BATCH_VALIDATE();
d344 1
a344 1
vbo_draw_vbo(struct gl_context *ctx, const struct gl_client_array **arrays,
d350 2
a351 2
	dispatch_t dispatch = get_array_dispatch(&to_render_state(ctx)->ib);
	int i, delta = 0, basevertex = 0;
d354 2
d364 2
a365 2
			vbo_bind_vertices(ctx, arrays, basevertex, min_index,
					  max_index, &delta);
d375 2
d382 1
a382 1
extract_id(struct nouveau_array *a, int i, int j)
d388 1
a388 1
vbo_draw_imm(struct gl_context *ctx, const struct gl_client_array **arrays,
d396 1
a396 1
	int i, j, k, attr;
d413 3
a415 2
			FOR_EACH_BOUND_ATTR(render, k, attr)
				EMIT_IMM(ctx, &render->attrs[attr], j);
d420 2
d427 1
a427 2
TAG(vbo_render_prims)(struct gl_context *ctx,
		      const struct gl_client_array **arrays,
a454 41
}

/* VBO rendering entry points. */

static void
TAG(vbo_check_render_prims)(struct gl_context *ctx,
			    const struct gl_client_array **arrays,
			    const struct _mesa_prim *prims, GLuint nr_prims,
			    const struct _mesa_index_buffer *ib,
			    GLboolean index_bounds_valid,
			    GLuint min_index, GLuint max_index)
{
	struct nouveau_context *nctx = to_nouveau_context(ctx);

	nouveau_validate_framebuffer(ctx);

	if (nctx->fallback == HWTNL)
		TAG(vbo_render_prims)(ctx, arrays, prims, nr_prims, ib,
				      index_bounds_valid, min_index, max_index);

	if (nctx->fallback == SWTNL)
		_tnl_vbo_draw_prims(ctx, arrays, prims, nr_prims, ib,
				    index_bounds_valid, min_index, max_index);
}

void
TAG(vbo_init)(struct gl_context *ctx)
{
	struct nouveau_render_state *render = to_render_state(ctx);
	int i;

	for (i = 0; i < VERT_ATTRIB_MAX; i++)
		render->map[i] = -1;

	vbo_set_draw_func(ctx, TAG(vbo_check_render_prims));
	vbo_use_buffer_objects(ctx);
}

void
TAG(vbo_destroy)(struct gl_context *ctx)
{
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a26 1
#include "nouveau_driver.h"
a30 1
#include "main/glformats.h"
d62 1
a62 1
				   ib->obj, ib->ptr, GL_TRUE, ctx);
d71 1
a71 1
				   array->Ptr, imm, ctx);
d122 1
a122 1
	struct nouveau_pushbuf *push = context_push(ctx);
d136 1
a136 1
				   GL_TRUE, ctx);
d218 1
a218 1
TAG(vbo_render_prims)(struct gl_context *ctx,
d222 1
a222 2
		      GLuint min_index, GLuint max_index,
		      struct gl_transform_feedback_object *tfb_vertcount);
d232 1
a232 2
	struct nouveau_bufctx *bufctx = nctx->hw.bufctx;
	unsigned pushbuf_avail = PUSHBUF_DWORDS - 2 * (bufctx->relocs +
d288 1
a288 1
	struct nouveau_pushbuf *push = context_push(ctx);
a339 1
		TAG(render_release_vertices)(ctx);
d341 1
d357 1
a357 2
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct nouveau_pushbuf *push = context_push(ctx);
a371 6

			nouveau_pushbuf_bufctx(push, nctx->hw.bufctx);
			if (nouveau_pushbuf_validate(push)) {
				nouveau_pushbuf_bufctx(push, NULL);
				return;
			}
d374 2
a375 2
		if (count > get_max_vertices(ctx, ib, PUSH_AVAIL(push)))
			PUSH_SPACE(push, PUSHBUF_DWORDS);
a380 3

	nouveau_pushbuf_bufctx(push, NULL);
	TAG(render_release_vertices)(ctx);
d398 1
a398 2
	struct nouveau_context *nctx = to_nouveau_context(ctx);
	struct nouveau_pushbuf *push = context_push(ctx);
a402 6
	nouveau_pushbuf_bufctx(push, nctx->hw.bufctx);
	if (nouveau_pushbuf_validate(push)) {
		nouveau_pushbuf_bufctx(push, NULL);
		return;
	}

d408 2
a409 2
						      PUSH_AVAIL(push)))
			PUSH_SPACE(push, PUSHBUF_DWORDS);
a422 2

	nouveau_pushbuf_bufctx(push, NULL);
d429 1
d433 1
a433 2
		      GLuint min_index, GLuint max_index,
		      struct gl_transform_feedback_object *tfb_vertcount)
a435 1
	const struct gl_client_array **arrays = ctx->Array._DrawArrays;
d438 1
a438 2
		vbo_get_minmax_indices(ctx, prims, ib, &min_index, &max_index,
				       nr_prims);
d463 1
d467 1
a467 2
			    GLuint min_index, GLuint max_index,
			    struct gl_transform_feedback_object *tfb_vertcount)
d474 2
a475 3
		TAG(vbo_render_prims)(ctx, prims, nr_prims, ib,
				      index_bounds_valid, min_index, max_index,
				      tfb_vertcount);
d478 2
a479 3
		_tnl_vbo_draw_prims(ctx, prims, nr_prims, ib,
				    index_bounds_valid, min_index, max_index,
				    tfb_vertcount);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d225 1
a225 2
		      struct gl_transform_feedback_object *tfb_vertcount,
		      struct gl_buffer_object *indirect);
d456 1
a456 2
		      struct gl_transform_feedback_object *tfb_vertcount,
		      struct gl_buffer_object *indirect)
d492 1
a492 2
			    struct gl_transform_feedback_object *tfb_vertcount,
			    struct gl_buffer_object *indirect)
d501 1
a501 1
				      tfb_vertcount, indirect);
d504 3
a506 3
		_tnl_draw_prims(ctx, prims, nr_prims, ib,
				index_bounds_valid, min_index, max_index,
				tfb_vertcount, indirect);
@


