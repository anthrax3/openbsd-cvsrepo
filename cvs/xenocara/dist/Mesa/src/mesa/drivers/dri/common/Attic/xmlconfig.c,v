head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.04.07;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.17;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.13;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.13;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.35;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.15.17;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.46;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.11.19;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.48.26;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * XML DRI client-side driver configuration
 * Copyright (C) 2003 Felix Kuehling
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * FELIX KUEHLING, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM, 
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 */
/**
 * \file xmlconfig.c
 * \brief Driver-independent client-side part of the XML configuration
 * \author Felix Kuehling
 */

#include "main/glheader.h"

#include <string.h>
#include <assert.h>
#include <expat.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include "main/imports.h"
#include "utils.h"
#include "xmlconfig.h"

#undef GET_PROGRAM_NAME

#if (defined(__GNU_LIBRARY__) || defined(__GLIBC__)) && !defined(__UCLIBC__)
#    if !defined(__GLIBC__) || (__GLIBC__ < 2)
/* These aren't declared in any libc5 header */
extern char *program_invocation_name, *program_invocation_short_name;
#    endif
#    define GET_PROGRAM_NAME() program_invocation_short_name
#elif defined(__FreeBSD__) && (__FreeBSD__ >= 2)
#    include <osreldate.h>
#    if (__FreeBSD_version >= 440000)
#        include <stdlib.h>
#        define GET_PROGRAM_NAME() getprogname()
#    endif
#elif defined(__NetBSD__) && defined(__NetBSD_Version) && (__NetBSD_Version >= 106000100)
#    include <stdlib.h>
#    define GET_PROGRAM_NAME() getprogname()
#elif defined(__APPLE__)
#    include <stdlib.h>
#    define GET_PROGRAM_NAME() getprogname()
#elif defined(__sun)
/* Solaris has getexecname() which returns the full path - return just
   the basename to match BSD getprogname() */
#    include <stdlib.h>
#    include <libgen.h>

static const char *__getProgramName () {
    static const char *progname;

    if (progname == NULL) {
	const char *e = getexecname();
	if (e != NULL) {
	    /* Have to make a copy since getexecname can return a readonly
	       string, but basename expects to be able to modify its arg. */
	    char *n = strdup(e);
	    if (n != NULL) {
		progname = basename(n);
	    }
	}
    }
    return progname;
}

#    define GET_PROGRAM_NAME() __getProgramName()
#endif

#if !defined(GET_PROGRAM_NAME)
#    if defined(__OpenBSD__) || defined(NetBSD) || defined(__UCLIBC__) || defined(ANDROID)
/* This is a hack. It's said to work on OpenBSD, NetBSD and GNU.
 * Rogelio M.Serrano Jr. reported it's also working with UCLIBC. It's
 * used as a last resort, if there is no documented facility available. */
static const char *__getProgramName () {
    extern const char *__progname;
    char * arg = strrchr(__progname, '/');
    if (arg)
        return arg+1;
    else
        return __progname;
}
#        define GET_PROGRAM_NAME() __getProgramName()
#    else
#        define GET_PROGRAM_NAME() ""
#        warning "Per application configuration won't work with your OS version."
#    endif
#endif

/** \brief Find an option in an option cache with the name as key */
static GLuint findOption (const driOptionCache *cache, const char *name) {
    GLuint len = strlen (name);
    GLuint size = 1 << cache->tableSize, mask = size - 1;
    GLuint hash = 0;
    GLuint i, shift;

  /* compute a hash from the variable length name */
    for (i = 0, shift = 0; i < len; ++i, shift = (shift+8) & 31)
	hash += (GLuint)name[i] << shift;
    hash *= hash;
    hash = (hash >> (16-cache->tableSize/2)) & mask;

  /* this is just the starting point of the linear search for the option */
    for (i = 0; i < size; ++i, hash = (hash+1) & mask) {
      /* if we hit an empty entry then the option is not defined (yet) */
	if (cache->info[hash].name == 0)
	    break;
	else if (!strcmp (name, cache->info[hash].name))
	    break;
    }
  /* this assertion fails if the hash table is full */
    assert (i < size);

    return hash;
}

/** \brief Like strdup but using malloc and with error checking. */
#define XSTRDUP(dest,source) do { \
    GLuint len = strlen (source); \
    if (!(dest = malloc(len+1))) { \
	fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__); \
	abort(); \
    } \
    memcpy (dest, source, len+1); \
} while (0)

static int compare (const void *a, const void *b) {
    return strcmp (*(char *const*)a, *(char *const*)b);
}
/** \brief Binary search in a string array. */
static GLuint bsearchStr (const XML_Char *name,
			  const XML_Char *elems[], GLuint count) {
    const XML_Char **found;
    found = bsearch (&name, elems, count, sizeof (XML_Char *), compare);
    if (found)
	return found - elems;
    else
	return count;
}

/** \brief Locale-independent integer parser.
 *
 * Works similar to strtol. Leading space is NOT skipped. The input
 * number may have an optional sign. Radix is specified by base. If
 * base is 0 then decimal is assumed unless the input number is
 * prefixed by 0x or 0X for hexadecimal or 0 for octal. After
 * returning tail points to the first character that is not part of
 * the integer number. If no number was found then tail points to the
 * start of the input string. */
static GLint strToI (const XML_Char *string, const XML_Char **tail, int base) {
    GLint radix = base == 0 ? 10 : base;
    GLint result = 0;
    GLint sign = 1;
    GLboolean numberFound = GL_FALSE;
    const XML_Char *start = string;

    assert (radix >= 2 && radix <= 36);

    if (*string == '-') {
	sign = -1;
	string++;
    } else if (*string == '+')
	string++;
    if (base == 0 && *string == '0') {
	numberFound = GL_TRUE; 
	if (*(string+1) == 'x' || *(string+1) == 'X') {
	    radix = 16;
	    string += 2;
	} else {
	    radix = 8;
	    string++;
	}
    }
    do {
	GLint digit = -1;
	if (radix <= 10) {
	    if (*string >= '0' && *string < '0' + radix)
		digit = *string - '0';
	} else {
	    if (*string >= '0' && *string <= '9')
		digit = *string - '0';
	    else if (*string >= 'a' && *string < 'a' + radix - 10)
		digit = *string - 'a' + 10;
	    else if (*string >= 'A' && *string < 'A' + radix - 10)
		digit = *string - 'A' + 10;
	}
	if (digit != -1) {
	    numberFound = GL_TRUE;
	    result = radix*result + digit;
	    string++;
	} else
	    break;
    } while (GL_TRUE);
    *tail = numberFound ? string : start;
    return sign * result;
}

/** \brief Locale-independent floating-point parser.
 *
 * Works similar to strtod. Leading space is NOT skipped. The input
 * number may have an optional sign. '.' is interpreted as decimal
 * point and may occur at most once. Optionally the number may end in
 * [eE]<exponent>, where <exponent> is an integer as recognized by
 * strToI. In that case the result is number * 10^exponent. After
 * returning tail points to the first character that is not part of
 * the floating point number. If no number was found then tail points
 * to the start of the input string.
 *
 * Uses two passes for maximum accuracy. */
static GLfloat strToF (const XML_Char *string, const XML_Char **tail) {
    GLint nDigits = 0, pointPos, exponent;
    GLfloat sign = 1.0f, result = 0.0f, scale;
    const XML_Char *start = string, *numStart;

    /* sign */
    if (*string == '-') {
	sign = -1.0f;
	string++;
    } else if (*string == '+')
	string++;

    /* first pass: determine position of decimal point, number of
     * digits, exponent and the end of the number. */
    numStart = string;
    while (*string >= '0' && *string <= '9') {
	string++;
	nDigits++;
    }
    pointPos = nDigits;
    if (*string == '.') {
	string++;
	while (*string >= '0' && *string <= '9') {
	    string++;
	    nDigits++;
	}
    }
    if (nDigits == 0) {
	/* no digits, no number */
	*tail = start;
	return 0.0f;
    }
    *tail = string;
    if (*string == 'e' || *string == 'E') {
	const XML_Char *expTail;
	exponent = strToI (string+1, &expTail, 10);
	if (expTail == string+1)
	    exponent = 0;
	else
	    *tail = expTail;
    } else
	exponent = 0;
    string = numStart;

    /* scale of the first digit */
    scale = sign * (GLfloat)pow (10.0, (GLdouble)(pointPos-1 + exponent));

    /* second pass: parse digits */
    do {
	if (*string != '.') {
	    assert (*string >= '0' && *string <= '9');
	    result += scale * (GLfloat)(*string - '0');
	    scale *= 0.1f;
	    nDigits--;
	}
	string++;
    } while (nDigits > 0);

    return result;
}

/** \brief Parse a value of a given type. */
static GLboolean parseValue (driOptionValue *v, driOptionType type,
			     const XML_Char *string) {
    const XML_Char *tail = NULL;
  /* skip leading white-space */
    string += strspn (string, " \f\n\r\t\v");
    switch (type) {
      case DRI_BOOL:
	if (!strcmp (string, "false")) {
	    v->_bool = GL_FALSE;
	    tail = string + 5;
	} else if (!strcmp (string, "true")) {
	    v->_bool = GL_TRUE;
	    tail = string + 4;
	}
	else
	    return GL_FALSE;
	break;
      case DRI_ENUM: /* enum is just a special integer */
      case DRI_INT:
	v->_int = strToI (string, &tail, 0);
	break;
      case DRI_FLOAT:
	v->_float = strToF (string, &tail);
	break;
    }

    if (tail == string)
	return GL_FALSE; /* empty string (or containing only white-space) */
  /* skip trailing white space */
    if (*tail)
	tail += strspn (tail, " \f\n\r\t\v");
    if (*tail)
	return GL_FALSE; /* something left over that is not part of value */

    return GL_TRUE;
}

/** \brief Parse a list of ranges of type info->type. */
static GLboolean parseRanges (driOptionInfo *info, const XML_Char *string) {
    XML_Char *cp, *range;
    GLuint nRanges, i;
    driOptionRange *ranges;

    XSTRDUP (cp, string);
  /* pass 1: determine the number of ranges (number of commas + 1) */
    range = cp;
    for (nRanges = 1; *range; ++range)
	if (*range == ',')
	    ++nRanges;

    if ((ranges = malloc(nRanges*sizeof(driOptionRange))) == NULL) {
	fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__);
	abort();
    }

  /* pass 2: parse all ranges into preallocated array */
    range = cp;
    for (i = 0; i < nRanges; ++i) {
	XML_Char *end, *sep;
	assert (range);
	end = strchr (range, ',');
	if (end)
	    *end = '\0';
	sep = strchr (range, ':');
	if (sep) { /* non-empty interval */
	    *sep = '\0';
	    if (!parseValue (&ranges[i].start, info->type, range) ||
		!parseValue (&ranges[i].end, info->type, sep+1))
	        break;
	    if (info->type == DRI_INT &&
		ranges[i].start._int > ranges[i].end._int)
		break;
	    if (info->type == DRI_FLOAT &&
		ranges[i].start._float > ranges[i].end._float)
		break;
	} else { /* empty interval */
	    if (!parseValue (&ranges[i].start, info->type, range))
		break;
	    ranges[i].end = ranges[i].start;
	}
	if (end)
	    range = end+1;
	else
	    range = NULL;
    }
    free(cp);
    if (i < nRanges) {
	free(ranges);
	return GL_FALSE;
    } else
	assert (range == NULL);

    info->nRanges = nRanges;
    info->ranges = ranges;
    return GL_TRUE;
}

/** \brief Check if a value is in one of info->ranges. */
static GLboolean checkValue (const driOptionValue *v, const driOptionInfo *info) {
    GLuint i;
    assert (info->type != DRI_BOOL); /* should be caught by the parser */
    if (info->nRanges == 0)
	return GL_TRUE;
    switch (info->type) {
      case DRI_ENUM: /* enum is just a special integer */
      case DRI_INT:
	for (i = 0; i < info->nRanges; ++i)
	    if (v->_int >= info->ranges[i].start._int &&
		v->_int <= info->ranges[i].end._int)
		return GL_TRUE;
	break;
      case DRI_FLOAT:
	for (i = 0; i < info->nRanges; ++i)
	    if (v->_float >= info->ranges[i].start._float &&
		v->_float <= info->ranges[i].end._float)
		return GL_TRUE;
	break;
      default:
	assert (0); /* should never happen */
    }
    return GL_FALSE;
}

/**
 * Print message to \c stderr if the \c LIBGL_DEBUG environment variable
 * is set. 
 * 
 * Is called from the drivers.
 * 
 * \param f \c printf like format string.
 */
static void
__driUtilMessage(const char *f, ...)
{
    va_list args;

    if (getenv("LIBGL_DEBUG")) {
        fprintf(stderr, "libGL: ");
        va_start(args, f);
        vfprintf(stderr, f, args);
        va_end(args);
        fprintf(stderr, "\n");
    }
}

/** \brief Output a warning message. */
#define XML_WARNING1(msg) do {\
    __driUtilMessage ("Warning in %s line %d, column %d: "msg, data->name, \
                      (int) XML_GetCurrentLineNumber(data->parser), \
                      (int) XML_GetCurrentColumnNumber(data->parser)); \
} while (0)
#define XML_WARNING(msg,args...) do { \
    __driUtilMessage ("Warning in %s line %d, column %d: "msg, data->name, \
                      (int) XML_GetCurrentLineNumber(data->parser), \
                      (int) XML_GetCurrentColumnNumber(data->parser), \
                      args); \
} while (0)
/** \brief Output an error message. */
#define XML_ERROR1(msg) do { \
    __driUtilMessage ("Error in %s line %d, column %d: "msg, data->name, \
                      (int) XML_GetCurrentLineNumber(data->parser), \
                      (int) XML_GetCurrentColumnNumber(data->parser)); \
} while (0)
#define XML_ERROR(msg,args...) do { \
    __driUtilMessage ("Error in %s line %d, column %d: "msg, data->name, \
                      (int) XML_GetCurrentLineNumber(data->parser), \
                      (int) XML_GetCurrentColumnNumber(data->parser), \
                      args); \
} while (0)
/** \brief Output a fatal error message and abort. */
#define XML_FATAL1(msg) do { \
    fprintf (stderr, "Fatal error in %s line %d, column %d: "msg"\n", \
             data->name, \
             (int) XML_GetCurrentLineNumber(data->parser),	\
             (int) XML_GetCurrentColumnNumber(data->parser)); \
    abort();\
} while (0)
#define XML_FATAL(msg,args...) do { \
    fprintf (stderr, "Fatal error in %s line %d, column %d: "msg"\n", \
             data->name, \
             (int) XML_GetCurrentLineNumber(data->parser),	\
             (int) XML_GetCurrentColumnNumber(data->parser),		\
             args); \
    abort();\
} while (0)

/** \brief Parser context for __driConfigOptions. */
struct OptInfoData {
    const char *name;
    XML_Parser parser;
    driOptionCache *cache;
    GLboolean inDriInfo;
    GLboolean inSection;
    GLboolean inDesc;
    GLboolean inOption;
    GLboolean inEnum;
    int curOption;
};

/** \brief Elements in __driConfigOptions. */
enum OptInfoElem {
    OI_DESCRIPTION = 0, OI_DRIINFO, OI_ENUM, OI_OPTION, OI_SECTION, OI_COUNT
};
static const XML_Char *OptInfoElems[] = {
    "description", "driinfo", "enum", "option", "section"
};

/** \brief Parse attributes of an enum element.
 *
 * We're not actually interested in the data. Just make sure this is ok
 * for external configuration tools.
 */
static void parseEnumAttr (struct OptInfoData *data, const XML_Char **attr) {
    GLuint i;
    const XML_Char *value = NULL, *text = NULL;
    driOptionValue v;
    GLuint opt = data->curOption;
    for (i = 0; attr[i]; i += 2) {
	if (!strcmp (attr[i], "value")) value = attr[i+1];
	else if (!strcmp (attr[i], "text")) text = attr[i+1];
	else XML_FATAL("illegal enum attribute: %s.", attr[i]);
    }
    if (!value) XML_FATAL1 ("value attribute missing in enum.");
    if (!text) XML_FATAL1 ("text attribute missing in enum.");
     if (!parseValue (&v, data->cache->info[opt].type, value))
	XML_FATAL ("illegal enum value: %s.", value);
    if (!checkValue (&v, &data->cache->info[opt]))
	XML_FATAL ("enum value out of valid range: %s.", value);
}

/** \brief Parse attributes of a description element.
 *
 * We're not actually interested in the data. Just make sure this is ok
 * for external configuration tools.
 */
static void parseDescAttr (struct OptInfoData *data, const XML_Char **attr) {
    GLuint i;
    const XML_Char *lang = NULL, *text = NULL;
    for (i = 0; attr[i]; i += 2) {
	if (!strcmp (attr[i], "lang")) lang = attr[i+1];
	else if (!strcmp (attr[i], "text")) text = attr[i+1];
	else XML_FATAL("illegal description attribute: %s.", attr[i]);
    }
    if (!lang) XML_FATAL1 ("lang attribute missing in description.");
    if (!text) XML_FATAL1 ("text attribute missing in description.");
}

/** \brief Parse attributes of an option element. */
static void parseOptInfoAttr (struct OptInfoData *data, const XML_Char **attr) {
    enum OptAttr {OA_DEFAULT = 0, OA_NAME, OA_TYPE, OA_VALID, OA_COUNT};
    static const XML_Char *optAttr[] = {"default", "name", "type", "valid"};
    const XML_Char *attrVal[OA_COUNT] = {NULL, NULL, NULL, NULL};
    const char *defaultVal;
    driOptionCache *cache = data->cache;
    GLuint opt, i;
    for (i = 0; attr[i]; i += 2) {
	GLuint attrName = bsearchStr (attr[i], optAttr, OA_COUNT);
	if (attrName >= OA_COUNT)
	    XML_FATAL ("illegal option attribute: %s", attr[i]);
	attrVal[attrName] = attr[i+1];
    }
    if (!attrVal[OA_NAME]) XML_FATAL1 ("name attribute missing in option.");
    if (!attrVal[OA_TYPE]) XML_FATAL1 ("type attribute missing in option.");
    if (!attrVal[OA_DEFAULT]) XML_FATAL1 ("default attribute missing in option.");

    opt = findOption (cache, attrVal[OA_NAME]);
    if (cache->info[opt].name)
	XML_FATAL ("option %s redefined.", attrVal[OA_NAME]);
    data->curOption = opt;

    XSTRDUP (cache->info[opt].name, attrVal[OA_NAME]);

    if (!strcmp (attrVal[OA_TYPE], "bool"))
	cache->info[opt].type = DRI_BOOL;
    else if (!strcmp (attrVal[OA_TYPE], "enum"))
	cache->info[opt].type = DRI_ENUM;
    else if (!strcmp (attrVal[OA_TYPE], "int"))
	cache->info[opt].type = DRI_INT;
    else if (!strcmp (attrVal[OA_TYPE], "float"))
	cache->info[opt].type = DRI_FLOAT;
    else
	XML_FATAL ("illegal type in option: %s.", attrVal[OA_TYPE]);

    defaultVal = getenv (cache->info[opt].name);
    if (defaultVal != NULL) {
      /* don't use XML_WARNING, we want the user to see this! */
	fprintf (stderr,
		 "ATTENTION: default value of option %s overridden by environment.\n",
		 cache->info[opt].name);
    } else
	defaultVal = attrVal[OA_DEFAULT];
    if (!parseValue (&cache->values[opt], cache->info[opt].type, defaultVal))
	XML_FATAL ("illegal default value for %s: %s.", cache->info[opt].name, defaultVal);

    if (attrVal[OA_VALID]) {
	if (cache->info[opt].type == DRI_BOOL)
	    XML_FATAL1 ("boolean option with valid attribute.");
	if (!parseRanges (&cache->info[opt], attrVal[OA_VALID]))
	    XML_FATAL ("illegal valid attribute: %s.", attrVal[OA_VALID]);
	if (!checkValue (&cache->values[opt], &cache->info[opt]))
	    XML_FATAL ("default value out of valid range '%s': %s.",
		       attrVal[OA_VALID], defaultVal);
    } else if (cache->info[opt].type == DRI_ENUM) {
	XML_FATAL1 ("valid attribute missing in option (mandatory for enums).");
    } else {
	cache->info[opt].nRanges = 0;
	cache->info[opt].ranges = NULL;
    }
}

/** \brief Handler for start element events. */
static void optInfoStartElem (void *userData, const XML_Char *name,
			      const XML_Char **attr) {
    struct OptInfoData *data = (struct OptInfoData *)userData;
    enum OptInfoElem elem = bsearchStr (name, OptInfoElems, OI_COUNT);
    switch (elem) {
      case OI_DRIINFO:
	if (data->inDriInfo)
	    XML_FATAL1 ("nested <driinfo> elements.");
	if (attr[0])
	    XML_FATAL1 ("attributes specified on <driinfo> element.");
	data->inDriInfo = GL_TRUE;
	break;
      case OI_SECTION:
	if (!data->inDriInfo)
	    XML_FATAL1 ("<section> must be inside <driinfo>.");
	if (data->inSection)
	    XML_FATAL1 ("nested <section> elements.");
	if (attr[0])
	    XML_FATAL1 ("attributes specified on <section> element.");
	data->inSection = GL_TRUE;
	break;
      case OI_DESCRIPTION:
	if (!data->inSection && !data->inOption)
	    XML_FATAL1 ("<description> must be inside <description> or <option.");
	if (data->inDesc)
	    XML_FATAL1 ("nested <description> elements.");
	data->inDesc = GL_TRUE;
	parseDescAttr (data, attr);
	break;
      case OI_OPTION:
	if (!data->inSection)
	    XML_FATAL1 ("<option> must be inside <section>.");
	if (data->inDesc)
	    XML_FATAL1 ("<option> nested in <description> element.");
	if (data->inOption)
	    XML_FATAL1 ("nested <option> elements.");
	data->inOption = GL_TRUE;
	parseOptInfoAttr (data, attr);
	break;
      case OI_ENUM:
	if (!(data->inOption && data->inDesc))
	    XML_FATAL1 ("<enum> must be inside <option> and <description>.");
	if (data->inEnum)
	    XML_FATAL1 ("nested <enum> elements.");
	data->inEnum = GL_TRUE;
	parseEnumAttr (data, attr);
	break;
      default:
	XML_FATAL ("unknown element: %s.", name);
    }
}

/** \brief Handler for end element events. */
static void optInfoEndElem (void *userData, const XML_Char *name) {
    struct OptInfoData *data = (struct OptInfoData *)userData;
    enum OptInfoElem elem = bsearchStr (name, OptInfoElems, OI_COUNT);
    switch (elem) {
      case OI_DRIINFO:
	data->inDriInfo = GL_FALSE;
	break;
      case OI_SECTION:
	data->inSection = GL_FALSE;
	break;
      case OI_DESCRIPTION:
	data->inDesc = GL_FALSE;
	break;
      case OI_OPTION:
	data->inOption = GL_FALSE;
	break;
      case OI_ENUM:
	data->inEnum = GL_FALSE;
	break;
      default:
	assert (0); /* should have been caught by StartElem */
    }
}

void driParseOptionInfo (driOptionCache *info, const char *configOptions) {
    XML_Parser p;
    int status;
    struct OptInfoData userData;
    struct OptInfoData *data = &userData;

    /* Make the hash table big enough to fit more than the maximum number of
     * config options we've ever seen in a driver.
     */
    info->tableSize = 6;
    info->info = calloc(1 << info->tableSize, sizeof (driOptionInfo));
    info->values = calloc(1 << info->tableSize, sizeof (driOptionValue));
    if (info->info == NULL || info->values == NULL) {
	fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__);
	abort();
    }

    p = XML_ParserCreate ("UTF-8"); /* always UTF-8 */
    XML_SetElementHandler (p, optInfoStartElem, optInfoEndElem);
    XML_SetUserData (p, data);

    userData.name = "__driConfigOptions";
    userData.parser = p;
    userData.cache = info;
    userData.inDriInfo = GL_FALSE;
    userData.inSection = GL_FALSE;
    userData.inDesc = GL_FALSE;
    userData.inOption = GL_FALSE;
    userData.inEnum = GL_FALSE;
    userData.curOption = -1;

    status = XML_Parse (p, configOptions, strlen (configOptions), 1);
    if (!status)
	XML_FATAL ("%s.", XML_ErrorString(XML_GetErrorCode(p)));

    XML_ParserFree (p);
}

/** \brief Parser context for configuration files. */
struct OptConfData {
    const char *name;
    XML_Parser parser;
    driOptionCache *cache;
    GLint screenNum;
    const char *driverName, *execName;
    GLuint ignoringDevice;
    GLuint ignoringApp;
    GLuint inDriConf;
    GLuint inDevice;
    GLuint inApp;
    GLuint inOption;
};

/** \brief Elements in configuration files. */
enum OptConfElem {
    OC_APPLICATION = 0, OC_DEVICE, OC_DRICONF, OC_OPTION, OC_COUNT
};
static const XML_Char *OptConfElems[] = {
    "application", "device", "driconf", "option"
};

/** \brief Parse attributes of a device element. */
static void parseDeviceAttr (struct OptConfData *data, const XML_Char **attr) {
    GLuint i;
    const XML_Char *driver = NULL, *screen = NULL;
    for (i = 0; attr[i]; i += 2) {
	if (!strcmp (attr[i], "driver")) driver = attr[i+1];
	else if (!strcmp (attr[i], "screen")) screen = attr[i+1];
	else XML_WARNING("unknown device attribute: %s.", attr[i]);
    }
    if (driver && strcmp (driver, data->driverName))
	data->ignoringDevice = data->inDevice;
    else if (screen) {
	driOptionValue screenNum;
	if (!parseValue (&screenNum, DRI_INT, screen))
	    XML_WARNING("illegal screen number: %s.", screen);
	else if (screenNum._int != data->screenNum)
	    data->ignoringDevice = data->inDevice;
    }
}

/** \brief Parse attributes of an application element. */
static void parseAppAttr (struct OptConfData *data, const XML_Char **attr) {
    GLuint i;
    const XML_Char *exec = NULL;
    for (i = 0; attr[i]; i += 2) {
	if (!strcmp (attr[i], "name")) /* not needed here */;
	else if (!strcmp (attr[i], "executable")) exec = attr[i+1];
	else XML_WARNING("unknown application attribute: %s.", attr[i]);
    }
    if (exec && strcmp (exec, data->execName))
	data->ignoringApp = data->inApp;
}

/** \brief Parse attributes of an option element. */
static void parseOptConfAttr (struct OptConfData *data, const XML_Char **attr) {
    GLuint i;
    const XML_Char *name = NULL, *value = NULL;
    for (i = 0; attr[i]; i += 2) {
	if (!strcmp (attr[i], "name")) name = attr[i+1];
	else if (!strcmp (attr[i], "value")) value = attr[i+1];
	else XML_WARNING("unknown option attribute: %s.", attr[i]);
    }
    if (!name) XML_WARNING1 ("name attribute missing in option.");
    if (!value) XML_WARNING1 ("value attribute missing in option.");
    if (name && value) {
	driOptionCache *cache = data->cache;
	GLuint opt = findOption (cache, name);
	if (cache->info[opt].name == NULL)
            /* don't use XML_WARNING, drirc defines options for all drivers,
             * but not all drivers support them */
            return;
	else if (getenv (cache->info[opt].name))
	  /* don't use XML_WARNING, we want the user to see this! */
	    fprintf (stderr, "ATTENTION: option value of option %s ignored.\n",
		     cache->info[opt].name);
	else if (!parseValue (&cache->values[opt], cache->info[opt].type, value))
	    XML_WARNING ("illegal option value: %s.", value);
    }
}

/** \brief Handler for start element events. */
static void optConfStartElem (void *userData, const XML_Char *name,
			      const XML_Char **attr) {
    struct OptConfData *data = (struct OptConfData *)userData;
    enum OptConfElem elem = bsearchStr (name, OptConfElems, OC_COUNT);
    switch (elem) {
      case OC_DRICONF:
	if (data->inDriConf)
	    XML_WARNING1 ("nested <driconf> elements.");
	if (attr[0])
	    XML_WARNING1 ("attributes specified on <driconf> element.");
	data->inDriConf++;
	break;
      case OC_DEVICE:
	if (!data->inDriConf)
	    XML_WARNING1 ("<device> should be inside <driconf>.");
	if (data->inDevice)
	    XML_WARNING1 ("nested <device> elements.");
	data->inDevice++;
	if (!data->ignoringDevice && !data->ignoringApp)
	    parseDeviceAttr (data, attr);
	break;
      case OC_APPLICATION:
	if (!data->inDevice)
	    XML_WARNING1 ("<application> should be inside <device>.");
	if (data->inApp)
	    XML_WARNING1 ("nested <application> elements.");
	data->inApp++;
	if (!data->ignoringDevice && !data->ignoringApp)
	    parseAppAttr (data, attr);
	break;
      case OC_OPTION:
	if (!data->inApp)
	    XML_WARNING1 ("<option> should be inside <application>.");
	if (data->inOption)
	    XML_WARNING1 ("nested <option> elements.");
	data->inOption++;
	if (!data->ignoringDevice && !data->ignoringApp)
	    parseOptConfAttr (data, attr);
	break;
      default:
	XML_WARNING ("unknown element: %s.", name);
    }
}

/** \brief Handler for end element events. */
static void optConfEndElem (void *userData, const XML_Char *name) {
    struct OptConfData *data = (struct OptConfData *)userData;
    enum OptConfElem elem = bsearchStr (name, OptConfElems, OC_COUNT);
    switch (elem) {
      case OC_DRICONF:
	data->inDriConf--;
	break;
      case OC_DEVICE:
	if (data->inDevice-- == data->ignoringDevice)
	    data->ignoringDevice = 0;
	break;
      case OC_APPLICATION:
	if (data->inApp-- == data->ignoringApp)
	    data->ignoringApp = 0;
	break;
      case OC_OPTION:
	data->inOption--;
	break;
      default:
	/* unknown element, warning was produced on start tag */;
    }
}

/** \brief Initialize an option cache based on info */
static void initOptionCache (driOptionCache *cache, const driOptionCache *info) {
    cache->info = info->info;
    cache->tableSize = info->tableSize;
    cache->values = malloc((1<<info->tableSize) * sizeof (driOptionValue));
    if (cache->values == NULL) {
	fprintf (stderr, "%s: %d: out of memory.\n", __FILE__, __LINE__);
	abort();
    }
    memcpy (cache->values, info->values,
	    (1<<info->tableSize) * sizeof (driOptionValue));
}

/** \brief Parse the named configuration file */
static void parseOneConfigFile (XML_Parser p) {
#define BUF_SIZE 0x1000
    struct OptConfData *data = (struct OptConfData *)XML_GetUserData (p);
    int status;
    int fd;

    if ((fd = open (data->name, O_RDONLY)) == -1) {
	__driUtilMessage ("Can't open configuration file %s: %s.",
			  data->name, strerror (errno));
	return;
    }

    while (1) {
	int bytesRead;
	void *buffer = XML_GetBuffer (p, BUF_SIZE);
	if (!buffer) {
	    __driUtilMessage ("Can't allocate parser buffer.");
	    break;
	}
	bytesRead = read (fd, buffer, BUF_SIZE);
	if (bytesRead == -1) {
	    __driUtilMessage ("Error reading from configuration file %s: %s.",
			      data->name, strerror (errno));
	    break;
	}
	status = XML_ParseBuffer (p, bytesRead, bytesRead == 0);
	if (!status) {
	    XML_ERROR ("%s.", XML_ErrorString(XML_GetErrorCode(p)));
	    break;
	}
	if (bytesRead == 0)
	    break;
    }

    close (fd);
#undef BUF_SIZE
}

void driParseConfigFiles (driOptionCache *cache, const driOptionCache *info,
			  GLint screenNum, const char *driverName) {
    char *filenames[2] = {"/etc/drirc", NULL};
    char *home;
    GLuint i;
    struct OptConfData userData;

    initOptionCache (cache, info);

    userData.cache = cache;
    userData.screenNum = screenNum;
    userData.driverName = driverName;
    userData.execName = GET_PROGRAM_NAME();

    if ((home = getenv ("HOME"))) {
	GLuint len = strlen (home);
	filenames[1] = malloc(len + 7+1);
	if (filenames[1] == NULL)
	    __driUtilMessage ("Can't allocate memory for %s/.drirc.", home);
	else {
	    memcpy (filenames[1], home, len);
	    memcpy (filenames[1] + len, "/.drirc", 7+1);
	}
    }

    for (i = 0; i < 2; ++i) {
	XML_Parser p;
	if (filenames[i] == NULL)
	    continue;

	p = XML_ParserCreate (NULL); /* use encoding specified by file */
	XML_SetElementHandler (p, optConfStartElem, optConfEndElem);
	XML_SetUserData (p, &userData);
	userData.parser = p;
	userData.name = filenames[i];
	userData.ignoringDevice = 0;
	userData.ignoringApp = 0;
	userData.inDriConf = 0;
	userData.inDevice = 0;
	userData.inApp = 0;
	userData.inOption = 0;

	parseOneConfigFile (p);
	XML_ParserFree (p);
    }

    free(filenames[1]);
}

void driDestroyOptionInfo (driOptionCache *info) {
    driDestroyOptionCache (info);
    if (info->info) {
	GLuint i, size = 1 << info->tableSize;
	for (i = 0; i < size; ++i) {
	    if (info->info[i].name) {
		free(info->info[i].name);
		free(info->info[i].ranges);
	    }
	}
	free(info->info);
    }
}

void driDestroyOptionCache (driOptionCache *cache) {
    free(cache->values);
}

GLboolean driCheckOption (const driOptionCache *cache, const char *name,
			  driOptionType type) {
    GLuint i = findOption (cache, name);
    return cache->info[i].name != NULL && cache->info[i].type == type;
}

GLboolean driQueryOptionb (const driOptionCache *cache, const char *name) {
    GLuint i = findOption (cache, name);
  /* make sure the option is defined and has the correct type */
    assert (cache->info[i].name != NULL);
    assert (cache->info[i].type == DRI_BOOL);
    return cache->values[i]._bool;
}

GLint driQueryOptioni (const driOptionCache *cache, const char *name) {
    GLuint i = findOption (cache, name);
  /* make sure the option is defined and has the correct type */
    assert (cache->info[i].name != NULL);
    assert (cache->info[i].type == DRI_INT || cache->info[i].type == DRI_ENUM);
    return cache->values[i]._int;
}

GLfloat driQueryOptionf (const driOptionCache *cache, const char *name) {
    GLuint i = findOption (cache, name);
  /* make sure the option is defined and has the correct type */
    assert (cache->info[i].name != NULL);
    assert (cache->info[i].type == DRI_FLOAT);
    return cache->values[i]._float;
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d30 2
a49 2
#elif defined(__CYGWIN__)
#    define GET_PROGRAM_NAME() program_invocation_short_name
d109 5
a113 5
static uint32_t findOption (const driOptionCache *cache, const char *name) {
    uint32_t len = strlen (name);
    uint32_t size = 1 << cache->tableSize, mask = size - 1;
    uint32_t hash = 0;
    uint32_t i, shift;
d117 1
a117 1
	hash += (uint32_t)name[i] << shift;
d137 1
a137 1
    uint32_t len = strlen (source); \
d149 2
a150 2
static uint32_t bsearchStr (const XML_Char *name,
			  const XML_Char *elems[], uint32_t count) {
d168 5
a172 5
static int strToI (const XML_Char *string, const XML_Char **tail, int base) {
    int radix = base == 0 ? 10 : base;
    int result = 0;
    int sign = 1;
    bool numberFound = false;
d183 1
a183 1
	numberFound = true;
d193 1
a193 1
	int digit = -1;
d206 1
a206 1
	    numberFound = true;
d211 1
a211 1
    } while (true);
d228 3
a230 3
static float strToF (const XML_Char *string, const XML_Char **tail) {
    int nDigits = 0, pointPos, exponent;
    float sign = 1.0f, result = 0.0f, scale;
d273 1
a273 1
    scale = sign * (float)pow (10.0, (double)(pointPos-1 + exponent));
d279 1
a279 1
	    result += scale * (float)(*string - '0');
d290 1
a290 1
static unsigned char parseValue (driOptionValue *v, driOptionType type,
d298 1
a298 1
	    v->_bool = false;
d301 1
a301 1
	    v->_bool = true;
d305 1
a305 1
	    return false;
a313 5
      case DRI_STRING:
	if (v->_string)
	    free (v->_string);
	v->_string = strndup(string, STRING_CONF_MAXLEN);
	return GL_TRUE;
d317 1
a317 1
	return false; /* empty string (or containing only white-space) */
d322 1
a322 1
	return false; /* something left over that is not part of value */
d324 1
a324 1
    return true;
d328 1
a328 1
static unsigned char parseRanges (driOptionInfo *info, const XML_Char *string) {
d330 1
a330 1
    uint32_t nRanges, i;
d378 1
a378 1
	return false;
d384 1
a384 1
    return true;
d388 2
a389 2
static bool checkValue (const driOptionValue *v, const driOptionInfo *info) {
    uint32_t i;
d392 1
a392 1
	return true;
d399 1
a399 1
		return true;
d405 1
a405 3
		return true;
	break;
      case DRI_STRING:
d410 1
a410 1
    return false;
a424 1
    const char *libgl_debug;
d426 1
a426 2
    libgl_debug=getenv("LIBGL_DEBUG");
    if (libgl_debug && !strstr(libgl_debug, "quiet")) {
d481 5
a485 5
    bool inDriInfo;
    bool inSection;
    bool inDesc;
    bool inOption;
    bool inEnum;
d503 1
a503 1
    uint32_t i;
d506 1
a506 1
    uint32_t opt = data->curOption;
d526 1
a526 1
    uint32_t i;
d544 1
a544 1
    uint32_t opt, i;
d546 1
a546 1
	uint32_t attrName = bsearchStr (attr[i], optAttr, OA_COUNT);
a569 2
    else if (!strcmp (attrVal[OA_TYPE], "string"))
	cache->info[opt].type = DRI_STRING;
d611 1
a611 1
	data->inDriInfo = true;
d620 1
a620 1
	data->inSection = true;
d627 1
a627 1
	data->inDesc = true;
d637 1
a637 1
	data->inOption = true;
d645 1
a645 1
	data->inEnum = true;
d659 1
a659 1
	data->inDriInfo = false;
d662 1
a662 1
	data->inSection = false;
d665 1
a665 1
	data->inDesc = false;
d668 1
a668 1
	data->inOption = false;
d671 1
a671 1
	data->inEnum = false;
d702 5
a706 5
    userData.inDriInfo = false;
    userData.inSection = false;
    userData.inDesc = false;
    userData.inOption = false;
    userData.inEnum = false;
d721 1
a721 1
    int screenNum;
d723 6
a728 6
    uint32_t ignoringDevice;
    uint32_t ignoringApp;
    uint32_t inDriConf;
    uint32_t inDevice;
    uint32_t inApp;
    uint32_t inOption;
d741 1
a741 1
    uint32_t i;
d761 1
a761 1
    uint32_t i;
d774 1
a774 1
    uint32_t i;
d785 1
a785 1
	uint32_t opt = findOption (cache, name);
a869 1
    GLuint i, size = 1 << info->tableSize;
a878 4
    for (i = 0; i < size; ++i) {
	if (cache->info[i].type == DRI_STRING)
	    XSTRDUP(cache->values[i]._string, info->values[i]._string);
    }
d921 1
a921 1
			  int screenNum, const char *driverName) {
d924 1
a924 1
    uint32_t i;
d935 1
a935 1
	uint32_t len = strlen (home);
d972 1
a972 1
	uint32_t i, size = 1 << info->tableSize;
a983 7
    if (cache->info) {
	GLuint i, size = 1 << cache->tableSize;
	for (i = 0; i < size; ++i) {
	    if (cache->info[i].type == DRI_STRING)
		free(cache->values[i]._string);
	}
    }
d987 1
a987 1
unsigned char driCheckOption (const driOptionCache *cache, const char *name,
d989 1
a989 1
    uint32_t i = findOption (cache, name);
d993 2
a994 2
unsigned char driQueryOptionb (const driOptionCache *cache, const char *name) {
    uint32_t i = findOption (cache, name);
d1001 2
a1002 2
int driQueryOptioni (const driOptionCache *cache, const char *name) {
    uint32_t i = findOption (cache, name);
d1009 2
a1010 2
float driQueryOptionf (const driOptionCache *cache, const char *name) {
    uint32_t i = findOption (cache, name);
a1014 8
}

char *driQueryOptionstr (const driOptionCache *cache, const char *name) {
    GLuint i = findOption (cache, name);
  /* make sure the option is defined and has the correct type */
    assert (cache->info[i].name != NULL);
    assert (cache->info[i].type == DRI_STRING);
    return cache->values[i]._string;
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a29 2
#include "main/glheader.h"

d48 2
d109 5
a113 5
static GLuint findOption (const driOptionCache *cache, const char *name) {
    GLuint len = strlen (name);
    GLuint size = 1 << cache->tableSize, mask = size - 1;
    GLuint hash = 0;
    GLuint i, shift;
d117 1
a117 1
	hash += (GLuint)name[i] << shift;
d137 1
a137 1
    GLuint len = strlen (source); \
d149 2
a150 2
static GLuint bsearchStr (const XML_Char *name,
			  const XML_Char *elems[], GLuint count) {
d168 5
a172 5
static GLint strToI (const XML_Char *string, const XML_Char **tail, int base) {
    GLint radix = base == 0 ? 10 : base;
    GLint result = 0;
    GLint sign = 1;
    GLboolean numberFound = GL_FALSE;
d183 1
a183 1
	numberFound = GL_TRUE; 
d193 1
a193 1
	GLint digit = -1;
d206 1
a206 1
	    numberFound = GL_TRUE;
d211 1
a211 1
    } while (GL_TRUE);
d228 3
a230 3
static GLfloat strToF (const XML_Char *string, const XML_Char **tail) {
    GLint nDigits = 0, pointPos, exponent;
    GLfloat sign = 1.0f, result = 0.0f, scale;
d273 1
a273 1
    scale = sign * (GLfloat)pow (10.0, (GLdouble)(pointPos-1 + exponent));
d279 1
a279 1
	    result += scale * (GLfloat)(*string - '0');
d290 1
a290 1
static GLboolean parseValue (driOptionValue *v, driOptionType type,
d298 1
a298 1
	    v->_bool = GL_FALSE;
d301 1
a301 1
	    v->_bool = GL_TRUE;
d305 1
a305 1
	    return GL_FALSE;
d314 5
d322 1
a322 1
	return GL_FALSE; /* empty string (or containing only white-space) */
d327 1
a327 1
	return GL_FALSE; /* something left over that is not part of value */
d329 1
a329 1
    return GL_TRUE;
d333 1
a333 1
static GLboolean parseRanges (driOptionInfo *info, const XML_Char *string) {
d335 1
a335 1
    GLuint nRanges, i;
d383 1
a383 1
	return GL_FALSE;
d389 1
a389 1
    return GL_TRUE;
d393 2
a394 2
static GLboolean checkValue (const driOptionValue *v, const driOptionInfo *info) {
    GLuint i;
d397 1
a397 1
	return GL_TRUE;
d404 1
a404 1
		return GL_TRUE;
d410 3
a412 1
		return GL_TRUE;
d417 1
a417 1
    return GL_FALSE;
d432 1
d434 2
a435 1
    if (getenv("LIBGL_DEBUG")) {
d490 5
a494 5
    GLboolean inDriInfo;
    GLboolean inSection;
    GLboolean inDesc;
    GLboolean inOption;
    GLboolean inEnum;
d512 1
a512 1
    GLuint i;
d515 1
a515 1
    GLuint opt = data->curOption;
d535 1
a535 1
    GLuint i;
d553 1
a553 1
    GLuint opt, i;
d555 1
a555 1
	GLuint attrName = bsearchStr (attr[i], optAttr, OA_COUNT);
d579 2
d622 1
a622 1
	data->inDriInfo = GL_TRUE;
d631 1
a631 1
	data->inSection = GL_TRUE;
d638 1
a638 1
	data->inDesc = GL_TRUE;
d648 1
a648 1
	data->inOption = GL_TRUE;
d656 1
a656 1
	data->inEnum = GL_TRUE;
d670 1
a670 1
	data->inDriInfo = GL_FALSE;
d673 1
a673 1
	data->inSection = GL_FALSE;
d676 1
a676 1
	data->inDesc = GL_FALSE;
d679 1
a679 1
	data->inOption = GL_FALSE;
d682 1
a682 1
	data->inEnum = GL_FALSE;
d713 5
a717 5
    userData.inDriInfo = GL_FALSE;
    userData.inSection = GL_FALSE;
    userData.inDesc = GL_FALSE;
    userData.inOption = GL_FALSE;
    userData.inEnum = GL_FALSE;
d732 1
a732 1
    GLint screenNum;
d734 6
a739 6
    GLuint ignoringDevice;
    GLuint ignoringApp;
    GLuint inDriConf;
    GLuint inDevice;
    GLuint inApp;
    GLuint inOption;
d752 1
a752 1
    GLuint i;
d772 1
a772 1
    GLuint i;
d785 1
a785 1
    GLuint i;
d796 1
a796 1
	GLuint opt = findOption (cache, name);
d881 1
d891 4
d937 1
a937 1
			  GLint screenNum, const char *driverName) {
d940 1
a940 1
    GLuint i;
d951 1
a951 1
	GLuint len = strlen (home);
d988 1
a988 1
	GLuint i, size = 1 << info->tableSize;
d1000 7
d1010 1
a1010 1
GLboolean driCheckOption (const driOptionCache *cache, const char *name,
d1012 1
a1012 1
    GLuint i = findOption (cache, name);
d1016 2
a1017 2
GLboolean driQueryOptionb (const driOptionCache *cache, const char *name) {
    GLuint i = findOption (cache, name);
d1024 2
a1025 2
GLint driQueryOptioni (const driOptionCache *cache, const char *name) {
    GLuint i = findOption (cache, name);
d1032 2
a1033 2
GLfloat driQueryOptionf (const driOptionCache *cache, const char *name) {
    GLuint i = findOption (cache, name);
d1038 8
@


1.7
log
@Merge Mesa 9.2.0
@
text
@a134 10
/** \brief Count the real number of options in an option cache */
static GLuint countOptions (const driOptionCache *cache) {
    GLuint size = 1 << cache->tableSize;
    GLuint i, count = 0;
    for (i = 0; i < size; ++i)
	if (cache->info[i].name)
	    count++;
    return count;
}

d678 1
a678 2
void driParseOptionInfo (driOptionCache *info,
			 const char *configOptions, GLuint nConfigOptions) {
a682 1
    GLuint realNoptions;
d684 6
a689 11
  /* determine hash table size and allocate memory:
   * 3/2 of the number of options, rounded up, so there remains always
   * at least one free entry. This is needed for detecting undefined
   * options in configuration files without getting a hash table overflow.
   * Round this up to a power of two. */
    GLuint minSize = (nConfigOptions*3 + 1) / 2;
    GLuint size, log2size;
    for (size = 1, log2size = 0; size < minSize; size <<= 1, ++log2size);
    info->tableSize = log2size;
    info->info = calloc(size, sizeof (driOptionInfo));
    info->values = calloc(size, sizeof (driOptionValue));
a713 11

  /* Check if the actual number of options matches nConfigOptions.
   * A mismatch is not fatal (a hash table overflow would be) but we
   * want the driver developer's attention anyway. */
    realNoptions = countOptions (info);
    if (realNoptions != nConfigOptions) {
	fprintf (stderr,
		 "Error: nConfigOptions (%u) does not match the actual number of options in\n"
		 "       __driConfigOptions (%u).\n",
		 nConfigOptions, realNoptions);
    }
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d89 1
a89 1
#    if defined(__OpenBSD__) || defined(NetBSD) || defined(__UCLIBC__)
d145 1
a145 1
/** \brief Like strdup but using MALLOC and with error checking. */
d148 1
a148 1
    if (!(dest = MALLOC (len+1))) { \
d350 1
a350 1
    if ((ranges = MALLOC (nRanges*sizeof(driOptionRange))) == NULL) {
d385 1
a385 1
    FREE (cp);
d387 1
a387 1
	FREE (ranges);
d423 22
d592 1
a592 1
	XML_FATAL ("illegal default value: %s.", defaultVal);
d705 2
a706 2
    info->info = CALLOC (size * sizeof (driOptionInfo));
    info->values = CALLOC (size * sizeof (driOptionValue));
d790 1
a790 1
    const XML_Char *name = NULL, *exec = NULL;
d792 1
a792 1
	if (!strcmp (attr[i], "name")) name = attr[i+1];
d815 3
a817 1
	    XML_WARNING ("undefined option: %s.", name);
d900 1
a900 1
    cache->values = MALLOC ((1<<info->tableSize) * sizeof (driOptionValue));
d964 1
a964 1
	filenames[1] = MALLOC (len + 7+1);
d994 1
a994 2
    if (filenames[1])
	FREE (filenames[1]);
d1003 2
a1004 3
		FREE (info->info[i].name);
		if (info->info[i].ranges)
		    FREE (info->info[i].ranges);
d1007 1
a1007 1
	FREE (info->info);
d1012 1
a1012 2
    if (cache->values)
	FREE (cache->values);
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d67 19
a85 1
#    define GET_PROGRAM_NAME() basename(getexecname())
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d39 1
a39 1
#include "dri_util.h"
d59 3
d212 1
a212 1
 * point and may occor at most once. Optionally the number may end in
d734 1
a734 1
	else XML_WARNING("unkown device attribute: %s.", attr[i]);
d754 1
a754 1
	else XML_WARNING("unkown application attribute: %s.", attr[i]);
d767 1
a767 1
	else XML_WARNING("unkown option attribute: %s.", attr[i]);
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a41 7
/*
 * OS dependent ways of getting the name of the running program
 */
#if (defined(__unix__) || defined(unix)) && !defined(USG)
#include <sys/param.h>
#endif

d68 1
a68 1
#    if defined(OpenBSD) || defined(NetBSD) || defined(__UCLIBC__)
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d30 1
a30 1
#include "glheader.h"
d38 1
a38 1
#include "imports.h"
@


1.1
log
@Initial revision
@
text
@d66 6
d288 1
a288 1
    const XML_Char *tail;
d412 2
a413 2
                      XML_GetCurrentLineNumber(data->parser), \
                      XML_GetCurrentColumnNumber(data->parser)); \
d417 2
a418 2
                      XML_GetCurrentLineNumber(data->parser), \
                      XML_GetCurrentColumnNumber(data->parser), \
d424 2
a425 2
                      XML_GetCurrentLineNumber(data->parser), \
                      XML_GetCurrentColumnNumber(data->parser)); \
d429 2
a430 2
                      XML_GetCurrentLineNumber(data->parser), \
                      XML_GetCurrentColumnNumber(data->parser), \
d437 2
a438 2
             XML_GetCurrentLineNumber(data->parser), \
             XML_GetCurrentColumnNumber(data->parser)); \
d444 2
a445 2
             XML_GetCurrentLineNumber(data->parser), \
             XML_GetCurrentColumnNumber(data->parser), \
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d30 1
a30 1
#include "main/glheader.h"
d38 2
a39 2
#include "main/imports.h"
#include "utils.h"
d42 7
a65 9
#elif defined(__APPLE__)
#    include <stdlib.h>
#    define GET_PROGRAM_NAME() getprogname()
#elif defined(__sun)
/* Solaris has getexecname() which returns the full path - return just
   the basename to match BSD getprogname() */
#    include <stdlib.h>
#    include <libgen.h>
#    define GET_PROGRAM_NAME() basename(getexecname())
d69 1
a69 1
#    if defined(__OpenBSD__) || defined(NetBSD) || defined(__UCLIBC__)
d210 1
a210 1
 * point and may occur at most once. Optionally the number may end in
d282 1
a282 1
    const XML_Char *tail = NULL;
d406 2
a407 2
                      (int) XML_GetCurrentLineNumber(data->parser), \
                      (int) XML_GetCurrentColumnNumber(data->parser)); \
d411 2
a412 2
                      (int) XML_GetCurrentLineNumber(data->parser), \
                      (int) XML_GetCurrentColumnNumber(data->parser), \
d418 2
a419 2
                      (int) XML_GetCurrentLineNumber(data->parser), \
                      (int) XML_GetCurrentColumnNumber(data->parser)); \
d423 2
a424 2
                      (int) XML_GetCurrentLineNumber(data->parser), \
                      (int) XML_GetCurrentColumnNumber(data->parser), \
d431 2
a432 2
             (int) XML_GetCurrentLineNumber(data->parser),	\
             (int) XML_GetCurrentColumnNumber(data->parser)); \
d438 2
a439 2
             (int) XML_GetCurrentLineNumber(data->parser),	\
             (int) XML_GetCurrentColumnNumber(data->parser),		\
d732 1
a732 1
	else XML_WARNING("unknown device attribute: %s.", attr[i]);
d752 1
a752 1
	else XML_WARNING("unknown application attribute: %s.", attr[i]);
d765 1
a765 1
	else XML_WARNING("unknown option attribute: %s.", attr[i]);
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d67 1
a67 19

static const char *__getProgramName () {
    static const char *progname;

    if (progname == NULL) {
	const char *e = getexecname();
	if (e != NULL) {
	    /* Have to make a copy since getexecname can return a readonly
	       string, but basename expects to be able to modify its arg. */
	    char *n = strdup(e);
	    if (n != NULL) {
		progname = basename(n);
	    }
	}
    }
    return progname;
}

#    define GET_PROGRAM_NAME() __getProgramName()
d71 1
a71 1
#    if defined(__OpenBSD__) || defined(NetBSD) || defined(__UCLIBC__) || defined(ANDROID)
d127 1
a127 1
/** \brief Like strdup but using malloc and with error checking. */
d130 1
a130 1
    if (!(dest = malloc(len+1))) { \
d332 1
a332 1
    if ((ranges = malloc(nRanges*sizeof(driOptionRange))) == NULL) {
d367 1
a367 1
    free(cp);
d369 1
a369 1
	free(ranges);
a404 22
/**
 * Print message to \c stderr if the \c LIBGL_DEBUG environment variable
 * is set. 
 * 
 * Is called from the drivers.
 * 
 * \param f \c printf like format string.
 */
static void
__driUtilMessage(const char *f, ...)
{
    va_list args;

    if (getenv("LIBGL_DEBUG")) {
        fprintf(stderr, "libGL: ");
        va_start(args, f);
        vfprintf(stderr, f, args);
        va_end(args);
        fprintf(stderr, "\n");
    }
}

d552 1
a552 1
	XML_FATAL ("illegal default value for %s: %s.", cache->info[opt].name, defaultVal);
d665 2
a666 2
    info->info = calloc(size, sizeof (driOptionInfo));
    info->values = calloc(size, sizeof (driOptionValue));
d750 1
a750 1
    const XML_Char *exec = NULL;
d752 1
a752 1
	if (!strcmp (attr[i], "name")) /* not needed here */;
d775 1
a775 3
            /* don't use XML_WARNING, drirc defines options for all drivers,
             * but not all drivers support them */
            return;
d858 1
a858 1
    cache->values = malloc((1<<info->tableSize) * sizeof (driOptionValue));
d922 1
a922 1
	filenames[1] = malloc(len + 7+1);
d952 2
a953 1
    free(filenames[1]);
d962 3
a964 2
		free(info->info[i].name);
		free(info->info[i].ranges);
d967 1
a967 1
	free(info->info);
d972 2
a973 1
    free(cache->values);
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d135 10
d688 2
a689 1
void driParseOptionInfo (driOptionCache *info, const char *configOptions) {
d694 1
d696 11
a706 6
    /* Make the hash table big enough to fit more than the maximum number of
     * config options we've ever seen in a driver.
     */
    info->tableSize = 6;
    info->info = calloc(1 << info->tableSize, sizeof (driOptionInfo));
    info->values = calloc(1 << info->tableSize, sizeof (driOptionValue));
d731 11
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d30 2
a49 2
#elif defined(__CYGWIN__)
#    define GET_PROGRAM_NAME() program_invocation_short_name
d109 5
a113 5
static uint32_t findOption (const driOptionCache *cache, const char *name) {
    uint32_t len = strlen (name);
    uint32_t size = 1 << cache->tableSize, mask = size - 1;
    uint32_t hash = 0;
    uint32_t i, shift;
d117 1
a117 1
	hash += (uint32_t)name[i] << shift;
d137 1
a137 1
    uint32_t len = strlen (source); \
d149 2
a150 2
static uint32_t bsearchStr (const XML_Char *name,
			  const XML_Char *elems[], uint32_t count) {
d168 5
a172 5
static int strToI (const XML_Char *string, const XML_Char **tail, int base) {
    int radix = base == 0 ? 10 : base;
    int result = 0;
    int sign = 1;
    bool numberFound = false;
d183 1
a183 1
	numberFound = true;
d193 1
a193 1
	int digit = -1;
d206 1
a206 1
	    numberFound = true;
d211 1
a211 1
    } while (true);
d228 3
a230 3
static float strToF (const XML_Char *string, const XML_Char **tail) {
    int nDigits = 0, pointPos, exponent;
    float sign = 1.0f, result = 0.0f, scale;
d273 1
a273 1
    scale = sign * (float)pow (10.0, (double)(pointPos-1 + exponent));
d279 1
a279 1
	    result += scale * (float)(*string - '0');
d290 1
a290 1
static unsigned char parseValue (driOptionValue *v, driOptionType type,
d298 1
a298 1
	    v->_bool = false;
d301 1
a301 1
	    v->_bool = true;
d305 1
a305 1
	    return false;
a313 5
      case DRI_STRING:
	if (v->_string)
	    free (v->_string);
	v->_string = strndup(string, STRING_CONF_MAXLEN);
	return GL_TRUE;
d317 1
a317 1
	return false; /* empty string (or containing only white-space) */
d322 1
a322 1
	return false; /* something left over that is not part of value */
d324 1
a324 1
    return true;
d328 1
a328 1
static unsigned char parseRanges (driOptionInfo *info, const XML_Char *string) {
d330 1
a330 1
    uint32_t nRanges, i;
d378 1
a378 1
	return false;
d384 1
a384 1
    return true;
d388 2
a389 2
static bool checkValue (const driOptionValue *v, const driOptionInfo *info) {
    uint32_t i;
d392 1
a392 1
	return true;
d399 1
a399 1
		return true;
d405 1
a405 3
		return true;
	break;
      case DRI_STRING:
d410 1
a410 1
    return false;
a424 1
    const char *libgl_debug;
d426 1
a426 2
    libgl_debug=getenv("LIBGL_DEBUG");
    if (libgl_debug && !strstr(libgl_debug, "quiet")) {
d481 5
a485 5
    bool inDriInfo;
    bool inSection;
    bool inDesc;
    bool inOption;
    bool inEnum;
d503 1
a503 1
    uint32_t i;
d506 1
a506 1
    uint32_t opt = data->curOption;
d526 1
a526 1
    uint32_t i;
d544 1
a544 1
    uint32_t opt, i;
d546 1
a546 1
	uint32_t attrName = bsearchStr (attr[i], optAttr, OA_COUNT);
a569 2
    else if (!strcmp (attrVal[OA_TYPE], "string"))
	cache->info[opt].type = DRI_STRING;
d611 1
a611 1
	data->inDriInfo = true;
d620 1
a620 1
	data->inSection = true;
d627 1
a627 1
	data->inDesc = true;
d637 1
a637 1
	data->inOption = true;
d645 1
a645 1
	data->inEnum = true;
d659 1
a659 1
	data->inDriInfo = false;
d662 1
a662 1
	data->inSection = false;
d665 1
a665 1
	data->inDesc = false;
d668 1
a668 1
	data->inOption = false;
d671 1
a671 1
	data->inEnum = false;
d702 5
a706 5
    userData.inDriInfo = false;
    userData.inSection = false;
    userData.inDesc = false;
    userData.inOption = false;
    userData.inEnum = false;
d721 1
a721 1
    int screenNum;
d723 6
a728 6
    uint32_t ignoringDevice;
    uint32_t ignoringApp;
    uint32_t inDriConf;
    uint32_t inDevice;
    uint32_t inApp;
    uint32_t inOption;
d741 1
a741 1
    uint32_t i;
d761 1
a761 1
    uint32_t i;
d774 1
a774 1
    uint32_t i;
d785 1
a785 1
	uint32_t opt = findOption (cache, name);
a869 1
    GLuint i, size = 1 << info->tableSize;
a878 4
    for (i = 0; i < size; ++i) {
	if (cache->info[i].type == DRI_STRING)
	    XSTRDUP(cache->values[i]._string, info->values[i]._string);
    }
d921 1
a921 1
			  int screenNum, const char *driverName) {
d924 1
a924 1
    uint32_t i;
d935 1
a935 1
	uint32_t len = strlen (home);
d972 1
a972 1
	uint32_t i, size = 1 << info->tableSize;
a983 7
    if (cache->info) {
	GLuint i, size = 1 << cache->tableSize;
	for (i = 0; i < size; ++i) {
	    if (cache->info[i].type == DRI_STRING)
		free(cache->values[i]._string);
	}
    }
d987 1
a987 1
unsigned char driCheckOption (const driOptionCache *cache, const char *name,
d989 1
a989 1
    uint32_t i = findOption (cache, name);
d993 2
a994 2
unsigned char driQueryOptionb (const driOptionCache *cache, const char *name) {
    uint32_t i = findOption (cache, name);
d1001 2
a1002 2
int driQueryOptioni (const driOptionCache *cache, const char *name) {
    uint32_t i = findOption (cache, name);
d1009 2
a1010 2
float driQueryOptionf (const driOptionCache *cache, const char *name) {
    uint32_t i = findOption (cache, name);
a1014 8
}

char *driQueryOptionstr (const driOptionCache *cache, const char *name) {
    GLuint i = findOption (cache, name);
  /* make sure the option is defined and has the correct type */
    assert (cache->info[i].name != NULL);
    assert (cache->info[i].type == DRI_STRING);
    return cache->values[i]._string;
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@a29 2
#include "main/glheader.h"

d48 2
d109 5
a113 5
static GLuint findOption (const driOptionCache *cache, const char *name) {
    GLuint len = strlen (name);
    GLuint size = 1 << cache->tableSize, mask = size - 1;
    GLuint hash = 0;
    GLuint i, shift;
d117 1
a117 1
	hash += (GLuint)name[i] << shift;
d137 1
a137 1
    GLuint len = strlen (source); \
d149 2
a150 2
static GLuint bsearchStr (const XML_Char *name,
			  const XML_Char *elems[], GLuint count) {
d168 5
a172 5
static GLint strToI (const XML_Char *string, const XML_Char **tail, int base) {
    GLint radix = base == 0 ? 10 : base;
    GLint result = 0;
    GLint sign = 1;
    GLboolean numberFound = GL_FALSE;
d183 1
a183 1
	numberFound = GL_TRUE; 
d193 1
a193 1
	GLint digit = -1;
d206 1
a206 1
	    numberFound = GL_TRUE;
d211 1
a211 1
    } while (GL_TRUE);
d228 3
a230 3
static GLfloat strToF (const XML_Char *string, const XML_Char **tail) {
    GLint nDigits = 0, pointPos, exponent;
    GLfloat sign = 1.0f, result = 0.0f, scale;
d273 1
a273 1
    scale = sign * (GLfloat)pow (10.0, (GLdouble)(pointPos-1 + exponent));
d279 1
a279 1
	    result += scale * (GLfloat)(*string - '0');
d290 1
a290 1
static GLboolean parseValue (driOptionValue *v, driOptionType type,
d298 1
a298 1
	    v->_bool = GL_FALSE;
d301 1
a301 1
	    v->_bool = GL_TRUE;
d305 1
a305 1
	    return GL_FALSE;
d314 5
d322 1
a322 1
	return GL_FALSE; /* empty string (or containing only white-space) */
d327 1
a327 1
	return GL_FALSE; /* something left over that is not part of value */
d329 1
a329 1
    return GL_TRUE;
d333 1
a333 1
static GLboolean parseRanges (driOptionInfo *info, const XML_Char *string) {
d335 1
a335 1
    GLuint nRanges, i;
d383 1
a383 1
	return GL_FALSE;
d389 1
a389 1
    return GL_TRUE;
d393 2
a394 2
static GLboolean checkValue (const driOptionValue *v, const driOptionInfo *info) {
    GLuint i;
d397 1
a397 1
	return GL_TRUE;
d404 1
a404 1
		return GL_TRUE;
d410 3
a412 1
		return GL_TRUE;
d417 1
a417 1
    return GL_FALSE;
d432 1
d434 2
a435 1
    if (getenv("LIBGL_DEBUG")) {
d490 5
a494 5
    GLboolean inDriInfo;
    GLboolean inSection;
    GLboolean inDesc;
    GLboolean inOption;
    GLboolean inEnum;
d512 1
a512 1
    GLuint i;
d515 1
a515 1
    GLuint opt = data->curOption;
d535 1
a535 1
    GLuint i;
d553 1
a553 1
    GLuint opt, i;
d555 1
a555 1
	GLuint attrName = bsearchStr (attr[i], optAttr, OA_COUNT);
d579 2
d622 1
a622 1
	data->inDriInfo = GL_TRUE;
d631 1
a631 1
	data->inSection = GL_TRUE;
d638 1
a638 1
	data->inDesc = GL_TRUE;
d648 1
a648 1
	data->inOption = GL_TRUE;
d656 1
a656 1
	data->inEnum = GL_TRUE;
d670 1
a670 1
	data->inDriInfo = GL_FALSE;
d673 1
a673 1
	data->inSection = GL_FALSE;
d676 1
a676 1
	data->inDesc = GL_FALSE;
d679 1
a679 1
	data->inOption = GL_FALSE;
d682 1
a682 1
	data->inEnum = GL_FALSE;
d713 5
a717 5
    userData.inDriInfo = GL_FALSE;
    userData.inSection = GL_FALSE;
    userData.inDesc = GL_FALSE;
    userData.inOption = GL_FALSE;
    userData.inEnum = GL_FALSE;
d732 1
a732 1
    GLint screenNum;
d734 6
a739 6
    GLuint ignoringDevice;
    GLuint ignoringApp;
    GLuint inDriConf;
    GLuint inDevice;
    GLuint inApp;
    GLuint inOption;
d752 1
a752 1
    GLuint i;
d772 1
a772 1
    GLuint i;
d785 1
a785 1
    GLuint i;
d796 1
a796 1
	GLuint opt = findOption (cache, name);
d881 1
d891 4
d937 1
a937 1
			  GLint screenNum, const char *driverName) {
d940 1
a940 1
    GLuint i;
d951 1
a951 1
	GLuint len = strlen (home);
d988 1
a988 1
	GLuint i, size = 1 << info->tableSize;
d1000 7
d1010 1
a1010 1
GLboolean driCheckOption (const driOptionCache *cache, const char *name,
d1012 1
a1012 1
    GLuint i = findOption (cache, name);
d1016 2
a1017 2
GLboolean driQueryOptionb (const driOptionCache *cache, const char *name) {
    GLuint i = findOption (cache, name);
d1024 2
a1025 2
GLint driQueryOptioni (const driOptionCache *cache, const char *name) {
    GLuint i = findOption (cache, name);
d1032 2
a1033 2
GLfloat driQueryOptionf (const driOptionCache *cache, const char *name) {
    GLuint i = findOption (cache, name);
d1038 8
@


