head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.04.49;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.39;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.52;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.54;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.12.00;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.49.07;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright (C) 2009 Francisco Jerez.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "nouveau_driver.h"
#include "nouveau_context.h"
#include "nouveau_texture.h"
#include "nouveau_fbo.h"
#include "nouveau_util.h"

#include "main/pbo.h"
#include "main/texobj.h"
#include "main/texstore.h"
#include "main/texformat.h"
#include "main/texcompress.h"
#include "main/texgetimage.h"
#include "main/mipmap.h"
#include "main/teximage.h"
#include "drivers/common/meta.h"
#include "swrast/s_texfetch.h"

static struct gl_texture_object *
nouveau_texture_new(struct gl_context *ctx, GLuint name, GLenum target)
{
	struct nouveau_texture *nt = CALLOC_STRUCT(nouveau_texture);

	_mesa_initialize_texture_object(ctx, &nt->base, name, target);

	return &nt->base;
}

static void
nouveau_texture_free(struct gl_context *ctx, struct gl_texture_object *t)
{
	struct nouveau_texture *nt = to_nouveau_texture(t);
	int i;

	for (i = 0; i < MAX_TEXTURE_LEVELS; i++)
		nouveau_surface_ref(NULL, &nt->surfaces[i]);

	_mesa_delete_texture_object(ctx, t);
}

static struct gl_texture_image *
nouveau_teximage_new(struct gl_context *ctx)
{
	struct nouveau_teximage *nti = CALLOC_STRUCT(nouveau_teximage);

	return &nti->base.Base;
}

static void
nouveau_teximage_free(struct gl_context *ctx, struct gl_texture_image *ti)
{
	struct nouveau_teximage *nti = to_nouveau_teximage(ti);

	nouveau_surface_ref(NULL, &nti->surface);
}

static void
nouveau_map_texture_image(struct gl_context *ctx,
			  struct gl_texture_image *ti,
			  GLuint slice,
			  GLuint x, GLuint y, GLuint w, GLuint h,
			  GLbitfield mode,
			  GLubyte **map,
			  GLint *stride)
{
	struct nouveau_teximage *nti = to_nouveau_teximage(ti);
	struct nouveau_surface *s = &nti->surface;
	struct nouveau_surface *st = &nti->transfer.surface;
	struct nouveau_client *client = context_client(ctx);

	/* Nouveau has no support for 3D or cubemap textures. */
	assert(slice == 0);

	if (s->bo) {
		if (!(mode & GL_MAP_READ_BIT) &&
		    nouveau_pushbuf_refd(context_push(ctx), s->bo)) {
			unsigned size;
			/*
			 * Heuristic: use a bounce buffer to pipeline
			 * teximage transfers.
			 */
			st->layout = LINEAR;
			st->format = s->format;
			st->cpp = s->cpp;
			st->width = w;
			st->height = h;
			st->pitch = s->pitch;
			nti->transfer.x = x;
			nti->transfer.y = y;

			size = get_format_blocksy(st->format, h) * st->pitch;
			*map = nouveau_get_scratch(ctx, size,
					  &st->bo, &st->offset);
			*stride = st->pitch;
		} else {
			int ret, flags = 0;

			if (mode & GL_MAP_READ_BIT)
				flags |= NOUVEAU_BO_RD;
			if (mode & GL_MAP_WRITE_BIT)
				flags |= NOUVEAU_BO_WR;

			if (!s->bo->map) {
				ret = nouveau_bo_map(s->bo, flags, client);
				assert(!ret);
			}

			*map = s->bo->map +
				get_format_blocksy(s->format, y) * s->pitch +
				get_format_blocksx(s->format, x) * s->cpp;
			*stride = s->pitch;
		}
	} else {
		*map = nti->base.Buffer +
			get_format_blocksy(s->format, y) * s->pitch +
			get_format_blocksx(s->format, x) * s->cpp;
		*stride = s->pitch;
	}
}

static void
nouveau_unmap_texture_image(struct gl_context *ctx, struct gl_texture_image *ti,
			    GLuint slice)
{
	struct nouveau_teximage *nti = to_nouveau_teximage(ti);
	struct nouveau_surface *s = &nti->surface;
	struct nouveau_surface *st = &nti->transfer.surface;

	if (st->bo) {
		context_drv(ctx)->surface_copy(ctx, s, st, nti->transfer.x,
					       nti->transfer.y, 0, 0,
					       st->width, st->height);
		nouveau_surface_ref(NULL, st);

	}
}

static mesa_format
nouveau_choose_tex_format(struct gl_context *ctx, GLenum target,
                          GLint internalFormat,
			  GLenum srcFormat, GLenum srcType)
{
	switch (internalFormat) {
	case 4:
	case GL_RGBA:
	case GL_RGBA2:
	case GL_RGBA4:
	case GL_RGBA8:
	case GL_RGBA12:
	case GL_RGBA16:
	case GL_RGB10_A2:
	case GL_COMPRESSED_RGBA:
		return MESA_FORMAT_B8G8R8A8_UNORM;
	case GL_RGB5_A1:
		return MESA_FORMAT_B5G5R5A1_UNORM;

	case GL_RGB:
	case GL_RGB8:
	case GL_RGB10:
	case GL_RGB12:
	case GL_RGB16:
	case GL_COMPRESSED_RGB:
		return MESA_FORMAT_B8G8R8X8_UNORM;
	case 3:
	case GL_R3_G3_B2:
	case GL_RGB4:
	case GL_RGB5:
		return MESA_FORMAT_B5G6R5_UNORM;

	case 2:
	case GL_LUMINANCE_ALPHA:
	case GL_LUMINANCE4_ALPHA4:
	case GL_LUMINANCE6_ALPHA2:
	case GL_LUMINANCE12_ALPHA4:
	case GL_LUMINANCE12_ALPHA12:
	case GL_LUMINANCE16_ALPHA16:
	case GL_LUMINANCE8_ALPHA8:
	case GL_COMPRESSED_LUMINANCE_ALPHA:
		return MESA_FORMAT_B8G8R8A8_UNORM;

	case 1:
	case GL_LUMINANCE:
	case GL_LUMINANCE4:
	case GL_LUMINANCE12:
	case GL_LUMINANCE16:
	case GL_LUMINANCE8:
	case GL_COMPRESSED_LUMINANCE:
		return MESA_FORMAT_L_UNORM8;

	case GL_ALPHA:
	case GL_ALPHA4:
	case GL_ALPHA12:
	case GL_ALPHA16:
	case GL_ALPHA8:
	case GL_COMPRESSED_ALPHA:
		return MESA_FORMAT_A_UNORM8;

	case GL_INTENSITY:
	case GL_INTENSITY4:
	case GL_INTENSITY12:
	case GL_INTENSITY16:
	case GL_INTENSITY8:
	case GL_COMPRESSED_INTENSITY:
		return MESA_FORMAT_I_UNORM8;

	case GL_RGB_S3TC:
	case GL_RGB4_S3TC:
	case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
		return MESA_FORMAT_RGB_DXT1;

	case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
		return MESA_FORMAT_RGBA_DXT1;

	case GL_RGBA_S3TC:
	case GL_RGBA4_S3TC:
	case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
		return MESA_FORMAT_RGBA_DXT3;

	case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
		return MESA_FORMAT_RGBA_DXT5;

	default:
		assert(0);
	}
}

static GLboolean
teximage_fits(struct gl_texture_object *t, int level)
{
	struct nouveau_surface *s = &to_nouveau_texture(t)->surfaces[level];
	struct gl_texture_image *ti = t->Image[0][level];

	if (!ti || !to_nouveau_teximage(ti)->surface.bo)
		return GL_FALSE;

	if (level == t->BaseLevel && (s->offset & 0x7f))
		return GL_FALSE;

	return t->Target == GL_TEXTURE_RECTANGLE ||
		(s->bo && s->format == ti->TexFormat &&
		 s->width == ti->Width && s->height == ti->Height);
}

static GLboolean
validate_teximage(struct gl_context *ctx, struct gl_texture_object *t,
		  int level, int x, int y, int z,
		  int width, int height, int depth)
{
	struct gl_texture_image *ti = t->Image[0][level];

	if (teximage_fits(t, level)) {
		struct nouveau_surface *ss = to_nouveau_texture(t)->surfaces;
		struct nouveau_surface *s = &to_nouveau_teximage(ti)->surface;

		if (t->Target == GL_TEXTURE_RECTANGLE)
			nouveau_surface_ref(s, &ss[level]);
		else
			context_drv(ctx)->surface_copy(ctx, &ss[level], s,
						       x, y, x, y,
						       width, height);

		return GL_TRUE;
	}

	return GL_FALSE;
}

static int
get_last_level(struct gl_texture_object *t)
{
	struct gl_texture_image *base = t->Image[0][t->BaseLevel];

	if (t->Sampler.MinFilter == GL_NEAREST ||
	    t->Sampler.MinFilter == GL_LINEAR || !base)
		return t->BaseLevel;
	else
		return MIN2(t->BaseLevel + base->MaxNumLevels - 1, t->MaxLevel);
}

static void
relayout_texture(struct gl_context *ctx, struct gl_texture_object *t)
{
	struct gl_texture_image *base = t->Image[0][t->BaseLevel];

	if (base && t->Target != GL_TEXTURE_RECTANGLE) {
		struct nouveau_surface *ss = to_nouveau_texture(t)->surfaces;
		struct nouveau_surface *s = &to_nouveau_teximage(base)->surface;
		int i, ret, last = get_last_level(t);
		enum nouveau_surface_layout layout =
			(_mesa_is_format_compressed(s->format) ? LINEAR : SWIZZLED);
		unsigned size, pitch, offset = 0,
			width = s->width,
			height = s->height;

		/* Deallocate the old storage. */
		for (i = 0; i < MAX_TEXTURE_LEVELS; i++)
			nouveau_bo_ref(NULL, &ss[i].bo);

		/* Relayout the mipmap tree. */
		for (i = t->BaseLevel; i <= last; i++) {
			pitch = _mesa_format_row_stride(s->format, width);
			size = get_format_blocksy(s->format, height) * pitch;

			/* Images larger than 16B have to be aligned. */
			if (size > 16)
				offset = align(offset, 64);

			ss[i] = (struct nouveau_surface) {
				.offset = offset,
				.layout = layout,
				.format = s->format,
				.width = width,
				.height = height,
				.cpp = s->cpp,
				.pitch = pitch,
			};

			offset += size;
			width = minify(width, 1);
			height = minify(height, 1);
		}

		/* Get new storage. */
		size = align(offset, 64);

		ret = nouveau_bo_new(context_dev(ctx), NOUVEAU_BO_MAP |
				     NOUVEAU_BO_GART | NOUVEAU_BO_VRAM,
				     0, size, NULL, &ss[last].bo);
		assert(!ret);

		for (i = t->BaseLevel; i < last; i++)
			nouveau_bo_ref(ss[last].bo, &ss[i].bo);
	}
}

GLboolean
nouveau_texture_validate(struct gl_context *ctx, struct gl_texture_object *t)
{
	struct nouveau_texture *nt = to_nouveau_texture(t);
	int i, last = get_last_level(t);

	if (!teximage_fits(t, t->BaseLevel) ||
	    !teximage_fits(t, last))
		return GL_FALSE;

	if (nt->dirty) {
		nt->dirty = GL_FALSE;

		/* Copy the teximages to the actual miptree. */
		for (i = t->BaseLevel; i <= last; i++) {
			struct nouveau_surface *s = &nt->surfaces[i];

			validate_teximage(ctx, t, i, 0, 0, 0,
					  s->width, s->height, 1);
		}

		PUSH_KICK(context_push(ctx));
	}

	return GL_TRUE;
}

void
nouveau_texture_reallocate(struct gl_context *ctx, struct gl_texture_object *t)
{
	if (!teximage_fits(t, t->BaseLevel) ||
	    !teximage_fits(t, get_last_level(t))) {
		texture_dirty(t);
		relayout_texture(ctx, t);
		nouveau_texture_validate(ctx, t);
	}
}

static unsigned
get_teximage_placement(struct gl_texture_image *ti)
{
	if (ti->TexFormat == MESA_FORMAT_A_UNORM8 ||
	    ti->TexFormat == MESA_FORMAT_L_UNORM8 ||
	    ti->TexFormat == MESA_FORMAT_I_UNORM8)
		/* 1 cpp formats will have to be swizzled by the CPU,
		 * so leave them in system RAM for now. */
		return NOUVEAU_BO_MAP;
	else
		return NOUVEAU_BO_GART | NOUVEAU_BO_MAP;
}

static void
nouveau_teximage(struct gl_context *ctx, GLint dims,
		 struct gl_texture_image *ti,
		 GLsizei imageSize,
		 GLenum format, GLenum type, const GLvoid *pixels,
		 const struct gl_pixelstore_attrib *packing,
		 GLboolean compressed)
{
	struct gl_texture_object *t = ti->TexObject;
	const GLuint level = ti->Level;
	struct nouveau_surface *s = &to_nouveau_teximage(ti)->surface;
	struct nouveau_teximage *nti = to_nouveau_teximage(ti);
	int ret;
	GLuint depth = compressed ? 1 : ti->Depth;

	/* Allocate a new bo for the image. */
	nouveau_surface_alloc(ctx, s, LINEAR, get_teximage_placement(ti),
			      ti->TexFormat, ti->Width, ti->Height);
	nti->base.RowStride = s->pitch / s->cpp;

	if (compressed)
		pixels = _mesa_validate_pbo_compressed_teximage(ctx,
			dims, imageSize,
			pixels, packing, "glCompressedTexImage");
	else
		pixels = _mesa_validate_pbo_teximage(ctx,
			dims, ti->Width, ti->Height, depth, format, type,
			pixels, packing, "glTexImage");

	if (pixels) {
		GLubyte *map;
		int row_stride;

		/* Store the pixel data. */
		nouveau_map_texture_image(ctx, ti, 0,
					  0, 0, ti->Width, ti->Height,
					  GL_MAP_WRITE_BIT,
					  &map, &row_stride);

		ret = _mesa_texstore(ctx, dims, ti->_BaseFormat,
				     ti->TexFormat,
				     row_stride,
				     &map,
				     ti->Width, ti->Height, depth,
				     format, type, pixels, packing);
		assert(ret);

		nouveau_unmap_texture_image(ctx, ti, 0);
		_mesa_unmap_teximage_pbo(ctx, packing);

		if (!validate_teximage(ctx, t, level, 0, 0, 0,
				       ti->Width, ti->Height, depth))
			/* It doesn't fit, mark it as dirty. */
			texture_dirty(t);
	}

	if (level == t->BaseLevel) {
		if (!teximage_fits(t, level))
			relayout_texture(ctx, t);
		nouveau_texture_validate(ctx, t);
	}

	context_dirty_i(ctx, TEX_OBJ, ctx->Texture.CurrentUnit);
	context_dirty_i(ctx, TEX_ENV, ctx->Texture.CurrentUnit);
}


static void
nouveau_teximage_123d(struct gl_context *ctx, GLuint dims,
                      struct gl_texture_image *ti,
                      GLenum format, GLenum type, const GLvoid *pixels,
                      const struct gl_pixelstore_attrib *packing)
{
	nouveau_teximage(ctx, dims, ti, 0, format, type, pixels,
			 packing, GL_FALSE);
}

static void
nouveau_compressed_teximage(struct gl_context *ctx, GLuint dims,
		    struct gl_texture_image *ti,
		    GLsizei imageSize, const GLvoid *data)
{
	nouveau_teximage(ctx, 2, ti, imageSize, 0, 0, data,
			 &ctx->Unpack, GL_TRUE);
}

static GLboolean
nouveau_teximage_alloc(struct gl_context *ctx, struct gl_texture_image *ti)
{
	nouveau_teximage(ctx, 3, ti, 0, 0, 0, NULL,
			 &ctx->DefaultPacking, GL_FALSE);
	return GL_TRUE;
}

static void
nouveau_texsubimage(struct gl_context *ctx, GLint dims,
		    struct gl_texture_image *ti,
		    GLint xoffset, GLint yoffset, GLint zoffset,
		    GLint width, GLint height, GLint depth,
		    GLsizei imageSize,
		    GLenum format, GLenum type, const void *pixels,
		    const struct gl_pixelstore_attrib *packing,
		    GLboolean compressed)
{
	int ret;

	if (compressed)
		pixels = _mesa_validate_pbo_compressed_teximage(ctx,
				dims, imageSize,
				pixels, packing, "glCompressedTexSubImage");
	else
		pixels = _mesa_validate_pbo_teximage(ctx,
				dims, width, height, depth, format, type,
				pixels, packing, "glTexSubImage");

	if (pixels) {
		GLubyte *map;
		int row_stride;

		nouveau_map_texture_image(ctx, ti, 0,
					  xoffset, yoffset, width, height,
					  GL_MAP_WRITE_BIT, &map, &row_stride);

		ret = _mesa_texstore(ctx, dims, ti->_BaseFormat, ti->TexFormat,
				     row_stride, &map,
                                     width, height, depth,
				     format, type, pixels, packing);
		assert(ret);

		nouveau_unmap_texture_image(ctx, ti, 0);
		_mesa_unmap_teximage_pbo(ctx, packing);
	}

	if (!to_nouveau_texture(ti->TexObject)->dirty)
		validate_teximage(ctx, ti->TexObject, ti->Level,
				  xoffset, yoffset, zoffset,
				  width, height, depth);
}

static void
nouveau_texsubimage_123d(struct gl_context *ctx, GLuint dims,
                         struct gl_texture_image *ti,
                         GLint xoffset, GLint yoffset, GLint zoffset,
                         GLint width, GLint height, GLint depth,
                         GLenum format, GLenum type, const void *pixels,
                         const struct gl_pixelstore_attrib *packing)
{
	nouveau_texsubimage(ctx, dims, ti, xoffset, yoffset, zoffset,
			    width, height, depth, 0, format, type, pixels,
			    packing, GL_FALSE);
}

static void
nouveau_compressed_texsubimage(struct gl_context *ctx, GLuint dims,
		       struct gl_texture_image *ti,
		       GLint xoffset, GLint yoffset, GLint zoffset,
		       GLsizei width, GLint height, GLint depth,
		       GLenum format,
		       GLint imageSize, const void *data)
{
	nouveau_texsubimage(ctx, dims, ti, xoffset, yoffset, zoffset,
			  width, height, depth, imageSize, format, 0, data,
			  &ctx->Unpack, GL_TRUE);
}

static void
nouveau_bind_texture(struct gl_context *ctx, GLuint texUnit,
                     GLenum target, struct gl_texture_object *t)
{
	context_dirty_i(ctx, TEX_OBJ, texUnit);
	context_dirty_i(ctx, TEX_ENV, texUnit);
}

static mesa_format
get_texbuffer_format(struct gl_renderbuffer *rb, GLint format)
{
	struct nouveau_surface *s = &to_nouveau_renderbuffer(rb)->surface;

	if (s->cpp < 4)
		return s->format;
	else if (format == __DRI_TEXTURE_FORMAT_RGBA)
		return MESA_FORMAT_B8G8R8A8_UNORM;
	else
		return MESA_FORMAT_B8G8R8X8_UNORM;
}

void
nouveau_set_texbuffer(__DRIcontext *dri_ctx,
		      GLint target, GLint format,
		      __DRIdrawable *draw)
{
	struct nouveau_context *nctx = dri_ctx->driverPrivate;
	struct gl_context *ctx = &nctx->base;
	struct gl_framebuffer *fb = draw->driverPrivate;
	struct gl_renderbuffer *rb =
		fb->Attachment[BUFFER_FRONT_LEFT].Renderbuffer;
	struct gl_texture_object *t = _mesa_get_current_tex_object(ctx, target);
	struct gl_texture_image *ti;
	struct nouveau_teximage *nti;
	struct nouveau_surface *s;

	_mesa_lock_texture(ctx, t);
	ti = _mesa_get_tex_image(ctx, t, target, 0);
	nti = to_nouveau_teximage(ti);
	s = &to_nouveau_teximage(ti)->surface;

	/* Update the texture surface with the given drawable. */
	nouveau_update_renderbuffers(dri_ctx, draw);
	nouveau_surface_ref(&to_nouveau_renderbuffer(rb)->surface, s);

        s->format = get_texbuffer_format(rb, format);

	/* Update the image fields. */
	_mesa_init_teximage_fields(ctx, ti, s->width, s->height,
				   1, 0, s->cpp, s->format);
	nti->base.RowStride = s->pitch / s->cpp;

	/* Try to validate it. */
	if (!validate_teximage(ctx, t, 0, 0, 0, 0, s->width, s->height, 1))
		nouveau_texture_reallocate(ctx, t);

	context_dirty_i(ctx, TEX_OBJ, ctx->Texture.CurrentUnit);
	context_dirty_i(ctx, TEX_ENV, ctx->Texture.CurrentUnit);

	_mesa_unlock_texture(ctx, t);
}

void
nouveau_texture_functions_init(struct dd_function_table *functions)
{
	functions->NewTextureObject = nouveau_texture_new;
	functions->DeleteTexture = nouveau_texture_free;
	functions->NewTextureImage = nouveau_teximage_new;
	functions->FreeTextureImageBuffer = nouveau_teximage_free;
	functions->AllocTextureImageBuffer = nouveau_teximage_alloc;
	functions->ChooseTextureFormat = nouveau_choose_tex_format;
	functions->TexImage = nouveau_teximage_123d;
	functions->TexSubImage = nouveau_texsubimage_123d;
	functions->CompressedTexImage = nouveau_compressed_teximage;
	functions->CompressedTexSubImage = nouveau_compressed_texsubimage;
	functions->BindTexture = nouveau_bind_texture;
	functions->MapTextureImage = nouveau_map_texture_image;
	functions->UnmapTextureImage = nouveau_unmap_texture_image;
}
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d348 2
a349 9
		if (t->BaseLevel <= last) {
			/* Get new storage. */
			size = align(offset, 64);
			assert(size);

			ret = nouveau_bo_new(context_dev(ctx), NOUVEAU_BO_MAP |
					     NOUVEAU_BO_GART | NOUVEAU_BO_VRAM,
					     0, size, NULL, &ss[last].bo);
			assert(!ret);
d351 7
a357 3
			for (i = t->BaseLevel; i < last; i++)
				nouveau_bo_ref(ss[last].bo, &ss[i].bo);
		}
a412 25
nouveau_compressed_copy(struct gl_context *ctx, GLint dims,
			struct gl_texture_image *ti,
			GLsizei width, GLsizei height, GLsizei depth,
			const GLvoid *src, GLvoid *dst, int row_stride)
{
	struct compressed_pixelstore store;
	int i;

	_mesa_compute_compressed_pixelstore(dims, ti->TexFormat,
					    width, height, depth,
					    &ctx->Unpack, &store);

	src += store.SkipBytes;

	assert(store.CopySlices == 1);

	/* copy rows of blocks */
	for (i = 0; i < store.CopyRowsPerSlice; i++) {
		memcpy(dst, src, store.CopyBytesPerRow);
		dst += row_stride;
		src += store.TotalBytesPerRow;
	}
}

static void
d451 7
a457 13
		if (compressed) {
			nouveau_compressed_copy(ctx, dims, ti,
						ti->Width, ti->Height, depth,
						pixels, map, row_stride);
		} else {
			ret = _mesa_texstore(ctx, dims, ti->_BaseFormat,
					     ti->TexFormat,
					     row_stride,
					     &map,
					     ti->Width, ti->Height, depth,
					     format, type, pixels, packing);
			assert(ret);
		}
d502 1
a502 2
			 &ctx->DefaultPacking,
			 _mesa_is_format_compressed(ti->TexFormat));
d535 5
a539 12
		if (compressed) {
			nouveau_compressed_copy(ctx, dims, ti,
						width, height, depth,
						pixels, map, row_stride);
		} else {
			ret = _mesa_texstore(ctx, dims, ti->_BaseFormat,
					     ti->TexFormat,
					     row_stride, &map,
					     width, height, depth,
					     format, type, pixels, packing);
			assert(ret);
		}
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d348 9
a356 2
		/* Get new storage. */
		size = align(offset, 64);
d358 3
a360 7
		ret = nouveau_bo_new(context_dev(ctx), NOUVEAU_BO_MAP |
				     NOUVEAU_BO_GART | NOUVEAU_BO_VRAM,
				     0, size, NULL, &ss[last].bo);
		assert(!ret);

		for (i = t->BaseLevel; i < last; i++)
			nouveau_bo_ref(ss[last].bo, &ss[i].bo);
d416 25
d479 13
a491 7
		ret = _mesa_texstore(ctx, dims, ti->_BaseFormat,
				     ti->TexFormat,
				     row_stride,
				     &map,
				     ti->Width, ti->Height, depth,
				     format, type, pixels, packing);
		assert(ret);
d536 2
a537 1
			 &ctx->DefaultPacking, GL_FALSE);
d570 12
a581 5
		ret = _mesa_texstore(ctx, dims, ti->_BaseFormat, ti->TexFormat,
				     row_stride, &map,
                                     width, height, depth,
				     format, type, pixels, packing);
		assert(ret);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d163 1
a163 1
static gl_format
d178 1
a178 1
		return MESA_FORMAT_ARGB8888;
d180 1
a180 1
		return MESA_FORMAT_ARGB1555;
d188 1
a188 1
		return MESA_FORMAT_XRGB8888;
d193 1
a193 1
		return MESA_FORMAT_RGB565;
d204 1
a204 1
		return MESA_FORMAT_ARGB8888;
d213 1
a213 1
		return MESA_FORMAT_L8;
d221 1
a221 1
		return MESA_FORMAT_A8;
d228 2
a229 1
		return MESA_FORMAT_I8;
d402 3
a404 3
	if (ti->TexFormat == MESA_FORMAT_A8 ||
	    ti->TexFormat == MESA_FORMAT_L8 ||
	    ti->TexFormat == MESA_FORMAT_I8)
d498 8
d578 2
a579 2
nouveau_bind_texture(struct gl_context *ctx, GLenum target,
		     struct gl_texture_object *t)
d581 2
a582 2
	context_dirty_i(ctx, TEX_OBJ, ctx->Texture.CurrentUnit);
	context_dirty_i(ctx, TEX_ENV, ctx->Texture.CurrentUnit);
d585 1
a585 1
static gl_format
d593 1
a593 1
		return MESA_FORMAT_ARGB8888;
d595 1
a595 1
		return MESA_FORMAT_XRGB8888;
d646 1
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a39 1
#include "main/texfetch.h"
d42 1
d49 1
a49 1
	_mesa_initialize_texture_object(&nt->base, name, target);
d71 1
a71 1
	return &nti->base;
d83 7
a89 2
nouveau_teximage_map(struct gl_context *ctx, struct gl_texture_image *ti,
		     int access, int x, int y, int w, int h)
d94 4
d100 3
a102 2
		if (!(access & GL_MAP_READ_BIT) &&
		    nouveau_bo_pending(s->bo)) {
d116 4
a119 3
			ti->Data = nouveau_get_scratch(ctx, st->pitch * h,
						       &st->bo, &st->offset);

d123 1
a123 1
			if (access & GL_MAP_READ_BIT)
d125 1
a125 1
			if (access & GL_MAP_WRITE_BIT)
d129 1
a129 1
				ret = nouveau_bo_map(s->bo, flags);
d133 4
a136 1
			ti->Data = s->bo->map + y * s->pitch + x * s->cpp;
d138 5
d147 2
a148 1
nouveau_teximage_unmap(struct gl_context *ctx, struct gl_texture_image *ti)
a159 2
	} else if (s->bo) {
		nouveau_bo_unmap(s->bo);
a160 2

	ti->Data = NULL;
d164 2
a165 1
nouveau_choose_tex_format(struct gl_context *ctx, GLint internalFormat,
d230 15
a244 8
	case GL_COLOR_INDEX:
	case GL_COLOR_INDEX1_EXT:
	case GL_COLOR_INDEX2_EXT:
	case GL_COLOR_INDEX4_EXT:
	case GL_COLOR_INDEX12_EXT:
	case GL_COLOR_INDEX16_EXT:
	case GL_COLOR_INDEX8_EXT:
		return MESA_FORMAT_CI8;
d301 1
a301 1
		return MIN2(t->BaseLevel + base->MaxLog2, t->MaxLevel);
d313 3
a315 1
		unsigned size, offset = 0,
d325 2
a326 1
			size = width * height * s->cpp;
d334 1
a334 1
				.layout = SWIZZLED,
d339 1
a339 1
				.pitch = width * s->cpp,
d343 2
a344 2
			width = MAX2(1, width / 2);
			height = MAX2(1, height / 2);
d352 1
a352 1
				     0, size, &ss[last].bo);
d381 1
a381 1
		FIRE_RING(context_chan(ctx));
d412 3
a414 3
nouveau_teximage(struct gl_context *ctx, GLint dims, GLenum target, GLint level,
		 GLint internalFormat,
		 GLint width, GLint height, GLint depth, GLint border,
d417 1
a417 2
		 struct gl_texture_object *t,
		 struct gl_texture_image *ti)
d419 2
d422 1
d424 1
d428 11
a438 2
			      ti->TexFormat, width, height);
	ti->RowStride = s->pitch / s->cpp;
a439 3
	pixels = _mesa_validate_pbo_teximage(ctx, dims, width, height, depth,
					     format, type, pixels, packing,
					     "glTexImage");
d441 3
d445 4
a448 2
		nouveau_teximage_map(ctx, ti, GL_MAP_WRITE_BIT,
				     0, 0, width, height);
d451 4
a454 4
				     ti->TexFormat, ti->Data,
				     0, 0, 0, s->pitch,
				     ti->ImageOffsets,
				     width, height, depth,
d458 1
a458 1
		nouveau_teximage_unmap(ctx, ti);
d462 1
a462 1
				       width, height, depth))
a476 13
static void
nouveau_teximage_1d(struct gl_context *ctx, GLenum target, GLint level,
		    GLint internalFormat,
		    GLint width, GLint border,
		    GLenum format, GLenum type, const GLvoid *pixels,
		    const struct gl_pixelstore_attrib *packing,
		    struct gl_texture_object *t,
		    struct gl_texture_image *ti)
{
	nouveau_teximage(ctx, 1, target, level, internalFormat,
			 width, 1, 1, border, format, type, pixels,
			 packing, t, ti);
}
d479 4
a482 7
nouveau_teximage_2d(struct gl_context *ctx, GLenum target, GLint level,
		    GLint internalFormat,
		    GLint width, GLint height, GLint border,
		    GLenum format, GLenum type, const GLvoid *pixels,
		    const struct gl_pixelstore_attrib *packing,
		    struct gl_texture_object *t,
		    struct gl_texture_image *ti)
d484 2
a485 3
	nouveau_teximage(ctx, 2, target, level, internalFormat,
			 width, height, 1, border, format, type, pixels,
			 packing, t, ti);
d489 3
a491 7
nouveau_teximage_3d(struct gl_context *ctx, GLenum target, GLint level,
		    GLint internalFormat,
		    GLint width, GLint height, GLint depth, GLint border,
		    GLenum format, GLenum type, const GLvoid *pixels,
		    const struct gl_pixelstore_attrib *packing,
		    struct gl_texture_object *t,
		    struct gl_texture_image *ti)
d493 2
a494 3
	nouveau_teximage(ctx, 3, target, level, internalFormat,
			 width, height, depth, border, format, type, pixels,
			 packing, t, ti);
d498 2
a499 1
nouveau_texsubimage(struct gl_context *ctx, GLint dims, GLenum target, GLint level,
d502 1
d505 1
a505 2
		    struct gl_texture_object *t,
		    struct gl_texture_image *ti)
a506 1
	struct nouveau_surface *s = &to_nouveau_teximage(ti)->surface;
d509 9
a517 3
	pixels = _mesa_validate_pbo_teximage(ctx, dims, width, height, depth,
					     format, type, pixels, packing,
					     "glTexSubImage");
d519 2
a520 2
		nouveau_teximage_map(ctx, ti, GL_MAP_WRITE_BIT,
				     xoffset, yoffset, width, height);
d522 7
a528 3
		ret = _mesa_texstore(ctx, 3, ti->_BaseFormat, ti->TexFormat,
				     ti->Data, 0, 0, 0, s->pitch,
				     ti->ImageOffsets, width, height, depth,
d532 1
a532 1
		nouveau_teximage_unmap(ctx, ti);
d536 3
a538 2
	if (!to_nouveau_texture(t)->dirty)
		validate_teximage(ctx, t, level, xoffset, yoffset, zoffset,
d543 6
a548 7
nouveau_texsubimage_3d(struct gl_context *ctx, GLenum target, GLint level,
		       GLint xoffset, GLint yoffset, GLint zoffset,
		       GLint width, GLint height, GLint depth,
		       GLenum format, GLenum type, const void *pixels,
		       const struct gl_pixelstore_attrib *packing,
		       struct gl_texture_object *t,
		       struct gl_texture_image *ti)
d550 3
a552 3
	nouveau_texsubimage(ctx, 3, target, level, xoffset, yoffset, zoffset,
			    width, height, depth, format, type, pixels,
			    packing, t, ti);
d556 10
a565 37
nouveau_texsubimage_2d(struct gl_context *ctx, GLenum target, GLint level,
		       GLint xoffset, GLint yoffset,
		       GLint width, GLint height,
		       GLenum format, GLenum type, const void *pixels,
		       const struct gl_pixelstore_attrib *packing,
		       struct gl_texture_object *t,
		       struct gl_texture_image *ti)
{
	nouveau_texsubimage(ctx, 2, target, level, xoffset, yoffset, 0,
			    width, height, 1, format, type, pixels,
			    packing, t, ti);
}

static void
nouveau_texsubimage_1d(struct gl_context *ctx, GLenum target, GLint level,
		       GLint xoffset, GLint width,
		       GLenum format, GLenum type, const void *pixels,
		       const struct gl_pixelstore_attrib *packing,
		       struct gl_texture_object *t,
		       struct gl_texture_image *ti)
{
	nouveau_texsubimage(ctx, 1, target, level, xoffset, 0, 0,
			    width, 1, 1, format, type, pixels,
			    packing, t, ti);
}

static void
nouveau_get_teximage(struct gl_context *ctx, GLenum target, GLint level,
		     GLenum format, GLenum type, GLvoid *pixels,
		     struct gl_texture_object *t,
		     struct gl_texture_image *ti)
{
	nouveau_teximage_map(ctx, ti, GL_MAP_READ_BIT,
			     0, 0, ti->Width, ti->Height);
	_mesa_get_teximage(ctx, target, level, format, type, pixels,
			   t, ti);
	nouveau_teximage_unmap(ctx, ti);
d601 1
d606 1
d616 1
a616 1
	_mesa_init_teximage_fields(ctx, target, ti, s->width, s->height,
d618 1
a618 1
	ti->RowStride = s->pitch / s->cpp;
a629 75
static void
nouveau_texture_map(struct gl_context *ctx, struct gl_texture_object *t)
{
	int i;

	for (i = t->BaseLevel; i < t->_MaxLevel; i++) {
		struct gl_texture_image *ti = t->Image[0][i];

		if (ti)
			nouveau_teximage_map(ctx, ti, GL_MAP_READ_BIT,
					     0, 0, ti->Width, ti->Height);
	}
}

static void
nouveau_texture_unmap(struct gl_context *ctx, struct gl_texture_object *t)
{
	int i;

	for (i = t->BaseLevel; i < t->_MaxLevel; i++) {
		if (t->Image[0][i])
			nouveau_teximage_unmap(ctx, t->Image[0][i]);
	}
}

static void
store_mipmap(struct gl_context *ctx, GLenum target, int first, int last,
	     struct gl_texture_object *t)
{
	struct gl_pixelstore_attrib packing = {
		.BufferObj = ctx->Shared->NullBufferObj,
		.Alignment = 1
	};
	GLenum format = t->Image[0][t->BaseLevel]->TexFormat;
	unsigned base_format, type, comps;
	int i;

	base_format = _mesa_get_format_base_format(format);
	_mesa_format_to_type_and_comps(format, &type, &comps);

	for (i = first; i <= last; i++) {
		struct gl_texture_image *ti = t->Image[0][i];
		void *data = ti->Data;

		nouveau_teximage(ctx, 3, target, i, ti->InternalFormat,
				 ti->Width, ti->Height, ti->Depth,
				 ti->Border, base_format, type, data,
				 &packing, t, ti);

		_mesa_free_texmemory(data);
	}
}

static void
nouveau_generate_mipmap(struct gl_context *ctx, GLenum target,
			struct gl_texture_object *t)
{
	if (_mesa_meta_check_generate_mipmap_fallback(ctx, target, t)) {
		struct gl_texture_image *base = t->Image[0][t->BaseLevel];

		nouveau_teximage_map(ctx, base, GL_MAP_READ_BIT,
				     0, 0, base->Width, base->Height);
		_mesa_generate_mipmap(ctx, target, t);
		nouveau_teximage_unmap(ctx, base);

		if (!_mesa_is_format_compressed(base->TexFormat)) {
			store_mipmap(ctx, target, t->BaseLevel + 1,
				     get_last_level(t), t);
		}

	} else {
		_mesa_meta_GenerateMipmap(ctx, target, t);
	}
}

d636 1
a636 1
	functions->FreeTexImageData = nouveau_teximage_free;
d638 4
a641 7
	functions->TexImage1D = nouveau_teximage_1d;
	functions->TexImage2D = nouveau_teximage_2d;
	functions->TexImage3D = nouveau_teximage_3d;
	functions->TexSubImage1D = nouveau_texsubimage_1d;
	functions->TexSubImage2D = nouveau_texsubimage_2d;
	functions->TexSubImage3D = nouveau_texsubimage_3d;
	functions->GetTexImage = nouveau_get_teximage;
d643 2
a644 3
	functions->MapTexture = nouveau_texture_map;
	functions->UnmapTexture = nouveau_texture_unmap;
	functions->GenerateMipmap = nouveau_generate_mipmap;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d33 1
d117 4
a120 2
			ret = nouveau_bo_map(s->bo, flags);
			assert(!ret);
d273 2
a274 2
	if (t->MinFilter == GL_NEAREST ||
	    t->MinFilter == GL_LINEAR || !base)
d691 4
a694 2
		store_mipmap(ctx, target, t->BaseLevel + 1,
			     get_last_level(t), t);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d41 1
d44 1
a44 1
nouveau_texture_new(GLcontext *ctx, GLuint name, GLenum target)
d54 1
a54 1
nouveau_texture_free(GLcontext *ctx, struct gl_texture_object *t)
d66 1
a66 1
nouveau_teximage_new(GLcontext *ctx)
d74 1
a74 1
nouveau_teximage_free(GLcontext *ctx, struct gl_texture_image *ti)
d82 2
a83 1
nouveau_teximage_map(GLcontext *ctx, struct gl_texture_image *ti)
d85 3
a87 2
	struct nouveau_surface *s = &to_nouveau_teximage(ti)->surface;
	int ret;
d90 28
a117 2
		ret = nouveau_bo_map(s->bo, NOUVEAU_BO_RDWR);
		assert(!ret);
d119 2
a120 1
		ti->Data = s->bo->map;
d125 1
a125 1
nouveau_teximage_unmap(GLcontext *ctx, struct gl_texture_image *ti)
d127 9
a135 1
	struct nouveau_surface *s = &to_nouveau_teximage(ti)->surface;
d137 1
a137 1
	if (s->bo)
d139 2
d145 1
a145 1
nouveau_choose_tex_format(GLcontext *ctx, GLint internalFormat,
d157 1
d167 1
d183 1
d192 1
d200 1
d225 1
a225 2
teximage_fits(struct gl_texture_object *t, int level,
	      struct gl_texture_image *ti)
d228 7
d237 2
a238 3
		(s->bo && s->width == ti->Width &&
		 s->height == ti->Height &&
		 s->format == ti->TexFormat);
d242 1
a242 1
validate_teximage(GLcontext *ctx, struct gl_texture_object *t,
d248 1
a248 1
	if (ti && teximage_fits(t, level, ti)) {
d278 1
a278 1
relayout_texture(GLcontext *ctx, struct gl_texture_object *t)
d331 1
a331 1
nouveau_texture_validate(GLcontext *ctx, struct gl_texture_object *t)
d336 2
a337 1
	if (!nt->surfaces[last].bo)
d350 2
d358 1
a358 1
nouveau_texture_reallocate(GLcontext *ctx, struct gl_texture_object *t)
d360 6
a365 3
	texture_dirty(t);
	relayout_texture(ctx, t);
	nouveau_texture_validate(ctx, t);
d382 1
a382 1
nouveau_teximage(GLcontext *ctx, GLint dims, GLenum target, GLint level,
d403 2
a404 1
		nouveau_teximage_map(ctx, ti);
d424 1
a424 1
		if (!teximage_fits(t, level, ti))
d434 1
a434 1
nouveau_teximage_1d(GLcontext *ctx, GLenum target, GLint level,
d448 1
a448 1
nouveau_teximage_2d(GLcontext *ctx, GLenum target, GLint level,
d462 1
a462 1
nouveau_teximage_3d(GLcontext *ctx, GLenum target, GLint level,
d476 35
a510 1
nouveau_texsubimage_3d(GLcontext *ctx, GLenum target, GLint level,
d518 3
a520 9
	nouveau_teximage_map(ctx, ti);
	_mesa_store_texsubimage3d(ctx, target, level, xoffset, yoffset, zoffset,
				  width, height, depth, format, type, pixels,
				  packing, t, ti);
	nouveau_teximage_unmap(ctx, ti);

	if (!to_nouveau_texture(t)->dirty)
		validate_teximage(ctx, t, level, xoffset, yoffset, zoffset,
				  width, height, depth);
d524 1
a524 1
nouveau_texsubimage_2d(GLcontext *ctx, GLenum target, GLint level,
d532 3
a534 9
	nouveau_teximage_map(ctx, ti);
	_mesa_store_texsubimage2d(ctx, target, level, xoffset, yoffset,
				  width, height, format, type, pixels,
				  packing, t, ti);
	nouveau_teximage_unmap(ctx, ti);

	if (!to_nouveau_texture(t)->dirty)
		validate_teximage(ctx, t, level, xoffset, yoffset, 0,
				  width, height, 1);
d538 1
a538 1
nouveau_texsubimage_1d(GLcontext *ctx, GLenum target, GLint level,
d545 3
a547 9
	nouveau_teximage_map(ctx, ti);
	_mesa_store_texsubimage1d(ctx, target, level, xoffset,
				  width, format, type, pixels,
				  packing, t, ti);
	nouveau_teximage_unmap(ctx, ti);

	if (!to_nouveau_texture(t)->dirty)
		validate_teximage(ctx, t, level, xoffset, 0, 0,
				  width, 1, 1);
d551 1
a551 1
nouveau_get_teximage(GLcontext *ctx, GLenum target, GLint level,
d556 2
a557 1
	nouveau_teximage_map(ctx, ti);
d564 1
a564 1
nouveau_bind_texture(GLcontext *ctx, GLenum target,
d590 1
a590 1
	GLcontext *ctx = &nctx->base;
d606 2
d610 1
a610 1
				   1, 0, s->cpp);
a611 1
	ti->TexFormat = s->format = get_texbuffer_format(rb, format);
d624 1
a624 1
nouveau_texture_map(GLcontext *ctx, struct gl_texture_object *t)
d629 5
a633 2
		if (t->Image[0][i])
			nouveau_teximage_map(ctx, t->Image[0][i]);
d638 1
a638 1
nouveau_texture_unmap(GLcontext *ctx, struct gl_texture_object *t)
d648 48
d714 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a40 1
#include "drivers/common/meta.h"
d43 1
a43 1
nouveau_texture_new(struct gl_context *ctx, GLuint name, GLenum target)
d53 1
a53 1
nouveau_texture_free(struct gl_context *ctx, struct gl_texture_object *t)
d65 1
a65 1
nouveau_teximage_new(struct gl_context *ctx)
d73 1
a73 1
nouveau_teximage_free(struct gl_context *ctx, struct gl_texture_image *ti)
d81 1
a81 2
nouveau_teximage_map(struct gl_context *ctx, struct gl_texture_image *ti,
		     int access, int x, int y, int w, int h)
d83 2
a84 3
	struct nouveau_teximage *nti = to_nouveau_teximage(ti);
	struct nouveau_surface *s = &nti->surface;
	struct nouveau_surface *st = &nti->transfer.surface;
d87 2
a88 28
		if (!(access & GL_MAP_READ_BIT) &&
		    nouveau_bo_pending(s->bo)) {
			/*
			 * Heuristic: use a bounce buffer to pipeline
			 * teximage transfers.
			 */
			st->layout = LINEAR;
			st->format = s->format;
			st->cpp = s->cpp;
			st->width = w;
			st->height = h;
			st->pitch = s->pitch;
			nti->transfer.x = x;
			nti->transfer.y = y;

			ti->Data = nouveau_get_scratch(ctx, st->pitch * h,
						       &st->bo, &st->offset);

		} else {
			int ret, flags = 0;

			if (access & GL_MAP_READ_BIT)
				flags |= NOUVEAU_BO_RD;
			if (access & GL_MAP_WRITE_BIT)
				flags |= NOUVEAU_BO_WR;

			ret = nouveau_bo_map(s->bo, flags);
			assert(!ret);
d90 1
a90 2
			ti->Data = s->bo->map + y * s->pitch + x * s->cpp;
		}
d95 1
a95 1
nouveau_teximage_unmap(struct gl_context *ctx, struct gl_texture_image *ti)
d97 1
a97 3
	struct nouveau_teximage *nti = to_nouveau_teximage(ti);
	struct nouveau_surface *s = &nti->surface;
	struct nouveau_surface *st = &nti->transfer.surface;
d99 1
a99 7
	if (st->bo) {
		context_drv(ctx)->surface_copy(ctx, s, st, nti->transfer.x,
					       nti->transfer.y, 0, 0,
					       st->width, st->height);
		nouveau_surface_ref(NULL, st);

	} else if (s->bo) {
a100 2
	}

d105 1
a105 1
nouveau_choose_tex_format(struct gl_context *ctx, GLint internalFormat,
a116 1
	case GL_COMPRESSED_RGBA:
a125 1
	case GL_COMPRESSED_RGB:
a140 1
	case GL_COMPRESSED_LUMINANCE_ALPHA:
a148 1
	case GL_COMPRESSED_LUMINANCE:
a155 1
	case GL_COMPRESSED_ALPHA:
d180 2
a181 1
teximage_fits(struct gl_texture_object *t, int level)
a183 7
	struct gl_texture_image *ti = t->Image[0][level];

	if (!ti || !to_nouveau_teximage(ti)->surface.bo)
		return GL_FALSE;

	if (level == t->BaseLevel && (s->offset & 0x7f))
		return GL_FALSE;
d186 3
a188 2
		(s->bo && s->format == ti->TexFormat &&
		 s->width == ti->Width && s->height == ti->Height);
d192 1
a192 1
validate_teximage(struct gl_context *ctx, struct gl_texture_object *t,
d198 1
a198 1
	if (teximage_fits(t, level)) {
d228 1
a228 1
relayout_texture(struct gl_context *ctx, struct gl_texture_object *t)
d281 1
a281 1
nouveau_texture_validate(struct gl_context *ctx, struct gl_texture_object *t)
d286 1
a286 2
	if (!teximage_fits(t, t->BaseLevel) ||
	    !teximage_fits(t, last))
a298 2

		FIRE_RING(context_chan(ctx));
d305 1
a305 1
nouveau_texture_reallocate(struct gl_context *ctx, struct gl_texture_object *t)
d307 3
a309 6
	if (!teximage_fits(t, t->BaseLevel) ||
	    !teximage_fits(t, get_last_level(t))) {
		texture_dirty(t);
		relayout_texture(ctx, t);
		nouveau_texture_validate(ctx, t);
	}
d326 1
a326 1
nouveau_teximage(struct gl_context *ctx, GLint dims, GLenum target, GLint level,
d347 1
a347 2
		nouveau_teximage_map(ctx, ti, GL_MAP_WRITE_BIT,
				     0, 0, width, height);
d367 1
a367 1
		if (!teximage_fits(t, level))
d377 1
a377 1
nouveau_teximage_1d(struct gl_context *ctx, GLenum target, GLint level,
d391 1
a391 1
nouveau_teximage_2d(struct gl_context *ctx, GLenum target, GLint level,
d405 1
a405 1
nouveau_teximage_3d(struct gl_context *ctx, GLenum target, GLint level,
d419 1
a419 35
nouveau_texsubimage(struct gl_context *ctx, GLint dims, GLenum target, GLint level,
		    GLint xoffset, GLint yoffset, GLint zoffset,
		    GLint width, GLint height, GLint depth,
		    GLenum format, GLenum type, const void *pixels,
		    const struct gl_pixelstore_attrib *packing,
		    struct gl_texture_object *t,
		    struct gl_texture_image *ti)
{
	struct nouveau_surface *s = &to_nouveau_teximage(ti)->surface;
	int ret;

	pixels = _mesa_validate_pbo_teximage(ctx, dims, width, height, depth,
					     format, type, pixels, packing,
					     "glTexSubImage");
	if (pixels) {
		nouveau_teximage_map(ctx, ti, GL_MAP_WRITE_BIT,
				     xoffset, yoffset, width, height);

		ret = _mesa_texstore(ctx, 3, ti->_BaseFormat, ti->TexFormat,
				     ti->Data, 0, 0, 0, s->pitch,
				     ti->ImageOffsets, width, height, depth,
				     format, type, pixels, packing);
		assert(ret);

		nouveau_teximage_unmap(ctx, ti);
		_mesa_unmap_teximage_pbo(ctx, packing);
	}

	if (!to_nouveau_texture(t)->dirty)
		validate_teximage(ctx, t, level, xoffset, yoffset, zoffset,
				  width, height, depth);
}

static void
nouveau_texsubimage_3d(struct gl_context *ctx, GLenum target, GLint level,
d427 9
a435 3
	nouveau_texsubimage(ctx, 3, target, level, xoffset, yoffset, zoffset,
			    width, height, depth, format, type, pixels,
			    packing, t, ti);
d439 1
a439 1
nouveau_texsubimage_2d(struct gl_context *ctx, GLenum target, GLint level,
d447 9
a455 3
	nouveau_texsubimage(ctx, 2, target, level, xoffset, yoffset, 0,
			    width, height, 1, format, type, pixels,
			    packing, t, ti);
d459 1
a459 1
nouveau_texsubimage_1d(struct gl_context *ctx, GLenum target, GLint level,
d466 9
a474 3
	nouveau_texsubimage(ctx, 1, target, level, xoffset, 0, 0,
			    width, 1, 1, format, type, pixels,
			    packing, t, ti);
d478 1
a478 1
nouveau_get_teximage(struct gl_context *ctx, GLenum target, GLint level,
d483 1
a483 2
	nouveau_teximage_map(ctx, ti, GL_MAP_READ_BIT,
			     0, 0, ti->Width, ti->Height);
d490 1
a490 1
nouveau_bind_texture(struct gl_context *ctx, GLenum target,
d516 1
a516 1
	struct gl_context *ctx = &nctx->base;
a531 2
        s->format = get_texbuffer_format(rb, format);

d534 1
a534 1
				   1, 0, s->cpp, s->format);
d536 1
d549 1
a549 1
nouveau_texture_map(struct gl_context *ctx, struct gl_texture_object *t)
d554 2
a555 5
		struct gl_texture_image *ti = t->Image[0][i];

		if (ti)
			nouveau_teximage_map(ctx, ti, GL_MAP_READ_BIT,
					     0, 0, ti->Width, ti->Height);
d560 1
a560 1
nouveau_texture_unmap(struct gl_context *ctx, struct gl_texture_object *t)
a569 48
static void
store_mipmap(struct gl_context *ctx, GLenum target, int first, int last,
	     struct gl_texture_object *t)
{
	struct gl_pixelstore_attrib packing = {
		.BufferObj = ctx->Shared->NullBufferObj,
		.Alignment = 1
	};
	GLenum format = t->Image[0][t->BaseLevel]->TexFormat;
	unsigned base_format, type, comps;
	int i;

	base_format = _mesa_get_format_base_format(format);
	_mesa_format_to_type_and_comps(format, &type, &comps);

	for (i = first; i <= last; i++) {
		struct gl_texture_image *ti = t->Image[0][i];
		void *data = ti->Data;

		nouveau_teximage(ctx, 3, target, i, ti->InternalFormat,
				 ti->Width, ti->Height, ti->Depth,
				 ti->Border, base_format, type, data,
				 &packing, t, ti);

		_mesa_free_texmemory(data);
	}
}

static void
nouveau_generate_mipmap(struct gl_context *ctx, GLenum target,
			struct gl_texture_object *t)
{
	if (_mesa_meta_check_generate_mipmap_fallback(ctx, target, t)) {
		struct gl_texture_image *base = t->Image[0][t->BaseLevel];

		nouveau_teximage_map(ctx, base, GL_MAP_READ_BIT,
				     0, 0, base->Width, base->Height);
		_mesa_generate_mipmap(ctx, target, t);
		nouveau_teximage_unmap(ctx, base);

		store_mipmap(ctx, target, t->BaseLevel + 1,
			     get_last_level(t), t);

	} else {
		_mesa_meta_GenerateMipmap(ctx, target, t);
	}
}

a587 1
	functions->GenerateMipmap = nouveau_generate_mipmap;
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a32 1
#include "main/pbo.h"
d39 1
a41 1
#include "swrast/s_texfetch.h"
d48 1
a48 1
	_mesa_initialize_texture_object(ctx, &nt->base, name, target);
d70 1
a70 1
	return &nti->base.Base;
d82 2
a83 7
nouveau_map_texture_image(struct gl_context *ctx,
			  struct gl_texture_image *ti,
			  GLuint slice,
			  GLuint x, GLuint y, GLuint w, GLuint h,
			  GLbitfield mode,
			  GLubyte **map,
			  GLint *stride)
a87 4
	struct nouveau_client *client = context_client(ctx);

	/* Nouveau has no support for 3D or cubemap textures. */
	assert(slice == 0);
d90 2
a91 3
		if (!(mode & GL_MAP_READ_BIT) &&
		    nouveau_pushbuf_refd(context_push(ctx), s->bo)) {
			unsigned size;
d105 3
a107 4
			size = get_format_blocksy(st->format, h) * st->pitch;
			*map = nouveau_get_scratch(ctx, size,
					  &st->bo, &st->offset);
			*stride = st->pitch;
d111 1
a111 1
			if (mode & GL_MAP_READ_BIT)
d113 1
a113 1
			if (mode & GL_MAP_WRITE_BIT)
d116 4
a119 9
			if (!s->bo->map) {
				ret = nouveau_bo_map(s->bo, flags, client);
				assert(!ret);
			}

			*map = s->bo->map +
				get_format_blocksy(s->format, y) * s->pitch +
				get_format_blocksx(s->format, x) * s->cpp;
			*stride = s->pitch;
a120 5
	} else {
		*map = nti->base.Buffer +
			get_format_blocksy(s->format, y) * s->pitch +
			get_format_blocksx(s->format, x) * s->cpp;
		*stride = s->pitch;
d125 1
a125 2
nouveau_unmap_texture_image(struct gl_context *ctx, struct gl_texture_image *ti,
			    GLuint slice)
d137 2
d140 2
d145 1
a145 2
nouveau_choose_tex_format(struct gl_context *ctx, GLenum target,
                          GLint internalFormat,
d210 8
a217 15
	case GL_RGB_S3TC:
	case GL_RGB4_S3TC:
	case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
		return MESA_FORMAT_RGB_DXT1;

	case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
		return MESA_FORMAT_RGBA_DXT1;

	case GL_RGBA_S3TC:
	case GL_RGBA4_S3TC:
	case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
		return MESA_FORMAT_RGBA_DXT3;

	case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
		return MESA_FORMAT_RGBA_DXT5;
d270 2
a271 2
	if (t->Sampler.MinFilter == GL_NEAREST ||
	    t->Sampler.MinFilter == GL_LINEAR || !base)
d274 1
a274 1
		return MIN2(t->BaseLevel + base->MaxNumLevels - 1, t->MaxLevel);
d286 1
a286 3
		enum nouveau_surface_layout layout =
			(_mesa_is_format_compressed(s->format) ? LINEAR : SWIZZLED);
		unsigned size, pitch, offset = 0,
d296 1
a296 2
			pitch = _mesa_format_row_stride(s->format, width);
			size = get_format_blocksy(s->format, height) * pitch;
d304 1
a304 1
				.layout = layout,
d309 1
a309 1
				.pitch = pitch,
d313 2
a314 2
			width = minify(width, 1);
			height = minify(height, 1);
d322 1
a322 1
				     0, size, NULL, &ss[last].bo);
d351 1
a351 1
		PUSH_KICK(context_push(ctx));
d382 3
a384 3
nouveau_teximage(struct gl_context *ctx, GLint dims,
		 struct gl_texture_image *ti,
		 GLsizei imageSize,
d387 2
a388 1
		 GLboolean compressed)
a389 2
	struct gl_texture_object *t = ti->TexObject;
	const GLuint level = ti->Level;
a390 1
	struct nouveau_teximage *nti = to_nouveau_teximage(ti);
a391 1
	GLuint depth = compressed ? 1 : ti->Depth;
d395 2
a396 11
			      ti->TexFormat, ti->Width, ti->Height);
	nti->base.RowStride = s->pitch / s->cpp;

	if (compressed)
		pixels = _mesa_validate_pbo_compressed_teximage(ctx,
			dims, imageSize,
			pixels, packing, "glCompressedTexImage");
	else
		pixels = _mesa_validate_pbo_teximage(ctx,
			dims, ti->Width, ti->Height, depth, format, type,
			pixels, packing, "glTexImage");
d398 3
a401 3
		GLubyte *map;
		int row_stride;

d403 2
a404 4
		nouveau_map_texture_image(ctx, ti, 0,
					  0, 0, ti->Width, ti->Height,
					  GL_MAP_WRITE_BIT,
					  &map, &row_stride);
d407 4
a410 4
				     ti->TexFormat,
				     row_stride,
				     &map,
				     ti->Width, ti->Height, depth,
d414 1
a414 1
		nouveau_unmap_texture_image(ctx, ti, 0);
d418 1
a418 1
				       ti->Width, ti->Height, depth))
d433 13
d448 7
a454 4
nouveau_teximage_123d(struct gl_context *ctx, GLuint dims,
                      struct gl_texture_image *ti,
                      GLenum format, GLenum type, const GLvoid *pixels,
                      const struct gl_pixelstore_attrib *packing)
d456 3
a458 2
	nouveau_teximage(ctx, dims, ti, 0, format, type, pixels,
			 packing, GL_FALSE);
d462 7
a468 3
nouveau_compressed_teximage(struct gl_context *ctx, GLuint dims,
		    struct gl_texture_image *ti,
		    GLsizei imageSize, const GLvoid *data)
d470 3
a472 2
	nouveau_teximage(ctx, 2, ti, imageSize, 0, 0, data,
			 &ctx->Unpack, GL_TRUE);
d476 1
a476 2
nouveau_texsubimage(struct gl_context *ctx, GLint dims,
		    struct gl_texture_image *ti,
a478 1
		    GLsizei imageSize,
d481 2
a482 1
		    GLboolean compressed)
d484 1
d487 3
a489 9
	if (compressed)
		pixels = _mesa_validate_pbo_compressed_teximage(ctx,
				dims, imageSize,
				pixels, packing, "glCompressedTexSubImage");
	else
		pixels = _mesa_validate_pbo_teximage(ctx,
				dims, width, height, depth, format, type,
				pixels, packing, "glTexSubImage");

d491 2
a492 2
		GLubyte *map;
		int row_stride;
d494 3
a496 7
		nouveau_map_texture_image(ctx, ti, 0,
					  xoffset, yoffset, width, height,
					  GL_MAP_WRITE_BIT, &map, &row_stride);

		ret = _mesa_texstore(ctx, dims, ti->_BaseFormat, ti->TexFormat,
				     row_stride, &map,
                                     width, height, depth,
d500 1
a500 1
		nouveau_unmap_texture_image(ctx, ti, 0);
d504 2
a505 3
	if (!to_nouveau_texture(ti->TexObject)->dirty)
		validate_teximage(ctx, ti->TexObject, ti->Level,
				  xoffset, yoffset, zoffset,
d510 21
a530 6
nouveau_texsubimage_123d(struct gl_context *ctx, GLuint dims,
                         struct gl_texture_image *ti,
                         GLint xoffset, GLint yoffset, GLint zoffset,
                         GLint width, GLint height, GLint depth,
                         GLenum format, GLenum type, const void *pixels,
                         const struct gl_pixelstore_attrib *packing)
d532 3
a534 3
	nouveau_texsubimage(ctx, dims, ti, xoffset, yoffset, zoffset,
			    width, height, depth, 0, format, type, pixels,
			    packing, GL_FALSE);
d538 23
a560 10
nouveau_compressed_texsubimage(struct gl_context *ctx, GLuint dims,
		       struct gl_texture_image *ti,
		       GLint xoffset, GLint yoffset, GLint zoffset,
		       GLsizei width, GLint height, GLint depth,
		       GLenum format,
		       GLint imageSize, const void *data)
{
	nouveau_texsubimage(ctx, dims, ti, xoffset, yoffset, zoffset,
			  width, height, depth, imageSize, format, 0, data,
			  &ctx->Unpack, GL_TRUE);
a595 1
	struct nouveau_teximage *nti;
a599 1
	nti = to_nouveau_teximage(ti);
d609 1
a609 1
	_mesa_init_teximage_fields(ctx, ti, s->width, s->height,
d611 1
a611 1
	nti->base.RowStride = s->pitch / s->cpp;
d623 73
d702 1
a702 1
	functions->FreeTextureImageBuffer = nouveau_teximage_free;
d704 7
a710 4
	functions->TexImage = nouveau_teximage_123d;
	functions->TexSubImage = nouveau_texsubimage_123d;
	functions->CompressedTexImage = nouveau_compressed_teximage;
	functions->CompressedTexSubImage = nouveau_compressed_texsubimage;
d712 3
a714 2
	functions->MapTextureImage = nouveau_map_texture_image;
	functions->UnmapTextureImage = nouveau_unmap_texture_image;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d163 1
a163 1
static mesa_format
d178 1
a178 1
		return MESA_FORMAT_B8G8R8A8_UNORM;
d180 1
a180 1
		return MESA_FORMAT_B5G5R5A1_UNORM;
d188 1
a188 1
		return MESA_FORMAT_B8G8R8X8_UNORM;
d193 1
a193 1
		return MESA_FORMAT_B5G6R5_UNORM;
d204 1
a204 1
		return MESA_FORMAT_B8G8R8A8_UNORM;
d213 1
a213 1
		return MESA_FORMAT_L_UNORM8;
d221 1
a221 1
		return MESA_FORMAT_A_UNORM8;
d228 1
a228 2
	case GL_COMPRESSED_INTENSITY:
		return MESA_FORMAT_I_UNORM8;
d401 3
a403 3
	if (ti->TexFormat == MESA_FORMAT_A_UNORM8 ||
	    ti->TexFormat == MESA_FORMAT_L_UNORM8 ||
	    ti->TexFormat == MESA_FORMAT_I_UNORM8)
a496 8
static GLboolean
nouveau_teximage_alloc(struct gl_context *ctx, struct gl_texture_image *ti)
{
	nouveau_teximage(ctx, 3, ti, 0, 0, 0, NULL,
			 &ctx->DefaultPacking, GL_FALSE);
	return GL_TRUE;
}

d569 2
a570 2
nouveau_bind_texture(struct gl_context *ctx, GLuint texUnit,
                     GLenum target, struct gl_texture_object *t)
d572 2
a573 2
	context_dirty_i(ctx, TEX_OBJ, texUnit);
	context_dirty_i(ctx, TEX_ENV, texUnit);
d576 1
a576 1
static mesa_format
d584 1
a584 1
		return MESA_FORMAT_B8G8R8A8_UNORM;
d586 1
a586 1
		return MESA_FORMAT_B8G8R8X8_UNORM;
a636 1
	functions->AllocTextureImageBuffer = nouveau_teximage_alloc;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d348 2
a349 9
		if (t->BaseLevel <= last) {
			/* Get new storage. */
			size = align(offset, 64);
			assert(size);

			ret = nouveau_bo_new(context_dev(ctx), NOUVEAU_BO_MAP |
					     NOUVEAU_BO_GART | NOUVEAU_BO_VRAM,
					     0, size, NULL, &ss[last].bo);
			assert(!ret);
d351 7
a357 3
			for (i = t->BaseLevel; i < last; i++)
				nouveau_bo_ref(ss[last].bo, &ss[i].bo);
		}
a412 25
nouveau_compressed_copy(struct gl_context *ctx, GLint dims,
			struct gl_texture_image *ti,
			GLsizei width, GLsizei height, GLsizei depth,
			const GLvoid *src, GLvoid *dst, int row_stride)
{
	struct compressed_pixelstore store;
	int i;

	_mesa_compute_compressed_pixelstore(dims, ti->TexFormat,
					    width, height, depth,
					    &ctx->Unpack, &store);

	src += store.SkipBytes;

	assert(store.CopySlices == 1);

	/* copy rows of blocks */
	for (i = 0; i < store.CopyRowsPerSlice; i++) {
		memcpy(dst, src, store.CopyBytesPerRow);
		dst += row_stride;
		src += store.TotalBytesPerRow;
	}
}

static void
d451 7
a457 13
		if (compressed) {
			nouveau_compressed_copy(ctx, dims, ti,
						ti->Width, ti->Height, depth,
						pixels, map, row_stride);
		} else {
			ret = _mesa_texstore(ctx, dims, ti->_BaseFormat,
					     ti->TexFormat,
					     row_stride,
					     &map,
					     ti->Width, ti->Height, depth,
					     format, type, pixels, packing);
			assert(ret);
		}
d502 1
a502 2
			 &ctx->DefaultPacking,
			 _mesa_is_format_compressed(ti->TexFormat));
d535 5
a539 12
		if (compressed) {
			nouveau_compressed_copy(ctx, dims, ti,
						width, height, depth,
						pixels, map, row_stride);
		} else {
			ret = _mesa_texstore(ctx, dims, ti->_BaseFormat,
					     ti->TexFormat,
					     row_stride, &map,
					     width, height, depth,
					     format, type, pixels, packing);
			assert(ret);
		}
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d348 9
a356 2
		/* Get new storage. */
		size = align(offset, 64);
d358 3
a360 7
		ret = nouveau_bo_new(context_dev(ctx), NOUVEAU_BO_MAP |
				     NOUVEAU_BO_GART | NOUVEAU_BO_VRAM,
				     0, size, NULL, &ss[last].bo);
		assert(!ret);

		for (i = t->BaseLevel; i < last; i++)
			nouveau_bo_ref(ss[last].bo, &ss[i].bo);
d416 25
d479 13
a491 7
		ret = _mesa_texstore(ctx, dims, ti->_BaseFormat,
				     ti->TexFormat,
				     row_stride,
				     &map,
				     ti->Width, ti->Height, depth,
				     format, type, pixels, packing);
		assert(ret);
d536 2
a537 1
			 &ctx->DefaultPacking, GL_FALSE);
d570 12
a581 5
		ret = _mesa_texstore(ctx, dims, ti->_BaseFormat, ti->TexFormat,
				     row_stride, &map,
                                     width, height, depth,
				     format, type, pixels, packing);
		assert(ret);
@


