head	1.3;
access;
symbols
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2013.09.05.14.04.48;	author jsg;	state dead;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.39;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@/*
 * Copyright (C) 2009 Francisco Jerez.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "nouveau_driver.h"
#include "nouveau_context.h"

static GLboolean
nouveau_bo_marker_emit(struct gl_context *ctx, struct nouveau_bo_marker *m,
		       uint32_t flags)
{
	struct nouveau_channel *chan = context_chan(ctx);
	uint32_t packet;

	if (m->gr->bound == NOUVEAU_GROBJ_UNBOUND)
		nouveau_grobj_autobind(m->gr);

	if (MARK_RING(chan, 2, 2))
		return GL_FALSE;

	packet = (m->gr->subc << 13) | (1 << 18) | m->mthd;

	if (flags) {
		if (nouveau_pushbuf_emit_reloc(chan, chan->cur++, m->bo,
					       packet, 0, flags |
					       (m->flags & (NOUVEAU_BO_VRAM |
							    NOUVEAU_BO_GART |
							    NOUVEAU_BO_RDWR)),
					       0, 0))
			goto fail;
	} else {
		*(chan->cur++) = packet;
	}

	if (nouveau_pushbuf_emit_reloc(chan, chan->cur++, m->bo, m->data,
				       m->data2, flags | m->flags,
				       m->vor, m->tor))
		goto fail;

	return GL_TRUE;

fail:
	MARK_UNDO(chan);
	return GL_FALSE;
}

static GLboolean
nouveau_bo_context_grow(struct nouveau_bo_context *bctx)
{
	struct nouveau_bo_marker *marker = bctx->marker;
	int allocated = bctx->allocated + 1;

	marker = realloc(marker, allocated * sizeof(struct nouveau_bo_marker));
	if (!marker)
		return GL_FALSE;

	bctx->marker = marker;
	bctx->allocated = allocated;

	return GL_TRUE;
}

GLboolean
nouveau_bo_mark(struct nouveau_bo_context *bctx, struct nouveau_grobj *gr,
		uint32_t mthd, struct nouveau_bo *bo,
		uint32_t data, uint32_t data2, uint32_t vor, uint32_t tor,
		uint32_t flags)
{
	struct nouveau_bo_state *s = &to_nouveau_context(bctx->ctx)->bo;
	struct nouveau_bo_marker *m;

	if (bctx->count == bctx->allocated) {
		if (!nouveau_bo_context_grow(bctx))
			goto fail;
	}

	m = &bctx->marker[bctx->count];

	*m = (struct nouveau_bo_marker) {
		.gr = gr,
		.mthd = mthd,
		.data = data,
		.data2 = data2,
		.vor = vor,
		.tor = tor,
		.flags = flags,
	};
	nouveau_bo_ref(bo, &m->bo);

	s->count++;
	bctx->count++;

	if (!nouveau_bo_marker_emit(bctx->ctx, m, 0))
		goto fail;

	return GL_TRUE;

fail:
	nouveau_bo_context_reset(bctx);
	return GL_FALSE;
}

void
nouveau_bo_context_reset(struct nouveau_bo_context *bctx)
{
	struct nouveau_bo_state *s = &to_nouveau_context(bctx->ctx)->bo;
	int i, n = bctx->count;

	s->count -= n;
	bctx->count = 0;

	for (i = 0; i < n; i++)
		nouveau_bo_ref(NULL, &bctx->marker[i].bo);
}

GLboolean
nouveau_bo_state_emit(struct gl_context *ctx)
{
	struct nouveau_bo_state *s = &to_nouveau_context(ctx)->bo;
	int i, j;

	for (i = 0; i < NUM_NOUVEAU_BO_CONTEXT; i++) {
		struct nouveau_bo_context *bctx = &s->context[i];

		for (j = 0; j < bctx->count; j++) {
			if (!nouveau_bo_marker_emit(ctx, &bctx->marker[j],
						    NOUVEAU_BO_DUMMY))
				return GL_FALSE;
		}
	}

	return GL_TRUE;
}

void
nouveau_bo_state_init(struct gl_context *ctx)
{
	struct nouveau_bo_state *s = &to_nouveau_context(ctx)->bo;
	int i;

	for (i = 0; i < NUM_NOUVEAU_BO_CONTEXT; i++)
		s->context[i].ctx = ctx;
}

void
nouveau_bo_state_destroy(struct gl_context *ctx)
{
	struct nouveau_bo_state *s = &to_nouveau_context(ctx)->bo;
	int i, j;

	for (i = 0; i < NUM_NOUVEAU_BO_CONTEXT; i++) {
		struct nouveau_bo_context *bctx = &s->context[i];

		for (j = 0; j < bctx->count; j++)
			nouveau_bo_ref(NULL, &bctx->marker[j].bo);

		if (bctx->marker)
			free(bctx->marker);
	}
}
@


1.2
log
@Merge Mesa 7.10.3
@
text
@@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d31 1
a31 1
nouveau_bo_marker_emit(GLcontext *ctx, struct nouveau_bo_marker *m,
d129 4
a132 1
	int i;
d134 1
a134 1
	for (i = 0; i < bctx->count; i++)
a135 3

	s->count -= bctx->count;
	bctx->count = 0;
d139 1
a139 1
nouveau_bo_state_emit(GLcontext *ctx)
d158 1
a158 1
nouveau_bo_state_init(GLcontext *ctx)
d168 1
a168 1
nouveau_bo_state_destroy(GLcontext *ctx)
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d31 1
a31 1
nouveau_bo_marker_emit(struct gl_context *ctx, struct nouveau_bo_marker *m,
d129 4
a132 1
	int i, n = bctx->count;
d134 1
a134 1
	s->count -= n;
a135 3

	for (i = 0; i < n; i++)
		nouveau_bo_ref(NULL, &bctx->marker[i].bo);
d139 1
a139 1
nouveau_bo_state_emit(struct gl_context *ctx)
d158 1
a158 1
nouveau_bo_state_init(struct gl_context *ctx)
d168 1
a168 1
nouveau_bo_state_destroy(struct gl_context *ctx)
@

