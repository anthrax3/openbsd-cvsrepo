head	1.5;
access;
symbols
	OPENBSD_5_4:1.4.0.8
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.09.05.14.05.51;	author jsg;	state dead;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.54.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.54.07;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.43;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge Mesa 9.2.0
@
text
@/*
 * GLX Hardware Device Driver for Intel i810
 * Copyright (C) 1999 Keith Whitwell
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * KEITH WHITWELL, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM, 
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *
 */
 
#include "main/glheader.h"
#include "main/mtypes.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/colormac.h"

#include "tdfx_context.h"
#include "tdfx_vb.h"
#include "tdfx_render.h"

static void copy_pv( struct gl_context *ctx, GLuint edst, GLuint esrc )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT( ctx );
   tdfxVertex *dst = fxMesa->verts + edst;
   tdfxVertex *src = fxMesa->verts + esrc;
   *(GLuint *)&dst->color = *(GLuint *)&src->color;
}

static struct {
   void                (*emit)( struct gl_context *, GLuint, GLuint, void * );
   tnl_interp_func		interp;
   tnl_copy_pv_func	        copy_pv;
   GLboolean           (*check_tex_sizes)( struct gl_context *ctx );
   GLuint               vertex_format;
} setup_tab[TDFX_MAX_SETUP];




#define GET_COLOR(ptr, idx) ((ptr)->data[idx])


static void interp_extras( struct gl_context *ctx,
			   GLfloat t,
			   GLuint dst, GLuint out, GLuint in,
			   GLboolean force_boundary )
{
   struct vertex_buffer *VB = &TNL_CONTEXT(ctx)->vb;

   /*fprintf(stderr, "%s\n", __FUNCTION__);*/

   if (VB->BackfaceColorPtr) {
      INTERP_4F( t,
		 GET_COLOR(VB->BackfaceColorPtr, dst),
		 GET_COLOR(VB->BackfaceColorPtr, out),
		 GET_COLOR(VB->BackfaceColorPtr, in) );
   }

   if (VB->EdgeFlag) {
      VB->EdgeFlag[dst] = VB->EdgeFlag[out] || force_boundary;
   }

   setup_tab[TDFX_CONTEXT(ctx)->SetupIndex].interp(ctx, t, dst, out, in,
						   force_boundary);
}

static void copy_pv_extras( struct gl_context *ctx, GLuint dst, GLuint src )
{
   struct vertex_buffer *VB = &TNL_CONTEXT(ctx)->vb;

   if (VB->BackfaceColorPtr) {
      COPY_4FV( GET_COLOR(VB->BackfaceColorPtr, dst),
		GET_COLOR(VB->BackfaceColorPtr, src) );
   }

   setup_tab[TDFX_CONTEXT(ctx)->SetupIndex].copy_pv(ctx, dst, src);
}



#define IND (TDFX_XYZ_BIT|TDFX_RGBA_BIT)
#define TAG(x) x##_wg
#include "tdfx_vbtmp.h"

/* Special for tdfx: fog requires w
 */
#define IND (TDFX_XYZ_BIT|TDFX_RGBA_BIT|TDFX_W_BIT)
#define TAG(x) x##_wg_fog
#include "tdfx_vbtmp.h"

#define IND (TDFX_XYZ_BIT|TDFX_RGBA_BIT|TDFX_W_BIT|TDFX_TEX0_BIT)
#define TAG(x) x##_wgt0
#include "tdfx_vbtmp.h"

#define IND (TDFX_XYZ_BIT|TDFX_RGBA_BIT|TDFX_W_BIT|TDFX_TEX0_BIT|TDFX_TEX1_BIT)
#define TAG(x) x##_wgt0t1
#include "tdfx_vbtmp.h"

#define IND (TDFX_XYZ_BIT|TDFX_RGBA_BIT|TDFX_W_BIT|TDFX_TEX0_BIT|TDFX_PTEX_BIT)
#define TAG(x) x##_wgpt0
#include "tdfx_vbtmp.h"

#define IND (TDFX_XYZ_BIT|TDFX_RGBA_BIT|TDFX_W_BIT|TDFX_TEX0_BIT|TDFX_TEX1_BIT|\
             TDFX_PTEX_BIT)
#define TAG(x) x##_wgpt0t1
#include "tdfx_vbtmp.h"

#define IND (TDFX_RGBA_BIT)
#define TAG(x) x##_g
#include "tdfx_vbtmp.h"

#define IND (TDFX_TEX0_BIT)
#define TAG(x) x##_t0
#include "tdfx_vbtmp.h"

#define IND (TDFX_TEX0_BIT|TDFX_TEX1_BIT)
#define TAG(x) x##_t0t1
#include "tdfx_vbtmp.h"

#define IND (TDFX_RGBA_BIT|TDFX_TEX0_BIT)
#define TAG(x) x##_gt0
#include "tdfx_vbtmp.h"

#define IND (TDFX_RGBA_BIT|TDFX_TEX0_BIT|TDFX_TEX1_BIT)
#define TAG(x) x##_gt0t1
#include "tdfx_vbtmp.h"


/* fogc { */
#define IND (TDFX_XYZ_BIT|TDFX_RGBA_BIT|TDFX_W_BIT|TDFX_FOGC_BIT)
#define TAG(x) x##_wgf
#include "tdfx_vbtmp.h"

#define IND (TDFX_XYZ_BIT|TDFX_RGBA_BIT|TDFX_W_BIT|TDFX_TEX0_BIT|TDFX_FOGC_BIT)
#define TAG(x) x##_wgt0f
#include "tdfx_vbtmp.h"

#define IND (TDFX_XYZ_BIT|TDFX_RGBA_BIT|TDFX_W_BIT|TDFX_TEX0_BIT|TDFX_TEX1_BIT|TDFX_FOGC_BIT)
#define TAG(x) x##_wgt0t1f
#include "tdfx_vbtmp.h"

#define IND (TDFX_XYZ_BIT|TDFX_RGBA_BIT|TDFX_W_BIT|TDFX_TEX0_BIT|TDFX_PTEX_BIT|TDFX_FOGC_BIT)
#define TAG(x) x##_wgpt0f
#include "tdfx_vbtmp.h"

#define IND (TDFX_XYZ_BIT|TDFX_RGBA_BIT|TDFX_W_BIT|TDFX_TEX0_BIT|TDFX_TEX1_BIT|\
             TDFX_PTEX_BIT|TDFX_FOGC_BIT)
#define TAG(x) x##_wgpt0t1f
#include "tdfx_vbtmp.h"
/* fogc } */


static void init_setup_tab( void )
{
   init_wg();
   init_wg_fog();
   init_wgt0();
   init_wgt0t1();
   init_wgpt0();
   init_wgpt0t1();

   init_g();
   init_t0();
   init_t0t1();
   init_gt0();
   init_gt0t1();

   /* fogcoord */
   init_wgf();
   init_wgt0f();
   init_wgt0t1f();
   init_wgpt0f();
   init_wgpt0t1f();
}


void tdfxPrintSetupFlags(char *msg, GLuint flags )
{
   fprintf(stderr, "%s(%x): %s%s%s%s%s%s\n",
	   msg,
	   (int)flags,
	   (flags & TDFX_XYZ_BIT)     ? " xyz," : "", 
	   (flags & TDFX_W_BIT)     ? " w," : "", 
	   (flags & TDFX_RGBA_BIT)     ? " rgba," : "",
	   (flags & TDFX_TEX0_BIT)     ? " tex-0," : "",
	   (flags & TDFX_TEX1_BIT)     ? " tex-1," : "",
	   (flags & TDFX_FOGC_BIT)     ? " fogc," : "");
}



void tdfxCheckTexSizes( struct gl_context *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   tdfxContextPtr fxMesa = TDFX_CONTEXT( ctx );

   if (!setup_tab[fxMesa->SetupIndex].check_tex_sizes(ctx)) {
      GLuint ind = fxMesa->SetupIndex |= (TDFX_PTEX_BIT|TDFX_RGBA_BIT);

      /* Tdfx handles projective textures nicely; just have to change
       * up to the new vertex format.
       */
      if (setup_tab[ind].vertex_format != fxMesa->vertexFormat) {
	 FLUSH_BATCH(fxMesa);
	 fxMesa->dirty |= TDFX_UPLOAD_VERTEX_LAYOUT;      
	 fxMesa->vertexFormat = setup_tab[ind].vertex_format;

	 /* This is required as we have just changed the vertex
	  * format, so the interp and copy routines must also change.
	  * In the unfilled and twosided cases we are using the
	  * swrast_setup ones anyway, so leave them in place.
	  */
	 if (!(ctx->_TriangleCaps & (DD_TRI_LIGHT_TWOSIDE|DD_TRI_UNFILLED))) {
	    tnl->Driver.Render.Interp = setup_tab[fxMesa->SetupIndex].interp;
	    tnl->Driver.Render.CopyPV = setup_tab[fxMesa->SetupIndex].copy_pv;
	 }
      }
   }
}


void tdfxBuildVertices( struct gl_context *ctx, GLuint start, GLuint end,
			GLuint newinputs )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT( ctx );
   tdfxVertex *v = fxMesa->verts + start;

   newinputs |= fxMesa->SetupNewInputs;
   fxMesa->SetupNewInputs = 0;

   if (!newinputs)
      return;

   if (newinputs & VERT_BIT_POS) {
      setup_tab[fxMesa->SetupIndex].emit( ctx, start, end, v );
   } else {
      GLuint ind = 0;

      if (newinputs & VERT_BIT_COLOR0)
	 ind |= TDFX_RGBA_BIT;

      if (newinputs & VERT_BIT_FOG)
	 ind |= TDFX_FOGC_BIT;
      
      if (newinputs & VERT_BIT_TEX0)
	 ind |= TDFX_TEX0_BIT;

      if (newinputs & VERT_BIT_TEX1)
	 ind |= TDFX_TEX0_BIT|TDFX_TEX1_BIT;

      if (fxMesa->SetupIndex & TDFX_PTEX_BIT)
	 ind = ~0;

      ind &= fxMesa->SetupIndex;

      if (ind) {
	 setup_tab[ind].emit( ctx, start, end, v );
      }
   }
}


void tdfxChooseVertexState( struct gl_context *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   tdfxContextPtr fxMesa = TDFX_CONTEXT( ctx );
   GLuint ind = TDFX_XYZ_BIT|TDFX_RGBA_BIT;

   fxMesa->tmu_source[0] = 0;
   fxMesa->tmu_source[1] = 1;

   if (ctx->Texture._EnabledUnits & 0x2) {
      if (ctx->Texture._EnabledUnits & 0x1) {
         ind |= TDFX_TEX1_BIT;
      }
      ind |= TDFX_W_BIT|TDFX_TEX0_BIT;
      fxMesa->tmu_source[0] = 1;
      fxMesa->tmu_source[1] = 0;
   } else if (ctx->Texture._EnabledUnits & 0x1) {
      /* unit 0 enabled */
      ind |= TDFX_W_BIT|TDFX_TEX0_BIT;
   } else if (fxMesa->Fog.Mode != GR_FOG_DISABLE) {
      ind |= TDFX_W_BIT;
   }

   if (fxMesa->Fog.Mode == GR_FOG_WITH_TABLE_ON_FOGCOORD_EXT) {
      ind |= TDFX_FOGC_BIT;
   }

   fxMesa->SetupIndex = ind;

   if (ctx->_TriangleCaps & (DD_TRI_LIGHT_TWOSIDE|DD_TRI_UNFILLED)) {
      tnl->Driver.Render.Interp = interp_extras;
      tnl->Driver.Render.CopyPV = copy_pv_extras;
   } else {
      tnl->Driver.Render.Interp = setup_tab[ind].interp;
      tnl->Driver.Render.CopyPV = setup_tab[ind].copy_pv;
   }

   if (setup_tab[ind].vertex_format != fxMesa->vertexFormat) {
      FLUSH_BATCH(fxMesa);
      fxMesa->dirty |= TDFX_UPLOAD_VERTEX_LAYOUT;      
      fxMesa->vertexFormat = setup_tab[ind].vertex_format;
   }
}



void tdfxInitVB( struct gl_context *ctx )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint size = TNL_CONTEXT(ctx)->vb.Size;
   static int firsttime = 1;
   if (firsttime) {
      init_setup_tab();
      firsttime = 0;
   }

   fxMesa->verts = _mesa_align_malloc(size * sizeof(tdfxVertex), 32);
   fxMesa->vertexFormat = TDFX_LAYOUT_TINY;
   fxMesa->SetupIndex = TDFX_XYZ_BIT|TDFX_RGBA_BIT;
}


void tdfxFreeVB( struct gl_context *ctx )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   if (fxMesa->verts) {
      _mesa_align_free(fxMesa->verts);
      fxMesa->verts = 0;
   }
}
@


1.4
log
@Merge Mesa 7.10.3
@
text
@@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d36 1
a36 1
static void copy_pv( GLcontext *ctx, GLuint edst, GLuint esrc )
d45 1
a45 1
   void                (*emit)( GLcontext *, GLuint, GLuint, void * );
d48 1
a48 1
   GLboolean           (*check_tex_sizes)( GLcontext *ctx );
d58 1
a58 1
static void interp_extras( GLcontext *ctx,
d82 1
a82 1
static void copy_pv_extras( GLcontext *ctx, GLuint dst, GLuint src )
d207 1
a207 1
void tdfxCheckTexSizes( GLcontext *ctx )
d237 1
a237 1
void tdfxBuildVertices( GLcontext *ctx, GLuint start, GLuint end,
d278 1
a278 1
void tdfxChooseVertexState( GLcontext *ctx )
d324 1
a324 1
void tdfxInitVB( GLcontext *ctx )
d340 1
a340 1
void tdfxFreeVB( GLcontext *ctx )
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a31 3
#include "math/m_translate.h"
#include "swrast_setup/swrast_setup.h"

a33 2
#include "tdfx_tris.h"
#include "tdfx_state.h"
d67 1
a67 1
   if (VB->ColorPtr[1]) {
d69 3
a71 3
		    GET_COLOR(VB->ColorPtr[1], dst),
		    GET_COLOR(VB->ColorPtr[1], out),
		    GET_COLOR(VB->ColorPtr[1], in) );
d86 3
a88 3
   if (VB->ColorPtr[1]) {
	 COPY_4FV( GET_COLOR(VB->ColorPtr[1], dst), 
		     GET_COLOR(VB->ColorPtr[1], src) );
d334 1
a334 1
   fxMesa->verts = ALIGN_MALLOC(size * sizeof(tdfxVertex), 32);
d344 1
a344 1
      ALIGN_FREE(fxMesa->verts);
@


1.1
log
@Initial revision
@
text
@a24 1
/* $XFree86: xc/lib/GL/mesa/src/drv/tdfx/tdfx_vb.c,v 1.3 2002/10/30 12:52:01 alanh Exp $ */
d26 5
a30 5
#include "glheader.h"
#include "mtypes.h"
#include "imports.h"
#include "macros.h"
#include "colormac.h"
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d25 1
d27 8
a34 5
#include "main/glheader.h"
#include "main/mtypes.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/colormac.h"
d38 2
d42 1
a42 1
static void copy_pv( struct gl_context *ctx, GLuint edst, GLuint esrc )
d51 1
a51 1
   void                (*emit)( struct gl_context *, GLuint, GLuint, void * );
d54 1
a54 1
   GLboolean           (*check_tex_sizes)( struct gl_context *ctx );
d64 1
a64 1
static void interp_extras( struct gl_context *ctx,
d73 1
a73 1
   if (VB->BackfaceColorPtr) {
d75 3
a77 3
		 GET_COLOR(VB->BackfaceColorPtr, dst),
		 GET_COLOR(VB->BackfaceColorPtr, out),
		 GET_COLOR(VB->BackfaceColorPtr, in) );
d88 1
a88 1
static void copy_pv_extras( struct gl_context *ctx, GLuint dst, GLuint src )
d92 3
a94 3
   if (VB->BackfaceColorPtr) {
      COPY_4FV( GET_COLOR(VB->BackfaceColorPtr, dst),
		GET_COLOR(VB->BackfaceColorPtr, src) );
d213 1
a213 1
void tdfxCheckTexSizes( struct gl_context *ctx )
d243 1
a243 1
void tdfxBuildVertices( struct gl_context *ctx, GLuint start, GLuint end,
d284 1
a284 1
void tdfxChooseVertexState( struct gl_context *ctx )
d330 1
a330 1
void tdfxInitVB( struct gl_context *ctx )
d340 1
a340 1
   fxMesa->verts = _mesa_align_malloc(size * sizeof(tdfxVertex), 32);
d346 1
a346 1
void tdfxFreeVB( struct gl_context *ctx )
d350 1
a350 1
      _mesa_align_free(fxMesa->verts);
@

