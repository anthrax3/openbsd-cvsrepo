head	1.17;
access;
symbols
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.13.0.2
	OPENBSD_5_6_BASE:1.13
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.12.0.2
	OPENBSD_5_5_BASE:1.12
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.11.0.4
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.10.0.4
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.9.0.6
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.6.0.4
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.2
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.16;
commitid	TnlogFl9nOv2eaRf;

1.16
date	2015.02.22.09.30.34;	author jsg;	state Exp;
branches;
next	1.15;
commitid	yhStanAcs6cSYmBc;

1.15
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.14;
commitid	4ry2gvZGMXkCUD2n;

1.14
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.13;
commitid	mcxB0JvoI9gTDYXU;

1.13
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.12;
commitid	WPD6rgPryPkvXOr9;

1.12
date	2013.09.05.14.05.33;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.10;

1.10
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.24.19.03.21;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.26.22.55.53;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2010.05.22.20.06.25;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.10.14.59.52;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.14.58.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.53.38;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.53.38;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.30;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.29.33;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.42;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.06;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.56;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.12.13;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.49.20;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.17
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************

Copyright 2000, 2001 ATI Technologies Inc., Ontario, Canada, and
                     VA Linux Systems Inc., Fremont, California.

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial
portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/**
 * \file radeon_screen.c
 * Screen initialization functions for the Radeon driver.
 *
 * \author Kevin E. Martin <martin@@valinux.com>
 * \author  Gareth Hughes <gareth@@valinux.com>
 */

#include <errno.h>
#include "main/glheader.h"
#include "main/imports.h"
#include "main/mtypes.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
#include "main/fbobject.h"
#include "swrast/s_renderbuffer.h"

#include "radeon_chipset.h"
#include "radeon_macros.h"
#include "radeon_screen.h"
#include "radeon_common.h"
#include "radeon_common_context.h"
#if defined(RADEON_R100)
#include "radeon_context.h"
#include "radeon_tex.h"
#elif defined(RADEON_R200)
#include "r200_context.h"
#include "r200_tex.h"
#endif

#include "utils.h"

#include "GL/internal/dri_interface.h"

/* Radeon configuration
 */
#include "xmlpool.h"

#define DRI_CONF_COMMAND_BUFFER_SIZE(def,min,max) \
DRI_CONF_OPT_BEGIN_V(command_buffer_size,int,def, # min ":" # max ) \
        DRI_CONF_DESC(en,"Size of command buffer (in KB)") \
        DRI_CONF_DESC(de,"GrÃ¶sse des Befehlspuffers (in KB)") \
DRI_CONF_OPT_END

#if defined(RADEON_R100)	/* R100 */
static const __DRIconfigOptionsExtension radeon_config_options = {
   .base = { __DRI_CONFIG_OPTIONS, 1 },
   .xml =
DRI_CONF_BEGIN
    DRI_CONF_SECTION_PERFORMANCE
        DRI_CONF_TCL_MODE(DRI_CONF_TCL_CODEGEN)
        DRI_CONF_FTHROTTLE_MODE(DRI_CONF_FTHROTTLE_IRQS)
        DRI_CONF_VBLANK_MODE(DRI_CONF_VBLANK_DEF_INTERVAL_0)
        DRI_CONF_MAX_TEXTURE_UNITS(3,2,3)
        DRI_CONF_HYPERZ("false")
        DRI_CONF_COMMAND_BUFFER_SIZE(8, 8, 32)
    DRI_CONF_SECTION_END
    DRI_CONF_SECTION_QUALITY
        DRI_CONF_TEXTURE_DEPTH(DRI_CONF_TEXTURE_DEPTH_FB)
        DRI_CONF_DEF_MAX_ANISOTROPY(1.0,"1.0,2.0,4.0,8.0,16.0")
        DRI_CONF_NO_NEG_LOD_BIAS("false")
        DRI_CONF_FORCE_S3TC_ENABLE("false")
        DRI_CONF_COLOR_REDUCTION(DRI_CONF_COLOR_REDUCTION_DITHER)
        DRI_CONF_ROUND_MODE(DRI_CONF_ROUND_TRUNC)
        DRI_CONF_DITHER_MODE(DRI_CONF_DITHER_XERRORDIFF)
    DRI_CONF_SECTION_END
    DRI_CONF_SECTION_DEBUG
        DRI_CONF_NO_RAST("false")
    DRI_CONF_SECTION_END
DRI_CONF_END
};

#elif defined(RADEON_R200)
static const __DRIconfigOptionsExtension radeon_config_options = {
   .base = { __DRI_CONFIG_OPTIONS, 1 },
   .xml =
DRI_CONF_BEGIN
    DRI_CONF_SECTION_PERFORMANCE
        DRI_CONF_TCL_MODE(DRI_CONF_TCL_CODEGEN)
        DRI_CONF_FTHROTTLE_MODE(DRI_CONF_FTHROTTLE_IRQS)
        DRI_CONF_VBLANK_MODE(DRI_CONF_VBLANK_DEF_INTERVAL_0)
        DRI_CONF_MAX_TEXTURE_UNITS(6,2,6)
        DRI_CONF_HYPERZ("false")
        DRI_CONF_COMMAND_BUFFER_SIZE(8, 8, 32)
    DRI_CONF_SECTION_END
    DRI_CONF_SECTION_QUALITY
        DRI_CONF_TEXTURE_DEPTH(DRI_CONF_TEXTURE_DEPTH_FB)
        DRI_CONF_DEF_MAX_ANISOTROPY(1.0,"1.0,2.0,4.0,8.0,16.0")
        DRI_CONF_NO_NEG_LOD_BIAS("false")
        DRI_CONF_FORCE_S3TC_ENABLE("false")
        DRI_CONF_COLOR_REDUCTION(DRI_CONF_COLOR_REDUCTION_DITHER)
        DRI_CONF_ROUND_MODE(DRI_CONF_ROUND_TRUNC)
        DRI_CONF_DITHER_MODE(DRI_CONF_DITHER_XERRORDIFF)
        DRI_CONF_TEXTURE_BLEND_QUALITY(1.0,"0.0:1.0")
    DRI_CONF_SECTION_END
    DRI_CONF_SECTION_DEBUG
        DRI_CONF_NO_RAST("false")
    DRI_CONF_SECTION_END
DRI_CONF_END
};
#endif

#ifndef RADEON_INFO_TILE_CONFIG
#define RADEON_INFO_TILE_CONFIG 0x6
#endif

static int
radeonGetParam(__DRIscreen *sPriv, int param, void *value)
{
  int ret;
  drm_radeon_getparam_t gp = { 0 };
  struct drm_radeon_info info = { 0 };

  if (sPriv->drm_version.major >= 2) {
      info.value = (uint64_t)(uintptr_t)value;
      switch (param) {
      case RADEON_PARAM_DEVICE_ID:
          info.request = RADEON_INFO_DEVICE_ID;
          break;
      case RADEON_PARAM_NUM_GB_PIPES:
          info.request = RADEON_INFO_NUM_GB_PIPES;
          break;
      case RADEON_PARAM_NUM_Z_PIPES:
          info.request = RADEON_INFO_NUM_Z_PIPES;
          break;
      case RADEON_INFO_TILE_CONFIG:
	  info.request = RADEON_INFO_TILE_CONFIG;
          break;
      default:
          return -EINVAL;
      }
      ret = drmCommandWriteRead(sPriv->fd, DRM_RADEON_INFO, &info, sizeof(info));
  } else {
      gp.param = param;
      gp.value = value;

      ret = drmCommandWriteRead(sPriv->fd, DRM_RADEON_GETPARAM, &gp, sizeof(gp));
  }
  return ret;
}

#if defined(RADEON_R100)
static const __DRItexBufferExtension radeonTexBufferExtension = {
   .base = { __DRI_TEX_BUFFER, 3 },

   .setTexBuffer        = radeonSetTexBuffer,
   .setTexBuffer2       = radeonSetTexBuffer2,
   .releaseTexBuffer    = NULL,
};
#elif defined(RADEON_R200)
static const __DRItexBufferExtension r200TexBufferExtension = {
   .base = { __DRI_TEX_BUFFER, 3 },

   .setTexBuffer        = r200SetTexBuffer,
   .setTexBuffer2       = r200SetTexBuffer2,
   .releaseTexBuffer    = NULL,
};
#endif

static void
radeonDRI2Flush(__DRIdrawable *drawable)
{
    radeonContextPtr rmesa;

    rmesa = (radeonContextPtr) drawable->driContextPriv->driverPrivate;
    radeonFlush(&rmesa->glCtx);
}

static const struct __DRI2flushExtensionRec radeonFlushExtension = {
   .base = { __DRI2_FLUSH, 3 },

   .flush               = radeonDRI2Flush,
   .invalidate          = dri2InvalidateDrawable,
};

static __DRIimage *
radeon_create_image_from_name(__DRIscreen *screen,
                              int width, int height, int format,
                              int name, int pitch, void *loaderPrivate)
{
   __DRIimage *image;
   radeonScreenPtr radeonScreen = screen->driverPrivate;

   if (name == 0)
      return NULL;

   image = calloc(1, sizeof *image);
   if (image == NULL)
      return NULL;

   switch (format) {
   case __DRI_IMAGE_FORMAT_RGB565:
      image->format = MESA_FORMAT_B5G6R5_UNORM;
      image->internal_format = GL_RGB;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   case __DRI_IMAGE_FORMAT_XRGB8888:
      image->format = MESA_FORMAT_B8G8R8X8_UNORM;
      image->internal_format = GL_RGB;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   case __DRI_IMAGE_FORMAT_ARGB8888:
      image->format = MESA_FORMAT_B8G8R8A8_UNORM;
      image->internal_format = GL_RGBA;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   default:
      free(image);
      return NULL;
   }

   image->data = loaderPrivate;
   image->cpp = _mesa_get_format_bytes(image->format);
   image->width = width;
   image->pitch = pitch;
   image->height = height;

   image->bo = radeon_bo_open(radeonScreen->bom,
                              (uint32_t)name,
                              image->pitch * image->height * image->cpp,
                              0,
                              RADEON_GEM_DOMAIN_VRAM,
                              0);

   if (image->bo == NULL) {
      free(image);
      return NULL;
   }

   return image;
}

static __DRIimage *
radeon_create_image_from_renderbuffer(__DRIcontext *context,
                                      int renderbuffer, void *loaderPrivate)
{
   __DRIimage *image;
   radeonContextPtr radeon = context->driverPrivate;
   struct gl_renderbuffer *rb;
   struct radeon_renderbuffer *rrb;

   rb = _mesa_lookup_renderbuffer(&radeon->glCtx, renderbuffer);
   if (!rb) {
      _mesa_error(&radeon->glCtx,
                  GL_INVALID_OPERATION, "glRenderbufferExternalMESA");
      return NULL;
   }

   rrb = radeon_renderbuffer(rb);
   image = calloc(1, sizeof *image);
   if (image == NULL)
      return NULL;

   image->internal_format = rb->InternalFormat;
   image->format = rb->Format;
   image->cpp = rrb->cpp;
   image->data_type = GL_UNSIGNED_BYTE;
   image->data = loaderPrivate;
   radeon_bo_ref(rrb->bo);
   image->bo = rrb->bo;

   image->width = rb->Width;
   image->height = rb->Height;
   image->pitch = rrb->pitch / image->cpp;

   return image;
}

static void
radeon_destroy_image(__DRIimage *image)
{
   radeon_bo_unref(image->bo);
   free(image);
}

static __DRIimage *
radeon_create_image(__DRIscreen *screen,
                    int width, int height, int format,
                    unsigned int use,
                    void *loaderPrivate)
{
   __DRIimage *image;
   radeonScreenPtr radeonScreen = screen->driverPrivate;

   image = calloc(1, sizeof *image);
   if (image == NULL)
      return NULL;

   image->dri_format = format;

   switch (format) {
   case __DRI_IMAGE_FORMAT_RGB565:
      image->format = MESA_FORMAT_B5G6R5_UNORM;
      image->internal_format = GL_RGB;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   case __DRI_IMAGE_FORMAT_XRGB8888:
      image->format = MESA_FORMAT_B8G8R8X8_UNORM;
      image->internal_format = GL_RGB;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   case __DRI_IMAGE_FORMAT_ARGB8888:
      image->format = MESA_FORMAT_B8G8R8A8_UNORM;
      image->internal_format = GL_RGBA;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   default:
      free(image);
      return NULL;
   }

   image->data = loaderPrivate;
   image->cpp = _mesa_get_format_bytes(image->format);
   image->width = width;
   image->height = height;
   image->pitch = ((image->cpp * image->width + 255) & ~255) / image->cpp;

   image->bo = radeon_bo_open(radeonScreen->bom,
                              0,
                              image->pitch * image->height * image->cpp,
                              0,
                              RADEON_GEM_DOMAIN_VRAM,
                              0);

   if (image->bo == NULL) {
      free(image);
      return NULL;
   }

   return image;
}

static GLboolean
radeon_query_image(__DRIimage *image, int attrib, int *value)
{
   switch (attrib) {
   case __DRI_IMAGE_ATTRIB_STRIDE:
      *value = image->pitch * image->cpp;
      return GL_TRUE;
   case __DRI_IMAGE_ATTRIB_HANDLE:
      *value = image->bo->handle;
      return GL_TRUE;
   case __DRI_IMAGE_ATTRIB_NAME:
      radeon_gem_get_kernel_name(image->bo, (uint32_t *) value);
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
}

static const __DRIimageExtension radeonImageExtension = {
   .base = { __DRI_IMAGE, 1 },

   .createImageFromName         = radeon_create_image_from_name,
   .createImageFromRenderbuffer = radeon_create_image_from_renderbuffer,
   .destroyImage                = radeon_destroy_image,
   .createImage                 = radeon_create_image,
   .queryImage                  = radeon_query_image
};

static int radeon_set_screen_flags(radeonScreenPtr screen, int device_id)
{
   screen->device_id = device_id;
   screen->chip_flags = 0;
   switch ( device_id ) {
#if defined(RADEON_R100)
   case PCI_CHIP_RN50_515E:
   case PCI_CHIP_RN50_5969:
	return -1;

   case PCI_CHIP_RADEON_LY:
   case PCI_CHIP_RADEON_LZ:
   case PCI_CHIP_RADEON_QY:
   case PCI_CHIP_RADEON_QZ:
      screen->chip_family = CHIP_FAMILY_RV100;
      break;

   case PCI_CHIP_RS100_4136:
   case PCI_CHIP_RS100_4336:
      screen->chip_family = CHIP_FAMILY_RS100;
      break;

   case PCI_CHIP_RS200_4137:
   case PCI_CHIP_RS200_4337:
   case PCI_CHIP_RS250_4237:
   case PCI_CHIP_RS250_4437:
      screen->chip_family = CHIP_FAMILY_RS200;
      break;

   case PCI_CHIP_RADEON_QD:
   case PCI_CHIP_RADEON_QE:
   case PCI_CHIP_RADEON_QF:
   case PCI_CHIP_RADEON_QG:
      /* all original radeons (7200) presumably have a stencil op bug */
      screen->chip_family = CHIP_FAMILY_R100;
      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_BROKEN_STENCIL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;
      break;

   case PCI_CHIP_RV200_QW:
   case PCI_CHIP_RV200_QX:
   case PCI_CHIP_RADEON_LW:
   case PCI_CHIP_RADEON_LX:
      screen->chip_family = CHIP_FAMILY_RV200;
      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;
      break;

#elif defined(RADEON_R200)
   case PCI_CHIP_R200_BB:
   case PCI_CHIP_R200_QH:
   case PCI_CHIP_R200_QL:
   case PCI_CHIP_R200_QM:
      screen->chip_family = CHIP_FAMILY_R200;
      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;
      break;

   case PCI_CHIP_RV250_If:
   case PCI_CHIP_RV250_Ig:
   case PCI_CHIP_RV250_Ld:
   case PCI_CHIP_RV250_Lf:
   case PCI_CHIP_RV250_Lg:
      screen->chip_family = CHIP_FAMILY_RV250;
      screen->chip_flags = R200_CHIPSET_YCBCR_BROKEN | RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;
      break;

   case PCI_CHIP_RV280_4C6E:
   case PCI_CHIP_RV280_5960:
   case PCI_CHIP_RV280_5961:
   case PCI_CHIP_RV280_5962:
   case PCI_CHIP_RV280_5964:
   case PCI_CHIP_RV280_5965:
   case PCI_CHIP_RV280_5C61:
   case PCI_CHIP_RV280_5C63:
      screen->chip_family = CHIP_FAMILY_RV280;
      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;
      break;

   case PCI_CHIP_RS300_5834:
   case PCI_CHIP_RS300_5835:
   case PCI_CHIP_RS350_7834:
   case PCI_CHIP_RS350_7835:
      screen->chip_family = CHIP_FAMILY_RS300;
      screen->chip_flags = RADEON_CHIPSET_DEPTH_ALWAYS_TILED;
      break;
#endif

   default:
      fprintf(stderr, "unknown chip id 0x%x, can't guess.\n",
	      device_id);
      return -1;
   }

   return 0;
}

static int
radeonQueryRendererInteger(__DRIscreen *psp, int param,
			       unsigned int *value)
{
   radeonScreenPtr screen = (radeonScreenPtr)psp->driverPrivate;

   switch (param) {
   case __DRI2_RENDERER_VENDOR_ID:
      value[0] = 0x1002;
      return 0;
   case __DRI2_RENDERER_DEVICE_ID:
      value[0] = screen->device_id;
      return 0;
   case __DRI2_RENDERER_ACCELERATED:
      value[0] = 1;
      return 0;
   case __DRI2_RENDERER_VIDEO_MEMORY: {
      struct drm_radeon_gem_info gem_info;
      int retval;
      memset(&gem_info, 0, sizeof(gem_info));

      /* Get GEM info. */
      retval = drmCommandWriteRead(psp->fd, DRM_RADEON_GEM_INFO, &gem_info,
				   sizeof(gem_info));

      if (retval) {
         fprintf(stderr, "radeon: Failed to get MM info, error number %d\n",
                retval);
         return -1;

      }
      /* XXX: Do we want to return vram_size or vram_visible ? */
      value[0] = gem_info.vram_size >> 20;
      return 0;
   }
   case __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE:
      value[0] = 0;
      return 0;
   default:
      return driQueryRendererIntegerCommon(psp, param, value);
   }
}

static int
radeonQueryRendererString(__DRIscreen *psp, int param, const char **value)
{
   radeonScreenPtr screen = (radeonScreenPtr)psp->driverPrivate;

   switch (param) {
   case __DRI2_RENDERER_VENDOR_ID:
      value[0] = radeonVendorString;
      return 0;
   case __DRI2_RENDERER_DEVICE_ID:
      value[0] = radeonGetRendererString(screen);
      return 0;
   default:
      return -1;
   }
}

static const __DRI2rendererQueryExtension radeonRendererQueryExtension = {
   .base = { __DRI2_RENDERER_QUERY, 1 },

   .queryInteger        = radeonQueryRendererInteger,
   .queryString         = radeonQueryRendererString
};


static const __DRIextension *radeon_screen_extensions[] = {
    &dri2ConfigQueryExtension.base,
#if defined(RADEON_R100)
    &radeonTexBufferExtension.base,
#elif defined(RADEON_R200)
    &r200TexBufferExtension.base,
#endif
    &radeonFlushExtension.base,
    &radeonImageExtension.base,
    &radeonRendererQueryExtension.base,
    NULL
};

static radeonScreenPtr
radeonCreateScreen2(__DRIscreen *sPriv)
{
   radeonScreenPtr screen;
   int ret;
   uint32_t device_id = 0;

   /* Allocate the private area */
   screen = calloc(1, sizeof(*screen));
   if ( !screen ) {
      fprintf(stderr, "%s: Could not allocate memory for screen structure", __FUNCTION__);
      fprintf(stderr, "leaving here\n");
      return NULL;
   }

   radeon_init_debug();

   /* parse information in __driConfigOptions */
   driParseOptionInfo (&screen->optionCache, radeon_config_options.xml);

   screen->chip_flags = 0;

   screen->irq = 1;

   ret = radeonGetParam(sPriv, RADEON_PARAM_DEVICE_ID, &device_id);
   if (ret) {
     free( screen );
     fprintf(stderr, "drm_radeon_getparam_t (RADEON_PARAM_DEVICE_ID): %d\n", ret);
     return NULL;
   }

   ret = radeon_set_screen_flags(screen, device_id);
   if (ret == -1) {
     free(screen);
     return NULL;
   }

   if (getenv("RADEON_NO_TCL"))
	   screen->chip_flags &= ~RADEON_CHIPSET_TCL;

   sPriv->extensions = radeon_screen_extensions;

   screen->driScreen = sPriv;
   screen->bom = radeon_bo_manager_gem_ctor(sPriv->fd);
   if (screen->bom == NULL) {
       free(screen);
       return NULL;
   }
   return screen;
}

/* Destroy the device specific screen private data struct.
 */
static void
radeonDestroyScreen( __DRIscreen *sPriv )
{
    radeonScreenPtr screen = (radeonScreenPtr)sPriv->driverPrivate;

    if (!screen)
        return;

#ifdef RADEON_BO_TRACK
    radeon_tracker_print(&screen->bom->tracker, stderr);
#endif
    radeon_bo_manager_gem_dtor(screen->bom);

    /* free all option information */
    driDestroyOptionInfo (&screen->optionCache);

    free( screen );
    sPriv->driverPrivate = NULL;
}


/* Initialize the driver specific screen private data.
 */
static GLboolean
radeonInitDriver( __DRIscreen *sPriv )
{
    sPriv->driverPrivate = (void *) radeonCreateScreen2( sPriv );
    if ( !sPriv->driverPrivate ) {
        radeonDestroyScreen( sPriv );
        return GL_FALSE;
    }

    return GL_TRUE;
}



/**
 * Create the Mesa framebuffer and renderbuffers for a given window/drawable.
 *
 * \todo This function (and its interface) will need to be updated to support
 * pbuffers.
 */
static GLboolean
radeonCreateBuffer( __DRIscreen *driScrnPriv,
                    __DRIdrawable *driDrawPriv,
                    const struct gl_config *mesaVis,
                    GLboolean isPixmap )
{
    radeonScreenPtr screen = (radeonScreenPtr) driScrnPriv->driverPrivate;

    const GLboolean swDepth = GL_FALSE;
    const GLboolean swAlpha = GL_FALSE;
    const GLboolean swAccum = mesaVis->accumRedBits > 0;
    const GLboolean swStencil = mesaVis->stencilBits > 0 &&
	mesaVis->depthBits != 24;
    mesa_format rgbFormat;
    struct radeon_framebuffer *rfb;

    if (isPixmap)
      return GL_FALSE; /* not implemented */

    rfb = CALLOC_STRUCT(radeon_framebuffer);
    if (!rfb)
      return GL_FALSE;

    _mesa_initialize_window_framebuffer(&rfb->base, mesaVis);

    if (mesaVis->redBits == 5)
        rgbFormat = _mesa_little_endian() ? MESA_FORMAT_B5G6R5_UNORM : MESA_FORMAT_R5G6B5_UNORM;
    else if (mesaVis->alphaBits == 0)
        rgbFormat = _mesa_little_endian() ? MESA_FORMAT_B8G8R8X8_UNORM : MESA_FORMAT_X8R8G8B8_UNORM;
    else
        rgbFormat = _mesa_little_endian() ? MESA_FORMAT_B8G8R8A8_UNORM : MESA_FORMAT_A8R8G8B8_UNORM;

    /* front color renderbuffer */
    rfb->color_rb[0] = radeon_create_renderbuffer(rgbFormat, driDrawPriv);
    _mesa_add_renderbuffer(&rfb->base, BUFFER_FRONT_LEFT, &rfb->color_rb[0]->base.Base);
    rfb->color_rb[0]->has_surface = 1;

    /* back color renderbuffer */
    if (mesaVis->doubleBufferMode) {
      rfb->color_rb[1] = radeon_create_renderbuffer(rgbFormat, driDrawPriv);
	_mesa_add_renderbuffer(&rfb->base, BUFFER_BACK_LEFT, &rfb->color_rb[1]->base.Base);
	rfb->color_rb[1]->has_surface = 1;
    }

    if (mesaVis->depthBits == 24) {
      if (mesaVis->stencilBits == 8) {
	struct radeon_renderbuffer *depthStencilRb =
           radeon_create_renderbuffer(MESA_FORMAT_Z24_UNORM_S8_UINT, driDrawPriv);
	_mesa_add_renderbuffer(&rfb->base, BUFFER_DEPTH, &depthStencilRb->base.Base);
	_mesa_add_renderbuffer(&rfb->base, BUFFER_STENCIL, &depthStencilRb->base.Base);
	depthStencilRb->has_surface = screen->depthHasSurface;
      } else {
	/* depth renderbuffer */
	struct radeon_renderbuffer *depth =
           radeon_create_renderbuffer(MESA_FORMAT_Z24_UNORM_X8_UINT, driDrawPriv);
	_mesa_add_renderbuffer(&rfb->base, BUFFER_DEPTH, &depth->base.Base);
	depth->has_surface = screen->depthHasSurface;
      }
    } else if (mesaVis->depthBits == 16) {
        /* just 16-bit depth buffer, no hw stencil */
	struct radeon_renderbuffer *depth =
           radeon_create_renderbuffer(MESA_FORMAT_Z_UNORM16, driDrawPriv);
	_mesa_add_renderbuffer(&rfb->base, BUFFER_DEPTH, &depth->base.Base);
	depth->has_surface = screen->depthHasSurface;
    }

    _swrast_add_soft_renderbuffers(&rfb->base,
	    GL_FALSE, /* color */
	    swDepth,
	    swStencil,
	    swAccum,
	    swAlpha,
	    GL_FALSE /* aux */);
    driDrawPriv->driverPrivate = (void *) rfb;

    return (driDrawPriv->driverPrivate != NULL);
}


static void radeon_cleanup_renderbuffers(struct radeon_framebuffer *rfb)
{
	struct radeon_renderbuffer *rb;

	rb = rfb->color_rb[0];
	if (rb && rb->bo) {
		radeon_bo_unref(rb->bo);
		rb->bo = NULL;
	}
	rb = rfb->color_rb[1];
	if (rb && rb->bo) {
		radeon_bo_unref(rb->bo);
		rb->bo = NULL;
	}
	rb = radeon_get_renderbuffer(&rfb->base, BUFFER_DEPTH);
	if (rb && rb->bo) {
		radeon_bo_unref(rb->bo);
		rb->bo = NULL;
	}
}

void
radeonDestroyBuffer(__DRIdrawable *driDrawPriv)
{
    struct radeon_framebuffer *rfb;
    if (!driDrawPriv)
	return;

    rfb = (void*)driDrawPriv->driverPrivate;
    if (!rfb)
	return;
    radeon_cleanup_renderbuffers(rfb);
    _mesa_reference_framebuffer((struct gl_framebuffer **)(&(driDrawPriv->driverPrivate)), NULL);
}

/**
 * This is the driver specific part of the createNewScreen entry point.
 * Called when using DRI2.
 *
 * \return the struct gl_config supported by this driver
 */
static const
__DRIconfig **radeonInitScreen2(__DRIscreen *psp)
{
   static const mesa_format formats[3] = {
      MESA_FORMAT_B5G6R5_UNORM,
      MESA_FORMAT_B8G8R8X8_UNORM,
      MESA_FORMAT_B8G8R8A8_UNORM
   };
   /* GLX_SWAP_COPY_OML is only supported because the Intel driver doesn't
    * support pageflipping at all.
    */
   static const GLenum back_buffer_modes[] = {
     GLX_NONE, GLX_SWAP_UNDEFINED_OML, /*, GLX_SWAP_COPY_OML*/
   };
   uint8_t depth_bits[4], stencil_bits[4], msaa_samples_array[1];
   int color;
   __DRIconfig **configs = NULL;

   psp->max_gl_compat_version = 13;
   psp->max_gl_es1_version = 11;

   if (!radeonInitDriver(psp)) {
       return NULL;
    }
   depth_bits[0] = 0;
   stencil_bits[0] = 0;
   depth_bits[1] = 16;
   stencil_bits[1] = 0;
   depth_bits[2] = 24;
   stencil_bits[2] = 0;
   depth_bits[3] = 24;
   stencil_bits[3] = 8;

   msaa_samples_array[0] = 0;

   for (color = 0; color < ARRAY_SIZE(formats); color++) {
      __DRIconfig **new_configs;

      new_configs = driCreateConfigs(formats[color],
				     depth_bits,
				     stencil_bits,
				     ARRAY_SIZE(depth_bits),
				     back_buffer_modes,
				     ARRAY_SIZE(back_buffer_modes),
				     msaa_samples_array,
				     ARRAY_SIZE(msaa_samples_array),
				     GL_TRUE);
      configs = driConcatConfigs(configs, new_configs);
   }

   if (configs == NULL) {
      fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
              __LINE__);
      return NULL;
   }

   return (const __DRIconfig **)configs;
}

static const struct __DriverAPIRec radeon_driver_api = {
   .InitScreen      = radeonInitScreen2,
   .DestroyScreen   = radeonDestroyScreen,
#if defined(RADEON_R200)
   .CreateContext   = r200CreateContext,
   .DestroyContext  = r200DestroyContext,
#else
   .CreateContext   = r100CreateContext,
   .DestroyContext  = radeonDestroyContext,
#endif
   .CreateBuffer    = radeonCreateBuffer,
   .DestroyBuffer   = radeonDestroyBuffer,
   .MakeCurrent     = radeonMakeCurrent,
   .UnbindContext   = radeonUnbindContext,
};

static const struct __DRIDriverVtableExtensionRec radeon_vtable = {
   .base = { __DRI_DRIVER_VTABLE, 1 },
   .vtable = &radeon_driver_api,
};

/* This is the table of extensions that the loader will dlsym() for. */
static const __DRIextension *radeon_driver_extensions[] = {
    &driCoreExtension.base,
    &driDRI2Extension.base,
    &radeon_config_options.base,
    &radeon_vtable.base,
    NULL
};

#ifdef RADEON_R200
PUBLIC const __DRIextension **__driDriverGetExtensions_r200(void)
{
   globalDriverAPI = &radeon_driver_api;

   return radeon_driver_extensions;
}
#else
PUBLIC const __DRIextension **__driDriverGetExtensions_radeon(void)
{
   globalDriverAPI = &radeon_driver_api;

   return radeon_driver_extensions;
}
#endif
@


1.16
log
@Backport support for GLX_MESA_query_renderer for non Intel drivers.
This is desirable as the chromium port now uses this extension to
obtain pci vendor/device ids for use in feature/extension blacklists.

Prompted by a mail from byrnet@@, tested on r600g by krw@@

The newly added os_get_total_physical_memory() was passing the length of
a pointer rather than the type which made the sysctl call fail on
non 64 bit archs.  And it was passing the wrong pointer for the result.
Fixes for these problems have been submitted back upstream.
@
text
@@


1.15
log
@Merge Mesa 10.2.9
@
text
@d484 67
d561 1
@


1.14
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d48 1
a483 67
static int
radeonQueryRendererInteger(__DRIscreen *psp, int param,
			       unsigned int *value)
{
   radeonScreenPtr screen = (radeonScreenPtr)psp->driverPrivate;

   switch (param) {
   case __DRI2_RENDERER_VENDOR_ID:
      value[0] = 0x1002;
      return 0;
   case __DRI2_RENDERER_DEVICE_ID:
      value[0] = screen->device_id;
      return 0;
   case __DRI2_RENDERER_ACCELERATED:
      value[0] = 1;
      return 0;
   case __DRI2_RENDERER_VIDEO_MEMORY: {
      struct drm_radeon_gem_info gem_info;
      int retval;
      memset(&gem_info, 0, sizeof(gem_info));

      /* Get GEM info. */
      retval = drmCommandWriteRead(psp->fd, DRM_RADEON_GEM_INFO, &gem_info,
				   sizeof(gem_info));

      if (retval) {
         fprintf(stderr, "radeon: Failed to get MM info, error number %d\n",
                retval);
         return -1;

      }
      /* XXX: Do we want to return vram_size or vram_visible ? */
      value[0] = gem_info.vram_size >> 20;
      return 0;
   }
   case __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE:
      value[0] = 0;
      return 0;
   default:
      return driQueryRendererIntegerCommon(psp, param, value);
   }
}

static int
radeonQueryRendererString(__DRIscreen *psp, int param, const char **value)
{
   radeonScreenPtr screen = (radeonScreenPtr)psp->driverPrivate;

   switch (param) {
   case __DRI2_RENDERER_VENDOR_ID:
      value[0] = radeonVendorString;
      return 0;
   case __DRI2_RENDERER_DEVICE_ID:
      value[0] = radeonGetRendererString(screen);
      return 0;
   default:
      return -1;
   }
}

static const __DRI2rendererQueryExtension radeonRendererQueryExtension = {
   .base = { __DRI2_RENDERER_QUERY, 1 },

   .queryInteger        = radeonQueryRendererInteger,
   .queryString         = radeonQueryRendererString
};

a493 1
    &radeonRendererQueryExtension.base,
@


1.13
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a47 1
#include "radeon_macros.h"
d483 67
d560 1
@


1.12
log
@Merge Mesa 9.2.0
@
text
@d75 3
a77 1
PUBLIC const char __driConfigOptions[] =
d99 2
a100 2
DRI_CONF_END;
static const GLuint __driNConfigOptions = 14;
d103 3
a105 2

PUBLIC const char __driConfigOptions[] =
d128 2
a129 3
DRI_CONF_END;
static const GLuint __driNConfigOptions = 15;

d173 5
a177 3
    { __DRI_TEX_BUFFER, __DRI_TEX_BUFFER_VERSION },
   radeonSetTexBuffer,
   radeonSetTexBuffer2,
d181 5
a185 3
    { __DRI_TEX_BUFFER, __DRI_TEX_BUFFER_VERSION },
   r200SetTexBuffer,
   r200SetTexBuffer2,
d199 4
a202 3
    { __DRI2_FLUSH, 3 },
    radeonDRI2Flush,
    dri2InvalidateDrawable,
d222 1
a222 1
      image->format = MESA_FORMAT_RGB565;
d227 1
a227 1
      image->format = MESA_FORMAT_XRGB8888;
d232 1
a232 1
      image->format = MESA_FORMAT_ARGB8888;
d322 1
a322 1
      image->format = MESA_FORMAT_RGB565;
d327 1
a327 1
      image->format = MESA_FORMAT_XRGB8888;
d332 1
a332 1
      image->format = MESA_FORMAT_ARGB8888;
d380 8
a387 7
static struct __DRIimageExtensionRec radeonImageExtension = {
    { __DRI_IMAGE, 1 },
   radeon_create_image_from_name,
   radeon_create_image_from_renderbuffer,
   radeon_destroy_image,
   radeon_create_image,
   radeon_query_image
d484 13
a500 1
   int i;
d515 1
a515 2
   driParseOptionInfo (&screen->optionCache,
		       __driConfigOptions, __driNConfigOptions);
d537 1
a537 14
   i = 0;
   screen->extensions[i++] = &dri2ConfigQueryExtension.base;

#if defined(RADEON_R100)
   screen->extensions[i++] = &radeonTexBufferExtension.base;
#elif defined(RADEON_R200)
   screen->extensions[i++] = &r200TexBufferExtension.base;
#endif

   screen->extensions[i++] = &radeonFlushExtension.base;
   screen->extensions[i++] = &radeonImageExtension.base;

   screen->extensions[i++] = NULL;
   sPriv->extensions = screen->extensions;
d606 1
a606 1
    gl_format rgbFormat;
d619 1
a619 1
        rgbFormat = _mesa_little_endian() ? MESA_FORMAT_RGB565 : MESA_FORMAT_RGB565_REV;
d621 1
a621 1
        rgbFormat = _mesa_little_endian() ? MESA_FORMAT_XRGB8888 : MESA_FORMAT_XRGB8888_REV;
d623 1
a623 1
        rgbFormat = _mesa_little_endian() ? MESA_FORMAT_ARGB8888 : MESA_FORMAT_ARGB8888_REV;
d640 1
a640 1
           radeon_create_renderbuffer(MESA_FORMAT_S8_Z24, driDrawPriv);
d647 1
a647 1
           radeon_create_renderbuffer(MESA_FORMAT_X8_Z24, driDrawPriv);
d654 1
a654 1
           radeon_create_renderbuffer(MESA_FORMAT_Z16, driDrawPriv);
d716 4
a719 4
   static const gl_format formats[3] = {
      MESA_FORMAT_RGB565,
      MESA_FORMAT_XRGB8888,
      MESA_FORMAT_ARGB8888
d731 3
d772 1
a772 1
const struct __DriverAPIRec driDriverAPI = {
d788 5
d794 1
a794 1
PUBLIC const __DRIextension *__driDriverExtensions[] = {
d797 2
d801 16
@


1.11
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d45 1
a46 1
#define STANDALONE_MMIO
a57 7
#elif defined(RADEON_R300)
#include "r300_context.h"
#include "r300_tex.h"
#elif defined(RADEON_R600)
#include "r600_context.h"
#include "r700_driconf.h" /* +r6/r7 */
#include "r600_tex.h"     /* +r6/r7 */
a60 3
#include "vblank.h"

#include "radeon_bocs_wrapper.h"
d82 1
a82 1
        DRI_CONF_HYPERZ(false)
d88 2
a89 2
        DRI_CONF_NO_NEG_LOD_BIAS(false)
        DRI_CONF_FORCE_S3TC_ENABLE(false)
a92 1
        DRI_CONF_ALLOW_LARGE_TEXTURES(2)
d95 1
a95 1
        DRI_CONF_NO_RAST(false)
d98 1
a98 1
static const GLuint __driNConfigOptions = 15;
d109 1
a109 1
        DRI_CONF_HYPERZ(false)
d115 2
a116 2
        DRI_CONF_NO_NEG_LOD_BIAS(false)
        DRI_CONF_FORCE_S3TC_ENABLE(false)
a119 1
        DRI_CONF_ALLOW_LARGE_TEXTURES(2)
d123 1
a123 4
        DRI_CONF_NO_RAST(false)
    DRI_CONF_SECTION_END
    DRI_CONF_SECTION_SOFTWARE
        DRI_CONF_NV_VERTEX_PROGRAM(false)
d126 1
a126 72
static const GLuint __driNConfigOptions = 17;

#elif defined(RADEON_R300) || defined(RADEON_R600)

#define DRI_CONF_FP_OPTIMIZATION_SPEED   0
#define DRI_CONF_FP_OPTIMIZATION_QUALITY 1

/* TODO: integrate these into xmlpool.h! */
#define DRI_CONF_MAX_TEXTURE_IMAGE_UNITS(def,min,max) \
DRI_CONF_OPT_BEGIN_V(texture_image_units,int,def, # min ":" # max ) \
        DRI_CONF_DESC(en,"Number of texture image units") \
        DRI_CONF_DESC(de,"Anzahl der Textureinheiten") \
DRI_CONF_OPT_END

#define DRI_CONF_MAX_TEXTURE_COORD_UNITS(def,min,max) \
DRI_CONF_OPT_BEGIN_V(texture_coord_units,int,def, # min ":" # max ) \
        DRI_CONF_DESC(en,"Number of texture coordinate units") \
        DRI_CONF_DESC(de,"Anzahl der Texturkoordinateneinheiten") \
DRI_CONF_OPT_END



#define DRI_CONF_DISABLE_S3TC(def) \
DRI_CONF_OPT_BEGIN(disable_s3tc,bool,def) \
        DRI_CONF_DESC(en,"Disable S3TC compression") \
DRI_CONF_OPT_END

#define DRI_CONF_DISABLE_FALLBACK(def) \
DRI_CONF_OPT_BEGIN(disable_lowimpact_fallback,bool,def) \
        DRI_CONF_DESC(en,"Disable Low-impact fallback") \
DRI_CONF_OPT_END

#define DRI_CONF_DISABLE_DOUBLE_SIDE_STENCIL(def) \
DRI_CONF_OPT_BEGIN(disable_stencil_two_side,bool,def) \
        DRI_CONF_DESC(en,"Disable GL_EXT_stencil_two_side") \
DRI_CONF_OPT_END

#define DRI_CONF_FP_OPTIMIZATION(def) \
DRI_CONF_OPT_BEGIN_V(fp_optimization,enum,def,"0:1") \
	DRI_CONF_DESC_BEGIN(en,"Fragment Program optimization") \
                DRI_CONF_ENUM(0,"Optimize for Speed") \
                DRI_CONF_ENUM(1,"Optimize for Quality") \
        DRI_CONF_DESC_END \
DRI_CONF_OPT_END

PUBLIC const char __driConfigOptions[] =
DRI_CONF_BEGIN
	DRI_CONF_SECTION_PERFORMANCE
		DRI_CONF_TCL_MODE(DRI_CONF_TCL_CODEGEN)
		DRI_CONF_FTHROTTLE_MODE(DRI_CONF_FTHROTTLE_IRQS)
		DRI_CONF_VBLANK_MODE(DRI_CONF_VBLANK_DEF_INTERVAL_0)
		DRI_CONF_MAX_TEXTURE_IMAGE_UNITS(8, 2, 8)
		DRI_CONF_MAX_TEXTURE_COORD_UNITS(8, 2, 8)
		DRI_CONF_COMMAND_BUFFER_SIZE(8, 8, 32)
		DRI_CONF_DISABLE_FALLBACK(true)
		DRI_CONF_DISABLE_DOUBLE_SIDE_STENCIL(false)
	DRI_CONF_SECTION_END
	DRI_CONF_SECTION_QUALITY
		DRI_CONF_TEXTURE_DEPTH(DRI_CONF_TEXTURE_DEPTH_FB)
		DRI_CONF_DEF_MAX_ANISOTROPY(1.0, "1.0,2.0,4.0,8.0,16.0")
		DRI_CONF_FORCE_S3TC_ENABLE(false)
		DRI_CONF_DISABLE_S3TC(false)
		DRI_CONF_COLOR_REDUCTION(DRI_CONF_COLOR_REDUCTION_DITHER)
		DRI_CONF_ROUND_MODE(DRI_CONF_ROUND_TRUNC)
		DRI_CONF_DITHER_MODE(DRI_CONF_DITHER_XERRORDIFF)
		DRI_CONF_FP_OPTIMIZATION(DRI_CONF_FP_OPTIMIZATION_SPEED)
	DRI_CONF_SECTION_END
	DRI_CONF_SECTION_DEBUG
		DRI_CONF_NO_RAST(false)
	DRI_CONF_SECTION_END
DRI_CONF_END;
static const GLuint __driNConfigOptions = 17;
a129 2
static int getSwapInfo( __DRIdrawable *dPriv, __DRIswapInfo * sInfo );

a168 78
static const __DRIconfig **
radeonFillInModes( __DRIscreen *psp,
		   unsigned pixel_bits, unsigned depth_bits,
		   unsigned stencil_bits, GLboolean have_back_buffer )
{
    __DRIconfig **configs;
    struct gl_config *m;
    unsigned depth_buffer_factor;
    unsigned back_buffer_factor;
    int i;

    /* Right now GLX_SWAP_COPY_OML isn't supported, but it would be easy
     * enough to add support.  Basically, if a context is created with an
     * fbconfig where the swap method is GLX_SWAP_COPY_OML, pageflipping
     * will never be used.
     */
    static const GLenum back_buffer_modes[] = {
	GLX_NONE, GLX_SWAP_UNDEFINED_OML /*, GLX_SWAP_COPY_OML */
    };

    uint8_t depth_bits_array[2];
    uint8_t stencil_bits_array[2];
    uint8_t msaa_samples_array[1];

    depth_bits_array[0] = depth_bits;
    depth_bits_array[1] = depth_bits;

    /* Just like with the accumulation buffer, always provide some modes
     * with a stencil buffer.  It will be a sw fallback, but some apps won't
     * care about that.
     */
    stencil_bits_array[0] = stencil_bits;
    stencil_bits_array[1] = (stencil_bits == 0) ? 8 : stencil_bits;

    msaa_samples_array[0] = 0;

    depth_buffer_factor = (stencil_bits == 0) ? 2 : 1;
    back_buffer_factor  = (have_back_buffer) ? 2 : 1;

    if (pixel_bits == 16) {
	__DRIconfig **configs_a8r8g8b8;
	__DRIconfig **configs_r5g6b5;

	configs_r5g6b5 = driCreateConfigs(GL_RGB, GL_UNSIGNED_SHORT_5_6_5,
					  depth_bits_array, stencil_bits_array,
					  depth_buffer_factor, back_buffer_modes,
					  back_buffer_factor, msaa_samples_array,
					  1, GL_TRUE);
	configs_a8r8g8b8 = driCreateConfigs(GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV,
					    depth_bits_array, stencil_bits_array,
					    1, back_buffer_modes, 1,
					    msaa_samples_array, 1, GL_TRUE);
	configs = driConcatConfigs(configs_r5g6b5, configs_a8r8g8b8);
   } else
	configs = driCreateConfigs(GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV,
				   depth_bits_array, stencil_bits_array,
				   depth_buffer_factor,
				   back_buffer_modes, back_buffer_factor,
				   msaa_samples_array, 1, GL_TRUE);

    if (configs == NULL) {
	fprintf( stderr, "[%s:%u] Error creating FBConfig!\n",
		 __func__, __LINE__ );
	return NULL;
    }

    /* Mark the visual as slow if there are "fake" stencil bits.
     */
    for (i = 0; configs[i]; i++) {
	m = &configs[i]->modes;
	if ((m->stencilBits != 0) && (m->stencilBits != stencil_bits)) {
	    m->visualRating = GLX_SLOW_CONFIG;
	}
    }

    return (const __DRIconfig **) configs;
}

a169 5
static const __DRItexOffsetExtension radeonTexOffsetExtension = {
    { __DRI_TEX_OFFSET, __DRI_TEX_OFFSET_VERSION },
    radeonSetTexOffset,
};

d175 1
a175 9
#endif

#if defined(RADEON_R200)

static const __DRItexOffsetExtension r200texOffsetExtension = {
    { __DRI_TEX_OFFSET, __DRI_TEX_OFFSET_VERSION },
   r200SetTexOffset,
};

a182 26
#if defined(RADEON_R300)
static const __DRItexOffsetExtension r300texOffsetExtension = {
    { __DRI_TEX_OFFSET, __DRI_TEX_OFFSET_VERSION },
   r300SetTexOffset,
};

static const __DRItexBufferExtension r300TexBufferExtension = {
    { __DRI_TEX_BUFFER, __DRI_TEX_BUFFER_VERSION },
   r300SetTexBuffer,
   r300SetTexBuffer2,
};
#endif

#if defined(RADEON_R600)
static const __DRItexOffsetExtension r600texOffsetExtension = {
    { __DRI_TEX_OFFSET, __DRI_TEX_OFFSET_VERSION },
   r600SetTexOffset, /* +r6/r7 */
};

static const __DRItexBufferExtension r600TexBufferExtension = {
    { __DRI_TEX_BUFFER, __DRI_TEX_BUFFER_VERSION },
   r600SetTexBuffer,  /* +r6/r7 */
   r600SetTexBuffer2, /* +r6/r7 */
};
#endif

d189 1
a189 1
    radeonFlush(rmesa->glCtx);
d193 1
a193 1
    { __DRI2_FLUSH, __DRI2_FLUSH_VERSION },
d204 1
a204 1
   radeonScreenPtr radeonScreen = screen->private;
d209 1
a209 1
   image = CALLOC(sizeof *image);
d248 1
a248 1
      FREE(image);
d264 1
a264 1
   rb = _mesa_lookup_renderbuffer(radeon->glCtx, renderbuffer);
d266 1
a266 1
      _mesa_error(radeon->glCtx,
d272 1
a272 1
   image = CALLOC(sizeof *image);
d279 1
a279 1
   image->data_type = rb->DataType;
d295 1
a295 1
   FREE(image);
d305 1
a305 1
   radeonScreenPtr radeonScreen = screen->private;
d307 1
a307 1
   image = CALLOC(sizeof *image);
d311 2
d348 1
a348 1
      FREE(image);
d374 1
a374 1
    { __DRI_IMAGE, __DRI_IMAGE_VERSION },
d387 1
d417 1
a417 1
      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_BROKEN_STENCIL;
d425 1
a425 1
      screen->chip_flags = RADEON_CHIPSET_TCL;
d428 1
d434 1
a434 1
      screen->chip_flags = RADEON_CHIPSET_TCL;
d443 1
a443 1
      screen->chip_flags = R200_CHIPSET_YCBCR_BROKEN | RADEON_CHIPSET_TCL;
d446 1
d455 1
a455 1
      screen->chip_flags = RADEON_CHIPSET_TCL;
d463 1
d465 1
a465 576

   case PCI_CHIP_R300_AD:
   case PCI_CHIP_R300_AE:
   case PCI_CHIP_R300_AF:
   case PCI_CHIP_R300_AG:
   case PCI_CHIP_R300_ND:
   case PCI_CHIP_R300_NE:
   case PCI_CHIP_R300_NF:
   case PCI_CHIP_R300_NG:
      screen->chip_family = CHIP_FAMILY_R300;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV350_AP:
   case PCI_CHIP_RV350_AQ:
   case PCI_CHIP_RV350_AR:
   case PCI_CHIP_RV350_AS:
   case PCI_CHIP_RV350_AT:
   case PCI_CHIP_RV350_AV:
   case PCI_CHIP_RV350_AU:
   case PCI_CHIP_RV350_NP:
   case PCI_CHIP_RV350_NQ:
   case PCI_CHIP_RV350_NR:
   case PCI_CHIP_RV350_NS:
   case PCI_CHIP_RV350_NT:
   case PCI_CHIP_RV350_NV:
      screen->chip_family = CHIP_FAMILY_RV350;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_R350_AH:
   case PCI_CHIP_R350_AI:
   case PCI_CHIP_R350_AJ:
   case PCI_CHIP_R350_AK:
   case PCI_CHIP_R350_NH:
   case PCI_CHIP_R350_NI:
   case PCI_CHIP_R360_NJ:
   case PCI_CHIP_R350_NK:
      screen->chip_family = CHIP_FAMILY_R350;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV370_5460:
   case PCI_CHIP_RV370_5462:
   case PCI_CHIP_RV370_5464:
   case PCI_CHIP_RV370_5B60:
   case PCI_CHIP_RV370_5B62:
   case PCI_CHIP_RV370_5B63:
   case PCI_CHIP_RV370_5B64:
   case PCI_CHIP_RV370_5B65:
   case PCI_CHIP_RV380_3150:
   case PCI_CHIP_RV380_3152:
   case PCI_CHIP_RV380_3154:
   case PCI_CHIP_RV380_3155:
   case PCI_CHIP_RV380_3E50:
   case PCI_CHIP_RV380_3E54:
      screen->chip_family = CHIP_FAMILY_RV380;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_R420_JN:
   case PCI_CHIP_R420_JH:
   case PCI_CHIP_R420_JI:
   case PCI_CHIP_R420_JJ:
   case PCI_CHIP_R420_JK:
   case PCI_CHIP_R420_JL:
   case PCI_CHIP_R420_JM:
   case PCI_CHIP_R420_JO:
   case PCI_CHIP_R420_JP:
   case PCI_CHIP_R420_JT:
   case PCI_CHIP_R481_4B49:
   case PCI_CHIP_R481_4B4A:
   case PCI_CHIP_R481_4B4B:
   case PCI_CHIP_R481_4B4C:
   case PCI_CHIP_R423_UH:
   case PCI_CHIP_R423_UI:
   case PCI_CHIP_R423_UJ:
   case PCI_CHIP_R423_UK:
   case PCI_CHIP_R430_554C:
   case PCI_CHIP_R430_554D:
   case PCI_CHIP_R430_554E:
   case PCI_CHIP_R430_554F:
   case PCI_CHIP_R423_5550:
   case PCI_CHIP_R423_UQ:
   case PCI_CHIP_R423_UR:
   case PCI_CHIP_R423_UT:
   case PCI_CHIP_R430_5D48:
   case PCI_CHIP_R430_5D49:
   case PCI_CHIP_R430_5D4A:
   case PCI_CHIP_R480_5D4C:
   case PCI_CHIP_R480_5D4D:
   case PCI_CHIP_R480_5D4E:
   case PCI_CHIP_R480_5D4F:
   case PCI_CHIP_R480_5D50:
   case PCI_CHIP_R480_5D52:
   case PCI_CHIP_R423_5D57:
      screen->chip_family = CHIP_FAMILY_R420;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV410_5E4C:
   case PCI_CHIP_RV410_5E4F:
   case PCI_CHIP_RV410_564A:
   case PCI_CHIP_RV410_564B:
   case PCI_CHIP_RV410_564F:
   case PCI_CHIP_RV410_5652:
   case PCI_CHIP_RV410_5653:
   case PCI_CHIP_RV410_5657:
   case PCI_CHIP_RV410_5E48:
   case PCI_CHIP_RV410_5E4A:
   case PCI_CHIP_RV410_5E4B:
   case PCI_CHIP_RV410_5E4D:
      screen->chip_family = CHIP_FAMILY_RV410;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RS480_5954:
   case PCI_CHIP_RS480_5955:
   case PCI_CHIP_RS482_5974:
   case PCI_CHIP_RS482_5975:
   case PCI_CHIP_RS400_5A41:
   case PCI_CHIP_RS400_5A42:
   case PCI_CHIP_RC410_5A61:
   case PCI_CHIP_RC410_5A62:
      screen->chip_family = CHIP_FAMILY_RS400;
      break;

   case PCI_CHIP_RS600_793F:
   case PCI_CHIP_RS600_7941:
   case PCI_CHIP_RS600_7942:
      screen->chip_family = CHIP_FAMILY_RS600;
      break;

   case PCI_CHIP_RS690_791E:
   case PCI_CHIP_RS690_791F:
      screen->chip_family = CHIP_FAMILY_RS690;
      break;
   case PCI_CHIP_RS740_796C:
   case PCI_CHIP_RS740_796D:
   case PCI_CHIP_RS740_796E:
   case PCI_CHIP_RS740_796F:
      screen->chip_family = CHIP_FAMILY_RS740;
      break;

   case PCI_CHIP_R520_7100:
   case PCI_CHIP_R520_7101:
   case PCI_CHIP_R520_7102:
   case PCI_CHIP_R520_7103:
   case PCI_CHIP_R520_7104:
   case PCI_CHIP_R520_7105:
   case PCI_CHIP_R520_7106:
   case PCI_CHIP_R520_7108:
   case PCI_CHIP_R520_7109:
   case PCI_CHIP_R520_710A:
   case PCI_CHIP_R520_710B:
   case PCI_CHIP_R520_710C:
   case PCI_CHIP_R520_710E:
   case PCI_CHIP_R520_710F:
      screen->chip_family = CHIP_FAMILY_R520;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV515_7140:
   case PCI_CHIP_RV515_7141:
   case PCI_CHIP_RV515_7142:
   case PCI_CHIP_RV515_7143:
   case PCI_CHIP_RV515_7144:
   case PCI_CHIP_RV515_7145:
   case PCI_CHIP_RV515_7146:
   case PCI_CHIP_RV515_7147:
   case PCI_CHIP_RV515_7149:
   case PCI_CHIP_RV515_714A:
   case PCI_CHIP_RV515_714B:
   case PCI_CHIP_RV515_714C:
   case PCI_CHIP_RV515_714D:
   case PCI_CHIP_RV515_714E:
   case PCI_CHIP_RV515_714F:
   case PCI_CHIP_RV515_7151:
   case PCI_CHIP_RV515_7152:
   case PCI_CHIP_RV515_7153:
   case PCI_CHIP_RV515_715E:
   case PCI_CHIP_RV515_715F:
   case PCI_CHIP_RV515_7180:
   case PCI_CHIP_RV515_7181:
   case PCI_CHIP_RV515_7183:
   case PCI_CHIP_RV515_7186:
   case PCI_CHIP_RV515_7187:
   case PCI_CHIP_RV515_7188:
   case PCI_CHIP_RV515_718A:
   case PCI_CHIP_RV515_718B:
   case PCI_CHIP_RV515_718C:
   case PCI_CHIP_RV515_718D:
   case PCI_CHIP_RV515_718F:
   case PCI_CHIP_RV515_7193:
   case PCI_CHIP_RV515_7196:
   case PCI_CHIP_RV515_719B:
   case PCI_CHIP_RV515_719F:
   case PCI_CHIP_RV515_7200:
   case PCI_CHIP_RV515_7210:
   case PCI_CHIP_RV515_7211:
      screen->chip_family = CHIP_FAMILY_RV515;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV530_71C0:
   case PCI_CHIP_RV530_71C1:
   case PCI_CHIP_RV530_71C2:
   case PCI_CHIP_RV530_71C3:
   case PCI_CHIP_RV530_71C4:
   case PCI_CHIP_RV530_71C5:
   case PCI_CHIP_RV530_71C6:
   case PCI_CHIP_RV530_71C7:
   case PCI_CHIP_RV530_71CD:
   case PCI_CHIP_RV530_71CE:
   case PCI_CHIP_RV530_71D2:
   case PCI_CHIP_RV530_71D4:
   case PCI_CHIP_RV530_71D5:
   case PCI_CHIP_RV530_71D6:
   case PCI_CHIP_RV530_71DA:
   case PCI_CHIP_RV530_71DE:
      screen->chip_family = CHIP_FAMILY_RV530;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_R580_7240:
   case PCI_CHIP_R580_7243:
   case PCI_CHIP_R580_7244:
   case PCI_CHIP_R580_7245:
   case PCI_CHIP_R580_7246:
   case PCI_CHIP_R580_7247:
   case PCI_CHIP_R580_7248:
   case PCI_CHIP_R580_7249:
   case PCI_CHIP_R580_724A:
   case PCI_CHIP_R580_724B:
   case PCI_CHIP_R580_724C:
   case PCI_CHIP_R580_724D:
   case PCI_CHIP_R580_724E:
   case PCI_CHIP_R580_724F:
   case PCI_CHIP_R580_7284:
      screen->chip_family = CHIP_FAMILY_R580;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV570_7280:
   case PCI_CHIP_RV560_7281:
   case PCI_CHIP_RV560_7283:
   case PCI_CHIP_RV560_7287:
   case PCI_CHIP_RV570_7288:
   case PCI_CHIP_RV570_7289:
   case PCI_CHIP_RV570_728B:
   case PCI_CHIP_RV570_728C:
   case PCI_CHIP_RV560_7290:
   case PCI_CHIP_RV560_7291:
   case PCI_CHIP_RV560_7293:
   case PCI_CHIP_RV560_7297:
      screen->chip_family = CHIP_FAMILY_RV560;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_R600_9400:
   case PCI_CHIP_R600_9401:
   case PCI_CHIP_R600_9402:
   case PCI_CHIP_R600_9403:
   case PCI_CHIP_R600_9405:
   case PCI_CHIP_R600_940A:
   case PCI_CHIP_R600_940B:
   case PCI_CHIP_R600_940F:
      screen->chip_family = CHIP_FAMILY_R600;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV610_94C0:
   case PCI_CHIP_RV610_94C1:
   case PCI_CHIP_RV610_94C3:
   case PCI_CHIP_RV610_94C4:
   case PCI_CHIP_RV610_94C5:
   case PCI_CHIP_RV610_94C6:
   case PCI_CHIP_RV610_94C7:
   case PCI_CHIP_RV610_94C8:
   case PCI_CHIP_RV610_94C9:
   case PCI_CHIP_RV610_94CB:
   case PCI_CHIP_RV610_94CC:
   case PCI_CHIP_RV610_94CD:
      screen->chip_family = CHIP_FAMILY_RV610;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV630_9580:
   case PCI_CHIP_RV630_9581:
   case PCI_CHIP_RV630_9583:
   case PCI_CHIP_RV630_9586:
   case PCI_CHIP_RV630_9587:
   case PCI_CHIP_RV630_9588:
   case PCI_CHIP_RV630_9589:
   case PCI_CHIP_RV630_958A:
   case PCI_CHIP_RV630_958B:
   case PCI_CHIP_RV630_958C:
   case PCI_CHIP_RV630_958D:
   case PCI_CHIP_RV630_958E:
   case PCI_CHIP_RV630_958F:
      screen->chip_family = CHIP_FAMILY_RV630;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV670_9500:
   case PCI_CHIP_RV670_9501:
   case PCI_CHIP_RV670_9504:
   case PCI_CHIP_RV670_9505:
   case PCI_CHIP_RV670_9506:
   case PCI_CHIP_RV670_9507:
   case PCI_CHIP_RV670_9508:
   case PCI_CHIP_RV670_9509:
   case PCI_CHIP_RV670_950F:
   case PCI_CHIP_RV670_9511:
   case PCI_CHIP_RV670_9515:
   case PCI_CHIP_RV670_9517:
   case PCI_CHIP_RV670_9519:
      screen->chip_family = CHIP_FAMILY_RV670;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV620_95C0:
   case PCI_CHIP_RV620_95C2:
   case PCI_CHIP_RV620_95C4:
   case PCI_CHIP_RV620_95C5:
   case PCI_CHIP_RV620_95C6:
   case PCI_CHIP_RV620_95C7:
   case PCI_CHIP_RV620_95C9:
   case PCI_CHIP_RV620_95CC:
   case PCI_CHIP_RV620_95CD:
   case PCI_CHIP_RV620_95CE:
   case PCI_CHIP_RV620_95CF:
      screen->chip_family = CHIP_FAMILY_RV620;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV635_9590:
   case PCI_CHIP_RV635_9591:
   case PCI_CHIP_RV635_9593:
   case PCI_CHIP_RV635_9595:
   case PCI_CHIP_RV635_9596:
   case PCI_CHIP_RV635_9597:
   case PCI_CHIP_RV635_9598:
   case PCI_CHIP_RV635_9599:
   case PCI_CHIP_RV635_959B:
      screen->chip_family = CHIP_FAMILY_RV635;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RS780_9610:
   case PCI_CHIP_RS780_9611:
   case PCI_CHIP_RS780_9612:
   case PCI_CHIP_RS780_9613:
   case PCI_CHIP_RS780_9614:
   case PCI_CHIP_RS780_9615:
   case PCI_CHIP_RS780_9616:
      screen->chip_family = CHIP_FAMILY_RS780;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;
   case PCI_CHIP_RS880_9710:
   case PCI_CHIP_RS880_9711:
   case PCI_CHIP_RS880_9712:
   case PCI_CHIP_RS880_9713:
   case PCI_CHIP_RS880_9714:
   case PCI_CHIP_RS880_9715:
      screen->chip_family = CHIP_FAMILY_RS880;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV770_9440:
   case PCI_CHIP_RV770_9441:
   case PCI_CHIP_RV770_9442:
   case PCI_CHIP_RV770_9443:
   case PCI_CHIP_RV770_9444:
   case PCI_CHIP_RV770_9446:
   case PCI_CHIP_RV770_944A:
   case PCI_CHIP_RV770_944B:
   case PCI_CHIP_RV770_944C:
   case PCI_CHIP_RV770_944E:
   case PCI_CHIP_RV770_9450:
   case PCI_CHIP_RV770_9452:
   case PCI_CHIP_RV770_9456:
   case PCI_CHIP_RV770_945A:
   case PCI_CHIP_RV770_945B:
   case PCI_CHIP_RV770_945E:
   case PCI_CHIP_RV790_9460:
   case PCI_CHIP_RV790_9462:
   case PCI_CHIP_RV770_946A:
   case PCI_CHIP_RV770_946B:
   case PCI_CHIP_RV770_947A:
   case PCI_CHIP_RV770_947B:
      screen->chip_family = CHIP_FAMILY_RV770;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV730_9480:
   case PCI_CHIP_RV730_9487:
   case PCI_CHIP_RV730_9488:
   case PCI_CHIP_RV730_9489:
   case PCI_CHIP_RV730_948A:
   case PCI_CHIP_RV730_948F:
   case PCI_CHIP_RV730_9490:
   case PCI_CHIP_RV730_9491:
   case PCI_CHIP_RV730_9495:
   case PCI_CHIP_RV730_9498:
   case PCI_CHIP_RV730_949C:
   case PCI_CHIP_RV730_949E:
   case PCI_CHIP_RV730_949F:
      screen->chip_family = CHIP_FAMILY_RV730;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV710_9540:
   case PCI_CHIP_RV710_9541:
   case PCI_CHIP_RV710_9542:
   case PCI_CHIP_RV710_954E:
   case PCI_CHIP_RV710_954F:
   case PCI_CHIP_RV710_9552:
   case PCI_CHIP_RV710_9553:
   case PCI_CHIP_RV710_9555:
   case PCI_CHIP_RV710_9557:
   case PCI_CHIP_RV710_955F:
      screen->chip_family = CHIP_FAMILY_RV710;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV740_94A0:
   case PCI_CHIP_RV740_94A1:
   case PCI_CHIP_RV740_94A3:
   case PCI_CHIP_RV740_94B1:
   case PCI_CHIP_RV740_94B3:
   case PCI_CHIP_RV740_94B4:
   case PCI_CHIP_RV740_94B5:
   case PCI_CHIP_RV740_94B9:
      screen->chip_family = CHIP_FAMILY_RV740;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

    case PCI_CHIP_CEDAR_68E0:
    case PCI_CHIP_CEDAR_68E1:
    case PCI_CHIP_CEDAR_68E4:
    case PCI_CHIP_CEDAR_68E5:
    case PCI_CHIP_CEDAR_68E8:
    case PCI_CHIP_CEDAR_68E9:
    case PCI_CHIP_CEDAR_68F1:
    case PCI_CHIP_CEDAR_68F2:
    case PCI_CHIP_CEDAR_68F8:
    case PCI_CHIP_CEDAR_68F9:
    case PCI_CHIP_CEDAR_68FE:
       screen->chip_family = CHIP_FAMILY_CEDAR;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

    case PCI_CHIP_REDWOOD_68C0:
    case PCI_CHIP_REDWOOD_68C1:
    case PCI_CHIP_REDWOOD_68C8:
    case PCI_CHIP_REDWOOD_68C9:
    case PCI_CHIP_REDWOOD_68D8:
    case PCI_CHIP_REDWOOD_68D9:
    case PCI_CHIP_REDWOOD_68DA:
    case PCI_CHIP_REDWOOD_68DE:
       screen->chip_family = CHIP_FAMILY_REDWOOD;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

    case PCI_CHIP_JUNIPER_68A0:
    case PCI_CHIP_JUNIPER_68A1:
    case PCI_CHIP_JUNIPER_68A8:
    case PCI_CHIP_JUNIPER_68A9:
    case PCI_CHIP_JUNIPER_68B0:
    case PCI_CHIP_JUNIPER_68B8:
    case PCI_CHIP_JUNIPER_68B9:
    case PCI_CHIP_JUNIPER_68BA:
    case PCI_CHIP_JUNIPER_68BE:
    case PCI_CHIP_JUNIPER_68BF:
       screen->chip_family = CHIP_FAMILY_JUNIPER;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

    case PCI_CHIP_CYPRESS_6880:
    case PCI_CHIP_CYPRESS_6888:
    case PCI_CHIP_CYPRESS_6889:
    case PCI_CHIP_CYPRESS_688A:
    case PCI_CHIP_CYPRESS_6898:
    case PCI_CHIP_CYPRESS_6899:
    case PCI_CHIP_CYPRESS_689B:
    case PCI_CHIP_CYPRESS_689E:
       screen->chip_family = CHIP_FAMILY_CYPRESS;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

    case PCI_CHIP_HEMLOCK_689C:
    case PCI_CHIP_HEMLOCK_689D:
       screen->chip_family = CHIP_FAMILY_HEMLOCK;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

    case PCI_CHIP_PALM_9802:
    case PCI_CHIP_PALM_9803:
    case PCI_CHIP_PALM_9804:
    case PCI_CHIP_PALM_9805:
    case PCI_CHIP_PALM_9806:
    case PCI_CHIP_PALM_9807:
       screen->chip_family = CHIP_FAMILY_PALM;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

    case PCI_CHIP_SUMO_9640:
    case PCI_CHIP_SUMO_9641:
    case PCI_CHIP_SUMO_9647:
    case PCI_CHIP_SUMO_9648:
    case PCI_CHIP_SUMO_964A:
    case PCI_CHIP_SUMO_964E:
    case PCI_CHIP_SUMO_964F:
       screen->chip_family = CHIP_FAMILY_SUMO;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

    case PCI_CHIP_SUMO2_9642:
    case PCI_CHIP_SUMO2_9643:
    case PCI_CHIP_SUMO2_9644:
    case PCI_CHIP_SUMO2_9645:
       screen->chip_family = CHIP_FAMILY_SUMO2;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

   case PCI_CHIP_BARTS_6720:
   case PCI_CHIP_BARTS_6721:
   case PCI_CHIP_BARTS_6722:
   case PCI_CHIP_BARTS_6723:
   case PCI_CHIP_BARTS_6724:
   case PCI_CHIP_BARTS_6725:
   case PCI_CHIP_BARTS_6726:
   case PCI_CHIP_BARTS_6727:
   case PCI_CHIP_BARTS_6728:
   case PCI_CHIP_BARTS_6729:
   case PCI_CHIP_BARTS_6738:
   case PCI_CHIP_BARTS_6739:
   case PCI_CHIP_BARTS_673E:
       screen->chip_family = CHIP_FAMILY_BARTS;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

   case PCI_CHIP_TURKS_6740:
   case PCI_CHIP_TURKS_6741:
   case PCI_CHIP_TURKS_6742:
   case PCI_CHIP_TURKS_6743:
   case PCI_CHIP_TURKS_6744:
   case PCI_CHIP_TURKS_6745:
   case PCI_CHIP_TURKS_6746:
   case PCI_CHIP_TURKS_6747:
   case PCI_CHIP_TURKS_6748:
   case PCI_CHIP_TURKS_6749:
   case PCI_CHIP_TURKS_6750:
   case PCI_CHIP_TURKS_6758:
   case PCI_CHIP_TURKS_6759:
   case PCI_CHIP_TURKS_675F:
       screen->chip_family = CHIP_FAMILY_TURKS;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

   case PCI_CHIP_CAICOS_6760:
   case PCI_CHIP_CAICOS_6761:
   case PCI_CHIP_CAICOS_6762:
   case PCI_CHIP_CAICOS_6763:
   case PCI_CHIP_CAICOS_6764:
   case PCI_CHIP_CAICOS_6765:
   case PCI_CHIP_CAICOS_6766:
   case PCI_CHIP_CAICOS_6767:
   case PCI_CHIP_CAICOS_6768:
   case PCI_CHIP_CAICOS_6770:
   case PCI_CHIP_CAICOS_6778:
   case PCI_CHIP_CAICOS_6779:
       screen->chip_family = CHIP_FAMILY_CAICOS;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;
a475 325

/* Create the device specific screen private data struct.
 */
static radeonScreenPtr
radeonCreateScreen( __DRIscreen *sPriv )
{
   radeonScreenPtr screen;
   RADEONDRIPtr dri_priv = (RADEONDRIPtr)sPriv->pDevPriv;
   int i;
   int ret;
   uint32_t temp = 0;

   if (sPriv->devPrivSize != sizeof(RADEONDRIRec)) {
      fprintf(stderr,"\nERROR!  sizeof(RADEONDRIRec) does not match passed size from device driver\n");
      return GL_FALSE;
   }

   /* Allocate the private area */
   screen = (radeonScreenPtr) CALLOC( sizeof(*screen) );
   if ( !screen ) {
      __driUtilMessage("%s: Could not allocate memory for screen structure",
		       __FUNCTION__);
      return NULL;
   }

   radeon_init_debug();

   /* parse information in __driConfigOptions */
   driParseOptionInfo (&screen->optionCache,
		       __driConfigOptions, __driNConfigOptions);

   /* This is first since which regions we map depends on whether or
    * not we are using a PCI card.
    */
   screen->card_type = (dri_priv->IsPCI ? RADEON_CARD_PCI : RADEON_CARD_AGP);
   {
      int ret;

      ret = radeonGetParam(sPriv, RADEON_PARAM_GART_BUFFER_OFFSET,
			    &screen->gart_buffer_offset);

      if (ret) {
	 FREE( screen );
	 fprintf(stderr, "drm_radeon_getparam_t (RADEON_PARAM_GART_BUFFER_OFFSET): %d\n", ret);
	 return NULL;
      }

      ret = radeonGetParam(sPriv, RADEON_PARAM_GART_BASE,
			    &screen->gart_base);
      if (ret) {
	 FREE( screen );
	 fprintf(stderr, "drm_radeon_getparam_t (RADEON_PARAM_GART_BASE): %d\n", ret);
	 return NULL;
      }

      ret = radeonGetParam(sPriv, RADEON_PARAM_IRQ_NR,
			    &screen->irq);
      if (ret) {
	 FREE( screen );
	 fprintf(stderr, "drm_radeon_getparam_t (RADEON_PARAM_IRQ_NR): %d\n", ret);
	 return NULL;
      }
      screen->drmSupportsCubeMapsR200 = (sPriv->drm_version.minor >= 7);
      screen->drmSupportsBlendColor = (sPriv->drm_version.minor >= 11);
      screen->drmSupportsTriPerf = (sPriv->drm_version.minor >= 16);
      screen->drmSupportsFragShader = (sPriv->drm_version.minor >= 18);
      screen->drmSupportsPointSprites = (sPriv->drm_version.minor >= 13);
      screen->drmSupportsCubeMapsR100 = (sPriv->drm_version.minor >= 15);
      screen->drmSupportsVertexProgram = (sPriv->drm_version.minor >= 25);
      screen->drmSupportsOcclusionQueries = (sPriv->drm_version.minor >= 30);
   }

   ret = radeon_set_screen_flags(screen, dri_priv->deviceID);
   if (ret == -1)
     return NULL;

   screen->status.handle = dri_priv->statusHandle;
   screen->status.size   = dri_priv->statusSize;
   if ( drmMap( sPriv->fd,
		screen->status.handle,
		screen->status.size,
		&screen->status.map ) ) {
     FREE( screen );
     __driUtilMessage("%s: drmMap (2) failed\n", __FUNCTION__ );
     return NULL;
   }
   if (screen->chip_family < CHIP_FAMILY_R600)
	   screen->scratch = (__volatile__ uint32_t *)
		   ((GLubyte *)screen->status.map + RADEON_SCRATCH_REG_OFFSET);
   else
	   screen->scratch = (__volatile__ uint32_t *)
		   ((GLubyte *)screen->status.map + R600_SCRATCH_REG_OFFSET);

   screen->buffers = drmMapBufs( sPriv->fd );
   if ( !screen->buffers ) {
     drmUnmap( screen->status.map, screen->status.size );
     FREE( screen );
     __driUtilMessage("%s: drmMapBufs failed\n", __FUNCTION__ );
     return NULL;
   }

   if ( dri_priv->gartTexHandle && dri_priv->gartTexMapSize ) {
     screen->gartTextures.handle = dri_priv->gartTexHandle;
     screen->gartTextures.size   = dri_priv->gartTexMapSize;
     if ( drmMap( sPriv->fd,
		  screen->gartTextures.handle,
		  screen->gartTextures.size,
		  (drmAddressPtr)&screen->gartTextures.map ) ) {
       drmUnmapBufs( screen->buffers );
       drmUnmap( screen->status.map, screen->status.size );
       FREE( screen );
       __driUtilMessage("%s: drmMap failed for GART texture area\n", __FUNCTION__);
       return NULL;
    }

     screen->gart_texture_offset = dri_priv->gartTexOffset + screen->gart_base;
   }

   if ((screen->chip_family == CHIP_FAMILY_R350 || screen->chip_family == CHIP_FAMILY_R300) &&
       sPriv->ddx_version.minor < 2) {
      fprintf(stderr, "xf86-video-ati-6.6.2 or newer needed for Radeon 9500/9700/9800 cards.\n");
      return NULL;
   }

   if ((sPriv->drm_version.minor < 29) && (screen->chip_family >= CHIP_FAMILY_RV515)) {
      fprintf(stderr, "R500 support requires a newer drm.\n");
      return NULL;
   }

   if (getenv("R300_NO_TCL"))
	   screen->chip_flags &= ~RADEON_CHIPSET_TCL;

   if (screen->chip_family <= CHIP_FAMILY_RS200)
	   screen->chip_flags |= RADEON_CLASS_R100;
   else if (screen->chip_family <= CHIP_FAMILY_RV280)
	   screen->chip_flags |= RADEON_CLASS_R200;
   else if (screen->chip_family <= CHIP_FAMILY_RV570)
	   screen->chip_flags |= RADEON_CLASS_R300;
   else
	   screen->chip_flags |= RADEON_CLASS_R600;

   /* set group bytes for r6xx+ */
   if (screen->chip_family >= CHIP_FAMILY_CEDAR)
	   screen->group_bytes = 512;
   else
	   screen->group_bytes = 256;

   screen->cpp = dri_priv->bpp / 8;
   screen->AGPMode = dri_priv->AGPMode;

   ret = radeonGetParam(sPriv, RADEON_PARAM_FB_LOCATION, &temp);

   /* +r6/r7 */
   if(screen->chip_family >= CHIP_FAMILY_R600)
   {
       if (ret)
       {
            FREE( screen );
            fprintf(stderr, "Unable to get fb location need newer drm\n");
            return NULL;
       }
       else
       {
            screen->fbLocation = (temp & 0xffff) << 24;
       }
   }
   else
   {
        if (ret)
        {
                FREE( screen );
                fprintf(stderr, "Unable to get fb location need newer drm\n");
                return NULL;
        }
        else
        {            
            screen->fbLocation = (temp & 0xffff) << 16;
        }
   }

   if (IS_R300_CLASS(screen)) {
       ret = radeonGetParam(sPriv, RADEON_PARAM_NUM_GB_PIPES, &temp);
       if (ret) {
	   fprintf(stderr, "Unable to get num_pipes, need newer drm\n");
	   switch (screen->chip_family) {
	   case CHIP_FAMILY_R300:
	   case CHIP_FAMILY_R350:
	       screen->num_gb_pipes = 2;
	       break;
	   case CHIP_FAMILY_R420:
	   case CHIP_FAMILY_R520:
	   case CHIP_FAMILY_R580:
	   case CHIP_FAMILY_RV560:
	   case CHIP_FAMILY_RV570:
	       screen->num_gb_pipes = 4;
	       break;
	   case CHIP_FAMILY_RV350:
	   case CHIP_FAMILY_RV515:
	   case CHIP_FAMILY_RV530:
	   case CHIP_FAMILY_RV410:
	   default:
	       screen->num_gb_pipes = 1;
	       break;
	   }
       } else {
	   screen->num_gb_pipes = temp;
       }

       /* pipe overrides */
       switch (dri_priv->deviceID) {
       case PCI_CHIP_R300_AD: /* 9500 with 1 quadpipe verified by: Reid Linnemann <lreid@@cs.okstate.edu> */
       case PCI_CHIP_R350_AH: /* 9800 SE only have 1 quadpipe */
       case PCI_CHIP_RV410_5E4C: /* RV410 SE only have 1 quadpipe */
       case PCI_CHIP_RV410_5E4F: /* RV410 SE only have 1 quadpipe */
	   screen->num_gb_pipes = 1;
	   break;
       default:
	   break;
       }

       if ( sPriv->drm_version.minor >= 31 ) {
	       ret = radeonGetParam(sPriv, RADEON_PARAM_NUM_Z_PIPES, &temp);
	       if (ret)
		       screen->num_z_pipes = 2;
	       else
		       screen->num_z_pipes = temp;
       } else
	       screen->num_z_pipes = 2;
   }

   if ( sPriv->drm_version.minor >= 10 ) {
      drm_radeon_setparam_t sp;

      sp.param = RADEON_SETPARAM_FB_LOCATION;
      sp.value = screen->fbLocation;

      drmCommandWrite( sPriv->fd, DRM_RADEON_SETPARAM,
		       &sp, sizeof( sp ) );
   }

   screen->frontOffset	= dri_priv->frontOffset;
   screen->frontPitch	= dri_priv->frontPitch;
   screen->backOffset	= dri_priv->backOffset;
   screen->backPitch	= dri_priv->backPitch;
   screen->depthOffset	= dri_priv->depthOffset;
   screen->depthPitch	= dri_priv->depthPitch;

   /* Check if ddx has set up a surface reg to cover depth buffer */
   screen->depthHasSurface = (sPriv->ddx_version.major > 4) ||
      /* these chips don't use tiled z without hyperz. So always pretend
         we have set up a surface which will cause linear reads/writes */
      (IS_R100_CLASS(screen) &&
      !(screen->chip_flags & RADEON_CHIPSET_TCL));

   if ( dri_priv->textureSize == 0 ) {
      screen->texOffset[RADEON_LOCAL_TEX_HEAP] = screen->gart_texture_offset;
      screen->texSize[RADEON_LOCAL_TEX_HEAP] = dri_priv->gartTexMapSize;
      screen->logTexGranularity[RADEON_LOCAL_TEX_HEAP] =
	 dri_priv->log2GARTTexGran;
   } else {
      screen->texOffset[RADEON_LOCAL_TEX_HEAP] = dri_priv->textureOffset
				               + screen->fbLocation;
      screen->texSize[RADEON_LOCAL_TEX_HEAP] = dri_priv->textureSize;
      screen->logTexGranularity[RADEON_LOCAL_TEX_HEAP] =
	 dri_priv->log2TexGran;
   }

   if ( !screen->gartTextures.map || dri_priv->textureSize == 0
	|| getenv( "RADEON_GARTTEXTURING_FORCE_DISABLE" ) ) {
      screen->numTexHeaps = RADEON_NR_TEX_HEAPS - 1;
      screen->texOffset[RADEON_GART_TEX_HEAP] = 0;
      screen->texSize[RADEON_GART_TEX_HEAP] = 0;
      screen->logTexGranularity[RADEON_GART_TEX_HEAP] = 0;
   } else {
      screen->numTexHeaps = RADEON_NR_TEX_HEAPS;
      screen->texOffset[RADEON_GART_TEX_HEAP] = screen->gart_texture_offset;
      screen->texSize[RADEON_GART_TEX_HEAP] = dri_priv->gartTexMapSize;
      screen->logTexGranularity[RADEON_GART_TEX_HEAP] =
	 dri_priv->log2GARTTexGran;
   }

   i = 0;
   screen->extensions[i++] = &driCopySubBufferExtension.base;
   screen->extensions[i++] = &driReadDrawableExtension;

   if ( screen->irq != 0 ) {
       screen->extensions[i++] = &driSwapControlExtension.base;
       screen->extensions[i++] = &driMediaStreamCounterExtension.base;
   }

#if defined(RADEON_R100)
   screen->extensions[i++] = &radeonTexOffsetExtension.base;
#endif

#if defined(RADEON_R200)
   screen->extensions[i++] = &r200texOffsetExtension.base;
#endif

#if defined(RADEON_R300)
   screen->extensions[i++] = &r300texOffsetExtension.base;
#endif

#if defined(RADEON_R600)
   screen->extensions[i++] = &r600texOffsetExtension.base;
#endif

   screen->extensions[i++] = &dri2ConfigQueryExtension.base;

   screen->extensions[i++] = NULL;
   sPriv->extensions = screen->extensions;

   screen->driScreen = sPriv;
   screen->sarea_priv_offset = dri_priv->sarea_priv_offset;
   screen->sarea = (drm_radeon_sarea_t *) ((GLubyte *) sPriv->pSAREA +
					       screen->sarea_priv_offset);

   screen->bom = radeon_bo_manager_legacy_ctor(screen);
   if (screen->bom == NULL) {
     free(screen);
     return NULL;
   }

   return screen;
}

a482 1
   uint32_t temp = 0;
d485 1
a485 1
   screen = (radeonScreenPtr) CALLOC( sizeof(*screen) );
d487 1
a487 2
      __driUtilMessage("%s: Could not allocate memory for screen structure",
		       __FUNCTION__);
a497 1
   screen->kernel_mm = 1;
a499 9
   /* if we have kms we can support all of these */
   screen->drmSupportsCubeMapsR200 = 1;
   screen->drmSupportsBlendColor = 1;
   screen->drmSupportsTriPerf = 1;
   screen->drmSupportsFragShader = 1;
   screen->drmSupportsPointSprites = 1;
   screen->drmSupportsCubeMapsR100 = 1;
   screen->drmSupportsVertexProgram = 1;
   screen->drmSupportsOcclusionQueries = 1;
d504 1
a504 1
     FREE( screen );
d510 2
a511 1
   if (ret == -1)
d513 1
d515 1
a515 1
   if (getenv("R300_NO_TCL"))
a517 165
   if (screen->chip_family <= CHIP_FAMILY_RS200)
	   screen->chip_flags |= RADEON_CLASS_R100;
   else if (screen->chip_family <= CHIP_FAMILY_RV280)
	   screen->chip_flags |= RADEON_CLASS_R200;
   else if (screen->chip_family <= CHIP_FAMILY_RV570)
	   screen->chip_flags |= RADEON_CLASS_R300;
   else
	   screen->chip_flags |= RADEON_CLASS_R600;

   /* r6xx+ tiling, default group bytes */
   if (screen->chip_family >= CHIP_FAMILY_CEDAR)
	   screen->group_bytes = 512;
   else
	   screen->group_bytes = 256;
   if (IS_R600_CLASS(screen)) {
	   if ((sPriv->drm_version.minor >= 6) &&
	       (screen->chip_family < CHIP_FAMILY_CEDAR)) {
		   ret = radeonGetParam(sPriv, RADEON_INFO_TILE_CONFIG, &temp);
		   if (ret)
			   fprintf(stderr, "failed to get tiling info\n");
		   else {
			   screen->tile_config = temp;
			   screen->r7xx_bank_op = 0;
			   switch ((screen->tile_config & 0xe) >> 1) {
			   case 0:
				   screen->num_channels = 1;
				   break;
			   case 1:
				   screen->num_channels = 2;
				   break;
			   case 2:
				   screen->num_channels = 4;
				   break;
			   case 3:
				   screen->num_channels = 8;
				   break;
			   default:
				   fprintf(stderr, "bad channels\n");
				   break;
			   }
			   switch ((screen->tile_config & 0x30) >> 4) {
			   case 0:
				   screen->num_banks = 4;
				   break;
			   case 1:
				   screen->num_banks = 8;
				   break;
			   default:
				   fprintf(stderr, "bad banks\n");
				   break;
			   }
			   switch ((screen->tile_config & 0xc0) >> 6) {
			   case 0:
				   screen->group_bytes = 256;
				   break;
			   case 1:
				   screen->group_bytes = 512;
				   break;
			   default:
				   fprintf(stderr, "bad group_bytes\n");
				   break;
			   }
		   }
	   } else if ((sPriv->drm_version.minor >= 7) &&
		      (screen->chip_family >= CHIP_FAMILY_CEDAR)) {
		   ret = radeonGetParam(sPriv, RADEON_INFO_TILE_CONFIG, &temp);
		   if (ret)
			   fprintf(stderr, "failed to get tiling info\n");
		   else {
			   screen->tile_config = temp;
			   screen->r7xx_bank_op = 0;
			   switch (screen->tile_config & 0xf) {
			   case 0:
				   screen->num_channels = 1;
				   break;
			   case 1:
				   screen->num_channels = 2;
				   break;
			   case 2:
				   screen->num_channels = 4;
				   break;
			   case 3:
				   screen->num_channels = 8;
				   break;
			   default:
				   fprintf(stderr, "bad channels\n");
				   break;
			   }
			   switch ((screen->tile_config & 0xf0) >> 4) {
			   case 0:
				   screen->num_banks = 4;
				   break;
			   case 1:
				   screen->num_banks = 8;
				   break;
			   case 2:
				   screen->num_banks = 16;
				   break;
			   default:
				   fprintf(stderr, "bad banks\n");
				   break;
			   }
			   switch ((screen->tile_config & 0xf00) >> 8) {
			   case 0:
				   screen->group_bytes = 256;
				   break;
			   case 1:
				   screen->group_bytes = 512;
				   break;
			   default:
				   fprintf(stderr, "bad group_bytes\n");
				   break;
			   }
		   }
	   }
   }

   if (IS_R300_CLASS(screen)) {
       ret = radeonGetParam(sPriv, RADEON_PARAM_NUM_GB_PIPES, &temp);
       if (ret) {
	   fprintf(stderr, "Unable to get num_pipes, need newer drm\n");
	   switch (screen->chip_family) {
	   case CHIP_FAMILY_R300:
	   case CHIP_FAMILY_R350:
	       screen->num_gb_pipes = 2;
	       break;
	   case CHIP_FAMILY_R420:
	   case CHIP_FAMILY_R520:
	   case CHIP_FAMILY_R580:
	   case CHIP_FAMILY_RV560:
	   case CHIP_FAMILY_RV570:
	       screen->num_gb_pipes = 4;
	       break;
	   case CHIP_FAMILY_RV350:
	   case CHIP_FAMILY_RV515:
	   case CHIP_FAMILY_RV530:
	   case CHIP_FAMILY_RV410:
	   default:
	       screen->num_gb_pipes = 1;
	       break;
	   }
       } else {
	   screen->num_gb_pipes = temp;
       }

       /* pipe overrides */
       switch (device_id) {
       case PCI_CHIP_R300_AD: /* 9500 with 1 quadpipe verified by: Reid Linnemann <lreid@@cs.okstate.edu> */
       case PCI_CHIP_R350_AH: /* 9800 SE only have 1 quadpipe */
       case PCI_CHIP_RV410_5E4C: /* RV410 SE only have 1 quadpipe */
       case PCI_CHIP_RV410_5E4F: /* RV410 SE only have 1 quadpipe */
	   screen->num_gb_pipes = 1;
	   break;
       default:
	   break;
       }

       ret = radeonGetParam(sPriv, RADEON_PARAM_NUM_Z_PIPES, &temp);
       if (ret)
	       screen->num_z_pipes = 2;
       else
	       screen->num_z_pipes = temp;

   }

a518 2
   screen->extensions[i++] = &driCopySubBufferExtension.base;
   screen->extensions[i++] = &driReadDrawableExtension;
a520 5
   if ( screen->irq != 0 ) {
       screen->extensions[i++] = &driSwapControlExtension.base;
       screen->extensions[i++] = &driMediaStreamCounterExtension.base;
   }

d523 1
a523 3
#endif

#if defined(RADEON_R200)
a526 8
#if defined(RADEON_R300)
   screen->extensions[i++] = &r300TexBufferExtension.base;
#endif

#if defined(RADEON_R600)
   screen->extensions[i++] = &r600TexBufferExtension.base;
#endif

d547 1
a547 1
    radeonScreenPtr screen = (radeonScreenPtr)sPriv->private;
a551 1
    if (screen->kernel_mm) {
d553 1
a553 1
        radeon_tracker_print(&screen->bom->tracker, stderr);
d555 1
a555 10
        radeon_bo_manager_gem_dtor(screen->bom);
    } else {
        radeon_bo_manager_legacy_dtor(screen->bom);

        if ( screen->gartTextures.map ) {
            drmUnmap( screen->gartTextures.map, screen->gartTextures.size );
        }
        drmUnmapBufs( screen->buffers );
        drmUnmap( screen->status.map, screen->status.size );
    }
d560 2
a561 2
    FREE( screen );
    sPriv->private = NULL;
d570 2
a571 6
    if (sPriv->dri2.enabled) {
        sPriv->private = (void *) radeonCreateScreen2( sPriv );
    } else {
        sPriv->private = (void *) radeonCreateScreen( sPriv );
    }
    if ( !sPriv->private ) {
d593 1
a593 1
    radeonScreenPtr screen = (radeonScreenPtr) driScrnPriv->private;
d621 1
a621 1
    _mesa_add_renderbuffer(&rfb->base, BUFFER_FRONT_LEFT, &rfb->color_rb[0]->base);
d627 1
a627 1
	_mesa_add_renderbuffer(&rfb->base, BUFFER_BACK_LEFT, &rfb->color_rb[1]->base);
d635 2
a636 2
	_mesa_add_renderbuffer(&rfb->base, BUFFER_DEPTH, &depthStencilRb->base);
	_mesa_add_renderbuffer(&rfb->base, BUFFER_STENCIL, &depthStencilRb->base);
d642 1
a642 1
	_mesa_add_renderbuffer(&rfb->base, BUFFER_DEPTH, &depth->base);
d649 1
a649 1
	_mesa_add_renderbuffer(&rfb->base, BUFFER_DEPTH, &depth->base);
d653 1
a653 1
    _mesa_add_soft_renderbuffers(&rfb->base,
a700 52

/**
 * This is the driver specific part of the createNewScreen entry point.
 *
 * \todo maybe fold this into intelInitDriver
 *
 * \return the struct gl_config supported by this driver
 */
static const __DRIconfig **
radeonInitScreen(__DRIscreen *psp)
{
#if defined(RADEON_R100)
   static const char *driver_name = "Radeon";
   static const __DRIutilversion2 ddx_expected = { 4, 5, 0, 0 };
   static const __DRIversion dri_expected = { 4, 0, 0 };
   static const __DRIversion drm_expected = { 1, 6, 0 };
#elif defined(RADEON_R200)
   static const char *driver_name = "R200";
   static const __DRIutilversion2 ddx_expected = { 4, 5, 0, 0 };
   static const __DRIversion dri_expected = { 4, 0, 0 };
   static const __DRIversion drm_expected = { 1, 6, 0 };
#elif defined(RADEON_R300)
   static const char *driver_name = "R300";
   static const __DRIutilversion2 ddx_expected = { 4, 5, 0, 0 };
   static const __DRIversion dri_expected = { 4, 0, 0 };
   static const __DRIversion drm_expected = { 1, 24, 0 };
#elif defined(RADEON_R600)
   static const char *driver_name = "R600";
   static const __DRIutilversion2 ddx_expected = { 4, 5, 0, 0 };
   static const __DRIversion dri_expected = { 4, 0, 0 };
   static const __DRIversion drm_expected = { 1, 24, 0 };
#endif
   RADEONDRIPtr dri_priv = (RADEONDRIPtr) psp->pDevPriv;

   if ( ! driCheckDriDdxDrmVersions3( driver_name,
				      &psp->dri_version, & dri_expected,
				      &psp->ddx_version, & ddx_expected,
				      &psp->drm_version, & drm_expected ) ) {
      return NULL;
   }

   if (!radeonInitDriver(psp))
       return NULL;

   /* for now fill in all modes */
   return radeonFillInModes( psp,
			     dri_priv->bpp,
			     (dri_priv->bpp == 16) ? 16 : 24,
			     (dri_priv->bpp == 16) ? 0  : 8, 1);
}
#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))

d710 5
a714 2
   GLenum fb_format[3];
   GLenum fb_type[3];
d739 1
a739 10
   fb_format[0] = GL_RGB;
   fb_type[0] = GL_UNSIGNED_SHORT_5_6_5;

   fb_format[1] = GL_BGR;
   fb_type[1] = GL_UNSIGNED_INT_8_8_8_8_REV;

   fb_format[2] = GL_BGRA;
   fb_type[2] = GL_UNSIGNED_INT_8_8_8_8_REV;

   for (color = 0; color < ARRAY_SIZE(fb_format); color++) {
d742 1
a742 1
      new_configs = driCreateConfigs(fb_format[color], fb_type[color],
d751 1
a751 4
      if (configs == NULL)
	 configs = new_configs;
      else
	 configs = driConcatConfigs(configs, new_configs);
a762 26
/**
 * Get information about previous buffer swaps.
 */
static int
getSwapInfo( __DRIdrawable *dPriv, __DRIswapInfo * sInfo )
{
    struct radeon_framebuffer *rfb;

    if ( (dPriv == NULL) || (dPriv->driContextPriv == NULL)
	 || (dPriv->driContextPriv->driverPrivate == NULL)
	 || (sInfo == NULL) ) {
	return -1;
   }

    rfb = dPriv->driverPrivate;
    sInfo->swap_count = rfb->swap_count;
    sInfo->swap_ust = rfb->swap_ust;
    sInfo->swap_missed_count = rfb->swap_missed_count;

   sInfo->swap_missed_usage = (sInfo->swap_missed_count != 0)
       ? driCalculateSwapUsage( dPriv, 0, rfb->swap_missed_ust )
       : 0.0;

   return 0;
}

d764 1
a764 1
   .InitScreen      = radeonInitScreen,
a768 6
#elif defined(RADEON_R600)
   .CreateContext   = r600CreateContext,
   .DestroyContext  = radeonDestroyContext,
#elif defined(RADEON_R300)
   .CreateContext   = r300CreateContext,
   .DestroyContext  = radeonDestroyContext,
a774 1
   .SwapBuffers     = radeonSwapBuffers,
a776 8
   .GetSwapInfo     = getSwapInfo,
   .GetDrawableMSC  = driDrawableGetMSC32,
   .WaitForMSC      = driWaitForMSC32,
   .WaitForSBC      = NULL,
   .SwapBuffersMSC  = NULL,
   .CopySubBuffer   = radeonCopySubBuffer,
    /* DRI2 */
   .InitScreen2     = radeonInitScreen2,
a781 1
    &driLegacyExtension.base,
@


1.10
log
@Merge Mesa 7.10.3
@
text
@d404 1
a404 1
radeon_create_image_from_name(__DRIcontext *context,
d409 1
a409 1
   radeonContextPtr radeon = context->driverPrivate;
d445 1
a445 1
   image->bo = radeon_bo_open(radeon->radeonScreen->bom,
a630 1
   case PCI_CHIP_R200_BC:
d1171 19
d1220 1
d1235 1
@


1.9
log
@Two patches cherry picked from mesa master just after 7.8 was branched
(but never made it into the 7.8 branch).

first:
Author: Jesse Barnes <jbarnes@@virtuousgeek.org>
Date:   Thu Apr 22 12:47:41 2010 -0700

    DRI2: add config query extension

    Add a new DRI2 configuration query extension.  Allows for DRI2
    client code to query for common DRI2 configuration options.

second:
Author: Jesse Barnes <jbarnes@@virtuousgeek.org>
Date:   Thu Apr 22 12:49:03 2010 -0700

    DRI2/GLX: check for vblank_mode in DRI2 GLX code

    Re-add support for the vblank_mode environment and configuration
    variable.  Useful for benchmarking and app control.

The final affect being that config and environment variables for
controlling swap mode work with dri2 now. which helps me a lot with
debugging.

ok matthieu@@.
@
text
@d44 1
d51 1
a56 1
#include "r200_ioctl.h"
d218 4
d241 3
d263 1
a263 1
    __GLcontextModes *m;
a348 6
static const __DRIallocateExtension r200AllocateExtension = {
    { __DRI_ALLOCATE, __DRI_ALLOCATE_VERSION },
    r200AllocateMemoryMESA,
    r200FreeMemoryMESA,
    r200GetMemoryOffsetMESA
};
d388 197
d718 1
d1103 118
d1371 6
d1405 1
a1405 1
        {
a1512 1
   screen->extensions[i++] = &driFrameTrackingExtension.base;
a1524 3
   if (IS_R200_CLASS(screen))
      screen->extensions[i++] = &r200AllocateExtension.base;

d1616 108
a1773 1
   screen->extensions[i++] = &driFrameTrackingExtension.base;
d1775 1
a1786 3
   if (IS_R200_CLASS(screen))
       screen->extensions[i++] = &r200AllocateExtension.base;

d1798 3
d1875 1
a1875 1
                    const __GLcontextModes *mesaVis,
d1983 1
a1983 1
    _mesa_reference_framebuffer((GLframebuffer **)(&(driDrawPriv->driverPrivate)), NULL);
d1992 1
a1992 1
 * \return the __GLcontextModes supported by this driver
d2042 1
a2042 1
 * \return the __GLcontextModes supported by this driver
@


1.8
log
@Bring back the local patch that has a habit of vanishing every time we
update mesa.

Specifically, we disallow in radeondrm for dri clients mapping
registers, so don't try and map them (and thus fail as we currently
were). for r300+ this was only used for falling back on old drm versions
(doesn't matter). For r100, the new BO abstraction used the SWI number
(in hardware scratch reg 3) for the buffer age, so use the newly added
getparam member to grab that info instead of trying to read the mapped
registers.

Update to the lastest kernel headers  before you even think about
building this or trying to use a snapshot on r100/r200.

So now radeon works with mesa again, hoorah!

Tested on rv250 by Josh Elsasser, and on R420 (and x800) by myself.
@
text
@d1216 2
@


1.7
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a919 1
   unsigned char *RADEONMMIO = NULL;
a987 13
   screen->mmio.handle = dri_priv->registerHandle;
   screen->mmio.size   = dri_priv->registerSize;
   if ( drmMap( sPriv->fd,
		screen->mmio.handle,
		screen->mmio.size,
		&screen->mmio.map ) ) {
     FREE( screen );
     __driUtilMessage("%s: drmMap failed\n", __FUNCTION__ );
     return NULL;
   }

   RADEONMMIO = screen->mmio.map;

a993 1
     drmUnmap( screen->mmio.map, screen->mmio.size );
a1007 1
     drmUnmap( screen->mmio.map, screen->mmio.size );
a1021 1
       drmUnmap( screen->mmio.map, screen->mmio.size );
a1075 4
            if (screen->chip_family < CHIP_FAMILY_RS600 && !screen->kernel_mm)
	            screen->fbLocation      = ( INREG( RADEON_MC_FB_LOCATION ) & 0xffff) << 16;
            else
            {
a1078 1
            }
a1405 1
        drmUnmap( screen->mmio.map, screen->mmio.size );
@


1.6
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d38 1
d49 2
a50 1
#if !RADEON_COMMON
a51 1
#include "radeon_span.h"
d53 1
a53 1
#elif RADEON_COMMON && defined(RADEON_COMMON_FOR_R200)
a55 1
#include "r200_span.h"
d57 1
a57 1
#elif RADEON_COMMON && defined(RADEON_COMMON_FOR_R300)
a58 1
#include "r300_fragprog.h"
d60 4
a63 1
#include "radeon_span.h"
d68 2
a69 1
#include "drirenderbuffer.h"
d77 7
a83 1
#if !RADEON_COMMON	/* R100 */
d92 1
d108 1
a108 1
static const GLuint __driNConfigOptions = 14;
d110 1
a110 1
#elif RADEON_COMMON && defined(RADEON_COMMON_FOR_R200)
d120 1
d140 1
a140 1
static const GLuint __driNConfigOptions = 16;
d142 1
a142 5
extern const struct dri_extension blend_extensions[];
extern const struct dri_extension ARB_vp_extension[];
extern const struct dri_extension NV_vp_extension[];
extern const struct dri_extension ATI_fs_extension[];
extern const struct dri_extension point_extensions[];
d144 2
a145 1
#elif RADEON_COMMON && defined(RADEON_COMMON_FOR_R300)
d160 1
a160 5
#define DRI_CONF_COMMAND_BUFFER_SIZE(def,min,max) \
DRI_CONF_OPT_BEGIN_V(command_buffer_size,int,def, # min ":" # max ) \
        DRI_CONF_DESC(en,"Size of command buffer (in KB)") \
        DRI_CONF_DESC(de,"GrÃ¶sse des Befehlspuffers (in KB)") \
DRI_CONF_OPT_END
d213 1
a213 26
#ifndef RADEON_DEBUG
int RADEON_DEBUG = 0;

static const struct dri_debug_control debug_control[] = {
	{"fall", DEBUG_FALLBACKS},
	{"tex", DEBUG_TEXTURE},
	{"ioctl", DEBUG_IOCTL},
	{"prim", DEBUG_PRIMS},
	{"vert", DEBUG_VERTS},
	{"state", DEBUG_STATE},
	{"code", DEBUG_CODEGEN},
	{"vfmt", DEBUG_VFMT},
	{"vtxf", DEBUG_VFMT},
	{"verb", DEBUG_VERBOSE},
	{"dri", DEBUG_DRI},
	{"dma", DEBUG_DMA},
	{"san", DEBUG_SANITY},
	{"sync", DEBUG_SYNC},
	{"pix", DEBUG_PIXEL},
	{"mem", DEBUG_MEMORY},
	{"allmsg", ~DEBUG_SYNC}, /* avoid the term "sync" because the parser uses strstr */
	{NULL, 0}
};
#endif /* RADEON_DEBUG */

#endif /* RADEON_COMMON && defined(RADEON_COMMON_FOR_R300) */
d215 1
a215 3
extern const struct dri_extension card_extensions[];

static int getSwapInfo( __DRIdrawablePrivate *dPriv, __DRIswapInfo * sInfo );
d218 1
a218 1
radeonGetParam(int fd, int param, void *value)
d221 2
a222 1
  drm_radeon_getparam_t gp;
d224 19
a242 2
  gp.param = param;
  gp.value = value;
d244 2
a245 1
  ret = drmCommandWriteRead( fd, DRM_RADEON_GETPARAM, &gp, sizeof(gp));
d250 1
a250 1
radeonFillInModes( __DRIscreenPrivate *psp,
d271 1
a271 1

d280 1
a280 1
    stencil_bits_array[0] = 0;
d283 3
a285 1
    depth_buffer_factor = ((depth_bits != 0) || (stencil_bits != 0)) ? 2 : 1;
d295 2
a296 1
					  back_buffer_factor);
d299 2
a300 1
					    1, back_buffer_modes, 1);
d306 2
a307 1
				   back_buffer_modes, back_buffer_factor);
d327 1
a327 1
#if !RADEON_COMMON
d332 6
d340 1
a340 1
#if RADEON_COMMON && defined(RADEON_COMMON_FOR_R200)
d352 6
d360 1
a360 1
#if RADEON_COMMON && defined(RADEON_COMMON_FOR_R300)
d365 6
d373 5
a377 10
/* Create the device specific screen private data struct.
 */
static radeonScreenPtr
radeonCreateScreen( __DRIscreenPrivate *sPriv )
{
   radeonScreenPtr screen;
   RADEONDRIPtr dri_priv = (RADEONDRIPtr)sPriv->pDevPriv;
   int i;
   int ret;
   uint32_t temp;
d379 5
a383 15
   if (sPriv->devPrivSize != sizeof(RADEONDRIRec)) {
      fprintf(stderr,"\nERROR!  sizeof(RADEONDRIRec) does not match passed size from device driver\n");
      return GL_FALSE;
   }

   /* Allocate the private area */
   screen = (radeonScreenPtr) CALLOC( sizeof(*screen) );
   if ( !screen ) {
      __driUtilMessage("%s: Could not allocate memory for screen structure",
		       __FUNCTION__);
      return NULL;
   }

#if DO_DEBUG && RADEON_COMMON && defined(RADEON_COMMON_FOR_R300)
	RADEON_DEBUG = driParseDebugString(getenv("RADEON_DEBUG"), debug_control);
d386 8
a393 77
   /* parse information in __driConfigOptions */
   driParseOptionInfo (&screen->optionCache,
		       __driConfigOptions, __driNConfigOptions);

   /* This is first since which regions we map depends on whether or
    * not we are using a PCI card.
    */
   screen->card_type = (dri_priv->IsPCI ? RADEON_CARD_PCI : RADEON_CARD_AGP);
   {
      int ret;
      ret = radeonGetParam( sPriv->fd, RADEON_PARAM_GART_BUFFER_OFFSET,
			    &screen->gart_buffer_offset);

      if (ret) {
	 FREE( screen );
	 fprintf(stderr, "drm_radeon_getparam_t (RADEON_PARAM_GART_BUFFER_OFFSET): %d\n", ret);
	 return NULL;
      }

      ret = radeonGetParam( sPriv->fd, RADEON_PARAM_GART_BASE,
			    &screen->gart_base);
      if (ret) {
	 FREE( screen );
	 fprintf(stderr, "drm_radeon_getparam_t (RADEON_PARAM_GART_BASE): %d\n", ret);
	 return NULL;
      }

      ret = radeonGetParam( sPriv->fd, RADEON_PARAM_IRQ_NR,
			    &screen->irq);
      if (ret) {
	 FREE( screen );
	 fprintf(stderr, "drm_radeon_getparam_t (RADEON_PARAM_IRQ_NR): %d\n", ret);
	 return NULL;
      }
      screen->drmSupportsCubeMapsR200 = (sPriv->drm_version.minor >= 7);
      screen->drmSupportsBlendColor = (sPriv->drm_version.minor >= 11);
      screen->drmSupportsTriPerf = (sPriv->drm_version.minor >= 16);
      screen->drmSupportsFragShader = (sPriv->drm_version.minor >= 18);
      screen->drmSupportsPointSprites = (sPriv->drm_version.minor >= 13);
      screen->drmSupportsCubeMapsR100 = (sPriv->drm_version.minor >= 15);
      screen->drmSupportsVertexProgram = (sPriv->drm_version.minor >= 25);
   }

   screen->status.handle = dri_priv->statusHandle;
   screen->status.size   = dri_priv->statusSize;
   if ( drmMap( sPriv->fd,
		screen->status.handle,
		screen->status.size,
		&screen->status.map ) ) {
      FREE( screen );
      __driUtilMessage("%s: drmMap (2) failed\n", __FUNCTION__ );
      return NULL;
   }
   screen->scratch = (__volatile__ uint32_t *)
      ((GLubyte *)screen->status.map + RADEON_SCRATCH_REG_OFFSET);

   screen->buffers = drmMapBufs( sPriv->fd );
   if ( !screen->buffers ) {
      drmUnmap( screen->status.map, screen->status.size );
      FREE( screen );
      __driUtilMessage("%s: drmMapBufs failed\n", __FUNCTION__ );
      return NULL;
   }

   if ( dri_priv->gartTexHandle && dri_priv->gartTexMapSize ) {
      screen->gartTextures.handle = dri_priv->gartTexHandle;
      screen->gartTextures.size   = dri_priv->gartTexMapSize;
      if ( drmMap( sPriv->fd,
		   screen->gartTextures.handle,
		   screen->gartTextures.size,
		   (drmAddressPtr)&screen->gartTextures.map ) ) {
	 drmUnmapBufs( screen->buffers );
	 drmUnmap( screen->status.map, screen->status.size );
	 FREE( screen );
	 __driUtilMessage("%s: drmMap failed for GART texture area\n", __FUNCTION__);
	 return NULL;
      }
a394 6
      screen->gart_texture_offset = dri_priv->gartTexOffset + screen->gart_base;
   }

   screen->chip_flags = 0;
   /* XXX: add more chipsets */
   switch ( dri_priv->deviceID ) {
a398 2
   case PCI_CHIP_RN50_515E:
   case PCI_CHIP_RN50_5969:
a466 1

d724 179
d905 30
a934 1
	      dri_priv->deviceID);
d937 110
d1059 1
a1059 1
     screen->chip_flags &= ~RADEON_CHIPSET_TCL;
d1062 1
a1062 1
      screen->chip_flags |= RADEON_CLASS_R100;
d1064 3
a1066 1
      screen->chip_flags |= RADEON_CLASS_R200;
d1068 1
a1068 1
      screen->chip_flags |= RADEON_CLASS_R300;
d1073 33
a1105 8
   ret = radeonGetParam( sPriv->fd, RADEON_PARAM_FB_LOCATION,
                         &temp);
   if (ret) {
       FREE( screen );
       fprintf(stderr, "Unable to get fb location need newer drm\n");
       return NULL;
   } else {
       screen->fbLocation = (temp & 0xffff) << 16;
d1108 2
a1109 3
   if (screen->chip_family >= CHIP_FAMILY_R300) {
       ret = radeonGetParam( sPriv->fd, RADEON_PARAM_NUM_GB_PIPES,
			     &temp);
d1139 1
d1148 8
d1219 1
a1219 1
#if !RADEON_COMMON
d1223 1
a1223 1
#if RADEON_COMMON && defined(RADEON_COMMON_FOR_R200)
d1225 1
a1225 1
       screen->extensions[i++] = &r200AllocateExtension.base;
d1230 1
a1230 1
#if RADEON_COMMON && defined(RADEON_COMMON_FOR_R300)
d1234 4
d1243 159
d1408 1
a1408 1
radeonDestroyScreen( __DRIscreenPrivate *sPriv )
d1410 1
a1410 1
   radeonScreenPtr screen = (radeonScreenPtr)sPriv->private;
d1412 2
a1413 2
   if (!screen)
      return;
d1415 15
a1429 5
   if ( screen->gartTextures.map ) {
      drmUnmap( screen->gartTextures.map, screen->gartTextures.size );
   }
   drmUnmapBufs( screen->buffers );
   drmUnmap( screen->status.map, screen->status.size );
d1431 2
a1432 2
   /* free all option information */
   driDestroyOptionInfo (&screen->optionCache);
d1434 2
a1435 2
   FREE( screen );
   sPriv->private = NULL;
d1442 1
a1442 1
radeonInitDriver( __DRIscreenPrivate *sPriv )
d1444 9
a1452 5
   sPriv->private = (void *) radeonCreateScreen( sPriv );
   if ( !sPriv->private ) {
      radeonDestroyScreen( sPriv );
      return GL_FALSE;
   }
d1454 1
a1454 1
   return GL_TRUE;
d1458 1
d1466 2
a1467 2
radeonCreateBuffer( __DRIscreenPrivate *driScrnPriv,
                    __DRIdrawablePrivate *driDrawPriv,
d1471 1
a1471 1
   radeonScreenPtr screen = (radeonScreenPtr) driScrnPriv->private;
d1473 9
a1481 1
   if (isPixmap) {
a1482 20
   }
   else {
      const GLboolean swDepth = GL_FALSE;
      const GLboolean swAlpha = GL_FALSE;
      const GLboolean swAccum = mesaVis->accumRedBits > 0;
      const GLboolean swStencil = mesaVis->stencilBits > 0 &&
         mesaVis->depthBits != 24;
      struct gl_framebuffer *fb = _mesa_create_framebuffer(mesaVis);

      /* front color renderbuffer */
      {
         driRenderbuffer *frontRb
            = driNewRenderbuffer(GL_RGBA,
                                 driScrnPriv->pFB + screen->frontOffset,
                                 screen->cpp,
                                 screen->frontOffset, screen->frontPitch,
                                 driDrawPriv);
         radeonSetSpanFunctions(frontRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_FRONT_LEFT, &frontRb->Base);
      }
d1484 5
a1488 11
      /* back color renderbuffer */
      if (mesaVis->doubleBufferMode) {
         driRenderbuffer *backRb
            = driNewRenderbuffer(GL_RGBA,
                                 driScrnPriv->pFB + screen->backOffset,
                                 screen->cpp,
                                 screen->backOffset, screen->backPitch,
                                 driDrawPriv);
         radeonSetSpanFunctions(backRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_BACK_LEFT, &backRb->Base);
      }
d1490 18
a1507 23
      /* depth renderbuffer */
      if (mesaVis->depthBits == 16) {
         driRenderbuffer *depthRb
            = driNewRenderbuffer(GL_DEPTH_COMPONENT16,
                                 driScrnPriv->pFB + screen->depthOffset,
                                 screen->cpp,
                                 screen->depthOffset, screen->depthPitch,
                                 driDrawPriv);
         radeonSetSpanFunctions(depthRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthRb->Base);
	 depthRb->depthHasSurface = screen->depthHasSurface;
      }
      else if (mesaVis->depthBits == 24) {
         driRenderbuffer *depthRb
            = driNewRenderbuffer(GL_DEPTH_COMPONENT24,
                                 driScrnPriv->pFB + screen->depthOffset,
                                 screen->cpp,
                                 screen->depthOffset, screen->depthPitch,
                                 driDrawPriv);
         radeonSetSpanFunctions(depthRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthRb->Base);
	 depthRb->depthHasSurface = screen->depthHasSurface;
      }
d1509 13
a1521 11
      /* stencil renderbuffer */
      if (mesaVis->stencilBits > 0 && !swStencil) {
         driRenderbuffer *stencilRb
            = driNewRenderbuffer(GL_STENCIL_INDEX8_EXT,
                                 driScrnPriv->pFB + screen->depthOffset,
                                 screen->cpp,
                                 screen->depthOffset, screen->depthPitch,
                                 driDrawPriv);
         radeonSetSpanFunctions(stencilRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_STENCIL, &stencilRb->Base);
	 stencilRb->depthHasSurface = screen->depthHasSurface;
d1523 7
d1531 8
a1538 8
      _mesa_add_soft_renderbuffers(fb,
                                   GL_FALSE, /* color */
                                   swDepth,
                                   swStencil,
                                   swAccum,
                                   swAlpha,
                                   GL_FALSE /* aux */);
      driDrawPriv->driverPrivate = (void *) fb;
d1540 1
a1540 2
      return (driDrawPriv->driverPrivate != NULL);
   }
d1544 1
a1544 2
static void
radeonDestroyBuffer(__DRIdrawablePrivate *driDrawPriv)
d1546 1
a1546 2
   _mesa_unreference_framebuffer((GLframebuffer **)(&(driDrawPriv->driverPrivate)));
}
d1548 15
a1562 15
#if RADEON_COMMON && defined(RADEON_COMMON_FOR_R300)
/**
 * Choose the appropriate CreateContext function based on the chipset.
 * Eventually, all drivers will go through this process.
 */
static GLboolean radeonCreateContext(const __GLcontextModes * glVisual,
				     __DRIcontextPrivate * driContextPriv,
				     void *sharedContextPriv)
{
	__DRIscreenPrivate *sPriv = driContextPriv->driScreenPriv;
	radeonScreenPtr screen = (radeonScreenPtr) (sPriv->private);

	if (IS_R300_CLASS(screen))
		return r300CreateContext(glVisual, driContextPriv, sharedContextPriv);
        return GL_FALSE;
d1565 2
a1566 4
/**
 * Choose the appropriate DestroyContext function based on the chipset.
 */
static void radeonDestroyContext(__DRIcontextPrivate * driContextPriv)
d1568 9
a1576 4
	radeonContextPtr radeon = (radeonContextPtr) driContextPriv->driverPrivate;

	if (IS_R300_CLASS(radeon->radeonScreen))
		return r300DestroyContext(driContextPriv);
a1579 2
#endif

d1588 1
a1588 1
radeonInitScreen(__DRIscreenPrivate *psp)
d1590 1
a1590 1
#if !RADEON_COMMON
d1595 1
a1595 1
#elif RADEON_COMMON && defined(RADEON_COMMON_FOR_R200)
d1600 1
a1600 1
#elif RADEON_COMMON && defined(RADEON_COMMON_FOR_R300)
d1605 5
a1619 19
   /* Calling driInitExtensions here, with a NULL context pointer,
    * does not actually enable the extensions.  It just makes sure
    * that all the dispatch offsets for all the extensions that
    * *might* be enables are known.  This is needed because the
    * dispatch offsets need to be known when _mesa_context_create
    * is called, but we can't enable the extensions until we have a
    * context pointer.
    *
    * Hello chicken.  Hello egg.  How are you two today?
    */
   driInitExtensions( NULL, card_extensions, GL_FALSE );
#if RADEON_COMMON && defined(RADEON_COMMON_FOR_R200)
   driInitExtensions( NULL, blend_extensions, GL_FALSE );
   driInitSingleExtension( NULL, ARB_vp_extension );
   driInitSingleExtension( NULL, NV_vp_extension );
   driInitSingleExtension( NULL, ATI_fs_extension );
   driInitExtensions( NULL, point_extensions, GL_FALSE );
#endif

d1623 1
d1627 1
a1627 2
			     (dri_priv->bpp == 16) ? 0  : 8,
			     (dri_priv->backOffset != dri_priv->depthOffset) );
d1629 1
d1631 70
d1706 1
a1706 1
getSwapInfo( __DRIdrawablePrivate *dPriv, __DRIswapInfo * sInfo )
d1708 1
a1708 5
#if !RADEON_COMMON || (RADEON_COMMON && defined(RADEON_COMMON_FOR_R300))
   radeonContextPtr  rmesa;
#elif RADEON_COMMON && defined(RADEON_COMMON_FOR_R200)
   r200ContextPtr  rmesa;
#endif
d1710 4
a1713 4
   if ( (dPriv == NULL) || (dPriv->driContextPriv == NULL)
	|| (dPriv->driContextPriv->driverPrivate == NULL)
	|| (sInfo == NULL) ) {
      return -1;
d1716 4
a1719 4
   rmesa = dPriv->driContextPriv->driverPrivate;
   sInfo->swap_count = rmesa->swap_count;
   sInfo->swap_ust = rmesa->swap_ust;
   sInfo->swap_missed_count = rmesa->swap_missed_count;
d1722 1
a1722 1
       ? driCalculateSwapUsage( dPriv, 0, rmesa->swap_missed_ust )
a1727 1
#if !RADEON_COMMON || (RADEON_COMMON && defined(RADEON_COMMON_FOR_R300))
d1731 11
a1741 1
   .CreateContext   = radeonCreateContext,
d1743 1
d1755 2
d1758 7
a1764 17
#else
const struct __DriverAPIRec driDriverAPI = {
   .InitScreen      = radeonInitScreen,
   .DestroyScreen   = radeonDestroyScreen,
   .CreateContext   = r200CreateContext,
   .DestroyContext  = r200DestroyContext,
   .CreateBuffer    = radeonCreateBuffer,
   .DestroyBuffer   = radeonDestroyBuffer,
   .SwapBuffers     = r200SwapBuffers,
   .MakeCurrent     = r200MakeCurrent,
   .UnbindContext   = r200UnbindContext,
   .GetSwapInfo     = getSwapInfo,
   .GetDrawableMSC  = driDrawableGetMSC32,
   .WaitForMSC      = driWaitForMSC32,
   .WaitForSBC      = NULL,
   .SwapBuffersMSC  = NULL,
   .CopySubBuffer   = r200CopySubBuffer,
a1765 1
#endif
@


1.5
log
@For the radeon mesa driver, don't try and map the card's mmio region. We
really don't need it. There's one case where it's used, and that is on
``older'' drms, newer ones provide that one value via a parameter.

This is the first stage in my project to stop all cards mapping
registers. This does mean that drivers that depend on this may
eventually die (tdfx, i'm looking at you!).

ok matthieu@@
@
text
@a0 1
/* $XFree86: xc/lib/GL/mesa/src/drv/radeon/radeon_screen.c,v 1.7 2003/03/26 20:43:51 tsi Exp $ */
d38 5
a42 5
#include "glheader.h"
#include "imports.h"
#include "mtypes.h"
#include "framebuffer.h"
#include "renderbuffer.h"
a64 1
#include "context.h"
a261 2
    GLenum fb_format;
    GLenum fb_type;
d273 2
a274 2
    u_int8_t depth_bits_array[2];
    u_int8_t stencil_bits_array[2];
d290 17
a306 8
    if ( pixel_bits == 16 ) {
        fb_format = GL_RGB;
        fb_type = GL_UNSIGNED_SHORT_5_6_5;
    }
    else {
        fb_format = GL_BGRA;
        fb_type = GL_UNSIGNED_INT_8_8_8_8_REV;
    }
a307 4
    configs = driCreateConfigs(fb_format, fb_type,
			       depth_bits_array, stencil_bits_array,
			       depth_buffer_factor,
			       back_buffer_modes, back_buffer_factor);
d435 1
a435 1
   screen->scratch = (__volatile__ u_int32_t *)
d540 1
a540 1
      /* 9500 with 1 pipe verified by: Reid Linnemann <lreid@@cs.okstate.edu> */
a541 3
      screen->chip_family = CHIP_FAMILY_RV350;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;
d666 6
d830 3
a832 3
           FREE( screen );
           fprintf(stderr, "Unable to get fb location need newer drm\n");
           return NULL;
d837 1
a837 1
   if (screen->chip_family >= CHIP_FAMILY_RV515) {
d865 12
d900 1
a900 1
      ((screen->chip_family & RADEON_CLASS_R100) &&
@


1.4
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a359 1
   unsigned char *RADEONMMIO;
a423 13
   screen->mmio.handle = dri_priv->registerHandle;
   screen->mmio.size   = dri_priv->registerSize;
   if ( drmMap( sPriv->fd,
		screen->mmio.handle,
		screen->mmio.size,
		&screen->mmio.map ) ) {
      FREE( screen );
      __driUtilMessage("%s: drmMap failed\n", __FUNCTION__ );
      return NULL;
   }

   RADEONMMIO = screen->mmio.map;

a429 1
      drmUnmap( screen->mmio.map, screen->mmio.size );
a439 1
      drmUnmap( screen->mmio.map, screen->mmio.size );
a453 1
	 drmUnmap( screen->mmio.map, screen->mmio.size );
a825 3
       if (screen->chip_family < CHIP_FAMILY_RS690)
	   screen->fbLocation      = ( INREG( RADEON_MC_FB_LOCATION ) & 0xffff) << 16;
       else {
a828 1
       }
a961 1
   drmUnmap( screen->mmio.map, screen->mmio.size );
@


1.3
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d52 1
d94 1
a94 1
        DRI_CONF_ALLOW_LARGE_TEXTURES(1)
d121 1
a121 1
        DRI_CONF_ALLOW_LARGE_TEXTURES(1)
d183 1
a183 1
const char __driConfigOptions[] =
d192 1
a192 1
		DRI_CONF_DISABLE_FALLBACK(false)
d198 1
a198 2
		DRI_CONF_NO_NEG_LOD_BIAS(false)
                DRI_CONF_FORCE_S3TC_ENABLE(false)
d209 1
a209 1
static const GLuint __driNConfigOptions = 18;
d247 1
a247 1
  
d250 1
a250 1
  
d255 4
a258 3
static __GLcontextModes *
radeonFillInModes( unsigned pixel_bits, unsigned depth_bits,
		 unsigned stencil_bits, GLboolean have_back_buffer )
d260 2
a261 3
    __GLcontextModes * modes;
    __GLcontextModes * m;
    unsigned num_modes;
d266 1
d283 1
a283 1
    
a293 2
    num_modes = depth_buffer_factor * back_buffer_factor * 4;

d303 5
a307 15
    modes = (*dri_interface->createContextModes)( num_modes, sizeof( __GLcontextModes ) );
    m = modes;
    if ( ! driFillInModes( & m, fb_format, fb_type,
			   depth_bits_array, stencil_bits_array, depth_buffer_factor,
			   back_buffer_modes, back_buffer_factor,
			   GLX_TRUE_COLOR ) ) {
	fprintf( stderr, "[%s:%u] Error creating FBConfig!\n",
		 __func__, __LINE__ );
	return NULL;
    }

    if ( ! driFillInModes( & m, fb_format, fb_type,
			   depth_bits_array, stencil_bits_array, depth_buffer_factor,
			   back_buffer_modes, back_buffer_factor,
			   GLX_DIRECT_COLOR ) ) {
d315 3
a317 2
    for ( m = modes ; m != NULL ; m = m->next ) {
	if ( (m->stencilBits != 0) && (m->stencilBits != stencil_bits) ) {
d322 1
a322 1
    return modes;
d325 27
d361 3
a363 3
   PFNGLXSCRENABLEEXTENSIONPROC glx_enable_extension =
     (PFNGLXSCRENABLEEXTENSIONPROC) (*dri_interface->getProcAddress("glxEnableExtension"));
   void * const psc = sPriv->psc->screenConfigs;
d394 1
a394 1
	
d416 7
a422 7
      screen->drmSupportsCubeMapsR200 = (sPriv->drmMinor >= 7);
      screen->drmSupportsBlendColor = (sPriv->drmMinor >= 11);
      screen->drmSupportsTriPerf = (sPriv->drmMinor >= 16);
      screen->drmSupportsFragShader = (sPriv->drmMinor >= 18);
      screen->drmSupportsPointSprites = (sPriv->drmMinor >= 13);
      screen->drmSupportsCubeMapsR100 = (sPriv->drmMinor >= 15);
      screen->drmSupportsVertexProgram = (sPriv->drmMinor >= 25);
d556 1
d558 3
a608 1
   case PCI_CHIP_RV370_5657:
a657 1
   /* RV410 SE chips have half the pipes of regular RV410 */
a659 4
      screen->chip_family = CHIP_FAMILY_RV380;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

d665 1
d683 126
a808 1
      fprintf(stderr, "Warning, xpress200 detected.\n");
d817 1
a817 1
       sPriv->ddxMinor < 2) {
d822 8
d840 43
a882 1
   screen->fbLocation	= ( INREG( RADEON_MC_FB_LOCATION ) & 0xffff ) << 16;
d884 1
a884 1
   if ( sPriv->drmMinor >= 10 ) {
d902 1
a902 1
   screen->depthHasSurface = (sPriv->ddxMajor > 4) ||
d935 13
a947 6
   if ( glx_enable_extension != NULL ) {
      if ( screen->irq != 0 ) {
	 (*glx_enable_extension)( psc, "GLX_SGI_swap_control" );
	 (*glx_enable_extension)( psc, "GLX_SGI_video_sync" );
	 (*glx_enable_extension)( psc, "GLX_MESA_swap_control" );
      }
d949 3
a951 3
      (*glx_enable_extension)( psc, "GLX_MESA_swap_frame_usage" );
      if (IS_R200_CLASS(screen))
	 (*glx_enable_extension)( psc, "GLX_MESA_allocate_memory" );
d953 2
a954 3
      (*glx_enable_extension)( psc, "GLX_MESA_copy_sub_buffer" );
      (*glx_enable_extension)( psc, "GLX_SGI_make_current_read" );
   }
d956 2
a957 6
#if RADEON_COMMON && defined(RADEON_COMMON_FOR_R200)
   if (IS_R200_CLASS(screen)) {
      sPriv->psc->allocateMemory = (void *) r200AllocateMemoryMESA;
      sPriv->psc->freeMemory     = (void *) r200FreeMemoryMESA;
      sPriv->psc->memoryOffset   = (void *) r200GetMemoryOffsetMESA;
   }
d960 3
a1144 42
#if !RADEON_COMMON || (RADEON_COMMON && defined(RADEON_COMMON_FOR_R300))
static struct __DriverAPIRec radeonAPI = {
   .InitDriver      = radeonInitDriver,
   .DestroyScreen   = radeonDestroyScreen,
   .CreateContext   = radeonCreateContext,
   .DestroyContext  = radeonDestroyContext,
   .CreateBuffer    = radeonCreateBuffer,
   .DestroyBuffer   = radeonDestroyBuffer,
   .SwapBuffers     = radeonSwapBuffers,
   .MakeCurrent     = radeonMakeCurrent,
   .UnbindContext   = radeonUnbindContext,
   .GetSwapInfo     = getSwapInfo,
   .GetMSC          = driGetMSC32,
   .WaitForMSC      = driWaitForMSC32,
   .WaitForSBC      = NULL,
   .SwapBuffersMSC  = NULL,
   .CopySubBuffer   = radeonCopySubBuffer,
#if RADEON_COMMON && defined(RADEON_COMMON_FOR_R300)
   .setTexOffset    = r300SetTexOffset,
#endif
};
#else
static const struct __DriverAPIRec r200API = {
   .InitDriver      = radeonInitDriver,
   .DestroyScreen   = radeonDestroyScreen,
   .CreateContext   = r200CreateContext,
   .DestroyContext  = r200DestroyContext,
   .CreateBuffer    = radeonCreateBuffer,
   .DestroyBuffer   = radeonDestroyBuffer,
   .SwapBuffers     = r200SwapBuffers,
   .MakeCurrent     = r200MakeCurrent,
   .UnbindContext   = r200UnbindContext,
   .GetSwapInfo     = getSwapInfo,
   .GetMSC          = driGetMSC32,
   .WaitForMSC      = driWaitForMSC32,
   .WaitForSBC      = NULL,
   .SwapBuffersMSC  = NULL,
   .CopySubBuffer   = r200CopySubBuffer,
   .setTexOffset    = r200SetTexOffset
};
#endif

d1146 3
a1148 5
 * This is the bootstrap function for the driver.  libGL supplies all of the
 * requisite information about the system, and the driver initializes itself.
 * This routine also fills in the linked list pointed to by \c driver_modes
 * with the \c __GLcontextModes that the driver can support for windows or
 * pbuffers.
d1150 1
a1150 2
 * \return A pointer to a \c __DRIscreenPrivate on success, or \c NULL on 
 *         failure.
d1152 2
a1153 12
PUBLIC void *
__driCreateNewScreen_20050727( __DRInativeDisplay *dpy,
                             int scrn, __DRIscreen *psc,
			     const __GLcontextModes * modes,
			     const __DRIversion * ddx_version,
			     const __DRIversion * dri_version,
			     const __DRIversion * drm_version,
			     const __DRIframebuffer * frame_buffer,
			     drmAddress pSAREA, int fd,
			     int internal_api_version,
			     const __DRIinterfaceMethods * interface,
			     __GLcontextModes ** driver_modes )
a1154 1
   __DRIscreenPrivate *psp;
d1171 1
a1171 2

   dri_interface = interface;
d1174 3
a1176 3
				      dri_version, & dri_expected,
				      ddx_version, & ddx_expected,
				      drm_version, & drm_expected ) ) {
a1178 11
#if !RADEON_COMMON || (RADEON_COMMON && defined(RADEON_COMMON_FOR_R300))
   psp = __driUtilCreateNewScreen(dpy, scrn, psc, NULL,
				  ddx_version, dri_version, drm_version,
				  frame_buffer, pSAREA, fd,
				  internal_api_version, &radeonAPI);
#elif RADEON_COMMON && defined(RADEON_COMMON_FOR_R200)
   psp = __driUtilCreateNewScreen(dpy, scrn, psc, NULL,
				  ddx_version, dri_version, drm_version,
				  frame_buffer, pSAREA, fd,
				  internal_api_version, &r200API);
#endif
d1180 11
a1190 20
   if ( psp != NULL ) {
      RADEONDRIPtr dri_priv = (RADEONDRIPtr) psp->pDevPriv;
      if (driver_modes) {
         *driver_modes = radeonFillInModes( dri_priv->bpp,
                                            (dri_priv->bpp == 16) ? 16 : 24,
                                            (dri_priv->bpp == 16) ? 0  : 8,
                                            (dri_priv->backOffset != dri_priv->depthOffset) );
      }

      /* Calling driInitExtensions here, with a NULL context pointer,
       * does not actually enable the extensions.  It just makes sure
       * that all the dispatch offsets for all the extensions that
       * *might* be enables are known.  This is needed because the
       * dispatch offsets need to be known when _mesa_context_create
       * is called, but we can't enable the extensions until we have a
       * context pointer.
       *
       * Hello chicken.  Hello egg.  How are you two today?
       */
      driInitExtensions( NULL, card_extensions, GL_FALSE );
d1192 5
a1196 5
      driInitExtensions( NULL, blend_extensions, GL_FALSE );
      driInitSingleExtension( NULL, ARB_vp_extension );
      driInitSingleExtension( NULL, NV_vp_extension );
      driInitSingleExtension( NULL, ATI_fs_extension );
      driInitExtensions( NULL, point_extensions, GL_FALSE );
a1197 1
   }
d1199 8
a1206 1
   return (void *) psp;
d1239 38
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d588 1
d638 7
a652 1
   case PCI_CHIP_RV410_5E4C:
a653 1
   case PCI_CHIP_RV410_5E4F:
d711 5
a715 2
   screen->depthHasSurface = ((sPriv->ddxMajor > 4) &&
      (screen->chip_flags & RADEON_CHIPSET_TCL));
@


1.1
log
@Initial revision
@
text
@d56 1
d59 2
d136 1
d169 12
d192 1
d203 1
d209 1
a209 1
static const GLuint __driNConfigOptions = 16;
d661 1
a661 1
      fprintf(stderr, "Warning, xpress200 detected. Probably won't work.\n");
d747 1
d906 1
a906 1
   _mesa_destroy_framebuffer((GLframebuffer *) (driDrawPriv->driverPrivate));
d957 3
d977 2
a978 1
   .CopySubBuffer   = r200CopySubBuffer
d1068 1
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a132 1
extern const struct dri_extension point_extensions[];
a728 1
      (*glx_enable_extension)( psc, "GLX_SGI_make_current_read" );
a1044 1
      driInitExtensions( NULL, point_extensions, GL_FALSE );
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@a57 2
#include "r300_fragprog.h"
#include "r300_tex.h"
a165 12
#define DRI_CONF_DISABLE_DOUBLE_SIDE_STENCIL(def) \
DRI_CONF_OPT_BEGIN(disable_stencil_two_side,bool,def) \
        DRI_CONF_DESC(en,"Disable GL_EXT_stencil_two_side") \
DRI_CONF_OPT_END

#define DRI_CONF_FP_OPTIMIZATION(def) \
DRI_CONF_OPT_BEGIN_V(fp_optimization,enum,def,"0:1") \
	DRI_CONF_DESC_BEGIN(en,"Fragment Program optimization") \
                DRI_CONF_ENUM(0,"Optimize for Speed") \
                DRI_CONF_ENUM(1,"Optimize for Quality") \
        DRI_CONF_DESC_END \
DRI_CONF_OPT_END
a176 1
		DRI_CONF_DISABLE_DOUBLE_SIDE_STENCIL(false)
a186 1
		DRI_CONF_FP_OPTIMIZATION(DRI_CONF_FP_OPTIMIZATION_SPEED)
d192 1
a192 1
static const GLuint __driNConfigOptions = 18;
d644 1
a644 1
      fprintf(stderr, "Warning, xpress200 detected.\n");
d889 1
a889 1
   _mesa_unreference_framebuffer((GLframebuffer **)(&(driDrawPriv->driverPrivate)));
a939 3
#if RADEON_COMMON && defined(RADEON_COMMON_FOR_R300)
   .setTexOffset    = r300SetTexOffset,
#endif
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d1 1
d39 5
a43 7
#include <errno.h>
#include "main/glheader.h"
#include "main/imports.h"
#include "main/mtypes.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
#include "main/fbobject.h"
d49 1
a49 3
#include "radeon_common.h"
#include "radeon_common_context.h"
#if defined(RADEON_R100)
d51 2
a52 2
#include "radeon_tex.h"
#elif defined(RADEON_R200)
d54 3
a56 2
#include "r200_tex.h"
#elif defined(RADEON_R300)
d58 1
d60 1
a60 4
#elif defined(RADEON_R600)
#include "r600_context.h"
#include "r700_driconf.h" /* +r6/r7 */
#include "r600_tex.h"     /* +r6/r7 */
d64 1
d66 1
a66 2

#include "radeon_bocs_wrapper.h"
d74 1
a74 7
#define DRI_CONF_COMMAND_BUFFER_SIZE(def,min,max) \
DRI_CONF_OPT_BEGIN_V(command_buffer_size,int,def, # min ":" # max ) \
        DRI_CONF_DESC(en,"Size of command buffer (in KB)") \
        DRI_CONF_DESC(de,"GrÃ¶sse des Befehlspuffers (in KB)") \
DRI_CONF_OPT_END

#if defined(RADEON_R100)	/* R100 */
a82 1
        DRI_CONF_COMMAND_BUFFER_SIZE(8, 8, 32)
d92 1
a92 1
        DRI_CONF_ALLOW_LARGE_TEXTURES(2)
d98 1
a98 1
static const GLuint __driNConfigOptions = 15;
d100 1
a100 1
#elif defined(RADEON_R200)
a109 1
        DRI_CONF_COMMAND_BUFFER_SIZE(8, 8, 32)
d119 1
a119 1
        DRI_CONF_ALLOW_LARGE_TEXTURES(2)
d129 1
a129 1
static const GLuint __driNConfigOptions = 17;
d131 5
a135 1
#elif defined(RADEON_R300) || defined(RADEON_R600)
d137 1
a137 2
#define DRI_CONF_FP_OPTIMIZATION_SPEED   0
#define DRI_CONF_FP_OPTIMIZATION_QUALITY 1
d152 5
a156 1

d181 1
a181 1
PUBLIC const char __driConfigOptions[] =
d190 1
a190 1
		DRI_CONF_DISABLE_FALLBACK(true)
d196 2
a197 1
		DRI_CONF_FORCE_S3TC_ENABLE(false)
d208 4
a211 1
static const GLuint __driNConfigOptions = 17;
d213 23
a235 1
#endif
d237 1
a237 1
static int getSwapInfo( __DRIdrawable *dPriv, __DRIswapInfo * sInfo );
d239 1
a239 3
#ifndef RADEON_INFO_TILE_CONFIG
#define RADEON_INFO_TILE_CONFIG 0x6
#endif
d242 1
a242 1
radeonGetParam(__DRIscreen *sPriv, int param, void *value)
d245 6
a250 28
  drm_radeon_getparam_t gp = { 0 };
  struct drm_radeon_info info = { 0 };

  if (sPriv->drm_version.major >= 2) {
      info.value = (uint64_t)(uintptr_t)value;
      switch (param) {
      case RADEON_PARAM_DEVICE_ID:
          info.request = RADEON_INFO_DEVICE_ID;
          break;
      case RADEON_PARAM_NUM_GB_PIPES:
          info.request = RADEON_INFO_NUM_GB_PIPES;
          break;
      case RADEON_PARAM_NUM_Z_PIPES:
          info.request = RADEON_INFO_NUM_Z_PIPES;
          break;
      case RADEON_INFO_TILE_CONFIG:
	  info.request = RADEON_INFO_TILE_CONFIG;
          break;
      default:
          return -EINVAL;
      }
      ret = drmCommandWriteRead(sPriv->fd, DRM_RADEON_INFO, &info, sizeof(info));
  } else {
      gp.param = param;
      gp.value = value;

      ret = drmCommandWriteRead(sPriv->fd, DRM_RADEON_GETPARAM, &gp, sizeof(gp));
  }
d254 3
a256 4
static const __DRIconfig **
radeonFillInModes( __DRIscreen *psp,
		   unsigned pixel_bits, unsigned depth_bits,
		   unsigned stencil_bits, GLboolean have_back_buffer )
d258 3
a260 2
    __DRIconfig **configs;
    struct gl_config *m;
d263 2
a264 1
    int i;
d275 3
a277 3
    uint8_t depth_bits_array[2];
    uint8_t stencil_bits_array[2];
    uint8_t msaa_samples_array[1];
d281 1
a281 1

d286 1
a286 1
    stencil_bits_array[0] = stencil_bits;
d289 1
a289 3
    msaa_samples_array[0] = 0;

    depth_buffer_factor = (stencil_bits == 0) ? 2 : 1;
d292 1
a292 20
    if (pixel_bits == 16) {
	__DRIconfig **configs_a8r8g8b8;
	__DRIconfig **configs_r5g6b5;

	configs_r5g6b5 = driCreateConfigs(GL_RGB, GL_UNSIGNED_SHORT_5_6_5,
					  depth_bits_array, stencil_bits_array,
					  depth_buffer_factor, back_buffer_modes,
					  back_buffer_factor, msaa_samples_array,
					  1, GL_TRUE);
	configs_a8r8g8b8 = driCreateConfigs(GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV,
					    depth_bits_array, stencil_bits_array,
					    1, back_buffer_modes, 1,
					    msaa_samples_array, 1, GL_TRUE);
	configs = driConcatConfigs(configs_r5g6b5, configs_a8r8g8b8);
   } else
	configs = driCreateConfigs(GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV,
				   depth_bits_array, stencil_bits_array,
				   depth_buffer_factor,
				   back_buffer_modes, back_buffer_factor,
				   msaa_samples_array, 1, GL_TRUE);
d294 24
a317 1
    if (configs == NULL) {
d325 2
a326 3
    for (i = 0; configs[i]; i++) {
	m = &configs[i]->modes;
	if ((m->stencilBits != 0) && (m->stencilBits != stencil_bits)) {
d331 1
a331 1
    return (const __DRIconfig **) configs;
a333 5
#if defined(RADEON_R100)
static const __DRItexOffsetExtension radeonTexOffsetExtension = {
    { __DRI_TEX_OFFSET, __DRI_TEX_OFFSET_VERSION },
    radeonSetTexOffset,
};
d335 11
a345 6
static const __DRItexBufferExtension radeonTexBufferExtension = {
    { __DRI_TEX_BUFFER, __DRI_TEX_BUFFER_VERSION },
   radeonSetTexBuffer,
   radeonSetTexBuffer2,
};
#endif
d347 4
a350 1
#if defined(RADEON_R200)
d352 7
a358 4
static const __DRItexOffsetExtension r200texOffsetExtension = {
    { __DRI_TEX_OFFSET, __DRI_TEX_OFFSET_VERSION },
   r200SetTexOffset,
};
d360 2
a361 5
static const __DRItexBufferExtension r200TexBufferExtension = {
    { __DRI_TEX_BUFFER, __DRI_TEX_BUFFER_VERSION },
   r200SetTexBuffer,
   r200SetTexBuffer2,
};
d364 3
a366 5
#if defined(RADEON_R300)
static const __DRItexOffsetExtension r300texOffsetExtension = {
    { __DRI_TEX_OFFSET, __DRI_TEX_OFFSET_VERSION },
   r300SetTexOffset,
};
d368 14
a381 6
static const __DRItexBufferExtension r300TexBufferExtension = {
    { __DRI_TEX_BUFFER, __DRI_TEX_BUFFER_VERSION },
   r300SetTexBuffer,
   r300SetTexBuffer2,
};
#endif
d383 7
a389 5
#if defined(RADEON_R600)
static const __DRItexOffsetExtension r600texOffsetExtension = {
    { __DRI_TEX_OFFSET, __DRI_TEX_OFFSET_VERSION },
   r600SetTexOffset, /* +r6/r7 */
};
d391 14
a404 56
static const __DRItexBufferExtension r600TexBufferExtension = {
    { __DRI_TEX_BUFFER, __DRI_TEX_BUFFER_VERSION },
   r600SetTexBuffer,  /* +r6/r7 */
   r600SetTexBuffer2, /* +r6/r7 */
};
#endif

static void
radeonDRI2Flush(__DRIdrawable *drawable)
{
    radeonContextPtr rmesa;

    rmesa = (radeonContextPtr) drawable->driContextPriv->driverPrivate;
    radeonFlush(rmesa->glCtx);
}

static const struct __DRI2flushExtensionRec radeonFlushExtension = {
    { __DRI2_FLUSH, __DRI2_FLUSH_VERSION },
    radeonDRI2Flush,
    dri2InvalidateDrawable,
};

static __DRIimage *
radeon_create_image_from_name(__DRIcontext *context,
                              int width, int height, int format,
                              int name, int pitch, void *loaderPrivate)
{
   __DRIimage *image;
   radeonContextPtr radeon = context->driverPrivate;

   if (name == 0)
      return NULL;

   image = CALLOC(sizeof *image);
   if (image == NULL)
      return NULL;

   switch (format) {
   case __DRI_IMAGE_FORMAT_RGB565:
      image->format = MESA_FORMAT_RGB565;
      image->internal_format = GL_RGB;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   case __DRI_IMAGE_FORMAT_XRGB8888:
      image->format = MESA_FORMAT_XRGB8888;
      image->internal_format = GL_RGB;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   case __DRI_IMAGE_FORMAT_ARGB8888:
      image->format = MESA_FORMAT_ARGB8888;
      image->internal_format = GL_RGBA;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   default:
      free(image);
      return NULL;
d407 8
a414 15
   image->data = loaderPrivate;
   image->cpp = _mesa_get_format_bytes(image->format);
   image->width = width;
   image->pitch = pitch;
   image->height = height;

   image->bo = radeon_bo_open(radeon->radeonScreen->bom,
                              (uint32_t)name,
                              image->pitch * image->height * image->cpp,
                              0,
                              RADEON_GEM_DOMAIN_VRAM,
                              0);

   if (image->bo == NULL) {
      FREE(image);
d418 1
a418 2
   return image;
}
d420 9
a428 13
static __DRIimage *
radeon_create_image_from_renderbuffer(__DRIcontext *context,
                                      int renderbuffer, void *loaderPrivate)
{
   __DRIimage *image;
   radeonContextPtr radeon = context->driverPrivate;
   struct gl_renderbuffer *rb;
   struct radeon_renderbuffer *rrb;

   rb = _mesa_lookup_renderbuffer(radeon->glCtx, renderbuffer);
   if (!rb) {
      _mesa_error(radeon->glCtx,
                  GL_INVALID_OPERATION, "glRenderbufferExternalMESA");
d431 2
d434 6
a439 58
   rrb = radeon_renderbuffer(rb);
   image = CALLOC(sizeof *image);
   if (image == NULL)
      return NULL;

   image->internal_format = rb->InternalFormat;
   image->format = rb->Format;
   image->cpp = rrb->cpp;
   image->data_type = rb->DataType;
   image->data = loaderPrivate;
   radeon_bo_ref(rrb->bo);
   image->bo = rrb->bo;

   image->width = rb->Width;
   image->height = rb->Height;
   image->pitch = rrb->pitch / image->cpp;

   return image;
}

static void
radeon_destroy_image(__DRIimage *image)
{
   radeon_bo_unref(image->bo);
   FREE(image);
}

static __DRIimage *
radeon_create_image(__DRIscreen *screen,
                    int width, int height, int format,
                    unsigned int use,
                    void *loaderPrivate)
{
   __DRIimage *image;
   radeonScreenPtr radeonScreen = screen->private;

   image = CALLOC(sizeof *image);
   if (image == NULL)
      return NULL;

   switch (format) {
   case __DRI_IMAGE_FORMAT_RGB565:
      image->format = MESA_FORMAT_RGB565;
      image->internal_format = GL_RGB;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   case __DRI_IMAGE_FORMAT_XRGB8888:
      image->format = MESA_FORMAT_XRGB8888;
      image->internal_format = GL_RGB;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   case __DRI_IMAGE_FORMAT_ARGB8888:
      image->format = MESA_FORMAT_ARGB8888;
      image->internal_format = GL_RGBA;
      image->data_type = GL_UNSIGNED_BYTE;
      break;
   default:
      free(image);
d443 14
a456 12
   image->data = loaderPrivate;
   image->cpp = _mesa_get_format_bytes(image->format);
   image->width = width;
   image->height = height;
   image->pitch = ((image->cpp * image->width + 255) & ~255) / image->cpp;

   image->bo = radeon_bo_open(radeonScreen->bom,
                              0,
                              image->pitch * image->height * image->cpp,
                              0,
                              RADEON_GEM_DOMAIN_VRAM,
                              0);
d458 1
a458 3
   if (image->bo == NULL) {
      FREE(image);
      return NULL;
a460 33
   return image;
}

static GLboolean
radeon_query_image(__DRIimage *image, int attrib, int *value)
{
   switch (attrib) {
   case __DRI_IMAGE_ATTRIB_STRIDE:
      *value = image->pitch * image->cpp;
      return GL_TRUE;
   case __DRI_IMAGE_ATTRIB_HANDLE:
      *value = image->bo->handle;
      return GL_TRUE;
   case __DRI_IMAGE_ATTRIB_NAME:
      radeon_gem_get_kernel_name(image->bo, (uint32_t *) value);
      return GL_TRUE;
   default:
      return GL_FALSE;
   }
}

static struct __DRIimageExtensionRec radeonImageExtension = {
    { __DRI_IMAGE, __DRI_IMAGE_VERSION },
   radeon_create_image_from_name,
   radeon_create_image_from_renderbuffer,
   radeon_destroy_image,
   radeon_create_image,
   radeon_query_image
};

static int radeon_set_screen_flags(radeonScreenPtr screen, int device_id)
{
   screen->device_id = device_id;
d462 2
a463 5
   switch ( device_id ) {
   case PCI_CHIP_RN50_515E:
   case PCI_CHIP_RN50_5969:
	return -1;

d468 2
a589 1
   case PCI_CHIP_RV380_3155:
a635 2
   case PCI_CHIP_RV410_5E4C:
   case PCI_CHIP_RV410_5E4F:
a640 1
   case PCI_CHIP_RV410_5657:
d644 1
d646 1
d660 1
a662 429
   case PCI_CHIP_RS600_793F:
   case PCI_CHIP_RS600_7941:
   case PCI_CHIP_RS600_7942:
      screen->chip_family = CHIP_FAMILY_RS600;
      break;

   case PCI_CHIP_RS690_791E:
   case PCI_CHIP_RS690_791F:
      screen->chip_family = CHIP_FAMILY_RS690;
      break;
   case PCI_CHIP_RS740_796C:
   case PCI_CHIP_RS740_796D:
   case PCI_CHIP_RS740_796E:
   case PCI_CHIP_RS740_796F:
      screen->chip_family = CHIP_FAMILY_RS740;
      break;

   case PCI_CHIP_R520_7100:
   case PCI_CHIP_R520_7101:
   case PCI_CHIP_R520_7102:
   case PCI_CHIP_R520_7103:
   case PCI_CHIP_R520_7104:
   case PCI_CHIP_R520_7105:
   case PCI_CHIP_R520_7106:
   case PCI_CHIP_R520_7108:
   case PCI_CHIP_R520_7109:
   case PCI_CHIP_R520_710A:
   case PCI_CHIP_R520_710B:
   case PCI_CHIP_R520_710C:
   case PCI_CHIP_R520_710E:
   case PCI_CHIP_R520_710F:
      screen->chip_family = CHIP_FAMILY_R520;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV515_7140:
   case PCI_CHIP_RV515_7141:
   case PCI_CHIP_RV515_7142:
   case PCI_CHIP_RV515_7143:
   case PCI_CHIP_RV515_7144:
   case PCI_CHIP_RV515_7145:
   case PCI_CHIP_RV515_7146:
   case PCI_CHIP_RV515_7147:
   case PCI_CHIP_RV515_7149:
   case PCI_CHIP_RV515_714A:
   case PCI_CHIP_RV515_714B:
   case PCI_CHIP_RV515_714C:
   case PCI_CHIP_RV515_714D:
   case PCI_CHIP_RV515_714E:
   case PCI_CHIP_RV515_714F:
   case PCI_CHIP_RV515_7151:
   case PCI_CHIP_RV515_7152:
   case PCI_CHIP_RV515_7153:
   case PCI_CHIP_RV515_715E:
   case PCI_CHIP_RV515_715F:
   case PCI_CHIP_RV515_7180:
   case PCI_CHIP_RV515_7181:
   case PCI_CHIP_RV515_7183:
   case PCI_CHIP_RV515_7186:
   case PCI_CHIP_RV515_7187:
   case PCI_CHIP_RV515_7188:
   case PCI_CHIP_RV515_718A:
   case PCI_CHIP_RV515_718B:
   case PCI_CHIP_RV515_718C:
   case PCI_CHIP_RV515_718D:
   case PCI_CHIP_RV515_718F:
   case PCI_CHIP_RV515_7193:
   case PCI_CHIP_RV515_7196:
   case PCI_CHIP_RV515_719B:
   case PCI_CHIP_RV515_719F:
   case PCI_CHIP_RV515_7200:
   case PCI_CHIP_RV515_7210:
   case PCI_CHIP_RV515_7211:
      screen->chip_family = CHIP_FAMILY_RV515;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV530_71C0:
   case PCI_CHIP_RV530_71C1:
   case PCI_CHIP_RV530_71C2:
   case PCI_CHIP_RV530_71C3:
   case PCI_CHIP_RV530_71C4:
   case PCI_CHIP_RV530_71C5:
   case PCI_CHIP_RV530_71C6:
   case PCI_CHIP_RV530_71C7:
   case PCI_CHIP_RV530_71CD:
   case PCI_CHIP_RV530_71CE:
   case PCI_CHIP_RV530_71D2:
   case PCI_CHIP_RV530_71D4:
   case PCI_CHIP_RV530_71D5:
   case PCI_CHIP_RV530_71D6:
   case PCI_CHIP_RV530_71DA:
   case PCI_CHIP_RV530_71DE:
      screen->chip_family = CHIP_FAMILY_RV530;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_R580_7240:
   case PCI_CHIP_R580_7243:
   case PCI_CHIP_R580_7244:
   case PCI_CHIP_R580_7245:
   case PCI_CHIP_R580_7246:
   case PCI_CHIP_R580_7247:
   case PCI_CHIP_R580_7248:
   case PCI_CHIP_R580_7249:
   case PCI_CHIP_R580_724A:
   case PCI_CHIP_R580_724B:
   case PCI_CHIP_R580_724C:
   case PCI_CHIP_R580_724D:
   case PCI_CHIP_R580_724E:
   case PCI_CHIP_R580_724F:
   case PCI_CHIP_R580_7284:
      screen->chip_family = CHIP_FAMILY_R580;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV570_7280:
   case PCI_CHIP_RV560_7281:
   case PCI_CHIP_RV560_7283:
   case PCI_CHIP_RV560_7287:
   case PCI_CHIP_RV570_7288:
   case PCI_CHIP_RV570_7289:
   case PCI_CHIP_RV570_728B:
   case PCI_CHIP_RV570_728C:
   case PCI_CHIP_RV560_7290:
   case PCI_CHIP_RV560_7291:
   case PCI_CHIP_RV560_7293:
   case PCI_CHIP_RV560_7297:
      screen->chip_family = CHIP_FAMILY_RV560;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_R600_9400:
   case PCI_CHIP_R600_9401:
   case PCI_CHIP_R600_9402:
   case PCI_CHIP_R600_9403:
   case PCI_CHIP_R600_9405:
   case PCI_CHIP_R600_940A:
   case PCI_CHIP_R600_940B:
   case PCI_CHIP_R600_940F:
      screen->chip_family = CHIP_FAMILY_R600;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV610_94C0:
   case PCI_CHIP_RV610_94C1:
   case PCI_CHIP_RV610_94C3:
   case PCI_CHIP_RV610_94C4:
   case PCI_CHIP_RV610_94C5:
   case PCI_CHIP_RV610_94C6:
   case PCI_CHIP_RV610_94C7:
   case PCI_CHIP_RV610_94C8:
   case PCI_CHIP_RV610_94C9:
   case PCI_CHIP_RV610_94CB:
   case PCI_CHIP_RV610_94CC:
   case PCI_CHIP_RV610_94CD:
      screen->chip_family = CHIP_FAMILY_RV610;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV630_9580:
   case PCI_CHIP_RV630_9581:
   case PCI_CHIP_RV630_9583:
   case PCI_CHIP_RV630_9586:
   case PCI_CHIP_RV630_9587:
   case PCI_CHIP_RV630_9588:
   case PCI_CHIP_RV630_9589:
   case PCI_CHIP_RV630_958A:
   case PCI_CHIP_RV630_958B:
   case PCI_CHIP_RV630_958C:
   case PCI_CHIP_RV630_958D:
   case PCI_CHIP_RV630_958E:
   case PCI_CHIP_RV630_958F:
      screen->chip_family = CHIP_FAMILY_RV630;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV670_9500:
   case PCI_CHIP_RV670_9501:
   case PCI_CHIP_RV670_9504:
   case PCI_CHIP_RV670_9505:
   case PCI_CHIP_RV670_9506:
   case PCI_CHIP_RV670_9507:
   case PCI_CHIP_RV670_9508:
   case PCI_CHIP_RV670_9509:
   case PCI_CHIP_RV670_950F:
   case PCI_CHIP_RV670_9511:
   case PCI_CHIP_RV670_9515:
   case PCI_CHIP_RV670_9517:
   case PCI_CHIP_RV670_9519:
      screen->chip_family = CHIP_FAMILY_RV670;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV620_95C0:
   case PCI_CHIP_RV620_95C2:
   case PCI_CHIP_RV620_95C4:
   case PCI_CHIP_RV620_95C5:
   case PCI_CHIP_RV620_95C6:
   case PCI_CHIP_RV620_95C7:
   case PCI_CHIP_RV620_95C9:
   case PCI_CHIP_RV620_95CC:
   case PCI_CHIP_RV620_95CD:
   case PCI_CHIP_RV620_95CE:
   case PCI_CHIP_RV620_95CF:
      screen->chip_family = CHIP_FAMILY_RV620;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV635_9590:
   case PCI_CHIP_RV635_9591:
   case PCI_CHIP_RV635_9593:
   case PCI_CHIP_RV635_9595:
   case PCI_CHIP_RV635_9596:
   case PCI_CHIP_RV635_9597:
   case PCI_CHIP_RV635_9598:
   case PCI_CHIP_RV635_9599:
   case PCI_CHIP_RV635_959B:
      screen->chip_family = CHIP_FAMILY_RV635;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RS780_9610:
   case PCI_CHIP_RS780_9611:
   case PCI_CHIP_RS780_9612:
   case PCI_CHIP_RS780_9613:
   case PCI_CHIP_RS780_9614:
   case PCI_CHIP_RS780_9615:
   case PCI_CHIP_RS780_9616:
      screen->chip_family = CHIP_FAMILY_RS780;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;
   case PCI_CHIP_RS880_9710:
   case PCI_CHIP_RS880_9711:
   case PCI_CHIP_RS880_9712:
   case PCI_CHIP_RS880_9713:
   case PCI_CHIP_RS880_9714:
   case PCI_CHIP_RS880_9715:
      screen->chip_family = CHIP_FAMILY_RS880;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV770_9440:
   case PCI_CHIP_RV770_9441:
   case PCI_CHIP_RV770_9442:
   case PCI_CHIP_RV770_9443:
   case PCI_CHIP_RV770_9444:
   case PCI_CHIP_RV770_9446:
   case PCI_CHIP_RV770_944A:
   case PCI_CHIP_RV770_944B:
   case PCI_CHIP_RV770_944C:
   case PCI_CHIP_RV770_944E:
   case PCI_CHIP_RV770_9450:
   case PCI_CHIP_RV770_9452:
   case PCI_CHIP_RV770_9456:
   case PCI_CHIP_RV770_945A:
   case PCI_CHIP_RV770_945B:
   case PCI_CHIP_RV770_945E:
   case PCI_CHIP_RV790_9460:
   case PCI_CHIP_RV790_9462:
   case PCI_CHIP_RV770_946A:
   case PCI_CHIP_RV770_946B:
   case PCI_CHIP_RV770_947A:
   case PCI_CHIP_RV770_947B:
      screen->chip_family = CHIP_FAMILY_RV770;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV730_9480:
   case PCI_CHIP_RV730_9487:
   case PCI_CHIP_RV730_9488:
   case PCI_CHIP_RV730_9489:
   case PCI_CHIP_RV730_948A:
   case PCI_CHIP_RV730_948F:
   case PCI_CHIP_RV730_9490:
   case PCI_CHIP_RV730_9491:
   case PCI_CHIP_RV730_9495:
   case PCI_CHIP_RV730_9498:
   case PCI_CHIP_RV730_949C:
   case PCI_CHIP_RV730_949E:
   case PCI_CHIP_RV730_949F:
      screen->chip_family = CHIP_FAMILY_RV730;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV710_9540:
   case PCI_CHIP_RV710_9541:
   case PCI_CHIP_RV710_9542:
   case PCI_CHIP_RV710_954E:
   case PCI_CHIP_RV710_954F:
   case PCI_CHIP_RV710_9552:
   case PCI_CHIP_RV710_9553:
   case PCI_CHIP_RV710_9555:
   case PCI_CHIP_RV710_9557:
   case PCI_CHIP_RV710_955F:
      screen->chip_family = CHIP_FAMILY_RV710;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

   case PCI_CHIP_RV740_94A0:
   case PCI_CHIP_RV740_94A1:
   case PCI_CHIP_RV740_94A3:
   case PCI_CHIP_RV740_94B1:
   case PCI_CHIP_RV740_94B3:
   case PCI_CHIP_RV740_94B4:
   case PCI_CHIP_RV740_94B5:
   case PCI_CHIP_RV740_94B9:
      screen->chip_family = CHIP_FAMILY_RV740;
      screen->chip_flags = RADEON_CHIPSET_TCL;
      break;

    case PCI_CHIP_CEDAR_68E0:
    case PCI_CHIP_CEDAR_68E1:
    case PCI_CHIP_CEDAR_68E4:
    case PCI_CHIP_CEDAR_68E5:
    case PCI_CHIP_CEDAR_68E8:
    case PCI_CHIP_CEDAR_68E9:
    case PCI_CHIP_CEDAR_68F1:
    case PCI_CHIP_CEDAR_68F2:
    case PCI_CHIP_CEDAR_68F8:
    case PCI_CHIP_CEDAR_68F9:
    case PCI_CHIP_CEDAR_68FE:
       screen->chip_family = CHIP_FAMILY_CEDAR;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

    case PCI_CHIP_REDWOOD_68C0:
    case PCI_CHIP_REDWOOD_68C1:
    case PCI_CHIP_REDWOOD_68C8:
    case PCI_CHIP_REDWOOD_68C9:
    case PCI_CHIP_REDWOOD_68D8:
    case PCI_CHIP_REDWOOD_68D9:
    case PCI_CHIP_REDWOOD_68DA:
    case PCI_CHIP_REDWOOD_68DE:
       screen->chip_family = CHIP_FAMILY_REDWOOD;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

    case PCI_CHIP_JUNIPER_68A0:
    case PCI_CHIP_JUNIPER_68A1:
    case PCI_CHIP_JUNIPER_68A8:
    case PCI_CHIP_JUNIPER_68A9:
    case PCI_CHIP_JUNIPER_68B0:
    case PCI_CHIP_JUNIPER_68B8:
    case PCI_CHIP_JUNIPER_68B9:
    case PCI_CHIP_JUNIPER_68BA:
    case PCI_CHIP_JUNIPER_68BE:
    case PCI_CHIP_JUNIPER_68BF:
       screen->chip_family = CHIP_FAMILY_JUNIPER;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

    case PCI_CHIP_CYPRESS_6880:
    case PCI_CHIP_CYPRESS_6888:
    case PCI_CHIP_CYPRESS_6889:
    case PCI_CHIP_CYPRESS_688A:
    case PCI_CHIP_CYPRESS_6898:
    case PCI_CHIP_CYPRESS_6899:
    case PCI_CHIP_CYPRESS_689B:
    case PCI_CHIP_CYPRESS_689E:
       screen->chip_family = CHIP_FAMILY_CYPRESS;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

    case PCI_CHIP_HEMLOCK_689C:
    case PCI_CHIP_HEMLOCK_689D:
       screen->chip_family = CHIP_FAMILY_HEMLOCK;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

    case PCI_CHIP_PALM_9802:
    case PCI_CHIP_PALM_9803:
    case PCI_CHIP_PALM_9804:
    case PCI_CHIP_PALM_9805:
    case PCI_CHIP_PALM_9806:
    case PCI_CHIP_PALM_9807:
       screen->chip_family = CHIP_FAMILY_PALM;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

   case PCI_CHIP_BARTS_6720:
   case PCI_CHIP_BARTS_6721:
   case PCI_CHIP_BARTS_6722:
   case PCI_CHIP_BARTS_6723:
   case PCI_CHIP_BARTS_6724:
   case PCI_CHIP_BARTS_6725:
   case PCI_CHIP_BARTS_6726:
   case PCI_CHIP_BARTS_6727:
   case PCI_CHIP_BARTS_6728:
   case PCI_CHIP_BARTS_6729:
   case PCI_CHIP_BARTS_6738:
   case PCI_CHIP_BARTS_6739:
   case PCI_CHIP_BARTS_673E:
       screen->chip_family = CHIP_FAMILY_BARTS;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

   case PCI_CHIP_TURKS_6740:
   case PCI_CHIP_TURKS_6741:
   case PCI_CHIP_TURKS_6742:
   case PCI_CHIP_TURKS_6743:
   case PCI_CHIP_TURKS_6744:
   case PCI_CHIP_TURKS_6745:
   case PCI_CHIP_TURKS_6746:
   case PCI_CHIP_TURKS_6747:
   case PCI_CHIP_TURKS_6748:
   case PCI_CHIP_TURKS_6749:
   case PCI_CHIP_TURKS_6750:
   case PCI_CHIP_TURKS_6758:
   case PCI_CHIP_TURKS_6759:
       screen->chip_family = CHIP_FAMILY_TURKS;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

   case PCI_CHIP_CAICOS_6760:
   case PCI_CHIP_CAICOS_6761:
   case PCI_CHIP_CAICOS_6762:
   case PCI_CHIP_CAICOS_6763:
   case PCI_CHIP_CAICOS_6764:
   case PCI_CHIP_CAICOS_6765:
   case PCI_CHIP_CAICOS_6766:
   case PCI_CHIP_CAICOS_6767:
   case PCI_CHIP_CAICOS_6768:
   case PCI_CHIP_CAICOS_6770:
   case PCI_CHIP_CAICOS_6779:
       screen->chip_family = CHIP_FAMILY_CAICOS;
       screen->chip_flags = RADEON_CHIPSET_TCL;
       break;

d665 1
a665 29
	      device_id);
      return -1;
   }

   return 0;
}


/* Create the device specific screen private data struct.
 */
static radeonScreenPtr
radeonCreateScreen( __DRIscreen *sPriv )
{
   radeonScreenPtr screen;
   RADEONDRIPtr dri_priv = (RADEONDRIPtr)sPriv->pDevPriv;
   int i;
   int ret;
   uint32_t temp = 0;

   if (sPriv->devPrivSize != sizeof(RADEONDRIRec)) {
      fprintf(stderr,"\nERROR!  sizeof(RADEONDRIRec) does not match passed size from device driver\n");
      return GL_FALSE;
   }

   /* Allocate the private area */
   screen = (radeonScreenPtr) CALLOC( sizeof(*screen) );
   if ( !screen ) {
      __driUtilMessage("%s: Could not allocate memory for screen structure",
		       __FUNCTION__);
a667 94

   radeon_init_debug();

   /* parse information in __driConfigOptions */
   driParseOptionInfo (&screen->optionCache,
		       __driConfigOptions, __driNConfigOptions);

   /* This is first since which regions we map depends on whether or
    * not we are using a PCI card.
    */
   screen->card_type = (dri_priv->IsPCI ? RADEON_CARD_PCI : RADEON_CARD_AGP);
   {
      int ret;

      ret = radeonGetParam(sPriv, RADEON_PARAM_GART_BUFFER_OFFSET,
			    &screen->gart_buffer_offset);

      if (ret) {
	 FREE( screen );
	 fprintf(stderr, "drm_radeon_getparam_t (RADEON_PARAM_GART_BUFFER_OFFSET): %d\n", ret);
	 return NULL;
      }

      ret = radeonGetParam(sPriv, RADEON_PARAM_GART_BASE,
			    &screen->gart_base);
      if (ret) {
	 FREE( screen );
	 fprintf(stderr, "drm_radeon_getparam_t (RADEON_PARAM_GART_BASE): %d\n", ret);
	 return NULL;
      }

      ret = radeonGetParam(sPriv, RADEON_PARAM_IRQ_NR,
			    &screen->irq);
      if (ret) {
	 FREE( screen );
	 fprintf(stderr, "drm_radeon_getparam_t (RADEON_PARAM_IRQ_NR): %d\n", ret);
	 return NULL;
      }
      screen->drmSupportsCubeMapsR200 = (sPriv->drm_version.minor >= 7);
      screen->drmSupportsBlendColor = (sPriv->drm_version.minor >= 11);
      screen->drmSupportsTriPerf = (sPriv->drm_version.minor >= 16);
      screen->drmSupportsFragShader = (sPriv->drm_version.minor >= 18);
      screen->drmSupportsPointSprites = (sPriv->drm_version.minor >= 13);
      screen->drmSupportsCubeMapsR100 = (sPriv->drm_version.minor >= 15);
      screen->drmSupportsVertexProgram = (sPriv->drm_version.minor >= 25);
      screen->drmSupportsOcclusionQueries = (sPriv->drm_version.minor >= 30);
   }

   ret = radeon_set_screen_flags(screen, dri_priv->deviceID);
   if (ret == -1)
     return NULL;

   screen->status.handle = dri_priv->statusHandle;
   screen->status.size   = dri_priv->statusSize;
   if ( drmMap( sPriv->fd,
		screen->status.handle,
		screen->status.size,
		&screen->status.map ) ) {
     FREE( screen );
     __driUtilMessage("%s: drmMap (2) failed\n", __FUNCTION__ );
     return NULL;
   }
   if (screen->chip_family < CHIP_FAMILY_R600)
	   screen->scratch = (__volatile__ uint32_t *)
		   ((GLubyte *)screen->status.map + RADEON_SCRATCH_REG_OFFSET);
   else
	   screen->scratch = (__volatile__ uint32_t *)
		   ((GLubyte *)screen->status.map + R600_SCRATCH_REG_OFFSET);

   screen->buffers = drmMapBufs( sPriv->fd );
   if ( !screen->buffers ) {
     drmUnmap( screen->status.map, screen->status.size );
     FREE( screen );
     __driUtilMessage("%s: drmMapBufs failed\n", __FUNCTION__ );
     return NULL;
   }

   if ( dri_priv->gartTexHandle && dri_priv->gartTexMapSize ) {
     screen->gartTextures.handle = dri_priv->gartTexHandle;
     screen->gartTextures.size   = dri_priv->gartTexMapSize;
     if ( drmMap( sPriv->fd,
		  screen->gartTextures.handle,
		  screen->gartTextures.size,
		  (drmAddressPtr)&screen->gartTextures.map ) ) {
       drmUnmapBufs( screen->buffers );
       drmUnmap( screen->status.map, screen->status.size );
       FREE( screen );
       __driUtilMessage("%s: drmMap failed for GART texture area\n", __FUNCTION__);
       return NULL;
    }

     screen->gart_texture_offset = dri_priv->gartTexOffset + screen->gart_base;
   }

d669 1
a669 1
       sPriv->ddx_version.minor < 2) {
a673 8
   if ((sPriv->drm_version.minor < 29) && (screen->chip_family >= CHIP_FAMILY_RV515)) {
      fprintf(stderr, "R500 support requires a newer drm.\n");
      return NULL;
   }

   if (getenv("R300_NO_TCL"))
	   screen->chip_flags &= ~RADEON_CHIPSET_TCL;

d675 1
a675 1
	   screen->chip_flags |= RADEON_CLASS_R100;
d677 1
a677 9
	   screen->chip_flags |= RADEON_CLASS_R200;
   else if (screen->chip_family <= CHIP_FAMILY_RV570)
	   screen->chip_flags |= RADEON_CLASS_R300;
   else
	   screen->chip_flags |= RADEON_CLASS_R600;

   /* set group bytes for r6xx+ */
   if (screen->chip_family >= CHIP_FAMILY_CEDAR)
	   screen->group_bytes = 512;
d679 1
a679 1
	   screen->group_bytes = 256;
d684 1
a684 1
   ret = radeonGetParam(sPriv, RADEON_PARAM_FB_LOCATION, &temp);
d686 1
a686 79
   /* +r6/r7 */
   if(screen->chip_family >= CHIP_FAMILY_R600)
   {
       if (ret)
       {
            FREE( screen );
            fprintf(stderr, "Unable to get fb location need newer drm\n");
            return NULL;
       }
       else
       {
            screen->fbLocation = (temp & 0xffff) << 24;
       }
   }
   else
   {
        if (ret)
        {
                FREE( screen );
                fprintf(stderr, "Unable to get fb location need newer drm\n");
                return NULL;
        }
        else
        {            
            screen->fbLocation = (temp & 0xffff) << 16;
        }
   }

   if (IS_R300_CLASS(screen)) {
       ret = radeonGetParam(sPriv, RADEON_PARAM_NUM_GB_PIPES, &temp);
       if (ret) {
	   fprintf(stderr, "Unable to get num_pipes, need newer drm\n");
	   switch (screen->chip_family) {
	   case CHIP_FAMILY_R300:
	   case CHIP_FAMILY_R350:
	       screen->num_gb_pipes = 2;
	       break;
	   case CHIP_FAMILY_R420:
	   case CHIP_FAMILY_R520:
	   case CHIP_FAMILY_R580:
	   case CHIP_FAMILY_RV560:
	   case CHIP_FAMILY_RV570:
	       screen->num_gb_pipes = 4;
	       break;
	   case CHIP_FAMILY_RV350:
	   case CHIP_FAMILY_RV515:
	   case CHIP_FAMILY_RV530:
	   case CHIP_FAMILY_RV410:
	   default:
	       screen->num_gb_pipes = 1;
	       break;
	   }
       } else {
	   screen->num_gb_pipes = temp;
       }

       /* pipe overrides */
       switch (dri_priv->deviceID) {
       case PCI_CHIP_R300_AD: /* 9500 with 1 quadpipe verified by: Reid Linnemann <lreid@@cs.okstate.edu> */
       case PCI_CHIP_R350_AH: /* 9800 SE only have 1 quadpipe */
       case PCI_CHIP_RV410_5E4C: /* RV410 SE only have 1 quadpipe */
       case PCI_CHIP_RV410_5E4F: /* RV410 SE only have 1 quadpipe */
	   screen->num_gb_pipes = 1;
	   break;
       default:
	   break;
       }

       if ( sPriv->drm_version.minor >= 31 ) {
	       ret = radeonGetParam(sPriv, RADEON_PARAM_NUM_Z_PIPES, &temp);
	       if (ret)
		       screen->num_z_pipes = 2;
	       else
		       screen->num_z_pipes = temp;
       } else
	       screen->num_z_pipes = 2;
   }

   if ( sPriv->drm_version.minor >= 10 ) {
d704 2
a705 5
   screen->depthHasSurface = (sPriv->ddx_version.major > 4) ||
      /* these chips don't use tiled z without hyperz. So always pretend
         we have set up a surface which will cause linear reads/writes */
      (IS_R100_CLASS(screen) &&
      !(screen->chip_flags & RADEON_CHIPSET_TCL));
d734 6
a739 3
   i = 0;
   screen->extensions[i++] = &driCopySubBufferExtension.base;
   screen->extensions[i++] = &driReadDrawableExtension;
d741 6
a746 3
   if ( screen->irq != 0 ) {
       screen->extensions[i++] = &driSwapControlExtension.base;
       screen->extensions[i++] = &driMediaStreamCounterExtension.base;
d749 6
a754 14
#if defined(RADEON_R100)
   screen->extensions[i++] = &radeonTexOffsetExtension.base;
#endif

#if defined(RADEON_R200)
   screen->extensions[i++] = &r200texOffsetExtension.base;
#endif

#if defined(RADEON_R300)
   screen->extensions[i++] = &r300texOffsetExtension.base;
#endif

#if defined(RADEON_R600)
   screen->extensions[i++] = &r600texOffsetExtension.base;
a756 5
   screen->extensions[i++] = &dri2ConfigQueryExtension.base;

   screen->extensions[i++] = NULL;
   sPriv->extensions = screen->extensions;

a758 267
   screen->sarea = (drm_radeon_sarea_t *) ((GLubyte *) sPriv->pSAREA +
					       screen->sarea_priv_offset);

   screen->bom = radeon_bo_manager_legacy_ctor(screen);
   if (screen->bom == NULL) {
     free(screen);
     return NULL;
   }

   return screen;
}

static radeonScreenPtr
radeonCreateScreen2(__DRIscreen *sPriv)
{
   radeonScreenPtr screen;
   int i;
   int ret;
   uint32_t device_id = 0;
   uint32_t temp = 0;

   /* Allocate the private area */
   screen = (radeonScreenPtr) CALLOC( sizeof(*screen) );
   if ( !screen ) {
      __driUtilMessage("%s: Could not allocate memory for screen structure",
		       __FUNCTION__);
      fprintf(stderr, "leaving here\n");
      return NULL;
   }

   radeon_init_debug();

   /* parse information in __driConfigOptions */
   driParseOptionInfo (&screen->optionCache,
		       __driConfigOptions, __driNConfigOptions);

   screen->kernel_mm = 1;
   screen->chip_flags = 0;

   /* if we have kms we can support all of these */
   screen->drmSupportsCubeMapsR200 = 1;
   screen->drmSupportsBlendColor = 1;
   screen->drmSupportsTriPerf = 1;
   screen->drmSupportsFragShader = 1;
   screen->drmSupportsPointSprites = 1;
   screen->drmSupportsCubeMapsR100 = 1;
   screen->drmSupportsVertexProgram = 1;
   screen->drmSupportsOcclusionQueries = 1;
   screen->irq = 1;

   ret = radeonGetParam(sPriv, RADEON_PARAM_DEVICE_ID, &device_id);
   if (ret) {
     FREE( screen );
     fprintf(stderr, "drm_radeon_getparam_t (RADEON_PARAM_DEVICE_ID): %d\n", ret);
     return NULL;
   }

   ret = radeon_set_screen_flags(screen, device_id);
   if (ret == -1)
     return NULL;

   if (getenv("R300_NO_TCL"))
	   screen->chip_flags &= ~RADEON_CHIPSET_TCL;

   if (screen->chip_family <= CHIP_FAMILY_RS200)
	   screen->chip_flags |= RADEON_CLASS_R100;
   else if (screen->chip_family <= CHIP_FAMILY_RV280)
	   screen->chip_flags |= RADEON_CLASS_R200;
   else if (screen->chip_family <= CHIP_FAMILY_RV570)
	   screen->chip_flags |= RADEON_CLASS_R300;
   else
	   screen->chip_flags |= RADEON_CLASS_R600;

   /* r6xx+ tiling, default group bytes */
   if (screen->chip_family >= CHIP_FAMILY_CEDAR)
	   screen->group_bytes = 512;
   else
	   screen->group_bytes = 256;
   if (IS_R600_CLASS(screen)) {
	   if ((sPriv->drm_version.minor >= 6) &&
	       (screen->chip_family < CHIP_FAMILY_CEDAR)) {
		   ret = radeonGetParam(sPriv, RADEON_INFO_TILE_CONFIG, &temp);
		   if (ret)
			   fprintf(stderr, "failed to get tiling info\n");
		   else {
			   screen->tile_config = temp;
			   screen->r7xx_bank_op = 0;
			   switch ((screen->tile_config & 0xe) >> 1) {
			   case 0:
				   screen->num_channels = 1;
				   break;
			   case 1:
				   screen->num_channels = 2;
				   break;
			   case 2:
				   screen->num_channels = 4;
				   break;
			   case 3:
				   screen->num_channels = 8;
				   break;
			   default:
				   fprintf(stderr, "bad channels\n");
				   break;
			   }
			   switch ((screen->tile_config & 0x30) >> 4) {
			   case 0:
				   screen->num_banks = 4;
				   break;
			   case 1:
				   screen->num_banks = 8;
				   break;
			   default:
				   fprintf(stderr, "bad banks\n");
				   break;
			   }
			   switch ((screen->tile_config & 0xc0) >> 6) {
			   case 0:
				   screen->group_bytes = 256;
				   break;
			   case 1:
				   screen->group_bytes = 512;
				   break;
			   default:
				   fprintf(stderr, "bad group_bytes\n");
				   break;
			   }
		   }
	   } else if ((sPriv->drm_version.minor >= 7) &&
		      (screen->chip_family >= CHIP_FAMILY_CEDAR)) {
		   ret = radeonGetParam(sPriv, RADEON_INFO_TILE_CONFIG, &temp);
		   if (ret)
			   fprintf(stderr, "failed to get tiling info\n");
		   else {
			   screen->tile_config = temp;
			   screen->r7xx_bank_op = 0;
			   switch (screen->tile_config & 0xf) {
			   case 0:
				   screen->num_channels = 1;
				   break;
			   case 1:
				   screen->num_channels = 2;
				   break;
			   case 2:
				   screen->num_channels = 4;
				   break;
			   case 3:
				   screen->num_channels = 8;
				   break;
			   default:
				   fprintf(stderr, "bad channels\n");
				   break;
			   }
			   switch ((screen->tile_config & 0xf0) >> 4) {
			   case 0:
				   screen->num_banks = 4;
				   break;
			   case 1:
				   screen->num_banks = 8;
				   break;
			   case 2:
				   screen->num_banks = 16;
				   break;
			   default:
				   fprintf(stderr, "bad banks\n");
				   break;
			   }
			   switch ((screen->tile_config & 0xf00) >> 8) {
			   case 0:
				   screen->group_bytes = 256;
				   break;
			   case 1:
				   screen->group_bytes = 512;
				   break;
			   default:
				   fprintf(stderr, "bad group_bytes\n");
				   break;
			   }
		   }
	   }
   }

   if (IS_R300_CLASS(screen)) {
       ret = radeonGetParam(sPriv, RADEON_PARAM_NUM_GB_PIPES, &temp);
       if (ret) {
	   fprintf(stderr, "Unable to get num_pipes, need newer drm\n");
	   switch (screen->chip_family) {
	   case CHIP_FAMILY_R300:
	   case CHIP_FAMILY_R350:
	       screen->num_gb_pipes = 2;
	       break;
	   case CHIP_FAMILY_R420:
	   case CHIP_FAMILY_R520:
	   case CHIP_FAMILY_R580:
	   case CHIP_FAMILY_RV560:
	   case CHIP_FAMILY_RV570:
	       screen->num_gb_pipes = 4;
	       break;
	   case CHIP_FAMILY_RV350:
	   case CHIP_FAMILY_RV515:
	   case CHIP_FAMILY_RV530:
	   case CHIP_FAMILY_RV410:
	   default:
	       screen->num_gb_pipes = 1;
	       break;
	   }
       } else {
	   screen->num_gb_pipes = temp;
       }

       /* pipe overrides */
       switch (device_id) {
       case PCI_CHIP_R300_AD: /* 9500 with 1 quadpipe verified by: Reid Linnemann <lreid@@cs.okstate.edu> */
       case PCI_CHIP_R350_AH: /* 9800 SE only have 1 quadpipe */
       case PCI_CHIP_RV410_5E4C: /* RV410 SE only have 1 quadpipe */
       case PCI_CHIP_RV410_5E4F: /* RV410 SE only have 1 quadpipe */
	   screen->num_gb_pipes = 1;
	   break;
       default:
	   break;
       }

       ret = radeonGetParam(sPriv, RADEON_PARAM_NUM_Z_PIPES, &temp);
       if (ret)
	       screen->num_z_pipes = 2;
       else
	       screen->num_z_pipes = temp;

   }

   i = 0;
   screen->extensions[i++] = &driCopySubBufferExtension.base;
   screen->extensions[i++] = &driReadDrawableExtension;
   screen->extensions[i++] = &dri2ConfigQueryExtension.base;

   if ( screen->irq != 0 ) {
       screen->extensions[i++] = &driSwapControlExtension.base;
       screen->extensions[i++] = &driMediaStreamCounterExtension.base;
   }

#if defined(RADEON_R100)
   screen->extensions[i++] = &radeonTexBufferExtension.base;
#endif

#if defined(RADEON_R200)
   screen->extensions[i++] = &r200TexBufferExtension.base;
#endif

#if defined(RADEON_R300)
   screen->extensions[i++] = &r300TexBufferExtension.base;
#endif

#if defined(RADEON_R600)
   screen->extensions[i++] = &r600TexBufferExtension.base;
#endif

   screen->extensions[i++] = &radeonFlushExtension.base;
   screen->extensions[i++] = &radeonImageExtension.base;

   screen->extensions[i++] = NULL;
   sPriv->extensions = screen->extensions;

   screen->driScreen = sPriv;
   screen->bom = radeon_bo_manager_gem_ctor(sPriv->fd);
   if (screen->bom == NULL) {
       free(screen);
       return NULL;
   }
d765 1
a765 1
radeonDestroyScreen( __DRIscreen *sPriv )
d767 1
a767 1
    radeonScreenPtr screen = (radeonScreenPtr)sPriv->private;
d769 2
a770 2
    if (!screen)
        return;
d772 6
a777 14
    if (screen->kernel_mm) {
#ifdef RADEON_BO_TRACK
        radeon_tracker_print(&screen->bom->tracker, stderr);
#endif
        radeon_bo_manager_gem_dtor(screen->bom);
    } else {
        radeon_bo_manager_legacy_dtor(screen->bom);

        if ( screen->gartTextures.map ) {
            drmUnmap( screen->gartTextures.map, screen->gartTextures.size );
        }
        drmUnmapBufs( screen->buffers );
        drmUnmap( screen->status.map, screen->status.size );
    }
d779 2
a780 2
    /* free all option information */
    driDestroyOptionInfo (&screen->optionCache);
d782 2
a783 2
    FREE( screen );
    sPriv->private = NULL;
d790 1
a790 1
radeonInitDriver( __DRIscreen *sPriv )
d792 5
a796 9
    if (sPriv->dri2.enabled) {
        sPriv->private = (void *) radeonCreateScreen2( sPriv );
    } else {
        sPriv->private = (void *) radeonCreateScreen( sPriv );
    }
    if ( !sPriv->private ) {
        radeonDestroyScreen( sPriv );
        return GL_FALSE;
    }
d798 1
a798 1
    return GL_TRUE;
a801 1

d809 3
a811 3
radeonCreateBuffer( __DRIscreen *driScrnPriv,
                    __DRIdrawable *driDrawPriv,
                    const struct gl_config *mesaVis,
d814 1
a814 9
    radeonScreenPtr screen = (radeonScreenPtr) driScrnPriv->private;

    const GLboolean swDepth = GL_FALSE;
    const GLboolean swAlpha = GL_FALSE;
    const GLboolean swAccum = mesaVis->accumRedBits > 0;
    const GLboolean swStencil = mesaVis->stencilBits > 0 &&
	mesaVis->depthBits != 24;
    gl_format rgbFormat;
    struct radeon_framebuffer *rfb;
d816 1
a816 1
    if (isPixmap)
d818 20
d839 11
a849 3
    rfb = CALLOC_STRUCT(radeon_framebuffer);
    if (!rfb)
      return GL_FALSE;
d851 23
a873 1
    _mesa_initialize_window_framebuffer(&rfb->base, mesaVis);
d875 11
a885 32
    if (mesaVis->redBits == 5)
        rgbFormat = _mesa_little_endian() ? MESA_FORMAT_RGB565 : MESA_FORMAT_RGB565_REV;
    else if (mesaVis->alphaBits == 0)
        rgbFormat = _mesa_little_endian() ? MESA_FORMAT_XRGB8888 : MESA_FORMAT_XRGB8888_REV;
    else
        rgbFormat = _mesa_little_endian() ? MESA_FORMAT_ARGB8888 : MESA_FORMAT_ARGB8888_REV;

    /* front color renderbuffer */
    rfb->color_rb[0] = radeon_create_renderbuffer(rgbFormat, driDrawPriv);
    _mesa_add_renderbuffer(&rfb->base, BUFFER_FRONT_LEFT, &rfb->color_rb[0]->base);
    rfb->color_rb[0]->has_surface = 1;

    /* back color renderbuffer */
    if (mesaVis->doubleBufferMode) {
      rfb->color_rb[1] = radeon_create_renderbuffer(rgbFormat, driDrawPriv);
	_mesa_add_renderbuffer(&rfb->base, BUFFER_BACK_LEFT, &rfb->color_rb[1]->base);
	rfb->color_rb[1]->has_surface = 1;
    }

    if (mesaVis->depthBits == 24) {
      if (mesaVis->stencilBits == 8) {
	struct radeon_renderbuffer *depthStencilRb =
           radeon_create_renderbuffer(MESA_FORMAT_S8_Z24, driDrawPriv);
	_mesa_add_renderbuffer(&rfb->base, BUFFER_DEPTH, &depthStencilRb->base);
	_mesa_add_renderbuffer(&rfb->base, BUFFER_STENCIL, &depthStencilRb->base);
	depthStencilRb->has_surface = screen->depthHasSurface;
      } else {
	/* depth renderbuffer */
	struct radeon_renderbuffer *depth =
           radeon_create_renderbuffer(MESA_FORMAT_X8_Z24, driDrawPriv);
	_mesa_add_renderbuffer(&rfb->base, BUFFER_DEPTH, &depth->base);
	depth->has_surface = screen->depthHasSurface;
a886 7
    } else if (mesaVis->depthBits == 16) {
        /* just 16-bit depth buffer, no hw stencil */
	struct radeon_renderbuffer *depth =
           radeon_create_renderbuffer(MESA_FORMAT_Z16, driDrawPriv);
	_mesa_add_renderbuffer(&rfb->base, BUFFER_DEPTH, &depth->base);
	depth->has_surface = screen->depthHasSurface;
    }
d888 8
a895 8
    _mesa_add_soft_renderbuffers(&rfb->base,
	    GL_FALSE, /* color */
	    swDepth,
	    swStencil,
	    swAccum,
	    swAlpha,
	    GL_FALSE /* aux */);
    driDrawPriv->driverPrivate = (void *) rfb;
d897 2
a898 1
    return (driDrawPriv->driverPrivate != NULL);
d902 14
a915 1
static void radeon_cleanup_renderbuffers(struct radeon_framebuffer *rfb)
d917 2
a918 1
	struct radeon_renderbuffer *rb;
d920 3
a922 15
	rb = rfb->color_rb[0];
	if (rb && rb->bo) {
		radeon_bo_unref(rb->bo);
		rb->bo = NULL;
	}
	rb = rfb->color_rb[1];
	if (rb && rb->bo) {
		radeon_bo_unref(rb->bo);
		rb->bo = NULL;
	}
	rb = radeon_get_renderbuffer(&rfb->base, BUFFER_DEPTH);
	if (rb && rb->bo) {
		radeon_bo_unref(rb->bo);
		rb->bo = NULL;
	}
d925 4
a928 2
void
radeonDestroyBuffer(__DRIdrawable *driDrawPriv)
d930 4
a933 9
    struct radeon_framebuffer *rfb;
    if (!driDrawPriv)
	return;

    rfb = (void*)driDrawPriv->driverPrivate;
    if (!rfb)
	return;
    radeon_cleanup_renderbuffers(rfb);
    _mesa_reference_framebuffer((struct gl_framebuffer **)(&(driDrawPriv->driverPrivate)), NULL);
d937 43
d981 5
a985 1
 * This is the driver specific part of the createNewScreen entry point.
d987 2
a988 3
 * \todo maybe fold this into intelInitDriver
 *
 * \return the struct gl_config supported by this driver
d990 12
a1001 2
static const __DRIconfig **
radeonInitScreen(__DRIscreen *psp)
d1003 2
a1004 1
#if defined(RADEON_R100)
d1009 1
a1009 1
#elif defined(RADEON_R200)
d1014 1
a1014 1
#elif defined(RADEON_R300)
a1018 5
#elif defined(RADEON_R600)
   static const char *driver_name = "R600";
   static const __DRIutilversion2 ddx_expected = { 4, 5, 0, 0 };
   static const __DRIversion dri_expected = { 4, 0, 0 };
   static const __DRIversion drm_expected = { 1, 24, 0 };
d1020 2
a1021 1
   RADEONDRIPtr dri_priv = (RADEONDRIPtr) psp->pDevPriv;
d1024 3
a1026 3
				      &psp->dri_version, & dri_expected,
				      &psp->ddx_version, & ddx_expected,
				      &psp->drm_version, & drm_expected ) ) {
d1029 11
d1041 8
a1048 2
   if (!radeonInitDriver(psp))
       return NULL;
d1050 18
a1067 74
   /* for now fill in all modes */
   return radeonFillInModes( psp,
			     dri_priv->bpp,
			     (dri_priv->bpp == 16) ? 16 : 24,
			     (dri_priv->bpp == 16) ? 0  : 8, 1);
}
#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))

/**
 * This is the driver specific part of the createNewScreen entry point.
 * Called when using DRI2.
 *
 * \return the struct gl_config supported by this driver
 */
static const
__DRIconfig **radeonInitScreen2(__DRIscreen *psp)
{
   GLenum fb_format[3];
   GLenum fb_type[3];
   /* GLX_SWAP_COPY_OML is only supported because the Intel driver doesn't
    * support pageflipping at all.
    */
   static const GLenum back_buffer_modes[] = {
     GLX_NONE, GLX_SWAP_UNDEFINED_OML, /*, GLX_SWAP_COPY_OML*/
   };
   uint8_t depth_bits[4], stencil_bits[4], msaa_samples_array[1];
   int color;
   __DRIconfig **configs = NULL;

   if (!radeonInitDriver(psp)) {
       return NULL;
    }
   depth_bits[0] = 0;
   stencil_bits[0] = 0;
   depth_bits[1] = 16;
   stencil_bits[1] = 0;
   depth_bits[2] = 24;
   stencil_bits[2] = 0;
   depth_bits[3] = 24;
   stencil_bits[3] = 8;

   msaa_samples_array[0] = 0;

   fb_format[0] = GL_RGB;
   fb_type[0] = GL_UNSIGNED_SHORT_5_6_5;

   fb_format[1] = GL_BGR;
   fb_type[1] = GL_UNSIGNED_INT_8_8_8_8_REV;

   fb_format[2] = GL_BGRA;
   fb_type[2] = GL_UNSIGNED_INT_8_8_8_8_REV;

   for (color = 0; color < ARRAY_SIZE(fb_format); color++) {
      __DRIconfig **new_configs;

      new_configs = driCreateConfigs(fb_format[color], fb_type[color],
				     depth_bits,
				     stencil_bits,
				     ARRAY_SIZE(depth_bits),
				     back_buffer_modes,
				     ARRAY_SIZE(back_buffer_modes),
				     msaa_samples_array,
				     ARRAY_SIZE(msaa_samples_array),
				     GL_TRUE);
      if (configs == NULL)
	 configs = new_configs;
      else
	 configs = driConcatConfigs(configs, new_configs);
   }

   if (configs == NULL) {
      fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
              __LINE__);
      return NULL;
d1070 1
a1070 1
   return (const __DRIconfig **)configs;
d1073 1
d1078 1
a1078 1
getSwapInfo( __DRIdrawable *dPriv, __DRIswapInfo * sInfo )
d1080 5
a1084 1
    struct radeon_framebuffer *rfb;
d1086 4
a1089 4
    if ( (dPriv == NULL) || (dPriv->driContextPriv == NULL)
	 || (dPriv->driContextPriv->driverPrivate == NULL)
	 || (sInfo == NULL) ) {
	return -1;
d1092 4
a1095 4
    rfb = dPriv->driverPrivate;
    sInfo->swap_count = rfb->swap_count;
    sInfo->swap_ust = rfb->swap_ust;
    sInfo->swap_missed_count = rfb->swap_missed_count;
d1098 1
a1098 1
       ? driCalculateSwapUsage( dPriv, 0, rfb->swap_missed_ust )
a1102 39

const struct __DriverAPIRec driDriverAPI = {
   .InitScreen      = radeonInitScreen,
   .DestroyScreen   = radeonDestroyScreen,
#if defined(RADEON_R200)
   .CreateContext   = r200CreateContext,
   .DestroyContext  = r200DestroyContext,
#elif defined(RADEON_R600)
   .CreateContext   = r600CreateContext,
   .DestroyContext  = radeonDestroyContext,
#elif defined(RADEON_R300)
   .CreateContext   = r300CreateContext,
   .DestroyContext  = radeonDestroyContext,
#else
   .CreateContext   = r100CreateContext,
   .DestroyContext  = radeonDestroyContext,
#endif
   .CreateBuffer    = radeonCreateBuffer,
   .DestroyBuffer   = radeonDestroyBuffer,
   .SwapBuffers     = radeonSwapBuffers,
   .MakeCurrent     = radeonMakeCurrent,
   .UnbindContext   = radeonUnbindContext,
   .GetSwapInfo     = getSwapInfo,
   .GetDrawableMSC  = driDrawableGetMSC32,
   .WaitForMSC      = driWaitForMSC32,
   .WaitForSBC      = NULL,
   .SwapBuffersMSC  = NULL,
   .CopySubBuffer   = radeonCopySubBuffer,
    /* DRI2 */
   .InitScreen2     = radeonInitScreen2,
};

/* This is the table of extensions that the loader will dlsym() for. */
PUBLIC const __DRIextension *__driDriverExtensions[] = {
    &driCoreExtension.base,
    &driLegacyExtension.base,
    &driDRI2Extension.base,
    NULL
};
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@a44 1
#include "swrast/s_renderbuffer.h"
d46 1
d58 7
d68 3
d92 1
a92 1
        DRI_CONF_HYPERZ("false")
d98 2
a99 2
        DRI_CONF_NO_NEG_LOD_BIAS("false")
        DRI_CONF_FORCE_S3TC_ENABLE("false")
d103 1
d106 1
a106 1
        DRI_CONF_NO_RAST("false")
d109 1
a109 1
static const GLuint __driNConfigOptions = 14;
d120 1
a120 1
        DRI_CONF_HYPERZ("false")
d126 2
a127 2
        DRI_CONF_NO_NEG_LOD_BIAS("false")
        DRI_CONF_FORCE_S3TC_ENABLE("false")
d131 1
d135 4
a138 1
        DRI_CONF_NO_RAST("false")
d141 72
a212 1
static const GLuint __driNConfigOptions = 15;
d216 2
d257 78
d336 5
d346 9
a354 1
#elif defined(RADEON_R200)
d362 26
d394 1
a394 1
    radeonFlush(&rmesa->glCtx);
d398 1
a398 1
    { __DRI2_FLUSH, 3 },
d404 1
a404 1
radeon_create_image_from_name(__DRIscreen *screen,
d409 1
a409 1
   radeonScreenPtr radeonScreen = screen->driverPrivate;
d414 1
a414 1
   image = calloc(1, sizeof *image);
d445 1
a445 1
   image->bo = radeon_bo_open(radeonScreen->bom,
d453 1
a453 1
      free(image);
d469 1
a469 1
   rb = _mesa_lookup_renderbuffer(&radeon->glCtx, renderbuffer);
d471 1
a471 1
      _mesa_error(&radeon->glCtx,
d477 1
a477 1
   image = calloc(1, sizeof *image);
d484 1
a484 1
   image->data_type = GL_UNSIGNED_BYTE;
d500 1
a500 1
   free(image);
d510 1
a510 1
   radeonScreenPtr radeonScreen = screen->driverPrivate;
d512 1
a512 1
   image = calloc(1, sizeof *image);
a515 2
   image->dri_format = format;

d551 1
a551 1
      free(image);
d577 1
a577 1
    { __DRI_IMAGE, 1 },
a589 1
#if defined(RADEON_R100)
d619 1
a619 1
      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_BROKEN_STENCIL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;
d627 1
a627 1
      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;
a629 1
#elif defined(RADEON_R200)
d631 1
d636 1
a636 1
      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;
d645 1
a645 1
      screen->chip_flags = R200_CHIPSET_YCBCR_BROKEN | RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;
a647 1
   case PCI_CHIP_RV280_4C6E:
d656 1
a656 1
      screen->chip_flags = RADEON_CHIPSET_TCL | RADEON_CHIPSET_DEPTH_ALWAYS_TILED;
a663 1
      screen->chip_flags = RADEON_CHIPSET_DEPTH_ALWAYS_TILED;
d665 555
a1219 1
#endif
d1230 325
d1562 1
d1565 1
a1565 1
   screen = calloc(1, sizeof(*screen));
d1567 2
a1568 1
      fprintf(stderr, "%s: Could not allocate memory for screen structure", __FUNCTION__);
d1579 1
d1582 9
d1595 1
a1595 1
     free( screen );
d1601 1
a1601 2
   if (ret == -1) {
     free(screen);
d1603 119
d1724 47
a1770 2
   if (getenv("RADEON_NO_TCL"))
	   screen->chip_flags &= ~RADEON_CHIPSET_TCL;
d1773 2
d1777 5
d1784 3
a1786 1
#elif defined(RADEON_R200)
d1790 8
d1818 1
a1818 1
    radeonScreenPtr screen = (radeonScreenPtr)sPriv->driverPrivate;
d1823 1
d1825 1
a1825 1
    radeon_tracker_print(&screen->bom->tracker, stderr);
d1827 10
a1836 1
    radeon_bo_manager_gem_dtor(screen->bom);
d1841 2
a1842 2
    free( screen );
    sPriv->driverPrivate = NULL;
d1851 6
a1856 2
    sPriv->driverPrivate = (void *) radeonCreateScreen2( sPriv );
    if ( !sPriv->driverPrivate ) {
d1878 1
a1878 1
    radeonScreenPtr screen = (radeonScreenPtr) driScrnPriv->driverPrivate;
d1906 1
a1906 1
    _mesa_add_renderbuffer(&rfb->base, BUFFER_FRONT_LEFT, &rfb->color_rb[0]->base.Base);
d1912 1
a1912 1
	_mesa_add_renderbuffer(&rfb->base, BUFFER_BACK_LEFT, &rfb->color_rb[1]->base.Base);
d1920 2
a1921 2
	_mesa_add_renderbuffer(&rfb->base, BUFFER_DEPTH, &depthStencilRb->base.Base);
	_mesa_add_renderbuffer(&rfb->base, BUFFER_STENCIL, &depthStencilRb->base.Base);
d1927 1
a1927 1
	_mesa_add_renderbuffer(&rfb->base, BUFFER_DEPTH, &depth->base.Base);
d1934 1
a1934 1
	_mesa_add_renderbuffer(&rfb->base, BUFFER_DEPTH, &depth->base.Base);
d1938 1
a1938 1
    _swrast_add_soft_renderbuffers(&rfb->base,
d1986 52
d2047 2
a2048 5
   static const gl_format formats[3] = {
      MESA_FORMAT_RGB565,
      MESA_FORMAT_XRGB8888,
      MESA_FORMAT_ARGB8888
   };
d2073 10
a2082 1
   for (color = 0; color < ARRAY_SIZE(formats); color++) {
d2085 1
a2085 1
      new_configs = driCreateConfigs(formats[color],
d2094 4
a2097 1
      configs = driConcatConfigs(configs, new_configs);
d2109 26
d2136 1
a2136 1
   .InitScreen      = radeonInitScreen2,
d2141 6
d2153 1
d2156 8
d2169 1
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d75 1
a75 3
static const __DRIconfigOptionsExtension radeon_config_options = {
   .base = { __DRI_CONFIG_OPTIONS, 1 },
   .xml =
d97 2
a98 2
DRI_CONF_END
};
d101 2
a102 3
static const __DRIconfigOptionsExtension radeon_config_options = {
   .base = { __DRI_CONFIG_OPTIONS, 1 },
   .xml =
d125 3
a127 2
DRI_CONF_END
};
d171 3
a173 5
   .base = { __DRI_TEX_BUFFER, 3 },

   .setTexBuffer        = radeonSetTexBuffer,
   .setTexBuffer2       = radeonSetTexBuffer2,
   .releaseTexBuffer    = NULL,
d177 3
a179 5
   .base = { __DRI_TEX_BUFFER, 3 },

   .setTexBuffer        = r200SetTexBuffer,
   .setTexBuffer2       = r200SetTexBuffer2,
   .releaseTexBuffer    = NULL,
d193 3
a195 4
   .base = { __DRI2_FLUSH, 3 },

   .flush               = radeonDRI2Flush,
   .invalidate          = dri2InvalidateDrawable,
d215 1
a215 1
      image->format = MESA_FORMAT_B5G6R5_UNORM;
d220 1
a220 1
      image->format = MESA_FORMAT_B8G8R8X8_UNORM;
d225 1
a225 1
      image->format = MESA_FORMAT_B8G8R8A8_UNORM;
d315 1
a315 1
      image->format = MESA_FORMAT_B5G6R5_UNORM;
d320 1
a320 1
      image->format = MESA_FORMAT_B8G8R8X8_UNORM;
d325 1
a325 1
      image->format = MESA_FORMAT_B8G8R8A8_UNORM;
d373 7
a379 8
static const __DRIimageExtension radeonImageExtension = {
   .base = { __DRI_IMAGE, 1 },

   .createImageFromName         = radeon_create_image_from_name,
   .createImageFromRenderbuffer = radeon_create_image_from_renderbuffer,
   .destroyImage                = radeon_destroy_image,
   .createImage                 = radeon_create_image,
   .queryImage                  = radeon_query_image
a475 13

static const __DRIextension *radeon_screen_extensions[] = {
    &dri2ConfigQueryExtension.base,
#if defined(RADEON_R100)
    &radeonTexBufferExtension.base,
#elif defined(RADEON_R200)
    &r200TexBufferExtension.base,
#endif
    &radeonFlushExtension.base,
    &radeonImageExtension.base,
    NULL
};

d480 1
d495 2
a496 1
   driParseOptionInfo (&screen->optionCache, radeon_config_options.xml);
d518 14
a531 1
   sPriv->extensions = radeon_screen_extensions;
d600 1
a600 1
    mesa_format rgbFormat;
d613 1
a613 1
        rgbFormat = _mesa_little_endian() ? MESA_FORMAT_B5G6R5_UNORM : MESA_FORMAT_R5G6B5_UNORM;
d615 1
a615 1
        rgbFormat = _mesa_little_endian() ? MESA_FORMAT_B8G8R8X8_UNORM : MESA_FORMAT_X8R8G8B8_UNORM;
d617 1
a617 1
        rgbFormat = _mesa_little_endian() ? MESA_FORMAT_B8G8R8A8_UNORM : MESA_FORMAT_A8R8G8B8_UNORM;
d634 1
a634 1
           radeon_create_renderbuffer(MESA_FORMAT_Z24_UNORM_S8_UINT, driDrawPriv);
d641 1
a641 1
           radeon_create_renderbuffer(MESA_FORMAT_Z24_UNORM_X8_UINT, driDrawPriv);
d648 1
a648 1
           radeon_create_renderbuffer(MESA_FORMAT_Z_UNORM16, driDrawPriv);
d710 4
a713 4
   static const mesa_format formats[3] = {
      MESA_FORMAT_B5G6R5_UNORM,
      MESA_FORMAT_B8G8R8X8_UNORM,
      MESA_FORMAT_B8G8R8A8_UNORM
a724 3
   psp->max_gl_compat_version = 13;
   psp->max_gl_es1_version = 11;

d763 1
a763 1
static const struct __DriverAPIRec radeon_driver_api = {
a778 5
static const struct __DRIDriverVtableExtensionRec radeon_vtable = {
   .base = { __DRI_DRIVER_VTABLE, 1 },
   .vtable = &radeon_driver_api,
};

d780 1
a780 1
static const __DRIextension *radeon_driver_extensions[] = {
a782 2
    &radeon_config_options.base,
    &radeon_vtable.base,
a784 16

#ifdef RADEON_R200
PUBLIC const __DRIextension **__driDriverGetExtensions_r200(void)
{
   globalDriverAPI = &radeon_driver_api;

   return radeon_driver_extensions;
}
#else
PUBLIC const __DRIextension **__driDriverGetExtensions_radeon(void)
{
   globalDriverAPI = &radeon_driver_api;

   return radeon_driver_extensions;
}
#endif
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@d48 1
a483 67
static int
radeonQueryRendererInteger(__DRIscreen *psp, int param,
			       unsigned int *value)
{
   radeonScreenPtr screen = (radeonScreenPtr)psp->driverPrivate;

   switch (param) {
   case __DRI2_RENDERER_VENDOR_ID:
      value[0] = 0x1002;
      return 0;
   case __DRI2_RENDERER_DEVICE_ID:
      value[0] = screen->device_id;
      return 0;
   case __DRI2_RENDERER_ACCELERATED:
      value[0] = 1;
      return 0;
   case __DRI2_RENDERER_VIDEO_MEMORY: {
      struct drm_radeon_gem_info gem_info;
      int retval;
      memset(&gem_info, 0, sizeof(gem_info));

      /* Get GEM info. */
      retval = drmCommandWriteRead(psp->fd, DRM_RADEON_GEM_INFO, &gem_info,
				   sizeof(gem_info));

      if (retval) {
         fprintf(stderr, "radeon: Failed to get MM info, error number %d\n",
                retval);
         return -1;

      }
      /* XXX: Do we want to return vram_size or vram_visible ? */
      value[0] = gem_info.vram_size >> 20;
      return 0;
   }
   case __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE:
      value[0] = 0;
      return 0;
   default:
      return driQueryRendererIntegerCommon(psp, param, value);
   }
}

static int
radeonQueryRendererString(__DRIscreen *psp, int param, const char **value)
{
   radeonScreenPtr screen = (radeonScreenPtr)psp->driverPrivate;

   switch (param) {
   case __DRI2_RENDERER_VENDOR_ID:
      value[0] = radeonVendorString;
      return 0;
   case __DRI2_RENDERER_DEVICE_ID:
      value[0] = radeonGetRendererString(screen);
      return 0;
   default:
      return -1;
   }
}

static const __DRI2rendererQueryExtension radeonRendererQueryExtension = {
   .base = { __DRI2_RENDERER_QUERY, 1 },

   .queryInteger        = radeonQueryRendererInteger,
   .queryString         = radeonQueryRendererString
};

a493 1
    &radeonRendererQueryExtension.base,
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@a47 1
#include "radeon_macros.h"
d483 67
d560 1
@


