head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.04.12;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.32;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.32;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.15.19;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.46;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.11.22;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.48.29;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@ /**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#ifndef I915CONTEXT_INC
#define I915CONTEXT_INC

#include "intel_context.h"

#define I915_FALLBACK_TEXTURE		 0x1000
#define I915_FALLBACK_COLORMASK		 0x2000
#define I915_FALLBACK_STENCIL		 0x4000
#define I915_FALLBACK_STIPPLE		 0x8000
#define I915_FALLBACK_PROGRAM		 0x10000
#define I915_FALLBACK_LOGICOP		 0x20000
#define I915_FALLBACK_POLYGON_SMOOTH	 0x40000
#define I915_FALLBACK_POINT_SMOOTH	 0x80000
#define I915_FALLBACK_POINT_SPRITE_COORD_ORIGIN	 0x100000
#define I915_FALLBACK_DRAW_OFFSET	 0x200000
#define I915_FALLBACK_COORD_REPLACE	 0x400000

#define I915_UPLOAD_CTX              0x1
#define I915_UPLOAD_BUFFERS          0x2
#define I915_UPLOAD_STIPPLE          0x4
#define I915_UPLOAD_PROGRAM          0x8
#define I915_UPLOAD_CONSTANTS        0x10
#define I915_UPLOAD_INVARIENT        0x40
#define I915_UPLOAD_DEFAULTS         0x80
#define I915_UPLOAD_RASTER_RULES     0x100
#define I915_UPLOAD_BLEND            0x200
#define I915_UPLOAD_TEX(i)           (0x00010000<<(i))
#define I915_UPLOAD_TEX_ALL          (0x00ff0000)
#define I915_UPLOAD_TEX_0_SHIFT      16


/* State structure offsets - these will probably disappear.
 */
#define I915_DESTREG_CBUFADDR0 0
#define I915_DESTREG_CBUFADDR1 1
#define I915_DESTREG_DBUFADDR0 3
#define I915_DESTREG_DBUFADDR1 4
#define I915_DESTREG_DV0 6
#define I915_DESTREG_DV1 7
#define I915_DESTREG_SENABLE 8
#define I915_DESTREG_SR0 9
#define I915_DESTREG_SR1 10
#define I915_DESTREG_SR2 11
#define I915_DESTREG_DRAWRECT0 12
#define I915_DESTREG_DRAWRECT1 13
#define I915_DESTREG_DRAWRECT2 14
#define I915_DESTREG_DRAWRECT3 15
#define I915_DESTREG_DRAWRECT4 16
#define I915_DESTREG_DRAWRECT5 17
#define I915_DEST_SETUP_SIZE 18

#define I915_CTXREG_STATE4		0
#define I915_CTXREG_LI			1
#define I915_CTXREG_LIS2		2
#define I915_CTXREG_LIS4		3
#define I915_CTXREG_LIS5		4
#define I915_CTXREG_LIS6		5
#define I915_CTXREG_BF_STENCIL_OPS	6
#define I915_CTXREG_BF_STENCIL_MASKS	7
#define I915_CTX_SETUP_SIZE		8

#define I915_BLENDREG_IAB		0
#define I915_BLENDREG_BLENDCOLOR0	1
#define I915_BLENDREG_BLENDCOLOR1	2
#define I915_BLEND_SETUP_SIZE		3

#define I915_STPREG_ST0        0
#define I915_STPREG_ST1        1
#define I915_STP_SETUP_SIZE    2

#define I915_TEXREG_MS3        1
#define I915_TEXREG_MS4        2
#define I915_TEXREG_SS2        3
#define I915_TEXREG_SS3        4
#define I915_TEXREG_SS4        5
#define I915_TEX_SETUP_SIZE    6

#define I915_DEFREG_C0    0
#define I915_DEFREG_C1    1
#define I915_DEFREG_S0    2
#define I915_DEFREG_S1    3
#define I915_DEFREG_Z0    4
#define I915_DEFREG_Z1    5
#define I915_DEF_SETUP_SIZE    6

enum {
   I915_RASTER_RULES,
   I915_RASTER_RULES_SETUP_SIZE,
};

#define I915_MAX_CONSTANT      32
#define I915_CONSTANT_SIZE     (2+(4*I915_MAX_CONSTANT))

#define I915_MAX_TEX_INDIRECT 4
#define I915_MAX_TEX_INSN     32
#define I915_MAX_ALU_INSN     64
#define I915_MAX_DECL_INSN    27
#define I915_MAX_TEMPORARY    16

#define I915_MAX_INSN          (I915_MAX_DECL_INSN + \
				I915_MAX_TEX_INSN + \
				I915_MAX_ALU_INSN)

/* Maximum size of the program packet, which matches the limits on
 * decl, tex, and ALU instructions.
 */
#define I915_PROGRAM_SIZE      (I915_MAX_INSN * 3 + 1)

/* Hardware version of a parsed fragment program.  "Derived" from the
 * mesa fragment_program struct.
 */
struct i915_fragment_program
{
   struct gl_fragment_program FragProg;

   bool translated;
   bool params_uptodate;
   bool on_hardware;
   bool error;             /* If program is malformed for any reason. */

   /** Record of which phases R registers were last written in. */
   GLuint register_phases[16];
   GLuint indirections;
   GLuint nr_tex_indirect;
   GLuint nr_tex_insn;
   GLuint nr_alu_insn;
   GLuint nr_decl_insn;




   /* TODO: split between the stored representation of a program and
    * the state used to build that representation.
    */
   struct gl_context *ctx;

   /* declarations contains the packet header. */
   GLuint declarations[I915_MAX_DECL_INSN * 3 + 1];
   GLuint program[(I915_MAX_TEX_INSN + I915_MAX_ALU_INSN) * 3];

   GLfloat constant[I915_MAX_CONSTANT][4];
   GLuint constant_flags[I915_MAX_CONSTANT];
   GLuint nr_constants;

   GLuint *csr;                 /* Cursor, points into program.
                                 */

   GLuint *decl;                /* Cursor, points into declarations.
                                 */

   GLuint decl_s;               /* flags for which s regs need to be decl'd */
   GLuint decl_t;               /* flags for which t regs need to be decl'd */

   GLuint temp_flag;            /* Tracks temporary regs which are in
                                 * use.
                                 */

   GLuint utemp_flag;           /* Tracks TYPE_U temporary regs which are in
                                 * use.
                                 */


   /* Track which R registers are "live" for each instruction.
    * A register is live between the time it's written to and the last time
    * it's read. */
   GLuint usedRegs[I915_MAX_INSN];

   /* Helpers for i915_fragprog.c:
    */
   GLuint wpos_tex;
   bool depth_written;

   struct
   {
      GLuint reg;               /* Hardware constant idx */
      const GLfloat *values;    /* Pointer to tracked values */
   } param[I915_MAX_CONSTANT];
   GLuint nr_params;
};







#define I915_TEX_UNITS 8


struct i915_hw_state
{
   GLuint Ctx[I915_CTX_SETUP_SIZE];
   GLuint Blend[I915_BLEND_SETUP_SIZE];
   GLuint Buffer[I915_DEST_SETUP_SIZE];
   GLuint Stipple[I915_STP_SETUP_SIZE];
   GLuint Defaults[I915_DEF_SETUP_SIZE];
   GLuint RasterRules[I915_RASTER_RULES_SETUP_SIZE];
   GLuint Tex[I915_TEX_UNITS][I915_TEX_SETUP_SIZE];
   GLuint Constant[I915_CONSTANT_SIZE];
   GLuint ConstantSize;
   GLuint Program[I915_PROGRAM_SIZE];
   GLuint ProgramSize;

   /* Region pointers for relocation: 
    */
   struct intel_region *draw_region;
   struct intel_region *depth_region;
/*    struct intel_region *tex_region[I915_TEX_UNITS]; */

   /* Regions aren't actually that appropriate here as the memory may
    * be from a PBO or FBO.  Will have to do this for draw and depth for
    * FBO's...
    */
   drm_intel_bo *tex_buffer[I915_TEX_UNITS];
   GLuint tex_offset[I915_TEX_UNITS];


   GLuint active;               /* I915_UPLOAD_* */
   GLuint emitted;              /* I915_UPLOAD_* */
};

struct i915_context
{
   struct intel_context intel;

   GLuint lodbias_ss2[MAX_TEXTURE_UNITS];


   struct i915_fragment_program *current_program;

   drm_intel_bo *current_vb_bo;
   unsigned int current_vertex_size;

   struct i915_hw_state state;
   uint32_t last_draw_offset;
   GLuint last_sampler;
};


#define I915_STATECHANGE(i915, flag)					\
do {									\
   INTEL_FIREVERTICES( &(i915)->intel );					\
   (i915)->state.emitted &= ~(flag);					\
} while (0)

#define I915_ACTIVESTATE(i915, flag, mode)			\
do {								\
   INTEL_FIREVERTICES( &(i915)->intel );				\
   if (mode)							\
      (i915)->state.active |= (flag);				\
   else								\
      (i915)->state.active &= ~(flag);				\
} while (0)


/*======================================================================
 * i915_vtbl.c
 */
extern void i915InitVtbl(struct i915_context *i915);

extern void
i915_state_draw_region(struct intel_context *intel,
                       struct i915_hw_state *state,
                       struct intel_region *color_region,
                       struct intel_region *depth_region);



#define SZ_TO_HW(sz)  ((sz-2)&0x3)
#define EMIT_SZ(sz)   (EMIT_1F + (sz) - 1)
#define EMIT_ATTR( ATTR, STYLE, S4, SZ )				\
do {									\
   intel->vertex_attrs[intel->vertex_attr_count].attrib = (ATTR);	\
   intel->vertex_attrs[intel->vertex_attr_count].format = (STYLE);	\
   s4 |= S4;								\
   intel->vertex_attr_count++;						\
   offset += (SZ);							\
} while (0)

#define EMIT_PAD( N )							\
do {									\
   intel->vertex_attrs[intel->vertex_attr_count].attrib = 0;		\
   intel->vertex_attrs[intel->vertex_attr_count].format = EMIT_PAD;	\
   intel->vertex_attrs[intel->vertex_attr_count].offset = (N);		\
   intel->vertex_attr_count++;						\
   offset += (N);							\
} while (0)



/*======================================================================
 * i915_context.c
 */
extern bool i915CreateContext(int api,
			      const struct gl_config * mesaVis,
			      __DRIcontext * driContextPriv,
                              unsigned major_version,
                              unsigned minor_version,
                              uint32_t flags,
                              unsigned *error,
			      void *sharedContextPrivate);


/*======================================================================
 * i915_debug.c
 */
extern void i915_disassemble_program(const GLuint * program, GLuint sz);
extern void i915_print_ureg(const char *msg, GLuint ureg);


/*======================================================================
 * i915_state.c
 */
extern void i915InitStateFunctions(struct dd_function_table *functions);
extern void i915InitState(struct i915_context *i915);
extern void i915_update_stencil(struct gl_context * ctx);
extern void i915_update_provoking_vertex(struct gl_context *ctx);
extern void i915_update_sprite_point_enable(struct gl_context *ctx);


/*======================================================================
 * i915_tex.c
 */
extern void i915UpdateTextureState(struct intel_context *intel);
extern void i915InitTextureFuncs(struct dd_function_table *functions);

/*======================================================================
 * i915_fragprog.c
 */
extern void i915ValidateFragmentProgram(struct i915_context *i915);
extern void i915InitFragProgFuncs(struct dd_function_table *functions);

/*======================================================================
 * Inline conversion functions.  These are better-typed than the
 * macros used previously:
 */
static INLINE struct i915_context *
i915_context(struct gl_context * ctx)
{
   return (struct i915_context *) ctx;
}



#define I915_CONTEXT(ctx)	i915_context(ctx)



#endif
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d67 4
a70 4
#define I915_DESTREG_SR0 8
#define I915_DESTREG_SR1 9
#define I915_DESTREG_SR2 10
#define I915_DESTREG_SENABLE 11
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d67 4
a70 4
#define I915_DESTREG_SENABLE 8
#define I915_DESTREG_SR0 9
#define I915_DESTREG_SR1 10
#define I915_DESTREG_SR2 11
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
a252 1
   GLuint last_ReallyEnabled;
d326 1
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d43 1
d143 4
a146 4
   GLboolean translated;
   GLboolean params_uptodate;
   GLboolean on_hardware;
   GLboolean error;             /* If program is malformed for any reason. */
d198 1
a198 1
   GLboolean depth_written;
d322 7
a328 4
extern GLboolean i915CreateContext(int api,
				   const struct gl_config * mesaVis,
                                   __DRIcontext * driContextPriv,
                                   void *sharedContextPrivate);
d345 1
@


1.5
log
@Merge Mesa 7.10.3
@
text
@a31 1
#include "i915_reg.h"
a48 1
#define I915_UPLOAD_FOG              0x20
d52 1
d79 13
a91 18
#define I915_CTXREG_LI	        	1
#define I915_CTXREG_LIS2		        2
#define I915_CTXREG_LIS4	        	3
#define I915_CTXREG_LIS5	        	4
#define I915_CTXREG_LIS6	         	5
#define I915_CTXREG_IAB   	 	6
#define I915_CTXREG_BLENDCOLOR0		7
#define I915_CTXREG_BLENDCOLOR1		8
#define I915_CTXREG_BF_STENCIL_OPS	9
#define I915_CTXREG_BF_STENCIL_MASKS	10
#define I915_CTX_SETUP_SIZE		11

#define I915_FOGREG_COLOR		0
#define I915_FOGREG_MODE0		1
#define I915_FOGREG_MODE1		2
#define I915_FOGREG_MODE2		3
#define I915_FOGREG_MODE3		4
#define I915_FOG_SETUP_SIZE		5
d120 6
d219 1
a221 1
   GLuint Fog[I915_FOG_SETUP_SIZE];
a247 4
#define I915_FOG_PIXEL  2
#define I915_FOG_VERTEX 1
#define I915_FOG_NONE   0

a252 1
   GLuint vertex_fog;
d258 3
d263 1
a338 1
extern void i915_update_fog(struct gl_context * ctx);
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d161 1
a161 1
   GLcontext *ctx;
d240 1
a240 1
   dri_bo *tex_buffer[I915_TEX_UNITS];
d264 1
d322 2
a323 1
extern GLboolean i915CreateContext(const __GLcontextModes * mesaVis,
d340 3
a342 3
extern void i915_update_fog(GLcontext * ctx);
extern void i915_update_stencil(GLcontext * ctx);
extern void i915_update_provoking_vertex(GLcontext *ctx);
d362 1
a362 1
i915_context(GLcontext * ctx)
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d42 2
d53 1
d88 3
a90 1
#define I915_CTX_SETUP_SIZE		9
d118 4
d126 3
d130 4
a133 3
#define I915_PROGRAM_SIZE      192

#define I915_MAX_INSN          (I915_MAX_TEX_INSN+I915_MAX_ALU_INSN)
d163 3
a165 2
   GLuint declarations[I915_PROGRAM_SIZE];
   GLuint program[I915_PROGRAM_SIZE];
d223 1
d263 1
a263 1
   struct i915_hw_state meta, initial, state, *current;
d322 1
a322 1
                                   __DRIcontextPrivate * driContextPriv,
d339 2
a347 6

/*======================================================================
 * i915_metaops.c
 */
void i915InitMetaFuncs(struct i915_context *i915);

@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d68 7
a74 1
#define I915_DEST_SETUP_SIZE 12
d134 3
@


1.1
log
@Initial revision
@
text
@d32 1
d50 1
a59 1
#define I915_DESTREG_CBUFADDR2 2
a61 1
#define I915_DESTREG_DBUFADDR2 5
a91 1
#define I915_TEXREG_MS2        0
d99 9
d114 1
d119 2
a120 1
struct i915_fragment_program {
d126 1
a126 1
   GLboolean error;		/* If program is malformed for any reason. */
d148 12
a159 2
   GLuint *csr;			/* Cursor, points into program.
				 */
d161 3
a163 13
   GLuint *decl;		/* Cursor, points into declarations.
				 */
   
   GLuint decl_s;		/* flags for which s regs need to be decl'd */
   GLuint decl_t;		/* flags for which t regs need to be decl'd */

   GLuint temp_flag;		/* Tracks temporary regs which are in
				 * use.
				 */

   GLuint utemp_flag;		/* Tracks TYPE_U temporary regs which are in
				 * use.
				 */
d166 4
d176 4
a179 3
   struct { 
      GLuint reg;		/* Hardware constant idx */
      const GLfloat *values; 	/* Pointer to tracked values */
a181 17
      



   /* Helpers for i915_texprog.c:
    */
   GLuint src_texture;		/* Reg containing sampled texture color,
				 * else UREG_BAD.
				 */

   GLuint src_previous;		/* Reg containing color from previous 
				 * stage.  May need to be decl'd.
				 */

   GLuint last_tex_stage;	/* Number of last enabled texture unit */

   struct vertex_buffer *VB;
a188 7
struct i915_texture_object
{
   struct intel_texture_object intel;
   GLenum lastTarget;
   GLboolean refs_border_color;
   GLuint Setup[I915_TEX_SETUP_SIZE];
};
d193 2
a194 1
struct i915_hw_state {
d199 1
d205 17
a221 2
   GLuint active;		/* I915_UPLOAD_* */
   GLuint emitted;		/* I915_UPLOAD_* */
d228 1
a228 1
struct i915_context 
d234 2
a236 1
   struct i915_fragment_program tex_program;
a242 7
typedef struct i915_context *i915ContextPtr;
typedef struct i915_texture_object *i915TextureObjectPtr;

#define I915_CONTEXT(ctx)	((i915ContextPtr)(ctx))



a244 1
   if (0) fprintf(stderr, "I915_STATECHANGE %x in %s\n", flag, __FUNCTION__);	\
a250 2
   if (0) fprintf(stderr, "I915_ACTIVESTATE %x %d in %s\n",	\
		  flag, mode, __FUNCTION__);			\
d262 7
a268 1
extern void i915InitVtbl( i915ContextPtr i915 );
d297 3
a299 9
extern GLboolean i915CreateContext( const __GLcontextModes *mesaVis,
				    __DRIcontextPrivate *driContextPriv,
				    void *sharedContextPrivate);


/*======================================================================
 * i915_texprog.c
 */
extern void i915ValidateTextureProgram( i915ContextPtr i915 );
d305 2
a306 2
extern void i915_disassemble_program( const GLuint *program, GLuint sz );
extern void i915_print_ureg( const char *msg, GLuint ureg );
d312 3
a314 3
extern void i915InitStateFunctions( struct dd_function_table *functions );
extern void i915InitState( i915ContextPtr i915 );
extern void i915_update_fog(GLcontext *ctxx);
d320 2
a321 3
extern void i915UpdateTextureState( intelContextPtr intel );
extern void i915InitTextureFuncs( struct dd_function_table *functions );
extern intelTextureObjectPtr i915AllocTexObj( struct gl_texture_object *texObj );
d326 1
a326 17
extern GLboolean
i915TryTextureReadPixels( GLcontext *ctx,
			  GLint x, GLint y, GLsizei width, GLsizei height,
			  GLenum format, GLenum type,
			  const struct gl_pixelstore_attrib *pack,
			  GLvoid *pixels );

extern GLboolean
i915TryTextureDrawPixels( GLcontext *ctx,
			  GLint x, GLint y, GLsizei width, GLsizei height,
			  GLenum format, GLenum type,
			  const struct gl_pixelstore_attrib *unpack,
			  const GLvoid *pixels );

extern void 
i915ClearWithTris( intelContextPtr intel, GLbitfield mask,
		   GLboolean all, GLint cx, GLint cy, GLint cw, GLint ch);
d329 5
a333 3
extern void
i915RotateWindow(intelContextPtr intel, __DRIdrawablePrivate *dPriv,
                 GLuint srcBuf);
d336 2
a337 1
 * i915_fragprog.c
d339 12
a350 3
extern void i915ValidateFragmentProgram( i915ContextPtr i915 );
extern void i915InitFragProgFuncs( struct dd_function_table *functions );
	
a351 1

@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@a31 1
#include "i915_reg.h"
a40 2
#define I915_FALLBACK_POINT_SPRITE_COORD_ORIGIN	 0x100000
#define I915_FALLBACK_DRAW_OFFSET	 0x200000
a48 2
#define I915_UPLOAD_DEFAULTS         0x80
#define I915_UPLOAD_RASTER_RULES     0x100
d58 1
d61 1
d68 1
a68 7
#define I915_DESTREG_DRAWRECT0 12
#define I915_DESTREG_DRAWRECT1 13
#define I915_DESTREG_DRAWRECT2 14
#define I915_DESTREG_DRAWRECT3 15
#define I915_DESTREG_DRAWRECT4 16
#define I915_DESTREG_DRAWRECT5 17
#define I915_DEST_SETUP_SIZE 18
d79 1
a79 3
#define I915_CTXREG_BF_STENCIL_OPS	9
#define I915_CTXREG_BF_STENCIL_MASKS	10
#define I915_CTX_SETUP_SIZE		11
d92 1
a99 13
#define I915_DEFREG_C0    0
#define I915_DEFREG_C1    1
#define I915_DEFREG_S0    2
#define I915_DEFREG_S1    3
#define I915_DEFREG_Z0    4
#define I915_DEFREG_Z1    5
#define I915_DEF_SETUP_SIZE    6

enum {
   I915_RASTER_RULES,
   I915_RASTER_RULES_SETUP_SIZE,
};

a102 3
#define I915_MAX_INSN          (I915_MAX_DECL_INSN + \
				I915_MAX_TEX_INSN + \
				I915_MAX_ALU_INSN)
d104 2
a105 4
/* Maximum size of the program packet, which matches the limits on
 * decl, tex, and ALU instructions.
 */
#define I915_PROGRAM_SIZE      (I915_MAX_INSN * 3 + 1)
d110 1
a110 2
struct i915_fragment_program
{
d116 1
a116 1
   GLboolean error;             /* If program is malformed for any reason. */
a117 3
   /** Record of which phases R registers were last written in. */
   GLuint register_phases[16];
   GLuint indirections;
d129 1
a129 1
   struct gl_context *ctx;
d131 2
a132 3
   /* declarations contains the packet header. */
   GLuint declarations[I915_MAX_DECL_INSN * 3 + 1];
   GLuint program[(I915_MAX_TEX_INSN + I915_MAX_ALU_INSN) * 3];
d138 2
a139 5
   GLuint *csr;                 /* Cursor, points into program.
                                 */

   GLuint *decl;                /* Cursor, points into declarations.
                                 */
d141 13
a153 2
   GLuint decl_s;               /* flags for which s regs need to be decl'd */
   GLuint decl_t;               /* flags for which t regs need to be decl'd */
a154 3
   GLuint temp_flag;            /* Tracks temporary regs which are in
                                 * use.
                                 */
a155 9
   GLuint utemp_flag;           /* Tracks TYPE_U temporary regs which are in
                                 * use.
                                 */


   /* Track which R registers are "live" for each instruction.
    * A register is live between the time it's written to and the last time
    * it's read. */
   GLuint usedRegs[I915_MAX_INSN];
d162 3
a164 4
   struct
   {
      GLuint reg;               /* Hardware constant idx */
      const GLfloat *values;    /* Pointer to tracked values */
d167 17
d191 7
d202 1
a202 2
struct i915_hw_state
{
a206 2
   GLuint Defaults[I915_DEF_SETUP_SIZE];
   GLuint RasterRules[I915_RASTER_RULES_SETUP_SIZE];
d212 2
a213 17

   /* Region pointers for relocation: 
    */
   struct intel_region *draw_region;
   struct intel_region *depth_region;
/*    struct intel_region *tex_region[I915_TEX_UNITS]; */

   /* Regions aren't actually that appropriate here as the memory may
    * be from a PBO or FBO.  Will have to do this for draw and depth for
    * FBO's...
    */
   drm_intel_bo *tex_buffer[I915_TEX_UNITS];
   GLuint tex_offset[I915_TEX_UNITS];


   GLuint active;               /* I915_UPLOAD_* */
   GLuint emitted;              /* I915_UPLOAD_* */
d220 1
a220 1
struct i915_context
a225 2
   GLuint lodbias_ss2[MAX_TEXTURE_UNITS];

d227 1
d230 1
a230 2
   struct i915_hw_state state;
   uint32_t last_draw_offset;
d234 7
d243 1
d250 2
d263 1
a263 7
extern void i915InitVtbl(struct i915_context *i915);

extern void
i915_state_draw_region(struct intel_context *intel,
                       struct i915_hw_state *state,
                       struct intel_region *color_region,
                       struct intel_region *depth_region);
d292 9
a300 4
extern GLboolean i915CreateContext(int api,
				   const struct gl_config * mesaVis,
                                   __DRIcontext * driContextPriv,
                                   void *sharedContextPrivate);
d306 2
a307 2
extern void i915_disassemble_program(const GLuint * program, GLuint sz);
extern void i915_print_ureg(const char *msg, GLuint ureg);
d313 3
a315 5
extern void i915InitStateFunctions(struct dd_function_table *functions);
extern void i915InitState(struct i915_context *i915);
extern void i915_update_fog(struct gl_context * ctx);
extern void i915_update_stencil(struct gl_context * ctx);
extern void i915_update_provoking_vertex(struct gl_context *ctx);
d321 3
a323 2
extern void i915UpdateTextureState(struct intel_context *intel);
extern void i915InitTextureFuncs(struct dd_function_table *functions);
d326 1
a326 1
 * i915_fragprog.c
d328 22
a349 2
extern void i915ValidateFragmentProgram(struct i915_context *i915);
extern void i915InitFragProgFuncs(struct dd_function_table *functions);
d352 1
a352 2
 * Inline conversion functions.  These are better-typed than the
 * macros used previously:
d354 4
a357 6
static INLINE struct i915_context *
i915_context(struct gl_context * ctx)
{
   return (struct i915_context *) ctx;
}

a358 6

#define I915_CONTEXT(ctx)	i915_context(ctx)



#endif
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d32 1
a43 1
#define I915_FALLBACK_COORD_REPLACE	 0x400000
d50 1
a53 1
#define I915_UPLOAD_BLEND            0x200
d80 18
a97 13
#define I915_CTXREG_LI			1
#define I915_CTXREG_LIS2		2
#define I915_CTXREG_LIS4		3
#define I915_CTXREG_LIS5		4
#define I915_CTXREG_LIS6		5
#define I915_CTXREG_BF_STENCIL_OPS	6
#define I915_CTXREG_BF_STENCIL_MASKS	7
#define I915_CTX_SETUP_SIZE		8

#define I915_BLENDREG_IAB		0
#define I915_BLENDREG_BLENDCOLOR0	1
#define I915_BLENDREG_BLENDCOLOR1	2
#define I915_BLEND_SETUP_SIZE		3
a125 6
#define I915_MAX_TEX_INDIRECT 4
#define I915_MAX_TEX_INSN     32
#define I915_MAX_ALU_INSN     64
#define I915_MAX_DECL_INSN    27
#define I915_MAX_TEMPORARY    16

d142 4
a145 4
   bool translated;
   bool params_uptodate;
   bool on_hardware;
   bool error;             /* If program is malformed for any reason. */
d197 1
a197 1
   bool depth_written;
a218 1
   GLuint Blend[I915_BLEND_SETUP_SIZE];
d221 1
d248 4
d257 1
a262 3
   drm_intel_bo *current_vb_bo;
   unsigned int current_vertex_size;

a264 1
   GLuint last_sampler;
d322 4
a325 7
extern bool i915CreateContext(int api,
			      const struct gl_config * mesaVis,
			      __DRIcontext * driContextPriv,
                              unsigned major_version,
                              unsigned minor_version,
                              unsigned *error,
			      void *sharedContextPrivate);
d340 1
a342 1
extern void i915_update_sprite_point_enable(struct gl_context *ctx);
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d253 1
a326 1
                              uint32_t flags,
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d67 4
a70 4
#define I915_DESTREG_SR0 8
#define I915_DESTREG_SR1 9
#define I915_DESTREG_SR2 10
#define I915_DESTREG_SENABLE 11
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d67 4
a70 4
#define I915_DESTREG_SENABLE 8
#define I915_DESTREG_SR0 9
#define I915_DESTREG_SR1 10
#define I915_DESTREG_SR2 11
@


