head	1.5;
access;
symbols
	OPENBSD_5_4:1.4.0.14
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.12
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.10
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.8
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.09.05.14.04.13;	author jsg;	state dead;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.32;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.32;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge Mesa 9.2.0
@
text
@/**************************************************************************
 * 
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "main/imports.h"

#include "i915_reg.h"
#include "i915_context.h"
#include "i915_debug.h"

static GLboolean debug( struct debug_stream *stream, const char *name, GLuint len )
{
   GLuint i;
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   
   if (len == 0) {
      printf("Error - zero length packet (0x%08x)\n", stream->ptr[0]);
      assert(0);
      return GL_FALSE;
   }

   if (stream->print_addresses)
      printf("%08x:  ", stream->offset);


   printf("%s (%d dwords):\n", name, len);
   for (i = 0; i < len; i++)
      printf("\t0x%08x\n",  ptr[i]);   
   printf("\n");

   stream->offset += len * sizeof(GLuint);
   
   return GL_TRUE;
}


static const char *get_prim_name( GLuint val )
{
   switch (val & PRIM3D_MASK) {
   case PRIM3D_TRILIST: return "TRILIST"; break;
   case PRIM3D_TRISTRIP: return "TRISTRIP"; break;
   case PRIM3D_TRISTRIP_RVRSE: return "TRISTRIP_RVRSE"; break;
   case PRIM3D_TRIFAN: return "TRIFAN"; break;
   case PRIM3D_POLY: return "POLY"; break;
   case PRIM3D_LINELIST: return "LINELIST"; break;
   case PRIM3D_LINESTRIP: return "LINESTRIP"; break;
   case PRIM3D_RECTLIST: return "RECTLIST"; break;
   case PRIM3D_POINTLIST: return "POINTLIST"; break;
   case PRIM3D_DIB: return "DIB"; break;
   case PRIM3D_CLEAR_RECT: return "CLEAR_RECT"; break;
   case PRIM3D_ZONE_INIT: return "ZONE_INIT"; break;
   default: return "????"; break;
   }
}

static GLboolean debug_prim( struct debug_stream *stream, const char *name, 
			     GLboolean dump_floats,
			     GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   const char *prim = get_prim_name( ptr[0] );
   GLuint i;
   


   printf("%s %s (%d dwords):\n", name, prim, len);
   printf("\t0x%08x\n",  ptr[0]);   
   for (i = 1; i < len; i++) {
      if (dump_floats)
	 printf("\t0x%08x // %f\n",  ptr[i], *(GLfloat *)&ptr[i]);   
      else
	 printf("\t0x%08x\n",  ptr[i]);   
   }

      
   printf("\n");

   stream->offset += len * sizeof(GLuint);
   
   return GL_TRUE;
}
   



static GLboolean debug_program( struct debug_stream *stream, const char *name, GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);

   if (len == 0) {
      printf("Error - zero length packet (0x%08x)\n", stream->ptr[0]);
      assert(0);
      return GL_FALSE;
   }

   if (stream->print_addresses)
      printf("%08x:  ", stream->offset);

   printf("%s (%d dwords):\n", name, len);
   i915_disassemble_program( ptr, len );

   stream->offset += len * sizeof(GLuint);
   return GL_TRUE;
}


static GLboolean debug_chain( struct debug_stream *stream, const char *name, GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   GLuint old_offset = stream->offset + len * sizeof(GLuint);
   GLuint i;

   printf("%s (%d dwords):\n", name, len);
   for (i = 0; i < len; i++)
      printf("\t0x%08x\n",  ptr[i]);

   stream->offset = ptr[1] & ~0x3;
   
   if (stream->offset < old_offset)
      printf("\n... skipping backwards from 0x%x --> 0x%x ...\n\n", 
		   old_offset, stream->offset );
   else
      printf("\n... skipping from 0x%x --> 0x%x ...\n\n", 
		   old_offset, stream->offset );


   return GL_TRUE;
}


static GLboolean debug_variable_length_prim( struct debug_stream *stream )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   const char *prim = get_prim_name( ptr[0] );
   GLuint i, len;

   GLushort *idx = (GLushort *)(ptr+1);
   for (i = 0; idx[i] != 0xffff; i++)
      ;

   len = 1+(i+2)/2;

   printf("3DPRIM, %s variable length %d indicies (%d dwords):\n", prim, i, len);
   for (i = 0; i < len; i++)
      printf("\t0x%08x\n",  ptr[i]);
   printf("\n");

   stream->offset += len * sizeof(GLuint);
   return GL_TRUE;
}


#define BITS( dw, hi, lo, ... )				\
do {							\
   unsigned himask = 0xffffffffU >> (31 - (hi));		\
   printf("\t\t ");				\
   printf(__VA_ARGS__);			\
   printf(": 0x%x\n", ((dw) & himask) >> (lo));	\
} while (0)

#define MBZ( dw, hi, lo) do {							\
   unsigned x = (dw) >> (lo);				\
   unsigned lomask = (1 << (lo)) - 1;			\
   unsigned himask;					\
   himask = (1UL << (hi)) - 1;				\
   assert ((x & himask & ~lomask) == 0);	\
} while (0)

#define FLAG( dw, bit, ... )			\
do {							\
   if (((dw) >> (bit)) & 1) {				\
      printf("\t\t ");				\
      printf(__VA_ARGS__);			\
      printf("\n");				\
   }							\
} while (0)

static GLboolean debug_load_immediate( struct debug_stream *stream,
				       const char *name,
				       GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   GLuint bits = (ptr[0] >> 4) & 0xff;
   GLuint j = 0;
   
   printf("%s (%d dwords, flags: %x):\n", name, len, bits);
   printf("\t0x%08x\n",  ptr[j++]);

   if (bits & (1<<0)) {
      printf("\t  LIS0: 0x%08x\n", ptr[j]);
      printf("\t vb address: 0x%08x\n", (ptr[j] & ~0x3));
      BITS(ptr[j], 0, 0, "vb invalidate disable");
      j++;
   }
   if (bits & (1<<1)) {
      printf("\t  LIS1: 0x%08x\n", ptr[j]);
      BITS(ptr[j], 29, 24, "vb dword width");
      BITS(ptr[j], 21, 16, "vb dword pitch");
      BITS(ptr[j], 15, 0, "vb max index");
      j++;
   }
   if (bits & (1<<2)) {
      int i;
      printf("\t  LIS2: 0x%08x\n", ptr[j]);
      for (i = 0; i < 8; i++) {
	 unsigned tc = (ptr[j] >> (i * 4)) & 0xf;
	 if (tc != 0xf)
	    BITS(tc, 3, 0, "tex coord %d", i);
      }
      j++;
   }
   if (bits & (1<<3)) {
      printf("\t  LIS3: 0x%08x\n", ptr[j]);
      j++;
   }
   if (bits & (1<<4)) {
      printf("\t  LIS4: 0x%08x\n", ptr[j]);
      BITS(ptr[j], 31, 23, "point width");
      BITS(ptr[j], 22, 19, "line width");
      FLAG(ptr[j], 18, "alpha flatshade");
      FLAG(ptr[j], 17, "fog flatshade");
      FLAG(ptr[j], 16, "spec flatshade");
      FLAG(ptr[j], 15, "rgb flatshade");
      BITS(ptr[j], 14, 13, "cull mode");
      FLAG(ptr[j], 12, "vfmt: point width");
      FLAG(ptr[j], 11, "vfmt: specular/fog");
      FLAG(ptr[j], 10, "vfmt: rgba");
      FLAG(ptr[j], 9, "vfmt: depth offset");
      BITS(ptr[j], 8, 6, "vfmt: position (2==xyzw)");
      FLAG(ptr[j], 5, "force dflt diffuse");
      FLAG(ptr[j], 4, "force dflt specular");
      FLAG(ptr[j], 3, "local depth offset enable");
      FLAG(ptr[j], 2, "vfmt: fp32 fog coord");
      FLAG(ptr[j], 1, "sprite point");
      FLAG(ptr[j], 0, "antialiasing");
      j++;
   }
   if (bits & (1<<5)) {
      printf("\t  LIS5: 0x%08x\n", ptr[j]);
      BITS(ptr[j], 31, 28, "rgba write disables");
      FLAG(ptr[j], 27,     "force dflt point width");
      FLAG(ptr[j], 26,     "last pixel enable");
      FLAG(ptr[j], 25,     "global z offset enable");
      FLAG(ptr[j], 24,     "fog enable");
      BITS(ptr[j], 23, 16, "stencil ref");
      BITS(ptr[j], 15, 13, "stencil test");
      BITS(ptr[j], 12, 10, "stencil fail op");
      BITS(ptr[j], 9, 7,   "stencil pass z fail op");
      BITS(ptr[j], 6, 4,   "stencil pass z pass op");
      FLAG(ptr[j], 3,      "stencil write enable");
      FLAG(ptr[j], 2,      "stencil test enable");
      FLAG(ptr[j], 1,      "color dither enable");
      FLAG(ptr[j], 0,      "logiop enable");
      j++;
   }
   if (bits & (1<<6)) {
      printf("\t  LIS6: 0x%08x\n", ptr[j]);
      FLAG(ptr[j], 31,      "alpha test enable");
      BITS(ptr[j], 30, 28,  "alpha func");
      BITS(ptr[j], 27, 20,  "alpha ref");
      FLAG(ptr[j], 19,      "depth test enable");
      BITS(ptr[j], 18, 16,  "depth func");
      FLAG(ptr[j], 15,      "blend enable");
      BITS(ptr[j], 14, 12,  "blend func");
      BITS(ptr[j], 11, 8,   "blend src factor");
      BITS(ptr[j], 7,  4,   "blend dst factor");
      FLAG(ptr[j], 3,       "depth write enable");
      FLAG(ptr[j], 2,       "color write enable");
      BITS(ptr[j], 1,  0,   "provoking vertex"); 
      j++;
   }


   printf("\n");

   assert(j == len);

   stream->offset += len * sizeof(GLuint);
   
   return GL_TRUE;
}
 


static GLboolean debug_load_indirect( struct debug_stream *stream,
				      const char *name,
				      GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   GLuint bits = (ptr[0] >> 8) & 0x3f;
   GLuint i, j = 0;
   
   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j++]);

   for (i = 0; i < 6; i++) {
      if (bits & (1<<i)) {
	 switch (1<<(8+i)) {
	 case LI0_STATE_STATIC_INDIRECT:
	    printf("        STATIC: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    printf("                0x%08x\n", ptr[j++]);
	    break;
	 case LI0_STATE_DYNAMIC_INDIRECT:
	    printf("       DYNAMIC: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    break;
	 case LI0_STATE_SAMPLER:
	    printf("       SAMPLER: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    printf("                0x%08x\n", ptr[j++]);
	    break;
	 case LI0_STATE_MAP:
	    printf("           MAP: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    printf("                0x%08x\n", ptr[j++]);
	    break;
	 case LI0_STATE_PROGRAM:
	    printf("       PROGRAM: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    printf("                0x%08x\n", ptr[j++]);
	    break;
	 case LI0_STATE_CONSTANTS:
	    printf("     CONSTANTS: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    printf("                0x%08x\n", ptr[j++]);
	    break;
	 default:
	    assert(0);
	    break;
	 }
      }
   }

   if (bits == 0) {
      printf("\t  DUMMY: 0x%08x\n", ptr[j++]);
   }

   printf("\n");


   assert(j == len);

   stream->offset += len * sizeof(GLuint);
   
   return GL_TRUE;
}
 	
static void BR13( struct debug_stream *stream,
		  GLuint val )
{
   printf("\t0x%08x\n",  val);
   FLAG(val, 30, "clipping enable");
   BITS(val, 25, 24, "color depth (3==32bpp)");
   BITS(val, 23, 16, "raster op");
   BITS(val, 15, 0,  "dest pitch");
}


static void BR2223( struct debug_stream *stream,
		    GLuint val22, GLuint val23 )
{
   union { GLuint val; short field[2]; } BR22, BR23;

   BR22.val = val22;
   BR23.val = val23;

   printf("\t0x%08x\n",  val22);
   BITS(val22, 31, 16, "dest y1");
   BITS(val22, 15, 0,  "dest x1");

   printf("\t0x%08x\n",  val23);
   BITS(val23, 31, 16, "dest y2");
   BITS(val23, 15, 0,  "dest x2");

   /* The blit engine may produce unexpected results when these aren't met */
   assert(BR22.field[0] < BR23.field[0]);
   assert(BR22.field[1] < BR23.field[1]);
}

static void BR09( struct debug_stream *stream,
		  GLuint val )
{
   printf("\t0x%08x -- dest address\n",  val);
}

static void BR26( struct debug_stream *stream,
		  GLuint val )
{
   printf("\t0x%08x\n",  val);
   BITS(val, 31, 16, "src y1");
   BITS(val, 15, 0,  "src x1");
}

static void BR11( struct debug_stream *stream,
		  GLuint val )
{
   printf("\t0x%08x\n",  val);
   BITS(val, 15, 0,  "src pitch");
}

static void BR12( struct debug_stream *stream,
		  GLuint val )
{
   printf("\t0x%08x -- src address\n",  val);
}

static void BR16( struct debug_stream *stream,
		  GLuint val )
{
   printf("\t0x%08x -- color\n",  val);
}
   
static GLboolean debug_copy_blit( struct debug_stream *stream,
				  const char *name,
				  GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   int j = 0;

   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j++]);
   
   BR13(stream, ptr[j++]);
   BR2223(stream, ptr[j], ptr[j+1]);
   j += 2;
   BR09(stream, ptr[j++]);
   BR26(stream, ptr[j++]);
   BR11(stream, ptr[j++]);
   BR12(stream, ptr[j++]);

   stream->offset += len * sizeof(GLuint);
   assert(j == len);
   return GL_TRUE;
}

static GLboolean debug_color_blit( struct debug_stream *stream,
				  const char *name,
				  GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   int j = 0;

   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j++]);

   BR13(stream, ptr[j++]);
   BR2223(stream, ptr[j], ptr[j+1]);
   j += 2;
   BR09(stream, ptr[j++]);
   BR16(stream, ptr[j++]);

   stream->offset += len * sizeof(GLuint);
   assert(j == len);
   return GL_TRUE;
}

static GLboolean debug_modes4( struct debug_stream *stream,
				  const char *name,
				  GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   int j = 0;

   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j]);
   BITS(ptr[j], 21, 18, "logicop func");
   FLAG(ptr[j], 17, "stencil test mask modify-enable");
   FLAG(ptr[j], 16, "stencil write mask modify-enable");
   BITS(ptr[j], 15, 8, "stencil test mask");
   BITS(ptr[j], 7, 0,  "stencil write mask");
   j++;

   stream->offset += len * sizeof(GLuint);
   assert(j == len);
   return GL_TRUE;
}

static GLboolean debug_map_state( struct debug_stream *stream,
				  const char *name,
				  GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   int j = 0;

   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j++]);
   
   {
      printf("\t0x%08x\n",  ptr[j]);
      BITS(ptr[j], 15, 0,   "map mask");
      j++;
   }

   while (j < len) {
      {
	 printf("\t  TMn.0: 0x%08x\n", ptr[j]);
	 printf("\t map address: 0x%08x\n", (ptr[j] & ~0x3));
	 FLAG(ptr[j], 1, "vertical line stride");
	 FLAG(ptr[j], 0, "vertical line stride offset");
	 j++;
      }

      {
	 printf("\t  TMn.1: 0x%08x\n", ptr[j]);
	 BITS(ptr[j], 31, 21, "height");
	 BITS(ptr[j], 20, 10, "width");
	 BITS(ptr[j], 9, 7, "surface format");
	 BITS(ptr[j], 6, 3, "texel format");
	 FLAG(ptr[j], 2, "use fence regs");
	 FLAG(ptr[j], 1, "tiled surface");
	 FLAG(ptr[j], 0, "tile walk ymajor");
	 j++;
      }
      {
	 printf("\t  TMn.2: 0x%08x\n", ptr[j]);
	 BITS(ptr[j], 31, 21, "dword pitch");
	 BITS(ptr[j], 20, 15, "cube face enables");
	 BITS(ptr[j], 14, 9, "max lod");
	 FLAG(ptr[j], 8,     "mip layout right");
	 BITS(ptr[j], 7, 0, "depth");
	 j++;
      }
   }

   stream->offset += len * sizeof(GLuint);
   assert(j == len);
   return GL_TRUE;
}

static GLboolean debug_sampler_state( struct debug_stream *stream,
				  const char *name,
				  GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   int j = 0;

   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j++]);
   
   {
      printf("\t0x%08x\n",  ptr[j]);
      BITS(ptr[j], 15, 0,   "sampler mask");
      j++;
   }

   while (j < len) {
      {
	 printf("\t  TSn.0: 0x%08x\n", ptr[j]);
	 FLAG(ptr[j], 31, "reverse gamma");
	 FLAG(ptr[j], 30, "planar to packed");
	 FLAG(ptr[j], 29, "yuv->rgb");
	 BITS(ptr[j], 28, 27, "chromakey index");
	 BITS(ptr[j], 26, 22, "base mip level");
	 BITS(ptr[j], 21, 20, "mip mode filter");
	 BITS(ptr[j], 19, 17, "mag mode filter");
	 BITS(ptr[j], 16, 14, "min mode filter");
	 BITS(ptr[j], 13, 5,  "lod bias (s4.4)");
	 FLAG(ptr[j], 4,      "shadow enable");
	 FLAG(ptr[j], 3,      "max-aniso-4");
	 BITS(ptr[j], 2, 0,   "shadow func");
	 j++;
      }

      {
	 printf("\t  TSn.1: 0x%08x\n", ptr[j]);
	 BITS(ptr[j], 31, 24, "min lod");
	 MBZ( ptr[j], 23, 18 );
	 FLAG(ptr[j], 17,     "kill pixel enable");
	 FLAG(ptr[j], 16,     "keyed tex filter mode");
	 FLAG(ptr[j], 15,     "chromakey enable");
	 BITS(ptr[j], 14, 12, "tcx wrap mode");
	 BITS(ptr[j], 11, 9,  "tcy wrap mode");
	 BITS(ptr[j], 8,  6,  "tcz wrap mode");
	 FLAG(ptr[j], 5,      "normalized coords");
	 BITS(ptr[j], 4,  1,  "map (surface) index");
	 FLAG(ptr[j], 0,      "EAST deinterlacer enable");
	 j++;
      }
      {
	 printf("\t  TSn.2: 0x%08x  (default color)\n", ptr[j]);
	 j++;
      }
   }

   stream->offset += len * sizeof(GLuint);
   assert(j == len);
   return GL_TRUE;
}

static GLboolean debug_dest_vars( struct debug_stream *stream,
				  const char *name,
				  GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   int j = 0;

   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j++]);

   {
      printf("\t0x%08x\n",  ptr[j]);
      FLAG(ptr[j], 31,     "early classic ztest");
      FLAG(ptr[j], 30,     "opengl tex default color");
      FLAG(ptr[j], 29,     "bypass iz");
      FLAG(ptr[j], 28,     "lod preclamp");
      BITS(ptr[j], 27, 26, "dither pattern");
      FLAG(ptr[j], 25,     "linear gamma blend");
      FLAG(ptr[j], 24,     "debug dither");
      BITS(ptr[j], 23, 20, "dstorg x");
      BITS(ptr[j], 19, 16, "dstorg y");
      MBZ (ptr[j], 15, 15 );
      BITS(ptr[j], 14, 12, "422 write select");
      BITS(ptr[j], 11, 8,  "cbuf format");
      BITS(ptr[j], 3, 2,   "zbuf format");
      FLAG(ptr[j], 1,      "vert line stride");
      FLAG(ptr[j], 1,      "vert line stride offset");
      j++;
   }
   
   stream->offset += len * sizeof(GLuint);
   assert(j == len);
   return GL_TRUE;
}

static GLboolean debug_buf_info( struct debug_stream *stream,
				  const char *name,
				  GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   int j = 0;

   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j++]);

   {
      printf("\t0x%08x\n",  ptr[j]);
      BITS(ptr[j], 28, 28, "aux buffer id");
      BITS(ptr[j], 27, 24, "buffer id (7=depth, 3=back)");
      FLAG(ptr[j], 23,     "use fence regs");
      FLAG(ptr[j], 22,     "tiled surface");
      FLAG(ptr[j], 21,     "tile walk ymajor");
      MBZ (ptr[j], 20, 14);
      BITS(ptr[j], 13, 2,  "dword pitch");
      MBZ (ptr[j], 2,  0);
      j++;
   }
   
   printf("\t0x%08x -- buffer base address\n",  ptr[j++]);

   stream->offset += len * sizeof(GLuint);
   assert(j == len);
   return GL_TRUE;
}

static GLboolean i915_debug_packet( struct debug_stream *stream )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   GLuint cmd = *ptr;
   
   switch (((cmd >> 29) & 0x7)) {
   case 0x0:
      switch ((cmd >> 23) & 0x3f) {
      case 0x0:
	 return debug(stream, "MI_NOOP", 1);
      case 0x3:
	 return debug(stream, "MI_WAIT_FOR_EVENT", 1);
      case 0x4:
	 return debug(stream, "MI_FLUSH", 1);
      case 0xA:
	 debug(stream, "MI_BATCH_BUFFER_END", 1);
	 return GL_FALSE;
      case 0x22:
	 return debug(stream, "MI_LOAD_REGISTER_IMM", 3);
      case 0x31:
	 return debug_chain(stream, "MI_BATCH_BUFFER_START", 2);
      default:
	 break;
      }
      break;
   case 0x1:
      break;
   case 0x2:
      switch ((cmd >> 22) & 0xff) {	 
      case 0x50:
	 return debug_color_blit(stream, "XY_COLOR_BLT", (cmd & 0xff) + 2);
      case 0x53:
	 return debug_copy_blit(stream, "XY_SRC_COPY_BLT", (cmd & 0xff) + 2);
      default:
	 return debug(stream, "blit command", (cmd & 0xff) + 2);
      }
      break;
   case 0x3:
      switch ((cmd >> 24) & 0x1f) {	 
      case 0x6:
	 return debug(stream, "3DSTATE_ANTI_ALIASING", 1);
      case 0x7:
	 return debug(stream, "3DSTATE_RASTERIZATION_RULES", 1);
      case 0x8:
	 return debug(stream, "3DSTATE_BACKFACE_STENCIL_OPS", 2);
      case 0x9:
	 return debug(stream, "3DSTATE_BACKFACE_STENCIL_MASKS", 1);
      case 0xb:
	 return debug(stream, "3DSTATE_INDEPENDENT_ALPHA_BLEND", 1);
      case 0xc:
	 return debug(stream, "3DSTATE_MODES5", 1);	 
      case 0xd:
	 return debug_modes4(stream, "3DSTATE_MODES4", 1);
      case 0x15:
	 return debug(stream, "3DSTATE_FOG_COLOR", 1);
      case 0x16:
	 return debug(stream, "3DSTATE_COORD_SET_BINDINGS", 1);
      case 0x1c:
	 /* 3DState16NP */
	 switch((cmd >> 19) & 0x1f) {
	 case 0x10:
	    return debug(stream, "3DSTATE_SCISSOR_ENABLE", 1);
	 case 0x11:
	    return debug(stream, "3DSTATE_DEPTH_SUBRECTANGLE_DISABLE", 1);
	 default:
	    break;
	 }
	 break;
      case 0x1d:
	 /* 3DStateMW */
	 switch ((cmd >> 16) & 0xff) {
	 case 0x0:
	    return debug_map_state(stream, "3DSTATE_MAP_STATE", (cmd & 0x1f) + 2);
	 case 0x1:
	    return debug_sampler_state(stream, "3DSTATE_SAMPLER_STATE", (cmd & 0x1f) + 2);
	 case 0x4:
	    return debug_load_immediate(stream, "3DSTATE_LOAD_STATE_IMMEDIATE", (cmd & 0xf) + 2);
	 case 0x5:
	    return debug_program(stream, "3DSTATE_PIXEL_SHADER_PROGRAM", (cmd & 0x1ff) + 2);
	 case 0x6:
	    return debug(stream, "3DSTATE_PIXEL_SHADER_CONSTANTS", (cmd & 0xff) + 2);
	 case 0x7:
	    return debug_load_indirect(stream, "3DSTATE_LOAD_INDIRECT", (cmd & 0xff) + 2);
	 case 0x80:
	    return debug(stream, "3DSTATE_DRAWING_RECTANGLE", (cmd & 0xffff) + 2);
	 case 0x81:
	    return debug(stream, "3DSTATE_SCISSOR_RECTANGLE", (cmd & 0xffff) + 2);
	 case 0x83:
	    return debug(stream, "3DSTATE_SPAN_STIPPLE", (cmd & 0xffff) + 2);
	 case 0x85:
	    return debug_dest_vars(stream, "3DSTATE_DEST_BUFFER_VARS", (cmd & 0xffff) + 2);
	 case 0x88:
	    return debug(stream, "3DSTATE_CONSTANT_BLEND_COLOR", (cmd & 0xffff) + 2);
	 case 0x89:
	    return debug(stream, "3DSTATE_FOG_MODE", (cmd & 0xffff) + 2);
	 case 0x8e:
	    return debug_buf_info(stream, "3DSTATE_BUFFER_INFO", (cmd & 0xffff) + 2);
	 case 0x97:
	    return debug(stream, "3DSTATE_DEPTH_OFFSET_SCALE", (cmd & 0xffff) + 2);
	 case 0x98:
	    return debug(stream, "3DSTATE_DEFAULT_Z", (cmd & 0xffff) + 2);
	 case 0x99:
	    return debug(stream, "3DSTATE_DEFAULT_DIFFUSE", (cmd & 0xffff) + 2);
	 case 0x9a:
	    return debug(stream, "3DSTATE_DEFAULT_SPECULAR", (cmd & 0xffff) + 2);
	 case 0x9c:
	    return debug(stream, "3DSTATE_CLEAR_PARAMETERS", (cmd & 0xffff) + 2);
	 default:
	    assert(0);
	    return 0;
	 }
	 break;
      case 0x1e:
	 if (cmd & (1 << 23))
	    return debug(stream, "???", (cmd & 0xffff) + 1);
	 else
	    return debug(stream, "", 1);
	 break;
      case 0x1f:
	 if ((cmd & (1 << 23)) == 0)	
	    return debug_prim(stream, "3DPRIM (inline)", 1, (cmd & 0x1ffff) + 2);
	 else if (cmd & (1 << 17)) 
	 {
	    if ((cmd & 0xffff) == 0)
	       return debug_variable_length_prim(stream);
	    else
	       return debug_prim(stream, "3DPRIM (indexed)", 0, (((cmd & 0xffff) + 1) / 2) + 1);
	 }
	 else
	    return debug_prim(stream, "3DPRIM  (indirect sequential)", 0, 2); 
	 break;
      default:
	 return debug(stream, "", 0);
      }
      break;
   default:
      assert(0);
      return 0;
   }

   assert(0);
   return 0;
}



void
i915_dump_batchbuffer( GLuint *start,
		       GLuint *end )
{
   struct debug_stream stream;
   GLuint bytes = (end - start) * 4;
   GLboolean done = GL_FALSE;

   printf("\n\nBATCH: (%d)\n", bytes / 4);

   stream.offset = 0;
   stream.ptr = (char *)start;
   stream.print_addresses = 0;

   while (!done &&
	  stream.offset < bytes &&
	  stream.offset >= 0)
   {
      if (!i915_debug_packet( &stream ))
	 break;

      assert(stream.offset <= bytes &&
	     stream.offset >= 0);
   }

   printf("END-BATCH\n\n\n");
}


@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a33 2
#define PRINTF( ... ) _mesa_printf( __VA_ARGS__ )

d40 1
a40 1
      PRINTF("Error - zero length packet (0x%08x)\n", stream->ptr[0]);
d46 1
a46 1
      PRINTF("%08x:  ", stream->offset);
d49 1
a49 1
   PRINTF("%s (%d dwords):\n", name, len);
d51 2
a52 2
      PRINTF("\t0x%08x\n",  ptr[i]);   
   PRINTF("\n");
d89 2
a90 2
   PRINTF("%s %s (%d dwords):\n", name, prim, len);
   PRINTF("\t0x%08x\n",  ptr[0]);   
d93 1
a93 1
	 PRINTF("\t0x%08x // %f\n",  ptr[i], *(GLfloat *)&ptr[i]);   
d95 1
a95 1
	 PRINTF("\t0x%08x\n",  ptr[i]);   
d99 1
a99 1
   PRINTF("\n");
d114 1
a114 1
      PRINTF("Error - zero length packet (0x%08x)\n", stream->ptr[0]);
d120 1
a120 1
      PRINTF("%08x:  ", stream->offset);
d122 1
a122 1
   PRINTF("%s (%d dwords):\n", name, len);
d136 1
a136 1
   PRINTF("%s (%d dwords):\n", name, len);
d138 1
a138 1
      PRINTF("\t0x%08x\n",  ptr[i]);
d143 1
a143 1
      PRINTF("\n... skipping backwards from 0x%x --> 0x%x ...\n\n", 
d146 1
a146 1
      PRINTF("\n... skipping from 0x%x --> 0x%x ...\n\n", 
d166 1
a166 1
   PRINTF("3DPRIM, %s variable length %d indicies (%d dwords):\n", prim, i, len);
d168 2
a169 2
      PRINTF("\t0x%08x\n",  ptr[i]);
   PRINTF("\n");
d179 3
a181 3
   PRINTF("\t\t ");				\
   PRINTF(__VA_ARGS__);			\
   PRINTF(": 0x%x\n", ((dw) & himask) >> (lo));	\
d195 3
a197 3
      PRINTF("\t\t ");				\
      PRINTF(__VA_ARGS__);			\
      PRINTF("\n");				\
d209 2
a210 2
   PRINTF("%s (%d dwords, flags: %x):\n", name, len, bits);
   PRINTF("\t0x%08x\n",  ptr[j++]);
d213 2
a214 2
      PRINTF("\t  LIS0: 0x%08x\n", ptr[j]);
      PRINTF("\t vb address: 0x%08x\n", (ptr[j] & ~0x3));
d219 1
a219 1
      PRINTF("\t  LIS1: 0x%08x\n", ptr[j]);
d227 1
a227 1
      PRINTF("\t  LIS2: 0x%08x\n", ptr[j]);
d236 1
a236 1
      PRINTF("\t  LIS3: 0x%08x\n", ptr[j]);
d240 1
a240 1
      PRINTF("\t  LIS4: 0x%08x\n", ptr[j]);
d262 1
a262 1
      PRINTF("\t  LIS5: 0x%08x\n", ptr[j]);
d280 1
a280 1
      PRINTF("\t  LIS6: 0x%08x\n", ptr[j]);
d297 1
a297 1
   PRINTF("\n");
d316 2
a317 2
   PRINTF("%s (%d dwords):\n", name, len);
   PRINTF("\t0x%08x\n",  ptr[j++]);
d323 2
a324 2
	    PRINTF("        STATIC: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    PRINTF("                0x%08x\n", ptr[j++]);
d327 1
a327 1
	    PRINTF("       DYNAMIC: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
d330 2
a331 2
	    PRINTF("       SAMPLER: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    PRINTF("                0x%08x\n", ptr[j++]);
d334 2
a335 2
	    PRINTF("           MAP: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    PRINTF("                0x%08x\n", ptr[j++]);
d338 2
a339 2
	    PRINTF("       PROGRAM: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    PRINTF("                0x%08x\n", ptr[j++]);
d342 2
a343 2
	    PRINTF("     CONSTANTS: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    PRINTF("                0x%08x\n", ptr[j++]);
d353 1
a353 1
      PRINTF("\t  DUMMY: 0x%08x\n", ptr[j++]);
d356 1
a356 1
   PRINTF("\n");
d369 1
a369 1
   PRINTF("\t0x%08x\n",  val);
d385 1
a385 1
   PRINTF("\t0x%08x\n",  val22);
d389 1
a389 1
   PRINTF("\t0x%08x\n",  val23);
d401 1
a401 1
   PRINTF("\t0x%08x -- dest address\n",  val);
d407 1
a407 1
   PRINTF("\t0x%08x\n",  val);
d415 1
a415 1
   PRINTF("\t0x%08x\n",  val);
d422 1
a422 1
   PRINTF("\t0x%08x -- src address\n",  val);
d428 1
a428 1
   PRINTF("\t0x%08x -- color\n",  val);
d438 2
a439 2
   PRINTF("%s (%d dwords):\n", name, len);
   PRINTF("\t0x%08x\n",  ptr[j++]);
d461 2
a462 2
   PRINTF("%s (%d dwords):\n", name, len);
   PRINTF("\t0x%08x\n",  ptr[j++]);
d482 2
a483 2
   PRINTF("%s (%d dwords):\n", name, len);
   PRINTF("\t0x%08x\n",  ptr[j]);
d503 2
a504 2
   PRINTF("%s (%d dwords):\n", name, len);
   PRINTF("\t0x%08x\n",  ptr[j++]);
d507 1
a507 1
      PRINTF("\t0x%08x\n",  ptr[j]);
d514 2
a515 2
	 PRINTF("\t  TMn.0: 0x%08x\n", ptr[j]);
	 PRINTF("\t map address: 0x%08x\n", (ptr[j] & ~0x3));
d522 1
a522 1
	 PRINTF("\t  TMn.1: 0x%08x\n", ptr[j]);
d533 1
a533 1
	 PRINTF("\t  TMn.2: 0x%08x\n", ptr[j]);
d555 2
a556 2
   PRINTF("%s (%d dwords):\n", name, len);
   PRINTF("\t0x%08x\n",  ptr[j++]);
d559 1
a559 1
      PRINTF("\t0x%08x\n",  ptr[j]);
d566 1
a566 1
	 PRINTF("\t  TSn.0: 0x%08x\n", ptr[j]);
d583 1
a583 1
	 PRINTF("\t  TSn.1: 0x%08x\n", ptr[j]);
d598 1
a598 1
	 PRINTF("\t  TSn.2: 0x%08x  (default color)\n", ptr[j]);
d615 2
a616 2
   PRINTF("%s (%d dwords):\n", name, len);
   PRINTF("\t0x%08x\n",  ptr[j++]);
d619 1
a619 1
      PRINTF("\t0x%08x\n",  ptr[j]);
d650 2
a651 2
   PRINTF("%s (%d dwords):\n", name, len);
   PRINTF("\t0x%08x\n",  ptr[j++]);
d654 1
a654 1
      PRINTF("\t0x%08x\n",  ptr[j]);
d666 1
a666 1
   PRINTF("\t0x%08x -- buffer base address\n",  ptr[j++]);
d807 1
d827 1
a827 1
   PRINTF("\n\nBATCH: (%d)\n", bytes / 4);
d844 1
a844 1
   PRINTF("END-BATCH\n\n\n");
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d28 1
a28 1
#include "imports.h"
@


1.1
log
@Initial revision
@
text
@d28 2
d32 28
a59 1
#include <stdio.h>
d62 57
a118 107
static const char *opcodes[0x20] = {
   "NOP",
   "ADD",
   "MOV",
   "MUL",
   "MAD",
   "DP2ADD",
   "DP3",
   "DP4",
   "FRC",
   "RCP",
   "RSQ",
   "EXP",
   "LOG",
   "CMP",
   "MIN",
   "MAX",
   "FLR",
   "MOD",
   "TRC",
   "SGE",
   "SLT",
   "TEXLD",
   "TEXLDP",
   "TEXLDB",
   "TEXKILL",
   "DCL",
   "0x1a",
   "0x1b",
   "0x1c",
   "0x1d",
   "0x1e",
   "0x1f",
};


static const int args[0x20] = {
   0,				/* 0 nop */
   2,				/* 1 add */
   1,				/* 2 mov */
   2,				/* 3 m ul */
   3, 				/* 4 mad */
   3,				/* 5 dp2add */
   2,				/* 6 dp3 */
   2,				/* 7 dp4 */
   1,				/* 8 frc */
   1,				/* 9 rcp */
   1,				/* a rsq */
   1,				/* b exp */
   1,				/* c log */
   3,				/* d cmp */
   2,				/* e min */
   2,				/* f max */
   1,				/* 10 flr */
   1,				/* 11 mod */
   1,				/* 12 trc */
   2,				/* 13 sge */
   2,				/* 14 slt */
   1,
   1,
   1,
   1,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
};


static const char *regname[0x8] = {
   "R",
   "T",
   "CONST",
   "S",
   "OC",
   "OD",
   "U",
   "UNKNOWN",
};

static void print_reg_type_nr( GLuint type, GLuint nr )
{
   switch (type) {
   case REG_TYPE_T:
      switch (nr) {
      case T_DIFFUSE: fprintf(stderr, "T_DIFFUSE"); return;
      case T_SPECULAR: fprintf(stderr, "T_SPECULAR"); return;
      case T_FOG_W: fprintf(stderr, "T_FOG_W"); return;
      default: fprintf(stderr, "T_TEX%d", nr); return;
      }
   case REG_TYPE_OC:
      if (nr == 0) {
	 fprintf(stderr, "oC");
	 return;
      }
      break;
   case REG_TYPE_OD:
      if (nr == 0) {
	 fprintf(stderr, "oD");
	 return;
      }
      break;
   default:
      break;
d121 8
a128 1
   fprintf(stderr, "%s[%d]", regname[type], nr);
a130 2
#define REG_SWIZZLE_MASK 0x7777
#define REG_NEGATE_MASK 0x8888
d132 22
a153 4
#define REG_SWIZZLE_XYZW ((SRC_X << A2_SRC2_CHANNEL_X_SHIFT) |	\
		      (SRC_Y << A2_SRC2_CHANNEL_Y_SHIFT) |	\
		      (SRC_Z << A2_SRC2_CHANNEL_Z_SHIFT) |	\
		      (SRC_W << A2_SRC2_CHANNEL_W_SHIFT))
d156 1
a156 1
static void print_reg_neg_swizzle( GLuint reg )
d158 14
a171 1
   int i;
d173 3
a175 3
   if ((reg & REG_SWIZZLE_MASK) == REG_SWIZZLE_XYZW &&
       (reg & REG_NEGATE_MASK) == 0)
      return;
a176 1
   fprintf(stderr, ".");
d178 56
a233 12
   for (i = 3 ; i >= 0; i--) {
      if (reg & (1<<((i*4)+3))) 
	 fprintf(stderr, "-");
	 
      switch ((reg>>(i*4)) & 0x7) {
      case 0: fprintf(stderr, "x"); break;
      case 1: fprintf(stderr, "y"); break;
      case 2: fprintf(stderr, "z"); break;
      case 3: fprintf(stderr, "w"); break;
      case 4: fprintf(stderr, "0"); break;
      case 5: fprintf(stderr, "1"); break;
      default: fprintf(stderr, "?"); break;
d235 121
d357 19
d379 2
a380 1
static void print_src_reg( GLuint dword )
d382 16
a397 4
   GLuint nr = (dword >> A2_SRC2_NR_SHIFT) & REG_NR_MASK;
   GLuint type = (dword >> A2_SRC2_TYPE_SHIFT) & REG_TYPE_MASK;
   print_reg_type_nr( type, nr );
   print_reg_neg_swizzle( dword );
d400 2
a401 1
void i915_print_ureg( const char *msg, GLuint ureg )
d403 1
a403 3
   fprintf(stderr, "%s: ", msg);
   print_src_reg( ureg >> 8 );
   fprintf(stderr, "\n");
d406 2
a407 1
static void print_dest_reg( GLuint dword )
d409 3
a411 10
   GLuint nr = (dword >> A0_DEST_NR_SHIFT) & REG_NR_MASK;
   GLuint type = (dword >> A0_DEST_TYPE_SHIFT) & REG_TYPE_MASK;
   print_reg_type_nr( type, nr );
   if ((dword & A0_DEST_CHANNEL_ALL) == A0_DEST_CHANNEL_ALL)
      return;
   fprintf(stderr, ".");
   if (dword & A0_DEST_CHANNEL_X) fprintf(stderr, "x");
   if (dword & A0_DEST_CHANNEL_Y) fprintf(stderr, "y");
   if (dword & A0_DEST_CHANNEL_Z) fprintf(stderr, "z");
   if (dword & A0_DEST_CHANNEL_W) fprintf(stderr, "w");
d414 6
d421 5
a425 3
#define GET_SRC0_REG(r0, r1) ((r0<<14)|(r1>>A1_SRC0_CHANNEL_W_SHIFT))
#define GET_SRC1_REG(r0, r1) ((r0<<8)|(r1>>A2_SRC1_CHANNEL_W_SHIFT))
#define GET_SRC2_REG(r)      (r)
d427 12
d440 19
a458 1
static void print_arith_op( GLuint opcode, const GLuint *program )
d460 83
a542 6
   if (opcode != A0_NOP) {
      print_dest_reg(program[0]);
      if (program[0] & A0_DEST_SATURATE)
	 fprintf(stderr, " = SATURATE ");
      else
	 fprintf(stderr, " = ");
d545 4
a548 1
   fprintf(stderr, "%s ", opcodes[opcode]);
d550 14
a563 4
   print_src_reg(GET_SRC0_REG(program[0], program[1]));
   if (args[opcode] == 1) {
      fprintf(stderr, "\n");
      return;
d566 37
a602 5
   fprintf(stderr, ", ");
   print_src_reg(GET_SRC1_REG(program[1], program[2]));
   if (args[opcode] == 2) { 
      fprintf(stderr, "\n");
      return;
d605 3
a607 4
   fprintf(stderr, ", ");
   print_src_reg(GET_SRC2_REG(program[2]));
   fprintf(stderr, "\n");
   return;
d610 34
d645 3
a647 1
static void print_tex_op( GLuint opcode, const GLuint *program )
d649 2
a650 2
   print_dest_reg(program[0] | A0_DEST_CHANNEL_ALL);
   fprintf(stderr, " = ");
d652 2
a653 1
   fprintf(stderr, "%s ", opcodes[opcode]);
d655 14
a668 2
   fprintf(stderr, "S[%d],", 
	   program[0] & T0_SAMPLER_NR_MASK);
d670 3
a672 3
   print_reg_type_nr( (program[1]>>T1_ADDRESS_REG_TYPE_SHIFT) & REG_TYPE_MASK,
		      (program[1]>>T1_ADDRESS_REG_NR_SHIFT) & REG_NR_MASK );
   fprintf(stderr, "\n");
d675 1
a675 1
static void print_dcl_op( GLuint opcode, const GLuint *program )
d677 139
a815 3
   fprintf(stderr, "%s ", opcodes[opcode]);
   print_dest_reg(program[0] | A0_DEST_CHANNEL_ALL);
   fprintf(stderr, "\n");
d819 4
a822 1
void i915_disassemble_program( const GLuint *program, GLuint sz )
d824 16
a839 4
   GLuint size = program[0] & 0x1ff;
   GLint i;
   
   fprintf(stderr, "BEGIN\n");
d841 2
a842 4
   if (size+2 != sz) {
      fprintf(stderr, "%s: program size mismatch %d/%d\n", __FUNCTION__,
	      size+2, sz);
      exit(1);
d845 2
a846 3
   program ++;
   for (i = 1 ; i < sz ; i+=3, program+=3) {
      GLuint opcode = program[0] & (0x1f<<24);
a847 9
      if ((GLint) opcode >= A0_NOP && opcode <= A0_SLT)
	 print_arith_op(opcode >> 24, program);
      else if (opcode >= T0_TEXLD && opcode <= T0_TEXKILL)
	 print_tex_op(opcode >> 24, program);
      else if (opcode == D0_DCL)
	 print_dcl_op(opcode >> 24, program);
      else 
	 fprintf(stderr, "Unknown opcode 0x%x\n", opcode);
   }
a848 2
   fprintf(stderr, "END\n\n");
}
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@a27 2
#include "main/imports.h"

d30 1
a30 1
#include "i915_debug.h"
a31 10
static GLboolean debug( struct debug_stream *stream, const char *name, GLuint len )
{
   GLuint i;
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   
   if (len == 0) {
      printf("Error - zero length packet (0x%08x)\n", stream->ptr[0]);
      assert(0);
      return GL_FALSE;
   }
d33 107
a139 72
   if (stream->print_addresses)
      printf("%08x:  ", stream->offset);


   printf("%s (%d dwords):\n", name, len);
   for (i = 0; i < len; i++)
      printf("\t0x%08x\n",  ptr[i]);   
   printf("\n");

   stream->offset += len * sizeof(GLuint);
   
   return GL_TRUE;
}


static const char *get_prim_name( GLuint val )
{
   switch (val & PRIM3D_MASK) {
   case PRIM3D_TRILIST: return "TRILIST"; break;
   case PRIM3D_TRISTRIP: return "TRISTRIP"; break;
   case PRIM3D_TRISTRIP_RVRSE: return "TRISTRIP_RVRSE"; break;
   case PRIM3D_TRIFAN: return "TRIFAN"; break;
   case PRIM3D_POLY: return "POLY"; break;
   case PRIM3D_LINELIST: return "LINELIST"; break;
   case PRIM3D_LINESTRIP: return "LINESTRIP"; break;
   case PRIM3D_RECTLIST: return "RECTLIST"; break;
   case PRIM3D_POINTLIST: return "POINTLIST"; break;
   case PRIM3D_DIB: return "DIB"; break;
   case PRIM3D_CLEAR_RECT: return "CLEAR_RECT"; break;
   case PRIM3D_ZONE_INIT: return "ZONE_INIT"; break;
   default: return "????"; break;
   }
}

static GLboolean debug_prim( struct debug_stream *stream, const char *name, 
			     GLboolean dump_floats,
			     GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   const char *prim = get_prim_name( ptr[0] );
   GLuint i;
   


   printf("%s %s (%d dwords):\n", name, prim, len);
   printf("\t0x%08x\n",  ptr[0]);   
   for (i = 1; i < len; i++) {
      if (dump_floats)
	 printf("\t0x%08x // %f\n",  ptr[i], *(GLfloat *)&ptr[i]);   
      else
	 printf("\t0x%08x\n",  ptr[i]);   
   }

      
   printf("\n");

   stream->offset += len * sizeof(GLuint);
   
   return GL_TRUE;
}
   



static GLboolean debug_program( struct debug_stream *stream, const char *name, GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);

   if (len == 0) {
      printf("Error - zero length packet (0x%08x)\n", stream->ptr[0]);
      assert(0);
      return GL_FALSE;
d142 1
a142 8
   if (stream->print_addresses)
      printf("%08x:  ", stream->offset);

   printf("%s (%d dwords):\n", name, len);
   i915_disassemble_program( ptr, len );

   stream->offset += len * sizeof(GLuint);
   return GL_TRUE;
d145 2
d148 4
a151 22
static GLboolean debug_chain( struct debug_stream *stream, const char *name, GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   GLuint old_offset = stream->offset + len * sizeof(GLuint);
   GLuint i;

   printf("%s (%d dwords):\n", name, len);
   for (i = 0; i < len; i++)
      printf("\t0x%08x\n",  ptr[i]);

   stream->offset = ptr[1] & ~0x3;
   
   if (stream->offset < old_offset)
      printf("\n... skipping backwards from 0x%x --> 0x%x ...\n\n", 
		   old_offset, stream->offset );
   else
      printf("\n... skipping from 0x%x --> 0x%x ...\n\n", 
		   old_offset, stream->offset );


   return GL_TRUE;
}
d154 1
a154 1
static GLboolean debug_variable_length_prim( struct debug_stream *stream )
d156 1
a156 18
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   const char *prim = get_prim_name( ptr[0] );
   GLuint i, len;

   GLushort *idx = (GLushort *)(ptr+1);
   for (i = 0; idx[i] != 0xffff; i++)
      ;

   len = 1+(i+2)/2;

   printf("3DPRIM, %s variable length %d indicies (%d dwords):\n", prim, i, len);
   for (i = 0; i < len; i++)
      printf("\t0x%08x\n",  ptr[i]);
   printf("\n");

   stream->offset += len * sizeof(GLuint);
   return GL_TRUE;
}
d158 3
d162 1
a162 35
#define BITS( dw, hi, lo, ... )				\
do {							\
   unsigned himask = 0xffffffffU >> (31 - (hi));		\
   printf("\t\t ");				\
   printf(__VA_ARGS__);			\
   printf(": 0x%x\n", ((dw) & himask) >> (lo));	\
} while (0)

#define MBZ( dw, hi, lo) do {							\
   unsigned x = (dw) >> (lo);				\
   unsigned lomask = (1 << (lo)) - 1;			\
   unsigned himask;					\
   himask = (1UL << (hi)) - 1;				\
   assert ((x & himask & ~lomask) == 0);	\
} while (0)

#define FLAG( dw, bit, ... )			\
do {							\
   if (((dw) >> (bit)) & 1) {				\
      printf("\t\t ");				\
      printf(__VA_ARGS__);			\
      printf("\n");				\
   }							\
} while (0)

static GLboolean debug_load_immediate( struct debug_stream *stream,
				       const char *name,
				       GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   GLuint bits = (ptr[0] >> 4) & 0xff;
   GLuint j = 0;
   
   printf("%s (%d dwords, flags: %x):\n", name, len, bits);
   printf("\t0x%08x\n",  ptr[j++]);
d164 12
a175 20
   if (bits & (1<<0)) {
      printf("\t  LIS0: 0x%08x\n", ptr[j]);
      printf("\t vb address: 0x%08x\n", (ptr[j] & ~0x3));
      BITS(ptr[j], 0, 0, "vb invalidate disable");
      j++;
   }
   if (bits & (1<<1)) {
      printf("\t  LIS1: 0x%08x\n", ptr[j]);
      BITS(ptr[j], 29, 24, "vb dword width");
      BITS(ptr[j], 21, 16, "vb dword pitch");
      BITS(ptr[j], 15, 0, "vb max index");
      j++;
   }
   if (bits & (1<<2)) {
      int i;
      printf("\t  LIS2: 0x%08x\n", ptr[j]);
      for (i = 0; i < 8; i++) {
	 unsigned tc = (ptr[j] >> (i * 4)) & 0xf;
	 if (tc != 0xf)
	    BITS(tc, 3, 0, "tex coord %d", i);
a176 121
      j++;
   }
   if (bits & (1<<3)) {
      printf("\t  LIS3: 0x%08x\n", ptr[j]);
      j++;
   }
   if (bits & (1<<4)) {
      printf("\t  LIS4: 0x%08x\n", ptr[j]);
      BITS(ptr[j], 31, 23, "point width");
      BITS(ptr[j], 22, 19, "line width");
      FLAG(ptr[j], 18, "alpha flatshade");
      FLAG(ptr[j], 17, "fog flatshade");
      FLAG(ptr[j], 16, "spec flatshade");
      FLAG(ptr[j], 15, "rgb flatshade");
      BITS(ptr[j], 14, 13, "cull mode");
      FLAG(ptr[j], 12, "vfmt: point width");
      FLAG(ptr[j], 11, "vfmt: specular/fog");
      FLAG(ptr[j], 10, "vfmt: rgba");
      FLAG(ptr[j], 9, "vfmt: depth offset");
      BITS(ptr[j], 8, 6, "vfmt: position (2==xyzw)");
      FLAG(ptr[j], 5, "force dflt diffuse");
      FLAG(ptr[j], 4, "force dflt specular");
      FLAG(ptr[j], 3, "local depth offset enable");
      FLAG(ptr[j], 2, "vfmt: fp32 fog coord");
      FLAG(ptr[j], 1, "sprite point");
      FLAG(ptr[j], 0, "antialiasing");
      j++;
   }
   if (bits & (1<<5)) {
      printf("\t  LIS5: 0x%08x\n", ptr[j]);
      BITS(ptr[j], 31, 28, "rgba write disables");
      FLAG(ptr[j], 27,     "force dflt point width");
      FLAG(ptr[j], 26,     "last pixel enable");
      FLAG(ptr[j], 25,     "global z offset enable");
      FLAG(ptr[j], 24,     "fog enable");
      BITS(ptr[j], 23, 16, "stencil ref");
      BITS(ptr[j], 15, 13, "stencil test");
      BITS(ptr[j], 12, 10, "stencil fail op");
      BITS(ptr[j], 9, 7,   "stencil pass z fail op");
      BITS(ptr[j], 6, 4,   "stencil pass z pass op");
      FLAG(ptr[j], 3,      "stencil write enable");
      FLAG(ptr[j], 2,      "stencil test enable");
      FLAG(ptr[j], 1,      "color dither enable");
      FLAG(ptr[j], 0,      "logiop enable");
      j++;
   }
   if (bits & (1<<6)) {
      printf("\t  LIS6: 0x%08x\n", ptr[j]);
      FLAG(ptr[j], 31,      "alpha test enable");
      BITS(ptr[j], 30, 28,  "alpha func");
      BITS(ptr[j], 27, 20,  "alpha ref");
      FLAG(ptr[j], 19,      "depth test enable");
      BITS(ptr[j], 18, 16,  "depth func");
      FLAG(ptr[j], 15,      "blend enable");
      BITS(ptr[j], 14, 12,  "blend func");
      BITS(ptr[j], 11, 8,   "blend src factor");
      BITS(ptr[j], 7,  4,   "blend dst factor");
      FLAG(ptr[j], 3,       "depth write enable");
      FLAG(ptr[j], 2,       "color write enable");
      BITS(ptr[j], 1,  0,   "provoking vertex"); 
      j++;
   }


   printf("\n");

   assert(j == len);

   stream->offset += len * sizeof(GLuint);
   
   return GL_TRUE;
}
 


static GLboolean debug_load_indirect( struct debug_stream *stream,
				      const char *name,
				      GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   GLuint bits = (ptr[0] >> 8) & 0x3f;
   GLuint i, j = 0;
   
   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j++]);

   for (i = 0; i < 6; i++) {
      if (bits & (1<<i)) {
	 switch (1<<(8+i)) {
	 case LI0_STATE_STATIC_INDIRECT:
	    printf("        STATIC: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    printf("                0x%08x\n", ptr[j++]);
	    break;
	 case LI0_STATE_DYNAMIC_INDIRECT:
	    printf("       DYNAMIC: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    break;
	 case LI0_STATE_SAMPLER:
	    printf("       SAMPLER: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    printf("                0x%08x\n", ptr[j++]);
	    break;
	 case LI0_STATE_MAP:
	    printf("           MAP: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    printf("                0x%08x\n", ptr[j++]);
	    break;
	 case LI0_STATE_PROGRAM:
	    printf("       PROGRAM: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    printf("                0x%08x\n", ptr[j++]);
	    break;
	 case LI0_STATE_CONSTANTS:
	    printf("     CONSTANTS: 0x%08x | %x\n", ptr[j]&~3, ptr[j]&3); j++;
	    printf("                0x%08x\n", ptr[j++]);
	    break;
	 default:
	    assert(0);
	    break;
	 }
      }
   }

   if (bits == 0) {
      printf("\t  DUMMY: 0x%08x\n", ptr[j++]);
a177 19

   printf("\n");


   assert(j == len);

   stream->offset += len * sizeof(GLuint);
   
   return GL_TRUE;
}
 	
static void BR13( struct debug_stream *stream,
		  GLuint val )
{
   printf("\t0x%08x\n",  val);
   FLAG(val, 30, "clipping enable");
   BITS(val, 25, 24, "color depth (3==32bpp)");
   BITS(val, 23, 16, "raster op");
   BITS(val, 15, 0,  "dest pitch");
d181 1
a181 2
static void BR2223( struct debug_stream *stream,
		    GLuint val22, GLuint val23 )
d183 4
a186 16
   union { GLuint val; short field[2]; } BR22, BR23;

   BR22.val = val22;
   BR23.val = val23;

   printf("\t0x%08x\n",  val22);
   BITS(val22, 31, 16, "dest y1");
   BITS(val22, 15, 0,  "dest x1");

   printf("\t0x%08x\n",  val23);
   BITS(val23, 31, 16, "dest y2");
   BITS(val23, 15, 0,  "dest x2");

   /* The blit engine may produce unexpected results when these aren't met */
   assert(BR22.field[0] < BR23.field[0]);
   assert(BR22.field[1] < BR23.field[1]);
d189 1
a189 2
static void BR09( struct debug_stream *stream,
		  GLuint val )
d191 3
a193 1
   printf("\t0x%08x -- dest address\n",  val);
d196 1
a196 2
static void BR26( struct debug_stream *stream,
		  GLuint val )
d198 10
a207 3
   printf("\t0x%08x\n",  val);
   BITS(val, 31, 16, "src y1");
   BITS(val, 15, 0,  "src x1");
a209 6
static void BR11( struct debug_stream *stream,
		  GLuint val )
{
   printf("\t0x%08x\n",  val);
   BITS(val, 15, 0,  "src pitch");
}
d211 3
a213 5
static void BR12( struct debug_stream *stream,
		  GLuint val )
{
   printf("\t0x%08x -- src address\n",  val);
}
a214 12
static void BR16( struct debug_stream *stream,
		  GLuint val )
{
   printf("\t0x%08x -- color\n",  val);
}
   
static GLboolean debug_copy_blit( struct debug_stream *stream,
				  const char *name,
				  GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   int j = 0;
d216 1
a216 19
   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j++]);
   
   BR13(stream, ptr[j++]);
   BR2223(stream, ptr[j], ptr[j+1]);
   j += 2;
   BR09(stream, ptr[j++]);
   BR26(stream, ptr[j++]);
   BR11(stream, ptr[j++]);
   BR12(stream, ptr[j++]);

   stream->offset += len * sizeof(GLuint);
   assert(j == len);
   return GL_TRUE;
}

static GLboolean debug_color_blit( struct debug_stream *stream,
				  const char *name,
				  GLuint len )
d218 7
a224 2
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   int j = 0;
d226 1
a226 2
   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j++]);
d228 4
a231 46
   BR13(stream, ptr[j++]);
   BR2223(stream, ptr[j], ptr[j+1]);
   j += 2;
   BR09(stream, ptr[j++]);
   BR16(stream, ptr[j++]);

   stream->offset += len * sizeof(GLuint);
   assert(j == len);
   return GL_TRUE;
}

static GLboolean debug_modes4( struct debug_stream *stream,
				  const char *name,
				  GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   int j = 0;

   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j]);
   BITS(ptr[j], 21, 18, "logicop func");
   FLAG(ptr[j], 17, "stencil test mask modify-enable");
   FLAG(ptr[j], 16, "stencil write mask modify-enable");
   BITS(ptr[j], 15, 8, "stencil test mask");
   BITS(ptr[j], 7, 0,  "stencil write mask");
   j++;

   stream->offset += len * sizeof(GLuint);
   assert(j == len);
   return GL_TRUE;
}

static GLboolean debug_map_state( struct debug_stream *stream,
				  const char *name,
				  GLuint len )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   int j = 0;

   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j++]);
   
   {
      printf("\t0x%08x\n",  ptr[j]);
      BITS(ptr[j], 15, 0,   "map mask");
      j++;
d234 5
a238 29
   while (j < len) {
      {
	 printf("\t  TMn.0: 0x%08x\n", ptr[j]);
	 printf("\t map address: 0x%08x\n", (ptr[j] & ~0x3));
	 FLAG(ptr[j], 1, "vertical line stride");
	 FLAG(ptr[j], 0, "vertical line stride offset");
	 j++;
      }

      {
	 printf("\t  TMn.1: 0x%08x\n", ptr[j]);
	 BITS(ptr[j], 31, 21, "height");
	 BITS(ptr[j], 20, 10, "width");
	 BITS(ptr[j], 9, 7, "surface format");
	 BITS(ptr[j], 6, 3, "texel format");
	 FLAG(ptr[j], 2, "use fence regs");
	 FLAG(ptr[j], 1, "tiled surface");
	 FLAG(ptr[j], 0, "tile walk ymajor");
	 j++;
      }
      {
	 printf("\t  TMn.2: 0x%08x\n", ptr[j]);
	 BITS(ptr[j], 31, 21, "dword pitch");
	 BITS(ptr[j], 20, 15, "cube face enables");
	 BITS(ptr[j], 14, 9, "max lod");
	 FLAG(ptr[j], 8,     "mip layout right");
	 BITS(ptr[j], 7, 0, "depth");
	 j++;
      }
d241 4
a244 3
   stream->offset += len * sizeof(GLuint);
   assert(j == len);
   return GL_TRUE;
d247 2
a248 3
static GLboolean debug_sampler_state( struct debug_stream *stream,
				  const char *name,
				  GLuint len )
d250 2
a251 2
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   int j = 0;
d253 1
a253 8
   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j++]);
   
   {
      printf("\t0x%08x\n",  ptr[j]);
      BITS(ptr[j], 15, 0,   "sampler mask");
      j++;
   }
d255 2
a256 17
   while (j < len) {
      {
	 printf("\t  TSn.0: 0x%08x\n", ptr[j]);
	 FLAG(ptr[j], 31, "reverse gamma");
	 FLAG(ptr[j], 30, "planar to packed");
	 FLAG(ptr[j], 29, "yuv->rgb");
	 BITS(ptr[j], 28, 27, "chromakey index");
	 BITS(ptr[j], 26, 22, "base mip level");
	 BITS(ptr[j], 21, 20, "mip mode filter");
	 BITS(ptr[j], 19, 17, "mag mode filter");
	 BITS(ptr[j], 16, 14, "min mode filter");
	 BITS(ptr[j], 13, 5,  "lod bias (s4.4)");
	 FLAG(ptr[j], 4,      "shadow enable");
	 FLAG(ptr[j], 3,      "max-aniso-4");
	 BITS(ptr[j], 2, 0,   "shadow func");
	 j++;
      }
d258 3
a260 24
      {
	 printf("\t  TSn.1: 0x%08x\n", ptr[j]);
	 BITS(ptr[j], 31, 24, "min lod");
	 MBZ( ptr[j], 23, 18 );
	 FLAG(ptr[j], 17,     "kill pixel enable");
	 FLAG(ptr[j], 16,     "keyed tex filter mode");
	 FLAG(ptr[j], 15,     "chromakey enable");
	 BITS(ptr[j], 14, 12, "tcx wrap mode");
	 BITS(ptr[j], 11, 9,  "tcy wrap mode");
	 BITS(ptr[j], 8,  6,  "tcz wrap mode");
	 FLAG(ptr[j], 5,      "normalized coords");
	 BITS(ptr[j], 4,  1,  "map (surface) index");
	 FLAG(ptr[j], 0,      "EAST deinterlacer enable");
	 j++;
      }
      {
	 printf("\t  TSn.2: 0x%08x  (default color)\n", ptr[j]);
	 j++;
      }
   }

   stream->offset += len * sizeof(GLuint);
   assert(j == len);
   return GL_TRUE;
d263 1
a263 3
static GLboolean debug_dest_vars( struct debug_stream *stream,
				  const char *name,
				  GLuint len )
d265 4
a268 2
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   int j = 0;
a269 2
   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j++]);
d271 1
a271 28
   {
      printf("\t0x%08x\n",  ptr[j]);
      FLAG(ptr[j], 31,     "early classic ztest");
      FLAG(ptr[j], 30,     "opengl tex default color");
      FLAG(ptr[j], 29,     "bypass iz");
      FLAG(ptr[j], 28,     "lod preclamp");
      BITS(ptr[j], 27, 26, "dither pattern");
      FLAG(ptr[j], 25,     "linear gamma blend");
      FLAG(ptr[j], 24,     "debug dither");
      BITS(ptr[j], 23, 20, "dstorg x");
      BITS(ptr[j], 19, 16, "dstorg y");
      MBZ (ptr[j], 15, 15 );
      BITS(ptr[j], 14, 12, "422 write select");
      BITS(ptr[j], 11, 8,  "cbuf format");
      BITS(ptr[j], 3, 2,   "zbuf format");
      FLAG(ptr[j], 1,      "vert line stride");
      FLAG(ptr[j], 1,      "vert line stride offset");
      j++;
   }
   
   stream->offset += len * sizeof(GLuint);
   assert(j == len);
   return GL_TRUE;
}

static GLboolean debug_buf_info( struct debug_stream *stream,
				  const char *name,
				  GLuint len )
d273 2
a274 18
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   int j = 0;

   printf("%s (%d dwords):\n", name, len);
   printf("\t0x%08x\n",  ptr[j++]);

   {
      printf("\t0x%08x\n",  ptr[j]);
      BITS(ptr[j], 28, 28, "aux buffer id");
      BITS(ptr[j], 27, 24, "buffer id (7=depth, 3=back)");
      FLAG(ptr[j], 23,     "use fence regs");
      FLAG(ptr[j], 22,     "tiled surface");
      FLAG(ptr[j], 21,     "tile walk ymajor");
      MBZ (ptr[j], 20, 14);
      BITS(ptr[j], 13, 2,  "dword pitch");
      MBZ (ptr[j], 2,  0);
      j++;
   }
d276 1
a276 6
   printf("\t0x%08x -- buffer base address\n",  ptr[j++]);

   stream->offset += len * sizeof(GLuint);
   assert(j == len);
   return GL_TRUE;
}
d278 4
a281 138
static GLboolean i915_debug_packet( struct debug_stream *stream )
{
   GLuint *ptr = (GLuint *)(stream->ptr + stream->offset);
   GLuint cmd = *ptr;
   
   switch (((cmd >> 29) & 0x7)) {
   case 0x0:
      switch ((cmd >> 23) & 0x3f) {
      case 0x0:
	 return debug(stream, "MI_NOOP", 1);
      case 0x3:
	 return debug(stream, "MI_WAIT_FOR_EVENT", 1);
      case 0x4:
	 return debug(stream, "MI_FLUSH", 1);
      case 0xA:
	 debug(stream, "MI_BATCH_BUFFER_END", 1);
	 return GL_FALSE;
      case 0x22:
	 return debug(stream, "MI_LOAD_REGISTER_IMM", 3);
      case 0x31:
	 return debug_chain(stream, "MI_BATCH_BUFFER_START", 2);
      default:
	 break;
      }
      break;
   case 0x1:
      break;
   case 0x2:
      switch ((cmd >> 22) & 0xff) {	 
      case 0x50:
	 return debug_color_blit(stream, "XY_COLOR_BLT", (cmd & 0xff) + 2);
      case 0x53:
	 return debug_copy_blit(stream, "XY_SRC_COPY_BLT", (cmd & 0xff) + 2);
      default:
	 return debug(stream, "blit command", (cmd & 0xff) + 2);
      }
      break;
   case 0x3:
      switch ((cmd >> 24) & 0x1f) {	 
      case 0x6:
	 return debug(stream, "3DSTATE_ANTI_ALIASING", 1);
      case 0x7:
	 return debug(stream, "3DSTATE_RASTERIZATION_RULES", 1);
      case 0x8:
	 return debug(stream, "3DSTATE_BACKFACE_STENCIL_OPS", 2);
      case 0x9:
	 return debug(stream, "3DSTATE_BACKFACE_STENCIL_MASKS", 1);
      case 0xb:
	 return debug(stream, "3DSTATE_INDEPENDENT_ALPHA_BLEND", 1);
      case 0xc:
	 return debug(stream, "3DSTATE_MODES5", 1);	 
      case 0xd:
	 return debug_modes4(stream, "3DSTATE_MODES4", 1);
      case 0x15:
	 return debug(stream, "3DSTATE_FOG_COLOR", 1);
      case 0x16:
	 return debug(stream, "3DSTATE_COORD_SET_BINDINGS", 1);
      case 0x1c:
	 /* 3DState16NP */
	 switch((cmd >> 19) & 0x1f) {
	 case 0x10:
	    return debug(stream, "3DSTATE_SCISSOR_ENABLE", 1);
	 case 0x11:
	    return debug(stream, "3DSTATE_DEPTH_SUBRECTANGLE_DISABLE", 1);
	 default:
	    break;
	 }
	 break;
      case 0x1d:
	 /* 3DStateMW */
	 switch ((cmd >> 16) & 0xff) {
	 case 0x0:
	    return debug_map_state(stream, "3DSTATE_MAP_STATE", (cmd & 0x1f) + 2);
	 case 0x1:
	    return debug_sampler_state(stream, "3DSTATE_SAMPLER_STATE", (cmd & 0x1f) + 2);
	 case 0x4:
	    return debug_load_immediate(stream, "3DSTATE_LOAD_STATE_IMMEDIATE", (cmd & 0xf) + 2);
	 case 0x5:
	    return debug_program(stream, "3DSTATE_PIXEL_SHADER_PROGRAM", (cmd & 0x1ff) + 2);
	 case 0x6:
	    return debug(stream, "3DSTATE_PIXEL_SHADER_CONSTANTS", (cmd & 0xff) + 2);
	 case 0x7:
	    return debug_load_indirect(stream, "3DSTATE_LOAD_INDIRECT", (cmd & 0xff) + 2);
	 case 0x80:
	    return debug(stream, "3DSTATE_DRAWING_RECTANGLE", (cmd & 0xffff) + 2);
	 case 0x81:
	    return debug(stream, "3DSTATE_SCISSOR_RECTANGLE", (cmd & 0xffff) + 2);
	 case 0x83:
	    return debug(stream, "3DSTATE_SPAN_STIPPLE", (cmd & 0xffff) + 2);
	 case 0x85:
	    return debug_dest_vars(stream, "3DSTATE_DEST_BUFFER_VARS", (cmd & 0xffff) + 2);
	 case 0x88:
	    return debug(stream, "3DSTATE_CONSTANT_BLEND_COLOR", (cmd & 0xffff) + 2);
	 case 0x89:
	    return debug(stream, "3DSTATE_FOG_MODE", (cmd & 0xffff) + 2);
	 case 0x8e:
	    return debug_buf_info(stream, "3DSTATE_BUFFER_INFO", (cmd & 0xffff) + 2);
	 case 0x97:
	    return debug(stream, "3DSTATE_DEPTH_OFFSET_SCALE", (cmd & 0xffff) + 2);
	 case 0x98:
	    return debug(stream, "3DSTATE_DEFAULT_Z", (cmd & 0xffff) + 2);
	 case 0x99:
	    return debug(stream, "3DSTATE_DEFAULT_DIFFUSE", (cmd & 0xffff) + 2);
	 case 0x9a:
	    return debug(stream, "3DSTATE_DEFAULT_SPECULAR", (cmd & 0xffff) + 2);
	 case 0x9c:
	    return debug(stream, "3DSTATE_CLEAR_PARAMETERS", (cmd & 0xffff) + 2);
	 default:
	    assert(0);
	    return 0;
	 }
	 break;
      case 0x1e:
	 if (cmd & (1 << 23))
	    return debug(stream, "???", (cmd & 0xffff) + 1);
	 else
	    return debug(stream, "", 1);
	 break;
      case 0x1f:
	 if ((cmd & (1 << 23)) == 0)	
	    return debug_prim(stream, "3DPRIM (inline)", 1, (cmd & 0x1ffff) + 2);
	 else if (cmd & (1 << 17)) 
	 {
	    if ((cmd & 0xffff) == 0)
	       return debug_variable_length_prim(stream);
	    else
	       return debug_prim(stream, "3DPRIM (indexed)", 0, (((cmd & 0xffff) + 1) / 2) + 1);
	 }
	 else
	    return debug_prim(stream, "3DPRIM  (indirect sequential)", 0, 2); 
	 break;
      default:
	 return debug(stream, "", 0);
      }
      break;
   default:
      assert(0);
      return 0;
d284 3
a286 5
   assert(0);
   return 0;
}


d288 8
a295 23
void
i915_dump_batchbuffer( GLuint *start,
		       GLuint *end )
{
   struct debug_stream stream;
   GLuint bytes = (end - start) * 4;
   GLboolean done = GL_FALSE;

   printf("\n\nBATCH: (%d)\n", bytes / 4);

   stream.offset = 0;
   stream.ptr = (char *)start;
   stream.print_addresses = 0;

   while (!done &&
	  stream.offset < bytes &&
	  stream.offset >= 0)
   {
      if (!i915_debug_packet( &stream ))
	 break;

      assert(stream.offset <= bytes &&
	     stream.offset >= 0);
d298 1
a298 1
   printf("END-BATCH\n\n\n");
a299 2


@

