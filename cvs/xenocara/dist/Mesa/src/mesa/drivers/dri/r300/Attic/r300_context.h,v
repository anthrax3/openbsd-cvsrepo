head	1.7;
access;
symbols
	OPENBSD_5_4:1.6.0.8
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.6
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.09.05.14.05.01;	author jsg;	state dead;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.23;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.17;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.53.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.53.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.27;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.29.22;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.40;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@/*
Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.

The Weather Channel (TM) funded Tungsten Graphics to develop the
initial release of the Radeon 8500 driver under the XFree86 license.
This notice must be preserved.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial
portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/**
 * \file
 *
 * \author Keith Whitwell <keith@@tungstengraphics.com>
 * \author Nicolai Haehnle <prefect_@@gmx.net>
 */

#ifndef __R300_CONTEXT_H__
#define __R300_CONTEXT_H__

#include "drm.h"
#include "radeon_drm.h"
#include "dri_util.h"
#include "radeon_common.h"

#include "main/mtypes.h"
#include "program/prog_instruction.h"
#include "compiler/radeon_code.h"

struct r300_context;
typedef struct r300_context r300ContextRec;
typedef struct r300_context *r300ContextPtr;


#include "r300_vertprog.h"


/* The blit width for texture uploads
 */
#define R300_BLIT_WIDTH_BYTES 1024
#define R300_MAX_TEXTURE_UNITS 8



#define R300_VPT_CMD_0		0
#define R300_VPT_XSCALE		1
#define R300_VPT_XOFFSET	2
#define R300_VPT_YSCALE		3
#define R300_VPT_YOFFSET	4
#define R300_VPT_ZSCALE		5
#define R300_VPT_ZOFFSET	6
#define R300_VPT_CMDSIZE	7

#define R300_VIR_CMD_0		0	/* vir is variable size (at least 1) */
#define R300_VIR_CNTL_0		1
#define R300_VIR_CNTL_1		2
#define R300_VIR_CNTL_2		3
#define R300_VIR_CNTL_3		4
#define R300_VIR_CNTL_4		5
#define R300_VIR_CNTL_5		6
#define R300_VIR_CNTL_6		7
#define R300_VIR_CNTL_7		8
#define R300_VIR_CMDSIZE	9

#define R300_VIC_CMD_0		0
#define R300_VIC_CNTL_0		1
#define R300_VIC_CNTL_1		2
#define R300_VIC_CMDSIZE	3

#define R300_VOF_CMD_0		0
#define R300_VOF_CNTL_0		1
#define R300_VOF_CNTL_1		2
#define R300_VOF_CMDSIZE	3

#define R300_PVS_CMD_0		0
#define R300_PVS_CNTL_1		1
#define R300_PVS_CNTL_2		2
#define R300_PVS_CNTL_3		3
#define R300_PVS_CMDSIZE	4

#define R300_GB_MISC_CMD_0		0
#define R300_GB_MISC_MSPOS_0		1
#define R300_GB_MISC_MSPOS_1		2
#define R300_GB_MISC_TILE_CONFIG	3
#define R300_GB_MISC_CMDSIZE		4
#define R300_GB_MISC2_CMD_0		    0
#define R300_GB_MISC2_SELECT		1
#define R300_GB_MISC2_AA_CONFIG		2
#define R300_GB_MISC2_CMDSIZE		3

#define R300_TXE_CMD_0		0
#define R300_TXE_ENABLE		1
#define R300_TXE_CMDSIZE	2

#define R300_PS_CMD_0		0
#define R300_PS_POINTSIZE	1
#define R300_PS_CMDSIZE		2

#define R300_ZBS_CMD_0		0
#define R300_ZBS_T_FACTOR	1
#define R300_ZBS_T_CONSTANT	2
#define R300_ZBS_W_FACTOR	3
#define R300_ZBS_W_CONSTANT	4
#define R300_ZBS_CMDSIZE	5

#define R300_CUL_CMD_0		0
#define R300_CUL_CULL		1
#define R300_CUL_CMDSIZE	2

#define R300_RC_CMD_0		0
#define R300_RC_CNTL_0		1
#define R300_RC_CNTL_1		2
#define R300_RC_CMDSIZE		3

#define R300_RI_CMD_0		0
#define R300_RI_INTERP_0	1
#define R300_RI_INTERP_1	2
#define R300_RI_INTERP_2	3
#define R300_RI_INTERP_3	4
#define R300_RI_INTERP_4	5
#define R300_RI_INTERP_5	6
#define R300_RI_INTERP_6	7
#define R300_RI_INTERP_7	8
#define R300_RI_CMDSIZE		9

#define R500_RI_CMDSIZE	       17

#define R300_RR_CMD_0		0	/* rr is variable size (at least 1) */
#define R300_RR_INST_0		1
#define R300_RR_INST_1		2
#define R300_RR_INST_2		3
#define R300_RR_INST_3		4
#define R300_RR_INST_4		5
#define R300_RR_INST_5		6
#define R300_RR_INST_6		7
#define R300_RR_INST_7		8
#define R300_RR_CMDSIZE		9

#define R300_FP_CMD_0		0
#define R300_FP_CNTL0		1
#define R300_FP_CNTL1		2
#define R300_FP_CNTL2		3
#define R300_FP_CMD_1		4
#define R300_FP_NODE0		5
#define R300_FP_NODE1		6
#define R300_FP_NODE2		7
#define R300_FP_NODE3		8
#define R300_FP_CMDSIZE		9

#define R500_FP_CMD_0           0
#define R500_FP_CNTL            1
#define R500_FP_PIXSIZE         2
#define R500_FP_CMD_1           3
#define R500_FP_CODE_ADDR       4
#define R500_FP_CODE_RANGE      5
#define R500_FP_CODE_OFFSET     6
#define R500_FP_CMD_2           7
#define R500_FP_FC_CNTL         8
#define R500_FP_CMDSIZE         9

#define R300_FPT_CMD_0		0
#define R300_FPT_INSTR_0	1
#define R300_FPT_CMDSIZE	65

#define R300_FPI_CMD_0		0
#define R300_FPI_INSTR_0	1
#define R300_FPI_CMDSIZE	65
/* R500 has space for 512 instructions - 6 dwords per instruction */
#define R500_FPI_CMDSIZE	(512*6+1)

#define R300_FPP_CMD_0		0
#define R300_FPP_PARAM_0	1
#define R300_FPP_CMDSIZE	(32*4+1)
/* R500 has spcae for 256 constants - 4 dwords per constant */
#define R500_FPP_CMDSIZE	(256*4+1)

#define R300_FOGS_CMD_0		0
#define R300_FOGS_STATE		1
#define R300_FOGS_CMDSIZE	2

#define R300_FOGC_CMD_0		0
#define R300_FOGC_R		1
#define R300_FOGC_G		2
#define R300_FOGC_B		3
#define R300_FOGC_CMDSIZE	4

#define R300_FOGP_CMD_0		0
#define R300_FOGP_SCALE		1
#define R300_FOGP_START		2
#define R300_FOGP_CMDSIZE	3

#define R300_AT_CMD_0		0
#define R300_AT_ALPHA_TEST	1
#define R300_AT_UNKNOWN		2
#define R300_AT_CMDSIZE		3

#define R300_BLD_CMD_0		0
#define R300_BLD_CBLEND		1
#define R300_BLD_ABLEND		2
#define R300_BLD_CMDSIZE	3

#define R300_CMK_CMD_0		0
#define R300_CMK_COLORMASK	1
#define R300_CMK_CMDSIZE	2

#define R300_CB_CMD_0		0
#define R300_CB_OFFSET		1
#define R300_CB_CMD_1		2
#define R300_CB_PITCH		3
#define R300_CB_CMDSIZE		4

#define R300_ZS_CMD_0		0
#define R300_ZS_CNTL_0		1
#define R300_ZS_CNTL_1		2
#define R300_ZS_CNTL_2		3
#define R300_ZS_CMDSIZE		4

#define R300_ZSB_CMD_0		0
#define R300_ZSB_CNTL_0		1
#define R300_ZSB_CMDSIZE	2

#define R300_ZB_CMD_0		0
#define R300_ZB_OFFSET		1
#define R300_ZB_PITCH		2
#define R300_ZB_CMDSIZE		3

#define R300_VAP_CNTL_FLUSH     0
#define R300_VAP_CNTL_FLUSH_1   1
#define R300_VAP_CNTL_CMD       2
#define R300_VAP_CNTL_INSTR     3
#define R300_VAP_CNTL_SIZE      4

#define R300_VPI_CMD_0		0
#define R300_VPI_INSTR_0	1
#define R300_VPI_CMDSIZE	1025	/* 256 16 byte instructions */

#define R300_VPP_CMD_0		0
#define R300_VPP_PARAM_0	1
#define R300_VPP_CMDSIZE	1025	/* 256 4-component parameters */

#define R300_VPUCP_CMD_0		0
#define R300_VPUCP_X            1
#define R300_VPUCP_Y            2
#define R300_VPUCP_Z            3
#define R300_VPUCP_W            4
#define R300_VPUCP_CMDSIZE	5	/* 256 4-component parameters */

#define R300_VPS_CMD_0		0
#define R300_VPS_ZERO_0		1
#define R300_VPS_ZERO_1		2
#define R300_VPS_POINTSIZE	3
#define R300_VPS_ZERO_3		4
#define R300_VPS_CMDSIZE	5

	/* the layout is common for all fields inside tex */
#define R300_TEX_CMD_0		0
#define R300_TEX_VALUE_0	1
/* We don't really use this, instead specify mtu+1 dynamically
#define R300_TEX_CMDSIZE	(MAX_TEXTURE_UNITS+1)
*/

#define R300_QUERYOBJ_CMD_0  0
#define R300_QUERYOBJ_DATA_0 1
#define R300_QUERYOBJ_CMD_1  2
#define R300_QUERYOBJ_DATA_1  3
#define R300_QUERYOBJ_CMDSIZE  4

/**
 * Cache for hardware register state.
 */
struct r300_hw_state {
	struct radeon_state_atom vpt;	/* viewport (1D98) */
	struct radeon_state_atom vap_cntl;
	struct radeon_state_atom vap_index_offset; /* 0x208c r5xx only */
	struct radeon_state_atom vof;	/* VAP output format register 0x2090 */
	struct radeon_state_atom vte;	/* (20B0) */
	struct radeon_state_atom vap_vf_max_vtx_indx;	/* Maximum Vertex Indx Clamp (2134) */
	struct radeon_state_atom vap_cntl_status;
	struct radeon_state_atom vir[2];	/* vap input route (2150/21E0) */
	struct radeon_state_atom vic;	/* vap input control (2180) */
	struct radeon_state_atom vap_psc_sgn_norm_cntl; /* Programmable Stream Control Signed Normalize Control (21DC) */
	struct radeon_state_atom vap_clip_cntl;
	struct radeon_state_atom vap_clip;
	struct radeon_state_atom vap_pvs_vtx_timeout_reg;	/* Vertex timeout register (2288) */
	struct radeon_state_atom pvs;	/* pvs_cntl (22D0) */
	struct radeon_state_atom gb_enable;	/* (4008) */
	struct radeon_state_atom gb_misc;	/* Multisampling position shifts ? (4010) */
	struct radeon_state_atom gb_misc2;	/* Multisampling position shifts ? (4010) */
	struct radeon_state_atom ga_point_s0;	/* S Texture Coordinate of Vertex 0 for Point texture stuffing (LLC) (4200) */
	struct radeon_state_atom ga_triangle_stipple;	/* (4214) */
	struct radeon_state_atom ps;	/* pointsize (421C) */
	struct radeon_state_atom ga_point_minmax;	/* (4230) */
	struct radeon_state_atom lcntl;	/* line control */
	struct radeon_state_atom ga_line_stipple;	/* (4260) */
	struct radeon_state_atom shade;
	struct radeon_state_atom shade2;
	struct radeon_state_atom polygon_mode;
	struct radeon_state_atom fogp;	/* fog parameters (4294) */
	struct radeon_state_atom ga_soft_reset;	/* (429C) */
	struct radeon_state_atom zbias_cntl;
	struct radeon_state_atom zbs;	/* zbias (42A4) */
	struct radeon_state_atom occlusion_cntl;
	struct radeon_state_atom cul;	/* cull cntl (42B8) */
	struct radeon_state_atom su_depth_scale;	/* (42C0) */
	struct radeon_state_atom rc;	/* rs control (4300) */
	struct radeon_state_atom ri;	/* rs interpolators (4310) */
	struct radeon_state_atom rr;	/* rs route (4330) */
	struct radeon_state_atom sc_hyperz;	/* (43A4) */
	struct radeon_state_atom sc_screendoor;	/* (43E8) */
	struct radeon_state_atom fp;	/* fragment program cntl + nodes (4600) */
	struct radeon_state_atom fpt;	/* texi - (4620) */
	struct radeon_state_atom us_out_fmt;	/* (46A4) */
	struct radeon_state_atom r500fp;	/* r500 fp instructions */
	struct radeon_state_atom r500fp_const;	/* r500 fp constants */
	struct radeon_state_atom fpi[4];	/* fp instructions (46C0/47C0/48C0/49C0) */
	struct radeon_state_atom fogs;	/* fog state (4BC0) */
	struct radeon_state_atom fogc;	/* fog color (4BC8) */
	struct radeon_state_atom at;	/* alpha test (4BD4) */
	struct radeon_state_atom fg_depth_src;	/* (4BD8) */
	struct radeon_state_atom fpp;	/* 0x4C00 and following */
	struct radeon_state_atom rb3d_cctl;	/* (4E00) */
	struct radeon_state_atom bld;	/* blending (4E04) */
	struct radeon_state_atom cmk;	/* colormask (4E0C) */
	struct radeon_state_atom blend_color;	/* constant blend color */
	struct radeon_state_atom rop;	/* ropcntl */
	struct radeon_state_atom cb;	/* colorbuffer (4E28) */
	struct radeon_state_atom rb3d_dither_ctl;	/* (4E50) */
	struct radeon_state_atom rb3d_aaresolve_ctl;	/* (4E88) */
	struct radeon_state_atom rb3d_discard_src_pixel_lte_threshold;	/* (4E88) I saw it only written on RV350 hardware..  */
	struct radeon_state_atom zs;	/* zstencil control (4F00) */
	struct radeon_state_atom zsb;	/* zstencil bf */
	struct radeon_state_atom zstencil_format;
	struct radeon_state_atom zb;	/* z buffer (4F20) */
	struct radeon_state_atom zb_depthclearvalue;	/* (4F28) */
	struct radeon_state_atom zb_zmask;	/* (4F30) */
	struct radeon_state_atom zb_hiz_offset;	/* (4F44) */
	struct radeon_state_atom zb_hiz_pitch;	/* (4F54) */

	struct radeon_state_atom vpi;	/* vp instructions */
	struct radeon_state_atom vpp;	/* vp parameters */
	struct radeon_state_atom vps;	/* vertex point size (?) */
	struct radeon_state_atom vpucp[6];	/* vp user clip plane - 6 */
	/* 8 texture units */
	/* the state is grouped by function and not by
	   texture unit. This makes single unit updates
	   really awkward - we are much better off
	   updating the whole thing at once */
	struct {
		struct radeon_state_atom filter;
		struct radeon_state_atom filter_1;
		struct radeon_state_atom size;
		struct radeon_state_atom format;
		struct radeon_state_atom pitch;
		struct radeon_state_atom offset;
		struct radeon_state_atom chroma_key;
		struct radeon_state_atom border_color;
	} tex;
	struct radeon_state_atom txe;	/* tex enable (4104) */
	radeonTexObj *textures[R300_MAX_TEXTURE_UNITS];
};

/**
 * State cache
 */

/* Vertex shader state */

#define COLOR_IS_RGBA
#define TAG(x) r300##x
#include "tnl_dd/t_dd_vertex.h"
#undef TAG

struct r300_vertex_program_key {
	GLbitfield FpReads;
	GLuint FogAttr;
	GLuint WPosAttr;
};

struct r300_vertex_program {
	struct gl_vertex_program *Base;
	struct r300_vertex_program *next;

	struct r300_vertex_program_key key;
	struct r300_vertex_program_code code;

	GLboolean error;
};

struct r300_vertex_program_cont {
	/* This is the unmodified vertex program mesa provided us with.
	 * We need to keep it unchanged because we may need to create another
	 * hw specific vertex program based on this.
	 */
	struct gl_vertex_program mesa_program;
	/* This is the list of hw specific vertex programs derived from mesa_program */
	struct r300_vertex_program *progs;
};


/**
* Store everything about a fragment program that is needed
* to render with that program.
*/
struct r300_fragment_program {
	GLboolean error;
	struct r300_fragment_program *next;
	struct r300_fragment_program_external_state state;

	struct rX00_fragment_program_code code;
	GLbitfield InputsRead;

	/* attribute that we are sending the WPOS in */
	gl_frag_attrib wpos_attr;
	/* attribute that we are sending the fog coordinate in */
	gl_frag_attrib fog_attr;
};

struct r300_fragment_program_cont {
	/* This is the unmodified fragment program mesa provided us with.
	 * We need to keep it unchanged because we may need to create another
	 * hw specific fragment program based on this.
	 */
	struct gl_fragment_program Base;
	/* This is the list of hw specific fragment programs derived from Base */
	struct r300_fragment_program *progs;
};


#define R300_MAX_AOS_ARRAYS		16


/* r300_swtcl.c
 */
struct r300_swtcl_info {
  /*
    * Offset of the 4UB color data within a hardware (swtcl) vertex.
    */
   GLuint coloroffset;

   /**
    * Offset of the 3UB specular color data within a hardware (swtcl) vertex.
    */
   GLuint specoffset;
};

struct r300_vtable {
	void (* SetupRSUnit)(struct gl_context *ctx);
	void (* SetupFragmentShaderTextures)(struct gl_context *ctx, int *tmu_mappings);
	void (* SetupPixelShader)(struct gl_context *ctx);
};

struct r300_vertex_buffer {
	struct vertex_attribute {
		/* generic */
		GLubyte element;
		GLuint stride;
		GLuint dwords;
		GLubyte size; /* number of components */
		GLboolean is_named_bo;
		struct radeon_bo *bo;
		GLint bo_offset;

		/* hw specific */
		uint32_t data_type:4;
		uint32_t dst_loc:5;
		uint32_t _signed:1;
		uint32_t normalize:1;
		uint32_t swizzle:12;
		uint32_t write_mask:4;
	} attribs[VERT_ATTRIB_MAX];

	GLubyte num_attribs;
};

struct r300_index_buffer {
	struct radeon_bo *bo;
	int bo_offset;

	GLboolean is_32bit;
	GLuint count;
};


/**
 * \brief R300 context structure.
 */
struct r300_context {
	struct radeon_context radeon;	/* parent class, must be first */

	struct r300_vtable vtbl;

	struct r300_hw_state hw;

	struct r300_vertex_program *selected_vp;
	struct r300_fragment_program *selected_fp;

	/* Vertex buffers
	 */
	GLvector4f dummy_attrib[_TNL_ATTRIB_MAX];
	GLvector4f *temp_attrib[_TNL_ATTRIB_MAX];

	struct r300_options {
		uint32_t conformance_mode:1;
		uint32_t hw_tcl_enabled:1;
		uint32_t s3tc_force_enabled:1;
		uint32_t s3tc_force_disabled:1;
		uint32_t stencil_two_side_disabled:1;
	} options;

	struct r300_swtcl_info swtcl;
	struct r300_vertex_buffer vbuf;
	struct r300_index_buffer ind_buf;

	uint32_t fallback;

	struct {
		struct r300_vertex_program_code vp_code;
		struct rX00_fragment_program_code fp_code;
	} blit;

	DECLARE_RENDERINPUTS(render_inputs_bitset);
};

#define R300_CONTEXT(ctx)		((r300ContextPtr)(ctx->DriverCtx))

extern void r300DestroyContext(__DRIcontext * driContextPriv);
extern GLboolean r300CreateContext(gl_api api,
				   const struct gl_config * glVisual,
				   __DRIcontext * driContextPriv,
				   void *sharedContextPrivate);

extern void r300InitShaderFuncs(struct dd_function_table *functions);

extern void r300InitShaderFunctions(r300ContextPtr r300);

extern void r300InitDraw(struct gl_context *ctx);

#define r300PackFloat32 radeonPackFloat32
#define r300PackFloat24 radeonPackFloat24

#endif				/* __R300_CONTEXT_H__ */
@


1.6
log
@Merge Mesa 7.10.3
@
text
@@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d46 1
a46 1
#include "shader/prog_instruction.h"
d466 3
a468 3
	void (* SetupRSUnit)(GLcontext *ctx);
	void (* SetupFragmentShaderTextures)(GLcontext *ctx, int *tmu_mappings);
	void (* SetupPixelShader)(GLcontext *ctx);
d546 2
a547 1
extern GLboolean r300CreateContext(const __GLcontextModes * glVisual,
d555 1
a555 1
extern void r300InitDraw(GLcontext *ctx);
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a39 1
#include "tnl/t_vertex.h"
d43 1
a43 1
#include "texmem.h"
a44 1
#include "main/macros.h"
d46 2
a47 3
#include "main/colormac.h"

#define USER_BUFFERS
a52 18
#include "radeon_lock.h"
#include "main/mm.h"

/* From http://gcc.gnu.org/onlinedocs/gcc-3.2.3/gcc/Variadic-Macros.html .
   I suppose we could inline this and use macro to fetch out __LINE__ and stuff in case we run into trouble
   with other compilers ... GLUE!
*/
#define WARN_ONCE(a, ...)	{ \
	static int warn##__LINE__=1; \
	if(warn##__LINE__){ \
		fprintf(stderr, "*********************************WARN_ONCE*********************************\n"); \
		fprintf(stderr, "File %s function %s line %d\n", \
			__FILE__, __FUNCTION__, __LINE__); \
		fprintf(stderr,  a, ## __VA_ARGS__);\
		fprintf(stderr, "***************************************************************************\n"); \
		warn##__LINE__=0;\
		} \
	}
a54 86
#include "r500_fragprog.h"

/**
 * This function takes a float and packs it into a uint32_t
 */
static INLINE uint32_t r300PackFloat32(float fl)
{
	union {
		float fl;
		uint32_t u;
	} u;

	u.fl = fl;
	return u.u;
}

/* This is probably wrong for some values, I need to test this
 * some more.  Range checking would be a good idea also..
 *
 * But it works for most things.  I'll fix it later if someone
 * else with a better clue doesn't
 */
static INLINE uint32_t r300PackFloat24(float f)
{
	float mantissa;
	int exponent;
	uint32_t float24 = 0;

	if (f == 0.0)
		return 0;

	mantissa = frexpf(f, &exponent);

	/* Handle -ve */
	if (mantissa < 0) {
		float24 |= (1 << 23);
		mantissa = mantissa * -1.0;
	}
	/* Handle exponent, bias of 63 */
	exponent += 62;
	float24 |= (exponent << 16);
	/* Kill 7 LSB of mantissa */
	float24 |= (r300PackFloat32(mantissa) & 0x7FFFFF) >> 7;

	return float24;
}

/************ DMA BUFFERS **************/

/* Need refcounting on dma buffers:
 */
struct r300_dma_buffer {
	int refcount;		/**< the number of retained regions in buf */
	drmBufPtr buf;
	int id;
};
#undef GET_START
#ifdef USER_BUFFERS
#define GET_START(rvb) (r300GartOffsetFromVirtual(rmesa, (rvb)->address+(rvb)->start))
#else
#define GET_START(rvb) (rmesa->radeon.radeonScreen->gart_buffer_offset +		\
			(rvb)->address - rmesa->dma.buf0_address +	\
			(rvb)->start)
#endif
/* A retained region, eg vertices for indexed vertices.
 */
struct r300_dma_region {
	struct r300_dma_buffer *buf;
	char *address;		/* == buf->address */
	int start, end, ptr;	/* offsets from start of buf */

	int aos_offset;		/* address in GART memory */
	int aos_stride;		/* distance between elements, in dwords */
	int aos_size;		/* number of components (1-4) */
};

struct r300_dma {
	/* Active dma region.  Allocations for vertices and retained
	 * regions come from here.  Also used for emitting random vertices,
	 * these may be flushed by calling flush_current();
	 */
	struct r300_dma_region current;

	void (*flush) (r300ContextPtr);

	char *buf0_address;	/* start of buf[0], for index calcs */
a55 55
	/* Number of "in-flight" DMA buffers, i.e. the number of buffers
	 * for which a DISCARD command is currently queued in the command buffer.
	 */
	GLuint nr_released_bufs;
};

       /* Texture related */

typedef struct r300_tex_obj r300TexObj, *r300TexObjPtr;

/* Texture object in locally shared texture space.
 */
struct r300_tex_obj {
	driTextureObject base;

	GLuint bufAddr;		/* Offset to start of locally
				   shared texture block */

	drm_radeon_tex_image_t image[6][RADEON_MAX_TEXTURE_LEVELS];
	/* Six, for the cube faces */

	GLboolean image_override;	/* Image overridden by GLX_EXT_tfp */

	GLuint pitch;		/* this isn't sent to hardware just used in calculations */
	/* hardware register values */
	/* Note that R200 has 8 registers per texture and R300 only 7 */
	GLuint filter;
	GLuint filter_1;
	GLuint pitch_reg;
	GLuint size;		/* npot only */
	GLuint format;
	GLuint offset;		/* Image location in the card's address space.
				   All cube faces follow. */
	GLuint unknown4;
	GLuint unknown5;
	/* end hardware registers */

	/* registers computed by r200 code - keep them here to
	   compare against what is actually written.

	   to be removed later.. */
	GLuint pp_border_color;
	GLuint pp_cubic_faces;	/* cube face 1,2,3,4 log2 sizes */
	GLuint format_x;

	GLboolean border_fallback;

	GLuint tile_bits;	/* hw texture tile bits used on this texture */
};

struct r300_texture_env_state {
	struct gl_texture_object *texobj;
	GLenum format;
	GLenum envMode;
};
a61 19
struct r300_texture_state {
	struct r300_texture_env_state unit[R300_MAX_TEXTURE_UNITS];
	int tc_count;		/* number of incoming texture coordinates from VAP */
};

/**
 * A block of hardware state.
 *
 * When check returns non-zero, the returned number of dwords must be
 * copied verbatim into the command buffer in order to update a state atom
 * when it is dirty.
 */
struct r300_state_atom {
	struct r300_state_atom *next, *prev;
	const char *name;	/* for debug */
	int cmd_size;		/* maximum size in dwords */
	GLuint idx;		/* index in an array (e.g. textures) */
	uint32_t *cmd;
	GLboolean dirty;
a62 2
	int (*check) (r300ContextPtr, struct r300_state_atom * atom);
};
d104 5
a108 3
#define R300_GB_MISC_SELECT		4
#define R300_GB_MISC_AA_CONFIG		5
#define R300_GB_MISC_CMDSIZE		6
d237 4
d281 6
d291 71
a361 74
	struct r300_state_atom atomlist;

	GLboolean is_dirty;
	GLboolean all_dirty;
	int max_state_size;	/* in dwords */

	struct r300_state_atom vpt;	/* viewport (1D98) */
	struct r300_state_atom vap_cntl;
        struct r300_state_atom vap_index_offset; /* 0x208c r5xx only */
	struct r300_state_atom vof;	/* VAP output format register 0x2090 */
	struct r300_state_atom vte;	/* (20B0) */
	struct r300_state_atom vap_vf_max_vtx_indx;	/* Maximum Vertex Indx Clamp (2134) */
	struct r300_state_atom vap_cntl_status;
	struct r300_state_atom vir[2];	/* vap input route (2150/21E0) */
	struct r300_state_atom vic;	/* vap input control (2180) */
	struct r300_state_atom vap_psc_sgn_norm_cntl; /* Programmable Stream Control Signed Normalize Control (21DC) */
	struct r300_state_atom vap_clip_cntl;
	struct r300_state_atom vap_clip;
	struct r300_state_atom vap_pvs_vtx_timeout_reg;	/* Vertex timeout register (2288) */
	struct r300_state_atom pvs;	/* pvs_cntl (22D0) */
	struct r300_state_atom gb_enable;	/* (4008) */
	struct r300_state_atom gb_misc;	/* Multisampling position shifts ? (4010) */
	struct r300_state_atom ga_point_s0;	/* S Texture Coordinate of Vertex 0 for Point texture stuffing (LLC) (4200) */
	struct r300_state_atom ga_triangle_stipple;	/* (4214) */
	struct r300_state_atom ps;	/* pointsize (421C) */
	struct r300_state_atom ga_point_minmax;	/* (4230) */
	struct r300_state_atom lcntl;	/* line control */
	struct r300_state_atom ga_line_stipple;	/* (4260) */
	struct r300_state_atom shade;
	struct r300_state_atom polygon_mode;
	struct r300_state_atom fogp;	/* fog parameters (4294) */
	struct r300_state_atom ga_soft_reset;	/* (429C) */
	struct r300_state_atom zbias_cntl;
	struct r300_state_atom zbs;	/* zbias (42A4) */
	struct r300_state_atom occlusion_cntl;
	struct r300_state_atom cul;	/* cull cntl (42B8) */
	struct r300_state_atom su_depth_scale;	/* (42C0) */
	struct r300_state_atom rc;	/* rs control (4300) */
	struct r300_state_atom ri;	/* rs interpolators (4310) */
	struct r300_state_atom rr;	/* rs route (4330) */
	struct r300_state_atom sc_hyperz;	/* (43A4) */
	struct r300_state_atom sc_screendoor;	/* (43E8) */
	struct r300_state_atom fp;	/* fragment program cntl + nodes (4600) */
	struct r300_state_atom fpt;	/* texi - (4620) */
	struct r300_state_atom us_out_fmt;	/* (46A4) */
	struct r300_state_atom r500fp;	/* r500 fp instructions */
	struct r300_state_atom r500fp_const;	/* r500 fp constants */
	struct r300_state_atom fpi[4];	/* fp instructions (46C0/47C0/48C0/49C0) */
	struct r300_state_atom fogs;	/* fog state (4BC0) */
	struct r300_state_atom fogc;	/* fog color (4BC8) */
	struct r300_state_atom at;	/* alpha test (4BD4) */
	struct r300_state_atom fg_depth_src;	/* (4BD8) */
	struct r300_state_atom fpp;	/* 0x4C00 and following */
	struct r300_state_atom rb3d_cctl;	/* (4E00) */
	struct r300_state_atom bld;	/* blending (4E04) */
	struct r300_state_atom cmk;	/* colormask (4E0C) */
	struct r300_state_atom blend_color;	/* constant blend color */
	struct r300_state_atom rop;	/* ropcntl */
	struct r300_state_atom cb;	/* colorbuffer (4E28) */
	struct r300_state_atom rb3d_dither_ctl;	/* (4E50) */
	struct r300_state_atom rb3d_aaresolve_ctl;	/* (4E88) */
	struct r300_state_atom rb3d_discard_src_pixel_lte_threshold;	/* (4E88) I saw it only written on RV350 hardware..  */
	struct r300_state_atom zs;	/* zstencil control (4F00) */
	struct r300_state_atom zstencil_format;
	struct r300_state_atom zb;	/* z buffer (4F20) */
	struct r300_state_atom zb_depthclearvalue;	/* (4F28) */
	struct r300_state_atom unk4F30;	/* (4F30) */
	struct r300_state_atom zb_hiz_offset;	/* (4F44) */
	struct r300_state_atom zb_hiz_pitch;	/* (4F54) */

	struct r300_state_atom vpi;	/* vp instructions */
	struct r300_state_atom vpp;	/* vp parameters */
	struct r300_state_atom vps;	/* vertex point size (?) */
	struct r300_state_atom vpucp[6];	/* vp user clip plane - 6 */
d368 8
a375 8
		struct r300_state_atom filter;
		struct r300_state_atom filter_1;
		struct r300_state_atom size;
		struct r300_state_atom format;
		struct r300_state_atom pitch;
		struct r300_state_atom offset;
		struct r300_state_atom chroma_key;
		struct r300_state_atom border_color;
d377 2
a378 15
	struct r300_state_atom txe;	/* tex enable (4104) */
};

/**
 * This structure holds the command buffer while it is being constructed.
 *
 * The first batch of commands in the buffer is always the state that needs
 * to be re-emitted when the context is lost. This batch can be skipped
 * otherwise.
 */
struct r300_cmdbuf {
	int size;		/* DWORDs allocated for buffer */
	uint32_t *cmd_buf;
	int count_used;		/* DWORDs filled so far */
	int count_reemit;	/* size of re-emission batch */
a384 8
struct r300_depthbuffer_state {
	GLfloat scale;
};

struct r300_stencilbuffer_state {
	GLboolean hw_stencil;
};

a386 25
/* Perhaps more if we store programs in vmem? */
/* drm_r300_cmd_header_t->vpu->count is unsigned char */
#define VSF_MAX_FRAGMENT_LENGTH (255*4)

/* Can be tested with colormat currently. */
#define VSF_MAX_FRAGMENT_TEMPS (14)

#define STATE_R300_WINDOW_DIMENSION (STATE_INTERNAL_DRIVER+0)
#define STATE_R300_TEXRECT_FACTOR (STATE_INTERNAL_DRIVER+1)

struct r300_vertex_shader_fragment {
	int length;
	union {
		GLuint d[VSF_MAX_FRAGMENT_LENGTH];
		float f[VSF_MAX_FRAGMENT_LENGTH];
		GLuint i[VSF_MAX_FRAGMENT_LENGTH];
	} body;
};

struct r300_vertex_shader_state {
	struct r300_vertex_shader_fragment program;
};

extern int hw_tcl_on;

a391 10
//#define CURRENT_VERTEX_SHADER(ctx) (ctx->VertexProgram._Current)
#define CURRENT_VERTEX_SHADER(ctx) (R300_CONTEXT(ctx)->selected_vp)

/* Should but doesnt work */
//#define CURRENT_VERTEX_SHADER(ctx) (R300_CONTEXT(ctx)->curr_vp)

/* r300_vertex_shader_state and r300_vertex_program should probably be merged together someday.
 * Keeping them them seperate for now should ensure fixed pipeline keeps functioning properly.
 */

d393 3
a395 3
	GLuint InputsRead;
	GLuint OutputsWritten;
	GLuint OutputsAdded;
d399 1
d401 1
d403 1
a403 1
	int translated;
d405 1
a405 10
	struct r300_vertex_shader_fragment program;

	int pos_end;
	int num_temporaries;	/* Number of temp vars used by program */
	int wpos_idx;
	int inputs[VERT_ATTRIB_MAX];
	int outputs[VERT_RESULT_MAX];
	int native;
	int ref_count;
	int use_ref_count;
d409 6
a414 2
	struct gl_vertex_program mesa_program;	/* Must be first */
	struct r300_vertex_shader_fragment params;
a417 8
#define PFS_MAX_ALU_INST	64
#define PFS_MAX_TEX_INST	64
#define PFS_MAX_TEX_INDIRECT 4
#define PFS_NUM_TEMP_REGS	32
#define PFS_NUM_CONST_REGS	16

struct r300_pfs_compile_state;

d420 3
a422 71
 * Stores state that influences the compilation of a fragment program.
 */
struct r300_fragment_program_external_state {
	struct {
		/**
		 * If the sampler is used as a shadow sampler,
		 * this field is:
		 *  0 - GL_LUMINANCE
		 *  1 - GL_INTENSITY
		 *  2 - GL_ALPHA
		 * depending on the depth texture mode.
		 */
		GLuint depth_texture_mode : 2;

		/**
		 * If the sampler is used as a shadow sampler,
		 * this field is (texture_compare_func - GL_NEVER).
		 * [e.g. if compare function is GL_LEQUAL, this field is 3]
		 *
		 * Otherwise, this field is 0.
		 */
		GLuint texture_compare_func : 3;
	} unit[16];
};


struct r300_fragment_program_node {
	int tex_offset; /**< first tex instruction */
	int tex_end; /**< last tex instruction, relative to tex_offset */
	int alu_offset; /**< first ALU instruction */
	int alu_end; /**< last ALU instruction, relative to alu_offset */
	int flags;
};

/**
 * Stores an R300 fragment program in its compiled-to-hardware form.
 */
struct r300_fragment_program_code {
	struct {
		int length; /**< total # of texture instructions used */
		GLuint inst[PFS_MAX_TEX_INST];
	} tex;

	struct {
		int length; /**< total # of ALU instructions used */
		struct {
			GLuint inst0;
			GLuint inst1;
			GLuint inst2;
			GLuint inst3;
		} inst[PFS_MAX_ALU_INST];
	} alu;

	struct r300_fragment_program_node node[4];
	int cur_node;
	int first_node_has_tex;

	/**
	 * Remember which program register a given hardware constant
	 * belongs to.
	 */
	struct prog_src_register constant[PFS_NUM_CONST_REGS];
	int const_nr;

	int max_temp_idx;
};

/**
 * Store everything about a fragment program that is needed
 * to render with that program.
 */
a423 3
	struct gl_fragment_program mesa_program;

	GLboolean translated;
d425 1
a425 1

a426 5
	struct r300_fragment_program_code code;

	GLboolean WritesDepth;
	GLuint optimization;
};
d428 2
a429 1
struct r500_pfs_compile_state;
d431 4
a434 21
struct r500_fragment_program_external_state {
	struct {
		/**
		 * If the sampler is used as a shadow sampler,
		 * this field is:
		 *  0 - GL_LUMINANCE
		 *  1 - GL_INTENSITY
		 *  2 - GL_ALPHA
		 * depending on the depth texture mode.
		 */
		GLuint depth_texture_mode : 2;

		/**
		 * If the sampler is used as a shadow sampler,
		 * this field is (texture_compare_func - GL_NEVER).
		 * [e.g. if compare function is GL_LEQUAL, this field is 3]
		 *
		 * Otherwise, this field is 0.
		 */
		GLuint texture_compare_func : 3;
	} unit[16];
d437 4
a440 16
struct r500_fragment_program_code {
	struct {
		GLuint inst0;
		GLuint inst1;
		GLuint inst2;
		GLuint inst3;
		GLuint inst4;
		GLuint inst5;
	} inst[512];

	int inst_offset;
	int inst_end;

	/**
	 * Remember which program register a given hardware constant
	 * belongs to.
d442 3
a444 4
	struct prog_src_register constant[PFS_NUM_CONST_REGS];
	int const_nr;

	int max_temp_idx;
a446 14
struct r500_fragment_program {
	struct gl_fragment_program mesa_program;

	GLcontext *ctx;
	GLboolean translated;
	GLboolean error;

	struct r500_fragment_program_external_state state;
	struct r500_fragment_program_code code;

	GLboolean writes_depth;

	GLuint optimization;
};
a449 26
#define REG_COORDS	0
#define REG_COLOR0	1
#define REG_TEX0	2

struct r300_state {
	struct r300_depthbuffer_state depth;
	struct r300_texture_state texture;
	int sw_tcl_inputs[VERT_ATTRIB_MAX];
	struct r300_vertex_shader_state vertex_shader;
	struct r300_dma_region aos[R300_MAX_AOS_ARRAYS];
	int aos_count;

	GLuint *Elts;
	struct r300_dma_region elt_dma;

	struct r300_dma_region swtcl_dma;
	DECLARE_RENDERINPUTS(render_inputs_bitset);	/* actual render inputs that R300 was configured for.
							   They are the same as tnl->render_inputs for fixed pipeline */

	struct r300_stencilbuffer_state stencil;

};

#define R300_FALLBACK_NONE 0
#define R300_FALLBACK_TCL 1
#define R300_FALLBACK_RAST 2
d454 1
a454 35
   GLuint RenderIndex;

   /**
    * Size of a hardware vertex.  This is calculated when \c ::vertex_attrs is
    * installed in the Mesa state vector.
    */
   GLuint vertex_size;

   /**
    * Attributes instructing the Mesa TCL pipeline where / how to put vertex
    * data in the hardware buffer.
    */
   struct tnl_attr_map vertex_attrs[VERT_ATTRIB_MAX];

   /**
    * Number of elements of \c ::vertex_attrs that are actually used.
    */
   GLuint vertex_attr_count;

   /**
    * Cached pointer to the buffer where Mesa will store vertex data.
    */
   GLubyte *verts;

   /* Fallback rasterization functions
    */
  //   r200_point_func draw_point;
  //   r200_line_func draw_line;
  //   r200_tri_func draw_tri;

   GLuint hw_primitive;
   GLenum render_primitive;
   GLuint numverts;

   /**
d463 1
d465 32
a496 4
   /**
    * Should Mesa project vertex data or will the hardware do it?
    */
   GLboolean needproj;
d498 2
a499 1
   struct r300_dma_region indexed_verts;
d509 2
d512 1
a512 3
	struct r300_cmdbuf cmdbuf;
	struct r300_state state;
	struct gl_vertex_program *curr_vp;
d514 1
a517 20
	struct r300_dma dma;
	GLboolean save_on_next_unlock;
	GLuint NewGLState;

	/* Texture object bookkeeping
	 */
	unsigned nr_heaps;
	driTexHeap *texture_heaps[RADEON_NR_TEX_HEAPS];
	driTextureObject swapped;
	int texture_depth;
	float initialMaxAnisotropy;

	/* Clientdata textures;
	 */
	GLuint prefer_gart_client_texturing;

#ifdef USER_BUFFERS
	struct r300_memory_manager *rmm;
#endif

d521 7
a527 1
	GLboolean disable_lowimpact_fallback;
a528 1
	DECLARE_RENDERINPUTS(tnl_index_bitset);	/* index of bits for last tnl_install_attrs */
d530 9
a538 1
};
d540 1
a540 3
struct r300_buffer_object {
	struct gl_buffer_object mesa_obj;
	int id;
d545 1
a545 1
extern void r300DestroyContext(__DRIcontextPrivate * driContextPriv);
d547 1
a547 1
				   __DRIcontextPrivate * driContextPriv,
a549 1
extern void r300SelectVertexShader(r300ContextPtr r300);
d551 7
a557 8
extern int r300VertexProgUpdateParams(GLcontext * ctx,
				      struct r300_vertex_program_cont *vp,
				      float *dst);

#define RADEON_D_CAPTURE 0
#define RADEON_D_PLAYBACK 1
#define RADEON_D_PLAYBACK_RAW 2
#define RADEON_D_T 3
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d46 3
a48 3
#include "macros.h"
#include "mtypes.h"
#include "colormac.h"
d57 1
a57 1
#include "mm.h"
d214 1
a214 1
	r300TexObjPtr texobj;
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@a51 2
//#define OPTIMIZE_ELTS

d76 1
a76 1
#include "r300_fragprog.h"
d81 1
a81 1
static __inline__ uint32_t r300PackFloat32(float fl)
d98 1
a98 1
static __inline__ uint32_t r300PackFloat24(float f)
a149 1
	int aos_reg;		/* VAP register assignment */
a180 7
	GLuint dirty_state;	/* Flags (1 per texunit) for
				   whether or not this texobj
				   has dirty hardware state
				   (pp_*) that needs to be
				   brought into the
				   texunit. */

d326 2
d329 8
a336 8
#define R300_RR_ROUTE_0		1
#define R300_RR_ROUTE_1		2
#define R300_RR_ROUTE_2		3
#define R300_RR_ROUTE_3		4
#define R300_RR_ROUTE_4		5
#define R300_RR_ROUTE_5		6
#define R300_RR_ROUTE_6		7
#define R300_RR_ROUTE_7		8
d350 11
d368 2
d374 2
d423 6
d470 1
d473 1
a473 1
	struct r300_state_atom unk2134;	/* (2134) */
d477 1
a477 1
	struct r300_state_atom unk21DC;	/* (21DC) */
d479 2
a480 2
	struct r300_state_atom unk2220;	/* (2220) */
	struct r300_state_atom unk2288;	/* (2288) */
d484 2
a485 2
	struct r300_state_atom unk4200;	/* (4200) */
	struct r300_state_atom unk4214;	/* (4214) */
d487 1
a487 1
	struct r300_state_atom unk4230;	/* (4230) */
d489 1
a489 1
	struct r300_state_atom unk4260;	/* (4260) */
d493 1
a493 1
	struct r300_state_atom unk429C;	/* (429C) */
d498 1
a498 1
	struct r300_state_atom unk42C0;	/* (42C0) */
d502 2
a503 2
	struct r300_state_atom unk43A4;	/* (43A4) */
	struct r300_state_atom unk43E8;	/* (43E8) */
d506 3
a508 1
	struct r300_state_atom unk46A4;	/* (46A4) */
d513 1
a513 1
	struct r300_state_atom unk4BD8;	/* (4BD8) */
d515 1
a515 1
	struct r300_state_atom unk4E00;	/* (4E00) */
d519 1
d521 3
a523 3
	struct r300_state_atom unk4E50;	/* (4E50) */
	struct r300_state_atom unk4E88;	/* (4E88) */
	struct r300_state_atom unk4EA0;	/* (4E88) I saw it only written on RV350 hardware..  */
d527 1
a527 1
	struct r300_state_atom unk4F28;	/* (4F28) */
d529 2
a530 2
	struct r300_state_atom unk4F44;	/* (4F44) */
	struct r300_state_atom unk4F54;	/* (4F54) */
a576 1
	GLuint clear;
a577 1

d597 1
a597 1
		VERTEX_SHADER_INSTRUCTION i[VSF_MAX_FRAGMENT_LENGTH / 4];
a600 9
#define VSF_DEST_PROGRAM	0x0
#define VSF_DEST_MATRIX0	0x200
#define VSF_DEST_MATRIX1	0x204
#define VSF_DEST_MATRIX2	0x208
#define VSF_DEST_VECTOR0	0x20c
#define VSF_DEST_VECTOR1	0x20d
#define VSF_DEST_UNKNOWN1	0x400
#define VSF_DEST_UNKNOWN2	0x406

a602 13

	struct r300_vertex_shader_fragment unknown1;
	struct r300_vertex_shader_fragment unknown2;

	int program_start;
	int unknown_ptr1;	/* pointer within program space */
	int program_end;

	int param_offset;
	int param_count;

	int unknown_ptr2;	/* pointer within program space */
	int unknown_ptr3;	/* pointer within program space */
d607 5
d625 1
d657 2
a658 5
/* Mapping Mesa registers to R300 temporaries */
struct reg_acc {
	int reg;		/* Assigned hw temp */
	unsigned int refcount;	/* Number of uses by mesa program */
};
d661 1
a661 1
 * Describe the current lifetime information for an R300 temporary
d663 21
a683 23
struct reg_lifetime {
	/* Index of the first slot where this register is free in the sense
	   that it can be used as a new destination register.
	   This is -1 if the register has been assigned to a Mesa register
	   and the last access to the register has not yet been emitted */
	int free;

	/* Index of the first slot where this register is currently reserved.
	   This is used to stop e.g. a scalar operation from being moved
	   before the allocation time of a register that was first allocated
	   for a vector operation. */
	int reserved;

	/* Index of the first slot in which the register can be used as a
	   source without losing the value that is written by the last
	   emitted instruction that writes to the register */
	int vector_valid;
	int scalar_valid;

	/* Index to the slot where the register was last read.
	   This is also the first slot in which the register may be written again */
	int vector_lastread;
	int scalar_lastread;
d686 7
a692 19
/**
 * Store usage information about an ALU instruction slot during the
 * compilation of a fragment program.
 */
#define SLOT_SRC_VECTOR  (1<<0)
#define SLOT_SRC_SCALAR  (1<<3)
#define SLOT_SRC_BOTH    (SLOT_SRC_VECTOR | SLOT_SRC_SCALAR)
#define SLOT_OP_VECTOR   (1<<16)
#define SLOT_OP_SCALAR   (1<<17)
#define SLOT_OP_BOTH     (SLOT_OP_VECTOR | SLOT_OP_SCALAR)

struct r300_pfs_compile_slot {
	/* Bitmask indicating which parts of the slot are used, using SLOT_ constants
	   defined above */
	unsigned int used;

	/* Selected sources */
	int vsrc[3];
	int ssrc[3];
d696 1
a696 1
 * Store information during compilation of fragment programs.
d698 5
a702 2
struct r300_pfs_compile_state {
	int nrslots;		/* number of ALU slots used so far */
d704 9
a712 2
	/* Track which (parts of) slots are already filled with instructions */
	struct r300_pfs_compile_slot slot[PFS_MAX_ALU_INST];
d714 12
a725 12
	/* Track the validity of R300 temporaries */
	struct reg_lifetime hwtemps[PFS_NUM_TEMP_REGS];

	/* Used to map Mesa's inputs/temps onto hardware temps */
	int temp_in_use;
	struct reg_acc temps[PFS_NUM_TEMP_REGS];
	struct reg_acc inputs[32];	/* don't actually need 32... */

	/* Track usage of hardware temps, for register allocation,
	 * indirection detection, etc. */
	GLuint used_in_node;
	GLuint dest_in_node;
a734 1
	GLcontext *ctx;
a736 1
	struct r300_pfs_compile_state *cs;
d738 8
a745 4
	struct {
		int length;
		GLuint inst[PFS_MAX_TEX_INST];
	} tex;
d747 1
d749 20
a768 7
		struct {
			GLuint inst0;
			GLuint inst1;
			GLuint inst2;
			GLuint inst3;
		} inst[PFS_MAX_ALU_INST];
	} alu;
d770 1
d772 14
a785 20
		int tex_offset;
		int tex_end;
		int alu_offset;
		int alu_end;
		int flags;
	} node[4];
	int cur_node;
	int first_node_has_tex;

	int alu_offset;
	int alu_end;
	int tex_offset;
	int tex_end;

	/* Hardware constants.
	 * Contains a pointer to the value. The destination of the pointer
	 * is supposed to be updated when GL state changes.
	 * Typically, this is either a pointer into
	 * gl_program_parameter_list::ParameterValues, or a pointer to a
	 * global constant (e.g. for sin/cos-approximation)
d787 1
a787 1
	const GLfloat *constant[PFS_NUM_CONST_REGS];
d791 13
a809 5
#define AOS_FORMAT_USHORT	0
#define AOS_FORMAT_FLOAT	1
#define AOS_FORMAT_UBYTE	2
#define AOS_FORMAT_FLOAT_COLOR	3

a813 22
struct dt {
	GLint size;
	GLenum type;
	GLsizei stride;
	void *data;
};

struct radeon_vertex_buffer {
	int Count;
	void *Elts;
	int elt_size;
	int elt_min, elt_max;	/* debug */

	struct dt AttribPtr[VERT_ATTRIB_MAX];

	const struct _mesa_prim *Primitive;
	GLuint PrimitiveCount;
	GLint LockFirst;
	GLsizei LockCount;
	int lock_uptodate;
};

a818 1
	struct r300_pfs_compile_state pfs_compile;
a820 1
	struct radeon_vertex_buffer VB;
d825 2
a826 1
	 DECLARE_RENDERINPUTS(render_inputs_bitset);	/* actual render inputs that R300 was configured for.
a828 4
	struct {
		int transform_offset;	/* Transform matrix offset, -1 if none */
	} vap_param;		/* vertex processor parameter allocation - tells where to write parameters */

d837 56
d931 3
@


1.1
log
@Initial revision
@
text
@d30 5
a34 4
/*
 * Authors:
 *   Keith Whitwell <keith@@tungstengraphics.com>
 *   Nicolai Haehnle <prefect_@@gmx.net>
a48 1
#include "radeon_context.h"
a50 7
#define RADEON_VTXFMT_A
#define HW_VBOS

/* We don't handle 16 bits elts swapping yet */
#ifdef MESA_BIG_ENDIAN
#define FORCE_32BITS_ELTS
#endif
a52 1
#define CB_DPATH
a60 2
/* Checkpoint.. for convenience */
#define CPT	{ fprintf(stderr, "%s:%s line %d\n", __FILE__, __FUNCTION__, __LINE__); }
d62 1
a62 1
   I suppose we could inline this and use macro to fetch out __LINE__ and stuff in case we run into trouble 
a64 1
#if 1
a75 3
#else
#define WARN_ONCE(a, ...) {}
#endif
d77 1
a77 4
  /* We should probably change types within vertex_shader
      and pixel_shader structure later on */
#define CARD32 GLuint
#include "vertex_shader.h"
a78 1
#undef CARD32
d80 3
d85 4
a88 1
	union { float fl; uint32_t u; } u;
d94 30
d130 1
a130 1
	int refcount;		/* the number of retained regions in buf */
d149 4
a152 4
    int aos_offset;     /* address in GART memory */
    int aos_stride;     /* distance between elements, in dwords */
    int aos_size;       /* number of components (1-4) */
    int aos_reg;        /* VAP register assignment */
d194 1
d196 1
a196 1
	GLuint pitch; /* this isn't sent to hardware just used in calculations */
d200 1
d202 1
a202 1
	GLuint size;	/* npot only */
d204 1
a204 1
	GLuint offset;	/* Image location in the card's address space.
a217 1

d220 1
a220 1
	GLuint tile_bits; /* hw texture tile bits used on this texture */
a228 1

d236 1
a236 1
	int tc_count; /* number of incoming texture coordinates from VAP */
d248 1
a248 1
	const char* name;	/* for debug */
d251 1
a251 1
	uint32_t* cmd;
d254 1
a254 1
	int (*check)(r300ContextPtr, struct r300_state_atom* atom);
a256 1

d266 1
a266 1
#define R300_VIR_CMD_0		0 /* vir is variable size (at least 1) */
a286 1

d336 1
a336 1
#define R300_RR_CMD_0		0 /* rr is variable size (at least 1) */
d418 1
a418 1
#define R300_VPI_CMDSIZE	1025 /* 256 16 byte instructions */
d422 8
a429 1
#define R300_VPP_CMDSIZE	1025 /* 256 4-component parameters */
d451 3
a453 3
	GLboolean	is_dirty;
	GLboolean	all_dirty;
	int		max_state_size;	/* in dwords */
d456 2
a457 2
	struct r300_state_atom unk2080;	/* (2080) */
	struct r300_state_atom vof;     /* VAP output format register 0x2090 */
d460 1
a460 1
	struct r300_state_atom unk2140;	/* (2140) */
d463 4
a466 4
	struct r300_state_atom unk21DC; /* (21DC) */
	struct r300_state_atom unk221C; /* (221C) */
	struct r300_state_atom unk2220; /* (2220) */
	struct r300_state_atom unk2288; /* (2288) */
d468 4
a471 4
	struct r300_state_atom gb_enable; /* (4008) */
	struct r300_state_atom gb_misc; /* Multisampling position shifts ? (4010) */
	struct r300_state_atom unk4200; /* (4200) */
	struct r300_state_atom unk4214; /* (4214) */
d473 1
a473 1
	struct r300_state_atom unk4230; /* (4230) */
d475 3
a477 3
	struct r300_state_atom unk4260; /* (4260) */
	struct r300_state_atom unk4274; /* (4274) */
	struct r300_state_atom unk4288; /* (4288) */
d479 2
a480 2
	struct r300_state_atom unk429C; /* (429C) */
	struct r300_state_atom unk42A0;	/* (42A0) */
d482 1
a482 1
	struct r300_state_atom unk42B4; /* (42B4) */
d484 1
a484 1
	struct r300_state_atom unk42C0; /* (42C0) */
d491 1
a491 1
	struct r300_state_atom fpt;     /* texi - (4620) */
d498 1
a498 1
	struct r300_state_atom fpp;     /* 0x4C00 and following */
d502 1
a502 1
	struct r300_state_atom unk4E10;	/* constant blend color + ??? (4E10) */
d508 1
a508 1
	struct r300_state_atom unk4F10;	/* (4F10) */
d518 6
a523 5
		/* 8 texture units */
		/* the state is grouped by function and not by
		   texture unit. This makes single unit updates
		   really awkward - we are much better off
		   updating the whole thing at once */
d526 1
a526 1
		struct r300_state_atom unknown1;
d531 1
a531 1
		struct r300_state_atom unknown4;
d533 1
a533 1
		} tex;
a536 1

d545 4
a548 4
	int		size;		/* DWORDs allocated for buffer */
	uint32_t*	cmd_buf;
	int		count_used;	/* DWORDs filled so far */
	int		count_reemit;	/* size of re-emission batch */
a550 1

d570 1
a570 1
	
d574 2
d582 3
a584 3
		VERTEX_SHADER_INSTRUCTION i[VSF_MAX_FRAGMENT_LENGTH/4];
		} body;
	};
a597 5
	/* a bit of a waste - each uses only a subset of allocated space..
	    but easier to program */
	struct r300_vertex_shader_fragment matrix[3];
	struct r300_vertex_shader_fragment vector[2];

d602 1
a602 1
	int unknown_ptr1;  /* pointer within program space */
d608 4
a611 4
	int unknown_ptr2;  /* pointer within program space */
	int unknown_ptr3;  /* pointer within program space */
	};
	
d614 2
a615 1
#define CURRENT_VERTEX_SHADER(ctx) (ctx->VertexProgram._Current)
d620 3
a622 4
//#define TMU_ENABLED(ctx, unit) (hw_tcl_on ? ctx->Texture.Unit[unit]._ReallyEnabled && (OutputsWritten & (1<<(VERT_RESULT_TEX0+(unit)))) : 
//	(r300->state.render_inputs & (_TNL_BIT_TEX0<<(unit))))
//#define TMU_ENABLED(ctx, unit) (hw_tcl_on ? ctx->Texture.Unit[unit]._ReallyEnabled && OutputsWritten & (1<<(VERT_RESULT_TEX0+(unit))) : 
//	ctx->Texture.Unit[unit]._ReallyEnabled && r300->state.render_inputs & (_TNL_BIT_TEX0<<(unit)))
d624 4
a627 1
#define TMU_ENABLED(ctx, unit) (ctx->Texture.Unit[unit]._ReallyEnabled)
a628 3
/* r300_vertex_shader_state and r300_vertex_program should probably be merged together someday.
 * Keeping them them seperate for now should ensure fixed pipeline keeps functioning properly.
 */	
d630 2
a631 1
	struct gl_vertex_program mesa_program; /* Must be first */
d633 1
a633 1
	
d635 1
a635 2
	struct r300_vertex_shader_fragment params;
	
d637 2
a638 1
	int num_temporaries; /* Number of temp vars used by program */
d646 6
d658 1
a658 1
/* Tracking data for Mesa registers */
d660 2
a661 2
       int reg;        /* Assigned hw temp */
       unsigned int refcount; /* Number of uses by mesa program */
d664 52
d717 4
a720 1
       int v_pos, s_pos;       /* highest ALU slots used */
d722 12
a733 21
       /* Track some information gathered during opcode
        * construction.
        * 
        * NOTE: Data is only set by the code, and isn't used yet.
        */
       struct {
               int vsrc[3];
               int ssrc[3];
               int umask;
       } slot[PFS_MAX_ALU_INST];

       /* Used to map Mesa's inputs/temps onto hardware temps */
       int temp_in_use;
       struct reg_acc temps[PFS_NUM_TEMP_REGS];
       struct reg_acc inputs[32]; /* don't actually need 32... */

       /* Track usage of hardware temps, for register allocation,
        * indirection detection, etc. */
       int hwreg_in_use;
       GLuint used_in_node;
       GLuint dest_in_node;
d736 4
d777 8
a784 2
	/* Hardware constants */
	GLfloat constant[PFS_NUM_CONST_REGS][4];
d787 1
a787 7
	/* Tracked parameters */
	struct {
		int idx;			/* hardware index */
		GLfloat *values;	/* pointer to values */
	} param[PFS_NUM_CONST_REGS];
	int param_nr;
	GLboolean params_uptodate;
d789 1
a789 1
	int max_temp_idx;
d814 2
a815 2
	int elt_min, elt_max; /* debug */
	
d817 3
a819 3
	
	struct tnl_prim  *Primitive;	              
	GLuint      PrimitiveCount;
a824 13
struct r300_aos_rec {
	GLuint offset;
	int element_size; /* in dwords */
	int stride;       /* distance between elements, in dwords */

	int format;

	int ncomponents; /* number of components - between 1 and 4, inclusive */

	int reg; /* which register they are assigned to. */

	};

d837 4
a840 4
	
	DECLARE_RENDERINPUTS(render_inputs_bitset); /* actual render inputs that R300 was configured for. 
				 They are the same as tnl->render_inputs for fixed pipeline */	
	
d842 3
a844 3
		int transform_offset;  /* Transform matrix offset, -1 if none */
		} vap_param;  /* vertex processor parameter allocation - tells where to write parameters */
	
d846 1
a846 1
	
d854 1
a854 1
 * R300 context structure.
d857 1
a857 1
	struct radeon_context radeon; /* parent class, must be first */
d863 1
d884 3
a886 1
	struct radeon_memory_manager *rmm;
a888 1
#endif
a889 2
	GLboolean texmicrotile;
	GLboolean span_dlocking;
d897 1
a897 1
		
a899 13
static __inline GLuint r300PackColor( GLuint cpp,
					GLubyte r, GLubyte g,
					GLubyte b, GLubyte a )
{
   switch ( cpp ) {
   case 2:
      return PACK_COLOR_565( r, g, b );
   case 4:
      return PACK_COLOR_8888( r, g, b, a );
   default:
      return 0;
   }
}
d905 1
a905 3
extern int r300_get_num_verts(r300ContextPtr rmesa, int num_verts, int prim);

void r300_translate_vertex_shader(struct r300_vertex_program *vp);
d907 3
a909 14
extern int r300VertexProgUpdateParams(GLcontext *ctx, struct r300_vertex_program *vp, float *dst);
extern int r300Fallback(GLcontext *ctx);

extern void radeon_vb_to_rvb(r300ContextPtr rmesa, struct radeon_vertex_buffer *rvb, struct vertex_buffer *vb);
extern GLboolean r300_run_vb_render(GLcontext *ctx, struct tnl_pipeline_stage *stage);

#ifdef RADEON_VTXFMT_A
extern void radeon_init_vtxfmt_a(r300ContextPtr rmesa);
#endif

#ifdef HW_VBOS
extern void r300_init_vbo_funcs(struct dd_function_table *functions);
extern void r300_evict_vbos(GLcontext *ctx, int amount);
#endif
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a551 1
#define STATE_R300_WINDOW_DIMENSION (STATE_INTERNAL_DRIVER+0)
d595 1
a595 2
//#define CURRENT_VERTEX_SHADER(ctx) (ctx->VertexProgram._Current)
#define CURRENT_VERTEX_SHADER(ctx) (R300_CONTEXT(ctx)->selected_vp)
a609 6

struct r300_vertex_program_key {
	GLuint InputsRead;
	GLuint OutputsWritten;
};

d611 1
a611 2
	struct r300_vertex_program *next;
	struct r300_vertex_program_key key;
d615 1
a618 1
	int wpos_idx;
a625 6
struct r300_vertex_program_cont {
	struct gl_vertex_program mesa_program; /* Must be first */
	struct r300_vertex_shader_fragment params;
	struct r300_vertex_program *progs;
};

a799 1
	struct r300_vertex_program *selected_vp;
d857 1
a857 1
extern void r300_select_vertex_shader(r300ContextPtr r300);
d859 1
a859 1
extern int r300VertexProgUpdateParams(GLcontext *ctx, struct r300_vertex_program_cont *vp, float *dst);
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d30 4
a33 5
/**
 * \file
 *
 * \author Keith Whitwell <keith@@tungstengraphics.com>
 * \author Nicolai Haehnle <prefect_@@gmx.net>
d48 1
d51 7
d60 1
d69 2
d72 1
a72 1
   I suppose we could inline this and use macro to fetch out __LINE__ and stuff in case we run into trouble
d75 1
d87 3
d91 4
a94 1
#include "r300_vertprog.h"
d96 1
a97 3
/**
 * This function takes a float and packs it into a uint32_t
 */
d100 1
a100 4
	union {
		float fl;
		uint32_t u;
	} u;
a105 30
/* This is probably wrong for some values, I need to test this
 * some more.  Range checking would be a good idea also..
 *
 * But it works for most things.  I'll fix it later if someone
 * else with a better clue doesn't
 */
static __inline__ uint32_t r300PackFloat24(float f)
{
	float mantissa;
	int exponent;
	uint32_t float24 = 0;

	if (f == 0.0)
		return 0;

	mantissa = frexpf(f, &exponent);

	/* Handle -ve */
	if (mantissa < 0) {
		float24 |= (1 << 23);
		mantissa = mantissa * -1.0;
	}
	/* Handle exponent, bias of 63 */
	exponent += 62;
	float24 |= (exponent << 16);
	/* Kill 7 LSB of mantissa */
	float24 |= (r300PackFloat32(mantissa) & 0x7FFFFF) >> 7;

	return float24;
}
d112 1
a112 1
	int refcount;		/**< the number of retained regions in buf */
d131 4
a134 4
	int aos_offset;		/* address in GART memory */
	int aos_stride;		/* distance between elements, in dwords */
	int aos_size;		/* number of components (1-4) */
	int aos_reg;		/* VAP register assignment */
a175 1
	GLboolean image_override;	/* Image overridden by GLX_EXT_tfp */
d177 1
a177 1
	GLuint pitch;		/* this isn't sent to hardware just used in calculations */
a180 1
	GLuint filter_1;
d182 1
a182 1
	GLuint size;		/* npot only */
d184 1
a184 1
	GLuint offset;		/* Image location in the card's address space.
d198 1
d201 1
a201 1
	GLuint tile_bits;	/* hw texture tile bits used on this texture */
d210 1
d218 1
a218 1
	int tc_count;		/* number of incoming texture coordinates from VAP */
d230 1
a230 1
	const char *name;	/* for debug */
d233 1
a233 1
	uint32_t *cmd;
d236 1
a236 1
	int (*check) (r300ContextPtr, struct r300_state_atom * atom);
d239 1
d249 1
a249 1
#define R300_VIR_CMD_0		0	/* vir is variable size (at least 1) */
d270 1
d320 1
a320 1
#define R300_RR_CMD_0		0	/* rr is variable size (at least 1) */
d402 1
a402 1
#define R300_VPI_CMDSIZE	1025	/* 256 16 byte instructions */
d406 1
a406 1
#define R300_VPP_CMDSIZE	1025	/* 256 4-component parameters */
d428 3
a430 3
	GLboolean is_dirty;
	GLboolean all_dirty;
	int max_state_size;	/* in dwords */
d433 2
a434 2
	struct r300_state_atom vap_cntl;
	struct r300_state_atom vof;	/* VAP output format register 0x2090 */
d437 1
a437 1
	struct r300_state_atom vap_cntl_status;
d440 4
a443 4
	struct r300_state_atom unk21DC;	/* (21DC) */
	struct r300_state_atom unk221C;	/* (221C) */
	struct r300_state_atom unk2220;	/* (2220) */
	struct r300_state_atom unk2288;	/* (2288) */
d445 4
a448 4
	struct r300_state_atom gb_enable;	/* (4008) */
	struct r300_state_atom gb_misc;	/* Multisampling position shifts ? (4010) */
	struct r300_state_atom unk4200;	/* (4200) */
	struct r300_state_atom unk4214;	/* (4214) */
d450 1
a450 1
	struct r300_state_atom unk4230;	/* (4230) */
d452 3
a454 3
	struct r300_state_atom unk4260;	/* (4260) */
	struct r300_state_atom shade;
	struct r300_state_atom polygon_mode;
d456 2
a457 2
	struct r300_state_atom unk429C;	/* (429C) */
	struct r300_state_atom zbias_cntl;
d459 1
a459 1
	struct r300_state_atom occlusion_cntl;
d461 1
a461 1
	struct r300_state_atom unk42C0;	/* (42C0) */
d468 1
a468 1
	struct r300_state_atom fpt;	/* texi - (4620) */
d475 1
a475 1
	struct r300_state_atom fpp;	/* 0x4C00 and following */
d479 1
a479 1
	struct r300_state_atom blend_color;	/* constant blend color */
d485 1
a485 1
	struct r300_state_atom zstencil_format;
d495 5
a499 5
	/* 8 texture units */
	/* the state is grouped by function and not by
	   texture unit. This makes single unit updates
	   really awkward - we are much better off
	   updating the whole thing at once */
d502 1
a502 1
		struct r300_state_atom filter_1;
d507 1
a507 1
		struct r300_state_atom chroma_key;
d509 1
a509 1
	} tex;
d513 1
d522 4
a525 4
	int size;		/* DWORDs allocated for buffer */
	uint32_t *cmd_buf;
	int count_used;		/* DWORDs filled so far */
	int count_reemit;	/* size of re-emission batch */
d528 1
d548 1
a548 1

a552 1
#define STATE_R300_TEXRECT_FACTOR (STATE_INTERNAL_DRIVER+1)
d559 3
a561 3
		VERTEX_SHADER_INSTRUCTION i[VSF_MAX_FRAGMENT_LENGTH / 4];
	} body;
};
d575 5
d584 1
a584 1
	int unknown_ptr1;	/* pointer within program space */
d590 4
a593 4
	int unknown_ptr2;	/* pointer within program space */
	int unknown_ptr3;	/* pointer within program space */
};

d602 7
d611 1
a611 1
 */
d622 1
a622 1

d624 1
a624 1

d626 1
a626 1
	int num_temporaries;	/* Number of temp vars used by program */
d636 1
a636 1
	struct gl_vertex_program mesa_program;	/* Must be first */
d647 1
a647 1
/* Mapping Mesa registers to R300 temporaries */
d649 2
a650 2
	int reg;		/* Assigned hw temp */
	unsigned int refcount;	/* Number of uses by mesa program */
a652 52
/**
 * Describe the current lifetime information for an R300 temporary
 */
struct reg_lifetime {
	/* Index of the first slot where this register is free in the sense
	   that it can be used as a new destination register.
	   This is -1 if the register has been assigned to a Mesa register
	   and the last access to the register has not yet been emitted */
	int free;

	/* Index of the first slot where this register is currently reserved.
	   This is used to stop e.g. a scalar operation from being moved
	   before the allocation time of a register that was first allocated
	   for a vector operation. */
	int reserved;

	/* Index of the first slot in which the register can be used as a
	   source without losing the value that is written by the last
	   emitted instruction that writes to the register */
	int vector_valid;
	int scalar_valid;

	/* Index to the slot where the register was last read.
	   This is also the first slot in which the register may be written again */
	int vector_lastread;
	int scalar_lastread;
};

/**
 * Store usage information about an ALU instruction slot during the
 * compilation of a fragment program.
 */
#define SLOT_SRC_VECTOR  (1<<0)
#define SLOT_SRC_SCALAR  (1<<3)
#define SLOT_SRC_BOTH    (SLOT_SRC_VECTOR | SLOT_SRC_SCALAR)
#define SLOT_OP_VECTOR   (1<<16)
#define SLOT_OP_SCALAR   (1<<17)
#define SLOT_OP_BOTH     (SLOT_OP_VECTOR | SLOT_OP_SCALAR)

struct r300_pfs_compile_slot {
	/* Bitmask indicating which parts of the slot are used, using SLOT_ constants
	   defined above */
	unsigned int used;

	/* Selected sources */
	int vsrc[3];
	int ssrc[3];
};

/**
 * Store information during compilation of fragment programs.
 */
d654 1
a654 1
	int nrslots;		/* number of ALU slots used so far */
d656 21
a676 15
	/* Track which (parts of) slots are already filled with instructions */
	struct r300_pfs_compile_slot slot[PFS_MAX_ALU_INST];

	/* Track the validity of R300 temporaries */
	struct reg_lifetime hwtemps[PFS_NUM_TEMP_REGS];

	/* Used to map Mesa's inputs/temps onto hardware temps */
	int temp_in_use;
	struct reg_acc temps[PFS_NUM_TEMP_REGS];
	struct reg_acc inputs[32];	/* don't actually need 32... */

	/* Track usage of hardware temps, for register allocation,
	 * indirection detection, etc. */
	GLuint used_in_node;
	GLuint dest_in_node;
a678 4
/**
 * Store everything about a fragment program that is needed
 * to render with that program.
 */
d716 2
a717 8
	/* Hardware constants.
	 * Contains a pointer to the value. The destination of the pointer
	 * is supposed to be updated when GL state changes.
	 * Typically, this is either a pointer into
	 * gl_program_parameter_list::ParameterValues, or a pointer to a
	 * global constant (e.g. for sin/cos-approximation)
	 */
	const GLfloat *constant[PFS_NUM_CONST_REGS];
d720 8
a728 2

	GLuint optimization;
d753 2
a754 2
	int elt_min, elt_max;	/* debug */

d756 3
a758 3

	const struct _mesa_prim *Primitive;
	GLuint PrimitiveCount;
d764 13
d789 4
a792 4

	 DECLARE_RENDERINPUTS(render_inputs_bitset);	/* actual render inputs that R300 was configured for.
							   They are the same as tnl->render_inputs for fixed pipeline */

d794 3
a796 3
		int transform_offset;	/* Transform matrix offset, -1 if none */
	} vap_param;		/* vertex processor parameter allocation - tells where to write parameters */

d798 1
a798 1

d806 1
a806 1
 * \brief R300 context structure.
d809 1
a809 1
	struct radeon_context radeon;	/* parent class, must be first */
d836 1
a836 3
	struct r300_memory_manager *rmm;
#endif

d839 1
d841 2
d850 1
a850 1

d853 13
d871 3
a873 1
extern void r300SelectVertexShader(r300ContextPtr r300);
d875 14
a888 3
extern int r300VertexProgUpdateParams(GLcontext * ctx,
				      struct r300_vertex_program_cont *vp,
				      float *dst);
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d40 1
d44 1
a44 1
#include "radeon_common.h"
d46 7
a52 3
#include "main/mtypes.h"
#include "program/prog_instruction.h"
#include "compiler/radeon_code.h"
d58 18
d78 43
d122 106
d234 19
d254 2
d297 3
a299 5
#define R300_GB_MISC_CMDSIZE		4
#define R300_GB_MISC2_CMD_0		    0
#define R300_GB_MISC2_SELECT		1
#define R300_GB_MISC2_AA_CONFIG		2
#define R300_GB_MISC2_CMDSIZE		3
a335 2
#define R500_RI_CMDSIZE	       17

d337 8
a344 8
#define R300_RR_INST_0		1
#define R300_RR_INST_1		2
#define R300_RR_INST_2		3
#define R300_RR_INST_3		4
#define R300_RR_INST_4		5
#define R300_RR_INST_5		6
#define R300_RR_INST_6		7
#define R300_RR_INST_7		8
a357 11
#define R500_FP_CMD_0           0
#define R500_FP_CNTL            1
#define R500_FP_PIXSIZE         2
#define R500_FP_CMD_1           3
#define R500_FP_CODE_ADDR       4
#define R500_FP_CODE_RANGE      5
#define R500_FP_CODE_OFFSET     6
#define R500_FP_CMD_2           7
#define R500_FP_FC_CNTL         8
#define R500_FP_CMDSIZE         9

a364 2
/* R500 has space for 512 instructions - 6 dwords per instruction */
#define R500_FPI_CMDSIZE	(512*6+1)
a368 2
/* R500 has spcae for 256 constants - 4 dwords per constant */
#define R500_FPP_CMDSIZE	(256*4+1)
a410 4
#define R300_ZSB_CMD_0		0
#define R300_ZSB_CNTL_0		1
#define R300_ZSB_CMDSIZE	2

a415 6
#define R300_VAP_CNTL_FLUSH     0
#define R300_VAP_CNTL_FLUSH_1   1
#define R300_VAP_CNTL_CMD       2
#define R300_VAP_CNTL_INSTR     3
#define R300_VAP_CNTL_SIZE      4

a423 7
#define R300_VPUCP_CMD_0		0
#define R300_VPUCP_X            1
#define R300_VPUCP_Y            2
#define R300_VPUCP_Z            3
#define R300_VPUCP_W            4
#define R300_VPUCP_CMDSIZE	5	/* 256 4-component parameters */

a437 6
#define R300_QUERYOBJ_CMD_0  0
#define R300_QUERYOBJ_DATA_0 1
#define R300_QUERYOBJ_CMD_1  2
#define R300_QUERYOBJ_DATA_1  3
#define R300_QUERYOBJ_CMDSIZE  4

d442 69
a510 71
	struct radeon_state_atom vpt;	/* viewport (1D98) */
	struct radeon_state_atom vap_cntl;
	struct radeon_state_atom vap_index_offset; /* 0x208c r5xx only */
	struct radeon_state_atom vof;	/* VAP output format register 0x2090 */
	struct radeon_state_atom vte;	/* (20B0) */
	struct radeon_state_atom vap_vf_max_vtx_indx;	/* Maximum Vertex Indx Clamp (2134) */
	struct radeon_state_atom vap_cntl_status;
	struct radeon_state_atom vir[2];	/* vap input route (2150/21E0) */
	struct radeon_state_atom vic;	/* vap input control (2180) */
	struct radeon_state_atom vap_psc_sgn_norm_cntl; /* Programmable Stream Control Signed Normalize Control (21DC) */
	struct radeon_state_atom vap_clip_cntl;
	struct radeon_state_atom vap_clip;
	struct radeon_state_atom vap_pvs_vtx_timeout_reg;	/* Vertex timeout register (2288) */
	struct radeon_state_atom pvs;	/* pvs_cntl (22D0) */
	struct radeon_state_atom gb_enable;	/* (4008) */
	struct radeon_state_atom gb_misc;	/* Multisampling position shifts ? (4010) */
	struct radeon_state_atom gb_misc2;	/* Multisampling position shifts ? (4010) */
	struct radeon_state_atom ga_point_s0;	/* S Texture Coordinate of Vertex 0 for Point texture stuffing (LLC) (4200) */
	struct radeon_state_atom ga_triangle_stipple;	/* (4214) */
	struct radeon_state_atom ps;	/* pointsize (421C) */
	struct radeon_state_atom ga_point_minmax;	/* (4230) */
	struct radeon_state_atom lcntl;	/* line control */
	struct radeon_state_atom ga_line_stipple;	/* (4260) */
	struct radeon_state_atom shade;
	struct radeon_state_atom shade2;
	struct radeon_state_atom polygon_mode;
	struct radeon_state_atom fogp;	/* fog parameters (4294) */
	struct radeon_state_atom ga_soft_reset;	/* (429C) */
	struct radeon_state_atom zbias_cntl;
	struct radeon_state_atom zbs;	/* zbias (42A4) */
	struct radeon_state_atom occlusion_cntl;
	struct radeon_state_atom cul;	/* cull cntl (42B8) */
	struct radeon_state_atom su_depth_scale;	/* (42C0) */
	struct radeon_state_atom rc;	/* rs control (4300) */
	struct radeon_state_atom ri;	/* rs interpolators (4310) */
	struct radeon_state_atom rr;	/* rs route (4330) */
	struct radeon_state_atom sc_hyperz;	/* (43A4) */
	struct radeon_state_atom sc_screendoor;	/* (43E8) */
	struct radeon_state_atom fp;	/* fragment program cntl + nodes (4600) */
	struct radeon_state_atom fpt;	/* texi - (4620) */
	struct radeon_state_atom us_out_fmt;	/* (46A4) */
	struct radeon_state_atom r500fp;	/* r500 fp instructions */
	struct radeon_state_atom r500fp_const;	/* r500 fp constants */
	struct radeon_state_atom fpi[4];	/* fp instructions (46C0/47C0/48C0/49C0) */
	struct radeon_state_atom fogs;	/* fog state (4BC0) */
	struct radeon_state_atom fogc;	/* fog color (4BC8) */
	struct radeon_state_atom at;	/* alpha test (4BD4) */
	struct radeon_state_atom fg_depth_src;	/* (4BD8) */
	struct radeon_state_atom fpp;	/* 0x4C00 and following */
	struct radeon_state_atom rb3d_cctl;	/* (4E00) */
	struct radeon_state_atom bld;	/* blending (4E04) */
	struct radeon_state_atom cmk;	/* colormask (4E0C) */
	struct radeon_state_atom blend_color;	/* constant blend color */
	struct radeon_state_atom rop;	/* ropcntl */
	struct radeon_state_atom cb;	/* colorbuffer (4E28) */
	struct radeon_state_atom rb3d_dither_ctl;	/* (4E50) */
	struct radeon_state_atom rb3d_aaresolve_ctl;	/* (4E88) */
	struct radeon_state_atom rb3d_discard_src_pixel_lte_threshold;	/* (4E88) I saw it only written on RV350 hardware..  */
	struct radeon_state_atom zs;	/* zstencil control (4F00) */
	struct radeon_state_atom zsb;	/* zstencil bf */
	struct radeon_state_atom zstencil_format;
	struct radeon_state_atom zb;	/* z buffer (4F20) */
	struct radeon_state_atom zb_depthclearvalue;	/* (4F28) */
	struct radeon_state_atom zb_zmask;	/* (4F30) */
	struct radeon_state_atom zb_hiz_offset;	/* (4F44) */
	struct radeon_state_atom zb_hiz_pitch;	/* (4F54) */

	struct radeon_state_atom vpi;	/* vp instructions */
	struct radeon_state_atom vpp;	/* vp parameters */
	struct radeon_state_atom vps;	/* vertex point size (?) */
	struct radeon_state_atom vpucp[6];	/* vp user clip plane - 6 */
d517 8
a524 8
		struct radeon_state_atom filter;
		struct radeon_state_atom filter_1;
		struct radeon_state_atom size;
		struct radeon_state_atom format;
		struct radeon_state_atom pitch;
		struct radeon_state_atom offset;
		struct radeon_state_atom chroma_key;
		struct radeon_state_atom border_color;
d526 15
a540 2
	struct radeon_state_atom txe;	/* tex enable (4104) */
	radeonTexObj *textures[R300_MAX_TEXTURE_UNITS];
d547 10
d559 56
a614 4
#define COLOR_IS_RGBA
#define TAG(x) r300##x
#include "tnl_dd/t_dd_vertex.h"
#undef TAG
d617 2
a618 3
	GLbitfield FpReads;
	GLuint FogAttr;
	GLuint WPosAttr;
a621 1
	struct gl_vertex_program *Base;
d623 2
d626 1
a626 2
	struct r300_vertex_program_key key;
	struct r300_vertex_program_code code;
d628 8
a635 1
	GLboolean error;
d639 2
a640 6
	/* This is the unmodified vertex program mesa provided us with.
	 * We need to keep it unchanged because we may need to create another
	 * hw specific vertex program based on this.
	 */
	struct gl_vertex_program mesa_program;
	/* This is the list of hw specific vertex programs derived from mesa_program */
d644 39
d685 47
a731 3
* Store everything about a fragment program that is needed
* to render with that program.
*/
d733 4
d738 1
a738 2
	struct r300_fragment_program *next;
	struct r300_fragment_program_external_state state;
d740 13
a752 2
	struct rX00_fragment_program_code code;
	GLbitfield InputsRead;
d754 21
a774 10
	/* attribute that we are sending the WPOS in */
	gl_frag_attrib wpos_attr;
	/* attribute that we are sending the fog coordinate in */
	gl_frag_attrib fog_attr;
};

struct r300_fragment_program_cont {
	/* This is the unmodified fragment program mesa provided us with.
	 * We need to keep it unchanged because we may need to create another
	 * hw specific fragment program based on this.
d776 6
a781 3
	struct gl_fragment_program Base;
	/* This is the list of hw specific fragment programs derived from Base */
	struct r300_fragment_program *progs;
d784 42
d827 2
a828 1
#define R300_MAX_AOS_ARRAYS		16
d830 2
d833 5
a837 46
/* r300_swtcl.c
 */
struct r300_swtcl_info {
  /*
    * Offset of the 4UB color data within a hardware (swtcl) vertex.
    */
   GLuint coloroffset;

   /**
    * Offset of the 3UB specular color data within a hardware (swtcl) vertex.
    */
   GLuint specoffset;
};

struct r300_vtable {
	void (* SetupRSUnit)(struct gl_context *ctx);
	void (* SetupFragmentShaderTextures)(struct gl_context *ctx, int *tmu_mappings);
	void (* SetupPixelShader)(struct gl_context *ctx);
};

struct r300_vertex_buffer {
	struct vertex_attribute {
		/* generic */
		GLubyte element;
		GLuint stride;
		GLuint dwords;
		GLubyte size; /* number of components */
		GLboolean is_named_bo;
		struct radeon_bo *bo;
		GLint bo_offset;

		/* hw specific */
		uint32_t data_type:4;
		uint32_t dst_loc:5;
		uint32_t _signed:1;
		uint32_t normalize:1;
		uint32_t swizzle:12;
		uint32_t write_mask:4;
	} attribs[VERT_ATTRIB_MAX];

	GLubyte num_attribs;
};

struct r300_index_buffer {
	struct radeon_bo *bo;
	int bo_offset;
a838 2
	GLboolean is_32bit;
	GLuint count;
d841 3
a850 2
	struct r300_vtable vtbl;

d852 3
a854 1

a855 1
	struct r300_fragment_program *selected_fp;
d859 20
d882 2
a883 18
	struct r300_options {
		uint32_t conformance_mode:1;
		uint32_t hw_tcl_enabled:1;
		uint32_t s3tc_force_enabled:1;
		uint32_t s3tc_force_disabled:1;
		uint32_t stencil_two_side_disabled:1;
	} options;

	struct r300_swtcl_info swtcl;
	struct r300_vertex_buffer vbuf;
	struct r300_index_buffer ind_buf;

	uint32_t fallback;

	struct {
		struct r300_vertex_program_code vp_code;
		struct rX00_fragment_program_code fp_code;
	} blit;
d885 3
a887 1
	DECLARE_RENDERINPUTS(render_inputs_bitset);
d892 3
a894 4
extern void r300DestroyContext(__DRIcontext * driContextPriv);
extern GLboolean r300CreateContext(gl_api api,
				   const struct gl_config * glVisual,
				   __DRIcontext * driContextPriv,
d897 1
d899 8
a906 7

extern void r300InitShaderFunctions(r300ContextPtr r300);

extern void r300InitDraw(struct gl_context *ctx);

#define r300PackFloat32 radeonPackFloat32
#define r300PackFloat24 radeonPackFloat24
@


