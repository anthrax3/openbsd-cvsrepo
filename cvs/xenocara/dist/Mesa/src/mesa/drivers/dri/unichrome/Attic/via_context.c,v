head	1.8;
access;
symbols
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2013.09.05.14.05.52;	author jsg;	state dead;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.26;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.27;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.54.10;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.54.10;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.38;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.30.02;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.43;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge Mesa 9.2.0
@
text
@/*
 * Copyright 1998-2003 VIA Technologies, Inc. All Rights Reserved.
 * Copyright 2001-2003 S3 Graphics, Inc. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sub license,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * VIA, S3 GRAPHICS, AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * \file via_context.c
 * 
 * \author John Sheng (presumably of either VIA Technologies or S3 Graphics)
 * \author Others at VIA Technologies?
 * \author Others at S3 Graphics?
 */

#include "main/glheader.h"
#include "main/context.h"
#include "main/formats.h"
#include "main/simple_list.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"

#include "swrast/swrast.h"
#include "swrast_setup/swrast_setup.h"
#include "tnl/tnl.h"
#include "vbo/vbo.h"

#include "tnl/t_pipeline.h"

#include "drivers/common/driverfuncs.h"

#include "via_screen.h"
#include "via_dri.h"

#include "via_state.h"
#include "via_tex.h"
#include "via_span.h"
#include "via_tris.h"
#include "via_ioctl.h"
#include "via_fb.h"

#include <stdio.h>
#include "main/macros.h"
#include "drirenderbuffer.h"

#define need_GL_ARB_point_parameters
#define need_GL_EXT_fog_coord
#define need_GL_EXT_secondary_color
#include "main/remap_helper.h"

#include "vblank.h"
#include "utils.h"

GLuint VIA_DEBUG = 0;

/**
 * Return various strings for \c glGetString.
 *
 * \sa glGetString
 */
static const GLubyte *viaGetString(struct gl_context *ctx, GLenum name)
{
   static char buffer[128];
   unsigned   offset;


   switch (name) {
   case GL_VENDOR:
      return (GLubyte *)"VIA Technology";

   case GL_RENDERER: {
      static const char * const chipset_names[] = {
	 "UniChrome",
	 "CastleRock (CLE266)",
	 "UniChrome (KM400)",
	 "UniChrome (K8M800)",
	 "UniChrome (PM8x0/CN400)",
      };
      struct via_context *vmesa = VIA_CONTEXT(ctx);
      unsigned id = vmesa->viaScreen->deviceID;

      offset = driGetRendererString( buffer, 
				     chipset_names[(id > VIA_PM800) ? 0 : id],
				     0 );
      return (GLubyte *)buffer;
   }

   default:
      return NULL;
   }
}


/**
 * Calculate a width that satisfies the hardware's alignment requirements.
 * On the Unichrome hardware, each scanline must be aligned to a multiple of
 * 16 pixels.
 *
 * \param width  Minimum buffer width, in pixels.
 * 
 * \returns A pixel width that meets the alignment requirements.
 */
static INLINE unsigned
buffer_align( unsigned width )
{
    return (width + 0x0f) & ~0x0f;
}


static void
viaDeleteRenderbuffer(struct gl_renderbuffer *rb)
{
   /* Don't free() since we're contained in via_context struct. */
}

static GLboolean
viaRenderbufferStorage(struct gl_context *ctx, struct gl_renderbuffer *rb,
                       GLenum internalFormat, GLuint width, GLuint height)
{
   rb->Width = width;
   rb->Height = height;
   rb->InternalFormat = internalFormat;
   return GL_TRUE;
}


static void
viaInitRenderbuffer(struct via_renderbuffer *vrb, GLenum format,
		    __DRIdrawable *dPriv)
{
   const GLuint name = 0;
   struct gl_renderbuffer *rb = & vrb->Base;

   vrb->dPriv = dPriv;
   _mesa_init_renderbuffer(rb, name);

   /* Make sure we're using a null-valued GetPointer routine */
   assert(rb->GetPointer(NULL, rb, 0, 0) == NULL);

   rb->InternalFormat = format;

   if (format == GL_RGBA) {
      /* Color */
      rb->_BaseFormat = GL_RGBA;
      rb->Format = MESA_FORMAT_ARGB8888;
      rb->DataType = GL_UNSIGNED_BYTE;
   }
   else if (format == GL_DEPTH_COMPONENT16) {
      /* Depth */
      rb->_BaseFormat = GL_DEPTH_COMPONENT;
      /* we always Get/Put 32-bit Z values */
      rb->Format = MESA_FORMAT_Z16;
      rb->DataType = GL_UNSIGNED_INT;
   }
   else if (format == GL_DEPTH_COMPONENT24) {
      /* Depth */
      rb->_BaseFormat = GL_DEPTH_COMPONENT;
      /* we always Get/Put 32-bit Z values */
      rb->Format = MESA_FORMAT_Z32;
      rb->DataType = GL_UNSIGNED_INT;
   }
   else {
      /* Stencil */
      ASSERT(format == GL_STENCIL_INDEX8_EXT);
      rb->_BaseFormat = GL_STENCIL_INDEX;
      rb->Format = MESA_FORMAT_S8;
      rb->DataType = GL_UNSIGNED_BYTE;
   }

   rb->Delete = viaDeleteRenderbuffer;
   rb->AllocStorage = viaRenderbufferStorage;
}


/**
 * Calculate the framebuffer parameters for all buffers (front, back, depth,
 * and stencil) associated with the specified context.
 * 
 * \warning
 * This function also calls \c AllocateBuffer to actually allocate the
 * buffers.
 * 
 * \sa AllocateBuffer
 */
static GLboolean
calculate_buffer_parameters(struct via_context *vmesa,
			    struct gl_framebuffer *fb,
			    __DRIdrawable *dPriv)
{
   const unsigned shift = vmesa->viaScreen->bitsPerPixel / 16;
   const unsigned extra = 32;
   unsigned w;
   unsigned h;

   /* Normally, the renderbuffer would be added to the framebuffer just once
    * when the framebuffer was created.  The VIA driver is a bit funny
    * though in that the front/back/depth renderbuffers are in the per-context
    * state!
    * That should be fixed someday.
    */

   if (!vmesa->front.Base.InternalFormat) {
      /* do one-time init for the renderbuffers */
      viaInitRenderbuffer(&vmesa->front, GL_RGBA, dPriv);
      viaSetSpanFunctions(&vmesa->front, &fb->Visual);
      _mesa_add_renderbuffer(fb, BUFFER_FRONT_LEFT, &vmesa->front.Base);

      if (fb->Visual.doubleBufferMode) {
         viaInitRenderbuffer(&vmesa->back, GL_RGBA, dPriv);
         viaSetSpanFunctions(&vmesa->back, &fb->Visual);
         _mesa_add_renderbuffer(fb, BUFFER_BACK_LEFT, &vmesa->back.Base);
      }

      if (vmesa->glCtx->Visual.depthBits > 0) {
         viaInitRenderbuffer(&vmesa->depth,
                             (vmesa->glCtx->Visual.depthBits == 16
                              ? GL_DEPTH_COMPONENT16 : GL_DEPTH_COMPONENT24),
			     dPriv);
         viaSetSpanFunctions(&vmesa->depth, &fb->Visual);
         _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &vmesa->depth.Base);
      }

      if (vmesa->glCtx->Visual.stencilBits > 0) {
         viaInitRenderbuffer(&vmesa->stencil, GL_STENCIL_INDEX8_EXT,
			     dPriv);
         viaSetSpanFunctions(&vmesa->stencil, &fb->Visual);
         _mesa_add_renderbuffer(fb, BUFFER_STENCIL, &vmesa->stencil.Base);
      }
   }

   assert(vmesa->front.Base.InternalFormat);
   assert(vmesa->front.Base.AllocStorage);
   if (fb->Visual.doubleBufferMode) {
      assert(vmesa->back.Base.AllocStorage);
   }
   if (fb->Visual.depthBits) {
      assert(vmesa->depth.Base.AllocStorage);
   }


   /* Allocate front-buffer */
   if (vmesa->drawType == GLX_PBUFFER_BIT) {
      w = vmesa->driDrawable->w;
      h = vmesa->driDrawable->h;

      vmesa->front.bpp = vmesa->viaScreen->bitsPerPixel;
      vmesa->front.pitch = buffer_align( w ) << shift; /* bytes, not pixels */
      vmesa->front.size = vmesa->front.pitch * h;

      if (vmesa->front.map)
	 via_free_draw_buffer(vmesa, &vmesa->front);
      if (!via_alloc_draw_buffer(vmesa, &vmesa->front))
	 return GL_FALSE;

   } else {
      w = vmesa->viaScreen->width;
      h = vmesa->viaScreen->height;

      vmesa->front.bpp = vmesa->viaScreen->bitsPerPixel;
      vmesa->front.pitch = buffer_align( w ) << shift; /* bytes, not pixels */
      vmesa->front.size = vmesa->front.pitch * h;
      if (getenv("ALTERNATE_SCREEN")) 
        vmesa->front.offset = vmesa->front.size;
      else
      	vmesa->front.offset = 0;
      vmesa->front.map = (char *) vmesa->driScreen->pFB;
   }


   /* Allocate back-buffer */
   if (vmesa->hasBack) {
      vmesa->back.bpp = vmesa->viaScreen->bitsPerPixel;
      vmesa->back.pitch = (buffer_align( vmesa->driDrawable->w ) << shift);
      vmesa->back.pitch += extra;
      vmesa->back.pitch = MIN2(vmesa->back.pitch, vmesa->front.pitch);
      vmesa->back.size = vmesa->back.pitch * vmesa->driDrawable->h;
      if (vmesa->back.map)
	 via_free_draw_buffer(vmesa, &vmesa->back);
      if (!via_alloc_draw_buffer(vmesa, &vmesa->back))
	 return GL_FALSE;
   }
   else {
      if (vmesa->back.map)
	 via_free_draw_buffer(vmesa, &vmesa->back);
      (void) memset( &vmesa->back, 0, sizeof( vmesa->back ) );
   }


   /* Allocate depth-buffer */
   if ( vmesa->hasStencil || vmesa->hasDepth ) {
      vmesa->depth.bpp = vmesa->depthBits;
      if (vmesa->depth.bpp == 24)
	 vmesa->depth.bpp = 32;

      vmesa->depth.pitch = (buffer_align( vmesa->driDrawable->w ) * 
			    (vmesa->depth.bpp/8)) + extra;
      vmesa->depth.size = vmesa->depth.pitch * vmesa->driDrawable->h;

      if (vmesa->depth.map)
	 via_free_draw_buffer(vmesa, &vmesa->depth);
      if (!via_alloc_draw_buffer(vmesa, &vmesa->depth)) {
	 return GL_FALSE;
      }
   }
   else {
      if (vmesa->depth.map)
   	 via_free_draw_buffer(vmesa, &vmesa->depth);
      (void) memset( & vmesa->depth, 0, sizeof( vmesa->depth ) );
   }

   /* stencil buffer is same as depth buffer */
   vmesa->stencil.handle = vmesa->depth.handle;
   vmesa->stencil.size = vmesa->depth.size;
   vmesa->stencil.offset = vmesa->depth.offset;
   vmesa->stencil.index = vmesa->depth.index;
   vmesa->stencil.pitch = vmesa->depth.pitch;
   vmesa->stencil.bpp = vmesa->depth.bpp;
   vmesa->stencil.map = vmesa->depth.map;
   vmesa->stencil.orig = vmesa->depth.orig;
   vmesa->stencil.origMap = vmesa->depth.origMap;

   if( vmesa->viaScreen->width == vmesa->driDrawable->w && 
       vmesa->viaScreen->height == vmesa->driDrawable->h ) {
      vmesa->doPageFlip = vmesa->allowPageFlip;
      if (vmesa->hasBack) {
         assert(vmesa->back.pitch == vmesa->front.pitch);
      }
   }
   else
      vmesa->doPageFlip = GL_FALSE;

   return GL_TRUE;
}


void viaReAllocateBuffers(struct gl_context *ctx, struct gl_framebuffer *drawbuffer,
                          GLuint width, GLuint height)
{
    struct via_context *vmesa = VIA_CONTEXT(ctx);

    calculate_buffer_parameters(vmesa, drawbuffer, vmesa->driDrawable);

    _mesa_resize_framebuffer(ctx, drawbuffer, width, height);
}

/* Extension strings exported by the Unichrome driver.
 */
static const struct dri_extension card_extensions[] =
{
    { "GL_ARB_multitexture",               NULL },
    { "GL_ARB_point_parameters",           GL_ARB_point_parameters_functions },
    { "GL_ARB_texture_env_add",            NULL },
    { "GL_ARB_texture_env_combine",        NULL },
/*    { "GL_ARB_texture_env_dot3",           NULL }, */
    { "GL_ARB_texture_mirrored_repeat",    NULL },
    { "GL_EXT_fog_coord",                  GL_EXT_fog_coord_functions },
    { "GL_EXT_secondary_color",            GL_EXT_secondary_color_functions },
    { "GL_EXT_stencil_wrap",               NULL },
    { "GL_EXT_texture_env_combine",        NULL },
/*    { "GL_EXT_texture_env_dot3",           NULL }, */
    { "GL_EXT_texture_lod_bias",           NULL },
    { "GL_NV_blend_square",                NULL },
    { NULL,                                NULL }
};

extern const struct tnl_pipeline_stage _via_fastrender_stage;
extern const struct tnl_pipeline_stage _via_render_stage;

static const struct tnl_pipeline_stage *via_pipeline[] = {
    &_tnl_vertex_transform_stage,
    &_tnl_normal_transform_stage,
    &_tnl_lighting_stage,
    &_tnl_fog_coordinate_stage,
    &_tnl_texgen_stage,
    &_tnl_texture_transform_stage,
    /* REMOVE: point attenuation stage */
#if 1
    &_via_fastrender_stage,     /* ADD: unclipped rastersetup-to-dma */
#endif
    &_tnl_render_stage,
    0,
};


static const struct dri_debug_control debug_control[] =
{
    { "fall",  DEBUG_FALLBACKS },
    { "tex",   DEBUG_TEXTURE },
    { "ioctl", DEBUG_IOCTL },
    { "prim",  DEBUG_PRIMS },
    { "vert",  DEBUG_VERTS },
    { "state", DEBUG_STATE },
    { "verb",  DEBUG_VERBOSE },
    { "dri",   DEBUG_DRI },
    { "dma",   DEBUG_DMA },
    { "san",   DEBUG_SANITY },
    { "sync",  DEBUG_SYNC },
    { "sleep", DEBUG_SLEEP },
    { "pix",   DEBUG_PIXEL },
    { "2d",    DEBUG_2D },
    { NULL,    0 }
};


static GLboolean
AllocateDmaBuffer(struct via_context *vmesa)
{
    if (vmesa->dma)
        via_free_dma_buffer(vmesa);
    
    if (!via_alloc_dma_buffer(vmesa))
        return GL_FALSE;

    vmesa->dmaLow = 0;
    vmesa->dmaCliprectAddr = ~0;
    return GL_TRUE;
}

static void
FreeBuffer(struct via_context *vmesa)
{
    if (vmesa->front.map && vmesa->drawType == GLX_PBUFFER_BIT)
	via_free_draw_buffer(vmesa, &vmesa->front);

    if (vmesa->back.map)
        via_free_draw_buffer(vmesa, &vmesa->back);

    if (vmesa->depth.map)
        via_free_draw_buffer(vmesa, &vmesa->depth);

    if (vmesa->breadcrumb.map)
        via_free_draw_buffer(vmesa, &vmesa->breadcrumb);

    if (vmesa->dma)
        via_free_dma_buffer(vmesa);
}


GLboolean
viaCreateContext(gl_api api,
		 const struct gl_config *visual,
                 __DRIcontext *driContextPriv,
                 void *sharedContextPrivate)
{
    struct gl_context *ctx, *shareCtx;
    struct via_context *vmesa;
    __DRIscreen *sPriv = driContextPriv->driScreenPriv;
    viaScreenPrivate *viaScreen = (viaScreenPrivate *)sPriv->private;
    drm_via_sarea_t *saPriv = (drm_via_sarea_t *)
        (((GLubyte *)sPriv->pSAREA) + viaScreen->sareaPrivOffset);
    struct dd_function_table functions;

    /* Allocate via context */
    vmesa = (struct via_context *) CALLOC_STRUCT(via_context);
    if (!vmesa) {
        return GL_FALSE;
    }

    /* Parse configuration files.
     */
    driParseConfigFiles (&vmesa->optionCache, &viaScreen->optionCache,
			 sPriv->myNum, "unichrome");

    /* pick back buffer */
    vmesa->hasBack = visual->doubleBufferMode;

    switch(visual->depthBits) {
    case 0:			
       vmesa->hasDepth = GL_FALSE;
       vmesa->depthBits = 0; 
       vmesa->depth_max = 1.0;
       break;
    case 16:
       vmesa->hasDepth = GL_TRUE;
       vmesa->depthBits = visual->depthBits;
       vmesa->have_hw_stencil = GL_FALSE;
       vmesa->depth_max = (GLfloat)0xffff;
       vmesa->depth_clear_mask = 0xf << 28;
       vmesa->ClearDepth = 0xffff;
       vmesa->polygon_offset_scale = 1.0 / vmesa->depth_max;
       break;
    case 24:
       vmesa->hasDepth = GL_TRUE;
       vmesa->depthBits = visual->depthBits;
       vmesa->depth_max = (GLfloat) 0xffffff;
       vmesa->depth_clear_mask = 0xe << 28;
       vmesa->ClearDepth = 0xffffff00;

       assert(visual->haveStencilBuffer);
       assert(visual->stencilBits == 8);

       vmesa->have_hw_stencil = GL_TRUE;
       vmesa->stencilBits = visual->stencilBits;
       vmesa->stencil_clear_mask = 0x1 << 28;
       vmesa->polygon_offset_scale = 2.0 / vmesa->depth_max;
       break;
    case 32:
       vmesa->hasDepth = GL_TRUE;
       vmesa->depthBits = visual->depthBits;
       assert(!visual->haveStencilBuffer);
       vmesa->have_hw_stencil = GL_FALSE;
       vmesa->depth_max = (GLfloat)0xffffffff;
       vmesa->depth_clear_mask = 0xf << 28;
       vmesa->ClearDepth = 0xffffffff;
       vmesa->polygon_offset_scale = 2.0 / vmesa->depth_max;
       break;
    default:
       assert(0); 
       break;
    }

    make_empty_list(&vmesa->freed_tex_buffers);
    make_empty_list(&vmesa->tex_image_list[VIA_MEM_VIDEO]);
    make_empty_list(&vmesa->tex_image_list[VIA_MEM_AGP]);
    make_empty_list(&vmesa->tex_image_list[VIA_MEM_SYSTEM]);

    _mesa_init_driver_functions(&functions);
    viaInitTextureFuncs(&functions);

    /* Allocate the Mesa context */
    if (sharedContextPrivate)
        shareCtx = ((struct via_context *) sharedContextPrivate)->glCtx;
    else
        shareCtx = NULL;

    vmesa->glCtx = _mesa_create_context(API_OPENGL, visual, shareCtx, &functions,
					(void*) vmesa);
    
    vmesa->shareCtx = shareCtx;
    
    if (!vmesa->glCtx) {
        FREE(vmesa);
        return GL_FALSE;
    }
    driContextPriv->driverPrivate = vmesa;

    ctx = vmesa->glCtx;

    if (driQueryOptionb(&vmesa->optionCache, "excess_mipmap"))
        ctx->Const.MaxTextureLevels = 11;
    else
        ctx->Const.MaxTextureLevels = 10;

    ctx->Const.MaxTextureUnits = 2;
    ctx->Const.MaxTextureImageUnits = ctx->Const.MaxTextureUnits;
    ctx->Const.MaxTextureCoordUnits = ctx->Const.MaxTextureUnits;

    ctx->Const.MinLineWidth = 1.0;
    ctx->Const.MinLineWidthAA = 1.0;
    ctx->Const.MaxLineWidth = 1.0;
    ctx->Const.MaxLineWidthAA = 1.0;
    ctx->Const.LineWidthGranularity = 1.0;

    ctx->Const.MinPointSize = 1.0;
    ctx->Const.MinPointSizeAA = 1.0;
    ctx->Const.MaxPointSize = 1.0;
    ctx->Const.MaxPointSizeAA = 1.0;
    ctx->Const.PointSizeGranularity = 1.0;

    ctx->Const.MaxDrawBuffers = 1;

    ctx->Driver.GetString = viaGetString;

    ctx->DriverCtx = (void *)vmesa;
    vmesa->glCtx = ctx;

    /* Initialize the software rasterizer and helper modules.
     */
    _swrast_CreateContext(ctx);
    _vbo_CreateContext(ctx);
    _tnl_CreateContext(ctx);
    _swsetup_CreateContext(ctx);

    /* Install the customized pipeline:
     */
    _tnl_destroy_pipeline(ctx);
    _tnl_install_pipeline(ctx, via_pipeline);

    /* Configure swrast and T&L to match hardware characteristics:
     */
    _swrast_allow_pixel_fog(ctx, GL_FALSE);
    _swrast_allow_vertex_fog(ctx, GL_TRUE);
    _tnl_allow_pixel_fog(ctx, GL_FALSE);
    _tnl_allow_vertex_fog(ctx, GL_TRUE);

    vmesa->hHWContext = driContextPriv->hHWContext;
    vmesa->driFd = sPriv->fd;
    vmesa->driHwLock = &sPriv->pSAREA->lock;

    vmesa->viaScreen = viaScreen;
    vmesa->driScreen = sPriv;
    vmesa->sarea = saPriv;

    vmesa->renderIndex = ~0;
    vmesa->setupIndex = ~0;
    vmesa->hwPrimitive = GL_POLYGON+1;

    /* KW: Hardwire this.  Was previously set bogusly in
     * viaCreateBuffer.  Needs work before PBUFFER can be used:
     */
    vmesa->drawType = GLX_WINDOW_BIT;


    _math_matrix_ctr(&vmesa->ViewportMatrix);

    /* Do this early, before VIA_FLUSH_DMA can be called:
     */
    if (!AllocateDmaBuffer(vmesa)) {
	fprintf(stderr ,"AllocateDmaBuffer fail\n");
	FreeBuffer(vmesa);
        FREE(vmesa);
        return GL_FALSE;
    }

    /* Allocate a small piece of fb memory for synchronization:
     */
    vmesa->breadcrumb.bpp = 32;
    vmesa->breadcrumb.pitch = buffer_align( 64 ) << 2;
    vmesa->breadcrumb.size = vmesa->breadcrumb.pitch;

    if (!via_alloc_draw_buffer(vmesa, &vmesa->breadcrumb)) {
        fprintf(stderr ,"AllocateDmaBuffer fail\n");
        FreeBuffer(vmesa);
        FREE(vmesa);
        return GL_FALSE;
    }

    driInitExtensions( ctx, card_extensions, GL_TRUE );
    viaInitStateFuncs(ctx);
    viaInitTriFuncs(ctx);
    viaInitSpanFuncs(ctx);
    viaInitIoctlFuncs(ctx);
    viaInitState(ctx);
        
    if (getenv("VIA_DEBUG"))
       VIA_DEBUG = driParseDebugString( getenv( "VIA_DEBUG" ),
					debug_control );

    if (getenv("VIA_NO_RAST") ||
        driQueryOptionb(&vmesa->optionCache, "no_rast"))
       FALLBACK(vmesa, VIA_FALLBACK_USER_DISABLE, 1);

    if (getenv("VIA_PAGEFLIP"))
       vmesa->allowPageFlip = 1;

    (*sPriv->systemTime->getUST)( &vmesa->swap_ust );


    vmesa->regMMIOBase = (GLuint *)((unsigned long)viaScreen->reg);
    vmesa->pnGEMode = (GLuint *)((unsigned long)viaScreen->reg + 0x4);
    vmesa->regEngineStatus = (GLuint *)((unsigned long)viaScreen->reg + 0x400);
    vmesa->regTranSet = (GLuint *)((unsigned long)viaScreen->reg + 0x43C);
    vmesa->regTranSpace = (GLuint *)((unsigned long)viaScreen->reg + 0x440);
    vmesa->agpBase = viaScreen->agpBase;


    return GL_TRUE;
}

void
viaDestroyContext(__DRIcontext *driContextPriv)
{
    GET_CURRENT_CONTEXT(ctx);
    struct via_context *vmesa =
       (struct via_context *)driContextPriv->driverPrivate;
    struct via_context *current = ctx ? VIA_CONTEXT(ctx) : NULL;

    assert(vmesa); /* should never be null */

    if (vmesa->driDrawable) {
       viaWaitIdle(vmesa, GL_FALSE);

       if (vmesa->doPageFlip) {
	  LOCK_HARDWARE(vmesa);
	  if (vmesa->pfCurrentOffset != 0) {
	     fprintf(stderr, "%s - reset pf\n", __FUNCTION__);
	     viaResetPageFlippingLocked(vmesa);
	  }
	  UNLOCK_HARDWARE(vmesa);
       }
    }

    /* check if we're deleting the currently bound context */
    if (vmesa == current) {
      VIA_FLUSH_DMA(vmesa);
      _mesa_make_current(NULL, NULL, NULL);
    }

    _swsetup_DestroyContext(vmesa->glCtx);
    _tnl_DestroyContext(vmesa->glCtx);
    _vbo_DestroyContext(vmesa->glCtx);
    _swrast_DestroyContext(vmesa->glCtx);
    /* free the Mesa context */
    _mesa_destroy_context(vmesa->glCtx);
    /* release our data */
    FreeBuffer(vmesa);

    assert (is_empty_list(&vmesa->tex_image_list[VIA_MEM_AGP]));
    assert (is_empty_list(&vmesa->tex_image_list[VIA_MEM_VIDEO]));
    assert (is_empty_list(&vmesa->tex_image_list[VIA_MEM_SYSTEM]));
    assert (is_empty_list(&vmesa->freed_tex_buffers));

    driDestroyOptionCache(&vmesa->optionCache);

    FREE(vmesa);
}


void viaXMesaWindowMoved(struct via_context *vmesa)
{
   __DRIdrawable *const drawable = vmesa->driDrawable;
   __DRIdrawable *const readable = vmesa->driReadable;
   struct via_renderbuffer * draw_buffer;
   struct via_renderbuffer * read_buffer;
   GLuint bytePerPixel = vmesa->viaScreen->bitsPerPixel >> 3;

   if (!drawable)
      return;

   draw_buffer =  (struct via_renderbuffer *) drawable->driverPrivate;
   read_buffer =  (struct via_renderbuffer *) readable->driverPrivate;
   
   switch (vmesa->glCtx->DrawBuffer->_ColorDrawBufferIndexes[0]) {
   case BUFFER_BACK_LEFT: 
      if (drawable->numBackClipRects == 0) {
	 vmesa->numClipRects = drawable->numClipRects;
	 vmesa->pClipRects = drawable->pClipRects;
      } 
      else {
	 vmesa->numClipRects = drawable->numBackClipRects;
	 vmesa->pClipRects = drawable->pBackClipRects;
      }
      break;
   case BUFFER_FRONT_LEFT:
      vmesa->numClipRects = drawable->numClipRects;
      vmesa->pClipRects = drawable->pClipRects;
      break;
   default:
      vmesa->numClipRects = 0;
      break;
   }

   if ((draw_buffer->drawW != drawable->w) 
       || (draw_buffer->drawH != drawable->h)) {
      calculate_buffer_parameters(vmesa, vmesa->glCtx->DrawBuffer,
				  drawable);
   }

   draw_buffer->drawX = drawable->x;
   draw_buffer->drawY = drawable->y;
   draw_buffer->drawW = drawable->w;
   draw_buffer->drawH = drawable->h;

   if (drawable != readable) {
      if ((read_buffer->drawW != readable->w) 
	  || (read_buffer->drawH != readable->h)) {
	 calculate_buffer_parameters(vmesa, vmesa->glCtx->ReadBuffer,
				     readable);
      }

      read_buffer->drawX = readable->x;
      read_buffer->drawY = readable->y;
      read_buffer->drawW = readable->w;
      read_buffer->drawH = readable->h;
   }

   vmesa->front.orig = (vmesa->front.offset + 
			draw_buffer->drawY * vmesa->front.pitch + 
			draw_buffer->drawX * bytePerPixel);

   vmesa->front.origMap = (vmesa->front.map + 
			draw_buffer->drawY * vmesa->front.pitch + 
			draw_buffer->drawX * bytePerPixel);

   vmesa->back.orig = (vmesa->back.offset +
			draw_buffer->drawY * vmesa->back.pitch +
			draw_buffer->drawX * bytePerPixel);

   vmesa->back.origMap = (vmesa->back.map +
			draw_buffer->drawY * vmesa->back.pitch +
			draw_buffer->drawX * bytePerPixel);

   vmesa->depth.orig = (vmesa->depth.offset +
			draw_buffer->drawY * vmesa->depth.pitch +
			draw_buffer->drawX * bytePerPixel);   

   vmesa->depth.origMap = (vmesa->depth.map +
			draw_buffer->drawY * vmesa->depth.pitch +
			draw_buffer->drawX * bytePerPixel);

   viaCalcViewport(vmesa->glCtx);
}

GLboolean
viaUnbindContext(__DRIcontext *driContextPriv)
{
    return GL_TRUE;
}

GLboolean
viaMakeCurrent(__DRIcontext *driContextPriv,
               __DRIdrawable *driDrawPriv,
               __DRIdrawable *driReadPriv)
{
    if (VIA_DEBUG & DEBUG_DRI) {
	fprintf(stderr, "driContextPriv = %016lx\n", (unsigned long)driContextPriv);
	fprintf(stderr, "driDrawPriv = %016lx\n", (unsigned long)driDrawPriv);    
	fprintf(stderr, "driReadPriv = %016lx\n", (unsigned long)driReadPriv);
    }	

    if (driContextPriv) {
        struct via_context *vmesa = 
	   (struct via_context *)driContextPriv->driverPrivate;
	struct gl_context *ctx = vmesa->glCtx;
        struct gl_framebuffer *drawBuffer, *readBuffer;

        drawBuffer = (struct gl_framebuffer *)driDrawPriv->driverPrivate;
        readBuffer = (struct gl_framebuffer *)driReadPriv->driverPrivate;

       if ((vmesa->driDrawable != driDrawPriv)
	   || (vmesa->driReadable != driReadPriv)) {
	  if (driDrawPriv->swap_interval == (unsigned)-1) {
	     driDrawPriv->vblFlags =
		vmesa->viaScreen->irqEnabled ?
		driGetDefaultVBlankFlags(&vmesa->optionCache) :
		VBLANK_FLAG_NO_IRQ;

	     driDrawableInitVBlank(driDrawPriv);
	  }

	  vmesa->driDrawable = driDrawPriv;
	  vmesa->driReadable = driReadPriv;

	  if ((drawBuffer->Width != driDrawPriv->w) 
	      || (drawBuffer->Height != driDrawPriv->h)) {
	     _mesa_resize_framebuffer(ctx, drawBuffer,
				      driDrawPriv->w, driDrawPriv->h);
	     drawBuffer->Initialized = GL_TRUE;
	  }

	  if (!calculate_buffer_parameters(vmesa, drawBuffer, driDrawPriv)) {
	     return GL_FALSE;
	  }

	  if (driDrawPriv != driReadPriv) {
	     if ((readBuffer->Width != driReadPriv->w)
		 || (readBuffer->Height != driReadPriv->h)) {
		_mesa_resize_framebuffer(ctx, readBuffer,
					 driReadPriv->w, driReadPriv->h);
		readBuffer->Initialized = GL_TRUE;
	     }

	     if (!calculate_buffer_parameters(vmesa, readBuffer, driReadPriv)) {
		return GL_FALSE;
	     }
	  }
       }

        _mesa_make_current(vmesa->glCtx, drawBuffer, readBuffer);

	ctx->Driver.DrawBuffer( ctx, ctx->Color.DrawBuffer[0] );
	   
        viaXMesaWindowMoved(vmesa);
	ctx->Driver.Scissor(vmesa->glCtx,
			    vmesa->glCtx->Scissor.X,
			    vmesa->glCtx->Scissor.Y,
			    vmesa->glCtx->Scissor.Width,
			    vmesa->glCtx->Scissor.Height);
    }
    else {
        _mesa_make_current(NULL, NULL, NULL);
    }
        
    return GL_TRUE;
}

void viaGetLock(struct via_context *vmesa, GLuint flags)
{
    __DRIdrawable *dPriv = vmesa->driDrawable;
    __DRIscreen *sPriv = vmesa->driScreen;

    drmGetLock(vmesa->driFd, vmesa->hHWContext, flags);

    DRI_VALIDATE_DRAWABLE_INFO(sPriv, dPriv);
    if (dPriv != vmesa->driReadable) {
	DRI_VALIDATE_DRAWABLE_INFO(sPriv, vmesa->driReadable);
    }

    if (vmesa->sarea->ctxOwner != vmesa->hHWContext) {
       vmesa->sarea->ctxOwner = vmesa->hHWContext;
       vmesa->newEmitState = ~0;
    }

    if (vmesa->lastStamp != dPriv->lastStamp) {
       viaXMesaWindowMoved(vmesa);
       driUpdateFramebufferSize(vmesa->glCtx, dPriv);
       vmesa->newEmitState = ~0;
       vmesa->lastStamp = dPriv->lastStamp;
    }

    if (vmesa->doPageFlip &&
	vmesa->pfCurrentOffset != vmesa->sarea->pfCurrentOffset) {
       fprintf(stderr, "%s - reset pf\n", __FUNCTION__);
       viaResetPageFlippingLocked(vmesa);
    }
}


void
viaSwapBuffers(__DRIdrawable *drawablePrivate)
{
    __DRIdrawable *dPriv = (__DRIdrawable *)drawablePrivate;

    if (dPriv && 
	dPriv->driContextPriv && 
	dPriv->driContextPriv->driverPrivate) {
        struct via_context *vmesa = 
	   (struct via_context *)dPriv->driContextPriv->driverPrivate;
        struct gl_context *ctx = vmesa->glCtx;

	_mesa_notifySwapBuffers(ctx);

        if (ctx->Visual.doubleBufferMode) {
            if (vmesa->doPageFlip) {
                viaPageFlip(dPriv);
            }
            else {
                viaCopyBuffer(dPriv);
            }
        }
	else
	    VIA_FLUSH_DMA(vmesa);
    }
    else {
        _mesa_problem(NULL, "viaSwapBuffers: drawable has no context!\n");
    }
}
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.6
log
@Merge Mesa 7.10.3
@
text
@a67 2
#define DRIVER_DATE	"20060710"

d101 1
a101 1
				     DRIVER_DATE, 0 );
d543 1
a543 1
    vmesa->glCtx = _mesa_create_context(visual, shareCtx, &functions,
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d80 1
a80 1
static const GLubyte *viaGetString(GLcontext *ctx, GLenum name)
d136 1
a136 1
viaRenderbufferStorage(GLcontext *ctx, struct gl_renderbuffer *rb,
d355 1
a355 1
void viaReAllocateBuffers(GLcontext *ctx, GLframebuffer *drawbuffer,
d459 2
a460 1
viaCreateContext(const __GLcontextModes *visual,
d464 1
a464 1
    GLcontext *ctx, *shareCtx;
d833 1
a833 1
	GLcontext *ctx = vmesa->glCtx;
d836 2
a837 2
        drawBuffer = (GLframebuffer *)driDrawPriv->driverPrivate;
        readBuffer = (GLframebuffer *)driReadPriv->driverPrivate;
d938 1
a938 1
        GLcontext *ctx = vmesa->glCtx;
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d35 1
a35 2
#include "main/matrix.h"
#include "main/state.h"
a36 1
#include "main/extensions.h"
a62 1
#define need_GL_ARB_multisample
a63 1
#define need_GL_ARB_vertex_buffer_object
d66 1
a66 1
#include "extension_helper.h"
d148 1
a148 1
		    __DRIdrawablePrivate *dPriv)
d164 1
d171 1
d178 1
d185 1
d207 1
a207 1
			    __DRIdrawablePrivate *dPriv)
d367 1
a367 1
const struct dri_extension card_extensions[] =
a368 1
    { "GL_ARB_multisample",                GL_ARB_multisample_functions },
a374 1
    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
d460 1
a460 1
                 __DRIcontextPrivate *driContextPriv,
d465 1
a465 1
    __DRIscreenPrivate *sPriv = driContextPriv->driScreenPriv;
d578 2
d679 1
a679 1
viaDestroyContext(__DRIcontextPrivate *driContextPriv)
d729 2
a730 2
   __DRIdrawablePrivate *const drawable = vmesa->driDrawable;
   __DRIdrawablePrivate *const readable = vmesa->driReadable;
d813 1
a813 1
viaUnbindContext(__DRIcontextPrivate *driContextPriv)
d819 3
a821 3
viaMakeCurrent(__DRIcontextPrivate *driContextPriv,
               __DRIdrawablePrivate *driDrawPriv,
               __DRIdrawablePrivate *driReadPriv)
d897 2
a898 2
    __DRIdrawablePrivate *dPriv = vmesa->driDrawable;
    __DRIscreenPrivate *sPriv = vmesa->driScreen;
d928 1
a928 1
viaSwapBuffers(__DRIdrawablePrivate *drawablePrivate)
d930 1
a930 1
    __DRIdrawablePrivate *dPriv = (__DRIdrawablePrivate *)drawablePrivate;
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d33 8
a40 8
#include "glheader.h"
#include "context.h"
#include "matrix.h"
#include "state.h"
#include "simple_list.h"
#include "extensions.h"
#include "framebuffer.h"
#include "renderbuffer.h"
d62 1
a62 1
#include "macros.h"
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d126 1
a126 1
static __inline__ unsigned
a603 3
/*     vmesa->display = dpy; */
    vmesa->display = sPriv->display;
    
a660 4
    vmesa->vblank_flags =
       vmesa->viaScreen->irqEnabled ?
        driGetDefaultVBlankFlags(&vmesa->optionCache) : VBLANK_FLAG_NO_IRQ;

d664 1
a664 1
    (*dri_interface->getUST)( &vmesa->swap_ust );
d682 1
a682 1
    struct via_context *vmesa = 
d685 1
d688 13
d707 13
a719 24
    if (vmesa) {
        viaWaitIdle(vmesa, GL_FALSE);
	if (vmesa->doPageFlip) {
	   LOCK_HARDWARE(vmesa);
	   if (vmesa->pfCurrentOffset != 0) {
	      fprintf(stderr, "%s - reset pf\n", __FUNCTION__);
	      viaResetPageFlippingLocked(vmesa);
	   }
	   UNLOCK_HARDWARE(vmesa);
	}
	
	_swsetup_DestroyContext(vmesa->glCtx);
        _tnl_DestroyContext(vmesa->glCtx);
        _vbo_DestroyContext(vmesa->glCtx);
        _swrast_DestroyContext(vmesa->glCtx);
        /* free the Mesa context */
	_mesa_destroy_context(vmesa->glCtx);
	/* release our data */
	FreeBuffer(vmesa);

	assert (is_empty_list(&vmesa->tex_image_list[VIA_MEM_AGP]));
	assert (is_empty_list(&vmesa->tex_image_list[VIA_MEM_VIDEO]));
	assert (is_empty_list(&vmesa->tex_image_list[VIA_MEM_SYSTEM]));
	assert (is_empty_list(&vmesa->freed_tex_buffers));
d721 1
a721 1
	driDestroyOptionCache(&vmesa->optionCache);
d723 1
a723 2
	FREE(vmesa);
    }
d741 2
a742 2
   switch (vmesa->glCtx->DrawBuffer->_ColorDrawBufferMask[0]) {
   case BUFFER_BIT_BACK_LEFT: 
d752 1
a752 1
   case BUFFER_BIT_FRONT_LEFT:
a837 5
	if (vmesa->driDrawable != driDrawPriv) {
	   driDrawableInitVBlank(driDrawPriv, vmesa->vblank_flags,
				 &vmesa->vbl_seq);
	}

d840 9
@


1.1
log
@Initial revision
@
text
@d45 1
a45 1
#include "array_cache/acache.h"
d67 1
d151 2
a152 1
viaInitRenderbuffer(struct gl_renderbuffer *rb, GLenum format)
d155 1
d157 1
d205 3
a207 2
calculate_buffer_parameters( struct via_context *vmesa,
                             struct gl_framebuffer *fb )
d223 1
a223 1
      viaInitRenderbuffer(&vmesa->front.Base, GL_RGBA);
d228 1
a228 1
         viaInitRenderbuffer(&vmesa->back.Base, GL_RGBA);
d234 1
a234 1
         viaInitRenderbuffer(&vmesa->depth.Base, 
d236 2
a237 1
                              ? GL_DEPTH_COMPONENT16 : GL_DEPTH_COMPONENT24));
d243 2
a244 1
         viaInitRenderbuffer(&vmesa->stencil.Base, GL_STENCIL_INDEX8_EXT);
d253 1
a253 2
      assert(fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer);
      assert(vmesa->front.Base.AllocStorage);
a255 1
      assert(fb->Attachment[BUFFER_DEPTH].Renderbuffer);
d360 1
a360 1
    calculate_buffer_parameters( vmesa, drawbuffer );
a364 8
static void viaBufferSize(GLframebuffer *buffer, GLuint *width, GLuint *height)
{
    GET_CURRENT_CONTEXT(ctx);
    struct via_context *vmesa = VIA_CONTEXT(ctx);       
    *width = vmesa->driDrawable->w;
    *height = vmesa->driDrawable->h;
}

d376 1
d482 1
a482 1
			 sPriv->myNum, "via");
d558 6
a563 2
    
    ctx->Const.MaxTextureLevels = 10;    
a579 2
    ctx->Driver.GetBufferSize = viaBufferSize;
/*    ctx->Driver.ResizeBuffers = _swrast_alloc_buffers;  *//* FIXME ?? */
d588 1
a588 1
    _ac_CreateContext(ctx);
d660 2
a661 1
    if (getenv("VIA_NO_RAST"))
a663 2
    /* I don't understand why this isn't working:
     */
a667 5
    /* Hack this up in its place:
     */
    vmesa->vblank_flags = (getenv("VIA_VSYNC") ? 
			   VBLANK_FLAG_SYNC : VBLANK_FLAG_NO_IRQ);

d713 1
a713 1
        _ac_DestroyContext(vmesa->glCtx);
d725 3
a727 1
        FREE(vmesa);
d734 4
a737 1
   __DRIdrawablePrivate *dPriv = vmesa->driDrawable;
d740 1
a740 1
   if (!dPriv)
d742 3
d748 3
a750 3
      if (dPriv->numBackClipRects == 0) {
	 vmesa->numClipRects = dPriv->numClipRects;
	 vmesa->pClipRects = dPriv->pClipRects;
d753 2
a754 2
	 vmesa->numClipRects = dPriv->numBackClipRects;
	 vmesa->pClipRects = dPriv->pBackClipRects;
d758 2
a759 2
      vmesa->numClipRects = dPriv->numClipRects;
      vmesa->pClipRects = dPriv->pClipRects;
d766 23
a788 10
   if (vmesa->drawW != dPriv->w ||
       vmesa->drawH != dPriv->h) 
      calculate_buffer_parameters( vmesa, vmesa->glCtx->DrawBuffer );

   vmesa->drawXoff = (GLuint)(((dPriv->x * bytePerPixel) & 0x1f) / 
			      bytePerPixel);  
   vmesa->drawX = dPriv->x - vmesa->drawXoff;
   vmesa->drawY = dPriv->y;
   vmesa->drawW = dPriv->w;
   vmesa->drawH = dPriv->h;
d791 2
a792 2
			vmesa->drawY * vmesa->front.pitch + 
			vmesa->drawX * bytePerPixel);
d795 2
a796 2
			   vmesa->drawY * vmesa->front.pitch + 
			   vmesa->drawX * bytePerPixel);
d798 15
a812 4
   vmesa->back.orig = vmesa->back.offset;
   vmesa->depth.orig = vmesa->depth.offset;   
   vmesa->back.origMap = vmesa->back.map;
   vmesa->depth.origMap = vmesa->depth.map;
d843 3
a845 6
	if ( vmesa->driDrawable != driDrawPriv ) {
	   driDrawableInitVBlank( driDrawPriv, vmesa->vblank_flags );
	   vmesa->driDrawable = driDrawPriv;
	   if ( ! calculate_buffer_parameters( vmesa, drawBuffer ) ) {
	      return GL_FALSE;
	   }
d848 30
d903 4
a906 1
    DRI_VALIDATE_DRAWABLE_INFO( sPriv, dPriv );
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d150 1
a150 2
viaInitRenderbuffer(struct via_renderbuffer *vrb, GLenum format,
		    __DRIdrawablePrivate *dPriv)
a152 1
   struct gl_renderbuffer *rb = & vrb->Base;
a153 1
   vrb->dPriv = dPriv;
d201 2
a202 3
calculate_buffer_parameters(struct via_context *vmesa,
			    struct gl_framebuffer *fb,
			    __DRIdrawablePrivate *dPriv)
d218 1
a218 1
      viaInitRenderbuffer(&vmesa->front, GL_RGBA, dPriv);
d223 1
a223 1
         viaInitRenderbuffer(&vmesa->back, GL_RGBA, dPriv);
d229 1
a229 1
         viaInitRenderbuffer(&vmesa->depth,
d231 1
a231 2
                              ? GL_DEPTH_COMPONENT16 : GL_DEPTH_COMPONENT24),
			     dPriv);
d237 1
a237 2
         viaInitRenderbuffer(&vmesa->stencil, GL_STENCIL_INDEX8_EXT,
			     dPriv);
d246 2
a247 1
      assert(vmesa->back.Base.AllocStorage);
d250 1
d355 1
a355 1
    calculate_buffer_parameters(vmesa, drawbuffer, vmesa->driDrawable);
d360 8
d484 1
a484 1
			 sPriv->myNum, "unichrome");
d560 2
a561 6

    if (driQueryOptionb(&vmesa->optionCache, "excess_mipmap"))
        ctx->Const.MaxTextureLevels = 11;
    else
        ctx->Const.MaxTextureLevels = 10;

d578 2
d660 1
a660 2
    if (getenv("VIA_NO_RAST") ||
        driQueryOptionb(&vmesa->optionCache, "no_rast"))
d663 2
d669 5
d731 1
a731 3
	driDestroyOptionCache(&vmesa->optionCache);

	FREE(vmesa);
d738 1
a738 6
   __DRIdrawablePrivate *const drawable = vmesa->driDrawable;
   __DRIdrawablePrivate *const readable = vmesa->driReadable;
   struct via_renderbuffer *const draw_buffer = 
     (struct via_renderbuffer *) drawable->driverPrivate;
   struct via_renderbuffer *const read_buffer =
     (struct via_renderbuffer *) readable->driverPrivate;
d741 1
a741 1
   if (!drawable)
d746 3
a748 3
      if (drawable->numBackClipRects == 0) {
	 vmesa->numClipRects = drawable->numClipRects;
	 vmesa->pClipRects = drawable->pClipRects;
d751 2
a752 2
	 vmesa->numClipRects = drawable->numBackClipRects;
	 vmesa->pClipRects = drawable->pBackClipRects;
d756 2
a757 2
      vmesa->numClipRects = drawable->numClipRects;
      vmesa->pClipRects = drawable->pClipRects;
d764 3
a766 5
   if ((draw_buffer->drawW != drawable->w) 
       || (draw_buffer->drawH != drawable->h)) {
      calculate_buffer_parameters(vmesa, vmesa->glCtx->DrawBuffer,
				  drawable);
   }
d768 1
a768 1
   draw_buffer->drawXoff = (GLuint)(((drawable->x * bytePerPixel) & 0x1f) / 
d770 4
a773 19
   draw_buffer->drawX = drawable->x - draw_buffer->drawXoff;
   draw_buffer->drawY = drawable->y;
   draw_buffer->drawW = drawable->w;
   draw_buffer->drawH = drawable->h;

   if (drawable != readable) {
      if ((read_buffer->drawW != readable->w) 
	  || (read_buffer->drawH != readable->h)) {
	 calculate_buffer_parameters(vmesa, vmesa->glCtx->ReadBuffer,
				     readable);
      }

      read_buffer->drawXoff = (GLuint)(((readable->x * bytePerPixel) & 0x1f) / 
				       bytePerPixel);  
      read_buffer->drawX = readable->x - read_buffer->drawXoff;
      read_buffer->drawY = readable->y;
      read_buffer->drawW = readable->w;
      read_buffer->drawH = readable->h;
   }
d776 2
a777 2
			draw_buffer->drawY * vmesa->front.pitch + 
			draw_buffer->drawX * bytePerPixel);
d780 2
a781 2
			   draw_buffer->drawY * vmesa->front.pitch + 
			   draw_buffer->drawX * bytePerPixel);
d817 6
a822 3
	if (vmesa->driDrawable != driDrawPriv) {
	   driDrawableInitVBlank(driDrawPriv, vmesa->vblank_flags,
				 &vmesa->vbl_seq);
a824 30
       if ((vmesa->driDrawable != driDrawPriv)
	   || (vmesa->driReadable != driReadPriv)) {
	  vmesa->driDrawable = driDrawPriv;
	  vmesa->driReadable = driReadPriv;

	  if ((drawBuffer->Width != driDrawPriv->w) 
	      || (drawBuffer->Height != driDrawPriv->h)) {
	     _mesa_resize_framebuffer(ctx, drawBuffer,
				      driDrawPriv->w, driDrawPriv->h);
	     drawBuffer->Initialized = GL_TRUE;
	  }

	  if (!calculate_buffer_parameters(vmesa, drawBuffer, driDrawPriv)) {
	     return GL_FALSE;
	  }

	  if (driDrawPriv != driReadPriv) {
	     if ((readBuffer->Width != driReadPriv->w)
		 || (readBuffer->Height != driReadPriv->h)) {
		_mesa_resize_framebuffer(ctx, readBuffer,
					 driReadPriv->w, driReadPriv->h);
		readBuffer->Initialized = GL_TRUE;
	     }

	     if (!calculate_buffer_parameters(vmesa, readBuffer, driReadPriv)) {
		return GL_FALSE;
	     }
	  }
       }

d850 1
a850 4
    DRI_VALIDATE_DRAWABLE_INFO(sPriv, dPriv);
    if (dPriv != vmesa->driReadable) {
	DRI_VALIDATE_DRAWABLE_INFO(sPriv, vmesa->driReadable);
    }
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d45 1
a45 1
#include "vbo/vbo.h"
a66 1
#define need_GL_ARB_vertex_buffer_object
a374 1
    { "GL_ARB_vertex_buffer_object",       GL_ARB_vertex_buffer_object_functions },
d586 1
a586 1
    _vbo_CreateContext(ctx);
d711 1
a711 1
        _vbo_DestroyContext(vmesa->glCtx);
d769 3
a771 1
   draw_buffer->drawX = drawable->x;
d783 3
a785 1
      read_buffer->drawX = readable->x;
d796 2
a797 6
			draw_buffer->drawY * vmesa->front.pitch + 
			draw_buffer->drawX * bytePerPixel);

   vmesa->back.orig = (vmesa->back.offset +
			draw_buffer->drawY * vmesa->back.pitch +
			draw_buffer->drawX * bytePerPixel);
d799 4
a802 11
   vmesa->back.origMap = (vmesa->back.map +
			draw_buffer->drawY * vmesa->back.pitch +
			draw_buffer->drawX * bytePerPixel);

   vmesa->depth.orig = (vmesa->depth.offset +
			draw_buffer->drawY * vmesa->depth.pitch +
			draw_buffer->drawX * bytePerPixel);   

   vmesa->depth.origMap = (vmesa->depth.map +
			draw_buffer->drawY * vmesa->depth.pitch +
			draw_buffer->drawX * bytePerPixel);
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d33 8
a40 6
#include "main/glheader.h"
#include "main/context.h"
#include "main/formats.h"
#include "main/simple_list.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
d62 1
a62 1
#include "main/macros.h"
d65 1
d67 1
d70 1
a70 1
#include "main/remap_helper.h"
d84 1
a84 1
static const GLubyte *viaGetString(struct gl_context *ctx, GLenum name)
d126 1
a126 1
static INLINE unsigned
d140 1
a140 1
viaRenderbufferStorage(struct gl_context *ctx, struct gl_renderbuffer *rb,
d152 1
a152 1
		    __DRIdrawable *dPriv)
a167 1
      rb->Format = MESA_FORMAT_ARGB8888;
a173 1
      rb->Format = MESA_FORMAT_Z16;
a179 1
      rb->Format = MESA_FORMAT_Z32;
a185 1
      rb->Format = MESA_FORMAT_S8;
d207 1
a207 1
			    __DRIdrawable *dPriv)
d355 1
a355 1
void viaReAllocateBuffers(struct gl_context *ctx, struct gl_framebuffer *drawbuffer,
d367 1
a367 1
static const struct dri_extension card_extensions[] =
d369 1
d376 1
d461 2
a462 3
viaCreateContext(gl_api api,
		 const struct gl_config *visual,
                 __DRIcontext *driContextPriv,
d465 1
a465 1
    struct gl_context *ctx, *shareCtx;
d467 1
a467 1
    __DRIscreen *sPriv = driContextPriv->driScreenPriv;
a579 2
    ctx->Const.MaxDrawBuffers = 1;

d604 3
d664 4
d671 1
a671 1
    (*sPriv->systemTime->getUST)( &vmesa->swap_ust );
d686 1
a686 1
viaDestroyContext(__DRIcontext *driContextPriv)
d689 1
a689 1
    struct via_context *vmesa =
a691 1

a693 13
    if (vmesa->driDrawable) {
       viaWaitIdle(vmesa, GL_FALSE);

       if (vmesa->doPageFlip) {
	  LOCK_HARDWARE(vmesa);
	  if (vmesa->pfCurrentOffset != 0) {
	     fprintf(stderr, "%s - reset pf\n", __FUNCTION__);
	     viaResetPageFlippingLocked(vmesa);
	  }
	  UNLOCK_HARDWARE(vmesa);
       }
    }

d700 24
a723 13
    _swsetup_DestroyContext(vmesa->glCtx);
    _tnl_DestroyContext(vmesa->glCtx);
    _vbo_DestroyContext(vmesa->glCtx);
    _swrast_DestroyContext(vmesa->glCtx);
    /* free the Mesa context */
    _mesa_destroy_context(vmesa->glCtx);
    /* release our data */
    FreeBuffer(vmesa);

    assert (is_empty_list(&vmesa->tex_image_list[VIA_MEM_AGP]));
    assert (is_empty_list(&vmesa->tex_image_list[VIA_MEM_VIDEO]));
    assert (is_empty_list(&vmesa->tex_image_list[VIA_MEM_SYSTEM]));
    assert (is_empty_list(&vmesa->freed_tex_buffers));
d725 1
a725 1
    driDestroyOptionCache(&vmesa->optionCache);
d727 2
a728 1
    FREE(vmesa);
d734 6
a739 4
   __DRIdrawable *const drawable = vmesa->driDrawable;
   __DRIdrawable *const readable = vmesa->driReadable;
   struct via_renderbuffer * draw_buffer;
   struct via_renderbuffer * read_buffer;
a743 3

   draw_buffer =  (struct via_renderbuffer *) drawable->driverPrivate;
   read_buffer =  (struct via_renderbuffer *) readable->driverPrivate;
d745 2
a746 2
   switch (vmesa->glCtx->DrawBuffer->_ColorDrawBufferIndexes[0]) {
   case BUFFER_BACK_LEFT: 
d756 1
a756 1
   case BUFFER_FRONT_LEFT:
d817 1
a817 1
viaUnbindContext(__DRIcontext *driContextPriv)
d823 3
a825 3
viaMakeCurrent(__DRIcontext *driContextPriv,
               __DRIdrawable *driDrawPriv,
               __DRIdrawable *driReadPriv)
d836 1
a836 1
	struct gl_context *ctx = vmesa->glCtx;
d839 7
a845 2
        drawBuffer = (struct gl_framebuffer *)driDrawPriv->driverPrivate;
        readBuffer = (struct gl_framebuffer *)driReadPriv->driverPrivate;
a848 9
	  if (driDrawPriv->swap_interval == (unsigned)-1) {
	     driDrawPriv->vblFlags =
		vmesa->viaScreen->irqEnabled ?
		driGetDefaultVBlankFlags(&vmesa->optionCache) :
		VBLANK_FLAG_NO_IRQ;

	     driDrawableInitVBlank(driDrawPriv);
	  }

d897 2
a898 2
    __DRIdrawable *dPriv = vmesa->driDrawable;
    __DRIscreen *sPriv = vmesa->driScreen;
d928 1
a928 1
viaSwapBuffers(__DRIdrawable *drawablePrivate)
d930 1
a930 1
    __DRIdrawable *dPriv = (__DRIdrawable *)drawablePrivate;
d937 1
a937 1
        struct gl_context *ctx = vmesa->glCtx;
@


