head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.04.51;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.22;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.39;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.55;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.54;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright (C) 2009-2010 Francisco Jerez.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "nouveau_driver.h"
#include "nouveau_context.h"
#include "nouveau_gldefs.h"
#include "nv10_3d.xml.h"
#include "nouveau_util.h"
#include "nv10_driver.h"
#include "nv20_driver.h"

#define RC_IN_SHIFT_A	24
#define RC_IN_SHIFT_B	16
#define RC_IN_SHIFT_C	8
#define RC_IN_SHIFT_D	0
#define RC_IN_SHIFT_E	56
#define RC_IN_SHIFT_F	48
#define RC_IN_SHIFT_G	40

#define RC_IN_SOURCE(source)				\
	((uint64_t)NV10_3D_RC_IN_RGB_D_INPUT_##source)
#define RC_IN_USAGE(usage)					\
	((uint64_t)NV10_3D_RC_IN_RGB_D_COMPONENT_USAGE_##usage)
#define RC_IN_MAPPING(mapping)					\
	((uint64_t)NV10_3D_RC_IN_RGB_D_MAPPING_##mapping)

#define RC_OUT_BIAS	NV10_3D_RC_OUT_RGB_BIAS_BIAS_BY_NEGATIVE_ONE_HALF
#define RC_OUT_SCALE_1	NV10_3D_RC_OUT_RGB_SCALE_NONE
#define RC_OUT_SCALE_2	NV10_3D_RC_OUT_RGB_SCALE_SCALE_BY_TWO
#define RC_OUT_SCALE_4	NV10_3D_RC_OUT_RGB_SCALE_SCALE_BY_FOUR

/* Make the combiner do: spare0_i = A_i * B_i */
#define RC_OUT_AB	NV10_3D_RC_OUT_RGB_AB_OUTPUT_SPARE0
/* spare0_i = dot3(A, B) */
#define RC_OUT_DOT_AB	(NV10_3D_RC_OUT_RGB_AB_OUTPUT_SPARE0 |	\
			 NV10_3D_RC_OUT_RGB_AB_DOT_PRODUCT)
/* spare0_i = A_i * B_i + C_i * D_i */
#define RC_OUT_SUM	NV10_3D_RC_OUT_RGB_SUM_OUTPUT_SPARE0

struct combiner_state {
	struct gl_context *ctx;
	int unit;
	GLboolean premodulate;

	/* GL state */
	GLenum mode;
	GLenum *source;
	GLenum *operand;
	GLuint logscale;

	/* Derived HW state */
	uint64_t in;
	uint32_t out;
};

/* Initialize a combiner_state struct from the texture unit
 * context. */
#define INIT_COMBINER(chan, ctx, rc, i) do {			\
		struct gl_tex_env_combine_state *c =		\
			ctx->Texture.Unit[i]._CurrentCombine;	\
		(rc)->ctx = ctx;				\
		(rc)->unit = i;					\
		(rc)->premodulate = c->_NumArgs##chan == 4;	\
		(rc)->mode = c->Mode##chan;			\
		(rc)->source = c->Source##chan;			\
		(rc)->operand = c->Operand##chan;		\
		(rc)->logscale = c->ScaleShift##chan;		\
		(rc)->in = (rc)->out = 0;			\
	} while (0)

/* Get the RC input source for the specified EXT_texture_env_combine
 * source. */
static uint32_t
get_input_source(struct combiner_state *rc, int source)
{
	switch (source) {
	case GL_ZERO:
		return RC_IN_SOURCE(ZERO);

	case GL_TEXTURE:
		return RC_IN_SOURCE(TEXTURE0) + rc->unit;

	case GL_TEXTURE0:
		return RC_IN_SOURCE(TEXTURE0);

	case GL_TEXTURE1:
		return RC_IN_SOURCE(TEXTURE1);

	case GL_TEXTURE2:
		return RC_IN_SOURCE(TEXTURE2);

	case GL_TEXTURE3:
		return RC_IN_SOURCE(TEXTURE3);

	case GL_CONSTANT:
		return context_chipset(rc->ctx) >= 0x20 ?
			RC_IN_SOURCE(CONSTANT_COLOR0) :
			RC_IN_SOURCE(CONSTANT_COLOR0) + rc->unit;

	case GL_PRIMARY_COLOR:
		return RC_IN_SOURCE(PRIMARY_COLOR);

	case GL_PREVIOUS:
		return rc->unit ? RC_IN_SOURCE(SPARE0)
			: RC_IN_SOURCE(PRIMARY_COLOR);

	default:
		assert(0);
	}
}

/* Get the RC input mapping for the specified texture_env_combine
 * operand, possibly inverted or biased. */
#define INVERT 0x1
#define HALF_BIAS 0x2

static uint32_t
get_input_mapping(struct combiner_state *rc, int operand, int flags)
{
	int map = 0;

	if (is_color_operand(operand))
		map |= RC_IN_USAGE(RGB);
	else
		map |= RC_IN_USAGE(ALPHA);

	if (is_negative_operand(operand) == !(flags & INVERT))
		map |= flags & HALF_BIAS ?
			RC_IN_MAPPING(HALF_BIAS_NEGATE) :
			RC_IN_MAPPING(UNSIGNED_INVERT);
	else
		map |= flags & HALF_BIAS ?
			RC_IN_MAPPING(HALF_BIAS_NORMAL) :
			RC_IN_MAPPING(UNSIGNED_IDENTITY);

	return map;
}

static uint32_t
get_input_arg(struct combiner_state *rc, int arg, int flags)
{
	int source = rc->source[arg];
	int operand = rc->operand[arg];

	/* Fake several unsupported texture formats. */
	if (is_texture_source(source)) {
		int i = (source == GL_TEXTURE ?
			 rc->unit : source - GL_TEXTURE0);
		struct gl_texture_object *t = rc->ctx->Texture.Unit[i]._Current;
		mesa_format format = t->Image[0][t->BaseLevel]->TexFormat;

		if (format == MESA_FORMAT_A_UNORM8) {
			/* Emulated using I8. */
			if (is_color_operand(operand))
				return RC_IN_SOURCE(ZERO) |
					get_input_mapping(rc, operand, flags);

		} else if (format == MESA_FORMAT_L_UNORM8) {
			/* Sometimes emulated using I8. */
			if (!is_color_operand(operand))
				return RC_IN_SOURCE(ZERO) |
					get_input_mapping(rc, operand,
							  flags ^ INVERT);

		} else if (format == MESA_FORMAT_B8G8R8X8_UNORM) {
			/* Sometimes emulated using ARGB8888. */
			if (!is_color_operand(operand))
				return RC_IN_SOURCE(ZERO) |
					get_input_mapping(rc, operand,
							  flags ^ INVERT);
		}
	}

	return get_input_source(rc, source) |
		get_input_mapping(rc, operand, flags);
}

/* Bind the RC input variable <var> to the EXT_texture_env_combine
 * argument <arg>, possibly inverted or biased. */
#define INPUT_ARG(rc, var, arg, flags)					\
	(rc)->in |= get_input_arg(rc, arg, flags) << RC_IN_SHIFT_##var

/* Bind the RC input variable <var> to the RC source <src>. */
#define INPUT_SRC(rc, var, src, chan)					\
	(rc)->in |= (RC_IN_SOURCE(src) |				\
		     RC_IN_USAGE(chan)) << RC_IN_SHIFT_##var

/* Bind the RC input variable <var> to a constant +/-1 */
#define INPUT_ONE(rc, var, flags)					\
	(rc)->in |= (RC_IN_SOURCE(ZERO) |				\
		     (flags & INVERT ? RC_IN_MAPPING(EXPAND_NORMAL) :	\
		      RC_IN_MAPPING(UNSIGNED_INVERT))) << RC_IN_SHIFT_##var

static void
setup_combiner(struct combiner_state *rc)
{
	switch (rc->mode) {
	case GL_REPLACE:
		INPUT_ARG(rc, A, 0, 0);
		INPUT_ONE(rc, B, 0);

		rc->out = RC_OUT_AB;
		break;

	case GL_MODULATE:
		INPUT_ARG(rc, A, 0, 0);
		INPUT_ARG(rc, B, 1, 0);

		rc->out = RC_OUT_AB;
		break;

	case GL_ADD:
	case GL_ADD_SIGNED:
		if (rc->premodulate) {
			INPUT_ARG(rc, A, 0, 0);
			INPUT_ARG(rc, B, 1, 0);
			INPUT_ARG(rc, C, 2, 0);
			INPUT_ARG(rc, D, 3, 0);
		} else {
			INPUT_ARG(rc, A, 0, 0);
			INPUT_ONE(rc, B, 0);
			INPUT_ARG(rc, C, 1, 0);
			INPUT_ONE(rc, D, 0);
		}

		rc->out = RC_OUT_SUM |
			(rc->mode == GL_ADD_SIGNED ? RC_OUT_BIAS : 0);
		break;

	case GL_INTERPOLATE:
		INPUT_ARG(rc, A, 0, 0);
		INPUT_ARG(rc, B, 2, 0);
		INPUT_ARG(rc, C, 1, 0);
		INPUT_ARG(rc, D, 2, INVERT);

		rc->out = RC_OUT_SUM;
		break;

	case GL_SUBTRACT:
		INPUT_ARG(rc, A, 0, 0);
		INPUT_ONE(rc, B, 0);
		INPUT_ARG(rc, C, 1, 0);
		INPUT_ONE(rc, D, INVERT);

		rc->out = RC_OUT_SUM;
		break;

	case GL_DOT3_RGB:
	case GL_DOT3_RGBA:
		INPUT_ARG(rc, A, 0, HALF_BIAS);
		INPUT_ARG(rc, B, 1, HALF_BIAS);

		rc->out = RC_OUT_DOT_AB | RC_OUT_SCALE_4;

		assert(!rc->logscale);
		break;

	default:
		assert(0);
	}

	switch (rc->logscale) {
	case 0:
		rc->out |= RC_OUT_SCALE_1;
		break;
	case 1:
		rc->out |= RC_OUT_SCALE_2;
		break;
	case 2:
		rc->out |= RC_OUT_SCALE_4;
		break;
	default:
		assert(0);
	}
}

void
nv10_get_general_combiner(struct gl_context *ctx, int i,
			  uint32_t *a_in, uint32_t *a_out,
			  uint32_t *c_in, uint32_t *c_out, uint32_t *k)
{
	struct combiner_state rc_a, rc_c;

	if (ctx->Texture.Unit[i]._Current) {
		INIT_COMBINER(RGB, ctx, &rc_c, i);

		if (rc_c.mode == GL_DOT3_RGBA)
			rc_a = rc_c;
		else
			INIT_COMBINER(A, ctx, &rc_a, i);

		setup_combiner(&rc_c);
		setup_combiner(&rc_a);

	} else {
		rc_a.in = rc_a.out = rc_c.in = rc_c.out = 0;
	}

	*k = pack_rgba_f(MESA_FORMAT_B8G8R8A8_UNORM,
			 ctx->Texture.Unit[i].EnvColor);
	*a_in = rc_a.in;
	*a_out = rc_a.out;
	*c_in = rc_c.in;
	*c_out = rc_c.out;
}

void
nv10_get_final_combiner(struct gl_context *ctx, uint64_t *in, int *n)
{
	struct combiner_state rc = {};

	/*
	 * The final fragment value equation is something like:
	 *	x_i = A_i * B_i + (1 - A_i) * C_i + D_i
	 *	x_alpha = G_alpha
	 * where D_i = E_i * F_i, i one of {red, green, blue}.
	 */
	if (ctx->Fog.ColorSumEnabled || ctx->Light.Enabled) {
		INPUT_SRC(&rc, D, E_TIMES_F, RGB);
		INPUT_SRC(&rc, F, SECONDARY_COLOR, RGB);
	}

	if (ctx->Fog.Enabled) {
		INPUT_SRC(&rc, A, FOG, ALPHA);
		INPUT_SRC(&rc, C, FOG, RGB);
		INPUT_SRC(&rc, E, FOG, ALPHA);
	} else {
		INPUT_ONE(&rc, A, 0);
		INPUT_ONE(&rc, C, 0);
		INPUT_ONE(&rc, E, 0);
	}

	if (ctx->Texture._MaxEnabledTexImageUnit != -1) {
		INPUT_SRC(&rc, B, SPARE0, RGB);
		INPUT_SRC(&rc, G, SPARE0, ALPHA);
	} else {
		INPUT_SRC(&rc, B, PRIMARY_COLOR, RGB);
		INPUT_SRC(&rc, G, PRIMARY_COLOR, ALPHA);
	}

	*in = rc.in;
	*n = ctx->Texture._MaxEnabledTexImageUnit + 1;
}

void
nv10_emit_tex_env(struct gl_context *ctx, int emit)
{
	const int i = emit - NOUVEAU_STATE_TEX_ENV0;
	struct nouveau_pushbuf *push = context_push(ctx);
	uint32_t a_in, a_out, c_in, c_out, k;

	nv10_get_general_combiner(ctx, i, &a_in, &a_out, &c_in, &c_out, &k);

	/* Enable the combiners we're going to need. */
	if (i == 1) {
		if (c_out || a_out)
			c_out |= 0x5 << 27;
		else
			c_out |= 0x3 << 27;
	}

	BEGIN_NV04(push, NV10_3D(RC_IN_ALPHA(i)), 1);
	PUSH_DATA (push, a_in);
	BEGIN_NV04(push, NV10_3D(RC_IN_RGB(i)), 1);
	PUSH_DATA (push, c_in);
	BEGIN_NV04(push, NV10_3D(RC_COLOR(i)), 1);
	PUSH_DATA (push, k);
	BEGIN_NV04(push, NV10_3D(RC_OUT_ALPHA(i)), 1);
	PUSH_DATA (push, a_out);
	BEGIN_NV04(push, NV10_3D(RC_OUT_RGB(i)), 1);
	PUSH_DATA (push, c_out);

	context_dirty(ctx, FRAG);
}

void
nv10_emit_frag(struct gl_context *ctx, int emit)
{
	struct nouveau_pushbuf *push = context_push(ctx);
	uint64_t in;
	int n;

	nv10_get_final_combiner(ctx, &in, &n);

	BEGIN_NV04(push, NV10_3D(RC_FINAL0), 2);
	PUSH_DATA (push, in);
	PUSH_DATA (push, in >> 32);
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d173 1
a173 1
		gl_format format = t->Image[0][t->BaseLevel]->TexFormat;
d175 1
a175 1
		if (format == MESA_FORMAT_A8) {
d181 1
a181 1
		} else if (format == MESA_FORMAT_L8) {
d188 1
a188 1
		} else if (format == MESA_FORMAT_XRGB8888) {
d307 1
a307 1
	if (ctx->Texture.Unit[i]._ReallyEnabled) {
d322 1
a322 1
	*k = pack_rgba_f(MESA_FORMAT_ARGB8888,
d356 1
a356 1
	if (ctx->Texture._EnabledUnits) {
d365 1
a365 1
	*n = log2i(ctx->Texture._EnabledUnits) + 1;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@d372 1
a372 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *celsius = context_eng3d(ctx);
d385 10
a394 10
	BEGIN_RING(chan, celsius, NV10_3D_RC_IN_ALPHA(i), 1);
	OUT_RING(chan, a_in);
	BEGIN_RING(chan, celsius, NV10_3D_RC_IN_RGB(i), 1);
	OUT_RING(chan, c_in);
	BEGIN_RING(chan, celsius, NV10_3D_RC_COLOR(i), 1);
	OUT_RING(chan, k);
	BEGIN_RING(chan, celsius, NV10_3D_RC_OUT_ALPHA(i), 1);
	OUT_RING(chan, a_out);
	BEGIN_RING(chan, celsius, NV10_3D_RC_OUT_RGB(i), 1);
	OUT_RING(chan, c_out);
d402 1
a402 2
	struct nouveau_channel *chan = context_chan(ctx);
	struct nouveau_grobj *celsius = context_eng3d(ctx);
d408 3
a410 3
	BEGIN_RING(chan, celsius, NV10_3D_RC_FINAL0, 2);
	OUT_RING(chan, in);
	OUT_RING(chan, in >> 32);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d30 1
a30 1
#include "nouveau_class.h"
d44 1
a44 1
	((uint64_t)NV10TCL_RC_IN_RGB_D_INPUT_##source)
d46 1
a46 1
	((uint64_t)NV10TCL_RC_IN_RGB_D_COMPONENT_USAGE_##usage)
d48 1
a48 1
	((uint64_t)NV10TCL_RC_IN_RGB_D_MAPPING_##mapping)
d50 4
a53 4
#define RC_OUT_BIAS	NV10TCL_RC_OUT_RGB_BIAS_BIAS_BY_NEGATIVE_ONE_HALF
#define RC_OUT_SCALE_1	NV10TCL_RC_OUT_RGB_SCALE_NONE
#define RC_OUT_SCALE_2	NV10TCL_RC_OUT_RGB_SCALE_SCALE_BY_TWO
#define RC_OUT_SCALE_4	NV10TCL_RC_OUT_RGB_SCALE_SCALE_BY_FOUR
d56 1
a56 1
#define RC_OUT_AB	NV10TCL_RC_OUT_RGB_AB_OUTPUT_SPARE0
d58 2
a59 2
#define RC_OUT_DOT_AB	(NV10TCL_RC_OUT_RGB_AB_OUTPUT_SPARE0 |	\
			 NV10TCL_RC_OUT_RGB_AB_DOT_PRODUCT)
d61 1
a61 1
#define RC_OUT_SUM	NV10TCL_RC_OUT_RGB_SUM_OUTPUT_SPARE0
d64 1
a64 1
	GLcontext *ctx;
d66 1
d86 1
d100 3
a235 8
		INPUT_ARG(rc, A, 0, 0);
		INPUT_ONE(rc, B, 0);
		INPUT_ARG(rc, C, 1, 0);
		INPUT_ONE(rc, D, 0);

		rc->out = RC_OUT_SUM;
		break;

d237 11
a247 4
		INPUT_ARG(rc, A, 0, 0);
		INPUT_ONE(rc, B, 0);
		INPUT_ARG(rc, C, 1, 0);
		INPUT_ONE(rc, D, 0);
d249 2
a250 1
		rc->out = RC_OUT_SUM | RC_OUT_BIAS;
d301 1
a301 1
nv10_get_general_combiner(GLcontext *ctx, int i,
d331 1
a331 1
nv10_get_final_combiner(GLcontext *ctx, uint64_t *in, int *n)
d369 1
a369 1
nv10_emit_tex_env(GLcontext *ctx, int emit)
d386 1
a386 1
	BEGIN_RING(chan, celsius, NV10TCL_RC_IN_ALPHA(i), 1);
d388 1
a388 1
	BEGIN_RING(chan, celsius, NV10TCL_RC_IN_RGB(i), 1);
d390 1
a390 1
	BEGIN_RING(chan, celsius, NV10TCL_RC_COLOR(i), 1);
d392 1
a392 1
	BEGIN_RING(chan, celsius, NV10TCL_RC_OUT_ALPHA(i), 1);
d394 1
a394 1
	BEGIN_RING(chan, celsius, NV10TCL_RC_OUT_RGB(i), 1);
d401 1
a401 1
nv10_emit_frag(GLcontext *ctx, int emit)
d410 1
a410 1
	BEGIN_RING(chan, celsius, NV10TCL_RC_FINAL0, 2);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d30 1
a30 1
#include "nv10_3d.xml.h"
d44 1
a44 1
	((uint64_t)NV10_3D_RC_IN_RGB_D_INPUT_##source)
d46 1
a46 1
	((uint64_t)NV10_3D_RC_IN_RGB_D_COMPONENT_USAGE_##usage)
d48 1
a48 1
	((uint64_t)NV10_3D_RC_IN_RGB_D_MAPPING_##mapping)
d50 4
a53 4
#define RC_OUT_BIAS	NV10_3D_RC_OUT_RGB_BIAS_BIAS_BY_NEGATIVE_ONE_HALF
#define RC_OUT_SCALE_1	NV10_3D_RC_OUT_RGB_SCALE_NONE
#define RC_OUT_SCALE_2	NV10_3D_RC_OUT_RGB_SCALE_SCALE_BY_TWO
#define RC_OUT_SCALE_4	NV10_3D_RC_OUT_RGB_SCALE_SCALE_BY_FOUR
d56 1
a56 1
#define RC_OUT_AB	NV10_3D_RC_OUT_RGB_AB_OUTPUT_SPARE0
d58 2
a59 2
#define RC_OUT_DOT_AB	(NV10_3D_RC_OUT_RGB_AB_OUTPUT_SPARE0 |	\
			 NV10_3D_RC_OUT_RGB_AB_DOT_PRODUCT)
d61 1
a61 1
#define RC_OUT_SUM	NV10_3D_RC_OUT_RGB_SUM_OUTPUT_SPARE0
d64 1
a64 1
	struct gl_context *ctx;
a65 1
	GLboolean premodulate;
a84 1
		(rc)->premodulate = c->_NumArgs##chan == 4;	\
a97 3
	case GL_ZERO:
		return RC_IN_SOURCE(ZERO);

d231 8
d240 4
a243 11
		if (rc->premodulate) {
			INPUT_ARG(rc, A, 0, 0);
			INPUT_ARG(rc, B, 1, 0);
			INPUT_ARG(rc, C, 2, 0);
			INPUT_ARG(rc, D, 3, 0);
		} else {
			INPUT_ARG(rc, A, 0, 0);
			INPUT_ONE(rc, B, 0);
			INPUT_ARG(rc, C, 1, 0);
			INPUT_ONE(rc, D, 0);
		}
d245 1
a245 2
		rc->out = RC_OUT_SUM |
			(rc->mode == GL_ADD_SIGNED ? RC_OUT_BIAS : 0);
d296 1
a296 1
nv10_get_general_combiner(struct gl_context *ctx, int i,
d326 1
a326 1
nv10_get_final_combiner(struct gl_context *ctx, uint64_t *in, int *n)
d364 1
a364 1
nv10_emit_tex_env(struct gl_context *ctx, int emit)
d381 1
a381 1
	BEGIN_RING(chan, celsius, NV10_3D_RC_IN_ALPHA(i), 1);
d383 1
a383 1
	BEGIN_RING(chan, celsius, NV10_3D_RC_IN_RGB(i), 1);
d385 1
a385 1
	BEGIN_RING(chan, celsius, NV10_3D_RC_COLOR(i), 1);
d387 1
a387 1
	BEGIN_RING(chan, celsius, NV10_3D_RC_OUT_ALPHA(i), 1);
d389 1
a389 1
	BEGIN_RING(chan, celsius, NV10_3D_RC_OUT_RGB(i), 1);
d396 1
a396 1
nv10_emit_frag(struct gl_context *ctx, int emit)
d405 1
a405 1
	BEGIN_RING(chan, celsius, NV10_3D_RC_FINAL0, 2);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d372 2
a373 1
	struct nouveau_pushbuf *push = context_push(ctx);
d386 10
a395 10
	BEGIN_NV04(push, NV10_3D(RC_IN_ALPHA(i)), 1);
	PUSH_DATA (push, a_in);
	BEGIN_NV04(push, NV10_3D(RC_IN_RGB(i)), 1);
	PUSH_DATA (push, c_in);
	BEGIN_NV04(push, NV10_3D(RC_COLOR(i)), 1);
	PUSH_DATA (push, k);
	BEGIN_NV04(push, NV10_3D(RC_OUT_ALPHA(i)), 1);
	PUSH_DATA (push, a_out);
	BEGIN_NV04(push, NV10_3D(RC_OUT_RGB(i)), 1);
	PUSH_DATA (push, c_out);
d403 2
a404 1
	struct nouveau_pushbuf *push = context_push(ctx);
d410 3
a412 3
	BEGIN_NV04(push, NV10_3D(RC_FINAL0), 2);
	PUSH_DATA (push, in);
	PUSH_DATA (push, in >> 32);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d173 1
a173 1
		mesa_format format = t->Image[0][t->BaseLevel]->TexFormat;
d175 1
a175 1
		if (format == MESA_FORMAT_A_UNORM8) {
d181 1
a181 1
		} else if (format == MESA_FORMAT_L_UNORM8) {
d188 1
a188 1
		} else if (format == MESA_FORMAT_B8G8R8X8_UNORM) {
d307 1
a307 1
	if (ctx->Texture.Unit[i]._Current) {
d322 1
a322 1
	*k = pack_rgba_f(MESA_FORMAT_B8G8R8A8_UNORM,
d356 1
a356 1
	if (ctx->Texture._MaxEnabledTexImageUnit != -1) {
d365 1
a365 1
	*n = ctx->Texture._MaxEnabledTexImageUnit + 1;
@


