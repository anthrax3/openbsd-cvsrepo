head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.04.14;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.14;	author matthieu;	state dead;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.35;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.35;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.10;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.15.21;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.47;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2006 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "intel_context.h"
#include "intel_batchbuffer.h"
#include "intel_buffer_objects.h"
#include "intel_reg.h"
#include "intel_bufmgr.h"
#include "intel_buffers.h"

static void
intel_batchbuffer_reset(struct intel_context *intel);

void
intel_batchbuffer_init(struct intel_context *intel)
{
   intel_batchbuffer_reset(intel);

   intel->batch.cpu_map = malloc(intel->maxBatchSize);
   intel->batch.map = intel->batch.cpu_map;
}

static void
intel_batchbuffer_reset(struct intel_context *intel)
{
   if (intel->batch.last_bo != NULL) {
      drm_intel_bo_unreference(intel->batch.last_bo);
      intel->batch.last_bo = NULL;
   }
   intel->batch.last_bo = intel->batch.bo;

   intel->batch.bo = drm_intel_bo_alloc(intel->bufmgr, "batchbuffer",
					intel->maxBatchSize, 4096);

   intel->batch.reserved_space = BATCH_RESERVED;
   intel->batch.used = 0;
}

void
intel_batchbuffer_free(struct intel_context *intel)
{
   free(intel->batch.cpu_map);
   drm_intel_bo_unreference(intel->batch.last_bo);
   drm_intel_bo_unreference(intel->batch.bo);
}

static void
do_batch_dump(struct intel_context *intel)
{
   struct drm_intel_decode *decode;
   struct intel_batchbuffer *batch = &intel->batch;
   int ret;

   decode = drm_intel_decode_context_alloc(intel->intelScreen->deviceID);
   if (!decode)
      return;

   ret = drm_intel_bo_map(batch->bo, false);
   if (ret == 0) {
      drm_intel_decode_set_batch_pointer(decode,
					 batch->bo->virtual,
					 batch->bo->offset,
					 batch->used);
   } else {
      fprintf(stderr,
	      "WARNING: failed to map batchbuffer (%s), "
	      "dumping uploaded data instead.\n", strerror(ret));

      drm_intel_decode_set_batch_pointer(decode,
					 batch->map,
					 batch->bo->offset,
					 batch->used);
   }

   drm_intel_decode(decode);

   drm_intel_decode_context_free(decode);

   if (ret == 0) {
      drm_intel_bo_unmap(batch->bo);

      if (intel->vtbl.debug_batch != NULL)
	 intel->vtbl.debug_batch(intel);
   }
}

/* TODO: Push this whole function into bufmgr.
 */
static int
do_flush_locked(struct intel_context *intel)
{
   struct intel_batchbuffer *batch = &intel->batch;
   int ret = 0;

   ret = drm_intel_bo_subdata(batch->bo, 0, 4*batch->used, batch->map);

   if (!intel->intelScreen->no_hw) {
      if (ret == 0) {
         if (unlikely(INTEL_DEBUG & DEBUG_AUB) && intel->vtbl.annotate_aub)
            intel->vtbl.annotate_aub(intel);
         ret = drm_intel_bo_mrb_exec(batch->bo, 4 * batch->used, NULL, 0, 0,
                                     I915_EXEC_RENDER);
      }
   }

   if (unlikely(INTEL_DEBUG & DEBUG_BATCH))
      do_batch_dump(intel);

   if (ret != 0) {
      fprintf(stderr, "intel_do_flush_locked failed: %s\n", strerror(-ret));
      exit(1);
   }
   intel->vtbl.new_batch(intel);

   return ret;
}

int
_intel_batchbuffer_flush(struct intel_context *intel,
			 const char *file, int line)
{
   int ret;

   if (intel->batch.used == 0)
      return 0;

   if (intel->first_post_swapbuffers_batch == NULL) {
      intel->first_post_swapbuffers_batch = intel->batch.bo;
      drm_intel_bo_reference(intel->first_post_swapbuffers_batch);
   }

   if (unlikely(INTEL_DEBUG & DEBUG_BATCH))
      fprintf(stderr, "%s:%d: Batchbuffer flush with %db used\n", file, line,
	      4*intel->batch.used);

   intel->batch.reserved_space = 0;

   if (intel->vtbl.finish_batch)
      intel->vtbl.finish_batch(intel);

   /* Mark the end of the buffer. */
   intel_batchbuffer_emit_dword(intel, MI_BATCH_BUFFER_END);
   if (intel->batch.used & 1) {
      /* Round batchbuffer usage to 2 DWORDs. */
      intel_batchbuffer_emit_dword(intel, MI_NOOP);
   }

   intel_upload_finish(intel);

   /* Check that we didn't just wrap our batchbuffer at a bad time. */
   assert(!intel->no_batch_wrap);

   ret = do_flush_locked(intel);

   if (unlikely(INTEL_DEBUG & DEBUG_SYNC)) {
      fprintf(stderr, "waiting for idle\n");
      drm_intel_bo_wait_rendering(intel->batch.bo);
   }

   /* Reset the buffer:
    */
   intel_batchbuffer_reset(intel);

   return ret;
}


/*  This is the only way buffers get added to the validate list.
 */
bool
intel_batchbuffer_emit_reloc(struct intel_context *intel,
                             drm_intel_bo *buffer,
                             uint32_t read_domains, uint32_t write_domain,
			     uint32_t delta)
{
   int ret;

   ret = drm_intel_bo_emit_reloc(intel->batch.bo, 4*intel->batch.used,
				 buffer, delta,
				 read_domains, write_domain);
   assert(ret == 0);
   (void)ret;

   /*
    * Using the old buffer offset, write in what the right data would be, in case
    * the buffer doesn't move and we can short-circuit the relocation processing
    * in the kernel
    */
   intel_batchbuffer_emit_dword(intel, buffer->offset + delta);

   return true;
}

bool
intel_batchbuffer_emit_reloc_fenced(struct intel_context *intel,
				    drm_intel_bo *buffer,
				    uint32_t read_domains,
				    uint32_t write_domain,
				    uint32_t delta)
{
   int ret;

   ret = drm_intel_bo_emit_reloc_fence(intel->batch.bo, 4*intel->batch.used,
				       buffer, delta,
				       read_domains, write_domain);
   assert(ret == 0);
   (void)ret;

   /*
    * Using the old buffer offset, write in what the right data would
    * be, in case the buffer doesn't move and we can short-circuit the
    * relocation processing in the kernel
    */
   intel_batchbuffer_emit_dword(intel, buffer->offset + delta);

   return true;
}

void
intel_batchbuffer_data(struct intel_context *intel,
                       const void *data, GLuint bytes)
{
   assert((bytes & 3) == 0);
   intel_batchbuffer_require_space(intel, bytes);
   __memcpy(intel->batch.map + intel->batch.used, data, bytes);
   intel->batch.used += bytes >> 2;
}

/* Emit a pipelined flush to either flush render and texture cache for
 * reading from a FBO-drawn texture, or flush so that frontbuffer
 * render appears on the screen in DRI1.
 *
 * This is also used for the always_flush_cache driconf debug option.
 */
void
intel_batchbuffer_emit_mi_flush(struct intel_context *intel)
{
   BEGIN_BATCH(1);
   OUT_BATCH(MI_FLUSH);
   ADVANCE_BATCH();
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2006 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d28 3
a30 9

#include <stdio.h>
#include <errno.h>

#include "mtypes.h"
#include "context.h"
#include "enums.h"
#include "vblank.h"

d32 2
a33 4
#include "intel_batchbuffer.h"
#include "intel_context.h"


d35 2
d38 2
a39 8
/* ================================================================
 * Performance monitoring functions
 */

static void intel_fill_box( intelContextPtr intel,
			    GLshort x, GLshort y,
			    GLshort w, GLshort h,
			    GLubyte r, GLubyte g, GLubyte b )
d41 1
a41 2
   x += intel->drawX;
   y += intel->drawY;
d43 2
a44 10
   if (x >= 0 && y >= 0 &&
       x+w < intel->intelScreen->width &&
       y+h < intel->intelScreen->height)
      intelEmitFillBlitLocked( intel, 
			       intel->intelScreen->cpp,
			       intel->intelScreen->back.pitch,
			       intel->intelScreen->back.offset,
			       x, y, w, h,
			       INTEL_PACKCOLOR(intel->intelScreen->fbFormat,
					       r,g,b,0xff));
d47 2
a48 1
static void intel_draw_performance_boxes( intelContextPtr intel )
d50 3
a52 36
   /* Purple box for page flipping
    */
   if ( intel->perf_boxes & I830_BOX_FLIP ) 
      intel_fill_box( intel, 4, 4, 8, 8, 255, 0, 255 );

   /* Red box if we have to wait for idle at any point
    */
   if ( intel->perf_boxes & I830_BOX_WAIT ) 
      intel_fill_box( intel, 16, 4, 8, 8, 255, 0, 0 );

   /* Blue box: lost context?
    */
   if ( intel->perf_boxes & I830_BOX_LOST_CONTEXT ) 
      intel_fill_box( intel, 28, 4, 8, 8, 0, 0, 255 );

   /* Yellow box for texture swaps
    */
   if ( intel->perf_boxes & I830_BOX_TEXTURE_LOAD ) 
      intel_fill_box( intel, 40, 4, 8, 8, 255, 255, 0 );

   /* Green box if hardware never idles (as far as we can tell)
    */
   if ( !(intel->perf_boxes & I830_BOX_RING_EMPTY) ) 
      intel_fill_box( intel, 64, 4, 8, 8, 0, 255, 0 );


   /* Draw bars indicating number of buffers allocated 
    * (not a great measure, easily confused)
    */
#if 0
   if (intel->dma_used) {
      int bar = intel->dma_used / 10240;
      if (bar > 100) bar = 100;
      if (bar < 1) bar = 1;
      intel_fill_box( intel, 4, 16, bar, 4, 196, 128, 128 );
      intel->dma_used = 0;
d54 1
a54 4
#endif

   intel->perf_boxes = 0;
}
d56 2
d59 2
a60 24




static int bad_prim_vertex_nr( int primitive, int nr )
{
   switch (primitive & PRIM3D_MASK) {
   case PRIM3D_POINTLIST:
      return nr < 1;
   case PRIM3D_LINELIST:
      return (nr & 1) || nr == 0;
   case PRIM3D_LINESTRIP:
      return nr < 2;
   case PRIM3D_TRILIST:
   case PRIM3D_RECTLIST:
      return nr % 3 || nr == 0;
   case PRIM3D_POLY:
   case PRIM3D_TRIFAN:
   case PRIM3D_TRISTRIP:
   case PRIM3D_TRISTRIP_RVRSE:
      return nr < 3;
   default:
      return 1;
   }	
d63 2
a64 1
static void intel_flush_inline_primitive( GLcontext *ctx )
d66 3
a68 49
   intelContextPtr intel = INTEL_CONTEXT( ctx );
   GLuint used = intel->batch.ptr - intel->prim.start_ptr;
   GLuint vertcount;

   assert(intel->prim.primitive != ~0);

   if (1) {
      /* Check vertex size against the vertex we're specifying to
       * hardware.  If it's wrong, ditch the primitive.
       */ 
      if (!intel->vtbl.check_vertex_size( intel, intel->vertex_size )) 
	 goto do_discard;

      vertcount = (used - 4)/ (intel->vertex_size * 4);

      if (!vertcount)
	 goto do_discard;
      
      if (vertcount * intel->vertex_size * 4 != used - 4) {
	 fprintf(stderr, "vertex size confusion %d %d\n", used, 
		 intel->vertex_size * vertcount * 4);
	 goto do_discard;
      }

      if (bad_prim_vertex_nr( intel->prim.primitive, vertcount )) {
	 fprintf(stderr, "bad_prim_vertex_nr %x %d\n", intel->prim.primitive,
		 vertcount);
	 goto do_discard;
      }
   }

   if (used < 8)
      goto do_discard;

   *(int *)intel->prim.start_ptr = (_3DPRIMITIVE | 
				    intel->prim.primitive |
				    (used/4-2));

   goto finished;
   
 do_discard:
   intel->batch.ptr -= used;
   intel->batch.space += used;
   assert(intel->batch.space >= 0);

 finished:
   intel->prim.primitive = ~0;
   intel->prim.start_ptr = 0;
   intel->prim.flush = 0;
d71 2
a72 4

/* Emit a primitive referencing vertices in a vertex buffer.
 */
void intelStartInlinePrimitive( intelContextPtr intel, GLuint prim )
d74 3
a76 1
   BATCH_LOCALS;
d78 3
a80 2
   if (0)
      fprintf(stderr, "%s %x\n", __FUNCTION__, prim);
d82 10
d93 4
a96 20
   /* Finish any in-progress primitive:
    */
   INTEL_FIREVERTICES( intel );
   
   /* Emit outstanding state:
    */
   intel->vtbl.emit_state( intel );
   
   /* Make sure there is some space in this buffer:
    */
   if (intel->vertex_size * 10 * sizeof(GLuint) >= intel->batch.space) {
      intelFlushBatch(intel, GL_TRUE); 
      intel->vtbl.emit_state( intel );
   }

#if 1
   if (((unsigned long)intel->batch.ptr) & 0x4) {
      BEGIN_BATCH(1);
      OUT_BATCH(0);
      ADVANCE_BATCH();
a97 7
#endif

   /* Emit a slot which will be filled with the inline primitive
    * command later.
    */
   BEGIN_BATCH(2);
   OUT_BATCH( 0 );
d99 1
a99 4
   intel->prim.start_ptr = batch_ptr;
   intel->prim.primitive = prim;
   intel->prim.flush = intel_flush_inline_primitive;
   intel->batch.contains_geometry = 1;
d101 1
a101 3
   OUT_BATCH( 0 );
   ADVANCE_BATCH();
}
d103 2
d106 3
a108 20
void intelRestartInlinePrimitive( intelContextPtr intel )
{
   GLuint prim = intel->prim.primitive;

   intel_flush_inline_primitive( &intel->ctx );
   if (1) intelFlushBatch(intel, GL_TRUE); /* GL_TRUE - is critical */
   intelStartInlinePrimitive( intel, prim );
}



void intelWrapInlinePrimitive( intelContextPtr intel )
{
   GLuint prim = intel->prim.primitive;

   if (0)
      fprintf(stderr, "%s\n", __FUNCTION__);
   intel_flush_inline_primitive( &intel->ctx );
   intelFlushBatch(intel, GL_TRUE);
   intelStartInlinePrimitive( intel, prim );
d111 1
a111 2

/* Emit a primitive with space for inline vertices.
d113 2
a114 4
GLuint *intelEmitInlinePrimitiveLocked(intelContextPtr intel, 
				       int primitive,
				       int dwords,
				       int vertex_size )
d116 2
a117 2
   GLuint *tmp = 0;
   BATCH_LOCALS;
d119 1
a119 2
   if (0)
      fprintf(stderr, "%s 0x%x %d\n", __FUNCTION__, primitive, dwords);
d121 7
a127 7
   /* Emit outstanding state:
    */
   intel->vtbl.emit_state( intel );

   if ((1+dwords)*4 >= intel->batch.space) {
      intelFlushBatch(intel, GL_TRUE); 
      intel->vtbl.emit_state( intel );
d130 2
d133 3
a135 24
   if (1) {
      int used = dwords * 4;
      int vertcount;

      /* Check vertex size against the vertex we're specifying to
       * hardware.  If it's wrong, ditch the primitive.
       */ 
      if (!intel->vtbl.check_vertex_size( intel, vertex_size )) 
	 goto do_discard;

      vertcount = dwords / vertex_size;
      
      if (dwords % vertex_size) {
	 fprintf(stderr, "did not request a whole number of vertices\n");
	 goto do_discard;
      }

      if (bad_prim_vertex_nr( primitive, vertcount )) {
	 fprintf(stderr, "bad_prim_vertex_nr %x %d\n", primitive, vertcount);
	 goto do_discard;
      }

      if (used < 8)
	 goto do_discard;
d137 1
d139 1
a139 16
   /* Emit 3D_PRIMITIVE commands:
    */
   BEGIN_BATCH(1 + dwords);
   OUT_BATCH( _3DPRIMITIVE | 
	      primitive |
	      (dwords-1) );

   tmp = (GLuint *)batch_ptr;
   batch_ptr += dwords * 4;

   ADVANCE_BATCH();

   intel->batch.contains_geometry = 1;

 do_discard:
   return tmp;
d142 3
a144 2

static void intelWaitForFrameCompletion( intelContextPtr intel )
d146 1
a146 1
  drm_i915_sarea_t *sarea = (drm_i915_sarea_t *)intel->sarea;
d148 2
a149 11
   if (intel->do_irqs) {
      if (intelGetLastFrame(intel) < sarea->last_dispatch) {
	 if (!intel->irqsEmitted) {
	    while (intelGetLastFrame (intel) < sarea->last_dispatch)
	       ;
	 }
	 else {
	    intelWaitIrq( intel, intel->alloc.irq_emitted );	
	 }
	 intel->irqsEmitted = 10;
      }
d151 3
a153 12
      if (intel->irqsEmitted) {
	 LOCK_HARDWARE( intel ); 
	 intelEmitIrqLocked( intel );
	 intel->irqsEmitted--;
	 UNLOCK_HARDWARE( intel ); 
      }
   } 
   else {
      while (intelGetLastFrame (intel) < sarea->last_dispatch) {
	 if (intel->do_usleeps) 
	    DO_USLEEP( 1 );
      }
a154 1
}
d156 5
a160 106
/*
 * Copy the back buffer to the front buffer. 
 */
void intelCopyBuffer( const __DRIdrawablePrivate *dPriv,
		      const drm_clip_rect_t	 *rect)
{
   intelContextPtr intel;
   GLboolean   missed_target;
   int64_t ust;

   if (0)
      fprintf(stderr, "%s\n", __FUNCTION__);

   assert(dPriv);
   assert(dPriv->driContextPriv);
   assert(dPriv->driContextPriv->driverPrivate);

   intel = (intelContextPtr) dPriv->driContextPriv->driverPrivate;

   intelFlush( &intel->ctx );
   
   intelWaitForFrameCompletion( intel );
   LOCK_HARDWARE( intel );

   if (!rect)
   {
       UNLOCK_HARDWARE( intel );
       driWaitForVBlank( dPriv, &intel->vbl_seq, intel->vblank_flags, & missed_target );
       LOCK_HARDWARE( intel );
   }
   {
      const intelScreenPrivate *intelScreen = intel->intelScreen;
      const __DRIdrawablePrivate *dPriv = intel->driDrawable;
      const int nbox = dPriv->numClipRects;
      const drm_clip_rect_t *pbox = dPriv->pClipRects;
      drm_clip_rect_t box;
      const int cpp = intelScreen->cpp;
      const int pitch = intelScreen->front.pitch; /* in bytes */
      int i;
      GLuint CMD, BR13;
      BATCH_LOCALS;

      switch(cpp) {
      case 2: 
	 BR13 = (pitch) | (0xCC << 16) | (1<<24);
	 CMD = XY_SRC_COPY_BLT_CMD;
	 break;
      case 4:
	 BR13 = (pitch) | (0xCC << 16) | (1<<24) | (1<<25);
	 CMD = (XY_SRC_COPY_BLT_CMD | XY_SRC_COPY_BLT_WRITE_ALPHA |
		XY_SRC_COPY_BLT_WRITE_RGB);
	 break;
      default:
	 BR13 = (pitch) | (0xCC << 16) | (1<<24);
	 CMD = XY_SRC_COPY_BLT_CMD;
	 break;
      }
   
      if (0) 
	 intel_draw_performance_boxes( intel );

      for (i = 0 ; i < nbox; i++, pbox++) 
      {
	 if (pbox->x1 > pbox->x2 ||
	     pbox->y1 > pbox->y2 ||
	     pbox->x2 > intelScreen->width ||
	     pbox->y2 > intelScreen->height) {
            _mesa_warning(&intel->ctx, "Bad cliprect in intelCopyBuffer()");
	    continue;
         }

	 box = *pbox;

	 if (rect)
	 {
	     if (rect->x1 > box.x1)
		 box.x1 = rect->x1;
	     if (rect->y1 > box.y1)
		 box.y1 = rect->y1;
	     if (rect->x2 < box.x2)
		 box.x2 = rect->x2;
	     if (rect->y2 < box.y2)
		 box.y2 = rect->y2;

	     if (box.x1 > box.x2 || box.y1 > box.y2)
		 continue;
	 }

	 BEGIN_BATCH( 8);
	 OUT_BATCH( CMD );
	 OUT_BATCH( BR13 );
	 OUT_BATCH( (box.y1 << 16) | box.x1 );
	 OUT_BATCH( (box.y2 << 16) | box.x2 );

	 if (intel->sarea->pf_current_page == 0) 
	    OUT_BATCH( intelScreen->front.offset );
	 else
	    OUT_BATCH( intelScreen->back.offset );			

	 OUT_BATCH( (box.y1 << 16) | box.x1 );
	 OUT_BATCH( BR13 & 0xffff );

	 if (intel->sarea->pf_current_page == 0) 
	    OUT_BATCH( intelScreen->back.offset );			
	 else
	    OUT_BATCH( intelScreen->front.offset );
d162 2
a163 5
	 ADVANCE_BATCH();
      }
   }
   intelFlushBatchLocked( intel, GL_TRUE, GL_TRUE, GL_TRUE );
   UNLOCK_HARDWARE( intel );
d165 5
a169 10
   if (!rect)
   {
       intel->swap_count++;
       (*dri_interface->getUST)(&ust);
       if (missed_target) {
	   intel->swap_missed_count++;
	   intel->swap_missed_ust = ust -  intel->swap_ust;
       }
   
       intel->swap_ust = ust;
a170 1
}
d172 1
d174 2
d177 1
d179 4
a182 10
void intelEmitFillBlitLocked( intelContextPtr intel,
			      GLuint cpp,
			      GLshort dst_pitch,  /* in bytes */
			      GLuint dst_offset,
			      GLshort x, GLshort y, 
			      GLshort w, GLshort h,
			      GLuint color )
{
   GLuint BR13, CMD;
   BATCH_LOCALS;
d184 3
a186 15
   switch(cpp) {
   case 1: 
   case 2: 
   case 3: 
      BR13 = dst_pitch | (0xF0 << 16) | (1<<24);
      CMD = XY_COLOR_BLT_CMD;
      break;
   case 4:
      BR13 = dst_pitch | (0xF0 << 16) | (1<<24) | (1<<25);
      CMD = (XY_COLOR_BLT_CMD | XY_COLOR_BLT_WRITE_ALPHA |
	     XY_COLOR_BLT_WRITE_RGB);
      break;
   default:
      return;
   }
d188 1
a188 8
   BEGIN_BATCH( 6);
   OUT_BATCH( CMD );
   OUT_BATCH( BR13 );
   OUT_BATCH( (y << 16) | x );
   OUT_BATCH( ((y+h) << 16) | (x+w) );
   OUT_BATCH( dst_offset );
   OUT_BATCH( color );
   ADVANCE_BATCH();
d192 1
a192 1
/* Copy BitBlt
d194 5
a198 9
void intelEmitCopyBlitLocked( intelContextPtr intel,
			      GLuint cpp,
			      GLshort src_pitch,
			      GLuint  src_offset,
			      GLshort dst_pitch,
			      GLuint  dst_offset,
			      GLshort src_x, GLshort src_y,
			      GLshort dst_x, GLshort dst_y,
			      GLshort w, GLshort h )
d200 7
a206 23
   GLuint CMD, BR13;
   int dst_y2 = dst_y + h;
   int dst_x2 = dst_x + w;
   BATCH_LOCALS;

   src_pitch *= cpp;
   dst_pitch *= cpp;

   switch(cpp) {
   case 1: 
   case 2: 
   case 3: 
      BR13 = dst_pitch | (0xCC << 16) | (1<<24);
      CMD = XY_SRC_COPY_BLT_CMD;
      break;
   case 4:
      BR13 = dst_pitch | (0xCC << 16) | (1<<24) | (1<<25);
      CMD = (XY_SRC_COPY_BLT_CMD | XY_SRC_COPY_BLT_WRITE_ALPHA |
	     XY_SRC_COPY_BLT_WRITE_RGB);
      break;
   default:
      return;
   }
d208 6
a213 4
   if (dst_y2 < dst_y ||
       dst_x2 < dst_x) {
      return;
   }
d215 1
a215 10
   BEGIN_BATCH( 12);
   OUT_BATCH( CMD );
   OUT_BATCH( BR13 );
   OUT_BATCH( (dst_y << 16) | dst_x );
   OUT_BATCH( (dst_y2 << 16) | dst_x2 );
   OUT_BATCH( dst_offset );	
   OUT_BATCH( (src_y << 16) | src_x );
   OUT_BATCH( src_pitch );
   OUT_BATCH( src_offset ); 
   ADVANCE_BATCH();
d218 6
a223 4


void intelClearWithBlit(GLcontext *ctx, GLbitfield flags, GLboolean all,
		      GLint cx1, GLint cy1, GLint cw, GLint ch)
d225 1
a225 12
   intelContextPtr intel = INTEL_CONTEXT( ctx );
   intelScreenPrivate *intelScreen = intel->intelScreen;
   GLuint clear_depth, clear_color;
   GLint cx, cy;
   GLint pitch;
   GLint cpp = intelScreen->cpp;
   GLint i;
   GLuint BR13, CMD, D_CMD;
   BATCH_LOCALS;

   intelFlush( &intel->ctx );
   LOCK_HARDWARE( intel );
d227 5
a231 1
   pitch = intelScreen->front.pitch;
d233 6
a238 45
   clear_color = intel->ClearColor;
   clear_depth = 0;

   if (flags & BUFFER_BIT_DEPTH) {
      clear_depth = (GLuint)(ctx->Depth.Clear * intel->ClearDepth);
   }

   if (flags & BUFFER_BIT_STENCIL) {
      clear_depth |= (ctx->Stencil.Clear & 0xff) << 24;
   }

   switch(cpp) {
   case 2: 
      BR13 = (0xF0 << 16) | (pitch) | (1<<24);
      D_CMD = CMD = XY_COLOR_BLT_CMD;
      break;
   case 4:
      BR13 = (0xF0 << 16) | (pitch) | (1<<24) | (1<<25);
      CMD = (XY_COLOR_BLT_CMD |
	     XY_COLOR_BLT_WRITE_ALPHA | 
	     XY_COLOR_BLT_WRITE_RGB);
      D_CMD = XY_COLOR_BLT_CMD;
      if (flags & BUFFER_BIT_DEPTH) D_CMD |= XY_COLOR_BLT_WRITE_RGB;
      if (flags & BUFFER_BIT_STENCIL) D_CMD |= XY_COLOR_BLT_WRITE_ALPHA;
      break;
   default:
      BR13 = (0xF0 << 16) | (pitch) | (1<<24);
      D_CMD = CMD = XY_COLOR_BLT_CMD;
      break;
   }

   {
      /* flip top to bottom */
      cy = intel->driDrawable->h-cy1-ch;
      cx = cx1 + intel->drawX;
      cy += intel->drawY;

      /* adjust for page flipping */
      if ( intel->sarea->pf_current_page == 1 ) {
	 GLuint tmp = flags;

	 flags &= ~(BUFFER_BIT_FRONT_LEFT | BUFFER_BIT_BACK_LEFT);
	 if ( tmp & BUFFER_BIT_FRONT_LEFT ) flags |= BUFFER_BIT_BACK_LEFT;
	 if ( tmp & BUFFER_BIT_BACK_LEFT )  flags |= BUFFER_BIT_FRONT_LEFT;
      }
d240 1
a240 69
      for (i = 0 ; i < intel->numClipRects ; i++) 
      { 	 
	 drm_clip_rect_t *box = &intel->pClipRects[i];	 
	 drm_clip_rect_t b;

	 if (!all) {
	    GLint x = box->x1;
	    GLint y = box->y1;
	    GLint w = box->x2 - x;
	    GLint h = box->y2 - y;

	    if (x < cx) w -= cx - x, x = cx; 
	    if (y < cy) h -= cy - y, y = cy;
	    if (x + w > cx + cw) w = cx + cw - x;
	    if (y + h > cy + ch) h = cy + ch - y;
	    if (w <= 0) continue;
	    if (h <= 0) continue;

	    b.x1 = x;
	    b.y1 = y;
	    b.x2 = x + w;
	    b.y2 = y + h;      
	 } else {
	    b = *box;
	 }


	 if (b.x1 > b.x2 ||
	     b.y1 > b.y2 ||
	     b.x2 > intelScreen->width ||
	     b.y2 > intelScreen->height)
	    continue;

	 if ( flags & BUFFER_BIT_FRONT_LEFT ) {	    
	    BEGIN_BATCH( 6);	    
	    OUT_BATCH( CMD );
	    OUT_BATCH( BR13 );
	    OUT_BATCH( (b.y1 << 16) | b.x1 );
	    OUT_BATCH( (b.y2 << 16) | b.x2 );
	    OUT_BATCH( intelScreen->front.offset );
	    OUT_BATCH( clear_color );
	    ADVANCE_BATCH();
	 }

	 if ( flags & BUFFER_BIT_BACK_LEFT ) {
	    BEGIN_BATCH( 6); 
	    OUT_BATCH( CMD );
	    OUT_BATCH( BR13 );
	    OUT_BATCH( (b.y1 << 16) | b.x1 );
	    OUT_BATCH( (b.y2 << 16) | b.x2 );
	    OUT_BATCH( intelScreen->back.offset );
	    OUT_BATCH( clear_color );
	    ADVANCE_BATCH();
	 }

	 if ( flags & (BUFFER_BIT_STENCIL | BUFFER_BIT_DEPTH) ) {
	    BEGIN_BATCH( 6);
	    OUT_BATCH( D_CMD );
	    OUT_BATCH( BR13 );
	    OUT_BATCH( (b.y1 << 16) | b.x1 );
	    OUT_BATCH( (b.y2 << 16) | b.x2 );
	    OUT_BATCH( intelScreen->depth.offset );
	    OUT_BATCH( clear_depth );
	    ADVANCE_BATCH();
	 }      
      }
   }
   intelFlushBatchLocked( intel, GL_TRUE, GL_FALSE, GL_TRUE );
   UNLOCK_HARDWARE( intel );
d243 3
a245 4



void intelDestroyBatchBuffer( GLcontext *ctx )
d247 4
a250 13
   intelContextPtr intel = INTEL_CONTEXT(ctx);

   if (intel->alloc.offset) {
      intelFreeAGP( intel, intel->alloc.ptr );
      intel->alloc.ptr = NULL;
      intel->alloc.offset = 0;
   }
   else if (intel->alloc.ptr) {
      free(intel->alloc.ptr);
      intel->alloc.ptr = NULL;
   }

   memset(&intel->batch, 0, sizeof(intel->batch));
d253 8
a260 2

void intelInitBatchBuffer( GLcontext *ctx )
d262 3
a264 38
   intelContextPtr intel = INTEL_CONTEXT(ctx);

   /* This path isn't really safe with rotate:
    */
   if (getenv("INTEL_BATCH") && intel->intelScreen->allow_batchbuffer) {      
      switch (intel->intelScreen->deviceID) {
      case PCI_CHIP_I865_G:
	 /* HW bug?  Seems to crash if batchbuffer crosses 4k boundary.
	  */
	 intel->alloc.size = 8 * 1024; 
	 break;
      default:
	 /* This is the smallest amount of memory the kernel deals with.
	  * We'd ideally like to make this smaller.
	  */
	 intel->alloc.size = 1 << intel->intelScreen->logTextureGranularity;
	 break;
      }

      intel->alloc.ptr = intelAllocateAGP( intel, intel->alloc.size );
      if (intel->alloc.ptr)
	 intel->alloc.offset = 
	    intelAgpOffsetFromVirtual( intel, intel->alloc.ptr );
      else
         intel->alloc.offset = 0; /* OK? */
   }

   /* The default is now to use a local buffer and pass that to the
    * kernel.  This is also a fallback if allocation fails on the
    * above path:
    */
   if (!intel->alloc.ptr) {
      intel->alloc.size = 8 * 1024;
      intel->alloc.ptr = malloc( intel->alloc.size );
      intel->alloc.offset = 0;
   }

   assert(intel->alloc.ptr);
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a370 1
   const intelScreenPrivate *intelScreen;
d385 2
a386 1
   intelScreen = intel->intelScreen;
d388 32
a419 15
   if (!rect && !intel->swap_scheduled && intelScreen->drmMinor >= 6 &&
       !(intel->vblank_flags & VBLANK_FLAG_NO_IRQ) &&
       intelScreen->current_rotation == 0) {
      unsigned int interval = driGetVBlankInterval(dPriv, intel->vblank_flags);
      unsigned int target;
      drm_i915_vblank_swap_t swap;

      swap.drawable = dPriv->hHWDrawable;
      swap.seqtype = DRM_VBLANK_ABSOLUTE;
      target = swap.sequence = intel->vbl_seq + interval;

      if (intel->vblank_flags & VBLANK_FLAG_SYNC) {
	 swap.seqtype |= DRM_VBLANK_NEXTONMISS;
      } else if (interval == 0) {
	 goto noschedule;
d421 3
d425 9
a433 3
      if ( intel->vblank_flags & VBLANK_FLAG_SECONDARY ) {
	 swap.seqtype |= DRM_VBLANK_SECONDARY;
      }
d435 1
a435 11
      if (!drmCommandWriteRead(intel->driFd, DRM_I915_VBLANK_SWAP, &swap,
                              sizeof(swap))) {
        intel->swap_scheduled = 1;
        intel->vbl_seq = swap.sequence;
        swap.sequence -= target;
        missed_target = swap.sequence > 0 && swap.sequence <= (1 << 23);
      }
   } else {
      intel->swap_scheduled = 0;
   }
noschedule:
d437 10
a446 3
   if (!intel->swap_scheduled) {
      intelWaitForFrameCompletion( intel );
      LOCK_HARDWARE( intel );
d448 2
a449 32
      if (!rect)
      {
	 UNLOCK_HARDWARE( intel );
	 driWaitForVBlank( dPriv, &intel->vbl_seq, intel->vblank_flags, & missed_target );
	 LOCK_HARDWARE( intel );
      }
      {
	 const intelScreenPrivate *intelScreen = intel->intelScreen;
	 const __DRIdrawablePrivate *dPriv = intel->driDrawable;
	 const int nbox = dPriv->numClipRects;
	 const drm_clip_rect_t *pbox = dPriv->pClipRects;
	 drm_clip_rect_t box;
	 const int cpp = intelScreen->cpp;
	 const int pitch = intelScreen->front.pitch; /* in bytes */
	 int i;
	 GLuint CMD, BR13;
	 BATCH_LOCALS;

	 switch(cpp) {
	 case 2: 
	    BR13 = (pitch) | (0xCC << 16) | (1<<24);
	    CMD = XY_SRC_COPY_BLT_CMD;
	    break;
	 case 4:
	    BR13 = (pitch) | (0xCC << 16) | (1<<24) | (1<<25);
	    CMD = (XY_SRC_COPY_BLT_CMD | XY_SRC_COPY_BLT_WRITE_ALPHA |
		   XY_SRC_COPY_BLT_WRITE_RGB);
	    break;
	 default:
	    BR13 = (pitch) | (0xCC << 16) | (1<<24);
	    CMD = XY_SRC_COPY_BLT_CMD;
	    break;
a450 3
   
	 if (0) 
	    intel_draw_performance_boxes( intel );
d452 10
a461 26
	 for (i = 0 ; i < nbox; i++, pbox++) 
	 {
	    if (pbox->x1 > pbox->x2 ||
		pbox->y1 > pbox->y2 ||
		pbox->x2 > intelScreen->width ||
		pbox->y2 > intelScreen->height) {
	       _mesa_warning(&intel->ctx, "Bad cliprect in intelCopyBuffer()");
	       continue;
	    }

	    box = *pbox;

	    if (rect)
	    {
	       if (rect->x1 > box.x1)
		  box.x1 = rect->x1;
	       if (rect->y1 > box.y1)
		  box.y1 = rect->y1;
	       if (rect->x2 < box.x2)
		  box.x2 = rect->x2;
	       if (rect->y2 < box.y2)
		  box.y2 = rect->y2;

	       if (box.x1 > box.x2 || box.y1 > box.y2)
		  continue;
	    }
d463 2
a464 5
	    BEGIN_BATCH( 8);
	    OUT_BATCH( CMD );
	    OUT_BATCH( BR13 );
	    OUT_BATCH( (box.y1 << 16) | box.x1 );
	    OUT_BATCH( (box.y2 << 16) | box.x2 );
d466 4
a469 12
	    if (intel->sarea->pf_current_page == 0) 
	       OUT_BATCH( intelScreen->front.offset );
	    else
	       OUT_BATCH( intelScreen->back.offset );			

	    OUT_BATCH( (box.y1 << 16) | box.x1 );
	    OUT_BATCH( BR13 & 0xffff );

	    if (intel->sarea->pf_current_page == 0) 
	       OUT_BATCH( intelScreen->back.offset );			
	    else
	       OUT_BATCH( intelScreen->front.offset );
d471 1
a471 2
	    ADVANCE_BATCH();
	 }
a472 2
      intelFlushBatchLocked( intel, GL_TRUE, GL_TRUE, GL_TRUE );
      UNLOCK_HARDWARE( intel );
d474 2
d586 2
a587 2
void intelClearWithBlit(GLcontext *ctx, GLbitfield buffers, GLboolean allFoo,
                        GLint cx1Foo, GLint cy1Foo, GLint cwFoo, GLint chFoo)
d592 1
a592 2
   GLint cx, cy, cw, ch;
   GLboolean all;
a601 8
   /* get clear bounds after locking */
   cx = intel->ctx.DrawBuffer->_Xmin;
   cy = intel->ctx.DrawBuffer->_Ymin;
   cw = intel->ctx.DrawBuffer->_Xmax - cx;
   ch = intel->ctx.DrawBuffer->_Ymax - cy;
   all = (cw == intel->ctx.DrawBuffer->Width &&
          ch == intel->ctx.DrawBuffer->Height);

d607 1
a607 1
   if (buffers & BUFFER_BIT_DEPTH) {
d611 1
a611 1
   if (buffers & BUFFER_BIT_STENCIL) {
d626 2
a627 2
      if (buffers & BUFFER_BIT_DEPTH) D_CMD |= XY_COLOR_BLT_WRITE_RGB;
      if (buffers & BUFFER_BIT_STENCIL) D_CMD |= XY_COLOR_BLT_WRITE_ALPHA;
d637 2
a638 2
      cy = intel->driDrawable->h - cy - ch;
      cx = cx + intel->drawX;
d643 1
a643 1
	 GLuint tmp = buffers;
d645 3
a647 3
	 buffers &= ~(BUFFER_BIT_FRONT_LEFT | BUFFER_BIT_BACK_LEFT);
	 if ( tmp & BUFFER_BIT_FRONT_LEFT ) buffers |= BUFFER_BIT_BACK_LEFT;
	 if ( tmp & BUFFER_BIT_BACK_LEFT )  buffers |= BUFFER_BIT_FRONT_LEFT;
d683 1
a683 1
	 if ( buffers & BUFFER_BIT_FRONT_LEFT ) {	    
d694 1
a694 1
	 if ( buffers & BUFFER_BIT_BACK_LEFT ) {
d705 1
a705 1
	 if ( buffers & (BUFFER_BIT_STENCIL | BUFFER_BIT_DEPTH) ) {
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2006 Tungsten Graphics, Inc., Cedar Park, Texas.
d28 11
a39 5
#include "intel_batchbuffer.h"
#include "intel_buffer_objects.h"
#include "intel_reg.h"
#include "intel_bufmgr.h"
#include "intel_buffers.h"
a40 2
static void
intel_batchbuffer_reset(struct intel_context *intel);
d42 10
a51 2
void
intel_batchbuffer_init(struct intel_context *intel)
d53 2
a54 1
   intel_batchbuffer_reset(intel);
d56 10
a65 2
   intel->batch.cpu_map = malloc(intel->maxBatchSize);
   intel->batch.map = intel->batch.cpu_map;
d68 1
a68 2
static void
intel_batchbuffer_reset(struct intel_context *intel)
d70 36
a105 3
   if (intel->batch.last_bo != NULL) {
      drm_intel_bo_unreference(intel->batch.last_bo);
      intel->batch.last_bo = NULL;
d107 5
a111 1
   intel->batch.last_bo = intel->batch.bo;
a112 2
   intel->batch.bo = drm_intel_bo_alloc(intel->bufmgr, "batchbuffer",
					intel->maxBatchSize, 4096);
d114 23
a136 2
   intel->batch.reserved_space = BATCH_RESERVED;
   intel->batch.used = 0;
d139 1
a139 2
void
intel_batchbuffer_free(struct intel_context *intel)
d141 49
a189 3
   free(intel->batch.cpu_map);
   drm_intel_bo_unreference(intel->batch.last_bo);
   drm_intel_bo_unreference(intel->batch.bo);
d192 4
a195 2
static void
do_batch_dump(struct intel_context *intel)
d197 4
a200 3
   struct drm_intel_decode *decode;
   struct intel_batchbuffer *batch = &intel->batch;
   int ret;
a201 3
   decode = drm_intel_decode_context_alloc(intel->intelScreen->deviceID);
   if (!decode)
      return;
d203 14
a216 10
   ret = drm_intel_bo_map(batch->bo, false);
   if (ret == 0) {
      drm_intel_decode_set_batch_pointer(decode,
					 batch->bo->virtual,
					 batch->bo->offset,
					 batch->used);
   } else {
      fprintf(stderr,
	      "WARNING: failed to map batchbuffer (%s), "
	      "dumping uploaded data instead.\n", strerror(ret));
d218 5
a222 4
      drm_intel_decode_set_batch_pointer(decode,
					 batch->map,
					 batch->bo->offset,
					 batch->used);
d224 16
a240 1
   drm_intel_decode(decode);
d242 8
a249 1
   drm_intel_decode_context_free(decode);
a250 2
   if (ret == 0) {
      drm_intel_bo_unmap(batch->bo);
d252 10
a261 3
      if (intel->vtbl.debug_batch != NULL)
	 intel->vtbl.debug_batch(intel);
   }
d264 2
a265 1
/* TODO: Push this whole function into bufmgr.
d267 4
a270 2
static int
do_flush_locked(struct intel_context *intel)
d272 2
a273 2
   struct intel_batchbuffer *batch = &intel->batch;
   int ret = 0;
d275 2
a276 1
   ret = drm_intel_bo_subdata(batch->bo, 0, 4*batch->used, batch->map);
d278 25
a302 6
   if (!intel->intelScreen->no_hw) {
      if (ret == 0) {
         if (unlikely(INTEL_DEBUG & DEBUG_AUB) && intel->vtbl.annotate_aub)
            intel->vtbl.annotate_aub(intel);
         ret = drm_intel_bo_mrb_exec(batch->bo, 4 * batch->used, NULL, 0, 0,
                                     I915_EXEC_RENDER);
d304 8
d314 6
a319 2
   if (unlikely(INTEL_DEBUG & DEBUG_BATCH))
      do_batch_dump(intel);
d321 6
a326 5
   if (ret != 0) {
      fprintf(stderr, "intel_do_flush_locked failed: %s\n", strerror(-ret));
      exit(1);
   }
   intel->vtbl.new_batch(intel);
d328 2
a329 1
   return ret;
d332 2
a333 3
int
_intel_batchbuffer_flush(struct intel_context *intel,
			 const char *file, int line)
d335 1
a335 1
   int ret;
d337 11
a347 2
   if (intel->batch.used == 0)
      return 0;
d349 12
a360 3
   if (intel->first_post_swapbuffers_batch == NULL) {
      intel->first_post_swapbuffers_batch = intel->batch.bo;
      drm_intel_bo_reference(intel->first_post_swapbuffers_batch);
d362 1
d364 56
a419 3
   if (unlikely(INTEL_DEBUG & DEBUG_BATCH))
      fprintf(stderr, "%s:%d: Batchbuffer flush with %db used\n", file, line,
	      4*intel->batch.used);
d421 86
a506 1
   intel->batch.reserved_space = 0;
d508 6
a513 2
   if (intel->vtbl.finish_batch)
      intel->vtbl.finish_batch(intel);
d515 10
a524 5
   /* Mark the end of the buffer. */
   intel_batchbuffer_emit_dword(intel, MI_BATCH_BUFFER_END);
   if (intel->batch.used & 1) {
      /* Round batchbuffer usage to 2 DWORDs. */
      intel_batchbuffer_emit_dword(intel, MI_NOOP);
d526 1
a527 1
   intel_upload_finish(intel);
a528 2
   /* Check that we didn't just wrap our batchbuffer at a bad time. */
   assert(!intel->no_batch_wrap);
a529 1
   ret = do_flush_locked(intel);
d531 25
a555 3
   if (unlikely(INTEL_DEBUG & DEBUG_SYNC)) {
      fprintf(stderr, "waiting for idle\n");
      drm_intel_bo_wait_rendering(intel->batch.bo);
d558 8
a565 5
   /* Reset the buffer:
    */
   intel_batchbuffer_reset(intel);

   return ret;
d569 1
a569 1
/*  This is the only way buffers get added to the validate list.
d571 9
a579 5
bool
intel_batchbuffer_emit_reloc(struct intel_context *intel,
                             drm_intel_bo *buffer,
                             uint32_t read_domains, uint32_t write_domain,
			     uint32_t delta)
d581 23
a603 1
   int ret;
d605 16
a620 5
   ret = drm_intel_bo_emit_reloc(intel->batch.bo, 4*intel->batch.used,
				 buffer, delta,
				 read_domains, write_domain);
   assert(ret == 0);
   (void)ret;
a621 6
   /*
    * Using the old buffer offset, write in what the right data would be, in case
    * the buffer doesn't move and we can short-circuit the relocation processing
    * in the kernel
    */
   intel_batchbuffer_emit_dword(intel, buffer->offset + delta);
a622 2
   return true;
}
d624 2
a625 6
bool
intel_batchbuffer_emit_reloc_fenced(struct intel_context *intel,
				    drm_intel_bo *buffer,
				    uint32_t read_domains,
				    uint32_t write_domain,
				    uint32_t delta)
d627 21
a647 1
   int ret;
d649 1
a649 5
   ret = drm_intel_bo_emit_reloc_fence(intel->batch.bo, 4*intel->batch.used,
				       buffer, delta,
				       read_domains, write_domain);
   assert(ret == 0);
   (void)ret;
d651 45
a695 6
   /*
    * Using the old buffer offset, write in what the right data would
    * be, in case the buffer doesn't move and we can short-circuit the
    * relocation processing in the kernel
    */
   intel_batchbuffer_emit_dword(intel, buffer->offset + delta);
d697 69
a765 1
   return true;
d768 4
a771 3
void
intel_batchbuffer_data(struct intel_context *intel,
                       const void *data, GLuint bytes)
d773 13
a785 4
   assert((bytes & 3) == 0);
   intel_batchbuffer_require_space(intel, bytes);
   __memcpy(intel->batch.map + intel->batch.used, data, bytes);
   intel->batch.used += bytes >> 2;
d788 2
a789 8
/* Emit a pipelined flush to either flush render and texture cache for
 * reading from a FBO-drawn texture, or flush so that frontbuffer
 * render appears on the screen in DRI1.
 *
 * This is also used for the always_flush_cache driconf debug option.
 */
void
intel_batchbuffer_emit_mi_flush(struct intel_context *intel)
d791 38
a828 3
   BEGIN_BATCH(1);
   OUT_BATCH(MI_FLUSH);
   ADVANCE_BATCH();
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2006 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
@


