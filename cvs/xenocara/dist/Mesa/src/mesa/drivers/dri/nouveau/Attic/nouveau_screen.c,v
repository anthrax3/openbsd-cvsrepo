head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v7_0_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.8;
commitid	4ry2gvZGMXkCUD2n;

1.8
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.7;
commitid	mcxB0JvoI9gTDYXU;

1.7
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.14.04.49;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.24.19.03.21;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.20;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.16;	author matthieu;	state dead;
branches;
next	1.1;

1.1
date	2007.11.24.17.28.59;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.17.28.59;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.39;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.15.51;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.54;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.11.59;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.49.06;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright (C) 2009 Francisco Jerez.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "nouveau_driver.h"
#include "nouveau_context.h"
#include "nouveau_fbo.h"
#include "nouveau_texture.h"
#include "nv04_driver.h"
#include "nv10_driver.h"
#include "nv20_driver.h"

#include "main/framebuffer.h"
#include "main/fbobject.h"
#include "main/renderbuffer.h"
#include "swrast/s_renderbuffer.h"

static const __DRIextension *nouveau_screen_extensions[];

static void
nouveau_destroy_screen(__DRIscreen *dri_screen);

static const __DRIconfig **
nouveau_get_configs(void)
{
	__DRIconfig **configs = NULL;
	int i;

	const uint8_t depth_bits[]   = { 0, 16, 24, 24 };
	const uint8_t stencil_bits[] = { 0,  0,  0,  8 };
	const uint8_t msaa_samples[] = { 0 };

	static const mesa_format formats[3] = {
		MESA_FORMAT_B5G6R5_UNORM,
		MESA_FORMAT_B8G8R8A8_UNORM,
		MESA_FORMAT_B8G8R8X8_UNORM,
	};

	const GLenum back_buffer_modes[] = {
		GLX_NONE, GLX_SWAP_UNDEFINED_OML
	};

	for (i = 0; i < Elements(formats); i++) {
		__DRIconfig **config;

		config = driCreateConfigs(formats[i],
					  depth_bits, stencil_bits,
					  Elements(depth_bits),
					  back_buffer_modes,
					  Elements(back_buffer_modes),
					  msaa_samples,
					  Elements(msaa_samples),
					  GL_TRUE);
		assert(config);

		configs = driConcatConfigs(configs, config);
	}

	return (const __DRIconfig **)configs;
}

static const __DRIconfig **
nouveau_init_screen2(__DRIscreen *dri_screen)
{
	const __DRIconfig **configs;
	struct nouveau_screen *screen;
	int ret;

	/* Allocate the screen. */
	screen = CALLOC_STRUCT(nouveau_screen);
	if (!screen)
		return NULL;

	/* Open the DRM device. */
	ret = nouveau_device_wrap(dri_screen->fd, 0, &screen->device);
	if (ret) {
		nouveau_error("Error opening the DRM device.\n");
		goto fail;
	}

	/* Choose the card specific function pointers. */
	switch (screen->device->chipset & 0xf0) {
	case 0x00:
		screen->driver = &nv04_driver;
		break;
	case 0x10:
		screen->driver = &nv10_driver;
		break;
	case 0x20:
		screen->driver = &nv20_driver;
		break;
	default:
		assert(0);
	}

	/* Compat version validation will occur at context init after
	 * _mesa_compute_version().
	 */
	dri_screen->max_gl_compat_version = 15;

	/* NV10 and NV20 can support OpenGL ES 1.0 only.  Older chips
	 * cannot do even that.
	 */
	if ((screen->device->chipset & 0xf0) != 0x00)
		dri_screen->max_gl_es1_version = 10;

	dri_screen->driverPrivate = screen;
	dri_screen->extensions = nouveau_screen_extensions;
	screen->dri_screen = dri_screen;

	configs = nouveau_get_configs();
	if (!configs)
		goto fail;

	return configs;
fail:
	nouveau_destroy_screen(dri_screen);
	return NULL;

}

static void
nouveau_destroy_screen(__DRIscreen *dri_screen)
{
	struct nouveau_screen *screen = dri_screen->driverPrivate;

	if (!screen)
		return;

	nouveau_device_del(&screen->device);

	free(screen);
	dri_screen->driverPrivate = NULL;
}

static GLboolean
nouveau_create_buffer(__DRIscreen *dri_screen,
		      __DRIdrawable *drawable,
		      const struct gl_config *visual,
		      GLboolean is_pixmap)
{
	struct gl_renderbuffer *rb;
	struct gl_framebuffer *fb;
	GLenum color_format;

	if (is_pixmap)
		return GL_FALSE; /* not implemented */

	if (visual->redBits == 5)
		color_format = GL_RGB5;
	else if (visual->alphaBits == 0)
		color_format = GL_RGB8;
	else
		color_format = GL_RGBA8;

	fb = nouveau_framebuffer_dri_new(visual);
	if (!fb)
		return GL_FALSE;

	/* Front buffer. */
	rb = nouveau_renderbuffer_dri_new(color_format, drawable);
	_mesa_add_renderbuffer(fb, BUFFER_FRONT_LEFT, rb);

	/* Back buffer */
	if (visual->doubleBufferMode) {
		rb = nouveau_renderbuffer_dri_new(color_format, drawable);
		_mesa_add_renderbuffer(fb, BUFFER_BACK_LEFT, rb);
	}

	/* Depth/stencil buffer. */
	if (visual->depthBits == 24 && visual->stencilBits == 8) {
		rb = nouveau_renderbuffer_dri_new(GL_DEPTH24_STENCIL8_EXT, drawable);
		_mesa_add_renderbuffer(fb, BUFFER_DEPTH, rb);
		_mesa_add_renderbuffer(fb, BUFFER_STENCIL, rb);

	} else if (visual->depthBits == 24) {
		rb = nouveau_renderbuffer_dri_new(GL_DEPTH_COMPONENT24, drawable);
		_mesa_add_renderbuffer(fb, BUFFER_DEPTH, rb);

	} else if (visual->depthBits == 16) {
		rb = nouveau_renderbuffer_dri_new(GL_DEPTH_COMPONENT16, drawable);
		_mesa_add_renderbuffer(fb, BUFFER_DEPTH, rb);
	}

	/* Software renderbuffers. */
	_swrast_add_soft_renderbuffers(fb, GL_FALSE, GL_FALSE, GL_FALSE,
                                       visual->accumRedBits > 0,
                                       GL_FALSE, GL_FALSE);

	drawable->driverPrivate = fb;

	return GL_TRUE;
}

static void
nouveau_destroy_buffer(__DRIdrawable *drawable)
{
	_mesa_reference_framebuffer(
		(struct gl_framebuffer **)&drawable->driverPrivate, NULL);
}

static void
nouveau_drawable_flush(__DRIdrawable *draw)
{
}

static const struct __DRI2flushExtensionRec nouveau_flush_extension = {
   .base = { __DRI2_FLUSH, 3 },

   .flush               = nouveau_drawable_flush,
   .invalidate          = dri2InvalidateDrawable,
};

static const struct __DRItexBufferExtensionRec nouveau_texbuffer_extension = {
   .base = { __DRI_TEX_BUFFER, 3 },

   .setTexBuffer        = NULL,
   .setTexBuffer2       = nouveau_set_texbuffer,
   .releaseTexBuffer    = NULL,
};

static const __DRIextension *nouveau_screen_extensions[] = {
    &nouveau_flush_extension.base,
    &nouveau_texbuffer_extension.base,
    &dri2ConfigQueryExtension.base,
    NULL
};

const struct __DriverAPIRec nouveau_driver_api = {
	.InitScreen      = nouveau_init_screen2,
	.DestroyScreen   = nouveau_destroy_screen,
	.CreateBuffer    = nouveau_create_buffer,
	.DestroyBuffer   = nouveau_destroy_buffer,
	.CreateContext   = nouveau_context_create,
	.DestroyContext  = nouveau_context_destroy,
	.MakeCurrent     = nouveau_context_make_current,
	.UnbindContext   = nouveau_context_unbind,
};

static const struct __DRIDriverVtableExtensionRec nouveau_vtable = {
   .base = { __DRI_DRIVER_VTABLE, 1 },
   .vtable = &nouveau_driver_api,
};

/* This is the table of extensions that the loader will dlsym() for. */
static const __DRIextension *nouveau_driver_extensions[] = {
	&driCoreExtension.base,
	&driDRI2Extension.base,
	&nouveau_vtable.base,
	NULL
};

PUBLIC const __DRIextension **__driDriverGetExtensions_nouveau_vieux(void)
{
   globalDriverAPI = &nouveau_driver_api;

   return nouveau_driver_extensions;
}
@


1.9
log
@Merge Mesa 10.2.9
@
text
@@


1.8
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a26 2
#include <xf86drm.h>
#include <nouveau_drm.h>
a95 2
	dri_screen->driverPrivate = screen;

a106 1
		dri_screen->max_gl_compat_version = 12;
a109 2
		dri_screen->max_gl_compat_version = 12;
		dri_screen->max_gl_es1_version = 10;
a112 2
		dri_screen->max_gl_compat_version = 13;
		dri_screen->max_gl_es1_version = 10;
d115 1
a115 3
		nouveau_error("Unknown chipset: %02X\n",
			      screen->device->chipset);
		goto fail;
d118 12
a143 63
static int
nouveau_query_renderer_integer(__DRIscreen *psp, int param,
			       unsigned int *value)
{
	const struct nouveau_screen *const screen =
		(struct nouveau_screen *) psp->driverPrivate;

	switch (param) {
	case __DRI2_RENDERER_VENDOR_ID:
		value[0] = 0x10de;
		return 0;
	case __DRI2_RENDERER_DEVICE_ID: {
		uint64_t device_id;

		if (nouveau_getparam(screen->device,
				     NOUVEAU_GETPARAM_PCI_DEVICE,
				     &device_id)) {
			nouveau_error("Error retrieving the device PCIID.\n");
			device_id = -1;
		}
		value[0] = (unsigned int) device_id;
		return 0;
	}
	case __DRI2_RENDERER_ACCELERATED:
		value[0] = 1;
		return 0;
	case __DRI2_RENDERER_VIDEO_MEMORY:
		/* XXX: return vram_size or vram_limit ? */
		value[0] = screen->device->vram_size >> 20;
		return 0;
	case __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE:
		value[0] = 0;
		return 0;
	default:
		return driQueryRendererIntegerCommon(psp, param, value);
	}
}

static int
nouveau_query_renderer_string(__DRIscreen *psp, int param, const char **value)
{
	const struct nouveau_screen *const screen =
		(struct nouveau_screen *) psp->driverPrivate;

	switch (param) {
	case __DRI2_RENDERER_VENDOR_ID:
		value[0] = nouveau_vendor_string;
		return 0;
	case __DRI2_RENDERER_DEVICE_ID:
		value[0] = nouveau_get_renderer_string(screen->device->chipset);
		return 0;
	default:
		return -1;
   }
}

static const __DRI2rendererQueryExtension nouveau_renderer_query_extension = {
	.base = { __DRI2_RENDERER_QUERY, 1 },

	.queryInteger        = nouveau_query_renderer_integer,
	.queryString         = nouveau_query_renderer_string
};

a246 1
    &nouveau_renderer_query_extension.base,
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d27 2
d98 2
d111 1
d115 2
d120 2
d124 3
a126 1
		assert(0);
a128 12
	/* Compat version validation will occur at context init after
	 * _mesa_compute_version().
	 */
	dri_screen->max_gl_compat_version = 15;

	/* NV10 and NV20 can support OpenGL ES 1.0 only.  Older chips
	 * cannot do even that.
	 */
	if ((screen->device->chipset & 0xf0) != 0x00)
		dri_screen->max_gl_es1_version = 10;

	dri_screen->driverPrivate = screen;
d143 63
d309 1
@


1.6
log
@Merge Mesa 9.2.0
@
text
@d55 4
a58 4
	static const gl_format formats[3] = {
		MESA_FORMAT_RGB565,
		MESA_FORMAT_ARGB8888,
		MESA_FORMAT_XRGB8888,
a95 4
	dri_screen->driverPrivate = screen;
	dri_screen->extensions = nouveau_screen_extensions;
	screen->dri_screen = dri_screen;

d118 15
d230 4
a233 3
    { __DRI2_FLUSH, 3 },
    nouveau_drawable_flush,
    dri2InvalidateDrawable,
d237 5
a241 3
    { __DRI_TEX_BUFFER, __DRI_TEX_BUFFER_VERSION },
    NULL,
    nouveau_set_texbuffer,
d251 1
a251 1
const struct __DriverAPIRec driDriverAPI = {
d262 5
d268 1
a268 1
PUBLIC const __DRIextension *__driDriverExtensions[] = {
d271 1
d274 7
@


1.5
log
@Merge Mesa 7.10.3
@
text
@a30 1
#include "nouveau_drmif.h"
d36 1
d38 1
d55 4
a58 7
	const struct {
		GLenum format;
		GLenum type;
	} fb_formats[] = {
		{ GL_RGB , GL_UNSIGNED_SHORT_5_6_5     },
		{ GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV },
		{ GL_BGR , GL_UNSIGNED_INT_8_8_8_8_REV },
d65 1
a65 1
	for (i = 0; i < Elements(fb_formats); i++) {
d68 1
a68 2
		config = driCreateConfigs(fb_formats[i].format,
					  fb_formats[i].type,
d78 1
a78 2
		configs = configs ? driConcatConfigs(configs, config)
			: config;
d96 1
a96 1
	dri_screen->private = screen;
d101 1
a101 2
	ret = nouveau_device_open_existing(&screen->device, 0, dri_screen->fd,
					   0);
d136 1
a136 1
	struct nouveau_screen *screen = dri_screen->private;
d141 1
a141 2
	if (screen->device)
		nouveau_device_close(&screen->device);
d143 2
a144 2
	FREE(screen);
	dri_screen->private = NULL;
d197 3
a199 3
	_mesa_add_soft_renderbuffers(fb, GL_FALSE, GL_FALSE, GL_FALSE,
				     visual->accumRedBits > 0,
				     GL_FALSE, GL_FALSE);
d219 1
a219 1
    { __DRI2_FLUSH, __DRI2_FLUSH_VERSION },
d238 1
a238 1
	.InitScreen2     = nouveau_init_screen2,
@


1.4
log
@Two patches cherry picked from mesa master just after 7.8 was branched
(but never made it into the 7.8 branch).

first:
Author: Jesse Barnes <jbarnes@@virtuousgeek.org>
Date:   Thu Apr 22 12:47:41 2010 -0700

    DRI2: add config query extension

    Add a new DRI2 configuration query extension.  Allows for DRI2
    client code to query for common DRI2 configuration options.

second:
Author: Jesse Barnes <jbarnes@@virtuousgeek.org>
Date:   Thu Apr 22 12:49:03 2010 -0700

    DRI2/GLX: check for vblank_mode in DRI2 GLX code

    Re-add support for the vblank_mode environment and configuration
    variable.  Useful for benchmarking and app control.

The final affect being that config and environment variables for
controlling swap mode work with dri2 now. which helps me a lot with
debugging.

ok matthieu@@.
@
text
@d156 1
a156 1
		      const __GLcontextModes *visual,
d159 1
a159 1
	struct gl_renderbuffer  *rb;
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d239 1
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d1 25
a25 1
/**************************************************************************
d27 8
a34 2
Copyright 2006 Stephane Marchesin
All Rights Reserved.
d36 2
a37 26
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
on the rights to use, copy, modify, merge, publish, distribute, sub
license, and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
ERIC ANHOLT OR SILICON INTEGRATED SYSTEMS CORP BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

#include "glheader.h"
#include "imports.h"
#include "mtypes.h"
#include "framebuffer.h"
#include "renderbuffer.h"
d39 4
a42 28
#include "nouveau_context.h"
#include "nouveau_screen.h"
#include "nouveau_object.h"
#include "nouveau_span.h"

#include "utils.h"
#include "context.h"
#include "vblank.h"
#include "drirenderbuffer.h"

#include "GL/internal/dri_interface.h"

#include "xmlpool.h"

PUBLIC const char __driConfigOptions[] =
DRI_CONF_BEGIN
    DRI_CONF_SECTION_DEBUG
        DRI_CONF_NO_RAST(false)
    DRI_CONF_SECTION_END
DRI_CONF_END;
static const GLuint __driNConfigOptions = 1;

extern const struct dri_extension common_extensions[];
extern const struct dri_extension nv10_extensions[];
extern const struct dri_extension nv20_extensions[];
extern const struct dri_extension nv30_extensions[];
extern const struct dri_extension nv40_extensions[];
extern const struct dri_extension nv50_extensions[];
d44 2
a45 1
static nouveauScreenPtr nouveauCreateScreen(__DRIscreenPrivate *sPriv)
d47 22
a68 2
	nouveauScreenPtr screen;
	NOUVEAUDRIPtr dri_priv=(NOUVEAUDRIPtr)sPriv->pDevPriv;
d70 13
a82 5
	/* allocate screen */
	screen = (nouveauScreenPtr) CALLOC( sizeof(*screen) );
	if ( !screen ) {         
		__driUtilMessage("%s: Could not allocate memory for screen structure",__FUNCTION__);
		return NULL;
d84 14
a97 6
	
	screen->card=nouveau_card_lookup(dri_priv->device_id);
	if (!screen->card) {
		__driUtilMessage("%s: Unknown card type 0x%04x:0x%04x\n",
			__func__, dri_priv->device_id >> 16, dri_priv->device_id & 0xFFFF);
		FREE(screen);
d99 11
d112 14
a125 2
	/* parse information in __driConfigOptions */
	driParseOptionInfo (&screen->optionCache,__driConfigOptions, __driNConfigOptions);
d127 8
a134 7
	screen->fbFormat    = dri_priv->bpp / 8;
	screen->frontOffset = dri_priv->front_offset;
	screen->frontPitch  = dri_priv->front_pitch;
	screen->backOffset  = dri_priv->back_offset;
	screen->backPitch   = dri_priv->back_pitch;
	screen->depthOffset = dri_priv->depth_offset;
	screen->depthPitch  = dri_priv->depth_pitch;
a135 2
	screen->driScreen = sPriv;
	return screen;
d139 1
a139 1
nouveauDestroyScreen(__DRIscreenPrivate *sPriv)
d141 1
a141 1
	nouveauScreenPtr screen = (nouveauScreenPtr)sPriv->private;
d143 2
a144 1
	if (!screen) return;
d146 2
a147 2
	/* free all option information */
	driDestroyOptionInfo (&screen->optionCache);
d150 1
a150 12
	sPriv->private = NULL;
}

static GLboolean nouveauInitDriver(__DRIscreenPrivate *sPriv)
{
	sPriv->private = (void *) nouveauCreateScreen( sPriv );
	if ( !sPriv->private ) {
		nouveauDestroyScreen( sPriv );
		return GL_FALSE;
	}

	return GL_TRUE;
a152 6
/**
 * Create the Mesa framebuffer and renderbuffers for a given window/drawable.
 *
 * \todo This function (and its interface) will need to be updated to support
 * pbuffers.
 */
d154 4
a157 4
nouveauCreateBuffer(__DRIscreenPrivate *driScrnPriv,
                    __DRIdrawablePrivate *driDrawPriv,
                    const __GLcontextModes *mesaVis,
                    GLboolean isPixmap)
d159 1
a159 2
	nouveauScreenPtr screen = (nouveauScreenPtr) driScrnPriv->private;
	nouveau_renderbuffer  *nrb;
d161 1
a161 3
	const GLboolean swAccum = mesaVis->accumRedBits > 0;
	const GLboolean swStencil = mesaVis->stencilBits > 0 && mesaVis->depthBits != 24;
	GLenum color_format = screen->fbFormat == 4 ? GL_RGBA8 : GL_RGB5;
d163 1
a163 1
	if (isPixmap)
d166 8
a173 1
	fb = _mesa_create_framebuffer(mesaVis);
d177 23
a199 39
	/* Front buffer */
	nrb = nouveau_renderbuffer_new(color_format,
				       driScrnPriv->pFB + screen->frontOffset,
				       screen->frontOffset,
				       screen->frontPitch * screen->fbFormat,
				       driDrawPriv);
	nouveauSpanSetFunctions(nrb, mesaVis);
	_mesa_add_renderbuffer(fb, BUFFER_FRONT_LEFT, &nrb->mesa);

	if (0 /* unified buffers if we choose to support them.. */) {
	} else {
		if (mesaVis->doubleBufferMode) {
			nrb = nouveau_renderbuffer_new(color_format, NULL,
						       0, 0,
						       NULL);
			nouveauSpanSetFunctions(nrb, mesaVis);
			_mesa_add_renderbuffer(fb, BUFFER_BACK_LEFT, &nrb->mesa);
		}

		if (mesaVis->depthBits == 24 && mesaVis->stencilBits == 8) {
			nrb = nouveau_renderbuffer_new(GL_DEPTH24_STENCIL8_EXT, NULL,
						       0, 0,
						       NULL);
			nouveauSpanSetFunctions(nrb, mesaVis);
			_mesa_add_renderbuffer(fb, BUFFER_DEPTH, &nrb->mesa);
			_mesa_add_renderbuffer(fb, BUFFER_STENCIL, &nrb->mesa);
		} else if (mesaVis->depthBits == 24) {
			nrb = nouveau_renderbuffer_new(GL_DEPTH_COMPONENT24, NULL,
						       0, 0,
						       NULL);
			nouveauSpanSetFunctions(nrb, mesaVis);
			_mesa_add_renderbuffer(fb, BUFFER_DEPTH, &nrb->mesa);
		} else if (mesaVis->depthBits == 16) {
			nrb = nouveau_renderbuffer_new(GL_DEPTH_COMPONENT16, NULL,
						       0, 0,
						       NULL);
			nouveauSpanSetFunctions(nrb, mesaVis);
			_mesa_add_renderbuffer(fb, BUFFER_DEPTH, &nrb->mesa);
		}
d202 4
a205 7
	_mesa_add_soft_renderbuffers(fb,
				     GL_FALSE, /* color */
				     GL_FALSE, /* depth */
				     swStencil,
				     swAccum,
				     GL_FALSE, /* alpha */
				     GL_FALSE  /* aux */);
d207 3
a209 2
	driDrawPriv->driverPrivate = (void *) fb;
	return (driDrawPriv->driverPrivate != NULL);
a211 1

d213 1
a213 1
nouveauDestroyBuffer(__DRIdrawablePrivate *driDrawPriv)
d215 2
a216 1
	_mesa_unreference_framebuffer((GLframebuffer **)(&(driDrawPriv->driverPrivate)));
d219 2
a220 2
static int
nouveauGetSwapInfo(__DRIdrawablePrivate *dpriv, __DRIswapInfo *sInfo)
a221 1
	return -1;
d224 4
a227 16
static const struct __DriverAPIRec nouveauAPI = {
	.InitDriver      = nouveauInitDriver,
	.DestroyScreen   = nouveauDestroyScreen,
	.CreateContext   = nouveauCreateContext,
	.DestroyContext  = nouveauDestroyContext,
	.CreateBuffer    = nouveauCreateBuffer,
	.DestroyBuffer   = nouveauDestroyBuffer,
	.SwapBuffers     = nouveauSwapBuffers,
	.MakeCurrent     = nouveauMakeCurrent,
	.UnbindContext   = nouveauUnbindContext,
	.GetSwapInfo     = nouveauGetSwapInfo,
	.GetMSC          = driGetMSC32,
	.WaitForMSC      = driWaitForMSC32,
	.WaitForSBC      = NULL,
	.SwapBuffersMSC  = NULL,
	.CopySubBuffer   = nouveauCopySubBuffer
d230 5
d236 5
a240 10
static __GLcontextModes *
nouveauFillInModes( unsigned pixel_bits, unsigned depth_bits,
		 unsigned stencil_bits, GLboolean have_back_buffer )
{
	__GLcontextModes * modes;
	__GLcontextModes * m;
	unsigned num_modes;
	unsigned depth_buffer_factor;
	unsigned back_buffer_factor;
	int i;
d242 10
a251 138
	static const struct {
		GLenum format;
		GLenum type;
	} fb_format_array[] = {
		{ GL_RGB , GL_UNSIGNED_SHORT_5_6_5     },
		{ GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV },
		{ GL_BGR , GL_UNSIGNED_INT_8_8_8_8_REV },
	};

	/* GLX_SWAP_COPY_OML is only supported because the Intel driver doesn't
	 * support pageflipping at all.
	 */
	static const GLenum back_buffer_modes[] = {
		GLX_NONE, GLX_SWAP_UNDEFINED_OML, GLX_SWAP_COPY_OML
	};

	u_int8_t depth_bits_array[4]   = { 0, 16, 24, 24 };
	u_int8_t stencil_bits_array[4] = { 0,  0,  0,  8 };

	depth_buffer_factor = 4;
	back_buffer_factor  = (have_back_buffer) ? 3 : 1;

	num_modes = ((pixel_bits==16) ? 1 : 2) *
		depth_buffer_factor * back_buffer_factor * 4;
	modes = (*dri_interface->createContextModes)(num_modes,
						     sizeof(__GLcontextModes));
	m = modes;

	for (i=((pixel_bits==16)?0:1);i<((pixel_bits==16)?1:3);i++) {
		if (!driFillInModes(&m, fb_format_array[i].format,
					fb_format_array[i].type,
					depth_bits_array,
					stencil_bits_array,
					depth_buffer_factor,
					back_buffer_modes,
					back_buffer_factor,
					GLX_TRUE_COLOR)) {
		fprintf( stderr, "[%s:%u] Error creating FBConfig!\n",
				__func__, __LINE__ );
		return NULL;
		}

		if (!driFillInModes(&m, fb_format_array[i].format,
					fb_format_array[i].type,
					depth_bits_array,
					stencil_bits_array,
					depth_buffer_factor,
					back_buffer_modes,
					back_buffer_factor,
					GLX_DIRECT_COLOR)) {
		fprintf( stderr, "[%s:%u] Error creating FBConfig!\n",
				__func__, __LINE__ );
		return NULL;
		}
	}

	return modes;
}


/**
 * This is the bootstrap function for the driver.  libGL supplies all of the
 * requisite information about the system, and the driver initializes itself.
 * This routine also fills in the linked list pointed to by \c driver_modes
 * with the \c __GLcontextModes that the driver can support for windows or
 * pbuffers.
 * 
 * \return A pointer to a \c __DRIscreenPrivate on success, or \c NULL on 
 *         failure.
 */
PUBLIC
void * __driCreateNewScreen_20050727( __DRInativeDisplay *dpy, int scrn, __DRIscreen *psc,
				     const __GLcontextModes * modes,
				     const __DRIversion * ddx_version,
				     const __DRIversion * dri_version,
				     const __DRIversion * drm_version,
				     const __DRIframebuffer * frame_buffer,
				     drmAddress pSAREA, int fd, 
				     int internal_api_version,
				     const __DRIinterfaceMethods * interface,
				     __GLcontextModes ** driver_modes)
			     
{
	__DRIscreenPrivate *psp;
	static const __DRIversion ddx_expected = { 1, 2, 0 };
	static const __DRIversion dri_expected = { 4, 0, 0 };
	static const __DRIversion drm_expected = { 0, 0, NOUVEAU_DRM_HEADER_PATCHLEVEL };
#if NOUVEAU_DRM_HEADER_PATCHLEVEL != 6
#error nouveau_drm.h version doesn't match expected version
#endif
	dri_interface = interface;

	if (!driCheckDriDdxDrmVersions2("nouveau",
					dri_version, & dri_expected,
					ddx_version, & ddx_expected,
					drm_version, & drm_expected)) {
		return NULL;
	}

	// temporary lock step versioning
	if (drm_expected.patch!=drm_version->patch) {
		__driUtilMessage("%s: wrong DRM version, expected %d, got %d\n",
				__func__,
				drm_expected.patch, drm_version->patch);
		return NULL;
	}

	psp = __driUtilCreateNewScreen(dpy, scrn, psc, NULL,
				       ddx_version, dri_version, drm_version,
				       frame_buffer, pSAREA, fd,
				       internal_api_version, &nouveauAPI);
	if ( psp != NULL ) {
		NOUVEAUDRIPtr dri_priv = (NOUVEAUDRIPtr)psp->pDevPriv;

		*driver_modes = nouveauFillInModes(dri_priv->bpp,
						   (dri_priv->bpp == 16) ? 16 : 24,
						   (dri_priv->bpp == 16) ? 0  : 8,
						   1
						   );

		/* Calling driInitExtensions here, with a NULL context pointer, does not actually
		 * enable the extensions.  It just makes sure that all the dispatch offsets for all
		 * the extensions that *might* be enables are known.  This is needed because the
		 * dispatch offsets need to be known when _mesa_context_create is called, but we can't
		 * enable the extensions until we have a context pointer.
		 * 
		 * Hello chicken.  Hello egg.  How are you two today?
		 */
		driInitExtensions( NULL, common_extensions, GL_FALSE );
		driInitExtensions( NULL,   nv10_extensions, GL_FALSE );
		driInitExtensions( NULL,   nv10_extensions, GL_FALSE );
		driInitExtensions( NULL,   nv30_extensions, GL_FALSE );
		driInitExtensions( NULL,   nv40_extensions, GL_FALSE );
		driInitExtensions( NULL,   nv50_extensions, GL_FALSE );
	}

	return (void *) psp;
}
d253 6
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Mesa 7.0.1
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d1 1
a1 25
/*
 * Copyright (C) 2009 Francisco Jerez.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */
d3 2
a4 8
#include "nouveau_driver.h"
#include "nouveau_context.h"
#include "nouveau_fbo.h"
#include "nouveau_texture.h"
#include "nouveau_drmif.h"
#include "nv04_driver.h"
#include "nv10_driver.h"
#include "nv20_driver.h"
d6 26
a31 2
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
d33 28
a60 4
static const __DRIextension *nouveau_screen_extensions[];

static void
nouveau_destroy_screen(__DRIscreen *dri_screen);
d62 1
a62 2
static const __DRIconfig **
nouveau_get_configs(void)
d64 2
a65 2
	__DRIconfig **configs = NULL;
	int i;
d67 5
a71 33
	const uint8_t depth_bits[]   = { 0, 16, 24, 24 };
	const uint8_t stencil_bits[] = { 0,  0,  0,  8 };
	const uint8_t msaa_samples[] = { 0 };

	const struct {
		GLenum format;
		GLenum type;
	} fb_formats[] = {
		{ GL_RGB , GL_UNSIGNED_SHORT_5_6_5     },
		{ GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV },
		{ GL_BGR , GL_UNSIGNED_INT_8_8_8_8_REV },
	};

	const GLenum back_buffer_modes[] = {
		GLX_NONE, GLX_SWAP_UNDEFINED_OML
	};

	for (i = 0; i < Elements(fb_formats); i++) {
		__DRIconfig **config;

		config = driCreateConfigs(fb_formats[i].format,
					  fb_formats[i].type,
					  depth_bits, stencil_bits,
					  Elements(depth_bits),
					  back_buffer_modes,
					  Elements(back_buffer_modes),
					  msaa_samples,
					  Elements(msaa_samples),
					  GL_TRUE);
		assert(config);

		configs = configs ? driConcatConfigs(configs, config)
			: config;
d73 6
a78 14

	return (const __DRIconfig **)configs;
}

static const __DRIconfig **
nouveau_init_screen2(__DRIscreen *dri_screen)
{
	const __DRIconfig **configs;
	struct nouveau_screen *screen;
	int ret;

	/* Allocate the screen. */
	screen = CALLOC_STRUCT(nouveau_screen);
	if (!screen)
a79 11

	dri_screen->private = screen;
	dri_screen->extensions = nouveau_screen_extensions;
	screen->dri_screen = dri_screen;

	/* Open the DRM device. */
	ret = nouveau_device_open_existing(&screen->device, 0, dri_screen->fd,
					   0);
	if (ret) {
		nouveau_error("Error opening the DRM device.\n");
		goto fail;
d82 2
a83 14
	/* Choose the card specific function pointers. */
	switch (screen->device->chipset & 0xf0) {
	case 0x00:
		screen->driver = &nv04_driver;
		break;
	case 0x10:
		screen->driver = &nv10_driver;
		break;
	case 0x20:
		screen->driver = &nv20_driver;
		break;
	default:
		assert(0);
	}
d85 7
a91 8
	configs = nouveau_get_configs();
	if (!configs)
		goto fail;

	return configs;
fail:
	nouveau_destroy_screen(dri_screen);
	return NULL;
d93 2
d98 1
a98 1
nouveau_destroy_screen(__DRIscreen *dri_screen)
d100 1
a100 1
	struct nouveau_screen *screen = dri_screen->private;
d102 1
a102 2
	if (!screen)
		return;
d104 2
a105 2
	if (screen->device)
		nouveau_device_close(&screen->device);
d108 12
a119 1
	dri_screen->private = NULL;
d122 6
d129 4
a132 4
nouveau_create_buffer(__DRIscreen *dri_screen,
		      __DRIdrawable *drawable,
		      const struct gl_config *visual,
		      GLboolean is_pixmap)
d134 2
a135 1
	struct gl_renderbuffer *rb;
d137 3
a139 1
	GLenum color_format;
d141 1
a141 1
	if (is_pixmap)
d144 1
a144 8
	if (visual->redBits == 5)
		color_format = GL_RGB5;
	else if (visual->alphaBits == 0)
		color_format = GL_RGB8;
	else
		color_format = GL_RGBA8;

	fb = nouveau_framebuffer_dri_new(visual);
d148 39
a186 8
	/* Front buffer. */
	rb = nouveau_renderbuffer_dri_new(color_format, drawable);
	_mesa_add_renderbuffer(fb, BUFFER_FRONT_LEFT, rb);

	/* Back buffer */
	if (visual->doubleBufferMode) {
		rb = nouveau_renderbuffer_dri_new(color_format, drawable);
		_mesa_add_renderbuffer(fb, BUFFER_BACK_LEFT, rb);
d189 7
a195 14
	/* Depth/stencil buffer. */
	if (visual->depthBits == 24 && visual->stencilBits == 8) {
		rb = nouveau_renderbuffer_dri_new(GL_DEPTH24_STENCIL8_EXT, drawable);
		_mesa_add_renderbuffer(fb, BUFFER_DEPTH, rb);
		_mesa_add_renderbuffer(fb, BUFFER_STENCIL, rb);

	} else if (visual->depthBits == 24) {
		rb = nouveau_renderbuffer_dri_new(GL_DEPTH_COMPONENT24, drawable);
		_mesa_add_renderbuffer(fb, BUFFER_DEPTH, rb);

	} else if (visual->depthBits == 16) {
		rb = nouveau_renderbuffer_dri_new(GL_DEPTH_COMPONENT16, drawable);
		_mesa_add_renderbuffer(fb, BUFFER_DEPTH, rb);
	}
d197 3
a199 4
	/* Software renderbuffers. */
	_mesa_add_soft_renderbuffers(fb, GL_FALSE, GL_FALSE, GL_FALSE,
				     visual->accumRedBits > 0,
				     GL_FALSE, GL_FALSE);
a200 1
	drawable->driverPrivate = fb;
d202 4
a205 1
	return GL_TRUE;
d208 2
a209 2
static void
nouveau_destroy_buffer(__DRIdrawable *drawable)
d211 1
a211 2
	_mesa_reference_framebuffer(
		(struct gl_framebuffer **)&drawable->driverPrivate, NULL);
d214 22
a235 2
static void
nouveau_drawable_flush(__DRIdrawable *draw)
d237 64
a302 5
static const struct __DRI2flushExtensionRec nouveau_flush_extension = {
    { __DRI2_FLUSH, __DRI2_FLUSH_VERSION },
    nouveau_drawable_flush,
    dri2InvalidateDrawable,
};
d304 46
a349 5
static const struct __DRItexBufferExtensionRec nouveau_texbuffer_extension = {
    { __DRI_TEX_BUFFER, __DRI_TEX_BUFFER_VERSION },
    NULL,
    nouveau_set_texbuffer,
};
d351 28
a378 6
static const __DRIextension *nouveau_screen_extensions[] = {
    &nouveau_flush_extension.base,
    &nouveau_texbuffer_extension.base,
    &dri2ConfigQueryExtension.base,
    NULL
};
d380 2
a381 10
const struct __DriverAPIRec driDriverAPI = {
	.InitScreen2     = nouveau_init_screen2,
	.DestroyScreen   = nouveau_destroy_screen,
	.CreateBuffer    = nouveau_create_buffer,
	.DestroyBuffer   = nouveau_destroy_buffer,
	.CreateContext   = nouveau_context_create,
	.DestroyContext  = nouveau_context_destroy,
	.MakeCurrent     = nouveau_context_make_current,
	.UnbindContext   = nouveau_context_unbind,
};
a382 6
/* This is the table of extensions that the loader will dlsym() for. */
PUBLIC const __DRIextension *__driDriverExtensions[] = {
	&driCoreExtension.base,
	&driDRI2Extension.base,
	NULL
};
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d31 1
a36 1
#include "main/fbobject.h"
a37 1
#include "swrast/s_renderbuffer.h"
d54 7
a60 4
	static const gl_format formats[3] = {
		MESA_FORMAT_RGB565,
		MESA_FORMAT_ARGB8888,
		MESA_FORMAT_XRGB8888,
d67 1
a67 1
	for (i = 0; i < Elements(formats); i++) {
d70 2
a71 1
		config = driCreateConfigs(formats[i],
d81 2
a82 1
		configs = driConcatConfigs(configs, config);
d100 1
a100 1
	dri_screen->driverPrivate = screen;
d105 2
a106 1
	ret = nouveau_device_wrap(dri_screen->fd, 0, &screen->device);
d141 1
a141 1
	struct nouveau_screen *screen = dri_screen->driverPrivate;
d146 2
a147 1
	nouveau_device_del(&screen->device);
d149 2
a150 2
	free(screen);
	dri_screen->driverPrivate = NULL;
d203 3
a205 3
	_swrast_add_soft_renderbuffers(fb, GL_FALSE, GL_FALSE, GL_FALSE,
                                       visual->accumRedBits > 0,
                                       GL_FALSE, GL_FALSE);
d225 1
a225 1
    { __DRI2_FLUSH, 3 },
d244 1
a244 1
	.InitScreen      = nouveau_init_screen2,
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d55 4
a58 4
	static const mesa_format formats[3] = {
		MESA_FORMAT_B5G6R5_UNORM,
		MESA_FORMAT_B8G8R8A8_UNORM,
		MESA_FORMAT_B8G8R8X8_UNORM,
d96 4
a121 15
	/* Compat version validation will occur at context init after
	 * _mesa_compute_version().
	 */
	dri_screen->max_gl_compat_version = 15;

	/* NV10 and NV20 can support OpenGL ES 1.0 only.  Older chips
	 * cannot do even that.
	 */
	if ((screen->device->chipset & 0xf0) != 0x00)
		dri_screen->max_gl_es1_version = 10;

	dri_screen->driverPrivate = screen;
	dri_screen->extensions = nouveau_screen_extensions;
	screen->dri_screen = dri_screen;

d219 3
a221 4
   .base = { __DRI2_FLUSH, 3 },

   .flush               = nouveau_drawable_flush,
   .invalidate          = dri2InvalidateDrawable,
d225 3
a227 5
   .base = { __DRI_TEX_BUFFER, 3 },

   .setTexBuffer        = NULL,
   .setTexBuffer2       = nouveau_set_texbuffer,
   .releaseTexBuffer    = NULL,
d237 1
a237 1
const struct __DriverAPIRec nouveau_driver_api = {
a247 5
static const struct __DRIDriverVtableExtensionRec nouveau_vtable = {
   .base = { __DRI_DRIVER_VTABLE, 1 },
   .vtable = &nouveau_driver_api,
};

d249 1
a249 1
static const __DRIextension *nouveau_driver_extensions[] = {
a251 1
	&nouveau_vtable.base,
a253 7

PUBLIC const __DRIextension **__driDriverGetExtensions_nouveau_vieux(void)
{
   globalDriverAPI = &nouveau_driver_api;

   return nouveau_driver_extensions;
}
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@a26 2
#include <xf86drm.h>
#include <nouveau_drm.h>
a95 2
	dri_screen->driverPrivate = screen;

a106 1
		dri_screen->max_gl_compat_version = 12;
a109 2
		dri_screen->max_gl_compat_version = 12;
		dri_screen->max_gl_es1_version = 10;
a112 2
		dri_screen->max_gl_compat_version = 13;
		dri_screen->max_gl_es1_version = 10;
d115 1
a115 3
		nouveau_error("Unknown chipset: %02X\n",
			      screen->device->chipset);
		goto fail;
d118 12
a143 63
static int
nouveau_query_renderer_integer(__DRIscreen *psp, int param,
			       unsigned int *value)
{
	const struct nouveau_screen *const screen =
		(struct nouveau_screen *) psp->driverPrivate;

	switch (param) {
	case __DRI2_RENDERER_VENDOR_ID:
		value[0] = 0x10de;
		return 0;
	case __DRI2_RENDERER_DEVICE_ID: {
		uint64_t device_id;

		if (nouveau_getparam(screen->device,
				     NOUVEAU_GETPARAM_PCI_DEVICE,
				     &device_id)) {
			nouveau_error("Error retrieving the device PCIID.\n");
			device_id = -1;
		}
		value[0] = (unsigned int) device_id;
		return 0;
	}
	case __DRI2_RENDERER_ACCELERATED:
		value[0] = 1;
		return 0;
	case __DRI2_RENDERER_VIDEO_MEMORY:
		/* XXX: return vram_size or vram_limit ? */
		value[0] = screen->device->vram_size >> 20;
		return 0;
	case __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE:
		value[0] = 0;
		return 0;
	default:
		return driQueryRendererIntegerCommon(psp, param, value);
	}
}

static int
nouveau_query_renderer_string(__DRIscreen *psp, int param, const char **value)
{
	const struct nouveau_screen *const screen =
		(struct nouveau_screen *) psp->driverPrivate;

	switch (param) {
	case __DRI2_RENDERER_VENDOR_ID:
		value[0] = nouveau_vendor_string;
		return 0;
	case __DRI2_RENDERER_DEVICE_ID:
		value[0] = nouveau_get_renderer_string(screen->device->chipset);
		return 0;
	default:
		return -1;
   }
}

static const __DRI2rendererQueryExtension nouveau_renderer_query_extension = {
	.base = { __DRI2_RENDERER_QUERY, 1 },

	.queryInteger        = nouveau_query_renderer_integer,
	.queryString         = nouveau_query_renderer_string
};

a246 1
    &nouveau_renderer_query_extension.base,
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d27 2
d98 2
d111 1
d115 2
d120 2
d124 3
a126 1
		assert(0);
a128 12
	/* Compat version validation will occur at context init after
	 * _mesa_compute_version().
	 */
	dri_screen->max_gl_compat_version = 15;

	/* NV10 and NV20 can support OpenGL ES 1.0 only.  Older chips
	 * cannot do even that.
	 */
	if ((screen->device->chipset & 0xf0) != 0x00)
		dri_screen->max_gl_es1_version = 10;

	dri_screen->driverPrivate = screen;
d143 63
d309 1
@


