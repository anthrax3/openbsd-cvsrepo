head	1.9;
access;
symbols
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2013.09.05.14.04.31;	author jsg;	state dead;
branches;
next	1.8;

1.8
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.7;

1.7
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.22.20.04.22;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.08.06.15.50.02;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.10.15.27.14;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.38;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Merge Mesa 9.2.0
@
text
@/**************************************************************************
 * 
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#ifndef INTELCONTEXT_INC
#define INTELCONTEXT_INC


#include <stdbool.h>
#include "main/mtypes.h"
#include "main/mm.h"

#ifdef __cplusplus
extern "C" {
	/* Evil hack for using libdrm in a c++ compiler. */
	#define virtual virt
#endif

#include "drm.h"
#include "intel_bufmgr.h"

#include "intel_screen.h"
#include "intel_tex_obj.h"
#include "i915_drm.h"

#ifdef __cplusplus
	#undef virtual
}
#endif

#include "tnl/t_vertex.h"

#define TAG(x) intel##x
#include "tnl_dd/t_dd_vertex.h"
#undef TAG

#define DV_PF_555  (1<<8)
#define DV_PF_565  (2<<8)
#define DV_PF_8888 (3<<8)
#define DV_PF_4444 (8<<8)
#define DV_PF_1555 (9<<8)

struct intel_region;
struct intel_context;

typedef void (*intel_tri_func) (struct intel_context *, intelVertex *,
                                intelVertex *, intelVertex *);
typedef void (*intel_line_func) (struct intel_context *, intelVertex *,
                                 intelVertex *);
typedef void (*intel_point_func) (struct intel_context *, intelVertex *);

/**
 * Bits for intel->Fallback field
 */
/*@@{*/
#define INTEL_FALLBACK_DRAW_BUFFER	 0x1
#define INTEL_FALLBACK_READ_BUFFER	 0x2
#define INTEL_FALLBACK_DEPTH_BUFFER      0x4
#define INTEL_FALLBACK_STENCIL_BUFFER    0x8
#define INTEL_FALLBACK_USER		 0x10
#define INTEL_FALLBACK_RENDERMODE	 0x20
#define INTEL_FALLBACK_TEXTURE   	 0x40
#define INTEL_FALLBACK_DRIVER            0x1000  /**< first for drivers */
/*@@}*/

extern void intelFallback(struct intel_context *intel, GLbitfield bit,
                          GLboolean mode);
#define FALLBACK( intel, bit, mode ) intelFallback( intel, bit, mode )


#define INTEL_WRITE_PART  0x1
#define INTEL_WRITE_FULL  0x2
#define INTEL_READ        0x4

#define INTEL_MAX_FIXUP 64

#ifndef likely
#ifdef __GNUC__
#define likely(expr) (__builtin_expect(expr, 1))
#define unlikely(expr) (__builtin_expect(expr, 0))
#else
#define likely(expr) (expr)
#define unlikely(expr) (expr)
#endif
#endif

struct intel_sync_object {
   struct gl_sync_object Base;

   /** Batch associated with this sync object */
   drm_intel_bo *bo;
};

/**
 * intel_context is derived from Mesa's context class: struct gl_context.
 */
struct intel_context
{
   struct gl_context ctx;  /**< base class, must be first field */

   struct
   {
      void (*destroy) (struct intel_context * intel);
      void (*emit_state) (struct intel_context * intel);
      void (*finish_batch) (struct intel_context * intel);
      void (*new_batch) (struct intel_context * intel);
      void (*emit_invarient_state) (struct intel_context * intel);
      void (*update_texture_state) (struct intel_context * intel);

      void (*render_start) (struct intel_context * intel);
      void (*render_prevalidate) (struct intel_context * intel);
      void (*set_draw_region) (struct intel_context * intel,
                               struct intel_region * draw_regions[],
                               struct intel_region * depth_region,
			       GLuint num_regions);
      void (*update_draw_buffer)(struct intel_context *intel);

      void (*reduced_primitive_state) (struct intel_context * intel,
                                       GLenum rprim);

      GLboolean (*check_vertex_size) (struct intel_context * intel,
				      GLuint expected);
      void (*invalidate_state) (struct intel_context *intel,
				GLuint new_state);

      void (*assert_not_dirty) (struct intel_context *intel);

      void (*debug_batch)(struct intel_context *intel);
      bool (*render_target_supported)(gl_format format);

      /** Can HiZ be enabled on a depthbuffer of the given format? */
      bool (*is_hiz_depth_format)(struct intel_context *intel,
	                          gl_format format);
   } vtbl;

   GLbitfield Fallback;  /**< mask of INTEL_FALLBACK_x bits */
   GLuint NewGLState;

   dri_bufmgr *bufmgr;
   unsigned int maxBatchSize;

   /**
    * Generation number of the hardware: 2 is 8xx, 3 is 9xx pre-965, 4 is 965.
    */
   int gen;
   GLboolean needs_ff_sync;
   GLboolean is_g4x;
   GLboolean is_945;
   GLboolean has_luminance_srgb;
   GLboolean has_xrgb_textures;
   GLboolean has_separate_stencil;
   GLboolean must_use_separate_stencil;
   GLboolean has_hiz;

   int urb_size;

   struct intel_batchbuffer {
      /** Current batchbuffer being queued up. */
      drm_intel_bo *bo;
      /** Last BO submitted to the hardware.  Used for glFinish(). */
      drm_intel_bo *last_bo;
      /** BO for post-sync nonzero writes for gen6 workaround. */
      drm_intel_bo *workaround_bo;
      bool need_workaround_flush;

      struct cached_batch_item *cached_items;

      uint16_t emit, total;
      uint16_t used, reserved_space;
      uint32_t map[8192];
#define BATCH_SZ (8192*sizeof(uint32_t))

      uint32_t state_batch_offset;
      bool is_blit;
   } batch;

   drm_intel_bo *first_post_swapbuffers_batch;
   GLboolean need_throttle;
   GLboolean no_batch_wrap;
   bool tnl_pipeline_running; /**< Set while i915's _tnl_run_pipeline. */

   struct
   {
      GLuint id;
      uint32_t start_ptr; /**< for i8xx */
      uint32_t primitive;	/**< Current hardware primitive type */
      void (*flush) (struct intel_context *);
      drm_intel_bo *vb_bo;
      uint8_t *vb;
      unsigned int start_offset; /**< Byte offset of primitive sequence */
      unsigned int current_offset; /**< Byte offset of next vertex */
      unsigned int count;	/**< Number of vertices in current primitive */
   } prim;

   struct {
      drm_intel_bo *bo;
      GLuint offset;
      uint32_t buffer_len;
      uint32_t buffer_offset;
      char buffer[4096];
   } upload;

   GLuint stats_wm;

   /* Offsets of fields within the current vertex:
    */
   GLuint coloroffset;
   GLuint specoffset;
   GLuint wpos_offset;

   struct tnl_attr_map vertex_attrs[VERT_ATTRIB_MAX];
   GLuint vertex_attr_count;

   GLfloat polygon_offset_scale;        /* dependent on depth_scale, bpp */

   GLboolean hw_stencil;
   GLboolean hw_stipple;
   GLboolean depth_buffer_is_float;
   GLboolean no_rast;
   GLboolean always_flush_batch;
   GLboolean always_flush_cache;

   /* 0 - nonconformant, best performance;
    * 1 - fallback to sw for known conformance bugs
    * 2 - always fallback to sw
    */
   GLuint conformance_mode;

   /* State for intelvb.c and inteltris.c.
    */
   GLuint RenderIndex;
   GLmatrix ViewportMatrix;
   GLenum render_primitive;
   GLenum reduced_primitive;
   GLuint vertex_size;
   GLubyte *verts;              /* points to tnl->clipspace.vertex_buf */

   /* Fallback rasterization functions 
    */
   intel_point_func draw_point;
   intel_line_func draw_line;
   intel_tri_func draw_tri;

   /**
    * Set if rendering has occured to the drawable's front buffer.
    *
    * This is used in the DRI2 case to detect that glFlush should also copy
    * the contents of the fake front buffer to the real front buffer.
    */
   GLboolean front_buffer_dirty;

   /**
    * Track whether front-buffer rendering is currently enabled
    *
    * A separate flag is used to track this in order to support MRT more
    * easily.
    */
   GLboolean is_front_buffer_rendering;
   /**
    * Track whether front-buffer is the current read target.
    *
    * This is closely associated with is_front_buffer_rendering, but may
    * be set separately.  The DRI2 fake front buffer must be referenced
    * either way.
    */
   GLboolean is_front_buffer_reading;

   GLboolean use_texture_tiling;
   GLboolean use_early_z;

   int driFd;

   __DRIcontext *driContext;
   struct intel_screen *intelScreen;
   void (*saved_viewport)(struct gl_context * ctx,
			  GLint x, GLint y, GLsizei width, GLsizei height);

   /**
    * Configuration cache
    */
   driOptionCache optionCache;
};

extern char *__progname;


#define SUBPIXEL_X 0.125
#define SUBPIXEL_Y 0.125

#define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))

/**
 * Align a value up to an alignment value
 *
 * If \c value is not already aligned to the requested alignment value, it
 * will be rounded up.
 *
 * \param value  Value to be rounded
 * \param alignment  Alignment value to be used.  This must be a power of two.
 *
 * \sa ROUND_DOWN_TO()
 */
#define ALIGN(value, alignment)  (((value) + alignment - 1) & ~(alignment - 1))

/**
 * Align a value down to an alignment value
 *
 * If \c value is not already aligned to the requested alignment value, it
 * will be rounded down.
 *
 * \param value  Value to be rounded
 * \param alignment  Alignment value to be used.  This must be a power of two.
 *
 * \sa ALIGN()
 */
#define ROUND_DOWN_TO(value, alignment) ((value) & ~(alignment - 1))

#define IS_POWER_OF_TWO(val) (((val) & (val - 1)) == 0)

static INLINE uint32_t
U_FIXED(float value, uint32_t frac_bits)
{
   value *= (1 << frac_bits);
   return value < 0 ? 0 : value;
}

static INLINE uint32_t
S_FIXED(float value, uint32_t frac_bits)
{
   return value * (1 << frac_bits);
}

#define INTEL_FIREVERTICES(intel)		\
do {						\
   if ((intel)->prim.flush)			\
      (intel)->prim.flush(intel);		\
} while (0)

/* ================================================================
 * From linux kernel i386 header files, copes with odd sizes better
 * than COPY_DWORDS would:
 * XXX Put this in src/mesa/main/imports.h ???
 */
#if defined(i386) || defined(__i386__)
static INLINE void * __memcpy(void * to, const void * from, size_t n)
{
   int d0, d1, d2;
   __asm__ __volatile__(
      "rep ; movsl\n\t"
      "testb $2,%b4\n\t"
      "je 1f\n\t"
      "movsw\n"
      "1:\ttestb $1,%b4\n\t"
      "je 2f\n\t"
      "movsb\n"
      "2:"
      : "=&c" (d0), "=&D" (d1), "=&S" (d2)
      :"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
      : "memory");
   return (to);
}
#else
#define __memcpy(a,b,c) memcpy(a,b,c)
#endif


/* ================================================================
 * Debugging:
 */
extern int INTEL_DEBUG;

#define DEBUG_TEXTURE	0x1
#define DEBUG_STATE	0x2
#define DEBUG_IOCTL	0x4
#define DEBUG_BLIT	0x8
#define DEBUG_MIPTREE   0x10
#define DEBUG_FALLBACKS	0x20
#define DEBUG_VERBOSE	0x40
#define DEBUG_BATCH     0x80
#define DEBUG_PIXEL     0x100
#define DEBUG_BUFMGR    0x200
#define DEBUG_REGION    0x400
#define DEBUG_FBO       0x800
#define DEBUG_GS        0x1000
#define DEBUG_SYNC	0x2000
#define DEBUG_PRIMS	0x4000
#define DEBUG_VERTS	0x8000
#define DEBUG_DRI       0x10000
#define DEBUG_SF        0x20000
#define DEBUG_SANITY    0x40000
#define DEBUG_SLEEP     0x80000
#define DEBUG_STATS     0x100000
#define DEBUG_TILE      0x200000
#define DEBUG_SINGLE_THREAD   0x400000
#define DEBUG_WM        0x800000
#define DEBUG_URB       0x1000000
#define DEBUG_VS        0x2000000
#define DEBUG_CLIP      0x8000000

#define DBG(...) do {						\
	if (unlikely(INTEL_DEBUG & FILE_DEBUG_FLAG))		\
		printf(__VA_ARGS__);			\
} while(0)

#define fallback_debug(...) do {				\
	if (unlikely(INTEL_DEBUG & DEBUG_FALLBACKS))		\
		printf(__VA_ARGS__);				\
} while(0)

#define PCI_CHIP_845_G			0x2562
#define PCI_CHIP_I830_M			0x3577
#define PCI_CHIP_I855_GM		0x3582
#define PCI_CHIP_I865_G			0x2572
#define PCI_CHIP_I915_G			0x2582
#define PCI_CHIP_I915_GM		0x2592
#define PCI_CHIP_I945_G			0x2772
#define PCI_CHIP_I945_GM		0x27A2
#define PCI_CHIP_I945_GME		0x27AE
#define PCI_CHIP_G33_G			0x29C2
#define PCI_CHIP_Q35_G			0x29B2
#define PCI_CHIP_Q33_G			0x29D2


/* ================================================================
 * intel_context.c:
 */

extern GLboolean intelInitContext(struct intel_context *intel,
				  int api,
                                  const struct gl_config * mesaVis,
                                  __DRIcontext * driContextPriv,
                                  void *sharedContextPrivate,
                                  struct dd_function_table *functions);

extern void intelFinish(struct gl_context * ctx);
extern void intel_flush(struct gl_context * ctx);

extern void intelInitDriverFunctions(struct dd_function_table *functions);

void intel_init_syncobj_functions(struct dd_function_table *functions);


/* ================================================================
 * intel_state.c:
 */
extern void intelInitStateFuncs(struct dd_function_table *functions);

#define COMPAREFUNC_ALWAYS		0
#define COMPAREFUNC_NEVER		0x1
#define COMPAREFUNC_LESS		0x2
#define COMPAREFUNC_EQUAL		0x3
#define COMPAREFUNC_LEQUAL		0x4
#define COMPAREFUNC_GREATER		0x5
#define COMPAREFUNC_NOTEQUAL		0x6
#define COMPAREFUNC_GEQUAL		0x7

#define STENCILOP_KEEP			0
#define STENCILOP_ZERO			0x1
#define STENCILOP_REPLACE		0x2
#define STENCILOP_INCRSAT		0x3
#define STENCILOP_DECRSAT		0x4
#define STENCILOP_INCR			0x5
#define STENCILOP_DECR			0x6
#define STENCILOP_INVERT		0x7

#define LOGICOP_CLEAR			0
#define LOGICOP_NOR			0x1
#define LOGICOP_AND_INV 		0x2
#define LOGICOP_COPY_INV		0x3
#define LOGICOP_AND_RVRSE		0x4
#define LOGICOP_INV			0x5
#define LOGICOP_XOR			0x6
#define LOGICOP_NAND			0x7
#define LOGICOP_AND			0x8
#define LOGICOP_EQUIV			0x9
#define LOGICOP_NOOP			0xa
#define LOGICOP_OR_INV			0xb
#define LOGICOP_COPY			0xc
#define LOGICOP_OR_RVRSE		0xd
#define LOGICOP_OR			0xe
#define LOGICOP_SET			0xf

#define BLENDFACT_ZERO			0x01
#define BLENDFACT_ONE			0x02
#define BLENDFACT_SRC_COLR		0x03
#define BLENDFACT_INV_SRC_COLR 		0x04
#define BLENDFACT_SRC_ALPHA		0x05
#define BLENDFACT_INV_SRC_ALPHA 	0x06
#define BLENDFACT_DST_ALPHA		0x07
#define BLENDFACT_INV_DST_ALPHA 	0x08
#define BLENDFACT_DST_COLR		0x09
#define BLENDFACT_INV_DST_COLR		0x0a
#define BLENDFACT_SRC_ALPHA_SATURATE	0x0b
#define BLENDFACT_CONST_COLOR		0x0c
#define BLENDFACT_INV_CONST_COLOR	0x0d
#define BLENDFACT_CONST_ALPHA		0x0e
#define BLENDFACT_INV_CONST_ALPHA	0x0f
#define BLENDFACT_MASK          	0x0f

enum {
   DRI_CONF_BO_REUSE_DISABLED,
   DRI_CONF_BO_REUSE_ALL
};

extern int intel_translate_shadow_compare_func(GLenum func);
extern int intel_translate_compare_func(GLenum func);
extern int intel_translate_stencil_op(GLenum op);
extern int intel_translate_blend_factor(GLenum factor);
extern int intel_translate_logic_op(GLenum opcode);

void intel_update_renderbuffers(__DRIcontext *context,
				__DRIdrawable *drawable);
void intel_prepare_render(struct intel_context *intel);

void i915_set_buf_info_for_region(uint32_t *state, struct intel_region *region,
				  uint32_t buffer_id);

/*======================================================================
 * Inline conversion functions.  
 * These are better-typed than the macros used previously:
 */
static INLINE struct intel_context *
intel_context(struct gl_context * ctx)
{
   return (struct intel_context *) ctx;
}

static INLINE GLboolean
is_power_of_two(uint32_t value)
{
   return (value & (value - 1)) == 0;
}

#endif
@


1.8
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.7
log
@Merge Mesa 7.10.3
@
text
@a34 1
#include "dri_metaops.h"
d139 1
d152 5
a158 2
   struct dri_metaops meta;

d174 3
d180 20
a199 1
   struct intel_batchbuffer *batch;
d203 1
d208 1
a210 1
      GLubyte *start_ptr; /**< for i8xx */
d218 8
a232 1
   GLuint wpos_size;
@


1.6
log
@Update to Mesa 7.8.2. Tested by johan@@. Thanks.
@
text
@d32 1
a32 1

a34 1
#include "texmem.h"
d36 7
d49 6
d101 10
d119 1
a119 1
 * intel_context is derived from Mesa's context class: GLcontext.
d123 1
a123 1
   GLcontext ctx;  /**< base class, must be first field */
d176 1
a177 1
   GLboolean using_dri2_swapbuffers;
d185 1
a185 1
      dri_bo *vb_bo;
a192 3
   GLboolean locked;
   char *prevLockFile;
   int prevLockLine;
a209 1
   GLboolean no_hw;
a263 3
   __DRIdrawable *driDrawable;
   __DRIdrawable *driReadDrawable;
   __DRIscreen *driScreen;
d265 2
d281 27
a307 1
#define ALIGN(value, alignment)  ((value + alignment - 1) & ~(alignment - 1))
d374 1
a374 1
#define DEBUG_LOCK      0x1000
d379 1
a379 1
#define DEBUG_DMA       0x20000
d388 1
d391 1
a391 1
	if (INTEL_DEBUG & FILE_DEBUG_FLAG)			\
d395 5
d419 2
a420 1
                                  const __GLcontextModes * mesaVis,
d425 2
a426 3
extern void intelFinish(GLcontext * ctx);
extern void intelFlush(GLcontext * ctx);
extern void intel_flush(GLcontext * ctx, GLboolean needs_mi_flush);
a500 3
void intel_viewport(GLcontext * ctx, GLint x, GLint y,
		    GLsizei width, GLsizei height);

d513 1
a513 1
intel_context(GLcontext * ctx)
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d148 1
@


1.4
log
@backport some code from mesa current (and 7.5) so that the dri2 protocol
is correctly handled. without fixes to mesa and the ddx, the so-called
backwards compat goop that was added just plain does not work and ends
up with rendering bullshit.
@
text
@d36 1
d52 2
d64 4
d75 2
d78 1
a78 1
extern void intelFallback(struct intel_context *intel, GLuint bit,
d89 10
d101 1
a101 1
   GLcontext ctx;               /* the parent class */
a109 2
      void (*note_fence) (struct intel_context *intel, GLuint fence);
      void (*note_unlock) (struct intel_context *intel);
a118 3
      GLuint (*flush_cmd) (void);
      void (*emit_flush) (struct intel_context *intel, GLuint unused);

a126 42

      /* Metaops: 
       */
      void (*install_meta_state) (struct intel_context * intel);
      void (*leave_meta_state) (struct intel_context * intel);

      void (*meta_draw_region) (struct intel_context * intel,
                                struct intel_region * draw_region,
                                struct intel_region * depth_region);

      void (*meta_draw_quad)(struct intel_context *intel,
			     GLfloat x0, GLfloat x1,
			     GLfloat y0, GLfloat y1,
			     GLfloat z,
			     GLuint color, /* ARGB32 */
			     GLfloat s0, GLfloat s1,
			     GLfloat t0, GLfloat t1);

      void (*meta_color_mask) (struct intel_context * intel, GLboolean);

      void (*meta_stencil_replace) (struct intel_context * intel,
                                    GLuint mask, GLuint clear);

      void (*meta_depth_replace) (struct intel_context * intel);

      void (*meta_texture_blend_replace) (struct intel_context * intel);

      void (*meta_no_stencil_write) (struct intel_context * intel);
      void (*meta_no_depth_write) (struct intel_context * intel);
      void (*meta_no_texture) (struct intel_context * intel);

      void (*meta_import_pixel_state) (struct intel_context * intel);
      void (*meta_frame_buffer_texture) (struct intel_context *intel,
					 GLint xoff, GLint yoff);

      GLboolean(*meta_tex_rect_source) (struct intel_context * intel,
					dri_bo * buffer,
					GLuint offset,
					GLuint pitch,
					GLuint height,
					GLenum format, GLenum type);

d132 1
a132 13
   struct {
      struct gl_fragment_program *bitmap_fp;
      struct gl_vertex_program *passthrough_vp;

      struct gl_fragment_program *saved_fp;
      GLboolean saved_fp_enable;
      struct gl_vertex_program *saved_vp;
      GLboolean saved_vp_enable;

      GLint saved_vp_x, saved_vp_y;
      GLsizei saved_vp_width, saved_vp_height;
      GLenum saved_matrix_mode;
   } meta;
d134 1
a134 2
   GLint refcount;
   GLuint Fallback;
a139 4
   struct intel_region *front_region;
   struct intel_region *back_region;
   struct intel_region *depth_region;

d141 1
a141 2
    * This value indicates that the kernel memory manager is being used
    * instead of the fake client-side memory manager.
d143 7
a149 1
   GLboolean ttm;
d152 1
d154 1
a154 1
   unsigned batch_id;
a173 3
   GLuint ClearColor565;
   GLuint ClearColor8888;

d190 3
a214 16
   /* These refer to the current drawing buffer:
    */
   struct gl_texture_object *frame_buffer_texobj;
   /**
    * Set to true if a single constant cliprect should be used in the
    * batchbuffer.  Otherwise, cliprects must be calculated at batchbuffer
    * flush time while the lock is held.
    */
   GLboolean constant_cliprect;

   /**
    * In !constant_cliprect mode, set to true if the front cliprects should be
    * used instead of back.
    */
   GLboolean front_cliprects;

d239 2
a240 7
   drm_clip_rect_t fboRect;     /**< cliprect for FBO rendering */

   int perf_boxes;

   GLuint do_usleeps;
   int do_irqs;
   GLuint irqsEmitted;
a241 6
   GLboolean scissor;
   drm_clip_rect_t draw_rect;
   drm_clip_rect_t scissor_rect;

   drm_context_t hHWContext;
   drmLock *driHwLock;
d244 5
a248 10
   __DRIcontextPrivate *driContext;
   __DRIdrawablePrivate *driDrawable;
   __DRIdrawablePrivate *driReadDrawable;
   __DRIscreenPrivate *driScreen;
   intelScreenPrivate *intelScreen;
   volatile struct drm_i915_sarea *sarea;

   GLuint lastStamp;

   GLboolean no_hw;
a253 6

   int64_t swap_ust;
   int64_t swap_missed_ust;

   GLuint swap_count;
   GLuint swap_missed_count;
a255 5
/* These are functions now:
 */
void LOCK_HARDWARE( struct intel_context *intel );
void UNLOCK_HARDWARE( struct intel_context *intel );

d264 14
a285 23
 * Color packing:
 */

#define INTEL_PACKCOLOR4444(r,g,b,a) \
  ((((a) & 0xf0) << 8) | (((r) & 0xf0) << 4) | ((g) & 0xf0) | ((b) >> 4))

#define INTEL_PACKCOLOR1555(r,g,b,a) \
  ((((r) & 0xf8) << 7) | (((g) & 0xf8) << 2) | (((b) & 0xf8) >> 3) | \
    ((a) ? 0x8000 : 0))

#define INTEL_PACKCOLOR565(r,g,b) \
  ((((r) & 0xf8) << 8) | (((g) & 0xfc) << 3) | (((b) & 0xf8) >> 3))

#define INTEL_PACKCOLOR8888(r,g,b,a) \
  ((a<<24) | (r<<16) | (g<<8) | b)

#define INTEL_PACKCOLOR(format, r,  g,  b, a)		\
(format == DV_PF_555 ? INTEL_PACKCOLOR1555(r,g,b,a) :	\
 (format == DV_PF_565 ? INTEL_PACKCOLOR565(r,g,b) :	\
  (format == DV_PF_8888 ? INTEL_PACKCOLOR8888(r,g,b,a) :	\
   0)))

/* ================================================================
d347 1
a347 1
		_mesa_printf(__VA_ARGS__);			\
d370 1
a370 1
                                  __DRIcontextPrivate * driContextPriv,
a373 2
extern void intelGetLock(struct intel_context *intel, GLuint flags);

d376 1
a376 1
extern void intel_glFlush(GLcontext *ctx);
d379 2
a380 1
extern void intelInitExtensions(GLcontext *ctx, GLboolean enable_imaging);
d456 4
d469 6
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d285 8
@


1.2
log
@remove the triple buffering support from the intel driver, the support
from this was removed from the kernel and is very much deprecated.
Pageflipping is also probably broken and should not be used. Similar
change happened in mesa master a while back.

ok matthieu@@
@
text
@d33 3
a35 1
#include "mtypes.h"
d37 1
a37 3
#include "mm.h"
#include "texmem.h"
#include "dri_bufmgr.h"
d88 1
d160 14
a190 3
   dri_fence *last_swap_fence;
   dri_fence *first_swap_fence;

d198 1
a198 2
      GLuint primitive;
      GLubyte *start_ptr;
d200 6
a212 1
   GLubyte clear_chan[4];
d232 6
a237 1
   GLboolean strict_conformance;
a246 1
   struct intel_region *draw_region;
a255 3
   int drawX, drawY;            /**< origin of drawing area within region */
   GLuint numClipRects;         /**< cliprects for drawing */
   drm_clip_rect_t *pClipRects;
d257 29
d302 1
a317 4
   /* Last seen width/height of the screen */
   int width;
   int height;

d336 1
d461 1
d535 5
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a167 1
   struct intel_region *third_region;
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a31 10
#include <stdbool.h>
#include "main/mtypes.h"
#include "main/mm.h"
#include "dri_metaops.h"

#ifdef __cplusplus
extern "C" {
	/* Evil hack for using libdrm in a c++ compiler. */
	#define virtual virt
#endif
d33 1
d35 3
a37 1
#include "intel_bufmgr.h"
a41 6

#ifdef __cplusplus
	#undef virtual
}
#endif

a50 2
#define DV_PF_4444 (8<<8)
#define DV_PF_1555 (9<<8)
a60 4
/**
 * Bits for intel->Fallback field
 */
/*@@{*/
a67 2
#define INTEL_FALLBACK_DRIVER            0x1000  /**< first for drivers */
/*@@}*/
d69 1
a69 1
extern void intelFallback(struct intel_context *intel, GLbitfield bit,
a79 20
#ifndef likely
#ifdef __GNUC__
#define likely(expr) (__builtin_expect(expr, 1))
#define unlikely(expr) (__builtin_expect(expr, 0))
#else
#define likely(expr) (expr)
#define unlikely(expr) (expr)
#endif
#endif

struct intel_sync_object {
   struct gl_sync_object Base;

   /** Batch associated with this sync object */
   drm_intel_bo *bo;
};

/**
 * intel_context is derived from Mesa's context class: struct gl_context.
 */
d82 1
a82 1
   struct gl_context ctx;  /**< base class, must be first field */
a87 1
      void (*finish_batch) (struct intel_context * intel);
d90 2
d101 3
d112 42
d159 2
a160 3
   struct dri_metaops meta;

   GLbitfield Fallback;  /**< mask of INTEL_FALLBACK_x bits */
d166 5
d172 2
a173 1
    * Generation number of the hardware: 2 is 8xx, 3 is 9xx pre-965, 4 is 965.
d175 1
a175 6
   int gen;
   GLboolean needs_ff_sync;
   GLboolean is_g4x;
   GLboolean is_945;
   GLboolean has_luminance_srgb;
   GLboolean has_xrgb_textures;
d177 2
a178 1
   int urb_size;
a180 2
   drm_intel_bo *first_post_swapbuffers_batch;
   GLboolean need_throttle;
d182 1
d187 2
a188 1
      uint32_t primitive;	/**< Current hardware primitive type */
a189 6
      GLubyte *start_ptr; /**< for i8xx */
      drm_intel_bo *vb_bo;
      uint8_t *vb;
      unsigned int start_offset; /**< Byte offset of primitive sequence */
      unsigned int current_offset; /**< Byte offset of next vertex */
      unsigned int count;	/**< Number of vertices in current primitive */
d193 7
d217 1
a217 8
   GLboolean always_flush_batch;
   GLboolean always_flush_cache;

   /* 0 - nonconformant, best performance;
    * 1 - fallback to sw for known conformance bugs
    * 2 - always fallback to sw
    */
   GLuint conformance_mode;
d227 1
d235 1
a235 5
   /**
    * Set if rendering has occured to the drawable's front buffer.
    *
    * This is used in the DRI2 case to detect that glFlush should also copy
    * the contents of the fake front buffer to the real front buffer.
d237 15
a251 1
   GLboolean front_buffer_dirty;
d253 3
a255 15
   /**
    * Track whether front-buffer rendering is currently enabled
    *
    * A separate flag is used to track this in order to support MRT more
    * easily.
    */
   GLboolean is_front_buffer_rendering;
   /**
    * Track whether front-buffer is the current read target.
    *
    * This is closely associated with is_front_buffer_rendering, but may
    * be set separately.  The DRI2 fake front buffer must be referenced
    * either way.
    */
   GLboolean is_front_buffer_reading;
d257 5
a261 2
   GLboolean use_texture_tiling;
   GLboolean use_early_z;
d263 1
a263 1
   int driFd;
d265 1
a265 4
   __DRIcontext *driContext;
   struct intel_screen *intelScreen;
   void (*saved_viewport)(struct gl_context * ctx,
			  GLint x, GLint y, GLsizei width, GLsizei height);
a270 1
};
d272 3
a274 1
extern char *__progname;
d276 2
d279 3
a281 4
#define SUBPIXEL_X 0.125
#define SUBPIXEL_Y 0.125

#define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))
d283 1
a283 10
/**
 * Align a value up to an alignment value
 *
 * If \c value is not already aligned to the requested alignment value, it
 * will be rounded up.
 *
 * \param value  Value to be rounded
 * \param alignment  Alignment value to be used.  This must be a power of two.
 *
 * \sa ROUND_DOWN_TO()
d285 2
a286 1
#define ALIGN(value, alignment)  (((value) + alignment - 1) & ~(alignment - 1))
d288 1
a288 12
/**
 * Align a value down to an alignment value
 *
 * If \c value is not already aligned to the requested alignment value, it
 * will be rounded down.
 *
 * \param value  Value to be rounded
 * \param alignment  Alignment value to be used.  This must be a power of two.
 *
 * \sa ALIGN()
 */
#define ROUND_DOWN_TO(value, alignment) ((value) & ~(alignment - 1))
a289 1
#define IS_POWER_OF_TWO(val) (((val) & (val - 1)) == 0)
d291 2
a292 6
static INLINE uint32_t
U_FIXED(float value, uint32_t frac_bits)
{
   value *= (1 << frac_bits);
   return value < 0 ? 0 : value;
}
d294 1
a294 5
static INLINE uint32_t
S_FIXED(float value, uint32_t frac_bits)
{
   return value * (1 << frac_bits);
}
d303 23
d370 1
a370 1
#define DEBUG_GS        0x1000
d375 1
a375 1
#define DEBUG_SF        0x20000
a383 1
#define DEBUG_CLIP      0x8000000
d386 2
a387 7
	if (unlikely(INTEL_DEBUG & FILE_DEBUG_FLAG))		\
		printf(__VA_ARGS__);			\
} while(0)

#define fallback_debug(...) do {				\
	if (unlikely(INTEL_DEBUG & DEBUG_FALLBACKS))		\
		printf(__VA_ARGS__);				\
d409 2
a410 3
				  int api,
                                  const struct gl_config * mesaVis,
                                  __DRIcontext * driContextPriv,
d414 4
a417 2
extern void intelFinish(struct gl_context * ctx);
extern void intel_flush(struct gl_context * ctx);
d420 1
a420 2

void intel_init_syncobj_functions(struct dd_function_table *functions);
a490 6
void intel_update_renderbuffers(__DRIcontext *context,
				__DRIdrawable *drawable);
void intel_prepare_render(struct intel_context *intel);

void i915_set_buf_info_for_region(uint32_t *state, struct intel_region *region,
				  uint32_t buffer_id);
d497 1
a497 1
intel_context(struct gl_context * ctx)
a499 6
}

static INLINE GLboolean
is_power_of_two(uint32_t value)
{
   return (value & (value - 1)) == 0;
@


