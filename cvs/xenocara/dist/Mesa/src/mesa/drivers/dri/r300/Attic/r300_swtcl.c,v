head	1.5;
access;
symbols
	OPENBSD_5_4:1.4.0.8
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.09.05.14.05.03;	author jsg;	state dead;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.18;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.41;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge Mesa 9.2.0
@
text
@/**************************************************************************

Copyright (C) 2007 Dave Airlie

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
on the rights to use, copy, modify, merge, publish, distribute, sub
license, and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Dave Airlie <airlied@@linux.ie>
 *   Maciej Cencora <m.cencora@@gmail.com>
 */

#include "tnl/tnl.h"
#include "tnl/t_pipeline.h"

#include "r300_state.h"
#include "r300_swtcl.h"
#include "r300_emit.h"
#include "r300_tex.h"
#include "r300_render.h"
#include "main/simple_list.h"

#define EMIT_ATTR( ATTR, STYLE )					\
do {									\
	rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].attrib = (ATTR);	\
	rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].format = (STYLE);	\
	rmesa->radeon.swtcl.vertex_attr_count++;					\
} while (0)

#define EMIT_PAD( N )							\
do {									\
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].attrib = 0;		\
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].format = EMIT_PAD;	\
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].offset = (N);		\
   rmesa->radeon.swtcl.vertex_attr_count++;					\
} while (0)

#define ADD_ATTR(_attr, _format, _dst_loc, _swizzle, _write_mask, _normalize) \
do { \
	attrs[num_attrs].element = (_attr); \
	attrs[num_attrs].data_type = (_format); \
	attrs[num_attrs].dst_loc = (_dst_loc); \
	attrs[num_attrs].swizzle = (_swizzle); \
	attrs[num_attrs].write_mask = (_write_mask); \
	attrs[num_attrs]._signed = 0; \
	attrs[num_attrs].normalize = (_normalize); \
	++num_attrs; \
} while (0)

void r300ChooseSwtclVertexFormat(struct gl_context *ctx, GLuint *_InputsRead,  GLuint *_OutputsWritten)
{
	r300ContextPtr rmesa = R300_CONTEXT( ctx );
	TNLcontext *tnl = TNL_CONTEXT(ctx);
	struct vertex_buffer *VB = &tnl->vb;
	int first_free_tex = 0;
	GLuint InputsRead = 0;
	GLuint OutputsWritten = 0;
	int num_attrs = 0;
	GLuint fp_reads = rmesa->selected_fp->InputsRead;
	struct vertex_attribute *attrs = rmesa->vbuf.attribs;

	radeon_print(RADEON_SWRENDER, RADEON_VERBOSE, "%s\n", __func__);
	rmesa->swtcl.coloroffset = rmesa->swtcl.specoffset = 0;
	rmesa->radeon.swtcl.vertex_attr_count = 0;

	if (RADEON_DEBUG & RADEON_VERTS)
		fprintf(stderr, "%s\n", __func__);

	/* We always want non Ndc coords format */
	VB->AttribPtr[VERT_ATTRIB_POS] = VB->ClipPtr;

	/* Always write position vector */
	InputsRead |= 1 << VERT_ATTRIB_POS;
	OutputsWritten |= 1 << VERT_RESULT_HPOS;
	EMIT_ATTR( _TNL_ATTRIB_POS, EMIT_4F );
	ADD_ATTR(VERT_ATTRIB_POS, R300_DATA_TYPE_FLOAT_4, SWTCL_OVM_POS, SWIZZLE_XYZW, MASK_XYZW, 0);
	rmesa->swtcl.coloroffset = 4;

	if (fp_reads & FRAG_BIT_COL0) {
		InputsRead |= 1 << VERT_ATTRIB_COLOR0;
		OutputsWritten |= 1 << VERT_RESULT_COL0;
#if MESA_LITTLE_ENDIAN
		EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_4UB_4F_RGBA );
		ADD_ATTR(VERT_ATTRIB_COLOR0, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR0, SWIZZLE_XYZW, MASK_XYZW, 1);
#else
		EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_4UB_4F_ABGR );
		ADD_ATTR(VERT_ATTRIB_COLOR0, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR0, SWIZZLE_XYZW, MASK_XYZW, 1);
#endif
	}

	if (fp_reads & FRAG_BIT_COL1) {
		GLuint swiz = MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_ONE);
		InputsRead |= 1 << VERT_ATTRIB_COLOR1;
		OutputsWritten |= 1 << VERT_RESULT_COL1;
#if MESA_LITTLE_ENDIAN
		EMIT_ATTR( _TNL_ATTRIB_COLOR1, EMIT_4UB_4F_RGBA );
		ADD_ATTR(VERT_ATTRIB_COLOR1, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR1, swiz, MASK_XYZW, 1);
#else
		EMIT_ATTR( _TNL_ATTRIB_COLOR1, EMIT_4UB_4F_ABGR );
		ADD_ATTR(VERT_ATTRIB_COLOR1, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR1, swiz, MASK_XYZW, 1);
#endif
		rmesa->swtcl.specoffset = rmesa->swtcl.coloroffset + 1;
	}

	if (ctx->Light.Enabled && ctx->Light.Model.TwoSide) {
		VB->AttribPtr[VERT_ATTRIB_GENERIC0] = VB->BackfaceColorPtr;
		OutputsWritten |= 1 << VERT_RESULT_BFC0;
#if MESA_LITTLE_ENDIAN
		EMIT_ATTR( _TNL_ATTRIB_GENERIC0, EMIT_4UB_4F_RGBA );
		ADD_ATTR(VERT_ATTRIB_GENERIC0, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR2, SWIZZLE_XYZW, MASK_XYZW, 1);
#else
		EMIT_ATTR( _TNL_ATTRIB_GENERIC0, EMIT_4UB_4F_ABGR );
		ADD_ATTR(VERT_ATTRIB_GENERIC0, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR2, SWIZZLE_XYZW, MASK_XYZW, 1);
#endif
		if (fp_reads & FRAG_BIT_COL1) {
			VB->AttribPtr[VERT_ATTRIB_GENERIC1] = VB->BackfaceSecondaryColorPtr;
			GLuint swiz = MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_ONE);
			OutputsWritten |= 1 << VERT_RESULT_BFC1;
#if MESA_LITTLE_ENDIAN
			EMIT_ATTR( _TNL_ATTRIB_GENERIC1, EMIT_4UB_4F_RGBA );
			ADD_ATTR(VERT_ATTRIB_GENERIC1, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR3, swiz, MASK_XYZW, 1);
#else
			EMIT_ATTR( _TNL_ATTRIB_GENERIC1, EMIT_4UB_4F_ABGR );
			ADD_ATTR(VERT_ATTRIB_GENERIC1, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR3, swiz, MASK_XYZW, 1);
#endif
		}
	}

	if (RENDERINPUTS_TEST(tnl->render_inputs_bitset, _TNL_ATTRIB_POINTSIZE )) {
		GLuint swiz = MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_ZERO, SWIZZLE_ZERO, SWIZZLE_ZERO);
		InputsRead |= 1 << VERT_ATTRIB_POINT_SIZE;
		OutputsWritten |= 1 << VERT_RESULT_PSIZ;
		EMIT_ATTR( _TNL_ATTRIB_POINTSIZE, EMIT_1F );
		ADD_ATTR(VERT_ATTRIB_POINT_SIZE, R300_DATA_TYPE_FLOAT_1, SWTCL_OVM_POINT_SIZE, swiz, MASK_X, 0);
	}

	if (rmesa->selected_fp->wpos_attr != FRAG_ATTRIB_MAX) {
		int tex_id = rmesa->selected_fp->wpos_attr - FRAG_ATTRIB_TEX0;

		VB->AttribPtr[VERT_ATTRIB_TEX0 + tex_id] = VB->AttribPtr[VERT_ATTRIB_POS];
		VB->AttribPtr[_TNL_ATTRIB_TEX0 + tex_id] = VB->AttribPtr[VERT_ATTRIB_POS];
		RENDERINPUTS_SET(tnl->render_inputs_bitset, _TNL_ATTRIB_TEX0 + tex_id);
	}

	if (rmesa->selected_fp->fog_attr != FRAG_ATTRIB_MAX) {
		int tex_id = rmesa->selected_fp->fog_attr - FRAG_ATTRIB_TEX0;

		VB->AttribPtr[VERT_ATTRIB_TEX0 + tex_id] = VB->AttribPtr[VERT_ATTRIB_FOG];
		VB->AttribPtr[_TNL_ATTRIB_TEX0 + tex_id] = VB->AttribPtr[VERT_ATTRIB_FOG];
		RENDERINPUTS_SET(tnl->render_inputs_bitset, _TNL_ATTRIB_TEX0 + tex_id);
	}

	/**
	 *  Sending only one texcoord component may lead to lock up,
	 *  so for all textures always output 4 texcoord components to RS.
	 */
	{
		int i;
		GLuint swiz, format, hw_format;
		for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
			if (fp_reads & FRAG_BIT_TEX(i)) {
				switch (VB->AttribPtr[_TNL_ATTRIB_TEX0 + i]->size) {
					case 1:
						format = EMIT_1F;
						hw_format = R300_DATA_TYPE_FLOAT_1;
						swiz = MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_ZERO, SWIZZLE_ZERO, SWIZZLE_ONE);
						break;
					case 2:
						format = EMIT_2F;
						hw_format = R300_DATA_TYPE_FLOAT_2;
						swiz = MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_ZERO, SWIZZLE_ONE);
						break;
					case 3:
						format = EMIT_3F;
						hw_format = R300_DATA_TYPE_FLOAT_3;
						swiz = MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_ONE);
						break;
					case 4:
						format = EMIT_4F;
						hw_format = R300_DATA_TYPE_FLOAT_4;
						swiz = SWIZZLE_XYZW;
						break;
					default:
						continue;
				}
				InputsRead |= 1 << (VERT_ATTRIB_TEX0 + i);
				OutputsWritten |= 1 << (VERT_RESULT_TEX0 + i);
				EMIT_ATTR(_TNL_ATTRIB_TEX(i), format);
				ADD_ATTR(VERT_ATTRIB_TEX0 + i, hw_format, SWTCL_OVM_TEX(first_free_tex), swiz, MASK_XYZW, 0);
				++first_free_tex;
			}
		}
	}

	if (first_free_tex >= ctx->Const.MaxTextureUnits) {
		fprintf(stderr, "\tout of free texcoords to write fog coordinate\n");
		exit(-1);
	}

	R300_NEWPRIM(rmesa);
	rmesa->vbuf.num_attribs = num_attrs;
	*_InputsRead = InputsRead;
	*_OutputsWritten = OutputsWritten;

	RENDERINPUTS_COPY(rmesa->render_inputs_bitset, tnl->render_inputs_bitset);
}

static void r300PrepareVertices(struct gl_context *ctx)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	GLuint InputsRead, OutputsWritten;
	radeon_print(RADEON_SWRENDER, RADEON_TRACE, "%s\n", __func__);

	r300ChooseSwtclVertexFormat(ctx, &InputsRead, &OutputsWritten);
	r300SetupVAP(ctx, InputsRead, OutputsWritten);

	rmesa->radeon.swtcl.vertex_size =
		_tnl_install_attrs( ctx,
				    rmesa->radeon.swtcl.vertex_attrs,
				    rmesa->radeon.swtcl.vertex_attr_count,
				    NULL, 0 );

	rmesa->radeon.swtcl.vertex_size /= 4;
}

static void r300_predict_emit_size( r300ContextPtr rmesa )
{
	if (!rmesa->radeon.swtcl.emit_prediction) {
		const int vertex_size = 7;
		const int prim_size = 3;
		const int cache_flush_size = 4;
		const int pre_emit_state = 4;
		const int scissor_size = 3;
		const int state_size = radeonCountStateEmitSize(&rmesa->radeon);

		if (rcommonEnsureCmdBufSpace(&rmesa->radeon,
					state_size + pre_emit_state + scissor_size
					+ vertex_size + prim_size + cache_flush_size * 2,
					__FUNCTION__))
			rmesa->radeon.swtcl.emit_prediction = radeonCountStateEmitSize(&rmesa->radeon);
		else
			rmesa->radeon.swtcl.emit_prediction = state_size;

		rmesa->radeon.swtcl.emit_prediction += rmesa->radeon.cmdbuf.cs->cdw
			+ vertex_size + scissor_size + prim_size + cache_flush_size * 2 + pre_emit_state;
		radeon_print(RADEON_SWRENDER, RADEON_VERBOSE,
				"%s, size %d\n",
				__func__, rmesa->radeon.cmdbuf.cs->cdw
				+ vertex_size + scissor_size + prim_size + cache_flush_size * 2 + pre_emit_state);
	}
}


static GLuint reduced_prim[] = {
	GL_POINTS,
	GL_LINES,
	GL_LINES,
	GL_LINES,
	GL_TRIANGLES,
	GL_TRIANGLES,
	GL_TRIANGLES,
	GL_TRIANGLES,
	GL_TRIANGLES,
	GL_TRIANGLES,
};

static void r300RasterPrimitive( struct gl_context *ctx, GLuint prim );

/***********************************************************************
 *                    Emit primitives as inline vertices               *
 ***********************************************************************/


#define HAVE_POINTS      1
#define HAVE_LINES       1
#define HAVE_LINE_STRIPS 1
#define HAVE_TRIANGLES   1
#define HAVE_TRI_STRIPS  1
#define HAVE_TRI_STRIP_1 0
#define HAVE_TRI_FANS    1
#define HAVE_QUADS       0
#define HAVE_QUAD_STRIPS 0
#define HAVE_POLYGONS    1
#define HAVE_ELTS        1

static void* r300_alloc_verts(r300ContextPtr rmesa, GLuint n, GLuint size)
{
	void *rv;
	do {
		r300_predict_emit_size( rmesa );
		rv = rcommonAllocDmaLowVerts( &rmesa->radeon, n, size * 4 );
	} while (!rv);
	return rv;
}

#undef LOCAL_VARS
#undef ALLOC_VERTS
#define CTX_ARG r300ContextPtr rmesa
#define GET_VERTEX_DWORDS() rmesa->radeon.swtcl.vertex_size
#define ALLOC_VERTS( n, size ) r300_alloc_verts(rmesa, n, size);
#define LOCAL_VARS						\
   r300ContextPtr rmesa = R300_CONTEXT(ctx);		\
   const char *r300verts = (char *)rmesa->radeon.swtcl.verts;
#define VERT(x) (r300Vertex *)(r300verts + ((x) * vertsize * sizeof(int)))
#define VERTEX r300Vertex
#undef TAG
#define TAG(x) r300_##x
#include "tnl_dd/t_dd_triemit.h"



/***********************************************************************
 *          Macros for t_dd_tritmp.h to draw basic primitives          *
 ***********************************************************************/

#define QUAD( a, b, c, d ) r300_quad( rmesa, a, b, c, d )
#define TRI( a, b, c )     r300_triangle( rmesa, a, b, c )
#define LINE( a, b )       r300_line( rmesa, a, b )
#define POINT( a )         r300_point( rmesa, a )

/***********************************************************************
 *              Build render functions from dd templates               *
 ***********************************************************************/

#define R300_UNFILLED_BIT	0x01
#define R300_MAX_TRIFUNC	0x02

static struct {
   tnl_points_func	        points;
   tnl_line_func		line;
   tnl_triangle_func	triangle;
   tnl_quad_func		quad;
} rast_tab[R300_MAX_TRIFUNC];

#define DO_FALLBACK  0
#define DO_UNFILLED (IND & R300_UNFILLED_BIT)
#define DO_TWOSIDE   0
#define DO_FLAT      0
#define DO_OFFSET    0
#define DO_TRI       1
#define DO_QUAD      1
#define DO_LINE      1
#define DO_POINTS    1
#define DO_FULL_QUAD 1

#define HAVE_SPEC   1
#define HAVE_BACK_COLORS  0
#define HAVE_HW_FLATSHADE 1
#define TAB rast_tab

#define DEPTH_SCALE 1.0
#define UNFILLED_TRI unfilled_tri
#define UNFILLED_QUAD unfilled_quad
#define VERT_X(_v) _v->v.x
#define VERT_Y(_v) _v->v.y
#define VERT_Z(_v) _v->v.z
#define AREA_IS_CCW( a ) (a < 0)
#define GET_VERTEX(e) (rmesa->radeon.swtcl.verts + (e*rmesa->radeon.swtcl.vertex_size*sizeof(int)))

#define VERT_SET_RGBA( v, c ) \
do { \
   r300_color_t *color = (r300_color_t *)&((v)->ui[coloroffset]); \
   UNCLAMPED_FLOAT_TO_UBYTE(color->red, (c)[0]); \
   UNCLAMPED_FLOAT_TO_UBYTE(color->green, (c)[1]); \
   UNCLAMPED_FLOAT_TO_UBYTE(color->blue, (c)[2]); \
   UNCLAMPED_FLOAT_TO_UBYTE(color->alpha, (c)[3]); \
} while (0)

#define VERT_COPY_RGBA( v0, v1 ) v0->ui[coloroffset] = v1->ui[coloroffset]

#define VERT_SET_SPEC( v0, c ) \
do { \
   if (specoffset) { \
   UNCLAMPED_FLOAT_TO_UBYTE(v0->v.specular.red, (c)[0]); \
   UNCLAMPED_FLOAT_TO_UBYTE(v0->v.specular.green, (c)[1]); \
   UNCLAMPED_FLOAT_TO_UBYTE(v0->v.specular.blue, (c)[2]); \
   } \
} while (0)

#define VERT_COPY_SPEC( v0, v1 ) \
do { \
   if (specoffset) { \
       v0->v.specular.red = v1->v.specular.red; \
       v0->v.specular.green = v1->v.specular.green; \
       v0->v.specular.blue = v1->v.specular.blue; \
   } \
} while (0)

#define VERT_SAVE_RGBA( idx )    color[idx] = v[idx]->ui[coloroffset]
#define VERT_RESTORE_RGBA( idx ) v[idx]->ui[coloroffset] = color[idx]
#define VERT_SAVE_SPEC( idx )    if (specoffset) spec[idx] = v[idx]->ui[specoffset]
#define VERT_RESTORE_SPEC( idx ) if (specoffset) v[idx]->ui[specoffset] = spec[idx]

#undef LOCAL_VARS
#undef TAG
#undef INIT

#define LOCAL_VARS(n)							\
   r300ContextPtr rmesa = R300_CONTEXT(ctx);			\
   GLuint color[n] = { 0, }, spec[n] = { 0, };				\
   GLuint coloroffset = rmesa->swtcl.coloroffset;	\
   GLuint specoffset = rmesa->swtcl.specoffset;			\
   (void) color; (void) spec; (void) coloroffset; (void) specoffset;

/***********************************************************************
 *                Helpers for rendering unfilled primitives            *
 ***********************************************************************/

#define RASTERIZE(x) r300RasterPrimitive( ctx, reduced_prim[x] )
#define RENDER_PRIMITIVE rmesa->radeon.swtcl.render_primitive
#undef TAG
#define TAG(x) x
#include "tnl_dd/t_dd_unfilled.h"
#undef IND


/***********************************************************************
 *                      Generate GL render functions                   *
 ***********************************************************************/


#define IND (0)
#define TAG(x) x
#include "tnl_dd/t_dd_tritmp.h"

#define IND (R300_UNFILLED_BIT)
#define TAG(x) x##_unfilled
#include "tnl_dd/t_dd_tritmp.h"


static void init_rast_tab( void )
{
   init();
   init_unfilled();
}

/**********************************************************************/
/*               Render unclipped begin/end objects                   */
/**********************************************************************/

#define RENDER_POINTS( start, count )		\
   for ( ; start < count ; start++)		\
      r300_point( rmesa, VERT(start) )
#define RENDER_LINE( v0, v1 ) \
   r300_line( rmesa, VERT(v0), VERT(v1) )
#define RENDER_TRI( v0, v1, v2 )  \
   r300_triangle( rmesa, VERT(v0), VERT(v1), VERT(v2) )
#define RENDER_QUAD( v0, v1, v2, v3 ) \
   r300_quad( rmesa, VERT(v0), VERT(v1), VERT(v2), VERT(v3) )
#define INIT(x) do {					\
   r300RenderPrimitive( ctx, x );			\
} while (0)
#undef LOCAL_VARS
#define LOCAL_VARS						\
   r300ContextPtr rmesa = R300_CONTEXT(ctx);		\
   const GLuint vertsize = rmesa->radeon.swtcl.vertex_size;		\
   const char *r300verts = (char *)rmesa->radeon.swtcl.verts;		\
   const GLuint * const elt = TNL_CONTEXT(ctx)->vb.Elts;	\
   const GLboolean stipple = ctx->Line.StippleFlag;		\
   (void) elt; (void) stipple;
#define RESET_STIPPLE	//if ( stipple ) r200ResetLineStipple( ctx );
#define RESET_OCCLUSION
#define PRESERVE_VB_DEFS
#define ELT(x) (x)
#define TAG(x) r300_##x##_verts
#include "tnl/t_vb_rendertmp.h"
#undef ELT
#undef TAG
#define TAG(x) r300_##x##_elts
#define ELT(x) elt[x]
#include "tnl/t_vb_rendertmp.h"




/**********************************************************************/
/*                    Choose render functions                         */
/**********************************************************************/
static void r300ChooseRenderState( struct gl_context *ctx )
{
	TNLcontext *tnl = TNL_CONTEXT(ctx);
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	GLuint index = 0;
	GLuint flags = ctx->_TriangleCaps;
	radeon_print(RADEON_SWRENDER, RADEON_VERBOSE, "%s\n", __func__);

	if (flags & DD_TRI_UNFILLED)      index |= R300_UNFILLED_BIT;

	if (index != rmesa->radeon.swtcl.RenderIndex) {
		tnl->Driver.Render.Points = rast_tab[index].points;
		tnl->Driver.Render.Line = rast_tab[index].line;
		tnl->Driver.Render.ClippedLine = rast_tab[index].line;
		tnl->Driver.Render.Triangle = rast_tab[index].triangle;
		tnl->Driver.Render.Quad = rast_tab[index].quad;

		if (index == 0) {
			tnl->Driver.Render.PrimTabVerts = r300_render_tab_verts;
			tnl->Driver.Render.PrimTabElts = r300_render_tab_elts;
			tnl->Driver.Render.ClippedPolygon = r300_fast_clipped_poly;
		} else {
			tnl->Driver.Render.PrimTabVerts = _tnl_render_tab_verts;
			tnl->Driver.Render.PrimTabElts = _tnl_render_tab_elts;
			tnl->Driver.Render.ClippedPolygon = _tnl_RenderClippedPolygon;
		}

		rmesa->radeon.swtcl.RenderIndex = index;
	}
}

void r300RenderStart(struct gl_context *ctx)
{
	radeon_print(RADEON_SWRENDER, RADEON_VERBOSE, "%s\n", __func__);
	r300ContextPtr rmesa = R300_CONTEXT( ctx );

	r300ChooseRenderState(ctx);

	r300UpdateShaders(rmesa);

	r300PrepareVertices(ctx);

	r300ValidateBuffers(ctx);

	r300UpdateShaderStates(rmesa);


	/* investigate if we can put back flush optimisation if needed */
	if (rmesa->radeon.dma.flush != NULL) {
		rmesa->radeon.dma.flush(ctx);
	}
}

void r300RenderFinish(struct gl_context *ctx)
{
}

static void r300RasterPrimitive( struct gl_context *ctx, GLuint hwprim )
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	radeon_print(RADEON_SWRENDER, RADEON_TRACE, "%s\n", __func__);

	if (rmesa->radeon.swtcl.hw_primitive != hwprim) {
		R300_NEWPRIM( rmesa );
		rmesa->radeon.swtcl.hw_primitive = hwprim;
	}
}

void r300RenderPrimitive(struct gl_context *ctx, GLenum prim)
{

	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	rmesa->radeon.swtcl.render_primitive = prim;
	radeon_print(RADEON_SWRENDER, RADEON_TRACE, "%s\n", __func__);

	if ((prim == GL_TRIANGLES) && (ctx->_TriangleCaps & DD_TRI_UNFILLED))
		return;

	r300RasterPrimitive( ctx, reduced_prim[prim] );
}

void r300ResetLineStipple(struct gl_context *ctx)
{
	if (RADEON_DEBUG & RADEON_VERTS)
		fprintf(stderr, "%s\n", __func__);
}

void r300InitSwtcl(struct gl_context *ctx)
{
	TNLcontext *tnl = TNL_CONTEXT(ctx);
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	static int firsttime = 1;
	radeon_print(RADEON_SWRENDER, RADEON_NORMAL, "%s\n", __func__);

	if (firsttime) {
		init_rast_tab();
		firsttime = 0;
	}
	rmesa->radeon.swtcl.emit_prediction = 0;

	tnl->Driver.Render.Start = r300RenderStart;
	tnl->Driver.Render.Finish = r300RenderFinish;
	tnl->Driver.Render.PrimitiveNotify = r300RenderPrimitive;
	tnl->Driver.Render.ResetLineStipple = r300ResetLineStipple;
	tnl->Driver.Render.BuildVertices = _tnl_build_vertices;
	tnl->Driver.Render.CopyPV = _tnl_copy_pv;
	tnl->Driver.Render.Interp = _tnl_interp;

	/* FIXME: what are these numbers? */
	_tnl_init_vertices( ctx, ctx->Const.MaxArrayLockSize + 12,
			    48 * sizeof(GLfloat) );

	rmesa->radeon.swtcl.verts = (GLubyte *)tnl->clipspace.vertex_buf;
	rmesa->radeon.swtcl.RenderIndex = ~0;
	rmesa->radeon.swtcl.render_primitive = GL_TRIANGLES;
	rmesa->radeon.swtcl.hw_primitive = 0;

	_tnl_invalidate_vertex_state( ctx, ~0 );
	_tnl_invalidate_vertices( ctx, ~0 );

	_tnl_need_projected_coords( ctx, GL_FALSE );
}

void r300DestroySwtcl(struct gl_context *ctx)
{
}

static void r300EmitVertexAOS(r300ContextPtr rmesa, GLuint vertex_size, struct radeon_bo *bo, GLuint offset)
{
	BATCH_LOCALS(&rmesa->radeon);

	radeon_print(RADEON_SWRENDER, RADEON_TRACE,
		"%s:  vertex_size %d, offset 0x%x \n",
			__FUNCTION__, vertex_size, offset);

	BEGIN_BATCH(7);
	OUT_BATCH_PACKET3(R300_PACKET3_3D_LOAD_VBPNTR, 2);
	OUT_BATCH(1);
	OUT_BATCH(vertex_size | (vertex_size << 8));
	OUT_BATCH_RELOC(offset, bo, offset, RADEON_GEM_DOMAIN_GTT, 0, 0);
	END_BATCH();
}

static void r300EmitVbufPrim(r300ContextPtr rmesa, GLuint primitive, GLuint vertex_nr)
{
	BATCH_LOCALS(&rmesa->radeon);
	int type, num_verts;
	if (RADEON_DEBUG & RADEON_VERTS)
		fprintf(stderr, "%s\n", __func__);

	type = r300PrimitiveType(rmesa, primitive);
	num_verts = r300NumVerts(rmesa, vertex_nr, primitive);

	BEGIN_BATCH(3);
	OUT_BATCH_PACKET3(R300_PACKET3_3D_DRAW_VBUF_2, 0);
	OUT_BATCH(R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_LIST | (num_verts << 16) | type);
	END_BATCH();
}

void r300_swtcl_flush(struct gl_context *ctx, uint32_t current_offset)
{
	radeon_print(RADEON_SWRENDER, RADEON_TRACE, "%s\n", __func__);
	r300ContextPtr rmesa = R300_CONTEXT(ctx);

	r300EmitCacheFlush(rmesa);

	radeonEmitState(&rmesa->radeon);
	r300_emit_scissor(ctx);
	r300EmitVertexAOS(rmesa,
			  rmesa->radeon.swtcl.vertex_size,
			  rmesa->radeon.swtcl.bo,
			  current_offset);

	r300EmitVbufPrim(rmesa,
		   rmesa->radeon.swtcl.hw_primitive,
		   rmesa->radeon.swtcl.numverts);
	r300EmitCacheFlush(rmesa);
	if ( rmesa->radeon.swtcl.emit_prediction < rmesa->radeon.cmdbuf.cs->cdw )
		WARN_ONCE("Rendering was %d commands larger than predicted size."
			" We might overflow  command buffer.\n",
			rmesa->radeon.cmdbuf.cs->cdw - rmesa->radeon.swtcl.emit_prediction );
	rmesa->radeon.swtcl.emit_prediction = 0;
	COMMIT_BATCH();
}
@


1.4
log
@Merge Mesa 7.10.3
@
text
@@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d71 1
a71 1
void r300ChooseSwtclVertexFormat(GLcontext *ctx, GLuint *_InputsRead,  GLuint *_OutputsWritten)
d229 1
a229 1
static void r300PrepareVertices(GLcontext *ctx)
d288 1
a288 1
static void r300RasterPrimitive( GLcontext *ctx, GLuint prim );
d500 1
a500 1
static void r300ChooseRenderState( GLcontext *ctx )
d531 1
a531 1
void r300RenderStart(GLcontext *ctx)
d553 1
a553 1
void r300RenderFinish(GLcontext *ctx)
d557 1
a557 1
static void r300RasterPrimitive( GLcontext *ctx, GLuint hwprim )
d568 1
a568 1
void r300RenderPrimitive(GLcontext *ctx, GLenum prim)
d581 1
a581 1
void r300ResetLineStipple(GLcontext *ctx)
d587 1
a587 1
void r300InitSwtcl(GLcontext *ctx)
d623 1
a623 1
void r300DestroySwtcl(GLcontext *ctx)
d659 1
a659 1
void r300_swtcl_flush(GLcontext *ctx, uint32_t current_offset)
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d31 1
a33 17
/* derived from r200 swtcl path */



#include "main/glheader.h"
#include "main/mtypes.h"
#include "main/colormac.h"
#include "main/enums.h"
#include "main/image.h"
#include "main/imports.h"
#include "main/light.h"
#include "main/macros.h"

#include "swrast/s_context.h"
#include "swrast/s_fog.h"
#include "swrast_setup/swrast_setup.h"
#include "math/m_translate.h"
a34 1
#include "tnl/t_context.h"
d37 1
a37 1
#include "r300_context.h"
a38 2
#include "r300_state.h"
#include "r300_ioctl.h"
d40 3
a42 4
#include "r300_mem.h"

static void flush_last_swtcl_prim( r300ContextPtr rmesa  );

a43 2
void r300EmitVertexAOS(r300ContextPtr rmesa, GLuint vertex_size, GLuint offset);
void r300EmitVbufPrim(r300ContextPtr rmesa, GLuint primitive, GLuint vertex_nr);
d46 3
a48 3
   rmesa->swtcl.vertex_attrs[rmesa->swtcl.vertex_attr_count].attrib = (ATTR);	\
   rmesa->swtcl.vertex_attrs[rmesa->swtcl.vertex_attr_count].format = (STYLE);	\
   rmesa->swtcl.vertex_attr_count++;					\
d53 4
a56 4
   rmesa->swtcl.vertex_attrs[rmesa->swtcl.vertex_attr_count].attrib = 0;		\
   rmesa->swtcl.vertex_attrs[rmesa->swtcl.vertex_attr_count].format = EMIT_PAD;	\
   rmesa->swtcl.vertex_attrs[rmesa->swtcl.vertex_attr_count].offset = (N);		\
   rmesa->swtcl.vertex_attr_count++;					\
d59 13
a71 1
static void r300SetVertexFormat( GLcontext *ctx )
d76 34
a109 24
	DECLARE_RENDERINPUTS(index_bitset);
	GLuint InputsRead = 0, OutputsWritten = 0;
	int vap_fmt_0 = 0;
	int vap_vte_cntl = 0;
	int offset = 0;
	int vte = 0;
	GLint inputs[VERT_ATTRIB_MAX];
	GLint tab[VERT_ATTRIB_MAX];
	int swizzle[VERT_ATTRIB_MAX][4];
	GLuint i, nr;
	GLuint sz, vap_fmt_1 = 0;

	DECLARE_RENDERINPUTS(render_inputs_bitset);
	RENDERINPUTS_COPY(render_inputs_bitset, tnl->render_inputs_bitset);
	RENDERINPUTS_COPY( index_bitset, tnl->render_inputs_bitset );
	RENDERINPUTS_COPY(rmesa->state.render_inputs_bitset, render_inputs_bitset);

	vte = rmesa->hw.vte.cmd[1];
	vte &= ~(R300_VTX_XY_FMT | R300_VTX_Z_FMT | R300_VTX_W0_FMT);
	/* Important:
	 */
	if ( VB->NdcPtr != NULL ) {
		VB->AttribPtr[VERT_ATTRIB_POS] = VB->NdcPtr;
		vte |= R300_VTX_XY_FMT | R300_VTX_Z_FMT;
d111 37
a147 3
	else {
		VB->AttribPtr[VERT_ATTRIB_POS] = VB->ClipPtr;
		vte |= R300_VTX_W0_FMT;
d150 4
a153 18
	assert( VB->AttribPtr[VERT_ATTRIB_POS] != NULL );
	rmesa->swtcl.vertex_attr_count = 0;

	/* EMIT_ATTR's must be in order as they tell t_vertex.c how to
	 * build up a hardware vertex.
	 */
	if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_POS)) {
		sz = VB->AttribPtr[VERT_ATTRIB_POS]->size;
		InputsRead |= 1 << VERT_ATTRIB_POS;
		OutputsWritten |= 1 << VERT_RESULT_HPOS;
		EMIT_ATTR( _TNL_ATTRIB_POS, EMIT_1F + sz - 1 );
		offset = sz;
	} else {
		offset = 4;
		EMIT_PAD(4 * sizeof(float));
	}
/*
	if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_POINTSIZE )) {
d155 1
a155 2
		vap_fmt_0 |=  R300_VAP_OUTPUT_VTX_FMT_0__PT_SIZE_PRESENT;
		offset += 1;
d157 7
a163 8
*/
	if (RENDERINPUTS_TEST(index_bitset, _TNL_ATTRIB_COLOR0)) {
		sz = VB->AttribPtr[VERT_ATTRIB_COLOR0]->size;
	        rmesa->swtcl.coloroffset = offset;
		InputsRead |= 1 << VERT_ATTRIB_COLOR0;
		OutputsWritten |= 1 << VERT_RESULT_COL0;
		EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_1F + sz - 1 );
		offset += sz;
d166 6
a171 7
	rmesa->swtcl.specoffset = 0;
	if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_COLOR1 )) {
		sz = VB->AttribPtr[VERT_ATTRIB_COLOR1]->size;
		rmesa->swtcl.specoffset = offset;
		EMIT_ATTR( _TNL_ATTRIB_COLOR1, EMIT_1F + sz - 1 );
		InputsRead |= 1 << VERT_ATTRIB_COLOR1;
		OutputsWritten |= 1 << VERT_RESULT_COL1;
d174 5
a178 1
	if (RENDERINPUTS_TEST_RANGE( index_bitset, _TNL_FIRST_TEX, _TNL_LAST_TEX )) {
d180 1
a180 1

d182 25
a206 2
			if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_TEX(i) )) {
				sz = VB->TexCoordPtr[i]->size;
d209 3
a211 2
				EMIT_ATTR( _TNL_ATTRIB_TEX0+i, EMIT_1F + sz - 1 );
				vap_fmt_1 |= sz << (3 * i);
d216 3
a218 36
	for (i = 0, nr = 0; i < VERT_ATTRIB_MAX; i++) {
		if (InputsRead & (1 << i)) {
			inputs[i] = nr++;
		} else {
			inputs[i] = -1;
		}
	}
	
	/* Fixed, apply to vir0 only */
	if (InputsRead & (1 << VERT_ATTRIB_POS))
		inputs[VERT_ATTRIB_POS] = 0;
	if (InputsRead & (1 << VERT_ATTRIB_COLOR0))
		inputs[VERT_ATTRIB_COLOR0] = 2;
	if (InputsRead & (1 << VERT_ATTRIB_COLOR1))
		inputs[VERT_ATTRIB_COLOR1] = 3;
	for (i = VERT_ATTRIB_TEX0; i <= VERT_ATTRIB_TEX7; i++)
		if (InputsRead & (1 << i))
			inputs[i] = 6 + (i - VERT_ATTRIB_TEX0);
	
	for (i = 0, nr = 0; i < VERT_ATTRIB_MAX; i++) {
		if (InputsRead & (1 << i)) {
			tab[nr++] = i;
		}
	}
	
	for (i = 0; i < nr; i++) {
		int ci;
		
		swizzle[i][0] = SWIZZLE_ZERO;
		swizzle[i][1] = SWIZZLE_ZERO;
		swizzle[i][2] = SWIZZLE_ZERO;
		swizzle[i][3] = SWIZZLE_ONE;

		for (ci = 0; ci < VB->AttribPtr[tab[i]]->size; ci++) {
			swizzle[i][ci] = ci;
		}
d222 3
a224 24
	R300_STATECHANGE(rmesa, vir[0]);
	((drm_r300_cmd_header_t *) rmesa->hw.vir[0].cmd)->packet0.count =
		r300VAPInputRoute0(&rmesa->hw.vir[0].cmd[R300_VIR_CNTL_0],
				   VB->AttribPtr, inputs, tab, nr);
	R300_STATECHANGE(rmesa, vir[1]);
	((drm_r300_cmd_header_t *) rmesa->hw.vir[1].cmd)->packet0.count =
		r300VAPInputRoute1(&rmesa->hw.vir[1].cmd[R300_VIR_CNTL_0], swizzle,
				   nr);
   
	R300_STATECHANGE(rmesa, vic);
	rmesa->hw.vic.cmd[R300_VIC_CNTL_0] = r300VAPInputCntl0(ctx, InputsRead);
	rmesa->hw.vic.cmd[R300_VIC_CNTL_1] = r300VAPInputCntl1(ctx, InputsRead);
   
	R300_STATECHANGE(rmesa, vof);
	rmesa->hw.vof.cmd[R300_VOF_CNTL_0] = r300VAPOutputCntl0(ctx, OutputsWritten);
	rmesa->hw.vof.cmd[R300_VOF_CNTL_1] = vap_fmt_1;
   
	rmesa->swtcl.vertex_size =
		_tnl_install_attrs( ctx,
				    rmesa->swtcl.vertex_attrs, 
				    rmesa->swtcl.vertex_attr_count,
				    NULL, 0 );
	
	rmesa->swtcl.vertex_size /= 4;
d226 2
a227 1
	RENDERINPUTS_COPY( rmesa->tnl_index_bitset, index_bitset );
d229 5
d235 2
a236 4
	R300_STATECHANGE(rmesa, vte);
	rmesa->hw.vte.cmd[1] = vte;
	rmesa->hw.vte.cmd[2] = rmesa->swtcl.vertex_size;
}
d238 5
d244 1
a244 37
/* Flush vertices in the current dma region.
 */
static void flush_last_swtcl_prim( r300ContextPtr rmesa  )
{
	if (RADEON_DEBUG & DEBUG_IOCTL)
		fprintf(stderr, "%s\n", __FUNCTION__);
	
	rmesa->dma.flush = NULL;

	if (rmesa->dma.current.buf) {
		struct r300_dma_region *current = &rmesa->dma.current;
		GLuint current_offset = GET_START(current);

		assert (current->start + 
			rmesa->swtcl.numverts * rmesa->swtcl.vertex_size * 4 ==
			current->ptr);

		if (rmesa->dma.current.start != rmesa->dma.current.ptr) {

			r300EnsureCmdBufSpace( rmesa, rmesa->hw.max_state_size + (12*sizeof(int)), __FUNCTION__);
			
			r300EmitState(rmesa);
			
			r300EmitVertexAOS( rmesa,
					   rmesa->swtcl.vertex_size,
					   current_offset);
			
			r300EmitVbufPrim( rmesa,
					  rmesa->swtcl.hw_primitive,
					  rmesa->swtcl.numverts);
			
			r300EmitCacheFlush(rmesa);
		}
		
		rmesa->swtcl.numverts = 0;
		current->start = current->ptr;
	}
d247 1
a247 4
/* Alloc space in the current dma region.
 */
static void *
r300AllocDmaLowVerts( r300ContextPtr rmesa, int nverts, int vsize )
d249 22
a270 8
	GLuint bytes = vsize * nverts;

	if ( rmesa->dma.current.ptr + bytes > rmesa->dma.current.end ) 
		r300RefillCurrentDmaRegion( rmesa, bytes);

	if (!rmesa->dma.flush) {
		rmesa->radeon.glCtx->Driver.NeedFlush |= FLUSH_STORED_VERTICES;
		rmesa->dma.flush = flush_last_swtcl_prim;
d272 1
a273 13
	ASSERT( vsize == rmesa->swtcl.vertex_size * 4 );
	ASSERT( rmesa->dma.flush == flush_last_swtcl_prim );
	ASSERT( rmesa->dma.current.start + 
		rmesa->swtcl.numverts * rmesa->swtcl.vertex_size * 4 ==
		rmesa->dma.current.ptr );

	{
		GLubyte *head = (GLubyte *) (rmesa->dma.current.address + rmesa->dma.current.ptr);
		rmesa->dma.current.ptr += bytes;
		rmesa->swtcl.numverts += nverts;
		return head;
	}
}
d276 10
a285 10
  GL_POINTS,
  GL_LINES,
  GL_LINES,
  GL_LINES,
  GL_TRIANGLES,
  GL_TRIANGLES,
  GL_TRIANGLES,
  GL_TRIANGLES,
  GL_TRIANGLES,
  GL_TRIANGLES,
a288 2
static void r300RenderPrimitive( GLcontext *ctx, GLenum prim );
//static void r300ResetLineStipple( GLcontext *ctx );
d307 10
d320 2
a321 2
#define GET_VERTEX_DWORDS() rmesa->swtcl.vertex_size
#define ALLOC_VERTS( n, size ) r300AllocDmaLowVerts( rmesa, n, size * 4 )
d324 1
a324 1
   const char *r300verts = (char *)rmesa->swtcl.verts;
d326 1
a326 3
#define VERTEX r300Vertex 
#define DO_DEBUG_VERTS (1 && (RADEON_DEBUG & DEBUG_VERTS))
#define PRINT_VERTEX(x)
d346 2
a347 3
#define R300_TWOSIDE_BIT	0x01
#define R300_UNFILLED_BIT	0x02
#define R300_MAX_TRIFUNC	0x04
d358 1
a358 1
#define DO_TWOSIDE  (IND & R300_TWOSIDE_BIT)
d360 1
a360 1
#define DO_OFFSET     0
a366 1
#define HAVE_RGBA   1
d379 12
a390 1
#define GET_VERTEX(e) (rmesa->swtcl.verts + (e*rmesa->swtcl.vertex_size*sizeof(int)))
d392 7
a398 9
/* Only used to pull back colors into vertices (ie, we know color is
 * floating point).
 */
#define R300_COLOR( dst, src )				\
do {							\
   UNCLAMPED_FLOAT_TO_UBYTE((dst)[0], (src)[2]);	\
   UNCLAMPED_FLOAT_TO_UBYTE((dst)[1], (src)[1]);	\
   UNCLAMPED_FLOAT_TO_UBYTE((dst)[2], (src)[0]);	\
   UNCLAMPED_FLOAT_TO_UBYTE((dst)[3], (src)[3]);	\
d401 7
a407 10
#define VERT_SET_RGBA( v, c )    if (coloroffset) R300_COLOR( v->ub4[coloroffset], c )
#define VERT_COPY_RGBA( v0, v1 ) if (coloroffset) v0->ui[coloroffset] = v1->ui[coloroffset]
#define VERT_SAVE_RGBA( idx )    if (coloroffset) color[idx] = v[idx]->ui[coloroffset]
#define VERT_RESTORE_RGBA( idx ) if (coloroffset) v[idx]->ui[coloroffset] = color[idx]

#define R300_SPEC( dst, src )				\
do {							\
   UNCLAMPED_FLOAT_TO_UBYTE((dst)[0], (src)[2]);	\
   UNCLAMPED_FLOAT_TO_UBYTE((dst)[1], (src)[1]);	\
   UNCLAMPED_FLOAT_TO_UBYTE((dst)[2], (src)[0]);	\
d410 2
a411 2
#define VERT_SET_SPEC( v, c )    if (specoffset) R300_SPEC( v->ub4[specoffset], c )
#define VERT_COPY_SPEC( v0, v1 ) if (specoffset) COPY_3V(v0->ub4[specoffset], v1->ub4[specoffset])
d421 1
a421 1
   GLuint color[n], spec[n];						\
d431 1
a431 1
#define RENDER_PRIMITIVE rmesa->swtcl.render_primitive
a446 4
#define IND (R300_TWOSIDE_BIT)
#define TAG(x) x##_twoside
#include "tnl_dd/t_dd_tritmp.h"

a450 5
#define IND (R300_TWOSIDE_BIT|R300_UNFILLED_BIT)
#define TAG(x) x##_twoside_unfilled
#include "tnl_dd/t_dd_tritmp.h"


a454 1
   init_twoside();
a455 1
   init_twoside_unfilled();
d477 2
a478 2
   const GLuint vertsize = rmesa->swtcl.vertex_size;		\
   const char *r300verts = (char *)rmesa->swtcl.verts;		\
d506 1
a507 1
	if (flags & DD_TRI_LIGHT_TWOSIDE) index |= R300_TWOSIDE_BIT;
d510 1
a510 1
	if (index != rmesa->swtcl.RenderIndex) {
d527 1
a527 1
		rmesa->swtcl.RenderIndex = index;
d531 1
a531 2

static void r300RenderStart(GLcontext *ctx)
d533 2
a534 2
        r300ContextPtr rmesa = R300_CONTEXT( ctx );
	//	fprintf(stderr, "%s\n", __FUNCTION__);
d536 1
a536 2
	r300ChooseRenderState(ctx);	
	r300SetVertexFormat(ctx);
d539 5
a545 5
	r300EmitCacheFlush(rmesa);
	
	if (rmesa->dma.flush != 0 && 
	    rmesa->dma.flush != flush_last_swtcl_prim)
		rmesa->dma.flush( rmesa );
d547 4
d553 1
a553 1
static void r300RenderFinish(GLcontext *ctx)
d560 5
a564 4
	
	if (rmesa->swtcl.hw_primitive != hwprim) {
	        R300_NEWPRIM( rmesa );
		rmesa->swtcl.hw_primitive = hwprim;
d568 1
a568 1
static void r300RenderPrimitive(GLcontext *ctx, GLenum prim)
d572 2
a573 1
	rmesa->swtcl.render_primitive = prim;
d576 1
a576 1
	  return;
a578 2
	//	fprintf(stderr, "%s\n", __FUNCTION__);
	
d581 1
a581 1
static void r300ResetLineStipple(GLcontext *ctx)
d583 2
a584 2


d592 2
a593 1
	
d598 2
a599 1
	
d607 1
a607 1
	
d609 1
a609 1
	_tnl_init_vertices( ctx, ctx->Const.MaxArrayLockSize + 12, 
d611 5
a615 5
	
	rmesa->swtcl.verts = (GLubyte *)tnl->clipspace.vertex_buf;
	rmesa->swtcl.RenderIndex = ~0;
	rmesa->swtcl.render_primitive = GL_TRIANGLES;
	rmesa->swtcl.hw_primitive = 0;	
a618 1
	RENDERINPUTS_ZERO( rmesa->tnl_index_bitset );
a620 6
	r300ChooseRenderState(ctx);

	_mesa_validate_all_lighting_tables( ctx ); 

	tnl->Driver.NotifyMaterialChange = 
	  _mesa_validate_all_lighting_tables;
d627 1
a627 1
void r300EmitVertexAOS(r300ContextPtr rmesa, GLuint vertex_size, GLuint offset)
d629 1
a629 2
	int cmd_reserved = 0;
	int cmd_written = 0;
d631 3
a633 4
	drm_radeon_cmd_header_t *cmd = NULL;
	if (RADEON_DEBUG & DEBUG_VERTS)
	  fprintf(stderr, "%s:  vertex_size %d, offset 0x%x \n",
		  __FUNCTION__, vertex_size, offset);
d635 6
a640 4
	start_packet3(CP_PACKET3(R300_PACKET3_3D_LOAD_VBPNTR, 2), 2);
	e32(1);
	e32(vertex_size | (vertex_size << 8));
	e32(offset);
d643 1
a643 1
void r300EmitVbufPrim(r300ContextPtr rmesa, GLuint primitive, GLuint vertex_nr)
d645 1
a645 3

	int cmd_reserved = 0;
	int cmd_written = 0;
d647 2
a648 1
	drm_radeon_cmd_header_t *cmd = NULL;
d652 31
a682 3
	
	start_packet3(CP_PACKET3(R300_PACKET3_3D_DRAW_VBUF_2, 0), 0);
	e32(R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_LIST | (num_verts << 16) | type);
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d37 8
a44 8
#include "glheader.h"
#include "mtypes.h"
#include "colormac.h"
#include "enums.h"
#include "image.h"
#include "imports.h"
#include "light.h"
#include "macros.h"
d132 1
a132 1

d138 1
a138 1

@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a30 1
 *   Maciej Cencora <m.cencora@@gmail.com>
d33 17
d51 1
d54 2
d57 1
a57 1
#include "r300_swtcl.h"
d59 3
a61 3
#include "r300_tex.h"
#include "r300_render.h"
#include "main/simple_list.h"
d63 3
d68 3
a70 3
	rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].attrib = (ATTR);	\
	rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].format = (STYLE);	\
	rmesa->radeon.swtcl.vertex_attr_count++;					\
d75 4
a78 16
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].attrib = 0;		\
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].format = EMIT_PAD;	\
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].offset = (N);		\
   rmesa->radeon.swtcl.vertex_attr_count++;					\
} while (0)

#define ADD_ATTR(_attr, _format, _dst_loc, _swizzle, _write_mask, _normalize) \
do { \
	attrs[num_attrs].element = (_attr); \
	attrs[num_attrs].data_type = (_format); \
	attrs[num_attrs].dst_loc = (_dst_loc); \
	attrs[num_attrs].swizzle = (_swizzle); \
	attrs[num_attrs].write_mask = (_write_mask); \
	attrs[num_attrs]._signed = 0; \
	attrs[num_attrs].normalize = (_normalize); \
	++num_attrs; \
d81 1
a81 1
void r300ChooseSwtclVertexFormat(struct gl_context *ctx, GLuint *_InputsRead,  GLuint *_OutputsWritten)
d86 29
a114 23
	int first_free_tex = 0;
	GLuint InputsRead = 0;
	GLuint OutputsWritten = 0;
	int num_attrs = 0;
	GLuint fp_reads = rmesa->selected_fp->InputsRead;
	struct vertex_attribute *attrs = rmesa->vbuf.attribs;

	radeon_print(RADEON_SWRENDER, RADEON_VERBOSE, "%s\n", __func__);
	rmesa->swtcl.coloroffset = rmesa->swtcl.specoffset = 0;
	rmesa->radeon.swtcl.vertex_attr_count = 0;

	if (RADEON_DEBUG & RADEON_VERTS)
		fprintf(stderr, "%s\n", __func__);

	/* We always want non Ndc coords format */
	VB->AttribPtr[VERT_ATTRIB_POS] = VB->ClipPtr;

	/* Always write position vector */
	InputsRead |= 1 << VERT_ATTRIB_POS;
	OutputsWritten |= 1 << VERT_RESULT_HPOS;
	EMIT_ATTR( _TNL_ATTRIB_POS, EMIT_4F );
	ADD_ATTR(VERT_ATTRIB_POS, R300_DATA_TYPE_FLOAT_4, SWTCL_OVM_POS, SWIZZLE_XYZW, MASK_XYZW, 0);
	rmesa->swtcl.coloroffset = 4;
d116 2
a117 11
	if (fp_reads & FRAG_BIT_COL0) {
		InputsRead |= 1 << VERT_ATTRIB_COLOR0;
		OutputsWritten |= 1 << VERT_RESULT_COL0;
#if MESA_LITTLE_ENDIAN
		EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_4UB_4F_RGBA );
		ADD_ATTR(VERT_ATTRIB_COLOR0, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR0, SWIZZLE_XYZW, MASK_XYZW, 1);
#else
		EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_4UB_4F_ABGR );
		ADD_ATTR(VERT_ATTRIB_COLOR0, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR0, SWIZZLE_XYZW, MASK_XYZW, 1);
#endif
	}
d119 12
a130 36
	if (fp_reads & FRAG_BIT_COL1) {
		GLuint swiz = MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_ONE);
		InputsRead |= 1 << VERT_ATTRIB_COLOR1;
		OutputsWritten |= 1 << VERT_RESULT_COL1;
#if MESA_LITTLE_ENDIAN
		EMIT_ATTR( _TNL_ATTRIB_COLOR1, EMIT_4UB_4F_RGBA );
		ADD_ATTR(VERT_ATTRIB_COLOR1, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR1, swiz, MASK_XYZW, 1);
#else
		EMIT_ATTR( _TNL_ATTRIB_COLOR1, EMIT_4UB_4F_ABGR );
		ADD_ATTR(VERT_ATTRIB_COLOR1, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR1, swiz, MASK_XYZW, 1);
#endif
		rmesa->swtcl.specoffset = rmesa->swtcl.coloroffset + 1;
	}

	if (ctx->Light.Enabled && ctx->Light.Model.TwoSide) {
		VB->AttribPtr[VERT_ATTRIB_GENERIC0] = VB->BackfaceColorPtr;
		OutputsWritten |= 1 << VERT_RESULT_BFC0;
#if MESA_LITTLE_ENDIAN
		EMIT_ATTR( _TNL_ATTRIB_GENERIC0, EMIT_4UB_4F_RGBA );
		ADD_ATTR(VERT_ATTRIB_GENERIC0, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR2, SWIZZLE_XYZW, MASK_XYZW, 1);
#else
		EMIT_ATTR( _TNL_ATTRIB_GENERIC0, EMIT_4UB_4F_ABGR );
		ADD_ATTR(VERT_ATTRIB_GENERIC0, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR2, SWIZZLE_XYZW, MASK_XYZW, 1);
#endif
		if (fp_reads & FRAG_BIT_COL1) {
			VB->AttribPtr[VERT_ATTRIB_GENERIC1] = VB->BackfaceSecondaryColorPtr;
			GLuint swiz = MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_ONE);
			OutputsWritten |= 1 << VERT_RESULT_BFC1;
#if MESA_LITTLE_ENDIAN
			EMIT_ATTR( _TNL_ATTRIB_GENERIC1, EMIT_4UB_4F_RGBA );
			ADD_ATTR(VERT_ATTRIB_GENERIC1, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR3, swiz, MASK_XYZW, 1);
#else
			EMIT_ATTR( _TNL_ATTRIB_GENERIC1, EMIT_4UB_4F_ABGR );
			ADD_ATTR(VERT_ATTRIB_GENERIC1, R300_DATA_TYPE_BYTE, SWTCL_OVM_COLOR3, swiz, MASK_XYZW, 1);
#endif
		}
d133 1
a133 4
	if (RENDERINPUTS_TEST(tnl->render_inputs_bitset, _TNL_ATTRIB_POINTSIZE )) {
		GLuint swiz = MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_ZERO, SWIZZLE_ZERO, SWIZZLE_ZERO);
		InputsRead |= 1 << VERT_ATTRIB_POINT_SIZE;
		OutputsWritten |= 1 << VERT_RESULT_PSIZ;
d135 2
a136 1
		ADD_ATTR(VERT_ATTRIB_POINT_SIZE, R300_DATA_TYPE_FLOAT_1, SWTCL_OVM_POINT_SIZE, swiz, MASK_X, 0);
d139 7
a145 6
	if (rmesa->selected_fp->wpos_attr != FRAG_ATTRIB_MAX) {
		int tex_id = rmesa->selected_fp->wpos_attr - FRAG_ATTRIB_TEX0;

		VB->AttribPtr[VERT_ATTRIB_TEX0 + tex_id] = VB->AttribPtr[VERT_ATTRIB_POS];
		VB->AttribPtr[_TNL_ATTRIB_TEX0 + tex_id] = VB->AttribPtr[VERT_ATTRIB_POS];
		RENDERINPUTS_SET(tnl->render_inputs_bitset, _TNL_ATTRIB_TEX0 + tex_id);
d148 7
a154 6
	if (rmesa->selected_fp->fog_attr != FRAG_ATTRIB_MAX) {
		int tex_id = rmesa->selected_fp->fog_attr - FRAG_ATTRIB_TEX0;

		VB->AttribPtr[VERT_ATTRIB_TEX0 + tex_id] = VB->AttribPtr[VERT_ATTRIB_FOG];
		VB->AttribPtr[_TNL_ATTRIB_TEX0 + tex_id] = VB->AttribPtr[VERT_ATTRIB_FOG];
		RENDERINPUTS_SET(tnl->render_inputs_bitset, _TNL_ATTRIB_TEX0 + tex_id);
d157 1
a157 5
	/**
	 *  Sending only one texcoord component may lead to lock up,
	 *  so for all textures always output 4 texcoord components to RS.
	 */
	{
d159 1
a159 1
		GLuint swiz, format, hw_format;
d161 2
a162 25
			if (fp_reads & FRAG_BIT_TEX(i)) {
				switch (VB->AttribPtr[_TNL_ATTRIB_TEX0 + i]->size) {
					case 1:
						format = EMIT_1F;
						hw_format = R300_DATA_TYPE_FLOAT_1;
						swiz = MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_ZERO, SWIZZLE_ZERO, SWIZZLE_ONE);
						break;
					case 2:
						format = EMIT_2F;
						hw_format = R300_DATA_TYPE_FLOAT_2;
						swiz = MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_ZERO, SWIZZLE_ONE);
						break;
					case 3:
						format = EMIT_3F;
						hw_format = R300_DATA_TYPE_FLOAT_3;
						swiz = MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_ONE);
						break;
					case 4:
						format = EMIT_4F;
						hw_format = R300_DATA_TYPE_FLOAT_4;
						swiz = SWIZZLE_XYZW;
						break;
					default:
						continue;
				}
d165 2
a166 3
				EMIT_ATTR(_TNL_ATTRIB_TEX(i), format);
				ADD_ATTR(VERT_ATTRIB_TEX0 + i, hw_format, SWTCL_OVM_TEX(first_free_tex), swiz, MASK_XYZW, 0);
				++first_free_tex;
d171 36
a206 3
	if (first_free_tex >= ctx->Const.MaxTextureUnits) {
		fprintf(stderr, "\tout of free texcoords to write fog coordinate\n");
		exit(-1);
d210 33
a242 3
	rmesa->vbuf.num_attribs = num_attrs;
	*_InputsRead = InputsRead;
	*_OutputsWritten = OutputsWritten;
d244 37
a280 1
	RENDERINPUTS_COPY(rmesa->render_inputs_bitset, tnl->render_inputs_bitset);
d283 4
a286 1
static void r300PrepareVertices(struct gl_context *ctx)
d288 1
a288 3
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	GLuint InputsRead, OutputsWritten;
	radeon_print(RADEON_SWRENDER, RADEON_TRACE, "%s\n", __func__);
d290 2
a291 2
	r300ChooseSwtclVertexFormat(ctx, &InputsRead, &OutputsWritten);
	r300SetupVAP(ctx, InputsRead, OutputsWritten);
d293 4
a296 5
	rmesa->radeon.swtcl.vertex_size =
		_tnl_install_attrs( ctx,
				    rmesa->radeon.swtcl.vertex_attrs,
				    rmesa->radeon.swtcl.vertex_attr_count,
				    NULL, 0 );
d298 5
a302 2
	rmesa->radeon.swtcl.vertex_size /= 4;
}
d304 5
a308 24
static void r300_predict_emit_size( r300ContextPtr rmesa )
{
	if (!rmesa->radeon.swtcl.emit_prediction) {
		const int vertex_size = 7;
		const int prim_size = 3;
		const int cache_flush_size = 4;
		const int pre_emit_state = 4;
		const int scissor_size = 3;
		const int state_size = radeonCountStateEmitSize(&rmesa->radeon);

		if (rcommonEnsureCmdBufSpace(&rmesa->radeon,
					state_size + pre_emit_state + scissor_size
					+ vertex_size + prim_size + cache_flush_size * 2,
					__FUNCTION__))
			rmesa->radeon.swtcl.emit_prediction = radeonCountStateEmitSize(&rmesa->radeon);
		else
			rmesa->radeon.swtcl.emit_prediction = state_size;

		rmesa->radeon.swtcl.emit_prediction += rmesa->radeon.cmdbuf.cs->cdw
			+ vertex_size + scissor_size + prim_size + cache_flush_size * 2 + pre_emit_state;
		radeon_print(RADEON_SWRENDER, RADEON_VERBOSE,
				"%s, size %d\n",
				__func__, rmesa->radeon.cmdbuf.cs->cdw
				+ vertex_size + scissor_size + prim_size + cache_flush_size * 2 + pre_emit_state);
a311 1

d313 10
a322 10
	GL_POINTS,
	GL_LINES,
	GL_LINES,
	GL_LINES,
	GL_TRIANGLES,
	GL_TRIANGLES,
	GL_TRIANGLES,
	GL_TRIANGLES,
	GL_TRIANGLES,
	GL_TRIANGLES,
d325 3
a327 1
static void r300RasterPrimitive( struct gl_context *ctx, GLuint prim );
a345 10
static void* r300_alloc_verts(r300ContextPtr rmesa, GLuint n, GLuint size)
{
	void *rv;
	do {
		r300_predict_emit_size( rmesa );
		rv = rcommonAllocDmaLowVerts( &rmesa->radeon, n, size * 4 );
	} while (!rv);
	return rv;
}

d349 2
a350 2
#define GET_VERTEX_DWORDS() rmesa->radeon.swtcl.vertex_size
#define ALLOC_VERTS( n, size ) r300_alloc_verts(rmesa, n, size);
d353 1
a353 1
   const char *r300verts = (char *)rmesa->radeon.swtcl.verts;
d355 3
a357 1
#define VERTEX r300Vertex
d377 3
a379 2
#define R300_UNFILLED_BIT	0x01
#define R300_MAX_TRIFUNC	0x02
d390 1
a390 1
#define DO_TWOSIDE   0
d392 1
a392 1
#define DO_OFFSET    0
d399 1
d412 1
a412 1
#define GET_VERTEX(e) (rmesa->radeon.swtcl.verts + (e*rmesa->radeon.swtcl.vertex_size*sizeof(int)))
d414 9
a422 18
#define VERT_SET_RGBA( v, c ) \
do { \
   r300_color_t *color = (r300_color_t *)&((v)->ui[coloroffset]); \
   UNCLAMPED_FLOAT_TO_UBYTE(color->red, (c)[0]); \
   UNCLAMPED_FLOAT_TO_UBYTE(color->green, (c)[1]); \
   UNCLAMPED_FLOAT_TO_UBYTE(color->blue, (c)[2]); \
   UNCLAMPED_FLOAT_TO_UBYTE(color->alpha, (c)[3]); \
} while (0)

#define VERT_COPY_RGBA( v0, v1 ) v0->ui[coloroffset] = v1->ui[coloroffset]

#define VERT_SET_SPEC( v0, c ) \
do { \
   if (specoffset) { \
   UNCLAMPED_FLOAT_TO_UBYTE(v0->v.specular.red, (c)[0]); \
   UNCLAMPED_FLOAT_TO_UBYTE(v0->v.specular.green, (c)[1]); \
   UNCLAMPED_FLOAT_TO_UBYTE(v0->v.specular.blue, (c)[2]); \
   } \
d425 10
a434 7
#define VERT_COPY_SPEC( v0, v1 ) \
do { \
   if (specoffset) { \
       v0->v.specular.red = v1->v.specular.red; \
       v0->v.specular.green = v1->v.specular.green; \
       v0->v.specular.blue = v1->v.specular.blue; \
   } \
d437 2
a438 2
#define VERT_SAVE_RGBA( idx )    color[idx] = v[idx]->ui[coloroffset]
#define VERT_RESTORE_RGBA( idx ) v[idx]->ui[coloroffset] = color[idx]
d448 1
a448 1
   GLuint color[n] = { 0, }, spec[n] = { 0, };				\
d458 1
a458 1
#define RENDER_PRIMITIVE rmesa->radeon.swtcl.render_primitive
d474 4
d482 5
d491 1
d493 1
d515 2
a516 2
   const GLuint vertsize = rmesa->radeon.swtcl.vertex_size;		\
   const char *r300verts = (char *)rmesa->radeon.swtcl.verts;		\
d538 1
a538 1
static void r300ChooseRenderState( struct gl_context *ctx )
a543 1
	radeon_print(RADEON_SWRENDER, RADEON_VERBOSE, "%s\n", __func__);
d545 1
d548 1
a548 1
	if (index != rmesa->radeon.swtcl.RenderIndex) {
d565 1
a565 1
		rmesa->radeon.swtcl.RenderIndex = index;
d569 2
a570 1
void r300RenderStart(struct gl_context *ctx)
d572 2
a573 2
	radeon_print(RADEON_SWRENDER, RADEON_VERBOSE, "%s\n", __func__);
	r300ContextPtr rmesa = R300_CONTEXT( ctx );
d575 2
a576 1
	r300ChooseRenderState(ctx);
a578 5

	r300PrepareVertices(ctx);

	r300ValidateBuffers(ctx);

d581 5
a586 4
	/* investigate if we can put back flush optimisation if needed */
	if (rmesa->radeon.dma.flush != NULL) {
		rmesa->radeon.dma.flush(ctx);
	}
d589 1
a589 1
void r300RenderFinish(struct gl_context *ctx)
d593 1
a593 1
static void r300RasterPrimitive( struct gl_context *ctx, GLuint hwprim )
d596 4
a599 5
	radeon_print(RADEON_SWRENDER, RADEON_TRACE, "%s\n", __func__);

	if (rmesa->radeon.swtcl.hw_primitive != hwprim) {
		R300_NEWPRIM( rmesa );
		rmesa->radeon.swtcl.hw_primitive = hwprim;
d603 1
a603 1
void r300RenderPrimitive(struct gl_context *ctx, GLenum prim)
d607 1
a607 2
	rmesa->radeon.swtcl.render_primitive = prim;
	radeon_print(RADEON_SWRENDER, RADEON_TRACE, "%s\n", __func__);
d610 1
a610 1
		return;
d613 2
d617 1
a617 1
void r300ResetLineStipple(struct gl_context *ctx)
d619 2
a620 2
	if (RADEON_DEBUG & RADEON_VERTS)
		fprintf(stderr, "%s\n", __func__);
d623 1
a623 1
void r300InitSwtcl(struct gl_context *ctx)
d628 1
a628 2
	radeon_print(RADEON_SWRENDER, RADEON_NORMAL, "%s\n", __func__);

d633 1
a633 2
	rmesa->radeon.swtcl.emit_prediction = 0;

d641 1
a641 1

d643 1
a643 1
	_tnl_init_vertices( ctx, ctx->Const.MaxArrayLockSize + 12,
d645 5
a649 5

	rmesa->radeon.swtcl.verts = (GLubyte *)tnl->clipspace.vertex_buf;
	rmesa->radeon.swtcl.RenderIndex = ~0;
	rmesa->radeon.swtcl.render_primitive = GL_TRIANGLES;
	rmesa->radeon.swtcl.hw_primitive = 0;
d653 1
d656 6
d664 1
a664 1
void r300DestroySwtcl(struct gl_context *ctx)
d668 1
a668 1
static void r300EmitVertexAOS(r300ContextPtr rmesa, GLuint vertex_size, struct radeon_bo *bo, GLuint offset)
d670 2
a671 1
	BATCH_LOCALS(&rmesa->radeon);
d673 4
a676 3
	radeon_print(RADEON_SWRENDER, RADEON_TRACE,
		"%s:  vertex_size %d, offset 0x%x \n",
			__FUNCTION__, vertex_size, offset);
d678 4
a681 6
	BEGIN_BATCH(7);
	OUT_BATCH_PACKET3(R300_PACKET3_3D_LOAD_VBPNTR, 2);
	OUT_BATCH(1);
	OUT_BATCH(vertex_size | (vertex_size << 8));
	OUT_BATCH_RELOC(offset, bo, offset, RADEON_GEM_DOMAIN_GTT, 0, 0);
	END_BATCH();
d684 1
a684 1
static void r300EmitVbufPrim(r300ContextPtr rmesa, GLuint primitive, GLuint vertex_nr)
d686 3
a688 1
	BATCH_LOCALS(&rmesa->radeon);
d690 1
a690 2
	if (RADEON_DEBUG & RADEON_VERTS)
		fprintf(stderr, "%s\n", __func__);
d694 3
a696 31

	BEGIN_BATCH(3);
	OUT_BATCH_PACKET3(R300_PACKET3_3D_DRAW_VBUF_2, 0);
	OUT_BATCH(R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_LIST | (num_verts << 16) | type);
	END_BATCH();
}

void r300_swtcl_flush(struct gl_context *ctx, uint32_t current_offset)
{
	radeon_print(RADEON_SWRENDER, RADEON_TRACE, "%s\n", __func__);
	r300ContextPtr rmesa = R300_CONTEXT(ctx);

	r300EmitCacheFlush(rmesa);

	radeonEmitState(&rmesa->radeon);
	r300_emit_scissor(ctx);
	r300EmitVertexAOS(rmesa,
			  rmesa->radeon.swtcl.vertex_size,
			  rmesa->radeon.swtcl.bo,
			  current_offset);

	r300EmitVbufPrim(rmesa,
		   rmesa->radeon.swtcl.hw_primitive,
		   rmesa->radeon.swtcl.numverts);
	r300EmitCacheFlush(rmesa);
	if ( rmesa->radeon.swtcl.emit_prediction < rmesa->radeon.cmdbuf.cs->cdw )
		WARN_ONCE("Rendering was %d commands larger than predicted size."
			" We might overflow  command buffer.\n",
			rmesa->radeon.cmdbuf.cs->cdw - rmesa->radeon.swtcl.emit_prediction );
	rmesa->radeon.swtcl.emit_prediction = 0;
	COMMIT_BATCH();
@


