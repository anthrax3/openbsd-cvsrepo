head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	v10_2_9:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.2.0.2
	OPENBSD_5_5_BASE:1.2
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_4:1.1.0.4
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.5;
commitid	TnlogFl9nOv2eaRf;

1.5
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.4;
commitid	4ry2gvZGMXkCUD2n;

1.4
date	2015.01.25.14.41.21;	author jsg;	state dead;
branches;
next	1.3;
commitid	mcxB0JvoI9gTDYXU;

1.3
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.2;
commitid	WPD6rgPryPkvXOr9;

1.2
date	2013.09.05.14.04.25;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.15.44;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.52;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.6
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2011 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#include "brw_context.h"
#include "brw_state.h"
#include "brw_defines.h"
#include "intel_batchbuffer.h"
#include "intel_mipmap_tree.h"

#include "main/macros.h"
#include "main/samplerobj.h"

/**
 * Sets the sampler state for a single unit.
 */
static void
gen7_update_sampler_state(struct brw_context *brw, int unit, int ss_index,
			  struct gen7_sampler_state *sampler,
                          uint32_t *sdc_offset)
{
   struct gl_context *ctx = &brw->ctx;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   struct gl_texture_object *texObj = texUnit->_Current;
   struct gl_sampler_object *gl_sampler = _mesa_get_samplerobj(ctx, unit);
   bool using_nearest = false;

   /* These don't use samplers at all. */
   if (texObj->Target == GL_TEXTURE_BUFFER)
      return;

   switch (gl_sampler->MinFilter) {
   case GL_NEAREST:
      sampler->ss0.min_filter = BRW_MAPFILTER_NEAREST;
      sampler->ss0.mip_filter = BRW_MIPFILTER_NONE;
      using_nearest = true;
      break;
   case GL_LINEAR:
      sampler->ss0.min_filter = BRW_MAPFILTER_LINEAR;
      sampler->ss0.mip_filter = BRW_MIPFILTER_NONE;
      break;
   case GL_NEAREST_MIPMAP_NEAREST:
      sampler->ss0.min_filter = BRW_MAPFILTER_NEAREST;
      sampler->ss0.mip_filter = BRW_MIPFILTER_NEAREST;
      break;
   case GL_LINEAR_MIPMAP_NEAREST:
      sampler->ss0.min_filter = BRW_MAPFILTER_LINEAR;
      sampler->ss0.mip_filter = BRW_MIPFILTER_NEAREST;
      break;
   case GL_NEAREST_MIPMAP_LINEAR:
      sampler->ss0.min_filter = BRW_MAPFILTER_NEAREST;
      sampler->ss0.mip_filter = BRW_MIPFILTER_LINEAR;
      break;
   case GL_LINEAR_MIPMAP_LINEAR:
      sampler->ss0.min_filter = BRW_MAPFILTER_LINEAR;
      sampler->ss0.mip_filter = BRW_MIPFILTER_LINEAR;
      break;
   default:
      break;
   }

   /* Set Anisotropy: */
   if (gl_sampler->MaxAnisotropy > 1.0) {
      sampler->ss0.min_filter = BRW_MAPFILTER_ANISOTROPIC;
      sampler->ss0.mag_filter = BRW_MAPFILTER_ANISOTROPIC;
      sampler->ss0.aniso_algorithm = 1;

      if (gl_sampler->MaxAnisotropy > 2.0) {
	 sampler->ss3.max_aniso = MIN2((gl_sampler->MaxAnisotropy - 2) / 2,
				       BRW_ANISORATIO_16);
      }
   }
   else {
      switch (gl_sampler->MagFilter) {
      case GL_NEAREST:
	 sampler->ss0.mag_filter = BRW_MAPFILTER_NEAREST;
	 using_nearest = true;
	 break;
      case GL_LINEAR:
	 sampler->ss0.mag_filter = BRW_MAPFILTER_LINEAR;
	 break;
      default:
	 break;
      }
   }

   sampler->ss3.r_wrap_mode = translate_wrap_mode(brw, gl_sampler->WrapR,
						  using_nearest);
   sampler->ss3.s_wrap_mode = translate_wrap_mode(brw, gl_sampler->WrapS,
						  using_nearest);
   sampler->ss3.t_wrap_mode = translate_wrap_mode(brw, gl_sampler->WrapT,
						  using_nearest);

   /* Cube-maps on 965 and later must use the same wrap mode for all 3
    * coordinate dimensions.  Futher, only CUBE and CLAMP are valid.
    */
   if (texObj->Target == GL_TEXTURE_CUBE_MAP ||
       texObj->Target == GL_TEXTURE_CUBE_MAP_ARRAY) {
      if ((ctx->Texture.CubeMapSeamless || gl_sampler->CubeMapSeamless) &&
	  (gl_sampler->MinFilter != GL_NEAREST ||
	   gl_sampler->MagFilter != GL_NEAREST)) {
	 sampler->ss3.r_wrap_mode = BRW_TEXCOORDMODE_CUBE;
	 sampler->ss3.s_wrap_mode = BRW_TEXCOORDMODE_CUBE;
	 sampler->ss3.t_wrap_mode = BRW_TEXCOORDMODE_CUBE;
      } else {
	 sampler->ss3.r_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	 sampler->ss3.s_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
	 sampler->ss3.t_wrap_mode = BRW_TEXCOORDMODE_CLAMP;
      }
   } else if (texObj->Target == GL_TEXTURE_1D) {
      /* There's a bug in 1D texture sampling - it actually pays
       * attention to the wrap_t value, though it should not.
       * Override the wrap_t value here to GL_REPEAT to keep
       * any nonexistent border pixels from floating in.
       */
      sampler->ss3.t_wrap_mode = BRW_TEXCOORDMODE_WRAP;
   }

   /* Set shadow function: */
   if (gl_sampler->CompareMode == GL_COMPARE_R_TO_TEXTURE_ARB) {
      /* Shadowing is "enabled" by emitting a particular sampler
       * message (sample_c).  So need to recompile WM program when
       * shadow comparison is enabled on each/any texture unit.
       */
      sampler->ss1.shadow_function =
	 intel_translate_shadow_compare_func(gl_sampler->CompareFunc);
   }

   /* Set LOD bias: */
   sampler->ss0.lod_bias = S_FIXED(CLAMP(texUnit->LodBias +
					 gl_sampler->LodBias, -16, 15), 8);

   sampler->ss0.lod_preclamp = 1; /* OpenGL mode */
   sampler->ss0.default_color_mode = 0; /* OpenGL/DX10 mode */

   sampler->ss0.base_level = U_FIXED(0, 1);

   sampler->ss1.max_lod = U_FIXED(CLAMP(gl_sampler->MaxLod, 0, 13), 8);
   sampler->ss1.min_lod = U_FIXED(CLAMP(gl_sampler->MinLod, 0, 13), 8);

   /* The sampler can handle non-normalized texture rectangle coordinates
    * natively
    */
   if (texObj->Target == GL_TEXTURE_RECTANGLE) {
      sampler->ss3.non_normalized_coord = 1;
   }

   upload_default_color(brw, gl_sampler, unit, sdc_offset);

   sampler->ss2.default_color_pointer = *sdc_offset >> 5;

   if (sampler->ss0.min_filter != BRW_MAPFILTER_NEAREST)
      sampler->ss3.address_round |= BRW_ADDRESS_ROUNDING_ENABLE_U_MIN |
                                    BRW_ADDRESS_ROUNDING_ENABLE_V_MIN |
                                    BRW_ADDRESS_ROUNDING_ENABLE_R_MIN;
   if (sampler->ss0.mag_filter != BRW_MAPFILTER_NEAREST)
      sampler->ss3.address_round |= BRW_ADDRESS_ROUNDING_ENABLE_U_MAG |
                                    BRW_ADDRESS_ROUNDING_ENABLE_V_MAG |
                                    BRW_ADDRESS_ROUNDING_ENABLE_R_MAG;
}


static void
gen7_upload_sampler_state_table(struct brw_context *brw,
                                struct gl_program *prog,
                                struct brw_stage_state *stage_state)
{
   struct gl_context *ctx = &brw->ctx;
   struct gen7_sampler_state *samplers;
   uint32_t sampler_count = stage_state->sampler_count;
   static const uint16_t packet_headers[] = {
      [MESA_SHADER_VERTEX] = _3DSTATE_SAMPLER_STATE_POINTERS_VS,
      [MESA_SHADER_GEOMETRY] = _3DSTATE_SAMPLER_STATE_POINTERS_GS,
      [MESA_SHADER_FRAGMENT] = _3DSTATE_SAMPLER_STATE_POINTERS_PS,
   };

   GLbitfield SamplersUsed = prog->SamplersUsed;

   if (sampler_count == 0)
      return;

   samplers = brw_state_batch(brw, AUB_TRACE_SAMPLER_STATE,
			      sampler_count * sizeof(*samplers),
			      32, &stage_state->sampler_offset);
   memset(samplers, 0, sampler_count * sizeof(*samplers));

   for (unsigned s = 0; s < sampler_count; s++) {
      if (SamplersUsed & (1 << s)) {
         const unsigned unit = prog->SamplerUnits[s];
         if (ctx->Texture.Unit[unit]._Current)
            gen7_update_sampler_state(brw, unit, s, &samplers[s],
                                      &stage_state->sdc_offset[s]);
      }
   }

  if (brw->gen == 7 && !brw->is_haswell &&
      stage_state->stage == MESA_SHADER_VERTEX) {
      gen7_emit_vs_workaround_flush(brw);
  }

   BEGIN_BATCH(2);
   OUT_BATCH(packet_headers[stage_state->stage] << 16 | (2 - 2));
   OUT_BATCH(stage_state->sampler_offset);
   ADVANCE_BATCH();
}

void
gen7_init_vtable_sampler_functions(struct brw_context *brw)
{
   brw->vtbl.upload_sampler_state_table = gen7_upload_sampler_state_table;
}
@


1.5
log
@Merge Mesa 10.2.9
@
text
@@


1.4
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@@


1.3
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.2
log
@Merge Mesa 9.2.0
@
text
@d28 1
d38 2
a39 1
			  struct gen7_sampler_state *sampler)
d85 1
d106 1
a106 1
   sampler->ss3.r_wrap_mode = translate_wrap_mode(gl_sampler->WrapR,
d108 1
a108 1
   sampler->ss3.s_wrap_mode = translate_wrap_mode(gl_sampler->WrapS,
d110 1
a110 1
   sampler->ss3.t_wrap_mode = translate_wrap_mode(gl_sampler->WrapT,
d118 1
a118 1
      if (ctx->Texture.CubeMapSeamless &&
a154 7
   /* Set BaseMipLevel, MaxLOD, MinLOD:
    *
    * XXX: I don't think that using firstLevel, lastLevel works,
    * because we always setup the surface state as if firstLevel ==
    * level zero.  Probably have to subtract firstLevel from each of
    * these:
    */
d167 1
a167 1
   upload_default_color(brw, gl_sampler, unit, ss_index);
d169 1
a169 1
   sampler->ss2.default_color_pointer = brw->wm.sdc_offset[ss_index] >> 5;
d183 3
a185 1
gen7_upload_samplers(struct brw_context *brw)
d189 6
d196 1
a196 7
   /* BRW_NEW_VERTEX_PROGRAM and BRW_NEW_FRAGMENT_PROGRAM */
   struct gl_program *vs = (struct gl_program *) brw->vertex_program;
   struct gl_program *fs = (struct gl_program *) brw->fragment_program;

   GLbitfield SamplersUsed = vs->SamplersUsed | fs->SamplersUsed;

   brw->sampler.count = _mesa_fls(SamplersUsed);
d198 1
a198 1
   if (brw->sampler.count == 0)
d202 3
a204 3
			      brw->sampler.count * sizeof(*samplers),
			      32, &brw->sampler.offset);
   memset(samplers, 0, brw->sampler.count * sizeof(*samplers));
d206 1
a206 1
   for (unsigned s = 0; s < brw->sampler.count; s++) {
d208 4
a211 4
         const unsigned unit = (fs->SamplersUsed & (1 << s)) ?
            fs->SamplerUnits[s] : vs->SamplerUnits[s];
         if (ctx->Texture.Unit[unit]._ReallyEnabled)
            gen7_update_sampler_state(brw, unit, s, &samplers[s]);
d215 9
a223 1
   brw->state.dirty.cache |= CACHE_NEW_SAMPLER;
d226 5
a230 10
const struct brw_tracked_state gen7_samplers = {
   .dirty = {
      .mesa = _NEW_TEXTURE,
      .brw = BRW_NEW_BATCH |
             BRW_NEW_VERTEX_PROGRAM |
             BRW_NEW_FRAGMENT_PROGRAM,
      .cache = 0
   },
   .emit = gen7_upload_samplers,
};
@


1.1
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d36 1
a36 1
gen7_update_sampler_state(struct brw_context *brw, int unit,
d39 1
a39 2
   struct intel_context *intel = &brw->intel;
   struct gl_context *ctx = &intel->ctx;
d45 4
d113 2
a114 1
   if (texObj->Target == GL_TEXTURE_CUBE_MAP) {
d164 8
a171 1
   upload_default_color(brw, gl_sampler, unit);
d173 1
a173 1
   sampler->ss2.default_color_pointer = brw->wm.sdc_offset[unit] >> 5;
a185 4
/* All samplers must be uploaded in a single contiguous array, which
 * complicates various things.  However, this is still too confusing -
 * FIXME: simplify all the different new texture state flags.
 */
d187 1
a187 1
gen7_prepare_samplers(struct brw_context *brw)
d189 1
a189 1
   struct gl_context *ctx = &brw->intel.ctx;
a190 1
   int i;
d192 7
a198 5
   brw->wm.sampler_count = 0;
   for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
      if (ctx->Texture.Unit[i]._ReallyEnabled)
	 brw->wm.sampler_count = i + 1;
   }
d200 1
a200 1
   if (brw->wm.sampler_count == 0)
d203 12
a214 7
   samplers = brw_state_batch(brw, brw->wm.sampler_count * sizeof(*samplers),
			      32, &brw->wm.sampler_offset);
   memset(samplers, 0, brw->wm.sampler_count * sizeof(*samplers));

   for (i = 0; i < brw->wm.sampler_count; i++) {
      if (ctx->Texture.Unit[i]._ReallyEnabled)
	 gen7_update_sampler_state(brw, i, &samplers[i]);
d223 3
a225 1
      .brw = BRW_NEW_BATCH,
d228 1
a228 1
   .prepare = gen7_prepare_samplers,
@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@d36 1
a36 1
gen7_update_sampler_state(struct brw_context *brw, int unit, int ss_index,
d39 2
a40 1
   struct gl_context *ctx = &brw->ctx;
a45 4
   /* These don't use samplers at all. */
   if (texObj->Target == GL_TEXTURE_BUFFER)
      return;

d110 1
a110 2
   if (texObj->Target == GL_TEXTURE_CUBE_MAP ||
       texObj->Target == GL_TEXTURE_CUBE_MAP_ARRAY) {
d160 1
a160 8
   /* The sampler can handle non-normalized texture rectangle coordinates
    * natively
    */
   if (texObj->Target == GL_TEXTURE_RECTANGLE) {
      sampler->ss3.non_normalized_coord = 1;
   }

   upload_default_color(brw, gl_sampler, unit, ss_index);
d162 1
a162 1
   sampler->ss2.default_color_pointer = brw->wm.sdc_offset[ss_index] >> 5;
d175 4
d180 1
a180 1
gen7_upload_samplers(struct brw_context *brw)
d182 1
a182 1
   struct gl_context *ctx = &brw->ctx;
d184 1
d186 5
a190 5
   /* BRW_NEW_VERTEX_PROGRAM and BRW_NEW_FRAGMENT_PROGRAM */
   struct gl_program *vs = (struct gl_program *) brw->vertex_program;
   struct gl_program *fs = (struct gl_program *) brw->fragment_program;

   GLbitfield SamplersUsed = vs->SamplersUsed | fs->SamplersUsed;
d192 1
a192 3
   brw->sampler.count = _mesa_fls(SamplersUsed);

   if (brw->sampler.count == 0)
d195 7
a201 12
   samplers = brw_state_batch(brw, AUB_TRACE_SAMPLER_STATE,
			      brw->sampler.count * sizeof(*samplers),
			      32, &brw->sampler.offset);
   memset(samplers, 0, brw->sampler.count * sizeof(*samplers));

   for (unsigned s = 0; s < brw->sampler.count; s++) {
      if (SamplersUsed & (1 << s)) {
         const unsigned unit = (fs->SamplersUsed & (1 << s)) ?
            fs->SamplerUnits[s] : vs->SamplerUnits[s];
         if (ctx->Texture.Unit[unit]._ReallyEnabled)
            gen7_update_sampler_state(brw, unit, s, &samplers[s]);
      }
d210 1
a210 3
      .brw = BRW_NEW_BATCH |
             BRW_NEW_VERTEX_PROGRAM |
             BRW_NEW_FRAGMENT_PROGRAM,
d213 1
a213 1
   .emit = gen7_upload_samplers,
@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@a27 1
#include "intel_mipmap_tree.h"
d37 1
a37 2
			  struct gen7_sampler_state *sampler,
                          uint32_t *sdc_offset)
a82 1
      sampler->ss0.aniso_algorithm = 1;
d103 1
a103 1
   sampler->ss3.r_wrap_mode = translate_wrap_mode(brw, gl_sampler->WrapR,
d105 1
a105 1
   sampler->ss3.s_wrap_mode = translate_wrap_mode(brw, gl_sampler->WrapS,
d107 1
a107 1
   sampler->ss3.t_wrap_mode = translate_wrap_mode(brw, gl_sampler->WrapT,
d115 1
a115 1
      if ((ctx->Texture.CubeMapSeamless || gl_sampler->CubeMapSeamless) &&
d152 7
d171 1
a171 1
   upload_default_color(brw, gl_sampler, unit, sdc_offset);
d173 1
a173 1
   sampler->ss2.default_color_pointer = *sdc_offset >> 5;
d187 1
a187 3
gen7_upload_sampler_state_table(struct brw_context *brw,
                                struct gl_program *prog,
                                struct brw_stage_state *stage_state)
a190 6
   uint32_t sampler_count = stage_state->sampler_count;
   static const uint16_t packet_headers[] = {
      [MESA_SHADER_VERTEX] = _3DSTATE_SAMPLER_STATE_POINTERS_VS,
      [MESA_SHADER_GEOMETRY] = _3DSTATE_SAMPLER_STATE_POINTERS_GS,
      [MESA_SHADER_FRAGMENT] = _3DSTATE_SAMPLER_STATE_POINTERS_PS,
   };
d192 7
a198 1
   GLbitfield SamplersUsed = prog->SamplersUsed;
d200 1
a200 1
   if (sampler_count == 0)
d204 3
a206 3
			      sampler_count * sizeof(*samplers),
			      32, &stage_state->sampler_offset);
   memset(samplers, 0, sampler_count * sizeof(*samplers));
d208 1
a208 1
   for (unsigned s = 0; s < sampler_count; s++) {
d210 4
a213 4
         const unsigned unit = prog->SamplerUnits[s];
         if (ctx->Texture.Unit[unit]._Current)
            gen7_update_sampler_state(brw, unit, s, &samplers[s],
                                      &stage_state->sdc_offset[s]);
d217 1
a217 9
  if (brw->gen == 7 && !brw->is_haswell &&
      stage_state->stage == MESA_SHADER_VERTEX) {
      gen7_emit_vs_workaround_flush(brw);
  }

   BEGIN_BATCH(2);
   OUT_BATCH(packet_headers[stage_state->stage] << 16 | (2 - 2));
   OUT_BATCH(stage_state->sampler_offset);
   ADVANCE_BATCH();
d220 10
a229 5
void
gen7_init_vtable_sampler_functions(struct brw_context *brw)
{
   brw->vtbl.upload_sampler_state_table = gen7_upload_sampler_state_table;
}
@


