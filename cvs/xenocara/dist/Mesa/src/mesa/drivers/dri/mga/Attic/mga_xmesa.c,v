head	1.7;
access;
symbols
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2013.09.05.14.04.43;	author jsg;	state dead;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.20;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.16;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.53.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.53.03;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.21;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.28.51;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.39;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@/*
 * Copyright 2000-2001 VA Linux Systems, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file mga_xmesa.c
 * MGA screen and context initialization / creation code.
 *
 * \author Keith Whitwell <keith@@tungstengraphics.com>
 */

#include <stdlib.h>
#include <stdint.h>
#include "drm.h"
#include "mga_drm.h"
#include "mga_xmesa.h"
#include "main/context.h"
#include "main/simple_list.h"
#include "main/imports.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"

#include "swrast/swrast.h"
#include "swrast_setup/swrast_setup.h"
#include "tnl/tnl.h"
#include "vbo/vbo.h"

#include "tnl/t_pipeline.h"

#include "drivers/common/driverfuncs.h"

#include "mgadd.h"
#include "mgastate.h"
#include "mgatex.h"
#include "mgaspan.h"
#include "mgaioctl.h"
#include "mgatris.h"
#include "mgavb.h"
#include "mgapixel.h"
#include "mga_dri.h"

#include "utils.h"
#include "vblank.h"

#include "drirenderbuffer.h"

#include "GL/internal/dri_interface.h"

#define need_GL_ARB_vertex_array_object
#define need_GL_ARB_vertex_program
#define need_GL_EXT_fog_coord
#define need_GL_EXT_gpu_program_parameters
#define need_GL_EXT_secondary_color
#if 0
#define need_GL_EXT_paletted_texture
#endif
#define need_GL_APPLE_vertex_array_object
#define need_GL_NV_vertex_program
#include "main/remap_helper.h"

/* MGA configuration
 */
#include "xmlpool.h"

PUBLIC const char __driConfigOptions[] =
DRI_CONF_BEGIN
    DRI_CONF_SECTION_PERFORMANCE
        DRI_CONF_VBLANK_MODE(DRI_CONF_VBLANK_DEF_INTERVAL_0)
    DRI_CONF_SECTION_END
    DRI_CONF_SECTION_QUALITY
        DRI_CONF_TEXTURE_DEPTH(DRI_CONF_TEXTURE_DEPTH_FB)
        DRI_CONF_COLOR_REDUCTION(DRI_CONF_COLOR_REDUCTION_DITHER)
    DRI_CONF_SECTION_END
    DRI_CONF_SECTION_SOFTWARE
        DRI_CONF_ARB_VERTEX_PROGRAM(true)
        DRI_CONF_NV_VERTEX_PROGRAM(true)
    DRI_CONF_SECTION_END
    DRI_CONF_SECTION_DEBUG
        DRI_CONF_NO_RAST(false)
    DRI_CONF_SECTION_END
DRI_CONF_END;
static const GLuint __driNConfigOptions = 6;

#ifndef MGA_DEBUG
int MGA_DEBUG = 0;
#endif

static const __DRIconfig **
mgaFillInModes( __DRIscreen *psp,
		unsigned pixel_bits, unsigned depth_bits,
		unsigned stencil_bits, GLboolean have_back_buffer )
{
    __DRIconfig **configs;
    struct gl_config * m;
    unsigned depth_buffer_factor;
    unsigned back_buffer_factor;
    GLenum fb_format;
    GLenum fb_type;
    int i;

    /* GLX_SWAP_COPY_OML is only supported because the MGA driver doesn't
     * support pageflipping at all.
     */
    static const GLenum back_buffer_modes[] = {
	GLX_NONE, GLX_SWAP_UNDEFINED_OML, GLX_SWAP_COPY_OML
    };

    uint8_t depth_bits_array[3];
    uint8_t stencil_bits_array[3];
    uint8_t msaa_samples_array[1];


    depth_bits_array[0] = 0;
    depth_bits_array[1] = depth_bits;
    depth_bits_array[2] = depth_bits;
    
    /* Just like with the accumulation buffer, always provide some modes
     * with a stencil buffer.  It will be a sw fallback, but some apps won't
     * care about that.
     */
    stencil_bits_array[0] = 0;
    stencil_bits_array[1] = 0;
    stencil_bits_array[2] = (stencil_bits == 0) ? 8 : stencil_bits;

    msaa_samples_array[0] = 0;

    depth_buffer_factor = ((depth_bits != 0) || (stencil_bits != 0)) ? 3 : 1;
    back_buffer_factor  = (have_back_buffer) ? 2 : 1;

    if ( pixel_bits == 16 ) {
        fb_format = GL_RGB;
        fb_type = GL_UNSIGNED_SHORT_5_6_5;
    }
    else {
        fb_format = GL_BGR;
        fb_type = GL_UNSIGNED_INT_8_8_8_8_REV;
    }

    configs = driCreateConfigs(fb_format, fb_type,
			       depth_bits_array, stencil_bits_array,
			       depth_buffer_factor,
			       back_buffer_modes, back_buffer_factor,
                               msaa_samples_array, 1, GL_TRUE);
    if (configs == NULL) {
	fprintf( stderr, "[%s:%u] Error creating FBConfig!\n",
		 __func__, __LINE__ );
	return NULL;
    }

   /* Mark the visual as slow if there are "fake" stencil bits.
    */
   for (i = 0; configs[i]; i++) {
      m = &configs[i]->modes;
      if ((m->stencilBits != 0) && (m->stencilBits != stencil_bits)) {
         m->visualRating = GLX_SLOW_CONFIG;
      }
   }

   return (const __DRIconfig **) configs;
}

const __DRIextension *mgaScreenExtensions[] = {
    &driReadDrawableExtension,
    &driSwapControlExtension.base,
    &driMediaStreamCounterExtension.base,
    NULL
};

static GLboolean
mgaInitDriver(__DRIscreen *sPriv)
{
   mgaScreenPrivate *mgaScreen;
   MGADRIPtr         serverInfo = (MGADRIPtr)sPriv->pDevPriv;

   if (sPriv->devPrivSize != sizeof(MGADRIRec)) {
      fprintf(stderr,"\nERROR!  sizeof(MGADRIRec) does not match passed size from device driver\n");
      return GL_FALSE;
   }

   /* Allocate the private area */
   mgaScreen = (mgaScreenPrivate *)MALLOC(sizeof(mgaScreenPrivate));
   if (!mgaScreen) {
      __driUtilMessage("Couldn't malloc screen struct");
      return GL_FALSE;
   }

   mgaScreen->sPriv = sPriv;
   sPriv->private = (void *)mgaScreen;

   if (sPriv->drm_version.minor >= 1) {
      int ret;
      drm_mga_getparam_t gp;

      gp.param = MGA_PARAM_IRQ_NR;
      gp.value = &mgaScreen->irq;
      mgaScreen->irq = 0;

      ret = drmCommandWriteRead( sPriv->fd, DRM_MGA_GETPARAM,
				    &gp, sizeof(gp));
      if (ret) {
	    fprintf(stderr, "drmMgaGetParam (MGA_PARAM_IRQ_NR): %d\n", ret);
	    FREE(mgaScreen);
	    sPriv->private = NULL;
	    return GL_FALSE;
      }
   }

   sPriv->extensions = mgaScreenExtensions;

   if (serverInfo->chipset != MGA_CARD_TYPE_G200 &&
       serverInfo->chipset != MGA_CARD_TYPE_G400) {
      FREE(mgaScreen);
      sPriv->private = NULL;
      __driUtilMessage("Unrecognized chipset");
      return GL_FALSE;
   }


   mgaScreen->chipset = serverInfo->chipset;
   mgaScreen->cpp = serverInfo->cpp;

   mgaScreen->agpMode = serverInfo->agpMode;

   mgaScreen->frontPitch = serverInfo->frontPitch;
   mgaScreen->frontOffset = serverInfo->frontOffset;
   mgaScreen->backOffset = serverInfo->backOffset;
   mgaScreen->backPitch  =  serverInfo->backPitch;
   mgaScreen->depthOffset = serverInfo->depthOffset;
   mgaScreen->depthPitch  =  serverInfo->depthPitch;


   /* The only reason that the MMIO region needs to be accessable and the
    * primary DMA region base address needs to be known is so that the driver
    * can busy wait for certain DMA operations to complete (see
    * mgaWaitForFrameCompletion in mgaioctl.c).
    *
    * Starting with MGA DRM version 3.2, these are completely unneeded as
    * there is a new, in-kernel mechanism for handling the wait.
    */

   if (mgaScreen->sPriv->drm_version.minor < 2) {
      mgaScreen->mmio.handle = serverInfo->registers.handle;
      mgaScreen->mmio.size = serverInfo->registers.size;
      if ( drmMap( sPriv->fd,
		   mgaScreen->mmio.handle, mgaScreen->mmio.size,
		   &mgaScreen->mmio.map ) < 0 ) {
	 FREE( mgaScreen );
	 sPriv->private = NULL;
	 __driUtilMessage( "Couldn't map MMIO registers" );
	 return GL_FALSE;
      }

      mgaScreen->primary.handle = serverInfo->primary.handle;
      mgaScreen->primary.size = serverInfo->primary.size;
   }
   else {
      (void) memset( & mgaScreen->primary, 0, sizeof( mgaScreen->primary ) );
      (void) memset( & mgaScreen->mmio, 0, sizeof( mgaScreen->mmio ) );
   }

   mgaScreen->textureOffset[MGA_CARD_HEAP] = serverInfo->textureOffset;
   mgaScreen->textureOffset[MGA_AGP_HEAP] = (serverInfo->agpTextureOffset |
					     PDEA_pagpxfer_enable | 1);

   mgaScreen->textureSize[MGA_CARD_HEAP] = serverInfo->textureSize;
   mgaScreen->textureSize[MGA_AGP_HEAP] = serverInfo->agpTextureSize;

   
   /* The texVirtual array stores the base addresses in the CPU's address
    * space of the texture memory pools.  The base address of the on-card
    * memory pool is calculated as an offset of the base of video memory.  The
    * AGP texture pool has to be mapped into the processes address space by
    * the DRM. 
    */

   mgaScreen->texVirtual[MGA_CARD_HEAP] = (char *)(mgaScreen->sPriv->pFB +
					   serverInfo->textureOffset);

   if ( serverInfo->agpTextureSize > 0 ) {
      if (drmMap(sPriv->fd, serverInfo->agpTextureOffset,
		 serverInfo->agpTextureSize,
		 (drmAddress *)&mgaScreen->texVirtual[MGA_AGP_HEAP]) != 0) {
	 FREE(mgaScreen);
	 sPriv->private = NULL;
	 __driUtilMessage("Couldn't map agptexture region");
	 return GL_FALSE;
      }
   }


   /* For calculating setupdma addresses.
    */

   mgaScreen->bufs = drmMapBufs(sPriv->fd);
   if (!mgaScreen->bufs) {
      FREE(mgaScreen);
      sPriv->private = NULL;
      __driUtilMessage("Couldn't map dma buffers");
      return GL_FALSE;
   }
   mgaScreen->sarea_priv_offset = serverInfo->sarea_priv_offset;

   /* parse information in __driConfigOptions */
   driParseOptionInfo (&mgaScreen->optionCache,
		       __driConfigOptions, __driNConfigOptions);

   return GL_TRUE;
}


static void
mgaDestroyScreen(__DRIscreen *sPriv)
{
   mgaScreenPrivate *mgaScreen = (mgaScreenPrivate *) sPriv->private;

   if (MGA_DEBUG&DEBUG_VERBOSE_DRI)
      fprintf(stderr, "mgaDestroyScreen\n");

   drmUnmapBufs(mgaScreen->bufs);


   /* free all option information */
   driDestroyOptionInfo (&mgaScreen->optionCache);

   FREE(mgaScreen);
   sPriv->private = NULL;
}


extern const struct tnl_pipeline_stage _mga_render_stage;

static const struct tnl_pipeline_stage *mga_pipeline[] = {
   &_tnl_vertex_transform_stage, 
   &_tnl_normal_transform_stage, 
   &_tnl_lighting_stage,	
   &_tnl_fog_coordinate_stage,
   &_tnl_texgen_stage, 
   &_tnl_texture_transform_stage, 
   &_tnl_vertex_program_stage,

				/* REMOVE: point attenuation stage */
#if 0
   &_mga_render_stage,		/* ADD: unclipped rastersetup-to-dma */
                                /* Need new ioctl for wacceptseq */
#endif
   &_tnl_render_stage,		
   0,
};


static const struct dri_extension g400_extensions[] =
{
   { "GL_ARB_multitexture",           NULL },
   { "GL_ARB_texture_env_add",        NULL },
   { "GL_ARB_texture_env_combine",    NULL },
   { "GL_ARB_texture_env_crossbar",   NULL },
   { "GL_EXT_texture_env_combine",    NULL },
   { "GL_EXT_texture_edge_clamp",     NULL },
   { "GL_ATI_texture_env_combine3",   NULL },
   { NULL,                            NULL }
};

static const struct dri_extension card_extensions[] =
{
   { "GL_ARB_texture_rectangle",      NULL },
   { "GL_ARB_vertex_array_object",    GL_ARB_vertex_array_object_functions },
   { "GL_EXT_blend_logic_op",         NULL },
   { "GL_EXT_fog_coord",              GL_EXT_fog_coord_functions },
   /* paletted_textures currently doesn't work, but we could fix them later */
#if defined( need_GL_EXT_paletted_texture )
   { "GL_EXT_shared_texture_palette", NULL },
   { "GL_EXT_paletted_texture",       GL_EXT_paletted_texture_functions },
#endif
   { "GL_EXT_secondary_color",        GL_EXT_secondary_color_functions },
   { "GL_EXT_stencil_wrap",           NULL },
   { "GL_APPLE_vertex_array_object",  GL_APPLE_vertex_array_object_functions },
   { "GL_MESA_ycbcr_texture",         NULL },
   { NULL,                            NULL }
};

static const struct dri_extension ARB_vp_extensions[] = {
   { "GL_ARB_vertex_program",         GL_ARB_vertex_program_functions },
   { "GL_EXT_gpu_program_parameters", GL_EXT_gpu_program_parameters_functions },
   { NULL,                            NULL }
};

static const struct dri_extension NV_vp_extensions[] = {
   { "GL_NV_vertex_program",          GL_NV_vertex_program_functions },
   { "GL_NV_vertex_program1_1",       NULL },
   { NULL,                            NULL }
};

static const struct dri_debug_control debug_control[] =
{
    { "fall",  DEBUG_VERBOSE_FALLBACK },
    { "tex",   DEBUG_VERBOSE_TEXTURE },
    { "ioctl", DEBUG_VERBOSE_IOCTL },
    { "verb",  DEBUG_VERBOSE_MSG },
    { "dri",   DEBUG_VERBOSE_DRI },
    { NULL,    0 }
};


static GLboolean
mgaCreateContext( gl_api api,
		  const struct gl_config *mesaVis,
                  __DRIcontext *driContextPriv,
                  void *sharedContextPrivate )
{
   int i;
   unsigned   maxlevels;
   struct gl_context *ctx, *shareCtx;
   mgaContextPtr mmesa;
   __DRIscreen *sPriv = driContextPriv->driScreenPriv;
   mgaScreenPrivate *mgaScreen = (mgaScreenPrivate *)sPriv->private;
   drm_mga_sarea_t *saPriv = (drm_mga_sarea_t *)(((char*)sPriv->pSAREA)+
					      mgaScreen->sarea_priv_offset);
   struct dd_function_table functions;

   if (MGA_DEBUG&DEBUG_VERBOSE_DRI)
      fprintf(stderr, "mgaCreateContext\n");

   /* allocate mga context */
   mmesa = (mgaContextPtr) CALLOC(sizeof(mgaContext));
   if (!mmesa) {
      return GL_FALSE;
   }

   /* Init default driver functions then plug in our Radeon-specific functions
    * (the texture functions are especially important)
    */
   _mesa_init_driver_functions( &functions );
   mgaInitDriverFuncs( &functions );
   mgaInitTextureFuncs( &functions );
   mgaInitIoctlFuncs( &functions );

   /* Allocate the Mesa context */
   if (sharedContextPrivate)
      shareCtx = ((mgaContextPtr) sharedContextPrivate)->glCtx;
   else 
      shareCtx = NULL;
   mmesa->glCtx = _mesa_create_context(API_OPENGL, mesaVis, shareCtx,
                                       &functions, (void *) mmesa);
   if (!mmesa->glCtx) {
      FREE(mmesa);
      return GL_FALSE;
   }
   driContextPriv->driverPrivate = mmesa;

   /* Init mga state */
   mmesa->hHWContext = driContextPriv->hHWContext;
   mmesa->driFd = sPriv->fd;
   mmesa->driHwLock = &sPriv->pSAREA->lock;

   mmesa->mgaScreen = mgaScreen;
   mmesa->driScreen = sPriv;
   mmesa->sarea = (void *)saPriv;

   /* Parse configuration files */
   driParseConfigFiles (&mmesa->optionCache, &mgaScreen->optionCache,
                        sPriv->myNum, "mga");

   (void) memset( mmesa->texture_heaps, 0, sizeof( mmesa->texture_heaps ) );
   make_empty_list( & mmesa->swapped );

   mmesa->nr_heaps = mgaScreen->texVirtual[MGA_AGP_HEAP] ? 2 : 1;
   for ( i = 0 ; i < mmesa->nr_heaps ; i++ ) {
      mmesa->texture_heaps[i] = driCreateTextureHeap( i, mmesa,
	    mgaScreen->textureSize[i],
	    6,
	    MGA_NR_TEX_REGIONS,
	    (drmTextureRegionPtr)mmesa->sarea->texList[i],
	    &mmesa->sarea->texAge[i],
	    &mmesa->swapped,
	    sizeof( mgaTextureObject_t ),
	    (destroy_texture_object_t *) mgaDestroyTexObj );
   }

   /* Set the maximum texture size small enough that we can guarentee
    * that both texture units can bind a maximal texture and have them
    * on the card at once.
    */
   ctx = mmesa->glCtx;
   if ( mgaScreen->chipset == MGA_CARD_TYPE_G200 ) {
      ctx->Const.MaxTextureUnits = 1;
      ctx->Const.MaxTextureImageUnits = 1;
      ctx->Const.MaxTextureCoordUnits = 1;
      maxlevels = G200_TEX_MAXLEVELS;

   }
   else {
      ctx->Const.MaxTextureUnits = 2;
      ctx->Const.MaxTextureImageUnits = 2;
      ctx->Const.MaxTextureCoordUnits = 2;
      maxlevels = G400_TEX_MAXLEVELS;
   }

   driCalculateMaxTextureLevels( mmesa->texture_heaps,
				 mmesa->nr_heaps,
				 & ctx->Const,
				 4,
				 11, /* max 2D texture size is 2048x2048 */
				 0,  /* 3D textures unsupported. */
				 0,  /* cube textures unsupported. */
				 11, /* max texture rect size is 2048x2048 */
				 maxlevels,
				 GL_FALSE,
				 0 );

   ctx->Const.MinLineWidth = 1.0;
   ctx->Const.MinLineWidthAA = 1.0;
   ctx->Const.MaxLineWidth = 10.0;
   ctx->Const.MaxLineWidthAA = 10.0;
   ctx->Const.LineWidthGranularity = 1.0;

   ctx->Const.MaxDrawBuffers = 1;

   mmesa->texture_depth = driQueryOptioni (&mmesa->optionCache,
					   "texture_depth");
   if (mmesa->texture_depth == DRI_CONF_TEXTURE_DEPTH_FB)
      mmesa->texture_depth = ( mesaVis->rgbBits >= 24 ) ?
	 DRI_CONF_TEXTURE_DEPTH_32 : DRI_CONF_TEXTURE_DEPTH_16;
   mmesa->hw_stencil = mesaVis->stencilBits && mesaVis->depthBits == 24;

   switch (mesaVis->depthBits) {
   case 16: 
      mmesa->depth_scale = 1.0/(GLdouble)0xffff; 
      mmesa->depth_clear_mask = ~0;
      mmesa->ClearDepth = 0xffff;
      break;
   case 24:
      mmesa->depth_scale = 1.0/(GLdouble)0xffffff;
      if (mmesa->hw_stencil) {
	 mmesa->depth_clear_mask = 0xffffff00;
	 mmesa->stencil_clear_mask = 0x000000ff;
      } else
	 mmesa->depth_clear_mask = ~0;
      mmesa->ClearDepth = 0xffffff00;
      break;
   case 32:
      mmesa->depth_scale = 1.0/(GLdouble)0xffffffff;
      mmesa->depth_clear_mask = ~0;
      mmesa->ClearDepth = 0xffffffff;
      break;
   };

   mmesa->haveHwStipple = GL_FALSE;
   mmesa->RenderIndex = -1;		/* impossible value */
   mmesa->dirty = ~0;
   mmesa->vertex_format = 0;   
   mmesa->CurrentTexObj[0] = 0;
   mmesa->CurrentTexObj[1] = 0;
   mmesa->tmu_source[0] = 0;
   mmesa->tmu_source[1] = 1;

   mmesa->texAge[0] = 0;
   mmesa->texAge[1] = 0;
   
   /* Initialize the software rasterizer and helper modules.
    */
   _swrast_CreateContext( ctx );
   _vbo_CreateContext( ctx );
   _tnl_CreateContext( ctx );
   
   _swsetup_CreateContext( ctx );

   /* Install the customized pipeline:
    */
   _tnl_destroy_pipeline( ctx );
   _tnl_install_pipeline( ctx, mga_pipeline );

   /* Configure swrast and T&L to match hardware characteristics:
    */
   _swrast_allow_pixel_fog( ctx, GL_FALSE );
   _swrast_allow_vertex_fog( ctx, GL_TRUE );
   _tnl_allow_pixel_fog( ctx, GL_FALSE );
   _tnl_allow_vertex_fog( ctx, GL_TRUE );

   mmesa->primary_offset = mmesa->mgaScreen->primary.handle;

   ctx->DriverCtx = (void *) mmesa;
   mmesa->glCtx = ctx;

   driInitExtensions( ctx, card_extensions, GL_FALSE );

   if (MGA_IS_G400(MGA_CONTEXT(ctx))) {
      driInitExtensions( ctx, g400_extensions, GL_FALSE );
   }

   if ( driQueryOptionb( &mmesa->optionCache, "arb_vertex_program" ) ) {
      driInitExtensions(ctx, ARB_vp_extensions, GL_FALSE);
   }
   
   if ( driQueryOptionb( &mmesa->optionCache, "nv_vertex_program" ) ) {
      driInitExtensions( ctx, NV_vp_extensions, GL_FALSE );
   }

	
   /* XXX these should really go right after _mesa_init_driver_functions() */
   mgaDDInitStateFuncs( ctx );
   mgaDDInitSpanFuncs( ctx );
   mgaDDInitPixelFuncs( ctx );
   mgaDDInitTriFuncs( ctx );

   mgaInitVB( ctx );
   mgaInitState( mmesa );

   driContextPriv->driverPrivate = (void *) mmesa;

#if DO_DEBUG
   MGA_DEBUG = driParseDebugString( getenv( "MGA_DEBUG" ),
				    debug_control );
#endif

   (*sPriv->systemTime->getUST)( & mmesa->swap_ust );

   if (driQueryOptionb(&mmesa->optionCache, "no_rast")) {
      fprintf(stderr, "disabling 3D acceleration\n");
      FALLBACK(mmesa->glCtx, MGA_FALLBACK_DISABLE, 1);
   }

   return GL_TRUE;
}

static void
mgaDestroyContext(__DRIcontext *driContextPriv)
{
   mgaContextPtr mmesa = (mgaContextPtr) driContextPriv->driverPrivate;

   if (MGA_DEBUG&DEBUG_VERBOSE_DRI)
      fprintf( stderr, "[%s:%d] mgaDestroyContext start\n",
	       __FILE__, __LINE__ );

   assert(mmesa); /* should never be null */
   if (mmesa) {
      GLboolean   release_texture_heaps;


      release_texture_heaps = (mmesa->glCtx->Shared->RefCount == 1);
      _swsetup_DestroyContext( mmesa->glCtx );
      _tnl_DestroyContext( mmesa->glCtx );
      _vbo_DestroyContext( mmesa->glCtx );
      _swrast_DestroyContext( mmesa->glCtx );

      mgaFreeVB( mmesa->glCtx );

      /* free the Mesa context */
      mmesa->glCtx->DriverCtx = NULL;
      _mesa_destroy_context(mmesa->glCtx);
       
      if ( release_texture_heaps ) {
         /* This share group is about to go away, free our private
          * texture object data.
          */
         int i;

         for ( i = 0 ; i < mmesa->nr_heaps ; i++ ) {
	    driDestroyTextureHeap( mmesa->texture_heaps[ i ] );
	    mmesa->texture_heaps[ i ] = NULL;
         }

	 assert( is_empty_list( & mmesa->swapped ) );
      }

      /* free the option cache */
      driDestroyOptionCache (&mmesa->optionCache);

      FREE(mmesa);
   }

   if (MGA_DEBUG&DEBUG_VERBOSE_DRI)
      fprintf( stderr, "[%s:%d] mgaDestroyContext done\n",
	       __FILE__, __LINE__ );
}


static GLboolean
mgaCreateBuffer( __DRIscreen *driScrnPriv,
                 __DRIdrawable *driDrawPriv,
                 const struct gl_config *mesaVis,
                 GLboolean isPixmap )
{
   mgaScreenPrivate *screen = (mgaScreenPrivate *) driScrnPriv->private;

   if (isPixmap) {
      return GL_FALSE; /* not implemented */
   }
   else {
      GLboolean swStencil = (mesaVis->stencilBits > 0 && 
			     mesaVis->depthBits != 24);

#if 0
      driDrawPriv->driverPrivate = (void *) 
         _mesa_create_framebuffer(mesaVis,
                                  GL_FALSE,  /* software depth buffer? */
                                  swStencil,
                                  mesaVis->accumRedBits > 0,
                                  mesaVis->alphaBits > 0 );
#else
      struct gl_framebuffer *fb = _mesa_create_framebuffer(mesaVis);

      {
         driRenderbuffer *frontRb
            = driNewRenderbuffer(MESA_FORMAT_ARGB8888,
                                 NULL,
                                 screen->cpp,
                                 screen->frontOffset, screen->frontPitch,
                                 driDrawPriv);
         mgaSetSpanFunctions(frontRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_FRONT_LEFT, &frontRb->Base);
      }

      if (mesaVis->doubleBufferMode) {
         driRenderbuffer *backRb
            = driNewRenderbuffer(MESA_FORMAT_ARGB8888,
                                 NULL,
                                 screen->cpp,
                                 screen->backOffset, screen->backPitch,
                                 driDrawPriv);
         mgaSetSpanFunctions(backRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_BACK_LEFT, &backRb->Base);
      }

      if (mesaVis->depthBits == 16) {
         driRenderbuffer *depthRb
            = driNewRenderbuffer(MESA_FORMAT_Z16,
                                 NULL,
                                 screen->cpp,
                                 screen->depthOffset, screen->depthPitch,
                                 driDrawPriv);
         mgaSetSpanFunctions(depthRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthRb->Base);
      }
      else if (mesaVis->depthBits == 24) {
         /* XXX is this right? */
         if (mesaVis->stencilBits) {
            driRenderbuffer *depthRb
               = driNewRenderbuffer(MESA_FORMAT_Z24_S8,
                                    NULL,
                                    screen->cpp,
                                    screen->depthOffset, screen->depthPitch,
                                    driDrawPriv);
            mgaSetSpanFunctions(depthRb, mesaVis);
            _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthRb->Base);
         }
         else {
            driRenderbuffer *depthRb
               = driNewRenderbuffer(MESA_FORMAT_Z32,
                                    NULL,
                                    screen->cpp,
                                    screen->depthOffset, screen->depthPitch,
                                    driDrawPriv);
            mgaSetSpanFunctions(depthRb, mesaVis);
            _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthRb->Base);
         }
      }
      else if (mesaVis->depthBits == 32) {
         driRenderbuffer *depthRb
            = driNewRenderbuffer(MESA_FORMAT_Z32,
                                 NULL,
                                 screen->cpp,
                                 screen->depthOffset, screen->depthPitch,
                                 driDrawPriv);
         mgaSetSpanFunctions(depthRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &depthRb->Base);
      }

      if (mesaVis->stencilBits > 0 && !swStencil) {
         driRenderbuffer *stencilRb
            = driNewRenderbuffer(MESA_FORMAT_S8,
                                 NULL,
                                 screen->cpp,
                                 screen->depthOffset, screen->depthPitch,
                                 driDrawPriv);
         mgaSetSpanFunctions(stencilRb, mesaVis);
         _mesa_add_renderbuffer(fb, BUFFER_STENCIL, &stencilRb->Base);
      }

      _mesa_add_soft_renderbuffers(fb,
                                   GL_FALSE, /* color */
                                   GL_FALSE, /* depth */
                                   swStencil,
                                   mesaVis->accumRedBits > 0,
                                   GL_FALSE, /* alpha */
                                   GL_FALSE /* aux */);
      driDrawPriv->driverPrivate = (void *) fb;
#endif

      return (driDrawPriv->driverPrivate != NULL);
   }
}


static void
mgaDestroyBuffer(__DRIdrawable *driDrawPriv)
{
   _mesa_reference_framebuffer((struct gl_framebuffer **)(&(driDrawPriv->driverPrivate)), NULL);
}

static void
mgaSwapBuffers(__DRIdrawable *dPriv)
{
   if (dPriv->driContextPriv && dPriv->driContextPriv->driverPrivate) {
      mgaContextPtr mmesa;
      struct gl_context *ctx;
      mmesa = (mgaContextPtr) dPriv->driContextPriv->driverPrivate;
      ctx = mmesa->glCtx;

      if (ctx->Visual.doubleBufferMode) {
         _mesa_notifySwapBuffers( ctx );
         mgaCopyBuffer( dPriv );
      }
   } else {
      /* XXX this shouldn't be an error but we can't handle it for now */
      _mesa_problem(NULL, "%s: drawable has no context!\n", __FUNCTION__);
   }
}

static GLboolean
mgaUnbindContext(__DRIcontext *driContextPriv)
{
   mgaContextPtr mmesa = (mgaContextPtr) driContextPriv->driverPrivate;
   if (mmesa)
      mmesa->dirty = ~0;

   return GL_TRUE;
}

/* This looks buggy to me - the 'b' variable isn't used anywhere...
 * Hmm - It seems that the drawable is already hooked in to
 * driDrawablePriv.
 *
 * But why are we doing context initialization here???
 */
static GLboolean
mgaMakeCurrent(__DRIcontext *driContextPriv,
               __DRIdrawable *driDrawPriv,
               __DRIdrawable *driReadPriv)
{
   if (driContextPriv) {
      mgaContextPtr mmesa = (mgaContextPtr) driContextPriv->driverPrivate;

      if (mmesa->driDrawable != driDrawPriv) {
	 if (driDrawPriv->swap_interval == (unsigned)-1) {
	    driDrawPriv->vblFlags = (mmesa->mgaScreen->irq == 0)
	       ? VBLANK_FLAG_NO_IRQ
	       : driGetDefaultVBlankFlags(&mmesa->optionCache);

	    driDrawableInitVBlank( driDrawPriv );
	 }

	 mmesa->driDrawable = driDrawPriv;
	 mmesa->dirty = ~0; 
	 mmesa->dirty_cliprects = (MGA_FRONT|MGA_BACK); 
      }

      mmesa->driReadable = driReadPriv;

      _mesa_make_current(mmesa->glCtx,
                         (struct gl_framebuffer *) driDrawPriv->driverPrivate,
                         (struct gl_framebuffer *) driReadPriv->driverPrivate);
   }
   else {
      _mesa_make_current(NULL, NULL, NULL);
   }

   return GL_TRUE;
}


void mgaGetLock( mgaContextPtr mmesa, GLuint flags )
{
   __DRIdrawable *dPriv = mmesa->driDrawable;
   drm_mga_sarea_t *sarea = mmesa->sarea;
   int me = mmesa->hHWContext;
   int i;

   drmGetLock(mmesa->driFd, mmesa->hHWContext, flags);

   DRI_VALIDATE_DRAWABLE_INFO( mmesa->driScreen, dPriv );
   if (*(dPriv->pStamp) != mmesa->lastStamp) {
      mmesa->lastStamp = *(dPriv->pStamp);
      mmesa->SetupNewInputs |= VERT_BIT_POS;
      mmesa->dirty_cliprects = (MGA_FRONT|MGA_BACK);
      mgaUpdateRects( mmesa, (MGA_FRONT|MGA_BACK) );
      driUpdateFramebufferSize(mmesa->glCtx, dPriv);
   }

   mmesa->dirty |= MGA_UPLOAD_CONTEXT | MGA_UPLOAD_CLIPRECTS;

   mmesa->sarea->dirty |= MGA_UPLOAD_CONTEXT;

   if (sarea->ctxOwner != me) {
      mmesa->dirty |= (MGA_UPLOAD_CONTEXT | MGA_UPLOAD_TEX0 |
		       MGA_UPLOAD_TEX1 | MGA_UPLOAD_PIPE);
      sarea->ctxOwner=me;
   }

   for ( i = 0 ; i < mmesa->nr_heaps ; i++ ) {
      DRI_AGE_TEXTURES( mmesa->texture_heaps[ i ] );
   }
}


/**
 * This is the driver specific part of the createNewScreen entry point.
 * 
 * \todo maybe fold this into intelInitDriver
 *
 * \return the struct gl_config supported by this driver
 */
static const __DRIconfig **mgaInitScreen(__DRIscreen *psp)
{
   static const __DRIversion ddx_expected = { 1, 2, 0 };
   static const __DRIversion dri_expected = { 4, 0, 0 };
   static const __DRIversion drm_expected = { 3, 0, 0 };
   MGADRIPtr dri_priv = (MGADRIPtr) psp->pDevPriv;

   if ( ! driCheckDriDdxDrmVersions2( "MGA",
				      &psp->dri_version, & dri_expected,
				      &psp->ddx_version, & ddx_expected,
				      &psp->drm_version, & drm_expected ) )
      return NULL;


   if (!mgaInitDriver(psp))
       return NULL;

   return mgaFillInModes( psp,
			  dri_priv->cpp * 8,
			  (dri_priv->cpp == 2) ? 16 : 24,
			  (dri_priv->cpp == 2) ? 0  : 8,
			  (dri_priv->backOffset != dri_priv->depthOffset) );
}


/**
 * Get information about previous buffer swaps.
 */
static int
getSwapInfo( __DRIdrawable *dPriv, __DRIswapInfo * sInfo )
{
   mgaContextPtr  mmesa;

   if ( (dPriv == NULL) || (dPriv->driContextPriv == NULL)
	|| (dPriv->driContextPriv->driverPrivate == NULL)
	|| (sInfo == NULL) ) {
      return -1;
   }

   mmesa = (mgaContextPtr) dPriv->driContextPriv->driverPrivate;
   sInfo->swap_count = mmesa->swap_count;
   sInfo->swap_ust = mmesa->swap_ust;
   sInfo->swap_missed_count = mmesa->swap_missed_count;

   sInfo->swap_missed_usage = (sInfo->swap_missed_count != 0)
       ? driCalculateSwapUsage( dPriv, 0, mmesa->swap_missed_ust )
       : 0.0;

   return 0;
}

const struct __DriverAPIRec driDriverAPI = {
   .InitScreen      = mgaInitScreen,
   .DestroyScreen   = mgaDestroyScreen,
   .CreateContext   = mgaCreateContext,
   .DestroyContext  = mgaDestroyContext,
   .CreateBuffer    = mgaCreateBuffer,
   .DestroyBuffer   = mgaDestroyBuffer,
   .SwapBuffers     = mgaSwapBuffers,
   .MakeCurrent     = mgaMakeCurrent,
   .UnbindContext   = mgaUnbindContext,
   .GetSwapInfo     = getSwapInfo,
   .GetDrawableMSC  = driDrawableGetMSC32,
   .WaitForMSC      = driWaitForMSC32,
   .WaitForSBC      = NULL,
   .SwapBuffersMSC  = NULL
};

/* This is the table of extensions that the loader will dlsym() for. */
PUBLIC const __DRIextension *__driDriverExtensions[] = {
    &driCoreExtension.base,
    &driLegacyExtension.base,
    NULL
};
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.5
log
@Merge Mesa 7.10.3
@
text
@d69 1
d386 1
d462 1
a462 1
   mmesa->glCtx = _mesa_create_context(mesaVis, shareCtx,
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a59 1
#include "mga_xmesa.h"
d113 1
a113 1
    __GLcontextModes * m;
a183 1
    &driFrameTrackingExtension.base,
a395 1
   { "GL_SGIS_generate_mipmap",       NULL },
d423 2
a424 1
mgaCreateContext( const __GLcontextModes *mesaVis,
d430 1
a430 1
   GLcontext *ctx, *shareCtx;
d698 1
a698 1
                 const __GLcontextModes *mesaVis,
d815 1
a815 1
   _mesa_reference_framebuffer((GLframebuffer **)(&(driDrawPriv->driverPrivate)), NULL);
d823 1
a823 1
      GLcontext *ctx;
d878 2
a879 2
                         (GLframebuffer *) driDrawPriv->driverPrivate,
                         (GLframebuffer *) driReadPriv->driverPrivate);
d928 1
a928 1
 * \return the __GLcontextModes supported by this driver
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a37 1
#include "main/matrix.h"
a65 1
#include "main/extensions.h"
a69 3
#define need_GL_ARB_multisample
#define need_GL_ARB_texture_compression
#define need_GL_ARB_vertex_buffer_object
a72 1
#define need_GL_EXT_multi_draw_arrays
d79 1
a79 1
#include "extension_helper.h"
d109 1
a109 1
mgaFillInModes( __DRIscreenPrivate *psp,
d130 1
d145 2
d162 2
a163 1
			       back_buffer_modes, back_buffer_factor);
d191 1
a191 1
mgaInitDriver(__DRIscreenPrivate *sPriv)
d333 1
a333 1
mgaDestroyScreen(__DRIscreenPrivate *sPriv)
a385 2
   { "GL_ARB_multisample",            GL_ARB_multisample_functions },
   { "GL_ARB_texture_compression",    GL_ARB_texture_compression_functions },
a386 1
   { "GL_ARB_vertex_buffer_object",   GL_ARB_vertex_buffer_object_functions },
a388 1
   { "GL_EXT_multi_draw_arrays",      GL_EXT_multi_draw_arrays_functions },
d427 1
a427 1
                  __DRIcontextPrivate *driContextPriv,
d434 1
a434 1
   __DRIscreenPrivate *sPriv = driContextPriv->driScreenPriv;
d536 2
d646 1
a646 1
mgaDestroyContext(__DRIcontextPrivate *driContextPriv)
d698 2
a699 2
mgaCreateBuffer( __DRIscreenPrivate *driScrnPriv,
                 __DRIdrawablePrivate *driDrawPriv,
d724 1
a724 1
            = driNewRenderbuffer(GL_RGBA,
d735 1
a735 1
            = driNewRenderbuffer(GL_RGBA,
d746 1
a746 1
            = driNewRenderbuffer(GL_DEPTH_COMPONENT16,
d758 1
a758 1
               = driNewRenderbuffer(GL_DEPTH_COMPONENT24,
d768 1
a768 1
               = driNewRenderbuffer(GL_DEPTH_COMPONENT32,
d779 1
a779 1
            = driNewRenderbuffer(GL_DEPTH_COMPONENT32,
d790 1
a790 1
            = driNewRenderbuffer(GL_STENCIL_INDEX8_EXT,
d815 1
a815 1
mgaDestroyBuffer(__DRIdrawablePrivate *driDrawPriv)
d817 1
a817 1
   _mesa_unreference_framebuffer((GLframebuffer **)(&(driDrawPriv->driverPrivate)));
d821 1
a821 1
mgaSwapBuffers(__DRIdrawablePrivate *dPriv)
d840 1
a840 1
mgaUnbindContext(__DRIcontextPrivate *driContextPriv)
d856 3
a858 3
mgaMakeCurrent(__DRIcontextPrivate *driContextPriv,
               __DRIdrawablePrivate *driDrawPriv,
               __DRIdrawablePrivate *driReadPriv)
d893 1
a893 1
   __DRIdrawablePrivate *dPriv = mmesa->driDrawable;
a945 16
   /* Calling driInitExtensions here, with a NULL context pointer,
    * does not actually enable the extensions.  It just makes sure
    * that all the dispatch offsets for all the extensions that
    * *might* be enables are known.  This is needed because the
    * dispatch offsets need to be known when _mesa_context_create is
    * called, but we can't enable the extensions until we have a
    * context pointer.
    *
    * Hello chicken.  Hello egg.  How are you two today?
    */

   driInitExtensions( NULL, card_extensions, GL_FALSE );
   driInitExtensions( NULL, g400_extensions, GL_FALSE );
   driInitExtensions(NULL, ARB_vp_extensions, GL_FALSE);
   driInitExtensions( NULL, NV_vp_extensions, GL_FALSE );

d961 1
a961 1
getSwapInfo( __DRIdrawablePrivate *dPriv, __DRIswapInfo * sInfo )
d998 7
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a0 1
/* $XFree86: xc/lib/GL/mesa/src/drv/mga/mga_xmesa.c,v 1.19 2003/03/26 20:43:49 tsi Exp $ */
d37 6
a42 6
#include "context.h"
#include "matrix.h"
#include "simple_list.h"
#include "imports.h"
#include "framebuffer.h"
#include "renderbuffer.h"
d67 1
a67 1
#include "extensions.h"
d134 2
a135 2
    u_int8_t depth_bits_array[3];
    u_int8_t stencil_bits_array[3];
@


1.1
log
@Initial revision
@
text
@d48 1
a48 1
#include "array_cache/acache.h"
d75 1
d78 1
d84 1
d115 3
a117 4
static int getSwapInfo( __DRIdrawablePrivate *dPriv, __DRIswapInfo * sInfo );

static __GLcontextModes *
mgaFillInModes( unsigned pixel_bits, unsigned depth_bits,
d120 1
a120 1
    __GLcontextModes * modes;
a121 1
    unsigned num_modes;
d126 1
a153 2
    num_modes = depth_buffer_factor * back_buffer_factor * 4;

d163 5
a167 6
    modes = (*dri_interface->createContextModes)( num_modes, sizeof( __GLcontextModes ) );
    m = modes;
    if ( ! driFillInModes( & m, fb_format, fb_type,
			   depth_bits_array, stencil_bits_array, depth_buffer_factor,
			   back_buffer_modes, back_buffer_factor,
			   GLX_TRUE_COLOR ) ) {
d173 8
a180 16
    if ( ! driFillInModes( & m, fb_format, fb_type,
			   depth_bits_array, stencil_bits_array, depth_buffer_factor,
			   back_buffer_modes, back_buffer_factor,
			   GLX_DIRECT_COLOR ) ) {
	fprintf( stderr, "[%s:%u] Error creating FBConfig!\n",
		 __func__, __LINE__ );
	return NULL;
    }

    /* Mark the visual as slow if there are "fake" stencil bits.
     */
    for ( m = modes ; m != NULL ; m = m->next ) {
	if ( (m->stencilBits != 0) && (m->stencilBits != stencil_bits) ) {
	    m->visualRating = GLX_SLOW_CONFIG;
	}
    }
d182 1
a182 1
    return modes;
d185 7
a197 3
   PFNGLXSCRENABLEEXTENSIONPROC glx_enable_extension =
       (PFNGLXSCRENABLEEXTENSIONPROC) (*dri_interface->getProcAddress("glxEnableExtension"));
   void * const psc = sPriv->psc->screenConfigs;
d214 1
a214 1
   if (sPriv->drmMinor >= 1) {
d232 1
a232 7
   if ( glx_enable_extension != NULL ) {
      (*glx_enable_extension)( psc, "GLX_MESA_swap_control" );
      (*glx_enable_extension)( psc, "GLX_MESA_swap_frame_usage" );
      (*glx_enable_extension)( psc, "GLX_SGI_make_current_read" );
      (*glx_enable_extension)( psc, "GLX_SGI_swap_control" );
      (*glx_enable_extension)( psc, "GLX_SGI_video_sync" );
   }
d265 1
a265 1
   if (mgaScreen->sPriv->drmMinor < 2) {
a362 1
   &_tnl_arb_vertex_program_stage,
d392 1
d403 1
d409 1
a409 1
static const struct dri_extension ARB_vp_extension[] = {
d411 1
d587 1
a587 1
   _ac_CreateContext( ctx );
d616 1
a616 1
      driInitSingleExtension( ctx, ARB_vp_extension );
d640 1
a640 4
   mmesa->vblank_flags = (mmesa->mgaScreen->irq == 0)
       ? VBLANK_FLAG_NO_IRQ : driGetDefaultVBlankFlags(&mmesa->optionCache);

   (*dri_interface->getUST)( & mmesa->swap_ust );
d667 1
a667 1
      _ac_DestroyContext( mmesa->glCtx );
d822 1
a822 1
   _mesa_destroy_framebuffer((GLframebuffer *) (driDrawPriv->driverPrivate));
d869 8
a876 1
	 driDrawableInitVBlank( driDrawPriv, mmesa->vblank_flags );
a879 1
	 mmesa->mesa_drawable = driDrawPriv;
d905 1
d916 1
a916 1
    mmesa->sarea->dirty |= MGA_UPLOAD_CONTEXT;
a929 18
static const struct __DriverAPIRec mgaAPI = {
   .InitDriver      = mgaInitDriver,
   .DestroyScreen   = mgaDestroyScreen,
   .CreateContext   = mgaCreateContext,
   .DestroyContext  = mgaDestroyContext,
   .CreateBuffer    = mgaCreateBuffer,
   .DestroyBuffer   = mgaDestroyBuffer,
   .SwapBuffers     = mgaSwapBuffers,
   .MakeCurrent     = mgaMakeCurrent,
   .UnbindContext   = mgaUnbindContext,
   .GetSwapInfo     = getSwapInfo,
   .GetMSC          = driGetMSC32,
   .WaitForMSC      = driWaitForMSC32,
   .WaitForSBC      = NULL,
   .SwapBuffersMSC  = NULL
};


d931 1
a931 5
 * This is the bootstrap function for the driver.  libGL supplies all of the
 * requisite information about the system, and the driver initializes itself.
 * This routine also fills in the linked list pointed to by \c driver_modes
 * with the \c __GLcontextModes that the driver can support for windows or
 * pbuffers.
d933 3
a935 2
 * \return A pointer to a \c __DRIscreenPrivate on success, or \c NULL on 
 *         failure.
d937 1
a937 12
PUBLIC
void * __driCreateNewScreen_20050727( __DRInativeDisplay *dpy, int scrn, __DRIscreen *psc,
			     const __GLcontextModes * modes,
			     const __DRIversion * ddx_version,
			     const __DRIversion * dri_version,
			     const __DRIversion * drm_version,
			     const __DRIframebuffer * frame_buffer,
			     drmAddress pSAREA, int fd, 
			     int internal_api_version,
			     const __DRIinterfaceMethods * interface,
			     __GLcontextModes ** driver_modes )
			     
a938 1
   __DRIscreenPrivate *psp;
d942 1
a942 2

   dri_interface = interface;
d945 3
a947 3
				      dri_version, & dri_expected,
				      ddx_version, & ddx_expected,
				      drm_version, & drm_expected ) ) {
a948 1
   }
a949 23
   psp = __driUtilCreateNewScreen(dpy, scrn, psc, NULL,
				  ddx_version, dri_version, drm_version,
				  frame_buffer, pSAREA, fd,
				  internal_api_version, &mgaAPI);
   if ( psp != NULL ) {
      MGADRIPtr dri_priv = (MGADRIPtr) psp->pDevPriv;
      *driver_modes = mgaFillInModes( dri_priv->cpp * 8,
				      (dri_priv->cpp == 2) ? 16 : 24,
				      (dri_priv->cpp == 2) ? 0  : 8,
				      (dri_priv->backOffset != dri_priv->depthOffset) );

      /* Calling driInitExtensions here, with a NULL context pointer, does not actually
       * enable the extensions.  It just makes sure that all the dispatch offsets for all
       * the extensions that *might* be enables are known.  This is needed because the
       * dispatch offsets need to be known when _mesa_context_create is called, but we can't
       * enable the extensions until we have a context pointer.
       *
       * Hello chicken.  Hello egg.  How are you two today?
       */
      driInitExtensions( NULL, card_extensions, GL_FALSE );
      driInitExtensions( NULL, g400_extensions, GL_FALSE );
      driInitSingleExtension( NULL, ARB_vp_extension );
      driInitExtensions( NULL, NV_vp_extensions, GL_FALSE );
d951 10
a960 1
   }
d962 13
a974 1
   return (void *) psp;
d1003 17
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d881 1
a881 2
	 driDrawableInitVBlank( driDrawPriv, mmesa->vblank_flags,
				&mmesa->vbl_seq );
d885 1
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d48 1
a48 1
#include "vbo/vbo.h"
a74 1
#define need_GL_ARB_vertex_buffer_object
d374 1
a403 1
   { "GL_ARB_vertex_buffer_object",   GL_ARB_vertex_buffer_object_functions },
d596 1
a596 1
   _vbo_CreateContext( ctx );
d679 1
a679 1
      _vbo_DestroyContext( mmesa->glCtx );
d834 1
a834 1
   _mesa_unreference_framebuffer((GLframebuffer **)(&(driDrawPriv->driverPrivate)));
a910 1
   DRI_VALIDATE_DRAWABLE_INFO( mmesa->driScreen, dPriv );
d921 1
a921 1
   mmesa->sarea->dirty |= MGA_UPLOAD_CONTEXT;
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d1 1
d38 6
a43 5
#include "main/context.h"
#include "main/simple_list.h"
#include "main/imports.h"
#include "main/framebuffer.h"
#include "main/renderbuffer.h"
d62 1
d68 1
d73 3
d78 1
a78 1
#define need_GL_EXT_gpu_program_parameters
a82 1
#define need_GL_APPLE_vertex_array_object
d84 1
a84 1
#include "main/remap_helper.h"
d113 4
a116 3
static const __DRIconfig **
mgaFillInModes( __DRIscreen *psp,
		unsigned pixel_bits, unsigned depth_bits,
d119 3
a121 2
    __DRIconfig **configs;
    struct gl_config * m;
a125 1
    int i;
d134 2
a135 3
    uint8_t depth_bits_array[3];
    uint8_t stencil_bits_array[3];
    uint8_t msaa_samples_array[1];
a149 2
    msaa_samples_array[0] = 0;

d153 2
d164 15
a178 6
    configs = driCreateConfigs(fb_format, fb_type,
			       depth_bits_array, stencil_bits_array,
			       depth_buffer_factor,
			       back_buffer_modes, back_buffer_factor,
                               msaa_samples_array, 1, GL_TRUE);
    if (configs == NULL) {
d184 7
a190 8
   /* Mark the visual as slow if there are "fake" stencil bits.
    */
   for (i = 0; configs[i]; i++) {
      m = &configs[i]->modes;
      if ((m->stencilBits != 0) && (m->stencilBits != stencil_bits)) {
         m->visualRating = GLX_SLOW_CONFIG;
      }
   }
d192 1
a192 1
   return (const __DRIconfig **) configs;
a194 6
const __DRIextension *mgaScreenExtensions[] = {
    &driReadDrawableExtension,
    &driSwapControlExtension.base,
    &driMediaStreamCounterExtension.base,
    NULL
};
d197 1
a197 1
mgaInitDriver(__DRIscreen *sPriv)
d201 3
d220 1
a220 1
   if (sPriv->drm_version.minor >= 1) {
d238 7
a244 1
   sPriv->extensions = mgaScreenExtensions;
d277 1
a277 1
   if (mgaScreen->sPriv->drm_version.minor < 2) {
d348 1
a348 1
mgaDestroyScreen(__DRIscreen *sPriv)
d401 2
d404 1
d407 1
a414 1
   { "GL_APPLE_vertex_array_object",  GL_APPLE_vertex_array_object_functions },
d416 1
d420 1
a420 1
static const struct dri_extension ARB_vp_extensions[] = {
a421 1
   { "GL_EXT_gpu_program_parameters", GL_EXT_gpu_program_parameters_functions },
d443 2
a444 3
mgaCreateContext( gl_api api,
		  const struct gl_config *mesaVis,
                  __DRIcontext *driContextPriv,
d449 1
a449 1
   struct gl_context *ctx, *shareCtx;
d451 1
a451 1
   __DRIscreen *sPriv = driContextPriv->driScreenPriv;
a552 2
   ctx->Const.MaxDrawBuffers = 1;

d626 1
a626 1
      driInitExtensions(ctx, ARB_vp_extensions, GL_FALSE);
d650 4
a653 1
   (*sPriv->systemTime->getUST)( & mmesa->swap_ust );
d664 1
a664 1
mgaDestroyContext(__DRIcontext *driContextPriv)
d716 3
a718 3
mgaCreateBuffer( __DRIscreen *driScrnPriv,
                 __DRIdrawable *driDrawPriv,
                 const struct gl_config *mesaVis,
d742 1
a742 1
            = driNewRenderbuffer(MESA_FORMAT_ARGB8888,
d753 1
a753 1
            = driNewRenderbuffer(MESA_FORMAT_ARGB8888,
d764 1
a764 1
            = driNewRenderbuffer(MESA_FORMAT_Z16,
d776 1
a776 1
               = driNewRenderbuffer(MESA_FORMAT_Z24_S8,
d786 1
a786 1
               = driNewRenderbuffer(MESA_FORMAT_Z32,
d797 1
a797 1
            = driNewRenderbuffer(MESA_FORMAT_Z32,
d808 1
a808 1
            = driNewRenderbuffer(MESA_FORMAT_S8,
d833 1
a833 1
mgaDestroyBuffer(__DRIdrawable *driDrawPriv)
d835 1
a835 1
   _mesa_reference_framebuffer((struct gl_framebuffer **)(&(driDrawPriv->driverPrivate)), NULL);
d839 1
a839 1
mgaSwapBuffers(__DRIdrawable *dPriv)
d843 1
a843 1
      struct gl_context *ctx;
d858 1
a858 1
mgaUnbindContext(__DRIcontext *driContextPriv)
d874 3
a876 3
mgaMakeCurrent(__DRIcontext *driContextPriv,
               __DRIdrawable *driDrawPriv,
               __DRIdrawable *driReadPriv)
d882 2
a883 8
	 if (driDrawPriv->swap_interval == (unsigned)-1) {
	    driDrawPriv->vblFlags = (mmesa->mgaScreen->irq == 0)
	       ? VBLANK_FLAG_NO_IRQ
	       : driGetDefaultVBlankFlags(&mmesa->optionCache);

	    driDrawableInitVBlank( driDrawPriv );
	 }

d892 2
a893 2
                         (struct gl_framebuffer *) driDrawPriv->driverPrivate,
                         (struct gl_framebuffer *) driReadPriv->driverPrivate);
d905 1
a905 1
   __DRIdrawable *dPriv = mmesa->driDrawable;
d937 18
d956 5
a960 1
 * This is the driver specific part of the createNewScreen entry point.
d962 2
a963 3
 * \todo maybe fold this into intelInitDriver
 *
 * \return the struct gl_config supported by this driver
d965 12
a976 1
static const __DRIconfig **mgaInitScreen(__DRIscreen *psp)
d978 1
d982 2
a983 1
   MGADRIPtr dri_priv = (MGADRIPtr) psp->pDevPriv;
d986 3
a988 3
				      &psp->dri_version, & dri_expected,
				      &psp->ddx_version, & ddx_expected,
				      &psp->drm_version, & drm_expected ) )
d990 1
d992 23
d1016 1
a1016 2
   if (!mgaInitDriver(psp))
       return NULL;
d1018 1
a1018 5
   return mgaFillInModes( psp,
			  dri_priv->cpp * 8,
			  (dri_priv->cpp == 2) ? 16 : 24,
			  (dri_priv->cpp == 2) ? 0  : 8,
			  (dri_priv->backOffset != dri_priv->depthOffset) );
d1026 1
a1026 1
getSwapInfo( __DRIdrawable *dPriv, __DRIswapInfo * sInfo )
a1046 24

const struct __DriverAPIRec driDriverAPI = {
   .InitScreen      = mgaInitScreen,
   .DestroyScreen   = mgaDestroyScreen,
   .CreateContext   = mgaCreateContext,
   .DestroyContext  = mgaDestroyContext,
   .CreateBuffer    = mgaCreateBuffer,
   .DestroyBuffer   = mgaDestroyBuffer,
   .SwapBuffers     = mgaSwapBuffers,
   .MakeCurrent     = mgaMakeCurrent,
   .UnbindContext   = mgaUnbindContext,
   .GetSwapInfo     = getSwapInfo,
   .GetDrawableMSC  = driDrawableGetMSC32,
   .WaitForMSC      = driWaitForMSC32,
   .WaitForSBC      = NULL,
   .SwapBuffersMSC  = NULL
};

/* This is the table of extensions that the loader will dlsym() for. */
PUBLIC const __DRIextension *__driDriverExtensions[] = {
    &driCoreExtension.base,
    &driLegacyExtension.base,
    NULL
};
@


