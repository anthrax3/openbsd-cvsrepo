head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.5.0.4
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.2
	OPENBSD_5_6_BASE:1.1.1.3
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.1.1.2.0.2
	OPENBSD_5_5_BASE:1.1.1.2
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;
expand	@o@;


1.2
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.15.39;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.15.39;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.10.05.09.25.23;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.51;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.11.46;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.48.51;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2011 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#include "brw_vec4.h"
#include "brw_cfg.h"

extern "C" {
#include "main/macros.h"
#include "main/shaderobj.h"
#include "program/prog_print.h"
#include "program/prog_parameter.h"
}

#define MAX_INSTRUCTION (1 << 30)

using namespace brw;

namespace brw {

/**
 * Common helper for constructing swizzles.  When only a subset of
 * channels of a vec4 are used, we don't want to reference the other
 * channels, as that will tell optimization passes that those other
 * channels are used.
 */
unsigned
swizzle_for_size(int size)
{
   static const unsigned size_swizzles[4] = {
      BRW_SWIZZLE4(SWIZZLE_X, SWIZZLE_X, SWIZZLE_X, SWIZZLE_X),
      BRW_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Y, SWIZZLE_Y),
      BRW_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_Z),
      BRW_SWIZZLE4(SWIZZLE_X, SWIZZLE_Y, SWIZZLE_Z, SWIZZLE_W),
   };

   assert((size >= 1) && (size <= 4));
   return size_swizzles[size - 1];
}

void
src_reg::init()
{
   memset(this, 0, sizeof(*this));

   this->file = BAD_FILE;
}

src_reg::src_reg(register_file file, int reg, const glsl_type *type)
{
   init();

   this->file = file;
   this->reg = reg;
   if (type && (type->is_scalar() || type->is_vector() || type->is_matrix()))
      this->swizzle = swizzle_for_size(type->vector_elements);
   else
      this->swizzle = SWIZZLE_XYZW;
}

/** Generic unset register constructor. */
src_reg::src_reg()
{
   init();
}

src_reg::src_reg(float f)
{
   init();

   this->file = IMM;
   this->type = BRW_REGISTER_TYPE_F;
   this->imm.f = f;
}

src_reg::src_reg(uint32_t u)
{
   init();

   this->file = IMM;
   this->type = BRW_REGISTER_TYPE_UD;
   this->imm.u = u;
}

src_reg::src_reg(int32_t i)
{
   init();

   this->file = IMM;
   this->type = BRW_REGISTER_TYPE_D;
   this->imm.i = i;
}

src_reg::src_reg(dst_reg reg)
{
   init();

   this->file = reg.file;
   this->reg = reg.reg;
   this->reg_offset = reg.reg_offset;
   this->type = reg.type;
   this->reladdr = reg.reladdr;
   this->fixed_hw_reg = reg.fixed_hw_reg;

   int swizzles[4];
   int next_chan = 0;
   int last = 0;

   for (int i = 0; i < 4; i++) {
      if (!(reg.writemask & (1 << i)))
         continue;

      swizzles[next_chan++] = last = i;
   }

   for (; next_chan < 4; next_chan++) {
      swizzles[next_chan] = last;
   }

   this->swizzle = BRW_SWIZZLE4(swizzles[0], swizzles[1],
                                swizzles[2], swizzles[3]);
}

void
dst_reg::init()
{
   memset(this, 0, sizeof(*this));
   this->file = BAD_FILE;
   this->writemask = WRITEMASK_XYZW;
}

dst_reg::dst_reg()
{
   init();
}

dst_reg::dst_reg(register_file file, int reg)
{
   init();

   this->file = file;
   this->reg = reg;
}

dst_reg::dst_reg(register_file file, int reg, const glsl_type *type,
                 int writemask)
{
   init();

   this->file = file;
   this->reg = reg;
   this->type = brw_type_for_base_type(type);
   this->writemask = writemask;
}

dst_reg::dst_reg(struct brw_reg reg)
{
   init();

   this->file = HW_REG;
   this->fixed_hw_reg = reg;
}

dst_reg::dst_reg(src_reg reg)
{
   init();

   this->file = reg.file;
   this->reg = reg.reg;
   this->reg_offset = reg.reg_offset;
   this->type = reg.type;
   /* How should we do writemasking when converting from a src_reg?  It seems
    * pretty obvious that for src.xxxx the caller wants to write to src.x, but
    * what about for src.wx?  Just special-case src.xxxx for now.
    */
   if (reg.swizzle == BRW_SWIZZLE_XXXX)
      this->writemask = WRITEMASK_X;
   else
      this->writemask = WRITEMASK_XYZW;
   this->reladdr = reg.reladdr;
   this->fixed_hw_reg = reg.fixed_hw_reg;
}

bool
vec4_instruction::is_send_from_grf()
{
   switch (opcode) {
   case SHADER_OPCODE_SHADER_TIME_ADD:
   case VS_OPCODE_PULL_CONSTANT_LOAD_GEN7:
      return true;
   default:
      return false;
   }
}

bool
vec4_visitor::can_do_source_mods(vec4_instruction *inst)
{
   if (brw->gen == 6 && inst->is_math())
      return false;

   if (inst->is_send_from_grf())
      return false;

   return true;
}

/**
 * Returns how many MRFs an opcode will write over.
 *
 * Note that this is not the 0 or 1 implied writes in an actual gen
 * instruction -- the generate_* functions generate additional MOVs
 * for setup.
 */
int
vec4_visitor::implied_mrf_writes(vec4_instruction *inst)
{
   if (inst->mlen == 0)
      return 0;

   switch (inst->opcode) {
   case SHADER_OPCODE_RCP:
   case SHADER_OPCODE_RSQ:
   case SHADER_OPCODE_SQRT:
   case SHADER_OPCODE_EXP2:
   case SHADER_OPCODE_LOG2:
   case SHADER_OPCODE_SIN:
   case SHADER_OPCODE_COS:
      return 1;
   case SHADER_OPCODE_INT_QUOTIENT:
   case SHADER_OPCODE_INT_REMAINDER:
   case SHADER_OPCODE_POW:
      return 2;
   case VS_OPCODE_URB_WRITE:
      return 1;
   case VS_OPCODE_PULL_CONSTANT_LOAD:
      return 2;
   case VS_OPCODE_SCRATCH_READ:
      return 2;
   case VS_OPCODE_SCRATCH_WRITE:
      return 3;
   case SHADER_OPCODE_SHADER_TIME_ADD:
      return 0;
   case SHADER_OPCODE_TEX:
   case SHADER_OPCODE_TXL:
   case SHADER_OPCODE_TXD:
   case SHADER_OPCODE_TXF:
   case SHADER_OPCODE_TXF_MS:
   case SHADER_OPCODE_TXS:
      return inst->header_present ? 1 : 0;
   default:
      assert(!"not reached");
      return inst->mlen;
   }
}

bool
src_reg::equals(src_reg *r)
{
   return (file == r->file &&
	   reg == r->reg &&
	   reg_offset == r->reg_offset &&
	   type == r->type &&
	   negate == r->negate &&
	   abs == r->abs &&
	   swizzle == r->swizzle &&
	   !reladdr && !r->reladdr &&
	   memcmp(&fixed_hw_reg, &r->fixed_hw_reg,
		  sizeof(fixed_hw_reg)) == 0 &&
	   imm.u == r->imm.u);
}

/**
 * Must be called after calculate_live_intervales() to remove unused
 * writes to registers -- register allocation will fail otherwise
 * because something deffed but not used won't be considered to
 * interfere with other regs.
 */
bool
vec4_visitor::dead_code_eliminate()
{
   bool progress = false;
   int pc = 0;

   calculate_live_intervals();

   foreach_list_safe(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

      if (inst->dst.file == GRF) {
         assert(this->virtual_grf_end[inst->dst.reg] >= pc);
         if (this->virtual_grf_end[inst->dst.reg] == pc) {
            inst->remove();
            progress = true;
         }
      }

      pc++;
   }

   if (progress)
      live_intervals_valid = false;

   return progress;
}

void
vec4_visitor::split_uniform_registers()
{
   /* Prior to this, uniforms have been in an array sized according to
    * the number of vector uniforms present, sparsely filled (so an
    * aggregate results in reg indices being skipped over).  Now we're
    * going to cut those aggregates up so each .reg index is one
    * vector.  The goal is to make elimination of unused uniform
    * components easier later.
    */
   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

      for (int i = 0 ; i < 3; i++) {
	 if (inst->src[i].file != UNIFORM)
	    continue;

	 assert(!inst->src[i].reladdr);

	 inst->src[i].reg += inst->src[i].reg_offset;
	 inst->src[i].reg_offset = 0;
      }
   }

   /* Update that everything is now vector-sized. */
   for (int i = 0; i < this->uniforms; i++) {
      this->uniform_size[i] = 1;
   }
}

void
vec4_visitor::pack_uniform_registers()
{
   bool uniform_used[this->uniforms];
   int new_loc[this->uniforms];
   int new_chan[this->uniforms];

   memset(uniform_used, 0, sizeof(uniform_used));
   memset(new_loc, 0, sizeof(new_loc));
   memset(new_chan, 0, sizeof(new_chan));

   /* Find which uniform vectors are actually used by the program.  We
    * expect unused vector elements when we've moved array access out
    * to pull constants, and from some GLSL code generators like wine.
    */
   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

      for (int i = 0 ; i < 3; i++) {
	 if (inst->src[i].file != UNIFORM)
	    continue;

	 uniform_used[inst->src[i].reg] = true;
      }
   }

   int new_uniform_count = 0;

   /* Now, figure out a packing of the live uniform vectors into our
    * push constants.
    */
   for (int src = 0; src < uniforms; src++) {
      int size = this->uniform_vector_size[src];

      if (!uniform_used[src]) {
	 this->uniform_vector_size[src] = 0;
	 continue;
      }

      int dst;
      /* Find the lowest place we can slot this uniform in. */
      for (dst = 0; dst < src; dst++) {
	 if (this->uniform_vector_size[dst] + size <= 4)
	    break;
      }

      if (src == dst) {
	 new_loc[src] = dst;
	 new_chan[src] = 0;
      } else {
	 new_loc[src] = dst;
	 new_chan[src] = this->uniform_vector_size[dst];

	 /* Move the references to the data */
	 for (int j = 0; j < size; j++) {
	    prog_data->param[dst * 4 + new_chan[src] + j] =
	       prog_data->param[src * 4 + j];
	 }

	 this->uniform_vector_size[dst] += size;
	 this->uniform_vector_size[src] = 0;
      }

      new_uniform_count = MAX2(new_uniform_count, dst + 1);
   }

   this->uniforms = new_uniform_count;

   /* Now, update the instructions for our repacked uniforms. */
   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

      for (int i = 0 ; i < 3; i++) {
	 int src = inst->src[i].reg;

	 if (inst->src[i].file != UNIFORM)
	    continue;

	 inst->src[i].reg = new_loc[src];

	 int sx = BRW_GET_SWZ(inst->src[i].swizzle, 0) + new_chan[src];
	 int sy = BRW_GET_SWZ(inst->src[i].swizzle, 1) + new_chan[src];
	 int sz = BRW_GET_SWZ(inst->src[i].swizzle, 2) + new_chan[src];
	 int sw = BRW_GET_SWZ(inst->src[i].swizzle, 3) + new_chan[src];
	 inst->src[i].swizzle = BRW_SWIZZLE4(sx, sy, sz, sw);
      }
   }
}

bool
src_reg::is_zero() const
{
   if (file != IMM)
      return false;

   if (type == BRW_REGISTER_TYPE_F) {
      return imm.f == 0.0;
   } else {
      return imm.i == 0;
   }
}

bool
src_reg::is_one() const
{
   if (file != IMM)
      return false;

   if (type == BRW_REGISTER_TYPE_F) {
      return imm.f == 1.0;
   } else {
      return imm.i == 1;
   }
}

/**
 * Does algebraic optimizations (0 * a = 0, 1 * a = a, a + 0 = a).
 *
 * While GLSL IR also performs this optimization, we end up with it in
 * our instruction stream for a couple of reasons.  One is that we
 * sometimes generate silly instructions, for example in array access
 * where we'll generate "ADD offset, index, base" even if base is 0.
 * The other is that GLSL IR's constant propagation doesn't track the
 * components of aggregates, so some VS patterns (initialize matrix to
 * 0, accumulate in vertex blending factors) end up breaking down to
 * instructions involving 0.
 */
bool
vec4_visitor::opt_algebraic()
{
   bool progress = false;

   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

      switch (inst->opcode) {
      case BRW_OPCODE_ADD:
	 if (inst->src[1].is_zero()) {
	    inst->opcode = BRW_OPCODE_MOV;
	    inst->src[1] = src_reg();
	    progress = true;
	 }
	 break;

      case BRW_OPCODE_MUL:
	 if (inst->src[1].is_zero()) {
	    inst->opcode = BRW_OPCODE_MOV;
	    switch (inst->src[0].type) {
	    case BRW_REGISTER_TYPE_F:
	       inst->src[0] = src_reg(0.0f);
	       break;
	    case BRW_REGISTER_TYPE_D:
	       inst->src[0] = src_reg(0);
	       break;
	    case BRW_REGISTER_TYPE_UD:
	       inst->src[0] = src_reg(0u);
	       break;
	    default:
	       assert(!"not reached");
	       inst->src[0] = src_reg(0.0f);
	       break;
	    }
	    inst->src[1] = src_reg();
	    progress = true;
	 } else if (inst->src[1].is_one()) {
	    inst->opcode = BRW_OPCODE_MOV;
	    inst->src[1] = src_reg();
	    progress = true;
	 }
	 break;
      default:
	 break;
      }
   }

   if (progress)
      this->live_intervals_valid = false;

   return progress;
}

/**
 * Only a limited number of hardware registers may be used for push
 * constants, so this turns access to the overflowed constants into
 * pull constants.
 */
void
vec4_visitor::move_push_constants_to_pull_constants()
{
   int pull_constant_loc[this->uniforms];

   /* Only allow 32 registers (256 uniform components) as push constants,
    * which is the limit on gen6.
    */
   int max_uniform_components = 32 * 8;
   if (this->uniforms * 4 <= max_uniform_components)
      return;

   /* Make some sort of choice as to which uniforms get sent to pull
    * constants.  We could potentially do something clever here like
    * look for the most infrequently used uniform vec4s, but leave
    * that for later.
    */
   for (int i = 0; i < this->uniforms * 4; i += 4) {
      pull_constant_loc[i / 4] = -1;

      if (i >= max_uniform_components) {
	 const float **values = &prog_data->param[i];

	 /* Try to find an existing copy of this uniform in the pull
	  * constants if it was part of an array access already.
	  */
	 for (unsigned int j = 0; j < prog_data->nr_pull_params; j += 4) {
	    int matches;

	    for (matches = 0; matches < 4; matches++) {
	       if (prog_data->pull_param[j + matches] != values[matches])
		  break;
	    }

	    if (matches == 4) {
	       pull_constant_loc[i / 4] = j / 4;
	       break;
	    }
	 }

	 if (pull_constant_loc[i / 4] == -1) {
	    assert(prog_data->nr_pull_params % 4 == 0);
	    pull_constant_loc[i / 4] = prog_data->nr_pull_params / 4;

	    for (int j = 0; j < 4; j++) {
	       prog_data->pull_param[prog_data->nr_pull_params++] = values[j];
	    }
	 }
      }
   }

   /* Now actually rewrite usage of the things we've moved to pull
    * constants.
    */
   foreach_list_safe(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

      for (int i = 0 ; i < 3; i++) {
	 if (inst->src[i].file != UNIFORM ||
	     pull_constant_loc[inst->src[i].reg] == -1)
	    continue;

	 int uniform = inst->src[i].reg;

	 dst_reg temp = dst_reg(this, glsl_type::vec4_type);

	 emit_pull_constant_load(inst, temp, inst->src[i],
				 pull_constant_loc[uniform]);

	 inst->src[i].file = temp.file;
	 inst->src[i].reg = temp.reg;
	 inst->src[i].reg_offset = temp.reg_offset;
	 inst->src[i].reladdr = NULL;
      }
   }

   /* Repack push constants to remove the now-unused ones. */
   pack_uniform_registers();
}

/**
 * Sets the dependency control fields on instructions after register
 * allocation and before the generator is run.
 *
 * When you have a sequence of instructions like:
 *
 * DP4 temp.x vertex uniform[0]
 * DP4 temp.y vertex uniform[0]
 * DP4 temp.z vertex uniform[0]
 * DP4 temp.w vertex uniform[0]
 *
 * The hardware doesn't know that it can actually run the later instructions
 * while the previous ones are in flight, producing stalls.  However, we have
 * manual fields we can set in the instructions that let it do so.
 */
void
vec4_visitor::opt_set_dependency_control()
{
   vec4_instruction *last_grf_write[BRW_MAX_GRF];
   uint8_t grf_channels_written[BRW_MAX_GRF];
   vec4_instruction *last_mrf_write[BRW_MAX_GRF];
   uint8_t mrf_channels_written[BRW_MAX_GRF];

   cfg_t cfg(this);

   assert(prog_data->total_grf ||
          !"Must be called after register allocation");

   for (int i = 0; i < cfg.num_blocks; i++) {
      bblock_t *bblock = cfg.blocks[i];
      vec4_instruction *inst;

      memset(last_grf_write, 0, sizeof(last_grf_write));
      memset(last_mrf_write, 0, sizeof(last_mrf_write));

      for (inst = (vec4_instruction *)bblock->start;
           inst != (vec4_instruction *)bblock->end->next;
           inst = (vec4_instruction *)inst->next) {
         /* If we read from a register that we were doing dependency control
          * on, don't do dependency control across the read.
          */
         for (int i = 0; i < 3; i++) {
            int reg = inst->src[i].reg + inst->src[i].reg_offset;
            if (inst->src[i].file == GRF) {
               last_grf_write[reg] = NULL;
            } else if (inst->src[i].file == HW_REG) {
               memset(last_grf_write, 0, sizeof(last_grf_write));
               break;
            }
            assert(inst->src[i].file != MRF);
         }

         /* In the presence of send messages, totally interrupt dependency
          * control.  They're long enough that the chance of dependency
          * control around them just doesn't matter.
          */
         if (inst->mlen) {
            memset(last_grf_write, 0, sizeof(last_grf_write));
            memset(last_mrf_write, 0, sizeof(last_mrf_write));
            continue;
         }

         /* It looks like setting dependency control on a predicated
          * instruction hangs the GPU.
          */
         if (inst->predicate) {
            memset(last_grf_write, 0, sizeof(last_grf_write));
            memset(last_mrf_write, 0, sizeof(last_mrf_write));
            continue;
         }

         /* Now, see if we can do dependency control for this instruction
          * against a previous one writing to its destination.
          */
         int reg = inst->dst.reg + inst->dst.reg_offset;
         if (inst->dst.file == GRF) {
            if (last_grf_write[reg] &&
                !(inst->dst.writemask & grf_channels_written[reg])) {
               last_grf_write[reg]->no_dd_clear = true;
               inst->no_dd_check = true;
            } else {
               grf_channels_written[reg] = 0;
            }

            last_grf_write[reg] = inst;
            grf_channels_written[reg] |= inst->dst.writemask;
         } else if (inst->dst.file == MRF) {
            if (last_mrf_write[reg] &&
                !(inst->dst.writemask & mrf_channels_written[reg])) {
               last_mrf_write[reg]->no_dd_clear = true;
               inst->no_dd_check = true;
            } else {
               mrf_channels_written[reg] = 0;
            }

            last_mrf_write[reg] = inst;
            mrf_channels_written[reg] |= inst->dst.writemask;
         } else if (inst->dst.reg == HW_REG) {
            if (inst->dst.fixed_hw_reg.file == BRW_GENERAL_REGISTER_FILE)
               memset(last_grf_write, 0, sizeof(last_grf_write));
            if (inst->dst.fixed_hw_reg.file == BRW_MESSAGE_REGISTER_FILE)
               memset(last_mrf_write, 0, sizeof(last_mrf_write));
         }
      }
   }
}

bool
vec4_instruction::can_reswizzle_dst(int dst_writemask,
                                    int swizzle,
                                    int swizzle_mask)
{
   /* If this instruction sets anything not referenced by swizzle, then we'd
    * totally break it when we reswizzle.
    */
   if (dst.writemask & ~swizzle_mask)
      return false;

   switch (opcode) {
   case BRW_OPCODE_DP4:
   case BRW_OPCODE_DP3:
   case BRW_OPCODE_DP2:
      return true;
   default:
      /* Check if there happens to be no reswizzling required. */
      for (int c = 0; c < 4; c++) {
         int bit = 1 << BRW_GET_SWZ(swizzle, c);
         /* Skip components of the swizzle not used by the dst. */
         if (!(dst_writemask & (1 << c)))
            continue;

         /* We don't do the reswizzling yet, so just sanity check that we
          * don't have to.
          */
         if (bit != (1 << c))
            return false;
      }
      return true;
   }
}

/**
 * For any channels in the swizzle's source that were populated by this
 * instruction, rewrite the instruction to put the appropriate result directly
 * in those channels.
 *
 * e.g. for swizzle=yywx, MUL a.xy b c -> MUL a.yy_x b.yy z.yy_x
 */
void
vec4_instruction::reswizzle_dst(int dst_writemask, int swizzle)
{
   int new_writemask = 0;

   switch (opcode) {
   case BRW_OPCODE_DP4:
   case BRW_OPCODE_DP3:
   case BRW_OPCODE_DP2:
      for (int c = 0; c < 4; c++) {
         int bit = 1 << BRW_GET_SWZ(swizzle, c);
         /* Skip components of the swizzle not used by the dst. */
         if (!(dst_writemask & (1 << c)))
            continue;
         /* If we were populating this component, then populate the
          * corresponding channel of the new dst.
          */
         if (dst.writemask & bit)
            new_writemask |= (1 << c);
      }
      dst.writemask = new_writemask;
      break;
   default:
      for (int c = 0; c < 4; c++) {
         /* Skip components of the swizzle not used by the dst. */
         if (!(dst_writemask & (1 << c)))
            continue;

         /* We don't do the reswizzling yet, so just sanity check that we
          * don't have to.
          */
         assert((1 << BRW_GET_SWZ(swizzle, c)) == (1 << c));
      }
      break;
   }
}

/*
 * Tries to reduce extra MOV instructions by taking temporary GRFs that get
 * just written and then MOVed into another reg and making the original write
 * of the GRF write directly to the final destination instead.
 */
bool
vec4_visitor::opt_register_coalesce()
{
   bool progress = false;
   int next_ip = 0;

   calculate_live_intervals();

   foreach_list_safe(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

      int ip = next_ip;
      next_ip++;

      if (inst->opcode != BRW_OPCODE_MOV ||
          (inst->dst.file != GRF && inst->dst.file != MRF) ||
	  inst->predicate ||
	  inst->src[0].file != GRF ||
	  inst->dst.type != inst->src[0].type ||
	  inst->src[0].abs || inst->src[0].negate || inst->src[0].reladdr)
	 continue;

      bool to_mrf = (inst->dst.file == MRF);

      /* Can't coalesce this GRF if someone else was going to
       * read it later.
       */
      if (this->virtual_grf_end[inst->src[0].reg] > ip)
	 continue;

      /* We need to check interference with the final destination between this
       * instruction and the earliest instruction involved in writing the GRF
       * we're eliminating.  To do that, keep track of which of our source
       * channels we've seen initialized.
       */
      bool chans_needed[4] = {false, false, false, false};
      int chans_remaining = 0;
      int swizzle_mask = 0;
      for (int i = 0; i < 4; i++) {
	 int chan = BRW_GET_SWZ(inst->src[0].swizzle, i);

	 if (!(inst->dst.writemask & (1 << i)))
	    continue;

         swizzle_mask |= (1 << chan);

	 if (!chans_needed[chan]) {
	    chans_needed[chan] = true;
	    chans_remaining++;
	 }
      }

      /* Now walk up the instruction stream trying to see if we can rewrite
       * everything writing to the temporary to write into the destination
       * instead.
       */
      vec4_instruction *scan_inst;
      for (scan_inst = (vec4_instruction *)inst->prev;
	   scan_inst->prev != NULL;
	   scan_inst = (vec4_instruction *)scan_inst->prev) {
	 if (scan_inst->dst.file == GRF &&
	     scan_inst->dst.reg == inst->src[0].reg &&
	     scan_inst->dst.reg_offset == inst->src[0].reg_offset) {
            /* Found something writing to the reg we want to coalesce away. */
            if (to_mrf) {
               /* SEND instructions can't have MRF as a destination. */
               if (scan_inst->mlen)
                  break;

               if (brw->gen == 6) {
                  /* gen6 math instructions must have the destination be
                   * GRF, so no compute-to-MRF for them.
                   */
                  if (scan_inst->is_math()) {
                     break;
                  }
               }
            }

            /* If we can't handle the swizzle, bail. */
            if (!scan_inst->can_reswizzle_dst(inst->dst.writemask,
                                              inst->src[0].swizzle,
                                              swizzle_mask)) {
               break;
            }

	    /* Mark which channels we found unconditional writes for. */
	    if (!scan_inst->predicate) {
	       for (int i = 0; i < 4; i++) {
		  if (scan_inst->dst.writemask & (1 << i) &&
		      chans_needed[i]) {
		     chans_needed[i] = false;
		     chans_remaining--;
		  }
	       }
	    }

	    if (chans_remaining == 0)
	       break;
	 }

	 /* We don't handle flow control here.  Most computation of values
	  * that could be coalesced happens just before their use.
	  */
	 if (scan_inst->opcode == BRW_OPCODE_DO ||
	     scan_inst->opcode == BRW_OPCODE_WHILE ||
	     scan_inst->opcode == BRW_OPCODE_ELSE ||
	     scan_inst->opcode == BRW_OPCODE_ENDIF) {
	    break;
	 }

         /* You can't read from an MRF, so if someone else reads our MRF's
          * source GRF that we wanted to rewrite, that stops us.  If it's a
          * GRF we're trying to coalesce to, we don't actually handle
          * rewriting sources so bail in that case as well.
          */
	 bool interfered = false;
	 for (int i = 0; i < 3; i++) {
	    if (scan_inst->src[i].file == GRF &&
		scan_inst->src[i].reg == inst->src[0].reg &&
		scan_inst->src[i].reg_offset == inst->src[0].reg_offset) {
	       interfered = true;
	    }
	 }
	 if (interfered)
	    break;

         /* If somebody else writes our destination here, we can't coalesce
          * before that.
          */
         if (scan_inst->dst.file == inst->dst.file &&
             scan_inst->dst.reg == inst->dst.reg) {
	    break;
         }

         /* Check for reads of the register we're trying to coalesce into.  We
          * can't go rewriting instructions above that to put some other value
          * in the register instead.
          */
         if (to_mrf && scan_inst->mlen > 0) {
            if (inst->dst.reg >= scan_inst->base_mrf &&
                inst->dst.reg < scan_inst->base_mrf + scan_inst->mlen) {
               break;
            }
         } else {
            for (int i = 0; i < 3; i++) {
               if (scan_inst->src[i].file == inst->dst.file &&
                   scan_inst->src[i].reg == inst->dst.reg &&
                   scan_inst->src[i].reg_offset == inst->src[0].reg_offset) {
                  interfered = true;
               }
            }
            if (interfered)
               break;
         }
      }

      if (chans_remaining == 0) {
	 /* If we've made it here, we have an MOV we want to coalesce out, and
	  * a scan_inst pointing to the earliest instruction involved in
	  * computing the value.  Now go rewrite the instruction stream
	  * between the two.
	  */

	 while (scan_inst != inst) {
	    if (scan_inst->dst.file == GRF &&
		scan_inst->dst.reg == inst->src[0].reg &&
		scan_inst->dst.reg_offset == inst->src[0].reg_offset) {
               scan_inst->reswizzle_dst(inst->dst.writemask,
                                        inst->src[0].swizzle);
	       scan_inst->dst.file = inst->dst.file;
	       scan_inst->dst.reg = inst->dst.reg;
	       scan_inst->dst.reg_offset = inst->dst.reg_offset;
	       scan_inst->saturate |= inst->saturate;
	    }
	    scan_inst = (vec4_instruction *)scan_inst->next;
	 }
	 inst->remove();
	 progress = true;
      }
   }

   if (progress)
      live_intervals_valid = false;

   return progress;
}

/**
 * Splits virtual GRFs requesting more than one contiguous physical register.
 *
 * We initially create large virtual GRFs for temporary structures, arrays,
 * and matrices, so that the dereference visitor functions can add reg_offsets
 * to work their way down to the actual member being accessed.  But when it
 * comes to optimization, we'd like to treat each register as individual
 * storage if possible.
 *
 * So far, the only thing that might prevent splitting is a send message from
 * a GRF on IVB.
 */
void
vec4_visitor::split_virtual_grfs()
{
   int num_vars = this->virtual_grf_count;
   int new_virtual_grf[num_vars];
   bool split_grf[num_vars];

   memset(new_virtual_grf, 0, sizeof(new_virtual_grf));

   /* Try to split anything > 0 sized. */
   for (int i = 0; i < num_vars; i++) {
      split_grf[i] = this->virtual_grf_sizes[i] != 1;
   }

   /* Check that the instructions are compatible with the registers we're trying
    * to split.
    */
   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

      /* If there's a SEND message loading from a GRF on gen7+, it needs to be
       * contiguous.  Assume that the GRF for the SEND is always in src[0].
       */
      if (inst->is_send_from_grf()) {
         split_grf[inst->src[0].reg] = false;
      }
   }

   /* Allocate new space for split regs.  Note that the virtual
    * numbers will be contiguous.
    */
   for (int i = 0; i < num_vars; i++) {
      if (!split_grf[i])
         continue;

      new_virtual_grf[i] = virtual_grf_alloc(1);
      for (int j = 2; j < this->virtual_grf_sizes[i]; j++) {
         int reg = virtual_grf_alloc(1);
         assert(reg == new_virtual_grf[i] + j - 1);
         (void) reg;
      }
      this->virtual_grf_sizes[i] = 1;
   }

   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

      if (inst->dst.file == GRF && split_grf[inst->dst.reg] &&
          inst->dst.reg_offset != 0) {
         inst->dst.reg = (new_virtual_grf[inst->dst.reg] +
                          inst->dst.reg_offset - 1);
         inst->dst.reg_offset = 0;
      }
      for (int i = 0; i < 3; i++) {
         if (inst->src[i].file == GRF && split_grf[inst->src[i].reg] &&
             inst->src[i].reg_offset != 0) {
            inst->src[i].reg = (new_virtual_grf[inst->src[i].reg] +
                                inst->src[i].reg_offset - 1);
            inst->src[i].reg_offset = 0;
         }
      }
   }
   this->live_intervals_valid = false;
}

void
vec4_visitor::dump_instruction(backend_instruction *be_inst)
{
   vec4_instruction *inst = (vec4_instruction *)be_inst;

   printf("%s ", brw_instruction_name(inst->opcode));

   switch (inst->dst.file) {
   case GRF:
      printf("vgrf%d.%d", inst->dst.reg, inst->dst.reg_offset);
      break;
   case MRF:
      printf("m%d", inst->dst.reg);
      break;
   case BAD_FILE:
      printf("(null)");
      break;
   default:
      printf("???");
      break;
   }
   if (inst->dst.writemask != WRITEMASK_XYZW) {
      printf(".");
      if (inst->dst.writemask & 1)
         printf("x");
      if (inst->dst.writemask & 2)
         printf("y");
      if (inst->dst.writemask & 4)
         printf("z");
      if (inst->dst.writemask & 8)
         printf("w");
   }
   printf(", ");

   for (int i = 0; i < 3; i++) {
      switch (inst->src[i].file) {
      case GRF:
         printf("vgrf%d", inst->src[i].reg);
         break;
      case ATTR:
         printf("attr%d", inst->src[i].reg);
         break;
      case UNIFORM:
         printf("u%d", inst->src[i].reg);
         break;
      case IMM:
         switch (inst->src[i].type) {
         case BRW_REGISTER_TYPE_F:
            printf("%fF", inst->src[i].imm.f);
            break;
         case BRW_REGISTER_TYPE_D:
            printf("%dD", inst->src[i].imm.i);
            break;
         case BRW_REGISTER_TYPE_UD:
            printf("%uU", inst->src[i].imm.u);
            break;
         default:
            printf("???");
            break;
         }
         break;
      case BAD_FILE:
         printf("(null)");
         break;
      default:
         printf("???");
         break;
      }

      if (inst->src[i].reg_offset)
         printf(".%d", inst->src[i].reg_offset);

      static const char *chans[4] = {"x", "y", "z", "w"};
      printf(".");
      for (int c = 0; c < 4; c++) {
         printf("%s", chans[BRW_GET_SWZ(inst->src[i].swizzle, c)]);
      }

      if (i < 3)
         printf(", ");
   }

   printf("\n");
}

/**
 * Replace each register of type ATTR in this->instructions with a reference
 * to a fixed HW register.
 */
void
vec4_visitor::lower_attributes_to_hw_regs(const int *attribute_map)
{
   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

      /* We have to support ATTR as a destination for GL_FIXED fixup. */
      if (inst->dst.file == ATTR) {
	 int grf = attribute_map[inst->dst.reg + inst->dst.reg_offset];

         /* All attributes used in the shader need to have been assigned a
          * hardware register by the caller
          */
         assert(grf != 0);

	 struct brw_reg reg = brw_vec8_grf(grf, 0);
	 reg.type = inst->dst.type;
	 reg.dw1.bits.writemask = inst->dst.writemask;

	 inst->dst.file = HW_REG;
	 inst->dst.fixed_hw_reg = reg;
      }

      for (int i = 0; i < 3; i++) {
	 if (inst->src[i].file != ATTR)
	    continue;

	 int grf = attribute_map[inst->src[i].reg + inst->src[i].reg_offset];

         /* All attributes used in the shader need to have been assigned a
          * hardware register by the caller
          */
         assert(grf != 0);

	 struct brw_reg reg = brw_vec8_grf(grf, 0);
	 reg.dw1.bits.swizzle = inst->src[i].swizzle;
         reg.type = inst->src[i].type;
	 if (inst->src[i].abs)
	    reg = brw_abs(reg);
	 if (inst->src[i].negate)
	    reg = negate(reg);

	 inst->src[i].file = HW_REG;
	 inst->src[i].fixed_hw_reg = reg;
      }
   }
}

int
vec4_vs_visitor::setup_attributes(int payload_reg)
{
   int nr_attributes;
   int attribute_map[VERT_ATTRIB_MAX + 1];
   memset(attribute_map, 0, sizeof(attribute_map));

   nr_attributes = 0;
   for (int i = 0; i < VERT_ATTRIB_MAX; i++) {
      if (vs_prog_data->inputs_read & BITFIELD64_BIT(i)) {
	 attribute_map[i] = payload_reg + nr_attributes;
	 nr_attributes++;
      }
   }

   /* VertexID is stored by the VF as the last vertex element, but we
    * don't represent it with a flag in inputs_read, so we call it
    * VERT_ATTRIB_MAX.
    */
   if (vs_prog_data->uses_vertexid) {
      attribute_map[VERT_ATTRIB_MAX] = payload_reg + nr_attributes;
      nr_attributes++;
   }

   lower_attributes_to_hw_regs(attribute_map);

   /* The BSpec says we always have to read at least one thing from
    * the VF, and it appears that the hardware wedges otherwise.
    */
   if (nr_attributes == 0)
      nr_attributes = 1;

   prog_data->urb_read_length = (nr_attributes + 1) / 2;

   unsigned vue_entries =
      MAX2(nr_attributes, prog_data->vue_map.num_slots);

   if (brw->gen == 6)
      prog_data->urb_entry_size = ALIGN(vue_entries, 8) / 8;
   else
      prog_data->urb_entry_size = ALIGN(vue_entries, 4) / 4;

   return payload_reg + nr_attributes;
}

int
vec4_visitor::setup_uniforms(int reg)
{
   /* The pre-gen6 VS requires that some push constants get loaded no
    * matter what, or the GPU would hang.
    */
   if (brw->gen < 6 && this->uniforms == 0) {
      this->uniform_vector_size[this->uniforms] = 1;

      for (unsigned int i = 0; i < 4; i++) {
	 unsigned int slot = this->uniforms * 4 + i;
	 static float zero = 0.0;
	 prog_data->param[slot] = &zero;
      }

      this->uniforms++;
      reg++;
   } else {
      reg += ALIGN(uniforms, 2) / 2;
   }

   prog_data->nr_params = this->uniforms * 4;

   prog_data->curb_read_length = reg - 1;

   return reg;
}

void
vec4_visitor::setup_payload(void)
{
   int reg = 0;

   /* The payload always contains important data in g0, which contains
    * the URB handles that are passed on to the URB write at the end
    * of the thread.  So, we always start push constants at g1.
    */
   reg++;

   reg = setup_uniforms(reg);

   reg = setup_attributes(reg);

   this->first_non_payload_grf = reg;
}

src_reg
vec4_visitor::get_timestamp()
{
   assert(brw->gen >= 7);

   src_reg ts = src_reg(brw_reg(BRW_ARCHITECTURE_REGISTER_FILE,
                                BRW_ARF_TIMESTAMP,
                                0,
                                BRW_REGISTER_TYPE_UD,
                                BRW_VERTICAL_STRIDE_0,
                                BRW_WIDTH_4,
                                BRW_HORIZONTAL_STRIDE_4,
                                BRW_SWIZZLE_XYZW,
                                WRITEMASK_XYZW));

   dst_reg dst = dst_reg(this, glsl_type::uvec4_type);

   vec4_instruction *mov = emit(MOV(dst, ts));
   /* We want to read the 3 fields we care about (mostly field 0, but also 2)
    * even if it's not enabled in the dispatch.
    */
   mov->force_writemask_all = true;

   return src_reg(dst);
}

void
vec4_visitor::emit_shader_time_begin()
{
   current_annotation = "shader time start";
   shader_start_time = get_timestamp();
}

void
vec4_visitor::emit_shader_time_end()
{
   current_annotation = "shader time end";
   src_reg shader_end_time = get_timestamp();


   /* Check that there weren't any timestamp reset events (assuming these
    * were the only two timestamp reads that happened).
    */
   src_reg reset_end = shader_end_time;
   reset_end.swizzle = BRW_SWIZZLE_ZZZZ;
   vec4_instruction *test = emit(AND(dst_null_d(), reset_end, src_reg(1u)));
   test->conditional_mod = BRW_CONDITIONAL_Z;

   emit(IF(BRW_PREDICATE_NORMAL));

   /* Take the current timestamp and get the delta. */
   shader_start_time.negate = true;
   dst_reg diff = dst_reg(this, glsl_type::uint_type);
   emit(ADD(diff, shader_start_time, shader_end_time));

   /* If there were no instructions between the two timestamp gets, the diff
    * is 2 cycles.  Remove that overhead, so I can forget about that when
    * trying to determine the time taken for single instructions.
    */
   emit(ADD(diff, src_reg(diff), src_reg(-2u)));

   emit_shader_time_write(ST_VS, src_reg(diff));
   emit_shader_time_write(ST_VS_WRITTEN, src_reg(1u));
   emit(BRW_OPCODE_ELSE);
   emit_shader_time_write(ST_VS_RESET, src_reg(1u));
   emit(BRW_OPCODE_ENDIF);
}

void
vec4_visitor::emit_shader_time_write(enum shader_time_shader_type type,
                                     src_reg value)
{
   int shader_time_index =
      brw_get_shader_time_index(brw, shader_prog, prog, type);

   dst_reg dst =
      dst_reg(this, glsl_type::get_array_instance(glsl_type::vec4_type, 2));

   dst_reg offset = dst;
   dst_reg time = dst;
   time.reg_offset++;

   offset.type = BRW_REGISTER_TYPE_UD;
   emit(MOV(offset, src_reg(shader_time_index * SHADER_TIME_STRIDE)));

   time.type = BRW_REGISTER_TYPE_UD;
   emit(MOV(time, src_reg(value)));

   emit(SHADER_OPCODE_SHADER_TIME_ADD, dst_reg(), src_reg(dst));
}

bool
vec4_visitor::run()
{
   sanity_param_count = prog->Parameters->NumParameters;

   if (INTEL_DEBUG & DEBUG_SHADER_TIME)
      emit_shader_time_begin();

   emit_prolog();

   /* Generate VS IR for main().  (the visitor only descends into
    * functions called "main").
    */
   if (shader) {
      visit_instructions(shader->ir);
   } else {
      emit_program_code();
   }
   base_ir = NULL;

   if (key->userclip_active && !key->uses_clip_distance)
      setup_uniform_clipplane_values();

   emit_thread_end();

   /* Before any optimization, push array accesses out to scratch
    * space where we need them to be.  This pass may allocate new
    * virtual GRFs, so we want to do it early.  It also makes sure
    * that we have reladdr computations available for CSE, since we'll
    * often do repeated subexpressions for those.
    */
   if (shader) {
      move_grf_array_access_to_scratch();
      move_uniform_array_access_to_pull_constants();
   } else {
      /* The ARB_vertex_program frontend emits pull constant loads directly
       * rather than using reladdr, so we don't need to walk through all the
       * instructions looking for things to move.  There isn't anything.
       *
       * We do still need to split things to vec4 size.
       */
      split_uniform_registers();
   }
   pack_uniform_registers();
   move_push_constants_to_pull_constants();
   split_virtual_grfs();

   bool progress;
   do {
      progress = false;
      progress = dead_code_eliminate() || progress;
      progress = opt_copy_propagation() || progress;
      progress = opt_algebraic() || progress;
      progress = opt_register_coalesce() || progress;
   } while (progress);


   if (failed)
      return false;

   setup_payload();

   if (false) {
      /* Debug of register spilling: Go spill everything. */
      const int grf_count = virtual_grf_count;
      float spill_costs[virtual_grf_count];
      bool no_spill[virtual_grf_count];
      evaluate_spill_costs(spill_costs, no_spill);
      for (int i = 0; i < grf_count; i++) {
         if (no_spill[i])
            continue;
         spill_reg(i);
      }
   }

   while (!reg_allocate()) {
      if (failed)
         break;
   }

   opt_schedule_instructions();

   opt_set_dependency_control();

   /* If any state parameters were appended, then ParameterValues could have
    * been realloced, in which case the driver uniform storage set up by
    * _mesa_associate_uniform_storage() would point to freed memory.  Make
    * sure that didn't happen.
    */
   assert(sanity_param_count == prog->Parameters->NumParameters);

   return !failed;
}

} /* namespace brw */

extern "C" {

/**
 * Compile a vertex shader.
 *
 * Returns the final assembly and the program's size.
 */
const unsigned *
brw_vs_emit(struct brw_context *brw,
            struct gl_shader_program *prog,
            struct brw_vs_compile *c,
            struct brw_vs_prog_data *prog_data,
            void *mem_ctx,
            unsigned *final_assembly_size)
{
   bool start_busy = false;
   float start_time = 0;

   if (unlikely(brw->perf_debug)) {
      start_busy = (brw->batch.last_bo &&
                    drm_intel_bo_busy(brw->batch.last_bo));
      start_time = get_time();
   }

   struct brw_shader *shader = NULL;
   if (prog)
      shader = (brw_shader *) prog->_LinkedShaders[MESA_SHADER_VERTEX];

   if (unlikely(INTEL_DEBUG & DEBUG_VS)) {
      if (prog) {
         printf("GLSL IR for native vertex shader %d:\n", prog->Name);
         _mesa_print_ir(shader->ir, NULL);
         printf("\n\n");
      } else {
         printf("ARB_vertex_program %d for native vertex shader\n",
                c->vp->program.Base.Id);
         _mesa_print_program(&c->vp->program.Base);
      }
   }

   vec4_vs_visitor v(brw, c, prog_data, prog, shader, mem_ctx);
   if (!v.run()) {
      if (prog) {
         prog->LinkStatus = false;
         ralloc_strcat(&prog->InfoLog, v.fail_msg);
      }

      _mesa_problem(NULL, "Failed to compile vertex shader: %s\n",
                    v.fail_msg);

      return NULL;
   }

   vec4_generator g(brw, prog, &c->vp->program.Base, mem_ctx,
                    INTEL_DEBUG & DEBUG_VS);
   const unsigned *generated =g.generate_assembly(&v.instructions,
                                                  final_assembly_size);

   if (unlikely(brw->perf_debug) && shader) {
      if (shader->compiled_once) {
         brw_vs_debug_recompile(brw, prog, &c->key);
      }
      if (start_busy && !drm_intel_bo_busy(brw->batch.last_bo)) {
         perf_debug("VS compile took %.03f ms and stalled the GPU\n",
                    (get_time() - start_time) * 1000);
      }
      shader->compiled_once = true;
   }

   return generated;
}

} /* extern "C" */
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.1
@
text
@d1033 1
a1033 1
       * contiguous.
d1036 1
a1036 5
         for (int i = 0; i < 3; i++) {
            if (inst->src[i].file == GRF) {
               split_grf[inst->src[i].reg] = false;
            }
         }
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@a25 2
#include "brw_vs.h"
#include "brw_dead_control_flow.h"
d77 1
a77 1
      this->swizzle = BRW_SWIZZLE_XYZW;
a112 9
src_reg::src_reg(struct brw_reg reg)
{
   init();

   this->file = HW_REG;
   this->fixed_hw_reg = reg;
   this->type = reg.type;
}

a142 9
bool
src_reg::is_accumulator() const
{
   return file == HW_REG &&
          fixed_hw_reg.file == BRW_ARCHITECTURE_REGISTER_FILE &&
          fixed_hw_reg.nr == BRW_ARF_ACCUMULATOR;
}


a180 1
   this->type = reg.type;
a203 16
dst_reg::is_null() const
{
   return file == HW_REG &&
          fixed_hw_reg.file == BRW_ARCHITECTURE_REGISTER_FILE &&
          fixed_hw_reg.nr == BRW_ARF_NULL;
}

bool
dst_reg::is_accumulator() const
{
   return file == HW_REG &&
          fixed_hw_reg.file == BRW_ARCHITECTURE_REGISTER_FILE &&
          fixed_hw_reg.nr == BRW_ARF_ACCUMULATOR;
}

bool
a223 3
   if (!inst->can_do_source_mods())
      return false;

d257 1
a257 1
   case SHADER_OPCODE_GEN4_SCRATCH_READ:
d259 1
a259 1
   case SHADER_OPCODE_GEN4_SCRATCH_WRITE:
a260 3
   case GS_OPCODE_URB_WRITE:
   case GS_OPCODE_THREAD_END:
      return 0;
d267 1
a267 2
   case SHADER_OPCODE_TXF_CMS:
   case SHADER_OPCODE_TXF_MCS:
a268 2
   case SHADER_OPCODE_TG4:
   case SHADER_OPCODE_TG4_OFFSET:
a269 3
   case SHADER_OPCODE_UNTYPED_ATOMIC:
   case SHADER_OPCODE_UNTYPED_SURFACE_READ:
      return 0;
a291 40
static bool
try_eliminate_instruction(vec4_instruction *inst, int new_writemask,
                          const struct brw_context *brw)
{
   if (inst->has_side_effects())
      return false;

   if (new_writemask == 0) {
      /* Don't dead code eliminate instructions that write to the
       * accumulator as a side-effect. Instead just set the destination
       * to the null register to free it.
       */
      if (inst->writes_accumulator || inst->writes_flag()) {
         inst->dst = dst_reg(retype(brw_null_reg(), inst->dst.type));
      } else {
         inst->remove();
      }

      return true;
   } else if (inst->dst.writemask != new_writemask) {
      switch (inst->opcode) {
      case SHADER_OPCODE_TXF_CMS:
      case SHADER_OPCODE_GEN4_SCRATCH_READ:
      case VS_OPCODE_PULL_CONSTANT_LOAD:
      case VS_OPCODE_PULL_CONSTANT_LOAD_GEN7:
         break;
      default:
         /* Do not set a writemask on Gen6 for math instructions, those are
          * executed using align1 mode that does not support a destination mask.
          */
         if (!(brw->gen == 6 && inst->is_math()) && !inst->is_tex()) {
            inst->dst.writemask = new_writemask;
            return true;
         }
      }
   }

   return false;
}

d293 1
a293 1
 * Must be called after calculate_live_intervals() to remove unused
d302 1
a302 1
   int pc = -1;
a308 11
      pc++;

      bool inst_writes_flag = false;
      if (inst->dst.file != GRF) {
         if (inst->dst.is_null() && inst->writes_flag()) {
            inst_writes_flag = true;
         } else {
            continue;
         }
      }

d310 4
a313 9
         int write_mask = inst->dst.writemask;

         for (int c = 0; c < 4; c++) {
            if (write_mask & (1 << c)) {
               assert(this->virtual_grf_end[inst->dst.reg * 4 + c] >= pc);
               if (this->virtual_grf_end[inst->dst.reg * 4 + c] == pc) {
                  write_mask &= ~(1 << c);
               }
            }
a314 3

         progress = try_eliminate_instruction(inst, write_mask, brw) ||
                    progress;
d317 1
a317 61
      if (inst->predicate || inst->prev == NULL)
         continue;

      int dead_channels;
      if (inst_writes_flag) {
/* Arbitrarily chosen, other than not being an xyzw writemask. */
#define FLAG_WRITEMASK (1 << 5)
         dead_channels = inst->reads_flag() ? 0 : FLAG_WRITEMASK;
      } else {
         dead_channels = inst->dst.writemask;

         for (int i = 0; i < 3; i++) {
            if (inst->src[i].file != GRF ||
                inst->src[i].reg != inst->dst.reg)
                  continue;

            for (int j = 0; j < 4; j++) {
               int swiz = BRW_GET_SWZ(inst->src[i].swizzle, j);
               dead_channels &= ~(1 << swiz);
            }
         }
      }

      for (exec_node *node = inst->prev, *prev = node->prev;
           prev != NULL && dead_channels != 0;
           node = prev, prev = prev->prev) {
         vec4_instruction *scan_inst = (vec4_instruction  *)node;

         if (scan_inst->is_control_flow())
            break;

         if (inst_writes_flag) {
            if (scan_inst->dst.is_null() && scan_inst->writes_flag()) {
               scan_inst->remove();
               progress = true;
               continue;
            } else if (scan_inst->reads_flag()) {
               break;
            }
         }

         if (inst->dst.file == scan_inst->dst.file &&
             inst->dst.reg == scan_inst->dst.reg &&
             inst->dst.reg_offset == scan_inst->dst.reg_offset) {
            int new_writemask = scan_inst->dst.writemask & ~dead_channels;

            progress = try_eliminate_instruction(scan_inst, new_writemask, brw) ||
                       progress;
         }

         for (int i = 0; i < 3; i++) {
            if (scan_inst->src[i].file != inst->dst.file ||
                scan_inst->src[i].reg != inst->dst.reg)
               continue;

            for (int j = 0; j < 4; j++) {
               int swiz = BRW_GET_SWZ(scan_inst->src[i].swizzle, j);
               dead_channels &= ~(1 << swiz);
            }
         }
      }
d321 1
a321 1
      invalidate_live_intervals();
a387 1
      assert(src < uniform_array_size);
d411 2
a412 2
	    stage_prog_data->param[dst * 4 + new_chan[src] + j] =
	       stage_prog_data->param[src * 4 + j];
d532 1
a532 1
      invalidate_live_intervals();
d563 1
a563 1
	 const float **values = &stage_prog_data->param[i];
d568 1
a568 1
	 for (unsigned int j = 0; j < stage_prog_data->nr_pull_params; j += 4) {
d572 1
a572 1
	       if (stage_prog_data->pull_param[j + matches] != values[matches])
d583 2
a584 2
	    assert(stage_prog_data->nr_pull_params % 4 == 0);
	    pull_constant_loc[i / 4] = stage_prog_data->nr_pull_params / 4;
d587 1
a587 2
	       stage_prog_data->pull_param[stage_prog_data->nr_pull_params++] =
                  values[j];
d645 1
a645 1
   cfg_t cfg(&instructions);
a692 8
         /* Dependency control does not work well over math instructions.
          */
         if (inst->is_math()) {
            memset(last_grf_write, 0, sizeof(last_grf_write));
            memset(last_mrf_write, 0, sizeof(last_mrf_write));
            continue;
         }

d839 1
a839 4
      if (this->virtual_grf_end[inst->src[0].reg * 4 + 0] > ip ||
          this->virtual_grf_end[inst->src[0].reg * 4 + 1] > ip ||
          this->virtual_grf_end[inst->src[0].reg * 4 + 2] > ip ||
          this->virtual_grf_end[inst->src[0].reg * 4 + 3] > ip)
d995 1
a995 1
      invalidate_live_intervals();
d1078 1
a1078 1
   invalidate_live_intervals();
d1086 1
a1086 10
   if (inst->predicate) {
      fprintf(stderr, "(%cf0) ",
             inst->predicate_inverse ? '-' : '+');
   }

   fprintf(stderr, "%s", brw_instruction_name(inst->opcode));
   if (inst->conditional_mod) {
      fprintf(stderr, "%s", conditional_modifier[inst->conditional_mod]);
   }
   fprintf(stderr, " ");
d1090 1
a1090 1
      fprintf(stderr, "vgrf%d.%d", inst->dst.reg, inst->dst.reg_offset);
d1093 1
a1093 28
      fprintf(stderr, "m%d", inst->dst.reg);
      break;
   case HW_REG:
      if (inst->dst.fixed_hw_reg.file == BRW_ARCHITECTURE_REGISTER_FILE) {
         switch (inst->dst.fixed_hw_reg.nr) {
         case BRW_ARF_NULL:
            fprintf(stderr, "null");
            break;
         case BRW_ARF_ADDRESS:
            fprintf(stderr, "a0.%d", inst->dst.fixed_hw_reg.subnr);
            break;
         case BRW_ARF_ACCUMULATOR:
            fprintf(stderr, "acc%d", inst->dst.fixed_hw_reg.subnr);
            break;
         case BRW_ARF_FLAG:
            fprintf(stderr, "f%d.%d", inst->dst.fixed_hw_reg.nr & 0xf,
                             inst->dst.fixed_hw_reg.subnr);
            break;
         default:
            fprintf(stderr, "arf%d.%d", inst->dst.fixed_hw_reg.nr & 0xf,
                               inst->dst.fixed_hw_reg.subnr);
            break;
         }
      } else {
         fprintf(stderr, "hw_reg%d", inst->dst.fixed_hw_reg.nr);
      }
      if (inst->dst.fixed_hw_reg.subnr)
         fprintf(stderr, "+%d", inst->dst.fixed_hw_reg.subnr);
d1096 1
a1096 1
      fprintf(stderr, "(null)");
d1099 1
a1099 1
      fprintf(stderr, "???");
d1103 1
a1103 1
      fprintf(stderr, ".");
d1105 1
a1105 1
         fprintf(stderr, "x");
d1107 1
a1107 1
         fprintf(stderr, "y");
d1109 1
a1109 1
         fprintf(stderr, "z");
d1111 1
a1111 1
         fprintf(stderr, "w");
d1113 1
a1113 1
   fprintf(stderr, ":%s, ", brw_reg_type_letters(inst->dst.type));
d1115 1
a1115 5
   for (int i = 0; i < 3 && inst->src[i].file != BAD_FILE; i++) {
      if (inst->src[i].negate)
         fprintf(stderr, "-");
      if (inst->src[i].abs)
         fprintf(stderr, "|");
d1118 1
a1118 1
         fprintf(stderr, "vgrf%d", inst->src[i].reg);
d1121 1
a1121 1
         fprintf(stderr, "attr%d", inst->src[i].reg);
d1124 1
a1124 1
         fprintf(stderr, "u%d", inst->src[i].reg);
d1129 1
a1129 1
            fprintf(stderr, "%fF", inst->src[i].imm.f);
d1132 1
a1132 1
            fprintf(stderr, "%dD", inst->src[i].imm.i);
d1135 1
a1135 1
            fprintf(stderr, "%uU", inst->src[i].imm.u);
d1138 1
a1138 1
            fprintf(stderr, "???");
a1141 33
      case HW_REG:
         if (inst->src[i].fixed_hw_reg.negate)
            fprintf(stderr, "-");
         if (inst->src[i].fixed_hw_reg.abs)
            fprintf(stderr, "|");
         if (inst->src[i].fixed_hw_reg.file == BRW_ARCHITECTURE_REGISTER_FILE) {
            switch (inst->src[i].fixed_hw_reg.nr) {
            case BRW_ARF_NULL:
               fprintf(stderr, "null");
               break;
            case BRW_ARF_ADDRESS:
               fprintf(stderr, "a0.%d", inst->src[i].fixed_hw_reg.subnr);
               break;
            case BRW_ARF_ACCUMULATOR:
               fprintf(stderr, "acc%d", inst->src[i].fixed_hw_reg.subnr);
               break;
            case BRW_ARF_FLAG:
               fprintf(stderr, "f%d.%d", inst->src[i].fixed_hw_reg.nr & 0xf,
                                inst->src[i].fixed_hw_reg.subnr);
               break;
            default:
               fprintf(stderr, "arf%d.%d", inst->src[i].fixed_hw_reg.nr & 0xf,
                                  inst->src[i].fixed_hw_reg.subnr);
               break;
            }
         } else {
            fprintf(stderr, "hw_reg%d", inst->src[i].fixed_hw_reg.nr);
         }
         if (inst->src[i].fixed_hw_reg.subnr)
            fprintf(stderr, "+%d", inst->src[i].fixed_hw_reg.subnr);
         if (inst->src[i].fixed_hw_reg.abs)
            fprintf(stderr, "|");
         break;
d1143 1
a1143 1
         fprintf(stderr, "(null)");
d1146 1
a1146 1
         fprintf(stderr, "???");
d1150 2
a1151 2
      if (virtual_grf_sizes[inst->src[i].reg] != 1)
         fprintf(stderr, ".%d", inst->src[i].reg_offset);
d1153 4
a1156 6
      if (inst->src[i].file != IMM) {
         static const char *chans[4] = {"x", "y", "z", "w"};
         fprintf(stderr, ".");
         for (int c = 0; c < 4; c++) {
            fprintf(stderr, "%s", chans[BRW_GET_SWZ(inst->src[i].swizzle, c)]);
         }
d1159 2
a1160 9
      if (inst->src[i].abs)
         fprintf(stderr, "|");

      if (inst->src[i].file != IMM) {
         fprintf(stderr, ":%s", brw_reg_type_letters(inst->src[i].type));
      }

      if (i < 2 && inst->src[i + 1].file != BAD_FILE)
         fprintf(stderr, ", ");
d1163 1
a1163 11
   fprintf(stderr, "\n");
}


static inline struct brw_reg
attribute_to_hw_reg(int attr, bool interleaved)
{
   if (interleaved)
      return stride(brw_vec4_grf(attr / 2, (attr % 2) * 4), 0, 4, 1);
   else
      return brw_vec8_grf(attr, 0);
a1165 1

a1168 8
 *
 * If interleaved is true, then each attribute takes up half a register, with
 * register N containing attribute 2*N in its first half and attribute 2*N+1
 * in its second half (this corresponds to the payload setup used by geometry
 * shaders in "single" or "dual instanced" dispatch mode).  If interleaved is
 * false, then each attribute takes up a whole register, with register N
 * containing attribute N (this corresponds to the payload setup used by
 * vertex shaders, and by geometry shaders in "dual object" dispatch mode).
d1171 1
a1171 2
vec4_visitor::lower_attributes_to_hw_regs(const int *attribute_map,
                                          bool interleaved)
d1185 1
a1185 1
	 struct brw_reg reg = attribute_to_hw_reg(grf, interleaved);
d1204 1
a1204 1
	 struct brw_reg reg = attribute_to_hw_reg(grf, interleaved);
d1242 1
a1242 1
   lower_attributes_to_hw_regs(attribute_map, false /* interleaved */);
a1265 2
   prog_data->dispatch_grf_start_reg = reg;

a1269 1
      assert(this->uniforms < this->uniform_array_size);
a1271 2
      stage_prog_data->param =
         reralloc(NULL, stage_prog_data->param, const float *, 4);
d1275 1
a1275 1
	 stage_prog_data->param[slot] = &zero;
d1284 1
a1284 1
   stage_prog_data->nr_params = this->uniforms * 4;
d1286 1
a1286 1
   prog_data->curb_read_length = reg - prog_data->dispatch_grf_start_reg;
d1292 1
a1292 1
vec4_vs_visitor::setup_payload(void)
d1370 2
a1371 2
   emit_shader_time_write(st_base, src_reg(diff));
   emit_shader_time_write(st_written, src_reg(1u));
d1373 1
a1373 1
   emit_shader_time_write(st_reset, src_reg(1u));
a1407 2
   assign_common_binding_table_offsets(0);

d1414 1
a1414 1
      visit_instructions(shader->base.ir);
d1420 1
a1420 1
   if (key->userclip_active && !prog->UsesClipDistanceOut)
a1450 1
      progress = dead_control_flow_eliminate(this) || progress;
d1477 1
a1477 1
         return false;
d1512 1
a1512 1
   double start_time = 0;
d1524 11
a1534 2
   if (unlikely(INTEL_DEBUG & DEBUG_VS))
      brw_dump_ir(brw, "vertex", prog, &shader->base, &c->vp->program.Base);
d1536 1
a1536 1
   vec4_vs_visitor v(brw, c, prog_data, prog, mem_ctx);
d1549 4
a1552 10
   const unsigned *assembly = NULL;
   if (brw->gen >= 8) {
      gen8_vec4_generator g(brw, prog, &c->vp->program.Base, &prog_data->base,
                            mem_ctx, INTEL_DEBUG & DEBUG_VS);
      assembly = g.generate_assembly(&v.instructions, final_assembly_size);
   } else {
      vec4_generator g(brw, prog, &c->vp->program.Base, &prog_data->base,
                       mem_ctx, INTEL_DEBUG & DEBUG_VS);
      assembly = g.generate_assembly(&v.instructions, final_assembly_size);
   }
d1565 1
a1565 23
   return assembly;
}


void
brw_vec4_setup_prog_key_for_precompile(struct gl_context *ctx,
                                       struct brw_vec4_prog_key *key,
                                       GLuint id, struct gl_program *prog)
{
   key->program_string_id = id;
   key->clamp_vertex_color = ctx->API == API_OPENGL_COMPAT;

   unsigned sampler_count = _mesa_fls(prog->SamplersUsed);
   for (unsigned i = 0; i < sampler_count; i++) {
      if (prog->ShadowSamplers & (1 << i)) {
         /* Assume DEPTH_TEXTURE_MODE is the default: X, X, X, 1 */
         key->tex.swizzles[i] =
            MAKE_SWIZZLE4(SWIZZLE_X, SWIZZLE_X, SWIZZLE_X, SWIZZLE_ONE);
      } else {
         /* Color sampler: assume no swizzling. */
         key->tex.swizzles[i] = SWIZZLE_XYZW;
      }
   }
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@d94 1
a94 1
   this->fixed_hw_reg.dw1.f = f;
d103 1
a103 1
   this->fixed_hw_reg.dw1.ud = u;
d112 1
a112 1
   this->fixed_hw_reg.dw1.d = i;
d154 9
d225 16
d253 1
a253 1
vec4_instruction::can_do_source_mods(struct brw_context *brw)
d255 1
a255 1
   if (brw->gen == 6 && is_math())
d258 1
a258 1
   if (is_send_from_grf())
d261 1
a261 1
   if (!backend_instruction::can_do_source_mods())
a301 1
   case GS_OPCODE_URB_WRITE_ALLOCATE:
a303 2
   case GS_OPCODE_FF_SYNC:
      return 1;
d320 2
a321 1
      unreachable("not reached");
d326 1
a326 1
src_reg::equals(const src_reg &r) const
d328 11
a338 107
   return (file == r.file &&
	   reg == r.reg &&
	   reg_offset == r.reg_offset &&
	   type == r.type &&
	   negate == r.negate &&
	   abs == r.abs &&
	   swizzle == r.swizzle &&
	   !reladdr && !r.reladdr &&
	   memcmp(&fixed_hw_reg, &r.fixed_hw_reg,
		  sizeof(fixed_hw_reg)) == 0);
}

/* Replaces unused channels of a swizzle with channels that are used.
 *
 * For instance, this pass transforms
 *
 *    mov vgrf4.yz, vgrf5.wxzy
 *
 * into
 *
 *    mov vgrf4.yz, vgrf5.xxzx
 *
 * This eliminates false uses of some channels, letting dead code elimination
 * remove the instructions that wrote them.
 */
bool
vec4_visitor::opt_reduce_swizzle()
{
   bool progress = false;

   foreach_block_and_inst_safe(block, vec4_instruction, inst, cfg) {
      if (inst->dst.file == BAD_FILE || inst->dst.file == HW_REG)
         continue;

      int swizzle[4];

      /* Determine which channels of the sources are read. */
      switch (inst->opcode) {
      case BRW_OPCODE_DP4:
      case BRW_OPCODE_DPH: /* FINISHME: DPH reads only three channels of src0,
                            *           but all four of src1.
                            */
         swizzle[0] = 0;
         swizzle[1] = 1;
         swizzle[2] = 2;
         swizzle[3] = 3;
         break;
      case BRW_OPCODE_DP3:
         swizzle[0] = 0;
         swizzle[1] = 1;
         swizzle[2] = 2;
         swizzle[3] = -1;
         break;
      case BRW_OPCODE_DP2:
         swizzle[0] = 0;
         swizzle[1] = 1;
         swizzle[2] = -1;
         swizzle[3] = -1;
         break;
      default:
         swizzle[0] = inst->dst.writemask & WRITEMASK_X ? 0 : -1;
         swizzle[1] = inst->dst.writemask & WRITEMASK_Y ? 1 : -1;
         swizzle[2] = inst->dst.writemask & WRITEMASK_Z ? 2 : -1;
         swizzle[3] = inst->dst.writemask & WRITEMASK_W ? 3 : -1;
         break;
      }

      /* Resolve unread channels (-1) by assigning them the swizzle of the
       * first channel that is used.
       */
      int first_used_channel = 0;
      for (int i = 0; i < 4; i++) {
         if (swizzle[i] != -1) {
            first_used_channel = swizzle[i];
            break;
         }
      }
      for (int i = 0; i < 4; i++) {
         if (swizzle[i] == -1) {
            swizzle[i] = first_used_channel;
         }
      }

      /* Update sources' swizzles. */
      for (int i = 0; i < 3; i++) {
         if (inst->src[i].file != GRF &&
             inst->src[i].file != ATTR &&
             inst->src[i].file != UNIFORM)
            continue;

         int swiz[4];
         for (int j = 0; j < 4; j++) {
            swiz[j] = BRW_GET_SWZ(inst->src[i].swizzle, swizzle[j]);
         }

         unsigned new_swizzle = BRW_SWIZZLE4(swiz[0], swiz[1], swiz[2], swiz[3]);
         if (inst->src[i].swizzle != new_swizzle) {
            inst->src[i].swizzle = new_swizzle;
            progress = true;
         }
      }
   }

   if (progress)
      invalidate_live_intervals();

   return progress;
d356 1
a356 1
         inst->opcode = BRW_OPCODE_NOP;
d395 3
a397 1
   foreach_block_and_inst(block, vec4_instruction, inst, cfg) {
d448 6
a453 3
      foreach_inst_in_block_reverse_starting_from(vec4_instruction, scan_inst,
                                                  inst, block) {
         if (dead_channels == 0)
d458 1
a458 1
               scan_inst->opcode = BRW_OPCODE_NOP;
d488 1
a488 7
   if (progress) {
      foreach_block_and_inst_safe (block, backend_instruction, inst, cfg) {
         if (inst->opcode == BRW_OPCODE_NOP) {
            inst->remove(block);
         }
      }

a489 1
   }
d504 3
a506 1
   foreach_block_and_inst(block, vec4_instruction, inst, cfg) {
d539 3
a541 1
   foreach_block_and_inst(block, vec4_instruction, inst, cfg) {
d594 3
a596 1
   foreach_block_and_inst(block, vec4_instruction, inst, cfg) {
d614 26
d657 3
a659 1
   foreach_block_and_inst(block, vec4_instruction, inst, cfg) {
d683 3
a685 1
	       unreachable("not reached");
a694 11
      case SHADER_OPCODE_RCP: {
         vec4_instruction *prev = (vec4_instruction *)inst->prev;
         if (prev->opcode == SHADER_OPCODE_SQRT) {
            if (inst->src[0].equals(src_reg(prev->dst))) {
               inst->opcode = SHADER_OPCODE_RSQ;
               inst->src[0] = prev->src[0];
               progress = true;
            }
         }
         break;
      }
a717 3
    *
    * If changing this value, note the limitation about total_regs in
    * brw_curbe.c.
d732 1
a732 1
	 const gl_constant_value **values = &stage_prog_data->param[i];
d766 3
a768 1
   foreach_block_and_inst_safe(block, vec4_instruction, inst, cfg) {
d778 1
a778 1
	 emit_pull_constant_load(block, inst, temp, inst->src[i],
d815 2
d820 4
a823 1
   foreach_block (block, cfg) {
d827 3
a829 1
      foreach_inst_in_block (vec4_instruction, inst, block) {
d908 3
a910 3
vec4_instruction::can_reswizzle(int dst_writemask,
                                int swizzle,
                                int swizzle_mask)
d918 12
a929 2
   if (mlen > 0)
      return false;
d931 8
a938 1
   return true;
d949 1
a949 1
vec4_instruction::reswizzle(int dst_writemask, int swizzle)
a951 1
   int new_swizzle[4] = { 0 };
d953 21
a973 5
   /* Dot product instructions write a single result into all channels. */
   if (opcode != BRW_OPCODE_DP4 && opcode != BRW_OPCODE_DPH &&
       opcode != BRW_OPCODE_DP3 && opcode != BRW_OPCODE_DP2) {
      for (int i = 0; i < 3; i++) {
         if (src[i].file == BAD_FILE || src[i].file == IMM)
d976 4
a979 6
         for (int c = 0; c < 4; c++) {
            new_swizzle[c] = BRW_GET_SWZ(src[i].swizzle, BRW_GET_SWZ(swizzle, c));
         }

         src[i].swizzle = BRW_SWIZZLE4(new_swizzle[0], new_swizzle[1],
                                       new_swizzle[2], new_swizzle[3]);
d981 1
a982 13

   for (int c = 0; c < 4; c++) {
      int bit = 1 << BRW_GET_SWZ(swizzle, c);
      /* Skip components of the swizzle not used by the dst. */
      if (!(dst_writemask & (1 << c)))
         continue;
      /* If we were populating this component, then populate the
       * corresponding channel of the new dst.
       */
      if (dst.writemask & bit)
         new_writemask |= (1 << c);
   }
   dst.writemask = new_writemask;
d998 3
a1000 1
   foreach_block_and_inst_safe (block, vec4_instruction, inst, cfg) {
d1049 4
a1052 5
      vec4_instruction *_scan_inst = (vec4_instruction *)inst->prev;
      foreach_inst_in_block_reverse_starting_from(vec4_instruction, scan_inst,
                                                  inst, block) {
         _scan_inst = scan_inst;

d1073 3
a1075 3
            if (!scan_inst->can_reswizzle(inst->dst.writemask,
                                          inst->src[0].swizzle,
                                          swizzle_mask)) {
d1094 10
d1156 1
a1156 1
         vec4_instruction *scan_inst = _scan_inst;
d1161 2
a1162 2
               scan_inst->reswizzle(inst->dst.writemask,
                                    inst->src[0].swizzle);
d1170 1
a1170 1
	 inst->remove(block);
d1210 3
a1212 1
   foreach_block_and_inst(block, vec4_instruction, inst, cfg) {
d1241 3
a1243 1
   foreach_block_and_inst(block, vec4_instruction, inst, cfg) {
a1264 6
   dump_instruction(be_inst, stderr);
}

void
vec4_visitor::dump_instruction(backend_instruction *be_inst, FILE *file)
{
d1268 1
a1268 1
      fprintf(file, "(%cf0) ",
d1272 1
a1272 1
   fprintf(file, "%s", brw_instruction_name(inst->opcode));
d1274 1
a1274 1
      fprintf(file, "%s", conditional_modifier[inst->conditional_mod]);
d1276 1
a1276 1
   fprintf(file, " ");
d1280 1
a1280 1
      fprintf(file, "vgrf%d.%d", inst->dst.reg, inst->dst.reg_offset);
d1283 1
a1283 1
      fprintf(file, "m%d", inst->dst.reg);
d1289 1
a1289 1
            fprintf(file, "null");
d1292 1
a1292 1
            fprintf(file, "a0.%d", inst->dst.fixed_hw_reg.subnr);
d1295 1
a1295 1
            fprintf(file, "acc%d", inst->dst.fixed_hw_reg.subnr);
d1298 1
a1298 1
            fprintf(file, "f%d.%d", inst->dst.fixed_hw_reg.nr & 0xf,
d1302 1
a1302 1
            fprintf(file, "arf%d.%d", inst->dst.fixed_hw_reg.nr & 0xf,
d1307 1
a1307 1
         fprintf(file, "hw_reg%d", inst->dst.fixed_hw_reg.nr);
d1310 1
a1310 1
         fprintf(file, "+%d", inst->dst.fixed_hw_reg.subnr);
d1313 1
a1313 1
      fprintf(file, "(null)");
d1316 1
a1316 1
      fprintf(file, "???");
d1320 1
a1320 1
      fprintf(file, ".");
d1322 1
a1322 1
         fprintf(file, "x");
d1324 1
a1324 1
         fprintf(file, "y");
d1326 1
a1326 1
         fprintf(file, "z");
d1328 1
a1328 1
         fprintf(file, "w");
d1330 1
a1330 4
   fprintf(file, ":%s", brw_reg_type_letters(inst->dst.type));

   if (inst->src[0].file != BAD_FILE)
      fprintf(file, ", ");
d1334 1
a1334 1
         fprintf(file, "-");
d1336 1
a1336 1
         fprintf(file, "|");
d1339 1
a1339 1
         fprintf(file, "vgrf%d", inst->src[i].reg);
d1342 1
a1342 1
         fprintf(file, "attr%d", inst->src[i].reg);
d1345 1
a1345 1
         fprintf(file, "u%d", inst->src[i].reg);
d1350 1
a1350 1
            fprintf(file, "%fF", inst->src[i].fixed_hw_reg.dw1.f);
d1353 1
a1353 1
            fprintf(file, "%dD", inst->src[i].fixed_hw_reg.dw1.d);
d1356 1
a1356 1
            fprintf(file, "%uU", inst->src[i].fixed_hw_reg.dw1.ud);
d1359 1
a1359 1
            fprintf(file, "???");
d1365 1
a1365 1
            fprintf(file, "-");
d1367 1
a1367 1
            fprintf(file, "|");
d1371 1
a1371 1
               fprintf(file, "null");
d1374 1
a1374 1
               fprintf(file, "a0.%d", inst->src[i].fixed_hw_reg.subnr);
d1377 1
a1377 1
               fprintf(file, "acc%d", inst->src[i].fixed_hw_reg.subnr);
d1380 1
a1380 1
               fprintf(file, "f%d.%d", inst->src[i].fixed_hw_reg.nr & 0xf,
d1384 1
a1384 1
               fprintf(file, "arf%d.%d", inst->src[i].fixed_hw_reg.nr & 0xf,
d1389 1
a1389 1
            fprintf(file, "hw_reg%d", inst->src[i].fixed_hw_reg.nr);
d1392 1
a1392 1
            fprintf(file, "+%d", inst->src[i].fixed_hw_reg.subnr);
d1394 1
a1394 1
            fprintf(file, "|");
d1397 1
a1397 1
         fprintf(file, "(null)");
d1400 1
a1400 1
         fprintf(file, "???");
d1404 2
a1405 5
      /* Don't print .0; and only VGRFs have reg_offsets and sizes */
      if (inst->src[i].reg_offset != 0 &&
          inst->src[i].file == GRF &&
          virtual_grf_sizes[inst->src[i].reg] != 1)
         fprintf(file, ".%d", inst->src[i].reg_offset);
d1409 1
a1409 1
         fprintf(file, ".");
d1411 1
a1411 1
            fprintf(file, "%s", chans[BRW_GET_SWZ(inst->src[i].swizzle, c)]);
d1416 1
a1416 1
         fprintf(file, "|");
d1419 1
a1419 1
         fprintf(file, ":%s", brw_reg_type_letters(inst->src[i].type));
d1423 1
a1423 1
         fprintf(file, ", ");
d1426 1
a1426 1
   fprintf(file, "\n");
d1456 3
a1458 1
   foreach_block_and_inst(block, vec4_instruction, inst, cfg) {
d1520 1
a1520 1
   if (vs_prog_data->uses_vertexid || vs_prog_data->uses_instanceid) {
d1549 1
a1549 1
   prog_data->base.dispatch_grf_start_reg = reg;
d1559 1
a1559 1
         reralloc(NULL, stage_prog_data->param, const gl_constant_value *, 4);
d1562 1
a1562 1
	 static gl_constant_value zero = { 0.0 };
d1574 1
a1574 2
   prog_data->base.curb_read_length =
      reg - prog_data->base.dispatch_grf_start_reg;
a1596 6
void
vec4_visitor::assign_binding_table_offsets()
{
   assign_common_binding_table_offsets(0);
}

a1604 2
                                0,
                                0,
d1696 1
a1696 1
   assign_binding_table_offsets();
a1714 2
   calculate_cfg();

a1736 26
   const char *stage_name = stage == MESA_SHADER_GEOMETRY ? "gs" : "vs";

#define OPT(pass, args...) do {                                        \
      pass_num++;                                                      \
      bool this_progress = pass(args);                                 \
                                                                       \
      if (unlikely(INTEL_DEBUG & DEBUG_OPTIMIZER) && this_progress) {  \
         char filename[64];                                            \
         snprintf(filename, 64, "%s-%04d-%02d-%02d-" #pass,            \
                  stage_name, shader_prog ? shader_prog->Name : 0, iteration, pass_num); \
                                                                       \
         backend_visitor::dump_instructions(filename);                 \
      }                                                                \
                                                                       \
      progress = progress || this_progress;                            \
   } while (false)


   if (unlikely(INTEL_DEBUG & DEBUG_OPTIMIZER)) {
      char filename[64];
      snprintf(filename, 64, "%s-%04d-00-start",
               stage_name, shader_prog ? shader_prog->Name : 0);

      backend_visitor::dump_instructions(filename);
   }

a1737 1
   int iteration = 0;
d1740 5
a1744 10
      iteration++;
      int pass_num = 0;

      OPT(opt_reduce_swizzle);
      OPT(dead_code_eliminate);
      OPT(dead_control_flow_eliminate, this);
      OPT(opt_copy_propagation);
      OPT(opt_cse);
      OPT(opt_algebraic);
      OPT(opt_register_coalesce);
d1816 1
a1816 1
      brw_dump_ir("vertex", prog, &shader->base, &c->vp->program.Base);
d1832 9
a1840 3
   vec4_generator g(brw, prog, &c->vp->program.Base, &prog_data->base,
                    mem_ctx, INTEL_DEBUG & DEBUG_VS);
   assembly = g.generate_assembly(v.cfg, final_assembly_size);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d94 1
a94 1
   this->imm.f = f;
d103 1
a103 1
   this->imm.u = u;
d112 1
a112 1
   this->imm.i = i;
a153 9
bool
src_reg::is_accumulator() const
{
   return file == HW_REG &&
          fixed_hw_reg.file == BRW_ARCHITECTURE_REGISTER_FILE &&
          fixed_hw_reg.nr == BRW_ARF_ACCUMULATOR;
}


a215 16
dst_reg::is_null() const
{
   return file == HW_REG &&
          fixed_hw_reg.file == BRW_ARCHITECTURE_REGISTER_FILE &&
          fixed_hw_reg.nr == BRW_ARF_NULL;
}

bool
dst_reg::is_accumulator() const
{
   return file == HW_REG &&
          fixed_hw_reg.file == BRW_ARCHITECTURE_REGISTER_FILE &&
          fixed_hw_reg.nr == BRW_ARF_ACCUMULATOR;
}

bool
d228 1
a228 1
vec4_visitor::can_do_source_mods(vec4_instruction *inst)
d230 1
a230 1
   if (brw->gen == 6 && inst->is_math())
d233 1
a233 1
   if (inst->is_send_from_grf())
d236 1
a236 1
   if (!inst->can_do_source_mods())
d277 1
d280 2
d298 1
a298 2
      assert(!"not reached");
      return inst->mlen;
d303 1
a303 1
src_reg::equals(src_reg *r)
d305 107
a411 11
   return (file == r->file &&
	   reg == r->reg &&
	   reg_offset == r->reg_offset &&
	   type == r->type &&
	   negate == r->negate &&
	   abs == r->abs &&
	   swizzle == r->swizzle &&
	   !reladdr && !r->reladdr &&
	   memcmp(&fixed_hw_reg, &r->fixed_hw_reg,
		  sizeof(fixed_hw_reg)) == 0 &&
	   imm.u == r->imm.u);
d429 1
a429 1
         inst->remove();
d468 1
a468 3
   foreach_list_safe(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

d519 3
a521 6
      for (exec_node *node = inst->prev, *prev = node->prev;
           prev != NULL && dead_channels != 0;
           node = prev, prev = prev->prev) {
         vec4_instruction *scan_inst = (vec4_instruction  *)node;

         if (scan_inst->is_control_flow())
d526 1
a526 1
               scan_inst->remove();
d556 7
a562 1
   if (progress)
d564 1
d579 1
a579 3
   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

d612 1
a612 3
   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

d665 1
a665 3
   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

a682 26
bool
src_reg::is_zero() const
{
   if (file != IMM)
      return false;

   if (type == BRW_REGISTER_TYPE_F) {
      return imm.f == 0.0;
   } else {
      return imm.i == 0;
   }
}

bool
src_reg::is_one() const
{
   if (file != IMM)
      return false;

   if (type == BRW_REGISTER_TYPE_F) {
      return imm.f == 1.0;
   } else {
      return imm.i == 1;
   }
}

d700 1
a700 3
   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

d724 1
a724 3
	       assert(!"not reached");
	       inst->src[0] = src_reg(0.0f);
	       break;
d734 11
d768 3
d785 1
a785 1
	 const float **values = &stage_prog_data->param[i];
d819 1
a819 3
   foreach_list_safe(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

d829 1
a829 1
	 emit_pull_constant_load(inst, temp, inst->src[i],
a865 2
   cfg_t cfg(&instructions);

d869 1
a869 4
   for (int i = 0; i < cfg.num_blocks; i++) {
      bblock_t *bblock = cfg.blocks[i];
      vec4_instruction *inst;

d873 1
a873 3
      for (inst = (vec4_instruction *)bblock->start;
           inst != (vec4_instruction *)bblock->end->next;
           inst = (vec4_instruction *)inst->next) {
d952 3
a954 3
vec4_instruction::can_reswizzle_dst(int dst_writemask,
                                    int swizzle,
                                    int swizzle_mask)
d962 2
a963 12
   switch (opcode) {
   case BRW_OPCODE_DP4:
   case BRW_OPCODE_DP3:
   case BRW_OPCODE_DP2:
      return true;
   default:
      /* Check if there happens to be no reswizzling required. */
      for (int c = 0; c < 4; c++) {
         int bit = 1 << BRW_GET_SWZ(swizzle, c);
         /* Skip components of the swizzle not used by the dst. */
         if (!(dst_writemask & (1 << c)))
            continue;
d965 1
a965 8
         /* We don't do the reswizzling yet, so just sanity check that we
          * don't have to.
          */
         if (bit != (1 << c))
            return false;
      }
      return true;
   }
d976 1
a976 1
vec4_instruction::reswizzle_dst(int dst_writemask, int swizzle)
d979 1
d981 5
a985 8
   switch (opcode) {
   case BRW_OPCODE_DP4:
   case BRW_OPCODE_DP3:
   case BRW_OPCODE_DP2:
      for (int c = 0; c < 4; c++) {
         int bit = 1 << BRW_GET_SWZ(swizzle, c);
         /* Skip components of the swizzle not used by the dst. */
         if (!(dst_writemask & (1 << c)))
d987 7
a993 5
         /* If we were populating this component, then populate the
          * corresponding channel of the new dst.
          */
         if (dst.writemask & bit)
            new_writemask |= (1 << c);
d995 1
a995 7
      dst.writemask = new_writemask;
      break;
   default:
      for (int c = 0; c < 4; c++) {
         /* Skip components of the swizzle not used by the dst. */
         if (!(dst_writemask & (1 << c)))
            continue;
d997 10
a1006 6
         /* We don't do the reswizzling yet, so just sanity check that we
          * don't have to.
          */
         assert((1 << BRW_GET_SWZ(swizzle, c)) == (1 << c));
      }
      break;
d1008 1
d1024 1
a1024 3
   foreach_list_safe(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

d1073 5
a1077 4
      vec4_instruction *scan_inst;
      for (scan_inst = (vec4_instruction *)inst->prev;
	   scan_inst->prev != NULL;
	   scan_inst = (vec4_instruction *)scan_inst->prev) {
d1098 3
a1100 3
            if (!scan_inst->can_reswizzle_dst(inst->dst.writemask,
                                              inst->src[0].swizzle,
                                              swizzle_mask)) {
a1118 10
	 /* We don't handle flow control here.  Most computation of values
	  * that could be coalesced happens just before their use.
	  */
	 if (scan_inst->opcode == BRW_OPCODE_DO ||
	     scan_inst->opcode == BRW_OPCODE_WHILE ||
	     scan_inst->opcode == BRW_OPCODE_ELSE ||
	     scan_inst->opcode == BRW_OPCODE_ENDIF) {
	    break;
	 }

d1171 1
a1171 1

d1176 2
a1177 2
               scan_inst->reswizzle_dst(inst->dst.writemask,
                                        inst->src[0].swizzle);
d1185 1
a1185 1
	 inst->remove();
d1225 1
a1225 3
   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

d1254 1
a1254 3
   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

d1276 6
d1285 1
a1285 1
      fprintf(stderr, "(%cf0) ",
d1289 1
a1289 1
   fprintf(stderr, "%s", brw_instruction_name(inst->opcode));
d1291 1
a1291 1
      fprintf(stderr, "%s", conditional_modifier[inst->conditional_mod]);
d1293 1
a1293 1
   fprintf(stderr, " ");
d1297 1
a1297 1
      fprintf(stderr, "vgrf%d.%d", inst->dst.reg, inst->dst.reg_offset);
d1300 1
a1300 1
      fprintf(stderr, "m%d", inst->dst.reg);
d1306 1
a1306 1
            fprintf(stderr, "null");
d1309 1
a1309 1
            fprintf(stderr, "a0.%d", inst->dst.fixed_hw_reg.subnr);
d1312 1
a1312 1
            fprintf(stderr, "acc%d", inst->dst.fixed_hw_reg.subnr);
d1315 1
a1315 1
            fprintf(stderr, "f%d.%d", inst->dst.fixed_hw_reg.nr & 0xf,
d1319 1
a1319 1
            fprintf(stderr, "arf%d.%d", inst->dst.fixed_hw_reg.nr & 0xf,
d1324 1
a1324 1
         fprintf(stderr, "hw_reg%d", inst->dst.fixed_hw_reg.nr);
d1327 1
a1327 1
         fprintf(stderr, "+%d", inst->dst.fixed_hw_reg.subnr);
d1330 1
a1330 1
      fprintf(stderr, "(null)");
d1333 1
a1333 1
      fprintf(stderr, "???");
d1337 1
a1337 1
      fprintf(stderr, ".");
d1339 1
a1339 1
         fprintf(stderr, "x");
d1341 1
a1341 1
         fprintf(stderr, "y");
d1343 1
a1343 1
         fprintf(stderr, "z");
d1345 1
a1345 1
         fprintf(stderr, "w");
d1347 4
a1350 1
   fprintf(stderr, ":%s, ", brw_reg_type_letters(inst->dst.type));
d1354 1
a1354 1
         fprintf(stderr, "-");
d1356 1
a1356 1
         fprintf(stderr, "|");
d1359 1
a1359 1
         fprintf(stderr, "vgrf%d", inst->src[i].reg);
d1362 1
a1362 1
         fprintf(stderr, "attr%d", inst->src[i].reg);
d1365 1
a1365 1
         fprintf(stderr, "u%d", inst->src[i].reg);
d1370 1
a1370 1
            fprintf(stderr, "%fF", inst->src[i].imm.f);
d1373 1
a1373 1
            fprintf(stderr, "%dD", inst->src[i].imm.i);
d1376 1
a1376 1
            fprintf(stderr, "%uU", inst->src[i].imm.u);
d1379 1
a1379 1
            fprintf(stderr, "???");
d1385 1
a1385 1
            fprintf(stderr, "-");
d1387 1
a1387 1
            fprintf(stderr, "|");
d1391 1
a1391 1
               fprintf(stderr, "null");
d1394 1
a1394 1
               fprintf(stderr, "a0.%d", inst->src[i].fixed_hw_reg.subnr);
d1397 1
a1397 1
               fprintf(stderr, "acc%d", inst->src[i].fixed_hw_reg.subnr);
d1400 1
a1400 1
               fprintf(stderr, "f%d.%d", inst->src[i].fixed_hw_reg.nr & 0xf,
d1404 1
a1404 1
               fprintf(stderr, "arf%d.%d", inst->src[i].fixed_hw_reg.nr & 0xf,
d1409 1
a1409 1
            fprintf(stderr, "hw_reg%d", inst->src[i].fixed_hw_reg.nr);
d1412 1
a1412 1
            fprintf(stderr, "+%d", inst->src[i].fixed_hw_reg.subnr);
d1414 1
a1414 1
            fprintf(stderr, "|");
d1417 1
a1417 1
         fprintf(stderr, "(null)");
d1420 1
a1420 1
         fprintf(stderr, "???");
d1424 5
a1428 2
      if (virtual_grf_sizes[inst->src[i].reg] != 1)
         fprintf(stderr, ".%d", inst->src[i].reg_offset);
d1432 1
a1432 1
         fprintf(stderr, ".");
d1434 1
a1434 1
            fprintf(stderr, "%s", chans[BRW_GET_SWZ(inst->src[i].swizzle, c)]);
d1439 1
a1439 1
         fprintf(stderr, "|");
d1442 1
a1442 1
         fprintf(stderr, ":%s", brw_reg_type_letters(inst->src[i].type));
d1446 1
a1446 1
         fprintf(stderr, ", ");
d1449 1
a1449 1
   fprintf(stderr, "\n");
d1479 1
a1479 3
   foreach_list(node, &this->instructions) {
      vec4_instruction *inst = (vec4_instruction *)node;

d1541 1
a1541 1
   if (vs_prog_data->uses_vertexid) {
d1570 1
a1570 1
   prog_data->dispatch_grf_start_reg = reg;
d1580 1
a1580 1
         reralloc(NULL, stage_prog_data->param, const float *, 4);
d1583 1
a1583 1
	 static float zero = 0.0;
d1595 2
a1596 1
   prog_data->curb_read_length = reg - prog_data->dispatch_grf_start_reg;
d1619 6
d1633 2
d1726 1
a1726 1
   assign_common_binding_table_offsets(0);
d1745 2
d1769 26
d1796 1
d1799 10
a1808 5
      progress = dead_code_eliminate() || progress;
      progress = dead_control_flow_eliminate(this) || progress;
      progress = opt_copy_propagation() || progress;
      progress = opt_algebraic() || progress;
      progress = opt_register_coalesce() || progress;
d1880 1
a1880 1
      brw_dump_ir(brw, "vertex", prog, &shader->base, &c->vp->program.Base);
d1896 3
a1898 9
   if (brw->gen >= 8) {
      gen8_vec4_generator g(brw, prog, &c->vp->program.Base, &prog_data->base,
                            mem_ctx, INTEL_DEBUG & DEBUG_VS);
      assembly = g.generate_assembly(&v.instructions, final_assembly_size);
   } else {
      vec4_generator g(brw, prog, &c->vp->program.Base, &prog_data->base,
                       mem_ctx, INTEL_DEBUG & DEBUG_VS);
      assembly = g.generate_assembly(&v.instructions, final_assembly_size);
   }
@


