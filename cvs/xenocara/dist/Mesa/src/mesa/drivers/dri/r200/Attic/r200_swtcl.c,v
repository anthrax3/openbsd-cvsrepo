head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.8;
commitid	4ry2gvZGMXkCUD2n;

1.8
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.7;
commitid	mcxB0JvoI9gTDYXU;

1.7
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.14.04.58;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.23;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.17;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.53.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.53.20;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.25;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.29.18;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.40;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.16.01;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.55;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.12.08;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.49.15;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.

The Weather Channel (TM) funded Tungsten Graphics to develop the
initial release of the Radeon 8500 driver under the XFree86 license.
This notice must be preserved.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial
portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Keith Whitwell <keithw@@vmware.com>
 */

#include "main/glheader.h"
#include "main/mtypes.h"
#include "main/colormac.h"
#include "main/enums.h"
#include "main/image.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/simple_list.h"

#include "swrast/s_context.h"
#include "swrast/s_fog.h"
#include "swrast_setup/swrast_setup.h"
#include "tnl/tnl.h"
#include "tnl/t_context.h"
#include "tnl/t_pipeline.h"

#include "r200_context.h"
#include "r200_ioctl.h"
#include "r200_state.h"
#include "r200_swtcl.h"
#include "r200_tcl.h"


/***********************************************************************
 *                         Initialization
 ***********************************************************************/

#define EMIT_ATTR( ATTR, STYLE, F0 )					\
do {									\
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].attrib = (ATTR);	\
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].format = (STYLE);	\
   rmesa->radeon.swtcl.vertex_attr_count++;					\
   fmt_0 |= F0;								\
} while (0)

#define EMIT_PAD( N )							\
do {									\
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].attrib = 0;		\
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].format = EMIT_PAD;	\
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].offset = (N);		\
   rmesa->radeon.swtcl.vertex_attr_count++;					\
} while (0)

static void r200SetVertexFormat( struct gl_context *ctx )
{
   r200ContextPtr rmesa = R200_CONTEXT( ctx );
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct vertex_buffer *VB = &tnl->vb;
   GLbitfield64 index_bitset = tnl->render_inputs_bitset;
   int fmt_0 = 0;
   int fmt_1 = 0;
   int offset = 0;

   /* Important:
    */
   if ( VB->NdcPtr != NULL ) {
      VB->AttribPtr[VERT_ATTRIB_POS] = VB->NdcPtr;
   }
   else {
      VB->AttribPtr[VERT_ATTRIB_POS] = VB->ClipPtr;
   }

   assert( VB->AttribPtr[VERT_ATTRIB_POS] != NULL );
   rmesa->radeon.swtcl.vertex_attr_count = 0;

   /* EMIT_ATTR's must be in order as they tell t_vertex.c how to
    * build up a hardware vertex.
    */
   if ( !rmesa->swtcl.needproj ||
        (index_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_TEX0, _TNL_NUM_TEX)) ) {
      /* need w coord for projected textures */
      EMIT_ATTR( _TNL_ATTRIB_POS, EMIT_4F, R200_VTX_XY | R200_VTX_Z0 | R200_VTX_W0 );
      offset = 4;
   }
   else {
      EMIT_ATTR( _TNL_ATTRIB_POS, EMIT_3F, R200_VTX_XY | R200_VTX_Z0 );
      offset = 3;
   }

   if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_POINTSIZE)) {
      EMIT_ATTR( _TNL_ATTRIB_POINTSIZE, EMIT_1F, R200_VTX_POINT_SIZE );
      offset += 1;
   }

   rmesa->swtcl.coloroffset = offset;
#if MESA_LITTLE_ENDIAN
   EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_4UB_4F_RGBA, (R200_VTX_PK_RGBA << R200_VTX_COLOR_0_SHIFT) );
#else
   EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_4UB_4F_ABGR, (R200_VTX_PK_RGBA << R200_VTX_COLOR_0_SHIFT) );
#endif
   offset += 1;

   rmesa->swtcl.specoffset = 0;
   if (index_bitset &
       (BITFIELD64_BIT(_TNL_ATTRIB_COLOR1) | BITFIELD64_BIT(_TNL_ATTRIB_FOG))) {

#if MESA_LITTLE_ENDIAN
      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_COLOR1)) {
	 rmesa->swtcl.specoffset = offset;
	 EMIT_ATTR( _TNL_ATTRIB_COLOR1, EMIT_3UB_3F_RGB, (R200_VTX_PK_RGBA << R200_VTX_COLOR_1_SHIFT) );
      }
      else {
	 EMIT_PAD( 3 );
      }

      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_FOG)) {
	 EMIT_ATTR( _TNL_ATTRIB_FOG, EMIT_1UB_1F, (R200_VTX_PK_RGBA << R200_VTX_COLOR_1_SHIFT) );
      }
      else {
	 EMIT_PAD( 1 );
      }
#else
      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_FOG)) {
	 EMIT_ATTR( _TNL_ATTRIB_FOG, EMIT_1UB_1F, (R200_VTX_PK_RGBA << R200_VTX_COLOR_1_SHIFT) );
      }
      else {
	 EMIT_PAD( 1 );
      }

      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_COLOR1)) {
	 rmesa->swtcl.specoffset = offset;
	 EMIT_ATTR( _TNL_ATTRIB_COLOR1, EMIT_3UB_3F_BGR, (R200_VTX_PK_RGBA << R200_VTX_COLOR_1_SHIFT) );
      }
      else {
	 EMIT_PAD( 3 );
      }
#endif
   }

   if (index_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_TEX0, _TNL_NUM_TEX)) {
      int i;

      for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
	 if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_TEX(i))) {
	    GLuint sz = VB->AttribPtr[_TNL_ATTRIB_TEX0 + i]->size;

	    fmt_1 |= sz << (3 * i);
	    EMIT_ATTR( _TNL_ATTRIB_TEX0+i, EMIT_1F + sz - 1, 0 );
	 }
      }
   }

   if ( (rmesa->hw.ctx.cmd[CTX_PP_FOG_COLOR] & R200_FOG_USE_MASK)
      != R200_FOG_USE_SPEC_ALPHA ) {
      R200_STATECHANGE( rmesa, ctx );
      rmesa->hw.ctx.cmd[CTX_PP_FOG_COLOR] &= ~R200_FOG_USE_MASK;
      rmesa->hw.ctx.cmd[CTX_PP_FOG_COLOR] |= R200_FOG_USE_SPEC_ALPHA;
   }

   if (rmesa->radeon.tnl_index_bitset != index_bitset ||
	(rmesa->hw.vtx.cmd[VTX_VTXFMT_0] != fmt_0) ||
	(rmesa->hw.vtx.cmd[VTX_VTXFMT_1] != fmt_1) ) {
      R200_NEWPRIM(rmesa);
      R200_STATECHANGE( rmesa, vtx );
      rmesa->hw.vtx.cmd[VTX_VTXFMT_0] = fmt_0;
      rmesa->hw.vtx.cmd[VTX_VTXFMT_1] = fmt_1;

      rmesa->radeon.swtcl.vertex_size =
	  _tnl_install_attrs( ctx,
			      rmesa->radeon.swtcl.vertex_attrs,
			      rmesa->radeon.swtcl.vertex_attr_count,
			      NULL, 0 );
      rmesa->radeon.swtcl.vertex_size /= 4;
      rmesa->radeon.tnl_index_bitset = index_bitset;
   }
}

static void r200_predict_emit_size( r200ContextPtr rmesa )
{
   if (RADEON_DEBUG & RADEON_VERTS)
      fprintf(stderr, "%s\n", __func__);
   const int vertex_array_size = 7;
   const int prim_size = 3;
   if (!rmesa->radeon.swtcl.emit_prediction) {
      const int state_size = radeonCountStateEmitSize(&rmesa->radeon);
      if (rcommonEnsureCmdBufSpace(&rmesa->radeon,
	       state_size +
	       vertex_array_size + prim_size,
	       __FUNCTION__))
	 rmesa->radeon.swtcl.emit_prediction = radeonCountStateEmitSize(&rmesa->radeon);
      else
	 rmesa->radeon.swtcl.emit_prediction = state_size;
      rmesa->radeon.swtcl.emit_prediction += vertex_array_size + prim_size
	 + rmesa->radeon.cmdbuf.cs->cdw;
   }
}


static void r200RenderStart( struct gl_context *ctx )
{
   r200SetVertexFormat( ctx );
   if (RADEON_DEBUG & RADEON_VERTS)
      fprintf(stderr, "%s\n", __func__);
}


/**
 * Set vertex state for SW TCL.  The primary purpose of this function is to
 * determine in advance whether or not the hardware can / should do the
 * projection divide or Mesa should do it.
 */
void r200ChooseVertexState( struct gl_context *ctx )
{
   r200ContextPtr rmesa = R200_CONTEXT( ctx );
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   GLuint vte;
   GLuint vap;
   GLboolean unfilled = (ctx->Polygon.FrontMode != GL_FILL ||
                         ctx->Polygon.BackMode != GL_FILL);
   GLboolean twosided = ctx->Light.Enabled && ctx->Light.Model.TwoSide;

   /* We must ensure that we don't do _tnl_need_projected_coords while in a
    * rasterization fallback.  As this function will be called again when we
    * leave a rasterization fallback, we can just skip it for now.
    */
   if (rmesa->radeon.Fallback != 0)
      return;

   vte = rmesa->hw.vte.cmd[VTE_SE_VTE_CNTL];
   vap = rmesa->hw.vap.cmd[VAP_SE_VAP_CNTL];

   /* HW perspective divide is a win, but tiny vertex formats are a
    * bigger one.
    */
   if ((0 == (tnl->render_inputs_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_TEX0, _TNL_NUM_TEX)))
       || twosided
       || unfilled) {
      rmesa->swtcl.needproj = GL_TRUE;
      vte |= R200_VTX_XY_FMT | R200_VTX_Z_FMT;
      vte &= ~R200_VTX_W0_FMT;
      if (tnl->render_inputs_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_TEX0, _TNL_NUM_TEX)) {
	 vap &= ~R200_VAP_FORCE_W_TO_ONE;
      }
      else {
	 vap |= R200_VAP_FORCE_W_TO_ONE;
      }
   }
   else {
      rmesa->swtcl.needproj = GL_FALSE;
      vte &= ~(R200_VTX_XY_FMT | R200_VTX_Z_FMT);
      vte |= R200_VTX_W0_FMT;
      vap &= ~R200_VAP_FORCE_W_TO_ONE;
   }

   _tnl_need_projected_coords( ctx, rmesa->swtcl.needproj );

   if (vte != rmesa->hw.vte.cmd[VTE_SE_VTE_CNTL]) {
      R200_STATECHANGE( rmesa, vte );
      rmesa->hw.vte.cmd[VTE_SE_VTE_CNTL] = vte;
   }

   if (vap != rmesa->hw.vap.cmd[VAP_SE_VAP_CNTL]) {
      R200_STATECHANGE( rmesa, vap );
      rmesa->hw.vap.cmd[VAP_SE_VAP_CNTL] = vap;
   }
}

void r200_swtcl_flush(struct gl_context *ctx, uint32_t current_offset)
{
   r200ContextPtr rmesa = R200_CONTEXT(ctx);
   if (RADEON_DEBUG & RADEON_VERTS)
      fprintf(stderr, "%s\n", __func__);


   radeonEmitState(&rmesa->radeon);
   r200EmitVertexAOS( rmesa,
		      rmesa->radeon.swtcl.vertex_size,
		      rmesa->radeon.swtcl.bo,
		      current_offset);


   r200EmitVbufPrim( rmesa,
		     rmesa->radeon.swtcl.hw_primitive,
		     rmesa->radeon.swtcl.numverts);
   if ( rmesa->radeon.swtcl.emit_prediction < rmesa->radeon.cmdbuf.cs->cdw )
      WARN_ONCE("Rendering was %d commands larger than predicted size."
	    " We might overflow  command buffer.\n",
	    rmesa->radeon.cmdbuf.cs->cdw - rmesa->radeon.swtcl.emit_prediction );

   rmesa->radeon.swtcl.emit_prediction = 0;

}

/**************************************************************************/


static INLINE GLuint reduced_hw_prim( struct gl_context *ctx, GLuint prim)
{
   switch (prim) {
   case GL_POINTS:
      return ((!ctx->Point.SmoothFlag) ?
	 R200_VF_PRIM_POINT_SPRITES : R200_VF_PRIM_POINTS);
   case GL_LINES:
   /* fallthrough */
   case GL_LINE_LOOP:
   /* fallthrough */
   case GL_LINE_STRIP:
      return R200_VF_PRIM_LINES;
   default:
   /* all others reduced to triangles */
      return R200_VF_PRIM_TRIANGLES;
   }
}


static void r200RasterPrimitive( struct gl_context *ctx, GLuint hwprim );
static void r200RenderPrimitive( struct gl_context *ctx, GLenum prim );
static void r200ResetLineStipple( struct gl_context *ctx );

/***********************************************************************
 *                    Emit primitives as inline vertices               *
 ***********************************************************************/

#define HAVE_POINTS      1
#define HAVE_LINES       1
#define HAVE_LINE_STRIPS 1
#define HAVE_TRIANGLES   1
#define HAVE_TRI_STRIPS  1
#define HAVE_TRI_STRIP_1 0
#define HAVE_TRI_FANS    1
#define HAVE_QUADS       0
#define HAVE_QUAD_STRIPS 0
#define HAVE_POLYGONS    1
#define HAVE_ELTS        0

static void* r200_alloc_verts( r200ContextPtr rmesa, GLuint n, GLuint size)
{
   void *rv;
   do {
      r200_predict_emit_size( rmesa );
      rv = rcommonAllocDmaLowVerts( &rmesa->radeon, n, size * 4 );
   } while(!rv);
   return rv;
}

#undef LOCAL_VARS
#undef ALLOC_VERTS
#define CTX_ARG r200ContextPtr rmesa
#define GET_VERTEX_DWORDS() rmesa->radeon.swtcl.vertex_size
#define ALLOC_VERTS( n, size ) r200_alloc_verts(rmesa, n, size)
#define LOCAL_VARS						\
   r200ContextPtr rmesa = R200_CONTEXT(ctx);		\
   const char *r200verts = (char *)rmesa->radeon.swtcl.verts;
#define VERT(x) (radeonVertex *)(r200verts + ((x) * vertsize * sizeof(int)))
#define VERTEX radeonVertex
#define DO_DEBUG_VERTS (1 && (R200_DEBUG & RADEON_VERTS))

#undef TAG
#define TAG(x) r200_##x
#include "tnl_dd/t_dd_triemit.h"


/***********************************************************************
 *          Macros for t_dd_tritmp.h to draw basic primitives          *
 ***********************************************************************/

#define QUAD( a, b, c, d ) r200_quad( rmesa, a, b, c, d )
#define TRI( a, b, c )     r200_triangle( rmesa, a, b, c )
#define LINE( a, b )       r200_line( rmesa, a, b )
#define POINT( a )         r200_point( rmesa, a )

/***********************************************************************
 *              Build render functions from dd templates               *
 ***********************************************************************/

#define R200_TWOSIDE_BIT	0x01
#define R200_UNFILLED_BIT	0x02
#define R200_MAX_TRIFUNC	0x04


static struct {
   tnl_points_func	        points;
   tnl_line_func		line;
   tnl_triangle_func	triangle;
   tnl_quad_func		quad;
} rast_tab[R200_MAX_TRIFUNC];


#define DO_FALLBACK  0
#define DO_UNFILLED (IND & R200_UNFILLED_BIT)
#define DO_TWOSIDE  (IND & R200_TWOSIDE_BIT)
#define DO_FLAT      0
#define DO_OFFSET     0
#define DO_TRI       1
#define DO_QUAD      1
#define DO_LINE      1
#define DO_POINTS    1
#define DO_FULL_QUAD 1

#define HAVE_SPEC   1
#define HAVE_BACK_COLORS  0
#define HAVE_HW_FLATSHADE 1
#define TAB rast_tab

#define DEPTH_SCALE 1.0
#define UNFILLED_TRI unfilled_tri
#define UNFILLED_QUAD unfilled_quad
#define VERT_X(_v) _v->v.x
#define VERT_Y(_v) _v->v.y
#define VERT_Z(_v) _v->v.z
#define AREA_IS_CCW( a ) (a < 0)
#define GET_VERTEX(e) (rmesa->radeon.swtcl.verts + (e*rmesa->radeon.swtcl.vertex_size*sizeof(int)))

#define VERT_SET_RGBA( v, c )  					\
do {								\
   radeon_color_t *color = (radeon_color_t *)&((v)->ui[coloroffset]);	\
   UNCLAMPED_FLOAT_TO_UBYTE(color->red, (c)[0]);		\
   UNCLAMPED_FLOAT_TO_UBYTE(color->green, (c)[1]);		\
   UNCLAMPED_FLOAT_TO_UBYTE(color->blue, (c)[2]);		\
   UNCLAMPED_FLOAT_TO_UBYTE(color->alpha, (c)[3]);		\
} while (0)

#define VERT_COPY_RGBA( v0, v1 ) v0->ui[coloroffset] = v1->ui[coloroffset]

#define VERT_SET_SPEC( v, c )					\
do {								\
   if (specoffset) {						\
      radeon_color_t *spec = (radeon_color_t *)&((v)->ui[specoffset]);	\
      UNCLAMPED_FLOAT_TO_UBYTE(spec->red, (c)[0]);	\
      UNCLAMPED_FLOAT_TO_UBYTE(spec->green, (c)[1]);	\
      UNCLAMPED_FLOAT_TO_UBYTE(spec->blue, (c)[2]);	\
   }								\
} while (0)
#define VERT_COPY_SPEC( v0, v1 )			\
do {							\
   if (specoffset) {					\
      radeon_color_t *spec0 = (radeon_color_t *)&((v0)->ui[specoffset]);	\
      radeon_color_t *spec1 = (radeon_color_t *)&((v1)->ui[specoffset]);	\
      spec0->red   = spec1->red;	\
      spec0->green = spec1->green;	\
      spec0->blue  = spec1->blue; 	\
   }							\
} while (0)

/* These don't need LE32_TO_CPU() as they used to save and restore
 * colors which are already in the correct format.
 */
#define VERT_SAVE_RGBA( idx )    color[idx] = v[idx]->ui[coloroffset]
#define VERT_RESTORE_RGBA( idx ) v[idx]->ui[coloroffset] = color[idx]
#define VERT_SAVE_SPEC( idx )    if (specoffset) spec[idx] = v[idx]->ui[specoffset]
#define VERT_RESTORE_SPEC( idx ) if (specoffset) v[idx]->ui[specoffset] = spec[idx]

#undef LOCAL_VARS
#undef TAG
#undef INIT

#define LOCAL_VARS(n)							\
   r200ContextPtr rmesa = R200_CONTEXT(ctx);			\
   GLuint color[n] = {0}, spec[n] = {0};						\
   GLuint coloroffset = rmesa->swtcl.coloroffset;	\
   GLuint specoffset = rmesa->swtcl.specoffset;			\
   (void) color; (void) spec; (void) coloroffset; (void) specoffset;

/***********************************************************************
 *                Helpers for rendering unfilled primitives            *
 ***********************************************************************/

#define RASTERIZE(x) r200RasterPrimitive( ctx, reduced_hw_prim(ctx, x) )
#define RENDER_PRIMITIVE rmesa->radeon.swtcl.render_primitive
#undef TAG
#define TAG(x) x
#include "tnl_dd/t_dd_unfilled.h"
#undef IND


/***********************************************************************
 *                      Generate GL render functions                   *
 ***********************************************************************/


#define IND (0)
#define TAG(x) x
#include "tnl_dd/t_dd_tritmp.h"

#define IND (R200_TWOSIDE_BIT)
#define TAG(x) x##_twoside
#include "tnl_dd/t_dd_tritmp.h"

#define IND (R200_UNFILLED_BIT)
#define TAG(x) x##_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (R200_TWOSIDE_BIT|R200_UNFILLED_BIT)
#define TAG(x) x##_twoside_unfilled
#include "tnl_dd/t_dd_tritmp.h"


static void init_rast_tab( void )
{
   init();
   init_twoside();
   init_unfilled();
   init_twoside_unfilled();
}

/**********************************************************************/
/*               Render unclipped begin/end objects                   */
/**********************************************************************/

#define RENDER_POINTS( start, count )		\
   for ( ; start < count ; start++)		\
      r200_point( rmesa, VERT(start) )
#define RENDER_LINE( v0, v1 ) \
   r200_line( rmesa, VERT(v0), VERT(v1) )
#define RENDER_TRI( v0, v1, v2 )  \
   r200_triangle( rmesa, VERT(v0), VERT(v1), VERT(v2) )
#define RENDER_QUAD( v0, v1, v2, v3 ) \
   r200_quad( rmesa, VERT(v0), VERT(v1), VERT(v2), VERT(v3) )
#define INIT(x) do {					\
   r200RenderPrimitive( ctx, x );			\
} while (0)
#undef LOCAL_VARS
#define LOCAL_VARS						\
   r200ContextPtr rmesa = R200_CONTEXT(ctx);		\
   const GLuint vertsize = rmesa->radeon.swtcl.vertex_size;		\
   const char *r200verts = (char *)rmesa->radeon.swtcl.verts;		\
   const GLuint * const elt = TNL_CONTEXT(ctx)->vb.Elts;	\
   const GLboolean stipple = ctx->Line.StippleFlag;		\
   (void) elt; (void) stipple;
#define RESET_STIPPLE	if ( stipple ) r200ResetLineStipple( ctx );
#define RESET_OCCLUSION
#define PRESERVE_VB_DEFS
#define ELT(x) (x)
#define TAG(x) r200_##x##_verts
#include "tnl/t_vb_rendertmp.h"
#undef ELT
#undef TAG
#define TAG(x) r200_##x##_elts
#define ELT(x) elt[x]
#include "tnl/t_vb_rendertmp.h"



/**********************************************************************/
/*                    Choose render functions                         */
/**********************************************************************/

void r200ChooseRenderState( struct gl_context *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   r200ContextPtr rmesa = R200_CONTEXT(ctx);
   GLuint index = 0;
   GLboolean unfilled = (ctx->Polygon.FrontMode != GL_FILL ||
                         ctx->Polygon.BackMode != GL_FILL);
   GLboolean twosided = ctx->Light.Enabled && ctx->Light.Model.TwoSide;

   if (!rmesa->radeon.TclFallback || rmesa->radeon.Fallback)
      return;

   if (twosided)
      index |= R200_TWOSIDE_BIT;
   if (unfilled)
      index |= R200_UNFILLED_BIT;

   if (index != rmesa->radeon.swtcl.RenderIndex) {
      tnl->Driver.Render.Points = rast_tab[index].points;
      tnl->Driver.Render.Line = rast_tab[index].line;
      tnl->Driver.Render.ClippedLine = rast_tab[index].line;
      tnl->Driver.Render.Triangle = rast_tab[index].triangle;
      tnl->Driver.Render.Quad = rast_tab[index].quad;

      if (index == 0) {
	 tnl->Driver.Render.PrimTabVerts = r200_render_tab_verts;
	 tnl->Driver.Render.PrimTabElts = r200_render_tab_elts;
	 tnl->Driver.Render.ClippedPolygon = r200_fast_clipped_poly;
      } else {
	 tnl->Driver.Render.PrimTabVerts = _tnl_render_tab_verts;
	 tnl->Driver.Render.PrimTabElts = _tnl_render_tab_elts;
	 tnl->Driver.Render.ClippedPolygon = _tnl_RenderClippedPolygon;
      }

      rmesa->radeon.swtcl.RenderIndex = index;
   }
}


/**********************************************************************/
/*                 High level hooks for t_vb_render.c                 */
/**********************************************************************/


static void r200RasterPrimitive( struct gl_context *ctx, GLuint hwprim )
{
   r200ContextPtr rmesa = R200_CONTEXT(ctx);

   radeon_prepare_render(&rmesa->radeon);
   if (rmesa->radeon.NewGLState)
      r200ValidateState( ctx );


   if (rmesa->radeon.swtcl.hw_primitive != hwprim) {
      /* need to disable perspective-correct texturing for point sprites */
      if ((hwprim & 0xf) == R200_VF_PRIM_POINT_SPRITES && ctx->Point.PointSprite) {
	 if (rmesa->hw.set.cmd[SET_RE_CNTL] & R200_PERSPECTIVE_ENABLE) {
	    R200_STATECHANGE( rmesa, set );
	    rmesa->hw.set.cmd[SET_RE_CNTL] &= ~R200_PERSPECTIVE_ENABLE;
	 }
      }
      else if (!(rmesa->hw.set.cmd[SET_RE_CNTL] & R200_PERSPECTIVE_ENABLE)) {
	 R200_STATECHANGE( rmesa, set );
	 rmesa->hw.set.cmd[SET_RE_CNTL] |= R200_PERSPECTIVE_ENABLE;
      }
      R200_NEWPRIM( rmesa );
      rmesa->radeon.swtcl.hw_primitive = hwprim;
   }
}

static void r200RenderPrimitive( struct gl_context *ctx, GLenum prim )
{
   r200ContextPtr rmesa = R200_CONTEXT(ctx);
   GLboolean unfilled = (ctx->Polygon.FrontMode != GL_FILL ||
                         ctx->Polygon.BackMode != GL_FILL);

   rmesa->radeon.swtcl.render_primitive = prim;
   if (prim < GL_TRIANGLES || !unfilled)
      r200RasterPrimitive( ctx, reduced_hw_prim(ctx, prim) );
}

static void r200RenderFinish( struct gl_context *ctx )
{
}

static void r200ResetLineStipple( struct gl_context *ctx )
{
   r200ContextPtr rmesa = R200_CONTEXT(ctx);
   R200_STATECHANGE( rmesa, lin );
}


/**********************************************************************/
/*           Transition to/from hardware rasterization.               */
/**********************************************************************/

static const char * const fallbackStrings[] = {
   "Texture mode",
   "glDrawBuffer(GL_FRONT_AND_BACK)",
   "glEnable(GL_STENCIL) without hw stencil buffer",
   "glRenderMode(selection or feedback)",
   "R200_NO_RAST",
   "Mixing GL_CLAMP_TO_BORDER and GL_CLAMP (or GL_MIRROR_CLAMP_ATI)"
};


static const char *getFallbackString(GLuint bit)
{
   int i = 0;
   while (bit > 1) {
      i++;
      bit >>= 1;
   }
   return fallbackStrings[i];
}


void r200Fallback( struct gl_context *ctx, GLuint bit, GLboolean mode )
{
   r200ContextPtr rmesa = R200_CONTEXT(ctx);
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   GLuint oldfallback = rmesa->radeon.Fallback;

   if (mode) {
      rmesa->radeon.Fallback |= bit;
      if (oldfallback == 0) {
	 radeon_firevertices(&rmesa->radeon);
	 TCL_FALLBACK( ctx, R200_TCL_FALLBACK_RASTER, GL_TRUE );
	 _swsetup_Wakeup( ctx );
	 rmesa->radeon.swtcl.RenderIndex = ~0;
         if (R200_DEBUG & RADEON_FALLBACKS) {
            fprintf(stderr, "R200 begin rasterization fallback: 0x%x %s\n",
                    bit, getFallbackString(bit));
         }
      }
   }
   else {
      rmesa->radeon.Fallback &= ~bit;
      if (oldfallback == bit) {

	 _swrast_flush( ctx );
	 tnl->Driver.Render.Start = r200RenderStart;
	 tnl->Driver.Render.PrimitiveNotify = r200RenderPrimitive;
	 tnl->Driver.Render.Finish = r200RenderFinish;

	 tnl->Driver.Render.BuildVertices = _tnl_build_vertices;
	 tnl->Driver.Render.CopyPV = _tnl_copy_pv;
	 tnl->Driver.Render.Interp = _tnl_interp;

	 tnl->Driver.Render.ResetLineStipple = r200ResetLineStipple;
	 TCL_FALLBACK( ctx, R200_TCL_FALLBACK_RASTER, GL_FALSE );
	 if (rmesa->radeon.TclFallback) {
	    /* These are already done if rmesa->radeon.TclFallback goes to
	     * zero above. But not if it doesn't (R200_NO_TCL for
	     * example?)
	     */
	    _tnl_invalidate_vertex_state( ctx, ~0 );
	    _tnl_invalidate_vertices( ctx, ~0 );
	    rmesa->radeon.tnl_index_bitset = 0;
	    r200ChooseVertexState( ctx );
	    r200ChooseRenderState( ctx );
	 }
         if (R200_DEBUG & RADEON_FALLBACKS) {
            fprintf(stderr, "R200 end rasterization fallback: 0x%x %s\n",
                    bit, getFallbackString(bit));
         }
      }
   }
}




/**
 * Cope with depth operations by drawing individual pixels as points.
 *
 * \todo
 * The way the vertex state is set in this routine is hokey.  It seems to
 * work, but it's very hackish.  This whole routine is pretty hackish.  If
 * the bitmap is small enough, it seems like it would be faster to copy it
 * to AGP memory and use it as a non-power-of-two texture (i.e.,
 * NV_texture_rectangle).
 */
void
r200PointsBitmap( struct gl_context *ctx, GLint px, GLint py,
		  GLsizei width, GLsizei height,
		  const struct gl_pixelstore_attrib *unpack,
		  const GLubyte *bitmap )
{
   r200ContextPtr rmesa = R200_CONTEXT(ctx);
   const GLfloat *rc = ctx->Current.RasterColor;
   GLint row, col;
   radeonVertex vert;
   GLuint orig_vte;
   GLuint h;


   /* Turn off tcl.
    */
   TCL_FALLBACK( ctx, R200_TCL_FALLBACK_BITMAP, 1 );

   /* Choose tiny vertex format
    */
   {
      const GLuint fmt_0 = R200_VTX_XY | R200_VTX_Z0 | R200_VTX_W0
	  | (R200_VTX_PK_RGBA << R200_VTX_COLOR_0_SHIFT);
      const GLuint fmt_1 = 0;
      GLuint vte = rmesa->hw.vte.cmd[VTE_SE_VTE_CNTL];
      GLuint vap = rmesa->hw.vap.cmd[VAP_SE_VAP_CNTL];

      vte &= ~(R200_VTX_XY_FMT | R200_VTX_Z_FMT);
      vte |= R200_VTX_W0_FMT;
      vap &= ~R200_VAP_FORCE_W_TO_ONE;

      rmesa->radeon.swtcl.vertex_size = 5;

      if ( (rmesa->hw.vtx.cmd[VTX_VTXFMT_0] != fmt_0)
	   || (rmesa->hw.vtx.cmd[VTX_VTXFMT_1] != fmt_1) ) {
	 R200_NEWPRIM(rmesa);
	 R200_STATECHANGE( rmesa, vtx );
	 rmesa->hw.vtx.cmd[VTX_VTXFMT_0] = fmt_0;
	 rmesa->hw.vtx.cmd[VTX_VTXFMT_1] = fmt_1;
      }

      if (vte != rmesa->hw.vte.cmd[VTE_SE_VTE_CNTL]) {
	 R200_STATECHANGE( rmesa, vte );
	 rmesa->hw.vte.cmd[VTE_SE_VTE_CNTL] = vte;
      }

      if (vap != rmesa->hw.vap.cmd[VAP_SE_VAP_CNTL]) {
	 R200_STATECHANGE( rmesa, vap );
	 rmesa->hw.vap.cmd[VAP_SE_VAP_CNTL] = vap;
      }
   }

   /* Ready for point primitives:
    */
   r200RenderPrimitive( ctx, GL_POINTS );

   /* Turn off the hw viewport transformation:
    */
   R200_STATECHANGE( rmesa, vte );
   orig_vte = rmesa->hw.vte.cmd[VTE_SE_VTE_CNTL];
   rmesa->hw.vte.cmd[VTE_SE_VTE_CNTL] &= ~(R200_VPORT_X_SCALE_ENA |
					   R200_VPORT_Y_SCALE_ENA |
					   R200_VPORT_Z_SCALE_ENA |
					   R200_VPORT_X_OFFSET_ENA |
					   R200_VPORT_Y_OFFSET_ENA |
					   R200_VPORT_Z_OFFSET_ENA);

   /* Turn off other stuff:  Stipple?, texture?, blending?, etc.
    */


   /* Populate the vertex
    *
    * Incorporate FOG into RGBA
    */
   if (ctx->Fog.Enabled) {
      const GLfloat *fc = ctx->Fog.Color;
      GLfloat color[4];
      GLfloat f;

      if (ctx->Fog.FogCoordinateSource == GL_FOG_COORDINATE_EXT)
         f = _swrast_z_to_fogfactor(ctx, ctx->Current.Attrib[VERT_ATTRIB_FOG][0]);
      else
         f = _swrast_z_to_fogfactor(ctx, ctx->Current.RasterDistance);

      color[0] = f * rc[0] + (1.F - f) * fc[0];
      color[1] = f * rc[1] + (1.F - f) * fc[1];
      color[2] = f * rc[2] + (1.F - f) * fc[2];
      color[3] = rc[3];

      UNCLAMPED_FLOAT_TO_CHAN(vert.tv.color.red,   color[0]);
      UNCLAMPED_FLOAT_TO_CHAN(vert.tv.color.green, color[1]);
      UNCLAMPED_FLOAT_TO_CHAN(vert.tv.color.blue,  color[2]);
      UNCLAMPED_FLOAT_TO_CHAN(vert.tv.color.alpha, color[3]);
   }
   else {
      UNCLAMPED_FLOAT_TO_CHAN(vert.tv.color.red,   rc[0]);
      UNCLAMPED_FLOAT_TO_CHAN(vert.tv.color.green, rc[1]);
      UNCLAMPED_FLOAT_TO_CHAN(vert.tv.color.blue,  rc[2]);
      UNCLAMPED_FLOAT_TO_CHAN(vert.tv.color.alpha, rc[3]);
   }


   vert.tv.z = ctx->Current.RasterPos[2];


   /* Update window height
    */
   h = radeon_get_drawable(&rmesa->radeon)->h;

   /* Clipping handled by existing mechansims in r200_ioctl.c?
    */
   for (row=0; row<height; row++) {
      const GLubyte *src = (const GLubyte *)
	 _mesa_image_address2d(unpack, bitmap, width, height,
                               GL_COLOR_INDEX, GL_BITMAP, row, 0 );

      if (unpack->LsbFirst) {
         /* Lsb first */
         GLubyte mask = 1U << (unpack->SkipPixels & 0x7);
         for (col=0; col<width; col++) {
            if (*src & mask) {
	       vert.tv.x = px+col;
	       vert.tv.y = h - (py+row) - 1;
	       r200_point( rmesa, &vert );
            }
	    src += (mask >> 7);
	    mask = ((mask << 1) & 0xff) | (mask >> 7);
         }

         /* get ready for next row */
         if (mask != 1)
            src++;
      }
      else {
         /* Msb first */
         GLubyte mask = 128U >> (unpack->SkipPixels & 0x7);
         for (col=0; col<width; col++) {
            if (*src & mask) {
	       vert.tv.x = px+col;
	       vert.tv.y = h - (py+row) - 1;
	       r200_point( rmesa, &vert );
            }
	    src += mask & 1;
	    mask = ((mask << 7) & 0xff) | (mask >> 1);
         }
         /* get ready for next row */
         if (mask != 128)
            src++;
      }
   }

   /* Fire outstanding vertices, restore state
    */
   R200_STATECHANGE( rmesa, vte );
   rmesa->hw.vte.cmd[VTE_SE_VTE_CNTL] = orig_vte;

   /* Unfallback
    */
   TCL_FALLBACK( ctx, R200_TCL_FALLBACK_BITMAP, 0 );

   /* Need to restore vertexformat?
    */
   if (rmesa->radeon.TclFallback)
      r200ChooseVertexState( ctx );
}



/**********************************************************************/
/*                            Initialization.                         */
/**********************************************************************/

void r200InitSwtcl( struct gl_context *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   r200ContextPtr rmesa = R200_CONTEXT(ctx);
   static int firsttime = 1;

   if (firsttime) {
      init_rast_tab();
      firsttime = 0;
   }
   rmesa->radeon.swtcl.emit_prediction = 0;

   tnl->Driver.Render.Start = r200RenderStart;
   tnl->Driver.Render.Finish = r200RenderFinish;
   tnl->Driver.Render.PrimitiveNotify = r200RenderPrimitive;
   tnl->Driver.Render.ResetLineStipple = r200ResetLineStipple;
   tnl->Driver.Render.BuildVertices = _tnl_build_vertices;
   tnl->Driver.Render.CopyPV = _tnl_copy_pv;
   tnl->Driver.Render.Interp = _tnl_interp;

   /* FIXME: what are these numbers? */
   _tnl_init_vertices( ctx, ctx->Const.MaxArrayLockSize + 12,
		       36 * sizeof(GLfloat) );

   rmesa->radeon.swtcl.verts = (GLubyte *)tnl->clipspace.vertex_buf;
   rmesa->radeon.swtcl.RenderIndex = ~0;
   rmesa->radeon.swtcl.render_primitive = GL_TRIANGLES;
   rmesa->radeon.swtcl.hw_primitive = 0;
}

@


1.9
log
@Merge Mesa 10.2.9
@
text
@@


1.8
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d414 2
a415 2
#define DO_UNFILLED ((IND & R200_UNFILLED_BIT) != 0)
#define DO_TWOSIDE  ((IND & R200_TWOSIDE_BIT) != 0)
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d414 2
a415 2
#define DO_UNFILLED (IND & R200_UNFILLED_BIT)
#define DO_TWOSIDE  (IND & R200_TWOSIDE_BIT)
@


1.6
log
@Merge Mesa 9.2.0
@
text
@d32 1
a32 1
 *   Keith Whitwell <keith@@tungstengraphics.com>
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d83 1
a83 1
   DECLARE_RENDERINPUTS(index_bitset);
a87 2
   RENDERINPUTS_COPY( index_bitset, tnl->render_inputs_bitset );

d104 2
a105 1
       RENDERINPUTS_TEST_RANGE( index_bitset, _TNL_FIRST_TEX, _TNL_LAST_TEX )) { /* need w coord for projected textures */
d114 1
a114 1
   if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_POINTSIZE )) {
d128 2
a129 2
   if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_COLOR1 ) ||
       RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_FOG )) {
d132 1
a132 1
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_COLOR1 )) {
d140 1
a140 1
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_FOG )) {
d147 1
a147 1
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_FOG )) {
d154 1
a154 1
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_COLOR1 )) {
d164 1
a164 1
   if (RENDERINPUTS_TEST_RANGE( index_bitset, _TNL_FIRST_TEX, _TNL_LAST_TEX )) {
d168 1
a168 1
	 if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_TEX(i) )) {
d184 1
a184 1
   if (!RENDERINPUTS_EQUAL( rmesa->radeon.tnl_index_bitset, index_bitset ) ||
d198 1
a198 1
      RENDERINPUTS_COPY( rmesa->radeon.tnl_index_bitset, index_bitset );
d242 3
d259 3
a261 2
   if (!RENDERINPUTS_TEST_RANGE( tnl->render_inputs_bitset, _TNL_FIRST_TEX, _TNL_LAST_TEX )
	|| (ctx->_TriangleCaps & (DD_TRI_LIGHT_TWOSIDE|DD_TRI_UNFILLED))) {
d265 1
a265 1
      if (RENDERINPUTS_TEST_RANGE( tnl->render_inputs_bitset, _TNL_FIRST_TEX, _TNL_LAST_TEX )) {
d325 1
a325 2
      return (((R200_CONTEXT(ctx))->radeon.radeonScreen->drmSupportsPointSprites &&
              !(ctx->_TriangleCaps & DD_POINT_SMOOTH)) ?
d577 3
a579 1
   GLuint flags = ctx->_TriangleCaps;
d584 4
a587 2
   if (flags & DD_TRI_LIGHT_TWOSIDE) index |= R200_TWOSIDE_BIT;
   if (flags & DD_TRI_UNFILLED)      index |= R200_UNFILLED_BIT;
d645 3
d649 1
a649 1
   if (prim < GL_TRIANGLES || !(ctx->_TriangleCaps & DD_TRI_UNFILLED))
d730 1
a730 1
	    RENDERINPUTS_ZERO( rmesa->radeon.tnl_index_bitset );
d863 1
a863 4
   LOCK_HARDWARE( &rmesa->radeon );
   UNLOCK_HARDWARE( &rmesa->radeon );
   h = radeon_get_drawable(&rmesa->radeon)->h + radeon_get_drawable(&rmesa->radeon)->y;
   px += radeon_get_drawable(&rmesa->radeon)->x;
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d78 1
a78 1
static void r200SetVertexFormat( GLcontext *ctx )
d224 1
a224 1
static void r200RenderStart( GLcontext *ctx )
d237 1
a237 1
void r200ChooseVertexState( GLcontext *ctx )
d289 1
a289 1
void r200_swtcl_flush(GLcontext *ctx, uint32_t current_offset)
d318 1
a318 1
static INLINE GLuint reduced_hw_prim( GLcontext *ctx, GLuint prim)
d322 3
a324 4
      return (ctx->Point.PointSprite ||
	 ((ctx->_TriangleCaps & (DD_POINT_SIZE | DD_POINT_ATTEN)) &&
	 !(ctx->_TriangleCaps & (DD_POINT_SMOOTH)))) ?
	 R200_VF_PRIM_POINT_SPRITES : R200_VF_PRIM_POINTS;
d338 3
a340 3
static void r200RasterPrimitive( GLcontext *ctx, GLuint hwprim );
static void r200RenderPrimitive( GLcontext *ctx, GLenum prim );
static void r200ResetLineStipple( GLcontext *ctx );
d570 1
a570 1
void r200ChooseRenderState( GLcontext *ctx )
d610 1
a610 1
static void r200RasterPrimitive( GLcontext *ctx, GLuint hwprim )
d614 5
d636 1
a636 1
static void r200RenderPrimitive( GLcontext *ctx, GLenum prim )
d644 1
a644 1
static void r200RenderFinish( GLcontext *ctx )
d648 1
a648 1
static void r200ResetLineStipple( GLcontext *ctx )
d680 1
a680 1
void r200Fallback( GLcontext *ctx, GLuint bit, GLboolean mode )
d747 1
a747 1
r200PointsBitmap( GLcontext *ctx, GLint px, GLint py,
d922 1
a922 1
void r200InitSwtcl( GLcontext *ctx )
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d42 1
a46 1
#include "math/m_translate.h"
a57 3
static void flush_last_swtcl_prim( r200ContextPtr rmesa  );


d59 1
a59 1
 *                         Initialization 
d64 3
a66 3
   rmesa->swtcl.vertex_attrs[rmesa->swtcl.vertex_attr_count].attrib = (ATTR);	\
   rmesa->swtcl.vertex_attrs[rmesa->swtcl.vertex_attr_count].format = (STYLE);	\
   rmesa->swtcl.vertex_attr_count++;					\
d72 4
a75 4
   rmesa->swtcl.vertex_attrs[rmesa->swtcl.vertex_attr_count].attrib = 0;		\
   rmesa->swtcl.vertex_attrs[rmesa->swtcl.vertex_attr_count].format = EMIT_PAD;	\
   rmesa->swtcl.vertex_attrs[rmesa->swtcl.vertex_attr_count].offset = (N);		\
   rmesa->swtcl.vertex_attr_count++;					\
d100 1
a100 1
   rmesa->swtcl.vertex_attr_count = 0;
d121 1
a121 1
#if MESA_LITTLE_ENDIAN 
d132 1
a132 1
#if MESA_LITTLE_ENDIAN 
d170 1
a170 1
	    GLuint sz = VB->TexCoordPtr[i]->size;
d185 1
a185 1
   if (!RENDERINPUTS_EQUAL( rmesa->tnl_index_bitset, index_bitset ) ||
d193 1
a193 1
      rmesa->swtcl.vertex_size =
d195 2
a196 2
			      rmesa->swtcl.vertex_attrs, 
			      rmesa->swtcl.vertex_attr_count,
d198 22
a219 2
      rmesa->swtcl.vertex_size /= 4;
      RENDERINPUTS_COPY( rmesa->tnl_index_bitset, index_bitset );
a225 2
   r200ContextPtr rmesa = R200_CONTEXT( ctx );

d227 2
a228 4

   if (rmesa->dma.flush != 0 && 
       rmesa->dma.flush != flush_last_swtcl_prim)
      rmesa->dma.flush( rmesa );
d248 1
a248 1
   if (rmesa->Fallback != 0)
d289 1
a289 4

/* Flush vertices in the current dma region.
 */
static void flush_last_swtcl_prim( r200ContextPtr rmesa  )
d291 3
a293 34
   if (R200_DEBUG & DEBUG_IOCTL)
      fprintf(stderr, "%s\n", __FUNCTION__);

   rmesa->dma.flush = NULL;

   if (rmesa->dma.current.buf) {
      struct r200_dma_region *current = &rmesa->dma.current;
      GLuint current_offset = (rmesa->r200Screen->gart_buffer_offset +
			       current->buf->buf->idx * RADEON_BUFFER_SIZE + 
			       current->start);

      assert (!(rmesa->swtcl.hw_primitive & R200_VF_PRIM_WALK_IND));

      assert (current->start + 
	      rmesa->swtcl.numverts * rmesa->swtcl.vertex_size * 4 ==
	      current->ptr);

      if (rmesa->dma.current.start != rmesa->dma.current.ptr) {
	 r200EnsureCmdBufSpace( rmesa, VERT_AOS_BUFSZ +
			        rmesa->hw.max_state_size + VBUF_BUFSZ );
	 r200EmitVertexAOS( rmesa,
			      rmesa->swtcl.vertex_size,
			      current_offset);

	 r200EmitVbufPrim( rmesa,
			   rmesa->swtcl.hw_primitive,
			   rmesa->swtcl.numverts);
      }

      rmesa->swtcl.numverts = 0;
      current->start = current->ptr;
   }
}

a294 6
/* Alloc space in the current dma region.
 */
static INLINE void *
r200AllocDmaLowVerts( r200ContextPtr rmesa, int nverts, int vsize )
{
   GLuint bytes = vsize * nverts;
d296 14
a309 2
   if ( rmesa->dma.current.ptr + bytes > rmesa->dma.current.end ) 
      r200RefillCurrentDmaRegion( rmesa );
d311 1
a311 18
   if (!rmesa->dma.flush) {
      rmesa->glCtx->Driver.NeedFlush |= FLUSH_STORED_VERTICES;
      rmesa->dma.flush = flush_last_swtcl_prim;
   }

   ASSERT( vsize == rmesa->swtcl.vertex_size * 4 );
   ASSERT( rmesa->dma.flush == flush_last_swtcl_prim );
   ASSERT( rmesa->dma.current.start + 
	   rmesa->swtcl.numverts * rmesa->swtcl.vertex_size * 4 ==
	   rmesa->dma.current.ptr );


   {
      GLubyte *head = (GLubyte *) (rmesa->dma.current.address + rmesa->dma.current.ptr);
      rmesa->dma.current.ptr += bytes;
      rmesa->swtcl.numverts += nverts;
      return head;
   }
a314 1

d359 10
d372 2
a373 2
#define GET_VERTEX_DWORDS() rmesa->swtcl.vertex_size
#define ALLOC_VERTS( n, size ) r200AllocDmaLowVerts( rmesa, n, size * 4 )
d376 4
a379 4
   const char *r200verts = (char *)rmesa->swtcl.verts;
#define VERT(x) (r200Vertex *)(r200verts + ((x) * vertsize * sizeof(int)))
#define VERTEX r200Vertex 
#define DO_DEBUG_VERTS (1 && (R200_DEBUG & DEBUG_VERTS))
a422 1
#define HAVE_RGBA   1
d435 1
a435 1
#define GET_VERTEX(e) (rmesa->swtcl.verts + (e*rmesa->swtcl.vertex_size*sizeof(int)))
d439 1
a439 1
   r200_color_t *color = (r200_color_t *)&((v)->ui[coloroffset]);	\
d451 1
a451 1
      r200_color_t *spec = (r200_color_t *)&((v)->ui[specoffset]);	\
d460 2
a461 2
      r200_color_t *spec0 = (r200_color_t *)&((v0)->ui[specoffset]);	\
      r200_color_t *spec1 = (r200_color_t *)&((v1)->ui[specoffset]);	\
d482 1
a482 1
   GLuint color[n], spec[n];						\
d492 1
a492 1
#define RENDER_PRIMITIVE rmesa->swtcl.render_primitive
d548 2
a549 2
   const GLuint vertsize = rmesa->swtcl.vertex_size;		\
   const char *r200verts = (char *)rmesa->swtcl.verts;		\
d578 1
a578 1
   if (!rmesa->TclFallback || rmesa->Fallback) 
d584 1
a584 1
   if (index != rmesa->swtcl.RenderIndex) {
d601 1
a601 1
      rmesa->swtcl.RenderIndex = index;
d615 1
a615 1
   if (rmesa->swtcl.hw_primitive != hwprim) {
d628 1
a628 1
      rmesa->swtcl.hw_primitive = hwprim;
d635 2
a636 2
   rmesa->swtcl.render_primitive = prim;
   if (prim < GL_TRIANGLES || !(ctx->_TriangleCaps & DD_TRI_UNFILLED)) 
d680 1
a680 1
   GLuint oldfallback = rmesa->Fallback;
d683 1
a683 1
      rmesa->Fallback |= bit;
d685 1
a685 1
	 R200_FIREVERTICES( rmesa );
d688 2
a689 2
	 rmesa->swtcl.RenderIndex = ~0;
         if (R200_DEBUG & DEBUG_FALLBACKS) {
d696 1
a696 1
      rmesa->Fallback &= ~bit;
d710 2
a711 2
	 if (rmesa->TclFallback) {
	    /* These are already done if rmesa->TclFallback goes to
d717 1
a717 1
	    RENDERINPUTS_ZERO( rmesa->tnl_index_bitset );
d721 1
a721 1
         if (R200_DEBUG & DEBUG_FALLBACKS) {
d734 1
a734 1
 * 
d749 1
a749 1
   const GLfloat *rc = ctx->Current.RasterColor; 
d751 1
a751 1
   r200Vertex vert;
d756 1
a756 1
   /* Turn off tcl.  
d773 1
a773 1
      rmesa->swtcl.vertex_size = 5;
d807 1
a807 1
					   R200_VPORT_Z_OFFSET_ENA); 
d850 4
a853 4
   LOCK_HARDWARE( rmesa );
   UNLOCK_HARDWARE( rmesa );
   h = rmesa->dri.drawable->h + rmesa->dri.drawable->y;
   px += rmesa->dri.drawable->x;
d858 2
a859 2
      const GLubyte *src = (const GLubyte *) 
	 _mesa_image_address2d(unpack, bitmap, width, height, 
d908 1
a908 1
   if (rmesa->TclFallback)
d928 1
d939 1
a939 1
   _tnl_init_vertices( ctx, ctx->Const.MaxArrayLockSize + 12, 
d941 5
a945 5
   
   rmesa->swtcl.verts = (GLubyte *)tnl->clipspace.vertex_buf;
   rmesa->swtcl.RenderIndex = ~0;
   rmesa->swtcl.render_primitive = GL_TRIANGLES;
   rmesa->swtcl.hw_primitive = 0;
a947 8

void r200DestroySwtcl( GLcontext *ctx )
{
   r200ContextPtr rmesa = R200_CONTEXT(ctx);

   if (rmesa->swtcl.indexed_verts.buf) 
      r200ReleaseDmaRegion( rmesa, &rmesa->swtcl.indexed_verts, __FUNCTION__ );
}
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d35 7
a41 7
#include "glheader.h"
#include "mtypes.h"
#include "colormac.h"
#include "enums.h"
#include "image.h"
#include "imports.h"
#include "macros.h"
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86: xc/lib/GL/mesa/src/drv/r200/r200_swtcl.c,v 1.5 2003/05/06 23:52:08 daenzer Exp $ */
a49 1
#include "tnl/t_vtx_api.h"
d118 5
d355 3
a357 1
      return (ctx->_TriangleCaps & DD_POINT_SIZE) ?
d640 11
a936 7
void r200FlushVertices( GLcontext *ctx, GLuint flags )
{
   _tnl_FlushVertices( ctx, flags );

   if (flags & FLUSH_STORED_VERTICES)
      R200_NEWPRIM( R200_CONTEXT( ctx ) );
}
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a119 5
   if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_POINTSIZE )) {
      EMIT_ATTR( _TNL_ATTRIB_POINTSIZE, EMIT_1F, R200_VTX_POINT_SIZE );
      offset += 1;
   }

d352 1
a352 3
      return (ctx->Point.PointSprite ||
	 ((ctx->_TriangleCaps & (DD_POINT_SIZE | DD_POINT_ATTEN)) &&
	 !(ctx->_TriangleCaps & (DD_POINT_SMOOTH)))) ?
a634 11
      /* need to disable perspective-correct texturing for point sprites */
      if ((hwprim & 0xf) == R200_VF_PRIM_POINT_SPRITES && ctx->Point.PointSprite) {
	 if (rmesa->hw.set.cmd[SET_RE_CNTL] & R200_PERSPECTIVE_ENABLE) {
	    R200_STATECHANGE( rmesa, set );
	    rmesa->hw.set.cmd[SET_RE_CNTL] &= ~R200_PERSPECTIVE_ENABLE;
	 }
      }
      else if (!(rmesa->hw.set.cmd[SET_RE_CNTL] & R200_PERSPECTIVE_ENABLE)) {
	 R200_STATECHANGE( rmesa, set );
	 rmesa->hw.set.cmd[SET_RE_CNTL] |= R200_PERSPECTIVE_ENABLE;
      }
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d51 1
d939 7
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d1 1
d36 7
a42 8
#include "main/glheader.h"
#include "main/mtypes.h"
#include "main/colormac.h"
#include "main/enums.h"
#include "main/image.h"
#include "main/imports.h"
#include "main/macros.h"
#include "main/simple_list.h"
d47 1
d59 3
d63 1
a63 1
 *                         Initialization
d68 3
a70 3
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].attrib = (ATTR);	\
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].format = (STYLE);	\
   rmesa->radeon.swtcl.vertex_attr_count++;					\
d76 4
a79 4
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].attrib = 0;		\
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].format = EMIT_PAD;	\
   rmesa->radeon.swtcl.vertex_attrs[rmesa->radeon.swtcl.vertex_attr_count].offset = (N);		\
   rmesa->radeon.swtcl.vertex_attr_count++;					\
d82 1
a82 1
static void r200SetVertexFormat( struct gl_context *ctx )
d104 1
a104 1
   rmesa->radeon.swtcl.vertex_attr_count = 0;
d125 1
a125 1
#if MESA_LITTLE_ENDIAN
d136 1
a136 1
#if MESA_LITTLE_ENDIAN
d174 1
a174 1
	    GLuint sz = VB->AttribPtr[_TNL_ATTRIB_TEX0 + i]->size;
d189 1
a189 1
   if (!RENDERINPUTS_EQUAL( rmesa->radeon.tnl_index_bitset, index_bitset ) ||
d197 1
a197 1
      rmesa->radeon.swtcl.vertex_size =
d199 2
a200 2
			      rmesa->radeon.swtcl.vertex_attrs,
			      rmesa->radeon.swtcl.vertex_attr_count,
d202 2
a203 2
      rmesa->radeon.swtcl.vertex_size /= 4;
      RENDERINPUTS_COPY( rmesa->radeon.tnl_index_bitset, index_bitset );
d207 2
a208 1
static void r200_predict_emit_size( r200ContextPtr rmesa )
d210 1
a210 17
   if (RADEON_DEBUG & RADEON_VERTS)
      fprintf(stderr, "%s\n", __func__);
   const int vertex_array_size = 7;
   const int prim_size = 3;
   if (!rmesa->radeon.swtcl.emit_prediction) {
      const int state_size = radeonCountStateEmitSize(&rmesa->radeon);
      if (rcommonEnsureCmdBufSpace(&rmesa->radeon,
	       state_size +
	       vertex_array_size + prim_size,
	       __FUNCTION__))
	 rmesa->radeon.swtcl.emit_prediction = radeonCountStateEmitSize(&rmesa->radeon);
      else
	 rmesa->radeon.swtcl.emit_prediction = state_size;
      rmesa->radeon.swtcl.emit_prediction += vertex_array_size + prim_size
	 + rmesa->radeon.cmdbuf.cs->cdw;
   }
}
d212 1
d214 3
a216 5
static void r200RenderStart( struct gl_context *ctx )
{
   r200SetVertexFormat( ctx );
   if (RADEON_DEBUG & RADEON_VERTS)
      fprintf(stderr, "%s\n", __func__);
d225 1
a225 1
void r200ChooseVertexState( struct gl_context *ctx )
d236 1
a236 1
   if (rmesa->radeon.Fallback != 0)
d277 44
a320 1
void r200_swtcl_flush(struct gl_context *ctx, uint32_t current_offset)
d322 9
a330 3
   r200ContextPtr rmesa = R200_CONTEXT(ctx);
   if (RADEON_DEBUG & RADEON_VERTS)
      fprintf(stderr, "%s\n", __func__);
d332 5
a337 14
   radeonEmitState(&rmesa->radeon);
   r200EmitVertexAOS( rmesa,
		      rmesa->radeon.swtcl.vertex_size,
		      rmesa->radeon.swtcl.bo,
		      current_offset);


   r200EmitVbufPrim( rmesa,
		     rmesa->radeon.swtcl.hw_primitive,
		     rmesa->radeon.swtcl.numverts);
   if ( rmesa->radeon.swtcl.emit_prediction < rmesa->radeon.cmdbuf.cs->cdw )
      WARN_ONCE("Rendering was %d commands larger than predicted size."
	    " We might overflow  command buffer.\n",
	    rmesa->radeon.cmdbuf.cs->cdw - rmesa->radeon.swtcl.emit_prediction );
d339 6
a344 1
   rmesa->radeon.swtcl.emit_prediction = 0;
d348 1
d352 1
a352 1
static INLINE GLuint reduced_hw_prim( struct gl_context *ctx, GLuint prim)
d356 4
a359 3
      return (((R200_CONTEXT(ctx))->radeon.radeonScreen->drmSupportsPointSprites &&
              !(ctx->_TriangleCaps & DD_POINT_SMOOTH)) ?
	 R200_VF_PRIM_POINT_SPRITES : R200_VF_PRIM_POINTS);
d373 3
a375 3
static void r200RasterPrimitive( struct gl_context *ctx, GLuint hwprim );
static void r200RenderPrimitive( struct gl_context *ctx, GLenum prim );
static void r200ResetLineStipple( struct gl_context *ctx );
a392 10
static void* r200_alloc_verts( r200ContextPtr rmesa, GLuint n, GLuint size)
{
   void *rv;
   do {
      r200_predict_emit_size( rmesa );
      rv = rcommonAllocDmaLowVerts( &rmesa->radeon, n, size * 4 );
   } while(!rv);
   return rv;
}

d396 2
a397 2
#define GET_VERTEX_DWORDS() rmesa->radeon.swtcl.vertex_size
#define ALLOC_VERTS( n, size ) r200_alloc_verts(rmesa, n, size)
d400 4
a403 4
   const char *r200verts = (char *)rmesa->radeon.swtcl.verts;
#define VERT(x) (radeonVertex *)(r200verts + ((x) * vertsize * sizeof(int)))
#define VERTEX radeonVertex
#define DO_DEBUG_VERTS (1 && (R200_DEBUG & RADEON_VERTS))
d447 1
d460 1
a460 1
#define GET_VERTEX(e) (rmesa->radeon.swtcl.verts + (e*rmesa->radeon.swtcl.vertex_size*sizeof(int)))
d464 1
a464 1
   radeon_color_t *color = (radeon_color_t *)&((v)->ui[coloroffset]);	\
d476 1
a476 1
      radeon_color_t *spec = (radeon_color_t *)&((v)->ui[specoffset]);	\
d485 2
a486 2
      radeon_color_t *spec0 = (radeon_color_t *)&((v0)->ui[specoffset]);	\
      radeon_color_t *spec1 = (radeon_color_t *)&((v1)->ui[specoffset]);	\
d507 1
a507 1
   GLuint color[n] = {0}, spec[n] = {0};						\
d517 1
a517 1
#define RENDER_PRIMITIVE rmesa->radeon.swtcl.render_primitive
d573 2
a574 2
   const GLuint vertsize = rmesa->radeon.swtcl.vertex_size;		\
   const char *r200verts = (char *)rmesa->radeon.swtcl.verts;		\
d596 1
a596 1
void r200ChooseRenderState( struct gl_context *ctx )
d603 1
a603 1
   if (!rmesa->radeon.TclFallback || rmesa->radeon.Fallback)
d609 1
a609 1
   if (index != rmesa->radeon.swtcl.RenderIndex) {
d626 1
a626 1
      rmesa->radeon.swtcl.RenderIndex = index;
d636 1
a636 1
static void r200RasterPrimitive( struct gl_context *ctx, GLuint hwprim )
d640 1
a640 6
   radeon_prepare_render(&rmesa->radeon);
   if (rmesa->radeon.NewGLState)
      r200ValidateState( ctx );


   if (rmesa->radeon.swtcl.hw_primitive != hwprim) {
d653 1
a653 1
      rmesa->radeon.swtcl.hw_primitive = hwprim;
d657 1
a657 1
static void r200RenderPrimitive( struct gl_context *ctx, GLenum prim )
d660 2
a661 2
   rmesa->radeon.swtcl.render_primitive = prim;
   if (prim < GL_TRIANGLES || !(ctx->_TriangleCaps & DD_TRI_UNFILLED))
d665 1
a665 1
static void r200RenderFinish( struct gl_context *ctx )
d669 1
a669 1
static void r200ResetLineStipple( struct gl_context *ctx )
d701 1
a701 1
void r200Fallback( struct gl_context *ctx, GLuint bit, GLboolean mode )
d705 1
a705 1
   GLuint oldfallback = rmesa->radeon.Fallback;
d708 1
a708 1
      rmesa->radeon.Fallback |= bit;
d710 1
a710 1
	 radeon_firevertices(&rmesa->radeon);
d713 2
a714 2
	 rmesa->radeon.swtcl.RenderIndex = ~0;
         if (R200_DEBUG & RADEON_FALLBACKS) {
d721 1
a721 1
      rmesa->radeon.Fallback &= ~bit;
d735 2
a736 2
	 if (rmesa->radeon.TclFallback) {
	    /* These are already done if rmesa->radeon.TclFallback goes to
d742 1
a742 1
	    RENDERINPUTS_ZERO( rmesa->radeon.tnl_index_bitset );
d746 1
a746 1
         if (R200_DEBUG & RADEON_FALLBACKS) {
d759 1
a759 1
 *
d768 1
a768 1
r200PointsBitmap( struct gl_context *ctx, GLint px, GLint py,
d774 1
a774 1
   const GLfloat *rc = ctx->Current.RasterColor;
d776 1
a776 1
   radeonVertex vert;
d781 1
a781 1
   /* Turn off tcl.
d798 1
a798 1
      rmesa->radeon.swtcl.vertex_size = 5;
d832 1
a832 1
					   R200_VPORT_Z_OFFSET_ENA);
d875 4
a878 4
   LOCK_HARDWARE( &rmesa->radeon );
   UNLOCK_HARDWARE( &rmesa->radeon );
   h = radeon_get_drawable(&rmesa->radeon)->h + radeon_get_drawable(&rmesa->radeon)->y;
   px += radeon_get_drawable(&rmesa->radeon)->x;
d883 2
a884 2
      const GLubyte *src = (const GLubyte *)
	 _mesa_image_address2d(unpack, bitmap, width, height,
d933 1
a933 1
   if (rmesa->radeon.TclFallback)
d943 1
a943 1
void r200InitSwtcl( struct gl_context *ctx )
a952 1
   rmesa->radeon.swtcl.emit_prediction = 0;
d963 1
a963 1
   _tnl_init_vertices( ctx, ctx->Const.MaxArrayLockSize + 12,
d965 6
d972 7
a978 4
   rmesa->radeon.swtcl.verts = (GLubyte *)tnl->clipspace.vertex_buf;
   rmesa->radeon.swtcl.RenderIndex = ~0;
   rmesa->radeon.swtcl.render_primitive = GL_TRIANGLES;
   rmesa->radeon.swtcl.hw_primitive = 0;
a979 1

@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d83 1
a83 1
   GLbitfield64 index_bitset = tnl->render_inputs_bitset;
d88 2
d106 1
a106 2
        (index_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_TEX0, _TNL_NUM_TEX)) ) {
      /* need w coord for projected textures */
d115 1
a115 1
   if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_POINTSIZE)) {
d129 2
a130 2
   if (index_bitset &
       (BITFIELD64_BIT(_TNL_ATTRIB_COLOR1) | BITFIELD64_BIT(_TNL_ATTRIB_FOG))) {
d133 1
a133 1
      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_COLOR1)) {
d141 1
a141 1
      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_FOG)) {
d148 1
a148 1
      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_FOG)) {
d155 1
a155 1
      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_COLOR1)) {
d165 1
a165 1
   if (index_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_TEX0, _TNL_NUM_TEX)) {
d169 1
a169 1
	 if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_TEX(i))) {
d185 1
a185 1
   if (rmesa->radeon.tnl_index_bitset != index_bitset ||
d199 1
a199 1
      rmesa->radeon.tnl_index_bitset = index_bitset;
a242 3
   GLboolean unfilled = (ctx->Polygon.FrontMode != GL_FILL ||
                         ctx->Polygon.BackMode != GL_FILL);
   GLboolean twosided = ctx->Light.Enabled && ctx->Light.Model.TwoSide;
d257 2
a258 3
   if ((0 == (tnl->render_inputs_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_TEX0, _TNL_NUM_TEX)))
       || twosided
       || unfilled) {
d262 1
a262 1
      if (tnl->render_inputs_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_TEX0, _TNL_NUM_TEX)) {
d322 2
a323 1
      return ((!ctx->Point.SmoothFlag) ?
d575 1
a575 3
   GLboolean unfilled = (ctx->Polygon.FrontMode != GL_FILL ||
                         ctx->Polygon.BackMode != GL_FILL);
   GLboolean twosided = ctx->Light.Enabled && ctx->Light.Model.TwoSide;
d580 2
a581 4
   if (twosided)
      index |= R200_TWOSIDE_BIT;
   if (unfilled)
      index |= R200_UNFILLED_BIT;
a638 3
   GLboolean unfilled = (ctx->Polygon.FrontMode != GL_FILL ||
                         ctx->Polygon.BackMode != GL_FILL);

d640 1
a640 1
   if (prim < GL_TRIANGLES || !unfilled)
d721 1
a721 1
	    rmesa->radeon.tnl_index_bitset = 0;
d854 4
a857 1
   h = radeon_get_drawable(&rmesa->radeon)->h;
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d32 1
a32 1
 *   Keith Whitwell <keithw@@vmware.com>
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@d414 2
a415 2
#define DO_UNFILLED ((IND & R200_UNFILLED_BIT) != 0)
#define DO_TWOSIDE  ((IND & R200_TWOSIDE_BIT) != 0)
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d414 2
a415 2
#define DO_UNFILLED (IND & R200_UNFILLED_BIT)
#define DO_TWOSIDE  (IND & R200_TWOSIDE_BIT)
@


