head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.6
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.2
	v10_4_3:1.1.1.2
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2013.09.05.14.04.24;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.38;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.43;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2009 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *
 */

#include "intel_batchbuffer.h"
#include "intel_fbo.h"
#include "brw_context.h"
#include "brw_defines.h"
#include "brw_state.h"

static void
gen6_upload_depth_stencil_state(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   struct gen6_depth_stencil_state *ds;
   struct intel_renderbuffer *depth_irb;

   /* _NEW_BUFFERS */
   depth_irb = intel_get_renderbuffer(ctx->DrawBuffer, BUFFER_DEPTH);

   ds = brw_state_batch(brw, AUB_TRACE_DEPTH_STENCIL_STATE,
			sizeof(*ds), 64,
			&brw->cc.depth_stencil_state_offset);
   memset(ds, 0, sizeof(*ds));

   /* _NEW_STENCIL | _NEW_BUFFERS */
   if (ctx->Stencil._Enabled) {
      int back = ctx->Stencil._BackFace;

      ds->ds0.stencil_enable = 1;
      ds->ds0.stencil_func =
	 intel_translate_compare_func(ctx->Stencil.Function[0]);
      ds->ds0.stencil_fail_op =
	 intel_translate_stencil_op(ctx->Stencil.FailFunc[0]);
      ds->ds0.stencil_pass_depth_fail_op =
	 intel_translate_stencil_op(ctx->Stencil.ZFailFunc[0]);
      ds->ds0.stencil_pass_depth_pass_op =
	 intel_translate_stencil_op(ctx->Stencil.ZPassFunc[0]);
      ds->ds1.stencil_write_mask = ctx->Stencil.WriteMask[0];
      ds->ds1.stencil_test_mask = ctx->Stencil.ValueMask[0];

      if (ctx->Stencil._TestTwoSide) {
	 ds->ds0.bf_stencil_enable = 1;
	 ds->ds0.bf_stencil_func =
	    intel_translate_compare_func(ctx->Stencil.Function[back]);
	 ds->ds0.bf_stencil_fail_op =
	    intel_translate_stencil_op(ctx->Stencil.FailFunc[back]);
	 ds->ds0.bf_stencil_pass_depth_fail_op =
	    intel_translate_stencil_op(ctx->Stencil.ZFailFunc[back]);
	 ds->ds0.bf_stencil_pass_depth_pass_op =
	    intel_translate_stencil_op(ctx->Stencil.ZPassFunc[back]);
	 ds->ds1.bf_stencil_write_mask = ctx->Stencil.WriteMask[back];
	 ds->ds1.bf_stencil_test_mask = ctx->Stencil.ValueMask[back];
      }

      ds->ds0.stencil_write_enable = ctx->Stencil._WriteEnabled;
   }

   /* _NEW_DEPTH */
   if (ctx->Depth.Test && depth_irb) {
      ds->ds2.depth_test_enable = ctx->Depth.Test;
      ds->ds2.depth_test_func = intel_translate_compare_func(ctx->Depth.Func);
      ds->ds2.depth_write_enable = ctx->Depth.Mask;
   }

   /* Point the GPU at the new indirect state. */
   if (brw->gen == 6) {
      BEGIN_BATCH(4);
      OUT_BATCH(_3DSTATE_CC_STATE_POINTERS << 16 | (4 - 2));
      OUT_BATCH(0);
      OUT_BATCH(brw->cc.depth_stencil_state_offset | 1);
      OUT_BATCH(0);
      ADVANCE_BATCH();
   } else {
      BEGIN_BATCH(2);
      OUT_BATCH(_3DSTATE_DEPTH_STENCIL_STATE_POINTERS << 16 | (2 - 2));
      OUT_BATCH(brw->cc.depth_stencil_state_offset | 1);
      ADVANCE_BATCH();
   }
}

const struct brw_tracked_state gen6_depth_stencil_state = {
   .dirty = {
      .mesa = _NEW_DEPTH | _NEW_STENCIL | _NEW_BUFFERS,
      .brw  = BRW_NEW_BATCH | BRW_NEW_STATE_BASE_ADDRESS,
      .cache = 0,
   },
   .emit = gen6_upload_depth_stencil_state,
};
@


1.4
log
@Merge Mesa 9.2.0
@
text
@@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d28 2
d31 1
d35 1
a35 1
gen6_prepare_depth_stencil_state(struct brw_context *brw)
d37 1
a37 1
   struct gl_context *ctx = &brw->intel.ctx;
d39 1
d41 5
a45 1
   ds = brw_state_batch(brw, sizeof(*ds), 64,
d49 1
a49 1
   /* _NEW_STENCIL */
d79 1
a79 5
      /* Not really sure about this:
       */
      if (ctx->Stencil.WriteMask[0] ||
	  (ctx->Stencil._TestTwoSide && ctx->Stencil.WriteMask[back]))
	 ds->ds0.stencil_write_enable = 1;
d83 2
a84 2
   if (ctx->Depth.Test) {
      ds->ds2.depth_test_enable = 1;
d89 14
a102 1
   brw->state.dirty.cache |= CACHE_NEW_DEPTH_STENCIL_STATE;
d107 2
a108 2
      .mesa = _NEW_DEPTH | _NEW_STENCIL,
      .brw = BRW_NEW_BATCH,
d111 1
a111 1
   .prepare = gen6_prepare_depth_stencil_state,
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a30 9
struct brw_depth_stencil_state_key {
   GLenum depth_func;
   GLboolean depth_test, depth_write;
   GLboolean stencil, stencil_two_side;
   GLenum stencil_func[2], stencil_fail_op[2];
   GLenum stencil_pass_depth_fail_op[2], stencil_pass_depth_pass_op[2];
   GLubyte stencil_write_mask[2], stencil_test_mask[2];
};

d32 1
a32 2
depth_stencil_state_populate_key(struct brw_context *brw,
				 struct brw_depth_stencil_state_key *key)
d35 1
a35 1
   const unsigned back = ctx->Stencil._BackFace;
d37 3
a39 1
   memset(key, 0, sizeof(*key));
d42 2
a43 36
   key->stencil = ctx->Stencil._Enabled;
   key->stencil_two_side = ctx->Stencil._TestTwoSide;

   if (key->stencil) {
      key->stencil_func[0] = ctx->Stencil.Function[0];
      key->stencil_fail_op[0] = ctx->Stencil.FailFunc[0];
      key->stencil_pass_depth_fail_op[0] = ctx->Stencil.ZFailFunc[0];
      key->stencil_pass_depth_pass_op[0] = ctx->Stencil.ZPassFunc[0];
      key->stencil_write_mask[0] = ctx->Stencil.WriteMask[0];
      key->stencil_test_mask[0] = ctx->Stencil.ValueMask[0];
   }
   if (key->stencil_two_side) {
      key->stencil_func[1] = ctx->Stencil.Function[back];
      key->stencil_fail_op[1] = ctx->Stencil.FailFunc[back];
      key->stencil_pass_depth_fail_op[1] = ctx->Stencil.ZFailFunc[back];
      key->stencil_pass_depth_pass_op[1] = ctx->Stencil.ZPassFunc[back];
      key->stencil_write_mask[1] = ctx->Stencil.WriteMask[back];
      key->stencil_test_mask[1] = ctx->Stencil.ValueMask[back];
   }

   key->depth_test = ctx->Depth.Test;
   if (key->depth_test) {
      key->depth_func = ctx->Depth.Func;
      key->depth_write = ctx->Depth.Mask;
   }
}

/**
 * Creates the state cache entry for the given DEPTH_STENCIL_STATE state key.
 */
static drm_intel_bo *
depth_stencil_state_create_from_key(struct brw_context *brw,
				    struct brw_depth_stencil_state_key *key)
{
   struct gen6_depth_stencil_state ds;
   drm_intel_bo *bo;
d45 24
a68 28
   memset(&ds, 0, sizeof(ds));

   /* _NEW_STENCIL */
   if (key->stencil) {
      ds.ds0.stencil_enable = 1;
      ds.ds0.stencil_func =
	 intel_translate_compare_func(key->stencil_func[0]);
      ds.ds0.stencil_fail_op =
	 intel_translate_stencil_op(key->stencil_fail_op[0]);
      ds.ds0.stencil_pass_depth_fail_op =
	 intel_translate_stencil_op(key->stencil_pass_depth_fail_op[0]);
      ds.ds0.stencil_pass_depth_pass_op =
	 intel_translate_stencil_op(key->stencil_pass_depth_pass_op[0]);
      ds.ds1.stencil_write_mask = key->stencil_write_mask[0];
      ds.ds1.stencil_test_mask = key->stencil_test_mask[0];

      if (key->stencil_two_side) {
	 ds.ds0.bf_stencil_enable = 1;
	 ds.ds0.bf_stencil_func =
	    intel_translate_compare_func(key->stencil_func[1]);
	 ds.ds0.bf_stencil_fail_op =
	    intel_translate_stencil_op(key->stencil_fail_op[1]);
	 ds.ds0.bf_stencil_pass_depth_fail_op =
	    intel_translate_stencil_op(key->stencil_pass_depth_fail_op[1]);
	 ds.ds0.bf_stencil_pass_depth_pass_op =
	    intel_translate_stencil_op(key->stencil_pass_depth_pass_op[1]);
	 ds.ds1.bf_stencil_write_mask = key->stencil_write_mask[1];
	 ds.ds1.bf_stencil_test_mask = key->stencil_test_mask[1];
d73 3
a75 3
      if (key->stencil_write_mask[0] ||
	  (key->stencil_two_side && key->stencil_write_mask[1]))
	 ds.ds0.stencil_write_enable = 1;
d79 4
a82 4
   if (key->depth_test) {
      ds.ds2.depth_test_enable = 1;
      ds.ds2.depth_test_func = intel_translate_compare_func(key->depth_func);
      ds.ds2.depth_write_enable = key->depth_write;
d85 1
a85 25
   bo = brw_upload_cache(&brw->cache, BRW_DEPTH_STENCIL_STATE,
			 key, sizeof(*key),
			 NULL, 0,
			 &ds, sizeof(ds));

   return bo;
}

static void
prepare_depth_stencil_state(struct brw_context *brw)
{
   struct brw_depth_stencil_state_key key;

   depth_stencil_state_populate_key(brw, &key);

   drm_intel_bo_unreference(brw->cc.depth_stencil_state_bo);
   brw->cc.depth_stencil_state_bo = brw_search_cache(&brw->cache,
						     BRW_DEPTH_STENCIL_STATE,
						     &key, sizeof(key),
						     NULL, 0,
						     NULL);

   if (brw->cc.depth_stencil_state_bo == NULL)
      brw->cc.depth_stencil_state_bo =
	 depth_stencil_state_create_from_key(brw, &key);
d91 1
a91 1
      .brw = 0,
d94 1
a94 1
   .prepare = prepare_depth_stencil_state,
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d44 1
a44 1
   GLcontext *ctx = &brw->intel.ctx;
d80 1
a80 1
static dri_bo *
d85 1
a85 1
   dri_bo *bo;
d146 1
a146 1
   dri_bo_unreference(brw->cc.depth_stencil_state_bo);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d44 1
a44 1
   struct gl_context *ctx = &brw->intel.ctx;
d80 1
a80 1
static drm_intel_bo *
d85 1
a85 1
   drm_intel_bo *bo;
d146 1
a146 1
   drm_intel_bo_unreference(brw->cc.depth_stencil_state_bo);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a27 2
#include "intel_batchbuffer.h"
#include "intel_fbo.h"
a28 1
#include "brw_defines.h"
d31 9
d41 42
a82 1
gen6_upload_depth_stencil_state(struct brw_context *brw)
d84 31
a114 40
   struct gl_context *ctx = &brw->ctx;
   struct gen6_depth_stencil_state *ds;
   struct intel_renderbuffer *depth_irb;

   /* _NEW_BUFFERS */
   depth_irb = intel_get_renderbuffer(ctx->DrawBuffer, BUFFER_DEPTH);

   ds = brw_state_batch(brw, AUB_TRACE_DEPTH_STENCIL_STATE,
			sizeof(*ds), 64,
			&brw->cc.depth_stencil_state_offset);
   memset(ds, 0, sizeof(*ds));

   /* _NEW_STENCIL | _NEW_BUFFERS */
   if (ctx->Stencil._Enabled) {
      int back = ctx->Stencil._BackFace;

      ds->ds0.stencil_enable = 1;
      ds->ds0.stencil_func =
	 intel_translate_compare_func(ctx->Stencil.Function[0]);
      ds->ds0.stencil_fail_op =
	 intel_translate_stencil_op(ctx->Stencil.FailFunc[0]);
      ds->ds0.stencil_pass_depth_fail_op =
	 intel_translate_stencil_op(ctx->Stencil.ZFailFunc[0]);
      ds->ds0.stencil_pass_depth_pass_op =
	 intel_translate_stencil_op(ctx->Stencil.ZPassFunc[0]);
      ds->ds1.stencil_write_mask = ctx->Stencil.WriteMask[0];
      ds->ds1.stencil_test_mask = ctx->Stencil.ValueMask[0];

      if (ctx->Stencil._TestTwoSide) {
	 ds->ds0.bf_stencil_enable = 1;
	 ds->ds0.bf_stencil_func =
	    intel_translate_compare_func(ctx->Stencil.Function[back]);
	 ds->ds0.bf_stencil_fail_op =
	    intel_translate_stencil_op(ctx->Stencil.FailFunc[back]);
	 ds->ds0.bf_stencil_pass_depth_fail_op =
	    intel_translate_stencil_op(ctx->Stencil.ZFailFunc[back]);
	 ds->ds0.bf_stencil_pass_depth_pass_op =
	    intel_translate_stencil_op(ctx->Stencil.ZPassFunc[back]);
	 ds->ds1.bf_stencil_write_mask = ctx->Stencil.WriteMask[back];
	 ds->ds1.bf_stencil_test_mask = ctx->Stencil.ValueMask[back];
d117 5
a121 1
      ds->ds0.stencil_write_enable = ctx->Stencil._WriteEnabled;
d125 4
a128 4
   if (ctx->Depth.Test && depth_irb) {
      ds->ds2.depth_test_enable = ctx->Depth.Test;
      ds->ds2.depth_test_func = intel_translate_compare_func(ctx->Depth.Func);
      ds->ds2.depth_write_enable = ctx->Depth.Mask;
d131 25
a155 14
   /* Point the GPU at the new indirect state. */
   if (brw->gen == 6) {
      BEGIN_BATCH(4);
      OUT_BATCH(_3DSTATE_CC_STATE_POINTERS << 16 | (4 - 2));
      OUT_BATCH(0);
      OUT_BATCH(brw->cc.depth_stencil_state_offset | 1);
      OUT_BATCH(0);
      ADVANCE_BATCH();
   } else {
      BEGIN_BATCH(2);
      OUT_BATCH(_3DSTATE_DEPTH_STENCIL_STATE_POINTERS << 16 | (2 - 2));
      OUT_BATCH(brw->cc.depth_stencil_state_offset | 1);
      ADVANCE_BATCH();
   }
d160 2
a161 2
      .mesa = _NEW_DEPTH | _NEW_STENCIL | _NEW_BUFFERS,
      .brw  = BRW_NEW_BATCH | BRW_NEW_STATE_BASE_ADDRESS,
d164 1
a164 1
   .emit = gen6_upload_depth_stencil_state,
@


