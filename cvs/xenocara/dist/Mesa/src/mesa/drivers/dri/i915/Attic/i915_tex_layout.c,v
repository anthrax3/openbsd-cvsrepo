head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.14.04.13;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.21;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.47;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2006 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

/** @@file i915_tex_layout.c
 * Code to layout images in a mipmap tree for i830M-GM915 and G945 and beyond.
 */

#include "intel_mipmap_tree.h"
#include "intel_tex_layout.h"
#include "main/macros.h"
#include "intel_context.h"

#define FILE_DEBUG_FLAG DEBUG_TEXTURE

static GLint initial_offsets[6][2] = {
   [FACE_POS_X] = {0, 0},
   [FACE_POS_Y] = {1, 0},
   [FACE_POS_Z] = {1, 1},
   [FACE_NEG_X] = {0, 2},
   [FACE_NEG_Y] = {1, 2},
   [FACE_NEG_Z] = {1, 3},
};


static GLint step_offsets[6][2] = {
   [FACE_POS_X] = {0, 2},
   [FACE_POS_Y] = {-1, 2},
   [FACE_POS_Z] = {-1, 1},
   [FACE_NEG_X] = {0, 2},
   [FACE_NEG_Y] = {-1, 2},
   [FACE_NEG_Z] = {-1, 1},
};


static GLint bottom_offsets[6] = {
   [FACE_POS_X] = 16 + 0 * 8,
   [FACE_POS_Y] = 16 + 1 * 8,
   [FACE_POS_Z] = 16 + 2 * 8,
   [FACE_NEG_X] = 16 + 3 * 8,
   [FACE_NEG_Y] = 16 + 4 * 8,
   [FACE_NEG_Z] = 16 + 5 * 8,
};


/**
 * Cube texture map layout for i830M-GM915 and
 * non-compressed cube texture map on GM945.
 *
 * Hardware layout looks like:
 *
 * +-------+-------+
 * |       |       |
 * |       |       |
 * |       |       |
 * |  +x   |  +y   |
 * |       |       |
 * |       |       |
 * |       |       |
 * |       |       |
 * +---+---+-------+
 * |   |   |       |
 * | +x| +y|       |
 * |   |   |       |
 * |   |   |       |
 * +-+-+---+  +z   |
 * | | |   |       |
 * +-+-+ +z|       |
 *   | |   |       |
 * +-+-+---+-------+
 * |       |       |
 * |       |       |
 * |       |       |
 * |  -x   |  -y   |
 * |       |       |
 * |       |       |
 * |       |       |
 * |       |       |
 * +---+---+-------+
 * |   |   |       |
 * | -x| -y|       |
 * |   |   |       |
 * |   |   |       |
 * +-+-+---+  -z   |
 * | | |   |       |
 * +-+-+ -z|       |
 *   | |   |       |
 *   +-+---+-------+
 *
 */
static void
i915_miptree_layout_cube(struct intel_mipmap_tree * mt)
{
   const GLuint dim = mt->physical_width0;
   GLuint face;
   GLuint lvlWidth = mt->physical_width0, lvlHeight = mt->physical_height0;
   GLint level;

   assert(lvlWidth == lvlHeight); /* cubemap images are square */

   /* double pitch for cube layouts */
   mt->total_width = dim * 2;
   mt->total_height = dim * 4;

   for (level = mt->first_level; level <= mt->last_level; level++) {
      intel_miptree_set_level_info(mt, level,
				   0, 0,
				   lvlWidth, lvlHeight,
				   6);
      lvlWidth /= 2;
      lvlHeight /= 2;
   }

   for (face = 0; face < 6; face++) {
      GLuint x = initial_offsets[face][0] * dim;
      GLuint y = initial_offsets[face][1] * dim;
      GLuint d = dim;

      for (level = mt->first_level; level <= mt->last_level; level++) {
	 intel_miptree_set_image_offset(mt, level, face, x, y);

	 if (d == 0)
	    printf("cube mipmap %d/%d (%d..%d) is 0x0\n",
		   face, level, mt->first_level, mt->last_level);

	 d >>= 1;
	 x += step_offsets[face][0] * d;
	 y += step_offsets[face][1] * d;
      }
   }
}

static void
i915_miptree_layout_3d(struct intel_mipmap_tree * mt)
{
   GLuint width = mt->physical_width0;
   GLuint height = mt->physical_height0;
   GLuint depth = mt->physical_depth0;
   GLuint stack_height = 0;
   GLint level;

   /* Calculate the size of a single slice. */
   mt->total_width = mt->physical_width0;

   /* XXX: hardware expects/requires 9 levels at minimum. */
   for (level = mt->first_level; level <= MAX2(8, mt->last_level); level++) {
      intel_miptree_set_level_info(mt, level, 0, mt->total_height,
				   width, height, depth);

      stack_height += MAX2(2, height);

      width = minify(width, 1);
      height = minify(height, 1);
      depth = minify(depth, 1);
   }

   /* Fixup depth image_offsets: */
   depth = mt->physical_depth0;
   for (level = mt->first_level; level <= mt->last_level; level++) {
      GLuint i;
      for (i = 0; i < depth; i++) {
	 intel_miptree_set_image_offset(mt, level, i,
					0, i * stack_height);
      }

      depth = minify(depth, 1);
   }

   /* Multiply slice size by texture depth for total size.  It's
    * remarkable how wasteful of memory the i915 texture layouts
    * are.  They are largely fixed in the i945.
    */
   mt->total_height = stack_height * mt->physical_depth0;
}

static void
i915_miptree_layout_2d(struct intel_mipmap_tree * mt)
{
   GLuint width = mt->physical_width0;
   GLuint height = mt->physical_height0;
   GLuint img_height;
   GLint level;

   mt->total_width = mt->physical_width0;
   mt->total_height = 0;

   for (level = mt->first_level; level <= mt->last_level; level++) {
      intel_miptree_set_level_info(mt, level,
				   0, mt->total_height,
				   width, height, 1);

      if (mt->compressed)
	 img_height = ALIGN(height, 4) / 4;
      else
	 img_height = ALIGN(height, 2);

      mt->total_height += img_height;

      width = minify(width, 1);
      height = minify(height, 1);
   }
}

void
i915_miptree_layout(struct intel_mipmap_tree * mt)
{
   switch (mt->target) {
   case GL_TEXTURE_CUBE_MAP:
      i915_miptree_layout_cube(mt);
      break;
   case GL_TEXTURE_3D:
      i915_miptree_layout_3d(mt);
      break;
   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_TEXTURE_RECTANGLE_ARB:
      i915_miptree_layout_2d(mt);
      break;
   default:
      _mesa_problem(NULL, "Unexpected tex target in i915_miptree_layout()");
      break;
   }

   DBG("%s: %dx%dx%d\n", __FUNCTION__,
       mt->total_width, mt->total_height, mt->cpp);
}


/**
 * Compressed cube texture map layout for GM945 and later.
 *
 * The hardware layout looks like the 830-915 layout, except for the small
 * sizes.  A zoomed in view of the layout for 945 is:
 *
 * +-------+-------+
 * |  8x8  |  8x8  |
 * |       |       |
 * |       |       |
 * |  +x   |  +y   |
 * |       |       |
 * |       |       |
 * |       |       |
 * |       |       |
 * +---+---+-------+
 * |4x4|   |  8x8  |
 * | +x|   |       |
 * |   |   |       |
 * |   |   |       |
 * +---+   |  +z   |
 * |4x4|   |       |
 * | +y|   |       |
 * |   |   |       |
 * +---+   +-------+
 *
 * ...
 *
 * +-------+-------+
 * |  8x8  |  8x8  |
 * |       |       |
 * |       |       |
 * |  -x   |  -y   |
 * |       |       |
 * |       |       |
 * |       |       |
 * |       |       |
 * +---+---+-------+
 * |4x4|   |  8x8  |
 * | -x|   |       |
 * |   |   |       |
 * |   |   |       |
 * +---+   |  -z   |
 * |4x4|   |       |
 * | -y|   |       |
 * |   |   |       |
 * +---+   +---+---+---+---+---+---+---+---+---+
 * |4x4|   |4x4|   |2x2|   |2x2|   |2x2|   |2x2|
 * | +z|   | -z|   | +x|   | +y|   | +z|   | -x| ...
 * |   |   |   |   |   |   |   |   |   |   |   |
 * +---+   +---+   +---+   +---+   +---+   +---+
 *
 * The bottom row continues with the remaining 2x2 then the 1x1 mip contents
 * in order, with each of them aligned to a 8x8 block boundary.  Thus, for
 * 32x32 cube maps and smaller, the bottom row layout is going to dictate the
 * pitch of the tree.  For a tree with 4x4 images, the pitch is at least
 * 14 * 8 = 112 texels, for 2x2 it is at least 12 * 8 texels, and for 1x1
 * it is 6 * 8 texels.
 */

static void
i945_miptree_layout_cube(struct intel_mipmap_tree * mt)
{
   const GLuint dim = mt->physical_width0;
   GLuint face;
   GLuint lvlWidth = mt->physical_width0, lvlHeight = mt->physical_height0;
   GLint level;

   assert(lvlWidth == lvlHeight); /* cubemap images are square */

   /* Depending on the size of the largest images, pitch can be
    * determined either by the old-style packing of cubemap faces,
    * or the final row of 4x4, 2x2 and 1x1 faces below this.
    */
   if (dim > 32)
      mt->total_width = dim * 2;
   else
      mt->total_width = 14 * 8;

   if (dim >= 4)
      mt->total_height = dim * 4 + 4;
   else
      mt->total_height = 4;

   /* Set all the levels to effectively occupy the whole rectangular region. */
   for (level = mt->first_level; level <= mt->last_level; level++) {
      intel_miptree_set_level_info(mt, level,
				   0, 0,
				   lvlWidth, lvlHeight, 6);
      lvlWidth /= 2;
      lvlHeight /= 2;
   }

   for (face = 0; face < 6; face++) {
      GLuint x = initial_offsets[face][0] * dim;
      GLuint y = initial_offsets[face][1] * dim;
      GLuint d = dim;

      if (dim == 4 && face >= 4) {
	 y = mt->total_height - 4;
	 x = (face - 4) * 8;
      } else if (dim < 4 && (face > 0 || mt->first_level > 0)) {
	 y = mt->total_height - 4;
	 x = face * 8;
      }

      for (level = mt->first_level; level <= mt->last_level; level++) {
	 intel_miptree_set_image_offset(mt, level, face, x, y);

	 d >>= 1;

	 switch (d) {
	 case 4:
	    switch (face) {
	    case FACE_POS_X:
	    case FACE_NEG_X:
	       x += step_offsets[face][0] * d;
	       y += step_offsets[face][1] * d;
	       break;
	    case FACE_POS_Y:
	    case FACE_NEG_Y:
	       y += 12;
	       x -= 8;
	       break;
	    case FACE_POS_Z:
	    case FACE_NEG_Z:
	       y = mt->total_height - 4;
	       x = (face - 4) * 8;
	       break;
	    }
	    break;

	 case 2:
	    y = mt->total_height - 4;
	    x = bottom_offsets[face];
	    break;

	 case 1:
	    x += 48;
	    break;

	 default:
	    x += step_offsets[face][0] * d;
	    y += step_offsets[face][1] * d;
	    break;
	 }
      }
   }
}

static void
i945_miptree_layout_3d(struct intel_mipmap_tree * mt)
{
   GLuint width = mt->physical_width0;
   GLuint height = mt->physical_height0;
   GLuint depth = mt->physical_depth0;
   GLuint pack_x_pitch, pack_x_nr;
   GLuint pack_y_pitch;
   GLuint level;

   mt->total_width = mt->physical_width0;
   mt->total_height = 0;

   pack_y_pitch = MAX2(mt->physical_height0, 2);
   pack_x_pitch = mt->total_width;
   pack_x_nr = 1;

   for (level = mt->first_level; level <= mt->last_level; level++) {
      GLint x = 0;
      GLint y = 0;
      GLint q, j;

      intel_miptree_set_level_info(mt, level,
				   0, mt->total_height,
				   width, height, depth);

      for (q = 0; q < depth;) {
	 for (j = 0; j < pack_x_nr && q < depth; j++, q++) {
	    intel_miptree_set_image_offset(mt, level, q, x, y);
	    x += pack_x_pitch;
	 }

	 x = 0;
	 y += pack_y_pitch;
      }

      mt->total_height += y;

      if (pack_x_pitch > 4) {
	 pack_x_pitch >>= 1;
	 pack_x_nr <<= 1;
	 assert(pack_x_pitch * pack_x_nr <= mt->total_width);
      }

      if (pack_y_pitch > 2) {
	 pack_y_pitch >>= 1;
      }

      width = minify(width, 1);
      height = minify(height, 1);
      depth = minify(depth, 1);
   }
}

void
i945_miptree_layout(struct intel_mipmap_tree * mt)
{
   switch (mt->target) {
   case GL_TEXTURE_CUBE_MAP:
      if (mt->compressed)
	 i945_miptree_layout_cube(mt);
      else
	 i915_miptree_layout_cube(mt);
      break;
   case GL_TEXTURE_3D:
      i945_miptree_layout_3d(mt);
      break;
   case GL_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_TEXTURE_RECTANGLE_ARB:
      i945_miptree_layout_2d(mt);
      break;
   default:
      _mesa_problem(NULL, "Unexpected tex target in i945_miptree_layout()");
      break;
   }

   DBG("%s: %dx%dx%d\n", __FUNCTION__,
       mt->total_width, mt->total_height, mt->cpp);
}
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2006 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d115 1
a115 3
i915_miptree_layout_cube(struct intel_context *intel,
			 struct intel_mipmap_tree * mt,
			 uint32_t tiling)
d117 1
a117 1
   const GLuint dim = mt->width0;
d119 1
a119 1
   GLuint lvlWidth = mt->width0, lvlHeight = mt->height0;
d129 1
a129 1
      intel_miptree_set_level_info(mt, level, 6,
d132 1
a132 1
				   1);
d157 1
a157 3
i915_miptree_layout_3d(struct intel_context *intel,
		       struct intel_mipmap_tree * mt,
		       uint32_t tiling)
d159 3
a161 3
   GLuint width = mt->width0;
   GLuint height = mt->height0;
   GLuint depth = mt->depth0;
d166 1
a166 1
   mt->total_width = mt->width0;
d170 1
a170 1
      intel_miptree_set_level_info(mt, level, depth, 0, mt->total_height,
d175 3
a177 3
      width = minify(width);
      height = minify(height);
      depth = minify(depth);
d181 1
a181 1
   depth = mt->depth0;
d189 1
a189 1
      depth = minify(depth);
d196 1
a196 1
   mt->total_height = stack_height * mt->depth0;
d200 1
a200 3
i915_miptree_layout_2d(struct intel_context *intel,
		       struct intel_mipmap_tree * mt,
		       uint32_t tiling)
d202 2
a203 2
   GLuint width = mt->width0;
   GLuint height = mt->height0;
d207 1
a207 1
   mt->total_width = mt->width0;
d211 1
a211 1
      intel_miptree_set_level_info(mt, level, 1,
d222 2
a223 2
      width = minify(width);
      height = minify(height);
d227 2
a228 3
GLboolean
i915_miptree_layout(struct intel_context *intel, struct intel_mipmap_tree * mt,
		    uint32_t tiling)
d232 1
a232 1
      i915_miptree_layout_cube(intel, mt, tiling);
d235 1
a235 1
      i915_miptree_layout_3d(intel, mt, tiling);
d240 1
a240 1
      i915_miptree_layout_2d(intel, mt, tiling);
a248 2

   return GL_TRUE;
d313 1
a313 3
i945_miptree_layout_cube(struct intel_context *intel,
			 struct intel_mipmap_tree * mt,
			 uint32_t tiling)
d315 1
a315 1
   const GLuint dim = mt->width0;
d317 1
a317 1
   GLuint lvlWidth = mt->width0, lvlHeight = mt->height0;
d338 1
a338 1
      intel_miptree_set_level_info(mt, level, 6,
d340 1
a340 1
				   lvlWidth, lvlHeight, 1);
d403 1
a403 3
i945_miptree_layout_3d(struct intel_context *intel,
		       struct intel_mipmap_tree * mt,
		       uint32_t tiling)
d405 3
a407 3
   GLuint width = mt->width0;
   GLuint height = mt->height0;
   GLuint depth = mt->depth0;
d412 1
a412 1
   mt->total_width = mt->width0;
d415 1
a415 1
   pack_y_pitch = MAX2(mt->height0, 2);
d424 1
a424 1
      intel_miptree_set_level_info(mt, level, depth,
d450 3
a452 3
      width = minify(width);
      height = minify(height);
      depth = minify(depth);
d456 2
a457 3
GLboolean
i945_miptree_layout(struct intel_context *intel, struct intel_mipmap_tree * mt,
		    uint32_t tiling)
d462 1
a462 1
	 i945_miptree_layout_cube(intel, mt, tiling);
d464 1
a464 1
	 i915_miptree_layout_cube(intel, mt, tiling);
d467 1
a467 1
      i945_miptree_layout_3d(intel, mt, tiling);
d472 1
a472 1
      i945_miptree_layout_2d(intel, mt, tiling, 1);
a480 2

   return GL_TRUE;
@


1.4
log
@Merge Mesa 7.10.3
@
text
@d222 1
a222 1
	 img_height = MAX2(1, height / 4);
d224 1
a224 1
	 img_height = (MAX2(2, height) + 1) & ~1;
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d70 2
a71 1
 * Cube texture map layout for i830M-GM915.
d127 1
a127 1
   mt->pitch = intel_miptree_pitch_align (intel, mt, tiling, dim * 2);
a132 1
				   /*OLD: mt->pitch, mt->total_height,*/
d170 1
a170 1
   mt->pitch = intel_miptree_pitch_align (intel, mt, tiling, mt->width0);
d213 1
a213 1
   mt->pitch = intel_miptree_pitch_align (intel, mt, tiling, mt->width0);
d254 2
a255 3
   DBG("%s: %dx%dx%d - sz 0x%x\n", __FUNCTION__,
       mt->pitch,
       mt->total_height, mt->cpp, mt->pitch * mt->total_height * mt->cpp);
d262 1
a262 1
 * Cube texture map layout for GM945 and later.
d338 1
a338 1
      mt->pitch = intel_miptree_pitch_align (intel, mt, tiling, dim * 2);
d340 1
a340 1
      mt->pitch = intel_miptree_pitch_align (intel, mt, tiling, 14 * 8);
d425 1
a425 1
   mt->pitch = intel_miptree_pitch_align (intel, mt, tiling, mt->width0);
d429 1
a429 1
   pack_x_pitch = mt->pitch;
d456 1
a456 1
	 assert(pack_x_pitch * pack_x_nr <= mt->pitch);
d493 2
a494 3
   DBG("%s: %dx%dx%d - sz 0x%x\n", __FUNCTION__,
       mt->pitch,
       mt->total_height, mt->cpp, mt->pitch * mt->total_height * mt->cpp);
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d58 11
d115 2
a116 1
			 struct intel_mipmap_tree * mt)
d126 1
a126 1
   mt->pitch = intel_miptree_pitch_align (intel, mt, dim * 2);
d148 2
a149 2
	    _mesa_printf("cube mipmap %d/%d (%d..%d) is 0x0\n",
			 face, level, mt->first_level, mt->last_level);
d160 2
a161 1
		       struct intel_mipmap_tree * mt)
d170 1
a170 1
   mt->pitch = intel_miptree_pitch_align (intel, mt, mt->width0);
d205 2
a206 1
		       struct intel_mipmap_tree * mt)
d213 1
a213 1
   mt->pitch = intel_miptree_pitch_align (intel, mt, mt->width0);
d234 2
a235 1
i915_miptree_layout(struct intel_context *intel, struct intel_mipmap_tree * mt)
d239 1
a239 1
      i915_miptree_layout_cube(intel, mt);
d242 1
a242 1
      i915_miptree_layout_3d(intel, mt);
d247 1
a247 1
      i915_miptree_layout_2d(intel, mt);
d315 1
a315 1
 * in order, with each of them aligned to a 4x4 block boundary.  Thus, for
d324 2
a325 1
			 struct intel_mipmap_tree * mt)
d339 1
a339 1
      mt->pitch = intel_miptree_pitch_align (intel, mt, dim * 2);
d341 1
a341 1
      mt->pitch = intel_miptree_pitch_align (intel, mt, 14 * 8);
d394 1
d398 1
a398 1
	    x = 16 + face * 8;
d416 2
a417 1
		       struct intel_mipmap_tree * mt)
d426 1
a426 1
   mt->pitch = intel_miptree_pitch_align (intel, mt, mt->width0);
d471 2
a472 1
i945_miptree_layout(struct intel_context *intel, struct intel_mipmap_tree * mt)
d476 4
a479 1
      i945_miptree_layout_cube(intel, mt);
d482 1
a482 1
      i945_miptree_layout_3d(intel, mt);
d487 1
a487 1
      i945_miptree_layout_2d(intel, mt);
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d34 1
a34 1
#include "macros.h"
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d34 1
a34 1
#include "main/macros.h"
a57 11

static GLint bottom_offsets[6] = {
   [FACE_POS_X] = 16 + 0 * 8,
   [FACE_POS_Y] = 16 + 1 * 8,
   [FACE_POS_Z] = 16 + 2 * 8,
   [FACE_NEG_X] = 16 + 3 * 8,
   [FACE_NEG_Y] = 16 + 4 * 8,
   [FACE_NEG_Z] = 16 + 5 * 8,
};


d59 1
a59 2
 * Cube texture map layout for i830M-GM915 and
 * non-compressed cube texture map on GM945.
d104 1
a104 2
			 struct intel_mipmap_tree * mt,
			 uint32_t tiling)
d114 1
a114 1
   mt->total_width = dim * 2;
d120 1
d136 2
a137 2
	    printf("cube mipmap %d/%d (%d..%d) is 0x0\n",
		   face, level, mt->first_level, mt->last_level);
d148 1
a148 2
		       struct intel_mipmap_tree * mt,
		       uint32_t tiling)
d157 1
a157 1
   mt->total_width = mt->width0;
d192 1
a192 2
		       struct intel_mipmap_tree * mt,
		       uint32_t tiling)
d199 1
a199 1
   mt->total_width = mt->width0;
d220 1
a220 2
i915_miptree_layout(struct intel_context *intel, struct intel_mipmap_tree * mt,
		    uint32_t tiling)
d224 1
a224 1
      i915_miptree_layout_cube(intel, mt, tiling);
d227 1
a227 1
      i915_miptree_layout_3d(intel, mt, tiling);
d232 1
a232 1
      i915_miptree_layout_2d(intel, mt, tiling);
d239 3
a241 2
   DBG("%s: %dx%dx%d\n", __FUNCTION__,
       mt->total_width, mt->total_height, mt->cpp);
d248 1
a248 1
 * Compressed cube texture map layout for GM945 and later.
d300 1
a300 1
 * in order, with each of them aligned to a 8x8 block boundary.  Thus, for
d309 1
a309 2
			 struct intel_mipmap_tree * mt,
			 uint32_t tiling)
d323 1
a323 1
      mt->total_width = dim * 2;
d325 1
a325 1
      mt->total_width = 14 * 8;
a377 1
	    break;
d381 1
a381 1
	    x = bottom_offsets[face];
d399 1
a399 2
		       struct intel_mipmap_tree * mt,
		       uint32_t tiling)
d408 1
a408 1
   mt->total_width = mt->width0;
d412 1
a412 1
   pack_x_pitch = mt->total_width;
d439 1
a439 1
	 assert(pack_x_pitch * pack_x_nr <= mt->total_width);
d453 1
a453 2
i945_miptree_layout(struct intel_context *intel, struct intel_mipmap_tree * mt,
		    uint32_t tiling)
d457 1
a457 4
      if (mt->compressed)
	 i945_miptree_layout_cube(intel, mt, tiling);
      else
	 i915_miptree_layout_cube(intel, mt, tiling);
d460 1
a460 1
      i945_miptree_layout_3d(intel, mt, tiling);
d465 1
a465 1
      i945_miptree_layout_2d(intel, mt, tiling, 1);
d472 3
a474 2
   DBG("%s: %dx%dx%d\n", __FUNCTION__,
       mt->total_width, mt->total_height, mt->cpp);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d115 3
a117 1
i915_miptree_layout_cube(struct intel_mipmap_tree * mt)
d119 1
a119 1
   const GLuint dim = mt->physical_width0;
d121 1
a121 1
   GLuint lvlWidth = mt->physical_width0, lvlHeight = mt->physical_height0;
d131 1
a131 1
      intel_miptree_set_level_info(mt, level,
d134 1
a134 1
				   6);
d159 3
a161 1
i915_miptree_layout_3d(struct intel_mipmap_tree * mt)
d163 3
a165 3
   GLuint width = mt->physical_width0;
   GLuint height = mt->physical_height0;
   GLuint depth = mt->physical_depth0;
d170 1
a170 1
   mt->total_width = mt->physical_width0;
d174 1
a174 1
      intel_miptree_set_level_info(mt, level, 0, mt->total_height,
d179 3
a181 3
      width = minify(width, 1);
      height = minify(height, 1);
      depth = minify(depth, 1);
d185 1
a185 1
   depth = mt->physical_depth0;
d193 1
a193 1
      depth = minify(depth, 1);
d200 1
a200 1
   mt->total_height = stack_height * mt->physical_depth0;
d204 3
a206 1
i915_miptree_layout_2d(struct intel_mipmap_tree * mt)
d208 2
a209 2
   GLuint width = mt->physical_width0;
   GLuint height = mt->physical_height0;
d213 1
a213 1
   mt->total_width = mt->physical_width0;
d217 1
a217 1
      intel_miptree_set_level_info(mt, level,
d222 1
a222 1
	 img_height = ALIGN(height, 4) / 4;
d224 1
a224 1
	 img_height = ALIGN(height, 2);
d228 2
a229 2
      width = minify(width, 1);
      height = minify(height, 1);
d233 3
a235 2
void
i915_miptree_layout(struct intel_mipmap_tree * mt)
d239 1
a239 1
      i915_miptree_layout_cube(mt);
d242 1
a242 1
      i915_miptree_layout_3d(mt);
d247 1
a247 1
      i915_miptree_layout_2d(mt);
d256 2
d322 3
a324 1
i945_miptree_layout_cube(struct intel_mipmap_tree * mt)
d326 1
a326 1
   const GLuint dim = mt->physical_width0;
d328 1
a328 1
   GLuint lvlWidth = mt->physical_width0, lvlHeight = mt->physical_height0;
d349 1
a349 1
      intel_miptree_set_level_info(mt, level,
d351 1
a351 1
				   lvlWidth, lvlHeight, 6);
d414 3
a416 1
i945_miptree_layout_3d(struct intel_mipmap_tree * mt)
d418 3
a420 3
   GLuint width = mt->physical_width0;
   GLuint height = mt->physical_height0;
   GLuint depth = mt->physical_depth0;
d425 1
a425 1
   mt->total_width = mt->physical_width0;
d428 1
a428 1
   pack_y_pitch = MAX2(mt->physical_height0, 2);
d437 1
a437 1
      intel_miptree_set_level_info(mt, level,
d463 3
a465 3
      width = minify(width, 1);
      height = minify(height, 1);
      depth = minify(depth, 1);
d469 3
a471 2
void
i945_miptree_layout(struct intel_mipmap_tree * mt)
d476 1
a476 1
	 i945_miptree_layout_cube(mt);
d478 1
a478 1
	 i915_miptree_layout_cube(mt);
d481 1
a481 1
      i945_miptree_layout_3d(mt);
d486 1
a486 1
      i945_miptree_layout_2d(mt);
d495 2
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2006 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
@


