head	1.4;
access;
symbols
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2013.09.05.14.05.09;	author jsg;	state dead;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.24;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.41;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@/*
 * Copyright (C) 2009 Nicolai Haehnle.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "radeon_dataflow.h"

#include "radeon_compiler.h"


struct updatemask_state {
	unsigned char Output[RC_REGISTER_MAX_INDEX];
	unsigned char Temporary[RC_REGISTER_MAX_INDEX];
	unsigned char Address;
	unsigned char Special[RC_NUM_SPECIAL_REGISTERS];
};

struct instruction_state {
	unsigned char WriteMask:4;
	unsigned char WriteALUResult:1;
	unsigned char SrcReg[3];
};

struct loopinfo {
	struct updatemask_state * Breaks;
	unsigned int BreakCount;
	unsigned int BreaksReserved;
};

struct branchinfo {
	unsigned int HaveElse:1;

	struct updatemask_state StoreEndif;
	struct updatemask_state StoreElse;
};

struct deadcode_state {
	struct radeon_compiler * C;
	struct instruction_state * Instructions;

	struct updatemask_state R;

	struct branchinfo * BranchStack;
	unsigned int BranchStackSize;
	unsigned int BranchStackReserved;

	struct loopinfo * LoopStack;
	unsigned int LoopStackSize;
	unsigned int LoopStackReserved;
};


static void or_updatemasks(
	struct updatemask_state * dst,
	struct updatemask_state * a,
	struct updatemask_state * b)
{
	for(unsigned int i = 0; i < RC_REGISTER_MAX_INDEX; ++i) {
		dst->Output[i] = a->Output[i] | b->Output[i];
		dst->Temporary[i] = a->Temporary[i] | b->Temporary[i];
	}

	for(unsigned int i = 0; i < RC_NUM_SPECIAL_REGISTERS; ++i)
		dst->Special[i] = a->Special[i] | b->Special[i];

	dst->Address = a->Address | b->Address;
}

static void push_break(struct deadcode_state *s)
{
	struct loopinfo * loop = &s->LoopStack[s->LoopStackSize - 1];
	memory_pool_array_reserve(&s->C->Pool, struct updatemask_state,
		loop->Breaks, loop->BreakCount, loop->BreaksReserved, 1);

	memcpy(&loop->Breaks[loop->BreakCount++], &s->R, sizeof(s->R));
}

static void push_loop(struct deadcode_state * s)
{
	memory_pool_array_reserve(&s->C->Pool, struct loopinfo, s->LoopStack,
			s->LoopStackSize, s->LoopStackReserved, 1);
	memset(&s->LoopStack[s->LoopStackSize++], 0, sizeof(struct loopinfo));
}

static void push_branch(struct deadcode_state * s)
{
	struct branchinfo * branch;

	memory_pool_array_reserve(&s->C->Pool, struct branchinfo, s->BranchStack,
			s->BranchStackSize, s->BranchStackReserved, 1);

	branch = &s->BranchStack[s->BranchStackSize++];
	branch->HaveElse = 0;
	memcpy(&branch->StoreEndif, &s->R, sizeof(s->R));
}

static unsigned char * get_used_ptr(struct deadcode_state *s, rc_register_file file, unsigned int index)
{
	if (file == RC_FILE_OUTPUT || file == RC_FILE_TEMPORARY) {
		if (index >= RC_REGISTER_MAX_INDEX) {
			rc_error(s->C, "%s: index %i is out of bounds for file %i\n", __FUNCTION__, index, file);
			return 0;
		}

		if (file == RC_FILE_OUTPUT)
			return &s->R.Output[index];
		else
			return &s->R.Temporary[index];
	} else if (file == RC_FILE_ADDRESS) {
		return &s->R.Address;
	} else if (file == RC_FILE_SPECIAL) {
		if (index >= RC_NUM_SPECIAL_REGISTERS) {
			rc_error(s->C, "%s: special file index %i out of bounds\n", __FUNCTION__, index);
			return 0;
		}

		return &s->R.Special[index];
	}

	return 0;
}

static void mark_used(struct deadcode_state * s, rc_register_file file, unsigned int index, unsigned int mask)
{
	unsigned char * pused = get_used_ptr(s, file, index);
	if (pused)
		*pused |= mask;
}

static void update_instruction(struct deadcode_state * s, struct rc_instruction * inst)
{
	const struct rc_opcode_info * opcode = rc_get_opcode_info(inst->U.I.Opcode);
	struct instruction_state * insts = &s->Instructions[inst->IP];
	unsigned int usedmask = 0;
	unsigned int srcmasks[3];

	if (opcode->HasDstReg) {
		unsigned char * pused = get_used_ptr(s, inst->U.I.DstReg.File, inst->U.I.DstReg.Index);
		if (pused) {
			usedmask = *pused & inst->U.I.DstReg.WriteMask;
			*pused &= ~usedmask;
		}
	}

	insts->WriteMask |= usedmask;

	if (inst->U.I.WriteALUResult) {
		unsigned char * pused = get_used_ptr(s, RC_FILE_SPECIAL, RC_SPECIAL_ALU_RESULT);
		if (pused && *pused) {
			if (inst->U.I.WriteALUResult == RC_ALURESULT_X)
				usedmask |= RC_MASK_X;
			else if (inst->U.I.WriteALUResult == RC_ALURESULT_W)
				usedmask |= RC_MASK_W;

			*pused = 0;
			insts->WriteALUResult = 1;
		}
	}

	rc_compute_sources_for_writemask(inst, usedmask, srcmasks);

	for(unsigned int src = 0; src < opcode->NumSrcRegs; ++src) {
		unsigned int refmask = 0;
		unsigned int newsrcmask = srcmasks[src] & ~insts->SrcReg[src];
		insts->SrcReg[src] |= newsrcmask;

		for(unsigned int chan = 0; chan < 4; ++chan) {
			if (GET_BIT(newsrcmask, chan))
				refmask |= 1 << GET_SWZ(inst->U.I.SrcReg[src].Swizzle, chan);
		}

		/* get rid of spurious bits from ZERO, ONE, etc. swizzles */
		refmask &= RC_MASK_XYZW;

		if (!refmask)
			continue;

		mark_used(s, inst->U.I.SrcReg[src].File, inst->U.I.SrcReg[src].Index, refmask);

		if (inst->U.I.SrcReg[src].RelAddr)
			mark_used(s, RC_FILE_ADDRESS, 0, RC_MASK_X);
	}
}

static void mark_output_use(void * data, unsigned int index, unsigned int mask)
{
	struct deadcode_state * s = data;

	mark_used(s, RC_FILE_OUTPUT, index, mask);
}

void rc_dataflow_deadcode(struct radeon_compiler * c, void *user)
{
	struct deadcode_state s;
	unsigned int nr_instructions;
	rc_dataflow_mark_outputs_fn dce = (rc_dataflow_mark_outputs_fn)user;
	unsigned int ip;

	memset(&s, 0, sizeof(s));
	s.C = c;

	nr_instructions = rc_recompute_ips(c);
	s.Instructions = memory_pool_malloc(&c->Pool, sizeof(struct instruction_state)*nr_instructions);
	memset(s.Instructions, 0, sizeof(struct instruction_state)*nr_instructions);

	dce(c, &s, &mark_output_use);

	for(struct rc_instruction * inst = c->Program.Instructions.Prev;
	    inst != &c->Program.Instructions;
	    inst = inst->Prev) {
		const struct rc_opcode_info * opcode = rc_get_opcode_info(inst->U.I.Opcode);

		switch(opcode->Opcode){
		/* Mark all sources in the loop body as used before doing
		 * normal deadcode analysis.  This is probably not optimal.
		 */
		case RC_OPCODE_ENDLOOP:
		{
			int endloops = 1;
			struct rc_instruction *ptr;
			for(ptr = inst->Prev; endloops > 0; ptr = ptr->Prev){
				opcode = rc_get_opcode_info(ptr->U.I.Opcode);
				if(ptr->U.I.Opcode == RC_OPCODE_BGNLOOP){
					endloops--;
					continue;
				}
				if(ptr->U.I.Opcode == RC_OPCODE_ENDLOOP){
					endloops++;
					continue;
				}
				if(opcode->HasDstReg){
					int src = 0;
					unsigned int srcmasks[3];
					rc_compute_sources_for_writemask(ptr,
						ptr->U.I.DstReg.WriteMask, srcmasks);
					for(src=0; src < opcode->NumSrcRegs; src++){
						mark_used(&s,
							ptr->U.I.SrcReg[src].File,
							ptr->U.I.SrcReg[src].Index,
							srcmasks[src]);
					}
				}
			}
			push_loop(&s);
			break;
		}
		case RC_OPCODE_BRK:
			push_break(&s);
			break;
		case RC_OPCODE_BGNLOOP:
		{
			unsigned int i;
			struct loopinfo * loop = &s.LoopStack[s.LoopStackSize-1];
			for(i = 0; i < loop->BreakCount; i++) {
				or_updatemasks(&s.R, &s.R, &loop->Breaks[i]);
			}
			break;
		}
		case RC_OPCODE_CONT:
			break;
		case RC_OPCODE_ENDIF:
			push_branch(&s);
			break;
		default:
			if (opcode->IsFlowControl && s.BranchStackSize) {
				struct branchinfo * branch = &s.BranchStack[s.BranchStackSize-1];
				if (opcode->Opcode == RC_OPCODE_IF) {
					or_updatemasks(&s.R,
							&s.R,
							branch->HaveElse ? &branch->StoreElse : &branch->StoreEndif);

					s.BranchStackSize--;
				} else if (opcode->Opcode == RC_OPCODE_ELSE) {
					if (branch->HaveElse) {
						rc_error(c, "%s: Multiple ELSE for one IF/ENDIF\n", __FUNCTION__);
					} else {
						memcpy(&branch->StoreElse, &s.R, sizeof(s.R));
						memcpy(&s.R, &branch->StoreEndif, sizeof(s.R));
						branch->HaveElse = 1;
					}
				} else {
					rc_error(c, "%s: Unhandled control flow instruction %s\n", __FUNCTION__, opcode->Name);
				}
			}
		}

		update_instruction(&s, inst);
	}

	ip = 0;
	for(struct rc_instruction * inst = c->Program.Instructions.Next;
	    inst != &c->Program.Instructions;
	    inst = inst->Next, ++ip) {
		const struct rc_opcode_info * opcode = rc_get_opcode_info(inst->U.I.Opcode);
		int dead = 1;
		unsigned int srcmasks[3];
		unsigned int usemask;

		if (!opcode->HasDstReg) {
			dead = 0;
		} else {
			inst->U.I.DstReg.WriteMask = s.Instructions[ip].WriteMask;
			if (s.Instructions[ip].WriteMask)
				dead = 0;

			if (s.Instructions[ip].WriteALUResult)
				dead = 0;
			else
				inst->U.I.WriteALUResult = RC_ALURESULT_NONE;
		}

		if (dead) {
			struct rc_instruction * todelete = inst;
			inst = inst->Prev;
			rc_remove_instruction(todelete);
			continue;
		}

		usemask = s.Instructions[ip].WriteMask;

		if (inst->U.I.WriteALUResult == RC_ALURESULT_X)
			usemask |= RC_MASK_X;
		else if (inst->U.I.WriteALUResult == RC_ALURESULT_W)
			usemask |= RC_MASK_W;

		rc_compute_sources_for_writemask(inst, usemask, srcmasks);

		for(unsigned int src = 0; src < 3; ++src) {
			for(unsigned int chan = 0; chan < 4; ++chan) {
				if (!GET_BIT(srcmasks[src], chan))
					SET_SWZ(inst->U.I.SrcReg[src].Swizzle, chan, RC_SWIZZLE_UNUSED);
			}
		}
	}

	rc_calculate_inputs_outputs(c);
}
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.2
log
@Merge Mesa 7.10.3
@
text
@d163 1
a163 2
			if (!inst->U.I.DstReg.RelAddr)
				*pused &= ~usedmask;
a164 3

		if (inst->U.I.DstReg.RelAddr)
			mark_used(s, RC_FILE_ADDRESS, 0, RC_MASK_X);
a217 1
	unsigned has_temp_reladdr_src = 0;
a220 12
	/* Give up if there is relative addressing of destination operands. */
	for(struct rc_instruction * inst = c->Program.Instructions.Next;
	    inst != &c->Program.Instructions;
	    inst = inst->Next) {
		const struct rc_opcode_info *opcode = rc_get_opcode_info(inst->U.I.Opcode);
		if (opcode->HasDstReg &&
		    inst->U.I.DstReg.WriteMask &&
		    inst->U.I.DstReg.RelAddr) {
			return;
		}
	}

a304 26
				}
			}

			if (!has_temp_reladdr_src) {
				for (unsigned i = 0; i < opcode->NumSrcRegs; i++) {
					if (inst->U.I.SrcReg[i].File == RC_FILE_TEMPORARY &&
					    inst->U.I.SrcReg[i].RelAddr) {
						/* If there is a register read from a temporary file with relative addressing,
						 * mark all preceding written registers as used. */
						for (struct rc_instruction *ptr = inst->Prev;
						     ptr != &c->Program.Instructions;
						     ptr = ptr->Prev) {
							opcode = rc_get_opcode_info(ptr->U.I.Opcode);
							if (opcode->HasDstReg &&
							    ptr->U.I.DstReg.File == RC_FILE_TEMPORARY &&
							    ptr->U.I.DstReg.WriteMask) {
								mark_used(&s,
									  ptr->U.I.DstReg.File,
									  ptr->U.I.DstReg.Index,
									  ptr->U.I.DstReg.WriteMask);
							}
						}

						has_temp_reladdr_src = 1;
						break;
					}
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d46 6
d68 4
d91 1
a91 1
static void push_branch(struct deadcode_state * s)
d93 6
a98 3
	if (s->BranchStackSize >= s->BranchStackReserved) {
		unsigned int new_reserve = 2 * s->BranchStackReserved;
		struct branchinfo * new_stack;
d100 6
a105 2
		if (!new_reserve)
			new_reserve = 4;
d107 3
a109 2
		new_stack = memory_pool_malloc(&s->C->Pool, new_reserve * sizeof(struct branchinfo));
		memcpy(new_stack, s->BranchStack, s->BranchStackSize * sizeof(struct branchinfo));
d111 2
a112 3
		s->BranchStack = new_stack;
		s->BranchStackReserved = new_reserve;
	}
d114 1
a114 1
	struct branchinfo * branch = &s->BranchStack[s->BranchStackSize++];
d157 1
d163 2
a164 1
			*pused &= ~usedmask;
d166 3
d186 1
a186 2
	unsigned int srcmasks[3];
	rc_compute_sources_for_writemask(opcode, usedmask, srcmasks);
d218 1
a218 1
void rc_dataflow_deadcode(struct radeon_compiler * c, rc_dataflow_mark_outputs_fn dce, void * userdata)
d222 15
d245 1
a245 1
	dce(userdata, &s, &mark_output_use);
d252 63
a314 21
		if (opcode->IsFlowControl) {
			if (opcode->Opcode == RC_OPCODE_ENDIF) {
				push_branch(&s);
			} else {
				if (s.BranchStackSize) {
					struct branchinfo * branch = &s.BranchStack[s.BranchStackSize-1];

					if (opcode->Opcode == RC_OPCODE_IF) {
						or_updatemasks(&s.R,
								&s.R,
								branch->HaveElse ? &branch->StoreElse : &branch->StoreEndif);

						s.BranchStackSize--;
					} else if (opcode->Opcode == RC_OPCODE_ELSE) {
						if (branch->HaveElse) {
							rc_error(c, "%s: Multiple ELSE for one IF/ENDIF\n", __FUNCTION__);
						} else {
							memcpy(&branch->StoreElse, &s.R, sizeof(s.R));
							memcpy(&s.R, &branch->StoreEndif, sizeof(s.R));
							branch->HaveElse = 1;
						}
d316 3
a318 1
						rc_error(c, "%s: Unhandled control flow instruction %s\n", __FUNCTION__, opcode->Name);
d321 27
a347 1
					rc_error(c, "%s: Unexpected control flow instruction\n", __FUNCTION__);
d355 1
a355 1
	unsigned int ip = 0;
d359 1
a359 1
		const struct rc_opcode_info * opcode = rc_get_opcode_info(inst->U.I.Opcode);\
d361 2
d384 1
a384 2
		unsigned int srcmasks[3];
		unsigned int usemask = s.Instructions[ip].WriteMask;
d391 1
a391 1
		rc_compute_sources_for_writemask(opcode, usemask, srcmasks);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a45 6
struct loopinfo {
	struct updatemask_state * Breaks;
	unsigned int BreakCount;
	unsigned int BreaksReserved;
};

a61 4

	struct loopinfo * LoopStack;
	unsigned int LoopStackSize;
	unsigned int LoopStackReserved;
d81 1
a81 1
static void push_break(struct deadcode_state *s)
d83 3
a85 3
	struct loopinfo * loop = &s->LoopStack[s->LoopStackSize - 1];
	memory_pool_array_reserve(&s->C->Pool, struct updatemask_state,
		loop->Breaks, loop->BreakCount, loop->BreaksReserved, 1);
d87 2
a88 2
	memcpy(&loop->Breaks[loop->BreakCount++], &s->R, sizeof(s->R));
}
d90 2
a91 6
static void push_loop(struct deadcode_state * s)
{
	memory_pool_array_reserve(&s->C->Pool, struct loopinfo, s->LoopStack,
			s->LoopStackSize, s->LoopStackReserved, 1);
	memset(&s->LoopStack[s->LoopStackSize++], 0, sizeof(struct loopinfo));
}
d93 3
a95 3
static void push_branch(struct deadcode_state * s)
{
	struct branchinfo * branch;
d97 1
a97 4
	memory_pool_array_reserve(&s->C->Pool, struct branchinfo, s->BranchStack,
			s->BranchStackSize, s->BranchStackReserved, 1);

	branch = &s->BranchStack[s->BranchStackSize++];
a139 1
	unsigned int srcmasks[3];
d145 1
a145 2
			if (!inst->U.I.DstReg.RelAddr)
				*pused &= ~usedmask;
a146 3

		if (inst->U.I.DstReg.RelAddr)
			mark_used(s, RC_FILE_ADDRESS, 0, RC_MASK_X);
d164 2
a165 1
	rc_compute_sources_for_writemask(inst, usedmask, srcmasks);
d197 1
a197 1
void rc_dataflow_deadcode(struct radeon_compiler * c, void *user)
a200 15
	unsigned has_temp_reladdr_src = 0;
	rc_dataflow_mark_outputs_fn dce = (rc_dataflow_mark_outputs_fn)user;
	unsigned int ip;

	/* Give up if there is relative addressing of destination operands. */
	for(struct rc_instruction * inst = c->Program.Instructions.Next;
	    inst != &c->Program.Instructions;
	    inst = inst->Next) {
		const struct rc_opcode_info *opcode = rc_get_opcode_info(inst->U.I.Opcode);
		if (opcode->HasDstReg &&
		    inst->U.I.DstReg.WriteMask &&
		    inst->U.I.DstReg.RelAddr) {
			return;
		}
	}
d209 1
a209 1
	dce(c, &s, &mark_output_use);
d216 21
a236 63
		switch(opcode->Opcode){
		/* Mark all sources in the loop body as used before doing
		 * normal deadcode analysis.  This is probably not optimal.
		 */
		case RC_OPCODE_ENDLOOP:
		{
			int endloops = 1;
			struct rc_instruction *ptr;
			for(ptr = inst->Prev; endloops > 0; ptr = ptr->Prev){
				opcode = rc_get_opcode_info(ptr->U.I.Opcode);
				if(ptr->U.I.Opcode == RC_OPCODE_BGNLOOP){
					endloops--;
					continue;
				}
				if(ptr->U.I.Opcode == RC_OPCODE_ENDLOOP){
					endloops++;
					continue;
				}
				if(opcode->HasDstReg){
					int src = 0;
					unsigned int srcmasks[3];
					rc_compute_sources_for_writemask(ptr,
						ptr->U.I.DstReg.WriteMask, srcmasks);
					for(src=0; src < opcode->NumSrcRegs; src++){
						mark_used(&s,
							ptr->U.I.SrcReg[src].File,
							ptr->U.I.SrcReg[src].Index,
							srcmasks[src]);
					}
				}
			}
			push_loop(&s);
			break;
		}
		case RC_OPCODE_BRK:
			push_break(&s);
			break;
		case RC_OPCODE_BGNLOOP:
		{
			unsigned int i;
			struct loopinfo * loop = &s.LoopStack[s.LoopStackSize-1];
			for(i = 0; i < loop->BreakCount; i++) {
				or_updatemasks(&s.R, &s.R, &loop->Breaks[i]);
			}
			break;
		}
		case RC_OPCODE_CONT:
			break;
		case RC_OPCODE_ENDIF:
			push_branch(&s);
			break;
		default:
			if (opcode->IsFlowControl && s.BranchStackSize) {
				struct branchinfo * branch = &s.BranchStack[s.BranchStackSize-1];
				if (opcode->Opcode == RC_OPCODE_IF) {
					or_updatemasks(&s.R,
							&s.R,
							branch->HaveElse ? &branch->StoreElse : &branch->StoreEndif);

					s.BranchStackSize--;
				} else if (opcode->Opcode == RC_OPCODE_ELSE) {
					if (branch->HaveElse) {
						rc_error(c, "%s: Multiple ELSE for one IF/ENDIF\n", __FUNCTION__);
d238 1
a238 3
						memcpy(&branch->StoreElse, &s.R, sizeof(s.R));
						memcpy(&s.R, &branch->StoreEndif, sizeof(s.R));
						branch->HaveElse = 1;
d241 1
a241 27
					rc_error(c, "%s: Unhandled control flow instruction %s\n", __FUNCTION__, opcode->Name);
				}
			}

			if (!has_temp_reladdr_src) {
				for (unsigned i = 0; i < opcode->NumSrcRegs; i++) {
					if (inst->U.I.SrcReg[i].File == RC_FILE_TEMPORARY &&
					    inst->U.I.SrcReg[i].RelAddr) {
						/* If there is a register read from a temporary file with relative addressing,
						 * mark all preceding written registers as used. */
						for (struct rc_instruction *ptr = inst->Prev;
						     ptr != &c->Program.Instructions;
						     ptr = ptr->Prev) {
							opcode = rc_get_opcode_info(ptr->U.I.Opcode);
							if (opcode->HasDstReg &&
							    ptr->U.I.DstReg.File == RC_FILE_TEMPORARY &&
							    ptr->U.I.DstReg.WriteMask) {
								mark_used(&s,
									  ptr->U.I.DstReg.File,
									  ptr->U.I.DstReg.Index,
									  ptr->U.I.DstReg.WriteMask);
							}
						}

						has_temp_reladdr_src = 1;
						break;
					}
d249 1
a249 1
	ip = 0;
d253 1
a253 1
		const struct rc_opcode_info * opcode = rc_get_opcode_info(inst->U.I.Opcode);
a254 2
		unsigned int srcmasks[3];
		unsigned int usemask;
d276 2
a277 1
		usemask = s.Instructions[ip].WriteMask;
d284 1
a284 1
		rc_compute_sources_for_writemask(inst, usemask, srcmasks);
@

