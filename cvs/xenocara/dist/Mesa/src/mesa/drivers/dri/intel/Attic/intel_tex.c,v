head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.09.05.14.04.35;	author jsg;	state dead;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.38;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@#include "swrast/swrast.h"
#include "main/renderbuffer.h"
#include "main/texobj.h"
#include "main/teximage.h"
#include "main/mipmap.h"
#include "drivers/common/meta.h"
#include "intel_context.h"
#include "intel_mipmap_tree.h"
#include "intel_tex.h"

#define FILE_DEBUG_FLAG DEBUG_TEXTURE

static struct gl_texture_image *
intelNewTextureImage(struct gl_context * ctx)
{
   DBG("%s\n", __FUNCTION__);
   (void) ctx;
   return (struct gl_texture_image *) CALLOC_STRUCT(intel_texture_image);
}


static struct gl_texture_object *
intelNewTextureObject(struct gl_context * ctx, GLuint name, GLenum target)
{
   struct intel_texture_object *obj = CALLOC_STRUCT(intel_texture_object);

   DBG("%s\n", __FUNCTION__);
   _mesa_initialize_texture_object(&obj->base, name, target);

   return &obj->base;
}

static void 
intelDeleteTextureObject(struct gl_context *ctx,
			 struct gl_texture_object *texObj)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_texture_object *intelObj = intel_texture_object(texObj);

   if (intelObj->mt)
      intel_miptree_release(intel, &intelObj->mt);

   _mesa_delete_texture_object(ctx, texObj);
}


static void
intelFreeTextureImageData(struct gl_context * ctx, struct gl_texture_image *texImage)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_texture_image *intelImage = intel_texture_image(texImage);

   DBG("%s\n", __FUNCTION__);

   if (intelImage->mt) {
      intel_miptree_release(intel, &intelImage->mt);
   }

   if (texImage->Data) {
      _mesa_free_texmemory(texImage->Data);
      texImage->Data = NULL;
   }

   if (intelImage->depth_rb) {
      _mesa_reference_renderbuffer(&intelImage->depth_rb, NULL);
   }

   if (intelImage->stencil_rb) {
      _mesa_reference_renderbuffer(&intelImage->stencil_rb, NULL);
   }
}

/**
 * Called via ctx->Driver.GenerateMipmap()
 * This is basically a wrapper for _mesa_meta_GenerateMipmap() which checks
 * if we'll be using software mipmap generation.  In that case, we need to
 * map/unmap the base level texture image.
 */
static void
intelGenerateMipmap(struct gl_context *ctx, GLenum target,
                    struct gl_texture_object *texObj)
{
   if (_mesa_meta_check_generate_mipmap_fallback(ctx, target, texObj)) {
      /* sw path: need to map texture images */
      struct intel_context *intel = intel_context(ctx);
      struct intel_texture_object *intelObj = intel_texture_object(texObj);
      struct gl_texture_image *first_image = texObj->Image[0][texObj->BaseLevel];

      fallback_debug("%s - fallback to swrast\n", __FUNCTION__);

      intel_tex_map_level_images(intel, intelObj, texObj->BaseLevel);
      _mesa_generate_mipmap(ctx, target, texObj);
      intel_tex_unmap_level_images(intel, intelObj, texObj->BaseLevel);

      if (!_mesa_is_format_compressed(first_image->TexFormat)) {
         GLuint nr_faces = (texObj->Target == GL_TEXTURE_CUBE_MAP) ? 6 : 1;
         GLuint face, i;
         /* Update the level information in our private data in the new images,
          * since it didn't get set as part of a normal TexImage path.
          */
         for (face = 0; face < nr_faces; face++) {
            for (i = texObj->BaseLevel + 1; i < texObj->MaxLevel; i++) {
               struct intel_texture_image *intelImage =
                  intel_texture_image(texObj->Image[face][i]);
               if (!intelImage)
                  break;
               intelImage->level = i;
               intelImage->face = face;
               /* Unreference the miptree to signal that the new Data is a
                * bare pointer from mesa.
                */
               intel_miptree_release(intel, &intelImage->mt);
            }
         }
      }
   }
   else {
      _mesa_meta_GenerateMipmap(ctx, target, texObj);
   }
}


void
intelInitTextureFuncs(struct dd_function_table *functions)
{
   functions->GenerateMipmap = intelGenerateMipmap;

   functions->NewTextureObject = intelNewTextureObject;
   functions->NewTextureImage = intelNewTextureImage;
   functions->DeleteTexture = intelDeleteTextureObject;
   functions->FreeTexImageData = intelFreeTextureImageData;
}
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.4
log
@Merge Mesa 7.10.3
@
text
@d2 1
d63 8
d87 1
d95 1
a95 1
      {
a125 1
   functions->ChooseTextureFormat = intelChooseTextureFormat;
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a11 17
static GLboolean
intelIsTextureResident(GLcontext * ctx, struct gl_texture_object *texObj)
{
#if 0
   struct intel_context *intel = intel_context(ctx);
   struct intel_texture_object *intelObj = intel_texture_object(texObj);

   return
      intelObj->mt &&
      intelObj->mt->region &&
      intel_is_region_resident(intel, intelObj->mt->region);
#endif
   return 1;
}



d13 1
a13 1
intelNewTextureImage(GLcontext * ctx)
d22 1
a22 1
intelNewTextureObject(GLcontext * ctx, GLuint name, GLenum target)
d33 1
a33 1
intelDeleteTextureObject(GLcontext *ctx,
d47 1
a47 1
intelFreeTextureImageData(GLcontext * ctx, struct gl_texture_image *texImage)
a63 82

/* The system memcpy (at least on ubuntu 5.10) has problems copying
 * to agp (writecombined) memory from a source which isn't 64-byte
 * aligned - there is a 4x performance falloff.
 *
 * The x86 __memcpy is immune to this but is slightly slower
 * (10%-ish) than the system memcpy.
 *
 * The sse_memcpy seems to have a slight cliff at 64/32 bytes, but
 * isn't much faster than x86_memcpy for agp copies.
 * 
 * TODO: switch dynamically.
 */
static void *
do_memcpy(void *dest, const void *src, size_t n)
{
   if ((((unsigned long) src) & 63) || (((unsigned long) dest) & 63)) {
      return __memcpy(dest, src, n);
   }
   else
      return memcpy(dest, src, n);
}


#if DO_DEBUG && !defined(__ia64__)

#ifndef __x86_64__
static unsigned
fastrdtsc(void)
{
   unsigned eax;
   __asm__ volatile ("\t"
                     "pushl  %%ebx\n\t"
                     "cpuid\n\t" ".byte 0x0f, 0x31\n\t"
                     "popl %%ebx\n":"=a" (eax)
                     :"0"(0)
                     :"ecx", "edx", "cc");

   return eax;
}
#else
static unsigned
fastrdtsc(void)
{
   unsigned eax;
   __asm__ volatile ("\t" "cpuid\n\t" ".byte 0x0f, 0x31\n\t":"=a" (eax)
                     :"0"(0)
                     :"ecx", "edx", "ebx", "cc");

   return eax;
}
#endif

static unsigned
time_diff(unsigned t, unsigned t2)
{
   return ((t < t2) ? t2 - t : 0xFFFFFFFFU - (t - t2 - 1));
}


static void *
timed_memcpy(void *dest, const void *src, size_t n)
{
   void *ret;
   unsigned t1, t2;
   double rate;

   if ((((unsigned) src) & 63) || (((unsigned) dest) & 63))
      printf("Warning - non-aligned texture copy!\n");

   t1 = fastrdtsc();
   ret = do_memcpy(dest, src, n);
   t2 = fastrdtsc();

   rate = time_diff(t1, t2);
   rate /= (double) n;
   printf("timed_memcpy: %u %u --> %f clocks/byte\n", t1, t2, rate);
   return ret;
}
#endif /* DO_DEBUG */


d71 1
a71 1
intelGenerateMipmap(GLcontext *ctx, GLenum target,
d78 3
a122 9
   functions->UpdateTexturePalette = 0;
   functions->IsTextureResident = intelIsTextureResident;

#if DO_DEBUG && !defined(__ia64__)
   if (INTEL_DEBUG & DEBUG_BUFMGR)
      functions->TextureMemCpy = timed_memcpy;
   else
#endif
      functions->TextureMemCpy = do_memcpy;
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d5 1
d97 1
a97 1
   if ((((unsigned) src) & 63) || (((unsigned) dest) & 63)) {
d149 1
a149 1
      _mesa_printf("Warning - non-aligned texture copy!\n");
d157 1
a157 1
   _mesa_printf("timed_memcpy: %u %u --> %f clocks/byte\n", t1, t2, rate);
d162 1
d164 4
a167 10
 * Generate new mipmap data from BASE+1 to BASE+p (the minimally-sized mipmap
 * level).
 *
 * The texture object's miptree must be mapped.
 *
 * It would be really nice if this was just called by Mesa whenever mipmaps
 * needed to be regenerated, rather than us having to remember to do so in
 * each texture image modification path.
 *
 * This function should also include an accelerated path.
d169 3
a171 3
void
intel_generate_mipmap(GLcontext *ctx, GLenum target,
                      struct gl_texture_object *texObj)
d173 28
a200 24
   struct intel_context *intel = intel_context(ctx);
   struct intel_texture_object *intelObj = intel_texture_object(texObj);
   GLuint nr_faces = (intelObj->base.Target == GL_TEXTURE_CUBE_MAP) ? 6 : 1;
   int face, i;

   _mesa_generate_mipmap(ctx, target, texObj);

   /* Update the level information in our private data in the new images, since
    * it didn't get set as part of a normal TexImage path.
    */
   for (face = 0; face < nr_faces; face++) {
      for (i = texObj->BaseLevel + 1; i < texObj->MaxLevel; i++) {
         struct intel_texture_image *intelImage;

	 intelImage = intel_texture_image(texObj->Image[face][i]);
	 if (intelImage == NULL)
	    break;

	 intelImage->level = i;
	 intelImage->face = face;
	 /* Unreference the miptree to signal that the new Data is a bare
	  * pointer from mesa.
	  */
	 intel_miptree_release(intel, &intelImage->mt);
d203 3
a207 9
static void intelGenerateMipmap(GLcontext *ctx, GLenum target, struct gl_texture_object *texObj)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_texture_object *intelObj = intel_texture_object(texObj);

   intel_tex_map_level_images(intel, intelObj, texObj->BaseLevel);
   intel_generate_mipmap(ctx, target, texObj);
   intel_tex_unmap_level_images(intel, intelObj, texObj->BaseLevel);
}
a212 11
   functions->TexImage1D = intelTexImage1D;
   functions->TexImage2D = intelTexImage2D;
   functions->TexImage3D = intelTexImage3D;
   functions->TexSubImage1D = intelTexSubImage1D;
   functions->TexSubImage2D = intelTexSubImage2D;
   functions->TexSubImage3D = intelTexSubImage3D;
   functions->CopyTexImage1D = intelCopyTexImage1D;
   functions->CopyTexImage2D = intelCopyTexImage2D;
   functions->CopyTexSubImage1D = intelCopyTexSubImage1D;
   functions->CopyTexSubImage2D = intelCopyTexSubImage2D;
   functions->GetTexImage = intelGetTexImage;
a213 5

   /* compressed texture functions */
   functions->CompressedTexImage2D = intelCompressedTexImage2D;
   functions->CompressedTexSubImage2D = intelCompressedTexSubImage2D;
   functions->GetCompressedTexImage = intelGetCompressedTexImage;
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d2 3
a4 3
#include "texobj.h"
#include "teximage.h"
#include "mipmap.h"
a224 1
#ifdef I915
a228 6
#else
   functions->CopyTexImage1D = _swrast_copy_teximage1d;
   functions->CopyTexImage2D = _swrast_copy_teximage2d;
   functions->CopyTexSubImage1D = _swrast_copy_texsubimage1d;
   functions->CopyTexSubImage2D = _swrast_copy_texsubimage2d;
#endif
d234 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d2 3
a4 4
#include "main/texobj.h"
#include "main/teximage.h"
#include "main/mipmap.h"
#include "drivers/common/meta.h"
d11 17
d29 1
a29 1
intelNewTextureImage(struct gl_context * ctx)
d38 1
a38 1
intelNewTextureObject(struct gl_context * ctx, GLuint name, GLenum target)
d49 1
a49 1
intelDeleteTextureObject(struct gl_context *ctx,
d63 1
a63 1
intelFreeTextureImageData(struct gl_context * ctx, struct gl_texture_image *texImage)
d80 81
d162 10
a171 4
 * Called via ctx->Driver.GenerateMipmap()
 * This is basically a wrapper for _mesa_meta_GenerateMipmap() which checks
 * if we'll be using software mipmap generation.  In that case, we need to
 * map/unmap the base level texture image.
d173 3
a175 3
static void
intelGenerateMipmap(struct gl_context *ctx, GLenum target,
                    struct gl_texture_object *texObj)
d177 24
a200 31
   if (_mesa_meta_check_generate_mipmap_fallback(ctx, target, texObj)) {
      /* sw path: need to map texture images */
      struct intel_context *intel = intel_context(ctx);
      struct intel_texture_object *intelObj = intel_texture_object(texObj);

      fallback_debug("%s - fallback to swrast\n", __FUNCTION__);

      intel_tex_map_level_images(intel, intelObj, texObj->BaseLevel);
      _mesa_generate_mipmap(ctx, target, texObj);
      intel_tex_unmap_level_images(intel, intelObj, texObj->BaseLevel);

      {
         GLuint nr_faces = (texObj->Target == GL_TEXTURE_CUBE_MAP) ? 6 : 1;
         GLuint face, i;
         /* Update the level information in our private data in the new images,
          * since it didn't get set as part of a normal TexImage path.
          */
         for (face = 0; face < nr_faces; face++) {
            for (i = texObj->BaseLevel + 1; i < texObj->MaxLevel; i++) {
               struct intel_texture_image *intelImage =
                  intel_texture_image(texObj->Image[face][i]);
               if (!intelImage)
                  break;
               intelImage->level = i;
               intelImage->face = face;
               /* Unreference the miptree to signal that the new Data is a
                * bare pointer from mesa.
                */
               intel_miptree_release(intel, &intelImage->mt);
            }
         }
a202 3
   else {
      _mesa_meta_GenerateMipmap(ctx, target, texObj);
   }
d205 9
d219 18
d239 4
d247 9
@


