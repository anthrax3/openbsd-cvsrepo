head	1.11;
access;
symbols
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.10;
commitid	TnlogFl9nOv2eaRf;

1.10
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.04.12;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.32;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.32;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.15.19;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.46;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.11.22;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.48.28;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.11
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "i830_context.h"
#include "i830_reg.h"
#include "intel_batchbuffer.h"
#include "intel_mipmap_tree.h"
#include "intel_regions.h"
#include "intel_tris.h"
#include "intel_fbo.h"
#include "intel_buffers.h"
#include "tnl/tnl.h"
#include "tnl/t_context.h"
#include "tnl/t_vertex.h"
#include "swrast_setup/swrast_setup.h"
#include "main/renderbuffer.h"
#include "main/framebuffer.h"
#include "main/fbobject.h"

#define FILE_DEBUG_FLAG DEBUG_STATE

static bool i830_check_vertex_size(struct intel_context *intel,
				   GLuint expected);

#define SZ_TO_HW(sz)  ((sz-2)&0x3)
#define EMIT_SZ(sz)   (EMIT_1F + (sz) - 1)
#define EMIT_ATTR( ATTR, STYLE, V0 )					\
do {									\
   intel->vertex_attrs[intel->vertex_attr_count].attrib = (ATTR);	\
   intel->vertex_attrs[intel->vertex_attr_count].format = (STYLE);	\
   intel->vertex_attr_count++;						\
   v0 |= V0;								\
} while (0)

#define EMIT_PAD( N )							\
do {									\
   intel->vertex_attrs[intel->vertex_attr_count].attrib = 0;		\
   intel->vertex_attrs[intel->vertex_attr_count].format = EMIT_PAD;	\
   intel->vertex_attrs[intel->vertex_attr_count].offset = (N);		\
   intel->vertex_attr_count++;						\
} while (0)


#define VRTX_TEX_SET_FMT(n, x)          ((x)<<((n)*2))
#define TEXBIND_SET(n, x) 		((x)<<((n)*4))

static void
i830_render_prevalidate(struct intel_context *intel)
{
}

static void
i830_render_start(struct intel_context *intel)
{
   struct gl_context *ctx = &intel->ctx;
   struct i830_context *i830 = i830_context(ctx);
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct vertex_buffer *VB = &tnl->vb;
   GLbitfield64 index_bitset = tnl->render_inputs_bitset;
   GLuint v0 = _3DSTATE_VFT0_CMD;
   GLuint v2 = _3DSTATE_VFT1_CMD;
   GLuint mcsb1 = 0;

   /* Important:
    */
   VB->AttribPtr[VERT_ATTRIB_POS] = VB->NdcPtr;
   intel->vertex_attr_count = 0;

   /* EMIT_ATTR's must be in order as they tell t_vertex.c how to
    * build up a hardware vertex.
    */
   if (index_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_TEX0, _TNL_NUM_TEX)) {
      EMIT_ATTR(_TNL_ATTRIB_POS, EMIT_4F_VIEWPORT, VFT0_XYZW);
      intel->coloroffset = 4;
   }
   else {
      EMIT_ATTR(_TNL_ATTRIB_POS, EMIT_3F_VIEWPORT, VFT0_XYZ);
      intel->coloroffset = 3;
   }

   if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_POINTSIZE)) {
      EMIT_ATTR(_TNL_ATTRIB_POINTSIZE, EMIT_1F, VFT0_POINT_WIDTH);
   }

   EMIT_ATTR(_TNL_ATTRIB_COLOR0, EMIT_4UB_4F_BGRA, VFT0_DIFFUSE);

   intel->specoffset = 0;
   if (index_bitset & (BITFIELD64_BIT(_TNL_ATTRIB_COLOR1) |
                       BITFIELD64_BIT(_TNL_ATTRIB_FOG))) {
      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_COLOR1)) {
         intel->specoffset = intel->coloroffset + 1;
         EMIT_ATTR(_TNL_ATTRIB_COLOR1, EMIT_3UB_3F_BGR, VFT0_SPEC);
      }
      else
         EMIT_PAD(3);

      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_FOG))
         EMIT_ATTR(_TNL_ATTRIB_FOG, EMIT_1UB_1F, VFT0_SPEC);
      else
         EMIT_PAD(1);
   }

   if (index_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_TEX0, _TNL_NUM_TEX)) {
      int i, count = 0;

      for (i = 0; i < I830_TEX_UNITS; i++) {
         if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_TEX(i))) {
            GLuint sz = VB->AttribPtr[_TNL_ATTRIB_TEX0 + i]->size;
            GLuint emit;
            GLuint mcs = (i830->state.Tex[i][I830_TEXREG_MCS] &
                          ~TEXCOORDTYPE_MASK);

            switch (sz) {
            case 1:
            case 2:
               emit = EMIT_2F;
               sz = 2;
               mcs |= TEXCOORDTYPE_CARTESIAN;
               break;
            case 3:
               emit = EMIT_3F;
               sz = 3;
               mcs |= TEXCOORDTYPE_VECTOR;
               break;
            case 4:
               emit = EMIT_3F_XYW;
               sz = 3;
               mcs |= TEXCOORDTYPE_HOMOGENEOUS;
               break;
            default:
               continue;
            };


            EMIT_ATTR(_TNL_ATTRIB_TEX0 + i, emit, 0);
            v2 |= VRTX_TEX_SET_FMT(count, SZ_TO_HW(sz));
            mcsb1 |= (count + 8) << (i * 4);

            if (mcs != i830->state.Tex[i][I830_TEXREG_MCS]) {
               I830_STATECHANGE(i830, I830_UPLOAD_TEX(i));
               i830->state.Tex[i][I830_TEXREG_MCS] = mcs;
            }

            count++;
         }
      }

      v0 |= VFT0_TEX_COUNT(count);
   }

   /* Only need to change the vertex emit code if there has been a
    * statechange to a new hardware vertex format:
    */
   if (v0 != i830->state.Ctx[I830_CTXREG_VF] ||
       v2 != i830->state.Ctx[I830_CTXREG_VF2] ||
       mcsb1 != i830->state.Ctx[I830_CTXREG_MCSB1] ||
       index_bitset != i830->last_index_bitset) {
      I830_STATECHANGE(i830, I830_UPLOAD_CTX);

      /* Must do this *after* statechange, so as not to affect
       * buffered vertices reliant on the old state:
       */
      intel->vertex_size =
         _tnl_install_attrs(ctx,
                            intel->vertex_attrs,
                            intel->vertex_attr_count,
                            intel->ViewportMatrix.m, 0);

      intel->vertex_size >>= 2;

      i830->state.Ctx[I830_CTXREG_VF] = v0;
      i830->state.Ctx[I830_CTXREG_VF2] = v2;
      i830->state.Ctx[I830_CTXREG_MCSB1] = mcsb1;
      i830->last_index_bitset = index_bitset;

      assert(i830_check_vertex_size(intel, intel->vertex_size));
   }
}

static void
i830_reduced_primitive_state(struct intel_context *intel, GLenum rprim)
{
   struct i830_context *i830 = i830_context(&intel->ctx);
   GLuint st1 = i830->state.Stipple[I830_STPREG_ST1];

   st1 &= ~ST1_ENABLE;

   switch (rprim) {
   case GL_TRIANGLES:
      if (intel->ctx.Polygon.StippleFlag && intel->hw_stipple)
         st1 |= ST1_ENABLE;
      break;
   case GL_LINES:
   case GL_POINTS:
   default:
      break;
   }

   i830->intel.reduced_primitive = rprim;

   if (st1 != i830->state.Stipple[I830_STPREG_ST1]) {
      INTEL_FIREVERTICES(intel);

      I830_STATECHANGE(i830, I830_UPLOAD_STIPPLE);
      i830->state.Stipple[I830_STPREG_ST1] = st1;
   }
}

/* Pull apart the vertex format registers and figure out how large a
 * vertex is supposed to be. 
 */
static bool
i830_check_vertex_size(struct intel_context *intel, GLuint expected)
{
   struct i830_context *i830 = i830_context(&intel->ctx);
   int vft0 = i830->state.Ctx[I830_CTXREG_VF];
   int vft1 = i830->state.Ctx[I830_CTXREG_VF2];
   int nrtex = (vft0 & VFT0_TEX_COUNT_MASK) >> VFT0_TEX_COUNT_SHIFT;
   int i, sz = 0;

   switch (vft0 & VFT0_XYZW_MASK) {
   case VFT0_XY:
      sz = 2;
      break;
   case VFT0_XYZ:
      sz = 3;
      break;
   case VFT0_XYW:
      sz = 3;
      break;
   case VFT0_XYZW:
      sz = 4;
      break;
   default:
      fprintf(stderr, "no xyzw specified\n");
      return 0;
   }

   if (vft0 & VFT0_SPEC)
      sz++;
   if (vft0 & VFT0_DIFFUSE)
      sz++;
   if (vft0 & VFT0_DEPTH_OFFSET)
      sz++;
   if (vft0 & VFT0_POINT_WIDTH)
      sz++;

   for (i = 0; i < nrtex; i++) {
      switch (vft1 & VFT1_TEX0_MASK) {
      case TEXCOORDFMT_2D:
         sz += 2;
         break;
      case TEXCOORDFMT_3D:
         sz += 3;
         break;
      case TEXCOORDFMT_4D:
         sz += 4;
         break;
      case TEXCOORDFMT_1D:
         sz += 1;
         break;
      }
      vft1 >>= VFT1_TEX1_SHIFT;
   }

   if (sz != expected)
      fprintf(stderr, "vertex size mismatch %d/%d\n", sz, expected);

   return sz == expected;
}

static void
i830_emit_invarient_state(struct intel_context *intel)
{
   BATCH_LOCALS;

   BEGIN_BATCH(29);

   OUT_BATCH(_3DSTATE_DFLT_DIFFUSE_CMD);
   OUT_BATCH(0);

   OUT_BATCH(_3DSTATE_DFLT_SPEC_CMD);
   OUT_BATCH(0);

   OUT_BATCH(_3DSTATE_DFLT_Z_CMD);
   OUT_BATCH(0);

   OUT_BATCH(_3DSTATE_FOG_MODE_CMD);
   OUT_BATCH(FOGFUNC_ENABLE |
             FOG_LINEAR_CONST | FOGSRC_INDEX_Z | ENABLE_FOG_DENSITY);
   OUT_BATCH(0);
   OUT_BATCH(0);


   OUT_BATCH(_3DSTATE_MAP_TEX_STREAM_CMD |
             MAP_UNIT(0) |
             DISABLE_TEX_STREAM_BUMP |
             ENABLE_TEX_STREAM_COORD_SET |
             TEX_STREAM_COORD_SET(0) |
             ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(0));
   OUT_BATCH(_3DSTATE_MAP_TEX_STREAM_CMD |
             MAP_UNIT(1) |
             DISABLE_TEX_STREAM_BUMP |
             ENABLE_TEX_STREAM_COORD_SET |
             TEX_STREAM_COORD_SET(1) |
             ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(1));
   OUT_BATCH(_3DSTATE_MAP_TEX_STREAM_CMD |
             MAP_UNIT(2) |
             DISABLE_TEX_STREAM_BUMP |
             ENABLE_TEX_STREAM_COORD_SET |
             TEX_STREAM_COORD_SET(2) |
             ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(2));
   OUT_BATCH(_3DSTATE_MAP_TEX_STREAM_CMD |
             MAP_UNIT(3) |
             DISABLE_TEX_STREAM_BUMP |
             ENABLE_TEX_STREAM_COORD_SET |
             TEX_STREAM_COORD_SET(3) |
             ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(3));

   OUT_BATCH(_3DSTATE_MAP_COORD_TRANSFORM);
   OUT_BATCH(DISABLE_TEX_TRANSFORM | TEXTURE_SET(0));
   OUT_BATCH(_3DSTATE_MAP_COORD_TRANSFORM);
   OUT_BATCH(DISABLE_TEX_TRANSFORM | TEXTURE_SET(1));
   OUT_BATCH(_3DSTATE_MAP_COORD_TRANSFORM);
   OUT_BATCH(DISABLE_TEX_TRANSFORM | TEXTURE_SET(2));
   OUT_BATCH(_3DSTATE_MAP_COORD_TRANSFORM);
   OUT_BATCH(DISABLE_TEX_TRANSFORM | TEXTURE_SET(3));

   OUT_BATCH(_3DSTATE_VERTEX_TRANSFORM);
   OUT_BATCH(DISABLE_VIEWPORT_TRANSFORM | DISABLE_PERSPECTIVE_DIVIDE);

   OUT_BATCH(_3DSTATE_W_STATE_CMD);
   OUT_BATCH(MAGIC_W_STATE_DWORD1);
   OUT_BATCH(0x3f800000 /* 1.0 in IEEE float */ );


   OUT_BATCH(_3DSTATE_COLOR_FACTOR_CMD);
   OUT_BATCH(0x80808080);       /* .5 required in alpha for GL_DOT3_RGBA_EXT */

   ADVANCE_BATCH();
}


#define emit( intel, state, size )			\
   intel_batchbuffer_data(intel, state, size)

static GLuint
get_dirty(struct i830_hw_state *state)
{
   return state->active & ~state->emitted;
}

static GLuint
get_state_size(struct i830_hw_state *state)
{
   GLuint dirty = get_dirty(state);
   GLuint sz = 0;
   GLuint i;

   if (dirty & I830_UPLOAD_INVARIENT)
      sz += 40 * sizeof(int);

   if (dirty & I830_UPLOAD_RASTER_RULES)
      sz += sizeof(state->RasterRules);

   if (dirty & I830_UPLOAD_CTX)
      sz += sizeof(state->Ctx);

   if (dirty & I830_UPLOAD_BUFFERS)
      sz += sizeof(state->Buffer);

   if (dirty & I830_UPLOAD_STIPPLE)
      sz += sizeof(state->Stipple);

   for (i = 0; i < I830_TEX_UNITS; i++) {
      if ((dirty & I830_UPLOAD_TEX(i)))
         sz += sizeof(state->Tex[i]);

      if (dirty & I830_UPLOAD_TEXBLEND(i))
         sz += state->TexBlendWordsUsed[i] * 4;
   }

   return sz;
}


/* Push the state into the sarea and/or texture memory.
 */
static void
i830_emit_state(struct intel_context *intel)
{
   struct i830_context *i830 = i830_context(&intel->ctx);
   struct i830_hw_state *state = &i830->state;
   int i, count;
   GLuint dirty;
   drm_intel_bo *aper_array[3 + I830_TEX_UNITS];
   int aper_count;
   GET_CURRENT_CONTEXT(ctx);
   BATCH_LOCALS;

   /* We don't hold the lock at this point, so want to make sure that
    * there won't be a buffer wrap between the state emits and the primitive
    * emit header.
    *
    * It might be better to talk about explicit places where
    * scheduling is allowed, rather than assume that it is whenever a
    * batchbuffer fills up.
    */
   intel_batchbuffer_require_space(intel,
				   get_state_size(state) +
                                   INTEL_PRIM_EMIT_SIZE);
   count = 0;
 again:
   aper_count = 0;
   dirty = get_dirty(state);

   aper_array[aper_count++] = intel->batch.bo;
   if (dirty & I830_UPLOAD_BUFFERS) {
      aper_array[aper_count++] = state->draw_region->bo;
      if (state->depth_region)
         aper_array[aper_count++] = state->depth_region->bo;
   }

   for (i = 0; i < I830_TEX_UNITS; i++)
     if (dirty & I830_UPLOAD_TEX(i)) {
	if (state->tex_buffer[i]) {
	   aper_array[aper_count++] = state->tex_buffer[i];
	}
     }

   if (dri_bufmgr_check_aperture_space(aper_array, aper_count)) {
       if (count == 0) {
	   count++;
	   intel_batchbuffer_flush(intel);
	   goto again;
       } else {
	   _mesa_error(ctx, GL_OUT_OF_MEMORY, "i830 emit state");
	   assert(0);
       }
   }


   /* Do this here as we may have flushed the batchbuffer above,
    * causing more state to be dirty!
    */
   dirty = get_dirty(state);
   state->emitted |= dirty;
   assert(get_dirty(state) == 0);

   if (dirty & I830_UPLOAD_INVARIENT) {
      DBG("I830_UPLOAD_INVARIENT:\n");
      i830_emit_invarient_state(intel);
   }

   if (dirty & I830_UPLOAD_RASTER_RULES) {
      DBG("I830_UPLOAD_RASTER_RULES:\n");
      emit(intel, state->RasterRules, sizeof(state->RasterRules));
   }

   if (dirty & I830_UPLOAD_CTX) {
      DBG("I830_UPLOAD_CTX:\n");
      emit(intel, state->Ctx, sizeof(state->Ctx));

   }

   if (dirty & I830_UPLOAD_BUFFERS) {
      GLuint count = 15;

      DBG("I830_UPLOAD_BUFFERS:\n");

      if (state->depth_region)
          count += 3;

      BEGIN_BATCH(count);
      OUT_BATCH(state->Buffer[I830_DESTREG_CBUFADDR0]);
      OUT_BATCH(state->Buffer[I830_DESTREG_CBUFADDR1]);
      OUT_RELOC(state->draw_region->bo,
		I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER, 0);

      if (state->depth_region) {
         OUT_BATCH(state->Buffer[I830_DESTREG_DBUFADDR0]);
         OUT_BATCH(state->Buffer[I830_DESTREG_DBUFADDR1]);
         OUT_RELOC(state->depth_region->bo,
		   I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER, 0);
      }

      OUT_BATCH(state->Buffer[I830_DESTREG_DV0]);
      OUT_BATCH(state->Buffer[I830_DESTREG_DV1]);
      OUT_BATCH(state->Buffer[I830_DESTREG_SENABLE]);
      OUT_BATCH(state->Buffer[I830_DESTREG_SR0]);
      OUT_BATCH(state->Buffer[I830_DESTREG_SR1]);
      OUT_BATCH(state->Buffer[I830_DESTREG_SR2]);

      assert(state->Buffer[I830_DESTREG_DRAWRECT0] != MI_NOOP);
      OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT0]);
      OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT1]);
      OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT2]);
      OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT3]);
      OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT4]);
      OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT5]);
      ADVANCE_BATCH();
   }
   
   if (dirty & I830_UPLOAD_STIPPLE) {
      DBG("I830_UPLOAD_STIPPLE:\n");
      emit(intel, state->Stipple, sizeof(state->Stipple));
   }

   for (i = 0; i < I830_TEX_UNITS; i++) {
      if ((dirty & I830_UPLOAD_TEX(i))) {
         DBG("I830_UPLOAD_TEX(%d):\n", i);

         BEGIN_BATCH(I830_TEX_SETUP_SIZE + 1);
         OUT_BATCH(state->Tex[i][I830_TEXREG_TM0LI]);

	 OUT_RELOC(state->tex_buffer[i],
		   I915_GEM_DOMAIN_SAMPLER, 0,
		   state->tex_offset[i]);

         OUT_BATCH(state->Tex[i][I830_TEXREG_TM0S1]);
         OUT_BATCH(state->Tex[i][I830_TEXREG_TM0S2]);
         OUT_BATCH(state->Tex[i][I830_TEXREG_TM0S3]);
         OUT_BATCH(state->Tex[i][I830_TEXREG_TM0S4]);
         OUT_BATCH(state->Tex[i][I830_TEXREG_MCS]);
         OUT_BATCH(state->Tex[i][I830_TEXREG_CUBE]);

         ADVANCE_BATCH();
      }

      if (dirty & I830_UPLOAD_TEXBLEND(i)) {
         DBG("I830_UPLOAD_TEXBLEND(%d): %d words\n", i,
             state->TexBlendWordsUsed[i]);
         emit(intel, state->TexBlend[i], state->TexBlendWordsUsed[i] * 4);
      }
   }

   assert(get_dirty(state) == 0);
}

static void
i830_destroy_context(struct intel_context *intel)
{
   GLuint i;
   struct i830_context *i830 = i830_context(&intel->ctx);

   intel_region_release(&i830->state.draw_region);
   intel_region_release(&i830->state.depth_region);

   for (i = 0; i < I830_TEX_UNITS; i++) {
      if (i830->state.tex_buffer[i] != NULL) {
	 drm_intel_bo_unreference(i830->state.tex_buffer[i]);
	 i830->state.tex_buffer[i] = NULL;
      }
   }

   _tnl_free_vertices(&intel->ctx);
}

static uint32_t i830_render_target_format_for_mesa_format[MESA_FORMAT_COUNT] =
{
   [MESA_FORMAT_B8G8R8A8_UNORM] = DV_PF_8888,
   [MESA_FORMAT_B8G8R8X8_UNORM] = DV_PF_8888,
   [MESA_FORMAT_B5G6R5_UNORM] = DV_PF_565,
   [MESA_FORMAT_B5G5R5A1_UNORM] = DV_PF_1555,
   [MESA_FORMAT_B4G4R4A4_UNORM] = DV_PF_4444,
};

static bool
i830_render_target_supported(struct intel_context *intel,
			     struct gl_renderbuffer *rb)
{
   mesa_format format = rb->Format;

   if (format == MESA_FORMAT_Z24_UNORM_S8_UINT ||
       format == MESA_FORMAT_Z24_UNORM_X8_UINT ||
       format == MESA_FORMAT_Z_UNORM16) {
      return true;
   }

   return i830_render_target_format_for_mesa_format[format] != 0;
}

static void
i830_set_draw_region(struct intel_context *intel,
                     struct intel_region *color_regions[],
                     struct intel_region *depth_region,
		     GLuint num_regions)
{
   struct i830_context *i830 = i830_context(&intel->ctx);
   struct gl_context *ctx = &intel->ctx;
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0];
   struct intel_renderbuffer *irb = intel_renderbuffer(rb);
   struct gl_renderbuffer *drb;
   struct intel_renderbuffer *idrb = NULL;
   GLuint value;
   struct i830_hw_state *state = &i830->state;
   uint32_t draw_x, draw_y;

   if (state->draw_region != color_regions[0]) {
      intel_region_reference(&state->draw_region, color_regions[0]);
   }
   if (state->depth_region != depth_region) {
      intel_region_reference(&state->depth_region, depth_region);
   }

   /*
    * Set stride/cpp values
    */
   i915_set_buf_info_for_region(&state->Buffer[I830_DESTREG_CBUFADDR0],
				color_regions[0], BUF_3D_ID_COLOR_BACK);

   i915_set_buf_info_for_region(&state->Buffer[I830_DESTREG_DBUFADDR0],
				depth_region, BUF_3D_ID_DEPTH);

   /*
    * Compute/set I830_DESTREG_DV1 value
    */
   value = (DSTORG_HORT_BIAS(0x8) |     /* .5 */
            DSTORG_VERT_BIAS(0x8) | DEPTH_IS_Z);    /* .5 */

   if (irb != NULL) {
      value |= i830_render_target_format_for_mesa_format[intel_rb_format(irb)];
   }

   if (depth_region && depth_region->cpp == 4) {
      value |= DEPTH_FRMT_24_FIXED_8_OTHER;
   }
   else {
      value |= DEPTH_FRMT_16_FIXED;
   }
   state->Buffer[I830_DESTREG_DV1] = value;

   drb = ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
   if (!drb)
      drb = ctx->DrawBuffer->Attachment[BUFFER_STENCIL].Renderbuffer;

   if (drb)
      idrb = intel_renderbuffer(drb);

   /* We set up the drawing rectangle to be offset into the color
    * region's location in the miptree.  If it doesn't match with
    * depth's offsets, we can't render to it.
    *
    * (Well, not actually true -- the hw grew a bit to let depth's
    * offset get forced to 0,0.  We may want to use that if people are
    * hitting that case.  Also, some configurations may be supportable
    * by tweaking the start offset of the buffers around, which we
    * can't do in general due to tiling)
    */
   FALLBACK(intel, I830_FALLBACK_DRAW_OFFSET,
	    idrb && irb && (idrb->draw_x != irb->draw_x ||
			    idrb->draw_y != irb->draw_y));

   if (irb) {
      draw_x = irb->draw_x;
      draw_y = irb->draw_y;
   } else if (idrb) {
      draw_x = idrb->draw_x;
      draw_y = idrb->draw_y;
   } else {
      draw_x = 0;
      draw_y = 0;
   }

   state->Buffer[I830_DESTREG_DRAWRECT0] = _3DSTATE_DRAWRECT_INFO;
   state->Buffer[I830_DESTREG_DRAWRECT1] = 0;
   state->Buffer[I830_DESTREG_DRAWRECT2] = (draw_y << 16) | draw_x;
   state->Buffer[I830_DESTREG_DRAWRECT3] =
      ((ctx->DrawBuffer->Width + draw_x - 1) & 0xffff) |
      ((ctx->DrawBuffer->Height + draw_y - 1) << 16);
   state->Buffer[I830_DESTREG_DRAWRECT4] = (draw_y << 16) | draw_x;
   state->Buffer[I830_DESTREG_DRAWRECT5] = MI_NOOP;

   I830_STATECHANGE(i830, I830_UPLOAD_BUFFERS);
}

/**
 * Update the hardware state for drawing into a window or framebuffer object.
 *
 * Called by glDrawBuffer, glBindFramebufferEXT, MakeCurrent, and other
 * places within the driver.
 *
 * Basically, this needs to be called any time the current framebuffer
 * changes, the renderbuffers change, or we need to draw into different
 * color buffers.
 */
static void
i830_update_draw_buffer(struct intel_context *intel)
{
   struct gl_context *ctx = &intel->ctx;
   struct gl_framebuffer *fb = ctx->DrawBuffer;
   struct intel_region *colorRegions[MAX_DRAW_BUFFERS], *depthRegion = NULL;
   struct intel_renderbuffer *irbDepth = NULL, *irbStencil = NULL;

   if (!fb) {
      /* this can happen during the initial context initialization */
      return;
   }

   irbDepth = intel_get_renderbuffer(fb, BUFFER_DEPTH);
   irbStencil = intel_get_renderbuffer(fb, BUFFER_STENCIL);

   /* Do this here, not core Mesa, since this function is called from
    * many places within the driver.
    */
   if (ctx->NewState & _NEW_BUFFERS) {
      /* this updates the DrawBuffer->_NumColorDrawBuffers fields, etc */
      _mesa_update_framebuffer(ctx);
      /* this updates the DrawBuffer's Width/Height if it's a FBO */
      _mesa_update_draw_buffer_bounds(ctx);
   }

   if (fb->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
      /* this may occur when we're called by glBindFrameBuffer() during
       * the process of someone setting up renderbuffers, etc.
       */
      /*_mesa_debug(ctx, "DrawBuffer: incomplete user FBO\n");*/
      return;
   }

   /* How many color buffers are we drawing into?
    *
    * If there are zero buffers or the buffer is too big, don't configure any
    * regions for hardware drawing.  We'll fallback to software below.  Not
    * having regions set makes some of the software fallback paths faster.
    */
   if ((fb->Width > ctx->Const.MaxRenderbufferSize)
       || (fb->Height > ctx->Const.MaxRenderbufferSize)
       || (fb->_NumColorDrawBuffers == 0)) {
      /* writing to 0  */
      colorRegions[0] = NULL;
   }
   else if (fb->_NumColorDrawBuffers > 1) {
       int i;
       struct intel_renderbuffer *irb;

       for (i = 0; i < fb->_NumColorDrawBuffers; i++) {
           irb = intel_renderbuffer(fb->_ColorDrawBuffers[i]);
           colorRegions[i] = (irb && irb->mt) ? irb->mt->region : NULL;
       }
   }
   else {
      /* Get the intel_renderbuffer for the single colorbuffer we're drawing
       * into.
       */
      if (_mesa_is_winsys_fbo(fb)) {
	 /* drawing to window system buffer */
	 if (fb->_ColorDrawBufferIndexes[0] == BUFFER_FRONT_LEFT)
	    colorRegions[0] = intel_get_rb_region(fb, BUFFER_FRONT_LEFT);
	 else
	    colorRegions[0] = intel_get_rb_region(fb, BUFFER_BACK_LEFT);
      }
      else {
	 /* drawing to user-created FBO */
	 struct intel_renderbuffer *irb;
	 irb = intel_renderbuffer(fb->_ColorDrawBuffers[0]);
	 colorRegions[0] = (irb && irb->mt->region) ? irb->mt->region : NULL;
      }
   }

   if (!colorRegions[0]) {
      FALLBACK(intel, INTEL_FALLBACK_DRAW_BUFFER, true);
   }
   else {
      FALLBACK(intel, INTEL_FALLBACK_DRAW_BUFFER, false);
   }

   /* Check for depth fallback. */
   if (irbDepth && irbDepth->mt) {
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, false);
      depthRegion = irbDepth->mt->region;
   } else if (irbDepth && !irbDepth->mt) {
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, true);
      depthRegion = NULL;
   } else { /* !irbDepth */
      /* No fallback is needed because there is no depth buffer. */
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, false);
      depthRegion = NULL;
   }

   /* Check for stencil fallback. */
   if (irbStencil && irbStencil->mt) {
      assert(intel_rb_format(irbStencil) == MESA_FORMAT_Z24_UNORM_S8_UINT);
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, false);
   } else if (irbStencil && !irbStencil->mt) {
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, true);
   } else { /* !irbStencil */
      /* No fallback is needed because there is no stencil buffer. */
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, false);
   }

   /* If we have a (packed) stencil buffer attached but no depth buffer,
    * we still need to set up the shared depth/stencil state so we can use it.
    */
   if (depthRegion == NULL && irbStencil && irbStencil->mt
       && intel_rb_format(irbStencil) == MESA_FORMAT_Z24_UNORM_S8_UINT) {
      depthRegion = irbStencil->mt->region;
   }

   /*
    * Update depth and stencil test state
    */
   ctx->Driver.Enable(ctx, GL_DEPTH_TEST, ctx->Depth.Test);
   ctx->Driver.Enable(ctx, GL_STENCIL_TEST,
		      (ctx->Stencil.Enabled && fb->Visual.stencilBits > 0));

   intel->vtbl.set_draw_region(intel, colorRegions, depthRegion,
                               fb->_NumColorDrawBuffers);
   intel->NewGLState |= _NEW_BUFFERS;

   /* Set state we know depends on drawable parameters:
    */
   intelCalcViewport(ctx);
   ctx->Driver.Scissor(ctx);

   /* Update culling direction which changes depending on the
    * orientation of the buffer:
    */
   ctx->Driver.FrontFace(ctx, ctx->Polygon.FrontFace);
}

/* This isn't really handled at the moment.
 */
static void
i830_new_batch(struct intel_context *intel)
{
   struct i830_context *i830 = i830_context(&intel->ctx);
   i830->state.emitted = 0;
}

static void 
i830_assert_not_dirty( struct intel_context *intel )
{
   struct i830_context *i830 = i830_context(&intel->ctx);
   assert(!get_dirty(&i830->state));
   (void) i830;
}

static void
i830_invalidate_state(struct intel_context *intel, GLuint new_state)
{
   struct gl_context *ctx = &intel->ctx;

   _swsetup_InvalidateState(ctx, new_state);
   _tnl_InvalidateState(ctx, new_state);
   _tnl_invalidate_vertex_state(ctx, new_state);

   if (new_state & _NEW_LIGHT)
      i830_update_provoking_vertex(&intel->ctx);
}

void
i830InitVtbl(struct i830_context *i830)
{
   i830->intel.vtbl.check_vertex_size = i830_check_vertex_size;
   i830->intel.vtbl.destroy = i830_destroy_context;
   i830->intel.vtbl.emit_state = i830_emit_state;
   i830->intel.vtbl.new_batch = i830_new_batch;
   i830->intel.vtbl.reduced_primitive_state = i830_reduced_primitive_state;
   i830->intel.vtbl.set_draw_region = i830_set_draw_region;
   i830->intel.vtbl.update_draw_buffer = i830_update_draw_buffer;
   i830->intel.vtbl.update_texture_state = i830UpdateTextureState;
   i830->intel.vtbl.render_start = i830_render_start;
   i830->intel.vtbl.render_prevalidate = i830_render_prevalidate;
   i830->intel.vtbl.assert_not_dirty = i830_assert_not_dirty;
   i830->intel.vtbl.finish_batch = intel_finish_vb;
   i830->intel.vtbl.invalidate_state = i830_invalidate_state;
   i830->intel.vtbl.render_target_supported = i830_render_target_supported;
}
@


1.10
log
@Merge Mesa 10.2.9
@
text
@@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d513 1
a516 1
      OUT_BATCH(state->Buffer[I830_DESTREG_SENABLE]);
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a512 1
      OUT_BATCH(state->Buffer[I830_DESTREG_SENABLE]);
d516 1
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d585 5
a589 5
   [MESA_FORMAT_ARGB8888] = DV_PF_8888,
   [MESA_FORMAT_XRGB8888] = DV_PF_8888,
   [MESA_FORMAT_RGB565] = DV_PF_565,
   [MESA_FORMAT_ARGB1555] = DV_PF_1555,
   [MESA_FORMAT_ARGB4444] = DV_PF_4444,
d596 1
a596 1
   gl_format format = rb->Format;
d598 3
a600 3
   if (format == MESA_FORMAT_S8_Z24 ||
       format == MESA_FORMAT_X8_Z24 ||
       format == MESA_FORMAT_Z16) {
d807 1
a807 1
      assert(intel_rb_format(irbStencil) == MESA_FORMAT_S8_Z24);
d820 1
a820 1
       && intel_rb_format(irbStencil) == MESA_FORMAT_S8_Z24) {
a834 3
   /* update viewport since it depends on window size */
   intelCalcViewport(ctx);

d837 2
a838 4
   ctx->Driver.Scissor(ctx, ctx->Scissor.X, ctx->Scissor.Y,
		       ctx->Scissor.Width, ctx->Scissor.Height);

   ctx->Driver.DepthRange(ctx, ctx->Viewport.Near, ctx->Viewport.Far);
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d31 1
d42 1
d46 2
a47 2
static GLboolean i830_check_vertex_size(struct intel_context *intel,
                                        GLuint expected);
d83 1
a83 1
   DECLARE_RENDERINPUTS(index_bitset);
a87 2
   RENDERINPUTS_COPY(index_bitset, tnl->render_inputs_bitset);

d96 1
a96 1
   if (RENDERINPUTS_TEST_RANGE(index_bitset, _TNL_FIRST_TEX, _TNL_LAST_TEX)) {
d105 1
a105 1
   if (RENDERINPUTS_TEST(index_bitset, _TNL_ATTRIB_POINTSIZE)) {
d112 3
a114 3
   if (RENDERINPUTS_TEST(index_bitset, _TNL_ATTRIB_COLOR1) ||
       RENDERINPUTS_TEST(index_bitset, _TNL_ATTRIB_FOG)) {
      if (RENDERINPUTS_TEST(index_bitset, _TNL_ATTRIB_COLOR1)) {
d121 1
a121 1
      if (RENDERINPUTS_TEST(index_bitset, _TNL_ATTRIB_FOG))
d127 1
a127 1
   if (RENDERINPUTS_TEST_RANGE(index_bitset, _TNL_FIRST_TEX, _TNL_LAST_TEX)) {
d131 1
a131 1
         if (RENDERINPUTS_TEST(index_bitset, _TNL_ATTRIB_TEX(i))) {
d181 1
a181 3
       !RENDERINPUTS_EQUAL(index_bitset, i830->last_index_bitset)) {
      int k;

d198 1
a198 1
      RENDERINPUTS_COPY(i830->last_index_bitset, index_bitset);
d200 1
a200 2
      k = i830_check_vertex_size(intel, intel->vertex_size);
      assert(k);
d236 1
a236 1
static GLboolean
d369 1
a369 1
   intel_batchbuffer_data(intel, state, size, false)
d434 2
a435 2
				   get_state_size(state) + INTEL_PRIM_EMIT_SIZE,
				   false);
d443 1
a443 1
      aper_array[aper_count++] = state->draw_region->buffer;
d445 1
a445 1
         aper_array[aper_count++] = state->depth_region->buffer;
d501 1
a501 1
      OUT_RELOC(state->draw_region->buffer,
d507 1
a507 1
         OUT_RELOC(state->depth_region->buffer,
d593 2
a594 1
i830_render_target_supported(gl_format format)
d596 2
a623 1
      intel_region_release(&state->draw_region);
a626 1
      intel_region_release(&state->depth_region);
d646 1
a646 1
      value |= i830_render_target_format_for_mesa_format[irb->Base.Format];
d693 2
a694 2
      ((ctx->DrawBuffer->Width + draw_x) & 0xffff) |
      ((ctx->DrawBuffer->Height + draw_y) << 16);
a717 1
   bool fb_has_hiz = intel_framebuffer_has_hiz(fb);
d763 1
a763 1
           colorRegions[i] = irb ? irb->region : NULL;
d770 1
a770 1
      if (fb->Name == 0) {
d781 1
a781 1
	 colorRegions[0] = (irb && irb->region) ? irb->region : NULL;
d786 1
a786 1
      FALLBACK(intel, INTEL_FALLBACK_DRAW_BUFFER, GL_TRUE);
d789 1
a789 1
      FALLBACK(intel, INTEL_FALLBACK_DRAW_BUFFER, GL_FALSE);
d793 5
a797 6
   if (irbDepth && irbDepth->region) {
      assert(!fb_has_hiz || irbDepth->Base.Format != MESA_FORMAT_S8_Z24);
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, GL_FALSE);
      depthRegion = irbDepth->region;
   } else if (irbDepth && !irbDepth->region) {
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, GL_TRUE);
d801 1
a801 1
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, GL_FALSE);
d806 5
a810 5
   if (irbStencil && irbStencil->region) {
      assert(irbStencil->Base.Format == MESA_FORMAT_S8_Z24);
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, GL_FALSE);
   } else if (irbStencil && !irbStencil->region) {
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, GL_TRUE);
d813 1
a813 1
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, GL_FALSE);
d819 3
a821 3
   if (depthRegion == NULL && irbStencil && irbStencil->region
       && irbStencil->Base.Format == MESA_FORMAT_S8_Z24) {
      depthRegion = irbStencil->region;
d827 1
a827 2
   ctx->Driver.Enable(ctx, GL_DEPTH_TEST,
		      (ctx->Depth.Test && fb->Visual.depthBits > 0));
a880 6
static bool
i830_is_hiz_depth_format(struct intel_context *intel, gl_format format)
{
   return false;
}

a897 1
   i830->intel.vtbl.is_hiz_depth_format = i830_is_hiz_depth_format;
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d34 2
d38 3
d372 1
a372 1
   intel_batchbuffer_data(intel->batch, state, size, false)
d436 1
a436 1
   intel_batchbuffer_require_space(intel->batch,
d444 1
a444 1
   aper_array[aper_count++] = intel->batch->buf;
d461 1
a461 1
	   intel_batchbuffer_flush(intel->batch);
d543 3
a545 8
         if (state->tex_buffer[i]) {
            OUT_RELOC(state->tex_buffer[i],
		      I915_GEM_DOMAIN_SAMPLER, 0,
                      state->tex_offset[i]);
         }
	 else {
	    OUT_BATCH(state->tex_offset[i]);
	 }
a563 1
   intel->batch->dirty_state &= ~dirty;
a564 1
   assert((intel->batch->dirty_state & (1<<1)) == 0);
d586 21
d617 2
d648 1
a648 18
      switch (irb->Base.Format) {
      case MESA_FORMAT_ARGB8888:
      case MESA_FORMAT_XRGB8888:
	 value |= DV_PF_8888;
	 break;
      case MESA_FORMAT_RGB565:
	 value |= DV_PF_565;
	 break;
      case MESA_FORMAT_ARGB1555:
	 value |= DV_PF_1555;
	 break;
      case MESA_FORMAT_ARGB4444:
	 value |= DV_PF_4444;
	 break;
      default:
	 _mesa_problem(ctx, "Bad renderbuffer format: %d\n",
		       irb->Base.Format);
      }
d659 7
d677 9
a685 10
	    (depth_region && color_regions[0]) &&
	    (depth_region->draw_x != color_regions[0]->draw_x ||
	     depth_region->draw_y != color_regions[0]->draw_y));

   if (color_regions[0]) {
      draw_x = color_regions[0]->draw_x;
      draw_y = color_regions[0]->draw_y;
   } else if (depth_region) {
      draw_x = depth_region->draw_x;
      draw_y = depth_region->draw_y;
d703 153
d876 6
d886 6
d901 1
d908 2
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d72 1
a72 1
   GLcontext *ctx = &intel->ctx;
d367 1
a367 1
   intel_batchbuffer_data(intel->batch, state, size )
d418 1
a418 1
   dri_bo *aper_array[3 + I830_TEX_UNITS];
d432 2
a433 1
				   get_state_size(state) + INTEL_PRIM_EMIT_SIZE);
d580 1
a580 1
	 dri_bo_unreference(i830->state.tex_buffer[i]);
d595 1
a595 1
   GLcontext *ctx = &intel->ctx;
d707 1
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a27 2
#include "glapi/glapi.h"

d33 1
d127 1
a127 1
            GLuint sz = VB->TexCoordPtr[i]->size;
d238 2
a239 2
   int vft0 = i830->current->Ctx[I830_CTXREG_VF];
   int vft1 = i830->current->Ctx[I830_CTXREG_VF2];
d299 1
a299 1
   BEGIN_BATCH(30, IGNORE_CLIPRECTS);
a350 9
   OUT_BATCH(_3DSTATE_RASTER_RULES_CMD |
             ENABLE_POINT_RASTER_RULE |
             OGL_POINT_RASTER_RULE |
             ENABLE_LINE_STRIP_PROVOKE_VRTX |
             ENABLE_TRI_FAN_PROVOKE_VRTX |
             ENABLE_TRI_STRIP_PROVOKE_VRTX |
             LINE_STRIP_PROVOKE_VRTX(1) |
             TRI_FAN_PROVOKE_VRTX(2) | TRI_STRIP_PROVOKE_VRTX(2));

d367 1
a367 1
   intel_batchbuffer_data(intel->batch, state, size, IGNORE_CLIPRECTS )
d385 3
d415 1
a415 1
   struct i830_hw_state *state = i830->current;
d418 2
a421 2
   dri_bo *aper_array[3 + I830_TEX_UNITS];
   int aper_count;
a429 3
    *
    * Set the space as LOOP_CLIPRECTS now, since that's what our primitives
    * will be emitted under.
d432 1
a432 2
				   get_state_size(state) + INTEL_PRIM_EMIT_SIZE,
				   LOOP_CLIPRECTS);
d476 5
d488 1
a488 1
      GLuint count = 9; 
d495 1
a495 4
      if (intel->constant_cliprect)
          count += 6;

      BEGIN_BATCH(count, IGNORE_CLIPRECTS);
d499 1
a499 2
		I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER,
                state->draw_region->draw_offset);
d505 1
a505 2
		   I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER,
                   state->depth_region->draw_offset);
d515 7
a521 9
      if (intel->constant_cliprect) {
	 assert(state->Buffer[I830_DESTREG_DRAWRECT0] != MI_NOOP);
	 OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT0]);
	 OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT1]);
	 OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT2]);
	 OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT3]);
	 OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT4]);
	 OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT5]);
      }
d534 1
a534 1
         BEGIN_BATCH(I830_TEX_SETUP_SIZE + 1, IGNORE_CLIPRECTS);
d540 1
a540 1
                      state->tex_offset[i] | TM0S0_USE_FENCE);
a541 4
	 else if (state == &i830->meta) {
	    assert(i == 0);
	    OUT_BATCH(0);
	 }
a575 4
   intel_region_release(&i830->meta.draw_region);
   intel_region_release(&i830->meta.depth_region);
   intel_region_release(&i830->initial.draw_region);
   intel_region_release(&i830->initial.depth_region);
d587 5
a591 6

void
i830_state_draw_region(struct intel_context *intel,
		       struct i830_hw_state *state,
		       struct intel_region *color_region,
		       struct intel_region *depth_region)
d595 2
d598 2
d601 1
a601 3
   ASSERT(state == &i830->state || state == &i830->meta);

   if (state->draw_region != color_region) {
d603 1
a603 1
      intel_region_reference(&state->draw_region, color_region);
d613 2
a614 7
   if (color_region) {
      state->Buffer[I830_DESTREG_CBUFADDR0] = _3DSTATE_BUF_INFO_CMD;
      state->Buffer[I830_DESTREG_CBUFADDR1] =
         (BUF_3D_ID_COLOR_BACK |
          BUF_3D_PITCH(color_region->pitch * color_region->cpp) |
          BUF_3D_USE_FENCE);
   }
d616 2
a617 7
   if (depth_region) {
      state->Buffer[I830_DESTREG_DBUFADDR0] = _3DSTATE_BUF_INFO_CMD;
      state->Buffer[I830_DESTREG_DBUFADDR1] =
         (BUF_3D_ID_DEPTH |
          BUF_3D_PITCH(depth_region->pitch * depth_region->cpp) |
          BUF_3D_USE_FENCE);
   }
d624 20
a643 6
            
   if (color_region && color_region->cpp == 4) {
      value |= DV_PF_8888;
   }
   else {
      value |= DV_PF_565;
d645 1
d654 21
a674 9
   if (intel->constant_cliprect) {
      state->Buffer[I830_DESTREG_DRAWRECT0] = _3DSTATE_DRAWRECT_INFO;
      state->Buffer[I830_DESTREG_DRAWRECT1] = 0;
      state->Buffer[I830_DESTREG_DRAWRECT2] = 0; /* xmin, ymin */
      state->Buffer[I830_DESTREG_DRAWRECT3] =
	 (ctx->DrawBuffer->Width & 0xffff) |
	 (ctx->DrawBuffer->Height << 16);
      state->Buffer[I830_DESTREG_DRAWRECT4] = 0; /* xoff, yoff */
      state->Buffer[I830_DESTREG_DRAWRECT5] = 0;
d676 2
a677 6
      state->Buffer[I830_DESTREG_DRAWRECT0] = MI_NOOP;
      state->Buffer[I830_DESTREG_DRAWRECT1] = MI_NOOP;
      state->Buffer[I830_DESTREG_DRAWRECT2] = MI_NOOP;
      state->Buffer[I830_DESTREG_DRAWRECT3] = MI_NOOP;
      state->Buffer[I830_DESTREG_DRAWRECT4] = MI_NOOP;
      state->Buffer[I830_DESTREG_DRAWRECT5] = MI_NOOP;
d680 9
a689 2


a691 31

static void
i830_set_draw_region(struct intel_context *intel,
                     struct intel_region *color_regions[],
                     struct intel_region *depth_region,
		     GLuint num_regions)
{
   struct i830_context *i830 = i830_context(&intel->ctx);
   i830_state_draw_region(intel, &i830->state, color_regions[0], depth_region);
}

#if 0
static void
i830_update_color_z_regions(intelContextPtr intel,
                            const intelRegion * colorRegion,
                            const intelRegion * depthRegion)
{
   i830ContextPtr i830 = I830_CONTEXT(intel);

   i830->state.Buffer[I830_DESTREG_CBUFADDR1] =
      (BUF_3D_ID_COLOR_BACK | BUF_3D_PITCH(colorRegion->pitch) |
       BUF_3D_USE_FENCE);
   i830->state.Buffer[I830_DESTREG_CBUFADDR2] = colorRegion->offset;

   i830->state.Buffer[I830_DESTREG_DBUFADDR1] =
      (BUF_3D_ID_DEPTH | BUF_3D_PITCH(depthRegion->pitch) | BUF_3D_USE_FENCE);
   i830->state.Buffer[I830_DESTREG_DBUFADDR2] = depthRegion->offset;
}
#endif


a698 3

   /* Check that we didn't just wrap our batchbuffer at a bad time. */
   assert(!intel->no_batch_wrap);
a700 9


static GLuint
i830_flush_cmd(void)
{
   return MI_FLUSH | FLUSH_MAP_CACHE;
}


d705 1
a705 2
   struct i830_hw_state *state = i830->current;
   assert(!get_dirty(state));
d709 1
a709 1
i830_note_unlock( struct intel_context *intel )
d711 2
a712 1
    /* nothing */
a724 1
   i830->intel.vtbl.flush_cmd = i830_flush_cmd;
a727 1
   i830->intel.vtbl.note_unlock = i830_note_unlock; 
d729 1
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d28 1
a28 1
#include "glapi.h"
d34 1
d300 1
a300 1
   BEGIN_BATCH(40, IGNORE_CLIPRECTS);
d423 1
a423 1
   int i, ret, count;
d427 2
d441 2
a442 1
   intel_batchbuffer_require_space(intel->batch, get_state_size(state) + 8,
d446 1
d449 1
a449 1
   ret = 0;
d451 3
a453 2
     ret |= dri_bufmgr_check_aperture_space(state->draw_region->buffer);
     ret |= dri_bufmgr_check_aperture_space(state->depth_region->buffer);
d455 1
a455 1
   
d459 1
a459 1
	  ret |= dri_bufmgr_check_aperture_space(state->tex_buffer[i]);
d463 1
a463 1
   if (ret) {
d494 2
d497 8
a504 1
      BEGIN_BATCH(I830_DEST_SETUP_SIZE + 2, IGNORE_CLIPRECTS);
d508 1
a508 1
                DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_WRITE,
d515 1
a515 1
                   DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_WRITE,
d525 10
d552 1
a552 1
                      DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_READ,
d569 2
d591 7
d616 1
d669 18
d773 1
@


1.1
log
@Initial revision
@
text
@d28 1
a31 1

d33 1
a33 1

d37 4
a40 2
static GLboolean i830_check_vertex_size( intelContextPtr intel,
					 GLuint expected );
d64 7
a70 1
static void i830_render_start( intelContextPtr intel )
d73 1
a73 1
   i830ContextPtr i830 = I830_CONTEXT(intel);
d81 1
a81 1
   RENDERINPUTS_COPY( index_bitset, tnl->render_inputs_bitset );
d91 2
a92 2
   if (RENDERINPUTS_TEST_RANGE( index_bitset, _TNL_FIRST_TEX, _TNL_LAST_TEX )) {
      EMIT_ATTR( _TNL_ATTRIB_POS, EMIT_4F_VIEWPORT, VFT0_XYZW );
d96 1
a96 1
      EMIT_ATTR( _TNL_ATTRIB_POS, EMIT_3F_VIEWPORT, VFT0_XYZ );
d100 2
a101 2
   if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_POINTSIZE )) {
      EMIT_ATTR( _TNL_ATTRIB_POINTSIZE, EMIT_1F, VFT0_POINT_WIDTH );
d104 2
a105 2
   EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_4UB_4F_BGRA, VFT0_DIFFUSE );
      
d107 3
a109 3
   if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_COLOR1 ) ||
       RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_FOG )) {
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_COLOR1 )) {
d111 1
a111 1
         EMIT_ATTR( _TNL_ATTRIB_COLOR1, EMIT_3UB_3F_BGR, VFT0_SPEC );
d114 1
a114 1
         EMIT_PAD( 3 );
d116 2
a117 2
      if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_FOG ))
         EMIT_ATTR( _TNL_ATTRIB_FOG, EMIT_1UB_1F, VFT0_SPEC );
d119 1
a119 1
         EMIT_PAD( 1 );
d122 1
a122 1
   if (RENDERINPUTS_TEST_RANGE( index_bitset, _TNL_FIRST_TEX, _TNL_LAST_TEX )) {
d126 1
a126 1
         if (RENDERINPUTS_TEST( index_bitset, _TNL_ATTRIB_TEX(i) )) {
d129 1
a129 1
            GLuint mcs = (i830->state.Tex[i][I830_TEXREG_MCS] & 
d132 30
a161 30
	    switch (sz) {
	    case 1: 
	    case 2: 
	       emit = EMIT_2F; 
	       sz = 2; 
	       mcs |= TEXCOORDTYPE_CARTESIAN; 
	       break;
	    case 3:
	       emit = EMIT_3F; 
	       sz = 3;
	       mcs |= TEXCOORDTYPE_VECTOR;
	       break;
	    case 4: 
	       emit = EMIT_3F_XYW; 
	       sz = 3;     
	       mcs |= TEXCOORDTYPE_HOMOGENEOUS;
	       break;
	    default: 
	       continue;
	    };
	      

	    EMIT_ATTR( _TNL_ATTRIB_TEX0+i, emit, 0 );	       
	    v2 |= VRTX_TEX_SET_FMT(count, SZ_TO_HW(sz));
	    mcsb1 |= (count+8)<<(i*4);

	    if (mcs != i830->state.Tex[i][I830_TEXREG_MCS]) {
	       I830_STATECHANGE(i830, I830_UPLOAD_TEX(i));
	       i830->state.Tex[i][I830_TEXREG_MCS] = mcs;
	    }
d163 2
a164 2
	    count++;
	 }
d169 1
a169 1
   
d176 4
a179 3
       !RENDERINPUTS_EQUAL( index_bitset, i830->last_index_bitset )) {
    
      I830_STATECHANGE( i830, I830_UPLOAD_CTX );
d184 5
a188 5
      intel->vertex_size = 
	 _tnl_install_attrs( ctx, 
			     intel->vertex_attrs, 
			     intel->vertex_attr_count,
			     intel->ViewportMatrix.m, 0 );
d195 1
a195 1
      RENDERINPUTS_COPY( i830->last_index_bitset, index_bitset );
d197 2
a198 1
      assert(i830_check_vertex_size( intel, intel->vertex_size ));
d202 2
a203 2
static void i830_reduced_primitive_state( intelContextPtr intel,
					  GLenum rprim )
d205 4
a208 2
    i830ContextPtr i830 = I830_CONTEXT(intel);
    GLuint st1 = i830->state.Stipple[I830_STPREG_ST1];
d210 10
a219 1
    st1 &= ~ST1_ENABLE;
d221 1
a221 11
    switch (rprim) {
    case GL_TRIANGLES:
       if (intel->ctx.Polygon.StippleFlag &&
	   intel->hw_stipple)
	  st1 |= ST1_ENABLE;
       break;
    case GL_LINES:
    case GL_POINTS:
    default:
       break;
    }
d223 2
a224 1
    i830->intel.reduced_primitive = rprim;
d226 3
a228 4
    if (st1 != i830->state.Stipple[I830_STPREG_ST1]) {
       I830_STATECHANGE(i830, I830_UPLOAD_STIPPLE);
       i830->state.Stipple[I830_STPREG_ST1] = st1;
    }
d234 2
a235 2
static GLboolean i830_check_vertex_size( intelContextPtr intel,
					 GLuint expected )
d237 1
a237 1
   i830ContextPtr i830 = I830_CONTEXT(intel);
d244 13
a256 5
   case VFT0_XY: sz = 2; break;
   case VFT0_XYZ: sz = 3; break;
   case VFT0_XYW: sz = 3; break;
   case VFT0_XYZW: sz = 4; break;
   default: 
d261 10
a270 6
   if (vft0 & VFT0_SPEC) sz++;
   if (vft0 & VFT0_DIFFUSE) sz++;
   if (vft0 & VFT0_DEPTH_OFFSET) sz++;
   if (vft0 & VFT0_POINT_WIDTH) sz++;
	
   for (i = 0 ; i < nrtex ; i++) { 
d272 12
a283 4
      case TEXCOORDFMT_2D: sz += 2; break;
      case TEXCOORDFMT_3D: sz += 3; break;
      case TEXCOORDFMT_4D: sz += 4; break;
      case TEXCOORDFMT_1D: sz += 1; break;
d287 2
a288 2
	
   if (sz != expected) 
d290 1
a290 1
   
d294 2
a295 1
static void i830_emit_invarient_state( intelContextPtr intel )
d299 1
a299 6
   BEGIN_BATCH( 40 );

   OUT_BATCH(_3DSTATE_MAP_CUBE | MAP_UNIT(0));
   OUT_BATCH(_3DSTATE_MAP_CUBE | MAP_UNIT(1));
   OUT_BATCH(_3DSTATE_MAP_CUBE | MAP_UNIT(2));
   OUT_BATCH(_3DSTATE_MAP_CUBE | MAP_UNIT(3));
d312 1
a312 3
	     FOG_LINEAR_CONST | 
	     FOGSRC_INDEX_Z | 
	     ENABLE_FOG_DENSITY);
d318 5
a322 5
	     MAP_UNIT(0) |
	     DISABLE_TEX_STREAM_BUMP |
	     ENABLE_TEX_STREAM_COORD_SET |
	     TEX_STREAM_COORD_SET(0) |
	     ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(0));
d324 5
a328 5
	     MAP_UNIT(1) |
	     DISABLE_TEX_STREAM_BUMP |
	     ENABLE_TEX_STREAM_COORD_SET |
	     TEX_STREAM_COORD_SET(1) |
	     ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(1));
d330 5
a334 5
	     MAP_UNIT(2) |
	     DISABLE_TEX_STREAM_BUMP |
	     ENABLE_TEX_STREAM_COORD_SET |
	     TEX_STREAM_COORD_SET(2) |
	     ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(2));
d336 5
a340 5
	     MAP_UNIT(3) |
	     DISABLE_TEX_STREAM_BUMP |
	     ENABLE_TEX_STREAM_COORD_SET |
	     TEX_STREAM_COORD_SET(3) |
	     ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(3));
d352 7
a358 15
	     ENABLE_POINT_RASTER_RULE |
	     OGL_POINT_RASTER_RULE |
	     ENABLE_LINE_STRIP_PROVOKE_VRTX |
	     ENABLE_TRI_FAN_PROVOKE_VRTX |
	     ENABLE_TRI_STRIP_PROVOKE_VRTX |
	     LINE_STRIP_PROVOKE_VRTX(1) |
	     TRI_FAN_PROVOKE_VRTX(2) | 
	     TRI_STRIP_PROVOKE_VRTX(2));

   OUT_BATCH(_3DSTATE_SCISSOR_ENABLE_CMD | 
	     DISABLE_SCISSOR_RECT);

   OUT_BATCH(_3DSTATE_SCISSOR_RECT_0_CMD);
   OUT_BATCH(0);
   OUT_BATCH(0);
d369 1
a369 1
   OUT_BATCH(0x80808080);	/* .5 required in alpha for GL_DOT3_RGBA_EXT */
d376 7
a382 7
do {							\
   int k;						\
   BEGIN_BATCH( size / sizeof(GLuint));			\
   for (k = 0 ; k < size / sizeof(GLuint) ; k++)	\
      OUT_BATCH(state[k]);				\
   ADVANCE_BATCH();					\
} while (0);
d384 2
a385 1
static GLuint get_state_size( struct i830_hw_state *state )
d387 1
a387 1
   GLuint dirty = state->active & ~state->emitted;
d394 1
a394 1
   if (dirty & I830_UPLOAD_CTX) 
d397 1
a397 1
   if (dirty & I830_UPLOAD_BUFFERS) 
d400 1
a400 1
   if (dirty & I830_UPLOAD_STIPPLE) 
d404 2
a405 2
      if ((dirty & I830_UPLOAD_TEX(i)))  
	 sz += sizeof(state->Tex[i]); 
d407 2
a408 2
      if (dirty & I830_UPLOAD_TEXBLEND(i)) 
	 sz += state->TexBlendWordsUsed[i] * 4;
d417 2
a418 1
static void i830_emit_state( intelContextPtr intel )
d420 1
a420 1
   i830ContextPtr i830 = I830_CONTEXT(intel);
d422 3
a424 3
   int i;
   GLuint dirty = state->active & ~state->emitted;
   GLuint counter = intel->batch.counter;
d427 21
a447 4
   if (intel->batch.space < get_state_size(state)) {
      intelFlushBatch(intel, GL_TRUE);
      dirty = state->active & ~state->emitted;
      counter = intel->batch.counter;
d449 26
d477 2
a478 2
      if (VERBOSE) fprintf(stderr, "I830_UPLOAD_INVARIENT:\n"); 
      i830_emit_invarient_state( intel );
d482 3
a484 2
      if (VERBOSE) fprintf(stderr, "I830_UPLOAD_CTX:\n"); 
      emit( i830, state->Ctx, sizeof(state->Ctx) );
d488 23
a510 2
      if (VERBOSE) fprintf(stderr, "I830_UPLOAD_BUFFERS:\n"); 
      emit( i830, state->Buffer, sizeof(state->Buffer) );
d512 1
a512 1

d514 2
a515 2
      if (VERBOSE) fprintf(stderr, "I830_UPLOAD_STIPPLE:\n"); 
      emit( i830, state->Stipple, sizeof(state->Stipple) );
d519 26
a544 4
      if ((dirty & I830_UPLOAD_TEX(i))) { 
 	 if (VERBOSE) fprintf(stderr, "I830_UPLOAD_TEX(%d):\n", i); 
	 emit( i830, state->Tex[i], sizeof(state->Tex[i])); 
      } 
d547 3
a549 3
	 if (VERBOSE) fprintf(stderr, "I830_UPLOAD_TEXBLEND(%d):\n", i); 
	 emit( i830, state->TexBlend[i], 
	       state->TexBlendWordsUsed[i] * 4 );
d553 3
a555 3
   state->emitted |= dirty;
   intel->batch.last_emit_state = counter;
   assert(counter == intel->batch.counter);
d558 2
a559 1
static void i830_destroy_context( intelContextPtr intel )
d561 10
d574 6
a579 2
static void
i830_set_color_region(intelContextPtr intel, const intelRegion *region)
d581 56
a636 5
   i830ContextPtr i830 = I830_CONTEXT(intel);
   I830_STATECHANGE( i830, I830_UPLOAD_BUFFERS );
   i830->state.Buffer[I830_DESTREG_CBUFADDR1] =
      (BUF_3D_ID_COLOR_BACK | BUF_3D_PITCH(region->pitch) | BUF_3D_USE_FENCE);
   i830->state.Buffer[I830_DESTREG_CBUFADDR2] = region->offset;
d641 4
a644 1
i830_set_z_region(intelContextPtr intel, const intelRegion *region)
d646 2
a647 5
   i830ContextPtr i830 = I830_CONTEXT(intel);
   I830_STATECHANGE( i830, I830_UPLOAD_BUFFERS );
   i830->state.Buffer[I830_DESTREG_DBUFADDR1] =
      (BUF_3D_ID_DEPTH | BUF_3D_PITCH(region->pitch) | BUF_3D_USE_FENCE);
   i830->state.Buffer[I830_DESTREG_DBUFADDR2] = region->offset;
d650 1
a650 1

d653 2
a654 2
                            const intelRegion *colorRegion,
                            const intelRegion *depthRegion)
d659 2
a660 1
      (BUF_3D_ID_COLOR_BACK | BUF_3D_PITCH(colorRegion->pitch) | BUF_3D_USE_FENCE);
d667 1
d672 2
a673 1
static void i830_lost_hardware( intelContextPtr intel )
d675 5
a679 1
   I830_CONTEXT(intel)->state.emitted = 0;
d684 2
a685 1
static void i830_emit_flush( intelContextPtr intel )
d687 1
a687 6
   BATCH_LOCALS;

   BEGIN_BATCH(2);
   OUT_BATCH( MI_FLUSH | FLUSH_MAP_CACHE ); 
   OUT_BATCH( 0 );
   ADVANCE_BATCH();
d691 7
d699 5
d705 2
a706 1
void i830InitVtbl( i830ContextPtr i830 )
a707 1
   i830->intel.vtbl.alloc_tex_obj = i830AllocTexObj;
a708 2
   i830->intel.vtbl.clear_with_tris = i830ClearWithTris;
   i830->intel.vtbl.rotate_window = i830RotateWindow;
d711 1
a711 1
   i830->intel.vtbl.lost_hardware = i830_lost_hardware;
d713 1
a713 3
   i830->intel.vtbl.set_color_region = i830_set_color_region;
   i830->intel.vtbl.set_z_region = i830_set_z_region;
   i830->intel.vtbl.update_color_z_regions = i830_update_color_z_regions;
d715 1
a715 1
   i830->intel.vtbl.emit_flush = i830_emit_flush;
d717 3
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d28 1
d31 1
d33 1
a33 3
#include "intel_regions.h"
#include "intel_tris.h"
#include "intel_fbo.h"
d37 2
a38 4
#define FILE_DEBUG_FLAG DEBUG_STATE

static GLboolean i830_check_vertex_size(struct intel_context *intel,
                                        GLuint expected);
d62 1
a62 7
static void
i830_render_prevalidate(struct intel_context *intel)
{
}

static void
i830_render_start(struct intel_context *intel)
d64 2
a65 2
   struct gl_context *ctx = &intel->ctx;
   struct i830_context *i830 = i830_context(ctx);
d73 1
a73 1
   RENDERINPUTS_COPY(index_bitset, tnl->render_inputs_bitset);
d83 2
a84 2
   if (RENDERINPUTS_TEST_RANGE(index_bitset, _TNL_FIRST_TEX, _TNL_LAST_TEX)) {
      EMIT_ATTR(_TNL_ATTRIB_POS, EMIT_4F_VIEWPORT, VFT0_XYZW);
d88 1
a88 1
      EMIT_ATTR(_TNL_ATTRIB_POS, EMIT_3F_VIEWPORT, VFT0_XYZ);
d92 2
a93 2
   if (RENDERINPUTS_TEST(index_bitset, _TNL_ATTRIB_POINTSIZE)) {
      EMIT_ATTR(_TNL_ATTRIB_POINTSIZE, EMIT_1F, VFT0_POINT_WIDTH);
d96 2
a97 2
   EMIT_ATTR(_TNL_ATTRIB_COLOR0, EMIT_4UB_4F_BGRA, VFT0_DIFFUSE);

d99 3
a101 3
   if (RENDERINPUTS_TEST(index_bitset, _TNL_ATTRIB_COLOR1) ||
       RENDERINPUTS_TEST(index_bitset, _TNL_ATTRIB_FOG)) {
      if (RENDERINPUTS_TEST(index_bitset, _TNL_ATTRIB_COLOR1)) {
d103 1
a103 1
         EMIT_ATTR(_TNL_ATTRIB_COLOR1, EMIT_3UB_3F_BGR, VFT0_SPEC);
d106 1
a106 1
         EMIT_PAD(3);
d108 2
a109 2
      if (RENDERINPUTS_TEST(index_bitset, _TNL_ATTRIB_FOG))
         EMIT_ATTR(_TNL_ATTRIB_FOG, EMIT_1UB_1F, VFT0_SPEC);
d111 1
a111 1
         EMIT_PAD(1);
d114 1
a114 1
   if (RENDERINPUTS_TEST_RANGE(index_bitset, _TNL_FIRST_TEX, _TNL_LAST_TEX)) {
d118 2
a119 2
         if (RENDERINPUTS_TEST(index_bitset, _TNL_ATTRIB_TEX(i))) {
            GLuint sz = VB->AttribPtr[_TNL_ATTRIB_TEX0 + i]->size;
d121 1
a121 1
            GLuint mcs = (i830->state.Tex[i][I830_TEXREG_MCS] &
d124 30
a153 30
            switch (sz) {
            case 1:
            case 2:
               emit = EMIT_2F;
               sz = 2;
               mcs |= TEXCOORDTYPE_CARTESIAN;
               break;
            case 3:
               emit = EMIT_3F;
               sz = 3;
               mcs |= TEXCOORDTYPE_VECTOR;
               break;
            case 4:
               emit = EMIT_3F_XYW;
               sz = 3;
               mcs |= TEXCOORDTYPE_HOMOGENEOUS;
               break;
            default:
               continue;
            };


            EMIT_ATTR(_TNL_ATTRIB_TEX0 + i, emit, 0);
            v2 |= VRTX_TEX_SET_FMT(count, SZ_TO_HW(sz));
            mcsb1 |= (count + 8) << (i * 4);

            if (mcs != i830->state.Tex[i][I830_TEXREG_MCS]) {
               I830_STATECHANGE(i830, I830_UPLOAD_TEX(i));
               i830->state.Tex[i][I830_TEXREG_MCS] = mcs;
            }
d155 2
a156 2
            count++;
         }
d161 1
a161 1

d168 3
a170 4
       !RENDERINPUTS_EQUAL(index_bitset, i830->last_index_bitset)) {
      int k;

      I830_STATECHANGE(i830, I830_UPLOAD_CTX);
d175 5
a179 5
      intel->vertex_size =
         _tnl_install_attrs(ctx,
                            intel->vertex_attrs,
                            intel->vertex_attr_count,
                            intel->ViewportMatrix.m, 0);
d186 1
a186 1
      RENDERINPUTS_COPY(i830->last_index_bitset, index_bitset);
d188 1
a188 2
      k = i830_check_vertex_size(intel, intel->vertex_size);
      assert(k);
d192 2
a193 2
static void
i830_reduced_primitive_state(struct intel_context *intel, GLenum rprim)
d195 2
a196 2
   struct i830_context *i830 = i830_context(&intel->ctx);
   GLuint st1 = i830->state.Stipple[I830_STPREG_ST1];
d198 1
a198 1
   st1 &= ~ST1_ENABLE;
d200 11
a210 12
   switch (rprim) {
   case GL_TRIANGLES:
      if (intel->ctx.Polygon.StippleFlag && intel->hw_stipple)
         st1 |= ST1_ENABLE;
      break;
   case GL_LINES:
   case GL_POINTS:
   default:
      break;
   }

   i830->intel.reduced_primitive = rprim;
d212 1
a212 2
   if (st1 != i830->state.Stipple[I830_STPREG_ST1]) {
      INTEL_FIREVERTICES(intel);
d214 4
a217 3
      I830_STATECHANGE(i830, I830_UPLOAD_STIPPLE);
      i830->state.Stipple[I830_STPREG_ST1] = st1;
   }
d223 2
a224 2
static GLboolean
i830_check_vertex_size(struct intel_context *intel, GLuint expected)
d226 3
a228 3
   struct i830_context *i830 = i830_context(&intel->ctx);
   int vft0 = i830->state.Ctx[I830_CTXREG_VF];
   int vft1 = i830->state.Ctx[I830_CTXREG_VF2];
d233 5
a237 13
   case VFT0_XY:
      sz = 2;
      break;
   case VFT0_XYZ:
      sz = 3;
      break;
   case VFT0_XYW:
      sz = 3;
      break;
   case VFT0_XYZW:
      sz = 4;
      break;
   default:
d242 6
a247 10
   if (vft0 & VFT0_SPEC)
      sz++;
   if (vft0 & VFT0_DIFFUSE)
      sz++;
   if (vft0 & VFT0_DEPTH_OFFSET)
      sz++;
   if (vft0 & VFT0_POINT_WIDTH)
      sz++;

   for (i = 0; i < nrtex; i++) {
d249 4
a252 12
      case TEXCOORDFMT_2D:
         sz += 2;
         break;
      case TEXCOORDFMT_3D:
         sz += 3;
         break;
      case TEXCOORDFMT_4D:
         sz += 4;
         break;
      case TEXCOORDFMT_1D:
         sz += 1;
         break;
d256 2
a257 2

   if (sz != expected)
d259 1
a259 1

d263 1
a263 2
static void
i830_emit_invarient_state(struct intel_context *intel)
d267 6
a272 1
   BEGIN_BATCH(29);
d285 3
a287 1
             FOG_LINEAR_CONST | FOGSRC_INDEX_Z | ENABLE_FOG_DENSITY);
d293 5
a297 5
             MAP_UNIT(0) |
             DISABLE_TEX_STREAM_BUMP |
             ENABLE_TEX_STREAM_COORD_SET |
             TEX_STREAM_COORD_SET(0) |
             ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(0));
d299 5
a303 5
             MAP_UNIT(1) |
             DISABLE_TEX_STREAM_BUMP |
             ENABLE_TEX_STREAM_COORD_SET |
             TEX_STREAM_COORD_SET(1) |
             ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(1));
d305 5
a309 5
             MAP_UNIT(2) |
             DISABLE_TEX_STREAM_BUMP |
             ENABLE_TEX_STREAM_COORD_SET |
             TEX_STREAM_COORD_SET(2) |
             ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(2));
d311 5
a315 5
             MAP_UNIT(3) |
             DISABLE_TEX_STREAM_BUMP |
             ENABLE_TEX_STREAM_COORD_SET |
             TEX_STREAM_COORD_SET(3) |
             ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(3));
d326 17
d352 1
a352 1
   OUT_BATCH(0x80808080);       /* .5 required in alpha for GL_DOT3_RGBA_EXT */
d359 7
a365 7
   intel_batchbuffer_data(intel->batch, state, size, false)

static GLuint
get_dirty(struct i830_hw_state *state)
{
   return state->active & ~state->emitted;
}
d367 1
a367 2
static GLuint
get_state_size(struct i830_hw_state *state)
d369 1
a369 1
   GLuint dirty = get_dirty(state);
d376 1
a376 4
   if (dirty & I830_UPLOAD_RASTER_RULES)
      sz += sizeof(state->RasterRules);

   if (dirty & I830_UPLOAD_CTX)
d379 1
a379 1
   if (dirty & I830_UPLOAD_BUFFERS)
d382 1
a382 1
   if (dirty & I830_UPLOAD_STIPPLE)
d386 2
a387 2
      if ((dirty & I830_UPLOAD_TEX(i)))
         sz += sizeof(state->Tex[i]);
d389 2
a390 2
      if (dirty & I830_UPLOAD_TEXBLEND(i))
         sz += state->TexBlendWordsUsed[i] * 4;
d399 1
a399 2
static void
i830_emit_state(struct intel_context *intel)
d401 5
a405 7
   struct i830_context *i830 = i830_context(&intel->ctx);
   struct i830_hw_state *state = &i830->state;
   int i, count;
   GLuint dirty;
   drm_intel_bo *aper_array[3 + I830_TEX_UNITS];
   int aper_count;
   GET_CURRENT_CONTEXT(ctx);
d408 4
a411 39
   /* We don't hold the lock at this point, so want to make sure that
    * there won't be a buffer wrap between the state emits and the primitive
    * emit header.
    *
    * It might be better to talk about explicit places where
    * scheduling is allowed, rather than assume that it is whenever a
    * batchbuffer fills up.
    */
   intel_batchbuffer_require_space(intel->batch,
				   get_state_size(state) + INTEL_PRIM_EMIT_SIZE,
				   false);
   count = 0;
 again:
   aper_count = 0;
   dirty = get_dirty(state);

   aper_array[aper_count++] = intel->batch->buf;
   if (dirty & I830_UPLOAD_BUFFERS) {
      aper_array[aper_count++] = state->draw_region->buffer;
      if (state->depth_region)
         aper_array[aper_count++] = state->depth_region->buffer;
   }

   for (i = 0; i < I830_TEX_UNITS; i++)
     if (dirty & I830_UPLOAD_TEX(i)) {
	if (state->tex_buffer[i]) {
	   aper_array[aper_count++] = state->tex_buffer[i];
	}
     }

   if (dri_bufmgr_check_aperture_space(aper_array, aper_count)) {
       if (count == 0) {
	   count++;
	   intel_batchbuffer_flush(intel->batch);
	   goto again;
       } else {
	   _mesa_error(ctx, GL_OUT_OF_MEMORY, "i830 emit state");
	   assert(0);
       }
a413 8

   /* Do this here as we may have flushed the batchbuffer above,
    * causing more state to be dirty!
    */
   dirty = get_dirty(state);
   state->emitted |= dirty;
   assert(get_dirty(state) == 0);

d415 2
a416 7
      DBG("I830_UPLOAD_INVARIENT:\n");
      i830_emit_invarient_state(intel);
   }

   if (dirty & I830_UPLOAD_RASTER_RULES) {
      DBG("I830_UPLOAD_RASTER_RULES:\n");
      emit(intel, state->RasterRules, sizeof(state->RasterRules));
d420 2
a421 3
      DBG("I830_UPLOAD_CTX:\n");
      emit(intel, state->Ctx, sizeof(state->Ctx));

d425 3
a427 19
      GLuint count = 15;

      DBG("I830_UPLOAD_BUFFERS:\n");

      if (state->depth_region)
          count += 3;

      BEGIN_BATCH(count);
      OUT_BATCH(state->Buffer[I830_DESTREG_CBUFADDR0]);
      OUT_BATCH(state->Buffer[I830_DESTREG_CBUFADDR1]);
      OUT_RELOC(state->draw_region->buffer,
		I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER, 0);

      if (state->depth_region) {
         OUT_BATCH(state->Buffer[I830_DESTREG_DBUFADDR0]);
         OUT_BATCH(state->Buffer[I830_DESTREG_DBUFADDR1]);
         OUT_RELOC(state->depth_region->buffer,
		   I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER, 0);
      }
a428 17
      OUT_BATCH(state->Buffer[I830_DESTREG_DV0]);
      OUT_BATCH(state->Buffer[I830_DESTREG_DV1]);
      OUT_BATCH(state->Buffer[I830_DESTREG_SENABLE]);
      OUT_BATCH(state->Buffer[I830_DESTREG_SR0]);
      OUT_BATCH(state->Buffer[I830_DESTREG_SR1]);
      OUT_BATCH(state->Buffer[I830_DESTREG_SR2]);

      assert(state->Buffer[I830_DESTREG_DRAWRECT0] != MI_NOOP);
      OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT0]);
      OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT1]);
      OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT2]);
      OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT3]);
      OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT4]);
      OUT_BATCH(state->Buffer[I830_DESTREG_DRAWRECT5]);
      ADVANCE_BATCH();
   }
   
d430 2
a431 2
      DBG("I830_UPLOAD_STIPPLE:\n");
      emit(intel, state->Stipple, sizeof(state->Stipple));
d435 4
a438 24
      if ((dirty & I830_UPLOAD_TEX(i))) {
         DBG("I830_UPLOAD_TEX(%d):\n", i);

         BEGIN_BATCH(I830_TEX_SETUP_SIZE + 1);
         OUT_BATCH(state->Tex[i][I830_TEXREG_TM0LI]);

         if (state->tex_buffer[i]) {
            OUT_RELOC(state->tex_buffer[i],
		      I915_GEM_DOMAIN_SAMPLER, 0,
                      state->tex_offset[i]);
         }
	 else {
	    OUT_BATCH(state->tex_offset[i]);
	 }

         OUT_BATCH(state->Tex[i][I830_TEXREG_TM0S1]);
         OUT_BATCH(state->Tex[i][I830_TEXREG_TM0S2]);
         OUT_BATCH(state->Tex[i][I830_TEXREG_TM0S3]);
         OUT_BATCH(state->Tex[i][I830_TEXREG_TM0S4]);
         OUT_BATCH(state->Tex[i][I830_TEXREG_MCS]);
         OUT_BATCH(state->Tex[i][I830_TEXREG_CUBE]);

         ADVANCE_BATCH();
      }
d441 3
a443 3
         DBG("I830_UPLOAD_TEXBLEND(%d): %d words\n", i,
             state->TexBlendWordsUsed[i]);
         emit(intel, state->TexBlend[i], state->TexBlendWordsUsed[i] * 4);
d447 3
a449 3
   intel->batch->dirty_state &= ~dirty;
   assert(get_dirty(state) == 0);
   assert((intel->batch->dirty_state & (1<<1)) == 0);
d452 1
a452 2
static void
i830_destroy_context(struct intel_context *intel)
a453 13
   GLuint i;
   struct i830_context *i830 = i830_context(&intel->ctx);

   intel_region_release(&i830->state.draw_region);
   intel_region_release(&i830->state.depth_region);

   for (i = 0; i < I830_TEX_UNITS; i++) {
      if (i830->state.tex_buffer[i] != NULL) {
	 drm_intel_bo_unreference(i830->state.tex_buffer[i]);
	 i830->state.tex_buffer[i] = NULL;
      }
   }

d458 8
a465 21
i830_set_draw_region(struct intel_context *intel,
                     struct intel_region *color_regions[],
                     struct intel_region *depth_region,
		     GLuint num_regions)
{
   struct i830_context *i830 = i830_context(&intel->ctx);
   struct gl_context *ctx = &intel->ctx;
   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0];
   struct intel_renderbuffer *irb = intel_renderbuffer(rb);
   GLuint value;
   struct i830_hw_state *state = &i830->state;
   uint32_t draw_x, draw_y;

   if (state->draw_region != color_regions[0]) {
      intel_region_release(&state->draw_region);
      intel_region_reference(&state->draw_region, color_regions[0]);
   }
   if (state->depth_region != depth_region) {
      intel_region_release(&state->depth_region);
      intel_region_reference(&state->depth_region, depth_region);
   }
a466 5
   /*
    * Set stride/cpp values
    */
   i915_set_buf_info_for_region(&state->Buffer[I830_DESTREG_CBUFADDR0],
				color_regions[0], BUF_3D_ID_COLOR_BACK);
d468 9
a476 2
   i915_set_buf_info_for_region(&state->Buffer[I830_DESTREG_DBUFADDR0],
				depth_region, BUF_3D_ID_DEPTH);
a477 5
   /*
    * Compute/set I830_DESTREG_DV1 value
    */
   value = (DSTORG_HORT_BIAS(0x8) |     /* .5 */
            DSTORG_VERT_BIAS(0x8) | DEPTH_IS_Z);    /* .5 */
d479 15
a493 63
   if (irb != NULL) {
      switch (irb->Base.Format) {
      case MESA_FORMAT_ARGB8888:
      case MESA_FORMAT_XRGB8888:
	 value |= DV_PF_8888;
	 break;
      case MESA_FORMAT_RGB565:
	 value |= DV_PF_565;
	 break;
      case MESA_FORMAT_ARGB1555:
	 value |= DV_PF_1555;
	 break;
      case MESA_FORMAT_ARGB4444:
	 value |= DV_PF_4444;
	 break;
      default:
	 _mesa_problem(ctx, "Bad renderbuffer format: %d\n",
		       irb->Base.Format);
      }
   }

   if (depth_region && depth_region->cpp == 4) {
      value |= DEPTH_FRMT_24_FIXED_8_OTHER;
   }
   else {
      value |= DEPTH_FRMT_16_FIXED;
   }
   state->Buffer[I830_DESTREG_DV1] = value;

   /* We set up the drawing rectangle to be offset into the color
    * region's location in the miptree.  If it doesn't match with
    * depth's offsets, we can't render to it.
    *
    * (Well, not actually true -- the hw grew a bit to let depth's
    * offset get forced to 0,0.  We may want to use that if people are
    * hitting that case.  Also, some configurations may be supportable
    * by tweaking the start offset of the buffers around, which we
    * can't do in general due to tiling)
    */
   FALLBACK(intel, I830_FALLBACK_DRAW_OFFSET,
	    (depth_region && color_regions[0]) &&
	    (depth_region->draw_x != color_regions[0]->draw_x ||
	     depth_region->draw_y != color_regions[0]->draw_y));

   if (color_regions[0]) {
      draw_x = color_regions[0]->draw_x;
      draw_y = color_regions[0]->draw_y;
   } else if (depth_region) {
      draw_x = depth_region->draw_x;
      draw_y = depth_region->draw_y;
   } else {
      draw_x = 0;
      draw_y = 0;
   }

   state->Buffer[I830_DESTREG_DRAWRECT0] = _3DSTATE_DRAWRECT_INFO;
   state->Buffer[I830_DESTREG_DRAWRECT1] = 0;
   state->Buffer[I830_DESTREG_DRAWRECT2] = (draw_y << 16) | draw_x;
   state->Buffer[I830_DESTREG_DRAWRECT3] =
      ((ctx->DrawBuffer->Width + draw_x) & 0xffff) |
      ((ctx->DrawBuffer->Height + draw_y) << 16);
   state->Buffer[I830_DESTREG_DRAWRECT4] = (draw_y << 16) | draw_x;
   state->Buffer[I830_DESTREG_DRAWRECT5] = MI_NOOP;
a494 2
   I830_STATECHANGE(i830, I830_UPLOAD_BUFFERS);
}
d498 1
a498 2
static void
i830_new_batch(struct intel_context *intel)
d500 1
a500 2
   struct i830_context *i830 = i830_context(&intel->ctx);
   i830->state.emitted = 0;
d503 3
a505 2
static void 
i830_assert_not_dirty( struct intel_context *intel )
d507 6
a512 3
   struct i830_context *i830 = i830_context(&intel->ctx);
   assert(!get_dirty(&i830->state));
   (void) i830;
a514 6
static void
i830_invalidate_state(struct intel_context *intel, GLuint new_state)
{
   if (new_state & _NEW_LIGHT)
      i830_update_provoking_vertex(&intel->ctx);
}
d516 3
a518 2
void
i830InitVtbl(struct i830_context *i830)
d520 1
d522 2
d526 1
a526 1
   i830->intel.vtbl.new_batch = i830_new_batch;
d528 3
a530 1
   i830->intel.vtbl.set_draw_region = i830_set_draw_region;
d532 1
a533 4
   i830->intel.vtbl.render_prevalidate = i830_render_prevalidate;
   i830->intel.vtbl.assert_not_dirty = i830_assert_not_dirty;
   i830->intel.vtbl.finish_batch = intel_finish_vb;
   i830->intel.vtbl.invalidate_state = i830_invalidate_state;
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@a30 1
#include "intel_mipmap_tree.h"
a33 2
#include "intel_buffers.h"
#include "tnl/tnl.h"
a35 4
#include "swrast_setup/swrast_setup.h"
#include "main/renderbuffer.h"
#include "main/framebuffer.h"
#include "main/fbobject.h"
d39 2
a40 2
static bool i830_check_vertex_size(struct intel_context *intel,
				   GLuint expected);
d76 1
a76 1
   GLbitfield64 index_bitset = tnl->render_inputs_bitset;
d81 2
d91 1
a91 1
   if (index_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_TEX0, _TNL_NUM_TEX)) {
d100 1
a100 1
   if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_POINTSIZE)) {
d107 3
a109 3
   if (index_bitset & (BITFIELD64_BIT(_TNL_ATTRIB_COLOR1) |
                       BITFIELD64_BIT(_TNL_ATTRIB_FOG))) {
      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_COLOR1)) {
d116 1
a116 1
      if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_FOG))
d122 1
a122 1
   if (index_bitset & BITFIELD64_RANGE(_TNL_ATTRIB_TEX0, _TNL_NUM_TEX)) {
d126 1
a126 1
         if (index_bitset & BITFIELD64_BIT(_TNL_ATTRIB_TEX(i))) {
d176 3
a178 1
       index_bitset != i830->last_index_bitset) {
d195 1
a195 1
      i830->last_index_bitset = index_bitset;
d197 2
a198 1
      assert(i830_check_vertex_size(intel, intel->vertex_size));
d234 1
a234 1
static bool
d367 1
a367 1
   intel_batchbuffer_data(intel, state, size)
d431 3
a433 3
   intel_batchbuffer_require_space(intel,
				   get_state_size(state) +
                                   INTEL_PRIM_EMIT_SIZE);
d439 1
a439 1
   aper_array[aper_count++] = intel->batch.bo;
d441 1
a441 1
      aper_array[aper_count++] = state->draw_region->bo;
d443 1
a443 1
         aper_array[aper_count++] = state->depth_region->bo;
d456 1
a456 1
	   intel_batchbuffer_flush(intel);
d499 1
a499 1
      OUT_RELOC(state->draw_region->bo,
d505 1
a505 1
         OUT_RELOC(state->depth_region->bo,
d538 8
a545 3
	 OUT_RELOC(state->tex_buffer[i],
		   I915_GEM_DOMAIN_SAMPLER, 0,
		   state->tex_offset[i]);
d564 1
d566 1
a587 24
static uint32_t i830_render_target_format_for_mesa_format[MESA_FORMAT_COUNT] =
{
   [MESA_FORMAT_ARGB8888] = DV_PF_8888,
   [MESA_FORMAT_XRGB8888] = DV_PF_8888,
   [MESA_FORMAT_RGB565] = DV_PF_565,
   [MESA_FORMAT_ARGB1555] = DV_PF_1555,
   [MESA_FORMAT_ARGB4444] = DV_PF_4444,
};

static bool
i830_render_target_supported(struct intel_context *intel,
			     struct gl_renderbuffer *rb)
{
   gl_format format = rb->Format;

   if (format == MESA_FORMAT_S8_Z24 ||
       format == MESA_FORMAT_X8_Z24 ||
       format == MESA_FORMAT_Z16) {
      return true;
   }

   return i830_render_target_format_for_mesa_format[format] != 0;
}

a597 2
   struct gl_renderbuffer *drb;
   struct intel_renderbuffer *idrb = NULL;
d603 1
d607 1
d627 18
a644 1
      value |= i830_render_target_format_for_mesa_format[intel_rb_format(irb)];
a654 7
   drb = ctx->DrawBuffer->Attachment[BUFFER_DEPTH].Renderbuffer;
   if (!drb)
      drb = ctx->DrawBuffer->Attachment[BUFFER_STENCIL].Renderbuffer;

   if (drb)
      idrb = intel_renderbuffer(drb);

d666 10
a675 9
	    idrb && irb && (idrb->draw_x != irb->draw_x ||
			    idrb->draw_y != irb->draw_y));

   if (irb) {
      draw_x = irb->draw_x;
      draw_y = irb->draw_y;
   } else if (idrb) {
      draw_x = idrb->draw_x;
      draw_y = idrb->draw_y;
d685 2
a686 2
      ((ctx->DrawBuffer->Width + draw_x - 1) & 0xffff) |
      ((ctx->DrawBuffer->Height + draw_y - 1) << 16);
a692 150
/**
 * Update the hardware state for drawing into a window or framebuffer object.
 *
 * Called by glDrawBuffer, glBindFramebufferEXT, MakeCurrent, and other
 * places within the driver.
 *
 * Basically, this needs to be called any time the current framebuffer
 * changes, the renderbuffers change, or we need to draw into different
 * color buffers.
 */
static void
i830_update_draw_buffer(struct intel_context *intel)
{
   struct gl_context *ctx = &intel->ctx;
   struct gl_framebuffer *fb = ctx->DrawBuffer;
   struct intel_region *colorRegions[MAX_DRAW_BUFFERS], *depthRegion = NULL;
   struct intel_renderbuffer *irbDepth = NULL, *irbStencil = NULL;

   if (!fb) {
      /* this can happen during the initial context initialization */
      return;
   }

   irbDepth = intel_get_renderbuffer(fb, BUFFER_DEPTH);
   irbStencil = intel_get_renderbuffer(fb, BUFFER_STENCIL);

   /* Do this here, not core Mesa, since this function is called from
    * many places within the driver.
    */
   if (ctx->NewState & _NEW_BUFFERS) {
      /* this updates the DrawBuffer->_NumColorDrawBuffers fields, etc */
      _mesa_update_framebuffer(ctx);
      /* this updates the DrawBuffer's Width/Height if it's a FBO */
      _mesa_update_draw_buffer_bounds(ctx);
   }

   if (fb->_Status != GL_FRAMEBUFFER_COMPLETE_EXT) {
      /* this may occur when we're called by glBindFrameBuffer() during
       * the process of someone setting up renderbuffers, etc.
       */
      /*_mesa_debug(ctx, "DrawBuffer: incomplete user FBO\n");*/
      return;
   }

   /* How many color buffers are we drawing into?
    *
    * If there are zero buffers or the buffer is too big, don't configure any
    * regions for hardware drawing.  We'll fallback to software below.  Not
    * having regions set makes some of the software fallback paths faster.
    */
   if ((fb->Width > ctx->Const.MaxRenderbufferSize)
       || (fb->Height > ctx->Const.MaxRenderbufferSize)
       || (fb->_NumColorDrawBuffers == 0)) {
      /* writing to 0  */
      colorRegions[0] = NULL;
   }
   else if (fb->_NumColorDrawBuffers > 1) {
       int i;
       struct intel_renderbuffer *irb;

       for (i = 0; i < fb->_NumColorDrawBuffers; i++) {
           irb = intel_renderbuffer(fb->_ColorDrawBuffers[i]);
           colorRegions[i] = (irb && irb->mt) ? irb->mt->region : NULL;
       }
   }
   else {
      /* Get the intel_renderbuffer for the single colorbuffer we're drawing
       * into.
       */
      if (_mesa_is_winsys_fbo(fb)) {
	 /* drawing to window system buffer */
	 if (fb->_ColorDrawBufferIndexes[0] == BUFFER_FRONT_LEFT)
	    colorRegions[0] = intel_get_rb_region(fb, BUFFER_FRONT_LEFT);
	 else
	    colorRegions[0] = intel_get_rb_region(fb, BUFFER_BACK_LEFT);
      }
      else {
	 /* drawing to user-created FBO */
	 struct intel_renderbuffer *irb;
	 irb = intel_renderbuffer(fb->_ColorDrawBuffers[0]);
	 colorRegions[0] = (irb && irb->mt->region) ? irb->mt->region : NULL;
      }
   }

   if (!colorRegions[0]) {
      FALLBACK(intel, INTEL_FALLBACK_DRAW_BUFFER, true);
   }
   else {
      FALLBACK(intel, INTEL_FALLBACK_DRAW_BUFFER, false);
   }

   /* Check for depth fallback. */
   if (irbDepth && irbDepth->mt) {
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, false);
      depthRegion = irbDepth->mt->region;
   } else if (irbDepth && !irbDepth->mt) {
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, true);
      depthRegion = NULL;
   } else { /* !irbDepth */
      /* No fallback is needed because there is no depth buffer. */
      FALLBACK(intel, INTEL_FALLBACK_DEPTH_BUFFER, false);
      depthRegion = NULL;
   }

   /* Check for stencil fallback. */
   if (irbStencil && irbStencil->mt) {
      assert(intel_rb_format(irbStencil) == MESA_FORMAT_S8_Z24);
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, false);
   } else if (irbStencil && !irbStencil->mt) {
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, true);
   } else { /* !irbStencil */
      /* No fallback is needed because there is no stencil buffer. */
      FALLBACK(intel, INTEL_FALLBACK_STENCIL_BUFFER, false);
   }

   /* If we have a (packed) stencil buffer attached but no depth buffer,
    * we still need to set up the shared depth/stencil state so we can use it.
    */
   if (depthRegion == NULL && irbStencil && irbStencil->mt
       && intel_rb_format(irbStencil) == MESA_FORMAT_S8_Z24) {
      depthRegion = irbStencil->mt->region;
   }

   /*
    * Update depth and stencil test state
    */
   ctx->Driver.Enable(ctx, GL_DEPTH_TEST, ctx->Depth.Test);
   ctx->Driver.Enable(ctx, GL_STENCIL_TEST,
		      (ctx->Stencil.Enabled && fb->Visual.stencilBits > 0));

   intel->vtbl.set_draw_region(intel, colorRegions, depthRegion,
                               fb->_NumColorDrawBuffers);
   intel->NewGLState |= _NEW_BUFFERS;

   /* update viewport since it depends on window size */
   intelCalcViewport(ctx);

   /* Set state we know depends on drawable parameters:
    */
   ctx->Driver.Scissor(ctx, ctx->Scissor.X, ctx->Scissor.Y,
		       ctx->Scissor.Width, ctx->Scissor.Height);

   ctx->Driver.DepthRange(ctx, ctx->Viewport.Near, ctx->Viewport.Far);

   /* Update culling direction which changes depending on the
    * orientation of the buffer:
    */
   ctx->Driver.FrontFace(ctx, ctx->Polygon.FrontFace);
}

a712 6
   struct gl_context *ctx = &intel->ctx;

   _swsetup_InvalidateState(ctx, new_state);
   _tnl_InvalidateState(ctx, new_state);
   _tnl_invalidate_vertex_state(ctx, new_state);

a725 1
   i830->intel.vtbl.update_draw_buffer = i830_update_draw_buffer;
a731 1
   i830->intel.vtbl.render_target_supported = i830_render_target_supported;
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d585 5
a589 5
   [MESA_FORMAT_B8G8R8A8_UNORM] = DV_PF_8888,
   [MESA_FORMAT_B8G8R8X8_UNORM] = DV_PF_8888,
   [MESA_FORMAT_B5G6R5_UNORM] = DV_PF_565,
   [MESA_FORMAT_B5G5R5A1_UNORM] = DV_PF_1555,
   [MESA_FORMAT_B4G4R4A4_UNORM] = DV_PF_4444,
d596 1
a596 1
   mesa_format format = rb->Format;
d598 3
a600 3
   if (format == MESA_FORMAT_Z24_UNORM_S8_UINT ||
       format == MESA_FORMAT_Z24_UNORM_X8_UINT ||
       format == MESA_FORMAT_Z_UNORM16) {
d807 1
a807 1
      assert(intel_rb_format(irbStencil) == MESA_FORMAT_Z24_UNORM_S8_UINT);
d820 1
a820 1
       && intel_rb_format(irbStencil) == MESA_FORMAT_Z24_UNORM_S8_UINT) {
d835 3
d840 4
a843 2
   intelCalcViewport(ctx);
   ctx->Driver.Scissor(ctx);
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d513 1
a516 1
      OUT_BATCH(state->Buffer[I830_DESTREG_SENABLE]);
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@a512 1
      OUT_BATCH(state->Buffer[I830_DESTREG_SENABLE]);
d516 1
@


