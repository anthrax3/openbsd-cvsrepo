head	1.4;
access;
symbols
	OPENBSD_5_4:1.3.0.14
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.12
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.10
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.3.0.6
	OPENBSD_4_5_BASE:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2013.09.05.14.04.40;	author jsg;	state dead;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.57;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.57;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.20;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.28.48;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.39;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge Mesa 9.2.0
@
text
@/* -*- mode: c; c-basic-offset: 3 -*- */
/*
 * Copyright 1999, 2000 ATI Technologies Inc. and Precision Insight, Inc.,
 *                                                Cedar Park, Texas.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * ATI, PRECISION INSIGHT AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * Authors:
 *   Gareth Hughes <gareth@@valinux.com>
 *   Leif Delgass <ldelgass@@retinalburn.net>
 *   Jose Fonseca <j_r_fonseca@@yahoo.co.uk>
 */

#include "main/context.h"
#include "main/macros.h"
#include "main/simple_list.h"
#include "main/imports.h"

#include "mach64_context.h"
#include "mach64_ioctl.h"
#include "mach64_tex.h"


/* Destroy hardware state associated with texture `t'.
 */
void mach64DestroyTexObj( mach64ContextPtr mmesa, mach64TexObjPtr t )
{
   unsigned   i;

   /* See if it was the driver's current object.
    */
   if ( mmesa != NULL )
   {
      for ( i = 0 ; i < mmesa->glCtx->Const.MaxTextureUnits ; i++ )
      {
         if ( t == mmesa->CurrentTexObj[ i ] ) {
            assert( t->base.bound & (1 << i) );
            mmesa->CurrentTexObj[ i ] = NULL;
         }
      }
   }
}

/* Upload the texture image associated with texture `t' at level `level'
 * at the address relative to `start'.
 */
static void mach64UploadAGPSubImage( mach64ContextPtr mmesa,
				     mach64TexObjPtr t, int level,
				     int x, int y, int width, int height )
{
   mach64ScreenRec *mach64Screen = mmesa->mach64Screen;
   struct gl_texture_image *image;
   int texelsPerDword = 0;
   int dwords;
   GLuint texelBytes;

   /* Ensure we have a valid texture to upload */
   if ( ( level < 0 ) || ( level > mmesa->glCtx->Const.MaxTextureLevels ) )
     return;

   image = t->base.tObj->Image[0][level];
   if ( !image )
      return;

   texelBytes = _mesa_get_format_bytes(image->TexFormat);

   switch ( texelBytes ) {
   case 1: texelsPerDword = 4; break;
   case 2: texelsPerDword = 2; break;
   case 4: texelsPerDword = 1; break;
   }

#if 1
   /* FIXME: The subimage index calcs are wrong... */
   x = 0;
   y = 0;
   width = image->Width;
   height = image->Height;
#endif

   dwords = width * height / texelsPerDword;

#if ENABLE_PERF_BOXES
   /* Bump the performance counter */
   mmesa->c_agpTextureBytes += (dwords << 2);
#endif

   if ( MACH64_DEBUG & DEBUG_VERBOSE_API ) {
      fprintf( stderr, "mach64UploadSubImage: %d,%d of %d,%d at %d,%d\n",
	       width, height, image->Width, image->Height, x, y );
      fprintf( stderr, "            blit ofs: 0x%07x pitch: 0x%x dwords: %d\n",
	       (GLuint)t->bufAddr, (GLint)width, dwords );
   }

   assert(image->Data);

   {
      CARD32 *dst = (CARD32 *)((char *)mach64Screen->agpTextures.map + t->base.memBlock->ofs);
      const GLubyte *src = (const GLubyte *) image->Data +
	 (y * image->Width + x) * texelBytes;
      const GLuint bytes = width * height * texelBytes;
      memcpy(dst, src, bytes);
   }

}

/* Upload the texture image associated with texture `t' at level `level'
 * at the address relative to `start'.
 */
static void mach64UploadLocalSubImage( mach64ContextPtr mmesa,
				  mach64TexObjPtr t, int level,
				  int x, int y, int width, int height )
{
   struct gl_texture_image *image;
   int texelsPerDword = 0;
   int imageWidth, imageHeight;
   int remaining, rows;
   int format, dwords;
   const int maxdwords = (MACH64_BUFFER_MAX_DWORDS - (MACH64_HOSTDATA_BLIT_OFFSET / 4));
   CARD32 pitch, offset;
   int i;
   GLuint texelBytes;

   /* Ensure we have a valid texture to upload */
   if ( ( level < 0 ) || ( level > mmesa->glCtx->Const.MaxTextureLevels ) )
      return;

   image = t->base.tObj->Image[0][level];
   if ( !image )
      return;

   texelBytes = _mesa_get_format_bytes(image->TexFormat);

   switch ( texelBytes ) {
   case 1: texelsPerDword = 4; break;
   case 2: texelsPerDword = 2; break;
   case 4: texelsPerDword = 1; break;
   }

#if 1
   /* FIXME: The subimage index calcs are wrong... */
   x = 0;
   y = 0;
   width = image->Width;
   height = image->Height;
#endif

   imageWidth  = image->Width;
   imageHeight = image->Height;

   format = t->textureFormat;

   /* The texel upload routines have a minimum width, so force the size
    * if needed.
    */
   if ( imageWidth < texelsPerDword ) {
      int factor;

      factor = texelsPerDword / imageWidth;
      imageWidth = texelsPerDword;
      imageHeight /= factor;
      if ( imageHeight == 0 ) {
	 /* In this case, the texel converter will actually walk a
	  * texel or two off the end of the image, but normal malloc
	  * alignment should prevent it from ever causing a fault.
	  */
	 imageHeight = 1;
      }
   }

   /* We can't upload to a pitch less than 64 texels so we will need to
    * linearly upload all modified rows for textures smaller than this.
    * This makes the x/y/width/height different for the blitter and the
    * texture walker.
    */
   if ( imageWidth >= 64 ) {
      /* The texture walker and the blitter look identical */
      pitch = imageWidth >> 3;
   } else {
      int factor;
      int y2;
      int start, end;

      start = (y * imageWidth) & ~63;
      end = (y + height) * imageWidth;

      if ( end - start < 64 ) {
	 /* Handle the case where the total number of texels
	  * uploaded is < 64.
	  */
	 x = 0;
	 y = start / 64;
	 width = end - start;
	 height = 1;
      } else {
	 /* Upload some number of full 64 texel blit rows */
	 factor = 64 / imageWidth;

	 y2 = y + height - 1;
	 y /= factor;
	 y2 /= factor;

	 x = 0;
	 width = 64;
	 height = y2 - y + 1;
      }

      /* Fixed pitch of 64 */
      pitch = 8;
   }

   dwords = width * height / texelsPerDword;
   offset = t->bufAddr;

#if ENABLE_PERF_BOXES
   /* Bump the performance counter */
   mmesa->c_textureBytes += (dwords << 2);
#endif

   if ( MACH64_DEBUG & DEBUG_VERBOSE_API ) {
      fprintf( stderr, "mach64UploadSubImage: %d,%d of %d,%d at %d,%d\n",
	       width, height, image->Width, image->Height, x, y );
      fprintf( stderr, "            blit ofs: 0x%07x pitch: 0x%x dwords: %d\n",
	       (GLuint)offset, (GLint)width, dwords );
   }

   /* Subdivide the texture if required (account for the registers added by the drm) */
   if ( dwords <= maxdwords ) {
      rows = height;
   } else {
      rows = (maxdwords * texelsPerDword) / (2 * width);
   }

   for ( i = 0, remaining = height ;
	 remaining > 0 ;
	 remaining -= rows, y += rows, i++ )
   {
       height = MIN2(remaining, rows);

       assert(image->Data);

       {
          const GLubyte *src = (const GLubyte *) image->Data +
             (y * image->Width + x) * texelBytes;

          mach64FireBlitLocked( mmesa, (void *)src, offset, pitch, format,
				x, y, width, height );
       }

   }

   mmesa->new_state |= MACH64_NEW_CONTEXT;
   mmesa->dirty |= MACH64_UPLOAD_CONTEXT | MACH64_UPLOAD_MISC;
}


/* Upload the texture images associated with texture `t'.  This might
 * require removing our own and/or other client's texture objects to
 * make room for these images.
 */
void mach64UploadTexImages( mach64ContextPtr mmesa, mach64TexObjPtr t )
{
   if ( MACH64_DEBUG & DEBUG_VERBOSE_API ) {
      fprintf( stderr, "%s( %p, %p )\n",
	       __FUNCTION__, mmesa->glCtx, t );
   }

   assert(t);
   assert(t->base.tObj);

   if ( !t->base.memBlock ) {
      int heap;

      /* NULL heaps are skipped */
      heap = driAllocateTexture( mmesa->texture_heaps, MACH64_NR_TEX_HEAPS,
				 (driTextureObject *) t );

      if ( heap == -1 ) {
	 fprintf( stderr, "%s: upload texture failure, sz=%d\n", __FUNCTION__,
		  t->base.totalSize );
	 exit(-1);
	 return;
      }

      t->heap = heap;

      /* Set the base offset of the texture image */
      assert(t->base.memBlock);
      t->bufAddr = mmesa->mach64Screen->texOffset[heap] + t->base.memBlock->ofs;

      /* Force loading the new state into the hardware */
      mmesa->dirty |= (MACH64_UPLOAD_SCALE_3D_CNTL |
		       MACH64_UPLOAD_TEXTURE);
   }

   /* Let the world know we've used this memory recently */
   driUpdateTextureLRU( (driTextureObject *) t );

   /* Upload any images that are new */
   if ( t->base.dirty_images[0] ) {
      const GLint j = t->base.tObj->BaseLevel;
      if (t->heap == MACH64_AGP_HEAP) {
	 /* Need to make sure any vertex buffers in the queue complete */
	 mach64WaitForIdleLocked( mmesa );
	 mach64UploadAGPSubImage( mmesa, t, j, 0, 0,
				  t->base.tObj->Image[0][j]->Width,
				  t->base.tObj->Image[0][j]->Height );
      } else {
	 mach64UploadLocalSubImage( mmesa, t, j, 0, 0,
				    t->base.tObj->Image[0][j]->Width,
				    t->base.tObj->Image[0][j]->Height );
      }

      mmesa->setup.tex_cntl |= MACH64_TEX_CACHE_FLUSH;
      t->base.dirty_images[0] = 0;
   }

   mmesa->dirty |= MACH64_UPLOAD_TEXTURE;
}


/* Allocate memory from the same texture heap `heap' for both textures
 * `u0' and `u1'.
 */
static int mach64AllocateMultiTex( mach64ContextPtr mmesa,
				   mach64TexObjPtr u0,
				   mach64TexObjPtr u1,
				   int heap, GLboolean alloc_u0 )
{
   /* Both objects should be bound */
   assert( u0->base.bound && u1->base.bound );

   if ( alloc_u0 ) {
      /* Evict u0 from its current heap */
      if ( u0->base.memBlock ) {
	 assert( u0->heap != heap );
	 driSwapOutTextureObject( (driTextureObject *) u0 );
      }

      /* Try to allocate u0 in the chosen heap */
      u0->heap = driAllocateTexture( &mmesa->texture_heaps[heap], 1,
				     (driTextureObject *) u0 );

      if ( u0->heap == -1 ) {
	 return -1;
      }
   }

   /* Evict u1 from its current heap */
   if ( u1->base.memBlock ) {
      assert( u1->heap != heap );
      driSwapOutTextureObject( (driTextureObject *) u1 );
   }

   /* Try to allocate u1 in the same heap as u0 */
   u1->heap = driAllocateTexture( &mmesa->texture_heaps[heap], 1,
				  (driTextureObject *) u1 );

   if ( u1->heap == -1 ) {
      return -1;
   }

   /* Bound objects are not evicted */
   assert( u0->base.memBlock && u1->base.memBlock );
   assert( u0->heap == u1->heap );

   return heap;
}

/* The mach64 needs to have both primary and secondary textures in either
 * local or AGP memory, so we need a "buddy system" to make sure that allocation
 * succeeds or fails for both textures.
 */
void mach64UploadMultiTexImages( mach64ContextPtr mmesa, 
				 mach64TexObjPtr t0,
				 mach64TexObjPtr t1 )
{
   if ( MACH64_DEBUG & DEBUG_VERBOSE_API ) {
      fprintf( stderr, "%s( %p, %p %p )\n",
	       __FUNCTION__, mmesa->glCtx, t0, t1 );
   }

   assert(t0 && t1);
   assert(t0->base.tObj && t1->base.tObj);

   if ( !t0->base.memBlock || !t1->base.memBlock || t0->heap != t1->heap ) {
      mach64TexObjPtr u0 = NULL;
      mach64TexObjPtr u1 = NULL;
      unsigned totalSize = t0->base.totalSize + t1->base.totalSize;

      int heap, ret;

      /* Check if one of the textures is already swapped in a heap and the
       * other texture fits in that heap.
       */
      if ( t0->base.memBlock && totalSize <= t0->base.heap->size ) {
	 u0 = t0;
	 u1 = t1;
      } else if ( t1->base.memBlock && totalSize <= t1->base.heap->size ) {
	 u0 = t1;
	 u1 = t0;
      }

      if ( u0 ) {
	 heap = u0->heap;

	 ret = mach64AllocateMultiTex( mmesa, u0, u1, heap, GL_FALSE );
      } else {
	 /* Both textures are swapped out or collocation is impossible */
	 u0 = t0;
	 u1 = t1;

	 /* Choose the heap appropriately */
	 heap = MACH64_CARD_HEAP;

	 if ( totalSize > mmesa->texture_heaps[heap]->size ) {
	    heap = MACH64_AGP_HEAP;
	 }

	 ret = mach64AllocateMultiTex( mmesa, u0, u1, heap, GL_TRUE );
      }

      if ( ret == -1 && heap == MACH64_CARD_HEAP ) {
	 /* Try AGP if local memory failed */
	 heap = MACH64_AGP_HEAP;

	 ret = mach64AllocateMultiTex( mmesa, u0, u1, heap, GL_TRUE );
      }

      if ( ret == -1 ) {
	 /* FIXME:
	  * Swap out all textures from the AGP heap and re-run allocation, this
	  * should succeed in all cases.
	  */
	 fprintf( stderr, "%s: upload multi-texture failure, sz0=%d sz1=%d\n",
		  __FUNCTION__, t0->base.totalSize, t1->base.totalSize );
	 exit(-1);
      }

      /* Set the base offset of the texture image */
      assert(t0->base.memBlock);
      t0->bufAddr = mmesa->mach64Screen->texOffset[heap] + t0->base.memBlock->ofs;
      assert(t1->base.memBlock);
      t1->bufAddr = mmesa->mach64Screen->texOffset[heap] + t1->base.memBlock->ofs;

      /* Force loading the new state into the hardware */
      mmesa->dirty |= (MACH64_UPLOAD_SCALE_3D_CNTL |
		       MACH64_UPLOAD_TEXTURE);
   }

   /* Let the world know we've used this memory recently */
   driUpdateTextureLRU( (driTextureObject *) t0 );
   driUpdateTextureLRU( (driTextureObject *) t1 );

   /* Upload any images that are new */
   if ( t0->base.dirty_images[0] ) {
      const GLint j0 = t0->base.tObj->BaseLevel;
      if (t0->heap == MACH64_AGP_HEAP) {
	 /* Need to make sure any vertex buffers in the queue complete */
	 mach64WaitForIdleLocked( mmesa );
	 mach64UploadAGPSubImage( mmesa, t0, j0, 0, 0,
				    t0->base.tObj->Image[0][j0]->Width,
				    t0->base.tObj->Image[0][j0]->Height );
      } else {
	 mach64UploadLocalSubImage( mmesa, t0, j0, 0, 0,
				    t0->base.tObj->Image[0][j0]->Width,
				    t0->base.tObj->Image[0][j0]->Height );
      }
      mmesa->setup.tex_cntl |= MACH64_TEX_CACHE_FLUSH;
      t0->base.dirty_images[0] = 0;
   }
   if ( t1->base.dirty_images[0] ) {
      const GLint j1 = t1->base.tObj->BaseLevel;
      if (t1->heap == MACH64_AGP_HEAP) {
	 /* Need to make sure any vertex buffers in the queue complete */
	 mach64WaitForIdleLocked( mmesa );
	 mach64UploadAGPSubImage( mmesa, t1, j1, 0, 0,
			       t1->base.tObj->Image[0][j1]->Width,
			       t1->base.tObj->Image[0][j1]->Height );
      } else {
	 mach64UploadLocalSubImage( mmesa, t1, j1, 0, 0,
			       t1->base.tObj->Image[0][j1]->Width,
			       t1->base.tObj->Image[0][j1]->Height );
      }
      
      mmesa->setup.tex_cntl |= MACH64_TEX_CACHE_FLUSH;
      t1->base.dirty_images[0] = 0;
   }

   mmesa->dirty |= MACH64_UPLOAD_TEXTURE;
}
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a33 7
#include "mach64_context.h"
#include "mach64_state.h"
#include "mach64_ioctl.h"
#include "mach64_vb.h"
#include "mach64_tris.h"
#include "mach64_tex.h"

a36 1
#include "main/texformat.h"
d39 4
d75 1
d85 3
a87 1
   switch ( image->TexFormat->TexelBytes ) {
d120 2
a121 2
	 (y * image->Width + x) * image->TexFormat->TexelBytes;
      const GLuint bytes = width * height * image->TexFormat->TexelBytes;
d142 1
d152 3
a154 1
   switch ( image->TexFormat->TexelBytes ) {
d264 1
a264 1
             (y * image->Width + x) * image->TexFormat->TexelBytes;
d308 1
d461 1
d463 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XFree86$ */ /* -*- mode: c; c-basic-offset: 3 -*- */
d41 5
a45 5
#include "context.h"
#include "macros.h"
#include "simple_list.h"
#include "texformat.h"
#include "imports.h"
d52 1
a52 60
#if ENABLE_PERF_BOXES
   /* Bump the performace counter */
   if (mmesa)
      mmesa->c_textureSwaps++;
#endif
   if ( !t ) return;

#if 0
   if ( t->tObj && t->memBlock && mmesa ) {
      /* not a placeholder, so release from global LRU if necessary */
      int heap = t->heap;
      drmTextureRegion *list = mmesa->sarea->tex_list[heap];
      int log2sz = mmesa->mach64Screen->logTexGranularity[heap];
      int start = t->memBlock->ofs >> log2sz;
      int end = (t->memBlock->ofs + t->memBlock->size - 1) >> log2sz;
      int i;

      mmesa->lastTexAge[heap] = ++mmesa->sarea->tex_age[heap];

      /* Update the global LRU */
      for ( i = start ; i <= end ; i++ ) {
	 /* do we own this block? */
	 if (list[i].in_use == mmesa->hHWContext) {
	    list[i].in_use = 0;
	    list[i].age = mmesa->lastTexAge[heap];

	    /* remove_from_list(i) */
	    list[(GLuint)list[i].next].prev = list[i].prev;
	    list[(GLuint)list[i].prev].next = list[i].next;
	 }
      }
   }
#endif

   if ( t->memBlock ) {
      mmFreeMem( t->memBlock );
      t->memBlock = NULL;
   }

   if ( t->tObj ) {
      t->tObj->DriverData = NULL;
   }

   if ( t->bound && mmesa )
      mmesa->CurrentTexObj[t->bound-1] = NULL;

   remove_from_list( t );
   FREE( t );
}

/* Keep track of swapped out texture objects.
 */
void mach64SwapOutTexObj( mach64ContextPtr mmesa,
			  mach64TexObjPtr t )
{
#if ENABLE_PERF_BOXES
   /* Bump the performace counter */
   if (mmesa)
     mmesa->c_textureSwaps++;
#endif
d54 1
a54 100
#if 0
   if ( t->tObj && t->memBlock && mmesa ) {
      /* not a placeholder, so release from global LRU if necessary */
      int heap = t->heap;
      drmTextureRegion *list = mmesa->sarea->tex_list[heap];
      int log2sz = mmesa->mach64Screen->logTexGranularity[heap];
      int start = t->memBlock->ofs >> log2sz;
      int end = (t->memBlock->ofs + t->memBlock->size - 1) >> log2sz;
      int i;

      mmesa->lastTexAge[heap] = ++mmesa->sarea->tex_age[heap];

      /* Update the global LRU */
      for ( i = start ; i <= end ; i++ ) {
	 /* do we own this block? */
	 if (list[i].in_use == mmesa->hHWContext) {
	    list[i].in_use = 0;
	    list[i].age = mmesa->lastTexAge[heap];

	    /* remove_from_list(i) */
	    list[(GLuint)list[i].next].prev = list[i].prev;
	    list[(GLuint)list[i].prev].next = list[i].next;
	 }
      }
   }
#endif

   if ( t->memBlock ) {
      mmFreeMem( t->memBlock );
      t->memBlock = NULL;
   }

   t->dirty = ~0;
   move_to_tail( &mmesa->SwappedOut, t );
}

/* Print out debugging information about texture LRU.
 */
void mach64PrintLocalLRU( mach64ContextPtr mmesa, int heap )
{
   mach64TexObjPtr t;
   int sz = 1 << (mmesa->mach64Screen->logTexGranularity[heap]);

   fprintf( stderr, "\nLocal LRU, heap %d:\n", heap );

   foreach( t, &mmesa->TexObjList[heap] ) {
      if ( !t->tObj ) {
	 fprintf( stderr, "Placeholder %d at 0x%x sz 0x%x\n",
		  t->memBlock->ofs / sz,
		  t->memBlock->ofs,
		  t->memBlock->size );
      } else {
	 fprintf( stderr, "Texture (bound %d) at 0x%x sz 0x%x\n",
		  t->bound,
		  t->memBlock->ofs,
		  t->memBlock->size );
      }
   }

   fprintf( stderr, "\n" );
}

void mach64PrintGlobalLRU( mach64ContextPtr mmesa, int heap )
{
   drm_tex_region_t *list = mmesa->sarea->tex_list[heap];
   int i, j;

   fprintf( stderr, "\nGlobal LRU, heap %d list %p:\n", heap, list );

   for ( i = 0, j = MACH64_NR_TEX_REGIONS ; i < MACH64_NR_TEX_REGIONS ; i++ ) {
      fprintf( stderr, "list[%d] age %d in_use %d next %d prev %d\n",
	       j, list[j].age, list[j].in_use, list[j].next, list[j].prev );
      j = list[j].next;
      if ( j == MACH64_NR_TEX_REGIONS ) break;
   }

   if ( j != MACH64_NR_TEX_REGIONS ) {
      fprintf( stderr, "Loop detected in global LRU\n" );
      for ( i = 0 ; i < MACH64_NR_TEX_REGIONS ; i++ ) {
	 fprintf( stderr, "list[%d] age %d in_use %d next %d prev %d\n",
		  i, list[i].age, list[i].in_use, list[i].next, list[i].prev );
      }
   }

   fprintf( stderr, "\n" );
}

/* Reset the global texture LRU.
 */
/* NOTE: This function is only called while holding the hardware lock */
static void mach64ResetGlobalLRU( mach64ContextPtr mmesa, int heap )
{
   drm_tex_region_t *list = mmesa->sarea->tex_list[heap];
   int sz = 1 << mmesa->mach64Screen->logTexGranularity[heap];
   int i;

   /* (Re)initialize the global circular LRU list.  The last element in
    * the array (MACH64_NR_TEX_REGIONS) is the sentinal.  Keeping it at
    * the end of the array allows it to be addressed rationally when
    * looking up objects at a particular location in texture memory.
d56 3
a58 130
   for ( i = 0 ; (i+1) * sz <= mmesa->mach64Screen->texSize[heap] ; i++ ) {
      list[i].prev = i-1;
      list[i].next = i+1;
      list[i].age = 0;
      list[i].in_use = 0;
   }

   i--;
   list[0].prev = MACH64_NR_TEX_REGIONS;
   list[i].prev = i-1;
   list[i].next = MACH64_NR_TEX_REGIONS;
   list[MACH64_NR_TEX_REGIONS].prev = i;
   list[MACH64_NR_TEX_REGIONS].next = 0;
   mmesa->sarea->tex_age[heap] = 0;
}

/* Update the local and global texture LRUs.
 */
/* NOTE: This function is only called while holding the hardware lock */
void mach64UpdateTexLRU( mach64ContextPtr mmesa,
			 mach64TexObjPtr t )
{
   int heap = t->heap;
   drm_tex_region_t *list = mmesa->sarea->tex_list[heap];
   int log2sz = mmesa->mach64Screen->logTexGranularity[heap];
   int start = t->memBlock->ofs >> log2sz;
   int end = (t->memBlock->ofs + t->memBlock->size - 1) >> log2sz;
   int i;

   mmesa->lastTexAge[heap] = ++mmesa->sarea->tex_age[heap];

   if ( !t->memBlock ) {
      fprintf( stderr, "no memblock\n\n" );
      return;
   }

   /* Update our local LRU */
   move_to_head( &mmesa->TexObjList[heap], t );

   /* Update the global LRU */
   for ( i = start ; i <= end ; i++ ) {
      list[i].in_use = mmesa->hHWContext;
      list[i].age = mmesa->lastTexAge[heap];

#if 0
      /* if this is the last region, it's not in the list */
      if ( !(i*(1<<log2sz) > mmesa->mach64Screen->texSize[heap] ) ) {
#endif
	 /* remove_from_list(i) */
	 list[(GLuint)list[i].next].prev = list[i].prev;
	 list[(GLuint)list[i].prev].next = list[i].next;
#if 0
      }
#endif

      /* insert_at_head(list, i) */
      list[i].prev = MACH64_NR_TEX_REGIONS;
      list[i].next = list[MACH64_NR_TEX_REGIONS].next;
      list[(GLuint)list[MACH64_NR_TEX_REGIONS].next].prev = i;
      list[MACH64_NR_TEX_REGIONS].next = i;
   }

   if ( MACH64_DEBUG & DEBUG_VERBOSE_LRU ) {
      mach64PrintGlobalLRU( mmesa, t->heap );
      mach64PrintLocalLRU( mmesa, t->heap );
   }
}

/* Update our notion of what textures have been changed since we last
 * held the lock.  This pertains to both our local textures and the
 * textures belonging to other clients.  Keep track of other client's
 * textures by pushing a placeholder texture onto the LRU list -- these
 * are denoted by (tObj == NULL).
 */
/* NOTE: This function is only called while holding the hardware lock */
static void mach64TexturesGone( mach64ContextPtr mmesa, int heap,
				int offset, int size, int in_use )
{
   mach64TexObjPtr t, tmp;

   foreach_s ( t, tmp, &mmesa->TexObjList[heap] ) {
      if ( t->memBlock->ofs >= offset + size ||
	   t->memBlock->ofs + t->memBlock->size <= offset )
	 continue;

      /* It overlaps - kick it out.  Need to hold onto the currently
       * bound objects, however.
       */
      if ( t->bound ) {
	 mach64SwapOutTexObj( mmesa, t );
      } else {
	 mach64DestroyTexObj( mmesa, t );
      }
   }

   if ( in_use > 0 && in_use != mmesa->hHWContext ) {
      t = (mach64TexObjPtr) CALLOC( sizeof(*t) );
      if (!t) return;

      t->memBlock = mmAllocMem( mmesa->texHeap[heap], size, 0, offset );
      if ( !t->memBlock ) {
	 fprintf( stderr, "Couldn't alloc placeholder sz %x ofs %x\n",
		  (int)size, (int)offset );
	 mmDumpMemInfo( mmesa->texHeap[heap] );
	 return;
      }
      insert_at_head( &mmesa->TexObjList[heap], t );
   }
}

/* Update our client's shared texture state.  If another client has
 * modified a region in which we have textures, then we need to figure
 * out which of our textures has been removed, and update our global
 * LRU.
 */
void mach64AgeTextures( mach64ContextPtr mmesa, int heap )
{
   drm_mach64_sarea_t *sarea = mmesa->sarea;

   if ( sarea->tex_age[heap] != mmesa->lastTexAge[heap] ) {
      int sz = 1 << mmesa->mach64Screen->logTexGranularity[heap];
      int nr = 0;
      int idx;

      /* Have to go right round from the back to ensure stuff ends up
       * LRU in our local list...  Fix with a cursor pointer.
       */
      for ( idx = sarea->tex_list[heap][MACH64_NR_TEX_REGIONS].prev ;
	    idx != MACH64_NR_TEX_REGIONS && nr < MACH64_NR_TEX_REGIONS ;
	    idx = sarea->tex_list[heap][idx].prev, nr++ )
d60 4
a63 28
	 /* If switching texturing schemes, then the SAREA might not
	  * have been properly cleared, so we need to reset the
	  * global texture LRU.
	  */
	 if ( idx * sz > mmesa->mach64Screen->texSize[heap] ) {
	    nr = MACH64_NR_TEX_REGIONS;
	    break;
	 }

	 if ( sarea->tex_list[heap][idx].age > mmesa->lastTexAge[heap] ) {
	    mach64TexturesGone( mmesa, heap, idx * sz, sz,
				sarea->tex_list[heap][idx].in_use );
	 }
      }

      /* If switching texturing schemes, then the SAREA might not
       * have been properly cleared, so we need to reset the
       * global texture LRU.
       */
      if ( nr == MACH64_NR_TEX_REGIONS ) {
	 mach64TexturesGone( mmesa, heap, 0,
			     mmesa->mach64Screen->texSize[heap], 0 );
	 mach64ResetGlobalLRU( mmesa, heap );
      }

      if ( 0 ) {
	 mach64PrintGlobalLRU( mmesa, heap );
	 mach64PrintLocalLRU( mmesa, heap );
a64 5

      mmesa->dirty |= (MACH64_UPLOAD_CONTEXT |
		       MACH64_UPLOAD_TEX0IMAGE |
		       MACH64_UPLOAD_TEX1IMAGE);
      mmesa->lastTexAge[heap] = sarea->tex_age[heap];
d84 1
a84 1
   image = t->tObj->Image[0][level];
d113 1
a113 2
	       (GLuint)t->offset, (GLint)width, dwords );
      mmDumpMemInfo( mmesa->texHeap[t->heap] );
d119 1
a119 1
      CARD32 *dst = (CARD32 *)((char *)mach64Screen->agpTextures.map + t->memBlock->ofs);
d148 1
a148 1
   image = t->tObj->Image[0][level];
d231 1
a231 1
   offset = t->offset;
a242 1
      mmDumpMemInfo( mmesa->texHeap[t->heap] );
a255 3
       drmBufPtr buffer;
       CARD32 *dst;

a257 5
       /* Grab the dma buffer for the texture blit */
       buffer = mach64GetBufferLocked( mmesa );

       dst = (CARD32 *)((char *)buffer->address + MACH64_HOSTDATA_BLIT_OFFSET);

d263 3
a265 2
          const GLuint bytes = width * height * image->TexFormat->TexelBytes;
          memcpy(dst, src, bytes);
a267 3
       mach64FireBlitLocked( mmesa, buffer, offset, pitch, format,
			     x, y, width, height );

a280 2
   GLint heap;

d287 1
a287 1
   assert(t->tObj);
d289 2
a290 2
   /* Choose the heap appropriately */
   heap = MACH64_CARD_HEAP;
d292 10
a301 4
   if ( !mmesa->mach64Screen->IsPCI &&
	t->size > mmesa->mach64Screen->texSize[heap] ) {
      heap = MACH64_AGP_HEAP;
   }
a302 2
   /* Do we need to eject LRU texture objects? */
   if ( !t->memBlock ) {
a304 48
      /* Allocate a memory block on a 64-byte boundary */
      t->memBlock = mmAllocMem( mmesa->texHeap[heap], t->size, 6, 0 );

      /* Try AGP before kicking anything out of local mem */
      if ( !mmesa->mach64Screen->IsPCI && !t->memBlock && heap == MACH64_CARD_HEAP ) {
	 t->memBlock = mmAllocMem( mmesa->texHeap[MACH64_AGP_HEAP],
				   t->size, 6, 0 );

	 if ( t->memBlock )
	    heap = t->heap = MACH64_AGP_HEAP;
      }

      /* Kick out textures until the requested texture fits */
      while ( !t->memBlock ) {
	 if ( mmesa->TexObjList[heap].prev->bound ) {
	    fprintf( stderr,
		     "mach64UploadTexImages: ran into bound texture\n" );
	    return;
	 }
	 if ( mmesa->TexObjList[heap].prev == &mmesa->TexObjList[heap] ) {
	    if ( mmesa->mach64Screen->IsPCI ) {
	       fprintf( stderr, "%s: upload texture failure on "
			"local texture heaps, sz=%d\n", __FUNCTION__,
			t->size );
	       return;
	    } else if ( heap == MACH64_CARD_HEAP ) {
	       heap = t->heap = MACH64_AGP_HEAP;
	       continue;
	    } else {
	      int i;
	       fprintf( stderr, "%s: upload texture failure on "
			"%sAGP texture heaps, sz=%d\n", __FUNCTION__,
			mmesa->firstTexHeap == MACH64_CARD_HEAP ? "both local and " : "",
			t->size );
	       for ( i = mmesa->firstTexHeap ; i < mmesa->lastTexHeap ; i++ ) {
		  mach64PrintLocalLRU( mmesa, i );
	          mmDumpMemInfo( mmesa->texHeap[i] );
	       }
	       exit(-1);
	       return;
	    }
	 }

	 mach64SwapOutTexObj( mmesa, mmesa->TexObjList[heap].prev );

	 t->memBlock = mmAllocMem( mmesa->texHeap[heap], t->size, 6, 0 );
      }

d306 1
a306 1
      t->offset = mmesa->mach64Screen->texOffset[heap] + t->memBlock->ofs;
d314 1
a314 1
   mach64UpdateTexLRU( mmesa, t );
d317 2
a318 1
   if ( t->dirty ) {
d322 3
a324 3
	 mach64UploadAGPSubImage( mmesa, t, t->tObj->BaseLevel, 0, 0,
				  t->tObj->Image[0][t->tObj->BaseLevel]->Width,
				  t->tObj->Image[0][t->tObj->BaseLevel]->Height );
d326 3
a328 3
	 mach64UploadLocalSubImage( mmesa, t, t->tObj->BaseLevel, 0, 0,
				    t->tObj->Image[0][t->tObj->BaseLevel]->Width,
				    t->tObj->Image[0][t->tObj->BaseLevel]->Height );
d332 1
d336 35
d372 13
a384 1
   t->dirty = 0;
a389 1
 * FIXME: This needs to be optimized better.
a394 2
   GLint heap;

d401 1
a401 1
   assert(t0->tObj && t1->tObj);
d403 4
a406 2
   /* Choose the heap appropriately */
   heap = MACH64_CARD_HEAP;
d408 11
a418 23
   if ( !mmesa->mach64Screen->IsPCI &&
	((t0->size + t1->size) > mmesa->mach64Screen->texSize[heap]) ) {
      heap = MACH64_AGP_HEAP;
   }

   /* Do we need to eject LRU texture objects? */
   if ( !t0->memBlock || !t1->memBlock || t0->heap != t1->heap ) {
      /* FIXME: starting from scratch for now to keep it simple */
      if ( t0->memBlock ) {
	 mach64SwapOutTexObj( mmesa, t0 );
      }
      if ( t1->memBlock ) {
	 mach64SwapOutTexObj( mmesa, t1 );
      }
      t0->heap = t1->heap = heap;
      /* Allocate a memory block on a 64-byte boundary */
      t0->memBlock = mmAllocMem( mmesa->texHeap[heap], t0->size, 6, 0 );
      if ( t0->memBlock ) {
	 t1->memBlock = mmAllocMem( mmesa->texHeap[heap], t1->size, 6, 0 );
	 if ( !t1->memBlock ) {
	    mmFreeMem( t0->memBlock );
	    t0->memBlock = NULL;
	 }
d420 15
a434 9
      /* Try AGP before kicking anything out of local mem */
      if ( (!t0->memBlock || !t1->memBlock) && heap == MACH64_CARD_HEAP ) {
	 t0->memBlock = mmAllocMem( mmesa->texHeap[MACH64_AGP_HEAP], t0->size, 6, 0 );
	 if ( t0->memBlock ) {
	    t1->memBlock = mmAllocMem( mmesa->texHeap[MACH64_AGP_HEAP], t1->size, 6, 0 );
	    if ( !t1->memBlock ) {
	       mmFreeMem( t0->memBlock );
	       t0->memBlock = NULL;
	    }
d437 1
a437 2
	 if ( t0->memBlock && t1->memBlock )
	    heap = t0->heap = t1->heap = MACH64_AGP_HEAP;
d440 6
a445 39
      /* Kick out textures until the requested texture fits */
      while ( !t0->memBlock || !t1->memBlock ) {
	 if ( mmesa->TexObjList[heap].prev->bound ) {
	    fprintf( stderr,
		     "%s: ran into bound texture\n", __FUNCTION__ );
	    return;
	 }
	 if ( mmesa->TexObjList[heap].prev == &mmesa->TexObjList[heap] ) {
	    if ( mmesa->mach64Screen->IsPCI ) {
	       fprintf( stderr, "%s: upload texture failure on local "
			"texture heaps, tex0 sz=%d  tex1 sz=%d\n", __FUNCTION__, 
			t0->size, t1->size );
	       return;
	    } else if ( heap == MACH64_CARD_HEAP ) {
	       /* If only one allocation succeeded, start over again in AGP */
	       if (t0->memBlock) {
		  mmFreeMem( t0->memBlock );
	          t0->memBlock = NULL;
	       }
	       if (t1->memBlock) {
		  mmFreeMem( t1->memBlock );
	          t1->memBlock = NULL;
	       }
	       heap = t0->heap = t1->heap = MACH64_AGP_HEAP;
	       continue;
	    } else {
	      int i;
	       fprintf( stderr, "%s: upload texture failure on %s"
			"AGP texture heaps, tex0 sz=%d  tex1 sz=%d\n", __FUNCTION__,
			mmesa->firstTexHeap == MACH64_CARD_HEAP ? "both local and " : "",
			t0->size, t1->size );
	       for ( i = mmesa->firstTexHeap ; i < mmesa->lastTexHeap ; i++ ) {
		  mach64PrintLocalLRU( mmesa, i );
	          mmDumpMemInfo( mmesa->texHeap[i] );
	       }
	       exit(-1);
	       return;
	    }
	 }
d447 8
a454 6
	 mach64SwapOutTexObj( mmesa, mmesa->TexObjList[heap].prev );
	 
	 if (!t0->memBlock)
	    t0->memBlock = mmAllocMem( mmesa->texHeap[heap], t0->size, 6, 0 );
	 if (!t1->memBlock)
	    t1->memBlock = mmAllocMem( mmesa->texHeap[heap], t1->size, 6, 0 );
d458 2
a459 2
      t0->offset = mmesa->mach64Screen->texOffset[heap] + t0->memBlock->ofs;
      t1->offset = mmesa->mach64Screen->texOffset[heap] + t1->memBlock->ofs;
d467 2
a468 2
   mach64UpdateTexLRU( mmesa, t0 );
   mach64UpdateTexLRU( mmesa, t1 );
d471 2
a472 1
   if ( t0->dirty ) {
d476 3
a478 3
	 mach64UploadAGPSubImage( mmesa, t0, t0->tObj->BaseLevel, 0, 0,
				    t0->tObj->Image[0][t0->tObj->BaseLevel]->Width,
				    t0->tObj->Image[0][t0->tObj->BaseLevel]->Height );
d480 3
a482 3
	 mach64UploadLocalSubImage( mmesa, t0, t0->tObj->BaseLevel, 0, 0,
				    t0->tObj->Image[0][t0->tObj->BaseLevel]->Width,
				    t0->tObj->Image[0][t0->tObj->BaseLevel]->Height );
d485 1
d487 2
a488 1
   if ( t1->dirty ) {
d492 3
a494 3
	 mach64UploadAGPSubImage( mmesa, t1, t1->tObj->BaseLevel, 0, 0,
			       t1->tObj->Image[0][t1->tObj->BaseLevel]->Width,
			       t1->tObj->Image[0][t1->tObj->BaseLevel]->Height );
d496 3
a498 3
	 mach64UploadLocalSubImage( mmesa, t1, t1->tObj->BaseLevel, 0, 0,
			       t1->tObj->Image[0][t1->tObj->BaseLevel]->Width,
			       t1->tObj->Image[0][t1->tObj->BaseLevel]->Height );
d502 1
a505 3

   t0->dirty = 0;
   t1->dirty = 0;
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d572 3
d577 5
d587 3
d591 2
a592 3
          mach64FireBlitLocked( mmesa, (void *)src, offset, pitch, format,
				x, y, width, height );
       }
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d52 136
a187 1
   unsigned   i;
d189 24
a212 1
   /* See if it was the driver's current object.
d214 130
a343 3
   if ( mmesa != NULL )
   {
      for ( i = 0 ; i < mmesa->glCtx->Const.MaxTextureUnits ; i++ )
d345 23
a367 4
         if ( t == mmesa->CurrentTexObj[ i ] ) {
            assert( t->base.bound & (1 << i) );
            mmesa->CurrentTexObj[ i ] = NULL;
         }
d369 10
d398 1
a398 1
   image = t->base.tObj->Image[0][level];
d427 2
a428 1
	       (GLuint)t->bufAddr, (GLint)width, dwords );
d434 1
a434 1
      CARD32 *dst = (CARD32 *)((char *)mach64Screen->agpTextures.map + t->base.memBlock->ofs);
d463 1
a463 1
   image = t->base.tObj->Image[0][level];
d546 1
a546 1
   offset = t->bufAddr;
d558 1
d597 2
d605 1
a605 1
   assert(t->base.tObj);
d607 2
a608 2
   if ( !t->base.memBlock ) {
      int heap;
d610 4
a613 10
      /* NULL heaps are skipped */
      heap = driAllocateTexture( mmesa->texture_heaps, MACH64_NR_TEX_HEAPS,
				 (driTextureObject *) t );

      if ( heap == -1 ) {
	 fprintf( stderr, "%s: upload texture failure, sz=%d\n", __FUNCTION__,
		  t->base.totalSize );
	 exit(-1);
	 return;
      }
d615 2
d619 48
d668 1
a668 1
      t->bufAddr = mmesa->mach64Screen->texOffset[heap] + t->base.memBlock->ofs;
d676 1
a676 1
   driUpdateTextureLRU( (driTextureObject *) t );
d679 1
a679 2
   if ( t->base.dirty_images[0] ) {
      const GLint j = t->base.tObj->BaseLevel;
d683 3
a685 3
	 mach64UploadAGPSubImage( mmesa, t, j, 0, 0,
				  t->base.tObj->Image[0][j]->Width,
				  t->base.tObj->Image[0][j]->Height );
d687 3
a689 3
	 mach64UploadLocalSubImage( mmesa, t, j, 0, 0,
				    t->base.tObj->Image[0][j]->Width,
				    t->base.tObj->Image[0][j]->Height );
a692 1
      t->base.dirty_images[0] = 0;
a695 39
}


/* Allocate memory from the same texture heap `heap' for both textures
 * `u0' and `u1'.
 */
static int mach64AllocateMultiTex( mach64ContextPtr mmesa,
				   mach64TexObjPtr u0,
				   mach64TexObjPtr u1,
				   int heap, GLboolean alloc_u0 )
{
   /* Both objects should be bound */
   assert( u0->base.bound && u1->base.bound );

   if ( alloc_u0 ) {
      /* Evict u0 from its current heap */
      if ( u0->base.memBlock ) {
	 assert( u0->heap != heap );
	 driSwapOutTextureObject( (driTextureObject *) u0 );
      }

      /* Try to allocate u0 in the chosen heap */
      u0->heap = driAllocateTexture( &mmesa->texture_heaps[heap], 1,
				     (driTextureObject *) u0 );

      if ( u0->heap == -1 ) {
	 return -1;
      }
   }

   /* Evict u1 from its current heap */
   if ( u1->base.memBlock ) {
      assert( u1->heap != heap );
      driSwapOutTextureObject( (driTextureObject *) u1 );
   }

   /* Try to allocate u1 in the same heap as u0 */
   u1->heap = driAllocateTexture( &mmesa->texture_heaps[heap], 1,
				  (driTextureObject *) u1 );
d697 1
a697 9
   if ( u1->heap == -1 ) {
      return -1;
   }

   /* Bound objects are not evicted */
   assert( u0->base.memBlock && u1->base.memBlock );
   assert( u0->heap == u1->heap );

   return heap;
d703 1
d709 2
d717 1
a717 1
   assert(t0->base.tObj && t1->base.tObj);
d719 2
a720 4
   if ( !t0->base.memBlock || !t1->base.memBlock || t0->heap != t1->heap ) {
      mach64TexObjPtr u0 = NULL;
      mach64TexObjPtr u1 = NULL;
      unsigned totalSize = t0->base.totalSize + t1->base.totalSize;
d722 23
a744 11
      int heap, ret;

      /* Check if one of the textures is already swapped in a heap and the
       * other texture fits in that heap.
       */
      if ( t0->base.memBlock && totalSize <= t0->base.heap->size ) {
	 u0 = t0;
	 u1 = t1;
      } else if ( t1->base.memBlock && totalSize <= t1->base.heap->size ) {
	 u0 = t1;
	 u1 = t0;
d746 9
a754 15

      if ( u0 ) {
	 heap = u0->heap;

	 ret = mach64AllocateMultiTex( mmesa, u0, u1, heap, GL_FALSE );
      } else {
	 /* Both textures are swapped out or collocation is impossible */
	 u0 = t0;
	 u1 = t1;

	 /* Choose the heap appropriately */
	 heap = MACH64_CARD_HEAP;

	 if ( totalSize > mmesa->texture_heaps[heap]->size ) {
	    heap = MACH64_AGP_HEAP;
d757 2
a758 1
	 ret = mach64AllocateMultiTex( mmesa, u0, u1, heap, GL_TRUE );
d761 39
a799 3
      if ( ret == -1 && heap == MACH64_CARD_HEAP ) {
	 /* Try AGP if local memory failed */
	 heap = MACH64_AGP_HEAP;
d801 6
a806 11
	 ret = mach64AllocateMultiTex( mmesa, u0, u1, heap, GL_TRUE );
      }

      if ( ret == -1 ) {
	 /* FIXME:
	  * Swap out all textures from the AGP heap and re-run allocation, this
	  * should succeed in all cases.
	  */
	 fprintf( stderr, "%s: upload multi-texture failure, sz0=%d sz1=%d\n",
		  __FUNCTION__, t0->base.totalSize, t1->base.totalSize );
	 exit(-1);
d810 2
a811 2
      t0->bufAddr = mmesa->mach64Screen->texOffset[heap] + t0->base.memBlock->ofs;
      t1->bufAddr = mmesa->mach64Screen->texOffset[heap] + t1->base.memBlock->ofs;
d819 2
a820 2
   driUpdateTextureLRU( (driTextureObject *) t0 );
   driUpdateTextureLRU( (driTextureObject *) t1 );
d823 1
a823 2
   if ( t0->base.dirty_images[0] ) {
      const GLint j0 = t0->base.tObj->BaseLevel;
d827 3
a829 3
	 mach64UploadAGPSubImage( mmesa, t0, j0, 0, 0,
				    t0->base.tObj->Image[0][j0]->Width,
				    t0->base.tObj->Image[0][j0]->Height );
d831 3
a833 3
	 mach64UploadLocalSubImage( mmesa, t0, j0, 0, 0,
				    t0->base.tObj->Image[0][j0]->Width,
				    t0->base.tObj->Image[0][j0]->Height );
a835 1
      t0->base.dirty_images[0] = 0;
d837 1
a837 2
   if ( t1->base.dirty_images[0] ) {
      const GLint j1 = t1->base.tObj->BaseLevel;
d841 3
a843 3
	 mach64UploadAGPSubImage( mmesa, t1, j1, 0, 0,
			       t1->base.tObj->Image[0][j1]->Width,
			       t1->base.tObj->Image[0][j1]->Height );
d845 3
a847 3
	 mach64UploadLocalSubImage( mmesa, t1, j1, 0, 0,
			       t1->base.tObj->Image[0][j1]->Width,
			       t1->base.tObj->Image[0][j1]->Height );
a850 1
      t1->base.dirty_images[0] = 0;
d854 3
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d1 1
a1 1
/* -*- mode: c; c-basic-offset: 3 -*- */
a33 5
#include "main/context.h"
#include "main/macros.h"
#include "main/simple_list.h"
#include "main/imports.h"

d35 1
d37 2
d41 6
a78 1
   GLuint texelBytes;
d88 1
a88 3
   texelBytes = _mesa_get_format_bytes(image->TexFormat);

   switch ( texelBytes ) {
d121 2
a122 2
	 (y * image->Width + x) * texelBytes;
      const GLuint bytes = width * height * texelBytes;
a142 1
   GLuint texelBytes;
d152 1
a152 3
   texelBytes = _mesa_get_format_bytes(image->TexFormat);

   switch ( texelBytes ) {
d262 1
a262 1
             (y * image->Width + x) * texelBytes;
a305 1
      assert(t->base.memBlock);
a457 1
      assert(t0->base.memBlock);
a458 1
      assert(t1->base.memBlock);
@


