head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.09.05.14.05.01;	author jsg;	state dead;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.23;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.17;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.53.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.53.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.29.23;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.40;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@/*
 * Copyright (C) 2005 Vladimir Dergachev.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

/*
 * Authors:
 *   Vladimir Dergachev <volodya@@mindspring.com>
 *   Nicolai Haehnle <prefect_@@gmx.net>
 *   Aapo Tahkola <aet@@rasterburn.org>
 *   Ben Skeggs <darktama@@iinet.net.au>
 *   Jerome Glisse <j.glisse@@gmail.com>
 */

/* This files defines functions for accessing R300 hardware.
 */
#ifndef __R300_EMIT_H__
#define __R300_EMIT_H__

#include "main/glheader.h"
#include "r300_context.h"
#include "r300_cmdbuf.h"

static INLINE uint32_t cmdpacket0(struct radeon_screen *rscrn,
                                  int reg, int count)
{
    if (!rscrn->kernel_mm) {
	    drm_r300_cmd_header_t cmd;

	cmd.u = 0;
    	cmd.packet0.cmd_type = R300_CMD_PACKET0;
	    cmd.packet0.count = count;
    	cmd.packet0.reghi = ((unsigned int)reg & 0xFF00) >> 8;
	    cmd.packet0.reglo = ((unsigned int)reg & 0x00FF);

    	return cmd.u;
    }
    if (count) {
        return CP_PACKET0(reg, count - 1);
    }
    return CP_PACKET2;
}

static INLINE uint32_t cmdvpu(struct radeon_screen *rscrn, int addr, int count)
{
	drm_r300_cmd_header_t cmd;

	cmd.u = 0;
	cmd.vpu.cmd_type = R300_CMD_VPU;
	cmd.vpu.count = count;
	cmd.vpu.adrhi = ((unsigned int)addr & 0xFF00) >> 8;
	cmd.vpu.adrlo = ((unsigned int)addr & 0x00FF);

	return cmd.u;
}

static INLINE uint32_t cmdr500fp(struct radeon_screen *rscrn,
                                 int addr, int count, int type, int clamp)
{
	drm_r300_cmd_header_t cmd;

	cmd.u = 0;
	cmd.r500fp.cmd_type = R300_CMD_R500FP;
	cmd.r500fp.count = count;
	cmd.r500fp.adrhi_flags = ((unsigned int)addr & 0x100) >> 8;
	cmd.r500fp.adrhi_flags |= type ? R500FP_CONSTANT_TYPE : 0;
	cmd.r500fp.adrhi_flags |= clamp ? R500FP_CONSTANT_CLAMP : 0;
	cmd.r500fp.adrlo = ((unsigned int)addr & 0x00FF);

	return cmd.u;
}

static INLINE uint32_t cmdpacket3(struct radeon_screen *rscrn, int packet)
{
	drm_r300_cmd_header_t cmd;

	cmd.u = 0;
	cmd.packet3.cmd_type = R300_CMD_PACKET3;
	cmd.packet3.packet = packet;

	return cmd.u;
}

static INLINE uint32_t cmdcpdelay(struct radeon_screen *rscrn,
                                  unsigned short count)
{
	drm_r300_cmd_header_t cmd;

	cmd.u = 0;

	cmd.delay.cmd_type = R300_CMD_CP_DELAY;
	cmd.delay.count = count;

	return cmd.u;
}

static INLINE uint32_t cmdwait(struct radeon_screen *rscrn,
                               unsigned char flags)
{
	drm_r300_cmd_header_t cmd;

	cmd.u = 0;
	cmd.wait.cmd_type = R300_CMD_WAIT;
	cmd.wait.flags = flags;

	return cmd.u;
}

static INLINE uint32_t cmdpacify(struct radeon_screen *rscrn)
{
	drm_r300_cmd_header_t cmd;

	cmd.u = 0;
	cmd.header.cmd_type = R300_CMD_END3D;

	return cmd.u;
}

/**
 * Write the header of a packet3 to the command buffer.
 * Outputs 2 dwords and expects (num_extra+1) additional dwords afterwards.
 */
#define OUT_BATCH_PACKET3(packet, num_extra) do {\
    if (!b_l_rmesa->radeonScreen->kernel_mm) {		\
    	OUT_BATCH(cmdpacket3(b_l_rmesa->radeonScreen,\
                  R300_CMD_PACKET3_RAW)); \
    } else b_l_rmesa->cmdbuf.cs->section_cdw++;\
	OUT_BATCH(CP_PACKET3((packet), (num_extra))); \
	} while(0)

/**
 * Must be sent to switch to 2d commands
 */
void static INLINE end_3d(radeonContextPtr radeon)
{
	BATCH_LOCALS(radeon);

	if (!radeon->radeonScreen->kernel_mm) {
		BEGIN_BATCH_NO_AUTOSTATE(1);
		OUT_BATCH(cmdpacify(radeon->radeonScreen));
		END_BATCH();
	}
}

void static INLINE cp_delay(r300ContextPtr rmesa, unsigned short count)
{
	BATCH_LOCALS(&rmesa->radeon);

	if (!rmesa->radeon.radeonScreen->kernel_mm) {
		BEGIN_BATCH_NO_AUTOSTATE(1);
		OUT_BATCH(cmdcpdelay(rmesa->radeon.radeonScreen, count));
		END_BATCH();
	}
}

void static INLINE cp_wait(radeonContextPtr radeon, unsigned char flags)
{
	BATCH_LOCALS(radeon);
	uint32_t wait_until;

	if (!radeon->radeonScreen->kernel_mm) {
		BEGIN_BATCH_NO_AUTOSTATE(1);
		OUT_BATCH(cmdwait(radeon->radeonScreen, flags));
		END_BATCH();
	} else {
		switch(flags) {
		case R300_WAIT_2D:
			wait_until = (1 << 14);
			break;
		case R300_WAIT_3D:
			wait_until = (1 << 15);
			break;
		case R300_NEW_WAIT_2D_3D:
			wait_until = (1 << 14) | (1 << 15);
			break;
		case R300_NEW_WAIT_2D_2D_CLEAN:
			wait_until = (1 << 14) | (1 << 16) | (1 << 18);
			break;
		case R300_NEW_WAIT_3D_3D_CLEAN:
			wait_until = (1 << 15) | (1 << 17) | (1 << 18);
			break;
		case R300_NEW_WAIT_2D_2D_CLEAN_3D_3D_CLEAN:
			wait_until  = (1 << 14) | (1 << 16) | (1 << 18);
			wait_until |= (1 << 15) | (1 << 17) | (1 << 18);
			break;
		default:
			return;
		}
		BEGIN_BATCH_NO_AUTOSTATE(2);
		OUT_BATCH(CP_PACKET0(RADEON_WAIT_UNTIL, 0));
		OUT_BATCH(wait_until);
		END_BATCH();
	}
}

extern int r300PrimitiveType(r300ContextPtr rmesa, int prim);
extern int r300NumVerts(r300ContextPtr rmesa, int num_verts, int prim);

extern void r300EmitCacheFlush(r300ContextPtr rmesa);

extern GLuint r300VAPInputCntl0(struct gl_context * ctx, GLuint InputsRead);
extern GLuint r300VAPInputCntl1(struct gl_context * ctx, GLuint InputsRead);
extern GLuint r300VAPOutputCntl0(struct gl_context * ctx, GLuint vp_writes);
extern GLuint r300VAPOutputCntl1(struct gl_context * ctx, GLuint vp_writes);

#endif
@


1.5
log
@Merge Mesa 7.10.3
@
text
@@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d223 4
a226 4
extern GLuint r300VAPInputCntl0(GLcontext * ctx, GLuint InputsRead);
extern GLuint r300VAPInputCntl1(GLcontext * ctx, GLuint InputsRead);
extern GLuint r300VAPOutputCntl0(GLcontext * ctx, GLuint vp_writes);
extern GLuint r300VAPOutputCntl1(GLcontext * ctx, GLuint vp_writes);
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a44 1
#include "radeon_reg.h"
d46 2
a47 7
/* TODO: move these defines (and the ones from DRM) into r300_reg.h and sync up
 * with DRM */
#define CP_PACKET0(reg, n)	(RADEON_CP_PACKET0 | ((n)<<16) | ((reg)>>2))
#define CP_PACKET3( pkt, n )						\
	(RADEON_CP_PACKET3 | (pkt) | ((n) << 16))

static INLINE uint32_t cmdpacket0(int reg, int count)
d49 2
a50 1
	drm_r300_cmd_header_t cmd;
d52 5
a56 4
	cmd.packet0.cmd_type = R300_CMD_PACKET0;
	cmd.packet0.count = count;
	cmd.packet0.reghi = ((unsigned int)reg & 0xFF00) >> 8;
	cmd.packet0.reglo = ((unsigned int)reg & 0x00FF);
d58 6
a63 1
	return cmd.u;
d66 1
a66 1
static INLINE uint32_t cmdvpu(int addr, int count)
d70 1
d79 2
a80 1
static INLINE uint32_t cmdr500fp(int addr, int count, int type, int clamp)
d84 1
d95 1
a95 1
static INLINE uint32_t cmdpacket3(int packet)
d99 1
d106 2
a107 1
static INLINE uint32_t cmdcpdelay(unsigned short count)
d111 2
d119 2
a120 1
static INLINE uint32_t cmdwait(unsigned char flags)
d124 1
d131 1
a131 1
static INLINE uint32_t cmdpacify(void)
d135 1
d142 2
a143 3
 * Prepare to write a register value to register at address reg.
 * If num_extra > 0 then the following extra values are written
 * to registers with address +4, +8 and so on..
d145 6
a150 31
#define reg_start(reg, num_extra)					\
	do {								\
		int _n;							\
		_n=(num_extra);						\
		cmd = (drm_radeon_cmd_header_t*)			\
			r300AllocCmdBuf(rmesa,				\
					(_n+2),				\
					__FUNCTION__);			\
		cmd_reserved=_n+2;					\
		cmd_written=1;						\
		cmd[0].i=cmdpacket0((reg), _n+1);			\
	} while (0);

/**
 * Emit GLuint freestyle
 */
#define e32(dword)							\
	do {								\
		if(cmd_written<cmd_reserved) {				\
			cmd[cmd_written].i=(dword);			\
			cmd_written++;					\
		} else {						\
			fprintf(stderr,					\
				"e32 but no previous packet "		\
				"declaration.\n"			\
				"Aborting! in %s::%s at line %d, "	\
				"cmd_written=%d cmd_reserved=%d\n",	\
				__FILE__, __FUNCTION__, __LINE__,	\
				cmd_written, cmd_reserved);		\
			_mesa_exit(-1);					\
		}							\
a152 50
#define	efloat(f) e32(r300PackFloat32(f))

#define vsf_start_fragment(dest, length)				\
	do {								\
		int _n;							\
		_n = (length);						\
		cmd = (drm_radeon_cmd_header_t*)			\
			r300AllocCmdBuf(rmesa,				\
					(_n+1),				\
					__FUNCTION__);			\
		cmd_reserved = _n+2;					\
		cmd_written =1;						\
		cmd[0].i = cmdvpu((dest), _n/4);			\
	} while (0);

#define r500fp_start_fragment(dest, length)				\
	do {								\
		int _n;							\
		_n = (length);						\
		cmd = (drm_radeon_cmd_header_t*)			\
			r300AllocCmdBuf(rmesa,				\
					(_n+1),				\
					__FUNCTION__);			\
		cmd_reserved = _n+1;					\
		cmd_written =1;						\
		cmd[0].i = cmdr500fp((dest), _n/6, 0, 0);		\
	} while (0);

#define start_packet3(packet, count)					\
	{								\
		int _n;							\
		GLuint _p;						\
		_n = (count);						\
		_p = (packet);						\
		cmd = (drm_radeon_cmd_header_t*)			\
			r300AllocCmdBuf(rmesa,				\
					(_n+3),				\
					__FUNCTION__);			\
		cmd_reserved = _n+3;					\
		cmd_written = 2;					\
		if(_n > 0x3fff) {					\
			fprintf(stderr,"Too big packet3 %08x: cannot "	\
				"store %d dwords\n",			\
				_p, _n);				\
			_mesa_exit(-1);					\
		}							\
		cmd[0].i = cmdpacket3(R300_CMD_PACKET3_RAW);		\
		cmd[1].i = _p | ((_n & 0x3fff)<<16);			\
	}

d156 1
a156 1
void static INLINE end_3d(r300ContextPtr rmesa)
d158 1
a158 1
	drm_radeon_cmd_header_t *cmd = NULL;
d160 5
a164 3
	cmd =
	    (drm_radeon_cmd_header_t *) r300AllocCmdBuf(rmesa, 1, __FUNCTION__);
	cmd[0].header.cmd_type = R300_CMD_END3D;
d169 1
a169 1
	drm_radeon_cmd_header_t *cmd = NULL;
d171 5
a175 3
	cmd =
	    (drm_radeon_cmd_header_t *) r300AllocCmdBuf(rmesa, 1, __FUNCTION__);
	cmd[0].i = cmdcpdelay(count);
d178 1
a178 1
void static INLINE cp_wait(r300ContextPtr rmesa, unsigned char flags)
d180 2
a181 1
	drm_radeon_cmd_header_t *cmd = NULL;
d183 33
a215 3
	cmd =
	    (drm_radeon_cmd_header_t *) r300AllocCmdBuf(rmesa, 1, __FUNCTION__);
	cmd[0].i = cmdwait(flags);
a217 7
extern int r300EmitArrays(GLcontext * ctx);

#ifdef USER_BUFFERS
void r300UseArrays(GLcontext * ctx);
#endif

extern void r300ReleaseArrays(GLcontext * ctx);
a222 3
extern GLuint r300VAPInputRoute0(uint32_t * dst, GLvector4f ** attribptr,
				 int *inputs, GLint * tab, GLuint nr);
extern GLuint r300VAPInputRoute1(uint32_t * dst, int swizzle[][4], GLuint nr);
d225 2
a226 2
extern GLuint r300VAPOutputCntl0(GLcontext * ctx, GLuint OutputsWritten);
extern GLuint r300VAPOutputCntl1(GLcontext * ctx, GLuint OutputsWritten);
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d42 1
a42 1
#include "glheader.h"
@


1.1
log
@Initial revision
@
text
@d47 2
a48 13
/*
 * CP type-3 packets
 */
#define RADEON_CP_PACKET3_UNK1B                     0xC0001B00
#define RADEON_CP_PACKET3_INDX_BUFFER               0xC0003300
#define RADEON_CP_PACKET3_3D_DRAW_VBUF_2            0xC0003400
#define RADEON_CP_PACKET3_3D_DRAW_IMMD_2            0xC0003500
#define RADEON_CP_PACKET3_3D_DRAW_INDX_2            0xC0003600
#define RADEON_CP_PACKET3_3D_LOAD_VBPNTR            0xC0002F00
#define RADEON_CP_PACKET3_3D_CLEAR_ZMASK            0xC0003202
#define RADEON_CP_PACKET3_3D_CLEAR_CMASK            0xC0003802
#define RADEON_CP_PACKET3_3D_CLEAR_HIZ              0xC0003702

d50 2
d53 1
a53 5
void static inline check_space(int dwords)
{
}

static __inline__ uint32_t cmdpacket0(int reg, int count)
d65 1
a65 1
static __inline__ uint32_t cmdvpu(int addr, int count)
d77 15
a91 1
static __inline__ uint32_t cmdpacket3(int packet)
d101 1
a101 1
static __inline__ uint32_t cmdcpdelay(unsigned short count)
d111 1
a111 1
static __inline__ uint32_t cmdwait(unsigned char flags)
d121 1
a121 1
static __inline__ uint32_t cmdpacify(void)
d142 1
a142 1
					__func__);			\
d164 1
a164 1
			exit(-1);					\
d166 1
a166 1
	} while(0);
d177 1
a177 1
					__func__);			\
d183 13
d205 1
a205 1
					__func__);			\
d212 1
a212 1
			exit(-1);					\
d221 1
a221 1
void static inline end_3d(r300ContextPtr rmesa)
d225 3
a227 4
	cmd = (drm_radeon_cmd_header_t*)r300AllocCmdBuf(rmesa,
							1,
							__FUNCTION__);
	cmd[0].header.cmd_type=R300_CMD_END3D;
d230 1
a230 1
void static inline cp_delay(r300ContextPtr rmesa, unsigned short count)
d234 3
a236 4
	cmd = (drm_radeon_cmd_header_t*)r300AllocCmdBuf(rmesa,
							1,
							__FUNCTION__);
	cmd[0].i=cmdcpdelay(count);
d239 1
a239 1
void static inline cp_wait(r300ContextPtr rmesa, unsigned char flags)
d243 2
a244 3
	cmd = (drm_radeon_cmd_header_t*)r300AllocCmdBuf(rmesa,
							1,
							__FUNCTION__);
d248 1
a248 9
/**
 * fire vertex buffer
 */
static void inline fire_AOS(r300ContextPtr rmesa, int vertex_count, int type)
{
	int cmd_reserved = 0;
	int cmd_written = 0;
	drm_radeon_cmd_header_t *cmd = NULL;
	check_space(9);
d250 2
a251 3
	start_packet3(RADEON_CP_PACKET3_3D_DRAW_VBUF_2, 0);
#ifdef NOTNEEDED_ANYMORE
	e32(0x840c0024);
a252 3
	e32(R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_LIST |
	    (vertex_count<<16) | type);
}
d254 13
a266 36
/**
 * These are followed by the corresponding data
 */
#define start_index32_packet(vertex_count, type)			\
	do {								\
		int _vc;						\
		_vc = (vertex_count);					\
		start_packet3(RADEON_CP_PACKET3_3D_DRAW_INDX_2, _vc);	\
		e32(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (_vc<<16) |	\
		    type | R300_VAP_VF_CNTL__INDEX_SIZE_32bit);		\
	} while (0);

#define start_index16_packet(vertex_count, type)			\
	do {								\
		int _vc, _n;						\
		_vc = (vertex_count);					\
		_n = (vertex_count+1)>>1;				\
		start_packet3(RADEON_CP_PACKET3_3D_DRAW_INDX_2, _n);	\
		e32(R300_VAP_VF_CNTL__PRIM_WALK_INDICES | (_vc<<16) |	\
		    type);						\
	} while (0);

/**
 * Interestingly enough this ones needs the call to setup_AOS, even thought
 * some of the data so setup is not needed and some is not as arbitrary
 * as when used by DRAW_VBUF_2 or DRAW_INDX_2
 */
#define start_immediate_packet(vertex_count, type, vertex_size)		\
	do {								\
		int _vc;						\
		_vc = (vertex_count);					\
		start_packet3(RADEON_CP_PACKET3_3D_DRAW_IMMD_2,		\
			      _vc*(vertex_size));			\
		e32(R300_VAP_VF_CNTL__PRIM_WALK_VERTEX_EMBEDDED |	\
		    (_vc<<16) | type);					\
	} while (0);
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d62 4
d141 1
a141 1
					__FUNCTION__);			\
d163 1
a163 1
			_mesa_exit(-1);					\
d165 1
a165 1
	} while(0)
d176 1
a176 1
					__FUNCTION__);			\
d191 1
a191 1
					__FUNCTION__);			\
d198 1
a198 1
			_mesa_exit(-1);					\
d211 4
a214 3
	cmd =
	    (drm_radeon_cmd_header_t *) r300AllocCmdBuf(rmesa, 1, __FUNCTION__);
	cmd[0].header.cmd_type = R300_CMD_END3D;
d221 4
a224 3
	cmd =
	    (drm_radeon_cmd_header_t *) r300AllocCmdBuf(rmesa, 1, __FUNCTION__);
	cmd[0].i = cmdcpdelay(count);
d231 3
a233 2
	cmd =
	    (drm_radeon_cmd_header_t *) r300AllocCmdBuf(rmesa, 1, __FUNCTION__);
d237 9
a245 1
extern int r300EmitArrays(GLcontext * ctx);
d247 3
a249 2
#ifdef USER_BUFFERS
void r300UseArrays(GLcontext * ctx);
d251 25
d277 14
a290 1
extern void r300ReleaseArrays(GLcontext * ctx);
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d42 1
a42 1
#include "main/glheader.h"
d45 1
d47 16
a62 2
static INLINE uint32_t cmdpacket0(struct radeon_screen *rscrn,
                                  int reg, int count)
d64 1
a64 2
    if (!rscrn->kernel_mm) {
	    drm_r300_cmd_header_t cmd;
d66 4
a69 5
	cmd.u = 0;
    	cmd.packet0.cmd_type = R300_CMD_PACKET0;
	    cmd.packet0.count = count;
    	cmd.packet0.reghi = ((unsigned int)reg & 0xFF00) >> 8;
	    cmd.packet0.reglo = ((unsigned int)reg & 0x00FF);
d71 1
a71 6
    	return cmd.u;
    }
    if (count) {
        return CP_PACKET0(reg, count - 1);
    }
    return CP_PACKET2;
d74 1
a74 1
static INLINE uint32_t cmdvpu(struct radeon_screen *rscrn, int addr, int count)
a77 1
	cmd.u = 0;
d86 1
a86 17
static INLINE uint32_t cmdr500fp(struct radeon_screen *rscrn,
                                 int addr, int count, int type, int clamp)
{
	drm_r300_cmd_header_t cmd;

	cmd.u = 0;
	cmd.r500fp.cmd_type = R300_CMD_R500FP;
	cmd.r500fp.count = count;
	cmd.r500fp.adrhi_flags = ((unsigned int)addr & 0x100) >> 8;
	cmd.r500fp.adrhi_flags |= type ? R500FP_CONSTANT_TYPE : 0;
	cmd.r500fp.adrhi_flags |= clamp ? R500FP_CONSTANT_CLAMP : 0;
	cmd.r500fp.adrlo = ((unsigned int)addr & 0x00FF);

	return cmd.u;
}

static INLINE uint32_t cmdpacket3(struct radeon_screen *rscrn, int packet)
a89 1
	cmd.u = 0;
d96 1
a96 2
static INLINE uint32_t cmdcpdelay(struct radeon_screen *rscrn,
                                  unsigned short count)
a99 2
	cmd.u = 0;

d106 1
a106 2
static INLINE uint32_t cmdwait(struct radeon_screen *rscrn,
                               unsigned char flags)
a109 1
	cmd.u = 0;
d116 1
a116 1
static INLINE uint32_t cmdpacify(struct radeon_screen *rscrn)
a119 1
	cmd.u = 0;
d126 19
a144 2
 * Write the header of a packet3 to the command buffer.
 * Outputs 2 dwords and expects (num_extra+1) additional dwords afterwards.
d146 15
a160 6
#define OUT_BATCH_PACKET3(packet, num_extra) do {\
    if (!b_l_rmesa->radeonScreen->kernel_mm) {		\
    	OUT_BATCH(cmdpacket3(b_l_rmesa->radeonScreen,\
                  R300_CMD_PACKET3_RAW)); \
    } else b_l_rmesa->cmdbuf.cs->section_cdw++;\
	OUT_BATCH(CP_PACKET3((packet), (num_extra))); \
d163 37
d203 1
a203 1
void static INLINE end_3d(radeonContextPtr radeon)
d205 1
a205 1
	BATCH_LOCALS(radeon);
d207 3
a209 5
	if (!radeon->radeonScreen->kernel_mm) {
		BEGIN_BATCH_NO_AUTOSTATE(1);
		OUT_BATCH(cmdpacify(radeon->radeonScreen));
		END_BATCH();
	}
d212 1
a212 1
void static INLINE cp_delay(r300ContextPtr rmesa, unsigned short count)
d214 1
a214 1
	BATCH_LOCALS(&rmesa->radeon);
d216 3
a218 5
	if (!rmesa->radeon.radeonScreen->kernel_mm) {
		BEGIN_BATCH_NO_AUTOSTATE(1);
		OUT_BATCH(cmdcpdelay(rmesa->radeon.radeonScreen, count));
		END_BATCH();
	}
d221 1
a221 1
void static INLINE cp_wait(radeonContextPtr radeon, unsigned char flags)
d223 1
a223 2
	BATCH_LOCALS(radeon);
	uint32_t wait_until;
d225 3
a227 33
	if (!radeon->radeonScreen->kernel_mm) {
		BEGIN_BATCH_NO_AUTOSTATE(1);
		OUT_BATCH(cmdwait(radeon->radeonScreen, flags));
		END_BATCH();
	} else {
		switch(flags) {
		case R300_WAIT_2D:
			wait_until = (1 << 14);
			break;
		case R300_WAIT_3D:
			wait_until = (1 << 15);
			break;
		case R300_NEW_WAIT_2D_3D:
			wait_until = (1 << 14) | (1 << 15);
			break;
		case R300_NEW_WAIT_2D_2D_CLEAN:
			wait_until = (1 << 14) | (1 << 16) | (1 << 18);
			break;
		case R300_NEW_WAIT_3D_3D_CLEAN:
			wait_until = (1 << 15) | (1 << 17) | (1 << 18);
			break;
		case R300_NEW_WAIT_2D_2D_CLEAN_3D_3D_CLEAN:
			wait_until  = (1 << 14) | (1 << 16) | (1 << 18);
			wait_until |= (1 << 15) | (1 << 17) | (1 << 18);
			break;
		default:
			return;
		}
		BEGIN_BATCH_NO_AUTOSTATE(2);
		OUT_BATCH(CP_PACKET0(RADEON_WAIT_UNTIL, 0));
		OUT_BATCH(wait_until);
		END_BATCH();
	}
d230 1
a230 2
extern int r300PrimitiveType(r300ContextPtr rmesa, int prim);
extern int r300NumVerts(r300ContextPtr rmesa, int num_verts, int prim);
d232 3
a234 1
extern void r300EmitCacheFlush(r300ContextPtr rmesa);
d236 1
a236 4
extern GLuint r300VAPInputCntl0(struct gl_context * ctx, GLuint InputsRead);
extern GLuint r300VAPInputCntl1(struct gl_context * ctx, GLuint InputsRead);
extern GLuint r300VAPOutputCntl0(struct gl_context * ctx, GLuint vp_writes);
extern GLuint r300VAPOutputCntl1(struct gl_context * ctx, GLuint vp_writes);
@


