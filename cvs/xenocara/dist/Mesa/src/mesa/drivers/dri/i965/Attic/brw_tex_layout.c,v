head	1.14;
access;
symbols
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	v10_2_9:1.1.1.10
	v10_4_3:1.1.1.9
	v10_2_7:1.1.1.8
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	v10_2_3:1.1.1.8
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	v9_2_5:1.1.1.7
	v9_2_3:1.1.1.6
	v9_2_2:1.1.1.6
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.13;
commitid	TnlogFl9nOv2eaRf;

1.13
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.12;
commitid	4ry2gvZGMXkCUD2n;

1.12
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.11;
commitid	mcxB0JvoI9gTDYXU;

1.11
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.10;
commitid	WPD6rgPryPkvXOr9;

1.10
date	2014.01.19.03.13.15;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2013.11.09.02.46.54;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2013.09.05.14.04.21;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.15;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.46;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.46;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.16;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.28.37;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.15.39;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.11.09.02.34.47;	author jsg;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.01.19.03.04.27;	author jsg;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.07.09.20.34.51;	author jsg;	state Exp;
branches;
next	1.1.1.9;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.9
date	2015.01.25.14.11.45;	author jsg;	state Exp;
branches;
next	1.1.1.10;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.10
date	2015.02.20.22.48.51;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.14
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2006 VMware, Inc.
 * Copyright © 2006 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * \file brw_tex_layout.cpp
 *
 * Code to lay out images in a mipmap tree.
 *
 * \author Keith Whitwell <keithw@@vmware.com>
 * \author Michel Dänzer <daenzer@@vmware.com>
 */

#include "intel_mipmap_tree.h"
#include "brw_context.h"
#include "main/macros.h"

#define FILE_DEBUG_FLAG DEBUG_MIPTREE

static unsigned int
intel_horizontal_texture_alignment_unit(struct brw_context *brw,
                                       mesa_format format)
{
   /**
    * From the "Alignment Unit Size" section of various specs, namely:
    * - Gen3 Spec: "Memory Data Formats" Volume,         Section 1.20.1.4
    * - i965 and G45 PRMs:             Volume 1,         Section 6.17.3.4.
    * - Ironlake and Sandybridge PRMs: Volume 1, Part 1, Section 7.18.3.4
    * - BSpec (for Ivybridge and slight variations in separate stencil)
    *
    * +----------------------------------------------------------------------+
    * |                                        | alignment unit width  ("i") |
    * | Surface Property                       |-----------------------------|
    * |                                        | 915 | 965 | ILK | SNB | IVB |
    * +----------------------------------------------------------------------+
    * | YUV 4:2:2 format                       |  8  |  4  |  4  |  4  |  4  |
    * | BC1-5 compressed format (DXTn/S3TC)    |  4  |  4  |  4  |  4  |  4  |
    * | FXT1  compressed format                |  8  |  8  |  8  |  8  |  8  |
    * | Depth Buffer (16-bit)                  |  4  |  4  |  4  |  4  |  8  |
    * | Depth Buffer (other)                   |  4  |  4  |  4  |  4  |  4  |
    * | Separate Stencil Buffer                | N/A | N/A |  8  |  8  |  8  |
    * | All Others                             |  4  |  4  |  4  |  4  |  4  |
    * +----------------------------------------------------------------------+
    *
    * On IVB+, non-special cases can be overridden by setting the SURFACE_STATE
    * "Surface Horizontal Alignment" field to HALIGN_4 or HALIGN_8.
    */
    if (_mesa_is_format_compressed(format)) {
       /* The hardware alignment requirements for compressed textures
        * happen to match the block boundaries.
        */
      unsigned int i, j;
      _mesa_get_format_block_size(format, &i, &j);
      return i;
    }

   if (format == MESA_FORMAT_S_UINT8)
      return 8;

   if (brw->gen >= 7 && format == MESA_FORMAT_Z_UNORM16)
      return 8;

   return 4;
}

static unsigned int
intel_vertical_texture_alignment_unit(struct brw_context *brw,
                                      mesa_format format, bool multisampled)
{
   /**
    * From the "Alignment Unit Size" section of various specs, namely:
    * - Gen3 Spec: "Memory Data Formats" Volume,         Section 1.20.1.4
    * - i965 and G45 PRMs:             Volume 1,         Section 6.17.3.4.
    * - Ironlake and Sandybridge PRMs: Volume 1, Part 1, Section 7.18.3.4
    * - BSpec (for Ivybridge and slight variations in separate stencil)
    *
    * +----------------------------------------------------------------------+
    * |                                        | alignment unit height ("j") |
    * | Surface Property                       |-----------------------------|
    * |                                        | 915 | 965 | ILK | SNB | IVB |
    * +----------------------------------------------------------------------+
    * | BC1-5 compressed format (DXTn/S3TC)    |  4  |  4  |  4  |  4  |  4  |
    * | FXT1  compressed format                |  4  |  4  |  4  |  4  |  4  |
    * | Depth Buffer                           |  2  |  2  |  2  |  4  |  4  |
    * | Separate Stencil Buffer                | N/A | N/A | N/A |  4  |  8  |
    * | Multisampled (4x or 8x) render target  | N/A | N/A | N/A |  4  |  4  |
    * | All Others                             |  2  |  2  |  2  |  *  |  *  |
    * +----------------------------------------------------------------------+
    *
    * Where "*" means either VALIGN_2 or VALIGN_4 depending on the setting of
    * the SURFACE_STATE "Surface Vertical Alignment" field.
    */
   if (_mesa_is_format_compressed(format))
      return 4;

   if (format == MESA_FORMAT_S_UINT8)
      return brw->gen >= 7 ? 8 : 4;

   /* Broadwell only supports VALIGN of 4, 8, and 16.  The BSpec says 4
    * should always be used, except for stencil buffers, which should be 8.
    */
   if (brw->gen >= 8)
      return 4;

   if (multisampled)
      return 4;

   GLenum base_format = _mesa_get_format_base_format(format);

   if (brw->gen >= 6 &&
       (base_format == GL_DEPTH_COMPONENT ||
	base_format == GL_DEPTH_STENCIL)) {
      return 4;
   }

   if (brw->gen == 7) {
      /* On Gen7, we prefer a vertical alignment of 4 when possible, because
       * that allows Y tiled render targets.
       *
       * From the Ivy Bridge PRM, Vol4 Part1 2.12.2.1 (SURFACE_STATE for most
       * messages), on p64, under the heading "Surface Vertical Alignment":
       *
       *     Value of 1 [VALIGN_4] is not supported for format YCRCB_NORMAL
       *     (0x182), YCRCB_SWAPUVY (0x183), YCRCB_SWAPUV (0x18f), YCRCB_SWAPY
       *     (0x190)
       *
       *     VALIGN_4 is not supported for surface format R32G32B32_FLOAT.
       */
      if (base_format == GL_YCBCR_MESA || format == MESA_FORMAT_RGB_FLOAT32)
         return 2;

      return 4;
   }

   return 2;
}

static void
brw_miptree_layout_2d(struct intel_mipmap_tree *mt)
{
   unsigned x = 0;
   unsigned y = 0;
   unsigned width = mt->physical_width0;
   unsigned height = mt->physical_height0;
   unsigned depth = mt->physical_depth0; /* number of array layers. */

   mt->total_width = mt->physical_width0;

   if (mt->compressed) {
       mt->total_width = ALIGN(mt->physical_width0, mt->align_w);
   }

   /* May need to adjust width to accomodate the placement of
    * the 2nd mipmap.  This occurs when the alignment
    * constraints of mipmap placement push the right edge of the
    * 2nd mipmap out past the width of its parent.
    */
   if (mt->first_level != mt->last_level) {
       unsigned mip1_width;

       if (mt->compressed) {
          mip1_width = ALIGN(minify(mt->physical_width0, 1), mt->align_w) +
             ALIGN(minify(mt->physical_width0, 2), mt->align_w);
       } else {
          mip1_width = ALIGN(minify(mt->physical_width0, 1), mt->align_w) +
             minify(mt->physical_width0, 2);
       }

       if (mip1_width > mt->total_width) {
           mt->total_width = mip1_width;
       }
   }

   mt->total_height = 0;

   for (unsigned level = mt->first_level; level <= mt->last_level; level++) {
      unsigned img_height;

      intel_miptree_set_level_info(mt, level, x, y, depth);

      img_height = ALIGN(height, mt->align_h);
      if (mt->compressed)
	 img_height /= mt->align_h;

      /* Because the images are packed better, the final offset
       * might not be the maximal one:
       */
      mt->total_height = MAX2(mt->total_height, y + img_height);

      /* Layout_below: step right after second mipmap.
       */
      if (level == mt->first_level + 1) {
	 x += ALIGN(width, mt->align_w);
      } else {
	 y += img_height;
      }

      width  = minify(width, 1);
      height = minify(height, 1);
   }
}

static void
align_cube(struct intel_mipmap_tree *mt)
{
   /* The 965's sampler lays cachelines out according to how accesses
    * in the texture surfaces run, so they may be "vertical" through
    * memory.  As a result, the docs say in Surface Padding Requirements:
    * Sampling Engine Surfaces that two extra rows of padding are required.
    */
   if (mt->target == GL_TEXTURE_CUBE_MAP)
      mt->total_height += 2;
}

static void
brw_miptree_layout_texture_array(struct brw_context *brw,
				 struct intel_mipmap_tree *mt)
{
   int h0, h1;

   h0 = ALIGN(mt->physical_height0, mt->align_h);
   h1 = ALIGN(minify(mt->physical_height0, 1), mt->align_h);
   if (mt->array_spacing_lod0)
      mt->qpitch = h0;
   else
      mt->qpitch = (h0 + h1 + (brw->gen >= 7 ? 12 : 11) * mt->align_h);

   int physical_qpitch = mt->compressed ? mt->qpitch / 4 : mt->qpitch;

   brw_miptree_layout_2d(mt);

   for (unsigned level = mt->first_level; level <= mt->last_level; level++) {
      for (int q = 0; q < mt->physical_depth0; q++) {
	 intel_miptree_set_image_offset(mt, level, q, 0, q * physical_qpitch);
      }
   }
   mt->total_height = physical_qpitch * mt->physical_depth0;

   align_cube(mt);
}

static void
brw_miptree_layout_texture_3d(struct brw_context *brw,
                              struct intel_mipmap_tree *mt)
{
   unsigned yscale = mt->compressed ? 4 : 1;

   mt->total_width = 0;
   mt->total_height = 0;

   unsigned ysum = 0;
   for (unsigned level = mt->first_level; level <= mt->last_level; level++) {
      unsigned WL = MAX2(mt->physical_width0 >> level, 1);
      unsigned HL = MAX2(mt->physical_height0 >> level, 1);
      unsigned DL = MAX2(mt->physical_depth0 >> level, 1);
      unsigned wL = ALIGN(WL, mt->align_w);
      unsigned hL = ALIGN(HL, mt->align_h);

      if (mt->target == GL_TEXTURE_CUBE_MAP)
         DL = 6;

      intel_miptree_set_level_info(mt, level, 0, 0, DL);

      for (unsigned q = 0; q < DL; q++) {
         unsigned x = (q % (1 << level)) * wL;
         unsigned y = ysum + (q >> level) * hL;

         intel_miptree_set_image_offset(mt, level, q, x, y / yscale);
         mt->total_width = MAX2(mt->total_width, x + wL);
         mt->total_height = MAX2(mt->total_height, (y + hL) / yscale);
      }

      ysum += ALIGN(DL, 1 << level) / (1 << level) * hL;
   }

   align_cube(mt);
}

void
brw_miptree_layout(struct brw_context *brw, struct intel_mipmap_tree *mt)
{
   bool multisampled = mt->num_samples > 1;
   mt->align_w = intel_horizontal_texture_alignment_unit(brw, mt->format);
   mt->align_h =
      intel_vertical_texture_alignment_unit(brw, mt->format, multisampled);

   switch (mt->target) {
   case GL_TEXTURE_CUBE_MAP:
      if (brw->gen == 4) {
         /* Gen4 stores cube maps as 3D textures. */
         assert(mt->physical_depth0 == 6);
         brw_miptree_layout_texture_3d(brw, mt);
      } else {
         /* All other hardware stores cube maps as 2D arrays. */
	 brw_miptree_layout_texture_array(brw, mt);
      }
      break;

   case GL_TEXTURE_3D:
      brw_miptree_layout_texture_3d(brw, mt);
      break;

   case GL_TEXTURE_1D_ARRAY:
   case GL_TEXTURE_2D_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
      brw_miptree_layout_texture_array(brw, mt);
      break;

   default:
      switch (mt->msaa_layout) {
      case INTEL_MSAA_LAYOUT_UMS:
      case INTEL_MSAA_LAYOUT_CMS:
         brw_miptree_layout_texture_array(brw, mt);
         break;
      case INTEL_MSAA_LAYOUT_NONE:
      case INTEL_MSAA_LAYOUT_IMS:
         brw_miptree_layout_2d(mt);
         break;
      }
      break;
   }
   DBG("%s: %dx%dx%d\n", __FUNCTION__,
       mt->total_width, mt->total_height, mt->cpp);
}

@


1.13
log
@Merge Mesa 10.2.9
@
text
@@


1.12
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a37 1
#include "main/glformats.h"
a205 5
      if (mt->array_layout == ALL_SLICES_AT_EACH_LOD) {
         /* Compact arrays with separated miplevels */
         img_height *= depth;
      }

a240 1
   unsigned height = mt->physical_height0;
d244 1
a244 1
   if (mt->array_layout == ALL_SLICES_AT_EACH_LOD)
a253 5
      unsigned img_height;
      img_height = ALIGN(height, mt->align_h);
      if (mt->compressed)
         img_height /= mt->align_h;

d255 1
a255 5
         if (mt->array_layout == ALL_SLICES_AT_EACH_LOD) {
            intel_miptree_set_image_offset(mt, level, q, 0, q * img_height);
         } else {
            intel_miptree_set_image_offset(mt, level, q, 0, q * physical_qpitch);
         }
a256 1
      height = minify(height, 1);
d258 1
a258 2
   if (mt->array_layout == ALL_LOD_IN_EACH_SLICE)
      mt->total_height = physical_qpitch * mt->physical_depth0;
d304 3
a306 35
   bool gen6_hiz_or_stencil = false;

   if (brw->gen == 6 && mt->array_layout == ALL_SLICES_AT_EACH_LOD) {
      const GLenum base_format = _mesa_get_format_base_format(mt->format);
      gen6_hiz_or_stencil = _mesa_is_depth_or_stencil_format(base_format);
   }

   if (gen6_hiz_or_stencil) {
      /* On gen6, we use ALL_SLICES_AT_EACH_LOD for stencil/hiz because the
       * hardware doesn't support multiple mip levels on stencil/hiz.
       *
       * PRM Vol 2, Part 1, 7.5.3 Hierarchical Depth Buffer:
       * "The hierarchical depth buffer does not support the LOD field"
       *
       * PRM Vol 2, Part 1, 7.5.4.1 Separate Stencil Buffer:
       * "The stencil depth buffer does not support the LOD field"
       */
      if (mt->format == MESA_FORMAT_S_UINT8) {
         /* Stencil uses W tiling, so we force W tiling alignment for the
          * ALL_SLICES_AT_EACH_LOD miptree layout.
          */
         mt->align_w = 64;
         mt->align_h = 64;
      } else {
         /* Depth uses Y tiling, so we force need Y tiling alignment for the
          * ALL_SLICES_AT_EACH_LOD miptree layout.
          */
         mt->align_w = 128 / mt->cpp;
         mt->align_h = 32;
      }
   } else {
      mt->align_w = intel_horizontal_texture_alignment_unit(brw, mt->format);
      mt->align_h =
         intel_vertical_texture_alignment_unit(brw, mt->format, multisampled);
   }
@


1.11
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d38 1
d207 5
d247 1
d251 1
a251 1
   if (mt->array_spacing_lod0)
d261 5
d267 5
a271 1
	 intel_miptree_set_image_offset(mt, level, q, 0, q * physical_qpitch);
d273 1
d275 2
a276 1
   mt->total_height = physical_qpitch * mt->physical_depth0;
d322 35
a356 3
   mt->align_w = intel_horizontal_texture_alignment_unit(brw, mt->format);
   mt->align_h =
      intel_vertical_texture_alignment_unit(brw, mt->format, multisampled);
@


1.10
log
@Merge Mesa 9.2.5
@
text
@d2 1
a2 1
 * Copyright 2006 Tungsten Graphics, Inc., Cedar Park, Texas.
d31 2
a32 2
 * \author Keith Whitwell <keith@@tungstengraphics.com>
 * \author Michel Dänzer <michel@@tungstengraphics.com>
d43 1
a43 1
                                       gl_format format)
d78 1
a78 1
   if (format == MESA_FORMAT_S8)
d81 1
a81 9
   /* The depth alignment requirements in the table above are for rendering to
    * depth miplevels using the LOD control fields.  We don't use LOD control
    * fields, and instead use page offsets plus intra-tile x/y offsets, which
    * require that the low 3 bits are zero.  To reduce the number of x/y
    * offset workaround blits we do, align the X to 8, which depth texturing
    * can handle (sadly, it can't handle 8 in the Y direction).
    */
   if (brw->gen >= 7 &&
       _mesa_get_format_base_format(format) == GL_DEPTH_COMPONENT)
d89 1
a89 1
                                      gl_format format, bool multisampled)
d108 1
a108 1
    * | All Others                             |  2  |  2  |  2  |  2  |  2  |
d111 2
a112 2
    * On SNB+, non-special cases can be overridden by setting the SURFACE_STATE
    * "Surface Vertical Alignment" field to VALIGN_2 or VALIGN_4.
d117 1
a117 1
   if (format == MESA_FORMAT_S8)
d120 6
d137 19
d200 1
a200 2
      intel_miptree_set_level_info(mt, level, x, y, width,
				   height, depth);
a239 1
   unsigned qpitch = 0;
d245 1
a245 1
      qpitch = h0;
d247 3
a249 3
      qpitch = (h0 + h1 + (brw->gen >= 7 ? 12 : 11) * mt->align_h);
   if (mt->compressed)
      qpitch /= 4;
d255 1
a255 1
	 intel_miptree_set_image_offset(mt, level, q, 0, q * qpitch);
d258 1
a258 1
   mt->total_height = qpitch * mt->physical_depth0;
d283 1
a283 1
      intel_miptree_set_level_info(mt, level, 0, 0, WL, HL, DL);
@


1.9
log
@Merge Mesa 9.2.2
@
text
@d97 1
a97 1
                                     gl_format format)
a120 2
    *
    * We currently don't support multisampling.
d128 3
d288 1
d290 2
a291 1
   mt->align_h = intel_vertical_texture_alignment_unit(brw, mt->format);
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d208 12
d243 2
d251 1
a251 5
   unsigned width  = mt->physical_width0;
   unsigned height = mt->physical_height0;
   unsigned depth = mt->physical_depth0;
   unsigned pack_x_pitch, pack_x_nr;
   unsigned pack_y_pitch;
d253 1
d256 1
a256 11
   if (mt->compressed) {
       mt->total_width = ALIGN(width, mt->align_w);
       pack_y_pitch = (height + 3) / 4;
   } else {
      mt->total_width = mt->physical_width0;
      pack_y_pitch = ALIGN(mt->physical_height0, mt->align_h);
   }

   pack_x_pitch = width;
   pack_x_nr = 1;

d258 18
a275 17
      int x = 0;
      int y = 0;

      intel_miptree_set_level_info(mt, level,
                                   0, mt->total_height,
                                   width, height, depth);

      for (int q = 0; q < depth; /* empty */) {
         for (int j = 0; j < pack_x_nr && q < depth; j++, q++) {
            intel_miptree_set_image_offset(mt, level, q, x, y);
            x += pack_x_pitch;
         }
         if (x > mt->total_width)
            mt->total_width = x;

         x = 0;
         y += pack_y_pitch;
d278 1
a278 24
      mt->total_height += y;
      width  = minify(width, 1);
      height = minify(height, 1);
      if (mt->target == GL_TEXTURE_3D)
         depth = minify(depth, 1);

      if (mt->compressed) {
         pack_y_pitch = (height + 3) / 4;

         if (pack_x_pitch > ALIGN(width, mt->align_w)) {
            pack_x_pitch = ALIGN(width, mt->align_w);
            pack_x_nr <<= 1;
         }
      } else {
         pack_x_nr <<= 1;
         if (pack_x_pitch > 4) {
            pack_x_pitch >>= 1;
         }

         if (pack_y_pitch > 2) {
            pack_y_pitch >>= 1;
            pack_y_pitch = ALIGN(pack_y_pitch, mt->align_h);
         }
      }
d281 1
a281 7
   /* The 965's sampler lays cachelines out according to how accesses
    * in the texture surfaces run, so they may be "vertical" through
    * memory.  As a result, the docs say in Surface Padding Requirements:
    * Sampling Engine Surfaces that two extra rows of padding are required.
    */
   if (mt->target == GL_TEXTURE_CUBE_MAP)
      mt->total_height += 2;
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d2 23
a24 29
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
 develop this 3D driver.
 
 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:
 
 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keith@@tungstengraphics.com>
  */
d26 7
a32 1
/* Code to layout images in a mipmap tree for i965.
d36 1
a36 2
#include "intel_tex_layout.h"
#include "intel_context.h"
d41 195
a235 3
GLboolean brw_miptree_layout(struct intel_context *intel,
			     struct intel_mipmap_tree *mt,
			     uint32_t tiling)
d237 34
a270 2
   /* XXX: these vary depending on image format: */
   /* GLint align_w = 4; */
d272 3
a274 43
   switch (mt->target) {
   case GL_TEXTURE_CUBE_MAP:
      if (intel->gen >= 5) {
          GLuint align_w;
          GLuint align_h;
          GLuint level;
          GLuint qpitch = 0;
	  int h0, h1, q;

	  intel_get_texture_alignment_unit(mt->format, &align_w, &align_h);

	  /* On Ironlake, cube maps are finally represented as just a series
	   * of MIPLAYOUT_BELOW 2D textures (like 2D texture arrays), separated
	   * by a pitch of qpitch rows, where qpitch is defined by the equation
	   * given in Volume 1 of the BSpec.
	   */
	  h0 = ALIGN(mt->height0, align_h);
	  h1 = ALIGN(minify(mt->height0), align_h);
	  qpitch = (h0 + h1 + (intel->gen >= 7 ? 12 : 11) * align_h);
          if (mt->compressed)
	     qpitch /= 4;

	  i945_miptree_layout_2d(intel, mt, tiling, 6);

          for (level = mt->first_level; level <= mt->last_level; level++) {
	     for (q = 0; q < 6; q++) {
		intel_miptree_set_image_offset(mt, level, q, 0, q * qpitch);
	     }
          }
	  mt->total_height = qpitch * 6;

          break;
      }

   case GL_TEXTURE_3D: {
      GLuint width  = mt->width0;
      GLuint height = mt->height0;
      GLuint depth = mt->depth0;
      GLuint pack_x_pitch, pack_x_nr;
      GLuint pack_y_pitch;
      GLuint level;
      GLuint align_h = 2;
      GLuint align_w = 4;
d276 5
a280 2
      mt->total_height = 0;
      intel_get_texture_alignment_unit(mt->format, &align_w, &align_h);
d283 40
a322 2
          mt->total_width = ALIGN(width, align_w);
          pack_y_pitch = (height + 3) / 4;
d324 2
a325 2
	 mt->total_width = mt->width0;
	 pack_y_pitch = ALIGN(mt->height0, align_h);
d327 1
d329 3
a331 2
      pack_x_pitch = width;
      pack_x_nr = 1;
d333 5
a337 54
      for (level = mt->first_level ; level <= mt->last_level ; level++) {
	 GLuint nr_images = mt->target == GL_TEXTURE_3D ? depth : 6;
	 GLint x = 0;
	 GLint y = 0;
	 GLint q, j;

	 intel_miptree_set_level_info(mt, level, nr_images,
				      0, mt->total_height,
				      width, height, depth);

	 for (q = 0; q < nr_images;) {
	    for (j = 0; j < pack_x_nr && q < nr_images; j++, q++) {
	       intel_miptree_set_image_offset(mt, level, q, x, y);
	       x += pack_x_pitch;
	    }

	    x = 0;
	    y += pack_y_pitch;
	 }


	 mt->total_height += y;
	 width  = minify(width);
	 height = minify(height);
	 depth  = minify(depth);

	 if (mt->compressed) {
	    pack_y_pitch = (height + 3) / 4;

	    if (pack_x_pitch > ALIGN(width, align_w)) {
	       pack_x_pitch = ALIGN(width, align_w);
	       pack_x_nr <<= 1;
	    }
	 } else {
	    if (pack_x_pitch > 4) {
	       pack_x_pitch >>= 1;
	       pack_x_nr <<= 1;
	       assert(pack_x_pitch * pack_x_nr <= mt->total_width);
	    }

	    if (pack_y_pitch > 2) {
	       pack_y_pitch >>= 1;
	       pack_y_pitch = ALIGN(pack_y_pitch, align_h);
	    }
	 }

      }
      /* The 965's sampler lays cachelines out according to how accesses
       * in the texture surfaces run, so they may be "vertical" through
       * memory.  As a result, the docs say in Surface Padding Requirements:
       * Sampling Engine Surfaces that two extra rows of padding are required.
       */
      if (mt->target == GL_TEXTURE_CUBE_MAP)
	 mt->total_height += 2;
a338 1
   }
d341 10
a350 1
      i945_miptree_layout_2d(intel, mt, tiling, 1);
a354 2

   return GL_TRUE;
@


1.6
log
@Merge Mesa 7.10.3
@
text
@d52 2
a53 1
          GLuint align_h = 2;
d58 2
d66 2
a67 2
	  h1 = ALIGN(minify(h0), align_h);
	  qpitch = (h0 + h1 + 11 * align_h);
d94 1
a94 1
      intel_get_texture_alignment_unit(mt->internal_format, &align_w, &align_h);
a157 3
       * We don't know of similar requirements for pre-965, but given that
       * those docs are silent on padding requirements in general, let's play
       * it safe.
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d51 1
a51 1
      if (intel->gen == 5) {
d94 1
a94 1
          mt->pitch = ALIGN(width, align_w);
d97 1
a97 1
	 mt->pitch = intel_miptree_pitch_align (intel, mt, tiling, mt->width0);
d141 1
a141 1
	       assert(pack_x_pitch * pack_x_nr <= mt->pitch);
d168 2
a169 5
   DBG("%s: %dx%dx%d - sz 0x%x\n", __FUNCTION__,
		mt->pitch,
		mt->total_height,
		mt->cpp,
		mt->pitch * mt->total_height * mt->cpp );
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a30 1
        
d42 3
a44 1
GLboolean brw_miptree_layout( struct intel_context *intel, struct intel_mipmap_tree *mt )
d46 2
a47 3
   /* XXX: these vary depending on image format: 
    */
/*    GLint align_w = 4; */
d50 30
a79 1
   case GL_TEXTURE_CUBE_MAP: 
d91 2
a92 1
      
a93 1
          align_w = intel_compressed_alignment(mt->internal_format);
d97 2
a98 2
          mt->pitch = intel_miptree_pitch_align (intel, mt, mt->width0);
          pack_y_pitch = ALIGN(mt->height0, align_h);
d101 1
a101 1
      pack_x_pitch = mt->pitch;
d104 1
a104 1
      for ( level = mt->first_level ; level <= mt->last_level ; level++ ) {
d109 1
a109 1
	    
d121 1
a121 1
	    y += pack_y_pitch;	    
d130 19
a148 19
    if (mt->compressed) {
        pack_y_pitch = (height + 3) / 4;
        
        if (pack_x_pitch > ALIGN(width, align_w)) {
            pack_x_pitch = ALIGN(width, align_w);
            pack_x_nr <<= 1;
        }
    } else {
        if (pack_x_pitch > 4) {
            pack_x_pitch >>= 1;
            pack_x_nr <<= 1;
            assert(pack_x_pitch * pack_x_nr <= mt->pitch);
        }

        if (pack_y_pitch > 2) {
            pack_y_pitch >>= 1;
            pack_y_pitch = ALIGN(pack_y_pitch, align_h);
        }
    }
d151 10
d165 1
a165 1
      i945_miptree_layout_2d(intel, mt);
d168 2
a169 2
   DBG("%s: %dx%dx%d - sz 0x%x\n", __FUNCTION__, 
		mt->pitch, 
d173 1
a173 1
		
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d39 1
a39 1
#include "macros.h"
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d38 1
d41 1
d58 2
a60 1
      mt->pitch = ((mt->width0 * mt->cpp + 3) & ~3) / mt->cpp;
d62 9
a71 1
      pack_y_pitch = MAX2(mt->height0, 2);
a96 11

	 if (pack_x_pitch > 4) {
	    pack_x_pitch >>= 1;
	    pack_x_nr <<= 1;
	    assert(pack_x_pitch * pack_x_nr <= mt->pitch);
	 }

	 if (pack_y_pitch > 2) {
	    pack_y_pitch >>= 1;
	 }

d100 21
@


1.1
log
@Initial revision
@
text
@d37 1
a39 5
static GLuint minify( GLuint d )
{
   return MAX2(1, d>>1);
}

d41 1
a41 1
GLboolean brw_miptree_layout( struct intel_mipmap_tree *mt )
a45 2
   GLint align_h = 2;

d104 2
a105 41
   default: {
      GLuint level;
      GLuint x = 0;
      GLuint y = 0;
      GLuint width = mt->width0;
      GLuint height = mt->height0;

      mt->pitch = ((mt->width0 * mt->cpp + 3) & ~3) / mt->cpp;
      mt->total_height = 0;

      for ( level = mt->first_level ; level <= mt->last_level ; level++ ) {
	 GLuint img_height;

	 intel_miptree_set_level_info(mt, level, 1,
				      x, y,
				      width, 
				      mt->compressed ? height/4 : height, 1);

	 if (mt->compressed)
	    img_height = MAX2(1, height/4);
	 else
	    img_height = MAX2(align_h, height);


	 /* Because the images are packed better, the final offset
	  * might not be the maximal one:
	  */
	 mt->total_height = MAX2(mt->total_height, y + img_height);
	 
	 /* Layout_below: step right after second mipmap.
	  */
	 if (level == mt->first_level + 1) 
	    x += mt->pitch / 2;
	 else {
	    y += img_height;
	 }


	 width  = minify(width);
	 height = minify(height);
      }
a106 1
   }
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d141 1
a141 1
	 if (level == mt->first_level + 1) {
a142 2
	    x = (x + 3) & ~ 3;
	 }
a144 2
	    y += align_h - 1;
	    y &= ~(align_h - 1);
d146 1
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@a36 1
#include "intel_tex_layout.h"
d39 5
d50 2
d110 44
a153 2
   default:
      i945_miptree_layout_2d(mt);
d155 1
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d31 1
d38 1
a38 2
#include "intel_context.h"
#include "main/macros.h"
a39 1
#define FILE_DEBUG_FLAG DEBUG_MIPTREE
d41 1
a41 3
GLboolean brw_miptree_layout(struct intel_context *intel,
			     struct intel_mipmap_tree *mt,
			     uint32_t tiling)
d43 3
a45 2
   /* XXX: these vary depending on image format: */
   /* GLint align_w = 4; */
d48 1
a48 30
   case GL_TEXTURE_CUBE_MAP:
      if (intel->gen >= 5) {
          GLuint align_h = 2;
          GLuint level;
          GLuint qpitch = 0;
	  int h0, h1, q;

	  /* On Ironlake, cube maps are finally represented as just a series
	   * of MIPLAYOUT_BELOW 2D textures (like 2D texture arrays), separated
	   * by a pitch of qpitch rows, where qpitch is defined by the equation
	   * given in Volume 1 of the BSpec.
	   */
	  h0 = ALIGN(mt->height0, align_h);
	  h1 = ALIGN(minify(h0), align_h);
	  qpitch = (h0 + h1 + 11 * align_h);
          if (mt->compressed)
	     qpitch /= 4;

	  i945_miptree_layout_2d(intel, mt, tiling, 6);

          for (level = mt->first_level; level <= mt->last_level; level++) {
	     for (q = 0; q < 6; q++) {
		intel_miptree_set_image_offset(mt, level, q, 0, q * qpitch);
	     }
          }
	  mt->total_height = qpitch * 6;

          break;
      }

a55 2
      GLuint align_h = 2;
      GLuint align_w = 4;
d57 1
a58 9
      intel_get_texture_alignment_unit(mt->internal_format, &align_w, &align_h);

      if (mt->compressed) {
          mt->total_width = ALIGN(width, align_w);
          pack_y_pitch = (height + 3) / 4;
      } else {
	 mt->total_width = mt->width0;
	 pack_y_pitch = ALIGN(mt->height0, align_h);
      }
d60 2
a61 1
      pack_x_pitch = width;
d64 1
a64 1
      for (level = mt->first_level ; level <= mt->last_level ; level++) {
d69 1
a69 1

d81 1
a81 1
	    y += pack_y_pitch;
a85 3
	 width  = minify(width);
	 height = minify(height);
	 depth  = minify(depth);
d87 5
a91 2
	 if (mt->compressed) {
	    pack_y_pitch = (height + 3) / 4;
d93 2
a94 15
	    if (pack_x_pitch > ALIGN(width, align_w)) {
	       pack_x_pitch = ALIGN(width, align_w);
	       pack_x_nr <<= 1;
	    }
	 } else {
	    if (pack_x_pitch > 4) {
	       pack_x_pitch >>= 1;
	       pack_x_nr <<= 1;
	       assert(pack_x_pitch * pack_x_nr <= mt->total_width);
	    }

	    if (pack_y_pitch > 2) {
	       pack_y_pitch >>= 1;
	       pack_y_pitch = ALIGN(pack_y_pitch, align_h);
	    }
d97 3
a100 10
      /* The 965's sampler lays cachelines out according to how accesses
       * in the texture surfaces run, so they may be "vertical" through
       * memory.  As a result, the docs say in Surface Padding Requirements:
       * Sampling Engine Surfaces that two extra rows of padding are required.
       * We don't know of similar requirements for pre-965, but given that
       * those docs are silent on padding requirements in general, let's play
       * it safe.
       */
      if (mt->target == GL_TEXTURE_CUBE_MAP)
	 mt->total_height += 2;
d105 1
a105 1
      i945_miptree_layout_2d(intel, mt, tiling, 1);
d108 6
a113 3
   DBG("%s: %dx%dx%d\n", __FUNCTION__,
       mt->total_width, mt->total_height, mt->cpp);

@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d2 29
a30 23
 * Copyright 2006 Tungsten Graphics, Inc., Cedar Park, Texas.
 * Copyright © 2006 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
d32 1
a32 7
/**
 * \file brw_tex_layout.cpp
 *
 * Code to lay out images in a mipmap tree.
 *
 * \author Keith Whitwell <keith@@tungstengraphics.com>
 * \author Michel Dänzer <michel@@tungstengraphics.com>
d36 2
a37 1
#include "brw_context.h"
d42 3
a44 57
static unsigned int
intel_horizontal_texture_alignment_unit(struct brw_context *brw,
                                       gl_format format)
{
   /**
    * From the "Alignment Unit Size" section of various specs, namely:
    * - Gen3 Spec: "Memory Data Formats" Volume,         Section 1.20.1.4
    * - i965 and G45 PRMs:             Volume 1,         Section 6.17.3.4.
    * - Ironlake and Sandybridge PRMs: Volume 1, Part 1, Section 7.18.3.4
    * - BSpec (for Ivybridge and slight variations in separate stencil)
    *
    * +----------------------------------------------------------------------+
    * |                                        | alignment unit width  ("i") |
    * | Surface Property                       |-----------------------------|
    * |                                        | 915 | 965 | ILK | SNB | IVB |
    * +----------------------------------------------------------------------+
    * | YUV 4:2:2 format                       |  8  |  4  |  4  |  4  |  4  |
    * | BC1-5 compressed format (DXTn/S3TC)    |  4  |  4  |  4  |  4  |  4  |
    * | FXT1  compressed format                |  8  |  8  |  8  |  8  |  8  |
    * | Depth Buffer (16-bit)                  |  4  |  4  |  4  |  4  |  8  |
    * | Depth Buffer (other)                   |  4  |  4  |  4  |  4  |  4  |
    * | Separate Stencil Buffer                | N/A | N/A |  8  |  8  |  8  |
    * | All Others                             |  4  |  4  |  4  |  4  |  4  |
    * +----------------------------------------------------------------------+
    *
    * On IVB+, non-special cases can be overridden by setting the SURFACE_STATE
    * "Surface Horizontal Alignment" field to HALIGN_4 or HALIGN_8.
    */
    if (_mesa_is_format_compressed(format)) {
       /* The hardware alignment requirements for compressed textures
        * happen to match the block boundaries.
        */
      unsigned int i, j;
      _mesa_get_format_block_size(format, &i, &j);
      return i;
    }

   if (format == MESA_FORMAT_S8)
      return 8;

   /* The depth alignment requirements in the table above are for rendering to
    * depth miplevels using the LOD control fields.  We don't use LOD control
    * fields, and instead use page offsets plus intra-tile x/y offsets, which
    * require that the low 3 bits are zero.  To reduce the number of x/y
    * offset workaround blits we do, align the X to 8, which depth texturing
    * can handle (sadly, it can't handle 8 in the Y direction).
    */
   if (brw->gen >= 7 &&
       _mesa_get_format_base_format(format) == GL_DEPTH_COMPONENT)
      return 8;

   return 4;
}

static unsigned int
intel_vertical_texture_alignment_unit(struct brw_context *brw,
                                     gl_format format)
d46 2
a47 38
   /**
    * From the "Alignment Unit Size" section of various specs, namely:
    * - Gen3 Spec: "Memory Data Formats" Volume,         Section 1.20.1.4
    * - i965 and G45 PRMs:             Volume 1,         Section 6.17.3.4.
    * - Ironlake and Sandybridge PRMs: Volume 1, Part 1, Section 7.18.3.4
    * - BSpec (for Ivybridge and slight variations in separate stencil)
    *
    * +----------------------------------------------------------------------+
    * |                                        | alignment unit height ("j") |
    * | Surface Property                       |-----------------------------|
    * |                                        | 915 | 965 | ILK | SNB | IVB |
    * +----------------------------------------------------------------------+
    * | BC1-5 compressed format (DXTn/S3TC)    |  4  |  4  |  4  |  4  |  4  |
    * | FXT1  compressed format                |  4  |  4  |  4  |  4  |  4  |
    * | Depth Buffer                           |  2  |  2  |  2  |  4  |  4  |
    * | Separate Stencil Buffer                | N/A | N/A | N/A |  4  |  8  |
    * | Multisampled (4x or 8x) render target  | N/A | N/A | N/A |  4  |  4  |
    * | All Others                             |  2  |  2  |  2  |  2  |  2  |
    * +----------------------------------------------------------------------+
    *
    * On SNB+, non-special cases can be overridden by setting the SURFACE_STATE
    * "Surface Vertical Alignment" field to VALIGN_2 or VALIGN_4.
    *
    * We currently don't support multisampling.
    */
   if (_mesa_is_format_compressed(format))
      return 4;

   if (format == MESA_FORMAT_S8)
      return brw->gen >= 7 ? 8 : 4;

   GLenum base_format = _mesa_get_format_base_format(format);

   if (brw->gen >= 6 &&
       (base_format == GL_DEPTH_COMPONENT ||
	base_format == GL_DEPTH_STENCIL)) {
      return 4;
   }
d49 40
a88 75
   return 2;
}

static void
brw_miptree_layout_2d(struct intel_mipmap_tree *mt)
{
   unsigned x = 0;
   unsigned y = 0;
   unsigned width = mt->physical_width0;
   unsigned height = mt->physical_height0;
   unsigned depth = mt->physical_depth0; /* number of array layers. */

   mt->total_width = mt->physical_width0;

   if (mt->compressed) {
       mt->total_width = ALIGN(mt->physical_width0, mt->align_w);
   }

   /* May need to adjust width to accomodate the placement of
    * the 2nd mipmap.  This occurs when the alignment
    * constraints of mipmap placement push the right edge of the
    * 2nd mipmap out past the width of its parent.
    */
   if (mt->first_level != mt->last_level) {
       unsigned mip1_width;

       if (mt->compressed) {
          mip1_width = ALIGN(minify(mt->physical_width0, 1), mt->align_w) +
             ALIGN(minify(mt->physical_width0, 2), mt->align_w);
       } else {
          mip1_width = ALIGN(minify(mt->physical_width0, 1), mt->align_w) +
             minify(mt->physical_width0, 2);
       }

       if (mip1_width > mt->total_width) {
           mt->total_width = mip1_width;
       }
   }

   mt->total_height = 0;

   for (unsigned level = mt->first_level; level <= mt->last_level; level++) {
      unsigned img_height;

      intel_miptree_set_level_info(mt, level, x, y, width,
				   height, depth);

      img_height = ALIGN(height, mt->align_h);
      if (mt->compressed)
	 img_height /= mt->align_h;

      /* Because the images are packed better, the final offset
       * might not be the maximal one:
       */
      mt->total_height = MAX2(mt->total_height, y + img_height);

      /* Layout_below: step right after second mipmap.
       */
      if (level == mt->first_level + 1) {
	 x += ALIGN(width, mt->align_w);
      } else {
	 y += img_height;
      }

      width  = minify(width, 1);
      height = minify(height, 1);
   }
}

static void
brw_miptree_layout_texture_array(struct brw_context *brw,
				 struct intel_mipmap_tree *mt)
{
   unsigned qpitch = 0;
   int h0, h1;
d90 2
a91 67
   h0 = ALIGN(mt->physical_height0, mt->align_h);
   h1 = ALIGN(minify(mt->physical_height0, 1), mt->align_h);
   if (mt->array_spacing_lod0)
      qpitch = h0;
   else
      qpitch = (h0 + h1 + (brw->gen >= 7 ? 12 : 11) * mt->align_h);
   if (mt->compressed)
      qpitch /= 4;

   brw_miptree_layout_2d(mt);

   for (unsigned level = mt->first_level; level <= mt->last_level; level++) {
      for (int q = 0; q < mt->physical_depth0; q++) {
	 intel_miptree_set_image_offset(mt, level, q, 0, q * qpitch);
      }
   }
   mt->total_height = qpitch * mt->physical_depth0;
}

static void
brw_miptree_layout_texture_3d(struct brw_context *brw,
                              struct intel_mipmap_tree *mt)
{
   unsigned width  = mt->physical_width0;
   unsigned height = mt->physical_height0;
   unsigned depth = mt->physical_depth0;
   unsigned pack_x_pitch, pack_x_nr;
   unsigned pack_y_pitch;

   mt->total_height = 0;

   if (mt->compressed) {
       mt->total_width = ALIGN(width, mt->align_w);
       pack_y_pitch = (height + 3) / 4;
   } else {
      mt->total_width = mt->physical_width0;
      pack_y_pitch = ALIGN(mt->physical_height0, mt->align_h);
   }

   pack_x_pitch = width;
   pack_x_nr = 1;

   for (unsigned level = mt->first_level; level <= mt->last_level; level++) {
      int x = 0;
      int y = 0;

      intel_miptree_set_level_info(mt, level,
                                   0, mt->total_height,
                                   width, height, depth);

      for (int q = 0; q < depth; /* empty */) {
         for (int j = 0; j < pack_x_nr && q < depth; j++, q++) {
            intel_miptree_set_image_offset(mt, level, q, x, y);
            x += pack_x_pitch;
         }
         if (x > mt->total_width)
            mt->total_width = x;

         x = 0;
         y += pack_y_pitch;
      }

      mt->total_height += y;
      width  = minify(width, 1);
      height = minify(height, 1);
      if (mt->target == GL_TEXTURE_3D)
         depth = minify(depth, 1);
d94 2
a95 6
         pack_y_pitch = (height + 3) / 4;

         if (pack_x_pitch > ALIGN(width, mt->align_w)) {
            pack_x_pitch = ALIGN(width, mt->align_w);
            pack_x_nr <<= 1;
         }
d97 2
a98 9
         pack_x_nr <<= 1;
         if (pack_x_pitch > 4) {
            pack_x_pitch >>= 1;
         }

         if (pack_y_pitch > 2) {
            pack_y_pitch >>= 1;
            pack_y_pitch = ALIGN(pack_y_pitch, mt->align_h);
         }
a99 1
   }
d101 2
a102 8
   /* The 965's sampler lays cachelines out according to how accesses
    * in the texture surfaces run, so they may be "vertical" through
    * memory.  As a result, the docs say in Surface Padding Requirements:
    * Sampling Engine Surfaces that two extra rows of padding are required.
    */
   if (mt->target == GL_TEXTURE_CUBE_MAP)
      mt->total_height += 2;
}
d104 57
a160 27
void
brw_miptree_layout(struct brw_context *brw, struct intel_mipmap_tree *mt)
{
   mt->align_w = intel_horizontal_texture_alignment_unit(brw, mt->format);
   mt->align_h = intel_vertical_texture_alignment_unit(brw, mt->format);

   switch (mt->target) {
   case GL_TEXTURE_CUBE_MAP:
      if (brw->gen == 4) {
         /* Gen4 stores cube maps as 3D textures. */
         assert(mt->physical_depth0 == 6);
         brw_miptree_layout_texture_3d(brw, mt);
      } else {
         /* All other hardware stores cube maps as 2D arrays. */
	 brw_miptree_layout_texture_array(brw, mt);
      }
      break;

   case GL_TEXTURE_3D:
      brw_miptree_layout_texture_3d(brw, mt);
      break;

   case GL_TEXTURE_1D_ARRAY:
   case GL_TEXTURE_2D_ARRAY:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
      brw_miptree_layout_texture_array(brw, mt);
d162 1
d165 1
a165 10
      switch (mt->msaa_layout) {
      case INTEL_MSAA_LAYOUT_UMS:
      case INTEL_MSAA_LAYOUT_CMS:
         brw_miptree_layout_texture_array(brw, mt);
         break;
      case INTEL_MSAA_LAYOUT_NONE:
      case INTEL_MSAA_LAYOUT_IMS:
         brw_miptree_layout_2d(mt);
         break;
      }
d170 2
@


1.1.1.6
log
@Import Mesa 9.2.2
@
text
@a207 12
align_cube(struct intel_mipmap_tree *mt)
{
   /* The 965's sampler lays cachelines out according to how accesses
    * in the texture surfaces run, so they may be "vertical" through
    * memory.  As a result, the docs say in Surface Padding Requirements:
    * Sampling Engine Surfaces that two extra rows of padding are required.
    */
   if (mt->target == GL_TEXTURE_CUBE_MAP)
      mt->total_height += 2;
}

static void
a230 2

   align_cube(mt);
d237 5
a241 1
   unsigned yscale = mt->compressed ? 4 : 1;
a242 1
   mt->total_width = 0;
d245 11
a255 1
   unsigned ysum = 0;
d257 17
a273 18
      unsigned WL = MAX2(mt->physical_width0 >> level, 1);
      unsigned HL = MAX2(mt->physical_height0 >> level, 1);
      unsigned DL = MAX2(mt->physical_depth0 >> level, 1);
      unsigned wL = ALIGN(WL, mt->align_w);
      unsigned hL = ALIGN(HL, mt->align_h);

      if (mt->target == GL_TEXTURE_CUBE_MAP)
         DL = 6;

      intel_miptree_set_level_info(mt, level, 0, 0, WL, HL, DL);

      for (unsigned q = 0; q < DL; q++) {
         unsigned x = (q % (1 << level)) * wL;
         unsigned y = ysum + (q >> level) * hL;

         intel_miptree_set_image_offset(mt, level, q, x, y / yscale);
         mt->total_width = MAX2(mt->total_width, x + wL);
         mt->total_height = MAX2(mt->total_height, (y + hL) / yscale);
d276 24
a299 1
      ysum += ALIGN(DL, 1 << level) / (1 << level) * hL;
d302 7
a308 1
   align_cube(mt);
@


1.1.1.7
log
@Import Mesa 9.2.5
@
text
@d97 1
a97 1
                                      gl_format format, bool multisampled)
d121 2
a129 3
   if (multisampled)
      return 4;

a286 1
   bool multisampled = mt->num_samples > 1;
d288 1
a288 2
   mt->align_h =
      intel_vertical_texture_alignment_unit(brw, mt->format, multisampled);
@


1.1.1.8
log
@Import Mesa 10.2.3
@
text
@d2 1
a2 1
 * Copyright 2006 VMware, Inc.
d31 2
a32 2
 * \author Keith Whitwell <keithw@@vmware.com>
 * \author Michel Dänzer <daenzer@@vmware.com>
d43 1
a43 1
                                       mesa_format format)
d78 1
a78 1
   if (format == MESA_FORMAT_S_UINT8)
d81 9
a89 1
   if (brw->gen >= 7 && format == MESA_FORMAT_Z_UNORM16)
d97 1
a97 1
                                      mesa_format format, bool multisampled)
d116 1
a116 1
    * | All Others                             |  2  |  2  |  2  |  *  |  *  |
d119 2
a120 2
    * Where "*" means either VALIGN_2 or VALIGN_4 depending on the setting of
    * the SURFACE_STATE "Surface Vertical Alignment" field.
d125 1
a125 1
   if (format == MESA_FORMAT_S_UINT8)
a127 6
   /* Broadwell only supports VALIGN of 4, 8, and 16.  The BSpec says 4
    * should always be used, except for stencil buffers, which should be 8.
    */
   if (brw->gen >= 8)
      return 4;

a138 19
   if (brw->gen == 7) {
      /* On Gen7, we prefer a vertical alignment of 4 when possible, because
       * that allows Y tiled render targets.
       *
       * From the Ivy Bridge PRM, Vol4 Part1 2.12.2.1 (SURFACE_STATE for most
       * messages), on p64, under the heading "Surface Vertical Alignment":
       *
       *     Value of 1 [VALIGN_4] is not supported for format YCRCB_NORMAL
       *     (0x182), YCRCB_SWAPUVY (0x183), YCRCB_SWAPUV (0x18f), YCRCB_SWAPY
       *     (0x190)
       *
       *     VALIGN_4 is not supported for surface format R32G32B32_FLOAT.
       */
      if (base_format == GL_YCBCR_MESA || format == MESA_FORMAT_RGB_FLOAT32)
         return 2;

      return 4;
   }

d183 2
a184 1
      intel_miptree_set_level_info(mt, level, x, y, depth);
d224 1
d230 1
a230 1
      mt->qpitch = h0;
d232 3
a234 3
      mt->qpitch = (h0 + h1 + (brw->gen >= 7 ? 12 : 11) * mt->align_h);

   int physical_qpitch = mt->compressed ? mt->qpitch / 4 : mt->qpitch;
d240 1
a240 1
	 intel_miptree_set_image_offset(mt, level, q, 0, q * physical_qpitch);
d243 1
a243 1
   mt->total_height = physical_qpitch * mt->physical_depth0;
d268 1
a268 1
      intel_miptree_set_level_info(mt, level, 0, 0, DL);
@


1.1.1.9
log
@Import Mesa 10.4.3
@
text
@a37 1
#include "main/glformats.h"
a205 5
      if (mt->array_layout == ALL_SLICES_AT_EACH_LOD) {
         /* Compact arrays with separated miplevels */
         img_height *= depth;
      }

a240 1
   unsigned height = mt->physical_height0;
d244 1
a244 1
   if (mt->array_layout == ALL_SLICES_AT_EACH_LOD)
a253 5
      unsigned img_height;
      img_height = ALIGN(height, mt->align_h);
      if (mt->compressed)
         img_height /= mt->align_h;

d255 1
a255 5
         if (mt->array_layout == ALL_SLICES_AT_EACH_LOD) {
            intel_miptree_set_image_offset(mt, level, q, 0, q * img_height);
         } else {
            intel_miptree_set_image_offset(mt, level, q, 0, q * physical_qpitch);
         }
a256 1
      height = minify(height, 1);
d258 1
a258 2
   if (mt->array_layout == ALL_LOD_IN_EACH_SLICE)
      mt->total_height = physical_qpitch * mt->physical_depth0;
d304 3
a306 35
   bool gen6_hiz_or_stencil = false;

   if (brw->gen == 6 && mt->array_layout == ALL_SLICES_AT_EACH_LOD) {
      const GLenum base_format = _mesa_get_format_base_format(mt->format);
      gen6_hiz_or_stencil = _mesa_is_depth_or_stencil_format(base_format);
   }

   if (gen6_hiz_or_stencil) {
      /* On gen6, we use ALL_SLICES_AT_EACH_LOD for stencil/hiz because the
       * hardware doesn't support multiple mip levels on stencil/hiz.
       *
       * PRM Vol 2, Part 1, 7.5.3 Hierarchical Depth Buffer:
       * "The hierarchical depth buffer does not support the LOD field"
       *
       * PRM Vol 2, Part 1, 7.5.4.1 Separate Stencil Buffer:
       * "The stencil depth buffer does not support the LOD field"
       */
      if (mt->format == MESA_FORMAT_S_UINT8) {
         /* Stencil uses W tiling, so we force W tiling alignment for the
          * ALL_SLICES_AT_EACH_LOD miptree layout.
          */
         mt->align_w = 64;
         mt->align_h = 64;
      } else {
         /* Depth uses Y tiling, so we force need Y tiling alignment for the
          * ALL_SLICES_AT_EACH_LOD miptree layout.
          */
         mt->align_w = 128 / mt->cpp;
         mt->align_h = 32;
      }
   } else {
      mt->align_w = intel_horizontal_texture_alignment_unit(brw, mt->format);
      mt->align_h =
         intel_vertical_texture_alignment_unit(brw, mt->format, multisampled);
   }
@


1.1.1.10
log
@Import Mesa 10.2.9
@
text
@d38 1
d207 5
d247 1
d251 1
a251 1
   if (mt->array_spacing_lod0)
d261 5
d267 5
a271 1
	 intel_miptree_set_image_offset(mt, level, q, 0, q * physical_qpitch);
d273 1
d275 2
a276 1
   mt->total_height = physical_qpitch * mt->physical_depth0;
d322 35
a356 3
   mt->align_w = intel_horizontal_texture_alignment_unit(brw, mt->format);
   mt->align_h =
      intel_vertical_texture_alignment_unit(brw, mt->format, multisampled);
@


