head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.7;
commitid	TnlogFl9nOv2eaRf;

1.7
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.6;
commitid	4ry2gvZGMXkCUD2n;

1.6
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.5;
commitid	mcxB0JvoI9gTDYXU;

1.5
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.04.27;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.15;	author matthieu;	state dead;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.51;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.51;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.48;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.53;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.11.56;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.49.02;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.8
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 *
 * Copyright 2006 VMware, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

/** @@file intel_mipmap_tree.h
 *
 * This file defines the structure that wraps a BO and describes how the
 * mipmap levels and slices of a texture are laid out.
 *
 * The hardware has a fixed layout of a texture depending on parameters such
 * as the target/type (2D, 3D, CUBE), width, height, pitch, and number of
 * mipmap levels.  The individual level/layer slices are each 2D rectangles of
 * pixels at some x/y offset from the start of the drm_intel_bo.
 *
 * Original OpenGL allowed texture miplevels to be specified in arbitrary
 * order, and a texture may change size over time.  Thus, each
 * intel_texture_image has a reference to a miptree that contains the pixel
 * data sized appropriately for it, which will later be referenced by/copied
 * to the intel_texture_object at draw time (intel_finalize_mipmap_tree()) so
 * that there's a single miptree for the complete texture.
 */

#ifndef INTEL_MIPMAP_TREE_H
#define INTEL_MIPMAP_TREE_H

#include <assert.h>

#include "main/mtypes.h"
#include "intel_bufmgr.h"
#include "intel_resolve_map.h"
#include <GL/internal/dri_interface.h>

#ifdef __cplusplus
extern "C" {
#endif

struct brw_context;
struct intel_renderbuffer;

struct intel_resolve_map;
struct intel_texture_image;

/**
 * When calling intel_miptree_map() on an ETC-transcoded-to-RGB miptree or a
 * depthstencil-split-to-separate-stencil miptree, we'll normally make a
 * tmeporary and recreate the kind of data requested by Mesa core, since we're
 * satisfying some glGetTexImage() request or something.
 *
 * However, occasionally you want to actually map the miptree's current data
 * without transcoding back.  This flag to intel_miptree_map() gets you that.
 */
#define BRW_MAP_DIRECT_BIT	0x80000000

struct intel_miptree_map {
   /** Bitfield of GL_MAP_READ_BIT, GL_MAP_WRITE_BIT, GL_MAP_INVALIDATE_BIT */
   GLbitfield mode;
   /** Region of interest for the map. */
   int x, y, w, h;
   /** Possibly malloced temporary buffer for the mapping. */
   void *buffer;
   /** Possible pointer to a temporary linear miptree for the mapping. */
   struct intel_mipmap_tree *mt;
   /** Pointer to the start of (map_x, map_y) returned by the mapping. */
   void *ptr;
   /** Stride of the mapping. */
   int stride;
};

/**
 * Describes the location of each texture image within a miptree.
 */
struct intel_mipmap_level
{
   /** Offset to this miptree level, used in computing x_offset. */
   GLuint level_x;
   /** Offset to this miptree level, used in computing y_offset. */
   GLuint level_y;

   /**
    * \brief Number of 2D slices in this miplevel.
    *
    * The exact semantics of depth varies according to the texture target:
    *    - For GL_TEXTURE_CUBE_MAP, depth is 6.
    *    - For GL_TEXTURE_2D_ARRAY, depth is the number of array slices. It is
    *      identical for all miplevels in the texture.
    *    - For GL_TEXTURE_3D, it is the texture's depth at this miplevel. Its
    *      value, like width and height, varies with miplevel.
    *    - For other texture types, depth is 1.
    *    - Additionally, for UMS and CMS miptrees, depth is multiplied by
    *      sample count.
    */
   GLuint depth;

   /**
    * \brief List of 2D images in this mipmap level.
    *
    * This may be a list of cube faces, array slices in 2D array texture, or
    * layers in a 3D texture. The list's length is \c depth.
    */
   struct intel_mipmap_slice {
      /**
       * \name Offset to slice
       * \{
       *
       * Hardware formats are so diverse that that there is no unified way to
       * compute the slice offsets, so we store them in this table.
       *
       * The (x, y) offset to slice \c s at level \c l relative the miptrees
       * base address is
       * \code
       *     x = mt->level[l].slice[s].x_offset
       *     y = mt->level[l].slice[s].y_offset
       */
      GLuint x_offset;
      GLuint y_offset;
      /** \} */

      /**
       * Mapping information. Persistent for the duration of
       * intel_miptree_map/unmap on this slice.
       */
      struct intel_miptree_map *map;

      /**
       * \brief Is HiZ enabled for this slice?
       *
       * If \c mt->level[l].slice[s].has_hiz is set, then (1) \c mt->hiz_mt
       * has been allocated and (2) the HiZ memory corresponding to this slice
       * resides at \c mt->hiz_mt->level[l].slice[s].
       */
      bool has_hiz;
   } *slice;
};

/**
 * Enum for keeping track of the different MSAA layouts supported by Gen7.
 */
enum intel_msaa_layout
{
   /**
    * Ordinary surface with no MSAA.
    */
   INTEL_MSAA_LAYOUT_NONE,

   /**
    * Interleaved Multisample Surface.  The additional samples are
    * accommodated by scaling up the width and the height of the surface so
    * that all the samples corresponding to a pixel are located at nearby
    * memory locations.
    */
   INTEL_MSAA_LAYOUT_IMS,

   /**
    * Uncompressed Multisample Surface.  The surface is stored as a 2D array,
    * with array slice n containing all pixel data for sample n.
    */
   INTEL_MSAA_LAYOUT_UMS,

   /**
    * Compressed Multisample Surface.  The surface is stored as in
    * INTEL_MSAA_LAYOUT_UMS, but there is an additional buffer called the MCS
    * (Multisample Control Surface) buffer.  Each pixel in the MCS buffer
    * indicates the mapping from sample number to array slice.  This allows
    * the common case (where all samples constituting a pixel have the same
    * color value) to be stored efficiently by just using a single array
    * slice.
    */
   INTEL_MSAA_LAYOUT_CMS,
};


/**
 * Enum for keeping track of the fast clear state of a buffer associated with
 * a miptree.
 *
 * Fast clear works by deferring the memory writes that would be used to clear
 * the buffer, so that instead of performing them at the time of the clear
 * operation, the hardware automatically performs them at the time that the
 * buffer is later accessed for rendering.  The MCS buffer keeps track of
 * which regions of the buffer still have pending clear writes.
 *
 * This enum keeps track of the driver's knowledge of pending fast clears in
 * the MCS buffer.
 *
 * MCS buffers only exist on Gen7+.
 */
enum intel_fast_clear_state
{
   /**
    * There is no MCS buffer for this miptree, and one should never be
    * allocated.
    */
   INTEL_FAST_CLEAR_STATE_NO_MCS,

   /**
    * No deferred clears are pending for this miptree, and the contents of the
    * color buffer are entirely correct.  An MCS buffer may or may not exist
    * for this miptree.  If it does exist, it is entirely in the "no deferred
    * clears pending" state.  If it does not exist, it will be created the
    * first time a fast color clear is executed.
    *
    * In this state, the color buffer can be used for purposes other than
    * rendering without needing a render target resolve.
    *
    * Since there is no such thing as a "fast color clear resolve" for MSAA
    * buffers, an MSAA buffer will never be in this state.
    */
   INTEL_FAST_CLEAR_STATE_RESOLVED,

   /**
    * An MCS buffer exists for this miptree, and deferred clears are pending
    * for some regions of the color buffer, as indicated by the MCS buffer.
    * The contents of the color buffer are only correct for the regions where
    * the MCS buffer doesn't indicate a deferred clear.
    *
    * If a single-sample buffer is in this state, a render target resolve must
    * be performed before it can be used for purposes other than rendering.
    */
   INTEL_FAST_CLEAR_STATE_UNRESOLVED,

   /**
    * An MCS buffer exists for this miptree, and deferred clears are pending
    * for the entire color buffer, and the contents of the MCS buffer reflect
    * this.  The contents of the color buffer are undefined.
    *
    * If a single-sample buffer is in this state, a render target resolve must
    * be performed before it can be used for purposes other than rendering.
    *
    * If the client attempts to clear a buffer which is already in this state,
    * the clear can be safely skipped, since the buffer is already clear.
    */
   INTEL_FAST_CLEAR_STATE_CLEAR,
};

struct intel_mipmap_tree
{
   /** Buffer object containing the pixel data. */
   drm_intel_bo *bo;

   uint32_t pitch; /**< pitch in bytes. */

   uint32_t tiling; /**< One of the I915_TILING_* flags */

   /* Effectively the key:
    */
   GLenum target;

   /**
    * Generally, this is just the same as the gl_texture_image->TexFormat or
    * gl_renderbuffer->Format.
    *
    * However, for textures and renderbuffers with packed depth/stencil formats
    * on hardware where we want or need to use separate stencil, there will be
    * two miptrees for storing the data.  If the depthstencil texture or rb is
    * MESA_FORMAT_Z32_FLOAT_S8X24_UINT, then mt->format will be
    * MESA_FORMAT_Z_FLOAT32, otherwise for MESA_FORMAT_Z24_UNORM_S8_UINT objects it will be
    * MESA_FORMAT_Z24_UNORM_X8_UINT.
    *
    * For ETC1/ETC2 textures, this is one of the uncompressed mesa texture
    * formats if the hardware lacks support for ETC1/ETC2. See @@ref etc_format.
    */
   mesa_format format;

   /** This variable stores the value of ETC compressed texture format */
   mesa_format etc_format;

   /**
    * The X offset of each image in the miptree must be aligned to this.
    * See the comments in brw_tex_layout.c.
    */
   unsigned int align_w;
   unsigned int align_h; /**< \see align_w */

   GLuint first_level;
   GLuint last_level;

   /**
    * Level zero image dimensions.  These dimensions correspond to the
    * physical layout of data in memory.  Accordingly, they account for the
    * extra width, height, and or depth that must be allocated in order to
    * accommodate multisample formats, and they account for the extra factor
    * of 6 in depth that must be allocated in order to accommodate cubemap
    * textures.
    */
   GLuint physical_width0, physical_height0, physical_depth0;

   GLuint cpp; /**< bytes per pixel */
   GLuint num_samples;
   bool compressed;

   /**
    * Level zero image dimensions.  These dimensions correspond to the
    * logical width, height, and depth of the texture as seen by client code.
    * Accordingly, they do not account for the extra width, height, and/or
    * depth that must be allocated in order to accommodate multisample
    * formats, nor do they account for the extra factor of 6 in depth that
    * must be allocated in order to accommodate cubemap textures.
    */
   uint32_t logical_width0, logical_height0, logical_depth0;

   /**
    * For 1D array, 2D array, cube, and 2D multisampled surfaces on Gen7: true
    * if the surface only contains LOD 0, and hence no space is for LOD's
    * other than 0 in between array slices.
    *
    * Corresponds to the surface_array_spacing bit in gen7_surface_state.
    */
   bool array_spacing_lod0;

   /**
    * The distance in rows between array slices in an uncompressed surface.
    *
    * For compressed surfaces, slices are stored closer together physically;
    * the real distance is (qpitch / block height).
    */
   uint32_t qpitch;

   /**
    * MSAA layout used by this buffer.
    */
   enum intel_msaa_layout msaa_layout;

   /* Derived from the above:
    */
   GLuint total_width;
   GLuint total_height;

   /* The 3DSTATE_CLEAR_PARAMS value associated with the last depth clear to
    * this depth mipmap tree, if any.
    */
   uint32_t depth_clear_value;

   /* Includes image offset tables:
    */
   struct intel_mipmap_level level[MAX_TEXTURE_LEVELS];

   /* Offset into bo where miptree starts:
    */
   uint32_t offset;

   /**
    * \brief HiZ miptree
    *
    * The hiz miptree contains the miptree's hiz buffer. To allocate the hiz
    * miptree, use intel_miptree_alloc_hiz().
    *
    * To determine if hiz is enabled, do not check this pointer. Instead, use
    * intel_miptree_slice_has_hiz().
    */
   struct intel_mipmap_tree *hiz_mt;

   /**
    * \brief Map of miptree slices to needed resolves.
    *
    * This is used only when the miptree has a child HiZ miptree.
    *
    * Let \c mt be a depth miptree with HiZ enabled. Then the resolve map is
    * \c mt->hiz_map. The resolve map of the child HiZ miptree, \c
    * mt->hiz_mt->hiz_map, is unused.
    */
   struct intel_resolve_map hiz_map;

   /**
    * \brief Stencil miptree for depthstencil textures.
    *
    * This miptree is used for depthstencil textures and renderbuffers that
    * require separate stencil.  It always has the true copy of the stencil
    * bits, regardless of mt->format.
    *
    * \see intel_miptree_map_depthstencil()
    * \see intel_miptree_unmap_depthstencil()
    */
   struct intel_mipmap_tree *stencil_mt;

   /**
    * \brief MCS miptree.
    *
    * This miptree contains the "multisample control surface", which stores
    * the necessary information to implement compressed MSAA
    * (INTEL_MSAA_FORMAT_CMS) and "fast color clear" behaviour on Gen7+.
    *
    * NULL if no MCS miptree is in use for this surface.
    */
   struct intel_mipmap_tree *mcs_mt;

   /**
    * Fast clear state for this buffer.
    */
   enum intel_fast_clear_state fast_clear_state;

   /**
    * The SURFACE_STATE bits associated with the last fast color clear to this
    * color mipmap tree, if any.
    *
    * This value will only ever contain ones in bits 28-31, so it is safe to
    * OR into dword 7 of SURFACE_STATE.
    */
   uint32_t fast_clear_color_value;

   /* These are also refcounted:
    */
   GLuint refcount;
};

enum intel_miptree_tiling_mode {
   INTEL_MIPTREE_TILING_ANY,
   INTEL_MIPTREE_TILING_Y,
   INTEL_MIPTREE_TILING_NONE,
};

bool
intel_is_non_msrt_mcs_buffer_supported(struct brw_context *brw,
                                       struct intel_mipmap_tree *mt);

void
intel_get_non_msrt_mcs_alignment(struct brw_context *brw,
                                 struct intel_mipmap_tree *mt,
                                 unsigned *width_px, unsigned *height);

bool
intel_miptree_alloc_non_msrt_mcs(struct brw_context *brw,
                                 struct intel_mipmap_tree *mt);

struct intel_mipmap_tree *intel_miptree_create(struct brw_context *brw,
                                               GLenum target,
					       mesa_format format,
                                               GLuint first_level,
                                               GLuint last_level,
                                               GLuint width0,
                                               GLuint height0,
                                               GLuint depth0,
					       bool expect_accelerated_upload,
                                               GLuint num_samples,
                                               enum intel_miptree_tiling_mode);

struct intel_mipmap_tree *
intel_miptree_create_layout(struct brw_context *brw,
                            GLenum target,
                            mesa_format format,
                            GLuint first_level,
                            GLuint last_level,
                            GLuint width0,
                            GLuint height0,
                            GLuint depth0,
                            bool for_bo,
                            GLuint num_samples);

struct intel_mipmap_tree *
intel_miptree_create_for_bo(struct brw_context *brw,
                            drm_intel_bo *bo,
                            mesa_format format,
                            uint32_t offset,
                            uint32_t width,
                            uint32_t height,
                            int pitch);

void
intel_update_winsys_renderbuffer_miptree(struct brw_context *intel,
                                         struct intel_renderbuffer *irb,
                                         drm_intel_bo *bo,
                                         uint32_t width, uint32_t height,
                                         uint32_t pitch);

/**
 * Create a miptree appropriate as the storage for a non-texture renderbuffer.
 * The miptree has the following properties:
 *     - The target is GL_TEXTURE_2D.
 *     - There are no levels other than the base level 0.
 *     - Depth is 1.
 */
struct intel_mipmap_tree*
intel_miptree_create_for_renderbuffer(struct brw_context *brw,
                                      mesa_format format,
                                      uint32_t width,
                                      uint32_t height,
                                      uint32_t num_samples);

mesa_format
intel_depth_format_for_depthstencil_format(mesa_format format);

mesa_format
intel_lower_compressed_format(struct brw_context *brw, mesa_format format);

/** \brief Assert that the level and layer are valid for the miptree. */
static inline void
intel_miptree_check_level_layer(struct intel_mipmap_tree *mt,
                                uint32_t level,
                                uint32_t layer)
{
   assert(level >= mt->first_level);
   assert(level <= mt->last_level);
   assert(layer < mt->level[level].depth);
}

void intel_miptree_reference(struct intel_mipmap_tree **dst,
                             struct intel_mipmap_tree *src);

void intel_miptree_release(struct intel_mipmap_tree **mt);

/* Check if an image fits an existing mipmap tree layout
 */
bool intel_miptree_match_image(struct intel_mipmap_tree *mt,
                                    struct gl_texture_image *image);

void
intel_miptree_get_image_offset(const struct intel_mipmap_tree *mt,
			       GLuint level, GLuint slice,
			       GLuint *x, GLuint *y);

void
intel_miptree_get_dimensions_for_image(struct gl_texture_image *image,
                                       int *width, int *height, int *depth);

void
intel_miptree_get_tile_masks(const struct intel_mipmap_tree *mt,
                             uint32_t *mask_x, uint32_t *mask_y,
                             bool map_stencil_as_y_tiled);

uint32_t
intel_miptree_get_tile_offsets(const struct intel_mipmap_tree *mt,
                               GLuint level, GLuint slice,
                               uint32_t *tile_x,
                               uint32_t *tile_y);
uint32_t
intel_miptree_get_aligned_offset(const struct intel_mipmap_tree *mt,
                                 uint32_t x, uint32_t y,
                                 bool map_stencil_as_y_tiled);

void intel_miptree_set_level_info(struct intel_mipmap_tree *mt,
                                  GLuint level,
                                  GLuint x, GLuint y, GLuint d);

void intel_miptree_set_image_offset(struct intel_mipmap_tree *mt,
                                    GLuint level,
                                    GLuint img, GLuint x, GLuint y);

void
intel_miptree_copy_teximage(struct brw_context *brw,
                            struct intel_texture_image *intelImage,
                            struct intel_mipmap_tree *dst_mt, bool invalidate);

bool
intel_miptree_alloc_mcs(struct brw_context *brw,
                        struct intel_mipmap_tree *mt,
                        GLuint num_samples);

/**
 * \name Miptree HiZ functions
 * \{
 *
 * It is safe to call the "slice_set_need_resolve" and "slice_resolve"
 * functions on a miptree without HiZ. In that case, each function is a no-op.
 */

/**
 * \brief Allocate the miptree's embedded HiZ miptree.
 * \see intel_mipmap_tree:hiz_mt
 * \return false if allocation failed
 */

bool
intel_miptree_alloc_hiz(struct brw_context *brw,
			struct intel_mipmap_tree *mt);

bool
intel_miptree_slice_has_hiz(struct intel_mipmap_tree *mt,
                            uint32_t level,
                            uint32_t layer);

void
intel_miptree_slice_set_needs_hiz_resolve(struct intel_mipmap_tree *mt,
                                          uint32_t level,
					  uint32_t depth);
void
intel_miptree_slice_set_needs_depth_resolve(struct intel_mipmap_tree *mt,
                                            uint32_t level,
					    uint32_t depth);

void
intel_miptree_set_all_slices_need_depth_resolve(struct intel_mipmap_tree *mt,
                                                uint32_t level);

/**
 * \return false if no resolve was needed
 */
bool
intel_miptree_slice_resolve_hiz(struct brw_context *brw,
				struct intel_mipmap_tree *mt,
				unsigned int level,
				unsigned int depth);

/**
 * \return false if no resolve was needed
 */
bool
intel_miptree_slice_resolve_depth(struct brw_context *brw,
				  struct intel_mipmap_tree *mt,
				  unsigned int level,
				  unsigned int depth);

/**
 * \return false if no resolve was needed
 */
bool
intel_miptree_all_slices_resolve_hiz(struct brw_context *brw,
				     struct intel_mipmap_tree *mt);

/**
 * \return false if no resolve was needed
 */
bool
intel_miptree_all_slices_resolve_depth(struct brw_context *brw,
				       struct intel_mipmap_tree *mt);

/**\}*/

/**
 * Update the fast clear state for a miptree to indicate that it has been used
 * for rendering.
 */
static inline void
intel_miptree_used_for_rendering(struct intel_mipmap_tree *mt)
{
   /* If the buffer was previously in fast clear state, change it to
    * unresolved state, since it won't be guaranteed to be clear after
    * rendering occurs.
    */
   if (mt->fast_clear_state == INTEL_FAST_CLEAR_STATE_CLEAR)
      mt->fast_clear_state = INTEL_FAST_CLEAR_STATE_UNRESOLVED;
}

void
intel_miptree_resolve_color(struct brw_context *brw,
                            struct intel_mipmap_tree *mt);

void
intel_miptree_make_shareable(struct brw_context *brw,
                             struct intel_mipmap_tree *mt);

void
intel_miptree_updownsample(struct brw_context *brw,
                           struct intel_mipmap_tree *src,
                           struct intel_mipmap_tree *dst);

void brw_miptree_layout(struct brw_context *brw, struct intel_mipmap_tree *mt);

void *intel_miptree_map_raw(struct brw_context *brw,
                            struct intel_mipmap_tree *mt);

void intel_miptree_unmap_raw(struct brw_context *brw,
                             struct intel_mipmap_tree *mt);

void
intel_miptree_map(struct brw_context *brw,
		  struct intel_mipmap_tree *mt,
		  unsigned int level,
		  unsigned int slice,
		  unsigned int x,
		  unsigned int y,
		  unsigned int w,
		  unsigned int h,
		  GLbitfield mode,
		  void **out_ptr,
		  int *out_stride);

void
intel_miptree_unmap(struct brw_context *brw,
		    struct intel_mipmap_tree *mt,
		    unsigned int level,
		    unsigned int slice);

void
intel_hiz_exec(struct brw_context *brw, struct intel_mipmap_tree *mt,
	       unsigned int level, unsigned int layer, enum gen6_hiz_op op);

#ifdef __cplusplus
}
#endif

#endif
@


1.7
log
@Merge Mesa 10.2.9
@
text
@@


1.6
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a117 9
    * \brief Is HiZ enabled for this level?
    *
    * If \c mt->level[l].has_hiz is set, then (1) \c mt->hiz_mt has been
    * allocated and (2) the HiZ memory for the slices in this level reside at
    * \c mt->hiz_mt->level[l].
    */
   bool has_hiz;

   /**
d146 9
a257 52
enum miptree_array_layout {
   /* Each array slice contains all miplevels packed together.
    *
    * Gen hardware usually wants multilevel miptrees configured this way.
    *
    * A 2D Array texture with 2 slices and multiple LODs using
    * ALL_LOD_IN_EACH_SLICE would look somewhat like this:
    *
    *   +----------+
    *   |          |
    *   |          |
    *   +----------+
    *   +---+ +-+
    *   |   | +-+
    *   +---+ *
    *   +----------+
    *   |          |
    *   |          |
    *   +----------+
    *   +---+ +-+
    *   |   | +-+
    *   +---+ *
    */
   ALL_LOD_IN_EACH_SLICE,

   /* Each LOD contains all slices of that LOD packed together.
    *
    * In some situations, Gen7+ hardware can use the array_spacing_lod0
    * feature to save space when the surface only contains LOD 0.
    *
    * Gen6 uses this for separate stencil and hiz since gen6 does not support
    * multiple LODs for separate stencil and hiz.
    *
    * A 2D Array texture with 2 slices and multiple LODs using
    * ALL_SLICES_AT_EACH_LOD would look somewhat like this:
    *
    *   +----------+
    *   |          |
    *   |          |
    *   +----------+
    *   |          |
    *   |          |
    *   +----------+
    *   +---+ +-+
    *   |   | +-+
    *   +---+ +-+
    *   |   | :
    *   +---+
    */
   ALL_SLICES_AT_EACH_LOD,
};

d325 5
a329 2
    * Indicates if we use the standard miptree layout (ALL_LOD_IN_EACH_SLICE),
    * or if we tightly pack array slices at each LOD (ALL_SLICES_AT_EACH_LOD).
d331 1
a331 1
   enum miptree_array_layout array_layout;
d384 1
a384 1
   struct exec_list hiz_map; /* List of intel_resolve_map. */
d457 1
a457 2
                                               enum intel_miptree_tiling_mode,
                                               bool force_all_slices_at_each_lod);
d469 1
a469 2
                            GLuint num_samples,
                            bool force_all_slices_at_each_lod);
d589 3
a591 1
intel_miptree_level_has_hiz(struct intel_mipmap_tree *mt, uint32_t level);
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d118 9
a154 9

      /**
       * \brief Is HiZ enabled for this slice?
       *
       * If \c mt->level[l].slice[s].has_hiz is set, then (1) \c mt->hiz_mt
       * has been allocated and (2) the HiZ memory corresponding to this slice
       * resides at \c mt->hiz_mt->level[l].slice[s].
       */
      bool has_hiz;
d258 52
d377 2
a378 5
    * For 1D array, 2D array, cube, and 2D multisampled surfaces on Gen7: true
    * if the surface only contains LOD 0, and hence no space is for LOD's
    * other than 0 in between array slices.
    *
    * Corresponds to the surface_array_spacing bit in gen7_surface_state.
d380 1
a380 1
   bool array_spacing_lod0;
d433 1
a433 1
   struct intel_resolve_map hiz_map;
d506 2
a507 1
                                               enum intel_miptree_tiling_mode);
d519 2
a520 1
                            GLuint num_samples);
d640 1
a640 3
intel_miptree_slice_has_hiz(struct intel_mipmap_tree *mt,
                            uint32_t level,
                            uint32_t layer);
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d2 2
a3 2
 * 
 * Copyright 2006 Tungsten Graphics, Inc., Cedar Park, Texas.
d5 1
a5 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
 * 
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d25 1
a25 1
 * 
d28 18
d51 2
a52 1
#include "intel_regions.h"
d54 1
d60 2
a61 25
/* A layer on top of the intel_regions code which adds:
 *
 * - Code to size and layout a region to hold a set of mipmaps.
 * - Query to determine if a new image fits in an existing tree.
 * - More refcounting 
 *     - maybe able to remove refcounting from intel_region?
 * - ?
 *
 * The fixed mipmap layout of intel hardware where one offset
 * specifies the position of all images in a mipmap hierachy
 * complicates the implementation of GL texture image commands,
 * compared to hardware where each image is specified with an
 * independent offset.
 *
 * In an ideal world, each texture object would be associated with a
 * single bufmgr buffer or 2d intel_region, and all the images within
 * the texture object would slot into the tree as they arrive.  The
 * reality can be a little messier, as images can arrive from the user
 * with sizes that don't fit in the existing tree, or in an order
 * where the tree layout cannot be guessed immediately.  
 * 
 * This structure encodes an idealized mipmap tree.  The GL image
 * commands build these where possible, otherwise store the images in
 * temporary system buffers.
 */
a89 6

   /**
    * intel_mipmap_tree::singlesample_mt is temporary storage that persists
    * only for the duration of the map.
    */
   bool singlesample_mt_is_tmp;
d93 1
a93 1
 * Describes the location of each texture image within a texture region.
a100 2
   GLuint width;
   GLuint height;
d112 2
d196 2
a197 2
 * Enum for keeping track of the state of an MCS buffer associated with a
 * miptree.  This determines when fast clear related operations are needed.
d205 2
a206 2
 * This enum keeps track of the driver's knowledge of the state of the MCS
 * buffer.
d210 1
a210 1
enum intel_mcs_state
d216 1
a216 6
   INTEL_MCS_STATE_NONE,

   /**
    * An MCS buffer exists for this miptree, and it is used for MSAA purposes.
    */
   INTEL_MCS_STATE_MSAA,
d227 3
d231 1
a231 1
   INTEL_MCS_STATE_RESOLVED,
d239 2
a240 2
    * In this state, a render target resolve must be performed before the
    * color buffer can be used for purposes other than rendering.
d242 1
a242 1
   INTEL_MCS_STATE_UNRESOLVED,
d249 2
a250 2
    * In this state, a render target resolve must be performed before the
    * color buffer can be used for purposes other than rendering.
d255 1
a255 1
   INTEL_MCS_STATE_CLEAR,
d260 7
d278 3
a280 3
    * MESA_FORMAT_Z32_FLOAT_X24S8, then mt->format will be
    * MESA_FORMAT_Z32_FLOAT, otherwise for MESA_FORMAT_S8_Z24 objects it will be
    * MESA_FORMAT_X8_Z24.
d283 1
a283 1
    * formats if the hardware lacks support for ETC1/ETC2. See @@ref wraps_etc.
d285 1
a285 1
   gl_format format;
d288 1
a288 1
   gl_format etc_format;
d310 1
a310 1
   GLuint cpp;
d316 1
a316 1
    * logical width, height, and depth of the region as seen by client code.
d334 8
d360 1
a360 5
   /* The data is held here:
    */
   struct intel_region *region;

   /* Offset into region bo where miptree starts:
a364 44
    * \brief Singlesample miptree.
    *
    * This is used under two cases.
    *
    * --- Case 1: As persistent singlesample storage for multisample window
    *  system front and back buffers ---
    *
    * Suppose that the window system FBO was created with a multisample
    * config.  Let `back_irb` be the `intel_renderbuffer` for the FBO's back
    * buffer. Then `back_irb` contains two miptrees: a parent multisample
    * miptree (back_irb->mt) and a child singlesample miptree
    * (back_irb->mt->singlesample_mt).  The DRM buffer shared with DRI2
    * belongs to `back_irb->mt->singlesample_mt` and contains singlesample
    * data.  The singlesample miptree is created at the same time as and
    * persists for the lifetime of its parent multisample miptree.
    *
    * When access to the singlesample data is needed, such as at
    * eglSwapBuffers and glReadPixels, an automatic downsample occurs from
    * `back_rb->mt` to `back_rb->mt->singlesample_mt` when necessary.
    *
    * This description of the back buffer applies analogously to the front
    * buffer.
    *
    *
    * --- Case 2: As temporary singlesample storage for mapping multisample
    *  miptrees ---
    *
    * Suppose the intel_miptree_map is called on a multisample miptree, `mt`,
    * for which case 1 does not apply (that is, `mt` does not belong to
    * a front or back buffer).  Then `mt->singlesample_mt` is null at the
    * start of the call. intel_miptree_map will create a temporary
    * singlesample miptree, store it at `mt->singlesample_mt`, downsample from
    * `mt` to `mt->singlesample_mt` if necessary, then map
    * `mt->singlesample_mt`. The temporary miptree is later deleted during
    * intel_miptree_unmap.
    */
   struct intel_mipmap_tree *singlesample_mt;

   /**
    * \brief A downsample is needed from this miptree to singlesample_mt.
    */
   bool need_downsample;

   /**
d410 1
a410 1
    * MCS state for this buffer.
d412 1
a412 1
   enum intel_mcs_state mcs_state;
d449 1
a449 1
					       gl_format format,
d462 1
a462 1
                            gl_format format,
d474 1
a474 1
                            gl_format format,
d478 1
a478 2
                            int pitch,
                            uint32_t tiling);
d480 6
a485 6
struct intel_mipmap_tree*
intel_miptree_create_for_dri2_buffer(struct brw_context *brw,
                                     unsigned dri_attachment,
                                     gl_format format,
                                     uint32_t num_samples,
                                     struct intel_region *region);
d496 1
a496 1
                                      gl_format format,
d501 6
d529 1
a529 1
intel_miptree_get_image_offset(struct intel_mipmap_tree *mt,
d537 5
d543 1
a543 1
intel_miptree_get_tile_offsets(struct intel_mipmap_tree *mt,
d547 4
d554 1
a554 2
                                  GLuint x, GLuint y,
                                  GLuint w, GLuint h, GLuint d);
d602 4
d651 2
a652 2
   if (mt->mcs_state == INTEL_MCS_STATE_CLEAR)
      mt->mcs_state = INTEL_MCS_STATE_UNRESOLVED;
d664 3
a666 6
intel_miptree_downsample(struct brw_context *brw,
                         struct intel_mipmap_tree *mt);

void
intel_miptree_upsample(struct brw_context *brw,
                       struct intel_mipmap_tree *mt);
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d31 2
d34 5
d44 3
d66 34
d101 9
a109 2
struct intel_mipmap_level {
   GLuint level_offset;
d112 12
a124 1
   GLuint nr_images;
d126 5
a130 5
   /* Explicitly store the offset of each image for each cube face or
    * depth value.  Pretty much have to accept that hardware formats
    * are going to be so diverse that there is no unified way to
    * compute the offsets of depth/cube images within a mipmap level,
    * so have to store them as a lookup table:
d132 33
a164 1
   GLuint *image_offset;
d167 104
a270 1
struct intel_mipmap_tree {
d274 26
a299 1
   GLenum internal_format;
d304 10
a313 1
   GLuint width0, height0, depth0;
d315 26
a340 1
   GLboolean compressed;
d343 2
a344 3
    */   
   GLuint pitch;
   GLuint depth_pitch;		/* per-image on i945? */
d346 6
a351 1
   
d360 107
d472 5
d478 81
d560 1
a560 25
struct intel_mipmap_tree *intel_miptree_create( struct intel_context *intel,
						GLenum target,
						GLenum internal_format,
						GLuint first_level,
						GLuint last_level,
						GLuint width0,
						GLuint height0,
						GLuint depth0,
						GLuint cpp,
						GLboolean compressed);

int intel_miptree_pitch_align (struct intel_context *intel,
			       struct intel_mipmap_tree *mt,
			       int pitch);

void intel_miptree_destroy( struct intel_context *intel,
			    struct intel_mipmap_tree *mt );


/* Return the linear offset of an image relative to the start of the
 * tree:
 */
GLuint intel_miptree_image_offset( struct intel_mipmap_tree *mt,
				   GLuint face,
				   GLuint level );
d562 1
a562 2
/* Return pointers to each 2d slice within an image.  Indexed by depth
 * value.
d564 2
a565 2
const GLuint *intel_miptree_depth_offsets(struct intel_mipmap_tree *mt,
					  GLuint level);
d567 14
d583 3
a585 4
				  GLuint level,
				  GLuint nr_images,
				  GLuint x, GLuint y,
				  GLuint w, GLuint h, GLuint d);
d588 20
a607 21
				    GLuint level,
				    GLuint img,
				    GLuint x, GLuint y);


/* Upload an image into a tree
 */
GLboolean intel_miptree_image_data(struct intel_context *intel, 
				   struct intel_mipmap_tree *dst,
				   GLuint face,
				   GLuint level,
				   const void *src, 
				   GLuint src_row_pitch,
				   GLuint src_image_pitch);

/* i915_mipmap_tree.c:
 */
GLboolean i915_miptree_layout( struct intel_mipmap_tree *mt );
GLboolean i945_miptree_layout( struct intel_mipmap_tree *mt );
GLboolean brw_miptree_layout( struct intel_context *intel,
			      struct intel_mipmap_tree *mt );
d609 41
d651 81
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@@


1.1
log
@Initial revision
@
text
@d118 4
d166 2
a167 1
GLboolean brw_miptree_layout( struct intel_mipmap_tree *mt );
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a30 2
#include <assert.h>

a31 5
#include "intel_resolve_map.h"

#ifdef __cplusplus
extern "C" {
#endif
a36 3
 * - More refcounting 
 *     - maybe able to remove refcounting from intel_region?
 * - ?
a55 34
struct intel_resolve_map;
struct intel_texture_image;

/**
 * When calling intel_miptree_map() on an ETC-transcoded-to-RGB miptree or a
 * depthstencil-split-to-separate-stencil miptree, we'll normally make a
 * tmeporary and recreate the kind of data requested by Mesa core, since we're
 * satisfying some glGetTexImage() request or something.
 *
 * However, occasionally you want to actually map the miptree's current data
 * without transcoding back.  This flag to intel_miptree_map() gets you that.
 */
#define BRW_MAP_DIRECT_BIT	0x80000000

struct intel_miptree_map {
   /** Bitfield of GL_MAP_READ_BIT, GL_MAP_WRITE_BIT, GL_MAP_INVALIDATE_BIT */
   GLbitfield mode;
   /** Region of interest for the map. */
   int x, y, w, h;
   /** Possibly malloced temporary buffer for the mapping. */
   void *buffer;
   /** Possible pointer to a temporary linear miptree for the mapping. */
   struct intel_mipmap_tree *mt;
   /** Pointer to the start of (map_x, map_y) returned by the mapping. */
   void *ptr;
   /** Stride of the mapping. */
   int stride;

   /**
    * intel_mipmap_tree::singlesample_mt is temporary storage that persists
    * only for the duration of the map.
    */
   bool singlesample_mt_is_tmp;
};
d57 2
a58 9
/**
 * Describes the location of each texture image within a texture region.
 */
struct intel_mipmap_level
{
   /** Offset to this miptree level, used in computing x_offset. */
   GLuint level_x;
   /** Offset to this miptree level, used in computing y_offset. */
   GLuint level_y;
a60 12

   /**
    * \brief Number of 2D slices in this miplevel.
    *
    * The exact semantics of depth varies according to the texture target:
    *    - For GL_TEXTURE_CUBE_MAP, depth is 6.
    *    - For GL_TEXTURE_2D_ARRAY, depth is the number of array slices. It is
    *      identical for all miplevels in the texture.
    *    - For GL_TEXTURE_3D, it is the texture's depth at this miplevel. Its
    *      value, like width and height, varies with miplevel.
    *    - For other texture types, depth is 1.
    */
d62 1
d64 5
a68 5
   /**
    * \brief List of 2D images in this mipmap level.
    *
    * This may be a list of cube faces, array slices in 2D array texture, or
    * layers in a 3D texture. The list's length is \c depth.
d70 1
a70 33
   struct intel_mipmap_slice {
      /**
       * \name Offset to slice
       * \{
       *
       * Hardware formats are so diverse that that there is no unified way to
       * compute the slice offsets, so we store them in this table.
       *
       * The (x, y) offset to slice \c s at level \c l relative the miptrees
       * base address is
       * \code
       *     x = mt->level[l].slice[s].x_offset
       *     y = mt->level[l].slice[s].y_offset
       */
      GLuint x_offset;
      GLuint y_offset;
      /** \} */

      /**
       * Mapping information. Persistent for the duration of
       * intel_miptree_map/unmap on this slice.
       */
      struct intel_miptree_map *map;

      /**
       * \brief Is HiZ enabled for this slice?
       *
       * If \c mt->level[l].slice[s].has_hiz is set, then (1) \c mt->hiz_mt
       * has been allocated and (2) the HiZ memory corresponding to this slice
       * resides at \c mt->hiz_mt->level[l].slice[s].
       */
      bool has_hiz;
   } *slice;
d73 1
a73 104
/**
 * Enum for keeping track of the different MSAA layouts supported by Gen7.
 */
enum intel_msaa_layout
{
   /**
    * Ordinary surface with no MSAA.
    */
   INTEL_MSAA_LAYOUT_NONE,

   /**
    * Interleaved Multisample Surface.  The additional samples are
    * accommodated by scaling up the width and the height of the surface so
    * that all the samples corresponding to a pixel are located at nearby
    * memory locations.
    */
   INTEL_MSAA_LAYOUT_IMS,

   /**
    * Uncompressed Multisample Surface.  The surface is stored as a 2D array,
    * with array slice n containing all pixel data for sample n.
    */
   INTEL_MSAA_LAYOUT_UMS,

   /**
    * Compressed Multisample Surface.  The surface is stored as in
    * INTEL_MSAA_LAYOUT_UMS, but there is an additional buffer called the MCS
    * (Multisample Control Surface) buffer.  Each pixel in the MCS buffer
    * indicates the mapping from sample number to array slice.  This allows
    * the common case (where all samples constituting a pixel have the same
    * color value) to be stored efficiently by just using a single array
    * slice.
    */
   INTEL_MSAA_LAYOUT_CMS,
};


/**
 * Enum for keeping track of the state of an MCS buffer associated with a
 * miptree.  This determines when fast clear related operations are needed.
 *
 * Fast clear works by deferring the memory writes that would be used to clear
 * the buffer, so that instead of performing them at the time of the clear
 * operation, the hardware automatically performs them at the time that the
 * buffer is later accessed for rendering.  The MCS buffer keeps track of
 * which regions of the buffer still have pending clear writes.
 *
 * This enum keeps track of the driver's knowledge of the state of the MCS
 * buffer.
 *
 * MCS buffers only exist on Gen7+.
 */
enum intel_mcs_state
{
   /**
    * There is no MCS buffer for this miptree, and one should never be
    * allocated.
    */
   INTEL_MCS_STATE_NONE,

   /**
    * An MCS buffer exists for this miptree, and it is used for MSAA purposes.
    */
   INTEL_MCS_STATE_MSAA,

   /**
    * No deferred clears are pending for this miptree, and the contents of the
    * color buffer are entirely correct.  An MCS buffer may or may not exist
    * for this miptree.  If it does exist, it is entirely in the "no deferred
    * clears pending" state.  If it does not exist, it will be created the
    * first time a fast color clear is executed.
    *
    * In this state, the color buffer can be used for purposes other than
    * rendering without needing a render target resolve.
    */
   INTEL_MCS_STATE_RESOLVED,

   /**
    * An MCS buffer exists for this miptree, and deferred clears are pending
    * for some regions of the color buffer, as indicated by the MCS buffer.
    * The contents of the color buffer are only correct for the regions where
    * the MCS buffer doesn't indicate a deferred clear.
    *
    * In this state, a render target resolve must be performed before the
    * color buffer can be used for purposes other than rendering.
    */
   INTEL_MCS_STATE_UNRESOLVED,

   /**
    * An MCS buffer exists for this miptree, and deferred clears are pending
    * for the entire color buffer, and the contents of the MCS buffer reflect
    * this.  The contents of the color buffer are undefined.
    *
    * In this state, a render target resolve must be performed before the
    * color buffer can be used for purposes other than rendering.
    *
    * If the client attempts to clear a buffer which is already in this state,
    * the clear can be safely skipped, since the buffer is already clear.
    */
   INTEL_MCS_STATE_CLEAR,
};

struct intel_mipmap_tree
{
d77 1
a77 26

   /**
    * Generally, this is just the same as the gl_texture_image->TexFormat or
    * gl_renderbuffer->Format.
    *
    * However, for textures and renderbuffers with packed depth/stencil formats
    * on hardware where we want or need to use separate stencil, there will be
    * two miptrees for storing the data.  If the depthstencil texture or rb is
    * MESA_FORMAT_Z32_FLOAT_X24S8, then mt->format will be
    * MESA_FORMAT_Z32_FLOAT, otherwise for MESA_FORMAT_S8_Z24 objects it will be
    * MESA_FORMAT_X8_Z24.
    *
    * For ETC1/ETC2 textures, this is one of the uncompressed mesa texture
    * formats if the hardware lacks support for ETC1/ETC2. See @@ref wraps_etc.
    */
   gl_format format;

   /** This variable stores the value of ETC compressed texture format */
   gl_format etc_format;

   /**
    * The X offset of each image in the miptree must be aligned to this.
    * See the comments in brw_tex_layout.c.
    */
   unsigned int align_w;
   unsigned int align_h; /**< \see align_w */
d82 1
a82 10
   /**
    * Level zero image dimensions.  These dimensions correspond to the
    * physical layout of data in memory.  Accordingly, they account for the
    * extra width, height, and or depth that must be allocated in order to
    * accommodate multisample formats, and they account for the extra factor
    * of 6 in depth that must be allocated in order to accommodate cubemap
    * textures.
    */
   GLuint physical_width0, physical_height0, physical_depth0;

d84 1
a84 26
   GLuint num_samples;
   bool compressed;

   /**
    * Level zero image dimensions.  These dimensions correspond to the
    * logical width, height, and depth of the region as seen by client code.
    * Accordingly, they do not account for the extra width, height, and/or
    * depth that must be allocated in order to accommodate multisample
    * formats, nor do they account for the extra factor of 6 in depth that
    * must be allocated in order to accommodate cubemap textures.
    */
   uint32_t logical_width0, logical_height0, logical_depth0;

   /**
    * For 1D array, 2D array, cube, and 2D multisampled surfaces on Gen7: true
    * if the surface only contains LOD 0, and hence no space is for LOD's
    * other than 0 in between array slices.
    *
    * Corresponds to the surface_array_spacing bit in gen7_surface_state.
    */
   bool array_spacing_lod0;

   /**
    * MSAA layout used by this buffer.
    */
   enum intel_msaa_layout msaa_layout;
d87 3
a89 2
    */
   GLuint total_width;
d91 1
a91 6

   /* The 3DSTATE_CLEAR_PARAMS value associated with the last depth clear to
    * this depth mipmap tree, if any.
    */
   uint32_t depth_clear_value;

a99 107
   /* Offset into region bo where miptree starts:
    */
   uint32_t offset;

   /**
    * \brief Singlesample miptree.
    *
    * This is used under two cases.
    *
    * --- Case 1: As persistent singlesample storage for multisample window
    *  system front and back buffers ---
    *
    * Suppose that the window system FBO was created with a multisample
    * config.  Let `back_irb` be the `intel_renderbuffer` for the FBO's back
    * buffer. Then `back_irb` contains two miptrees: a parent multisample
    * miptree (back_irb->mt) and a child singlesample miptree
    * (back_irb->mt->singlesample_mt).  The DRM buffer shared with DRI2
    * belongs to `back_irb->mt->singlesample_mt` and contains singlesample
    * data.  The singlesample miptree is created at the same time as and
    * persists for the lifetime of its parent multisample miptree.
    *
    * When access to the singlesample data is needed, such as at
    * eglSwapBuffers and glReadPixels, an automatic downsample occurs from
    * `back_rb->mt` to `back_rb->mt->singlesample_mt` when necessary.
    *
    * This description of the back buffer applies analogously to the front
    * buffer.
    *
    *
    * --- Case 2: As temporary singlesample storage for mapping multisample
    *  miptrees ---
    *
    * Suppose the intel_miptree_map is called on a multisample miptree, `mt`,
    * for which case 1 does not apply (that is, `mt` does not belong to
    * a front or back buffer).  Then `mt->singlesample_mt` is null at the
    * start of the call. intel_miptree_map will create a temporary
    * singlesample miptree, store it at `mt->singlesample_mt`, downsample from
    * `mt` to `mt->singlesample_mt` if necessary, then map
    * `mt->singlesample_mt`. The temporary miptree is later deleted during
    * intel_miptree_unmap.
    */
   struct intel_mipmap_tree *singlesample_mt;

   /**
    * \brief A downsample is needed from this miptree to singlesample_mt.
    */
   bool need_downsample;

   /**
    * \brief HiZ miptree
    *
    * The hiz miptree contains the miptree's hiz buffer. To allocate the hiz
    * miptree, use intel_miptree_alloc_hiz().
    *
    * To determine if hiz is enabled, do not check this pointer. Instead, use
    * intel_miptree_slice_has_hiz().
    */
   struct intel_mipmap_tree *hiz_mt;

   /**
    * \brief Map of miptree slices to needed resolves.
    *
    * This is used only when the miptree has a child HiZ miptree.
    *
    * Let \c mt be a depth miptree with HiZ enabled. Then the resolve map is
    * \c mt->hiz_map. The resolve map of the child HiZ miptree, \c
    * mt->hiz_mt->hiz_map, is unused.
    */
   struct intel_resolve_map hiz_map;

   /**
    * \brief Stencil miptree for depthstencil textures.
    *
    * This miptree is used for depthstencil textures and renderbuffers that
    * require separate stencil.  It always has the true copy of the stencil
    * bits, regardless of mt->format.
    *
    * \see intel_miptree_map_depthstencil()
    * \see intel_miptree_unmap_depthstencil()
    */
   struct intel_mipmap_tree *stencil_mt;

   /**
    * \brief MCS miptree.
    *
    * This miptree contains the "multisample control surface", which stores
    * the necessary information to implement compressed MSAA
    * (INTEL_MSAA_FORMAT_CMS) and "fast color clear" behaviour on Gen7+.
    *
    * NULL if no MCS miptree is in use for this surface.
    */
   struct intel_mipmap_tree *mcs_mt;

   /**
    * MCS state for this buffer.
    */
   enum intel_mcs_state mcs_state;

   /**
    * The SURFACE_STATE bits associated with the last fast color clear to this
    * color mipmap tree, if any.
    *
    * This value will only ever contain ones in bits 28-31, so it is safe to
    * OR into dword 7 of SURFACE_STATE.
    */
   uint32_t fast_clear_color_value;

a104 5
enum intel_miptree_tiling_mode {
   INTEL_MIPTREE_TILING_ANY,
   INTEL_MIPTREE_TILING_Y,
   INTEL_MIPTREE_TILING_NONE,
};
a105 81
bool
intel_is_non_msrt_mcs_buffer_supported(struct brw_context *brw,
                                       struct intel_mipmap_tree *mt);

void
intel_get_non_msrt_mcs_alignment(struct brw_context *brw,
                                 struct intel_mipmap_tree *mt,
                                 unsigned *width_px, unsigned *height);

bool
intel_miptree_alloc_non_msrt_mcs(struct brw_context *brw,
                                 struct intel_mipmap_tree *mt);

struct intel_mipmap_tree *intel_miptree_create(struct brw_context *brw,
                                               GLenum target,
					       gl_format format,
                                               GLuint first_level,
                                               GLuint last_level,
                                               GLuint width0,
                                               GLuint height0,
                                               GLuint depth0,
					       bool expect_accelerated_upload,
                                               GLuint num_samples,
                                               enum intel_miptree_tiling_mode);

struct intel_mipmap_tree *
intel_miptree_create_layout(struct brw_context *brw,
                            GLenum target,
                            gl_format format,
                            GLuint first_level,
                            GLuint last_level,
                            GLuint width0,
                            GLuint height0,
                            GLuint depth0,
                            bool for_bo,
                            GLuint num_samples);

struct intel_mipmap_tree *
intel_miptree_create_for_bo(struct brw_context *brw,
                            drm_intel_bo *bo,
                            gl_format format,
                            uint32_t offset,
                            uint32_t width,
                            uint32_t height,
                            int pitch,
                            uint32_t tiling);

struct intel_mipmap_tree*
intel_miptree_create_for_dri2_buffer(struct brw_context *brw,
                                     unsigned dri_attachment,
                                     gl_format format,
                                     uint32_t num_samples,
                                     struct intel_region *region);

/**
 * Create a miptree appropriate as the storage for a non-texture renderbuffer.
 * The miptree has the following properties:
 *     - The target is GL_TEXTURE_2D.
 *     - There are no levels other than the base level 0.
 *     - Depth is 1.
 */
struct intel_mipmap_tree*
intel_miptree_create_for_renderbuffer(struct brw_context *brw,
                                      gl_format format,
                                      uint32_t width,
                                      uint32_t height,
                                      uint32_t num_samples);

/** \brief Assert that the level and layer are valid for the miptree. */
static inline void
intel_miptree_check_level_layer(struct intel_mipmap_tree *mt,
                                uint32_t level,
                                uint32_t layer)
{
   assert(level >= mt->first_level);
   assert(level <= mt->last_level);
   assert(layer < mt->level[level].depth);
}

void intel_miptree_reference(struct intel_mipmap_tree **dst,
                             struct intel_mipmap_tree *src);
d107 21
a127 1
void intel_miptree_release(struct intel_mipmap_tree **mt);
d129 2
a130 1
/* Check if an image fits an existing mipmap tree layout
d132 2
a133 2
bool intel_miptree_match_image(struct intel_mipmap_tree *mt,
                                    struct gl_texture_image *image);
a134 14
void
intel_miptree_get_image_offset(struct intel_mipmap_tree *mt,
			       GLuint level, GLuint slice,
			       GLuint *x, GLuint *y);

void
intel_miptree_get_dimensions_for_image(struct gl_texture_image *image,
                                       int *width, int *height, int *depth);

uint32_t
intel_miptree_get_tile_offsets(struct intel_mipmap_tree *mt,
                               GLuint level, GLuint slice,
                               uint32_t *tile_x,
                               uint32_t *tile_y);
d137 4
a140 3
                                  GLuint level,
                                  GLuint x, GLuint y,
                                  GLuint w, GLuint h, GLuint d);
d143 20
a162 20
                                    GLuint level,
                                    GLuint img, GLuint x, GLuint y);

void
intel_miptree_copy_teximage(struct brw_context *brw,
                            struct intel_texture_image *intelImage,
                            struct intel_mipmap_tree *dst_mt, bool invalidate);

bool
intel_miptree_alloc_mcs(struct brw_context *brw,
                        struct intel_mipmap_tree *mt,
                        GLuint num_samples);

/**
 * \name Miptree HiZ functions
 * \{
 *
 * It is safe to call the "slice_set_need_resolve" and "slice_resolve"
 * functions on a miptree without HiZ. In that case, each function is a no-op.
 */
a163 41
/**
 * \brief Allocate the miptree's embedded HiZ miptree.
 * \see intel_mipmap_tree:hiz_mt
 * \return false if allocation failed
 */

bool
intel_miptree_alloc_hiz(struct brw_context *brw,
			struct intel_mipmap_tree *mt);

bool
intel_miptree_slice_has_hiz(struct intel_mipmap_tree *mt,
                            uint32_t level,
                            uint32_t layer);

void
intel_miptree_slice_set_needs_hiz_resolve(struct intel_mipmap_tree *mt,
                                          uint32_t level,
					  uint32_t depth);
void
intel_miptree_slice_set_needs_depth_resolve(struct intel_mipmap_tree *mt,
                                            uint32_t level,
					    uint32_t depth);

/**
 * \return false if no resolve was needed
 */
bool
intel_miptree_slice_resolve_hiz(struct brw_context *brw,
				struct intel_mipmap_tree *mt,
				unsigned int level,
				unsigned int depth);

/**
 * \return false if no resolve was needed
 */
bool
intel_miptree_slice_resolve_depth(struct brw_context *brw,
				  struct intel_mipmap_tree *mt,
				  unsigned int level,
				  unsigned int depth);
a164 81
/**
 * \return false if no resolve was needed
 */
bool
intel_miptree_all_slices_resolve_hiz(struct brw_context *brw,
				     struct intel_mipmap_tree *mt);

/**
 * \return false if no resolve was needed
 */
bool
intel_miptree_all_slices_resolve_depth(struct brw_context *brw,
				       struct intel_mipmap_tree *mt);

/**\}*/

/**
 * Update the fast clear state for a miptree to indicate that it has been used
 * for rendering.
 */
static inline void
intel_miptree_used_for_rendering(struct intel_mipmap_tree *mt)
{
   /* If the buffer was previously in fast clear state, change it to
    * unresolved state, since it won't be guaranteed to be clear after
    * rendering occurs.
    */
   if (mt->mcs_state == INTEL_MCS_STATE_CLEAR)
      mt->mcs_state = INTEL_MCS_STATE_UNRESOLVED;
}

void
intel_miptree_resolve_color(struct brw_context *brw,
                            struct intel_mipmap_tree *mt);

void
intel_miptree_make_shareable(struct brw_context *brw,
                             struct intel_mipmap_tree *mt);

void
intel_miptree_downsample(struct brw_context *brw,
                         struct intel_mipmap_tree *mt);

void
intel_miptree_upsample(struct brw_context *brw,
                       struct intel_mipmap_tree *mt);

void brw_miptree_layout(struct brw_context *brw, struct intel_mipmap_tree *mt);

void *intel_miptree_map_raw(struct brw_context *brw,
                            struct intel_mipmap_tree *mt);

void intel_miptree_unmap_raw(struct brw_context *brw,
                             struct intel_mipmap_tree *mt);

void
intel_miptree_map(struct brw_context *brw,
		  struct intel_mipmap_tree *mt,
		  unsigned int level,
		  unsigned int slice,
		  unsigned int x,
		  unsigned int y,
		  unsigned int w,
		  unsigned int h,
		  GLbitfield mode,
		  void **out_ptr,
		  int *out_stride);

void
intel_miptree_unmap(struct brw_context *brw,
		    struct intel_mipmap_tree *mt,
		    unsigned int level,
		    unsigned int slice);

void
intel_hiz_exec(struct brw_context *brw, struct intel_mipmap_tree *mt,
	       unsigned int level, unsigned int layer, enum gen6_hiz_op op);

#ifdef __cplusplus
}
#endif
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d2 2
a3 2
 *
 * Copyright 2006 VMware, Inc.
d5 1
a5 1
 *
d13 1
a13 1
 *
d17 1
a17 1
 *
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
d25 1
a25 1
 *
a27 18
/** @@file intel_mipmap_tree.h
 *
 * This file defines the structure that wraps a BO and describes how the
 * mipmap levels and slices of a texture are laid out.
 *
 * The hardware has a fixed layout of a texture depending on parameters such
 * as the target/type (2D, 3D, CUBE), width, height, pitch, and number of
 * mipmap levels.  The individual level/layer slices are each 2D rectangles of
 * pixels at some x/y offset from the start of the drm_intel_bo.
 *
 * Original OpenGL allowed texture miplevels to be specified in arbitrary
 * order, and a texture may change size over time.  Thus, each
 * intel_texture_image has a reference to a miptree that contains the pixel
 * data sized appropriately for it, which will later be referenced by/copied
 * to the intel_texture_object at draw time (intel_finalize_mipmap_tree()) so
 * that there's a single miptree for the complete texture.
 */

d33 1
a33 2
#include "main/mtypes.h"
#include "intel_bufmgr.h"
a34 1
#include <GL/internal/dri_interface.h>
d40 25
a64 2
struct brw_context;
struct intel_renderbuffer;
d93 6
d102 1
a102 1
 * Describes the location of each texture image within a miptree.
d110 2
a122 2
    *    - Additionally, for UMS and CMS miptrees, depth is multiplied by
    *      sample count.
d205 2
a206 2
 * Enum for keeping track of the fast clear state of a buffer associated with
 * a miptree.
d214 2
a215 2
 * This enum keeps track of the driver's knowledge of pending fast clears in
 * the MCS buffer.
d219 1
a219 1
enum intel_fast_clear_state
d225 6
a230 1
   INTEL_FAST_CLEAR_STATE_NO_MCS,
a240 3
    *
    * Since there is no such thing as a "fast color clear resolve" for MSAA
    * buffers, an MSAA buffer will never be in this state.
d242 1
a242 1
   INTEL_FAST_CLEAR_STATE_RESOLVED,
d250 2
a251 2
    * If a single-sample buffer is in this state, a render target resolve must
    * be performed before it can be used for purposes other than rendering.
d253 1
a253 1
   INTEL_FAST_CLEAR_STATE_UNRESOLVED,
d260 2
a261 2
    * If a single-sample buffer is in this state, a render target resolve must
    * be performed before it can be used for purposes other than rendering.
d266 1
a266 1
   INTEL_FAST_CLEAR_STATE_CLEAR,
a270 7
   /** Buffer object containing the pixel data. */
   drm_intel_bo *bo;

   uint32_t pitch; /**< pitch in bytes. */

   uint32_t tiling; /**< One of the I915_TILING_* flags */

d282 3
a284 3
    * MESA_FORMAT_Z32_FLOAT_S8X24_UINT, then mt->format will be
    * MESA_FORMAT_Z_FLOAT32, otherwise for MESA_FORMAT_Z24_UNORM_S8_UINT objects it will be
    * MESA_FORMAT_Z24_UNORM_X8_UINT.
d287 1
a287 1
    * formats if the hardware lacks support for ETC1/ETC2. See @@ref etc_format.
d289 1
a289 1
   mesa_format format;
d292 1
a292 1
   mesa_format etc_format;
d314 1
a314 1
   GLuint cpp; /**< bytes per pixel */
d320 1
a320 1
    * logical width, height, and depth of the texture as seen by client code.
a337 8
    * The distance in rows between array slices in an uncompressed surface.
    *
    * For compressed surfaces, slices are stored closer together physically;
    * the real distance is (qpitch / block height).
    */
   uint32_t qpitch;

   /**
d356 5
a360 1
   /* Offset into bo where miptree starts:
d365 44
d454 1
a454 1
    * Fast clear state for this buffer.
d456 1
a456 1
   enum intel_fast_clear_state fast_clear_state;
d493 1
a493 1
					       mesa_format format,
d506 1
a506 1
                            mesa_format format,
d518 1
a518 1
                            mesa_format format,
d522 2
a523 1
                            int pitch);
d525 6
a530 6
void
intel_update_winsys_renderbuffer_miptree(struct brw_context *intel,
                                         struct intel_renderbuffer *irb,
                                         drm_intel_bo *bo,
                                         uint32_t width, uint32_t height,
                                         uint32_t pitch);
d541 1
a541 1
                                      mesa_format format,
a545 6
mesa_format
intel_depth_format_for_depthstencil_format(mesa_format format);

mesa_format
intel_lower_compressed_format(struct brw_context *brw, mesa_format format);

d568 1
a568 1
intel_miptree_get_image_offset(const struct intel_mipmap_tree *mt,
a575 5
void
intel_miptree_get_tile_masks(const struct intel_mipmap_tree *mt,
                             uint32_t *mask_x, uint32_t *mask_y,
                             bool map_stencil_as_y_tiled);

d577 1
a577 1
intel_miptree_get_tile_offsets(const struct intel_mipmap_tree *mt,
a580 4
uint32_t
intel_miptree_get_aligned_offset(const struct intel_mipmap_tree *mt,
                                 uint32_t x, uint32_t y,
                                 bool map_stencil_as_y_tiled);
d584 2
a585 1
                                  GLuint x, GLuint y, GLuint d);
a632 4
void
intel_miptree_set_all_slices_need_depth_resolve(struct intel_mipmap_tree *mt,
                                                uint32_t level);

d678 2
a679 2
   if (mt->fast_clear_state == INTEL_FAST_CLEAR_STATE_CLEAR)
      mt->fast_clear_state = INTEL_FAST_CLEAR_STATE_UNRESOLVED;
d691 6
a696 3
intel_miptree_updownsample(struct brw_context *brw,
                           struct intel_mipmap_tree *src,
                           struct intel_mipmap_tree *dst);
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a117 9
    * \brief Is HiZ enabled for this level?
    *
    * If \c mt->level[l].has_hiz is set, then (1) \c mt->hiz_mt has been
    * allocated and (2) the HiZ memory for the slices in this level reside at
    * \c mt->hiz_mt->level[l].
    */
   bool has_hiz;

   /**
d146 9
a257 52
enum miptree_array_layout {
   /* Each array slice contains all miplevels packed together.
    *
    * Gen hardware usually wants multilevel miptrees configured this way.
    *
    * A 2D Array texture with 2 slices and multiple LODs using
    * ALL_LOD_IN_EACH_SLICE would look somewhat like this:
    *
    *   +----------+
    *   |          |
    *   |          |
    *   +----------+
    *   +---+ +-+
    *   |   | +-+
    *   +---+ *
    *   +----------+
    *   |          |
    *   |          |
    *   +----------+
    *   +---+ +-+
    *   |   | +-+
    *   +---+ *
    */
   ALL_LOD_IN_EACH_SLICE,

   /* Each LOD contains all slices of that LOD packed together.
    *
    * In some situations, Gen7+ hardware can use the array_spacing_lod0
    * feature to save space when the surface only contains LOD 0.
    *
    * Gen6 uses this for separate stencil and hiz since gen6 does not support
    * multiple LODs for separate stencil and hiz.
    *
    * A 2D Array texture with 2 slices and multiple LODs using
    * ALL_SLICES_AT_EACH_LOD would look somewhat like this:
    *
    *   +----------+
    *   |          |
    *   |          |
    *   +----------+
    *   |          |
    *   |          |
    *   +----------+
    *   +---+ +-+
    *   |   | +-+
    *   +---+ +-+
    *   |   | :
    *   +---+
    */
   ALL_SLICES_AT_EACH_LOD,
};

d325 5
a329 2
    * Indicates if we use the standard miptree layout (ALL_LOD_IN_EACH_SLICE),
    * or if we tightly pack array slices at each LOD (ALL_SLICES_AT_EACH_LOD).
d331 1
a331 1
   enum miptree_array_layout array_layout;
d384 1
a384 1
   struct exec_list hiz_map; /* List of intel_resolve_map. */
d457 1
a457 2
                                               enum intel_miptree_tiling_mode,
                                               bool force_all_slices_at_each_lod);
d469 1
a469 2
                            GLuint num_samples,
                            bool force_all_slices_at_each_lod);
d589 3
a591 1
intel_miptree_level_has_hiz(struct intel_mipmap_tree *mt, uint32_t level);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d118 9
a154 9

      /**
       * \brief Is HiZ enabled for this slice?
       *
       * If \c mt->level[l].slice[s].has_hiz is set, then (1) \c mt->hiz_mt
       * has been allocated and (2) the HiZ memory corresponding to this slice
       * resides at \c mt->hiz_mt->level[l].slice[s].
       */
      bool has_hiz;
d258 52
d377 2
a378 5
    * For 1D array, 2D array, cube, and 2D multisampled surfaces on Gen7: true
    * if the surface only contains LOD 0, and hence no space is for LOD's
    * other than 0 in between array slices.
    *
    * Corresponds to the surface_array_spacing bit in gen7_surface_state.
d380 1
a380 1
   bool array_spacing_lod0;
d433 1
a433 1
   struct intel_resolve_map hiz_map;
d506 2
a507 1
                                               enum intel_miptree_tiling_mode);
d519 2
a520 1
                            GLuint num_samples);
d640 1
a640 3
intel_miptree_slice_has_hiz(struct intel_mipmap_tree *mt,
                            uint32_t level,
                            uint32_t layer);
@


