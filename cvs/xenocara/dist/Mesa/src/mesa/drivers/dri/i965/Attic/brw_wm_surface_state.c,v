head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.8
	v10_4_3:1.1.1.7
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.11.24.06.19.52;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2013.09.05.14.04.23;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.15;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.50;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.50;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.17;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.37;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.15.42;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.11.24.06.00.39;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.52;	author jsg;	state Exp;
branches;
next	1.1.1.7;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.7
date	2015.01.25.14.11.50;	author jsg;	state Exp;
branches;
next	1.1.1.8;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.8
date	2015.02.20.22.48.55;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics to
 develop this 3D driver.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */


#include "main/context.h"
#include "main/blend.h"
#include "main/mtypes.h"
#include "main/samplerobj.h"
#include "program/prog_parameter.h"

#include "intel_mipmap_tree.h"
#include "intel_batchbuffer.h"
#include "intel_tex.h"
#include "intel_fbo.h"
#include "intel_buffer_objects.h"

#include "brw_context.h"
#include "brw_state.h"
#include "brw_defines.h"
#include "brw_wm.h"

GLuint
translate_tex_target(GLenum target)
{
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_TEXTURE_1D_ARRAY_EXT:
      return BRW_SURFACE_1D;

   case GL_TEXTURE_RECTANGLE_NV:
      return BRW_SURFACE_2D;

   case GL_TEXTURE_2D:
   case GL_TEXTURE_2D_ARRAY_EXT:
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
      return BRW_SURFACE_2D;

   case GL_TEXTURE_3D:
      return BRW_SURFACE_3D;

   case GL_TEXTURE_CUBE_MAP:
   case GL_TEXTURE_CUBE_MAP_ARRAY:
      return BRW_SURFACE_CUBE;

   default:
      assert(0);
      return 0;
   }
}

uint32_t
brw_get_surface_tiling_bits(uint32_t tiling)
{
   switch (tiling) {
   case I915_TILING_X:
      return BRW_SURFACE_TILED;
   case I915_TILING_Y:
      return BRW_SURFACE_TILED | BRW_SURFACE_TILED_Y;
   default:
      return 0;
   }
}


uint32_t
brw_get_surface_num_multisamples(unsigned num_samples)
{
   if (num_samples > 1)
      return BRW_SURFACE_MULTISAMPLECOUNT_4;
   else
      return BRW_SURFACE_MULTISAMPLECOUNT_1;
}

void
brw_configure_w_tiled(const struct intel_mipmap_tree *mt,
                      bool is_render_target,
                      unsigned *width, unsigned *height,
                      unsigned *pitch, uint32_t *tiling, unsigned *format)
{
   static const unsigned halign_stencil = 8;

   /* In Y-tiling row is twice as wide as in W-tiling, and subsequently
    * there are half as many rows.
    * In addition, mip-levels are accessed manually by the program and
    * therefore the surface is setup to cover all the mip-levels for one slice.
    * (Hardware is still used to access individual slices).
    */
   *tiling = I915_TILING_Y;
   *pitch = mt->pitch * 2;
   *width = ALIGN(mt->total_width, halign_stencil) * 2;
   *height = (mt->total_height / mt->physical_depth0) / 2;

   if (is_render_target) {
      *format = BRW_SURFACEFORMAT_R8_UINT;
   }
}


/**
 * Compute the combination of DEPTH_TEXTURE_MODE and EXT_texture_swizzle
 * swizzling.
 */
int
brw_get_texture_swizzle(const struct gl_context *ctx,
                        const struct gl_texture_object *t)
{
   const struct gl_texture_image *img = t->Image[0][t->BaseLevel];

   int swizzles[SWIZZLE_NIL + 1] = {
      SWIZZLE_X,
      SWIZZLE_Y,
      SWIZZLE_Z,
      SWIZZLE_W,
      SWIZZLE_ZERO,
      SWIZZLE_ONE,
      SWIZZLE_NIL
   };

   if (img->_BaseFormat == GL_DEPTH_COMPONENT ||
       img->_BaseFormat == GL_DEPTH_STENCIL) {
      GLenum depth_mode = t->DepthMode;

      /* In ES 3.0, DEPTH_TEXTURE_MODE is expected to be GL_RED for textures
       * with depth component data specified with a sized internal format.
       * Otherwise, it's left at the old default, GL_LUMINANCE.
       */
      if (_mesa_is_gles3(ctx) &&
          img->InternalFormat != GL_DEPTH_COMPONENT &&
          img->InternalFormat != GL_DEPTH_STENCIL) {
         depth_mode = GL_RED;
      }

      switch (depth_mode) {
      case GL_ALPHA:
         swizzles[0] = SWIZZLE_ZERO;
         swizzles[1] = SWIZZLE_ZERO;
         swizzles[2] = SWIZZLE_ZERO;
         swizzles[3] = SWIZZLE_X;
         break;
      case GL_LUMINANCE:
         swizzles[0] = SWIZZLE_X;
         swizzles[1] = SWIZZLE_X;
         swizzles[2] = SWIZZLE_X;
         swizzles[3] = SWIZZLE_ONE;
         break;
      case GL_INTENSITY:
         swizzles[0] = SWIZZLE_X;
         swizzles[1] = SWIZZLE_X;
         swizzles[2] = SWIZZLE_X;
         swizzles[3] = SWIZZLE_X;
         break;
      case GL_RED:
         swizzles[0] = SWIZZLE_X;
         swizzles[1] = SWIZZLE_ZERO;
         swizzles[2] = SWIZZLE_ZERO;
         swizzles[3] = SWIZZLE_ONE;
         break;
      }
   }

   /* If the texture's format is alpha-only, force R, G, and B to
    * 0.0. Similarly, if the texture's format has no alpha channel,
    * force the alpha value read to 1.0. This allows for the
    * implementation to use an RGBA texture for any of these formats
    * without leaking any unexpected values.
    */
   switch (img->_BaseFormat) {
   case GL_ALPHA:
      swizzles[0] = SWIZZLE_ZERO;
      swizzles[1] = SWIZZLE_ZERO;
      swizzles[2] = SWIZZLE_ZERO;
      break;
   case GL_RED:
   case GL_RG:
   case GL_RGB:
      if (_mesa_get_format_bits(img->TexFormat, GL_ALPHA_BITS) > 0)
         swizzles[3] = SWIZZLE_ONE;
      break;
   }

   return MAKE_SWIZZLE4(swizzles[GET_SWZ(t->_Swizzle, 0)],
                        swizzles[GET_SWZ(t->_Swizzle, 1)],
                        swizzles[GET_SWZ(t->_Swizzle, 2)],
                        swizzles[GET_SWZ(t->_Swizzle, 3)]);
}

static void
gen4_emit_buffer_surface_state(struct brw_context *brw,
                               uint32_t *out_offset,
                               drm_intel_bo *bo,
                               unsigned buffer_offset,
                               unsigned surface_format,
                               unsigned buffer_size,
                               unsigned pitch,
                               unsigned mocs,
                               bool rw)
{
   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
                                    6 * 4, 32, out_offset);
   memset(surf, 0, 6 * 4);

   surf[0] = BRW_SURFACE_BUFFER << BRW_SURFACE_TYPE_SHIFT |
             surface_format << BRW_SURFACE_FORMAT_SHIFT |
             (brw->gen >= 6 ? BRW_SURFACE_RC_READ_WRITE : 0);
   surf[1] = (bo ? bo->offset64 : 0) + buffer_offset; /* reloc */
   surf[2] = (buffer_size & 0x7f) << BRW_SURFACE_WIDTH_SHIFT |
             ((buffer_size >> 7) & 0x1fff) << BRW_SURFACE_HEIGHT_SHIFT;
   surf[3] = ((buffer_size >> 20) & 0x7f) << BRW_SURFACE_DEPTH_SHIFT |
             (pitch - 1) << BRW_SURFACE_PITCH_SHIFT;

   /* Emit relocation to surface contents.  The 965 PRM, Volume 4, section
    * 5.1.2 "Data Cache" says: "the data cache does not exist as a separate
    * physical cache.  It is mapped in hardware to the sampler cache."
    */
   if (bo) {
      drm_intel_bo_emit_reloc(brw->batch.bo, *out_offset + 4,
                              bo, buffer_offset,
                              I915_GEM_DOMAIN_SAMPLER,
                              (rw ? I915_GEM_DOMAIN_SAMPLER : 0));
   }
}

void
brw_update_buffer_texture_surface(struct gl_context *ctx,
                                  unsigned unit,
                                  uint32_t *surf_offset)
{
   struct brw_context *brw = brw_context(ctx);
   struct gl_texture_object *tObj = ctx->Texture.Unit[unit]._Current;
   struct intel_buffer_object *intel_obj =
      intel_buffer_object(tObj->BufferObject);
   uint32_t size = tObj->BufferSize;
   drm_intel_bo *bo = NULL;
   mesa_format format = tObj->_BufferObjectFormat;
   uint32_t brw_format = brw_format_for_mesa_format(format);
   int texel_size = _mesa_get_format_bytes(format);

   if (intel_obj) {
      size = MIN2(size, intel_obj->Base.Size);
      bo = intel_bufferobj_buffer(brw, intel_obj, tObj->BufferOffset, size);
   }

   if (brw_format == 0 && format != MESA_FORMAT_RGBA_FLOAT32) {
      _mesa_problem(NULL, "bad format %s for texture buffer\n",
		    _mesa_get_format_name(format));
   }

   brw->vtbl.emit_buffer_surface_state(brw, surf_offset, bo,
                                       tObj->BufferOffset,
                                       brw_format,
                                       size / texel_size,
                                       texel_size,
                                       0, /* mocs */
                                       false /* rw */);
}

static void
brw_update_texture_surface(struct gl_context *ctx,
                           unsigned unit,
                           uint32_t *surf_offset,
                           bool for_gather)
{
   struct brw_context *brw = brw_context(ctx);
   struct gl_texture_object *tObj = ctx->Texture.Unit[unit]._Current;
   struct intel_texture_object *intelObj = intel_texture_object(tObj);
   struct intel_mipmap_tree *mt = intelObj->mt;
   struct gl_sampler_object *sampler = _mesa_get_samplerobj(ctx, unit);
   uint32_t *surf;

   /* BRW_NEW_UNIFORM_BUFFER */
   if (tObj->Target == GL_TEXTURE_BUFFER) {
      brw_update_buffer_texture_surface(ctx, unit, surf_offset);
      return;
   }

   surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
			  6 * 4, 32, surf_offset);

   uint32_t tex_format = translate_tex_format(brw, mt->format,
                                              sampler->sRGBDecode);

   if (for_gather) {
      /* Sandybridge's gather4 message is broken for integer formats.
       * To work around this, we pretend the surface is UNORM for
       * 8 or 16-bit formats, and emit shader instructions to recover
       * the real INT/UINT value.  For 32-bit formats, we pretend
       * the surface is FLOAT, and simply reinterpret the resulting
       * bits.
       */
      switch (tex_format) {
      case BRW_SURFACEFORMAT_R8_SINT:
      case BRW_SURFACEFORMAT_R8_UINT:
         tex_format = BRW_SURFACEFORMAT_R8_UNORM;
         break;

      case BRW_SURFACEFORMAT_R16_SINT:
      case BRW_SURFACEFORMAT_R16_UINT:
         tex_format = BRW_SURFACEFORMAT_R16_UNORM;
         break;

      case BRW_SURFACEFORMAT_R32_SINT:
      case BRW_SURFACEFORMAT_R32_UINT:
         tex_format = BRW_SURFACEFORMAT_R32_FLOAT;
         break;

      default:
         break;
      }
   }

   surf[0] = (translate_tex_target(tObj->Target) << BRW_SURFACE_TYPE_SHIFT |
	      BRW_SURFACE_MIPMAPLAYOUT_BELOW << BRW_SURFACE_MIPLAYOUT_SHIFT |
	      BRW_SURFACE_CUBEFACE_ENABLES |
	      tex_format << BRW_SURFACE_FORMAT_SHIFT);

   surf[1] = mt->bo->offset64 + mt->offset; /* reloc */

   surf[2] = ((intelObj->_MaxLevel - tObj->BaseLevel) << BRW_SURFACE_LOD_SHIFT |
	      (mt->logical_width0 - 1) << BRW_SURFACE_WIDTH_SHIFT |
	      (mt->logical_height0 - 1) << BRW_SURFACE_HEIGHT_SHIFT);

   surf[3] = (brw_get_surface_tiling_bits(mt->tiling) |
	      (mt->logical_depth0 - 1) << BRW_SURFACE_DEPTH_SHIFT |
	      (mt->pitch - 1) << BRW_SURFACE_PITCH_SHIFT);

   surf[4] = (brw_get_surface_num_multisamples(mt->num_samples) |
              SET_FIELD(tObj->BaseLevel - mt->first_level, BRW_SURFACE_MIN_LOD));

   surf[5] = mt->align_h == 4 ? BRW_SURFACE_VERTICAL_ALIGN_ENABLE : 0;

   /* Emit relocation to surface contents */
   drm_intel_bo_emit_reloc(brw->batch.bo,
                           *surf_offset + 4,
                           mt->bo,
                           surf[1] - mt->bo->offset64,
                           I915_GEM_DOMAIN_SAMPLER, 0);
}

/**
 * Create the constant buffer surface.  Vertex/fragment shader constants will be
 * read from this buffer with Data Port Read instructions/messages.
 */
void
brw_create_constant_surface(struct brw_context *brw,
			    drm_intel_bo *bo,
			    uint32_t offset,
			    uint32_t size,
			    uint32_t *out_offset,
                            bool dword_pitch)
{
   uint32_t stride = dword_pitch ? 4 : 16;
   uint32_t elements = ALIGN(size, stride) / stride;

   brw->vtbl.emit_buffer_surface_state(brw, out_offset, bo, offset,
                                       BRW_SURFACEFORMAT_R32G32B32A32_FLOAT,
                                       elements, stride, 0, false);
}

/**
 * Set up a binding table entry for use by stream output logic (transform
 * feedback).
 *
 * buffer_size_minus_1 must me less than BRW_MAX_NUM_BUFFER_ENTRIES.
 */
void
brw_update_sol_surface(struct brw_context *brw,
                       struct gl_buffer_object *buffer_obj,
                       uint32_t *out_offset, unsigned num_vector_components,
                       unsigned stride_dwords, unsigned offset_dwords)
{
   struct intel_buffer_object *intel_bo = intel_buffer_object(buffer_obj);
   uint32_t offset_bytes = 4 * offset_dwords;
   drm_intel_bo *bo = intel_bufferobj_buffer(brw, intel_bo,
                                             offset_bytes,
                                             buffer_obj->Size - offset_bytes);
   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE, 6 * 4, 32,
                                    out_offset);
   uint32_t pitch_minus_1 = 4*stride_dwords - 1;
   size_t size_dwords = buffer_obj->Size / 4;
   uint32_t buffer_size_minus_1, width, height, depth, surface_format;

   /* FIXME: can we rely on core Mesa to ensure that the buffer isn't
    * too big to map using a single binding table entry?
    */
   assert((size_dwords - offset_dwords) / stride_dwords
          <= BRW_MAX_NUM_BUFFER_ENTRIES);

   if (size_dwords > offset_dwords + num_vector_components) {
      /* There is room for at least 1 transform feedback output in the buffer.
       * Compute the number of additional transform feedback outputs the
       * buffer has room for.
       */
      buffer_size_minus_1 =
         (size_dwords - offset_dwords - num_vector_components) / stride_dwords;
   } else {
      /* There isn't even room for a single transform feedback output in the
       * buffer.  We can't configure the binding table entry to prevent output
       * entirely; we'll have to rely on the geometry shader to detect
       * overflow.  But to minimize the damage in case of a bug, set up the
       * binding table entry to just allow a single output.
       */
      buffer_size_minus_1 = 0;
   }
   width = buffer_size_minus_1 & 0x7f;
   height = (buffer_size_minus_1 & 0xfff80) >> 7;
   depth = (buffer_size_minus_1 & 0x7f00000) >> 20;

   switch (num_vector_components) {
   case 1:
      surface_format = BRW_SURFACEFORMAT_R32_FLOAT;
      break;
   case 2:
      surface_format = BRW_SURFACEFORMAT_R32G32_FLOAT;
      break;
   case 3:
      surface_format = BRW_SURFACEFORMAT_R32G32B32_FLOAT;
      break;
   case 4:
      surface_format = BRW_SURFACEFORMAT_R32G32B32A32_FLOAT;
      break;
   default:
      assert(!"Invalid vector size for transform feedback output");
      surface_format = BRW_SURFACEFORMAT_R32_FLOAT;
      break;
   }

   surf[0] = BRW_SURFACE_BUFFER << BRW_SURFACE_TYPE_SHIFT |
      BRW_SURFACE_MIPMAPLAYOUT_BELOW << BRW_SURFACE_MIPLAYOUT_SHIFT |
      surface_format << BRW_SURFACE_FORMAT_SHIFT |
      BRW_SURFACE_RC_READ_WRITE;
   surf[1] = bo->offset64 + offset_bytes; /* reloc */
   surf[2] = (width << BRW_SURFACE_WIDTH_SHIFT |
	      height << BRW_SURFACE_HEIGHT_SHIFT);
   surf[3] = (depth << BRW_SURFACE_DEPTH_SHIFT |
              pitch_minus_1 << BRW_SURFACE_PITCH_SHIFT);
   surf[4] = 0;
   surf[5] = 0;

   /* Emit relocation to surface contents. */
   drm_intel_bo_emit_reloc(brw->batch.bo,
			   *out_offset + 4,
			   bo, offset_bytes,
			   I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER);
}

/* Creates a new WM constant buffer reflecting the current fragment program's
 * constants, if needed by the fragment program.
 *
 * Otherwise, constants go through the CURBEs using the brw_constant_buffer
 * state atom.
 */
static void
brw_upload_wm_pull_constants(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   /* BRW_NEW_FRAGMENT_PROGRAM */
   struct brw_fragment_program *fp =
      (struct brw_fragment_program *) brw->fragment_program;
   struct gl_program_parameter_list *params = fp->program.Base.Parameters;
   const int size = brw->wm.prog_data->base.nr_pull_params * sizeof(float);
   const int surf_index =
      brw->wm.prog_data->base.binding_table.pull_constants_start;
   unsigned int i;

   _mesa_load_state_parameters(ctx, params);

   /* CACHE_NEW_WM_PROG */
   if (brw->wm.prog_data->base.nr_pull_params == 0) {
      if (brw->wm.base.surf_offset[surf_index]) {
	 brw->wm.base.surf_offset[surf_index] = 0;
	 brw->state.dirty.brw |= BRW_NEW_SURFACES;
      }
      return;
   }

   /* _NEW_PROGRAM_CONSTANTS */
   drm_intel_bo *const_bo = NULL;
   uint32_t const_offset;
   float *constants = intel_upload_space(brw, size, 64,
                                         &const_bo, &const_offset);
   for (i = 0; i < brw->wm.prog_data->base.nr_pull_params; i++) {
      constants[i] = *brw->wm.prog_data->base.pull_param[i];
   }

   brw_create_constant_surface(brw, const_bo, const_offset, size,
                               &brw->wm.base.surf_offset[surf_index],
                               true);
   drm_intel_bo_unreference(const_bo);

   brw->state.dirty.brw |= BRW_NEW_SURFACES;
}

const struct brw_tracked_state brw_wm_pull_constants = {
   .dirty = {
      .mesa = (_NEW_PROGRAM_CONSTANTS),
      .brw = (BRW_NEW_BATCH | BRW_NEW_FRAGMENT_PROGRAM),
      .cache = CACHE_NEW_WM_PROG,
   },
   .emit = brw_upload_wm_pull_constants,
};

static void
brw_update_null_renderbuffer_surface(struct brw_context *brw, unsigned int unit)
{
   /* From the Sandy bridge PRM, Vol4 Part1 p71 (Surface Type: Programming
    * Notes):
    *
    *     A null surface will be used in instances where an actual surface is
    *     not bound. When a write message is generated to a null surface, no
    *     actual surface is written to. When a read message (including any
    *     sampling engine message) is generated to a null surface, the result
    *     is all zeros. Note that a null surface type is allowed to be used
    *     with all messages, even if it is not specificially indicated as
    *     supported. All of the remaining fields in surface state are ignored
    *     for null surfaces, with the following exceptions:
    *
    *     - [DevSNB+]: Width, Height, Depth, and LOD fields must match the
    *       depth buffer’s corresponding state for all render target surfaces,
    *       including null.
    *
    *     - Surface Format must be R8G8B8A8_UNORM.
    */
   struct gl_context *ctx = &brw->ctx;
   uint32_t *surf;
   unsigned surface_type = BRW_SURFACE_NULL;
   drm_intel_bo *bo = NULL;
   unsigned pitch_minus_1 = 0;
   uint32_t multisampling_state = 0;
   uint32_t surf_index =
      brw->wm.prog_data->binding_table.render_target_start + unit;

   /* _NEW_BUFFERS */
   const struct gl_framebuffer *fb = ctx->DrawBuffer;

   surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE, 6 * 4, 32,
                          &brw->wm.base.surf_offset[surf_index]);

   if (fb->Visual.samples > 1) {
      /* On Gen6, null render targets seem to cause GPU hangs when
       * multisampling.  So work around this problem by rendering into dummy
       * color buffer.
       *
       * To decrease the amount of memory needed by the workaround buffer, we
       * set its pitch to 128 bytes (the width of a Y tile).  This means that
       * the amount of memory needed for the workaround buffer is
       * (width_in_tiles + height_in_tiles - 1) tiles.
       *
       * Note that since the workaround buffer will be interpreted by the
       * hardware as an interleaved multisampled buffer, we need to compute
       * width_in_tiles and height_in_tiles by dividing the width and height
       * by 16 rather than the normal Y-tile size of 32.
       */
      unsigned width_in_tiles = ALIGN(fb->Width, 16) / 16;
      unsigned height_in_tiles = ALIGN(fb->Height, 16) / 16;
      unsigned size_needed = (width_in_tiles + height_in_tiles - 1) * 4096;
      brw_get_scratch_bo(brw, &brw->wm.multisampled_null_render_target_bo,
                         size_needed);
      bo = brw->wm.multisampled_null_render_target_bo;
      surface_type = BRW_SURFACE_2D;
      pitch_minus_1 = 127;
      multisampling_state =
         brw_get_surface_num_multisamples(fb->Visual.samples);
   }

   surf[0] = (surface_type << BRW_SURFACE_TYPE_SHIFT |
	      BRW_SURFACEFORMAT_B8G8R8A8_UNORM << BRW_SURFACE_FORMAT_SHIFT);
   if (brw->gen < 6) {
      surf[0] |= (1 << BRW_SURFACE_WRITEDISABLE_R_SHIFT |
		  1 << BRW_SURFACE_WRITEDISABLE_G_SHIFT |
		  1 << BRW_SURFACE_WRITEDISABLE_B_SHIFT |
		  1 << BRW_SURFACE_WRITEDISABLE_A_SHIFT);
   }
   surf[1] = bo ? bo->offset64 : 0;
   surf[2] = ((fb->Width - 1) << BRW_SURFACE_WIDTH_SHIFT |
              (fb->Height - 1) << BRW_SURFACE_HEIGHT_SHIFT);

   /* From Sandy bridge PRM, Vol4 Part1 p82 (Tiled Surface: Programming
    * Notes):
    *
    *     If Surface Type is SURFTYPE_NULL, this field must be TRUE
    */
   surf[3] = (BRW_SURFACE_TILED | BRW_SURFACE_TILED_Y |
              pitch_minus_1 << BRW_SURFACE_PITCH_SHIFT);
   surf[4] = multisampling_state;
   surf[5] = 0;

   if (bo) {
      drm_intel_bo_emit_reloc(brw->batch.bo,
                              brw->wm.base.surf_offset[surf_index] + 4,
                              bo, 0,
                              I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER);
   }
}

/**
 * Sets up a surface state structure to point at the given region.
 * While it is only used for the front/back buffer currently, it should be
 * usable for further buffers when doing ARB_draw_buffer support.
 */
static void
brw_update_renderbuffer_surface(struct brw_context *brw,
				struct gl_renderbuffer *rb,
				bool layered,
				unsigned int unit)
{
   struct gl_context *ctx = &brw->ctx;
   struct intel_renderbuffer *irb = intel_renderbuffer(rb);
   struct intel_mipmap_tree *mt = irb->mt;
   uint32_t *surf;
   uint32_t tile_x, tile_y;
   uint32_t format = 0;
   /* _NEW_BUFFERS */
   mesa_format rb_format = _mesa_get_render_format(ctx, intel_rb_format(irb));
   uint32_t surf_index =
      brw->wm.prog_data->binding_table.render_target_start + unit;

   assert(!layered);

   if (rb->TexImage && !brw->has_surface_tile_offset) {
      intel_renderbuffer_get_tile_offsets(irb, &tile_x, &tile_y);

      if (tile_x != 0 || tile_y != 0) {
	 /* Original gen4 hardware couldn't draw to a non-tile-aligned
	  * destination in a miptree unless you actually setup your renderbuffer
	  * as a miptree and used the fragile lod/array_index/etc. controls to
	  * select the image.  So, instead, we just make a new single-level
	  * miptree and render into that.
	  */
	 intel_renderbuffer_move_to_temp(brw, irb, false);
	 mt = irb->mt;
      }
   }

   intel_miptree_used_for_rendering(irb->mt);

   surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE, 6 * 4, 32,
                          &brw->wm.base.surf_offset[surf_index]);

   format = brw->render_target_format[rb_format];
   if (unlikely(!brw->format_supported_as_render_target[rb_format])) {
      _mesa_problem(ctx, "%s: renderbuffer format %s unsupported\n",
                    __FUNCTION__, _mesa_get_format_name(rb_format));
   }

   surf[0] = (BRW_SURFACE_2D << BRW_SURFACE_TYPE_SHIFT |
	      format << BRW_SURFACE_FORMAT_SHIFT);

   /* reloc */
   surf[1] = (intel_renderbuffer_get_tile_offsets(irb, &tile_x, &tile_y) +
	      mt->bo->offset64);

   surf[2] = ((rb->Width - 1) << BRW_SURFACE_WIDTH_SHIFT |
	      (rb->Height - 1) << BRW_SURFACE_HEIGHT_SHIFT);

   surf[3] = (brw_get_surface_tiling_bits(mt->tiling) |
	      (mt->pitch - 1) << BRW_SURFACE_PITCH_SHIFT);

   surf[4] = brw_get_surface_num_multisamples(mt->num_samples);

   assert(brw->has_surface_tile_offset || (tile_x == 0 && tile_y == 0));
   /* Note that the low bits of these fields are missing, so
    * there's the possibility of getting in trouble.
    */
   assert(tile_x % 4 == 0);
   assert(tile_y % 2 == 0);
   surf[5] = ((tile_x / 4) << BRW_SURFACE_X_OFFSET_SHIFT |
	      (tile_y / 2) << BRW_SURFACE_Y_OFFSET_SHIFT |
	      (mt->align_h == 4 ? BRW_SURFACE_VERTICAL_ALIGN_ENABLE : 0));

   if (brw->gen < 6) {
      /* _NEW_COLOR */
      if (!ctx->Color.ColorLogicOpEnabled &&
	  (ctx->Color.BlendEnabled & (1 << unit)))
	 surf[0] |= BRW_SURFACE_BLEND_ENABLED;

      if (!ctx->Color.ColorMask[unit][0])
	 surf[0] |= 1 << BRW_SURFACE_WRITEDISABLE_R_SHIFT;
      if (!ctx->Color.ColorMask[unit][1])
	 surf[0] |= 1 << BRW_SURFACE_WRITEDISABLE_G_SHIFT;
      if (!ctx->Color.ColorMask[unit][2])
	 surf[0] |= 1 << BRW_SURFACE_WRITEDISABLE_B_SHIFT;

      /* As mentioned above, disable writes to the alpha component when the
       * renderbuffer is XRGB.
       */
      if (ctx->DrawBuffer->Visual.alphaBits == 0 ||
	  !ctx->Color.ColorMask[unit][3]) {
	 surf[0] |= 1 << BRW_SURFACE_WRITEDISABLE_A_SHIFT;
      }
   }

   drm_intel_bo_emit_reloc(brw->batch.bo,
			   brw->wm.base.surf_offset[surf_index] + 4,
			   mt->bo,
			   surf[1] - mt->bo->offset64,
			   I915_GEM_DOMAIN_RENDER,
			   I915_GEM_DOMAIN_RENDER);
}

/**
 * Construct SURFACE_STATE objects for renderbuffers/draw buffers.
 */
static void
brw_update_renderbuffer_surfaces(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   GLuint i;

   /* _NEW_BUFFERS | _NEW_COLOR */
   /* Update surfaces for drawing buffers */
   if (ctx->DrawBuffer->_NumColorDrawBuffers >= 1) {
      for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++) {
	 if (intel_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[i])) {
	    brw->vtbl.update_renderbuffer_surface(brw, ctx->DrawBuffer->_ColorDrawBuffers[i],
                                                  ctx->DrawBuffer->MaxNumLayers > 0, i);
	 } else {
	    brw->vtbl.update_null_renderbuffer_surface(brw, i);
	 }
      }
   } else {
      brw->vtbl.update_null_renderbuffer_surface(brw, 0);
   }
   brw->state.dirty.brw |= BRW_NEW_SURFACES;
}

const struct brw_tracked_state brw_renderbuffer_surfaces = {
   .dirty = {
      .mesa = (_NEW_COLOR |
               _NEW_BUFFERS),
      .brw = BRW_NEW_BATCH,
      .cache = 0
   },
   .emit = brw_update_renderbuffer_surfaces,
};

const struct brw_tracked_state gen6_renderbuffer_surfaces = {
   .dirty = {
      .mesa = _NEW_BUFFERS,
      .brw = BRW_NEW_BATCH,
      .cache = 0
   },
   .emit = brw_update_renderbuffer_surfaces,
};


static void
update_stage_texture_surfaces(struct brw_context *brw,
                              const struct gl_program *prog,
                              struct brw_stage_state *stage_state,
                              bool for_gather)
{
   if (!prog)
      return;

   struct gl_context *ctx = &brw->ctx;

   uint32_t *surf_offset = stage_state->surf_offset;
   if (for_gather)
      surf_offset += stage_state->prog_data->binding_table.gather_texture_start;
   else
      surf_offset += stage_state->prog_data->binding_table.texture_start;

   unsigned num_samplers = _mesa_fls(prog->SamplersUsed);
   for (unsigned s = 0; s < num_samplers; s++) {
      surf_offset[s] = 0;

      if (prog->SamplersUsed & (1 << s)) {
         const unsigned unit = prog->SamplerUnits[s];

         /* _NEW_TEXTURE */
         if (ctx->Texture.Unit[unit]._Current) {
            brw->vtbl.update_texture_surface(ctx, unit, surf_offset + s, for_gather);
         }
      }
   }
}


/**
 * Construct SURFACE_STATE objects for enabled textures.
 */
static void
brw_update_texture_surfaces(struct brw_context *brw)
{
   /* BRW_NEW_VERTEX_PROGRAM */
   struct gl_program *vs = (struct gl_program *) brw->vertex_program;

   /* BRW_NEW_GEOMETRY_PROGRAM */
   struct gl_program *gs = (struct gl_program *) brw->geometry_program;

   /* BRW_NEW_FRAGMENT_PROGRAM */
   struct gl_program *fs = (struct gl_program *) brw->fragment_program;

   /* _NEW_TEXTURE */
   update_stage_texture_surfaces(brw, vs, &brw->vs.base, false);
   update_stage_texture_surfaces(brw, gs, &brw->gs.base, false);
   update_stage_texture_surfaces(brw, fs, &brw->wm.base, false);

   /* emit alternate set of surface state for gather. this
    * allows the surface format to be overriden for only the
    * gather4 messages. */
   if (brw->gen < 8) {
      if (vs && vs->UsesGather)
         update_stage_texture_surfaces(brw, vs, &brw->vs.base, true);
      if (gs && gs->UsesGather)
         update_stage_texture_surfaces(brw, gs, &brw->gs.base, true);
      if (fs && fs->UsesGather)
         update_stage_texture_surfaces(brw, fs, &brw->wm.base, true);
   }

   brw->state.dirty.brw |= BRW_NEW_SURFACES;
}

const struct brw_tracked_state brw_texture_surfaces = {
   .dirty = {
      .mesa = _NEW_TEXTURE,
      .brw = BRW_NEW_BATCH |
             BRW_NEW_UNIFORM_BUFFER |
             BRW_NEW_VERTEX_PROGRAM |
             BRW_NEW_GEOMETRY_PROGRAM |
             BRW_NEW_FRAGMENT_PROGRAM,
      .cache = 0
   },
   .emit = brw_update_texture_surfaces,
};

void
brw_upload_ubo_surfaces(struct brw_context *brw,
			struct gl_shader *shader,
                        struct brw_stage_state *stage_state,
                        struct brw_stage_prog_data *prog_data)
{
   struct gl_context *ctx = &brw->ctx;

   if (!shader)
      return;

   uint32_t *surf_offsets =
      &stage_state->surf_offset[prog_data->binding_table.ubo_start];

   for (int i = 0; i < shader->NumUniformBlocks; i++) {
      struct gl_uniform_buffer_binding *binding;
      struct intel_buffer_object *intel_bo;

      binding = &ctx->UniformBufferBindings[shader->UniformBlocks[i].Binding];
      intel_bo = intel_buffer_object(binding->BufferObject);
      drm_intel_bo *bo =
         intel_bufferobj_buffer(brw, intel_bo,
                                binding->Offset,
                                binding->BufferObject->Size - binding->Offset);

      /* Because behavior for referencing outside of the binding's size in the
       * glBindBufferRange case is undefined, we can just bind the whole buffer
       * glBindBufferBase wants and be a correct implementation.
       */
      brw_create_constant_surface(brw, bo, binding->Offset,
                                  bo->size - binding->Offset,
                                  &surf_offsets[i],
                                  shader->Stage == MESA_SHADER_FRAGMENT);
   }

   if (shader->NumUniformBlocks)
      brw->state.dirty.brw |= BRW_NEW_SURFACES;
}

static void
brw_upload_wm_ubo_surfaces(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   /* _NEW_PROGRAM */
   struct gl_shader_program *prog = ctx->_Shader->_CurrentFragmentProgram;

   if (!prog)
      return;

   /* CACHE_NEW_WM_PROG */
   brw_upload_ubo_surfaces(brw, prog->_LinkedShaders[MESA_SHADER_FRAGMENT],
                           &brw->wm.base, &brw->wm.prog_data->base);
}

const struct brw_tracked_state brw_wm_ubo_surfaces = {
   .dirty = {
      .mesa = _NEW_PROGRAM,
      .brw = BRW_NEW_BATCH | BRW_NEW_UNIFORM_BUFFER,
      .cache = CACHE_NEW_WM_PROG,
   },
   .emit = brw_upload_wm_ubo_surfaces,
};

void
brw_upload_abo_surfaces(struct brw_context *brw,
			struct gl_shader_program *prog,
                        struct brw_stage_state *stage_state,
                        struct brw_stage_prog_data *prog_data)
{
   struct gl_context *ctx = &brw->ctx;
   uint32_t *surf_offsets =
      &stage_state->surf_offset[prog_data->binding_table.abo_start];

   for (int i = 0; i < prog->NumAtomicBuffers; i++) {
      struct gl_atomic_buffer_binding *binding =
         &ctx->AtomicBufferBindings[prog->AtomicBuffers[i].Binding];
      struct intel_buffer_object *intel_bo =
         intel_buffer_object(binding->BufferObject);
      drm_intel_bo *bo = intel_bufferobj_buffer(
         brw, intel_bo, binding->Offset, intel_bo->Base.Size - binding->Offset);

      brw->vtbl.create_raw_surface(brw, bo, binding->Offset,
                                   bo->size - binding->Offset,
                                   &surf_offsets[i], true);
   }

   if (prog->NumUniformBlocks)
      brw->state.dirty.brw |= BRW_NEW_SURFACES;
}

static void
brw_upload_wm_abo_surfaces(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   /* _NEW_PROGRAM */
   struct gl_shader_program *prog = ctx->Shader._CurrentFragmentProgram;

   if (prog) {
      /* CACHE_NEW_WM_PROG */
      brw_upload_abo_surfaces(brw, prog, &brw->wm.base,
                              &brw->wm.prog_data->base);
   }
}

const struct brw_tracked_state brw_wm_abo_surfaces = {
   .dirty = {
      .mesa = _NEW_PROGRAM,
      .brw = BRW_NEW_BATCH | BRW_NEW_ATOMIC_BUFFER,
      .cache = CACHE_NEW_WM_PROG,
   },
   .emit = brw_upload_wm_abo_surfaces,
};

void
gen4_init_vtable_surface_functions(struct brw_context *brw)
{
   brw->vtbl.update_texture_surface = brw_update_texture_surface;
   brw->vtbl.update_renderbuffer_surface = brw_update_renderbuffer_surface;
   brw->vtbl.update_null_renderbuffer_surface =
      brw_update_null_renderbuffer_surface;
   brw->vtbl.emit_buffer_surface_state = gen4_emit_buffer_surface_state;
}
@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d76 2
a77 1
      unreachable("not reached");
d300 1
a300 1
   /* BRW_NEW_TEXTURE_BUFFER */
d393 1
a393 1
 * buffer_size_minus_1 must be less than BRW_MAX_NUM_BUFFER_ENTRIES.
d452 3
a454 1
      unreachable("Invalid vector size for transform feedback output");
d485 1
a485 1
   struct brw_stage_state *stage_state = &brw->wm.base;
d489 8
d498 7
a504 1
   struct brw_stage_prog_data *prog_data = &brw->wm.prog_data->base;
d507 14
a520 2
   brw_upload_pull_constants(brw, BRW_NEW_SURFACES, &fp->program.Base,
                             stage_state, prog_data, true);
a531 8
/**
 * Creates a null renderbuffer surface.
 *
 * This is used when the shader doesn't write to any color output.  An FB
 * write to target 0 will still be emitted, because that's how the thread is
 * terminated (and computed depth is returned), so we need to have the
 * hardware discard the target 0 color output..
 */
a558 1
   /* CACHE_NEW_WM_PROG */
a643 1
   /* CACHE_NEW_WM_PROG */
d761 1
a761 1
      .cache = CACHE_NEW_WM_PROG,
a787 2

   /* CACHE_NEW_*_PROG */
d848 1
a848 1
             BRW_NEW_TEXTURE_BUFFER |
d852 1
a852 1
      .cache = CACHE_NEW_VS_PROG | CACHE_NEW_GS_PROG | CACHE_NEW_WM_PROG,
d943 1
a943 1
   if (prog->NumAtomicBuffers)
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d76 1
a76 2
      assert(0);
      return 0;
d299 1
a299 1
   /* BRW_NEW_UNIFORM_BUFFER */
d392 1
a392 1
 * buffer_size_minus_1 must me less than BRW_MAX_NUM_BUFFER_ENTRIES.
d451 1
a451 3
      assert(!"Invalid vector size for transform feedback output");
      surface_format = BRW_SURFACEFORMAT_R32_FLOAT;
      break;
d482 1
a482 1
   struct gl_context *ctx = &brw->ctx;
a485 8
   struct gl_program_parameter_list *params = fp->program.Base.Parameters;
   const int size = brw->wm.prog_data->base.nr_pull_params * sizeof(float);
   const int surf_index =
      brw->wm.prog_data->base.binding_table.pull_constants_start;
   unsigned int i;

   _mesa_load_state_parameters(ctx, params);

d487 1
a487 7
   if (brw->wm.prog_data->base.nr_pull_params == 0) {
      if (brw->wm.base.surf_offset[surf_index]) {
	 brw->wm.base.surf_offset[surf_index] = 0;
	 brw->state.dirty.brw |= BRW_NEW_SURFACES;
      }
      return;
   }
d490 2
a491 14
   drm_intel_bo *const_bo = NULL;
   uint32_t const_offset;
   float *constants = intel_upload_space(brw, size, 64,
                                         &const_bo, &const_offset);
   for (i = 0; i < brw->wm.prog_data->base.nr_pull_params; i++) {
      constants[i] = *brw->wm.prog_data->base.pull_param[i];
   }

   brw_create_constant_surface(brw, const_bo, const_offset, size,
                               &brw->wm.base.surf_offset[surf_index],
                               true);
   drm_intel_bo_unreference(const_bo);

   brw->state.dirty.brw |= BRW_NEW_SURFACES;
d503 8
d538 1
d624 1
d742 1
a742 1
      .cache = 0
d769 2
d831 1
a831 1
             BRW_NEW_UNIFORM_BUFFER |
d835 1
a835 1
      .cache = 0
d926 1
a926 1
   if (prog->NumUniformBlocks)
@


1.8
log
@Merge Mesa 9.2.3
ok mpi@@ kettenis@@
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
d5 1
a5 1
 
d13 1
a13 1
 
d17 1
a17 1
 
d25 1
a25 1
 
d29 1
a29 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d31 1
a31 1
                   
d54 1
a54 1
   case GL_TEXTURE_1D: 
d58 1
a58 1
   case GL_TEXTURE_RECTANGLE_NV: 
d61 1
a61 1
   case GL_TEXTURE_2D: 
d68 1
a68 1
   case GL_TEXTURE_3D: 
d71 1
a71 1
   case GL_TEXTURE_CUBE_MAP: 
d75 2
a76 2
   default: 
      assert(0); 
d104 24
d217 23
d241 13
a253 1
static void
d256 1
a256 2
                                  uint32_t *binding_table,
                                  unsigned surf_index)
a259 1
   uint32_t *surf;
d262 3
a264 2
   drm_intel_bo *bo = intel_obj ? intel_obj->buffer : NULL;
   gl_format format = tObj->_BufferObjectFormat;
d268 5
d278 7
a284 30
   surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
			  6 * 4, 32, &binding_table[surf_index]);

   surf[0] = (BRW_SURFACE_BUFFER << BRW_SURFACE_TYPE_SHIFT |
	      (brw_format_for_mesa_format(format) << BRW_SURFACE_FORMAT_SHIFT));

   if (brw->gen >= 6)
      surf[0] |= BRW_SURFACE_RC_READ_WRITE;

   if (bo) {
      surf[1] = bo->offset; /* reloc */

      /* Emit relocation to surface contents. */
      drm_intel_bo_emit_reloc(brw->batch.bo,
			      binding_table[surf_index] + 4,
			      bo, 0, I915_GEM_DOMAIN_SAMPLER, 0);

      int w = intel_obj->Base.Size / texel_size;
      surf[2] = ((w & 0x7f) << BRW_SURFACE_WIDTH_SHIFT |
		 ((w >> 7) & 0x1fff) << BRW_SURFACE_HEIGHT_SHIFT);
      surf[3] = (((w >> 20) & 0x7f) << BRW_SURFACE_DEPTH_SHIFT |
		 (texel_size - 1) << BRW_SURFACE_PITCH_SHIFT);
   } else {
      surf[1] = 0;
      surf[2] = 0;
      surf[3] = 0;
   }

   surf[4] = 0;
   surf[5] = 0;
d290 2
a291 2
                           uint32_t *binding_table,
                           unsigned surf_index)
a296 1
   struct gl_texture_image *firstImage = tObj->Image[0][tObj->BaseLevel];
a298 1
   uint32_t tile_x, tile_y;
d302 1
a302 1
      brw_update_buffer_texture_surface(ctx, unit, binding_table, surf_index);
d307 33
a339 1
			  6 * 4, 32, &binding_table[surf_index]);
d344 3
a346 9
	      (translate_tex_format(brw,
                                    mt->format,
				    tObj->DepthMode,
				    sampler->sRGBDecode) <<
	       BRW_SURFACE_FORMAT_SHIFT));

   surf[1] = intelObj->mt->region->bo->offset + intelObj->mt->offset; /* reloc */
   surf[1] += intel_miptree_get_tile_offsets(intelObj->mt, firstImage->Level, 0,
                                             &tile_x, &tile_y);
d352 1
a352 1
   surf[3] = (brw_get_surface_tiling_bits(intelObj->mt->region->tiling) |
d354 1
a354 2
	      (intelObj->mt->region->pitch - 1) <<
	      BRW_SURFACE_PITCH_SHIFT);
d356 2
a357 1
   surf[4] = brw_get_surface_num_multisamples(intelObj->mt->num_samples);
d359 1
a359 9
   assert(brw->has_surface_tile_offset || (tile_x == 0 && tile_y == 0));
   /* Note that the low bits of these fields are missing, so
    * there's the possibility of getting in trouble.
    */
   assert(tile_x % 4 == 0);
   assert(tile_y % 2 == 0);
   surf[5] = ((tile_x / 4) << BRW_SURFACE_X_OFFSET_SHIFT |
	      (tile_y / 2) << BRW_SURFACE_Y_OFFSET_SHIFT |
	      (mt->align_h == 4 ? BRW_SURFACE_VERTICAL_ALIGN_ENABLE : 0));
d363 4
a366 4
			   binding_table[surf_index] + 4,
			   intelObj->mt->region->bo,
                           surf[1] - intelObj->mt->region->bo->offset,
			   I915_GEM_DOMAIN_SAMPLER, 0);
d373 1
a373 1
static void
a382 12
   const GLint w = elements - 1;
   uint32_t *surf;

   surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
			  6 * 4, 32, out_offset);

   surf[0] = (BRW_SURFACE_BUFFER << BRW_SURFACE_TYPE_SHIFT |
	      BRW_SURFACE_MIPMAPLAYOUT_BELOW << BRW_SURFACE_MIPLAYOUT_SHIFT |
	      BRW_SURFACEFORMAT_R32G32B32A32_FLOAT << BRW_SURFACE_FORMAT_SHIFT);

   if (brw->gen >= 6)
      surf[0] |= BRW_SURFACE_RC_READ_WRITE;
d384 3
a386 19
   surf[1] = bo->offset + offset; /* reloc */

   surf[2] = ((w & 0x7f) << BRW_SURFACE_WIDTH_SHIFT |
	      ((w >> 7) & 0x1fff) << BRW_SURFACE_HEIGHT_SHIFT);

   surf[3] = (((w >> 20) & 0x7f) << BRW_SURFACE_DEPTH_SHIFT |
	      (stride - 1) << BRW_SURFACE_PITCH_SHIFT);

   surf[4] = 0;
   surf[5] = 0;

   /* Emit relocation to surface contents.  The 965 PRM, Volume 4, section
    * 5.1.2 "Data Cache" says: "the data cache does not exist as a separate
    * physical cache.  It is mapped in hardware to the sampler cache."
    */
   drm_intel_bo_emit_reloc(brw->batch.bo,
			   *out_offset + 4,
			   bo, offset,
			   I915_GEM_DOMAIN_SAMPLER, 0);
d402 4
a405 1
   drm_intel_bo *bo = intel_bufferobj_buffer(brw, intel_bo, INTEL_WRITE_PART);
a408 1
   uint32_t offset_bytes = 4 * offset_dwords;
d461 1
a461 1
   surf[1] = bo->offset + offset_bytes; /* reloc */
d490 3
a492 3
   const int size = brw->wm.prog_data->nr_pull_params * sizeof(float);
   const int surf_index = SURF_INDEX_FRAG_CONST_BUFFER;
   float *constants;
d498 3
a500 5
   if (brw->wm.prog_data->nr_pull_params == 0) {
      if (brw->wm.const_bo) {
	 drm_intel_bo_unreference(brw->wm.const_bo);
	 brw->wm.const_bo = NULL;
	 brw->wm.surf_offset[surf_index] = 0;
d506 8
a513 3
   drm_intel_bo_unreference(brw->wm.const_bo);
   brw->wm.const_bo = drm_intel_bo_alloc(brw->bufmgr, "WM const bo",
					 size, 64);
d515 4
a518 11
   /* _NEW_PROGRAM_CONSTANTS */
   drm_intel_gem_bo_map_gtt(brw->wm.const_bo);
   constants = brw->wm.const_bo->virtual;
   for (i = 0; i < brw->wm.prog_data->nr_pull_params; i++) {
      constants[i] = *brw->wm.prog_data->pull_param[i];
   }
   drm_intel_gem_bo_unmap_gtt(brw->wm.const_bo);

   brw->vtbl.create_constant_surface(brw, brw->wm.const_bo, 0, size,
                                     &brw->wm.surf_offset[surf_index],
                                     true);
d559 2
d565 2
a566 2
   surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
			  6 * 4, 32, &brw->wm.surf_offset[unit]);
d603 1
a603 1
   surf[1] = bo ? bo->offset : 0;
d619 1
a619 1
                              brw->wm.surf_offset[unit] + 4,
a638 1
   struct intel_region *region;
d643 3
a645 1
   gl_format rb_format = _mesa_get_render_format(ctx, intel_rb_format(irb));
d666 2
a667 4
   region = irb->mt->region;

   surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
			  6 * 4, 32, &brw->wm.surf_offset[unit]);
d680 1
a680 1
	      region->bo->offset);
d685 2
a686 2
   surf[3] = (brw_get_surface_tiling_bits(region->tiling) |
	      (region->pitch - 1) << BRW_SURFACE_PITCH_SHIFT);
d723 3
a725 3
			   brw->wm.surf_offset[unit] + 4,
			   region->bo,
			   surf[1] - region->bo->offset,
d745 1
a745 1
                                                  ctx->DrawBuffer->Layered, i);
d775 1
a775 3
/**
 * Construct SURFACE_STATE objects for enabled textures.
 */
d777 4
a780 1
brw_update_texture_surfaces(struct brw_context *brw)
d782 3
d787 5
a791 10
   /* BRW_NEW_VERTEX_PROGRAM and BRW_NEW_FRAGMENT_PROGRAM:
    * Unfortunately, we're stuck using the gl_program structs until the
    * ARB_fragment_program front-end gets converted to GLSL IR.  These
    * have the downside that SamplerUnits is split and only contains the
    * mappings for samplers active in that stage.
    */
   struct gl_program *vs = (struct gl_program *) brw->vertex_program;
   struct gl_program *fs = (struct gl_program *) brw->fragment_program;

   unsigned num_samplers = _mesa_fls(vs->SamplersUsed | fs->SamplersUsed);
d793 1
d795 1
a795 2
      brw->vs.surf_offset[SURF_INDEX_VS_TEXTURE(s)] = 0;
      brw->wm.surf_offset[SURF_INDEX_TEXTURE(s)] = 0;
d797 2
a798 2
      if (vs->SamplersUsed & (1 << s)) {
         const unsigned unit = vs->SamplerUnits[s];
d801 2
a802 4
         if (ctx->Texture.Unit[unit]._ReallyEnabled) {
            brw->vtbl.update_texture_surface(ctx, unit,
                                             brw->vs.surf_offset,
                                             SURF_INDEX_VS_TEXTURE(s));
d805 3
d809 14
a822 2
      if (fs->SamplersUsed & (1 << s)) {
         const unsigned unit = fs->SamplerUnits[s];
d824 15
a838 7
         /* _NEW_TEXTURE */
         if (ctx->Texture.Unit[unit]._ReallyEnabled) {
            brw->vtbl.update_texture_surface(ctx, unit,
                                             brw->wm.surf_offset,
                                             SURF_INDEX_TEXTURE(s));
         }
      }
d850 1
d860 2
a861 1
			uint32_t *surf_offsets)
d868 3
d877 4
a880 1
      drm_intel_bo *bo = intel_bufferobj_buffer(brw, intel_bo, INTEL_READ);
d886 4
a889 4
      brw->vtbl.create_constant_surface(brw, bo, binding->Offset,
                                        bo->size - binding->Offset,
                                        &surf_offsets[i],
                                        shader->Type == GL_FRAGMENT_SHADER);
d901 1
a901 1
   struct gl_shader_program *prog = ctx->Shader._CurrentFragmentProgram;
d906 1
d908 1
a908 1
			   &brw->wm.surf_offset[SURF_INDEX_WM_UBO(0)]);
d915 1
a915 1
      .cache = 0,
d920 5
a924 6
/**
 * Constructs the binding table for the WM surface state, which maps unit
 * numbers to surface state objects.
 */
static void
brw_upload_wm_binding_table(struct brw_context *brw)
d926 3
a928 2
   uint32_t *bind;
   int i;
d930 11
a940 2
   if (INTEL_DEBUG & DEBUG_SHADER_TIME) {
      gen7_create_shader_time_surface(brw, &brw->wm.surf_offset[SURF_INDEX_WM_SHADER_TIME]);
d943 10
a952 6
   /* Might want to calculate nr_surfaces first, to avoid taking up so much
    * space for the binding table.
    */
   bind = brw_state_batch(brw, AUB_TRACE_BINDING_TABLE,
			  sizeof(uint32_t) * BRW_MAX_WM_SURFACES,
			  32, &brw->wm.bind_bo_offset);
d954 4
a957 3
   /* BRW_NEW_SURFACES */
   for (i = 0; i < BRW_MAX_WM_SURFACES; i++) {
      bind[i] = brw->wm.surf_offset[i];
a958 2

   brw->state.dirty.brw |= BRW_NEW_PS_BINDING_TABLE;
d961 1
a961 1
const struct brw_tracked_state brw_wm_binding_table = {
d963 3
a965 4
      .mesa = 0,
      .brw = (BRW_NEW_BATCH |
	      BRW_NEW_SURFACES),
      .cache = 0
d967 1
a967 1
   .emit = brw_upload_wm_binding_table,
d977 1
a977 1
   brw->vtbl.create_constant_surface = brw_create_constant_surface;
@


1.7
log
@Merge Mesa 9.2.0
@
text
@d262 1
d801 1
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d33 2
a36 1
#include "main/texstore.h"
d43 1
d55 1
d62 4
d72 1
d82 1
a82 1
brw_format_for_mesa_format(gl_format mesa_format)
d84 8
a91 51
   static const uint32_t table[MESA_FORMAT_COUNT] =
   {
      [MESA_FORMAT_L8] = BRW_SURFACEFORMAT_L8_UNORM,
      [MESA_FORMAT_I8] = BRW_SURFACEFORMAT_I8_UNORM,
      [MESA_FORMAT_A8] = BRW_SURFACEFORMAT_A8_UNORM,
      [MESA_FORMAT_AL88] = BRW_SURFACEFORMAT_L8A8_UNORM,
      [MESA_FORMAT_AL1616] = BRW_SURFACEFORMAT_L16A16_UNORM,
      [MESA_FORMAT_R8] = BRW_SURFACEFORMAT_R8_UNORM,
      [MESA_FORMAT_R16] = BRW_SURFACEFORMAT_R16_UNORM,
      [MESA_FORMAT_RG88] = BRW_SURFACEFORMAT_R8G8_UNORM,
      [MESA_FORMAT_RG1616] = BRW_SURFACEFORMAT_R16G16_UNORM,
      [MESA_FORMAT_ARGB8888] = BRW_SURFACEFORMAT_B8G8R8A8_UNORM,
      [MESA_FORMAT_XRGB8888] = BRW_SURFACEFORMAT_B8G8R8X8_UNORM,
      [MESA_FORMAT_RGB565] = BRW_SURFACEFORMAT_B5G6R5_UNORM,
      [MESA_FORMAT_ARGB1555] = BRW_SURFACEFORMAT_B5G5R5A1_UNORM,
      [MESA_FORMAT_ARGB4444] = BRW_SURFACEFORMAT_B4G4R4A4_UNORM,
      [MESA_FORMAT_YCBCR_REV] = BRW_SURFACEFORMAT_YCRCB_NORMAL,
      [MESA_FORMAT_YCBCR] = BRW_SURFACEFORMAT_YCRCB_SWAPUVY,
      [MESA_FORMAT_RGB_FXT1] = BRW_SURFACEFORMAT_FXT1,
      [MESA_FORMAT_RGBA_FXT1] = BRW_SURFACEFORMAT_FXT1,
      [MESA_FORMAT_RGB_DXT1] = BRW_SURFACEFORMAT_DXT1_RGB,
      [MESA_FORMAT_RGBA_DXT1] = BRW_SURFACEFORMAT_BC1_UNORM,
      [MESA_FORMAT_RGBA_DXT3] = BRW_SURFACEFORMAT_BC2_UNORM,
      [MESA_FORMAT_RGBA_DXT5] = BRW_SURFACEFORMAT_BC3_UNORM,
      [MESA_FORMAT_SRGB_DXT1] = BRW_SURFACEFORMAT_DXT1_RGB_SRGB,
      [MESA_FORMAT_SRGBA_DXT1] = BRW_SURFACEFORMAT_BC1_UNORM_SRGB,
      [MESA_FORMAT_SRGBA_DXT3] = BRW_SURFACEFORMAT_BC2_UNORM_SRGB,
      [MESA_FORMAT_SRGBA_DXT5] = BRW_SURFACEFORMAT_BC3_UNORM_SRGB,
      [MESA_FORMAT_SARGB8] = BRW_SURFACEFORMAT_B8G8R8A8_UNORM_SRGB,
      [MESA_FORMAT_SLA8] = BRW_SURFACEFORMAT_L8A8_UNORM_SRGB,
      [MESA_FORMAT_SL8] = BRW_SURFACEFORMAT_L8_UNORM_SRGB,
      [MESA_FORMAT_DUDV8] = BRW_SURFACEFORMAT_R8G8_SNORM,
      [MESA_FORMAT_SIGNED_R8] = BRW_SURFACEFORMAT_R8_SNORM,
      [MESA_FORMAT_SIGNED_RG88_REV] = BRW_SURFACEFORMAT_R8G8_SNORM,
      [MESA_FORMAT_SIGNED_RGBA8888_REV] = BRW_SURFACEFORMAT_R8G8B8A8_SNORM,
      [MESA_FORMAT_SIGNED_R16] = BRW_SURFACEFORMAT_R16_SNORM,
      [MESA_FORMAT_SIGNED_GR1616] = BRW_SURFACEFORMAT_R16G16_SNORM,
      [MESA_FORMAT_RGBA_FLOAT32] = BRW_SURFACEFORMAT_R32G32B32A32_FLOAT,
      [MESA_FORMAT_RG_FLOAT32] = BRW_SURFACEFORMAT_R32G32_FLOAT,
      [MESA_FORMAT_R_FLOAT32] = BRW_SURFACEFORMAT_R32_FLOAT,
      [MESA_FORMAT_INTENSITY_FLOAT32] = BRW_SURFACEFORMAT_I32_FLOAT,
      [MESA_FORMAT_LUMINANCE_FLOAT32] = BRW_SURFACEFORMAT_L32_FLOAT,
      [MESA_FORMAT_ALPHA_FLOAT32] = BRW_SURFACEFORMAT_A32_FLOAT,
      [MESA_FORMAT_LUMINANCE_ALPHA_FLOAT32] = BRW_SURFACEFORMAT_L32A32_FLOAT,
      [MESA_FORMAT_RED_RGTC1] = BRW_SURFACEFORMAT_BC4_UNORM,
      [MESA_FORMAT_SIGNED_RED_RGTC1] = BRW_SURFACEFORMAT_BC4_SNORM,
      [MESA_FORMAT_RG_RGTC2] = BRW_SURFACEFORMAT_BC5_UNORM,
      [MESA_FORMAT_SIGNED_RG_RGTC2] = BRW_SURFACEFORMAT_BC5_SNORM,
   };
   assert(mesa_format < MESA_FORMAT_COUNT);
   return table[mesa_format];
d94 3
a96 2
bool
brw_render_target_supported(gl_format format)
d98 67
a164 8
   /* These are not color render targets like the table holds, but we
    * ask the question for FBO completeness.
    */
   if (format == MESA_FORMAT_S8_Z24 ||
       format == MESA_FORMAT_X8_Z24 ||
       format == MESA_FORMAT_S8 ||
       format == MESA_FORMAT_Z16) {
      return true;
d167 5
a171 1
   /* The value of this BRW_SURFACEFORMAT is 0, so hardcode it.
d173 13
a185 2
   if (format == MESA_FORMAT_RGBA_FLOAT32)
      return true;
d187 4
a190 4
   /* Not exactly true, as some of those formats are not renderable.
    * But at least we know how to translate them.
    */
   return brw_format_for_mesa_format(format) != 0;
a192 45
GLuint
translate_tex_format(gl_format mesa_format,
		     GLenum internal_format,
		     GLenum depth_mode,
		     GLenum srgb_decode)
{
   switch( mesa_format ) {

   case MESA_FORMAT_Z16:
      if (depth_mode == GL_INTENSITY) 
	  return BRW_SURFACEFORMAT_I16_UNORM;
      else if (depth_mode == GL_ALPHA)
	  return BRW_SURFACEFORMAT_A16_UNORM;
      else if (depth_mode == GL_RED)
	  return BRW_SURFACEFORMAT_R16_UNORM;
      else
	  return BRW_SURFACEFORMAT_L16_UNORM;

   case MESA_FORMAT_S8_Z24:
   case MESA_FORMAT_X8_Z24:
      /* XXX: these different surface formats don't seem to
       * make any difference for shadow sampler/compares.
       */
      if (depth_mode == GL_INTENSITY) 
         return BRW_SURFACEFORMAT_I24X8_UNORM;
      else if (depth_mode == GL_ALPHA)
         return BRW_SURFACEFORMAT_A24X8_UNORM;
      else if (depth_mode == GL_RED)
         return BRW_SURFACEFORMAT_R24_UNORM_X8_TYPELESS;
      else
         return BRW_SURFACEFORMAT_L24X8_UNORM;
      
   case MESA_FORMAT_SARGB8:
   case MESA_FORMAT_SLA8:
   case MESA_FORMAT_SL8:
      if (srgb_decode == GL_DECODE_EXT)
	 return brw_format_for_mesa_format(mesa_format);
      else if (srgb_decode == GL_SKIP_DECODE_EXT)
	 return brw_format_for_mesa_format(_mesa_get_srgb_format_linear(mesa_format));

   case MESA_FORMAT_RGBA_FLOAT32:
      /* The value of this BRW_SURFACEFORMAT is 0, which tricks the
       * assertion below.
       */
      return BRW_SURFACEFORMAT_R32G32B32A32_FLOAT;
d194 19
a212 3
   default:
      assert(brw_format_for_mesa_format(mesa_format) != 0);
      return brw_format_for_mesa_format(mesa_format);
a213 1
}
d215 26
a240 10
static uint32_t
brw_get_surface_tiling_bits(uint32_t tiling)
{
   switch (tiling) {
   case I915_TILING_X:
      return BRW_SURFACE_TILED;
   case I915_TILING_Y:
      return BRW_SURFACE_TILED | BRW_SURFACE_TILED_Y;
   default:
      return 0;
d242 3
d248 4
a251 1
brw_update_texture_surface( struct gl_context *ctx, GLuint unit )
d256 1
a258 1
   const GLuint surf_index = SURF_INDEX_TEXTURE(unit);
d260 6
d267 2
a268 1
   surf = brw_state_batch(brw, 6 * 4, 32, &brw->wm.surf_offset[surf_index]);
d273 3
a275 3
	      (translate_tex_format(firstImage->TexFormat,
				    firstImage->InternalFormat,
				    sampler->DepthMode,
d279 3
a281 1
   surf[1] = intelObj->mt->region->buffer->offset; /* reloc */
d284 2
a285 2
	      (firstImage->Width - 1) << BRW_SURFACE_WIDTH_SHIFT |
	      (firstImage->Height - 1) << BRW_SURFACE_HEIGHT_SHIFT);
d288 2
a289 2
	      (firstImage->Depth - 1) << BRW_SURFACE_DEPTH_SHIFT |
	      ((intelObj->mt->region->pitch * intelObj->mt->cpp) - 1) <<
d292 11
a302 2
   surf[4] = 0;
   surf[5] = 0;
d305 4
a308 3
   drm_intel_bo_emit_reloc(brw->intel.batch.bo,
			   brw->wm.surf_offset[surf_index] + 4,
			   intelObj->mt->region->buffer, 0,
d316 1
a316 1
void
d319 8
a326 5
			    int width,
			    uint32_t *out_offset)
{
   struct intel_context *intel = &brw->intel;
   const GLint w = width - 1;
d329 2
a330 1
   surf = brw_state_batch(brw, 6 * 4, 32, out_offset);
d336 1
a336 1
   if (intel->gen >= 6)
d339 1
a339 1
   surf[1] = bo->offset; /* reloc */
d345 1
a345 1
	      (width * 16 - 1) << BRW_SURFACE_PITCH_SHIFT);
d350 3
a352 3
   /* Emit relocation to surface contents.  Section 5.1.1 of the gen4
    * bspec ("Data Cache") says that the data cache does not exist as
    * a separate cache and is just the sampler cache.
d354 1
a354 1
   drm_intel_bo_emit_reloc(brw->intel.batch.bo,
d356 1
a356 1
			   bo, 0,
d360 85
d452 1
a452 1
prepare_wm_pull_constants(struct brw_context *brw)
d454 2
a455 2
   struct gl_context *ctx = &brw->intel.ctx;
   struct intel_context *intel = &brw->intel;
d458 1
d460 1
d464 1
a464 1
   _mesa_load_state_parameters(ctx, fp->program.Base.Parameters);
d466 1
a466 1
   /* BRW_NEW_FRAGMENT_PROGRAM */
d471 2
a472 1
	 brw->state.dirty.brw |= BRW_NEW_WM_CONSTBUF;
d478 1
a478 1
   brw->wm.const_bo = drm_intel_bo_alloc(intel->bufmgr, "WM const bo",
d485 1
a485 2
      constants[i] = convert_param(brw->wm.prog_data->pull_param_convert[i],
				   *brw->wm.prog_data->pull_param[i]);
d489 5
a493 1
   brw->state.dirty.brw |= BRW_NEW_WM_CONSTBUF;
d496 1
a496 1
const struct brw_tracked_state brw_wm_constants = {
d499 2
a500 44
      .brw = (BRW_NEW_FRAGMENT_PROGRAM),
      .cache = 0
   },
   .prepare = prepare_wm_pull_constants,
};

/**
 * Updates surface / buffer for fragment shader constant buffer, if
 * one is required.
 *
 * This consumes the state updates for the constant buffer, and produces
 * BRW_NEW_WM_SURFACES to get picked up by brw_prepare_wm_surfaces for
 * inclusion in the binding table.
 */
static void upload_wm_constant_surface(struct brw_context *brw )
{
   GLuint surf = SURF_INDEX_FRAG_CONST_BUFFER;
   struct brw_fragment_program *fp =
      (struct brw_fragment_program *) brw->fragment_program;
   const struct gl_program_parameter_list *params =
      fp->program.Base.Parameters;

   /* If there's no constant buffer, then no surface BO is needed to point at
    * it.
    */
   if (brw->wm.const_bo == 0) {
      if (brw->wm.surf_offset[surf]) {
	 brw->state.dirty.brw |= BRW_NEW_WM_SURFACES;
	 brw->wm.surf_offset[surf] = 0;
      }
      return;
   }

   brw_create_constant_surface(brw, brw->wm.const_bo, params->NumParameters,
			       &brw->wm.surf_offset[surf]);
   brw->state.dirty.brw |= BRW_NEW_WM_SURFACES;
}

const struct brw_tracked_state brw_wm_constant_surface = {
   .dirty = {
      .mesa = 0,
      .brw = (BRW_NEW_WM_CONSTBUF |
	      BRW_NEW_BATCH),
      .cache = 0
d502 1
a502 1
   .emit = upload_wm_constant_surface,
d508 19
a526 1
   struct intel_context *intel = &brw->intel;
d528 37
d566 1
a566 3
   surf = brw_state_batch(brw, 6 * 4, 32, &brw->wm.surf_offset[unit]);

   surf[0] = (BRW_SURFACE_NULL << BRW_SURFACE_TYPE_SHIFT |
d568 1
a568 1
   if (intel->gen < 6) {
d574 12
a585 4
   surf[1] = 0;
   surf[2] = 0;
   surf[3] = 0;
   surf[4] = 0;
d587 7
d604 1
d607 1
a607 2
   struct intel_context *intel = &brw->intel;
   struct gl_context *ctx = &intel->ctx;
d609 2
a610 1
   struct intel_region *region = irb->region;
d614 21
d636 1
a636 1
   surf = brw_state_batch(brw, 6 * 4, 32, &brw->wm.surf_offset[unit]);
d638 7
a644 30
   switch (irb->Base.Format) {
   case MESA_FORMAT_XRGB8888:
      /* XRGB is handled as ARGB because the chips in this family
       * cannot render to XRGB targets.  This means that we have to
       * mask writes to alpha (ala glColorMask) and reconfigure the
       * alpha blending hardware to use GL_ONE (or GL_ZERO) for
       * cases where GL_DST_ALPHA (or GL_ONE_MINUS_DST_ALPHA) is
       * used.
       */
      format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
      break;
   case MESA_FORMAT_INTENSITY_FLOAT32:
   case MESA_FORMAT_LUMINANCE_FLOAT32:
      /* For these formats, we just need to read/write the first
       * channel into R, which is to say that we just treat them as
       * GL_RED.
       */
      format = BRW_SURFACEFORMAT_R32_FLOAT;
      break;
   case MESA_FORMAT_SARGB8:
      /* without GL_EXT_framebuffer_sRGB we shouldn't bind sRGB
	 surfaces to the blend/update as sRGB */
      if (ctx->Color.sRGBEnabled)
	 format = brw_format_for_mesa_format(irb->Base.Format);
      else
	 format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
      break;
   default:
      assert(brw_render_target_supported(irb->Base.Format));
      format = brw_format_for_mesa_format(irb->Base.Format);
d651 2
a652 2
   surf[1] = (intel_renderbuffer_tile_offsets(irb, &tile_x, &tile_y) +
	      region->buffer->offset);
d658 1
a658 1
	      ((region->pitch * region->cpp) - 1) << BRW_SURFACE_PITCH_SHIFT);
d660 1
a660 1
   surf[4] = 0;
d669 2
a670 1
	      (tile_y / 2) << BRW_SURFACE_Y_OFFSET_SHIFT);
d672 1
a672 1
   if (intel->gen < 6) {
d674 1
a674 1
      if (!ctx->Color._LogicOpEnabled &&
d694 1
a694 1
   drm_intel_bo_emit_reloc(brw->intel.batch.bo,
d696 2
a697 2
			   region->buffer,
			   surf[1] - region->buffer->offset,
a701 43
static void
prepare_wm_surfaces(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->intel.ctx;
   int i;
   int nr_surfaces = 0;

   for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++) {
      struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[i];
      struct intel_renderbuffer *irb = intel_renderbuffer(rb);
      struct intel_region *region = irb ? irb->region : NULL;

      if (region)
	 brw_add_validated_bo(brw, region->buffer);
      nr_surfaces = SURF_INDEX_DRAW(i) + 1;
   }

   if (brw->wm.const_bo) {
      brw_add_validated_bo(brw, brw->wm.const_bo);
      nr_surfaces = SURF_INDEX_FRAG_CONST_BUFFER + 1;
   }

   for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
      const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[i];

      if (texUnit->_ReallyEnabled) {
	 struct gl_texture_object *tObj = texUnit->_Current;
	 struct intel_texture_object *intelObj = intel_texture_object(tObj);

	 brw_add_validated_bo(brw, intelObj->mt->region->buffer);
	 nr_surfaces = SURF_INDEX_TEXTURE(i) + 1;
      }
   }

   /* Have to update this in our prepare, since the unit's prepare
    * relies on it.
    */
   if (brw->wm.nr_surfaces != nr_surfaces) {
      brw->wm.nr_surfaces = nr_surfaces;
      brw->state.dirty.brw |= BRW_NEW_NR_WM_SURFACES;
   }
}

d703 1
a703 2
 * Constructs the set of surface state objects pointed to by the
 * binding table.
d706 1
a706 1
upload_wm_surfaces(struct brw_context *brw)
d708 1
a708 1
   struct gl_context *ctx = &brw->intel.ctx;
d716 2
a717 3
	    brw_update_renderbuffer_surface(brw,
					    ctx->DrawBuffer->_ColorDrawBuffers[i],
					    i);
d719 1
a719 1
	    brw_update_null_renderbuffer_surface(brw, i);
d723 1
a723 1
      brw_update_null_renderbuffer_surface(brw, 0);
d725 21
d747 43
a789 10
   /* Update surfaces for textures */
   for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
      const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[i];
      const GLuint surf = SURF_INDEX_TEXTURE(i);

      /* _NEW_TEXTURE */
      if (texUnit->_ReallyEnabled) {
	 brw_update_texture_surface(ctx, i);
      } else {
         brw->wm.surf_offset[surf] = 0;
d793 1
a793 1
   brw->state.dirty.brw |= BRW_NEW_WM_SURFACES;
d796 1
a796 1
const struct brw_tracked_state brw_wm_surfaces = {
d798 4
a801 4
      .mesa = (_NEW_COLOR |
               _NEW_TEXTURE |
               _NEW_BUFFERS),
      .brw = (BRW_NEW_BATCH),
d804 56
a859 2
   .prepare = prepare_wm_surfaces,
   .emit = upload_wm_surfaces,
d867 1
a867 1
brw_wm_upload_binding_table(struct brw_context *brw)
d872 4
d879 2
a880 1
   bind = brw_state_batch(brw, sizeof(uint32_t) * BRW_WM_MAX_SURF,
d883 2
a884 2
   for (i = 0; i < BRW_WM_MAX_SURF; i++) {
      /* BRW_NEW_WM_SURFACES */
d895 1
a895 1
	      BRW_NEW_WM_SURFACES),
d898 1
a898 1
   .emit = brw_wm_upload_binding_table,
d900 10
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d34 1
d46 1
d48 2
a49 2

static GLuint translate_tex_target( GLenum target )
d73 55
d129 2
a130 3
static GLuint translate_tex_format( gl_format mesa_format,
                                    GLenum internal_format,
				    GLenum depth_mode )
d132 9
a140 3
   switch( mesa_format ) {
   case MESA_FORMAT_L8:
      return BRW_SURFACEFORMAT_L8_UNORM;
d142 4
a145 2
   case MESA_FORMAT_I8:
      return BRW_SURFACEFORMAT_I8_UNORM;
d147 5
a151 2
   case MESA_FORMAT_A8:
      return BRW_SURFACEFORMAT_A8_UNORM; 
d153 7
a159 50
   case MESA_FORMAT_AL88:
      return BRW_SURFACEFORMAT_L8A8_UNORM;

   case MESA_FORMAT_AL1616:
      return BRW_SURFACEFORMAT_L16A16_UNORM;

   case MESA_FORMAT_R8:
      return BRW_SURFACEFORMAT_R8_UNORM;

   case MESA_FORMAT_R16:
      return BRW_SURFACEFORMAT_R16_UNORM;

   case MESA_FORMAT_RG88:
      return BRW_SURFACEFORMAT_R8G8_UNORM;

   case MESA_FORMAT_RG1616:
      return BRW_SURFACEFORMAT_R16G16_UNORM;

   case MESA_FORMAT_RGB888:
      assert(0);		/* not supported for sampling */
      return BRW_SURFACEFORMAT_R8G8B8_UNORM;      

   case MESA_FORMAT_ARGB8888:
      return BRW_SURFACEFORMAT_B8G8R8A8_UNORM;

   case MESA_FORMAT_XRGB8888:
      return BRW_SURFACEFORMAT_B8G8R8X8_UNORM;

   case MESA_FORMAT_RGBA8888_REV:
      _mesa_problem(NULL, "unexpected format in i965:translate_tex_format()");
      return BRW_SURFACEFORMAT_R8G8B8A8_UNORM;

   case MESA_FORMAT_RGB565:
      return BRW_SURFACEFORMAT_B5G6R5_UNORM;

   case MESA_FORMAT_ARGB1555:
      return BRW_SURFACEFORMAT_B5G5R5A1_UNORM;

   case MESA_FORMAT_ARGB4444:
      return BRW_SURFACEFORMAT_B4G4R4A4_UNORM;

   case MESA_FORMAT_YCBCR_REV:
      return BRW_SURFACEFORMAT_YCRCB_NORMAL;

   case MESA_FORMAT_YCBCR:
      return BRW_SURFACEFORMAT_YCRCB_SWAPUVY;

   case MESA_FORMAT_RGB_FXT1:
   case MESA_FORMAT_RGBA_FXT1:
      return BRW_SURFACEFORMAT_FXT1;
a170 24
   case MESA_FORMAT_RGB_DXT1:
       return BRW_SURFACEFORMAT_DXT1_RGB;

   case MESA_FORMAT_RGBA_DXT1:
       return BRW_SURFACEFORMAT_BC1_UNORM;
       
   case MESA_FORMAT_RGBA_DXT3:
       return BRW_SURFACEFORMAT_BC2_UNORM;
       
   case MESA_FORMAT_RGBA_DXT5:
       return BRW_SURFACEFORMAT_BC3_UNORM;

   case MESA_FORMAT_SARGB8:
      return BRW_SURFACEFORMAT_B8G8R8A8_UNORM_SRGB;

   case MESA_FORMAT_SLA8:
      return BRW_SURFACEFORMAT_L8A8_UNORM_SRGB;

   case MESA_FORMAT_SL8:
      return BRW_SURFACEFORMAT_L8_UNORM_SRGB;

   case MESA_FORMAT_SRGB_DXT1:
      return BRW_SURFACEFORMAT_BC1_UNORM_SRGB;

d172 1
d184 14
a197 6

   case MESA_FORMAT_DUDV8:
      return BRW_SURFACEFORMAT_R8G8_SNORM;

   case MESA_FORMAT_SIGNED_RGBA8888_REV:
      return BRW_SURFACEFORMAT_R8G8B8A8_SNORM;
d200 2
a201 2
      assert(0);
      return 0;
d205 2
a206 2
static void
brw_set_surface_tiling(struct brw_surface_state *surf, uint32_t tiling)
a208 4
   case I915_TILING_NONE:
      surf->ss3.tiled_surface = 0;
      surf->ss3.tile_walk = 0;
      break;
d210 1
a210 3
      surf->ss3.tiled_surface = 1;
      surf->ss3.tile_walk = BRW_TILEWALK_XMAJOR;
      break;
d212 3
a214 3
      surf->ss3.tiled_surface = 1;
      surf->ss3.tile_walk = BRW_TILEWALK_YMAJOR;
      break;
d224 2
a225 1
   struct gl_texture_image *firstImage = tObj->Image[0][intelObj->firstLevel];
d227 1
a227 4
   struct brw_surface_state surf;
   void *map;

   memset(&surf, 0, sizeof(surf));
d229 1
a229 5
   surf.ss0.mipmap_layout_mode = BRW_SURFACE_MIPMAPLAYOUT_BELOW;
   surf.ss0.surface_type = translate_tex_target(tObj->Target);
   surf.ss0.surface_format = translate_tex_format(firstImage->TexFormat,
						  firstImage->InternalFormat,
						  tObj->DepthMode);
d231 19
a249 4
   /* This is ok for all textures with channel width 8bit or less:
    */
/*    surf.ss0.data_return_format = BRW_SURFACERETURNFORMAT_S1; */
   surf.ss1.base_addr = intelObj->mt->region->buffer->offset; /* reloc */
d251 2
a252 22
   surf.ss2.mip_count = intelObj->lastLevel - intelObj->firstLevel;
   surf.ss2.width = firstImage->Width - 1;
   surf.ss2.height = firstImage->Height - 1;
   brw_set_surface_tiling(&surf, intelObj->mt->region->tiling);
   surf.ss3.pitch = (intelObj->mt->region->pitch * intelObj->mt->cpp) - 1;
   surf.ss3.depth = firstImage->Depth - 1;

   surf.ss4.min_lod = 0;
 
   if (tObj->Target == GL_TEXTURE_CUBE_MAP) {
      surf.ss0.cube_pos_x = 1;
      surf.ss0.cube_pos_y = 1;
      surf.ss0.cube_pos_z = 1;
      surf.ss0.cube_neg_x = 1;
      surf.ss0.cube_neg_y = 1;
      surf.ss0.cube_neg_z = 1;
   }

   map = brw_state_batch(brw, sizeof(surf), 32,
			 &brw->wm.surf_bo[surf_index],
			 &brw->wm.surf_offset[surf_index]);
   memcpy(map, &surf, sizeof(surf));
d255 2
a256 3
   drm_intel_bo_emit_reloc(brw->wm.surf_bo[surf_index],
			   brw->wm.surf_offset[surf_index] +
			   offsetof(struct brw_surface_state, ss1),
a268 1
			    drm_intel_bo **out_bo,
d273 1
a273 2
   struct brw_surface_state surf;
   void *map;
d275 1
a275 1
   memset(&surf, 0, sizeof(surf));
d277 3
a279 3
   surf.ss0.mipmap_layout_mode = BRW_SURFACE_MIPMAPLAYOUT_BELOW;
   surf.ss0.surface_type = BRW_SURFACE_BUFFER;
   surf.ss0.surface_format = BRW_SURFACEFORMAT_R32G32B32A32_FLOAT;
d282 3
a284 1
      surf.ss0.render_cache_read_write = 1;
d286 2
a287 2
   assert(bo);
   surf.ss1.base_addr = bo->offset; /* reloc */
d289 2
a290 5
   surf.ss2.width = w & 0x7f;            /* bits 6:0 of size or width */
   surf.ss2.height = (w >> 7) & 0x1fff;  /* bits 19:7 of size or width */
   surf.ss3.depth = (w >> 20) & 0x7f;    /* bits 26:20 of size or width */
   surf.ss3.pitch = (width * 16) - 1; /* ignored?? */
   brw_set_surface_tiling(&surf, I915_TILING_NONE); /* tiling now allowed */
d292 2
a293 2
   map = brw_state_batch(brw, sizeof(surf), 32, out_bo, out_offset);
   memcpy(map, &surf, sizeof(surf));
d299 2
a300 2
   drm_intel_bo_emit_reloc(*out_bo, (*out_offset +
				     offsetof(struct brw_surface_state, ss1)),
d312 1
a312 1
prepare_wm_constants(struct brw_context *brw)
d356 1
a356 1
   .prepare = prepare_wm_constants,
d379 1
a379 3
      if (brw->wm.surf_bo[surf] != NULL) {
	 drm_intel_bo_unreference(brw->wm.surf_bo[surf]);
	 brw->wm.surf_bo[surf] = NULL;
d381 1
a386 1
			       &brw->wm.surf_bo[surf],
d401 22
a435 1
   drm_intel_bo *region_bo = NULL;
d437 15
a451 26
   struct intel_region *region = irb ? irb->region : NULL;
   struct {
      unsigned int surface_type;
      unsigned int surface_format;
      unsigned int width, height, pitch, cpp;
      GLubyte color_mask[4];
      GLboolean color_blend;
      uint32_t tiling;
      uint32_t draw_x;
      uint32_t draw_y;
   } key;
   struct brw_surface_state surf;
   void *map;

   memset(&key, 0, sizeof(key));

   if (region != NULL) {
      region_bo = region->buffer;

      key.surface_type = BRW_SURFACE_2D;
      switch (irb->Base.Format) {
      /* XRGB and ARGB are treated the same here because the chips in this
       * family cannot render to XRGB targets.  This means that we have to
       * mask writes to alpha (ala glColorMask) and reconfigure the alpha
       * blending hardware to use GL_ONE (or GL_ZERO) for cases where
       * GL_DST_ALPHA (or GL_ONE_MINUS_DST_ALPHA) is used.
d453 21
a473 50
      case MESA_FORMAT_ARGB8888:
      case MESA_FORMAT_XRGB8888:
	 key.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
	 break;
      case MESA_FORMAT_SARGB8:
	 key.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM_SRGB;
	 break;
      case MESA_FORMAT_RGB565:
	 key.surface_format = BRW_SURFACEFORMAT_B5G6R5_UNORM;
	 break;
      case MESA_FORMAT_ARGB1555:
	 key.surface_format = BRW_SURFACEFORMAT_B5G5R5A1_UNORM;
	 break;
      case MESA_FORMAT_ARGB4444:
	 key.surface_format = BRW_SURFACEFORMAT_B4G4R4A4_UNORM;
	 break;
      case MESA_FORMAT_A8:
	 key.surface_format = BRW_SURFACEFORMAT_A8_UNORM;
	 break;
      case MESA_FORMAT_R8:
	 key.surface_format = BRW_SURFACEFORMAT_R8_UNORM;
	 break;
      case MESA_FORMAT_R16:
	 key.surface_format = BRW_SURFACEFORMAT_R16_UNORM;
	 break;
      case MESA_FORMAT_RG88:
	 key.surface_format = BRW_SURFACEFORMAT_R8G8_UNORM;
	 break;
      case MESA_FORMAT_RG1616:
	 key.surface_format = BRW_SURFACEFORMAT_R16G16_UNORM;
	 break;
      default:
	 _mesa_problem(ctx, "Bad renderbuffer format: %d\n", irb->Base.Format);
      }
      key.tiling = region->tiling;
      key.width = rb->Width;
      key.height = rb->Height;
      key.pitch = region->pitch;
      key.cpp = region->cpp;
      key.draw_x = region->draw_x;
      key.draw_y = region->draw_y;
   } else {
      key.surface_type = BRW_SURFACE_NULL;
      key.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
      key.tiling = I915_TILING_X;
      key.width = 1;
      key.height = 1;
      key.cpp = 4;
      key.draw_x = 0;
      key.draw_y = 0;
d476 2
a477 4
   if (intel->gen < 6) {
      /* _NEW_COLOR */
      memcpy(key.color_mask, ctx->Color.ColorMask[unit],
	     sizeof(key.color_mask));
d479 3
a481 5
      /* As mentioned above, disable writes to the alpha component when the
       * renderbuffer is XRGB.
       */
      if (ctx->DrawBuffer->Visual.alphaBits == 0)
	 key.color_mask[3] = GL_FALSE;
d483 2
a484 3
      key.color_blend = (!ctx->Color._LogicOpEnabled &&
			 (ctx->Color.BlendEnabled & (1 << unit)));
   }
d486 2
a487 1
   memset(&surf, 0, sizeof(surf));
d489 1
a489 7
   surf.ss0.surface_format = key.surface_format;
   surf.ss0.surface_type = key.surface_type;
   if (key.tiling == I915_TILING_NONE) {
      surf.ss1.base_addr = (key.draw_x + key.draw_y * key.pitch) * key.cpp;
   } else {
      uint32_t tile_base, tile_x, tile_y;
      uint32_t pitch = key.pitch * key.cpp;
d491 8
a498 29
      if (key.tiling == I915_TILING_X) {
	 tile_x = key.draw_x % (512 / key.cpp);
	 tile_y = key.draw_y % 8;
	 tile_base = ((key.draw_y / 8) * (8 * pitch));
	 tile_base += (key.draw_x - tile_x) / (512 / key.cpp) * 4096;
      } else {
	 /* Y */
	 tile_x = key.draw_x % (128 / key.cpp);
	 tile_y = key.draw_y % 32;
	 tile_base = ((key.draw_y / 32) * (32 * pitch));
	 tile_base += (key.draw_x - tile_x) / (128 / key.cpp) * 4096;
      }
      assert(brw->has_surface_tile_offset || (tile_x == 0 && tile_y == 0));
      assert(tile_x % 4 == 0);
      assert(tile_y % 2 == 0);
      /* Note that the low bits of these fields are missing, so
       * there's the possibility of getting in trouble.
       */
      surf.ss1.base_addr = tile_base;
      surf.ss5.x_offset = tile_x / 4;
      surf.ss5.y_offset = tile_y / 2;
   }
   if (region_bo != NULL)
      surf.ss1.base_addr += region_bo->offset; /* reloc */

   surf.ss2.width = key.width - 1;
   surf.ss2.height = key.height - 1;
   brw_set_surface_tiling(&surf, key.tiling);
   surf.ss3.pitch = (key.pitch * key.cpp) - 1;
d502 18
a519 20
      surf.ss0.color_blend = key.color_blend;
      surf.ss0.writedisable_red =   !key.color_mask[0];
      surf.ss0.writedisable_green = !key.color_mask[1];
      surf.ss0.writedisable_blue =  !key.color_mask[2];
      surf.ss0.writedisable_alpha = !key.color_mask[3];
   }

   map = brw_state_batch(brw, sizeof(surf), 32,
			 &brw->wm.surf_bo[unit],
			 &brw->wm.surf_offset[unit]);
   memcpy(map, &surf, sizeof(surf));

   if (region_bo != NULL) {
      drm_intel_bo_emit_reloc(brw->wm.surf_bo[unit],
			      brw->wm.surf_offset[unit] +
			      offsetof(struct brw_surface_state, ss1),
			      region_bo,
			      surf.ss1.base_addr - region_bo->offset,
			      I915_GEM_DOMAIN_RENDER,
			      I915_GEM_DOMAIN_RENDER);
d521 7
d537 4
a540 5
   if (ctx->DrawBuffer->_NumColorDrawBuffers >= 1) {
      for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++) {
	 struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[i];
	 struct intel_renderbuffer *irb = intel_renderbuffer(rb);
	 struct intel_region *region = irb ? irb->region : NULL;
d542 1
d544 1
a544 2
	 nr_surfaces = SURF_INDEX_DRAW(i) + 1;
      }
a553 2
      struct gl_texture_object *tObj = texUnit->_Current;
      struct intel_texture_object *intelObj = intel_texture_object(tObj);
d556 3
d587 7
a593 3
         brw_update_renderbuffer_surface(brw,
					 ctx->DrawBuffer->_ColorDrawBuffers[i],
					 i);
d596 1
a596 1
      brw_update_renderbuffer_surface(brw, NULL, 0);
d608 1
a608 2
         drm_intel_bo_unreference(brw->wm.surf_bo[surf]);
         brw->wm.surf_bo[surf] = NULL;
d641 1
a641 1
			  32, &brw->wm.bind_bo, &brw->wm.bind_bo_offset);
a645 5
      if (brw->wm.surf_bo[i]) {
	 bind[i] = brw->wm.surf_offset[i];
      } else {
	 bind[i] = 0;
      }
d648 1
a648 1
   brw->state.dirty.brw |= BRW_NEW_BINDING_TABLE;
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d35 1
a35 1
#include "shader/prog_parameter.h"
d92 12
d142 2
d179 2
d215 2
a216 3
static dri_bo *
brw_create_texture_surface( struct brw_context *brw,
			    struct brw_surface_key *key )
d218 5
d224 1
a224 1
   dri_bo *bo;
d229 4
a232 4
   surf.ss0.surface_type = translate_tex_target(key->target);
   surf.ss0.surface_format = translate_tex_format(key->format,
						  key->internal_format,
						  key->depthmode);
d237 1
a237 1
   surf.ss1.base_addr = key->bo->offset; /* reloc */
d239 6
a244 6
   surf.ss2.mip_count = key->last_level - key->first_level;
   surf.ss2.width = key->width - 1;
   surf.ss2.height = key->height - 1;
   brw_set_surface_tiling(&surf, key->tiling);
   surf.ss3.pitch = (key->pitch * key->cpp) - 1;
   surf.ss3.depth = key->depth - 1;
d248 1
a248 1
   if (key->target == GL_TEXTURE_CUBE_MAP) {
d257 4
a260 4
   bo = brw_upload_cache(&brw->surface_cache, BRW_SS_SURFACE,
			 key, sizeof(*key),
			 &key->bo, 1,
			 &surf, sizeof(surf));
d263 4
a266 2
   drm_intel_bo_emit_reloc(bo, offsetof(struct brw_surface_state, ss1),
			   key->bo, 0,
a267 2

   return bo;
a269 41
static void
brw_update_texture_surface( GLcontext *ctx, GLuint unit )
{
   struct brw_context *brw = brw_context(ctx);
   struct gl_texture_object *tObj = ctx->Texture.Unit[unit]._Current;
   struct intel_texture_object *intelObj = intel_texture_object(tObj);
   struct gl_texture_image *firstImage = tObj->Image[0][intelObj->firstLevel];
   struct brw_surface_key key;
   const GLuint surf = SURF_INDEX_TEXTURE(unit);

   memset(&key, 0, sizeof(key));

   key.format = firstImage->TexFormat;
   key.internal_format = firstImage->InternalFormat;
   key.pitch = intelObj->mt->pitch;
   key.depth = firstImage->Depth;
   key.bo = intelObj->mt->region->buffer;
   key.offset = 0;

   key.target = tObj->Target;
   key.depthmode = tObj->DepthMode;
   key.first_level = intelObj->firstLevel;
   key.last_level = intelObj->lastLevel;
   key.width = firstImage->Width;
   key.height = firstImage->Height;
   key.cpp = intelObj->mt->cpp;
   key.tiling = intelObj->mt->region->tiling;

   dri_bo_unreference(brw->wm.surf_bo[surf]);
   brw->wm.surf_bo[surf] = brw_search_cache(&brw->surface_cache,
                                            BRW_SS_SURFACE,
                                            &key, sizeof(key),
                                            &key.bo, 1,
                                            NULL);
   if (brw->wm.surf_bo[surf] == NULL) {
      brw->wm.surf_bo[surf] = brw_create_texture_surface(brw, &key);
   }
}



d274 6
a279 3
dri_bo *
brw_create_constant_surface( struct brw_context *brw,
                             struct brw_surface_key *key )
d281 2
a282 1
   const GLint w = key->width - 1;
d284 1
a284 1
   dri_bo *bo;
d292 5
a296 2
   assert(key->bo);
   surf.ss1.base_addr = key->bo->offset; /* reloc */
d301 5
a305 7
   surf.ss3.pitch = (key->pitch * key->cpp) - 1; /* ignored?? */
   brw_set_surface_tiling(&surf, key->tiling); /* tiling now allowed */
 
   bo = brw_upload_cache(&brw->surface_cache, BRW_SS_SURFACE,
			 key, sizeof(*key),
			 &key->bo, 1,
			 &surf, sizeof(surf));
d311 3
a313 2
   drm_intel_bo_emit_reloc(bo, offsetof(struct brw_surface_state, ss1),
			   key->bo, 0,
a314 2

   return bo;
d323 2
a324 2
static drm_intel_bo *
brw_wm_update_constant_buffer(struct brw_context *brw)
d326 1
d330 5
a334 3
   const struct gl_program_parameter_list *params = fp->program.Base.Parameters;
   const int size = params->NumParameters * 4 * sizeof(GLfloat);
   drm_intel_bo *const_buffer;
d337 8
a344 2
   if (!fp->use_const_buffer)
      return NULL;
d346 3
a348 2
   const_buffer = drm_intel_bo_alloc(intel->bufmgr, "fp_const_buffer",
				     size, 64);
d351 7
a357 1
   dri_bo_subdata(const_buffer, 0, size, params->ParameterValues);
d359 1
a359 1
   return const_buffer;
d362 8
a369 59
/**
 * Update the surface state for a WM constant buffer.
 * The constant buffer will be (re)allocated here if needed.
 */
static void
brw_update_wm_constant_surface( GLcontext *ctx,
                                GLuint surf)
{
   struct brw_context *brw = brw_context(ctx);
   struct brw_surface_key key;
   struct brw_fragment_program *fp =
      (struct brw_fragment_program *) brw->fragment_program;
   const struct gl_program_parameter_list *params =
      fp->program.Base.Parameters;

   /* If we're in this state update atom, we need to update WM constants, so
    * free the old buffer and create a new one for the new contents.
    */
   dri_bo_unreference(fp->const_buffer);
   fp->const_buffer = brw_wm_update_constant_buffer(brw);

   /* If there's no constant buffer, then no surface BO is needed to point at
    * it.
    */
   if (fp->const_buffer == NULL) {
      drm_intel_bo_unreference(brw->wm.surf_bo[surf]);
      brw->wm.surf_bo[surf] = NULL;
      return;
   }

   memset(&key, 0, sizeof(key));

   key.format = MESA_FORMAT_RGBA_FLOAT32;
   key.internal_format = GL_RGBA;
   key.bo = fp->const_buffer;
   key.depthmode = GL_NONE;
   key.pitch = params->NumParameters;
   key.width = params->NumParameters;
   key.height = 1;
   key.depth = 1;
   key.cpp = 16;

   /*
   printf("%s:\n", __FUNCTION__);
   printf("  width %d  height %d  depth %d  cpp %d  pitch %d\n",
          key.width, key.height, key.depth, key.cpp, key.pitch);
   */

   dri_bo_unreference(brw->wm.surf_bo[surf]);
   brw->wm.surf_bo[surf] = brw_search_cache(&brw->surface_cache,
                                            BRW_SS_SURFACE,
                                            &key, sizeof(key),
                                            &key.bo, 1,
                                            NULL);
   if (brw->wm.surf_bo[surf] == NULL) {
      brw->wm.surf_bo[surf] = brw_create_constant_surface(brw, &key);
   }
   brw->state.dirty.brw |= BRW_NEW_WM_SURFACES;
}
d379 1
a379 1
static void prepare_wm_constant_surface(struct brw_context *brw )
d381 1
a381 1
   GLcontext *ctx = &brw->intel.ctx;
d384 2
a385 4
   GLuint surf = SURF_INDEX_FRAG_CONST_BUFFER;

   drm_intel_bo_unreference(fp->const_buffer);
   fp->const_buffer = brw_wm_update_constant_buffer(brw);
d390 1
a390 1
   if (fp->const_buffer == 0) {
d399 4
a402 1
   brw_update_wm_constant_surface(ctx, surf);
d407 3
a409 2
      .mesa = (_NEW_PROGRAM_CONSTANTS),
      .brw = (BRW_NEW_FRAGMENT_PROGRAM),
d412 1
a412 1
   .prepare = prepare_wm_constant_surface,
d427 2
a428 2
   GLcontext *ctx = &intel->ctx;
   dri_bo *region_bo = NULL;
d441 2
d461 3
d473 15
d492 2
a493 7
      if (brw->intel.intelScreen->driScrnPriv->dri2.enabled) {
	 key.width = rb->Width;
	 key.height = rb->Height;
      } else {
	 key.width = region->width;
	 key.height = region->height;
      }
d524 1
a524 19
   dri_bo_unreference(brw->wm.surf_bo[unit]);
   brw->wm.surf_bo[unit] = brw_search_cache(&brw->surface_cache,
					    BRW_SS_SURFACE,
					    &key, sizeof(key),
					    &region_bo, 1,
					    NULL);

   if (brw->wm.surf_bo[unit] == NULL) {
      struct brw_surface_state surf;

      memset(&surf, 0, sizeof(surf));

      surf.ss0.surface_format = key.surface_format;
      surf.ss0.surface_type = key.surface_type;
      if (key.tiling == I915_TILING_NONE) {
	 surf.ss1.base_addr = (key.draw_x + key.draw_y * key.pitch) * key.cpp;
      } else {
	 uint32_t tile_base, tile_x, tile_y;
	 uint32_t pitch = key.pitch * key.cpp;
d526 7
a532 24
	 if (key.tiling == I915_TILING_X) {
	    tile_x = key.draw_x % (512 / key.cpp);
	    tile_y = key.draw_y % 8;
	    tile_base = ((key.draw_y / 8) * (8 * pitch));
	    tile_base += (key.draw_x - tile_x) / (512 / key.cpp) * 4096;
	 } else {
	    /* Y */
	    tile_x = key.draw_x % (128 / key.cpp);
	    tile_y = key.draw_y % 32;
	    tile_base = ((key.draw_y / 32) * (32 * pitch));
	    tile_base += (key.draw_x - tile_x) / (128 / key.cpp) * 4096;
	 }
	 assert(brw->has_surface_tile_offset || (tile_x == 0 && tile_y == 0));
	 assert(tile_x % 4 == 0);
	 assert(tile_y % 2 == 0);
	 /* Note that the low bits of these fields are missing, so
	  * there's the possibility of getting in trouble.
	  */
	 surf.ss1.base_addr = tile_base;
	 surf.ss5.x_offset = tile_x / 4;
	 surf.ss5.y_offset = tile_y / 2;
      }
      if (region_bo != NULL)
	 surf.ss1.base_addr += region_bo->offset; /* reloc */
d534 11
a544 12
      surf.ss2.width = key.width - 1;
      surf.ss2.height = key.height - 1;
      brw_set_surface_tiling(&surf, key.tiling);
      surf.ss3.pitch = (key.pitch * key.cpp) - 1;

      if (intel->gen < 6) {
	 /* _NEW_COLOR */
	 surf.ss0.color_blend = key.color_blend;
	 surf.ss0.writedisable_red =   !key.color_mask[0];
	 surf.ss0.writedisable_green = !key.color_mask[1];
	 surf.ss0.writedisable_blue =  !key.color_mask[2];
	 surf.ss0.writedisable_alpha = !key.color_mask[3];
d546 17
d564 22
a585 18
      /* Key size will never match key size for textures, so we're safe. */
      brw->wm.surf_bo[unit] = brw_upload_cache(&brw->surface_cache,
                                               BRW_SS_SURFACE,
                                               &key, sizeof(key),
					       &region_bo, 1,
					       &surf, sizeof(surf));
      if (region_bo != NULL) {
	 /* We might sample from it, and we might render to it, so flag
	  * them both.  We might be able to figure out from other state
	  * a more restrictive relocation to emit.
	  */
	 drm_intel_bo_emit_reloc(brw->wm.surf_bo[unit],
				 offsetof(struct brw_surface_state, ss1),
				 region_bo,
				 surf.ss1.base_addr - region_bo->offset,
				 I915_GEM_DOMAIN_RENDER,
				 I915_GEM_DOMAIN_RENDER);
      }
d589 12
d602 9
a610 8
/**
 * Constructs the binding table for the WM surface state, which maps unit
 * numbers to surface state objects.
 */
static dri_bo *
brw_wm_get_binding_table(struct brw_context *brw)
{
   dri_bo *bind_bo;
d612 4
a615 1
   assert(brw->wm.nr_surfaces <= BRW_WM_MAX_SURF);
d617 3
a619 30
   bind_bo = brw_search_cache(&brw->surface_cache, BRW_SS_SURF_BIND,
			      NULL, 0,
			      brw->wm.surf_bo, brw->wm.nr_surfaces,
			      NULL);

   if (bind_bo == NULL) {
      GLuint data_size = brw->wm.nr_surfaces * sizeof(GLuint);
      uint32_t data[BRW_WM_MAX_SURF];
      int i;

      for (i = 0; i < brw->wm.nr_surfaces; i++)
         if (brw->wm.surf_bo[i])
            data[i] = brw->wm.surf_bo[i]->offset;
         else
            data[i] = 0;

      bind_bo = brw_upload_cache( &brw->surface_cache, BRW_SS_SURF_BIND,
				  NULL, 0,
				  brw->wm.surf_bo, brw->wm.nr_surfaces,
				  data, data_size);

      /* Emit binding table relocations to surface state */
      for (i = 0; i < BRW_WM_MAX_SURF; i++) {
	 if (brw->wm.surf_bo[i] != NULL) {
	    dri_bo_emit_reloc(bind_bo,
			      I915_GEM_DOMAIN_INSTRUCTION, 0,
			      0,
			      i * sizeof(GLuint),
			      brw->wm.surf_bo[i]);
	 }
d623 7
a629 1
   return bind_bo;
d632 6
a637 1
static void prepare_wm_surfaces(struct brw_context *brw )
d639 1
a639 1
   GLcontext *ctx = &brw->intel.ctx;
a640 1
   int old_nr_surfaces;
a653 6
   old_nr_surfaces = brw->wm.nr_surfaces;
   brw->wm.nr_surfaces = BRW_MAX_DRAW_BUFFERS;

   if (brw->wm.surf_bo[SURF_INDEX_FRAG_CONST_BUFFER] != NULL)
       brw->wm.nr_surfaces = SURF_INDEX_FRAG_CONST_BUFFER + 1;

d659 1
a659 1
      /* _NEW_TEXTURE, BRW_NEW_TEXDATA */
a661 1
	 brw->wm.nr_surfaces = surf + 1;
d663 1
a663 1
         dri_bo_unreference(brw->wm.surf_bo[surf]);
d668 1
a668 5
   dri_bo_unreference(brw->wm.bind_bo);
   brw->wm.bind_bo = brw_wm_get_binding_table(brw);

   if (brw->wm.nr_surfaces != old_nr_surfaces)
      brw->state.dirty.brw |= BRW_NEW_NR_WM_SURFACES;
d676 1
a676 2
      .brw = (BRW_NEW_CONTEXT |
	      BRW_NEW_WM_SURFACES),
d680 1
d683 15
d699 12
d712 9
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a33 1
#include "main/texformat.h"
d35 1
d40 1
a40 1

d72 3
a74 1
static GLuint translate_tex_format( GLuint mesa_format, GLenum depth_mode )
d89 3
d99 3
d103 1
d145 9
a153 2
   case MESA_FORMAT_SRGBA8:
      return BRW_SURFACEFORMAT_R8G8B8A8_UNORM_SRGB;
d158 15
a172 1
      return BRW_SURFACEFORMAT_I24X8_UNORM;
a179 11
struct brw_wm_surface_key {
   GLenum target, depthmode;
   dri_bo *bo;
   GLint format;
   GLint first_level, last_level;
   GLint width, height, depth;
   GLint pitch, cpp;
   uint32_t tiling;
   GLuint offset;
};

d201 1
a201 1
			    struct brw_wm_surface_key *key )
d210 3
a212 17

   if (key->bo) 
      surf.ss0.surface_format = translate_tex_format(key->format, key->depthmode);
   else {
      switch (key->depth) {
      case 32:
         surf.ss0.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
         break;
      default:
      case 24:
         surf.ss0.surface_format = BRW_SURFACEFORMAT_B8G8R8X8_UNORM;
         break;
      case 16:
         surf.ss0.surface_format = BRW_SURFACEFORMAT_B5G6R5_UNORM;
         break;
      }
   }
d217 1
a217 4
   if (key->bo)
      surf.ss1.base_addr = key->bo->offset; /* reloc */
   else
      surf.ss1.base_addr = key->offset;
d237 1
a237 1
   bo = brw_upload_cache(&brw->cache, BRW_SS_SURFACE,
d239 8
a246 12
			 &key->bo, key->bo ? 1 : 0,
			 &surf, sizeof(surf),
			 NULL, NULL);

   if (key->bo) {
      /* Emit relocation to surface contents */
      dri_bo_emit_reloc(bo,
			I915_GEM_DOMAIN_SAMPLER, 0,
			0,
			offsetof(struct brw_surface_state, ss1),
			key->bo);
   }
d257 2
a258 1
   struct brw_wm_surface_key key;
d262 6
a267 12
   if (intelObj->imageOverride) {
      key.pitch = intelObj->pitchOverride / intelObj->mt->cpp;
      key.depth = intelObj->depthOverride;
      key.bo = NULL;
      key.offset = intelObj->textureOffset;
   } else {
      key.format = firstImage->TexFormat->MesaFormat;
      key.pitch = intelObj->mt->pitch;
      key.depth = firstImage->Depth;
      key.bo = intelObj->mt->region->buffer;
      key.offset = 0;
   }
d278 113
a390 7
   dri_bo_unreference(brw->wm.surf_bo[unit + MAX_DRAW_BUFFERS]);
   brw->wm.surf_bo[unit + MAX_DRAW_BUFFERS] = brw_search_cache(&brw->cache, BRW_SS_SURFACE,
							       &key, sizeof(key),
							       &key.bo, key.bo ? 1 : 0,
							       NULL);
   if (brw->wm.surf_bo[unit + MAX_DRAW_BUFFERS] == NULL) {
      brw->wm.surf_bo[unit + MAX_DRAW_BUFFERS] = brw_create_texture_surface(brw, &key);
d392 29
d424 43
d472 3
a474 2
brw_update_region_surface(struct brw_context *brw, struct intel_region *region,
			  unsigned int unit, GLboolean cached)
d476 2
a477 1
   GLcontext *ctx = &brw->intel.ctx;
d479 2
d484 1
a484 1
      unsigned int width, height, cpp;
d488 2
a489 1
      uint32_t draw_offset;
d498 9
a506 1
      if (region->cpp == 4)
d508 2
a509 1
      else
d511 10
d522 8
a529 2
      key.width = region->pitch; /* XXX: not really! */
      key.height = region->height;
d531 2
a532 1
      key.draw_offset = region->draw_offset; /* cur 3d or cube face offset */
d536 1
a536 1
      key.tiling = 0;
d540 17
a556 1
      key.draw_offset = 0;
a557 4
   memcpy(key.color_mask, ctx->Color.ColorMask,
	  sizeof(key.color_mask));
   key.color_blend = (!ctx->Color._LogicOpEnabled &&
		      ctx->Color.BlendEnabled);
d560 5
a564 6
   brw->wm.surf_bo[unit] = NULL;
   if (cached) 
       brw->wm.surf_bo[unit] = brw_search_cache(&brw->cache, BRW_SS_SURFACE,
	       &key, sizeof(key),
	       &region_bo, 1,
	       NULL);
d573 28
a600 1
      surf.ss1.base_addr =  key.draw_offset;
d607 1
a607 1
      surf.ss3.pitch = (key.width * key.cpp) - 1;
d609 8
a616 6
      /* _NEW_COLOR */
      surf.ss0.color_blend = key.color_blend;
      surf.ss0.writedisable_red =   !key.color_mask[0];
      surf.ss0.writedisable_green = !key.color_mask[1];
      surf.ss0.writedisable_blue =  !key.color_mask[2];
      surf.ss0.writedisable_alpha = !key.color_mask[3];
d619 3
a621 2
      brw->wm.surf_bo[unit] = brw_upload_cache(&brw->cache, BRW_SS_SURFACE,
					      &key, sizeof(key),
d623 1
a623 2
					       &surf, sizeof(surf),
					       NULL, NULL);
d632 1
a632 1
				 key.draw_offset,
d649 3
a651 1
   bind_bo = brw_search_cache(&brw->cache, BRW_SS_SURF_BIND,
d658 1
a658 1
      uint32_t *data = malloc(data_size);
d667 1
a667 1
      bind_bo = brw_upload_cache( &brw->cache, BRW_SS_SURF_BIND,
d670 1
a670 2
				  data, data_size,
				  NULL, NULL);
a681 2

      free(data);
a689 1
   struct intel_context *intel = &brw->intel;
d693 7
a699 4
   if (brw->state.nr_draw_regions  > 1) {
      for (i = 0; i < brw->state.nr_draw_regions; i++) {
         brw_update_region_surface(brw, brw->state.draw_regions[i], i,
				   GL_FALSE);
d701 2
a702 2
   }else {
      brw_update_region_surface(brw, brw->state.draw_regions[0], 0, GL_TRUE);
d706 1
a706 1
   brw->wm.nr_surfaces = MAX_DRAW_BUFFERS;
d708 4
d713 2
a714 1
      struct gl_texture_unit *texUnit = &ctx->Texture.Unit[i];
d717 3
a719 10
      if(texUnit->_ReallyEnabled) {
         if (texUnit->_Current == intel->frame_buffer_texobj) {
            dri_bo_unreference(brw->wm.surf_bo[i+MAX_DRAW_BUFFERS]);
            brw->wm.surf_bo[i+MAX_DRAW_BUFFERS] = brw->wm.surf_bo[0];
            dri_bo_reference(brw->wm.surf_bo[i+MAX_DRAW_BUFFERS]);
            brw->wm.nr_surfaces = i + MAX_DRAW_BUFFERS + 1;
         } else {
            brw_update_texture_surface(ctx, i);
            brw->wm.nr_surfaces = i + MAX_DRAW_BUFFERS + 1;
         }
d721 2
a722 2
         dri_bo_unreference(brw->wm.surf_bo[i+MAX_DRAW_BUFFERS]);
         brw->wm.surf_bo[i+MAX_DRAW_BUFFERS] = NULL;
a723 1

d730 1
a730 1
      brw->state.dirty.brw |= BRW_NEW_NR_SURFACES;
a732 1

d735 5
a739 2
      .mesa = _NEW_COLOR | _NEW_TEXTURE | _NEW_BUFFERS,
      .brw = BRW_NEW_CONTEXT,
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d33 3
a35 3
#include "mtypes.h"
#include "texformat.h"
#include "texstore.h"
d157 1
a157 1
   GLboolean tiled;
d161 19
d195 12
a206 6
     switch(key->depth) {
     case 32: surf.ss0.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM; break;
     default:
     case 24: surf.ss0.surface_format = BRW_SURFACEFORMAT_B8G8R8X8_UNORM; break;
     case 16: surf.ss0.surface_format = BRW_SURFACEFORMAT_B5G6R5_UNORM; break;
     }
d213 1
a213 1
     surf.ss1.base_addr = key->bo->offset; /* reloc */
d215 1
a215 1
     surf.ss1.base_addr = key->offset;
d220 1
a220 3

   surf.ss3.tile_walk = BRW_TILEWALK_XMAJOR;
   surf.ss3.tiled_surface = key->tiled;
d240 1
d243 5
a247 5
      dri_emit_reloc(bo,
		     DRM_BO_FLAG_MEM_TT | DRM_BO_FLAG_READ,
		     0,
		     offsetof(struct brw_surface_state, ss1),
		     key->bo);
d252 1
a252 1
static int
d256 1
a256 1
   struct gl_texture_object *tObj = brw->attribs.Texture->Unit[unit]._Current;
a259 1
   int ret = 0;
a273 1
      ret |= dri_bufmgr_check_aperture_space(key.bo);
d283 1
a283 1
   key.tiled = intelObj->mt->region->tiled;
a292 3

   ret |= dri_bufmgr_check_aperture_space(brw->wm.surf_bo[unit + MAX_DRAW_BUFFERS]);
   return ret;
d300 1
a300 1
static int
d304 1
a305 1
   int ret = 0;
d311 3
a313 1
      GLboolean tiled, color_blend;
d326 1
a326 1
      key.tiled = region->tiled;
d330 1
a330 2

      ret |= dri_bufmgr_check_aperture_space(region->buffer);
d334 1
a334 1
      key.tiled = 0;
d338 1
d340 1
a340 1
   memcpy(key.color_mask, brw->attribs.Color->ColorMask,
d342 2
a343 2
   key.color_blend = (!brw->attribs.Color->_LogicOpEnabled &&
		      brw->attribs.Color->BlendEnabled);
d360 1
d362 1
a362 1
	 surf.ss1.base_addr = region_bo->offset; /* reloc */
d366 1
a366 2
      surf.ss3.tile_walk = BRW_TILEWALK_XMAJOR;
      surf.ss3.tiled_surface = key.tiled;
d383 10
a392 7
	 dri_emit_reloc(brw->wm.surf_bo[unit],
			DRM_BO_FLAG_MEM_TT |
			DRM_BO_FLAG_READ |
			DRM_BO_FLAG_WRITE,
			0,
			offsetof(struct brw_surface_state, ss1),
			region_bo);
a394 4

   ret |= dri_bufmgr_check_aperture_space(brw->wm.surf_bo[unit]);

   return ret;
d432 5
a436 7
	    dri_emit_reloc(bind_bo,
			   DRM_BO_FLAG_MEM_TT |
			   DRM_BO_FLAG_READ |
			   DRM_BO_FLAG_WRITE,
			   0,
			   i * sizeof(GLuint),
			   brw->wm.surf_bo[i]);
d446 1
a446 1
static int prepare_wm_surfaces(struct brw_context *brw )
d450 2
a451 1
   GLuint i, ret;
d455 2
a456 4
         ret = brw_update_region_surface(brw, brw->state.draw_regions[i], i,
                                         GL_FALSE);
         if (ret)
            return ret;
d459 1
a459 3
      ret = brw_update_region_surface(brw, brw->state.draw_regions[0], 0, GL_TRUE);
      if (ret)
         return ret;
d462 1
d466 1
a466 1
      struct gl_texture_unit *texUnit = &brw->attribs.Texture->Unit[i];
d476 1
a476 1
            ret = brw_update_texture_surface(ctx, i);
a477 3

            if (ret)
               return ret;
d489 2
a490 1
   return dri_bufmgr_check_aperture_space(brw->wm.bind_bo);
@


1.1
log
@Initial revision
@
text
@d72 1
a72 1
static GLuint translate_tex_format( GLuint mesa_format )
d88 2
a89 1
      return BRW_SURFACEFORMAT_R8G8B8_UNORM;
d97 9
d117 9
a125 1
      return BRW_SURFACEFORMAT_L16_UNORM;
d128 15
a142 2
   case MESA_FORMAT_RGB_DXT1:
      return BRW_SURFACEFORMAT_DXT1_RGB;
d150 14
a163 4
static
void brw_update_texture_surface( GLcontext *ctx, 
				 GLuint unit,
				 struct brw_surface_state *surf )
d165 4
a168 5
   struct intel_context *intel = intel_context(ctx);
   struct brw_context *brw = brw_context(ctx);
   struct gl_texture_object *tObj = brw->attribs.Texture->Unit[unit]._Current;
   struct intel_texture_object *intelObj = intel_texture_object(tObj);
   struct gl_texture_image *firstImage = tObj->Image[0][intelObj->firstLevel];
d170 2
a171 1
   memset(surf, 0, sizeof(*surf));
d173 10
a182 3
   surf->ss0.mipmap_layout_mode = BRW_SURFACE_MIPMAPLAYOUT_BELOW;   
   surf->ss0.surface_type = translate_tex_target(tObj->Target);
   surf->ss0.surface_format = translate_tex_format(firstImage->TexFormat->MesaFormat);
d186 14
a199 1
/*    surf->ss0.data_return_format = BRW_SURFACERETURNFORMAT_S1; */
d201 10
a210 12
   /* BRW_NEW_LOCK */
   surf->ss1.base_addr = bmBufferOffset(intel,
					intelObj->mt->region->buffer);

   surf->ss2.mip_count = intelObj->lastLevel - intelObj->firstLevel;
   surf->ss2.width = firstImage->Width - 1;
   surf->ss2.height = firstImage->Height - 1;

   surf->ss3.tile_walk = BRW_TILEWALK_XMAJOR;
   surf->ss3.tiled_surface = intelObj->mt->region->tiled; /* always zero */
   surf->ss3.pitch = (intelObj->mt->pitch * intelObj->mt->cpp) - 1;
   surf->ss3.depth = firstImage->Depth - 1;
d212 12
a223 9
   surf->ss4.min_lod = 0;
 
   if (tObj->Target == GL_TEXTURE_CUBE_MAP) {
      surf->ss0.cube_pos_x = 1;
      surf->ss0.cube_pos_y = 1;
      surf->ss0.cube_pos_z = 1;
      surf->ss0.cube_neg_x = 1;
      surf->ss0.cube_neg_y = 1;
      surf->ss0.cube_neg_z = 1;
d225 1
d228 9
d238 1
d240 31
a270 1
#define OFFSET(TYPE, FIELD) ( (GLuint)&(((TYPE *)0)->FIELD) )
d272 3
d276 8
a283 1
static void upload_wm_surfaces(struct brw_context *brw )
d285 46
a330 4
   GLcontext *ctx = &brw->intel.ctx;
   struct intel_context *intel = &brw->intel;
   struct brw_surface_binding_table bind;
   GLuint i;
d332 1
a332 3
   memcpy(&bind, &brw->wm.bind, sizeof(bind));
      
   {
a333 1
      struct intel_region *region = brw->state.draw_region;
d337 4
a340 4
      if (region->cpp == 4)
	 surf.ss0.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
      else 
	 surf.ss0.surface_format = BRW_SURFACEFORMAT_B5G6R5_UNORM;
d342 5
a346 1
      surf.ss0.surface_type = BRW_SURFACE_2D;
d349 22
a370 2
      surf.ss0.color_blend = (!brw->attribs.Color->_LogicOpEnabled &&
			      brw->attribs.Color->BlendEnabled);
d372 1
d374 2
a375 4
      surf.ss0.writedisable_red =   !brw->attribs.Color->ColorMask[0];
      surf.ss0.writedisable_green = !brw->attribs.Color->ColorMask[1];
      surf.ss0.writedisable_blue =  !brw->attribs.Color->ColorMask[2];
      surf.ss0.writedisable_alpha = !brw->attribs.Color->ColorMask[3];
a376 2
      /* BRW_NEW_LOCK */
      surf.ss1.base_addr = bmBufferOffset(&brw->intel, region->buffer);
d378 8
d387 34
a420 5
      surf.ss2.width = region->pitch - 1; /* XXX: not really! */
      surf.ss2.height = region->height - 1;
      surf.ss3.tile_walk = BRW_TILEWALK_XMAJOR;
      surf.ss3.tiled_surface = region->tiled;
      surf.ss3.pitch = (region->pitch * region->cpp) - 1;
d422 1
a422 2
      brw->wm.bind.surf_ss_offset[0] = brw_cache_data( &brw->cache[BRW_SS_SURFACE], &surf );
      brw->wm.nr_surfaces = 1;
d425 2
d428 5
a432 2
   for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
      struct gl_texture_unit *texUnit = &brw->attribs.Texture->Unit[i];
d434 12
a445 4
      /* _NEW_TEXTURE, BRW_NEW_TEXDATA 
       */
      if (texUnit->_ReallyEnabled &&
	  intel_finalize_mipmap_tree(intel,texUnit->_Current)) {
d447 1
a447 1
	 struct brw_surface_state surf;
d449 2
a450 1
	 brw_update_texture_surface(ctx, i, &surf);
d452 17
a468 5
	 brw->wm.bind.surf_ss_offset[i+1] = brw_cache_data( &brw->cache[BRW_SS_SURFACE], &surf );
	 brw->wm.nr_surfaces = i+2;
      }
      else {
	 brw->wm.bind.surf_ss_offset[i+1] = 0;
d470 1
d473 4
a476 2
   brw->wm.bind_ss_offset = brw_cache_data( &brw->cache[BRW_SS_SURF_BIND],
					    &brw->wm.bind );
d479 1
d483 1
a483 2
      .brw = (BRW_NEW_CONTEXT | 
	      BRW_NEW_LOCK),	/* required for bmBufferOffset */
d486 1
a486 1
   .update = upload_wm_surfaces
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d88 1
a88 2
      assert(0);		/* not supported for sampling */
      return BRW_SURFACEFORMAT_R8G8B8_UNORM;      
a95 9
   case MESA_FORMAT_RGB565:
      return BRW_SURFACEFORMAT_B5G6R5_UNORM;

   case MESA_FORMAT_ARGB1555:
      return BRW_SURFACEFORMAT_B5G5R5A1_UNORM;

   case MESA_FORMAT_ARGB4444:
      return BRW_SURFACEFORMAT_B4G4R4A4_UNORM;

a231 6
      else if( texUnit->_ReallyEnabled &&
	       texUnit->_Current == intel->frame_buffer_texobj )
      {
	 brw->wm.bind.surf_ss_offset[i+1] = brw->wm.bind.surf_ss_offset[0];
	 brw->wm.nr_surfaces = i+2;
      }    
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d33 3
a35 3
#include "main/mtypes.h"
#include "main/texstore.h"
#include "program/prog_parameter.h"
d40 1
a40 1
#include "intel_fbo.h"
d72 1
a72 3
static GLuint translate_tex_format( gl_format mesa_format,
                                    GLenum internal_format,
				    GLenum depth_mode )
a86 15
   case MESA_FORMAT_AL1616:
      return BRW_SURFACEFORMAT_L16A16_UNORM;

   case MESA_FORMAT_R8:
      return BRW_SURFACEFORMAT_R8_UNORM;

   case MESA_FORMAT_R16:
      return BRW_SURFACEFORMAT_R16_UNORM;

   case MESA_FORMAT_RG88:
      return BRW_SURFACEFORMAT_R8G8_UNORM;

   case MESA_FORMAT_RG1616:
      return BRW_SURFACEFORMAT_R16G16_UNORM;

a93 3
   case MESA_FORMAT_XRGB8888:
      return BRW_SURFACEFORMAT_B8G8R8X8_UNORM;

a94 1
      _mesa_problem(NULL, "unexpected format in i965:translate_tex_format()");
d117 1
a117 8
      if (depth_mode == GL_INTENSITY) 
	  return BRW_SURFACEFORMAT_I16_UNORM;
      else if (depth_mode == GL_ALPHA)
	  return BRW_SURFACEFORMAT_A16_UNORM;
      else if (depth_mode == GL_RED)
	  return BRW_SURFACEFORMAT_R16_UNORM;
      else
	  return BRW_SURFACEFORMAT_L16_UNORM;
d119 1
d121 1
a121 41
       return BRW_SURFACEFORMAT_DXT1_RGB;

   case MESA_FORMAT_RGBA_DXT1:
       return BRW_SURFACEFORMAT_BC1_UNORM;
       
   case MESA_FORMAT_RGBA_DXT3:
       return BRW_SURFACEFORMAT_BC2_UNORM;
       
   case MESA_FORMAT_RGBA_DXT5:
       return BRW_SURFACEFORMAT_BC3_UNORM;

   case MESA_FORMAT_SARGB8:
      return BRW_SURFACEFORMAT_B8G8R8A8_UNORM_SRGB;

   case MESA_FORMAT_SLA8:
      return BRW_SURFACEFORMAT_L8A8_UNORM_SRGB;

   case MESA_FORMAT_SL8:
      return BRW_SURFACEFORMAT_L8_UNORM_SRGB;

   case MESA_FORMAT_SRGB_DXT1:
      return BRW_SURFACEFORMAT_BC1_UNORM_SRGB;

   case MESA_FORMAT_S8_Z24:
      /* XXX: these different surface formats don't seem to
       * make any difference for shadow sampler/compares.
       */
      if (depth_mode == GL_INTENSITY) 
         return BRW_SURFACEFORMAT_I24X8_UNORM;
      else if (depth_mode == GL_ALPHA)
         return BRW_SURFACEFORMAT_A24X8_UNORM;
      else if (depth_mode == GL_RED)
         return BRW_SURFACEFORMAT_R24_UNORM_X8_TYPELESS;
      else
         return BRW_SURFACEFORMAT_L24X8_UNORM;

   case MESA_FORMAT_DUDV8:
      return BRW_SURFACEFORMAT_R8G8_SNORM;

   case MESA_FORMAT_SIGNED_RGBA8888_REV:
      return BRW_SURFACEFORMAT_R8G8B8A8_SNORM;
d129 4
a132 21
static void
brw_set_surface_tiling(struct brw_surface_state *surf, uint32_t tiling)
{
   switch (tiling) {
   case I915_TILING_NONE:
      surf->ss3.tiled_surface = 0;
      surf->ss3.tile_walk = 0;
      break;
   case I915_TILING_X:
      surf->ss3.tiled_surface = 1;
      surf->ss3.tile_walk = BRW_TILEWALK_XMAJOR;
      break;
   case I915_TILING_Y:
      surf->ss3.tiled_surface = 1;
      surf->ss3.tile_walk = BRW_TILEWALK_YMAJOR;
      break;
   }
}

static void
brw_update_texture_surface( struct gl_context *ctx, GLuint unit )
d134 1
d136 1
a136 1
   struct gl_texture_object *tObj = ctx->Texture.Unit[unit]._Current;
d139 6
a144 11
   const GLuint surf_index = SURF_INDEX_TEXTURE(unit);
   struct brw_surface_state surf;
   void *map;

   memset(&surf, 0, sizeof(surf));

   surf.ss0.mipmap_layout_mode = BRW_SURFACE_MIPMAPLAYOUT_BELOW;
   surf.ss0.surface_type = translate_tex_target(tObj->Target);
   surf.ss0.surface_format = translate_tex_format(firstImage->TexFormat,
						  firstImage->InternalFormat,
						  tObj->DepthMode);
d148 1
a148 2
/*    surf.ss0.data_return_format = BRW_SURFACERETURNFORMAT_S1; */
   surf.ss1.base_addr = intelObj->mt->region->buffer->offset; /* reloc */
d150 12
a161 6
   surf.ss2.mip_count = intelObj->lastLevel - intelObj->firstLevel;
   surf.ss2.width = firstImage->Width - 1;
   surf.ss2.height = firstImage->Height - 1;
   brw_set_surface_tiling(&surf, intelObj->mt->region->tiling);
   surf.ss3.pitch = (intelObj->mt->region->pitch * intelObj->mt->cpp) - 1;
   surf.ss3.depth = firstImage->Depth - 1;
d163 1
a163 1
   surf.ss4.min_lod = 0;
d166 6
a171 6
      surf.ss0.cube_pos_x = 1;
      surf.ss0.cube_pos_y = 1;
      surf.ss0.cube_pos_z = 1;
      surf.ss0.cube_neg_x = 1;
      surf.ss0.cube_neg_y = 1;
      surf.ss0.cube_neg_z = 1;
a172 59

   map = brw_state_batch(brw, sizeof(surf), 32,
			 &brw->wm.surf_bo[surf_index],
			 &brw->wm.surf_offset[surf_index]);
   memcpy(map, &surf, sizeof(surf));

   /* Emit relocation to surface contents */
   drm_intel_bo_emit_reloc(brw->wm.surf_bo[surf_index],
			   brw->wm.surf_offset[surf_index] +
			   offsetof(struct brw_surface_state, ss1),
			   intelObj->mt->region->buffer, 0,
			   I915_GEM_DOMAIN_SAMPLER, 0);
}

/**
 * Create the constant buffer surface.  Vertex/fragment shader constants will be
 * read from this buffer with Data Port Read instructions/messages.
 */
void
brw_create_constant_surface(struct brw_context *brw,
			    drm_intel_bo *bo,
			    int width,
			    drm_intel_bo **out_bo,
			    uint32_t *out_offset)
{
   struct intel_context *intel = &brw->intel;
   const GLint w = width - 1;
   struct brw_surface_state surf;
   void *map;

   memset(&surf, 0, sizeof(surf));

   surf.ss0.mipmap_layout_mode = BRW_SURFACE_MIPMAPLAYOUT_BELOW;
   surf.ss0.surface_type = BRW_SURFACE_BUFFER;
   surf.ss0.surface_format = BRW_SURFACEFORMAT_R32G32B32A32_FLOAT;

   if (intel->gen >= 6)
      surf.ss0.render_cache_read_write = 1;

   assert(bo);
   surf.ss1.base_addr = bo->offset; /* reloc */

   surf.ss2.width = w & 0x7f;            /* bits 6:0 of size or width */
   surf.ss2.height = (w >> 7) & 0x1fff;  /* bits 19:7 of size or width */
   surf.ss3.depth = (w >> 20) & 0x7f;    /* bits 26:20 of size or width */
   surf.ss3.pitch = (width * 16) - 1; /* ignored?? */
   brw_set_surface_tiling(&surf, I915_TILING_NONE); /* tiling now allowed */

   map = brw_state_batch(brw, sizeof(surf), 32, out_bo, out_offset);
   memcpy(map, &surf, sizeof(surf));

   /* Emit relocation to surface contents.  Section 5.1.1 of the gen4
    * bspec ("Data Cache") says that the data cache does not exist as
    * a separate cache and is just the sampler cache.
    */
   drm_intel_bo_emit_reloc(*out_bo, (*out_offset +
				     offsetof(struct brw_surface_state, ss1)),
			   bo, 0,
			   I915_GEM_DOMAIN_SAMPLER, 0);
a174 28
/* Creates a new WM constant buffer reflecting the current fragment program's
 * constants, if needed by the fragment program.
 *
 * Otherwise, constants go through the CURBEs using the brw_constant_buffer
 * state atom.
 */
static void
prepare_wm_constants(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->intel.ctx;
   struct intel_context *intel = &brw->intel;
   struct brw_fragment_program *fp =
      (struct brw_fragment_program *) brw->fragment_program;
   const int size = brw->wm.prog_data->nr_pull_params * sizeof(float);
   float *constants;
   unsigned int i;

   _mesa_load_state_parameters(ctx, fp->program.Base.Parameters);

   /* BRW_NEW_FRAGMENT_PROGRAM */
   if (brw->wm.prog_data->nr_pull_params == 0) {
      if (brw->wm.const_bo) {
	 drm_intel_bo_unreference(brw->wm.const_bo);
	 brw->wm.const_bo = NULL;
	 brw->state.dirty.brw |= BRW_NEW_WM_CONSTBUF;
      }
      return;
   }
a175 12
   drm_intel_bo_unreference(brw->wm.const_bo);
   brw->wm.const_bo = drm_intel_bo_alloc(intel->bufmgr, "WM const bo",
					 size, 64);

   /* _NEW_PROGRAM_CONSTANTS */
   drm_intel_gem_bo_map_gtt(brw->wm.const_bo);
   constants = brw->wm.const_bo->virtual;
   for (i = 0; i < brw->wm.prog_data->nr_pull_params; i++) {
      constants[i] = convert_param(brw->wm.prog_data->pull_param_convert[i],
				   *brw->wm.prog_data->pull_param[i]);
   }
   drm_intel_gem_bo_unmap_gtt(brw->wm.const_bo);
d177 1
a177 2
   brw->state.dirty.brw |= BRW_NEW_WM_CONSTBUF;
}
a178 8
const struct brw_tracked_state brw_wm_constants = {
   .dirty = {
      .mesa = (_NEW_PROGRAM_CONSTANTS),
      .brw = (BRW_NEW_FRAGMENT_PROGRAM),
      .cache = 0
   },
   .prepare = prepare_wm_constants,
};
d180 1
a180 9
/**
 * Updates surface / buffer for fragment shader constant buffer, if
 * one is required.
 *
 * This consumes the state updates for the constant buffer, and produces
 * BRW_NEW_WM_SURFACES to get picked up by brw_prepare_wm_surfaces for
 * inclusion in the binding table.
 */
static void upload_wm_constant_surface(struct brw_context *brw )
d182 4
a185 33
   GLuint surf = SURF_INDEX_FRAG_CONST_BUFFER;
   struct brw_fragment_program *fp =
      (struct brw_fragment_program *) brw->fragment_program;
   const struct gl_program_parameter_list *params =
      fp->program.Base.Parameters;

   /* If there's no constant buffer, then no surface BO is needed to point at
    * it.
    */
   if (brw->wm.const_bo == 0) {
      if (brw->wm.surf_bo[surf] != NULL) {
	 drm_intel_bo_unreference(brw->wm.surf_bo[surf]);
	 brw->wm.surf_bo[surf] = NULL;
	 brw->state.dirty.brw |= BRW_NEW_WM_SURFACES;
      }
      return;
   }

   brw_create_constant_surface(brw, brw->wm.const_bo, params->NumParameters,
			       &brw->wm.surf_bo[surf],
			       &brw->wm.surf_offset[surf]);
   brw->state.dirty.brw |= BRW_NEW_WM_SURFACES;
}

const struct brw_tracked_state brw_wm_constant_surface = {
   .dirty = {
      .mesa = 0,
      .brw = (BRW_NEW_WM_CONSTBUF |
	      BRW_NEW_BATCH),
      .cache = 0
   },
   .emit = upload_wm_constant_surface,
};
d187 12
d200 1
a200 92
/**
 * Sets up a surface state structure to point at the given region.
 * While it is only used for the front/back buffer currently, it should be
 * usable for further buffers when doing ARB_draw_buffer support.
 */
static void
brw_update_renderbuffer_surface(struct brw_context *brw,
				struct gl_renderbuffer *rb,
				unsigned int unit)
{
   struct intel_context *intel = &brw->intel;
   struct gl_context *ctx = &intel->ctx;
   drm_intel_bo *region_bo = NULL;
   struct intel_renderbuffer *irb = intel_renderbuffer(rb);
   struct intel_region *region = irb ? irb->region : NULL;
   struct {
      unsigned int surface_type;
      unsigned int surface_format;
      unsigned int width, height, pitch, cpp;
      GLubyte color_mask[4];
      GLboolean color_blend;
      uint32_t tiling;
      uint32_t draw_x;
      uint32_t draw_y;
   } key;
   struct brw_surface_state surf;
   void *map;

   memset(&key, 0, sizeof(key));

   if (region != NULL) {
      region_bo = region->buffer;

      key.surface_type = BRW_SURFACE_2D;
      switch (irb->Base.Format) {
      /* XRGB and ARGB are treated the same here because the chips in this
       * family cannot render to XRGB targets.  This means that we have to
       * mask writes to alpha (ala glColorMask) and reconfigure the alpha
       * blending hardware to use GL_ONE (or GL_ZERO) for cases where
       * GL_DST_ALPHA (or GL_ONE_MINUS_DST_ALPHA) is used.
       */
      case MESA_FORMAT_ARGB8888:
      case MESA_FORMAT_XRGB8888:
	 key.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
	 break;
      case MESA_FORMAT_SARGB8:
	 key.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM_SRGB;
	 break;
      case MESA_FORMAT_RGB565:
	 key.surface_format = BRW_SURFACEFORMAT_B5G6R5_UNORM;
	 break;
      case MESA_FORMAT_ARGB1555:
	 key.surface_format = BRW_SURFACEFORMAT_B5G5R5A1_UNORM;
	 break;
      case MESA_FORMAT_ARGB4444:
	 key.surface_format = BRW_SURFACEFORMAT_B4G4R4A4_UNORM;
	 break;
      case MESA_FORMAT_A8:
	 key.surface_format = BRW_SURFACEFORMAT_A8_UNORM;
	 break;
      case MESA_FORMAT_R8:
	 key.surface_format = BRW_SURFACEFORMAT_R8_UNORM;
	 break;
      case MESA_FORMAT_R16:
	 key.surface_format = BRW_SURFACEFORMAT_R16_UNORM;
	 break;
      case MESA_FORMAT_RG88:
	 key.surface_format = BRW_SURFACEFORMAT_R8G8_UNORM;
	 break;
      case MESA_FORMAT_RG1616:
	 key.surface_format = BRW_SURFACEFORMAT_R16G16_UNORM;
	 break;
      default:
	 _mesa_problem(ctx, "Bad renderbuffer format: %d\n", irb->Base.Format);
      }
      key.tiling = region->tiling;
      key.width = rb->Width;
      key.height = rb->Height;
      key.pitch = region->pitch;
      key.cpp = region->cpp;
      key.draw_x = region->draw_x;
      key.draw_y = region->draw_y;
   } else {
      key.surface_type = BRW_SURFACE_NULL;
      key.surface_format = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
      key.tiling = I915_TILING_X;
      key.width = 1;
      key.height = 1;
      key.cpp = 4;
      key.draw_x = 0;
      key.draw_y = 0;
   }
a201 1
   if (intel->gen < 6) {
d203 2
a204 2
      memcpy(key.color_mask, ctx->Color.ColorMask[unit],
	     sizeof(key.color_mask));
a205 5
      /* As mentioned above, disable writes to the alpha component when the
       * renderbuffer is XRGB.
       */
      if (ctx->DrawBuffer->Visual.alphaBits == 0)
	 key.color_mask[3] = GL_FALSE;
d207 4
a210 3
      key.color_blend = (!ctx->Color._LogicOpEnabled &&
			 (ctx->Color.BlendEnabled & (1 << unit)));
   }
d212 2
a213 1
   memset(&surf, 0, sizeof(surf));
a214 32
   surf.ss0.surface_format = key.surface_format;
   surf.ss0.surface_type = key.surface_type;
   if (key.tiling == I915_TILING_NONE) {
      surf.ss1.base_addr = (key.draw_x + key.draw_y * key.pitch) * key.cpp;
   } else {
      uint32_t tile_base, tile_x, tile_y;
      uint32_t pitch = key.pitch * key.cpp;

      if (key.tiling == I915_TILING_X) {
	 tile_x = key.draw_x % (512 / key.cpp);
	 tile_y = key.draw_y % 8;
	 tile_base = ((key.draw_y / 8) * (8 * pitch));
	 tile_base += (key.draw_x - tile_x) / (512 / key.cpp) * 4096;
      } else {
	 /* Y */
	 tile_x = key.draw_x % (128 / key.cpp);
	 tile_y = key.draw_y % 32;
	 tile_base = ((key.draw_y / 32) * (32 * pitch));
	 tile_base += (key.draw_x - tile_x) / (128 / key.cpp) * 4096;
      }
      assert(brw->has_surface_tile_offset || (tile_x == 0 && tile_y == 0));
      assert(tile_x % 4 == 0);
      assert(tile_y % 2 == 0);
      /* Note that the low bits of these fields are missing, so
       * there's the possibility of getting in trouble.
       */
      surf.ss1.base_addr = tile_base;
      surf.ss5.x_offset = tile_x / 4;
      surf.ss5.y_offset = tile_y / 2;
   }
   if (region_bo != NULL)
      surf.ss1.base_addr += region_bo->offset; /* reloc */
d216 5
a220 4
   surf.ss2.width = key.width - 1;
   surf.ss2.height = key.height - 1;
   brw_set_surface_tiling(&surf, key.tiling);
   surf.ss3.pitch = (key.pitch * key.cpp) - 1;
d222 2
a223 7
   if (intel->gen < 6) {
      /* _NEW_COLOR */
      surf.ss0.color_blend = key.color_blend;
      surf.ss0.writedisable_red =   !key.color_mask[0];
      surf.ss0.writedisable_green = !key.color_mask[1];
      surf.ss0.writedisable_blue =  !key.color_mask[2];
      surf.ss0.writedisable_alpha = !key.color_mask[3];
a225 15
   map = brw_state_batch(brw, sizeof(surf), 32,
			 &brw->wm.surf_bo[unit],
			 &brw->wm.surf_offset[unit]);
   memcpy(map, &surf, sizeof(surf));

   if (region_bo != NULL) {
      drm_intel_bo_emit_reloc(brw->wm.surf_bo[unit],
			      brw->wm.surf_offset[unit] +
			      offsetof(struct brw_surface_state, ss1),
			      region_bo,
			      surf.ss1.base_addr - region_bo->offset,
			      I915_GEM_DOMAIN_RENDER,
			      I915_GEM_DOMAIN_RENDER);
   }
}
d227 2
a228 12
static void
prepare_wm_surfaces(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->intel.ctx;
   int i;
   int nr_surfaces = 0;

   if (ctx->DrawBuffer->_NumColorDrawBuffers >= 1) {
      for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++) {
	 struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[i];
	 struct intel_renderbuffer *irb = intel_renderbuffer(rb);
	 struct intel_region *region = irb ? irb->region : NULL;
d230 4
a233 20
	 brw_add_validated_bo(brw, region->buffer);
	 nr_surfaces = SURF_INDEX_DRAW(i) + 1;
      }
   }

   if (brw->wm.const_bo) {
      brw_add_validated_bo(brw, brw->wm.const_bo);
      nr_surfaces = SURF_INDEX_FRAG_CONST_BUFFER + 1;
   }

   for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
      const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[i];
      struct gl_texture_object *tObj = texUnit->_Current;
      struct intel_texture_object *intelObj = intel_texture_object(tObj);

      if (texUnit->_ReallyEnabled) {
	 brw_add_validated_bo(brw, intelObj->mt->region->buffer);
	 nr_surfaces = SURF_INDEX_TEXTURE(i) + 1;
      }
   }
d235 1
a235 8
   /* Have to update this in our prepare, since the unit's prepare
    * relies on it.
    */
   if (brw->wm.nr_surfaces != nr_surfaces) {
      brw->wm.nr_surfaces = nr_surfaces;
      brw->state.dirty.brw |= BRW_NEW_NR_WM_SURFACES;
   }
}
d237 1
a237 9
/**
 * Constructs the set of surface state objects pointed to by the
 * binding table.
 */
static void
upload_wm_surfaces(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->intel.ctx;
   GLuint i;
d239 2
a240 7
   /* _NEW_BUFFERS | _NEW_COLOR */
   /* Update surfaces for drawing buffers */
   if (ctx->DrawBuffer->_NumColorDrawBuffers >= 1) {
      for (i = 0; i < ctx->DrawBuffer->_NumColorDrawBuffers; i++) {
         brw_update_renderbuffer_surface(brw,
					 ctx->DrawBuffer->_ColorDrawBuffers[i],
					 i);
d242 8
a249 15
   } else {
      brw_update_renderbuffer_surface(brw, NULL, 0);
   }

   /* Update surfaces for textures */
   for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
      const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[i];
      const GLuint surf = SURF_INDEX_TEXTURE(i);

      /* _NEW_TEXTURE */
      if (texUnit->_ReallyEnabled) {
	 brw_update_texture_surface(ctx, i);
      } else {
         drm_intel_bo_unreference(brw->wm.surf_bo[surf]);
         brw->wm.surf_bo[surf] = NULL;
d253 2
a254 1
   brw->state.dirty.brw |= BRW_NEW_WM_SURFACES;
d259 3
a261 4
      .mesa = (_NEW_COLOR |
               _NEW_TEXTURE |
               _NEW_BUFFERS),
      .brw = (BRW_NEW_BATCH),
d264 1
a264 2
   .prepare = prepare_wm_surfaces,
   .emit = upload_wm_surfaces,
a266 15
/**
 * Constructs the binding table for the WM surface state, which maps unit
 * numbers to surface state objects.
 */
static void
brw_wm_upload_binding_table(struct brw_context *brw)
{
   uint32_t *bind;
   int i;

   /* Might want to calculate nr_surfaces first, to avoid taking up so much
    * space for the binding table.
    */
   bind = brw_state_batch(brw, sizeof(uint32_t) * BRW_WM_MAX_SURF,
			  32, &brw->wm.bind_bo, &brw->wm.bind_bo_offset);
a267 9
   for (i = 0; i < BRW_WM_MAX_SURF; i++) {
      /* BRW_NEW_WM_SURFACES */
      bind[i] = brw->wm.surf_offset[i];
      if (brw->wm.surf_bo[i]) {
	 bind[i] = brw->wm.surf_offset[i];
      } else {
	 bind[i] = 0;
      }
   }
a268 12
   brw->state.dirty.brw |= BRW_NEW_BINDING_TABLE;
}

const struct brw_tracked_state brw_wm_binding_table = {
   .dirty = {
      .mesa = 0,
      .brw = (BRW_NEW_BATCH |
	      BRW_NEW_WM_SURFACES),
      .cache = 0
   },
   .emit = brw_wm_upload_binding_table,
};
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@a32 2
#include "main/context.h"
#include "main/blend.h"
d34 1
a34 1
#include "main/samplerobj.h"
a40 1
#include "intel_buffer_objects.h"
a44 1
#include "brw_wm.h"
d46 2
a47 2
GLuint
translate_tex_target(GLenum target)
a50 1
   case GL_TEXTURE_1D_ARRAY_EXT:
a56 4
   case GL_TEXTURE_2D_ARRAY_EXT:
   case GL_TEXTURE_EXTERNAL_OES:
   case GL_TEXTURE_2D_MULTISAMPLE:
   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:
a62 1
   case GL_TEXTURE_CUBE_MAP_ARRAY:
d71 4
a74 2
uint32_t
brw_get_surface_tiling_bits(uint32_t tiling)
d76 85
a160 9
   switch (tiling) {
   case I915_TILING_X:
      return BRW_SURFACE_TILED;
   case I915_TILING_Y:
      return BRW_SURFACE_TILED | BRW_SURFACE_TILED_Y;
   default:
      return 0;
   }
}
d162 2
d165 2
a166 8
uint32_t
brw_get_surface_num_multisamples(unsigned num_samples)
{
   if (num_samples > 1)
      return BRW_SURFACE_MULTISAMPLECOUNT_4;
   else
      return BRW_SURFACE_MULTISAMPLECOUNT_1;
}
d168 2
d171 3
a173 27
/**
 * Compute the combination of DEPTH_TEXTURE_MODE and EXT_texture_swizzle
 * swizzling.
 */
int
brw_get_texture_swizzle(const struct gl_context *ctx,
                        const struct gl_texture_object *t)
{
   const struct gl_texture_image *img = t->Image[0][t->BaseLevel];

   int swizzles[SWIZZLE_NIL + 1] = {
      SWIZZLE_X,
      SWIZZLE_Y,
      SWIZZLE_Z,
      SWIZZLE_W,
      SWIZZLE_ZERO,
      SWIZZLE_ONE,
      SWIZZLE_NIL
   };

   if (img->_BaseFormat == GL_DEPTH_COMPONENT ||
       img->_BaseFormat == GL_DEPTH_STENCIL) {
      GLenum depth_mode = t->DepthMode;

      /* In ES 3.0, DEPTH_TEXTURE_MODE is expected to be GL_RED for textures
       * with depth component data specified with a sized internal format.
       * Otherwise, it's left at the old default, GL_LUMINANCE.
d175 11
a185 5
      if (_mesa_is_gles3(ctx) &&
          img->InternalFormat != GL_DEPTH_COMPONENT &&
          img->InternalFormat != GL_DEPTH_STENCIL) {
         depth_mode = GL_RED;
      }
d187 2
a188 27
      switch (depth_mode) {
      case GL_ALPHA:
         swizzles[0] = SWIZZLE_ZERO;
         swizzles[1] = SWIZZLE_ZERO;
         swizzles[2] = SWIZZLE_ZERO;
         swizzles[3] = SWIZZLE_X;
         break;
      case GL_LUMINANCE:
         swizzles[0] = SWIZZLE_X;
         swizzles[1] = SWIZZLE_X;
         swizzles[2] = SWIZZLE_X;
         swizzles[3] = SWIZZLE_ONE;
         break;
      case GL_INTENSITY:
         swizzles[0] = SWIZZLE_X;
         swizzles[1] = SWIZZLE_X;
         swizzles[2] = SWIZZLE_X;
         swizzles[3] = SWIZZLE_X;
         break;
      case GL_RED:
         swizzles[0] = SWIZZLE_X;
         swizzles[1] = SWIZZLE_ZERO;
         swizzles[2] = SWIZZLE_ZERO;
         swizzles[3] = SWIZZLE_ONE;
         break;
      }
   }
d190 3
a192 18
   /* If the texture's format is alpha-only, force R, G, and B to
    * 0.0. Similarly, if the texture's format has no alpha channel,
    * force the alpha value read to 1.0. This allows for the
    * implementation to use an RGBA texture for any of these formats
    * without leaking any unexpected values.
    */
   switch (img->_BaseFormat) {
   case GL_ALPHA:
      swizzles[0] = SWIZZLE_ZERO;
      swizzles[1] = SWIZZLE_ZERO;
      swizzles[2] = SWIZZLE_ZERO;
      break;
   case GL_RED:
   case GL_RG:
   case GL_RGB:
      if (_mesa_get_format_bits(img->TexFormat, GL_ALPHA_BITS) > 0)
         swizzles[3] = SWIZZLE_ONE;
      break;
a193 5

   return MAKE_SWIZZLE4(swizzles[GET_SWZ(t->_Swizzle, 0)],
                        swizzles[GET_SWZ(t->_Swizzle, 1)],
                        swizzles[GET_SWZ(t->_Swizzle, 2)],
                        swizzles[GET_SWZ(t->_Swizzle, 3)]);
a195 1

d197 1
a197 4
brw_update_buffer_texture_surface(struct gl_context *ctx,
                                  unsigned unit,
                                  uint32_t *binding_table,
                                  unsigned surf_index)
d199 13
a211 41
   struct brw_context *brw = brw_context(ctx);
   struct gl_texture_object *tObj = ctx->Texture.Unit[unit]._Current;
   uint32_t *surf;
   struct intel_buffer_object *intel_obj =
      intel_buffer_object(tObj->BufferObject);
   drm_intel_bo *bo = intel_obj ? intel_obj->buffer : NULL;
   gl_format format = tObj->_BufferObjectFormat;
   uint32_t brw_format = brw_format_for_mesa_format(format);
   int texel_size = _mesa_get_format_bytes(format);

   if (brw_format == 0 && format != MESA_FORMAT_RGBA_FLOAT32) {
      _mesa_problem(NULL, "bad format %s for texture buffer\n",
		    _mesa_get_format_name(format));
   }

   surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
			  6 * 4, 32, &binding_table[surf_index]);

   surf[0] = (BRW_SURFACE_BUFFER << BRW_SURFACE_TYPE_SHIFT |
	      (brw_format_for_mesa_format(format) << BRW_SURFACE_FORMAT_SHIFT));

   if (brw->gen >= 6)
      surf[0] |= BRW_SURFACE_RC_READ_WRITE;

   if (bo) {
      surf[1] = bo->offset; /* reloc */

      /* Emit relocation to surface contents. */
      drm_intel_bo_emit_reloc(brw->batch.bo,
			      binding_table[surf_index] + 4,
			      bo, 0, I915_GEM_DOMAIN_SAMPLER, 0);

      int w = intel_obj->Base.Size / texel_size;
      surf[2] = ((w & 0x7f) << BRW_SURFACE_WIDTH_SHIFT |
		 ((w >> 7) & 0x1fff) << BRW_SURFACE_HEIGHT_SHIFT);
      surf[3] = (((w >> 20) & 0x7f) << BRW_SURFACE_DEPTH_SHIFT |
		 (texel_size - 1) << BRW_SURFACE_PITCH_SHIFT);
   } else {
      surf[1] = 0;
      surf[2] = 0;
      surf[3] = 0;
a212 3

   surf[4] = 0;
   surf[5] = 0;
d216 1
a216 4
brw_update_texture_surface(struct gl_context *ctx,
                           unsigned unit,
                           uint32_t *binding_table,
                           unsigned surf_index)
d221 12
a232 5
   struct intel_mipmap_tree *mt = intelObj->mt;
   struct gl_texture_image *firstImage = tObj->Image[0][tObj->BaseLevel];
   struct gl_sampler_object *sampler = _mesa_get_samplerobj(ctx, unit);
   uint32_t *surf;
   uint32_t tile_x, tile_y;
d234 4
a237 7
   if (tObj->Target == GL_TEXTURE_BUFFER) {
      brw_update_buffer_texture_surface(ctx, unit, binding_table, surf_index);
      return;
   }

   surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
			  6 * 4, 32, &binding_table[surf_index]);
d239 22
a260 33
   surf[0] = (translate_tex_target(tObj->Target) << BRW_SURFACE_TYPE_SHIFT |
	      BRW_SURFACE_MIPMAPLAYOUT_BELOW << BRW_SURFACE_MIPLAYOUT_SHIFT |
	      BRW_SURFACE_CUBEFACE_ENABLES |
	      (translate_tex_format(brw,
                                    mt->format,
				    tObj->DepthMode,
				    sampler->sRGBDecode) <<
	       BRW_SURFACE_FORMAT_SHIFT));

   surf[1] = intelObj->mt->region->bo->offset + intelObj->mt->offset; /* reloc */
   surf[1] += intel_miptree_get_tile_offsets(intelObj->mt, firstImage->Level, 0,
                                             &tile_x, &tile_y);

   surf[2] = ((intelObj->_MaxLevel - tObj->BaseLevel) << BRW_SURFACE_LOD_SHIFT |
	      (mt->logical_width0 - 1) << BRW_SURFACE_WIDTH_SHIFT |
	      (mt->logical_height0 - 1) << BRW_SURFACE_HEIGHT_SHIFT);

   surf[3] = (brw_get_surface_tiling_bits(intelObj->mt->region->tiling) |
	      (mt->logical_depth0 - 1) << BRW_SURFACE_DEPTH_SHIFT |
	      (intelObj->mt->region->pitch - 1) <<
	      BRW_SURFACE_PITCH_SHIFT);

   surf[4] = brw_get_surface_num_multisamples(intelObj->mt->num_samples);

   assert(brw->has_surface_tile_offset || (tile_x == 0 && tile_y == 0));
   /* Note that the low bits of these fields are missing, so
    * there's the possibility of getting in trouble.
    */
   assert(tile_x % 4 == 0);
   assert(tile_y % 2 == 0);
   surf[5] = ((tile_x / 4) << BRW_SURFACE_X_OFFSET_SHIFT |
	      (tile_y / 2) << BRW_SURFACE_Y_OFFSET_SHIFT |
	      (mt->align_h == 4 ? BRW_SURFACE_VERTICAL_ALIGN_ENABLE : 0));
d263 4
a266 4
   drm_intel_bo_emit_reloc(brw->batch.bo,
			   binding_table[surf_index] + 4,
			   intelObj->mt->region->bo,
                           surf[1] - intelObj->mt->region->bo->offset,
d274 1
a274 1
static void
d277 33
a309 34
			    uint32_t offset,
			    uint32_t size,
			    uint32_t *out_offset,
                            bool dword_pitch)
{
   uint32_t stride = dword_pitch ? 4 : 16;
   uint32_t elements = ALIGN(size, stride) / stride;
   const GLint w = elements - 1;
   uint32_t *surf;

   surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
			  6 * 4, 32, out_offset);

   surf[0] = (BRW_SURFACE_BUFFER << BRW_SURFACE_TYPE_SHIFT |
	      BRW_SURFACE_MIPMAPLAYOUT_BELOW << BRW_SURFACE_MIPLAYOUT_SHIFT |
	      BRW_SURFACEFORMAT_R32G32B32A32_FLOAT << BRW_SURFACE_FORMAT_SHIFT);

   if (brw->gen >= 6)
      surf[0] |= BRW_SURFACE_RC_READ_WRITE;

   surf[1] = bo->offset + offset; /* reloc */

   surf[2] = ((w & 0x7f) << BRW_SURFACE_WIDTH_SHIFT |
	      ((w >> 7) & 0x1fff) << BRW_SURFACE_HEIGHT_SHIFT);

   surf[3] = (((w >> 20) & 0x7f) << BRW_SURFACE_DEPTH_SHIFT |
	      (stride - 1) << BRW_SURFACE_PITCH_SHIFT);

   surf[4] = 0;
   surf[5] = 0;

   /* Emit relocation to surface contents.  The 965 PRM, Volume 4, section
    * 5.1.2 "Data Cache" says: "the data cache does not exist as a separate
    * physical cache.  It is mapped in hardware to the sampler cache."
d311 3
a313 3
   drm_intel_bo_emit_reloc(brw->batch.bo,
			   *out_offset + 4,
			   bo, offset,
a316 85
/**
 * Set up a binding table entry for use by stream output logic (transform
 * feedback).
 *
 * buffer_size_minus_1 must me less than BRW_MAX_NUM_BUFFER_ENTRIES.
 */
void
brw_update_sol_surface(struct brw_context *brw,
                       struct gl_buffer_object *buffer_obj,
                       uint32_t *out_offset, unsigned num_vector_components,
                       unsigned stride_dwords, unsigned offset_dwords)
{
   struct intel_buffer_object *intel_bo = intel_buffer_object(buffer_obj);
   drm_intel_bo *bo = intel_bufferobj_buffer(brw, intel_bo, INTEL_WRITE_PART);
   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE, 6 * 4, 32,
                                    out_offset);
   uint32_t pitch_minus_1 = 4*stride_dwords - 1;
   uint32_t offset_bytes = 4 * offset_dwords;
   size_t size_dwords = buffer_obj->Size / 4;
   uint32_t buffer_size_minus_1, width, height, depth, surface_format;

   /* FIXME: can we rely on core Mesa to ensure that the buffer isn't
    * too big to map using a single binding table entry?
    */
   assert((size_dwords - offset_dwords) / stride_dwords
          <= BRW_MAX_NUM_BUFFER_ENTRIES);

   if (size_dwords > offset_dwords + num_vector_components) {
      /* There is room for at least 1 transform feedback output in the buffer.
       * Compute the number of additional transform feedback outputs the
       * buffer has room for.
       */
      buffer_size_minus_1 =
         (size_dwords - offset_dwords - num_vector_components) / stride_dwords;
   } else {
      /* There isn't even room for a single transform feedback output in the
       * buffer.  We can't configure the binding table entry to prevent output
       * entirely; we'll have to rely on the geometry shader to detect
       * overflow.  But to minimize the damage in case of a bug, set up the
       * binding table entry to just allow a single output.
       */
      buffer_size_minus_1 = 0;
   }
   width = buffer_size_minus_1 & 0x7f;
   height = (buffer_size_minus_1 & 0xfff80) >> 7;
   depth = (buffer_size_minus_1 & 0x7f00000) >> 20;

   switch (num_vector_components) {
   case 1:
      surface_format = BRW_SURFACEFORMAT_R32_FLOAT;
      break;
   case 2:
      surface_format = BRW_SURFACEFORMAT_R32G32_FLOAT;
      break;
   case 3:
      surface_format = BRW_SURFACEFORMAT_R32G32B32_FLOAT;
      break;
   case 4:
      surface_format = BRW_SURFACEFORMAT_R32G32B32A32_FLOAT;
      break;
   default:
      assert(!"Invalid vector size for transform feedback output");
      surface_format = BRW_SURFACEFORMAT_R32_FLOAT;
      break;
   }

   surf[0] = BRW_SURFACE_BUFFER << BRW_SURFACE_TYPE_SHIFT |
      BRW_SURFACE_MIPMAPLAYOUT_BELOW << BRW_SURFACE_MIPLAYOUT_SHIFT |
      surface_format << BRW_SURFACE_FORMAT_SHIFT |
      BRW_SURFACE_RC_READ_WRITE;
   surf[1] = bo->offset + offset_bytes; /* reloc */
   surf[2] = (width << BRW_SURFACE_WIDTH_SHIFT |
	      height << BRW_SURFACE_HEIGHT_SHIFT);
   surf[3] = (depth << BRW_SURFACE_DEPTH_SHIFT |
              pitch_minus_1 << BRW_SURFACE_PITCH_SHIFT);
   surf[4] = 0;
   surf[5] = 0;

   /* Emit relocation to surface contents. */
   drm_intel_bo_emit_reloc(brw->batch.bo,
			   *out_offset + 4,
			   bo, offset_bytes,
			   I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER);
}

d324 1
a324 1
brw_upload_wm_pull_constants(struct brw_context *brw)
d326 2
a327 2
   struct gl_context *ctx = &brw->ctx;
   /* BRW_NEW_FRAGMENT_PROGRAM */
a329 1
   struct gl_program_parameter_list *params = fp->program.Base.Parameters;
a330 1
   const int surf_index = SURF_INDEX_FRAG_CONST_BUFFER;
d334 1
a334 1
   _mesa_load_state_parameters(ctx, params);
d336 1
a336 1
   /* CACHE_NEW_WM_PROG */
d341 1
a341 2
	 brw->wm.surf_offset[surf_index] = 0;
	 brw->state.dirty.brw |= BRW_NEW_SURFACES;
d347 1
a347 1
   brw->wm.const_bo = drm_intel_bo_alloc(brw->bufmgr, "WM const bo",
d354 2
a355 1
      constants[i] = *brw->wm.prog_data->pull_param[i];
d359 1
a359 5
   brw->vtbl.create_constant_surface(brw, brw->wm.const_bo, 0, size,
                                     &brw->wm.surf_offset[surf_index],
                                     true);

   brw->state.dirty.brw |= BRW_NEW_SURFACES;
d362 1
a362 1
const struct brw_tracked_state brw_wm_pull_constants = {
d365 2
a366 2
      .brw = (BRW_NEW_BATCH | BRW_NEW_FRAGMENT_PROGRAM),
      .cache = CACHE_NEW_WM_PROG,
d368 1
a368 1
   .emit = brw_upload_wm_pull_constants,
d371 9
a379 2
static void
brw_update_null_renderbuffer_surface(struct brw_context *brw, unsigned int unit)
d381 8
a388 17
   /* From the Sandy bridge PRM, Vol4 Part1 p71 (Surface Type: Programming
    * Notes):
    *
    *     A null surface will be used in instances where an actual surface is
    *     not bound. When a write message is generated to a null surface, no
    *     actual surface is written to. When a read message (including any
    *     sampling engine message) is generated to a null surface, the result
    *     is all zeros. Note that a null surface type is allowed to be used
    *     with all messages, even if it is not specificially indicated as
    *     supported. All of the remaining fields in surface state are ignored
    *     for null surfaces, with the following exceptions:
    *
    *     - [DevSNB+]: Width, Height, Depth, and LOD fields must match the
    *       depth buffer’s corresponding state for all render target surfaces,
    *       including null.
    *
    *     - Surface Format must be R8G8B8A8_UNORM.
d390 7
a396 67
   struct gl_context *ctx = &brw->ctx;
   uint32_t *surf;
   unsigned surface_type = BRW_SURFACE_NULL;
   drm_intel_bo *bo = NULL;
   unsigned pitch_minus_1 = 0;
   uint32_t multisampling_state = 0;

   /* _NEW_BUFFERS */
   const struct gl_framebuffer *fb = ctx->DrawBuffer;

   surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
			  6 * 4, 32, &brw->wm.surf_offset[unit]);

   if (fb->Visual.samples > 1) {
      /* On Gen6, null render targets seem to cause GPU hangs when
       * multisampling.  So work around this problem by rendering into dummy
       * color buffer.
       *
       * To decrease the amount of memory needed by the workaround buffer, we
       * set its pitch to 128 bytes (the width of a Y tile).  This means that
       * the amount of memory needed for the workaround buffer is
       * (width_in_tiles + height_in_tiles - 1) tiles.
       *
       * Note that since the workaround buffer will be interpreted by the
       * hardware as an interleaved multisampled buffer, we need to compute
       * width_in_tiles and height_in_tiles by dividing the width and height
       * by 16 rather than the normal Y-tile size of 32.
       */
      unsigned width_in_tiles = ALIGN(fb->Width, 16) / 16;
      unsigned height_in_tiles = ALIGN(fb->Height, 16) / 16;
      unsigned size_needed = (width_in_tiles + height_in_tiles - 1) * 4096;
      brw_get_scratch_bo(brw, &brw->wm.multisampled_null_render_target_bo,
                         size_needed);
      bo = brw->wm.multisampled_null_render_target_bo;
      surface_type = BRW_SURFACE_2D;
      pitch_minus_1 = 127;
      multisampling_state =
         brw_get_surface_num_multisamples(fb->Visual.samples);
   }

   surf[0] = (surface_type << BRW_SURFACE_TYPE_SHIFT |
	      BRW_SURFACEFORMAT_B8G8R8A8_UNORM << BRW_SURFACE_FORMAT_SHIFT);
   if (brw->gen < 6) {
      surf[0] |= (1 << BRW_SURFACE_WRITEDISABLE_R_SHIFT |
		  1 << BRW_SURFACE_WRITEDISABLE_G_SHIFT |
		  1 << BRW_SURFACE_WRITEDISABLE_B_SHIFT |
		  1 << BRW_SURFACE_WRITEDISABLE_A_SHIFT);
   }
   surf[1] = bo ? bo->offset : 0;
   surf[2] = ((fb->Width - 1) << BRW_SURFACE_WIDTH_SHIFT |
              (fb->Height - 1) << BRW_SURFACE_HEIGHT_SHIFT);

   /* From Sandy bridge PRM, Vol4 Part1 p82 (Tiled Surface: Programming
    * Notes):
    *
    *     If Surface Type is SURFTYPE_NULL, this field must be TRUE
    */
   surf[3] = (BRW_SURFACE_TILED | BRW_SURFACE_TILED_Y |
              pitch_minus_1 << BRW_SURFACE_PITCH_SHIFT);
   surf[4] = multisampling_state;
   surf[5] = 0;

   if (bo) {
      drm_intel_bo_emit_reloc(brw->batch.bo,
                              brw->wm.surf_offset[unit] + 4,
                              bo, 0,
                              I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER);
d398 5
d405 11
a423 1
				bool layered,
d426 3
a428 1
   struct gl_context *ctx = &brw->ctx;
d430 60
a489 22
   struct intel_mipmap_tree *mt = irb->mt;
   struct intel_region *region;
   uint32_t *surf;
   uint32_t tile_x, tile_y;
   uint32_t format = 0;
   /* _NEW_BUFFERS */
   gl_format rb_format = _mesa_get_render_format(ctx, intel_rb_format(irb));

   assert(!layered);

   if (rb->TexImage && !brw->has_surface_tile_offset) {
      intel_renderbuffer_get_tile_offsets(irb, &tile_x, &tile_y);

      if (tile_x != 0 || tile_y != 0) {
	 /* Original gen4 hardware couldn't draw to a non-tile-aligned
	  * destination in a miptree unless you actually setup your renderbuffer
	  * as a miptree and used the fragile lod/array_index/etc. controls to
	  * select the image.  So, instead, we just make a new single-level
	  * miptree and render into that.
	  */
	 intel_renderbuffer_move_to_temp(brw, irb, false);
	 mt = irb->mt;
d491 16
d509 4
a512 1
   intel_miptree_used_for_rendering(irb->mt);
d514 5
a518 1
   region = irb->mt->region;
d520 3
a522 2
   surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
			  6 * 4, 32, &brw->wm.surf_offset[unit]);
d524 1
a524 5
   format = brw->render_target_format[rb_format];
   if (unlikely(!brw->format_supported_as_render_target[rb_format])) {
      _mesa_problem(ctx, "%s: renderbuffer format %s unsupported\n",
                    __FUNCTION__, _mesa_get_format_name(rb_format));
   }
d526 7
a532 2
   surf[0] = (BRW_SURFACE_2D << BRW_SURFACE_TYPE_SHIFT |
	      format << BRW_SURFACE_FORMAT_SHIFT);
d534 29
a562 3
   /* reloc */
   surf[1] = (intel_renderbuffer_get_tile_offsets(irb, &tile_x, &tile_y) +
	      region->bo->offset);
d564 24
a587 2
   surf[2] = ((rb->Width - 1) << BRW_SURFACE_WIDTH_SHIFT |
	      (rb->Height - 1) << BRW_SURFACE_HEIGHT_SHIFT);
d589 6
a594 2
   surf[3] = (brw_get_surface_tiling_bits(region->tiling) |
	      (region->pitch - 1) << BRW_SURFACE_PITCH_SHIFT);
d596 5
a600 1
   surf[4] = brw_get_surface_num_multisamples(mt->num_samples);
d602 4
a605 9
   assert(brw->has_surface_tile_offset || (tile_x == 0 && tile_y == 0));
   /* Note that the low bits of these fields are missing, so
    * there's the possibility of getting in trouble.
    */
   assert(tile_x % 4 == 0);
   assert(tile_y % 2 == 0);
   surf[5] = ((tile_x / 4) << BRW_SURFACE_X_OFFSET_SHIFT |
	      (tile_y / 2) << BRW_SURFACE_Y_OFFSET_SHIFT |
	      (mt->align_h == 4 ? BRW_SURFACE_VERTICAL_ALIGN_ENABLE : 0));
d607 4
a610 12
   if (brw->gen < 6) {
      /* _NEW_COLOR */
      if (!ctx->Color.ColorLogicOpEnabled &&
	  (ctx->Color.BlendEnabled & (1 << unit)))
	 surf[0] |= BRW_SURFACE_BLEND_ENABLED;

      if (!ctx->Color.ColorMask[unit][0])
	 surf[0] |= 1 << BRW_SURFACE_WRITEDISABLE_R_SHIFT;
      if (!ctx->Color.ColorMask[unit][1])
	 surf[0] |= 1 << BRW_SURFACE_WRITEDISABLE_G_SHIFT;
      if (!ctx->Color.ColorMask[unit][2])
	 surf[0] |= 1 << BRW_SURFACE_WRITEDISABLE_B_SHIFT;
d612 8
a619 6
      /* As mentioned above, disable writes to the alpha component when the
       * renderbuffer is XRGB.
       */
      if (ctx->DrawBuffer->Visual.alphaBits == 0 ||
	  !ctx->Color.ColorMask[unit][3]) {
	 surf[0] |= 1 << BRW_SURFACE_WRITEDISABLE_A_SHIFT;
d623 7
a629 6
   drm_intel_bo_emit_reloc(brw->batch.bo,
			   brw->wm.surf_offset[unit] + 4,
			   region->bo,
			   surf[1] - region->bo->offset,
			   I915_GEM_DOMAIN_RENDER,
			   I915_GEM_DOMAIN_RENDER);
d633 2
a634 1
 * Construct SURFACE_STATE objects for renderbuffers/draw buffers.
d637 1
a637 1
brw_update_renderbuffer_surfaces(struct brw_context *brw)
d639 1
a639 1
   struct gl_context *ctx = &brw->ctx;
d646 3
a648 6
	 if (intel_renderbuffer(ctx->DrawBuffer->_ColorDrawBuffers[i])) {
	    brw->vtbl.update_renderbuffer_surface(brw, ctx->DrawBuffer->_ColorDrawBuffers[i],
                                                  ctx->DrawBuffer->Layered, i);
	 } else {
	    brw->vtbl.update_null_renderbuffer_surface(brw, i);
	 }
d651 1
a651 1
      brw->vtbl.update_null_renderbuffer_surface(brw, 0);
a652 2
   brw->state.dirty.brw |= BRW_NEW_SURFACES;
}
d654 11
a664 62
const struct brw_tracked_state brw_renderbuffer_surfaces = {
   .dirty = {
      .mesa = (_NEW_COLOR |
               _NEW_BUFFERS),
      .brw = BRW_NEW_BATCH,
      .cache = 0
   },
   .emit = brw_update_renderbuffer_surfaces,
};

const struct brw_tracked_state gen6_renderbuffer_surfaces = {
   .dirty = {
      .mesa = _NEW_BUFFERS,
      .brw = BRW_NEW_BATCH,
      .cache = 0
   },
   .emit = brw_update_renderbuffer_surfaces,
};

/**
 * Construct SURFACE_STATE objects for enabled textures.
 */
static void
brw_update_texture_surfaces(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;

   /* BRW_NEW_VERTEX_PROGRAM and BRW_NEW_FRAGMENT_PROGRAM:
    * Unfortunately, we're stuck using the gl_program structs until the
    * ARB_fragment_program front-end gets converted to GLSL IR.  These
    * have the downside that SamplerUnits is split and only contains the
    * mappings for samplers active in that stage.
    */
   struct gl_program *vs = (struct gl_program *) brw->vertex_program;
   struct gl_program *fs = (struct gl_program *) brw->fragment_program;

   unsigned num_samplers = _mesa_fls(vs->SamplersUsed | fs->SamplersUsed);

   for (unsigned s = 0; s < num_samplers; s++) {
      brw->vs.surf_offset[SURF_INDEX_VS_TEXTURE(s)] = 0;
      brw->wm.surf_offset[SURF_INDEX_TEXTURE(s)] = 0;

      if (vs->SamplersUsed & (1 << s)) {
         const unsigned unit = vs->SamplerUnits[s];

         /* _NEW_TEXTURE */
         if (ctx->Texture.Unit[unit]._ReallyEnabled) {
            brw->vtbl.update_texture_surface(ctx, unit,
                                             brw->vs.surf_offset,
                                             SURF_INDEX_VS_TEXTURE(s));
         }
      }

      if (fs->SamplersUsed & (1 << s)) {
         const unsigned unit = fs->SamplerUnits[s];

         /* _NEW_TEXTURE */
         if (ctx->Texture.Unit[unit]._ReallyEnabled) {
            brw->vtbl.update_texture_surface(ctx, unit,
                                             brw->wm.surf_offset,
                                             SURF_INDEX_TEXTURE(s));
         }
d668 1
a668 1
   brw->state.dirty.brw |= BRW_NEW_SURFACES;
d671 1
a671 1
const struct brw_tracked_state brw_texture_surfaces = {
d673 4
a676 4
      .mesa = _NEW_TEXTURE,
      .brw = BRW_NEW_BATCH |
             BRW_NEW_VERTEX_PROGRAM |
             BRW_NEW_FRAGMENT_PROGRAM,
d679 2
a680 56
   .emit = brw_update_texture_surfaces,
};

void
brw_upload_ubo_surfaces(struct brw_context *brw,
			struct gl_shader *shader,
			uint32_t *surf_offsets)
{
   struct gl_context *ctx = &brw->ctx;

   if (!shader)
      return;

   for (int i = 0; i < shader->NumUniformBlocks; i++) {
      struct gl_uniform_buffer_binding *binding;
      struct intel_buffer_object *intel_bo;

      binding = &ctx->UniformBufferBindings[shader->UniformBlocks[i].Binding];
      intel_bo = intel_buffer_object(binding->BufferObject);
      drm_intel_bo *bo = intel_bufferobj_buffer(brw, intel_bo, INTEL_READ);

      /* Because behavior for referencing outside of the binding's size in the
       * glBindBufferRange case is undefined, we can just bind the whole buffer
       * glBindBufferBase wants and be a correct implementation.
       */
      brw->vtbl.create_constant_surface(brw, bo, binding->Offset,
                                        bo->size - binding->Offset,
                                        &surf_offsets[i],
                                        shader->Type == GL_FRAGMENT_SHADER);
   }

   if (shader->NumUniformBlocks)
      brw->state.dirty.brw |= BRW_NEW_SURFACES;
}

static void
brw_upload_wm_ubo_surfaces(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   /* _NEW_PROGRAM */
   struct gl_shader_program *prog = ctx->Shader._CurrentFragmentProgram;

   if (!prog)
      return;

   brw_upload_ubo_surfaces(brw, prog->_LinkedShaders[MESA_SHADER_FRAGMENT],
			   &brw->wm.surf_offset[SURF_INDEX_WM_UBO(0)]);
}

const struct brw_tracked_state brw_wm_ubo_surfaces = {
   .dirty = {
      .mesa = _NEW_PROGRAM,
      .brw = BRW_NEW_BATCH | BRW_NEW_UNIFORM_BUFFER,
      .cache = 0,
   },
   .emit = brw_upload_wm_ubo_surfaces,
d688 1
a688 1
brw_upload_wm_binding_table(struct brw_context *brw)
a692 4
   if (INTEL_DEBUG & DEBUG_SHADER_TIME) {
      gen7_create_shader_time_surface(brw, &brw->wm.surf_offset[SURF_INDEX_WM_SHADER_TIME]);
   }

d696 2
a697 3
   bind = brw_state_batch(brw, AUB_TRACE_BINDING_TABLE,
			  sizeof(uint32_t) * BRW_MAX_WM_SURFACES,
			  32, &brw->wm.bind_bo_offset);
d699 2
a700 2
   /* BRW_NEW_SURFACES */
   for (i = 0; i < BRW_MAX_WM_SURFACES; i++) {
d702 5
d709 1
a709 1
   brw->state.dirty.brw |= BRW_NEW_PS_BINDING_TABLE;
d716 1
a716 1
	      BRW_NEW_SURFACES),
d719 1
a719 1
   .emit = brw_upload_wm_binding_table,
a720 10

void
gen4_init_vtable_surface_functions(struct brw_context *brw)
{
   brw->vtbl.update_texture_surface = brw_update_texture_surface;
   brw->vtbl.update_renderbuffer_surface = brw_update_renderbuffer_surface;
   brw->vtbl.update_null_renderbuffer_surface =
      brw_update_null_renderbuffer_surface;
   brw->vtbl.create_constant_surface = brw_create_constant_surface;
}
@


1.1.1.5
log
@Import Mesa 9.2.3
@
text
@a261 1
   /* BRW_NEW_UNIFORM_BUFFER */
a799 1
             BRW_NEW_UNIFORM_BUFFER |
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics to
d5 1
a5 1

d13 1
a13 1

d17 1
a17 1

d25 1
a25 1

d29 1
a29 1
  *   Keith Whitwell <keithw@@vmware.com>
d31 1
a31 1

d54 1
a54 1
   case GL_TEXTURE_1D:
d58 1
a58 1
   case GL_TEXTURE_RECTANGLE_NV:
d61 1
a61 1
   case GL_TEXTURE_2D:
d68 1
a68 1
   case GL_TEXTURE_3D:
d71 1
a71 1
   case GL_TEXTURE_CUBE_MAP:
d75 2
a76 2
   default:
      assert(0);
a103 24
void
brw_configure_w_tiled(const struct intel_mipmap_tree *mt,
                      bool is_render_target,
                      unsigned *width, unsigned *height,
                      unsigned *pitch, uint32_t *tiling, unsigned *format)
{
   static const unsigned halign_stencil = 8;

   /* In Y-tiling row is twice as wide as in W-tiling, and subsequently
    * there are half as many rows.
    * In addition, mip-levels are accessed manually by the program and
    * therefore the surface is setup to cover all the mip-levels for one slice.
    * (Hardware is still used to access individual slices).
    */
   *tiling = I915_TILING_Y;
   *pitch = mt->pitch * 2;
   *width = ALIGN(mt->total_width, halign_stencil) * 2;
   *height = (mt->total_height / mt->physical_depth0) / 2;

   if (is_render_target) {
      *format = BRW_SURFACEFORMAT_R8_UINT;
   }
}

d193 1
a194 36
gen4_emit_buffer_surface_state(struct brw_context *brw,
                               uint32_t *out_offset,
                               drm_intel_bo *bo,
                               unsigned buffer_offset,
                               unsigned surface_format,
                               unsigned buffer_size,
                               unsigned pitch,
                               unsigned mocs,
                               bool rw)
{
   uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
                                    6 * 4, 32, out_offset);
   memset(surf, 0, 6 * 4);

   surf[0] = BRW_SURFACE_BUFFER << BRW_SURFACE_TYPE_SHIFT |
             surface_format << BRW_SURFACE_FORMAT_SHIFT |
             (brw->gen >= 6 ? BRW_SURFACE_RC_READ_WRITE : 0);
   surf[1] = (bo ? bo->offset64 : 0) + buffer_offset; /* reloc */
   surf[2] = (buffer_size & 0x7f) << BRW_SURFACE_WIDTH_SHIFT |
             ((buffer_size >> 7) & 0x1fff) << BRW_SURFACE_HEIGHT_SHIFT;
   surf[3] = ((buffer_size >> 20) & 0x7f) << BRW_SURFACE_DEPTH_SHIFT |
             (pitch - 1) << BRW_SURFACE_PITCH_SHIFT;

   /* Emit relocation to surface contents.  The 965 PRM, Volume 4, section
    * 5.1.2 "Data Cache" says: "the data cache does not exist as a separate
    * physical cache.  It is mapped in hardware to the sampler cache."
    */
   if (bo) {
      drm_intel_bo_emit_reloc(brw->batch.bo, *out_offset + 4,
                              bo, buffer_offset,
                              I915_GEM_DOMAIN_SAMPLER,
                              (rw ? I915_GEM_DOMAIN_SAMPLER : 0));
   }
}

void
d197 2
a198 1
                                  uint32_t *surf_offset)
d202 1
d205 2
a206 3
   uint32_t size = tObj->BufferSize;
   drm_intel_bo *bo = NULL;
   mesa_format format = tObj->_BufferObjectFormat;
a209 5
   if (intel_obj) {
      size = MIN2(size, intel_obj->Base.Size);
      bo = intel_bufferobj_buffer(brw, intel_obj, tObj->BufferOffset, size);
   }

d215 30
a244 7
   brw->vtbl.emit_buffer_surface_state(brw, surf_offset, bo,
                                       tObj->BufferOffset,
                                       brw_format,
                                       size / texel_size,
                                       texel_size,
                                       0, /* mocs */
                                       false /* rw */);
d250 2
a251 2
                           uint32_t *surf_offset,
                           bool for_gather)
d257 1
d260 1
d264 1
a264 1
      brw_update_buffer_texture_surface(ctx, unit, surf_offset);
d269 1
a269 33
			  6 * 4, 32, surf_offset);

   uint32_t tex_format = translate_tex_format(brw, mt->format,
                                              sampler->sRGBDecode);

   if (for_gather) {
      /* Sandybridge's gather4 message is broken for integer formats.
       * To work around this, we pretend the surface is UNORM for
       * 8 or 16-bit formats, and emit shader instructions to recover
       * the real INT/UINT value.  For 32-bit formats, we pretend
       * the surface is FLOAT, and simply reinterpret the resulting
       * bits.
       */
      switch (tex_format) {
      case BRW_SURFACEFORMAT_R8_SINT:
      case BRW_SURFACEFORMAT_R8_UINT:
         tex_format = BRW_SURFACEFORMAT_R8_UNORM;
         break;

      case BRW_SURFACEFORMAT_R16_SINT:
      case BRW_SURFACEFORMAT_R16_UINT:
         tex_format = BRW_SURFACEFORMAT_R16_UNORM;
         break;

      case BRW_SURFACEFORMAT_R32_SINT:
      case BRW_SURFACEFORMAT_R32_UINT:
         tex_format = BRW_SURFACEFORMAT_R32_FLOAT;
         break;

      default:
         break;
      }
   }
d274 9
a282 3
	      tex_format << BRW_SURFACE_FORMAT_SHIFT);

   surf[1] = mt->bo->offset64 + mt->offset; /* reloc */
d288 1
a288 1
   surf[3] = (brw_get_surface_tiling_bits(mt->tiling) |
d290 2
a291 1
	      (mt->pitch - 1) << BRW_SURFACE_PITCH_SHIFT);
d293 1
a293 2
   surf[4] = (brw_get_surface_num_multisamples(mt->num_samples) |
              SET_FIELD(tObj->BaseLevel - mt->first_level, BRW_SURFACE_MIN_LOD));
d295 9
a303 1
   surf[5] = mt->align_h == 4 ? BRW_SURFACE_VERTICAL_ALIGN_ENABLE : 0;
d307 4
a310 4
                           *surf_offset + 4,
                           mt->bo,
                           surf[1] - mt->bo->offset64,
                           I915_GEM_DOMAIN_SAMPLER, 0);
d317 1
a317 1
void
d327 12
d340 19
a358 3
   brw->vtbl.emit_buffer_surface_state(brw, out_offset, bo, offset,
                                       BRW_SURFACEFORMAT_R32G32B32A32_FLOAT,
                                       elements, stride, 0, false);
d374 1
a374 4
   uint32_t offset_bytes = 4 * offset_dwords;
   drm_intel_bo *bo = intel_bufferobj_buffer(brw, intel_bo,
                                             offset_bytes,
                                             buffer_obj->Size - offset_bytes);
d378 1
d431 1
a431 1
   surf[1] = bo->offset64 + offset_bytes; /* reloc */
d460 3
a462 3
   const int size = brw->wm.prog_data->base.nr_pull_params * sizeof(float);
   const int surf_index =
      brw->wm.prog_data->base.binding_table.pull_constants_start;
d468 5
a472 3
   if (brw->wm.prog_data->base.nr_pull_params == 0) {
      if (brw->wm.base.surf_offset[surf_index]) {
	 brw->wm.base.surf_offset[surf_index] = 0;
d478 4
d483 10
a492 12
   drm_intel_bo *const_bo = NULL;
   uint32_t const_offset;
   float *constants = intel_upload_space(brw, size, 64,
                                         &const_bo, &const_offset);
   for (i = 0; i < brw->wm.prog_data->base.nr_pull_params; i++) {
      constants[i] = *brw->wm.prog_data->base.pull_param[i];
   }

   brw_create_constant_surface(brw, const_bo, const_offset, size,
                               &brw->wm.base.surf_offset[surf_index],
                               true);
   drm_intel_bo_unreference(const_bo);
a532 2
   uint32_t surf_index =
      brw->wm.prog_data->binding_table.render_target_start + unit;
d537 2
a538 2
   surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE, 6 * 4, 32,
                          &brw->wm.base.surf_offset[surf_index]);
d575 1
a575 1
   surf[1] = bo ? bo->offset64 : 0;
d591 1
a591 1
                              brw->wm.base.surf_offset[surf_index] + 4,
d611 1
d616 1
a616 3
   mesa_format rb_format = _mesa_get_render_format(ctx, intel_rb_format(irb));
   uint32_t surf_index =
      brw->wm.prog_data->binding_table.render_target_start + unit;
d637 4
a640 2
   surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE, 6 * 4, 32,
                          &brw->wm.base.surf_offset[surf_index]);
d653 1
a653 1
	      mt->bo->offset64);
d658 2
a659 2
   surf[3] = (brw_get_surface_tiling_bits(mt->tiling) |
	      (mt->pitch - 1) << BRW_SURFACE_PITCH_SHIFT);
d696 3
a698 3
			   brw->wm.base.surf_offset[surf_index] + 4,
			   mt->bo,
			   surf[1] - mt->bo->offset64,
d718 1
a718 1
                                                  ctx->DrawBuffer->MaxNumLayers > 0, i);
d748 3
a750 1

d752 1
a752 4
update_stage_texture_surfaces(struct brw_context *brw,
                              const struct gl_program *prog,
                              struct brw_stage_state *stage_state,
                              bool for_gather)
d754 1
a754 2
   if (!prog)
      return;
d756 8
a763 1
   struct gl_context *ctx = &brw->ctx;
d765 1
a765 5
   uint32_t *surf_offset = stage_state->surf_offset;
   if (for_gather)
      surf_offset += stage_state->prog_data->binding_table.gather_texture_start;
   else
      surf_offset += stage_state->prog_data->binding_table.texture_start;
a766 1
   unsigned num_samplers = _mesa_fls(prog->SamplersUsed);
d768 2
a769 1
      surf_offset[s] = 0;
d771 2
a772 2
      if (prog->SamplersUsed & (1 << s)) {
         const unsigned unit = prog->SamplerUnits[s];
d775 4
a778 2
         if (ctx->Texture.Unit[unit]._Current) {
            brw->vtbl.update_texture_surface(ctx, unit, surf_offset + s, for_gather);
a780 2
   }
}
d782 2
d785 7
a791 30
/**
 * Construct SURFACE_STATE objects for enabled textures.
 */
static void
brw_update_texture_surfaces(struct brw_context *brw)
{
   /* BRW_NEW_VERTEX_PROGRAM */
   struct gl_program *vs = (struct gl_program *) brw->vertex_program;

   /* BRW_NEW_GEOMETRY_PROGRAM */
   struct gl_program *gs = (struct gl_program *) brw->geometry_program;

   /* BRW_NEW_FRAGMENT_PROGRAM */
   struct gl_program *fs = (struct gl_program *) brw->fragment_program;

   /* _NEW_TEXTURE */
   update_stage_texture_surfaces(brw, vs, &brw->vs.base, false);
   update_stage_texture_surfaces(brw, gs, &brw->gs.base, false);
   update_stage_texture_surfaces(brw, fs, &brw->wm.base, false);

   /* emit alternate set of surface state for gather. this
    * allows the surface format to be overriden for only the
    * gather4 messages. */
   if (brw->gen < 8) {
      if (vs && vs->UsesGather)
         update_stage_texture_surfaces(brw, vs, &brw->vs.base, true);
      if (gs && gs->UsesGather)
         update_stage_texture_surfaces(brw, gs, &brw->gs.base, true);
      if (fs && fs->UsesGather)
         update_stage_texture_surfaces(brw, fs, &brw->wm.base, true);
a802 1
             BRW_NEW_GEOMETRY_PROGRAM |
d812 1
a812 2
                        struct brw_stage_state *stage_state,
                        struct brw_stage_prog_data *prog_data)
a818 3
   uint32_t *surf_offsets =
      &stage_state->surf_offset[prog_data->binding_table.ubo_start];

d825 1
a825 4
      drm_intel_bo *bo =
         intel_bufferobj_buffer(brw, intel_bo,
                                binding->Offset,
                                binding->BufferObject->Size - binding->Offset);
d831 4
a834 4
      brw_create_constant_surface(brw, bo, binding->Offset,
                                  bo->size - binding->Offset,
                                  &surf_offsets[i],
                                  shader->Stage == MESA_SHADER_FRAGMENT);
d846 1
a846 1
   struct gl_shader_program *prog = ctx->_Shader->_CurrentFragmentProgram;
a850 1
   /* CACHE_NEW_WM_PROG */
d852 1
a852 1
                           &brw->wm.base, &brw->wm.prog_data->base);
d859 1
a859 1
      .cache = CACHE_NEW_WM_PROG,
d864 6
a869 5
void
brw_upload_abo_surfaces(struct brw_context *brw,
			struct gl_shader_program *prog,
                        struct brw_stage_state *stage_state,
                        struct brw_stage_prog_data *prog_data)
d871 2
a872 3
   struct gl_context *ctx = &brw->ctx;
   uint32_t *surf_offsets =
      &stage_state->surf_offset[prog_data->binding_table.abo_start];
d874 2
a875 11
   for (int i = 0; i < prog->NumAtomicBuffers; i++) {
      struct gl_atomic_buffer_binding *binding =
         &ctx->AtomicBufferBindings[prog->AtomicBuffers[i].Binding];
      struct intel_buffer_object *intel_bo =
         intel_buffer_object(binding->BufferObject);
      drm_intel_bo *bo = intel_bufferobj_buffer(
         brw, intel_bo, binding->Offset, intel_bo->Base.Size - binding->Offset);

      brw->vtbl.create_raw_surface(brw, bo, binding->Offset,
                                   bo->size - binding->Offset,
                                   &surf_offsets[i], true);
d878 6
a883 3
   if (prog->NumUniformBlocks)
      brw->state.dirty.brw |= BRW_NEW_SURFACES;
}
d885 4
a888 6
static void
brw_upload_wm_abo_surfaces(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   /* _NEW_PROGRAM */
   struct gl_shader_program *prog = ctx->Shader._CurrentFragmentProgram;
d890 1
a890 5
   if (prog) {
      /* CACHE_NEW_WM_PROG */
      brw_upload_abo_surfaces(brw, prog, &brw->wm.base,
                              &brw->wm.prog_data->base);
   }
d893 1
a893 1
const struct brw_tracked_state brw_wm_abo_surfaces = {
d895 4
a898 3
      .mesa = _NEW_PROGRAM,
      .brw = BRW_NEW_BATCH | BRW_NEW_ATOMIC_BUFFER,
      .cache = CACHE_NEW_WM_PROG,
d900 1
a900 1
   .emit = brw_upload_wm_abo_surfaces,
d910 1
a910 1
   brw->vtbl.emit_buffer_surface_state = gen4_emit_buffer_surface_state;
@


1.1.1.7
log
@Import Mesa 10.4.3
@
text
@d76 2
a77 1
      unreachable("not reached");
d300 1
a300 1
   /* BRW_NEW_TEXTURE_BUFFER */
d393 1
a393 1
 * buffer_size_minus_1 must be less than BRW_MAX_NUM_BUFFER_ENTRIES.
d452 3
a454 1
      unreachable("Invalid vector size for transform feedback output");
d485 1
a485 1
   struct brw_stage_state *stage_state = &brw->wm.base;
d489 8
d498 7
a504 1
   struct brw_stage_prog_data *prog_data = &brw->wm.prog_data->base;
d507 14
a520 2
   brw_upload_pull_constants(brw, BRW_NEW_SURFACES, &fp->program.Base,
                             stage_state, prog_data, true);
a531 8
/**
 * Creates a null renderbuffer surface.
 *
 * This is used when the shader doesn't write to any color output.  An FB
 * write to target 0 will still be emitted, because that's how the thread is
 * terminated (and computed depth is returned), so we need to have the
 * hardware discard the target 0 color output..
 */
a558 1
   /* CACHE_NEW_WM_PROG */
a643 1
   /* CACHE_NEW_WM_PROG */
d761 1
a761 1
      .cache = CACHE_NEW_WM_PROG,
a787 2

   /* CACHE_NEW_*_PROG */
d848 1
a848 1
             BRW_NEW_TEXTURE_BUFFER |
d852 1
a852 1
      .cache = CACHE_NEW_VS_PROG | CACHE_NEW_GS_PROG | CACHE_NEW_WM_PROG,
d943 1
a943 1
   if (prog->NumAtomicBuffers)
@


1.1.1.8
log
@Import Mesa 10.2.9
@
text
@d76 1
a76 2
      assert(0);
      return 0;
d299 1
a299 1
   /* BRW_NEW_UNIFORM_BUFFER */
d392 1
a392 1
 * buffer_size_minus_1 must me less than BRW_MAX_NUM_BUFFER_ENTRIES.
d451 1
a451 3
      assert(!"Invalid vector size for transform feedback output");
      surface_format = BRW_SURFACEFORMAT_R32_FLOAT;
      break;
d482 1
a482 1
   struct gl_context *ctx = &brw->ctx;
a485 8
   struct gl_program_parameter_list *params = fp->program.Base.Parameters;
   const int size = brw->wm.prog_data->base.nr_pull_params * sizeof(float);
   const int surf_index =
      brw->wm.prog_data->base.binding_table.pull_constants_start;
   unsigned int i;

   _mesa_load_state_parameters(ctx, params);

d487 1
a487 7
   if (brw->wm.prog_data->base.nr_pull_params == 0) {
      if (brw->wm.base.surf_offset[surf_index]) {
	 brw->wm.base.surf_offset[surf_index] = 0;
	 brw->state.dirty.brw |= BRW_NEW_SURFACES;
      }
      return;
   }
d490 2
a491 14
   drm_intel_bo *const_bo = NULL;
   uint32_t const_offset;
   float *constants = intel_upload_space(brw, size, 64,
                                         &const_bo, &const_offset);
   for (i = 0; i < brw->wm.prog_data->base.nr_pull_params; i++) {
      constants[i] = *brw->wm.prog_data->base.pull_param[i];
   }

   brw_create_constant_surface(brw, const_bo, const_offset, size,
                               &brw->wm.base.surf_offset[surf_index],
                               true);
   drm_intel_bo_unreference(const_bo);

   brw->state.dirty.brw |= BRW_NEW_SURFACES;
d503 8
d538 1
d624 1
d742 1
a742 1
      .cache = 0
d769 2
d831 1
a831 1
             BRW_NEW_UNIFORM_BUFFER |
d835 1
a835 1
      .cache = 0
d926 1
a926 1
   if (prog->NumUniformBlocks)
@


