head	1.6;
access;
symbols
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2013.09.05.14.04.33;	author jsg;	state dead;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.38;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Merge Mesa 9.2.0
@
text
@/**************************************************************************
 * 
 * Copyright 2006 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portionsalloc
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "main/glheader.h"
#include "main/enums.h"
#include "main/image.h"
#include "main/colormac.h"
#include "main/condrender.h"
#include "main/mtypes.h"
#include "main/macros.h"
#include "main/pbo.h"
#include "main/bufferobj.h"
#include "main/state.h"
#include "main/texobj.h"
#include "main/context.h"
#include "swrast/swrast.h"
#include "drivers/common/meta.h"

#include "intel_screen.h"
#include "intel_context.h"
#include "intel_batchbuffer.h"
#include "intel_blit.h"
#include "intel_regions.h"
#include "intel_buffers.h"
#include "intel_pixel.h"
#include "intel_reg.h"


#define FILE_DEBUG_FLAG DEBUG_PIXEL


/* Unlike the other intel_pixel_* functions, the expectation here is
 * that the incoming data is not in a PBO.  With the XY_TEXT blit
 * method, there's no benefit haveing it in a PBO, but we could
 * implement a path based on XY_MONO_SRC_COPY_BLIT which might benefit
 * PBO bitmaps.  I think they are probably pretty rare though - I
 * wonder if Xgl uses them?
 */
static const GLubyte *map_pbo( struct gl_context *ctx,
			       GLsizei width, GLsizei height,
			       const struct gl_pixelstore_attrib *unpack,
			       const GLubyte *bitmap )
{
   GLubyte *buf;

   if (!_mesa_validate_pbo_access(2, unpack, width, height, 1,
				  GL_COLOR_INDEX, GL_BITMAP,
				  INT_MAX, (const GLvoid *) bitmap)) {
      _mesa_error(ctx, GL_INVALID_OPERATION,"glBitmap(invalid PBO access)");
      return NULL;
   }

   buf = (GLubyte *) ctx->Driver.MapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
					   GL_READ_ONLY_ARB,
					   unpack->BufferObj);
   if (!buf) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBitmap(PBO is mapped)");
      return NULL;
   }

   return ADD_POINTERS(buf, bitmap);
}

static GLboolean test_bit( const GLubyte *src, GLuint bit )
{
   return (src[bit/8] & (1<<(bit % 8))) ? 1 : 0;
}

static void set_bit( GLubyte *dest, GLuint bit )
{
   dest[bit/8] |= 1 << (bit % 8);
}

/* Extract a rectangle's worth of data from the bitmap.  Called
 * per chunk of HW-sized bitmap.
 */
static GLuint get_bitmap_rect(GLsizei width, GLsizei height,
			      const struct gl_pixelstore_attrib *unpack,
			      const GLubyte *bitmap,
			      GLuint x, GLuint y, 
			      GLuint w, GLuint h,
			      GLubyte *dest,
			      GLuint row_align,
			      GLboolean invert)
{
   GLuint src_offset = (x + unpack->SkipPixels) & 0x7;
   GLuint mask = unpack->LsbFirst ? 0 : 7;
   GLuint bit = 0;
   GLint row, col;
   GLint first, last;
   GLint incr;
   GLuint count = 0;

   DBG("%s %d,%d %dx%d bitmap %dx%d skip %d src_offset %d mask %d\n",
       __FUNCTION__, x,y,w,h,width,height,unpack->SkipPixels, src_offset, mask);

   if (invert) {
      first = h-1;
      last = 0;
      incr = -1;
   }
   else {
      first = 0;
      last = h-1;
      incr = 1;
   }

   /* Require that dest be pre-zero'd.
    */
   for (row = first; row != (last+incr); row += incr) {
      const GLubyte *rowsrc = _mesa_image_address2d(unpack, bitmap, 
						    width, height, 
						    GL_COLOR_INDEX, GL_BITMAP, 
						    y + row, x);

      for (col = 0; col < w; col++, bit++) {
	 if (test_bit(rowsrc, (col + src_offset) ^ mask)) {
	    set_bit(dest, bit ^ 7);
	    count++;
	 }
      }

      if (row_align)
	 bit = ALIGN(bit, row_align);
   }

   return count;
}

/**
 * Returns the low Y value of the vertical range given, flipped according to
 * whether the framebuffer is or not.
 */
static INLINE int
y_flip(struct gl_framebuffer *fb, int y, int height)
{
   if (fb->Name != 0)
      return y;
   else
      return fb->Height - y - height;
}

/*
 * Render a bitmap.
 */
static GLboolean
do_blit_bitmap( struct gl_context *ctx, 
		GLint dstx, GLint dsty,
		GLsizei width, GLsizei height,
		const struct gl_pixelstore_attrib *unpack,
		const GLubyte *bitmap )
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_region *dst;
   struct gl_framebuffer *fb = ctx->DrawBuffer;
   GLfloat tmpColor[4];
   GLubyte ubcolor[4];
   GLuint color;
   GLsizei bitmap_width = width;
   GLsizei bitmap_height = height;
   GLint px, py;
   GLuint stipple[32];
   GLint orig_dstx = dstx;
   GLint orig_dsty = dsty;

   /* Update draw buffer bounds */
   _mesa_update_state(ctx);

   if (ctx->Depth.Test) {
      /* The blit path produces incorrect results when depth testing is on.
       * It seems the blit Z coord is always 1.0 (the far plane) so fragments
       * will likely be obscured by other, closer geometry.
       */
      return GL_FALSE;
   }

   intel_prepare_render(intel);
   dst = intel_drawbuf_region(intel);

   if (!dst)
       return GL_FALSE;

   if (_mesa_is_bufferobj(unpack->BufferObj)) {
      bitmap = map_pbo(ctx, width, height, unpack, bitmap);
      if (bitmap == NULL)
	 return GL_TRUE;	/* even though this is an error, we're done */
   }

   COPY_4V(tmpColor, ctx->Current.RasterColor);

   if (_mesa_need_secondary_color(ctx)) {
       ADD_3V(tmpColor, tmpColor, ctx->Current.RasterSecondaryColor);
   }

   UNCLAMPED_FLOAT_TO_UBYTE(ubcolor[0], tmpColor[0]);
   UNCLAMPED_FLOAT_TO_UBYTE(ubcolor[1], tmpColor[1]);
   UNCLAMPED_FLOAT_TO_UBYTE(ubcolor[2], tmpColor[2]);
   UNCLAMPED_FLOAT_TO_UBYTE(ubcolor[3], tmpColor[3]);

   if (dst->cpp == 2)
      color = PACK_COLOR_565(ubcolor[0], ubcolor[1], ubcolor[2]);
   else
      color = PACK_COLOR_8888(ubcolor[3], ubcolor[0], ubcolor[1], ubcolor[2]);

   if (!intel_check_blit_fragment_ops(ctx, tmpColor[3] == 1.0F))
      return GL_FALSE;

   /* Clip to buffer bounds and scissor. */
   if (!_mesa_clip_to_region(fb->_Xmin, fb->_Ymin,
			     fb->_Xmax, fb->_Ymax,
			     &dstx, &dsty, &width, &height))
      goto out;

   dsty = y_flip(fb, dsty, height);

#define DY 32
#define DX 32

   /* Chop it all into chunks that can be digested by hardware: */
   for (py = 0; py < height; py += DY) {
      for (px = 0; px < width; px += DX) {
	 int h = MIN2(DY, height - py);
	 int w = MIN2(DX, width - px);
	 GLuint sz = ALIGN(ALIGN(w,8) * h, 64)/8;
	 GLenum logic_op = ctx->Color.ColorLogicOpEnabled ?
	    ctx->Color.LogicOp : GL_COPY;

	 assert(sz <= sizeof(stipple));
	 memset(stipple, 0, sz);

	 /* May need to adjust this when padding has been introduced in
	  * sz above:
	  *
	  * Have to translate destination coordinates back into source
	  * coordinates.
	  */
	 if (get_bitmap_rect(bitmap_width, bitmap_height, unpack,
			     bitmap,
			     -orig_dstx + (dstx + px),
			     -orig_dsty + y_flip(fb, dsty + py, h),
			     w, h,
			     (GLubyte *)stipple,
			     8,
			     fb->Name == 0 ? GL_TRUE : GL_FALSE) == 0)
	    continue;

	 if (!intelEmitImmediateColorExpandBlit(intel,
						dst->cpp,
						(GLubyte *)stipple,
						sz,
						color,
						dst->pitch,
						dst->buffer,
						0,
						dst->tiling,
						dstx + px,
						dsty + py,
						w, h,
						logic_op)) {
	    return GL_FALSE;
	 }
      }
   }
out:

   if (unlikely(INTEL_DEBUG & DEBUG_SYNC))
      intel_batchbuffer_flush(intel);

   if (_mesa_is_bufferobj(unpack->BufferObj)) {
      /* done with PBO so unmap it now */
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              unpack->BufferObj);
   }

   intel_check_front_buffer_rendering(intel);

   return GL_TRUE;
}


/* There are a large number of possible ways to implement bitmap on
 * this hardware, most of them have some sort of drawback.  Here are a
 * few that spring to mind:
 * 
 * Blit:
 *    - XY_MONO_SRC_BLT_CMD
 *         - use XY_SETUP_CLIP_BLT for cliprect clipping.
 *    - XY_TEXT_BLT
 *    - XY_TEXT_IMMEDIATE_BLT
 *         - blit per cliprect, subject to maximum immediate data size.
 *    - XY_COLOR_BLT 
 *         - per pixel or run of pixels
 *    - XY_PIXEL_BLT
 *         - good for sparse bitmaps
 *
 * 3D engine:
 *    - Point per pixel
 *    - Translate bitmap to an alpha texture and render as a quad
 *    - Chop bitmap up into 32x32 squares and render w/polygon stipple.
 */
void
intelBitmap(struct gl_context * ctx,
	    GLint x, GLint y,
	    GLsizei width, GLsizei height,
	    const struct gl_pixelstore_attrib *unpack,
	    const GLubyte * pixels)
{
   struct intel_context *intel = intel_context(ctx);

   if (!_mesa_check_conditional_render(ctx))
      return;

   if (do_blit_bitmap(ctx, x, y, width, height,
                          unpack, pixels))
      return;

   /* FIXME */
   if (intel->gen == 6)
       return _swrast_Bitmap(ctx, x, y, width, height, unpack, pixels);

   _mesa_meta_Bitmap(ctx, x, y, width, height, unpack, pixels);
}
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.4
log
@Merge Mesa 7.10.3
@
text
@d32 1
d35 1
d72 1
a72 1
				  (GLvoid *) bitmap)) {
d178 1
a178 1
   struct intel_region *dst = intel_drawbuf_region(intel);
d201 3
d215 1
a215 1
   if (NEED_SECONDARY_COLOR(ctx)) {
a231 2
   intel_prepare_render(intel);

d291 1
a291 1
      intel_batchbuffer_flush(intel->batch);
d333 3
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a34 3
#include "main/polygon.h"
#include "main/pixelstore.h"
#include "main/polygon.h"
a35 1
#include "main/teximage.h"
d37 1
a37 7
#include "main/texstate.h"
#include "main/texparam.h"
#include "main/varray.h"
#include "main/attrib.h"
#include "main/enable.h"
#include "main/viewport.h"
#include "shader/arbprogram.h"
d39 1
d61 1
a61 1
static const GLubyte *map_pbo( GLcontext *ctx,
d116 2
a117 3
   if (INTEL_DEBUG & DEBUG_PIXEL)
      printf("%s %d,%d %dx%d bitmap %dx%d skip %d src_offset %d mask %d\n",
		   __FUNCTION__, x,y,w,h,width,height,unpack->SkipPixels, src_offset, mask);
d169 1
a169 1
do_blit_bitmap( GLcontext *ctx, 
d287 1
a287 1
   if (INTEL_DEBUG & DEBUG_SYNC)
a300 171
static GLboolean
intel_texture_bitmap(GLcontext * ctx,
		     GLint dst_x, GLint dst_y,
		     GLsizei width, GLsizei height,
		     const struct gl_pixelstore_attrib *unpack,
		     const GLubyte *bitmap)
{
   struct intel_context *intel = intel_context(ctx);
   static const char *fp =
      "!!ARBfp1.0\n"
      "TEMP val;\n"
      "PARAM color=program.local[0];\n"
      "TEX val, fragment.texcoord[0], texture[0], 2D;\n"
      "ADD val, val.wwww, {-.5, -.5, -.5, -.5};\n"
      "KIL val;\n"
      "MOV result.color, color;\n"
      "END\n";
   GLuint texname;
   GLfloat vertices[4][4];
   GLint old_active_texture;
   GLubyte *a8_bitmap;
   GLfloat dst_z;

   /* We need a fragment program for the KIL effect */
   if (!ctx->Extensions.ARB_fragment_program ||
       !ctx->Extensions.ARB_vertex_program) {
      if (INTEL_DEBUG & DEBUG_FALLBACKS)
	 fprintf(stderr,
		 "glBitmap fallback: No fragment/vertex program support\n");
      return GL_FALSE;
   }

   /* We're going to mess with texturing with no regard to existing texture
    * state, so if there is some set up we have to bail.
    */
   if (ctx->Texture._EnabledUnits != 0) {
      if (INTEL_DEBUG & DEBUG_FALLBACKS)
	 fprintf(stderr, "glBitmap fallback: texturing enabled\n");
      return GL_FALSE;
   }

   /* Can't do textured DrawPixels with a fragment program, unless we were
    * to generate a new program that sampled our texture and put the results
    * in the fragment color before the user's program started.
    */
   if (ctx->FragmentProgram.Enabled) {
      if (INTEL_DEBUG & DEBUG_FALLBACKS)
	 fprintf(stderr, "glBitmap fallback: fragment program enabled\n");
      return GL_FALSE;
   }

   if (ctx->VertexProgram.Enabled) {
      if (INTEL_DEBUG & DEBUG_FALLBACKS)
	 fprintf(stderr, "glBitmap fallback: vertex program enabled\n");
      return GL_FALSE;
   }

   if (!ctx->Extensions.ARB_texture_non_power_of_two &&
       (!is_power_of_two(width) || !is_power_of_two(height))) {
      if (INTEL_DEBUG & DEBUG_FALLBACKS)
	 fprintf(stderr,
		 "glBitmap() fallback: NPOT texture\n");
      return GL_FALSE;
   }

   if (ctx->Fog.Enabled) {
      if (INTEL_DEBUG & DEBUG_FALLBACKS)
	 fprintf(stderr, "glBitmap() fallback: fog\n");
      return GL_FALSE;
   }

   /* Check that we can load in a texture this big. */
   if (width > (1 << (ctx->Const.MaxTextureLevels - 1)) ||
       height > (1 << (ctx->Const.MaxTextureLevels - 1))) {
      if (INTEL_DEBUG & DEBUG_FALLBACKS)
	 fprintf(stderr, "glBitmap fallback: bitmap too large (%dx%d)\n",
		 width, height);
      return GL_FALSE;
   }

   if (_mesa_is_bufferobj(unpack->BufferObj)) {
      bitmap = map_pbo(ctx, width, height, unpack, bitmap);
      if (bitmap == NULL)
	 return GL_TRUE;	/* even though this is an error, we're done */
   }

   /* Convert the A1 bitmap to an A8 format suitable for glTexImage */
   a8_bitmap = calloc(1, width * height);
   _mesa_expand_bitmap(width, height, unpack, bitmap, a8_bitmap, width, 0xff);

   if (_mesa_is_bufferobj(unpack->BufferObj)) {
      /* done with PBO so unmap it now */
      ctx->Driver.UnmapBuffer(ctx, GL_PIXEL_UNPACK_BUFFER_EXT,
                              unpack->BufferObj);
   }

   /* Save GL state before we start setting up our drawing */
   _mesa_PushAttrib(GL_ENABLE_BIT | GL_CURRENT_BIT | GL_POLYGON_BIT |
                    GL_TEXTURE_BIT | GL_VIEWPORT_BIT);
   _mesa_PushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT |
			  GL_CLIENT_PIXEL_STORE_BIT);
   old_active_texture = ctx->Texture.CurrentUnit;

   _mesa_Disable(GL_POLYGON_STIPPLE);
   _mesa_PolygonMode(GL_FRONT_AND_BACK, GL_FILL);

   /* Upload our bitmap data to an alpha texture */
   _mesa_ActiveTextureARB(GL_TEXTURE0_ARB);
   _mesa_Enable(GL_TEXTURE_2D);
   _mesa_GenTextures(1, &texname);
   _mesa_BindTexture(GL_TEXTURE_2D, texname);
   _mesa_TexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
   _mesa_TexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

   _mesa_PixelStorei(GL_UNPACK_SWAP_BYTES, GL_FALSE);
   _mesa_PixelStorei(GL_UNPACK_LSB_FIRST, GL_FALSE);
   _mesa_PixelStorei(GL_UNPACK_ROW_LENGTH, 0);
   _mesa_PixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
   _mesa_PixelStorei(GL_UNPACK_SKIP_ROWS, 0);
   _mesa_PixelStorei(GL_UNPACK_ALIGNMENT, 1);
   _mesa_TexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, width, height, 0,
		    GL_ALPHA, GL_UNSIGNED_BYTE, a8_bitmap);
   free(a8_bitmap);

   meta_set_fragment_program(&intel->meta, &intel->meta.bitmap_fp, fp);
   _mesa_ProgramLocalParameter4fvARB(GL_FRAGMENT_PROGRAM_ARB, 0,
				     ctx->Current.RasterColor);
   meta_set_passthrough_vertex_program(&intel->meta);
   meta_set_passthrough_transform(&intel->meta);

   /* convert rasterpos Z from [0,1] to NDC coord in [-1,1] */
   dst_z = -1.0 + 2.0 * ctx->Current.RasterPos[2];

   /* RasterPos[2] already takes into account the DepthRange mapping. */
   _mesa_DepthRange(0.0, 1.0);

   vertices[0][0] = dst_x;
   vertices[0][1] = dst_y;
   vertices[0][2] = dst_z;
   vertices[0][3] = 1.0;
   vertices[1][0] = dst_x + width;
   vertices[1][1] = dst_y;
   vertices[1][2] = dst_z;
   vertices[1][3] = 1.0;
   vertices[2][0] = dst_x + width;
   vertices[2][1] = dst_y + height;
   vertices[2][2] = dst_z;
   vertices[2][3] = 1.0;
   vertices[3][0] = dst_x;
   vertices[3][1] = dst_y + height;
   vertices[3][2] = dst_z;
   vertices[3][3] = 1.0;

   _mesa_VertexPointer(4, GL_FLOAT, 4 * sizeof(GLfloat), &vertices);
   _mesa_Enable(GL_VERTEX_ARRAY);
   meta_set_default_texrect(&intel->meta);
   _mesa_DrawArrays(GL_TRIANGLE_FAN, 0, 4);

   meta_restore_texcoords(&intel->meta);
   meta_restore_transform(&intel->meta);
   meta_restore_fragment_program(&intel->meta);
   meta_restore_vertex_program(&intel->meta);

   _mesa_ActiveTextureARB(GL_TEXTURE0_ARB + old_active_texture);
   _mesa_PopClientAttrib();
   _mesa_PopAttrib();

   _mesa_DeleteTextures(1, &texname);

   return GL_TRUE;
}
d323 1
a323 1
intelBitmap(GLcontext * ctx,
d329 2
d335 3
a337 6
   if (intel_texture_bitmap(ctx, x, y, width, height,
			    unpack, pixels))
      return;

   if (INTEL_DEBUG & DEBUG_PIXEL)
      printf("%s: fallback to swrast\n", __FUNCTION__);
d339 1
a339 1
   _swrast_Bitmap(ctx, x, y, width, height, unpack, pixels);
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d35 1
d37 1
a39 1
#include "main/texenv.h"
d46 1
a47 1
#include "glapi/dispatch.h"
a54 1
#include "intel_buffer_objects.h"
d95 1
a95 2
static GLboolean test_bit( const GLubyte *src,
			    GLuint bit )
d100 1
a100 7
static GLboolean test_msb_bit(const GLubyte *src, GLuint bit)
{
   return (src[bit/8] & (1<<(7 - (bit % 8)))) ? 1 : 0;
}

static void set_bit( GLubyte *dest,
			  GLuint bit )
d106 1
a106 1
 * per-cliprect.
d126 1
a126 1
      _mesa_printf("%s %d,%d %dx%d bitmap %dx%d skip %d src_offset %d mask %d\n",
d166 1
a166 1
static inline int
d190 1
a190 4
   GLuint color8888, color565;
   unsigned int num_cliprects;
   drm_clip_rect_t *cliprects;
   int x_off, y_off;
d193 4
d212 1
a212 1
   if (unpack->BufferObj->Name) {
d229 4
a232 2
   color8888 = INTEL_PACKCOLOR8888(ubcolor[0], ubcolor[1], ubcolor[2], ubcolor[3]);
   color565 = INTEL_PACKCOLOR565(ubcolor[0], ubcolor[1], ubcolor[2]);
d237 1
a237 1
   LOCK_HARDWARE(intel);
d239 7
a245 32
   intel_get_cliprects(intel, &cliprects, &num_cliprects, &x_off, &y_off);
   if (num_cliprects != 0) {
      GLuint i;
      GLint orig_dstx = dstx;
      GLint orig_dsty = dsty;

      /* Clip to buffer bounds and scissor. */
      if (!_mesa_clip_to_region(fb->_Xmin, fb->_Ymin,
				fb->_Xmax, fb->_Ymax,
				&dstx, &dsty, &width, &height))
            goto out;

      dstx = x_off + dstx;
      dsty = y_off + y_flip(fb, dsty, height);

      for (i = 0; i < num_cliprects; i++) {
	 int box_x, box_y, box_w, box_h;
	 GLint px, py;
	 GLuint stipple[32];  

	 box_x = dstx;
	 box_y = dsty;
	 box_w = width;
	 box_h = height;

	 /* Clip to drawable cliprect */
         if (!_mesa_clip_to_region(cliprects[i].x1,
				   cliprects[i].y1,
				   cliprects[i].x2,
				   cliprects[i].y2,
				   &box_x, &box_y, &box_w, &box_h))
	    continue;
d250 17
a266 2
	 /* Then, finally, chop it all into chunks that can be
	  * digested by hardware:
d268 25
a292 45
	 for (py = 0; py < box_h; py += DY) { 
	    for (px = 0; px < box_w; px += DX) { 
	       int h = MIN2(DY, box_h - py);
	       int w = MIN2(DX, box_w - px); 
	       GLuint sz = ALIGN(ALIGN(w,8) * h, 64)/8;
	       GLenum logic_op = ctx->Color.ColorLogicOpEnabled ?
		  ctx->Color.LogicOp : GL_COPY;

	       assert(sz <= sizeof(stipple));
	       memset(stipple, 0, sz);

	       /* May need to adjust this when padding has been introduced in
		* sz above:
		*
		* Have to translate destination coordinates back into source
		* coordinates.
		*/
	       if (get_bitmap_rect(bitmap_width, bitmap_height, unpack,
				   bitmap,
				   -orig_dstx + (box_x + px - x_off),
				   -orig_dsty + y_flip(fb,
						       box_y + py - y_off, h),
				   w, h,
				   (GLubyte *)stipple,
				   8,
				   fb->Name == 0 ? GL_TRUE : GL_FALSE) == 0)
		  continue;

	       /* 
		*/
	       intelEmitImmediateColorExpandBlit( intel,
						  dst->cpp,
						  (GLubyte *)stipple, 
						  sz,
						  (dst->cpp == 2) ? color565 : color8888,
						  dst->pitch,
						  dst->buffer,
						  0,
						  dst->tiling,
						  box_x + px,
						  box_y + py,
						  w, h,
						  logic_op);
	    } 
	 } 
a295 1
   UNLOCK_HARDWARE(intel);
d300 1
a300 1
   if (unpack->BufferObj->Name) {
d306 2
a329 1
   GLfloat texcoords[4][2];
a330 1
   GLubyte *unpacked_bitmap;
a331 1
   int x, y;
d368 14
d391 1
a391 2
   /* Convert the A1 bitmap to an A8 format suitable for glTexImage */
   if (unpack->BufferObj->Name) {
d396 6
a401 11
   unpacked_bitmap = _mesa_unpack_bitmap(width, height, bitmap,
					 unpack);
   a8_bitmap = _mesa_calloc(width * height);
   for (y = 0; y < height; y++) {
      for (x = 0; x < width; x++) {
	 if (test_msb_bit(unpacked_bitmap, ALIGN(width, 8) * y + x))
	    a8_bitmap[y * width + x] = 0xff;
      }
   }
   _mesa_free(unpacked_bitmap);
   if (unpack->BufferObj->Name) {
d408 2
a409 2
   _mesa_PushAttrib(GL_ENABLE_BIT | GL_CURRENT_BIT |
		    GL_VIEWPORT_BIT);
d415 1
d433 1
a433 1
   _mesa_free(a8_bitmap);
d435 1
a435 1
   intel_meta_set_fragment_program(intel, &intel->meta.bitmap_fp, fp);
d438 2
a439 2
   intel_meta_set_passthrough_vertex_program(intel);
   intel_meta_set_passthrough_transform(intel);
d444 3
a463 9
   texcoords[0][0] = 0.0;
   texcoords[0][1] = 0.0;
   texcoords[1][0] = 1.0;
   texcoords[1][1] = 0.0;
   texcoords[2][0] = 1.0;
   texcoords[2][1] = 1.0;
   texcoords[3][0] = 0.0;
   texcoords[3][1] = 1.0;

a464 2
   _mesa_ClientActiveTextureARB(GL_TEXTURE0);
   _mesa_TexCoordPointer(2, GL_FLOAT, 2 * sizeof(GLfloat), &texcoords);
d466 2
a467 2
   _mesa_Enable(GL_TEXTURE_COORD_ARRAY);
   CALL_DrawArrays(ctx->Exec, (GL_TRIANGLE_FAN, 0, 4));
d469 4
a472 3
   intel_meta_restore_transform(intel);
   intel_meta_restore_fragment_program(intel);
   intel_meta_restore_vertex_program(intel);
d474 1
a475 2
   _mesa_Disable(GL_TEXTURE_2D); /* asserted that it was disabled at entry */
   _mesa_ActiveTextureARB(GL_TEXTURE0_ARB + old_active_texture);
d519 1
a519 1
      _mesa_printf("%s: fallback to swrast\n", __FUNCTION__);
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d28 19
a46 7
#include "glheader.h"
#include "enums.h"
#include "image.h"
#include "colormac.h"
#include "mtypes.h"
#include "macros.h"
#include "bufferobj.h"
a50 1
#include "intel_ioctl.h"
d57 1
a57 1

d101 5
d169 12
a180 2


d194 1
d198 16
d238 1
a238 5
   /* Does zoom apply to bitmaps?
    */
   if (!intel_check_blit_fragment_ops(ctx, tmpColor[3] == 1.0F) ||
       ctx->Pixel.ZoomX != 1.0F || 
       ctx->Pixel.ZoomY != 1.0F)
d243 2
a244 7
   if (intel->driDrawable->numClipRects) {
      __DRIdrawablePrivate *dPriv = intel->driDrawable;
      drm_clip_rect_t *box = dPriv->pClipRects;
      drm_clip_rect_t dest_rect;
      GLint nbox = dPriv->numClipRects;
      GLint srcx = 0, srcy = 0;
      GLint orig_screen_x1, orig_screen_y2;
d246 2
d249 4
a252 14

      orig_screen_x1 = dPriv->x + dstx;
      orig_screen_y2 = dPriv->y + (dPriv->h - dsty);

      /* Do scissoring in GL coordinates:
       */
      if (ctx->Scissor.Enabled)
      {
	 GLint x = ctx->Scissor.X;
	 GLint y = ctx->Scissor.Y;
	 GLuint w = ctx->Scissor.Width;
	 GLuint h = ctx->Scissor.Height;

         if (!_mesa_clip_to_region(x, y, x+w-1, y+h-1, &dstx, &dsty, &width, &height))
a253 1
      }
d255 2
a256 4
      /* Convert from GL to hardware coordinates:
       */
      dsty = dPriv->y + (dPriv->h - dsty - height);  
      dstx = dPriv->x + dstx;
d258 2
a259 8
      dest_rect.x1 = dstx < 0 ? 0 : dstx;
      dest_rect.y1 = dsty < 0 ? 0 : dsty;
      dest_rect.x2 = dstx + width < 0 ? 0 : dstx + width;
      dest_rect.y2 = dsty + height < 0 ? 0 : dsty + height;

      for (i = 0; i < nbox; i++) {
         drm_clip_rect_t rect;
	 int box_w, box_h;
d263 12
a274 11
         if (!intel_intersect_cliprects(&rect, &dest_rect, &box[i]))
            continue;

	 /* Now go back to GL coordinates to figure out what subset of
	  * the bitmap we are uploading for this cliprect:
	  */
	 box_w = rect.x2 - rect.x1;
	 box_h = rect.y2 - rect.y1;
	 srcx = rect.x1 - orig_screen_x1;
	 srcy = orig_screen_y2 - rect.y2;

d295 3
d299 1
a299 1
	       if (get_bitmap_rect(width, height, unpack, 
d301 4
a304 1
				   srcx + px, srcy + py, w, h,
d307 1
a307 1
				   GL_TRUE) == 0)
d320 3
a322 3
						  dst->tiled,
						  rect.x1 + px,
						  rect.y2 - (py + h),
a327 2
   out:
      intel_batchbuffer_flush(intel->batch);
d329 1
d332 2
d344 34
d379 8
d388 9
d398 119
d547 4
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d28 7
a34 10
#include "main/glheader.h"
#include "main/enums.h"
#include "main/image.h"
#include "main/colormac.h"
#include "main/mtypes.h"
#include "main/macros.h"
#include "main/bufferobj.h"
#include "main/state.h"
#include "main/texobj.h"
#include "main/context.h"
a35 1
#include "drivers/common/meta.h"
d39 1
d43 1
d46 1
a46 1
#include "intel_reg.h"
d59 1
a59 1
static const GLubyte *map_pbo( struct gl_context *ctx,
d84 2
a85 1
static GLboolean test_bit( const GLubyte *src, GLuint bit )
d90 2
a91 1
static void set_bit( GLubyte *dest, GLuint bit )
d97 1
a97 1
 * per chunk of HW-sized bitmap.
d116 3
a118 2
   DBG("%s %d,%d %dx%d bitmap %dx%d skip %d src_offset %d mask %d\n",
       __FUNCTION__, x,y,w,h,width,height,unpack->SkipPixels, src_offset, mask);
d153 2
a154 12
/**
 * Returns the low Y value of the vertical range given, flipped according to
 * whether the framebuffer is or not.
 */
static INLINE int
y_flip(struct gl_framebuffer *fb, int y, int height)
{
   if (fb->Name != 0)
      return y;
   else
      return fb->Height - y - height;
}
d160 1
a160 1
do_blit_bitmap( struct gl_context *ctx, 
a167 1
   struct gl_framebuffer *fb = ctx->DrawBuffer;
d170 1
a170 18
   GLuint color;
   GLsizei bitmap_width = width;
   GLsizei bitmap_height = height;
   GLint px, py;
   GLuint stipple[32];
   GLint orig_dstx = dstx;
   GLint orig_dsty = dsty;

   /* Update draw buffer bounds */
   _mesa_update_state(ctx);

   if (ctx->Depth.Test) {
      /* The blit path produces incorrect results when depth testing is on.
       * It seems the blit Z coord is always 1.0 (the far plane) so fragments
       * will likely be obscured by other, closer geometry.
       */
      return GL_FALSE;
   }
d175 1
a175 1
   if (_mesa_is_bufferobj(unpack->BufferObj)) {
d192 2
a193 4
   if (dst->cpp == 2)
      color = PACK_COLOR_565(ubcolor[0], ubcolor[1], ubcolor[2]);
   else
      color = PACK_COLOR_8888(ubcolor[3], ubcolor[0], ubcolor[1], ubcolor[2]);
d195 5
a199 1
   if (!intel_check_blit_fragment_ops(ctx, tmpColor[3] == 1.0F))
d202 11
a212 1
   intel_prepare_render(intel);
d214 42
a255 5
   /* Clip to buffer bounds and scissor. */
   if (!_mesa_clip_to_region(fb->_Xmin, fb->_Ymin,
			     fb->_Xmax, fb->_Ymax,
			     &dstx, &dsty, &width, &height))
      goto out;
a256 1
   dsty = y_flip(fb, dsty, height);
d261 2
a262 17
   /* Chop it all into chunks that can be digested by hardware: */
   for (py = 0; py < height; py += DY) {
      for (px = 0; px < width; px += DX) {
	 int h = MIN2(DY, height - py);
	 int w = MIN2(DX, width - px);
	 GLuint sz = ALIGN(ALIGN(w,8) * h, 64)/8;
	 GLenum logic_op = ctx->Color.ColorLogicOpEnabled ?
	    ctx->Color.LogicOp : GL_COPY;

	 assert(sz <= sizeof(stipple));
	 memset(stipple, 0, sz);

	 /* May need to adjust this when padding has been introduced in
	  * sz above:
	  *
	  * Have to translate destination coordinates back into source
	  * coordinates.
d264 39
a302 25
	 if (get_bitmap_rect(bitmap_width, bitmap_height, unpack,
			     bitmap,
			     -orig_dstx + (dstx + px),
			     -orig_dsty + y_flip(fb, dsty + py, h),
			     w, h,
			     (GLubyte *)stipple,
			     8,
			     fb->Name == 0 ? GL_TRUE : GL_FALSE) == 0)
	    continue;

	 if (!intelEmitImmediateColorExpandBlit(intel,
						dst->cpp,
						(GLubyte *)stipple,
						sz,
						color,
						dst->pitch,
						dst->buffer,
						0,
						dst->tiling,
						dstx + px,
						dsty + py,
						w, h,
						logic_op)) {
	    return GL_FALSE;
	 }
d304 2
d307 1
a307 1
out:
a308 2
   if (unlikely(INTEL_DEBUG & DEBUG_SYNC))
      intel_batchbuffer_flush(intel->batch);
d310 1
a310 1
   if (_mesa_is_bufferobj(unpack->BufferObj)) {
a315 2
   intel_check_front_buffer_rendering(intel);

d320 3
d344 1
a344 1
intelBitmap(struct gl_context * ctx,
a349 2
   struct intel_context *intel = intel_context(ctx);

d354 2
a355 3
   /* FIXME */
   if (intel->gen == 6)
       return _swrast_Bitmap(ctx, x, y, width, height, unpack, pixels);
d357 1
a357 1
   _mesa_meta_Bitmap(ctx, x, y, width, height, unpack, pixels);
@


