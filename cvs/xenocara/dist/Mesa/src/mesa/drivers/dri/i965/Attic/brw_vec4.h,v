head	1.2;
access;
symbols
	OPENBSD_5_8:1.1.1.4.0.4
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.2
	OPENBSD_5_6_BASE:1.1.1.2
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.1.1.1.0.2
	OPENBSD_5_5_BASE:1.1.1.1
	v9_2_5:1.1.1.1
	v9_2_3:1.1.1.1
	v9_2_2:1.1.1.1
	v9_2_1:1.1.1.1
	v9_2_0:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.1;
commitid	TnlogFl9nOv2eaRf;

1.1
date	2013.09.05.13.15.39;	author jsg;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.09.05.13.15.39;	author jsg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.07.09.20.34.51;	author jsg;	state Exp;
branches;
next	1.1.1.3;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.3
date	2015.01.25.14.11.46;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.48.52;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.2
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2011 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef BRW_VEC4_H
#define BRW_VEC4_H

#include <stdint.h>
#include "brw_shader.h"
#include "main/compiler.h"
#include "program/hash_table.h"

extern "C" {
#include "brw_vs.h"
#include "brw_context.h"
#include "brw_eu.h"
};

#include "glsl/ir.h"

namespace brw {

class dst_reg;

unsigned
swizzle_for_size(int size);

class reg
{
public:
   /** Register file: ARF, GRF, MRF, IMM. */
   enum register_file file;
   /** virtual register number.  0 = fixed hw reg */
   int reg;
   /** Offset within the virtual register. */
   int reg_offset;
   /** Register type.  BRW_REGISTER_TYPE_* */
   int type;
   struct brw_reg fixed_hw_reg;

   /** Value for file == BRW_IMMMEDIATE_FILE */
   union {
      int32_t i;
      uint32_t u;
      float f;
   } imm;
};

class src_reg : public reg
{
public:
   /* Callers of this ralloc-based new need not call delete. It's
    * easier to just ralloc_free 'ctx' (or any of its ancestors). */
   static void* operator new(size_t size, void *ctx)
   {
      void *node;

      node = ralloc_size(ctx, size);
      assert(node != NULL);

      return node;
   }

   void init();

   src_reg(register_file file, int reg, const glsl_type *type);
   src_reg();
   src_reg(float f);
   src_reg(uint32_t u);
   src_reg(int32_t i);

   bool equals(src_reg *r);
   bool is_zero() const;
   bool is_one() const;

   src_reg(class vec4_visitor *v, const struct glsl_type *type);

   explicit src_reg(dst_reg reg);

   GLuint swizzle; /**< SWIZZLE_XYZW swizzles from Mesa. */
   bool negate;
   bool abs;

   src_reg *reladdr;
};

class dst_reg : public reg
{
public:
   /* Callers of this ralloc-based new need not call delete. It's
    * easier to just ralloc_free 'ctx' (or any of its ancestors). */
   static void* operator new(size_t size, void *ctx)
   {
      void *node;

      node = ralloc_size(ctx, size);
      assert(node != NULL);

      return node;
   }

   void init();

   dst_reg();
   dst_reg(register_file file, int reg);
   dst_reg(register_file file, int reg, const glsl_type *type, int writemask);
   dst_reg(struct brw_reg reg);
   dst_reg(class vec4_visitor *v, const struct glsl_type *type);

   explicit dst_reg(src_reg reg);

   int writemask; /**< Bitfield of WRITEMASK_[XYZW] */

   src_reg *reladdr;
};

class vec4_instruction : public backend_instruction {
public:
   /* Callers of this ralloc-based new need not call delete. It's
    * easier to just ralloc_free 'ctx' (or any of its ancestors). */
   static void* operator new(size_t size, void *ctx)
   {
      void *node;

      node = rzalloc_size(ctx, size);
      assert(node != NULL);

      return node;
   }

   vec4_instruction(vec4_visitor *v, enum opcode opcode,
		    dst_reg dst = dst_reg(),
		    src_reg src0 = src_reg(),
		    src_reg src1 = src_reg(),
		    src_reg src2 = src_reg());

   struct brw_reg get_dst(void);
   struct brw_reg get_src(int i);

   dst_reg dst;
   src_reg src[3];

   bool saturate;
   bool force_writemask_all;
   bool no_dd_clear, no_dd_check;

   int conditional_mod; /**< BRW_CONDITIONAL_* */

   int sampler;
   uint32_t texture_offset; /**< Texture Offset bitfield */
   int target; /**< MRT target. */
   bool shadow_compare;

   bool eot;
   bool header_present;
   int mlen; /**< SEND message length */
   int base_mrf; /**< First MRF in the SEND message, if mlen is nonzero. */

   uint32_t offset; /* spill/unspill offset */
   /** @@{
    * Annotation for the generated IR.  One of the two can be set.
    */
   const void *ir;
   const char *annotation;

   bool is_send_from_grf();
   bool can_reswizzle_dst(int dst_writemask, int swizzle, int swizzle_mask);
   void reswizzle_dst(int dst_writemask, int swizzle);
};

/**
 * The vertex shader front-end.
 *
 * Translates either GLSL IR or Mesa IR (for ARB_vertex_program and
 * fixed-function) into VS IR.
 */
class vec4_visitor : public backend_visitor
{
public:
   vec4_visitor(struct brw_context *brw,
                struct brw_vec4_compile *c,
                struct gl_program *prog,
                const struct brw_vec4_prog_key *key,
                struct brw_vec4_prog_data *prog_data,
		struct gl_shader_program *shader_prog,
		struct brw_shader *shader,
		void *mem_ctx,
                bool debug_flag);
   ~vec4_visitor();

   dst_reg dst_null_f()
   {
      return dst_reg(brw_null_reg());
   }

   dst_reg dst_null_d()
   {
      return dst_reg(retype(brw_null_reg(), BRW_REGISTER_TYPE_D));
   }

   struct gl_program *prog;
   struct brw_vec4_compile *c;
   const struct brw_vec4_prog_key *key;
   struct brw_vec4_prog_data *prog_data;
   unsigned int sanity_param_count;

   char *fail_msg;
   bool failed;

   /**
    * GLSL IR currently being processed, which is associated with our
    * driver IR instructions for debugging purposes.
    */
   const void *base_ir;
   const char *current_annotation;

   int *virtual_grf_sizes;
   int virtual_grf_count;
   int virtual_grf_array_size;
   int first_non_payload_grf;
   unsigned int max_grf;
   int *virtual_grf_start;
   int *virtual_grf_end;
   dst_reg userplane[MAX_CLIP_PLANES];

   /**
    * This is the size to be used for an array with an element per
    * reg_offset
    */
   int virtual_grf_reg_count;
   /** Per-virtual-grf indices into an array of size virtual_grf_reg_count */
   int *virtual_grf_reg_map;

   bool live_intervals_valid;

   dst_reg *variable_storage(ir_variable *var);

   void reladdr_to_temp(ir_instruction *ir, src_reg *reg, int *num_reladdr);

   bool need_all_constants_in_pull_buffer;

   /**
    * \name Visit methods
    *
    * As typical for the visitor pattern, there must be one \c visit method for
    * each concrete subclass of \c ir_instruction.  Virtual base classes within
    * the hierarchy should not have \c visit methods.
    */
   /*@@{*/
   virtual void visit(ir_variable *);
   virtual void visit(ir_loop *);
   virtual void visit(ir_loop_jump *);
   virtual void visit(ir_function_signature *);
   virtual void visit(ir_function *);
   virtual void visit(ir_expression *);
   virtual void visit(ir_swizzle *);
   virtual void visit(ir_dereference_variable  *);
   virtual void visit(ir_dereference_array *);
   virtual void visit(ir_dereference_record *);
   virtual void visit(ir_assignment *);
   virtual void visit(ir_constant *);
   virtual void visit(ir_call *);
   virtual void visit(ir_return *);
   virtual void visit(ir_discard *);
   virtual void visit(ir_texture *);
   virtual void visit(ir_if *);
   /*@@}*/

   src_reg result;

   /* Regs for vertex results.  Generated at ir_variable visiting time
    * for the ir->location's used.
    */
   dst_reg output_reg[BRW_VARYING_SLOT_COUNT];
   const char *output_reg_annotation[BRW_VARYING_SLOT_COUNT];
   int uniform_size[MAX_UNIFORMS];
   int uniform_vector_size[MAX_UNIFORMS];
   int uniforms;

   src_reg shader_start_time;

   struct hash_table *variable_ht;

   bool run(void);
   void fail(const char *msg, ...);

   int virtual_grf_alloc(int size);
   void setup_uniform_clipplane_values();
   void setup_uniform_values(ir_variable *ir);
   void setup_builtin_uniform_values(ir_variable *ir);
   int setup_uniforms(int payload_reg);
   void setup_payload();
   bool reg_allocate_trivial();
   bool reg_allocate();
   void evaluate_spill_costs(float *spill_costs, bool *no_spill);
   int choose_spill_reg(struct ra_graph *g);
   void spill_reg(int spill_reg);
   void move_grf_array_access_to_scratch();
   void move_uniform_array_access_to_pull_constants();
   void move_push_constants_to_pull_constants();
   void split_uniform_registers();
   void pack_uniform_registers();
   void calculate_live_intervals();
   void split_virtual_grfs();
   bool dead_code_eliminate();
   bool virtual_grf_interferes(int a, int b);
   bool opt_copy_propagation();
   bool opt_algebraic();
   bool opt_register_coalesce();
   void opt_set_dependency_control();
   void opt_schedule_instructions();

   bool can_do_source_mods(vec4_instruction *inst);

   vec4_instruction *emit(vec4_instruction *inst);

   vec4_instruction *emit(enum opcode opcode);

   vec4_instruction *emit(enum opcode opcode, dst_reg dst, src_reg src0);

   vec4_instruction *emit(enum opcode opcode, dst_reg dst,
			  src_reg src0, src_reg src1);

   vec4_instruction *emit(enum opcode opcode, dst_reg dst,
			  src_reg src0, src_reg src1, src_reg src2);

   vec4_instruction *emit_before(vec4_instruction *inst,
				 vec4_instruction *new_inst);

   vec4_instruction *MOV(dst_reg dst, src_reg src0);
   vec4_instruction *NOT(dst_reg dst, src_reg src0);
   vec4_instruction *RNDD(dst_reg dst, src_reg src0);
   vec4_instruction *RNDE(dst_reg dst, src_reg src0);
   vec4_instruction *RNDZ(dst_reg dst, src_reg src0);
   vec4_instruction *FRC(dst_reg dst, src_reg src0);
   vec4_instruction *F32TO16(dst_reg dst, src_reg src0);
   vec4_instruction *F16TO32(dst_reg dst, src_reg src0);
   vec4_instruction *ADD(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *MUL(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *MACH(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *MAC(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *AND(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *OR(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *XOR(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *DP3(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *DP4(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *DPH(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *SHL(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *SHR(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *ASR(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *CMP(dst_reg dst, src_reg src0, src_reg src1,
			 uint32_t condition);
   vec4_instruction *IF(src_reg src0, src_reg src1, uint32_t condition);
   vec4_instruction *IF(uint32_t predicate);
   vec4_instruction *PULL_CONSTANT_LOAD(dst_reg dst, src_reg index);
   vec4_instruction *SCRATCH_READ(dst_reg dst, src_reg index);
   vec4_instruction *SCRATCH_WRITE(dst_reg dst, src_reg src, src_reg index);
   vec4_instruction *LRP(dst_reg dst, src_reg a, src_reg y, src_reg x);
   vec4_instruction *BFREV(dst_reg dst, src_reg value);
   vec4_instruction *BFE(dst_reg dst, src_reg bits, src_reg offset, src_reg value);
   vec4_instruction *BFI1(dst_reg dst, src_reg bits, src_reg offset);
   vec4_instruction *BFI2(dst_reg dst, src_reg bfi1_dst, src_reg insert, src_reg base);
   vec4_instruction *FBH(dst_reg dst, src_reg value);
   vec4_instruction *FBL(dst_reg dst, src_reg value);
   vec4_instruction *CBIT(dst_reg dst, src_reg value);

   int implied_mrf_writes(vec4_instruction *inst);

   bool try_rewrite_rhs_to_dst(ir_assignment *ir,
			       dst_reg dst,
			       src_reg src,
			       vec4_instruction *pre_rhs_inst,
			       vec4_instruction *last_rhs_inst);

   bool try_copy_propagation(vec4_instruction *inst, int arg,
                             src_reg *values[4]);

   /** Walks an exec_list of ir_instruction and sends it through this visitor. */
   void visit_instructions(const exec_list *list);

   void emit_vp_sop(uint32_t condmod, dst_reg dst,
                    src_reg src0, src_reg src1, src_reg one);

   void emit_bool_to_cond_code(ir_rvalue *ir, uint32_t *predicate);
   void emit_bool_comparison(unsigned int op, dst_reg dst, src_reg src0, src_reg src1);
   void emit_if_gen6(ir_if *ir);

   void emit_minmax(uint32_t condmod, dst_reg dst, src_reg src0, src_reg src1);

   void emit_block_move(dst_reg *dst, src_reg *src,
			const struct glsl_type *type, uint32_t predicate);

   void emit_constant_values(dst_reg *dst, ir_constant *value);

   /**
    * Emit the correct dot-product instruction for the type of arguments
    */
   void emit_dp(dst_reg dst, src_reg src0, src_reg src1, unsigned elements);

   void emit_scalar(ir_instruction *ir, enum prog_opcode op,
		    dst_reg dst, src_reg src0);

   void emit_scalar(ir_instruction *ir, enum prog_opcode op,
		    dst_reg dst, src_reg src0, src_reg src1);

   void emit_scs(ir_instruction *ir, enum prog_opcode op,
		 dst_reg dst, const src_reg &src);

   src_reg fix_3src_operand(src_reg src);

   void emit_math1_gen6(enum opcode opcode, dst_reg dst, src_reg src);
   void emit_math1_gen4(enum opcode opcode, dst_reg dst, src_reg src);
   void emit_math(enum opcode opcode, dst_reg dst, src_reg src);
   void emit_math2_gen6(enum opcode opcode, dst_reg dst, src_reg src0, src_reg src1);
   void emit_math2_gen4(enum opcode opcode, dst_reg dst, src_reg src0, src_reg src1);
   void emit_math(enum opcode opcode, dst_reg dst, src_reg src0, src_reg src1);
   src_reg fix_math_operand(src_reg src);

   void emit_pack_half_2x16(dst_reg dst, src_reg src0);
   void emit_unpack_half_2x16(dst_reg dst, src_reg src0);

   void swizzle_result(ir_texture *ir, src_reg orig_val, int sampler);

   void emit_ndc_computation();
   void emit_psiz_and_flags(struct brw_reg reg);
   void emit_clip_distances(struct brw_reg reg, int offset);
   void emit_generic_urb_slot(dst_reg reg, int varying);
   void emit_urb_slot(int mrf, int varying);

   void emit_shader_time_begin();
   void emit_shader_time_end();
   void emit_shader_time_write(enum shader_time_shader_type type,
                               src_reg value);

   src_reg get_scratch_offset(vec4_instruction *inst,
			      src_reg *reladdr, int reg_offset);
   src_reg get_pull_constant_offset(vec4_instruction *inst,
				    src_reg *reladdr, int reg_offset);
   void emit_scratch_read(vec4_instruction *inst,
			  dst_reg dst,
			  src_reg orig_src,
			  int base_offset);
   void emit_scratch_write(vec4_instruction *inst,
			   int base_offset);
   void emit_pull_constant_load(vec4_instruction *inst,
				dst_reg dst,
				src_reg orig_src,
				int base_offset);

   bool try_emit_sat(ir_expression *ir);
   bool try_emit_mad(ir_expression *ir, int mul_arg);
   void resolve_ud_negate(src_reg *reg);

   src_reg get_timestamp();

   bool process_move_condition(ir_rvalue *ir);

   void dump_instruction(backend_instruction *inst);

protected:
   void emit_vertex();
   void lower_attributes_to_hw_regs(const int *attribute_map);
   virtual dst_reg *make_reg_for_system_value(ir_variable *ir) = 0;
   virtual int setup_attributes(int payload_reg) = 0;
   virtual void emit_prolog() = 0;
   virtual void emit_program_code() = 0;
   virtual void emit_thread_end() = 0;
   virtual void emit_urb_write_header(int mrf) = 0;
   virtual vec4_instruction *emit_urb_write_opcode(bool complete) = 0;
   virtual int compute_array_stride(ir_dereference_array *ir);

   const bool debug_flag;
};

class vec4_vs_visitor : public vec4_visitor
{
public:
   vec4_vs_visitor(struct brw_context *brw,
                   struct brw_vs_compile *vs_compile,
                   struct brw_vs_prog_data *vs_prog_data,
                   struct gl_shader_program *prog,
                   struct brw_shader *shader,
                   void *mem_ctx);

protected:
   virtual dst_reg *make_reg_for_system_value(ir_variable *ir);
   virtual int setup_attributes(int payload_reg);
   virtual void emit_prolog();
   virtual void emit_program_code();
   virtual void emit_thread_end();
   virtual void emit_urb_write_header(int mrf);
   virtual vec4_instruction *emit_urb_write_opcode(bool complete);

private:
   void setup_vp_regs();
   dst_reg get_vp_dst_reg(const prog_dst_register &dst);
   src_reg get_vp_src_reg(const prog_src_register &src);

   struct brw_vs_compile * const vs_compile;
   struct brw_vs_prog_data * const vs_prog_data;
   src_reg *vp_temp_regs;
   src_reg vp_addr_reg;
};

/**
 * The vertex shader code generator.
 *
 * Translates VS IR to actual i965 assembly code.
 */
class vec4_generator
{
public:
   vec4_generator(struct brw_context *brw,
                  struct gl_shader_program *shader_prog,
                  struct gl_program *prog,
                  void *mem_ctx,
                  bool debug_flag);
   ~vec4_generator();

   const unsigned *generate_assembly(exec_list *insts, unsigned *asm_size);

private:
   void generate_code(exec_list *instructions);
   void generate_vec4_instruction(vec4_instruction *inst,
                                  struct brw_reg dst,
                                  struct brw_reg *src);

   void generate_math1_gen4(vec4_instruction *inst,
			    struct brw_reg dst,
			    struct brw_reg src);
   void generate_math1_gen6(vec4_instruction *inst,
			    struct brw_reg dst,
			    struct brw_reg src);
   void generate_math2_gen4(vec4_instruction *inst,
			    struct brw_reg dst,
			    struct brw_reg src0,
			    struct brw_reg src1);
   void generate_math2_gen6(vec4_instruction *inst,
			    struct brw_reg dst,
			    struct brw_reg src0,
			    struct brw_reg src1);
   void generate_math2_gen7(vec4_instruction *inst,
			    struct brw_reg dst,
			    struct brw_reg src0,
			    struct brw_reg src1);

   void generate_tex(vec4_instruction *inst,
		     struct brw_reg dst,
		     struct brw_reg src);

   void generate_urb_write(vec4_instruction *inst);
   void generate_oword_dual_block_offsets(struct brw_reg m1,
					  struct brw_reg index);
   void generate_scratch_write(vec4_instruction *inst,
			       struct brw_reg dst,
			       struct brw_reg src,
			       struct brw_reg index);
   void generate_scratch_read(vec4_instruction *inst,
			      struct brw_reg dst,
			      struct brw_reg index);
   void generate_pull_constant_load(vec4_instruction *inst,
				    struct brw_reg dst,
				    struct brw_reg index,
				    struct brw_reg offset);
   void generate_pull_constant_load_gen7(vec4_instruction *inst,
                                         struct brw_reg dst,
                                         struct brw_reg surf_index,
                                         struct brw_reg offset);

   struct brw_context *brw;
   struct gl_context *ctx;

   struct brw_compile *p;

   struct gl_shader_program *shader_prog;
   struct gl_shader *shader;
   const struct gl_program *prog;

   void *mem_ctx;
   const bool debug_flag;
};

} /* namespace brw */

#endif /* BRW_VEC4_H */
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import Mesa 9.2.0
@
text
@@


1.1.1.2
log
@Import Mesa 10.2.3
@
text
@a30 1
#include "brw_program.h"
a31 1
#ifdef __cplusplus
d33 1
a33 2
#endif

d36 1
a36 5

#ifdef __cplusplus
}; /* extern "C" */
#include "gen8_generator.h"
#endif
a39 39

struct brw_vec4_compile {
   GLuint last_scratch; /**< measured in 32-byte (register size) units */
};


struct brw_vec4_prog_key {
   GLuint program_string_id;

   /**
    * True if at least one clip flag is enabled, regardless of whether the
    * shader uses clip planes or gl_ClipDistance.
    */
   GLuint userclip_active:1;

   /**
    * How many user clipping planes are being uploaded to the vertex shader as
    * push constants.
    */
   GLuint nr_userclip_plane_consts:4;

   GLuint clamp_vertex_color:1;

   struct brw_sampler_prog_key_data tex;
};


#ifdef __cplusplus
extern "C" {
#endif

void
brw_vec4_setup_prog_key_for_precompile(struct gl_context *ctx,
                                       struct brw_vec4_prog_key *key,
                                       GLuint id, struct gl_program *prog);

#ifdef __cplusplus
} /* extern "C" */

d50 1
a50 1
   /** Register file: GRF, MRF, IMM. */
d71 11
a81 1
   DECLARE_RALLOC_CXX_OPERATORS(src_reg)
a89 1
   src_reg(struct brw_reg reg);
a93 1
   bool is_accumulator() const;
d99 1
a99 1
   GLuint swizzle; /**< BRW_SWIZZLE_XYZW macros from brw_reg.h. */
d106 1
a106 2
static inline src_reg
retype(src_reg reg, unsigned type)
d108 6
a113 3
   reg.fixed_hw_reg.type = reg.type = type;
   return reg;
}
d115 2
a116 7
static inline src_reg
offset(src_reg reg, unsigned delta)
{
   assert(delta == 0 || (reg.file != HW_REG && reg.file != IMM));
   reg.reg_offset += delta;
   return reg;
}
d118 2
a119 28
/**
 * Reswizzle a given source register.
 * \sa brw_swizzle().
 */
static inline src_reg
swizzle(src_reg reg, unsigned swizzle)
{
   assert(reg.file != HW_REG);
   reg.swizzle = BRW_SWIZZLE4(
      BRW_GET_SWZ(reg.swizzle, BRW_GET_SWZ(swizzle, 0)),
      BRW_GET_SWZ(reg.swizzle, BRW_GET_SWZ(swizzle, 1)),
      BRW_GET_SWZ(reg.swizzle, BRW_GET_SWZ(swizzle, 2)),
      BRW_GET_SWZ(reg.swizzle, BRW_GET_SWZ(swizzle, 3)));
   return reg;
}

static inline src_reg
negate(src_reg reg)
{
   assert(reg.file != HW_REG && reg.file != IMM);
   reg.negate = !reg.negate;
   return reg;
}

class dst_reg : public reg
{
public:
   DECLARE_RALLOC_CXX_OPERATORS(dst_reg)
a130 3
   bool is_null() const;
   bool is_accumulator() const;

d136 7
a142 6
static inline dst_reg
retype(dst_reg reg, unsigned type)
{
   reg.fixed_hw_reg.type = reg.type = type;
   return reg;
}
d144 2
a145 7
static inline dst_reg
offset(dst_reg reg, unsigned delta)
{
   assert(delta == 0 || (reg.file != HW_REG && reg.file != IMM));
   reg.reg_offset += delta;
   return reg;
}
d147 2
a148 12
static inline dst_reg
writemask(dst_reg reg, unsigned mask)
{
   assert(reg.file != HW_REG && reg.file != IMM);
   assert((reg.writemask & mask) != 0);
   reg.writemask &= mask;
   return reg;
}

class vec4_instruction : public backend_instruction {
public:
   DECLARE_RALLOC_CXX_OPERATORS(vec4_instruction)
d157 1
a157 1
   struct brw_reg get_src(const struct brw_vec4_prog_data *prog_data, int i);
d173 1
a173 1
   enum brw_urb_write_flags urb_write_flags;
a183 1
   /** @@} */
a187 10

   bool reads_flag()
   {
      return predicate || opcode == VS_OPCODE_UNPACK_FLAGS_SIMD4X2;
   }

   bool writes_flag()
   {
      return conditional_mod && opcode != BRW_OPCODE_SEL;
   }
d205 1
a205 1
                gl_shader_stage stage,
d207 1
a207 5
                bool debug_flag,
                bool no_spills,
                shader_time_shader_type st_base,
                shader_time_shader_type st_written,
                shader_time_shader_type st_reset);
d220 4
a223 8
   dst_reg dst_null_ud()
   {
      return dst_reg(retype(brw_null_reg(), BRW_REGISTER_TYPE_UD));
   }

   struct brw_vec4_compile * const c;
   const struct brw_vec4_prog_key * const key;
   struct brw_vec4_prog_data * const prog_data;
a285 2
   virtual void visit(ir_emit_vertex *);
   virtual void visit(ir_end_primitive *);
d295 2
a296 3
   int *uniform_size;
   int *uniform_vector_size;
   int uniform_array_size; /*< Size of uniform_[vector_]size arrays */
d311 1
a322 1
   void invalidate_live_intervals();
a337 2
   vec4_instruction *emit(enum opcode opcode, dst_reg dst);

a384 3
   vec4_instruction *MAD(dst_reg dst, src_reg c, src_reg b, src_reg a);
   vec4_instruction *ADDC(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *SUBB(dst_reg dst, src_reg src0, src_reg src1);
a408 3
   void emit_lrp(const dst_reg &dst,
                 const src_reg &x, const src_reg &y, const src_reg &a);

a440 3
   uint32_t gather_channel(ir_texture *ir, int sampler);
   src_reg emit_mcs_fetch(ir_texture *ir, src_reg coordinate, int sampler);
   void emit_gen6_gather_wa(uint8_t wa, dst_reg dst);
d445 1
a445 1
   void emit_clip_distances(dst_reg reg, int offset);
a453 7
   void emit_untyped_atomic(unsigned atomic_op, unsigned surf_index,
                            dst_reg dst, src_reg offset, src_reg src0,
                            src_reg src1);

   void emit_untyped_surface_read(unsigned surf_index, dst_reg dst,
                                  src_reg offset);

d470 1
a470 1
   bool try_emit_mad(ir_expression *ir);
a478 2
   void visit_atomic_counter_intrinsic(ir_call *ir);

d481 1
a481 4
   void lower_attributes_to_hw_regs(const int *attribute_map,
                                    bool interleaved);
   void setup_payload_interference(struct ra_graph *g, int first_payload_node,
                                   int reg_node_count);
d483 1
a483 1
   virtual void setup_payload() = 0;
d492 20
d514 8
a521 8
   /**
    * If true, then register allocation should fail instead of spilling.
    */
   const bool no_spills;

   const shader_time_shader_type st_base;
   const shader_time_shader_type st_written;
   const shader_time_shader_type st_reset;
a523 1

a534 1
                  struct brw_vec4_prog_data *prog_data,
d570 1
a570 12
   void generate_vs_urb_write(vec4_instruction *inst);
   void generate_gs_urb_write(vec4_instruction *inst);
   void generate_gs_thread_end(vec4_instruction *inst);
   void generate_gs_set_write_offset(struct brw_reg dst,
                                     struct brw_reg src0,
                                     struct brw_reg src1);
   void generate_gs_set_vertex_count(struct brw_reg dst,
                                     struct brw_reg src);
   void generate_gs_set_dword_2_immed(struct brw_reg dst, struct brw_reg src);
   void generate_gs_prepare_channel_masks(struct brw_reg dst);
   void generate_gs_set_channel_masks(struct brw_reg dst, struct brw_reg src);
   void generate_gs_get_instance_id(struct brw_reg dst);
a587 11
   void generate_unpack_flags(vec4_instruction *inst,
                              struct brw_reg dst);

   void generate_untyped_atomic(vec4_instruction *inst,
                                struct brw_reg dst,
                                struct brw_reg atomic_op,
                                struct brw_reg surf_index);

   void generate_untyped_surface_read(vec4_instruction *inst,
                                      struct brw_reg dst,
                                      struct brw_reg surf_index);
d590 1
d595 1
a597 2
   struct brw_vec4_prog_data *prog_data;

a601 65
/**
 * The vertex shader code generator.
 *
 * Translates VS IR to actual i965 assembly code.
 */
class gen8_vec4_generator : public gen8_generator
{
public:
   gen8_vec4_generator(struct brw_context *brw,
                       struct gl_shader_program *shader_prog,
                       struct gl_program *prog,
                       struct brw_vec4_prog_data *prog_data,
                       void *mem_ctx,
                       bool debug_flag);
   ~gen8_vec4_generator();

   const unsigned *generate_assembly(exec_list *insts, unsigned *asm_size);

private:
   void generate_code(exec_list *instructions);
   void generate_vec4_instruction(vec4_instruction *inst,
                                  struct brw_reg dst,
                                  struct brw_reg *src);

   void generate_tex(vec4_instruction *inst,
                     struct brw_reg dst);

   void generate_urb_write(vec4_instruction *ir, bool copy_g0);
   void generate_gs_thread_end(vec4_instruction *ir);
   void generate_gs_set_write_offset(struct brw_reg dst,
                                     struct brw_reg src0,
                                     struct brw_reg src1);
   void generate_gs_set_vertex_count(struct brw_reg dst,
                                     struct brw_reg src);
   void generate_gs_set_dword_2_immed(struct brw_reg dst, struct brw_reg src);
   void generate_gs_prepare_channel_masks(struct brw_reg dst);
   void generate_gs_set_channel_masks(struct brw_reg dst, struct brw_reg src);

   void generate_oword_dual_block_offsets(struct brw_reg m1,
                                          struct brw_reg index);
   void generate_scratch_write(vec4_instruction *inst,
                               struct brw_reg dst,
                               struct brw_reg src,
                               struct brw_reg index);
   void generate_scratch_read(vec4_instruction *inst,
                              struct brw_reg dst,
                              struct brw_reg index);
   void generate_pull_constant_load(vec4_instruction *inst,
                                    struct brw_reg dst,
                                    struct brw_reg index,
                                    struct brw_reg offset);
   void generate_untyped_atomic(vec4_instruction *ir,
                                struct brw_reg dst,
                                struct brw_reg atomic_op,
                                struct brw_reg surf_index);
   void generate_untyped_surface_read(vec4_instruction *ir,
                                      struct brw_reg dst,
                                      struct brw_reg surf_index);

   struct brw_vec4_prog_data *prog_data;

   const bool debug_flag;
};


a602 1
#endif /* __cplusplus */
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@a38 1
#include "intel_asm_annotation.h"
d42 1
d93 22
a114 1
class src_reg : public backend_reg
d128 4
a131 1
   bool equals(const src_reg &r) const;
a133 1
   src_reg(class vec4_visitor *v, const struct glsl_type *type, int size);
d138 2
d145 1
a145 1
retype(src_reg reg, enum brw_reg_type type)
d183 1
a183 1
class dst_reg : public backend_reg
d198 3
d207 1
a207 1
retype(dst_reg reg, enum brw_reg_type type)
d235 4
a238 4
                    const dst_reg &dst = dst_reg(),
                    const src_reg &src0 = src_reg(),
                    const src_reg &src1 = src_reg(),
                    const src_reg &src2 = src_reg());
d246 9
d259 2
d262 7
a268 3
   unsigned sol_binding; /**< gen6: SOL binding table index */
   bool sol_final_write; /**< gen6: send commit message */
   unsigned sol_vertex; /**< gen6: used for setting dst index in SVB header */
d271 2
a272 3
   bool can_reswizzle(int dst_writemask, int swizzle, int swizzle_mask);
   void reswizzle(int dst_writemask, int swizzle);
   bool can_do_source_mods(struct brw_context *brw);
a429 1
   bool opt_reduce_swizzle();
a432 2
   bool opt_cse_local(bblock_t *block);
   bool opt_cse();
d438 2
a442 8
   vec4_instruction *emit(enum opcode opcode, const dst_reg &dst);
   vec4_instruction *emit(enum opcode opcode, const dst_reg &dst,
                          const src_reg &src0);
   vec4_instruction *emit(enum opcode opcode, const dst_reg &dst,
                          const src_reg &src0, const src_reg &src1);
   vec4_instruction *emit(enum opcode opcode, const dst_reg &dst,
                          const src_reg &src0, const src_reg &src1,
                          const src_reg &src2);
d444 11
a454 2
   vec4_instruction *emit_before(bblock_t *block,
                                 vec4_instruction *inst,
d457 21
a477 24
#define EMIT1(op) vec4_instruction *op(const dst_reg &, const src_reg &);
#define EMIT2(op) vec4_instruction *op(const dst_reg &, const src_reg &, const src_reg &);
#define EMIT3(op) vec4_instruction *op(const dst_reg &, const src_reg &, const src_reg &, const src_reg &);
   EMIT1(MOV)
   EMIT1(NOT)
   EMIT1(RNDD)
   EMIT1(RNDE)
   EMIT1(RNDZ)
   EMIT1(FRC)
   EMIT1(F32TO16)
   EMIT1(F16TO32)
   EMIT2(ADD)
   EMIT2(MUL)
   EMIT2(MACH)
   EMIT2(MAC)
   EMIT2(AND)
   EMIT2(OR)
   EMIT2(XOR)
   EMIT2(DP3)
   EMIT2(DP4)
   EMIT2(DPH)
   EMIT2(SHL)
   EMIT2(SHR)
   EMIT2(ASR)
d479 17
a495 21
			 enum brw_conditional_mod condition);
   vec4_instruction *IF(src_reg src0, src_reg src1,
                        enum brw_conditional_mod condition);
   vec4_instruction *IF(enum brw_predicate predicate);
   EMIT1(PULL_CONSTANT_LOAD)
   EMIT1(SCRATCH_READ)
   EMIT2(SCRATCH_WRITE)
   EMIT3(LRP)
   EMIT1(BFREV)
   EMIT3(BFE)
   EMIT2(BFI1)
   EMIT3(BFI2)
   EMIT1(FBH)
   EMIT1(FBL)
   EMIT1(CBIT)
   EMIT3(MAD)
   EMIT2(ADDC)
   EMIT2(SUBB)
#undef EMIT1
#undef EMIT2
#undef EMIT3
d505 3
d511 1
a511 1
   void emit_vp_sop(enum brw_conditional_mod condmod, dst_reg dst,
d514 2
a515 1
   void emit_bool_to_cond_code(ir_rvalue *ir, enum brw_predicate *predicate);
d518 1
a518 2
   void emit_minmax(enum brw_conditional_mod conditionalmod, dst_reg dst,
                    src_reg src0, src_reg src1);
d524 1
a524 1
                        const struct glsl_type *type, brw_predicate predicate);
d544 6
a549 2
   void emit_math(enum opcode opcode, const dst_reg &dst, const src_reg &src0,
                  const src_reg &src1 = src_reg());
d555 2
a556 2
   uint32_t gather_channel(ir_texture *ir, uint32_t sampler);
   src_reg emit_mcs_fetch(ir_texture *ir, src_reg coordinate, src_reg sampler);
d558 1
a558 1
   void swizzle_result(ir_texture *ir, src_reg orig_val, uint32_t sampler);
d561 1
a561 1
   void emit_psiz_and_flags(dst_reg reg);
d564 1
a564 1
   void emit_urb_slot(dst_reg reg, int varying);
d578 1
a578 1
   src_reg get_scratch_offset(bblock_t *block, vec4_instruction *inst,
d580 1
a580 1
   src_reg get_pull_constant_offset(bblock_t *block, vec4_instruction *inst,
d582 1
a582 1
   void emit_scratch_read(bblock_t *block, vec4_instruction *inst,
d586 1
a586 1
   void emit_scratch_write(bblock_t *block, vec4_instruction *inst,
d588 1
a588 1
   void emit_pull_constant_load(bblock_t *block, vec4_instruction *inst,
d593 1
a594 1
   bool try_emit_b2f_of_compare(ir_expression *ir);
a601 1
   void dump_instruction(backend_instruction *inst, FILE *file);
a611 1
   virtual void assign_binding_table_offsets();
d650 1
a650 1
   const unsigned *generate_assembly(const cfg_t *cfg, unsigned *asm_size);
d653 4
a656 1
   void generate_code(const cfg_t *cfg);
d661 3
d668 8
a675 4
   void generate_math_gen6(vec4_instruction *inst,
                           struct brw_reg dst,
                           struct brw_reg src0,
                           struct brw_reg src1);
d678 2
a679 3
                     struct brw_reg dst,
                     struct brw_reg src,
                     struct brw_reg sampler_index);
a682 1
   void generate_gs_urb_write_allocate(vec4_instruction *inst);
d689 1
a689 8
   void generate_gs_svb_write(vec4_instruction *inst,
                              struct brw_reg dst,
                              struct brw_reg src0,
                              struct brw_reg src1);
   void generate_gs_svb_set_destination_index(vec4_instruction *inst,
                                              struct brw_reg dst,
                                              struct brw_reg src);
   void generate_gs_set_dword_2(struct brw_reg dst, struct brw_reg src);
a692 9
   void generate_gs_ff_sync_set_primitives(struct brw_reg dst,
                                           struct brw_reg src0,
                                           struct brw_reg src1,
                                           struct brw_reg src2);
   void generate_gs_ff_sync(vec4_instruction *inst,
                            struct brw_reg dst,
                            struct brw_reg src0,
                            struct brw_reg src1);
   void generate_gs_set_primitive_id(struct brw_reg dst);
d734 65
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d39 1
a42 1
#include "gen8_generator.h"
d93 1
a93 22
class reg
{
public:
   /** Register file: GRF, MRF, IMM. */
   enum register_file file;
   /** virtual register number.  0 = fixed hw reg */
   int reg;
   /** Offset within the virtual register. */
   int reg_offset;
   /** Register type.  BRW_REGISTER_TYPE_* */
   int type;
   struct brw_reg fixed_hw_reg;

   /** Value for file == BRW_IMMMEDIATE_FILE */
   union {
      int32_t i;
      uint32_t u;
      float f;
   } imm;
};

class src_reg : public reg
d107 1
a107 4
   bool equals(src_reg *r);
   bool is_zero() const;
   bool is_one() const;
   bool is_accumulator() const;
d110 1
a114 2
   bool negate;
   bool abs;
d120 1
a120 1
retype(src_reg reg, unsigned type)
d158 1
a158 1
class dst_reg : public reg
a172 3
   bool is_null() const;
   bool is_accumulator() const;

d179 1
a179 1
retype(dst_reg reg, unsigned type)
d207 4
a210 4
		    dst_reg dst = dst_reg(),
		    src_reg src0 = src_reg(),
		    src_reg src1 = src_reg(),
		    src_reg src2 = src_reg());
a217 9
   bool saturate;
   bool force_writemask_all;
   bool no_dd_clear, no_dd_check;

   int conditional_mod; /**< BRW_CONDITIONAL_* */

   int sampler;
   uint32_t texture_offset; /**< Texture Offset bitfield */
   int target; /**< MRT target. */
a221 2
   int mlen; /**< SEND message length */
   int base_mrf; /**< First MRF in the SEND message, if mlen is nonzero. */
d223 3
a225 7
   uint32_t offset; /* spill/unspill offset */
   /** @@{
    * Annotation for the generated IR.  One of the two can be set.
    */
   const void *ir;
   const char *annotation;
   /** @@} */
d228 3
a230 2
   bool can_reswizzle_dst(int dst_writemask, int swizzle, int swizzle_mask);
   void reswizzle_dst(int dst_writemask, int swizzle);
d388 1
d392 2
a398 2
   bool can_do_source_mods(vec4_instruction *inst);

d402 8
d411 2
a412 11
   vec4_instruction *emit(enum opcode opcode, dst_reg dst);

   vec4_instruction *emit(enum opcode opcode, dst_reg dst, src_reg src0);

   vec4_instruction *emit(enum opcode opcode, dst_reg dst,
			  src_reg src0, src_reg src1);

   vec4_instruction *emit(enum opcode opcode, dst_reg dst,
			  src_reg src0, src_reg src1, src_reg src2);

   vec4_instruction *emit_before(vec4_instruction *inst,
d415 24
a438 21
   vec4_instruction *MOV(dst_reg dst, src_reg src0);
   vec4_instruction *NOT(dst_reg dst, src_reg src0);
   vec4_instruction *RNDD(dst_reg dst, src_reg src0);
   vec4_instruction *RNDE(dst_reg dst, src_reg src0);
   vec4_instruction *RNDZ(dst_reg dst, src_reg src0);
   vec4_instruction *FRC(dst_reg dst, src_reg src0);
   vec4_instruction *F32TO16(dst_reg dst, src_reg src0);
   vec4_instruction *F16TO32(dst_reg dst, src_reg src0);
   vec4_instruction *ADD(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *MUL(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *MACH(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *MAC(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *AND(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *OR(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *XOR(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *DP3(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *DP4(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *DPH(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *SHL(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *SHR(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *ASR(dst_reg dst, src_reg src0, src_reg src1);
d440 21
a460 17
			 uint32_t condition);
   vec4_instruction *IF(src_reg src0, src_reg src1, uint32_t condition);
   vec4_instruction *IF(uint32_t predicate);
   vec4_instruction *PULL_CONSTANT_LOAD(dst_reg dst, src_reg index);
   vec4_instruction *SCRATCH_READ(dst_reg dst, src_reg index);
   vec4_instruction *SCRATCH_WRITE(dst_reg dst, src_reg src, src_reg index);
   vec4_instruction *LRP(dst_reg dst, src_reg a, src_reg y, src_reg x);
   vec4_instruction *BFREV(dst_reg dst, src_reg value);
   vec4_instruction *BFE(dst_reg dst, src_reg bits, src_reg offset, src_reg value);
   vec4_instruction *BFI1(dst_reg dst, src_reg bits, src_reg offset);
   vec4_instruction *BFI2(dst_reg dst, src_reg bfi1_dst, src_reg insert, src_reg base);
   vec4_instruction *FBH(dst_reg dst, src_reg value);
   vec4_instruction *FBL(dst_reg dst, src_reg value);
   vec4_instruction *CBIT(dst_reg dst, src_reg value);
   vec4_instruction *MAD(dst_reg dst, src_reg c, src_reg b, src_reg a);
   vec4_instruction *ADDC(dst_reg dst, src_reg src0, src_reg src1);
   vec4_instruction *SUBB(dst_reg dst, src_reg src0, src_reg src1);
a469 3
   bool try_copy_propagation(vec4_instruction *inst, int arg,
                             src_reg *values[4]);

d473 1
a473 1
   void emit_vp_sop(uint32_t condmod, dst_reg dst,
d476 1
a476 2
   void emit_bool_to_cond_code(ir_rvalue *ir, uint32_t *predicate);
   void emit_bool_comparison(unsigned int op, dst_reg dst, src_reg src0, src_reg src1);
d479 2
a480 1
   void emit_minmax(uint32_t condmod, dst_reg dst, src_reg src0, src_reg src1);
d486 1
a486 1
			const struct glsl_type *type, uint32_t predicate);
d506 2
a507 6
   void emit_math1_gen6(enum opcode opcode, dst_reg dst, src_reg src);
   void emit_math1_gen4(enum opcode opcode, dst_reg dst, src_reg src);
   void emit_math(enum opcode opcode, dst_reg dst, src_reg src);
   void emit_math2_gen6(enum opcode opcode, dst_reg dst, src_reg src0, src_reg src1);
   void emit_math2_gen4(enum opcode opcode, dst_reg dst, src_reg src0, src_reg src1);
   void emit_math(enum opcode opcode, dst_reg dst, src_reg src0, src_reg src1);
d513 2
a514 2
   uint32_t gather_channel(ir_texture *ir, int sampler);
   src_reg emit_mcs_fetch(ir_texture *ir, src_reg coordinate, int sampler);
d516 1
a516 1
   void swizzle_result(ir_texture *ir, src_reg orig_val, int sampler);
d519 1
a519 1
   void emit_psiz_and_flags(struct brw_reg reg);
d522 1
a522 1
   void emit_urb_slot(int mrf, int varying);
d536 1
a536 1
   src_reg get_scratch_offset(vec4_instruction *inst,
d538 1
a538 1
   src_reg get_pull_constant_offset(vec4_instruction *inst,
d540 1
a540 1
   void emit_scratch_read(vec4_instruction *inst,
d544 1
a544 1
   void emit_scratch_write(vec4_instruction *inst,
d546 1
a546 1
   void emit_pull_constant_load(vec4_instruction *inst,
a550 1
   bool try_emit_sat(ir_expression *ir);
d552 1
d560 1
d571 1
d610 1
a610 1
   const unsigned *generate_assembly(exec_list *insts, unsigned *asm_size);
d613 1
a613 4
   void generate_code(exec_list *instructions);
   void generate_vec4_instruction(vec4_instruction *inst,
                                  struct brw_reg dst,
                                  struct brw_reg *src);
a617 3
   void generate_math1_gen6(vec4_instruction *inst,
			    struct brw_reg dst,
			    struct brw_reg src);
d622 4
a625 8
   void generate_math2_gen6(vec4_instruction *inst,
			    struct brw_reg dst,
			    struct brw_reg src0,
			    struct brw_reg src1);
   void generate_math2_gen7(vec4_instruction *inst,
			    struct brw_reg dst,
			    struct brw_reg src0,
			    struct brw_reg src1);
d628 3
a630 2
		     struct brw_reg dst,
		     struct brw_reg src);
d634 1
d641 8
a648 1
   void generate_gs_set_dword_2_immed(struct brw_reg dst, struct brw_reg src);
d652 9
a701 65

/**
 * The vertex shader code generator.
 *
 * Translates VS IR to actual i965 assembly code.
 */
class gen8_vec4_generator : public gen8_generator
{
public:
   gen8_vec4_generator(struct brw_context *brw,
                       struct gl_shader_program *shader_prog,
                       struct gl_program *prog,
                       struct brw_vec4_prog_data *prog_data,
                       void *mem_ctx,
                       bool debug_flag);
   ~gen8_vec4_generator();

   const unsigned *generate_assembly(exec_list *insts, unsigned *asm_size);

private:
   void generate_code(exec_list *instructions);
   void generate_vec4_instruction(vec4_instruction *inst,
                                  struct brw_reg dst,
                                  struct brw_reg *src);

   void generate_tex(vec4_instruction *inst,
                     struct brw_reg dst);

   void generate_urb_write(vec4_instruction *ir, bool copy_g0);
   void generate_gs_thread_end(vec4_instruction *ir);
   void generate_gs_set_write_offset(struct brw_reg dst,
                                     struct brw_reg src0,
                                     struct brw_reg src1);
   void generate_gs_set_vertex_count(struct brw_reg dst,
                                     struct brw_reg src);
   void generate_gs_set_dword_2_immed(struct brw_reg dst, struct brw_reg src);
   void generate_gs_prepare_channel_masks(struct brw_reg dst);
   void generate_gs_set_channel_masks(struct brw_reg dst, struct brw_reg src);

   void generate_oword_dual_block_offsets(struct brw_reg m1,
                                          struct brw_reg index);
   void generate_scratch_write(vec4_instruction *inst,
                               struct brw_reg dst,
                               struct brw_reg src,
                               struct brw_reg index);
   void generate_scratch_read(vec4_instruction *inst,
                              struct brw_reg dst,
                              struct brw_reg index);
   void generate_pull_constant_load(vec4_instruction *inst,
                                    struct brw_reg dst,
                                    struct brw_reg index,
                                    struct brw_reg offset);
   void generate_untyped_atomic(vec4_instruction *ir,
                                struct brw_reg dst,
                                struct brw_reg atomic_op,
                                struct brw_reg surf_index);
   void generate_untyped_surface_read(vec4_instruction *ir,
                                      struct brw_reg dst,
                                      struct brw_reg surf_index);

   struct brw_vec4_prog_data *prog_data;

   const bool debug_flag;
};

@


