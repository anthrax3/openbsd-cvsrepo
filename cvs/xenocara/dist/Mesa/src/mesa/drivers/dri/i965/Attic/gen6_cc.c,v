head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.4
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.2
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.2
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2013.09.05.14.04.24;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.37;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.43;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2015.01.25.14.11.50;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.4
date	2015.02.20.22.48.55;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2009 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *
 */

#include "brw_context.h"
#include "brw_state.h"
#include "brw_defines.h"
#include "brw_util.h"
#include "intel_batchbuffer.h"
#include "main/macros.h"
#include "main/enums.h"
#include "main/glformats.h"
#include "main/stencil.h"

static void
gen6_upload_blend_state(struct brw_context *brw)
{
   bool is_buffer_zero_integer_format = false;
   struct gl_context *ctx = &brw->ctx;
   struct gen6_blend_state *blend;
   int b;
   int nr_draw_buffers = ctx->DrawBuffer->_NumColorDrawBuffers;
   int size;

   /* We need at least one BLEND_STATE written, because we might do
    * thread dispatch even if _NumColorDrawBuffers is 0 (for example
    * for computed depth or alpha test), which will do an FB write
    * with render target 0, which will reference BLEND_STATE[0] for
    * alpha test enable.
    */
   if (nr_draw_buffers == 0 && ctx->Color.AlphaEnabled)
      nr_draw_buffers = 1;

   size = sizeof(*blend) * nr_draw_buffers;
   blend = brw_state_batch(brw, AUB_TRACE_BLEND_STATE,
			   size, 64, &brw->cc.blend_state_offset);

   memset(blend, 0, size);

   for (b = 0; b < nr_draw_buffers; b++) {
      /* _NEW_BUFFERS */
      struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[b];
      GLenum rb_type;
      bool integer;

      if (rb)
	 rb_type = _mesa_get_format_datatype(rb->Format);
      else
	 rb_type = GL_UNSIGNED_NORMALIZED;

      /* Used for implementing the following bit of GL_EXT_texture_integer:
       *     "Per-fragment operations that require floating-point color
       *      components, including multisample alpha operations, alpha test,
       *      blending, and dithering, have no effect when the corresponding
       *      colors are written to an integer color buffer."
      */
      integer = (rb_type == GL_INT || rb_type == GL_UNSIGNED_INT);

      if(b == 0 && integer)
         is_buffer_zero_integer_format = true;

      /* _NEW_COLOR */
      if (ctx->Color.ColorLogicOpEnabled) {
	 /* Floating point RTs should have no effect from LogicOp,
	  * except for disabling of blending, but other types should.
	  *
	  * However, from the Sandy Bridge PRM, Vol 2 Par 1, Section 8.1.11,
	  * "Logic Ops",
	  *
	  *     "Logic Ops are only supported on *_UNORM surfaces (excluding
	  *      _SRGB variants), otherwise Logic Ops must be DISABLED."
	  */
         WARN_ONCE(ctx->Color.LogicOp != GL_COPY &&
                   rb_type != GL_UNSIGNED_NORMALIZED &&
                   rb_type != GL_FLOAT, "Ignoring %s logic op on %s "
                   "renderbuffer\n",
                   _mesa_lookup_enum_by_nr(ctx->Color.LogicOp),
                   _mesa_lookup_enum_by_nr(rb_type));
	 if (rb_type == GL_UNSIGNED_NORMALIZED) {
	    blend[b].blend1.logic_op_enable = 1;
	    blend[b].blend1.logic_op_func =
	       intel_translate_logic_op(ctx->Color.LogicOp);
	 }
      } else if (ctx->Color.BlendEnabled & (1 << b) && !integer) {
	 GLenum eqRGB = ctx->Color.Blend[b].EquationRGB;
	 GLenum eqA = ctx->Color.Blend[b].EquationA;
	 GLenum srcRGB = ctx->Color.Blend[b].SrcRGB;
	 GLenum dstRGB = ctx->Color.Blend[b].DstRGB;
	 GLenum srcA = ctx->Color.Blend[b].SrcA;
	 GLenum dstA = ctx->Color.Blend[b].DstA;

	 if (eqRGB == GL_MIN || eqRGB == GL_MAX) {
	    srcRGB = dstRGB = GL_ONE;
	 }

	 if (eqA == GL_MIN || eqA == GL_MAX) {
	    srcA = dstA = GL_ONE;
	 }

         /* Due to hardware limitations, the destination may have information
          * in an alpha channel even when the format specifies no alpha
          * channel. In order to avoid getting any incorrect blending due to
          * that alpha channel, coerce the blend factors to values that will
          * not read the alpha channel, but will instead use the correct
          * implicit value for alpha.
          */
         if (rb && !_mesa_base_format_has_channel(rb->_BaseFormat, GL_TEXTURE_ALPHA_TYPE))
         {
            srcRGB = brw_fix_xRGB_alpha(srcRGB);
            srcA = brw_fix_xRGB_alpha(srcA);
            dstRGB = brw_fix_xRGB_alpha(dstRGB);
            dstA = brw_fix_xRGB_alpha(dstA);
         }

	 blend[b].blend0.dest_blend_factor = brw_translate_blend_factor(dstRGB);
	 blend[b].blend0.source_blend_factor = brw_translate_blend_factor(srcRGB);
	 blend[b].blend0.blend_func = brw_translate_blend_equation(eqRGB);

	 blend[b].blend0.ia_dest_blend_factor = brw_translate_blend_factor(dstA);
	 blend[b].blend0.ia_source_blend_factor = brw_translate_blend_factor(srcA);
	 blend[b].blend0.ia_blend_func = brw_translate_blend_equation(eqA);

	 blend[b].blend0.blend_enable = 1;
	 blend[b].blend0.ia_blend_enable = (srcA != srcRGB ||
					 dstA != dstRGB ||
					 eqA != eqRGB);
      }

      /* See section 8.1.6 "Pre-Blend Color Clamping" of the
       * SandyBridge PRM Volume 2 Part 1 for HW requirements.
       *
       * We do our ARB_color_buffer_float CLAMP_FRAGMENT_COLOR
       * clamping in the fragment shader.  For its clamping of
       * blending, the spec says:
       *
       *     "RESOLVED: For fixed-point color buffers, the inputs and
       *      the result of the blending equation are clamped.  For
       *      floating-point color buffers, no clamping occurs."
       *
       * So, generally, we want clamping to the render target's range.
       * And, good news, the hardware tables for both pre- and
       * post-blend color clamping are either ignored, or any are
       * allowed, or clamping is required but RT range clamping is a
       * valid option.
       */
      blend[b].blend1.pre_blend_clamp_enable = 1;
      blend[b].blend1.post_blend_clamp_enable = 1;
      blend[b].blend1.clamp_range = BRW_RENDERTARGET_CLAMPRANGE_FORMAT;

      /* _NEW_COLOR */
      if (ctx->Color.AlphaEnabled && !integer) {
	 blend[b].blend1.alpha_test_enable = 1;
	 blend[b].blend1.alpha_test_func =
	    intel_translate_compare_func(ctx->Color.AlphaFunc);

      }

      /* _NEW_COLOR */
      if (ctx->Color.DitherFlag && !integer) {
	 blend[b].blend1.dither_enable = 1;
	 blend[b].blend1.y_dither_offset = 0;
	 blend[b].blend1.x_dither_offset = 0;
      }

      blend[b].blend1.write_disable_r = !ctx->Color.ColorMask[b][0];
      blend[b].blend1.write_disable_g = !ctx->Color.ColorMask[b][1];
      blend[b].blend1.write_disable_b = !ctx->Color.ColorMask[b][2];
      blend[b].blend1.write_disable_a = !ctx->Color.ColorMask[b][3];

      /* OpenGL specification 3.3 (page 196), section 4.1.3 says:
       * "If drawbuffer zero is not NONE and the buffer it references has an
       * integer format, the SAMPLE_ALPHA_TO_COVERAGE and SAMPLE_ALPHA_TO_ONE
       * operations are skipped."
       */
      if(!is_buffer_zero_integer_format) {
         /* _NEW_MULTISAMPLE */
         blend[b].blend1.alpha_to_coverage =
            ctx->Multisample._Enabled && ctx->Multisample.SampleAlphaToCoverage;

	/* From SandyBridge PRM, volume 2 Part 1, section 8.2.3, BLEND_STATE:
	 * DWord 1, Bit 30 (AlphaToOne Enable):
	 * "If Dual Source Blending is enabled, this bit must be disabled"
	 */
         WARN_ONCE(ctx->Color.Blend[b]._UsesDualSrc &&
                   ctx->Multisample._Enabled &&
                   ctx->Multisample.SampleAlphaToOne,
                   "HW workaround: disabling alpha to one with dual src "
                   "blending\n");
	 if (ctx->Color.Blend[b]._UsesDualSrc)
            blend[b].blend1.alpha_to_one = false;
	 else
	    blend[b].blend1.alpha_to_one =
	       ctx->Multisample._Enabled && ctx->Multisample.SampleAlphaToOne;

         blend[b].blend1.alpha_to_coverage_dither = (brw->gen >= 7);
      }
      else {
         blend[b].blend1.alpha_to_coverage = false;
         blend[b].blend1.alpha_to_one = false;
      }
   }

   /* Point the GPU at the new indirect state. */
   if (brw->gen == 6) {
      BEGIN_BATCH(4);
      OUT_BATCH(_3DSTATE_CC_STATE_POINTERS << 16 | (4 - 2));
      OUT_BATCH(brw->cc.blend_state_offset | 1);
      OUT_BATCH(0);
      OUT_BATCH(0);
      ADVANCE_BATCH();
   } else {
      BEGIN_BATCH(2);
      OUT_BATCH(_3DSTATE_BLEND_STATE_POINTERS << 16 | (2 - 2));
      OUT_BATCH(brw->cc.blend_state_offset | 1);
      ADVANCE_BATCH();
   }
}

const struct brw_tracked_state gen6_blend_state = {
   .dirty = {
      .mesa = (_NEW_COLOR |
               _NEW_BUFFERS |
               _NEW_MULTISAMPLE),
      .brw = BRW_NEW_BATCH | BRW_NEW_STATE_BASE_ADDRESS,
      .cache = 0,
   },
   .emit = gen6_upload_blend_state,
};

static void
gen6_upload_color_calc_state(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->ctx;
   struct gen6_color_calc_state *cc;

   cc = brw_state_batch(brw, AUB_TRACE_CC_STATE,
			sizeof(*cc), 64, &brw->cc.state_offset);
   memset(cc, 0, sizeof(*cc));

   /* _NEW_COLOR */
   cc->cc0.alpha_test_format = BRW_ALPHATEST_FORMAT_UNORM8;
   UNCLAMPED_FLOAT_TO_UBYTE(cc->cc1.alpha_ref_fi.ui, ctx->Color.AlphaRef);

   /* _NEW_STENCIL */
   cc->cc0.stencil_ref = _mesa_get_stencil_ref(ctx, 0);
   cc->cc0.bf_stencil_ref = _mesa_get_stencil_ref(ctx, ctx->Stencil._BackFace);

   /* _NEW_COLOR */
   cc->constant_r = ctx->Color.BlendColorUnclamped[0];
   cc->constant_g = ctx->Color.BlendColorUnclamped[1];
   cc->constant_b = ctx->Color.BlendColorUnclamped[2];
   cc->constant_a = ctx->Color.BlendColorUnclamped[3];

   /* Point the GPU at the new indirect state. */
   if (brw->gen == 6) {
      BEGIN_BATCH(4);
      OUT_BATCH(_3DSTATE_CC_STATE_POINTERS << 16 | (4 - 2));
      OUT_BATCH(0);
      OUT_BATCH(0);
      OUT_BATCH(brw->cc.state_offset | 1);
      ADVANCE_BATCH();
   } else {
      BEGIN_BATCH(2);
      OUT_BATCH(_3DSTATE_CC_STATE_POINTERS << 16 | (2 - 2));
      OUT_BATCH(brw->cc.state_offset | 1);
      ADVANCE_BATCH();
   }
}

const struct brw_tracked_state gen6_color_calc_state = {
   .dirty = {
      .mesa = _NEW_COLOR | _NEW_STENCIL,
      .brw = BRW_NEW_BATCH | BRW_NEW_STATE_BASE_ADDRESS,
      .cache = 0,
   },
   .emit = gen6_upload_color_calc_state,
};
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d267 3
a269 6
   if (brw->gen < 9) {
      /* _NEW_STENCIL */
      cc->cc0.stencil_ref = _mesa_get_stencil_ref(ctx, 0);
      cc->cc0.bf_stencil_ref =
         _mesa_get_stencil_ref(ctx, ctx->Stencil._BackFace);
   }
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d267 6
a272 3
   /* _NEW_STENCIL */
   cc->cc0.stencil_ref = _mesa_get_stencil_ref(ctx, 0);
   cc->cc0.bf_stencil_ref = _mesa_get_stencil_ref(ctx, ctx->Stencil._BackFace);
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d34 3
d39 1
a39 1
prepare_blend_state(struct brw_context *brw)
d41 2
a42 1
   struct gl_context *ctx = &brw->intel.ctx;
d58 2
a59 1
   blend = brw_state_batch(brw, size, 64, &brw->cc.blend_state_offset);
d64 21
d86 1
a86 3
      if (ctx->Color._LogicOpEnabled) {
	 struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[b];
	 /* _NEW_BUFFERS */
d88 7
a94 1
	  * except for disabling of blending
d96 7
a102 1
	 if (_mesa_get_format_datatype(rb->Format) != GL_FLOAT) {
d107 7
a113 7
      } else if (ctx->Color.BlendEnabled & (1 << b)) {
	 GLenum eqRGB = ctx->Color.Blend[0].EquationRGB;
	 GLenum eqA = ctx->Color.Blend[0].EquationA;
	 GLenum srcRGB = ctx->Color.Blend[0].SrcRGB;
	 GLenum dstRGB = ctx->Color.Blend[0].DstRGB;
	 GLenum srcA = ctx->Color.Blend[0].SrcA;
	 GLenum dstA = ctx->Color.Blend[0].DstA;
d123 15
d152 20
d174 1
a174 1
      if (ctx->Color.AlphaEnabled) {
d182 1
a182 1
      if (ctx->Color.DitherFlag) {
d192 32
d226 14
a239 1
   brw->state.dirty.cache |= CACHE_NEW_BLEND_STATE;
d245 3
a247 2
	       _NEW_BUFFERS),
      .brw = BRW_NEW_BATCH,
d250 1
a250 1
   .prepare = prepare_blend_state,
d254 1
a254 1
gen6_prepare_color_calc_state(struct brw_context *brw)
d256 1
a256 1
   struct gl_context *ctx = &brw->intel.ctx;
d259 2
a260 1
   cc = brw_state_batch(brw, sizeof(*cc), 64, &brw->cc.state_offset);
d268 2
a269 2
   cc->cc0.stencil_ref = ctx->Stencil.Ref[0];
   cc->cc0.bf_stencil_ref = ctx->Stencil.Ref[ctx->Stencil._BackFace];
d277 14
a290 1
   brw->state.dirty.cache |= CACHE_NEW_COLOR_CALC_STATE;
d296 1
a296 1
      .brw = BRW_NEW_BATCH,
d299 1
a299 25
   .prepare = gen6_prepare_color_calc_state,
};

static void upload_cc_state_pointers(struct brw_context *brw)
{
   struct intel_context *intel = &brw->intel;

   BEGIN_BATCH(4);
   OUT_BATCH(_3DSTATE_CC_STATE_POINTERS << 16 | (4 - 2));
   OUT_BATCH(brw->cc.blend_state_offset | 1);
   OUT_BATCH(brw->cc.depth_stencil_state_offset | 1);
   OUT_BATCH(brw->cc.state_offset | 1);
   ADVANCE_BATCH();
}

const struct brw_tracked_state gen6_cc_state_pointers = {
   .dirty = {
      .mesa = 0,
      .brw = (BRW_NEW_BATCH |
	      BRW_NEW_STATE_BASE_ADDRESS),
      .cache = (CACHE_NEW_BLEND_STATE |
		CACHE_NEW_COLOR_CALC_STATE |
		CACHE_NEW_DEPTH_STENCIL_STATE)
   },
   .emit = upload_cc_state_pointers,
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a34 14
struct gen6_blend_state_key {
   GLboolean color_blend, alpha_enabled;
   GLboolean dither;
   GLboolean color_mask[BRW_MAX_DRAW_BUFFERS][4];

   GLenum logic_op;

   GLenum blend_eq_rgb, blend_eq_a;
   GLenum blend_src_rgb, blend_src_a;
   GLenum blend_dst_rgb, blend_dst_a;

   GLenum alpha_func;
};

d36 1
a36 2
blend_state_populate_key(struct brw_context *brw,
			 struct gen6_blend_state_key *key)
d39 1
a39 42

   memset(key, 0, sizeof(*key));

   /* _NEW_COLOR */
   memcpy(key->color_mask, ctx->Color.ColorMask, sizeof(key->color_mask));

   /* _NEW_COLOR */
   if (ctx->Color._LogicOpEnabled)
      key->logic_op = ctx->Color.LogicOp;
   else
      key->logic_op = GL_COPY;

   /* _NEW_COLOR */
   key->color_blend = ctx->Color.BlendEnabled;
   if (key->color_blend) {
      key->blend_eq_rgb = ctx->Color.BlendEquationRGB;
      key->blend_eq_a = ctx->Color.BlendEquationA;
      key->blend_src_rgb = ctx->Color.BlendSrcRGB;
      key->blend_dst_rgb = ctx->Color.BlendDstRGB;
      key->blend_src_a = ctx->Color.BlendSrcA;
      key->blend_dst_a = ctx->Color.BlendDstA;
   }

   /* _NEW_COLOR */
   key->alpha_enabled = ctx->Color.AlphaEnabled;
   if (key->alpha_enabled) {
      key->alpha_func = ctx->Color.AlphaFunc;
   }

   /* _NEW_COLOR */
   key->dither = ctx->Color.DitherFlag;
}

/**
 * Creates the state cache entry for the given CC unit key.
 */
static drm_intel_bo *
blend_state_create_from_key(struct brw_context *brw,
			    struct gen6_blend_state_key *key)
{
   struct gen6_blend_state blend[BRW_MAX_DRAW_BUFFERS];
   drm_intel_bo *bo;
d41 2
d44 34
a77 13
   memset(&blend, 0, sizeof(blend));

   for (b = 0; b < BRW_MAX_DRAW_BUFFERS; b++) {
      if (key->logic_op != GL_COPY) {
	 blend[b].blend1.logic_op_enable = 1;
	 blend[b].blend1.logic_op_func = intel_translate_logic_op(key->logic_op);
      } else if (key->color_blend & (1 << b)) {
	 GLenum eqRGB = key->blend_eq_rgb;
	 GLenum eqA = key->blend_eq_a;
	 GLenum srcRGB = key->blend_src_rgb;
	 GLenum dstRGB = key->blend_dst_rgb;
	 GLenum srcA = key->blend_src_a;
	 GLenum dstA = key->blend_dst_a;
d101 3
a103 1
      if (key->alpha_enabled) {
d105 2
a106 1
	 blend[b].blend1.alpha_test_func = intel_translate_compare_func(key->alpha_func);
d110 2
a111 1
      if (key->dither) {
d117 4
a120 4
      blend[b].blend1.write_disable_r = !key->color_mask[b][0];
      blend[b].blend1.write_disable_g = !key->color_mask[b][1];
      blend[b].blend1.write_disable_b = !key->color_mask[b][2];
      blend[b].blend1.write_disable_a = !key->color_mask[b][3];
d123 1
a123 23
   bo = brw_upload_cache(&brw->cache, BRW_BLEND_STATE,
			 key, sizeof(*key),
			 NULL, 0,
			 &blend, sizeof(blend));

   return bo;
}

static void
prepare_blend_state(struct brw_context *brw)
{
   struct gen6_blend_state_key key;

   blend_state_populate_key(brw, &key);

   drm_intel_bo_unreference(brw->cc.blend_state_bo);
   brw->cc.blend_state_bo = brw_search_cache(&brw->cache, BRW_BLEND_STATE,
					     &key, sizeof(key),
					     NULL, 0,
					     NULL);

   if (brw->cc.blend_state_bo == NULL)
      brw->cc.blend_state_bo = blend_state_create_from_key(brw, &key);
d128 3
a130 2
      .mesa = _NEW_COLOR,
      .brw = 0,
a135 6
struct gen6_color_calc_state_key {
   float blend_constant_color[4];
   GLclampf alpha_ref;
   GLubyte stencil_ref[2];
};

d137 1
a137 2
color_calc_state_populate_key(struct brw_context *brw,
			      struct gen6_color_calc_state_key *key)
d140 1
d142 6
a147 1
   memset(key, 0, sizeof(*key));
d150 2
a151 7
   if (ctx->Stencil._Enabled) {
      const unsigned back = ctx->Stencil._BackFace;

      key->stencil_ref[0] = ctx->Stencil.Ref[0];
      if (ctx->Stencil._TestTwoSide)
	 key->stencil_ref[1] = ctx->Stencil.Ref[back];
   }
d154 4
a157 26
   if (ctx->Color.AlphaEnabled)
      key->alpha_ref = ctx->Color.AlphaRef;

   key->blend_constant_color[0] = ctx->Color.BlendColor[0];
   key->blend_constant_color[1] = ctx->Color.BlendColor[1];
   key->blend_constant_color[2] = ctx->Color.BlendColor[2];
   key->blend_constant_color[3] = ctx->Color.BlendColor[3];
}

/**
 * Creates the state cache entry for the given CC state key.
 */
static drm_intel_bo *
color_calc_state_create_from_key(struct brw_context *brw,
				 struct gen6_color_calc_state_key *key)
{
   struct gen6_color_calc_state cc;
   drm_intel_bo *bo;

   memset(&cc, 0, sizeof(cc));

   cc.cc0.alpha_test_format = BRW_ALPHATEST_FORMAT_UNORM8;
   UNCLAMPED_FLOAT_TO_UBYTE(cc.cc1.alpha_ref_fi.ui, key->alpha_ref);

   cc.cc0.stencil_ref = key->stencil_ref[0];
   cc.cc0.bf_stencil_ref = key->stencil_ref[1];
d159 1
a159 28
   cc.constant_r = key->blend_constant_color[0];
   cc.constant_g = key->blend_constant_color[1];
   cc.constant_b = key->blend_constant_color[2];
   cc.constant_a = key->blend_constant_color[3];

   bo = brw_upload_cache(&brw->cache, BRW_COLOR_CALC_STATE,
			 key, sizeof(*key),
			 NULL, 0,
			 &cc, sizeof(cc));

   return bo;
}

static void
prepare_color_calc_state(struct brw_context *brw)
{
   struct gen6_color_calc_state_key key;

   color_calc_state_populate_key(brw, &key);

   drm_intel_bo_unreference(brw->cc.state_bo);
   brw->cc.state_bo = brw_search_cache(&brw->cache, BRW_COLOR_CALC_STATE,
				       &key, sizeof(key),
				       NULL, 0,
				       NULL);

   if (brw->cc.state_bo == NULL)
      brw->cc.state_bo = color_calc_state_create_from_key(brw, &key);
d165 1
a165 1
      .brw = 0,
d168 1
a168 1
   .prepare = prepare_color_calc_state,
d177 3
a179 3
   OUT_RELOC(brw->cc.blend_state_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 1);
   OUT_RELOC(brw->cc.depth_stencil_state_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 1);
   OUT_RELOC(brw->cc.state_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 1);
a182 8

static void prepare_cc_state_pointers(struct brw_context *brw)
{
   brw_add_validated_bo(brw, brw->cc.state_bo);
   brw_add_validated_bo(brw, brw->cc.blend_state_bo);
   brw_add_validated_bo(brw, brw->cc.depth_stencil_state_bo);
}

d186 2
a187 1
      .brw = BRW_NEW_BATCH,
a191 1
   .prepare = prepare_cc_state_pointers,
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d38 1
d53 1
a53 1
   GLcontext *ctx = &brw->intel.ctx;
d58 3
d94 1
a94 1
   struct gen6_blend_state blend;
d96 1
d100 37
a136 10
   if (key->logic_op != GL_COPY) {
      blend.blend1.logic_op_enable = 1;
      blend.blend1.logic_op_func = intel_translate_logic_op(key->logic_op);
   } else if (key->color_blend) {
      GLenum eqRGB = key->blend_eq_rgb;
      GLenum eqA = key->blend_eq_a;
      GLenum srcRGB = key->blend_src_rgb;
      GLenum dstRGB = key->blend_dst_rgb;
      GLenum srcA = key->blend_src_a;
      GLenum dstA = key->blend_dst_a;
a137 2
      if (eqRGB == GL_MIN || eqRGB == GL_MAX) {
	 srcRGB = dstRGB = GL_ONE;
d140 4
a143 2
      if (eqA == GL_MIN || eqA == GL_MAX) {
	 srcA = dstA = GL_ONE;
d146 4
a149 24
      blend.blend0.dest_blend_factor = brw_translate_blend_factor(dstRGB);
      blend.blend0.source_blend_factor = brw_translate_blend_factor(srcRGB);
      blend.blend0.blend_func = brw_translate_blend_equation(eqRGB);

      blend.blend0.ia_dest_blend_factor = brw_translate_blend_factor(dstA);
      blend.blend0.ia_source_blend_factor = brw_translate_blend_factor(srcA);
      blend.blend0.ia_blend_func = brw_translate_blend_equation(eqA);

      blend.blend0.blend_enable = 1;
      blend.blend0.ia_blend_enable = (srcA != srcRGB ||
				      dstA != dstRGB ||
				      eqA != eqRGB);
   }

   if (key->alpha_enabled) {
      blend.blend1.alpha_test_enable = 1;
      blend.blend1.alpha_test_func = intel_translate_compare_func(key->alpha_func);

   }

   if (key->dither) {
      blend.blend1.dither_enable = 1;
      blend.blend1.y_dither_offset = 0;
      blend.blend1.x_dither_offset = 0;
d187 1
a187 1
   GLubyte blend_constant_color[4];
d196 1
a196 1
   GLcontext *ctx = &brw->intel.ctx;
d269 1
a269 1
      .mesa = _NEW_COLOR,
d281 1
a281 2
   OUT_BATCH(CMD_3D_CC_STATE_POINTERS << 16 | (4 - 2));
   OUT_RELOC(brw->cc.state_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 1);
d284 1
a285 2

   intel_batchbuffer_emit_mi_flush(intel->batch);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a37 1
   GLboolean color_mask[BRW_MAX_DRAW_BUFFERS][4];
d52 1
a52 1
   struct gl_context *ctx = &brw->intel.ctx;
a56 3
   memcpy(key->color_mask, ctx->Color.ColorMask, sizeof(key->color_mask));

   /* _NEW_COLOR */
d90 1
a90 1
   struct gen6_blend_state blend[BRW_MAX_DRAW_BUFFERS];
a91 1
   int b;
d95 13
a107 32
   for (b = 0; b < BRW_MAX_DRAW_BUFFERS; b++) {
      if (key->logic_op != GL_COPY) {
	 blend[b].blend1.logic_op_enable = 1;
	 blend[b].blend1.logic_op_func = intel_translate_logic_op(key->logic_op);
      } else if (key->color_blend & (1 << b)) {
	 GLenum eqRGB = key->blend_eq_rgb;
	 GLenum eqA = key->blend_eq_a;
	 GLenum srcRGB = key->blend_src_rgb;
	 GLenum dstRGB = key->blend_dst_rgb;
	 GLenum srcA = key->blend_src_a;
	 GLenum dstA = key->blend_dst_a;

	 if (eqRGB == GL_MIN || eqRGB == GL_MAX) {
	    srcRGB = dstRGB = GL_ONE;
	 }

	 if (eqA == GL_MIN || eqA == GL_MAX) {
	    srcA = dstA = GL_ONE;
	 }

	 blend[b].blend0.dest_blend_factor = brw_translate_blend_factor(dstRGB);
	 blend[b].blend0.source_blend_factor = brw_translate_blend_factor(srcRGB);
	 blend[b].blend0.blend_func = brw_translate_blend_equation(eqRGB);

	 blend[b].blend0.ia_dest_blend_factor = brw_translate_blend_factor(dstA);
	 blend[b].blend0.ia_source_blend_factor = brw_translate_blend_factor(srcA);
	 blend[b].blend0.ia_blend_func = brw_translate_blend_equation(eqA);

	 blend[b].blend0.blend_enable = 1;
	 blend[b].blend0.ia_blend_enable = (srcA != srcRGB ||
					 dstA != dstRGB ||
					 eqA != eqRGB);
d110 3
a112 3
      if (key->alpha_enabled) {
	 blend[b].blend1.alpha_test_enable = 1;
	 blend[b].blend1.alpha_test_func = intel_translate_compare_func(key->alpha_func);
d114 17
a130 1
      }
d132 1
a132 5
      if (key->dither) {
	 blend[b].blend1.dither_enable = 1;
	 blend[b].blend1.y_dither_offset = 0;
	 blend[b].blend1.x_dither_offset = 0;
      }
d134 4
a137 4
      blend[b].blend1.write_disable_r = !key->color_mask[b][0];
      blend[b].blend1.write_disable_g = !key->color_mask[b][1];
      blend[b].blend1.write_disable_b = !key->color_mask[b][2];
      blend[b].blend1.write_disable_a = !key->color_mask[b][3];
d175 1
a175 1
   float blend_constant_color[4];
d184 1
a184 1
   struct gl_context *ctx = &brw->intel.ctx;
d257 1
a257 1
      .mesa = _NEW_COLOR | _NEW_STENCIL,
d269 2
a270 1
   OUT_BATCH(_3DSTATE_CC_STATE_POINTERS << 16 | (4 - 2));
a272 1
   OUT_RELOC(brw->cc.state_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, 1);
d274 2
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d34 14
a47 3
#include "main/enums.h"
#include "main/glformats.h"
#include "main/stencil.h"
d50 43
a92 1
gen6_upload_blend_state(struct brw_context *brw)
d94 2
a95 3
   bool is_buffer_zero_integer_format = false;
   struct gl_context *ctx = &brw->ctx;
   struct gen6_blend_state *blend;
a96 2
   int nr_draw_buffers = ctx->DrawBuffer->_NumColorDrawBuffers;
   int size;
d98 13
a110 66
   /* We need at least one BLEND_STATE written, because we might do
    * thread dispatch even if _NumColorDrawBuffers is 0 (for example
    * for computed depth or alpha test), which will do an FB write
    * with render target 0, which will reference BLEND_STATE[0] for
    * alpha test enable.
    */
   if (nr_draw_buffers == 0 && ctx->Color.AlphaEnabled)
      nr_draw_buffers = 1;

   size = sizeof(*blend) * nr_draw_buffers;
   blend = brw_state_batch(brw, AUB_TRACE_BLEND_STATE,
			   size, 64, &brw->cc.blend_state_offset);

   memset(blend, 0, size);

   for (b = 0; b < nr_draw_buffers; b++) {
      /* _NEW_BUFFERS */
      struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[b];
      GLenum rb_type;
      bool integer;

      if (rb)
	 rb_type = _mesa_get_format_datatype(rb->Format);
      else
	 rb_type = GL_UNSIGNED_NORMALIZED;

      /* Used for implementing the following bit of GL_EXT_texture_integer:
       *     "Per-fragment operations that require floating-point color
       *      components, including multisample alpha operations, alpha test,
       *      blending, and dithering, have no effect when the corresponding
       *      colors are written to an integer color buffer."
      */
      integer = (rb_type == GL_INT || rb_type == GL_UNSIGNED_INT);

      if(b == 0 && integer)
         is_buffer_zero_integer_format = true;

      /* _NEW_COLOR */
      if (ctx->Color.ColorLogicOpEnabled) {
	 /* Floating point RTs should have no effect from LogicOp,
	  * except for disabling of blending, but other types should.
	  *
	  * However, from the Sandy Bridge PRM, Vol 2 Par 1, Section 8.1.11,
	  * "Logic Ops",
	  *
	  *     "Logic Ops are only supported on *_UNORM surfaces (excluding
	  *      _SRGB variants), otherwise Logic Ops must be DISABLED."
	  */
         WARN_ONCE(ctx->Color.LogicOp != GL_COPY &&
                   rb_type != GL_UNSIGNED_NORMALIZED &&
                   rb_type != GL_FLOAT, "Ignoring %s logic op on %s "
                   "renderbuffer\n",
                   _mesa_lookup_enum_by_nr(ctx->Color.LogicOp),
                   _mesa_lookup_enum_by_nr(rb_type));
	 if (rb_type == GL_UNSIGNED_NORMALIZED) {
	    blend[b].blend1.logic_op_enable = 1;
	    blend[b].blend1.logic_op_func =
	       intel_translate_logic_op(ctx->Color.LogicOp);
	 }
      } else if (ctx->Color.BlendEnabled & (1 << b) && !integer) {
	 GLenum eqRGB = ctx->Color.Blend[b].EquationRGB;
	 GLenum eqA = ctx->Color.Blend[b].EquationA;
	 GLenum srcRGB = ctx->Color.Blend[b].SrcRGB;
	 GLenum dstRGB = ctx->Color.Blend[b].DstRGB;
	 GLenum srcA = ctx->Color.Blend[b].SrcA;
	 GLenum dstA = ctx->Color.Blend[b].DstA;
a119 15
         /* Due to hardware limitations, the destination may have information
          * in an alpha channel even when the format specifies no alpha
          * channel. In order to avoid getting any incorrect blending due to
          * that alpha channel, coerce the blend factors to values that will
          * not read the alpha channel, but will instead use the correct
          * implicit value for alpha.
          */
         if (rb && !_mesa_base_format_has_channel(rb->_BaseFormat, GL_TEXTURE_ALPHA_TYPE))
         {
            srcRGB = brw_fix_xRGB_alpha(srcRGB);
            srcA = brw_fix_xRGB_alpha(srcA);
            dstRGB = brw_fix_xRGB_alpha(dstRGB);
            dstA = brw_fix_xRGB_alpha(dstA);
         }

d134 1
a134 23
      /* See section 8.1.6 "Pre-Blend Color Clamping" of the
       * SandyBridge PRM Volume 2 Part 1 for HW requirements.
       *
       * We do our ARB_color_buffer_float CLAMP_FRAGMENT_COLOR
       * clamping in the fragment shader.  For its clamping of
       * blending, the spec says:
       *
       *     "RESOLVED: For fixed-point color buffers, the inputs and
       *      the result of the blending equation are clamped.  For
       *      floating-point color buffers, no clamping occurs."
       *
       * So, generally, we want clamping to the render target's range.
       * And, good news, the hardware tables for both pre- and
       * post-blend color clamping are either ignored, or any are
       * allowed, or clamping is required but RT range clamping is a
       * valid option.
       */
      blend[b].blend1.pre_blend_clamp_enable = 1;
      blend[b].blend1.post_blend_clamp_enable = 1;
      blend[b].blend1.clamp_range = BRW_RENDERTARGET_CLAMPRANGE_FORMAT;

      /* _NEW_COLOR */
      if (ctx->Color.AlphaEnabled && !integer) {
d136 1
a136 2
	 blend[b].blend1.alpha_test_func =
	    intel_translate_compare_func(ctx->Color.AlphaFunc);
d140 1
a140 2
      /* _NEW_COLOR */
      if (ctx->Color.DitherFlag && !integer) {
d146 18
a163 29
      blend[b].blend1.write_disable_r = !ctx->Color.ColorMask[b][0];
      blend[b].blend1.write_disable_g = !ctx->Color.ColorMask[b][1];
      blend[b].blend1.write_disable_b = !ctx->Color.ColorMask[b][2];
      blend[b].blend1.write_disable_a = !ctx->Color.ColorMask[b][3];

      /* OpenGL specification 3.3 (page 196), section 4.1.3 says:
       * "If drawbuffer zero is not NONE and the buffer it references has an
       * integer format, the SAMPLE_ALPHA_TO_COVERAGE and SAMPLE_ALPHA_TO_ONE
       * operations are skipped."
       */
      if(!is_buffer_zero_integer_format) {
         /* _NEW_MULTISAMPLE */
         blend[b].blend1.alpha_to_coverage =
            ctx->Multisample._Enabled && ctx->Multisample.SampleAlphaToCoverage;

	/* From SandyBridge PRM, volume 2 Part 1, section 8.2.3, BLEND_STATE:
	 * DWord 1, Bit 30 (AlphaToOne Enable):
	 * "If Dual Source Blending is enabled, this bit must be disabled"
	 */
         WARN_ONCE(ctx->Color.Blend[b]._UsesDualSrc &&
                   ctx->Multisample._Enabled &&
                   ctx->Multisample.SampleAlphaToOne,
                   "HW workaround: disabling alpha to one with dual src "
                   "blending\n");
	 if (ctx->Color.Blend[b]._UsesDualSrc)
            blend[b].blend1.alpha_to_one = false;
	 else
	    blend[b].blend1.alpha_to_one =
	       ctx->Multisample._Enabled && ctx->Multisample.SampleAlphaToOne;
d165 7
a171 7
         blend[b].blend1.alpha_to_coverage_dither = (brw->gen >= 7);
      }
      else {
         blend[b].blend1.alpha_to_coverage = false;
         blend[b].blend1.alpha_to_one = false;
      }
   }
d173 2
a174 14
   /* Point the GPU at the new indirect state. */
   if (brw->gen == 6) {
      BEGIN_BATCH(4);
      OUT_BATCH(_3DSTATE_CC_STATE_POINTERS << 16 | (4 - 2));
      OUT_BATCH(brw->cc.blend_state_offset | 1);
      OUT_BATCH(0);
      OUT_BATCH(0);
      ADVANCE_BATCH();
   } else {
      BEGIN_BATCH(2);
      OUT_BATCH(_3DSTATE_BLEND_STATE_POINTERS << 16 | (2 - 2));
      OUT_BATCH(brw->cc.blend_state_offset | 1);
      ADVANCE_BATCH();
   }
d179 2
a180 4
      .mesa = (_NEW_COLOR |
               _NEW_BUFFERS |
               _NEW_MULTISAMPLE),
      .brw = BRW_NEW_BATCH | BRW_NEW_STATE_BASE_ADDRESS,
d183 7
a189 1
   .emit = gen6_upload_blend_state,
d193 2
a194 1
gen6_upload_color_calc_state(struct brw_context *brw)
d196 3
a198 2
   struct gl_context *ctx = &brw->ctx;
   struct gen6_color_calc_state *cc;
d200 8
a207 3
   cc = brw_state_batch(brw, AUB_TRACE_CC_STATE,
			sizeof(*cc), 64, &brw->cc.state_offset);
   memset(cc, 0, sizeof(*cc));
d210 18
a227 2
   cc->cc0.alpha_test_format = BRW_ALPHATEST_FORMAT_UNORM8;
   UNCLAMPED_FLOAT_TO_UBYTE(cc->cc1.alpha_ref_fi.ui, ctx->Color.AlphaRef);
d229 33
a261 3
   /* _NEW_STENCIL */
   cc->cc0.stencil_ref = _mesa_get_stencil_ref(ctx, 0);
   cc->cc0.bf_stencil_ref = _mesa_get_stencil_ref(ctx, ctx->Stencil._BackFace);
d263 2
a264 20
   /* _NEW_COLOR */
   cc->constant_r = ctx->Color.BlendColorUnclamped[0];
   cc->constant_g = ctx->Color.BlendColorUnclamped[1];
   cc->constant_b = ctx->Color.BlendColorUnclamped[2];
   cc->constant_a = ctx->Color.BlendColorUnclamped[3];

   /* Point the GPU at the new indirect state. */
   if (brw->gen == 6) {
      BEGIN_BATCH(4);
      OUT_BATCH(_3DSTATE_CC_STATE_POINTERS << 16 | (4 - 2));
      OUT_BATCH(0);
      OUT_BATCH(0);
      OUT_BATCH(brw->cc.state_offset | 1);
      ADVANCE_BATCH();
   } else {
      BEGIN_BATCH(2);
      OUT_BATCH(_3DSTATE_CC_STATE_POINTERS << 16 | (2 - 2));
      OUT_BATCH(brw->cc.state_offset | 1);
      ADVANCE_BATCH();
   }
d270 1
a270 1
      .brw = BRW_NEW_BATCH | BRW_NEW_STATE_BASE_ADDRESS,
d273 33
a305 1
   .emit = gen6_upload_color_calc_state,
@


1.1.1.3
log
@Import Mesa 10.4.3
@
text
@d267 3
a269 6
   if (brw->gen < 9) {
      /* _NEW_STENCIL */
      cc->cc0.stencil_ref = _mesa_get_stencil_ref(ctx, 0);
      cc->cc0.bf_stencil_ref =
         _mesa_get_stencil_ref(ctx, ctx->Stencil._BackFace);
   }
@


1.1.1.4
log
@Import Mesa 10.2.9
@
text
@d267 6
a272 3
   /* _NEW_STENCIL */
   cc->cc0.stencil_ref = _mesa_get_stencil_ref(ctx, 0);
   cc->cc0.bf_stencil_ref = _mesa_get_stencil_ref(ctx, ctx->Stencil._BackFace);
@


