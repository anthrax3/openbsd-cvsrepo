head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.05.33;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.18;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.53.39;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.53.39;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.29.33;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.42;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.16.06;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.56;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************

Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.
Copyright 2000, 2001 ATI Technologies Inc., Ontario, Canada, and
                     VA Linux Systems Inc., Fremont, California.

The Weather Channel (TM) funded Tungsten Graphics to develop the
initial release of the Radeon 8500 driver under the XFree86 license.
This notice must be preserved.

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial
portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Kevin E. Martin <martin@@valinux.com>
 *   Gareth Hughes <gareth@@valinux.com>
 *   Keith Whitwell <keithw@@vmware.com>
 *
 */

#include "main/glheader.h"
#include "main/texformat.h"
#include "main/renderbuffer.h"
#include "main/samplerobj.h"
#include "swrast/swrast.h"
#include "swrast/s_renderbuffer.h"

#include "radeon_common.h"
#include "radeon_span.h"


static void
radeon_renderbuffer_map(struct gl_context *ctx, struct gl_renderbuffer *rb)
{
	struct radeon_renderbuffer *rrb = radeon_renderbuffer(rb);
	GLubyte *map;
	int stride;

	if (!rb || !rrb)
		return;

	ctx->Driver.MapRenderbuffer(ctx, rb, 0, 0, rb->Width, rb->Height,
				    GL_MAP_READ_BIT | GL_MAP_WRITE_BIT,
				    &map, &stride);

	rrb->base.Map = map;
	rrb->base.RowStride = stride;
	/* No floating point color buffers, use GLubytes */
	rrb->base.ColorType = GL_UNSIGNED_BYTE;
}

static void
radeon_renderbuffer_unmap(struct gl_context *ctx, struct gl_renderbuffer *rb)
{
	struct radeon_renderbuffer *rrb = radeon_renderbuffer(rb);
	if (!rb || !rrb)
		return;

	ctx->Driver.UnmapRenderbuffer(ctx, rb);

	rrb->base.Map = NULL;
	rrb->base.RowStride = 0;
}

static void
radeon_map_framebuffer(struct gl_context *ctx, struct gl_framebuffer *fb)
{
	GLuint i;

	radeon_print(RADEON_MEMORY, RADEON_TRACE,
		"%s( %p , fb %p )\n",
		     __func__, ctx, fb);

	/* check for render to textures */
	for (i = 0; i < BUFFER_COUNT; i++)
		radeon_renderbuffer_map(ctx, fb->Attachment[i].Renderbuffer);

	radeon_check_front_buffer_rendering(ctx);
}

static void
radeon_unmap_framebuffer(struct gl_context *ctx, struct gl_framebuffer *fb)
{
	GLuint i;

	radeon_print(RADEON_MEMORY, RADEON_TRACE,
		"%s( %p , fb %p)\n",
		     __func__, ctx, fb);

	/* check for render to textures */
	for (i = 0; i < BUFFER_COUNT; i++)
		radeon_renderbuffer_unmap(ctx, fb->Attachment[i].Renderbuffer);

	radeon_check_front_buffer_rendering(ctx);
}

static void radeonSpanRenderStart(struct gl_context * ctx)
{
	radeonContextPtr rmesa = RADEON_CONTEXT(ctx);

	radeon_firevertices(rmesa);

	_swrast_map_textures(ctx);

	radeon_map_framebuffer(ctx, ctx->DrawBuffer);
	if (ctx->ReadBuffer != ctx->DrawBuffer)
		radeon_map_framebuffer(ctx, ctx->ReadBuffer);
}

static void radeonSpanRenderFinish(struct gl_context * ctx)
{
	_swrast_flush(ctx);
	_swrast_unmap_textures(ctx);

	radeon_unmap_framebuffer(ctx, ctx->DrawBuffer);
	if (ctx->ReadBuffer != ctx->DrawBuffer)
		radeon_unmap_framebuffer(ctx, ctx->ReadBuffer);
}

void radeonInitSpanFuncs(struct gl_context * ctx)
{
	struct swrast_device_driver *swdd =
	    _swrast_GetDeviceDriverReference(ctx);
	swdd->SpanRenderStart = radeonSpanRenderStart;
	swdd->SpanRenderFinish = radeonSpanRenderFinish;
}

@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@d39 1
a39 1
 *   Keith Whitwell <keith@@tungstengraphics.com>
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d45 2
d48 1
a50 1
#include "radeon_lock.h"
a52 1
#define DBG 0
d54 2
a55 20
#if defined(BYTE_ORDER) && defined(BIG_ENDIAN) && BYTE_ORDER == BIG_ENDIAN
#if defined(__linux__)
#include <byteswap.h>
#define CPU_TO_LE16( x )	bswap_16( x )
#define LE16_TO_CPU( x )	bswap_16( x )
#endif /* __linux__ */
#else
#define CPU_TO_LE16( x )	( x )
#define LE16_TO_CPU( x )	( x )
#endif

static void radeonSetSpanFunctions(struct radeon_renderbuffer *rrb);


/* r200 depth buffer is always tiled - this is the formula
   according to the docs unless I typo'ed in it
*/
#if defined(RADEON_R200)
static GLubyte *r200_depth_2byte(const struct radeon_renderbuffer * rrb,
				 GLint x, GLint y)
d57 3
a59 21
    GLubyte *ptr = rrb->bo->ptr + rrb->draw_offset;
    GLint offset;
    if (rrb->has_surface) {
	offset = x * rrb->cpp + y * rrb->pitch;
    } else {
	GLuint b;
	offset = 0;
	b = (((y  >> 4) * (rrb->pitch >> 8) + (x >> 6)));
	offset += (b >> 1) << 12;
	offset += (((rrb->pitch >> 8) & 0x1) ? (b & 0x1) : ((b & 0x1) ^ ((y >> 4) & 0x1))) << 11;
	offset += ((y >> 2) & 0x3) << 9;
	offset += ((x >> 3) & 0x1) << 8;
	offset += ((x >> 4) & 0x3) << 6;
	offset += ((x >> 2) & 0x1) << 5;
	offset += ((y >> 1) & 0x1) << 4;
	offset += ((x >> 1) & 0x1) << 3;
	offset += (y & 0x1) << 2;
	offset += (x & 0x1) << 1;
    }
    return &ptr[offset];
}
d61 2
a62 24
static GLubyte *r200_depth_4byte(const struct radeon_renderbuffer * rrb,
				 GLint x, GLint y)
{
    GLubyte *ptr = rrb->bo->ptr + rrb->draw_offset;
    GLint offset;
    if (rrb->has_surface) {
	offset = x * rrb->cpp + y * rrb->pitch;
    } else {
	GLuint b;
	offset = 0;
	b = (((y & 0x7ff) >> 4) * (rrb->pitch >> 7) + (x >> 5));
	offset += (b >> 1) << 12;
	offset += (((rrb->pitch >> 7) & 0x1) ? (b & 0x1) : ((b & 0x1) ^ ((y >> 4) & 0x1))) << 11;
	offset += ((y >> 2) & 0x3) << 9;
	offset += ((x >> 2) & 0x1) << 8;
	offset += ((x >> 3) & 0x3) << 6;
	offset += ((y >> 1) & 0x1) << 5;
	offset += ((x >> 1) & 0x1) << 4;
	offset += (y & 0x1) << 3;
	offset += (x & 0x1) << 2;
    }
    return &ptr[offset];
}
#endif
d64 8
a71 98
/* r600 tiling
 * two main types:
 * - 1D (akin to macro-linear/micro-tiled on older asics)
 * - 2D (akin to macro-tiled/micro-tiled on older asics)
 */
#if defined(RADEON_R600)
static inline GLint r600_1d_tile_helper(const struct radeon_renderbuffer * rrb,
					GLint x, GLint y, GLint is_depth, GLint is_stencil)
{
    GLint element_bytes = rrb->cpp;
    GLint num_samples = 1;
    GLint tile_width = 8;
    GLint tile_height = 8;
    GLint tile_thickness = 1;
    GLint pitch_elements = rrb->pitch / element_bytes;
    GLint height = rrb->base.Height;
    GLint z = 0;
    GLint sample_number = 0;
    /* */
    GLint tile_bytes;
    GLint tiles_per_row;
    GLint tiles_per_slice;
    GLint slice_offset;
    GLint tile_row_index;
    GLint tile_column_index;
    GLint tile_offset;
    GLint pixel_number = 0;
    GLint element_offset;
    GLint offset = 0;

    tile_bytes = tile_width * tile_height * tile_thickness * element_bytes * num_samples;
    tiles_per_row = pitch_elements / tile_width;
    tiles_per_slice = tiles_per_row * (height / tile_height);
    slice_offset = (z / tile_thickness) * tiles_per_slice * tile_bytes;
    tile_row_index = y / tile_height;
    tile_column_index = x / tile_width;
    tile_offset = ((tile_row_index * tiles_per_row) + tile_column_index) * tile_bytes;

    if (is_depth) {
	    GLint pixel_offset = 0;

	    pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
	    pixel_number |= ((y >> 0) & 1) << 1; // pn[1] = y[0]
	    pixel_number |= ((x >> 1) & 1) << 2; // pn[2] = x[1]
	    pixel_number |= ((y >> 1) & 1) << 3; // pn[3] = y[1]
	    pixel_number |= ((x >> 2) & 1) << 4; // pn[4] = x[2]
	    pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
	    switch (element_bytes) {
	    case 2:
		    pixel_offset = pixel_number * element_bytes * num_samples;
		    break;
	    case 4:
		    /* stencil and depth data are stored separately within a tile.
		     * stencil is stored in a contiguous tile before the depth tile.
		     * stencil element is 1 byte, depth element is 3 bytes.
		     * stencil tile is 64 bytes.
		     */
		    if (is_stencil)
			    pixel_offset = pixel_number * 1 * num_samples;
		    else
			    pixel_offset = (pixel_number * 3 * num_samples) + 64;
		    break;
	    }
	    element_offset = pixel_offset + (sample_number * element_bytes);
    } else {
	    GLint sample_offset;

	    switch (element_bytes) {
	    case 1:
		    pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
		    pixel_number |= ((x >> 1) & 1) << 1; // pn[1] = x[1]
		    pixel_number |= ((x >> 2) & 1) << 2; // pn[2] = x[2]
		    pixel_number |= ((y >> 1) & 1) << 3; // pn[3] = y[1]
		    pixel_number |= ((y >> 0) & 1) << 4; // pn[4] = y[0]
		    pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
		    break;
	    case 2:
		    pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
		    pixel_number |= ((x >> 1) & 1) << 1; // pn[1] = x[1]
		    pixel_number |= ((x >> 2) & 1) << 2; // pn[2] = x[2]
		    pixel_number |= ((y >> 0) & 1) << 3; // pn[3] = y[0]
		    pixel_number |= ((y >> 1) & 1) << 4; // pn[4] = y[1]
		    pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
		    break;
	    case 4:
		    pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
		    pixel_number |= ((x >> 1) & 1) << 1; // pn[1] = x[1]
		    pixel_number |= ((y >> 0) & 1) << 2; // pn[2] = y[0]
		    pixel_number |= ((x >> 2) & 1) << 3; // pn[3] = x[2]
		    pixel_number |= ((y >> 1) & 1) << 4; // pn[4] = y[1]
		    pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
		    break;
	    }
	    sample_offset = sample_number * (tile_bytes / num_samples);
	    element_offset = sample_offset + (pixel_number * element_bytes);
    }
    offset = slice_offset + tile_offset + element_offset;
    return offset;
d74 2
a75 1
static inline GLint r600_log2(GLint n)
d77 3
a79 1
	GLint log2 = 0;
d81 1
a81 166
	while (n >>= 1)
		++log2;
	return log2;
}

static inline GLint r600_2d_tile_helper(const struct radeon_renderbuffer * rrb,
					GLint x, GLint y, GLint is_depth, GLint is_stencil)
{
	GLint group_bytes = rrb->group_bytes;
	GLint num_channels = rrb->num_channels;
	GLint num_banks = rrb->num_banks;
	GLint r7xx_bank_op = rrb->r7xx_bank_op;
	/* */
	GLint group_bits = r600_log2(group_bytes);
	GLint channel_bits = r600_log2(num_channels);
	GLint bank_bits = r600_log2(num_banks);
	GLint element_bytes = rrb->cpp;
	GLint num_samples = 1;
	GLint tile_width = 8;
	GLint tile_height = 8;
	GLint tile_thickness = 1;
	GLint macro_tile_width = num_banks;
	GLint macro_tile_height = num_channels;
	GLint pitch_elements = (rrb->pitch / element_bytes) / tile_width;
	GLint height = rrb->base.Height / tile_height;
	GLint z = 0;
	GLint sample_number = 0;
	/* */
	GLint tile_bytes;
	GLint macro_tile_bytes;
	GLint macro_tiles_per_row;
	GLint macro_tiles_per_slice;
	GLint slice_offset;
	GLint macro_tile_row_index;
	GLint macro_tile_column_index;
	GLint macro_tile_offset;
	GLint pixel_number = 0;
	GLint element_offset;
	GLint bank = 0;
	GLint channel = 0;
	GLint total_offset;
	GLint group_mask = (1 << group_bits) - 1;
	GLint offset_low;
	GLint offset_high;
	GLint offset = 0;

	switch (num_channels) {
	case 2:
	default:
		// channel[0] = x[3] ^ y[3]
		channel |= (((x >> 3) ^ (y >> 3)) & 1) << 0;
		break;
	case 4:
		// channel[0] = x[4] ^ y[3]
		channel |= (((x >> 4) ^ (y >> 3)) & 1) << 0;
		// channel[1] = x[3] ^ y[4]
		channel |= (((x >> 3) ^ (y >> 4)) & 1) << 1;
		break;
	case 8:
		// channel[0] = x[5] ^ y[3]
		channel |= (((x >> 5) ^ (y >> 3)) & 1) << 0;
		// channel[0] = x[4] ^ x[5] ^ y[4]
		channel |= (((x >> 4) ^ (x >> 5) ^ (y >> 4)) & 1) << 1;
		// channel[0] = x[3] ^ y[5]
		channel |= (((x >> 3) ^ (y >> 5)) & 1) << 2;
		break;
	}

	switch (num_banks) {
	case 4:
		// bank[0] = x[3] ^ y[4 + log2(num_channels)]
		bank |= (((x >> 3) ^ (y >> (4 + channel_bits))) & 1) << 0;
		if (r7xx_bank_op)
			// bank[1] = x[3] ^ y[4 + log2(num_channels)] ^ x[5]
			bank |= (((x >> 4) ^ (y >> (3 + channel_bits)) ^ (x >> 5)) & 1) << 1;
		else
			// bank[1] = x[4] ^ y[3 + log2(num_channels)]
			bank |= (((x >> 4) ^ (y >> (3 + channel_bits))) & 1) << 1;
		break;
	case 8:
		// bank[0] = x[3] ^ y[5 + log2(num_channels)]
		bank |= (((x >> 3) ^ (y >> (5 + channel_bits))) & 1) << 0;
		// bank[1] = x[4] ^ y[4 + log2(num_channels)] ^ y[5 + log2(num_channels)]
		bank |= (((x >> 4) ^ (y >> (4 + channel_bits)) ^ (y >> (5 + channel_bits))) & 1) << 1;
		if (r7xx_bank_op)
			// bank[2] = x[5] ^ y[3 + log2(num_channels)] ^ x[6]
			bank |= (((x >> 5) ^ (y >> (3 + channel_bits)) ^ (x >> 6)) & 1) << 2;
		else
			// bank[2] = x[5] ^ y[3 + log2(num_channels)]
			bank |= (((x >> 5) ^ (y >> (3 + channel_bits))) & 1) << 2;
		break;
	}

	tile_bytes = tile_width * tile_height * tile_thickness * element_bytes * num_samples;
	macro_tile_bytes = macro_tile_width * macro_tile_height * tile_bytes;
	macro_tiles_per_row = pitch_elements / macro_tile_width;
	macro_tiles_per_slice = macro_tiles_per_row * (height / macro_tile_height);
	slice_offset = (z / tile_thickness) * macro_tiles_per_slice * macro_tile_bytes;
	macro_tile_row_index = (y / tile_height) / macro_tile_height;
	macro_tile_column_index = (x / tile_width) / macro_tile_width;
	macro_tile_offset = ((macro_tile_row_index * macro_tiles_per_row) + macro_tile_column_index) * macro_tile_bytes;

	if (is_depth) {
		GLint pixel_offset = 0;

		pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
		pixel_number |= ((y >> 0) & 1) << 1; // pn[1] = y[0]
		pixel_number |= ((x >> 1) & 1) << 2; // pn[2] = x[1]
		pixel_number |= ((y >> 1) & 1) << 3; // pn[3] = y[1]
		pixel_number |= ((x >> 2) & 1) << 4; // pn[4] = x[2]
		pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
		switch (element_bytes) {
		case 2:
			pixel_offset = pixel_number * element_bytes * num_samples;
			break;
		case 4:
			/* stencil and depth data are stored separately within a tile.
			 * stencil is stored in a contiguous tile before the depth tile.
			 * stencil element is 1 byte, depth element is 3 bytes.
			 * stencil tile is 64 bytes.
			 */
			if (is_stencil)
				pixel_offset = pixel_number * 1 * num_samples;
			else
				pixel_offset = (pixel_number * 3 * num_samples) + 64;
			break;
		}
		element_offset = pixel_offset + (sample_number * element_bytes);
	} else {
		GLint sample_offset;

		switch (element_bytes) {
		case 1:
			pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
			pixel_number |= ((x >> 1) & 1) << 1; // pn[1] = x[1]
			pixel_number |= ((x >> 2) & 1) << 2; // pn[2] = x[2]
			pixel_number |= ((y >> 1) & 1) << 3; // pn[3] = y[1]
			pixel_number |= ((y >> 0) & 1) << 4; // pn[4] = y[0]
			pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
			break;
		case 2:
			pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
			pixel_number |= ((x >> 1) & 1) << 1; // pn[1] = x[1]
			pixel_number |= ((x >> 2) & 1) << 2; // pn[2] = x[2]
			pixel_number |= ((y >> 0) & 1) << 3; // pn[3] = y[0]
			pixel_number |= ((y >> 1) & 1) << 4; // pn[4] = y[1]
			pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
			break;
		case 4:
			pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
			pixel_number |= ((x >> 1) & 1) << 1; // pn[1] = x[1]
			pixel_number |= ((y >> 0) & 1) << 2; // pn[2] = y[0]
			pixel_number |= ((x >> 2) & 1) << 3; // pn[3] = x[2]
			pixel_number |= ((y >> 1) & 1) << 4; // pn[4] = y[1]
			pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
			break;
		}
		sample_offset = sample_number * (tile_bytes / num_samples);
		element_offset = sample_offset + (pixel_number * element_bytes);
	}
	total_offset = (slice_offset + macro_tile_offset) >> (channel_bits + bank_bits);
	total_offset += element_offset;

	offset_low = total_offset & group_mask;
	offset_high = (total_offset & ~group_mask) << (channel_bits + bank_bits);
	offset = (bank << (group_bits + channel_bits)) + (channel << group_bits) + offset_low + offset_high;
d83 2
a84 1
	return offset;
d87 2
a88 3
/* depth buffers */
static GLubyte *r600_ptr_depth(const struct radeon_renderbuffer * rrb,
			       GLint x, GLint y)
d90 1
a90 8
    GLubyte *ptr = rrb->bo->ptr;
    GLint offset;
    if (rrb->bo->flags & RADEON_BO_FLAGS_MACRO_TILE)
	    offset = r600_2d_tile_helper(rrb, x, y, 1, 0);
    else
	    offset = r600_1d_tile_helper(rrb, x, y, 1, 0);
    return &ptr[offset];
}
d92 3
a94 11
static GLubyte *r600_ptr_stencil(const struct radeon_renderbuffer * rrb,
				 GLint x, GLint y)
{
    GLubyte *ptr = rrb->bo->ptr;
    GLint offset;
    if (rrb->bo->flags & RADEON_BO_FLAGS_MACRO_TILE)
	    offset = r600_2d_tile_helper(rrb, x, y, 1, 1);
    else
	    offset = r600_1d_tile_helper(rrb, x, y, 1, 1);
    return &ptr[offset];
}
d96 3
a98 17
static GLubyte *r600_ptr_color(const struct radeon_renderbuffer * rrb,
			       GLint x, GLint y)
{
    GLubyte *ptr = rrb->bo->ptr;
    uint32_t mask = RADEON_BO_FLAGS_MACRO_TILE | RADEON_BO_FLAGS_MICRO_TILE;
    GLint offset;

    if (rrb->has_surface || !(rrb->bo->flags & mask)) {
        offset = x * rrb->cpp + y * rrb->pitch;
    } else {
	    if (rrb->bo->flags & RADEON_BO_FLAGS_MACRO_TILE)
		    offset = r600_2d_tile_helper(rrb, x, y, 0, 0);
	    else
		    offset = r600_1d_tile_helper(rrb, x, y, 0, 0);
    }
    return &ptr[offset];
}
d100 1
a100 616
#else

/* radeon tiling on r300-r500 has 4 states,
   macro-linear/micro-linear
   macro-linear/micro-tiled
   macro-tiled /micro-linear
   macro-tiled /micro-tiled
   1 byte surface 
   2 byte surface - two types - we only provide 8x2 microtiling
   4 byte surface
   8/16 byte (unused)
*/
static GLubyte *radeon_ptr_4byte(const struct radeon_renderbuffer * rrb,
			     GLint x, GLint y)
{
    GLubyte *ptr = rrb->bo->ptr + rrb->draw_offset;
    uint32_t mask = RADEON_BO_FLAGS_MACRO_TILE | RADEON_BO_FLAGS_MICRO_TILE;
    GLint offset;

    if (rrb->has_surface || !(rrb->bo->flags & mask)) {
        offset = x * rrb->cpp + y * rrb->pitch;
    } else {
        offset = 0;
        if (rrb->bo->flags & RADEON_BO_FLAGS_MACRO_TILE) {
	    if (rrb->bo->flags & RADEON_BO_FLAGS_MICRO_TILE) {
		offset = ((y >> 4) * (rrb->pitch >> 7) + (x >> 5)) << 11;
		offset += (((y >> 3) ^ (x >> 5)) & 0x1) << 10;
		offset += (((y >> 4) ^ (x >> 4)) & 0x1) << 9;
		offset += (((y >> 2) ^ (x >> 4)) & 0x1) << 8;
		offset += (((y >> 3) ^ (x >> 3)) & 0x1) << 7;
		offset += ((y >> 1) & 0x1) << 6;
		offset += ((x >> 2) & 0x1) << 5;
		offset += (y & 1) << 4;
		offset += (x & 3) << 2;
            } else {
		offset = ((y >> 3) * (rrb->pitch >> 8) + (x >> 6)) << 11;
		offset += (((y >> 2) ^ (x >> 6)) & 0x1) << 10;
		offset += (((y >> 3) ^ (x >> 5)) & 0x1) << 9;
		offset += (((y >> 1) ^ (x >> 5)) & 0x1) << 8;
		offset += (((y >> 2) ^ (x >> 4)) & 0x1) << 7;
		offset += (y & 1) << 6;
		offset += (x & 15) << 2;
            }
        } else {
	    offset = ((y >> 1) * (rrb->pitch >> 4) + (x >> 2)) << 5;
	    offset += (y & 1) << 4;
	    offset += (x & 3) << 2;
        }
    }
    return &ptr[offset];
}

static GLubyte *radeon_ptr_2byte_8x2(const struct radeon_renderbuffer * rrb,
				     GLint x, GLint y)
{
    GLubyte *ptr = rrb->bo->ptr + rrb->draw_offset;
    uint32_t mask = RADEON_BO_FLAGS_MACRO_TILE | RADEON_BO_FLAGS_MICRO_TILE;
    GLint offset;

    if (rrb->has_surface || !(rrb->bo->flags & mask)) {
        offset = x * rrb->cpp + y * rrb->pitch;
    } else {
        offset = 0;
        if (rrb->bo->flags & RADEON_BO_FLAGS_MACRO_TILE) {
            if (rrb->bo->flags & RADEON_BO_FLAGS_MICRO_TILE) {
		offset = ((y >> 4) * (rrb->pitch >> 7) + (x >> 6)) << 11;
		offset += (((y >> 3) ^ (x >> 6)) & 0x1) << 10;
		offset += (((y >> 4) ^ (x >> 5)) & 0x1) << 9;
		offset += (((y >> 2) ^ (x >> 5)) & 0x1) << 8;
		offset += (((y >> 3) ^ (x >> 4)) & 0x1) << 7;
		offset += ((y >> 1) & 0x1) << 6;
		offset += ((x >> 3) & 0x1) << 5;
		offset += (y & 1) << 4;
		offset += (x & 3) << 2;
            } else {
		offset = ((y >> 3) * (rrb->pitch >> 8) + (x >> 7)) << 11;
		offset += (((y >> 2) ^ (x >> 7)) & 0x1) << 10;
		offset += (((y >> 3) ^ (x >> 6)) & 0x1) << 9;
		offset += (((y >> 1) ^ (x >> 6)) & 0x1) << 8;
		offset += (((y >> 2) ^ (x >> 5)) & 0x1) << 7;
		offset += (y & 1) << 6;
		offset += ((x >> 4) & 0x1) << 5;
                offset += (x & 15) << 2;
            }
        } else {
	    offset = ((y >> 1) * (rrb->pitch >> 4) + (x >> 3)) << 5;
	    offset += (y & 0x1) << 4;
	    offset += (x & 0x7) << 1;
        }
    }
    return &ptr[offset];
}

#endif

/*
 * Note that all information needed to access pixels in a renderbuffer
 * should be obtained through the gl_renderbuffer parameter, not per-context
 * information.
 */
#define LOCAL_VARS						\
   struct radeon_context *radeon = RADEON_CONTEXT(ctx);			\
   struct radeon_renderbuffer *rrb = (void *) rb;		\
   const GLint yScale = ctx->DrawBuffer->Name ? 1 : -1;			\
   const GLint yBias = ctx->DrawBuffer->Name ? 0 : rrb->base.Height - 1;\
   unsigned int num_cliprects;						\
   struct drm_clip_rect *cliprects;					\
   int x_off, y_off;							\
   GLuint p;						\
   (void)p;						\
   radeon_get_cliprects(radeon, &cliprects, &num_cliprects, &x_off, &y_off);

#define LOCAL_DEPTH_VARS				\
   struct radeon_context *radeon = RADEON_CONTEXT(ctx);			\
   struct radeon_renderbuffer *rrb = (void *) rb;	\
   const GLint yScale = ctx->DrawBuffer->Name ? 1 : -1;			\
   const GLint yBias = ctx->DrawBuffer->Name ? 0 : rrb->base.Height - 1;\
   unsigned int num_cliprects;						\
   struct drm_clip_rect *cliprects;					\
   int x_off, y_off;							\
  radeon_get_cliprects(radeon, &cliprects, &num_cliprects, &x_off, &y_off);

#define LOCAL_STENCIL_VARS LOCAL_DEPTH_VARS

#define Y_FLIP(_y) ((_y) * yScale + yBias)

#define HW_LOCK()

#define HW_UNLOCK()

/* XXX FBO: this is identical to the macro in spantmp2.h except we get
 * the cliprect info from the context, not the driDrawable.
 * Move this into spantmp2.h someday.
 */
#define HW_CLIPLOOP()							\
   do {									\
      int _nc = num_cliprects;						\
      while ( _nc-- ) {							\
	 int minx = cliprects[_nc].x1 - x_off;				\
	 int miny = cliprects[_nc].y1 - y_off;				\
	 int maxx = cliprects[_nc].x2 - x_off;				\
	 int maxy = cliprects[_nc].y2 - y_off;

/* ================================================================
 * Color buffer
 */

/* 16 bit, RGB565 color spanline and pixel functions
 */
#define SPANTMP_PIXEL_FMT GL_RGB
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_5_6_5

#define TAG(x)    radeon##x##_RGB565
#define TAG2(x,y) radeon##x##_RGB565##y
#if defined(RADEON_R600)
#define GET_VALUE(_x, _y) (LE16_TO_CPU(*(GLushort*)(r600_ptr_color(rrb, _x + x_off, _y + y_off))))
#define PUT_VALUE(_x, _y, d) { \
   GLushort *_ptr = (GLushort*)r600_ptr_color( rrb, _x + x_off, _y + y_off );		\
   *_ptr = CPU_TO_LE16(d);								\
} while (0)
#else
#define GET_PTR(X,Y) radeon_ptr_2byte_8x2(rrb, (X) + x_off, (Y) + y_off)
#endif
#include "spantmp2.h"

#define SPANTMP_PIXEL_FMT GL_RGB
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_5_6_5_REV

#define TAG(x)    radeon##x##_RGB565_REV
#define TAG2(x,y) radeon##x##_RGB565_REV##y
#if defined(RADEON_R600)
#define GET_VALUE(_x, _y) (LE16_TO_CPU(*(GLushort*)(r600_ptr_color(rrb, _x + x_off, _y + y_off))))
#define PUT_VALUE(_x, _y, d) { \
   GLushort *_ptr = (GLushort*)r600_ptr_color( rrb, _x + x_off, _y + y_off );		\
   *_ptr = CPU_TO_LE16(d);								\
} while (0)
#else
#define GET_PTR(X,Y) radeon_ptr_2byte_8x2(rrb, (X) + x_off, (Y) + y_off)
#endif
#include "spantmp2.h"

/* 16 bit, ARGB1555 color spanline and pixel functions
 */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_1_5_5_5_REV

#define TAG(x)    radeon##x##_ARGB1555
#define TAG2(x,y) radeon##x##_ARGB1555##y
#if defined(RADEON_R600)
#define GET_VALUE(_x, _y) (LE16_TO_CPU(*(GLushort*)(r600_ptr_color(rrb, _x + x_off, _y + y_off))))
#define PUT_VALUE(_x, _y, d) { \
   GLushort *_ptr = (GLushort*)r600_ptr_color( rrb, _x + x_off, _y + y_off );		\
   *_ptr = CPU_TO_LE16(d);								\
} while (0)
#else
#define GET_PTR(X,Y) radeon_ptr_2byte_8x2(rrb, (X) + x_off, (Y) + y_off)
#endif
#include "spantmp2.h"

#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_1_5_5_5

#define TAG(x)    radeon##x##_ARGB1555_REV
#define TAG2(x,y) radeon##x##_ARGB1555_REV##y
#if defined(RADEON_R600)
#define GET_VALUE(_x, _y) (LE16_TO_CPU(*(GLushort*)(r600_ptr_color(rrb, _x + x_off, _y + y_off))))
#define PUT_VALUE(_x, _y, d) { \
   GLushort *_ptr = (GLushort*)r600_ptr_color( rrb, _x + x_off, _y + y_off );		\
   *_ptr = CPU_TO_LE16(d);								\
} while (0)
#else
#define GET_PTR(X,Y) radeon_ptr_2byte_8x2(rrb, (X) + x_off, (Y) + y_off)
#endif
#include "spantmp2.h"

/* 16 bit, RGBA4 color spanline and pixel functions
 */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_4_4_4_4_REV

#define TAG(x)    radeon##x##_ARGB4444
#define TAG2(x,y) radeon##x##_ARGB4444##y
#if defined(RADEON_R600)
#define GET_VALUE(_x, _y) (LE16_TO_CPU(*(GLushort*)(r600_ptr_color(rrb, _x + x_off, _y + y_off))))
#define PUT_VALUE(_x, _y, d) { \
   GLushort *_ptr = (GLushort*)r600_ptr_color( rrb, _x + x_off, _y + y_off );		\
   *_ptr = CPU_TO_LE16(d);								\
} while (0)
#else
#define GET_PTR(X,Y) radeon_ptr_2byte_8x2(rrb, (X) + x_off, (Y) + y_off)
#endif
#include "spantmp2.h"

#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_4_4_4_4

#define TAG(x)    radeon##x##_ARGB4444_REV
#define TAG2(x,y) radeon##x##_ARGB4444_REV##y
#if defined(RADEON_R600)
#define GET_VALUE(_x, _y) (LE16_TO_CPU(*(GLushort*)(r600_ptr_color(rrb, _x + x_off, _y + y_off))))
#define PUT_VALUE(_x, _y, d) { \
   GLushort *_ptr = (GLushort*)r600_ptr_color( rrb, _x + x_off, _y + y_off );		\
   *_ptr = CPU_TO_LE16(d);								\
} while (0)
#else
#define GET_PTR(X,Y) radeon_ptr_2byte_8x2(rrb, (X) + x_off, (Y) + y_off)
#endif
#include "spantmp2.h"

/* 32 bit, xRGB8888 color spanline and pixel functions
 */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV

#define TAG(x)    radeon##x##_xRGB8888
#define TAG2(x,y) radeon##x##_xRGB8888##y
#if defined(RADEON_R600)
#define GET_VALUE(_x, _y) ((LE32_TO_CPU(*(GLuint*)(r600_ptr_color(rrb, _x + x_off, _y + y_off))) | 0xff000000))
#define PUT_VALUE(_x, _y, d) { \
   GLuint *_ptr = (GLuint*)r600_ptr_color( rrb, _x + x_off, _y + y_off );		\
   *_ptr = CPU_TO_LE32(d);								\
} while (0)
#else
#define GET_VALUE(_x, _y) ((*(GLuint*)(radeon_ptr_4byte(rrb, _x + x_off, _y + y_off)) | 0xff000000))
#define PUT_VALUE(_x, _y, d) { \
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );		\
   *_ptr = d;								\
} while (0)
#endif
#include "spantmp2.h"

/* 32 bit, ARGB8888 color spanline and pixel functions
 */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV

#define TAG(x)    radeon##x##_ARGB8888
#define TAG2(x,y) radeon##x##_ARGB8888##y
#if defined(RADEON_R600)
#define GET_VALUE(_x, _y) (LE32_TO_CPU(*(GLuint*)(r600_ptr_color(rrb, _x + x_off, _y + y_off))))
#define PUT_VALUE(_x, _y, d) { \
   GLuint *_ptr = (GLuint*)r600_ptr_color( rrb, _x + x_off, _y + y_off );		\
   *_ptr = CPU_TO_LE32(d);								\
} while (0)
#else
#define GET_VALUE(_x, _y) (*(GLuint*)(radeon_ptr_4byte(rrb, _x + x_off, _y + y_off)))
#define PUT_VALUE(_x, _y, d) { \
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );		\
   *_ptr = d;								\
} while (0)
#endif
#include "spantmp2.h"

/* 32 bit, BGRx8888 color spanline and pixel functions
 */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8

#define TAG(x)    radeon##x##_BGRx8888
#define TAG2(x,y) radeon##x##_BGRx8888##y
#if defined(RADEON_R600)
#define GET_VALUE(_x, _y) ((LE32_TO_CPU(*(GLuint*)(r600_ptr_color(rrb, _x + x_off, _y + y_off))) | 0x000000ff))
#define PUT_VALUE(_x, _y, d) { \
   GLuint *_ptr = (GLuint*)r600_ptr_color( rrb, _x + x_off, _y + y_off );		\
   *_ptr = CPU_TO_LE32(d);								\
} while (0)
#else
#define GET_VALUE(_x, _y) ((*(GLuint*)(radeon_ptr_4byte(rrb, _x + x_off, _y + y_off)) | 0x000000ff))
#define PUT_VALUE(_x, _y, d) { \
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );		\
   *_ptr = d;								\
} while (0)
#endif
#include "spantmp2.h"

/* 32 bit, BGRA8888 color spanline and pixel functions
 */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8

#define TAG(x)    radeon##x##_BGRA8888
#define TAG2(x,y) radeon##x##_BGRA8888##y
#if defined(RADEON_R600)
#define GET_VALUE(_x, _y) (LE32_TO_CPU(*(GLuint*)(r600_ptr_color(rrb, _x + x_off, _y + y_off))))
#define PUT_VALUE(_x, _y, d) { \
   GLuint *_ptr = (GLuint*)r600_ptr_color( rrb, _x + x_off, _y + y_off );		\
   *_ptr = CPU_TO_LE32(d);								\
} while (0)
#else
#define GET_PTR(X,Y) radeon_ptr_4byte(rrb, (X) + x_off, (Y) + y_off)
#endif
#include "spantmp2.h"

/* ================================================================
 * Depth buffer
 */

/* The Radeon family has depth tiling on all the time, so we have to convert
 * the x,y coordinates into the memory bus address (mba) in the same
 * manner as the engine.  In each case, the linear block address (ba)
 * is calculated, and then wired with x and y to produce the final
 * memory address.
 * The chip will do address translation on its own if the surface registers
 * are set up correctly. It is not quite enough to get it working with hyperz
 * too...
 */

/* 16-bit depth buffer functions
 */
#define VALUE_TYPE GLushort

#if defined(RADEON_R200)
#define WRITE_DEPTH( _x, _y, d )					\
   *(GLushort *)r200_depth_2byte(rrb, _x + x_off, _y + y_off) = d
#elif defined(RADEON_R600)
#define WRITE_DEPTH( _x, _y, d )					\
   *(GLushort *)r600_ptr_depth(rrb, _x + x_off, _y + y_off) = CPU_TO_LE16(d)
#else
#define WRITE_DEPTH( _x, _y, d )					\
   *(GLushort *)radeon_ptr_2byte_8x2(rrb, _x + x_off, _y + y_off) = d
#endif

#if defined(RADEON_R200)
#define READ_DEPTH( d, _x, _y )						\
   d = *(GLushort *)r200_depth_2byte(rrb, _x + x_off, _y + y_off)
#elif defined(RADEON_R600)
#define READ_DEPTH( d, _x, _y )						\
   d = LE16_TO_CPU(*(GLushort *)r600_ptr_depth(rrb, _x + x_off, _y + y_off))
#else
#define READ_DEPTH( d, _x, _y )						\
   d = *(GLushort *)radeon_ptr_2byte_8x2(rrb, _x + x_off, _y + y_off)
#endif

#define TAG(x) radeon##x##_z16
#include "depthtmp.h"

/* 24 bit depth
 *
 * Careful: It looks like the R300 uses ZZZS byte order while the R200
 * uses SZZZ for 24 bit depth, 8 bit stencil mode.
 */
#define VALUE_TYPE GLuint

#if defined(RADEON_R300)
#define WRITE_DEPTH( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   tmp &= 0x000000ff;							\
   tmp |= ((d << 8) & 0xffffff00);					\
   *_ptr = CPU_TO_LE32(tmp);                                            \
} while (0)
#elif defined(RADEON_R600)
#define WRITE_DEPTH( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)r600_ptr_depth( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = LE32_TO_CPU(*_ptr);				\
   tmp &= 0xff000000;							\
   tmp |= ((d) & 0x00ffffff);					\
   *_ptr = CPU_TO_LE32(tmp);					\
} while (0)
#elif defined(RADEON_R200)
#define WRITE_DEPTH( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)r200_depth_4byte( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   tmp &= 0xff000000;							\
   tmp |= ((d) & 0x00ffffff);						\
   *_ptr = CPU_TO_LE32(tmp);                                            \
} while (0)
#else
#define WRITE_DEPTH( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );	\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   tmp &= 0xff000000;							\
   tmp |= ((d) & 0x00ffffff);						\
   *_ptr = CPU_TO_LE32(tmp);                                            \
} while (0)
#endif

#if defined(RADEON_R300)
#define READ_DEPTH( d, _x, _y )						\
  do {									\
    d = (LE32_TO_CPU(*(GLuint*)(radeon_ptr_4byte(rrb, _x + x_off, _y + y_off))) & 0xffffff00) >> 8; \
  }while(0)
#elif defined(RADEON_R600)
#define READ_DEPTH( d, _x, _y )						\
  do {									\
    d = (LE32_TO_CPU(*(GLuint*)(r600_ptr_depth(rrb, _x + x_off, _y + y_off))) & 0x00ffffff); \
  }while(0)
#elif defined(RADEON_R200)
#define READ_DEPTH( d, _x, _y )						\
  do {									\
    d = LE32_TO_CPU(*(GLuint*)(r200_depth_4byte(rrb, _x + x_off, _y + y_off))) & 0x00ffffff; \
  }while(0)
#else
#define READ_DEPTH( d, _x, _y )	\
  d = LE32_TO_CPU(*(GLuint*)(radeon_ptr_4byte(rrb, _x + x_off,	_y + y_off))) & 0x00ffffff;
#endif

#define TAG(x) radeon##x##_z24
#include "depthtmp.h"

/* 24 bit depth, 8 bit stencil depthbuffer functions
 * EXT_depth_stencil
 *
 * Careful: It looks like the R300 uses ZZZS byte order while the R200
 * uses SZZZ for 24 bit depth, 8 bit stencil mode.
 */
#define VALUE_TYPE GLuint

#if defined(RADEON_R300)
#define WRITE_DEPTH( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );		\
   *_ptr = CPU_TO_LE32((((d) & 0xff000000) >> 24) | (((d) & 0x00ffffff) << 8));   \
} while (0)
#elif defined(RADEON_R600)
#define WRITE_DEPTH( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)r600_ptr_depth( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = LE32_TO_CPU(*_ptr);				\
   tmp &= 0xff000000;							\
   tmp |= ((d) & 0x00ffffff);					\
   *_ptr = CPU_TO_LE32(tmp);					\
   _ptr = (GLuint*)r600_ptr_stencil(rrb, _x + x_off, _y + y_off);		\
   tmp = LE32_TO_CPU(*_ptr);				\
   tmp &= 0xffffff00;							\
   tmp |= ((d) >> 24) & 0xff;						\
   *_ptr = CPU_TO_LE32(tmp);					\
} while (0)
#elif defined(RADEON_R200)
#define WRITE_DEPTH( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)r200_depth_4byte( rrb, _x + x_off, _y + y_off );		\
   *_ptr = CPU_TO_LE32(d);						\
} while (0)
#else
#define WRITE_DEPTH( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );	\
   *_ptr = CPU_TO_LE32(d);						\
} while (0)
#endif

#if defined(RADEON_R300)
#define READ_DEPTH( d, _x, _y )						\
  do { \
    GLuint tmp = (*(GLuint*)(radeon_ptr_4byte(rrb, _x + x_off, _y + y_off)));	\
    d = LE32_TO_CPU(((tmp & 0x000000ff) << 24) | ((tmp & 0xffffff00) >> 8));	\
  }while(0)
#elif defined(RADEON_R600)
#define READ_DEPTH( d, _x, _y )						\
  do { \
    d = (LE32_TO_CPU(*(GLuint*)(r600_ptr_depth(rrb, _x + x_off, _y + y_off))) & 0x00ffffff); \
    d |= ((LE32_TO_CPU(*(GLuint*)(r600_ptr_stencil(rrb, _x + x_off, _y + y_off))) << 24) & 0xff000000); \
  }while(0)
#elif defined(RADEON_R200)
#define READ_DEPTH( d, _x, _y )						\
  do { \
    d = LE32_TO_CPU(*(GLuint*)(r200_depth_4byte(rrb, _x + x_off, _y + y_off))); \
  }while(0)
#else
#define READ_DEPTH( d, _x, _y )	do {					\
    d = LE32_TO_CPU(*(GLuint*)(radeon_ptr_4byte(rrb, _x + x_off, _y + y_off))); \
  } while (0)
#endif

#define TAG(x) radeon##x##_s8_z24
#include "depthtmp.h"

/* ================================================================
 * Stencil buffer
 */

/* 24 bit depth, 8 bit stencil depthbuffer functions
 */
#ifdef RADEON_R300
#define WRITE_STENCIL( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte(rrb, _x + x_off, _y + y_off);		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   tmp &= 0xffffff00;							\
   tmp |= (d) & 0xff;							\
   *_ptr = CPU_TO_LE32(tmp);                                            \
} while (0)
#elif defined(RADEON_R600)
#define WRITE_STENCIL( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)r600_ptr_stencil(rrb, _x + x_off, _y + y_off);		\
   GLuint tmp = LE32_TO_CPU(*_ptr);				\
   tmp &= 0xffffff00;							\
   tmp |= (d) & 0xff;							\
   *_ptr = CPU_TO_LE32(tmp);					\
} while (0)
#elif defined(RADEON_R200)
#define WRITE_STENCIL( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)r200_depth_4byte(rrb, _x + x_off, _y + y_off);		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   tmp &= 0x00ffffff;							\
   tmp |= (((d) & 0xff) << 24);						\
   *_ptr = CPU_TO_LE32(tmp);                                            \
} while (0)
#else
#define WRITE_STENCIL( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte(rrb, _x + x_off, _y + y_off);		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   tmp &= 0x00ffffff;							\
   tmp |= (((d) & 0xff) << 24);						\
   *_ptr = CPU_TO_LE32(tmp);                                            \
} while (0)
#endif

#ifdef RADEON_R300
#define READ_STENCIL( d, _x, _y )					\
do {									\
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   d = tmp & 0x000000ff;						\
} while (0)
#elif defined(RADEON_R600)
#define READ_STENCIL( d, _x, _y )					\
do {									\
   GLuint *_ptr = (GLuint*)r600_ptr_stencil( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = LE32_TO_CPU(*_ptr);				\
   d = tmp & 0x000000ff;						\
} while (0)
#elif defined(RADEON_R200)
#define READ_STENCIL( d, _x, _y )					\
do {									\
   GLuint *_ptr = (GLuint*)r200_depth_4byte( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   d = (tmp & 0xff000000) >> 24;					\
} while (0)
#else
#define READ_STENCIL( d, _x, _y )					\
do {									\
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   d = (tmp & 0xff000000) >> 24;					\
} while (0)
#endif

#define TAG(x) radeon##x##_s8_z24
#include "stenciltmp.h"


static void map_unmap_rb(struct gl_renderbuffer *rb, int flag)
{
	struct radeon_renderbuffer *rrb = radeon_renderbuffer(rb);
	int r;

	if (rrb == NULL || !rrb->bo)
		return;

	radeon_print(RADEON_MEMORY, RADEON_TRACE,
		"%s( rb %p, flag %s )\n",
		__func__, rb, flag ? "true":"false");

	if (flag) {
	        radeon_bo_wait(rrb->bo);
		r = radeon_bo_map(rrb->bo, 1);
		if (r) {
			fprintf(stderr, "(%s) error(%d) mapping buffer.\n",
				__FUNCTION__, r);
		}

		radeonSetSpanFunctions(rrb);
	} else {
		radeon_bo_unmap(rrb->bo);
		rb->GetRow = NULL;
		rb->PutRow = NULL;
	}
d104 1
a104 2
radeon_map_unmap_framebuffer(struct gl_context *ctx, struct gl_framebuffer *fb,
			     GLboolean map)
d106 1
a106 1
	GLuint i, j;
d109 2
a110 8
		"%s( %p , fb %p, map %s )\n",
		__func__, ctx, fb, map ? "true":"false");

	/* color draw buffers */
	for (j = 0; j < ctx->DrawBuffer->_NumColorDrawBuffers; j++)
		map_unmap_rb(fb->_ColorDrawBuffers[j], map);

	map_unmap_rb(fb->_ColorReadBuffer, map);
d113 2
a114 25
	for (i = 0; i < BUFFER_COUNT; i++) {
		struct gl_renderbuffer_attachment *att =
			fb->Attachment + i;
		struct gl_texture_object *tex = att->Texture;
		if (tex) {
			/* Render to texture. Note that a mipmapped texture need not
			 * be complete for render to texture, so we must restrict to
			 * mapping only the attached image.
			 */
			radeon_texture_image *image = get_radeon_texture_image(tex->Image[att->CubeMapFace][att->TextureLevel]);
			ASSERT(att->Renderbuffer);

			if (map)
				radeon_teximage_map(image, GL_TRUE);
			else
				radeon_teximage_unmap(image);
		}
	}
	
	/* depth buffer (Note wrapper!) */
	if (fb->_DepthBuffer)
		map_unmap_rb(fb->_DepthBuffer->Wrapped, map);

	if (fb->_StencilBuffer)
		map_unmap_rb(fb->_StencilBuffer->Wrapped, map);
a121 1
	int i;
d125 1
a125 14
	/* The locking and wait for idle should really only be needed in classic mode.
	 * In a future memory manager based implementation, this should become
	 * unnecessary due to the fact that mapping our buffers, textures, etc.
	 * should implicitly wait for any previous rendering commands that must
	 * be waited on. */
	if (!rmesa->radeonScreen->driScreen->dri2.enabled) {
		LOCK_HARDWARE(rmesa);
		radeonWaitForIdleLocked(rmesa);
	}

	for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
		if (ctx->Texture.Unit[i]._ReallyEnabled)
			ctx->Driver.MapTexture(ctx, ctx->Texture.Unit[i]._Current);
	}
d127 1
a127 1
	radeon_map_unmap_framebuffer(ctx, ctx->DrawBuffer, GL_TRUE);
d129 1
a129 1
		radeon_map_unmap_framebuffer(ctx, ctx->ReadBuffer, GL_TRUE);
a133 3
	radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
	int i;

d135 1
d137 1
a137 6
	for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
		if (ctx->Texture.Unit[i]._ReallyEnabled)
			ctx->Driver.UnmapTexture(ctx, ctx->Texture.Unit[i]._Current);
	}

	radeon_map_unmap_framebuffer(ctx, ctx->DrawBuffer, GL_FALSE);
d139 1
a139 5
		radeon_map_unmap_framebuffer(ctx, ctx->ReadBuffer, GL_FALSE);

	if (!rmesa->radeonScreen->driScreen->dri2.enabled) {
		UNLOCK_HARDWARE(rmesa);
	}
a149 37
/**
 * Plug in the Get/Put routines for the given driRenderbuffer.
 */
static void radeonSetSpanFunctions(struct radeon_renderbuffer *rrb)
{
	if (rrb->base.Format == MESA_FORMAT_RGB565) {
		radeonInitPointers_RGB565(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_RGB565_REV) {
		radeonInitPointers_RGB565_REV(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_XRGB8888) {
		radeonInitPointers_xRGB8888(&rrb->base);
        } else if (rrb->base.Format == MESA_FORMAT_XRGB8888_REV) {
		radeonInitPointers_BGRx8888(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_ARGB8888) {
		radeonInitPointers_ARGB8888(&rrb->base);
        } else if (rrb->base.Format == MESA_FORMAT_ARGB8888_REV) {
		radeonInitPointers_BGRA8888(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_ARGB4444) {
		radeonInitPointers_ARGB4444(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_ARGB4444_REV) {
		radeonInitPointers_ARGB4444_REV(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_ARGB1555) {
		radeonInitPointers_ARGB1555(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_ARGB1555_REV) {
		radeonInitPointers_ARGB1555_REV(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_Z16) {
		radeonInitDepthPointers_z16(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_X8_Z24) {
		radeonInitDepthPointers_z24(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_S8_Z24) {
		radeonInitDepthPointers_s8_z24(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_S8) {
		radeonInitStencilPointers_s8_z24(&rrb->base);
	} else {
		fprintf(stderr, "radeonSetSpanFunctions: bad format: 0x%04X\n", rrb->base.Format);
	}
}
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d53 11
d593 5
a597 1
#define GET_PTR(X,Y) r600_ptr_color(rrb, (X) + x_off, (Y) + y_off)
d609 5
a613 1
#define GET_PTR(X,Y) r600_ptr_color(rrb, (X) + x_off, (Y) + y_off)
d627 5
a631 1
#define GET_PTR(X,Y) r600_ptr_color(rrb, (X) + x_off, (Y) + y_off)
d643 5
a647 1
#define GET_PTR(X,Y) r600_ptr_color(rrb, (X) + x_off, (Y) + y_off)
d661 5
a665 1
#define GET_PTR(X,Y) r600_ptr_color(rrb, (X) + x_off, (Y) + y_off)
d677 5
a681 1
#define GET_PTR(X,Y) r600_ptr_color(rrb, (X) + x_off, (Y) + y_off)
d695 1
a695 1
#define GET_VALUE(_x, _y) ((*(GLuint*)(r600_ptr_color(rrb, _x + x_off, _y + y_off)) | 0xff000000))
d698 1
a698 1
   *_ptr = d;								\
d717 1
a717 1
#define GET_VALUE(_x, _y) (*(GLuint*)(r600_ptr_color(rrb, _x + x_off, _y + y_off)))
d720 1
a720 1
   *_ptr = d;								\
d739 1
a739 1
#define GET_VALUE(_x, _y) ((*(GLuint*)(r600_ptr_color(rrb, _x + x_off, _y + y_off)) | 0x000000ff))
d742 1
a742 1
   *_ptr = d;								\
d761 5
a765 1
#define GET_PTR(X,Y) r600_ptr_color(rrb, (X) + x_off, (Y) + y_off)
d794 1
a794 1
   *(GLushort *)r600_ptr_depth(rrb, _x + x_off, _y + y_off) = d
d805 1
a805 1
   d = *(GLushort *)r600_ptr_depth(rrb, _x + x_off, _y + y_off)
d834 1
a834 1
   GLuint tmp = *_ptr;				\
d837 1
a837 1
   *_ptr = tmp;					\
d867 1
a867 1
    d = (*(GLuint*)(r600_ptr_depth(rrb, _x + x_off, _y + y_off)) & 0x00ffffff); \
d900 1
a900 1
   GLuint tmp = *_ptr;				\
d903 1
a903 1
   *_ptr = tmp;					\
d905 1
a905 1
   tmp = *_ptr;				\
d908 1
a908 1
   *_ptr = tmp;					\
d933 2
a934 2
    d = (*(GLuint*)(r600_ptr_depth(rrb, _x + x_off, _y + y_off))) & 0x00ffffff; \
    d |= ((*(GLuint*)(r600_ptr_stencil(rrb, _x + x_off, _y + y_off))) << 24) & 0xff000000; \
d969 1
a969 1
   GLuint tmp = *_ptr;				\
d972 1
a972 1
   *_ptr = tmp;					\
d1005 1
a1005 1
   GLuint tmp = *_ptr;				\
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d63 1
a63 1
    GLubyte *ptr = rrb->bo->ptr;
d88 1
a88 1
    GLubyte *ptr = rrb->bo->ptr;
a113 1
 * only 1D tiling is implemented below
d210 174
d389 5
a393 1
    GLint offset = r600_1d_tile_helper(rrb, x, y, 1, 0);
d401 5
a405 1
    GLint offset = r600_1d_tile_helper(rrb, x, y, 1, 1);
d419 4
a422 1
	    offset = r600_1d_tile_helper(rrb, x, y, 0, 0);
d442 1
a442 1
    GLubyte *ptr = rrb->bo->ptr;
d482 1
a482 1
    GLubyte *ptr = rrb->bo->ptr;
d1018 1
a1018 1
radeon_map_unmap_framebuffer(GLcontext *ctx, struct gl_framebuffer *fb,
d1063 1
a1063 1
static void radeonSpanRenderStart(GLcontext * ctx)
d1090 1
a1090 1
static void radeonSpanRenderFinish(GLcontext * ctx)
d1111 1
a1111 1
void radeonInitSpanFuncs(GLcontext * ctx)
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d44 1
d47 2
a48 3
#include "radeon_context.h"
#include "radeon_ioctl.h"
#include "radeon_state.h"
a49 1
#include "radeon_tex.h"
d51 33
a83 1
#include "drirenderbuffer.h"
d85 252
a336 1
#define DBG 0
d344 10
a353 7
   driRenderbuffer *drb = (driRenderbuffer *) rb;		\
   const __DRIdrawablePrivate *dPriv = drb->dPriv;		\
   const GLuint bottom = dPriv->h - 1;				\
   GLubyte *buf = (GLubyte *) drb->flippedData			\
      + (dPriv->y * drb->flippedPitch + dPriv->x) * drb->cpp;	\
   GLuint p;							\
   (void) p;
d356 8
a363 6
   driRenderbuffer *drb = (driRenderbuffer *) rb;	\
   const __DRIdrawablePrivate *dPriv = drb->dPriv;	\
   const GLuint bottom = dPriv->h - 1;			\
   GLuint xo = dPriv->x;				\
   GLuint yo = dPriv->y;				\
   GLubyte *buf = (GLubyte *) drb->Base.Data;
d367 1
a367 1
#define Y_FLIP(Y) (bottom - (Y))
d373 13
d397 91
a487 1
#define GET_PTR(X,Y) (buf + ((Y) * drb->flippedPitch + (X)) * 2)
d497 49
a545 1
#define GET_PTR(X,Y) (buf + ((Y) * drb->flippedPitch + (X)) * 4)
d562 3
a564 7
static GLuint radeon_mba_z32(const driRenderbuffer * drb, GLint x, GLint y)
{
	GLuint pitch = drb->pitch;
	if (drb->depthHasSurface) {
		return 4 * (x + y * pitch);
	} else {
		GLuint ba, address = 0;	/* a[0..1] = 0           */
d566 6
a571 2
#ifdef COMPILE_R300
		ba = (y / 8) * (pitch / 8) + (x / 8);
d573 2
a574 1
		ba = (y / 16) * (pitch / 16) + (x / 16);
d577 10
a586 4
		address |= (x & 0x7) << 2;	/* a[2..4] = x[0..2]     */
		address |= (y & 0x3) << 5;	/* a[5..6] = y[0..1]     */
		address |= (((x & 0x10) >> 2) ^ (y & 0x4)) << 5;	/* a[7]    = x[4] ^ y[2] */
		address |= (ba & 0x3) << 8;	/* a[8..9] = ba[0..1]    */
d588 2
a589 3
		address |= (y & 0x8) << 7;	/* a[10]   = y[3]        */
		address |= (((x & 0x8) << 1) ^ (y & 0x10)) << 7;	/* a[11]   = x[3] ^ y[4] */
		address |= (ba & ~0x3) << 10;	/* a[12..] = ba[2..]     */
d591 4
a594 28
		return address;
	}
}

static INLINE GLuint
radeon_mba_z16(const driRenderbuffer * drb, GLint x, GLint y)
{
	GLuint pitch = drb->pitch;
	if (drb->depthHasSurface) {
		return 2 * (x + y * pitch);
	} else {
		GLuint ba, address = 0;	/* a[0]    = 0           */

		ba = (y / 16) * (pitch / 32) + (x / 32);

		address |= (x & 0x7) << 1;	/* a[1..3] = x[0..2]     */
		address |= (y & 0x7) << 4;	/* a[4..6] = y[0..2]     */
		address |= (x & 0x8) << 4;	/* a[7]    = x[3]        */
		address |= (ba & 0x3) << 8;	/* a[8..9] = ba[0..1]    */
		address |= (y & 0x8) << 7;	/* a[10]   = y[3]        */
		address |= ((x & 0x10) ^ (y & 0x10)) << 7;	/* a[11]   = x[4] ^ y[4] */
		address |= (ba & ~0x3) << 10;	/* a[12..] = ba[2..]     */

		return address;
	}
}

/* 16-bit depth buffer functions
d596 1
a596 1
#define VALUE_TYPE GLushort
d598 1
d600 35
a634 1
   *(GLushort *)(buf + radeon_mba_z16( drb, _x + xo, _y + yo )) = d;
d636 11
d648 7
a654 1
   d = *(GLushort *)(buf + radeon_mba_z16( drb, _x + xo, _y + yo ));
d656 1
a656 1
#define TAG(x) radeon##x##_z16
d660 1
d667 1
a667 1
#ifdef COMPILE_R300
d670 22
a691 5
   GLuint offset = radeon_mba_z32( drb, _x + xo, _y + yo );		\
   GLuint tmp = *(GLuint *)(buf + offset);				\
   tmp &= 0x000000ff;							\
   tmp |= ((d << 8) & 0xffffff00);					\
   *(GLuint *)(buf + offset) = tmp;					\
d696 2
a697 5
   GLuint offset = radeon_mba_z32( drb, _x + xo, _y + yo );		\
   GLuint tmp = *(GLuint *)(buf + offset);				\
   tmp &= 0xff000000;							\
   tmp |= ((d) & 0x00ffffff);						\
   *(GLuint *)(buf + offset) = tmp;					\
d701 13
a713 1
#ifdef COMPILE_R300
d716 1
a716 2
    d = (*(GLuint *)(buf + radeon_mba_z32( drb, _x + xo,		\
					 _y + yo )) & 0xffffff00) >> 8; \
d719 3
a721 3
#define READ_DEPTH( d, _x, _y )						\
   d = *(GLuint *)(buf + radeon_mba_z32( drb, _x + xo,			\
					 _y + yo )) & 0x00ffffff;
d724 1
a724 1
#define TAG(x) radeon##x##_z24_s8
d733 1
a733 1
#ifdef COMPILE_R300
d736 2
a737 2
   GLuint offset = radeon_mba_z32( drb, _x + xo, _y + yo );		\
   GLuint tmp = *(GLuint *)(buf + offset);				\
d740 19
a758 1
   *(GLuint *)(buf + offset) = tmp;					\
d763 2
a764 2
   GLuint offset = radeon_mba_z32( drb, _x + xo, _y + yo );		\
   GLuint tmp = *(GLuint *)(buf + offset);				\
d767 1
a767 1
   *(GLuint *)(buf + offset) = tmp;					\
d771 1
a771 1
#ifdef COMPILE_R300
d774 2
a775 2
   GLuint offset = radeon_mba_z32( drb, _x + xo, _y + yo );		\
   GLuint tmp = *(GLuint *)(buf + offset);				\
d778 14
d795 2
a796 2
   GLuint offset = radeon_mba_z32( drb, _x + xo, _y + yo );		\
   GLuint tmp = *(GLuint *)(buf + offset);				\
d801 1
a801 1
#define TAG(x) radeon##x##_z24_s8
d804 74
a877 4
/* Move locking out to get reasonable span performance (10x better
 * than doing this in HW_LOCK above).  WaitForIdle() is the main
 * culprit.
 */
d882 22
a903 8
#ifdef COMPILE_R300
	r300ContextPtr r300 = (r300ContextPtr) rmesa;
	R300_FIREVERTICES(r300);
#else
	RADEON_FIREVERTICES(rmesa);
#endif
	LOCK_HARDWARE(rmesa);
	radeonWaitForIdleLocked(rmesa);
d909 2
d912 13
a924 1
	UNLOCK_HARDWARE(rmesa);
d938 1
a938 1
void radeonSetSpanFunctions(driRenderbuffer * drb, const GLvisual * vis)
d940 30
a969 13
	if (drb->Base.InternalFormat == GL_RGBA) {
		if (vis->redBits == 5 && vis->greenBits == 6
		    && vis->blueBits == 5) {
			radeonInitPointers_RGB565(&drb->Base);
		} else {
			radeonInitPointers_ARGB8888(&drb->Base);
		}
	} else if (drb->Base.InternalFormat == GL_DEPTH_COMPONENT16) {
		radeonInitDepthPointers_z16(&drb->Base);
	} else if (drb->Base.InternalFormat == GL_DEPTH_COMPONENT24) {
		radeonInitDepthPointers_z24_s8(&drb->Base);
	} else if (drb->Base.InternalFormat == GL_STENCIL_INDEX8_EXT) {
		radeonInitStencilPointers_z24_s8(&drb->Base);
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d43 1
a43 1
#include "glheader.h"
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XFree86: xc/lib/GL/mesa/src/drv/radeon/radeon_span.c,v 1.6 2002/10/30 12:51:56 alanh Exp $ */
d3 1
d7 4
a53 1

a55 1

a85 2


a99 1

a109 1

d124 1
a124 2
static GLuint
radeon_mba_z32( const driRenderbuffer *drb, GLint x, GLint y )
d126 20
a145 19
   GLuint pitch = drb->pitch;
   if (drb->depthHasSurface) {
      return 4 * (x + y * pitch);
   }
   else {
      GLuint ba, address = 0;			/* a[0..1] = 0           */

      ba = (y / 16) * (pitch / 16) + (x / 16);

      address |= (x & 0x7) << 2;		/* a[2..4] = x[0..2]     */
      address |= (y & 0x3) << 5;		/* a[5..6] = y[0..1]     */
      address |=
         (((x & 0x10) >> 2) ^ (y & 0x4)) << 5;	/* a[7]    = x[4] ^ y[2] */
      address |= (ba & 0x3) << 8;		/* a[8..9] = ba[0..1]    */

      address |= (y & 0x8) << 7;		/* a[10]   = y[3]        */
      address |=
         (((x & 0x8) << 1) ^ (y & 0x10)) << 7;	/* a[11]   = x[3] ^ y[4] */
      address |= (ba & ~0x3) << 10;		/* a[12..] = ba[2..]     */
d147 2
a148 2
      return address;
   }
a150 1

d152 1
a152 1
radeon_mba_z16( const driRenderbuffer *drb, GLint x, GLint y )
d154 15
a168 16
   GLuint pitch = drb->pitch;
   if (drb->depthHasSurface) {
      return 2 * (x + y * pitch);
   }
   else {
      GLuint ba, address = 0;			/* a[0]    = 0           */

      ba = (y / 16) * (pitch / 32) + (x / 32);

      address |= (x & 0x7) << 1;		/* a[1..3] = x[0..2]     */
      address |= (y & 0x7) << 4;		/* a[4..6] = y[0..2]     */
      address |= (x & 0x8) << 4;		/* a[7]    = x[3]        */
      address |= (ba & 0x3) << 8;		/* a[8..9] = ba[0..1]    */
      address |= (y & 0x8) << 7;		/* a[10]   = y[3]        */
      address |= ((x & 0x10) ^ (y & 0x10)) << 7;/* a[11]   = x[4] ^ y[4] */
      address |= (ba & ~0x3) << 10;		/* a[12..] = ba[2..]     */
d170 2
a171 2
      return address;
   }
a173 1

d176 2
a186 1

d188 3
d192 12
d212 1
d214 7
d224 1
a228 1

d235 10
d253 1
d255 1
d260 8
a267 2
   tmp &= 0xff000000;							\
   d = tmp >> 24;							\
d269 1
a273 2


d279 1
a279 1
static void radeonSpanRenderStart( GLcontext *ctx )
d281 9
a289 4
   radeonContextPtr rmesa = RADEON_CONTEXT( ctx );
   RADEON_FIREVERTICES( rmesa );
   LOCK_HARDWARE( rmesa );
   radeonWaitForIdleLocked( rmesa );
d292 1
a292 1
static void radeonSpanRenderFinish( GLcontext *ctx )
d294 3
a296 3
   radeonContextPtr rmesa = RADEON_CONTEXT( ctx );
   _swrast_flush( ctx );
   UNLOCK_HARDWARE( rmesa );
d299 1
a299 1
void radeonInitSpanFuncs( GLcontext *ctx )
d301 4
a304 3
   struct swrast_device_driver *swdd = _swrast_GetDeviceDriverReference(ctx);
   swdd->SpanRenderStart          = radeonSpanRenderStart;
   swdd->SpanRenderFinish         = radeonSpanRenderFinish; 
a306 1

d310 1
a310 2
void
radeonSetSpanFunctions(driRenderbuffer *drb, const GLvisual *vis)
d312 14
a325 17
   if (drb->Base.InternalFormat == GL_RGBA) {
      if (vis->redBits == 5 && vis->greenBits == 6 && vis->blueBits == 5) {
         radeonInitPointers_RGB565(&drb->Base);
      }
      else {
         radeonInitPointers_ARGB8888(&drb->Base);
      }
   }
   else if (drb->Base.InternalFormat == GL_DEPTH_COMPONENT16) {
      radeonInitDepthPointers_z16(&drb->Base);
   }
   else if (drb->Base.InternalFormat == GL_DEPTH_COMPONENT24) {
      radeonInitDepthPointers_z24_s8(&drb->Base);
   }
   else if (drb->Base.InternalFormat == GL_STENCIL_INDEX8_EXT) {
      radeonInitStencilPointers_z24_s8(&drb->Base);
   }
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d1 1
a3 1
Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.
a6 4
The Weather Channel (TM) funded Tungsten Graphics to develop the
initial release of the Radeon 8500 driver under the XFree86 license.
This notice must be preserved.

d50 1
d53 1
d84 2
d100 1
d111 1
d126 2
a127 1
static GLuint radeon_mba_z32(const driRenderbuffer * drb, GLint x, GLint y)
d129 19
a147 20
	GLuint pitch = drb->pitch;
	if (drb->depthHasSurface) {
		return 4 * (x + y * pitch);
	} else {
		GLuint ba, address = 0;	/* a[0..1] = 0           */

#ifdef COMPILE_R300
		ba = (y / 8) * (pitch / 8) + (x / 8);
#else
		ba = (y / 16) * (pitch / 16) + (x / 16);
#endif

		address |= (x & 0x7) << 2;	/* a[2..4] = x[0..2]     */
		address |= (y & 0x3) << 5;	/* a[5..6] = y[0..1]     */
		address |= (((x & 0x10) >> 2) ^ (y & 0x4)) << 5;	/* a[7]    = x[4] ^ y[2] */
		address |= (ba & 0x3) << 8;	/* a[8..9] = ba[0..1]    */

		address |= (y & 0x8) << 7;	/* a[10]   = y[3]        */
		address |= (((x & 0x8) << 1) ^ (y & 0x10)) << 7;	/* a[11]   = x[3] ^ y[4] */
		address |= (ba & ~0x3) << 10;	/* a[12..] = ba[2..]     */
d149 2
a150 2
		return address;
	}
d153 1
d155 1
a155 1
radeon_mba_z16(const driRenderbuffer * drb, GLint x, GLint y)
d157 16
a172 15
	GLuint pitch = drb->pitch;
	if (drb->depthHasSurface) {
		return 2 * (x + y * pitch);
	} else {
		GLuint ba, address = 0;	/* a[0]    = 0           */

		ba = (y / 16) * (pitch / 32) + (x / 32);

		address |= (x & 0x7) << 1;	/* a[1..3] = x[0..2]     */
		address |= (y & 0x7) << 4;	/* a[4..6] = y[0..2]     */
		address |= (x & 0x8) << 4;	/* a[7]    = x[3]        */
		address |= (ba & 0x3) << 8;	/* a[8..9] = ba[0..1]    */
		address |= (y & 0x8) << 7;	/* a[10]   = y[3]        */
		address |= ((x & 0x10) ^ (y & 0x10)) << 7;	/* a[11]   = x[4] ^ y[4] */
		address |= (ba & ~0x3) << 10;	/* a[12..] = ba[2..]     */
d174 2
a175 2
		return address;
	}
d178 1
d190 1
a191 3
 *
 * Careful: It looks like the R300 uses ZZZS byte order while the R200
 * uses SZZZ for 24 bit depth, 8 bit stencil mode.
a192 10
#ifdef COMPILE_R300
#define WRITE_DEPTH( _x, _y, d )					\
do {									\
   GLuint offset = radeon_mba_z32( drb, _x + xo, _y + yo );		\
   GLuint tmp = *(GLuint *)(buf + offset);				\
   tmp &= 0x000000ff;							\
   tmp |= ((d << 8) & 0xffffff00);					\
   *(GLuint *)(buf + offset) = tmp;					\
} while (0)
#else
a200 1
#endif
a201 7
#ifdef COMPILE_R300
#define READ_DEPTH( d, _x, _y )						\
  do { \
    d = (*(GLuint *)(buf + radeon_mba_z32( drb, _x + xo,		\
					 _y + yo )) & 0xffffff00) >> 8; \
  }while(0)
#else
a204 1
#endif
d209 1
a215 10
#ifdef COMPILE_R300
#define WRITE_STENCIL( _x, _y, d )					\
do {									\
   GLuint offset = radeon_mba_z32( drb, _x + xo, _y + yo );		\
   GLuint tmp = *(GLuint *)(buf + offset);				\
   tmp &= 0xffffff00;							\
   tmp |= (d) & 0xff;							\
   *(GLuint *)(buf + offset) = tmp;					\
} while (0)
#else
a223 1
#endif
a224 1
#ifdef COMPILE_R300
d229 2
a230 1
   d = tmp & 0x000000ff;						\
a231 8
#else
#define READ_STENCIL( d, _x, _y )					\
do {									\
   GLuint offset = radeon_mba_z32( drb, _x + xo, _y + yo );		\
   GLuint tmp = *(GLuint *)(buf + offset);				\
   d = (tmp & 0xff000000) >> 24;					\
} while (0)
#endif
d236 2
d243 1
a243 1
static void radeonSpanRenderStart(GLcontext * ctx)
d245 4
a248 9
	radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
#ifdef COMPILE_R300
	r300ContextPtr r300 = (r300ContextPtr) rmesa;
	R300_FIREVERTICES(r300);
#else
	RADEON_FIREVERTICES(rmesa);
#endif
	LOCK_HARDWARE(rmesa);
	radeonWaitForIdleLocked(rmesa);
d251 1
a251 1
static void radeonSpanRenderFinish(GLcontext * ctx)
d253 3
a255 3
	radeonContextPtr rmesa = RADEON_CONTEXT(ctx);
	_swrast_flush(ctx);
	UNLOCK_HARDWARE(rmesa);
d258 1
a258 1
void radeonInitSpanFuncs(GLcontext * ctx)
d260 3
a262 4
	struct swrast_device_driver *swdd =
	    _swrast_GetDeviceDriverReference(ctx);
	swdd->SpanRenderStart = radeonSpanRenderStart;
	swdd->SpanRenderFinish = radeonSpanRenderFinish;
d265 1
d269 2
a270 1
void radeonSetSpanFunctions(driRenderbuffer * drb, const GLvisual * vis)
d272 17
a288 14
	if (drb->Base.InternalFormat == GL_RGBA) {
		if (vis->redBits == 5 && vis->greenBits == 6
		    && vis->blueBits == 5) {
			radeonInitPointers_RGB565(&drb->Base);
		} else {
			radeonInitPointers_ARGB8888(&drb->Base);
		}
	} else if (drb->Base.InternalFormat == GL_DEPTH_COMPONENT16) {
		radeonInitDepthPointers_z16(&drb->Base);
	} else if (drb->Base.InternalFormat == GL_DEPTH_COMPONENT24) {
		radeonInitDepthPointers_z24_s8(&drb->Base);
	} else if (drb->Base.InternalFormat == GL_STENCIL_INDEX8_EXT) {
		radeonInitStencilPointers_z24_s8(&drb->Base);
	}
@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d43 1
a43 2
#include "main/glheader.h"
#include "main/texformat.h"
d46 3
a48 2
#include "radeon_common.h"
#include "radeon_lock.h"
d50 3
a55 469
static void radeonSetSpanFunctions(struct radeon_renderbuffer *rrb);


/* r200 depth buffer is always tiled - this is the formula
   according to the docs unless I typo'ed in it
*/
#if defined(RADEON_R200)
static GLubyte *r200_depth_2byte(const struct radeon_renderbuffer * rrb,
				 GLint x, GLint y)
{
    GLubyte *ptr = rrb->bo->ptr + rrb->draw_offset;
    GLint offset;
    if (rrb->has_surface) {
	offset = x * rrb->cpp + y * rrb->pitch;
    } else {
	GLuint b;
	offset = 0;
	b = (((y  >> 4) * (rrb->pitch >> 8) + (x >> 6)));
	offset += (b >> 1) << 12;
	offset += (((rrb->pitch >> 8) & 0x1) ? (b & 0x1) : ((b & 0x1) ^ ((y >> 4) & 0x1))) << 11;
	offset += ((y >> 2) & 0x3) << 9;
	offset += ((x >> 3) & 0x1) << 8;
	offset += ((x >> 4) & 0x3) << 6;
	offset += ((x >> 2) & 0x1) << 5;
	offset += ((y >> 1) & 0x1) << 4;
	offset += ((x >> 1) & 0x1) << 3;
	offset += (y & 0x1) << 2;
	offset += (x & 0x1) << 1;
    }
    return &ptr[offset];
}

static GLubyte *r200_depth_4byte(const struct radeon_renderbuffer * rrb,
				 GLint x, GLint y)
{
    GLubyte *ptr = rrb->bo->ptr + rrb->draw_offset;
    GLint offset;
    if (rrb->has_surface) {
	offset = x * rrb->cpp + y * rrb->pitch;
    } else {
	GLuint b;
	offset = 0;
	b = (((y & 0x7ff) >> 4) * (rrb->pitch >> 7) + (x >> 5));
	offset += (b >> 1) << 12;
	offset += (((rrb->pitch >> 7) & 0x1) ? (b & 0x1) : ((b & 0x1) ^ ((y >> 4) & 0x1))) << 11;
	offset += ((y >> 2) & 0x3) << 9;
	offset += ((x >> 2) & 0x1) << 8;
	offset += ((x >> 3) & 0x3) << 6;
	offset += ((y >> 1) & 0x1) << 5;
	offset += ((x >> 1) & 0x1) << 4;
	offset += (y & 0x1) << 3;
	offset += (x & 0x1) << 2;
    }
    return &ptr[offset];
}
#endif

/* r600 tiling
 * two main types:
 * - 1D (akin to macro-linear/micro-tiled on older asics)
 * - 2D (akin to macro-tiled/micro-tiled on older asics)
 */
#if defined(RADEON_R600)
static inline GLint r600_1d_tile_helper(const struct radeon_renderbuffer * rrb,
					GLint x, GLint y, GLint is_depth, GLint is_stencil)
{
    GLint element_bytes = rrb->cpp;
    GLint num_samples = 1;
    GLint tile_width = 8;
    GLint tile_height = 8;
    GLint tile_thickness = 1;
    GLint pitch_elements = rrb->pitch / element_bytes;
    GLint height = rrb->base.Height;
    GLint z = 0;
    GLint sample_number = 0;
    /* */
    GLint tile_bytes;
    GLint tiles_per_row;
    GLint tiles_per_slice;
    GLint slice_offset;
    GLint tile_row_index;
    GLint tile_column_index;
    GLint tile_offset;
    GLint pixel_number = 0;
    GLint element_offset;
    GLint offset = 0;

    tile_bytes = tile_width * tile_height * tile_thickness * element_bytes * num_samples;
    tiles_per_row = pitch_elements / tile_width;
    tiles_per_slice = tiles_per_row * (height / tile_height);
    slice_offset = (z / tile_thickness) * tiles_per_slice * tile_bytes;
    tile_row_index = y / tile_height;
    tile_column_index = x / tile_width;
    tile_offset = ((tile_row_index * tiles_per_row) + tile_column_index) * tile_bytes;

    if (is_depth) {
	    GLint pixel_offset = 0;

	    pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
	    pixel_number |= ((y >> 0) & 1) << 1; // pn[1] = y[0]
	    pixel_number |= ((x >> 1) & 1) << 2; // pn[2] = x[1]
	    pixel_number |= ((y >> 1) & 1) << 3; // pn[3] = y[1]
	    pixel_number |= ((x >> 2) & 1) << 4; // pn[4] = x[2]
	    pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
	    switch (element_bytes) {
	    case 2:
		    pixel_offset = pixel_number * element_bytes * num_samples;
		    break;
	    case 4:
		    /* stencil and depth data are stored separately within a tile.
		     * stencil is stored in a contiguous tile before the depth tile.
		     * stencil element is 1 byte, depth element is 3 bytes.
		     * stencil tile is 64 bytes.
		     */
		    if (is_stencil)
			    pixel_offset = pixel_number * 1 * num_samples;
		    else
			    pixel_offset = (pixel_number * 3 * num_samples) + 64;
		    break;
	    }
	    element_offset = pixel_offset + (sample_number * element_bytes);
    } else {
	    GLint sample_offset;

	    switch (element_bytes) {
	    case 1:
		    pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
		    pixel_number |= ((x >> 1) & 1) << 1; // pn[1] = x[1]
		    pixel_number |= ((x >> 2) & 1) << 2; // pn[2] = x[2]
		    pixel_number |= ((y >> 1) & 1) << 3; // pn[3] = y[1]
		    pixel_number |= ((y >> 0) & 1) << 4; // pn[4] = y[0]
		    pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
		    break;
	    case 2:
		    pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
		    pixel_number |= ((x >> 1) & 1) << 1; // pn[1] = x[1]
		    pixel_number |= ((x >> 2) & 1) << 2; // pn[2] = x[2]
		    pixel_number |= ((y >> 0) & 1) << 3; // pn[3] = y[0]
		    pixel_number |= ((y >> 1) & 1) << 4; // pn[4] = y[1]
		    pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
		    break;
	    case 4:
		    pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
		    pixel_number |= ((x >> 1) & 1) << 1; // pn[1] = x[1]
		    pixel_number |= ((y >> 0) & 1) << 2; // pn[2] = y[0]
		    pixel_number |= ((x >> 2) & 1) << 3; // pn[3] = x[2]
		    pixel_number |= ((y >> 1) & 1) << 4; // pn[4] = y[1]
		    pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
		    break;
	    }
	    sample_offset = sample_number * (tile_bytes / num_samples);
	    element_offset = sample_offset + (pixel_number * element_bytes);
    }
    offset = slice_offset + tile_offset + element_offset;
    return offset;
}

static inline GLint r600_log2(GLint n)
{
	GLint log2 = 0;

	while (n >>= 1)
		++log2;
	return log2;
}

static inline GLint r600_2d_tile_helper(const struct radeon_renderbuffer * rrb,
					GLint x, GLint y, GLint is_depth, GLint is_stencil)
{
	GLint group_bytes = rrb->group_bytes;
	GLint num_channels = rrb->num_channels;
	GLint num_banks = rrb->num_banks;
	GLint r7xx_bank_op = rrb->r7xx_bank_op;
	/* */
	GLint group_bits = r600_log2(group_bytes);
	GLint channel_bits = r600_log2(num_channels);
	GLint bank_bits = r600_log2(num_banks);
	GLint element_bytes = rrb->cpp;
	GLint num_samples = 1;
	GLint tile_width = 8;
	GLint tile_height = 8;
	GLint tile_thickness = 1;
	GLint macro_tile_width = num_banks;
	GLint macro_tile_height = num_channels;
	GLint pitch_elements = (rrb->pitch / element_bytes) / tile_width;
	GLint height = rrb->base.Height / tile_height;
	GLint z = 0;
	GLint sample_number = 0;
	/* */
	GLint tile_bytes;
	GLint macro_tile_bytes;
	GLint macro_tiles_per_row;
	GLint macro_tiles_per_slice;
	GLint slice_offset;
	GLint macro_tile_row_index;
	GLint macro_tile_column_index;
	GLint macro_tile_offset;
	GLint pixel_number = 0;
	GLint element_offset;
	GLint bank = 0;
	GLint channel = 0;
	GLint total_offset;
	GLint group_mask = (1 << group_bits) - 1;
	GLint offset_low;
	GLint offset_high;
	GLint offset = 0;

	switch (num_channels) {
	case 2:
	default:
		// channel[0] = x[3] ^ y[3]
		channel |= (((x >> 3) ^ (y >> 3)) & 1) << 0;
		break;
	case 4:
		// channel[0] = x[4] ^ y[3]
		channel |= (((x >> 4) ^ (y >> 3)) & 1) << 0;
		// channel[1] = x[3] ^ y[4]
		channel |= (((x >> 3) ^ (y >> 4)) & 1) << 1;
		break;
	case 8:
		// channel[0] = x[5] ^ y[3]
		channel |= (((x >> 5) ^ (y >> 3)) & 1) << 0;
		// channel[0] = x[4] ^ x[5] ^ y[4]
		channel |= (((x >> 4) ^ (x >> 5) ^ (y >> 4)) & 1) << 1;
		// channel[0] = x[3] ^ y[5]
		channel |= (((x >> 3) ^ (y >> 5)) & 1) << 2;
		break;
	}

	switch (num_banks) {
	case 4:
		// bank[0] = x[3] ^ y[4 + log2(num_channels)]
		bank |= (((x >> 3) ^ (y >> (4 + channel_bits))) & 1) << 0;
		if (r7xx_bank_op)
			// bank[1] = x[3] ^ y[4 + log2(num_channels)] ^ x[5]
			bank |= (((x >> 4) ^ (y >> (3 + channel_bits)) ^ (x >> 5)) & 1) << 1;
		else
			// bank[1] = x[4] ^ y[3 + log2(num_channels)]
			bank |= (((x >> 4) ^ (y >> (3 + channel_bits))) & 1) << 1;
		break;
	case 8:
		// bank[0] = x[3] ^ y[5 + log2(num_channels)]
		bank |= (((x >> 3) ^ (y >> (5 + channel_bits))) & 1) << 0;
		// bank[1] = x[4] ^ y[4 + log2(num_channels)] ^ y[5 + log2(num_channels)]
		bank |= (((x >> 4) ^ (y >> (4 + channel_bits)) ^ (y >> (5 + channel_bits))) & 1) << 1;
		if (r7xx_bank_op)
			// bank[2] = x[5] ^ y[3 + log2(num_channels)] ^ x[6]
			bank |= (((x >> 5) ^ (y >> (3 + channel_bits)) ^ (x >> 6)) & 1) << 2;
		else
			// bank[2] = x[5] ^ y[3 + log2(num_channels)]
			bank |= (((x >> 5) ^ (y >> (3 + channel_bits))) & 1) << 2;
		break;
	}

	tile_bytes = tile_width * tile_height * tile_thickness * element_bytes * num_samples;
	macro_tile_bytes = macro_tile_width * macro_tile_height * tile_bytes;
	macro_tiles_per_row = pitch_elements / macro_tile_width;
	macro_tiles_per_slice = macro_tiles_per_row * (height / macro_tile_height);
	slice_offset = (z / tile_thickness) * macro_tiles_per_slice * macro_tile_bytes;
	macro_tile_row_index = (y / tile_height) / macro_tile_height;
	macro_tile_column_index = (x / tile_width) / macro_tile_width;
	macro_tile_offset = ((macro_tile_row_index * macro_tiles_per_row) + macro_tile_column_index) * macro_tile_bytes;

	if (is_depth) {
		GLint pixel_offset = 0;

		pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
		pixel_number |= ((y >> 0) & 1) << 1; // pn[1] = y[0]
		pixel_number |= ((x >> 1) & 1) << 2; // pn[2] = x[1]
		pixel_number |= ((y >> 1) & 1) << 3; // pn[3] = y[1]
		pixel_number |= ((x >> 2) & 1) << 4; // pn[4] = x[2]
		pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
		switch (element_bytes) {
		case 2:
			pixel_offset = pixel_number * element_bytes * num_samples;
			break;
		case 4:
			/* stencil and depth data are stored separately within a tile.
			 * stencil is stored in a contiguous tile before the depth tile.
			 * stencil element is 1 byte, depth element is 3 bytes.
			 * stencil tile is 64 bytes.
			 */
			if (is_stencil)
				pixel_offset = pixel_number * 1 * num_samples;
			else
				pixel_offset = (pixel_number * 3 * num_samples) + 64;
			break;
		}
		element_offset = pixel_offset + (sample_number * element_bytes);
	} else {
		GLint sample_offset;

		switch (element_bytes) {
		case 1:
			pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
			pixel_number |= ((x >> 1) & 1) << 1; // pn[1] = x[1]
			pixel_number |= ((x >> 2) & 1) << 2; // pn[2] = x[2]
			pixel_number |= ((y >> 1) & 1) << 3; // pn[3] = y[1]
			pixel_number |= ((y >> 0) & 1) << 4; // pn[4] = y[0]
			pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
			break;
		case 2:
			pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
			pixel_number |= ((x >> 1) & 1) << 1; // pn[1] = x[1]
			pixel_number |= ((x >> 2) & 1) << 2; // pn[2] = x[2]
			pixel_number |= ((y >> 0) & 1) << 3; // pn[3] = y[0]
			pixel_number |= ((y >> 1) & 1) << 4; // pn[4] = y[1]
			pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
			break;
		case 4:
			pixel_number |= ((x >> 0) & 1) << 0; // pn[0] = x[0]
			pixel_number |= ((x >> 1) & 1) << 1; // pn[1] = x[1]
			pixel_number |= ((y >> 0) & 1) << 2; // pn[2] = y[0]
			pixel_number |= ((x >> 2) & 1) << 3; // pn[3] = x[2]
			pixel_number |= ((y >> 1) & 1) << 4; // pn[4] = y[1]
			pixel_number |= ((y >> 2) & 1) << 5; // pn[5] = y[2]
			break;
		}
		sample_offset = sample_number * (tile_bytes / num_samples);
		element_offset = sample_offset + (pixel_number * element_bytes);
	}
	total_offset = (slice_offset + macro_tile_offset) >> (channel_bits + bank_bits);
	total_offset += element_offset;

	offset_low = total_offset & group_mask;
	offset_high = (total_offset & ~group_mask) << (channel_bits + bank_bits);
	offset = (bank << (group_bits + channel_bits)) + (channel << group_bits) + offset_low + offset_high;

	return offset;
}

/* depth buffers */
static GLubyte *r600_ptr_depth(const struct radeon_renderbuffer * rrb,
			       GLint x, GLint y)
{
    GLubyte *ptr = rrb->bo->ptr;
    GLint offset;
    if (rrb->bo->flags & RADEON_BO_FLAGS_MACRO_TILE)
	    offset = r600_2d_tile_helper(rrb, x, y, 1, 0);
    else
	    offset = r600_1d_tile_helper(rrb, x, y, 1, 0);
    return &ptr[offset];
}

static GLubyte *r600_ptr_stencil(const struct radeon_renderbuffer * rrb,
				 GLint x, GLint y)
{
    GLubyte *ptr = rrb->bo->ptr;
    GLint offset;
    if (rrb->bo->flags & RADEON_BO_FLAGS_MACRO_TILE)
	    offset = r600_2d_tile_helper(rrb, x, y, 1, 1);
    else
	    offset = r600_1d_tile_helper(rrb, x, y, 1, 1);
    return &ptr[offset];
}

static GLubyte *r600_ptr_color(const struct radeon_renderbuffer * rrb,
			       GLint x, GLint y)
{
    GLubyte *ptr = rrb->bo->ptr;
    uint32_t mask = RADEON_BO_FLAGS_MACRO_TILE | RADEON_BO_FLAGS_MICRO_TILE;
    GLint offset;

    if (rrb->has_surface || !(rrb->bo->flags & mask)) {
        offset = x * rrb->cpp + y * rrb->pitch;
    } else {
	    if (rrb->bo->flags & RADEON_BO_FLAGS_MACRO_TILE)
		    offset = r600_2d_tile_helper(rrb, x, y, 0, 0);
	    else
		    offset = r600_1d_tile_helper(rrb, x, y, 0, 0);
    }
    return &ptr[offset];
}

#else

/* radeon tiling on r300-r500 has 4 states,
   macro-linear/micro-linear
   macro-linear/micro-tiled
   macro-tiled /micro-linear
   macro-tiled /micro-tiled
   1 byte surface 
   2 byte surface - two types - we only provide 8x2 microtiling
   4 byte surface
   8/16 byte (unused)
*/
static GLubyte *radeon_ptr_4byte(const struct radeon_renderbuffer * rrb,
			     GLint x, GLint y)
{
    GLubyte *ptr = rrb->bo->ptr + rrb->draw_offset;
    uint32_t mask = RADEON_BO_FLAGS_MACRO_TILE | RADEON_BO_FLAGS_MICRO_TILE;
    GLint offset;

    if (rrb->has_surface || !(rrb->bo->flags & mask)) {
        offset = x * rrb->cpp + y * rrb->pitch;
    } else {
        offset = 0;
        if (rrb->bo->flags & RADEON_BO_FLAGS_MACRO_TILE) {
	    if (rrb->bo->flags & RADEON_BO_FLAGS_MICRO_TILE) {
		offset = ((y >> 4) * (rrb->pitch >> 7) + (x >> 5)) << 11;
		offset += (((y >> 3) ^ (x >> 5)) & 0x1) << 10;
		offset += (((y >> 4) ^ (x >> 4)) & 0x1) << 9;
		offset += (((y >> 2) ^ (x >> 4)) & 0x1) << 8;
		offset += (((y >> 3) ^ (x >> 3)) & 0x1) << 7;
		offset += ((y >> 1) & 0x1) << 6;
		offset += ((x >> 2) & 0x1) << 5;
		offset += (y & 1) << 4;
		offset += (x & 3) << 2;
            } else {
		offset = ((y >> 3) * (rrb->pitch >> 8) + (x >> 6)) << 11;
		offset += (((y >> 2) ^ (x >> 6)) & 0x1) << 10;
		offset += (((y >> 3) ^ (x >> 5)) & 0x1) << 9;
		offset += (((y >> 1) ^ (x >> 5)) & 0x1) << 8;
		offset += (((y >> 2) ^ (x >> 4)) & 0x1) << 7;
		offset += (y & 1) << 6;
		offset += (x & 15) << 2;
            }
        } else {
	    offset = ((y >> 1) * (rrb->pitch >> 4) + (x >> 2)) << 5;
	    offset += (y & 1) << 4;
	    offset += (x & 3) << 2;
        }
    }
    return &ptr[offset];
}

static GLubyte *radeon_ptr_2byte_8x2(const struct radeon_renderbuffer * rrb,
				     GLint x, GLint y)
{
    GLubyte *ptr = rrb->bo->ptr + rrb->draw_offset;
    uint32_t mask = RADEON_BO_FLAGS_MACRO_TILE | RADEON_BO_FLAGS_MICRO_TILE;
    GLint offset;

    if (rrb->has_surface || !(rrb->bo->flags & mask)) {
        offset = x * rrb->cpp + y * rrb->pitch;
    } else {
        offset = 0;
        if (rrb->bo->flags & RADEON_BO_FLAGS_MACRO_TILE) {
            if (rrb->bo->flags & RADEON_BO_FLAGS_MICRO_TILE) {
		offset = ((y >> 4) * (rrb->pitch >> 7) + (x >> 6)) << 11;
		offset += (((y >> 3) ^ (x >> 6)) & 0x1) << 10;
		offset += (((y >> 4) ^ (x >> 5)) & 0x1) << 9;
		offset += (((y >> 2) ^ (x >> 5)) & 0x1) << 8;
		offset += (((y >> 3) ^ (x >> 4)) & 0x1) << 7;
		offset += ((y >> 1) & 0x1) << 6;
		offset += ((x >> 3) & 0x1) << 5;
		offset += (y & 1) << 4;
		offset += (x & 3) << 2;
            } else {
		offset = ((y >> 3) * (rrb->pitch >> 8) + (x >> 7)) << 11;
		offset += (((y >> 2) ^ (x >> 7)) & 0x1) << 10;
		offset += (((y >> 3) ^ (x >> 6)) & 0x1) << 9;
		offset += (((y >> 1) ^ (x >> 6)) & 0x1) << 8;
		offset += (((y >> 2) ^ (x >> 5)) & 0x1) << 7;
		offset += (y & 1) << 6;
		offset += ((x >> 4) & 0x1) << 5;
                offset += (x & 15) << 2;
            }
        } else {
	    offset = ((y >> 1) * (rrb->pitch >> 4) + (x >> 3)) << 5;
	    offset += (y & 0x1) << 4;
	    offset += (x & 0x7) << 1;
        }
    }
    return &ptr[offset];
}

#endif

d62 7
a68 10
   struct radeon_context *radeon = RADEON_CONTEXT(ctx);			\
   struct radeon_renderbuffer *rrb = (void *) rb;		\
   const GLint yScale = ctx->DrawBuffer->Name ? 1 : -1;			\
   const GLint yBias = ctx->DrawBuffer->Name ? 0 : rrb->base.Height - 1;\
   unsigned int num_cliprects;						\
   struct drm_clip_rect *cliprects;					\
   int x_off, y_off;							\
   GLuint p;						\
   (void)p;						\
   radeon_get_cliprects(radeon, &cliprects, &num_cliprects, &x_off, &y_off);
d71 6
a76 8
   struct radeon_context *radeon = RADEON_CONTEXT(ctx);			\
   struct radeon_renderbuffer *rrb = (void *) rb;	\
   const GLint yScale = ctx->DrawBuffer->Name ? 1 : -1;			\
   const GLint yBias = ctx->DrawBuffer->Name ? 0 : rrb->base.Height - 1;\
   unsigned int num_cliprects;						\
   struct drm_clip_rect *cliprects;					\
   int x_off, y_off;							\
  radeon_get_cliprects(radeon, &cliprects, &num_cliprects, &x_off, &y_off);
d80 1
a80 1
#define Y_FLIP(_y) ((_y) * yScale + yBias)
a85 13
/* XXX FBO: this is identical to the macro in spantmp2.h except we get
 * the cliprect info from the context, not the driDrawable.
 * Move this into spantmp2.h someday.
 */
#define HW_CLIPLOOP()							\
   do {									\
      int _nc = num_cliprects;						\
      while ( _nc-- ) {							\
	 int minx = cliprects[_nc].x1 - x_off;				\
	 int miny = cliprects[_nc].y1 - y_off;				\
	 int maxx = cliprects[_nc].x2 - x_off;				\
	 int maxy = cliprects[_nc].y2 - y_off;

d97 1
a97 91
#if defined(RADEON_R600)
#define GET_PTR(X,Y) r600_ptr_color(rrb, (X) + x_off, (Y) + y_off)
#else
#define GET_PTR(X,Y) radeon_ptr_2byte_8x2(rrb, (X) + x_off, (Y) + y_off)
#endif
#include "spantmp2.h"

#define SPANTMP_PIXEL_FMT GL_RGB
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_5_6_5_REV

#define TAG(x)    radeon##x##_RGB565_REV
#define TAG2(x,y) radeon##x##_RGB565_REV##y
#if defined(RADEON_R600)
#define GET_PTR(X,Y) r600_ptr_color(rrb, (X) + x_off, (Y) + y_off)
#else
#define GET_PTR(X,Y) radeon_ptr_2byte_8x2(rrb, (X) + x_off, (Y) + y_off)
#endif
#include "spantmp2.h"

/* 16 bit, ARGB1555 color spanline and pixel functions
 */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_1_5_5_5_REV

#define TAG(x)    radeon##x##_ARGB1555
#define TAG2(x,y) radeon##x##_ARGB1555##y
#if defined(RADEON_R600)
#define GET_PTR(X,Y) r600_ptr_color(rrb, (X) + x_off, (Y) + y_off)
#else
#define GET_PTR(X,Y) radeon_ptr_2byte_8x2(rrb, (X) + x_off, (Y) + y_off)
#endif
#include "spantmp2.h"

#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_1_5_5_5

#define TAG(x)    radeon##x##_ARGB1555_REV
#define TAG2(x,y) radeon##x##_ARGB1555_REV##y
#if defined(RADEON_R600)
#define GET_PTR(X,Y) r600_ptr_color(rrb, (X) + x_off, (Y) + y_off)
#else
#define GET_PTR(X,Y) radeon_ptr_2byte_8x2(rrb, (X) + x_off, (Y) + y_off)
#endif
#include "spantmp2.h"

/* 16 bit, RGBA4 color spanline and pixel functions
 */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_4_4_4_4_REV

#define TAG(x)    radeon##x##_ARGB4444
#define TAG2(x,y) radeon##x##_ARGB4444##y
#if defined(RADEON_R600)
#define GET_PTR(X,Y) r600_ptr_color(rrb, (X) + x_off, (Y) + y_off)
#else
#define GET_PTR(X,Y) radeon_ptr_2byte_8x2(rrb, (X) + x_off, (Y) + y_off)
#endif
#include "spantmp2.h"

#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_SHORT_4_4_4_4

#define TAG(x)    radeon##x##_ARGB4444_REV
#define TAG2(x,y) radeon##x##_ARGB4444_REV##y
#if defined(RADEON_R600)
#define GET_PTR(X,Y) r600_ptr_color(rrb, (X) + x_off, (Y) + y_off)
#else
#define GET_PTR(X,Y) radeon_ptr_2byte_8x2(rrb, (X) + x_off, (Y) + y_off)
#endif
#include "spantmp2.h"

/* 32 bit, xRGB8888 color spanline and pixel functions
 */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8_REV

#define TAG(x)    radeon##x##_xRGB8888
#define TAG2(x,y) radeon##x##_xRGB8888##y
#if defined(RADEON_R600)
#define GET_VALUE(_x, _y) ((*(GLuint*)(r600_ptr_color(rrb, _x + x_off, _y + y_off)) | 0xff000000))
#define PUT_VALUE(_x, _y, d) { \
   GLuint *_ptr = (GLuint*)r600_ptr_color( rrb, _x + x_off, _y + y_off );		\
   *_ptr = d;								\
} while (0)
#else
#define GET_VALUE(_x, _y) ((*(GLuint*)(radeon_ptr_4byte(rrb, _x + x_off, _y + y_off)) | 0xff000000))
#define PUT_VALUE(_x, _y, d) { \
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );		\
   *_ptr = d;								\
} while (0)
#endif
d107 1
a107 49
#if defined(RADEON_R600)
#define GET_VALUE(_x, _y) (*(GLuint*)(r600_ptr_color(rrb, _x + x_off, _y + y_off)))
#define PUT_VALUE(_x, _y, d) { \
   GLuint *_ptr = (GLuint*)r600_ptr_color( rrb, _x + x_off, _y + y_off );		\
   *_ptr = d;								\
} while (0)
#else
#define GET_VALUE(_x, _y) (*(GLuint*)(radeon_ptr_4byte(rrb, _x + x_off, _y + y_off)))
#define PUT_VALUE(_x, _y, d) { \
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );		\
   *_ptr = d;								\
} while (0)
#endif
#include "spantmp2.h"

/* 32 bit, BGRx8888 color spanline and pixel functions
 */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8

#define TAG(x)    radeon##x##_BGRx8888
#define TAG2(x,y) radeon##x##_BGRx8888##y
#if defined(RADEON_R600)
#define GET_VALUE(_x, _y) ((*(GLuint*)(r600_ptr_color(rrb, _x + x_off, _y + y_off)) | 0x000000ff))
#define PUT_VALUE(_x, _y, d) { \
   GLuint *_ptr = (GLuint*)r600_ptr_color( rrb, _x + x_off, _y + y_off );		\
   *_ptr = d;								\
} while (0)
#else
#define GET_VALUE(_x, _y) ((*(GLuint*)(radeon_ptr_4byte(rrb, _x + x_off, _y + y_off)) | 0x000000ff))
#define PUT_VALUE(_x, _y, d) { \
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );		\
   *_ptr = d;								\
} while (0)
#endif
#include "spantmp2.h"

/* 32 bit, BGRA8888 color spanline and pixel functions
 */
#define SPANTMP_PIXEL_FMT GL_BGRA
#define SPANTMP_PIXEL_TYPE GL_UNSIGNED_INT_8_8_8_8

#define TAG(x)    radeon##x##_BGRA8888
#define TAG2(x,y) radeon##x##_BGRA8888##y
#if defined(RADEON_R600)
#define GET_PTR(X,Y) r600_ptr_color(rrb, (X) + x_off, (Y) + y_off)
#else
#define GET_PTR(X,Y) radeon_ptr_4byte(rrb, (X) + x_off, (Y) + y_off)
#endif
d124 7
a130 3
/* 16-bit depth buffer functions
 */
#define VALUE_TYPE GLushort
d132 2
a133 6
#if defined(RADEON_R200)
#define WRITE_DEPTH( _x, _y, d )					\
   *(GLushort *)r200_depth_2byte(rrb, _x + x_off, _y + y_off) = d
#elif defined(RADEON_R600)
#define WRITE_DEPTH( _x, _y, d )					\
   *(GLushort *)r600_ptr_depth(rrb, _x + x_off, _y + y_off) = d
d135 1
a135 2
#define WRITE_DEPTH( _x, _y, d )					\
   *(GLushort *)radeon_ptr_2byte_8x2(rrb, _x + x_off, _y + y_off) = d
d138 31
a168 10
#if defined(RADEON_R200)
#define READ_DEPTH( d, _x, _y )						\
   d = *(GLushort *)r200_depth_2byte(rrb, _x + x_off, _y + y_off)
#elif defined(RADEON_R600)
#define READ_DEPTH( d, _x, _y )						\
   d = *(GLushort *)r600_ptr_depth(rrb, _x + x_off, _y + y_off)
#else
#define READ_DEPTH( d, _x, _y )						\
   d = *(GLushort *)radeon_ptr_2byte_8x2(rrb, _x + x_off, _y + y_off)
#endif
d170 3
a172 2
#define TAG(x) radeon##x##_z16
#include "depthtmp.h"
d174 1
a174 4
/* 24 bit depth
 *
 * Careful: It looks like the R300 uses ZZZS byte order while the R200
 * uses SZZZ for 24 bit depth, 8 bit stencil mode.
a175 30
#define VALUE_TYPE GLuint

#if defined(RADEON_R300)
#define WRITE_DEPTH( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   tmp &= 0x000000ff;							\
   tmp |= ((d << 8) & 0xffffff00);					\
   *_ptr = CPU_TO_LE32(tmp);                                            \
} while (0)
#elif defined(RADEON_R600)
#define WRITE_DEPTH( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)r600_ptr_depth( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = *_ptr;				\
   tmp &= 0xff000000;							\
   tmp |= ((d) & 0x00ffffff);					\
   *_ptr = tmp;					\
} while (0)
#elif defined(RADEON_R200)
#define WRITE_DEPTH( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)r200_depth_4byte( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   tmp &= 0xff000000;							\
   tmp |= ((d) & 0x00ffffff);						\
   *_ptr = CPU_TO_LE32(tmp);                                            \
} while (0)
#else
d177 1
a177 8
do {									\
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );	\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   tmp &= 0xff000000;							\
   tmp |= ((d) & 0x00ffffff);						\
   *_ptr = CPU_TO_LE32(tmp);                                            \
} while (0)
#endif
a178 11
#if defined(RADEON_R300)
#define READ_DEPTH( d, _x, _y )						\
  do {									\
    d = (LE32_TO_CPU(*(GLuint*)(radeon_ptr_4byte(rrb, _x + x_off, _y + y_off))) & 0xffffff00) >> 8; \
  }while(0)
#elif defined(RADEON_R600)
#define READ_DEPTH( d, _x, _y )						\
  do {									\
    d = (*(GLuint*)(r600_ptr_depth(rrb, _x + x_off, _y + y_off)) & 0x00ffffff); \
  }while(0)
#elif defined(RADEON_R200)
d180 1
a180 7
  do {									\
    d = LE32_TO_CPU(*(GLuint*)(r200_depth_4byte(rrb, _x + x_off, _y + y_off))) & 0x00ffffff; \
  }while(0)
#else
#define READ_DEPTH( d, _x, _y )	\
  d = LE32_TO_CPU(*(GLuint*)(radeon_ptr_4byte(rrb, _x + x_off,	_y + y_off))) & 0x00ffffff;
#endif
d182 1
a182 1
#define TAG(x) radeon##x##_z24
a185 1
 * EXT_depth_stencil
d190 1
a190 3
#define VALUE_TYPE GLuint

#if defined(RADEON_R300)
d193 5
a197 2
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );		\
   *_ptr = CPU_TO_LE32((((d) & 0xff000000) >> 24) | (((d) & 0x00ffffff) << 8));   \
d199 1
a199 1
#elif defined(RADEON_R600)
d202 2
a203 2
   GLuint *_ptr = (GLuint*)r600_ptr_depth( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = *_ptr;				\
d205 2
a206 19
   tmp |= ((d) & 0x00ffffff);					\
   *_ptr = tmp;					\
   _ptr = (GLuint*)r600_ptr_stencil(rrb, _x + x_off, _y + y_off);		\
   tmp = *_ptr;				\
   tmp &= 0xffffff00;							\
   tmp |= ((d) >> 24) & 0xff;						\
   *_ptr = tmp;					\
} while (0)
#elif defined(RADEON_R200)
#define WRITE_DEPTH( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)r200_depth_4byte( rrb, _x + x_off, _y + y_off );		\
   *_ptr = CPU_TO_LE32(d);						\
} while (0)
#else
#define WRITE_DEPTH( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );	\
   *_ptr = CPU_TO_LE32(d);						\
d210 1
a210 1
#if defined(RADEON_R300)
d213 2
a214 2
    GLuint tmp = (*(GLuint*)(radeon_ptr_4byte(rrb, _x + x_off, _y + y_off)));	\
    d = LE32_TO_CPU(((tmp & 0x000000ff) << 24) | ((tmp & 0xffffff00) >> 8));	\
d216 1
a216 7
#elif defined(RADEON_R600)
#define READ_DEPTH( d, _x, _y )						\
  do { \
    d = (*(GLuint*)(r600_ptr_depth(rrb, _x + x_off, _y + y_off))) & 0x00ffffff; \
    d |= ((*(GLuint*)(r600_ptr_stencil(rrb, _x + x_off, _y + y_off))) << 24) & 0xff000000; \
  }while(0)
#elif defined(RADEON_R200)
d218 2
a219 7
  do { \
    d = LE32_TO_CPU(*(GLuint*)(r200_depth_4byte(rrb, _x + x_off, _y + y_off))); \
  }while(0)
#else
#define READ_DEPTH( d, _x, _y )	do {					\
    d = LE32_TO_CPU(*(GLuint*)(radeon_ptr_4byte(rrb, _x + x_off, _y + y_off))); \
  } while (0)
d222 1
a222 1
#define TAG(x) radeon##x##_s8_z24
d231 1
a231 10
#ifdef RADEON_R300
#define WRITE_STENCIL( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte(rrb, _x + x_off, _y + y_off);		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   tmp &= 0xffffff00;							\
   tmp |= (d) & 0xff;							\
   *_ptr = CPU_TO_LE32(tmp);                                            \
} while (0)
#elif defined(RADEON_R600)
d234 2
a235 2
   GLuint *_ptr = (GLuint*)r600_ptr_stencil(rrb, _x + x_off, _y + y_off);		\
   GLuint tmp = *_ptr;				\
d238 1
a238 10
   *_ptr = tmp;					\
} while (0)
#elif defined(RADEON_R200)
#define WRITE_STENCIL( _x, _y, d )					\
do {									\
   GLuint *_ptr = (GLuint*)r200_depth_4byte(rrb, _x + x_off, _y + y_off);		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   tmp &= 0x00ffffff;							\
   tmp |= (((d) & 0xff) << 24);						\
   *_ptr = CPU_TO_LE32(tmp);                                            \
d243 2
a244 2
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte(rrb, _x + x_off, _y + y_off);		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
d247 1
a247 1
   *_ptr = CPU_TO_LE32(tmp);                                            \
d251 1
a251 8
#ifdef RADEON_R300
#define READ_STENCIL( d, _x, _y )					\
do {									\
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   d = tmp & 0x000000ff;						\
} while (0)
#elif defined(RADEON_R600)
d254 2
a255 2
   GLuint *_ptr = (GLuint*)r600_ptr_stencil( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = *_ptr;				\
a257 7
#elif defined(RADEON_R200)
#define READ_STENCIL( d, _x, _y )					\
do {									\
   GLuint *_ptr = (GLuint*)r200_depth_4byte( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
   d = (tmp & 0xff000000) >> 24;					\
} while (0)
d261 2
a262 2
   GLuint *_ptr = (GLuint*)radeon_ptr_4byte( rrb, _x + x_off, _y + y_off );		\
   GLuint tmp = LE32_TO_CPU(*_ptr);                                     \
d267 1
a267 1
#define TAG(x) radeon##x##_s8_z24
d270 4
d275 1
a275 75
static void map_unmap_rb(struct gl_renderbuffer *rb, int flag)
{
	struct radeon_renderbuffer *rrb = radeon_renderbuffer(rb);
	int r;

	if (rrb == NULL || !rrb->bo)
		return;

	radeon_print(RADEON_MEMORY, RADEON_TRACE,
		"%s( rb %p, flag %s )\n",
		__func__, rb, flag ? "true":"false");

	if (flag) {
	        radeon_bo_wait(rrb->bo);
		r = radeon_bo_map(rrb->bo, 1);
		if (r) {
			fprintf(stderr, "(%s) error(%d) mapping buffer.\n",
				__FUNCTION__, r);
		}

		radeonSetSpanFunctions(rrb);
	} else {
		radeon_bo_unmap(rrb->bo);
		rb->GetRow = NULL;
		rb->PutRow = NULL;
	}
}

static void
radeon_map_unmap_framebuffer(struct gl_context *ctx, struct gl_framebuffer *fb,
			     GLboolean map)
{
	GLuint i, j;

	radeon_print(RADEON_MEMORY, RADEON_TRACE,
		"%s( %p , fb %p, map %s )\n",
		__func__, ctx, fb, map ? "true":"false");

	/* color draw buffers */
	for (j = 0; j < ctx->DrawBuffer->_NumColorDrawBuffers; j++)
		map_unmap_rb(fb->_ColorDrawBuffers[j], map);

	map_unmap_rb(fb->_ColorReadBuffer, map);

	/* check for render to textures */
	for (i = 0; i < BUFFER_COUNT; i++) {
		struct gl_renderbuffer_attachment *att =
			fb->Attachment + i;
		struct gl_texture_object *tex = att->Texture;
		if (tex) {
			/* Render to texture. Note that a mipmapped texture need not
			 * be complete for render to texture, so we must restrict to
			 * mapping only the attached image.
			 */
			radeon_texture_image *image = get_radeon_texture_image(tex->Image[att->CubeMapFace][att->TextureLevel]);
			ASSERT(att->Renderbuffer);

			if (map)
				radeon_teximage_map(image, GL_TRUE);
			else
				radeon_teximage_unmap(image);
		}
	}
	
	/* depth buffer (Note wrapper!) */
	if (fb->_DepthBuffer)
		map_unmap_rb(fb->_DepthBuffer->Wrapped, map);

	if (fb->_StencilBuffer)
		map_unmap_rb(fb->_StencilBuffer->Wrapped, map);

	radeon_check_front_buffer_rendering(ctx);
}

static void radeonSpanRenderStart(struct gl_context * ctx)
d278 8
a285 22
	int i;

	radeon_firevertices(rmesa);

	/* The locking and wait for idle should really only be needed in classic mode.
	 * In a future memory manager based implementation, this should become
	 * unnecessary due to the fact that mapping our buffers, textures, etc.
	 * should implicitly wait for any previous rendering commands that must
	 * be waited on. */
	if (!rmesa->radeonScreen->driScreen->dri2.enabled) {
		LOCK_HARDWARE(rmesa);
		radeonWaitForIdleLocked(rmesa);
	}

	for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
		if (ctx->Texture.Unit[i]._ReallyEnabled)
			ctx->Driver.MapTexture(ctx, ctx->Texture.Unit[i]._Current);
	}

	radeon_map_unmap_framebuffer(ctx, ctx->DrawBuffer, GL_TRUE);
	if (ctx->ReadBuffer != ctx->DrawBuffer)
		radeon_map_unmap_framebuffer(ctx, ctx->ReadBuffer, GL_TRUE);
d288 1
a288 1
static void radeonSpanRenderFinish(struct gl_context * ctx)
a290 2
	int i;

d292 1
a292 13

	for (i = 0; i < ctx->Const.MaxTextureImageUnits; i++) {
		if (ctx->Texture.Unit[i]._ReallyEnabled)
			ctx->Driver.UnmapTexture(ctx, ctx->Texture.Unit[i]._Current);
	}

	radeon_map_unmap_framebuffer(ctx, ctx->DrawBuffer, GL_FALSE);
	if (ctx->ReadBuffer != ctx->DrawBuffer)
		radeon_map_unmap_framebuffer(ctx, ctx->ReadBuffer, GL_FALSE);

	if (!rmesa->radeonScreen->driScreen->dri2.enabled) {
		UNLOCK_HARDWARE(rmesa);
	}
d295 1
a295 1
void radeonInitSpanFuncs(struct gl_context * ctx)
d306 1
a306 1
static void radeonSetSpanFunctions(struct radeon_renderbuffer *rrb)
d308 13
a320 30
	if (rrb->base.Format == MESA_FORMAT_RGB565) {
		radeonInitPointers_RGB565(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_RGB565_REV) {
		radeonInitPointers_RGB565_REV(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_XRGB8888) {
		radeonInitPointers_xRGB8888(&rrb->base);
        } else if (rrb->base.Format == MESA_FORMAT_XRGB8888_REV) {
		radeonInitPointers_BGRx8888(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_ARGB8888) {
		radeonInitPointers_ARGB8888(&rrb->base);
        } else if (rrb->base.Format == MESA_FORMAT_ARGB8888_REV) {
		radeonInitPointers_BGRA8888(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_ARGB4444) {
		radeonInitPointers_ARGB4444(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_ARGB4444_REV) {
		radeonInitPointers_ARGB4444_REV(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_ARGB1555) {
		radeonInitPointers_ARGB1555(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_ARGB1555_REV) {
		radeonInitPointers_ARGB1555_REV(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_Z16) {
		radeonInitDepthPointers_z16(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_X8_Z24) {
		radeonInitDepthPointers_z24(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_S8_Z24) {
		radeonInitDepthPointers_s8_z24(&rrb->base);
	} else if (rrb->base.Format == MESA_FORMAT_S8) {
		radeonInitStencilPointers_s8_z24(&rrb->base);
	} else {
		fprintf(stderr, "radeonSetSpanFunctions: bad format: 0x%04X\n", rrb->base.Format);
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@a44 2
#include "main/renderbuffer.h"
#include "main/samplerobj.h"
a45 1
#include "swrast/s_renderbuffer.h"
d48 1
d51 1
d53 168
a220 2
static void
radeon_renderbuffer_map(struct gl_context *ctx, struct gl_renderbuffer *rb)
d222 161
a382 3
	struct radeon_renderbuffer *rrb = radeon_renderbuffer(rb);
	GLubyte *map;
	int stride;
d384 12
a395 2
	if (!rb || !rrb)
		return;
d397 10
a406 8
	ctx->Driver.MapRenderbuffer(ctx, rb, 0, 0, rb->Width, rb->Height,
				    GL_MAP_READ_BIT | GL_MAP_WRITE_BIT,
				    &map, &stride);

	rrb->base.Map = map;
	rrb->base.RowStride = stride;
	/* No floating point color buffers, use GLubytes */
	rrb->base.ColorType = GL_UNSIGNED_BYTE;
d409 2
a410 2
static void
radeon_renderbuffer_unmap(struct gl_context *ctx, struct gl_renderbuffer *rb)
d412 16
a427 3
	struct radeon_renderbuffer *rrb = radeon_renderbuffer(rb);
	if (!rb || !rrb)
		return;
d429 49
a477 1
	ctx->Driver.UnmapRenderbuffer(ctx, rb);
d479 39
a517 2
	rrb->base.Map = NULL;
	rrb->base.RowStride = 0;
d520 470
a989 2
static void
radeon_map_framebuffer(struct gl_context *ctx, struct gl_framebuffer *fb)
d991 5
a995 1
	GLuint i;
d998 2
a999 2
		"%s( %p , fb %p )\n",
		     __func__, ctx, fb);
d1001 14
a1014 5
	/* check for render to textures */
	for (i = 0; i < BUFFER_COUNT; i++)
		radeon_renderbuffer_map(ctx, fb->Attachment[i].Renderbuffer);

	radeon_check_front_buffer_rendering(ctx);
d1018 2
a1019 1
radeon_unmap_framebuffer(struct gl_context *ctx, struct gl_framebuffer *fb)
d1021 1
a1021 1
	GLuint i;
d1024 8
a1031 2
		"%s( %p , fb %p)\n",
		     __func__, ctx, fb);
d1034 25
a1058 2
	for (i = 0; i < BUFFER_COUNT; i++)
		radeon_renderbuffer_unmap(ctx, fb->Attachment[i].Renderbuffer);
d1066 1
d1070 14
a1083 1
	_swrast_map_textures(ctx);
d1085 1
a1085 1
	radeon_map_framebuffer(ctx, ctx->DrawBuffer);
d1087 1
a1087 1
		radeon_map_framebuffer(ctx, ctx->ReadBuffer);
d1092 3
a1095 1
	_swrast_unmap_textures(ctx);
d1097 6
a1102 1
	radeon_unmap_framebuffer(ctx, ctx->DrawBuffer);
d1104 5
a1108 1
		radeon_unmap_framebuffer(ctx, ctx->ReadBuffer);
d1119 37
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d39 1
a39 1
 *   Keith Whitwell <keithw@@vmware.com>
@


