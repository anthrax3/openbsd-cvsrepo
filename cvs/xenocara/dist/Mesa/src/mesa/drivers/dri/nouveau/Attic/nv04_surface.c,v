head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.8
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.6
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.50;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.04.50;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.22;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.39;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.54;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.54;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright (C) 2007-2010 The Nouveau Project.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "nouveau_driver.h"
#include "nv_object.xml.h"
#include "nv_m2mf.xml.h"
#include "nv01_2d.xml.h"
#include "nv04_3d.xml.h"
#include "nouveau_context.h"
#include "nouveau_util.h"
#include "nv04_driver.h"

static inline int
swzsurf_format(mesa_format format)
{
	switch (format) {
	case MESA_FORMAT_A_UNORM8:
	case MESA_FORMAT_L_UNORM8:
	case MESA_FORMAT_I_UNORM8:
	case MESA_FORMAT_B2G3R3_UNORM:
		return NV04_SWIZZLED_SURFACE_FORMAT_COLOR_Y8;

	case MESA_FORMAT_B5G6R5_UNORM:
	case MESA_FORMAT_R5G6B5_UNORM:
	case MESA_FORMAT_B4G4R4A4_UNORM:
	case MESA_FORMAT_A4R4G4B4_UNORM:
	case MESA_FORMAT_B5G5R5A1_UNORM:
	case MESA_FORMAT_A1B5G5R5_UNORM:
	case MESA_FORMAT_A1R5G5B5_UNORM:
	case MESA_FORMAT_L8A8_UNORM:
	case MESA_FORMAT_A8L8_UNORM:
	case MESA_FORMAT_YCBCR:
	case MESA_FORMAT_YCBCR_REV:
	case MESA_FORMAT_Z_UNORM16:
		return NV04_SWIZZLED_SURFACE_FORMAT_COLOR_R5G6B5;

	case MESA_FORMAT_A8B8G8R8_UNORM:
	case MESA_FORMAT_R8G8B8A8_UNORM:
	case MESA_FORMAT_B8G8R8X8_UNORM:
	case MESA_FORMAT_B8G8R8A8_UNORM:
	case MESA_FORMAT_A8R8G8B8_UNORM:
	case MESA_FORMAT_Z24_UNORM_S8_UINT:
	case MESA_FORMAT_S8_UINT_Z24_UNORM:
	case MESA_FORMAT_Z_UNORM32:
		return NV04_SWIZZLED_SURFACE_FORMAT_COLOR_A8R8G8B8;

	default:
		assert(0);
	}
}

static inline int
surf2d_format(mesa_format format)
{
	switch (format) {
	case MESA_FORMAT_A_UNORM8:
	case MESA_FORMAT_L_UNORM8:
	case MESA_FORMAT_I_UNORM8:
	case MESA_FORMAT_B2G3R3_UNORM:
		return NV04_CONTEXT_SURFACES_2D_FORMAT_Y8;

	case MESA_FORMAT_B5G6R5_UNORM:
	case MESA_FORMAT_R5G6B5_UNORM:
	case MESA_FORMAT_B4G4R4A4_UNORM:
	case MESA_FORMAT_A4R4G4B4_UNORM:
	case MESA_FORMAT_B5G5R5A1_UNORM:
	case MESA_FORMAT_A1B5G5R5_UNORM:
	case MESA_FORMAT_A1R5G5B5_UNORM:
	case MESA_FORMAT_L8A8_UNORM:
	case MESA_FORMAT_A8L8_UNORM:
	case MESA_FORMAT_YCBCR:
	case MESA_FORMAT_YCBCR_REV:
	case MESA_FORMAT_Z_UNORM16:
		return NV04_CONTEXT_SURFACES_2D_FORMAT_R5G6B5;

	case MESA_FORMAT_A8B8G8R8_UNORM:
	case MESA_FORMAT_R8G8B8A8_UNORM:
	case MESA_FORMAT_B8G8R8X8_UNORM:
	case MESA_FORMAT_B8G8R8A8_UNORM:
	case MESA_FORMAT_A8R8G8B8_UNORM:
	case MESA_FORMAT_Z24_UNORM_S8_UINT:
	case MESA_FORMAT_S8_UINT_Z24_UNORM:
	case MESA_FORMAT_Z_UNORM32:
		return NV04_CONTEXT_SURFACES_2D_FORMAT_Y32;

	default:
		assert(0);
	}
}

static inline int
rect_format(mesa_format format)
{
	switch (format) {
	case MESA_FORMAT_A_UNORM8:
	case MESA_FORMAT_L_UNORM8:
	case MESA_FORMAT_I_UNORM8:
	case MESA_FORMAT_B2G3R3_UNORM:
		return NV04_GDI_RECTANGLE_TEXT_COLOR_FORMAT_A8R8G8B8;

	case MESA_FORMAT_B5G6R5_UNORM:
	case MESA_FORMAT_R5G6B5_UNORM:
	case MESA_FORMAT_B4G4R4A4_UNORM:
	case MESA_FORMAT_A4R4G4B4_UNORM:
	case MESA_FORMAT_B5G5R5A1_UNORM:
	case MESA_FORMAT_A1B5G5R5_UNORM:
	case MESA_FORMAT_A1R5G5B5_UNORM:
	case MESA_FORMAT_L8A8_UNORM:
	case MESA_FORMAT_A8L8_UNORM:
	case MESA_FORMAT_YCBCR:
	case MESA_FORMAT_YCBCR_REV:
	case MESA_FORMAT_Z_UNORM16:
		return NV04_GDI_RECTANGLE_TEXT_COLOR_FORMAT_A16R5G6B5;

	case MESA_FORMAT_A8B8G8R8_UNORM:
	case MESA_FORMAT_R8G8B8A8_UNORM:
	case MESA_FORMAT_B8G8R8X8_UNORM:
	case MESA_FORMAT_B8G8R8A8_UNORM:
	case MESA_FORMAT_A8R8G8B8_UNORM:
	case MESA_FORMAT_Z24_UNORM_S8_UINT:
	case MESA_FORMAT_S8_UINT_Z24_UNORM:
	case MESA_FORMAT_Z_UNORM32:
		return NV04_GDI_RECTANGLE_TEXT_COLOR_FORMAT_A8R8G8B8;

	default:
		assert(0);
	}
}

static inline int
sifm_format(mesa_format format)
{
	switch (format) {
	case MESA_FORMAT_A_UNORM8:
	case MESA_FORMAT_L_UNORM8:
	case MESA_FORMAT_I_UNORM8:
	case MESA_FORMAT_B2G3R3_UNORM:
		return NV03_SCALED_IMAGE_FROM_MEMORY_COLOR_FORMAT_AY8;

	case MESA_FORMAT_B5G6R5_UNORM:
	case MESA_FORMAT_R5G6B5_UNORM:
	case MESA_FORMAT_B4G4R4A4_UNORM:
	case MESA_FORMAT_A4R4G4B4_UNORM:
	case MESA_FORMAT_B5G5R5A1_UNORM:
	case MESA_FORMAT_A1B5G5R5_UNORM:
	case MESA_FORMAT_A1R5G5B5_UNORM:
	case MESA_FORMAT_L8A8_UNORM:
	case MESA_FORMAT_A8L8_UNORM:
	case MESA_FORMAT_YCBCR:
	case MESA_FORMAT_YCBCR_REV:
	case MESA_FORMAT_Z_UNORM16:
		return NV03_SCALED_IMAGE_FROM_MEMORY_COLOR_FORMAT_R5G6B5;

	case MESA_FORMAT_A8B8G8R8_UNORM:
	case MESA_FORMAT_R8G8B8A8_UNORM:
	case MESA_FORMAT_B8G8R8X8_UNORM:
	case MESA_FORMAT_B8G8R8A8_UNORM:
	case MESA_FORMAT_A8R8G8B8_UNORM:
	case MESA_FORMAT_Z24_UNORM_S8_UINT:
	case MESA_FORMAT_S8_UINT_Z24_UNORM:
	case MESA_FORMAT_Z_UNORM32:
		return NV03_SCALED_IMAGE_FROM_MEMORY_COLOR_FORMAT_A8R8G8B8;

	default:
		assert(0);
	}
}

static void
nv04_surface_copy_swizzle(struct gl_context *ctx,
			  struct nouveau_surface *dst,
			  struct nouveau_surface *src,
			  int dx, int dy, int sx, int sy,
			  int w, int h)
{
	struct nouveau_pushbuf_refn refs[] = {
		{ src->bo, NOUVEAU_BO_RD | NOUVEAU_BO_VRAM | NOUVEAU_BO_GART },
		{ dst->bo, NOUVEAU_BO_WR | NOUVEAU_BO_VRAM },
	};
	struct nouveau_pushbuf *push = context_push(ctx);
	struct nouveau_hw_state *hw = &to_nouveau_context(ctx)->hw;
	struct nouveau_object *swzsurf = hw->swzsurf;
	struct nv04_fifo *fifo = hw->chan->data;
	/* Max width & height may not be the same on all HW, but must be POT */
	const unsigned max_w = 1024;
	const unsigned max_h = 1024;
	unsigned sub_w = w > max_w ? max_w : w;
	unsigned sub_h = h > max_h ? max_h : h;
	unsigned x, y;

        /* Swizzled surfaces must be POT  */
	assert(_mesa_is_pow_two(dst->width) &&
	       _mesa_is_pow_two(dst->height));

	if (context_chipset(ctx) < 0x10) {
		BEGIN_NV04(push, NV01_SUBC(SURF, OBJECT), 1);
		PUSH_DATA (push, swzsurf->handle);
	}

	for (y = 0; y < h; y += sub_h) {
		sub_h = MIN2(sub_h, h - y);

		for (x = 0; x < w; x += sub_w) {
			sub_w = MIN2(sub_w, w - x);

			if (nouveau_pushbuf_space(push, 64, 4, 0) ||
			    nouveau_pushbuf_refn (push, refs, 2))
				return;

			BEGIN_NV04(push, NV04_SSWZ(DMA_IMAGE), 1);
			PUSH_DATA (push, fifo->vram);
			BEGIN_NV04(push, NV04_SSWZ(FORMAT), 2);
			PUSH_DATA (push, swzsurf_format(dst->format) |
					 log2i(dst->width) << 16 |
					 log2i(dst->height) << 24);
			PUSH_RELOC(push, dst->bo, dst->offset, NOUVEAU_BO_LOW, 0, 0);

			BEGIN_NV04(push, NV03_SIFM(DMA_IMAGE), 1);
			PUSH_RELOC(push, src->bo, 0, NOUVEAU_BO_OR, fifo->vram, fifo->gart);
			BEGIN_NV04(push, NV05_SIFM(SURFACE), 1);
			PUSH_DATA (push, swzsurf->handle);

			BEGIN_NV04(push, NV03_SIFM(COLOR_FORMAT), 8);
			PUSH_DATA (push, sifm_format(src->format));
			PUSH_DATA (push, NV03_SCALED_IMAGE_FROM_MEMORY_OPERATION_SRCCOPY);
			PUSH_DATA (push, (y + dy) << 16 | (x + dx));
			PUSH_DATA (push, sub_h << 16 | sub_w);
			PUSH_DATA (push, (y + dy) << 16 | (x + dx));
			PUSH_DATA (push, sub_h << 16 | sub_w);
			PUSH_DATA (push, 1 << 20);
			PUSH_DATA (push, 1 << 20);

			BEGIN_NV04(push, NV03_SIFM(SIZE), 4);
			PUSH_DATA (push, align(sub_h, 2) << 16 | align(sub_w, 2));
			PUSH_DATA (push, src->pitch  |
					 NV03_SCALED_IMAGE_FROM_MEMORY_FORMAT_ORIGIN_CENTER |
					 NV03_SCALED_IMAGE_FROM_MEMORY_FORMAT_FILTER_POINT_SAMPLE);
			PUSH_RELOC(push, src->bo, src->offset + (y + sy) * src->pitch +
					 (x + sx) * src->cpp, NOUVEAU_BO_LOW, 0, 0);
			PUSH_DATA (push, 0);
		}
	}

	if (context_chipset(ctx) < 0x10) {
		BEGIN_NV04(push, NV01_SUBC(SURF, OBJECT), 1);
		PUSH_DATA (push, hw->surf3d->handle);
	}
}

static void
nv04_surface_copy_m2mf(struct gl_context *ctx,
		       struct nouveau_surface *dst,
		       struct nouveau_surface *src,
		       int dx, int dy, int sx, int sy,
		       int w, int h)
{
	struct nouveau_pushbuf_refn refs[] = {
		{ src->bo, NOUVEAU_BO_RD | NOUVEAU_BO_VRAM | NOUVEAU_BO_GART },
		{ dst->bo, NOUVEAU_BO_WR | NOUVEAU_BO_VRAM | NOUVEAU_BO_GART },
	};
	struct nouveau_pushbuf *push = context_push(ctx);
	struct nouveau_hw_state *hw = &to_nouveau_context(ctx)->hw;
	struct nv04_fifo *fifo = hw->chan->data;
	unsigned dst_offset = dst->offset + dy * dst->pitch + dx * dst->cpp;
	unsigned src_offset = src->offset + sy * src->pitch + sx * src->cpp;

	while (h) {
		int count = (h > 2047) ? 2047 : h;

		if (nouveau_pushbuf_space(push, 16, 4, 0) ||
		    nouveau_pushbuf_refn (push, refs, 2))
			return;

		BEGIN_NV04(push, NV03_M2MF(DMA_BUFFER_IN), 2);
		PUSH_RELOC(push, src->bo, 0, NOUVEAU_BO_OR, fifo->vram, fifo->gart);
		PUSH_RELOC(push, dst->bo, 0, NOUVEAU_BO_OR, fifo->vram, fifo->gart);
		BEGIN_NV04(push, NV03_M2MF(OFFSET_IN), 8);
		PUSH_RELOC(push, src->bo, src->offset, NOUVEAU_BO_LOW, 0, 0);
		PUSH_RELOC(push, dst->bo, dst->offset, NOUVEAU_BO_LOW, 0, 0);
		PUSH_DATA (push, src->pitch);
		PUSH_DATA (push, dst->pitch);
		PUSH_DATA (push, w * src->cpp);
		PUSH_DATA (push, count);
		PUSH_DATA (push, 0x0101);
		PUSH_DATA (push, 0);

		src_offset += src->pitch * count;
		dst_offset += dst->pitch * count;
		h -= count;
	}
}

typedef unsigned (*get_offset_t)(struct nouveau_surface *s,
				 unsigned x, unsigned y);

static unsigned
get_linear_offset(struct nouveau_surface *s, unsigned x, unsigned y)
{
	return x * s->cpp + y * s->pitch;
}

static unsigned
get_swizzled_offset(struct nouveau_surface *s, unsigned x, unsigned y)
{
	unsigned k = log2i(MIN2(s->width, s->height));

	unsigned u = (x & 0x001) << 0 |
		(x & 0x002) << 1 |
		(x & 0x004) << 2 |
		(x & 0x008) << 3 |
		(x & 0x010) << 4 |
		(x & 0x020) << 5 |
		(x & 0x040) << 6 |
		(x & 0x080) << 7 |
		(x & 0x100) << 8 |
		(x & 0x200) << 9 |
		(x & 0x400) << 10 |
		(x & 0x800) << 11;

	unsigned v = (y & 0x001) << 1 |
		(y & 0x002) << 2 |
		(y & 0x004) << 3 |
		(y & 0x008) << 4 |
		(y & 0x010) << 5 |
		(y & 0x020) << 6 |
		(y & 0x040) << 7 |
		(y & 0x080) << 8 |
		(y & 0x100) << 9 |
		(y & 0x200) << 10 |
		(y & 0x400) << 11 |
		(y & 0x800) << 12;

	return s->cpp * (((u | v) & ~(~0 << 2*k)) |
			 (x & (~0 << k)) << k |
			 (y & (~0 << k)) << k);
}

static void
nv04_surface_copy_cpu(struct gl_context *ctx,
		      struct nouveau_surface *dst,
		      struct nouveau_surface *src,
		      int dx, int dy, int sx, int sy,
		      int w, int h)
{
	int x, y;
	get_offset_t get_dst = (dst->layout == SWIZZLED ?
				get_swizzled_offset : get_linear_offset);
	get_offset_t get_src = (src->layout == SWIZZLED ?
				get_swizzled_offset : get_linear_offset);
	void *dp, *sp;

	nouveau_bo_map(dst->bo, NOUVEAU_BO_WR, context_client(ctx));
	nouveau_bo_map(src->bo, NOUVEAU_BO_RD, context_client(ctx));

	dp = dst->bo->map + dst->offset;
	sp = src->bo->map + src->offset;

	for (y = 0; y < h; y++) {
		for (x = 0; x < w; x++) {
			memcpy(dp + get_dst(dst, dx + x, dy + y),
			       sp + get_src(src, sx + x, sy + y), dst->cpp);
		}
	}
}

void
nv04_surface_copy(struct gl_context *ctx,
		  struct nouveau_surface *dst,
		  struct nouveau_surface *src,
		  int dx, int dy, int sx, int sy,
		  int w, int h)
{
	if (_mesa_is_format_compressed(src->format)) {
		sx = get_format_blocksx(src->format, sx);
		sy = get_format_blocksy(src->format, sy);
		dx = get_format_blocksx(dst->format, dx);
		dy = get_format_blocksy(dst->format, dy);
		w = get_format_blocksx(src->format, w);
		h = get_format_blocksy(src->format, h);
	}

	/* Linear texture copy. */
	if ((src->layout == LINEAR && dst->layout == LINEAR) ||
	    dst->width <= 2 || dst->height <= 1) {
		nv04_surface_copy_m2mf(ctx, dst, src, dx, dy, sx, sy, w, h);
		return;
	}

	/* Swizzle using sifm+swzsurf. */
        if (src->layout == LINEAR && dst->layout == SWIZZLED &&
	    dst->cpp != 1 && !(dst->offset & 63)) {
		nv04_surface_copy_swizzle(ctx, dst, src, dx, dy, sx, sy, w, h);
		return;
	}

	/* Fallback to CPU copy. */
	nv04_surface_copy_cpu(ctx, dst, src, dx, dy, sx, sy, w, h);
}

void
nv04_surface_fill(struct gl_context *ctx,
		  struct nouveau_surface *dst,
		  unsigned mask, unsigned value,
		  int dx, int dy, int w, int h)
{
	struct nouveau_pushbuf_refn refs[] = {
		{ dst->bo, NOUVEAU_BO_WR | NOUVEAU_BO_VRAM | NOUVEAU_BO_GART },
	};
	struct nouveau_pushbuf *push = context_push(ctx);
	struct nouveau_hw_state *hw = &to_nouveau_context(ctx)->hw;
	struct nv04_fifo *fifo = hw->chan->data;

	if (nouveau_pushbuf_space(push, 64, 4, 0) ||
	    nouveau_pushbuf_refn (push, refs, 1))
		return;

	BEGIN_NV04(push, NV04_SF2D(DMA_IMAGE_SOURCE), 2);
	PUSH_RELOC(push, dst->bo, 0, NOUVEAU_BO_OR, fifo->vram, fifo->gart);
	PUSH_RELOC(push, dst->bo, 0, NOUVEAU_BO_OR, fifo->vram, fifo->gart);
	BEGIN_NV04(push, NV04_SF2D(FORMAT), 4);
	PUSH_DATA (push, surf2d_format(dst->format));
	PUSH_DATA (push, (dst->pitch << 16) | dst->pitch);
	PUSH_RELOC(push, dst->bo, dst->offset, NOUVEAU_BO_LOW, 0, 0);
	PUSH_RELOC(push, dst->bo, dst->offset, NOUVEAU_BO_LOW, 0, 0);

	BEGIN_NV04(push, NV01_PATT(COLOR_FORMAT), 1);
	PUSH_DATA (push, rect_format(dst->format));
	BEGIN_NV04(push, NV01_PATT(MONOCHROME_COLOR1), 1);
	PUSH_DATA (push, mask | ~0ll << (8 * dst->cpp));

	BEGIN_NV04(push, NV04_GDI(COLOR_FORMAT), 1);
	PUSH_DATA (push, rect_format(dst->format));
	BEGIN_NV04(push, NV04_GDI(COLOR1_A), 1);
	PUSH_DATA (push, value);
	BEGIN_NV04(push, NV04_GDI(UNCLIPPED_RECTANGLE_POINT(0)), 2);
	PUSH_DATA (push, (dx << 16) | dy);
	PUSH_DATA (push, ( w << 16) |  h);
}

void
nv04_surface_takedown(struct gl_context *ctx)
{
	struct nouveau_hw_state *hw = &to_nouveau_context(ctx)->hw;

	nouveau_object_del(&hw->swzsurf);
	nouveau_object_del(&hw->sifm);
	nouveau_object_del(&hw->rect);
	nouveau_object_del(&hw->rop);
	nouveau_object_del(&hw->patt);
	nouveau_object_del(&hw->surf2d);
	nouveau_object_del(&hw->m2mf);
	nouveau_object_del(&hw->ntfy);
}

GLboolean
nv04_surface_init(struct gl_context *ctx)
{
	struct nouveau_pushbuf *push = context_push(ctx);
	struct nouveau_hw_state *hw = &to_nouveau_context(ctx)->hw;
	struct nouveau_object *chan = hw->chan;
	unsigned handle = 0x88000000, class;
	int ret;

	/* Notifier object. */
	ret = nouveau_object_new(chan, handle++, NOUVEAU_NOTIFIER_CLASS,
				 &(struct nv04_notify) {
					.length = 32,
				 }, sizeof(struct nv04_notify), &hw->ntfy);
	if (ret)
		goto fail;

	/* Memory to memory format. */
	ret = nouveau_object_new(chan, handle++, NV03_M2MF_CLASS,
				 NULL, 0, &hw->m2mf);
	if (ret)
		goto fail;

	BEGIN_NV04(push, NV01_SUBC(M2MF, OBJECT), 1);
	PUSH_DATA (push, hw->m2mf->handle);
	BEGIN_NV04(push, NV03_M2MF(DMA_NOTIFY), 1);
	PUSH_DATA (push, hw->ntfy->handle);

	/* Context surfaces 2D. */
	if (context_chipset(ctx) < 0x10)
		class = NV04_SURFACE_2D_CLASS;
	else
		class = NV10_SURFACE_2D_CLASS;

	ret = nouveau_object_new(chan, handle++, class, NULL, 0, &hw->surf2d);
	if (ret)
		goto fail;

	BEGIN_NV04(push, NV01_SUBC(SF2D, OBJECT), 1);
	PUSH_DATA (push, hw->surf2d->handle);

	/* Raster op. */
	ret = nouveau_object_new(chan, handle++, NV03_ROP_CLASS,
				 NULL, 0, &hw->rop);
	if (ret)
		goto fail;

	BEGIN_NV04(push, NV01_SUBC(PATT, OBJECT), 1);
	PUSH_DATA (push, hw->rop->handle);
	BEGIN_NV04(push, NV01_ROP(DMA_NOTIFY), 1);
	PUSH_DATA (push, hw->ntfy->handle);

	BEGIN_NV04(push, NV01_ROP(ROP), 1);
	PUSH_DATA (push, 0xca); /* DPSDxax in the GDI speech. */

	/* Image pattern. */
	ret = nouveau_object_new(chan, handle++, NV04_PATTERN_CLASS,
				 NULL, 0, &hw->patt);
	if (ret)
		goto fail;

	BEGIN_NV04(push, NV01_SUBC(PATT, OBJECT), 1);
	PUSH_DATA (push, hw->patt->handle);
	BEGIN_NV04(push, NV01_PATT(DMA_NOTIFY), 1);
	PUSH_DATA (push, hw->ntfy->handle);

	BEGIN_NV04(push, NV01_PATT(MONOCHROME_FORMAT), 3);
	PUSH_DATA (push, NV04_IMAGE_PATTERN_MONOCHROME_FORMAT_LE);
	PUSH_DATA (push, NV04_IMAGE_PATTERN_MONOCHROME_SHAPE_8X8);
	PUSH_DATA (push, NV04_IMAGE_PATTERN_PATTERN_SELECT_MONO);

	BEGIN_NV04(push, NV01_PATT(MONOCHROME_COLOR0), 4);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, ~0);
	PUSH_DATA (push, ~0);

	/* GDI rectangle text. */
	ret = nouveau_object_new(chan, handle++, NV04_GDI_CLASS,
				 NULL, 0, &hw->rect);
	if (ret)
		goto fail;

	BEGIN_NV04(push, NV01_SUBC(GDI, OBJECT), 1);
	PUSH_DATA (push, hw->rect->handle);
	BEGIN_NV04(push, NV04_GDI(DMA_NOTIFY), 1);
	PUSH_DATA (push, hw->ntfy->handle);
	BEGIN_NV04(push, NV04_GDI(SURFACE), 1);
	PUSH_DATA (push, hw->surf2d->handle);
	BEGIN_NV04(push, NV04_GDI(ROP), 1);
	PUSH_DATA (push, hw->rop->handle);
	BEGIN_NV04(push, NV04_GDI(PATTERN), 1);
	PUSH_DATA (push, hw->patt->handle);

	BEGIN_NV04(push, NV04_GDI(OPERATION), 1);
	PUSH_DATA (push, NV04_GDI_RECTANGLE_TEXT_OPERATION_ROP_AND);
	BEGIN_NV04(push, NV04_GDI(MONOCHROME_FORMAT), 1);
	PUSH_DATA (push, NV04_GDI_RECTANGLE_TEXT_MONOCHROME_FORMAT_LE);

	/* Swizzled surface. */
	if (context_chipset(ctx) < 0x20)
		class = NV04_SURFACE_SWZ_CLASS;
	else
		class = NV20_SURFACE_SWZ_CLASS;

	ret = nouveau_object_new(chan, handle++, class, NULL, 0, &hw->swzsurf);
	if (ret)
		goto fail;

	BEGIN_NV04(push, NV01_SUBC(SURF, OBJECT), 1);
	PUSH_DATA (push, hw->swzsurf->handle);

	/* Scaled image from memory. */
	if  (context_chipset(ctx) < 0x10)
		class = NV04_SIFM_CLASS;
	else
		class = NV10_SIFM_CLASS;

	ret = nouveau_object_new(chan, handle++, class, NULL, 0, &hw->sifm);
	if (ret)
		goto fail;

	BEGIN_NV04(push, NV01_SUBC(SIFM, OBJECT), 1);
	PUSH_DATA (push, hw->sifm->handle);

	if (context_chipset(ctx) >= 0x10) {
		BEGIN_NV04(push, NV05_SIFM(COLOR_CONVERSION), 1);
		PUSH_DATA (push, NV05_SCALED_IMAGE_FROM_MEMORY_COLOR_CONVERSION_TRUNCATE);
	}

	return GL_TRUE;

fail:
	nv04_surface_takedown(ctx);
	return GL_FALSE;
}
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.3
log
@Merge Mesa 9.2.0
@
text
@d37 1
a37 1
swzsurf_format(gl_format format)
d40 4
a43 4
	case MESA_FORMAT_A8:
	case MESA_FORMAT_L8:
	case MESA_FORMAT_I8:
	case MESA_FORMAT_RGB332:
d46 9
a54 9
	case MESA_FORMAT_RGB565:
	case MESA_FORMAT_RGB565_REV:
	case MESA_FORMAT_ARGB4444:
	case MESA_FORMAT_ARGB4444_REV:
	case MESA_FORMAT_ARGB1555:
	case MESA_FORMAT_RGBA5551:
	case MESA_FORMAT_ARGB1555_REV:
	case MESA_FORMAT_AL88:
	case MESA_FORMAT_AL88_REV:
d57 1
a57 1
	case MESA_FORMAT_Z16:
d60 8
a67 8
	case MESA_FORMAT_RGBA8888:
	case MESA_FORMAT_RGBA8888_REV:
	case MESA_FORMAT_XRGB8888:
	case MESA_FORMAT_ARGB8888:
	case MESA_FORMAT_ARGB8888_REV:
	case MESA_FORMAT_S8_Z24:
	case MESA_FORMAT_Z24_S8:
	case MESA_FORMAT_Z32:
d76 1
a76 1
surf2d_format(gl_format format)
d79 4
a82 4
	case MESA_FORMAT_A8:
	case MESA_FORMAT_L8:
	case MESA_FORMAT_I8:
	case MESA_FORMAT_RGB332:
d85 9
a93 9
	case MESA_FORMAT_RGB565:
	case MESA_FORMAT_RGB565_REV:
	case MESA_FORMAT_ARGB4444:
	case MESA_FORMAT_ARGB4444_REV:
	case MESA_FORMAT_ARGB1555:
	case MESA_FORMAT_RGBA5551:
	case MESA_FORMAT_ARGB1555_REV:
	case MESA_FORMAT_AL88:
	case MESA_FORMAT_AL88_REV:
d96 1
a96 1
	case MESA_FORMAT_Z16:
d99 8
a106 8
	case MESA_FORMAT_RGBA8888:
	case MESA_FORMAT_RGBA8888_REV:
	case MESA_FORMAT_XRGB8888:
	case MESA_FORMAT_ARGB8888:
	case MESA_FORMAT_ARGB8888_REV:
	case MESA_FORMAT_S8_Z24:
	case MESA_FORMAT_Z24_S8:
	case MESA_FORMAT_Z32:
d115 1
a115 1
rect_format(gl_format format)
d118 4
a121 4
	case MESA_FORMAT_A8:
	case MESA_FORMAT_L8:
	case MESA_FORMAT_I8:
	case MESA_FORMAT_RGB332:
d124 9
a132 9
	case MESA_FORMAT_RGB565:
	case MESA_FORMAT_RGB565_REV:
	case MESA_FORMAT_ARGB4444:
	case MESA_FORMAT_ARGB4444_REV:
	case MESA_FORMAT_ARGB1555:
	case MESA_FORMAT_RGBA5551:
	case MESA_FORMAT_ARGB1555_REV:
	case MESA_FORMAT_AL88:
	case MESA_FORMAT_AL88_REV:
d135 1
a135 1
	case MESA_FORMAT_Z16:
d138 8
a145 8
	case MESA_FORMAT_RGBA8888:
	case MESA_FORMAT_RGBA8888_REV:
	case MESA_FORMAT_XRGB8888:
	case MESA_FORMAT_ARGB8888:
	case MESA_FORMAT_ARGB8888_REV:
	case MESA_FORMAT_S8_Z24:
	case MESA_FORMAT_Z24_S8:
	case MESA_FORMAT_Z32:
d154 1
a154 1
sifm_format(gl_format format)
d157 4
a160 4
	case MESA_FORMAT_A8:
	case MESA_FORMAT_L8:
	case MESA_FORMAT_I8:
	case MESA_FORMAT_RGB332:
d163 9
a171 9
	case MESA_FORMAT_RGB565:
	case MESA_FORMAT_RGB565_REV:
	case MESA_FORMAT_ARGB4444:
	case MESA_FORMAT_ARGB4444_REV:
	case MESA_FORMAT_ARGB1555:
	case MESA_FORMAT_RGBA5551:
	case MESA_FORMAT_ARGB1555_REV:
	case MESA_FORMAT_AL88:
	case MESA_FORMAT_AL88_REV:
d174 1
a174 1
	case MESA_FORMAT_Z16:
d177 8
a184 8
	case MESA_FORMAT_RGBA8888:
	case MESA_FORMAT_RGBA8888_REV:
	case MESA_FORMAT_XRGB8888:
	case MESA_FORMAT_ARGB8888:
	case MESA_FORMAT_ARGB8888_REV:
	case MESA_FORMAT_S8_Z24:
	case MESA_FORMAT_Z24_S8:
	case MESA_FORMAT_Z32:
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a43 1
	case MESA_FORMAT_CI8:
a82 1
	case MESA_FORMAT_CI8:
a121 1
	case MESA_FORMAT_CI8:
a160 1
	case MESA_FORMAT_CI8:
d199 5
a203 1
	struct nouveau_channel *chan = context_chan(ctx);
d205 2
a206 4
	struct nouveau_grobj *swzsurf = hw->swzsurf;
	struct nouveau_grobj *sifm = hw->sifm;
	struct nouveau_bo_context *bctx = context_bctx(ctx, SURFACE);
	const unsigned bo_flags = NOUVEAU_BO_VRAM | NOUVEAU_BO_GART;
d218 4
a221 14
	nouveau_bo_marko(bctx, sifm, NV03_SCALED_IMAGE_FROM_MEMORY_DMA_IMAGE,
			 src->bo, bo_flags | NOUVEAU_BO_RD);
	nouveau_bo_marko(bctx, swzsurf, NV04_SWIZZLED_SURFACE_DMA_IMAGE,
			 dst->bo, NOUVEAU_BO_VRAM | NOUVEAU_BO_WR);
	nouveau_bo_markl(bctx, swzsurf, NV04_SWIZZLED_SURFACE_OFFSET,
			 dst->bo, dst->offset, NOUVEAU_BO_VRAM | NOUVEAU_BO_WR);

	BEGIN_RING(chan, swzsurf, NV04_SWIZZLED_SURFACE_FORMAT, 1);
	OUT_RING  (chan, swzsurf_format(dst->format) |
		   log2i(dst->width) << 16 |
		   log2i(dst->height) << 24);

	BEGIN_RING(chan, sifm, NV04_SCALED_IMAGE_FROM_MEMORY_SURFACE, 1);
	OUT_RING  (chan, swzsurf->handle);
d229 35
a263 24
			MARK_RING(chan, 15, 1);

			BEGIN_RING(chan, sifm,
				   NV03_SCALED_IMAGE_FROM_MEMORY_COLOR_FORMAT, 8);
			OUT_RING(chan, sifm_format(src->format));
			OUT_RING(chan, NV03_SCALED_IMAGE_FROM_MEMORY_OPERATION_SRCCOPY);
			OUT_RING(chan, (y + dy) << 16 | (x + dx));
			OUT_RING(chan, sub_h << 16 | sub_w);
			OUT_RING(chan, (y + dy) << 16 | (x + dx));
			OUT_RING(chan, sub_h << 16 | sub_w);
			OUT_RING(chan, 1 << 20);
			OUT_RING(chan, 1 << 20);

			BEGIN_RING(chan, sifm,
				   NV03_SCALED_IMAGE_FROM_MEMORY_SIZE, 4);
			OUT_RING(chan, align(sub_h, 2) << 16 | align(sub_w, 2));
			OUT_RING(chan, src->pitch  |
				 NV03_SCALED_IMAGE_FROM_MEMORY_FORMAT_ORIGIN_CENTER |
				 NV03_SCALED_IMAGE_FROM_MEMORY_FORMAT_FILTER_POINT_SAMPLE);
			OUT_RELOCl(chan, src->bo, src->offset +
				   (y + sy) * src->pitch +
				   (x + sx) * src->cpp,
				   bo_flags | NOUVEAU_BO_RD);
			OUT_RING(chan, 0);
d267 4
a270 4
	nouveau_bo_context_reset(bctx);

	if (context_chipset(ctx) < 0x10)
		FIRE_RING(chan);
d280 5
a284 1
	struct nouveau_channel *chan = context_chan(ctx);
d286 1
a286 3
	struct nouveau_grobj *m2mf = hw->m2mf;
	struct nouveau_bo_context *bctx = context_bctx(ctx, SURFACE);
	const unsigned bo_flags = NOUVEAU_BO_VRAM | NOUVEAU_BO_GART;
a289 5
	nouveau_bo_marko(bctx, m2mf, NV04_M2MF_DMA_BUFFER_IN,
			 src->bo, bo_flags | NOUVEAU_BO_RD);
	nouveau_bo_marko(bctx, m2mf, NV04_M2MF_DMA_BUFFER_OUT,
			 dst->bo, bo_flags | NOUVEAU_BO_WR);

d293 16
a308 13
		MARK_RING(chan, 9, 2);

		BEGIN_RING(chan, m2mf, NV04_M2MF_OFFSET_IN, 8);
		OUT_RELOCl(chan, src->bo, src_offset,
			   bo_flags | NOUVEAU_BO_RD);
		OUT_RELOCl(chan, dst->bo, dst_offset,
			   bo_flags | NOUVEAU_BO_WR);
		OUT_RING  (chan, src->pitch);
		OUT_RING  (chan, dst->pitch);
		OUT_RING  (chan, w * src->cpp);
		OUT_RING  (chan, count);
		OUT_RING  (chan, 0x0101);
		OUT_RING  (chan, 0);
a309 1
		h -= count;
d312 1
a313 5

	nouveau_bo_context_reset(bctx);

	if (context_chipset(ctx) < 0x10)
		FIRE_RING(chan);
d375 2
a376 2
	nouveau_bo_map(dst->bo, NOUVEAU_BO_WR);
	nouveau_bo_map(src->bo, NOUVEAU_BO_RD);
a386 3

	nouveau_bo_unmap(src->bo);
	nouveau_bo_unmap(dst->bo);
d396 9
d429 4
a432 1
	struct nouveau_channel *chan = context_chan(ctx);
d434 5
a438 29
	struct nouveau_grobj *surf2d = hw->surf2d;
	struct nouveau_grobj *patt = hw->patt;
	struct nouveau_grobj *rect = hw->rect;
	unsigned bo_flags = NOUVEAU_BO_VRAM | NOUVEAU_BO_GART;

	MARK_RING (chan, 19, 4);

	BEGIN_RING(chan, surf2d, NV04_CONTEXT_SURFACES_2D_DMA_IMAGE_SOURCE, 2);
	OUT_RELOCo(chan, dst->bo, bo_flags | NOUVEAU_BO_WR);
	OUT_RELOCo(chan, dst->bo, bo_flags | NOUVEAU_BO_WR);
	BEGIN_RING(chan, surf2d, NV04_CONTEXT_SURFACES_2D_FORMAT, 4);
	OUT_RING  (chan, surf2d_format(dst->format));
	OUT_RING  (chan, (dst->pitch << 16) | dst->pitch);
	OUT_RELOCl(chan, dst->bo, dst->offset, bo_flags | NOUVEAU_BO_WR);
	OUT_RELOCl(chan, dst->bo, dst->offset, bo_flags | NOUVEAU_BO_WR);

	BEGIN_RING(chan, patt, NV04_IMAGE_PATTERN_COLOR_FORMAT, 1);
	OUT_RING  (chan, rect_format(dst->format));
	BEGIN_RING(chan, patt, NV04_IMAGE_PATTERN_MONOCHROME_COLOR1, 1);
	OUT_RING  (chan, mask | ~0ll << (8 * dst->cpp));

	BEGIN_RING(chan, rect, NV04_GDI_RECTANGLE_TEXT_COLOR_FORMAT, 1);
	OUT_RING  (chan, rect_format(dst->format));
	BEGIN_RING(chan, rect, NV04_GDI_RECTANGLE_TEXT_COLOR1_A, 1);
	OUT_RING  (chan, value);
	BEGIN_RING(chan, rect,
		   NV04_GDI_RECTANGLE_TEXT_UNCLIPPED_RECTANGLE_POINT(0), 2);
	OUT_RING  (chan, (dx << 16) | dy);
	OUT_RING  (chan, ( w << 16) |  h);
d440 21
a460 2
	if (context_chipset(ctx) < 0x10)
		FIRE_RING(chan);
d468 8
a475 8
	nouveau_grobj_free(&hw->swzsurf);
	nouveau_grobj_free(&hw->sifm);
	nouveau_grobj_free(&hw->rect);
	nouveau_grobj_free(&hw->rop);
	nouveau_grobj_free(&hw->patt);
	nouveau_grobj_free(&hw->surf2d);
	nouveau_grobj_free(&hw->m2mf);
	nouveau_notifier_free(&hw->ntfy);
d481 1
a481 1
	struct nouveau_channel *chan = context_chan(ctx);
d483 1
d488 4
a491 1
	ret = nouveau_notifier_alloc(chan, handle++, 1, &hw->ntfy);
d496 2
a497 1
	ret = nouveau_grobj_alloc(chan, handle++, NV04_M2MF, &hw->m2mf);
d501 4
a504 2
	BEGIN_RING(chan, hw->m2mf, NV04_M2MF_DMA_NOTIFY, 1);
	OUT_RING  (chan, hw->ntfy->handle);
d508 1
a508 1
		class = NV04_CONTEXT_SURFACES_2D;
d510 1
a510 1
		class = NV10_CONTEXT_SURFACES_2D;
d512 1
a512 1
	ret = nouveau_grobj_alloc(chan, handle++, class, &hw->surf2d);
d516 3
d520 2
a521 1
	ret = nouveau_grobj_alloc(chan, handle++, NV03_CONTEXT_ROP, &hw->rop);
d525 4
a528 2
	BEGIN_RING(chan, hw->rop, NV03_CONTEXT_ROP_DMA_NOTIFY, 1);
	OUT_RING  (chan, hw->ntfy->handle);
d530 2
a531 2
	BEGIN_RING(chan, hw->rop, NV03_CONTEXT_ROP_ROP, 1);
	OUT_RING  (chan, 0xca); /* DPSDxax in the GDI speech. */
d534 2
a535 2
	ret = nouveau_grobj_alloc(chan, handle++, NV04_IMAGE_PATTERN,
				  &hw->patt);
d539 15
a553 13
	BEGIN_RING(chan, hw->patt, NV04_IMAGE_PATTERN_DMA_NOTIFY, 1);
	OUT_RING  (chan, hw->ntfy->handle);

	BEGIN_RING(chan, hw->patt, NV04_IMAGE_PATTERN_MONOCHROME_FORMAT, 3);
	OUT_RING  (chan, NV04_IMAGE_PATTERN_MONOCHROME_FORMAT_LE);
	OUT_RING  (chan, NV04_IMAGE_PATTERN_MONOCHROME_SHAPE_8X8);
	OUT_RING  (chan, NV04_IMAGE_PATTERN_PATTERN_SELECT_MONO);

	BEGIN_RING(chan, hw->patt, NV04_IMAGE_PATTERN_MONOCHROME_COLOR0, 4);
	OUT_RING  (chan, 0);
	OUT_RING  (chan, 0);
	OUT_RING  (chan, ~0);
	OUT_RING  (chan, ~0);
d556 2
a557 2
	ret = nouveau_grobj_alloc(chan, handle++, NV04_GDI_RECTANGLE_TEXT,
				  &hw->rect);
d561 15
a575 14
	BEGIN_RING(chan, hw->rect, NV04_GDI_RECTANGLE_TEXT_DMA_NOTIFY, 1);
	OUT_RING  (chan, hw->ntfy->handle);
	BEGIN_RING(chan, hw->rect, NV04_GDI_RECTANGLE_TEXT_SURFACE, 1);
	OUT_RING  (chan, hw->surf2d->handle);
	BEGIN_RING(chan, hw->rect, NV04_GDI_RECTANGLE_TEXT_ROP, 1);
	OUT_RING  (chan, hw->rop->handle);
	BEGIN_RING(chan, hw->rect, NV04_GDI_RECTANGLE_TEXT_PATTERN, 1);
	OUT_RING  (chan, hw->patt->handle);

	BEGIN_RING(chan, hw->rect, NV04_GDI_RECTANGLE_TEXT_OPERATION, 1);
	OUT_RING  (chan, NV04_GDI_RECTANGLE_TEXT_OPERATION_ROP_AND);
	BEGIN_RING(chan, hw->rect,
		   NV04_GDI_RECTANGLE_TEXT_MONOCHROME_FORMAT, 1);
	OUT_RING  (chan, NV04_GDI_RECTANGLE_TEXT_MONOCHROME_FORMAT_LE);
d579 1
a579 1
		class = NV04_SWIZZLED_SURFACE;
d581 1
a581 1
		class = NV20_SWIZZLED_SURFACE;
d583 1
a583 1
	ret = nouveau_grobj_alloc(chan, handle++, class, &hw->swzsurf);
d587 3
d592 1
a592 1
		class = NV04_SCALED_IMAGE_FROM_MEMORY;
d594 1
a594 1
		class = NV10_SCALED_IMAGE_FROM_MEMORY;
d596 1
a596 1
	ret = nouveau_grobj_alloc(chan, handle++, class, &hw->sifm);
d600 3
d604 2
a605 3
		BEGIN_RING(chan, hw->sifm,
			   NV05_SCALED_IMAGE_FROM_MEMORY_COLOR_CONVERSION, 1);
		OUT_RING(chan, NV05_SCALED_IMAGE_FROM_MEMORY_COLOR_CONVERSION_TRUNCATE);
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d28 4
a31 1
#include "nouveau_class.h"
d197 1
a197 1
nv04_surface_copy_swizzle(GLcontext *ctx,
a219 5
        /* If area is too large to copy in one shot we must copy it in
	 * POT chunks to meet alignment requirements */
	assert(sub_w == w || _mesa_is_pow_two(w));
	assert(sub_h == h || _mesa_is_pow_two(h));

d256 1
a256 1
			OUT_RING(chan, sub_h << 16 | sub_w);
d275 1
a275 1
nv04_surface_copy_m2mf(GLcontext *ctx,
d289 1
a289 1
	nouveau_bo_marko(bctx, m2mf, NV04_MEMORY_TO_MEMORY_FORMAT_DMA_BUFFER_IN,
d291 1
a291 1
	nouveau_bo_marko(bctx, m2mf, NV04_MEMORY_TO_MEMORY_FORMAT_DMA_BUFFER_OUT,
d299 1
a299 1
		BEGIN_RING(chan, m2mf, NV04_MEMORY_TO_MEMORY_FORMAT_OFFSET_IN, 8);
d368 1
a368 1
nv04_surface_copy_cpu(GLcontext *ctx,
d399 1
a399 1
nv04_surface_copy(GLcontext *ctx,
d424 1
a424 1
nv04_surface_fill(GLcontext *ctx,
d466 1
a466 1
nv04_surface_takedown(GLcontext *ctx)
d481 1
a481 1
nv04_surface_init(GLcontext *ctx)
d494 1
a494 2
	ret = nouveau_grobj_alloc(chan, handle++, NV04_MEMORY_TO_MEMORY_FORMAT,
				  &hw->m2mf);
d498 1
a498 1
	BEGIN_RING(chan, hw->m2mf, NV04_MEMORY_TO_MEMORY_FORMAT_DMA_NOTIFY, 1);
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d28 1
a28 4
#include "nv_object.xml.h"
#include "nv_m2mf.xml.h"
#include "nv01_2d.xml.h"
#include "nv04_3d.xml.h"
d194 1
a194 1
nv04_surface_copy_swizzle(struct gl_context *ctx,
d217 5
d258 1
a258 1
			OUT_RING(chan, align(sub_h, 2) << 16 | align(sub_w, 2));
d277 1
a277 1
nv04_surface_copy_m2mf(struct gl_context *ctx,
d291 1
a291 1
	nouveau_bo_marko(bctx, m2mf, NV04_M2MF_DMA_BUFFER_IN,
d293 1
a293 1
	nouveau_bo_marko(bctx, m2mf, NV04_M2MF_DMA_BUFFER_OUT,
d301 1
a301 1
		BEGIN_RING(chan, m2mf, NV04_M2MF_OFFSET_IN, 8);
d370 1
a370 1
nv04_surface_copy_cpu(struct gl_context *ctx,
d401 1
a401 1
nv04_surface_copy(struct gl_context *ctx,
d426 1
a426 1
nv04_surface_fill(struct gl_context *ctx,
d468 1
a468 1
nv04_surface_takedown(struct gl_context *ctx)
d483 1
a483 1
nv04_surface_init(struct gl_context *ctx)
d496 2
a497 1
	ret = nouveau_grobj_alloc(chan, handle++, NV04_M2MF, &hw->m2mf);
d501 1
a501 1
	BEGIN_RING(chan, hw->m2mf, NV04_M2MF_DMA_NOTIFY, 1);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d44 1
d84 1
d124 1
d164 1
d203 1
a203 5
	struct nouveau_pushbuf_refn refs[] = {
		{ src->bo, NOUVEAU_BO_RD | NOUVEAU_BO_VRAM | NOUVEAU_BO_GART },
		{ dst->bo, NOUVEAU_BO_WR | NOUVEAU_BO_VRAM },
	};
	struct nouveau_pushbuf *push = context_push(ctx);
d205 4
a208 2
	struct nouveau_object *swzsurf = hw->swzsurf;
	struct nv04_fifo *fifo = hw->chan->data;
d220 14
a233 4
	if (context_chipset(ctx) < 0x10) {
		BEGIN_NV04(push, NV01_SUBC(SURF, OBJECT), 1);
		PUSH_DATA (push, swzsurf->handle);
	}
d241 24
a264 35
			if (nouveau_pushbuf_space(push, 64, 4, 0) ||
			    nouveau_pushbuf_refn (push, refs, 2))
				return;

			BEGIN_NV04(push, NV04_SSWZ(DMA_IMAGE), 1);
			PUSH_DATA (push, fifo->vram);
			BEGIN_NV04(push, NV04_SSWZ(FORMAT), 2);
			PUSH_DATA (push, swzsurf_format(dst->format) |
					 log2i(dst->width) << 16 |
					 log2i(dst->height) << 24);
			PUSH_RELOC(push, dst->bo, dst->offset, NOUVEAU_BO_LOW, 0, 0);

			BEGIN_NV04(push, NV03_SIFM(DMA_IMAGE), 1);
			PUSH_RELOC(push, src->bo, 0, NOUVEAU_BO_OR, fifo->vram, fifo->gart);
			BEGIN_NV04(push, NV05_SIFM(SURFACE), 1);
			PUSH_DATA (push, swzsurf->handle);

			BEGIN_NV04(push, NV03_SIFM(COLOR_FORMAT), 8);
			PUSH_DATA (push, sifm_format(src->format));
			PUSH_DATA (push, NV03_SCALED_IMAGE_FROM_MEMORY_OPERATION_SRCCOPY);
			PUSH_DATA (push, (y + dy) << 16 | (x + dx));
			PUSH_DATA (push, sub_h << 16 | sub_w);
			PUSH_DATA (push, (y + dy) << 16 | (x + dx));
			PUSH_DATA (push, sub_h << 16 | sub_w);
			PUSH_DATA (push, 1 << 20);
			PUSH_DATA (push, 1 << 20);

			BEGIN_NV04(push, NV03_SIFM(SIZE), 4);
			PUSH_DATA (push, align(sub_h, 2) << 16 | align(sub_w, 2));
			PUSH_DATA (push, src->pitch  |
					 NV03_SCALED_IMAGE_FROM_MEMORY_FORMAT_ORIGIN_CENTER |
					 NV03_SCALED_IMAGE_FROM_MEMORY_FORMAT_FILTER_POINT_SAMPLE);
			PUSH_RELOC(push, src->bo, src->offset + (y + sy) * src->pitch +
					 (x + sx) * src->cpp, NOUVEAU_BO_LOW, 0, 0);
			PUSH_DATA (push, 0);
d268 4
a271 4
	if (context_chipset(ctx) < 0x10) {
		BEGIN_NV04(push, NV01_SUBC(SURF, OBJECT), 1);
		PUSH_DATA (push, hw->surf3d->handle);
	}
d281 1
a281 5
	struct nouveau_pushbuf_refn refs[] = {
		{ src->bo, NOUVEAU_BO_RD | NOUVEAU_BO_VRAM | NOUVEAU_BO_GART },
		{ dst->bo, NOUVEAU_BO_WR | NOUVEAU_BO_VRAM | NOUVEAU_BO_GART },
	};
	struct nouveau_pushbuf *push = context_push(ctx);
d283 3
a285 1
	struct nv04_fifo *fifo = hw->chan->data;
d289 5
d297 13
a309 16
		if (nouveau_pushbuf_space(push, 16, 4, 0) ||
		    nouveau_pushbuf_refn (push, refs, 2))
			return;

		BEGIN_NV04(push, NV03_M2MF(DMA_BUFFER_IN), 2);
		PUSH_RELOC(push, src->bo, 0, NOUVEAU_BO_OR, fifo->vram, fifo->gart);
		PUSH_RELOC(push, dst->bo, 0, NOUVEAU_BO_OR, fifo->vram, fifo->gart);
		BEGIN_NV04(push, NV03_M2MF(OFFSET_IN), 8);
		PUSH_RELOC(push, src->bo, src->offset, NOUVEAU_BO_LOW, 0, 0);
		PUSH_RELOC(push, dst->bo, dst->offset, NOUVEAU_BO_LOW, 0, 0);
		PUSH_DATA (push, src->pitch);
		PUSH_DATA (push, dst->pitch);
		PUSH_DATA (push, w * src->cpp);
		PUSH_DATA (push, count);
		PUSH_DATA (push, 0x0101);
		PUSH_DATA (push, 0);
d311 1
a313 1
		h -= count;
d315 5
d381 2
a382 2
	nouveau_bo_map(dst->bo, NOUVEAU_BO_WR, context_client(ctx));
	nouveau_bo_map(src->bo, NOUVEAU_BO_RD, context_client(ctx));
d393 3
a404 9
	if (_mesa_is_format_compressed(src->format)) {
		sx = get_format_blocksx(src->format, sx);
		sy = get_format_blocksy(src->format, sy);
		dx = get_format_blocksx(dst->format, dx);
		dy = get_format_blocksy(dst->format, dy);
		w = get_format_blocksx(src->format, w);
		h = get_format_blocksy(src->format, h);
	}

d429 1
a429 4
	struct nouveau_pushbuf_refn refs[] = {
		{ dst->bo, NOUVEAU_BO_WR | NOUVEAU_BO_VRAM | NOUVEAU_BO_GART },
	};
	struct nouveau_pushbuf *push = context_push(ctx);
d431 29
a459 1
	struct nv04_fifo *fifo = hw->chan->data;
d461 2
a462 25
	if (nouveau_pushbuf_space(push, 64, 4, 0) ||
	    nouveau_pushbuf_refn (push, refs, 1))
		return;

	BEGIN_NV04(push, NV04_SF2D(DMA_IMAGE_SOURCE), 2);
	PUSH_RELOC(push, dst->bo, 0, NOUVEAU_BO_OR, fifo->vram, fifo->gart);
	PUSH_RELOC(push, dst->bo, 0, NOUVEAU_BO_OR, fifo->vram, fifo->gart);
	BEGIN_NV04(push, NV04_SF2D(FORMAT), 4);
	PUSH_DATA (push, surf2d_format(dst->format));
	PUSH_DATA (push, (dst->pitch << 16) | dst->pitch);
	PUSH_RELOC(push, dst->bo, dst->offset, NOUVEAU_BO_LOW, 0, 0);
	PUSH_RELOC(push, dst->bo, dst->offset, NOUVEAU_BO_LOW, 0, 0);

	BEGIN_NV04(push, NV01_PATT(COLOR_FORMAT), 1);
	PUSH_DATA (push, rect_format(dst->format));
	BEGIN_NV04(push, NV01_PATT(MONOCHROME_COLOR1), 1);
	PUSH_DATA (push, mask | ~0ll << (8 * dst->cpp));

	BEGIN_NV04(push, NV04_GDI(COLOR_FORMAT), 1);
	PUSH_DATA (push, rect_format(dst->format));
	BEGIN_NV04(push, NV04_GDI(COLOR1_A), 1);
	PUSH_DATA (push, value);
	BEGIN_NV04(push, NV04_GDI(UNCLIPPED_RECTANGLE_POINT(0)), 2);
	PUSH_DATA (push, (dx << 16) | dy);
	PUSH_DATA (push, ( w << 16) |  h);
d470 8
a477 8
	nouveau_object_del(&hw->swzsurf);
	nouveau_object_del(&hw->sifm);
	nouveau_object_del(&hw->rect);
	nouveau_object_del(&hw->rop);
	nouveau_object_del(&hw->patt);
	nouveau_object_del(&hw->surf2d);
	nouveau_object_del(&hw->m2mf);
	nouveau_object_del(&hw->ntfy);
d483 1
a483 1
	struct nouveau_pushbuf *push = context_push(ctx);
a484 1
	struct nouveau_object *chan = hw->chan;
d489 1
a489 4
	ret = nouveau_object_new(chan, handle++, NOUVEAU_NOTIFIER_CLASS,
				 &(struct nv04_notify) {
					.length = 32,
				 }, sizeof(struct nv04_notify), &hw->ntfy);
d494 1
a494 2
	ret = nouveau_object_new(chan, handle++, NV03_M2MF_CLASS,
				 NULL, 0, &hw->m2mf);
d498 2
a499 4
	BEGIN_NV04(push, NV01_SUBC(M2MF, OBJECT), 1);
	PUSH_DATA (push, hw->m2mf->handle);
	BEGIN_NV04(push, NV03_M2MF(DMA_NOTIFY), 1);
	PUSH_DATA (push, hw->ntfy->handle);
d503 1
a503 1
		class = NV04_SURFACE_2D_CLASS;
d505 1
a505 1
		class = NV10_SURFACE_2D_CLASS;
d507 1
a507 1
	ret = nouveau_object_new(chan, handle++, class, NULL, 0, &hw->surf2d);
a510 3
	BEGIN_NV04(push, NV01_SUBC(SF2D, OBJECT), 1);
	PUSH_DATA (push, hw->surf2d->handle);

d512 1
a512 2
	ret = nouveau_object_new(chan, handle++, NV03_ROP_CLASS,
				 NULL, 0, &hw->rop);
d516 2
a517 4
	BEGIN_NV04(push, NV01_SUBC(PATT, OBJECT), 1);
	PUSH_DATA (push, hw->rop->handle);
	BEGIN_NV04(push, NV01_ROP(DMA_NOTIFY), 1);
	PUSH_DATA (push, hw->ntfy->handle);
d519 2
a520 2
	BEGIN_NV04(push, NV01_ROP(ROP), 1);
	PUSH_DATA (push, 0xca); /* DPSDxax in the GDI speech. */
d523 2
a524 2
	ret = nouveau_object_new(chan, handle++, NV04_PATTERN_CLASS,
				 NULL, 0, &hw->patt);
d528 13
a540 15
	BEGIN_NV04(push, NV01_SUBC(PATT, OBJECT), 1);
	PUSH_DATA (push, hw->patt->handle);
	BEGIN_NV04(push, NV01_PATT(DMA_NOTIFY), 1);
	PUSH_DATA (push, hw->ntfy->handle);

	BEGIN_NV04(push, NV01_PATT(MONOCHROME_FORMAT), 3);
	PUSH_DATA (push, NV04_IMAGE_PATTERN_MONOCHROME_FORMAT_LE);
	PUSH_DATA (push, NV04_IMAGE_PATTERN_MONOCHROME_SHAPE_8X8);
	PUSH_DATA (push, NV04_IMAGE_PATTERN_PATTERN_SELECT_MONO);

	BEGIN_NV04(push, NV01_PATT(MONOCHROME_COLOR0), 4);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, 0);
	PUSH_DATA (push, ~0);
	PUSH_DATA (push, ~0);
d543 2
a544 2
	ret = nouveau_object_new(chan, handle++, NV04_GDI_CLASS,
				 NULL, 0, &hw->rect);
d548 14
a561 15
	BEGIN_NV04(push, NV01_SUBC(GDI, OBJECT), 1);
	PUSH_DATA (push, hw->rect->handle);
	BEGIN_NV04(push, NV04_GDI(DMA_NOTIFY), 1);
	PUSH_DATA (push, hw->ntfy->handle);
	BEGIN_NV04(push, NV04_GDI(SURFACE), 1);
	PUSH_DATA (push, hw->surf2d->handle);
	BEGIN_NV04(push, NV04_GDI(ROP), 1);
	PUSH_DATA (push, hw->rop->handle);
	BEGIN_NV04(push, NV04_GDI(PATTERN), 1);
	PUSH_DATA (push, hw->patt->handle);

	BEGIN_NV04(push, NV04_GDI(OPERATION), 1);
	PUSH_DATA (push, NV04_GDI_RECTANGLE_TEXT_OPERATION_ROP_AND);
	BEGIN_NV04(push, NV04_GDI(MONOCHROME_FORMAT), 1);
	PUSH_DATA (push, NV04_GDI_RECTANGLE_TEXT_MONOCHROME_FORMAT_LE);
d565 1
a565 1
		class = NV04_SURFACE_SWZ_CLASS;
d567 1
a567 1
		class = NV20_SURFACE_SWZ_CLASS;
d569 1
a569 1
	ret = nouveau_object_new(chan, handle++, class, NULL, 0, &hw->swzsurf);
a572 3
	BEGIN_NV04(push, NV01_SUBC(SURF, OBJECT), 1);
	PUSH_DATA (push, hw->swzsurf->handle);

d575 1
a575 1
		class = NV04_SIFM_CLASS;
d577 1
a577 1
		class = NV10_SIFM_CLASS;
d579 1
a579 1
	ret = nouveau_object_new(chan, handle++, class, NULL, 0, &hw->sifm);
a582 3
	BEGIN_NV04(push, NV01_SUBC(SIFM, OBJECT), 1);
	PUSH_DATA (push, hw->sifm->handle);

d584 3
a586 2
		BEGIN_NV04(push, NV05_SIFM(COLOR_CONVERSION), 1);
		PUSH_DATA (push, NV05_SCALED_IMAGE_FROM_MEMORY_COLOR_CONVERSION_TRUNCATE);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d37 1
a37 1
swzsurf_format(mesa_format format)
d40 4
a43 4
	case MESA_FORMAT_A_UNORM8:
	case MESA_FORMAT_L_UNORM8:
	case MESA_FORMAT_I_UNORM8:
	case MESA_FORMAT_B2G3R3_UNORM:
d46 9
a54 9
	case MESA_FORMAT_B5G6R5_UNORM:
	case MESA_FORMAT_R5G6B5_UNORM:
	case MESA_FORMAT_B4G4R4A4_UNORM:
	case MESA_FORMAT_A4R4G4B4_UNORM:
	case MESA_FORMAT_B5G5R5A1_UNORM:
	case MESA_FORMAT_A1B5G5R5_UNORM:
	case MESA_FORMAT_A1R5G5B5_UNORM:
	case MESA_FORMAT_L8A8_UNORM:
	case MESA_FORMAT_A8L8_UNORM:
d57 1
a57 1
	case MESA_FORMAT_Z_UNORM16:
d60 8
a67 8
	case MESA_FORMAT_A8B8G8R8_UNORM:
	case MESA_FORMAT_R8G8B8A8_UNORM:
	case MESA_FORMAT_B8G8R8X8_UNORM:
	case MESA_FORMAT_B8G8R8A8_UNORM:
	case MESA_FORMAT_A8R8G8B8_UNORM:
	case MESA_FORMAT_Z24_UNORM_S8_UINT:
	case MESA_FORMAT_S8_UINT_Z24_UNORM:
	case MESA_FORMAT_Z_UNORM32:
d76 1
a76 1
surf2d_format(mesa_format format)
d79 4
a82 4
	case MESA_FORMAT_A_UNORM8:
	case MESA_FORMAT_L_UNORM8:
	case MESA_FORMAT_I_UNORM8:
	case MESA_FORMAT_B2G3R3_UNORM:
d85 9
a93 9
	case MESA_FORMAT_B5G6R5_UNORM:
	case MESA_FORMAT_R5G6B5_UNORM:
	case MESA_FORMAT_B4G4R4A4_UNORM:
	case MESA_FORMAT_A4R4G4B4_UNORM:
	case MESA_FORMAT_B5G5R5A1_UNORM:
	case MESA_FORMAT_A1B5G5R5_UNORM:
	case MESA_FORMAT_A1R5G5B5_UNORM:
	case MESA_FORMAT_L8A8_UNORM:
	case MESA_FORMAT_A8L8_UNORM:
d96 1
a96 1
	case MESA_FORMAT_Z_UNORM16:
d99 8
a106 8
	case MESA_FORMAT_A8B8G8R8_UNORM:
	case MESA_FORMAT_R8G8B8A8_UNORM:
	case MESA_FORMAT_B8G8R8X8_UNORM:
	case MESA_FORMAT_B8G8R8A8_UNORM:
	case MESA_FORMAT_A8R8G8B8_UNORM:
	case MESA_FORMAT_Z24_UNORM_S8_UINT:
	case MESA_FORMAT_S8_UINT_Z24_UNORM:
	case MESA_FORMAT_Z_UNORM32:
d115 1
a115 1
rect_format(mesa_format format)
d118 4
a121 4
	case MESA_FORMAT_A_UNORM8:
	case MESA_FORMAT_L_UNORM8:
	case MESA_FORMAT_I_UNORM8:
	case MESA_FORMAT_B2G3R3_UNORM:
d124 9
a132 9
	case MESA_FORMAT_B5G6R5_UNORM:
	case MESA_FORMAT_R5G6B5_UNORM:
	case MESA_FORMAT_B4G4R4A4_UNORM:
	case MESA_FORMAT_A4R4G4B4_UNORM:
	case MESA_FORMAT_B5G5R5A1_UNORM:
	case MESA_FORMAT_A1B5G5R5_UNORM:
	case MESA_FORMAT_A1R5G5B5_UNORM:
	case MESA_FORMAT_L8A8_UNORM:
	case MESA_FORMAT_A8L8_UNORM:
d135 1
a135 1
	case MESA_FORMAT_Z_UNORM16:
d138 8
a145 8
	case MESA_FORMAT_A8B8G8R8_UNORM:
	case MESA_FORMAT_R8G8B8A8_UNORM:
	case MESA_FORMAT_B8G8R8X8_UNORM:
	case MESA_FORMAT_B8G8R8A8_UNORM:
	case MESA_FORMAT_A8R8G8B8_UNORM:
	case MESA_FORMAT_Z24_UNORM_S8_UINT:
	case MESA_FORMAT_S8_UINT_Z24_UNORM:
	case MESA_FORMAT_Z_UNORM32:
d154 1
a154 1
sifm_format(mesa_format format)
d157 4
a160 4
	case MESA_FORMAT_A_UNORM8:
	case MESA_FORMAT_L_UNORM8:
	case MESA_FORMAT_I_UNORM8:
	case MESA_FORMAT_B2G3R3_UNORM:
d163 9
a171 9
	case MESA_FORMAT_B5G6R5_UNORM:
	case MESA_FORMAT_R5G6B5_UNORM:
	case MESA_FORMAT_B4G4R4A4_UNORM:
	case MESA_FORMAT_A4R4G4B4_UNORM:
	case MESA_FORMAT_B5G5R5A1_UNORM:
	case MESA_FORMAT_A1B5G5R5_UNORM:
	case MESA_FORMAT_A1R5G5B5_UNORM:
	case MESA_FORMAT_L8A8_UNORM:
	case MESA_FORMAT_A8L8_UNORM:
d174 1
a174 1
	case MESA_FORMAT_Z_UNORM16:
d177 8
a184 8
	case MESA_FORMAT_A8B8G8R8_UNORM:
	case MESA_FORMAT_R8G8B8A8_UNORM:
	case MESA_FORMAT_B8G8R8X8_UNORM:
	case MESA_FORMAT_B8G8R8A8_UNORM:
	case MESA_FORMAT_A8R8G8B8_UNORM:
	case MESA_FORMAT_Z24_UNORM_S8_UINT:
	case MESA_FORMAT_S8_UINT_Z24_UNORM:
	case MESA_FORMAT_Z_UNORM32:
@


