head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.4
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@// @;


1.7
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.6;
commitid	TnlogFl9nOv2eaRf;

1.6
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.5;
commitid	4ry2gvZGMXkCUD2n;

1.5
date	2015.01.25.14.41.20;	author jsg;	state Exp;
branches;
next	1.4;
commitid	mcxB0JvoI9gTDYXU;

1.4
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.3;
commitid	WPD6rgPryPkvXOr9;

1.3
date	2013.09.05.14.04.18;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.34;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.50;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.11.39;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.48.45;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.7
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *
 */

#include "brw_fs.h"
#include "glsl/glsl_types.h"
#include "glsl/ir_optimization.h"

static void
assign_reg(int *reg_hw_locations, fs_reg *reg, int reg_width)
{
   if (reg->file == GRF) {
      assert(reg->reg_offset >= 0);
      reg->reg = reg_hw_locations[reg->reg] + reg->reg_offset * reg_width;
      reg->reg_offset = 0;
   }
}

void
fs_visitor::assign_regs_trivial()
{
   int hw_reg_mapping[this->virtual_grf_count + 1];
   int i;
   int reg_width = dispatch_width / 8;

   /* Note that compressed instructions require alignment to 2 registers. */
   hw_reg_mapping[0] = ALIGN(this->first_non_payload_grf, reg_width);
   for (i = 1; i <= this->virtual_grf_count; i++) {
      hw_reg_mapping[i] = (hw_reg_mapping[i - 1] +
			   this->virtual_grf_sizes[i - 1] * reg_width);
   }
   this->grf_used = hw_reg_mapping[this->virtual_grf_count];

   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      assign_reg(hw_reg_mapping, &inst->dst, reg_width);
      assign_reg(hw_reg_mapping, &inst->src[0], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[1], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[2], reg_width);
   }

   if (this->grf_used >= max_grf) {
      fail("Ran out of regs on trivial allocator (%d/%d)\n",
	   this->grf_used, max_grf);
   }

}

static void
brw_alloc_reg_set(struct intel_screen *screen, int reg_width)
{
   const struct brw_device_info *devinfo = screen->devinfo;
   int base_reg_count = BRW_MAX_GRF / reg_width;
   int index = reg_width - 1;

   /* The registers used to make up almost all values handled in the compiler
    * are a scalar value occupying a single register (or 2 registers in the
    * case of SIMD16, which is handled by dividing base_reg_count by 2 and
    * multiplying allocated register numbers by 2).  Things that were
    * aggregates of scalar values at the GLSL level were split to scalar
    * values by split_virtual_grfs().
    *
    * However, texture SEND messages return a series of contiguous registers
    * to write into.  We currently always ask for 4 registers, but we may
    * convert that to use less some day.
    *
    * Additionally, on gen5 we need aligned pairs of registers for the PLN
    * instruction, and on gen4 we need 8 contiguous regs for workaround simd16
    * texturing.
    *
    * So we have a need for classes for 1, 2, 4, and 8 registers currently,
    * and we add in '3' to make indexing the array easier for the common case
    * (since we'll probably want it for texturing later).
    *
    * And, on gen7 and newer, we do texturing SEND messages from GRFs, which
    * means that we may need any size up to the sampler message size limit (11
    * regs).
    */
   int class_count;
   int class_sizes[BRW_MAX_MRF];

   if (devinfo->gen >= 7) {
      for (class_count = 0; class_count < MAX_SAMPLER_MESSAGE_SIZE;
           class_count++)
         class_sizes[class_count] = class_count + 1;
   } else {
      for (class_count = 0; class_count < 4; class_count++)
         class_sizes[class_count] = class_count + 1;
      class_sizes[class_count++] = 8;
   }

   /* Compute the total number of registers across all classes. */
   int ra_reg_count = 0;
   for (int i = 0; i < class_count; i++) {
      ra_reg_count += base_reg_count - (class_sizes[i] - 1);
   }

   uint8_t *ra_reg_to_grf = ralloc_array(screen, uint8_t, ra_reg_count);
   struct ra_regs *regs = ra_alloc_reg_set(screen, ra_reg_count);
   if (devinfo->gen >= 6)
      ra_set_allocate_round_robin(regs);
   int *classes = ralloc_array(screen, int, class_count);
   int aligned_pairs_class = -1;

   /* Now, add the registers to their classes, and add the conflicts
    * between them and the base GRF registers (and also each other).
    */
   int reg = 0;
   int pairs_base_reg = 0;
   int pairs_reg_count = 0;
   for (int i = 0; i < class_count; i++) {
      int class_reg_count = base_reg_count - (class_sizes[i] - 1);
      classes[i] = ra_alloc_reg_class(regs);

      /* Save this off for the aligned pair class at the end. */
      if (class_sizes[i] == 2) {
	 pairs_base_reg = reg;
	 pairs_reg_count = class_reg_count;
      }

      for (int j = 0; j < class_reg_count; j++) {
	 ra_class_add_reg(regs, classes[i], reg);

	 ra_reg_to_grf[reg] = j;

	 for (int base_reg = j;
	      base_reg < j + class_sizes[i];
	      base_reg++) {
	    ra_add_transitive_reg_conflict(regs, base_reg, reg);
	 }

	 reg++;
      }
   }
   assert(reg == ra_reg_count);

   /* Add a special class for aligned pairs, which we'll put delta_x/y
    * in on gen5 so that we can do PLN.
    */
   if (devinfo->has_pln && reg_width == 1 && devinfo->gen < 6) {
      aligned_pairs_class = ra_alloc_reg_class(regs);

      for (int i = 0; i < pairs_reg_count; i++) {
	 if ((ra_reg_to_grf[pairs_base_reg + i] & 1) == 0) {
	    ra_class_add_reg(regs, aligned_pairs_class, pairs_base_reg + i);
	 }
      }
   }

   ra_set_finalize(regs, NULL);

   screen->wm_reg_sets[index].regs = regs;
   for (unsigned i = 0; i < ARRAY_SIZE(screen->wm_reg_sets[index].classes); i++)
      screen->wm_reg_sets[index].classes[i] = -1;
   for (int i = 0; i < class_count; i++)
      screen->wm_reg_sets[index].classes[class_sizes[i] - 1] = classes[i];
   screen->wm_reg_sets[index].ra_reg_to_grf = ra_reg_to_grf;
   screen->wm_reg_sets[index].aligned_pairs_class = aligned_pairs_class;
}

void
brw_fs_alloc_reg_sets(struct intel_screen *screen)
{
   brw_alloc_reg_set(screen, 1);
   brw_alloc_reg_set(screen, 2);
}

int
count_to_loop_end(fs_inst *do_inst)
{
   int depth = 1;
   int ip = 1;
   for (fs_inst *inst = (fs_inst *)do_inst->next;
        depth > 0;
        inst = (fs_inst *)inst->next) {
      switch (inst->opcode) {
      case BRW_OPCODE_DO:
         depth++;
         break;
      case BRW_OPCODE_WHILE:
         depth--;
         break;
      default:
         break;
      }
      ip++;
   }
   return ip;
}

/**
 * Sets up interference between thread payload registers and the virtual GRFs
 * to be allocated for program temporaries.
 *
 * We want to be able to reallocate the payload for our virtual GRFs, notably
 * because the setup coefficients for a full set of 16 FS inputs takes up 8 of
 * our 128 registers.
 *
 * The layout of the payload registers is:
 *
 * 0..nr_payload_regs-1: fixed function setup (including bary coordinates).
 * nr_payload_regs..nr_payload_regs+curb_read_lengh-1: uniform data
 * nr_payload_regs+curb_read_lengh..first_non_payload_grf-1: setup coefficients.
 *
 * And we have payload_node_count nodes covering these registers in order
 * (note that in SIMD16, a node is two registers).
 */
void
fs_visitor::setup_payload_interference(struct ra_graph *g,
                                       int payload_node_count,
                                       int first_payload_node)
{
   int reg_width = dispatch_width / 8;
   int loop_depth = 0;
   int loop_end_ip = 0;

   int payload_last_use_ip[payload_node_count];
   memset(payload_last_use_ip, 0, sizeof(payload_last_use_ip));
   int ip = 0;
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      switch (inst->opcode) {
      case BRW_OPCODE_DO:
         loop_depth++;

         /* Since payload regs are deffed only at the start of the shader
          * execution, any uses of the payload within a loop mean the live
          * interval extends to the end of the outermost loop.  Find the ip of
          * the end now.
          */
         if (loop_depth == 1)
            loop_end_ip = ip + count_to_loop_end(inst);
         break;
      case BRW_OPCODE_WHILE:
         loop_depth--;
         break;
      default:
         break;
      }

      int use_ip;
      if (loop_depth > 0)
         use_ip = loop_end_ip;
      else
         use_ip = ip;

      /* Note that UNIFORM args have been turned into FIXED_HW_REG by
       * assign_curbe_setup(), and interpolation uses fixed hardware regs from
       * the start (see interp_reg()).
       */
      for (int i = 0; i < 3; i++) {
         if (inst->src[i].file == HW_REG &&
             inst->src[i].fixed_hw_reg.file == BRW_GENERAL_REGISTER_FILE) {
            int node_nr = inst->src[i].fixed_hw_reg.nr / reg_width;
            if (node_nr >= payload_node_count)
               continue;

            payload_last_use_ip[node_nr] = use_ip;
         }
      }

      /* Special case instructions which have extra implied registers used. */
      switch (inst->opcode) {
      case FS_OPCODE_FB_WRITE:
         /* We could omit this for the !inst->header_present case, except that
          * the simulator apparently incorrectly reads from g0/g1 instead of
          * sideband.  It also really freaks out driver developers to see g0
          * used in unusual places, so just always reserve it.
          */
         payload_last_use_ip[0 / reg_width] = use_ip;
         payload_last_use_ip[1 / reg_width] = use_ip;
         break;

      case FS_OPCODE_LINTERP:
         /* On gen6+ in SIMD16, there are 4 adjacent registers (so 2 nodes)
          * used by PLN's sourcing of the deltas, while we list only the first
          * two in the arguments (1 node).  Pre-gen6, the deltas are computed
          * in normal VGRFs.
          */
         if (brw->gen >= 6) {
            int delta_x_arg = 0;
            if (inst->src[delta_x_arg].file == HW_REG &&
                inst->src[delta_x_arg].fixed_hw_reg.file ==
                BRW_GENERAL_REGISTER_FILE) {
               int sechalf_node = (inst->src[delta_x_arg].fixed_hw_reg.nr /
                                   reg_width) + 1;
               assert(sechalf_node < payload_node_count);
               payload_last_use_ip[sechalf_node] = use_ip;
            }
         }
         break;

      default:
         break;
      }

      ip++;
   }

   for (int i = 0; i < payload_node_count; i++) {
      /* Mark the payload node as interfering with any virtual grf that is
       * live between the start of the program and our last use of the payload
       * node.
       */
      for (int j = 0; j < this->virtual_grf_count; j++) {
         /* Note that we use a <= comparison, unlike virtual_grf_interferes(),
          * in order to not have to worry about the uniform issue described in
          * calculate_live_intervals().
          */
         if (this->virtual_grf_start[j] <= payload_last_use_ip[i]) {
            ra_add_node_interference(g, first_payload_node + i, j);
         }
      }
   }

   for (int i = 0; i < payload_node_count; i++) {
      /* Mark each payload node as being allocated to its physical register.
       *
       * The alternative would be to have per-physical-register classes, which
       * would just be silly.
       */
      ra_set_node_reg(g, first_payload_node + i, i);
   }
}

/**
 * Sets the mrf_used array to indicate which MRFs are used by the shader IR
 *
 * This is used in assign_regs() to decide which of the GRFs that we use as
 * MRFs on gen7 get normally register allocated, and in register spilling to
 * see if we can actually use MRFs to do spills without overwriting normal MRF
 * contents.
 */
void
fs_visitor::get_used_mrfs(bool *mrf_used)
{
   int reg_width = dispatch_width / 8;

   memset(mrf_used, 0, BRW_MAX_MRF * sizeof(bool));

   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      if (inst->dst.file == MRF) {
         int reg = inst->dst.reg & ~BRW_MRF_COMPR4;
         mrf_used[reg] = true;
         if (reg_width == 2) {
            if (inst->dst.reg & BRW_MRF_COMPR4) {
               mrf_used[reg + 4] = true;
            } else {
               mrf_used[reg + 1] = true;
            }
         }
      }

      if (inst->mlen > 0) {
	 for (int i = 0; i < implied_mrf_writes(inst); i++) {
            mrf_used[inst->base_mrf + i] = true;
         }
      }
   }
}

/**
 * Sets interference between virtual GRFs and usage of the high GRFs for SEND
 * messages (treated as MRFs in code generation).
 */
void
fs_visitor::setup_mrf_hack_interference(struct ra_graph *g, int first_mrf_node)
{
   int reg_width = dispatch_width / 8;

   bool mrf_used[BRW_MAX_MRF];
   get_used_mrfs(mrf_used);

   for (int i = 0; i < BRW_MAX_MRF; i++) {
      /* Mark each MRF reg node as being allocated to its physical register.
       *
       * The alternative would be to have per-physical-register classes, which
       * would just be silly.
       */
      ra_set_node_reg(g, first_mrf_node + i,
                      (GEN7_MRF_HACK_START + i) / reg_width);

      /* Since we don't have any live/dead analysis on the MRFs, just mark all
       * that are used as conflicting with all virtual GRFs.
       */
      if (mrf_used[i]) {
         for (int j = 0; j < this->virtual_grf_count; j++) {
            ra_add_node_interference(g, first_mrf_node + i, j);
         }
      }
   }
}

bool
fs_visitor::assign_regs(bool allow_spilling)
{
   struct intel_screen *screen = brw->intelScreen;
   /* Most of this allocation was written for a reg_width of 1
    * (dispatch_width == 8).  In extending to SIMD16, the code was
    * left in place and it was converted to have the hardware
    * registers it's allocating be contiguous physical pairs of regs
    * for reg_width == 2.
    */
   int reg_width = dispatch_width / 8;
   int hw_reg_mapping[this->virtual_grf_count];
   int payload_node_count = (ALIGN(this->first_non_payload_grf, reg_width) /
                            reg_width);
   int rsi = reg_width - 1; /* Which screen->wm_reg_sets[] to use */
   calculate_live_intervals();

   int node_count = this->virtual_grf_count;
   int first_payload_node = node_count;
   node_count += payload_node_count;
   int first_mrf_hack_node = node_count;
   if (brw->gen >= 7)
      node_count += BRW_MAX_GRF - GEN7_MRF_HACK_START;
   struct ra_graph *g = ra_alloc_interference_graph(screen->wm_reg_sets[rsi].regs,
                                                    node_count);

   for (int i = 0; i < this->virtual_grf_count; i++) {
      unsigned size = this->virtual_grf_sizes[i];
      int c;

      assert(size <= ARRAY_SIZE(screen->wm_reg_sets[rsi].classes) &&
             "Register allocation relies on split_virtual_grfs()");
      c = screen->wm_reg_sets[rsi].classes[size - 1];

      /* Special case: on pre-GEN6 hardware that supports PLN, the
       * second operand of a PLN instruction needs to be an
       * even-numbered register, so we have a special register class
       * wm_aligned_pairs_class to handle this case.  pre-GEN6 always
       * uses this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC] as the
       * second operand of a PLN instruction (since it doesn't support
       * any other interpolation modes).  So all we need to do is find
       * that register and set it to the appropriate class.
       */
      if (screen->wm_reg_sets[rsi].aligned_pairs_class >= 0 &&
          this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC].reg == i) {
         c = screen->wm_reg_sets[rsi].aligned_pairs_class;
      }

      ra_set_node_class(g, i, c);

      for (int j = 0; j < i; j++) {
	 if (virtual_grf_interferes(i, j)) {
	    ra_add_node_interference(g, i, j);
	 }
      }
   }

   setup_payload_interference(g, payload_node_count, first_payload_node);
   if (brw->gen >= 7)
      setup_mrf_hack_interference(g, first_mrf_hack_node);

   /* Debug of register spilling: Go spill everything. */
   if (0) {
      int reg = choose_spill_reg(g);

      if (reg != -1) {
         spill_reg(reg);
         ralloc_free(g);
         return false;
      }
   }

   if (!ra_allocate_no_spills(g)) {
      /* Failed to allocate registers.  Spill a reg, and the caller will
       * loop back into here to try again.
       */
      int reg = choose_spill_reg(g);

      if (reg == -1) {
         fail("no register to spill:\n");
         dump_instructions();
      } else if (allow_spilling) {
         spill_reg(reg);
      }

      ralloc_free(g);

      return false;
   }

   /* Get the chosen virtual registers for each node, and map virtual
    * regs in the register classes back down to real hardware reg
    * numbers.
    */
   this->grf_used = payload_node_count * reg_width;
   for (int i = 0; i < this->virtual_grf_count; i++) {
      int reg = ra_get_node_reg(g, i);

      hw_reg_mapping[i] = screen->wm_reg_sets[rsi].ra_reg_to_grf[reg] * reg_width;
      this->grf_used = MAX2(this->grf_used,
			    hw_reg_mapping[i] + this->virtual_grf_sizes[i] *
			    reg_width);
   }

   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      assign_reg(hw_reg_mapping, &inst->dst, reg_width);
      assign_reg(hw_reg_mapping, &inst->src[0], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[1], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[2], reg_width);
   }

   ralloc_free(g);

   return true;
}

void
fs_visitor::emit_unspill(fs_inst *inst, fs_reg dst, uint32_t spill_offset,
                         int count)
{
   for (int i = 0; i < count; i++) {
      /* The gen7 descriptor-based offset is 12 bits of HWORD units. */
      bool gen7_read = brw->gen >= 7 && spill_offset < (1 << 12) * REG_SIZE;

      fs_inst *unspill_inst =
         new(mem_ctx) fs_inst(gen7_read ?
                              SHADER_OPCODE_GEN7_SCRATCH_READ :
                              SHADER_OPCODE_GEN4_SCRATCH_READ,
                              dst);
      unspill_inst->offset = spill_offset;
      unspill_inst->ir = inst->ir;
      unspill_inst->annotation = inst->annotation;

      if (!gen7_read) {
         unspill_inst->base_mrf = 14;
         unspill_inst->mlen = 1; /* header contains offset */
      }
      inst->insert_before(unspill_inst);

      dst.reg_offset++;
      spill_offset += dispatch_width * sizeof(float);
   }
}

int
fs_visitor::choose_spill_reg(struct ra_graph *g)
{
   float loop_scale = 1.0;
   float spill_costs[this->virtual_grf_count];
   bool no_spill[this->virtual_grf_count];

   for (int i = 0; i < this->virtual_grf_count; i++) {
      spill_costs[i] = 0.0;
      no_spill[i] = false;
   }

   /* Calculate costs for spilling nodes.  Call it a cost of 1 per
    * spill/unspill we'll have to do, and guess that the insides of
    * loops run 10 times.
    */
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      for (unsigned int i = 0; i < 3; i++) {
	 if (inst->src[i].file == GRF) {
	    spill_costs[inst->src[i].reg] += loop_scale;

            /* Register spilling logic assumes full-width registers; smeared
             * registers have a width of 1 so if we try to spill them we'll
             * generate invalid assembly.  This shouldn't be a problem because
             * smeared registers are only used as short-term temporaries when
             * loading pull constants, so spilling them is unlikely to reduce
             * register pressure anyhow.
             */
            if (!inst->src[i].is_contiguous()) {
               no_spill[inst->src[i].reg] = true;
            }
	 }
      }

      if (inst->dst.file == GRF) {
	 spill_costs[inst->dst.reg] += inst->regs_written * loop_scale;

         if (!inst->dst.is_contiguous()) {
            no_spill[inst->dst.reg] = true;
         }
      }

      switch (inst->opcode) {

      case BRW_OPCODE_DO:
	 loop_scale *= 10;
	 break;

      case BRW_OPCODE_WHILE:
	 loop_scale /= 10;
	 break;

      case SHADER_OPCODE_GEN4_SCRATCH_WRITE:
	 if (inst->src[0].file == GRF)
	    no_spill[inst->src[0].reg] = true;
	 break;

      case SHADER_OPCODE_GEN4_SCRATCH_READ:
      case SHADER_OPCODE_GEN7_SCRATCH_READ:
	 if (inst->dst.file == GRF)
	    no_spill[inst->dst.reg] = true;
	 break;

      default:
	 break;
      }
   }

   for (int i = 0; i < this->virtual_grf_count; i++) {
      if (!no_spill[i])
	 ra_set_node_spill_cost(g, i, spill_costs[i]);
   }

   return ra_get_best_spill_node(g);
}

void
fs_visitor::spill_reg(int spill_reg)
{
   int reg_size = dispatch_width * sizeof(float);
   int size = virtual_grf_sizes[spill_reg];
   unsigned int spill_offset = c->last_scratch;
   assert(ALIGN(spill_offset, 16) == spill_offset); /* oword read/write req. */
   int spill_base_mrf = dispatch_width > 8 ? 13 : 14;

   /* Spills may use MRFs 13-15 in the SIMD16 case.  Our texturing is done
    * using up to 11 MRFs starting from either m1 or m2, and fb writes can use
    * up to m13 (gen6+ simd16: 2 header + 8 color + 2 src0alpha + 2 omask) or
    * m15 (gen4-5 simd16: 2 header + 8 color + 1 aads + 2 src depth + 2 dst
    * depth), starting from m1.  In summary: We may not be able to spill in
    * SIMD16 mode, because we'd stomp the FB writes.
    */
   if (!spilled_any_registers) {
      bool mrf_used[BRW_MAX_MRF];
      get_used_mrfs(mrf_used);

      for (int i = spill_base_mrf; i < BRW_MAX_MRF; i++) {
         if (mrf_used[i]) {
            fail("Register spilling not supported with m%d used", i);
          return;
         }
      }

      spilled_any_registers = true;
   }

   c->last_scratch += size * reg_size;

   /* Generate spill/unspill instructions for the objects being
    * spilled.  Right now, we spill or unspill the whole thing to a
    * virtual grf of the same size.  For most instructions, though, we
    * could just spill/unspill the GRF being accessed.
    */
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      for (unsigned int i = 0; i < 3; i++) {
	 if (inst->src[i].file == GRF &&
	     inst->src[i].reg == spill_reg) {
            int regs_read = inst->regs_read(this, i);
            int subset_spill_offset = (spill_offset +
                                       reg_size * inst->src[i].reg_offset);
            fs_reg unspill_dst(GRF, virtual_grf_alloc(regs_read));

            inst->src[i].reg = unspill_dst.reg;
            inst->src[i].reg_offset = 0;

            emit_unspill(inst, unspill_dst, subset_spill_offset, regs_read);
	 }
      }

      if (inst->dst.file == GRF &&
	  inst->dst.reg == spill_reg) {
         int subset_spill_offset = (spill_offset +
                                    reg_size * inst->dst.reg_offset);
         fs_reg spill_src(GRF, virtual_grf_alloc(inst->regs_written));

         inst->dst.reg = spill_src.reg;
         inst->dst.reg_offset = 0;

	 /* If our write is going to affect just part of the
          * inst->regs_written(), then we need to unspill the destination
          * since we write back out all of the regs_written().
	  */
	 if (inst->predicate || inst->force_uncompressed ||
             inst->force_sechalf || inst->dst.subreg_offset) {
            emit_unspill(inst, spill_src, subset_spill_offset,
                         inst->regs_written);
	 }

	 for (int chan = 0; chan < inst->regs_written; chan++) {
	    fs_inst *spill_inst =
               new(mem_ctx) fs_inst(SHADER_OPCODE_GEN4_SCRATCH_WRITE,
                                    reg_null_f, spill_src);
	    spill_src.reg_offset++;
	    spill_inst->offset = subset_spill_offset + chan * reg_size;
	    spill_inst->ir = inst->ir;
	    spill_inst->annotation = inst->annotation;
	    spill_inst->mlen = 1 + dispatch_width / 8; /* header, value */
	    spill_inst->base_mrf = spill_base_mrf;
	    inst->insert_after(spill_inst);
	 }
      }
   }

   invalidate_live_intervals();
}
@


1.6
log
@Merge Mesa 10.2.9
@
text
@@


1.5
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a28 1
#include "brw_cfg.h"
d33 1
a33 1
assign_reg(int *reg_hw_locations, fs_reg *reg)
d37 1
a37 1
      reg->reg = reg_hw_locations[reg->reg] + reg->reg_offset;
d53 1
a53 1
			   this->virtual_grf_sizes[i - 1]);
d57 7
a63 5
   foreach_block_and_inst(block, fs_inst, inst, cfg) {
      assign_reg(hw_reg_mapping, &inst->dst);
      for (i = 0; i < inst->sources; i++) {
         assign_reg(hw_reg_mapping, &inst->src[i]);
      }
a68 2
   } else {
      this->virtual_grf_count = this->grf_used;
d77 1
a77 1
   int base_reg_count = BRW_MAX_GRF;
d104 1
a104 1
   int class_sizes[MAX_VGRF_SIZE];
d107 2
a108 1
      for (class_count = 0; class_count < MAX_VGRF_SIZE; class_count++)
a115 4
   memset(screen->wm_reg_sets[index].class_to_ra_reg_range, 0,
          sizeof(screen->wm_reg_sets[index].class_to_ra_reg_range));
   int *class_to_ra_reg_range = screen->wm_reg_sets[index].class_to_ra_reg_range;

d119 1
a119 23
      if (devinfo->gen <= 5 && reg_width == 2) {
         /* From the G45 PRM:
          *
          * In order to reduce the hardware complexity, the following
          * rules and restrictions apply to the compressed instruction:
          * ...
          * * Operand Alignment Rule: With the exceptions listed below, a
          *   source/destination operand in general should be aligned to
          *   even 256-bit physical register with a region size equal to
          *   two 256-bit physical register
          */
         ra_reg_count += (base_reg_count - (class_sizes[i] - 1)) / 2;
      } else {
         ra_reg_count += base_reg_count - (class_sizes[i] - 1);
      }
      /* Mark the last register. We'll fill in the beginnings later. */
      class_to_ra_reg_range[class_sizes[i]] = ra_reg_count;
   }

   /* Fill out the rest of the range markers */
   for (int i = 1; i < 17; ++i) {
      if (class_to_ra_reg_range[i] == 0)
         class_to_ra_reg_range[i] = class_to_ra_reg_range[i-1];
a128 7
   /* Allocate space for q values.  We allocate class_count + 1 because we
    * want to leave room for the aligned pairs class if we have it. */
   unsigned int **q_values = ralloc_array(screen, unsigned int *,
                                          class_count + 1);
   for (int i = 0; i < class_count + 1; ++i)
      q_values[i] = ralloc_array(q_values, unsigned int, class_count + 1);

d136 1
a136 39
      int class_reg_count;
      if (devinfo->gen <= 5 && reg_width == 2) {
         class_reg_count = (base_reg_count - (class_sizes[i] - 1)) / 2;

         /* See comment below.  The only difference here is that we are
          * dealing with pairs of registers instead of single registers.
          * Registers of odd sizes simply get rounded up. */
         for (int j = 0; j < class_count; j++)
            q_values[i][j] = (class_sizes[i] + 1) / 2 +
                             (class_sizes[j] + 1) / 2 - 1;
      } else {
         class_reg_count = base_reg_count - (class_sizes[i] - 1);

         /* From register_allocate.c:
          *
          * q(B,C) (indexed by C, B is this register class) in
          * Runeson/NystrÃ¶m paper.  This is "how many registers of B could
          * the worst choice register from C conflict with".
          *
          * If we just let the register allocation algorithm compute these
          * values, is extremely expensive.  However, since all of our
          * registers are laid out, we can very easily compute them
          * ourselves.  View the register from C as fixed starting at GRF n
          * somwhere in the middle, and the register from B as sliding back
          * and forth.  Then the first register to conflict from B is the
          * one starting at n - class_size[B] + 1 and the last register to
          * conflict will start at n + class_size[B] - 1.  Therefore, the
          * number of conflicts from B is class_size[B] + class_size[C] - 1.
          *
          *   +-+-+-+-+-+-+     +-+-+-+-+-+-+
          * B | | | | | |n| --> | | | | | | |
          *   +-+-+-+-+-+-+     +-+-+-+-+-+-+
          *             +-+-+-+-+-+
          * C           |n| | | | |
          *             +-+-+-+-+-+
          */
         for (int j = 0; j < class_count; j++)
            q_values[i][j] = class_sizes[i] + class_sizes[j] - 1;
      }
d141 2
a142 2
         pairs_base_reg = reg;
         pairs_reg_count = class_reg_count;
d145 2
a146 3
      if (devinfo->gen <= 5 && reg_width == 2) {
         for (int j = 0; j < class_reg_count; j++) {
            ra_class_add_reg(regs, classes[i], reg);
d148 1
a148 1
            ra_reg_to_grf[reg] = j * 2;
d150 5
a154 19
            for (int base_reg = j;
                 base_reg < j + (class_sizes[i] + 1) / 2;
                 base_reg++) {
               ra_add_transitive_reg_conflict(regs, base_reg, reg);
            }

            reg++;
         }
      } else {
         for (int j = 0; j < class_reg_count; j++) {
            ra_class_add_reg(regs, classes[i], reg);

            ra_reg_to_grf[reg] = j;

            for (int base_reg = j;
                 base_reg < j + class_sizes[i];
                 base_reg++) {
               ra_add_transitive_reg_conflict(regs, base_reg, reg);
            }
d156 1
a156 2
            reg++;
         }
a171 12

      for (int i = 0; i < class_count; i++) {
         /* These are a little counter-intuitive because the pair registers
          * are required to be aligned while the register they are
          * potentially interferring with are not.  In the case where the
          * size is even, the worst-case is that the register is
          * odd-aligned.  In the odd-size case, it doesn't matter.
          */
         q_values[class_count][i] = class_sizes[i] / 2 + 1;
         q_values[i][class_count] = class_sizes[i] + 1;
      }
      q_values[class_count][class_count] = 1;
d174 1
a174 3
   ra_set_finalize(regs, q_values);

   ralloc_free(q_values);
d192 2
a193 2
static int
count_to_loop_end(const bblock_t *block)
a194 3
   if (block->end()->opcode == BRW_OPCODE_WHILE)
      return block->end_ip;

d196 2
a197 4
   /* Skip the first block, since we don't want to count the do the calling
    * function found.
    */
   for (block = block->next();
d199 3
a201 2
        block = block->next()) {
      if (block->start()->opcode == BRW_OPCODE_DO)
d203 2
a204 1
      if (block->end()->opcode == BRW_OPCODE_WHILE) {
d206 3
a208 2
         if (depth == 0)
            return block->end_ip;
d210 1
d212 1
a212 1
   unreachable("not reached");
d225 3
a227 3
 * 0..payload.num_regs-1: fixed function setup (including bary coordinates).
 * payload.num_regs..payload.num_regs+curb_read_lengh-1: uniform data
 * payload.num_regs+curb_read_lengh..first_non_payload_grf-1: setup coefficients.
d237 1
d244 3
a246 1
   foreach_block_and_inst(block, fs_inst, inst, cfg) {
d257 1
a257 1
            loop_end_ip = count_to_loop_end(block);
d276 1
a276 1
      for (int i = 0; i < inst->sources; i++) {
d279 1
a279 1
            int node_nr = inst->src[i].fixed_hw_reg.nr;
d295 2
a296 2
         payload_last_use_ip[0] = use_ip;
         payload_last_use_ip[1] = use_ip;
d300 4
a303 4
         /* On gen6+ in SIMD16, there are 4 adjacent registers used by
          * PLN's sourcing of the deltas, while we list only the first one
          * in the arguments.  Pre-gen6, the deltas are computed in normal
          * VGRFs.
d310 4
a313 5
               for (int i = 1; i < 4; ++i) {
                  int node = inst->src[delta_x_arg].fixed_hw_reg.nr + i;
                  assert(node < payload_node_count);
                  payload_last_use_ip[node] = use_ip;
               }
d347 1
a347 10
      if (brw->intelScreen->devinfo->gen <= 5 && dispatch_width == 16) {
         /* We have to divide by 2 here because we only have even numbered
          * registers.  Some of the payload registers will be odd, but
          * that's ok because their physical register numbers have already
          * been assigned.  The only thing this is used for is interference.
          */
         ra_set_node_reg(g, first_payload_node + i, i / 2);
      } else {
         ra_set_node_reg(g, first_payload_node + i, i);
      }
d366 3
a368 1
   foreach_block_and_inst(block, fs_inst, inst, cfg) {
d396 2
d407 2
a408 1
      ra_set_node_reg(g, first_mrf_node + i, GEN7_MRF_HACK_START + i);
d433 2
a434 1
   int payload_node_count = ALIGN(this->first_non_payload_grf, reg_width);
a464 1
          this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC].file == GRF &&
d479 1
a479 1
   if (brw->gen >= 7) {
a481 44
      foreach_block_and_inst(block, fs_inst, inst, cfg) {
         /* When we do send-from-GRF for FB writes, we need to ensure that
          * the last write instruction sends from a high register.  This is
          * because the vertex fetcher wants to start filling the low
          * payload registers while the pixel data port is still working on
          * writing out the memory.  If we don't do this, we get rendering
          * artifacts.
          *
          * We could just do "something high".  Instead, we just pick the
          * highest register that works.
          */
         if (inst->opcode == FS_OPCODE_FB_WRITE && inst->eot) {
            int size = virtual_grf_sizes[inst->src[0].reg];
            int reg = screen->wm_reg_sets[rsi].class_to_ra_reg_range[size] - 1;
            ra_set_node_reg(g, inst->src[0].reg, reg);
            break;
         }
      }
   }

   if (dispatch_width > 8) {
      /* In 16-wide dispatch we have an issue where a compressed
       * instruction is actually two instructions executed simultaneiously.
       * It's actually ok to have the source and destination registers be
       * the same.  In this case, each instruction over-writes its own
       * source and there's no problem.  The real problem here is if the
       * source and destination registers are off by one.  Then you can end
       * up in a scenario where the first instruction over-writes the
       * source of the second instruction.  Since the compiler doesn't know
       * about this level of granularity, we simply make the source and
       * destination interfere.
       */
      foreach_block_and_inst(block, fs_inst, inst, cfg) {
         if (inst->dst.file != GRF)
            continue;

         for (int i = 0; i < inst->sources; ++i) {
            if (inst->src[i].file == GRF) {
               ra_add_node_interference(g, inst->dst.reg, inst->src[i].reg);
            }
         }
      }
   }

d493 1
a493 1
   if (!ra_allocate(g)) {
d501 1
a501 1
         dump_instructions(NULL);
d515 1
a515 1
   this->grf_used = payload_node_count;
d519 1
a519 1
      hw_reg_mapping[i] = screen->wm_reg_sets[rsi].ra_reg_to_grf[reg];
d521 2
a522 1
			    hw_reg_mapping[i] + this->virtual_grf_sizes[i]);
d525 7
a531 5
   foreach_block_and_inst(block, fs_inst, inst, cfg) {
      assign_reg(hw_reg_mapping, &inst->dst);
      for (int i = 0; i < inst->sources; i++) {
         assign_reg(hw_reg_mapping, &inst->src[i]);
      }
a533 2
   this->virtual_grf_count = this->grf_used;

d540 2
a541 2
fs_visitor::emit_unspill(bblock_t *block, fs_inst *inst, fs_reg dst,
                         uint32_t spill_offset, int count)
d543 1
a543 7
   int reg_size = 1;
   if (dispatch_width == 16 && count % 2 == 0) {
      reg_size = 2;
      dst.width = 16;
   }

   for (int i = 0; i < count / reg_size; i++) {
a554 1
      unspill_inst->regs_written = reg_size;
d560 1
a560 6
      inst->insert_before(block, unspill_inst);

      dst.reg_offset += reg_size;
      spill_offset += reg_size * REG_SIZE;
   }
}
d562 2
a563 22
void
fs_visitor::emit_spill(bblock_t *block, fs_inst *inst, fs_reg src,
                       uint32_t spill_offset, int count)
{
   int reg_size = 1;
   int spill_base_mrf = 14;
   if (dispatch_width == 16 && count % 2 == 0) {
      spill_base_mrf = 13;
      reg_size = 2;
   }

   for (int i = 0; i < count / reg_size; i++) {
      fs_inst *spill_inst =
         new(mem_ctx) fs_inst(SHADER_OPCODE_GEN4_SCRATCH_WRITE,
                              reg_size * 8, reg_null_f, src);
      src.reg_offset += reg_size;
      spill_inst->offset = spill_offset + i * reg_size * REG_SIZE;
      spill_inst->ir = inst->ir;
      spill_inst->annotation = inst->annotation;
      spill_inst->mlen = 1 + reg_size; /* header, value */
      spill_inst->base_mrf = spill_base_mrf;
      inst->insert_after(block, spill_inst);
d583 4
a586 2
   foreach_block_and_inst(block, fs_inst, inst, cfg) {
      for (unsigned int i = 0; i < inst->sources; i++) {
d648 1
d650 1
a650 1
   unsigned int spill_offset = last_scratch;
d675 1
a675 1
   last_scratch += size * REG_SIZE;
d682 4
a685 2
   foreach_block_and_inst (block, fs_inst, inst, cfg) {
      for (unsigned int i = 0; i < inst->sources; i++) {
d690 1
a690 1
                                       REG_SIZE * inst->src[i].reg_offset);
d696 1
a696 2
            emit_unspill(block, inst, unspill_dst, subset_spill_offset,
                         regs_read);
d703 1
a703 1
                                    REG_SIZE * inst->dst.reg_offset);
a708 8
         /* If we're immediately spilling the register, we should not use
          * destination dependency hints.  Doing so will cause the GPU do
          * try to read and write the register at the same time and may
          * hang the GPU.
          */
         inst->no_dd_clear = false;
         inst->no_dd_check = false;

d713 3
a715 2
	 if (inst->is_partial_write())
            emit_unspill(block, inst, spill_src, subset_spill_offset,
d717 1
d719 12
a730 2
         emit_spill(block, inst, spill_src, subset_spill_offset,
                    inst->regs_written);
@


1.4
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d29 1
d34 1
a34 1
assign_reg(int *reg_hw_locations, fs_reg *reg, int reg_width)
d38 1
a38 1
      reg->reg = reg_hw_locations[reg->reg] + reg->reg_offset * reg_width;
d54 1
a54 1
			   this->virtual_grf_sizes[i - 1] * reg_width);
d58 5
a62 7
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      assign_reg(hw_reg_mapping, &inst->dst, reg_width);
      assign_reg(hw_reg_mapping, &inst->src[0], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[1], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[2], reg_width);
d68 2
d78 1
a78 1
   int base_reg_count = BRW_MAX_GRF / reg_width;
d105 1
a105 1
   int class_sizes[BRW_MAX_MRF];
d108 1
a108 2
      for (class_count = 0; class_count < MAX_SAMPLER_MESSAGE_SIZE;
           class_count++)
d116 4
d123 23
a145 1
      ra_reg_count += base_reg_count - (class_sizes[i] - 1);
d155 7
d169 39
a207 1
      int class_reg_count = base_reg_count - (class_sizes[i] - 1);
d212 2
a213 2
	 pairs_base_reg = reg;
	 pairs_reg_count = class_reg_count;
d216 5
a220 2
      for (int j = 0; j < class_reg_count; j++) {
	 ra_class_add_reg(regs, classes[i], reg);
d222 5
a226 1
	 ra_reg_to_grf[reg] = j;
d228 13
a240 5
	 for (int base_reg = j;
	      base_reg < j + class_sizes[i];
	      base_reg++) {
	    ra_add_transitive_reg_conflict(regs, base_reg, reg);
	 }
d242 2
a243 1
	 reg++;
d259 12
d273 3
a275 1
   ra_set_finalize(regs, NULL);
d293 2
a294 2
int
count_to_loop_end(fs_inst *do_inst)
d296 3
d300 4
a303 2
   int ip = 1;
   for (fs_inst *inst = (fs_inst *)do_inst->next;
d305 2
a306 3
        inst = (fs_inst *)inst->next) {
      switch (inst->opcode) {
      case BRW_OPCODE_DO:
d308 1
a308 2
         break;
      case BRW_OPCODE_WHILE:
d310 2
a311 3
         break;
      default:
         break;
a312 1
      ip++;
d314 1
a314 1
   return ip;
d327 3
a329 3
 * 0..nr_payload_regs-1: fixed function setup (including bary coordinates).
 * nr_payload_regs..nr_payload_regs+curb_read_lengh-1: uniform data
 * nr_payload_regs+curb_read_lengh..first_non_payload_grf-1: setup coefficients.
a338 1
   int reg_width = dispatch_width / 8;
d345 1
a345 3
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

d356 1
a356 1
            loop_end_ip = ip + count_to_loop_end(inst);
d375 1
a375 1
      for (int i = 0; i < 3; i++) {
d378 1
a378 1
            int node_nr = inst->src[i].fixed_hw_reg.nr / reg_width;
d394 2
a395 2
         payload_last_use_ip[0 / reg_width] = use_ip;
         payload_last_use_ip[1 / reg_width] = use_ip;
d399 4
a402 4
         /* On gen6+ in SIMD16, there are 4 adjacent registers (so 2 nodes)
          * used by PLN's sourcing of the deltas, while we list only the first
          * two in the arguments (1 node).  Pre-gen6, the deltas are computed
          * in normal VGRFs.
d409 5
a413 4
               int sechalf_node = (inst->src[delta_x_arg].fixed_hw_reg.nr /
                                   reg_width) + 1;
               assert(sechalf_node < payload_node_count);
               payload_last_use_ip[sechalf_node] = use_ip;
d447 10
a456 1
      ra_set_node_reg(g, first_payload_node + i, i);
d475 1
a475 3
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

a502 2
   int reg_width = dispatch_width / 8;

d512 1
a512 2
      ra_set_node_reg(g, first_mrf_node + i,
                      (GEN7_MRF_HACK_START + i) / reg_width);
d537 1
a537 2
   int payload_node_count = (ALIGN(this->first_non_payload_grf, reg_width) /
                            reg_width);
d568 1
d583 1
a583 1
   if (brw->gen >= 7)
d586 44
d641 1
a641 1
   if (!ra_allocate_no_spills(g)) {
d649 1
a649 1
         dump_instructions();
d663 1
a663 1
   this->grf_used = payload_node_count * reg_width;
d667 1
a667 1
      hw_reg_mapping[i] = screen->wm_reg_sets[rsi].ra_reg_to_grf[reg] * reg_width;
d669 1
a669 2
			    hw_reg_mapping[i] + this->virtual_grf_sizes[i] *
			    reg_width);
d672 6
a677 2
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;
d679 1
a679 5
      assign_reg(hw_reg_mapping, &inst->dst, reg_width);
      assign_reg(hw_reg_mapping, &inst->src[0], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[1], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[2], reg_width);
   }
d687 2
a688 2
fs_visitor::emit_unspill(fs_inst *inst, fs_reg dst, uint32_t spill_offset,
                         int count)
d690 7
a696 1
   for (int i = 0; i < count; i++) {
d708 1
d714 6
a719 1
      inst->insert_before(unspill_inst);
d721 22
a742 2
      dst.reg_offset++;
      spill_offset += dispatch_width * sizeof(float);
d762 2
a763 4
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      for (unsigned int i = 0; i < 3; i++) {
a824 1
   int reg_size = dispatch_width * sizeof(float);
d826 1
a826 1
   unsigned int spill_offset = c->last_scratch;
d851 1
a851 1
   c->last_scratch += size * reg_size;
d858 2
a859 4
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      for (unsigned int i = 0; i < 3; i++) {
d864 1
a864 1
                                       reg_size * inst->src[i].reg_offset);
d870 2
a871 1
            emit_unspill(inst, unspill_dst, subset_spill_offset, regs_read);
d878 1
a878 1
                                    reg_size * inst->dst.reg_offset);
d884 8
d896 2
a897 3
	 if (inst->predicate || inst->force_uncompressed ||
             inst->force_sechalf || inst->dst.subreg_offset) {
            emit_unspill(inst, spill_src, subset_spill_offset,
a898 1
	 }
d900 2
a901 12
	 for (int chan = 0; chan < inst->regs_written; chan++) {
	    fs_inst *spill_inst =
               new(mem_ctx) fs_inst(SHADER_OPCODE_GEN4_SCRATCH_WRITE,
                                    reg_null_f, spill_src);
	    spill_src.reg_offset++;
	    spill_inst->offset = subset_spill_offset + chan * reg_size;
	    spill_inst->ir = inst->ir;
	    spill_inst->annotation = inst->annotation;
	    spill_inst->mlen = 1 + dispatch_width / 8; /* header, value */
	    spill_inst->base_mrf = spill_base_mrf;
	    inst->insert_after(spill_inst);
	 }
@


1.3
log
@Merge Mesa 9.2.0
@
text
@d74 1
a74 1
brw_alloc_reg_set(struct brw_context *brw, int reg_width)
d76 1
d82 1
a82 1
    * case of 16-wide, which is handled by dividing base_reg_count by 2 and
d87 3
a89 3
    * However, texture SEND messages return a series of contiguous registers.
    * We currently always ask for 4 registers, but we may convert that to use
    * less some day.
d98 4
d103 12
a114 2
   const int class_count = 5;
   const int class_sizes[class_count] = {1, 2, 3, 4, 8};
d122 3
a124 3
   uint8_t *ra_reg_to_grf = ralloc_array(brw, uint8_t, ra_reg_count);
   struct ra_regs *regs = ra_alloc_reg_set(brw, ra_reg_count);
   if (brw->gen >= 6)
d126 1
a126 1
   int *classes = ralloc_array(brw, int, class_count);
d164 1
a164 1
   if (brw->has_pln && reg_width == 1 && brw->gen < 6) {
d176 7
a182 4
   brw->wm.reg_sets[index].regs = regs;
   brw->wm.reg_sets[index].classes = classes;
   brw->wm.reg_sets[index].ra_reg_to_grf = ra_reg_to_grf;
   brw->wm.reg_sets[index].aligned_pairs_class = aligned_pairs_class;
d186 1
a186 1
brw_fs_alloc_reg_sets(struct brw_context *brw)
d188 2
a189 2
   brw_alloc_reg_set(brw, 1);
   brw_alloc_reg_set(brw, 2);
d230 1
a230 1
 * (note that in 16-wide, a node is two registers).
d300 1
a300 1
         /* On gen6+ in 16-wide, there are 4 adjacent registers (so 2 nodes)
d352 6
a357 2
 * Sets interference between virtual GRFs and usage of the high GRFs for SEND
 * messages (treated as MRFs in code generation).
d360 1
a360 1
fs_visitor::setup_mrf_hack_interference(struct ra_graph *g, int first_mrf_node)
a361 1
   int mrf_count = BRW_MAX_GRF - GEN7_MRF_HACK_START;
d364 2
a365 3
   /* Identify all the MRFs used in the program. */
   bool mrf_used[mrf_count];
   memset(mrf_used, 0, sizeof(mrf_used));
d387 1
d389 14
a402 2
   for (int i = 0; i < mrf_count; i++) {
      /* Mark each payload reg node as being allocated to its physical register.
d422 1
a422 1
fs_visitor::assign_regs()
d424 1
d426 1
a426 1
    * (dispatch_width == 8).  In extending to 16-wide, the code was
d435 1
a435 1
   int rsi = reg_width - 1; /* Which brw->wm.reg_sets[] to use */
d444 1
a444 1
   struct ra_graph *g = ra_alloc_interference_graph(brw->wm.reg_sets[rsi].regs,
d448 1
a448 1
      int size = this->virtual_grf_sizes[i];
d451 3
a453 8
      if (size == 8) {
         c = 4;
      } else {
         assert(size >= 1 &&
                size <= 4 &&
                "Register allocation relies on split_virtual_grfs()");
         c = brw->wm.reg_sets[rsi].classes[size - 1];
      }
d464 1
a464 1
      if (brw->wm.reg_sets[rsi].aligned_pairs_class >= 0 &&
d466 1
a466 1
         c = brw->wm.reg_sets[rsi].aligned_pairs_class;
d482 11
d502 2
a503 5
      } else if (dispatch_width == 16) {
	 fail("Failure to register allocate.  Reduce number of live scalar "
              "values to avoid this.");
      } else {
	 spill_reg(reg);
a505 1

d519 1
a519 1
      hw_reg_mapping[i] = brw->wm.reg_sets[rsi].ra_reg_to_grf[reg] * reg_width;
d540 2
a541 1
fs_visitor::emit_unspill(fs_inst *inst, fs_reg dst, uint32_t spill_offset)
d543 18
a560 4
   fs_inst *unspill_inst = new(mem_ctx) fs_inst(FS_OPCODE_UNSPILL, dst);
   unspill_inst->offset = spill_offset;
   unspill_inst->ir = inst->ir;
   unspill_inst->annotation = inst->annotation;
d562 3
a564 6
   /* Choose a MRF that won't conflict with an MRF that's live across the
    * spill.  Nothing else will make it up to MRF 14/15.
    */
   unspill_inst->base_mrf = 14;
   unspill_inst->mlen = 1; /* header contains offset */
   inst->insert_before(unspill_inst);
d597 1
a597 1
            if (inst->src[i].smear >= 0) {
d606 1
a606 1
         if (inst->dst.smear >= 0) {
d621 1
a621 1
      case FS_OPCODE_SPILL:
d626 2
a627 1
      case FS_OPCODE_UNSPILL:
d648 1
d652 24
a675 1
   c->last_scratch += size * REG_SIZE;
d688 9
a696 3
	    inst->src[i].reg = virtual_grf_alloc(1);
	    emit_unspill(inst, inst->src[i],
                         spill_offset + REG_SIZE * inst->src[i].reg_offset);
d703 4
a706 2
                                    REG_SIZE * inst->dst.reg_offset);
         inst->dst.reg = virtual_grf_alloc(inst->regs_written);
d713 4
a716 7
	 if (inst->predicate || inst->force_uncompressed || inst->force_sechalf) {
            fs_reg unspill_reg = inst->dst;
            for (int chan = 0; chan < inst->regs_written; chan++) {
               emit_unspill(inst, unspill_reg,
                            subset_spill_offset + REG_SIZE * chan);
               unspill_reg.reg_offset++;
            }
a718 6
	 fs_reg spill_src = inst->dst;
	 spill_src.reg_offset = 0;
	 spill_src.abs = false;
	 spill_src.negate = false;
	 spill_src.smear = -1;

d720 3
a722 2
	    fs_inst *spill_inst = new(mem_ctx) fs_inst(FS_OPCODE_SPILL,
						       reg_null_f, spill_src);
d724 1
a724 1
	    spill_inst->offset = subset_spill_offset + chan * REG_SIZE;
d727 2
a728 2
	    spill_inst->base_mrf = 14;
	    spill_inst->mlen = 2; /* header, value */
d734 1
a734 1
   this->live_intervals_valid = false;
@


1.2
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a27 17
extern "C" {

#include <sys/types.h>

#include "main/macros.h"
#include "main/shaderobj.h"
#include "main/uniforms.h"
#include "program/prog_parameter.h"
#include "program/prog_print.h"
#include "program/prog_optimize.h"
#include "program/register_allocate.h"
#include "program/sampler.h"
#include "program/hash_table.h"
#include "brw_context.h"
#include "brw_eu.h"
#include "brw_wm.h"
}
d29 2
a30 3
#include "../glsl/glsl_types.h"
#include "../glsl/ir_optimization.h"
#include "../glsl/ir_print_visitor.h"
d35 1
a35 1
   if (reg->file == GRF && reg->reg != 0) {
d37 2
a38 2
      reg->hw_reg = reg_hw_locations[reg->reg] + reg->reg_offset * reg_width;
      reg->reg = 0;
d45 1
a45 2
   int last_grf = 0;
   int hw_reg_mapping[this->virtual_grf_next];
d47 1
a47 1
   int reg_width = c->dispatch_width / 8;
a48 1
   hw_reg_mapping[0] = 0;
d50 2
a51 2
   hw_reg_mapping[1] = ALIGN(this->first_non_payload_grf, reg_width);
   for (i = 2; i < this->virtual_grf_next; i++) {
d55 1
a55 2
   last_grf = hw_reg_mapping[i - 1] + (this->virtual_grf_sizes[i - 1] *
				       reg_width);
d57 2
a58 2
   foreach_iter(exec_list_iterator, iter, this->instructions) {
      fs_inst *inst = (fs_inst *)iter.get();
d63 1
d66 1
a66 1
   if (last_grf >= BRW_MAX_GRF) {
d68 1
a68 1
	   last_grf, BRW_MAX_GRF);
a70 1
   this->grf_used = last_grf + reg_width;
d73 2
a74 2
bool
fs_visitor::assign_regs()
d76 21
a96 5
   /* Most of this allocation was written for a reg_width of 1
    * (dispatch_width == 8).  In extending to 16-wide, the code was
    * left in place and it was converted to have the hardware
    * registers it's allocating be contiguous physical pairs of regs
    * for reg_width == 2.
d98 2
a99 7
   int reg_width = c->dispatch_width / 8;
   int hw_reg_mapping[this->virtual_grf_next + 1];
   int first_assigned_grf = ALIGN(this->first_non_payload_grf, reg_width);
   int base_reg_count = (BRW_MAX_GRF - first_assigned_grf) / reg_width;
   int class_sizes[base_reg_count];
   int class_count = 0;
   int aligned_pair_class = -1;
d101 12
a112 1
   calculate_live_intervals();
d114 2
a115 7
   /* Set up the register classes.
    *
    * The base registers store a scalar value.  For texture samples,
    * we get virtual GRFs composed of 4 contiguous hw register.  For
    * structures and arrays, we store them as contiguous larger things
    * than that, though we should be able to do better most of the
    * time.
d117 26
a142 6
   class_sizes[class_count++] = 1;
   if (brw->has_pln && intel->gen < 6) {
      /* Always set up the (unaligned) pairs for gen5, so we can find
       * them for making the aligned pair class.
       */
      class_sizes[class_count++] = 2;
d144 7
a150 2
   for (int r = 1; r < this->virtual_grf_next; r++) {
      int i;
d152 3
a154 7
      for (i = 0; i < class_count; i++) {
	 if (class_sizes[i] == this->virtual_grf_sizes[r])
	    break;
      }
      if (i == class_count) {
	 if (this->virtual_grf_sizes[r] >= base_reg_count) {
	    fail("Object too large to register allocate.\n");
d156 17
d174 17
a190 1
	 class_sizes[class_count++] = this->virtual_grf_sizes[r];
d192 1
d194 38
d233 89
a321 4
   int ra_reg_count = 0;
   int class_base_reg[class_count];
   int class_reg_count[class_count];
   int classes[class_count + 1];
d323 7
a329 4
   for (int i = 0; i < class_count; i++) {
      class_base_reg[i] = ra_reg_count;
      class_reg_count[i] = base_reg_count - (class_sizes[i] - 1);
      ra_reg_count += class_reg_count[i];
d331 1
d333 9
a341 3
   struct ra_regs *regs = ra_alloc_reg_set(ra_reg_count);
   for (int i = 0; i < class_count; i++) {
      classes[i] = ra_alloc_reg_class(regs);
d343 22
a364 2
      for (int i_r = 0; i_r < class_reg_count[i]; i_r++) {
	 ra_class_add_reg(regs, classes[i], class_base_reg[i] + i_r);
d366 10
d377 2
a378 3
      /* Add conflicts between our contiguous registers aliasing
       * base regs and other register classes' contiguous registers
       * that alias base regs, or the base regs themselves for classes[0].
d380 4
a383 17
      for (int c = 0; c <= i; c++) {
	 for (int i_r = 0; i_r < class_reg_count[i]; i_r++) {
	    for (int c_r = MAX2(0, i_r - (class_sizes[c] - 1));
		 c_r < MIN2(class_reg_count[c], i_r + class_sizes[i]);
		 c_r++) {

	       if (0) {
		  printf("%d/%d conflicts %d/%d\n",
			 class_sizes[i], first_assigned_grf + i_r,
			 class_sizes[c], first_assigned_grf + c_r);
	       }

	       ra_add_reg_conflict(regs,
				   class_base_reg[i] + i_r,
				   class_base_reg[c] + c_r);
	    }
	 }
d386 1
d388 8
a395 2
   /* Add a special class for aligned pairs, which we'll put delta_x/y
    * in on gen5 so that we can do PLN.
d397 28
a424 27
   if (brw->has_pln && reg_width == 1 && intel->gen < 6) {
      int reg_count = (base_reg_count - 1) / 2;
      int unaligned_pair_class = 1;
      assert(class_sizes[unaligned_pair_class] == 2);

      aligned_pair_class = class_count;
      classes[aligned_pair_class] = ra_alloc_reg_class(regs);
      class_sizes[aligned_pair_class] = 2;
      class_base_reg[aligned_pair_class] = 0;
      class_reg_count[aligned_pair_class] = 0;
      int start = (first_assigned_grf & 1) ? 1 : 0;

      for (int i = 0; i < reg_count; i++) {
	 ra_class_add_reg(regs, classes[aligned_pair_class],
			  class_base_reg[unaligned_pair_class] + i * 2 + start);
      }
      class_count++;
   }

   ra_set_finalize(regs);

   struct ra_graph *g = ra_alloc_interference_graph(regs,
						    this->virtual_grf_next);
   /* Node 0 is just a placeholder to keep virtual_grf[] mapping 1:1
    * with nodes.
    */
   ra_set_node_class(g, 0, classes[0]);
d426 12
a437 11
   for (int i = 1; i < this->virtual_grf_next; i++) {
      for (int c = 0; c < class_count; c++) {
	 if (class_sizes[c] == this->virtual_grf_sizes[i]) {
	    if (aligned_pair_class >= 0 &&
		this->delta_x.reg == i) {
	       ra_set_node_class(g, i, classes[aligned_pair_class]);
	    } else {
	       ra_set_node_class(g, i, classes[c]);
	    }
	    break;
	 }
d440 3
a442 1
      for (int j = 1; j < i; j++) {
d449 4
d460 5
a464 5
	 fail("no register to spill\n");
      } else if (intel->gen >= 7) {
	 fail("no spilling support on gen7 yet\n");
      } else if (c->dispatch_width == 16) {
	 fail("no spilling support on 16-wide yet\n");
a470 1
      ralloc_free(regs);
d479 2
a480 3
   this->grf_used = first_assigned_grf;
   hw_reg_mapping[0] = 0; /* unused */
   for (int i = 1; i < this->virtual_grf_next; i++) {
a481 1
      int hw_reg = -1;
d483 1
a483 10
      for (int c = 0; c < class_count; c++) {
	 if (reg >= class_base_reg[c] &&
	     reg < class_base_reg[c] + class_reg_count[c]) {
	    hw_reg = reg - class_base_reg[c];
	    break;
	 }
      }

      assert(hw_reg >= 0);
      hw_reg_mapping[i] = first_assigned_grf + hw_reg * reg_width;
d489 2
a490 2
   foreach_iter(exec_list_iterator, iter, this->instructions) {
      fs_inst *inst = (fs_inst *)iter.get();
d495 1
a498 1
   ralloc_free(regs);
d506 4
a509 2
   int size = virtual_grf_sizes[dst.reg];
   dst.reg_offset = 0;
d511 6
a516 15
   for (int chan = 0; chan < size; chan++) {
      fs_inst *unspill_inst = new(mem_ctx) fs_inst(FS_OPCODE_UNSPILL,
						   dst);
      dst.reg_offset++;
      unspill_inst->offset = spill_offset + chan * REG_SIZE;
      unspill_inst->ir = inst->ir;
      unspill_inst->annotation = inst->annotation;

      /* Choose a MRF that won't conflict with an MRF that's live across the
       * spill.  Nothing else will make it up to MRF 14/15.
       */
      unspill_inst->base_mrf = 14;
      unspill_inst->mlen = 1; /* header contains offset */
      inst->insert_before(unspill_inst);
   }
d523 2
a524 2
   float spill_costs[this->virtual_grf_next];
   bool no_spill[this->virtual_grf_next];
d526 1
a526 1
   for (int i = 0; i < this->virtual_grf_next; i++) {
d535 2
a536 2
   foreach_iter(exec_list_iterator, iter, this->instructions) {
      fs_inst *inst = (fs_inst *)iter.get();
d540 12
a551 2
	    int size = virtual_grf_sizes[inst->src[i].reg];
	    spill_costs[inst->src[i].reg] += size * loop_scale;
d556 5
a560 2
	 int size = virtual_grf_sizes[inst->dst.reg];
	 spill_costs[inst->dst.reg] += size * loop_scale;
d582 3
d588 1
a588 1
   for (int i = 0; i < this->virtual_grf_next; i++) {
d609 2
a610 2
   foreach_iter(exec_list_iterator, iter, this->instructions) {
      fs_inst *inst = (fs_inst *)iter.get();
d615 3
a617 2
	    inst->src[i].reg = virtual_grf_alloc(size);
	    emit_unspill(inst, inst->src[i], spill_offset);
d623 8
a630 5
	 inst->dst.reg = virtual_grf_alloc(size);

	 /* Since we spill/unspill the whole thing even if we access
	  * just a component, we may need to unspill before the
	  * instruction we're spilling for.
d632 7
a638 2
	 if (size != 1 || inst->predicated) {
	    emit_unspill(inst, inst->dst, spill_offset);
d647 1
a647 1
	 for (int chan = 0; chan < size; chan++) {
d651 1
a651 1
	    spill_inst->offset = spill_offset + chan * REG_SIZE;
@


1.1
log
@Initial revision
@
text
@d51 1
a51 1
assign_reg(int *reg_hw_locations, fs_reg *reg)
d55 1
a55 1
      reg->hw_reg = reg_hw_locations[reg->reg] + reg->reg_offset;
d66 1
d69 2
a70 1
   hw_reg_mapping[1] = this->first_non_payload_grf;
d73 1
a73 1
			   this->virtual_grf_sizes[i - 1]);
d75 2
a76 1
   last_grf = hw_reg_mapping[i - 1] + this->virtual_grf_sizes[i - 1];
d81 3
a83 3
      assign_reg(hw_reg_mapping, &inst->dst);
      assign_reg(hw_reg_mapping, &inst->src[0]);
      assign_reg(hw_reg_mapping, &inst->src[1]);
d86 6
a91 1
   this->grf_used = last_grf + 1;
d97 7
a103 1
   int last_grf = 0;
d105 2
a106 1
   int base_reg_count = BRW_MAX_GRF - this->first_non_payload_grf;
d111 2
d137 1
a137 2
	    fprintf(stderr, "Object too large to register allocate.\n");
	    this->fail = true;
d175 2
a176 2
			 class_sizes[i], this->first_non_payload_grf + i_r,
			 class_sizes[c], this->first_non_payload_grf + c_r);
d190 1
a190 1
   if (brw->has_pln && intel->gen < 6) {
d200 1
a200 1
      int start = (this->first_non_payload_grf & 1) ? 1 : 0;
d243 7
a249 2
      if (reg == -1 || intel->gen >= 6) {
	 this->fail = true;
d265 1
d280 4
a283 3
      hw_reg_mapping[i] = this->first_non_payload_grf + hw_reg;
      last_grf = MAX2(last_grf,
		      hw_reg_mapping[i] + this->virtual_grf_sizes[i] - 1);
d289 3
a291 3
      assign_reg(hw_reg_mapping, &inst->dst);
      assign_reg(hw_reg_mapping, &inst->src[0]);
      assign_reg(hw_reg_mapping, &inst->src[1]);
a293 2
   this->grf_used = last_grf + 1;

d439 2
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d28 17
d46 3
a48 2
#include "glsl/glsl_types.h"
#include "glsl/ir_optimization.h"
d51 1
a51 1
assign_reg(int *reg_hw_locations, fs_reg *reg, int reg_width)
d53 1
a53 1
   if (reg->file == GRF) {
d55 2
a56 2
      reg->reg = reg_hw_locations[reg->reg] + reg->reg_offset * reg_width;
      reg->reg_offset = 0;
d63 2
a64 1
   int hw_reg_mapping[this->virtual_grf_count + 1];
a65 1
   int reg_width = dispatch_width / 8;
d67 3
a69 3
   /* Note that compressed instructions require alignment to 2 registers. */
   hw_reg_mapping[0] = ALIGN(this->first_non_payload_grf, reg_width);
   for (i = 1; i <= this->virtual_grf_count; i++) {
d71 1
a71 1
			   this->virtual_grf_sizes[i - 1] * reg_width);
d73 1
a73 1
   this->grf_used = hw_reg_mapping[this->virtual_grf_count];
d75 2
a76 2
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;
d78 3
a80 9
      assign_reg(hw_reg_mapping, &inst->dst, reg_width);
      assign_reg(hw_reg_mapping, &inst->src[0], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[1], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[2], reg_width);
   }

   if (this->grf_used >= max_grf) {
      fail("Ran out of regs on trivial allocator (%d/%d)\n",
	   this->grf_used, max_grf);
d83 1
d86 2
a87 2
static void
brw_alloc_reg_set(struct brw_context *brw, int reg_width)
d89 6
a94 2
   int base_reg_count = BRW_MAX_GRF / reg_width;
   int index = reg_width - 1;
d96 1
a96 10
   /* The registers used to make up almost all values handled in the compiler
    * are a scalar value occupying a single register (or 2 registers in the
    * case of 16-wide, which is handled by dividing base_reg_count by 2 and
    * multiplying allocated register numbers by 2).  Things that were
    * aggregates of scalar values at the GLSL level were split to scalar
    * values by split_virtual_grfs().
    *
    * However, texture SEND messages return a series of contiguous registers.
    * We currently always ask for 4 registers, but we may convert that to use
    * less some day.
d98 5
a102 7
    * Additionally, on gen5 we need aligned pairs of registers for the PLN
    * instruction, and on gen4 we need 8 contiguous regs for workaround simd16
    * texturing.
    *
    * So we have a need for classes for 1, 2, 4, and 8 registers currently,
    * and we add in '3' to make indexing the array easier for the common case
    * (since we'll probably want it for texturing later).
d104 23
a126 2
   const int class_count = 5;
   const int class_sizes[class_count] = {1, 2, 3, 4, 8};
a127 1
   /* Compute the total number of registers across all classes. */
d129 4
d134 3
a136 1
      ra_reg_count += base_reg_count - (class_sizes[i] - 1);
d139 1
a139 13
   uint8_t *ra_reg_to_grf = ralloc_array(brw, uint8_t, ra_reg_count);
   struct ra_regs *regs = ra_alloc_reg_set(brw, ra_reg_count);
   if (brw->gen >= 6)
      ra_set_allocate_round_robin(regs);
   int *classes = ralloc_array(brw, int, class_count);
   int aligned_pairs_class = -1;

   /* Now, add the registers to their classes, and add the conflicts
    * between them and the base GRF registers (and also each other).
    */
   int reg = 0;
   int pairs_base_reg = 0;
   int pairs_reg_count = 0;
a140 1
      int class_reg_count = base_reg_count - (class_sizes[i] - 1);
d143 2
a144 4
      /* Save this off for the aligned pair class at the end. */
      if (class_sizes[i] == 2) {
	 pairs_base_reg = reg;
	 pairs_reg_count = class_reg_count;
d147 20
a166 9
      for (int j = 0; j < class_reg_count; j++) {
	 ra_class_add_reg(regs, classes[i], reg);

	 ra_reg_to_grf[reg] = j;

	 for (int base_reg = j;
	      base_reg < j + class_sizes[i];
	      base_reg++) {
	    ra_add_transitive_reg_conflict(regs, base_reg, reg);
a167 2

	 reg++;
a169 1
   assert(reg == ra_reg_count);
d174 27
a200 2
   if (brw->has_pln && reg_width == 1 && brw->gen < 6) {
      aligned_pairs_class = ra_alloc_reg_class(regs);
d202 10
a211 3
      for (int i = 0; i < pairs_reg_count; i++) {
	 if ((ra_reg_to_grf[pairs_base_reg + i] & 1) == 0) {
	    ra_class_add_reg(regs, aligned_pairs_class, pairs_base_reg + i);
a213 185
   }

   ra_set_finalize(regs, NULL);

   brw->wm.reg_sets[index].regs = regs;
   brw->wm.reg_sets[index].classes = classes;
   brw->wm.reg_sets[index].ra_reg_to_grf = ra_reg_to_grf;
   brw->wm.reg_sets[index].aligned_pairs_class = aligned_pairs_class;
}

void
brw_fs_alloc_reg_sets(struct brw_context *brw)
{
   brw_alloc_reg_set(brw, 1);
   brw_alloc_reg_set(brw, 2);
}

int
count_to_loop_end(fs_inst *do_inst)
{
   int depth = 1;
   int ip = 1;
   for (fs_inst *inst = (fs_inst *)do_inst->next;
        depth > 0;
        inst = (fs_inst *)inst->next) {
      switch (inst->opcode) {
      case BRW_OPCODE_DO:
         depth++;
         break;
      case BRW_OPCODE_WHILE:
         depth--;
         break;
      default:
         break;
      }
      ip++;
   }
   return ip;
}

/**
 * Sets up interference between thread payload registers and the virtual GRFs
 * to be allocated for program temporaries.
 *
 * We want to be able to reallocate the payload for our virtual GRFs, notably
 * because the setup coefficients for a full set of 16 FS inputs takes up 8 of
 * our 128 registers.
 *
 * The layout of the payload registers is:
 *
 * 0..nr_payload_regs-1: fixed function setup (including bary coordinates).
 * nr_payload_regs..nr_payload_regs+curb_read_lengh-1: uniform data
 * nr_payload_regs+curb_read_lengh..first_non_payload_grf-1: setup coefficients.
 *
 * And we have payload_node_count nodes covering these registers in order
 * (note that in 16-wide, a node is two registers).
 */
void
fs_visitor::setup_payload_interference(struct ra_graph *g,
                                       int payload_node_count,
                                       int first_payload_node)
{
   int reg_width = dispatch_width / 8;
   int loop_depth = 0;
   int loop_end_ip = 0;

   int payload_last_use_ip[payload_node_count];
   memset(payload_last_use_ip, 0, sizeof(payload_last_use_ip));
   int ip = 0;
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      switch (inst->opcode) {
      case BRW_OPCODE_DO:
         loop_depth++;

         /* Since payload regs are deffed only at the start of the shader
          * execution, any uses of the payload within a loop mean the live
          * interval extends to the end of the outermost loop.  Find the ip of
          * the end now.
          */
         if (loop_depth == 1)
            loop_end_ip = ip + count_to_loop_end(inst);
         break;
      case BRW_OPCODE_WHILE:
         loop_depth--;
         break;
      default:
         break;
      }

      int use_ip;
      if (loop_depth > 0)
         use_ip = loop_end_ip;
      else
         use_ip = ip;

      /* Note that UNIFORM args have been turned into FIXED_HW_REG by
       * assign_curbe_setup(), and interpolation uses fixed hardware regs from
       * the start (see interp_reg()).
       */
      for (int i = 0; i < 3; i++) {
         if (inst->src[i].file == HW_REG &&
             inst->src[i].fixed_hw_reg.file == BRW_GENERAL_REGISTER_FILE) {
            int node_nr = inst->src[i].fixed_hw_reg.nr / reg_width;
            if (node_nr >= payload_node_count)
               continue;

            payload_last_use_ip[node_nr] = use_ip;
         }
      }

      /* Special case instructions which have extra implied registers used. */
      switch (inst->opcode) {
      case FS_OPCODE_FB_WRITE:
         /* We could omit this for the !inst->header_present case, except that
          * the simulator apparently incorrectly reads from g0/g1 instead of
          * sideband.  It also really freaks out driver developers to see g0
          * used in unusual places, so just always reserve it.
          */
         payload_last_use_ip[0 / reg_width] = use_ip;
         payload_last_use_ip[1 / reg_width] = use_ip;
         break;

      case FS_OPCODE_LINTERP:
         /* On gen6+ in 16-wide, there are 4 adjacent registers (so 2 nodes)
          * used by PLN's sourcing of the deltas, while we list only the first
          * two in the arguments (1 node).  Pre-gen6, the deltas are computed
          * in normal VGRFs.
          */
         if (brw->gen >= 6) {
            int delta_x_arg = 0;
            if (inst->src[delta_x_arg].file == HW_REG &&
                inst->src[delta_x_arg].fixed_hw_reg.file ==
                BRW_GENERAL_REGISTER_FILE) {
               int sechalf_node = (inst->src[delta_x_arg].fixed_hw_reg.nr /
                                   reg_width) + 1;
               assert(sechalf_node < payload_node_count);
               payload_last_use_ip[sechalf_node] = use_ip;
            }
         }
         break;

      default:
         break;
      }

      ip++;
   }

   for (int i = 0; i < payload_node_count; i++) {
      /* Mark the payload node as interfering with any virtual grf that is
       * live between the start of the program and our last use of the payload
       * node.
       */
      for (int j = 0; j < this->virtual_grf_count; j++) {
         /* Note that we use a <= comparison, unlike virtual_grf_interferes(),
          * in order to not have to worry about the uniform issue described in
          * calculate_live_intervals().
          */
         if (this->virtual_grf_start[j] <= payload_last_use_ip[i]) {
            ra_add_node_interference(g, first_payload_node + i, j);
         }
      }
   }

   for (int i = 0; i < payload_node_count; i++) {
      /* Mark each payload node as being allocated to its physical register.
       *
       * The alternative would be to have per-physical-register classes, which
       * would just be silly.
       */
      ra_set_node_reg(g, first_payload_node + i, i);
   }
}

/**
 * Sets interference between virtual GRFs and usage of the high GRFs for SEND
 * messages (treated as MRFs in code generation).
 */
void
fs_visitor::setup_mrf_hack_interference(struct ra_graph *g, int first_mrf_node)
{
   int mrf_count = BRW_MAX_GRF - GEN7_MRF_HACK_START;
   int reg_width = dispatch_width / 8;
d215 1
a215 100
   /* Identify all the MRFs used in the program. */
   bool mrf_used[mrf_count];
   memset(mrf_used, 0, sizeof(mrf_used));
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      if (inst->dst.file == MRF) {
         int reg = inst->dst.reg & ~BRW_MRF_COMPR4;
         mrf_used[reg] = true;
         if (reg_width == 2) {
            if (inst->dst.reg & BRW_MRF_COMPR4) {
               mrf_used[reg + 4] = true;
            } else {
               mrf_used[reg + 1] = true;
            }
         }
      }

      if (inst->mlen > 0) {
	 for (int i = 0; i < implied_mrf_writes(inst); i++) {
            mrf_used[inst->base_mrf + i] = true;
         }
      }
   }

   for (int i = 0; i < mrf_count; i++) {
      /* Mark each payload reg node as being allocated to its physical register.
       *
       * The alternative would be to have per-physical-register classes, which
       * would just be silly.
       */
      ra_set_node_reg(g, first_mrf_node + i,
                      (GEN7_MRF_HACK_START + i) / reg_width);

      /* Since we don't have any live/dead analysis on the MRFs, just mark all
       * that are used as conflicting with all virtual GRFs.
       */
      if (mrf_used[i]) {
         for (int j = 0; j < this->virtual_grf_count; j++) {
            ra_add_node_interference(g, first_mrf_node + i, j);
         }
      }
   }
}

bool
fs_visitor::assign_regs()
{
   /* Most of this allocation was written for a reg_width of 1
    * (dispatch_width == 8).  In extending to 16-wide, the code was
    * left in place and it was converted to have the hardware
    * registers it's allocating be contiguous physical pairs of regs
    * for reg_width == 2.
    */
   int reg_width = dispatch_width / 8;
   int hw_reg_mapping[this->virtual_grf_count];
   int payload_node_count = (ALIGN(this->first_non_payload_grf, reg_width) /
                            reg_width);
   int rsi = reg_width - 1; /* Which brw->wm.reg_sets[] to use */
   calculate_live_intervals();

   int node_count = this->virtual_grf_count;
   int first_payload_node = node_count;
   node_count += payload_node_count;
   int first_mrf_hack_node = node_count;
   if (brw->gen >= 7)
      node_count += BRW_MAX_GRF - GEN7_MRF_HACK_START;
   struct ra_graph *g = ra_alloc_interference_graph(brw->wm.reg_sets[rsi].regs,
                                                    node_count);

   for (int i = 0; i < this->virtual_grf_count; i++) {
      int size = this->virtual_grf_sizes[i];
      int c;

      if (size == 8) {
         c = 4;
      } else {
         assert(size >= 1 &&
                size <= 4 &&
                "Register allocation relies on split_virtual_grfs()");
         c = brw->wm.reg_sets[rsi].classes[size - 1];
      }

      /* Special case: on pre-GEN6 hardware that supports PLN, the
       * second operand of a PLN instruction needs to be an
       * even-numbered register, so we have a special register class
       * wm_aligned_pairs_class to handle this case.  pre-GEN6 always
       * uses this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC] as the
       * second operand of a PLN instruction (since it doesn't support
       * any other interpolation modes).  So all we need to do is find
       * that register and set it to the appropriate class.
       */
      if (brw->wm.reg_sets[rsi].aligned_pairs_class >= 0 &&
          this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC].reg == i) {
         c = brw->wm.reg_sets[rsi].aligned_pairs_class;
      }

      ra_set_node_class(g, i, c);

      for (int j = 0; j < i; j++) {
a221 4
   setup_payload_interference(g, payload_node_count, first_payload_node);
   if (brw->gen >= 7)
      setup_mrf_hack_interference(g, first_mrf_hack_node);

d227 2
a228 7

      if (reg == -1) {
         fail("no register to spill:\n");
         dump_instructions();
      } else if (dispatch_width == 16) {
	 fail("Failure to register allocate.  Reduce number of live scalar "
              "values to avoid this.");
d235 1
d244 2
a245 2
   this->grf_used = payload_node_count * reg_width;
   for (int i = 0; i < this->virtual_grf_count; i++) {
d247 9
d257 4
a260 4
      hw_reg_mapping[i] = brw->wm.reg_sets[rsi].ra_reg_to_grf[reg] * reg_width;
      this->grf_used = MAX2(this->grf_used,
			    hw_reg_mapping[i] + this->virtual_grf_sizes[i] *
			    reg_width);
d263 6
a268 7
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      assign_reg(hw_reg_mapping, &inst->dst, reg_width);
      assign_reg(hw_reg_mapping, &inst->src[0], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[1], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[2], reg_width);
d271 2
d274 1
d282 10
a291 4
   fs_inst *unspill_inst = new(mem_ctx) fs_inst(FS_OPCODE_UNSPILL, dst);
   unspill_inst->offset = spill_offset;
   unspill_inst->ir = inst->ir;
   unspill_inst->annotation = inst->annotation;
d293 7
a299 6
   /* Choose a MRF that won't conflict with an MRF that's live across the
    * spill.  Nothing else will make it up to MRF 14/15.
    */
   unspill_inst->base_mrf = 14;
   unspill_inst->mlen = 1; /* header contains offset */
   inst->insert_before(unspill_inst);
d306 2
a307 2
   float spill_costs[this->virtual_grf_count];
   bool no_spill[this->virtual_grf_count];
d309 1
a309 1
   for (int i = 0; i < this->virtual_grf_count; i++) {
d318 2
a319 2
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;
d323 2
a324 12
	    spill_costs[inst->src[i].reg] += loop_scale;

            /* Register spilling logic assumes full-width registers; smeared
             * registers have a width of 1 so if we try to spill them we'll
             * generate invalid assembly.  This shouldn't be a problem because
             * smeared registers are only used as short-term temporaries when
             * loading pull constants, so spilling them is unlikely to reduce
             * register pressure anyhow.
             */
            if (inst->src[i].smear >= 0) {
               no_spill[inst->src[i].reg] = true;
            }
d329 2
a330 5
	 spill_costs[inst->dst.reg] += inst->regs_written * loop_scale;

         if (inst->dst.smear >= 0) {
            no_spill[inst->dst.reg] = true;
         }
a351 3

      default:
	 break;
d355 1
a355 1
   for (int i = 0; i < this->virtual_grf_count; i++) {
d376 2
a377 2
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;
d382 2
a383 3
	    inst->src[i].reg = virtual_grf_alloc(1);
	    emit_unspill(inst, inst->src[i],
                         spill_offset + REG_SIZE * inst->src[i].reg_offset);
d389 5
a393 8
         int subset_spill_offset = (spill_offset +
                                    REG_SIZE * inst->dst.reg_offset);
         inst->dst.reg = virtual_grf_alloc(inst->regs_written);
         inst->dst.reg_offset = 0;

	 /* If our write is going to affect just part of the
          * inst->regs_written(), then we need to unspill the destination
          * since we write back out all of the regs_written().
d395 2
a396 7
	 if (inst->predicate || inst->force_uncompressed || inst->force_sechalf) {
            fs_reg unspill_reg = inst->dst;
            for (int chan = 0; chan < inst->regs_written; chan++) {
               emit_unspill(inst, unspill_reg,
                            subset_spill_offset + REG_SIZE * chan);
               unspill_reg.reg_offset++;
            }
d405 1
a405 1
	 for (int chan = 0; chan < inst->regs_written; chan++) {
d409 1
a409 1
	    spill_inst->offset = subset_spill_offset + chan * REG_SIZE;
a417 2

   this->live_intervals_valid = false;
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d74 1
a74 1
brw_alloc_reg_set(struct intel_screen *screen, int reg_width)
a75 1
   const struct brw_device_info *devinfo = screen->devinfo;
d81 1
a81 1
    * case of SIMD16, which is handled by dividing base_reg_count by 2 and
d86 3
a88 3
    * However, texture SEND messages return a series of contiguous registers
    * to write into.  We currently always ask for 4 registers, but we may
    * convert that to use less some day.
a96 4
    *
    * And, on gen7 and newer, we do texturing SEND messages from GRFs, which
    * means that we may need any size up to the sampler message size limit (11
    * regs).
d98 2
a99 12
   int class_count;
   int class_sizes[BRW_MAX_MRF];

   if (devinfo->gen >= 7) {
      for (class_count = 0; class_count < MAX_SAMPLER_MESSAGE_SIZE;
           class_count++)
         class_sizes[class_count] = class_count + 1;
   } else {
      for (class_count = 0; class_count < 4; class_count++)
         class_sizes[class_count] = class_count + 1;
      class_sizes[class_count++] = 8;
   }
d107 3
a109 3
   uint8_t *ra_reg_to_grf = ralloc_array(screen, uint8_t, ra_reg_count);
   struct ra_regs *regs = ra_alloc_reg_set(screen, ra_reg_count);
   if (devinfo->gen >= 6)
d111 1
a111 1
   int *classes = ralloc_array(screen, int, class_count);
d149 1
a149 1
   if (devinfo->has_pln && reg_width == 1 && devinfo->gen < 6) {
d161 4
a164 7
   screen->wm_reg_sets[index].regs = regs;
   for (unsigned i = 0; i < ARRAY_SIZE(screen->wm_reg_sets[index].classes); i++)
      screen->wm_reg_sets[index].classes[i] = -1;
   for (int i = 0; i < class_count; i++)
      screen->wm_reg_sets[index].classes[class_sizes[i] - 1] = classes[i];
   screen->wm_reg_sets[index].ra_reg_to_grf = ra_reg_to_grf;
   screen->wm_reg_sets[index].aligned_pairs_class = aligned_pairs_class;
d168 1
a168 1
brw_fs_alloc_reg_sets(struct intel_screen *screen)
d170 2
a171 2
   brw_alloc_reg_set(screen, 1);
   brw_alloc_reg_set(screen, 2);
d212 1
a212 1
 * (note that in SIMD16, a node is two registers).
d282 1
a282 1
         /* On gen6+ in SIMD16, there are 4 adjacent registers (so 2 nodes)
d334 2
a335 6
 * Sets the mrf_used array to indicate which MRFs are used by the shader IR
 *
 * This is used in assign_regs() to decide which of the GRFs that we use as
 * MRFs on gen7 get normally register allocated, and in register spilling to
 * see if we can actually use MRFs to do spills without overwriting normal MRF
 * contents.
d338 1
a338 1
fs_visitor::get_used_mrfs(bool *mrf_used)
d340 1
d343 3
a345 2
   memset(mrf_used, 0, BRW_MAX_MRF * sizeof(bool));

a366 1
}
d368 2
a369 14
/**
 * Sets interference between virtual GRFs and usage of the high GRFs for SEND
 * messages (treated as MRFs in code generation).
 */
void
fs_visitor::setup_mrf_hack_interference(struct ra_graph *g, int first_mrf_node)
{
   int reg_width = dispatch_width / 8;

   bool mrf_used[BRW_MAX_MRF];
   get_used_mrfs(mrf_used);

   for (int i = 0; i < BRW_MAX_MRF; i++) {
      /* Mark each MRF reg node as being allocated to its physical register.
d389 1
a389 1
fs_visitor::assign_regs(bool allow_spilling)
a390 1
   struct intel_screen *screen = brw->intelScreen;
d392 1
a392 1
    * (dispatch_width == 8).  In extending to SIMD16, the code was
d401 1
a401 1
   int rsi = reg_width - 1; /* Which screen->wm_reg_sets[] to use */
d410 1
a410 1
   struct ra_graph *g = ra_alloc_interference_graph(screen->wm_reg_sets[rsi].regs,
d414 1
a414 1
      unsigned size = this->virtual_grf_sizes[i];
d417 8
a424 3
      assert(size <= ARRAY_SIZE(screen->wm_reg_sets[rsi].classes) &&
             "Register allocation relies on split_virtual_grfs()");
      c = screen->wm_reg_sets[rsi].classes[size - 1];
d435 1
a435 1
      if (screen->wm_reg_sets[rsi].aligned_pairs_class >= 0 &&
d437 1
a437 1
         c = screen->wm_reg_sets[rsi].aligned_pairs_class;
a452 11
   /* Debug of register spilling: Go spill everything. */
   if (0) {
      int reg = choose_spill_reg(g);

      if (reg != -1) {
         spill_reg(reg);
         ralloc_free(g);
         return false;
      }
   }

d462 5
a466 2
      } else if (allow_spilling) {
         spill_reg(reg);
d469 1
d483 1
a483 1
      hw_reg_mapping[i] = screen->wm_reg_sets[rsi].ra_reg_to_grf[reg] * reg_width;
d504 1
a504 2
fs_visitor::emit_unspill(fs_inst *inst, fs_reg dst, uint32_t spill_offset,
                         int count)
d506 4
a509 18
   for (int i = 0; i < count; i++) {
      /* The gen7 descriptor-based offset is 12 bits of HWORD units. */
      bool gen7_read = brw->gen >= 7 && spill_offset < (1 << 12) * REG_SIZE;

      fs_inst *unspill_inst =
         new(mem_ctx) fs_inst(gen7_read ?
                              SHADER_OPCODE_GEN7_SCRATCH_READ :
                              SHADER_OPCODE_GEN4_SCRATCH_READ,
                              dst);
      unspill_inst->offset = spill_offset;
      unspill_inst->ir = inst->ir;
      unspill_inst->annotation = inst->annotation;

      if (!gen7_read) {
         unspill_inst->base_mrf = 14;
         unspill_inst->mlen = 1; /* header contains offset */
      }
      inst->insert_before(unspill_inst);
d511 6
a516 3
      dst.reg_offset++;
      spill_offset += dispatch_width * sizeof(float);
   }
d549 1
a549 1
            if (!inst->src[i].is_contiguous()) {
d558 1
a558 1
         if (!inst->dst.is_contiguous()) {
d573 1
a573 1
      case SHADER_OPCODE_GEN4_SCRATCH_WRITE:
d578 1
a578 2
      case SHADER_OPCODE_GEN4_SCRATCH_READ:
      case SHADER_OPCODE_GEN7_SCRATCH_READ:
a598 1
   int reg_size = dispatch_width * sizeof(float);
d602 1
a602 24
   int spill_base_mrf = dispatch_width > 8 ? 13 : 14;

   /* Spills may use MRFs 13-15 in the SIMD16 case.  Our texturing is done
    * using up to 11 MRFs starting from either m1 or m2, and fb writes can use
    * up to m13 (gen6+ simd16: 2 header + 8 color + 2 src0alpha + 2 omask) or
    * m15 (gen4-5 simd16: 2 header + 8 color + 1 aads + 2 src depth + 2 dst
    * depth), starting from m1.  In summary: We may not be able to spill in
    * SIMD16 mode, because we'd stomp the FB writes.
    */
   if (!spilled_any_registers) {
      bool mrf_used[BRW_MAX_MRF];
      get_used_mrfs(mrf_used);

      for (int i = spill_base_mrf; i < BRW_MAX_MRF; i++) {
         if (mrf_used[i]) {
            fail("Register spilling not supported with m%d used", i);
          return;
         }
      }

      spilled_any_registers = true;
   }

   c->last_scratch += size * reg_size;
d615 3
a617 9
            int regs_read = inst->regs_read(this, i);
            int subset_spill_offset = (spill_offset +
                                       reg_size * inst->src[i].reg_offset);
            fs_reg unspill_dst(GRF, virtual_grf_alloc(regs_read));

            inst->src[i].reg = unspill_dst.reg;
            inst->src[i].reg_offset = 0;

            emit_unspill(inst, unspill_dst, subset_spill_offset, regs_read);
d624 2
a625 4
                                    reg_size * inst->dst.reg_offset);
         fs_reg spill_src(GRF, virtual_grf_alloc(inst->regs_written));

         inst->dst.reg = spill_src.reg;
d632 7
a638 4
	 if (inst->predicate || inst->force_uncompressed ||
             inst->force_sechalf || inst->dst.subreg_offset) {
            emit_unspill(inst, spill_src, subset_spill_offset,
                         inst->regs_written);
d641 6
d648 2
a649 3
	    fs_inst *spill_inst =
               new(mem_ctx) fs_inst(SHADER_OPCODE_GEN4_SCRATCH_WRITE,
                                    reg_null_f, spill_src);
d651 1
a651 1
	    spill_inst->offset = subset_spill_offset + chan * reg_size;
d654 2
a655 2
	    spill_inst->mlen = 1 + dispatch_width / 8; /* header, value */
	    spill_inst->base_mrf = spill_base_mrf;
d661 1
a661 1
   invalidate_live_intervals();
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a28 1
#include "brw_cfg.h"
d33 1
a33 1
assign_reg(int *reg_hw_locations, fs_reg *reg)
d37 1
a37 1
      reg->reg = reg_hw_locations[reg->reg] + reg->reg_offset;
d53 1
a53 1
			   this->virtual_grf_sizes[i - 1]);
d57 7
a63 5
   foreach_block_and_inst(block, fs_inst, inst, cfg) {
      assign_reg(hw_reg_mapping, &inst->dst);
      for (i = 0; i < inst->sources; i++) {
         assign_reg(hw_reg_mapping, &inst->src[i]);
      }
a68 2
   } else {
      this->virtual_grf_count = this->grf_used;
d77 1
a77 1
   int base_reg_count = BRW_MAX_GRF;
d104 1
a104 1
   int class_sizes[MAX_VGRF_SIZE];
d107 2
a108 1
      for (class_count = 0; class_count < MAX_VGRF_SIZE; class_count++)
a115 4
   memset(screen->wm_reg_sets[index].class_to_ra_reg_range, 0,
          sizeof(screen->wm_reg_sets[index].class_to_ra_reg_range));
   int *class_to_ra_reg_range = screen->wm_reg_sets[index].class_to_ra_reg_range;

d119 1
a119 23
      if (devinfo->gen <= 5 && reg_width == 2) {
         /* From the G45 PRM:
          *
          * In order to reduce the hardware complexity, the following
          * rules and restrictions apply to the compressed instruction:
          * ...
          * * Operand Alignment Rule: With the exceptions listed below, a
          *   source/destination operand in general should be aligned to
          *   even 256-bit physical register with a region size equal to
          *   two 256-bit physical register
          */
         ra_reg_count += (base_reg_count - (class_sizes[i] - 1)) / 2;
      } else {
         ra_reg_count += base_reg_count - (class_sizes[i] - 1);
      }
      /* Mark the last register. We'll fill in the beginnings later. */
      class_to_ra_reg_range[class_sizes[i]] = ra_reg_count;
   }

   /* Fill out the rest of the range markers */
   for (int i = 1; i < 17; ++i) {
      if (class_to_ra_reg_range[i] == 0)
         class_to_ra_reg_range[i] = class_to_ra_reg_range[i-1];
a128 7
   /* Allocate space for q values.  We allocate class_count + 1 because we
    * want to leave room for the aligned pairs class if we have it. */
   unsigned int **q_values = ralloc_array(screen, unsigned int *,
                                          class_count + 1);
   for (int i = 0; i < class_count + 1; ++i)
      q_values[i] = ralloc_array(q_values, unsigned int, class_count + 1);

d136 1
a136 39
      int class_reg_count;
      if (devinfo->gen <= 5 && reg_width == 2) {
         class_reg_count = (base_reg_count - (class_sizes[i] - 1)) / 2;

         /* See comment below.  The only difference here is that we are
          * dealing with pairs of registers instead of single registers.
          * Registers of odd sizes simply get rounded up. */
         for (int j = 0; j < class_count; j++)
            q_values[i][j] = (class_sizes[i] + 1) / 2 +
                             (class_sizes[j] + 1) / 2 - 1;
      } else {
         class_reg_count = base_reg_count - (class_sizes[i] - 1);

         /* From register_allocate.c:
          *
          * q(B,C) (indexed by C, B is this register class) in
          * Runeson/NystrÃ¶m paper.  This is "how many registers of B could
          * the worst choice register from C conflict with".
          *
          * If we just let the register allocation algorithm compute these
          * values, is extremely expensive.  However, since all of our
          * registers are laid out, we can very easily compute them
          * ourselves.  View the register from C as fixed starting at GRF n
          * somwhere in the middle, and the register from B as sliding back
          * and forth.  Then the first register to conflict from B is the
          * one starting at n - class_size[B] + 1 and the last register to
          * conflict will start at n + class_size[B] - 1.  Therefore, the
          * number of conflicts from B is class_size[B] + class_size[C] - 1.
          *
          *   +-+-+-+-+-+-+     +-+-+-+-+-+-+
          * B | | | | | |n| --> | | | | | | |
          *   +-+-+-+-+-+-+     +-+-+-+-+-+-+
          *             +-+-+-+-+-+
          * C           |n| | | | |
          *             +-+-+-+-+-+
          */
         for (int j = 0; j < class_count; j++)
            q_values[i][j] = class_sizes[i] + class_sizes[j] - 1;
      }
d141 2
a142 2
         pairs_base_reg = reg;
         pairs_reg_count = class_reg_count;
d145 2
a146 3
      if (devinfo->gen <= 5 && reg_width == 2) {
         for (int j = 0; j < class_reg_count; j++) {
            ra_class_add_reg(regs, classes[i], reg);
d148 1
a148 1
            ra_reg_to_grf[reg] = j * 2;
d150 5
a154 19
            for (int base_reg = j;
                 base_reg < j + (class_sizes[i] + 1) / 2;
                 base_reg++) {
               ra_add_transitive_reg_conflict(regs, base_reg, reg);
            }

            reg++;
         }
      } else {
         for (int j = 0; j < class_reg_count; j++) {
            ra_class_add_reg(regs, classes[i], reg);

            ra_reg_to_grf[reg] = j;

            for (int base_reg = j;
                 base_reg < j + class_sizes[i];
                 base_reg++) {
               ra_add_transitive_reg_conflict(regs, base_reg, reg);
            }
d156 1
a156 2
            reg++;
         }
a171 12

      for (int i = 0; i < class_count; i++) {
         /* These are a little counter-intuitive because the pair registers
          * are required to be aligned while the register they are
          * potentially interferring with are not.  In the case where the
          * size is even, the worst-case is that the register is
          * odd-aligned.  In the odd-size case, it doesn't matter.
          */
         q_values[class_count][i] = class_sizes[i] / 2 + 1;
         q_values[i][class_count] = class_sizes[i] + 1;
      }
      q_values[class_count][class_count] = 1;
d174 1
a174 3
   ra_set_finalize(regs, q_values);

   ralloc_free(q_values);
d192 2
a193 2
static int
count_to_loop_end(const bblock_t *block)
a194 3
   if (block->end()->opcode == BRW_OPCODE_WHILE)
      return block->end_ip;

d196 2
a197 4
   /* Skip the first block, since we don't want to count the do the calling
    * function found.
    */
   for (block = block->next();
d199 3
a201 2
        block = block->next()) {
      if (block->start()->opcode == BRW_OPCODE_DO)
d203 2
a204 1
      if (block->end()->opcode == BRW_OPCODE_WHILE) {
d206 3
a208 2
         if (depth == 0)
            return block->end_ip;
d210 1
d212 1
a212 1
   unreachable("not reached");
d225 3
a227 3
 * 0..payload.num_regs-1: fixed function setup (including bary coordinates).
 * payload.num_regs..payload.num_regs+curb_read_lengh-1: uniform data
 * payload.num_regs+curb_read_lengh..first_non_payload_grf-1: setup coefficients.
d237 1
d244 3
a246 1
   foreach_block_and_inst(block, fs_inst, inst, cfg) {
d257 1
a257 1
            loop_end_ip = count_to_loop_end(block);
d276 1
a276 1
      for (int i = 0; i < inst->sources; i++) {
d279 1
a279 1
            int node_nr = inst->src[i].fixed_hw_reg.nr;
d295 2
a296 2
         payload_last_use_ip[0] = use_ip;
         payload_last_use_ip[1] = use_ip;
d300 4
a303 4
         /* On gen6+ in SIMD16, there are 4 adjacent registers used by
          * PLN's sourcing of the deltas, while we list only the first one
          * in the arguments.  Pre-gen6, the deltas are computed in normal
          * VGRFs.
d310 4
a313 5
               for (int i = 1; i < 4; ++i) {
                  int node = inst->src[delta_x_arg].fixed_hw_reg.nr + i;
                  assert(node < payload_node_count);
                  payload_last_use_ip[node] = use_ip;
               }
d347 1
a347 10
      if (brw->intelScreen->devinfo->gen <= 5 && dispatch_width == 16) {
         /* We have to divide by 2 here because we only have even numbered
          * registers.  Some of the payload registers will be odd, but
          * that's ok because their physical register numbers have already
          * been assigned.  The only thing this is used for is interference.
          */
         ra_set_node_reg(g, first_payload_node + i, i / 2);
      } else {
         ra_set_node_reg(g, first_payload_node + i, i);
      }
d366 3
a368 1
   foreach_block_and_inst(block, fs_inst, inst, cfg) {
d396 2
d407 2
a408 1
      ra_set_node_reg(g, first_mrf_node + i, GEN7_MRF_HACK_START + i);
d433 2
a434 1
   int payload_node_count = ALIGN(this->first_non_payload_grf, reg_width);
a464 1
          this->delta_x[BRW_WM_PERSPECTIVE_PIXEL_BARYCENTRIC].file == GRF &&
d479 1
a479 1
   if (brw->gen >= 7) {
a481 44
      foreach_block_and_inst(block, fs_inst, inst, cfg) {
         /* When we do send-from-GRF for FB writes, we need to ensure that
          * the last write instruction sends from a high register.  This is
          * because the vertex fetcher wants to start filling the low
          * payload registers while the pixel data port is still working on
          * writing out the memory.  If we don't do this, we get rendering
          * artifacts.
          *
          * We could just do "something high".  Instead, we just pick the
          * highest register that works.
          */
         if (inst->opcode == FS_OPCODE_FB_WRITE && inst->eot) {
            int size = virtual_grf_sizes[inst->src[0].reg];
            int reg = screen->wm_reg_sets[rsi].class_to_ra_reg_range[size] - 1;
            ra_set_node_reg(g, inst->src[0].reg, reg);
            break;
         }
      }
   }

   if (dispatch_width > 8) {
      /* In 16-wide dispatch we have an issue where a compressed
       * instruction is actually two instructions executed simultaneiously.
       * It's actually ok to have the source and destination registers be
       * the same.  In this case, each instruction over-writes its own
       * source and there's no problem.  The real problem here is if the
       * source and destination registers are off by one.  Then you can end
       * up in a scenario where the first instruction over-writes the
       * source of the second instruction.  Since the compiler doesn't know
       * about this level of granularity, we simply make the source and
       * destination interfere.
       */
      foreach_block_and_inst(block, fs_inst, inst, cfg) {
         if (inst->dst.file != GRF)
            continue;

         for (int i = 0; i < inst->sources; ++i) {
            if (inst->src[i].file == GRF) {
               ra_add_node_interference(g, inst->dst.reg, inst->src[i].reg);
            }
         }
      }
   }

d493 1
a493 1
   if (!ra_allocate(g)) {
d501 1
a501 1
         dump_instructions(NULL);
d515 1
a515 1
   this->grf_used = payload_node_count;
d519 1
a519 1
      hw_reg_mapping[i] = screen->wm_reg_sets[rsi].ra_reg_to_grf[reg];
d521 2
a522 1
			    hw_reg_mapping[i] + this->virtual_grf_sizes[i]);
d525 7
a531 5
   foreach_block_and_inst(block, fs_inst, inst, cfg) {
      assign_reg(hw_reg_mapping, &inst->dst);
      for (int i = 0; i < inst->sources; i++) {
         assign_reg(hw_reg_mapping, &inst->src[i]);
      }
a533 2
   this->virtual_grf_count = this->grf_used;

d540 2
a541 2
fs_visitor::emit_unspill(bblock_t *block, fs_inst *inst, fs_reg dst,
                         uint32_t spill_offset, int count)
d543 1
a543 7
   int reg_size = 1;
   if (dispatch_width == 16 && count % 2 == 0) {
      reg_size = 2;
      dst.width = 16;
   }

   for (int i = 0; i < count / reg_size; i++) {
a554 1
      unspill_inst->regs_written = reg_size;
d560 1
a560 6
      inst->insert_before(block, unspill_inst);

      dst.reg_offset += reg_size;
      spill_offset += reg_size * REG_SIZE;
   }
}
d562 2
a563 22
void
fs_visitor::emit_spill(bblock_t *block, fs_inst *inst, fs_reg src,
                       uint32_t spill_offset, int count)
{
   int reg_size = 1;
   int spill_base_mrf = 14;
   if (dispatch_width == 16 && count % 2 == 0) {
      spill_base_mrf = 13;
      reg_size = 2;
   }

   for (int i = 0; i < count / reg_size; i++) {
      fs_inst *spill_inst =
         new(mem_ctx) fs_inst(SHADER_OPCODE_GEN4_SCRATCH_WRITE,
                              reg_size * 8, reg_null_f, src);
      src.reg_offset += reg_size;
      spill_inst->offset = spill_offset + i * reg_size * REG_SIZE;
      spill_inst->ir = inst->ir;
      spill_inst->annotation = inst->annotation;
      spill_inst->mlen = 1 + reg_size; /* header, value */
      spill_inst->base_mrf = spill_base_mrf;
      inst->insert_after(block, spill_inst);
d583 4
a586 2
   foreach_block_and_inst(block, fs_inst, inst, cfg) {
      for (unsigned int i = 0; i < inst->sources; i++) {
d648 1
d650 1
a650 1
   unsigned int spill_offset = last_scratch;
d675 1
a675 1
   last_scratch += size * REG_SIZE;
d682 4
a685 2
   foreach_block_and_inst (block, fs_inst, inst, cfg) {
      for (unsigned int i = 0; i < inst->sources; i++) {
d690 1
a690 1
                                       REG_SIZE * inst->src[i].reg_offset);
d696 1
a696 2
            emit_unspill(block, inst, unspill_dst, subset_spill_offset,
                         regs_read);
d703 1
a703 1
                                    REG_SIZE * inst->dst.reg_offset);
a708 8
         /* If we're immediately spilling the register, we should not use
          * destination dependency hints.  Doing so will cause the GPU do
          * try to read and write the register at the same time and may
          * hang the GPU.
          */
         inst->no_dd_clear = false;
         inst->no_dd_check = false;

d713 3
a715 2
	 if (inst->is_partial_write())
            emit_unspill(block, inst, spill_src, subset_spill_offset,
d717 1
d719 12
a730 2
         emit_spill(block, inst, spill_src, subset_spill_offset,
                    inst->regs_written);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d29 1
d34 1
a34 1
assign_reg(int *reg_hw_locations, fs_reg *reg, int reg_width)
d38 1
a38 1
      reg->reg = reg_hw_locations[reg->reg] + reg->reg_offset * reg_width;
d54 1
a54 1
			   this->virtual_grf_sizes[i - 1] * reg_width);
d58 5
a62 7
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      assign_reg(hw_reg_mapping, &inst->dst, reg_width);
      assign_reg(hw_reg_mapping, &inst->src[0], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[1], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[2], reg_width);
d68 2
d78 1
a78 1
   int base_reg_count = BRW_MAX_GRF / reg_width;
d105 1
a105 1
   int class_sizes[BRW_MAX_MRF];
d108 1
a108 2
      for (class_count = 0; class_count < MAX_SAMPLER_MESSAGE_SIZE;
           class_count++)
d116 4
d123 23
a145 1
      ra_reg_count += base_reg_count - (class_sizes[i] - 1);
d155 7
d169 39
a207 1
      int class_reg_count = base_reg_count - (class_sizes[i] - 1);
d212 2
a213 2
	 pairs_base_reg = reg;
	 pairs_reg_count = class_reg_count;
d216 5
a220 2
      for (int j = 0; j < class_reg_count; j++) {
	 ra_class_add_reg(regs, classes[i], reg);
d222 5
a226 1
	 ra_reg_to_grf[reg] = j;
d228 13
a240 5
	 for (int base_reg = j;
	      base_reg < j + class_sizes[i];
	      base_reg++) {
	    ra_add_transitive_reg_conflict(regs, base_reg, reg);
	 }
d242 2
a243 1
	 reg++;
d259 12
d273 3
a275 1
   ra_set_finalize(regs, NULL);
d293 2
a294 2
int
count_to_loop_end(fs_inst *do_inst)
d296 3
d300 4
a303 2
   int ip = 1;
   for (fs_inst *inst = (fs_inst *)do_inst->next;
d305 2
a306 3
        inst = (fs_inst *)inst->next) {
      switch (inst->opcode) {
      case BRW_OPCODE_DO:
d308 1
a308 2
         break;
      case BRW_OPCODE_WHILE:
d310 2
a311 3
         break;
      default:
         break;
a312 1
      ip++;
d314 1
a314 1
   return ip;
d327 3
a329 3
 * 0..nr_payload_regs-1: fixed function setup (including bary coordinates).
 * nr_payload_regs..nr_payload_regs+curb_read_lengh-1: uniform data
 * nr_payload_regs+curb_read_lengh..first_non_payload_grf-1: setup coefficients.
a338 1
   int reg_width = dispatch_width / 8;
d345 1
a345 3
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

d356 1
a356 1
            loop_end_ip = ip + count_to_loop_end(inst);
d375 1
a375 1
      for (int i = 0; i < 3; i++) {
d378 1
a378 1
            int node_nr = inst->src[i].fixed_hw_reg.nr / reg_width;
d394 2
a395 2
         payload_last_use_ip[0 / reg_width] = use_ip;
         payload_last_use_ip[1 / reg_width] = use_ip;
d399 4
a402 4
         /* On gen6+ in SIMD16, there are 4 adjacent registers (so 2 nodes)
          * used by PLN's sourcing of the deltas, while we list only the first
          * two in the arguments (1 node).  Pre-gen6, the deltas are computed
          * in normal VGRFs.
d409 5
a413 4
               int sechalf_node = (inst->src[delta_x_arg].fixed_hw_reg.nr /
                                   reg_width) + 1;
               assert(sechalf_node < payload_node_count);
               payload_last_use_ip[sechalf_node] = use_ip;
d447 10
a456 1
      ra_set_node_reg(g, first_payload_node + i, i);
d475 1
a475 3
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

a502 2
   int reg_width = dispatch_width / 8;

d512 1
a512 2
      ra_set_node_reg(g, first_mrf_node + i,
                      (GEN7_MRF_HACK_START + i) / reg_width);
d537 1
a537 2
   int payload_node_count = (ALIGN(this->first_non_payload_grf, reg_width) /
                            reg_width);
d568 1
d583 1
a583 1
   if (brw->gen >= 7)
d586 44
d641 1
a641 1
   if (!ra_allocate_no_spills(g)) {
d649 1
a649 1
         dump_instructions();
d663 1
a663 1
   this->grf_used = payload_node_count * reg_width;
d667 1
a667 1
      hw_reg_mapping[i] = screen->wm_reg_sets[rsi].ra_reg_to_grf[reg] * reg_width;
d669 1
a669 2
			    hw_reg_mapping[i] + this->virtual_grf_sizes[i] *
			    reg_width);
d672 6
a677 2
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;
d679 1
a679 5
      assign_reg(hw_reg_mapping, &inst->dst, reg_width);
      assign_reg(hw_reg_mapping, &inst->src[0], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[1], reg_width);
      assign_reg(hw_reg_mapping, &inst->src[2], reg_width);
   }
d687 2
a688 2
fs_visitor::emit_unspill(fs_inst *inst, fs_reg dst, uint32_t spill_offset,
                         int count)
d690 7
a696 1
   for (int i = 0; i < count; i++) {
d708 1
d714 6
a719 1
      inst->insert_before(unspill_inst);
d721 22
a742 2
      dst.reg_offset++;
      spill_offset += dispatch_width * sizeof(float);
d762 2
a763 4
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      for (unsigned int i = 0; i < 3; i++) {
a824 1
   int reg_size = dispatch_width * sizeof(float);
d826 1
a826 1
   unsigned int spill_offset = c->last_scratch;
d851 1
a851 1
   c->last_scratch += size * reg_size;
d858 2
a859 4
   foreach_list(node, &this->instructions) {
      fs_inst *inst = (fs_inst *)node;

      for (unsigned int i = 0; i < 3; i++) {
d864 1
a864 1
                                       reg_size * inst->src[i].reg_offset);
d870 2
a871 1
            emit_unspill(inst, unspill_dst, subset_spill_offset, regs_read);
d878 1
a878 1
                                    reg_size * inst->dst.reg_offset);
d884 8
d896 2
a897 3
	 if (inst->predicate || inst->force_uncompressed ||
             inst->force_sechalf || inst->dst.subreg_offset) {
            emit_unspill(inst, spill_src, subset_spill_offset,
a898 1
	 }
d900 2
a901 12
	 for (int chan = 0; chan < inst->regs_written; chan++) {
	    fs_inst *spill_inst =
               new(mem_ctx) fs_inst(SHADER_OPCODE_GEN4_SCRATCH_WRITE,
                                    reg_null_f, spill_src);
	    spill_src.reg_offset++;
	    spill_inst->offset = subset_spill_offset + chan * reg_size;
	    spill_inst->ir = inst->ir;
	    spill_inst->annotation = inst->annotation;
	    spill_inst->mlen = 1 + dispatch_width / 8; /* header, value */
	    spill_inst->base_mrf = spill_base_mrf;
	    inst->insert_after(spill_inst);
	 }
@


