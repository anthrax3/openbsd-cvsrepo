head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.22.09.30.34;	author jsg;	state Exp;
branches;
next	1.10;
commitid	yhStanAcs6cSYmBc;

1.10
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.9;
commitid	4ry2gvZGMXkCUD2n;

1.9
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.8;
commitid	mcxB0JvoI9gTDYXU;

1.8
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2014.01.19.03.13.15;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2013.09.05.14.05.45;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.41;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.18;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.43;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.16.10;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.01.19.03.04.31;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.57;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.12.17;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.49.24;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright 2008, 2010 George Sapountzis <gsapountzis@@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * DRI software rasterizer
 *
 * This is the mesa swrast module packaged into a DRI driver structure.
 *
 * The front-buffer is allocated by the loader. The loader provides read/write
 * callbacks for access to the front-buffer. The driver uses a scratch row for
 * front-buffer rendering to avoid repeated calls to the loader.
 *
 * The back-buffer is allocated by the driver and is private.
 */

#include "main/api_exec.h"
#include "main/context.h"
#include "main/extensions.h"
#include "main/formats.h"
#include "main/framebuffer.h"
#include "main/imports.h"
#include "main/renderbuffer.h"
#include "main/version.h"
#include "main/vtxfmt.h"
#include "swrast/swrast.h"
#include "swrast/s_renderbuffer.h"
#include "swrast_setup/swrast_setup.h"
#include "tnl/tnl.h"
#include "tnl/t_context.h"
#include "tnl/t_pipeline.h"
#include "vbo/vbo.h"
#include "drivers/common/driverfuncs.h"
#include "drivers/common/meta.h"
#include "utils.h"

#include "main/teximage.h"
#include "main/texformat.h"
#include "main/texstate.h"

#include "swrast_priv.h"
#include "swrast/s_context.h"

const __DRIextension **__driDriverGetExtensions_swrast(void);

const char const *swrast_vendor_string = "Mesa Project";
const char const *swrast_renderer_string = "Software Rasterizer";

/**
 * Screen and config-related functions
 */

static void swrastSetTexBuffer2(__DRIcontext *pDRICtx, GLint target,
				GLint texture_format, __DRIdrawable *dPriv)
{
    struct dri_context *dri_ctx;
    int x, y, w, h;
    __DRIscreen *sPriv = dPriv->driScreenPriv;
    struct gl_texture_object *texObj;
    struct gl_texture_image *texImage;
    struct swrast_texture_image *swImage;
    uint32_t internalFormat;
    mesa_format texFormat;

    dri_ctx = pDRICtx->driverPrivate;

    internalFormat = (texture_format == __DRI_TEXTURE_FORMAT_RGB ? 3 : 4);

    texObj = _mesa_get_current_tex_object(&dri_ctx->Base, target);
    texImage = _mesa_get_tex_image(&dri_ctx->Base, texObj, target, 0);
    swImage = swrast_texture_image(texImage);

    _mesa_lock_texture(&dri_ctx->Base, texObj);

    sPriv->swrast_loader->getDrawableInfo(dPriv, &x, &y, &w, &h, dPriv->loaderPrivate);

    if (texture_format == __DRI_TEXTURE_FORMAT_RGB)
	texFormat = MESA_FORMAT_B8G8R8X8_UNORM;
    else
	texFormat = MESA_FORMAT_B8G8R8A8_UNORM;

    _mesa_init_teximage_fields(&dri_ctx->Base, texImage,
			       w, h, 1, 0, internalFormat, texFormat);

    sPriv->swrast_loader->getImage(dPriv, x, y, w, h, (char *)swImage->Buffer,
				   dPriv->loaderPrivate);

    _mesa_unlock_texture(&dri_ctx->Base, texObj);
}

static void swrastSetTexBuffer(__DRIcontext *pDRICtx, GLint target,
			       __DRIdrawable *dPriv)
{
    swrastSetTexBuffer2(pDRICtx, target, __DRI_TEXTURE_FORMAT_RGBA, dPriv);
}

static const __DRItexBufferExtension swrastTexBufferExtension = {
   .base = { __DRI_TEX_BUFFER, 3 },

   .setTexBuffer        = swrastSetTexBuffer,
   .setTexBuffer2       = swrastSetTexBuffer2,
   .releaseTexBuffer    = NULL,
};


static int
swrast_query_renderer_integer(__DRIscreen *psp, int param,
			       unsigned int *value)
{
   switch (param) {
   case __DRI2_RENDERER_VENDOR_ID:
   case __DRI2_RENDERER_DEVICE_ID:
      /* Return 0xffffffff for both vendor and device id */
      value[0] = 0xffffffff;
      return 0;
   case __DRI2_RENDERER_ACCELERATED:
      value[0] = 0;
      return 0;
   case __DRI2_RENDERER_VIDEO_MEMORY: {
      /* XXX: Do we want to return the full amount of system memory ? */
      const long system_memory_pages = sysconf(_SC_PHYS_PAGES);
      const long system_page_size = sysconf(_SC_PAGE_SIZE);

      if (system_memory_pages <= 0 || system_page_size <= 0)
         return -1;

      const uint64_t system_memory_bytes = (uint64_t) system_memory_pages
         * (uint64_t) system_page_size;

      const unsigned system_memory_megabytes =
         (unsigned) (system_memory_bytes / (1024 * 1024));

      value[0] = system_memory_megabytes;
      return 0;
   }
   case __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE:
      /**
       * XXX: Perhaps we should return 1 ?
       * See issue #7 from the spec, currently UNRESOLVED.
       */
      value[0] = 0;
      return 0;
   default:
      return driQueryRendererIntegerCommon(psp, param, value);
   }
}

static int
swrast_query_renderer_string(__DRIscreen *psp, int param, const char **value)
{
   switch (param) {
   case __DRI2_RENDERER_VENDOR_ID:
      value[0] = swrast_vendor_string;
      return 0;
   case __DRI2_RENDERER_DEVICE_ID:
      value[0] = swrast_renderer_string;
      return 0;
   default:
      return -1;
   }
}

static const __DRI2rendererQueryExtension swrast_query_renderer_extension = {
   .base = { __DRI2_RENDERER_QUERY, 1 },

   .queryInteger        = swrast_query_renderer_integer,
   .queryString         = swrast_query_renderer_string
};

static const __DRIextension *dri_screen_extensions[] = {
    &swrastTexBufferExtension.base,
    &swrast_query_renderer_extension.base,
    NULL
};

static __DRIconfig **
swrastFillInModes(__DRIscreen *psp,
		  unsigned pixel_bits, unsigned depth_bits,
		  unsigned stencil_bits, GLboolean have_back_buffer)
{
    __DRIconfig **configs;
    unsigned depth_buffer_factor;
    unsigned back_buffer_factor;
    mesa_format format;

    /* GLX_SWAP_COPY_OML is only supported because the Intel driver doesn't
     * support pageflipping at all.
     */
    static const GLenum back_buffer_modes[] = {
	GLX_NONE, GLX_SWAP_UNDEFINED_OML
    };

    uint8_t depth_bits_array[4];
    uint8_t stencil_bits_array[4];
    uint8_t msaa_samples_array[1];

    (void) psp;
    (void) have_back_buffer;

    depth_bits_array[0] = 0;
    depth_bits_array[1] = 0;
    depth_bits_array[2] = depth_bits;
    depth_bits_array[3] = depth_bits;

    /* Just like with the accumulation buffer, always provide some modes
     * with a stencil buffer.
     */
    stencil_bits_array[0] = 0;
    stencil_bits_array[1] = (stencil_bits == 0) ? 8 : stencil_bits;
    stencil_bits_array[2] = 0;
    stencil_bits_array[3] = (stencil_bits == 0) ? 8 : stencil_bits;

    msaa_samples_array[0] = 0;

    depth_buffer_factor = 4;
    back_buffer_factor = 2;

    switch (pixel_bits) {
    case 16:
	format = MESA_FORMAT_B5G6R5_UNORM;
	break;
    case 24:
        format = MESA_FORMAT_B8G8R8X8_UNORM;
	break;
    case 32:
	format = MESA_FORMAT_B8G8R8A8_UNORM;
	break;
    default:
	fprintf(stderr, "[%s:%u] bad depth %d\n", __func__, __LINE__,
		pixel_bits);
	return NULL;
    }

    configs = driCreateConfigs(format,
			       depth_bits_array, stencil_bits_array,
			       depth_buffer_factor, back_buffer_modes,
			       back_buffer_factor, msaa_samples_array, 1,
			       GL_TRUE);
    if (configs == NULL) {
	fprintf(stderr, "[%s:%u] Error creating FBConfig!\n", __func__,
		__LINE__);
	return NULL;
    }

    return configs;
}

static const __DRIconfig **
dri_init_screen(__DRIscreen * psp)
{
    __DRIconfig **configs16, **configs24, **configs32;

    TRACE;

    psp->max_gl_compat_version = 21;
    psp->max_gl_es1_version = 11;
    psp->max_gl_es2_version = 20;

    psp->extensions = dri_screen_extensions;

    configs16 = swrastFillInModes(psp, 16, 16, 0, 1);
    configs24 = swrastFillInModes(psp, 24, 24, 8, 1);
    configs32 = swrastFillInModes(psp, 32, 24, 8, 1);

    configs24 = driConcatConfigs(configs16, configs24);
    configs32 = driConcatConfigs(configs24, configs32);

    return (const __DRIconfig **)configs32;
}

static void
dri_destroy_screen(__DRIscreen * sPriv)
{
    TRACE;
    (void) sPriv;
}


/**
 * Framebuffer and renderbuffer-related functions.
 */

static GLuint
choose_pixel_format(const struct gl_config *v)
{
    int depth = v->rgbBits;

    if (depth == 32
	&& v->redMask   == 0xff0000
	&& v->greenMask == 0x00ff00
	&& v->blueMask  == 0x0000ff)
	return PF_A8R8G8B8;
    else if (depth == 24
	     && v->redMask   == 0xff0000
	     && v->greenMask == 0x00ff00
	     && v->blueMask  == 0x0000ff)
	return PF_X8R8G8B8;
    else if (depth == 16
	     && v->redMask   == 0xf800
	     && v->greenMask == 0x07e0
	     && v->blueMask  == 0x001f)
	return PF_R5G6B5;
    else if (depth == 8
	     && v->redMask   == 0x07
	     && v->greenMask == 0x38
	     && v->blueMask  == 0xc0)
	return PF_R3G3B2;

    _mesa_problem( NULL, "unexpected format in %s", __FUNCTION__ );
    return 0;
}

static void
swrast_delete_renderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
{
    struct dri_swrast_renderbuffer *xrb = dri_swrast_renderbuffer(rb);

    TRACE;

    free(xrb->Base.Buffer);
    _mesa_delete_renderbuffer(ctx, rb);
}

/* see bytes_per_line in libGL */
static INLINE int
bytes_per_line(unsigned pitch_bits, unsigned mul)
{
   unsigned mask = mul - 1;

   return ((pitch_bits + mask) & ~mask) / 8;
}

static GLboolean
swrast_alloc_front_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
			   GLenum internalFormat, GLuint width, GLuint height)
{
    struct dri_swrast_renderbuffer *xrb = dri_swrast_renderbuffer(rb);

    TRACE;

    (void) ctx;
    (void) internalFormat;

    xrb->Base.Buffer = NULL;
    rb->Width = width;
    rb->Height = height;
    xrb->pitch = bytes_per_line(width * xrb->bpp, 32);

    return GL_TRUE;
}

static GLboolean
swrast_alloc_back_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
			  GLenum internalFormat, GLuint width, GLuint height)
{
    struct dri_swrast_renderbuffer *xrb = dri_swrast_renderbuffer(rb);

    TRACE;

    free(xrb->Base.Buffer);

    swrast_alloc_front_storage(ctx, rb, internalFormat, width, height);

    xrb->Base.Buffer = malloc(height * xrb->pitch);

    return GL_TRUE;
}

static struct dri_swrast_renderbuffer *
swrast_new_renderbuffer(const struct gl_config *visual, __DRIdrawable *dPriv,
			GLboolean front)
{
    struct dri_swrast_renderbuffer *xrb = calloc(1, sizeof *xrb);
    struct gl_renderbuffer *rb;
    GLuint pixel_format;

    TRACE;

    if (!xrb)
	return NULL;

    rb = &xrb->Base.Base;

    _mesa_init_renderbuffer(rb, 0);

    pixel_format = choose_pixel_format(visual);

    xrb->dPriv = dPriv;
    xrb->Base.Base.Delete = swrast_delete_renderbuffer;
    if (front) {
        rb->AllocStorage = swrast_alloc_front_storage;
    }
    else {
	rb->AllocStorage = swrast_alloc_back_storage;
    }

    switch (pixel_format) {
    case PF_A8R8G8B8:
	rb->Format = MESA_FORMAT_B8G8R8A8_UNORM;
	rb->InternalFormat = GL_RGBA;
	rb->_BaseFormat = GL_RGBA;
	xrb->bpp = 32;
	break;
    case PF_X8R8G8B8:
	rb->Format = MESA_FORMAT_B8G8R8A8_UNORM; /* XXX */
	rb->InternalFormat = GL_RGB;
	rb->_BaseFormat = GL_RGB;
	xrb->bpp = 32;
	break;
    case PF_R5G6B5:
	rb->Format = MESA_FORMAT_B5G6R5_UNORM;
	rb->InternalFormat = GL_RGB;
	rb->_BaseFormat = GL_RGB;
	xrb->bpp = 16;
	break;
    case PF_R3G3B2:
	rb->Format = MESA_FORMAT_B2G3R3_UNORM;
	rb->InternalFormat = GL_RGB;
	rb->_BaseFormat = GL_RGB;
	xrb->bpp = 8;
	break;
    default:
	free(xrb);
	return NULL;
    }

    return xrb;
}

static void
swrast_map_renderbuffer(struct gl_context *ctx,
			struct gl_renderbuffer *rb,
			GLuint x, GLuint y, GLuint w, GLuint h,
			GLbitfield mode,
			GLubyte **out_map,
			GLint *out_stride)
{
   struct dri_swrast_renderbuffer *xrb = dri_swrast_renderbuffer(rb);
   GLubyte *map = xrb->Base.Buffer;
   int cpp = _mesa_get_format_bytes(rb->Format);
   int stride = rb->Width * cpp;

   if (rb->AllocStorage == swrast_alloc_front_storage) {
      __DRIdrawable *dPriv = xrb->dPriv;
      __DRIscreen *sPriv = dPriv->driScreenPriv;

      xrb->map_mode = mode;
      xrb->map_x = x;
      xrb->map_y = y;
      xrb->map_w = w;
      xrb->map_h = h;

      stride = w * cpp;
      xrb->Base.Buffer = malloc(h * stride);

      sPriv->swrast_loader->getImage(dPriv, x, rb->Height - y - h, w, h,
				     (char *) xrb->Base.Buffer,
				     dPriv->loaderPrivate);

      *out_map = xrb->Base.Buffer + (h - 1) * stride;
      *out_stride = -stride;
      return;
   }

   ASSERT(xrb->Base.Buffer);

   if (rb->AllocStorage == swrast_alloc_back_storage) {
      map += (rb->Height - 1) * stride;
      stride = -stride;
   }

   map += (GLsizei)y * stride;
   map += (GLsizei)x * cpp;

   *out_map = map;
   *out_stride = stride;
}

static void
swrast_unmap_renderbuffer(struct gl_context *ctx,
			  struct gl_renderbuffer *rb)
{
   struct dri_swrast_renderbuffer *xrb = dri_swrast_renderbuffer(rb);

   if (rb->AllocStorage == swrast_alloc_front_storage) {
      __DRIdrawable *dPriv = xrb->dPriv;
      __DRIscreen *sPriv = dPriv->driScreenPriv;

      if (xrb->map_mode & GL_MAP_WRITE_BIT) {
	 sPriv->swrast_loader->putImage(dPriv, __DRI_SWRAST_IMAGE_OP_DRAW,
					xrb->map_x, xrb->map_y,
					xrb->map_w, xrb->map_h,
					(char *) xrb->Base.Buffer,
					dPriv->loaderPrivate);
      }

      free(xrb->Base.Buffer);
      xrb->Base.Buffer = NULL;
   }
}

static GLboolean
dri_create_buffer(__DRIscreen * sPriv,
		  __DRIdrawable * dPriv,
		  const struct gl_config * visual, GLboolean isPixmap)
{
    struct dri_drawable *drawable = NULL;
    struct gl_framebuffer *fb;
    struct dri_swrast_renderbuffer *frontrb, *backrb;

    TRACE;

    (void) sPriv;
    (void) isPixmap;

    drawable = CALLOC_STRUCT(dri_drawable);
    if (drawable == NULL)
	goto drawable_fail;

    dPriv->driverPrivate = drawable;
    drawable->dPriv = dPriv;

    drawable->row = malloc(SWRAST_MAX_WIDTH * 4);
    if (drawable->row == NULL)
	goto drawable_fail;

    fb = &drawable->Base;

    /* basic framebuffer setup */
    _mesa_initialize_window_framebuffer(fb, visual);

    /* add front renderbuffer */
    frontrb = swrast_new_renderbuffer(visual, dPriv, GL_TRUE);
    _mesa_add_renderbuffer(fb, BUFFER_FRONT_LEFT, &frontrb->Base.Base);

    /* add back renderbuffer */
    if (visual->doubleBufferMode) {
	backrb = swrast_new_renderbuffer(visual, dPriv, GL_FALSE);
	_mesa_add_renderbuffer(fb, BUFFER_BACK_LEFT, &backrb->Base.Base);
    }

    /* add software renderbuffers */
    _swrast_add_soft_renderbuffers(fb,
                                   GL_FALSE, /* color */
                                   visual->haveDepthBuffer,
                                   visual->haveStencilBuffer,
                                   visual->haveAccumBuffer,
                                   GL_FALSE, /* alpha */
                                   GL_FALSE /* aux bufs */);

    return GL_TRUE;

drawable_fail:

    if (drawable)
	free(drawable->row);

    free(drawable);

    return GL_FALSE;
}

static void
dri_destroy_buffer(__DRIdrawable * dPriv)
{
    TRACE;

    if (dPriv) {
	struct dri_drawable *drawable = dri_drawable(dPriv);
	struct gl_framebuffer *fb;

	free(drawable->row);

	fb = &drawable->Base;

	fb->DeletePending = GL_TRUE;
	_mesa_reference_framebuffer(&fb, NULL);
    }
}

static void
dri_swap_buffers(__DRIdrawable * dPriv)
{
    __DRIscreen *sPriv = dPriv->driScreenPriv;

    GET_CURRENT_CONTEXT(ctx);

    struct dri_drawable *drawable = dri_drawable(dPriv);
    struct gl_framebuffer *fb;
    struct dri_swrast_renderbuffer *frontrb, *backrb;

    TRACE;

    fb = &drawable->Base;

    frontrb =
	dri_swrast_renderbuffer(fb->Attachment[BUFFER_FRONT_LEFT].Renderbuffer);
    backrb =
	dri_swrast_renderbuffer(fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer);

    /* check for signle-buffered */
    if (backrb == NULL)
	return;

    /* check if swapping currently bound buffer */
    if (ctx && ctx->DrawBuffer == fb) {
	/* flush pending rendering */
	_mesa_notifySwapBuffers(ctx);
    }

    sPriv->swrast_loader->putImage(dPriv, __DRI_SWRAST_IMAGE_OP_SWAP,
				   0, 0,
				   frontrb->Base.Base.Width,
				   frontrb->Base.Base.Height,
				   (char *) backrb->Base.Buffer,
				   dPriv->loaderPrivate);
}


/**
 * General device driver functions.
 */

static void
get_window_size( struct gl_framebuffer *fb, GLsizei *w, GLsizei *h )
{
    __DRIdrawable *dPriv = swrast_drawable(fb)->dPriv;
    __DRIscreen *sPriv = dPriv->driScreenPriv;
    int x, y;

    sPriv->swrast_loader->getDrawableInfo(dPriv,
					  &x, &y, w, h,
					  dPriv->loaderPrivate);
}

static void
swrast_check_and_update_window_size( struct gl_context *ctx, struct gl_framebuffer *fb )
{
    GLsizei width, height;

    get_window_size(fb, &width, &height);
    if (fb->Width != width || fb->Height != height) {
	_mesa_resize_framebuffer(ctx, fb, width, height);
    }
}

static const GLubyte *
get_string(struct gl_context *ctx, GLenum pname)
{
    (void) ctx;
    switch (pname) {
	case GL_VENDOR:
	    return (const GLubyte *) swrast_vendor_string;
	case GL_RENDERER:
	    return (const GLubyte *) swrast_renderer_string;
	default:
	    return NULL;
    }
}

static void
update_state( struct gl_context *ctx, GLuint new_state )
{
    /* not much to do here - pass it on */
    _swrast_InvalidateState( ctx, new_state );
    _swsetup_InvalidateState( ctx, new_state );
    _vbo_InvalidateState( ctx, new_state );
    _tnl_InvalidateState( ctx, new_state );
}

static void
viewport(struct gl_context *ctx)
{
    struct gl_framebuffer *draw = ctx->WinSysDrawBuffer;
    struct gl_framebuffer *read = ctx->WinSysReadBuffer;

    swrast_check_and_update_window_size(ctx, draw);
    swrast_check_and_update_window_size(ctx, read);
}

static mesa_format swrastChooseTextureFormat(struct gl_context * ctx,
                                           GLenum target,
					   GLint internalFormat,
					   GLenum format,
					   GLenum type)
{
    if (internalFormat == GL_RGB)
	return MESA_FORMAT_B8G8R8X8_UNORM;
    return _mesa_choose_tex_format(ctx, target, internalFormat, format, type);
}

static void
swrast_init_driver_functions(struct dd_function_table *driver)
{
    driver->GetString = get_string;
    driver->UpdateState = update_state;
    driver->Viewport = viewport;
    driver->ChooseTextureFormat = swrastChooseTextureFormat;
    driver->MapRenderbuffer = swrast_map_renderbuffer;
    driver->UnmapRenderbuffer = swrast_unmap_renderbuffer;
}

/**
 * Context-related functions.
 */

static GLboolean
dri_create_context(gl_api api,
		   const struct gl_config * visual,
		   __DRIcontext * cPriv,
		   unsigned major_version,
		   unsigned minor_version,
		   uint32_t flags,
		   bool notify_reset,
		   unsigned *error,
		   void *sharedContextPrivate)
{
    struct dri_context *ctx = NULL;
    struct dri_context *share = (struct dri_context *)sharedContextPrivate;
    struct gl_context *mesaCtx = NULL;
    struct gl_context *sharedCtx = NULL;
    struct dd_function_table functions;

    TRACE;

    /* Flag filtering is handled in dri2CreateContextAttribs.
     */
    (void) flags;

    ctx = CALLOC_STRUCT(dri_context);
    if (ctx == NULL) {
	*error = __DRI_CTX_ERROR_NO_MEMORY;
	goto context_fail;
    }

    cPriv->driverPrivate = ctx;
    ctx->cPriv = cPriv;

    /* build table of device driver functions */
    _mesa_init_driver_functions(&functions);
    swrast_init_driver_functions(&functions);

    if (share) {
	sharedCtx = &share->Base;
    }

    mesaCtx = &ctx->Base;

    /* basic context setup */
    if (!_mesa_initialize_context(mesaCtx, api, visual, sharedCtx, &functions)) {
	*error = __DRI_CTX_ERROR_NO_MEMORY;
	goto context_fail;
    }

    driContextSetFlags(mesaCtx, flags);

    /* do bounds checking to prevent segfaults and server crashes! */
    mesaCtx->Const.CheckArrayBounds = GL_TRUE;

    /* create module contexts */
    _swrast_CreateContext( mesaCtx );
    _vbo_CreateContext( mesaCtx );
    _tnl_CreateContext( mesaCtx );
    _swsetup_CreateContext( mesaCtx );
    _swsetup_Wakeup( mesaCtx );

    /* use default TCL pipeline */
    {
       TNLcontext *tnl = TNL_CONTEXT(mesaCtx);
       tnl->Driver.RunPipeline = _tnl_run_pipeline;
    }

    _mesa_meta_init(mesaCtx);
    _mesa_enable_sw_extensions(mesaCtx);

    _mesa_compute_version(mesaCtx);

    _mesa_initialize_dispatch_tables(mesaCtx);
    _mesa_initialize_vbo_vtxfmt(mesaCtx);

    *error = __DRI_CTX_ERROR_SUCCESS;
    return GL_TRUE;

context_fail:

    free(ctx);

    return GL_FALSE;
}

static void
dri_destroy_context(__DRIcontext * cPriv)
{
    TRACE;

    if (cPriv) {
	struct dri_context *ctx = dri_context(cPriv);
	struct gl_context *mesaCtx;

	mesaCtx = &ctx->Base;

        _mesa_meta_free(mesaCtx);
	_swsetup_DestroyContext( mesaCtx );
	_swrast_DestroyContext( mesaCtx );
	_tnl_DestroyContext( mesaCtx );
	_vbo_DestroyContext( mesaCtx );
	_mesa_destroy_context( mesaCtx );
    }
}

static GLboolean
dri_make_current(__DRIcontext * cPriv,
		 __DRIdrawable * driDrawPriv,
		 __DRIdrawable * driReadPriv)
{
    struct gl_context *mesaCtx;
    struct gl_framebuffer *mesaDraw;
    struct gl_framebuffer *mesaRead;
    TRACE;

    if (cPriv) {
	struct dri_context *ctx = dri_context(cPriv);
	struct dri_drawable *draw;
	struct dri_drawable *read;

	if (!driDrawPriv || !driReadPriv)
	    return GL_FALSE;

	draw = dri_drawable(driDrawPriv);
	read = dri_drawable(driReadPriv);
	mesaCtx = &ctx->Base;
	mesaDraw = &draw->Base;
	mesaRead = &read->Base;

	/* check for same context and buffer */
	if (mesaCtx == _mesa_get_current_context()
	    && mesaCtx->DrawBuffer == mesaDraw
	    && mesaCtx->ReadBuffer == mesaRead) {
	    return GL_TRUE;
	}

	_glapi_check_multithread();

	swrast_check_and_update_window_size(mesaCtx, mesaDraw);
	if (mesaRead != mesaDraw)
	    swrast_check_and_update_window_size(mesaCtx, mesaRead);

	_mesa_make_current( mesaCtx,
			    mesaDraw,
			    mesaRead );
    }
    else {
	/* unbind */
	_mesa_make_current( NULL, NULL, NULL );
    }

    return GL_TRUE;
}

static GLboolean
dri_unbind_context(__DRIcontext * cPriv)
{
    TRACE;
    (void) cPriv;

    /* Unset current context and dispath table */
    _mesa_make_current(NULL, NULL, NULL);

    return GL_TRUE;
}

static void
dri_copy_sub_buffer(__DRIdrawable *dPriv, int x, int y,
                    int w, int h)
{
    __DRIscreen *sPriv = dPriv->driScreenPriv;
    void *data;
    int iy;
    struct dri_drawable *drawable = dri_drawable(dPriv);
    struct gl_framebuffer *fb;
    struct dri_swrast_renderbuffer *frontrb, *backrb;

    TRACE;

    fb = &drawable->Base;

    frontrb =
	dri_swrast_renderbuffer(fb->Attachment[BUFFER_FRONT_LEFT].Renderbuffer);
    backrb =
	dri_swrast_renderbuffer(fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer);

    /* check for signle-buffered */
    if (backrb == NULL)
       return;

    iy = frontrb->Base.Base.Height - y - h;
    data = (char *)backrb->Base.Buffer + (iy * backrb->pitch) + (x * ((backrb->bpp + 7) / 8));
    sPriv->swrast_loader->putImage2(dPriv, __DRI_SWRAST_IMAGE_OP_SWAP,
                                    x, iy, w, h,
                                    frontrb->pitch,
                                    data,
                                    dPriv->loaderPrivate);
}


static const struct __DriverAPIRec swrast_driver_api = {
    .InitScreen = dri_init_screen,
    .DestroyScreen = dri_destroy_screen,
    .CreateContext = dri_create_context,
    .DestroyContext = dri_destroy_context,
    .CreateBuffer = dri_create_buffer,
    .DestroyBuffer = dri_destroy_buffer,
    .SwapBuffers = dri_swap_buffers,
    .MakeCurrent = dri_make_current,
    .UnbindContext = dri_unbind_context,
    .CopySubBuffer = dri_copy_sub_buffer,
};

static const struct __DRIDriverVtableExtensionRec swrast_vtable = {
   .base = { __DRI_DRIVER_VTABLE, 1 },
   .vtable = &swrast_driver_api,
};

static const __DRIextension *swrast_driver_extensions[] = {
    &driCoreExtension.base,
    &driSWRastExtension.base,
    &driCopySubBufferExtension.base,
    &swrast_vtable.base,
    NULL
};

PUBLIC const __DRIextension **__driDriverGetExtensions_swrast(void)
{
   globalDriverAPI = &swrast_driver_api;

   return swrast_driver_extensions;
}
@


1.11
log
@Backport support for GLX_MESA_query_renderer for non Intel drivers.
This is desirable as the chromium port now uses this extension to
obtain pci vendor/device ids for use in feature/extension blacklists.

Prompted by a mail from byrnet@@, tested on r600g by krw@@

The newly added os_get_total_physical_memory() was passing the length of
a pointer rather than the type which made the sysctl call fail on
non 64 bit archs.  And it was passing the wrong pointer for the result.
Fixes for these problems have been submitted back upstream.
@
text
@@


1.10
log
@Merge Mesa 10.2.9
@
text
@d64 3
d123 65
d190 1
d671 1
a671 1
	    return (const GLubyte *) "Mesa Project";
d673 1
a673 1
	    return (const GLubyte *) "Software Rasterizer";
@


1.9
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a63 3
const char const *swrast_vendor_string = "Mesa Project";
const char const *swrast_renderer_string = "Software Rasterizer";

a119 65

static int
swrast_query_renderer_integer(__DRIscreen *psp, int param,
			       unsigned int *value)
{
   switch (param) {
   case __DRI2_RENDERER_VENDOR_ID:
   case __DRI2_RENDERER_DEVICE_ID:
      /* Return 0xffffffff for both vendor and device id */
      value[0] = 0xffffffff;
      return 0;
   case __DRI2_RENDERER_ACCELERATED:
      value[0] = 0;
      return 0;
   case __DRI2_RENDERER_VIDEO_MEMORY: {
      /* XXX: Do we want to return the full amount of system memory ? */
      const long system_memory_pages = sysconf(_SC_PHYS_PAGES);
      const long system_page_size = sysconf(_SC_PAGE_SIZE);

      if (system_memory_pages <= 0 || system_page_size <= 0)
         return -1;

      const uint64_t system_memory_bytes = (uint64_t) system_memory_pages
         * (uint64_t) system_page_size;

      const unsigned system_memory_megabytes =
         (unsigned) (system_memory_bytes / (1024 * 1024));

      value[0] = system_memory_megabytes;
      return 0;
   }
   case __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE:
      /**
       * XXX: Perhaps we should return 1 ?
       * See issue #7 from the spec, currently UNRESOLVED.
       */
      value[0] = 0;
      return 0;
   default:
      return driQueryRendererIntegerCommon(psp, param, value);
   }
}

static int
swrast_query_renderer_string(__DRIscreen *psp, int param, const char **value)
{
   switch (param) {
   case __DRI2_RENDERER_VENDOR_ID:
      value[0] = swrast_vendor_string;
      return 0;
   case __DRI2_RENDERER_DEVICE_ID:
      value[0] = swrast_renderer_string;
      return 0;
   default:
      return -1;
   }
}

static const __DRI2rendererQueryExtension swrast_query_renderer_extension = {
   .base = { __DRI2_RENDERER_QUERY, 1 },

   .queryInteger        = swrast_query_renderer_integer,
   .queryString         = swrast_query_renderer_string
};

a121 1
    &swrast_query_renderer_extension.base,
d602 1
a602 1
	    return (const GLubyte *) swrast_vendor_string;
d604 1
a604 1
	    return (const GLubyte *) swrast_renderer_string;
d705 3
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d64 3
d123 65
d190 1
d671 1
a671 1
	    return (const GLubyte *) "Mesa Project";
d673 1
a673 1
	    return (const GLubyte *) "Software Rasterizer";
a773 3

    /* do bounds checking to prevent segfaults and server crashes! */
    mesaCtx->Const.CheckArrayBounds = GL_TRUE;
@


1.7
log
@Merge Mesa 9.2.5
@
text
@d62 1
a73 1
    struct gl_texture_unit *texUnit;
d78 1
a78 1
    gl_format texFormat;
d84 1
a84 2
    texUnit = _mesa_get_current_tex_unit(&dri_ctx->Base);
    texObj = _mesa_select_tex_object(&dri_ctx->Base, texUnit, target);
d93 1
a93 1
	texFormat = MESA_FORMAT_XRGB8888;
d95 1
a95 1
	texFormat = MESA_FORMAT_ARGB8888;
d113 5
a117 3
    { __DRI_TEX_BUFFER, __DRI_TEX_BUFFER_VERSION },
    swrastSetTexBuffer,
    swrastSetTexBuffer2,
d133 1
a133 1
    gl_format format;
d169 1
a169 1
	format = MESA_FORMAT_RGB565;
d172 1
a172 1
        format = MESA_FORMAT_XRGB8888;
d175 1
a175 1
	format = MESA_FORMAT_ARGB8888;
d204 4
d348 1
a348 1
	rb->Format = MESA_FORMAT_ARGB8888;
d354 1
a354 1
	rb->Format = MESA_FORMAT_ARGB8888; /* XXX */
d360 1
a360 1
	rb->Format = MESA_FORMAT_RGB565;
d366 1
a366 1
	rb->Format = MESA_FORMAT_RGB332;
d621 1
a621 1
viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
a625 4
    (void) x;
    (void) y;
    (void) w;
    (void) h;
d630 1
a630 1
static gl_format swrastChooseTextureFormat(struct gl_context * ctx,
d637 1
a637 1
	return MESA_FORMAT_XRGB8888;
d663 1
a678 16
    switch (api) {
    case API_OPENGL_COMPAT:
        if (major_version > 2
	    || (major_version == 2 && minor_version > 1)) {
            *error = __DRI_CTX_ERROR_BAD_VERSION;
            return GL_FALSE;
        }
        break;
    case API_OPENGLES:
    case API_OPENGLES2:
        break;
    case API_OPENGL_CORE:
        *error = __DRI_CTX_ERROR_BAD_API;
        return GL_FALSE;
    }

d704 2
d821 33
d855 1
a855 1
const struct __DriverAPIRec driDriverAPI = {
d865 6
d873 1
a873 2
/* This is the table of extensions that the loader will dlsym() for. */
PUBLIC const __DRIextension *__driDriverExtensions[] = {
d876 2
d880 7
@


1.6
log
@Merge Mesa 9.2.0
@
text
@d400 1
a400 1
      sPriv->swrast_loader->getImage(dPriv, x, y, w, h,
d404 2
a405 2
      *out_map = xrb->Base.Buffer;
      *out_stride = stride;
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d17 4
a20 3
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d35 1
d42 2
d45 1
d60 1
d76 1
d87 1
d98 1
a98 1
    _mesa_init_teximage_fields(&dri_ctx->Base, target, texImage,
d101 1
a101 1
    sPriv->swrast_loader->getImage(dPriv, x, y, w, h, (char *)texImage->Data,
d132 1
a132 2
    GLenum fb_format;
    GLenum fb_type;
d145 3
a166 4
    case 8:
	fb_format = GL_RGB;
	fb_type = GL_UNSIGNED_BYTE_2_3_3_REV;
	break;
d168 1
a168 2
	fb_format = GL_RGB;
	fb_type = GL_UNSIGNED_SHORT_5_6_5;
d171 1
a171 2
	fb_format = GL_BGR;
	fb_type = GL_UNSIGNED_INT_8_8_8_8_REV;
d174 1
a174 2
	fb_format = GL_BGRA;
	fb_type = GL_UNSIGNED_INT_8_8_8_8_REV;
d182 1
a182 1
    configs = driCreateConfigs(fb_format, fb_type,
d199 1
a199 1
    __DRIconfig **configs8, **configs16, **configs24, **configs32;
a204 1
    configs8  = swrastFillInModes(psp,  8,  8, 0, 1);
a208 1
    configs16 = driConcatConfigs(configs8, configs16);
d219 1
d258 1
a258 1
swrast_delete_renderbuffer(struct gl_renderbuffer *rb)
d260 2
d264 2
a265 2
    free(rb->Data);
    free(rb);
d281 1
a281 1
    struct swrast_renderbuffer *xrb = swrast_renderbuffer(rb);
d285 4
a288 1
    rb->Data = NULL;
a290 1

d300 1
a300 1
    struct swrast_renderbuffer *xrb = swrast_renderbuffer(rb);
d304 1
a304 1
    free(rb->Data);
d308 1
a308 1
    rb->Data = malloc(height * xrb->pitch);
d313 3
a315 2
static struct swrast_renderbuffer *
swrast_new_renderbuffer(const struct gl_config *visual, GLboolean front)
d317 2
a318 1
    struct swrast_renderbuffer *xrb = calloc(1, sizeof *xrb);
d326 3
a328 1
    _mesa_init_renderbuffer(&xrb->Base, 0);
d332 2
a333 1
    xrb->Base.Delete = swrast_delete_renderbuffer;
d335 1
a335 2
	xrb->Base.AllocStorage = swrast_alloc_front_storage;
	swrast_set_span_funcs_front(xrb, pixel_format);
d338 1
a338 2
	xrb->Base.AllocStorage = swrast_alloc_back_storage;
	swrast_set_span_funcs_back(xrb, pixel_format);
d343 3
a345 4
	xrb->Base.Format = MESA_FORMAT_ARGB8888;
	xrb->Base.InternalFormat = GL_RGBA;
	xrb->Base._BaseFormat = GL_RGBA;
	xrb->Base.DataType = GL_UNSIGNED_BYTE;
d349 3
a351 4
	xrb->Base.Format = MESA_FORMAT_ARGB8888; /* XXX */
	xrb->Base.InternalFormat = GL_RGB;
	xrb->Base._BaseFormat = GL_RGB;
	xrb->Base.DataType = GL_UNSIGNED_BYTE;
d355 3
a357 4
	xrb->Base.Format = MESA_FORMAT_RGB565;
	xrb->Base.InternalFormat = GL_RGB;
	xrb->Base._BaseFormat = GL_RGB;
	xrb->Base.DataType = GL_UNSIGNED_BYTE;
d361 3
a363 4
	xrb->Base.Format = MESA_FORMAT_RGB332;
	xrb->Base.InternalFormat = GL_RGB;
	xrb->Base._BaseFormat = GL_RGB;
	xrb->Base.DataType = GL_UNSIGNED_BYTE;
d367 1
d374 72
d453 1
a453 1
    struct swrast_renderbuffer *frontrb, *backrb;
d457 3
d467 1
a467 1
    drawable->row = malloc(MAX_WIDTH * 4);
d477 2
a478 2
    frontrb = swrast_new_renderbuffer(visual, GL_TRUE);
    _mesa_add_renderbuffer(fb, BUFFER_FRONT_LEFT, &frontrb->Base);
d482 2
a483 2
	backrb = swrast_new_renderbuffer(visual, GL_FALSE);
	_mesa_add_renderbuffer(fb, BUFFER_BACK_LEFT, &backrb->Base);
d487 7
a493 7
    _mesa_add_soft_renderbuffers(fb,
				 GL_FALSE, /* color */
				 visual->haveDepthBuffer,
				 visual->haveStencilBuffer,
				 visual->haveAccumBuffer,
				 GL_FALSE, /* alpha */
				 GL_FALSE /* aux bufs */);
d502 1
a502 1
    FREE(drawable);
d534 1
a534 1
    struct swrast_renderbuffer *frontrb, *backrb;
d541 1
a541 1
	swrast_renderbuffer(fb->Attachment[BUFFER_FRONT_LEFT].Renderbuffer);
d543 1
a543 1
	swrast_renderbuffer(fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer);
d557 3
a559 3
				   frontrb->Base.Width,
				   frontrb->Base.Height,
				   backrb->Base.Data,
d621 4
d630 1
d637 1
a637 1
    return _mesa_choose_tex_format(ctx, internalFormat, format, type);
a644 1
    driver->GetBufferSize = NULL;
d647 2
a648 55
}

static const char *es2_extensions[] = {
   /* Used by mesa internally (cf all_mesa_extensions in ../common/utils.c) */
   "GL_ARB_draw_buffers",
   "GL_ARB_multisample",
   "GL_ARB_texture_compression",
   "GL_ARB_transpose_matrix",
   "GL_ARB_vertex_buffer_object",
   "GL_ARB_window_pos",
   "GL_EXT_blend_func_separate",
   "GL_EXT_compiled_vertex_array",
   "GL_EXT_framebuffer_blit",
   "GL_EXT_multi_draw_arrays",
   "GL_EXT_polygon_offset",
   "GL_EXT_texture_object",
   "GL_EXT_vertex_array",
   "GL_IBM_multimode_draw_arrays",
   "GL_MESA_window_pos",
   "GL_NV_vertex_program",

   /* Required by GLES2 */
   "GL_ARB_fragment_program",
   "GL_ARB_fragment_shader",
   "GL_ARB_multitexture",
   "GL_ARB_shader_objects",
   "GL_ARB_texture_cube_map",
   "GL_ARB_texture_mirrored_repeat",
   "GL_ARB_texture_non_power_of_two",
   "GL_ARB_vertex_shader",
   "GL_EXT_blend_color",
   "GL_EXT_blend_equation_separate",
   "GL_EXT_blend_minmax",
   "GL_EXT_blend_subtract",
   "GL_EXT_stencil_wrap",

   /* Optional GLES2 */
   "GL_ARB_framebuffer_object",
   "GL_EXT_texture_filter_anisotropic",
   "GL_ARB_depth_texture",
   "GL_EXT_packed_depth_stencil",
   "GL_EXT_framebuffer_object",
   NULL,
};

static void
InitExtensionsES2(struct gl_context *ctx)
{
   int i;

   /* Can't use driInitExtensions() since it uses extensions from
    * main/remap_helper.h when called the first time. */

   for (i = 0; es2_extensions[i]; i++)
      _mesa_enable_extension(ctx, es2_extensions[i]);
d658 6
a663 1
		   __DRIcontext * cPriv, void *sharedContextPrivate)
d673 20
d694 2
a695 1
    if (ctx == NULL)
d697 1
d713 2
a714 1
    if (!_mesa_initialize_context(mesaCtx, api, visual, sharedCtx, &functions, (void *) cPriv)) {
d737 1
a737 7
    switch (api) {
    case API_OPENGL:
        _mesa_enable_1_3_extensions(mesaCtx);
        _mesa_enable_1_4_extensions(mesaCtx);
        _mesa_enable_1_5_extensions(mesaCtx);
        _mesa_enable_2_0_extensions(mesaCtx);
        _mesa_enable_2_1_extensions(mesaCtx);
d739 2
a740 12
        driInitExtensions( mesaCtx, NULL, GL_FALSE );
        break;
    case API_OPENGLES:
        _mesa_enable_1_3_extensions(mesaCtx);
        _mesa_enable_1_4_extensions(mesaCtx);
        _mesa_enable_1_5_extensions(mesaCtx);

        break;
    case API_OPENGLES2:
        InitExtensionsES2( mesaCtx);
        break;
    }
d742 1
d747 1
a747 1
    FREE(ctx);
@


1.4
log
@Merge Mesa 7.10.3
@
text
@d564 54
d654 1
a654 1
    if (!_mesa_initialize_context(mesaCtx, visual, sharedCtx, &functions, (void *) cPriv)) {
d674 1
a675 5
    _mesa_enable_1_3_extensions(mesaCtx);
    _mesa_enable_1_4_extensions(mesaCtx);
    _mesa_enable_1_5_extensions(mesaCtx);
    _mesa_enable_2_0_extensions(mesaCtx);
    _mesa_enable_2_1_extensions(mesaCtx);
d677 20
a696 3
    _mesa_meta_init(mesaCtx);

    driInitExtensions( mesaCtx, NULL, GL_FALSE );
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d2 1
a2 1
 * Copyright (C) 2008 George Sapountzis <gsap7@@yahoo.gr>
d50 4
d61 2
a62 3
static void
setupLoaderExtensions(__DRIscreen *psp,
		      const __DRIextension **extensions)
d64 31
a94 1
    int i;
d96 7
a102 4
    for (i = 0; extensions[i]; i++) {
	if (strcmp(extensions[i]->name, __DRI_SWRAST_LOADER) == 0)
	    psp->swrast_loader = (__DRIswrastLoaderExtension *) extensions[i];
    }
d105 11
d193 2
a194 3
static __DRIscreen *
driCreateNewScreen(int scrn, const __DRIextension **extensions,
		   const __DRIconfig ***driver_configs, void *data)
a195 2
    static const __DRIextension *emptyExtensionList[] = { NULL };
    __DRIscreen *psp;
a197 2
    (void) data;

d200 1
a200 8
    psp = calloc(1, sizeof(*psp));
    if (!psp)
	return NULL;

    setupLoaderExtensions(psp, extensions);

    psp->num = scrn;
    psp->extensions = emptyExtensionList;
d209 1
a209 4
    *driver_configs = (const __DRIconfig **)
       driConcatConfigs(configs24, configs32);

    driInitExtensions( NULL, NULL, GL_FALSE );
d211 1
a211 1
    return psp;
d214 2
a215 1
static void driDestroyScreen(__DRIscreen *psp)
a217 11

    if (psp) {
	free(psp);
    }
}

static const __DRIextension **driGetExtensions(__DRIscreen *psp)
{
    TRACE;

    return psp->extensions;
d226 1
a226 1
choose_pixel_format(const GLvisual *v)
d264 9
d274 1
a274 1
swrast_alloc_front_storage(GLcontext *ctx, struct gl_renderbuffer *rb,
a277 1
    unsigned mask = PITCH_ALIGN_BITS - 1;
d285 1
a285 2
    /* always pad to PITCH_ALIGN_BITS */
    xrb->pitch = ((width * xrb->bpp + mask) & ~mask) / 8;
d291 1
a291 1
swrast_alloc_back_storage(GLcontext *ctx, struct gl_renderbuffer *rb,
d308 1
a308 1
swrast_new_renderbuffer(const GLvisual *visual, GLboolean front)
d368 4
a371 3
static __DRIdrawable *
driCreateNewDrawable(__DRIscreen *screen,
		     const __DRIconfig *config, void *data)
d373 2
a374 1
    __DRIdrawable *buf;
d379 10
a388 7
    buf = calloc(1, sizeof *buf);
    if (!buf)
	return NULL;

    buf->loaderPrivate = data;

    buf->driScreenPriv = screen;
d390 1
a390 1
    buf->row = malloc(MAX_WIDTH * 4);
d393 1
a393 1
    _mesa_initialize_window_framebuffer(&buf->Base, &config->modes);
d396 2
a397 2
    frontrb = swrast_new_renderbuffer(&config->modes, GL_TRUE);
    _mesa_add_renderbuffer(&buf->Base, BUFFER_FRONT_LEFT, &frontrb->Base);
d400 3
a402 3
    if (config->modes.doubleBufferMode) {
	backrb = swrast_new_renderbuffer(&config->modes, GL_FALSE);
	_mesa_add_renderbuffer(&buf->Base, BUFFER_BACK_LEFT, &backrb->Base);
d406 1
a406 1
    _mesa_add_soft_renderbuffers(&buf->Base,
d408 3
a410 3
				 config->modes.haveDepthBuffer,
				 config->modes.haveStencilBuffer,
				 config->modes.haveAccumBuffer,
d414 10
a423 1
    return buf;
d427 1
a427 1
driDestroyDrawable(__DRIdrawable *buf)
d431 3
a433 2
    if (buf) {
	struct gl_framebuffer *fb = &buf->Base;
d435 3
a437 1
	free(buf->row);
d444 2
a445 1
static void driSwapBuffers(__DRIdrawable *buf)
d447 2
d451 5
a455 4
    struct swrast_renderbuffer *frontrb =
	swrast_renderbuffer(buf->Base.Attachment[BUFFER_FRONT_LEFT].Renderbuffer);
    struct swrast_renderbuffer *backrb =
	swrast_renderbuffer(buf->Base.Attachment[BUFFER_BACK_LEFT].Renderbuffer);
d457 1
a457 1
    __DRIscreen *screen = buf->driScreenPriv;
d459 4
a462 1
    TRACE;
d469 1
a469 1
    if (ctx && ctx->DrawBuffer == &(buf->Base)) {
d474 6
a479 6
    screen->swrast_loader->putImage(buf, __DRI_SWRAST_IMAGE_OP_SWAP,
				    0, 0,
				    frontrb->Base.Width,
				    frontrb->Base.Height,
				    backrb->Base.Data,
				    buf->loaderPrivate);
d488 1
a488 1
get_window_size( GLframebuffer *fb, GLsizei *w, GLsizei *h )
d490 2
a491 2
    __DRIdrawable *buf = swrast_drawable(fb);
    __DRIscreen *screen = buf->driScreenPriv;
d494 3
a496 3
    screen->swrast_loader->getDrawableInfo(buf,
					   &x, &y, w, h,
					   buf->loaderPrivate);
d500 1
a500 1
swrast_check_and_update_window_size( GLcontext *ctx, GLframebuffer *fb )
d511 1
a511 1
get_string(GLcontext *ctx, GLenum pname)
d525 1
a525 1
update_state( GLcontext *ctx, GLuint new_state )
d535 1
a535 1
viewport(GLcontext *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
d537 2
a538 2
    GLframebuffer *draw = ctx->WinSysDrawBuffer;
    GLframebuffer *read = ctx->WinSysReadBuffer;
d544 10
d561 1
d569 9
a577 6
static __DRIcontext *
driCreateNewContext(__DRIscreen *screen, const __DRIconfig *config,
		    __DRIcontext *shared, void *data)
{
    __DRIcontext *ctx;
    GLcontext *mesaCtx;
d582 3
a584 5
    ctx = calloc(1, sizeof *ctx);
    if (!ctx)
	return NULL;

    ctx->loaderPrivate = data;
d586 2
a587 1
    ctx->driScreenPriv = screen;
d593 2
a594 5
    if (!_mesa_initialize_context(&ctx->Base, &config->modes,
				  shared ? &shared->Base : NULL,
				  &functions, (void *) ctx)) {
      free(ctx);
      return NULL;
d599 5
d629 9
a637 1
    return ctx;
d641 1
a641 1
driDestroyContext(__DRIcontext *ctx)
a642 1
    GLcontext *mesaCtx;
d645 4
a648 1
    if (ctx) {
d650 1
d660 4
a663 2
static int
driCopyContext(__DRIcontext *dst, __DRIcontext *src, unsigned long mask)
d665 3
d670 4
a673 3
    _mesa_copy_context(&src->Base, &dst->Base, mask);
    return GL_TRUE;
}
d675 1
a675 11
static int driBindContext(__DRIcontext *ctx,
			  __DRIdrawable *draw,
			  __DRIdrawable *read)
{
    GLcontext *mesaCtx;
    GLframebuffer *mesaDraw;
    GLframebuffer *mesaRead;
    TRACE;

    if (ctx) {
	if (!draw || !read)
d678 2
d694 1
a694 1
	if (read != draw)
d709 2
a710 1
static int driUnbindContext(__DRIcontext *ctx)
d713 5
a717 1
    (void) ctx;
d722 10
a731 21
static const __DRIcoreExtension driCoreExtension = {
    { __DRI_CORE, __DRI_CORE_VERSION },
    NULL, /* driCreateNewScreen */
    driDestroyScreen,
    driGetExtensions,
    driGetConfigAttrib,
    driIndexConfigAttrib,
    NULL, /* driCreateNewDrawable */
    driDestroyDrawable,
    driSwapBuffers,
    driCreateNewContext,
    driCopyContext,
    driDestroyContext,
    driBindContext,
    driUnbindContext
};

static const __DRIswrastExtension driSWRastExtension = {
    { __DRI_SWRAST, __DRI_SWRAST_VERSION },
    driCreateNewScreen,
    driCreateNewDrawable
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d36 1
d47 1
a52 65
#define need_GL_VERSION_1_3
#define need_GL_VERSION_1_4
#define need_GL_VERSION_1_5
#define need_GL_VERSION_2_0
#define need_GL_VERSION_2_1

/* sw extensions for imaging */
#define need_GL_EXT_blend_color
#define need_GL_EXT_blend_minmax
#define need_GL_EXT_convolution
#define need_GL_EXT_histogram
#define need_GL_SGI_color_table

/* sw extensions not associated with some GL version */
#define need_GL_ARB_shader_objects
#define need_GL_ARB_vertex_program
#define need_GL_APPLE_vertex_array_object
#define need_GL_ATI_fragment_shader
#define need_GL_ATI_separate_stencil
#define need_GL_EXT_depth_bounds_test
#define need_GL_EXT_framebuffer_object
#define need_GL_EXT_framebuffer_blit
#define need_GL_EXT_gpu_program_parameters
#define need_GL_EXT_paletted_texture
#define need_GL_EXT_stencil_two_side
#define need_GL_IBM_multimode_draw_arrays
#define need_GL_MESA_resize_buffers
#define need_GL_NV_vertex_program
#define need_GL_NV_fragment_program

#include "extension_helper.h"

const struct dri_extension card_extensions[] =
{
    { "GL_VERSION_1_3",			GL_VERSION_1_3_functions },
    { "GL_VERSION_1_4",			GL_VERSION_1_4_functions },
    { "GL_VERSION_1_5",			GL_VERSION_1_5_functions },
    { "GL_VERSION_2_0",			GL_VERSION_2_0_functions },
    { "GL_VERSION_2_1",			GL_VERSION_2_1_functions },

    { "GL_EXT_blend_color",		GL_EXT_blend_color_functions },
    { "GL_EXT_blend_minmax",		GL_EXT_blend_minmax_functions },
    { "GL_EXT_convolution",		GL_EXT_convolution_functions },
    { "GL_EXT_histogram",		GL_EXT_histogram_functions },
    { "GL_SGI_color_table",		GL_SGI_color_table_functions },

    { "GL_ARB_shader_objects",		GL_ARB_shader_objects_functions },
    { "GL_ARB_vertex_program",		GL_ARB_vertex_program_functions },
    { "GL_APPLE_vertex_array_object",	GL_APPLE_vertex_array_object_functions },
    { "GL_ATI_fragment_shader",		GL_ATI_fragment_shader_functions },
    { "GL_ATI_separate_stencil",	GL_ATI_separate_stencil_functions },
    { "GL_EXT_depth_bounds_test",	GL_EXT_depth_bounds_test_functions },
    { "GL_EXT_framebuffer_object",	GL_EXT_framebuffer_object_functions },
    { "GL_EXT_framebuffer_blit",	GL_EXT_framebuffer_blit_functions },
    { "GL_EXT_gpu_program_parameters",	GL_EXT_gpu_program_parameters_functions },
    { "GL_EXT_paletted_texture",	GL_EXT_paletted_texture_functions },
    { "GL_EXT_stencil_two_side",	GL_EXT_stencil_two_side_functions },
    { "GL_IBM_multimode_draw_arrays",	GL_IBM_multimode_draw_arrays_functions },
    { "GL_MESA_resize_buffers",		GL_MESA_resize_buffers_functions },
    { "GL_NV_vertex_program",		GL_NV_vertex_program_functions },
    { "GL_NV_fragment_program",		GL_NV_fragment_program_functions },
    { NULL,				NULL }
};


d89 1
d104 2
d135 2
a136 1
			       back_buffer_factor);
d152 1
a152 1
    const __DRIconfig **configs8, **configs16, **configs24, **configs32;
d158 1
a158 1
    psp = _mesa_calloc(sizeof(*psp));
d174 2
a175 1
    *driver_configs = driConcatConfigs(configs24, configs32);
d177 1
a177 1
    driInitExtensions( NULL, card_extensions, GL_FALSE );
d187 1
a187 1
	_mesa_free(psp);
d206 1
a206 2
    if (v->rgbMode) {
	int depth = v->rgbBits;
d208 20
a227 25
	if (depth == 32
	    && v->redMask   == 0xff0000
	    && v->greenMask == 0x00ff00
	    && v->blueMask  == 0x0000ff)
	    return PF_A8R8G8B8;
	else if (depth == 24
	    && v->redMask   == 0xff0000
	    && v->greenMask == 0x00ff00
	    && v->blueMask  == 0x0000ff)
	    return PF_X8R8G8B8;
	else if (depth == 16
	    && v->redMask   == 0xf800
	    && v->greenMask == 0x07e0
	    && v->blueMask  == 0x001f)
	    return PF_R5G6B5;
	else if (depth == 8
	    && v->redMask   == 0x07
	    && v->greenMask == 0x38
	    && v->blueMask  == 0xc0)
	    return PF_R3G3B2;
    }
    else {
	if (v->indexBits == 8)
	    return PF_CI8;
    }
d238 2
a239 2
    _mesa_free(rb->Data);
    _mesa_free(rb);
d269 1
a269 1
    _mesa_free(rb->Data);
d273 1
a273 1
    rb->Data = _mesa_malloc(height * xrb->pitch);
d281 1
a281 1
    struct swrast_renderbuffer *xrb = _mesa_calloc(sizeof *xrb);
d305 1
a308 4
	xrb->Base.RedBits   = 8 * sizeof(GLubyte);
	xrb->Base.GreenBits = 8 * sizeof(GLubyte);
	xrb->Base.BlueBits  = 8 * sizeof(GLubyte);
	xrb->Base.AlphaBits = 8 * sizeof(GLubyte);
d312 1
a315 4
	xrb->Base.RedBits   = 8 * sizeof(GLubyte);
	xrb->Base.GreenBits = 8 * sizeof(GLubyte);
	xrb->Base.BlueBits  = 8 * sizeof(GLubyte);
	xrb->Base.AlphaBits = 0;
d319 1
a322 4
	xrb->Base.RedBits   = 5 * sizeof(GLubyte);
	xrb->Base.GreenBits = 6 * sizeof(GLubyte);
	xrb->Base.BlueBits  = 5 * sizeof(GLubyte);
	xrb->Base.AlphaBits = 0;
d326 1
a329 11
	xrb->Base.RedBits   = 3 * sizeof(GLubyte);
	xrb->Base.GreenBits = 3 * sizeof(GLubyte);
	xrb->Base.BlueBits  = 2 * sizeof(GLubyte);
	xrb->Base.AlphaBits = 0;
	xrb->bpp = 8;
	break;
    case PF_CI8:
	xrb->Base.InternalFormat = GL_COLOR_INDEX8_EXT;
	xrb->Base._BaseFormat = GL_COLOR_INDEX;
	xrb->Base.DataType = GL_UNSIGNED_BYTE;
	xrb->Base.IndexBits = 8 * sizeof(GLubyte);
d348 1
a348 1
    buf = _mesa_calloc(sizeof *buf);
d356 1
a356 1
    buf->row = _mesa_malloc(MAX_WIDTH * 4);
d359 1
a359 1
    _mesa_initialize_framebuffer(&buf->Base, &config->modes);
d391 1
a391 1
	_mesa_free(buf->row);
d394 1
a394 1
	_mesa_unreference_framebuffer(&fb);
d515 1
a515 1
    ctx = _mesa_calloc(sizeof *ctx);
d530 1
a530 1
      _mesa_free(ctx);
d559 2
d572 1
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d34 5
a38 5
#include "context.h"
#include "extensions.h"
#include "framebuffer.h"
#include "imports.h"
#include "renderbuffer.h"
d69 1
d75 1
d101 1
d107 1
d150 2
a151 2
    u_int8_t depth_bits_array[4];
    u_int8_t stencil_bits_array[4];
d169 2
a170 1
    if (pixel_bits == 8) {
d173 2
a174 2
    }
    else if (pixel_bits == 16) {
d177 6
a182 2
    }
    else {
d185 5
d211 1
a211 1
    __DRIconfig **configs8, **configs16, **configs32;
d228 1
d231 3
a233 3
    configs16 = (__DRIconfig **)driConcatConfigs(configs8, configs16);

    *driver_configs = driConcatConfigs(configs16, configs32);
d265 1
a265 1
	int bpp = v->rgbBits;
d267 1
a267 1
	if (bpp == 32
d272 6
a277 1
	else if (bpp == 16
d282 1
a282 1
	else if (bpp == 8
a310 1
    int bpp;
a318 15
    switch (internalFormat) {
    case GL_RGB:
	bpp = rb->RedBits + rb->GreenBits + rb->BlueBits;
	break;
    case GL_RGBA:
	bpp = rb->RedBits + rb->GreenBits + rb->BlueBits + rb->AlphaBits;
	break;
    case GL_COLOR_INDEX8_EXT:
	bpp = rb->IndexBits;
	break;
    default:
	_mesa_problem( NULL, "unexpected format in %s", __FUNCTION__ );
	return GL_FALSE;
    }

d320 1
a320 1
    xrb->pitch = ((width * bpp + mask) & ~mask) / 8;
d376 11
d396 1
d406 1
d413 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d2 1
a2 1
 * Copyright 2008, 2010 George Sapountzis <gsapountzis@@gmail.com>
d34 5
a38 6
#include "main/context.h"
#include "main/extensions.h"
#include "main/formats.h"
#include "main/framebuffer.h"
#include "main/imports.h"
#include "main/renderbuffer.h"
a45 1
#include "drivers/common/meta.h"
d48 2
a49 3
#include "main/teximage.h"
#include "main/texformat.h"
#include "main/texstate.h"
d51 59
a109 1
#include "swrast_priv.h"
d116 3
a118 2
static void swrastSetTexBuffer2(__DRIcontext *pDRICtx, GLint target,
				GLint texture_format, __DRIdrawable *dPriv)
d120 1
a120 8
    struct dri_context *dri_ctx;
    int x, y, w, h;
    __DRIscreen *sPriv = dPriv->driScreenPriv;
    struct gl_texture_unit *texUnit;
    struct gl_texture_object *texObj;
    struct gl_texture_image *texImage;
    uint32_t internalFormat;
    gl_format texFormat;
d122 4
a125 24
    dri_ctx = pDRICtx->driverPrivate;

    internalFormat = (texture_format == __DRI_TEXTURE_FORMAT_RGB ? 3 : 4);

    texUnit = _mesa_get_current_tex_unit(&dri_ctx->Base);
    texObj = _mesa_select_tex_object(&dri_ctx->Base, texUnit, target);
    texImage = _mesa_get_tex_image(&dri_ctx->Base, texObj, target, 0);

    _mesa_lock_texture(&dri_ctx->Base, texObj);

    sPriv->swrast_loader->getDrawableInfo(dPriv, &x, &y, &w, &h, dPriv->loaderPrivate);

    if (texture_format == __DRI_TEXTURE_FORMAT_RGB)
	texFormat = MESA_FORMAT_XRGB8888;
    else
	texFormat = MESA_FORMAT_ARGB8888;

    _mesa_init_teximage_fields(&dri_ctx->Base, target, texImage,
			       w, h, 1, 0, internalFormat, texFormat);

    sPriv->swrast_loader->getImage(dPriv, x, y, w, h, (char *)texImage->Data,
				   dPriv->loaderPrivate);

    _mesa_unlock_texture(&dri_ctx->Base, texObj);
a127 17
static void swrastSetTexBuffer(__DRIcontext *pDRICtx, GLint target,
			       __DRIdrawable *dPriv)
{
    swrastSetTexBuffer2(pDRICtx, target, __DRI_TEXTURE_FORMAT_RGBA, dPriv);
}

static const __DRItexBufferExtension swrastTexBufferExtension = {
    { __DRI_TEX_BUFFER, __DRI_TEX_BUFFER_VERSION },
    swrastSetTexBuffer,
    swrastSetTexBuffer2,
};

static const __DRIextension *dri_screen_extensions[] = {
    &swrastTexBufferExtension.base,
    NULL
};

d146 2
a147 3
    uint8_t depth_bits_array[4];
    uint8_t stencil_bits_array[4];
    uint8_t msaa_samples_array[1];
a161 2
    msaa_samples_array[0] = 0;

d165 1
a165 2
    switch (pixel_bits) {
    case 8:
d168 2
a169 2
	break;
    case 16:
d172 2
a173 6
	break;
    case 24:
	fb_format = GL_BGR;
	fb_type = GL_UNSIGNED_INT_8_8_8_8_REV;
	break;
    case 32:
a175 5
	break;
    default:
	fprintf(stderr, "[%s:%u] bad depth %d\n", __func__, __LINE__,
		pixel_bits);
	return NULL;
d181 1
a181 2
			       back_buffer_factor, msaa_samples_array, 1,
			       GL_TRUE);
d191 3
a193 2
static const __DRIconfig **
dri_init_screen(__DRIscreen * psp)
d195 5
a199 1
    __DRIconfig **configs8, **configs16, **configs24, **configs32;
d203 8
a210 1
    psp->extensions = dri_screen_extensions;
a213 1
    configs24 = swrastFillInModes(psp, 24, 24, 8, 1);
d216 3
a218 3
    configs16 = driConcatConfigs(configs8, configs16);
    configs24 = driConcatConfigs(configs16, configs24);
    configs32 = driConcatConfigs(configs24, configs32);
d220 3
a222 1
    return (const __DRIconfig **)configs32;
d225 10
a234 2
static void
dri_destroy_screen(__DRIscreen * sPriv)
d237 2
d247 1
a247 1
choose_pixel_format(const struct gl_config *v)
d249 2
a250 1
    int depth = v->rgbBits;
d252 20
a271 20
    if (depth == 32
	&& v->redMask   == 0xff0000
	&& v->greenMask == 0x00ff00
	&& v->blueMask  == 0x0000ff)
	return PF_A8R8G8B8;
    else if (depth == 24
	     && v->redMask   == 0xff0000
	     && v->greenMask == 0x00ff00
	     && v->blueMask  == 0x0000ff)
	return PF_X8R8G8B8;
    else if (depth == 16
	     && v->redMask   == 0xf800
	     && v->greenMask == 0x07e0
	     && v->blueMask  == 0x001f)
	return PF_R5G6B5;
    else if (depth == 8
	     && v->redMask   == 0x07
	     && v->greenMask == 0x38
	     && v->blueMask  == 0xc0)
	return PF_R3G3B2;
d282 2
a283 11
    free(rb->Data);
    free(rb);
}

/* see bytes_per_line in libGL */
static INLINE int
bytes_per_line(unsigned pitch_bits, unsigned mul)
{
   unsigned mask = mul - 1;

   return ((pitch_bits + mask) & ~mask) / 8;
d287 1
a287 1
swrast_alloc_front_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
d291 2
d300 17
a316 1
    xrb->pitch = bytes_per_line(width * xrb->bpp, 32);
d322 1
a322 1
swrast_alloc_back_storage(struct gl_context *ctx, struct gl_renderbuffer *rb,
d329 1
a329 1
    free(rb->Data);
d333 1
a333 1
    rb->Data = malloc(height * xrb->pitch);
d339 1
a339 1
swrast_new_renderbuffer(const struct gl_config *visual, GLboolean front)
d341 1
a341 1
    struct swrast_renderbuffer *xrb = calloc(1, sizeof *xrb);
a364 1
	xrb->Base.Format = MESA_FORMAT_ARGB8888;
d368 4
a371 1
	xrb->bpp = 32;
d373 1
a373 2
    case PF_X8R8G8B8:
	xrb->Base.Format = MESA_FORMAT_ARGB8888; /* XXX */
d377 4
a380 1
	xrb->bpp = 32;
d382 1
a382 2
    case PF_R5G6B5:
	xrb->Base.Format = MESA_FORMAT_RGB565;
d386 4
a389 1
	xrb->bpp = 16;
d391 3
a393 4
    case PF_R3G3B2:
	xrb->Base.Format = MESA_FORMAT_RGB332;
	xrb->Base.InternalFormat = GL_RGB;
	xrb->Base._BaseFormat = GL_RGB;
d395 1
a395 1
	xrb->bpp = 8;
d404 3
a406 4
static GLboolean
dri_create_buffer(__DRIscreen * sPriv,
		  __DRIdrawable * dPriv,
		  const struct gl_config * visual, GLboolean isPixmap)
d408 1
a408 2
    struct dri_drawable *drawable = NULL;
    struct gl_framebuffer *fb;
d413 7
a419 10
    drawable = CALLOC_STRUCT(dri_drawable);
    if (drawable == NULL)
	goto drawable_fail;

    dPriv->driverPrivate = drawable;
    drawable->dPriv = dPriv;

    drawable->row = malloc(MAX_WIDTH * 4);
    if (drawable->row == NULL)
	goto drawable_fail;
d421 1
a421 1
    fb = &drawable->Base;
d424 1
a424 1
    _mesa_initialize_window_framebuffer(fb, visual);
d427 2
a428 2
    frontrb = swrast_new_renderbuffer(visual, GL_TRUE);
    _mesa_add_renderbuffer(fb, BUFFER_FRONT_LEFT, &frontrb->Base);
d431 3
a433 3
    if (visual->doubleBufferMode) {
	backrb = swrast_new_renderbuffer(visual, GL_FALSE);
	_mesa_add_renderbuffer(fb, BUFFER_BACK_LEFT, &backrb->Base);
d437 1
a437 1
    _mesa_add_soft_renderbuffers(fb,
d439 3
a441 3
				 visual->haveDepthBuffer,
				 visual->haveStencilBuffer,
				 visual->haveAccumBuffer,
d445 1
a445 10
    return GL_TRUE;

drawable_fail:

    if (drawable)
	free(drawable->row);

    FREE(drawable);

    return GL_FALSE;
d449 1
a449 1
dri_destroy_buffer(__DRIdrawable * dPriv)
d453 2
a454 5
    if (dPriv) {
	struct dri_drawable *drawable = dri_drawable(dPriv);
	struct gl_framebuffer *fb;

	free(drawable->row);
d456 1
a456 1
	fb = &drawable->Base;
d459 1
a459 1
	_mesa_reference_framebuffer(&fb, NULL);
d463 1
a463 2
static void
dri_swap_buffers(__DRIdrawable * dPriv)
d465 1
a465 1
    __DRIscreen *sPriv = dPriv->driScreenPriv;
d467 4
a470 1
    GET_CURRENT_CONTEXT(ctx);
d472 1
a472 3
    struct dri_drawable *drawable = dri_drawable(dPriv);
    struct gl_framebuffer *fb;
    struct swrast_renderbuffer *frontrb, *backrb;
a475 7
    fb = &drawable->Base;

    frontrb =
	swrast_renderbuffer(fb->Attachment[BUFFER_FRONT_LEFT].Renderbuffer);
    backrb =
	swrast_renderbuffer(fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer);

d481 1
a481 1
    if (ctx && ctx->DrawBuffer == fb) {
d486 6
a491 6
    sPriv->swrast_loader->putImage(dPriv, __DRI_SWRAST_IMAGE_OP_SWAP,
				   0, 0,
				   frontrb->Base.Width,
				   frontrb->Base.Height,
				   backrb->Base.Data,
				   dPriv->loaderPrivate);
d500 1
a500 1
get_window_size( struct gl_framebuffer *fb, GLsizei *w, GLsizei *h )
d502 2
a503 2
    __DRIdrawable *dPriv = swrast_drawable(fb)->dPriv;
    __DRIscreen *sPriv = dPriv->driScreenPriv;
d506 3
a508 3
    sPriv->swrast_loader->getDrawableInfo(dPriv,
					  &x, &y, w, h,
					  dPriv->loaderPrivate);
d512 1
a512 1
swrast_check_and_update_window_size( struct gl_context *ctx, struct gl_framebuffer *fb )
d523 1
a523 1
get_string(struct gl_context *ctx, GLenum pname)
d537 1
a537 1
update_state( struct gl_context *ctx, GLuint new_state )
d547 1
a547 1
viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
d549 2
a550 2
    struct gl_framebuffer *draw = ctx->WinSysDrawBuffer;
    struct gl_framebuffer *read = ctx->WinSysReadBuffer;
a555 10
static gl_format swrastChooseTextureFormat(struct gl_context * ctx,
					   GLint internalFormat,
					   GLenum format,
					   GLenum type)
{
    if (internalFormat == GL_RGB)
	return MESA_FORMAT_XRGB8888;
    return _mesa_choose_tex_format(ctx, internalFormat, format, type);
}

a562 1
    driver->ChooseTextureFormat = swrastChooseTextureFormat;
d570 6
a575 9
static GLboolean
dri_create_context(gl_api api,
		   const struct gl_config * visual,
		   __DRIcontext * cPriv, void *sharedContextPrivate)
{
    struct dri_context *ctx = NULL;
    struct dri_context *share = (struct dri_context *)sharedContextPrivate;
    struct gl_context *mesaCtx = NULL;
    struct gl_context *sharedCtx = NULL;
d580 3
a582 3
    ctx = CALLOC_STRUCT(dri_context);
    if (ctx == NULL)
	goto context_fail;
d584 3
a586 2
    cPriv->driverPrivate = ctx;
    ctx->cPriv = cPriv;
d592 5
a596 2
    if (share) {
	sharedCtx = &share->Base;
a600 5
    /* basic context setup */
    if (!_mesa_initialize_context(mesaCtx, visual, sharedCtx, &functions, (void *) cPriv)) {
	goto context_fail;
    }

d624 1
a624 11
    _mesa_meta_init(mesaCtx);

    driInitExtensions( mesaCtx, NULL, GL_FALSE );

    return GL_TRUE;

context_fail:

    FREE(ctx);

    return GL_FALSE;
d628 1
a628 1
dri_destroy_context(__DRIcontext * cPriv)
d630 1
d633 1
a633 4
    if (cPriv) {
	struct dri_context *ctx = dri_context(cPriv);
	struct gl_context *mesaCtx;

a634 2

        _mesa_meta_free(mesaCtx);
d643 2
a644 4
static GLboolean
dri_make_current(__DRIcontext * cPriv,
		 __DRIdrawable * driDrawPriv,
		 __DRIdrawable * driReadPriv)
a645 3
    struct gl_context *mesaCtx;
    struct gl_framebuffer *mesaDraw;
    struct gl_framebuffer *mesaRead;
d648 12
a659 4
    if (cPriv) {
	struct dri_context *ctx = dri_context(cPriv);
	struct dri_drawable *draw;
	struct dri_drawable *read;
d661 2
a662 1
	if (!driDrawPriv || !driReadPriv)
a664 2
	draw = dri_drawable(driDrawPriv);
	read = dri_drawable(driReadPriv);
d679 1
a679 1
	if (mesaRead != mesaDraw)
d694 1
a694 2
static GLboolean
dri_unbind_context(__DRIcontext * cPriv)
d697 1
a697 5
    (void) cPriv;

    /* Unset current context and dispath table */
    _mesa_make_current(NULL, NULL, NULL);

d702 21
a722 10
const struct __DriverAPIRec driDriverAPI = {
    .InitScreen = dri_init_screen,
    .DestroyScreen = dri_destroy_screen,
    .CreateContext = dri_create_context,
    .DestroyContext = dri_destroy_context,
    .CreateBuffer = dri_create_buffer,
    .DestroyBuffer = dri_destroy_buffer,
    .SwapBuffers = dri_swap_buffers,
    .MakeCurrent = dri_make_current,
    .UnbindContext = dri_unbind_context,
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d17 3
a19 4
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
a33 1
#include "main/api_exec.h"
a39 2
#include "main/version.h"
#include "main/vtxfmt.h"
a40 1
#include "swrast/s_renderbuffer.h"
a54 1
#include "swrast/s_context.h"
a69 1
    struct swrast_texture_image *swImage;
a79 1
    swImage = swrast_texture_image(texImage);
d90 1
a90 1
    _mesa_init_teximage_fields(&dri_ctx->Base, texImage,
d93 1
a93 1
    sPriv->swrast_loader->getImage(dPriv, x, y, w, h, (char *)swImage->Buffer,
d124 2
a125 1
    gl_format format;
a137 3
    (void) psp;
    (void) have_back_buffer;

d157 4
d162 2
a163 1
	format = MESA_FORMAT_RGB565;
d166 2
a167 1
        format = MESA_FORMAT_XRGB8888;
d170 2
a171 1
	format = MESA_FORMAT_ARGB8888;
d179 1
a179 1
    configs = driCreateConfigs(format,
d196 1
a196 1
    __DRIconfig **configs16, **configs24, **configs32;
d202 1
d207 1
a217 1
    (void) sPriv;
d256 1
a256 1
swrast_delete_renderbuffer(struct gl_context *ctx, struct gl_renderbuffer *rb)
a257 2
    struct dri_swrast_renderbuffer *xrb = dri_swrast_renderbuffer(rb);

d260 2
a261 2
    free(xrb->Base.Buffer);
    _mesa_delete_renderbuffer(ctx, rb);
d277 1
a277 1
    struct dri_swrast_renderbuffer *xrb = dri_swrast_renderbuffer(rb);
d281 1
a281 4
    (void) ctx;
    (void) internalFormat;

    xrb->Base.Buffer = NULL;
d284 1
d294 1
a294 1
    struct dri_swrast_renderbuffer *xrb = dri_swrast_renderbuffer(rb);
d298 1
a298 1
    free(xrb->Base.Buffer);
d302 1
a302 1
    xrb->Base.Buffer = malloc(height * xrb->pitch);
d307 2
a308 3
static struct dri_swrast_renderbuffer *
swrast_new_renderbuffer(const struct gl_config *visual, __DRIdrawable *dPriv,
			GLboolean front)
d310 1
a310 2
    struct dri_swrast_renderbuffer *xrb = calloc(1, sizeof *xrb);
    struct gl_renderbuffer *rb;
d318 1
a318 3
    rb = &xrb->Base.Base;

    _mesa_init_renderbuffer(rb, 0);
d322 1
a322 2
    xrb->dPriv = dPriv;
    xrb->Base.Base.Delete = swrast_delete_renderbuffer;
d324 2
a325 1
        rb->AllocStorage = swrast_alloc_front_storage;
d328 2
a329 1
	rb->AllocStorage = swrast_alloc_back_storage;
d334 4
a337 3
	rb->Format = MESA_FORMAT_ARGB8888;
	rb->InternalFormat = GL_RGBA;
	rb->_BaseFormat = GL_RGBA;
d341 4
a344 3
	rb->Format = MESA_FORMAT_ARGB8888; /* XXX */
	rb->InternalFormat = GL_RGB;
	rb->_BaseFormat = GL_RGB;
d348 4
a351 3
	rb->Format = MESA_FORMAT_RGB565;
	rb->InternalFormat = GL_RGB;
	rb->_BaseFormat = GL_RGB;
d355 4
a358 3
	rb->Format = MESA_FORMAT_RGB332;
	rb->InternalFormat = GL_RGB;
	rb->_BaseFormat = GL_RGB;
a361 1
	free(xrb);
a367 72
static void
swrast_map_renderbuffer(struct gl_context *ctx,
			struct gl_renderbuffer *rb,
			GLuint x, GLuint y, GLuint w, GLuint h,
			GLbitfield mode,
			GLubyte **out_map,
			GLint *out_stride)
{
   struct dri_swrast_renderbuffer *xrb = dri_swrast_renderbuffer(rb);
   GLubyte *map = xrb->Base.Buffer;
   int cpp = _mesa_get_format_bytes(rb->Format);
   int stride = rb->Width * cpp;

   if (rb->AllocStorage == swrast_alloc_front_storage) {
      __DRIdrawable *dPriv = xrb->dPriv;
      __DRIscreen *sPriv = dPriv->driScreenPriv;

      xrb->map_mode = mode;
      xrb->map_x = x;
      xrb->map_y = y;
      xrb->map_w = w;
      xrb->map_h = h;

      stride = w * cpp;
      xrb->Base.Buffer = malloc(h * stride);

      sPriv->swrast_loader->getImage(dPriv, x, y, w, h,
				     (char *) xrb->Base.Buffer,
				     dPriv->loaderPrivate);

      *out_map = xrb->Base.Buffer;
      *out_stride = stride;
      return;
   }

   ASSERT(xrb->Base.Buffer);

   if (rb->AllocStorage == swrast_alloc_back_storage) {
      map += (rb->Height - 1) * stride;
      stride = -stride;
   }

   map += (GLsizei)y * stride;
   map += (GLsizei)x * cpp;

   *out_map = map;
   *out_stride = stride;
}

static void
swrast_unmap_renderbuffer(struct gl_context *ctx,
			  struct gl_renderbuffer *rb)
{
   struct dri_swrast_renderbuffer *xrb = dri_swrast_renderbuffer(rb);

   if (rb->AllocStorage == swrast_alloc_front_storage) {
      __DRIdrawable *dPriv = xrb->dPriv;
      __DRIscreen *sPriv = dPriv->driScreenPriv;

      if (xrb->map_mode & GL_MAP_WRITE_BIT) {
	 sPriv->swrast_loader->putImage(dPriv, __DRI_SWRAST_IMAGE_OP_DRAW,
					xrb->map_x, xrb->map_y,
					xrb->map_w, xrb->map_h,
					(char *) xrb->Base.Buffer,
					dPriv->loaderPrivate);
      }

      free(xrb->Base.Buffer);
      xrb->Base.Buffer = NULL;
   }
}

d375 1
a375 1
    struct dri_swrast_renderbuffer *frontrb, *backrb;
a378 3
    (void) sPriv;
    (void) isPixmap;

d386 1
a386 1
    drawable->row = malloc(SWRAST_MAX_WIDTH * 4);
d396 2
a397 2
    frontrb = swrast_new_renderbuffer(visual, dPriv, GL_TRUE);
    _mesa_add_renderbuffer(fb, BUFFER_FRONT_LEFT, &frontrb->Base.Base);
d401 2
a402 2
	backrb = swrast_new_renderbuffer(visual, dPriv, GL_FALSE);
	_mesa_add_renderbuffer(fb, BUFFER_BACK_LEFT, &backrb->Base.Base);
d406 7
a412 7
    _swrast_add_soft_renderbuffers(fb,
                                   GL_FALSE, /* color */
                                   visual->haveDepthBuffer,
                                   visual->haveStencilBuffer,
                                   visual->haveAccumBuffer,
                                   GL_FALSE, /* alpha */
                                   GL_FALSE /* aux bufs */);
d421 1
a421 1
    free(drawable);
d453 1
a453 1
    struct dri_swrast_renderbuffer *frontrb, *backrb;
d460 1
a460 1
	dri_swrast_renderbuffer(fb->Attachment[BUFFER_FRONT_LEFT].Renderbuffer);
d462 1
a462 1
	dri_swrast_renderbuffer(fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer);
d476 3
a478 3
				   frontrb->Base.Base.Width,
				   frontrb->Base.Base.Height,
				   (char *) backrb->Base.Buffer,
a539 4
    (void) x;
    (void) y;
    (void) w;
    (void) h;
a544 1
                                           GLenum target,
d551 1
a551 1
    return _mesa_choose_tex_format(ctx, target, internalFormat, format, type);
d559 1
a561 2
    driver->MapRenderbuffer = swrast_map_renderbuffer;
    driver->UnmapRenderbuffer = swrast_unmap_renderbuffer;
d564 1
d572 1
a572 6
		   __DRIcontext * cPriv,
		   unsigned major_version,
		   unsigned minor_version,
		   uint32_t flags,
		   unsigned *error,
		   void *sharedContextPrivate)
a581 20
    /* Flag filtering is handled in dri2CreateContextAttribs.
     */
    (void) flags;

    switch (api) {
    case API_OPENGL_COMPAT:
        if (major_version > 2
	    || (major_version == 2 && minor_version > 1)) {
            *error = __DRI_CTX_ERROR_BAD_VERSION;
            return GL_FALSE;
        }
        break;
    case API_OPENGLES:
    case API_OPENGLES2:
        break;
    case API_OPENGL_CORE:
        *error = __DRI_CTX_ERROR_BAD_API;
        return GL_FALSE;
    }

d583 1
a583 2
    if (ctx == NULL) {
	*error = __DRI_CTX_ERROR_NO_MEMORY;
a584 1
    }
d600 1
a600 2
    if (!_mesa_initialize_context(mesaCtx, api, visual, sharedCtx, &functions)) {
	*error = __DRI_CTX_ERROR_NO_MEMORY;
a619 1
    _mesa_meta_init(mesaCtx);
d621 5
d627 1
a627 1
    _mesa_compute_version(mesaCtx);
d629 1
a629 2
    _mesa_initialize_dispatch_tables(mesaCtx);
    _mesa_initialize_vbo_vtxfmt(mesaCtx);
a630 1
    *error = __DRI_CTX_ERROR_SUCCESS;
d635 1
a635 1
    free(ctx);
@


1.1.1.3
log
@Import Mesa 9.2.5
@
text
@d400 1
a400 1
      sPriv->swrast_loader->getImage(dPriv, x, rb->Height - y - h, w, h,
d404 2
a405 2
      *out_map = xrb->Base.Buffer + (h - 1) * stride;
      *out_stride = -stride;
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@a61 1
const __DRIextension **__driDriverGetExtensions_swrast(void);
d73 1
d78 1
a78 1
    mesa_format texFormat;
d84 2
a85 1
    texObj = _mesa_get_current_tex_object(&dri_ctx->Base, target);
d94 1
a94 1
	texFormat = MESA_FORMAT_B8G8R8X8_UNORM;
d96 1
a96 1
	texFormat = MESA_FORMAT_B8G8R8A8_UNORM;
d114 3
a116 5
   .base = { __DRI_TEX_BUFFER, 3 },

   .setTexBuffer        = swrastSetTexBuffer,
   .setTexBuffer2       = swrastSetTexBuffer2,
   .releaseTexBuffer    = NULL,
d132 1
a132 1
    mesa_format format;
d168 1
a168 1
	format = MESA_FORMAT_B5G6R5_UNORM;
d171 1
a171 1
        format = MESA_FORMAT_B8G8R8X8_UNORM;
d174 1
a174 1
	format = MESA_FORMAT_B8G8R8A8_UNORM;
a202 4
    psp->max_gl_compat_version = 21;
    psp->max_gl_es1_version = 11;
    psp->max_gl_es2_version = 20;

d343 1
a343 1
	rb->Format = MESA_FORMAT_B8G8R8A8_UNORM;
d349 1
a349 1
	rb->Format = MESA_FORMAT_B8G8R8A8_UNORM; /* XXX */
d355 1
a355 1
	rb->Format = MESA_FORMAT_B5G6R5_UNORM;
d361 1
a361 1
	rb->Format = MESA_FORMAT_B2G3R3_UNORM;
d616 1
a616 1
viewport(struct gl_context *ctx)
d621 4
d629 1
a629 1
static mesa_format swrastChooseTextureFormat(struct gl_context * ctx,
d636 1
a636 1
	return MESA_FORMAT_B8G8R8X8_UNORM;
a661 1
		   bool notify_reset,
d677 16
a717 2
    driContextSetFlags(mesaCtx, flags);

a832 33
static void
dri_copy_sub_buffer(__DRIdrawable *dPriv, int x, int y,
                    int w, int h)
{
    __DRIscreen *sPriv = dPriv->driScreenPriv;
    void *data;
    int iy;
    struct dri_drawable *drawable = dri_drawable(dPriv);
    struct gl_framebuffer *fb;
    struct dri_swrast_renderbuffer *frontrb, *backrb;

    TRACE;

    fb = &drawable->Base;

    frontrb =
	dri_swrast_renderbuffer(fb->Attachment[BUFFER_FRONT_LEFT].Renderbuffer);
    backrb =
	dri_swrast_renderbuffer(fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer);

    /* check for signle-buffered */
    if (backrb == NULL)
       return;

    iy = frontrb->Base.Base.Height - y - h;
    data = (char *)backrb->Base.Buffer + (iy * backrb->pitch) + (x * ((backrb->bpp + 7) / 8));
    sPriv->swrast_loader->putImage2(dPriv, __DRI_SWRAST_IMAGE_OP_SWAP,
                                    x, iy, w, h,
                                    frontrb->pitch,
                                    data,
                                    dPriv->loaderPrivate);
}

d834 1
a834 1
static const struct __DriverAPIRec swrast_driver_api = {
a843 6
    .CopySubBuffer = dri_copy_sub_buffer,
};

static const struct __DRIDriverVtableExtensionRec swrast_vtable = {
   .base = { __DRI_DRIVER_VTABLE, 1 },
   .vtable = &swrast_driver_api,
d846 2
a847 1
static const __DRIextension *swrast_driver_extensions[] = {
a849 2
    &driCopySubBufferExtension.base,
    &swrast_vtable.base,
a851 7

PUBLIC const __DRIextension **__driDriverGetExtensions_swrast(void)
{
   globalDriverAPI = &swrast_driver_api;

   return swrast_driver_extensions;
}
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@a63 3
const char const *swrast_vendor_string = "Mesa Project";
const char const *swrast_renderer_string = "Software Rasterizer";

a119 65

static int
swrast_query_renderer_integer(__DRIscreen *psp, int param,
			       unsigned int *value)
{
   switch (param) {
   case __DRI2_RENDERER_VENDOR_ID:
   case __DRI2_RENDERER_DEVICE_ID:
      /* Return 0xffffffff for both vendor and device id */
      value[0] = 0xffffffff;
      return 0;
   case __DRI2_RENDERER_ACCELERATED:
      value[0] = 0;
      return 0;
   case __DRI2_RENDERER_VIDEO_MEMORY: {
      /* XXX: Do we want to return the full amount of system memory ? */
      const long system_memory_pages = sysconf(_SC_PHYS_PAGES);
      const long system_page_size = sysconf(_SC_PAGE_SIZE);

      if (system_memory_pages <= 0 || system_page_size <= 0)
         return -1;

      const uint64_t system_memory_bytes = (uint64_t) system_memory_pages
         * (uint64_t) system_page_size;

      const unsigned system_memory_megabytes =
         (unsigned) (system_memory_bytes / (1024 * 1024));

      value[0] = system_memory_megabytes;
      return 0;
   }
   case __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE:
      /**
       * XXX: Perhaps we should return 1 ?
       * See issue #7 from the spec, currently UNRESOLVED.
       */
      value[0] = 0;
      return 0;
   default:
      return driQueryRendererIntegerCommon(psp, param, value);
   }
}

static int
swrast_query_renderer_string(__DRIscreen *psp, int param, const char **value)
{
   switch (param) {
   case __DRI2_RENDERER_VENDOR_ID:
      value[0] = swrast_vendor_string;
      return 0;
   case __DRI2_RENDERER_DEVICE_ID:
      value[0] = swrast_renderer_string;
      return 0;
   default:
      return -1;
   }
}

static const __DRI2rendererQueryExtension swrast_query_renderer_extension = {
   .base = { __DRI2_RENDERER_QUERY, 1 },

   .queryInteger        = swrast_query_renderer_integer,
   .queryString         = swrast_query_renderer_string
};

a121 1
    &swrast_query_renderer_extension.base,
d602 1
a602 1
	    return (const GLubyte *) swrast_vendor_string;
d604 1
a604 1
	    return (const GLubyte *) swrast_renderer_string;
d705 3
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@d64 3
d123 65
d190 1
d671 1
a671 1
	    return (const GLubyte *) "Mesa Project";
d673 1
a673 1
	    return (const GLubyte *) "Software Rasterizer";
a773 3

    /* do bounds checking to prevent segfaults and server crashes! */
    mesaCtx->Const.CheckArrayBounds = GL_TRUE;
@


