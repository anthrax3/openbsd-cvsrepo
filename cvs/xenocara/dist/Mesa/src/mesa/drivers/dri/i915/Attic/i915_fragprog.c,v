head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.6
	v10_2_7:1.1.1.6
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	v10_2_3:1.1.1.6
	OPENBSD_5_5:1.7.0.2
	OPENBSD_5_5_BASE:1.7
	v9_2_5:1.1.1.5
	v9_2_3:1.1.1.5
	v9_2_2:1.1.1.5
	v9_2_1:1.1.1.5
	v9_2_0:1.1.1.5
	OPENBSD_5_4:1.6.0.4
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.4
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.48;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.7;
commitid	WPD6rgPryPkvXOr9;

1.7
date	2013.09.05.14.04.13;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.17.13.58.14;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.33;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.09;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.28.12;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.05.13.15.20;	author jsg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.07.09.20.34.47;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/**************************************************************************
 * 
 * Copyright 2003 VMware, Inc.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"

#include "program/prog_instruction.h"
#include "program/prog_parameter.h"
#include "program/program.h"
#include "program/programopt.h"
#include "program/prog_print.h"

#include "tnl/tnl.h"
#include "tnl/t_context.h"

#include "intel_batchbuffer.h"

#include "i915_reg.h"
#include "i915_context.h"
#include "i915_program.h"

static const GLfloat sin_quad_constants[2][4] = {
   {
      2.0,
      -1.0,
      .5,
      .75
   },
   {
      4.0,
      -4.0,
      1.0 / (2.0 * M_PI),
      .2225
   }
};

static const GLfloat sin_constants[4] = { 1.0,
   -1.0 / (3 * 2 * 1),
   1.0 / (5 * 4 * 3 * 2 * 1),
   -1.0 / (7 * 6 * 5 * 4 * 3 * 2 * 1)
};

/* 1, -1/2!, 1/4!, -1/6! */
static const GLfloat cos_constants[4] = { 1.0,
   -1.0 / (2 * 1),
   1.0 / (4 * 3 * 2 * 1),
   -1.0 / (6 * 5 * 4 * 3 * 2 * 1)
};

/**
 * Retrieve a ureg for the given source register.  Will emit
 * constants, apply swizzling and negation as needed.
 */
static GLuint
src_vector(struct i915_fragment_program *p,
           const struct prog_src_register *source,
           const struct gl_fragment_program *program)
{
   GLuint src;

   switch (source->File) {

      /* Registers:
       */
   case PROGRAM_TEMPORARY:
      if (source->Index >= I915_MAX_TEMPORARY) {
         i915_program_error(p, "Exceeded max temporary reg: %d/%d",
			    source->Index, I915_MAX_TEMPORARY);
         return 0;
      }
      src = UREG(REG_TYPE_R, source->Index);
      break;
   case PROGRAM_INPUT:
      switch (source->Index) {
      case VARYING_SLOT_POS:
         src = i915_emit_decl(p, REG_TYPE_T, p->wpos_tex, D0_CHANNEL_ALL);
         break;
      case VARYING_SLOT_COL0:
         src = i915_emit_decl(p, REG_TYPE_T, T_DIFFUSE, D0_CHANNEL_ALL);
         break;
      case VARYING_SLOT_COL1:
         src = i915_emit_decl(p, REG_TYPE_T, T_SPECULAR, D0_CHANNEL_XYZ);
         src = swizzle(src, X, Y, Z, ONE);
         break;
      case VARYING_SLOT_FOGC:
         src = i915_emit_decl(p, REG_TYPE_T, T_FOG_W, D0_CHANNEL_W);
         src = swizzle(src, W, ZERO, ZERO, ONE);
         break;
      case VARYING_SLOT_TEX0:
      case VARYING_SLOT_TEX1:
      case VARYING_SLOT_TEX2:
      case VARYING_SLOT_TEX3:
      case VARYING_SLOT_TEX4:
      case VARYING_SLOT_TEX5:
      case VARYING_SLOT_TEX6:
      case VARYING_SLOT_TEX7:
         src = i915_emit_decl(p, REG_TYPE_T,
                              T_TEX0 + (source->Index - VARYING_SLOT_TEX0),
                              D0_CHANNEL_ALL);
	 break;

      case VARYING_SLOT_VAR0:
      case VARYING_SLOT_VAR0 + 1:
      case VARYING_SLOT_VAR0 + 2:
      case VARYING_SLOT_VAR0 + 3:
      case VARYING_SLOT_VAR0 + 4:
      case VARYING_SLOT_VAR0 + 5:
      case VARYING_SLOT_VAR0 + 6:
      case VARYING_SLOT_VAR0 + 7:
         src = i915_emit_decl(p, REG_TYPE_T,
                              T_TEX0 + (source->Index - VARYING_SLOT_VAR0),
                              D0_CHANNEL_ALL);
         break;

      default:
         i915_program_error(p, "Bad source->Index: %d", source->Index);
         return 0;
      }
      break;

   case PROGRAM_OUTPUT:
      switch (source->Index) {
      case FRAG_RESULT_COLOR:
      case FRAG_RESULT_DATA0:
	 src = UREG(REG_TYPE_OC, 0);
	 break;
      case FRAG_RESULT_DEPTH:
	 src = UREG(REG_TYPE_OD, 0);
	 break;
      default:
	 i915_program_error(p, "Bad source->Index: %d", source->Index);
	 return 0;
      }
      break;

      /* Various paramters and env values.  All emitted to
       * hardware as program constants.
       */
   case PROGRAM_CONSTANT:
   case PROGRAM_STATE_VAR:
   case PROGRAM_UNIFORM:
      src = i915_emit_param4fv(p,
	 &program->Base.Parameters->ParameterValues[source->Index][0].f);
      break;

   default:
      i915_program_error(p, "Bad source->File: %d", source->File);
      return 0;
   }

   src = swizzle(src,
                 GET_SWZ(source->Swizzle, 0),
                 GET_SWZ(source->Swizzle, 1),
                 GET_SWZ(source->Swizzle, 2), GET_SWZ(source->Swizzle, 3));

   if (source->Negate)
      src = negate(src,
                   GET_BIT(source->Negate, 0),
                   GET_BIT(source->Negate, 1),
                   GET_BIT(source->Negate, 2),
                   GET_BIT(source->Negate, 3));

   return src;
}


static GLuint
get_result_vector(struct i915_fragment_program *p,
                  const struct prog_instruction *inst)
{
   switch (inst->DstReg.File) {
   case PROGRAM_OUTPUT:
      switch (inst->DstReg.Index) {
      case FRAG_RESULT_COLOR:
      case FRAG_RESULT_DATA0:
         return UREG(REG_TYPE_OC, 0);
      case FRAG_RESULT_DEPTH:
         p->depth_written = 1;
         return UREG(REG_TYPE_OD, 0);
      default:
         i915_program_error(p, "Bad inst->DstReg.Index: %d",
			    inst->DstReg.Index);
         return 0;
      }
   case PROGRAM_TEMPORARY:
      return UREG(REG_TYPE_R, inst->DstReg.Index);
   default:
      i915_program_error(p, "Bad inst->DstReg.File: %d", inst->DstReg.File);
      return 0;
   }
}

static GLuint
get_result_flags(const struct prog_instruction *inst)
{
   GLuint flags = 0;

   if (inst->SaturateMode == SATURATE_ZERO_ONE)
      flags |= A0_DEST_SATURATE;
   if (inst->DstReg.WriteMask & WRITEMASK_X)
      flags |= A0_DEST_CHANNEL_X;
   if (inst->DstReg.WriteMask & WRITEMASK_Y)
      flags |= A0_DEST_CHANNEL_Y;
   if (inst->DstReg.WriteMask & WRITEMASK_Z)
      flags |= A0_DEST_CHANNEL_Z;
   if (inst->DstReg.WriteMask & WRITEMASK_W)
      flags |= A0_DEST_CHANNEL_W;

   return flags;
}

static GLuint
translate_tex_src_target(struct i915_fragment_program *p, GLubyte bit)
{
   switch (bit) {
   case TEXTURE_1D_INDEX:
      return D0_SAMPLE_TYPE_2D;
   case TEXTURE_2D_INDEX:
      return D0_SAMPLE_TYPE_2D;
   case TEXTURE_RECT_INDEX:
      return D0_SAMPLE_TYPE_2D;
   case TEXTURE_3D_INDEX:
      return D0_SAMPLE_TYPE_VOLUME;
   case TEXTURE_CUBE_INDEX:
      return D0_SAMPLE_TYPE_CUBE;
   default:
      i915_program_error(p, "TexSrcBit: %d", bit);
      return 0;
   }
}

#define EMIT_TEX( OP )						\
do {								\
   GLuint dim = translate_tex_src_target( p, inst->TexSrcTarget );	\
   const struct gl_fragment_program *program = &p->FragProg;	\
   GLuint unit = program->Base.SamplerUnits[inst->TexSrcUnit];	\
   GLuint sampler = i915_emit_decl(p, REG_TYPE_S,		\
				   unit, dim);			\
   GLuint coord = src_vector( p, &inst->SrcReg[0], program);	\
   /* Texel lookup */						\
								\
   i915_emit_texld( p, get_live_regs(p, inst),						\
	       get_result_vector( p, inst ),			\
	       get_result_flags( inst ),			\
	       sampler,						\
	       coord,						\
	       OP);						\
} while (0)

#define EMIT_ARITH( OP, N )						\
do {									\
   i915_emit_arith( p,							\
	       OP,							\
	       get_result_vector( p, inst ), 				\
	       get_result_flags( inst ), 0,			\
	       (N<1)?0:src_vector( p, &inst->SrcReg[0], program),	\
	       (N<2)?0:src_vector( p, &inst->SrcReg[1], program),	\
	       (N<3)?0:src_vector( p, &inst->SrcReg[2], program));	\
} while (0)

#define EMIT_1ARG_ARITH( OP ) EMIT_ARITH( OP, 1 )
#define EMIT_2ARG_ARITH( OP ) EMIT_ARITH( OP, 2 )
#define EMIT_3ARG_ARITH( OP ) EMIT_ARITH( OP, 3 )

/* 
 * TODO: consider moving this into core 
 */
static bool calc_live_regs( struct i915_fragment_program *p )
{
    const struct gl_fragment_program *program = &p->FragProg;
    GLuint regsUsed = ~((1 << I915_MAX_TEMPORARY) - 1);
    uint8_t live_components[I915_MAX_TEMPORARY] = { 0, };
    GLint i;
   
    for (i = program->Base.NumInstructions - 1; i >= 0; i--) {
        struct prog_instruction *inst = &program->Base.Instructions[i];
        int opArgs = _mesa_num_inst_src_regs(inst->Opcode);
        int a;

        /* Register is written to: unmark as live for this and preceeding ops */ 
        if (inst->DstReg.File == PROGRAM_TEMPORARY) {
	    if (inst->DstReg.Index >= I915_MAX_TEMPORARY)
	       return false;

            live_components[inst->DstReg.Index] &= ~inst->DstReg.WriteMask;
            if (live_components[inst->DstReg.Index] == 0)
                regsUsed &= ~(1 << inst->DstReg.Index);
        }

        for (a = 0; a < opArgs; a++) {
            /* Register is read from: mark as live for this and preceeding ops */ 
            if (inst->SrcReg[a].File == PROGRAM_TEMPORARY) {
                unsigned c;

		if (inst->SrcReg[a].Index >= I915_MAX_TEMPORARY)
		   return false;

                regsUsed |= 1 << inst->SrcReg[a].Index;

                for (c = 0; c < 4; c++) {
                    const unsigned field = GET_SWZ(inst->SrcReg[a].Swizzle, c);

                    if (field <= SWIZZLE_W)
                        live_components[inst->SrcReg[a].Index] |= (1U << field);
                }
            }
        }

        p->usedRegs[i] = regsUsed;
    }

    return true;
}

static GLuint get_live_regs( struct i915_fragment_program *p, 
                             const struct prog_instruction *inst )
{
    const struct gl_fragment_program *program = &p->FragProg;
    GLuint nr = inst - program->Base.Instructions;

    return p->usedRegs[nr];
}
 

/* Possible concerns:
 *
 * SIN, COS -- could use another taylor step?
 * LIT      -- results seem a little different to sw mesa
 * LOG      -- different to mesa on negative numbers, but this is conformant.
 * 
 * Parse failures -- Mesa doesn't currently give a good indication
 * internally whether a particular program string parsed or not.  This
 * can lead to confusion -- hopefully we cope with it ok now.
 *
 */
static void
upload_program(struct i915_fragment_program *p)
{
   const struct gl_fragment_program *program = &p->FragProg;
   const struct prog_instruction *inst = program->Base.Instructions;

   if (INTEL_DEBUG & DEBUG_WM)
      _mesa_print_program(&program->Base);

   /* Is this a parse-failed program?  Ensure a valid program is
    * loaded, as the flagging of an error isn't sufficient to stop
    * this being uploaded to hardware.
    */
   if (inst[0].Opcode == OPCODE_END) {
      GLuint tmp = i915_get_utemp(p);
      i915_emit_arith(p,
                      A0_MOV,
                      UREG(REG_TYPE_OC, 0),
                      A0_DEST_CHANNEL_ALL, 0,
                      swizzle(tmp, ONE, ZERO, ONE, ONE), 0, 0);
      return;
   }

   if (program->Base.NumInstructions > I915_MAX_INSN) {
      i915_program_error(p, "Exceeded max instructions (%d out of %d)",
			 program->Base.NumInstructions, I915_MAX_INSN);
      return;
   }

   /* Not always needed:
    */
   if (!calc_live_regs(p)) {
      i915_program_error(p, "Could not allocate registers");
      return;
   }

   while (1) {
      GLuint src0, src1, src2, flags;
      GLuint tmp = 0, dst, consts0 = 0, consts1 = 0;

      switch (inst->Opcode) {
      case OPCODE_ABS:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         i915_emit_arith(p,
                         A0_MAX,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         src0, negate(src0, 1, 1, 1, 1), 0);
         break;

      case OPCODE_ADD:
         EMIT_2ARG_ARITH(A0_ADD);
         break;

      case OPCODE_CMP:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);
         src2 = src_vector(p, &inst->SrcReg[2], program);
         i915_emit_arith(p, A0_CMP, get_result_vector(p, inst), get_result_flags(inst), 0, src0, src2, src1);   /* NOTE: order of src2, src1 */
         break;

      case OPCODE_COS:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         tmp = i915_get_utemp(p);
	 consts0 = i915_emit_const4fv(p, sin_quad_constants[0]);
	 consts1 = i915_emit_const4fv(p, sin_quad_constants[1]);

	 /* Reduce range from repeating about [-pi,pi] to [-1,1] */
         i915_emit_arith(p,
                         A0_MAD,
                         tmp, A0_DEST_CHANNEL_X, 0,
                         src0,
			 swizzle(consts1, Z, ZERO, ZERO, ZERO), /* 1/(2pi) */
			 swizzle(consts0, W, ZERO, ZERO, ZERO)); /* .75 */

         i915_emit_arith(p, A0_FRC, tmp, A0_DEST_CHANNEL_X, 0, tmp, 0, 0);

	 i915_emit_arith(p,
			 A0_MAD,
			 tmp, A0_DEST_CHANNEL_X, 0,
			 tmp,
			 swizzle(consts0, X, ZERO, ZERO, ZERO), /* 2 */
			 swizzle(consts0, Y, ZERO, ZERO, ZERO)); /* -1 */

	 /* Compute COS with the same calculation used for SIN, but a
	  * different source range has been mapped to [-1,1] this time.
	  */

	 /* tmp.y = abs(tmp.x); {x, abs(x), 0, 0} */
	 i915_emit_arith(p,
                         A0_MAX,
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 negate(swizzle(tmp, ZERO, X, ZERO, ZERO), 0, 1, 0, 0),
			 0);

	 /* tmp.y = tmp.y * tmp.x; {x, x * abs(x), 0, 0} */
	 i915_emit_arith(p,
			 A0_MUL,
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 tmp,
			 0);

	 /* tmp.x = tmp.xy DP sin_quad_constants[2].xy */
         i915_emit_arith(p,
                         A0_DP3,
                         tmp, A0_DEST_CHANNEL_X, 0,
			 tmp,
                         swizzle(consts1, X, Y, ZERO, ZERO),
			 0);

	 /* tmp.x now contains a first approximation (y).  Now, weight it
	  * against tmp.y**2 to get closer.
	  */
	 i915_emit_arith(p,
                         A0_MAX,
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 negate(swizzle(tmp, ZERO, X, ZERO, ZERO), 0, 1, 0, 0),
			 0);

	 /* tmp.y = tmp.x * tmp.y - tmp.x; {y, y * abs(y) - y, 0, 0} */
	 i915_emit_arith(p,
			 A0_MAD,
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 swizzle(tmp, ZERO, Y, ZERO, ZERO),
			 negate(swizzle(tmp, ZERO, X, ZERO, ZERO), 0, 1, 0, 0));

	 /* result = .2225 * tmp.y + tmp.x =.2225(y * abs(y) - y) + y= */
	 i915_emit_arith(p,
			 A0_MAD,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
			 swizzle(consts1, W, W, W, W),
			 swizzle(tmp, Y, Y, Y, Y),
			 swizzle(tmp, X, X, X, X));
         break;

      case OPCODE_DP2:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);
	 i915_emit_arith(p,
			 A0_DP3,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
			 swizzle(src0, X, Y, ZERO, ZERO),
			 swizzle(src1, X, Y, ZERO, ZERO),
			 0);
         break;

      case OPCODE_DP3:
         EMIT_2ARG_ARITH(A0_DP3);
         break;

      case OPCODE_DP4:
         EMIT_2ARG_ARITH(A0_DP4);
         break;

      case OPCODE_DPH:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);

         i915_emit_arith(p,
                         A0_DP4,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         swizzle(src0, X, Y, Z, ONE), src1, 0);
         break;

      case OPCODE_DST:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);

         /* result[0] = 1    * 1;
          * result[1] = a[1] * b[1];
          * result[2] = a[2] * 1;
          * result[3] = 1    * b[3];
          */
         i915_emit_arith(p,
                         A0_MUL,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         swizzle(src0, ONE, Y, Z, ONE),
                         swizzle(src1, ONE, Y, ONE, W), 0);
         break;

      case OPCODE_EX2:
         src0 = src_vector(p, &inst->SrcReg[0], program);

         i915_emit_arith(p,
                         A0_EXP,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         swizzle(src0, X, X, X, X), 0, 0);
         break;

      case OPCODE_FLR:
         EMIT_1ARG_ARITH(A0_FLR);
         break;

      case OPCODE_TRUNC:
	 EMIT_1ARG_ARITH(A0_TRC);
	 break;

      case OPCODE_FRC:
         EMIT_1ARG_ARITH(A0_FRC);
         break;

      case OPCODE_KIL:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         tmp = i915_get_utemp(p);

         i915_emit_texld(p, get_live_regs(p, inst),
                         tmp, A0_DEST_CHANNEL_ALL,   /* use a dummy dest reg */
                         0, src0, T0_TEXKILL);
         break;

      case OPCODE_KIL_NV:
	 if (inst->DstReg.CondMask == COND_TR) {
	    tmp = i915_get_utemp(p);

	    /* The KIL instruction discards the fragment if any component of
	     * the source is < 0.  Emit an immediate operand of {-1}.xywz.
	     */
	    i915_emit_texld(p, get_live_regs(p, inst),
			    tmp, A0_DEST_CHANNEL_ALL,
			    0, /* use a dummy dest reg */
			    negate(swizzle(tmp, ONE, ONE, ONE, ONE),
				   1, 1, 1, 1),
			    T0_TEXKILL);
	 } else {
	    p->error = 1;
	    i915_program_error(p, "Unsupported KIL_NV condition code: %d",
			       inst->DstReg.CondMask);
	 }
	 break;

      case OPCODE_LG2:
         src0 = src_vector(p, &inst->SrcReg[0], program);

         i915_emit_arith(p,
                         A0_LOG,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         swizzle(src0, X, X, X, X), 0, 0);
         break;

      case OPCODE_LIT:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         tmp = i915_get_utemp(p);

         /* tmp = max( a.xyzw, a.00zw )
          * XXX: Clamp tmp.w to -128..128
          * tmp.y = log(tmp.y)
          * tmp.y = tmp.w * tmp.y
          * tmp.y = exp(tmp.y)
          * result = cmp (a.11-x1, a.1x01, a.1xy1 )
          */
         i915_emit_arith(p, A0_MAX, tmp, A0_DEST_CHANNEL_ALL, 0,
                         src0, swizzle(src0, ZERO, ZERO, Z, W), 0);

         i915_emit_arith(p, A0_LOG, tmp, A0_DEST_CHANNEL_Y, 0,
                         swizzle(tmp, Y, Y, Y, Y), 0, 0);

         i915_emit_arith(p, A0_MUL, tmp, A0_DEST_CHANNEL_Y, 0,
                         swizzle(tmp, ZERO, Y, ZERO, ZERO),
                         swizzle(tmp, ZERO, W, ZERO, ZERO), 0);

         i915_emit_arith(p, A0_EXP, tmp, A0_DEST_CHANNEL_Y, 0,
                         swizzle(tmp, Y, Y, Y, Y), 0, 0);

         i915_emit_arith(p, A0_CMP,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         negate(swizzle(tmp, ONE, ONE, X, ONE), 0, 0, 1, 0),
                         swizzle(tmp, ONE, X, ZERO, ONE),
                         swizzle(tmp, ONE, X, Y, ONE));

         break;

      case OPCODE_LRP:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);
         src2 = src_vector(p, &inst->SrcReg[2], program);
         flags = get_result_flags(inst);
         tmp = i915_get_utemp(p);

         /* b*a + c*(1-a)
          *
          * b*a + c - ca 
          *
          * tmp = b*a + c, 
          * result = (-c)*a + tmp 
          */
         i915_emit_arith(p, A0_MAD, tmp,
                         flags & A0_DEST_CHANNEL_ALL, 0, src1, src0, src2);

         i915_emit_arith(p, A0_MAD,
                         get_result_vector(p, inst),
                         flags, 0, negate(src2, 1, 1, 1, 1), src0, tmp);
         break;

      case OPCODE_MAD:
         EMIT_3ARG_ARITH(A0_MAD);
         break;

      case OPCODE_MAX:
         EMIT_2ARG_ARITH(A0_MAX);
         break;

      case OPCODE_MIN:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);
         tmp = i915_get_utemp(p);
         flags = get_result_flags(inst);

         i915_emit_arith(p,
                         A0_MAX,
                         tmp, flags & A0_DEST_CHANNEL_ALL, 0,
                         negate(src0, 1, 1, 1, 1),
                         negate(src1, 1, 1, 1, 1), 0);

         i915_emit_arith(p,
                         A0_MOV,
                         get_result_vector(p, inst),
                         flags, 0, negate(tmp, 1, 1, 1, 1), 0, 0);
         break;

      case OPCODE_MOV:
         EMIT_1ARG_ARITH(A0_MOV);
         break;

      case OPCODE_MUL:
         EMIT_2ARG_ARITH(A0_MUL);
         break;

      case OPCODE_POW:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);
         tmp = i915_get_utemp(p);
         flags = get_result_flags(inst);

         /* XXX: masking on intermediate values, here and elsewhere.
          */
         i915_emit_arith(p,
                         A0_LOG,
                         tmp, A0_DEST_CHANNEL_X, 0,
                         swizzle(src0, X, X, X, X), 0, 0);

         i915_emit_arith(p, A0_MUL, tmp, A0_DEST_CHANNEL_X, 0, tmp, src1, 0);


         i915_emit_arith(p,
                         A0_EXP,
                         get_result_vector(p, inst),
                         flags, 0, swizzle(tmp, X, X, X, X), 0, 0);

         break;

      case OPCODE_RCP:
         src0 = src_vector(p, &inst->SrcReg[0], program);

         i915_emit_arith(p,
                         A0_RCP,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         swizzle(src0, X, X, X, X), 0, 0);
         break;

      case OPCODE_RSQ:

         src0 = src_vector(p, &inst->SrcReg[0], program);

         i915_emit_arith(p,
                         A0_RSQ,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         swizzle(src0, X, X, X, X), 0, 0);
         break;

      case OPCODE_SCS:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         tmp = i915_get_utemp(p);

         /* 
          * t0.xy = MUL x.xx11, x.x1111  ; x^2, x, 1, 1
          * t0 = MUL t0.xyxy t0.xx11 ; x^4, x^3, x^2, x
          * t1 = MUL t0.xyyw t0.yz11    ; x^7 x^5 x^3 x
          * scs.x = DP4 t1, sin_constants
          * t1 = MUL t0.xxz1 t0.z111    ; x^6 x^4 x^2 1
          * scs.y = DP4 t1, cos_constants
          */
         i915_emit_arith(p,
                         A0_MUL,
                         tmp, A0_DEST_CHANNEL_XY, 0,
                         swizzle(src0, X, X, ONE, ONE),
                         swizzle(src0, X, ONE, ONE, ONE), 0);

         i915_emit_arith(p,
                         A0_MUL,
                         tmp, A0_DEST_CHANNEL_ALL, 0,
                         swizzle(tmp, X, Y, X, Y),
                         swizzle(tmp, X, X, ONE, ONE), 0);

         if (inst->DstReg.WriteMask & WRITEMASK_Y) {
            GLuint tmp1;

            if (inst->DstReg.WriteMask & WRITEMASK_X)
               tmp1 = i915_get_utemp(p);
            else
               tmp1 = tmp;

            i915_emit_arith(p,
                            A0_MUL,
                            tmp1, A0_DEST_CHANNEL_ALL, 0,
                            swizzle(tmp, X, Y, Y, W),
                            swizzle(tmp, X, Z, ONE, ONE), 0);

            i915_emit_arith(p,
                            A0_DP4,
                            get_result_vector(p, inst),
                            A0_DEST_CHANNEL_Y, 0,
                            swizzle(tmp1, W, Z, Y, X),
                            i915_emit_const4fv(p, sin_constants), 0);
         }

         if (inst->DstReg.WriteMask & WRITEMASK_X) {
            i915_emit_arith(p,
                            A0_MUL,
                            tmp, A0_DEST_CHANNEL_XYZ, 0,
                            swizzle(tmp, X, X, Z, ONE),
                            swizzle(tmp, Z, ONE, ONE, ONE), 0);

            i915_emit_arith(p,
                            A0_DP4,
                            get_result_vector(p, inst),
                            A0_DEST_CHANNEL_X, 0,
                            swizzle(tmp, ONE, Z, Y, X),
                            i915_emit_const4fv(p, cos_constants), 0);
         }
         break;

      case OPCODE_SEQ:
	 tmp = i915_get_utemp(p);
	 flags = get_result_flags(inst);
	 dst = get_result_vector(p, inst);

         /* If both operands are uniforms or constants, we get 5 instructions
          * like:
          *
          *     U[1] = MOV CONST[1]
          *     U[0].xyz = SGE CONST[0].xxxx, U[1]
          *     U[1] = MOV CONST[1].-x-y-z-w
          *     R[0].xyz = SGE CONST[0].-x-x-x-x, U[1]
          *     R[0].xyz = MUL R[0], U[0]
          *
          * This code is stupid.  Instead of having the individual calls to
          * i915_emit_arith generate the moves to utemps, do it in the caller.
          * This results in code like:
          *
          *     U[1] = MOV CONST[1]
          *     U[0].xyz = SGE CONST[0].xxxx, U[1]
          *     R[0].xyz = SGE CONST[0].-x-x-x-x, U[1].-x-y-z-w
          *     R[0].xyz = MUL R[0], U[0]
          */
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);

         if (GET_UREG_TYPE(src0) == REG_TYPE_CONST
             && GET_UREG_TYPE(src1) == REG_TYPE_CONST) {
            unsigned tmp = i915_get_utemp(p);

            i915_emit_arith(p, A0_MOV, tmp, A0_DEST_CHANNEL_ALL, 0,
                            src1, 0, 0);

            src1 = tmp;
         }

	 /* tmp = src1 >= src2 */
	 i915_emit_arith(p,
			 A0_SGE,
			 tmp,
			 flags, 0,
			 src0,
			 src1,
			 0);
	 /* dst = src1 <= src2 */
	 i915_emit_arith(p,
			 A0_SGE,
			 dst,
			 flags, 0,
			 negate(src0, 1, 1, 1, 1),
			 negate(src1, 1, 1, 1, 1),
			 0);
	 /* dst = tmp && dst */
	 i915_emit_arith(p,
			 A0_MUL,
			 dst,
			 flags, 0,
			 dst,
			 tmp,
			 0);
	 break;

      case OPCODE_SIN:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         tmp = i915_get_utemp(p);
	 consts0 = i915_emit_const4fv(p, sin_quad_constants[0]);
	 consts1 = i915_emit_const4fv(p, sin_quad_constants[1]);

	 /* Reduce range from repeating about [-pi,pi] to [-1,1] */
         i915_emit_arith(p,
                         A0_MAD,
                         tmp, A0_DEST_CHANNEL_X, 0,
                         src0,
			 swizzle(consts1, Z, ZERO, ZERO, ZERO), /* 1/(2pi) */
			 swizzle(consts0, Z, ZERO, ZERO, ZERO)); /* .5 */

         i915_emit_arith(p, A0_FRC, tmp, A0_DEST_CHANNEL_X, 0, tmp, 0, 0);

	 i915_emit_arith(p,
			 A0_MAD,
			 tmp, A0_DEST_CHANNEL_X, 0,
			 tmp,
			 swizzle(consts0, X, ZERO, ZERO, ZERO), /* 2 */
			 swizzle(consts0, Y, ZERO, ZERO, ZERO)); /* -1 */

	 /* Compute sin using a quadratic and quartic.  It gives continuity
	  * that repeating the Taylor series lacks every 2*pi, and has
	  * reduced error.
	  *
	  * The idea was described at:
	  * http://www.devmaster.net/forums/showthread.php?t=5784
	  */

	 /* tmp.y = abs(tmp.x); {x, abs(x), 0, 0} */
	 i915_emit_arith(p,
                         A0_MAX,
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 negate(swizzle(tmp, ZERO, X, ZERO, ZERO), 0, 1, 0, 0),
			 0);

	 /* tmp.y = tmp.y * tmp.x; {x, x * abs(x), 0, 0} */
	 i915_emit_arith(p,
			 A0_MUL,
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 tmp,
			 0);

	 /* tmp.x = tmp.xy DP sin_quad_constants[2].xy */
         i915_emit_arith(p,
                         A0_DP3,
                         tmp, A0_DEST_CHANNEL_X, 0,
			 tmp,
                         swizzle(consts1, X, Y, ZERO, ZERO),
			 0);

	 /* tmp.x now contains a first approximation (y).  Now, weight it
	  * against tmp.y**2 to get closer.
	  */
	 i915_emit_arith(p,
                         A0_MAX,
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 negate(swizzle(tmp, ZERO, X, ZERO, ZERO), 0, 1, 0, 0),
			 0);

	 /* tmp.y = tmp.x * tmp.y - tmp.x; {y, y * abs(y) - y, 0, 0} */
	 i915_emit_arith(p,
			 A0_MAD,
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 swizzle(tmp, ZERO, Y, ZERO, ZERO),
			 negate(swizzle(tmp, ZERO, X, ZERO, ZERO), 0, 1, 0, 0));

	 /* result = .2225 * tmp.y + tmp.x =.2225(y * abs(y) - y) + y= */
	 i915_emit_arith(p,
			 A0_MAD,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
			 swizzle(consts1, W, W, W, W),
			 swizzle(tmp, Y, Y, Y, Y),
			 swizzle(tmp, X, X, X, X));

         break;

      case OPCODE_SGE:
	 EMIT_2ARG_ARITH(A0_SGE);
	 break;

      case OPCODE_SGT:
	 i915_emit_arith(p,
			 A0_SLT,
			 get_result_vector( p, inst ),
			 get_result_flags( inst ), 0,
			 negate(src_vector( p, &inst->SrcReg[0], program),
				1, 1, 1, 1),
			 negate(src_vector( p, &inst->SrcReg[1], program),
				1, 1, 1, 1),
			 0);
         break;

      case OPCODE_SLE:
	 i915_emit_arith(p,
			 A0_SGE,
			 get_result_vector( p, inst ),
			 get_result_flags( inst ), 0,
			 negate(src_vector( p, &inst->SrcReg[0], program),
				1, 1, 1, 1),
			 negate(src_vector( p, &inst->SrcReg[1], program),
				1, 1, 1, 1),
			 0);
         break;

      case OPCODE_SLT:
         EMIT_2ARG_ARITH(A0_SLT);
         break;

      case OPCODE_SNE:
	 tmp = i915_get_utemp(p);
	 flags = get_result_flags(inst);
	 dst = get_result_vector(p, inst);

         /* If both operands are uniforms or constants, we get 5 instructions
          * like:
          *
          *     U[1] = MOV CONST[1]
          *     U[0].xyz = SLT CONST[0].xxxx, U[1]
          *     U[1] = MOV CONST[1].-x-y-z-w
          *     R[0].xyz = SLT CONST[0].-x-x-x-x, U[1]
          *     R[0].xyz = MUL R[0], U[0]
          *
          * This code is stupid.  Instead of having the individual calls to
          * i915_emit_arith generate the moves to utemps, do it in the caller.
          * This results in code like:
          *
          *     U[1] = MOV CONST[1]
          *     U[0].xyz = SLT CONST[0].xxxx, U[1]
          *     R[0].xyz = SLT CONST[0].-x-x-x-x, U[1].-x-y-z-w
          *     R[0].xyz = MUL R[0], U[0]
          */
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);

         if (GET_UREG_TYPE(src0) == REG_TYPE_CONST
             && GET_UREG_TYPE(src1) == REG_TYPE_CONST) {
            unsigned tmp = i915_get_utemp(p);

            i915_emit_arith(p, A0_MOV, tmp, A0_DEST_CHANNEL_ALL, 0,
                            src1, 0, 0);

            src1 = tmp;
         }

	 /* tmp = src1 < src2 */
	 i915_emit_arith(p,
			 A0_SLT,
			 tmp,
			 flags, 0,
			 src0,
			 src1,
			 0);
	 /* dst = src1 > src2 */
	 i915_emit_arith(p,
			 A0_SLT,
			 dst,
			 flags, 0,
			 negate(src0, 1, 1, 1, 1),
			 negate(src1, 1, 1, 1, 1),
			 0);
	 /* dst = tmp || dst */
	 i915_emit_arith(p,
			 A0_ADD,
			 dst,
			 flags | A0_DEST_SATURATE, 0,
			 dst,
			 tmp,
			 0);
         break;

      case OPCODE_SSG:
	 dst = get_result_vector(p, inst);
	 flags = get_result_flags(inst);
         src0 = src_vector(p, &inst->SrcReg[0], program);
	 tmp = i915_get_utemp(p);

	 /* tmp = (src < 0.0) */
	 i915_emit_arith(p,
			 A0_SLT,
			 tmp,
			 flags, 0,
			 src0,
			 swizzle(src0, ZERO, ZERO, ZERO, ZERO),
			 0);

	 /* dst = (0.0 < src) */
	 i915_emit_arith(p,
			 A0_SLT,
			 dst,
			 flags, 0,
			 swizzle(src0, ZERO, ZERO, ZERO, ZERO),
			 src0,
			 0);

	 /* dst = (src > 0.0) - (src < 0.0) */
	 i915_emit_arith(p,
			 A0_ADD,
			 dst,
			 flags, 0,
			 dst,
			 negate(tmp, 1, 1, 1, 1),
			 0);

         break;

      case OPCODE_SUB:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);

         i915_emit_arith(p,
                         A0_ADD,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         src0, negate(src1, 1, 1, 1, 1), 0);
         break;

      case OPCODE_SWZ:
         EMIT_1ARG_ARITH(A0_MOV);       /* extended swizzle handled natively */
         break;

      case OPCODE_TEX:
         EMIT_TEX(T0_TEXLD);
         break;

      case OPCODE_TXB:
         EMIT_TEX(T0_TEXLDB);
         break;

      case OPCODE_TXP:
         EMIT_TEX(T0_TEXLDP);
         break;

      case OPCODE_XPD:
         /* Cross product:
          *      result.x = src0.y * src1.z - src0.z * src1.y;
          *      result.y = src0.z * src1.x - src0.x * src1.z;
          *      result.z = src0.x * src1.y - src0.y * src1.x;
          *      result.w = undef;
          */
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);
         tmp = i915_get_utemp(p);

         i915_emit_arith(p,
                         A0_MUL,
                         tmp, A0_DEST_CHANNEL_ALL, 0,
                         swizzle(src0, Z, X, Y, ONE),
                         swizzle(src1, Y, Z, X, ONE), 0);

         i915_emit_arith(p,
                         A0_MAD,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         swizzle(src0, Y, Z, X, ONE),
                         swizzle(src1, Z, X, Y, ONE),
                         negate(tmp, 1, 1, 1, 0));
         break;

      case OPCODE_END:
         return;

      case OPCODE_BGNLOOP:
      case OPCODE_BGNSUB:
      case OPCODE_BRK:
      case OPCODE_CAL:
      case OPCODE_CONT:
      case OPCODE_DDX:
      case OPCODE_DDY:
      case OPCODE_ELSE:
      case OPCODE_ENDIF:
      case OPCODE_ENDLOOP:
      case OPCODE_ENDSUB:
      case OPCODE_IF:
      case OPCODE_RET:
	 p->error = 1;
	 i915_program_error(p, "Unsupported opcode: %s",
			    _mesa_opcode_string(inst->Opcode));
	 return;

      case OPCODE_EXP:
      case OPCODE_LOG:
	 /* These opcodes are claimed as GLSL, NV_vp, and ARB_vp in
	  * prog_instruction.h, but apparently GLSL doesn't ever emit them.
	  * Instead, it translates to EX2 or LG2.
	  */
      case OPCODE_TXD:
      case OPCODE_TXL:
	 /* These opcodes are claimed by GLSL in prog_instruction.h, but
	  * only NV_vp/fp appears to emit them.
	  */
      default:
         i915_program_error(p, "bad opcode: %s",
			    _mesa_opcode_string(inst->Opcode));
         return;
      }

      inst++;
      i915_release_utemps(p);
   }
}

/* Rather than trying to intercept and jiggle depth writes during
 * emit, just move the value into its correct position at the end of
 * the program:
 */
static void
fixup_depth_write(struct i915_fragment_program *p)
{
   if (p->depth_written) {
      GLuint depth = UREG(REG_TYPE_OD, 0);

      i915_emit_arith(p,
                      A0_MOV,
                      depth, A0_DEST_CHANNEL_W, 0,
                      swizzle(depth, X, Y, Z, Z), 0, 0);
   }
}


static void
check_wpos(struct i915_fragment_program *p)
{
   GLbitfield64 inputs = p->FragProg.Base.InputsRead;
   GLint i;

   p->wpos_tex = -1;

   for (i = 0; i < p->ctx->Const.MaxTextureCoordUnits; i++) {
      if (inputs & (VARYING_BIT_TEX(i) | VARYING_BIT_VAR(i)))
         continue;
      else if (inputs & VARYING_BIT_POS) {
         p->wpos_tex = i;
         inputs &= ~VARYING_BIT_POS;
      }
   }

   if (inputs & VARYING_BIT_POS) {
      i915_program_error(p, "No free texcoord for wpos value");
   }
}


static void
translate_program(struct i915_fragment_program *p)
{
   struct i915_context *i915 = I915_CONTEXT(p->ctx);

   if (INTEL_DEBUG & DEBUG_WM) {
      printf("fp:\n");
      _mesa_print_program(&p->FragProg.Base);
      printf("\n");
   }

   i915_init_program(i915, p);
   check_wpos(p);
   upload_program(p);
   fixup_depth_write(p);
   i915_fini_program(p);

   p->translated = 1;
}


static void
track_params(struct i915_fragment_program *p)
{
   GLint i;

   if (p->nr_params)
      _mesa_load_state_parameters(p->ctx, p->FragProg.Base.Parameters);

   for (i = 0; i < p->nr_params; i++) {
      GLint reg = p->param[i].reg;
      COPY_4V(p->constant[reg], p->param[i].values);
   }

   p->params_uptodate = 1;
   p->on_hardware = 0;          /* overkill */
}


static void
i915BindProgram(struct gl_context * ctx, GLenum target, struct gl_program *prog)
{
   if (target == GL_FRAGMENT_PROGRAM_ARB) {
      struct i915_context *i915 = I915_CONTEXT(ctx);
      struct i915_fragment_program *p = (struct i915_fragment_program *) prog;

      if (i915->current_program == p)
         return;

      if (i915->current_program) {
         i915->current_program->on_hardware = 0;
         i915->current_program->params_uptodate = 0;
      }

      i915->current_program = p;

      assert(p->on_hardware == 0);
      assert(p->params_uptodate == 0);

   }
}

static struct gl_program *
i915NewProgram(struct gl_context * ctx, GLenum target, GLuint id)
{
   switch (target) {
   case GL_VERTEX_PROGRAM_ARB:
      return _mesa_init_vertex_program(ctx, CALLOC_STRUCT(gl_vertex_program),
                                       target, id);

   case GL_FRAGMENT_PROGRAM_ARB:{
         struct i915_fragment_program *prog =
            CALLOC_STRUCT(i915_fragment_program);
         if (prog) {
            i915_init_program(I915_CONTEXT(ctx), prog);

            return _mesa_init_fragment_program(ctx, &prog->FragProg,
                                               target, id);
         }
         else
            return NULL;
      }

   default:
      /* Just fallback:
       */
      return _mesa_new_program(ctx, target, id);
   }
}

static void
i915DeleteProgram(struct gl_context * ctx, struct gl_program *prog)
{
   if (prog->Target == GL_FRAGMENT_PROGRAM_ARB) {
      struct i915_context *i915 = I915_CONTEXT(ctx);
      struct i915_fragment_program *p = (struct i915_fragment_program *) prog;

      if (i915->current_program == p)
         i915->current_program = 0;
   }

   _mesa_delete_program(ctx, prog);
}


static GLboolean
i915IsProgramNative(struct gl_context * ctx, GLenum target, struct gl_program *prog)
{
   if (target == GL_FRAGMENT_PROGRAM_ARB) {
      struct i915_fragment_program *p = (struct i915_fragment_program *) prog;

      if (!p->translated)
         translate_program(p);

      return !p->error;
   }
   else
      return true;
}

static GLboolean
i915ProgramStringNotify(struct gl_context * ctx,
                        GLenum target, struct gl_program *prog)
{
   if (target == GL_FRAGMENT_PROGRAM_ARB) {
      struct i915_fragment_program *p = (struct i915_fragment_program *) prog;
      p->translated = 0;
   }

   (void) _tnl_program_string(ctx, target, prog);

   /* XXX check if program is legal, within limits */
   return true;
}

static void
i915SamplerUniformChange(struct gl_context *ctx,
                         GLenum target, struct gl_program *prog)
{
   i915ProgramStringNotify(ctx, target, prog);
}

void
i915_update_program(struct gl_context *ctx)
{
   struct intel_context *intel = intel_context(ctx);
   struct i915_context *i915 = i915_context(&intel->ctx);
   struct i915_fragment_program *fp =
      (struct i915_fragment_program *) ctx->FragmentProgram._Current;

   if (i915->current_program != fp) {
      if (i915->current_program) {
         i915->current_program->on_hardware = 0;
         i915->current_program->params_uptodate = 0;
      }

      i915->current_program = fp;
   }

   if (!fp->translated)
      translate_program(fp);

   FALLBACK(&i915->intel, I915_FALLBACK_PROGRAM, fp->error);
}

void
i915ValidateFragmentProgram(struct i915_context *i915)
{
   struct gl_context *ctx = &i915->intel.ctx;
   struct intel_context *intel = intel_context(ctx);
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct vertex_buffer *VB = &tnl->vb;

   struct i915_fragment_program *p =
      (struct i915_fragment_program *) ctx->FragmentProgram._Current;

   const GLbitfield64 inputsRead = p->FragProg.Base.InputsRead;
   GLuint s4 = i915->state.Ctx[I915_CTXREG_LIS4] & ~S4_VFMT_MASK;
   GLuint s2 = S2_TEXCOORD_NONE;
   int i, offset = 0;

   /* Important:
    */
   VB->AttribPtr[VERT_ATTRIB_POS] = VB->NdcPtr;

   if (!p->translated)
      translate_program(p);

   intel->vertex_attr_count = 0;
   intel->wpos_offset = 0;
   intel->coloroffset = 0;
   intel->specoffset = 0;

   if (inputsRead & VARYING_BITS_TEX_ANY || p->wpos_tex != -1) {
      EMIT_ATTR(_TNL_ATTRIB_POS, EMIT_4F_VIEWPORT, S4_VFMT_XYZW, 16);
   }
   else {
      EMIT_ATTR(_TNL_ATTRIB_POS, EMIT_3F_VIEWPORT, S4_VFMT_XYZ, 12);
   }

   /* Handle gl_PointSize builtin var here */
   if (ctx->Point._Attenuated || ctx->VertexProgram.PointSizeEnabled)
      EMIT_ATTR(_TNL_ATTRIB_POINTSIZE, EMIT_1F, S4_VFMT_POINT_WIDTH, 4);

   if (inputsRead & VARYING_BIT_COL0) {
      intel->coloroffset = offset / 4;
      EMIT_ATTR(_TNL_ATTRIB_COLOR0, EMIT_4UB_4F_BGRA, S4_VFMT_COLOR, 4);
   }

   if (inputsRead & VARYING_BIT_COL1) {
       intel->specoffset = offset / 4;
       EMIT_ATTR(_TNL_ATTRIB_COLOR1, EMIT_4UB_4F_BGRA, S4_VFMT_SPEC_FOG, 4);
   }

   if ((inputsRead & VARYING_BIT_FOGC)) {
      EMIT_ATTR(_TNL_ATTRIB_FOG, EMIT_1F, S4_VFMT_FOG_PARAM, 4);
   }

   for (i = 0; i < p->ctx->Const.MaxTextureCoordUnits; i++) {
      if (inputsRead & VARYING_BIT_TEX(i)) {
         int sz = VB->AttribPtr[_TNL_ATTRIB_TEX0 + i]->size;

         s2 &= ~S2_TEXCOORD_FMT(i, S2_TEXCOORD_FMT0_MASK);
         s2 |= S2_TEXCOORD_FMT(i, SZ_TO_HW(sz));

         EMIT_ATTR(_TNL_ATTRIB_TEX0 + i, EMIT_SZ(sz), 0, sz * 4);
      }
      else if (inputsRead & VARYING_BIT_VAR(i)) {
         int sz = VB->AttribPtr[_TNL_ATTRIB_GENERIC0 + i]->size;

         s2 &= ~S2_TEXCOORD_FMT(i, S2_TEXCOORD_FMT0_MASK);
         s2 |= S2_TEXCOORD_FMT(i, SZ_TO_HW(sz));

         EMIT_ATTR(_TNL_ATTRIB_GENERIC0 + i, EMIT_SZ(sz), 0, sz * 4);
      }
      else if (i == p->wpos_tex) {
	 int wpos_size = 4 * sizeof(float);
         /* If WPOS is required, duplicate the XYZ position data in an
          * unused texture coordinate:
          */
         s2 &= ~S2_TEXCOORD_FMT(i, S2_TEXCOORD_FMT0_MASK);
         s2 |= S2_TEXCOORD_FMT(i, SZ_TO_HW(wpos_size));

         intel->wpos_offset = offset;
         EMIT_PAD(wpos_size);
      }
   }

   if (s2 != i915->state.Ctx[I915_CTXREG_LIS2] ||
       s4 != i915->state.Ctx[I915_CTXREG_LIS4]) {
      int k;

      I915_STATECHANGE(i915, I915_UPLOAD_CTX);

      /* Must do this *after* statechange, so as not to affect
       * buffered vertices reliant on the old state:
       */
      intel->vertex_size = _tnl_install_attrs(&intel->ctx,
                                              intel->vertex_attrs,
                                              intel->vertex_attr_count,
                                              intel->ViewportMatrix.m, 0);

      assert(intel->prim.current_offset == intel->prim.start_offset);
      intel->prim.start_offset = (intel->prim.current_offset + intel->vertex_size-1) / intel->vertex_size * intel->vertex_size;
      intel->prim.current_offset = intel->prim.start_offset;

      intel->vertex_size >>= 2;

      i915->state.Ctx[I915_CTXREG_LIS2] = s2;
      i915->state.Ctx[I915_CTXREG_LIS4] = s4;

      k = intel->vtbl.check_vertex_size(intel, intel->vertex_size);
      assert(k);
   }

   if (!p->params_uptodate)
      track_params(p);

   if (!p->on_hardware)
      i915_upload_program(i915, p);

   if (INTEL_DEBUG & DEBUG_WM) {
      printf("i915:\n");
      i915_disassemble_program(i915->state.Program, i915->state.ProgramSize);
   }
}

void
i915InitFragProgFuncs(struct dd_function_table *functions)
{
   functions->BindProgram = i915BindProgram;
   functions->NewProgram = i915NewProgram;
   functions->DeleteProgram = i915DeleteProgram;
   functions->IsProgramNative = i915IsProgramNative;
   functions->ProgramStringNotify = i915ProgramStringNotify;
   functions->SamplerUniformChange = i915SamplerUniformChange;
}
@


1.8
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.7
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
d21 1
a21 1
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
d149 1
a163 11
   case PROGRAM_LOCAL_PARAM:
      src = i915_emit_param4fv(p, program->Base.LocalParams[source->Index]);
      break;

   case PROGRAM_ENV_PARAM:
      src =
         i915_emit_param4fv(p,
                            p->ctx->FragmentProgram.Parameters[source->
                                                               Index]);
      break;

d810 31
d846 2
a847 2
			 src_vector(p, &inst->SrcReg[0], program),
			 src_vector(p, &inst->SrcReg[1], program),
d854 2
a855 4
			 negate(src_vector(p, &inst->SrcReg[0], program),
				1, 1, 1, 1),
			 negate(src_vector(p, &inst->SrcReg[1], program),
				1, 1, 1, 1),
d988 31
d1024 2
a1025 2
			 src_vector(p, &inst->SrcReg[0], program),
			 src_vector(p, &inst->SrcReg[1], program),
d1032 2
a1033 4
			 negate(src_vector(p, &inst->SrcReg[0], program),
				1, 1, 1, 1),
			 negate(src_vector(p, &inst->SrcReg[1], program),
				1, 1, 1, 1),
@


1.6
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d100 1
a100 1
      case FRAG_ATTRIB_WPOS:
d103 1
a103 1
      case FRAG_ATTRIB_COL0:
d106 1
a106 1
      case FRAG_ATTRIB_COL1:
d110 1
a110 1
      case FRAG_ATTRIB_FOGC:
d114 8
a121 8
      case FRAG_ATTRIB_TEX0:
      case FRAG_ATTRIB_TEX1:
      case FRAG_ATTRIB_TEX2:
      case FRAG_ATTRIB_TEX3:
      case FRAG_ATTRIB_TEX4:
      case FRAG_ATTRIB_TEX5:
      case FRAG_ATTRIB_TEX6:
      case FRAG_ATTRIB_TEX7:
d123 1
a123 1
                              T_TEX0 + (source->Index - FRAG_ATTRIB_TEX0),
d127 8
a134 8
      case FRAG_ATTRIB_VAR0:
      case FRAG_ATTRIB_VAR0 + 1:
      case FRAG_ATTRIB_VAR0 + 2:
      case FRAG_ATTRIB_VAR0 + 3:
      case FRAG_ATTRIB_VAR0 + 4:
      case FRAG_ATTRIB_VAR0 + 5:
      case FRAG_ATTRIB_VAR0 + 6:
      case FRAG_ATTRIB_VAR0 + 7:
d136 1
a136 1
                              T_TEX0 + (source->Index - FRAG_ATTRIB_VAR0),
a175 1
   case PROGRAM_NAMED_PARAM:
d177 2
a178 4
      src =
         i915_emit_param4fv(p,
                            program->Base.Parameters->ParameterValues[source->
                                                                      Index]);
a1089 1
      case OPCODE_BRA:
d1149 1
a1149 1
   GLuint inputs = p->FragProg.Base.InputsRead;
d1155 1
a1155 1
      if (inputs & (FRAG_BIT_TEX(i) | FRAG_BIT_VAR(i)))
d1157 1
a1157 1
      else if (inputs & FRAG_BIT_WPOS) {
d1159 1
a1159 1
         inputs &= ~FRAG_BIT_WPOS;
d1163 1
a1163 1
   if (inputs & FRAG_BIT_WPOS) {
d1286 1
a1286 1
      return GL_TRUE;
d1301 8
a1308 1
   return GL_TRUE;
d1345 1
a1345 1
   const GLuint inputsRead = p->FragProg.Base.InputsRead;
d1362 1
a1362 1
   if (inputsRead & FRAG_BITS_TEX_ANY || p->wpos_tex != -1) {
d1369 5
a1373 1
   if (inputsRead & FRAG_BIT_COL0) {
d1378 1
a1378 1
   if (inputsRead & FRAG_BIT_COL1) {
d1383 1
a1383 1
   if ((inputsRead & FRAG_BIT_FOGC)) {
d1388 1
a1388 1
      if (inputsRead & FRAG_BIT_TEX(i)) {
d1396 1
a1396 1
      else if (inputsRead & FRAG_BIT_VAR(i)) {
d1464 1
@


1.5
log
@Merge Mesa 7.10.3
@
text
@d213 1
d273 1
a273 1
   const struct gl_fragment_program *program = p->ctx->FragmentProgram._Current; \
d306 1
a306 1
static void calc_live_regs( struct i915_fragment_program *p )
d308 3
a310 3
    const struct gl_fragment_program *program = p->ctx->FragmentProgram._Current;
    GLuint regsUsed = 0xffff0000;
    uint8_t live_components[16] = { 0, };
d320 3
d333 3
d349 2
d356 1
a356 1
    const struct gl_fragment_program *program = p->ctx->FragmentProgram._Current;
d377 1
a377 2
   const struct gl_fragment_program *program =
      p->ctx->FragmentProgram._Current;
d405 4
a408 1
   calc_live_regs(p);
d1180 1
a1180 1
      _mesa_print_program(&p->ctx->FragmentProgram._Current->Base);
a1189 5
   if (INTEL_DEBUG & DEBUG_WM) {
      printf("i915:\n");
      i915_disassemble_program(i915->state.Program, i915->state.ProgramSize);
   }

a1299 9

      /* Hack: make sure fog is correctly enabled according to this
       * fragment program's fog options.
       */
      if (p->FragProg.FogOption) {
         /* add extra instructions to do fog, then turn off FogOption field */
         _mesa_append_fog_code(ctx, &p->FragProg);
         p->FragProg.FogOption = GL_NONE;
      }
a1355 1
   intel->wpos_size = 0;
d1359 1
a1359 1
   if (inputsRead & FRAG_BITS_TEX_ANY) {
d1376 1
a1376 1
   if ((inputsRead & FRAG_BIT_FOGC) || i915->vertex_fog != I915_FOG_NONE) {
d1398 1
a1398 1

d1403 1
a1403 1
         s2 |= S2_TEXCOORD_FMT(i, SZ_TO_HW(3));
d1406 1
a1406 3
         intel->wpos_size = 3 * sizeof(GLuint);

         EMIT_PAD(intel->wpos_size);
d1424 4
d1442 5
@


1.4
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d32 5
a36 5
#include "shader/prog_instruction.h"
#include "shader/prog_parameter.h"
#include "shader/program.h"
#include "shader/programopt.h"
#include "shader/prog_print.h"
d146 14
d272 2
d275 1
a275 1
				  inst->TexSrcUnit, dim);	\
d309 1
d318 5
a322 2
        if (inst->DstReg.File == PROGRAM_TEMPORARY)
            regsUsed &= ~(1 << inst->DstReg.Index);
d326 3
a328 1
            if (inst->SrcReg[a].File == PROGRAM_TEMPORARY)
d330 8
d390 4
a393 3
       i915_program_error( p, "Exceeded max instructions" );
       return;
    }
d503 12
d586 3
d592 2
a593 1
			    swizzle(tmp, ONE, ONE, ONE, ONE), /* always */
a700 14
      case OPCODE_NOISE1:
      case OPCODE_NOISE2:
      case OPCODE_NOISE3:
      case OPCODE_NOISE4:
	 /* Don't implement noise because we just don't have the instructions
	  * to spare.  We aren't the first vendor to do so.
	  */
	 i915_program_error(p, "Stubbed-out noise functions");
	 i915_emit_arith(p,
			 A0_MOV,
			 get_result_vector(p, inst),
			 get_result_flags(inst), 0,
			 swizzle(tmp, ZERO, ZERO, ZERO, ZERO), 0, 0);

d812 1
a812 1
	 /* dst = src1 >= src2 */
d815 1
a815 1
			 dst,
d820 1
a820 1
	 /* tmp = src1 <= src2 */
d823 1
a823 1
			 tmp,
d961 1
a961 1
	 /* dst = src1 < src2 */
d964 1
a964 1
			 dst,
d969 1
a969 1
	 /* tmp = src1 > src2 */
d972 1
a972 1
			 tmp,
d989 35
d1167 6
d1179 5
d1207 1
a1207 1
i915BindProgram(GLcontext * ctx, GLenum target, struct gl_program *prog)
d1230 1
a1230 1
i915NewProgram(GLcontext * ctx, GLenum target, GLuint id)
d1258 1
a1258 1
i915DeleteProgram(GLcontext * ctx, struct gl_program *prog)
d1273 1
a1273 1
i915IsProgramNative(GLcontext * ctx, GLenum target, struct gl_program *prog)
d1288 1
a1288 1
i915ProgramStringNotify(GLcontext * ctx,
d1312 1
a1312 1
i915_update_program(GLcontext *ctx)
d1337 1
a1337 1
   GLcontext *ctx = &i915->intel.ctx;
@


1.3
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d92 2
a93 1
         i915_program_error(p, "Exceeded max temporary reg");
d125 13
d141 1
a141 1
         i915_program_error(p, "Bad source->Index");
d163 1
d171 1
a171 1
      i915_program_error(p, "Bad source->File");
d180 1
a180 1
   if (source->NegateBase)
d182 4
a185 4
                   GET_BIT(source->NegateBase, 0),
                   GET_BIT(source->NegateBase, 1),
                   GET_BIT(source->NegateBase, 2),
                   GET_BIT(source->NegateBase, 3));
d198 1
a198 1
      case FRAG_RESULT_COLR:
d200 1
a200 1
      case FRAG_RESULT_DEPR:
d204 2
a205 1
         i915_program_error(p, "Bad inst->DstReg.Index");
d211 1
a211 1
      i915_program_error(p, "Bad inst->DstReg.File");
d250 1
a250 1
      i915_program_error(p, "TexSrcBit");
d342 2
a343 1
/*    _mesa_debug_fp_inst(program->Base.NumInstructions, inst); */
d370 1
a370 1
      GLuint tmp = 0, consts0 = 0, consts1 = 0;
d522 4
d539 16
d654 14
d774 32
a805 3
      case OPCODE_SGE:
         EMIT_2ARG_ARITH(A0_SGE);
         break;
d891 28
d923 33
d1012 30
d1043 2
a1044 1
         i915_program_error(p, "bad opcode");
d1080 1
a1080 1
      if (inputs & FRAG_BIT_TEX(i))
d1208 1
a1208 1
static void
d1224 1
d1226 21
a1246 2
      if (INTEL_DEBUG & DEBUG_STATE)
	 _mesa_print_program(prog);
d1249 4
a1252 1
   _tnl_program_string(ctx, target, prog);
a1254 1

a1270 10
   if (i915->current_program != p) {
      if (i915->current_program) {
         i915->current_program->on_hardware = 0;
         i915->current_program->params_uptodate = 0;
      }

      i915->current_program = p;
   }


d1307 1
a1307 1
         int sz = VB->TexCoordPtr[i]->size;
d1313 8
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d28 3
a30 3
#include "glheader.h"
#include "macros.h"
#include "enums.h"
d36 1
d1052 3
d1112 3
a1114 14
   if ((inputsRead & (FRAG_BIT_COL1 | FRAG_BIT_FOGC)) ||
       i915->vertex_fog != I915_FOG_NONE) {

      if (inputsRead & FRAG_BIT_COL1) {
         intel->specoffset = offset / 4;
         EMIT_ATTR(_TNL_ATTRIB_COLOR1, EMIT_3UB_3F_BGR, S4_VFMT_SPEC_FOG, 3);
      }
      else
         EMIT_PAD(3);

      if ((inputsRead & FRAG_BIT_FOGC) || i915->vertex_fog != I915_FOG_NONE)
         EMIT_ATTR(_TNL_ATTRIB_FOG, EMIT_1UB_1F, S4_VFMT_SPEC_FOG, 1);
      else
         EMIT_PAD(1);
a1116 4
   /* XXX this was disabled, but enabling this code helped fix the Glean
    * tfragprog1 fog tests.
    */
#if 1
a1119 1
#endif
@


1.1
log
@Initial revision
@
text
@d32 6
d39 1
d46 20
a65 10
#include "program_instruction.h"
#include "program.h"



/* 1, -1/3!, 1/5!, -1/7! */
static const GLfloat sin_constants[4] = {  1.0, 
					   -1.0/(3*2*1),
					   1.0/(5*4*3*2*1),
					   -1.0/(7*6*5*4*3*2*1) };
d68 5
a72 4
static const GLfloat cos_constants[4] = {  1.0, 
					   -1.0/(2*1),
					   1.0/(4*3*2*1),
					   -1.0/(6*5*4*3*2*1) };
d78 4
a81 3
static GLuint src_vector( struct i915_fragment_program *p,
			  const struct prog_src_register *source,
			  const struct gl_fragment_program *program )
d89 34
a122 40
      case PROGRAM_TEMPORARY:
	 if (source->Index >= I915_MAX_TEMPORARY) {
	    i915_program_error( p, "Exceeded max temporary reg" );
	    return 0;
	 }
	 src = UREG( REG_TYPE_R, source->Index );
         break;
      case PROGRAM_INPUT:
	 switch (source->Index) {
	 case FRAG_ATTRIB_WPOS:
	    src = i915_emit_decl( p,  REG_TYPE_T, p->wpos_tex, D0_CHANNEL_ALL ); 
	    break;
	 case FRAG_ATTRIB_COL0:
	    src = i915_emit_decl( p,  REG_TYPE_T, T_DIFFUSE, D0_CHANNEL_ALL ); 
	    break;
	 case FRAG_ATTRIB_COL1:
	    src = i915_emit_decl( p,  REG_TYPE_T, T_SPECULAR, D0_CHANNEL_XYZ ); 
	    src = swizzle( src, X, Y, Z, ONE );
	    break;
	 case FRAG_ATTRIB_FOGC:
	    src = i915_emit_decl( p,  REG_TYPE_T, T_FOG_W, D0_CHANNEL_W ); 
	    src = swizzle( src, W, W, W, W );
	    break;
	 case FRAG_ATTRIB_TEX0:
	 case FRAG_ATTRIB_TEX1:
	 case FRAG_ATTRIB_TEX2:
	 case FRAG_ATTRIB_TEX3:
	 case FRAG_ATTRIB_TEX4:
	 case FRAG_ATTRIB_TEX5:
	 case FRAG_ATTRIB_TEX6:
	 case FRAG_ATTRIB_TEX7:
	    src = i915_emit_decl( p,  REG_TYPE_T, 
				 T_TEX0 + (source->Index - FRAG_ATTRIB_TEX0),
				 D0_CHANNEL_ALL ); 
	    break;

	 default:
	    i915_program_error( p, "Bad source->Index" ); 
	    return 0;
	 }
d125 28
a152 18
	 /* Various paramters and env values.  All emitted to
	  * hardware as program constants.
	  */
      case PROGRAM_LOCAL_PARAM:
         src = i915_emit_param4fv( 
	    p, program->Base.LocalParams[source->Index]);
	 break;

      case PROGRAM_ENV_PARAM:
         src = i915_emit_param4fv( 
	    p, p->ctx->FragmentProgram.Parameters[source->Index]);
	 break;

      case PROGRAM_STATE_VAR:
      case PROGRAM_NAMED_PARAM:
         src = i915_emit_param4fv( 
	    p, program->Base.Parameters->ParameterValues[source->Index] );
	 break;
d154 3
a156 3
      default:
	 i915_program_error( p, "Bad source->File" ); 
	 return 0;
d159 4
a162 5
   src = swizzle(src, 
		 GET_SWZ(source->Swizzle, 0),
		 GET_SWZ(source->Swizzle, 1),
		 GET_SWZ(source->Swizzle, 2),
		 GET_SWZ(source->Swizzle, 3));
d165 5
a169 5
      src = negate( src, 
		    GET_BIT(source->NegateBase, 0),
		    GET_BIT(source->NegateBase, 1),
		    GET_BIT(source->NegateBase, 2),
		    GET_BIT(source->NegateBase, 3));
d175 3
a177 2
static GLuint get_result_vector( struct i915_fragment_program *p,
				 const struct prog_instruction *inst )
d182 8
a189 8
      case FRAG_RESULT_COLR: 
	 return UREG(REG_TYPE_OC, 0);
      case FRAG_RESULT_DEPR: 
	 p->depth_written = 1;
	 return UREG(REG_TYPE_OD, 0);
      default: 
	 i915_program_error( p, "Bad inst->DstReg.Index" ); 
	 return 0;
d194 1
a194 1
      i915_program_error( p, "Bad inst->DstReg.File" ); 
d198 3
a200 2
   
static GLuint get_result_flags( const struct prog_instruction *inst )
d204 10
a213 5
   if (inst->SaturateMode == SATURATE_ZERO_ONE) flags |= A0_DEST_SATURATE;
   if (inst->DstReg.WriteMask & WRITEMASK_X) flags |= A0_DEST_CHANNEL_X;
   if (inst->DstReg.WriteMask & WRITEMASK_Y) flags |= A0_DEST_CHANNEL_Y;
   if (inst->DstReg.WriteMask & WRITEMASK_Z) flags |= A0_DEST_CHANNEL_Z;
   if (inst->DstReg.WriteMask & WRITEMASK_W) flags |= A0_DEST_CHANNEL_W;
d218 2
a219 2
static GLuint translate_tex_src_target( struct i915_fragment_program *p,
				     GLubyte bit )
d222 13
a234 6
   case TEXTURE_1D_INDEX:   return D0_SAMPLE_TYPE_2D;
   case TEXTURE_2D_INDEX:   return D0_SAMPLE_TYPE_2D;
   case TEXTURE_RECT_INDEX: return D0_SAMPLE_TYPE_2D;
   case TEXTURE_3D_INDEX:   return D0_SAMPLE_TYPE_VOLUME;
   case TEXTURE_CUBE_INDEX: return D0_SAMPLE_TYPE_CUBE;
   default: i915_program_error(p, "TexSrcBit"); return 0;
d246 1
a246 1
   i915_emit_texld( p,						\
d269 37
d318 2
a319 1
static void upload_program( struct i915_fragment_program *p )
d321 2
a322 1
   const struct gl_fragment_program *program = p->ctx->FragmentProgram._Current;
d332 6
a337 6
      GLuint tmp = i915_get_utemp( p );
      i915_emit_arith( p,
		      A0_MOV,
		      UREG(REG_TYPE_OC, 0), 
		      A0_DEST_CHANNEL_ALL, 0,
		      swizzle(tmp,ONE,ZERO,ONE,ONE), 0, 0);
d341 9
d352 1
a352 1
      GLuint tmp = 0;
d355 19
a373 23
      case OPCODE_ABS: 
	 src0 = src_vector( p, &inst->SrcReg[0], program);
	 i915_emit_arith( p, 
			 A0_MAX,
			 get_result_vector( p, inst ), 
			 get_result_flags( inst ), 0,
			 src0, negate(src0, 1,1,1,1), 0);
	 break;

      case OPCODE_ADD: 
	 EMIT_2ARG_ARITH( A0_ADD );
	 break;

      case OPCODE_CMP: 
	 src0 = src_vector( p, &inst->SrcReg[0], program);
	 src1 = src_vector( p, &inst->SrcReg[1], program);
	 src2 = src_vector( p, &inst->SrcReg[2], program);
	 i915_emit_arith( p, 
			 A0_CMP,
			 get_result_vector( p, inst ), 
			 get_result_flags( inst ), 0,
			 src0, src2, src1);	/* NOTE: order of src2, src1 */
	 break;
d376 12
a387 2
	 src0 = src_vector( p, &inst->SrcReg[0], program);
	 tmp = i915_get_utemp( p );
d389 1
a389 6
	 i915_emit_arith( p, 
			 A0_MUL,
			 tmp, A0_DEST_CHANNEL_X, 0,
			 src0, 
			 i915_emit_const1f(p, 1.0/(M_PI * 2)),
			 0);
d391 2
a392 2
	 i915_emit_arith( p, 
			 A0_MOD,
d394 3
a396 2
			 tmp, 
			 0, 0 );
d398 2
a399 1
	 /* By choosing different taylor constants, could get rid of this mul:
d401 7
a407 5
	 i915_emit_arith( p, 
			 A0_MUL,
			 tmp, A0_DEST_CHANNEL_X, 0,
			 tmp, 
			 i915_emit_const1f(p, (M_PI * 2)),
d410 2
a411 7
	 /* 
	  * t0.xy = MUL x.xx11, x.x1111  ; x^2, x, 1, 1
	  * t0 = MUL t0.xyxy t0.xx11 ; x^4, x^3, x^2, 1
	  * t0 = MUL t0.xxz1 t0.z111    ; x^6 x^4 x^2 1
	  * result = DP4 t0, cos_constants
	  */
	 i915_emit_arith( p, 
d413 4
a416 3
			 tmp, A0_DEST_CHANNEL_XY, 0,
			 swizzle(tmp, X,X,ONE,ONE), 
			 swizzle(tmp, X,ONE,ONE,ONE), 0);
d418 7
a424 5
	 i915_emit_arith( p, 
			 A0_MUL,
			 tmp, A0_DEST_CHANNEL_XYZ, 0,
			 swizzle(tmp, X,Y,X,ONE), 
			 swizzle(tmp, X,X,ONE,ONE), 0);
d426 2
a427 42
	 i915_emit_arith( p, 
			 A0_MUL,
			 tmp, A0_DEST_CHANNEL_XYZ, 0,
			 swizzle(tmp, X,X,Z,ONE), 
			 swizzle(tmp, Z,ONE,ONE,ONE), 0);
	    
	 i915_emit_arith( p, 
			 A0_DP4,
			 get_result_vector( p, inst ), 
			 get_result_flags( inst ), 0,
			 swizzle(tmp, ONE,Z,Y,X),
			 i915_emit_const4fv( p, cos_constants ), 0);

	 break;

      case OPCODE_DP3: 
	 EMIT_2ARG_ARITH( A0_DP3 );
	 break;

      case OPCODE_DP4: 
	 EMIT_2ARG_ARITH( A0_DP4 );
	 break;

      case OPCODE_DPH:  
	 src0 = src_vector( p, &inst->SrcReg[0], program);
	 src1 = src_vector( p, &inst->SrcReg[1], program);

	 i915_emit_arith( p, 
			 A0_DP4,
			 get_result_vector( p, inst ), 
			 get_result_flags( inst ), 0,
			 swizzle(src0, X,Y,Z,ONE), src1, 0);
	 break;

      case OPCODE_DST: 
	 src0 = src_vector( p, &inst->SrcReg[0], program);
	 src1 = src_vector( p, &inst->SrcReg[1], program);

	 /* result[0] = 1    * 1;
	  * result[1] = a[1] * b[1];
	  * result[2] = a[2] * 1;
	  * result[3] = 1    * b[3];
d429 5
a433 6
	 i915_emit_arith( p, 
			 A0_MUL,
			 get_result_vector( p, inst ), 
			 get_result_flags( inst ), 0,
			 swizzle(src0, ONE, Y, Z,   ONE), 
			 swizzle(src1, ONE, Y, ONE, W  ),
a434 1
	 break;
d436 56
a491 2
      case OPCODE_EX2: 
	 src0 = src_vector( p, &inst->SrcReg[0], program);
d493 14
a506 14
	 i915_emit_arith( p, 
			 A0_EXP,
			 get_result_vector( p, inst ), 
			 get_result_flags( inst ), 0,
			 swizzle(src0,X,X,X,X), 0, 0);
	 break;

      case OPCODE_FLR: 
	 EMIT_1ARG_ARITH( A0_FLR );
	 break;

      case OPCODE_FRC: 
	 EMIT_1ARG_ARITH( A0_FRC );
	 break;
d509 2
a510 2
	 src0 = src_vector( p, &inst->SrcReg[0], program);
	 tmp = i915_get_utemp( p );
d512 14
a525 30
	 i915_emit_texld( p,
			 tmp, A0_DEST_CHANNEL_ALL, /* use a dummy dest reg */
			 0,
			 src0,
			 T0_TEXKILL );
	 break;

      case OPCODE_LG2: 
	 src0 = src_vector( p, &inst->SrcReg[0], program);

	 i915_emit_arith( p, 
			 A0_LOG,
			 get_result_vector( p, inst ), 
			 get_result_flags( inst ), 0,
			 swizzle(src0,X,X,X,X), 0, 0);
	 break;

      case OPCODE_LIT: 
	 src0 = src_vector( p, &inst->SrcReg[0], program);
	 tmp = i915_get_utemp( p );

	 /* tmp = max( a.xyzw, a.00zw )
	  * XXX: Clamp tmp.w to -128..128
	  * tmp.y = log(tmp.y)
	  * tmp.y = tmp.w * tmp.y
	  * tmp.y = exp(tmp.y)
	  * result = cmp (a.11-x1, a.1x01, a.1xy1 )
	  */
	 i915_emit_arith( p, A0_MAX, tmp, A0_DEST_CHANNEL_ALL, 0, 
			 src0, swizzle(src0, ZERO, ZERO, Z, W), 0 );
d527 30
a556 2
	 i915_emit_arith( p, A0_LOG, tmp, A0_DEST_CHANNEL_Y, 0, 
			 swizzle(tmp, Y, Y, Y, Y), 0, 0 );
d558 1
a558 22
	 i915_emit_arith( p, A0_MUL, tmp, A0_DEST_CHANNEL_Y, 0, 
			 swizzle(tmp, ZERO, Y, ZERO, ZERO), 
			 swizzle(tmp, ZERO, W, ZERO, ZERO), 0 );

	 i915_emit_arith( p, A0_EXP, tmp, A0_DEST_CHANNEL_Y, 0, 
			 swizzle(tmp, Y, Y, Y, Y), 0, 0 );

	 i915_emit_arith( p, A0_CMP,
			 get_result_vector( p, inst ), 
			 get_result_flags( inst ), 0,
			 negate(swizzle(tmp, ONE, ONE, X, ONE),0,0,1,0),
			 swizzle(tmp, ONE, X, ZERO, ONE),
			 swizzle(tmp, ONE, X, Y, ONE));
		     
	 break;

      case OPCODE_LRP: 
	 src0 = src_vector( p, &inst->SrcReg[0], program);
	 src1 = src_vector( p, &inst->SrcReg[1], program);
	 src2 = src_vector( p, &inst->SrcReg[2], program);
	 flags = get_result_flags( inst );
	 tmp = i915_get_utemp( p );
d560 21
a580 16
	 /* b*a + c*(1-a)
	  *
	  * b*a + c - ca 
	  *
	  * tmp = b*a + c, 
	  * result = (-c)*a + tmp 
	  */
	 i915_emit_arith( p, A0_MAD, tmp, 
			 flags & A0_DEST_CHANNEL_ALL, 0,
			 src1, src0, src2 );

	 i915_emit_arith( p, A0_MAD, 
			 get_result_vector( p, inst ), 
			 flags, 0, 
			 negate(src2, 1,1,1,1), src0, tmp );
	 break;
d583 2
a584 2
	 EMIT_3ARG_ARITH( A0_MAD );
	 break;
d587 2
a588 2
	 EMIT_2ARG_ARITH( A0_MAX );
	 break;
d590 25
a614 32
      case OPCODE_MIN: 
	 src0 = src_vector( p, &inst->SrcReg[0], program);
	 src1 = src_vector( p, &inst->SrcReg[1], program);
	 tmp = i915_get_utemp( p );
	 flags = get_result_flags( inst );

	 i915_emit_arith( p, 
			 A0_MAX,
			 tmp, flags & A0_DEST_CHANNEL_ALL, 0,
			 negate(src0,1,1,1,1), 
			 negate(src1,1,1,1,1), 0);

	 i915_emit_arith( p,
			 A0_MOV,
			 get_result_vector( p, inst ), 
			 flags, 0,
			 negate(tmp, 1,1,1,1), 0, 0);
	 break;

      case OPCODE_MOV: 
	 EMIT_1ARG_ARITH( A0_MOV );
	 break;

      case OPCODE_MUL: 
	 EMIT_2ARG_ARITH( A0_MUL );
	 break;

      case OPCODE_POW: 
	 src0 = src_vector( p, &inst->SrcReg[0], program);
	 src1 = src_vector( p, &inst->SrcReg[1], program);
	 tmp = i915_get_utemp( p );
	 flags = get_result_flags( inst );
d616 34
a649 6
	 /* XXX: masking on intermediate values, here and elsewhere.
	  */
	 i915_emit_arith( p, 
			 A0_LOG,
			 tmp, A0_DEST_CHANNEL_X, 0,
			 swizzle(src0,X,X,X,X), 0, 0);
d651 1
a651 4
	 i915_emit_arith( p,
			 A0_MUL,
			 tmp, A0_DEST_CHANNEL_X, 0,
			 tmp, src1, 0);
d653 6
a659 29
	 i915_emit_arith( p,
			 A0_EXP,
			 get_result_vector( p, inst ), 
			 flags, 0,
			 swizzle(tmp,X,X,X,X), 0, 0);

	 break;

      case OPCODE_RCP: 
	 src0 = src_vector( p, &inst->SrcReg[0], program);

	 i915_emit_arith( p, 
			 A0_RCP,
			 get_result_vector( p, inst ), 
			 get_result_flags( inst ), 0,
			 swizzle(src0,X,X,X,X), 0, 0);
	 break;

      case OPCODE_RSQ: 

	 src0 = src_vector( p, &inst->SrcReg[0], program);

	 i915_emit_arith( p, 
			 A0_RSQ,
			 get_result_vector( p, inst ), 
			 get_result_flags( inst ), 0,
			 swizzle(src0,X,X,X,X), 0, 0);
	 break;
	 
d661 2
a662 2
	 src0 = src_vector( p, &inst->SrcReg[0], program);
	 tmp = i915_get_utemp( p );
d664 57
a720 13
	 /* 
	  * t0.xy = MUL x.xx11, x.x1111  ; x^2, x, 1, 1
	  * t0 = MUL t0.xyxy t0.xx11 ; x^4, x^3, x^2, x
	  * t1 = MUL t0.xyyw t0.yz11    ; x^7 x^5 x^3 x
	  * scs.x = DP4 t1, sin_constants
	  * t1 = MUL t0.xxz1 t0.z111    ; x^6 x^4 x^2 1
	  * scs.y = DP4 t1, cos_constants
	  */
	 i915_emit_arith( p, 
			 A0_MUL,
			 tmp, A0_DEST_CHANNEL_XY, 0,
			 swizzle(src0, X,X,ONE,ONE), 
			 swizzle(src0, X,ONE,ONE,ONE), 0);
d722 3
a724 47
	 i915_emit_arith( p, 
			 A0_MUL,
			 tmp, A0_DEST_CHANNEL_ALL, 0,
			 swizzle(tmp, X,Y,X,Y), 
			 swizzle(tmp, X,X,ONE,ONE), 0);

	 if (inst->DstReg.WriteMask & WRITEMASK_Y) {
	    GLuint tmp1;
	    
	    if (inst->DstReg.WriteMask & WRITEMASK_X)
	       tmp1 = i915_get_utemp( p );
	    else
	       tmp1 = tmp;

	    i915_emit_arith( p, 
			    A0_MUL,
			    tmp1, A0_DEST_CHANNEL_ALL, 0,
			    swizzle(tmp, X,Y,Y,W), 
			    swizzle(tmp, X,Z,ONE,ONE), 0);
	    
	    i915_emit_arith( p, 
			    A0_DP4,
			    get_result_vector( p, inst ), 
			    A0_DEST_CHANNEL_Y, 0,
			    swizzle(tmp1, W,Z,Y,X),
			    i915_emit_const4fv( p, sin_constants ), 0);
	 }

	 if (inst->DstReg.WriteMask & WRITEMASK_X) {
	    i915_emit_arith( p, 
			    A0_MUL,
			    tmp, A0_DEST_CHANNEL_XYZ, 0,
			    swizzle(tmp, X,X,Z,ONE), 
			    swizzle(tmp, Z,ONE,ONE,ONE), 0);
	    
	    i915_emit_arith( p, 
			    A0_DP4,
			    get_result_vector( p, inst ), 
			    A0_DEST_CHANNEL_X, 0,
			    swizzle(tmp, ONE,Z,Y,X), 
			    i915_emit_const4fv( p, cos_constants ), 0);
	 }
	 break;

      case OPCODE_SGE: 
	 EMIT_2ARG_ARITH( A0_SGE );
	 break;
d727 29
a755 2
	 src0 = src_vector( p, &inst->SrcReg[0], program);
	 tmp = i915_get_utemp( p );
d757 10
a766 1
	 i915_emit_arith( p, 
d768 3
a770 3
			 tmp, A0_DEST_CHANNEL_X, 0,
			 src0, 
			 i915_emit_const1f(p, 1.0/(M_PI * 2)),
d773 7
a779 5
	 i915_emit_arith( p, 
			 A0_MOD,
			 tmp, A0_DEST_CHANNEL_X, 0,
			 tmp, 
			 0, 0 );
d781 2
a782 1
	 /* By choosing different taylor constants, could get rid of this mul:
d784 5
a788 5
	 i915_emit_arith( p, 
			 A0_MUL,
			 tmp, A0_DEST_CHANNEL_X, 0,
			 tmp, 
			 i915_emit_const1f(p, (M_PI * 2)),
d791 33
a823 11
	 /* 
	  * t0.xy = MUL x.xx11, x.x1111  ; x^2, x, 1, 1
	  * t0 = MUL t0.xyxy t0.xx11 ; x^4, x^3, x^2, x
	  * t1 = MUL t0.xyyw t0.yz11    ; x^7 x^5 x^3 x
	  * result = DP4 t1.wzyx, sin_constants
	  */
	 i915_emit_arith( p, 
			 A0_MUL,
			 tmp, A0_DEST_CHANNEL_XY, 0,
			 swizzle(tmp, X,X,ONE,ONE), 
			 swizzle(tmp, X,ONE,ONE,ONE), 0);
d825 3
a827 5
	 i915_emit_arith( p, 
			 A0_MUL,
			 tmp, A0_DEST_CHANNEL_ALL, 0,
			 swizzle(tmp, X,Y,X,Y), 
			 swizzle(tmp, X,X,ONE,ONE), 0);
d829 3
a831 36
	 i915_emit_arith( p, 
			 A0_MUL,
			 tmp, A0_DEST_CHANNEL_ALL, 0,
			 swizzle(tmp, X,Y,Y,W), 
			 swizzle(tmp, X,Z,ONE,ONE), 0);
	    
	 i915_emit_arith( p, 
			 A0_DP4,
			 get_result_vector( p, inst ), 
			 get_result_flags( inst ), 0,
			 swizzle(tmp, W, Z, Y, X ),
			 i915_emit_const4fv( p, sin_constants ), 0);
	 break;

      case OPCODE_SLT: 
	 EMIT_2ARG_ARITH( A0_SLT );
	 break;

      case OPCODE_SUB: 
	 src0 = src_vector( p, &inst->SrcReg[0], program);
	 src1 = src_vector( p, &inst->SrcReg[1], program);

	 i915_emit_arith( p, 
			 A0_ADD,
			 get_result_vector( p, inst ), 
			 get_result_flags( inst ), 0,
			 src0, negate(src1, 1,1,1,1), 0);
	 break;

      case OPCODE_SWZ: 
	 EMIT_1ARG_ARITH( A0_MOV ); /* extended swizzle handled natively */
	 break;

      case OPCODE_TEX: 
	 EMIT_TEX( T0_TEXLD );
	 break;
d834 2
a835 2
	 EMIT_TEX( T0_TEXLDB );
	 break;
d838 2
a839 2
	 EMIT_TEX( T0_TEXLDP );
	 break;
d842 24
a865 15
	 /* Cross product:
	  *      result.x = src0.y * src1.z - src0.z * src1.y;
	  *      result.y = src0.z * src1.x - src0.x * src1.z;
	  *      result.z = src0.x * src1.y - src0.y * src1.x;
	  *      result.w = undef;
	  */
	 src0 = src_vector( p, &inst->SrcReg[0], program);
	 src1 = src_vector( p, &inst->SrcReg[1], program);
	 tmp = i915_get_utemp( p );
	 
	 i915_emit_arith( p, 
			 A0_MUL,
			 tmp, A0_DEST_CHANNEL_ALL, 0,
			 swizzle(src0,Z,X,Y,ONE), 
			 swizzle(src1,Y,Z,X,ONE), 0);
d867 2
a868 8
	 i915_emit_arith( p, 
			 A0_MAD,
			 get_result_vector( p, inst ), 
			 get_result_flags( inst ), 0,
			 swizzle(src0,Y,Z,X,ONE), 
			 swizzle(src1,Z,X,Y,ONE), 
			 negate(tmp,1,1,1,0));
	 break;
a869 3
      case OPCODE_END:
	 return;
	 
d871 2
a872 2
	 i915_program_error( p, "bad opcode" );
	 return;
d876 1
a876 1
      i915_release_utemps( p ); 
d884 2
a885 1
static void fixup_depth_write( struct i915_fragment_program *p )
d890 4
a893 5
      i915_emit_arith( p, 
		      A0_MOV,
		      depth, A0_DEST_CHANNEL_W, 0,
		      swizzle(depth,X,Y,Z,Z), 
		      0, 0);
d898 2
a899 4
#define FRAG_BIT_TEX(n)  (FRAG_BIT_TEX0 << (n))


static void check_wpos( struct i915_fragment_program *p )
d907 2
a908 2
      if (inputs & FRAG_BIT_TEX(i)) 
	 continue;
d910 3
a912 3
	 p->wpos_tex = i;
	 inputs &= ~FRAG_BIT_WPOS;
      }   
d921 2
a922 1
static void translate_program( struct i915_fragment_program *p )
d924 8
a931 8
   i915ContextPtr i915 = I915_CONTEXT(p->ctx);
   
   i915_init_program( i915, p );
   check_wpos( p ); 
   upload_program( p );
   fixup_depth_write( p );
   i915_fini_program( p ); 
   
d936 2
a937 1
static void track_params( struct i915_fragment_program *p )
d942 1
a942 1
      _mesa_load_state_parameters(p->ctx, p->FragProg.Base.Parameters); 
d946 1
a946 1
      COPY_4V( p->constant[reg], p->param[i].values );
d948 1
a948 1
   
d950 1
a950 1
   p->on_hardware = 0;		/* overkill */
d954 2
a955 3
static void i915BindProgram( GLcontext *ctx,
			    GLenum target, 
			    struct gl_program *prog )
d958 5
a962 2
      i915ContextPtr i915 = I915_CONTEXT(ctx);
      struct i915_fragment_program *p = (struct i915_fragment_program *)prog;
a963 3
      if (i915->current_program == p) 
	 return;
      
d965 2
a966 2
	 i915->current_program->on_hardware = 0;
	 i915->current_program->params_uptodate = 0;
d968 1
a968 1
      
a973 5
      /* Hack: make sure fog is correctly enabled according to this
       * fragment program's fog options.
       */
      ctx->Driver.Enable( ctx, GL_FRAGMENT_PROGRAM_ARB, 
			  ctx->FragmentProgram.Enabled );
d977 2
a978 3
static struct gl_program *i915NewProgram( GLcontext *ctx,
				      GLenum target, 
				      GLuint id )
d982 2
a983 2
      return _mesa_init_vertex_program( ctx, CALLOC_STRUCT(gl_vertex_program),
					target, id );
d985 11
a995 7
   case GL_FRAGMENT_PROGRAM_ARB: {
      struct i915_fragment_program *prog = CALLOC_STRUCT(i915_fragment_program);
      if (prog) {
	 i915_init_program( I915_CONTEXT(ctx), prog );

	 return _mesa_init_fragment_program( ctx, &prog->FragProg,
					     target, id );
a996 3
      else
	 return NULL;
   }
d1001 1
a1001 1
      return _mesa_new_program( ctx, target, id );
d1005 2
a1006 2
static void i915DeleteProgram( GLcontext *ctx,
			      struct gl_program *prog )
d1009 5
a1013 5
      i915ContextPtr i915 = I915_CONTEXT(ctx);
      struct i915_fragment_program *p = (struct i915_fragment_program *)prog;
      
      if (i915->current_program == p) 
	 i915->current_program = 0;
d1016 1
a1016 1
   _mesa_delete_program( ctx, prog );
d1020 2
a1021 3
static GLboolean i915IsProgramNative( GLcontext *ctx,
				     GLenum target, 
				     struct gl_program *prog )
d1024 1
a1024 1
      struct i915_fragment_program *p = (struct i915_fragment_program *)prog;
d1027 2
a1028 2
	 translate_program( p );
      
d1035 3
a1037 3
static void i915ProgramStringNotify( GLcontext *ctx,
				    GLenum target,
				    struct gl_program *prog )
d1040 1
a1040 1
      struct i915_fragment_program *p = (struct i915_fragment_program *)prog;
d1046 5
a1050 2
      ctx->Driver.Enable( ctx, GL_FRAGMENT_PROGRAM_ARB, 
			  ctx->FragmentProgram.Enabled );
d1052 2
d1057 2
a1058 1
void i915ValidateFragmentProgram( i915ContextPtr i915 )
d1061 1
a1061 1
   intelContextPtr intel = INTEL_CONTEXT(ctx);
d1065 2
a1066 2
   struct i915_fragment_program *p = 
      (struct i915_fragment_program *)ctx->FragmentProgram._Current;
d1073 10
d1087 2
a1088 2
   if (!p->translated) 
      translate_program( p );
d1097 1
a1097 1
      EMIT_ATTR( _TNL_ATTRIB_POS, EMIT_4F_VIEWPORT, S4_VFMT_XYZW, 16 );
d1100 1
a1100 1
      EMIT_ATTR( _TNL_ATTRIB_POS, EMIT_3F_VIEWPORT, S4_VFMT_XYZ, 12 );
d1105 1
a1105 1
      EMIT_ATTR( _TNL_ATTRIB_COLOR0, EMIT_4UB_4F_BGRA, S4_VFMT_COLOR, 4 );
d1107 2
a1108 2
   
   if ((inputsRead & (FRAG_BIT_COL1|FRAG_BIT_FOGC)) || 
d1112 2
a1113 2
	 intel->specoffset = offset / 4;
	 EMIT_ATTR( _TNL_ATTRIB_COLOR1, EMIT_3UB_3F_BGR, S4_VFMT_SPEC_FOG, 3 );
d1116 1
a1116 1
	 EMIT_PAD(3);
d1118 2
a1119 2
      if ((inputsRead & FRAG_BIT_FOGC) || i915->vertex_fog != I915_FOG_NONE) 
	 EMIT_ATTR( _TNL_ATTRIB_FOG, EMIT_1UB_1F, S4_VFMT_SPEC_FOG, 1 );
d1121 1
a1121 1
	 EMIT_PAD( 1 );
d1124 4
a1127 1
#if 0
d1129 1
a1129 1
      EMIT_ATTR( _TNL_ATTRIB_FOG, EMIT_1F, S4_VFMT_FOG_PARAM, 4 );
d1135 1
a1135 4
	 int sz = VB->TexCoordPtr[i]->size;
	    
	 s2 &= ~S2_TEXCOORD_FMT(i, S2_TEXCOORD_FMT0_MASK);
	 s2 |= S2_TEXCOORD_FMT(i, SZ_TO_HW(sz));
d1137 4
a1140 1
	 EMIT_ATTR( _TNL_ATTRIB_TEX0+i, EMIT_SZ(sz), 0, sz * 4 );
a1142 6
	
	 /* If WPOS is required, duplicate the XYZ position data in an
	  * unused texture coordinate:
	  */
	 s2 &= ~S2_TEXCOORD_FMT(i, S2_TEXCOORD_FMT0_MASK);
	 s2 |= S2_TEXCOORD_FMT(i, SZ_TO_HW(3));
d1144 8
a1151 2
	 intel->wpos_offset = offset;
	 intel->wpos_size = 3 * sizeof(GLuint);
d1153 2
a1154 2
	 EMIT_PAD( intel->wpos_size );
      }   
d1159 3
a1161 2
    
      I915_STATECHANGE( i915, I915_UPLOAD_CTX );
d1166 4
a1169 4
      intel->vertex_size = _tnl_install_attrs( &intel->ctx, 
					       intel->vertex_attrs, 
					       intel->vertex_attr_count,
					       intel->ViewportMatrix.m, 0 ); 
d1176 2
a1177 1
      assert(intel->vtbl.check_vertex_size( intel, intel->vertex_size ));
d1180 2
a1181 2
   if (!p->params_uptodate) 
      track_params( p );
d1183 2
a1184 2
   if (!p->on_hardware) 
      i915_upload_program( i915, p );
d1187 2
a1188 1
void i915InitFragProgFuncs( struct dd_function_table *functions )
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a31 1
#include "tnl/tnl.h"
a40 1
#include "programopt.h"
a124 1
      case PROGRAM_CONSTANT:
a938 6

      if (p->FragProg.FogOption) {
         /* add extra instructions to do fog, then turn off FogOption field */
         _mesa_append_fog_code(ctx, &p->FragProg);
         p->FragProg.FogOption = GL_NONE;
      }
a939 2

   _tnl_program_string(ctx, target, prog);
a957 11
   if (i915->current_program != p) 
   {
      if (i915->current_program) {
	 i915->current_program->on_hardware = 0;
	 i915->current_program->params_uptodate = 0;
      }
      
      i915->current_program = p;
   }


d999 1
a999 4
   /* XXX this was disabled, but enabling this code helped fix the Glean
    * tfragprog1 fog tests.
    */
#if 1
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d40 1
a40 2
#include "prog_instruction.h"
#include "prog_parameter.h"
d783 3
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d28 3
a30 9
#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"

#include "program/prog_instruction.h"
#include "program/prog_parameter.h"
#include "program/program.h"
#include "program/programopt.h"
#include "program/prog_print.h"
a33 1

d40 12
a51 20
static const GLfloat sin_quad_constants[2][4] = {
   {
      2.0,
      -1.0,
      .5,
      .75
   },
   {
      4.0,
      -4.0,
      1.0 / (2.0 * M_PI),
      .2225
   }
};

static const GLfloat sin_constants[4] = { 1.0,
   -1.0 / (3 * 2 * 1),
   1.0 / (5 * 4 * 3 * 2 * 1),
   -1.0 / (7 * 6 * 5 * 4 * 3 * 2 * 1)
};
d54 4
a57 5
static const GLfloat cos_constants[4] = { 1.0,
   -1.0 / (2 * 1),
   1.0 / (4 * 3 * 2 * 1),
   -1.0 / (6 * 5 * 4 * 3 * 2 * 1)
};
d63 3
a65 4
static GLuint
src_vector(struct i915_fragment_program *p,
           const struct prog_src_register *source,
           const struct gl_fragment_program *program)
d73 6
a78 12
   case PROGRAM_TEMPORARY:
      if (source->Index >= I915_MAX_TEMPORARY) {
         i915_program_error(p, "Exceeded max temporary reg: %d/%d",
			    source->Index, I915_MAX_TEMPORARY);
         return 0;
      }
      src = UREG(REG_TYPE_R, source->Index);
      break;
   case PROGRAM_INPUT:
      switch (source->Index) {
      case FRAG_ATTRIB_WPOS:
         src = i915_emit_decl(p, REG_TYPE_T, p->wpos_tex, D0_CHANNEL_ALL);
d80 33
a112 35
      case FRAG_ATTRIB_COL0:
         src = i915_emit_decl(p, REG_TYPE_T, T_DIFFUSE, D0_CHANNEL_ALL);
         break;
      case FRAG_ATTRIB_COL1:
         src = i915_emit_decl(p, REG_TYPE_T, T_SPECULAR, D0_CHANNEL_XYZ);
         src = swizzle(src, X, Y, Z, ONE);
         break;
      case FRAG_ATTRIB_FOGC:
         src = i915_emit_decl(p, REG_TYPE_T, T_FOG_W, D0_CHANNEL_W);
         src = swizzle(src, W, ZERO, ZERO, ONE);
         break;
      case FRAG_ATTRIB_TEX0:
      case FRAG_ATTRIB_TEX1:
      case FRAG_ATTRIB_TEX2:
      case FRAG_ATTRIB_TEX3:
      case FRAG_ATTRIB_TEX4:
      case FRAG_ATTRIB_TEX5:
      case FRAG_ATTRIB_TEX6:
      case FRAG_ATTRIB_TEX7:
         src = i915_emit_decl(p, REG_TYPE_T,
                              T_TEX0 + (source->Index - FRAG_ATTRIB_TEX0),
                              D0_CHANNEL_ALL);
	 break;

      case FRAG_ATTRIB_VAR0:
      case FRAG_ATTRIB_VAR0 + 1:
      case FRAG_ATTRIB_VAR0 + 2:
      case FRAG_ATTRIB_VAR0 + 3:
      case FRAG_ATTRIB_VAR0 + 4:
      case FRAG_ATTRIB_VAR0 + 5:
      case FRAG_ATTRIB_VAR0 + 6:
      case FRAG_ATTRIB_VAR0 + 7:
         src = i915_emit_decl(p, REG_TYPE_T,
                              T_TEX0 + (source->Index - FRAG_ATTRIB_VAR0),
                              D0_CHANNEL_ALL);
d115 7
a121 5
      default:
         i915_program_error(p, "Bad source->Index: %d", source->Index);
         return 0;
      }
      break;
d123 3
a125 4
   case PROGRAM_OUTPUT:
      switch (source->Index) {
      case FRAG_RESULT_COLOR:
	 src = UREG(REG_TYPE_OC, 0);
d127 6
a132 2
      case FRAG_RESULT_DEPTH:
	 src = UREG(REG_TYPE_OD, 0);
d134 1
d136 1
a136 1
	 i915_program_error(p, "Bad source->Index: %d", source->Index);
a137 30
      }
      break;

      /* Various paramters and env values.  All emitted to
       * hardware as program constants.
       */
   case PROGRAM_LOCAL_PARAM:
      src = i915_emit_param4fv(p, program->Base.LocalParams[source->Index]);
      break;

   case PROGRAM_ENV_PARAM:
      src =
         i915_emit_param4fv(p,
                            p->ctx->FragmentProgram.Parameters[source->
                                                               Index]);
      break;

   case PROGRAM_CONSTANT:
   case PROGRAM_STATE_VAR:
   case PROGRAM_NAMED_PARAM:
   case PROGRAM_UNIFORM:
      src =
         i915_emit_param4fv(p,
                            program->Base.Parameters->ParameterValues[source->
                                                                      Index]);
      break;

   default:
      i915_program_error(p, "Bad source->File: %d", source->File);
      return 0;
d140 12
a151 11
   src = swizzle(src,
                 GET_SWZ(source->Swizzle, 0),
                 GET_SWZ(source->Swizzle, 1),
                 GET_SWZ(source->Swizzle, 2), GET_SWZ(source->Swizzle, 3));

   if (source->Negate)
      src = negate(src,
                   GET_BIT(source->Negate, 0),
                   GET_BIT(source->Negate, 1),
                   GET_BIT(source->Negate, 2),
                   GET_BIT(source->Negate, 3));
d157 2
a158 3
static GLuint
get_result_vector(struct i915_fragment_program *p,
                  const struct prog_instruction *inst)
d163 8
a170 9
      case FRAG_RESULT_COLOR:
         return UREG(REG_TYPE_OC, 0);
      case FRAG_RESULT_DEPTH:
         p->depth_written = 1;
         return UREG(REG_TYPE_OD, 0);
      default:
         i915_program_error(p, "Bad inst->DstReg.Index: %d",
			    inst->DstReg.Index);
         return 0;
d175 1
a175 1
      i915_program_error(p, "Bad inst->DstReg.File: %d", inst->DstReg.File);
d179 2
a180 3

static GLuint
get_result_flags(const struct prog_instruction *inst)
d184 5
a188 10
   if (inst->SaturateMode == SATURATE_ZERO_ONE)
      flags |= A0_DEST_SATURATE;
   if (inst->DstReg.WriteMask & WRITEMASK_X)
      flags |= A0_DEST_CHANNEL_X;
   if (inst->DstReg.WriteMask & WRITEMASK_Y)
      flags |= A0_DEST_CHANNEL_Y;
   if (inst->DstReg.WriteMask & WRITEMASK_Z)
      flags |= A0_DEST_CHANNEL_Z;
   if (inst->DstReg.WriteMask & WRITEMASK_W)
      flags |= A0_DEST_CHANNEL_W;
d193 2
a194 2
static GLuint
translate_tex_src_target(struct i915_fragment_program *p, GLubyte bit)
d197 6
a202 13
   case TEXTURE_1D_INDEX:
      return D0_SAMPLE_TYPE_2D;
   case TEXTURE_2D_INDEX:
      return D0_SAMPLE_TYPE_2D;
   case TEXTURE_RECT_INDEX:
      return D0_SAMPLE_TYPE_2D;
   case TEXTURE_3D_INDEX:
      return D0_SAMPLE_TYPE_VOLUME;
   case TEXTURE_CUBE_INDEX:
      return D0_SAMPLE_TYPE_CUBE;
   default:
      i915_program_error(p, "TexSrcBit: %d", bit);
      return 0;
a208 2
   const struct gl_fragment_program *program = p->ctx->FragmentProgram._Current; \
   GLuint unit = program->Base.SamplerUnits[inst->TexSrcUnit];	\
d210 1
a210 1
				   unit, dim);			\
d214 1
a214 1
   i915_emit_texld( p, get_live_regs(p, inst),						\
a236 51
/* 
 * TODO: consider moving this into core 
 */
static void calc_live_regs( struct i915_fragment_program *p )
{
    const struct gl_fragment_program *program = p->ctx->FragmentProgram._Current;
    GLuint regsUsed = 0xffff0000;
    uint8_t live_components[16] = { 0, };
    GLint i;
   
    for (i = program->Base.NumInstructions - 1; i >= 0; i--) {
        struct prog_instruction *inst = &program->Base.Instructions[i];
        int opArgs = _mesa_num_inst_src_regs(inst->Opcode);
        int a;

        /* Register is written to: unmark as live for this and preceeding ops */ 
        if (inst->DstReg.File == PROGRAM_TEMPORARY) {
            live_components[inst->DstReg.Index] &= ~inst->DstReg.WriteMask;
            if (live_components[inst->DstReg.Index] == 0)
                regsUsed &= ~(1 << inst->DstReg.Index);
        }

        for (a = 0; a < opArgs; a++) {
            /* Register is read from: mark as live for this and preceeding ops */ 
            if (inst->SrcReg[a].File == PROGRAM_TEMPORARY) {
                unsigned c;

                regsUsed |= 1 << inst->SrcReg[a].Index;

                for (c = 0; c < 4; c++) {
                    const unsigned field = GET_SWZ(inst->SrcReg[a].Swizzle, c);

                    if (field <= SWIZZLE_W)
                        live_components[inst->SrcReg[a].Index] |= (1U << field);
                }
            }
        }

        p->usedRegs[i] = regsUsed;
    }
}

static GLuint get_live_regs( struct i915_fragment_program *p, 
                             const struct prog_instruction *inst )
{
    const struct gl_fragment_program *program = p->ctx->FragmentProgram._Current;
    GLuint nr = inst - program->Base.Instructions;

    return p->usedRegs[nr];
}
 
d249 1
a249 2
static void
upload_program(struct i915_fragment_program *p)
d251 1
a251 2
   const struct gl_fragment_program *program =
      p->ctx->FragmentProgram._Current;
d254 1
a254 2
   if (INTEL_DEBUG & DEBUG_WM)
      _mesa_print_program(&program->Base);
d261 6
a266 12
      GLuint tmp = i915_get_utemp(p);
      i915_emit_arith(p,
                      A0_MOV,
                      UREG(REG_TYPE_OC, 0),
                      A0_DEST_CHANNEL_ALL, 0,
                      swizzle(tmp, ONE, ZERO, ONE, ONE), 0, 0);
      return;
   }

   if (program->Base.NumInstructions > I915_MAX_INSN) {
      i915_program_error(p, "Exceeded max instructions (%d out of %d)",
			 program->Base.NumInstructions, I915_MAX_INSN);
a269 4
   /* Not always needed:
    */
   calc_live_regs(p);

d272 1
a272 1
      GLuint tmp = 0, dst, consts0 = 0, consts1 = 0;
d275 8
a282 8
      case OPCODE_ABS:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         i915_emit_arith(p,
                         A0_MAX,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         src0, negate(src0, 1, 1, 1, 1), 0);
         break;
d284 3
a286 3
      case OPCODE_ADD:
         EMIT_2ARG_ARITH(A0_ADD);
         break;
d288 10
a297 6
      case OPCODE_CMP:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);
         src2 = src_vector(p, &inst->SrcReg[2], program);
         i915_emit_arith(p, A0_CMP, get_result_vector(p, inst), get_result_flags(inst), 0, src0, src2, src1);   /* NOTE: order of src2, src1 */
         break;
d300 2
a301 12
         src0 = src_vector(p, &inst->SrcReg[0], program);
         tmp = i915_get_utemp(p);
	 consts0 = i915_emit_const4fv(p, sin_quad_constants[0]);
	 consts1 = i915_emit_const4fv(p, sin_quad_constants[1]);

	 /* Reduce range from repeating about [-pi,pi] to [-1,1] */
         i915_emit_arith(p,
                         A0_MAD,
                         tmp, A0_DEST_CHANNEL_X, 0,
                         src0,
			 swizzle(consts1, Z, ZERO, ZERO, ZERO), /* 1/(2pi) */
			 swizzle(consts0, W, ZERO, ZERO, ZERO)); /* .75 */
d303 6
a308 1
         i915_emit_arith(p, A0_FRC, tmp, A0_DEST_CHANNEL_X, 0, tmp, 0, 0);
d310 2
a311 2
	 i915_emit_arith(p,
			 A0_MAD,
d313 2
a314 3
			 tmp,
			 swizzle(consts0, X, ZERO, ZERO, ZERO), /* 2 */
			 swizzle(consts0, Y, ZERO, ZERO, ZERO)); /* -1 */
d316 1
a316 2
	 /* Compute COS with the same calculation used for SIN, but a
	  * different source range has been mapped to [-1,1] this time.
d318 6
d325 17
a341 7
	 /* tmp.y = abs(tmp.x); {x, abs(x), 0, 0} */
	 i915_emit_arith(p,
                         A0_MAX,
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 negate(swizzle(tmp, ZERO, X, ZERO, ZERO), 0, 1, 0, 0),
			 0);
d343 1
a343 2
	 /* tmp.y = tmp.y * tmp.x; {x, x * abs(x), 0, 0} */
	 i915_emit_arith(p,
d345 10
a354 4
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 tmp,
			 0);
d356 1
a356 7
	 /* tmp.x = tmp.xy DP sin_quad_constants[2].xy */
         i915_emit_arith(p,
                         A0_DP3,
                         tmp, A0_DEST_CHANNEL_X, 0,
			 tmp,
                         swizzle(consts1, X, Y, ZERO, ZERO),
			 0);
d358 3
a360 9
	 /* tmp.x now contains a first approximation (y).  Now, weight it
	  * against tmp.y**2 to get closer.
	  */
	 i915_emit_arith(p,
                         A0_MAX,
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 negate(swizzle(tmp, ZERO, X, ZERO, ZERO), 0, 1, 0, 0),
			 0);
d362 3
a364 7
	 /* tmp.y = tmp.x * tmp.y - tmp.x; {y, y * abs(y) - y, 0, 0} */
	 i915_emit_arith(p,
			 A0_MAD,
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 swizzle(tmp, ZERO, Y, ZERO, ZERO),
			 negate(swizzle(tmp, ZERO, X, ZERO, ZERO), 0, 1, 0, 0));
d366 10
a375 9
	 /* result = .2225 * tmp.y + tmp.x =.2225(y * abs(y) - y) + y= */
	 i915_emit_arith(p,
			 A0_MAD,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
			 swizzle(consts1, W, W, W, W),
			 swizzle(tmp, Y, Y, Y, Y),
			 swizzle(tmp, X, X, X, X));
         break;
d377 15
a391 9
      case OPCODE_DP2:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);
	 i915_emit_arith(p,
			 A0_DP3,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
			 swizzle(src0, X, Y, ZERO, ZERO),
			 swizzle(src1, X, Y, ZERO, ZERO),
d393 1
a393 1
         break;
d395 2
a396 3
      case OPCODE_DP3:
         EMIT_2ARG_ARITH(A0_DP3);
         break;
d398 6
a403 3
      case OPCODE_DP4:
         EMIT_2ARG_ARITH(A0_DP4);
         break;
d405 3
a407 10
      case OPCODE_DPH:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);

         i915_emit_arith(p,
                         A0_DP4,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         swizzle(src0, X, Y, Z, ONE), src1, 0);
         break;
d409 3
a411 16
      case OPCODE_DST:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);

         /* result[0] = 1    * 1;
          * result[1] = a[1] * b[1];
          * result[2] = a[2] * 1;
          * result[3] = 1    * b[3];
          */
         i915_emit_arith(p,
                         A0_MUL,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         swizzle(src0, ONE, Y, Z, ONE),
                         swizzle(src1, ONE, Y, ONE, W), 0);
         break;
d413 3
a415 2
      case OPCODE_EX2:
         src0 = src_vector(p, &inst->SrcReg[0], program);
d417 6
a422 6
         i915_emit_arith(p,
                         A0_EXP,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         swizzle(src0, X, X, X, X), 0, 0);
         break;
d424 2
a425 3
      case OPCODE_FLR:
         EMIT_1ARG_ARITH(A0_FLR);
         break;
d427 5
a431 2
      case OPCODE_TRUNC:
	 EMIT_1ARG_ARITH(A0_TRC);
d434 16
a449 3
      case OPCODE_FRC:
         EMIT_1ARG_ARITH(A0_FRC);
         break;
d451 3
a453 3
      case OPCODE_KIL:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         tmp = i915_get_utemp(p);
d455 2
a456 4
         i915_emit_texld(p, get_live_regs(p, inst),
                         tmp, A0_DEST_CHANNEL_ALL,   /* use a dummy dest reg */
                         0, src0, T0_TEXKILL);
         break;
d458 7
a464 18
      case OPCODE_KIL_NV:
	 if (inst->DstReg.CondMask == COND_TR) {
	    tmp = i915_get_utemp(p);

	    /* The KIL instruction discards the fragment if any component of
	     * the source is < 0.  Emit an immediate operand of {-1}.xywz.
	     */
	    i915_emit_texld(p, get_live_regs(p, inst),
			    tmp, A0_DEST_CHANNEL_ALL,
			    0, /* use a dummy dest reg */
			    negate(swizzle(tmp, ONE, ONE, ONE, ONE),
				   1, 1, 1, 1),
			    T0_TEXKILL);
	 } else {
	    p->error = 1;
	    i915_program_error(p, "Unsupported KIL_NV condition code: %d",
			       inst->DstReg.CondMask);
	 }
d467 6
a472 2
      case OPCODE_LG2:
         src0 = src_vector(p, &inst->SrcReg[0], program);
d474 16
a489 6
         i915_emit_arith(p,
                         A0_LOG,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         swizzle(src0, X, X, X, X), 0, 0);
         break;
d491 3
a493 30
      case OPCODE_LIT:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         tmp = i915_get_utemp(p);

         /* tmp = max( a.xyzw, a.00zw )
          * XXX: Clamp tmp.w to -128..128
          * tmp.y = log(tmp.y)
          * tmp.y = tmp.w * tmp.y
          * tmp.y = exp(tmp.y)
          * result = cmp (a.11-x1, a.1x01, a.1xy1 )
          */
         i915_emit_arith(p, A0_MAX, tmp, A0_DEST_CHANNEL_ALL, 0,
                         src0, swizzle(src0, ZERO, ZERO, Z, W), 0);

         i915_emit_arith(p, A0_LOG, tmp, A0_DEST_CHANNEL_Y, 0,
                         swizzle(tmp, Y, Y, Y, Y), 0, 0);

         i915_emit_arith(p, A0_MUL, tmp, A0_DEST_CHANNEL_Y, 0,
                         swizzle(tmp, ZERO, Y, ZERO, ZERO),
                         swizzle(tmp, ZERO, W, ZERO, ZERO), 0);

         i915_emit_arith(p, A0_EXP, tmp, A0_DEST_CHANNEL_Y, 0,
                         swizzle(tmp, Y, Y, Y, Y), 0, 0);

         i915_emit_arith(p, A0_CMP,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         negate(swizzle(tmp, ONE, ONE, X, ONE), 0, 0, 1, 0),
                         swizzle(tmp, ONE, X, ZERO, ONE),
                         swizzle(tmp, ONE, X, Y, ONE));
d495 3
a497 1
         break;
d499 18
a516 21
      case OPCODE_LRP:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);
         src2 = src_vector(p, &inst->SrcReg[2], program);
         flags = get_result_flags(inst);
         tmp = i915_get_utemp(p);

         /* b*a + c*(1-a)
          *
          * b*a + c - ca 
          *
          * tmp = b*a + c, 
          * result = (-c)*a + tmp 
          */
         i915_emit_arith(p, A0_MAD, tmp,
                         flags & A0_DEST_CHANNEL_ALL, 0, src1, src0, src2);

         i915_emit_arith(p, A0_MAD,
                         get_result_vector(p, inst),
                         flags, 0, negate(src2, 1, 1, 1, 1), src0, tmp);
         break;
d518 3
a520 3
      case OPCODE_MAD:
         EMIT_3ARG_ARITH(A0_MAD);
         break;
d522 3
a524 3
      case OPCODE_MAX:
         EMIT_2ARG_ARITH(A0_MAX);
         break;
d526 5
a530 17
      case OPCODE_MIN:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);
         tmp = i915_get_utemp(p);
         flags = get_result_flags(inst);

         i915_emit_arith(p,
                         A0_MAX,
                         tmp, flags & A0_DEST_CHANNEL_ALL, 0,
                         negate(src0, 1, 1, 1, 1),
                         negate(src1, 1, 1, 1, 1), 0);

         i915_emit_arith(p,
                         A0_MOV,
                         get_result_vector(p, inst),
                         flags, 0, negate(tmp, 1, 1, 1, 1), 0, 0);
         break;
d532 6
a537 3
      case OPCODE_MOV:
         EMIT_1ARG_ARITH(A0_MOV);
         break;
d539 4
a542 3
      case OPCODE_MUL:
         EMIT_2ARG_ARITH(A0_MUL);
         break;
a543 20
      case OPCODE_POW:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);
         tmp = i915_get_utemp(p);
         flags = get_result_flags(inst);

         /* XXX: masking on intermediate values, here and elsewhere.
          */
         i915_emit_arith(p,
                         A0_LOG,
                         tmp, A0_DEST_CHANNEL_X, 0,
                         swizzle(src0, X, X, X, X), 0, 0);

         i915_emit_arith(p, A0_MUL, tmp, A0_DEST_CHANNEL_X, 0, tmp, src1, 0);


         i915_emit_arith(p,
                         A0_EXP,
                         get_result_vector(p, inst),
                         flags, 0, swizzle(tmp, X, X, X, X), 0, 0);
d545 5
a549 1
         break;
d551 1
a551 2
      case OPCODE_RCP:
         src0 = src_vector(p, &inst->SrcReg[0], program);
d553 2
a554 6
         i915_emit_arith(p,
                         A0_RCP,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         swizzle(src0, X, X, X, X), 0, 0);
         break;
d556 6
a561 1
      case OPCODE_RSQ:
d563 1
a563 1
         src0 = src_vector(p, &inst->SrcReg[0], program);
d565 1
a565 6
         i915_emit_arith(p,
                         A0_RSQ,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         swizzle(src0, X, X, X, X), 0, 0);
         break;
d567 7
d575 2
a576 2
         src0 = src_vector(p, &inst->SrcReg[0], program);
         tmp = i915_get_utemp(p);
d578 13
a590 57
         /* 
          * t0.xy = MUL x.xx11, x.x1111  ; x^2, x, 1, 1
          * t0 = MUL t0.xyxy t0.xx11 ; x^4, x^3, x^2, x
          * t1 = MUL t0.xyyw t0.yz11    ; x^7 x^5 x^3 x
          * scs.x = DP4 t1, sin_constants
          * t1 = MUL t0.xxz1 t0.z111    ; x^6 x^4 x^2 1
          * scs.y = DP4 t1, cos_constants
          */
         i915_emit_arith(p,
                         A0_MUL,
                         tmp, A0_DEST_CHANNEL_XY, 0,
                         swizzle(src0, X, X, ONE, ONE),
                         swizzle(src0, X, ONE, ONE, ONE), 0);

         i915_emit_arith(p,
                         A0_MUL,
                         tmp, A0_DEST_CHANNEL_ALL, 0,
                         swizzle(tmp, X, Y, X, Y),
                         swizzle(tmp, X, X, ONE, ONE), 0);

         if (inst->DstReg.WriteMask & WRITEMASK_Y) {
            GLuint tmp1;

            if (inst->DstReg.WriteMask & WRITEMASK_X)
               tmp1 = i915_get_utemp(p);
            else
               tmp1 = tmp;

            i915_emit_arith(p,
                            A0_MUL,
                            tmp1, A0_DEST_CHANNEL_ALL, 0,
                            swizzle(tmp, X, Y, Y, W),
                            swizzle(tmp, X, Z, ONE, ONE), 0);

            i915_emit_arith(p,
                            A0_DP4,
                            get_result_vector(p, inst),
                            A0_DEST_CHANNEL_Y, 0,
                            swizzle(tmp1, W, Z, Y, X),
                            i915_emit_const4fv(p, sin_constants), 0);
         }

         if (inst->DstReg.WriteMask & WRITEMASK_X) {
            i915_emit_arith(p,
                            A0_MUL,
                            tmp, A0_DEST_CHANNEL_XYZ, 0,
                            swizzle(tmp, X, X, Z, ONE),
                            swizzle(tmp, Z, ONE, ONE, ONE), 0);

            i915_emit_arith(p,
                            A0_DP4,
                            get_result_vector(p, inst),
                            A0_DEST_CHANNEL_X, 0,
                            swizzle(tmp, ONE, Z, Y, X),
                            i915_emit_const4fv(p, cos_constants), 0);
         }
         break;
d592 1
a592 25
      case OPCODE_SEQ:
	 tmp = i915_get_utemp(p);
	 flags = get_result_flags(inst);
	 dst = get_result_vector(p, inst);

	 /* tmp = src1 >= src2 */
	 i915_emit_arith(p,
			 A0_SGE,
			 tmp,
			 flags, 0,
			 src_vector(p, &inst->SrcReg[0], program),
			 src_vector(p, &inst->SrcReg[1], program),
			 0);
	 /* dst = src1 <= src2 */
	 i915_emit_arith(p,
			 A0_SGE,
			 dst,
			 flags, 0,
			 negate(src_vector(p, &inst->SrcReg[0], program),
				1, 1, 1, 1),
			 negate(src_vector(p, &inst->SrcReg[1], program),
				1, 1, 1, 1),
			 0);
	 /* dst = tmp && dst */
	 i915_emit_arith(p,
d594 44
a637 5
			 dst,
			 flags, 0,
			 dst,
			 tmp,
			 0);
d641 2
a642 12
         src0 = src_vector(p, &inst->SrcReg[0], program);
         tmp = i915_get_utemp(p);
	 consts0 = i915_emit_const4fv(p, sin_quad_constants[0]);
	 consts1 = i915_emit_const4fv(p, sin_quad_constants[1]);

	 /* Reduce range from repeating about [-pi,pi] to [-1,1] */
         i915_emit_arith(p,
                         A0_MAD,
                         tmp, A0_DEST_CHANNEL_X, 0,
                         src0,
			 swizzle(consts1, Z, ZERO, ZERO, ZERO), /* 1/(2pi) */
			 swizzle(consts0, Z, ZERO, ZERO, ZERO)); /* .5 */
d644 6
a649 1
         i915_emit_arith(p, A0_FRC, tmp, A0_DEST_CHANNEL_X, 0, tmp, 0, 0);
d651 2
a652 2
	 i915_emit_arith(p,
			 A0_MAD,
d654 4
a657 10
			 tmp,
			 swizzle(consts0, X, ZERO, ZERO, ZERO), /* 2 */
			 swizzle(consts0, Y, ZERO, ZERO, ZERO)); /* -1 */

	 /* Compute sin using a quadratic and quartic.  It gives continuity
	  * that repeating the Taylor series lacks every 2*pi, and has
	  * reduced error.
	  *
	  * The idea was described at:
	  * http://www.devmaster.net/forums/showthread.php?t=5784
d659 1
a659 11

	 /* tmp.y = abs(tmp.x); {x, abs(x), 0, 0} */
	 i915_emit_arith(p,
                         A0_MAX,
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 negate(swizzle(tmp, ZERO, X, ZERO, ZERO), 0, 1, 0, 0),
			 0);

	 /* tmp.y = tmp.y * tmp.x; {x, x * abs(x), 0, 0} */
	 i915_emit_arith(p,
d661 3
a663 11
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 tmp,
			 0);

	 /* tmp.x = tmp.xy DP sin_quad_constants[2].xy */
         i915_emit_arith(p,
                         A0_DP3,
                         tmp, A0_DEST_CHANNEL_X, 0,
			 tmp,
                         swizzle(consts1, X, Y, ZERO, ZERO),
d666 5
a670 2
	 /* tmp.x now contains a first approximation (y).  Now, weight it
	  * against tmp.y**2 to get closer.
d672 5
a676 6
	 i915_emit_arith(p,
                         A0_MAX,
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 negate(swizzle(tmp, ZERO, X, ZERO, ZERO), 0, 1, 0, 0),
			 0);
d678 5
a682 7
	 /* tmp.y = tmp.x * tmp.y - tmp.x; {y, y * abs(y) - y, 0, 0} */
	 i915_emit_arith(p,
			 A0_MAD,
			 tmp, A0_DEST_CHANNEL_Y, 0,
			 swizzle(tmp, ZERO, X, ZERO, ZERO),
			 swizzle(tmp, ZERO, Y, ZERO, ZERO),
			 negate(swizzle(tmp, ZERO, X, ZERO, ZERO), 0, 1, 0, 0));
d684 13
a696 8
	 /* result = .2225 * tmp.y + tmp.x =.2225(y * abs(y) - y) + y= */
	 i915_emit_arith(p,
			 A0_MAD,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
			 swizzle(consts1, W, W, W, W),
			 swizzle(tmp, Y, Y, Y, Y),
			 swizzle(tmp, X, X, X, X));
d698 2
a699 4
         break;

      case OPCODE_SGE:
	 EMIT_2ARG_ARITH(A0_SGE);
d702 3
a704 11
      case OPCODE_SGT:
	 i915_emit_arith(p,
			 A0_SLT,
			 get_result_vector( p, inst ),
			 get_result_flags( inst ), 0,
			 negate(src_vector( p, &inst->SrcReg[0], program),
				1, 1, 1, 1),
			 negate(src_vector( p, &inst->SrcReg[1], program),
				1, 1, 1, 1),
			 0);
         break;
d706 3
a708 4
      case OPCODE_SLE:
	 i915_emit_arith(p,
			 A0_SGE,
			 get_result_vector( p, inst ),
d710 2
a711 6
			 negate(src_vector( p, &inst->SrcReg[0], program),
				1, 1, 1, 1),
			 negate(src_vector( p, &inst->SrcReg[1], program),
				1, 1, 1, 1),
			 0);
         break;
d713 3
a715 3
      case OPCODE_SLT:
         EMIT_2ARG_ARITH(A0_SLT);
         break;
d717 3
a719 86
      case OPCODE_SNE:
	 tmp = i915_get_utemp(p);
	 flags = get_result_flags(inst);
	 dst = get_result_vector(p, inst);

	 /* tmp = src1 < src2 */
	 i915_emit_arith(p,
			 A0_SLT,
			 tmp,
			 flags, 0,
			 src_vector(p, &inst->SrcReg[0], program),
			 src_vector(p, &inst->SrcReg[1], program),
			 0);
	 /* dst = src1 > src2 */
	 i915_emit_arith(p,
			 A0_SLT,
			 dst,
			 flags, 0,
			 negate(src_vector(p, &inst->SrcReg[0], program),
				1, 1, 1, 1),
			 negate(src_vector(p, &inst->SrcReg[1], program),
				1, 1, 1, 1),
			 0);
	 /* dst = tmp || dst */
	 i915_emit_arith(p,
			 A0_ADD,
			 dst,
			 flags | A0_DEST_SATURATE, 0,
			 dst,
			 tmp,
			 0);
         break;

      case OPCODE_SSG:
	 dst = get_result_vector(p, inst);
	 flags = get_result_flags(inst);
         src0 = src_vector(p, &inst->SrcReg[0], program);
	 tmp = i915_get_utemp(p);

	 /* tmp = (src < 0.0) */
	 i915_emit_arith(p,
			 A0_SLT,
			 tmp,
			 flags, 0,
			 src0,
			 swizzle(src0, ZERO, ZERO, ZERO, ZERO),
			 0);

	 /* dst = (0.0 < src) */
	 i915_emit_arith(p,
			 A0_SLT,
			 dst,
			 flags, 0,
			 swizzle(src0, ZERO, ZERO, ZERO, ZERO),
			 src0,
			 0);

	 /* dst = (src > 0.0) - (src < 0.0) */
	 i915_emit_arith(p,
			 A0_ADD,
			 dst,
			 flags, 0,
			 dst,
			 negate(tmp, 1, 1, 1, 1),
			 0);

         break;

      case OPCODE_SUB:
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);

         i915_emit_arith(p,
                         A0_ADD,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         src0, negate(src1, 1, 1, 1, 1), 0);
         break;

      case OPCODE_SWZ:
         EMIT_1ARG_ARITH(A0_MOV);       /* extended swizzle handled natively */
         break;

      case OPCODE_TEX:
         EMIT_TEX(T0_TEXLD);
         break;
d722 2
a723 2
         EMIT_TEX(T0_TEXLDB);
         break;
d726 2
a727 2
         EMIT_TEX(T0_TEXLDP);
         break;
d730 24
a753 24
         /* Cross product:
          *      result.x = src0.y * src1.z - src0.z * src1.y;
          *      result.y = src0.z * src1.x - src0.x * src1.z;
          *      result.z = src0.x * src1.y - src0.y * src1.x;
          *      result.w = undef;
          */
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);
         tmp = i915_get_utemp(p);

         i915_emit_arith(p,
                         A0_MUL,
                         tmp, A0_DEST_CHANNEL_ALL, 0,
                         swizzle(src0, Z, X, Y, ONE),
                         swizzle(src1, Y, Z, X, ONE), 0);

         i915_emit_arith(p,
                         A0_MAD,
                         get_result_vector(p, inst),
                         get_result_flags(inst), 0,
                         swizzle(src0, Y, Z, X, ONE),
                         swizzle(src1, Z, X, Y, ONE),
                         negate(tmp, 1, 1, 1, 0));
         break;
a755 19
         return;

      case OPCODE_BGNLOOP:
      case OPCODE_BGNSUB:
      case OPCODE_BRA:
      case OPCODE_BRK:
      case OPCODE_CAL:
      case OPCODE_CONT:
      case OPCODE_DDX:
      case OPCODE_DDY:
      case OPCODE_ELSE:
      case OPCODE_ENDIF:
      case OPCODE_ENDLOOP:
      case OPCODE_ENDSUB:
      case OPCODE_IF:
      case OPCODE_RET:
	 p->error = 1;
	 i915_program_error(p, "Unsupported opcode: %s",
			    _mesa_opcode_string(inst->Opcode));
d757 1
a757 12

      case OPCODE_EXP:
      case OPCODE_LOG:
	 /* These opcodes are claimed as GLSL, NV_vp, and ARB_vp in
	  * prog_instruction.h, but apparently GLSL doesn't ever emit them.
	  * Instead, it translates to EX2 or LG2.
	  */
      case OPCODE_TXD:
      case OPCODE_TXL:
	 /* These opcodes are claimed by GLSL in prog_instruction.h, but
	  * only NV_vp/fp appears to emit them.
	  */
d759 2
a760 3
         i915_program_error(p, "bad opcode: %s",
			    _mesa_opcode_string(inst->Opcode));
         return;
d764 1
a764 1
      i915_release_utemps(p);
d772 1
a772 2
static void
fixup_depth_write(struct i915_fragment_program *p)
d777 5
a781 4
      i915_emit_arith(p,
                      A0_MOV,
                      depth, A0_DEST_CHANNEL_W, 0,
                      swizzle(depth, X, Y, Z, Z), 0, 0);
d786 1
a786 2
static void
check_wpos(struct i915_fragment_program *p)
d794 2
a795 2
      if (inputs & (FRAG_BIT_TEX(i) | FRAG_BIT_VAR(i)))
         continue;
d797 3
a799 3
         p->wpos_tex = i;
         inputs &= ~FRAG_BIT_WPOS;
      }
d808 1
a808 2
static void
translate_program(struct i915_fragment_program *p)
d810 8
a817 19
   struct i915_context *i915 = I915_CONTEXT(p->ctx);

   if (INTEL_DEBUG & DEBUG_WM) {
      printf("fp:\n");
      _mesa_print_program(&p->ctx->FragmentProgram._Current->Base);
      printf("\n");
   }

   i915_init_program(i915, p);
   check_wpos(p);
   upload_program(p);
   fixup_depth_write(p);
   i915_fini_program(p);

   if (INTEL_DEBUG & DEBUG_WM) {
      printf("i915:\n");
      i915_disassemble_program(i915->state.Program, i915->state.ProgramSize);
   }

d822 1
a822 2
static void
track_params(struct i915_fragment_program *p)
d827 1
a827 1
      _mesa_load_state_parameters(p->ctx, p->FragProg.Base.Parameters);
d831 1
a831 1
      COPY_4V(p->constant[reg], p->param[i].values);
d833 1
a833 1

d835 1
a835 1
   p->on_hardware = 0;          /* overkill */
d839 3
a841 2
static void
i915BindProgram(struct gl_context * ctx, GLenum target, struct gl_program *prog)
d844 2
a845 5
      struct i915_context *i915 = I915_CONTEXT(ctx);
      struct i915_fragment_program *p = (struct i915_fragment_program *) prog;

      if (i915->current_program == p)
         return;
d847 3
d851 2
a852 2
         i915->current_program->on_hardware = 0;
         i915->current_program->params_uptodate = 0;
d854 1
a854 1

d860 5
d868 3
a870 2
static struct gl_program *
i915NewProgram(struct gl_context * ctx, GLenum target, GLuint id)
d874 2
a875 2
      return _mesa_init_vertex_program(ctx, CALLOC_STRUCT(gl_vertex_program),
                                       target, id);
d877 7
a883 11
   case GL_FRAGMENT_PROGRAM_ARB:{
         struct i915_fragment_program *prog =
            CALLOC_STRUCT(i915_fragment_program);
         if (prog) {
            i915_init_program(I915_CONTEXT(ctx), prog);

            return _mesa_init_fragment_program(ctx, &prog->FragProg,
                                               target, id);
         }
         else
            return NULL;
d885 3
d892 1
a892 1
      return _mesa_new_program(ctx, target, id);
d896 2
a897 2
static void
i915DeleteProgram(struct gl_context * ctx, struct gl_program *prog)
d900 5
a904 5
      struct i915_context *i915 = I915_CONTEXT(ctx);
      struct i915_fragment_program *p = (struct i915_fragment_program *) prog;

      if (i915->current_program == p)
         i915->current_program = 0;
d907 1
a907 1
   _mesa_delete_program(ctx, prog);
d911 3
a913 2
static GLboolean
i915IsProgramNative(struct gl_context * ctx, GLenum target, struct gl_program *prog)
d916 1
a916 1
      struct i915_fragment_program *p = (struct i915_fragment_program *) prog;
d919 2
a920 2
         translate_program(p);

d927 3
a929 3
static GLboolean
i915ProgramStringNotify(struct gl_context * ctx,
                        GLenum target, struct gl_program *prog)
d932 1
a932 1
      struct i915_fragment_program *p = (struct i915_fragment_program *) prog;
d938 3
d948 1
a948 4
   (void) _tnl_program_string(ctx, target, prog);

   /* XXX check if program is legal, within limits */
   return GL_TRUE;
a950 7
void
i915_update_program(struct gl_context *ctx)
{
   struct intel_context *intel = intel_context(ctx);
   struct i915_context *i915 = i915_context(&intel->ctx);
   struct i915_fragment_program *fp =
      (struct i915_fragment_program *) ctx->FragmentProgram._Current;
d952 1
a952 17
   if (i915->current_program != fp) {
      if (i915->current_program) {
         i915->current_program->on_hardware = 0;
         i915->current_program->params_uptodate = 0;
      }

      i915->current_program = fp;
   }

   if (!fp->translated)
      translate_program(fp);

   FALLBACK(&i915->intel, I915_FALLBACK_PROGRAM, fp->error);
}

void
i915ValidateFragmentProgram(struct i915_context *i915)
d954 2
a955 2
   struct gl_context *ctx = &i915->intel.ctx;
   struct intel_context *intel = intel_context(ctx);
d959 2
a960 2
   struct i915_fragment_program *p =
      (struct i915_fragment_program *) ctx->FragmentProgram._Current;
d967 11
d982 2
a983 2
   if (!p->translated)
      translate_program(p);
d992 1
a992 1
      EMIT_ATTR(_TNL_ATTRIB_POS, EMIT_4F_VIEWPORT, S4_VFMT_XYZW, 16);
d995 1
a995 1
      EMIT_ATTR(_TNL_ATTRIB_POS, EMIT_3F_VIEWPORT, S4_VFMT_XYZ, 12);
d1000 1
a1000 1
      EMIT_ATTR(_TNL_ATTRIB_COLOR0, EMIT_4UB_4F_BGRA, S4_VFMT_COLOR, 4);
d1002 10
d1013 4
a1016 3
   if (inputsRead & FRAG_BIT_COL1) {
       intel->specoffset = offset / 4;
       EMIT_ATTR(_TNL_ATTRIB_COLOR1, EMIT_4UB_4F_BGRA, S4_VFMT_SPEC_FOG, 4);
d1019 4
d1024 1
a1024 1
      EMIT_ATTR(_TNL_ATTRIB_FOG, EMIT_1F, S4_VFMT_FOG_PARAM, 4);
d1026 1
d1030 4
a1033 1
         int sz = VB->AttribPtr[_TNL_ATTRIB_TEX0 + i]->size;
d1035 1
a1035 12
         s2 &= ~S2_TEXCOORD_FMT(i, S2_TEXCOORD_FMT0_MASK);
         s2 |= S2_TEXCOORD_FMT(i, SZ_TO_HW(sz));

         EMIT_ATTR(_TNL_ATTRIB_TEX0 + i, EMIT_SZ(sz), 0, sz * 4);
      }
      else if (inputsRead & FRAG_BIT_VAR(i)) {
         int sz = VB->AttribPtr[_TNL_ATTRIB_GENERIC0 + i]->size;

         s2 &= ~S2_TEXCOORD_FMT(i, S2_TEXCOORD_FMT0_MASK);
         s2 |= S2_TEXCOORD_FMT(i, SZ_TO_HW(sz));

         EMIT_ATTR(_TNL_ATTRIB_GENERIC0 + i, EMIT_SZ(sz), 0, sz * 4);
d1038 6
d1045 2
a1046 8
         /* If WPOS is required, duplicate the XYZ position data in an
          * unused texture coordinate:
          */
         s2 &= ~S2_TEXCOORD_FMT(i, S2_TEXCOORD_FMT0_MASK);
         s2 |= S2_TEXCOORD_FMT(i, SZ_TO_HW(3));

         intel->wpos_offset = offset;
         intel->wpos_size = 3 * sizeof(GLuint);
d1048 2
a1049 2
         EMIT_PAD(intel->wpos_size);
      }
d1054 2
a1055 3
      int k;

      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
d1060 4
a1063 4
      intel->vertex_size = _tnl_install_attrs(&intel->ctx,
                                              intel->vertex_attrs,
                                              intel->vertex_attr_count,
                                              intel->ViewportMatrix.m, 0);
d1070 1
a1070 2
      k = intel->vtbl.check_vertex_size(intel, intel->vertex_size);
      assert(k);
d1073 2
a1074 2
   if (!p->params_uptodate)
      track_params(p);
d1076 2
a1077 2
   if (!p->on_hardware)
      i915_upload_program(i915, p);
d1080 1
a1080 2
void
i915InitFragProgFuncs(struct dd_function_table *functions)
@


1.1.1.5
log
@Import Mesa 9.2.0
@
text
@d100 1
a100 1
      case VARYING_SLOT_POS:
d103 1
a103 1
      case VARYING_SLOT_COL0:
d106 1
a106 1
      case VARYING_SLOT_COL1:
d110 1
a110 1
      case VARYING_SLOT_FOGC:
d114 8
a121 8
      case VARYING_SLOT_TEX0:
      case VARYING_SLOT_TEX1:
      case VARYING_SLOT_TEX2:
      case VARYING_SLOT_TEX3:
      case VARYING_SLOT_TEX4:
      case VARYING_SLOT_TEX5:
      case VARYING_SLOT_TEX6:
      case VARYING_SLOT_TEX7:
d123 1
a123 1
                              T_TEX0 + (source->Index - VARYING_SLOT_TEX0),
d127 8
a134 8
      case VARYING_SLOT_VAR0:
      case VARYING_SLOT_VAR0 + 1:
      case VARYING_SLOT_VAR0 + 2:
      case VARYING_SLOT_VAR0 + 3:
      case VARYING_SLOT_VAR0 + 4:
      case VARYING_SLOT_VAR0 + 5:
      case VARYING_SLOT_VAR0 + 6:
      case VARYING_SLOT_VAR0 + 7:
d136 1
a136 1
                              T_TEX0 + (source->Index - VARYING_SLOT_VAR0),
d176 1
d178 4
a181 2
      src = i915_emit_param4fv(p,
	 &program->Base.Parameters->ParameterValues[source->Index][0].f);
a212 1
      case FRAG_RESULT_DATA0:
d272 1
a272 1
   const struct gl_fragment_program *program = &p->FragProg;	\
d305 1
a305 1
static bool calc_live_regs( struct i915_fragment_program *p )
d307 3
a309 3
    const struct gl_fragment_program *program = &p->FragProg;
    GLuint regsUsed = ~((1 << I915_MAX_TEMPORARY) - 1);
    uint8_t live_components[I915_MAX_TEMPORARY] = { 0, };
a318 3
	    if (inst->DstReg.Index >= I915_MAX_TEMPORARY)
	       return false;

a328 3
		if (inst->SrcReg[a].Index >= I915_MAX_TEMPORARY)
		   return false;

a341 2

    return true;
d347 1
a347 1
    const struct gl_fragment_program *program = &p->FragProg;
d368 2
a369 1
   const struct gl_fragment_program *program = &p->FragProg;
d397 1
a397 4
   if (!calc_live_regs(p)) {
      i915_program_error(p, "Could not allocate registers");
      return;
   }
d1082 1
d1142 1
a1142 1
   GLbitfield64 inputs = p->FragProg.Base.InputsRead;
d1148 1
a1148 1
      if (inputs & (VARYING_BIT_TEX(i) | VARYING_BIT_VAR(i)))
d1150 1
a1150 1
      else if (inputs & VARYING_BIT_POS) {
d1152 1
a1152 1
         inputs &= ~VARYING_BIT_POS;
d1156 1
a1156 1
   if (inputs & VARYING_BIT_POS) {
d1169 1
a1169 1
      _mesa_print_program(&p->FragProg.Base);
d1179 5
d1284 1
a1284 1
      return true;
d1294 9
d1308 1
a1308 8
   return true;
}

static void
i915SamplerUniformChange(struct gl_context *ctx,
                         GLenum target, struct gl_program *prog)
{
   i915ProgramStringNotify(ctx, target, prog);
d1345 1
a1345 1
   const GLbitfield64 inputsRead = p->FragProg.Base.InputsRead;
d1359 1
d1363 1
a1363 1
   if (inputsRead & VARYING_BITS_TEX_ANY || p->wpos_tex != -1) {
d1370 1
a1370 5
   /* Handle gl_PointSize builtin var here */
   if (ctx->Point._Attenuated || ctx->VertexProgram.PointSizeEnabled)
      EMIT_ATTR(_TNL_ATTRIB_POINTSIZE, EMIT_1F, S4_VFMT_POINT_WIDTH, 4);

   if (inputsRead & VARYING_BIT_COL0) {
d1375 1
a1375 1
   if (inputsRead & VARYING_BIT_COL1) {
d1380 1
a1380 1
   if ((inputsRead & VARYING_BIT_FOGC)) {
d1385 1
a1385 1
      if (inputsRead & VARYING_BIT_TEX(i)) {
d1393 1
a1393 1
      else if (inputsRead & VARYING_BIT_VAR(i)) {
d1402 1
a1402 1
	 int wpos_size = 4 * sizeof(float);
d1407 1
a1407 1
         s2 |= S2_TEXCOORD_FMT(i, SZ_TO_HW(wpos_size));
d1410 3
a1412 1
         EMIT_PAD(wpos_size);
a1429 4
      assert(intel->prim.current_offset == intel->prim.start_offset);
      intel->prim.start_offset = (intel->prim.current_offset + intel->vertex_size-1) / intel->vertex_size * intel->vertex_size;
      intel->prim.current_offset = intel->prim.start_offset;

a1443 5

   if (INTEL_DEBUG & DEBUG_WM) {
      printf("i915:\n");
      i915_disassemble_program(i915->state.Program, i915->state.ProgramSize);
   }
a1453 1
   functions->SamplerUniformChange = i915SamplerUniformChange;
@


1.1.1.6
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 * Copyright 2003 VMware, Inc.
d21 1
a21 1
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
a148 1
      case FRAG_RESULT_DATA0:
d163 11
a819 31
         /* If both operands are uniforms or constants, we get 5 instructions
          * like:
          *
          *     U[1] = MOV CONST[1]
          *     U[0].xyz = SGE CONST[0].xxxx, U[1]
          *     U[1] = MOV CONST[1].-x-y-z-w
          *     R[0].xyz = SGE CONST[0].-x-x-x-x, U[1]
          *     R[0].xyz = MUL R[0], U[0]
          *
          * This code is stupid.  Instead of having the individual calls to
          * i915_emit_arith generate the moves to utemps, do it in the caller.
          * This results in code like:
          *
          *     U[1] = MOV CONST[1]
          *     U[0].xyz = SGE CONST[0].xxxx, U[1]
          *     R[0].xyz = SGE CONST[0].-x-x-x-x, U[1].-x-y-z-w
          *     R[0].xyz = MUL R[0], U[0]
          */
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);

         if (GET_UREG_TYPE(src0) == REG_TYPE_CONST
             && GET_UREG_TYPE(src1) == REG_TYPE_CONST) {
            unsigned tmp = i915_get_utemp(p);

            i915_emit_arith(p, A0_MOV, tmp, A0_DEST_CHANNEL_ALL, 0,
                            src1, 0, 0);

            src1 = tmp;
         }

d825 2
a826 2
			 src0,
			 src1,
d833 4
a836 2
			 negate(src0, 1, 1, 1, 1),
			 negate(src1, 1, 1, 1, 1),
a968 31
         /* If both operands are uniforms or constants, we get 5 instructions
          * like:
          *
          *     U[1] = MOV CONST[1]
          *     U[0].xyz = SLT CONST[0].xxxx, U[1]
          *     U[1] = MOV CONST[1].-x-y-z-w
          *     R[0].xyz = SLT CONST[0].-x-x-x-x, U[1]
          *     R[0].xyz = MUL R[0], U[0]
          *
          * This code is stupid.  Instead of having the individual calls to
          * i915_emit_arith generate the moves to utemps, do it in the caller.
          * This results in code like:
          *
          *     U[1] = MOV CONST[1]
          *     U[0].xyz = SLT CONST[0].xxxx, U[1]
          *     R[0].xyz = SLT CONST[0].-x-x-x-x, U[1].-x-y-z-w
          *     R[0].xyz = MUL R[0], U[0]
          */
         src0 = src_vector(p, &inst->SrcReg[0], program);
         src1 = src_vector(p, &inst->SrcReg[1], program);

         if (GET_UREG_TYPE(src0) == REG_TYPE_CONST
             && GET_UREG_TYPE(src1) == REG_TYPE_CONST) {
            unsigned tmp = i915_get_utemp(p);

            i915_emit_arith(p, A0_MOV, tmp, A0_DEST_CHANNEL_ALL, 0,
                            src1, 0, 0);

            src1 = tmp;
         }

d974 2
a975 2
			 src0,
			 src1,
d982 4
a985 2
			 negate(src0, 1, 1, 1, 1),
			 negate(src1, 1, 1, 1, 1),
@


