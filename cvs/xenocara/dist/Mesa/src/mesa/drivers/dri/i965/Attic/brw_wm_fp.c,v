head	1.8;
access;
symbols
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2013.09.05.14.04.22;	author jsg;	state dead;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.19;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.15;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.49;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.49;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.17;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.28.39;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.37;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge Mesa 9.2.0
@
text
@/*
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
 develop this 3D driver.
 
 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:
 
 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keith@@tungstengraphics.com>
  */
               

#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"
#include "brw_context.h"
#include "brw_wm.h"
#include "brw_util.h"

#include "program/prog_parameter.h"
#include "program/prog_print.h"
#include "program/prog_statevars.h"


/** An invalid texture target */
#define TEX_TARGET_NONE NUM_TEXTURE_TARGETS

/** An invalid texture unit */
#define TEX_UNIT_NONE BRW_MAX_TEX_UNIT

#define FIRST_INTERNAL_TEMP MAX_NV_FRAGMENT_PROGRAM_TEMPS

#define X    0
#define Y    1
#define Z    2
#define W    3


static const char *wm_opcode_strings[] = {   
   "PIXELXY",
   "DELTAXY",
   "PIXELW",
   "LINTERP",
   "PINTERP",
   "CINTERP",
   "WPOSXY",
   "FB_WRITE",
   "FRONTFACING",
};

#if 0
static const char *wm_file_strings[] = {   
   "PAYLOAD"
};
#endif


/***********************************************************************
 * Source regs
 */

static struct prog_src_register src_reg(GLuint file, GLuint idx)
{
   struct prog_src_register reg;
   reg.File = file;
   reg.Index = idx;
   reg.Swizzle = SWIZZLE_NOOP;
   reg.RelAddr = 0;
   reg.Negate = NEGATE_NONE;
   reg.Abs = 0;
   reg.HasIndex2 = 0;
   reg.RelAddr2 = 0;
   reg.Index2 = 0;
   return reg;
}

static struct prog_src_register src_reg_from_dst(struct prog_dst_register dst)
{
   return src_reg(dst.File, dst.Index);
}

static struct prog_src_register src_undef( void )
{
   return src_reg(PROGRAM_UNDEFINED, 0);
}

static GLboolean src_is_undef(struct prog_src_register src)
{
   return src.File == PROGRAM_UNDEFINED;
}

static struct prog_src_register src_swizzle( struct prog_src_register reg, int x, int y, int z, int w )
{
   reg.Swizzle = MAKE_SWIZZLE4(x,y,z,w);
   return reg;
}

static struct prog_src_register src_swizzle1( struct prog_src_register reg, int x )
{
   return src_swizzle(reg, x, x, x, x);
}

static struct prog_src_register src_swizzle4( struct prog_src_register reg, uint swizzle )
{
   reg.Swizzle = swizzle;
   return reg;
}


/***********************************************************************
 * Dest regs
 */

static struct prog_dst_register dst_reg(GLuint file, GLuint idx)
{
   struct prog_dst_register reg;
   reg.File = file;
   reg.Index = idx;
   reg.WriteMask = WRITEMASK_XYZW;
   reg.RelAddr = 0;
   reg.CondMask = COND_TR;
   reg.CondSwizzle = 0;
   reg.CondSrc = 0;
   return reg;
}

static struct prog_dst_register dst_mask( struct prog_dst_register reg, int mask )
{
   reg.WriteMask &= mask;
   return reg;
}

static struct prog_dst_register dst_undef( void )
{
   return dst_reg(PROGRAM_UNDEFINED, 0);
}



static struct prog_dst_register get_temp( struct brw_wm_compile *c )
{
   int bit = _mesa_ffs( ~c->fp_temp );

   if (!bit) {
      printf("%s: out of temporaries\n", __FILE__);
      exit(1);
   }

   c->fp_temp |= 1<<(bit-1);
   return dst_reg(PROGRAM_TEMPORARY, FIRST_INTERNAL_TEMP+(bit-1));
}


static void release_temp( struct brw_wm_compile *c, struct prog_dst_register temp )
{
   c->fp_temp &= ~(1 << (temp.Index - FIRST_INTERNAL_TEMP));
}


/***********************************************************************
 * Instructions 
 */

static struct prog_instruction *get_fp_inst(struct brw_wm_compile *c)
{
   assert(c->nr_fp_insns < BRW_WM_MAX_INSN);
   memset(&c->prog_instructions[c->nr_fp_insns], 0,
	  sizeof(*c->prog_instructions));
   return &c->prog_instructions[c->nr_fp_insns++];
}

static struct prog_instruction *emit_insn(struct brw_wm_compile *c,
					const struct prog_instruction *inst0)
{
   struct prog_instruction *inst = get_fp_inst(c);
   *inst = *inst0;
   return inst;
}

static struct prog_instruction * emit_tex_op(struct brw_wm_compile *c,
				       GLuint op,
				       struct prog_dst_register dest,
				       GLuint saturate,
				       GLuint tex_src_unit,
				       GLuint tex_src_target,
				       GLuint tex_shadow,
				       struct prog_src_register src0,
				       struct prog_src_register src1,
				       struct prog_src_register src2 )
{
   struct prog_instruction *inst = get_fp_inst(c);
      
   assert(tex_src_unit < BRW_MAX_TEX_UNIT ||
          tex_src_unit == TEX_UNIT_NONE);
   assert(tex_src_target < NUM_TEXTURE_TARGETS ||
          tex_src_target == TEX_TARGET_NONE);

   /* update mask of which texture units are referenced by this program */
   if (tex_src_unit != TEX_UNIT_NONE)
      c->fp->tex_units_used |= (1 << tex_src_unit);

   memset(inst, 0, sizeof(*inst));

   inst->Opcode = op;
   inst->DstReg = dest;
   inst->SaturateMode = saturate;   
   inst->TexSrcUnit = tex_src_unit;
   inst->TexSrcTarget = tex_src_target;
   inst->TexShadow = tex_shadow;
   inst->SrcReg[0] = src0;
   inst->SrcReg[1] = src1;
   inst->SrcReg[2] = src2;
   return inst;
}
   

static struct prog_instruction * emit_op(struct brw_wm_compile *c,
				       GLuint op,
				       struct prog_dst_register dest,
				       GLuint saturate,
				       struct prog_src_register src0,
				       struct prog_src_register src1,
				       struct prog_src_register src2 )
{
   return emit_tex_op(c, op, dest, saturate,
                      TEX_UNIT_NONE, TEX_TARGET_NONE, 0,  /* unit, tgt, shadow */
                      src0, src1, src2);
}


/* Many Mesa opcodes produce the same value across all the result channels.
 * We'd rather not have to support that splatting in the opcode implementations,
 * and brw_wm_pass*.c wants to optimize them out by shuffling references around
 * anyway.  We can easily get both by emitting the opcode to one channel, and
 * then MOVing it to the others, which brw_wm_pass*.c already understands.
 */
static struct prog_instruction *emit_scalar_insn(struct brw_wm_compile *c,
						 const struct prog_instruction *inst0)
{
   struct prog_instruction *inst;
   unsigned int dst_chan;
   unsigned int other_channel_mask;

   if (inst0->DstReg.WriteMask == 0)
      return NULL;

   dst_chan = _mesa_ffs(inst0->DstReg.WriteMask) - 1;
   inst = get_fp_inst(c);
   *inst = *inst0;
   inst->DstReg.WriteMask = 1 << dst_chan;

   other_channel_mask = inst0->DstReg.WriteMask & ~(1 << dst_chan);
   if (other_channel_mask != 0) {
      inst = emit_op(c,
		     OPCODE_MOV,
		     dst_mask(inst0->DstReg, other_channel_mask),
		     0,
		     src_swizzle1(src_reg_from_dst(inst0->DstReg), dst_chan),
		     src_undef(),
		     src_undef());
   }
   return inst;
}


/***********************************************************************
 * Special instructions for interpolation and other tasks
 */

static struct prog_src_register get_pixel_xy( struct brw_wm_compile *c )
{
   if (src_is_undef(c->pixel_xy)) {
      struct prog_dst_register pixel_xy = get_temp(c);
      struct prog_src_register payload_r0_depth = src_reg(PROGRAM_PAYLOAD, PAYLOAD_DEPTH);
      
      
      /* Emit the out calculations, and hold onto the results.  Use
       * two instructions as a temporary is required.
       */   
      /* pixel_xy.xy = PIXELXY payload[0];
       */
      emit_op(c,
	      WM_PIXELXY,
	      dst_mask(pixel_xy, WRITEMASK_XY),
	      0,
	      payload_r0_depth,
	      src_undef(),
	      src_undef());

      c->pixel_xy = src_reg_from_dst(pixel_xy);
   }

   return c->pixel_xy;
}

static struct prog_src_register get_delta_xy( struct brw_wm_compile *c )
{
   if (src_is_undef(c->delta_xy)) {
      struct prog_dst_register delta_xy = get_temp(c);
      struct prog_src_register pixel_xy = get_pixel_xy(c);
      struct prog_src_register payload_r0_depth = src_reg(PROGRAM_PAYLOAD, PAYLOAD_DEPTH);
      
      /* deltas.xy = DELTAXY pixel_xy, payload[0]
       */
      emit_op(c,
	      WM_DELTAXY,
	      dst_mask(delta_xy, WRITEMASK_XY),
	      0,
	      pixel_xy, 
	      payload_r0_depth,
	      src_undef());
      
      c->delta_xy = src_reg_from_dst(delta_xy);
   }

   return c->delta_xy;
}

static struct prog_src_register get_pixel_w( struct brw_wm_compile *c )
{
   /* This is called for producing 1/w in pre-gen6 interp.  for gen6,
    * the interp opcodes don't use this argument.  But to keep the
    * nr_args = 3 expectations of pinterp happy, just stuff delta_xy
    * into the slot.
    */
   if (c->func.brw->intel.gen >= 6)
      return c->delta_xy;

   if (src_is_undef(c->pixel_w)) {
      struct prog_dst_register pixel_w = get_temp(c);
      struct prog_src_register deltas = get_delta_xy(c);
      struct prog_src_register interp_wpos = src_reg(PROGRAM_PAYLOAD, FRAG_ATTRIB_WPOS);

      /* deltas.xyw = DELTAS2 deltas.xy, payload.interp_wpos.x
       */
      emit_op(c,
	      WM_PIXELW,
	      dst_mask(pixel_w, WRITEMASK_W),
	      0,
	      interp_wpos,
	      deltas, 
	      src_undef());
      

      c->pixel_w = src_reg_from_dst(pixel_w);
   }

   return c->pixel_w;
}

static void emit_interp( struct brw_wm_compile *c,
			 GLuint idx )
{
   struct prog_dst_register dst = dst_reg(PROGRAM_INPUT, idx);
   struct prog_src_register interp = src_reg(PROGRAM_PAYLOAD, idx);
   struct prog_src_register deltas;

   deltas = get_delta_xy(c);

   /* Need to use PINTERP on attributes which have been
    * multiplied by 1/W in the SF program, and LINTERP on those
    * which have not:
    */
   switch (idx) {
   case FRAG_ATTRIB_WPOS:
      /* Have to treat wpos.xy specially:
       */
      emit_op(c,
	      WM_WPOSXY,
	      dst_mask(dst, WRITEMASK_XY),
	      0,
	      get_pixel_xy(c),
	      src_undef(),
	      src_undef());
      
      dst = dst_mask(dst, WRITEMASK_ZW);

      /* PROGRAM_INPUT.attr.xyzw = INTERP payload.interp[attr].x, deltas.xyw
       */
      emit_op(c,
	      WM_LINTERP,
	      dst,
	      0,
	      interp,
	      deltas,
	      src_undef());
      break;
   case FRAG_ATTRIB_COL0:
   case FRAG_ATTRIB_COL1:
      if (c->key.flat_shade) {
	 emit_op(c,
		 WM_CINTERP,
		 dst,
		 0,
		 interp,
		 src_undef(),
		 src_undef());
      }
      else {
	 /* perspective-corrected color interpolation */
	 emit_op(c,
		 WM_PINTERP,
		 dst,
		 0,
		 interp,
		 deltas,
		 get_pixel_w(c));
      }
      break;
   case FRAG_ATTRIB_FOGC:
      /* Interpolate the fog coordinate */
      emit_op(c,
	      WM_PINTERP,
	      dst_mask(dst, WRITEMASK_X),
	      0,
	      interp,
	      deltas,
	      get_pixel_w(c));

      emit_op(c,
	      OPCODE_MOV,
	      dst_mask(dst, WRITEMASK_YZW),
	      0,
	      src_swizzle(interp,
			  SWIZZLE_ZERO,
			  SWIZZLE_ZERO,
			  SWIZZLE_ZERO,
			  SWIZZLE_ONE),
	      src_undef(),
	      src_undef());
      break;

   case FRAG_ATTRIB_FACE:
      emit_op(c,
              WM_FRONTFACING,
              dst_mask(dst, WRITEMASK_X),
              0,
              src_undef(),
              src_undef(),
              src_undef());
      break;

   case FRAG_ATTRIB_PNTC:
      /* XXX review/test this case */
      emit_op(c,
	      WM_PINTERP,
	      dst_mask(dst, WRITEMASK_XY),
	      0,
	      interp,
	      deltas,
	      get_pixel_w(c));

      emit_op(c,
	      OPCODE_MOV,
	      dst_mask(dst, WRITEMASK_ZW),
	      0,
	      src_swizzle(interp,
			  SWIZZLE_ZERO,
			  SWIZZLE_ZERO,
			  SWIZZLE_ZERO,
			  SWIZZLE_ONE),
	      src_undef(),
	      src_undef());
      break;

   default:
      emit_op(c,
	      WM_PINTERP,
	      dst,
	      0,
	      interp,
	      deltas,
	      get_pixel_w(c));
      break;
   }

   c->fp_interp_emitted |= 1<<idx;
}

/***********************************************************************
 * Hacks to extend the program parameter and constant lists.
 */

/* Add the fog parameters to the parameter list of the original
 * program, rather than creating a new list.  Doesn't really do any
 * harm and it's not as if the parameter handling isn't a big hack
 * anyway.
 */
static struct prog_src_register search_or_add_param5(struct brw_wm_compile *c, 
                                                     GLint s0,
                                                     GLint s1,
                                                     GLint s2,
                                                     GLint s3,
                                                     GLint s4)
{
   struct gl_program_parameter_list *paramList = c->fp->program.Base.Parameters;
   gl_state_index tokens[STATE_LENGTH];
   GLuint idx;
   tokens[0] = s0;
   tokens[1] = s1;
   tokens[2] = s2;
   tokens[3] = s3;
   tokens[4] = s4;

   idx = _mesa_add_state_reference( paramList, tokens );

   return src_reg(PROGRAM_STATE_VAR, idx);
}


static struct prog_src_register search_or_add_const4f( struct brw_wm_compile *c, 
						     GLfloat s0,
						     GLfloat s1,
						     GLfloat s2,
						     GLfloat s3)
{
   struct gl_program_parameter_list *paramList = c->fp->program.Base.Parameters;
   GLfloat values[4];
   GLuint idx;
   GLuint swizzle;
   struct prog_src_register reg;

   values[0] = s0;
   values[1] = s1;
   values[2] = s2;
   values[3] = s3;

   idx = _mesa_add_unnamed_constant( paramList, values, 4, &swizzle );
   reg = src_reg(PROGRAM_STATE_VAR, idx);
   reg.Swizzle = swizzle;

   return reg;
}



/***********************************************************************
 * Expand various instructions here to simpler forms.  
 */
static void precalc_dst( struct brw_wm_compile *c,
			       const struct prog_instruction *inst )
{
   struct prog_src_register src0 = inst->SrcReg[0];
   struct prog_src_register src1 = inst->SrcReg[1];
   struct prog_dst_register dst = inst->DstReg;
   struct prog_dst_register temp = get_temp(c);

   if (dst.WriteMask & WRITEMASK_Y) {      
      /* dst.y = mul src0.y, src1.y
       */
      emit_op(c,
	      OPCODE_MUL,
	      dst_mask(temp, WRITEMASK_Y),
	      inst->SaturateMode,
	      src0,
	      src1,
	      src_undef());
   }

   if (dst.WriteMask & WRITEMASK_XZ) {
      struct prog_instruction *swz;
      GLuint z = GET_SWZ(src0.Swizzle, Z);

      /* dst.xz = swz src0.1zzz
       */
      swz = emit_op(c,
		    OPCODE_SWZ,
		    dst_mask(temp, WRITEMASK_XZ),
		    inst->SaturateMode,
		    src_swizzle(src0, SWIZZLE_ONE, z, z, z),
		    src_undef(),
		    src_undef());
      /* Avoid letting negation flag of src0 affect our 1 constant. */
      swz->SrcReg[0].Negate &= ~NEGATE_X;
   }
   if (dst.WriteMask & WRITEMASK_W) {
      /* dst.w = mov src1.w
       */
      emit_op(c,
	      OPCODE_MOV,
	      dst_mask(temp, WRITEMASK_W),
	      inst->SaturateMode,
	      src1,
	      src_undef(),
	      src_undef());
   }

   /* This will get optimized out in general, but it ensures that we
    * don't overwrite src operands in our channel-wise splitting
    * above.  See piglit fp-dst-aliasing-[12].
    */
   emit_op(c,
	   OPCODE_MOV,
	   dst,
	   0,
	   src_reg_from_dst(temp),
	   src_undef(),
	   src_undef());

   release_temp(c, temp);
}


static void precalc_lit( struct brw_wm_compile *c,
			 const struct prog_instruction *inst )
{
   struct prog_src_register src0 = inst->SrcReg[0];
   struct prog_dst_register dst = inst->DstReg;

   if (dst.WriteMask & WRITEMASK_YZ) {
      emit_op(c,
	      OPCODE_LIT,
	      dst_mask(dst, WRITEMASK_YZ),
	      inst->SaturateMode,
	      src0,
	      src_undef(),
	      src_undef());
   }

   if (dst.WriteMask & WRITEMASK_XW) {
      struct prog_instruction *swz;

      /* dst.xw = swz src0.1111
       */
      swz = emit_op(c,
		    OPCODE_SWZ,
		    dst_mask(dst, WRITEMASK_XW),
		    0,
		    src_swizzle1(src0, SWIZZLE_ONE),
		    src_undef(),
		    src_undef());
      /* Avoid letting the negation flag of src0 affect our 1 constant. */
      swz->SrcReg[0].Negate = NEGATE_NONE;
   }
}


/**
 * Some TEX instructions require extra code, cube map coordinate
 * normalization, or coordinate scaling for RECT textures, etc.
 * This function emits those extra instructions and the TEX
 * instruction itself.
 */
static void precalc_tex( struct brw_wm_compile *c,
			 const struct prog_instruction *inst )
{
   struct prog_src_register coord;
   struct prog_dst_register tmpcoord = { 0 };
   const GLuint unit = c->fp->program.Base.SamplerUnits[inst->TexSrcUnit];

   assert(unit < BRW_MAX_TEX_UNIT);

   if (inst->TexSrcTarget == TEXTURE_CUBE_INDEX) {
       struct prog_instruction *out;
       struct prog_dst_register tmp0 = get_temp(c);
       struct prog_src_register tmp0src = src_reg_from_dst(tmp0);
       struct prog_dst_register tmp1 = get_temp(c);
       struct prog_src_register tmp1src = src_reg_from_dst(tmp1);
       struct prog_src_register src0 = inst->SrcReg[0];

       /* find longest component of coord vector and normalize it */
       tmpcoord = get_temp(c);
       coord = src_reg_from_dst(tmpcoord);

       /* tmpcoord = src0 (i.e.: coord = src0) */
       out = emit_op(c, OPCODE_MOV,
                     tmpcoord,
                     0,
                     src0,
                     src_undef(),
                     src_undef());
       out->SrcReg[0].Negate = NEGATE_NONE;
       out->SrcReg[0].Abs = 1;

       /* tmp0 = MAX(coord.X, coord.Y) */
       emit_op(c, OPCODE_MAX,
               tmp0,
               0,
               src_swizzle1(coord, X),
               src_swizzle1(coord, Y),
               src_undef());

       /* tmp1 = MAX(tmp0, coord.Z) */
       emit_op(c, OPCODE_MAX,
               tmp1,
               0,
               tmp0src,
               src_swizzle1(coord, Z),
               src_undef());

       /* tmp0 = 1 / tmp1 */
       emit_op(c, OPCODE_RCP,
               dst_mask(tmp0, WRITEMASK_X),
               0,
               tmp1src,
               src_undef(),
               src_undef());

       /* tmpCoord = src0 * tmp0 */
       emit_op(c, OPCODE_MUL,
               tmpcoord,
               0,
               src0,
               src_swizzle1(tmp0src, SWIZZLE_X),
               src_undef());

       release_temp(c, tmp0);
       release_temp(c, tmp1);
   }
   else if (inst->TexSrcTarget == TEXTURE_RECT_INDEX) {
      struct prog_src_register scale = 
	 search_or_add_param5( c, 
			       STATE_INTERNAL, 
			       STATE_TEXRECT_SCALE,
			       unit,
			       0,0 );

      tmpcoord = get_temp(c);

      /* coord.xy   = MUL inst->SrcReg[0], { 1/width, 1/height }
       */
      emit_op(c,
	      OPCODE_MUL,
	      tmpcoord,
	      0,
	      inst->SrcReg[0],
	      src_swizzle(scale,
			  SWIZZLE_X,
			  SWIZZLE_Y,
			  SWIZZLE_ONE,
			  SWIZZLE_ONE),
	      src_undef());

      coord = src_reg_from_dst(tmpcoord);
   }
   else {
      coord = inst->SrcReg[0];
   }

   /* Need to emit YUV texture conversions by hand.  Probably need to
    * do this here - the alternative is in brw_wm_emit.c, but the
    * conversion requires allocating a temporary variable which we
    * don't have the facility to do that late in the compilation.
    */
   if (c->key.yuvtex_mask & (1 << unit)) {
      /* convert ycbcr to RGBA */
      GLboolean  swap_uv = c->key.yuvtex_swap_mask & (1<<unit);

      /* 
	 CONST C0 = { -.5, -.0625,  -.5, 1.164 }
	 CONST C1 = { 1.596, -0.813, 2.018, -.391 }
	 UYV     = TEX ...
	 UYV.xyz = ADD UYV,     C0
	 UYV.y   = MUL UYV.y,   C0.w
 	 if (UV swaped)
	    RGB.xyz = MAD UYV.zzx, C1,   UYV.y
	 else
	    RGB.xyz = MAD UYV.xxz, C1,   UYV.y 
	 RGB.y   = MAD UYV.z,   C1.w, RGB.y
      */
      struct prog_dst_register dst = inst->DstReg;
      struct prog_dst_register tmp = get_temp(c);
      struct prog_src_register tmpsrc = src_reg_from_dst(tmp);
      struct prog_src_register C0 = search_or_add_const4f( c,  -.5, -.0625, -.5, 1.164 );
      struct prog_src_register C1 = search_or_add_const4f( c, 1.596, -0.813, 2.018, -.391 );
     
      /* tmp     = TEX ...
       */
      emit_tex_op(c, 
                  OPCODE_TEX,
                  tmp,
                  inst->SaturateMode,
                  unit,
                  inst->TexSrcTarget,
                  inst->TexShadow,
                  coord,
                  src_undef(),
                  src_undef());

      /* tmp.xyz =  ADD TMP, C0
       */
      emit_op(c,
	      OPCODE_ADD,
	      dst_mask(tmp, WRITEMASK_XYZ),
	      0,
	      tmpsrc,
	      C0,
	      src_undef());

      /* YUV.y   = MUL YUV.y, C0.w
       */

      emit_op(c,
	      OPCODE_MUL,
	      dst_mask(tmp, WRITEMASK_Y),
	      0,
	      tmpsrc,
	      src_swizzle1(C0, W),
	      src_undef());

      /* 
       * if (UV swaped)
       *     RGB.xyz = MAD YUV.zzx, C1, YUV.y
       * else
       *     RGB.xyz = MAD YUV.xxz, C1, YUV.y
       */

      emit_op(c,
	      OPCODE_MAD,
	      dst_mask(dst, WRITEMASK_XYZ),
	      0,
	      swap_uv?src_swizzle(tmpsrc, Z,Z,X,X):src_swizzle(tmpsrc, X,X,Z,Z),
	      C1,
	      src_swizzle1(tmpsrc, Y));

      /*  RGB.y   = MAD YUV.z, C1.w, RGB.y
       */
      emit_op(c,
	      OPCODE_MAD,
	      dst_mask(dst, WRITEMASK_Y),
	      0,
	      src_swizzle1(tmpsrc, Z),
	      src_swizzle1(C1, W),
	      src_swizzle1(src_reg_from_dst(dst), Y));

      release_temp(c, tmp);
   }
   else {
      /* ordinary RGBA tex instruction */
      emit_tex_op(c, 
                  OPCODE_TEX,
                  inst->DstReg,
                  inst->SaturateMode,
                  unit,
                  inst->TexSrcTarget,
                  inst->TexShadow,
                  coord,
                  src_undef(),
                  src_undef());
   }

   /* For GL_EXT_texture_swizzle: */
   if (c->key.tex_swizzles[unit] != SWIZZLE_NOOP) {
      /* swizzle the result of the TEX instruction */
      struct prog_src_register tmpsrc = src_reg_from_dst(inst->DstReg);
      emit_op(c, OPCODE_SWZ,
              inst->DstReg,
              SATURATE_OFF, /* saturate already done above */
              src_swizzle4(tmpsrc, c->key.tex_swizzles[unit]),
              src_undef(),
              src_undef());
   }

   if ((inst->TexSrcTarget == TEXTURE_RECT_INDEX) ||
       (inst->TexSrcTarget == TEXTURE_CUBE_INDEX))
      release_temp(c, tmpcoord);
}


/**
 * Check if the given TXP instruction really needs the divide-by-W step.
 */
static GLboolean projtex( struct brw_wm_compile *c,
			  const struct prog_instruction *inst )
{
   const struct prog_src_register src = inst->SrcReg[0];
   GLboolean retVal;

   assert(inst->Opcode == OPCODE_TXP);

   /* Only try to detect the simplest cases.  Could detect (later)
    * cases where we are trying to emit code like RCP {1.0}, MUL x,
    * {1.0}, and so on.
    *
    * More complex cases than this typically only arise from
    * user-provided fragment programs anyway:
    */
   if (inst->TexSrcTarget == TEXTURE_CUBE_INDEX)
      retVal = GL_FALSE;  /* ut2004 gun rendering !?! */
   else if (src.File == PROGRAM_INPUT && 
	    GET_SWZ(src.Swizzle, W) == W &&
            (c->key.proj_attrib_mask & (1 << src.Index)) == 0)
      retVal = GL_FALSE;
   else
      retVal = GL_TRUE;

   return retVal;
}


/**
 * Emit code for TXP.
 */
static void precalc_txp( struct brw_wm_compile *c,
			       const struct prog_instruction *inst )
{
   struct prog_src_register src0 = inst->SrcReg[0];

   if (projtex(c, inst)) {
      struct prog_dst_register tmp = get_temp(c);
      struct prog_instruction tmp_inst;

      /* tmp0.w = RCP inst.arg[0][3]
       */
      emit_op(c,
	      OPCODE_RCP,
	      dst_mask(tmp, WRITEMASK_W),
	      0,
	      src_swizzle1(src0, GET_SWZ(src0.Swizzle, W)),
	      src_undef(),
	      src_undef());

      /* tmp0.xyz =  MUL inst.arg[0], tmp0.wwww
       */
      emit_op(c,
	      OPCODE_MUL,
	      dst_mask(tmp, WRITEMASK_XYZ),
	      0,
	      src0,
	      src_swizzle1(src_reg_from_dst(tmp), W),
	      src_undef());

      /* dst = precalc(TEX tmp0)
       */
      tmp_inst = *inst;
      tmp_inst.SrcReg[0] = src_reg_from_dst(tmp);
      precalc_tex(c, &tmp_inst);

      release_temp(c, tmp);
   }
   else
   {
      /* dst = precalc(TEX src0)
       */
      precalc_tex(c, inst);
   }
}



static void emit_render_target_writes( struct brw_wm_compile *c )
{
   struct prog_src_register payload_r0_depth = src_reg(PROGRAM_PAYLOAD, PAYLOAD_DEPTH);
   struct prog_src_register outdepth = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_DEPTH);
   struct prog_src_register outcolor;
   GLuint i;

   struct prog_instruction *inst = NULL;

   /* The inst->Aux field is used for FB write target and the EOT marker */

   for (i = 0; i < c->key.nr_color_regions; i++) {
      if (c->fp->program.Base.OutputsWritten & (1 << FRAG_RESULT_COLOR)) {
	 outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_COLOR);
      } else {
	 outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_DATA0 + i);
      }
      inst = emit_op(c, WM_FB_WRITE, dst_mask(dst_undef(), 0),
		     0, outcolor, payload_r0_depth, outdepth);
      inst->Aux = INST_AUX_TARGET(i);
   }

   /* Mark the last FB write as final, or emit a dummy write if we had
    * no render targets bound.
    */
   if (c->key.nr_color_regions != 0) {
      inst->Aux |= INST_AUX_EOT;
   } else {
      inst = emit_op(c, WM_FB_WRITE, dst_mask(dst_undef(), 0),
		     0, src_reg(PROGRAM_OUTPUT, FRAG_RESULT_COLOR),
		     payload_r0_depth, outdepth);
      inst->Aux = INST_AUX_TARGET(0) | INST_AUX_EOT;
   }
}




/***********************************************************************
 * Emit INTERP instructions ahead of first use of each attrib.
 */

static void validate_src_regs( struct brw_wm_compile *c,
			       const struct prog_instruction *inst )
{
   GLuint nr_args = brw_wm_nr_args( inst->Opcode );
   GLuint i;

   for (i = 0; i < nr_args; i++) {
      if (inst->SrcReg[i].File == PROGRAM_INPUT) {
	 GLuint idx = inst->SrcReg[i].Index;
	 if (!(c->fp_interp_emitted & (1<<idx))) {
	    emit_interp(c, idx);
	 }
      }
   }
}

static void print_insns( const struct prog_instruction *insn,
			 GLuint nr )
{
   GLuint i;
   for (i = 0; i < nr; i++, insn++) {
      printf("%3d: ", i);
      if (insn->Opcode < MAX_OPCODE)
	 _mesa_fprint_instruction_opt(stdout, insn, 0, PROG_PRINT_DEBUG, NULL);
      else if (insn->Opcode < MAX_WM_OPCODE) {
	 GLuint idx = insn->Opcode - MAX_OPCODE;

	 _mesa_fprint_alu_instruction(stdout, insn, wm_opcode_strings[idx],
				      3, PROG_PRINT_DEBUG, NULL);
      }
      else 
	 printf("965 Opcode %d\n", insn->Opcode);
   }
}


/**
 * Initial pass for fragment program code generation.
 * This function is used by both the GLSL and non-GLSL paths.
 */
void brw_wm_pass_fp( struct brw_wm_compile *c )
{
   struct intel_context *intel = &c->func.brw->intel;
   struct brw_fragment_program *fp = c->fp;
   GLuint insn;

   if (unlikely(INTEL_DEBUG & DEBUG_WM)) {
      printf("pre-fp:\n");
      _mesa_fprint_program_opt(stdout, &fp->program.Base, PROG_PRINT_DEBUG,
			       GL_TRUE);
      printf("\n");
   }

   c->pixel_xy = src_undef();
   if (intel->gen >= 6) {
      /* The interpolation deltas come in as the perspective pixel
       * location barycentric params.
       */
      c->delta_xy = src_reg(PROGRAM_PAYLOAD, PAYLOAD_DEPTH);
   } else {
      c->delta_xy = src_undef();
   }
   c->pixel_w = src_undef();
   c->nr_fp_insns = 0;
   c->fp->tex_units_used = 0x0;

   /* Emit preamble instructions.  This is where special instructions such as
    * WM_CINTERP, WM_LINTERP, WM_PINTERP and WM_WPOSXY are emitted to
    * compute shader inputs from varying vars.
    */
   for (insn = 0; insn < fp->program.Base.NumInstructions; insn++) {
      const struct prog_instruction *inst = &fp->program.Base.Instructions[insn];
      validate_src_regs(c, inst);
   }

   /* Loop over all instructions doing assorted simplifications and
    * transformations.
    */
   for (insn = 0; insn < fp->program.Base.NumInstructions; insn++) {
      const struct prog_instruction *inst = &fp->program.Base.Instructions[insn];
      struct prog_instruction *out;

      /* Check for INPUT values, emit INTERP instructions where
       * necessary:
       */

      switch (inst->Opcode) {
      case OPCODE_SWZ: 
	 out = emit_insn(c, inst);
	 out->Opcode = OPCODE_MOV;
	 break;
	 
      case OPCODE_ABS:
	 out = emit_insn(c, inst);
	 out->Opcode = OPCODE_MOV;
	 out->SrcReg[0].Negate = NEGATE_NONE;
	 out->SrcReg[0].Abs = 1;
	 break;

      case OPCODE_SUB: 
	 out = emit_insn(c, inst);
	 out->Opcode = OPCODE_ADD;
	 out->SrcReg[1].Negate ^= NEGATE_XYZW;
	 break;

      case OPCODE_SCS: 
	 out = emit_insn(c, inst);
	 /* This should probably be done in the parser. 
	  */
	 out->DstReg.WriteMask &= WRITEMASK_XY;
	 break;
	 
      case OPCODE_DST:
	 precalc_dst(c, inst);
	 break;

      case OPCODE_LIT:
	 precalc_lit(c, inst);
	 break;

      case OPCODE_RSQ:
	 out = emit_scalar_insn(c, inst);
	 out->SrcReg[0].Abs = GL_TRUE;
	 break;

      case OPCODE_TEX:
	 precalc_tex(c, inst);
	 break;

      case OPCODE_TXP:
	 precalc_txp(c, inst);
	 break;

      case OPCODE_TXB:
	 out = emit_insn(c, inst);
	 out->TexSrcUnit = fp->program.Base.SamplerUnits[inst->TexSrcUnit];
         assert(out->TexSrcUnit < BRW_MAX_TEX_UNIT);
	 break;

      case OPCODE_XPD: 
	 out = emit_insn(c, inst);
	 /* This should probably be done in the parser. 
	  */
	 out->DstReg.WriteMask &= WRITEMASK_XYZ;
	 break;

      case OPCODE_KIL: 
	 out = emit_insn(c, inst);
	 /* This should probably be done in the parser. 
	  */
	 out->DstReg.WriteMask = 0;
	 break;
      case OPCODE_END:
	 emit_render_target_writes(c);
	 break;
      case OPCODE_PRINT:
	 break;
      default:
	 if (brw_wm_is_scalar_result(inst->Opcode))
	    emit_scalar_insn(c, inst);
	 else
	    emit_insn(c, inst);
	 break;
      }
   }

   if (unlikely(INTEL_DEBUG & DEBUG_WM)) {
      printf("pass_fp:\n");
      print_insns( c->prog_instructions, c->nr_fp_insns );
      printf("\n");
   }
}

@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.6
log
@Merge Mesa 7.10.3
@
text
@d420 8
a427 19
         if (c->key.linear_color) {
            emit_op(c,
                    WM_LINTERP,
                    dst,
                    0,
                    interp,
                    deltas,
                    src_undef());
         }
         else {
            /* perspective-corrected color interpolation */
            emit_op(c,
                    WM_PINTERP,
                    dst,
                    0,
                    interp,
                    deltas,
                    get_pixel_w(c));
         }
d566 2
a567 1
   
d573 1
a573 1
	      dst_mask(dst, WRITEMASK_Y),
d588 1
a588 1
		    dst_mask(dst, WRITEMASK_XZ),
d601 1
a601 1
	      dst_mask(dst, WRITEMASK_W),
d607 14
d629 11
a639 1
   
a654 10

   if (dst.WriteMask & WRITEMASK_YZ) {
      emit_op(c,
	      OPCODE_LIT,
	      dst_mask(dst, WRITEMASK_YZ),
	      inst->SaturateMode,
	      src0,
	      src_undef(),
	      src_undef());
   }
d968 1
a968 1
   struct prog_instruction *inst, *last_inst = NULL;
d972 5
a976 12
   if (c->key.nr_color_regions > 1) {
      for (i = 0 ; i < c->key.nr_color_regions; i++) {
         outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_DATA0 + i);
         last_inst = inst = emit_op(c, WM_FB_WRITE, dst_mask(dst_undef(), 0),
                                    0, outcolor, payload_r0_depth, outdepth);
         inst->Aux = INST_AUX_TARGET(i);
         if (c->fp_fragcolor_emitted) {
            outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_COLOR);
            last_inst = inst = emit_op(c, WM_FB_WRITE, dst_mask(dst_undef(), 0),
                                       0, outcolor, payload_r0_depth, outdepth);
            inst->Aux = INST_AUX_TARGET(i);
         }
d978 3
a980 1
      last_inst->Aux |= INST_AUX_EOT;
a981 6
   else {
      /* if gl_FragData[0] is written, use it, else use gl_FragColor */
      if (c->fp->program.Base.OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_DATA0))
         outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_DATA0);
      else 
         outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_COLOR);
d983 10
a992 3
      inst = emit_op(c, WM_FB_WRITE, dst_mask(dst_undef(),0),
                     0, outcolor, payload_r0_depth, outdepth);
      inst->Aux = INST_AUX_EOT | INST_AUX_TARGET(0);
a1017 10
	 
static void validate_dst_regs( struct brw_wm_compile *c,
			       const struct prog_instruction *inst )
{
   if (inst->DstReg.File == PROGRAM_OUTPUT) {
      GLuint idx = inst->DstReg.Index;
      if (idx == FRAG_RESULT_COLOR)
         c->fp_fragcolor_emitted = 1;
   }
}
a1075 1
      validate_dst_regs(c, inst);
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d40 3
a42 3
#include "shader/prog_parameter.h"
#include "shader/prog_print.h"
#include "shader/prog_statevars.h"
d91 3
d341 8
d376 3
a378 1
   struct prog_src_register deltas = get_delta_xy(c);
a534 6
   
   for (idx = 0; idx < paramList->NumParameters; idx++) {
      if (paramList->Parameters[idx].Type == PROGRAM_STATE_VAR &&
	  memcmp(paramList->Parameters[idx].StateIndexes, tokens, sizeof(tokens)) == 0)
	 return src_reg(PROGRAM_STATE_VAR, idx);
   }
d552 1
d559 3
a561 6
   /* Have to search, otherwise multiple compilations will each grow
    * the parameter list.
    */
   for (idx = 0; idx < paramList->NumParameters; idx++) {
      if (paramList->Parameters[idx].Type == PROGRAM_CONSTANT &&
	  memcmp(paramList->ParameterValues[idx], values, sizeof(values)) == 0)
d563 1
a563 9
	 /* XXX: this mimics the mesa bug which puts all constants and
	  * parameters into the "PROGRAM_STATE_VAR" category:
	  */
	 return src_reg(PROGRAM_STATE_VAR, idx);
   }
   
   idx = _mesa_add_unnamed_constant( paramList, values, 4, &swizzle );
   assert(swizzle == SWIZZLE_NOOP); /* Need to handle swizzle in reg setup */
   return src_reg(PROGRAM_STATE_VAR, idx);
d664 1
a664 1
   struct prog_dst_register tmpcoord;
d964 1
a964 1
   struct prog_instruction *inst, *last_inst;
d1036 1
a1036 1
	 _mesa_print_instruction(insn);
d1040 2
a1041 3
	 _mesa_print_alu_instruction(insn,
				     wm_opcode_strings[idx],
				     3);
d1055 1
d1059 1
a1059 1
   if (INTEL_DEBUG & DEBUG_WM) {
d1061 2
a1062 1
      _mesa_print_program(&fp->program.Base); 
d1067 8
a1074 1
   c->delta_xy = src_undef();
d1134 5
d1180 1
a1180 1
   if (INTEL_DEBUG & DEBUG_WM) {
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d45 6
d89 1
a89 1
   reg.NegateBase = 0;
a90 1
   reg.NegateAbs = 0;
d120 6
a140 1
   reg.pad = 0;
d162 1
a162 1
      _mesa_printf("%s: out of temporaries\n", __FILE__);
d183 3
d203 1
d210 9
d226 1
d243 1
a243 1
                      0, 0,  /* tex unit, target */
a245 1
   
d248 34
d342 1
a342 2
      
      
d407 19
a425 7
	 emit_op(c,
		 WM_LINTERP,
		 dst,
		 0,
		 interp,
		 deltas,
		 src_undef());
a428 8
      /* The FOGC input is really special.  When a program uses glFogFragCoord,
       * the results returned are supposed to be (f,0,0,1).  But for Mesa GLSL,
       * the glFrontFacing and glPointCoord values are also stashed in FOGC.
       * So, write the interpolated fog value to X, then either 0, 1, or the
       * stashed values to Y, Z, W.  Note that this means that
       * glFogFragCoord.yzw can be wrong in those cases!
       */

d438 32
a469 18
      /* Move the front facing value into FOGC.y if it's needed. */
      if (c->fp->program.UsesFrontFacing) {
	 emit_op(c,
		 WM_FRONTFACING,
		 dst_mask(dst, WRITEMASK_Y),
		 0,
		 src_undef(),
		 src_undef(),
		 src_undef());
      } else {
	 emit_op(c,
		 OPCODE_MOV,
		 dst_mask(dst, WRITEMASK_Y),
		 0,
		 src_swizzle1(interp, SWIZZLE_ZERO),
		 src_undef(),
		 src_undef());
      }
a470 1
      /* Should do the PointCoord thing here. */
d483 1
a497 32
static void emit_ddx( struct brw_wm_compile *c,
        const struct prog_instruction *inst )
{
    GLuint idx = inst->SrcReg[0].Index;
    struct prog_src_register interp = src_reg(PROGRAM_PAYLOAD, idx);

    c->fp_deriv_emitted |= 1<<idx;
    emit_op(c,
            OPCODE_DDX,
            inst->DstReg,
            0,
            interp,
            get_pixel_w(c),
            src_undef());
}

static void emit_ddy( struct brw_wm_compile *c,
        const struct prog_instruction *inst )
{
    GLuint idx = inst->SrcReg[0].Index;
    struct prog_src_register interp = src_reg(PROGRAM_PAYLOAD, idx);

    c->fp_deriv_emitted |= 1<<idx;
    emit_op(c,
            OPCODE_DDY,
            inst->DstReg,
            0,
            interp,
            get_pixel_w(c),
            src_undef());
}

a592 1

d607 1
a607 1
      swz->SrcReg[0].NegateBase &= ~NEGATE_X;
d642 1
a642 1
      swz->SrcReg[0].NegateBase = 0;
a644 1

d670 2
d691 1
a691 1
       out->SrcReg[0].NegateBase = 0;
d712 1
a712 1
               tmp0,
d723 1
a723 1
               tmp0src,
d746 5
a750 1
	      scale,
d794 1
d855 1
d861 12
d879 3
d885 4
a888 1
   struct prog_src_register src = inst->SrcReg[0];
d898 1
a898 1
      return 0;  /* ut2004 gun rendering !?! */
d901 2
a902 2
           (c->key.projtex_mask & (1<<(src.Index + FRAG_ATTRIB_WPOS - FRAG_ATTRIB_TEX0))) == 0)
      return 0;
d904 3
a906 1
      return 1;
d910 3
d960 1
a960 1
static void emit_fb_write( struct brw_wm_compile *c )
d963 1
a963 1
   struct prog_src_register outdepth = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_DEPR);
a967 1
   struct brw_context *brw = c->func.brw;
d969 1
a969 2
   /* inst->Sampler is not used by backend, 
      use it for fb write target and eot */
d971 14
a984 15
   if (brw->state.nr_draw_regions > 1) {
       for (i = 0 ; i < brw->state.nr_draw_regions; i++) {
	   outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_DATA0 + i);
	   last_inst = inst = emit_op(c,
		   WM_FB_WRITE, dst_mask(dst_undef(),0), 0,
		   outcolor, payload_r0_depth, outdepth);
	   inst->Sampler = (i<<1);
	   if (c->fp_fragcolor_emitted) {
	       outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_COLR);
	       last_inst = inst = emit_op(c, WM_FB_WRITE, dst_mask(dst_undef(),0),
		       0, outcolor, payload_r0_depth, outdepth);
	       inst->Sampler = (i<<1);
	   }
       }
       last_inst->Sampler |= 1; //eot
d988 1
a988 1
      if (c->fp->program.Base.OutputsWritten & (1 << FRAG_RESULT_DATA0))
d991 1
a991 1
         outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_COLR);
d993 3
a995 3
       inst = emit_op(c, WM_FB_WRITE, dst_mask(dst_undef(),0),
	       0, outcolor, payload_r0_depth, outdepth);
       inst->Sampler = 1|(0<<1);
d1026 3
a1028 3
       GLuint idx = inst->DstReg.Index;
       if (idx == FRAG_RESULT_COLR)
	   c->fp_fragcolor_emitted = 1;
d1037 1
a1037 1
      _mesa_printf("%3d: ", i);
d1048 1
a1048 1
	 _mesa_printf("965 Opcode %d\n", insn->Opcode);
d1052 5
d1063 1
a1063 1
      _mesa_printf("pre-fp:\n");
d1065 1
a1065 1
      _mesa_printf("\n");
d1072 1
d1074 3
a1076 1
   /* Emit preamble instructions:
a1077 2


d1083 4
a1094 1

d1104 1
a1104 1
	 out->SrcReg[0].NegateBase = 0;
d1111 1
a1111 1
	 out->SrcReg[1].NegateBase ^= 0xf;
d1140 1
a1155 6
      case OPCODE_DDX:
	 emit_ddx(c, inst);
	 break;
      case OPCODE_DDY:
         emit_ddy(c, inst);
	break;
d1157 1
a1157 1
	 emit_fb_write(c);
a1160 1
	 
d1162 4
a1165 1
	 emit_insn(c, inst);
d1171 3
a1173 3
	   _mesa_printf("pass_fp:\n");
	   print_insns( c->prog_instructions, c->nr_fp_insns );
	   _mesa_printf("\n");
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d33 3
a35 3
#include "glheader.h"
#include "macros.h"
#include "enums.h"
d61 2
a62 1
   "FB_WRITE"
d126 2
a127 1
   reg.CondMask = 0;
d129 1
a130 1
   reg.CondSrc = 0;
a180 1
   inst->Data = (void *)inst0;
d184 1
a184 1
static struct prog_instruction * emit_op(struct brw_wm_compile *c,
d210 14
d245 1
a245 1
	      0, 0, 0,
d268 1
a268 1
	      0, 0, 0,
d292 1
a292 1
	      0, 0, 0,
d310 1
a310 3
   struct prog_src_register arg2;
   GLuint opcode;
   
a316 3
      opcode = WM_LINTERP;
      arg2 = src_undef();

d322 1
a322 1
	      0, 0, 0,
d334 1
a334 1
	      0, 0, 0,
d337 1
a337 1
	      arg2);
d345 1
a345 1
		 0, 0, 0,
d354 1
a354 1
		 0, 0, 0,
d360 50
d414 1
a414 1
	      0, 0, 0,
d434 1
a434 1
            0, 0, 0,
d450 1
a450 1
            0, 0, 0,
a488 4
   /* Recalculate state dependency: 
    */
   c->fp->param_state = paramList->StateFlags;

d545 1
a545 1
	      inst->SaturateMode, 0, 0,
d561 1
a561 1
		    inst->SaturateMode, 0, 0,
d574 1
a574 1
	      inst->SaturateMode, 0, 0,
d596 1
a596 1
		    0, 0, 0,
d609 1
a609 1
	      inst->SaturateMode, 0, 0,
d616 7
d628 1
a628 1
   GLuint unit = c->fp->program.Base.SamplerUnits[inst->TexSrcUnit];
d638 1
d642 1
d645 1
a645 1
                     0, 0, 0,
d652 1
d655 1
a655 1
               0, 0, 0,
d660 1
d663 1
a663 1
               0, 0, 0,
d668 1
d671 1
a671 1
               0, 0, 0,
d676 1
d679 1
a679 1
               0, 0, 0,
d686 2
a687 1
   } else if (inst->TexSrcTarget == TEXTURE_RECT_INDEX) {
d702 1
a702 1
	      0, 0, 0,
d718 3
a720 13
   if (!(c->key.yuvtex_mask & (1<<unit))) {
      emit_op(c, 
	      OPCODE_TEX,
	      inst->DstReg,
	      inst->SaturateMode,
	      unit,
	      inst->TexSrcTarget,
	      coord,
	      src_undef(),
	      src_undef());
   }
   else {
       GLboolean  swap_uv = c->key.yuvtex_swap_mask & (1<<unit);
d742 9
a750 9
      emit_op(c, 
	      OPCODE_TEX,
	      tmp,
	      inst->SaturateMode,
	      unit,
	      inst->TexSrcTarget,
	      coord,
	      src_undef(),
	      src_undef());
d757 1
a757 1
	      0, 0, 0,
d768 1
a768 1
	      0, 0, 0,
d783 1
a783 1
	      0, 0, 0,
d793 1
a793 1
	      0, 0, 0,
d800 12
d856 1
a856 1
	      0, 0, 0,
d866 1
a866 1
	      0, 0, 0,
a888 51


/***********************************************************************
 * Add instructions to perform fog blending
 */

static void fog_blend( struct brw_wm_compile *c,
			     struct prog_src_register fog_factor )
{
   struct prog_dst_register outcolor = dst_reg(PROGRAM_OUTPUT, FRAG_RESULT_COLR);
   struct prog_src_register fogcolor = search_or_add_param5( c, STATE_FOG_COLOR, 0,0,0,0 );

   /* color.xyz = LRP fog_factor.xxxx, output_color, fog_color */
   
   emit_op(c, 
	   OPCODE_LRP,
	   dst_mask(outcolor, WRITEMASK_XYZ),
	   0, 0, 0,
	   fog_factor,
	   src_reg_from_dst(outcolor),
	   fogcolor);
}



/* This one is simple - just take the interpolated fog coordinate and
 * use it as the fog blend factor.
 */
static void fog_interpolated( struct brw_wm_compile *c )
{
   struct prog_src_register fogc = src_reg(PROGRAM_INPUT, FRAG_ATTRIB_FOGC);
   
   if (!(c->fp_interp_emitted & (1<<FRAG_ATTRIB_FOGC))) 
      emit_interp(c, FRAG_ATTRIB_FOGC);

   fog_blend( c, src_swizzle1(fogc, GET_SWZ(fogc.Swizzle,X)));
}

static void emit_fog( struct brw_wm_compile *c ) 
{
   if (!c->fp->program.FogOption)
      return;

   if (1) 
      fog_interpolated( c );
   else {
      /* TODO: per-pixel fog */
      assert(0);
   }
}

a890 1
   struct prog_src_register outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_COLR);
d893 1
d906 1
a906 1
		   WM_FB_WRITE, dst_mask(dst_undef(),0), 0, 0, 0,
d912 1
a912 1
		       0, 0, 0, outcolor, payload_r0_depth, outdepth);
d917 8
a924 1
   }else {
d926 1
a926 1
	       0, 0, 0, outcolor, payload_r0_depth, outdepth);
d980 1
a980 2
	 _mesa_printf("UNKNOWN\n");
	   
d990 1
a990 1
      _mesa_printf("\n\n\npre-fp:\n");
a1084 1
	 emit_fog(c);
d1097 1
a1097 1
	   _mesa_printf("\n\n\npass_fp:\n");
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d147 1
a147 1
   int bit = ffs( ~c->fp_temp );
d161 1
a161 1
   c->fp_temp &= ~1<<(temp.Index + 1 - FIRST_INTERNAL_TEMP);
d179 1
a204 1
   
d364 31
d467 1
a467 1
   /* XXX what about swizzle? */
d497 1
d502 9
a510 7
      emit_op(c,
	      OPCODE_SWZ,
	      dst_mask(dst, WRITEMASK_XZ),
	      inst->SaturateMode, 0, 0,
	      src_swizzle(src0, SWIZZLE_ONE, z, z, z),
	      src_undef(),
	      src_undef());
d533 2
d537 9
a545 7
      emit_op(c,
	      OPCODE_SWZ,
	      dst_mask(dst, WRITEMASK_XW),
	      0, 0, 0,
	      src_swizzle1(src0, SWIZZLE_ONE),
	      src_undef(),
	      src_undef());
d565 1
d622 1
a622 1
			       inst->TexSrcUnit,
d648 1
a648 1
   if (!(c->key.yuvtex_mask & (1<<inst->TexSrcUnit))) {
d653 1
a653 1
	      inst->TexSrcUnit,
d660 2
d668 4
a671 1
	 RGB.xyz = MAD UYV.xxz, C1,   UYV.y
a674 1
      struct prog_src_register src0 = inst->SrcReg[0];
d686 1
a686 1
	      inst->TexSrcUnit,
d688 1
a688 1
	      src0,
d704 1
d713 5
a717 1
      /* RGB.xyz = MAD YUV.xxz, C1, YUV.y
d719 1
d724 1
a724 1
	      src_swizzle(tmpsrc, X,X,Z,Z),
d741 2
a742 1
   if (inst->TexSrcTarget == GL_TEXTURE_RECTANGLE_NV) 
d763 1
a763 1
	    (c->key.projtex_mask & (1<<src.Index)) == 0)
d873 4
d878 23
a900 7
   emit_op(c,
	   WM_FB_WRITE,
	   dst_mask(dst_undef(),0),
	   0, 0, 0,
	   outcolor,
	   payload_r0_depth,
	   outdepth);
d926 9
a934 1

d979 5
a988 1
      validate_src_regs(c, inst);
d1024 5
a1028 1
     
d1033 5
d1051 6
a1056 1

d1058 3
a1068 4
   
   emit_fog(c);
   emit_fb_write(c);

d1071 3
a1073 3
      _mesa_printf("\n\n\npass_fp:\n");
      print_insns( c->prog_instructions, c->nr_fp_insns );
      _mesa_printf("\n");
@


1.1
log
@Initial revision
@
text
@d40 4
a43 3
#include "shader/program.h"
#include "shader/program_instruction.h"
#include "shader/arbprogparse.h"
d64 1
d68 1
d374 6
a379 7
static struct prog_src_register search_or_add_param6( struct brw_wm_compile *c, 
					     GLint s0,
					     GLint s1,
					     GLint s2,
					     GLint s3,
					     GLint s4,
					     GLint s5)
d382 1
a382 1
   GLint tokens[6];
a388 1
   tokens[5] = s5;
d400 1
a400 1
   c->fp->param_state = brw_parameter_list_state_flags( paramList );
d415 1
d435 2
a436 2
   idx = _mesa_add_unnamed_constant( paramList, values );

d525 79
d616 1
a616 1
	      inst->SrcReg[0],
d688 2
d691 3
d777 1
a777 1
   struct prog_src_register fogcolor = search_or_add_param6( c, STATE_FOG_COLOR, 0,0,0,0,0 );
d858 21
d977 1
a977 1
/*       _mesa_debug_fp_inst(c->nr_fp_insns, c->prog_instructions, wm_opcode_strings, wm_file_strings);  */
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@a62 1
#if 0
a65 1
#endif
d433 1
a433 1
   idx = _mesa_add_unnamed_constant( paramList, values, 4 );
a522 29
   struct prog_src_register coord;
   struct prog_dst_register tmpcoord;

   if (inst->TexSrcTarget == TEXTURE_RECT_INDEX) {
      struct prog_src_register scale = 
	 search_or_add_param6( c, 
			       STATE_INTERNAL, 
			       STATE_TEXRECT_SCALE,
			       inst->TexSrcUnit,
			       0,0,0 );

      tmpcoord = get_temp(c);

      /* coord.xy   = MUL inst->SrcReg[0], { 1/width, 1/height }
       */
      emit_op(c,
	      OPCODE_MUL,
	      tmpcoord,
	      0, 0, 0,
	      inst->SrcReg[0],
	      scale,
	      src_undef());

      coord = src_reg_from_dst(tmpcoord);
   }
   else {
      coord = inst->SrcReg[0];
   }

d535 1
a535 1
	      coord,
a606 2

      release_temp(c, tmp);
a607 3

   if (inst->TexSrcTarget == GL_TEXTURE_RECTANGLE_NV) 
      release_temp(c, tmpcoord);
a771 21
static void print_insns( const struct prog_instruction *insn,
			 GLuint nr )
{
   GLuint i;
   for (i = 0; i < nr; i++, insn++) {
      _mesa_printf("%3d: ", i);
      if (insn->Opcode < MAX_OPCODE)
	 _mesa_print_instruction(insn);
      else if (insn->Opcode < MAX_WM_OPCODE) {
	 GLuint idx = insn->Opcode - MAX_OPCODE;

	 _mesa_print_alu_instruction(insn,
				     wm_opcode_strings[idx],
				     3);
      }
      else 
	 _mesa_printf("UNKNOWN\n");
	   
   }
}

d870 1
a870 1
      print_insns( c->prog_instructions, c->nr_fp_insns );
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d40 3
a42 4
#include "shader/prog_parameter.h"
#include "shader/prog_print.h"
#include "shader/prog_statevars.h"

d373 7
a379 6
static struct prog_src_register search_or_add_param5(struct brw_wm_compile *c, 
                                                     GLint s0,
                                                     GLint s1,
                                                     GLint s2,
                                                     GLint s3,
                                                     GLint s4)
d382 1
a382 1
   gl_state_index tokens[STATE_LENGTH];
d389 1
d401 1
a401 1
   c->fp->param_state = paramList->StateFlags;
a415 1
   GLuint swizzle;
d435 2
a436 2
   idx = _mesa_add_unnamed_constant( paramList, values, 4, &swizzle );
   /* XXX what about swizzle? */
d530 1
a530 1
	 search_or_add_param5( c, 
d534 1
a534 1
			       0,0 );
d727 1
a727 1
   struct prog_src_register fogcolor = search_or_add_param5( c, STATE_FOG_COLOR, 0,0,0,0 );
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d33 3
a35 3
#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"
d40 3
a42 3
#include "program/prog_parameter.h"
#include "program/prog_print.h"
#include "program/prog_statevars.h"
a44 6
/** An invalid texture target */
#define TEX_TARGET_NONE NUM_TEXTURE_TARGETS

/** An invalid texture unit */
#define TEX_UNIT_NONE BRW_MAX_TEX_UNIT

d61 1
a61 2
   "FB_WRITE",
   "FRONTFACING",
d82 1
a82 1
   reg.Negate = NEGATE_NONE;
d84 1
a84 3
   reg.HasIndex2 = 0;
   reg.RelAddr2 = 0;
   reg.Index2 = 0;
a113 6
static struct prog_src_register src_swizzle4( struct prog_src_register reg, uint swizzle )
{
   reg.Swizzle = swizzle;
   return reg;
}

d125 1
a125 2
   reg.RelAddr = 0;
   reg.CondMask = COND_TR;
d127 1
d147 1
a147 1
   int bit = _mesa_ffs( ~c->fp_temp );
d150 1
a150 1
      printf("%s: out of temporaries\n", __FILE__);
d161 1
a161 1
   c->fp_temp &= ~(1 << (temp.Index - FIRST_INTERNAL_TEMP));
a170 3
   assert(c->nr_fp_insns < BRW_WM_MAX_INSN);
   memset(&c->prog_instructions[c->nr_fp_insns], 0,
	  sizeof(*c->prog_instructions));
d182 1
a182 1
static struct prog_instruction * emit_tex_op(struct brw_wm_compile *c,
a187 1
				       GLuint tex_shadow,
a193 9
   assert(tex_src_unit < BRW_MAX_TEX_UNIT ||
          tex_src_unit == TEX_UNIT_NONE);
   assert(tex_src_target < NUM_TEXTURE_TARGETS ||
          tex_src_target == TEX_TARGET_NONE);

   /* update mask of which texture units are referenced by this program */
   if (tex_src_unit != TEX_UNIT_NONE)
      c->fp->tex_units_used |= (1 << tex_src_unit);

a200 1
   inst->TexShadow = tex_shadow;
d204 1
a208 47
static struct prog_instruction * emit_op(struct brw_wm_compile *c,
				       GLuint op,
				       struct prog_dst_register dest,
				       GLuint saturate,
				       struct prog_src_register src0,
				       struct prog_src_register src1,
				       struct prog_src_register src2 )
{
   return emit_tex_op(c, op, dest, saturate,
                      TEX_UNIT_NONE, TEX_TARGET_NONE, 0,  /* unit, tgt, shadow */
                      src0, src1, src2);
}


/* Many Mesa opcodes produce the same value across all the result channels.
 * We'd rather not have to support that splatting in the opcode implementations,
 * and brw_wm_pass*.c wants to optimize them out by shuffling references around
 * anyway.  We can easily get both by emitting the opcode to one channel, and
 * then MOVing it to the others, which brw_wm_pass*.c already understands.
 */
static struct prog_instruction *emit_scalar_insn(struct brw_wm_compile *c,
						 const struct prog_instruction *inst0)
{
   struct prog_instruction *inst;
   unsigned int dst_chan;
   unsigned int other_channel_mask;

   if (inst0->DstReg.WriteMask == 0)
      return NULL;

   dst_chan = _mesa_ffs(inst0->DstReg.WriteMask) - 1;
   inst = get_fp_inst(c);
   *inst = *inst0;
   inst->DstReg.WriteMask = 1 << dst_chan;

   other_channel_mask = inst0->DstReg.WriteMask & ~(1 << dst_chan);
   if (other_channel_mask != 0) {
      inst = emit_op(c,
		     OPCODE_MOV,
		     dst_mask(inst0->DstReg, other_channel_mask),
		     0,
		     src_swizzle1(src_reg_from_dst(inst0->DstReg), dst_chan),
		     src_undef(),
		     src_undef());
   }
   return inst;
}
d230 1
a230 1
	      0,
d253 1
a253 1
	      0,
a265 8
   /* This is called for producing 1/w in pre-gen6 interp.  for gen6,
    * the interp opcodes don't use this argument.  But to keep the
    * nr_args = 3 expectations of pinterp happy, just stuff delta_xy
    * into the slot.
    */
   if (c->func.brw->intel.gen >= 6)
      return c->delta_xy;

d270 2
a271 1

d277 1
a277 1
	      0,
d294 4
a297 4
   struct prog_src_register deltas;

   deltas = get_delta_xy(c);

d304 3
d312 1
a312 1
	      0,
d324 1
a324 1
	      0,
d327 1
a327 1
	      src_undef());
d335 1
a335 1
		 0,
d341 7
a347 19
         if (c->key.linear_color) {
            emit_op(c,
                    WM_LINTERP,
                    dst,
                    0,
                    interp,
                    deltas,
                    src_undef());
         }
         else {
            /* perspective-corrected color interpolation */
            emit_op(c,
                    WM_PINTERP,
                    dst,
                    0,
                    interp,
                    deltas,
                    get_pixel_w(c));
         }
a349 56
   case FRAG_ATTRIB_FOGC:
      /* Interpolate the fog coordinate */
      emit_op(c,
	      WM_PINTERP,
	      dst_mask(dst, WRITEMASK_X),
	      0,
	      interp,
	      deltas,
	      get_pixel_w(c));

      emit_op(c,
	      OPCODE_MOV,
	      dst_mask(dst, WRITEMASK_YZW),
	      0,
	      src_swizzle(interp,
			  SWIZZLE_ZERO,
			  SWIZZLE_ZERO,
			  SWIZZLE_ZERO,
			  SWIZZLE_ONE),
	      src_undef(),
	      src_undef());
      break;

   case FRAG_ATTRIB_FACE:
      emit_op(c,
              WM_FRONTFACING,
              dst_mask(dst, WRITEMASK_X),
              0,
              src_undef(),
              src_undef(),
              src_undef());
      break;

   case FRAG_ATTRIB_PNTC:
      /* XXX review/test this case */
      emit_op(c,
	      WM_PINTERP,
	      dst_mask(dst, WRITEMASK_XY),
	      0,
	      interp,
	      deltas,
	      get_pixel_w(c));

      emit_op(c,
	      OPCODE_MOV,
	      dst_mask(dst, WRITEMASK_ZW),
	      0,
	      src_swizzle(interp,
			  SWIZZLE_ZERO,
			  SWIZZLE_ZERO,
			  SWIZZLE_ZERO,
			  SWIZZLE_ONE),
	      src_undef(),
	      src_undef());
      break;

d354 1
a354 1
	      0,
d364 1
d389 6
d398 4
a415 1
   struct prog_src_register reg;
d422 13
d436 2
a437 4
   reg = src_reg(PROGRAM_STATE_VAR, idx);
   reg.Swizzle = swizzle;

   return reg;
d458 1
a458 1
	      inst->SaturateMode,
d464 1
a465 1
      struct prog_instruction *swz;
d470 7
a476 9
      swz = emit_op(c,
		    OPCODE_SWZ,
		    dst_mask(dst, WRITEMASK_XZ),
		    inst->SaturateMode,
		    src_swizzle(src0, SWIZZLE_ONE, z, z, z),
		    src_undef(),
		    src_undef());
      /* Avoid letting negation flag of src0 affect our 1 constant. */
      swz->SrcReg[0].Negate &= ~NEGATE_X;
d484 1
a484 1
	      inst->SaturateMode,
a498 2
      struct prog_instruction *swz;

d501 7
a507 9
      swz = emit_op(c,
		    OPCODE_SWZ,
		    dst_mask(dst, WRITEMASK_XW),
		    0,
		    src_swizzle1(src0, SWIZZLE_ONE),
		    src_undef(),
		    src_undef());
      /* Avoid letting the negation flag of src0 affect our 1 constant. */
      swz->SrcReg[0].Negate = NEGATE_NONE;
d510 1
d515 1
a515 1
	      inst->SaturateMode,
a521 7

/**
 * Some TEX instructions require extra code, cube map coordinate
 * normalization, or coordinate scaling for RECT textures, etc.
 * This function emits those extra instructions and the TEX
 * instruction itself.
 */
d526 1
a526 58
   struct prog_dst_register tmpcoord = { 0 };
   const GLuint unit = c->fp->program.Base.SamplerUnits[inst->TexSrcUnit];

   assert(unit < BRW_MAX_TEX_UNIT);

   if (inst->TexSrcTarget == TEXTURE_CUBE_INDEX) {
       struct prog_instruction *out;
       struct prog_dst_register tmp0 = get_temp(c);
       struct prog_src_register tmp0src = src_reg_from_dst(tmp0);
       struct prog_dst_register tmp1 = get_temp(c);
       struct prog_src_register tmp1src = src_reg_from_dst(tmp1);
       struct prog_src_register src0 = inst->SrcReg[0];

       /* find longest component of coord vector and normalize it */
       tmpcoord = get_temp(c);
       coord = src_reg_from_dst(tmpcoord);

       /* tmpcoord = src0 (i.e.: coord = src0) */
       out = emit_op(c, OPCODE_MOV,
                     tmpcoord,
                     0,
                     src0,
                     src_undef(),
                     src_undef());
       out->SrcReg[0].Negate = NEGATE_NONE;
       out->SrcReg[0].Abs = 1;

       /* tmp0 = MAX(coord.X, coord.Y) */
       emit_op(c, OPCODE_MAX,
               tmp0,
               0,
               src_swizzle1(coord, X),
               src_swizzle1(coord, Y),
               src_undef());

       /* tmp1 = MAX(tmp0, coord.Z) */
       emit_op(c, OPCODE_MAX,
               tmp1,
               0,
               tmp0src,
               src_swizzle1(coord, Z),
               src_undef());

       /* tmp0 = 1 / tmp1 */
       emit_op(c, OPCODE_RCP,
               dst_mask(tmp0, WRITEMASK_X),
               0,
               tmp1src,
               src_undef(),
               src_undef());

       /* tmpCoord = src0 * tmp0 */
       emit_op(c, OPCODE_MUL,
               tmpcoord,
               0,
               src0,
               src_swizzle1(tmp0src, SWIZZLE_X),
               src_undef());
d528 1
a528 4
       release_temp(c, tmp0);
       release_temp(c, tmp1);
   }
   else if (inst->TexSrcTarget == TEXTURE_RECT_INDEX) {
d533 1
a533 1
			       unit,
d543 1
a543 1
	      0,
d545 1
a545 5
	      src_swizzle(scale,
			  SWIZZLE_X,
			  SWIZZLE_Y,
			  SWIZZLE_ONE,
			  SWIZZLE_ONE),
d559 12
a570 4
   if (c->key.yuvtex_mask & (1 << unit)) {
      /* convert ycbcr to RGBA */
      GLboolean  swap_uv = c->key.yuvtex_swap_mask & (1<<unit);

d577 1
a577 4
 	 if (UV swaped)
	    RGB.xyz = MAD UYV.zzx, C1,   UYV.y
	 else
	    RGB.xyz = MAD UYV.xxz, C1,   UYV.y 
d581 1
d589 9
a597 10
      emit_tex_op(c, 
                  OPCODE_TEX,
                  tmp,
                  inst->SaturateMode,
                  unit,
                  inst->TexSrcTarget,
                  inst->TexShadow,
                  coord,
                  src_undef(),
                  src_undef());
d604 1
a604 1
	      0,
a610 1

d614 1
a614 1
	      0,
d619 1
a619 5
      /* 
       * if (UV swaped)
       *     RGB.xyz = MAD YUV.zzx, C1, YUV.y
       * else
       *     RGB.xyz = MAD YUV.xxz, C1, YUV.y
a620 1

d624 2
a625 2
	      0,
	      swap_uv?src_swizzle(tmpsrc, Z,Z,X,X):src_swizzle(tmpsrc, X,X,Z,Z),
d634 1
a634 1
	      0,
a640 25
   else {
      /* ordinary RGBA tex instruction */
      emit_tex_op(c, 
                  OPCODE_TEX,
                  inst->DstReg,
                  inst->SaturateMode,
                  unit,
                  inst->TexSrcTarget,
                  inst->TexShadow,
                  coord,
                  src_undef(),
                  src_undef());
   }

   /* For GL_EXT_texture_swizzle: */
   if (c->key.tex_swizzles[unit] != SWIZZLE_NOOP) {
      /* swizzle the result of the TEX instruction */
      struct prog_src_register tmpsrc = src_reg_from_dst(inst->DstReg);
      emit_op(c, OPCODE_SWZ,
              inst->DstReg,
              SATURATE_OFF, /* saturate already done above */
              src_swizzle4(tmpsrc, c->key.tex_swizzles[unit]),
              src_undef(),
              src_undef());
   }
d642 1
a642 2
   if ((inst->TexSrcTarget == TEXTURE_RECT_INDEX) ||
       (inst->TexSrcTarget == TEXTURE_CUBE_INDEX))
a646 3
/**
 * Check if the given TXP instruction really needs the divide-by-W step.
 */
d650 1
a650 4
   const struct prog_src_register src = inst->SrcReg[0];
   GLboolean retVal;

   assert(inst->Opcode == OPCODE_TXP);
d660 1
a660 1
      retVal = GL_FALSE;  /* ut2004 gun rendering !?! */
d663 2
a664 2
            (c->key.proj_attrib_mask & (1 << src.Index)) == 0)
      retVal = GL_FALSE;
d666 1
a666 3
      retVal = GL_TRUE;

   return retVal;
a669 3
/**
 * Emit code for TXP.
 */
d684 1
a684 1
	      0,
d694 1
a694 1
	      0,
d717 29
a745 1
static void emit_render_target_writes( struct brw_wm_compile *c )
d747 4
a750 4
   struct prog_src_register payload_r0_depth = src_reg(PROGRAM_PAYLOAD, PAYLOAD_DEPTH);
   struct prog_src_register outdepth = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_DEPTH);
   struct prog_src_register outcolor;
   GLuint i;
d752 2
a753 1
   struct prog_instruction *inst, *last_inst = NULL;
d755 4
a758 1
   /* The inst->Aux field is used for FB write target and the EOT marker */
d760 5
a764 14
   if (c->key.nr_color_regions > 1) {
      for (i = 0 ; i < c->key.nr_color_regions; i++) {
         outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_DATA0 + i);
         last_inst = inst = emit_op(c, WM_FB_WRITE, dst_mask(dst_undef(), 0),
                                    0, outcolor, payload_r0_depth, outdepth);
         inst->Aux = INST_AUX_TARGET(i);
         if (c->fp_fragcolor_emitted) {
            outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_COLOR);
            last_inst = inst = emit_op(c, WM_FB_WRITE, dst_mask(dst_undef(), 0),
                                       0, outcolor, payload_r0_depth, outdepth);
            inst->Aux = INST_AUX_TARGET(i);
         }
      }
      last_inst->Aux |= INST_AUX_EOT;
d766 7
a772 6
   else {
      /* if gl_FragData[0] is written, use it, else use gl_FragColor */
      if (c->fp->program.Base.OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_DATA0))
         outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_DATA0);
      else 
         outcolor = src_reg(PROGRAM_OUTPUT, FRAG_RESULT_COLOR);
d774 7
a780 4
      inst = emit_op(c, WM_FB_WRITE, dst_mask(dst_undef(),0),
                     0, outcolor, payload_r0_depth, outdepth);
      inst->Aux = INST_AUX_EOT | INST_AUX_TARGET(0);
   }
d806 1
a806 9
static void validate_dst_regs( struct brw_wm_compile *c,
			       const struct prog_instruction *inst )
{
   if (inst->DstReg.File == PROGRAM_OUTPUT) {
      GLuint idx = inst->DstReg.Index;
      if (idx == FRAG_RESULT_COLOR)
         c->fp_fragcolor_emitted = 1;
   }
}
d813 1
a813 1
      printf("%3d: ", i);
d815 1
a815 1
	 _mesa_fprint_instruction_opt(stdout, insn, 0, PROG_PRINT_DEBUG, NULL);
d819 3
a821 2
	 _mesa_fprint_alu_instruction(stdout, insn, wm_opcode_strings[idx],
				      3, PROG_PRINT_DEBUG, NULL);
d824 2
a825 1
	 printf("965 Opcode %d\n", insn->Opcode);
a828 5

/**
 * Initial pass for fragment program code generation.
 * This function is used by both the GLSL and non-GLSL paths.
 */
a830 1
   struct intel_context *intel = &c->func.brw->intel;
d834 4
a837 5
   if (unlikely(INTEL_DEBUG & DEBUG_WM)) {
      printf("pre-fp:\n");
      _mesa_fprint_program_opt(stdout, &fp->program.Base, PROG_PRINT_DEBUG,
			       GL_TRUE);
      printf("\n");
d841 1
a841 8
   if (intel->gen >= 6) {
      /* The interpolation deltas come in as the perspective pixel
       * location barycentric params.
       */
      c->delta_xy = src_reg(PROGRAM_PAYLOAD, PAYLOAD_DEPTH);
   } else {
      c->delta_xy = src_undef();
   }
a843 1
   c->fp->tex_units_used = 0x0;
d845 1
a845 3
   /* Emit preamble instructions.  This is where special instructions such as
    * WM_CINTERP, WM_LINTERP, WM_PINTERP and WM_WPOSXY are emitted to
    * compute shader inputs from varying vars.
a846 5
   for (insn = 0; insn < fp->program.Base.NumInstructions; insn++) {
      const struct prog_instruction *inst = &fp->program.Base.Instructions[insn];
      validate_src_regs(c, inst);
      validate_dst_regs(c, inst);
   }
d848 1
a848 3
   /* Loop over all instructions doing assorted simplifications and
    * transformations.
    */
d856 2
d868 1
a868 1
	 out->SrcReg[0].Negate = NEGATE_NONE;
d875 1
a875 1
	 out->SrcReg[1].Negate ^= NEGATE_XYZW;
d892 1
a892 10

      case OPCODE_RSQ:
	 out = emit_scalar_insn(c, inst);
	 out->SrcReg[0].Abs = GL_TRUE;
	 break;

      case OPCODE_TEX:
	 precalc_tex(c, inst);
	 break;

a896 6
      case OPCODE_TXB:
	 out = emit_insn(c, inst);
	 out->TexSrcUnit = fp->program.Base.SamplerUnits[inst->TexSrcUnit];
         assert(out->TexSrcUnit < BRW_MAX_TEX_UNIT);
	 break;

d910 1
a911 2
	 emit_render_target_writes(c);
	 break;
d914 1
d916 1
a916 4
	 if (brw_wm_is_scalar_result(inst->Opcode))
	    emit_scalar_insn(c, inst);
	 else
	    emit_insn(c, inst);
d920 4
d925 2
a926 2
   if (unlikely(INTEL_DEBUG & DEBUG_WM)) {
      printf("pass_fp:\n");
d928 1
a928 1
      printf("\n");
@


