head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.6
	OPENBSD_5_7_BASE:1.4
	v10_2_9:1.1.1.3
	v10_4_3:1.1.1.3
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.4;
commitid	TnlogFl9nOv2eaRf;

1.4
date	2013.09.05.14.04.15;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.14;	author matthieu;	state dead;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.37;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.37;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.28.17;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.15.24;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove the now unused Mesa 10.2.9 code
@
text
@#include "swrast/swrast.h"
#include "main/renderbuffer.h"
#include "main/texobj.h"
#include "main/teximage.h"
#include "main/mipmap.h"
#include "drivers/common/meta.h"
#include "intel_context.h"
#include "intel_mipmap_tree.h"
#include "intel_tex.h"
#include "intel_fbo.h"

#define FILE_DEBUG_FLAG DEBUG_TEXTURE

static struct gl_texture_image *
intelNewTextureImage(struct gl_context * ctx)
{
   DBG("%s\n", __FUNCTION__);
   (void) ctx;
   return (struct gl_texture_image *) CALLOC_STRUCT(intel_texture_image);
}

static void
intelDeleteTextureImage(struct gl_context * ctx, struct gl_texture_image *img)
{
   /* nothing special (yet) for intel_texture_image */
   _mesa_delete_texture_image(ctx, img);
}


static struct gl_texture_object *
intelNewTextureObject(struct gl_context * ctx, GLuint name, GLenum target)
{
   struct intel_texture_object *obj = CALLOC_STRUCT(intel_texture_object);

   (void) ctx;

   DBG("%s\n", __FUNCTION__);

   if (obj == NULL)
      return NULL;

   _mesa_initialize_texture_object(ctx, &obj->base, name, target);

   obj->needs_validate = true;

   return &obj->base;
}

static void 
intelDeleteTextureObject(struct gl_context *ctx,
			 struct gl_texture_object *texObj)
{
   struct intel_texture_object *intelObj = intel_texture_object(texObj);

   intel_miptree_release(&intelObj->mt);
   _mesa_delete_texture_object(ctx, texObj);
}

static GLboolean
intel_alloc_texture_image_buffer(struct gl_context *ctx,
				 struct gl_texture_image *image)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_texture_image *intel_image = intel_texture_image(image);
   struct gl_texture_object *texobj = image->TexObject;
   struct intel_texture_object *intel_texobj = intel_texture_object(texobj);

   assert(image->Border == 0);

   /* Because the driver uses AllocTextureImageBuffer() internally, it may end
    * up mismatched with FreeTextureImageBuffer(), but that is safe to call
    * multiple times.
    */
   ctx->Driver.FreeTextureImageBuffer(ctx, image);

   if (!_swrast_init_texture_image(image))
      return false;

   if (intel_texobj->mt &&
       intel_miptree_match_image(intel_texobj->mt, image)) {
      intel_miptree_reference(&intel_image->mt, intel_texobj->mt);
      DBG("%s: alloc obj %p level %d %dx%dx%d using object's miptree %p\n",
          __FUNCTION__, texobj, image->Level,
          image->Width, image->Height, image->Depth, intel_texobj->mt);
   } else {
      intel_image->mt = intel_miptree_create_for_teximage(intel, intel_texobj,
                                                          intel_image,
                                                          false);

      /* Even if the object currently has a mipmap tree associated
       * with it, this one is a more likely candidate to represent the
       * whole object since our level didn't fit what was there
       * before, and any lower levels would fit into our miptree.
       */
      intel_miptree_reference(&intel_texobj->mt, intel_image->mt);

      DBG("%s: alloc obj %p level %d %dx%dx%d using new miptree %p\n",
          __FUNCTION__, texobj, image->Level,
          image->Width, image->Height, image->Depth, intel_image->mt);
   }

   intel_texobj->needs_validate = true;

   return true;
}

static void
intel_free_texture_image_buffer(struct gl_context * ctx,
				struct gl_texture_image *texImage)
{
   struct intel_texture_image *intelImage = intel_texture_image(texImage);

   DBG("%s\n", __FUNCTION__);

   intel_miptree_release(&intelImage->mt);

   _swrast_free_texture_image_buffer(ctx, texImage);
}

/**
 * Map texture memory/buffer into user space.
 * Note: the region of interest parameters are ignored here.
 * \param mode  bitmask of GL_MAP_READ_BIT, GL_MAP_WRITE_BIT
 * \param mapOut  returns start of mapping of region of interest
 * \param rowStrideOut  returns row stride in bytes
 */
static void
intel_map_texture_image(struct gl_context *ctx,
			struct gl_texture_image *tex_image,
			GLuint slice,
			GLuint x, GLuint y, GLuint w, GLuint h,
			GLbitfield mode,
			GLubyte **map,
			GLint *stride)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_texture_image *intel_image = intel_texture_image(tex_image);
   struct intel_mipmap_tree *mt = intel_image->mt;

   /* Our texture data is always stored in a miptree. */
   assert(mt);

   /* Check that our caller wasn't confused about how to map a 1D texture. */
   assert(tex_image->TexObject->Target != GL_TEXTURE_1D_ARRAY ||
	  h == 1);

   /* intel_miptree_map operates on a unified "slice" number that references the
    * cube face, since it's all just slices to the miptree code.
    */
   if (tex_image->TexObject->Target == GL_TEXTURE_CUBE_MAP)
      slice = tex_image->Face;

   intel_miptree_map(intel, mt, tex_image->Level, slice, x, y, w, h, mode,
		     (void **)map, stride);
}

static void
intel_unmap_texture_image(struct gl_context *ctx,
			  struct gl_texture_image *tex_image, GLuint slice)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_texture_image *intel_image = intel_texture_image(tex_image);
   struct intel_mipmap_tree *mt = intel_image->mt;

   if (tex_image->TexObject->Target == GL_TEXTURE_CUBE_MAP)
      slice = tex_image->Face;

   intel_miptree_unmap(intel, mt, tex_image->Level, slice);
}

void
intelInitTextureFuncs(struct dd_function_table *functions)
{
   functions->NewTextureObject = intelNewTextureObject;
   functions->NewTextureImage = intelNewTextureImage;
   functions->DeleteTextureImage = intelDeleteTextureImage;
   functions->DeleteTexture = intelDeleteTextureObject;
   functions->AllocTextureImageBuffer = intel_alloc_texture_image_buffer;
   functions->FreeTextureImageBuffer = intel_free_texture_image_buffer;
   functions->MapTextureImage = intel_map_texture_image;
   functions->UnmapTextureImage = intel_unmap_texture_image;
}
@


1.4
log
@Merge Mesa 9.2.0
@
text
@@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@a0 39
/**************************************************************************
 * 
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **************************************************************************/

#include "glheader.h"
#include "mtypes.h"
#include "imports.h"
#include "macros.h"
#include "simple_list.h"
#include "enums.h"
#include "image.h"
#include "texstore.h"
#include "texformat.h"
#include "teximage.h"
#include "texmem.h"
#include "texobj.h"
d2 5
a6 5

#include "mm.h"

#include "intel_screen.h"
#include "intel_batchbuffer.h"
d8 1
d10 1
a10 1
#include "intel_ioctl.h"
d12 1
d14 2
a15 10

static GLboolean
intelValidateClientStorage( intelContextPtr intel, GLenum target,
			    GLint internalFormat,
			    GLint srcWidth, GLint srcHeight, 
			    GLenum format, GLenum type,  const void *pixels,
			    const struct gl_pixelstore_attrib *packing,
			    struct gl_texture_object *texObj,
			    struct gl_texture_image *texImage)

d17 3
a19 97
   GLcontext *ctx = &intel->ctx;
   int texelBytes;

   if (0)
      fprintf(stderr, "intformat %s format %s type %s\n",
	      _mesa_lookup_enum_by_nr( internalFormat ),
	      _mesa_lookup_enum_by_nr( format ),
	      _mesa_lookup_enum_by_nr( type ));

   if (!ctx->Unpack.ClientStorage)
      return 0;

   if (ctx->_ImageTransferState ||
       texImage->IsCompressed ||
       texObj->GenerateMipmap)
      return 0;


   /* This list is incomplete
    */
   switch ( internalFormat ) {
   case GL_RGBA:
      if ( format == GL_BGRA && type == GL_UNSIGNED_INT_8_8_8_8_REV ) {
	 texImage->TexFormat = &_mesa_texformat_argb8888;
	 texelBytes = 4;
      }
      else
	 return 0;
      break;

   case GL_RGB:
      if ( format == GL_RGB && type == GL_UNSIGNED_SHORT_5_6_5 ) {
	 texImage->TexFormat = &_mesa_texformat_rgb565;
	 texelBytes = 2;
      }
      else
	 return 0;
      break;

   case GL_YCBCR_MESA:
      if ( format == GL_YCBCR_MESA && 
	   type == GL_UNSIGNED_SHORT_8_8_REV_APPLE ) {
	 texImage->TexFormat = &_mesa_texformat_ycbcr_rev;
	 texelBytes = 2;
      }
      else if ( format == GL_YCBCR_MESA && 
		(type == GL_UNSIGNED_SHORT_8_8_APPLE || 
		 type == GL_UNSIGNED_BYTE)) {
	 texImage->TexFormat = &_mesa_texformat_ycbcr;
	 texelBytes = 2;
      }
      else
	 return 0;
      break;
      
	 
   default:
      return 0;
   }

   /* Could deal with these packing issues, but currently don't:
    */
   if (packing->SkipPixels || 
       packing->SkipRows || 
       packing->SwapBytes ||
       packing->LsbFirst) {
      return 0;
   }

   {      
      GLint srcRowStride = _mesa_image_row_stride(packing, srcWidth,
						  format, type);

      
      if (0)
	 fprintf(stderr, "%s: srcRowStride %d/%x\n", 
		 __FUNCTION__, srcRowStride, srcRowStride);

      /* Could check this later in upload, pitch restrictions could be
       * relaxed, but would need to store the image pitch somewhere,
       * as packing details might change before image is uploaded:
       */
      if (!intelIsAgpMemory( intel, pixels, srcHeight * srcRowStride ) ||
	  (srcRowStride & 63))
	 return 0;


      /* Have validated that _mesa_transfer_teximage would be a straight
       * memcpy at this point.  NOTE: future calls to TexSubImage will
       * overwrite the client data.  This is explicitly mentioned in the
       * extension spec.
       */
      texImage->Data = (void *)pixels;
      texImage->IsClientData = GL_TRUE;
      texImage->RowStride = srcRowStride / texelBytes;
      return 1;
   }
d22 2
a23 9
 

static void intelTexImage1D( GLcontext *ctx, GLenum target, GLint level,
			    GLint internalFormat,
			    GLint width, GLint border,
			    GLenum format, GLenum type, const GLvoid *pixels,
			    const struct gl_pixelstore_attrib *packing,
			    struct gl_texture_object *texObj,
			    struct gl_texture_image *texImage )
d25 3
a27 1
   driTextureObject * t = (driTextureObject *) texObj->DriverData;
a28 3
   assert(t);
   intelFlush( ctx );
   driSwapOutTextureObject( t );
d30 2
a31 19
   texImage->IsClientData = GL_FALSE;

   _mesa_store_teximage1d( ctx, target, level, internalFormat,
			   width, border, format, type,
			   pixels, packing, texObj, texImage );

   t->dirty_images[0] |= (1 << level);
}

static void intelTexSubImage1D( GLcontext *ctx, 
			       GLenum target,
			       GLint level,	
			       GLint xoffset,
				GLsizei width,
			       GLenum format, GLenum type,
			       const GLvoid *pixels,
			       const struct gl_pixelstore_attrib *packing,
			       struct gl_texture_object *texObj,
			       struct gl_texture_image *texImage )
d33 1
a33 1
   driTextureObject * t = (driTextureObject *) texObj->DriverData;
d35 1
a35 8
   assert(t);
   intelFlush( ctx );
   driSwapOutTextureObject( t );

   _mesa_store_texsubimage1d(ctx, target, level, xoffset, width, 
			     format, type, pixels, packing, texObj,
			     texImage);
}
d37 1
d39 2
a40 12
/* Handles 2D, CUBE, RECT:
 */
static void intelTexImage2D( GLcontext *ctx, GLenum target, GLint level,
			    GLint internalFormat,
			    GLint width, GLint height, GLint border,
			    GLenum format, GLenum type, const GLvoid *pixels,
			    const struct gl_pixelstore_attrib *packing,
			    struct gl_texture_object *texObj,
			    struct gl_texture_image *texImage )
{
   driTextureObject * t = (driTextureObject *) texObj->DriverData;
   GLuint face;
d42 1
a42 14
   /* which cube face or ordinary 2D image */
   switch (target) {
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
      face = (GLuint) target - (GLuint) GL_TEXTURE_CUBE_MAP_POSITIVE_X;
      ASSERT(face < 6);
      break;
   default:
      face = 0;
   }
d44 1
a44 17
   assert(t);
   intelFlush( ctx );
   driSwapOutTextureObject( t );
   texImage->IsClientData = GL_FALSE;

   if (intelValidateClientStorage( INTEL_CONTEXT(ctx), target, 
				   internalFormat, 
				   width, height, 
				   format, type, pixels, 
				   packing, texObj, texImage)) {
      if (INTEL_DEBUG & DEBUG_TEXTURE)
	 fprintf(stderr, "%s: Using client storage\n", __FUNCTION__); 
   }
   else {
      _mesa_store_teximage2d( ctx, target, level, internalFormat,
			      width, height, border, format, type,
			      pixels, packing, texObj, texImage );
d46 1
a46 2
      t->dirty_images[face] |= (1 << level);
   }
d49 3
a51 10
static void intelTexSubImage2D( GLcontext *ctx, 
			       GLenum target,
			       GLint level,	
			       GLint xoffset, GLint yoffset,
			       GLsizei width, GLsizei height,
			       GLenum format, GLenum type,
			       const GLvoid *pixels,
			       const struct gl_pixelstore_attrib *packing,
			       struct gl_texture_object *texObj,
			       struct gl_texture_image *texImage )
d53 1
a53 22
   driTextureObject * t = (driTextureObject *) texObj->DriverData;
   GLuint face;

   /* which cube face or ordinary 2D image */
   switch (target) {
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
      face = (GLuint) target - (GLuint) GL_TEXTURE_CUBE_MAP_POSITIVE_X;
      ASSERT(face < 6);
      break;
   default:
      face = 0;
   }

   if (texImage->IsClientData &&
       (char *)pixels == (char *)texImage->Data + 
       ((xoffset + yoffset * texImage->RowStride) * 
	texImage->TexFormat->TexelBytes)) {
d55 2
a56 13
      /* Notification only - no upload required */
   }
   else {
      assert( t ); /* this _should_ be true */
      intelFlush( ctx );
      driSwapOutTextureObject( t );

      _mesa_store_texsubimage2d(ctx, target, level, xoffset, yoffset, width, 
				height, format, type, pixels, packing, texObj,
				texImage);

      t->dirty_images[face] |= (1 << level);
   }
d59 3
a61 6
static void intelCompressedTexImage2D( GLcontext *ctx, GLenum target, GLint level,
                              GLint internalFormat,
                              GLint width, GLint height, GLint border,
                              GLsizei imageSize, const GLvoid *data,
                              struct gl_texture_object *texObj,
                              struct gl_texture_image *texImage )
d63 12
a74 2
   driTextureObject * t = (driTextureObject *) texObj->DriverData;
   GLuint face;
d76 2
a77 41
   /* which cube face or ordinary 2D image */
   switch (target) {
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
      face = (GLuint) target - (GLuint) GL_TEXTURE_CUBE_MAP_POSITIVE_X;
      ASSERT(face < 6);
      break;
   default:
      face = 0;
   }

   assert(t);
   intelFlush( ctx );
   
   driSwapOutTextureObject( t );
   texImage->IsClientData = GL_FALSE;

   if (INTEL_DEBUG & DEBUG_TEXTURE)
     fprintf(stderr, "%s: Using normal storage\n", __FUNCTION__); 
   
   _mesa_store_compressed_teximage2d(ctx, target, level, internalFormat, width,
				     height, border, imageSize, data, texObj, texImage);
   
   t->dirty_images[face] |= (1 << level);
}


static void intelCompressedTexSubImage2D( GLcontext *ctx, GLenum target, GLint level,
                                 GLint xoffset, GLint yoffset,
                                 GLsizei width, GLsizei height,
                                 GLenum format,
                                 GLsizei imageSize, const GLvoid *data,
                                 struct gl_texture_object *texObj,
                                 struct gl_texture_image *texImage )
{
   driTextureObject * t = (driTextureObject *) texObj->DriverData;
   GLuint face;
d79 17
d97 3
a99 13
   /* which cube face or ordinary 2D image */
   switch (target) {
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
      face = (GLuint) target - (GLuint) GL_TEXTURE_CUBE_MAP_POSITIVE_X;
      ASSERT(face < 6);
      break;
   default:
      face = 0;
d102 1
a102 10
   assert( t ); /* this _should_ be true */
   intelFlush( ctx );
   driSwapOutTextureObject( t );
   
   _mesa_store_compressed_texsubimage2d(ctx, target, level, xoffset, yoffset, width,
					height, format, imageSize, data, texObj, texImage);
   
   t->dirty_images[face] |= (1 << level);
}

d104 1
a104 21
static void intelTexImage3D( GLcontext *ctx, GLenum target, GLint level,
                            GLint internalFormat,
                            GLint width, GLint height, GLint depth,
                            GLint border,
                            GLenum format, GLenum type, const GLvoid *pixels,
                            const struct gl_pixelstore_attrib *packing,
                            struct gl_texture_object *texObj,
                            struct gl_texture_image *texImage )
{
   driTextureObject * t = (driTextureObject *) texObj->DriverData;

   assert(t);
   driSwapOutTextureObject( t );
   texImage->IsClientData = GL_FALSE;

   _mesa_store_teximage3d(ctx, target, level, internalFormat,
			  width, height, depth, border,
			  format, type, pixels,
			  &ctx->Unpack, texObj, texImage);
   
   t->dirty_images[0] |= (1 << level);
a106 1

d108 2
a109 8
intelTexSubImage3D( GLcontext *ctx, GLenum target, GLint level,
                   GLint xoffset, GLint yoffset, GLint zoffset,
                   GLsizei width, GLsizei height, GLsizei depth,
                   GLenum format, GLenum type,
                   const GLvoid *pixels,
                   const struct gl_pixelstore_attrib *packing,
                   struct gl_texture_object *texObj,
                   struct gl_texture_image *texImage )
d111 1
a111 1
   driTextureObject * t = (driTextureObject *) texObj->DriverData;
d113 1
a113 2
   assert( t ); /* this _should_ be true */
   driSwapOutTextureObject( t );
d115 1
a115 3
   _mesa_store_texsubimage3d(ctx, target, level, xoffset, yoffset, zoffset,
                             width, height, depth,
                             format, type, pixels, packing, texObj, texImage);
d117 1
a117 1
   t->dirty_images[0] |= (1 << level);
d120 6
a125 176



static void intelDeleteTexture( GLcontext *ctx, struct gl_texture_object *tObj )
{
   driTextureObject * t = (driTextureObject *) tObj->DriverData;

   if ( t != NULL ) {
      intelFlush( ctx );
      driDestroyTextureObject( t );
   }
   
   /* Free mipmap images and the texture object itself */
   _mesa_delete_texture_object(ctx, tObj);
}


static const struct gl_texture_format *
intelChooseTextureFormat( GLcontext *ctx, GLint internalFormat,
			 GLenum format, GLenum type )
{
   intelContextPtr intel = INTEL_CONTEXT( ctx );
   const GLboolean do32bpt = ( intel->intelScreen->cpp == 4 &&
			       intel->intelScreen->tex.size > 4*1024*1024);

   switch ( internalFormat ) {
   case 4:
   case GL_RGBA:
   case GL_COMPRESSED_RGBA:
      if ( format == GL_BGRA ) {
	 if ( type == GL_UNSIGNED_INT_8_8_8_8_REV ) {
	    return &_mesa_texformat_argb8888;
	 }
         else if ( type == GL_UNSIGNED_SHORT_4_4_4_4_REV ) {
            return &_mesa_texformat_argb4444;
	 }
         else if ( type == GL_UNSIGNED_SHORT_1_5_5_5_REV ) {
	    return &_mesa_texformat_argb1555;
	 }
      }
      return do32bpt ? &_mesa_texformat_argb8888 : &_mesa_texformat_argb4444;

   case 3:
   case GL_RGB:
   case GL_COMPRESSED_RGB:
      if ( format == GL_RGB && type == GL_UNSIGNED_SHORT_5_6_5 ) {
	 return &_mesa_texformat_rgb565;
      }
      return do32bpt ? &_mesa_texformat_argb8888 : &_mesa_texformat_rgb565;

   case GL_RGBA8:
   case GL_RGB10_A2:
   case GL_RGBA12:
   case GL_RGBA16:
      return do32bpt ? &_mesa_texformat_argb8888 : &_mesa_texformat_argb4444;

   case GL_RGBA4:
   case GL_RGBA2:
      return &_mesa_texformat_argb4444;

   case GL_RGB5_A1:
      return &_mesa_texformat_argb1555;

   case GL_RGB8:
   case GL_RGB10:
   case GL_RGB12:
   case GL_RGB16:
      return do32bpt ? &_mesa_texformat_argb8888 : &_mesa_texformat_rgb565;

   case GL_RGB5:
   case GL_RGB4:
   case GL_R3_G3_B2:
      return &_mesa_texformat_rgb565;

   case GL_ALPHA:
   case GL_ALPHA4:
   case GL_ALPHA8:
   case GL_ALPHA12:
   case GL_ALPHA16:
   case GL_COMPRESSED_ALPHA:
      return &_mesa_texformat_a8;

   case 1:
   case GL_LUMINANCE:
   case GL_LUMINANCE4:
   case GL_LUMINANCE8:
   case GL_LUMINANCE12:
   case GL_LUMINANCE16:
   case GL_COMPRESSED_LUMINANCE:
      return &_mesa_texformat_l8;

   case 2:
   case GL_LUMINANCE_ALPHA:
   case GL_LUMINANCE4_ALPHA4:
   case GL_LUMINANCE6_ALPHA2:
   case GL_LUMINANCE8_ALPHA8:
   case GL_LUMINANCE12_ALPHA4:
   case GL_LUMINANCE12_ALPHA12:
   case GL_LUMINANCE16_ALPHA16:
   case GL_COMPRESSED_LUMINANCE_ALPHA:
      return &_mesa_texformat_al88;

   case GL_INTENSITY:
   case GL_INTENSITY4:
   case GL_INTENSITY8:
   case GL_INTENSITY12:
   case GL_INTENSITY16:
   case GL_COMPRESSED_INTENSITY:
      return &_mesa_texformat_i8;

   case GL_YCBCR_MESA:
      if (type == GL_UNSIGNED_SHORT_8_8_MESA ||
	  type == GL_UNSIGNED_BYTE)
         return &_mesa_texformat_ycbcr;
      else
         return &_mesa_texformat_ycbcr_rev;

   case GL_COMPRESSED_RGB_FXT1_3DFX:
     return &_mesa_texformat_rgb_fxt1;
   case GL_COMPRESSED_RGBA_FXT1_3DFX:
     return &_mesa_texformat_rgba_fxt1;

   case GL_RGB_S3TC:
   case GL_RGB4_S3TC:
   case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
     return &_mesa_texformat_rgb_dxt1;

   case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
     return &_mesa_texformat_rgba_dxt1;

   case GL_RGBA_S3TC:
   case GL_RGBA4_S3TC:
   case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
     return &_mesa_texformat_rgba_dxt3;

   case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
      return &_mesa_texformat_rgba_dxt5;

   case GL_DEPTH_COMPONENT:
   case GL_DEPTH_COMPONENT16:
   case GL_DEPTH_COMPONENT24:
   case GL_DEPTH_COMPONENT32:
      return &_mesa_texformat_z16;

   default:
      fprintf(stderr, "unexpected texture format %s in %s\n", 
	      _mesa_lookup_enum_by_nr(internalFormat),
	      __FUNCTION__);
      return NULL;
   }

   return NULL; /* never get here */
}



void intelDestroyTexObj(intelContextPtr intel, intelTextureObjectPtr t)
{
   unsigned   i;

   if ( intel == NULL ) 
      return;

   if ( t->age > intel->dirtyAge )
      intel->dirtyAge = t->age;

   for ( i = 0 ; i < MAX_TEXTURE_UNITS ; i++ ) {
      if ( t == intel->CurrentTexObj[ i ] ) 
	 intel->CurrentTexObj[ i ] = NULL;
   }
}



/* Upload an image from mesa's internal copy.  Image may be 1D, 2D or
 * 3D.  Cubemaps are expanded elsewhere.
d127 19
a145 8
static void intelUploadTexImage( intelContextPtr intel,
				 intelTextureObjectPtr t,
				 const struct gl_texture_image *image,
				 const GLuint offset )
{

   if (!image || !image->Data) 
      return;
d147 2
a148 59
   if (image->Depth == 1 && image->IsClientData) {
      if (INTEL_DEBUG & DEBUG_TEXTURE)
	 fprintf(stderr, "Blit uploading\n");

      /* Do it with a blit.
       */
      intelEmitCopyBlitLocked( intel,
			       image->TexFormat->TexelBytes,
			       image->RowStride, /* ? */
			       intelGetMemoryOffsetMESA( NULL, 0, image->Data ),
			       t->Pitch / image->TexFormat->TexelBytes,
			       intelGetMemoryOffsetMESA( NULL, 0, t->BufAddr + offset ),
			       0, 0,
			       0, 0,
			       image->Width,
			       image->Height);
   }
   else if (image->IsCompressed) {
      GLuint row_len = 0;
      GLubyte *dst = (GLubyte *)(t->BufAddr + offset);
      GLubyte *src = (GLubyte *)image->Data;
      GLuint j;

      /* must always copy whole blocks (8/16 bytes) */
      switch (image->InternalFormat) {
	case GL_COMPRESSED_RGB_FXT1_3DFX:
	case GL_COMPRESSED_RGBA_FXT1_3DFX:
	case GL_RGB_S3TC:
	case GL_RGB4_S3TC:
	case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
	case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
	  row_len = (image->Width * 2 + 7) & ~7;
	  break;
	case GL_RGBA_S3TC:
	case GL_RGBA4_S3TC:
	case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
	case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
	  row_len = (image->Width * 4 + 15) & ~15;
	  break;
	default:
	  fprintf(stderr,"Internal Compressed format not supported %d\n", image->InternalFormat);
	  break;
      }

      if (INTEL_DEBUG & DEBUG_TEXTURE)
	 fprintf(stderr, 
		 "Upload image %dx%dx%d offset %xm row_len %x "
		 "pitch %x depth_pitch %x\n",
		 image->Width, image->Height, image->Depth, offset,
		 row_len, t->Pitch, t->depth_pitch);

      if (row_len) {
	 for (j = 0 ; j < (image->Height + 3)/4 ; j++, dst += (t->Pitch)) {
	   __memcpy(dst, src, row_len );
	   src += row_len;
	 }
      }
   }
   /* Time for another vtbl entry:
d150 2
a151 40
   else if (intel->intelScreen->deviceID == PCI_CHIP_I945_G ||
            intel->intelScreen->deviceID == PCI_CHIP_I945_GM ||
            intel->intelScreen->deviceID == PCI_CHIP_I945_GME ||
            intel->intelScreen->deviceID == PCI_CHIP_G33_G ||
            intel->intelScreen->deviceID == PCI_CHIP_Q33_G ||
            intel->intelScreen->deviceID == PCI_CHIP_Q35_G) {
      GLuint row_len = image->Width * image->TexFormat->TexelBytes;
      GLubyte *dst = (GLubyte *)(t->BufAddr + offset);
      GLubyte *src = (GLubyte *)image->Data;
      GLuint d, j;

      if (INTEL_DEBUG & DEBUG_TEXTURE)
	 fprintf(stderr, 
		 "Upload image %dx%dx%d offset %xm row_len %x "
		 "pitch %x depth_pitch %x\n",
		 image->Width, image->Height, image->Depth, offset,
		 row_len, t->Pitch, t->depth_pitch);

      if (row_len == t->Pitch) {
	 memcpy( dst, src, row_len * image->Height * image->Depth );
      }
      else { 
	 GLuint x = 0, y = 0;

	 for (d = 0 ; d < image->Depth ; d++) {
	    GLubyte *dst0 = dst + x + y * t->Pitch;

	    for (j = 0 ; j < image->Height ; j++) {
	       __memcpy(dst0, src, row_len );
	       src += row_len;
	       dst0 += t->Pitch;
	    }

	    x += MIN2(4, row_len); /* Guess: 4 byte minimum alignment */
	    if (x > t->Pitch) {
	       x = 0;
	       y += image->Height;
	    }
	 }
      }
d153 2
a154 33
   }
   else {
      GLuint row_len = image->Width * image->TexFormat->TexelBytes;
      GLubyte *dst = (GLubyte *)(t->BufAddr + offset);
      GLubyte *src = (GLubyte *)image->Data;
      GLuint d, j;

      if (INTEL_DEBUG & DEBUG_TEXTURE)
	 fprintf(stderr, 
		 "Upload image %dx%dx%d offset %xm row_len %x "
		 "pitch %x depth_pitch %x\n",
		 image->Width, image->Height, image->Depth, offset,
		 row_len, t->Pitch, t->depth_pitch);

      if (row_len == t->Pitch) {
	 for (d = 0; d < image->Depth; d++) {
	    memcpy( dst, src, t->Pitch * image->Height );
	    dst += t->depth_pitch;
	    src += row_len * image->Height;
	 }
      }
      else { 
	 for (d = 0 ; d < image->Depth ; d++) {
	    for (j = 0 ; j < image->Height ; j++) {
	       __memcpy(dst, src, row_len );
	       src += row_len;
	       dst += t->Pitch;
	    }

	    dst += t->depth_pitch - (t->Pitch * image->Height);
	 }
      }
   }
d157 3
a159 101


int intelUploadTexImages( intelContextPtr intel, 
			  intelTextureObjectPtr t,
			  GLuint face)
{
   const int numLevels = t->base.lastLevel - t->base.firstLevel + 1;
   const struct gl_texture_image *firstImage = t->image[face][t->base.firstLevel].image;
   int pitch = firstImage->RowStride * firstImage->TexFormat->TexelBytes;

   /* Can we texture out of the existing client data? */
   if ( numLevels == 1 &&
	firstImage->IsClientData &&
	(pitch & 3) == 0) {

      if (INTEL_DEBUG & DEBUG_TEXTURE)
	 fprintf(stderr, "AGP texturing from client memory\n");

      t->TextureOffset = intelAgpOffsetFromVirtual( intel, firstImage->Data );
      t->BufAddr = 0;
      t->dirty = ~0;
      return GL_TRUE;
   }
   else {
      if (INTEL_DEBUG & DEBUG_TEXTURE) 
	 fprintf(stderr, "Uploading client data to agp\n");

      INTEL_FIREVERTICES( intel );
      LOCK_HARDWARE( intel );

      if ( t->base.memBlock == NULL ) {
	 int heap;

	 heap = driAllocateTexture( intel->texture_heaps, intel->nr_heaps,
				    (driTextureObject *) t );
	 if ( heap == -1 ) {
	    UNLOCK_HARDWARE( intel );
	    return GL_FALSE;
	 }

	 /* Set the base offset of the texture image */
	 t->BufAddr = (GLubyte *) (intel->intelScreen->tex.map + 
				   t->base.memBlock->ofs);
	 t->TextureOffset = intel->intelScreen->tex.offset + t->base.memBlock->ofs;
	 t->dirty = ~0;
      }


      /* Let the world know we've used this memory recently.
       */
      driUpdateTextureLRU( (driTextureObject *) t );


      /* Upload any images that are new */
      if (t->base.dirty_images[face]) {
	 int i;

 	 intelWaitForIdle( intel );
	    
	 for (i = 0 ; i < numLevels ; i++) { 
	    int level = i + t->base.firstLevel;

	    if (t->base.dirty_images[face] & (1<<level)) {

	       const struct gl_texture_image *image = t->image[face][i].image;
	       GLuint offset = t->image[face][i].offset;

     	       if (INTEL_DEBUG & DEBUG_TEXTURE)
	          fprintf(stderr, "upload level %d, offset %x\n", 
			  level, offset);

	       intelUploadTexImage( intel, t, image, offset );
	    }
	 }
	 t->base.dirty_images[face] = 0;
	 intel->perf_boxes |= I830_BOX_TEXTURE_LOAD;
      }
      
      UNLOCK_HARDWARE( intel );
      return GL_TRUE;
   }
}

/**
 * Allocate a new texture object.
 * Called via ctx->Driver.NewTextureObject.
 * Note: this function will be called during context creation to
 * allocate the default texture objects.
 * Note: we could use containment here to 'derive' the driver-specific
 * texture object from the core mesa gl_texture_object.  Not done at this time.
 */
static struct gl_texture_object *
intelNewTextureObject( GLcontext *ctx, GLuint name, GLenum target )
{
   struct gl_texture_object *obj = _mesa_new_texture_object(ctx, name, target);
   INTEL_CONTEXT(ctx)->vtbl.alloc_tex_obj( obj );
   return obj;
}


void intelInitTextureFuncs( struct dd_function_table *functions )
d161 21
a181 20
   functions->NewTextureObject          = intelNewTextureObject;
   functions->ChooseTextureFormat       = intelChooseTextureFormat;
   functions->TexImage1D                = intelTexImage1D;
   functions->TexImage2D                = intelTexImage2D;
   functions->TexImage3D                = intelTexImage3D;
   functions->TexSubImage1D             = intelTexSubImage1D;
   functions->TexSubImage2D             = intelTexSubImage2D;
   functions->TexSubImage3D             = intelTexSubImage3D;
   functions->CopyTexImage1D            = _swrast_copy_teximage1d;
   functions->CopyTexImage2D            = _swrast_copy_teximage2d;
   functions->CopyTexSubImage1D         = _swrast_copy_texsubimage1d;
   functions->CopyTexSubImage2D         = _swrast_copy_texsubimage2d;
   functions->CopyTexSubImage3D         = _swrast_copy_texsubimage3d;
   functions->DeleteTexture             = intelDeleteTexture;
   functions->UpdateTexturePalette      = NULL;
   functions->IsTextureResident         = driIsTextureResident;
   functions->TestProxyTexImage         = _mesa_test_proxy_teximage;
   functions->DeleteTexture             = intelDeleteTexture;
   functions->CompressedTexImage2D      = intelCompressedTexImage2D;
   functions->CompressedTexSubImage2D   = intelCompressedTexSubImage2D;
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@@


1.1
log
@Initial revision
@
text
@d637 1
a637 1
      GLuint row_len = image->Width * 2;
d642 1
a642 7
      if (INTEL_DEBUG & DEBUG_TEXTURE)
	 fprintf(stderr, 
		 "Upload image %dx%dx%d offset %xm row_len %x "
		 "pitch %x depth_pitch %x\n",
		 image->Width, image->Height, image->Depth, offset,
		 row_len, t->Pitch, t->depth_pitch);

d650 1
a650 4
	  for (j = 0 ; j < image->Height/4 ; j++, dst += (t->Pitch)) {
	    __memcpy(dst, src, row_len );
	    src += row_len;
	  }
d656 1
a656 4
	  for (j = 0 ; j < image->Height/4 ; j++, dst += (t->Pitch)) {
	    __memcpy(dst, src, (image->Width*4) );
	    src += image->Width*4;
	  }
d662 14
d680 5
a684 1
            intel->intelScreen->deviceID == PCI_CHIP_I945_GM) {
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@d637 1
a637 1
      GLuint row_len = 0;
d642 7
a648 1
      /* must always copy whole blocks (8/16 bytes) */
d656 4
a659 1
	  row_len = (image->Width * 2 + 7) & ~7;
d665 4
a668 1
	  row_len = (image->Width * 4 + 15) & ~15;
a672 14
      }

      if (INTEL_DEBUG & DEBUG_TEXTURE)
	 fprintf(stderr, 
		 "Upload image %dx%dx%d offset %xm row_len %x "
		 "pitch %x depth_pitch %x\n",
		 image->Width, image->Height, image->Depth, offset,
		 row_len, t->Pitch, t->depth_pitch);

      if (row_len) {
	 for (j = 0 ; j < (image->Height + 3)/4 ; j++, dst += (t->Pitch)) {
	   __memcpy(dst, src, row_len );
	   src += row_len;
	 }
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d1 39
d41 5
a45 5
#include "main/renderbuffer.h"
#include "main/texobj.h"
#include "main/teximage.h"
#include "main/mipmap.h"
#include "drivers/common/meta.h"
a46 1
#include "intel_mipmap_tree.h"
d48 124
a171 1
#include "intel_fbo.h"
d173 3
a175 1
#define FILE_DEBUG_FLAG DEBUG_TEXTURE
d177 19
a195 2
static struct gl_texture_image *
intelNewTextureImage(struct gl_context * ctx)
d197 9
a205 3
   DBG("%s\n", __FUNCTION__);
   (void) ctx;
   return (struct gl_texture_image *) CALLOC_STRUCT(intel_texture_image);
d208 10
a217 2
static void
intelDeleteTextureImage(struct gl_context * ctx, struct gl_texture_image *img)
d219 38
a256 2
   /* nothing special (yet) for intel_texture_image */
   _mesa_delete_texture_image(ctx, img);
d259 48
d308 6
a313 2
static struct gl_texture_object *
intelNewTextureObject(struct gl_context * ctx, GLuint name, GLenum target)
d315 2
a316 1
   struct intel_texture_object *obj = CALLOC_STRUCT(intel_texture_object);
d318 29
a346 1
   (void) ctx;
a347 1
   DBG("%s\n", __FUNCTION__);
d349 10
a358 2
   if (obj == NULL)
      return NULL;
a359 1
   _mesa_initialize_texture_object(ctx, &obj->base, name, target);
d361 14
a374 1
   obj->needs_validate = true;
d376 8
a383 1
   return &obj->base;
d386 9
a394 3
static void 
intelDeleteTextureObject(struct gl_context *ctx,
			 struct gl_texture_object *texObj)
d396 1
a396 1
   struct intel_texture_object *intelObj = intel_texture_object(texObj);
d398 10
a407 2
   intel_miptree_release(&intelObj->mt);
   _mesa_delete_texture_object(ctx, texObj);
d410 10
a419 3
static GLboolean
intel_alloc_texture_image_buffer(struct gl_context *ctx,
				 struct gl_texture_image *image)
d421 13
a433 12
   struct intel_context *intel = intel_context(ctx);
   struct intel_texture_image *intel_image = intel_texture_image(image);
   struct gl_texture_object *texobj = image->TexObject;
   struct intel_texture_object *intel_texobj = intel_texture_object(texobj);

   assert(image->Border == 0);

   /* Because the driver uses AllocTextureImageBuffer() internally, it may end
    * up mismatched with FreeTextureImageBuffer(), but that is safe to call
    * multiple times.
    */
   ctx->Driver.FreeTextureImageBuffer(ctx, image);
a434 2
   if (!_swrast_init_texture_image(image))
      return false;
d436 3
a438 17
   if (intel_texobj->mt &&
       intel_miptree_match_image(intel_texobj->mt, image)) {
      intel_miptree_reference(&intel_image->mt, intel_texobj->mt);
      DBG("%s: alloc obj %p level %d %dx%dx%d using object's miptree %p\n",
          __FUNCTION__, texobj, image->Level,
          image->Width, image->Height, image->Depth, intel_texobj->mt);
   } else {
      intel_image->mt = intel_miptree_create_for_teximage(intel, intel_texobj,
                                                          intel_image,
                                                          false);

      /* Even if the object currently has a mipmap tree associated
       * with it, this one is a more likely candidate to represent the
       * whole object since our level didn't fit what was there
       * before, and any lower levels would fit into our miptree.
       */
      intel_miptree_reference(&intel_texobj->mt, intel_image->mt);
d440 3
a442 3
      DBG("%s: alloc obj %p level %d %dx%dx%d using new miptree %p\n",
          __FUNCTION__, texobj, image->Level,
          image->Width, image->Height, image->Depth, intel_image->mt);
d444 4
a448 1
   intel_texobj->needs_validate = true;
d450 135
a584 1
   return true;
d587 3
a589 3
static void
intel_free_texture_image_buffer(struct gl_context * ctx,
				struct gl_texture_image *texImage)
d591 1
a591 1
   struct intel_texture_image *intelImage = intel_texture_image(texImage);
d593 2
a594 1
   DBG("%s\n", __FUNCTION__);
d596 2
a597 1
   intel_miptree_release(&intelImage->mt);
d599 4
a602 1
   _swrast_free_texture_image_buffer(ctx, texImage);
d605 4
a608 6
/**
 * Map texture memory/buffer into user space.
 * Note: the region of interest parameters are ignored here.
 * \param mode  bitmask of GL_MAP_READ_BIT, GL_MAP_WRITE_BIT
 * \param mapOut  returns start of mapping of region of interest
 * \param rowStrideOut  returns row stride in bytes
d610 12
a621 19
static void
intel_map_texture_image(struct gl_context *ctx,
			struct gl_texture_image *tex_image,
			GLuint slice,
			GLuint x, GLuint y, GLuint w, GLuint h,
			GLbitfield mode,
			GLubyte **map,
			GLint *stride)
{
   struct intel_context *intel = intel_context(ctx);
   struct intel_texture_image *intel_image = intel_texture_image(tex_image);
   struct intel_mipmap_tree *mt = intel_image->mt;

   /* Our texture data is always stored in a miptree. */
   assert(mt);

   /* Check that our caller wasn't confused about how to map a 1D texture. */
   assert(tex_image->TexObject->Target != GL_TEXTURE_1D_ARRAY ||
	  h == 1);
d623 55
a677 2
   /* intel_miptree_map operates on a unified "slice" number that references the
    * cube face, since it's all just slices to the miptree code.
d679 154
a832 2
   if (tex_image->TexObject->Target == GL_TEXTURE_CUBE_MAP)
      slice = tex_image->Face;
d834 14
a847 2
   intel_miptree_map(intel, mt, tex_image->Level, slice, x, y, w, h, mode,
		     (void **)map, stride);
d850 2
a851 3
static void
intel_unmap_texture_image(struct gl_context *ctx,
			  struct gl_texture_image *tex_image, GLuint slice)
d853 20
a872 21
   struct intel_context *intel = intel_context(ctx);
   struct intel_texture_image *intel_image = intel_texture_image(tex_image);
   struct intel_mipmap_tree *mt = intel_image->mt;

   if (tex_image->TexObject->Target == GL_TEXTURE_CUBE_MAP)
      slice = tex_image->Face;

   intel_miptree_unmap(intel, mt, tex_image->Level, slice);
}

void
intelInitTextureFuncs(struct dd_function_table *functions)
{
   functions->NewTextureObject = intelNewTextureObject;
   functions->NewTextureImage = intelNewTextureImage;
   functions->DeleteTextureImage = intelDeleteTextureImage;
   functions->DeleteTexture = intelDeleteTextureObject;
   functions->AllocTextureImageBuffer = intel_alloc_texture_image_buffer;
   functions->FreeTextureImageBuffer = intel_free_texture_image_buffer;
   functions->MapTextureImage = intel_map_texture_image;
   functions->UnmapTextureImage = intel_unmap_texture_image;
@


