head	1.8;
access;
symbols
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	v7_10_3:1.1.1.4
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v7_0_1:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v6_5_2:1.1.1.2
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2013.09.05.14.05.03;	author jsg;	state dead;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.22.20.06.23;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.17.20.26.40;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.14.58.17;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.53.32;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.53.32;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.57.28;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.29.26;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.10.23.13.29.41;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge Mesa 9.2.0
@
text
@/*
Copyright (C) The Weather Channel, Inc.  2002.
Copyright (C) 2004 Nicolai Haehnle.
All Rights Reserved.

The Weather Channel (TM) funded Tungsten Graphics to develop the
initial release of the Radeon 8500 driver under the XFree86 license.
This notice must be preserved.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial
portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/**
 * \file
 *
 * \author Nicolai Haehnle <prefect_@@gmx.net>
 */

#include "main/glheader.h"
#include "main/state.h"
#include "main/imports.h"
#include "main/enums.h"
#include "main/macros.h"
#include "main/context.h"
#include "main/dd.h"
#include "main/framebuffer.h"
#include "main/simple_list.h"
#include "main/api_arrayelt.h"

#include "drivers/common/meta.h"
#include "swrast/swrast.h"
#include "swrast_setup/swrast_setup.h"
#include "program/prog_parameter.h"
#include "program/prog_statevars.h"
#include "vbo/vbo.h"
#include "tnl/tnl.h"

#include "r300_context.h"
#include "r300_state.h"
#include "r300_reg.h"
#include "r300_emit.h"
#include "r300_fragprog_common.h"
#include "r300_render.h"
#include "r300_vertprog.h"

static void r300BlendColor(struct gl_context * ctx, const GLfloat cf[4])
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);

	R300_STATECHANGE(rmesa, blend_color);

	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
		GLuint r = IROUND(cf[0]*1023.0f);
		GLuint g = IROUND(cf[1]*1023.0f);
		GLuint b = IROUND(cf[2]*1023.0f);
		GLuint a = IROUND(cf[3]*1023.0f);

		rmesa->hw.blend_color.cmd[1] = r | (a << 16);
		rmesa->hw.blend_color.cmd[2] = b | (g << 16);
	} else {
		GLubyte color[4];
		CLAMPED_FLOAT_TO_UBYTE(color[0], cf[0]);
		CLAMPED_FLOAT_TO_UBYTE(color[1], cf[1]);
		CLAMPED_FLOAT_TO_UBYTE(color[2], cf[2]);
		CLAMPED_FLOAT_TO_UBYTE(color[3], cf[3]);

		rmesa->hw.blend_color.cmd[1] = PACK_COLOR_8888(color[3], color[0],
							color[1], color[2]);
	}
}

/**
 * Calculate the hardware blend factor setting.  This same function is used
 * for source and destination of both alpha and RGB.
 *
 * \returns
 * The hardware register value for the specified blend factor.  This value
 * will need to be shifted into the correct position for either source or
 * destination factor.
 *
 * \todo
 * Since the two cases where source and destination are handled differently
 * are essentially error cases, they should never happen.  Determine if these
 * cases can be removed.
 */
static int blend_factor(GLenum factor, GLboolean is_src)
{
	switch (factor) {
	case GL_ZERO:
		return R300_BLEND_GL_ZERO;
		break;
	case GL_ONE:
		return R300_BLEND_GL_ONE;
		break;
	case GL_DST_COLOR:
		return R300_BLEND_GL_DST_COLOR;
		break;
	case GL_ONE_MINUS_DST_COLOR:
		return R300_BLEND_GL_ONE_MINUS_DST_COLOR;
		break;
	case GL_SRC_COLOR:
		return R300_BLEND_GL_SRC_COLOR;
		break;
	case GL_ONE_MINUS_SRC_COLOR:
		return R300_BLEND_GL_ONE_MINUS_SRC_COLOR;
		break;
	case GL_SRC_ALPHA:
		return R300_BLEND_GL_SRC_ALPHA;
		break;
	case GL_ONE_MINUS_SRC_ALPHA:
		return R300_BLEND_GL_ONE_MINUS_SRC_ALPHA;
		break;
	case GL_DST_ALPHA:
		return R300_BLEND_GL_DST_ALPHA;
		break;
	case GL_ONE_MINUS_DST_ALPHA:
		return R300_BLEND_GL_ONE_MINUS_DST_ALPHA;
		break;
	case GL_SRC_ALPHA_SATURATE:
		return (is_src) ? R300_BLEND_GL_SRC_ALPHA_SATURATE :
		    R300_BLEND_GL_ZERO;
		break;
	case GL_CONSTANT_COLOR:
		return R300_BLEND_GL_CONST_COLOR;
		break;
	case GL_ONE_MINUS_CONSTANT_COLOR:
		return R300_BLEND_GL_ONE_MINUS_CONST_COLOR;
		break;
	case GL_CONSTANT_ALPHA:
		return R300_BLEND_GL_CONST_ALPHA;
		break;
	case GL_ONE_MINUS_CONSTANT_ALPHA:
		return R300_BLEND_GL_ONE_MINUS_CONST_ALPHA;
		break;
	default:
		fprintf(stderr, "unknown blend factor %x\n", factor);
		return (is_src) ? R300_BLEND_GL_ONE : R300_BLEND_GL_ZERO;
		break;
	}
}

/**
 * Sets both the blend equation and the blend function.
 * This is done in a single
 * function because some blend equations (i.e., \c GL_MIN and \c GL_MAX)
 * change the interpretation of the blend function.
 * Also, make sure that blend function and blend equation are set to their
 * default value if color blending is not enabled, since at least blend
 * equations GL_MIN and GL_FUNC_REVERSE_SUBTRACT will cause wrong results
 * otherwise for unknown reasons.
 */

/* helper function */
static void r300SetBlendCntl(r300ContextPtr r300, int func, int eqn,
			     int cbits, int funcA, int eqnA)
{
	GLuint new_ablend, new_cblend;

#if 0
	fprintf(stderr,
		"eqnA=%08x funcA=%08x eqn=%08x func=%08x cbits=%08x\n",
		eqnA, funcA, eqn, func, cbits);
#endif
	new_ablend = eqnA | funcA;
	new_cblend = eqn | func;

	/* Some blend factor combinations don't seem to work when the
	 * BLEND_NO_SEPARATE bit is set.
	 *
	 * Especially problematic candidates are the ONE_MINUS_* flags,
	 * but I can't see a real pattern.
	 */
#if 0
	if (new_ablend == new_cblend) {
		new_cblend |= R300_DISCARD_SRC_PIXELS_SRC_ALPHA_0;
	}
#endif
	new_cblend |= cbits;

	if ((new_ablend != r300->hw.bld.cmd[R300_BLD_ABLEND]) ||
	    (new_cblend != r300->hw.bld.cmd[R300_BLD_CBLEND])) {
		R300_STATECHANGE(r300, bld);
		r300->hw.bld.cmd[R300_BLD_ABLEND] = new_ablend;
		r300->hw.bld.cmd[R300_BLD_CBLEND] = new_cblend;
	}
}

static void r300SetBlendState(struct gl_context * ctx)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	int func = (R300_BLEND_GL_ONE << R300_SRC_BLEND_SHIFT) |
	    (R300_BLEND_GL_ZERO << R300_DST_BLEND_SHIFT);
	int eqn = R300_COMB_FCN_ADD_CLAMP;
	int funcA = (R300_BLEND_GL_ONE << R300_SRC_BLEND_SHIFT) |
	    (R300_BLEND_GL_ZERO << R300_DST_BLEND_SHIFT);
	int eqnA = R300_COMB_FCN_ADD_CLAMP;

	if (_mesa_rgba_logicop_enabled(ctx) || !ctx->Color.BlendEnabled) {
		r300SetBlendCntl(r300, func, eqn, 0, func, eqn);
		return;
	}

	func =
	    (blend_factor(ctx->Color.Blend[0].SrcRGB, GL_TRUE) <<
	     R300_SRC_BLEND_SHIFT) | (blend_factor(ctx->Color.Blend[0].DstRGB,
						   GL_FALSE) <<
				      R300_DST_BLEND_SHIFT);

	switch (ctx->Color.Blend[0].EquationRGB) {
	case GL_FUNC_ADD:
		eqn = R300_COMB_FCN_ADD_CLAMP;
		break;

	case GL_FUNC_SUBTRACT:
		eqn = R300_COMB_FCN_SUB_CLAMP;
		break;

	case GL_FUNC_REVERSE_SUBTRACT:
		eqn = R300_COMB_FCN_RSUB_CLAMP;
		break;

	case GL_MIN:
		eqn = R300_COMB_FCN_MIN;
		func = (R300_BLEND_GL_ONE << R300_SRC_BLEND_SHIFT) |
		    (R300_BLEND_GL_ONE << R300_DST_BLEND_SHIFT);
		break;

	case GL_MAX:
		eqn = R300_COMB_FCN_MAX;
		func = (R300_BLEND_GL_ONE << R300_SRC_BLEND_SHIFT) |
		    (R300_BLEND_GL_ONE << R300_DST_BLEND_SHIFT);
		break;

	default:
		fprintf(stderr,
			"[%s:%u] Invalid RGB blend equation (0x%04x).\n",
			__FUNCTION__, __LINE__, ctx->Color.Blend[0].EquationRGB);
		return;
	}

	funcA =
	    (blend_factor(ctx->Color.Blend[0].SrcA, GL_TRUE) <<
	     R300_SRC_BLEND_SHIFT) | (blend_factor(ctx->Color.Blend[0].DstA,
						   GL_FALSE) <<
				      R300_DST_BLEND_SHIFT);

	switch (ctx->Color.Blend[0].EquationA) {
	case GL_FUNC_ADD:
		eqnA = R300_COMB_FCN_ADD_CLAMP;
		break;

	case GL_FUNC_SUBTRACT:
		eqnA = R300_COMB_FCN_SUB_CLAMP;
		break;

	case GL_FUNC_REVERSE_SUBTRACT:
		eqnA = R300_COMB_FCN_RSUB_CLAMP;
		break;

	case GL_MIN:
		eqnA = R300_COMB_FCN_MIN;
		funcA = (R300_BLEND_GL_ONE << R300_SRC_BLEND_SHIFT) |
		    (R300_BLEND_GL_ONE << R300_DST_BLEND_SHIFT);
		break;

	case GL_MAX:
		eqnA = R300_COMB_FCN_MAX;
		funcA = (R300_BLEND_GL_ONE << R300_SRC_BLEND_SHIFT) |
		    (R300_BLEND_GL_ONE << R300_DST_BLEND_SHIFT);
		break;

	default:
		fprintf(stderr,
			"[%s:%u] Invalid A blend equation (0x%04x).\n",
			__FUNCTION__, __LINE__, ctx->Color.Blend[0].EquationA);
		return;
	}

	r300SetBlendCntl(r300,
			 func, eqn,
			 (R300_SEPARATE_ALPHA_ENABLE |
			  R300_READ_ENABLE |
			  R300_ALPHA_BLEND_ENABLE), funcA, eqnA);
}

static void r300BlendEquationSeparate(struct gl_context * ctx,
				      GLenum modeRGB, GLenum modeA)
{
	r300SetBlendState(ctx);
}

static void r300BlendFuncSeparate(struct gl_context * ctx,
				  GLenum sfactorRGB, GLenum dfactorRGB,
				  GLenum sfactorA, GLenum dfactorA)
{
	r300SetBlendState(ctx);
}

/**
 * Translate LogicOp enums into hardware representation.
 * Both use a very logical bit-wise layout, but unfortunately the order
 * of bits is reversed.
 */
static GLuint translate_logicop(GLenum logicop)
{
	GLuint bits = logicop - GL_CLEAR;
	bits = ((bits & 1) << 3) | ((bits & 2) << 1) | ((bits & 4) >> 1) | ((bits & 8) >> 3);
	return bits << R300_RB3D_ROPCNTL_ROP_SHIFT;
}

/**
 * Used internally to update the r300->hw hardware state to match the
 * current OpenGL state.
 */
static void r300SetLogicOpState(struct gl_context *ctx)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	R300_STATECHANGE(r300, rop);
	if (_mesa_rgba_logicop_enabled(ctx)) {
		r300->hw.rop.cmd[1] = R300_RB3D_ROPCNTL_ROP_ENABLE |
			translate_logicop(ctx->Color.LogicOp);
	} else {
		r300->hw.rop.cmd[1] = 0;
	}
}

/**
 * Called by Mesa when an application program changes the LogicOp state
 * via glLogicOp.
 */
static void r300LogicOpcode(struct gl_context *ctx, GLenum logicop)
{
	if (_mesa_rgba_logicop_enabled(ctx))
		r300SetLogicOpState(ctx);
}

static void r300ClipPlane( struct gl_context *ctx, GLenum plane, const GLfloat *eq )
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	GLint p;
	GLint *ip;

	/* no VAP UCP on non-TCL chipsets */
	if (!rmesa->options.hw_tcl_enabled)
			return;

	p = (GLint) plane - (GLint) GL_CLIP_PLANE0;
	ip = (GLint *)ctx->Transform._ClipUserPlane[p];

	R300_STATECHANGE( rmesa, vpucp[p] );
	rmesa->hw.vpucp[p].cmd[R300_VPUCP_X] = ip[0];
	rmesa->hw.vpucp[p].cmd[R300_VPUCP_Y] = ip[1];
	rmesa->hw.vpucp[p].cmd[R300_VPUCP_Z] = ip[2];
	rmesa->hw.vpucp[p].cmd[R300_VPUCP_W] = ip[3];
}

static void r300SetClipPlaneState(struct gl_context * ctx, GLenum cap, GLboolean state)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	GLuint p;

	/* no VAP UCP on non-TCL chipsets */
	if (!r300->options.hw_tcl_enabled)
		return;

	p = cap - GL_CLIP_PLANE0;
	R300_STATECHANGE(r300, vap_clip_cntl);
	if (state) {
		r300->hw.vap_clip_cntl.cmd[1] |= (R300_VAP_UCP_ENABLE_0 << p);
		r300ClipPlane(ctx, cap, NULL);
	} else {
		r300->hw.vap_clip_cntl.cmd[1] &= ~(R300_VAP_UCP_ENABLE_0 << p);
	}
}

/**
 * Update our tracked culling state based on Mesa's state.
 */
static void r300UpdateCulling(struct gl_context * ctx)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	uint32_t val = 0;

	if (ctx->Polygon.CullFlag) {
		switch (ctx->Polygon.CullFaceMode) {
		case GL_FRONT:
			val = R300_CULL_FRONT;
			break;
		case GL_BACK:
			val = R300_CULL_BACK;
			break;
		case GL_FRONT_AND_BACK:
			val = R300_CULL_FRONT | R300_CULL_BACK;
			break;
		default:
			break;
		}
	}

	switch (ctx->Polygon.FrontFace) {
	case GL_CW:
		val |= R300_FRONT_FACE_CW;
		break;
	case GL_CCW:
		val |= R300_FRONT_FACE_CCW;
		break;
	default:
		break;
	}

	/* Winding is inverted when rendering to FBO */
	if (ctx->DrawBuffer && ctx->DrawBuffer->Name)
		val ^= R300_FRONT_FACE_CW;

	R300_STATECHANGE(r300, cul);
	r300->hw.cul.cmd[R300_CUL_CULL] = val;
}

static void r300SetPolygonOffsetState(struct gl_context * ctx, GLboolean state)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);

	R300_STATECHANGE(r300, occlusion_cntl);
	if (state) {
		r300->hw.occlusion_cntl.cmd[1] |= (3 << 0);
	} else {
		r300->hw.occlusion_cntl.cmd[1] &= ~(3 << 0);
	}
}

static GLboolean current_fragment_program_writes_depth(struct gl_context* ctx)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);

	return ctx->FragmentProgram._Current && r300->selected_fp->code.writes_depth;
}

static void r300SetEarlyZState(struct gl_context * ctx)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	GLuint topZ = R300_ZTOP_ENABLE;
	GLuint w_fmt, fgdepthsrc;

	if (ctx->Color.AlphaEnabled && ctx->Color.AlphaFunc != GL_ALWAYS)
		topZ = R300_ZTOP_DISABLE;
	else if (current_fragment_program_writes_depth(ctx))
		topZ = R300_ZTOP_DISABLE;
	else if (ctx->FragmentProgram._Current && ctx->FragmentProgram._Current->UsesKill)
		topZ = R300_ZTOP_DISABLE;
	else if (r300->radeon.query.current)
		topZ = R300_ZTOP_DISABLE;

	if (topZ != r300->hw.zstencil_format.cmd[2]) {
		/* Note: This completely reemits the stencil format.
		 * I have not tested whether this is strictly necessary,
		 * or if emitting a write to ZB_ZTOP is enough.
		 */
		R300_STATECHANGE(r300, zstencil_format);
		r300->hw.zstencil_format.cmd[2] = topZ;
	}

	/* w_fmt value is set to get best performance
	* see p.130 R5xx 3D acceleration guide v1.3 */
	if (current_fragment_program_writes_depth(ctx)) {
		fgdepthsrc = R300_FG_DEPTH_SRC_SHADER;
		w_fmt = R300_W_FMT_W24 | R300_W_SRC_US;
	} else {
		fgdepthsrc = R300_FG_DEPTH_SRC_SCAN;
		w_fmt = R300_W_FMT_W0 | R300_W_SRC_US;
	}

	if (w_fmt != r300->hw.us_out_fmt.cmd[5]) {
		R300_STATECHANGE(r300, us_out_fmt);
		r300->hw.us_out_fmt.cmd[5] = w_fmt;
	}

	if (fgdepthsrc != r300->hw.fg_depth_src.cmd[1]) {
		R300_STATECHANGE(r300, fg_depth_src);
		r300->hw.fg_depth_src.cmd[1] = fgdepthsrc;
	}
}

static void r300SetAlphaState(struct gl_context * ctx)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	GLubyte refByte;
	uint32_t pp_misc = 0x0;
	GLboolean really_enabled = ctx->Color.AlphaEnabled;

	CLAMPED_FLOAT_TO_UBYTE(refByte, ctx->Color.AlphaRef);

	switch (ctx->Color.AlphaFunc) {
	case GL_NEVER:
		pp_misc |= R300_FG_ALPHA_FUNC_NEVER;
		break;
	case GL_LESS:
		pp_misc |= R300_FG_ALPHA_FUNC_LESS;
		break;
	case GL_EQUAL:
		pp_misc |= R300_FG_ALPHA_FUNC_EQUAL;
		break;
	case GL_LEQUAL:
		pp_misc |= R300_FG_ALPHA_FUNC_LE;
		break;
	case GL_GREATER:
		pp_misc |= R300_FG_ALPHA_FUNC_GREATER;
		break;
	case GL_NOTEQUAL:
		pp_misc |= R300_FG_ALPHA_FUNC_NOTEQUAL;
		break;
	case GL_GEQUAL:
		pp_misc |= R300_FG_ALPHA_FUNC_GE;
		break;
	case GL_ALWAYS:
		/*pp_misc |= FG_ALPHA_FUNC_ALWAYS; */
		really_enabled = GL_FALSE;
		break;
	}

	if (really_enabled) {
		pp_misc |= R300_FG_ALPHA_FUNC_ENABLE;
		pp_misc |= R500_FG_ALPHA_FUNC_8BIT;
		pp_misc |= (refByte & R300_FG_ALPHA_FUNC_VAL_MASK);
	} else {
		pp_misc = 0x0;
	}

	R300_STATECHANGE(r300, at);
	r300->hw.at.cmd[R300_AT_ALPHA_TEST] = pp_misc;
	r300->hw.at.cmd[R300_AT_UNKNOWN] = 0;
}

static void r300AlphaFunc(struct gl_context * ctx, GLenum func, GLfloat ref)
{
	(void)func;
	(void)ref;
	r300SetAlphaState(ctx);
}

static int translate_func(int func)
{
	switch (func) {
	case GL_NEVER:
		return R300_ZS_NEVER;
	case GL_LESS:
		return R300_ZS_LESS;
	case GL_EQUAL:
		return R300_ZS_EQUAL;
	case GL_LEQUAL:
		return R300_ZS_LEQUAL;
	case GL_GREATER:
		return R300_ZS_GREATER;
	case GL_NOTEQUAL:
		return R300_ZS_NOTEQUAL;
	case GL_GEQUAL:
		return R300_ZS_GEQUAL;
	case GL_ALWAYS:
		return R300_ZS_ALWAYS;
	}
	return 0;
}

static void r300SetDepthState(struct gl_context * ctx)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);

	R300_STATECHANGE(r300, zs);
	r300->hw.zs.cmd[R300_ZS_CNTL_0] &= (R300_STENCIL_ENABLE |
					    R300_STENCIL_FRONT_BACK |
					    R500_STENCIL_REFMASK_FRONT_BACK);
	r300->hw.zs.cmd[R300_ZS_CNTL_1] &= ~(R300_ZS_MASK << R300_Z_FUNC_SHIFT);

	if (ctx->Depth.Test && ctx->DrawBuffer->_DepthBuffer) {
		r300->hw.zs.cmd[R300_ZS_CNTL_0] |= R300_Z_ENABLE;
		if (ctx->Depth.Mask)
			r300->hw.zs.cmd[R300_ZS_CNTL_0] |= R300_Z_WRITE_ENABLE;
		r300->hw.zs.cmd[R300_ZS_CNTL_1] |=
		    translate_func(ctx->Depth.Func) << R300_Z_FUNC_SHIFT;
	}
}

static void r300CatchStencilFallback(struct gl_context *ctx)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	const unsigned back = ctx->Stencil._BackFace;

	if (rmesa->radeon.radeonScreen->kernel_mm &&
	    (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515)) {
		r300SwitchFallback(ctx, R300_FALLBACK_STENCIL_TWOSIDE, GL_FALSE);
	} else if (ctx->Stencil._Enabled &&
		   (ctx->Stencil.Ref[0] != ctx->Stencil.Ref[back]
		    || ctx->Stencil.ValueMask[0] != ctx->Stencil.ValueMask[back]
		    || ctx->Stencil.WriteMask[0] != ctx->Stencil.WriteMask[back])) {
		r300SwitchFallback(ctx, R300_FALLBACK_STENCIL_TWOSIDE, GL_TRUE);
	} else {
		r300SwitchFallback(ctx, R300_FALLBACK_STENCIL_TWOSIDE, GL_FALSE);
	}
}

static void r300SetStencilState(struct gl_context * ctx, GLboolean state)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	GLboolean hw_stencil = GL_FALSE;

	r300CatchStencilFallback(ctx);

	if (ctx->DrawBuffer) {
		struct radeon_renderbuffer *rrbStencil
			= radeon_get_renderbuffer(ctx->DrawBuffer, BUFFER_STENCIL);
		hw_stencil = (rrbStencil && rrbStencil->bo);
	}

	if (hw_stencil) {
		R300_STATECHANGE(r300, zs);
		if (state) {
			r300->hw.zs.cmd[R300_ZS_CNTL_0] |=
			    R300_STENCIL_ENABLE;
		} else {
			r300->hw.zs.cmd[R300_ZS_CNTL_0] &=
			    ~R300_STENCIL_ENABLE;
		}
	}
}

static void r300UpdatePolygonMode(struct gl_context * ctx)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	uint32_t hw_mode = R300_GA_POLY_MODE_DISABLE;

	/* Only do something if a polygon mode is wanted, default is GL_FILL */
	if (ctx->Polygon.FrontMode != GL_FILL ||
	    ctx->Polygon.BackMode != GL_FILL) {
		GLenum f, b;

		/* Handle GL_CW (clock wise and GL_CCW (counter clock wise)
		 * correctly by selecting the correct front and back face
		 */
		if (ctx->Polygon.FrontFace == GL_CCW) {
			f = ctx->Polygon.FrontMode;
			b = ctx->Polygon.BackMode;
		} else {
			f = ctx->Polygon.BackMode;
			b = ctx->Polygon.FrontMode;
		}

		/* Enable polygon mode */
		hw_mode |= R300_GA_POLY_MODE_DUAL;

		switch (f) {
		case GL_LINE:
			hw_mode |= R300_GA_POLY_MODE_FRONT_PTYPE_LINE;
			break;
		case GL_POINT:
			hw_mode |= R300_GA_POLY_MODE_FRONT_PTYPE_POINT;
			break;
		case GL_FILL:
			hw_mode |= R300_GA_POLY_MODE_FRONT_PTYPE_TRI;
			break;
		}

		switch (b) {
		case GL_LINE:
			hw_mode |= R300_GA_POLY_MODE_BACK_PTYPE_LINE;
			break;
		case GL_POINT:
			hw_mode |= R300_GA_POLY_MODE_BACK_PTYPE_POINT;
			break;
		case GL_FILL:
			hw_mode |= R300_GA_POLY_MODE_BACK_PTYPE_TRI;
			break;
		}
	}

	if (r300->hw.polygon_mode.cmd[1] != hw_mode) {
		R300_STATECHANGE(r300, polygon_mode);
		r300->hw.polygon_mode.cmd[1] = hw_mode;
	}

	r300->hw.polygon_mode.cmd[2] = 0x00000001;
	r300->hw.polygon_mode.cmd[3] = 0x00000000;
}

/**
 * Change the culling mode.
 *
 * \note Mesa already filters redundant calls to this function.
 */
static void r300CullFace(struct gl_context * ctx, GLenum mode)
{
	(void)mode;

	r300UpdateCulling(ctx);
}

/**
 * Change the polygon orientation.
 *
 * \note Mesa already filters redundant calls to this function.
 */
static void r300FrontFace(struct gl_context * ctx, GLenum mode)
{
	(void)mode;

	r300UpdateCulling(ctx);
	r300UpdatePolygonMode(ctx);
}

/**
 * Change the depth testing function.
 *
 * \note Mesa already filters redundant calls to this function.
 */
static void r300DepthFunc(struct gl_context * ctx, GLenum func)
{
	(void)func;
	r300SetDepthState(ctx);
}

/**
 * Enable/Disable depth writing.
 *
 * \note Mesa already filters redundant calls to this function.
 */
static void r300DepthMask(struct gl_context * ctx, GLboolean mask)
{
	(void)mask;
	r300SetDepthState(ctx);
}

/**
 * Handle glColorMask()
 */
static void r300ColorMask(struct gl_context * ctx,
			  GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	int mask = (r ? RB3D_COLOR_CHANNEL_MASK_RED_MASK0 : 0) |
	    (g ? RB3D_COLOR_CHANNEL_MASK_GREEN_MASK0 : 0) |
	    (b ? RB3D_COLOR_CHANNEL_MASK_BLUE_MASK0 : 0) |
	    (a ? RB3D_COLOR_CHANNEL_MASK_ALPHA_MASK0 : 0);

	if (mask != r300->hw.cmk.cmd[R300_CMK_COLORMASK]) {
		R300_STATECHANGE(r300, cmk);
		r300->hw.cmk.cmd[R300_CMK_COLORMASK] = mask;
	}
}

/* =============================================================
 * Point state
 */
static void r300PointSize(struct gl_context * ctx, GLfloat size)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);

	/* We need to clamp to user defined range here, because
	 * the HW clamping happens only for per vertex point size. */
	size = CLAMP(size, ctx->Point.MinSize, ctx->Point.MaxSize);

	/* same size limits for AA, non-AA points */
	size = CLAMP(size, ctx->Const.MinPointSize, ctx->Const.MaxPointSize);

	R300_STATECHANGE(r300, ps);
	r300->hw.ps.cmd[R300_PS_POINTSIZE] =
	    ((int)(size * 6) << R300_POINTSIZE_X_SHIFT) |
	    ((int)(size * 6) << R300_POINTSIZE_Y_SHIFT);
}

static void r300PointParameter(struct gl_context * ctx, GLenum pname, const GLfloat * param)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);

	switch (pname) {
	case GL_POINT_SIZE_MIN:
		R300_STATECHANGE(r300, ga_point_minmax);
		r300->hw.ga_point_minmax.cmd[1] &= ~R300_GA_POINT_MINMAX_MIN_MASK;
		r300->hw.ga_point_minmax.cmd[1] |= (GLuint)(ctx->Point.MinSize * 6.0);
		r300PointSize(ctx, ctx->Point.Size);
		break;
	case GL_POINT_SIZE_MAX:
		R300_STATECHANGE(r300, ga_point_minmax);
		r300->hw.ga_point_minmax.cmd[1] &= ~R300_GA_POINT_MINMAX_MAX_MASK;
		r300->hw.ga_point_minmax.cmd[1] |= (GLuint)(ctx->Point.MaxSize * 6.0)
			<< R300_GA_POINT_MINMAX_MAX_SHIFT;
		r300PointSize(ctx, ctx->Point.Size);
		break;
	case GL_POINT_DISTANCE_ATTENUATION:
		break;
	case GL_POINT_FADE_THRESHOLD_SIZE:
		break;
	default:
		break;
	}
}

/* =============================================================
 * Line state
 */
static void r300LineWidth(struct gl_context * ctx, GLfloat widthf)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);

	widthf = CLAMP(widthf,
                       ctx->Const.MinPointSize,
                       ctx->Const.MaxPointSize);
	R300_STATECHANGE(r300, lcntl);
	r300->hw.lcntl.cmd[1] =
	    R300_LINE_CNT_HO | R300_LINE_CNT_VE | (int)(widthf * 6.0);
}

static void r300PolygonMode(struct gl_context * ctx, GLenum face, GLenum mode)
{
	(void)face;
	(void)mode;

	r300UpdatePolygonMode(ctx);
}

/* =============================================================
 * Stencil
 */

static int translate_stencil_op(int op)
{
	switch (op) {
	case GL_KEEP:
		return R300_ZS_KEEP;
	case GL_ZERO:
		return R300_ZS_ZERO;
	case GL_REPLACE:
		return R300_ZS_REPLACE;
	case GL_INCR:
		return R300_ZS_INCR;
	case GL_DECR:
		return R300_ZS_DECR;
	case GL_INCR_WRAP_EXT:
		return R300_ZS_INCR_WRAP;
	case GL_DECR_WRAP_EXT:
		return R300_ZS_DECR_WRAP;
	case GL_INVERT:
		return R300_ZS_INVERT;
	default:
		WARN_ONCE("Do not know how to translate stencil op");
		return R300_ZS_KEEP;
	}
	return 0;
}

static void r300ShadeModel(struct gl_context * ctx, GLenum mode)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);

	R300_STATECHANGE(rmesa, shade);
	rmesa->hw.shade.cmd[1] = 0x00000002;
	R300_STATECHANGE(rmesa, shade2);
	switch (mode) {
	case GL_FLAT:
		rmesa->hw.shade2.cmd[1] = R300_RE_SHADE_MODEL_FLAT;
		break;
	case GL_SMOOTH:
		rmesa->hw.shade2.cmd[1] = R300_RE_SHADE_MODEL_SMOOTH;
		break;
	default:
		return;
	}
	rmesa->hw.shade2.cmd[2] = 0x00000000;
	rmesa->hw.shade2.cmd[3] = 0x00000000;
}

static void r300StencilFuncSeparate(struct gl_context * ctx, GLenum face,
				    GLenum func, GLint ref, GLuint mask)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	GLuint refmask;
	GLuint flag;
	const unsigned back = ctx->Stencil._BackFace;

	r300CatchStencilFallback(ctx);

	refmask = ((ctx->Stencil.Ref[0] & 0xff) << R300_STENCILREF_SHIFT)
	     | ((ctx->Stencil.ValueMask[0] & 0xff) << R300_STENCILMASK_SHIFT);

	R300_STATECHANGE(rmesa, zs);
	rmesa->hw.zs.cmd[R300_ZS_CNTL_0] |= R300_STENCIL_FRONT_BACK;
	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] &= ~((R300_ZS_MASK <<
					       R300_S_FRONT_FUNC_SHIFT)
					      | (R300_ZS_MASK <<
						 R300_S_BACK_FUNC_SHIFT));

	rmesa->hw.zs.cmd[R300_ZS_CNTL_2] &=
	    ~((R300_STENCILREF_MASK << R300_STENCILREF_SHIFT) |
	      (R300_STENCILREF_MASK << R300_STENCILMASK_SHIFT));

	flag = translate_func(ctx->Stencil.Function[0]);
	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
	    (flag << R300_S_FRONT_FUNC_SHIFT);

	flag = translate_func(ctx->Stencil.Function[back]);

	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
	    (flag << R300_S_BACK_FUNC_SHIFT);
	rmesa->hw.zs.cmd[R300_ZS_CNTL_2] |= refmask;

	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
		rmesa->hw.zs.cmd[R300_ZS_CNTL_0] |= R500_STENCIL_REFMASK_FRONT_BACK;
		R300_STATECHANGE(rmesa, zsb);
		refmask = ((ctx->Stencil.Ref[back] & 0xff) << R300_STENCILREF_SHIFT)
			| ((ctx->Stencil.ValueMask[back] & 0xff) << R300_STENCILMASK_SHIFT);

		rmesa->hw.zsb.cmd[R300_ZSB_CNTL_0] &=
			~((R300_STENCILREF_MASK << R300_STENCILREF_SHIFT) |
			  (R300_STENCILREF_MASK << R300_STENCILMASK_SHIFT));
		rmesa->hw.zsb.cmd[R300_ZSB_CNTL_0] |= refmask;
	}
}

static void r300StencilMaskSeparate(struct gl_context * ctx, GLenum face, GLuint mask)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	const unsigned back = ctx->Stencil._BackFace;

	r300CatchStencilFallback(ctx);

	R300_STATECHANGE(rmesa, zs);
	rmesa->hw.zs.cmd[R300_ZS_CNTL_2] &=
	    ~(R300_STENCILREF_MASK <<
	      R300_STENCILWRITEMASK_SHIFT);
	rmesa->hw.zs.cmd[R300_ZS_CNTL_2] |=
	    (ctx->Stencil.
	     WriteMask[0] & R300_STENCILREF_MASK) <<
	     R300_STENCILWRITEMASK_SHIFT;
	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
		R300_STATECHANGE(rmesa, zsb);
		rmesa->hw.zsb.cmd[R300_ZSB_CNTL_0] |=
			(ctx->Stencil.
			 WriteMask[back] & R300_STENCILREF_MASK) <<
			R300_STENCILWRITEMASK_SHIFT;
	}
}

static void r300StencilOpSeparate(struct gl_context * ctx, GLenum face,
				  GLenum fail, GLenum zfail, GLenum zpass)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	const unsigned back = ctx->Stencil._BackFace;

	r300CatchStencilFallback(ctx);

	R300_STATECHANGE(rmesa, zs);
	/* It is easier to mask what's left.. */
	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] &=
	    (R300_ZS_MASK << R300_Z_FUNC_SHIFT) |
	    (R300_ZS_MASK << R300_S_FRONT_FUNC_SHIFT) |
	    (R300_ZS_MASK << R300_S_BACK_FUNC_SHIFT);

	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
	    (translate_stencil_op(ctx->Stencil.FailFunc[0]) <<
	     R300_S_FRONT_SFAIL_OP_SHIFT)
	    | (translate_stencil_op(ctx->Stencil.ZFailFunc[0]) <<
	       R300_S_FRONT_ZFAIL_OP_SHIFT)
	    | (translate_stencil_op(ctx->Stencil.ZPassFunc[0]) <<
	       R300_S_FRONT_ZPASS_OP_SHIFT);

	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
	    (translate_stencil_op(ctx->Stencil.FailFunc[back]) <<
	     R300_S_BACK_SFAIL_OP_SHIFT)
	    | (translate_stencil_op(ctx->Stencil.ZFailFunc[back]) <<
	       R300_S_BACK_ZFAIL_OP_SHIFT)
	    | (translate_stencil_op(ctx->Stencil.ZPassFunc[back]) <<
	       R300_S_BACK_ZPASS_OP_SHIFT);
}

/* =============================================================
 * Window position and viewport transformation
 */

static void r300UpdateWindow(struct gl_context * ctx)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	__DRIdrawable *dPriv = radeon_get_drawable(&rmesa->radeon);
	GLfloat xoffset = dPriv ? (GLfloat) dPriv->x : 0;
	GLfloat yoffset = dPriv ? (GLfloat) dPriv->y + dPriv->h : 0;
	const GLfloat *v = ctx->Viewport._WindowMap.m;
	const GLfloat depthScale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
	const GLboolean render_to_fbo = (ctx->DrawBuffer->Name != 0);
	GLfloat y_scale, y_bias;

	if (render_to_fbo) {
		y_scale = 1.0;
		y_bias = 0;
	} else {
		y_scale = -1.0;
		y_bias = yoffset;
	}

	GLfloat sx = v[MAT_SX];
	GLfloat tx = v[MAT_TX] + xoffset;
	GLfloat sy = v[MAT_SY] * y_scale;
	GLfloat ty = (v[MAT_TY] * y_scale) + y_bias;
	GLfloat sz = v[MAT_SZ] * depthScale;
	GLfloat tz = v[MAT_TZ] * depthScale;

	R300_STATECHANGE(rmesa, vpt);

	rmesa->hw.vpt.cmd[R300_VPT_XSCALE] = r300PackFloat32(sx);
	rmesa->hw.vpt.cmd[R300_VPT_XOFFSET] = r300PackFloat32(tx);
	rmesa->hw.vpt.cmd[R300_VPT_YSCALE] = r300PackFloat32(sy);
	rmesa->hw.vpt.cmd[R300_VPT_YOFFSET] = r300PackFloat32(ty);
	rmesa->hw.vpt.cmd[R300_VPT_ZSCALE] = r300PackFloat32(sz);
	rmesa->hw.vpt.cmd[R300_VPT_ZOFFSET] = r300PackFloat32(tz);
}

static void r300Viewport(struct gl_context * ctx, GLint x, GLint y,
			 GLsizei width, GLsizei height)
{
	/* Don't pipeline viewport changes, conflict with window offset
	 * setting below.  Could apply deltas to rescue pipelined viewport
	 * values, or keep the originals hanging around.
	 */
	r300UpdateWindow(ctx);

	radeon_viewport(ctx, x, y, width, height);
}

static void r300DepthRange(struct gl_context * ctx, GLclampd nearval, GLclampd farval)
{
	r300UpdateWindow(ctx);
}

void r300UpdateViewportOffset(struct gl_context * ctx)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	__DRIdrawable *dPriv = radeon_get_drawable(&rmesa->radeon);
	GLfloat xoffset = (GLfloat) dPriv->x;
	GLfloat yoffset = (GLfloat) dPriv->y + dPriv->h;
	const GLfloat *v = ctx->Viewport._WindowMap.m;

	GLfloat tx = v[MAT_TX] + xoffset;
	GLfloat ty = (-v[MAT_TY]) + yoffset;

	if (rmesa->hw.vpt.cmd[R300_VPT_XOFFSET] != r300PackFloat32(tx) ||
	    rmesa->hw.vpt.cmd[R300_VPT_YOFFSET] != r300PackFloat32(ty)) {
		/* Note: this should also modify whatever data the context reset
		 * code uses...
		 */
		R300_STATECHANGE(rmesa, vpt);
		rmesa->hw.vpt.cmd[R300_VPT_XOFFSET] = r300PackFloat32(tx);
		rmesa->hw.vpt.cmd[R300_VPT_YOFFSET] = r300PackFloat32(ty);

	}

	radeonUpdateScissor(ctx);
}

/**
 * Update R300's own internal state parameters.
 * For now just STATE_R300_WINDOW_DIMENSION
 */
static void r300UpdateStateParameters(struct gl_context * ctx, GLuint new_state)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	struct gl_program_parameter_list *paramList;

	if (!(new_state & (_NEW_BUFFERS | _NEW_PROGRAM | _NEW_PROGRAM_CONSTANTS)))
		return;

	if (!ctx->FragmentProgram._Current || !rmesa->selected_fp)
		return;

	paramList = ctx->FragmentProgram._Current->Base.Parameters;

	if (!paramList)
		return;

	_mesa_load_state_parameters(ctx, paramList);
}

/* =============================================================
 * Polygon state
 */
static void r300PolygonOffset(struct gl_context * ctx, GLfloat factor, GLfloat units)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	GLfloat constant = units;

	switch (ctx->Visual.depthBits) {
	case 16:
		constant *= 4.0;
		break;
	case 24:
		constant *= 2.0;
		break;
	}

	factor *= 12.0;

/*    fprintf(stderr, "%s f:%f u:%f\n", __FUNCTION__, factor, constant); */

	R300_STATECHANGE(rmesa, zbs);
	rmesa->hw.zbs.cmd[R300_ZBS_T_FACTOR] = r300PackFloat32(factor);
	rmesa->hw.zbs.cmd[R300_ZBS_T_CONSTANT] = r300PackFloat32(constant);
	rmesa->hw.zbs.cmd[R300_ZBS_W_FACTOR] = r300PackFloat32(factor);
	rmesa->hw.zbs.cmd[R300_ZBS_W_CONSTANT] = r300PackFloat32(constant);
}

/* Routing and texture-related */

/* r300 doesnt handle GL_CLAMP and GL_MIRROR_CLAMP_EXT correctly when filter is NEAREST.
 * Since texwrap produces same results for GL_CLAMP and GL_CLAMP_TO_EDGE we use them instead.
 * We need to recalculate wrap modes whenever filter mode is changed because someone might do:
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
 * Since r300 completely ignores R300_TX_CLAMP when either min or mag is nearest it cant handle
 * combinations where only one of them is nearest.
 */
static unsigned long gen_fixed_filter(unsigned long f)
{
	unsigned long mag, min, needs_fixing = 0;
	//return f;

	/* We ignore MIRROR bit so we dont have to do everything twice */
	if ((f & ((7 - 1) << R300_TX_WRAP_S_SHIFT)) ==
	    (R300_TX_CLAMP << R300_TX_WRAP_S_SHIFT)) {
		needs_fixing |= 1;
	}
	if ((f & ((7 - 1) << R300_TX_WRAP_T_SHIFT)) ==
	    (R300_TX_CLAMP << R300_TX_WRAP_T_SHIFT)) {
		needs_fixing |= 2;
	}
	if ((f & ((7 - 1) << R300_TX_WRAP_R_SHIFT)) ==
	    (R300_TX_CLAMP << R300_TX_WRAP_R_SHIFT)) {
		needs_fixing |= 4;
	}

	if (!needs_fixing)
		return f;

	mag = f & R300_TX_MAG_FILTER_MASK;
	min = f & (R300_TX_MIN_FILTER_MASK|R300_TX_MIN_FILTER_MIP_MASK);

	/* TODO: Check for anisto filters too */
	if ((mag != R300_TX_MAG_FILTER_NEAREST)
	    && (min != R300_TX_MIN_FILTER_NEAREST))
		return f;

	/* r300 cant handle these modes hence we force nearest to linear */
	if ((mag == R300_TX_MAG_FILTER_NEAREST)
	    && (min != R300_TX_MIN_FILTER_NEAREST)) {
		f &= ~R300_TX_MAG_FILTER_NEAREST;
		f |= R300_TX_MAG_FILTER_LINEAR;
		return f;
	}

	if ((min == R300_TX_MIN_FILTER_NEAREST)
	    && (mag != R300_TX_MAG_FILTER_NEAREST)) {
		f &= ~R300_TX_MIN_FILTER_NEAREST;
		f |= R300_TX_MIN_FILTER_LINEAR;
		return f;
	}

	/* Both are nearest */
	if (needs_fixing & 1) {
		f &= ~((7 - 1) << R300_TX_WRAP_S_SHIFT);
		f |= R300_TX_CLAMP_TO_EDGE << R300_TX_WRAP_S_SHIFT;
	}
	if (needs_fixing & 2) {
		f &= ~((7 - 1) << R300_TX_WRAP_T_SHIFT);
		f |= R300_TX_CLAMP_TO_EDGE << R300_TX_WRAP_T_SHIFT;
	}
	if (needs_fixing & 4) {
		f &= ~((7 - 1) << R300_TX_WRAP_R_SHIFT);
		f |= R300_TX_CLAMP_TO_EDGE << R300_TX_WRAP_R_SHIFT;
	}
	return f;
}

static void r300SetupFragmentShaderTextures(struct gl_context *ctx, int *tmu_mappings)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	int i;
	struct r300_fragment_program_code *code = &r300->selected_fp->code.code.r300;

	R300_STATECHANGE(r300, fpt);

	for (i = 0; i < code->tex.length; i++) {
		int unit;
		int opcode;
		unsigned long val;

		unit = code->tex.inst[i] >> R300_TEX_ID_SHIFT;
		unit &= 15;

		val = code->tex.inst[i];
		val &= ~R300_TEX_ID_MASK;

		opcode =
			(val & R300_TEX_INST_MASK) >> R300_TEX_INST_SHIFT;
		if (opcode == R300_TEX_OP_KIL) {
			r300->hw.fpt.cmd[R300_FPT_INSTR_0 + i] = val;
		} else {
			if (tmu_mappings[unit] >= 0) {
				val |=
					tmu_mappings[unit] <<
					R300_TEX_ID_SHIFT;
				r300->hw.fpt.cmd[R300_FPT_INSTR_0 + i] = val;
			} else {
				// We get here when the corresponding texture image is incomplete
				// (e.g. incomplete mipmaps etc.)
				r300->hw.fpt.cmd[R300_FPT_INSTR_0 + i] = val;
			}
		}
	}

	r300->hw.fpt.cmd[R300_FPT_CMD_0] =
		cmdpacket0(r300->radeon.radeonScreen,
                   R300_US_TEX_INST_0, code->tex.length);
}

static void r500SetupFragmentShaderTextures(struct gl_context *ctx, int *tmu_mappings)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	int i;
	struct r500_fragment_program_code *code = &r300->selected_fp->code.code.r500;

	/* find all the texture instructions and relocate the texture units */
	for (i = 0; i < code->inst_end + 1; i++) {
		if ((code->inst[i].inst0 & 0x3) == R500_INST_TYPE_TEX) {
			uint32_t val;
			int unit, opcode, new_unit;

			val = code->inst[i].inst1;

			unit = (val >> 16) & 0xf;

			val &= ~(0xf << 16);

			opcode = val & (0x7 << 22);
			if (opcode == R500_TEX_INST_TEXKILL) {
				new_unit = 0;
			} else {
				if (tmu_mappings[unit] >= 0) {
					new_unit = tmu_mappings[unit];
				} else {
					new_unit = 0;
				}
			}
			val |= R500_TEX_ID(new_unit);
			code->inst[i].inst1 = val;
		}
	}
}

static GLuint translate_lod_bias(GLfloat bias)
{
	GLint b = (int)(bias*32);
	if (b >= (1 << 9))
		b = (1 << 9)-1;
	else if (b < -(1 << 9))
		b = -(1 << 9);
	return (((GLuint)b) << R300_LOD_BIAS_SHIFT) & R300_LOD_BIAS_MASK;
}


static void r300SetupTextures(struct gl_context * ctx)
{
	int i, mtu;
	struct radeon_tex_obj *t;
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	int hw_tmu = 0;
	int last_hw_tmu = -1;	/* -1 translates into no setup costs for fields */
	int tmu_mappings[R300_MAX_TEXTURE_UNITS] = { -1, };

	R300_STATECHANGE(r300, txe);
	R300_STATECHANGE(r300, tex.filter);
	R300_STATECHANGE(r300, tex.filter_1);
	R300_STATECHANGE(r300, tex.size);
	R300_STATECHANGE(r300, tex.format);
	R300_STATECHANGE(r300, tex.pitch);
	R300_STATECHANGE(r300, tex.offset);
	R300_STATECHANGE(r300, tex.chroma_key);
	R300_STATECHANGE(r300, tex.border_color);

	r300->hw.txe.cmd[R300_TXE_ENABLE] = 0x0;

	mtu = r300->radeon.glCtx->Const.MaxTextureUnits;
	if (RADEON_DEBUG & RADEON_STATE)
		fprintf(stderr, "mtu=%d\n", mtu);

	if (mtu > R300_MAX_TEXTURE_UNITS) {
		fprintf(stderr,
			"Aiiee ! mtu=%d is greater than R300_MAX_TEXTURE_UNITS=%d\n",
			mtu, R300_MAX_TEXTURE_UNITS);
		exit(-1);
	}

	/* We cannot let disabled tmu offsets pass DRM */
	for (i = 0; i < mtu; i++) {
		if (ctx->Texture.Unit[i]._ReallyEnabled) {
			tmu_mappings[i] = hw_tmu;

			t = radeon_tex_obj(ctx->Texture.Unit[i]._Current);
			if (!t)
				continue;

			if ((t->pp_txformat & 0xffffff00) == 0xffffff00) {
				WARN_ONCE
				    ("unknown texture format (entry %x) encountered. Help me !\n",
				     t->pp_txformat & 0xff);
			}

			if (RADEON_DEBUG & RADEON_STATE)
				fprintf(stderr,
					"Activating texture unit %d\n", i);

			r300->hw.txe.cmd[R300_TXE_ENABLE] |= (1 << hw_tmu);

			r300->hw.tex.filter.cmd[R300_TEX_VALUE_0 +
						hw_tmu] =
			    gen_fixed_filter(t->pp_txfilter) | (hw_tmu << 28);
			/* Note: There is a LOD bias per texture unit and a LOD bias
			 * per texture object. We add them here to get the correct behaviour.
			 * (The per-texture object LOD bias was introduced in OpenGL 1.4
			 * and is not present in the EXT_texture_object extension).
			 */
			r300->hw.tex.filter_1.cmd[R300_TEX_VALUE_0 + hw_tmu] =
				t->pp_txfilter_1 |
				translate_lod_bias(ctx->Texture.Unit[i].LodBias + t->base.Sampler.LodBias);
			r300->hw.tex.size.cmd[R300_TEX_VALUE_0 + hw_tmu] =
			    t->pp_txsize;
			r300->hw.tex.format.cmd[R300_TEX_VALUE_0 +
						hw_tmu] = t->pp_txformat;
			r300->hw.tex.pitch.cmd[R300_TEX_VALUE_0 + hw_tmu] =
			  t->pp_txpitch;
			r300->hw.textures[hw_tmu] = t;

			if (t->tile_bits & R300_TXO_MACRO_TILE) {
				WARN_ONCE("macro tiling enabled!\n");
			}

			if (t->tile_bits & R300_TXO_MICRO_TILE) {
				WARN_ONCE("micro tiling enabled!\n");
			}

			r300->hw.tex.chroma_key.cmd[R300_TEX_VALUE_0 +
						    hw_tmu] = 0x0;
			r300->hw.tex.border_color.cmd[R300_TEX_VALUE_0 +
						      hw_tmu] =
			    t->pp_border_color;

			last_hw_tmu = hw_tmu;

			hw_tmu++;
		}
	}

	/* R3xx and R4xx chips require that the texture unit corresponding to
	 * KIL instructions is really enabled.
	 *
	 * We do some fakery here and in the state atom emit logic to enable
	 * the texture without tripping up the CS checker in the kernel.
	 */
	if (r300->radeon.radeonScreen->chip_family < CHIP_FAMILY_RV515) {
		if (ctx->FragmentProgram._Current->UsesKill && last_hw_tmu < 0) {
			last_hw_tmu++;

			r300->hw.txe.cmd[R300_TXE_ENABLE] |= 1;

			r300->hw.tex.border_color.cmd[R300_TEX_VALUE_0] = 0;
			r300->hw.tex.chroma_key.cmd[R300_TEX_VALUE_0] = 0;
			r300->hw.tex.filter.cmd[R300_TEX_VALUE_0] = 0;
			r300->hw.tex.filter_1.cmd[R300_TEX_VALUE_0] = 0;
			r300->hw.tex.size.cmd[R300_TEX_VALUE_0] = 0; /* 1x1 texture */
			r300->hw.tex.format.cmd[R300_TEX_VALUE_0] = 0; /* A8 format */
			r300->hw.tex.pitch.cmd[R300_TEX_VALUE_0] = 0;
		}
	}

	r300->hw.tex.filter.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_FILTER0_0, last_hw_tmu + 1);
	r300->hw.tex.filter_1.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_FILTER1_0, last_hw_tmu + 1);
	r300->hw.tex.size.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_SIZE_0, last_hw_tmu + 1);
	r300->hw.tex.format.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_FORMAT_0, last_hw_tmu + 1);
	r300->hw.tex.pitch.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_FORMAT2_0, last_hw_tmu + 1);
	r300->hw.tex.offset.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_OFFSET_0, last_hw_tmu + 1);
	r300->hw.tex.chroma_key.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_CHROMA_KEY_0, last_hw_tmu + 1);
	r300->hw.tex.border_color.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_BORDER_COLOR_0, last_hw_tmu + 1);

	r300->vtbl.SetupFragmentShaderTextures(ctx, tmu_mappings);

	if (RADEON_DEBUG & RADEON_STATE)
		fprintf(stderr, "TX_ENABLE: %08x  last_hw_tmu=%d\n",
			r300->hw.txe.cmd[R300_TXE_ENABLE], last_hw_tmu);
}

union r300_outputs_written {
	GLuint vp_outputs;	/* hw_tcl_on */
	 DECLARE_RENDERINPUTS(index_bitset);	/* !hw_tcl_on */
};

#define R300_OUTPUTS_WRITTEN_TEST(ow, vp_result, tnl_attrib) \
	((hw_tcl_on) ? (ow).vp_outputs & (1 << (vp_result)) : \
	RENDERINPUTS_TEST( (ow.index_bitset), (tnl_attrib) ))

static void r300SetupRSUnit(struct gl_context * ctx)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	union r300_outputs_written OutputsWritten;
	GLuint InputsRead;
	int fp_reg, high_rr;
	int col_ip, tex_ip;
	int rs_tex_count = 0;
	int i, col_fmt, hw_tcl_on;

	hw_tcl_on = r300->options.hw_tcl_enabled;

	if (hw_tcl_on)
		OutputsWritten.vp_outputs = r300->selected_vp->code.OutputsWritten;
	else
		RENDERINPUTS_COPY(OutputsWritten.index_bitset, r300->render_inputs_bitset);

	InputsRead = r300->selected_fp->InputsRead;

	R300_STATECHANGE(r300, ri);
	R300_STATECHANGE(r300, rc);
	R300_STATECHANGE(r300, rr);

	fp_reg = col_ip = tex_ip = col_fmt = 0;

	r300->hw.rc.cmd[1] = 0;
	r300->hw.rc.cmd[2] = 0;
	for (i=0; i<R300_RR_CMDSIZE-1; ++i)
		r300->hw.rr.cmd[R300_RR_INST_0 + i] = 0;

	for (i=0; i<R300_RI_CMDSIZE-1; ++i)
		r300->hw.ri.cmd[R300_RI_INTERP_0 + i] = 0;


	if (InputsRead & FRAG_BIT_COL0) {
		if (R300_OUTPUTS_WRITTEN_TEST(OutputsWritten, VERT_RESULT_COL0, _TNL_ATTRIB_COLOR0)) {
			r300->hw.ri.cmd[R300_RI_INTERP_0 + col_ip] = R300_RS_COL_PTR(col_ip) | R300_RS_COL_FMT(R300_RS_COL_FMT_RGBA);
			r300->hw.rr.cmd[R300_RR_INST_0 + col_ip] = R300_RS_INST_COL_ID(col_ip) | R300_RS_INST_COL_CN_WRITE | R300_RS_INST_COL_ADDR(fp_reg);
			InputsRead &= ~FRAG_BIT_COL0;
			++col_ip;
			++fp_reg;
		} else {
			WARN_ONCE("fragprog wants col0, vp doesn't provide it\n");
		}
	}

	if (InputsRead & FRAG_BIT_COL1) {
		if (R300_OUTPUTS_WRITTEN_TEST(OutputsWritten, VERT_RESULT_COL1, _TNL_ATTRIB_COLOR1)) {
			r300->hw.ri.cmd[R300_RI_INTERP_0 + col_ip] = R300_RS_COL_PTR(col_ip) | R300_RS_COL_FMT(R300_RS_COL_FMT_RGBA);
			r300->hw.rr.cmd[R300_RR_INST_0 + col_ip] = R300_RS_INST_COL_ID(col_ip) | R300_RS_INST_COL_CN_WRITE | R300_RS_INST_COL_ADDR(fp_reg);
			InputsRead &= ~FRAG_BIT_COL1;
			++col_ip;
			++fp_reg;
		} else {
			WARN_ONCE("fragprog wants col1, vp doesn't provide it\n");
		}
	}

	/* We always route 4 texcoord components */
	for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
		if (! ( InputsRead & FRAG_BIT_TEX(i) ) )
		    continue;

		if (!R300_OUTPUTS_WRITTEN_TEST(OutputsWritten, VERT_RESULT_TEX0 + i, _TNL_ATTRIB_TEX(i))) {
		    WARN_ONCE("fragprog wants coords for tex%d, vp doesn't provide them!\n", i);
		    continue;
		}

		r300->hw.ri.cmd[R300_RI_INTERP_0 + tex_ip] |= R300_RS_SEL_S(0) | R300_RS_SEL_T(1) | R300_RS_SEL_R(2) | R300_RS_SEL_Q(3) | R300_RS_TEX_PTR(rs_tex_count);
		r300->hw.rr.cmd[R300_RR_INST_0 + tex_ip] |= R300_RS_INST_TEX_ID(tex_ip) | R300_RS_INST_TEX_CN_WRITE | R300_RS_INST_TEX_ADDR(fp_reg);
		InputsRead &= ~(FRAG_BIT_TEX0 << i);
		rs_tex_count += 4;
		++tex_ip;
		++fp_reg;
	}

	/* Setup default color if no color or tex was set */
	if (rs_tex_count == 0 && col_ip == 0) {
		r300->hw.rr.cmd[R300_RR_INST_0] = R300_RS_INST_COL_ID(0) | R300_RS_INST_COL_ADDR(0);
		r300->hw.ri.cmd[R300_RI_INTERP_0] = R300_RS_COL_PTR(0) | R300_RS_COL_FMT(R300_RS_COL_FMT_0001);
		++col_ip;
	}

	high_rr = (col_ip > tex_ip) ? col_ip : tex_ip;
	r300->hw.rc.cmd[1] |= (rs_tex_count << R300_IT_COUNT_SHIFT) | (col_ip << R300_IC_COUNT_SHIFT) | R300_HIRES_EN;
	r300->hw.rc.cmd[2] |= high_rr - 1;

	r300->hw.rr.cmd[R300_RR_CMD_0] = cmdpacket0(r300->radeon.radeonScreen, R300_RS_INST_0, high_rr);
	r300->hw.ri.cmd[R300_RI_CMD_0] = cmdpacket0(r300->radeon.radeonScreen, R300_RS_IP_0, high_rr);

	if (InputsRead)
		WARN_ONCE("Don't know how to satisfy InputsRead=0x%08x\n", InputsRead);
}

static void r500SetupRSUnit(struct gl_context * ctx)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	union r300_outputs_written OutputsWritten;
	GLuint InputsRead;
	int fp_reg, high_rr;
	int col_ip, tex_ip;
	int rs_tex_count = 0;
	int i, col_fmt, hw_tcl_on;

	hw_tcl_on = r300->options.hw_tcl_enabled;

	if (hw_tcl_on)
		OutputsWritten.vp_outputs = r300->selected_vp->code.OutputsWritten;
	else
		RENDERINPUTS_COPY(OutputsWritten.index_bitset, r300->render_inputs_bitset);

	InputsRead = r300->selected_fp->InputsRead;

	R300_STATECHANGE(r300, ri);
	R300_STATECHANGE(r300, rc);
	R300_STATECHANGE(r300, rr);

	fp_reg = col_ip = tex_ip = col_fmt = 0;

	r300->hw.rc.cmd[1] = 0;
	r300->hw.rc.cmd[2] = 0;
	for (i=0; i<R300_RR_CMDSIZE-1; ++i)
		r300->hw.rr.cmd[R300_RR_INST_0 + i] = 0;

	for (i=0; i<R500_RI_CMDSIZE-1; ++i)
		r300->hw.ri.cmd[R300_RI_INTERP_0 + i] = 0;


	if (InputsRead & FRAG_BIT_COL0) {
		if (R300_OUTPUTS_WRITTEN_TEST(OutputsWritten, VERT_RESULT_COL0, _TNL_ATTRIB_COLOR0)) {
			r300->hw.ri.cmd[R300_RI_INTERP_0 + col_ip] = R500_RS_COL_PTR(col_ip) | R500_RS_COL_FMT(R300_RS_COL_FMT_RGBA);
			r300->hw.rr.cmd[R300_RR_INST_0 + col_ip] = R500_RS_INST_COL_ID(col_ip) | R500_RS_INST_COL_CN_WRITE | R500_RS_INST_COL_ADDR(fp_reg);
			InputsRead &= ~FRAG_BIT_COL0;
			++col_ip;
			++fp_reg;
		} else {
			WARN_ONCE("fragprog wants col0, vp doesn't provide it\n");
		}
	}

	if (InputsRead & FRAG_BIT_COL1) {
		if (R300_OUTPUTS_WRITTEN_TEST(OutputsWritten, VERT_RESULT_COL1, _TNL_ATTRIB_COLOR1)) {
			r300->hw.ri.cmd[R300_RI_INTERP_0 + col_ip] = R500_RS_COL_PTR(col_ip) | R500_RS_COL_FMT(R300_RS_COL_FMT_RGBA);
			r300->hw.rr.cmd[R300_RR_INST_0 + col_ip] = R500_RS_INST_COL_ID(col_ip) | R500_RS_INST_COL_CN_WRITE | R500_RS_INST_COL_ADDR(fp_reg);
			InputsRead &= ~FRAG_BIT_COL1;
			++col_ip;
			++fp_reg;
		} else {
			WARN_ONCE("fragprog wants col1, vp doesn't provide it\n");
		}
	}

	/* We always route 4 texcoord components */
	for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
		if (! ( InputsRead & FRAG_BIT_TEX(i) ) )
		    continue;

		if (!R300_OUTPUTS_WRITTEN_TEST(OutputsWritten, VERT_RESULT_TEX0 + i, _TNL_ATTRIB_TEX(i))) {
		    WARN_ONCE("fragprog wants coords for tex%d, vp doesn't provide them!\n", i);
		    continue;
		}

		r300->hw.ri.cmd[R300_RI_INTERP_0 + tex_ip] |= ((rs_tex_count + 0) << R500_RS_IP_TEX_PTR_S_SHIFT) |
			((rs_tex_count + 1) << R500_RS_IP_TEX_PTR_T_SHIFT) |
			((rs_tex_count + 2) << R500_RS_IP_TEX_PTR_R_SHIFT) |
			((rs_tex_count + 3) << R500_RS_IP_TEX_PTR_Q_SHIFT);

		r300->hw.rr.cmd[R300_RR_INST_0 + tex_ip] |= R500_RS_INST_TEX_ID(tex_ip) | R500_RS_INST_TEX_CN_WRITE | R500_RS_INST_TEX_ADDR(fp_reg);
		InputsRead &= ~(FRAG_BIT_TEX0 << i);
		rs_tex_count += 4;
		++tex_ip;
		++fp_reg;
	}

	/* Setup default color if no color or tex was set */
	if (rs_tex_count == 0 && col_ip == 0) {
		r300->hw.rr.cmd[R300_RR_INST_0] = R500_RS_INST_COL_ID(0) | R500_RS_INST_COL_ADDR(0);
		r300->hw.ri.cmd[R300_RI_INTERP_0] = R500_RS_COL_PTR(0) | R500_RS_COL_FMT(R300_RS_COL_FMT_0001);
		++col_ip;
	}

	high_rr = (col_ip > tex_ip) ? col_ip : tex_ip;
	r300->hw.rc.cmd[1] = (rs_tex_count << R300_IT_COUNT_SHIFT) | (col_ip << R300_IC_COUNT_SHIFT) | R300_HIRES_EN;
	r300->hw.rc.cmd[2] = 0xC0 | (high_rr - 1);

	r300->hw.rr.cmd[R300_RR_CMD_0] = cmdpacket0(r300->radeon.radeonScreen, R500_RS_INST_0, high_rr);
	r300->hw.ri.cmd[R300_RI_CMD_0] = cmdpacket0(r300->radeon.radeonScreen, R500_RS_IP_0, high_rr);

	if (InputsRead)
		WARN_ONCE("Don't know how to satisfy InputsRead=0x%08x\n", InputsRead);
}


void r300VapCntl(r300ContextPtr rmesa, GLuint input_count,
			GLuint output_count, GLuint temp_count)
{
    int vtx_mem_size;
    int pvs_num_slots;
    int pvs_num_cntrls;

    /* Flush PVS engine before changing PVS_NUM_SLOTS, PVS_NUM_CNTRLS.
     * See r500 docs 6.5.2 - done in emit */

    /* avoid division by zero */
    if (input_count == 0) input_count = 1;
    if (output_count == 0) output_count = 1;
    if (temp_count == 0) temp_count = 1;

    if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515)
	vtx_mem_size = 128;
    else
	vtx_mem_size = 72;

    pvs_num_slots = MIN3(10, vtx_mem_size/input_count, vtx_mem_size/output_count);
    pvs_num_cntrls = MIN2(6, vtx_mem_size/temp_count);

    R300_STATECHANGE(rmesa, vap_cntl);
    if (rmesa->options.hw_tcl_enabled) {
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] =
	    (pvs_num_slots << R300_PVS_NUM_SLOTS_SHIFT) |
	    (pvs_num_cntrls << R300_PVS_NUM_CNTLRS_SHIFT) |
	    (12 << R300_VF_MAX_VTX_NUM_SHIFT);
	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515)
	    rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] |= R500_TCL_STATE_OPTIMIZATION;
    } else
	/* not sure about non-tcl */
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] = ((10 << R300_PVS_NUM_SLOTS_SHIFT) |
				    (5 << R300_PVS_NUM_CNTLRS_SHIFT) |
				    (5 << R300_VF_MAX_VTX_NUM_SHIFT));

    if ((rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_R300) ||
	(rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_R350))
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] |= (4 << R300_PVS_NUM_FPUS_SHIFT);
    else if (rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_RV530)
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] |= (5 << R300_PVS_NUM_FPUS_SHIFT);
    else if ((rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_RV410) ||
	     (rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_R420))
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] |= (6 << R300_PVS_NUM_FPUS_SHIFT);
    else if ((rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_R520) ||
	     (rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_R580) ||
	     (rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_RV560) ||
	     (rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_RV570))
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] |= (8 << R300_PVS_NUM_FPUS_SHIFT);
    else
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] |= (2 << R300_PVS_NUM_FPUS_SHIFT);

}

/**
 * Enable/Disable states.
 *
 * \note Mesa already filters redundant calls to this function.
 */
static void r300Enable(struct gl_context * ctx, GLenum cap, GLboolean state)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	if (RADEON_DEBUG & RADEON_STATE)
		fprintf(stderr, "%s( %s = %s )\n", __FUNCTION__,
			_mesa_lookup_enum_by_nr(cap),
			state ? "GL_TRUE" : "GL_FALSE");

	switch (cap) {
	case GL_ALPHA_TEST:
		r300SetAlphaState(ctx);
		break;
	case GL_COLOR_LOGIC_OP:
		r300SetLogicOpState(ctx);
		/* fall-through, because logic op overrides blending */
	case GL_BLEND:
		r300SetBlendState(ctx);
		break;
	case GL_CLIP_PLANE0:
	case GL_CLIP_PLANE1:
	case GL_CLIP_PLANE2:
	case GL_CLIP_PLANE3:
	case GL_CLIP_PLANE4:
	case GL_CLIP_PLANE5:
		r300SetClipPlaneState(ctx, cap, state);
		break;
	case GL_CULL_FACE:
		r300UpdateCulling(ctx);
		break;
	case GL_DEPTH_TEST:
		r300SetDepthState(ctx);
		break;
	case GL_LINE_SMOOTH:
		if (rmesa->options.conformance_mode)
			r300SwitchFallback(ctx, R300_FALLBACK_LINE_SMOOTH, ctx->Line.SmoothFlag);
		break;
	case GL_LINE_STIPPLE:
		if (rmesa->options.conformance_mode)
			r300SwitchFallback(ctx, R300_FALLBACK_LINE_STIPPLE, ctx->Line.StippleFlag);
		break;
	case GL_POINT_SMOOTH:
		if (rmesa->options.conformance_mode)
			r300SwitchFallback(ctx, R300_FALLBACK_POINT_SMOOTH, ctx->Point.SmoothFlag);
		break;
	case GL_POLYGON_SMOOTH:
		if (rmesa->options.conformance_mode)
			r300SwitchFallback(ctx, R300_FALLBACK_POLYGON_SMOOTH, ctx->Polygon.SmoothFlag);
		break;
	case GL_POLYGON_STIPPLE:
		if (rmesa->options.conformance_mode)
			r300SwitchFallback(ctx, R300_FALLBACK_POLYGON_STIPPLE, ctx->Polygon.StippleFlag);
		break;
	case GL_POLYGON_OFFSET_POINT:
	case GL_POLYGON_OFFSET_LINE:
	case GL_POLYGON_OFFSET_FILL:
		r300SetPolygonOffsetState(ctx, state);
		break;
	case GL_SCISSOR_TEST:
		radeon_firevertices(&rmesa->radeon);
		rmesa->radeon.state.scissor.enabled = state;
		radeonUpdateScissor( ctx );
		break;
	case GL_STENCIL_TEST:
		r300SetStencilState(ctx, state);
		break;
	default:
		break;
	}
}

/**
 * Completely recalculates hardware state based on the Mesa state.
 */
static void r300ResetHwState(r300ContextPtr r300)
{
	struct gl_context *ctx = r300->radeon.glCtx;
	int has_tcl;

	has_tcl = r300->options.hw_tcl_enabled;

	if (RADEON_DEBUG & RADEON_STATE)
		fprintf(stderr, "%s\n", __FUNCTION__);

	r300ColorMask(ctx,
		      ctx->Color.ColorMask[0][RCOMP],
		      ctx->Color.ColorMask[0][GCOMP],
		      ctx->Color.ColorMask[0][BCOMP],
                      ctx->Color.ColorMask[0][ACOMP]);

	r300Enable(ctx, GL_DEPTH_TEST, ctx->Depth.Test);
	r300DepthMask(ctx, ctx->Depth.Mask);
	r300DepthFunc(ctx, ctx->Depth.Func);

	/* stencil */
	r300Enable(ctx, GL_STENCIL_TEST, ctx->Stencil._Enabled);
	r300StencilMaskSeparate(ctx, 0, ctx->Stencil.WriteMask[0]);
	r300StencilFuncSeparate(ctx, 0, ctx->Stencil.Function[0],
				ctx->Stencil.Ref[0], ctx->Stencil.ValueMask[0]);
	r300StencilOpSeparate(ctx, 0, ctx->Stencil.FailFunc[0],
			      ctx->Stencil.ZFailFunc[0],
			      ctx->Stencil.ZPassFunc[0]);

	r300UpdateCulling(ctx);

	r300SetBlendState(ctx);
	r300SetLogicOpState(ctx);

	r300AlphaFunc(ctx, ctx->Color.AlphaFunc, ctx->Color.AlphaRef);
	r300Enable(ctx, GL_ALPHA_TEST, ctx->Color.AlphaEnabled);

	r300->hw.vte.cmd[1] = R300_VPORT_X_SCALE_ENA
	    | R300_VPORT_X_OFFSET_ENA
	    | R300_VPORT_Y_SCALE_ENA
	    | R300_VPORT_Y_OFFSET_ENA
	    | R300_VPORT_Z_SCALE_ENA
	    | R300_VPORT_Z_OFFSET_ENA | R300_VTX_W0_FMT;
	r300->hw.vte.cmd[2] = 0x00000008;

	r300->hw.vap_vf_max_vtx_indx.cmd[1] = 0x00FFFFFF;
	r300->hw.vap_vf_max_vtx_indx.cmd[2] = 0x00000000;

#ifdef MESA_LITTLE_ENDIAN
	r300->hw.vap_cntl_status.cmd[1] = R300_VC_NO_SWAP;
#else
	r300->hw.vap_cntl_status.cmd[1] = R300_VC_32BIT_SWAP;
#endif

	/* disable VAP/TCL on non-TCL capable chips */
	if (!has_tcl)
		r300->hw.vap_cntl_status.cmd[1] |= R300_VAP_TCL_BYPASS;

	r300->hw.vap_psc_sgn_norm_cntl.cmd[1] = 0xAAAAAAAA;

	/* XXX: Other families? */
	if (has_tcl) {
		r300->hw.vap_clip_cntl.cmd[1] = R300_PS_UCP_MODE_DIST_COP;

		r300->hw.vap_clip.cmd[1] = r300PackFloat32(1.0); /* X */
		r300->hw.vap_clip.cmd[2] = r300PackFloat32(1.0); /* X */
		r300->hw.vap_clip.cmd[3] = r300PackFloat32(1.0); /* Y */
		r300->hw.vap_clip.cmd[4] = r300PackFloat32(1.0); /* Y */

		switch (r300->radeon.radeonScreen->chip_family) {
		case CHIP_FAMILY_R300:
			r300->hw.vap_pvs_vtx_timeout_reg.cmd[1] = R300_2288_R300;
			break;
		default:
			r300->hw.vap_pvs_vtx_timeout_reg.cmd[1] = R300_2288_RV350;
			break;
		}
	}

	r300->hw.gb_enable.cmd[1] = R300_GB_POINT_STUFF_ENABLE
	    | R300_GB_LINE_STUFF_ENABLE
	    | R300_GB_TRIANGLE_STUFF_ENABLE;

	r300->hw.gb_misc.cmd[R300_GB_MISC_MSPOS_0] = 0x66666666;
	r300->hw.gb_misc.cmd[R300_GB_MISC_MSPOS_1] = 0x06666666;

	r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] =
	    R300_GB_TILE_ENABLE | R300_GB_TILE_SIZE_16 /*| R300_GB_SUBPIXEL_1_16*/;
	switch (r300->radeon.radeonScreen->num_gb_pipes) {
	case 1:
	default:
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] |=
		    R300_GB_TILE_PIPE_COUNT_RV300;
		break;
	case 2:
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] |=
		    R300_GB_TILE_PIPE_COUNT_R300;
		break;
	case 3:
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] |=
		    R300_GB_TILE_PIPE_COUNT_R420_3P;
		break;
	case 4:
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] |=
		    R300_GB_TILE_PIPE_COUNT_R420;
		break;
	}

	/* XXX: Enable anti-aliasing? */
	r300->hw.gb_misc2.cmd[R300_GB_MISC2_AA_CONFIG] = GB_AA_CONFIG_AA_DISABLE;
	r300->hw.gb_misc2.cmd[R300_GB_MISC2_SELECT] = 0;

	r300->hw.ga_point_s0.cmd[1] = r300PackFloat32(0.0);
	r300->hw.ga_point_s0.cmd[2] = r300PackFloat32(0.0);
	r300->hw.ga_point_s0.cmd[3] = r300PackFloat32(1.0);
	r300->hw.ga_point_s0.cmd[4] = r300PackFloat32(1.0);

	r300->hw.ga_triangle_stipple.cmd[1] = 0x00050005;

	r300PointSize(ctx, 1.0);

	r300->hw.ga_point_minmax.cmd[1] = 0x18000006;
	r300->hw.ga_point_minmax.cmd[2] = 0x00020006;
	r300->hw.ga_point_minmax.cmd[3] = r300PackFloat32(1.0 / 192.0);

	r300LineWidth(ctx, 1.0);

	r300->hw.ga_line_stipple.cmd[1] = 0;
	r300->hw.ga_line_stipple.cmd[2] = r300PackFloat32(0.0);
	r300->hw.ga_line_stipple.cmd[3] = r300PackFloat32(1.0);

	r300ShadeModel(ctx, ctx->Light.ShadeModel);

	r300PolygonMode(ctx, GL_FRONT, ctx->Polygon.FrontMode);
	r300PolygonMode(ctx, GL_BACK, ctx->Polygon.BackMode);
	r300->hw.zbias_cntl.cmd[1] = 0x00000000;

	r300PolygonOffset(ctx, ctx->Polygon.OffsetFactor,
			  ctx->Polygon.OffsetUnits);
	r300Enable(ctx, GL_POLYGON_OFFSET_POINT, ctx->Polygon.OffsetPoint);
	r300Enable(ctx, GL_POLYGON_OFFSET_LINE, ctx->Polygon.OffsetLine);
	r300Enable(ctx, GL_POLYGON_OFFSET_FILL, ctx->Polygon.OffsetFill);

	r300->hw.su_depth_scale.cmd[1] = 0x4B7FFFFF;
	r300->hw.su_depth_scale.cmd[2] = 0x00000000;

	r300->hw.sc_hyperz.cmd[1] = 0x0000001C;
	r300->hw.sc_hyperz.cmd[2] = 0x2DA49525;

	r300->hw.sc_screendoor.cmd[1] = 0x00FFFFFF;

	r300->hw.us_out_fmt.cmd[1] = R500_OUT_FMT_C4_8  |
	  R500_C0_SEL_B | R500_C1_SEL_G | R500_C2_SEL_R | R500_C3_SEL_A;
	r300->hw.us_out_fmt.cmd[2] = R500_OUT_FMT_UNUSED |
	  R500_C0_SEL_B | R500_C1_SEL_G | R500_C2_SEL_R | R500_C3_SEL_A;
	r300->hw.us_out_fmt.cmd[3] = R500_OUT_FMT_UNUSED |
	  R500_C0_SEL_B | R500_C1_SEL_G | R500_C2_SEL_R | R500_C3_SEL_A;
	r300->hw.us_out_fmt.cmd[4] = R500_OUT_FMT_UNUSED |
	  R500_C0_SEL_B | R500_C1_SEL_G | R500_C2_SEL_R | R500_C3_SEL_A;
	r300->hw.us_out_fmt.cmd[5] = R300_W_FMT_W0 | R300_W_SRC_US;

	/* disable fog unit */
	r300->hw.fogs.cmd[R300_FOGS_STATE] = 0;
	r300->hw.fg_depth_src.cmd[1] = R300_FG_DEPTH_SRC_SCAN;

	r300->hw.rb3d_cctl.cmd[1] = 0;

	r300BlendColor(ctx, ctx->Color.BlendColor);

	r300->hw.rb3d_dither_ctl.cmd[1] = 0;
	r300->hw.rb3d_dither_ctl.cmd[2] = 0;
	r300->hw.rb3d_dither_ctl.cmd[3] = 0;
	r300->hw.rb3d_dither_ctl.cmd[4] = 0;
	r300->hw.rb3d_dither_ctl.cmd[5] = 0;
	r300->hw.rb3d_dither_ctl.cmd[6] = 0;
	r300->hw.rb3d_dither_ctl.cmd[7] = 0;
	r300->hw.rb3d_dither_ctl.cmd[8] = 0;
	r300->hw.rb3d_dither_ctl.cmd[9] = 0;

	r300->hw.rb3d_aaresolve_ctl.cmd[1] = 0;

    r300->hw.rb3d_discard_src_pixel_lte_threshold.cmd[1] = 0x00000000;
    r300->hw.rb3d_discard_src_pixel_lte_threshold.cmd[2] = 0xffffffff;

	r300->hw.zb_depthclearvalue.cmd[1] = 0;

	r300->hw.zstencil_format.cmd[2] = R300_ZTOP_DISABLE;
	r300->hw.zstencil_format.cmd[3] = 0x00000003;
	r300->hw.zstencil_format.cmd[4] = 0x00000000;
	r300SetEarlyZState(ctx);

	r300->hw.zb_zmask.cmd[1] = 0;
	r300->hw.zb_zmask.cmd[2] = 0;

	r300->hw.zb_hiz_offset.cmd[1] = 0;

	r300->hw.zb_hiz_pitch.cmd[1] = 0;

	r300VapCntl(r300, 0, 0, 0);
	if (has_tcl) {
		r300->hw.vps.cmd[R300_VPS_ZERO_0] = 0;
		r300->hw.vps.cmd[R300_VPS_ZERO_1] = 0;
		r300->hw.vps.cmd[R300_VPS_POINTSIZE] = r300PackFloat32(1.0);
		r300->hw.vps.cmd[R300_VPS_ZERO_3] = 0;
	}

	r300->radeon.hw.all_dirty = GL_TRUE;
}

void r300UpdateShaders(r300ContextPtr rmesa)
{
	struct gl_context *ctx = rmesa->radeon.glCtx;

	/* should only happenen once, just after context is created */
	/* TODO: shouldn't we fallback to sw here? */
	if (!ctx->FragmentProgram._Current) {
		fprintf(stderr, "No ctx->FragmentProgram._Current!!\n");
		return;
	}

	{
		struct r300_fragment_program *fp;

		fp = r300SelectAndTranslateFragmentShader(ctx);

		r300SwitchFallback(ctx, R300_FALLBACK_FRAGMENT_PROGRAM, fp->error);
	}

	if (rmesa->options.hw_tcl_enabled) {
		struct r300_vertex_program *vp;

		vp = r300SelectAndTranslateVertexShader(ctx);

		r300SwitchFallback(ctx, R300_FALLBACK_VERTEX_PROGRAM, vp->error);
	}

	r300UpdateStateParameters(ctx, _NEW_PROGRAM | _NEW_PROGRAM_CONSTANTS);
	rmesa->radeon.NewGLState = 0;
}

static const GLfloat *get_fragmentprogram_constant(struct gl_context *ctx, GLuint index, GLfloat * buffer)
{
	static const GLfloat dummy[4] = { 0, 0, 0, 0 };
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	struct rc_constant * rcc = &rmesa->selected_fp->code.constants.Constants[index];

	switch(rcc->Type) {
	case RC_CONSTANT_EXTERNAL:
		return ctx->FragmentProgram._Current->Base.Parameters->ParameterValues[rcc->u.External];
	case RC_CONSTANT_IMMEDIATE:
		return rcc->u.Immediate;
	case RC_CONSTANT_STATE:
		switch(rcc->u.State[0]) {
		case RC_STATE_SHADOW_AMBIENT: {
			const int unit = (int) rcc->u.State[1];
			const struct gl_texture_object *texObj = ctx->Texture.Unit[unit]._Current;
			if (texObj) {
				buffer[0] =
				buffer[1] =
				buffer[2] =
				buffer[3] = texObj->Sampler.CompareFailValue;
			}
			return buffer;
		}

		case RC_STATE_R300_WINDOW_DIMENSION: {
			__DRIdrawable * drawable = radeon_get_drawable(&rmesa->radeon);
			buffer[0] = drawable->w * 0.5f;	/* width*0.5 */
			buffer[1] = drawable->h * 0.5f;	/* height*0.5 */
			buffer[2] = 0.5F;	/* for moving range [-1 1] -> [0 1] */
			buffer[3] = 1.0F;	/* not used */
			return buffer;
		}

		case RC_STATE_R300_TEXRECT_FACTOR: {
			struct gl_texture_object *t =
				ctx->Texture.Unit[rcc->u.State[1]].CurrentTex[TEXTURE_RECT_INDEX];

			if (t && t->Image[0][t->BaseLevel]) {
				struct gl_texture_image *image =
					t->Image[0][t->BaseLevel];
				buffer[0] = 1.0 / image->Width2;
				buffer[1] = 1.0 / image->Height2;
			} else {
				buffer[0] = 1.0;
				buffer[1] = 1.0;
			}
			buffer[2] = 1.0;
			buffer[3] = 1.0;
			return buffer;
		}
		}
	}

	return dummy;
}


static void r300SetupPixelShader(struct gl_context *ctx)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	struct r300_fragment_program *fp = rmesa->selected_fp;
	struct r300_fragment_program_code *code;
	int i;

	code = &fp->code.code.r300;

	R300_STATECHANGE(rmesa, fpi[0]);
	R300_STATECHANGE(rmesa, fpi[1]);
	R300_STATECHANGE(rmesa, fpi[2]);
	R300_STATECHANGE(rmesa, fpi[3]);
	rmesa->hw.fpi[0].cmd[R300_FPI_CMD_0] = cmdpacket0(rmesa->radeon.radeonScreen, R300_US_ALU_RGB_INST_0, code->alu.length);
	rmesa->hw.fpi[1].cmd[R300_FPI_CMD_0] = cmdpacket0(rmesa->radeon.radeonScreen, R300_US_ALU_RGB_ADDR_0, code->alu.length);
	rmesa->hw.fpi[2].cmd[R300_FPI_CMD_0] = cmdpacket0(rmesa->radeon.radeonScreen, R300_US_ALU_ALPHA_INST_0, code->alu.length);
	rmesa->hw.fpi[3].cmd[R300_FPI_CMD_0] = cmdpacket0(rmesa->radeon.radeonScreen, R300_US_ALU_ALPHA_ADDR_0, code->alu.length);
	for (i = 0; i < code->alu.length; i++) {
		rmesa->hw.fpi[0].cmd[R300_FPI_INSTR_0 + i] = code->alu.inst[i].rgb_inst;
		rmesa->hw.fpi[1].cmd[R300_FPI_INSTR_0 + i] = code->alu.inst[i].rgb_addr;
		rmesa->hw.fpi[2].cmd[R300_FPI_INSTR_0 + i] = code->alu.inst[i].alpha_inst;
		rmesa->hw.fpi[3].cmd[R300_FPI_INSTR_0 + i] = code->alu.inst[i].alpha_addr;
	}

	R300_STATECHANGE(rmesa, fp);
	rmesa->hw.fp.cmd[R300_FP_CNTL0] = code->config;
	rmesa->hw.fp.cmd[R300_FP_CNTL1] = code->pixsize;
	rmesa->hw.fp.cmd[R300_FP_CNTL2] = code->code_offset;
	for (i = 0; i < 4; i++)
		rmesa->hw.fp.cmd[R300_FP_NODE0 + i] = code->code_addr[i];

	R300_STATECHANGE(rmesa, fpp);
	rmesa->hw.fpp.cmd[R300_FPP_CMD_0] = cmdpacket0(rmesa->radeon.radeonScreen, R300_PFS_PARAM_0_X, fp->code.constants.Count * 4);
	for (i = 0; i < fp->code.constants.Count; i++) {
		GLfloat buffer[4];
		const GLfloat *constant = get_fragmentprogram_constant(ctx, i, buffer);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 0] = r300PackFloat24(constant[0]);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 1] = r300PackFloat24(constant[1]);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 2] = r300PackFloat24(constant[2]);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 3] = r300PackFloat24(constant[3]);
	}
}

#define bump_r500fp_count(ptr, new_count)   do{\
	drm_r300_cmd_header_t* _p=((drm_r300_cmd_header_t*)(ptr));\
	int _nc=(new_count)/6; \
	assert(_nc < 256); \
	if(_nc>_p->r500fp.count)_p->r500fp.count=_nc;\
} while(0)

#define bump_r500fp_const_count(ptr, new_count)   do{\
	drm_r300_cmd_header_t* _p=((drm_r300_cmd_header_t*)(ptr));\
	int _nc=(new_count)/4; \
	assert(_nc < 256); \
	if(_nc>_p->r500fp.count)_p->r500fp.count=_nc;\
} while(0)

static void r500SetupPixelShader(struct gl_context *ctx)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	struct r300_fragment_program *fp = rmesa->selected_fp;
	int i;
	struct r500_fragment_program_code *code;

	((drm_r300_cmd_header_t *) rmesa->hw.r500fp.cmd)->r500fp.count = 0;
	((drm_r300_cmd_header_t *) rmesa->hw.r500fp_const.cmd)->r500fp.count = 0;

	code = &fp->code.code.r500;

	R300_STATECHANGE(rmesa, fp);
	rmesa->hw.fp.cmd[R500_FP_PIXSIZE] = code->max_temp_idx;

	rmesa->hw.fp.cmd[R500_FP_CODE_ADDR] =
	    R500_US_CODE_START_ADDR(0) |
	    R500_US_CODE_END_ADDR(code->inst_end);
	rmesa->hw.fp.cmd[R500_FP_CODE_RANGE] =
	    R500_US_CODE_RANGE_ADDR(0) |
	    R500_US_CODE_RANGE_SIZE(code->inst_end);
	rmesa->hw.fp.cmd[R500_FP_CODE_OFFSET] =
	    R500_US_CODE_OFFSET_ADDR(0);

	R300_STATECHANGE(rmesa, r500fp);
	/* Emit our shader... */
	for (i = 0; i < code->inst_end+1; i++) {
		rmesa->hw.r500fp.cmd[i*6+1] = code->inst[i].inst0;
		rmesa->hw.r500fp.cmd[i*6+2] = code->inst[i].inst1;
		rmesa->hw.r500fp.cmd[i*6+3] = code->inst[i].inst2;
		rmesa->hw.r500fp.cmd[i*6+4] = code->inst[i].inst3;
		rmesa->hw.r500fp.cmd[i*6+5] = code->inst[i].inst4;
		rmesa->hw.r500fp.cmd[i*6+6] = code->inst[i].inst5;
	}

	bump_r500fp_count(rmesa->hw.r500fp.cmd, (code->inst_end + 1) * 6);

	R300_STATECHANGE(rmesa, r500fp_const);
	for (i = 0; i < fp->code.constants.Count; i++) {
		GLfloat buffer[4];
		const GLfloat *constant = get_fragmentprogram_constant(ctx, i, buffer);
		rmesa->hw.r500fp_const.cmd[R300_FPP_PARAM_0 + 4 * i + 0] = r300PackFloat32(constant[0]);
		rmesa->hw.r500fp_const.cmd[R300_FPP_PARAM_0 + 4 * i + 1] = r300PackFloat32(constant[1]);
		rmesa->hw.r500fp_const.cmd[R300_FPP_PARAM_0 + 4 * i + 2] = r300PackFloat32(constant[2]);
		rmesa->hw.r500fp_const.cmd[R300_FPP_PARAM_0 + 4 * i + 3] = r300PackFloat32(constant[3]);
	}
	bump_r500fp_const_count(rmesa->hw.r500fp_const.cmd, fp->code.constants.Count * 4);
}

void r300SetupVAP(struct gl_context *ctx, GLuint InputsRead, GLuint OutputsWritten)
{
	r300ContextPtr rmesa = R300_CONTEXT( ctx );
	struct vertex_attribute *attrs = rmesa->vbuf.attribs;
	int i, j, reg_count;
	uint32_t *vir0 = &rmesa->hw.vir[0].cmd[1];
	uint32_t *vir1 = &rmesa->hw.vir[1].cmd[1];

	for (i = 0; i < R300_VIR_CMDSIZE-1; ++i)
		vir0[i] = vir1[i] = 0;

	for (i = 0, j = 0; i < rmesa->vbuf.num_attribs; ++i) {
		int tmp;

		tmp = attrs[i].data_type | (attrs[i].dst_loc << R300_DST_VEC_LOC_SHIFT);
		if (attrs[i]._signed)
			tmp |= R300_SIGNED;
		if (attrs[i].normalize)
			tmp |= R300_NORMALIZE;

		if (i % 2 == 0) {
			vir0[j] = tmp << R300_DATA_TYPE_0_SHIFT;
			vir1[j] = attrs[i].swizzle | (attrs[i].write_mask << R300_WRITE_ENA_SHIFT);
		} else {
			vir0[j] |= tmp << R300_DATA_TYPE_1_SHIFT;
			vir1[j] |= (attrs[i].swizzle | (attrs[i].write_mask << R300_WRITE_ENA_SHIFT)) << R300_SWIZZLE1_SHIFT;
			++j;
		}
	}

	reg_count = (rmesa->vbuf.num_attribs + 1) >> 1;
	if (rmesa->vbuf.num_attribs % 2 != 0) {
		vir0[reg_count-1] |= R300_LAST_VEC << R300_DATA_TYPE_0_SHIFT;
	} else {
		vir0[reg_count-1] |= R300_LAST_VEC << R300_DATA_TYPE_1_SHIFT;
	}

	R300_STATECHANGE(rmesa, vir[0]);
	R300_STATECHANGE(rmesa, vir[1]);
	R300_STATECHANGE(rmesa, vof);
	R300_STATECHANGE(rmesa, vic);

	if (rmesa->radeon.radeonScreen->kernel_mm) {
		rmesa->hw.vir[0].cmd[0] &= 0xC000FFFF;
		rmesa->hw.vir[1].cmd[0] &= 0xC000FFFF;
		rmesa->hw.vir[0].cmd[0] |= (reg_count & 0x3FFF) << 16;
		rmesa->hw.vir[1].cmd[0] |= (reg_count & 0x3FFF) << 16;
	} else {
		((drm_r300_cmd_header_t *) rmesa->hw.vir[0].cmd)->packet0.count = reg_count;
		((drm_r300_cmd_header_t *) rmesa->hw.vir[1].cmd)->packet0.count = reg_count;
	}

	rmesa->hw.vic.cmd[R300_VIC_CNTL_0] = r300VAPInputCntl0(ctx, InputsRead);
	rmesa->hw.vic.cmd[R300_VIC_CNTL_1] = r300VAPInputCntl1(ctx, InputsRead);
	rmesa->hw.vof.cmd[R300_VOF_CNTL_0] = r300VAPOutputCntl0(ctx, OutputsWritten);
	rmesa->hw.vof.cmd[R300_VOF_CNTL_1] = r300VAPOutputCntl1(ctx, OutputsWritten);
}

void r300UpdateShaderStates(r300ContextPtr rmesa)
{
	struct gl_context *ctx;
	ctx = rmesa->radeon.glCtx;

	/* should only happenen once, just after context is created */
	if (!ctx->FragmentProgram._Current)
		return;

	r300SetEarlyZState(ctx);

	r300SetupTextures(ctx);

	rmesa->vtbl.SetupPixelShader(ctx);

	rmesa->vtbl.SetupRSUnit(ctx);

	if (rmesa->options.hw_tcl_enabled) {
		r300SetupVertexProgram(rmesa);
	}
}

#define EASY_US_OUT_FMT(comps, c0, c1, c2, c3) \
	(R500_OUT_FMT_##comps | R500_C0_SEL_##c0 | R500_C1_SEL_##c1 | \
	 R500_C2_SEL_##c2 | R500_C3_SEL_##c3)
static void r300SetupUsOutputFormat(struct gl_context *ctx)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	uint32_t hw_format;
	struct radeon_renderbuffer *rrb = radeon_get_colorbuffer(&rmesa->radeon);

	if (!rrb) {
		return;
	}
	
	switch (rrb->base.Format)
	{
		case MESA_FORMAT_RGBA5551:
		case MESA_FORMAT_RGBA8888:
			hw_format = EASY_US_OUT_FMT(C4_8, A, B, G, R);
			break;
		case MESA_FORMAT_RGB565_REV:
		case MESA_FORMAT_RGBA8888_REV:
			hw_format = EASY_US_OUT_FMT(C4_8, R, G, B, A);
			break;
		case MESA_FORMAT_RGB565:
		case MESA_FORMAT_ARGB4444:
		case MESA_FORMAT_ARGB1555:
		case MESA_FORMAT_XRGB8888:
		case MESA_FORMAT_ARGB8888:
			hw_format = EASY_US_OUT_FMT(C4_8, B, G, R, A);
			break;
		case MESA_FORMAT_ARGB4444_REV:
		case MESA_FORMAT_ARGB1555_REV:
		case MESA_FORMAT_XRGB8888_REV:
		case MESA_FORMAT_ARGB8888_REV:
			hw_format = EASY_US_OUT_FMT(C4_8, A, R, G, B);
			break;
		case MESA_FORMAT_SRGBA8:
			hw_format = EASY_US_OUT_FMT(C4_10_GAMMA, A, B, G, R);
			break;
		case MESA_FORMAT_SARGB8:
			hw_format = EASY_US_OUT_FMT(C4_10_GAMMA, B, G, R, A);
			break;
		case MESA_FORMAT_SL8:
			hw_format = EASY_US_OUT_FMT(C4_10_GAMMA, A, A, R, A);
			break;
		case MESA_FORMAT_A8:
			hw_format = EASY_US_OUT_FMT(C4_8, A, A, A, A);
			break;
		case MESA_FORMAT_L8:
		case MESA_FORMAT_I8:
			hw_format = EASY_US_OUT_FMT(C4_8, A, A, R, A);
			break;
		default:
			assert(!"Unsupported format");
			hw_format = 0;
			break;
	}

	R300_STATECHANGE(rmesa, us_out_fmt);
	rmesa->hw.us_out_fmt.cmd[1] = hw_format;
}
#undef EASY_US_OUT_FMT

/**
 * Called by Mesa after an internal state update.
 */
static void r300InvalidateState(struct gl_context * ctx, GLuint new_state)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);

	_swrast_InvalidateState(ctx, new_state);
	_swsetup_InvalidateState(ctx, new_state);
	_vbo_InvalidateState(ctx, new_state);
	_tnl_InvalidateState(ctx, new_state);

	if (new_state & _NEW_BUFFERS) {
		_mesa_update_framebuffer(ctx);
		/* this updates the DrawBuffer's Width/Height if it's a FBO */
		_mesa_update_draw_buffer_bounds(ctx);

		R300_STATECHANGE(r300, cb);
		R300_STATECHANGE(r300, zb);
	}

	if (new_state & (_NEW_LIGHT)) {
		R300_STATECHANGE(r300, shade2);
		if (ctx->Light.ProvokingVertex == GL_LAST_VERTEX_CONVENTION)
			r300->hw.shade2.cmd[1] |= R300_GA_COLOR_CONTROL_PROVOKING_VERTEX_LAST;
		else
			r300->hw.shade2.cmd[1] &= ~R300_GA_COLOR_CONTROL_PROVOKING_VERTEX_LAST;
	}

	if (new_state & _NEW_BUFFERS) {
		r300SetupUsOutputFormat(ctx);
	}

	r300->radeon.NewGLState |= new_state;
}

/**
 * Calculate initial hardware state and register state functions.
 * Assumes that the command buffer and state atoms have been
 * initialized already.
 */
void r300InitState(r300ContextPtr r300)
{
	r300ResetHwState(r300);
}

static void r300RenderMode(struct gl_context * ctx, GLenum mode)
{
	r300SwitchFallback(ctx, R300_FALLBACK_RENDER_MODE, ctx->RenderMode != GL_RENDER);
}

/**
 * Initialize driver's state callback functions
 */
void r300InitStateFuncs(radeonContextPtr radeon, struct dd_function_table *functions)
{

	functions->UpdateState = r300InvalidateState;
	functions->AlphaFunc = r300AlphaFunc;
	functions->BlendColor = r300BlendColor;
	functions->BlendEquationSeparate = r300BlendEquationSeparate;
	functions->BlendFuncSeparate = r300BlendFuncSeparate;
	functions->Enable = r300Enable;
	functions->ColorMask = r300ColorMask;
	functions->DepthFunc = r300DepthFunc;
	functions->DepthMask = r300DepthMask;
	functions->CullFace = r300CullFace;
	functions->FrontFace = r300FrontFace;
	functions->ShadeModel = r300ShadeModel;
	functions->LogicOpcode = r300LogicOpcode;

	/* ARB_point_parameters */
	functions->PointParameterfv = r300PointParameter;

	/* Stencil related */
	functions->StencilFuncSeparate = r300StencilFuncSeparate;
	functions->StencilMaskSeparate = r300StencilMaskSeparate;
	functions->StencilOpSeparate = r300StencilOpSeparate;

	/* Viewport related */
	functions->Viewport = r300Viewport;
	functions->DepthRange = r300DepthRange;
	functions->PointSize = r300PointSize;
	functions->LineWidth = r300LineWidth;

	functions->PolygonOffset = r300PolygonOffset;
	functions->PolygonMode = r300PolygonMode;

	functions->RenderMode = r300RenderMode;

	functions->ClipPlane = r300ClipPlane;
	functions->Scissor = radeonScissor;

	functions->DrawBuffer = radeonDrawBuffer;
	functions->ReadBuffer = radeonReadBuffer;

	functions->CopyPixels = _mesa_meta_CopyPixels;
	functions->DrawPixels = _mesa_meta_DrawPixels;
	if (radeon->radeonScreen->kernel_mm)
		functions->ReadPixels = radeonReadPixels;
}

void r300InitShaderFunctions(r300ContextPtr r300)
{
	if (r300->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
		r300->vtbl.SetupRSUnit = r500SetupRSUnit;
		r300->vtbl.SetupPixelShader = r500SetupPixelShader;
		r300->vtbl.SetupFragmentShaderTextures = r500SetupFragmentShaderTextures;
	} else {
		r300->vtbl.SetupRSUnit = r300SetupRSUnit;
		r300->vtbl.SetupPixelShader = r300SetupPixelShader;
		r300->vtbl.SetupFragmentShaderTextures = r300SetupFragmentShaderTextures;
	}
}
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@@


1.6
log
@Merge Mesa 7.10.3
@
text
@d217 1
a217 1
	if (RGBA_LOGICOP_ENABLED(ctx) || !ctx->Color.BlendEnabled) {
d223 2
a224 2
	    (blend_factor(ctx->Color.BlendSrcRGB, GL_TRUE) <<
	     R300_SRC_BLEND_SHIFT) | (blend_factor(ctx->Color.BlendDstRGB,
d228 1
a228 1
	switch (ctx->Color.BlendEquationRGB) {
d256 1
a256 1
			__FUNCTION__, __LINE__, ctx->Color.BlendEquationRGB);
d261 2
a262 2
	    (blend_factor(ctx->Color.BlendSrcA, GL_TRUE) <<
	     R300_SRC_BLEND_SHIFT) | (blend_factor(ctx->Color.BlendDstA,
d266 1
a266 1
	switch (ctx->Color.BlendEquationA) {
d294 1
a294 1
			__FUNCTION__, __LINE__, ctx->Color.BlendEquationA);
d338 1
a338 1
	if (RGBA_LOGICOP_ENABLED(ctx)) {
d352 1
a352 1
	if (RGBA_LOGICOP_ENABLED(ctx))
d1346 1
a1346 1
				translate_lod_bias(ctx->Texture.Unit[i].LodBias + t->base.LodBias);
a1621 1
#define MIN3(a, b, c)	((a) < (b) ? MIN2(a, c) : MIN2(b, c))
d2016 1
a2016 1
				buffer[3] = texObj->CompareFailValue;
@


1.5
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d49 1
d52 2
a53 2
#include "shader/prog_parameter.h"
#include "shader/prog_statevars.h"
a55 1
#include "tnl/t_vp_build.h"
d65 1
a65 1
static void r300BlendColor(GLcontext * ctx, const GLfloat cf[4])
d207 1
a207 1
static void r300SetBlendState(GLcontext * ctx)
d305 1
a305 1
static void r300BlendEquationSeparate(GLcontext * ctx,
d311 1
a311 1
static void r300BlendFuncSeparate(GLcontext * ctx,
d334 1
a334 1
static void r300SetLogicOpState(GLcontext *ctx)
d350 1
a350 1
static void r300LogicOpcode(GLcontext *ctx, GLenum logicop)
d356 1
a356 1
static void r300ClipPlane( GLcontext *ctx, GLenum plane, const GLfloat *eq )
d376 1
a376 1
static void r300SetClipPlaneState(GLcontext * ctx, GLenum cap, GLboolean state)
d398 1
a398 1
static void r300UpdateCulling(GLcontext * ctx)
d438 1
a438 1
static void r300SetPolygonOffsetState(GLcontext * ctx, GLboolean state)
d450 1
a450 1
static GLboolean current_fragment_program_writes_depth(GLcontext* ctx)
d457 1
a457 1
static void r300SetEarlyZState(GLcontext * ctx)
d502 1
a502 1
static void r300SetAlphaState(GLcontext * ctx)
d552 1
a552 1
static void r300AlphaFunc(GLcontext * ctx, GLenum func, GLfloat ref)
d582 1
a582 1
static void r300SetDepthState(GLcontext * ctx)
d592 1
a592 1
	if (ctx->Depth.Test) {
d601 1
a601 1
static void r300CatchStencilFallback(GLcontext *ctx)
d619 1
a619 1
static void r300SetStencilState(GLcontext * ctx, GLboolean state)
d644 1
a644 1
static void r300UpdatePolygonMode(GLcontext * ctx)
d707 1
a707 1
static void r300CullFace(GLcontext * ctx, GLenum mode)
d719 1
a719 1
static void r300FrontFace(GLcontext * ctx, GLenum mode)
d732 1
a732 1
static void r300DepthFunc(GLcontext * ctx, GLenum func)
d743 1
a743 1
static void r300DepthMask(GLcontext * ctx, GLboolean mask)
d752 1
a752 1
static void r300ColorMask(GLcontext * ctx,
d770 1
a770 1
static void r300PointSize(GLcontext * ctx, GLfloat size)
d787 1
a787 1
static void r300PointParameter(GLcontext * ctx, GLenum pname, const GLfloat * param)
d817 1
a817 1
static void r300LineWidth(GLcontext * ctx, GLfloat widthf)
d829 1
a829 1
static void r300PolygonMode(GLcontext * ctx, GLenum face, GLenum mode)
d867 1
a867 1
static void r300ShadeModel(GLcontext * ctx, GLenum mode)
d888 1
a888 1
static void r300StencilFuncSeparate(GLcontext * ctx, GLenum face,
d935 1
a935 1
static void r300StencilMaskSeparate(GLcontext * ctx, GLenum face, GLuint mask)
d959 1
a959 1
static void r300StencilOpSeparate(GLcontext * ctx, GLenum face,
d995 1
a995 1
static void r300UpdateWindow(GLcontext * ctx)
d1031 1
a1031 1
static void r300Viewport(GLcontext * ctx, GLint x, GLint y,
d1043 1
a1043 1
static void r300DepthRange(GLcontext * ctx, GLclampd nearval, GLclampd farval)
d1048 1
a1048 1
void r300UpdateViewportOffset(GLcontext * ctx)
d1077 1
a1077 1
static void r300UpdateStateParameters(GLcontext * ctx, GLuint new_state)
d1099 1
a1099 1
static void r300PolygonOffset(GLcontext * ctx, GLfloat factor, GLfloat units)
d1196 1
a1196 1
static void r300SetupFragmentShaderTextures(GLcontext *ctx, int *tmu_mappings)
d1238 1
a1238 1
static void r500SetupFragmentShaderTextures(GLcontext *ctx, int *tmu_mappings)
d1283 1
a1283 1
static void r300SetupTextures(GLcontext * ctx)
d1430 1
a1430 1
static void r300SetupRSUnit(GLcontext * ctx)
d1524 1
a1524 1
static void r500SetupRSUnit(GLcontext * ctx)
d1684 1
a1684 1
static void r300Enable(GLcontext * ctx, GLenum cap, GLboolean state)
d1759 1
a1759 1
	GLcontext *ctx = r300->radeon.glCtx;
d1968 1
a1968 1
	GLcontext *ctx = rmesa->radeon.glCtx;
d1997 1
a1997 1
static const GLfloat *get_fragmentprogram_constant(GLcontext *ctx, GLuint index, GLfloat * buffer)
d2055 1
a2055 1
static void r300SetupPixelShader(GLcontext *ctx)
d2112 1
a2112 1
static void r500SetupPixelShader(GLcontext *ctx)
d2161 1
a2161 1
void r300SetupVAP(GLcontext *ctx, GLuint InputsRead, GLuint OutputsWritten)
d2221 1
a2221 1
	GLcontext *ctx;
d2241 63
d2307 1
a2307 1
static void r300InvalidateState(GLcontext * ctx, GLuint new_state)
d2333 4
d2350 1
a2350 1
static void r300RenderMode(GLcontext * ctx, GLenum mode)
d2358 1
a2358 1
void r300InitStateFuncs(struct dd_function_table *functions)
d2397 7
a2403 2
	functions->DrawBuffer		= radeonDrawBuffer;
	functions->ReadBuffer		= radeonReadBuffer;
@


1.4
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d45 1
a47 1
#include "main/texformat.h"
d55 1
a56 2
#include "radeon_ioctl.h"
#include "radeon_state.h"
a57 1
#include "r300_ioctl.h"
d61 3
a63 7
#include "r300_fragprog.h"
#include "r300_tex.h"

#include "drirenderbuffer.h"

extern int future_hw_tcl_on;
extern void _tnl_UpdateFixedFunctionProgram(GLcontext * ctx);
d363 1
a363 1
	if (!(rmesa->radeon.radeonScreen->chip_flags & RADEON_CHIPSET_TCL))
d382 1
a382 1
	if (!(r300->radeon.radeonScreen->chip_flags & RADEON_CHIPSET_TCL))
d430 4
d454 1
a454 10
	if (r300->radeon.radeonScreen->chip_family < CHIP_FAMILY_RV515) {
		struct r300_fragment_program *fp = (struct r300_fragment_program *)
			(char *)ctx->FragmentProgram._Current;
		return (fp && fp->WritesDepth);
	} else {
		struct r500_fragment_program* fp =
			(struct r500_fragment_program*)(char*)
			ctx->FragmentProgram._Current;
		return (fp && fp->writes_depth);
	}
d461 1
d465 5
a469 1
	if (current_fragment_program_writes_depth(ctx))
d480 20
a549 2

	r300SetEarlyZState(ctx);
d587 3
a589 1
	r300->hw.zs.cmd[R300_ZS_CNTL_0] &= R300_STENCIL_ENABLE|R300_STENCIL_FRONT_BACK;
d599 1
d601 16
a616 1
	r300SetEarlyZState(ctx);
d622 1
d624 9
a632 1
	if (r300->state.stencil.hw_stencil) {
a640 4
	} else {
#if R200_MERGED
		FALLBACK(&r300->radeon, RADEON_FALLBACK_STENCIL, state);
#endif
d768 1
a768 1
 * Fog
d770 1
a770 1
static void r300Fogfv(GLcontext * ctx, GLenum pname, const GLfloat * param)
a772 4
	union {
		int i;
		float f;
	} fogScale, fogStart;
d774 3
a776 1
	(void)param;
d778 1
a778 121
	fogScale.i = r300->hw.fogp.cmd[R300_FOGP_SCALE];
	fogStart.i = r300->hw.fogp.cmd[R300_FOGP_START];

	switch (pname) {
	case GL_FOG_MODE:
		switch (ctx->Fog.Mode) {
		case GL_LINEAR:
			R300_STATECHANGE(r300, fogs);
			r300->hw.fogs.cmd[R300_FOGS_STATE] =
			    (r300->hw.fogs.
			     cmd[R300_FOGS_STATE] & ~R300_FG_FOG_BLEND_FN_MASK) |
			    R300_FG_FOG_BLEND_FN_LINEAR;

			if (ctx->Fog.Start == ctx->Fog.End) {
				fogScale.f = -1.0;
				fogStart.f = 1.0;
			} else {
				fogScale.f =
				    1.0 / (ctx->Fog.End - ctx->Fog.Start);
				fogStart.f =
				    -ctx->Fog.Start / (ctx->Fog.End -
						       ctx->Fog.Start);
			}
			break;
		case GL_EXP:
			R300_STATECHANGE(r300, fogs);
			r300->hw.fogs.cmd[R300_FOGS_STATE] =
			    (r300->hw.fogs.
			     cmd[R300_FOGS_STATE] & ~R300_FG_FOG_BLEND_FN_MASK) |
			    R300_FG_FOG_BLEND_FN_EXP;
			fogScale.f = 0.0933 * ctx->Fog.Density;
			fogStart.f = 0.0;
			break;
		case GL_EXP2:
			R300_STATECHANGE(r300, fogs);
			r300->hw.fogs.cmd[R300_FOGS_STATE] =
			    (r300->hw.fogs.
			     cmd[R300_FOGS_STATE] & ~R300_FG_FOG_BLEND_FN_MASK) |
			    R300_FG_FOG_BLEND_FN_EXP2;
			fogScale.f = 0.3 * ctx->Fog.Density;
			fogStart.f = 0.0;
		default:
			return;
		}
		break;
	case GL_FOG_DENSITY:
		switch (ctx->Fog.Mode) {
		case GL_EXP:
			fogScale.f = 0.0933 * ctx->Fog.Density;
			fogStart.f = 0.0;
			break;
		case GL_EXP2:
			fogScale.f = 0.3 * ctx->Fog.Density;
			fogStart.f = 0.0;
		default:
			break;
		}
		break;
	case GL_FOG_START:
	case GL_FOG_END:
		if (ctx->Fog.Mode == GL_LINEAR) {
			if (ctx->Fog.Start == ctx->Fog.End) {
				fogScale.f = -1.0;
				fogStart.f = 1.0;
			} else {
				fogScale.f =
				    1.0 / (ctx->Fog.End - ctx->Fog.Start);
				fogStart.f =
				    -ctx->Fog.Start / (ctx->Fog.End -
						       ctx->Fog.Start);
			}
		}
		break;
	case GL_FOG_COLOR:
		R300_STATECHANGE(r300, fogc);
		r300->hw.fogc.cmd[R300_FOGC_R] =
		    (GLuint) (ctx->Fog.Color[0] * 1023.0F) & 0x3FF;
		r300->hw.fogc.cmd[R300_FOGC_G] =
		    (GLuint) (ctx->Fog.Color[1] * 1023.0F) & 0x3FF;
		r300->hw.fogc.cmd[R300_FOGC_B] =
		    (GLuint) (ctx->Fog.Color[2] * 1023.0F) & 0x3FF;
		break;
	case GL_FOG_COORD_SRC:
		break;
	default:
		return;
	}

	if (fogScale.i != r300->hw.fogp.cmd[R300_FOGP_SCALE] ||
	    fogStart.i != r300->hw.fogp.cmd[R300_FOGP_START]) {
		R300_STATECHANGE(r300, fogp);
		r300->hw.fogp.cmd[R300_FOGP_SCALE] = fogScale.i;
		r300->hw.fogp.cmd[R300_FOGP_START] = fogStart.i;
	}
}

static void r300SetFogState(GLcontext * ctx, GLboolean state)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);

	R300_STATECHANGE(r300, fogs);
	if (state) {
		r300->hw.fogs.cmd[R300_FOGS_STATE] |= R300_FG_FOG_BLEND_ENABLE;

		r300Fogfv(ctx, GL_FOG_MODE, NULL);
		r300Fogfv(ctx, GL_FOG_DENSITY, &ctx->Fog.Density);
		r300Fogfv(ctx, GL_FOG_START, &ctx->Fog.Start);
		r300Fogfv(ctx, GL_FOG_END, &ctx->Fog.End);
		r300Fogfv(ctx, GL_FOG_COLOR, ctx->Fog.Color);
	} else {
		r300->hw.fogs.cmd[R300_FOGS_STATE] &= ~R300_FG_FOG_BLEND_ENABLE;
	}
}

/* =============================================================
 * Point state
 */
static void r300PointSize(GLcontext * ctx, GLfloat size)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
        /* same size limits for AA, non-AA points */
d796 1
d803 1
d873 1
d876 1
a876 1
		rmesa->hw.shade.cmd[2] = R300_RE_SHADE_MODEL_FLAT;
d879 1
a879 1
		rmesa->hw.shade.cmd[2] = R300_RE_SHADE_MODEL_SMOOTH;
d884 2
a885 2
	rmesa->hw.shade.cmd[3] = 0x00000000;
	rmesa->hw.shade.cmd[4] = 0x00000000;
d892 7
a898 2
	GLuint refmask =
	    ((ctx->Stencil.Ref[0] & 0xff) << R300_STENCILREF_SHIFT)
a899 2
	const unsigned back = ctx->Stencil._BackFace;
	GLuint flag;
d921 12
d938 3
d950 7
d965 2
a994 6
/*
 * To correctly position primitives:
 */
#define SUBPIXEL_X 0.125
#define SUBPIXEL_Y 0.125

d998 1
a998 1
	__DRIdrawablePrivate *dPriv = rmesa->radeon.dri.drawable;
d1002 11
d1015 5
a1019 5
	GLfloat tx = v[MAT_TX] + xoffset + SUBPIXEL_X;
	GLfloat sy = -v[MAT_SY];
	GLfloat ty = (-v[MAT_TY]) + yoffset + SUBPIXEL_Y;
	GLfloat sz = v[MAT_SZ] * rmesa->state.depth.scale;
	GLfloat tz = v[MAT_TZ] * rmesa->state.depth.scale;
a1020 1
	R300_FIREVERTICES(rmesa);
d1039 2
d1051 1
a1051 1
	__DRIdrawablePrivate *dPriv = ((radeonContextPtr) rmesa)->dri.drawable;
d1056 2
a1057 2
	GLfloat tx = v[MAT_TX] + xoffset + SUBPIXEL_X;
	GLfloat ty = (-v[MAT_TY]) + yoffset + SUBPIXEL_Y;
a1073 103
 * Tell the card where to render (offset, pitch).
 * Effected by glDrawBuffer, etc
 */
void r300UpdateDrawBuffer(GLcontext * ctx)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	r300ContextPtr r300 = rmesa;
	struct gl_framebuffer *fb = ctx->DrawBuffer;
	driRenderbuffer *drb;

	if (fb->_ColorDrawBufferIndexes[0] == BUFFER_FRONT_LEFT) {
		/* draw to front */
		drb =
		    (driRenderbuffer *) fb->Attachment[BUFFER_FRONT_LEFT].
		    Renderbuffer;
	} else if (fb->_ColorDrawBufferIndexes[0] == BUFFER_BACK_LEFT) {
		/* draw to back */
		drb =
		    (driRenderbuffer *) fb->Attachment[BUFFER_BACK_LEFT].
		    Renderbuffer;
	} else {
		/* drawing to multiple buffers, or none */
		return;
	}

	assert(drb);
	assert(drb->flippedPitch);

	R300_STATECHANGE(rmesa, cb);

	r300->hw.cb.cmd[R300_CB_OFFSET] = drb->flippedOffset +	//r300->radeon.state.color.drawOffset +
	    r300->radeon.radeonScreen->fbLocation;
	r300->hw.cb.cmd[R300_CB_PITCH] = drb->flippedPitch;	//r300->radeon.state.color.drawPitch;

	if (r300->radeon.radeonScreen->cpp == 4)
		r300->hw.cb.cmd[R300_CB_PITCH] |= R300_COLOR_FORMAT_ARGB8888;
	else
		r300->hw.cb.cmd[R300_CB_PITCH] |= R300_COLOR_FORMAT_RGB565;

	if (r300->radeon.sarea->tiling_enabled)
		r300->hw.cb.cmd[R300_CB_PITCH] |= R300_COLOR_TILE_ENABLE;
#if 0
	R200_STATECHANGE(rmesa, ctx);

	/* Note: we used the (possibly) page-flipped values */
	rmesa->hw.ctx.cmd[CTX_RB3D_COLOROFFSET]
	    = ((drb->flippedOffset + rmesa->r200Screen->fbLocation)
	       & R200_COLOROFFSET_MASK);
	rmesa->hw.ctx.cmd[CTX_RB3D_COLORPITCH] = drb->flippedPitch;

	if (rmesa->sarea->tiling_enabled) {
		rmesa->hw.ctx.cmd[CTX_RB3D_COLORPITCH] |=
		    R200_COLOR_TILE_ENABLE;
	}
#endif
}

static void
r300FetchStateParameter(GLcontext * ctx,
			const gl_state_index state[STATE_LENGTH],
			GLfloat * value)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);

	switch (state[0]) {
	case STATE_INTERNAL:
		switch (state[1]) {
		case STATE_R300_WINDOW_DIMENSION:
			value[0] = r300->radeon.dri.drawable->w * 0.5f;	/* width*0.5 */
			value[1] = r300->radeon.dri.drawable->h * 0.5f;	/* height*0.5 */
			value[2] = 0.5F;	/* for moving range [-1 1] -> [0 1] */
			value[3] = 1.0F;	/* not used */
			break;

		case STATE_R300_TEXRECT_FACTOR:{
				struct gl_texture_object *t =
				    ctx->Texture.Unit[state[2]].CurrentTex[TEXTURE_RECT_INDEX];

				if (t && t->Image[0][t->BaseLevel]) {
					struct gl_texture_image *image =
					    t->Image[0][t->BaseLevel];
					value[0] = 1.0 / image->Width2;
					value[1] = 1.0 / image->Height2;
				} else {
					value[0] = 1.0;
					value[1] = 1.0;
				}
				value[2] = 1.0;
				value[3] = 1.0;
				break;
			}

		default:
			break;
		}
		break;

	default:
		break;
	}
}

/**
d1077 1
a1077 1
void r300UpdateStateParameters(GLcontext * ctx, GLuint new_state)
d1079 1
a1079 1
	struct r300_fragment_program *fp;
a1080 1
	GLuint i;
d1082 1
a1082 1
	if (!(new_state & (_NEW_BUFFERS | _NEW_PROGRAM)))
d1085 1
a1085 2
	fp = (struct r300_fragment_program *)ctx->FragmentProgram._Current;
	if (!fp)
d1088 1
a1088 1
	paramList = fp->mesa_program.Base.Parameters;
d1093 1
a1093 8
	for (i = 0; i < paramList->NumParameters; i++) {
		if (paramList->Parameters[i].Type == PROGRAM_STATE_VAR) {
			r300FetchStateParameter(ctx,
						paramList->Parameters[i].
						StateIndexes,
						paramList->ParameterValues[i]);
		}
	}
d1200 1
a1200 3
	struct r300_fragment_program *fp = (struct r300_fragment_program *)
	    (char *)ctx->FragmentProgram._Current;
	struct r300_fragment_program_code *code = &fp->code;
d1234 2
a1235 1
		cmdpacket0(R300_US_TEX_INST_0, code->tex.length);
d1240 1
d1242 1
a1242 3
	struct r500_fragment_program *fp = (struct r500_fragment_program *)
	    (char *)ctx->FragmentProgram._Current;
	struct r500_fragment_program_code *code = &fp->code;
d1282 1
d1286 1
a1286 1
	struct r300_tex_obj *t;
a1290 2
	struct r300_fragment_program *fp = (struct r300_fragment_program *)
	    (char *)ctx->FragmentProgram._Current;
d1305 1
a1305 1
	if (RADEON_DEBUG & DEBUG_STATE)
d1312 1
a1312 1
		_mesa_exit(-1);
a1317 4

#if 0				/* Enables old behaviour */
			hw_tmu = i;
#endif
d1320 1
a1320 2
			t = (r300TexObjPtr) r300->state.texture.unit[i].texobj->DriverData;
			/* XXX questionable fix for bug 9170: */
d1324 1
a1324 1
			if ((t->format & 0xffffff00) == 0xffffff00) {
d1327 1
a1327 1
				     t->format & 0xff);
d1330 1
a1330 1
			if (RADEON_DEBUG & DEBUG_STATE)
d1338 1
a1338 1
			    gen_fixed_filter(t->filter) | (hw_tmu << 28);
d1345 2
a1346 2
				t->filter_1 |
				translate_lod_bias(ctx->Texture.Unit[i].LodBias + t->base.tObj->LodBias);
d1348 1
a1348 1
			    t->size;
d1350 1
a1350 1
						hw_tmu] = t->format;
d1352 2
a1353 3
			    t->pitch_reg;
			r300->hw.tex.offset.cmd[R300_TEX_VALUE_0 +
						hw_tmu] = t->offset;
d1355 1
a1355 1
			if (t->offset & R300_TXO_MACRO_TILE) {
d1359 1
a1359 1
			if (t->offset & R300_TXO_MICRO_TILE) {
d1375 22
d1398 1
a1398 1
	    cmdpacket0(R300_TX_FILTER0_0, last_hw_tmu + 1);
d1400 1
a1400 1
	    cmdpacket0(R300_TX_FILTER1_0, last_hw_tmu + 1);
d1402 1
a1402 1
	    cmdpacket0(R300_TX_SIZE_0, last_hw_tmu + 1);
d1404 1
a1404 1
	    cmdpacket0(R300_TX_FORMAT_0, last_hw_tmu + 1);
d1406 1
a1406 1
	    cmdpacket0(R300_TX_FORMAT2_0, last_hw_tmu + 1);
d1408 1
a1408 1
	    cmdpacket0(R300_TX_OFFSET_0, last_hw_tmu + 1);
d1410 1
a1410 1
	    cmdpacket0(R300_TX_CHROMA_KEY_0, last_hw_tmu + 1);
d1412 1
a1412 4
	    cmdpacket0(R300_TX_BORDER_COLOR_0, last_hw_tmu + 1);

	if (!fp)		/* should only happenen once, just after context is created */
		return;
d1414 1
a1414 12
	if (r300->radeon.radeonScreen->chip_family < CHIP_FAMILY_RV515) {
		if (fp->mesa_program.UsesKill && last_hw_tmu < 0) {
			// The KILL operation requires the first texture unit
			// to be enabled.
			r300->hw.txe.cmd[R300_TXE_ENABLE] |= 1;
			r300->hw.tex.filter.cmd[R300_TEX_VALUE_0] = 0;
			r300->hw.tex.filter.cmd[R300_TEX_CMD_0] =
				cmdpacket0(R300_TX_FILTER0_0, 1);
		}
		r300SetupFragmentShaderTextures(ctx, tmu_mappings);
	} else
		r500SetupFragmentShaderTextures(ctx, tmu_mappings);
d1416 1
a1416 1
	if (RADEON_DEBUG & DEBUG_STATE)
a1432 4
	/* I'm still unsure if these are needed */
	GLuint interp_col[8];
        TNLcontext *tnl = TNL_CONTEXT(ctx);
	struct vertex_buffer *VB = &tnl->vb;
d1436 3
a1438 3
	int col_interp_nr;
	int rs_tex_count = 0, rs_col_count = 0;
	int i, count;
d1440 1
a1440 1
	memset(interp_col, 0, sizeof(interp_col));
d1443 1
a1443 1
		OutputsWritten.vp_outputs = CURRENT_VERTEX_SHADER(ctx)->key.OutputsWritten;
d1445 1
a1445 1
		RENDERINPUTS_COPY(OutputsWritten.index_bitset, r300->state.render_inputs_bitset);
d1447 1
a1447 6
	if (ctx->FragmentProgram._Current)
		InputsRead = ctx->FragmentProgram._Current->Base.InputsRead;
	else {
		fprintf(stderr, "No ctx->FragmentProgram._Current!!\n");
		return;		/* This should only ever happen once.. */
	}
d1453 1
a1453 1
	fp_reg = col_interp_nr = high_rr = 0;
d1455 4
a1458 1
	r300->hw.rr.cmd[R300_RR_INST_1] = 0;
d1460 2
a1461 4
	if (InputsRead & FRAG_BIT_WPOS) {
		for (i = 0; i < ctx->Const.MaxTextureUnits; i++)
			if (!(InputsRead & (FRAG_BIT_TEX0 << i)))
				break;
a1462 74
		if (i == ctx->Const.MaxTextureUnits) {
			fprintf(stderr, "\tno free texcoord found...\n");
			_mesa_exit(-1);
		}

		InputsRead |= (FRAG_BIT_TEX0 << i);
		InputsRead &= ~FRAG_BIT_WPOS;
	}

	if (InputsRead & FRAG_BIT_COL0) {
		count = VB->AttribPtr[_TNL_ATTRIB_COLOR0]->size;
		interp_col[0] |= R300_RS_COL_PTR(rs_col_count);
		if (count == 3)
			interp_col[0] |= R300_RS_COL_FMT(R300_RS_COL_FMT_RGB1);
		rs_col_count += count;
	}
	else
		interp_col[0] = R300_RS_COL_FMT(R300_RS_COL_FMT_0001);

	if (InputsRead & FRAG_BIT_COL1) {
		count = VB->AttribPtr[_TNL_ATTRIB_COLOR1]->size;
		if (count == 3)
			interp_col[1] |= R300_RS_COL_FMT(R300_RS_COL_FMT_RGB0);
		interp_col[1] |= R300_RS_COL_PTR(1);
		rs_col_count += count;
	}

	if (InputsRead & FRAG_BIT_FOGC) {
		/* XXX FIX THIS
		 * Just turn off the bit for now.
		 * Need to do something similar to the color/texcoord inputs.
		 */
		InputsRead &= ~FRAG_BIT_FOGC;
	}

	for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
		int swiz;

		/* with TCL we always seem to route 4 components */
		if (hw_tcl_on)
		  count = 4;
		else
		  count = VB->AttribPtr[_TNL_ATTRIB_TEX(i)]->size;

		r300->hw.ri.cmd[R300_RI_INTERP_0 + i] = interp_col[i] | rs_tex_count;
		switch(count) {
		case 4: swiz = R300_RS_SEL_S(0) | R300_RS_SEL_T(1) | R300_RS_SEL_R(2) | R300_RS_SEL_Q(3); break;
		case 3: swiz = R300_RS_SEL_S(0) | R300_RS_SEL_T(1) | R300_RS_SEL_R(2) | R300_RS_SEL_Q(R300_RS_SEL_K1); break;
		default:
		case 1:
		case 2: swiz = R300_RS_SEL_S(0) | R300_RS_SEL_T(1) | R300_RS_SEL_R(R300_RS_SEL_K0) | R300_RS_SEL_Q(R300_RS_SEL_K1); break;
		};

		r300->hw.ri.cmd[R300_RI_INTERP_0 + i] |= swiz;

		r300->hw.rr.cmd[R300_RR_INST_0 + fp_reg] = 0;
		if (InputsRead & (FRAG_BIT_TEX0 << i)) {

			rs_tex_count += count;

			//assert(r300->state.texture.tc_count != 0);
			r300->hw.rr.cmd[R300_RR_INST_0 + fp_reg] |= R300_RS_INST_TEX_CN_WRITE | i	/* source INTERP */
			    | (fp_reg << R300_RS_INST_TEX_ADDR_SHIFT);
			high_rr = fp_reg;

			/* Passing invalid data here can lock the GPU. */
			if (R300_OUTPUTS_WRITTEN_TEST(OutputsWritten, VERT_RESULT_TEX0 + i, _TNL_ATTRIB_TEX(i))) {
				InputsRead &= ~(FRAG_BIT_TEX0 << i);
				fp_reg++;
			} else {
				WARN_ONCE("fragprog wants coords for tex%d, vp doesn't provide them!\n", i);
			}
		}
	}
d1466 2
a1467 1
			r300->hw.rr.cmd[R300_RR_INST_0] |= R300_RS_INST_COL_ID(0) | R300_RS_INST_COL_CN_WRITE | (fp_reg++ << R300_RS_INST_COL_ADDR_SHIFT);
d1469 2
a1470 1
			col_interp_nr++;
d1478 2
a1479 1
			r300->hw.rr.cmd[R300_RR_INST_1] |= R300_RS_INST_COL_ID(1) | R300_RS_INST_COL_CN_WRITE | (fp_reg++ << R300_RS_INST_COL_ADDR_SHIFT);
d1481 2
a1482 3
			if (high_rr < 1)
				high_rr = 1;
			col_interp_nr++;
d1488 23
a1510 4
	/* Need at least one. This might still lock as the values are undefined... */
	if (rs_tex_count == 0 && col_interp_nr == 0) {
		r300->hw.rr.cmd[R300_RR_INST_0] |= R300_RS_INST_COL_ID(0) | R300_RS_INST_COL_CN_WRITE | (fp_reg++ << R300_RS_INST_COL_ADDR_SHIFT);
		col_interp_nr++;
d1513 6
a1518 7
	r300->hw.rc.cmd[1] = 0 | (rs_tex_count << R300_IT_COUNT_SHIFT)
	  | (col_interp_nr << R300_IC_COUNT_SHIFT)
	  | R300_HIRES_EN;

	assert(high_rr >= 0);
	r300->hw.rr.cmd[R300_RR_CMD_0] = cmdpacket0(R300_RS_INST_0, high_rr + 1);
	r300->hw.rc.cmd[2] = high_rr;
a1526 2
	/* I'm still unsure if these are needed */
	GLuint interp_col[8];
a1527 2
        TNLcontext *tnl = TNL_CONTEXT(ctx);
	struct vertex_buffer *VB = &tnl->vb;
d1530 5
a1534 3
	int rs_col_count = 0;
	int in_texcoords, col_interp_nr;
	int i, count;
a1535 1
	memset(interp_col, 0, sizeof(interp_col));
d1537 1
a1537 1
		OutputsWritten.vp_outputs = CURRENT_VERTEX_SHADER(ctx)->key.OutputsWritten;
d1539 1
a1539 1
		RENDERINPUTS_COPY(OutputsWritten.index_bitset, r300->state.render_inputs_bitset);
d1541 1
a1541 6
	if (ctx->FragmentProgram._Current)
		InputsRead = ctx->FragmentProgram._Current->Base.InputsRead;
	else {
		fprintf(stderr, "No ctx->FragmentProgram._Current!!\n");
		return;		/* This should only ever happen once.. */
	}
d1547 1
a1547 1
	fp_reg = col_interp_nr = high_rr = in_texcoords = 0;
d1549 4
a1552 1
	r300->hw.rr.cmd[R300_RR_INST_1] = 0;
d1554 2
a1555 4
	if (InputsRead & FRAG_BIT_WPOS) {
		for (i = 0; i < ctx->Const.MaxTextureUnits; i++)
			if (!(InputsRead & (FRAG_BIT_TEX0 << i)))
				break;
a1556 79
		if (i == ctx->Const.MaxTextureUnits) {
			fprintf(stderr, "\tno free texcoord found...\n");
			_mesa_exit(-1);
		}

		InputsRead |= (FRAG_BIT_TEX0 << i);
		InputsRead &= ~FRAG_BIT_WPOS;
	}

	if (InputsRead & FRAG_BIT_COL0) {
		count = VB->AttribPtr[_TNL_ATTRIB_COLOR0]->size;
		interp_col[0] |= R500_RS_COL_PTR(rs_col_count);
		if (count == 3)
			interp_col[0] |= R500_RS_COL_FMT(R300_RS_COL_FMT_RGB1);
		rs_col_count += count;
	}
	else
		interp_col[0] = R500_RS_COL_FMT(R300_RS_COL_FMT_0001);

	if (InputsRead & FRAG_BIT_COL1) {
		count = VB->AttribPtr[_TNL_ATTRIB_COLOR1]->size;
		interp_col[1] |= R500_RS_COL_PTR(1);
		if (count == 3)
			interp_col[1] |= R500_RS_COL_FMT(R300_RS_COL_FMT_RGB0);
		rs_col_count += count;
	}

	for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
		GLuint swiz = 0;

		/* with TCL we always seem to route 4 components */
		if (InputsRead & (FRAG_BIT_TEX0 << i)) {

		  if (hw_tcl_on)
		    count = 4;
		  else
		    count = VB->AttribPtr[_TNL_ATTRIB_TEX(i)]->size;

		  /* always have on texcoord */
		  swiz |= in_texcoords++ << R500_RS_IP_TEX_PTR_S_SHIFT;
		  if (count >= 2)
		    swiz |= in_texcoords++ << R500_RS_IP_TEX_PTR_T_SHIFT;
		  else
		    swiz |= R500_RS_IP_PTR_K0 << R500_RS_IP_TEX_PTR_T_SHIFT;

		  if (count >= 3)
		    swiz |= in_texcoords++ << R500_RS_IP_TEX_PTR_R_SHIFT;
		  else
		    swiz |= R500_RS_IP_PTR_K0 << R500_RS_IP_TEX_PTR_R_SHIFT;

		  if (count == 4)
		    swiz |= in_texcoords++ << R500_RS_IP_TEX_PTR_Q_SHIFT;
		  else
		    swiz |= R500_RS_IP_PTR_K1 << R500_RS_IP_TEX_PTR_Q_SHIFT;

		} else
		   swiz = (R500_RS_IP_PTR_K0 << R500_RS_IP_TEX_PTR_S_SHIFT) |
		          (R500_RS_IP_PTR_K0 << R500_RS_IP_TEX_PTR_T_SHIFT) |
		          (R500_RS_IP_PTR_K0 << R500_RS_IP_TEX_PTR_R_SHIFT) |
		          (R500_RS_IP_PTR_K1 << R500_RS_IP_TEX_PTR_Q_SHIFT);

		r300->hw.ri.cmd[R300_RI_INTERP_0 + i] = interp_col[i] | swiz;

		r300->hw.rr.cmd[R300_RR_INST_0 + fp_reg] = 0;
		if (InputsRead & (FRAG_BIT_TEX0 << i)) {
			//assert(r300->state.texture.tc_count != 0);
			r300->hw.rr.cmd[R300_RR_INST_0 + fp_reg] |= R500_RS_INST_TEX_CN_WRITE | i	/* source INTERP */
			    | (fp_reg << R500_RS_INST_TEX_ADDR_SHIFT);
			high_rr = fp_reg;

			/* Passing invalid data here can lock the GPU. */
			if (R300_OUTPUTS_WRITTEN_TEST(OutputsWritten, VERT_RESULT_TEX0 + i, _TNL_ATTRIB_TEX(i))) {
				InputsRead &= ~(FRAG_BIT_TEX0 << i);
				fp_reg++;
			} else {
				WARN_ONCE("fragprog wants coords for tex%d, vp doesn't provide them!\n", i);
			}
		}
	}
d1560 2
a1561 1
			r300->hw.rr.cmd[R300_RR_INST_0] |= R500_RS_INST_COL_CN_WRITE | (fp_reg++ << R500_RS_INST_COL_ADDR_SHIFT);
d1563 2
a1564 1
			col_interp_nr++;
d1572 2
a1573 1
			r300->hw.rr.cmd[R300_RR_INST_1] |= (1 << 12) | R500_RS_INST_COL_CN_WRITE |  (fp_reg++ << R500_RS_INST_COL_ADDR_SHIFT);
d1575 2
a1576 3
			if (high_rr < 1)
				high_rr = 1;
			col_interp_nr++;
d1582 4
a1585 5
	/* Need at least one. This might still lock as the values are undefined... */
	if (in_texcoords == 0 && col_interp_nr == 0) {
		r300->hw.rr.cmd[R300_RR_INST_0] |= 0 | R500_RS_INST_COL_CN_WRITE | (fp_reg++ << R500_RS_INST_COL_ADDR_SHIFT);
		col_interp_nr++;
	}
d1587 4
a1590 11
	r300->hw.rc.cmd[1] = 0 | (in_texcoords << R300_IT_COUNT_SHIFT)
	  | (col_interp_nr << R300_IC_COUNT_SHIFT)
	  | R300_HIRES_EN;

	assert(high_rr >= 0);
	r300->hw.rr.cmd[R300_RR_CMD_0] = cmdpacket0(R500_RS_INST_0, high_rr + 1);
	r300->hw.rc.cmd[2] = 0xC0 | high_rr;

	if (InputsRead)
		WARN_ONCE("Don't know how to satisfy InputsRead=0x%08x\n", InputsRead);
}
d1592 4
d1597 6
d1604 6
d1611 3
a1613 6
#define bump_vpu_count(ptr, new_count)   do{\
	drm_r300_cmd_header_t* _p=((drm_r300_cmd_header_t*)(ptr));\
	int _nc=(new_count)/4; \
	assert(_nc < 256); \
	if(_nc>_p->vpu.count)_p->vpu.count=_nc;\
	}while(0)
d1615 2
a1616 3
static INLINE void r300SetupVertexProgramFragment(r300ContextPtr r300, int dest, struct r300_vertex_shader_fragment *vsf)
{
	int i;
d1618 2
a1619 32
	if (vsf->length == 0)
		return;

	if (vsf->length & 0x3) {
		fprintf(stderr, "VERTEX_SHADER_FRAGMENT must have length divisible by 4\n");
		_mesa_exit(-1);
	}

	switch ((dest >> 8) & 0xf) {
	case 0:
		R300_STATECHANGE(r300, vpi);
		for (i = 0; i < vsf->length; i++)
			r300->hw.vpi.cmd[R300_VPI_INSTR_0 + i + 4 * (dest & 0xff)] = (vsf->body.d[i]);
		bump_vpu_count(r300->hw.vpi.cmd, vsf->length + 4 * (dest & 0xff));
		break;

	case 2:
		R300_STATECHANGE(r300, vpp);
		for (i = 0; i < vsf->length; i++)
			r300->hw.vpp.cmd[R300_VPP_PARAM_0 + i + 4 * (dest & 0xff)] = (vsf->body.d[i]);
		bump_vpu_count(r300->hw.vpp.cmd, vsf->length + 4 * (dest & 0xff));
		break;
	case 4:
		R300_STATECHANGE(r300, vps);
		for (i = 0; i < vsf->length; i++)
			r300->hw.vps.cmd[1 + i + 4 * (dest & 0xff)] = (vsf->body.d[i]);
		bump_vpu_count(r300->hw.vps.cmd, vsf->length + 4 * (dest & 0xff));
		break;
	default:
		fprintf(stderr, "%s:%s don't know how to handle dest %04x\n", __FILE__, __FUNCTION__, dest);
		_mesa_exit(-1);
	}
d1624 1
a1624 2

static void r300VapCntl(r300ContextPtr rmesa, GLuint input_count,
d1648 1
a1648 1
    if (rmesa->radeon.radeonScreen->chip_flags & RADEON_CHIPSET_TCL) {
d1661 4
a1664 5
    if (rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_RV515)
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] |= (2 << R300_PVS_NUM_FPUS_SHIFT);
    else if ((rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_RV530) ||
	     (rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_RV560) ||
	     (rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_RV570))
d1670 3
a1672 1
	     (rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_R580))
d1675 1
a1675 109
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] |= (4 << R300_PVS_NUM_FPUS_SHIFT);

}

static void r300SetupDefaultVertexProgram(r300ContextPtr rmesa)
{
	struct r300_vertex_shader_state *prog = &(rmesa->state.vertex_shader);
	GLuint o_reg = 0;
	GLuint i_reg = 0;
	int i;
	int inst_count = 0;
	int param_count = 0;
	int program_end = 0;

	for (i = VERT_ATTRIB_POS; i < VERT_ATTRIB_MAX; i++) {
		if (rmesa->state.sw_tcl_inputs[i] != -1) {
			prog->program.body.i[program_end + 0] = PVS_OP_DST_OPERAND(VE_MULTIPLY, GL_FALSE, GL_FALSE, o_reg++, VSF_FLAG_ALL, PVS_DST_REG_OUT);
			prog->program.body.i[program_end + 1] = PVS_SRC_OPERAND(rmesa->state.sw_tcl_inputs[i], PVS_SRC_SELECT_X, PVS_SRC_SELECT_Y, PVS_SRC_SELECT_Z, PVS_SRC_SELECT_W, PVS_SRC_REG_INPUT, VSF_FLAG_NONE);
			prog->program.body.i[program_end + 2] = PVS_SRC_OPERAND(rmesa->state.sw_tcl_inputs[i], PVS_SRC_SELECT_FORCE_1, PVS_SRC_SELECT_FORCE_1, PVS_SRC_SELECT_FORCE_1, PVS_SRC_SELECT_FORCE_1, PVS_SRC_REG_INPUT, VSF_FLAG_NONE);
			prog->program.body.i[program_end + 3] = PVS_SRC_OPERAND(rmesa->state.sw_tcl_inputs[i], PVS_SRC_SELECT_FORCE_1, PVS_SRC_SELECT_FORCE_1, PVS_SRC_SELECT_FORCE_1, PVS_SRC_SELECT_FORCE_1, PVS_SRC_REG_INPUT, VSF_FLAG_NONE);
			program_end += 4;
			i_reg++;
		}
	}

	prog->program.length = program_end;

	r300SetupVertexProgramFragment(rmesa, R300_PVS_CODE_START,
				       &(prog->program));
	inst_count = (prog->program.length / 4) - 1;

	r300VapCntl(rmesa, i_reg, o_reg, 0);

	R300_STATECHANGE(rmesa, pvs);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_1] =
	    (0 << R300_PVS_FIRST_INST_SHIFT) |
	    (inst_count << R300_PVS_XYZW_VALID_INST_SHIFT) |
	    (inst_count << R300_PVS_LAST_INST_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_2] =
	    (0 << R300_PVS_CONST_BASE_OFFSET_SHIFT) |
	    (param_count << R300_PVS_MAX_CONST_ADDR_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_3] =
	    (inst_count << R300_PVS_LAST_VTX_SRC_INST_SHIFT);
}

static int bit_count (int x)
{
    x = ((x & 0xaaaaaaaaU) >> 1) + (x & 0x55555555U);
    x = ((x & 0xccccccccU) >> 2) + (x & 0x33333333U);
    x = (x >> 16) + (x & 0xffff);
    x = ((x & 0xf0f0) >> 4) + (x & 0x0f0f);
    return (x >> 8) + (x & 0x00ff);
}

static void r300SetupRealVertexProgram(r300ContextPtr rmesa)
{
	GLcontext *ctx = rmesa->radeon.glCtx;
	struct r300_vertex_program *prog = (struct r300_vertex_program *)CURRENT_VERTEX_SHADER(ctx);
	int inst_count = 0;
	int param_count = 0;

	/* FIXME: r300SetupVertexProgramFragment */
	R300_STATECHANGE(rmesa, vpp);
	param_count =
	    r300VertexProgUpdateParams(ctx,
				       (struct r300_vertex_program_cont *)
				       ctx->VertexProgram._Current,
				       (float *)&rmesa->hw.vpp.
				       cmd[R300_VPP_PARAM_0]);
	bump_vpu_count(rmesa->hw.vpp.cmd, param_count);
	param_count /= 4;

	r300SetupVertexProgramFragment(rmesa, R300_PVS_CODE_START, &(prog->program));
	inst_count = (prog->program.length / 4) - 1;

	r300VapCntl(rmesa, bit_count(prog->key.InputsRead),
		    bit_count(prog->key.OutputsWritten), prog->num_temporaries);

	R300_STATECHANGE(rmesa, pvs);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_1] =
	  (0 << R300_PVS_FIRST_INST_SHIFT) |
	  (inst_count << R300_PVS_XYZW_VALID_INST_SHIFT) |
	  (inst_count << R300_PVS_LAST_INST_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_2] =
	  (0 << R300_PVS_CONST_BASE_OFFSET_SHIFT) |
	  (param_count << R300_PVS_MAX_CONST_ADDR_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_3] =
	  (inst_count << R300_PVS_LAST_VTX_SRC_INST_SHIFT);
}

static void r300SetupVertexProgram(r300ContextPtr rmesa)
{
	GLcontext *ctx = rmesa->radeon.glCtx;

	/* Reset state, in case we don't use something */
	((drm_r300_cmd_header_t *) rmesa->hw.vpp.cmd)->vpu.count = 0;
	((drm_r300_cmd_header_t *) rmesa->hw.vpi.cmd)->vpu.count = 0;
	((drm_r300_cmd_header_t *) rmesa->hw.vps.cmd)->vpu.count = 0;

	/* Not sure why this doesnt work...
	   0x400 area might have something to do with pixel shaders as it appears right after pfs programming.
	   0x406 is set to { 0.0, 0.0, 1.0, 0.0 } most of the time but should change with smooth points and in other rare cases. */
	//setup_vertex_shader_fragment(rmesa, 0x406, &unk4);
	if (hw_tcl_on && ((struct r300_vertex_program *)CURRENT_VERTEX_SHADER(ctx))->translated) {
		r300SetupRealVertexProgram(rmesa);
	} else {
		/* FIXME: This needs to be replaced by vertex shader generation code. */
		r300SetupDefaultVertexProgram(rmesa);
	}
d1686 2
a1687 1
	if (RADEON_DEBUG & DEBUG_STATE)
a1692 8
	case GL_TEXTURE_1D:
	case GL_TEXTURE_2D:
	case GL_TEXTURE_3D:
		/* empty */
		break;
	case GL_FOG:
		r300SetFogState(ctx, state);
		break;
d1710 3
d1716 19
a1734 5
	case GL_STENCIL_TEST:
		r300SetStencilState(ctx, state);
		break;
	case GL_CULL_FACE:
		r300UpdateCulling(ctx);
d1741 8
a1749 1
		radeonEnable(ctx, cap, state);
d1760 1
a1760 1
	int has_tcl = 1;
d1762 1
a1762 2
	if (!(r300->radeon.radeonScreen->chip_flags & RADEON_CHIPSET_TCL))
		has_tcl = 0;
d1764 1
a1764 1
	if (RADEON_DEBUG & DEBUG_STATE)
a1766 2
	r300UpdateWindow(ctx);

d1768 4
a1771 3
		      ctx->Color.ColorMask[RCOMP],
		      ctx->Color.ColorMask[GCOMP],
		      ctx->Color.ColorMask[BCOMP], ctx->Color.ColorMask[ACOMP]);
d1778 1
a1778 1
	r300Enable(ctx, GL_STENCIL_TEST, ctx->Stencil.Enabled);
a1787 2
	r300UpdateTextureState(ctx);

a1864 3
	/* XXX: set to 0 when fog is disabled? */
	r300->hw.gb_misc.cmd[R300_GB_MISC_SELECT] = R300_GB_FOG_SELECT_1_1_W;

d1866 2
a1867 1
	r300->hw.gb_misc.cmd[R300_GB_MISC_AA_CONFIG] = GB_AA_CONFIG_AA_DISABLE;
d1916 1
a1916 9
	r300->hw.us_out_fmt.cmd[5] = R300_W_FMT_W24;

	r300Enable(ctx, GL_FOG, ctx->Fog.Enabled);
	r300Fogfv(ctx, GL_FOG_MODE, NULL);
	r300Fogfv(ctx, GL_FOG_DENSITY, &ctx->Fog.Density);
	r300Fogfv(ctx, GL_FOG_START, &ctx->Fog.Start);
	r300Fogfv(ctx, GL_FOG_END, &ctx->Fog.End);
	r300Fogfv(ctx, GL_FOG_COLOR, ctx->Fog.Color);
	r300Fogfv(ctx, GL_FOG_COORDINATE_SOURCE_EXT, NULL);
d1918 3
a1920 1
	r300->hw.fg_depth_src.cmd[1] = 0;
a1925 14
	/* Again, r300ClearBuffer uses this */
	r300->hw.cb.cmd[R300_CB_OFFSET] =
	    r300->radeon.state.color.drawOffset +
	    r300->radeon.radeonScreen->fbLocation;
	r300->hw.cb.cmd[R300_CB_PITCH] = r300->radeon.state.color.drawPitch;

	if (r300->radeon.radeonScreen->cpp == 4)
		r300->hw.cb.cmd[R300_CB_PITCH] |= R300_COLOR_FORMAT_ARGB8888;
	else
		r300->hw.cb.cmd[R300_CB_PITCH] |= R300_COLOR_FORMAT_RGB565;

	if (r300->radeon.sarea->tiling_enabled)
		r300->hw.cb.cmd[R300_CB_PITCH] |= R300_COLOR_TILE_ENABLE;

d1938 2
a1939 16
	r300->hw.rb3d_discard_src_pixel_lte_threshold.cmd[1] = 0x00000000;
	r300->hw.rb3d_discard_src_pixel_lte_threshold.cmd[2] = 0xffffffff;

	r300->hw.zb.cmd[R300_ZB_OFFSET] =
	    r300->radeon.radeonScreen->depthOffset +
	    r300->radeon.radeonScreen->fbLocation;
	r300->hw.zb.cmd[R300_ZB_PITCH] = r300->radeon.radeonScreen->depthPitch;

	if (r300->radeon.sarea->tiling_enabled) {
		/* XXX: Turn off when clearing buffers ? */
		r300->hw.zb.cmd[R300_ZB_PITCH] |= R300_DEPTHMACROTILE_ENABLE;

		if (ctx->Visual.depthBits == 24)
			r300->hw.zb.cmd[R300_ZB_PITCH] |=
			    R300_DEPTHMICROTILE_TILED;
	}
a1942 12
	switch (ctx->Visual.depthBits) {
	case 16:
		r300->hw.zstencil_format.cmd[1] = R300_DEPTHFORMAT_16BIT_INT_Z;
		break;
	case 24:
		r300->hw.zstencil_format.cmd[1] = R300_DEPTHFORMAT_24BIT_INT_Z_8BIT_STENCIL;
		break;
	default:
		fprintf(stderr, "Error: Unsupported depth %d... exiting\n", ctx->Visual.depthBits);
		_mesa_exit(-1);
	}

d1948 2
a1949 2
	r300->hw.unk4F30.cmd[1] = 0;
	r300->hw.unk4F30.cmd[2] = 0;
d1963 1
a1963 1
	r300->hw.all_dirty = GL_TRUE;
d1968 13
a1980 3
	GLcontext *ctx;
	struct r300_vertex_program *vp;
	int i;
d1982 2
a1983 1
	ctx = rmesa->radeon.glCtx;
d1985 2
a1986 2
	if (rmesa->NewGLState && hw_tcl_on) {
		rmesa->NewGLState = 0;
d1988 1
a1988 23
		for (i = _TNL_FIRST_MAT; i <= _TNL_LAST_MAT; i++) {
			rmesa->temp_attrib[i] =
			    TNL_CONTEXT(ctx)->vb.AttribPtr[i];
			TNL_CONTEXT(ctx)->vb.AttribPtr[i] =
			    &rmesa->dummy_attrib[i];
		}

		_tnl_UpdateFixedFunctionProgram(ctx);

		for (i = _TNL_FIRST_MAT; i <= _TNL_LAST_MAT; i++) {
			TNL_CONTEXT(ctx)->vb.AttribPtr[i] =
			    rmesa->temp_attrib[i];
		}

		r300SelectVertexShader(rmesa);
		vp = (struct r300_vertex_program *)
		    CURRENT_VERTEX_SHADER(ctx);
		/*if (vp->translated == GL_FALSE)
		   r300TranslateVertexShader(vp); */
		if (vp->translated == GL_FALSE) {
			fprintf(stderr, "Failing back to sw-tcl\n");
			hw_tcl_on = future_hw_tcl_on = 0;
			r300ResetHwState(rmesa);
d1990 1
a1990 3
			r300UpdateStateParameters(ctx, _NEW_PROGRAM);
			return;
		}
d1992 3
a1994 1
	r300UpdateStateParameters(ctx, _NEW_PROGRAM);
d1997 1
a1997 2
static const GLfloat *get_fragmentprogram_constant(GLcontext *ctx,
	struct gl_program *program, struct prog_src_register srcreg)
d2000 21
d2022 27
a2048 12
	switch(srcreg.File) {
	case PROGRAM_LOCAL_PARAM:
		return program->LocalParams[srcreg.Index];
	case PROGRAM_ENV_PARAM:
		return ctx->FragmentProgram.Parameters[srcreg.Index];
	case PROGRAM_STATE_VAR:
	case PROGRAM_NAMED_PARAM:
	case PROGRAM_CONSTANT:
		return program->Parameters->ParameterValues[srcreg.Index];
	default:
		_mesa_problem(ctx, "get_fragmentprogram_constant: Unknown\n");
		return dummy;
d2050 2
d2055 1
a2055 1
static void r300SetupPixelShader(r300ContextPtr rmesa)
d2057 2
a2058 3
	GLcontext *ctx = rmesa->radeon.glCtx;
	struct r300_fragment_program *fp = (struct r300_fragment_program *)
	    (char *)ctx->FragmentProgram._Current;
d2060 1
a2060 1
	int i, k;
d2062 1
a2062 12
	if (!fp)		/* should only happenen once, just after context is created */
		return;

	r300TranslateFragmentShader(rmesa, fp);
	if (!fp->translated) {
		fprintf(stderr, "%s: No valid fragment shader, exiting\n",
			__FUNCTION__);
		return;
	}
	code = &fp->code;

	r300SetupTextures(ctx);
d2068 4
a2071 4
	rmesa->hw.fpi[0].cmd[R300_FPI_CMD_0] = cmdpacket0(R300_US_ALU_RGB_INST_0, code->alu.length);
	rmesa->hw.fpi[1].cmd[R300_FPI_CMD_0] = cmdpacket0(R300_US_ALU_RGB_ADDR_0, code->alu.length);
	rmesa->hw.fpi[2].cmd[R300_FPI_CMD_0] = cmdpacket0(R300_US_ALU_ALPHA_INST_0, code->alu.length);
	rmesa->hw.fpi[3].cmd[R300_FPI_CMD_0] = cmdpacket0(R300_US_ALU_ALPHA_ADDR_0, code->alu.length);
d2073 4
a2076 4
		rmesa->hw.fpi[0].cmd[R300_FPI_INSTR_0 + i] = code->alu.inst[i].inst0;
		rmesa->hw.fpi[1].cmd[R300_FPI_INSTR_0 + i] = code->alu.inst[i].inst1;
		rmesa->hw.fpi[2].cmd[R300_FPI_INSTR_0 + i] = code->alu.inst[i].inst2;
		rmesa->hw.fpi[3].cmd[R300_FPI_INSTR_0 + i] = code->alu.inst[i].inst3;
d2080 5
a2084 20
	rmesa->hw.fp.cmd[R300_FP_CNTL0] = code->cur_node | (code->first_node_has_tex << 3);
	rmesa->hw.fp.cmd[R300_FP_CNTL1] = code->max_temp_idx;
	rmesa->hw.fp.cmd[R300_FP_CNTL2] =
	  (0 << R300_PFS_CNTL_ALU_OFFSET_SHIFT) |
	  ((code->alu.length-1) << R300_PFS_CNTL_ALU_END_SHIFT) |
	  (0 << R300_PFS_CNTL_TEX_OFFSET_SHIFT) |
	  ((code->tex.length ? code->tex.length-1 : 0) << R300_PFS_CNTL_TEX_END_SHIFT);
	/* I just want to say, the way these nodes are stored.. weird.. */
	for (i = 0, k = (4 - (code->cur_node + 1)); i < 4; i++, k++) {
		if (i < (code->cur_node + 1)) {
			rmesa->hw.fp.cmd[R300_FP_NODE0 + k] =
			  (code->node[i].alu_offset << R300_ALU_START_SHIFT) |
			  (code->node[i].alu_end << R300_ALU_SIZE_SHIFT) |
			  (code->node[i].tex_offset << R300_TEX_START_SHIFT) |
			  (code->node[i].tex_end << R300_TEX_SIZE_SHIFT) |
			  code->node[i].flags;
		} else {
			rmesa->hw.fp.cmd[R300_FP_NODE0 + (3 - i)] = 0;
		}
	}
d2087 4
a2090 4
	rmesa->hw.fpp.cmd[R300_FPP_CMD_0] = cmdpacket0(R300_PFS_PARAM_0_X, code->const_nr * 4);
	for (i = 0; i < code->const_nr; i++) {
		const GLfloat *constant = get_fragmentprogram_constant(ctx,
			&fp->mesa_program.Base, code->constant[i]);
d2112 1
a2112 1
static void r500SetupPixelShader(r300ContextPtr rmesa)
d2114 2
a2115 3
	GLcontext *ctx = rmesa->radeon.glCtx;
	struct r500_fragment_program *fp = (struct r500_fragment_program *)
	    (char *)ctx->FragmentProgram._Current;
a2118 3
	if (!fp)		/* should only happenen once, just after context is created */
		return;

d2122 1
a2122 19
	r500TranslateFragmentShader(rmesa, fp);
	if (!fp->translated) {
		fprintf(stderr, "%s: No valid fragment shader, exiting\n",
			__FUNCTION__);
		return;
	}
	code = &fp->code;

	if (fp->mesa_program.FogOption != GL_NONE) {
		/* Enable HW fog. Try not to squish GL context.
		 * (Anybody sane remembered to set glFog() opts first!) */
		r300SetFogState(ctx, GL_TRUE);
		ctx->Fog.Mode = fp->mesa_program.FogOption;
		r300Fogfv(ctx, GL_FOG_MODE, NULL);
	} else
		/* Make sure HW is matching GL context. */
		r300SetFogState(ctx, ctx->Fog.Enabled);

	r300SetupTextures(ctx);
d2128 1
a2128 1
	    R500_US_CODE_START_ADDR(code->inst_offset) |
d2131 1
a2131 1
	    R500_US_CODE_RANGE_ADDR(code->inst_offset) |
d2134 1
a2134 1
	    R500_US_CODE_OFFSET_ADDR(0); /* FIXME when we add flow control */
d2150 3
a2152 3
	for (i = 0; i < code->const_nr; i++) {
		const GLfloat *constant = get_fragmentprogram_constant(ctx,
			&fp->mesa_program.Base, code->constant[i]);
d2158 32
a2189 1
	bump_r500fp_const_count(rmesa->hw.r500fp_const.cmd, code->const_nr * 4);
d2191 26
d2224 4
a2227 1
	r300UpdateTextureState(ctx);
d2230 1
a2230 7
	GLuint fgdepthsrc = R300_FG_DEPTH_SRC_SCAN;
	if (current_fragment_program_writes_depth(ctx))
		fgdepthsrc = R300_FG_DEPTH_SRC_SHADER;
	if (fgdepthsrc != rmesa->hw.fg_depth_src.cmd[1]) {
		R300_STATECHANGE(rmesa, fg_depth_src);
		rmesa->hw.fg_depth_src.cmd[1] = fgdepthsrc;
	}
d2232 1
a2232 4
	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515)
		r500SetupPixelShader(rmesa);
	else
		r300SetupPixelShader(rmesa);
d2234 1
a2234 4
	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515)
		r500SetupRSUnit(ctx);
	else
		r300SetupRSUnit(ctx);
d2236 1
a2236 1
	if ((rmesa->radeon.radeonScreen->chip_flags & RADEON_CHIPSET_TCL))
d2238 1
a2238 1

a2251 1
	_ae_invalidate_state(ctx, new_state);
d2253 7
a2259 2
	if (new_state & (_NEW_BUFFERS | _NEW_COLOR | _NEW_PIXEL)) {
		r300UpdateDrawBuffer(ctx);
d2262 7
a2268 1
	r300UpdateStateParameters(ctx, new_state);
d2270 1
a2270 1
	r300->NewGLState |= new_state;
a2279 26
	GLcontext *ctx = r300->radeon.glCtx;
	GLuint depth_fmt;

	radeonInitState(&r300->radeon);

	switch (ctx->Visual.depthBits) {
	case 16:
		r300->state.depth.scale = 1.0 / (GLfloat) 0xffff;
		depth_fmt = R300_DEPTHFORMAT_16BIT_INT_Z;
		break;
	case 24:
		r300->state.depth.scale = 1.0 / (GLfloat) 0xffffff;
		depth_fmt = R300_DEPTHFORMAT_24BIT_INT_Z_8BIT_STENCIL;
		break;
	default:
		fprintf(stderr, "Error: Unsupported depth %d... exiting\n",
			ctx->Visual.depthBits);
		_mesa_exit(-1);
	}

	/* Only have hw stencil when depth buffer is 24 bits deep */
	r300->state.stencil.hw_stencil = (ctx->Visual.stencilBits > 0 &&
					  ctx->Visual.depthBits == 24);

	memset(&(r300->state.texture), 0, sizeof(r300->state.texture));

d2285 1
a2285 21
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	(void)rmesa;
	(void)mode;
}

void r300UpdateClipPlanes( GLcontext *ctx )
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	GLuint p;

	for (p = 0; p < ctx->Const.MaxClipPlanes; p++) {
		if (ctx->Transform.ClipPlanesEnabled & (1 << p)) {
			GLint *ip = (GLint *)ctx->Transform._ClipUserPlane[p];

			R300_STATECHANGE( rmesa, vpucp[p] );
			rmesa->hw.vpucp[p].cmd[R300_VPUCP_X] = ip[0];
			rmesa->hw.vpucp[p].cmd[R300_VPUCP_Y] = ip[1];
			rmesa->hw.vpucp[p].cmd[R300_VPUCP_Z] = ip[2];
			rmesa->hw.vpucp[p].cmd[R300_VPUCP_W] = ip[3];
		}
	}
a2292 1
	radeonInitStateFuncs(functions);
a2303 1
	functions->Fogfv = r300Fogfv;
d2328 17
@


1.3
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d38 10
a47 8
#include "glheader.h"
#include "state.h"
#include "imports.h"
#include "enums.h"
#include "macros.h"
#include "context.h"
#include "dd.h"
#include "simple_list.h"
a48 1
#include "api_arrayelt.h"
a54 1
#include "texformat.h"
d977 3
a979 9
	    (((ctx->Stencil.
	       Ref[0] & 0xff) << R300_STENCILREF_SHIFT) | ((ctx->
							    Stencil.
							    ValueMask
							    [0] &
							    0xff)
							   <<
							   R300_STENCILMASK_SHIFT));

d997 1
a997 2
	if (ctx->Stencil._TestTwoSide)
		flag = translate_func(ctx->Stencil.Function[1]);
d1022 1
d1039 7
a1045 17
	if (ctx->Stencil._TestTwoSide) {
		rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
		    (translate_stencil_op(ctx->Stencil.FailFunc[1]) <<
		     R300_S_BACK_SFAIL_OP_SHIFT)
		    | (translate_stencil_op(ctx->Stencil.ZFailFunc[1]) <<
		       R300_S_BACK_ZFAIL_OP_SHIFT)
		    | (translate_stencil_op(ctx->Stencil.ZPassFunc[1]) <<
		       R300_S_BACK_ZPASS_OP_SHIFT);
	} else {
		rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
		    (translate_stencil_op(ctx->Stencil.FailFunc[0]) <<
		     R300_S_BACK_SFAIL_OP_SHIFT)
		    | (translate_stencil_op(ctx->Stencil.ZFailFunc[0]) <<
		       R300_S_BACK_ZFAIL_OP_SHIFT)
		    | (translate_stencil_op(ctx->Stencil.ZPassFunc[0]) <<
		       R300_S_BACK_ZPASS_OP_SHIFT);
	}
d1201 1
a1201 1
				    ctx->Texture.Unit[state[2]].CurrentRect;
d1490 1
a1490 1
			t = r300->state.texture.unit[i].texobj;
d1662 7
@


1.2
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d68 3
a72 1
	GLubyte color[4];
d77 14
a90 4
	CLAMPED_FLOAT_TO_UBYTE(color[0], cf[0]);
	CLAMPED_FLOAT_TO_UBYTE(color[1], cf[1]);
	CLAMPED_FLOAT_TO_UBYTE(color[2], cf[2]);
	CLAMPED_FLOAT_TO_UBYTE(color[3], cf[3]);
d92 3
a94 2
	rmesa->hw.blend_color.cmd[1] = PACK_COLOR_8888(color[3], color[0],
						       color[1], color[2]);
d200 1
a200 1
		new_cblend |= R300_BLEND_NO_SEPARATE;
d306 3
a308 1
			 R300_BLEND_UNKNOWN | R300_BLEND_ENABLE, funcA, eqnA);
d325 77
a408 1
	R300_STATECHANGE(r300, cul);
d410 2
a411 3
		if (ctx->Polygon.CullFaceMode == GL_FRONT_AND_BACK)
			val = R300_CULL_FRONT | R300_CULL_BACK;
		else if (ctx->Polygon.CullFaceMode == GL_FRONT)
d413 2
a414 1
		else
d416 8
d425 9
a433 4
		if (ctx->Polygon.FrontFace == GL_CW)
			val |= R300_FRONT_FACE_CW;
		else
			val |= R300_FRONT_FACE_CCW;
d435 2
d440 28
a469 5
	/* updates register R300_RB3D_EARLY_Z (0x4F14)
	   if depth test is not enabled it should be R300_EARLY_Z_DISABLE
	   if depth is enabled and alpha not it should be R300_EARLY_Z_ENABLE
	   if depth and alpha is enabled it should be R300_EARLY_Z_DISABLE
	 */
d471 1
a472 1
	R300_STATECHANGE(r300, zstencil_format);
d474 11
a484 9
		/* disable early Z */
		r300->hw.zstencil_format.cmd[2] = R300_EARLY_Z_DISABLE;
	else {
		if (ctx->Depth.Test && ctx->Depth.Func != GL_NEVER)
			/* enable early Z */
			r300->hw.zstencil_format.cmd[2] = R300_EARLY_Z_ENABLE;
		else
			/* disable early Z */
			r300->hw.zstencil_format.cmd[2] = R300_EARLY_Z_DISABLE;
d499 1
a499 1
		pp_misc |= R300_ALPHA_TEST_FAIL;
d502 1
a502 1
		pp_misc |= R300_ALPHA_TEST_LESS;
d505 1
a505 1
		pp_misc |= R300_ALPHA_TEST_EQUAL;
d508 1
a508 1
		pp_misc |= R300_ALPHA_TEST_LEQUAL;
d511 1
a511 1
		pp_misc |= R300_ALPHA_TEST_GREATER;
d514 1
a514 1
		pp_misc |= R300_ALPHA_TEST_NEQUAL;
d517 1
a517 1
		pp_misc |= R300_ALPHA_TEST_GEQUAL;
d520 1
a520 1
		/*pp_misc |= R300_ALPHA_TEST_PASS; */
d526 3
a528 2
		pp_misc |= R300_ALPHA_TEST_ENABLE;
		pp_misc |= (refByte & R300_REF_ALPHA_MASK);
d535 1
d575 2
a576 3
	r300->hw.zs.cmd[R300_ZS_CNTL_0] &= R300_RB3D_STENCIL_ENABLE;
	r300->hw.zs.cmd[R300_ZS_CNTL_1] &=
	    ~(R300_ZS_MASK << R300_RB3D_ZS1_DEPTH_FUNC_SHIFT);
d578 2
a579 1
	if (ctx->Depth.Test && ctx->Depth.Func != GL_NEVER) {
d581 1
a581 10
			r300->hw.zs.cmd[R300_ZS_CNTL_0] |=
			    R300_RB3D_Z_TEST_AND_WRITE;
		else
			r300->hw.zs.cmd[R300_ZS_CNTL_0] |= R300_RB3D_Z_TEST;

		r300->hw.zs.cmd[R300_ZS_CNTL_1] |=
		    translate_func(ctx->Depth.
				   Func) << R300_RB3D_ZS1_DEPTH_FUNC_SHIFT;
	} else {
		r300->hw.zs.cmd[R300_ZS_CNTL_0] |= R300_RB3D_Z_DISABLED_1;
d583 1
a583 1
		    translate_func(GL_NEVER) << R300_RB3D_ZS1_DEPTH_FUNC_SHIFT;
d589 1
a589 8
static void r300ClipPlane( GLcontext *ctx, GLenum plane, const GLfloat *eq );

/**
 * Handle glEnable()/glDisable().
 *
 * \note Mesa already filters redundant calls to glEnable/glDisable.
 */
static void r300Enable(GLcontext * ctx, GLenum cap, GLboolean state)
a591 13
	GLuint p;
	if (RADEON_DEBUG & DEBUG_STATE)
		fprintf(stderr, "%s( %s = %s )\n", __FUNCTION__,
			_mesa_lookup_enum_by_nr(cap),
			state ? "GL_TRUE" : "GL_FALSE");

	switch (cap) {
		/* Fast track this one...
		 */
	case GL_TEXTURE_1D:
	case GL_TEXTURE_2D:
	case GL_TEXTURE_3D:
		break;
d593 2
a594 2
	case GL_FOG:
		R300_STATECHANGE(r300, fogs);
d596 2
a597 8
			r300->hw.fogs.cmd[R300_FOGS_STATE] |= R300_FOG_ENABLE;

			ctx->Driver.Fogfv(ctx, GL_FOG_MODE, NULL);
			ctx->Driver.Fogfv(ctx, GL_FOG_DENSITY,
					  &ctx->Fog.Density);
			ctx->Driver.Fogfv(ctx, GL_FOG_START, &ctx->Fog.Start);
			ctx->Driver.Fogfv(ctx, GL_FOG_END, &ctx->Fog.End);
			ctx->Driver.Fogfv(ctx, GL_FOG_COLOR, ctx->Fog.Color);
d599 2
a600 1
			r300->hw.fogs.cmd[R300_FOGS_STATE] &= ~R300_FOG_ENABLE;
d602 1
a602 48

		break;

	case GL_ALPHA_TEST:
		r300SetAlphaState(ctx);
		break;

	case GL_BLEND:
	case GL_COLOR_LOGIC_OP:
		r300SetBlendState(ctx);
		break;


	case GL_CLIP_PLANE0:
	case GL_CLIP_PLANE1:
	case GL_CLIP_PLANE2:
	case GL_CLIP_PLANE3:
	case GL_CLIP_PLANE4:
	case GL_CLIP_PLANE5:
		/* no VAP UCP on non-TCL chipsets */
		if (!(r300->radeon.radeonScreen->chip_flags & RADEON_CHIPSET_TCL))
			return;

		p = cap-GL_CLIP_PLANE0;
		R300_STATECHANGE( r300, vap_clip_cntl );
		if (state) {
			r300->hw.vap_clip_cntl.cmd[1] |= (R300_VAP_UCP_ENABLE_0<<p);
			r300ClipPlane( ctx, cap, NULL );
		}
		else {
			r300->hw.vap_clip_cntl.cmd[1] &= ~(R300_VAP_UCP_ENABLE_0<<p);
		}
		break;
	case GL_DEPTH_TEST:
		r300SetDepthState(ctx);
		break;

	case GL_STENCIL_TEST:
		if (r300->state.stencil.hw_stencil) {
			R300_STATECHANGE(r300, zs);
			if (state) {
				r300->hw.zs.cmd[R300_ZS_CNTL_0] |=
				    R300_RB3D_STENCIL_ENABLE;
			} else {
				r300->hw.zs.cmd[R300_ZS_CNTL_0] &=
				    ~R300_RB3D_STENCIL_ENABLE;
			}
		} else {
d604 1
a604 1
			FALLBACK(&r300->radeon, RADEON_FALLBACK_STENCIL, state);
a605 22
		}
		break;

	case GL_CULL_FACE:
		r300UpdateCulling(ctx);
		break;

	case GL_POLYGON_OFFSET_POINT:
	case GL_POLYGON_OFFSET_LINE:
		break;

	case GL_POLYGON_OFFSET_FILL:
		R300_STATECHANGE(r300, occlusion_cntl);
		if (state) {
			r300->hw.occlusion_cntl.cmd[1] |= (3 << 0);
		} else {
			r300->hw.occlusion_cntl.cmd[1] &= ~(3 << 0);
		}
		break;
	default:
		radeonEnable(ctx, cap, state);
		return;
d612 1
a612 1
	uint32_t hw_mode = 0;
d614 1
d619 3
d630 2
a631 1
		hw_mode |= R300_PM_ENABLED;
d635 1
a635 1
			hw_mode |= R300_PM_FRONT_LINE;
d637 2
a638 2
		case GL_POINT:	/* noop */
			hw_mode |= R300_PM_FRONT_POINT;
d641 1
a641 1
			hw_mode |= R300_PM_FRONT_FILL;
d647 1
a647 1
			hw_mode |= R300_PM_BACK_LINE;
d649 2
a650 2
		case GL_POINT:	/* noop */
			hw_mode |= R300_PM_BACK_POINT;
d653 1
a653 1
			hw_mode |= R300_PM_BACK_FILL;
d662 3
d721 4
a724 3
	int mask = (r ? R300_COLORMASK0_R : 0) |
	    (g ? R300_COLORMASK0_G : 0) |
	    (b ? R300_COLORMASK0_B : 0) | (a ? R300_COLORMASK0_A : 0);
a749 2
		if (!ctx->Fog.Enabled)
			return;
d755 2
a756 2
			     cmd[R300_FOGS_STATE] & ~R300_FOG_MODE_MASK) |
			    R300_FOG_MODE_LINEAR;
d773 2
a774 2
			     cmd[R300_FOGS_STATE] & ~R300_FOG_MODE_MASK) |
			    R300_FOG_MODE_EXP;
d782 2
a783 2
			     cmd[R300_FOGS_STATE] & ~R300_FOG_MODE_MASK) |
			    R300_FOG_MODE_EXP2;
d841 18
d865 2
a866 2

	size = ctx->Point._Size;
d874 25
d906 3
a908 2
	widthf = ctx->Line._Width;

d910 2
a911 2
	r300->hw.lcntl.cmd[1] = (int)(widthf * 6.0);
	r300->hw.lcntl.cmd[1] |= R300_LINE_CNT_VE;
d957 1
d968 2
d978 7
a984 7
	       Ref[0] & 0xff) << R300_RB3D_ZS2_STENCIL_REF_SHIFT) | ((ctx->
								      Stencil.
								      ValueMask
								      [0] &
								      0xff)
								     <<
								     R300_RB3D_ZS2_STENCIL_MASK_SHIFT));
d989 1
a989 1

d991 1
a991 1
					       R300_RB3D_ZS1_FRONT_FUNC_SHIFT)
d993 1
a993 1
						 R300_RB3D_ZS1_BACK_FUNC_SHIFT));
d996 2
a997 3
	    ~((R300_RB3D_ZS2_STENCIL_MASK <<
	       R300_RB3D_ZS2_STENCIL_REF_SHIFT) |
	      (R300_RB3D_ZS2_STENCIL_MASK << R300_RB3D_ZS2_STENCIL_MASK_SHIFT));
d1001 1
a1001 1
	    (flag << R300_RB3D_ZS1_FRONT_FUNC_SHIFT);
d1007 1
a1007 1
	    (flag << R300_RB3D_ZS1_BACK_FUNC_SHIFT);
d1017 2
a1018 2
	    ~(R300_RB3D_ZS2_STENCIL_MASK <<
	      R300_RB3D_ZS2_STENCIL_WRITE_MASK_SHIFT);
d1021 2
a1022 1
	     WriteMask[0] & 0xff) << R300_RB3D_ZS2_STENCIL_WRITE_MASK_SHIFT;
d1033 3
a1035 3
	    (R300_ZS_MASK << R300_RB3D_ZS1_DEPTH_FUNC_SHIFT) |
	    (R300_ZS_MASK << R300_RB3D_ZS1_FRONT_FUNC_SHIFT) |
	    (R300_ZS_MASK << R300_RB3D_ZS1_BACK_FUNC_SHIFT);
d1039 1
a1039 1
	     R300_RB3D_ZS1_FRONT_FAIL_OP_SHIFT)
d1041 1
a1041 1
	       R300_RB3D_ZS1_FRONT_ZFAIL_OP_SHIFT)
d1043 1
a1043 1
	       R300_RB3D_ZS1_FRONT_ZPASS_OP_SHIFT);
d1048 1
a1048 1
		     R300_RB3D_ZS1_BACK_FAIL_OP_SHIFT)
d1050 1
a1050 1
		       R300_RB3D_ZS1_BACK_ZFAIL_OP_SHIFT)
d1052 1
a1052 1
		       R300_RB3D_ZS1_BACK_ZPASS_OP_SHIFT);
d1056 1
a1056 1
		     R300_RB3D_ZS1_BACK_FAIL_OP_SHIFT)
d1058 1
a1058 1
		       R300_RB3D_ZS1_BACK_ZFAIL_OP_SHIFT)
d1060 1
a1060 1
		       R300_RB3D_ZS1_BACK_ZPASS_OP_SHIFT);
a1063 12
static void r300ClearStencil(GLcontext * ctx, GLint s)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);

	rmesa->state.stencil.clear =
	    ((GLuint) (ctx->Stencil.Clear & 0xff) |
	     (R300_RB3D_ZS2_STENCIL_MASK <<
	      R300_RB3D_ZS2_STENCIL_MASK_SHIFT) | ((ctx->Stencil.
						    WriteMask[0] & 0xff) <<
						   R300_RB3D_ZS2_STENCIL_WRITE_MASK_SHIFT));
}

d1151 1
a1151 1
	if (fb->_ColorDrawBufferMask[0] == BUFFER_BIT_FRONT_LEFT) {
d1156 1
a1156 1
	} else if (fb->_ColorDrawBufferMask[0] == BUFFER_BIT_BACK_LEFT) {
d1328 2
a1329 2
	if ((f & ((7 - 1) << R300_TX_WRAP_Q_SHIFT)) ==
	    (R300_TX_CLAMP << R300_TX_WRAP_Q_SHIFT)) {
d1337 1
a1337 1
	min = f & R300_TX_MIN_FILTER_MASK;
d1369 2
a1370 2
		f &= ~((7 - 1) << R300_TX_WRAP_Q_SHIFT);
		f |= R300_TX_CLAMP_TO_EDGE << R300_TX_WRAP_Q_SHIFT;
d1375 88
d1526 8
a1533 2
			/* Currently disabled! */
			r300->hw.tex.filter_1.cmd[R300_TEX_VALUE_0 + hw_tmu] = 0x0;	//0x20501f80;
d1564 1
a1564 1
	    cmdpacket0(R300_TX_FILTER_0, last_hw_tmu + 1);
d1572 1
a1572 1
	    cmdpacket0(R300_TX_PITCH_0, last_hw_tmu + 1);
d1583 12
a1594 1
	R300_STATECHANGE(r300, fpt);
d1596 4
a1599 4
	for (i = 0; i < fp->tex.length; i++) {
		int unit;
		int opcode;
		unsigned long val;
d1601 100
a1700 2
		unit = fp->tex.inst[i] >> R300_FPITX_IMAGE_SHIFT;
		unit &= 15;
d1702 1
a1702 2
		val = fp->tex.inst[i];
		val &= ~R300_FPITX_IMAGE_MASK;
d1704 9
a1712 10
		opcode =
		    (val & R300_FPITX_OPCODE_MASK) >> R300_FPITX_OPCODE_SHIFT;
		if (opcode == R300_FPITX_OP_KIL) {
			r300->hw.fpt.cmd[R300_FPT_INSTR_0 + i] = val;
		} else {
			if (tmu_mappings[unit] >= 0) {
				val |=
				    tmu_mappings[unit] <<
				    R300_FPITX_IMAGE_SHIFT;
				r300->hw.fpt.cmd[R300_FPT_INSTR_0 + i] = val;
d1714 1
a1714 3
				// We get here when the corresponding texture image is incomplete
				// (e.g. incomplete mipmaps etc.)
				r300->hw.fpt.cmd[R300_FPT_INSTR_0 + i] = val;
d1719 27
a1745 2
	r300->hw.fpt.cmd[R300_FPT_CMD_0] =
	    cmdpacket0(R300_PFS_TEXI_0, fp->tex.length);
d1747 3
a1749 4
	if (RADEON_DEBUG & DEBUG_STATE)
		fprintf(stderr, "TX_ENABLE: %08x  last_hw_tmu=%d\n",
			r300->hw.txe.cmd[R300_TXE_ENABLE], last_hw_tmu);
}
d1751 3
a1753 4
union r300_outputs_written {
	GLuint vp_outputs;	/* hw_tcl_on */
	 DECLARE_RENDERINPUTS(index_bitset);	/* !hw_tcl_on */
};
d1755 3
a1757 3
#define R300_OUTPUTS_WRITTEN_TEST(ow, vp_result, tnl_attrib) \
	((hw_tcl_on) ? (ow).vp_outputs & (1 << (vp_result)) : \
	RENDERINPUTS_TEST( (ow.index_bitset), (tnl_attrib) ))
d1759 1
a1759 1
static void r300SetupRSUnit(GLcontext * ctx)
d1763 1
a1763 10
	GLuint interp_magic[8] = {
		0x00,
		R300_RS_INTERP_1_UNKNOWN,
		R300_RS_INTERP_2_UNKNOWN,
		R300_RS_INTERP_3_UNKNOWN,
		0x00,
		0x00,
		0x00,
		0x00
	};
d1765 2
d1769 1
d1771 1
a1771 1
	int i;
d1773 1
d1775 1
a1775 2
		OutputsWritten.vp_outputs =
		    CURRENT_VERTEX_SHADER(ctx)->key.OutputsWritten;
d1777 1
a1777 2
		RENDERINPUTS_COPY(OutputsWritten.index_bitset,
				  r300->state.render_inputs_bitset);
d1790 1
a1790 1
	fp_reg = in_texcoords = col_interp_nr = high_rr = 0;
d1792 1
a1792 1
	r300->hw.rr.cmd[R300_RR_ROUTE_1] = 0;
d1808 18
d1827 4
a1830 4
		r300->hw.ri.cmd[R300_RI_INTERP_0 + i] = 0
		    | R300_RS_INTERP_USED
		    | (in_texcoords << R300_RS_INTERP_SRC_SHIFT)
		    | interp_magic[i];
d1832 31
a1862 1
		r300->hw.rr.cmd[R300_RR_ROUTE_0 + fp_reg] = 0;
d1865 2
a1866 2
			r300->hw.rr.cmd[R300_RR_ROUTE_0 + fp_reg] |= R300_RS_ROUTE_ENABLE | i	/* source INTERP */
			    | (fp_reg << R300_RS_ROUTE_DEST_SHIFT);
d1869 6
a1874 9
			if (!R300_OUTPUTS_WRITTEN_TEST
			    (OutputsWritten, VERT_RESULT_TEX0 + i,
			     _TNL_ATTRIB_TEX(i))) {
				/* Passing invalid data here can lock the GPU. */
				WARN_ONCE
				    ("fragprog wants coords for tex%d, vp doesn't provide them!\n",
				     i);
				//_mesa_print_program(&CURRENT_VERTEX_SHADER(ctx)->Base);
				//_mesa_exit(-1);
a1875 2
			InputsRead &= ~(FRAG_BIT_TEX0 << i);
			fp_reg++;
a1876 4
		/* Need to count all coords enabled at vof */
		if (R300_OUTPUTS_WRITTEN_TEST
		    (OutputsWritten, VERT_RESULT_TEX0 + i, _TNL_ATTRIB_TEX(i)))
			in_texcoords++;
d1880 6
a1885 7
		if (!R300_OUTPUTS_WRITTEN_TEST
		    (OutputsWritten, VERT_RESULT_COL0, _TNL_ATTRIB_COLOR0)) {
			WARN_ONCE
			    ("fragprog wants col0, vp doesn't provide it\n");
			goto out;	/* FIXME */
			//_mesa_print_program(&CURRENT_VERTEX_SHADER(ctx)->Base);
			//_mesa_exit(-1);
a1886 6

		r300->hw.rr.cmd[R300_RR_ROUTE_0] |= 0
		    | R300_RS_ROUTE_0_COLOR
		    | (fp_reg++ << R300_RS_ROUTE_0_COLOR_DEST_SHIFT);
		InputsRead &= ~FRAG_BIT_COL0;
		col_interp_nr++;
a1887 1
      out:
d1890 8
a1897 5
		if (!R300_OUTPUTS_WRITTEN_TEST
		    (OutputsWritten, VERT_RESULT_COL1, _TNL_ATTRIB_COLOR1)) {
			WARN_ONCE
			    ("fragprog wants col1, vp doesn't provide it\n");
			//_mesa_exit(-1);
a1898 8

		r300->hw.rr.cmd[R300_RR_ROUTE_1] |=
		    R300_RS_ROUTE_1_UNKNOWN11 | R300_RS_ROUTE_1_COLOR1 |
		    (fp_reg++ << R300_RS_ROUTE_1_COLOR1_DEST_SHIFT);
		InputsRead &= ~FRAG_BIT_COL1;
		if (high_rr < 1)
			high_rr = 1;
		col_interp_nr++;
d1903 1
a1903 3
		r300->hw.rr.cmd[R300_RR_ROUTE_0] |= 0
		    | R300_RS_ROUTE_0_COLOR
		    | (fp_reg++ << R300_RS_ROUTE_0_COLOR_DEST_SHIFT);
d1907 3
a1909 3
	r300->hw.rc.cmd[1] = 0 | (in_texcoords << R300_RS_CNTL_TC_CNT_SHIFT)
	    | (col_interp_nr << R300_RS_CNTL_CI_CNT_SHIFT)
	    | R300_RS_CNTL_0_UNKNOWN_18;
d1912 1
a1912 2
	r300->hw.rr.cmd[R300_RR_CMD_0] =
	    cmdpacket0(R300_RS_ROUTE_0, high_rr + 1);
d1916 1
a1916 2
		WARN_ONCE("Don't know how to satisfy InputsRead=0x%08x\n",
			  InputsRead);
d1919 2
a1920 1
#define vpucount(ptr) (((drm_r300_cmd_header_t*)(ptr))->vpu.count)
d1929 1
a1929 3
void static inline setup_vertex_shader_fragment(r300ContextPtr r300, int dest, struct
						r300_vertex_shader_fragment
						*vsf)
d1937 1
a1937 2
		fprintf(stderr,
			"VERTEX_SHADER_FRAGMENT must have length divisible by 4\n");
d1945 2
a1946 4
			r300->hw.vpi.cmd[R300_VPI_INSTR_0 + i +
					 4 * (dest & 0xff)] = (vsf->body.d[i]);
		bump_vpu_count(r300->hw.vpi.cmd,
			       vsf->length + 4 * (dest & 0xff));
d1952 2
a1953 4
			r300->hw.vpp.cmd[R300_VPP_PARAM_0 + i +
					 4 * (dest & 0xff)] = (vsf->body.d[i]);
		bump_vpu_count(r300->hw.vpp.cmd,
			       vsf->length + 4 * (dest & 0xff));
d1958 2
a1959 4
			r300->hw.vps.cmd[1 + i + 4 * (dest & 0xff)] =
			    (vsf->body.d[i]);
		bump_vpu_count(r300->hw.vps.cmd,
			       vsf->length + 4 * (dest & 0xff));
d1962 1
a1962 3
		fprintf(stderr,
			"%s:%s don't know how to handle dest %04x\n",
			__FILE__, __FUNCTION__, dest);
d1967 1
a1967 1
/* just a skeleton for now.. */
a1968 2
/* Generate a vertex shader that simply transforms vertex and texture coordinates,
   while leaving colors intact. Nothing fancy (like lights)
d1970 2
a1971 2
   If implementing lights make a copy first, so it is easy to switch between the two versions */
static void r300GenerateSimpleVertexShader(r300ContextPtr r300)
d1973 56
d2030 16
a2045 1
	GLuint o_reg = 0;
d2047 3
a2049 31
	/* Allocate parameters */
	r300->state.vap_param.transform_offset = 0x0;	/* transform matrix */
	r300->state.vertex_shader.param_offset = 0x0;
	r300->state.vertex_shader.param_count = 0x4;	/* 4 vector values - 4x4 matrix */

	r300->state.vertex_shader.program_start = 0x0;
	r300->state.vertex_shader.unknown_ptr1 = 0x4;	/* magic value ? */
	r300->state.vertex_shader.program_end = 0x0;

	r300->state.vertex_shader.unknown_ptr2 = 0x0;	/* magic value */
	r300->state.vertex_shader.unknown_ptr3 = 0x4;	/* magic value */

	r300->state.vertex_shader.unknown1.length = 0;
	r300->state.vertex_shader.unknown2.length = 0;

#define WRITE_OP(oper,source1,source2,source3)	{\
	r300->state.vertex_shader.program.body.i[r300->state.vertex_shader.program_end].op=(oper); \
	r300->state.vertex_shader.program.body.i[r300->state.vertex_shader.program_end].src[0]=(source1); \
	r300->state.vertex_shader.program.body.i[r300->state.vertex_shader.program_end].src[1]=(source2); \
	r300->state.vertex_shader.program.body.i[r300->state.vertex_shader.program_end].src[2]=(source3); \
	r300->state.vertex_shader.program_end++; \
	}

	for (i = VERT_ATTRIB_POS; i < VERT_ATTRIB_MAX; i++)
		if (r300->state.sw_tcl_inputs[i] != -1) {
			WRITE_OP(EASY_VSF_OP(MUL, o_reg++, ALL, RESULT),
				 VSF_REG(r300->state.sw_tcl_inputs[i]),
				 VSF_ATTR_UNITY(r300->state.
						sw_tcl_inputs[i]),
				 VSF_UNITY(r300->state.sw_tcl_inputs[i])
			    )
d2051 1
a2051 1
		}
d2053 11
a2063 7
	r300->state.vertex_shader.program_end--;	/* r300 wants program length to be one more - no idea why */
	r300->state.vertex_shader.program.length =
	    (r300->state.vertex_shader.program_end + 1) * 4;

	r300->state.vertex_shader.unknown_ptr1 = r300->state.vertex_shader.program_end;	/* magic value ? */
	r300->state.vertex_shader.unknown_ptr2 = r300->state.vertex_shader.program_end;	/* magic value ? */
	r300->state.vertex_shader.unknown_ptr3 = r300->state.vertex_shader.program_end;	/* magic value ? */
d2065 7
d2074 1
a2074 1
static void r300SetupVertexProgram(r300ContextPtr rmesa)
d2077 3
a2079 4
	int inst_count;
	int param_count;
	struct r300_vertex_program *prog =
	    (struct r300_vertex_program *)CURRENT_VERTEX_SHADER(ctx);
d2081 1
a2081 1
	((drm_r300_cmd_header_t *) rmesa->hw.vpp.cmd)->vpu.count = 0;
d2084 3
a2086 2
	    r300VertexProgUpdateParams(ctx, (struct r300_vertex_program_cont *)
				       ctx->VertexProgram._Current /*prog */ ,
d2092 2
a2093 3
	/* Reset state, in case we don't use something */
	((drm_r300_cmd_header_t *) rmesa->hw.vpi.cmd)->vpu.count = 0;
	((drm_r300_cmd_header_t *) rmesa->hw.vps.cmd)->vpu.count = 0;
d2095 2
a2096 10
	setup_vertex_shader_fragment(rmesa, VSF_DEST_PROGRAM, &(prog->program));

#if 0
	setup_vertex_shader_fragment(rmesa, VSF_DEST_UNKNOWN1,
				     &(rmesa->state.vertex_shader.unknown1));
	setup_vertex_shader_fragment(rmesa, VSF_DEST_UNKNOWN2,
				     &(rmesa->state.vertex_shader.unknown2));
#endif

	inst_count = prog->program.length / 4 - 1;
d2100 3
a2102 3
	    (0 << R300_PVS_CNTL_1_PROGRAM_START_SHIFT)
	    | (inst_count /*pos_end */  << R300_PVS_CNTL_1_POS_END_SHIFT)
	    | (inst_count << R300_PVS_CNTL_1_PROGRAM_END_SHIFT);
d2104 2
a2105 2
	    (0 << R300_PVS_CNTL_2_PARAM_OFFSET_SHIFT)
	    | (param_count << R300_PVS_CNTL_2_PARAM_COUNT_SHIFT);
d2107 1
a2107 11
	    (0 /*rmesa->state.vertex_shader.unknown_ptr2 */  <<
	     R300_PVS_CNTL_3_PROGRAM_UNKNOWN_SHIFT)
	    | (inst_count /*rmesa->state.vertex_shader.unknown_ptr3 */  <<
	       0);

	/* This is done for vertex shader fragments, but also needs to be done for vap_pvs,
	   so I leave it as a reminder */
#if 0
	reg_start(R300_VAP_PVS_WAITIDLE, 0);
	e32(0x00000000);
#endif
d2110 1
a2110 1
static void r300SetupVertexShader(r300ContextPtr rmesa)
d2123 5
a2127 5
	if (hw_tcl_on
	    && ((struct r300_vertex_program *)CURRENT_VERTEX_SHADER(ctx))->
	    translated) {
		r300SetupVertexProgram(rmesa);
		return;
d2130 1
a2130 2
	/* This needs to be replaced by vertex shader generation code */
	r300GenerateSimpleVertexShader(rmesa);
d2132 11
a2142 2
	setup_vertex_shader_fragment(rmesa, VSF_DEST_PROGRAM,
				     &(rmesa->state.vertex_shader.program));
d2144 44
a2187 31
#if 0
	setup_vertex_shader_fragment(rmesa, VSF_DEST_UNKNOWN1,
				     &(rmesa->state.vertex_shader.unknown1));
	setup_vertex_shader_fragment(rmesa, VSF_DEST_UNKNOWN2,
				     &(rmesa->state.vertex_shader.unknown2));
#endif

	R300_STATECHANGE(rmesa, pvs);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_1] =
	    (rmesa->state.vertex_shader.
	     program_start << R300_PVS_CNTL_1_PROGRAM_START_SHIFT)
	    | (rmesa->state.vertex_shader.
	       unknown_ptr1 << R300_PVS_CNTL_1_POS_END_SHIFT)
	    | (rmesa->state.vertex_shader.
	       program_end << R300_PVS_CNTL_1_PROGRAM_END_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_2] =
	    (rmesa->state.vertex_shader.
	     param_offset << R300_PVS_CNTL_2_PARAM_OFFSET_SHIFT)
	    | (rmesa->state.vertex_shader.
	       param_count << R300_PVS_CNTL_2_PARAM_COUNT_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_3] =
	    (rmesa->state.vertex_shader.
	     unknown_ptr2 << R300_PVS_CNTL_3_PROGRAM_UNKNOWN_SHIFT)
	    | (rmesa->state.vertex_shader.unknown_ptr3 << 0);

	/* This is done for vertex shader fragments, but also needs to be done for vap_pvs,
	   so I leave it as a reminder */
#if 0
	reg_start(R300_VAP_PVS_WAITIDLE, 0);
	e32(0x00000000);
#endif
a2203 6
	/* This is a place to initialize registers which
	   have bitfields accessed by different functions
	   and not all bits are used */

	/* go and compute register values from GL state */

d2229 1
a2233 7
	/* Initialize magic registers
	   TODO : learn what they really do, or get rid of
	   those we don't have to touch */
	if (!has_tcl)
		r300->hw.vap_cntl.cmd[1] = 0x0014045a;
	else
		r300->hw.vap_cntl.cmd[1] = 0x0030045A;	//0x0030065a /* Dangerous */
d2242 8
a2249 6
	r300->hw.unk2134.cmd[1] = 0x00FFFFFF;
	r300->hw.unk2134.cmd[2] = 0x00000000;
	if (_mesa_little_endian())
		r300->hw.vap_cntl_status.cmd[1] = R300_VC_NO_SWAP;
	else
		r300->hw.vap_cntl_status.cmd[1] = R300_VC_32BIT_SWAP;
d2255 1
a2255 1
	r300->hw.unk21DC.cmd[1] = 0xAAAAAAAA;
d2257 3
a2259 1
	r300->hw.vap_clip_cntl.cmd[1] = R300_221C_NORMAL;
d2261 14
a2274 10
	r300->hw.unk2220.cmd[1] = r300PackFloat32(1.0);
	r300->hw.unk2220.cmd[2] = r300PackFloat32(1.0);
	r300->hw.unk2220.cmd[3] = r300PackFloat32(1.0);
	r300->hw.unk2220.cmd[4] = r300PackFloat32(1.0);

	/* what about other chips than r300 or rv350??? */
	if (r300->radeon.radeonScreen->chip_family == CHIP_FAMILY_R300)
		r300->hw.unk2288.cmd[1] = R300_2288_R300;
	else
		r300->hw.unk2288.cmd[1] = R300_2288_RV350;
d2278 1
a2278 1
	    | R300_GB_TRIANGLE_STUFF_ENABLE /*| R300_GB_UNK31 */ ;
d2282 24
a2305 18
	if ((r300->radeon.radeonScreen->chip_family == CHIP_FAMILY_R300) ||
	    (r300->radeon.radeonScreen->chip_family == CHIP_FAMILY_R350))
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] =
		    R300_GB_TILE_ENABLE | R300_GB_TILE_PIPE_COUNT_R300 |
		    R300_GB_TILE_SIZE_16;
	else if (r300->radeon.radeonScreen->chip_family == CHIP_FAMILY_RV410)
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] =
		    R300_GB_TILE_ENABLE | R300_GB_TILE_PIPE_COUNT_RV410 |
		    R300_GB_TILE_SIZE_16;
	else if (r300->radeon.radeonScreen->chip_family == CHIP_FAMILY_R420)
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] =
		    R300_GB_TILE_ENABLE | R300_GB_TILE_PIPE_COUNT_R420 |
		    R300_GB_TILE_SIZE_16;
	else
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] =
		    R300_GB_TILE_ENABLE | R300_GB_TILE_PIPE_COUNT_RV300 |
		    R300_GB_TILE_SIZE_16;
	/* set to 0 when fog is disabled? */
a2306 1
	r300->hw.gb_misc.cmd[R300_GB_MISC_AA_CONFIG] = R300_AA_DISABLE;	/* No antialiasing */
d2308 7
a2314 4
	r300->hw.unk4200.cmd[1] = r300PackFloat32(0.0);
	r300->hw.unk4200.cmd[2] = r300PackFloat32(0.0);
	r300->hw.unk4200.cmd[3] = r300PackFloat32(1.0);
	r300->hw.unk4200.cmd[4] = r300PackFloat32(1.0);
d2316 1
a2316 1
	r300->hw.unk4214.cmd[1] = 0x00050005;
d2318 1
a2318 1
	r300PointSize(ctx, 0.0);
d2320 3
a2322 3
	r300->hw.unk4230.cmd[1] = 0x18000006;
	r300->hw.unk4230.cmd[2] = 0x00020006;
	r300->hw.unk4230.cmd[3] = r300PackFloat32(1.0 / 192.0);
d2324 1
a2324 1
	r300LineWidth(ctx, 0.0);
d2326 3
a2328 3
	r300->hw.unk4260.cmd[1] = 0;
	r300->hw.unk4260.cmd[2] = r300PackFloat32(0.0);
	r300->hw.unk4260.cmd[3] = r300PackFloat32(1.0);
a2329 1
	r300->hw.shade.cmd[1] = 0x00000002;
a2330 2
	r300->hw.shade.cmd[3] = 0x00000000;
	r300->hw.shade.cmd[4] = 0x00000000;
a2333 2
	r300->hw.polygon_mode.cmd[2] = 0x00000001;
	r300->hw.polygon_mode.cmd[3] = 0x00000000;
d2338 2
d2342 2
a2343 2
	r300->hw.unk42C0.cmd[1] = 0x4B7FFFFF;
	r300->hw.unk42C0.cmd[2] = 0x00000000;
d2345 2
a2346 2
	r300->hw.unk43A4.cmd[1] = 0x0000001C;
	r300->hw.unk43A4.cmd[2] = 0x2DA49525;
d2348 1
a2348 1
	r300->hw.unk43E8.cmd[1] = 0x00FFFFFF;
d2350 9
a2358 5
	r300->hw.unk46A4.cmd[1] = 0x00001B01;
	r300->hw.unk46A4.cmd[2] = 0x00001B0F;
	r300->hw.unk46A4.cmd[3] = 0x00001B0F;
	r300->hw.unk46A4.cmd[4] = 0x00001B0F;
	r300->hw.unk46A4.cmd[5] = 0x00000001;
d2361 6
a2366 6
	ctx->Driver.Fogfv(ctx, GL_FOG_MODE, NULL);
	ctx->Driver.Fogfv(ctx, GL_FOG_DENSITY, &ctx->Fog.Density);
	ctx->Driver.Fogfv(ctx, GL_FOG_START, &ctx->Fog.Start);
	ctx->Driver.Fogfv(ctx, GL_FOG_END, &ctx->Fog.End);
	ctx->Driver.Fogfv(ctx, GL_FOG_COLOR, ctx->Fog.Color);
	ctx->Driver.Fogfv(ctx, GL_FOG_COORDINATE_SOURCE_EXT, NULL);
d2368 1
a2368 2
	r300->hw.at.cmd[R300_AT_UNKNOWN] = 0;
	r300->hw.unk4BD8.cmd[1] = 0;
d2370 1
a2370 1
	r300->hw.unk4E00.cmd[1] = 0;
a2372 2
	r300->hw.blend_color.cmd[2] = 0;
	r300->hw.blend_color.cmd[3] = 0;
d2388 23
a2410 9
	r300->hw.unk4E50.cmd[1] = 0;
	r300->hw.unk4E50.cmd[2] = 0;
	r300->hw.unk4E50.cmd[3] = 0;
	r300->hw.unk4E50.cmd[4] = 0;
	r300->hw.unk4E50.cmd[5] = 0;
	r300->hw.unk4E50.cmd[6] = 0;
	r300->hw.unk4E50.cmd[7] = 0;
	r300->hw.unk4E50.cmd[8] = 0;
	r300->hw.unk4E50.cmd[9] = 0;
d2412 4
a2415 1
	r300->hw.unk4E88.cmd[1] = 0;
d2417 1
a2417 2
	r300->hw.unk4EA0.cmd[1] = 0x00000000;
	r300->hw.unk4EA0.cmd[2] = 0xffffffff;
d2421 1
a2421 1
		r300->hw.zstencil_format.cmd[1] = R300_DEPTH_FORMAT_16BIT_INT_Z;
d2424 1
a2424 1
		r300->hw.zstencil_format.cmd[1] = R300_DEPTH_FORMAT_24BIT_INT_Z;
d2427 1
a2427 2
		fprintf(stderr, "Error: Unsupported depth %d... exiting\n",
			ctx->Visual.depthBits);
a2428 1

a2429 2
	/* z compress? */
	//r300->hw.zstencil_format.cmd[1] |= R300_DEPTH_FORMAT_UNK32;
d2431 1
d2434 1
a2434 16

	r300->hw.zb.cmd[R300_ZB_OFFSET] =
	    r300->radeon.radeonScreen->depthOffset +
	    r300->radeon.radeonScreen->fbLocation;
	r300->hw.zb.cmd[R300_ZB_PITCH] = r300->radeon.radeonScreen->depthPitch;

	if (r300->radeon.sarea->tiling_enabled) {
		/* Turn off when clearing buffers ? */
		r300->hw.zb.cmd[R300_ZB_PITCH] |= R300_DEPTH_TILE_ENABLE;

		if (ctx->Visual.depthBits == 24)
			r300->hw.zb.cmd[R300_ZB_PITCH] |=
			    R300_DEPTH_MICROTILE_ENABLE;
	}

	r300->hw.unk4F28.cmd[1] = 0;
d2439 1
a2439 1
	r300->hw.unk4F44.cmd[1] = 0;
d2441 1
a2441 1
	r300->hw.unk4F54.cmd[1] = 0;
d2443 1
d2450 1
a2450 1
//END: TODO
a2453 4

extern void _tnl_UpdateFixedFunctionProgram(GLcontext * ctx);

extern int future_hw_tcl_on;
d2489 1
a2491 1
		r300UpdateStateParameters(ctx, _NEW_PROGRAM);
d2493 7
d2501 13
d2516 1
d2522 1
d2534 18
a2551 11
#define OUTPUT_FIELD(st, reg, field)  \
		R300_STATECHANGE(rmesa, st); \
		for(i=0;i<=fp->alu_end;i++) \
			rmesa->hw.st.cmd[R300_FPI_INSTR_0+i]=fp->alu.inst[i].field;\
		rmesa->hw.st.cmd[R300_FPI_CMD_0]=cmdpacket0(reg, fp->alu_end+1);

	OUTPUT_FIELD(fpi[0], R300_PFS_INSTR0_0, inst0);
	OUTPUT_FIELD(fpi[1], R300_PFS_INSTR1_0, inst1);
	OUTPUT_FIELD(fpi[2], R300_PFS_INSTR2_0, inst2);
	OUTPUT_FIELD(fpi[3], R300_PFS_INSTR3_0, inst3);
#undef OUTPUT_FIELD
d2554 7
d2562 2
a2563 2
	for (i = 0, k = (4 - (fp->cur_node + 1)); i < 4; i++, k++) {
		if (i < (fp->cur_node + 1)) {
d2565 5
a2569 9
			    (fp->node[i].
			     alu_offset << R300_PFS_NODE_ALU_OFFSET_SHIFT)
			    | (fp->node[i].
			       alu_end << R300_PFS_NODE_ALU_END_SHIFT)
			    | (fp->node[i].
			       tex_offset << R300_PFS_NODE_TEX_OFFSET_SHIFT)
			    | (fp->node[i].
			       tex_end << R300_PFS_NODE_TEX_END_SHIFT)
			    | fp->node[i].flags;	/*  ( (k==3) ? R300_PFS_NODE_LAST_NODE : 0); */
d2575 62
a2636 11
	/*  PFS_CNTL_0 */
	rmesa->hw.fp.cmd[R300_FP_CNTL0] =
	    fp->cur_node | (fp->first_node_has_tex << 3);
	/* PFS_CNTL_1 */
	rmesa->hw.fp.cmd[R300_FP_CNTL1] = fp->max_temp_idx;
	/* PFS_CNTL_2 */
	rmesa->hw.fp.cmd[R300_FP_CNTL2] =
	    (fp->alu_offset << R300_PFS_CNTL_ALU_OFFSET_SHIFT)
	    | (fp->alu_end << R300_PFS_CNTL_ALU_END_SHIFT)
	    | (fp->tex_offset << R300_PFS_CNTL_TEX_OFFSET_SHIFT)
	    | (fp->tex_end << R300_PFS_CNTL_TEX_END_SHIFT);
d2638 30
a2667 10
	R300_STATECHANGE(rmesa, fpp);
	for (i = 0; i < fp->const_nr; i++) {
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 0] =
		    r300PackFloat24(fp->constant[i][0]);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 1] =
		    r300PackFloat24(fp->constant[i][1]);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 2] =
		    r300PackFloat24(fp->constant[i][2]);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 3] =
		    r300PackFloat24(fp->constant[i][3]);
d2669 2
a2670 2
	rmesa->hw.fpp.cmd[R300_FPP_CMD_0] =
	    cmdpacket0(R300_PFS_PARAM_0_X, fp->const_nr * 4);
d2679 14
d2694 4
a2697 2
	r300SetupPixelShader(rmesa);
	r300SetupTextures(ctx);
d2700 2
a2701 2
		r300SetupVertexShader(rmesa);
	r300SetupRSUnit(ctx);
d2741 1
a2741 2
		depth_fmt = R300_DEPTH_FORMAT_16BIT_INT_Z;
		r300->state.stencil.clear = 0x00000000;
d2745 1
a2745 2
		depth_fmt = R300_DEPTH_FORMAT_24BIT_INT_Z;
		r300->state.stencil.clear = 0x00ff0000;
a2746 2


a2768 14
static void r300ClipPlane( GLcontext *ctx, GLenum plane, const GLfloat *eq )
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	GLint p = (GLint) plane - (GLint) GL_CLIP_PLANE0;
	GLint *ip = (GLint *)ctx->Transform._ClipUserPlane[p];

	R300_STATECHANGE( rmesa, vpucp[p] );
	rmesa->hw.vpucp[p].cmd[R300_VPUCP_X] = ip[0];
	rmesa->hw.vpucp[p].cmd[R300_VPUCP_Y] = ip[1];
	rmesa->hw.vpucp[p].cmd[R300_VPUCP_Z] = ip[2];
	rmesa->hw.vpucp[p].cmd[R300_VPUCP_W] = ip[3];
}


d2773 1
a2773 1
	
d2777 1
a2777 1
			
d2807 4
a2812 1
	functions->ClearStencil = r300ClearStencil;
@


1.1
log
@Initial revision
@
text
@d32 4
a35 3
/*
 * Authors:
 *   Nicolai Haehnle <prefect_@@gmx.net>
d50 3
a52 1
#include "array_cache/acache.h"
a61 1
#include "r300_program.h"
a64 1
#include "r300_maos.h"
d73 1
a73 1
	R300_STATECHANGE(rmesa, unk4E10);
d80 2
a81 2
	rmesa->hw.unk4E10.cmd[1] = r300PackColor(4, color[3], color[0],
						 color[1], color[2]);
a99 2
	int func;

d102 1
a102 1
		func = R300_BLEND_GL_ZERO;
d105 1
a105 1
		func = R300_BLEND_GL_ONE;
d108 1
a108 1
		func = R300_BLEND_GL_DST_COLOR;
d111 1
a111 1
		func = R300_BLEND_GL_ONE_MINUS_DST_COLOR;
d114 1
a114 1
		func = R300_BLEND_GL_SRC_COLOR;
d117 1
a117 1
		func = R300_BLEND_GL_ONE_MINUS_SRC_COLOR;
d120 1
a120 1
		func = R300_BLEND_GL_SRC_ALPHA;
d123 1
a123 1
		func = R300_BLEND_GL_ONE_MINUS_SRC_ALPHA;
d126 1
a126 1
		func = R300_BLEND_GL_DST_ALPHA;
d129 1
a129 1
		func = R300_BLEND_GL_ONE_MINUS_DST_ALPHA;
d132 2
a133 2
		func = (is_src) ? R300_BLEND_GL_SRC_ALPHA_SATURATE :
		R300_BLEND_GL_ZERO;
d136 1
a136 1
		func = R300_BLEND_GL_CONST_COLOR;
d139 1
a139 1
		func = R300_BLEND_GL_ONE_MINUS_CONST_COLOR;
d142 1
a142 1
		func = R300_BLEND_GL_CONST_ALPHA;
d145 1
a145 1
		func = R300_BLEND_GL_ONE_MINUS_CONST_ALPHA;
d149 2
a150 1
		func = (is_src) ? R300_BLEND_GL_ONE : R300_BLEND_GL_ZERO;
a151 1
	return func;
d166 2
a167 1
static void r300_set_blend_cntl(r300ContextPtr r300, int func, int eqn, int cbits, int funcA, int eqnA)
d172 3
a174 1
	fprintf(stderr, "eqnA=%08x funcA=%08x eqn=%08x func=%08x cbits=%08x\n", eqnA, funcA, eqn, func, cbits);
d187 1
a187 1
		new_cblend |=  R300_BLEND_NO_SEPARATE;
d192 2
a193 2
	if((new_ablend != r300->hw.bld.cmd[R300_BLD_ABLEND]) ||
	   (new_cblend != r300->hw.bld.cmd[R300_BLD_CBLEND])) {
d195 2
a196 2
		r300->hw.bld.cmd[R300_BLD_ABLEND]=new_ablend;
		r300->hw.bld.cmd[R300_BLD_CBLEND]=new_cblend;
d200 1
a200 2

static void r300_set_blend_state(GLcontext * ctx)
d210 2
a211 4
	if (ctx->Color._LogicOpEnabled || !ctx->Color.BlendEnabled) {
		r300_set_blend_cntl(r300,
			func, eqn, 0,
			func, eqn);
d215 5
a219 2
	func = (blend_factor(ctx->Color.BlendSrcRGB, GL_TRUE) << R300_SRC_BLEND_SHIFT) |
		(blend_factor(ctx->Color.BlendDstRGB, GL_FALSE) << R300_DST_BLEND_SHIFT);
d249 1
a249 1
			__func__, __LINE__, ctx->Color.BlendEquationRGB);
d253 5
a257 3

	funcA = (blend_factor(ctx->Color.BlendSrcA, GL_TRUE) << R300_SRC_BLEND_SHIFT) |
		(blend_factor(ctx->Color.BlendDstA, GL_FALSE) << R300_DST_BLEND_SHIFT);
d285 3
a287 2
		fprintf(stderr, "[%s:%u] Invalid A blend equation (0x%04x).\n",
			__func__, __LINE__, ctx->Color.BlendEquationA);
d291 3
a293 3
	r300_set_blend_cntl(r300,
		func, eqn, R300_BLEND_UNKNOWN | R300_BLEND_ENABLE,
		funcA, eqnA);
d299 1
a299 1
	r300_set_blend_state(ctx);
d306 1
a306 1
	r300_set_blend_state(ctx);
d312 1
a312 1
static void r300UpdateCulling(GLcontext* ctx)
d320 1
a320 1
			val = R300_CULL_FRONT|R300_CULL_BACK;
d334 1
a334 1
static void update_early_z(GLcontext *ctx)
d336 5
a340 5
	/* updates register 0x4f14 
	   if depth test is not enabled it should be 0x00000000
	   if depth is enabled and alpha not it should be 0x00000001
	   if depth and alpha is enabled it should be 0x00000000
	*/
d343 1
a343 1
	R300_STATECHANGE(r300, unk4F10);
d346 1
a346 1
		r300->hw.unk4F10.cmd[2] = 0x00000000;
d350 1
a350 1
			r300->hw.unk4F10.cmd[2] = 0x00000001;
d353 1
a353 1
			r300->hw.unk4F10.cmd[2] = 0x00000000;
d357 1
a357 1
static void update_alpha(GLcontext *ctx)
d365 1
a365 1
	
d389 1
a389 1
		/*pp_misc |= R300_ALPHA_TEST_PASS;*/
d393 1
a393 1
	
d400 1
a400 2
	
	
d403 2
a404 1
	update_early_z(ctx);
d409 3
a411 3
	(void) func;
	(void) ref;
	update_alpha(ctx);
d437 1
a437 1
static void update_depth(GLcontext* ctx)
d443 3
a445 2
	r300->hw.zs.cmd[R300_ZS_CNTL_1] &= ~(R300_ZS_MASK << R300_RB3D_ZS1_DEPTH_FUNC_SHIFT);
	
d448 2
a449 1
			r300->hw.zs.cmd[R300_ZS_CNTL_0] |= R300_RB3D_Z_TEST_AND_WRITE;
d452 4
a455 2
		
		r300->hw.zs.cmd[R300_ZS_CNTL_1] |= translate_func(ctx->Depth.Func) << R300_RB3D_ZS1_DEPTH_FUNC_SHIFT;
d458 2
a459 1
		r300->hw.zs.cmd[R300_ZS_CNTL_1] |= translate_func(GL_NEVER) << R300_RB3D_ZS1_DEPTH_FUNC_SHIFT;
d461 2
a462 2
	
	update_early_z(ctx);
d465 2
d472 1
a472 1
static void r300Enable(GLcontext* ctx, GLenum cap, GLboolean state)
d475 1
a475 2
	uint32_t newval;

d492 8
a499 8
			r300->hw.fogs.cmd[R300_FOGS_STATE] |=
			    R300_FOG_ENABLE;
			
			ctx->Driver.Fogfv( ctx, GL_FOG_MODE, NULL );
			ctx->Driver.Fogfv( ctx, GL_FOG_DENSITY, &ctx->Fog.Density );
			ctx->Driver.Fogfv( ctx, GL_FOG_START, &ctx->Fog.Start );
			ctx->Driver.Fogfv( ctx, GL_FOG_END, &ctx->Fog.End );
			ctx->Driver.Fogfv( ctx, GL_FOG_COLOR, ctx->Fog.Color );
d501 1
a501 2
			r300->hw.fogs.cmd[R300_FOGS_STATE] &=
			    ~R300_FOG_ENABLE;
d503 1
a503 1
		
d507 1
a507 1
		update_alpha(ctx);
d512 1
a512 1
		r300_set_blend_state(ctx);
d515 21
d537 1
a537 1
		update_depth(ctx);
a543 1
				WARN_ONCE("TODO - double side stencil !\n");
d553 1
a553 1
#endif			
d566 3
a568 3
		R300_STATECHANGE(r300, unk42B4);
		if(state){
			r300->hw.unk42B4.cmd[1] |= (3<<0);
d570 1
a570 1
			r300->hw.unk42B4.cmd[1] &= ~(3<<0);
d579 1
a579 2

static void r300UpdatePolygonMode(GLcontext *ctx)
d582 1
a582 1
	uint32_t hw_mode=0;
d587 1
a587 1
		
d601 2
a602 2
		break;
		case GL_POINT: /* noop */
d604 1
a604 1
		break;
d607 1
a607 1
		break;
d613 2
a614 2
		break;
		case GL_POINT: /* noop */
d616 1
a616 1
		break;
d619 1
a619 1
		break;
d623 3
a625 3
	if (r300->hw.unk4288.cmd[1] != hw_mode) {
		R300_STATECHANGE(r300, unk4288);
		r300->hw.unk4288.cmd[1] = hw_mode;
d634 1
a634 1
static void r300CullFace(GLcontext* ctx, GLenum mode)
a640 1

d646 1
a646 1
static void r300FrontFace(GLcontext* ctx, GLenum mode)
a653 1

d659 1
a659 1
static void r300DepthFunc(GLcontext* ctx, GLenum func)
d661 2
a662 2
	(void) func;
	update_depth(ctx);
a664 1

d670 1
a670 1
static void r300DepthMask(GLcontext* ctx, GLboolean mask)
d672 2
a673 2
	(void) mask;
	update_depth(ctx);
a675 1

d679 1
a679 1
static void r300ColorMask(GLcontext* ctx,
d684 2
a685 3
		   (g ? R300_COLORMASK0_G : 0) |
		   (b ? R300_COLORMASK0_B : 0) |
		   (a ? R300_COLORMASK0_A : 0);
d696 1
a696 1
static void r300Fogfv( GLcontext *ctx, GLenum pname, const GLfloat *param )
d699 7
a705 4
	union { int i; float f; } fogScale, fogStart;
	
	(void) param;
	
d717 3
a719 1
				(r300->hw.fogs.cmd[R300_FOGS_STATE] & ~R300_FOG_MODE_MASK) | R300_FOG_MODE_LINEAR;
d724 6
a729 4
			}
			else {
				fogScale.f = 1.0 / (ctx->Fog.End-ctx->Fog.Start);
				fogStart.f = -ctx->Fog.Start / (ctx->Fog.End-ctx->Fog.Start);
d735 4
a738 2
				(r300->hw.fogs.cmd[R300_FOGS_STATE] & ~R300_FOG_MODE_MASK) | R300_FOG_MODE_EXP;
			fogScale.f = 0.0933*ctx->Fog.Density;
d744 4
a747 2
				(r300->hw.fogs.cmd[R300_FOGS_STATE] & ~R300_FOG_MODE_MASK) | R300_FOG_MODE_EXP2;
			fogScale.f = 0.3*ctx->Fog.Density;
d756 1
a756 1
			fogScale.f = 0.0933*ctx->Fog.Density;
d760 1
a760 1
			fogScale.f = 0.3*ctx->Fog.Density;
d772 6
a777 4
			}
			else {
				fogScale.f = 1.0 / (ctx->Fog.End-ctx->Fog.Start);
				fogStart.f = -ctx->Fog.Start / (ctx->Fog.End-ctx->Fog.Start);
d783 6
a788 3
		r300->hw.fogc.cmd[R300_FOGC_R] = (GLuint) (ctx->Fog.Color[0]*1023.0F) & 0x3FF;
		r300->hw.fogc.cmd[R300_FOGC_G] = (GLuint) (ctx->Fog.Color[1]*1023.0F) & 0x3FF;
		r300->hw.fogc.cmd[R300_FOGC_B] = (GLuint) (ctx->Fog.Color[2]*1023.0F) & 0x3FF;
d814 3
a816 3
	r300->hw.ps.cmd[R300_PS_POINTSIZE] = 
		((int)(size * 6) << R300_POINTSIZE_X_SHIFT) |
		((int)(size * 6) << R300_POINTSIZE_Y_SHIFT);
d822 1
a822 1
static void r300LineWidth(GLcontext *ctx, GLfloat widthf)
d833 1
a833 1
static void r300PolygonMode(GLcontext *ctx, GLenum face, GLenum mode)
d837 1
a837 1
	
d874 2
a875 2
	
	R300_STATECHANGE(rmesa, unk4274);
d878 1
a878 1
		rmesa->hw.unk4274.cmd[2] = R300_RE_SHADE_MODEL_FLAT;
d881 1
a881 1
		rmesa->hw.unk4274.cmd[2] = R300_RE_SHADE_MODEL_SMOOTH;
d889 1
a889 1
                                    GLenum func, GLint ref, GLuint mask)
d892 10
a901 3
	GLuint refmask = (((ctx->Stencil.Ref[0] & 0xff) << R300_RB3D_ZS2_STENCIL_REF_SHIFT) |
			  ((ctx->Stencil.ValueMask[0] & 0xff) << R300_RB3D_ZS2_STENCIL_MASK_SHIFT));
			  
d906 10
a915 7
	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] &= ~(
		(R300_ZS_MASK << R300_RB3D_ZS1_FRONT_FUNC_SHIFT)
		| (R300_ZS_MASK << R300_RB3D_ZS1_BACK_FUNC_SHIFT));
	
	rmesa->hw.zs.cmd[R300_ZS_CNTL_2] &=  ~((R300_RB3D_ZS2_STENCIL_MASK << R300_RB3D_ZS2_STENCIL_REF_SHIFT) |
						(R300_RB3D_ZS2_STENCIL_MASK << R300_RB3D_ZS2_STENCIL_MASK_SHIFT));
	
d917 5
d923 2
a924 2
	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |= (flag << R300_RB3D_ZS1_FRONT_FUNC_SHIFT)
					  | (flag << R300_RB3D_ZS1_BACK_FUNC_SHIFT);
d933 6
a938 2
	rmesa->hw.zs.cmd[R300_ZS_CNTL_2]  &= ~(R300_RB3D_ZS2_STENCIL_MASK << R300_RB3D_ZS2_STENCIL_WRITE_MASK_SHIFT);
	rmesa->hw.zs.cmd[R300_ZS_CNTL_2] |= (ctx->Stencil.WriteMask[0] & 0xff) << R300_RB3D_ZS2_STENCIL_WRITE_MASK_SHIFT;
d941 2
a942 3

static void r300StencilOpSeparate(GLcontext * ctx, GLenum face, GLenum fail,
                                  GLenum zfail, GLenum zpass)
d947 4
a950 4
		/* It is easier to mask what's left.. */
	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] &= 
	    (R300_ZS_MASK << R300_RB3D_ZS1_DEPTH_FUNC_SHIFT) | 
	    (R300_ZS_MASK << R300_RB3D_ZS1_FRONT_FUNC_SHIFT) | 
d954 24
a977 6
		 (translate_stencil_op(ctx->Stencil.FailFunc[0]) << R300_RB3D_ZS1_FRONT_FAIL_OP_SHIFT)
		|(translate_stencil_op(ctx->Stencil.ZFailFunc[0]) << R300_RB3D_ZS1_FRONT_ZFAIL_OP_SHIFT)
		|(translate_stencil_op(ctx->Stencil.ZPassFunc[0]) << R300_RB3D_ZS1_FRONT_ZPASS_OP_SHIFT)
		|(translate_stencil_op(ctx->Stencil.FailFunc[0]) << R300_RB3D_ZS1_BACK_FAIL_OP_SHIFT)
		|(translate_stencil_op(ctx->Stencil.ZFailFunc[0]) << R300_RB3D_ZS1_BACK_ZFAIL_OP_SHIFT)
		|(translate_stencil_op(ctx->Stencil.ZPassFunc[0]) << R300_RB3D_ZS1_BACK_ZPASS_OP_SHIFT);
d986 4
a989 2
	     (R300_RB3D_ZS2_STENCIL_MASK << R300_RB3D_ZS2_STENCIL_MASK_SHIFT) |
	     ((ctx->Stencil.WriteMask[0] & 0xff) << R300_RB3D_ZS2_STENCIL_WRITE_MASK_SHIFT));
d1002 1
a1002 1
void r300UpdateWindow(GLcontext * ctx)
d1020 1
a1020 1
	rmesa->hw.vpt.cmd[R300_VPT_XSCALE]  = r300PackFloat32(sx);
d1022 1
a1022 1
	rmesa->hw.vpt.cmd[R300_VPT_YSCALE]  = r300PackFloat32(sy);
d1024 1
a1024 1
	rmesa->hw.vpt.cmd[R300_VPT_ZSCALE]  = r300PackFloat32(sz);
d1043 1
a1043 1
void r300UpdateViewportOffset( GLcontext *ctx )
d1046 3
a1048 3
	__DRIdrawablePrivate *dPriv = ((radeonContextPtr)rmesa)->dri.drawable;
	GLfloat xoffset = (GLfloat)dPriv->x;
	GLfloat yoffset = (GLfloat)dPriv->y + dPriv->h;
d1052 10
a1061 1
	GLfloat ty = (- v[MAT_TY]) + yoffset + SUBPIXEL_Y;
a1062 10
	if ( rmesa->hw.vpt.cmd[R300_VPT_XOFFSET] != r300PackFloat32(tx) ||
		rmesa->hw.vpt.cmd[R300_VPT_YOFFSET] != r300PackFloat32(ty))
	{
	/* Note: this should also modify whatever data the context reset
	 * code uses...
	 */
	R300_STATECHANGE( rmesa, vpt );
	rmesa->hw.vpt.cmd[R300_VPT_XOFFSET] = r300PackFloat32(tx);
	rmesa->hw.vpt.cmd[R300_VPT_YOFFSET] = r300PackFloat32(ty);
      
d1065 1
a1065 1
	radeonUpdateScissor( ctx );
d1072 1
a1072 2
void
r300UpdateDrawBuffer(GLcontext *ctx)
d1081 4
a1084 3
		drb = (driRenderbuffer *) fb->Attachment[BUFFER_FRONT_LEFT].Renderbuffer;
	}
	else if (fb->_ColorDrawBufferMask[0] == BUFFER_BIT_BACK_LEFT) {
d1086 4
a1089 3
		drb = (driRenderbuffer *) fb->Attachment[BUFFER_BACK_LEFT].Renderbuffer;
	}
	else {
d1097 5
a1102 6
	R300_STATECHANGE( rmesa, cb );
	
	r300->hw.cb.cmd[R300_CB_OFFSET] = drb->flippedOffset + //r300->radeon.state.color.drawOffset +
		r300->radeon.radeonScreen->fbLocation;
	r300->hw.cb.cmd[R300_CB_PITCH] = drb->flippedPitch;//r300->radeon.state.color.drawPitch;
	
d1107 1
a1107 1
	
d1111 1
a1111 1
	R200_STATECHANGE( rmesa, ctx );
d1115 2
a1116 2
		= ((drb->flippedOffset + rmesa->r200Screen->fbLocation)
		& R200_COLOROFFSET_MASK);
d1118 1
a1118 1
	
d1120 2
a1121 1
		rmesa->hw.ctx.cmd[CTX_RB3D_COLORPITCH] |= R200_COLOR_TILE_ENABLE;
d1126 77
d1210 1
a1210 1
	
d1214 1
a1214 1
	break;
d1217 1
a1217 1
	break;
a1232 1

d1244 1
a1244 1
	unsigned long mag, min, needs_fixing=0;
d1248 2
a1249 1
	if((f & ((7-1) << R300_TX_WRAP_S_SHIFT)) == (R300_TX_CLAMP << R300_TX_WRAP_S_SHIFT)){
d1252 2
a1253 1
	if((f & ((7-1) << R300_TX_WRAP_T_SHIFT)) == (R300_TX_CLAMP << R300_TX_WRAP_T_SHIFT)){
d1256 2
a1257 1
	if((f & ((7-1) << R300_TX_WRAP_Q_SHIFT)) == (R300_TX_CLAMP << R300_TX_WRAP_Q_SHIFT)){
d1261 1
a1261 1
	if(!needs_fixing)
d1264 2
a1265 2
	mag=f & R300_TX_MAG_FILTER_MASK;
	min=f & R300_TX_MIN_FILTER_MASK;
d1268 2
a1269 1
	if((mag != R300_TX_MAG_FILTER_NEAREST) && (min != R300_TX_MIN_FILTER_NEAREST))
d1273 2
a1274 1
	if((mag == R300_TX_MAG_FILTER_NEAREST) && (min != R300_TX_MIN_FILTER_NEAREST)){
d1280 2
a1281 1
	if((min == R300_TX_MIN_FILTER_NEAREST) && (mag != R300_TX_MAG_FILTER_NEAREST)){
d1288 2
a1289 2
	if(needs_fixing & 1){
		f &= ~((7-1) << R300_TX_WRAP_S_SHIFT);
d1292 2
a1293 2
	if(needs_fixing & 2){
		f &= ~((7-1) << R300_TX_WRAP_T_SHIFT);
d1296 2
a1297 2
	if(needs_fixing & 4){
		f &= ~((7-1) << R300_TX_WRAP_Q_SHIFT);
d1303 1
a1303 1
void r300_setup_textures(GLcontext *ctx)
d1308 5
a1312 6
	int hw_tmu=0;
	int last_hw_tmu=-1; /* -1 translates into no setup costs for fields */
	int tmu_mappings[R300_MAX_TEXTURE_UNITS] = { -1 };
	struct r300_fragment_program *rp =
		(struct r300_fragment_program *)
		(char *)ctx->FragmentProgram._Current;
d1316 1
a1316 1
	R300_STATECHANGE(r300, tex.unknown1);
d1321 1
a1321 1
	R300_STATECHANGE(r300, tex.unknown4);
d1323 2
a1324 2
	
	r300->hw.txe.cmd[R300_TXE_ENABLE]=0x0;
d1330 3
a1332 2
	if(mtu > R300_MAX_TEXTURE_UNITS) {
		fprintf(stderr, "Aiiee ! mtu=%d is greater than R300_MAX_TEXTURE_UNITS=%d\n",
d1334 1
a1334 1
		exit(-1);
d1338 4
a1341 4
	for(i=0; i < mtu; i++) {
		if(TMU_ENABLED(ctx, i)) {
			
#if 0 /* Enables old behaviour */
d1345 10
a1354 5
			
			t=r300->state.texture.unit[i].texobj;
			
			if((t->format & 0xffffff00)==0xffffff00) {
				WARN_ONCE("unknown texture format (entry %x) encountered. Help me !\n", t->format & 0xff);
d1356 1
a1356 1
			
d1358 3
a1360 2
				fprintf(stderr, "Activating texture unit %d\n", i);
			
d1362 4
a1365 2
			
			r300->hw.tex.filter.cmd[R300_TEX_VALUE_0 + hw_tmu] = gen_fixed_filter(t->filter) | (hw_tmu << 28);
d1367 11
a1377 7
			r300->hw.tex.unknown1.cmd[R300_TEX_VALUE_0 + hw_tmu] = 0x0; //0x20501f80;
			r300->hw.tex.size.cmd[R300_TEX_VALUE_0 + hw_tmu] = t->size;
			r300->hw.tex.format.cmd[R300_TEX_VALUE_0 + hw_tmu] = t->format;
			r300->hw.tex.pitch.cmd[R300_TEX_VALUE_0 + hw_tmu] = t->pitch_reg;
			r300->hw.tex.offset.cmd[R300_TEX_VALUE_0 + hw_tmu] = t->offset;
			
			if(t->offset & R300_TXO_MACRO_TILE) {
d1380 2
a1381 2
			
			if(t->offset & R300_TXO_MICRO_TILE) {
d1384 7
a1390 4
			
			r300->hw.tex.unknown4.cmd[R300_TEX_VALUE_0 + hw_tmu] = 0x0;
			r300->hw.tex.border_color.cmd[R300_TEX_VALUE_0 + hw_tmu] = t->pp_border_color;
			
d1392 1
a1392 1
			
d1396 19
a1414 12
	
	r300->hw.tex.filter.cmd[R300_TEX_CMD_0] = cmdpacket0(R300_TX_FILTER_0, last_hw_tmu + 1);
	r300->hw.tex.unknown1.cmd[R300_TEX_CMD_0] = cmdpacket0(R300_TX_FILTER1_0, last_hw_tmu + 1);
	r300->hw.tex.size.cmd[R300_TEX_CMD_0] = cmdpacket0(R300_TX_SIZE_0, last_hw_tmu + 1);
	r300->hw.tex.format.cmd[R300_TEX_CMD_0] = cmdpacket0(R300_TX_FORMAT_0, last_hw_tmu + 1);
	r300->hw.tex.pitch.cmd[R300_TEX_CMD_0] = cmdpacket0(R300_TX_PITCH_0, last_hw_tmu + 1);
	r300->hw.tex.offset.cmd[R300_TEX_CMD_0] = cmdpacket0(R300_TX_OFFSET_0, last_hw_tmu + 1);
	r300->hw.tex.unknown4.cmd[R300_TEX_CMD_0] = cmdpacket0(R300_TX_CHROMA_KEY_0, last_hw_tmu + 1);
	r300->hw.tex.border_color.cmd[R300_TEX_CMD_0] = cmdpacket0(R300_TX_BORDER_COLOR_0, last_hw_tmu + 1);
	
	
	if (!rp)	/* should only happenen once, just after context is created */
d1416 1
a1416 1
	
d1418 2
a1419 2
	
	for(i = 0; i < rp->tex.length; i++){
d1421 1
d1423 2
a1424 2
		
		unit = rp->tex.inst[i] >> R300_FPITX_IMAGE_SHIFT;
d1426 2
a1427 2
		
		val = rp->tex.inst[i];
d1429 17
a1445 5
		
		assert(tmu_mappings[unit] >= 0);
		
		val |= tmu_mappings[unit] << R300_FPITX_IMAGE_SHIFT;
		r300->hw.fpt.cmd[R300_FPT_INSTR_0+i] = val;
d1447 4
a1450 3
	
	r300->hw.fpt.cmd[R300_FPT_CMD_0] = cmdpacket0(R300_PFS_TEXI_0, rp->tex.length);
	
d1452 2
a1453 1
		fprintf(stderr, "TX_ENABLE: %08x  last_hw_tmu=%d\n", r300->hw.txe.cmd[R300_TXE_ENABLE], last_hw_tmu);
d1457 2
a1458 2
	GLuint vp_outputs;                       /* hw_tcl_on */
	DECLARE_RENDERINPUTS(index_bitset);      /* !hw_tcl_on */
d1465 1
a1465 1
void r300_setup_rs_unit(GLcontext *ctx)
d1471 3
a1473 3
		0x40,
		0x80,
		0xC0,
d1485 3
a1487 2
	if(hw_tcl_on)
		OutputsWritten.vp_outputs = CURRENT_VERTEX_SHADER(ctx)->Base.OutputsWritten;
d1489 2
a1490 1
		RENDERINPUTS_COPY( OutputsWritten.index_bitset, r300->state.render_inputs_bitset );
d1496 1
a1496 1
		return; /* This should only ever happen once.. */
d1502 1
a1502 1
	
d1506 20
a1525 6
	
	for (i=0;i<ctx->Const.MaxTextureUnits;i++) {
		r300->hw.ri.cmd[R300_RI_INTERP_0+i] = 0
				| R300_RS_INTERP_USED
				| (in_texcoords << R300_RS_INTERP_SRC_SHIFT)
				| interp_magic[i];
d1528 1
a1528 1
		if (InputsRead & (FRAG_BIT_TEX0<<i)) {
d1530 2
a1531 4
			r300->hw.rr.cmd[R300_RR_ROUTE_0 + fp_reg] |=
					  R300_RS_ROUTE_ENABLE
					| i /* source INTERP */
					| (fp_reg << R300_RS_ROUTE_DEST_SHIFT);
d1534 3
a1536 1
			if (!R300_OUTPUTS_WRITTEN_TEST( OutputsWritten, VERT_RESULT_TEX0+i, _TNL_ATTRIB_TEX(i) )) {
d1538 3
a1540 1
				WARN_ONCE("fragprog wants coords for tex%d, vp doesn't provide them!\n", i);
d1542 1
a1542 1
				//exit(-1);
d1544 1
a1544 1
			InputsRead &= ~(FRAG_BIT_TEX0<<i);
d1546 1
a1546 1
		} 
d1548 2
a1549 1
		if (R300_OUTPUTS_WRITTEN_TEST( OutputsWritten, VERT_RESULT_TEX0+i, _TNL_ATTRIB_TEX(i) ))
d1554 5
a1558 3
		if (!R300_OUTPUTS_WRITTEN_TEST( OutputsWritten, VERT_RESULT_COL0, _TNL_ATTRIB_COLOR0 )) {
			WARN_ONCE("fragprog wants col0, vp doesn't provide it\n");
			goto out; /* FIXME */
d1560 1
a1560 1
			//exit(-1);
d1564 2
a1565 2
				| R300_RS_ROUTE_0_COLOR
				| (fp_reg++ << R300_RS_ROUTE_0_COLOR_DEST_SHIFT);
d1569 2
a1570 2
	out:
	
d1572 5
a1576 3
		if (!R300_OUTPUTS_WRITTEN_TEST( OutputsWritten, VERT_RESULT_COL1, _TNL_ATTRIB_COLOR1 )) {
			WARN_ONCE("fragprog wants col1, vp doesn't provide it\n");
			//exit(-1);
d1579 3
a1581 3
		r300->hw.rr.cmd[R300_RR_ROUTE_1] |= R300_RS_ROUTE_1_UNKNOWN11
				| R300_RS_ROUTE_1_COLOR1
				| (fp_reg++ << R300_RS_ROUTE_1_COLOR1_DEST_SHIFT);
d1583 2
a1584 1
		if (high_rr < 1) high_rr = 1;
d1587 1
a1587 1
	
d1591 2
a1592 2
				| R300_RS_ROUTE_0_COLOR
				| (fp_reg++ << R300_RS_ROUTE_0_COLOR_DEST_SHIFT);
d1595 4
a1598 5
	
	r300->hw.rc.cmd[1] = 0
			| (in_texcoords << R300_RS_CNTL_TC_CNT_SHIFT)
			| (col_interp_nr << R300_RS_CNTL_CI_CNT_SHIFT)
			| R300_RS_CNTL_0_UNKNOWN_18;
d1601 2
a1602 1
	r300->hw.rr.cmd[R300_RR_CMD_0] = cmdpacket0(R300_RS_ROUTE_0, high_rr+1);
d1606 2
a1607 1
		WARN_ONCE("Don't know how to satisfy InputsRead=0x%08x\n", InputsRead);
d1619 3
a1621 1
void static inline setup_vertex_shader_fragment(r300ContextPtr r300, int dest, struct r300_vertex_shader_fragment *vsf)
d1625 2
a1626 1
	if(vsf->length==0)return;
d1628 5
a1632 4
	if(vsf->length & 0x3){
		fprintf(stderr,"VERTEX_SHADER_FRAGMENT must have length divisible by 4\n");
		exit(-1);
		}
d1634 1
a1634 1
	switch((dest>>8) & 0xf){
d1637 5
a1641 3
		for(i=0;i<vsf->length;i++)
			r300->hw.vpi.cmd[R300_VPI_INSTR_0+i+4*(dest & 0xff)]=(vsf->body.d[i]);
		bump_vpu_count(r300->hw.vpi.cmd, vsf->length+4*(dest & 0xff));
d1646 5
a1650 3
		for(i=0;i<vsf->length;i++)
			r300->hw.vpp.cmd[R300_VPP_PARAM_0+i+4*(dest & 0xff)]=(vsf->body.d[i]);
		bump_vpu_count(r300->hw.vpp.cmd, vsf->length+4*(dest & 0xff));
d1654 5
a1658 3
		for(i=0;i<vsf->length;i++)
			r300->hw.vps.cmd[1+i+4*(dest & 0xff)]=(vsf->body.d[i]);
		bump_vpu_count(r300->hw.vps.cmd, vsf->length+4*(dest & 0xff));
d1661 4
a1664 2
		fprintf(stderr, "%s:%s don't know how to handle dest %04x\n", __FILE__, __FUNCTION__, dest);
		exit(-1);
a1667 2
void r300SetupVertexProgram(r300ContextPtr rmesa);

d1671 2
a1672 2
   while leaving colors intact. Nothing fancy (like lights) 
   
d1680 14
a1693 21
	r300->state.vap_param.transform_offset=0x0;  /* transform matrix */
	r300->state.vertex_shader.param_offset=0x0;
	r300->state.vertex_shader.param_count=0x4;  /* 4 vector values - 4x4 matrix */
	
	r300->state.vertex_shader.program_start=0x0;
	r300->state.vertex_shader.unknown_ptr1=0x4; /* magic value ? */
	r300->state.vertex_shader.program_end=0x0;
	
	r300->state.vertex_shader.unknown_ptr2=0x0; /* magic value */
	r300->state.vertex_shader.unknown_ptr3=0x4; /* magic value */
	
	/* Initialize matrix and vector parameters.. these should really be restructured */
	/* TODO: fix vertex_shader structure */
	r300->state.vertex_shader.matrix[0].length=16;
	r300->state.vertex_shader.matrix[1].length=0;
	r300->state.vertex_shader.matrix[2].length=0;
	r300->state.vertex_shader.vector[0].length=0;
	r300->state.vertex_shader.vector[1].length=0;
	r300->state.vertex_shader.unknown1.length=0;
	r300->state.vertex_shader.unknown2.length=0;
	
d1696 3
a1698 3
	r300->state.vertex_shader.program.body.i[r300->state.vertex_shader.program_end].src1=(source1); \
	r300->state.vertex_shader.program.body.i[r300->state.vertex_shader.program_end].src2=(source2); \
	r300->state.vertex_shader.program.body.i[r300->state.vertex_shader.program_end].src3=(source3); \
d1702 1
a1702 39
	/* Multiply vertex coordinates with transform matrix */
			
	WRITE_OP(
		EASY_VSF_OP(MUL, 0, ALL, TMP),
		VSF_PARAM(3),
		VSF_ATTR_W(0),
		EASY_VSF_SOURCE(0, W, W, W, W, NONE, NONE)
		)
	
	WRITE_OP(
		EASY_VSF_OP(MUL, 1, ALL, RESULT),
		VSF_REG(1),
		VSF_ATTR_UNITY(1),
		VSF_UNITY(1)
		)
	
	WRITE_OP(
		EASY_VSF_OP(MAD, 0, ALL, TMP),
		VSF_PARAM(2),
		VSF_ATTR_Z(0),
		VSF_TMP(0)
		)
	
	WRITE_OP(
		EASY_VSF_OP(MAD, 0, ALL, TMP),
		VSF_PARAM(1),
		VSF_ATTR_Y(0),
		VSF_TMP(0)
		)
	
	WRITE_OP(
		EASY_VSF_OP(MAD, 0, ALL, RESULT),
		VSF_PARAM(0),
		VSF_ATTR_X(0),
		VSF_TMP(0)
		)
	o_reg += 2;
	
	for (i = VERT_ATTRIB_COLOR1; i < VERT_ATTRIB_MAX; i++)
d1704 6
a1709 39
			WRITE_OP(
				EASY_VSF_OP(MUL, o_reg++ /* 2+i */, ALL, RESULT),
				VSF_REG(r300->state.sw_tcl_inputs[i]),
				VSF_ATTR_UNITY(r300->state.sw_tcl_inputs[i]),
				VSF_UNITY(r300->state.sw_tcl_inputs[i])
				)
		
		}
	
	r300->state.vertex_shader.program_end--; /* r300 wants program length to be one more - no idea why */
	r300->state.vertex_shader.program.length=(r300->state.vertex_shader.program_end+1)*4;
	
	r300->state.vertex_shader.unknown_ptr1=r300->state.vertex_shader.program_end; /* magic value ? */
	r300->state.vertex_shader.unknown_ptr2=r300->state.vertex_shader.program_end; /* magic value ? */
	r300->state.vertex_shader.unknown_ptr3=r300->state.vertex_shader.program_end; /* magic value ? */
	
}


void r300SetupVertexShader(r300ContextPtr rmesa)
{
	GLcontext* ctx = rmesa->radeon.glCtx;

	/* Reset state, in case we don't use something */
	((drm_r300_cmd_header_t*)rmesa->hw.vpp.cmd)->vpu.count = 0;
	((drm_r300_cmd_header_t*)rmesa->hw.vpi.cmd)->vpu.count = 0;
	((drm_r300_cmd_header_t*)rmesa->hw.vps.cmd)->vpu.count = 0;

	/* Not sure why this doesnt work...
	   0x400 area might have something to do with pixel shaders as it appears right after pfs programming.
	   0x406 is set to { 0.0, 0.0, 1.0, 0.0 } most of the time but should change with smooth points and in other rare cases. */
	//setup_vertex_shader_fragment(rmesa, 0x406, &unk4);
	if(hw_tcl_on && ((struct r300_vertex_program *)CURRENT_VERTEX_SHADER(ctx))->translated){
		r300SetupVertexProgram(rmesa);
		return ;
	}

/* This needs to be replaced by vertex shader generation code */

a1710 6
#if 0
	/* textures enabled ? */
	if(rmesa->state.texture.tc_count>0){
		rmesa->state.vertex_shader=SINGLE_TEXTURE_VERTEX_SHADER;
		} else {
		rmesa->state.vertex_shader=FLAT_COLOR_VERTEX_SHADER;
a1711 17
#endif

	r300GenerateSimpleVertexShader(rmesa);

        rmesa->state.vertex_shader.matrix[0].length=16;
        memcpy(rmesa->state.vertex_shader.matrix[0].body.f, ctx->_ModelProjectMatrix.m, 16*4);

	setup_vertex_shader_fragment(rmesa, VSF_DEST_PROGRAM, &(rmesa->state.vertex_shader.program));

	setup_vertex_shader_fragment(rmesa, VSF_DEST_MATRIX0, &(rmesa->state.vertex_shader.matrix[0]));
#if 0
	setup_vertex_shader_fragment(rmesa, VSF_DEST_MATRIX1, &(rmesa->state.vertex_shader.matrix[0]));
	setup_vertex_shader_fragment(rmesa, VSF_DEST_MATRIX2, &(rmesa->state.vertex_shader.matrix[0]));

	setup_vertex_shader_fragment(rmesa, VSF_DEST_VECTOR0, &(rmesa->state.vertex_shader.vector[0]));
	setup_vertex_shader_fragment(rmesa, VSF_DEST_VECTOR1, &(rmesa->state.vertex_shader.vector[1]));
#endif
d1713 3
a1715 4
#if 0
	setup_vertex_shader_fragment(rmesa, VSF_DEST_UNKNOWN1, &(rmesa->state.vertex_shader.unknown1));
	setup_vertex_shader_fragment(rmesa, VSF_DEST_UNKNOWN2, &(rmesa->state.vertex_shader.unknown2));
#endif
d1717 3
a1719 8
	R300_STATECHANGE(rmesa, pvs);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_1]=(rmesa->state.vertex_shader.program_start << R300_PVS_CNTL_1_PROGRAM_START_SHIFT)
		| (rmesa->state.vertex_shader.unknown_ptr1 << R300_PVS_CNTL_1_POS_END_SHIFT)
		| (rmesa->state.vertex_shader.program_end << R300_PVS_CNTL_1_PROGRAM_END_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_2]=(rmesa->state.vertex_shader.param_offset << R300_PVS_CNTL_2_PARAM_OFFSET_SHIFT)
		| (rmesa->state.vertex_shader.param_count << R300_PVS_CNTL_2_PARAM_COUNT_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_3]=(rmesa->state.vertex_shader.unknown_ptr2 << R300_PVS_CNTL_3_PROGRAM_UNKNOWN_SHIFT)
	| (rmesa->state.vertex_shader.unknown_ptr3 << 0);
a1720 6
	/* This is done for vertex shader fragments, but also needs to be done for vap_pvs,
	so I leave it as a reminder */
#if 0
	reg_start(R300_VAP_PVS_WAITIDLE,0);
		e32(0x00000000);
#endif
d1723 1
a1723 1
void r300SetupVertexProgram(r300ContextPtr rmesa)
d1725 1
a1725 1
	GLcontext* ctx = rmesa->radeon.glCtx;
d1728 2
a1729 2
	struct r300_vertex_program *prog=(struct r300_vertex_program *)CURRENT_VERTEX_SHADER(ctx);
			
d1731 1
a1731 1
	((drm_r300_cmd_header_t*)rmesa->hw.vpp.cmd)->vpu.count = 0;
d1733 5
a1737 1
	param_count = r300VertexProgUpdateParams(ctx, prog, (float *)&rmesa->hw.vpp.cmd[R300_VPP_PARAM_0]);
d1740 1
a1740 1
	
d1742 2
a1743 2
	((drm_r300_cmd_header_t*)rmesa->hw.vpi.cmd)->vpu.count = 0;
	((drm_r300_cmd_header_t*)rmesa->hw.vps.cmd)->vpu.count = 0;
d1748 4
a1751 2
	setup_vertex_shader_fragment(rmesa, VSF_DEST_UNKNOWN1, &(rmesa->state.vertex_shader.unknown1));
	setup_vertex_shader_fragment(rmesa, VSF_DEST_UNKNOWN2, &(rmesa->state.vertex_shader.unknown2));
d1754 1
a1754 1
	inst_count=prog->program.length/4 - 1;
d1757 12
a1768 7
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_1]=(0 << R300_PVS_CNTL_1_PROGRAM_START_SHIFT)
		| (inst_count/*pos_end*/ << R300_PVS_CNTL_1_POS_END_SHIFT)
		| (inst_count << R300_PVS_CNTL_1_PROGRAM_END_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_2]=(0 << R300_PVS_CNTL_2_PARAM_OFFSET_SHIFT)
		| (param_count << R300_PVS_CNTL_2_PARAM_COUNT_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_3]=(0/*rmesa->state.vertex_shader.unknown_ptr2*/ << R300_PVS_CNTL_3_PROGRAM_UNKNOWN_SHIFT)
	| (inst_count /*rmesa->state.vertex_shader.unknown_ptr3*/ << 0);
d1771 1
a1771 1
	so I leave it as a reminder */
d1773 2
a1774 2
	reg_start(R300_VAP_PVS_WAITIDLE,0);
		e32(0x00000000);
d1778 8
a1785 1
extern void _tnl_UpdateFixedFunctionProgram( GLcontext *ctx );
d1787 8
a1794 92
extern int future_hw_tcl_on;
void r300UpdateShaders(r300ContextPtr rmesa)
{
	GLcontext *ctx;
	struct r300_vertex_program *vp;
	int i;
	
	ctx = rmesa->radeon.glCtx;
	
	if (rmesa->NewGLState && hw_tcl_on) {
		rmesa->NewGLState = 0;
		
		for (i = _TNL_FIRST_MAT; i <= _TNL_LAST_MAT; i++) {
			rmesa->temp_attrib[i] = TNL_CONTEXT(ctx)->vb.AttribPtr[i];
			TNL_CONTEXT(ctx)->vb.AttribPtr[i] = &rmesa->dummy_attrib[i];
		}
		
		_tnl_UpdateFixedFunctionProgram(ctx);
	
		for (i = _TNL_FIRST_MAT; i <= _TNL_LAST_MAT; i++) {
			TNL_CONTEXT(ctx)->vb.AttribPtr[i] = rmesa->temp_attrib[i];
		}
		
		vp = (struct r300_vertex_program *)CURRENT_VERTEX_SHADER(ctx);
		if (vp->translated == GL_FALSE)
			r300_translate_vertex_shader(vp);
		if (vp->translated == GL_FALSE) {
			fprintf(stderr, "Failing back to sw-tcl\n");
			hw_tcl_on = future_hw_tcl_on = 0;
			r300ResetHwState(rmesa);

			return ;
		}
	}
	
}

void r300UpdateShaderStates(r300ContextPtr rmesa)
{
	GLcontext *ctx;
	ctx = rmesa->radeon.glCtx;
	
#ifdef CB_DPATH
	r300UpdateTextureState(ctx);
#endif

	r300SetupPixelShader(rmesa);
	r300_setup_textures(ctx);
	
	r300SetupVertexShader(rmesa);
	r300_setup_rs_unit(ctx);
}

/* This is probably wrong for some values, I need to test this
 * some more.  Range checking would be a good idea also..
 * 
 * But it works for most things.  I'll fix it later if someone
 * else with a better clue doesn't
 */
static unsigned int r300PackFloat24(float f)
{
	float mantissa;
	int exponent;
	unsigned int float24 = 0;

	if (f == 0.0) return 0;

	mantissa = frexpf(f, &exponent);

	/* Handle -ve */
	if (mantissa < 0) {
		float24 |= (1<<23);
		mantissa = mantissa * -1.0;
	}
	/* Handle exponent, bias of 63 */
	exponent += 62;
	float24 |= (exponent << 16);
	/* Kill 7 LSB of mantissa */
	float24 |= (r300PackFloat32(mantissa) & 0x7FFFFF)  >> 7;

	return float24;
}

void r300SetupPixelShader(r300ContextPtr rmesa)
{
	GLcontext *ctx = rmesa->radeon.glCtx;
	struct r300_fragment_program *rp =
		(struct r300_fragment_program *)
		(char *)ctx->FragmentProgram._Current;
	int i,k;

	if (!rp)	/* should only happenen once, just after context is created */
a1795 5
	
	r300_translate_fragment_shader(rp);
	if (!rp->translated) {
		fprintf(stderr, "%s: No valid fragment shader, exiting\n", __func__);
		exit(-1);
a1796 6
	
#define OUTPUT_FIELD(st, reg, field)  \
		R300_STATECHANGE(rmesa, st); \
		for(i=0;i<=rp->alu_end;i++) \
			rmesa->hw.st.cmd[R300_FPI_INSTR_0+i]=rp->alu.inst[i].field;\
		rmesa->hw.st.cmd[R300_FPI_CMD_0]=cmdpacket0(reg, rp->alu_end+1);
d1798 2
a1799 5
	OUTPUT_FIELD(fpi[0], R300_PFS_INSTR0_0, inst0);
	OUTPUT_FIELD(fpi[1], R300_PFS_INSTR1_0, inst1);
	OUTPUT_FIELD(fpi[2], R300_PFS_INSTR2_0, inst2);
	OUTPUT_FIELD(fpi[3], R300_PFS_INSTR3_0, inst3);
#undef OUTPUT_FIELD
d1801 2
a1802 14
	R300_STATECHANGE(rmesa, fp);
	/* I just want to say, the way these nodes are stored.. weird.. */
	for (i=0,k=(4-(rp->cur_node+1));i<4;i++,k++) {
		if (i<(rp->cur_node+1)) {
			rmesa->hw.fp.cmd[R300_FP_NODE0+k]=
				(rp->node[i].alu_offset << R300_PFS_NODE_ALU_OFFSET_SHIFT)
				| (rp->node[i].alu_end  << R300_PFS_NODE_ALU_END_SHIFT)
				| (rp->node[i].tex_offset << R300_PFS_NODE_TEX_OFFSET_SHIFT)
				| (rp->node[i].tex_end  << R300_PFS_NODE_TEX_END_SHIFT)
				| rp->node[i].flags; /*  ( (k==3) ? R300_PFS_NODE_LAST_NODE : 0); */
		} else {
			rmesa->hw.fp.cmd[R300_FP_NODE0+(3-i)] = 0;
		}
	}
d1804 6
a1809 12
		/*  PFS_CNTL_0 */
	rmesa->hw.fp.cmd[R300_FP_CNTL0]=
		rp->cur_node
		| (rp->first_node_has_tex<<3);
		/* PFS_CNTL_1 */
	rmesa->hw.fp.cmd[R300_FP_CNTL1]=rp->max_temp_idx;
		/* PFS_CNTL_2 */
	rmesa->hw.fp.cmd[R300_FP_CNTL2]=
		(rp->alu_offset << R300_PFS_CNTL_ALU_OFFSET_SHIFT)
		| (rp->alu_end << R300_PFS_CNTL_ALU_END_SHIFT)
		| (rp->tex_offset << R300_PFS_CNTL_TEX_OFFSET_SHIFT)
		| (rp->tex_end << R300_PFS_CNTL_TEX_END_SHIFT);
d1811 17
a1827 9
	R300_STATECHANGE(rmesa, fpp);
	for(i=0;i<rp->const_nr;i++){
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0+4*i+0]=r300PackFloat24(rp->constant[i][0]);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0+4*i+1]=r300PackFloat24(rp->constant[i][1]);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0+4*i+2]=r300PackFloat24(rp->constant[i][2]);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0+4*i+3]=r300PackFloat24(rp->constant[i][3]);
	}
	rmesa->hw.fpp.cmd[R300_FPP_CMD_0]=cmdpacket0(R300_PFS_PARAM_0_X, rp->const_nr*4);
}
d1829 5
a1833 19
/**
 * Called by Mesa after an internal state update.
 */
static void r300InvalidateState(GLcontext * ctx, GLuint new_state)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	
	_swrast_InvalidateState(ctx, new_state);
	_swsetup_InvalidateState(ctx, new_state);
	_ac_InvalidateState(ctx, new_state);
	_tnl_InvalidateState(ctx, new_state);
	_ae_invalidate_state(ctx, new_state);

	if (new_state & (_NEW_BUFFERS | _NEW_COLOR | _NEW_PIXEL)) {
		r300UpdateDrawBuffer(ctx);
	}
#ifndef CB_DPATH
	/* Go inefficiency! */
	r300ResetHwState(r300);
a1834 5
#ifdef HW_VBOS
	if(new_state & _NEW_ARRAY)
		r300->state.VB.lock_uptodate = GL_FALSE;
#endif
	r300->NewGLState |= new_state;
d1840 1
a1840 1
void r300ResetHwState(r300ContextPtr r300)
d1842 5
a1846 1
	GLcontext* ctx = r300->radeon.glCtx;
d1851 3
a1853 17
		/* This is a place to initialize registers which
		   have bitfields accessed by different functions
		   and not all bits are used */
#if 0
	/* initialize similiar to r200 */
	r300->hw.zs.cmd[R300_ZS_CNTL_0] = 0;
	r300->hw.zs.cmd[R300_ZS_CNTL_1] =
	    (R300_ZS_ALWAYS << R300_RB3D_ZS1_FRONT_FUNC_SHIFT) |
	    (R300_ZS_KEEP << R300_RB3D_ZS1_FRONT_FAIL_OP_SHIFT) |
	    (R300_ZS_KEEP << R300_RB3D_ZS1_FRONT_ZPASS_OP_SHIFT) |
	    (R300_ZS_KEEP << R300_RB3D_ZS1_FRONT_ZFAIL_OP_SHIFT) |
	    (R300_ZS_ALWAYS << R300_RB3D_ZS1_BACK_FUNC_SHIFT) |
	    (R300_ZS_KEEP << R300_RB3D_ZS1_BACK_FAIL_OP_SHIFT) |
	    (R300_ZS_KEEP << R300_RB3D_ZS1_BACK_ZPASS_OP_SHIFT) |
	    (R300_ZS_KEEP << R300_RB3D_ZS1_BACK_ZFAIL_OP_SHIFT);
	r300->hw.zs.cmd[R300_ZS_CNTL_2] = 0x00ffff00;
#endif
d1855 1
a1855 1
		/* go and compute register values from GL state */
d1860 3
a1862 4
		ctx->Color.ColorMask[RCOMP],
		ctx->Color.ColorMask[GCOMP],
		ctx->Color.ColorMask[BCOMP],
		ctx->Color.ColorMask[ACOMP]);
d1867 1
a1867 1
	
d1871 5
a1875 2
	r300StencilFuncSeparate(ctx, 0, ctx->Stencil.Function[0], ctx->Stencil.Ref[0], ctx->Stencil.ValueMask[0]);
	r300StencilOpSeparate(ctx, 0, ctx->Stencil.FailFunc[0], ctx->Stencil.ZFailFunc[0], ctx->Stencil.ZPassFunc[0]);
d1881 1
a1881 14
//	r300_setup_routing(ctx, GL_TRUE);
	
#if 0 /* Done in prior to rendering */
	if(hw_tcl_on == GL_FALSE){
		r300EmitArrays(ctx, GL_TRUE); /* Just do the routing */
		r300_setup_textures(ctx);
		r300_setup_rs_unit(ctx);

		r300SetupVertexShader(r300);
		r300SetupPixelShader(r300);
	}
#endif

	r300_set_blend_state(ctx);
a1884 5
		
		/* Initialize magic registers
		 TODO : learn what they really do, or get rid of
		 those we don't have to touch */
	r300->hw.unk2080.cmd[1] = 0x0030045A; //0x0030065a /* Dangerous */
d1886 7
d1894 5
a1898 6
				| R300_VPORT_X_OFFSET_ENA
				| R300_VPORT_Y_SCALE_ENA
				| R300_VPORT_Y_OFFSET_ENA
				| R300_VPORT_Z_SCALE_ENA
				| R300_VPORT_Z_OFFSET_ENA
				| R300_VTX_W0_FMT;
d1903 4
a1906 9
#ifdef MESA_BIG_ENDIAN
	r300->hw.unk2140.cmd[1] = 0x00000002;
#else
	r300->hw.unk2140.cmd[1] = 0x00000000;
#endif

#if 0 /* Done in setup routing */
	((drm_r300_cmd_header_t*)r300->hw.vir[0].cmd)->packet0.count = 1;
	r300->hw.vir[0].cmd[1] = 0x21030003;
d1908 3
a1910 6
	((drm_r300_cmd_header_t*)r300->hw.vir[1].cmd)->packet0.count = 1;
	r300->hw.vir[1].cmd[1] = 0xF688F688;

	r300->hw.vic.cmd[R300_VIR_CNTL_0] = 0x00000001;
	r300->hw.vic.cmd[R300_VIR_CNTL_1] = 0x00000405;
#endif
d1914 1
a1914 1
	r300->hw.unk221C.cmd[1] = R300_221C_NORMAL;
a1926 11
#if 0
	r300->hw.vof.cmd[R300_VOF_CNTL_0] = R300_VAP_OUTPUT_VTX_FMT_0__POS_PRESENT
				| R300_VAP_OUTPUT_VTX_FMT_0__COLOR_PRESENT;
	r300->hw.vof.cmd[R300_VOF_CNTL_1] = 0; /* no textures */


	r300->hw.pvs.cmd[R300_PVS_CNTL_1] = 0;
	r300->hw.pvs.cmd[R300_PVS_CNTL_2] = 0;
	r300->hw.pvs.cmd[R300_PVS_CNTL_3] = 0;
#endif

d1928 2
a1929 2
		| R300_GB_LINE_STUFF_ENABLE
		| R300_GB_TRIANGLE_STUFF_ENABLE /*| R300_GB_UNK31*/;
d1933 5
a1937 5
	if ((r300->radeon.radeonScreen->chip_family == CHIP_FAMILY_R300) || 
	     (r300->radeon.radeonScreen->chip_family == CHIP_FAMILY_R350))
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] = R300_GB_TILE_ENABLE
							| R300_GB_TILE_PIPE_COUNT_R300
							| R300_GB_TILE_SIZE_16;
d1939 3
a1941 3
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] = R300_GB_TILE_ENABLE
							| R300_GB_TILE_PIPE_COUNT_RV410
							| R300_GB_TILE_SIZE_16;
d1943 3
a1945 3
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] = R300_GB_TILE_ENABLE
							| R300_GB_TILE_PIPE_COUNT_R420
							| R300_GB_TILE_SIZE_16;
d1947 3
a1949 3
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] = R300_GB_TILE_ENABLE
							| R300_GB_TILE_PIPE_COUNT_RV300
							| R300_GB_TILE_SIZE_16;
d1952 1
a1952 3
	r300->hw.gb_misc.cmd[R300_GB_MISC_AA_CONFIG] = 0x00000000; /* No antialiasing */

	//r300->hw.txe.cmd[R300_TXE_ENABLE] = 0;
a1961 4
#if 0
	r300->hw.ps.cmd[R300_PS_POINTSIZE] = (6 << R300_POINTSIZE_X_SHIFT) |
					     (6 << R300_POINTSIZE_Y_SHIFT);
#endif
d1973 1
a1973 1
	r300->hw.unk4274.cmd[1] = 0x00000002;
d1975 2
a1976 2
	r300->hw.unk4274.cmd[3] = 0x00000000;
	r300->hw.unk4274.cmd[4] = 0x00000000;
d1980 3
a1982 3
	r300->hw.unk4288.cmd[2] = 0x00000001;
	r300->hw.unk4288.cmd[3] = 0x00000000;
	r300->hw.unk42A0.cmd[1] = 0x00000000;
d1984 2
a1985 1
	r300PolygonOffset(ctx, ctx->Polygon.OffsetFactor, ctx->Polygon.OffsetUnits);
d1987 1
a1987 1
	
a1990 1

a1995 10
#if 0
	r300->hw.fp.cmd[R300_FP_CNTL0] = 0;
	r300->hw.fp.cmd[R300_FP_CNTL1] = 0;
	r300->hw.fp.cmd[R300_FP_CNTL2] = 0;
	r300->hw.fp.cmd[R300_FP_NODE0] = 0;
	r300->hw.fp.cmd[R300_FP_NODE1] = 0;
	r300->hw.fp.cmd[R300_FP_NODE2] = 0;
	r300->hw.fp.cmd[R300_FP_NODE3] = 0;
#endif

a2001 9
#if 0
	for(i = 1; i <= 64; ++i) {
		/* create NOP instructions */
		r300->hw.fpi[0].cmd[i] = FP_INSTRC(MAD, FP_ARGC(SRC0C_XYZ), FP_ARGC(ONE), FP_ARGC(ZERO));
		r300->hw.fpi[1].cmd[i] = FP_SELC(0,XYZ,NO,FP_TMP(0),0,0);
		r300->hw.fpi[2].cmd[i] = FP_INSTRA(MAD, FP_ARGA(SRC0A), FP_ARGA(ONE), FP_ARGA(ZERO));
		r300->hw.fpi[3].cmd[i] = FP_SELA(0,W,NO,FP_TMP(0),0,0);
	}
#endif
d2003 6
a2008 6
	ctx->Driver.Fogfv( ctx, GL_FOG_MODE, NULL );
	ctx->Driver.Fogfv( ctx, GL_FOG_DENSITY, &ctx->Fog.Density );
	ctx->Driver.Fogfv( ctx, GL_FOG_START, &ctx->Fog.Start );
	ctx->Driver.Fogfv( ctx, GL_FOG_END, &ctx->Fog.End );
	ctx->Driver.Fogfv( ctx, GL_FOG_COLOR, ctx->Fog.Color );
	ctx->Driver.Fogfv( ctx, GL_FOG_COORDINATE_SOURCE_EXT, NULL );
d2015 3
a2017 4
#if 0
	r300->hw.bld.cmd[R300_BLD_CBLEND] = 0;
	r300->hw.bld.cmd[R300_BLD_ABLEND] = 0;
#endif
a2018 4
	r300BlendColor(ctx, ctx->Color.BlendColor);
	r300->hw.unk4E10.cmd[2] = 0;
	r300->hw.unk4E10.cmd[3] = 0;
	
d2020 3
a2022 2
	r300->hw.cb.cmd[R300_CB_OFFSET] = r300->radeon.state.color.drawOffset +
		r300->radeon.radeonScreen->fbLocation;
d2024 1
a2024 1
	
d2029 1
a2029 1
	
d2032 1
a2032 1
	
d2050 2
a2051 2
		r300->hw.unk4F10.cmd[1] = R300_DEPTH_FORMAT_16BIT_INT_Z;
	break;
d2053 2
a2054 2
		r300->hw.unk4F10.cmd[1] = R300_DEPTH_FORMAT_24BIT_INT_Z;
	break;
d2058 2
a2059 2
		exit(-1);
			
d2062 4
a2065 4
	//r300->hw.unk4F10.cmd[1] |= R300_DEPTH_FORMAT_UNK32;
	
	r300->hw.unk4F10.cmd[3] = 0x00000003;
	r300->hw.unk4F10.cmd[4] = 0x00000000;
d2068 2
a2069 2
		r300->radeon.radeonScreen->depthOffset +
		r300->radeon.radeonScreen->fbLocation;
d2071 2
a2072 2
	
	if (r300->radeon.sarea->tiling_enabled)	{
d2075 1
a2075 1
	
d2077 2
a2078 1
			r300->hw.zb.cmd[R300_ZB_PITCH] |= R300_DEPTH_MICROTILE_ENABLE;
d2080 1
a2080 1
	
d2090 125
a2214 8
#if 0
	((drm_r300_cmd_header_t*)r300->hw.vpi.cmd)->vpu.count = 0;
	for(i = 1; i < R300_VPI_CMDSIZE; i += 4) {
		/* MOV t0, t0 */
		r300->hw.vpi.cmd[i+0] = VP_OUT(ADD,TMP,0,XYZW);
		r300->hw.vpi.cmd[i+1] = VP_IN(TMP,0);
		r300->hw.vpi.cmd[i+2] = VP_ZERO();
		r300->hw.vpi.cmd[i+3] = VP_ZERO();
d2216 3
d2220 6
a2225 4
	((drm_r300_cmd_header_t*)r300->hw.vpp.cmd)->vpu.count = 0;
	for(i = 1; i < R300_VPP_CMDSIZE; ++i)
		r300->hw.vpp.cmd[i] = 0;
#endif
d2227 2
a2228 4
	r300->hw.vps.cmd[R300_VPS_ZERO_0] = 0;
	r300->hw.vps.cmd[R300_VPS_ZERO_1] = 0;
	r300->hw.vps.cmd[R300_VPS_POINTSIZE] = r300PackFloat32(1.0);
	r300->hw.vps.cmd[R300_VPS_ZERO_3] = 0;
d2230 3
a2232 2
//END: TODO
	r300->hw.all_dirty = GL_TRUE;
d2235 12
d2248 8
d2280 2
d2285 1
a2285 1
		exit(-1);
d2290 1
a2290 1
					 ctx->Visual.depthBits == 24);
d2293 1
a2293 1
	
d2297 1
a2297 1
static void r300RenderMode( GLcontext *ctx, GLenum mode )
d2304 32
d2339 1
a2339 1
void r300InitStateFuncs(struct dd_function_table* functions)
d2371 4
a2374 2
	
   	functions->RenderMode = r300RenderMode;
a2375 1

@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@import MesaLibs version 6.5.2
@
text
@d209 1
a209 1
	if (RGBA_LOGICOP_ENABLED(ctx) || !ctx->Color.BlendEnabled) {
d463 1
a1047 53
static void r300FetchStateParameter(GLcontext *ctx, const enum state_index state[],
                  GLfloat *value)
{
    r300ContextPtr r300 = R300_CONTEXT(ctx);

    switch(state[0])
    {
    case STATE_INTERNAL:
    	switch(state[1])
	{
	case STATE_R300_WINDOW_DIMENSION:
	    value[0] = r300->radeon.dri.drawable->w;	/* width */
    	    value[1] = r300->radeon.dri.drawable->h;	/* height */
	    value[2] = 0.5F; 				/* for moving range [-1 1] -> [0 1] */
    	    value[3] = 1.0F; 				/* not used */
	    break;
	default:;
	}
    default:;
    }
}

/**
 * Update R300's own internal state parameters.
 * For now just STATE_R300_WINDOW_DIMENSION
 */
static void r300UpdateStateParameters(GLcontext * ctx, GLuint new_state)
{
	struct r300_vertex_program_cont *vpc;
	struct gl_program_parameter_list *paramList;
	GLuint i;

	if(!(new_state & (_NEW_BUFFERS|_NEW_PROGRAM)))
	    return;

	vpc = (struct r300_vertex_program_cont *)ctx->VertexProgram._Current;
	if (!vpc)
	    return;

	paramList = vpc->mesa_program.Base.Parameters;

	if (!paramList)
	    return;

	for (i = 0; i < paramList->NumParameters; i++) {
		if (paramList->Parameters[i].Type == PROGRAM_STATE_VAR){
			r300FetchStateParameter(ctx,
				    paramList->Parameters[i].StateIndexes,
				    paramList->ParameterValues[i]);
		}
	}
}

d1289 1
a1289 1
		OutputsWritten.vp_outputs = CURRENT_VERTEX_SHADER(ctx)->key.OutputsWritten;
a1307 14
	if (InputsRead & FRAG_BIT_WPOS){
		for (i = 0; i < ctx->Const.MaxTextureUnits; i++)
			if (!(InputsRead & (FRAG_BIT_TEX0 << i)))
				break;

		if(i == ctx->Const.MaxTextureUnits){
			fprintf(stderr, "\tno free texcoord found...\n");
			exit(0);
		}

		InputsRead |= (FRAG_BIT_TEX0 << i);
		InputsRead &= ~FRAG_BIT_WPOS;
	}
	
d1614 1
a1614 1
	param_count = r300VertexProgUpdateParams(ctx, (struct r300_vertex_program_cont *)ctx->VertexProgram._Current/*prog*/, (float *)&rmesa->hw.vpp.cmd[R300_VPP_PARAM_0]);
a1672 1
		r300_select_vertex_shader(rmesa);
d1674 2
a1675 2
		/*if (vp->translated == GL_FALSE)
			r300_translate_vertex_shader(vp);*/
a1682 1
		r300UpdateStateParameters(ctx, _NEW_PROGRAM);
a1815 3

	r300UpdateStateParameters(ctx, new_state);

d1913 5
a1917 4
	if (_mesa_little_endian())
		r300->hw.unk2140.cmd[1] = 0x00000000;
	else
		r300->hw.unk2140.cmd[1] = 0x00000002;
@


1.1.1.3
log
@Mesa 7.0.1
@
text
@d32 3
a34 4
/**
 * \file
 *
 * \author Nicolai Haehnle <prefect_@@gmx.net>
d49 1
a49 3
#include "shader/prog_parameter.h"
#include "shader/prog_statevars.h"
#include "vbo/vbo.h"
d59 1
d63 1
d72 1
a72 1
	R300_STATECHANGE(rmesa, blend_color);
d79 2
a80 2
	rmesa->hw.blend_color.cmd[1] = PACK_COLOR_8888(color[3], color[0],
						       color[1], color[2]);
d99 2
d103 1
a103 1
		return R300_BLEND_GL_ZERO;
d106 1
a106 1
		return R300_BLEND_GL_ONE;
d109 1
a109 1
		return R300_BLEND_GL_DST_COLOR;
d112 1
a112 1
		return R300_BLEND_GL_ONE_MINUS_DST_COLOR;
d115 1
a115 1
		return R300_BLEND_GL_SRC_COLOR;
d118 1
a118 1
		return R300_BLEND_GL_ONE_MINUS_SRC_COLOR;
d121 1
a121 1
		return R300_BLEND_GL_SRC_ALPHA;
d124 1
a124 1
		return R300_BLEND_GL_ONE_MINUS_SRC_ALPHA;
d127 1
a127 1
		return R300_BLEND_GL_DST_ALPHA;
d130 1
a130 1
		return R300_BLEND_GL_ONE_MINUS_DST_ALPHA;
d133 2
a134 2
		return (is_src) ? R300_BLEND_GL_SRC_ALPHA_SATURATE :
		    R300_BLEND_GL_ZERO;
d137 1
a137 1
		return R300_BLEND_GL_CONST_COLOR;
d140 1
a140 1
		return R300_BLEND_GL_ONE_MINUS_CONST_COLOR;
d143 1
a143 1
		return R300_BLEND_GL_CONST_ALPHA;
d146 1
a146 1
		return R300_BLEND_GL_ONE_MINUS_CONST_ALPHA;
d150 1
a150 2
		return (is_src) ? R300_BLEND_GL_ONE : R300_BLEND_GL_ZERO;
		break;
d152 1
d167 1
a167 2
static void r300SetBlendCntl(r300ContextPtr r300, int func, int eqn,
			     int cbits, int funcA, int eqnA)
d172 1
a172 3
	fprintf(stderr,
		"eqnA=%08x funcA=%08x eqn=%08x func=%08x cbits=%08x\n",
		eqnA, funcA, eqn, func, cbits);
d185 1
a185 1
		new_cblend |= R300_BLEND_NO_SEPARATE;
d190 2
a191 2
	if ((new_ablend != r300->hw.bld.cmd[R300_BLD_ABLEND]) ||
	    (new_cblend != r300->hw.bld.cmd[R300_BLD_CBLEND])) {
d193 2
a194 2
		r300->hw.bld.cmd[R300_BLD_ABLEND] = new_ablend;
		r300->hw.bld.cmd[R300_BLD_CBLEND] = new_cblend;
d198 2
a199 1
static void r300SetBlendState(GLcontext * ctx)
d210 3
a212 1
		r300SetBlendCntl(r300, func, eqn, 0, func, eqn);
d216 2
a217 5
	func =
	    (blend_factor(ctx->Color.BlendSrcRGB, GL_TRUE) <<
	     R300_SRC_BLEND_SHIFT) | (blend_factor(ctx->Color.BlendDstRGB,
						   GL_FALSE) <<
				      R300_DST_BLEND_SHIFT);
d247 1
a247 1
			__FUNCTION__, __LINE__, ctx->Color.BlendEquationRGB);
d251 3
a253 5
	funcA =
	    (blend_factor(ctx->Color.BlendSrcA, GL_TRUE) <<
	     R300_SRC_BLEND_SHIFT) | (blend_factor(ctx->Color.BlendDstA,
						   GL_FALSE) <<
				      R300_DST_BLEND_SHIFT);
d281 2
a282 3
		fprintf(stderr,
			"[%s:%u] Invalid A blend equation (0x%04x).\n",
			__FUNCTION__, __LINE__, ctx->Color.BlendEquationA);
d286 3
a288 3
	r300SetBlendCntl(r300,
			 func, eqn,
			 R300_BLEND_UNKNOWN | R300_BLEND_ENABLE, funcA, eqnA);
d294 1
a294 1
	r300SetBlendState(ctx);
d301 1
a301 1
	r300SetBlendState(ctx);
d307 1
a307 1
static void r300UpdateCulling(GLcontext * ctx)
d315 1
a315 1
			val = R300_CULL_FRONT | R300_CULL_BACK;
d329 1
a329 1
static void r300SetEarlyZState(GLcontext * ctx)
d331 5
a335 5
	/* updates register R300_RB3D_EARLY_Z (0x4F14)
	   if depth test is not enabled it should be R300_EARLY_Z_DISABLE
	   if depth is enabled and alpha not it should be R300_EARLY_Z_ENABLE
	   if depth and alpha is enabled it should be R300_EARLY_Z_DISABLE
	 */
d338 1
a338 1
	R300_STATECHANGE(r300, zstencil_format);
d341 1
a341 1
		r300->hw.zstencil_format.cmd[2] = R300_EARLY_Z_DISABLE;
d345 1
a345 1
			r300->hw.zstencil_format.cmd[2] = R300_EARLY_Z_ENABLE;
d348 1
a348 1
			r300->hw.zstencil_format.cmd[2] = R300_EARLY_Z_DISABLE;
d352 1
a352 1
static void r300SetAlphaState(GLcontext * ctx)
d360 1
a360 1

d384 1
a384 1
		/*pp_misc |= R300_ALPHA_TEST_PASS; */
d388 1
a388 1

d395 2
a396 1

d399 1
a399 2

	r300SetEarlyZState(ctx);
d404 3
a406 3
	(void)func;
	(void)ref;
	r300SetAlphaState(ctx);
d432 1
a432 1
static void r300SetDepthState(GLcontext * ctx)
d438 2
a439 3
	r300->hw.zs.cmd[R300_ZS_CNTL_1] &=
	    ~(R300_ZS_MASK << R300_RB3D_ZS1_DEPTH_FUNC_SHIFT);

d442 1
a442 2
			r300->hw.zs.cmd[R300_ZS_CNTL_0] |=
			    R300_RB3D_Z_TEST_AND_WRITE;
d445 2
a446 4

		r300->hw.zs.cmd[R300_ZS_CNTL_1] |=
		    translate_func(ctx->Depth.
				   Func) << R300_RB3D_ZS1_DEPTH_FUNC_SHIFT;
d449 1
a449 2
		r300->hw.zs.cmd[R300_ZS_CNTL_1] |=
		    translate_func(GL_NEVER) << R300_RB3D_ZS1_DEPTH_FUNC_SHIFT;
d451 2
a452 2

	r300SetEarlyZState(ctx);
d460 1
a460 1
static void r300Enable(GLcontext * ctx, GLenum cap, GLboolean state)
d480 8
a487 8
			r300->hw.fogs.cmd[R300_FOGS_STATE] |= R300_FOG_ENABLE;

			ctx->Driver.Fogfv(ctx, GL_FOG_MODE, NULL);
			ctx->Driver.Fogfv(ctx, GL_FOG_DENSITY,
					  &ctx->Fog.Density);
			ctx->Driver.Fogfv(ctx, GL_FOG_START, &ctx->Fog.Start);
			ctx->Driver.Fogfv(ctx, GL_FOG_END, &ctx->Fog.End);
			ctx->Driver.Fogfv(ctx, GL_FOG_COLOR, ctx->Fog.Color);
d489 2
a490 1
			r300->hw.fogs.cmd[R300_FOGS_STATE] &= ~R300_FOG_ENABLE;
d492 1
a492 1

d496 1
a496 1
		r300SetAlphaState(ctx);
d501 1
a501 1
		r300SetBlendState(ctx);
d505 1
a505 1
		r300SetDepthState(ctx);
d512 1
d522 1
a522 1
#endif
d535 3
a537 3
		R300_STATECHANGE(r300, occlusion_cntl);
		if (state) {
			r300->hw.occlusion_cntl.cmd[1] |= (3 << 0);
d539 1
a539 1
			r300->hw.occlusion_cntl.cmd[1] &= ~(3 << 0);
d548 2
a549 1
static void r300UpdatePolygonMode(GLcontext * ctx)
d552 1
a552 1
	uint32_t hw_mode = 0;
d557 1
a557 1

d571 2
a572 2
			break;
		case GL_POINT:	/* noop */
d574 1
a574 1
			break;
d577 1
a577 1
			break;
d583 2
a584 2
			break;
		case GL_POINT:	/* noop */
d586 1
a586 1
			break;
d589 1
a589 1
			break;
d593 3
a595 3
	if (r300->hw.polygon_mode.cmd[1] != hw_mode) {
		R300_STATECHANGE(r300, polygon_mode);
		r300->hw.polygon_mode.cmd[1] = hw_mode;
d604 1
a604 1
static void r300CullFace(GLcontext * ctx, GLenum mode)
d611 1
d617 1
a617 1
static void r300FrontFace(GLcontext * ctx, GLenum mode)
d625 1
d631 1
a631 1
static void r300DepthFunc(GLcontext * ctx, GLenum func)
d633 2
a634 2
	(void)func;
	r300SetDepthState(ctx);
d637 1
d643 1
a643 1
static void r300DepthMask(GLcontext * ctx, GLboolean mask)
d645 2
a646 2
	(void)mask;
	r300SetDepthState(ctx);
d649 1
d653 1
a653 1
static void r300ColorMask(GLcontext * ctx,
d658 3
a660 2
	    (g ? R300_COLORMASK0_G : 0) |
	    (b ? R300_COLORMASK0_B : 0) | (a ? R300_COLORMASK0_A : 0);
d671 1
a671 1
static void r300Fogfv(GLcontext * ctx, GLenum pname, const GLfloat * param)
d674 4
a677 7
	union {
		int i;
		float f;
	} fogScale, fogStart;

	(void)param;

d689 1
a689 3
			    (r300->hw.fogs.
			     cmd[R300_FOGS_STATE] & ~R300_FOG_MODE_MASK) |
			    R300_FOG_MODE_LINEAR;
d694 4
a697 6
			} else {
				fogScale.f =
				    1.0 / (ctx->Fog.End - ctx->Fog.Start);
				fogStart.f =
				    -ctx->Fog.Start / (ctx->Fog.End -
						       ctx->Fog.Start);
d703 2
a704 4
			    (r300->hw.fogs.
			     cmd[R300_FOGS_STATE] & ~R300_FOG_MODE_MASK) |
			    R300_FOG_MODE_EXP;
			fogScale.f = 0.0933 * ctx->Fog.Density;
d710 2
a711 4
			    (r300->hw.fogs.
			     cmd[R300_FOGS_STATE] & ~R300_FOG_MODE_MASK) |
			    R300_FOG_MODE_EXP2;
			fogScale.f = 0.3 * ctx->Fog.Density;
d720 1
a720 1
			fogScale.f = 0.0933 * ctx->Fog.Density;
d724 1
a724 1
			fogScale.f = 0.3 * ctx->Fog.Density;
d736 4
a739 6
			} else {
				fogScale.f =
				    1.0 / (ctx->Fog.End - ctx->Fog.Start);
				fogStart.f =
				    -ctx->Fog.Start / (ctx->Fog.End -
						       ctx->Fog.Start);
d745 3
a747 6
		r300->hw.fogc.cmd[R300_FOGC_R] =
		    (GLuint) (ctx->Fog.Color[0] * 1023.0F) & 0x3FF;
		r300->hw.fogc.cmd[R300_FOGC_G] =
		    (GLuint) (ctx->Fog.Color[1] * 1023.0F) & 0x3FF;
		r300->hw.fogc.cmd[R300_FOGC_B] =
		    (GLuint) (ctx->Fog.Color[2] * 1023.0F) & 0x3FF;
d773 3
a775 3
	r300->hw.ps.cmd[R300_PS_POINTSIZE] =
	    ((int)(size * 6) << R300_POINTSIZE_X_SHIFT) |
	    ((int)(size * 6) << R300_POINTSIZE_Y_SHIFT);
d781 1
a781 1
static void r300LineWidth(GLcontext * ctx, GLfloat widthf)
d792 1
a792 1
static void r300PolygonMode(GLcontext * ctx, GLenum face, GLenum mode)
d796 1
a796 1

d833 2
a834 2

	R300_STATECHANGE(rmesa, shade);
d837 1
a837 1
		rmesa->hw.shade.cmd[2] = R300_RE_SHADE_MODEL_FLAT;
d840 1
a840 1
		rmesa->hw.shade.cmd[2] = R300_RE_SHADE_MODEL_SMOOTH;
d848 1
a848 1
				    GLenum func, GLint ref, GLuint mask)
d851 3
a853 10
	GLuint refmask =
	    (((ctx->Stencil.
	       Ref[0] & 0xff) << R300_RB3D_ZS2_STENCIL_REF_SHIFT) | ((ctx->
								      Stencil.
								      ValueMask
								      [0] &
								      0xff)
								     <<
								     R300_RB3D_ZS2_STENCIL_MASK_SHIFT));

d858 7
a864 10
	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] &= ~((R300_ZS_MASK <<
					       R300_RB3D_ZS1_FRONT_FUNC_SHIFT)
					      | (R300_ZS_MASK <<
						 R300_RB3D_ZS1_BACK_FUNC_SHIFT));

	rmesa->hw.zs.cmd[R300_ZS_CNTL_2] &=
	    ~((R300_RB3D_ZS2_STENCIL_MASK <<
	       R300_RB3D_ZS2_STENCIL_REF_SHIFT) |
	      (R300_RB3D_ZS2_STENCIL_MASK << R300_RB3D_ZS2_STENCIL_MASK_SHIFT));

a865 5
	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
	    (flag << R300_RB3D_ZS1_FRONT_FUNC_SHIFT);

	if (ctx->Stencil._TestTwoSide)
		flag = translate_func(ctx->Stencil.Function[1]);
d867 2
a868 2
	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
	    (flag << R300_RB3D_ZS1_BACK_FUNC_SHIFT);
d877 2
a878 6
	rmesa->hw.zs.cmd[R300_ZS_CNTL_2] &=
	    ~(R300_RB3D_ZS2_STENCIL_MASK <<
	      R300_RB3D_ZS2_STENCIL_WRITE_MASK_SHIFT);
	rmesa->hw.zs.cmd[R300_ZS_CNTL_2] |=
	    (ctx->Stencil.
	     WriteMask[0] & 0xff) << R300_RB3D_ZS2_STENCIL_WRITE_MASK_SHIFT;
d881 3
a883 2
static void r300StencilOpSeparate(GLcontext * ctx, GLenum face,
				  GLenum fail, GLenum zfail, GLenum zpass)
d888 4
a891 4
	/* It is easier to mask what's left.. */
	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] &=
	    (R300_ZS_MASK << R300_RB3D_ZS1_DEPTH_FUNC_SHIFT) |
	    (R300_ZS_MASK << R300_RB3D_ZS1_FRONT_FUNC_SHIFT) |
d895 6
a900 24
	    (translate_stencil_op(ctx->Stencil.FailFunc[0]) <<
	     R300_RB3D_ZS1_FRONT_FAIL_OP_SHIFT)
	    | (translate_stencil_op(ctx->Stencil.ZFailFunc[0]) <<
	       R300_RB3D_ZS1_FRONT_ZFAIL_OP_SHIFT)
	    | (translate_stencil_op(ctx->Stencil.ZPassFunc[0]) <<
	       R300_RB3D_ZS1_FRONT_ZPASS_OP_SHIFT);

	if (ctx->Stencil._TestTwoSide) {
		rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
		    (translate_stencil_op(ctx->Stencil.FailFunc[1]) <<
		     R300_RB3D_ZS1_BACK_FAIL_OP_SHIFT)
		    | (translate_stencil_op(ctx->Stencil.ZFailFunc[1]) <<
		       R300_RB3D_ZS1_BACK_ZFAIL_OP_SHIFT)
		    | (translate_stencil_op(ctx->Stencil.ZPassFunc[1]) <<
		       R300_RB3D_ZS1_BACK_ZPASS_OP_SHIFT);
	} else {
		rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
		    (translate_stencil_op(ctx->Stencil.FailFunc[0]) <<
		     R300_RB3D_ZS1_BACK_FAIL_OP_SHIFT)
		    | (translate_stencil_op(ctx->Stencil.ZFailFunc[0]) <<
		       R300_RB3D_ZS1_BACK_ZFAIL_OP_SHIFT)
		    | (translate_stencil_op(ctx->Stencil.ZPassFunc[0]) <<
		       R300_RB3D_ZS1_BACK_ZPASS_OP_SHIFT);
	}
d909 2
a910 4
	     (R300_RB3D_ZS2_STENCIL_MASK <<
	      R300_RB3D_ZS2_STENCIL_MASK_SHIFT) | ((ctx->Stencil.
						    WriteMask[0] & 0xff) <<
						   R300_RB3D_ZS2_STENCIL_WRITE_MASK_SHIFT));
d923 1
a923 1
static void r300UpdateWindow(GLcontext * ctx)
d941 1
a941 1
	rmesa->hw.vpt.cmd[R300_VPT_XSCALE] = r300PackFloat32(sx);
d943 1
a943 1
	rmesa->hw.vpt.cmd[R300_VPT_YSCALE] = r300PackFloat32(sy);
d945 1
a945 1
	rmesa->hw.vpt.cmd[R300_VPT_ZSCALE] = r300PackFloat32(sz);
d964 1
a964 1
void r300UpdateViewportOffset(GLcontext * ctx)
d967 3
a969 3
	__DRIdrawablePrivate *dPriv = ((radeonContextPtr) rmesa)->dri.drawable;
	GLfloat xoffset = (GLfloat) dPriv->x;
	GLfloat yoffset = (GLfloat) dPriv->y + dPriv->h;
d973 1
a973 10
	GLfloat ty = (-v[MAT_TY]) + yoffset + SUBPIXEL_Y;

	if (rmesa->hw.vpt.cmd[R300_VPT_XOFFSET] != r300PackFloat32(tx) ||
	    rmesa->hw.vpt.cmd[R300_VPT_YOFFSET] != r300PackFloat32(ty)) {
		/* Note: this should also modify whatever data the context reset
		 * code uses...
		 */
		R300_STATECHANGE(rmesa, vpt);
		rmesa->hw.vpt.cmd[R300_VPT_XOFFSET] = r300PackFloat32(tx);
		rmesa->hw.vpt.cmd[R300_VPT_YOFFSET] = r300PackFloat32(ty);
d975 10
d987 1
a987 1
	radeonUpdateScissor(ctx);
d994 2
a995 1
void r300UpdateDrawBuffer(GLcontext * ctx)
d1004 3
a1006 4
		drb =
		    (driRenderbuffer *) fb->Attachment[BUFFER_FRONT_LEFT].
		    Renderbuffer;
	} else if (fb->_ColorDrawBufferMask[0] == BUFFER_BIT_BACK_LEFT) {
d1008 3
a1010 4
		drb =
		    (driRenderbuffer *) fb->Attachment[BUFFER_BACK_LEFT].
		    Renderbuffer;
	} else {
a1017 5
	R300_STATECHANGE(rmesa, cb);

	r300->hw.cb.cmd[R300_CB_OFFSET] = drb->flippedOffset +	//r300->radeon.state.color.drawOffset +
	    r300->radeon.radeonScreen->fbLocation;
	r300->hw.cb.cmd[R300_CB_PITCH] = drb->flippedPitch;	//r300->radeon.state.color.drawPitch;
d1019 6
d1029 1
a1029 1

d1033 1
a1033 1
	R200_STATECHANGE(rmesa, ctx);
d1037 2
a1038 2
	    = ((drb->flippedOffset + rmesa->r200Screen->fbLocation)
	       & R200_COLOROFFSET_MASK);
d1040 1
a1040 1

d1042 1
a1042 2
		rmesa->hw.ctx.cmd[CTX_RB3D_COLORPITCH] |=
		    R200_COLOR_TILE_ENABLE;
d1047 2
a1048 4
static void
r300FetchStateParameter(GLcontext * ctx,
			const gl_state_index state[STATE_LENGTH],
			GLfloat * value)
d1050 1
a1050 34
	r300ContextPtr r300 = R300_CONTEXT(ctx);

	switch (state[0]) {
	case STATE_INTERNAL:
		switch (state[1]) {
		case STATE_R300_WINDOW_DIMENSION:
			value[0] = r300->radeon.dri.drawable->w * 0.5f;	/* width*0.5 */
			value[1] = r300->radeon.dri.drawable->h * 0.5f;	/* height*0.5 */
			value[2] = 0.5F;	/* for moving range [-1 1] -> [0 1] */
			value[3] = 1.0F;	/* not used */
			break;

		case STATE_R300_TEXRECT_FACTOR:{
				struct gl_texture_object *t =
				    ctx->Texture.Unit[state[2]].CurrentRect;

				if (t && t->Image[0][t->BaseLevel]) {
					struct gl_texture_image *image =
					    t->Image[0][t->BaseLevel];
					value[0] = 1.0 / image->Width2;
					value[1] = 1.0 / image->Height2;
				} else {
					value[0] = 1.0;
					value[1] = 1.0;
				}
				value[2] = 1.0;
				value[3] = 1.0;
				break;
			}

		default:
			break;
		}
		break;
d1052 12
a1063 2
	default:
		break;
d1065 2
d1073 1
a1073 1
void r300UpdateStateParameters(GLcontext * ctx, GLuint new_state)
d1075 1
a1075 1
	struct r300_fragment_program *fp;
d1079 2
a1080 2
	if (!(new_state & (_NEW_BUFFERS | _NEW_PROGRAM)))
		return;
d1082 3
a1084 3
	fp = (struct r300_fragment_program *)ctx->FragmentProgram._Current;
	if (!fp)
		return;
d1086 1
a1086 1
	paramList = fp->mesa_program.Base.Parameters;
d1089 1
a1089 1
		return;
d1092 1
a1092 1
		if (paramList->Parameters[i].Type == PROGRAM_STATE_VAR) {
d1094 2
a1095 3
						paramList->Parameters[i].
						StateIndexes,
						paramList->ParameterValues[i]);
d1107 1
a1107 1

d1111 1
a1111 1
		break;
d1114 1
a1114 1
		break;
d1130 1
d1142 1
a1142 1
	unsigned long mag, min, needs_fixing = 0;
d1146 1
a1146 2
	if ((f & ((7 - 1) << R300_TX_WRAP_S_SHIFT)) ==
	    (R300_TX_CLAMP << R300_TX_WRAP_S_SHIFT)) {
d1149 1
a1149 2
	if ((f & ((7 - 1) << R300_TX_WRAP_T_SHIFT)) ==
	    (R300_TX_CLAMP << R300_TX_WRAP_T_SHIFT)) {
d1152 1
a1152 2
	if ((f & ((7 - 1) << R300_TX_WRAP_Q_SHIFT)) ==
	    (R300_TX_CLAMP << R300_TX_WRAP_Q_SHIFT)) {
d1156 1
a1156 1
	if (!needs_fixing)
d1159 2
a1160 2
	mag = f & R300_TX_MAG_FILTER_MASK;
	min = f & R300_TX_MIN_FILTER_MASK;
d1163 1
a1163 2
	if ((mag != R300_TX_MAG_FILTER_NEAREST)
	    && (min != R300_TX_MIN_FILTER_NEAREST))
d1167 1
a1167 2
	if ((mag == R300_TX_MAG_FILTER_NEAREST)
	    && (min != R300_TX_MIN_FILTER_NEAREST)) {
d1173 1
a1173 2
	if ((min == R300_TX_MIN_FILTER_NEAREST)
	    && (mag != R300_TX_MAG_FILTER_NEAREST)) {
d1180 2
a1181 2
	if (needs_fixing & 1) {
		f &= ~((7 - 1) << R300_TX_WRAP_S_SHIFT);
d1184 2
a1185 2
	if (needs_fixing & 2) {
		f &= ~((7 - 1) << R300_TX_WRAP_T_SHIFT);
d1188 2
a1189 2
	if (needs_fixing & 4) {
		f &= ~((7 - 1) << R300_TX_WRAP_Q_SHIFT);
d1195 1
a1195 1
static void r300SetupTextures(GLcontext * ctx)
d1200 6
a1205 5
	int hw_tmu = 0;
	int last_hw_tmu = -1;	/* -1 translates into no setup costs for fields */
	int tmu_mappings[R300_MAX_TEXTURE_UNITS] = { -1, };
	struct r300_fragment_program *fp = (struct r300_fragment_program *)
	    (char *)ctx->FragmentProgram._Current;
d1209 1
a1209 1
	R300_STATECHANGE(r300, tex.filter_1);
d1214 1
a1214 1
	R300_STATECHANGE(r300, tex.chroma_key);
d1216 2
a1217 2

	r300->hw.txe.cmd[R300_TXE_ENABLE] = 0x0;
d1223 2
a1224 3
	if (mtu > R300_MAX_TEXTURE_UNITS) {
		fprintf(stderr,
			"Aiiee ! mtu=%d is greater than R300_MAX_TEXTURE_UNITS=%d\n",
d1226 1
a1226 1
		_mesa_exit(-1);
d1230 4
a1233 4
	for (i = 0; i < mtu; i++) {
		if (ctx->Texture.Unit[i]._ReallyEnabled) {

#if 0				/* Enables old behaviour */
d1237 5
a1241 10

			t = r300->state.texture.unit[i].texobj;
			/* XXX questionable fix for bug 9170: */
			if (!t)
				continue;

			if ((t->format & 0xffffff00) == 0xffffff00) {
				WARN_ONCE
				    ("unknown texture format (entry %x) encountered. Help me !\n",
				     t->format & 0xff);
d1243 1
a1243 1

d1245 2
a1246 3
				fprintf(stderr,
					"Activating texture unit %d\n", i);

d1248 2
a1249 4

			r300->hw.tex.filter.cmd[R300_TEX_VALUE_0 +
						hw_tmu] =
			    gen_fixed_filter(t->filter) | (hw_tmu << 28);
d1251 7
a1257 11
			r300->hw.tex.filter_1.cmd[R300_TEX_VALUE_0 + hw_tmu] = 0x0;	//0x20501f80;
			r300->hw.tex.size.cmd[R300_TEX_VALUE_0 + hw_tmu] =
			    t->size;
			r300->hw.tex.format.cmd[R300_TEX_VALUE_0 +
						hw_tmu] = t->format;
			r300->hw.tex.pitch.cmd[R300_TEX_VALUE_0 + hw_tmu] =
			    t->pitch_reg;
			r300->hw.tex.offset.cmd[R300_TEX_VALUE_0 +
						hw_tmu] = t->offset;

			if (t->offset & R300_TXO_MACRO_TILE) {
d1260 2
a1261 2

			if (t->offset & R300_TXO_MICRO_TILE) {
d1264 4
a1267 7

			r300->hw.tex.chroma_key.cmd[R300_TEX_VALUE_0 +
						    hw_tmu] = 0x0;
			r300->hw.tex.border_color.cmd[R300_TEX_VALUE_0 +
						      hw_tmu] =
			    t->pp_border_color;

d1269 1
a1269 1

d1273 12
a1284 19

	r300->hw.tex.filter.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(R300_TX_FILTER_0, last_hw_tmu + 1);
	r300->hw.tex.filter_1.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(R300_TX_FILTER1_0, last_hw_tmu + 1);
	r300->hw.tex.size.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(R300_TX_SIZE_0, last_hw_tmu + 1);
	r300->hw.tex.format.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(R300_TX_FORMAT_0, last_hw_tmu + 1);
	r300->hw.tex.pitch.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(R300_TX_PITCH_0, last_hw_tmu + 1);
	r300->hw.tex.offset.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(R300_TX_OFFSET_0, last_hw_tmu + 1);
	r300->hw.tex.chroma_key.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(R300_TX_CHROMA_KEY_0, last_hw_tmu + 1);
	r300->hw.tex.border_color.cmd[R300_TEX_CMD_0] =
	    cmdpacket0(R300_TX_BORDER_COLOR_0, last_hw_tmu + 1);

	if (!fp)		/* should only happenen once, just after context is created */
d1286 1
a1286 1

d1288 2
a1289 2

	for (i = 0; i < fp->tex.length; i++) {
a1290 1
		int opcode;
d1292 2
a1293 2

		unit = fp->tex.inst[i] >> R300_FPITX_IMAGE_SHIFT;
d1295 2
a1296 2

		val = fp->tex.inst[i];
d1298 9
a1306 22

		opcode =
		    (val & R300_FPITX_OPCODE_MASK) >> R300_FPITX_OPCODE_SHIFT;
		if (opcode == R300_FPITX_OP_KIL) {
			r300->hw.fpt.cmd[R300_FPT_INSTR_0 + i] = val;
		} else {
			if (tmu_mappings[unit] >= 0) {
				val |=
				    tmu_mappings[unit] <<
				    R300_FPITX_IMAGE_SHIFT;
				r300->hw.fpt.cmd[R300_FPT_INSTR_0 + i] = val;
			} else {
				// We get here when the corresponding texture image is incomplete
				// (e.g. incomplete mipmaps etc.)
				r300->hw.fpt.cmd[R300_FPT_INSTR_0 + i] = val;
			}
		}
	}

	r300->hw.fpt.cmd[R300_FPT_CMD_0] =
	    cmdpacket0(R300_PFS_TEXI_0, fp->tex.length);

d1308 1
a1308 2
		fprintf(stderr, "TX_ENABLE: %08x  last_hw_tmu=%d\n",
			r300->hw.txe.cmd[R300_TXE_ENABLE], last_hw_tmu);
d1312 2
a1313 2
	GLuint vp_outputs;	/* hw_tcl_on */
	 DECLARE_RENDERINPUTS(index_bitset);	/* !hw_tcl_on */
d1320 1
a1320 1
static void r300SetupRSUnit(GLcontext * ctx)
d1326 3
a1328 3
		R300_RS_INTERP_1_UNKNOWN,
		R300_RS_INTERP_2_UNKNOWN,
		R300_RS_INTERP_3_UNKNOWN,
d1340 2
a1341 3
	if (hw_tcl_on)
		OutputsWritten.vp_outputs =
		    CURRENT_VERTEX_SHADER(ctx)->key.OutputsWritten;
d1343 1
a1343 2
		RENDERINPUTS_COPY(OutputsWritten.index_bitset,
				  r300->state.render_inputs_bitset);
d1349 1
a1349 1
		return;		/* This should only ever happen once.. */
d1355 1
a1355 1

d1359 2
a1360 2

	if (InputsRead & FRAG_BIT_WPOS) {
d1365 1
a1365 1
		if (i == ctx->Const.MaxTextureUnits) {
d1367 1
a1367 1
			_mesa_exit(-1);
d1373 6
a1378 6

	for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
		r300->hw.ri.cmd[R300_RI_INTERP_0 + i] = 0
		    | R300_RS_INTERP_USED
		    | (in_texcoords << R300_RS_INTERP_SRC_SHIFT)
		    | interp_magic[i];
d1381 1
a1381 1
		if (InputsRead & (FRAG_BIT_TEX0 << i)) {
d1383 4
a1386 2
			r300->hw.rr.cmd[R300_RR_ROUTE_0 + fp_reg] |= R300_RS_ROUTE_ENABLE | i	/* source INTERP */
			    | (fp_reg << R300_RS_ROUTE_DEST_SHIFT);
d1389 1
a1389 3
			if (!R300_OUTPUTS_WRITTEN_TEST
			    (OutputsWritten, VERT_RESULT_TEX0 + i,
			     _TNL_ATTRIB_TEX(i))) {
d1391 1
a1391 3
				WARN_ONCE
				    ("fragprog wants coords for tex%d, vp doesn't provide them!\n",
				     i);
d1393 1
a1393 1
				//_mesa_exit(-1);
d1395 1
a1395 1
			InputsRead &= ~(FRAG_BIT_TEX0 << i);
d1397 1
a1397 1
		}
d1399 1
a1399 2
		if (R300_OUTPUTS_WRITTEN_TEST
		    (OutputsWritten, VERT_RESULT_TEX0 + i, _TNL_ATTRIB_TEX(i)))
d1404 3
a1406 5
		if (!R300_OUTPUTS_WRITTEN_TEST
		    (OutputsWritten, VERT_RESULT_COL0, _TNL_ATTRIB_COLOR0)) {
			WARN_ONCE
			    ("fragprog wants col0, vp doesn't provide it\n");
			goto out;	/* FIXME */
d1408 1
a1408 1
			//_mesa_exit(-1);
d1412 2
a1413 2
		    | R300_RS_ROUTE_0_COLOR
		    | (fp_reg++ << R300_RS_ROUTE_0_COLOR_DEST_SHIFT);
d1417 2
a1418 2
      out:

d1420 3
a1422 5
		if (!R300_OUTPUTS_WRITTEN_TEST
		    (OutputsWritten, VERT_RESULT_COL1, _TNL_ATTRIB_COLOR1)) {
			WARN_ONCE
			    ("fragprog wants col1, vp doesn't provide it\n");
			//_mesa_exit(-1);
d1425 3
a1427 3
		r300->hw.rr.cmd[R300_RR_ROUTE_1] |=
		    R300_RS_ROUTE_1_UNKNOWN11 | R300_RS_ROUTE_1_COLOR1 |
		    (fp_reg++ << R300_RS_ROUTE_1_COLOR1_DEST_SHIFT);
d1429 1
a1429 2
		if (high_rr < 1)
			high_rr = 1;
d1432 1
a1432 1

d1436 2
a1437 2
		    | R300_RS_ROUTE_0_COLOR
		    | (fp_reg++ << R300_RS_ROUTE_0_COLOR_DEST_SHIFT);
d1440 5
a1444 4

	r300->hw.rc.cmd[1] = 0 | (in_texcoords << R300_RS_CNTL_TC_CNT_SHIFT)
	    | (col_interp_nr << R300_RS_CNTL_CI_CNT_SHIFT)
	    | R300_RS_CNTL_0_UNKNOWN_18;
d1447 1
a1447 2
	r300->hw.rr.cmd[R300_RR_CMD_0] =
	    cmdpacket0(R300_RS_ROUTE_0, high_rr + 1);
d1451 1
a1451 2
		WARN_ONCE("Don't know how to satisfy InputsRead=0x%08x\n",
			  InputsRead);
d1463 1
a1463 3
void static inline setup_vertex_shader_fragment(r300ContextPtr r300, int dest, struct
						r300_vertex_shader_fragment
						*vsf)
d1467 1
a1467 2
	if (vsf->length == 0)
		return;
d1469 4
a1472 5
	if (vsf->length & 0x3) {
		fprintf(stderr,
			"VERTEX_SHADER_FRAGMENT must have length divisible by 4\n");
		_mesa_exit(-1);
	}
d1474 1
a1474 1
	switch ((dest >> 8) & 0xf) {
d1477 3
a1479 5
		for (i = 0; i < vsf->length; i++)
			r300->hw.vpi.cmd[R300_VPI_INSTR_0 + i +
					 4 * (dest & 0xff)] = (vsf->body.d[i]);
		bump_vpu_count(r300->hw.vpi.cmd,
			       vsf->length + 4 * (dest & 0xff));
d1484 3
a1486 5
		for (i = 0; i < vsf->length; i++)
			r300->hw.vpp.cmd[R300_VPP_PARAM_0 + i +
					 4 * (dest & 0xff)] = (vsf->body.d[i]);
		bump_vpu_count(r300->hw.vpp.cmd,
			       vsf->length + 4 * (dest & 0xff));
d1490 3
a1492 5
		for (i = 0; i < vsf->length; i++)
			r300->hw.vps.cmd[1 + i + 4 * (dest & 0xff)] =
			    (vsf->body.d[i]);
		bump_vpu_count(r300->hw.vps.cmd,
			       vsf->length + 4 * (dest & 0xff));
d1495 2
a1496 4
		fprintf(stderr,
			"%s:%s don't know how to handle dest %04x\n",
			__FILE__, __FUNCTION__, dest);
		_mesa_exit(-1);
d1500 2
d1505 2
a1506 2
   while leaving colors intact. Nothing fancy (like lights)

d1514 21
a1534 14
	r300->state.vap_param.transform_offset = 0x0;	/* transform matrix */
	r300->state.vertex_shader.param_offset = 0x0;
	r300->state.vertex_shader.param_count = 0x4;	/* 4 vector values - 4x4 matrix */

	r300->state.vertex_shader.program_start = 0x0;
	r300->state.vertex_shader.unknown_ptr1 = 0x4;	/* magic value ? */
	r300->state.vertex_shader.program_end = 0x0;

	r300->state.vertex_shader.unknown_ptr2 = 0x0;	/* magic value */
	r300->state.vertex_shader.unknown_ptr3 = 0x4;	/* magic value */

	r300->state.vertex_shader.unknown1.length = 0;
	r300->state.vertex_shader.unknown2.length = 0;

d1537 3
a1539 3
	r300->state.vertex_shader.program.body.i[r300->state.vertex_shader.program_end].src[0]=(source1); \
	r300->state.vertex_shader.program.body.i[r300->state.vertex_shader.program_end].src[1]=(source2); \
	r300->state.vertex_shader.program.body.i[r300->state.vertex_shader.program_end].src[2]=(source3); \
d1543 39
a1581 1
	for (i = VERT_ATTRIB_POS; i < VERT_ATTRIB_MAX; i++)
d1583 18
a1600 6
			WRITE_OP(EASY_VSF_OP(MUL, o_reg++, ALL, RESULT),
				 VSF_REG(r300->state.sw_tcl_inputs[i]),
				 VSF_ATTR_UNITY(r300->state.
						sw_tcl_inputs[i]),
				 VSF_UNITY(r300->state.sw_tcl_inputs[i])
			    )
d1602 27
d1630 3
d1634 2
a1635 3
	r300->state.vertex_shader.program_end--;	/* r300 wants program length to be one more - no idea why */
	r300->state.vertex_shader.program.length =
	    (r300->state.vertex_shader.program_end + 1) * 4;
d1637 1
a1637 3
	r300->state.vertex_shader.unknown_ptr1 = r300->state.vertex_shader.program_end;	/* magic value ? */
	r300->state.vertex_shader.unknown_ptr2 = r300->state.vertex_shader.program_end;	/* magic value ? */
	r300->state.vertex_shader.unknown_ptr3 = r300->state.vertex_shader.program_end;	/* magic value ? */
d1639 29
d1670 1
a1670 1
static void r300SetupVertexProgram(r300ContextPtr rmesa)
d1672 1
a1672 1
	GLcontext *ctx = rmesa->radeon.glCtx;
d1675 2
a1676 2
	struct r300_vertex_program *prog =
	    (struct r300_vertex_program *)CURRENT_VERTEX_SHADER(ctx);
d1678 1
a1678 1
	((drm_r300_cmd_header_t *) rmesa->hw.vpp.cmd)->vpu.count = 0;
d1680 1
a1680 5
	param_count =
	    r300VertexProgUpdateParams(ctx, (struct r300_vertex_program_cont *)
				       ctx->VertexProgram._Current /*prog */ ,
				       (float *)&rmesa->hw.vpp.
				       cmd[R300_VPP_PARAM_0]);
d1683 1
a1683 1

d1685 2
a1686 2
	((drm_r300_cmd_header_t *) rmesa->hw.vpi.cmd)->vpu.count = 0;
	((drm_r300_cmd_header_t *) rmesa->hw.vps.cmd)->vpu.count = 0;
d1691 2
a1692 4
	setup_vertex_shader_fragment(rmesa, VSF_DEST_UNKNOWN1,
				     &(rmesa->state.vertex_shader.unknown1));
	setup_vertex_shader_fragment(rmesa, VSF_DEST_UNKNOWN2,
				     &(rmesa->state.vertex_shader.unknown2));
d1695 1
a1695 1
	inst_count = prog->program.length / 4 - 1;
d1698 7
a1704 12
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_1] =
	    (0 << R300_PVS_CNTL_1_PROGRAM_START_SHIFT)
	    | (inst_count /*pos_end */  << R300_PVS_CNTL_1_POS_END_SHIFT)
	    | (inst_count << R300_PVS_CNTL_1_PROGRAM_END_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_2] =
	    (0 << R300_PVS_CNTL_2_PARAM_OFFSET_SHIFT)
	    | (param_count << R300_PVS_CNTL_2_PARAM_COUNT_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_3] =
	    (0 /*rmesa->state.vertex_shader.unknown_ptr2 */  <<
	     R300_PVS_CNTL_3_PROGRAM_UNKNOWN_SHIFT)
	    | (inst_count /*rmesa->state.vertex_shader.unknown_ptr3 */  <<
	       0);
d1707 1
a1707 1
	   so I leave it as a reminder */
d1709 2
a1710 2
	reg_start(R300_VAP_PVS_WAITIDLE, 0);
	e32(0x00000000);
d1714 88
a1801 1
static void r300SetupVertexShader(r300ContextPtr rmesa)
d1804 4
d1809 20
a1828 4
	/* Reset state, in case we don't use something */
	((drm_r300_cmd_header_t *) rmesa->hw.vpp.cmd)->vpu.count = 0;
	((drm_r300_cmd_header_t *) rmesa->hw.vpi.cmd)->vpu.count = 0;
	((drm_r300_cmd_header_t *) rmesa->hw.vps.cmd)->vpu.count = 0;
d1830 13
a1842 9
	/* Not sure why this doesnt work...
	   0x400 area might have something to do with pixel shaders as it appears right after pfs programming.
	   0x406 is set to { 0.0, 0.0, 1.0, 0.0 } most of the time but should change with smooth points and in other rare cases. */
	//setup_vertex_shader_fragment(rmesa, 0x406, &unk4);
	if (hw_tcl_on
	    && ((struct r300_vertex_program *)CURRENT_VERTEX_SHADER(ctx))->
	    translated) {
		r300SetupVertexProgram(rmesa);
		return;
d1845 12
a1856 2
	/* This needs to be replaced by vertex shader generation code */
	r300GenerateSimpleVertexShader(rmesa);
d1858 9
a1866 2
	setup_vertex_shader_fragment(rmesa, VSF_DEST_PROGRAM,
				     &(rmesa->state.vertex_shader.program));
d1868 16
a1883 6
#if 0
	setup_vertex_shader_fragment(rmesa, VSF_DEST_UNKNOWN1,
				     &(rmesa->state.vertex_shader.unknown1));
	setup_vertex_shader_fragment(rmesa, VSF_DEST_UNKNOWN2,
				     &(rmesa->state.vertex_shader.unknown2));
#endif
d1885 1
a1885 17
	R300_STATECHANGE(rmesa, pvs);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_1] =
	    (rmesa->state.vertex_shader.
	     program_start << R300_PVS_CNTL_1_PROGRAM_START_SHIFT)
	    | (rmesa->state.vertex_shader.
	       unknown_ptr1 << R300_PVS_CNTL_1_POS_END_SHIFT)
	    | (rmesa->state.vertex_shader.
	       program_end << R300_PVS_CNTL_1_PROGRAM_END_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_2] =
	    (rmesa->state.vertex_shader.
	     param_offset << R300_PVS_CNTL_2_PARAM_OFFSET_SHIFT)
	    | (rmesa->state.vertex_shader.
	       param_count << R300_PVS_CNTL_2_PARAM_COUNT_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_3] =
	    (rmesa->state.vertex_shader.
	     unknown_ptr2 << R300_PVS_CNTL_3_PROGRAM_UNKNOWN_SHIFT)
	    | (rmesa->state.vertex_shader.unknown_ptr3 << 0);
d1887 7
a1893 5
	/* This is done for vertex shader fragments, but also needs to be done for vap_pvs,
	   so I leave it as a reminder */
#if 0
	reg_start(R300_VAP_PVS_WAITIDLE, 0);
	e32(0x00000000);
d1895 1
d1901 1
a1901 1
static void r300ResetHwState(r300ContextPtr r300)
d1903 1
a1903 5
	GLcontext *ctx = r300->radeon.glCtx;
	int has_tcl = 1;

	if (!(r300->radeon.radeonScreen->chip_flags & RADEON_CHIPSET_TCL))
		has_tcl = 0;
d1908 17
a1924 3
	/* This is a place to initialize registers which
	   have bitfields accessed by different functions
	   and not all bits are used */
d1926 1
a1926 1
	/* go and compute register values from GL state */
d1931 4
a1934 3
		      ctx->Color.ColorMask[RCOMP],
		      ctx->Color.ColorMask[GCOMP],
		      ctx->Color.ColorMask[BCOMP], ctx->Color.ColorMask[ACOMP]);
d1939 1
a1939 1

d1943 2
a1944 5
	r300StencilFuncSeparate(ctx, 0, ctx->Stencil.Function[0],
				ctx->Stencil.Ref[0], ctx->Stencil.ValueMask[0]);
	r300StencilOpSeparate(ctx, 0, ctx->Stencil.FailFunc[0],
			      ctx->Stencil.ZFailFunc[0],
			      ctx->Stencil.ZPassFunc[0]);
d1950 14
a1963 1
	r300SetBlendState(ctx);
d1967 5
a1972 7
	/* Initialize magic registers
	   TODO : learn what they really do, or get rid of
	   those we don't have to touch */
	if (!has_tcl)
		r300->hw.vap_cntl.cmd[1] = 0x0014045a;
	else
		r300->hw.vap_cntl.cmd[1] = 0x0030045A;	//0x0030065a /* Dangerous */
d1974 6
a1979 5
	    | R300_VPORT_X_OFFSET_ENA
	    | R300_VPORT_Y_SCALE_ENA
	    | R300_VPORT_Y_OFFSET_ENA
	    | R300_VPORT_Z_SCALE_ENA
	    | R300_VPORT_Z_OFFSET_ENA | R300_VTX_W0_FMT;
d1985 1
a1985 1
		r300->hw.vap_cntl_status.cmd[1] = R300_VC_NO_SWAP;
d1987 5
a1991 1
		r300->hw.vap_cntl_status.cmd[1] = R300_VC_32BIT_SWAP;
d1993 6
a1998 3
	/* disable VAP/TCL on non-TCL capable chips */
	if (!has_tcl)
		r300->hw.vap_cntl_status.cmd[1] |= R300_VAP_TCL_BYPASS;
d2015 11
d2027 2
a2028 2
	    | R300_GB_LINE_STUFF_ENABLE
	    | R300_GB_TRIANGLE_STUFF_ENABLE /*| R300_GB_UNK31 */ ;
d2032 5
a2036 5
	if ((r300->radeon.radeonScreen->chip_family == CHIP_FAMILY_R300) ||
	    (r300->radeon.radeonScreen->chip_family == CHIP_FAMILY_R350))
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] =
		    R300_GB_TILE_ENABLE | R300_GB_TILE_PIPE_COUNT_R300 |
		    R300_GB_TILE_SIZE_16;
d2038 3
a2040 3
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] =
		    R300_GB_TILE_ENABLE | R300_GB_TILE_PIPE_COUNT_RV410 |
		    R300_GB_TILE_SIZE_16;
d2042 3
a2044 3
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] =
		    R300_GB_TILE_ENABLE | R300_GB_TILE_PIPE_COUNT_R420 |
		    R300_GB_TILE_SIZE_16;
d2046 3
a2048 3
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] =
		    R300_GB_TILE_ENABLE | R300_GB_TILE_PIPE_COUNT_RV300 |
		    R300_GB_TILE_SIZE_16;
d2051 3
a2053 1
	r300->hw.gb_misc.cmd[R300_GB_MISC_AA_CONFIG] = R300_AA_DISABLE;	/* No antialiasing */
d2063 4
d2078 1
a2078 1
	r300->hw.shade.cmd[1] = 0x00000002;
d2080 2
a2081 2
	r300->hw.shade.cmd[3] = 0x00000000;
	r300->hw.shade.cmd[4] = 0x00000000;
d2085 3
a2087 3
	r300->hw.polygon_mode.cmd[2] = 0x00000001;
	r300->hw.polygon_mode.cmd[3] = 0x00000000;
	r300->hw.zbias_cntl.cmd[1] = 0x00000000;
d2089 1
a2089 2
	r300PolygonOffset(ctx, ctx->Polygon.OffsetFactor,
			  ctx->Polygon.OffsetUnits);
d2091 1
a2091 1

d2095 1
d2101 10
d2117 9
d2127 6
a2132 6
	ctx->Driver.Fogfv(ctx, GL_FOG_MODE, NULL);
	ctx->Driver.Fogfv(ctx, GL_FOG_DENSITY, &ctx->Fog.Density);
	ctx->Driver.Fogfv(ctx, GL_FOG_START, &ctx->Fog.Start);
	ctx->Driver.Fogfv(ctx, GL_FOG_END, &ctx->Fog.End);
	ctx->Driver.Fogfv(ctx, GL_FOG_COLOR, ctx->Fog.Color);
	ctx->Driver.Fogfv(ctx, GL_FOG_COORDINATE_SOURCE_EXT, NULL);
d2139 5
d2145 3
a2147 3
	r300->hw.blend_color.cmd[2] = 0;
	r300->hw.blend_color.cmd[3] = 0;

d2149 2
a2150 3
	r300->hw.cb.cmd[R300_CB_OFFSET] =
	    r300->radeon.state.color.drawOffset +
	    r300->radeon.radeonScreen->fbLocation;
d2152 1
a2152 1

d2157 1
a2157 1

d2160 1
a2160 1

d2178 2
a2179 2
		r300->hw.zstencil_format.cmd[1] = R300_DEPTH_FORMAT_16BIT_INT_Z;
		break;
d2181 2
a2182 2
		r300->hw.zstencil_format.cmd[1] = R300_DEPTH_FORMAT_24BIT_INT_Z;
		break;
d2186 2
a2187 2
		_mesa_exit(-1);

d2190 4
a2193 4
	//r300->hw.zstencil_format.cmd[1] |= R300_DEPTH_FORMAT_UNK32;

	r300->hw.zstencil_format.cmd[3] = 0x00000003;
	r300->hw.zstencil_format.cmd[4] = 0x00000000;
d2196 2
a2197 2
	    r300->radeon.radeonScreen->depthOffset +
	    r300->radeon.radeonScreen->fbLocation;
d2199 2
a2200 2

	if (r300->radeon.sarea->tiling_enabled) {
d2203 1
a2203 1

d2205 1
a2205 2
			r300->hw.zb.cmd[R300_ZB_PITCH] |=
			    R300_DEPTH_MICROTILE_ENABLE;
d2207 1
a2207 1

d2217 8
a2224 5
	if (has_tcl) {
		r300->hw.vps.cmd[R300_VPS_ZERO_0] = 0;
		r300->hw.vps.cmd[R300_VPS_ZERO_1] = 0;
		r300->hw.vps.cmd[R300_VPS_POINTSIZE] = r300PackFloat32(1.0);
		r300->hw.vps.cmd[R300_VPS_ZERO_3] = 0;
a2225 3
//END: TODO
	r300->hw.all_dirty = GL_TRUE;
}
d2227 4
d2232 4
a2235 42
extern void _tnl_UpdateFixedFunctionProgram(GLcontext * ctx);

extern int future_hw_tcl_on;
void r300UpdateShaders(r300ContextPtr rmesa)
{
	GLcontext *ctx;
	struct r300_vertex_program *vp;
	int i;

	ctx = rmesa->radeon.glCtx;

	if (rmesa->NewGLState && hw_tcl_on) {
		rmesa->NewGLState = 0;

		for (i = _TNL_FIRST_MAT; i <= _TNL_LAST_MAT; i++) {
			rmesa->temp_attrib[i] =
			    TNL_CONTEXT(ctx)->vb.AttribPtr[i];
			TNL_CONTEXT(ctx)->vb.AttribPtr[i] =
			    &rmesa->dummy_attrib[i];
		}

		_tnl_UpdateFixedFunctionProgram(ctx);

		for (i = _TNL_FIRST_MAT; i <= _TNL_LAST_MAT; i++) {
			TNL_CONTEXT(ctx)->vb.AttribPtr[i] =
			    rmesa->temp_attrib[i];
		}

		r300SelectVertexShader(rmesa);
		vp = (struct r300_vertex_program *)
		    CURRENT_VERTEX_SHADER(ctx);
		/*if (vp->translated == GL_FALSE)
		   r300TranslateVertexShader(vp); */
		if (vp->translated == GL_FALSE) {
			fprintf(stderr, "Failing back to sw-tcl\n");
			hw_tcl_on = future_hw_tcl_on = 0;
			r300ResetHwState(rmesa);

			return;
		}
		r300UpdateStateParameters(ctx, _NEW_PROGRAM);
	}
d2237 2
a2240 9
static void r300SetupPixelShader(r300ContextPtr rmesa)
{
	GLcontext *ctx = rmesa->radeon.glCtx;
	struct r300_fragment_program *fp = (struct r300_fragment_program *)
	    (char *)ctx->FragmentProgram._Current;
	int i, k;

	if (!fp)		/* should only happenen once, just after context is created */
		return;
a2241 100
	r300TranslateFragmentShader(rmesa, fp);
	if (!fp->translated) {
		fprintf(stderr, "%s: No valid fragment shader, exiting\n",
			__FUNCTION__);
		return;
	}
#define OUTPUT_FIELD(st, reg, field)  \
		R300_STATECHANGE(rmesa, st); \
		for(i=0;i<=fp->alu_end;i++) \
			rmesa->hw.st.cmd[R300_FPI_INSTR_0+i]=fp->alu.inst[i].field;\
		rmesa->hw.st.cmd[R300_FPI_CMD_0]=cmdpacket0(reg, fp->alu_end+1);

	OUTPUT_FIELD(fpi[0], R300_PFS_INSTR0_0, inst0);
	OUTPUT_FIELD(fpi[1], R300_PFS_INSTR1_0, inst1);
	OUTPUT_FIELD(fpi[2], R300_PFS_INSTR2_0, inst2);
	OUTPUT_FIELD(fpi[3], R300_PFS_INSTR3_0, inst3);
#undef OUTPUT_FIELD

	R300_STATECHANGE(rmesa, fp);
	/* I just want to say, the way these nodes are stored.. weird.. */
	for (i = 0, k = (4 - (fp->cur_node + 1)); i < 4; i++, k++) {
		if (i < (fp->cur_node + 1)) {
			rmesa->hw.fp.cmd[R300_FP_NODE0 + k] =
			    (fp->node[i].
			     alu_offset << R300_PFS_NODE_ALU_OFFSET_SHIFT)
			    | (fp->node[i].
			       alu_end << R300_PFS_NODE_ALU_END_SHIFT)
			    | (fp->node[i].
			       tex_offset << R300_PFS_NODE_TEX_OFFSET_SHIFT)
			    | (fp->node[i].
			       tex_end << R300_PFS_NODE_TEX_END_SHIFT)
			    | fp->node[i].flags;	/*  ( (k==3) ? R300_PFS_NODE_LAST_NODE : 0); */
		} else {
			rmesa->hw.fp.cmd[R300_FP_NODE0 + (3 - i)] = 0;
		}
	}

	/*  PFS_CNTL_0 */
	rmesa->hw.fp.cmd[R300_FP_CNTL0] =
	    fp->cur_node | (fp->first_node_has_tex << 3);
	/* PFS_CNTL_1 */
	rmesa->hw.fp.cmd[R300_FP_CNTL1] = fp->max_temp_idx;
	/* PFS_CNTL_2 */
	rmesa->hw.fp.cmd[R300_FP_CNTL2] =
	    (fp->alu_offset << R300_PFS_CNTL_ALU_OFFSET_SHIFT)
	    | (fp->alu_end << R300_PFS_CNTL_ALU_END_SHIFT)
	    | (fp->tex_offset << R300_PFS_CNTL_TEX_OFFSET_SHIFT)
	    | (fp->tex_end << R300_PFS_CNTL_TEX_END_SHIFT);

	R300_STATECHANGE(rmesa, fpp);
	for (i = 0; i < fp->const_nr; i++) {
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 0] =
		    r300PackFloat24(fp->constant[i][0]);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 1] =
		    r300PackFloat24(fp->constant[i][1]);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 2] =
		    r300PackFloat24(fp->constant[i][2]);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 3] =
		    r300PackFloat24(fp->constant[i][3]);
	}
	rmesa->hw.fpp.cmd[R300_FPP_CMD_0] =
	    cmdpacket0(R300_PFS_PARAM_0_X, fp->const_nr * 4);
}

void r300UpdateShaderStates(r300ContextPtr rmesa)
{
	GLcontext *ctx;
	ctx = rmesa->radeon.glCtx;

	r300UpdateTextureState(ctx);

	r300SetupPixelShader(rmesa);
	r300SetupTextures(ctx);

	if ((rmesa->radeon.radeonScreen->chip_flags & RADEON_CHIPSET_TCL))
		r300SetupVertexShader(rmesa);
	r300SetupRSUnit(ctx);
}

/**
 * Called by Mesa after an internal state update.
 */
static void r300InvalidateState(GLcontext * ctx, GLuint new_state)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);

	_swrast_InvalidateState(ctx, new_state);
	_swsetup_InvalidateState(ctx, new_state);
	_vbo_InvalidateState(ctx, new_state);
	_tnl_InvalidateState(ctx, new_state);
	_ae_invalidate_state(ctx, new_state);

	if (new_state & (_NEW_BUFFERS | _NEW_COLOR | _NEW_PIXEL)) {
		r300UpdateDrawBuffer(ctx);
	}

	r300UpdateStateParameters(ctx, new_state);

	r300->NewGLState |= new_state;
}
d2269 1
a2269 1
		_mesa_exit(-1);
d2274 1
a2274 1
					  ctx->Visual.depthBits == 24);
d2277 1
a2277 1

d2281 1
a2281 1
static void r300RenderMode(GLcontext * ctx, GLenum mode)
d2291 1
a2291 1
void r300InitStateFuncs(struct dd_function_table *functions)
d2323 3
a2326 2
	functions->RenderMode = r300RenderMode;
}
@


1.1.1.4
log
@Import Mesa 7.10.3
@
text
@d38 8
a45 10
#include "main/glheader.h"
#include "main/state.h"
#include "main/imports.h"
#include "main/enums.h"
#include "main/macros.h"
#include "main/context.h"
#include "main/dd.h"
#include "main/framebuffer.h"
#include "main/simple_list.h"
#include "main/api_arrayelt.h"
d47 1
a47 1
#include "drivers/common/meta.h"
d50 2
a51 2
#include "program/prog_parameter.h"
#include "program/prog_statevars.h"
d54 1
d56 2
d59 1
d63 2
a64 3
#include "r300_fragprog_common.h"
#include "r300_render.h"
#include "r300_vertprog.h"
d66 3
a68 1
static void r300BlendColor(struct gl_context * ctx, const GLfloat cf[4])
d70 1
d75 4
a78 14
	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
		GLuint r = IROUND(cf[0]*1023.0f);
		GLuint g = IROUND(cf[1]*1023.0f);
		GLuint b = IROUND(cf[2]*1023.0f);
		GLuint a = IROUND(cf[3]*1023.0f);

		rmesa->hw.blend_color.cmd[1] = r | (a << 16);
		rmesa->hw.blend_color.cmd[2] = b | (g << 16);
	} else {
		GLubyte color[4];
		CLAMPED_FLOAT_TO_UBYTE(color[0], cf[0]);
		CLAMPED_FLOAT_TO_UBYTE(color[1], cf[1]);
		CLAMPED_FLOAT_TO_UBYTE(color[2], cf[2]);
		CLAMPED_FLOAT_TO_UBYTE(color[3], cf[3]);
d80 2
a81 3
		rmesa->hw.blend_color.cmd[1] = PACK_COLOR_8888(color[3], color[0],
							color[1], color[2]);
	}
d187 1
a187 1
		new_cblend |= R300_DISCARD_SRC_PIXELS_SRC_ALPHA_0;
d200 1
a200 1
static void r300SetBlendState(struct gl_context * ctx)
d293 1
a293 3
			 (R300_SEPARATE_ALPHA_ENABLE |
			  R300_READ_ENABLE |
			  R300_ALPHA_BLEND_ENABLE), funcA, eqnA);
d296 1
a296 1
static void r300BlendEquationSeparate(struct gl_context * ctx,
d302 1
a302 1
static void r300BlendFuncSeparate(struct gl_context * ctx,
a309 77
 * Translate LogicOp enums into hardware representation.
 * Both use a very logical bit-wise layout, but unfortunately the order
 * of bits is reversed.
 */
static GLuint translate_logicop(GLenum logicop)
{
	GLuint bits = logicop - GL_CLEAR;
	bits = ((bits & 1) << 3) | ((bits & 2) << 1) | ((bits & 4) >> 1) | ((bits & 8) >> 3);
	return bits << R300_RB3D_ROPCNTL_ROP_SHIFT;
}

/**
 * Used internally to update the r300->hw hardware state to match the
 * current OpenGL state.
 */
static void r300SetLogicOpState(struct gl_context *ctx)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	R300_STATECHANGE(r300, rop);
	if (RGBA_LOGICOP_ENABLED(ctx)) {
		r300->hw.rop.cmd[1] = R300_RB3D_ROPCNTL_ROP_ENABLE |
			translate_logicop(ctx->Color.LogicOp);
	} else {
		r300->hw.rop.cmd[1] = 0;
	}
}

/**
 * Called by Mesa when an application program changes the LogicOp state
 * via glLogicOp.
 */
static void r300LogicOpcode(struct gl_context *ctx, GLenum logicop)
{
	if (RGBA_LOGICOP_ENABLED(ctx))
		r300SetLogicOpState(ctx);
}

static void r300ClipPlane( struct gl_context *ctx, GLenum plane, const GLfloat *eq )
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	GLint p;
	GLint *ip;

	/* no VAP UCP on non-TCL chipsets */
	if (!rmesa->options.hw_tcl_enabled)
			return;

	p = (GLint) plane - (GLint) GL_CLIP_PLANE0;
	ip = (GLint *)ctx->Transform._ClipUserPlane[p];

	R300_STATECHANGE( rmesa, vpucp[p] );
	rmesa->hw.vpucp[p].cmd[R300_VPUCP_X] = ip[0];
	rmesa->hw.vpucp[p].cmd[R300_VPUCP_Y] = ip[1];
	rmesa->hw.vpucp[p].cmd[R300_VPUCP_Z] = ip[2];
	rmesa->hw.vpucp[p].cmd[R300_VPUCP_W] = ip[3];
}

static void r300SetClipPlaneState(struct gl_context * ctx, GLenum cap, GLboolean state)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	GLuint p;

	/* no VAP UCP on non-TCL chipsets */
	if (!r300->options.hw_tcl_enabled)
		return;

	p = cap - GL_CLIP_PLANE0;
	R300_STATECHANGE(r300, vap_clip_cntl);
	if (state) {
		r300->hw.vap_clip_cntl.cmd[1] |= (R300_VAP_UCP_ENABLE_0 << p);
		r300ClipPlane(ctx, cap, NULL);
	} else {
		r300->hw.vap_clip_cntl.cmd[1] &= ~(R300_VAP_UCP_ENABLE_0 << p);
	}
}

/**
d312 1
a312 1
static void r300UpdateCulling(struct gl_context * ctx)
d317 1
d319 3
a321 2
		switch (ctx->Polygon.CullFaceMode) {
		case GL_FRONT:
d323 1
a323 2
			break;
		case GL_BACK:
a324 8
			break;
		case GL_FRONT_AND_BACK:
			val = R300_CULL_FRONT | R300_CULL_BACK;
			break;
		default:
			break;
		}
	}
d326 4
a329 9
	switch (ctx->Polygon.FrontFace) {
	case GL_CW:
		val |= R300_FRONT_FACE_CW;
		break;
	case GL_CCW:
		val |= R300_FRONT_FACE_CCW;
		break;
	default:
		break;
a330 6

	/* Winding is inverted when rendering to FBO */
	if (ctx->DrawBuffer && ctx->DrawBuffer->Name)
		val ^= R300_FRONT_FACE_CW;

	R300_STATECHANGE(r300, cul);
d334 1
a334 13
static void r300SetPolygonOffsetState(struct gl_context * ctx, GLboolean state)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);

	R300_STATECHANGE(r300, occlusion_cntl);
	if (state) {
		r300->hw.occlusion_cntl.cmd[1] |= (3 << 0);
	} else {
		r300->hw.occlusion_cntl.cmd[1] &= ~(3 << 0);
	}
}

static GLboolean current_fragment_program_writes_depth(struct gl_context* ctx)
d336 5
d343 1
a343 9
	return ctx->FragmentProgram._Current && r300->selected_fp->code.writes_depth;
}

static void r300SetEarlyZState(struct gl_context * ctx)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	GLuint topZ = R300_ZTOP_ENABLE;
	GLuint w_fmt, fgdepthsrc;

d345 9
a353 35
		topZ = R300_ZTOP_DISABLE;
	else if (current_fragment_program_writes_depth(ctx))
		topZ = R300_ZTOP_DISABLE;
	else if (ctx->FragmentProgram._Current && ctx->FragmentProgram._Current->UsesKill)
		topZ = R300_ZTOP_DISABLE;
	else if (r300->radeon.query.current)
		topZ = R300_ZTOP_DISABLE;

	if (topZ != r300->hw.zstencil_format.cmd[2]) {
		/* Note: This completely reemits the stencil format.
		 * I have not tested whether this is strictly necessary,
		 * or if emitting a write to ZB_ZTOP is enough.
		 */
		R300_STATECHANGE(r300, zstencil_format);
		r300->hw.zstencil_format.cmd[2] = topZ;
	}

	/* w_fmt value is set to get best performance
	* see p.130 R5xx 3D acceleration guide v1.3 */
	if (current_fragment_program_writes_depth(ctx)) {
		fgdepthsrc = R300_FG_DEPTH_SRC_SHADER;
		w_fmt = R300_W_FMT_W24 | R300_W_SRC_US;
	} else {
		fgdepthsrc = R300_FG_DEPTH_SRC_SCAN;
		w_fmt = R300_W_FMT_W0 | R300_W_SRC_US;
	}

	if (w_fmt != r300->hw.us_out_fmt.cmd[5]) {
		R300_STATECHANGE(r300, us_out_fmt);
		r300->hw.us_out_fmt.cmd[5] = w_fmt;
	}

	if (fgdepthsrc != r300->hw.fg_depth_src.cmd[1]) {
		R300_STATECHANGE(r300, fg_depth_src);
		r300->hw.fg_depth_src.cmd[1] = fgdepthsrc;
d357 1
a357 1
static void r300SetAlphaState(struct gl_context * ctx)
d368 1
a368 1
		pp_misc |= R300_FG_ALPHA_FUNC_NEVER;
d371 1
a371 1
		pp_misc |= R300_FG_ALPHA_FUNC_LESS;
d374 1
a374 1
		pp_misc |= R300_FG_ALPHA_FUNC_EQUAL;
d377 1
a377 1
		pp_misc |= R300_FG_ALPHA_FUNC_LE;
d380 1
a380 1
		pp_misc |= R300_FG_ALPHA_FUNC_GREATER;
d383 1
a383 1
		pp_misc |= R300_FG_ALPHA_FUNC_NOTEQUAL;
d386 1
a386 1
		pp_misc |= R300_FG_ALPHA_FUNC_GE;
d389 1
a389 1
		/*pp_misc |= FG_ALPHA_FUNC_ALWAYS; */
d395 2
a396 3
		pp_misc |= R300_FG_ALPHA_FUNC_ENABLE;
		pp_misc |= R500_FG_ALPHA_FUNC_8BIT;
		pp_misc |= (refByte & R300_FG_ALPHA_FUNC_VAL_MASK);
d403 2
a404 1
	r300->hw.at.cmd[R300_AT_UNKNOWN] = 0;
d407 1
a407 1
static void r300AlphaFunc(struct gl_context * ctx, GLenum func, GLfloat ref)
d437 1
a437 1
static void r300SetDepthState(struct gl_context * ctx)
d442 3
a444 4
	r300->hw.zs.cmd[R300_ZS_CNTL_0] &= (R300_STENCIL_ENABLE |
					    R300_STENCIL_FRONT_BACK |
					    R500_STENCIL_REFMASK_FRONT_BACK);
	r300->hw.zs.cmd[R300_ZS_CNTL_1] &= ~(R300_ZS_MASK << R300_Z_FUNC_SHIFT);
d446 1
a446 2
	if (ctx->Depth.Test && ctx->DrawBuffer->_DepthBuffer) {
		r300->hw.zs.cmd[R300_ZS_CNTL_0] |= R300_Z_ENABLE;
d448 5
a452 1
			r300->hw.zs.cmd[R300_ZS_CNTL_0] |= R300_Z_WRITE_ENABLE;
d454 6
a459 1
		    translate_func(ctx->Depth.Func) << R300_Z_FUNC_SHIFT;
d461 2
d465 6
a470 1
static void r300CatchStencilFallback(struct gl_context *ctx)
d472 40
a511 2
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	const unsigned back = ctx->Stencil._BackFace;
d513 3
a515 12
	if (rmesa->radeon.radeonScreen->kernel_mm &&
	    (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515)) {
		r300SwitchFallback(ctx, R300_FALLBACK_STENCIL_TWOSIDE, GL_FALSE);
	} else if (ctx->Stencil._Enabled &&
		   (ctx->Stencil.Ref[0] != ctx->Stencil.Ref[back]
		    || ctx->Stencil.ValueMask[0] != ctx->Stencil.ValueMask[back]
		    || ctx->Stencil.WriteMask[0] != ctx->Stencil.WriteMask[back])) {
		r300SwitchFallback(ctx, R300_FALLBACK_STENCIL_TWOSIDE, GL_TRUE);
	} else {
		r300SwitchFallback(ctx, R300_FALLBACK_STENCIL_TWOSIDE, GL_FALSE);
	}
}
d517 16
a532 4
static void r300SetStencilState(struct gl_context * ctx, GLboolean state)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	GLboolean hw_stencil = GL_FALSE;
d534 3
a536 1
	r300CatchStencilFallback(ctx);
d538 3
a540 5
	if (ctx->DrawBuffer) {
		struct radeon_renderbuffer *rrbStencil
			= radeon_get_renderbuffer(ctx->DrawBuffer, BUFFER_STENCIL);
		hw_stencil = (rrbStencil && rrbStencil->bo);
	}
d542 2
a543 2
	if (hw_stencil) {
		R300_STATECHANGE(r300, zs);
d545 1
a545 2
			r300->hw.zs.cmd[R300_ZS_CNTL_0] |=
			    R300_STENCIL_ENABLE;
d547 1
a547 2
			r300->hw.zs.cmd[R300_ZS_CNTL_0] &=
			    ~R300_STENCIL_ENABLE;
d549 4
d556 1
a556 1
static void r300UpdatePolygonMode(struct gl_context * ctx)
d559 1
a559 1
	uint32_t hw_mode = R300_GA_POLY_MODE_DISABLE;
a560 1
	/* Only do something if a polygon mode is wanted, default is GL_FILL */
a564 3
		/* Handle GL_CW (clock wise and GL_CCW (counter clock wise)
		 * correctly by selecting the correct front and back face
		 */
d573 1
a573 2
		/* Enable polygon mode */
		hw_mode |= R300_GA_POLY_MODE_DUAL;
d577 1
a577 1
			hw_mode |= R300_GA_POLY_MODE_FRONT_PTYPE_LINE;
d579 2
a580 2
		case GL_POINT:
			hw_mode |= R300_GA_POLY_MODE_FRONT_PTYPE_POINT;
d583 1
a583 1
			hw_mode |= R300_GA_POLY_MODE_FRONT_PTYPE_TRI;
d589 1
a589 1
			hw_mode |= R300_GA_POLY_MODE_BACK_PTYPE_LINE;
d591 2
a592 2
		case GL_POINT:
			hw_mode |= R300_GA_POLY_MODE_BACK_PTYPE_POINT;
d595 1
a595 1
			hw_mode |= R300_GA_POLY_MODE_BACK_PTYPE_TRI;
a603 3

	r300->hw.polygon_mode.cmd[2] = 0x00000001;
	r300->hw.polygon_mode.cmd[3] = 0x00000000;
d611 1
a611 1
static void r300CullFace(struct gl_context * ctx, GLenum mode)
d623 1
a623 1
static void r300FrontFace(struct gl_context * ctx, GLenum mode)
d636 1
a636 1
static void r300DepthFunc(struct gl_context * ctx, GLenum func)
d647 1
a647 1
static void r300DepthMask(struct gl_context * ctx, GLboolean mask)
d656 1
a656 1
static void r300ColorMask(struct gl_context * ctx,
d660 3
a662 4
	int mask = (r ? RB3D_COLOR_CHANNEL_MASK_RED_MASK0 : 0) |
	    (g ? RB3D_COLOR_CHANNEL_MASK_GREEN_MASK0 : 0) |
	    (b ? RB3D_COLOR_CHANNEL_MASK_BLUE_MASK0 : 0) |
	    (a ? RB3D_COLOR_CHANNEL_MASK_ALPHA_MASK0 : 0);
d671 1
a671 1
 * Point state
d673 1
a673 1
static void r300PointSize(struct gl_context * ctx, GLfloat size)
d676 4
d681 1
a681 12
	/* We need to clamp to user defined range here, because
	 * the HW clamping happens only for per vertex point size. */
	size = CLAMP(size, ctx->Point.MinSize, ctx->Point.MaxSize);

	/* same size limits for AA, non-AA points */
	size = CLAMP(size, ctx->Const.MinPointSize, ctx->Const.MaxPointSize);

	R300_STATECHANGE(r300, ps);
	r300->hw.ps.cmd[R300_PS_POINTSIZE] =
	    ((int)(size * 6) << R300_POINTSIZE_X_SHIFT) |
	    ((int)(size * 6) << R300_POINTSIZE_Y_SHIFT);
}
d683 2
a684 3
static void r300PointParameter(struct gl_context * ctx, GLenum pname, const GLfloat * param)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
d687 70
a756 12
	case GL_POINT_SIZE_MIN:
		R300_STATECHANGE(r300, ga_point_minmax);
		r300->hw.ga_point_minmax.cmd[1] &= ~R300_GA_POINT_MINMAX_MIN_MASK;
		r300->hw.ga_point_minmax.cmd[1] |= (GLuint)(ctx->Point.MinSize * 6.0);
		r300PointSize(ctx, ctx->Point.Size);
		break;
	case GL_POINT_SIZE_MAX:
		R300_STATECHANGE(r300, ga_point_minmax);
		r300->hw.ga_point_minmax.cmd[1] &= ~R300_GA_POINT_MINMAX_MAX_MASK;
		r300->hw.ga_point_minmax.cmd[1] |= (GLuint)(ctx->Point.MaxSize * 6.0)
			<< R300_GA_POINT_MINMAX_MAX_SHIFT;
		r300PointSize(ctx, ctx->Point.Size);
d758 8
a765 1
	case GL_POINT_DISTANCE_ATTENUATION:
d767 1
a767 1
	case GL_POINT_FADE_THRESHOLD_SIZE:
d770 8
a777 1
		break;
d782 15
d799 1
a799 1
static void r300LineWidth(struct gl_context * ctx, GLfloat widthf)
d803 2
a804 3
	widthf = CLAMP(widthf,
                       ctx->Const.MinPointSize,
                       ctx->Const.MaxPointSize);
d806 2
a807 2
	r300->hw.lcntl.cmd[1] =
	    R300_LINE_CNT_HO | R300_LINE_CNT_VE | (int)(widthf * 6.0);
d810 1
a810 1
static void r300PolygonMode(struct gl_context * ctx, GLenum face, GLenum mode)
d848 1
a848 1
static void r300ShadeModel(struct gl_context * ctx, GLenum mode)
a852 2
	rmesa->hw.shade.cmd[1] = 0x00000002;
	R300_STATECHANGE(rmesa, shade2);
d855 1
a855 1
		rmesa->hw.shade2.cmd[1] = R300_RE_SHADE_MODEL_FLAT;
d858 1
a858 1
		rmesa->hw.shade2.cmd[1] = R300_RE_SHADE_MODEL_SMOOTH;
a862 2
	rmesa->hw.shade2.cmd[2] = 0x00000000;
	rmesa->hw.shade2.cmd[3] = 0x00000000;
d865 1
a865 1
static void r300StencilFuncSeparate(struct gl_context * ctx, GLenum face,
d869 10
a878 1
	GLuint refmask;
a879 1
	const unsigned back = ctx->Stencil._BackFace;
d881 1
a881 4
	r300CatchStencilFallback(ctx);

	refmask = ((ctx->Stencil.Ref[0] & 0xff) << R300_STENCILREF_SHIFT)
	     | ((ctx->Stencil.ValueMask[0] & 0xff) << R300_STENCILMASK_SHIFT);
a882 2
	R300_STATECHANGE(rmesa, zs);
	rmesa->hw.zs.cmd[R300_ZS_CNTL_0] |= R300_STENCIL_FRONT_BACK;
d884 1
a884 1
					       R300_S_FRONT_FUNC_SHIFT)
d886 1
a886 1
						 R300_S_BACK_FUNC_SHIFT));
d889 3
a891 2
	    ~((R300_STENCILREF_MASK << R300_STENCILREF_SHIFT) |
	      (R300_STENCILREF_MASK << R300_STENCILMASK_SHIFT));
d895 1
a895 1
	    (flag << R300_S_FRONT_FUNC_SHIFT);
d897 2
a898 1
	flag = translate_func(ctx->Stencil.Function[back]);
d901 1
a901 1
	    (flag << R300_S_BACK_FUNC_SHIFT);
a902 12

	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
		rmesa->hw.zs.cmd[R300_ZS_CNTL_0] |= R500_STENCIL_REFMASK_FRONT_BACK;
		R300_STATECHANGE(rmesa, zsb);
		refmask = ((ctx->Stencil.Ref[back] & 0xff) << R300_STENCILREF_SHIFT)
			| ((ctx->Stencil.ValueMask[back] & 0xff) << R300_STENCILMASK_SHIFT);

		rmesa->hw.zsb.cmd[R300_ZSB_CNTL_0] &=
			~((R300_STENCILREF_MASK << R300_STENCILREF_SHIFT) |
			  (R300_STENCILREF_MASK << R300_STENCILMASK_SHIFT));
		rmesa->hw.zsb.cmd[R300_ZSB_CNTL_0] |= refmask;
	}
d905 1
a905 1
static void r300StencilMaskSeparate(struct gl_context * ctx, GLenum face, GLuint mask)
a907 3
	const unsigned back = ctx->Stencil._BackFace;

	r300CatchStencilFallback(ctx);
d911 2
a912 2
	    ~(R300_STENCILREF_MASK <<
	      R300_STENCILWRITEMASK_SHIFT);
d915 1
a915 9
	     WriteMask[0] & R300_STENCILREF_MASK) <<
	     R300_STENCILWRITEMASK_SHIFT;
	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
		R300_STATECHANGE(rmesa, zsb);
		rmesa->hw.zsb.cmd[R300_ZSB_CNTL_0] |=
			(ctx->Stencil.
			 WriteMask[back] & R300_STENCILREF_MASK) <<
			R300_STENCILWRITEMASK_SHIFT;
	}
d918 1
a918 1
static void r300StencilOpSeparate(struct gl_context * ctx, GLenum face,
a921 3
	const unsigned back = ctx->Stencil._BackFace;

	r300CatchStencilFallback(ctx);
d926 3
a928 3
	    (R300_ZS_MASK << R300_Z_FUNC_SHIFT) |
	    (R300_ZS_MASK << R300_S_FRONT_FUNC_SHIFT) |
	    (R300_ZS_MASK << R300_S_BACK_FUNC_SHIFT);
d932 1
a932 1
	     R300_S_FRONT_SFAIL_OP_SHIFT)
d934 1
a934 1
	       R300_S_FRONT_ZFAIL_OP_SHIFT)
d936 24
a959 1
	       R300_S_FRONT_ZPASS_OP_SHIFT);
d961 6
a966 7
	rmesa->hw.zs.cmd[R300_ZS_CNTL_1] |=
	    (translate_stencil_op(ctx->Stencil.FailFunc[back]) <<
	     R300_S_BACK_SFAIL_OP_SHIFT)
	    | (translate_stencil_op(ctx->Stencil.ZFailFunc[back]) <<
	       R300_S_BACK_ZFAIL_OP_SHIFT)
	    | (translate_stencil_op(ctx->Stencil.ZPassFunc[back]) <<
	       R300_S_BACK_ZPASS_OP_SHIFT);
d973 7
a979 1
static void r300UpdateWindow(struct gl_context * ctx)
d982 1
a982 1
	__DRIdrawable *dPriv = radeon_get_drawable(&rmesa->radeon);
a985 11
	const GLfloat depthScale = 1.0F / ctx->DrawBuffer->_DepthMaxF;
	const GLboolean render_to_fbo = (ctx->DrawBuffer->Name != 0);
	GLfloat y_scale, y_bias;

	if (render_to_fbo) {
		y_scale = 1.0;
		y_bias = 0;
	} else {
		y_scale = -1.0;
		y_bias = yoffset;
	}
d988 5
a992 5
	GLfloat tx = v[MAT_TX] + xoffset;
	GLfloat sy = v[MAT_SY] * y_scale;
	GLfloat ty = (v[MAT_TY] * y_scale) + y_bias;
	GLfloat sz = v[MAT_SZ] * depthScale;
	GLfloat tz = v[MAT_TZ] * depthScale;
d994 1
d1005 1
a1005 1
static void r300Viewport(struct gl_context * ctx, GLint x, GLint y,
a1012 2

	radeon_viewport(ctx, x, y, width, height);
d1015 1
a1015 1
static void r300DepthRange(struct gl_context * ctx, GLclampd nearval, GLclampd farval)
d1020 1
a1020 1
void r300UpdateViewportOffset(struct gl_context * ctx)
d1023 1
a1023 1
	__DRIdrawable *dPriv = radeon_get_drawable(&rmesa->radeon);
d1028 2
a1029 2
	GLfloat tx = v[MAT_TX] + xoffset;
	GLfloat ty = (-v[MAT_TY]) + yoffset;
d1046 103
d1152 1
a1152 1
static void r300UpdateStateParameters(struct gl_context * ctx, GLuint new_state)
d1154 1
a1154 1
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
d1156 1
d1158 1
a1158 1
	if (!(new_state & (_NEW_BUFFERS | _NEW_PROGRAM | _NEW_PROGRAM_CONSTANTS)))
d1161 2
a1162 1
	if (!ctx->FragmentProgram._Current || !rmesa->selected_fp)
d1165 1
a1165 1
	paramList = ctx->FragmentProgram._Current->Base.Parameters;
d1170 8
a1177 1
	_mesa_load_state_parameters(ctx, paramList);
d1183 1
a1183 1
static void r300PolygonOffset(struct gl_context * ctx, GLfloat factor, GLfloat units)
d1233 2
a1234 2
	if ((f & ((7 - 1) << R300_TX_WRAP_R_SHIFT)) ==
	    (R300_TX_CLAMP << R300_TX_WRAP_R_SHIFT)) {
d1242 1
a1242 1
	min = f & (R300_TX_MIN_FILTER_MASK|R300_TX_MIN_FILTER_MIP_MASK);
d1274 2
a1275 2
		f &= ~((7 - 1) << R300_TX_WRAP_R_SHIFT);
		f |= R300_TX_CLAMP_TO_EDGE << R300_TX_WRAP_R_SHIFT;
d1280 1
a1280 1
static void r300SetupFragmentShaderTextures(struct gl_context *ctx, int *tmu_mappings)
d1282 2
d1285 2
a1286 91
	int i;
	struct r300_fragment_program_code *code = &r300->selected_fp->code.code.r300;

	R300_STATECHANGE(r300, fpt);

	for (i = 0; i < code->tex.length; i++) {
		int unit;
		int opcode;
		unsigned long val;

		unit = code->tex.inst[i] >> R300_TEX_ID_SHIFT;
		unit &= 15;

		val = code->tex.inst[i];
		val &= ~R300_TEX_ID_MASK;

		opcode =
			(val & R300_TEX_INST_MASK) >> R300_TEX_INST_SHIFT;
		if (opcode == R300_TEX_OP_KIL) {
			r300->hw.fpt.cmd[R300_FPT_INSTR_0 + i] = val;
		} else {
			if (tmu_mappings[unit] >= 0) {
				val |=
					tmu_mappings[unit] <<
					R300_TEX_ID_SHIFT;
				r300->hw.fpt.cmd[R300_FPT_INSTR_0 + i] = val;
			} else {
				// We get here when the corresponding texture image is incomplete
				// (e.g. incomplete mipmaps etc.)
				r300->hw.fpt.cmd[R300_FPT_INSTR_0 + i] = val;
			}
		}
	}

	r300->hw.fpt.cmd[R300_FPT_CMD_0] =
		cmdpacket0(r300->radeon.radeonScreen,
                   R300_US_TEX_INST_0, code->tex.length);
}

static void r500SetupFragmentShaderTextures(struct gl_context *ctx, int *tmu_mappings)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	int i;
	struct r500_fragment_program_code *code = &r300->selected_fp->code.code.r500;

	/* find all the texture instructions and relocate the texture units */
	for (i = 0; i < code->inst_end + 1; i++) {
		if ((code->inst[i].inst0 & 0x3) == R500_INST_TYPE_TEX) {
			uint32_t val;
			int unit, opcode, new_unit;

			val = code->inst[i].inst1;

			unit = (val >> 16) & 0xf;

			val &= ~(0xf << 16);

			opcode = val & (0x7 << 22);
			if (opcode == R500_TEX_INST_TEXKILL) {
				new_unit = 0;
			} else {
				if (tmu_mappings[unit] >= 0) {
					new_unit = tmu_mappings[unit];
				} else {
					new_unit = 0;
				}
			}
			val |= R500_TEX_ID(new_unit);
			code->inst[i].inst1 = val;
		}
	}
}

static GLuint translate_lod_bias(GLfloat bias)
{
	GLint b = (int)(bias*32);
	if (b >= (1 << 9))
		b = (1 << 9)-1;
	else if (b < -(1 << 9))
		b = -(1 << 9);
	return (((GLuint)b) << R300_LOD_BIAS_SHIFT) & R300_LOD_BIAS_MASK;
}


static void r300SetupTextures(struct gl_context * ctx)
{
	int i, mtu;
	struct radeon_tex_obj *t;
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	int hw_tmu = 0;
	int last_hw_tmu = -1;	/* -1 translates into no setup costs for fields */
d1288 2
d1304 1
a1304 1
	if (RADEON_DEBUG & RADEON_STATE)
d1311 1
a1311 1
		exit(-1);
d1317 4
d1323 2
a1324 1
			t = radeon_tex_obj(ctx->Texture.Unit[i]._Current);
d1328 1
a1328 1
			if ((t->pp_txformat & 0xffffff00) == 0xffffff00) {
d1331 1
a1331 1
				     t->pp_txformat & 0xff);
d1334 1
a1334 1
			if (RADEON_DEBUG & RADEON_STATE)
d1342 3
a1344 9
			    gen_fixed_filter(t->pp_txfilter) | (hw_tmu << 28);
			/* Note: There is a LOD bias per texture unit and a LOD bias
			 * per texture object. We add them here to get the correct behaviour.
			 * (The per-texture object LOD bias was introduced in OpenGL 1.4
			 * and is not present in the EXT_texture_object extension).
			 */
			r300->hw.tex.filter_1.cmd[R300_TEX_VALUE_0 + hw_tmu] =
				t->pp_txfilter_1 |
				translate_lod_bias(ctx->Texture.Unit[i].LodBias + t->base.LodBias);
d1346 1
a1346 1
			    t->pp_txsize;
d1348 1
a1348 1
						hw_tmu] = t->pp_txformat;
d1350 3
a1352 2
			  t->pp_txpitch;
			r300->hw.textures[hw_tmu] = t;
d1354 1
a1354 1
			if (t->tile_bits & R300_TXO_MACRO_TILE) {
d1358 1
a1358 1
			if (t->tile_bits & R300_TXO_MICRO_TILE) {
a1373 22
	/* R3xx and R4xx chips require that the texture unit corresponding to
	 * KIL instructions is really enabled.
	 *
	 * We do some fakery here and in the state atom emit logic to enable
	 * the texture without tripping up the CS checker in the kernel.
	 */
	if (r300->radeon.radeonScreen->chip_family < CHIP_FAMILY_RV515) {
		if (ctx->FragmentProgram._Current->UsesKill && last_hw_tmu < 0) {
			last_hw_tmu++;

			r300->hw.txe.cmd[R300_TXE_ENABLE] |= 1;

			r300->hw.tex.border_color.cmd[R300_TEX_VALUE_0] = 0;
			r300->hw.tex.chroma_key.cmd[R300_TEX_VALUE_0] = 0;
			r300->hw.tex.filter.cmd[R300_TEX_VALUE_0] = 0;
			r300->hw.tex.filter_1.cmd[R300_TEX_VALUE_0] = 0;
			r300->hw.tex.size.cmd[R300_TEX_VALUE_0] = 0; /* 1x1 texture */
			r300->hw.tex.format.cmd[R300_TEX_VALUE_0] = 0; /* A8 format */
			r300->hw.tex.pitch.cmd[R300_TEX_VALUE_0] = 0;
		}
	}

d1375 1
a1375 1
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_FILTER0_0, last_hw_tmu + 1);
d1377 1
a1377 1
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_FILTER1_0, last_hw_tmu + 1);
d1379 1
a1379 1
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_SIZE_0, last_hw_tmu + 1);
d1381 1
a1381 1
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_FORMAT_0, last_hw_tmu + 1);
d1383 1
a1383 1
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_FORMAT2_0, last_hw_tmu + 1);
d1385 1
a1385 1
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_OFFSET_0, last_hw_tmu + 1);
d1387 1
a1387 1
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_CHROMA_KEY_0, last_hw_tmu + 1);
d1389 1
a1389 1
	    cmdpacket0(r300->radeon.radeonScreen, R300_TX_BORDER_COLOR_0, last_hw_tmu + 1);
d1391 4
a1394 1
	r300->vtbl.SetupFragmentShaderTextures(ctx, tmu_mappings);
d1396 33
a1428 1
	if (RADEON_DEBUG & RADEON_STATE)
d1442 1
a1442 1
static void r300SetupRSUnit(struct gl_context * ctx)
d1445 11
d1459 2
a1460 5
	int col_ip, tex_ip;
	int rs_tex_count = 0;
	int i, col_fmt, hw_tcl_on;

	hw_tcl_on = r300->options.hw_tcl_enabled;
d1463 2
a1464 1
		OutputsWritten.vp_outputs = r300->selected_vp->code.OutputsWritten;
d1466 2
a1467 1
		RENDERINPUTS_COPY(OutputsWritten.index_bitset, r300->render_inputs_bitset);
d1469 6
a1474 1
	InputsRead = r300->selected_fp->InputsRead;
d1480 1
a1480 1
	fp_reg = col_ip = tex_ip = col_fmt = 0;
d1482 1
a1482 4
	r300->hw.rc.cmd[1] = 0;
	r300->hw.rc.cmd[2] = 0;
	for (i=0; i<R300_RR_CMDSIZE-1; ++i)
		r300->hw.rr.cmd[R300_RR_INST_0 + i] = 0;
d1484 4
a1487 2
	for (i=0; i<R300_RI_CMDSIZE-1; ++i)
		r300->hw.ri.cmd[R300_RI_INTERP_0 + i] = 0;
d1489 3
a1491 10

	if (InputsRead & FRAG_BIT_COL0) {
		if (R300_OUTPUTS_WRITTEN_TEST(OutputsWritten, VERT_RESULT_COL0, _TNL_ATTRIB_COLOR0)) {
			r300->hw.ri.cmd[R300_RI_INTERP_0 + col_ip] = R300_RS_COL_PTR(col_ip) | R300_RS_COL_FMT(R300_RS_COL_FMT_RGBA);
			r300->hw.rr.cmd[R300_RR_INST_0 + col_ip] = R300_RS_INST_COL_ID(col_ip) | R300_RS_INST_COL_CN_WRITE | R300_RS_INST_COL_ADDR(fp_reg);
			InputsRead &= ~FRAG_BIT_COL0;
			++col_ip;
			++fp_reg;
		} else {
			WARN_ONCE("fragprog wants col0, vp doesn't provide it\n");
a1492 1
	}
d1494 2
a1495 10
	if (InputsRead & FRAG_BIT_COL1) {
		if (R300_OUTPUTS_WRITTEN_TEST(OutputsWritten, VERT_RESULT_COL1, _TNL_ATTRIB_COLOR1)) {
			r300->hw.ri.cmd[R300_RI_INTERP_0 + col_ip] = R300_RS_COL_PTR(col_ip) | R300_RS_COL_FMT(R300_RS_COL_FMT_RGBA);
			r300->hw.rr.cmd[R300_RR_INST_0 + col_ip] = R300_RS_INST_COL_ID(col_ip) | R300_RS_INST_COL_CN_WRITE | R300_RS_INST_COL_ADDR(fp_reg);
			InputsRead &= ~FRAG_BIT_COL1;
			++col_ip;
			++fp_reg;
		} else {
			WARN_ONCE("fragprog wants col1, vp doesn't provide it\n");
		}
a1497 1
	/* We always route 4 texcoord components */
d1499 24
a1522 6
		if (! ( InputsRead & FRAG_BIT_TEX(i) ) )
		    continue;

		if (!R300_OUTPUTS_WRITTEN_TEST(OutputsWritten, VERT_RESULT_TEX0 + i, _TNL_ATTRIB_TEX(i))) {
		    WARN_ONCE("fragprog wants coords for tex%d, vp doesn't provide them!\n", i);
		    continue;
d1524 4
a1527 7

		r300->hw.ri.cmd[R300_RI_INTERP_0 + tex_ip] |= R300_RS_SEL_S(0) | R300_RS_SEL_T(1) | R300_RS_SEL_R(2) | R300_RS_SEL_Q(3) | R300_RS_TEX_PTR(rs_tex_count);
		r300->hw.rr.cmd[R300_RR_INST_0 + tex_ip] |= R300_RS_INST_TEX_ID(tex_ip) | R300_RS_INST_TEX_CN_WRITE | R300_RS_INST_TEX_ADDR(fp_reg);
		InputsRead &= ~(FRAG_BIT_TEX0 << i);
		rs_tex_count += 4;
		++tex_ip;
		++fp_reg;
d1530 15
a1544 5
	/* Setup default color if no color or tex was set */
	if (rs_tex_count == 0 && col_ip == 0) {
		r300->hw.rr.cmd[R300_RR_INST_0] = R300_RS_INST_COL_ID(0) | R300_RS_INST_COL_ADDR(0);
		r300->hw.ri.cmd[R300_RI_INTERP_0] = R300_RS_COL_PTR(0) | R300_RS_COL_FMT(R300_RS_COL_FMT_0001);
		++col_ip;
d1546 1
d1548 33
a1580 6
	high_rr = (col_ip > tex_ip) ? col_ip : tex_ip;
	r300->hw.rc.cmd[1] |= (rs_tex_count << R300_IT_COUNT_SHIFT) | (col_ip << R300_IC_COUNT_SHIFT) | R300_HIRES_EN;
	r300->hw.rc.cmd[2] |= high_rr - 1;

	r300->hw.rr.cmd[R300_RR_CMD_0] = cmdpacket0(r300->radeon.radeonScreen, R300_RS_INST_0, high_rr);
	r300->hw.ri.cmd[R300_RI_CMD_0] = cmdpacket0(r300->radeon.radeonScreen, R300_RS_IP_0, high_rr);
d1583 2
a1584 1
		WARN_ONCE("Don't know how to satisfy InputsRead=0x%08x\n", InputsRead);
d1587 12
a1598 1
static void r500SetupRSUnit(struct gl_context * ctx)
d1600 20
a1619 7
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	union r300_outputs_written OutputsWritten;
	GLuint InputsRead;
	int fp_reg, high_rr;
	int col_ip, tex_ip;
	int rs_tex_count = 0;
	int i, col_fmt, hw_tcl_on;
d1621 23
a1643 1
	hw_tcl_on = r300->options.hw_tcl_enabled;
d1645 1
a1645 4
	if (hw_tcl_on)
		OutputsWritten.vp_outputs = r300->selected_vp->code.OutputsWritten;
	else
		RENDERINPUTS_COPY(OutputsWritten.index_bitset, r300->render_inputs_bitset);
d1647 2
a1648 1
	InputsRead = r300->selected_fp->InputsRead;
d1650 5
a1654 3
	R300_STATECHANGE(r300, ri);
	R300_STATECHANGE(r300, rc);
	R300_STATECHANGE(r300, rr);
d1656 4
a1659 1
	fp_reg = col_ip = tex_ip = col_fmt = 0;
d1661 3
a1663 4
	r300->hw.rc.cmd[1] = 0;
	r300->hw.rc.cmd[2] = 0;
	for (i=0; i<R300_RR_CMDSIZE-1; ++i)
		r300->hw.rr.cmd[R300_RR_INST_0 + i] = 0;
d1665 2
a1666 2
	for (i=0; i<R500_RI_CMDSIZE-1; ++i)
		r300->hw.ri.cmd[R300_RI_INTERP_0 + i] = 0;
d1668 2
d1671 6
a1676 10
	if (InputsRead & FRAG_BIT_COL0) {
		if (R300_OUTPUTS_WRITTEN_TEST(OutputsWritten, VERT_RESULT_COL0, _TNL_ATTRIB_COLOR0)) {
			r300->hw.ri.cmd[R300_RI_INTERP_0 + col_ip] = R500_RS_COL_PTR(col_ip) | R500_RS_COL_FMT(R300_RS_COL_FMT_RGBA);
			r300->hw.rr.cmd[R300_RR_INST_0 + col_ip] = R500_RS_INST_COL_ID(col_ip) | R500_RS_INST_COL_CN_WRITE | R500_RS_INST_COL_ADDR(fp_reg);
			InputsRead &= ~FRAG_BIT_COL0;
			++col_ip;
			++fp_reg;
		} else {
			WARN_ONCE("fragprog wants col0, vp doesn't provide it\n");
		}
d1679 9
a1687 9
	if (InputsRead & FRAG_BIT_COL1) {
		if (R300_OUTPUTS_WRITTEN_TEST(OutputsWritten, VERT_RESULT_COL1, _TNL_ATTRIB_COLOR1)) {
			r300->hw.ri.cmd[R300_RI_INTERP_0 + col_ip] = R500_RS_COL_PTR(col_ip) | R500_RS_COL_FMT(R300_RS_COL_FMT_RGBA);
			r300->hw.rr.cmd[R300_RR_INST_0 + col_ip] = R500_RS_INST_COL_ID(col_ip) | R500_RS_INST_COL_CN_WRITE | R500_RS_INST_COL_ADDR(fp_reg);
			InputsRead &= ~FRAG_BIT_COL1;
			++col_ip;
			++fp_reg;
		} else {
			WARN_ONCE("fragprog wants col1, vp doesn't provide it\n");
a1688 1
	}
d1690 3
a1692 4
	/* We always route 4 texcoord components */
	for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
		if (! ( InputsRead & FRAG_BIT_TEX(i) ) )
		    continue;
d1694 3
a1696 4
		if (!R300_OUTPUTS_WRITTEN_TEST(OutputsWritten, VERT_RESULT_TEX0 + i, _TNL_ATTRIB_TEX(i))) {
		    WARN_ONCE("fragprog wants coords for tex%d, vp doesn't provide them!\n", i);
		    continue;
		}
d1698 1
a1698 4
		r300->hw.ri.cmd[R300_RI_INTERP_0 + tex_ip] |= ((rs_tex_count + 0) << R500_RS_IP_TEX_PTR_S_SHIFT) |
			((rs_tex_count + 1) << R500_RS_IP_TEX_PTR_T_SHIFT) |
			((rs_tex_count + 2) << R500_RS_IP_TEX_PTR_R_SHIFT) |
			((rs_tex_count + 3) << R500_RS_IP_TEX_PTR_Q_SHIFT);
d1700 7
a1706 6
		r300->hw.rr.cmd[R300_RR_INST_0 + tex_ip] |= R500_RS_INST_TEX_ID(tex_ip) | R500_RS_INST_TEX_CN_WRITE | R500_RS_INST_TEX_ADDR(fp_reg);
		InputsRead &= ~(FRAG_BIT_TEX0 << i);
		rs_tex_count += 4;
		++tex_ip;
		++fp_reg;
	}
d1708 9
a1716 6
	/* Setup default color if no color or tex was set */
	if (rs_tex_count == 0 && col_ip == 0) {
		r300->hw.rr.cmd[R300_RR_INST_0] = R500_RS_INST_COL_ID(0) | R500_RS_INST_COL_ADDR(0);
		r300->hw.ri.cmd[R300_RI_INTERP_0] = R500_RS_COL_PTR(0) | R500_RS_COL_FMT(R300_RS_COL_FMT_0001);
		++col_ip;
	}
d1718 3
a1720 3
	high_rr = (col_ip > tex_ip) ? col_ip : tex_ip;
	r300->hw.rc.cmd[1] = (rs_tex_count << R300_IT_COUNT_SHIFT) | (col_ip << R300_IC_COUNT_SHIFT) | R300_HIRES_EN;
	r300->hw.rc.cmd[2] = 0xC0 | (high_rr - 1);
d1722 1
a1722 2
	r300->hw.rr.cmd[R300_RR_CMD_0] = cmdpacket0(r300->radeon.radeonScreen, R500_RS_INST_0, high_rr);
	r300->hw.ri.cmd[R300_RI_CMD_0] = cmdpacket0(r300->radeon.radeonScreen, R500_RS_IP_0, high_rr);
d1724 6
a1729 3
	if (InputsRead)
		WARN_ONCE("Don't know how to satisfy InputsRead=0x%08x\n", InputsRead);
}
d1731 1
a1731 1
#define MIN3(a, b, c)	((a) < (b) ? MIN2(a, c) : MIN2(b, c))
d1733 13
a1745 52
void r300VapCntl(r300ContextPtr rmesa, GLuint input_count,
			GLuint output_count, GLuint temp_count)
{
    int vtx_mem_size;
    int pvs_num_slots;
    int pvs_num_cntrls;

    /* Flush PVS engine before changing PVS_NUM_SLOTS, PVS_NUM_CNTRLS.
     * See r500 docs 6.5.2 - done in emit */

    /* avoid division by zero */
    if (input_count == 0) input_count = 1;
    if (output_count == 0) output_count = 1;
    if (temp_count == 0) temp_count = 1;

    if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515)
	vtx_mem_size = 128;
    else
	vtx_mem_size = 72;

    pvs_num_slots = MIN3(10, vtx_mem_size/input_count, vtx_mem_size/output_count);
    pvs_num_cntrls = MIN2(6, vtx_mem_size/temp_count);

    R300_STATECHANGE(rmesa, vap_cntl);
    if (rmesa->options.hw_tcl_enabled) {
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] =
	    (pvs_num_slots << R300_PVS_NUM_SLOTS_SHIFT) |
	    (pvs_num_cntrls << R300_PVS_NUM_CNTLRS_SHIFT) |
	    (12 << R300_VF_MAX_VTX_NUM_SHIFT);
	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515)
	    rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] |= R500_TCL_STATE_OPTIMIZATION;
    } else
	/* not sure about non-tcl */
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] = ((10 << R300_PVS_NUM_SLOTS_SHIFT) |
				    (5 << R300_PVS_NUM_CNTLRS_SHIFT) |
				    (5 << R300_VF_MAX_VTX_NUM_SHIFT));

    if ((rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_R300) ||
	(rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_R350))
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] |= (4 << R300_PVS_NUM_FPUS_SHIFT);
    else if (rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_RV530)
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] |= (5 << R300_PVS_NUM_FPUS_SHIFT);
    else if ((rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_RV410) ||
	     (rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_R420))
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] |= (6 << R300_PVS_NUM_FPUS_SHIFT);
    else if ((rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_R520) ||
	     (rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_R580) ||
	     (rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_RV560) ||
	     (rmesa->radeon.radeonScreen->chip_family == CHIP_FAMILY_RV570))
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] |= (8 << R300_PVS_NUM_FPUS_SHIFT);
    else
	rmesa->hw.vap_cntl.cmd[R300_VAP_CNTL_INSTR] |= (2 << R300_PVS_NUM_FPUS_SHIFT);
d1747 6
d1755 1
a1755 6
/**
 * Enable/Disable states.
 *
 * \note Mesa already filters redundant calls to this function.
 */
static void r300Enable(struct gl_context * ctx, GLenum cap, GLboolean state)
d1757 1
a1757 5
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	if (RADEON_DEBUG & RADEON_STATE)
		fprintf(stderr, "%s( %s = %s )\n", __FUNCTION__,
			_mesa_lookup_enum_by_nr(cap),
			state ? "GL_TRUE" : "GL_FALSE");
d1759 14
a1772 59
	switch (cap) {
	case GL_ALPHA_TEST:
		r300SetAlphaState(ctx);
		break;
	case GL_COLOR_LOGIC_OP:
		r300SetLogicOpState(ctx);
		/* fall-through, because logic op overrides blending */
	case GL_BLEND:
		r300SetBlendState(ctx);
		break;
	case GL_CLIP_PLANE0:
	case GL_CLIP_PLANE1:
	case GL_CLIP_PLANE2:
	case GL_CLIP_PLANE3:
	case GL_CLIP_PLANE4:
	case GL_CLIP_PLANE5:
		r300SetClipPlaneState(ctx, cap, state);
		break;
	case GL_CULL_FACE:
		r300UpdateCulling(ctx);
		break;
	case GL_DEPTH_TEST:
		r300SetDepthState(ctx);
		break;
	case GL_LINE_SMOOTH:
		if (rmesa->options.conformance_mode)
			r300SwitchFallback(ctx, R300_FALLBACK_LINE_SMOOTH, ctx->Line.SmoothFlag);
		break;
	case GL_LINE_STIPPLE:
		if (rmesa->options.conformance_mode)
			r300SwitchFallback(ctx, R300_FALLBACK_LINE_STIPPLE, ctx->Line.StippleFlag);
		break;
	case GL_POINT_SMOOTH:
		if (rmesa->options.conformance_mode)
			r300SwitchFallback(ctx, R300_FALLBACK_POINT_SMOOTH, ctx->Point.SmoothFlag);
		break;
	case GL_POLYGON_SMOOTH:
		if (rmesa->options.conformance_mode)
			r300SwitchFallback(ctx, R300_FALLBACK_POLYGON_SMOOTH, ctx->Polygon.SmoothFlag);
		break;
	case GL_POLYGON_STIPPLE:
		if (rmesa->options.conformance_mode)
			r300SwitchFallback(ctx, R300_FALLBACK_POLYGON_STIPPLE, ctx->Polygon.StippleFlag);
		break;
	case GL_POLYGON_OFFSET_POINT:
	case GL_POLYGON_OFFSET_LINE:
	case GL_POLYGON_OFFSET_FILL:
		r300SetPolygonOffsetState(ctx, state);
		break;
	case GL_SCISSOR_TEST:
		radeon_firevertices(&rmesa->radeon);
		rmesa->radeon.state.scissor.enabled = state;
		radeonUpdateScissor( ctx );
		break;
	case GL_STENCIL_TEST:
		r300SetStencilState(ctx, state);
		break;
	default:
		break;
d1774 38
d1819 2
a1820 2
	struct gl_context *ctx = r300->radeon.glCtx;
	int has_tcl;
d1822 2
a1823 1
	has_tcl = r300->options.hw_tcl_enabled;
d1825 1
a1825 1
	if (RADEON_DEBUG & RADEON_STATE)
d1828 8
d1837 3
a1839 4
		      ctx->Color.ColorMask[0][RCOMP],
		      ctx->Color.ColorMask[0][GCOMP],
		      ctx->Color.ColorMask[0][BCOMP],
                      ctx->Color.ColorMask[0][ACOMP]);
d1846 1
a1846 1
	r300Enable(ctx, GL_STENCIL_TEST, ctx->Stencil._Enabled);
d1856 2
a1858 1
	r300SetLogicOpState(ctx);
d1863 7
d1878 6
a1883 8
	r300->hw.vap_vf_max_vtx_indx.cmd[1] = 0x00FFFFFF;
	r300->hw.vap_vf_max_vtx_indx.cmd[2] = 0x00000000;

#ifdef MESA_LITTLE_ENDIAN
	r300->hw.vap_cntl_status.cmd[1] = R300_VC_NO_SWAP;
#else
	r300->hw.vap_cntl_status.cmd[1] = R300_VC_32BIT_SWAP;
#endif
d1889 1
a1889 1
	r300->hw.vap_psc_sgn_norm_cntl.cmd[1] = 0xAAAAAAAA;
d1891 1
a1891 3
	/* XXX: Other families? */
	if (has_tcl) {
		r300->hw.vap_clip_cntl.cmd[1] = R300_PS_UCP_MODE_DIST_COP;
d1893 10
a1902 14
		r300->hw.vap_clip.cmd[1] = r300PackFloat32(1.0); /* X */
		r300->hw.vap_clip.cmd[2] = r300PackFloat32(1.0); /* X */
		r300->hw.vap_clip.cmd[3] = r300PackFloat32(1.0); /* Y */
		r300->hw.vap_clip.cmd[4] = r300PackFloat32(1.0); /* Y */

		switch (r300->radeon.radeonScreen->chip_family) {
		case CHIP_FAMILY_R300:
			r300->hw.vap_pvs_vtx_timeout_reg.cmd[1] = R300_2288_R300;
			break;
		default:
			r300->hw.vap_pvs_vtx_timeout_reg.cmd[1] = R300_2288_RV350;
			break;
		}
	}
d1906 1
a1906 1
	    | R300_GB_TRIANGLE_STUFF_ENABLE;
d1910 20
d1931 4
a1934 25
	r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] =
	    R300_GB_TILE_ENABLE | R300_GB_TILE_SIZE_16 /*| R300_GB_SUBPIXEL_1_16*/;
	switch (r300->radeon.radeonScreen->num_gb_pipes) {
	case 1:
	default:
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] |=
		    R300_GB_TILE_PIPE_COUNT_RV300;
		break;
	case 2:
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] |=
		    R300_GB_TILE_PIPE_COUNT_R300;
		break;
	case 3:
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] |=
		    R300_GB_TILE_PIPE_COUNT_R420_3P;
		break;
	case 4:
		r300->hw.gb_misc.cmd[R300_GB_MISC_TILE_CONFIG] |=
		    R300_GB_TILE_PIPE_COUNT_R420;
		break;
	}

	/* XXX: Enable anti-aliasing? */
	r300->hw.gb_misc2.cmd[R300_GB_MISC2_AA_CONFIG] = GB_AA_CONFIG_AA_DISABLE;
	r300->hw.gb_misc2.cmd[R300_GB_MISC2_SELECT] = 0;
d1936 1
a1936 4
	r300->hw.ga_point_s0.cmd[1] = r300PackFloat32(0.0);
	r300->hw.ga_point_s0.cmd[2] = r300PackFloat32(0.0);
	r300->hw.ga_point_s0.cmd[3] = r300PackFloat32(1.0);
	r300->hw.ga_point_s0.cmd[4] = r300PackFloat32(1.0);
d1938 1
a1938 1
	r300->hw.ga_triangle_stipple.cmd[1] = 0x00050005;
d1940 3
a1942 1
	r300PointSize(ctx, 1.0);
d1944 1
a1944 3
	r300->hw.ga_point_minmax.cmd[1] = 0x18000006;
	r300->hw.ga_point_minmax.cmd[2] = 0x00020006;
	r300->hw.ga_point_minmax.cmd[3] = r300PackFloat32(1.0 / 192.0);
d1946 3
a1948 5
	r300LineWidth(ctx, 1.0);

	r300->hw.ga_line_stipple.cmd[1] = 0;
	r300->hw.ga_line_stipple.cmd[2] = r300PackFloat32(0.0);
	r300->hw.ga_line_stipple.cmd[3] = r300PackFloat32(1.0);
d1950 1
d1952 2
d1957 2
a1962 2
	r300Enable(ctx, GL_POLYGON_OFFSET_POINT, ctx->Polygon.OffsetPoint);
	r300Enable(ctx, GL_POLYGON_OFFSET_LINE, ctx->Polygon.OffsetLine);
d1965 2
a1966 2
	r300->hw.su_depth_scale.cmd[1] = 0x4B7FFFFF;
	r300->hw.su_depth_scale.cmd[2] = 0x00000000;
d1968 2
a1969 2
	r300->hw.sc_hyperz.cmd[1] = 0x0000001C;
	r300->hw.sc_hyperz.cmd[2] = 0x2DA49525;
d1971 1
a1971 1
	r300->hw.sc_screendoor.cmd[1] = 0x00FFFFFF;
d1973 13
a1985 13
	r300->hw.us_out_fmt.cmd[1] = R500_OUT_FMT_C4_8  |
	  R500_C0_SEL_B | R500_C1_SEL_G | R500_C2_SEL_R | R500_C3_SEL_A;
	r300->hw.us_out_fmt.cmd[2] = R500_OUT_FMT_UNUSED |
	  R500_C0_SEL_B | R500_C1_SEL_G | R500_C2_SEL_R | R500_C3_SEL_A;
	r300->hw.us_out_fmt.cmd[3] = R500_OUT_FMT_UNUSED |
	  R500_C0_SEL_B | R500_C1_SEL_G | R500_C2_SEL_R | R500_C3_SEL_A;
	r300->hw.us_out_fmt.cmd[4] = R500_OUT_FMT_UNUSED |
	  R500_C0_SEL_B | R500_C1_SEL_G | R500_C2_SEL_R | R500_C3_SEL_A;
	r300->hw.us_out_fmt.cmd[5] = R300_W_FMT_W0 | R300_W_SRC_US;

	/* disable fog unit */
	r300->hw.fogs.cmd[R300_FOGS_STATE] = 0;
	r300->hw.fg_depth_src.cmd[1] = R300_FG_DEPTH_SRC_SCAN;
d1987 4
a1990 1
	r300->hw.rb3d_cctl.cmd[1] = 0;
d1993 2
d1996 5
a2000 9
	r300->hw.rb3d_dither_ctl.cmd[1] = 0;
	r300->hw.rb3d_dither_ctl.cmd[2] = 0;
	r300->hw.rb3d_dither_ctl.cmd[3] = 0;
	r300->hw.rb3d_dither_ctl.cmd[4] = 0;
	r300->hw.rb3d_dither_ctl.cmd[5] = 0;
	r300->hw.rb3d_dither_ctl.cmd[6] = 0;
	r300->hw.rb3d_dither_ctl.cmd[7] = 0;
	r300->hw.rb3d_dither_ctl.cmd[8] = 0;
	r300->hw.rb3d_dither_ctl.cmd[9] = 0;
d2002 4
a2005 1
	r300->hw.rb3d_aaresolve_ctl.cmd[1] = 0;
d2007 2
a2008 2
    r300->hw.rb3d_discard_src_pixel_lte_threshold.cmd[1] = 0x00000000;
    r300->hw.rb3d_discard_src_pixel_lte_threshold.cmd[2] = 0xffffffff;
d2010 9
a2018 1
	r300->hw.zb_depthclearvalue.cmd[1] = 0;
d2020 1
a2020 4
	r300->hw.zstencil_format.cmd[2] = R300_ZTOP_DISABLE;
	r300->hw.zstencil_format.cmd[3] = 0x00000003;
	r300->hw.zstencil_format.cmd[4] = 0x00000000;
	r300SetEarlyZState(ctx);
d2022 2
a2023 2
	r300->hw.zb_zmask.cmd[1] = 0;
	r300->hw.zb_zmask.cmd[2] = 0;
d2025 11
a2035 1
	r300->hw.zb_hiz_offset.cmd[1] = 0;
d2037 3
a2039 1
	r300->hw.zb_hiz_pitch.cmd[1] = 0;
d2041 2
a2042 7
	r300VapCntl(r300, 0, 0, 0);
	if (has_tcl) {
		r300->hw.vps.cmd[R300_VPS_ZERO_0] = 0;
		r300->hw.vps.cmd[R300_VPS_ZERO_1] = 0;
		r300->hw.vps.cmd[R300_VPS_POINTSIZE] = r300PackFloat32(1.0);
		r300->hw.vps.cmd[R300_VPS_ZERO_3] = 0;
	}
d2044 4
a2047 2
	r300->radeon.hw.all_dirty = GL_TRUE;
}
d2049 3
a2051 3
void r300UpdateShaders(r300ContextPtr rmesa)
{
	struct gl_context *ctx = rmesa->radeon.glCtx;
d2053 3
a2055 5
	/* should only happenen once, just after context is created */
	/* TODO: shouldn't we fallback to sw here? */
	if (!ctx->FragmentProgram._Current) {
		fprintf(stderr, "No ctx->FragmentProgram._Current!!\n");
		return;
d2058 1
a2058 2
	{
		struct r300_fragment_program *fp;
d2060 2
a2061 1
		fp = r300SelectAndTranslateFragmentShader(ctx);
d2063 1
a2063 2
		r300SwitchFallback(ctx, R300_FALLBACK_FRAGMENT_PROGRAM, fp->error);
	}
d2065 1
a2065 2
	if (rmesa->options.hw_tcl_enabled) {
		struct r300_vertex_program *vp;
d2067 5
a2071 3
		vp = r300SelectAndTranslateVertexShader(ctx);

		r300SwitchFallback(ctx, R300_FALLBACK_VERTEX_PROGRAM, vp->error);
d2073 2
a2074 3

	r300UpdateStateParameters(ctx, _NEW_PROGRAM | _NEW_PROGRAM_CONSTANTS);
	rmesa->radeon.NewGLState = 0;
a2076 5
static const GLfloat *get_fragmentprogram_constant(struct gl_context *ctx, GLuint index, GLfloat * buffer)
{
	static const GLfloat dummy[4] = { 0, 0, 0, 0 };
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	struct rc_constant * rcc = &rmesa->selected_fp->code.constants.Constants[index];
d2078 1
a2078 18
	switch(rcc->Type) {
	case RC_CONSTANT_EXTERNAL:
		return ctx->FragmentProgram._Current->Base.Parameters->ParameterValues[rcc->u.External];
	case RC_CONSTANT_IMMEDIATE:
		return rcc->u.Immediate;
	case RC_CONSTANT_STATE:
		switch(rcc->u.State[0]) {
		case RC_STATE_SHADOW_AMBIENT: {
			const int unit = (int) rcc->u.State[1];
			const struct gl_texture_object *texObj = ctx->Texture.Unit[unit]._Current;
			if (texObj) {
				buffer[0] =
				buffer[1] =
				buffer[2] =
				buffer[3] = texObj->CompareFailValue;
			}
			return buffer;
		}
d2080 2
a2081 34
		case RC_STATE_R300_WINDOW_DIMENSION: {
			__DRIdrawable * drawable = radeon_get_drawable(&rmesa->radeon);
			buffer[0] = drawable->w * 0.5f;	/* width*0.5 */
			buffer[1] = drawable->h * 0.5f;	/* height*0.5 */
			buffer[2] = 0.5F;	/* for moving range [-1 1] -> [0 1] */
			buffer[3] = 1.0F;	/* not used */
			return buffer;
		}

		case RC_STATE_R300_TEXRECT_FACTOR: {
			struct gl_texture_object *t =
				ctx->Texture.Unit[rcc->u.State[1]].CurrentTex[TEXTURE_RECT_INDEX];

			if (t && t->Image[0][t->BaseLevel]) {
				struct gl_texture_image *image =
					t->Image[0][t->BaseLevel];
				buffer[0] = 1.0 / image->Width2;
				buffer[1] = 1.0 / image->Height2;
			} else {
				buffer[0] = 1.0;
				buffer[1] = 1.0;
			}
			buffer[2] = 1.0;
			buffer[3] = 1.0;
			return buffer;
		}
		}
	}

	return dummy;
}


static void r300SetupPixelShader(struct gl_context *ctx)
d2083 2
a2084 3
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	struct r300_fragment_program *fp = rmesa->selected_fp;
	struct r300_fragment_program_code *code;
d2087 1
a2087 1
	code = &fp->code.code.r300;
d2089 2
a2090 14
	R300_STATECHANGE(rmesa, fpi[0]);
	R300_STATECHANGE(rmesa, fpi[1]);
	R300_STATECHANGE(rmesa, fpi[2]);
	R300_STATECHANGE(rmesa, fpi[3]);
	rmesa->hw.fpi[0].cmd[R300_FPI_CMD_0] = cmdpacket0(rmesa->radeon.radeonScreen, R300_US_ALU_RGB_INST_0, code->alu.length);
	rmesa->hw.fpi[1].cmd[R300_FPI_CMD_0] = cmdpacket0(rmesa->radeon.radeonScreen, R300_US_ALU_RGB_ADDR_0, code->alu.length);
	rmesa->hw.fpi[2].cmd[R300_FPI_CMD_0] = cmdpacket0(rmesa->radeon.radeonScreen, R300_US_ALU_ALPHA_INST_0, code->alu.length);
	rmesa->hw.fpi[3].cmd[R300_FPI_CMD_0] = cmdpacket0(rmesa->radeon.radeonScreen, R300_US_ALU_ALPHA_ADDR_0, code->alu.length);
	for (i = 0; i < code->alu.length; i++) {
		rmesa->hw.fpi[0].cmd[R300_FPI_INSTR_0 + i] = code->alu.inst[i].rgb_inst;
		rmesa->hw.fpi[1].cmd[R300_FPI_INSTR_0 + i] = code->alu.inst[i].rgb_addr;
		rmesa->hw.fpi[2].cmd[R300_FPI_INSTR_0 + i] = code->alu.inst[i].alpha_inst;
		rmesa->hw.fpi[3].cmd[R300_FPI_INSTR_0 + i] = code->alu.inst[i].alpha_addr;
	}
d2092 23
a2114 6
	R300_STATECHANGE(rmesa, fp);
	rmesa->hw.fp.cmd[R300_FP_CNTL0] = code->config;
	rmesa->hw.fp.cmd[R300_FP_CNTL1] = code->pixsize;
	rmesa->hw.fp.cmd[R300_FP_CNTL2] = code->code_offset;
	for (i = 0; i < 4; i++)
		rmesa->hw.fp.cmd[R300_FP_NODE0 + i] = code->code_addr[i];
d2116 3
a2118 9
	R300_STATECHANGE(rmesa, fpp);
	rmesa->hw.fpp.cmd[R300_FPP_CMD_0] = cmdpacket0(rmesa->radeon.radeonScreen, R300_PFS_PARAM_0_X, fp->code.constants.Count * 4);
	for (i = 0; i < fp->code.constants.Count; i++) {
		GLfloat buffer[4];
		const GLfloat *constant = get_fragmentprogram_constant(ctx, i, buffer);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 0] = r300PackFloat24(constant[0]);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 1] = r300PackFloat24(constant[1]);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 2] = r300PackFloat24(constant[2]);
		rmesa->hw.fpp.cmd[R300_FPP_PARAM_0 + 4 * i + 3] = r300PackFloat24(constant[3]);
d2120 1
d2123 1
a2123 15
#define bump_r500fp_count(ptr, new_count)   do{\
	drm_r300_cmd_header_t* _p=((drm_r300_cmd_header_t*)(ptr));\
	int _nc=(new_count)/6; \
	assert(_nc < 256); \
	if(_nc>_p->r500fp.count)_p->r500fp.count=_nc;\
} while(0)

#define bump_r500fp_const_count(ptr, new_count)   do{\
	drm_r300_cmd_header_t* _p=((drm_r300_cmd_header_t*)(ptr));\
	int _nc=(new_count)/4; \
	assert(_nc < 256); \
	if(_nc>_p->r500fp.count)_p->r500fp.count=_nc;\
} while(0)

static void r500SetupPixelShader(struct gl_context *ctx)
d2125 4
a2128 4
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	struct r300_fragment_program *fp = rmesa->selected_fp;
	int i;
	struct r500_fragment_program_code *code;
d2130 2
a2131 2
	((drm_r300_cmd_header_t *) rmesa->hw.r500fp.cmd)->r500fp.count = 0;
	((drm_r300_cmd_header_t *) rmesa->hw.r500fp_const.cmd)->r500fp.count = 0;
d2133 17
a2149 1
	code = &fp->code.code.r500;
d2152 13
a2164 59
	rmesa->hw.fp.cmd[R500_FP_PIXSIZE] = code->max_temp_idx;

	rmesa->hw.fp.cmd[R500_FP_CODE_ADDR] =
	    R500_US_CODE_START_ADDR(0) |
	    R500_US_CODE_END_ADDR(code->inst_end);
	rmesa->hw.fp.cmd[R500_FP_CODE_RANGE] =
	    R500_US_CODE_RANGE_ADDR(0) |
	    R500_US_CODE_RANGE_SIZE(code->inst_end);
	rmesa->hw.fp.cmd[R500_FP_CODE_OFFSET] =
	    R500_US_CODE_OFFSET_ADDR(0);

	R300_STATECHANGE(rmesa, r500fp);
	/* Emit our shader... */
	for (i = 0; i < code->inst_end+1; i++) {
		rmesa->hw.r500fp.cmd[i*6+1] = code->inst[i].inst0;
		rmesa->hw.r500fp.cmd[i*6+2] = code->inst[i].inst1;
		rmesa->hw.r500fp.cmd[i*6+3] = code->inst[i].inst2;
		rmesa->hw.r500fp.cmd[i*6+4] = code->inst[i].inst3;
		rmesa->hw.r500fp.cmd[i*6+5] = code->inst[i].inst4;
		rmesa->hw.r500fp.cmd[i*6+6] = code->inst[i].inst5;
	}

	bump_r500fp_count(rmesa->hw.r500fp.cmd, (code->inst_end + 1) * 6);

	R300_STATECHANGE(rmesa, r500fp_const);
	for (i = 0; i < fp->code.constants.Count; i++) {
		GLfloat buffer[4];
		const GLfloat *constant = get_fragmentprogram_constant(ctx, i, buffer);
		rmesa->hw.r500fp_const.cmd[R300_FPP_PARAM_0 + 4 * i + 0] = r300PackFloat32(constant[0]);
		rmesa->hw.r500fp_const.cmd[R300_FPP_PARAM_0 + 4 * i + 1] = r300PackFloat32(constant[1]);
		rmesa->hw.r500fp_const.cmd[R300_FPP_PARAM_0 + 4 * i + 2] = r300PackFloat32(constant[2]);
		rmesa->hw.r500fp_const.cmd[R300_FPP_PARAM_0 + 4 * i + 3] = r300PackFloat32(constant[3]);
	}
	bump_r500fp_const_count(rmesa->hw.r500fp_const.cmd, fp->code.constants.Count * 4);
}

void r300SetupVAP(struct gl_context *ctx, GLuint InputsRead, GLuint OutputsWritten)
{
	r300ContextPtr rmesa = R300_CONTEXT( ctx );
	struct vertex_attribute *attrs = rmesa->vbuf.attribs;
	int i, j, reg_count;
	uint32_t *vir0 = &rmesa->hw.vir[0].cmd[1];
	uint32_t *vir1 = &rmesa->hw.vir[1].cmd[1];

	for (i = 0; i < R300_VIR_CMDSIZE-1; ++i)
		vir0[i] = vir1[i] = 0;

	for (i = 0, j = 0; i < rmesa->vbuf.num_attribs; ++i) {
		int tmp;

		tmp = attrs[i].data_type | (attrs[i].dst_loc << R300_DST_VEC_LOC_SHIFT);
		if (attrs[i]._signed)
			tmp |= R300_SIGNED;
		if (attrs[i].normalize)
			tmp |= R300_NORMALIZE;

		if (i % 2 == 0) {
			vir0[j] = tmp << R300_DATA_TYPE_0_SHIFT;
			vir1[j] = attrs[i].swizzle | (attrs[i].write_mask << R300_WRITE_ENA_SHIFT);
d2166 1
a2166 3
			vir0[j] |= tmp << R300_DATA_TYPE_1_SHIFT;
			vir1[j] |= (attrs[i].swizzle | (attrs[i].write_mask << R300_WRITE_ENA_SHIFT)) << R300_SWIZZLE1_SHIFT;
			++j;
d2170 11
a2180 6
	reg_count = (rmesa->vbuf.num_attribs + 1) >> 1;
	if (rmesa->vbuf.num_attribs % 2 != 0) {
		vir0[reg_count-1] |= R300_LAST_VEC << R300_DATA_TYPE_0_SHIFT;
	} else {
		vir0[reg_count-1] |= R300_LAST_VEC << R300_DATA_TYPE_1_SHIFT;
	}
d2182 10
a2191 13
	R300_STATECHANGE(rmesa, vir[0]);
	R300_STATECHANGE(rmesa, vir[1]);
	R300_STATECHANGE(rmesa, vof);
	R300_STATECHANGE(rmesa, vic);

	if (rmesa->radeon.radeonScreen->kernel_mm) {
		rmesa->hw.vir[0].cmd[0] &= 0xC000FFFF;
		rmesa->hw.vir[1].cmd[0] &= 0xC000FFFF;
		rmesa->hw.vir[0].cmd[0] |= (reg_count & 0x3FFF) << 16;
		rmesa->hw.vir[1].cmd[0] |= (reg_count & 0x3FFF) << 16;
	} else {
		((drm_r300_cmd_header_t *) rmesa->hw.vir[0].cmd)->packet0.count = reg_count;
		((drm_r300_cmd_header_t *) rmesa->hw.vir[1].cmd)->packet0.count = reg_count;
d2193 2
a2194 5

	rmesa->hw.vic.cmd[R300_VIC_CNTL_0] = r300VAPInputCntl0(ctx, InputsRead);
	rmesa->hw.vic.cmd[R300_VIC_CNTL_1] = r300VAPInputCntl1(ctx, InputsRead);
	rmesa->hw.vof.cmd[R300_VOF_CNTL_0] = r300VAPOutputCntl0(ctx, OutputsWritten);
	rmesa->hw.vof.cmd[R300_VOF_CNTL_1] = r300VAPOutputCntl1(ctx, OutputsWritten);
d2199 1
a2199 1
	struct gl_context *ctx;
d2202 1
a2202 5
	/* should only happenen once, just after context is created */
	if (!ctx->FragmentProgram._Current)
		return;

	r300SetEarlyZState(ctx);
d2204 1
d2207 3
a2209 7
	rmesa->vtbl.SetupPixelShader(ctx);

	rmesa->vtbl.SetupRSUnit(ctx);

	if (rmesa->options.hw_tcl_enabled) {
		r300SetupVertexProgram(rmesa);
	}
a2211 63
#define EASY_US_OUT_FMT(comps, c0, c1, c2, c3) \
	(R500_OUT_FMT_##comps | R500_C0_SEL_##c0 | R500_C1_SEL_##c1 | \
	 R500_C2_SEL_##c2 | R500_C3_SEL_##c3)
static void r300SetupUsOutputFormat(struct gl_context *ctx)
{
	r300ContextPtr rmesa = R300_CONTEXT(ctx);
	uint32_t hw_format;
	struct radeon_renderbuffer *rrb = radeon_get_colorbuffer(&rmesa->radeon);

	if (!rrb) {
		return;
	}
	
	switch (rrb->base.Format)
	{
		case MESA_FORMAT_RGBA5551:
		case MESA_FORMAT_RGBA8888:
			hw_format = EASY_US_OUT_FMT(C4_8, A, B, G, R);
			break;
		case MESA_FORMAT_RGB565_REV:
		case MESA_FORMAT_RGBA8888_REV:
			hw_format = EASY_US_OUT_FMT(C4_8, R, G, B, A);
			break;
		case MESA_FORMAT_RGB565:
		case MESA_FORMAT_ARGB4444:
		case MESA_FORMAT_ARGB1555:
		case MESA_FORMAT_XRGB8888:
		case MESA_FORMAT_ARGB8888:
			hw_format = EASY_US_OUT_FMT(C4_8, B, G, R, A);
			break;
		case MESA_FORMAT_ARGB4444_REV:
		case MESA_FORMAT_ARGB1555_REV:
		case MESA_FORMAT_XRGB8888_REV:
		case MESA_FORMAT_ARGB8888_REV:
			hw_format = EASY_US_OUT_FMT(C4_8, A, R, G, B);
			break;
		case MESA_FORMAT_SRGBA8:
			hw_format = EASY_US_OUT_FMT(C4_10_GAMMA, A, B, G, R);
			break;
		case MESA_FORMAT_SARGB8:
			hw_format = EASY_US_OUT_FMT(C4_10_GAMMA, B, G, R, A);
			break;
		case MESA_FORMAT_SL8:
			hw_format = EASY_US_OUT_FMT(C4_10_GAMMA, A, A, R, A);
			break;
		case MESA_FORMAT_A8:
			hw_format = EASY_US_OUT_FMT(C4_8, A, A, A, A);
			break;
		case MESA_FORMAT_L8:
		case MESA_FORMAT_I8:
			hw_format = EASY_US_OUT_FMT(C4_8, A, A, R, A);
			break;
		default:
			assert(!"Unsupported format");
			hw_format = 0;
			break;
	}

	R300_STATECHANGE(rmesa, us_out_fmt);
	rmesa->hw.us_out_fmt.cmd[1] = hw_format;
}
#undef EASY_US_OUT_FMT

d2215 1
a2215 1
static void r300InvalidateState(struct gl_context * ctx, GLuint new_state)
d2223 1
d2225 2
a2226 7
	if (new_state & _NEW_BUFFERS) {
		_mesa_update_framebuffer(ctx);
		/* this updates the DrawBuffer's Width/Height if it's a FBO */
		_mesa_update_draw_buffer_bounds(ctx);

		R300_STATECHANGE(r300, cb);
		R300_STATECHANGE(r300, zb);
d2229 1
a2229 7
	if (new_state & (_NEW_LIGHT)) {
		R300_STATECHANGE(r300, shade2);
		if (ctx->Light.ProvokingVertex == GL_LAST_VERTEX_CONVENTION)
			r300->hw.shade2.cmd[1] |= R300_GA_COLOR_CONTROL_PROVOKING_VERTEX_LAST;
		else
			r300->hw.shade2.cmd[1] &= ~R300_GA_COLOR_CONTROL_PROVOKING_VERTEX_LAST;
	}
d2231 1
a2231 5
	if (new_state & _NEW_BUFFERS) {
		r300SetupUsOutputFormat(ctx);
	}

	r300->radeon.NewGLState |= new_state;
d2241 28
d2272 1
a2272 1
static void r300RenderMode(struct gl_context * ctx, GLenum mode)
d2274 3
a2276 1
	r300SwitchFallback(ctx, R300_FALLBACK_RENDER_MODE, ctx->RenderMode != GL_RENDER);
d2282 1
a2282 1
void r300InitStateFuncs(radeonContextPtr radeon, struct dd_function_table *functions)
d2284 1
d2296 1
a2298 4
	functions->LogicOpcode = r300LogicOpcode;

	/* ARB_point_parameters */
	functions->PointParameterfv = r300PointParameter;
d2301 1
a2315 24

	functions->ClipPlane = r300ClipPlane;
	functions->Scissor = radeonScissor;

	functions->DrawBuffer = radeonDrawBuffer;
	functions->ReadBuffer = radeonReadBuffer;

	functions->CopyPixels = _mesa_meta_CopyPixels;
	functions->DrawPixels = _mesa_meta_DrawPixels;
	if (radeon->radeonScreen->kernel_mm)
		functions->ReadPixels = radeonReadPixels;
}

void r300InitShaderFunctions(r300ContextPtr r300)
{
	if (r300->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
		r300->vtbl.SetupRSUnit = r500SetupRSUnit;
		r300->vtbl.SetupPixelShader = r500SetupPixelShader;
		r300->vtbl.SetupFragmentShaderTextures = r500SetupFragmentShaderTextures;
	} else {
		r300->vtbl.SetupRSUnit = r300SetupRSUnit;
		r300->vtbl.SetupPixelShader = r300SetupPixelShader;
		r300->vtbl.SetupFragmentShaderTextures = r300SetupFragmentShaderTextures;
	}
@


