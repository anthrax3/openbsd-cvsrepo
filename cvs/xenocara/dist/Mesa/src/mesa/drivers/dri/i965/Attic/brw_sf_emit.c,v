head	1.12;
access;
symbols
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	v10_2_3:1.1.1.4
	OPENBSD_5_5:1.8.0.2
	OPENBSD_5_5_BASE:1.8
	v9_2_5:1.1.1.3
	v9_2_3:1.1.1.3
	v9_2_2:1.1.1.3
	v9_2_1:1.1.1.3
	v9_2_0:1.1.1.3
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.10
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.2
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v7_0_1:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.11;
commitid	TnlogFl9nOv2eaRf;

1.11
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.10;
commitid	4ry2gvZGMXkCUD2n;

1.10
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.9;
commitid	mcxB0JvoI9gTDYXU;

1.9
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.8;
commitid	WPD6rgPryPkvXOr9;

1.8
date	2013.09.05.14.04.20;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.14.58.15;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.31.16.36.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.12.21.09.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.45;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.45;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.09.05.13.15.37;	author jsg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.07.09.20.34.51;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.5
date	2015.01.25.14.11.43;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.48.49;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.12
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics to
 develop this 3D driver.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */


#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"

#include "intel_batchbuffer.h"

#include "brw_defines.h"
#include "brw_context.h"
#include "brw_eu.h"
#include "brw_util.h"
#include "brw_sf.h"


/**
 * Determine the vue slot corresponding to the given half of the given register.
 */
static inline int vert_reg_to_vue_slot(struct brw_sf_compile *c, GLuint reg,
                                       int half)
{
   return (reg + c->urb_entry_read_offset) * 2 + half;
}

/**
 * Determine the varying corresponding to the given half of the given
 * register.  half=0 means the first half of a register, half=1 means the
 * second half.
 */
static inline int vert_reg_to_varying(struct brw_sf_compile *c, GLuint reg,
                                      int half)
{
   int vue_slot = vert_reg_to_vue_slot(c, reg, half);
   return c->vue_map.slot_to_varying[vue_slot];
}

/**
 * Determine the register corresponding to the given vue slot
 */
static struct brw_reg get_vue_slot(struct brw_sf_compile *c,
                                   struct brw_reg vert,
                                   int vue_slot)
{
   GLuint off = vue_slot / 2 - c->urb_entry_read_offset;
   GLuint sub = vue_slot % 2;

   return brw_vec4_grf(vert.nr + off, sub * 4);
}

/**
 * Determine the register corresponding to the given varying.
 */
static struct brw_reg get_varying(struct brw_sf_compile *c,
                                  struct brw_reg vert,
                                  GLuint varying)
{
   int vue_slot = c->vue_map.varying_to_slot[varying];
   assert (vue_slot >= c->urb_entry_read_offset);
   return get_vue_slot(c, vert, vue_slot);
}

static bool
have_attr(struct brw_sf_compile *c, GLuint attr)
{
   return (c->key.attrs & BITFIELD64_BIT(attr)) ? 1 : 0;
}

/***********************************************************************
 * Twoside lighting
 */
static void copy_bfc( struct brw_sf_compile *c,
		      struct brw_reg vert )
{
   struct brw_compile *p = &c->func;
   GLuint i;

   for (i = 0; i < 2; i++) {
      if (have_attr(c, VARYING_SLOT_COL0+i) &&
	  have_attr(c, VARYING_SLOT_BFC0+i))
	 brw_MOV(p,
		 get_varying(c, vert, VARYING_SLOT_COL0+i),
		 get_varying(c, vert, VARYING_SLOT_BFC0+i));
   }
}


static void do_twoside_color( struct brw_sf_compile *c )
{
   struct brw_compile *p = &c->func;
   GLuint backface_conditional = c->key.frontface_ccw ? BRW_CONDITIONAL_G : BRW_CONDITIONAL_L;

   /* Already done in clip program:
    */
   if (c->key.primitive == SF_UNFILLED_TRIS)
      return;

   /* If the vertex shader provides backface color, do the selection. The VS
    * promises to set up the front color if the backface color is provided, but
    * it may contain junk if never written to.
    */
   if (!(have_attr(c, VARYING_SLOT_COL0) && have_attr(c, VARYING_SLOT_BFC0)) &&
       !(have_attr(c, VARYING_SLOT_COL1) && have_attr(c, VARYING_SLOT_BFC1)))
      return;

   /* Need to use BRW_EXECUTE_4 and also do an 4-wide compare in order
    * to get all channels active inside the IF.  In the clipping code
    * we run with NoMask, so it's not an option and we can use
    * BRW_EXECUTE_1 for all comparisions.
    */
   brw_push_insn_state(p);
   brw_CMP(p, vec4(brw_null_reg()), backface_conditional, c->det, brw_imm_f(0));
   brw_IF(p, BRW_EXECUTE_4);
   {
      switch (c->nr_verts) {
      case 3: copy_bfc(c, c->vert[2]);
      case 2: copy_bfc(c, c->vert[1]);
      case 1: copy_bfc(c, c->vert[0]);
      }
   }
   brw_ENDIF(p);
   brw_pop_insn_state(p);
}



/***********************************************************************
 * Flat shading
 */

static void copy_flatshaded_attributes(struct brw_sf_compile *c,
                                       struct brw_reg dst,
                                       struct brw_reg src)
{
   struct brw_compile *p = &c->func;
   int i;

   for (i = 0; i < c->vue_map.num_slots; i++) {
      if (c->key.interpolation_mode.mode[i] == INTERP_QUALIFIER_FLAT) {
         brw_MOV(p,
                 get_vue_slot(c, dst, i),
                 get_vue_slot(c, src, i));
      }
   }
}

static int count_flatshaded_attributes(struct brw_sf_compile *c)
{
   int i;
   int count = 0;

   for (i = 0; i < c->vue_map.num_slots; i++)
      if (c->key.interpolation_mode.mode[i] == INTERP_QUALIFIER_FLAT)
         count++;

   return count;
}



/* Need to use a computed jump to copy flatshaded attributes as the
 * vertices are ordered according to y-coordinate before reaching this
 * point, so the PV could be anywhere.
 */
static void do_flatshade_triangle( struct brw_sf_compile *c )
{
   struct brw_compile *p = &c->func;
   struct brw_context *brw = p->brw;
   struct brw_reg ip = brw_ip_reg();
   GLuint nr;
   GLuint jmpi = 1;

   /* Already done in clip program:
    */
   if (c->key.primitive == SF_UNFILLED_TRIS)
      return;

   if (brw->gen == 5)
       jmpi = 2;

   nr = count_flatshaded_attributes(c);

   brw_push_insn_state(p);

   brw_MUL(p, c->pv, c->pv, brw_imm_d(jmpi*(nr*2+1)));
   brw_JMPI(p, ip, ip, c->pv);

   copy_flatshaded_attributes(c, c->vert[1], c->vert[0]);
   copy_flatshaded_attributes(c, c->vert[2], c->vert[0]);
   brw_JMPI(p, ip, ip, brw_imm_d(jmpi*(nr*4+1)));

   copy_flatshaded_attributes(c, c->vert[0], c->vert[1]);
   copy_flatshaded_attributes(c, c->vert[2], c->vert[1]);
   brw_JMPI(p, ip, ip, brw_imm_d(jmpi*nr*2));

   copy_flatshaded_attributes(c, c->vert[0], c->vert[2]);
   copy_flatshaded_attributes(c, c->vert[1], c->vert[2]);

   brw_pop_insn_state(p);
}
	

static void do_flatshade_line( struct brw_sf_compile *c )
{
   struct brw_compile *p = &c->func;
   struct brw_context *brw = p->brw;
   struct brw_reg ip = brw_ip_reg();
   GLuint nr;
   GLuint jmpi = 1;

   /* Already done in clip program:
    */
   if (c->key.primitive == SF_UNFILLED_TRIS)
      return;

   if (brw->gen == 5)
       jmpi = 2;

   nr = count_flatshaded_attributes(c);

   brw_push_insn_state(p);

   brw_MUL(p, c->pv, c->pv, brw_imm_d(jmpi*(nr+1)));
   brw_JMPI(p, ip, ip, c->pv);
   copy_flatshaded_attributes(c, c->vert[1], c->vert[0]);

   brw_JMPI(p, ip, ip, brw_imm_ud(jmpi*nr));
   copy_flatshaded_attributes(c, c->vert[0], c->vert[1]);

   brw_pop_insn_state(p);
}

	

/***********************************************************************
 * Triangle setup.
 */


static void alloc_regs( struct brw_sf_compile *c )
{
   GLuint reg, i;

   /* Values computed by fixed function unit:
    */
   c->pv  = retype(brw_vec1_grf(1, 1), BRW_REGISTER_TYPE_D);
   c->det = brw_vec1_grf(1, 2);
   c->dx0 = brw_vec1_grf(1, 3);
   c->dx2 = brw_vec1_grf(1, 4);
   c->dy0 = brw_vec1_grf(1, 5);
   c->dy2 = brw_vec1_grf(1, 6);

   /* z and 1/w passed in seperately:
    */
   c->z[0]     = brw_vec1_grf(2, 0);
   c->inv_w[0] = brw_vec1_grf(2, 1);
   c->z[1]     = brw_vec1_grf(2, 2);
   c->inv_w[1] = brw_vec1_grf(2, 3);
   c->z[2]     = brw_vec1_grf(2, 4);
   c->inv_w[2] = brw_vec1_grf(2, 5);

   /* The vertices:
    */
   reg = 3;
   for (i = 0; i < c->nr_verts; i++) {
      c->vert[i] = brw_vec8_grf(reg, 0);
      reg += c->nr_attr_regs;
   }

   /* Temporaries, allocated after last vertex reg.
    */
   c->inv_det = brw_vec1_grf(reg, 0);  reg++;
   c->a1_sub_a0 = brw_vec8_grf(reg, 0);  reg++;
   c->a2_sub_a0 = brw_vec8_grf(reg, 0);  reg++;
   c->tmp = brw_vec8_grf(reg, 0);  reg++;

   /* Note grf allocation:
    */
   c->prog_data.total_grf = reg;


   /* Outputs of this program - interpolation coefficients for
    * rasterization:
    */
   c->m1Cx = brw_vec8_reg(BRW_MESSAGE_REGISTER_FILE, 1, 0);
   c->m2Cy = brw_vec8_reg(BRW_MESSAGE_REGISTER_FILE, 2, 0);
   c->m3C0 = brw_vec8_reg(BRW_MESSAGE_REGISTER_FILE, 3, 0);
}


static void copy_z_inv_w( struct brw_sf_compile *c )
{
   struct brw_compile *p = &c->func;
   GLuint i;

   brw_push_insn_state(p);
	
   /* Copy both scalars with a single MOV:
    */
   for (i = 0; i < c->nr_verts; i++)
      brw_MOV(p, vec2(suboffset(c->vert[i], 2)), vec2(c->z[i]));
	
   brw_pop_insn_state(p);
}


static void invert_det( struct brw_sf_compile *c)
{
   /* Looks like we invert all 8 elements just to get 1/det in
    * position 2 !?!
    */
   brw_math(&c->func,
	    c->inv_det,
	    BRW_MATH_FUNCTION_INV,
	    0,
	    c->det,
	    BRW_MATH_DATA_SCALAR,
	    BRW_MATH_PRECISION_FULL);

}


static bool
calculate_masks(struct brw_sf_compile *c,
                GLuint reg,
                GLushort *pc,
                GLushort *pc_persp,
                GLushort *pc_linear)
{
   bool is_last_attr = (reg == c->nr_setup_regs - 1);
   enum glsl_interp_qualifier interp;

   *pc_persp = 0;
   *pc_linear = 0;
   *pc = 0xf;

   interp = c->key.interpolation_mode.mode[vert_reg_to_vue_slot(c, reg, 0)];
   if (interp == INTERP_QUALIFIER_SMOOTH) {
      *pc_linear = 0xf;
      *pc_persp = 0xf;
   } else if (interp == INTERP_QUALIFIER_NOPERSPECTIVE)
      *pc_linear = 0xf;

   /* Maybe only processs one attribute on the final round:
    */
   if (vert_reg_to_varying(c, reg, 1) != BRW_VARYING_SLOT_COUNT) {
      *pc |= 0xf0;

      interp = c->key.interpolation_mode.mode[vert_reg_to_vue_slot(c, reg, 1)];
      if (interp == INTERP_QUALIFIER_SMOOTH) {
         *pc_linear |= 0xf0;
         *pc_persp |= 0xf0;
      } else if (interp == INTERP_QUALIFIER_NOPERSPECTIVE)
         *pc_linear |= 0xf0;
   }

   return is_last_attr;
}

/* Calculates the predicate control for which channels of a reg
 * (containing 2 attrs) to do point sprite coordinate replacement on.
 */
static uint16_t
calculate_point_sprite_mask(struct brw_sf_compile *c, GLuint reg)
{
   int varying1, varying2;
   uint16_t pc = 0;

   varying1 = vert_reg_to_varying(c, reg, 0);
   if (varying1 >= VARYING_SLOT_TEX0 && varying1 <= VARYING_SLOT_TEX7) {
      if (c->key.point_sprite_coord_replace & (1 << (varying1 - VARYING_SLOT_TEX0)))
	 pc |= 0x0f;
   }
   if (varying1 == BRW_VARYING_SLOT_PNTC)
      pc |= 0x0f;

   varying2 = vert_reg_to_varying(c, reg, 1);
   if (varying2 >= VARYING_SLOT_TEX0 && varying2 <= VARYING_SLOT_TEX7) {
      if (c->key.point_sprite_coord_replace & (1 << (varying2 -
                                                     VARYING_SLOT_TEX0)))
         pc |= 0xf0;
   }
   if (varying2 == BRW_VARYING_SLOT_PNTC)
      pc |= 0xf0;

   return pc;
}



void brw_emit_tri_setup(struct brw_sf_compile *c, bool allocate)
{
   struct brw_compile *p = &c->func;
   GLuint i;

   c->nr_verts = 3;

   if (allocate)
      alloc_regs(c);

   invert_det(c);
   copy_z_inv_w(c);

   if (c->key.do_twoside_color)
      do_twoside_color(c);

   if (c->has_flat_shading)
      do_flatshade_triangle(c);


   for (i = 0; i < c->nr_setup_regs; i++)
   {
      /* Pair of incoming attributes:
       */
      struct brw_reg a0 = offset(c->vert[0], i);
      struct brw_reg a1 = offset(c->vert[1], i);
      struct brw_reg a2 = offset(c->vert[2], i);
      GLushort pc, pc_persp, pc_linear;
      bool last = calculate_masks(c, i, &pc, &pc_persp, &pc_linear);

      if (pc_persp)
      {
	 brw_set_predicate_control_flag_value(p, pc_persp);
	 brw_MUL(p, a0, a0, c->inv_w[0]);
	 brw_MUL(p, a1, a1, c->inv_w[1]);
	 brw_MUL(p, a2, a2, c->inv_w[2]);
      }


      /* Calculate coefficients for interpolated values:
       */
      if (pc_linear)
      {
	 brw_set_predicate_control_flag_value(p, pc_linear);

	 brw_ADD(p, c->a1_sub_a0, a1, negate(a0));
	 brw_ADD(p, c->a2_sub_a0, a2, negate(a0));

	 /* calculate dA/dx
	  */
	 brw_MUL(p, brw_null_reg(), c->a1_sub_a0, c->dy2);
	 brw_MAC(p, c->tmp, c->a2_sub_a0, negate(c->dy0));
	 brw_MUL(p, c->m1Cx, c->tmp, c->inv_det);
		
	 /* calculate dA/dy
	  */
	 brw_MUL(p, brw_null_reg(), c->a2_sub_a0, c->dx0);
	 brw_MAC(p, c->tmp, c->a1_sub_a0, negate(c->dx2));
	 brw_MUL(p, c->m2Cy, c->tmp, c->inv_det);
      }

      {
	 brw_set_predicate_control_flag_value(p, pc);
	 /* start point for interpolation
	  */
	 brw_MOV(p, c->m3C0, a0);

	 /* Copy m0..m3 to URB.  m0 is implicitly copied from r0 in
	  * the send instruction:
	  */	
	 brw_urb_WRITE(p,
		       brw_null_reg(),
		       0,
		       brw_vec8_grf(0, 0), /* r0, will be copied to m0 */
                       last ? BRW_URB_WRITE_EOT_COMPLETE
                       : BRW_URB_WRITE_NO_FLAGS,
		       4, 	/* msg len */
		       0,	/* response len */
		       i*4,	/* offset */
		       BRW_URB_SWIZZLE_TRANSPOSE); /* XXX: Swizzle control "SF to windower" */
      }
   }
}



void brw_emit_line_setup(struct brw_sf_compile *c, bool allocate)
{
   struct brw_compile *p = &c->func;
   GLuint i;


   c->nr_verts = 2;

   if (allocate)
      alloc_regs(c);

   invert_det(c);
   copy_z_inv_w(c);

   if (c->has_flat_shading)
      do_flatshade_line(c);

   for (i = 0; i < c->nr_setup_regs; i++)
   {
      /* Pair of incoming attributes:
       */
      struct brw_reg a0 = offset(c->vert[0], i);
      struct brw_reg a1 = offset(c->vert[1], i);
      GLushort pc, pc_persp, pc_linear;
      bool last = calculate_masks(c, i, &pc, &pc_persp, &pc_linear);

      if (pc_persp)
      {
	 brw_set_predicate_control_flag_value(p, pc_persp);
	 brw_MUL(p, a0, a0, c->inv_w[0]);
	 brw_MUL(p, a1, a1, c->inv_w[1]);
      }

      /* Calculate coefficients for position, color:
       */
      if (pc_linear) {
	 brw_set_predicate_control_flag_value(p, pc_linear);

	 brw_ADD(p, c->a1_sub_a0, a1, negate(a0));

 	 brw_MUL(p, c->tmp, c->a1_sub_a0, c->dx0);
	 brw_MUL(p, c->m1Cx, c->tmp, c->inv_det);
		
	 brw_MUL(p, c->tmp, c->a1_sub_a0, c->dy0);
	 brw_MUL(p, c->m2Cy, c->tmp, c->inv_det);
      }

      {
	 brw_set_predicate_control_flag_value(p, pc);

	 /* start point for interpolation
	  */
	 brw_MOV(p, c->m3C0, a0);

	 /* Copy m0..m3 to URB.
	  */
	 brw_urb_WRITE(p,
		       brw_null_reg(),
		       0,
		       brw_vec8_grf(0, 0),
                       last ? BRW_URB_WRITE_EOT_COMPLETE
                       : BRW_URB_WRITE_NO_FLAGS,
		       4, 	/* msg len */
		       0,	/* response len */
		       i*4,	/* urb destination offset */
		       BRW_URB_SWIZZLE_TRANSPOSE);
      }
   }
}

void brw_emit_point_sprite_setup(struct brw_sf_compile *c, bool allocate)
{
   struct brw_compile *p = &c->func;
   GLuint i;

   c->nr_verts = 1;

   if (allocate)
      alloc_regs(c);

   copy_z_inv_w(c);
   for (i = 0; i < c->nr_setup_regs; i++)
   {
      struct brw_reg a0 = offset(c->vert[0], i);
      GLushort pc, pc_persp, pc_linear, pc_coord_replace;
      bool last = calculate_masks(c, i, &pc, &pc_persp, &pc_linear);

      pc_coord_replace = calculate_point_sprite_mask(c, i);
      pc_persp &= ~pc_coord_replace;

      if (pc_persp) {
	 brw_set_predicate_control_flag_value(p, pc_persp);
	 brw_MUL(p, a0, a0, c->inv_w[0]);
      }

      /* Point sprite coordinate replacement: A texcoord with this
       * enabled gets replaced with the value (x, y, 0, 1) where x and
       * y vary from 0 to 1 across the horizontal and vertical of the
       * point.
       */
      if (pc_coord_replace) {
	 brw_set_predicate_control_flag_value(p, pc_coord_replace);
	 /* Caculate 1.0/PointWidth */
	 brw_math(&c->func,
		  c->tmp,
		  BRW_MATH_FUNCTION_INV,
		  0,
		  c->dx0,
		  BRW_MATH_DATA_SCALAR,
		  BRW_MATH_PRECISION_FULL);

	 brw_set_access_mode(p, BRW_ALIGN_16);

	 /* dA/dx, dA/dy */
	 brw_MOV(p, c->m1Cx, brw_imm_f(0.0));
	 brw_MOV(p, c->m2Cy, brw_imm_f(0.0));
	 brw_MOV(p, brw_writemask(c->m1Cx, WRITEMASK_X), c->tmp);
	 if (c->key.sprite_origin_lower_left) {
	    brw_MOV(p, brw_writemask(c->m2Cy, WRITEMASK_Y), negate(c->tmp));
	 } else {
	    brw_MOV(p, brw_writemask(c->m2Cy, WRITEMASK_Y), c->tmp);
	 }

	 /* attribute constant offset */
	 brw_MOV(p, c->m3C0, brw_imm_f(0.0));
	 if (c->key.sprite_origin_lower_left) {
	    brw_MOV(p, brw_writemask(c->m3C0, WRITEMASK_YW), brw_imm_f(1.0));
	 } else {
	    brw_MOV(p, brw_writemask(c->m3C0, WRITEMASK_W), brw_imm_f(1.0));
	 }

	 brw_set_access_mode(p, BRW_ALIGN_1);
      }

      if (pc & ~pc_coord_replace) {
	 brw_set_predicate_control_flag_value(p, pc & ~pc_coord_replace);
	 brw_MOV(p, c->m1Cx, brw_imm_ud(0));
	 brw_MOV(p, c->m2Cy, brw_imm_ud(0));
	 brw_MOV(p, c->m3C0, a0); /* constant value */
      }


      brw_set_predicate_control_flag_value(p, pc);
      /* Copy m0..m3 to URB. */
      brw_urb_WRITE(p,
		    brw_null_reg(),
		    0,
		    brw_vec8_grf(0, 0),
                    last ? BRW_URB_WRITE_EOT_COMPLETE
                    : BRW_URB_WRITE_NO_FLAGS,
		    4, 	/* msg len */
		    0,	/* response len */
		    i*4,	/* urb destination offset */
		    BRW_URB_SWIZZLE_TRANSPOSE);
   }
}

/* Points setup - several simplifications as all attributes are
 * constant across the face of the point (point sprites excluded!)
 */
void brw_emit_point_setup(struct brw_sf_compile *c, bool allocate)
{
   struct brw_compile *p = &c->func;
   GLuint i;

   c->nr_verts = 1;

   if (allocate)
      alloc_regs(c);

   copy_z_inv_w(c);

   brw_MOV(p, c->m1Cx, brw_imm_ud(0)); /* zero - move out of loop */
   brw_MOV(p, c->m2Cy, brw_imm_ud(0)); /* zero - move out of loop */

   for (i = 0; i < c->nr_setup_regs; i++)
   {
      struct brw_reg a0 = offset(c->vert[0], i);
      GLushort pc, pc_persp, pc_linear;
      bool last = calculate_masks(c, i, &pc, &pc_persp, &pc_linear);

      if (pc_persp)
      {				
	 /* This seems odd as the values are all constant, but the
	  * fragment shader will be expecting it:
	  */
	 brw_set_predicate_control_flag_value(p, pc_persp);
	 brw_MUL(p, a0, a0, c->inv_w[0]);
      }


      /* The delta values are always zero, just send the starting
       * coordinate.  Again, this is to fit in with the interpolation
       * code in the fragment shader.
       */
      {
	 brw_set_predicate_control_flag_value(p, pc);

	 brw_MOV(p, c->m3C0, a0); /* constant value */

	 /* Copy m0..m3 to URB.
	  */
	 brw_urb_WRITE(p,
		       brw_null_reg(),
		       0,
		       brw_vec8_grf(0, 0),
                       last ? BRW_URB_WRITE_EOT_COMPLETE
                       : BRW_URB_WRITE_NO_FLAGS,
		       4, 	/* msg len */
		       0,	/* response len */
		       i*4,	/* urb destination offset */
		       BRW_URB_SWIZZLE_TRANSPOSE);
      }
   }
}

void brw_emit_anyprim_setup( struct brw_sf_compile *c )
{
   struct brw_compile *p = &c->func;
   struct brw_reg ip = brw_ip_reg();
   struct brw_reg payload_prim = brw_uw1_reg(BRW_GENERAL_REGISTER_FILE, 1, 0);
   struct brw_reg payload_attr = get_element_ud(brw_vec1_reg(BRW_GENERAL_REGISTER_FILE, 1, 0), 0);
   struct brw_reg primmask;
   int jmp;
   struct brw_reg v1_null_ud = vec1(retype(brw_null_reg(), BRW_REGISTER_TYPE_UD));

   GLuint saveflag;

   c->nr_verts = 3;
   alloc_regs(c);

   primmask = retype(get_element(c->tmp, 0), BRW_REGISTER_TYPE_UD);

   brw_MOV(p, primmask, brw_imm_ud(1));
   brw_SHL(p, primmask, primmask, payload_prim);

   brw_set_conditionalmod(p, BRW_CONDITIONAL_Z);
   brw_AND(p, v1_null_ud, primmask, brw_imm_ud((1<<_3DPRIM_TRILIST) |
					       (1<<_3DPRIM_TRISTRIP) |
					       (1<<_3DPRIM_TRIFAN) |
					       (1<<_3DPRIM_TRISTRIP_REVERSE) |
					       (1<<_3DPRIM_POLYGON) |
					       (1<<_3DPRIM_RECTLIST) |
					       (1<<_3DPRIM_TRIFAN_NOSTIPPLE)));
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0)) - p->store;
   {
      saveflag = p->flag_value;
      brw_push_insn_state(p);
      brw_emit_tri_setup( c, false );
      brw_pop_insn_state(p);
      p->flag_value = saveflag;
      /* note - thread killed in subroutine, so must
       * restore the flag which is changed when building
       * the subroutine. fix #13240
       */
   }
   brw_land_fwd_jump(p, jmp);

   brw_set_conditionalmod(p, BRW_CONDITIONAL_Z);
   brw_AND(p, v1_null_ud, primmask, brw_imm_ud((1<<_3DPRIM_LINELIST) |
					       (1<<_3DPRIM_LINESTRIP) |
					       (1<<_3DPRIM_LINELOOP) |
					       (1<<_3DPRIM_LINESTRIP_CONT) |
					       (1<<_3DPRIM_LINESTRIP_BF) |
					       (1<<_3DPRIM_LINESTRIP_CONT_BF)));
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0)) - p->store;
   {
      saveflag = p->flag_value;
      brw_push_insn_state(p);
      brw_emit_line_setup( c, false );
      brw_pop_insn_state(p);
      p->flag_value = saveflag;
      /* note - thread killed in subroutine */
   }
   brw_land_fwd_jump(p, jmp);

   brw_set_conditionalmod(p, BRW_CONDITIONAL_Z);
   brw_AND(p, v1_null_ud, payload_attr, brw_imm_ud(1<<BRW_SPRITE_POINT_ENABLE));
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0)) - p->store;
   {
      saveflag = p->flag_value;
      brw_push_insn_state(p);
      brw_emit_point_sprite_setup( c, false );
      brw_pop_insn_state(p);
      p->flag_value = saveflag;
   }
   brw_land_fwd_jump(p, jmp);

   brw_emit_point_setup( c, false );
}




@


1.11
log
@Merge Mesa 10.2.9
@
text
@@


1.10
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d140 1
d151 1
d198 1
d212 2
d215 1
a215 1
   brw_JMPI(p, c->pv, BRW_PREDICATE_NONE);
d219 1
a219 1
   brw_JMPI(p, brw_imm_d(jmpi*(nr*4+1)), BRW_PREDICATE_NONE);
d223 1
a223 1
   brw_JMPI(p, brw_imm_d(jmpi*nr*2), BRW_PREDICATE_NONE);
d227 2
d236 1
d250 2
d253 1
a253 1
   brw_JMPI(p, c->pv, BRW_PREDICATE_NONE);
d256 1
a256 1
   brw_JMPI(p, brw_imm_ud(jmpi*nr), BRW_PREDICATE_NONE);
d258 2
d325 2
d331 2
d341 7
a347 6
   gen4_math(&c->func,
	     c->inv_det,
	     BRW_MATH_FUNCTION_INV,
	     0,
	     c->det,
	     BRW_MATH_PRECISION_FULL);
a417 6
static void
set_predicate_control_flag_value(struct brw_compile *p,
                                 struct brw_sf_compile *c,
                                 unsigned value)
{
   brw_set_default_predicate_control(p, BRW_PREDICATE_NONE);
a418 9
   if (value != 0xff) {
      if (value != c->flag_value) {
         brw_MOV(p, brw_flag_reg(0, 0), brw_imm_uw(value));
         c->flag_value = value;
      }

      brw_set_default_predicate_control(p, BRW_PREDICATE_NORMAL);
   }
}
a424 1
   c->flag_value = 0xff;
d452 1
a452 1
	 set_predicate_control_flag_value(p, c, pc_persp);
d463 1
a463 1
	 set_predicate_control_flag_value(p, c, pc_linear);
d482 1
a482 1
	 set_predicate_control_flag_value(p, c, pc);
a501 2

   brw_set_default_predicate_control(p, BRW_PREDICATE_NONE);
d511 1
a511 1
   c->flag_value = 0xff;
d534 1
a534 1
	 set_predicate_control_flag_value(p, c, pc_persp);
d542 1
a542 1
	 set_predicate_control_flag_value(p, c, pc_linear);
d554 1
a554 1
	 set_predicate_control_flag_value(p, c, pc);
a573 2

   brw_set_default_predicate_control(p, BRW_PREDICATE_NONE);
a580 1
   c->flag_value = 0xff;
d597 1
a597 1
	 set_predicate_control_flag_value(p, c, pc_persp);
d607 1
a607 1
	 set_predicate_control_flag_value(p, c, pc_coord_replace);
d609 7
a615 6
	 gen4_math(&c->func,
		   c->tmp,
		   BRW_MATH_FUNCTION_INV,
		   0,
		   c->dx0,
		   BRW_MATH_PRECISION_FULL);
d617 1
a617 1
	 brw_set_default_access_mode(p, BRW_ALIGN_16);
d637 1
a637 1
	 brw_set_default_access_mode(p, BRW_ALIGN_1);
d641 1
a641 1
	 set_predicate_control_flag_value(p, c, pc & ~pc_coord_replace);
d648 1
a648 1
      set_predicate_control_flag_value(p, c, pc);
a660 2

   brw_set_default_predicate_control(p, BRW_PREDICATE_NONE);
a670 1
   c->flag_value = 0xff;
d692 1
a692 1
	 set_predicate_control_flag_value(p, c, pc_persp);
d702 1
a702 1
	 set_predicate_control_flag_value(p, c, pc);
a719 2

   brw_set_default_predicate_control(p, BRW_PREDICATE_NONE);
d725 1
a725 1
   struct brw_context *brw = p->brw;
d732 2
d742 1
d750 12
a761 3
   brw_inst_set_cond_modifier(brw, brw_last_inst, BRW_CONDITIONAL_Z);
   jmp = brw_JMPI(p, brw_imm_d(0), BRW_PREDICATE_NORMAL) - p->store;
   brw_emit_tri_setup(c, false);
d764 1
d771 9
a779 3
   brw_inst_set_cond_modifier(brw, brw_last_inst, BRW_CONDITIONAL_Z);
   jmp = brw_JMPI(p, brw_imm_d(0), BRW_PREDICATE_NORMAL) - p->store;
   brw_emit_line_setup(c, false);
d782 1
d784 8
a791 3
   brw_inst_set_cond_modifier(brw, brw_last_inst, BRW_CONDITIONAL_Z);
   jmp = brw_JMPI(p, brw_imm_d(0), BRW_PREDICATE_NORMAL) - p->store;
   brw_emit_point_sprite_setup(c, false);
@


1.9
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@a139 1
   brw_push_insn_state(p);
a149 1
   brw_pop_insn_state(p);
a195 1
   struct brw_reg ip = brw_ip_reg();
a208 2
   brw_push_insn_state(p);

d210 1
a210 1
   brw_JMPI(p, ip, ip, c->pv);
d214 1
a214 1
   brw_JMPI(p, ip, ip, brw_imm_d(jmpi*(nr*4+1)));
d218 1
a218 1
   brw_JMPI(p, ip, ip, brw_imm_d(jmpi*nr*2));
a221 2

   brw_pop_insn_state(p);
a228 1
   struct brw_reg ip = brw_ip_reg();
a241 2
   brw_push_insn_state(p);

d243 1
a243 1
   brw_JMPI(p, ip, ip, c->pv);
d246 1
a246 1
   brw_JMPI(p, ip, ip, brw_imm_ud(jmpi*nr));
a247 2

   brw_pop_insn_state(p);
a312 2
   brw_push_insn_state(p);
	
a316 2
	
   brw_pop_insn_state(p);
d325 6
a330 7
   brw_math(&c->func,
	    c->inv_det,
	    BRW_MATH_FUNCTION_INV,
	    0,
	    c->det,
	    BRW_MATH_DATA_SCALAR,
	    BRW_MATH_PRECISION_FULL);
d401 6
d408 9
d423 1
d451 1
a451 1
	 brw_set_predicate_control_flag_value(p, pc_persp);
d462 1
a462 1
	 brw_set_predicate_control_flag_value(p, pc_linear);
d481 1
a481 1
	 brw_set_predicate_control_flag_value(p, pc);
d501 2
d512 1
a512 1

d535 1
a535 1
	 brw_set_predicate_control_flag_value(p, pc_persp);
d543 1
a543 1
	 brw_set_predicate_control_flag_value(p, pc_linear);
d555 1
a555 1
	 brw_set_predicate_control_flag_value(p, pc);
d575 2
d584 1
d601 1
a601 1
	 brw_set_predicate_control_flag_value(p, pc_persp);
d611 1
a611 1
	 brw_set_predicate_control_flag_value(p, pc_coord_replace);
d613 6
a618 7
	 brw_math(&c->func,
		  c->tmp,
		  BRW_MATH_FUNCTION_INV,
		  0,
		  c->dx0,
		  BRW_MATH_DATA_SCALAR,
		  BRW_MATH_PRECISION_FULL);
d620 1
a620 1
	 brw_set_access_mode(p, BRW_ALIGN_16);
d640 1
a640 1
	 brw_set_access_mode(p, BRW_ALIGN_1);
d644 1
a644 1
	 brw_set_predicate_control_flag_value(p, pc & ~pc_coord_replace);
d651 1
a651 1
      brw_set_predicate_control_flag_value(p, pc);
d664 2
d676 1
d698 1
a698 1
	 brw_set_predicate_control_flag_value(p, pc_persp);
d708 1
a708 1
	 brw_set_predicate_control_flag_value(p, pc);
d726 2
d733 1
a733 1
   struct brw_reg ip = brw_ip_reg();
a739 2
   GLuint saveflag;

a747 1
   brw_set_conditionalmod(p, BRW_CONDITIONAL_Z);
d755 3
a757 12
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0)) - p->store;
   {
      saveflag = p->flag_value;
      brw_push_insn_state(p);
      brw_emit_tri_setup( c, false );
      brw_pop_insn_state(p);
      p->flag_value = saveflag;
      /* note - thread killed in subroutine, so must
       * restore the flag which is changed when building
       * the subroutine. fix #13240
       */
   }
a759 1
   brw_set_conditionalmod(p, BRW_CONDITIONAL_Z);
d766 3
a768 9
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0)) - p->store;
   {
      saveflag = p->flag_value;
      brw_push_insn_state(p);
      brw_emit_line_setup( c, false );
      brw_pop_insn_state(p);
      p->flag_value = saveflag;
      /* note - thread killed in subroutine */
   }
a770 1
   brw_set_conditionalmod(p, BRW_CONDITIONAL_Z);
d772 3
a774 8
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0)) - p->store;
   {
      saveflag = p->flag_value;
      brw_push_insn_state(p);
      brw_emit_point_sprite_setup( c, false );
      brw_pop_insn_state(p);
      p->flag_value = saveflag;
   }
@


1.8
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
d5 1
a5 1
 
d13 1
a13 1
 
d17 1
a17 1
 
d25 1
a25 1
 
d29 1
a29 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d31 1
a31 1
   
d47 9
d63 1
a63 1
   int vue_slot = (reg + c->urb_entry_read_offset) * 2 + half;
d68 13
d89 1
a89 4
   GLuint off = vue_slot / 2 - c->urb_entry_read_offset;
   GLuint sub = vue_slot % 2;

   return brw_vec4_grf(vert.nr + off, sub * 4);
d98 1
a98 1
/*********************************************************************** 
d110 1
a110 1
	 brw_MOV(p, 
d127 3
a129 3
   /* XXX: What happens if BFC isn't present?  This could only happen
    * for user-supplied vertex programs, as t_vp_build.c always does
    * the right thing.
d134 1
a134 1
   
d160 3
a162 6
#define VARYING_SLOT_COLOR_BITS (BITFIELD64_BIT(VARYING_SLOT_COL0) | \
                                 BITFIELD64_BIT(VARYING_SLOT_COL1))

static void copy_colors( struct brw_sf_compile *c,
		     struct brw_reg dst,
		     struct brw_reg src)
d165 1
a165 1
   GLuint i;
d167 6
a172 5
   for (i = VARYING_SLOT_COL0; i <= VARYING_SLOT_COL1; i++) {
      if (have_attr(c,i))
	 brw_MOV(p, 
		 get_varying(c, dst, i),
		 get_varying(c, src, i));
d176 12
d199 1
a199 1
   GLuint nr = _mesa_bitcount_64(c->key.attrs & VARYING_SLOT_COLOR_BITS);
a201 3
   if (!nr)
      return;

d210 2
d213 1
a213 1
   
d217 2
a218 2
   copy_colors(c, c->vert[1], c->vert[0]);
   copy_colors(c, c->vert[2], c->vert[0]);
d221 2
a222 2
   copy_colors(c, c->vert[0], c->vert[1]);
   copy_colors(c, c->vert[2], c->vert[1]);
d225 2
a226 2
   copy_colors(c, c->vert[0], c->vert[2]);
   copy_colors(c, c->vert[1], c->vert[2]);
d237 1
a237 1
   GLuint nr = _mesa_bitcount_64(c->key.attrs & VARYING_SLOT_COLOR_BITS);
d240 1
a240 4
   if (!nr)
      return;

   /* Already done in clip program: 
d248 2
d251 1
a251 1
   
d254 1
a254 1
   copy_colors(c, c->vert[1], c->vert[0]);
d257 1
a257 1
   copy_colors(c, c->vert[0], c->vert[1]);
d290 1
a290 1
   
d309 1
a309 1
   
d331 1
a331 1
	 
d341 2
a342 2
   brw_math(&c->func, 
	    c->inv_det, 
d344 1
a344 1
	    0, 
d354 4
a357 4
	        GLuint reg,
		GLushort *pc,
		GLushort *pc_persp,
		GLushort *pc_linear)
d360 1
a360 15
   GLbitfield64 persp_mask;
   GLbitfield64 linear_mask;

   if (c->key.do_flat_shading)
      persp_mask = c->key.attrs & ~(BITFIELD64_BIT(VARYING_SLOT_POS) |
                                    BITFIELD64_BIT(VARYING_SLOT_COL0) |
                                    BITFIELD64_BIT(VARYING_SLOT_COL1));
   else
      persp_mask = c->key.attrs & ~(BITFIELD64_BIT(VARYING_SLOT_POS));

   if (c->key.do_flat_shading)
      linear_mask = c->key.attrs & ~(BITFIELD64_BIT(VARYING_SLOT_COL0) |
                                     BITFIELD64_BIT(VARYING_SLOT_COL1));
   else
      linear_mask = c->key.attrs;
d365 4
a368 2
      
   if (persp_mask & BITFIELD64_BIT(vert_reg_to_varying(c, reg, 0)))
d370 1
a370 2

   if (linear_mask & BITFIELD64_BIT(vert_reg_to_varying(c, reg, 0)))
d378 6
a383 5
      if (persp_mask & BITFIELD64_BIT(vert_reg_to_varying(c, reg, 1)))
	 *pc_persp |= 0xf0;

      if (linear_mask & BITFIELD64_BIT(vert_reg_to_varying(c, reg, 1)))
	 *pc_linear |= 0xf0;
d433 1
a433 1
   if (c->key.do_twoside_color) 
d436 1
a436 1
   if (c->key.do_flat_shading)
d438 2
a439 2
      
   
d457 2
a458 2
      
      
d460 1
a460 1
       */      
d482 1
a482 1
	 brw_set_predicate_control_flag_value(p, pc); 
d486 1
a486 1
      
d489 2
a490 2
	  */	 
	 brw_urb_WRITE(p, 
d494 2
a495 2
		       0, 	/* allocate */
		       1,	/* used */
a497 2
		       last,	/* eot */
		       last, 	/* writes complete */
d520 1
a520 1
   if (c->key.do_flat_shading)
d542 1
a542 1
	 brw_set_predicate_control_flag_value(p, pc_linear); 
d546 1
a546 1
 	 brw_MUL(p, c->tmp, c->a1_sub_a0, c->dx0); 
d554 1
a554 1
	 brw_set_predicate_control_flag_value(p, pc); 
d560 1
a560 1
	 /* Copy m0..m3 to URB. 
d562 1
a562 1
	 brw_urb_WRITE(p, 
d566 2
a567 2
		       0, 	/* allocate */
		       1, 	/* used */
a569 2
		       last, 	/* eot */
		       last, 	/* writes complete */
d571 1
a571 1
		       BRW_URB_SWIZZLE_TRANSPOSE); 
d573 1
a573 1
   } 
d654 2
a655 2
		    0, 	/* allocate */
		    1,	/* used */
a657 2
		    last, 	/* eot */
		    last, 	/* writes complete */
d672 1
a672 1
   
d686 1
a686 1
            
d702 1
a702 1
	 brw_set_predicate_control_flag_value(p, pc); 
d706 1
a706 1
	 /* Copy m0..m3 to URB. 
d708 1
a708 1
	 brw_urb_WRITE(p, 
d712 2
a713 2
		       0, 	/* allocate */
		       1,	/* used */
a715 2
		       last, 	/* eot */
		       last, 	/* writes complete */
d727 1
a727 1
   struct brw_reg payload_attr = get_element_ud(brw_vec1_reg(BRW_GENERAL_REGISTER_FILE, 1, 0), 0); 
d731 1
a731 1
   
d753 1
a753 1
      brw_push_insn_state(p); 
d774 1
a774 1
      brw_push_insn_state(p); 
d780 1
a780 1
   brw_land_fwd_jump(p, jmp); 
d787 1
a787 1
      brw_push_insn_state(p); 
d792 1
a792 1
   brw_land_fwd_jump(p, jmp); 
@


1.7
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@d46 7
a52 3
static struct brw_reg get_vert_attr(struct brw_sf_compile *c,
				    struct brw_reg vert,
				    GLuint attr)
d54 15
a68 2
   GLuint off = c->attr_to_idx[attr] / 2;
   GLuint sub = c->attr_to_idx[attr] % 2;
d73 2
a74 2
static GLboolean have_attr(struct brw_sf_compile *c,
			   GLuint attr)
d89 2
a90 2
      if (have_attr(c, VERT_RESULT_COL0+i) &&
	  have_attr(c, VERT_RESULT_BFC0+i))
d92 2
a93 2
		 get_vert_attr(c, vert, VERT_RESULT_COL0+i), 
		 get_vert_attr(c, vert, VERT_RESULT_BFC0+i));
d112 2
a113 2
   if (!(have_attr(c, VERT_RESULT_COL0) && have_attr(c, VERT_RESULT_BFC0)) &&
       !(have_attr(c, VERT_RESULT_COL1) && have_attr(c, VERT_RESULT_BFC1)))
d141 2
a142 2
#define VERT_RESULT_COLOR_BITS (BITFIELD64_BIT(VERT_RESULT_COL0) | \
				BITFIELD64_BIT(VERT_RESULT_COL1))
d151 1
a151 1
   for (i = VERT_RESULT_COL0; i <= VERT_RESULT_COL1; i++) {
d154 2
a155 2
		 get_vert_attr(c, dst, i), 
		 get_vert_attr(c, src, i));
d168 1
a168 1
   struct intel_context *intel = &p->brw->intel;
d170 1
a170 1
   GLuint nr = brw_count_bits(c->key.attrs & VERT_RESULT_COLOR_BITS);
d181 1
a181 1
   if (intel->gen == 5)
d207 1
a207 1
   struct intel_context *intel = &p->brw->intel;
d209 1
a209 1
   GLuint nr = brw_count_bits(c->key.attrs & VERT_RESULT_COLOR_BITS);
d220 1
a220 1
   if (intel->gen == 5)
a316 1
	    BRW_MATH_SATURATE_NONE,
d325 6
a330 5
static GLboolean calculate_masks( struct brw_sf_compile *c,
				  GLuint reg,
				  GLushort *pc,
				  GLushort *pc_persp,
				  GLushort *pc_linear)
d332 1
a332 1
   GLboolean is_last_attr = (reg == c->nr_setup_regs - 1);
d337 3
a339 3
      persp_mask = c->key.attrs & ~(FRAG_BIT_WPOS |
                                    FRAG_BIT_COL0 |
                                    FRAG_BIT_COL1);
d341 1
a341 1
      persp_mask = c->key.attrs & ~(FRAG_BIT_WPOS);
d344 2
a345 1
      linear_mask = c->key.attrs & ~(FRAG_BIT_COL0|FRAG_BIT_COL1);
d353 1
a353 1
   if (persp_mask & BITFIELD64_BIT(c->idx_to_attr[reg*2]))
d356 1
a356 1
   if (linear_mask & BITFIELD64_BIT(c->idx_to_attr[reg*2]))
d361 1
a361 1
   if (reg*2+1 < c->nr_setup_attrs) {
d364 1
a364 1
      if (persp_mask & BITFIELD64_BIT(c->idx_to_attr[reg*2+1]))
d367 1
a367 1
      if (linear_mask & BITFIELD64_BIT(c->idx_to_attr[reg*2+1]))
d380 1
a380 1
   int attr1, attr2;
d383 3
a385 3
   attr1 = c->idx_to_attr[reg * 2];
   if (attr1 >= VERT_RESULT_TEX0 && attr1 <= VERT_RESULT_TEX7) {
      if (c->key.point_sprite_coord_replace & (1 << (attr1 - VERT_RESULT_TEX0)))
d388 2
d391 5
a395 7
   if (reg * 2 + 1 < c->nr_setup_attrs) {
       attr2 = c->idx_to_attr[reg * 2 + 1];
       if (attr2 >= VERT_RESULT_TEX0 && attr2 <= VERT_RESULT_TEX7) {
	  if (c->key.point_sprite_coord_replace & (1 << (attr2 -
							 VERT_RESULT_TEX0)))
	     pc |= 0xf0;
       }
d397 2
d405 1
a405 1
void brw_emit_tri_setup( struct brw_sf_compile *c, GLboolean allocate)
d433 1
a433 1
      GLboolean last = calculate_masks(c, i, &pc, &pc_persp, &pc_linear);
d493 1
a493 1
void brw_emit_line_setup( struct brw_sf_compile *c, GLboolean allocate)
d517 1
a517 1
      GLboolean last = calculate_masks(c, i, &pc, &pc_persp, &pc_linear);
d565 1
a565 1
void brw_emit_point_sprite_setup( struct brw_sf_compile *c, GLboolean allocate)
d580 1
a580 1
      GLboolean last = calculate_masks(c, i, &pc, &pc_persp, &pc_linear);
a600 1
		  BRW_MATH_SATURATE_NONE,
d657 1
a657 1
void brw_emit_point_setup( struct brw_sf_compile *c, GLboolean allocate)
d676 1
a676 1
      GLboolean last = calculate_masks(c, i, &pc, &pc_persp, &pc_linear);
d722 1
a722 1
   struct brw_instruction *jmp;
d743 1
a743 1
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0));
d747 1
a747 1
      brw_emit_tri_setup( c, GL_FALSE );
d764 1
a764 1
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0));
d768 1
a768 1
      brw_emit_line_setup( c, GL_FALSE );
d777 1
a777 1
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0));
d781 1
a781 1
      brw_emit_point_sprite_setup( c, GL_FALSE );
d787 1
a787 1
   brw_emit_point_setup( c, GL_FALSE );
@


1.6
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@a83 1
   struct brw_instruction *if_insn;
d106 1
a106 1
   if_insn = brw_IF(p, BRW_EXECUTE_4); 
d114 1
a114 1
   brw_ENDIF(p, if_insn);
d319 1
a319 1
   if (c->key.do_flat_shading || c->key.linear_color)
@


1.5
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@d59 1
a59 1
   return (c->key.attrs & (1<<attr)) ? 1 : 0;
d125 2
a126 2
#define VERT_RESULT_COLOR_BITS ((1<<VERT_RESULT_COL0) | \
                                 (1<<VERT_RESULT_COL1))
d152 1
d155 2
d165 3
d170 1
a170 1
   brw_MUL(p, c->pv, c->pv, brw_imm_ud(nr*2+1));
d175 1
a175 1
   brw_JMPI(p, ip, ip, brw_imm_ud(nr*4+1));
d179 1
a179 1
   brw_JMPI(p, ip, ip, brw_imm_ud(nr*2));
d191 1
d194 2
a195 1
   
d204 3
d209 1
a209 1
   brw_MUL(p, c->pv, c->pv, brw_imm_ud(nr+1));
d213 1
a213 1
   brw_JMPI(p, ip, ip, brw_imm_ud(nr));
d232 1
a232 1
   c->pv  = retype(brw_vec1_grf(1, 1), BRW_REGISTER_TYPE_UD);
a308 3
#define NON_PERPECTIVE_ATTRS  (FRAG_BIT_WPOS | \
                               FRAG_BIT_COL0 | \
			       FRAG_BIT_COL1)
d317 9
a325 2
   GLuint persp_mask = c->key.attrs & ~NON_PERPECTIVE_ATTRS;
   GLuint linear_mask;
d336 1
a336 1
   if (persp_mask & (1 << c->idx_to_attr[reg*2])) 
d339 1
a339 1
   if (linear_mask & (1 << c->idx_to_attr[reg*2])) 
d347 1
a347 1
      if (persp_mask & (1 << c->idx_to_attr[reg*2+1])) 
d350 1
a350 1
      if (linear_mask & (1 << c->idx_to_attr[reg*2+1])) 
d357 27
a558 1
      struct brw_sf_point_tex *tex = &c->point_attrs[c->idx_to_attr[2*i]];
d560 1
a560 1
      GLushort pc, pc_persp, pc_linear;
d562 7
a568 7
            
      if (pc_persp)
      {				
	  if (!tex->CoordReplace) {
	      brw_set_predicate_control_flag_value(p, pc_persp);
	      brw_MUL(p, a0, a0, c->inv_w[0]);
	  }
d571 9
a579 3
      if (tex->CoordReplace) {
	  /* Caculate 1.0/PointWidth */
	  brw_math(&c->func,
d588 11
a598 15
	  if (c->key.SpriteOrigin == GL_LOWER_LEFT) {
	   	brw_MUL(p, c->m1Cx, c->tmp, c->inv_w[0]);
		brw_MOV(p, vec1(suboffset(c->m1Cx, 1)), brw_imm_f(0.0));
	  	brw_MUL(p, c->m2Cy, c->tmp, negate(c->inv_w[0]));
		brw_MOV(p, vec1(suboffset(c->m2Cy, 0)), brw_imm_f(0.0));
	  } else {
	   	brw_MUL(p, c->m1Cx, c->tmp, c->inv_w[0]);
		brw_MOV(p, vec1(suboffset(c->m1Cx, 1)), brw_imm_f(0.0));
	  	brw_MUL(p, c->m2Cy, c->tmp, c->inv_w[0]);
		brw_MOV(p, vec1(suboffset(c->m2Cy, 0)), brw_imm_f(0.0));
	  }
      } else {
	  brw_MOV(p, c->m1Cx, brw_imm_ud(0));
	  brw_MOV(p, c->m2Cy, brw_imm_ud(0));
      }
d600 4
a603 9
      {
	 brw_set_predicate_control_flag_value(p, pc); 
	 if (tex->CoordReplace) {
	     if (c->key.SpriteOrigin == GL_LOWER_LEFT) {
		 brw_MUL(p, c->m3C0, c->inv_w[0], brw_imm_f(1.0));
		 brw_MOV(p, vec1(suboffset(c->m3C0, 0)), brw_imm_f(0.0));
	     }
	     else
		 brw_MOV(p, c->m3C0, brw_imm_f(0.0));
d605 1
a605 1
	 	brw_MOV(p, c->m3C0, a0); /* constant value */
d608 8
a615 14
	 /* Copy m0..m3 to URB. 
	  */
	 brw_urb_WRITE(p, 
		       brw_null_reg(),
		       0,
		       brw_vec8_grf(0, 0),
		       0, 	/* allocate */
		       1,	/* used */
		       4, 	/* msg len */
		       0,	/* response len */
		       last, 	/* eot */
		       last, 	/* writes complete */
		       i*4,	/* urb destination offset */
		       BRW_URB_SWIZZLE_TRANSPOSE);
d617 16
d725 1
a725 1
   jmp = brw_JMPI(p, ip, ip, brw_imm_w(0));
d746 1
a746 1
   jmp = brw_JMPI(p, ip, ip, brw_imm_w(0));
d759 1
a759 1
   jmp = brw_JMPI(p, ip, ip, brw_imm_w(0));
@


1.4
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d33 3
a35 3
#include "glheader.h"
#include "macros.h"
#include "enums.h"
a61 31
/**
 * Sets VERT_RESULT_FOGC.Y  for gl_FrontFacing
 *
 * This is currently executed if the fragment program uses VERT_RESULT_FOGC
 * at all, but this could be eliminated with a scan of the FP contents.
 */
static void
do_front_facing( struct brw_sf_compile *c )
{
   struct brw_compile *p = &c->func; 
   int i;

   if (!have_attr(c, VERT_RESULT_FOGC))
      return;

   brw_push_insn_state(p);
   brw_CMP(p, brw_null_reg(), 
        c->key.frontface_ccw ? BRW_CONDITIONAL_G : BRW_CONDITIONAL_L,
        c->det, brw_imm_f(0));
   brw_set_predicate_control(p, BRW_PREDICATE_NONE);
   for (i = 0; i < 3; i++) {
       struct brw_reg fogc = get_vert_attr(c, c->vert[i],FRAG_ATTRIB_FOGC);
       brw_MOV(p, get_element(fogc, 1), brw_imm_f(0));
       brw_set_predicate_control(p, BRW_PREDICATE_NORMAL);
       brw_MOV(p, get_element(fogc, 1), brw_imm_f(1));
       brw_set_predicate_control(p, BRW_PREDICATE_NONE);
   }
   brw_pop_insn_state(p);
}

			 
a355 1
   do_front_facing(c);
@


1.3
log
@Update to Mesa 7.0.3. tested my oga@@ and johan@@
@
text
@d62 29
d387 1
d536 84
d686 1
d738 12
@


1.2
log
@Update to Mesa 7.0.2. Tested by naddy@@ (full ports build), simon@@
and oga@@ (with dri enabled).
@
text
@d346 1
a346 1
void brw_emit_tri_setup( struct brw_sf_compile *c )
d352 4
a355 1
   alloc_regs(c);
d434 1
a434 1
void brw_emit_line_setup( struct brw_sf_compile *c )
d441 4
a444 1
   alloc_regs(c);
a505 1

d509 1
a509 1
void brw_emit_point_setup( struct brw_sf_compile *c )
d515 4
a518 1
   alloc_regs(c);
d575 2
d578 1
d596 3
a598 2
      brw_push_insn_state(p);
      brw_emit_tri_setup( c );
d600 5
a604 1
      /* note - thread killed in subroutine */
d617 1
d619 1
a619 1
      brw_emit_line_setup( c );
d621 1
d626 1
a626 1
   brw_emit_point_setup( c );
@


1.1
log
@Initial revision
@
text
@d585 1
d587 1
d601 1
d603 1
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d33 3
a35 3
#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"
d59 1
a59 1
   return (c->key.attrs & BITFIELD64_BIT(attr)) ? 1 : 0;
d62 2
d127 2
a128 2
#define VERT_RESULT_COLOR_BITS (BITFIELD64_BIT(VERT_RESULT_COL0) | \
				BITFIELD64_BIT(VERT_RESULT_COL1))
a153 1
   struct intel_context *intel = &p->brw->intel;
a155 2
   GLuint jmpi = 1;

a163 3
   if (intel->gen == 5)
       jmpi = 2;

d166 1
a166 1
   brw_MUL(p, c->pv, c->pv, brw_imm_d(jmpi*(nr*2+1)));
d171 1
a171 1
   brw_JMPI(p, ip, ip, brw_imm_d(jmpi*(nr*4+1)));
d175 1
a175 1
   brw_JMPI(p, ip, ip, brw_imm_d(jmpi*nr*2));
a186 1
   struct intel_context *intel = &p->brw->intel;
d189 1
a189 2
   GLuint jmpi = 1;

a197 3
   if (intel->gen == 5)
       jmpi = 2;

d200 1
a200 1
   brw_MUL(p, c->pv, c->pv, brw_imm_d(jmpi*(nr+1)));
d204 1
a204 1
   brw_JMPI(p, ip, ip, brw_imm_ud(jmpi*nr));
d223 1
a223 1
   c->pv  = retype(brw_vec1_grf(1, 1), BRW_REGISTER_TYPE_D);
d300 3
d311 2
a312 9
   GLbitfield64 persp_mask;
   GLbitfield64 linear_mask;

   if (c->key.do_flat_shading || c->key.linear_color)
      persp_mask = c->key.attrs & ~(FRAG_BIT_WPOS |
                                    FRAG_BIT_COL0 |
                                    FRAG_BIT_COL1);
   else
      persp_mask = c->key.attrs & ~(FRAG_BIT_WPOS);
d323 1
a323 1
   if (persp_mask & BITFIELD64_BIT(c->idx_to_attr[reg*2]))
d326 1
a326 1
   if (linear_mask & BITFIELD64_BIT(c->idx_to_attr[reg*2]))
d334 1
a334 1
      if (persp_mask & BITFIELD64_BIT(c->idx_to_attr[reg*2+1]))
d337 1
a337 1
      if (linear_mask & BITFIELD64_BIT(c->idx_to_attr[reg*2+1]))
a343 27
/* Calculates the predicate control for which channels of a reg
 * (containing 2 attrs) to do point sprite coordinate replacement on.
 */
static uint16_t
calculate_point_sprite_mask(struct brw_sf_compile *c, GLuint reg)
{
   int attr1, attr2;
   uint16_t pc = 0;

   attr1 = c->idx_to_attr[reg * 2];
   if (attr1 >= VERT_RESULT_TEX0 && attr1 <= VERT_RESULT_TEX7) {
      if (c->key.point_sprite_coord_replace & (1 << (attr1 - VERT_RESULT_TEX0)))
	 pc |= 0x0f;
   }

   if (reg * 2 + 1 < c->nr_setup_attrs) {
       attr2 = c->idx_to_attr[reg * 2 + 1];
       if (attr2 >= VERT_RESULT_TEX0 && attr2 <= VERT_RESULT_TEX7) {
	  if (c->key.point_sprite_coord_replace & (1 << (attr2 -
							 VERT_RESULT_TEX0)))
	     pc |= 0xf0;
       }
   }

   return pc;
}

d346 1
a346 1
void brw_emit_tri_setup( struct brw_sf_compile *c, GLboolean allocate)
d352 1
a352 4

   if (allocate)
      alloc_regs(c);

d431 1
a431 1
void brw_emit_line_setup( struct brw_sf_compile *c, GLboolean allocate)
d438 1
a438 4

   if (allocate)
      alloc_regs(c);

a499 89
void brw_emit_point_sprite_setup( struct brw_sf_compile *c, GLboolean allocate)
{
   struct brw_compile *p = &c->func;
   GLuint i;

   c->nr_verts = 1;

   if (allocate)
      alloc_regs(c);

   copy_z_inv_w(c);
   for (i = 0; i < c->nr_setup_regs; i++)
   {
      struct brw_reg a0 = offset(c->vert[0], i);
      GLushort pc, pc_persp, pc_linear, pc_coord_replace;
      GLboolean last = calculate_masks(c, i, &pc, &pc_persp, &pc_linear);

      pc_coord_replace = calculate_point_sprite_mask(c, i);
      pc_persp &= ~pc_coord_replace;

      if (pc_persp) {
	 brw_set_predicate_control_flag_value(p, pc_persp);
	 brw_MUL(p, a0, a0, c->inv_w[0]);
      }

      /* Point sprite coordinate replacement: A texcoord with this
       * enabled gets replaced with the value (x, y, 0, 1) where x and
       * y vary from 0 to 1 across the horizontal and vertical of the
       * point.
       */
      if (pc_coord_replace) {
	 brw_set_predicate_control_flag_value(p, pc_coord_replace);
	 /* Caculate 1.0/PointWidth */
	 brw_math(&c->func,
		  c->tmp,
		  BRW_MATH_FUNCTION_INV,
		  BRW_MATH_SATURATE_NONE,
		  0,
		  c->dx0,
		  BRW_MATH_DATA_SCALAR,
		  BRW_MATH_PRECISION_FULL);

	 brw_set_access_mode(p, BRW_ALIGN_16);

	 /* dA/dx, dA/dy */
	 brw_MOV(p, c->m1Cx, brw_imm_f(0.0));
	 brw_MOV(p, c->m2Cy, brw_imm_f(0.0));
	 brw_MOV(p, brw_writemask(c->m1Cx, WRITEMASK_X), c->tmp);
	 if (c->key.sprite_origin_lower_left) {
	    brw_MOV(p, brw_writemask(c->m2Cy, WRITEMASK_Y), negate(c->tmp));
	 } else {
	    brw_MOV(p, brw_writemask(c->m2Cy, WRITEMASK_Y), c->tmp);
	 }

	 /* attribute constant offset */
	 brw_MOV(p, c->m3C0, brw_imm_f(0.0));
	 if (c->key.sprite_origin_lower_left) {
	    brw_MOV(p, brw_writemask(c->m3C0, WRITEMASK_YW), brw_imm_f(1.0));
	 } else {
	    brw_MOV(p, brw_writemask(c->m3C0, WRITEMASK_W), brw_imm_f(1.0));
	 }

	 brw_set_access_mode(p, BRW_ALIGN_1);
      }

      if (pc & ~pc_coord_replace) {
	 brw_set_predicate_control_flag_value(p, pc & ~pc_coord_replace);
	 brw_MOV(p, c->m1Cx, brw_imm_ud(0));
	 brw_MOV(p, c->m2Cy, brw_imm_ud(0));
	 brw_MOV(p, c->m3C0, a0); /* constant value */
      }


      brw_set_predicate_control_flag_value(p, pc);
      /* Copy m0..m3 to URB. */
      brw_urb_WRITE(p,
		    brw_null_reg(),
		    0,
		    brw_vec8_grf(0, 0),
		    0, 	/* allocate */
		    1,	/* used */
		    4, 	/* msg len */
		    0,	/* response len */
		    last, 	/* eot */
		    last, 	/* writes complete */
		    i*4,	/* urb destination offset */
		    BRW_URB_SWIZZLE_TRANSPOSE);
   }
}
d504 1
a504 1
void brw_emit_point_setup( struct brw_sf_compile *c, GLboolean allocate)
d510 1
a510 4
   
   if (allocate)
      alloc_regs(c);

a563 1
   struct brw_reg payload_attr = get_element_ud(brw_vec1_reg(BRW_GENERAL_REGISTER_FILE, 1, 0), 0); 
a566 2
   
   GLuint saveflag;
a567 1
   c->nr_verts = 3;
d583 1
a583 1
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0));
d585 2
a586 9
      saveflag = p->flag_value;
      brw_push_insn_state(p); 
      brw_emit_tri_setup( c, GL_FALSE );
      brw_pop_insn_state(p);
      p->flag_value = saveflag;
      /* note - thread killed in subroutine, so must
       * restore the flag which is changed when building
       * the subroutine. fix #13240
       */
d597 1
a597 1
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0));
d599 1
a599 5
      saveflag = p->flag_value;
      brw_push_insn_state(p); 
      brw_emit_line_setup( c, GL_FALSE );
      brw_pop_insn_state(p);
      p->flag_value = saveflag;
d604 1
a604 13
   brw_set_conditionalmod(p, BRW_CONDITIONAL_Z);
   brw_AND(p, v1_null_ud, payload_attr, brw_imm_ud(1<<BRW_SPRITE_POINT_ENABLE));
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0));
   {
      saveflag = p->flag_value;
      brw_push_insn_state(p); 
      brw_emit_point_sprite_setup( c, GL_FALSE );
      brw_pop_insn_state(p);
      p->flag_value = saveflag;
   }
   brw_land_fwd_jump(p, jmp); 

   brw_emit_point_setup( c, GL_FALSE );
@


1.1.1.3
log
@Import Mesa 9.2.0
@
text
@d46 3
a48 7
/**
 * Determine the varying corresponding to the given half of the given
 * register.  half=0 means the first half of a register, half=1 means the
 * second half.
 */
static inline int vert_reg_to_varying(struct brw_sf_compile *c, GLuint reg,
                                      int half)
d50 2
a51 15
   int vue_slot = (reg + c->urb_entry_read_offset) * 2 + half;
   return c->vue_map.slot_to_varying[vue_slot];
}

/**
 * Determine the register corresponding to the given varying.
 */
static struct brw_reg get_varying(struct brw_sf_compile *c,
                                  struct brw_reg vert,
                                  GLuint varying)
{
   int vue_slot = c->vue_map.varying_to_slot[varying];
   assert (vue_slot >= c->urb_entry_read_offset);
   GLuint off = vue_slot / 2 - c->urb_entry_read_offset;
   GLuint sub = vue_slot % 2;
d56 2
a57 2
static bool
have_attr(struct brw_sf_compile *c, GLuint attr)
d72 2
a73 2
      if (have_attr(c, VARYING_SLOT_COL0+i) &&
	  have_attr(c, VARYING_SLOT_BFC0+i))
d75 2
a76 2
		 get_varying(c, vert, VARYING_SLOT_COL0+i),
		 get_varying(c, vert, VARYING_SLOT_BFC0+i));
d84 1
d96 2
a97 2
   if (!(have_attr(c, VARYING_SLOT_COL0) && have_attr(c, VARYING_SLOT_BFC0)) &&
       !(have_attr(c, VARYING_SLOT_COL1) && have_attr(c, VARYING_SLOT_BFC1)))
d107 1
a107 1
   brw_IF(p, BRW_EXECUTE_4);
d115 1
a115 1
   brw_ENDIF(p);
d125 2
a126 2
#define VARYING_SLOT_COLOR_BITS (BITFIELD64_BIT(VARYING_SLOT_COL0) | \
                                 BITFIELD64_BIT(VARYING_SLOT_COL1))
d135 1
a135 1
   for (i = VARYING_SLOT_COL0; i <= VARYING_SLOT_COL1; i++) {
d138 2
a139 2
		 get_varying(c, dst, i),
		 get_varying(c, src, i));
d152 1
a152 1
   struct brw_context *brw = p->brw;
d154 1
a154 1
   GLuint nr = _mesa_bitcount_64(c->key.attrs & VARYING_SLOT_COLOR_BITS);
d165 1
a165 1
   if (brw->gen == 5)
d191 1
a191 1
   struct brw_context *brw = p->brw;
d193 1
a193 1
   GLuint nr = _mesa_bitcount_64(c->key.attrs & VARYING_SLOT_COLOR_BITS);
d204 1
a204 1
   if (brw->gen == 5)
d301 1
d310 5
a314 6
static bool
calculate_masks(struct brw_sf_compile *c,
	        GLuint reg,
		GLushort *pc,
		GLushort *pc_persp,
		GLushort *pc_linear)
d316 1
a316 1
   bool is_last_attr = (reg == c->nr_setup_regs - 1);
d320 4
a323 4
   if (c->key.do_flat_shading)
      persp_mask = c->key.attrs & ~(BITFIELD64_BIT(VARYING_SLOT_POS) |
                                    BITFIELD64_BIT(VARYING_SLOT_COL0) |
                                    BITFIELD64_BIT(VARYING_SLOT_COL1));
d325 1
a325 1
      persp_mask = c->key.attrs & ~(BITFIELD64_BIT(VARYING_SLOT_POS));
d328 1
a328 2
      linear_mask = c->key.attrs & ~(BITFIELD64_BIT(VARYING_SLOT_COL0) |
                                     BITFIELD64_BIT(VARYING_SLOT_COL1));
d336 1
a336 1
   if (persp_mask & BITFIELD64_BIT(vert_reg_to_varying(c, reg, 0)))
d339 1
a339 1
   if (linear_mask & BITFIELD64_BIT(vert_reg_to_varying(c, reg, 0)))
d344 1
a344 1
   if (vert_reg_to_varying(c, reg, 1) != BRW_VARYING_SLOT_COUNT) {
d347 1
a347 1
      if (persp_mask & BITFIELD64_BIT(vert_reg_to_varying(c, reg, 1)))
d350 1
a350 1
      if (linear_mask & BITFIELD64_BIT(vert_reg_to_varying(c, reg, 1)))
d363 1
a363 1
   int varying1, varying2;
d366 3
a368 3
   varying1 = vert_reg_to_varying(c, reg, 0);
   if (varying1 >= VARYING_SLOT_TEX0 && varying1 <= VARYING_SLOT_TEX7) {
      if (c->key.point_sprite_coord_replace & (1 << (varying1 - VARYING_SLOT_TEX0)))
a370 2
   if (varying1 == BRW_VARYING_SLOT_PNTC)
      pc |= 0x0f;
d372 7
a378 5
   varying2 = vert_reg_to_varying(c, reg, 1);
   if (varying2 >= VARYING_SLOT_TEX0 && varying2 <= VARYING_SLOT_TEX7) {
      if (c->key.point_sprite_coord_replace & (1 << (varying2 -
                                                     VARYING_SLOT_TEX0)))
         pc |= 0xf0;
a379 2
   if (varying2 == BRW_VARYING_SLOT_PNTC)
      pc |= 0xf0;
d386 1
a386 1
void brw_emit_tri_setup(struct brw_sf_compile *c, bool allocate)
d414 1
a414 1
      bool last = calculate_masks(c, i, &pc, &pc_persp, &pc_linear);
d474 1
a474 1
void brw_emit_line_setup(struct brw_sf_compile *c, bool allocate)
d498 1
a498 1
      bool last = calculate_masks(c, i, &pc, &pc_persp, &pc_linear);
d546 1
a546 1
void brw_emit_point_sprite_setup(struct brw_sf_compile *c, bool allocate)
d561 1
a561 1
      bool last = calculate_masks(c, i, &pc, &pc_persp, &pc_linear);
d582 1
d639 1
a639 1
void brw_emit_point_setup(struct brw_sf_compile *c, bool allocate)
d658 1
a658 1
      bool last = calculate_masks(c, i, &pc, &pc_persp, &pc_linear);
d704 1
a704 1
   int jmp;
d725 1
a725 1
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0)) - p->store;
d729 1
a729 1
      brw_emit_tri_setup( c, false );
d746 1
a746 1
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0)) - p->store;
d750 1
a750 1
      brw_emit_line_setup( c, false );
d759 1
a759 1
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0)) - p->store;
d763 1
a763 1
      brw_emit_point_sprite_setup( c, false );
d769 1
a769 1
   brw_emit_point_setup( c, false );
@


1.1.1.4
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics to
d5 1
a5 1

d13 1
a13 1

d17 1
a17 1

d25 1
a25 1

d29 1
a29 1
  *   Keith Whitwell <keithw@@vmware.com>
d31 1
a31 1

a46 9
 * Determine the vue slot corresponding to the given half of the given register.
 */
static inline int vert_reg_to_vue_slot(struct brw_sf_compile *c, GLuint reg,
                                       int half)
{
   return (reg + c->urb_entry_read_offset) * 2 + half;
}

/**
d54 1
a54 1
   int vue_slot = vert_reg_to_vue_slot(c, reg, half);
a58 13
 * Determine the register corresponding to the given vue slot
 */
static struct brw_reg get_vue_slot(struct brw_sf_compile *c,
                                   struct brw_reg vert,
                                   int vue_slot)
{
   GLuint off = vue_slot / 2 - c->urb_entry_read_offset;
   GLuint sub = vue_slot % 2;

   return brw_vec4_grf(vert.nr + off, sub * 4);
}

/**
d67 4
a70 1
   return get_vue_slot(c, vert, vue_slot);
d79 1
a79 1
/***********************************************************************
d91 1
a91 1
	 brw_MOV(p,
d108 3
a110 3
   /* If the vertex shader provides backface color, do the selection. The VS
    * promises to set up the front color if the backface color is provided, but
    * it may contain junk if never written to.
d115 1
a115 1

d141 6
a146 3
static void copy_flatshaded_attributes(struct brw_sf_compile *c,
                                       struct brw_reg dst,
                                       struct brw_reg src)
d149 1
a149 1
   int i;
d151 5
a155 6
   for (i = 0; i < c->vue_map.num_slots; i++) {
      if (c->key.interpolation_mode.mode[i] == INTERP_QUALIFIER_FLAT) {
         brw_MOV(p,
                 get_vue_slot(c, dst, i),
                 get_vue_slot(c, src, i));
      }
a158 12
static int count_flatshaded_attributes(struct brw_sf_compile *c)
{
   int i;
   int count = 0;

   for (i = 0; i < c->vue_map.num_slots; i++)
      if (c->key.interpolation_mode.mode[i] == INTERP_QUALIFIER_FLAT)
         count++;

   return count;
}

d170 1
a170 1
   GLuint nr;
d173 3
a183 2
   nr = count_flatshaded_attributes(c);

d185 1
a185 1

d189 2
a190 2
   copy_flatshaded_attributes(c, c->vert[1], c->vert[0]);
   copy_flatshaded_attributes(c, c->vert[2], c->vert[0]);
d193 2
a194 2
   copy_flatshaded_attributes(c, c->vert[0], c->vert[1]);
   copy_flatshaded_attributes(c, c->vert[2], c->vert[1]);
d197 2
a198 2
   copy_flatshaded_attributes(c, c->vert[0], c->vert[2]);
   copy_flatshaded_attributes(c, c->vert[1], c->vert[2]);
d209 1
a209 1
   GLuint nr;
d212 4
a215 1
   /* Already done in clip program:
a222 2
   nr = count_flatshaded_attributes(c);

d224 1
a224 1

d227 1
a227 1
   copy_flatshaded_attributes(c, c->vert[1], c->vert[0]);
d230 1
a230 1
   copy_flatshaded_attributes(c, c->vert[0], c->vert[1]);
d263 1
a263 1

d282 1
a282 1

d304 1
a304 1
	
d314 2
a315 2
   brw_math(&c->func,
	    c->inv_det,
d317 1
a317 1
	    0,
d327 4
a330 4
                GLuint reg,
                GLushort *pc,
                GLushort *pc_persp,
                GLushort *pc_linear)
d333 15
a347 1
   enum glsl_interp_qualifier interp;
d352 3
d356 1
a356 5
   interp = c->key.interpolation_mode.mode[vert_reg_to_vue_slot(c, reg, 0)];
   if (interp == INTERP_QUALIFIER_SMOOTH) {
      *pc_linear = 0xf;
      *pc_persp = 0xf;
   } else if (interp == INTERP_QUALIFIER_NOPERSPECTIVE)
d364 5
a368 6
      interp = c->key.interpolation_mode.mode[vert_reg_to_vue_slot(c, reg, 1)];
      if (interp == INTERP_QUALIFIER_SMOOTH) {
         *pc_linear |= 0xf0;
         *pc_persp |= 0xf0;
      } else if (interp == INTERP_QUALIFIER_NOPERSPECTIVE)
         *pc_linear |= 0xf0;
d418 1
a418 1
   if (c->key.do_twoside_color)
d421 1
a421 1
   if (c->has_flat_shading)
d423 2
a424 2


d442 2
a443 2


d445 1
a445 1
       */
d467 1
a467 1
	 brw_set_predicate_control_flag_value(p, pc);
d471 1
a471 1

d474 2
a475 2
	  */	
	 brw_urb_WRITE(p,
d479 2
a480 2
                       last ? BRW_URB_WRITE_EOT_COMPLETE
                       : BRW_URB_WRITE_NO_FLAGS,
d483 2
d507 1
a507 1
   if (c->has_flat_shading)
d529 1
a529 1
	 brw_set_predicate_control_flag_value(p, pc_linear);
d533 1
a533 1
 	 brw_MUL(p, c->tmp, c->a1_sub_a0, c->dx0);
d541 1
a541 1
	 brw_set_predicate_control_flag_value(p, pc);
d547 1
a547 1
	 /* Copy m0..m3 to URB.
d549 1
a549 1
	 brw_urb_WRITE(p,
d553 2
a554 2
                       last ? BRW_URB_WRITE_EOT_COMPLETE
                       : BRW_URB_WRITE_NO_FLAGS,
d557 2
d560 1
a560 1
		       BRW_URB_SWIZZLE_TRANSPOSE);
d562 1
a562 1
   }
d643 2
a644 2
                    last ? BRW_URB_WRITE_EOT_COMPLETE
                    : BRW_URB_WRITE_NO_FLAGS,
d647 2
d663 1
a663 1

d677 1
a677 1

d693 1
a693 1
	 brw_set_predicate_control_flag_value(p, pc);
d697 1
a697 1
	 /* Copy m0..m3 to URB.
d699 1
a699 1
	 brw_urb_WRITE(p,
d703 2
a704 2
                       last ? BRW_URB_WRITE_EOT_COMPLETE
                       : BRW_URB_WRITE_NO_FLAGS,
d707 2
d720 1
a720 1
   struct brw_reg payload_attr = get_element_ud(brw_vec1_reg(BRW_GENERAL_REGISTER_FILE, 1, 0), 0);
d724 1
a724 1

d746 1
a746 1
      brw_push_insn_state(p);
d767 1
a767 1
      brw_push_insn_state(p);
d773 1
a773 1
   brw_land_fwd_jump(p, jmp);
d780 1
a780 1
      brw_push_insn_state(p);
d785 1
a785 1
   brw_land_fwd_jump(p, jmp);
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d140 1
d151 1
d198 1
d212 2
d215 1
a215 1
   brw_JMPI(p, c->pv, BRW_PREDICATE_NONE);
d219 1
a219 1
   brw_JMPI(p, brw_imm_d(jmpi*(nr*4+1)), BRW_PREDICATE_NONE);
d223 1
a223 1
   brw_JMPI(p, brw_imm_d(jmpi*nr*2), BRW_PREDICATE_NONE);
d227 2
d236 1
d250 2
d253 1
a253 1
   brw_JMPI(p, c->pv, BRW_PREDICATE_NONE);
d256 1
a256 1
   brw_JMPI(p, brw_imm_ud(jmpi*nr), BRW_PREDICATE_NONE);
d258 2
d325 2
d331 2
d341 7
a347 6
   gen4_math(&c->func,
	     c->inv_det,
	     BRW_MATH_FUNCTION_INV,
	     0,
	     c->det,
	     BRW_MATH_PRECISION_FULL);
a417 6
static void
set_predicate_control_flag_value(struct brw_compile *p,
                                 struct brw_sf_compile *c,
                                 unsigned value)
{
   brw_set_default_predicate_control(p, BRW_PREDICATE_NONE);
a418 9
   if (value != 0xff) {
      if (value != c->flag_value) {
         brw_MOV(p, brw_flag_reg(0, 0), brw_imm_uw(value));
         c->flag_value = value;
      }

      brw_set_default_predicate_control(p, BRW_PREDICATE_NORMAL);
   }
}
a424 1
   c->flag_value = 0xff;
d452 1
a452 1
	 set_predicate_control_flag_value(p, c, pc_persp);
d463 1
a463 1
	 set_predicate_control_flag_value(p, c, pc_linear);
d482 1
a482 1
	 set_predicate_control_flag_value(p, c, pc);
a501 2

   brw_set_default_predicate_control(p, BRW_PREDICATE_NONE);
d511 1
a511 1
   c->flag_value = 0xff;
d534 1
a534 1
	 set_predicate_control_flag_value(p, c, pc_persp);
d542 1
a542 1
	 set_predicate_control_flag_value(p, c, pc_linear);
d554 1
a554 1
	 set_predicate_control_flag_value(p, c, pc);
a573 2

   brw_set_default_predicate_control(p, BRW_PREDICATE_NONE);
a580 1
   c->flag_value = 0xff;
d597 1
a597 1
	 set_predicate_control_flag_value(p, c, pc_persp);
d607 1
a607 1
	 set_predicate_control_flag_value(p, c, pc_coord_replace);
d609 7
a615 6
	 gen4_math(&c->func,
		   c->tmp,
		   BRW_MATH_FUNCTION_INV,
		   0,
		   c->dx0,
		   BRW_MATH_PRECISION_FULL);
d617 1
a617 1
	 brw_set_default_access_mode(p, BRW_ALIGN_16);
d637 1
a637 1
	 brw_set_default_access_mode(p, BRW_ALIGN_1);
d641 1
a641 1
	 set_predicate_control_flag_value(p, c, pc & ~pc_coord_replace);
d648 1
a648 1
      set_predicate_control_flag_value(p, c, pc);
a660 2

   brw_set_default_predicate_control(p, BRW_PREDICATE_NONE);
a670 1
   c->flag_value = 0xff;
d692 1
a692 1
	 set_predicate_control_flag_value(p, c, pc_persp);
d702 1
a702 1
	 set_predicate_control_flag_value(p, c, pc);
a719 2

   brw_set_default_predicate_control(p, BRW_PREDICATE_NONE);
d725 1
a725 1
   struct brw_context *brw = p->brw;
d732 2
d742 1
d750 12
a761 3
   brw_inst_set_cond_modifier(brw, brw_last_inst, BRW_CONDITIONAL_Z);
   jmp = brw_JMPI(p, brw_imm_d(0), BRW_PREDICATE_NORMAL) - p->store;
   brw_emit_tri_setup(c, false);
d764 1
d771 9
a779 3
   brw_inst_set_cond_modifier(brw, brw_last_inst, BRW_CONDITIONAL_Z);
   jmp = brw_JMPI(p, brw_imm_d(0), BRW_PREDICATE_NORMAL) - p->store;
   brw_emit_line_setup(c, false);
d782 1
d784 8
a791 3
   brw_inst_set_cond_modifier(brw, brw_last_inst, BRW_CONDITIONAL_Z);
   jmp = brw_JMPI(p, brw_imm_d(0), BRW_PREDICATE_NORMAL) - p->store;
   brw_emit_point_sprite_setup(c, false);
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@a139 1
   brw_push_insn_state(p);
a149 1
   brw_pop_insn_state(p);
a195 1
   struct brw_reg ip = brw_ip_reg();
a208 2
   brw_push_insn_state(p);

d210 1
a210 1
   brw_JMPI(p, ip, ip, c->pv);
d214 1
a214 1
   brw_JMPI(p, ip, ip, brw_imm_d(jmpi*(nr*4+1)));
d218 1
a218 1
   brw_JMPI(p, ip, ip, brw_imm_d(jmpi*nr*2));
a221 2

   brw_pop_insn_state(p);
a228 1
   struct brw_reg ip = brw_ip_reg();
a241 2
   brw_push_insn_state(p);

d243 1
a243 1
   brw_JMPI(p, ip, ip, c->pv);
d246 1
a246 1
   brw_JMPI(p, ip, ip, brw_imm_ud(jmpi*nr));
a247 2

   brw_pop_insn_state(p);
a312 2
   brw_push_insn_state(p);
	
a316 2
	
   brw_pop_insn_state(p);
d325 6
a330 7
   brw_math(&c->func,
	    c->inv_det,
	    BRW_MATH_FUNCTION_INV,
	    0,
	    c->det,
	    BRW_MATH_DATA_SCALAR,
	    BRW_MATH_PRECISION_FULL);
d401 6
d408 9
d423 1
d451 1
a451 1
	 brw_set_predicate_control_flag_value(p, pc_persp);
d462 1
a462 1
	 brw_set_predicate_control_flag_value(p, pc_linear);
d481 1
a481 1
	 brw_set_predicate_control_flag_value(p, pc);
d501 2
d512 1
a512 1

d535 1
a535 1
	 brw_set_predicate_control_flag_value(p, pc_persp);
d543 1
a543 1
	 brw_set_predicate_control_flag_value(p, pc_linear);
d555 1
a555 1
	 brw_set_predicate_control_flag_value(p, pc);
d575 2
d584 1
d601 1
a601 1
	 brw_set_predicate_control_flag_value(p, pc_persp);
d611 1
a611 1
	 brw_set_predicate_control_flag_value(p, pc_coord_replace);
d613 6
a618 7
	 brw_math(&c->func,
		  c->tmp,
		  BRW_MATH_FUNCTION_INV,
		  0,
		  c->dx0,
		  BRW_MATH_DATA_SCALAR,
		  BRW_MATH_PRECISION_FULL);
d620 1
a620 1
	 brw_set_access_mode(p, BRW_ALIGN_16);
d640 1
a640 1
	 brw_set_access_mode(p, BRW_ALIGN_1);
d644 1
a644 1
	 brw_set_predicate_control_flag_value(p, pc & ~pc_coord_replace);
d651 1
a651 1
      brw_set_predicate_control_flag_value(p, pc);
d664 2
d676 1
d698 1
a698 1
	 brw_set_predicate_control_flag_value(p, pc_persp);
d708 1
a708 1
	 brw_set_predicate_control_flag_value(p, pc);
d726 2
d733 1
a733 1
   struct brw_reg ip = brw_ip_reg();
a739 2
   GLuint saveflag;

a747 1
   brw_set_conditionalmod(p, BRW_CONDITIONAL_Z);
d755 3
a757 12
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0)) - p->store;
   {
      saveflag = p->flag_value;
      brw_push_insn_state(p);
      brw_emit_tri_setup( c, false );
      brw_pop_insn_state(p);
      p->flag_value = saveflag;
      /* note - thread killed in subroutine, so must
       * restore the flag which is changed when building
       * the subroutine. fix #13240
       */
   }
a759 1
   brw_set_conditionalmod(p, BRW_CONDITIONAL_Z);
d766 3
a768 9
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0)) - p->store;
   {
      saveflag = p->flag_value;
      brw_push_insn_state(p);
      brw_emit_line_setup( c, false );
      brw_pop_insn_state(p);
      p->flag_value = saveflag;
      /* note - thread killed in subroutine */
   }
a770 1
   brw_set_conditionalmod(p, BRW_CONDITIONAL_Z);
d772 3
a774 8
   jmp = brw_JMPI(p, ip, ip, brw_imm_d(0)) - p->store;
   {
      saveflag = p->flag_value;
      brw_push_insn_state(p);
      brw_emit_point_sprite_setup( c, false );
      brw_pop_insn_state(p);
      p->flag_value = saveflag;
   }
@


