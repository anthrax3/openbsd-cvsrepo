head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.6
	v10_4_3:1.1.1.5
	v10_2_7:1.1.1.4
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.4.0.2
	OPENBSD_5_5_BASE:1.4
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.3.0.4
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.51;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2015.02.22.09.30.34;	author jsg;	state Exp;
branches;
next	1.8;
commitid	yhStanAcs6cSYmBc;

1.8
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.09.07.15.20.07;	author jsg;	state Exp;
branches;
next	1.5;
commitid	7kimTMT4YlQauAIU;

1.5
date	2014.07.09.21.09.00;	author jsg;	state Exp;
branches;
next	1.4;
commitid	WPD6rgPryPkvXOr9;

1.4
date	2013.09.05.14.05.30;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.17.13.58.16;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.22.20.06.24;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.42;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.16.04;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.56;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2014.09.07.15.06.40;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	dm8VnQHhowGHmemJ;

1.1.1.5
date	2015.01.25.14.12.11;	author jsg;	state Exp;
branches;
next	1.1.1.6;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.6
date	2015.02.20.22.49.18;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@
#ifndef COMMON_CONTEXT_H
#define COMMON_CONTEXT_H

#include "main/mm.h"
#include "math/m_vector.h"
#include "tnl/t_context.h"
#include "main/colormac.h"

#include "radeon_screen.h"
#include "radeon_debug.h"
#include "radeon_drm.h"
#include "dri_util.h"
#include "tnl/t_vertex.h"
#include "swrast/s_context.h"

struct radeon_context;

#include "radeon_bo_gem.h"
#include "radeon_cs_gem.h"

/* This union is used to avoid warnings/miscompilation
   with float to uint32_t casts due to strict-aliasing */
typedef union { GLfloat f; uint32_t ui32; } float_ui32_type;

struct radeon_context;
typedef struct radeon_context radeonContextRec;
typedef struct radeon_context *radeonContextPtr;


#define TEX_0   0x1
#define TEX_1   0x2
#define TEX_2   0x4
#define TEX_3	0x8
#define TEX_4	0x10
#define TEX_5	0x20

/* Rasterizing fallbacks */
/* See correponding strings in r200_swtcl.c */
#define RADEON_FALLBACK_TEXTURE		0x0001
#define RADEON_FALLBACK_DRAW_BUFFER	0x0002
#define RADEON_FALLBACK_STENCIL		0x0004
#define RADEON_FALLBACK_RENDER_MODE	0x0008
#define RADEON_FALLBACK_BLEND_EQ	0x0010
#define RADEON_FALLBACK_BLEND_FUNC	0x0020
#define RADEON_FALLBACK_DISABLE 	0x0040
#define RADEON_FALLBACK_BORDER_MODE	0x0080
#define RADEON_FALLBACK_DEPTH_BUFFER	0x0100
#define RADEON_FALLBACK_STENCIL_BUFFER  0x0200

#define R200_FALLBACK_TEXTURE           0x01
#define R200_FALLBACK_DRAW_BUFFER       0x02
#define R200_FALLBACK_STENCIL           0x04
#define R200_FALLBACK_RENDER_MODE       0x08
#define R200_FALLBACK_DISABLE           0x10
#define R200_FALLBACK_BORDER_MODE       0x20

#define RADEON_TCL_FALLBACK_RASTER            0x1 /* rasterization */
#define RADEON_TCL_FALLBACK_UNFILLED          0x2 /* unfilled tris */
#define RADEON_TCL_FALLBACK_LIGHT_TWOSIDE     0x4 /* twoside tris */
#define RADEON_TCL_FALLBACK_MATERIAL          0x8 /* material in vb */
#define RADEON_TCL_FALLBACK_TEXGEN_0          0x10 /* texgen, unit 0 */
#define RADEON_TCL_FALLBACK_TEXGEN_1          0x20 /* texgen, unit 1 */
#define RADEON_TCL_FALLBACK_TEXGEN_2          0x40 /* texgen, unit 2 */
#define RADEON_TCL_FALLBACK_TCL_DISABLE       0x80 /* user disable */
#define RADEON_TCL_FALLBACK_FOGCOORDSPEC      0x100 /* fogcoord, sep. spec light */

/* The blit width for texture uploads
 */
#define BLIT_WIDTH_BYTES 1024

/* Use the templated vertex format:
 */
#define COLOR_IS_RGBA
#define TAG(x) radeon##x
#include "tnl_dd/t_dd_vertex.h"
#undef TAG

#define RADEON_RB_CLASS 0xdeadbeef

struct radeon_renderbuffer
{
	struct swrast_renderbuffer base;

	struct radeon_bo *bo;
	unsigned int cpp;
	/* unsigned int offset; */
	unsigned int pitch;

	struct radeon_bo *map_bo;
	GLbitfield map_mode;
	int map_x, map_y, map_w, map_h;
	int map_pitch;
	void *map_buffer;

	uint32_t draw_offset; /* FBO */
	/* boo Xorg 6.8.2 compat */
	int has_surface;

	GLuint pf_pending;  /**< sequence number of pending flip */
	__DRIdrawable *dPriv;
};

struct radeon_framebuffer
{
	struct gl_framebuffer base;

	struct radeon_renderbuffer *color_rb[2];
};


struct radeon_colorbuffer_state {
	int roundEnable;
	struct gl_renderbuffer *rb;
	uint32_t draw_offset; /* offset into color renderbuffer - FBOs */
};

struct radeon_depthbuffer_state {
	struct gl_renderbuffer *rb;
};

struct radeon_scissor_state {
	drm_clip_rect_t rect;
	GLboolean enabled;
};

struct radeon_state_atom {
	struct radeon_state_atom *next, *prev;
	const char *name;	/* for debug */
	int cmd_size;		/* size in bytes */
        GLuint idx;
	GLuint is_tcl;
        GLuint *cmd;		/* one or more cmd's */
	GLuint *lastcmd;		/* one or more cmd's */
	GLboolean dirty;	/* dirty-mark in emit_state_list */
        int (*check) (struct gl_context *, struct radeon_state_atom *atom); /* is this state active? */
        void (*emit) (struct gl_context *, struct radeon_state_atom *atom);
};

struct radeon_hw_state {
  	/* Head of the linked list of state atoms. */
	struct radeon_state_atom atomlist;
	int max_state_size;	/* Number of bytes necessary for a full state emit. */
	int max_post_flush_size; /* Number of bytes necessary for post flushing emits */
	GLboolean is_dirty, all_dirty;
};


/* Texture related */
typedef struct _radeon_texture_image radeon_texture_image;


/**
 * This is a subclass of swrast_texture_image since we use swrast
 * for software fallback rendering.
 */
struct _radeon_texture_image {
	struct swrast_texture_image base;

	/**
	 * If mt != 0, the image is stored in hardware format in the
	 * given mipmap tree. In this case, base.Data may point into the
	 * mapping of the buffer object that contains the mipmap tree.
	 *
	 * If mt == 0, the image is stored in normal memory pointed to
	 * by base.Data.
	 */
	struct _radeon_mipmap_tree *mt;
	struct radeon_bo *bo;
	GLboolean used_as_render_target;
};


static INLINE radeon_texture_image *get_radeon_texture_image(struct gl_texture_image *image)
{
	return (radeon_texture_image*)image;
}


typedef struct radeon_tex_obj radeonTexObj, *radeonTexObjPtr;

#define RADEON_TXO_MICRO_TILE               (1 << 3)

/* Texture object in locally shared texture space.
 */
struct radeon_tex_obj {
	struct gl_texture_object base;
	struct _radeon_mipmap_tree *mt;

	/**
	 * This is true if we've verified that the mipmap tree above is complete
	 * and so on.
	 */
	GLboolean validated;
	/* Minimum LOD to be used during rendering */
	unsigned minLod;
	/* Miximum LOD to be used during rendering */
	unsigned maxLod;

	GLuint override_offset;
	GLboolean image_override; /* Image overridden by GLX_EXT_tfp */
	GLuint tile_bits;	/* hw texture tile bits used on this texture */
        struct radeon_bo *bo;

	GLuint pp_txfilter;	/* hardware register values */
	GLuint pp_txformat;
	GLuint pp_txformat_x;
	GLuint pp_txsize;	/* npot only */
	GLuint pp_txpitch;	/* npot only */
	GLuint pp_border_color;
	GLuint pp_cubic_faces;	/* cube face 1,2,3,4 log2 sizes */

	GLboolean border_fallback;
};

static INLINE radeonTexObj* radeon_tex_obj(struct gl_texture_object *texObj)
{
	return (radeonTexObj*)texObj;
}

/* occlusion query */
struct radeon_query_object {
	struct gl_query_object Base;
	struct radeon_bo *bo;
	int curr_offset;
	GLboolean emitted_begin;

	/* Double linked list of not flushed query objects */
	struct radeon_query_object *prev, *next;
};

/* Need refcounting on dma buffers:
 */
struct radeon_dma_buffer {
	int refcount;		/* the number of retained regions in buf */
	drmBufPtr buf;
};

struct radeon_aos {
	struct radeon_bo *bo; /** Buffer object where vertex data is stored */
	int offset; /** Offset into buffer object, in bytes */
	int components; /** Number of components per vertex */
	int stride; /** Stride in dwords (may be 0 for repeating) */
	int count; /** Number of vertices */
};

#define DMA_BO_FREE_TIME 100

struct radeon_dma_bo {
  struct radeon_dma_bo *next, *prev;
  struct radeon_bo *bo;
  int expire_counter;
};

struct radeon_dma {
        /* Active dma region.  Allocations for vertices and retained
         * regions come from here.  Also used for emitting random vertices,
         * these may be flushed by calling flush_current();
         */
	struct radeon_dma_bo free;
	struct radeon_dma_bo wait;
	struct radeon_dma_bo reserved;
        size_t current_used; /** Number of bytes allocated and forgotten about */
        size_t current_vertexptr; /** End of active vertex region */
        size_t minimum_size;

        /**
         * If current_vertexptr != current_used then flush must be non-zero.
         * flush must be called before non-active vertex allocations can be
         * performed.
         */
        void (*flush) (struct gl_context *);
};

/* radeon_swtcl.c
 */
struct radeon_swtcl_info {

	GLuint RenderIndex;
	GLuint vertex_size;
	GLubyte *verts;

	/* Fallback rasterization functions
	 */
	GLuint hw_primitive;
	GLenum render_primitive;
	GLuint numverts;

	struct tnl_attr_map vertex_attrs[VERT_ATTRIB_MAX];
	GLuint vertex_attr_count;

	GLuint emit_prediction;
        struct radeon_bo *bo;
};

#define RADEON_MAX_AOS_ARRAYS		16
struct radeon_tcl_info {
	struct radeon_aos aos[RADEON_MAX_AOS_ARRAYS];
	GLuint aos_count;
	struct radeon_bo *elt_dma_bo; /** Buffer object that contains element indices */
	int elt_dma_offset; /** Offset into this buffer object, in bytes */
};

struct radeon_ioctl {
	GLuint vertex_offset;
	GLuint vertex_max;
	struct radeon_bo *bo;
	GLuint vertex_size;
};

#define RADEON_MAX_PRIMS 64

struct radeon_prim {
	GLuint start;
	GLuint end;
	GLuint prim;
};

static INLINE GLuint radeonPackColor(GLuint cpp,
                                     GLubyte r, GLubyte g,
                                     GLubyte b, GLubyte a)
{
	switch (cpp) {
	case 2:
		return PACK_COLOR_565(r, g, b);
	case 4:
		return PACK_COLOR_8888(a, r, g, b);
	default:
		return 0;
	}
}

#define MAX_CMD_BUF_SZ (16*1024)

#define MAX_DMA_BUF_SZ (64*1024)

struct radeon_store {
	GLuint statenr;
	GLuint primnr;
	char cmd_buf[MAX_CMD_BUF_SZ];
	int cmd_used;
	int elts_start;
};

struct radeon_dri_mirror {
	__DRIcontext *context;	/* DRI context */
	__DRIscreen *screen;	/* DRI screen */

	drm_context_t hwContext;
	drm_hw_lock_t *hwLock;
	int hwLockCount;
	int fd;
	int drmMinor;
};

typedef void (*radeon_tri_func) (radeonContextPtr,
				 radeonVertex *,
				 radeonVertex *, radeonVertex *);

typedef void (*radeon_line_func) (radeonContextPtr,
				  radeonVertex *, radeonVertex *);

typedef void (*radeon_point_func) (radeonContextPtr, radeonVertex *);

#define RADEON_MAX_BOS 32
struct radeon_state {
	struct radeon_colorbuffer_state color;
	struct radeon_depthbuffer_state depth;
	struct radeon_scissor_state scissor;
};

/**
 * This structure holds the command buffer while it is being constructed.
 *
 * The first batch of commands in the buffer is always the state that needs
 * to be re-emitted when the context is lost. This batch can be skipped
 * otherwise.
 */
struct radeon_cmdbuf {
	struct radeon_cs_manager    *csm;
	struct radeon_cs            *cs;
	int size; /** # of dwords total */
	unsigned int flushing:1; /** whether we're currently in FlushCmdBufLocked */
};

struct radeon_context {
   struct gl_context glCtx;             /**< base class, must be first */
   radeonScreenPtr radeonScreen;	/* Screen private DRI data */

   /* Texture object bookkeeping
    */
   int                   texture_depth;
   float                 initialMaxAnisotropy;
   uint32_t              texture_row_align;
   uint32_t              texture_rect_row_align;
   uint32_t              texture_compressed_row_align;

  struct radeon_dma dma;
  struct radeon_hw_state hw;
   /* Rasterization and vertex state:
    */
   GLuint TclFallback;
   GLuint Fallback;
   GLuint NewGLState;
   GLbitfield64 tnl_index_bitset;	/* index of bits for last tnl_install_attrs */

   /* Drawable information */
   unsigned int lastStamp;
   drm_radeon_sarea_t *sarea;	/* Private SAREA data */

   /* Mirrors of some DRI state */
   struct radeon_dri_mirror dri;

   /* Busy waiting */
   GLuint do_usleeps;
   GLuint do_irqs;
   GLuint irqsEmitted;
   drm_radeon_irq_wait_t iw;

   /* Derived state - for r300 only */
   struct radeon_state state;

   struct radeon_swtcl_info swtcl;
   struct radeon_tcl_info tcl;
   /* Configuration cache
    */
   driOptionCache optionCache;

   struct radeon_cmdbuf cmdbuf;

   struct radeon_debug debug;

  drm_clip_rect_t fboRect;
  GLboolean front_cliprects;

   /**
    * Set if rendering has occured to the drawable's front buffer.
    *
    * This is used in the DRI2 case to detect that glFlush should also copy
    * the contents of the fake front buffer to the real front buffer.
    */
   GLboolean front_buffer_dirty;

   /**
    * Track whether front-buffer rendering is currently enabled
    *
    * A separate flag is used to track this in order to support MRT more
    * easily.
    */
   GLboolean is_front_buffer_rendering;

   /**
    * Track whether front-buffer is the current read target.
    *
    * This is closely associated with is_front_buffer_rendering, but may
    * be set separately.  The DRI2 fake front buffer must be referenced
    * either way.
    */
   GLboolean is_front_buffer_reading;

   struct {
	struct radeon_query_object *current;
	struct radeon_state_atom queryobj;
   } query;

   struct {
	   void (*get_lock)(radeonContextPtr radeon);
	   void (*update_viewport_offset)(struct gl_context *ctx);
	   void (*emit_cs_header)(struct radeon_cs *cs, radeonContextPtr rmesa);
	   void (*swtcl_flush)(struct gl_context *ctx, uint32_t offset);
	   void (*pre_emit_atoms)(radeonContextPtr rmesa);
	   void (*pre_emit_state)(radeonContextPtr rmesa);
	   void (*fallback)(struct gl_context *ctx, GLuint bit, GLboolean mode);
	   void (*free_context)(struct gl_context *ctx);
	   void (*emit_query_finish)(radeonContextPtr radeon);
	   void (*update_scissor)(struct gl_context *ctx);
	   unsigned (*check_blit)(mesa_format mesa_format, uint32_t dst_pitch);
	   unsigned (*blit)(struct gl_context *ctx,
                        struct radeon_bo *src_bo,
                        intptr_t src_offset,
                        mesa_format src_mesaformat,
                        unsigned src_pitch,
                        unsigned src_width,
                        unsigned src_height,
                        unsigned src_x_offset,
                        unsigned src_y_offset,
                        struct radeon_bo *dst_bo,
                        intptr_t dst_offset,
                        mesa_format dst_mesaformat,
                        unsigned dst_pitch,
                        unsigned dst_width,
                        unsigned dst_height,
                        unsigned dst_x_offset,
                        unsigned dst_y_offset,
                        unsigned reg_width,
                        unsigned reg_height,
                        unsigned flip_y);
	   unsigned (*is_format_renderable)(mesa_format mesa_format);
	   GLboolean (*revalidate_all_buffers)(struct gl_context *ctx);
   } vtbl;
};

static inline radeonContextPtr RADEON_CONTEXT(struct gl_context *ctx)
{
	return (radeonContextPtr) ctx;
}

static inline __DRIdrawable* radeon_get_drawable(radeonContextPtr radeon)
{
	return radeon->dri.context->driDrawablePriv;
}

static inline __DRIdrawable* radeon_get_readable(radeonContextPtr radeon)
{
	return radeon->dri.context->driReadablePriv;
}

extern const char const *radeonVendorString;

const char *radeonGetRendererString(radeonScreenPtr radeonScreen);

GLboolean radeonInitContext(radeonContextPtr radeon,
                            gl_api api,
			    struct dd_function_table* functions,
			    const struct gl_config * glVisual,
			    __DRIcontext * driContextPriv,
			    void *sharedContextPrivate);

void radeonCleanupContext(radeonContextPtr radeon);
GLboolean radeonUnbindContext(__DRIcontext * driContextPriv);
void radeon_update_renderbuffers(__DRIcontext *context, __DRIdrawable *drawable,
				 GLboolean front_only);
GLboolean radeonMakeCurrent(__DRIcontext * driContextPriv,
			    __DRIdrawable * driDrawPriv,
			    __DRIdrawable * driReadPriv);
extern void radeonDestroyContext(__DRIcontext * driContextPriv);
void radeon_prepare_render(radeonContextPtr radeon);

#endif
@


1.9
log
@Backport support for GLX_MESA_query_renderer for non Intel drivers.
This is desirable as the chromium port now uses this extension to
obtain pci vendor/device ids for use in feature/extension blacklists.

Prompted by a mail from byrnet@@, tested on r600g by krw@@

The newly added os_get_total_physical_memory() was passing the length of
a pointer rather than the type which made the sysctl call fail on
non 64 bit archs.  And it was passing the wrong pointer for the result.
Fixes for these problems have been submitted back upstream.
@
text
@@


1.8
log
@Merge Mesa 10.2.9
@
text
@d518 4
@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@d409 1
d467 3
d471 1
a516 4

extern const char const *radeonVendorString;

const char *radeonGetRendererString(radeonScreenPtr radeonScreen);
@


1.6
log
@Merge Mesa 10.2.7
@
text
@a408 1
   drm_radeon_sarea_t *sarea;	/* Private SAREA data */
a465 3
	   void (*get_lock)(radeonContextPtr radeon);
	   void (*update_viewport_offset)(struct gl_context *ctx);
	   void (*emit_cs_header)(struct radeon_cs *cs, radeonContextPtr rmesa);
a466 1
	   void (*pre_emit_atoms)(radeonContextPtr rmesa);
d512 4
@


1.5
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d499 1
@


1.4
log
@Merge Mesa 9.2.0
@
text
@d10 1
a11 1
#include "radeon_screen.h"
d477 1
a477 1
	   unsigned (*check_blit)(gl_format mesa_format, uint32_t dst_pitch);
d481 1
a481 1
                        gl_format src_mesaformat,
d489 1
a489 1
                        gl_format dst_mesaformat,
d498 1
a498 1
	   unsigned (*is_format_renderable)(gl_format mesa_format);
d518 1
@


1.3
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a6 1
#include "texmem.h"
d15 1
d19 2
a20 1
#include "radeon_bocs_wrapper.h"
d83 2
a84 1
	struct gl_renderbuffer base;
d90 6
a100 1
	GLuint vbl_pending;   /**< vblank sequence number of pending flip */
a101 7

	/* r6xx+ tiling */
	GLuint tile_config;
	GLint group_bytes;
	GLint num_channels;
	GLint num_banks;
	GLint r7xx_bank_op;
a108 15

	GLuint vbl_waited;

	/* buffer swap */
	int64_t swap_ust;
	int64_t swap_missed_ust;

	GLuint swap_count;
	GLuint swap_missed_count;

	/* Drawable page flipping state */
	GLboolean pf_active;
	GLint pf_current_page;
	GLint pf_num_pages;

a112 1
	GLuint clear;
a118 1
	GLuint clear;
a124 8

	GLuint numClipRects;	/* Cliprects active */
	GLuint numAllocedClipRects;	/* Cliprects available */
	drm_clip_rect_t *pClipRects;
};

struct radeon_stencilbuffer_state {
	GLuint clear;		/* rb3d_stencilrefmask value */
d152 5
d158 1
a158 1
	struct gl_texture_image base;
d170 1
a170 3

	int mtlevel; /** if mt != 0, this is the image's level in the mipmap tree */
	int mtface; /** if mt != 0, this is the image's face in the mipmap tree */
a212 22
        GLuint pp_txfilter_1;	/*  r300 */

	/* r700 texture states */
	GLuint SQ_TEX_RESOURCE0;
	GLuint SQ_TEX_RESOURCE1;
	GLuint SQ_TEX_RESOURCE2;
	GLuint SQ_TEX_RESOURCE3;
	GLuint SQ_TEX_RESOURCE4;
	GLuint SQ_TEX_RESOURCE5;
	GLuint SQ_TEX_RESOURCE6;

    GLuint SQ_TEX_RESOURCE7;

	GLuint SQ_TEX_SAMPLER0;
	GLuint SQ_TEX_SAMPLER1;
	GLuint SQ_TEX_SAMPLER2;

	GLuint TD_PS_SAMPLER0_BORDER_RED;
	GLuint TD_PS_SAMPLER0_BORDER_GREEN;
	GLuint TD_PS_SAMPLER0_BORDER_BLUE;
	GLuint TD_PS_SAMPLER0_BORDER_ALPHA;

a213 2


a369 1
	struct radeon_stencilbuffer_state stencil;
d387 1
a387 1
   struct gl_context *glCtx;
d405 1
a405 1
   DECLARE_RENDERINPUTS(tnl_index_bitset);	/* index of bits for last tnl_install_attrs */
d407 1
a407 3
   /* Drawable, cliprect and scissor information */
   GLuint numClipRects;	/* Cliprects for the draw buffer */
   drm_clip_rect_t *pClipRects;
a433 1
  GLboolean constant_cliprect; /* use for FBO or DRI2 rendering */
d477 1
a477 1
	   unsigned (*check_blit)(gl_format mesa_format);
d502 4
a505 1
#define RADEON_CONTEXT(glctx) ((radeonContextPtr)(ctx->DriverCtx))
a514 45
}

/**
 * This function takes a float and packs it into a uint32_t
 */
static INLINE uint32_t radeonPackFloat32(float fl)
{
	union {
		float fl;
		uint32_t u;
	} u;

	u.fl = fl;
	return u.u;
}

/* This is probably wrong for some values, I need to test this
 * some more.  Range checking would be a good idea also..
 *
 * But it works for most things.  I'll fix it later if someone
 * else with a better clue doesn't
 */
static INLINE uint32_t radeonPackFloat24(float f)
{
	float mantissa;
	int exponent;
	uint32_t float24 = 0;

	if (f == 0.0)
		return 0;

	mantissa = frexpf(f, &exponent);

	/* Handle -ve */
	if (mantissa < 0) {
		float24 |= (1 << 23);
		mantissa = mantissa * -1.0;
	}
	/* Handle exponent, bias of 63 */
	exponent += 62;
	float24 |= (exponent << 16);
	/* Kill 7 LSB of mantissa */
	float24 |= (radeonPackFloat32(mantissa) & 0x7FFFFF) >> 7;

	return float24;
@


1.2
log
@Merge Mesa 7.10.3
@
text
@a16 1
#include "dri_metaops.h"
a509 2

   struct dri_metaops meta;
@


1.1
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d96 7
d162 2
a163 2
        int (*check) (GLcontext *, struct radeon_state_atom *atom); /* is this state active? */
        void (*emit) (GLcontext *, struct radeon_state_atom *atom);
d247 2
d319 1
a319 1
        void (*flush) (GLcontext *);
d435 1
a435 1
   GLcontext *glCtx;
d521 1
a521 1
	   void (*update_viewport_offset)(GLcontext *ctx);
d523 1
a523 1
	   void (*swtcl_flush)(GLcontext *ctx, uint32_t offset);
d526 2
a527 2
	   void (*fallback)(GLcontext *ctx, GLuint bit, GLboolean mode);
	   void (*free_context)(GLcontext *ctx);
d529 1
a529 1
	   void (*update_scissor)(GLcontext *ctx);
d531 1
a531 1
	   unsigned (*blit)(GLcontext *ctx,
d551 1
d614 1
a614 1
			    const __GLcontextModes * glVisual,
d626 1
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@a95 7

	/* r6xx+ tiling */
	GLuint tile_config;
	GLint group_bytes;
	GLint num_channels;
	GLint num_banks;
	GLint r7xx_bank_op;
d155 2
a156 2
        int (*check) (struct gl_context *, struct radeon_state_atom *atom); /* is this state active? */
        void (*emit) (struct gl_context *, struct radeon_state_atom *atom);
a239 2
    GLuint SQ_TEX_RESOURCE7;

d310 1
a310 1
        void (*flush) (struct gl_context *);
d426 1
a426 1
   struct gl_context *glCtx;
d512 1
a512 1
	   void (*update_viewport_offset)(struct gl_context *ctx);
d514 1
a514 1
	   void (*swtcl_flush)(struct gl_context *ctx, uint32_t offset);
d517 2
a518 2
	   void (*fallback)(struct gl_context *ctx, GLuint bit, GLboolean mode);
	   void (*free_context)(struct gl_context *ctx);
d520 1
a520 1
	   void (*update_scissor)(struct gl_context *ctx);
d522 1
a522 1
	   unsigned (*blit)(struct gl_context *ctx,
a541 1
	   unsigned (*is_format_renderable)(gl_format mesa_format);
d604 1
a604 1
			    const struct gl_config * glVisual,
a615 1
void radeon_prepare_render(radeonContextPtr radeon);
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@d7 1
a15 1
#include "swrast/s_context.h"
d17 1
d20 1
a20 2
#include "radeon_bo_gem.h"
#include "radeon_cs_gem.h"
d83 1
a83 2
	struct swrast_renderbuffer base;

a88 6
	struct radeon_bo *map_bo;
	GLbitfield map_mode;
	int map_x, map_y, map_w, map_h;
	int map_pitch;
	void *map_buffer;

d94 1
d96 7
d110 15
d129 1
d136 1
d143 8
a177 5

/**
 * This is a subclass of swrast_texture_image since we use swrast
 * for software fallback rendering.
 */
d179 1
a179 1
	struct swrast_texture_image base;
d191 3
a193 1
	GLboolean used_as_render_target;
d236 22
d259 2
d417 1
d435 1
a435 1
   struct gl_context glCtx;             /**< base class, must be first */
d453 1
a453 1
   GLbitfield64 tnl_index_bitset;	/* index of bits for last tnl_install_attrs */
d455 3
a457 1
   /* Drawable information */
d484 1
d512 2
d530 1
a530 1
	   unsigned (*check_blit)(gl_format mesa_format, uint32_t dst_pitch);
d555 1
a555 4
static inline radeonContextPtr RADEON_CONTEXT(struct gl_context *ctx)
{
	return (radeonContextPtr) ctx;
}
d565 45
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d10 1
a11 1
#include "radeon_debug.h"
d477 1
a477 1
	   unsigned (*check_blit)(mesa_format mesa_format, uint32_t dst_pitch);
d481 1
a481 1
                        mesa_format src_mesaformat,
d489 1
a489 1
                        mesa_format dst_mesaformat,
d498 1
a498 1
	   unsigned (*is_format_renderable)(mesa_format mesa_format);
a517 1
                            gl_api api,
@


1.1.1.4
log
@Import Mesa 10.2.7
@
text
@a498 1
	   GLboolean (*revalidate_all_buffers)(struct gl_context *ctx);
@


1.1.1.5
log
@Import Mesa 10.4.3
@
text
@d409 1
d467 3
d471 1
a516 4

extern const char const *radeonVendorString;

const char *radeonGetRendererString(radeonScreenPtr radeonScreen);
@


1.1.1.6
log
@Import Mesa 10.2.9
@
text
@a408 1
   drm_radeon_sarea_t *sarea;	/* Private SAREA data */
a465 3
	   void (*get_lock)(radeonContextPtr radeon);
	   void (*update_viewport_offset)(struct gl_context *ctx);
	   void (*emit_cs_header)(struct radeon_cs *cs, radeonContextPtr rmesa);
a466 1
	   void (*pre_emit_atoms)(radeonContextPtr rmesa);
d512 4
@


