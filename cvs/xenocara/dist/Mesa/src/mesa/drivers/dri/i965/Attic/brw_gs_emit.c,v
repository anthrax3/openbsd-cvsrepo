head	1.9;
access;
symbols
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	v10_2_9:1.1.1.5
	v10_2_7:1.1.1.5
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	v10_2_3:1.1.1.5
	OPENBSD_5_5:1.5.0.2
	OPENBSD_5_5_BASE:1.5
	v9_2_5:1.1.1.4
	v9_2_3:1.1.1.4
	v9_2_2:1.1.1.4
	v9_2_1:1.1.1.4
	v9_2_0:1.1.1.4
	OPENBSD_5_4:1.4.0.8
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.3
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v7_0_1:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v6_5_2:1.1.1.1
	v6_5_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.8;
commitid	TnlogFl9nOv2eaRf;

1.8
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.7;
commitid	4ry2gvZGMXkCUD2n;

1.7
date	2015.01.25.14.41.21;	author jsg;	state dead;
branches;
next	1.6;
commitid	mcxB0JvoI9gTDYXU;

1.6
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.5;
commitid	WPD6rgPryPkvXOr9;

1.5
date	2013.09.05.14.04.19;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.52.44;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.18.52.44;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.28.35;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.05.13.15.35;	author jsg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.07.09.20.34.50;	author jsg;	state Exp;
branches;
next	;
commitid	3JhLfwcuBALP0ZR7;


desc
@@


1.9
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 Copyright (C) Intel Corp.  2006.  All Rights Reserved.
 Intel funded Tungsten Graphics to
 develop this 3D driver.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:

 The above copyright notice and this permission notice (including the
 next paragraph) shall be included in all copies or substantial
 portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 **********************************************************************/
 /*
  * Authors:
  *   Keith Whitwell <keithw@@vmware.com>
  */


#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"

#include "program/program.h"
#include "intel_batchbuffer.h"

#include "brw_defines.h"
#include "brw_context.h"
#include "brw_eu.h"
#include "brw_gs.h"

/**
 * Allocate registers for GS.
 *
 * If sol_program is true, then:
 *
 * - The thread will be spawned with the "SVBI Payload Enable" bit set, so GRF
 *   1 needs to be set aside to hold the streamed vertex buffer indices.
 *
 * - The thread will need to use the destination_indices register.
 */
static void brw_ff_gs_alloc_regs(struct brw_ff_gs_compile *c,
                                 GLuint nr_verts,
                                 bool sol_program)
{
   GLuint i = 0,j;

   /* Register usage is static, precompute here:
    */
   c->reg.R0 = retype(brw_vec8_grf(i, 0), BRW_REGISTER_TYPE_UD); i++;

   /* Streamed vertex buffer indices */
   if (sol_program)
      c->reg.SVBI = retype(brw_vec8_grf(i++, 0), BRW_REGISTER_TYPE_UD);

   /* Payload vertices plus space for more generated vertices:
    */
   for (j = 0; j < nr_verts; j++) {
      c->reg.vertex[j] = brw_vec4_grf(i, 0);
      i += c->nr_regs;
   }

   c->reg.header = retype(brw_vec8_grf(i++, 0), BRW_REGISTER_TYPE_UD);
   c->reg.temp = retype(brw_vec8_grf(i++, 0), BRW_REGISTER_TYPE_UD);

   if (sol_program) {
      c->reg.destination_indices =
         retype(brw_vec4_grf(i++, 0), BRW_REGISTER_TYPE_UD);
   }

   c->prog_data.urb_read_length = c->nr_regs;
   c->prog_data.total_grf = i;
}


/**
 * Set up the initial value of c->reg.header register based on c->reg.R0.
 *
 * The following information is passed to the GS thread in R0, and needs to be
 * included in the first URB_WRITE or FF_SYNC message sent by the GS:
 *
 * - DWORD 0 [31:0] handle info (Gen4 only)
 * - DWORD 5 [7:0] FFTID
 * - DWORD 6 [31:0] Debug info
 * - DWORD 7 [31:0] Debug info
 *
 * This function sets up the above data by copying by copying the contents of
 * R0 to the header register.
 */
static void brw_ff_gs_initialize_header(struct brw_ff_gs_compile *c)
{
   struct brw_compile *p = &c->func;
   brw_MOV(p, c->reg.header, c->reg.R0);
}

/**
 * Overwrite DWORD 2 of c->reg.header with the given immediate unsigned value.
 *
 * In URB_WRITE messages, DWORD 2 contains the fields PrimType, PrimStart,
 * PrimEnd, Increment CL_INVOCATIONS, and SONumPrimsWritten, many of which we
 * need to be able to update on a per-vertex basis.
 */
static void brw_ff_gs_overwrite_header_dw2(struct brw_ff_gs_compile *c,
                                           unsigned dw2)
{
   struct brw_compile *p = &c->func;
   brw_MOV(p, get_element_ud(c->reg.header, 2), brw_imm_ud(dw2));
}

/**
 * Overwrite DWORD 2 of c->reg.header with the primitive type from c->reg.R0.
 *
 * When the thread is spawned, GRF 0 contains the primitive type in bits 4:0
 * of DWORD 2.  URB_WRITE messages need the primitive type in bits 6:2 of
 * DWORD 2.  So this function extracts the primitive type field, bitshifts it
 * appropriately, and stores it in c->reg.header.
 */
static void brw_ff_gs_overwrite_header_dw2_from_r0(struct brw_ff_gs_compile *c)
{
   struct brw_compile *p = &c->func;
   brw_AND(p, get_element_ud(c->reg.header, 2), get_element_ud(c->reg.R0, 2),
           brw_imm_ud(0x1f));
   brw_SHL(p, get_element_ud(c->reg.header, 2),
           get_element_ud(c->reg.header, 2), brw_imm_ud(2));
}

/**
 * Apply an additive offset to DWORD 2 of c->reg.header.
 *
 * This is used to set/unset the "PrimStart" and "PrimEnd" flags appropriately
 * for each vertex.
 */
static void brw_ff_gs_offset_header_dw2(struct brw_ff_gs_compile *c,
                                        int offset)
{
   struct brw_compile *p = &c->func;
   brw_ADD(p, get_element_d(c->reg.header, 2), get_element_d(c->reg.header, 2),
           brw_imm_d(offset));
}


/**
 * Emit a vertex using the URB_WRITE message.  Use the contents of
 * c->reg.header for the message header, and the registers starting at \c vert
 * for the vertex data.
 *
 * If \c last is true, then this is the last vertex, so no further URB space
 * should be allocated, and this message should end the thread.
 *
 * If \c last is false, then a new URB entry will be allocated, and its handle
 * will be stored in DWORD 0 of c->reg.header for use in the next URB_WRITE
 * message.
 */
static void brw_ff_gs_emit_vue(struct brw_ff_gs_compile *c,
                               struct brw_reg vert,
                               bool last)
{
   struct brw_compile *p = &c->func;
   int write_offset = 0;
   bool complete = false;

   do {
      /* We can't write more than 14 registers at a time to the URB */
      int write_len = MIN2(c->nr_regs - write_offset, 14);
      if (write_len == c->nr_regs - write_offset)
         complete = true;

      /* Copy the vertex from vertn into m1..mN+1:
       */
      brw_copy8(p, brw_message_reg(1), offset(vert, write_offset), write_len);

      /* Send the vertex data to the URB.  If this is the last write for this
       * vertex, then we mark it as complete, and either end the thread or
       * allocate another vertex URB entry (depending whether this is the last
       * vertex).
       */
      enum brw_urb_write_flags flags;
      if (!complete)
         flags = BRW_URB_WRITE_NO_FLAGS;
      else if (last)
         flags = BRW_URB_WRITE_EOT_COMPLETE;
      else
         flags = BRW_URB_WRITE_ALLOCATE_COMPLETE;
      brw_urb_WRITE(p,
                    (flags & BRW_URB_WRITE_ALLOCATE) ? c->reg.temp
                    : retype(brw_null_reg(), BRW_REGISTER_TYPE_UD),
                    0,
                    c->reg.header,
                    flags,
                    write_len + 1, /* msg length */
                    (flags & BRW_URB_WRITE_ALLOCATE) ? 1
                    : 0, /* response length */
                    write_offset,  /* urb offset */
                    BRW_URB_SWIZZLE_NONE);
      write_offset += write_len;
   } while (!complete);

   if (!last) {
      brw_MOV(p, get_element_ud(c->reg.header, 0),
              get_element_ud(c->reg.temp, 0));
   }
}

/**
 * Send an FF_SYNC message to ensure that all previously spawned GS threads
 * have finished sending primitives down the pipeline, and to allocate a URB
 * entry for the first output vertex.  Only needed on Ironlake+.
 *
 * This function modifies c->reg.header: in DWORD 1, it stores num_prim (which
 * is needed by the FF_SYNC message), and in DWORD 0, it stores the handle to
 * the allocated URB entry (which will be needed by the URB_WRITE meesage that
 * follows).
 */
static void brw_ff_gs_ff_sync(struct brw_ff_gs_compile *c, int num_prim)
{
   struct brw_compile *p = &c->func;

   brw_MOV(p, get_element_ud(c->reg.header, 1), brw_imm_ud(num_prim));
   brw_ff_sync(p,
               c->reg.temp,
               0,
               c->reg.header,
               1, /* allocate */
               1, /* response length */
               0 /* eot */);
   brw_MOV(p, get_element_ud(c->reg.header, 0),
           get_element_ud(c->reg.temp, 0));
}


void
brw_ff_gs_quads(struct brw_ff_gs_compile *c, struct brw_ff_gs_prog_key *key)
{
   struct brw_context *brw = c->func.brw;

   brw_ff_gs_alloc_regs(c, 4, false);
   brw_ff_gs_initialize_header(c);
   /* Use polygons for correct edgeflag behaviour. Note that vertex 3
    * is the PV for quads, but vertex 0 for polygons:
    */
   if (brw->gen == 5)
      brw_ff_gs_ff_sync(c, 1);
   brw_ff_gs_overwrite_header_dw2(
      c, ((_3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT)
          | URB_WRITE_PRIM_START));
   if (key->pv_first) {
      brw_ff_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_ff_gs_overwrite_header_dw2(
         c, _3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT);
      brw_ff_gs_emit_vue(c, c->reg.vertex[1], 0);
      brw_ff_gs_emit_vue(c, c->reg.vertex[2], 0);
      brw_ff_gs_overwrite_header_dw2(
         c, ((_3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT)
             | URB_WRITE_PRIM_END));
      brw_ff_gs_emit_vue(c, c->reg.vertex[3], 1);
   }
   else {
      brw_ff_gs_emit_vue(c, c->reg.vertex[3], 0);
      brw_ff_gs_overwrite_header_dw2(
         c, _3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT);
      brw_ff_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_ff_gs_emit_vue(c, c->reg.vertex[1], 0);
      brw_ff_gs_overwrite_header_dw2(
         c, ((_3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT)
             | URB_WRITE_PRIM_END));
      brw_ff_gs_emit_vue(c, c->reg.vertex[2], 1);
   }
}

void
brw_ff_gs_quad_strip(struct brw_ff_gs_compile *c,
                     struct brw_ff_gs_prog_key *key)
{
   struct brw_context *brw = c->func.brw;

   brw_ff_gs_alloc_regs(c, 4, false);
   brw_ff_gs_initialize_header(c);

   if (brw->gen == 5)
      brw_ff_gs_ff_sync(c, 1);
   brw_ff_gs_overwrite_header_dw2(
      c, ((_3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT)
          | URB_WRITE_PRIM_START));
   if (key->pv_first) {
      brw_ff_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_ff_gs_overwrite_header_dw2(
         c, _3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT);
      brw_ff_gs_emit_vue(c, c->reg.vertex[1], 0);
      brw_ff_gs_emit_vue(c, c->reg.vertex[2], 0);
      brw_ff_gs_overwrite_header_dw2(
         c, ((_3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT)
             | URB_WRITE_PRIM_END));
      brw_ff_gs_emit_vue(c, c->reg.vertex[3], 1);
   }
   else {
      brw_ff_gs_emit_vue(c, c->reg.vertex[2], 0);
      brw_ff_gs_overwrite_header_dw2(
         c, _3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT);
      brw_ff_gs_emit_vue(c, c->reg.vertex[3], 0);
      brw_ff_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_ff_gs_overwrite_header_dw2(
         c, ((_3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT)
             | URB_WRITE_PRIM_END));
      brw_ff_gs_emit_vue(c, c->reg.vertex[1], 1);
   }
}

void brw_ff_gs_lines(struct brw_ff_gs_compile *c)
{
   struct brw_context *brw = c->func.brw;

   brw_ff_gs_alloc_regs(c, 2, false);
   brw_ff_gs_initialize_header(c);

   if (brw->gen == 5)
      brw_ff_gs_ff_sync(c, 1);
   brw_ff_gs_overwrite_header_dw2(
      c, ((_3DPRIM_LINESTRIP << URB_WRITE_PRIM_TYPE_SHIFT)
          | URB_WRITE_PRIM_START));
   brw_ff_gs_emit_vue(c, c->reg.vertex[0], 0);
   brw_ff_gs_overwrite_header_dw2(
      c, ((_3DPRIM_LINESTRIP << URB_WRITE_PRIM_TYPE_SHIFT)
          | URB_WRITE_PRIM_END));
   brw_ff_gs_emit_vue(c, c->reg.vertex[1], 1);
}

/**
 * Generate the geometry shader program used on Gen6 to perform stream output
 * (transform feedback).
 */
void
gen6_sol_program(struct brw_ff_gs_compile *c, struct brw_ff_gs_prog_key *key,
	         unsigned num_verts, bool check_edge_flags)
{
   struct brw_compile *p = &c->func;
   c->prog_data.svbi_postincrement_value = num_verts;

   brw_ff_gs_alloc_regs(c, num_verts, true);
   brw_ff_gs_initialize_header(c);

   if (key->num_transform_feedback_bindings > 0) {
      unsigned vertex, binding;
      struct brw_reg destination_indices_uw =
         vec8(retype(c->reg.destination_indices, BRW_REGISTER_TYPE_UW));

      /* Note: since we use the binding table to keep track of buffer offsets
       * and stride, the GS doesn't need to keep track of a separate pointer
       * into each buffer; it uses a single pointer which increments by 1 for
       * each vertex.  So we use SVBI0 for this pointer, regardless of whether
       * transform feedback is in interleaved or separate attribs mode.
       *
       * Make sure that the buffers have enough room for all the vertices.
       */
      brw_ADD(p, get_element_ud(c->reg.temp, 0),
	         get_element_ud(c->reg.SVBI, 0), brw_imm_ud(num_verts));
      brw_CMP(p, vec1(brw_null_reg()), BRW_CONDITIONAL_LE,
	         get_element_ud(c->reg.temp, 0),
	         get_element_ud(c->reg.SVBI, 4));
      brw_IF(p, BRW_EXECUTE_1);

      /* Compute the destination indices to write to.  Usually we use SVBI[0]
       * + (0, 1, 2).  However, for odd-numbered triangles in tristrips, the
       * vertices come down the pipeline in reversed winding order, so we need
       * to flip the order when writing to the transform feedback buffer.  To
       * ensure that flatshading accuracy is preserved, we need to write them
       * in order SVBI[0] + (0, 2, 1) if we're using the first provoking
       * vertex convention, and in order SVBI[0] + (1, 0, 2) if we're using
       * the last provoking vertex convention.
       *
       * Note: since brw_imm_v can only be used in instructions in
       * packed-word execution mode, and SVBI is a double-word, we need to
       * first move the appropriate immediate constant ((0, 1, 2), (0, 2, 1),
       * or (1, 0, 2)) to the destination_indices register, and then add SVBI
       * using a separate instruction.  Also, since the immediate constant is
       * expressed as packed words, and we need to load double-words into
       * destination_indices, we need to intersperse zeros to fill the upper
       * halves of each double-word.
       */
      brw_MOV(p, destination_indices_uw,
              brw_imm_v(0x00020100)); /* (0, 1, 2) */
      if (num_verts == 3) {
         /* Get primitive type into temp register. */
         brw_AND(p, get_element_ud(c->reg.temp, 0),
                 get_element_ud(c->reg.R0, 2), brw_imm_ud(0x1f));

         /* Test if primitive type is TRISTRIP_REVERSE.  We need to do this as
          * an 8-wide comparison so that the conditional MOV that follows
          * moves all 8 words correctly.
          */
         brw_CMP(p, vec8(brw_null_reg()), BRW_CONDITIONAL_EQ,
                 get_element_ud(c->reg.temp, 0),
                 brw_imm_ud(_3DPRIM_TRISTRIP_REVERSE));

         /* If so, then overwrite destination_indices_uw with the appropriate
          * reordering.
          */
         brw_MOV(p, destination_indices_uw,
                 brw_imm_v(key->pv_first ? 0x00010200    /* (0, 2, 1) */
                                         : 0x00020001)); /* (1, 0, 2) */
         brw_set_predicate_control(p, BRW_PREDICATE_NONE);
      }
      brw_ADD(p, c->reg.destination_indices,
              c->reg.destination_indices, get_element_ud(c->reg.SVBI, 0));

      /* For each vertex, generate code to output each varying using the
       * appropriate binding table entry.
       */
      for (vertex = 0; vertex < num_verts; ++vertex) {
         /* Set up the correct destination index for this vertex */
         brw_MOV(p, get_element_ud(c->reg.header, 5),
                 get_element_ud(c->reg.destination_indices, vertex));

         for (binding = 0; binding < key->num_transform_feedback_bindings;
              ++binding) {
            unsigned char varying =
               key->transform_feedback_bindings[binding];
            unsigned char slot = c->vue_map.varying_to_slot[varying];
            /* From the Sandybridge PRM, Volume 2, Part 1, Section 4.5.1:
             *
             *   "Prior to End of Thread with a URB_WRITE, the kernel must
             *   ensure that all writes are complete by sending the final
             *   write as a committed write."
             */
            bool final_write =
               binding == key->num_transform_feedback_bindings - 1 &&
               vertex == num_verts - 1;
            struct brw_reg vertex_slot = c->reg.vertex[vertex];
            vertex_slot.nr += slot / 2;
            vertex_slot.subnr = (slot % 2) * 16;
            /* gl_PointSize is stored in VARYING_SLOT_PSIZ.w. */
            vertex_slot.dw1.bits.swizzle = varying == VARYING_SLOT_PSIZ
               ? BRW_SWIZZLE_WWWW : key->transform_feedback_swizzles[binding];
            brw_set_access_mode(p, BRW_ALIGN_16);
            brw_MOV(p, stride(c->reg.header, 4, 4, 1),
                    retype(vertex_slot, BRW_REGISTER_TYPE_UD));
            brw_set_access_mode(p, BRW_ALIGN_1);
            brw_svb_write(p,
                          final_write ? c->reg.temp : brw_null_reg(), /* dest */
                          1, /* msg_reg_nr */
                          c->reg.header, /* src0 */
                          SURF_INDEX_GEN6_SOL_BINDING(binding), /* binding_table_index */
                          final_write); /* send_commit_msg */
         }
      }
      brw_ENDIF(p);

      /* Now, reinitialize the header register from R0 to restore the parts of
       * the register that we overwrote while streaming out transform feedback
       * data.
       */
      brw_ff_gs_initialize_header(c);

      /* Finally, wait for the write commit to occur so that we can proceed to
       * other things safely.
       *
       * From the Sandybridge PRM, Volume 4, Part 1, Section 3.3:
       *
       *   The write commit does not modify the destination register, but
       *   merely clears the dependency associated with the destination
       *   register. Thus, a simple “mov” instruction using the register as a
       *   source is sufficient to wait for the write commit to occur.
       */
      brw_MOV(p, c->reg.temp, c->reg.temp);
   }

   brw_ff_gs_ff_sync(c, 1);

   brw_ff_gs_overwrite_header_dw2_from_r0(c);
   switch (num_verts) {
   case 1:
      brw_ff_gs_offset_header_dw2(c,
                                  URB_WRITE_PRIM_START | URB_WRITE_PRIM_END);
      brw_ff_gs_emit_vue(c, c->reg.vertex[0], true);
      break;
   case 2:
      brw_ff_gs_offset_header_dw2(c, URB_WRITE_PRIM_START);
      brw_ff_gs_emit_vue(c, c->reg.vertex[0], false);
      brw_ff_gs_offset_header_dw2(c,
                                  URB_WRITE_PRIM_END - URB_WRITE_PRIM_START);
      brw_ff_gs_emit_vue(c, c->reg.vertex[1], true);
      break;
   case 3:
      if (check_edge_flags) {
         /* Only emit vertices 0 and 1 if this is the first triangle of the
          * polygon.  Otherwise they are redundant.
          */
         brw_set_conditionalmod(p, BRW_CONDITIONAL_NZ);
         brw_AND(p, retype(brw_null_reg(), BRW_REGISTER_TYPE_UD),
                 get_element_ud(c->reg.R0, 2),
                 brw_imm_ud(BRW_GS_EDGE_INDICATOR_0));
         brw_IF(p, BRW_EXECUTE_1);
      }
      brw_ff_gs_offset_header_dw2(c, URB_WRITE_PRIM_START);
      brw_ff_gs_emit_vue(c, c->reg.vertex[0], false);
      brw_ff_gs_offset_header_dw2(c, -URB_WRITE_PRIM_START);
      brw_ff_gs_emit_vue(c, c->reg.vertex[1], false);
      if (check_edge_flags) {
         brw_ENDIF(p);
         /* Only emit vertex 2 in PRIM_END mode if this is the last triangle
          * of the polygon.  Otherwise leave the primitive incomplete because
          * there are more polygon vertices coming.
          */
         brw_set_conditionalmod(p, BRW_CONDITIONAL_NZ);
         brw_AND(p, retype(brw_null_reg(), BRW_REGISTER_TYPE_UD),
                 get_element_ud(c->reg.R0, 2),
                 brw_imm_ud(BRW_GS_EDGE_INDICATOR_1));
         brw_set_predicate_control(p, BRW_PREDICATE_NORMAL);
      }
      brw_ff_gs_offset_header_dw2(c, URB_WRITE_PRIM_END);
      brw_set_predicate_control(p, BRW_PREDICATE_NONE);
      brw_ff_gs_emit_vue(c, c->reg.vertex[2], true);
      break;
   }
}
@


1.8
log
@Merge Mesa 10.2.9
@
text
@@


1.7
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@@


1.6
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@@


1.5
log
@Merge Mesa 9.2.0
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
d5 1
a5 1
 
d13 1
a13 1
 
d17 1
a17 1
 
d25 1
a25 1
 
d29 1
a29 1
  *   Keith Whitwell <keith@@tungstengraphics.com>
d31 1
a31 1
 
d55 3
a57 3
static void brw_gs_alloc_regs( struct brw_gs_compile *c,
			       GLuint nr_verts,
                               bool sol_program )
d84 1
a84 1
   c->prog_data.urb_read_length = c->nr_regs; 
d103 1
a103 1
static void brw_gs_initialize_header(struct brw_gs_compile *c)
d116 2
a117 2
static void brw_gs_overwrite_header_dw2(struct brw_gs_compile *c,
                                        unsigned dw2)
d131 1
a131 1
static void brw_gs_overwrite_header_dw2_from_r0(struct brw_gs_compile *c)
d146 2
a147 1
static void brw_gs_offset_header_dw2(struct brw_gs_compile *c, int offset)
d167 3
a169 3
static void brw_gs_emit_vue(struct brw_gs_compile *c, 
			    struct brw_reg vert,
			    bool last)
d172 8
a179 1
   bool allocate = !last;
d181 3
a183 3
   /* Copy the vertex from vertn into m1..mN+1:
    */
   brw_copy8(p, brw_message_reg(1), vert, c->nr_regs);
d185 25
a209 19
   /* Send each vertex as a seperate write to the urb.  This is
    * different to the concept in brw_sf_emit.c, where subsequent
    * writes are used to build up a single urb entry.  Each of these
    * writes instantiates a seperate urb entry, and a new one must be
    * allocated each time.
    */
   brw_urb_WRITE(p, 
		 allocate ? c->reg.temp
                          : retype(brw_null_reg(), BRW_REGISTER_TYPE_UD),
		 0,
		 c->reg.header,
		 allocate,
		 1,		/* used */
		 c->nr_regs + 1, /* msg length */
		 allocate ? 1 : 0, /* response length */
		 allocate ? 0 : 1, /* eot */
		 1,		/* writes_complete */
		 0,		/* urb offset */
		 BRW_URB_SWIZZLE_NONE);
d211 1
a211 1
   if (allocate) {
d227 1
a227 1
static void brw_gs_ff_sync(struct brw_gs_compile *c, int num_prim)
d244 2
a245 1
void brw_gs_quads( struct brw_gs_compile *c, struct brw_gs_prog_key *key )
d249 2
a250 2
   brw_gs_alloc_regs(c, 4, false);
   brw_gs_initialize_header(c);
d255 2
a256 2
      brw_gs_ff_sync(c, 1);
   brw_gs_overwrite_header_dw2(
d260 2
a261 2
      brw_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_gs_overwrite_header_dw2(
d263 3
a265 3
      brw_gs_emit_vue(c, c->reg.vertex[1], 0);
      brw_gs_emit_vue(c, c->reg.vertex[2], 0);
      brw_gs_overwrite_header_dw2(
d268 1
a268 1
      brw_gs_emit_vue(c, c->reg.vertex[3], 1);
d271 2
a272 2
      brw_gs_emit_vue(c, c->reg.vertex[3], 0);
      brw_gs_overwrite_header_dw2(
d274 3
a276 3
      brw_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_gs_emit_vue(c, c->reg.vertex[1], 0);
      brw_gs_overwrite_header_dw2(
d279 1
a279 1
      brw_gs_emit_vue(c, c->reg.vertex[2], 1);
d283 3
a285 1
void brw_gs_quad_strip( struct brw_gs_compile *c, struct brw_gs_prog_key *key )
d289 3
a291 3
   brw_gs_alloc_regs(c, 4, false);
   brw_gs_initialize_header(c);
   
d293 2
a294 2
      brw_gs_ff_sync(c, 1);
   brw_gs_overwrite_header_dw2(
d298 2
a299 2
      brw_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_gs_overwrite_header_dw2(
d301 3
a303 3
      brw_gs_emit_vue(c, c->reg.vertex[1], 0);
      brw_gs_emit_vue(c, c->reg.vertex[2], 0);
      brw_gs_overwrite_header_dw2(
d306 1
a306 1
      brw_gs_emit_vue(c, c->reg.vertex[3], 1);
d309 2
a310 2
      brw_gs_emit_vue(c, c->reg.vertex[2], 0);
      brw_gs_overwrite_header_dw2(
d312 3
a314 3
      brw_gs_emit_vue(c, c->reg.vertex[3], 0);
      brw_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_gs_overwrite_header_dw2(
d317 1
a317 1
      brw_gs_emit_vue(c, c->reg.vertex[1], 1);
d321 1
a321 1
void brw_gs_lines( struct brw_gs_compile *c )
d325 2
a326 2
   brw_gs_alloc_regs(c, 2, false);
   brw_gs_initialize_header(c);
d329 2
a330 2
      brw_gs_ff_sync(c, 1);
   brw_gs_overwrite_header_dw2(
d333 2
a334 2
   brw_gs_emit_vue(c, c->reg.vertex[0], 0);
   brw_gs_overwrite_header_dw2(
d337 1
a337 1
   brw_gs_emit_vue(c, c->reg.vertex[1], 1);
d345 1
a345 1
gen6_sol_program(struct brw_gs_compile *c, struct brw_gs_prog_key *key,
d351 2
a352 2
   brw_gs_alloc_regs(c, num_verts, true);
   brw_gs_initialize_header(c);
d454 1
a454 1
                          SURF_INDEX_SOL_BINDING(binding), /* binding_table_index */
d464 1
a464 1
      brw_gs_initialize_header(c);
d479 1
a479 1
   brw_gs_ff_sync(c, 1);
d481 1
a481 1
   brw_gs_overwrite_header_dw2_from_r0(c);
d484 3
a486 2
      brw_gs_offset_header_dw2(c, URB_WRITE_PRIM_START | URB_WRITE_PRIM_END);
      brw_gs_emit_vue(c, c->reg.vertex[0], true);
d489 5
a493 4
      brw_gs_offset_header_dw2(c, URB_WRITE_PRIM_START);
      brw_gs_emit_vue(c, c->reg.vertex[0], false);
      brw_gs_offset_header_dw2(c, URB_WRITE_PRIM_END - URB_WRITE_PRIM_START);
      brw_gs_emit_vue(c, c->reg.vertex[1], true);
d506 4
a509 4
      brw_gs_offset_header_dw2(c, URB_WRITE_PRIM_START);
      brw_gs_emit_vue(c, c->reg.vertex[0], false);
      brw_gs_offset_header_dw2(c, -URB_WRITE_PRIM_START);
      brw_gs_emit_vue(c, c->reg.vertex[1], false);
d522 1
a522 1
      brw_gs_offset_header_dw2(c, URB_WRITE_PRIM_END);
d524 1
a524 1
      brw_gs_emit_vue(c, c->reg.vertex[2], true);
@


1.4
log
@Merge Mesa 7.10.3
@
text
@d45 10
d56 2
a57 1
			       GLuint nr_verts )
d65 4
d76 7
a82 1
   c->reg.temp = brw_vec8_grf(i, 0);
d89 77
d168 1
a168 2
			    GLboolean last,
			    GLuint header)
d171 1
a171 16
   struct intel_context *intel = &c->func.brw->intel;
   GLboolean allocate = !last;
   struct brw_reg temp;

   if (intel->gen < 6)
       temp = c->reg.R0;
   else {
       temp = c->reg.temp;
       brw_MOV(p, retype(temp, BRW_REGISTER_TYPE_UD),
	       retype(c->reg.R0, BRW_REGISTER_TYPE_UD));
   }

   /* Overwrite PrimType and PrimStart in the message header, for
    * each vertex in turn:
    */
   brw_MOV(p, get_element_ud(temp, 2), brw_imm_ud(header));
d184 2
a185 1
		 allocate ? temp : retype(brw_null_reg(), BRW_REGISTER_TYPE_UD),
d187 1
a187 1
		 temp,
d197 4
a200 2
   if (intel->gen >= 6 && allocate)
       brw_MOV(p, get_element_ud(c->reg.R0, 0), get_element_ud(temp, 0));
d203 10
d215 1
a215 2
	struct brw_compile *p = &c->func;
	struct intel_context *intel = &c->func.brw->intel;
d217 10
a226 23
	if (intel->gen < 6) {
	    brw_MOV(p, get_element_ud(c->reg.R0, 1), brw_imm_ud(num_prim));
	    brw_ff_sync(p,
		        c->reg.R0,
			0,
			c->reg.R0,
			1, /* allocate */
			1, /* response length */
			0 /* eot */);
	} else {
	    brw_MOV(p, retype(c->reg.temp, BRW_REGISTER_TYPE_UD),
		    retype(c->reg.R0, BRW_REGISTER_TYPE_UD));
	    brw_MOV(p, get_element_ud(c->reg.temp, 1), brw_imm_ud(num_prim));
	    brw_ff_sync(p,
		        c->reg.temp,
			0,
			c->reg.temp,
			1, /* allocate */
			1, /* response length */
			0 /* eot */);
	    brw_MOV(p, get_element_ud(c->reg.R0, 0),
		    get_element_ud(c->reg.temp, 0));
	}
d232 1
a232 1
   struct intel_context *intel = &c->func.brw->intel;
d234 2
a235 2
   brw_gs_alloc_regs(c, 4);
   
d239 5
a243 2
   if (intel->needs_ff_sync)
	   brw_gs_ff_sync(c, 1);
d245 9
a253 4
      brw_gs_emit_vue(c, c->reg.vertex[0], 0, ((_3DPRIM_POLYGON << 2) | R02_PRIM_START));
      brw_gs_emit_vue(c, c->reg.vertex[1], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[2], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[3], 1, ((_3DPRIM_POLYGON << 2) | R02_PRIM_END));
d256 9
a264 4
      brw_gs_emit_vue(c, c->reg.vertex[3], 0, ((_3DPRIM_POLYGON << 2) | R02_PRIM_START));
      brw_gs_emit_vue(c, c->reg.vertex[0], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[1], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[2], 1, ((_3DPRIM_POLYGON << 2) | R02_PRIM_END));
d270 1
a270 1
   struct intel_context *intel = &c->func.brw->intel;
d272 2
a273 1
   brw_gs_alloc_regs(c, 4);
d275 5
a279 2
   if (intel->needs_ff_sync)
	   brw_gs_ff_sync(c, 1);      
d281 9
a289 4
      brw_gs_emit_vue(c, c->reg.vertex[0], 0, ((_3DPRIM_POLYGON << 2) | R02_PRIM_START));
      brw_gs_emit_vue(c, c->reg.vertex[1], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[2], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[3], 1, ((_3DPRIM_POLYGON << 2) | R02_PRIM_END));
d292 9
a300 4
      brw_gs_emit_vue(c, c->reg.vertex[2], 0, ((_3DPRIM_POLYGON << 2) | R02_PRIM_START));
      brw_gs_emit_vue(c, c->reg.vertex[3], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[0], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[1], 1, ((_3DPRIM_POLYGON << 2) | R02_PRIM_END));
d306 1
a306 1
   struct intel_context *intel = &c->func.brw->intel;
d308 2
a309 1
   brw_gs_alloc_regs(c, 2);
d311 197
a507 4
   if (intel->needs_ff_sync)
	   brw_gs_ff_sync(c, 1);      
   brw_gs_emit_vue(c, c->reg.vertex[0], 0, ((_3DPRIM_LINESTRIP << 2) | R02_PRIM_START));
   brw_gs_emit_vue(c, c->reg.vertex[1], 1, ((_3DPRIM_LINESTRIP << 2) | R02_PRIM_END));
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d37 1
a37 1
#include "shader/program.h"
d61 2
d74 1
d76 9
d89 1
a89 1
   brw_MOV(p, get_element_ud(c->reg.R0, 2), brw_imm_ud(header));
d102 1
a102 1
		 allocate ? c->reg.R0 : retype(brw_null_reg(), BRW_REGISTER_TYPE_UD),
d104 1
a104 1
		 c->reg.R0,
d113 3
d121 25
a145 13
	brw_MOV(p, get_element_ud(c->reg.R0, 1), brw_imm_ud(num_prim));
	brw_ff_sync(p, 
				c->reg.R0,
				0,
				c->reg.R0,
				1,	
				1,		/* used */
				1,  	/* msg length */
				1,		/* response length */
				0,		/* eot */
				1,		/* write compelete */
				0,		/* urb offset */
				BRW_URB_SWIZZLE_NONE);
a195 13
void brw_gs_tris( struct brw_gs_compile *c )
{
   struct intel_context *intel = &c->func.brw->intel;

   brw_gs_alloc_regs(c, 3);

   if (intel->needs_ff_sync)
	   brw_gs_ff_sync(c, 1);      
   brw_gs_emit_vue(c, c->reg.vertex[0], 0, ((_3DPRIM_TRILIST << 2) | R02_PRIM_START));
   brw_gs_emit_vue(c, c->reg.vertex[1], 0, (_3DPRIM_TRILIST << 2));
   brw_gs_emit_vue(c, c->reg.vertex[2], 1, ((_3DPRIM_TRILIST << 2) | R02_PRIM_END));
}

a206 19

void brw_gs_points( struct brw_gs_compile *c )
{
   struct intel_context *intel = &c->func.brw->intel;

   brw_gs_alloc_regs(c, 1);

   if (intel->needs_ff_sync)
	   brw_gs_ff_sync(c, 1);      
   brw_gs_emit_vue(c, c->reg.vertex[0], 1, ((_3DPRIM_POINTLIST << 2) | R02_PRIM_START | R02_PRIM_END));
}








@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a42 1
#include "brw_util.h"
d103 17
d122 1
a122 1
void brw_gs_quads( struct brw_gs_compile *c )
d124 2
d131 14
a144 4
   brw_gs_emit_vue(c, c->reg.vertex[3], 0, ((_3DPRIM_POLYGON << 2) | R02_PRIM_START));
   brw_gs_emit_vue(c, c->reg.vertex[0], 0, (_3DPRIM_POLYGON << 2));
   brw_gs_emit_vue(c, c->reg.vertex[1], 0, (_3DPRIM_POLYGON << 2)); 
   brw_gs_emit_vue(c, c->reg.vertex[2], 1, ((_3DPRIM_POLYGON << 2) | R02_PRIM_END));
d147 1
a147 1
void brw_gs_quad_strip( struct brw_gs_compile *c )
d149 2
d153 14
a166 4
   brw_gs_emit_vue(c, c->reg.vertex[2], 0, ((_3DPRIM_POLYGON << 2) | R02_PRIM_START));
   brw_gs_emit_vue(c, c->reg.vertex[3], 0, (_3DPRIM_POLYGON << 2));
   brw_gs_emit_vue(c, c->reg.vertex[0], 0, (_3DPRIM_POLYGON << 2)); 
   brw_gs_emit_vue(c, c->reg.vertex[1], 1, ((_3DPRIM_POLYGON << 2) | R02_PRIM_END));
d171 2
d174 3
d184 2
d187 3
d196 2
d199 3
@


1.1
log
@Initial revision
@
text
@d33 3
a35 3
#include "glheader.h"
#include "macros.h"
#include "enums.h"
d117 10
@


1.1.1.1
log
@Import MesaLibs 6.5.1. (in dist/ since its code is shared between lib 
and xserver)...
@
text
@@


1.1.1.2
log
@Mesa 7.0.1
@
text
@a118 10
void brw_gs_quad_strip( struct brw_gs_compile *c )
{
   brw_gs_alloc_regs(c, 4);
   
   brw_gs_emit_vue(c, c->reg.vertex[2], 0, ((_3DPRIM_POLYGON << 2) | R02_PRIM_START));
   brw_gs_emit_vue(c, c->reg.vertex[3], 0, (_3DPRIM_POLYGON << 2));
   brw_gs_emit_vue(c, c->reg.vertex[0], 0, (_3DPRIM_POLYGON << 2)); 
   brw_gs_emit_vue(c, c->reg.vertex[1], 1, ((_3DPRIM_POLYGON << 2) | R02_PRIM_END));
}

@


1.1.1.3
log
@Import Mesa 7.10.3
@
text
@d33 3
a35 3
#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"
d37 1
a37 1
#include "program/program.h"
d43 1
a61 2
   c->reg.temp = brw_vec8_grf(i, 0);

a72 1
   struct intel_context *intel = &c->func.brw->intel;
a73 9
   struct brw_reg temp;

   if (intel->gen < 6)
       temp = c->reg.R0;
   else {
       temp = c->reg.temp;
       brw_MOV(p, retype(temp, BRW_REGISTER_TYPE_UD),
	       retype(c->reg.R0, BRW_REGISTER_TYPE_UD));
   }
d78 1
a78 1
   brw_MOV(p, get_element_ud(temp, 2), brw_imm_ud(header));
d91 1
a91 1
		 allocate ? temp : retype(brw_null_reg(), BRW_REGISTER_TYPE_UD),
d93 1
a93 1
		 temp,
a101 3

   if (intel->gen >= 6 && allocate)
       brw_MOV(p, get_element_ud(c->reg.R0, 0), get_element_ud(temp, 0));
a103 29
static void brw_gs_ff_sync(struct brw_gs_compile *c, int num_prim)
{
	struct brw_compile *p = &c->func;
	struct intel_context *intel = &c->func.brw->intel;

	if (intel->gen < 6) {
	    brw_MOV(p, get_element_ud(c->reg.R0, 1), brw_imm_ud(num_prim));
	    brw_ff_sync(p,
		        c->reg.R0,
			0,
			c->reg.R0,
			1, /* allocate */
			1, /* response length */
			0 /* eot */);
	} else {
	    brw_MOV(p, retype(c->reg.temp, BRW_REGISTER_TYPE_UD),
		    retype(c->reg.R0, BRW_REGISTER_TYPE_UD));
	    brw_MOV(p, get_element_ud(c->reg.temp, 1), brw_imm_ud(num_prim));
	    brw_ff_sync(p,
		        c->reg.temp,
			0,
			c->reg.temp,
			1, /* allocate */
			1, /* response length */
			0 /* eot */);
	    brw_MOV(p, get_element_ud(c->reg.R0, 0),
		    get_element_ud(c->reg.temp, 0));
	}
}
d106 1
a106 1
void brw_gs_quads( struct brw_gs_compile *c, struct brw_gs_prog_key *key )
a107 2
   struct intel_context *intel = &c->func.brw->intel;

d113 4
a116 14
   if (intel->needs_ff_sync)
	   brw_gs_ff_sync(c, 1);
   if (key->pv_first) {
      brw_gs_emit_vue(c, c->reg.vertex[0], 0, ((_3DPRIM_POLYGON << 2) | R02_PRIM_START));
      brw_gs_emit_vue(c, c->reg.vertex[1], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[2], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[3], 1, ((_3DPRIM_POLYGON << 2) | R02_PRIM_END));
   }
   else {
      brw_gs_emit_vue(c, c->reg.vertex[3], 0, ((_3DPRIM_POLYGON << 2) | R02_PRIM_START));
      brw_gs_emit_vue(c, c->reg.vertex[0], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[1], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[2], 1, ((_3DPRIM_POLYGON << 2) | R02_PRIM_END));
   }
d119 1
a119 1
void brw_gs_quad_strip( struct brw_gs_compile *c, struct brw_gs_prog_key *key )
a120 2
   struct intel_context *intel = &c->func.brw->intel;

d123 12
a134 14
   if (intel->needs_ff_sync)
	   brw_gs_ff_sync(c, 1);      
   if (key->pv_first) {
      brw_gs_emit_vue(c, c->reg.vertex[0], 0, ((_3DPRIM_POLYGON << 2) | R02_PRIM_START));
      brw_gs_emit_vue(c, c->reg.vertex[1], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[2], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[3], 1, ((_3DPRIM_POLYGON << 2) | R02_PRIM_END));
   }
   else {
      brw_gs_emit_vue(c, c->reg.vertex[2], 0, ((_3DPRIM_POLYGON << 2) | R02_PRIM_START));
      brw_gs_emit_vue(c, c->reg.vertex[3], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[0], 0, (_3DPRIM_POLYGON << 2));
      brw_gs_emit_vue(c, c->reg.vertex[1], 1, ((_3DPRIM_POLYGON << 2) | R02_PRIM_END));
   }
a138 2
   struct intel_context *intel = &c->func.brw->intel;

a139 3

   if (intel->needs_ff_sync)
	   brw_gs_ff_sync(c, 1);      
d143 14
@


1.1.1.4
log
@Import Mesa 9.2.0
@
text
@a44 10
/**
 * Allocate registers for GS.
 *
 * If sol_program is true, then:
 *
 * - The thread will be spawned with the "SVBI Payload Enable" bit set, so GRF
 *   1 needs to be set aside to hold the streamed vertex buffer indices.
 *
 * - The thread will need to use the destination_indices register.
 */
d46 1
a46 2
			       GLuint nr_verts,
                               bool sol_program )
a53 4
   /* Streamed vertex buffer indices */
   if (sol_program)
      c->reg.SVBI = retype(brw_vec8_grf(i++, 0), BRW_REGISTER_TYPE_UD);

d61 1
a61 7
   c->reg.header = retype(brw_vec8_grf(i++, 0), BRW_REGISTER_TYPE_UD);
   c->reg.temp = retype(brw_vec8_grf(i++, 0), BRW_REGISTER_TYPE_UD);

   if (sol_program) {
      c->reg.destination_indices =
         retype(brw_vec4_grf(i++, 0), BRW_REGISTER_TYPE_UD);
   }
d68 4
a71 15
/**
 * Set up the initial value of c->reg.header register based on c->reg.R0.
 *
 * The following information is passed to the GS thread in R0, and needs to be
 * included in the first URB_WRITE or FF_SYNC message sent by the GS:
 *
 * - DWORD 0 [31:0] handle info (Gen4 only)
 * - DWORD 5 [7:0] FFTID
 * - DWORD 6 [31:0] Debug info
 * - DWORD 7 [31:0] Debug info
 *
 * This function sets up the above data by copying by copying the contents of
 * R0 to the header register.
 */
static void brw_gs_initialize_header(struct brw_gs_compile *c)
d74 3
a76 2
   brw_MOV(p, c->reg.header, c->reg.R0);
}
d78 7
a84 13
/**
 * Overwrite DWORD 2 of c->reg.header with the given immediate unsigned value.
 *
 * In URB_WRITE messages, DWORD 2 contains the fields PrimType, PrimStart,
 * PrimEnd, Increment CL_INVOCATIONS, and SONumPrimsWritten, many of which we
 * need to be able to update on a per-vertex basis.
 */
static void brw_gs_overwrite_header_dw2(struct brw_gs_compile *c,
                                        unsigned dw2)
{
   struct brw_compile *p = &c->func;
   brw_MOV(p, get_element_ud(c->reg.header, 2), brw_imm_ud(dw2));
}
d86 4
a89 49
/**
 * Overwrite DWORD 2 of c->reg.header with the primitive type from c->reg.R0.
 *
 * When the thread is spawned, GRF 0 contains the primitive type in bits 4:0
 * of DWORD 2.  URB_WRITE messages need the primitive type in bits 6:2 of
 * DWORD 2.  So this function extracts the primitive type field, bitshifts it
 * appropriately, and stores it in c->reg.header.
 */
static void brw_gs_overwrite_header_dw2_from_r0(struct brw_gs_compile *c)
{
   struct brw_compile *p = &c->func;
   brw_AND(p, get_element_ud(c->reg.header, 2), get_element_ud(c->reg.R0, 2),
           brw_imm_ud(0x1f));
   brw_SHL(p, get_element_ud(c->reg.header, 2),
           get_element_ud(c->reg.header, 2), brw_imm_ud(2));
}

/**
 * Apply an additive offset to DWORD 2 of c->reg.header.
 *
 * This is used to set/unset the "PrimStart" and "PrimEnd" flags appropriately
 * for each vertex.
 */
static void brw_gs_offset_header_dw2(struct brw_gs_compile *c, int offset)
{
   struct brw_compile *p = &c->func;
   brw_ADD(p, get_element_d(c->reg.header, 2), get_element_d(c->reg.header, 2),
           brw_imm_d(offset));
}


/**
 * Emit a vertex using the URB_WRITE message.  Use the contents of
 * c->reg.header for the message header, and the registers starting at \c vert
 * for the vertex data.
 *
 * If \c last is true, then this is the last vertex, so no further URB space
 * should be allocated, and this message should end the thread.
 *
 * If \c last is false, then a new URB entry will be allocated, and its handle
 * will be stored in DWORD 0 of c->reg.header for use in the next URB_WRITE
 * message.
 */
static void brw_gs_emit_vue(struct brw_gs_compile *c, 
			    struct brw_reg vert,
			    bool last)
{
   struct brw_compile *p = &c->func;
   bool allocate = !last;
d102 1
a102 2
		 allocate ? c->reg.temp
                          : retype(brw_null_reg(), BRW_REGISTER_TYPE_UD),
d104 1
a104 1
		 c->reg.header,
d114 2
a115 4
   if (allocate) {
      brw_MOV(p, get_element_ud(c->reg.header, 0),
              get_element_ud(c->reg.temp, 0));
   }
a117 10
/**
 * Send an FF_SYNC message to ensure that all previously spawned GS threads
 * have finished sending primitives down the pipeline, and to allocate a URB
 * entry for the first output vertex.  Only needed on Ironlake+.
 *
 * This function modifies c->reg.header: in DWORD 1, it stores num_prim (which
 * is needed by the FF_SYNC message), and in DWORD 0, it stores the handle to
 * the allocated URB entry (which will be needed by the URB_WRITE meesage that
 * follows).
 */
d120 2
a121 1
   struct brw_compile *p = &c->func;
d123 23
a145 10
   brw_MOV(p, get_element_ud(c->reg.header, 1), brw_imm_ud(num_prim));
   brw_ff_sync(p,
               c->reg.temp,
               0,
               c->reg.header,
               1, /* allocate */
               1, /* response length */
               0 /* eot */);
   brw_MOV(p, get_element_ud(c->reg.header, 0),
           get_element_ud(c->reg.temp, 0));
d151 1
a151 1
   struct brw_context *brw = c->func.brw;
d153 2
a154 2
   brw_gs_alloc_regs(c, 4, false);
   brw_gs_initialize_header(c);
d158 2
a159 5
   if (brw->gen == 5)
      brw_gs_ff_sync(c, 1);
   brw_gs_overwrite_header_dw2(
      c, ((_3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT)
          | URB_WRITE_PRIM_START));
d161 4
a164 9
      brw_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_gs_overwrite_header_dw2(
         c, _3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT);
      brw_gs_emit_vue(c, c->reg.vertex[1], 0);
      brw_gs_emit_vue(c, c->reg.vertex[2], 0);
      brw_gs_overwrite_header_dw2(
         c, ((_3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT)
             | URB_WRITE_PRIM_END));
      brw_gs_emit_vue(c, c->reg.vertex[3], 1);
d167 4
a170 9
      brw_gs_emit_vue(c, c->reg.vertex[3], 0);
      brw_gs_overwrite_header_dw2(
         c, _3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT);
      brw_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_gs_emit_vue(c, c->reg.vertex[1], 0);
      brw_gs_overwrite_header_dw2(
         c, ((_3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT)
             | URB_WRITE_PRIM_END));
      brw_gs_emit_vue(c, c->reg.vertex[2], 1);
d176 1
a176 1
   struct brw_context *brw = c->func.brw;
d178 1
a178 2
   brw_gs_alloc_regs(c, 4, false);
   brw_gs_initialize_header(c);
d180 2
a181 5
   if (brw->gen == 5)
      brw_gs_ff_sync(c, 1);
   brw_gs_overwrite_header_dw2(
      c, ((_3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT)
          | URB_WRITE_PRIM_START));
d183 4
a186 9
      brw_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_gs_overwrite_header_dw2(
         c, _3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT);
      brw_gs_emit_vue(c, c->reg.vertex[1], 0);
      brw_gs_emit_vue(c, c->reg.vertex[2], 0);
      brw_gs_overwrite_header_dw2(
         c, ((_3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT)
             | URB_WRITE_PRIM_END));
      brw_gs_emit_vue(c, c->reg.vertex[3], 1);
d189 4
a192 9
      brw_gs_emit_vue(c, c->reg.vertex[2], 0);
      brw_gs_overwrite_header_dw2(
         c, _3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT);
      brw_gs_emit_vue(c, c->reg.vertex[3], 0);
      brw_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_gs_overwrite_header_dw2(
         c, ((_3DPRIM_POLYGON << URB_WRITE_PRIM_TYPE_SHIFT)
             | URB_WRITE_PRIM_END));
      brw_gs_emit_vue(c, c->reg.vertex[1], 1);
d198 1
a198 1
   struct brw_context *brw = c->func.brw;
d200 1
a200 2
   brw_gs_alloc_regs(c, 2, false);
   brw_gs_initialize_header(c);
d202 4
a205 197
   if (brw->gen == 5)
      brw_gs_ff_sync(c, 1);
   brw_gs_overwrite_header_dw2(
      c, ((_3DPRIM_LINESTRIP << URB_WRITE_PRIM_TYPE_SHIFT)
          | URB_WRITE_PRIM_START));
   brw_gs_emit_vue(c, c->reg.vertex[0], 0);
   brw_gs_overwrite_header_dw2(
      c, ((_3DPRIM_LINESTRIP << URB_WRITE_PRIM_TYPE_SHIFT)
          | URB_WRITE_PRIM_END));
   brw_gs_emit_vue(c, c->reg.vertex[1], 1);
}

/**
 * Generate the geometry shader program used on Gen6 to perform stream output
 * (transform feedback).
 */
void
gen6_sol_program(struct brw_gs_compile *c, struct brw_gs_prog_key *key,
	         unsigned num_verts, bool check_edge_flags)
{
   struct brw_compile *p = &c->func;
   c->prog_data.svbi_postincrement_value = num_verts;

   brw_gs_alloc_regs(c, num_verts, true);
   brw_gs_initialize_header(c);

   if (key->num_transform_feedback_bindings > 0) {
      unsigned vertex, binding;
      struct brw_reg destination_indices_uw =
         vec8(retype(c->reg.destination_indices, BRW_REGISTER_TYPE_UW));

      /* Note: since we use the binding table to keep track of buffer offsets
       * and stride, the GS doesn't need to keep track of a separate pointer
       * into each buffer; it uses a single pointer which increments by 1 for
       * each vertex.  So we use SVBI0 for this pointer, regardless of whether
       * transform feedback is in interleaved or separate attribs mode.
       *
       * Make sure that the buffers have enough room for all the vertices.
       */
      brw_ADD(p, get_element_ud(c->reg.temp, 0),
	         get_element_ud(c->reg.SVBI, 0), brw_imm_ud(num_verts));
      brw_CMP(p, vec1(brw_null_reg()), BRW_CONDITIONAL_LE,
	         get_element_ud(c->reg.temp, 0),
	         get_element_ud(c->reg.SVBI, 4));
      brw_IF(p, BRW_EXECUTE_1);

      /* Compute the destination indices to write to.  Usually we use SVBI[0]
       * + (0, 1, 2).  However, for odd-numbered triangles in tristrips, the
       * vertices come down the pipeline in reversed winding order, so we need
       * to flip the order when writing to the transform feedback buffer.  To
       * ensure that flatshading accuracy is preserved, we need to write them
       * in order SVBI[0] + (0, 2, 1) if we're using the first provoking
       * vertex convention, and in order SVBI[0] + (1, 0, 2) if we're using
       * the last provoking vertex convention.
       *
       * Note: since brw_imm_v can only be used in instructions in
       * packed-word execution mode, and SVBI is a double-word, we need to
       * first move the appropriate immediate constant ((0, 1, 2), (0, 2, 1),
       * or (1, 0, 2)) to the destination_indices register, and then add SVBI
       * using a separate instruction.  Also, since the immediate constant is
       * expressed as packed words, and we need to load double-words into
       * destination_indices, we need to intersperse zeros to fill the upper
       * halves of each double-word.
       */
      brw_MOV(p, destination_indices_uw,
              brw_imm_v(0x00020100)); /* (0, 1, 2) */
      if (num_verts == 3) {
         /* Get primitive type into temp register. */
         brw_AND(p, get_element_ud(c->reg.temp, 0),
                 get_element_ud(c->reg.R0, 2), brw_imm_ud(0x1f));

         /* Test if primitive type is TRISTRIP_REVERSE.  We need to do this as
          * an 8-wide comparison so that the conditional MOV that follows
          * moves all 8 words correctly.
          */
         brw_CMP(p, vec8(brw_null_reg()), BRW_CONDITIONAL_EQ,
                 get_element_ud(c->reg.temp, 0),
                 brw_imm_ud(_3DPRIM_TRISTRIP_REVERSE));

         /* If so, then overwrite destination_indices_uw with the appropriate
          * reordering.
          */
         brw_MOV(p, destination_indices_uw,
                 brw_imm_v(key->pv_first ? 0x00010200    /* (0, 2, 1) */
                                         : 0x00020001)); /* (1, 0, 2) */
         brw_set_predicate_control(p, BRW_PREDICATE_NONE);
      }
      brw_ADD(p, c->reg.destination_indices,
              c->reg.destination_indices, get_element_ud(c->reg.SVBI, 0));

      /* For each vertex, generate code to output each varying using the
       * appropriate binding table entry.
       */
      for (vertex = 0; vertex < num_verts; ++vertex) {
         /* Set up the correct destination index for this vertex */
         brw_MOV(p, get_element_ud(c->reg.header, 5),
                 get_element_ud(c->reg.destination_indices, vertex));

         for (binding = 0; binding < key->num_transform_feedback_bindings;
              ++binding) {
            unsigned char varying =
               key->transform_feedback_bindings[binding];
            unsigned char slot = c->vue_map.varying_to_slot[varying];
            /* From the Sandybridge PRM, Volume 2, Part 1, Section 4.5.1:
             *
             *   "Prior to End of Thread with a URB_WRITE, the kernel must
             *   ensure that all writes are complete by sending the final
             *   write as a committed write."
             */
            bool final_write =
               binding == key->num_transform_feedback_bindings - 1 &&
               vertex == num_verts - 1;
            struct brw_reg vertex_slot = c->reg.vertex[vertex];
            vertex_slot.nr += slot / 2;
            vertex_slot.subnr = (slot % 2) * 16;
            /* gl_PointSize is stored in VARYING_SLOT_PSIZ.w. */
            vertex_slot.dw1.bits.swizzle = varying == VARYING_SLOT_PSIZ
               ? BRW_SWIZZLE_WWWW : key->transform_feedback_swizzles[binding];
            brw_set_access_mode(p, BRW_ALIGN_16);
            brw_MOV(p, stride(c->reg.header, 4, 4, 1),
                    retype(vertex_slot, BRW_REGISTER_TYPE_UD));
            brw_set_access_mode(p, BRW_ALIGN_1);
            brw_svb_write(p,
                          final_write ? c->reg.temp : brw_null_reg(), /* dest */
                          1, /* msg_reg_nr */
                          c->reg.header, /* src0 */
                          SURF_INDEX_SOL_BINDING(binding), /* binding_table_index */
                          final_write); /* send_commit_msg */
         }
      }
      brw_ENDIF(p);

      /* Now, reinitialize the header register from R0 to restore the parts of
       * the register that we overwrote while streaming out transform feedback
       * data.
       */
      brw_gs_initialize_header(c);

      /* Finally, wait for the write commit to occur so that we can proceed to
       * other things safely.
       *
       * From the Sandybridge PRM, Volume 4, Part 1, Section 3.3:
       *
       *   The write commit does not modify the destination register, but
       *   merely clears the dependency associated with the destination
       *   register. Thus, a simple “mov” instruction using the register as a
       *   source is sufficient to wait for the write commit to occur.
       */
      brw_MOV(p, c->reg.temp, c->reg.temp);
   }

   brw_gs_ff_sync(c, 1);

   brw_gs_overwrite_header_dw2_from_r0(c);
   switch (num_verts) {
   case 1:
      brw_gs_offset_header_dw2(c, URB_WRITE_PRIM_START | URB_WRITE_PRIM_END);
      brw_gs_emit_vue(c, c->reg.vertex[0], true);
      break;
   case 2:
      brw_gs_offset_header_dw2(c, URB_WRITE_PRIM_START);
      brw_gs_emit_vue(c, c->reg.vertex[0], false);
      brw_gs_offset_header_dw2(c, URB_WRITE_PRIM_END - URB_WRITE_PRIM_START);
      brw_gs_emit_vue(c, c->reg.vertex[1], true);
      break;
   case 3:
      if (check_edge_flags) {
         /* Only emit vertices 0 and 1 if this is the first triangle of the
          * polygon.  Otherwise they are redundant.
          */
         brw_set_conditionalmod(p, BRW_CONDITIONAL_NZ);
         brw_AND(p, retype(brw_null_reg(), BRW_REGISTER_TYPE_UD),
                 get_element_ud(c->reg.R0, 2),
                 brw_imm_ud(BRW_GS_EDGE_INDICATOR_0));
         brw_IF(p, BRW_EXECUTE_1);
      }
      brw_gs_offset_header_dw2(c, URB_WRITE_PRIM_START);
      brw_gs_emit_vue(c, c->reg.vertex[0], false);
      brw_gs_offset_header_dw2(c, -URB_WRITE_PRIM_START);
      brw_gs_emit_vue(c, c->reg.vertex[1], false);
      if (check_edge_flags) {
         brw_ENDIF(p);
         /* Only emit vertex 2 in PRIM_END mode if this is the last triangle
          * of the polygon.  Otherwise leave the primitive incomplete because
          * there are more polygon vertices coming.
          */
         brw_set_conditionalmod(p, BRW_CONDITIONAL_NZ);
         brw_AND(p, retype(brw_null_reg(), BRW_REGISTER_TYPE_UD),
                 get_element_ud(c->reg.R0, 2),
                 brw_imm_ud(BRW_GS_EDGE_INDICATOR_1));
         brw_set_predicate_control(p, BRW_PREDICATE_NORMAL);
      }
      brw_gs_offset_header_dw2(c, URB_WRITE_PRIM_END);
      brw_set_predicate_control(p, BRW_PREDICATE_NONE);
      brw_gs_emit_vue(c, c->reg.vertex[2], true);
      break;
   }
@


1.1.1.5
log
@Import Mesa 10.2.3
@
text
@d3 1
a3 1
 Intel funded Tungsten Graphics to
d5 1
a5 1

d13 1
a13 1

d17 1
a17 1

d25 1
a25 1

d29 1
a29 1
  *   Keith Whitwell <keithw@@vmware.com>
d31 1
a31 1

d55 3
a57 3
static void brw_ff_gs_alloc_regs(struct brw_ff_gs_compile *c,
                                 GLuint nr_verts,
                                 bool sol_program)
d84 1
a84 1
   c->prog_data.urb_read_length = c->nr_regs;
d103 1
a103 1
static void brw_ff_gs_initialize_header(struct brw_ff_gs_compile *c)
d116 2
a117 2
static void brw_ff_gs_overwrite_header_dw2(struct brw_ff_gs_compile *c,
                                           unsigned dw2)
d131 1
a131 1
static void brw_ff_gs_overwrite_header_dw2_from_r0(struct brw_ff_gs_compile *c)
d146 1
a146 2
static void brw_ff_gs_offset_header_dw2(struct brw_ff_gs_compile *c,
                                        int offset)
d166 3
a168 3
static void brw_ff_gs_emit_vue(struct brw_ff_gs_compile *c,
                               struct brw_reg vert,
                               bool last)
d171 1
a171 2
   int write_offset = 0;
   bool complete = false;
d173 3
a175 5
   do {
      /* We can't write more than 14 registers at a time to the URB */
      int write_len = MIN2(c->nr_regs - write_offset, 14);
      if (write_len == c->nr_regs - write_offset)
         complete = true;
d177 19
a195 29
      /* Copy the vertex from vertn into m1..mN+1:
       */
      brw_copy8(p, brw_message_reg(1), offset(vert, write_offset), write_len);

      /* Send the vertex data to the URB.  If this is the last write for this
       * vertex, then we mark it as complete, and either end the thread or
       * allocate another vertex URB entry (depending whether this is the last
       * vertex).
       */
      enum brw_urb_write_flags flags;
      if (!complete)
         flags = BRW_URB_WRITE_NO_FLAGS;
      else if (last)
         flags = BRW_URB_WRITE_EOT_COMPLETE;
      else
         flags = BRW_URB_WRITE_ALLOCATE_COMPLETE;
      brw_urb_WRITE(p,
                    (flags & BRW_URB_WRITE_ALLOCATE) ? c->reg.temp
                    : retype(brw_null_reg(), BRW_REGISTER_TYPE_UD),
                    0,
                    c->reg.header,
                    flags,
                    write_len + 1, /* msg length */
                    (flags & BRW_URB_WRITE_ALLOCATE) ? 1
                    : 0, /* response length */
                    write_offset,  /* urb offset */
                    BRW_URB_SWIZZLE_NONE);
      write_offset += write_len;
   } while (!complete);
d197 1
a197 1
   if (!last) {
d213 1
a213 1
static void brw_ff_gs_ff_sync(struct brw_ff_gs_compile *c, int num_prim)
d230 1
a230 2
void
brw_ff_gs_quads(struct brw_ff_gs_compile *c, struct brw_ff_gs_prog_key *key)
d234 2
a235 2
   brw_ff_gs_alloc_regs(c, 4, false);
   brw_ff_gs_initialize_header(c);
d240 2
a241 2
      brw_ff_gs_ff_sync(c, 1);
   brw_ff_gs_overwrite_header_dw2(
d245 2
a246 2
      brw_ff_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_ff_gs_overwrite_header_dw2(
d248 3
a250 3
      brw_ff_gs_emit_vue(c, c->reg.vertex[1], 0);
      brw_ff_gs_emit_vue(c, c->reg.vertex[2], 0);
      brw_ff_gs_overwrite_header_dw2(
d253 1
a253 1
      brw_ff_gs_emit_vue(c, c->reg.vertex[3], 1);
d256 2
a257 2
      brw_ff_gs_emit_vue(c, c->reg.vertex[3], 0);
      brw_ff_gs_overwrite_header_dw2(
d259 3
a261 3
      brw_ff_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_ff_gs_emit_vue(c, c->reg.vertex[1], 0);
      brw_ff_gs_overwrite_header_dw2(
d264 1
a264 1
      brw_ff_gs_emit_vue(c, c->reg.vertex[2], 1);
d268 1
a268 3
void
brw_ff_gs_quad_strip(struct brw_ff_gs_compile *c,
                     struct brw_ff_gs_prog_key *key)
d272 3
a274 3
   brw_ff_gs_alloc_regs(c, 4, false);
   brw_ff_gs_initialize_header(c);

d276 2
a277 2
      brw_ff_gs_ff_sync(c, 1);
   brw_ff_gs_overwrite_header_dw2(
d281 2
a282 2
      brw_ff_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_ff_gs_overwrite_header_dw2(
d284 3
a286 3
      brw_ff_gs_emit_vue(c, c->reg.vertex[1], 0);
      brw_ff_gs_emit_vue(c, c->reg.vertex[2], 0);
      brw_ff_gs_overwrite_header_dw2(
d289 1
a289 1
      brw_ff_gs_emit_vue(c, c->reg.vertex[3], 1);
d292 2
a293 2
      brw_ff_gs_emit_vue(c, c->reg.vertex[2], 0);
      brw_ff_gs_overwrite_header_dw2(
d295 3
a297 3
      brw_ff_gs_emit_vue(c, c->reg.vertex[3], 0);
      brw_ff_gs_emit_vue(c, c->reg.vertex[0], 0);
      brw_ff_gs_overwrite_header_dw2(
d300 1
a300 1
      brw_ff_gs_emit_vue(c, c->reg.vertex[1], 1);
d304 1
a304 1
void brw_ff_gs_lines(struct brw_ff_gs_compile *c)
d308 2
a309 2
   brw_ff_gs_alloc_regs(c, 2, false);
   brw_ff_gs_initialize_header(c);
d312 2
a313 2
      brw_ff_gs_ff_sync(c, 1);
   brw_ff_gs_overwrite_header_dw2(
d316 2
a317 2
   brw_ff_gs_emit_vue(c, c->reg.vertex[0], 0);
   brw_ff_gs_overwrite_header_dw2(
d320 1
a320 1
   brw_ff_gs_emit_vue(c, c->reg.vertex[1], 1);
d328 1
a328 1
gen6_sol_program(struct brw_ff_gs_compile *c, struct brw_ff_gs_prog_key *key,
d334 2
a335 2
   brw_ff_gs_alloc_regs(c, num_verts, true);
   brw_ff_gs_initialize_header(c);
d437 1
a437 1
                          SURF_INDEX_GEN6_SOL_BINDING(binding), /* binding_table_index */
d447 1
a447 1
      brw_ff_gs_initialize_header(c);
d462 1
a462 1
   brw_ff_gs_ff_sync(c, 1);
d464 1
a464 1
   brw_ff_gs_overwrite_header_dw2_from_r0(c);
d467 2
a468 3
      brw_ff_gs_offset_header_dw2(c,
                                  URB_WRITE_PRIM_START | URB_WRITE_PRIM_END);
      brw_ff_gs_emit_vue(c, c->reg.vertex[0], true);
d471 4
a474 5
      brw_ff_gs_offset_header_dw2(c, URB_WRITE_PRIM_START);
      brw_ff_gs_emit_vue(c, c->reg.vertex[0], false);
      brw_ff_gs_offset_header_dw2(c,
                                  URB_WRITE_PRIM_END - URB_WRITE_PRIM_START);
      brw_ff_gs_emit_vue(c, c->reg.vertex[1], true);
d487 4
a490 4
      brw_ff_gs_offset_header_dw2(c, URB_WRITE_PRIM_START);
      brw_ff_gs_emit_vue(c, c->reg.vertex[0], false);
      brw_ff_gs_offset_header_dw2(c, -URB_WRITE_PRIM_START);
      brw_ff_gs_emit_vue(c, c->reg.vertex[1], false);
d503 1
a503 1
      brw_ff_gs_offset_header_dw2(c, URB_WRITE_PRIM_END);
d505 1
a505 1
      brw_ff_gs_emit_vue(c, c->reg.vertex[2], true);
@


