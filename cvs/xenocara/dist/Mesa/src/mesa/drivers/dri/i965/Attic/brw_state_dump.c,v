head	1.10;
access;
symbols
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	v10_2_9:1.1.1.5
	v10_4_3:1.1.1.4
	v10_2_7:1.1.1.3
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	v10_2_3:1.1.1.3
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	v9_2_5:1.1.1.2
	v9_2_3:1.1.1.2
	v9_2_2:1.1.1.2
	v9_2_1:1.1.1.2
	v9_2_0:1.1.1.2
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.1
	mesa:1.1.1
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.12.23.05.17.49;	author jsg;	state dead;
branches;
next	1.9;
commitid	TnlogFl9nOv2eaRf;

1.9
date	2015.02.20.23.09.58;	author jsg;	state Exp;
branches;
next	1.8;
commitid	4ry2gvZGMXkCUD2n;

1.8
date	2015.01.25.14.41.21;	author jsg;	state Exp;
branches;
next	1.7;
commitid	mcxB0JvoI9gTDYXU;

1.7
date	2014.07.09.21.08.59;	author jsg;	state Exp;
branches;
next	1.6;
commitid	WPD6rgPryPkvXOr9;

1.6
date	2013.09.05.14.04.20;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.17.13.58.15;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.39;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.17.20.26.39;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.14.58.15;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2011.10.23.13.29.36;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.09.05.13.15.38;	author jsg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.07.09.20.34.51;	author jsg;	state Exp;
branches;
next	1.1.1.4;
commitid	3JhLfwcuBALP0ZR7;

1.1.1.4
date	2015.01.25.14.11.44;	author jsg;	state Exp;
branches;
next	1.1.1.5;
commitid	ce2W5rH5aF7VS9gi;

1.1.1.5
date	2015.02.20.22.48.49;	author jsg;	state Exp;
branches;
next	;
commitid	F54a1i0WXHMxq7kE;


desc
@@


1.10
log
@remove the now unused Mesa 10.2.9 code
@
text
@/*
 * Copyright Â© 2007 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *
 */

#include "main/mtypes.h"
#include "intel_batchbuffer.h"

#include "brw_context.h"
#include "brw_defines.h"

static void
batch_out(struct brw_context *brw, const char *name, uint32_t offset,
	  int index, char *fmt, ...) PRINTFLIKE(5, 6);

static void
batch_out(struct brw_context *brw, const char *name, uint32_t offset,
	  int index, char *fmt, ...)
{
   uint32_t *data = brw->batch.bo->virtual + offset;
   va_list va;

   fprintf(stderr, "0x%08x:      0x%08x: %8s: ",
	   offset + index * 4, data[index], name);
   va_start(va, fmt);
   vfprintf(stderr, fmt, va);
   va_end(va);
}

static const char *
get_965_surfacetype(unsigned int surfacetype)
{
    switch (surfacetype) {
    case 0: return "1D";
    case 1: return "2D";
    case 2: return "3D";
    case 3: return "CUBE";
    case 4: return "BUFFER";
    case 7: return "NULL";
    default: return "unknown";
    }
}

static const char *
get_965_surface_format(unsigned int surface_format)
{
    switch (surface_format) {
    case 0x000: return "r32g32b32a32_float";
    case 0x0c1: return "b8g8r8a8_unorm";
    case 0x100: return "b5g6r5_unorm";
    case 0x102: return "b5g5r5a1_unorm";
    case 0x104: return "b4g4r4a4_unorm";
    default: return "unknown";
    }
}

static void dump_vs_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "VS_STATE";
   struct brw_vs_unit_state *vs = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0, "thread0\n");
   batch_out(brw, name, offset, 1, "thread1\n");
   batch_out(brw, name, offset, 2, "thread2\n");
   batch_out(brw, name, offset, 3, "thread3\n");
   batch_out(brw, name, offset, 4, "thread4: %d threads\n",
	     vs->thread4.max_threads + 1);
   batch_out(brw, name, offset, 5, "vs5\n");
   batch_out(brw, name, offset, 6, "vs6\n");
}

static void dump_gs_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "GS_STATE";
   struct brw_gs_unit_state *gs = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0, "thread0\n");
   batch_out(brw, name, offset, 1, "thread1\n");
   batch_out(brw, name, offset, 2, "thread2\n");
   batch_out(brw, name, offset, 3, "thread3\n");
   batch_out(brw, name, offset, 4, "thread4: %d threads\n",
	     gs->thread4.max_threads + 1);
   batch_out(brw, name, offset, 5, "vs5\n");
   batch_out(brw, name, offset, 6, "vs6\n");
}

static void dump_clip_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "CLIP_STATE";
   struct brw_clip_unit_state *clip = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0, "thread0\n");
   batch_out(brw, name, offset, 1, "thread1\n");
   batch_out(brw, name, offset, 2, "thread2\n");
   batch_out(brw, name, offset, 3, "thread3\n");
   batch_out(brw, name, offset, 4, "thread4: %d threads\n",
	     clip->thread4.max_threads + 1);
   batch_out(brw, name, offset, 5, "clip5\n");
   batch_out(brw, name, offset, 6, "clip6\n");
   batch_out(brw, name, offset, 7, "vp xmin %f\n", clip->viewport_xmin);
   batch_out(brw, name, offset, 8, "vp xmax %f\n", clip->viewport_xmax);
   batch_out(brw, name, offset, 9, "vp ymin %f\n", clip->viewport_ymin);
   batch_out(brw, name, offset, 10, "vp ymax %f\n", clip->viewport_ymax);
}

static void dump_sf_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "SF_STATE";
   struct brw_sf_unit_state *sf = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0, "thread0\n");
   batch_out(brw, name, offset, 1, "thread1\n");
   batch_out(brw, name, offset, 2, "thread2\n");
   batch_out(brw, name, offset, 3, "thread3\n");
   batch_out(brw, name, offset, 4, "thread4: %d threads\n",
	     sf->thread4.max_threads + 1);
   batch_out(brw, name, offset, 5, "sf5: viewport offset\n");
   batch_out(brw, name, offset, 6, "sf6\n");
   batch_out(brw, name, offset, 7, "sf7\n");
}

static void dump_wm_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "WM_STATE";
   struct brw_wm_unit_state *wm = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0, "thread0\n");
   batch_out(brw, name, offset, 1, "thread1\n");
   batch_out(brw, name, offset, 2, "thread2\n");
   batch_out(brw, name, offset, 3, "thread3\n");
   batch_out(brw, name, offset, 4, "wm4\n");
   batch_out(brw, name, offset, 5, "wm5: %s%s%s%s%s%s, %d threads\n",
	     wm->wm5.enable_8_pix ? "8pix" : "",
	     wm->wm5.enable_16_pix ? "16pix" : "",
	     wm->wm5.program_uses_depth ? ", uses depth" : "",
	     wm->wm5.program_computes_depth ? ", computes depth" : "",
	     wm->wm5.program_uses_killpixel ? ", kills" : "",
	     wm->wm5.thread_dispatch_enable ? "" : ", no dispatch",
	     wm->wm5.max_threads + 1);
   batch_out(brw, name, offset, 6, "depth offset constant %f\n",
	     wm->global_depth_offset_constant);
   batch_out(brw, name, offset, 7, "depth offset scale %f\n",
	     wm->global_depth_offset_scale);
   batch_out(brw, name, offset, 8, "wm8: kernel 1 (gen5+)\n");
   batch_out(brw, name, offset, 9, "wm9: kernel 2 (gen5+)\n");
   batch_out(brw, name, offset, 10, "wm10: kernel 3 (gen5+)\n");
}

static void dump_surface_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "SURF";
   uint32_t *surf = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0, "%s %s\n",
	     get_965_surfacetype(GET_FIELD(surf[0], BRW_SURFACE_TYPE)),
	     get_965_surface_format(GET_FIELD(surf[0], BRW_SURFACE_FORMAT)));
   batch_out(brw, name, offset, 1, "offset\n");
   batch_out(brw, name, offset, 2, "%dx%d size, %d mips\n",
	     GET_FIELD(surf[2], BRW_SURFACE_WIDTH) + 1,
	     GET_FIELD(surf[2], BRW_SURFACE_HEIGHT) + 1,
	     GET_FIELD(surf[2], BRW_SURFACE_LOD));
   batch_out(brw, name, offset, 3, "pitch %d, %s tiled\n",
	     GET_FIELD(surf[3], BRW_SURFACE_PITCH) + 1,
	     (surf[3] & BRW_SURFACE_TILED) ?
	     ((surf[3] & BRW_SURFACE_TILED_Y) ? "Y" : "X") : "not");
   batch_out(brw, name, offset, 4, "mip base %d\n",
	     GET_FIELD(surf[4], BRW_SURFACE_MIN_LOD));
   batch_out(brw, name, offset, 5, "x,y offset: %d,%d\n",
	     GET_FIELD(surf[5], BRW_SURFACE_X_OFFSET),
	     GET_FIELD(surf[5], BRW_SURFACE_Y_OFFSET));
}

static void dump_gen7_surface_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "SURF";
   uint32_t *surf = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0, "%s %s %s\n",
             get_965_surfacetype(GET_FIELD(surf[0], BRW_SURFACE_TYPE)),
             get_965_surface_format(GET_FIELD(surf[0], BRW_SURFACE_FORMAT)),
             (surf[0] & GEN7_SURFACE_IS_ARRAY) ? "array" : "");
   batch_out(brw, name, offset, 1, "offset\n");
   batch_out(brw, name, offset, 2, "%dx%d size, %d mips, %d slices\n",
             GET_FIELD(surf[2], GEN7_SURFACE_WIDTH) + 1,
             GET_FIELD(surf[2], GEN7_SURFACE_HEIGHT) + 1,
             surf[5] & INTEL_MASK(3, 0),
             GET_FIELD(surf[3], BRW_SURFACE_DEPTH) + 1);
   batch_out(brw, name, offset, 3, "pitch %d, %stiled\n",
	     (surf[3] & INTEL_MASK(17, 0)) + 1,
             (surf[0] & (1 << 14)) ? "" : "not ");
   batch_out(brw, name, offset, 4, "min array element %d, array extent %d\n",
             GET_FIELD(surf[4], GEN7_SURFACE_MIN_ARRAY_ELEMENT),
             GET_FIELD(surf[4], GEN7_SURFACE_RENDER_TARGET_VIEW_EXTENT) + 1);
   batch_out(brw, name, offset, 5, "mip base %d\n",
             GET_FIELD(surf[5], GEN7_SURFACE_MIN_LOD));
   batch_out(brw, name, offset, 6, "x,y offset: %d,%d\n",
             GET_FIELD(surf[5], BRW_SURFACE_X_OFFSET),
             GET_FIELD(surf[5], BRW_SURFACE_Y_OFFSET));
   batch_out(brw, name, offset, 7, "\n");
}

static void
dump_sdc(struct brw_context *brw, uint32_t offset)
{
   const char *name = "SDC";

   if (brw->gen >= 5 && brw->gen <= 6) {
      struct gen5_sampler_default_color *sdc = (brw->batch.bo->virtual +
						offset);
      batch_out(brw, name, offset, 0, "unorm rgba\n");
      batch_out(brw, name, offset, 1, "r %f\n", sdc->f[0]);
      batch_out(brw, name, offset, 2, "b %f\n", sdc->f[1]);
      batch_out(brw, name, offset, 3, "g %f\n", sdc->f[2]);
      batch_out(brw, name, offset, 4, "a %f\n", sdc->f[3]);
      batch_out(brw, name, offset, 5, "half float rg\n");
      batch_out(brw, name, offset, 6, "half float ba\n");
      batch_out(brw, name, offset, 7, "u16 rg\n");
      batch_out(brw, name, offset, 8, "u16 ba\n");
      batch_out(brw, name, offset, 9, "s16 rg\n");
      batch_out(brw, name, offset, 10, "s16 ba\n");
      batch_out(brw, name, offset, 11, "s8 rgba\n");
   } else {
      struct brw_sampler_default_color *sdc = (brw->batch.bo->virtual +
					       offset);
      batch_out(brw, name, offset, 0, "r %f\n", sdc->color[0]);
      batch_out(brw, name, offset, 1, "g %f\n", sdc->color[1]);
      batch_out(brw, name, offset, 2, "b %f\n", sdc->color[2]);
      batch_out(brw, name, offset, 3, "a %f\n", sdc->color[3]);
   }
}

static void dump_sampler_state(struct brw_context *brw,
			       uint32_t offset, uint32_t size)
{
   int i;
   struct brw_sampler_state *samp = brw->batch.bo->virtual + offset;

   assert(brw->gen < 7);

   for (i = 0; i < size / sizeof(*samp); i++) {
      char name[20];

      sprintf(name, "WM SAMP%d", i);
      batch_out(brw, name, offset, 0, "filtering\n");
      batch_out(brw, name, offset, 1, "wrapping, lod\n");
      batch_out(brw, name, offset, 2, "default color pointer\n");
      batch_out(brw, name, offset, 3, "chroma key, aniso\n");

      samp++;
      offset += sizeof(*samp);
   }
}

static void dump_gen7_sampler_state(struct brw_context *brw,
				    uint32_t offset, uint32_t size)
{
   struct gen7_sampler_state *samp = brw->batch.bo->virtual + offset;
   int i;

   assert(brw->gen >= 7);

   for (i = 0; i < size / sizeof(*samp); i++) {
      char name[20];

      sprintf(name, "WM SAMP%d", i);
      batch_out(brw, name, offset, 0, "filtering\n");
      batch_out(brw, name, offset, 1, "wrapping, lod\n");
      batch_out(brw, name, offset, 2, "default color pointer\n");
      batch_out(brw, name, offset, 3, "chroma key, aniso\n");

      samp++;
      offset += sizeof(*samp);
   }
}


static void dump_sf_viewport_state(struct brw_context *brw,
				   uint32_t offset)
{
   const char *name = "SF VP";
   struct brw_sf_viewport *vp = brw->batch.bo->virtual + offset;

   assert(brw->gen < 7);

   batch_out(brw, name, offset, 0, "m00 = %f\n", vp->viewport.m00);
   batch_out(brw, name, offset, 1, "m11 = %f\n", vp->viewport.m11);
   batch_out(brw, name, offset, 2, "m22 = %f\n", vp->viewport.m22);
   batch_out(brw, name, offset, 3, "m30 = %f\n", vp->viewport.m30);
   batch_out(brw, name, offset, 4, "m31 = %f\n", vp->viewport.m31);
   batch_out(brw, name, offset, 5, "m32 = %f\n", vp->viewport.m32);

   batch_out(brw, name, offset, 6, "top left = %d,%d\n",
	     vp->scissor.xmin, vp->scissor.ymin);
   batch_out(brw, name, offset, 7, "bottom right = %d,%d\n",
	     vp->scissor.xmax, vp->scissor.ymax);
}

static void dump_clip_viewport_state(struct brw_context *brw,
				     uint32_t offset)
{
   const char *name = "CLIP VP";
   struct brw_clipper_viewport *vp = brw->batch.bo->virtual + offset;

   assert(brw->gen < 7);

   batch_out(brw, name, offset, 0, "xmin = %f\n", vp->xmin);
   batch_out(brw, name, offset, 1, "xmax = %f\n", vp->xmax);
   batch_out(brw, name, offset, 2, "ymin = %f\n", vp->ymin);
   batch_out(brw, name, offset, 3, "ymax = %f\n", vp->ymax);
}

static void dump_sf_clip_viewport_state(struct brw_context *brw,
					uint32_t offset)
{
   const char *name = "SF_CLIP VP";
   struct gen7_sf_clip_viewport *vp = brw->batch.bo->virtual + offset;

   assert(brw->gen >= 7);

   batch_out(brw, name, offset, 0, "m00 = %f\n", vp->viewport.m00);
   batch_out(brw, name, offset, 1, "m11 = %f\n", vp->viewport.m11);
   batch_out(brw, name, offset, 2, "m22 = %f\n", vp->viewport.m22);
   batch_out(brw, name, offset, 3, "m30 = %f\n", vp->viewport.m30);
   batch_out(brw, name, offset, 4, "m31 = %f\n", vp->viewport.m31);
   batch_out(brw, name, offset, 5, "m32 = %f\n", vp->viewport.m32);
   batch_out(brw, name, offset, 6, "guardband xmin = %f\n", vp->guardband.xmin);
   batch_out(brw, name, offset, 7, "guardband xmax = %f\n", vp->guardband.xmax);
   batch_out(brw, name, offset, 8, "guardband ymin = %f\n", vp->guardband.ymin);
   batch_out(brw, name, offset, 9, "guardband ymax = %f\n", vp->guardband.ymax);
}


static void dump_cc_viewport_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "CC VP";
   struct brw_cc_viewport *vp = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0, "min_depth = %f\n", vp->min_depth);
   batch_out(brw, name, offset, 1, "max_depth = %f\n", vp->max_depth);
}

static void dump_depth_stencil_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "D_S";
   struct gen6_depth_stencil_state *ds = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0,
	     "stencil %sable, func %d, write %sable\n",
	     ds->ds0.stencil_enable ? "en" : "dis",
	     ds->ds0.stencil_func,
	     ds->ds0.stencil_write_enable ? "en" : "dis");
   batch_out(brw, name, offset, 1,
	     "stencil test mask 0x%x, write mask 0x%x\n",
	     ds->ds1.stencil_test_mask, ds->ds1.stencil_write_mask);
   batch_out(brw, name, offset, 2,
	     "depth test %sable, func %d, write %sable\n",
	     ds->ds2.depth_test_enable ? "en" : "dis",
	     ds->ds2.depth_test_func,
	     ds->ds2.depth_write_enable ? "en" : "dis");
}

static void dump_cc_state_gen4(struct brw_context *brw, uint32_t offset)
{
   const char *name = "CC";

   batch_out(brw, name, offset, 0, "cc0\n");
   batch_out(brw, name, offset, 1, "cc1\n");
   batch_out(brw, name, offset, 2, "cc2\n");
   batch_out(brw, name, offset, 3, "cc3\n");
   batch_out(brw, name, offset, 4, "cc4: viewport offset\n");
   batch_out(brw, name, offset, 5, "cc5\n");
   batch_out(brw, name, offset, 6, "cc6\n");
   batch_out(brw, name, offset, 7, "cc7\n");
}

static void dump_cc_state_gen6(struct brw_context *brw, uint32_t offset)
{
   const char *name = "CC";
   struct gen6_color_calc_state *cc = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0,
	     "alpha test format %s, round disable %d, stencil ref %d, "
	     "bf stencil ref %d\n",
	     cc->cc0.alpha_test_format ? "FLOAT32" : "UNORM8",
	     cc->cc0.round_disable,
	     cc->cc0.stencil_ref,
	     cc->cc0.bf_stencil_ref);
   batch_out(brw, name, offset, 1, "\n");
   batch_out(brw, name, offset, 2, "constant red %f\n", cc->constant_r);
   batch_out(brw, name, offset, 3, "constant green %f\n", cc->constant_g);
   batch_out(brw, name, offset, 4, "constant blue %f\n", cc->constant_b);
   batch_out(brw, name, offset, 5, "constant alpha %f\n", cc->constant_a);
}

static void dump_blend_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "BLEND";

   batch_out(brw, name, offset, 0, "\n");
   batch_out(brw, name, offset, 1, "\n");
}

static void
dump_scissor(struct brw_context *brw, uint32_t offset)
{
   const char *name = "SCISSOR";
   struct gen6_scissor_rect *scissor = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0, "xmin %d, ymin %d\n",
	     scissor->xmin, scissor->ymin);
   batch_out(brw, name, offset, 1, "xmax %d, ymax %d\n",
	     scissor->xmax, scissor->ymax);
}

static void
dump_vs_constants(struct brw_context *brw, uint32_t offset, uint32_t size)
{
   const char *name = "VS_CONST";
   uint32_t *as_uint = brw->batch.bo->virtual + offset;
   float *as_float = brw->batch.bo->virtual + offset;
   int i;

   for (i = 0; i < size / 4; i += 4) {
      batch_out(brw, name, offset, i, "%3d: (% f % f % f % f) (0x%08x 0x%08x 0x%08x 0x%08x)\n",
		i / 4,
		as_float[i], as_float[i + 1], as_float[i + 2], as_float[i + 3],
		as_uint[i], as_uint[i + 1], as_uint[i + 2], as_uint[i + 3]);
   }
}

static void
dump_wm_constants(struct brw_context *brw, uint32_t offset, uint32_t size)
{
   const char *name = "WM_CONST";
   uint32_t *as_uint = brw->batch.bo->virtual + offset;
   float *as_float = brw->batch.bo->virtual + offset;
   int i;

   for (i = 0; i < size / 4; i += 4) {
      batch_out(brw, name, offset, i, "%3d: (% f % f % f % f) (0x%08x 0x%08x 0x%08x 0x%08x)\n",
		i / 4,
		as_float[i], as_float[i + 1], as_float[i + 2], as_float[i + 3],
		as_uint[i], as_uint[i + 1], as_uint[i + 2], as_uint[i + 3]);
   }
}

static void dump_binding_table(struct brw_context *brw, uint32_t offset,
			       uint32_t size)
{
   char name[20];
   int i;
   uint32_t *data = brw->batch.bo->virtual + offset;

   for (i = 0; i < size / 4; i++) {
      if (data[i] == 0)
	 continue;

      sprintf(name, "BIND%d", i);
      batch_out(brw, name, offset, i, "surface state address\n");
   }
}

static void
dump_prog_cache(struct brw_context *brw)
{
   struct brw_cache *cache = &brw->cache;
   unsigned int b, i;
   uint32_t *data;

   drm_intel_bo_map(brw->cache.bo, false);

   for (b = 0; b < cache->size; b++) {
      struct brw_cache_item *item;

      for (item = cache->items[b]; item; item = item->next) {
	 const char *name;
	 uint32_t offset = item->offset;

	 data = brw->cache.bo->virtual + item->offset;

	 switch (item->cache_id) {
	 case BRW_VS_PROG:
	    name = "VS kernel";
	    break;
	 case BRW_FF_GS_PROG:
	    name = "Fixed-function GS kernel";
	    break;
         case BRW_GS_PROG:
            name = "GS kernel";
            break;
	 case BRW_CLIP_PROG:
	    name = "CLIP kernel";
	    break;
	 case BRW_SF_PROG:
	    name = "SF kernel";
	    break;
	 case BRW_WM_PROG:
	    name = "WM kernel";
	    break;
	 default:
	    name = "unknown";
	    break;
	 }

	 for (i = 0; i < item->size / 4 / 4; i++) {
	    fprintf(stderr, "0x%08x: %8s: 0x%08x 0x%08x 0x%08x 0x%08x ",
		    offset + i * 4 * 4,
		    name,
		    data[i * 4], data[i * 4 + 1], data[i * 4 + 2], data[i * 4 + 3]);

	    brw_disasm(stderr, (void *)(data + i * 4), brw->gen);
	 }
      }
   }

   drm_intel_bo_unmap(brw->cache.bo);
}

static void
dump_state_batch(struct brw_context *brw)
{
   int i;

   for (i = 0; i < brw->state_batch_count; i++) {
      uint32_t offset = brw->state_batch_list[i].offset;
      uint32_t size = brw->state_batch_list[i].size;

      switch (brw->state_batch_list[i].type) {
      case AUB_TRACE_VS_STATE:
	 dump_vs_state(brw, offset);
	 break;
      case AUB_TRACE_GS_STATE:
	 dump_gs_state(brw, offset);
	 break;
      case AUB_TRACE_CLIP_STATE:
	 dump_clip_state(brw, offset);
	 break;
      case AUB_TRACE_SF_STATE:
	 dump_sf_state(brw, offset);
	 break;
      case AUB_TRACE_WM_STATE:
	 dump_wm_state(brw, offset);
	 break;
      case AUB_TRACE_CLIP_VP_STATE:
	 dump_clip_viewport_state(brw, offset);
	 break;
      case AUB_TRACE_SF_VP_STATE:
	 if (brw->gen >= 7) {
	    dump_sf_clip_viewport_state(brw, offset);
	 } else {
	    dump_sf_viewport_state(brw, offset);
	 }
	 break;
      case AUB_TRACE_CC_VP_STATE:
	 dump_cc_viewport_state(brw, offset);
	 break;
      case AUB_TRACE_DEPTH_STENCIL_STATE:
	 dump_depth_stencil_state(brw, offset);
	 break;
      case AUB_TRACE_CC_STATE:
	 if (brw->gen >= 6)
	    dump_cc_state_gen6(brw, offset);
	 else
	    dump_cc_state_gen4(brw, offset);
	 break;
      case AUB_TRACE_BLEND_STATE:
	 dump_blend_state(brw, offset);
	 break;
      case AUB_TRACE_BINDING_TABLE:
	 dump_binding_table(brw, offset, size);
	 break;
      case AUB_TRACE_SURFACE_STATE:
	 if (brw->gen < 7) {
	    dump_surface_state(brw, offset);
	 } else {
	    dump_gen7_surface_state(brw, offset);
	 }
	 break;
      case AUB_TRACE_SAMPLER_STATE:
	 if (brw->gen < 7) {
	    dump_sampler_state(brw, offset, size);
	 } else {
	    dump_gen7_sampler_state(brw, offset, size);
	 }
	 break;
      case AUB_TRACE_SAMPLER_DEFAULT_COLOR:
	 dump_sdc(brw, offset);
	 break;
      case AUB_TRACE_SCISSOR_STATE:
	 dump_scissor(brw, offset);
	 break;
      case AUB_TRACE_VS_CONSTANTS:
	 dump_vs_constants(brw, offset, size);
	 break;
      case AUB_TRACE_WM_CONSTANTS:
	 dump_wm_constants(brw, offset, size);
	 break;
      default:
	 break;
      }
   }
}

/**
 * Print additional debug information associated with the batchbuffer
 * when DEBUG_BATCH is set.
 *
 * For 965, this means mapping the state buffers that would have been referenced
 * by the batchbuffer and dumping them.
 *
 * The buffer offsets printed rely on the buffer containing the last offset
 * it was validated at.
 */
void brw_debug_batch(struct brw_context *brw)
{
   drm_intel_bo_map(brw->batch.bo, false);
   dump_state_batch(brw);
   drm_intel_bo_unmap(brw->batch.bo);

   if (0)
      dump_prog_cache(brw);
}
@


1.9
log
@Merge Mesa 10.2.9
@
text
@@


1.8
log
@Merge Mesa 10.4.3
Tested by matthieu@@ mpi@@ and myself.  landry@@ ran a ports bulk build.
kettenis@@ tracked down the cause of an alignment fault on archs
that require strict eight byte pointer alignment.
@
text
@a32 1
#include "brw_eu.h"
d245 6
a250 5
      float *sdc = brw->batch.bo->virtual + offset;
      batch_out(brw, name, offset, 0, "r %f\n", sdc[0]);
      batch_out(brw, name, offset, 1, "g %f\n", sdc[1]);
      batch_out(brw, name, offset, 2, "b %f\n", sdc[2]);
      batch_out(brw, name, offset, 3, "a %f\n", sdc[3]);
d258 1
a258 1
   uint32_t *samp = brw->batch.bo->virtual + offset;
d260 3
a262 1
   for (i = 0; i < size / 16; i++) {
d271 2
a272 2
      samp += 4;
      offset += 4 * sizeof(uint32_t);
d276 23
d489 2
a490 1
   unsigned int b;
d499 3
d527 8
a534 3
         fprintf(stderr, "%s:\n", name);
         brw_disassemble(brw, brw->cache.bo->virtual, item->offset, item->size,
                         stderr);
d602 5
a606 1
         dump_sampler_state(brw, offset, size);
@


1.7
log
@Merge Mesa 10.2.3
tested by matthieu@@ kettenis@@ mpi@@ brett@@ and myself across a
diverse range of hardware
@
text
@d33 1
d246 5
a250 6
      struct brw_sampler_default_color *sdc = (brw->batch.bo->virtual +
					       offset);
      batch_out(brw, name, offset, 0, "r %f\n", sdc->color[0]);
      batch_out(brw, name, offset, 1, "g %f\n", sdc->color[1]);
      batch_out(brw, name, offset, 2, "b %f\n", sdc->color[2]);
      batch_out(brw, name, offset, 3, "a %f\n", sdc->color[3]);
d258 1
a258 1
   struct brw_sampler_state *samp = brw->batch.bo->virtual + offset;
d260 1
a260 3
   assert(brw->gen < 7);

   for (i = 0; i < size / sizeof(*samp); i++) {
d269 2
a270 2
      samp++;
      offset += sizeof(*samp);
a273 23
static void dump_gen7_sampler_state(struct brw_context *brw,
				    uint32_t offset, uint32_t size)
{
   struct gen7_sampler_state *samp = brw->batch.bo->virtual + offset;
   int i;

   assert(brw->gen >= 7);

   for (i = 0; i < size / sizeof(*samp); i++) {
      char name[20];

      sprintf(name, "WM SAMP%d", i);
      batch_out(brw, name, offset, 0, "filtering\n");
      batch_out(brw, name, offset, 1, "wrapping, lod\n");
      batch_out(brw, name, offset, 2, "default color pointer\n");
      batch_out(brw, name, offset, 3, "chroma key, aniso\n");

      samp++;
      offset += sizeof(*samp);
   }
}


d464 1
a464 2
   unsigned int b, i;
   uint32_t *data;
a472 3
	 uint32_t offset = item->offset;

	 data = brw->cache.bo->virtual + item->offset;
d498 3
a500 8
	 for (i = 0; i < item->size / 4 / 4; i++) {
	    fprintf(stderr, "0x%08x: %8s: 0x%08x 0x%08x 0x%08x 0x%08x ",
		    offset + i * 4 * 4,
		    name,
		    data[i * 4], data[i * 4 + 1], data[i * 4 + 2], data[i * 4 + 3]);

	    brw_disasm(stderr, (void *)(data + i * 4), brw->gen);
	 }
d568 1
a568 5
	 if (brw->gen < 7) {
	    dump_sampler_state(brw, offset, size);
	 } else {
	    dump_gen7_sampler_state(brw, offset, size);
	 }
@


1.6
log
@Merge Mesa 9.2.0
@
text
@d200 1
a200 1
   batch_out(brw, name, offset, 0, "%s %s\n",
d202 2
a203 1
             get_965_surface_format(GET_FIELD(surf[0], BRW_SURFACE_FORMAT)));
d205 1
a205 1
   batch_out(brw, name, offset, 2, "%dx%d size, %d mips\n",
d208 2
a209 1
             surf[5] & INTEL_MASK(3, 0));
d213 4
a216 1
   batch_out(brw, name, offset, 4, "mip base %d\n",
d218 1
a218 1
   batch_out(brw, name, offset, 5, "x,y offset: %d,%d\n",
d221 1
d507 2
a508 2
	 case BRW_GS_PROG:
	    name = "GS kernel";
d510 3
@


1.5
log
@Upate to libGL 7.11.2

Tested by jsg@@, matthieu@@ and ajacoutot@@, ok mattieu@@
@
text
@a33 9
/**
 * Prints out a header, the contents, and the message associated with
 * the hardware state data given.
 *
 * \param name Name of the state object
 * \param data Pointer to the base of the state object
 * \param hw_offset Hardware offset of the base of the state data.
 * \param index Index of the DWORD being output.
 */
d35 2
a36 4
state_out(const char *name, void *data, uint32_t hw_offset, int index,
	  char *fmt, ...)
{
    va_list va;
a37 8
    fprintf(stderr, "%8s: 0x%08x: 0x%08x: ",
	    name, hw_offset + index * 4, ((uint32_t *)data)[index]);
    va_start(va, fmt);
    vfprintf(stderr, fmt, va);
    va_end(va);
}

/** Generic, undecoded state buffer debug printout */
d39 2
a40 2
state_struct_out(const char *name, drm_intel_bo *buffer,
		 unsigned int offset, unsigned int size)
d42 2
a43 1
   int i;
d45 5
a49 9
   if (buffer == NULL)
      return;

   drm_intel_bo_map(buffer, GL_FALSE);
   for (i = 0; i < size / 4; i++) {
      state_out(name, buffer->virtual + offset, buffer->offset + offset, i,
		"dword %d\n", i);
   }
   drm_intel_bo_unmap(buffer);
d79 1
a79 1
static void dump_wm_surface_state(struct brw_context *brw)
d81 2
a82 19
   dri_bo *bo;
   GLubyte *base;
   int i;

   bo = brw->intel.batch.bo;
   drm_intel_bo_map(bo, GL_FALSE);
   base = bo->virtual;

   for (i = 0; i < brw->wm.nr_surfaces; i++) {
      unsigned int surfoff;
      uint32_t *surf;
      char name[20];

      if (brw->wm.surf_offset[i] == 0) {
	 fprintf(stderr, "WM SURF%d: NULL\n", i);
	 continue;
      }
      surfoff = bo->offset + brw->wm.surf_offset[i];
      surf = (uint32_t *)(base + brw->wm.surf_offset[i]);
d84 132
a215 19
      sprintf(name, "WM SURF%d", i);
      state_out(name, surf, surfoff, 0, "%s %s\n",
		get_965_surfacetype(GET_FIELD(surf[0], BRW_SURFACE_TYPE)),
		get_965_surface_format(GET_FIELD(surf[0], BRW_SURFACE_FORMAT)));
      state_out(name, surf, surfoff, 1, "offset\n");
      state_out(name, surf, surfoff, 2, "%dx%d size, %d mips\n",
		GET_FIELD(surf[2], BRW_SURFACE_WIDTH) + 1,
		GET_FIELD(surf[2], BRW_SURFACE_HEIGHT) + 1);
      state_out(name, surf, surfoff, 3, "pitch %d, %s tiled\n",
		GET_FIELD(surf[3], BRW_SURFACE_PITCH) + 1,
		(surf[3] & BRW_SURFACE_TILED) ?
		((surf[3] & BRW_SURFACE_TILED_Y) ? "Y" : "X") : "not");
      state_out(name, surf, surfoff, 4, "mip base %d\n",
		GET_FIELD(surf[4], BRW_SURFACE_MIN_LOD));
      state_out(name, surf, surfoff, 5, "x,y offset: %d,%d\n",
		GET_FIELD(surf[5], BRW_SURFACE_X_OFFSET),
		GET_FIELD(surf[5], BRW_SURFACE_Y_OFFSET));
   }
   drm_intel_bo_unmap(bo);
d218 2
a219 1
static void dump_gen7_surface_state(struct brw_context *brw)
d221 1
a221 3
   dri_bo *bo;
   GLubyte *base;
   int i;
d223 22
a244 29
   bo = brw->intel.batch.bo;
   drm_intel_bo_map(bo, GL_FALSE);
   base = bo->virtual;

   for (i = 0; i < brw->wm.nr_surfaces; i++) {
      unsigned int surfoff;
      struct gen7_surface_state *surf;
      char name[20];

      if (brw->wm.surf_offset[i] == 0) {
	 fprintf(stderr, "WM SURF%d: NULL\n", i);
	 continue;
      }
      surfoff = bo->offset + brw->wm.surf_offset[i];
      surf = (struct gen7_surface_state *) (base + brw->wm.surf_offset[i]);

      sprintf(name, "WM SURF%d", i);
      state_out(name, surf, surfoff, 0, "%s %s\n",
		get_965_surfacetype(surf->ss0.surface_type),
		get_965_surface_format(surf->ss0.surface_format));
      state_out(name, surf, surfoff, 1, "offset\n");
      state_out(name, surf, surfoff, 2, "%dx%d size, %d mips\n",
		surf->ss2.width + 1, surf->ss2.height + 1, surf->ss5.mip_count);
      state_out(name, surf, surfoff, 3, "pitch %d, %stiled\n",
		surf->ss3.pitch + 1, surf->ss0.tiled_surface ? "" : "not ");
      state_out(name, surf, surfoff, 4, "mip base %d\n",
		surf->ss5.min_lod);
      state_out(name, surf, surfoff, 5, "x,y offset: %d,%d\n",
		surf->ss5.x_offset, surf->ss5.y_offset);
a245 1
   drm_intel_bo_unmap(bo);
d248 2
a249 1
static void dump_wm_sampler_state(struct brw_context *brw)
a250 2
   struct intel_context *intel = &brw->intel;
   struct gl_context *ctx = &brw->intel.ctx;
d252 1
d254 1
a254 1
   assert(intel->gen < 7);
d256 1
a256 5
   drm_intel_bo_map(intel->batch.bo, GL_FALSE);
   for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
      unsigned int offset;
      uint32_t sdc_offset;
      struct brw_sampler_state *samp;
d259 5
a263 4
      if (!ctx->Texture.Unit[i]._ReallyEnabled) {
	 fprintf(stderr, "WM SAMP%d: disabled\n", i);
	 continue;
      }
d265 2
a266 39
      offset = (intel->batch.bo->offset +
		brw->wm.sampler_offset +
		i * sizeof(struct brw_sampler_state));
      samp = (struct brw_sampler_state *)(intel->batch.bo->virtual +
					  brw->wm.sampler_offset +
					  i * sizeof(struct brw_sampler_state));

      sprintf(name, "WM SAMP%d", i);
      state_out(name, samp, offset, 0, "filtering\n");
      state_out(name, samp, offset, 1, "wrapping, lod\n");
      state_out(name, samp, offset, 2, "default color pointer\n");
      state_out(name, samp, offset, 3, "chroma key, aniso\n");

      sprintf(name, " WM SDC%d", i);

      sdc_offset = intel->batch.bo->offset + brw->wm.sdc_offset[i];
      if (intel->gen >= 5) {
	 struct gen5_sampler_default_color *sdc = (intel->batch.bo->virtual +
						   brw->wm.sdc_offset[i]);
	 state_out(name, sdc, sdc_offset, 0, "unorm rgba\n");
	 state_out(name, sdc, sdc_offset, 1, "r %f\n", sdc->f[0]);
	 state_out(name, sdc, sdc_offset, 2, "b %f\n", sdc->f[1]);
	 state_out(name, sdc, sdc_offset, 3, "g %f\n", sdc->f[2]);
	 state_out(name, sdc, sdc_offset, 4, "a %f\n", sdc->f[3]);
	 state_out(name, sdc, sdc_offset, 5, "half float rg\n");
	 state_out(name, sdc, sdc_offset, 6, "half float ba\n");
	 state_out(name, sdc, sdc_offset, 7, "u16 rg\n");
	 state_out(name, sdc, sdc_offset, 8, "u16 ba\n");
	 state_out(name, sdc, sdc_offset, 9, "s16 rg\n");
	 state_out(name, sdc, sdc_offset, 10, "s16 ba\n");
	 state_out(name, sdc, sdc_offset, 11, "s8 rgba\n");
      } else {
	 struct brw_sampler_default_color *sdc = (intel->batch.bo->virtual +
						  brw->wm.sdc_offset[i]);
	 state_out(name, sdc, sdc_offset, 0, "r %f\n", sdc->color[0]);
	 state_out(name, sdc, sdc_offset, 1, "g %f\n", sdc->color[1]);
	 state_out(name, sdc, sdc_offset, 2, "b %f\n", sdc->color[2]);
	 state_out(name, sdc, sdc_offset, 3, "a %f\n", sdc->color[3]);
      }
a267 1
   drm_intel_bo_unmap(intel->batch.bo);
d270 2
a271 1
static void dump_gen7_sampler_state(struct brw_context *brw)
d273 1
a273 2
   struct intel_context *intel = &brw->intel;
   struct gl_context *ctx = &brw->intel.ctx;
d276 1
a276 1
   assert(intel->gen >= 7);
d278 1
a278 5
   drm_intel_bo_map(intel->batch.bo, GL_FALSE);
   for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
      unsigned int offset;
      uint32_t sdc_offset;
      struct gen7_sampler_state *samp;
d281 5
a285 11
      if (!ctx->Texture.Unit[i]._ReallyEnabled) {
	 fprintf(stderr, "WM SAMP%d: disabled\n", i);
	 continue;
      }

      offset = (intel->batch.bo->offset +
		brw->wm.sampler_offset +
		i * sizeof(struct gen7_sampler_state));
      samp = (struct gen7_sampler_state *)
	     (intel->batch.bo->virtual + brw->wm.sampler_offset +
	      i * sizeof(struct gen7_sampler_state));
d287 2
a288 15
      sprintf(name, "WM SAMP%d", i);
      state_out(name, samp, offset, 0, "filtering\n");
      state_out(name, samp, offset, 1, "wrapping, lod\n");
      state_out(name, samp, offset, 2, "default color pointer\n");
      state_out(name, samp, offset, 3, "chroma key, aniso\n");

      sprintf(name, " WM SDC%d", i);

      sdc_offset = intel->batch.bo->offset + brw->wm.sdc_offset[i];
      struct brw_sampler_default_color *sdc =
	 intel->batch.bo->virtual + brw->wm.sdc_offset[i];
      state_out(name, sdc, sdc_offset, 0, "r %f\n", sdc->color[0]);
      state_out(name, sdc, sdc_offset, 1, "g %f\n", sdc->color[1]);
      state_out(name, sdc, sdc_offset, 2, "b %f\n", sdc->color[2]);
      state_out(name, sdc, sdc_offset, 3, "a %f\n", sdc->color[3]);
a289 1
   drm_intel_bo_unmap(intel->batch.bo);
d293 2
a294 1
static void dump_sf_viewport_state(struct brw_context *brw)
a295 1
   struct intel_context *intel = &brw->intel;
d297 1
a297 4
   struct brw_sf_viewport *vp;
   uint32_t vp_off;

   assert(intel->gen < 7);
d299 1
a299 1
   drm_intel_bo_map(intel->batch.bo, GL_FALSE);
d301 6
a306 2
   vp = intel->batch.bo->virtual + brw->sf.vp_offset;
   vp_off = intel->batch.bo->offset + brw->sf.vp_offset;
d308 1
a308 8
   state_out(name, vp, vp_off, 0, "m00 = %f\n", vp->viewport.m00);
   state_out(name, vp, vp_off, 1, "m11 = %f\n", vp->viewport.m11);
   state_out(name, vp, vp_off, 2, "m22 = %f\n", vp->viewport.m22);
   state_out(name, vp, vp_off, 3, "m30 = %f\n", vp->viewport.m30);
   state_out(name, vp, vp_off, 4, "m31 = %f\n", vp->viewport.m31);
   state_out(name, vp, vp_off, 5, "m32 = %f\n", vp->viewport.m32);

   state_out(name, vp, vp_off, 6, "top left = %d,%d\n",
d310 1
a310 1
   state_out(name, vp, vp_off, 7, "bottom right = %d,%d\n",
a311 2

   drm_intel_bo_unmap(intel->batch.bo);
d314 2
a315 1
static void dump_clip_viewport_state(struct brw_context *brw)
a316 1
   struct intel_context *intel = &brw->intel;
d318 1
a318 2
   struct brw_clipper_viewport *vp;
   uint32_t vp_off;
d320 1
a320 1
   assert(intel->gen < 7);
d322 4
a325 10
   drm_intel_bo_map(intel->batch.bo, GL_FALSE);

   vp = intel->batch.bo->virtual + brw->clip.vp_offset;
   vp_off = intel->batch.bo->offset + brw->clip.vp_offset;

   state_out(name, vp, vp_off, 0, "xmin = %f\n", vp->xmin);
   state_out(name, vp, vp_off, 1, "xmax = %f\n", vp->xmax);
   state_out(name, vp, vp_off, 2, "ymin = %f\n", vp->ymin);
   state_out(name, vp, vp_off, 3, "ymax = %f\n", vp->ymax);
   drm_intel_bo_unmap(intel->batch.bo);
d328 2
a329 1
static void dump_sf_clip_viewport_state(struct brw_context *brw)
a330 1
   struct intel_context *intel = &brw->intel;
d332 1
a332 2
   struct gen7_sf_clip_viewport *vp;
   uint32_t vp_off;
d334 1
a334 1
   assert(intel->gen >= 7);
d336 11
a346 1
   drm_intel_bo_map(intel->batch.bo, GL_FALSE);
a347 2
   vp = intel->batch.bo->virtual + brw->sf.vp_offset;
   vp_off = intel->batch.bo->offset + brw->sf.vp_offset;
d349 7
a355 11
   state_out(name, vp, vp_off, 0, "m00 = %f\n", vp->viewport.m00);
   state_out(name, vp, vp_off, 1, "m11 = %f\n", vp->viewport.m11);
   state_out(name, vp, vp_off, 2, "m22 = %f\n", vp->viewport.m22);
   state_out(name, vp, vp_off, 3, "m30 = %f\n", vp->viewport.m30);
   state_out(name, vp, vp_off, 4, "m31 = %f\n", vp->viewport.m31);
   state_out(name, vp, vp_off, 5, "m32 = %f\n", vp->viewport.m32);
   state_out(name, vp, vp_off, 6, "guardband xmin = %f\n", vp->guardband.xmin);
   state_out(name, vp, vp_off, 7, "guardband xmax = %f\n", vp->guardband.xmax);
   state_out(name, vp, vp_off, 8, "guardband ymin = %f\n", vp->guardband.ymin);
   state_out(name, vp, vp_off, 9, "guardband ymax = %f\n", vp->guardband.ymax);
   drm_intel_bo_unmap(intel->batch.bo);
d358 4
d363 16
a378 1
static void dump_cc_viewport_state(struct brw_context *brw)
d380 1
a380 4
   struct intel_context *intel = &brw->intel;
   const char *name = "CC VP";
   struct brw_cc_viewport *vp;
   uint32_t vp_off;
d382 9
a390 1
   drm_intel_bo_map(intel->batch.bo, GL_FALSE);
d392 4
a395 2
   vp = intel->batch.bo->virtual + brw->cc.vp_offset;
   vp_off = intel->batch.bo->offset + brw->cc.vp_offset;
d397 12
a408 3
   state_out(name, vp, vp_off, 0, "min_depth = %f\n", vp->min_depth);
   state_out(name, vp, vp_off, 1, "max_depth = %f\n", vp->max_depth);
   drm_intel_bo_unmap(intel->batch.bo);
d411 1
a411 1
static void dump_depth_stencil_state(struct brw_context *brw)
d413 1
a413 4
   struct intel_context *intel = &brw->intel;
   const char *name = "DEPTH STENCIL";
   struct gen6_depth_stencil_state *ds;
   uint32_t ds_off;
d415 3
a417 1
   drm_intel_bo_map(intel->batch.bo, GL_FALSE);
d419 5
a423 2
   ds = intel->batch.bo->virtual + brw->cc.depth_stencil_state_offset;
   ds_off = intel->batch.bo->offset + brw->cc.depth_stencil_state_offset;
d425 4
a428 11
   state_out(name, ds, ds_off, 0, "stencil %sable, func %d, write %sable\n",
		ds->ds0.stencil_enable ? "en" : "dis",
		ds->ds0.stencil_func,
		ds->ds0.stencil_write_enable ? "en" : "dis");
   state_out(name, ds, ds_off, 1, "stencil test mask 0x%x, write mask 0x%x\n",
		ds->ds1.stencil_test_mask, ds->ds1.stencil_write_mask);
   state_out(name, ds, ds_off, 2, "depth test %sable, func %d, write %sable\n",
		ds->ds2.depth_test_enable ? "en" : "dis",
		ds->ds2.depth_test_func,
		ds->ds2.depth_write_enable ? "en" : "dis");
   drm_intel_bo_unmap(intel->batch.bo);
d431 2
a432 1
static void dump_cc_state(struct brw_context *brw)
d434 4
a437 25
   const char *name = "CC";
   struct gen6_color_calc_state *cc;
   uint32_t cc_off;
   dri_bo *bo = brw->intel.batch.bo;

   if (brw->cc.state_offset == 0)
	return;

   drm_intel_bo_map(bo, GL_FALSE);
   cc = bo->virtual + brw->cc.state_offset;
   cc_off = bo->offset + brw->cc.state_offset;

   state_out(name, cc, cc_off, 0, "alpha test format %s, round disable %d, stencil ref %d,"
		"bf stencil ref %d\n",
		cc->cc0.alpha_test_format ? "FLOAT32" : "UNORM8",
		cc->cc0.round_disable,
		cc->cc0.stencil_ref,
		cc->cc0.bf_stencil_ref);
   state_out(name, cc, cc_off, 1, "\n");
   state_out(name, cc, cc_off, 2, "constant red %f\n", cc->constant_r);
   state_out(name, cc, cc_off, 3, "constant green %f\n", cc->constant_g);
   state_out(name, cc, cc_off, 4, "constant blue %f\n", cc->constant_b);
   state_out(name, cc, cc_off, 5, "constant alpha %f\n", cc->constant_a);
   
   drm_intel_bo_unmap(bo);
d439 6
d447 2
a448 1
static void dump_blend_state(struct brw_context *brw)
d450 4
a453 4
   struct intel_context *intel = &brw->intel;
   const char *name = "BLEND";
   struct gen6_blend_state *blend;
   uint32_t blend_off;
d455 7
a461 1
   drm_intel_bo_map(intel->batch.bo, GL_FALSE);
d463 6
a468 2
   blend = intel->batch.bo->virtual + brw->cc.blend_state_offset;
   blend_off = intel->batch.bo->offset + brw->cc.blend_state_offset;
d470 3
a472 4
   state_out(name, blend, blend_off, 0, "\n");
   state_out(name, blend, blend_off, 1, "\n");

   drm_intel_bo_unmap(intel->batch.bo);
d474 3
d479 2
a480 2
static void brw_debug_prog(struct brw_context *brw,
			   const char *name, uint32_t prog_offset)
d482 2
a483 1
   unsigned int i;
d488 2
a489 1
   data = brw->cache.bo->virtual + prog_offset;
d491 36
a526 12
   for (i = 0; i < brw->cache.bo->size / 4 / 4; i++) {
      fprintf(stderr, "%8s: 0x%08x: 0x%08x 0x%08x 0x%08x 0x%08x\n",
	      name, (unsigned int)brw->cache.bo->offset + i * 4 * 4,
	      data[i * 4], data[i * 4 + 1], data[i * 4 + 2], data[i * 4 + 3]);
      /* Stop at the end of the program.  It'd be nice to keep track of the actual
       * intended program size instead of guessing like this.
       */
      if (data[i * 4 + 0] == 0 &&
	  data[i * 4 + 1] == 0 &&
	  data[i * 4 + 2] == 0 &&
	  data[i * 4 + 3] == 0)
	 break;
d532 84
d627 1
a627 1
void brw_debug_batch(struct intel_context *intel)
d629 3
a631 1
   struct brw_context *brw = brw_context(&intel->ctx);
d633 2
a634 47
   state_struct_out("WM bind",
		    brw->intel.batch.bo,
		    brw->wm.bind_bo_offset,
		    4 * brw->wm.nr_surfaces);
   if (intel->gen < 7) {
      dump_wm_surface_state(brw);
      dump_wm_sampler_state(brw);
   } else {
      dump_gen7_surface_state(brw);
      dump_gen7_sampler_state(brw);
   }

   if (intel->gen < 6)
       state_struct_out("VS", intel->batch.bo, brw->vs.state_offset,
			sizeof(struct brw_vs_unit_state));
   brw_debug_prog(brw, "VS prog", brw->vs.prog_offset);

   if (intel->gen < 6)
       state_struct_out("GS", intel->batch.bo, brw->gs.state_offset,
			sizeof(struct brw_gs_unit_state));
   if (brw->gs.prog_active) {
      brw_debug_prog(brw, "GS prog", brw->gs.prog_offset);
   }

   if (intel->gen < 6) {
      state_struct_out("SF", intel->batch.bo, brw->sf.state_offset,
		       sizeof(struct brw_sf_unit_state));
      brw_debug_prog(brw, "SF prog", brw->sf.prog_offset);
   }
   if (intel->gen >= 7)
      dump_sf_clip_viewport_state(brw);
   else
      dump_sf_viewport_state(brw);
   if (intel->gen == 6)
      dump_clip_viewport_state(brw);

   if (intel->gen < 6)
       state_struct_out("WM", intel->batch.bo, brw->wm.state_offset,
			sizeof(struct brw_wm_unit_state));
   brw_debug_prog(brw, "WM prog", brw->wm.prog_offset);

   if (intel->gen >= 6) {
	dump_cc_viewport_state(brw);
	dump_depth_stencil_state(brw);
	dump_cc_state(brw);
	dump_blend_state(brw);
   }
@


1.4
log
@Merge Mesa 7.10.3
@
text
@d29 1
d58 2
a59 1
state_struct_out(const char *name, drm_intel_bo *buffer, unsigned int state_size)
d67 2
a68 2
   for (i = 0; i < state_size / 4; i++) {
      state_out(name, buffer->virtual, buffer->offset, i,
d103 2
d107 4
a111 1
      drm_intel_bo *surf_bo = brw->wm.surf_bo[i];
d113 1
a113 1
      struct brw_surface_state *surf;
d116 1
a116 1
      if (surf_bo == NULL) {
d120 45
a164 3
      drm_intel_bo_map(surf_bo, GL_FALSE);
      surfoff = surf_bo->offset + brw->wm.surf_offset[i];
      surf = (struct brw_surface_state *)(surf_bo->virtual + brw->wm.surf_offset[i]);
d172 1
a172 1
		surf->ss2.width + 1, surf->ss2.height + 1, surf->ss2.mip_count);
d174 1
a174 1
		surf->ss3.pitch + 1, surf->ss3.tiled_surface ? "" : "not ");
d176 1
a176 1
		surf->ss4.min_lod);
a178 2

      drm_intel_bo_unmap(surf_bo);
d180 1
a182 1

d185 1
d189 1
a189 4
   if (!brw->wm.sampler_bo) {
      fprintf(stderr, "WM_SAMPLER: NULL\n");
      return;
   }
d191 1
a191 1
   drm_intel_bo_map(brw->wm.sampler_bo, GL_FALSE);
d194 1
a195 1
      struct brw_sampler_default_color *sdc;
d203 5
a207 3
      offset = brw->wm.sampler_bo->offset +
	 i * sizeof(struct brw_sampler_state);
      samp = (struct brw_sampler_state *)(brw->wm.sampler_bo->virtual +
d218 24
a241 7
      drm_intel_bo_map(brw->wm.sdc_bo[i], GL_FALSE);
      sdc = (struct brw_sampler_default_color *)(brw->wm.sdc_bo[i]->virtual);
      state_out(name, sdc, brw->wm.sdc_bo[i]->offset, 0, "r\n");
      state_out(name, sdc, brw->wm.sdc_bo[i]->offset, 1, "g\n");
      state_out(name, sdc, brw->wm.sdc_bo[i]->offset, 2, "b\n");
      state_out(name, sdc, brw->wm.sdc_bo[i]->offset, 3, "a\n");
      drm_intel_bo_unmap(brw->wm.sdc_bo[i]);
d243 1
a243 1
   drm_intel_bo_unmap(brw->wm.sampler_bo);
d246 47
d295 1
d300 1
a300 2
   if (brw->sf.vp_bo == NULL)
      return;
d302 1
a302 1
   drm_intel_bo_map(brw->sf.vp_bo, GL_FALSE);
d304 2
a305 2
   vp = brw->sf.vp_bo->virtual;
   vp_off = brw->sf.vp_bo->offset;
d319 1
a319 1
   drm_intel_bo_unmap(brw->sf.vp_bo);
d324 1
d329 1
a329 2
   if (brw->clip.vp_bo == NULL)
      return;
d331 1
a331 1
   drm_intel_bo_map(brw->clip.vp_bo, GL_FALSE);
d333 2
a334 2
   vp = brw->clip.vp_bo->virtual;
   vp_off = brw->clip.vp_bo->offset;
d340 28
a367 1
   drm_intel_bo_unmap(brw->clip.vp_bo);
d370 1
d373 1
d378 1
a378 4
   if (brw->cc.vp_bo == NULL)
      return;

   drm_intel_bo_map(brw->cc.vp_bo, GL_FALSE);
d380 2
a381 2
   vp = brw->cc.vp_bo->virtual;
   vp_off = brw->cc.vp_bo->offset;
d385 1
a385 1
   drm_intel_bo_unmap(brw->cc.vp_bo);
d390 1
d395 1
a395 2
   if (brw->cc.depth_stencil_state_bo == NULL)
	return;
d397 2
a398 4
   drm_intel_bo_map(brw->cc.depth_stencil_state_bo, GL_FALSE);

   ds = brw->cc.depth_stencil_state_bo->virtual;
   ds_off = brw->cc.depth_stencil_state_bo->offset;
d410 1
a410 1
   drm_intel_bo_unmap(brw->cc.depth_stencil_state_bo); 
d418 1
d420 1
a420 1
   if (brw->cc.state_bo == NULL)
d423 3
a425 3
   drm_intel_bo_map(brw->cc.state_bo, GL_FALSE);
   cc = brw->cc.state_bo->virtual;
   cc_off = brw->cc.state_bo->offset;
d439 1
a439 1
   drm_intel_bo_unmap(brw->cc.state_bo);
d445 1
d450 1
a450 4
   if (brw->cc.blend_state_bo == NULL)
	return;

   drm_intel_bo_map(brw->cc.blend_state_bo, GL_FALSE);
d452 2
a453 2
   blend = brw->cc.blend_state_bo->virtual;
   blend_off = brw->cc.blend_state_bo->offset;
d458 1
a458 1
   drm_intel_bo_unmap(brw->cc.blend_state_bo);
d462 2
a463 1
static void brw_debug_prog(const char *name, drm_intel_bo *prog)
d468 1
a468 4
   if (prog == NULL)
      return;

   drm_intel_bo_map(prog, GL_FALSE);
d470 1
a470 1
   data = prog->virtual;
d472 1
a472 1
   for (i = 0; i < prog->size / 4 / 4; i++) {
d474 1
a474 1
	      name, (unsigned int)prog->offset + i * 4 * 4,
d486 1
a486 1
   drm_intel_bo_unmap(prog);
d504 11
a514 3
   state_struct_out("WM bind", brw->wm.bind_bo, 4 * brw->wm.nr_surfaces);
   dump_wm_surface_state(brw);
   dump_wm_sampler_state(brw);
d517 3
a519 2
       state_struct_out("VS", brw->vs.state_bo, sizeof(struct brw_vs_unit_state));
   brw_debug_prog("VS prog", brw->vs.prog_bo);
d522 5
a526 2
       state_struct_out("GS", brw->gs.state_bo, sizeof(struct brw_gs_unit_state));
   brw_debug_prog("GS prog", brw->gs.prog_bo);
d529 3
a531 2
       state_struct_out("SF", brw->sf.state_bo, sizeof(struct brw_sf_unit_state));
       brw_debug_prog("SF prog", brw->sf.prog_bo);
d533 6
a538 1
   dump_sf_viewport_state(brw);
d541 3
a543 2
       state_struct_out("WM", brw->wm.state_bo, sizeof(struct brw_wm_unit_state));
   brw_debug_prog("WM prog", brw->wm.prog_bo);
a546 1
	dump_clip_viewport_state(brw);
@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d57 1
a57 1
state_struct_out(const char *name, dri_bo *buffer, unsigned int state_size)
d64 1
a64 1
   dri_bo_map(buffer, GL_FALSE);
d69 1
a69 1
   dri_bo_unmap(buffer);
d104 1
a104 1
      dri_bo *surf_bo = brw->wm.surf_bo[i];
d110 1
a110 1
	 fprintf(stderr, "  WM SS%d: NULL\n", i);
d113 3
a115 3
      dri_bo_map(surf_bo, GL_FALSE);
      surfoff = surf_bo->offset;
      surf = (struct brw_surface_state *)(surf_bo->virtual);
d117 1
a117 1
      sprintf(name, "WM SS%d", i);
d131 1
a131 1
      dri_bo_unmap(surf_bo);
d135 47
d191 1
a191 1
   dri_bo_map(brw->sf.vp_bo, GL_FALSE);
d208 97
a304 1
   dri_bo_unmap(brw->sf.vp_bo);
d307 22
a328 1
static void brw_debug_prog(const char *name, dri_bo *prog)
d336 1
a336 1
   dri_bo_map(prog, GL_FALSE);
d354 1
a354 1
   dri_bo_unmap(prog);
d374 1
d376 2
a377 1
   state_struct_out("VS", brw->vs.state_bo, sizeof(struct brw_vs_unit_state));
d380 2
a381 1
   state_struct_out("GS", brw->gs.state_bo, sizeof(struct brw_gs_unit_state));
d384 4
a387 1
   state_struct_out("SF", brw->sf.state_bo, sizeof(struct brw_sf_unit_state));
a388 1
   brw_debug_prog("SF prog", brw->sf.prog_bo);
d390 2
a391 1
   state_struct_out("WM", brw->wm.state_bo, sizeof(struct brw_wm_unit_state));
d393 8
@


1.2
log
@Update to Mesa 7.4.2. Tested by oga@@, ckuethe@@ and naddy@@.
@
text
@a30 1
#include "brw_state.h"
d86 13
d110 1
a110 1
	 fprintf(stderr, "WM SS%d: NULL\n", i);
d118 3
a120 2
      state_out(name, surf, surfoff, 0, "%s\n",
		get_965_surfacetype(surf->ss0.surface_type));
d128 2
d180 8
@


1.1
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d28 1
a28 1
#include "mtypes.h"
@


1.1.1.1
log
@Import Mesa 7.10.3
@
text
@d28 1
a28 1
#include "main/mtypes.h"
d31 1
d58 1
a58 1
state_struct_out(const char *name, drm_intel_bo *buffer, unsigned int state_size)
d65 1
a65 1
   drm_intel_bo_map(buffer, GL_FALSE);
d70 1
a70 1
   drm_intel_bo_unmap(buffer);
a86 13
static const char *
get_965_surface_format(unsigned int surface_format)
{
    switch (surface_format) {
    case 0x000: return "r32g32b32a32_float";
    case 0x0c1: return "b8g8r8a8_unorm";
    case 0x100: return "b5g6r5_unorm";
    case 0x102: return "b5g5r5a1_unorm";
    case 0x104: return "b4g4r4a4_unorm";
    default: return "unknown";
    }
}

d92 1
a92 1
      drm_intel_bo *surf_bo = brw->wm.surf_bo[i];
d98 1
a98 1
	 fprintf(stderr, "WM SURF%d: NULL\n", i);
d101 7
a107 8
      drm_intel_bo_map(surf_bo, GL_FALSE);
      surfoff = surf_bo->offset + brw->wm.surf_offset[i];
      surf = (struct brw_surface_state *)(surf_bo->virtual + brw->wm.surf_offset[i]);

      sprintf(name, "WM SURF%d", i);
      state_out(name, surf, surfoff, 0, "%s %s\n",
		get_965_surfacetype(surf->ss0.surface_type),
		get_965_surface_format(surf->ss0.surface_format));
a114 2
      state_out(name, surf, surfoff, 5, "x,y offset: %d,%d\n",
		surf->ss5.x_offset, surf->ss5.y_offset);
d116 1
a116 1
      drm_intel_bo_unmap(surf_bo);
a119 47

static void dump_wm_sampler_state(struct brw_context *brw)
{
   struct gl_context *ctx = &brw->intel.ctx;
   int i;

   if (!brw->wm.sampler_bo) {
      fprintf(stderr, "WM_SAMPLER: NULL\n");
      return;
   }

   drm_intel_bo_map(brw->wm.sampler_bo, GL_FALSE);
   for (i = 0; i < BRW_MAX_TEX_UNIT; i++) {
      unsigned int offset;
      struct brw_sampler_state *samp;
      struct brw_sampler_default_color *sdc;
      char name[20];

      if (!ctx->Texture.Unit[i]._ReallyEnabled) {
	 fprintf(stderr, "WM SAMP%d: disabled\n", i);
	 continue;
      }

      offset = brw->wm.sampler_bo->offset +
	 i * sizeof(struct brw_sampler_state);
      samp = (struct brw_sampler_state *)(brw->wm.sampler_bo->virtual +
					  i * sizeof(struct brw_sampler_state));

      sprintf(name, "WM SAMP%d", i);
      state_out(name, samp, offset, 0, "filtering\n");
      state_out(name, samp, offset, 1, "wrapping, lod\n");
      state_out(name, samp, offset, 2, "default color pointer\n");
      state_out(name, samp, offset, 3, "chroma key, aniso\n");

      sprintf(name, " WM SDC%d", i);

      drm_intel_bo_map(brw->wm.sdc_bo[i], GL_FALSE);
      sdc = (struct brw_sampler_default_color *)(brw->wm.sdc_bo[i]->virtual);
      state_out(name, sdc, brw->wm.sdc_bo[i]->offset, 0, "r\n");
      state_out(name, sdc, brw->wm.sdc_bo[i]->offset, 1, "g\n");
      state_out(name, sdc, brw->wm.sdc_bo[i]->offset, 2, "b\n");
      state_out(name, sdc, brw->wm.sdc_bo[i]->offset, 3, "a\n");
      drm_intel_bo_unmap(brw->wm.sdc_bo[i]);
   }
   drm_intel_bo_unmap(brw->wm.sampler_bo);
}

d129 1
a129 1
   drm_intel_bo_map(brw->sf.vp_bo, GL_FALSE);
d146 1
a146 22
   drm_intel_bo_unmap(brw->sf.vp_bo);
}

static void dump_clip_viewport_state(struct brw_context *brw)
{
   const char *name = "CLIP VP";
   struct brw_clipper_viewport *vp;
   uint32_t vp_off;

   if (brw->clip.vp_bo == NULL)
      return;

   drm_intel_bo_map(brw->clip.vp_bo, GL_FALSE);

   vp = brw->clip.vp_bo->virtual;
   vp_off = brw->clip.vp_bo->offset;

   state_out(name, vp, vp_off, 0, "xmin = %f\n", vp->xmin);
   state_out(name, vp, vp_off, 1, "xmax = %f\n", vp->xmax);
   state_out(name, vp, vp_off, 2, "ymin = %f\n", vp->ymin);
   state_out(name, vp, vp_off, 3, "ymax = %f\n", vp->ymax);
   drm_intel_bo_unmap(brw->clip.vp_bo);
d149 1
a149 97
static void dump_cc_viewport_state(struct brw_context *brw)
{
   const char *name = "CC VP";
   struct brw_cc_viewport *vp;
   uint32_t vp_off;

   if (brw->cc.vp_bo == NULL)
      return;

   drm_intel_bo_map(brw->cc.vp_bo, GL_FALSE);

   vp = brw->cc.vp_bo->virtual;
   vp_off = brw->cc.vp_bo->offset;

   state_out(name, vp, vp_off, 0, "min_depth = %f\n", vp->min_depth);
   state_out(name, vp, vp_off, 1, "max_depth = %f\n", vp->max_depth);
   drm_intel_bo_unmap(brw->cc.vp_bo);
}

static void dump_depth_stencil_state(struct brw_context *brw)
{
   const char *name = "DEPTH STENCIL";
   struct gen6_depth_stencil_state *ds;
   uint32_t ds_off;

   if (brw->cc.depth_stencil_state_bo == NULL)
	return;

   drm_intel_bo_map(brw->cc.depth_stencil_state_bo, GL_FALSE);

   ds = brw->cc.depth_stencil_state_bo->virtual;
   ds_off = brw->cc.depth_stencil_state_bo->offset;

   state_out(name, ds, ds_off, 0, "stencil %sable, func %d, write %sable\n",
		ds->ds0.stencil_enable ? "en" : "dis",
		ds->ds0.stencil_func,
		ds->ds0.stencil_write_enable ? "en" : "dis");
   state_out(name, ds, ds_off, 1, "stencil test mask 0x%x, write mask 0x%x\n",
		ds->ds1.stencil_test_mask, ds->ds1.stencil_write_mask);
   state_out(name, ds, ds_off, 2, "depth test %sable, func %d, write %sable\n",
		ds->ds2.depth_test_enable ? "en" : "dis",
		ds->ds2.depth_test_func,
		ds->ds2.depth_write_enable ? "en" : "dis");
   drm_intel_bo_unmap(brw->cc.depth_stencil_state_bo); 
}

static void dump_cc_state(struct brw_context *brw)
{
   const char *name = "CC";
   struct gen6_color_calc_state *cc;
   uint32_t cc_off;

   if (brw->cc.state_bo == NULL)
	return;

   drm_intel_bo_map(brw->cc.state_bo, GL_FALSE);
   cc = brw->cc.state_bo->virtual;
   cc_off = brw->cc.state_bo->offset;

   state_out(name, cc, cc_off, 0, "alpha test format %s, round disable %d, stencil ref %d,"
		"bf stencil ref %d\n",
		cc->cc0.alpha_test_format ? "FLOAT32" : "UNORM8",
		cc->cc0.round_disable,
		cc->cc0.stencil_ref,
		cc->cc0.bf_stencil_ref);
   state_out(name, cc, cc_off, 1, "\n");
   state_out(name, cc, cc_off, 2, "constant red %f\n", cc->constant_r);
   state_out(name, cc, cc_off, 3, "constant green %f\n", cc->constant_g);
   state_out(name, cc, cc_off, 4, "constant blue %f\n", cc->constant_b);
   state_out(name, cc, cc_off, 5, "constant alpha %f\n", cc->constant_a);
   
   drm_intel_bo_unmap(brw->cc.state_bo);

}

static void dump_blend_state(struct brw_context *brw)
{
   const char *name = "BLEND";
   struct gen6_blend_state *blend;
   uint32_t blend_off;

   if (brw->cc.blend_state_bo == NULL)
	return;

   drm_intel_bo_map(brw->cc.blend_state_bo, GL_FALSE);

   blend = brw->cc.blend_state_bo->virtual;
   blend_off = brw->cc.blend_state_bo->offset;

   state_out(name, blend, blend_off, 0, "\n");
   state_out(name, blend, blend_off, 1, "\n");

   drm_intel_bo_unmap(brw->cc.blend_state_bo);

}

static void brw_debug_prog(const char *name, drm_intel_bo *prog)
d157 1
a157 1
   drm_intel_bo_map(prog, GL_FALSE);
a164 8
      /* Stop at the end of the program.  It'd be nice to keep track of the actual
       * intended program size instead of guessing like this.
       */
      if (data[i * 4 + 0] == 0 &&
	  data[i * 4 + 1] == 0 &&
	  data[i * 4 + 2] == 0 &&
	  data[i * 4 + 3] == 0)
	 break;
d167 1
a167 1
   drm_intel_bo_unmap(prog);
a186 1
   dump_wm_sampler_state(brw);
d188 1
a188 2
   if (intel->gen < 6)
       state_struct_out("VS", brw->vs.state_bo, sizeof(struct brw_vs_unit_state));
d191 1
a191 2
   if (intel->gen < 6)
       state_struct_out("GS", brw->gs.state_bo, sizeof(struct brw_gs_unit_state));
d194 1
a194 4
   if (intel->gen < 6) {
       state_struct_out("SF", brw->sf.state_bo, sizeof(struct brw_sf_unit_state));
       brw_debug_prog("SF prog", brw->sf.prog_bo);
   }
d196 1
d198 1
a198 2
   if (intel->gen < 6)
       state_struct_out("WM", brw->wm.state_bo, sizeof(struct brw_wm_unit_state));
a199 8

   if (intel->gen >= 6) {
	dump_cc_viewport_state(brw);
	dump_clip_viewport_state(brw);
	dump_depth_stencil_state(brw);
	dump_cc_state(brw);
	dump_blend_state(brw);
   }
@


1.1.1.2
log
@Import Mesa 9.2.0
@
text
@a28 1
#include "intel_batchbuffer.h"
d33 9
d43 4
a46 2
batch_out(struct brw_context *brw, const char *name, uint32_t offset,
	  int index, char *fmt, ...) PRINTFLIKE(5, 6);
d48 8
d57 1
a57 2
batch_out(struct brw_context *brw, const char *name, uint32_t offset,
	  int index, char *fmt, ...)
d59 1
a59 2
   uint32_t *data = brw->batch.bo->virtual + offset;
   va_list va;
d61 9
a69 5
   fprintf(stderr, "0x%08x:      0x%08x: %8s: ",
	   offset + index * 4, data[index], name);
   va_start(va, fmt);
   vfprintf(stderr, fmt, va);
   va_end(va);
d99 1
a99 1
static void dump_vs_state(struct brw_context *brw, uint32_t offset)
d101 1
a101 2
   const char *name = "VS_STATE";
   struct brw_vs_unit_state *vs = brw->batch.bo->virtual + offset;
d103 5
a107 133
   batch_out(brw, name, offset, 0, "thread0\n");
   batch_out(brw, name, offset, 1, "thread1\n");
   batch_out(brw, name, offset, 2, "thread2\n");
   batch_out(brw, name, offset, 3, "thread3\n");
   batch_out(brw, name, offset, 4, "thread4: %d threads\n",
	     vs->thread4.max_threads + 1);
   batch_out(brw, name, offset, 5, "vs5\n");
   batch_out(brw, name, offset, 6, "vs6\n");
}

static void dump_gs_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "GS_STATE";
   struct brw_gs_unit_state *gs = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0, "thread0\n");
   batch_out(brw, name, offset, 1, "thread1\n");
   batch_out(brw, name, offset, 2, "thread2\n");
   batch_out(brw, name, offset, 3, "thread3\n");
   batch_out(brw, name, offset, 4, "thread4: %d threads\n",
	     gs->thread4.max_threads + 1);
   batch_out(brw, name, offset, 5, "vs5\n");
   batch_out(brw, name, offset, 6, "vs6\n");
}

static void dump_clip_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "CLIP_STATE";
   struct brw_clip_unit_state *clip = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0, "thread0\n");
   batch_out(brw, name, offset, 1, "thread1\n");
   batch_out(brw, name, offset, 2, "thread2\n");
   batch_out(brw, name, offset, 3, "thread3\n");
   batch_out(brw, name, offset, 4, "thread4: %d threads\n",
	     clip->thread4.max_threads + 1);
   batch_out(brw, name, offset, 5, "clip5\n");
   batch_out(brw, name, offset, 6, "clip6\n");
   batch_out(brw, name, offset, 7, "vp xmin %f\n", clip->viewport_xmin);
   batch_out(brw, name, offset, 8, "vp xmax %f\n", clip->viewport_xmax);
   batch_out(brw, name, offset, 9, "vp ymin %f\n", clip->viewport_ymin);
   batch_out(brw, name, offset, 10, "vp ymax %f\n", clip->viewport_ymax);
}

static void dump_sf_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "SF_STATE";
   struct brw_sf_unit_state *sf = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0, "thread0\n");
   batch_out(brw, name, offset, 1, "thread1\n");
   batch_out(brw, name, offset, 2, "thread2\n");
   batch_out(brw, name, offset, 3, "thread3\n");
   batch_out(brw, name, offset, 4, "thread4: %d threads\n",
	     sf->thread4.max_threads + 1);
   batch_out(brw, name, offset, 5, "sf5: viewport offset\n");
   batch_out(brw, name, offset, 6, "sf6\n");
   batch_out(brw, name, offset, 7, "sf7\n");
}

static void dump_wm_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "WM_STATE";
   struct brw_wm_unit_state *wm = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0, "thread0\n");
   batch_out(brw, name, offset, 1, "thread1\n");
   batch_out(brw, name, offset, 2, "thread2\n");
   batch_out(brw, name, offset, 3, "thread3\n");
   batch_out(brw, name, offset, 4, "wm4\n");
   batch_out(brw, name, offset, 5, "wm5: %s%s%s%s%s%s, %d threads\n",
	     wm->wm5.enable_8_pix ? "8pix" : "",
	     wm->wm5.enable_16_pix ? "16pix" : "",
	     wm->wm5.program_uses_depth ? ", uses depth" : "",
	     wm->wm5.program_computes_depth ? ", computes depth" : "",
	     wm->wm5.program_uses_killpixel ? ", kills" : "",
	     wm->wm5.thread_dispatch_enable ? "" : ", no dispatch",
	     wm->wm5.max_threads + 1);
   batch_out(brw, name, offset, 6, "depth offset constant %f\n",
	     wm->global_depth_offset_constant);
   batch_out(brw, name, offset, 7, "depth offset scale %f\n",
	     wm->global_depth_offset_scale);
   batch_out(brw, name, offset, 8, "wm8: kernel 1 (gen5+)\n");
   batch_out(brw, name, offset, 9, "wm9: kernel 2 (gen5+)\n");
   batch_out(brw, name, offset, 10, "wm10: kernel 3 (gen5+)\n");
}

static void dump_surface_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "SURF";
   uint32_t *surf = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0, "%s %s\n",
	     get_965_surfacetype(GET_FIELD(surf[0], BRW_SURFACE_TYPE)),
	     get_965_surface_format(GET_FIELD(surf[0], BRW_SURFACE_FORMAT)));
   batch_out(brw, name, offset, 1, "offset\n");
   batch_out(brw, name, offset, 2, "%dx%d size, %d mips\n",
	     GET_FIELD(surf[2], BRW_SURFACE_WIDTH) + 1,
	     GET_FIELD(surf[2], BRW_SURFACE_HEIGHT) + 1,
	     GET_FIELD(surf[2], BRW_SURFACE_LOD));
   batch_out(brw, name, offset, 3, "pitch %d, %s tiled\n",
	     GET_FIELD(surf[3], BRW_SURFACE_PITCH) + 1,
	     (surf[3] & BRW_SURFACE_TILED) ?
	     ((surf[3] & BRW_SURFACE_TILED_Y) ? "Y" : "X") : "not");
   batch_out(brw, name, offset, 4, "mip base %d\n",
	     GET_FIELD(surf[4], BRW_SURFACE_MIN_LOD));
   batch_out(brw, name, offset, 5, "x,y offset: %d,%d\n",
	     GET_FIELD(surf[5], BRW_SURFACE_X_OFFSET),
	     GET_FIELD(surf[5], BRW_SURFACE_Y_OFFSET));
}

static void dump_gen7_surface_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "SURF";
   uint32_t *surf = brw->batch.bo->virtual + offset;

   batch_out(brw, name, offset, 0, "%s %s\n",
             get_965_surfacetype(GET_FIELD(surf[0], BRW_SURFACE_TYPE)),
             get_965_surface_format(GET_FIELD(surf[0], BRW_SURFACE_FORMAT)));
   batch_out(brw, name, offset, 1, "offset\n");
   batch_out(brw, name, offset, 2, "%dx%d size, %d mips\n",
             GET_FIELD(surf[2], GEN7_SURFACE_WIDTH) + 1,
             GET_FIELD(surf[2], GEN7_SURFACE_HEIGHT) + 1,
             surf[5] & INTEL_MASK(3, 0));
   batch_out(brw, name, offset, 3, "pitch %d, %stiled\n",
	     (surf[3] & INTEL_MASK(17, 0)) + 1,
             (surf[0] & (1 << 14)) ? "" : "not ");
   batch_out(brw, name, offset, 4, "mip base %d\n",
             GET_FIELD(surf[5], GEN7_SURFACE_MIN_LOD));
   batch_out(brw, name, offset, 5, "x,y offset: %d,%d\n",
             GET_FIELD(surf[5], BRW_SURFACE_X_OFFSET),
             GET_FIELD(surf[5], BRW_SURFACE_Y_OFFSET));
}
d109 21
a129 4
static void
dump_sdc(struct brw_context *brw, uint32_t offset)
{
   const char *name = "SDC";
d131 1
a131 22
   if (brw->gen >= 5 && brw->gen <= 6) {
      struct gen5_sampler_default_color *sdc = (brw->batch.bo->virtual +
						offset);
      batch_out(brw, name, offset, 0, "unorm rgba\n");
      batch_out(brw, name, offset, 1, "r %f\n", sdc->f[0]);
      batch_out(brw, name, offset, 2, "b %f\n", sdc->f[1]);
      batch_out(brw, name, offset, 3, "g %f\n", sdc->f[2]);
      batch_out(brw, name, offset, 4, "a %f\n", sdc->f[3]);
      batch_out(brw, name, offset, 5, "half float rg\n");
      batch_out(brw, name, offset, 6, "half float ba\n");
      batch_out(brw, name, offset, 7, "u16 rg\n");
      batch_out(brw, name, offset, 8, "u16 ba\n");
      batch_out(brw, name, offset, 9, "s16 rg\n");
      batch_out(brw, name, offset, 10, "s16 ba\n");
      batch_out(brw, name, offset, 11, "s8 rgba\n");
   } else {
      struct brw_sampler_default_color *sdc = (brw->batch.bo->virtual +
					       offset);
      batch_out(brw, name, offset, 0, "r %f\n", sdc->color[0]);
      batch_out(brw, name, offset, 1, "g %f\n", sdc->color[1]);
      batch_out(brw, name, offset, 2, "b %f\n", sdc->color[2]);
      batch_out(brw, name, offset, 3, "a %f\n", sdc->color[3]);
d135 2
a136 2
static void dump_sampler_state(struct brw_context *brw,
			       uint32_t offset, uint32_t size)
d138 1
a139 1
   struct brw_sampler_state *samp = brw->batch.bo->virtual + offset;
d141 4
a144 1
   assert(brw->gen < 7);
d146 5
a150 1
   for (i = 0; i < size / sizeof(*samp); i++) {
d153 4
a156 16
      sprintf(name, "WM SAMP%d", i);
      batch_out(brw, name, offset, 0, "filtering\n");
      batch_out(brw, name, offset, 1, "wrapping, lod\n");
      batch_out(brw, name, offset, 2, "default color pointer\n");
      batch_out(brw, name, offset, 3, "chroma key, aniso\n");

      samp++;
      offset += sizeof(*samp);
   }
}

static void dump_gen7_sampler_state(struct brw_context *brw,
				    uint32_t offset, uint32_t size)
{
   struct gen7_sampler_state *samp = brw->batch.bo->virtual + offset;
   int i;
d158 4
a161 4
   assert(brw->gen >= 7);

   for (i = 0; i < size / sizeof(*samp); i++) {
      char name[20];
d164 14
a177 7
      batch_out(brw, name, offset, 0, "filtering\n");
      batch_out(brw, name, offset, 1, "wrapping, lod\n");
      batch_out(brw, name, offset, 2, "default color pointer\n");
      batch_out(brw, name, offset, 3, "chroma key, aniso\n");

      samp++;
      offset += sizeof(*samp);
d179 1
d182 1
a182 3

static void dump_sf_viewport_state(struct brw_context *brw,
				   uint32_t offset)
d185 5
a189 1
   struct brw_sf_viewport *vp = brw->batch.bo->virtual + offset;
d191 1
a191 1
   assert(brw->gen < 7);
d193 2
a194 6
   batch_out(brw, name, offset, 0, "m00 = %f\n", vp->viewport.m00);
   batch_out(brw, name, offset, 1, "m11 = %f\n", vp->viewport.m11);
   batch_out(brw, name, offset, 2, "m22 = %f\n", vp->viewport.m22);
   batch_out(brw, name, offset, 3, "m30 = %f\n", vp->viewport.m30);
   batch_out(brw, name, offset, 4, "m31 = %f\n", vp->viewport.m31);
   batch_out(brw, name, offset, 5, "m32 = %f\n", vp->viewport.m32);
d196 8
a203 1
   batch_out(brw, name, offset, 6, "top left = %d,%d\n",
d205 1
a205 1
   batch_out(brw, name, offset, 7, "bottom right = %d,%d\n",
d207 2
d211 1
a211 2
static void dump_clip_viewport_state(struct brw_context *brw,
				     uint32_t offset)
d214 2
a215 3
   struct brw_clipper_viewport *vp = brw->batch.bo->virtual + offset;

   assert(brw->gen < 7);
d217 2
a218 5
   batch_out(brw, name, offset, 0, "xmin = %f\n", vp->xmin);
   batch_out(brw, name, offset, 1, "xmax = %f\n", vp->xmax);
   batch_out(brw, name, offset, 2, "ymin = %f\n", vp->ymin);
   batch_out(brw, name, offset, 3, "ymax = %f\n", vp->ymax);
}
d220 1
a220 5
static void dump_sf_clip_viewport_state(struct brw_context *brw,
					uint32_t offset)
{
   const char *name = "SF_CLIP VP";
   struct gen7_sf_clip_viewport *vp = brw->batch.bo->virtual + offset;
d222 2
a223 1
   assert(brw->gen >= 7);
d225 5
a229 10
   batch_out(brw, name, offset, 0, "m00 = %f\n", vp->viewport.m00);
   batch_out(brw, name, offset, 1, "m11 = %f\n", vp->viewport.m11);
   batch_out(brw, name, offset, 2, "m22 = %f\n", vp->viewport.m22);
   batch_out(brw, name, offset, 3, "m30 = %f\n", vp->viewport.m30);
   batch_out(brw, name, offset, 4, "m31 = %f\n", vp->viewport.m31);
   batch_out(brw, name, offset, 5, "m32 = %f\n", vp->viewport.m32);
   batch_out(brw, name, offset, 6, "guardband xmin = %f\n", vp->guardband.xmin);
   batch_out(brw, name, offset, 7, "guardband xmax = %f\n", vp->guardband.xmax);
   batch_out(brw, name, offset, 8, "guardband ymin = %f\n", vp->guardband.ymin);
   batch_out(brw, name, offset, 9, "guardband ymax = %f\n", vp->guardband.ymax);
d232 1
a232 2

static void dump_cc_viewport_state(struct brw_context *brw, uint32_t offset)
d235 2
a236 1
   struct brw_cc_viewport *vp = brw->batch.bo->virtual + offset;
d238 4
a241 3
   batch_out(brw, name, offset, 0, "min_depth = %f\n", vp->min_depth);
   batch_out(brw, name, offset, 1, "max_depth = %f\n", vp->max_depth);
}
d243 2
a244 4
static void dump_depth_stencil_state(struct brw_context *brw, uint32_t offset)
{
   const char *name = "D_S";
   struct gen6_depth_stencil_state *ds = brw->batch.bo->virtual + offset;
d246 3
a248 13
   batch_out(brw, name, offset, 0,
	     "stencil %sable, func %d, write %sable\n",
	     ds->ds0.stencil_enable ? "en" : "dis",
	     ds->ds0.stencil_func,
	     ds->ds0.stencil_write_enable ? "en" : "dis");
   batch_out(brw, name, offset, 1,
	     "stencil test mask 0x%x, write mask 0x%x\n",
	     ds->ds1.stencil_test_mask, ds->ds1.stencil_write_mask);
   batch_out(brw, name, offset, 2,
	     "depth test %sable, func %d, write %sable\n",
	     ds->ds2.depth_test_enable ? "en" : "dis",
	     ds->ds2.depth_test_func,
	     ds->ds2.depth_write_enable ? "en" : "dis");
d251 1
a251 1
static void dump_cc_state_gen4(struct brw_context *brw, uint32_t offset)
d253 6
a258 1
   const char *name = "CC";
d260 1
a260 9
   batch_out(brw, name, offset, 0, "cc0\n");
   batch_out(brw, name, offset, 1, "cc1\n");
   batch_out(brw, name, offset, 2, "cc2\n");
   batch_out(brw, name, offset, 3, "cc3\n");
   batch_out(brw, name, offset, 4, "cc4: viewport offset\n");
   batch_out(brw, name, offset, 5, "cc5\n");
   batch_out(brw, name, offset, 6, "cc6\n");
   batch_out(brw, name, offset, 7, "cc7\n");
}
d262 2
a263 4
static void dump_cc_state_gen6(struct brw_context *brw, uint32_t offset)
{
   const char *name = "CC";
   struct gen6_color_calc_state *cc = brw->batch.bo->virtual + offset;
d265 11
a275 12
   batch_out(brw, name, offset, 0,
	     "alpha test format %s, round disable %d, stencil ref %d, "
	     "bf stencil ref %d\n",
	     cc->cc0.alpha_test_format ? "FLOAT32" : "UNORM8",
	     cc->cc0.round_disable,
	     cc->cc0.stencil_ref,
	     cc->cc0.bf_stencil_ref);
   batch_out(brw, name, offset, 1, "\n");
   batch_out(brw, name, offset, 2, "constant red %f\n", cc->constant_r);
   batch_out(brw, name, offset, 3, "constant green %f\n", cc->constant_g);
   batch_out(brw, name, offset, 4, "constant blue %f\n", cc->constant_b);
   batch_out(brw, name, offset, 5, "constant alpha %f\n", cc->constant_a);
d278 1
a278 1
static void dump_blend_state(struct brw_context *brw, uint32_t offset)
d280 3
a282 1
   const char *name = "BLEND";
d284 2
a285 3
   batch_out(brw, name, offset, 0, "\n");
   batch_out(brw, name, offset, 1, "\n");
}
d287 17
a303 5
static void
dump_scissor(struct brw_context *brw, uint32_t offset)
{
   const char *name = "SCISSOR";
   struct gen6_scissor_rect *scissor = brw->batch.bo->virtual + offset;
a304 4
   batch_out(brw, name, offset, 0, "xmin %d, ymin %d\n",
	     scissor->xmin, scissor->ymin);
   batch_out(brw, name, offset, 1, "xmax %d, ymax %d\n",
	     scissor->xmax, scissor->ymax);
d307 1
a307 2
static void
dump_vs_constants(struct brw_context *brw, uint32_t offset, uint32_t size)
d309 3
a311 4
   const char *name = "VS_CONST";
   uint32_t *as_uint = brw->batch.bo->virtual + offset;
   float *as_float = brw->batch.bo->virtual + offset;
   int i;
d313 2
a314 7
   for (i = 0; i < size / 4; i += 4) {
      batch_out(brw, name, offset, i, "%3d: (% f % f % f % f) (0x%08x 0x%08x 0x%08x 0x%08x)\n",
		i / 4,
		as_float[i], as_float[i + 1], as_float[i + 2], as_float[i + 3],
		as_uint[i], as_uint[i + 1], as_uint[i + 2], as_uint[i + 3]);
   }
}
d316 1
a316 7
static void
dump_wm_constants(struct brw_context *brw, uint32_t offset, uint32_t size)
{
   const char *name = "WM_CONST";
   uint32_t *as_uint = brw->batch.bo->virtual + offset;
   float *as_float = brw->batch.bo->virtual + offset;
   int i;
d318 2
a319 7
   for (i = 0; i < size / 4; i += 4) {
      batch_out(brw, name, offset, i, "%3d: (% f % f % f % f) (0x%08x 0x%08x 0x%08x 0x%08x)\n",
		i / 4,
		as_float[i], as_float[i + 1], as_float[i + 2], as_float[i + 3],
		as_uint[i], as_uint[i + 1], as_uint[i + 2], as_uint[i + 3]);
   }
}
d321 2
a322 6
static void dump_binding_table(struct brw_context *brw, uint32_t offset,
			       uint32_t size)
{
   char name[20];
   int i;
   uint32_t *data = brw->batch.bo->virtual + offset;
d324 1
a324 3
   for (i = 0; i < size / 4; i++) {
      if (data[i] == 0)
	 continue;
a325 3
      sprintf(name, "BIND%d", i);
      batch_out(brw, name, offset, i, "surface state address\n");
   }
d328 1
a328 2
static void
dump_prog_cache(struct brw_context *brw)
d330 1
a330 2
   struct brw_cache *cache = &brw->cache;
   unsigned int b, i;
d333 2
a334 1
   drm_intel_bo_map(brw->cache.bo, false);
d336 1
a336 2
   for (b = 0; b < cache->size; b++) {
      struct brw_cache_item *item;
d338 1
a338 32
      for (item = cache->items[b]; item; item = item->next) {
	 const char *name;
	 uint32_t offset = item->offset;

	 data = brw->cache.bo->virtual + item->offset;

	 switch (item->cache_id) {
	 case BRW_VS_PROG:
	    name = "VS kernel";
	    break;
	 case BRW_GS_PROG:
	    name = "GS kernel";
	    break;
	 case BRW_CLIP_PROG:
	    name = "CLIP kernel";
	    break;
	 case BRW_SF_PROG:
	    name = "SF kernel";
	    break;
	 case BRW_WM_PROG:
	    name = "WM kernel";
	    break;
	 default:
	    name = "unknown";
	    break;
	 }

	 for (i = 0; i < item->size / 4 / 4; i++) {
	    fprintf(stderr, "0x%08x: %8s: 0x%08x 0x%08x 0x%08x 0x%08x ",
		    offset + i * 4 * 4,
		    name,
		    data[i * 4], data[i * 4 + 1], data[i * 4 + 2], data[i * 4 + 3]);
d340 12
a351 3
	    brw_disasm(stderr, (void *)(data + i * 4), brw->gen);
	 }
      }
d354 1
a354 1
   drm_intel_bo_unmap(brw->cache.bo);
a356 84
static void
dump_state_batch(struct brw_context *brw)
{
   int i;

   for (i = 0; i < brw->state_batch_count; i++) {
      uint32_t offset = brw->state_batch_list[i].offset;
      uint32_t size = brw->state_batch_list[i].size;

      switch (brw->state_batch_list[i].type) {
      case AUB_TRACE_VS_STATE:
	 dump_vs_state(brw, offset);
	 break;
      case AUB_TRACE_GS_STATE:
	 dump_gs_state(brw, offset);
	 break;
      case AUB_TRACE_CLIP_STATE:
	 dump_clip_state(brw, offset);
	 break;
      case AUB_TRACE_SF_STATE:
	 dump_sf_state(brw, offset);
	 break;
      case AUB_TRACE_WM_STATE:
	 dump_wm_state(brw, offset);
	 break;
      case AUB_TRACE_CLIP_VP_STATE:
	 dump_clip_viewport_state(brw, offset);
	 break;
      case AUB_TRACE_SF_VP_STATE:
	 if (brw->gen >= 7) {
	    dump_sf_clip_viewport_state(brw, offset);
	 } else {
	    dump_sf_viewport_state(brw, offset);
	 }
	 break;
      case AUB_TRACE_CC_VP_STATE:
	 dump_cc_viewport_state(brw, offset);
	 break;
      case AUB_TRACE_DEPTH_STENCIL_STATE:
	 dump_depth_stencil_state(brw, offset);
	 break;
      case AUB_TRACE_CC_STATE:
	 if (brw->gen >= 6)
	    dump_cc_state_gen6(brw, offset);
	 else
	    dump_cc_state_gen4(brw, offset);
	 break;
      case AUB_TRACE_BLEND_STATE:
	 dump_blend_state(brw, offset);
	 break;
      case AUB_TRACE_BINDING_TABLE:
	 dump_binding_table(brw, offset, size);
	 break;
      case AUB_TRACE_SURFACE_STATE:
	 if (brw->gen < 7) {
	    dump_surface_state(brw, offset);
	 } else {
	    dump_gen7_surface_state(brw, offset);
	 }
	 break;
      case AUB_TRACE_SAMPLER_STATE:
	 if (brw->gen < 7) {
	    dump_sampler_state(brw, offset, size);
	 } else {
	    dump_gen7_sampler_state(brw, offset, size);
	 }
	 break;
      case AUB_TRACE_SAMPLER_DEFAULT_COLOR:
	 dump_sdc(brw, offset);
	 break;
      case AUB_TRACE_SCISSOR_STATE:
	 dump_scissor(brw, offset);
	 break;
      case AUB_TRACE_VS_CONSTANTS:
	 dump_vs_constants(brw, offset, size);
	 break;
      case AUB_TRACE_WM_CONSTANTS:
	 dump_wm_constants(brw, offset, size);
	 break;
      default:
	 break;
      }
   }
}
d368 1
a368 1
void brw_debug_batch(struct brw_context *brw)
d370 1
a370 3
   drm_intel_bo_map(brw->batch.bo, false);
   dump_state_batch(brw);
   drm_intel_bo_unmap(brw->batch.bo);
d372 29
a400 2
   if (0)
      dump_prog_cache(brw);
@


1.1.1.3
log
@Import Mesa 10.2.3
@
text
@d200 1
a200 1
   batch_out(brw, name, offset, 0, "%s %s %s\n",
d202 1
a202 2
             get_965_surface_format(GET_FIELD(surf[0], BRW_SURFACE_FORMAT)),
             (surf[0] & GEN7_SURFACE_IS_ARRAY) ? "array" : "");
d204 1
a204 1
   batch_out(brw, name, offset, 2, "%dx%d size, %d mips, %d slices\n",
d207 1
a207 2
             surf[5] & INTEL_MASK(3, 0),
             GET_FIELD(surf[3], BRW_SURFACE_DEPTH) + 1);
d211 1
a211 4
   batch_out(brw, name, offset, 4, "min array element %d, array extent %d\n",
             GET_FIELD(surf[4], GEN7_SURFACE_MIN_ARRAY_ELEMENT),
             GET_FIELD(surf[4], GEN7_SURFACE_RENDER_TARGET_VIEW_EXTENT) + 1);
   batch_out(brw, name, offset, 5, "mip base %d\n",
d213 1
a213 1
   batch_out(brw, name, offset, 6, "x,y offset: %d,%d\n",
a215 1
   batch_out(brw, name, offset, 7, "\n");
d501 2
a502 2
	 case BRW_FF_GS_PROG:
	    name = "Fixed-function GS kernel";
a503 3
         case BRW_GS_PROG:
            name = "GS kernel";
            break;
@


1.1.1.4
log
@Import Mesa 10.4.3
@
text
@a32 1
#include "brw_eu.h"
d245 6
a250 5
      float *sdc = brw->batch.bo->virtual + offset;
      batch_out(brw, name, offset, 0, "r %f\n", sdc[0]);
      batch_out(brw, name, offset, 1, "g %f\n", sdc[1]);
      batch_out(brw, name, offset, 2, "b %f\n", sdc[2]);
      batch_out(brw, name, offset, 3, "a %f\n", sdc[3]);
d258 1
a258 1
   uint32_t *samp = brw->batch.bo->virtual + offset;
d260 3
a262 1
   for (i = 0; i < size / 16; i++) {
d271 2
a272 2
      samp += 4;
      offset += 4 * sizeof(uint32_t);
d276 23
d489 2
a490 1
   unsigned int b;
d499 3
d527 8
a534 3
         fprintf(stderr, "%s:\n", name);
         brw_disassemble(brw, brw->cache.bo->virtual, item->offset, item->size,
                         stderr);
d602 5
a606 1
         dump_sampler_state(brw, offset, size);
@


1.1.1.5
log
@Import Mesa 10.2.9
@
text
@d33 1
d246 5
a250 6
      struct brw_sampler_default_color *sdc = (brw->batch.bo->virtual +
					       offset);
      batch_out(brw, name, offset, 0, "r %f\n", sdc->color[0]);
      batch_out(brw, name, offset, 1, "g %f\n", sdc->color[1]);
      batch_out(brw, name, offset, 2, "b %f\n", sdc->color[2]);
      batch_out(brw, name, offset, 3, "a %f\n", sdc->color[3]);
d258 1
a258 1
   struct brw_sampler_state *samp = brw->batch.bo->virtual + offset;
d260 1
a260 3
   assert(brw->gen < 7);

   for (i = 0; i < size / sizeof(*samp); i++) {
d269 2
a270 2
      samp++;
      offset += sizeof(*samp);
a273 23
static void dump_gen7_sampler_state(struct brw_context *brw,
				    uint32_t offset, uint32_t size)
{
   struct gen7_sampler_state *samp = brw->batch.bo->virtual + offset;
   int i;

   assert(brw->gen >= 7);

   for (i = 0; i < size / sizeof(*samp); i++) {
      char name[20];

      sprintf(name, "WM SAMP%d", i);
      batch_out(brw, name, offset, 0, "filtering\n");
      batch_out(brw, name, offset, 1, "wrapping, lod\n");
      batch_out(brw, name, offset, 2, "default color pointer\n");
      batch_out(brw, name, offset, 3, "chroma key, aniso\n");

      samp++;
      offset += sizeof(*samp);
   }
}


d464 1
a464 2
   unsigned int b, i;
   uint32_t *data;
a472 3
	 uint32_t offset = item->offset;

	 data = brw->cache.bo->virtual + item->offset;
d498 3
a500 8
	 for (i = 0; i < item->size / 4 / 4; i++) {
	    fprintf(stderr, "0x%08x: %8s: 0x%08x 0x%08x 0x%08x 0x%08x ",
		    offset + i * 4 * 4,
		    name,
		    data[i * 4], data[i * 4 + 1], data[i * 4 + 2], data[i * 4 + 3]);

	    brw_disasm(stderr, (void *)(data + i * 4), brw->gen);
	 }
d568 1
a568 5
	 if (brw->gen < 7) {
	    dump_sampler_state(brw, offset, size);
	 } else {
	    dump_gen7_sampler_state(brw, offset, size);
	 }
@


