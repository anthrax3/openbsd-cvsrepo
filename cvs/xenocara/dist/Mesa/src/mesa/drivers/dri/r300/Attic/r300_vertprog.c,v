head	1.5;
access;
symbols
	OPENBSD_5_4:1.4.0.8
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	v7_10_3:1.1.1.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v7_0_1:1.1.1.1
	mesa:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.09.05.14.05.04;	author jsg;	state dead;
branches;
next	1.4;

1.4
date	2011.10.23.13.37.40;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.22.20.06.23;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.14.58.18;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.17.29.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.17.29.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.10.23.13.29.41;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Merge Mesa 9.2.0
@
text
@/**************************************************************************

Copyright (C) 2005  Aapo Tahkola <aet@@rasterburn.org>
Copyright (C) 2008  Oliver McFadden <z3ro.geek@@gmail.com>

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
on the rights to use, copy, modify, merge, publish, distribute, sub
license, and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/* Radeon R5xx Acceleration, Revision 1.2 */

#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"
#include "program/program.h"
#include "program/programopt.h"
#include "program/prog_instruction.h"
#include "program/prog_parameter.h"
#include "program/prog_print.h"
#include "program/prog_statevars.h"
#include "tnl/tnl.h"

#include "compiler/radeon_compiler.h"
#include "radeon_mesa_to_rc.h"
#include "r300_context.h"
#include "r300_fragprog_common.h"
#include "r300_state.h"

/**
 * Write parameter array for the given vertex program into dst.
 * Return the total number of components written.
 */
static int r300VertexProgUpdateParams(struct gl_context * ctx, struct r300_vertex_program *vp, float *dst)
{
	int i;

	if (vp->Base->IsNVProgram) {
		_mesa_load_tracked_matrices(ctx);
	} else {
		if (vp->Base->Base.Parameters) {
			_mesa_load_state_parameters(ctx, vp->Base->Base.Parameters);
		}
	}

	for(i = 0; i < vp->code.constants.Count; ++i) {
		const float * src = 0;
		const struct rc_constant * constant = &vp->code.constants.Constants[i];

		switch(constant->Type) {
		case RC_CONSTANT_EXTERNAL:
			if (vp->Base->IsNVProgram) {
				src = ctx->VertexProgram.Parameters[constant->u.External];
			} else {
				src = vp->Base->Base.Parameters->ParameterValues[constant->u.External];
			}
			break;

		case RC_CONSTANT_IMMEDIATE:
			src = constant->u.Immediate;
			break;
		}

		assert(src);
		dst[4*i] = src[0];
		dst[4*i + 1] = src[1];
		dst[4*i + 2] = src[2];
		dst[4*i + 3] = src[3];
	}

	return 4 * vp->code.constants.Count;
}

static GLbitfield compute_required_outputs(struct gl_vertex_program * vp, GLbitfield fpreads)
{
	GLbitfield outputs = 0;
	int i;

#define ADD_OUTPUT(fp_attr, vp_result) \
	do { \
		if (fpreads & (1 << (fp_attr))) \
			outputs |= (1 << (vp_result)); \
	} while (0)

	ADD_OUTPUT(FRAG_ATTRIB_COL0, VERT_RESULT_COL0);
	ADD_OUTPUT(FRAG_ATTRIB_COL1, VERT_RESULT_COL1);

	for (i = 0; i <= 7; ++i) {
		ADD_OUTPUT(FRAG_ATTRIB_TEX0 + i, VERT_RESULT_TEX0 + i);
	}

#undef ADD_OUTPUT

	if ((fpreads & (1 << FRAG_ATTRIB_COL0)) &&
	    (vp->Base.OutputsWritten & (1 << VERT_RESULT_BFC0)))
		outputs |= 1 << VERT_RESULT_BFC0;
	if ((fpreads & (1 << FRAG_ATTRIB_COL1)) &&
	    (vp->Base.OutputsWritten & (1 << VERT_RESULT_BFC1)))
		outputs |= 1 << VERT_RESULT_BFC1;

	outputs |= 1 << VERT_RESULT_HPOS;
	if (vp->Base.OutputsWritten & (1 << VERT_RESULT_PSIZ))
		outputs |= 1 << VERT_RESULT_PSIZ;

	return outputs;
}


static void t_inputs_outputs(struct r300_vertex_program_compiler * c)
{
	int i;
	int cur_reg;
	GLuint OutputsWritten, InputsRead;

	OutputsWritten = c->Base.Program.OutputsWritten;
	InputsRead = c->Base.Program.InputsRead;

	cur_reg = -1;
	for (i = 0; i < VERT_ATTRIB_MAX; i++) {
		if (InputsRead & (1 << i))
			c->code->inputs[i] = ++cur_reg;
		else
			c->code->inputs[i] = -1;
	}

	cur_reg = 0;
	for (i = 0; i < VERT_RESULT_MAX; i++)
		c->code->outputs[i] = -1;

	assert(OutputsWritten & (1 << VERT_RESULT_HPOS));

	if (OutputsWritten & (1 << VERT_RESULT_HPOS)) {
		c->code->outputs[VERT_RESULT_HPOS] = cur_reg++;
	}

	if (OutputsWritten & (1 << VERT_RESULT_PSIZ)) {
		c->code->outputs[VERT_RESULT_PSIZ] = cur_reg++;
	}

	/* If we're writing back facing colors we need to send
	 * four colors to make front/back face colors selection work.
	 * If the vertex program doesn't write all 4 colors, lets
	 * pretend it does by skipping output index reg so the colors
	 * get written into appropriate output vectors.
	 */
	if (OutputsWritten & (1 << VERT_RESULT_COL0)) {
		c->code->outputs[VERT_RESULT_COL0] = cur_reg++;
	} else if (OutputsWritten & (1 << VERT_RESULT_BFC0) ||
		OutputsWritten & (1 << VERT_RESULT_BFC1)) {
		cur_reg++;
	}

	if (OutputsWritten & (1 << VERT_RESULT_COL1)) {
		c->code->outputs[VERT_RESULT_COL1] = cur_reg++;
	} else if (OutputsWritten & (1 << VERT_RESULT_BFC0) ||
		OutputsWritten & (1 << VERT_RESULT_BFC1)) {
		cur_reg++;
	}

	if (OutputsWritten & (1 << VERT_RESULT_BFC0)) {
		c->code->outputs[VERT_RESULT_BFC0] = cur_reg++;
	} else if (OutputsWritten & (1 << VERT_RESULT_BFC1)) {
		cur_reg++;
	}

	if (OutputsWritten & (1 << VERT_RESULT_BFC1)) {
		c->code->outputs[VERT_RESULT_BFC1] = cur_reg++;
	} else if (OutputsWritten & (1 << VERT_RESULT_BFC0)) {
		cur_reg++;
	}

	for (i = VERT_RESULT_TEX0; i <= VERT_RESULT_TEX7; i++) {
		if (OutputsWritten & (1 << i)) {
			c->code->outputs[i] = cur_reg++;
		}
	}

	if (OutputsWritten & (1 << VERT_RESULT_FOGC)) {
		c->code->outputs[VERT_RESULT_FOGC] = cur_reg++;
	}
}

/**
 * The NV_vertex_program spec mandates that all registers be
 * initialized to zero. We do this here unconditionally.
 *
 * \note We rely on dead-code elimination in the compiler.
 */
static void initialize_NV_registers(struct radeon_compiler * compiler)
{
	unsigned int reg;
	struct rc_instruction * inst;

	for(reg = 0; reg < 12; ++reg) {
		inst = rc_insert_new_instruction(compiler, &compiler->Program.Instructions);
		inst->U.I.Opcode = RC_OPCODE_MOV;
		inst->U.I.DstReg.File = RC_FILE_TEMPORARY;
		inst->U.I.DstReg.Index = reg;
		inst->U.I.SrcReg[0].File = RC_FILE_NONE;
		inst->U.I.SrcReg[0].Swizzle = RC_SWIZZLE_0000;
	}

	inst = rc_insert_new_instruction(compiler, &compiler->Program.Instructions);
	inst->U.I.Opcode = RC_OPCODE_ARL;
	inst->U.I.DstReg.File = RC_FILE_ADDRESS;
	inst->U.I.DstReg.Index = 0;
	inst->U.I.DstReg.WriteMask = WRITEMASK_X;
	inst->U.I.SrcReg[0].File = RC_FILE_NONE;
	inst->U.I.SrcReg[0].Swizzle = RC_SWIZZLE_0000;
}

static struct r300_vertex_program *build_program(struct gl_context *ctx,
						 struct r300_vertex_program_key *wanted_key,
						 const struct gl_vertex_program *mesa_vp)
{
	struct r300_vertex_program *vp;
	struct r300_vertex_program_compiler compiler;

	vp = calloc(1, sizeof(*vp));
	vp->Base = _mesa_clone_vertex_program(ctx, mesa_vp);
	memcpy(&vp->key, wanted_key, sizeof(vp->key));

        memset(&compiler, 0, sizeof(compiler));
	rc_init(&compiler.Base);
	compiler.Base.Debug = (RADEON_DEBUG & RADEON_VERTS) ? GL_TRUE : GL_FALSE;

	compiler.code = &vp->code;
	compiler.RequiredOutputs = compute_required_outputs(vp->Base, vp->key.FpReads);
	compiler.SetHwInputOutput = &t_inputs_outputs;
	compiler.Base.is_r500 = R300_CONTEXT(ctx)->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515;
	compiler.Base.disable_optimizations = 0;
	compiler.Base.has_half_swizzles = 0;
	compiler.Base.max_temp_regs = 32;
	compiler.Base.max_constants = 256;
	compiler.Base.max_alu_insts = compiler.Base.is_r500 ? 1024 : 256;

	if (compiler.Base.Debug) {
		fprintf(stderr, "Initial vertex program:\n");
		_mesa_print_program(&vp->Base->Base);
		fflush(stderr);
	}

	if (mesa_vp->IsPositionInvariant) {
		_mesa_insert_mvp_code(ctx, vp->Base);
	}

	radeon_mesa_to_rc_program(&compiler.Base, &vp->Base->Base);

	if (mesa_vp->IsNVProgram)
		initialize_NV_registers(&compiler.Base);

	rc_move_output(&compiler.Base, VERT_RESULT_PSIZ, VERT_RESULT_PSIZ, WRITEMASK_X);

	if (vp->key.WPosAttr != FRAG_ATTRIB_MAX) {
		unsigned int vp_wpos_attr = vp->key.WPosAttr - FRAG_ATTRIB_TEX0 + VERT_RESULT_TEX0;

		/* Set empty writemask for instructions writing to vp_wpos_attr
		 * before moving the wpos attr there.
		 * Such instructions will be removed by DCE.
		 */
		rc_move_output(&compiler.Base, vp_wpos_attr, vp->key.WPosAttr, 0);
		rc_copy_output(&compiler.Base, VERT_RESULT_HPOS, vp_wpos_attr);
	}

	if (vp->key.FogAttr != FRAG_ATTRIB_MAX) {
		unsigned int vp_fog_attr = vp->key.FogAttr - FRAG_ATTRIB_TEX0 + VERT_RESULT_TEX0;

		/* Set empty writemask for instructions writing to vp_fog_attr
		 * before moving the fog attr there.
		 * Such instructions will be removed by DCE.
		 */
		rc_move_output(&compiler.Base, vp_fog_attr, vp->key.FogAttr, 0);
		rc_move_output(&compiler.Base, VERT_RESULT_FOGC, vp_fog_attr, WRITEMASK_X);
	}

	r3xx_compile_vertex_program(&compiler);

	if (vp->code.constants.Count > ctx->Const.VertexProgram.MaxParameters) {
		rc_error(&compiler.Base, "Program exceeds constant buffer size limit\n");
	}

	vp->error = compiler.Base.Error;

	vp->Base->Base.InputsRead = vp->code.InputsRead;
	vp->Base->Base.OutputsWritten = vp->code.OutputsWritten;

	rc_destroy(&compiler.Base);

	return vp;
}

struct r300_vertex_program * r300SelectAndTranslateVertexShader(struct gl_context *ctx)
{
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	struct r300_vertex_program_key wanted_key = { 0 };
	struct r300_vertex_program_cont *vpc;
	struct r300_vertex_program *vp;

	vpc = (struct r300_vertex_program_cont *)ctx->VertexProgram._Current;

	if (!r300->selected_fp) {
		/* This can happen when GetProgramiv is called to check
		 * whether the program runs natively.
		 *
		 * To be honest, this is not a very good solution,
		 * but solving the problem of reporting good values
		 * for those queries is tough anyway considering that
		 * we recompile vertex programs based on the precise
		 * fragment program that is in use.
		 */
		r300SelectAndTranslateFragmentShader(ctx);
	}

	assert(r300->selected_fp);
	wanted_key.FpReads = r300->selected_fp->InputsRead;
	wanted_key.FogAttr = r300->selected_fp->fog_attr;
	wanted_key.WPosAttr = r300->selected_fp->wpos_attr;

	for (vp = vpc->progs; vp; vp = vp->next) {
		if (memcmp(&vp->key, &wanted_key, sizeof(wanted_key)) == 0) {
			return r300->selected_vp = vp;
		}
	}

	vp = build_program(ctx, &wanted_key, &vpc->mesa_program);
	vp->next = vpc->progs;
	vpc->progs = vp;

	return r300->selected_vp = vp;
}

#define bump_vpu_count(ptr, new_count)   do { \
		drm_r300_cmd_header_t* _p=((drm_r300_cmd_header_t*)(ptr)); \
		int _nc=(new_count)/4; \
		if(_nc>_p->vpu.count)_p->vpu.count=_nc; \
	} while(0)

static void r300EmitVertexProgram(r300ContextPtr r300, int dest, struct r300_vertex_program_code *code)
{
	int i;

	assert((code->length > 0) && (code->length % 4 == 0));

	switch ((dest >> 8) & 0xf) {
		case 0:
			R300_STATECHANGE(r300, vpi);
			for (i = 0; i < code->length; i++)
				r300->hw.vpi.cmd[R300_VPI_INSTR_0 + i + 4 * (dest & 0xff)] = (code->body.d[i]);
			bump_vpu_count(r300->hw.vpi.cmd, code->length + 4 * (dest & 0xff));
			break;
		case 2:
			R300_STATECHANGE(r300, vpp);
			for (i = 0; i < code->length; i++)
				r300->hw.vpp.cmd[R300_VPP_PARAM_0 + i + 4 * (dest & 0xff)] = (code->body.d[i]);
			bump_vpu_count(r300->hw.vpp.cmd, code->length + 4 * (dest & 0xff));
			break;
		case 4:
			R300_STATECHANGE(r300, vps);
			for (i = 0; i < code->length; i++)
				r300->hw.vps.cmd[1 + i + 4 * (dest & 0xff)] = (code->body.d[i]);
			bump_vpu_count(r300->hw.vps.cmd, code->length + 4 * (dest & 0xff));
			break;
		default:
			fprintf(stderr, "%s:%s don't know how to handle dest %04x\n", __FILE__, __FUNCTION__, dest);
			exit(-1);
	}
}

void r300SetupVertexProgram(r300ContextPtr rmesa)
{
	struct gl_context *ctx = rmesa->radeon.glCtx;
	struct r300_vertex_program *prog = rmesa->selected_vp;
	int inst_count = 0;
	int param_count = 0;

	/* Reset state, in case we don't use something */
	((drm_r300_cmd_header_t *) rmesa->hw.vpp.cmd)->vpu.count = 0;
	((drm_r300_cmd_header_t *) rmesa->hw.vpi.cmd)->vpu.count = 0;
	((drm_r300_cmd_header_t *) rmesa->hw.vps.cmd)->vpu.count = 0;

	R300_STATECHANGE(rmesa, vap_cntl);
	R300_STATECHANGE(rmesa, vpp);
	param_count = r300VertexProgUpdateParams(ctx, prog, (float *)&rmesa->hw.vpp.cmd[R300_VPP_PARAM_0]);
	if (!rmesa->radeon.radeonScreen->kernel_mm && param_count > 255 * 4) {
		WARN_ONCE("Too many VP params, expect rendering errors\n");
	}
	/* Prevent the overflow (vpu.count is u8) */
	bump_vpu_count(rmesa->hw.vpp.cmd, MIN2(255 * 4, param_count));
	param_count /= 4;

	r300EmitVertexProgram(rmesa, R300_PVS_CODE_START, &(prog->code));
	inst_count = (prog->code.length / 4) - 1;

	r300VapCntl(rmesa, _mesa_bitcount(prog->code.InputsRead),
				 _mesa_bitcount(prog->code.OutputsWritten), prog->code.num_temporaries);

	R300_STATECHANGE(rmesa, pvs);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_1] = (0 << R300_PVS_FIRST_INST_SHIFT) | (inst_count << R300_PVS_XYZW_VALID_INST_SHIFT) |
				(inst_count << R300_PVS_LAST_INST_SHIFT);

	rmesa->hw.pvs.cmd[R300_PVS_CNTL_2] = (0 << R300_PVS_CONST_BASE_OFFSET_SHIFT) | ((param_count - 1) << R300_PVS_MAX_CONST_ADDR_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_3] = (inst_count << R300_PVS_LAST_VTX_SRC_INST_SHIFT);
}
@


1.4
log
@Merge Mesa 7.10.3
@
text
@@


1.3
log
@Update to Mesa 7.8.1. Tested on a bulk ports build by naddy@@, ok oga@@.
@
text
@d34 6
a39 6
#include "shader/program.h"
#include "shader/programopt.h"
#include "shader/prog_instruction.h"
#include "shader/prog_parameter.h"
#include "shader/prog_print.h"
#include "shader/prog_statevars.h"
d52 1
a52 1
static int r300VertexProgUpdateParams(GLcontext * ctx, struct r300_vertex_program *vp, float *dst)
d230 1
a230 1
static struct r300_vertex_program *build_program(GLcontext *ctx,
d241 1
d248 6
d310 1
a310 1
struct r300_vertex_program * r300SelectAndTranslateVertexShader(GLcontext *ctx)
d389 1
a389 1
	GLcontext *ctx = rmesa->radeon.glCtx;
@


1.2
log
@Mesa 7.2, Tested by ckuethe@@, naddy@@, oga@@, and others.
@
text
@d35 1
d38 1
d42 2
d45 2
d48 3
a50 10
/* TODO: Get rid of t_src_class call */
#define CMP_SRCS(a, b) ((a.RelAddr != b.RelAddr) || (a.Index != b.Index && \
		       ((t_src_class(a.File) == PVS_SRC_REG_CONSTANT && \
			 t_src_class(b.File) == PVS_SRC_REG_CONSTANT) || \
			(t_src_class(a.File) == PVS_SRC_REG_INPUT && \
			 t_src_class(b.File) == PVS_SRC_REG_INPUT)))) \

/*
 * Take an already-setup and valid source then swizzle it appropriately to
 * obtain a constant ZERO or ONE source.
d52 1
a52 21
#define __CONST(x, y)	\
	(PVS_SRC_OPERAND(t_src_index(vp, &src[x]),	\
			   t_swizzle(y),	\
			   t_swizzle(y),	\
			   t_swizzle(y),	\
			   t_swizzle(y),	\
			   t_src_class(src[x].File), \
			   VSF_FLAG_NONE) | (src[x].RelAddr << 4))

#define FREE_TEMPS() \
	do { \
		int u_temp_used = (VSF_MAX_FRAGMENT_TEMPS - 1) - u_temp_i; \
		if((vp->num_temporaries + u_temp_used) > VSF_MAX_FRAGMENT_TEMPS) { \
			WARN_ONCE("Ran out of temps, num temps %d, us %d\n", vp->num_temporaries, u_temp_used); \
			vp->native = GL_FALSE; \
		} \
		u_temp_i=VSF_MAX_FRAGMENT_TEMPS-1; \
	} while (0)

int r300VertexProgUpdateParams(GLcontext * ctx,
			       struct r300_vertex_program_cont *vp, float *dst)
d54 1
a54 4
	int pi;
	struct gl_vertex_program *mesa_vp = &vp->mesa_program;
	float *dst_o = dst;
	struct gl_program_parameter_list *paramList;
d56 1
a56 1
	if (mesa_vp->IsNVProgram) {
d58 3
a60 6

		for (pi = 0; pi < MAX_NV_VERTEX_PROGRAM_PARAMS; pi++) {
			*dst++ = ctx->VertexProgram.Parameters[pi][0];
			*dst++ = ctx->VertexProgram.Parameters[pi][1];
			*dst++ = ctx->VertexProgram.Parameters[pi][2];
			*dst++ = ctx->VertexProgram.Parameters[pi][3];
a61 1
		return dst - dst_o;
d64 12
a75 2
	assert(mesa_vp->Base.Parameters);
	_mesa_load_state_parameters(ctx, mesa_vp->Base.Parameters);
d77 2
a78 17
	if (mesa_vp->Base.Parameters->NumParameters * 4 >
	    VSF_MAX_FRAGMENT_LENGTH) {
		fprintf(stderr, "%s:Params exhausted\n", __FUNCTION__);
		_mesa_exit(-1);
	}

	paramList = mesa_vp->Base.Parameters;
	for (pi = 0; pi < paramList->NumParameters; pi++) {
		switch (paramList->Parameters[pi].Type) {
		case PROGRAM_STATE_VAR:
		case PROGRAM_NAMED_PARAM:
			//fprintf(stderr, "%s", vp->Parameters->Parameters[pi].Name);
		case PROGRAM_CONSTANT:
			*dst++ = paramList->ParameterValues[pi][0];
			*dst++ = paramList->ParameterValues[pi][1];
			*dst++ = paramList->ParameterValues[pi][2];
			*dst++ = paramList->ParameterValues[pi][3];
a79 3
		default:
			_mesa_problem(NULL, "Bad param type in %s",
				      __FUNCTION__);
d82 5
d89 1
a89 73
	return dst - dst_o;
}

static unsigned long t_dst_mask(GLuint mask)
{
	/* WRITEMASK_* is equivalent to VSF_FLAG_* */
	return mask & VSF_FLAG_ALL;
}

static unsigned long t_dst_class(enum register_file file)
{

	switch (file) {
	case PROGRAM_TEMPORARY:
		return PVS_DST_REG_TEMPORARY;
	case PROGRAM_OUTPUT:
		return PVS_DST_REG_OUT;
	case PROGRAM_ADDRESS:
		return PVS_DST_REG_A0;
		/*
		   case PROGRAM_INPUT:
		   case PROGRAM_LOCAL_PARAM:
		   case PROGRAM_ENV_PARAM:
		   case PROGRAM_NAMED_PARAM:
		   case PROGRAM_STATE_VAR:
		   case PROGRAM_WRITE_ONLY:
		   case PROGRAM_ADDRESS:
		 */
	default:
		fprintf(stderr, "problem in %s", __FUNCTION__);
		_mesa_exit(-1);
		return -1;
	}
}

static unsigned long t_dst_index(struct r300_vertex_program *vp,
				 struct prog_dst_register *dst)
{
	if (dst->File == PROGRAM_OUTPUT)
		return vp->outputs[dst->Index];

	return dst->Index;
}

static unsigned long t_src_class(enum register_file file)
{
	switch (file) {
	case PROGRAM_TEMPORARY:
		return PVS_SRC_REG_TEMPORARY;
	case PROGRAM_INPUT:
		return PVS_SRC_REG_INPUT;
	case PROGRAM_LOCAL_PARAM:
	case PROGRAM_ENV_PARAM:
	case PROGRAM_NAMED_PARAM:
	case PROGRAM_CONSTANT:
	case PROGRAM_STATE_VAR:
		return PVS_SRC_REG_CONSTANT;
		/*
		   case PROGRAM_OUTPUT:
		   case PROGRAM_WRITE_ONLY:
		   case PROGRAM_ADDRESS:
		 */
	default:
		fprintf(stderr, "problem in %s", __FUNCTION__);
		_mesa_exit(-1);
		return -1;
	}
}

static INLINE unsigned long t_swizzle(GLubyte swizzle)
{
/* this is in fact a NOP as the Mesa SWIZZLE_* are all identical to VSF_IN_COMPONENT_* */
	return swizzle;
d92 1
a92 2
#if 0
static void vp_dump_inputs(struct r300_vertex_program *vp, char *caller)
d94 1
d97 5
a101 5
	if (vp == NULL) {
		fprintf(stderr, "vp null in call to %s from %s\n", __FUNCTION__,
			caller);
		return;
	}
d103 2
a104 4
	fprintf(stderr, "%s:<", caller);
	for (i = 0; i < VERT_ATTRIB_MAX; i++)
		fprintf(stderr, "%d ", vp->inputs[i]);
	fprintf(stderr, ">\n");
d106 2
a107 29
}
#endif

static unsigned long t_src_index(struct r300_vertex_program *vp,
				 struct prog_src_register *src)
{
	int i;
	int max_reg = -1;

	if (src->File == PROGRAM_INPUT) {
		if (vp->inputs[src->Index] != -1)
			return vp->inputs[src->Index];

		for (i = 0; i < VERT_ATTRIB_MAX; i++)
			if (vp->inputs[i] > max_reg)
				max_reg = vp->inputs[i];

		vp->inputs[src->Index] = max_reg + 1;

		//vp_dump_inputs(vp, __FUNCTION__);

		return vp->inputs[src->Index];
	} else {
		if (src->Index < 0) {
			fprintf(stderr,
				"negative offsets for indirect addressing do not work.\n");
			return 0;
		}
		return src->Index;
a108 483
}

/* these two functions should probably be merged... */

static unsigned long t_src(struct r300_vertex_program *vp,
			   struct prog_src_register *src)
{
	/* src->NegateBase uses the NEGATE_ flags from program_instruction.h,
	 * which equal our VSF_FLAGS_ values, so it's safe to just pass it here.
	 */
	return PVS_SRC_OPERAND(t_src_index(vp, src),
			       t_swizzle(GET_SWZ(src->Swizzle, 0)),
			       t_swizzle(GET_SWZ(src->Swizzle, 1)),
			       t_swizzle(GET_SWZ(src->Swizzle, 2)),
			       t_swizzle(GET_SWZ(src->Swizzle, 3)),
			       t_src_class(src->File),
			       src->NegateBase) | (src->RelAddr << 4);
}

static unsigned long t_src_scalar(struct r300_vertex_program *vp,
				  struct prog_src_register *src)
{
	/* src->NegateBase uses the NEGATE_ flags from program_instruction.h,
	 * which equal our VSF_FLAGS_ values, so it's safe to just pass it here.
	 */
	return PVS_SRC_OPERAND(t_src_index(vp, src),
			       t_swizzle(GET_SWZ(src->Swizzle, 0)),
			       t_swizzle(GET_SWZ(src->Swizzle, 0)),
			       t_swizzle(GET_SWZ(src->Swizzle, 0)),
			       t_swizzle(GET_SWZ(src->Swizzle, 0)),
			       t_src_class(src->File),
			       src->
			       NegateBase ? VSF_FLAG_ALL : VSF_FLAG_NONE) |
	    (src->RelAddr << 4);
}

static GLboolean valid_dst(struct r300_vertex_program *vp,
			   struct prog_dst_register *dst)
{
	if (dst->File == PROGRAM_OUTPUT && vp->outputs[dst->Index] == -1) {
		return GL_FALSE;
	} else if (dst->File == PROGRAM_ADDRESS) {
		assert(dst->Index == 0);
	}

	return GL_TRUE;
}

static GLuint *r300TranslateOpcodeABS(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	//MAX RESULT 1.X Y Z W PARAM 0{} {X Y Z W} PARAM 0{X Y Z W } {X Y Z W} neg Xneg Yneg Zneg W

	inst[0] = PVS_OP_DST_OPERAND(VE_MAXIMUM,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = PVS_SRC_OPERAND(t_src_index(vp, &src[0]),
				  t_swizzle(GET_SWZ(src[0].Swizzle, 0)),
				  t_swizzle(GET_SWZ(src[0].Swizzle, 1)),
				  t_swizzle(GET_SWZ(src[0].Swizzle, 2)),
				  t_swizzle(GET_SWZ(src[0].Swizzle, 3)),
				  t_src_class(src[0].File),
				  (!src[0].
				   NegateBase) ? VSF_FLAG_ALL : VSF_FLAG_NONE) |
	    (src[0].RelAddr << 4);
	inst[3] = 0;

	return inst;
}

static GLuint *r300TranslateOpcodeADD(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(VE_ADD,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = t_src(vp, &src[1]);
	inst[3] = __CONST(1, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeARL(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(VE_FLT2FIX_DX,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = __CONST(0, SWIZZLE_ZERO);
	inst[3] = __CONST(0, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeDP3(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	//DOT RESULT 1.X Y Z W PARAM 0{} {X Y Z ZERO} PARAM 0{} {X Y Z ZERO}

	inst[0] = PVS_OP_DST_OPERAND(VE_DOT_PRODUCT,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = PVS_SRC_OPERAND(t_src_index(vp, &src[0]),
				  t_swizzle(GET_SWZ(src[0].Swizzle, 0)),
				  t_swizzle(GET_SWZ(src[0].Swizzle, 1)),
				  t_swizzle(GET_SWZ(src[0].Swizzle, 2)),
				  SWIZZLE_ZERO,
				  t_src_class(src[0].File),
				  src[0].
				  NegateBase ? VSF_FLAG_XYZ : VSF_FLAG_NONE) |
	    (src[0].RelAddr << 4);
	inst[2] =
	    PVS_SRC_OPERAND(t_src_index(vp, &src[1]),
			    t_swizzle(GET_SWZ(src[1].Swizzle, 0)),
			    t_swizzle(GET_SWZ(src[1].Swizzle, 1)),
			    t_swizzle(GET_SWZ(src[1].Swizzle, 2)), SWIZZLE_ZERO,
			    t_src_class(src[1].File),
			    src[1].
			    NegateBase ? VSF_FLAG_XYZ : VSF_FLAG_NONE) |
	    (src[1].RelAddr << 4);
	inst[3] = __CONST(1, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeDP4(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(VE_DOT_PRODUCT,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = t_src(vp, &src[1]);
	inst[3] = __CONST(1, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeDPH(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	//DOT RESULT 1.X Y Z W PARAM 0{} {X Y Z ONE} PARAM 0{} {X Y Z W}
	inst[0] = PVS_OP_DST_OPERAND(VE_DOT_PRODUCT,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = PVS_SRC_OPERAND(t_src_index(vp, &src[0]),
				  t_swizzle(GET_SWZ(src[0].Swizzle, 0)),
				  t_swizzle(GET_SWZ(src[0].Swizzle, 1)),
				  t_swizzle(GET_SWZ(src[0].Swizzle, 2)),
				  PVS_SRC_SELECT_FORCE_1,
				  t_src_class(src[0].File),
				  src[0].
				  NegateBase ? VSF_FLAG_XYZ : VSF_FLAG_NONE) |
	    (src[0].RelAddr << 4);
	inst[2] = t_src(vp, &src[1]);
	inst[3] = __CONST(1, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeDST(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(VE_DISTANCE_VECTOR,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = t_src(vp, &src[1]);
	inst[3] = __CONST(1, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeEX2(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(ME_EXP_BASE2_FULL_DX,
				     GL_TRUE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src_scalar(vp, &src[0]);
	inst[2] = __CONST(0, SWIZZLE_ZERO);
	inst[3] = __CONST(0, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeEXP(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(ME_EXP_BASE2_DX,
				     GL_TRUE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src_scalar(vp, &src[0]);
	inst[2] = __CONST(0, SWIZZLE_ZERO);
	inst[3] = __CONST(0, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeFLR(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3],
				      int *u_temp_i)
{
	/* FRC TMP 0.X Y Z W PARAM 0{} {X Y Z W}
	   ADD RESULT 1.X Y Z W PARAM 0{} {X Y Z W} TMP 0{X Y Z W } {X Y Z W} neg Xneg Yneg Zneg W */

	inst[0] = PVS_OP_DST_OPERAND(VE_FRACTION,
				     GL_FALSE,
				     GL_FALSE,
				     *u_temp_i,
				     t_dst_mask(vpi->DstReg.WriteMask),
				     PVS_DST_REG_TEMPORARY);
	inst[1] = t_src(vp, &src[0]);
	inst[2] = __CONST(0, SWIZZLE_ZERO);
	inst[3] = __CONST(0, SWIZZLE_ZERO);
	inst += 4;

	inst[0] = PVS_OP_DST_OPERAND(VE_ADD,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = PVS_SRC_OPERAND(*u_temp_i,
				  PVS_SRC_SELECT_X,
				  PVS_SRC_SELECT_Y,
				  PVS_SRC_SELECT_Z,
				  PVS_SRC_SELECT_W, PVS_SRC_REG_TEMPORARY,
				  /* Not 100% sure about this */
				  (!src[0].
				   NegateBase) ? VSF_FLAG_ALL : VSF_FLAG_NONE
				  /*VSF_FLAG_ALL */ );
	inst[3] = __CONST(0, SWIZZLE_ZERO);
	(*u_temp_i)--;

	return inst;
}

static GLuint *r300TranslateOpcodeFRC(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(VE_FRACTION,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = __CONST(0, SWIZZLE_ZERO);
	inst[3] = __CONST(0, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeLG2(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	// LG2 RESULT 1.X Y Z W PARAM 0{} {X X X X}

	inst[0] = PVS_OP_DST_OPERAND(ME_LOG_BASE2_FULL_DX,
				     GL_TRUE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = PVS_SRC_OPERAND(t_src_index(vp, &src[0]),
				  t_swizzle(GET_SWZ(src[0].Swizzle, 0)),
				  t_swizzle(GET_SWZ(src[0].Swizzle, 0)),
				  t_swizzle(GET_SWZ(src[0].Swizzle, 0)),
				  t_swizzle(GET_SWZ(src[0].Swizzle, 0)),
				  t_src_class(src[0].File),
				  src[0].
				  NegateBase ? VSF_FLAG_ALL : VSF_FLAG_NONE) |
	    (src[0].RelAddr << 4);
	inst[2] = __CONST(0, SWIZZLE_ZERO);
	inst[3] = __CONST(0, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeLIT(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	//LIT TMP 1.Y Z TMP 1{} {X W Z Y} TMP 1{} {Y W Z X} TMP 1{} {Y X Z W}

	inst[0] = PVS_OP_DST_OPERAND(ME_LIGHT_COEFF_DX,
				     GL_TRUE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	/* NOTE: Users swizzling might not work. */
	inst[1] = PVS_SRC_OPERAND(t_src_index(vp, &src[0]), t_swizzle(GET_SWZ(src[0].Swizzle, 0)),	// X
				  t_swizzle(GET_SWZ(src[0].Swizzle, 3)),	// W
				  PVS_SRC_SELECT_FORCE_0,	// Z
				  t_swizzle(GET_SWZ(src[0].Swizzle, 1)),	// Y
				  t_src_class(src[0].File),
				  src[0].
				  NegateBase ? VSF_FLAG_ALL : VSF_FLAG_NONE) |
	    (src[0].RelAddr << 4);
	inst[2] = PVS_SRC_OPERAND(t_src_index(vp, &src[0]), t_swizzle(GET_SWZ(src[0].Swizzle, 1)),	// Y
				  t_swizzle(GET_SWZ(src[0].Swizzle, 3)),	// W
				  PVS_SRC_SELECT_FORCE_0,	// Z
				  t_swizzle(GET_SWZ(src[0].Swizzle, 0)),	// X
				  t_src_class(src[0].File),
				  src[0].
				  NegateBase ? VSF_FLAG_ALL : VSF_FLAG_NONE) |
	    (src[0].RelAddr << 4);
	inst[3] = PVS_SRC_OPERAND(t_src_index(vp, &src[0]), t_swizzle(GET_SWZ(src[0].Swizzle, 1)),	// Y
				  t_swizzle(GET_SWZ(src[0].Swizzle, 0)),	// X
				  PVS_SRC_SELECT_FORCE_0,	// Z
				  t_swizzle(GET_SWZ(src[0].Swizzle, 3)),	// W
				  t_src_class(src[0].File),
				  src[0].
				  NegateBase ? VSF_FLAG_ALL : VSF_FLAG_NONE) |
	    (src[0].RelAddr << 4);

	return inst;
}

static GLuint *r300TranslateOpcodeLOG(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(ME_LOG_BASE2_DX,
				     GL_TRUE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src_scalar(vp, &src[0]);
	inst[2] = __CONST(0, SWIZZLE_ZERO);
	inst[3] = __CONST(0, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeMAD(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(PVS_MACRO_OP_2CLK_MADD,
				     GL_FALSE,
				     GL_TRUE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = t_src(vp, &src[1]);
	inst[3] = t_src(vp, &src[2]);

	return inst;
}

static GLuint *r300TranslateOpcodeMAX(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(VE_MAXIMUM,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = t_src(vp, &src[1]);
	inst[3] = __CONST(1, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeMIN(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(VE_MINIMUM,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = t_src(vp, &src[1]);
	inst[3] = __CONST(1, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeMOV(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	//ADD RESULT 1.X Y Z W PARAM 0{} {X Y Z W} PARAM 0{} {ZERO ZERO ZERO ZERO}

	inst[0] = PVS_OP_DST_OPERAND(VE_ADD,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = __CONST(0, SWIZZLE_ZERO);
	inst[3] = __CONST(0, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeMUL(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(VE_MULTIPLY,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = t_src(vp, &src[1]);
	inst[3] = __CONST(1, SWIZZLE_ZERO);
d110 1
a110 99
	return inst;
}

static GLuint *r300TranslateOpcodePOW(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(ME_POWER_FUNC_FF,
				     GL_TRUE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src_scalar(vp, &src[0]);
	inst[2] = __CONST(0, SWIZZLE_ZERO);
	inst[3] = t_src_scalar(vp, &src[1]);

	return inst;
}

static GLuint *r300TranslateOpcodeRCP(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(ME_RECIP_DX,
				     GL_TRUE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src_scalar(vp, &src[0]);
	inst[2] = __CONST(0, SWIZZLE_ZERO);
	inst[3] = __CONST(0, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeRSQ(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(ME_RECIP_SQRT_DX,
				     GL_TRUE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src_scalar(vp, &src[0]);
	inst[2] = __CONST(0, SWIZZLE_ZERO);
	inst[3] = __CONST(0, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeSGE(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(VE_SET_GREATER_THAN_EQUAL,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = t_src(vp, &src[1]);
	inst[3] = __CONST(1, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeSLT(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	inst[0] = PVS_OP_DST_OPERAND(VE_SET_LESS_THAN,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = t_src(vp, &src[1]);
	inst[3] = __CONST(1, SWIZZLE_ZERO);

	return inst;
}

static GLuint *r300TranslateOpcodeSUB(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	//ADD RESULT 1.X Y Z W TMP 0{} {X Y Z W} PARAM 1{X Y Z W } {X Y Z W} neg Xneg Yneg Zneg W
d112 6
a117 48
#if 0
	inst[0] = PVS_OP_DST_OPERAND(VE_ADD,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = PVS_SRC_OPERAND(t_src_index(vp, &src[1]),
				  t_swizzle(GET_SWZ(src[1].Swizzle, 0)),
				  t_swizzle(GET_SWZ(src[1].Swizzle, 1)),
				  t_swizzle(GET_SWZ(src[1].Swizzle, 2)),
				  t_swizzle(GET_SWZ(src[1].Swizzle, 3)),
				  t_src_class(src[1].File),
				  (!src[1].
				   NegateBase) ? VSF_FLAG_ALL : VSF_FLAG_NONE) |
	    (src[1].RelAddr << 4);
	inst[3] = 0;
#else
	inst[0] =
	    PVS_OP_DST_OPERAND(VE_MULTIPLY_ADD,
			       GL_FALSE,
			       GL_FALSE,
			       t_dst_index(vp, &vpi->DstReg),
			       t_dst_mask(vpi->DstReg.WriteMask),
			       t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = __CONST(0, SWIZZLE_ONE);
	inst[3] = PVS_SRC_OPERAND(t_src_index(vp, &src[1]),
				  t_swizzle(GET_SWZ(src[1].Swizzle, 0)),
				  t_swizzle(GET_SWZ(src[1].Swizzle, 1)),
				  t_swizzle(GET_SWZ(src[1].Swizzle, 2)),
				  t_swizzle(GET_SWZ(src[1].Swizzle, 3)),
				  t_src_class(src[1].File),
				  (!src[1].
				   NegateBase) ? VSF_FLAG_ALL : VSF_FLAG_NONE) |
	    (src[1].RelAddr << 4);
#endif

	return inst;
}

static GLuint *r300TranslateOpcodeSWZ(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3])
{
	//ADD RESULT 1.X Y Z W PARAM 0{} {X Y Z W} PARAM 0{} {ZERO ZERO ZERO ZERO}
d119 3
a121 9
	inst[0] = PVS_OP_DST_OPERAND(VE_ADD,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = t_src(vp, &src[0]);
	inst[2] = __CONST(0, SWIZZLE_ZERO);
	inst[3] = __CONST(0, SWIZZLE_ZERO);
d123 1
a123 1
	return inst;
a125 61
static GLuint *r300TranslateOpcodeXPD(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi,
				      GLuint * inst,
				      struct prog_src_register src[3],
				      int *u_temp_i)
{
	/* mul r0, r1.yzxw, r2.zxyw
	   mad r0, -r2.yzxw, r1.zxyw, r0
	 */

	inst[0] = PVS_OP_DST_OPERAND(VE_MULTIPLY_ADD,
				     GL_FALSE,
				     GL_FALSE,
				     *u_temp_i,
				     t_dst_mask(vpi->DstReg.WriteMask),
				     PVS_DST_REG_TEMPORARY);
	inst[1] = PVS_SRC_OPERAND(t_src_index(vp, &src[0]), t_swizzle(GET_SWZ(src[0].Swizzle, 1)),	// Y
				  t_swizzle(GET_SWZ(src[0].Swizzle, 2)),	// Z
				  t_swizzle(GET_SWZ(src[0].Swizzle, 0)),	// X
				  t_swizzle(GET_SWZ(src[0].Swizzle, 3)),	// W
				  t_src_class(src[0].File),
				  src[0].
				  NegateBase ? VSF_FLAG_ALL : VSF_FLAG_NONE) |
	    (src[0].RelAddr << 4);
	inst[2] = PVS_SRC_OPERAND(t_src_index(vp, &src[1]), t_swizzle(GET_SWZ(src[1].Swizzle, 2)),	// Z
				  t_swizzle(GET_SWZ(src[1].Swizzle, 0)),	// X
				  t_swizzle(GET_SWZ(src[1].Swizzle, 1)),	// Y
				  t_swizzle(GET_SWZ(src[1].Swizzle, 3)),	// W
				  t_src_class(src[1].File),
				  src[1].
				  NegateBase ? VSF_FLAG_ALL : VSF_FLAG_NONE) |
	    (src[1].RelAddr << 4);
	inst[3] = __CONST(1, SWIZZLE_ZERO);
	inst += 4;

	inst[0] = PVS_OP_DST_OPERAND(VE_MULTIPLY_ADD,
				     GL_FALSE,
				     GL_FALSE,
				     t_dst_index(vp, &vpi->DstReg),
				     t_dst_mask(vpi->DstReg.WriteMask),
				     t_dst_class(vpi->DstReg.File));
	inst[1] = PVS_SRC_OPERAND(t_src_index(vp, &src[1]), t_swizzle(GET_SWZ(src[1].Swizzle, 1)),	// Y
				  t_swizzle(GET_SWZ(src[1].Swizzle, 2)),	// Z
				  t_swizzle(GET_SWZ(src[1].Swizzle, 0)),	// X
				  t_swizzle(GET_SWZ(src[1].Swizzle, 3)),	// W
				  t_src_class(src[1].File),
				  (!src[1].
				   NegateBase) ? VSF_FLAG_ALL : VSF_FLAG_NONE) |
	    (src[1].RelAddr << 4);
	inst[2] = PVS_SRC_OPERAND(t_src_index(vp, &src[0]), t_swizzle(GET_SWZ(src[0].Swizzle, 2)),	// Z
				  t_swizzle(GET_SWZ(src[0].Swizzle, 0)),	// X
				  t_swizzle(GET_SWZ(src[0].Swizzle, 1)),	// Y
				  t_swizzle(GET_SWZ(src[0].Swizzle, 3)),	// W
				  t_src_class(src[0].File),
				  src[0].
				  NegateBase ? VSF_FLAG_ALL : VSF_FLAG_NONE) |
	    (src[0].RelAddr << 4);
	inst[3] =
	    PVS_SRC_OPERAND(*u_temp_i, PVS_SRC_SELECT_X, PVS_SRC_SELECT_Y,
			    PVS_SRC_SELECT_Z, PVS_SRC_SELECT_W,
			    PVS_SRC_REG_TEMPORARY, VSF_FLAG_NONE);
d127 1
a127 6
	(*u_temp_i)--;

	return inst;
}

static void t_inputs_outputs(struct r300_vertex_program *vp)
d130 2
a131 1
	int cur_reg = 0;
d133 2
a134 2
	for (i = 0; i < VERT_ATTRIB_MAX; i++)
		vp->inputs[i] = -1;
d136 6
a141 7
	for (i = 0; i < VERT_RESULT_MAX; i++)
		vp->outputs[i] = -1;

	assert(vp->key.OutputsWritten & (1 << VERT_RESULT_HPOS));

	if (vp->key.OutputsWritten & (1 << VERT_RESULT_HPOS)) {
		vp->outputs[VERT_RESULT_HPOS] = cur_reg++;
d144 3
a146 3
	if (vp->key.OutputsWritten & (1 << VERT_RESULT_PSIZ)) {
		vp->outputs[VERT_RESULT_PSIZ] = cur_reg++;
	}
d148 1
a148 3
	if (vp->key.OutputsWritten & (1 << VERT_RESULT_COL0)) {
		vp->outputs[VERT_RESULT_COL0] = cur_reg++;
	}
d150 2
a151 4
	if (vp->key.OutputsWritten & (1 << VERT_RESULT_COL1)) {
		vp->outputs[VERT_RESULT_COL1] =
		    vp->outputs[VERT_RESULT_COL0] + 1;
		cur_reg = vp->outputs[VERT_RESULT_COL1] + 1;
d154 2
a155 4
	if (vp->key.OutputsWritten & (1 << VERT_RESULT_BFC0)) {
		vp->outputs[VERT_RESULT_BFC0] =
		    vp->outputs[VERT_RESULT_COL0] + 2;
		cur_reg = vp->outputs[VERT_RESULT_BFC0] + 2;
d158 30
a187 4
	if (vp->key.OutputsWritten & (1 << VERT_RESULT_BFC1)) {
		vp->outputs[VERT_RESULT_BFC1] =
		    vp->outputs[VERT_RESULT_COL0] + 3;
		cur_reg = vp->outputs[VERT_RESULT_BFC1] + 1;
a188 5
#if 0
	if (vp->key.OutputsWritten & (1 << VERT_RESULT_FOGC)) {
		vp->outputs[VERT_RESULT_FOGC] = cur_reg++;
	}
#endif
d191 2
a192 2
		if (vp->key.OutputsWritten & (1 << i)) {
			vp->outputs[i] = cur_reg++;
d195 4
d201 7
a207 2
static void r300TranslateVertexShader(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi)
d209 2
a210 27
	int i;
	GLuint *inst;
	unsigned long num_operands;
	/* Initial value should be last tmp reg that hw supports.
	   Strangely enough r300 doesnt mind even though these would be out of range.
	   Smart enough to realize that it doesnt need it? */
	int u_temp_i = VSF_MAX_FRAGMENT_TEMPS - 1;
	struct prog_src_register src[3];

	vp->pos_end = 0;	/* Not supported yet */
	vp->program.length = 0;
	/*vp->num_temporaries=mesa_vp->Base.NumTemporaries; */
	vp->translated = GL_TRUE;
	vp->native = GL_TRUE;

	t_inputs_outputs(vp);

	for (inst = vp->program.body.i; vpi->Opcode != OPCODE_END;
	     vpi++, inst += 4) {

		FREE_TEMPS();

		if (!valid_dst(vp, &vpi->DstReg)) {
			/* redirect result to unused temp */
			vpi->DstReg.File = PROGRAM_TEMPORARY;
			vpi->DstReg.Index = u_temp_i;
		}
d212 24
a235 36
		num_operands = _mesa_num_inst_src_regs(vpi->Opcode);

		/* copy the sources (src) from mesa into a local variable... is this needed? */
		for (i = 0; i < num_operands; i++) {
			src[i] = vpi->SrcReg[i];
		}

		if (num_operands == 3) {	/* TODO: scalars */
			if (CMP_SRCS(src[1], src[2])
			    || CMP_SRCS(src[0], src[2])) {
				inst[0] = PVS_OP_DST_OPERAND(VE_ADD,
							     GL_FALSE,
							     GL_FALSE,
							     u_temp_i,
							     VSF_FLAG_ALL,
							     PVS_DST_REG_TEMPORARY);
				inst[1] =
				    PVS_SRC_OPERAND(t_src_index(vp, &src[2]),
						    SWIZZLE_X,
						    SWIZZLE_Y,
						    SWIZZLE_Z,
						    SWIZZLE_W,
						    t_src_class(src[2].File),
						    VSF_FLAG_NONE) | (src[2].
								      RelAddr <<
								      4);
				inst[2] = __CONST(2, SWIZZLE_ZERO);
				inst[3] = __CONST(2, SWIZZLE_ZERO);
				inst += 4;

				src[2].File = PROGRAM_TEMPORARY;
				src[2].Index = u_temp_i;
				src[2].RelAddr = 0;
				u_temp_i--;
			}
		}
d237 15
a251 117
		if (num_operands >= 2) {
			if (CMP_SRCS(src[1], src[0])) {
				inst[0] = PVS_OP_DST_OPERAND(VE_ADD,
							     GL_FALSE,
							     GL_FALSE,
							     u_temp_i,
							     VSF_FLAG_ALL,
							     PVS_DST_REG_TEMPORARY);
				inst[1] =
				    PVS_SRC_OPERAND(t_src_index(vp, &src[0]),
						    SWIZZLE_X,
						    SWIZZLE_Y,
						    SWIZZLE_Z,
						    SWIZZLE_W,
						    t_src_class(src[0].File),
						    VSF_FLAG_NONE) | (src[0].
								      RelAddr <<
								      4);
				inst[2] = __CONST(0, SWIZZLE_ZERO);
				inst[3] = __CONST(0, SWIZZLE_ZERO);
				inst += 4;

				src[0].File = PROGRAM_TEMPORARY;
				src[0].Index = u_temp_i;
				src[0].RelAddr = 0;
				u_temp_i--;
			}
		}

		switch (vpi->Opcode) {
		case OPCODE_ABS:
			inst = r300TranslateOpcodeABS(vp, vpi, inst, src);
			break;
		case OPCODE_ADD:
			inst = r300TranslateOpcodeADD(vp, vpi, inst, src);
			break;
		case OPCODE_ARL:
			inst = r300TranslateOpcodeARL(vp, vpi, inst, src);
			break;
		case OPCODE_DP3:
			inst = r300TranslateOpcodeDP3(vp, vpi, inst, src);
			break;
		case OPCODE_DP4:
			inst = r300TranslateOpcodeDP4(vp, vpi, inst, src);
			break;
		case OPCODE_DPH:
			inst = r300TranslateOpcodeDPH(vp, vpi, inst, src);
			break;
		case OPCODE_DST:
			inst = r300TranslateOpcodeDST(vp, vpi, inst, src);
			break;
		case OPCODE_EX2:
			inst = r300TranslateOpcodeEX2(vp, vpi, inst, src);
			break;
		case OPCODE_EXP:
			inst = r300TranslateOpcodeEXP(vp, vpi, inst, src);
			break;
		case OPCODE_FLR:
			inst = r300TranslateOpcodeFLR(vp, vpi, inst, src,	/* FIXME */
						      &u_temp_i);
			break;
		case OPCODE_FRC:
			inst = r300TranslateOpcodeFRC(vp, vpi, inst, src);
			break;
		case OPCODE_LG2:
			inst = r300TranslateOpcodeLG2(vp, vpi, inst, src);
			break;
		case OPCODE_LIT:
			inst = r300TranslateOpcodeLIT(vp, vpi, inst, src);
			break;
		case OPCODE_LOG:
			inst = r300TranslateOpcodeLOG(vp, vpi, inst, src);
			break;
		case OPCODE_MAD:
			inst = r300TranslateOpcodeMAD(vp, vpi, inst, src);
			break;
		case OPCODE_MAX:
			inst = r300TranslateOpcodeMAX(vp, vpi, inst, src);
			break;
		case OPCODE_MIN:
			inst = r300TranslateOpcodeMIN(vp, vpi, inst, src);
			break;
		case OPCODE_MOV:
			inst = r300TranslateOpcodeMOV(vp, vpi, inst, src);
			break;
		case OPCODE_MUL:
			inst = r300TranslateOpcodeMUL(vp, vpi, inst, src);
			break;
		case OPCODE_POW:
			inst = r300TranslateOpcodePOW(vp, vpi, inst, src);
			break;
		case OPCODE_RCP:
			inst = r300TranslateOpcodeRCP(vp, vpi, inst, src);
			break;
		case OPCODE_RSQ:
			inst = r300TranslateOpcodeRSQ(vp, vpi, inst, src);
			break;
		case OPCODE_SGE:
			inst = r300TranslateOpcodeSGE(vp, vpi, inst, src);
			break;
		case OPCODE_SLT:
			inst = r300TranslateOpcodeSLT(vp, vpi, inst, src);
			break;
		case OPCODE_SUB:
			inst = r300TranslateOpcodeSUB(vp, vpi, inst, src);
			break;
		case OPCODE_SWZ:
			inst = r300TranslateOpcodeSWZ(vp, vpi, inst, src);
			break;
		case OPCODE_XPD:
			inst = r300TranslateOpcodeXPD(vp, vpi, inst, src,	/* FIXME */
						      &u_temp_i);
			break;
		default:
			assert(0);
			break;
		}
d254 2
a255 15
	/* Some outputs may be artificially added, to match the inputs
	   of the fragment program. Blank the outputs here. */
	for (i = 0; i < VERT_RESULT_MAX; i++) {
		if (vp->key.OutputsAdded & (1 << i)) {
			inst[0] = PVS_OP_DST_OPERAND(VE_ADD,
						     GL_FALSE,
						     GL_FALSE,
						     vp->outputs[i],
						     VSF_FLAG_ALL,
						     PVS_DST_REG_OUT);
			inst[1] = __CONST(0, SWIZZLE_ZERO);
			inst[2] = __CONST(0, SWIZZLE_ZERO);
			inst[3] = __CONST(0, SWIZZLE_ZERO);
			inst += 4;
		}
d258 1
a258 11
	vp->program.length = (inst - vp->program.body.i);
	if (vp->program.length >= VSF_MAX_FRAGMENT_LENGTH) {
		vp->program.length = 0;
		vp->native = GL_FALSE;
	}
#if 0
	fprintf(stderr, "hw program:\n");
	for (i = 0; i < vp->program.length; i++)
		fprintf(stderr, "%08x\n", vp->program.body.d[i]);
#endif
}
d260 2
a261 2
/* DP4 version seems to trigger some hw peculiarity */
//#define PREFER_DP4
d263 1
a263 5
static void position_invariant(struct gl_program *prog)
{
	struct prog_instruction *vpi;
	struct gl_program_parameter_list *paramList;
	int i;
d265 2
a266 1
	gl_state_index tokens[STATE_LENGTH] = { STATE_MVP_MATRIX, 0, 0, 0, 0 };
d268 7
a274 37
	/* tokens[4] = matrix modifier */
#ifdef PREFER_DP4
	tokens[4] = 0;		/* not transposed or inverted */
#else
	tokens[4] = STATE_MATRIX_TRANSPOSE;
#endif
	paramList = prog->Parameters;

	vpi = _mesa_alloc_instructions(prog->NumInstructions + 4);
	_mesa_init_instructions(vpi, prog->NumInstructions + 4);

	for (i = 0; i < 4; i++) {
		GLint idx;
		tokens[2] = tokens[3] = i;	/* matrix row[i]..row[i] */
		idx = _mesa_add_state_reference(paramList, tokens);
#ifdef PREFER_DP4
		vpi[i].Opcode = OPCODE_DP4;
		vpi[i].StringPos = 0;
		vpi[i].Data = 0;

		vpi[i].DstReg.File = PROGRAM_OUTPUT;
		vpi[i].DstReg.Index = VERT_RESULT_HPOS;
		vpi[i].DstReg.WriteMask = 1 << i;
		vpi[i].DstReg.CondMask = COND_TR;

		vpi[i].SrcReg[0].File = PROGRAM_STATE_VAR;
		vpi[i].SrcReg[0].Index = idx;
		vpi[i].SrcReg[0].Swizzle = SWIZZLE_XYZW;

		vpi[i].SrcReg[1].File = PROGRAM_INPUT;
		vpi[i].SrcReg[1].Index = VERT_ATTRIB_POS;
		vpi[i].SrcReg[1].Swizzle = SWIZZLE_XYZW;
#else
		if (i == 0)
			vpi[i].Opcode = OPCODE_MUL;
		else
			vpi[i].Opcode = OPCODE_MAD;
d276 2
a277 2
		vpi[i].StringPos = 0;
		vpi[i].Data = 0;
d279 6
a284 22
		if (i == 3)
			vpi[i].DstReg.File = PROGRAM_OUTPUT;
		else
			vpi[i].DstReg.File = PROGRAM_TEMPORARY;
		vpi[i].DstReg.Index = 0;
		vpi[i].DstReg.WriteMask = 0xf;
		vpi[i].DstReg.CondMask = COND_TR;

		vpi[i].SrcReg[0].File = PROGRAM_STATE_VAR;
		vpi[i].SrcReg[0].Index = idx;
		vpi[i].SrcReg[0].Swizzle = SWIZZLE_XYZW;

		vpi[i].SrcReg[1].File = PROGRAM_INPUT;
		vpi[i].SrcReg[1].Index = VERT_ATTRIB_POS;
		vpi[i].SrcReg[1].Swizzle = MAKE_SWIZZLE4(i, i, i, i);

		if (i > 0) {
			vpi[i].SrcReg[2].File = PROGRAM_TEMPORARY;
			vpi[i].SrcReg[2].Index = 0;
			vpi[i].SrcReg[2].Swizzle = SWIZZLE_XYZW;
		}
#endif
d287 1
a287 2
	_mesa_copy_instructions(&vpi[i], prog->Instructions,
				prog->NumInstructions);
d289 3
a291 1
	free(prog->Instructions);
d293 1
a293 1
	prog->Instructions = vpi;
d295 2
a296 2
	prog->NumInstructions += 4;
	vpi = &prog->Instructions[prog->NumInstructions - 1];
d298 1
a298 2
	assert(vpi->Opcode == OPCODE_END);
}
d300 1
a300 50
static void insert_wpos(struct r300_vertex_program *vp, struct gl_program *prog,
			GLuint temp_index)
{
	struct prog_instruction *vpi;
	struct prog_instruction *vpi_insert;
	int i = 0;

	vpi = _mesa_alloc_instructions(prog->NumInstructions + 2);
	_mesa_init_instructions(vpi, prog->NumInstructions + 2);
	/* all but END */
	_mesa_copy_instructions(vpi, prog->Instructions,
				prog->NumInstructions - 1);
	/* END */
	_mesa_copy_instructions(&vpi[prog->NumInstructions + 1],
				&prog->Instructions[prog->NumInstructions - 1],
				1);
	vpi_insert = &vpi[prog->NumInstructions - 1];

	vpi_insert[i].Opcode = OPCODE_MOV;

	vpi_insert[i].DstReg.File = PROGRAM_OUTPUT;
	vpi_insert[i].DstReg.Index = VERT_RESULT_HPOS;
	vpi_insert[i].DstReg.WriteMask = WRITEMASK_XYZW;
	vpi_insert[i].DstReg.CondMask = COND_TR;

	vpi_insert[i].SrcReg[0].File = PROGRAM_TEMPORARY;
	vpi_insert[i].SrcReg[0].Index = temp_index;
	vpi_insert[i].SrcReg[0].Swizzle = SWIZZLE_XYZW;
	i++;

	vpi_insert[i].Opcode = OPCODE_MOV;

	vpi_insert[i].DstReg.File = PROGRAM_OUTPUT;
	vpi_insert[i].DstReg.Index = VERT_RESULT_TEX0 + vp->wpos_idx;
	vpi_insert[i].DstReg.WriteMask = WRITEMASK_XYZW;
	vpi_insert[i].DstReg.CondMask = COND_TR;

	vpi_insert[i].SrcReg[0].File = PROGRAM_TEMPORARY;
	vpi_insert[i].SrcReg[0].Index = temp_index;
	vpi_insert[i].SrcReg[0].Swizzle = SWIZZLE_XYZW;
	i++;

	free(prog->Instructions);

	prog->Instructions = vpi;

	prog->NumInstructions += i;
	vpi = &prog->Instructions[prog->NumInstructions - 1];

	assert(vpi->Opcode == OPCODE_END);
d303 1
a303 21
static void pos_as_texcoord(struct r300_vertex_program *vp,
			    struct gl_program *prog)
{
	struct prog_instruction *vpi;
	GLuint tempregi = prog->NumTemporaries;
	/* should do something else if no temps left... */
	prog->NumTemporaries++;

	for (vpi = prog->Instructions; vpi->Opcode != OPCODE_END; vpi++) {
		if (vpi->DstReg.File == PROGRAM_OUTPUT
		    && vpi->DstReg.Index == VERT_RESULT_HPOS) {
			vpi->DstReg.File = PROGRAM_TEMPORARY;
			vpi->DstReg.Index = tempregi;
		}
	}
	insert_wpos(vp, prog, tempregi);
}

static struct r300_vertex_program *build_program(struct r300_vertex_program_key
						 *wanted_key, struct gl_vertex_program
						 *mesa_vp, GLint wpos_idx)
d305 3
d310 1
a310 3
	vp = _mesa_calloc(sizeof(*vp));
	_mesa_memcpy(&vp->key, wanted_key, sizeof(vp->key));
	vp->wpos_idx = wpos_idx;
d312 11
a322 2
	if (mesa_vp->IsPositionInvariant) {
		position_invariant(&mesa_vp->Base);
d325 9
a333 2
	if (wpos_idx > -1) {
		pos_as_texcoord(vp, &mesa_vp->Base);
d336 3
a338 3
	assert(mesa_vp->Base.NumInstructions);
	vp->num_temporaries = mesa_vp->Base.NumTemporaries;
	r300TranslateVertexShader(vp, mesa_vp->Base.Instructions);
d340 1
a340 1
	return vp;
d343 5
a347 8
static void add_outputs(struct r300_vertex_program_key *key, GLint vert)
{
	if (key->OutputsWritten & (1 << vert))
		return;

	key->OutputsWritten |= 1 << vert;
	key->OutputsAdded |= 1 << vert;
}
d349 1
a349 1
void r300SelectVertexShader(r300ContextPtr r300)
d351 1
a351 7
	GLcontext *ctx = ctx = r300->radeon.glCtx;
	GLuint InputsRead;
	struct r300_vertex_program_key wanted_key = { 0 };
	GLint i;
	struct r300_vertex_program_cont *vpc;
	struct r300_vertex_program *vp;
	GLint wpos_idx;
d353 1
a353 15
	vpc = (struct r300_vertex_program_cont *)ctx->VertexProgram._Current;
	wanted_key.InputsRead = vpc->mesa_program.Base.InputsRead;
	wanted_key.OutputsWritten = vpc->mesa_program.Base.OutputsWritten;
	InputsRead = ctx->FragmentProgram._Current->Base.InputsRead;

	wpos_idx = -1;
	if (InputsRead & FRAG_BIT_WPOS) {
		for (i = 0; i < ctx->Const.MaxTextureUnits; i++)
			if (!(InputsRead & (FRAG_BIT_TEX0 << i)))
				break;

		if (i == ctx->Const.MaxTextureUnits) {
			fprintf(stderr, "\tno free texcoord found\n");
			_mesa_exit(-1);
		}
d355 22
a376 2
		wanted_key.OutputsWritten |= 1 << (VERT_RESULT_TEX0 + i);
		wpos_idx = i;
d378 1
d380 6
a385 1
	add_outputs(&wanted_key, VERT_RESULT_HPOS);
d387 4
a390 3
	if (InputsRead & FRAG_BIT_COL0) {
		add_outputs(&wanted_key, VERT_RESULT_COL0);
	}
d392 5
a396 2
	if (InputsRead & FRAG_BIT_COL1) {
		add_outputs(&wanted_key, VERT_RESULT_COL1);
d398 3
d402 2
a403 5
	for (i = 0; i < ctx->Const.MaxTextureUnits; i++) {
		if (InputsRead & (FRAG_BIT_TEX0 << i)) {
			add_outputs(&wanted_key, VERT_RESULT_TEX0 + i);
		}
	}
d405 2
a406 4
	if (vpc->mesa_program.IsPositionInvariant) {
		/* we wan't position don't we ? */
		wanted_key.InputsRead |= (1 << VERT_ATTRIB_POS);
	}
d408 3
a410 7
	for (vp = vpc->progs; vp; vp = vp->next)
		if (_mesa_memcmp(&vp->key, &wanted_key, sizeof(wanted_key))
		    == 0) {
			r300->selected_vp = vp;
			return;
		}
	//_mesa_print_program(&vpc->mesa_program.Base);
d412 2
a413 4
	vp = build_program(&wanted_key, &vpc->mesa_program, wpos_idx);
	vp->next = vpc->progs;
	vpc->progs = vp;
	r300->selected_vp = vp;
@


1.1
log
@Initial revision
@
text
@d3 2
a4 1
Copyright (C) 2005 Aapo Tahkola.
d29 1
a29 5
/**
 * \file
 *
 * \author Aapo Tahkola <aet@@rasterburn.org>
 */
d31 4
a34 4
#include "glheader.h"
#include "macros.h"
#include "enums.h"
#include "program.h"
d42 19
a60 12
#if SWIZZLE_X != VSF_IN_COMPONENT_X || \
    SWIZZLE_Y != VSF_IN_COMPONENT_Y || \
    SWIZZLE_Z != VSF_IN_COMPONENT_Z || \
    SWIZZLE_W != VSF_IN_COMPONENT_W || \
    SWIZZLE_ZERO != VSF_IN_COMPONENT_ZERO || \
    SWIZZLE_ONE != VSF_IN_COMPONENT_ONE || \
    WRITEMASK_X != VSF_FLAG_X || \
    WRITEMASK_Y != VSF_FLAG_Y || \
    WRITEMASK_Z != VSF_FLAG_Z || \
    WRITEMASK_W != VSF_FLAG_W
#error Cannot change these!
#endif
d62 9
a70 45
#define SCALAR_FLAG (1<<31)
#define FLAG_MASK (1<<31)
#define OP_MASK	(0xf)		/* we are unlikely to have more than 15 */
#define OPN(operator, ip) {#operator, OPCODE_##operator, ip}

static struct {
	char *name;
	int opcode;
	unsigned long ip;	/* number of input operands and flags */
} op_names[] = {
	/* *INDENT-OFF* */
	OPN(ABS, 1),
	OPN(ADD, 2),
	OPN(ARL, 1 | SCALAR_FLAG),
	OPN(DP3, 2),
	OPN(DP4, 2),
	OPN(DPH, 2),
	OPN(DST, 2),
	OPN(EX2, 1 | SCALAR_FLAG),
	OPN(EXP, 1 | SCALAR_FLAG),
	OPN(FLR, 1),
	OPN(FRC, 1),
	OPN(LG2, 1 | SCALAR_FLAG),
	OPN(LIT, 1),
	OPN(LOG, 1 | SCALAR_FLAG),
	OPN(MAD, 3),
	OPN(MAX, 2),
	OPN(MIN, 2),
	OPN(MOV, 1),
	OPN(MUL, 2),
	OPN(POW, 2 | SCALAR_FLAG),
	OPN(RCP, 1 | SCALAR_FLAG),
	OPN(RSQ, 1 | SCALAR_FLAG),
	OPN(SGE, 2),
	OPN(SLT, 2),
	OPN(SUB, 2),
	OPN(SWZ, 1),
	OPN(XPD, 2),
	OPN(RCC, 0),	//extra
	OPN(PRINT, 0),
	OPN(END, 0)
	/* *INDENT-ON* */
};

#undef OPN
a103 1

a112 1

d134 1
a134 1
		return VSF_OUT_CLASS_TMP;
d136 1
a136 1
		return VSF_OUT_CLASS_RESULT;
d138 1
a138 1
		return VSF_OUT_CLASS_ADDR;
a165 1

d168 1
a168 2
		return VSF_IN_CLASS_TMP;

d170 1
a170 2
		return VSF_IN_CLASS_ATTR;

d174 1
d176 1
a176 1
		return VSF_IN_CLASS_PARAM;
d189 1
a189 1
static __inline unsigned long t_swizzle(GLubyte swizzle)
d243 2
d251 1
a251 1
	return MAKE_VSF_SOURCE(t_src_index(vp, src),
d263 4
a266 2

	return MAKE_VSF_SOURCE(t_src_index(vp, src),
d277 16
a292 1
static unsigned long t_opcode(enum prog_opcode opcode)
d294 19
d314 2
a315 18
	switch (opcode) {
	/* *INDENT-OFF* */
	case OPCODE_ARL: return R300_VPI_OUT_OP_ARL;
	case OPCODE_DST: return R300_VPI_OUT_OP_DST;
	case OPCODE_EX2: return R300_VPI_OUT_OP_EX2;
	case OPCODE_EXP: return R300_VPI_OUT_OP_EXP;
	case OPCODE_FRC: return R300_VPI_OUT_OP_FRC;
	case OPCODE_LG2: return R300_VPI_OUT_OP_LG2;
	case OPCODE_LOG: return R300_VPI_OUT_OP_LOG;
	case OPCODE_MAX: return R300_VPI_OUT_OP_MAX;
	case OPCODE_MIN: return R300_VPI_OUT_OP_MIN;
	case OPCODE_MUL: return R300_VPI_OUT_OP_MUL;
	case OPCODE_RCP: return R300_VPI_OUT_OP_RCP;
	case OPCODE_RSQ: return R300_VPI_OUT_OP_RSQ;
	case OPCODE_SGE: return R300_VPI_OUT_OP_SGE;
	case OPCODE_SLT: return R300_VPI_OUT_OP_SLT;
	case OPCODE_DP4: return R300_VPI_OUT_OP_DOT;
	/* *INDENT-ON* */
d317 481
a797 6
	default:
		fprintf(stderr, "%s: Should not be called with opcode %d!",
			__FUNCTION__, opcode);
	}
	_mesa_exit(-1);
	return 0;
d800 4
a803 1
static unsigned long op_operands(enum prog_opcode opcode)
d805 9
a813 1
	int i;
d815 1
a815 8
	/* Can we trust mesas opcodes to be in order ? */
	for (i = 0; i < sizeof(op_names) / sizeof(*op_names); i++)
		if (op_names[i].opcode == opcode)
			return op_names[i].ip;

	fprintf(stderr, "op %d not found in op_names\n", opcode);
	_mesa_exit(-1);
	return 0;
d818 4
a821 2
static GLboolean valid_dst(struct r300_vertex_program *vp,
			   struct prog_dst_register *dst)
d823 40
a862 5
	if (dst->File == PROGRAM_OUTPUT && vp->outputs[dst->Index] == -1) {
		return GL_FALSE;
	} else if (dst->File == PROGRAM_ADDRESS) {
		assert(dst->Index == 0);
	}
d864 1
a864 1
	return GL_TRUE;
d867 6
a872 36
/* TODO: Get rid of t_src_class call */
#define CMP_SRCS(a, b) ((a.RelAddr != b.RelAddr) || (a.Index != b.Index && \
		       ((t_src_class(a.File) == VSF_IN_CLASS_PARAM && \
			 t_src_class(b.File) == VSF_IN_CLASS_PARAM) || \
			(t_src_class(a.File) == VSF_IN_CLASS_ATTR && \
			 t_src_class(b.File) == VSF_IN_CLASS_ATTR)))) \

#define ZERO_SRC_0 (MAKE_VSF_SOURCE(t_src_index(vp, &src[0]), \
				    SWIZZLE_ZERO, SWIZZLE_ZERO, \
				    SWIZZLE_ZERO, SWIZZLE_ZERO, \
				    t_src_class(src[0].File), VSF_FLAG_NONE) | (src[0].RelAddr << 4))

#define ZERO_SRC_1 (MAKE_VSF_SOURCE(t_src_index(vp, &src[1]), \
				    SWIZZLE_ZERO, SWIZZLE_ZERO, \
				    SWIZZLE_ZERO, SWIZZLE_ZERO, \
				    t_src_class(src[1].File), VSF_FLAG_NONE) | (src[1].RelAddr << 4))

#define ZERO_SRC_2 (MAKE_VSF_SOURCE(t_src_index(vp, &src[2]), \
				    SWIZZLE_ZERO, SWIZZLE_ZERO, \
				    SWIZZLE_ZERO, SWIZZLE_ZERO, \
				    t_src_class(src[2].File), VSF_FLAG_NONE) | (src[2].RelAddr << 4))

#define ONE_SRC_0 (MAKE_VSF_SOURCE(t_src_index(vp, &src[0]), \
				    SWIZZLE_ONE, SWIZZLE_ONE, \
				    SWIZZLE_ONE, SWIZZLE_ONE, \
				    t_src_class(src[0].File), VSF_FLAG_NONE) | (src[0].RelAddr << 4))

#define ONE_SRC_1 (MAKE_VSF_SOURCE(t_src_index(vp, &src[1]), \
				    SWIZZLE_ONE, SWIZZLE_ONE, \
				    SWIZZLE_ONE, SWIZZLE_ONE, \
				    t_src_class(src[1].File), VSF_FLAG_NONE) | (src[1].RelAddr << 4))

#define ONE_SRC_2 (MAKE_VSF_SOURCE(t_src_index(vp, &src[2]), \
				    SWIZZLE_ONE, SWIZZLE_ONE, \
				    SWIZZLE_ONE, SWIZZLE_ONE, \
				    t_src_class(src[2].File), VSF_FLAG_NONE) | (src[2].RelAddr << 4))
d874 9
a882 2
/* DP4 version seems to trigger some hw peculiarity */
//#define PREFER_DP4
d884 2
a885 8
#define FREE_TEMPS() \
	do { \
		if(u_temp_i < vp->num_temporaries) { \
			WARN_ONCE("Ran out of temps, num temps %d, us %d\n", vp->num_temporaries, u_temp_i); \
			vp->native = GL_FALSE; \
		} \
		u_temp_i=VSF_MAX_FRAGMENT_TEMPS-1; \
	} while (0)
d887 5
a891 2
static void r300TranslateVertexShader(struct r300_vertex_program *vp,
				      struct prog_instruction *vpi)
d893 60
a952 10
	int i, cur_reg = 0;
	VERTEX_SHADER_INSTRUCTION *o_inst;
	unsigned long operands;
	int are_srcs_scalar;
	unsigned long hw_op;
	/* Initial value should be last tmp reg that hw supports.
	   Strangely enough r300 doesnt mind even though these would be out of range.
	   Smart enough to realize that it doesnt need it? */
	int u_temp_i = VSF_MAX_FRAGMENT_TEMPS - 1;
	struct prog_src_register src[3];
d954 4
a957 3
	vp->pos_end = 0;	/* Not supported yet */
	vp->program.length = 0;
	/*vp->num_temporaries=mesa_vp->Base.NumTemporaries; */
d967 1
a967 2
	/* Assign outputs */
	if (vp->key.OutputsWritten & (1 << VERT_RESULT_HPOS))
d969 1
d971 1
a971 1
	if (vp->key.OutputsWritten & (1 << VERT_RESULT_PSIZ))
d973 1
d975 1
a975 1
	if (vp->key.OutputsWritten & (1 << VERT_RESULT_COL0))
d977 1
d979 5
a983 2
	if (vp->key.OutputsWritten & (1 << VERT_RESULT_COL1))
		vp->outputs[VERT_RESULT_COL1] = cur_reg++;
d985 5
a989 3
#if 0				/* Not supported yet */
	if (vp->key.OutputsWritten & (1 << VERT_RESULT_BFC0))
		vp->outputs[VERT_RESULT_BFC0] = cur_reg++;
d991 7
a997 4
	if (vp->key.OutputsWritten & (1 << VERT_RESULT_BFC1))
		vp->outputs[VERT_RESULT_BFC1] = cur_reg++;

	if (vp->key.OutputsWritten & (1 << VERT_RESULT_FOGC))
d999 1
d1002 2
a1003 2
	for (i = VERT_RESULT_TEX0; i <= VERT_RESULT_TEX7; i++)
		if (vp->key.OutputsWritten & (1 << i))
d1005 15
d1021 3
d1027 5
a1031 2
	o_inst = vp->program.body.i;
	for (; vpi->Opcode != OPCODE_END; vpi++, o_inst++) {
d1040 1
a1040 3
		operands = op_operands(vpi->Opcode);
		are_srcs_scalar = operands & SCALAR_FLAG;
		operands &= OP_MASK;
d1042 2
a1043 1
		for (i = 0; i < operands; i++)
d1045 1
d1047 1
a1047 1
		if (operands == 3) {	/* TODO: scalars */
d1050 12
a1061 9
				o_inst->op =
				    MAKE_VSF_OP(R300_VPI_OUT_OP_ADD, u_temp_i,
						VSF_FLAG_ALL,
						VSF_OUT_CLASS_TMP);

				o_inst->src[0] =
				    MAKE_VSF_SOURCE(t_src_index(vp, &src[2]),
						    SWIZZLE_X, SWIZZLE_Y,
						    SWIZZLE_Z, SWIZZLE_W,
d1066 3
a1068 4

				o_inst->src[1] = ZERO_SRC_2;
				o_inst->src[2] = ZERO_SRC_2;
				o_inst++;
a1074 1

d1077 1
a1077 1
		if (operands >= 2) {
d1079 12
a1090 9
				o_inst->op =
				    MAKE_VSF_OP(R300_VPI_OUT_OP_ADD, u_temp_i,
						VSF_FLAG_ALL,
						VSF_OUT_CLASS_TMP);

				o_inst->src[0] =
				    MAKE_VSF_SOURCE(t_src_index(vp, &src[0]),
						    SWIZZLE_X, SWIZZLE_Y,
						    SWIZZLE_Z, SWIZZLE_W,
d1095 3
a1097 4

				o_inst->src[1] = ZERO_SRC_0;
				o_inst->src[2] = ZERO_SRC_0;
				o_inst++;
a1105 1
		/* These ops need special handling. */
d1107 58
d1166 17
a1182 11
			o_inst->op =
			    MAKE_VSF_OP(R300_VPI_OUT_OP_POW,
					t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));
			o_inst->src[0] = t_src_scalar(vp, &src[0]);
			o_inst->src[1] = ZERO_SRC_0;
			o_inst->src[2] = t_src_scalar(vp, &src[1]);
			goto next;

		case OPCODE_MOV:	//ADD RESULT 1.X Y Z W PARAM 0{} {X Y Z W} PARAM 0{} {ZERO ZERO ZERO ZERO}
d1184 2
a1185 337
#if 1
			o_inst->op =
			    MAKE_VSF_OP(R300_VPI_OUT_OP_ADD,
					t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));
			o_inst->src[0] = t_src(vp, &src[0]);
			o_inst->src[1] = ZERO_SRC_0;
			o_inst->src[2] = ZERO_SRC_0;
#else
			hw_op =
			    (src[0].File ==
			     PROGRAM_TEMPORARY) ? R300_VPI_OUT_OP_MAD_2 :
			    R300_VPI_OUT_OP_MAD;

			o_inst->op =
			    MAKE_VSF_OP(hw_op, t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));
			o_inst->src[0] = t_src(vp, &src[0]);
			o_inst->src[1] = ONE_SRC_0;
			o_inst->src[2] = ZERO_SRC_0;
#endif

			goto next;

		case OPCODE_ADD:
#if 1
			hw_op = (src[0].File == PROGRAM_TEMPORARY &&
				 src[1].File ==
				 PROGRAM_TEMPORARY) ? R300_VPI_OUT_OP_MAD_2 :
			    R300_VPI_OUT_OP_MAD;

			o_inst->op =
			    MAKE_VSF_OP(hw_op, t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));
			o_inst->src[0] = ONE_SRC_0;
			o_inst->src[1] = t_src(vp, &src[0]);
			o_inst->src[2] = t_src(vp, &src[1]);
#else
			o_inst->op =
			    MAKE_VSF_OP(R300_VPI_OUT_OP_ADD,
					t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));
			o_inst->src[0] = t_src(vp, &src[0]);
			o_inst->src[1] = t_src(vp, &src[1]);
			o_inst->src[2] = ZERO_SRC_1;

#endif
			goto next;

		case OPCODE_MAD:
			hw_op = (src[0].File == PROGRAM_TEMPORARY &&
				 src[1].File == PROGRAM_TEMPORARY &&
				 src[2].File ==
				 PROGRAM_TEMPORARY) ? R300_VPI_OUT_OP_MAD_2 :
			    R300_VPI_OUT_OP_MAD;

			o_inst->op =
			    MAKE_VSF_OP(hw_op, t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));
			o_inst->src[0] = t_src(vp, &src[0]);
			o_inst->src[1] = t_src(vp, &src[1]);
			o_inst->src[2] = t_src(vp, &src[2]);
			goto next;

		case OPCODE_MUL:	/* HW mul can take third arg but appears to have some other limitations. */
			hw_op = (src[0].File == PROGRAM_TEMPORARY &&
				 src[1].File ==
				 PROGRAM_TEMPORARY) ? R300_VPI_OUT_OP_MAD_2 :
			    R300_VPI_OUT_OP_MAD;

			o_inst->op =
			    MAKE_VSF_OP(hw_op, t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));
			o_inst->src[0] = t_src(vp, &src[0]);
			o_inst->src[1] = t_src(vp, &src[1]);

			o_inst->src[2] = ZERO_SRC_1;
			goto next;

		case OPCODE_DP3:	//DOT RESULT 1.X Y Z W PARAM 0{} {X Y Z ZERO} PARAM 0{} {X Y Z ZERO}
			o_inst->op =
			    MAKE_VSF_OP(R300_VPI_OUT_OP_DOT,
					t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));

			o_inst->src[0] =
			    MAKE_VSF_SOURCE(t_src_index(vp, &src[0]),
					    t_swizzle(GET_SWZ
						      (src[0].Swizzle, 0)),
					    t_swizzle(GET_SWZ
						      (src[0].Swizzle, 1)),
					    t_swizzle(GET_SWZ
						      (src[0].Swizzle, 2)),
					    SWIZZLE_ZERO,
					    t_src_class(src[0].File),
					    src[0].
					    NegateBase ? VSF_FLAG_XYZ :
					    VSF_FLAG_NONE) | (src[0].
							      RelAddr << 4);

			o_inst->src[1] =
			    MAKE_VSF_SOURCE(t_src_index(vp, &src[1]),
					    t_swizzle(GET_SWZ
						      (src[1].Swizzle, 0)),
					    t_swizzle(GET_SWZ
						      (src[1].Swizzle, 1)),
					    t_swizzle(GET_SWZ
						      (src[1].Swizzle, 2)),
					    SWIZZLE_ZERO,
					    t_src_class(src[1].File),
					    src[1].
					    NegateBase ? VSF_FLAG_XYZ :
					    VSF_FLAG_NONE) | (src[1].
							      RelAddr << 4);

			o_inst->src[2] = ZERO_SRC_1;
			goto next;

		case OPCODE_SUB:	//ADD RESULT 1.X Y Z W TMP 0{} {X Y Z W} PARAM 1{X Y Z W } {X Y Z W} neg Xneg Yneg Zneg W
#if 1
			hw_op = (src[0].File == PROGRAM_TEMPORARY &&
				 src[1].File ==
				 PROGRAM_TEMPORARY) ? R300_VPI_OUT_OP_MAD_2 :
			    R300_VPI_OUT_OP_MAD;

			o_inst->op =
			    MAKE_VSF_OP(hw_op, t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));
			o_inst->src[0] = t_src(vp, &src[0]);
			o_inst->src[1] = ONE_SRC_0;
			o_inst->src[2] =
			    MAKE_VSF_SOURCE(t_src_index(vp, &src[1]),
					    t_swizzle(GET_SWZ
						      (src[1].Swizzle, 0)),
					    t_swizzle(GET_SWZ
						      (src[1].Swizzle, 1)),
					    t_swizzle(GET_SWZ
						      (src[1].Swizzle, 2)),
					    t_swizzle(GET_SWZ
						      (src[1].Swizzle, 3)),
					    t_src_class(src[1].File),
					    (!src[1].
					     NegateBase) ? VSF_FLAG_ALL :
					    VSF_FLAG_NONE) | (src[1].
							      RelAddr << 4);
#else
			o_inst->op =
			    MAKE_VSF_OP(R300_VPI_OUT_OP_ADD,
					t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));

			o_inst->src[0] = t_src(vp, &src[0]);
			o_inst->src[1] =
			    MAKE_VSF_SOURCE(t_src_index(vp, &src[1]),
					    t_swizzle(GET_SWZ
						      (src[1].Swizzle, 0)),
					    t_swizzle(GET_SWZ
						      (src[1].Swizzle, 1)),
					    t_swizzle(GET_SWZ
						      (src[1].Swizzle, 2)),
					    t_swizzle(GET_SWZ
						      (src[1].Swizzle, 3)),
					    t_src_class(src[1].File),
					    (!src[1].
					     NegateBase) ? VSF_FLAG_ALL :
					    VSF_FLAG_NONE) | (src[1].
							      RelAddr << 4);
			o_inst->src[2] = 0;
#endif
			goto next;

		case OPCODE_ABS:	//MAX RESULT 1.X Y Z W PARAM 0{} {X Y Z W} PARAM 0{X Y Z W } {X Y Z W} neg Xneg Yneg Zneg W
			o_inst->op =
			    MAKE_VSF_OP(R300_VPI_OUT_OP_MAX,
					t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));

			o_inst->src[0] = t_src(vp, &src[0]);
			o_inst->src[1] =
			    MAKE_VSF_SOURCE(t_src_index(vp, &src[0]),
					    t_swizzle(GET_SWZ
						      (src[0].Swizzle, 0)),
					    t_swizzle(GET_SWZ
						      (src[0].Swizzle, 1)),
					    t_swizzle(GET_SWZ
						      (src[0].Swizzle, 2)),
					    t_swizzle(GET_SWZ
						      (src[0].Swizzle, 3)),
					    t_src_class(src[0].File),
					    (!src[0].
					     NegateBase) ? VSF_FLAG_ALL :
					    VSF_FLAG_NONE) | (src[0].
							      RelAddr << 4);
			o_inst->src[2] = 0;
			goto next;

		case OPCODE_FLR:
			/* FRC TMP 0.X Y Z W PARAM 0{} {X Y Z W}
			   ADD RESULT 1.X Y Z W PARAM 0{} {X Y Z W} TMP 0{X Y Z W } {X Y Z W} neg Xneg Yneg Zneg W */

			o_inst->op = MAKE_VSF_OP(R300_VPI_OUT_OP_FRC, u_temp_i,
						 t_dst_mask(vpi->DstReg.
							    WriteMask),
						 VSF_OUT_CLASS_TMP);

			o_inst->src[0] = t_src(vp, &src[0]);
			o_inst->src[1] = ZERO_SRC_0;
			o_inst->src[2] = ZERO_SRC_0;
			o_inst++;

			o_inst->op =
			    MAKE_VSF_OP(R300_VPI_OUT_OP_ADD,
					t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));

			o_inst->src[0] = t_src(vp, &src[0]);
			o_inst->src[1] = MAKE_VSF_SOURCE(u_temp_i,
							 VSF_IN_COMPONENT_X,
							 VSF_IN_COMPONENT_Y,
							 VSF_IN_COMPONENT_Z,
							 VSF_IN_COMPONENT_W,
							 VSF_IN_CLASS_TMP,
							 /* Not 100% sure about this */
							 (!src[0].
							  NegateBase) ?
							 VSF_FLAG_ALL :
							 VSF_FLAG_NONE
							 /*VSF_FLAG_ALL */ );

			o_inst->src[2] = ZERO_SRC_0;
			u_temp_i--;
			goto next;

		case OPCODE_LG2:	// LG2 RESULT 1.X Y Z W PARAM 0{} {X X X X}
			o_inst->op =
			    MAKE_VSF_OP(R300_VPI_OUT_OP_LG2,
					t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));

			o_inst->src[0] =
			    MAKE_VSF_SOURCE(t_src_index(vp, &src[0]),
					    t_swizzle(GET_SWZ
						      (src[0].Swizzle, 0)),
					    t_swizzle(GET_SWZ
						      (src[0].Swizzle, 0)),
					    t_swizzle(GET_SWZ
						      (src[0].Swizzle, 0)),
					    t_swizzle(GET_SWZ
						      (src[0].Swizzle, 0)),
					    t_src_class(src[0].File),
					    src[0].
					    NegateBase ? VSF_FLAG_ALL :
					    VSF_FLAG_NONE) | (src[0].
							      RelAddr << 4);
			o_inst->src[1] = ZERO_SRC_0;
			o_inst->src[2] = ZERO_SRC_0;
			goto next;

		case OPCODE_LIT:	//LIT TMP 1.Y Z TMP 1{} {X W Z Y} TMP 1{} {Y W Z X} TMP 1{} {Y X Z W}
			o_inst->op =
			    MAKE_VSF_OP(R300_VPI_OUT_OP_LIT,
					t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));
			/* NOTE: Users swizzling might not work. */
			o_inst->src[0] = MAKE_VSF_SOURCE(t_src_index(vp, &src[0]), t_swizzle(GET_SWZ(src[0].Swizzle, 0)),	// x
							 t_swizzle(GET_SWZ(src[0].Swizzle, 3)),	// w
							 VSF_IN_COMPONENT_ZERO,	// z
							 t_swizzle(GET_SWZ(src[0].Swizzle, 1)),	// y
							 t_src_class(src[0].
								     File),
							 src[0].
							 NegateBase ?
							 VSF_FLAG_ALL :
							 VSF_FLAG_NONE) |
			    (src[0].RelAddr << 4);
			o_inst->src[1] = MAKE_VSF_SOURCE(t_src_index(vp, &src[0]), t_swizzle(GET_SWZ(src[0].Swizzle, 1)),	// y
							 t_swizzle(GET_SWZ(src[0].Swizzle, 3)),	// w
							 VSF_IN_COMPONENT_ZERO,	// z
							 t_swizzle(GET_SWZ(src[0].Swizzle, 0)),	// x
							 t_src_class(src[0].
								     File),
							 src[0].
							 NegateBase ?
							 VSF_FLAG_ALL :
							 VSF_FLAG_NONE) |
			    (src[0].RelAddr << 4);
			o_inst->src[2] = MAKE_VSF_SOURCE(t_src_index(vp, &src[0]), t_swizzle(GET_SWZ(src[0].Swizzle, 1)),	// y
							 t_swizzle(GET_SWZ(src[0].Swizzle, 0)),	// x
							 VSF_IN_COMPONENT_ZERO,	// z
							 t_swizzle(GET_SWZ(src[0].Swizzle, 3)),	// w
							 t_src_class(src[0].
								     File),
							 src[0].
							 NegateBase ?
							 VSF_FLAG_ALL :
							 VSF_FLAG_NONE) |
			    (src[0].RelAddr << 4);
			goto next;

		case OPCODE_DPH:	//DOT RESULT 1.X Y Z W PARAM 0{} {X Y Z ONE} PARAM 0{} {X Y Z W}
			o_inst->op =
			    MAKE_VSF_OP(R300_VPI_OUT_OP_DOT,
					t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));

			o_inst->src[0] =
			    MAKE_VSF_SOURCE(t_src_index(vp, &src[0]),
					    t_swizzle(GET_SWZ
						      (src[0].Swizzle, 0)),
					    t_swizzle(GET_SWZ
						      (src[0].Swizzle, 1)),
					    t_swizzle(GET_SWZ
						      (src[0].Swizzle, 2)),
					    VSF_IN_COMPONENT_ONE,
					    t_src_class(src[0].File),
					    src[0].
					    NegateBase ? VSF_FLAG_XYZ :
					    VSF_FLAG_NONE) | (src[0].
							      RelAddr << 4);
			o_inst->src[1] = t_src(vp, &src[1]);
			o_inst->src[2] = ZERO_SRC_1;
			goto next;

d1187 2
a1188 84
			/* mul r0, r1.yzxw, r2.zxyw
			   mad r0, -r2.yzxw, r1.zxyw, r0
			   NOTE: might need MAD_2
			 */

			o_inst->op = MAKE_VSF_OP(R300_VPI_OUT_OP_MAD, u_temp_i,
						 t_dst_mask(vpi->DstReg.
							    WriteMask),
						 VSF_OUT_CLASS_TMP);

			o_inst->src[0] = MAKE_VSF_SOURCE(t_src_index(vp, &src[0]), t_swizzle(GET_SWZ(src[0].Swizzle, 1)),	// y
							 t_swizzle(GET_SWZ(src[0].Swizzle, 2)),	// z
							 t_swizzle(GET_SWZ(src[0].Swizzle, 0)),	// x
							 t_swizzle(GET_SWZ(src[0].Swizzle, 3)),	// w
							 t_src_class(src[0].
								     File),
							 src[0].
							 NegateBase ?
							 VSF_FLAG_ALL :
							 VSF_FLAG_NONE) |
			    (src[0].RelAddr << 4);

			o_inst->src[1] = MAKE_VSF_SOURCE(t_src_index(vp, &src[1]), t_swizzle(GET_SWZ(src[1].Swizzle, 2)),	// z
							 t_swizzle(GET_SWZ(src[1].Swizzle, 0)),	// x
							 t_swizzle(GET_SWZ(src[1].Swizzle, 1)),	// y
							 t_swizzle(GET_SWZ(src[1].Swizzle, 3)),	// w
							 t_src_class(src[1].
								     File),
							 src[1].
							 NegateBase ?
							 VSF_FLAG_ALL :
							 VSF_FLAG_NONE) |
			    (src[1].RelAddr << 4);

			o_inst->src[2] = ZERO_SRC_1;
			o_inst++;
			u_temp_i--;

			o_inst->op =
			    MAKE_VSF_OP(R300_VPI_OUT_OP_MAD,
					t_dst_index(vp, &vpi->DstReg),
					t_dst_mask(vpi->DstReg.WriteMask),
					t_dst_class(vpi->DstReg.File));

			o_inst->src[0] = MAKE_VSF_SOURCE(t_src_index(vp, &src[1]), t_swizzle(GET_SWZ(src[1].Swizzle, 1)),	// y
							 t_swizzle(GET_SWZ(src[1].Swizzle, 2)),	// z
							 t_swizzle(GET_SWZ(src[1].Swizzle, 0)),	// x
							 t_swizzle(GET_SWZ(src[1].Swizzle, 3)),	// w
							 t_src_class(src[1].
								     File),
							 (!src[1].
							  NegateBase) ?
							 VSF_FLAG_ALL :
							 VSF_FLAG_NONE) |
			    (src[1].RelAddr << 4);

			o_inst->src[1] = MAKE_VSF_SOURCE(t_src_index(vp, &src[0]), t_swizzle(GET_SWZ(src[0].Swizzle, 2)),	// z
							 t_swizzle(GET_SWZ(src[0].Swizzle, 0)),	// x
							 t_swizzle(GET_SWZ(src[0].Swizzle, 1)),	// y
							 t_swizzle(GET_SWZ(src[0].Swizzle, 3)),	// w
							 t_src_class(src[0].
								     File),
							 src[0].
							 NegateBase ?
							 VSF_FLAG_ALL :
							 VSF_FLAG_NONE) |
			    (src[0].RelAddr << 4);

			o_inst->src[2] = MAKE_VSF_SOURCE(u_temp_i + 1,
							 VSF_IN_COMPONENT_X,
							 VSF_IN_COMPONENT_Y,
							 VSF_IN_COMPONENT_Z,
							 VSF_IN_COMPONENT_W,
							 VSF_IN_CLASS_TMP,
							 VSF_FLAG_NONE);

			goto next;

		case OPCODE_RCC:
			fprintf(stderr, "Dont know how to handle op %d yet\n",
				vpi->Opcode);
			_mesa_exit(-1);
			break;
		case OPCODE_END:
d1191 1
d1194 1
d1196 14
a1209 58
		o_inst->op =
		    MAKE_VSF_OP(t_opcode(vpi->Opcode),
				t_dst_index(vp, &vpi->DstReg),
				t_dst_mask(vpi->DstReg.WriteMask),
				t_dst_class(vpi->DstReg.File));

		if (are_srcs_scalar) {
			switch (operands) {
			case 1:
				o_inst->src[0] = t_src_scalar(vp, &src[0]);
				o_inst->src[1] = ZERO_SRC_0;
				o_inst->src[2] = ZERO_SRC_0;
				break;

			case 2:
				o_inst->src[0] = t_src_scalar(vp, &src[0]);
				o_inst->src[1] = t_src_scalar(vp, &src[1]);
				o_inst->src[2] = ZERO_SRC_1;
				break;

			case 3:
				o_inst->src[0] = t_src_scalar(vp, &src[0]);
				o_inst->src[1] = t_src_scalar(vp, &src[1]);
				o_inst->src[2] = t_src_scalar(vp, &src[2]);
				break;

			default:
				fprintf(stderr,
					"scalars and op RCC not handled yet");
				_mesa_exit(-1);
				break;
			}
		} else {
			switch (operands) {
			case 1:
				o_inst->src[0] = t_src(vp, &src[0]);
				o_inst->src[1] = ZERO_SRC_0;
				o_inst->src[2] = ZERO_SRC_0;
				break;

			case 2:
				o_inst->src[0] = t_src(vp, &src[0]);
				o_inst->src[1] = t_src(vp, &src[1]);
				o_inst->src[2] = ZERO_SRC_1;
				break;

			case 3:
				o_inst->src[0] = t_src(vp, &src[0]);
				o_inst->src[1] = t_src(vp, &src[1]);
				o_inst->src[2] = t_src(vp, &src[2]);
				break;

			default:
				fprintf(stderr,
					"scalars and op RCC not handled yet");
				_mesa_exit(-1);
				break;
			}
a1210 1
	      next:;
d1213 2
a1214 2
	/* Will most likely segfault before we get here... fix later. */
	if (o_inst - vp->program.body.i >= VSF_MAX_FRAGMENT_LENGTH / 4) {
a1216 1
		return;
a1217 1
	vp->program.length = (o_inst - vp->program.body.i) * 4;
d1225 3
d1314 2
a1315 2
static void insert_wpos(struct r300_vertex_program *vp,
			struct gl_program *prog, GLuint temp_index)
d1375 2
a1376 2
		if (vpi->DstReg.File == PROGRAM_OUTPUT &&
		    vpi->DstReg.Index == VERT_RESULT_HPOS) {
a1391 1

d1398 1
a1398 1
	if (wpos_idx > -1)
d1400 1
a1402 1

a1403 1

d1409 9
d1429 2
a1432 2
	wanted_key.OutputsWritten |= 1 << VERT_RESULT_HPOS;

d1444 1
a1444 1
		InputsRead |= (FRAG_BIT_TEX0 << i);
d1448 1
a1448 2
	if (InputsRead & FRAG_BIT_COL0)
		wanted_key.OutputsWritten |= 1 << VERT_RESULT_COL0;
d1450 13
a1462 8
	if ((InputsRead & FRAG_BIT_COL1)	/*||
						   (InputsRead & FRAG_BIT_FOGC) */ )
		wanted_key.OutputsWritten |= 1 << VERT_RESULT_COL1;

	for (i = 0; i < ctx->Const.MaxTextureUnits; i++)
		if (InputsRead & (FRAG_BIT_TEX0 << i))
			wanted_key.OutputsWritten |=
			    1 << (VERT_RESULT_TEX0 + i);
a1463 1
	wanted_key.InputsRead = vpc->mesa_program.Base.InputsRead;
d1470 2
a1471 2
		if (_mesa_memcmp(&vp->key, &wanted_key, sizeof(wanted_key)) ==
		    0) {
@


1.1.1.1
log
@Mesa 7.0.1
@
text
@@


1.1.1.2
log
@Import Mesa 7.10.3
@
text
@d3 1
a3 2
Copyright (C) 2005  Aapo Tahkola <aet@@rasterburn.org>
Copyright (C) 2008  Oliver McFadden <z3ro.geek@@gmail.com>
d28 5
a32 1
/* Radeon R5xx Acceleration, Revision 1.2 */
d34 7
a40 9
#include "main/glheader.h"
#include "main/macros.h"
#include "main/enums.h"
#include "program/program.h"
#include "program/programopt.h"
#include "program/prog_instruction.h"
#include "program/prog_parameter.h"
#include "program/prog_print.h"
#include "program/prog_statevars.h"
a42 2
#include "compiler/radeon_compiler.h"
#include "radeon_mesa_to_rc.h"
a43 2
#include "r300_fragprog_common.h"
#include "r300_state.h"
d45 61
a105 5
/**
 * Write parameter array for the given vertex program into dst.
 * Return the total number of components written.
 */
static int r300VertexProgUpdateParams(struct gl_context * ctx, struct r300_vertex_program *vp, float *dst)
d107 4
a110 1
	int i;
d112 1
a112 1
	if (vp->Base->IsNVProgram) {
d114 6
a119 3
	} else {
		if (vp->Base->Base.Parameters) {
			_mesa_load_state_parameters(ctx, vp->Base->Base.Parameters);
d121 1
d124 2
a125 3
	for(i = 0; i < vp->code.constants.Count; ++i) {
		const float * src = 0;
		const struct rc_constant * constant = &vp->code.constants.Constants[i];
d127 18
a144 7
		switch(constant->Type) {
		case RC_CONSTANT_EXTERNAL:
			if (vp->Base->IsNVProgram) {
				src = ctx->VertexProgram.Parameters[constant->u.External];
			} else {
				src = vp->Base->Base.Parameters->ParameterValues[constant->u.External];
			}
d147 3
a149 3
		case RC_CONSTANT_IMMEDIATE:
			src = constant->u.Immediate;
			break;
a151 5
		assert(src);
		dst[4*i] = src[0];
		dst[4*i + 1] = src[1];
		dst[4*i + 2] = src[2];
		dst[4*i + 3] = src[3];
d154 1
a154 1
	return 4 * vp->code.constants.Count;
d157 1
a157 1
static GLbitfield compute_required_outputs(struct gl_vertex_program * vp, GLbitfield fpreads)
d159 3
a161 2
	GLbitfield outputs = 0;
	int i;
d163 2
a164 5
#define ADD_OUTPUT(fp_attr, vp_result) \
	do { \
		if (fpreads & (1 << (fp_attr))) \
			outputs |= (1 << (vp_result)); \
	} while (0)
d166 20
a185 5
	ADD_OUTPUT(FRAG_ATTRIB_COL0, VERT_RESULT_COL0);
	ADD_OUTPUT(FRAG_ATTRIB_COL1, VERT_RESULT_COL1);

	for (i = 0; i <= 7; ++i) {
		ADD_OUTPUT(FRAG_ATTRIB_TEX0 + i, VERT_RESULT_TEX0 + i);
d187 1
d189 5
a193 1
#undef ADD_OUTPUT
d195 2
a196 6
	if ((fpreads & (1 << FRAG_ATTRIB_COL0)) &&
	    (vp->Base.OutputsWritten & (1 << VERT_RESULT_BFC0)))
		outputs |= 1 << VERT_RESULT_BFC0;
	if ((fpreads & (1 << FRAG_ATTRIB_COL1)) &&
	    (vp->Base.OutputsWritten & (1 << VERT_RESULT_BFC1)))
		outputs |= 1 << VERT_RESULT_BFC1;
d198 2
a199 3
	outputs |= 1 << VERT_RESULT_HPOS;
	if (vp->Base.OutputsWritten & (1 << VERT_RESULT_PSIZ))
		outputs |= 1 << VERT_RESULT_PSIZ;
d201 22
a222 1
	return outputs;
d225 5
d231 2
a232 1
static void t_inputs_outputs(struct r300_vertex_program_compiler * c)
a234 2
	int cur_reg;
	GLuint OutputsWritten, InputsRead;
d236 5
a240 2
	OutputsWritten = c->Base.Program.OutputsWritten;
	InputsRead = c->Base.Program.InputsRead;
d242 17
a258 7
	cur_reg = -1;
	for (i = 0; i < VERT_ATTRIB_MAX; i++) {
		if (InputsRead & (1 << i))
			c->code->inputs[i] = ++cur_reg;
		else
			c->code->inputs[i] = -1;
	}
d260 3
a262 3
	cur_reg = 0;
	for (i = 0; i < VERT_RESULT_MAX; i++)
		c->code->outputs[i] = -1;
d264 1
a264 1
	assert(OutputsWritten & (1 << VERT_RESULT_HPOS));
d266 1
a266 3
	if (OutputsWritten & (1 << VERT_RESULT_HPOS)) {
		c->code->outputs[VERT_RESULT_HPOS] = cur_reg++;
	}
d268 8
a275 2
	if (OutputsWritten & (1 << VERT_RESULT_PSIZ)) {
		c->code->outputs[VERT_RESULT_PSIZ] = cur_reg++;
d277 1
d279 5
a283 5
	/* If we're writing back facing colors we need to send
	 * four colors to make front/back face colors selection work.
	 * If the vertex program doesn't write all 4 colors, lets
	 * pretend it does by skipping output index reg so the colors
	 * get written into appropriate output vectors.
d285 26
a310 6
	if (OutputsWritten & (1 << VERT_RESULT_COL0)) {
		c->code->outputs[VERT_RESULT_COL0] = cur_reg++;
	} else if (OutputsWritten & (1 << VERT_RESULT_BFC0) ||
		OutputsWritten & (1 << VERT_RESULT_BFC1)) {
		cur_reg++;
	}
d312 22
a333 5
	if (OutputsWritten & (1 << VERT_RESULT_COL1)) {
		c->code->outputs[VERT_RESULT_COL1] = cur_reg++;
	} else if (OutputsWritten & (1 << VERT_RESULT_BFC0) ||
		OutputsWritten & (1 << VERT_RESULT_BFC1)) {
		cur_reg++;
d335 3
d339 3
a341 5
	if (OutputsWritten & (1 << VERT_RESULT_BFC0)) {
		c->code->outputs[VERT_RESULT_BFC0] = cur_reg++;
	} else if (OutputsWritten & (1 << VERT_RESULT_BFC1)) {
		cur_reg++;
	}
d343 9
a351 5
	if (OutputsWritten & (1 << VERT_RESULT_BFC1)) {
		c->code->outputs[VERT_RESULT_BFC1] = cur_reg++;
	} else if (OutputsWritten & (1 << VERT_RESULT_BFC0)) {
		cur_reg++;
	}
d353 7
a359 4
	for (i = VERT_RESULT_TEX0; i <= VERT_RESULT_TEX7; i++) {
		if (OutputsWritten & (1 << i)) {
			c->code->outputs[i] = cur_reg++;
		}
d362 1
a362 3
	if (OutputsWritten & (1 << VERT_RESULT_FOGC)) {
		c->code->outputs[VERT_RESULT_FOGC] = cur_reg++;
	}
d365 51
a415 7
/**
 * The NV_vertex_program spec mandates that all registers be
 * initialized to zero. We do this here unconditionally.
 *
 * \note We rely on dead-code elimination in the compiler.
 */
static void initialize_NV_registers(struct radeon_compiler * compiler)
d417 20
a436 2
	unsigned int reg;
	struct rc_instruction * inst;
d438 8
a445 24
	for(reg = 0; reg < 12; ++reg) {
		inst = rc_insert_new_instruction(compiler, &compiler->Program.Instructions);
		inst->U.I.Opcode = RC_OPCODE_MOV;
		inst->U.I.DstReg.File = RC_FILE_TEMPORARY;
		inst->U.I.DstReg.Index = reg;
		inst->U.I.SrcReg[0].File = RC_FILE_NONE;
		inst->U.I.SrcReg[0].Swizzle = RC_SWIZZLE_0000;
	}

	inst = rc_insert_new_instruction(compiler, &compiler->Program.Instructions);
	inst->U.I.Opcode = RC_OPCODE_ARL;
	inst->U.I.DstReg.File = RC_FILE_ADDRESS;
	inst->U.I.DstReg.Index = 0;
	inst->U.I.DstReg.WriteMask = WRITEMASK_X;
	inst->U.I.SrcReg[0].File = RC_FILE_NONE;
	inst->U.I.SrcReg[0].Swizzle = RC_SWIZZLE_0000;
}

static struct r300_vertex_program *build_program(struct gl_context *ctx,
						 struct r300_vertex_program_key *wanted_key,
						 const struct gl_vertex_program *mesa_vp)
{
	struct r300_vertex_program *vp;
	struct r300_vertex_program_compiler compiler;
d447 2
a448 23
	vp = calloc(1, sizeof(*vp));
	vp->Base = _mesa_clone_vertex_program(ctx, mesa_vp);
	memcpy(&vp->key, wanted_key, sizeof(vp->key));

        memset(&compiler, 0, sizeof(compiler));
	rc_init(&compiler.Base);
	compiler.Base.Debug = (RADEON_DEBUG & RADEON_VERTS) ? GL_TRUE : GL_FALSE;

	compiler.code = &vp->code;
	compiler.RequiredOutputs = compute_required_outputs(vp->Base, vp->key.FpReads);
	compiler.SetHwInputOutput = &t_inputs_outputs;
	compiler.Base.is_r500 = R300_CONTEXT(ctx)->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515;
	compiler.Base.disable_optimizations = 0;
	compiler.Base.has_half_swizzles = 0;
	compiler.Base.max_temp_regs = 32;
	compiler.Base.max_constants = 256;
	compiler.Base.max_alu_insts = compiler.Base.is_r500 ? 1024 : 256;

	if (compiler.Base.Debug) {
		fprintf(stderr, "Initial vertex program:\n");
		_mesa_print_program(&vp->Base->Base);
		fflush(stderr);
	}
d450 2
a451 3
	if (mesa_vp->IsPositionInvariant) {
		_mesa_insert_mvp_code(ctx, vp->Base);
	}
d453 3
a455 1
	radeon_mesa_to_rc_program(&compiler.Base, &vp->Base->Base);
d457 2
a458 2
	if (mesa_vp->IsNVProgram)
		initialize_NV_registers(&compiler.Base);
d460 3
a462 1
	rc_move_output(&compiler.Base, VERT_RESULT_PSIZ, VERT_RESULT_PSIZ, WRITEMASK_X);
d464 3
a466 2
	if (vp->key.WPosAttr != FRAG_ATTRIB_MAX) {
		unsigned int vp_wpos_attr = vp->key.WPosAttr - FRAG_ATTRIB_TEX0 + VERT_RESULT_TEX0;
d468 2
a469 7
		/* Set empty writemask for instructions writing to vp_wpos_attr
		 * before moving the wpos attr there.
		 * Such instructions will be removed by DCE.
		 */
		rc_move_output(&compiler.Base, vp_wpos_attr, vp->key.WPosAttr, 0);
		rc_copy_output(&compiler.Base, VERT_RESULT_HPOS, vp_wpos_attr);
	}
d471 3
a473 2
	if (vp->key.FogAttr != FRAG_ATTRIB_MAX) {
		unsigned int vp_fog_attr = vp->key.FogAttr - FRAG_ATTRIB_TEX0 + VERT_RESULT_TEX0;
d475 5
a479 7
		/* Set empty writemask for instructions writing to vp_fog_attr
		 * before moving the fog attr there.
		 * Such instructions will be removed by DCE.
		 */
		rc_move_output(&compiler.Base, vp_fog_attr, vp->key.FogAttr, 0);
		rc_move_output(&compiler.Base, VERT_RESULT_FOGC, vp_fog_attr, WRITEMASK_X);
	}
d481 33
a513 1
	r3xx_compile_vertex_program(&compiler);
d515 1
a515 3
	if (vp->code.constants.Count > ctx->Const.VertexProgram.MaxParameters) {
		rc_error(&compiler.Base, "Program exceeds constant buffer size limit\n");
	}
d517 26
a542 1
	vp->error = compiler.Base.Error;
d544 441
a984 2
	vp->Base->Base.InputsRead = vp->code.InputsRead;
	vp->Base->Base.OutputsWritten = vp->code.OutputsWritten;
d986 61
a1046 1
	rc_destroy(&compiler.Base);
d1048 12
a1059 1
	return vp;
d1062 1
a1062 1
struct r300_vertex_program * r300SelectAndTranslateVertexShader(struct gl_context *ctx)
d1064 3
a1066 4
	r300ContextPtr r300 = R300_CONTEXT(ctx);
	struct r300_vertex_program_key wanted_key = { 0 };
	struct r300_vertex_program_cont *vpc;
	struct r300_vertex_program *vp;
d1068 1
a1068 1
	vpc = (struct r300_vertex_program_cont *)ctx->VertexProgram._Current;
d1070 37
a1106 12
	if (!r300->selected_fp) {
		/* This can happen when GetProgramiv is called to check
		 * whether the program runs natively.
		 *
		 * To be honest, this is not a very good solution,
		 * but solving the problem of reporting good values
		 * for those queries is tough anyway considering that
		 * we recompile vertex programs based on the precise
		 * fragment program that is in use.
		 */
		r300SelectAndTranslateFragmentShader(ctx);
	}
d1108 2
a1109 4
	assert(r300->selected_fp);
	wanted_key.FpReads = r300->selected_fp->InputsRead;
	wanted_key.FogAttr = r300->selected_fp->fog_attr;
	wanted_key.WPosAttr = r300->selected_fp->wpos_attr;
d1111 20
a1130 3
	for (vp = vpc->progs; vp; vp = vp->next) {
		if (memcmp(&vp->key, &wanted_key, sizeof(wanted_key)) == 0) {
			return r300->selected_vp = vp;
d1132 1
d1135 61
a1195 3
	vp = build_program(ctx, &wanted_key, &vpc->mesa_program);
	vp->next = vpc->progs;
	vpc->progs = vp;
d1197 1
a1197 1
	return r300->selected_vp = vp;
d1200 17
a1216 5
#define bump_vpu_count(ptr, new_count)   do { \
		drm_r300_cmd_header_t* _p=((drm_r300_cmd_header_t*)(ptr)); \
		int _nc=(new_count)/4; \
		if(_nc>_p->vpu.count)_p->vpu.count=_nc; \
	} while(0)
d1218 3
a1220 1
static void r300EmitVertexProgram(r300ContextPtr r300, int dest, struct r300_vertex_program_code *code)
d1222 4
a1225 1
	int i;
d1227 1
a1227 1
	assert((code->length > 0) && (code->length % 4 == 0));
d1229 2
a1230 22
	switch ((dest >> 8) & 0xf) {
		case 0:
			R300_STATECHANGE(r300, vpi);
			for (i = 0; i < code->length; i++)
				r300->hw.vpi.cmd[R300_VPI_INSTR_0 + i + 4 * (dest & 0xff)] = (code->body.d[i]);
			bump_vpu_count(r300->hw.vpi.cmd, code->length + 4 * (dest & 0xff));
			break;
		case 2:
			R300_STATECHANGE(r300, vpp);
			for (i = 0; i < code->length; i++)
				r300->hw.vpp.cmd[R300_VPP_PARAM_0 + i + 4 * (dest & 0xff)] = (code->body.d[i]);
			bump_vpu_count(r300->hw.vpp.cmd, code->length + 4 * (dest & 0xff));
			break;
		case 4:
			R300_STATECHANGE(r300, vps);
			for (i = 0; i < code->length; i++)
				r300->hw.vps.cmd[1 + i + 4 * (dest & 0xff)] = (code->body.d[i]);
			bump_vpu_count(r300->hw.vps.cmd, code->length + 4 * (dest & 0xff));
			break;
		default:
			fprintf(stderr, "%s:%s don't know how to handle dest %04x\n", __FILE__, __FUNCTION__, dest);
			exit(-1);
d1232 11
d1245 1
a1245 1
void r300SetupVertexProgram(r300ContextPtr rmesa)
d1247 12
a1258 4
	struct gl_context *ctx = rmesa->radeon.glCtx;
	struct r300_vertex_program *prog = rmesa->selected_vp;
	int inst_count = 0;
	int param_count = 0;
d1260 10
a1269 4
	/* Reset state, in case we don't use something */
	((drm_r300_cmd_header_t *) rmesa->hw.vpp.cmd)->vpu.count = 0;
	((drm_r300_cmd_header_t *) rmesa->hw.vpi.cmd)->vpu.count = 0;
	((drm_r300_cmd_header_t *) rmesa->hw.vps.cmd)->vpu.count = 0;
d1271 2
a1272 5
	R300_STATECHANGE(rmesa, vap_cntl);
	R300_STATECHANGE(rmesa, vpp);
	param_count = r300VertexProgUpdateParams(ctx, prog, (float *)&rmesa->hw.vpp.cmd[R300_VPP_PARAM_0]);
	if (!rmesa->radeon.radeonScreen->kernel_mm && param_count > 255 * 4) {
		WARN_ONCE("Too many VP params, expect rendering errors\n");
a1273 3
	/* Prevent the overflow (vpu.count is u8) */
	bump_vpu_count(rmesa->hw.vpp.cmd, MIN2(255 * 4, param_count));
	param_count /= 4;
d1275 2
a1276 2
	r300EmitVertexProgram(rmesa, R300_PVS_CODE_START, &(prog->code));
	inst_count = (prog->code.length / 4) - 1;
d1278 3
a1280 2
	r300VapCntl(rmesa, _mesa_bitcount(prog->code.InputsRead),
				 _mesa_bitcount(prog->code.OutputsWritten), prog->code.num_temporaries);
d1282 10
a1291 3
	R300_STATECHANGE(rmesa, pvs);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_1] = (0 << R300_PVS_FIRST_INST_SHIFT) | (inst_count << R300_PVS_XYZW_VALID_INST_SHIFT) |
				(inst_count << R300_PVS_LAST_INST_SHIFT);
d1293 12
a1304 2
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_2] = (0 << R300_PVS_CONST_BASE_OFFSET_SHIFT) | ((param_count - 1) << R300_PVS_MAX_CONST_ADDR_SHIFT);
	rmesa->hw.pvs.cmd[R300_PVS_CNTL_3] = (inst_count << R300_PVS_LAST_VTX_SRC_INST_SHIFT);
@

